{
    "hands_on_practices": [
        {
            "introduction": "A primary goal in studying percolation is to determine whether a system-spanning connection exists. This exercise provides a foundational hands-on task: applying a cluster labeling algorithm to a 2D lattice to identify all clusters that bridge the system from left to right. By marking and counting the sites belonging to these spanning clusters, you will practice a core skill required for measuring the percolation probability and analyzing the properties of the infinite cluster .",
            "id": "2380626",
            "problem": "Consider site percolation on a finite rectangular lattice represented by a binary matrix with $N$ rows and $M$ columns. Each site $(i,j)$, with $i \\in \\{0,1,\\dots,N-1\\}$ and $j \\in \\{0,1,\\dots,M-1\\}$, is either occupied (encoded as $1$) or empty (encoded as $0$). Two occupied sites are connected if and only if they are nearest neighbors in the horizontal or vertical direction. A cluster is a maximal set of occupied sites that are mutually connected under this rule. Define the left boundary as the set of sites in column index $0$ and the right boundary as the set of sites in column index $M-1$. A cluster is said to bridge horizontally if it contains at least one site on the left boundary and at least one site on the right boundary. Define the marked set as the set of all occupied sites that belong to any horizontally bridging cluster. For each test case below, compute the total number of marked sites.\n\nYour program must produce a single line of output containing the results for all test cases in order, formatted as a comma-separated list enclosed in square brackets. For example, if the results are $a_1,a_2,\\dots,a_k$, the output must be exactly \"[a_1,a_2,\\dots,a_k]\".\n\nTest Suite:\n\n- Case A ($N=5$, $M=5$): The lattice $L_A$ is given row-by-row as\n  Row $0$: [$1$, $1$, $0$, $0$, $0$]\n  Row $1$: [$0$, $1$, $1$, $0$, $0$]\n  Row $2$: [$0$, $0$, $1$, $1$, $1$]\n  Row $3$: [$1$, $0$, $0$, $0$, $1$]\n  Row $4$: [$0$, $0$, $0$, $0$, $1$]\n  Compute the total number of marked sites in $L_A$.\n\n- Case B ($N=5$, $M=5$): The lattice $L_B$ is given row-by-row as\n  Row $0$: [$0$, $0$, $0$, $0$, $0$]\n  Row $1$: [$1$, $1$, $1$, $1$, $1$]\n  Row $2$: [$0$, $0$, $0$, $0$, $0$]\n  Row $3$: [$1$, $1$, $1$, $1$, $1$]\n  Row $4$: [$0$, $0$, $0$, $0$, $0$]\n  Compute the total number of marked sites in $L_B$.\n\n- Case C ($N=4$, $M=4$): The lattice $L_C$ is given row-by-row as\n  Row $0$: [$1$, $0$, $0$, $0$]\n  Row $1$: [$1$, $1$, $0$, $0$]\n  Row $2$: [$0$, $1$, $0$, $1$]\n  Row $3$: [$0$, $0$, $1$, $1$]\n  Compute the total number of marked sites in $L_C$.\n\n- Case D ($N=4$, $M=1$): The lattice $L_D$ is given row-by-row as\n  Row $0$: [$1$]\n  Row $1$: [$0$]\n  Row $2$: [$1$]\n  Row $3$: [$1$]\n  Compute the total number of marked sites in $L_D$.\n\n- Case E ($N=6$, $M=6$): The lattice $L_E$ is given row-by-row as\n  Row $0$: [$1$, $0$, $0$, $0$, $0$, $1$]\n  Row $1$: [$1$, $1$, $1$, $1$, $1$, $1$]\n  Row $2$: [$0$, $0$, $1$, $0$, $0$, $0$]\n  Row $3$: [$1$, $0$, $1$, $1$, $1$, $0$]\n  Row $4$: [$1$, $0$, $0$, $0$, $1$, $1$]\n  Row $5$: [$0$, $0$, $0$, $0$, $0$, $1$]\n  Compute the total number of marked sites in $L_E$.\n\nFinal Output Format:\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the order A, B, C, D, E, i.e., \"[$r_A$,$r_B$,$r_C$,$r_D$,$r_E$]\" where each $r_X$ is the total number of marked sites for the corresponding case.",
            "solution": "The problem statement has been rigorously validated and is determined to be valid. It is a well-posed problem in computational physics, specifically concerning site percolation on a two-dimensional lattice. The definitions are precise, the data is complete, and the objective is unambiguous. Therefore, a complete solution is presented.\n\nThe problem is to compute the total number of sites belonging to horizontally bridging clusters on a rectangular lattice. A lattice is given as a binary matrix $L$ of size $N \\times M$, where $1$ denotes an occupied site and $0$ an empty site.\n\nFirst, we formalize the definitions.\n1.  **Lattice and Sites**: The system is a grid of sites $(i, j)$ where $i \\in \\{0, 1, \\dots, N-1\\}$ and $j \\in \\{0, 1, \\dots, M-1\\}$.\n2.  **Connectivity**: Two occupied sites $(i, j)$ and $(i', j')$ are connected if they are nearest neighbors, which for a two-dimensional grid implies $|i - i'| + |j - j'| = 1$. This is the von Neumann neighborhood.\n3.  **Cluster**: A cluster $C$ is a maximal set of occupied sites where any two sites in $C$ are connected to each other through a path of connected occupied sites, and no site in $C$ is connected to any occupied site outside of $C$.\n4.  **Bridging Condition**: A cluster $C$ is defined as horizontally bridging if it simultaneously contains a site on the left boundary and a site on the right boundary. Mathematically, this means:\n    $$ (\\exists (i, j) \\in C \\text{ such that } j=0) \\land (\\exists (i', j') \\in C \\text{ such that } j'=M-1) $$\n5.  **Marked Set**: The marked set is the union of all horizontally bridging clusters. The objective is to find the cardinality of this set.\n\nThe problem is fundamentally one of connected-component labeling on a grid. A standard and highly efficient algorithm for this task is available in many scientific computing libraries. We will use the `scipy.ndimage.label` function, which implements such an algorithm.\n\nThe solution proceeds in the following steps:\n\n1.  **Component Labeling**: Given the input lattice matrix $L$, we first identify all distinct clusters. The function `scipy.ndimage.label` is applied to $L$. We must specify a structuring element that defines the $4$-connectivity (von Neumann neighborhood). This function returns a new matrix, let's call it $L_{\\text{labeled}}$, of the same dimensions $N \\times M$. In $L_{\\text{labeled}}$, all sites belonging to the same cluster are assigned a unique positive integer label, while empty sites retain the value $0$.\n\n2.  **Identify Boundary-Touching Clusters**: We need to find which clusters touch the left and right boundaries.\n    - The set of labels for clusters touching the left boundary, $S_{\\text{left}}$, is obtained by finding all unique non-zero values in the first column ($j=0$) of $L_{\\text{labeled}}$.\n    - The set of labels for clusters touching the right boundary, $S_{\\text{right}}$, is obtained by finding all unique non-zero values in the last column ($j=M-1$) of $L_{\\text{labeled}}$.\n\n3.  **Identify Bridging Clusters**: A cluster is bridging if it touches both boundaries. Therefore, the set of labels for all bridging clusters, $S_{\\text{bridge}}$, is the intersection of the two sets identified in the previous step:\n    $$ S_{\\text{bridge}} = S_{\\text{left}} \\cap S_{\\text{right}} $$\n\n4.  **Calculate Total Marked Sites**: The marked set consists of all sites belonging to clusters whose labels are in $S_{\\text{bridge}}$. The total count of such sites is the final answer. This can be computed efficiently by creating a boolean mask indicating which sites in $L_{\\text{labeled}}$ have a label present in $S_{\\text{bridge}}$, and then summing the true values in this mask. This is equivalent to summing the sizes of all clusters in $S_{\\text{bridge}}$:\n    $$ \\text{Total Marked Sites} = \\sum_{k \\in S_{\\text{bridge}}} \\left| \\{ (i,j) : L_{\\text{labeled}}[i,j] = k \\} \\right| $$\n\nThis method is robust and correctly handles all given test cases, including the edge case where the lattice width $M=1$. In this special case, the left and right boundaries are identical (column $0$), so any cluster is trivially bridging. The algorithm handles this correctly as $S_{\\text{left}}$ and $S_{\\text{right}}$ will be identical, and their intersection will contain the labels of all clusters present on the lattice.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import ndimage\n\ndef solve():\n    \"\"\"\n    Main function to solve the percolation problem for all test cases.\n    \"\"\"\n\n    def calculate_marked_sites(lattice: np.ndarray) -> int:\n        \"\"\"\n        Calculates the total number of marked sites in a given lattice.\n\n        A marked site is an occupied site that belongs to a horizontally\n        bridging cluster.\n\n        Args:\n            lattice: A 2D numpy array representing the percolation grid,\n                     with 1 for occupied and 0 for empty sites.\n\n        Returns:\n            The total number of marked sites.\n        \"\"\"\n        if lattice.size == 0:\n            return 0\n            \n        n_rows, n_cols = lattice.shape\n\n        # Define 4-connectivity (von Neumann neighborhood)\n        # [[0,1,0],\n        #  [1,1,1],\n        #  [0,1,0]]\n        structure = ndimage.generate_binary_structure(2, 1)\n\n        # Label all connected components (clusters) of occupied sites\n        labeled_matrix, num_clusters = ndimage.label(lattice, structure=structure)\n\n        if num_clusters == 0:\n            return 0\n\n        # Identify labels of clusters touching the left boundary (j=0)\n        left_labels = set(np.unique(labeled_matrix[:, 0]))\n        \n        # Identify labels of clusters touching the right boundary (j=M-1)\n        # Note: for M=1, [:, -1] is the same as [:, 0]\n        right_labels = set(np.unique(labeled_matrix[:, -1]))\n\n        # The background label is 0, which we must exclude from cluster sets\n        left_labels.discard(0)\n        right_labels.discard(0)\n\n        # Bridging clusters are those that touch both left and right boundaries\n        bridging_labels = left_labels.intersection(right_labels)\n\n        if not bridging_labels:\n            return 0\n\n        # An efficient way to count all sites in bridging clusters:\n        # Create a boolean mask where True corresponds to a site belonging\n        # to any bridging cluster. Then sum the mask.\n        is_in_bridging_cluster = np.isin(labeled_matrix, list(bridging_labels))\n        total_marked_sites = np.sum(is_in_bridging_cluster)\n\n        return int(total_marked_sites)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (N=5, M=5)\n        np.array([\n            [1, 1, 0, 0, 0],\n            [0, 1, 1, 0, 0],\n            [0, 0, 1, 1, 1],\n            [1, 0, 0, 0, 1],\n            [0, 0, 0, 0, 1]\n        ]),\n        # Case B (N=5, M=5)\n        np.array([\n            [0, 0, 0, 0, 0],\n            [1, 1, 1, 1, 1],\n            [0, 0, 0, 0, 0],\n            [1, 1, 1, 1, 1],\n            [0, 0, 0, 0, 0]\n        ]),\n        # Case C (N=4, M=4)\n        np.array([\n            [1, 0, 0, 0],\n            [1, 1, 0, 0],\n            [0, 1, 0, 1],\n            [0, 0, 1, 1]\n        ]),\n        # Case D (N=4, M=1)\n        np.array([\n            [1],\n            [0],\n            [1],\n            [1]\n        ]),\n        # Case E (N=6, M=6)\n        np.array([\n            [1, 0, 0, 0, 0, 1],\n            [1, 1, 1, 1, 1, 1],\n            [0, 0, 1, 0, 0, 0],\n            [1, 0, 1, 1, 1, 0],\n            [1, 0, 0, 0, 1, 1],\n            [0, 0, 0, 0, 0, 1]\n        ]),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_marked_sites(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Once a spanning cluster is identified, a deeper question arises about its internal structure: which parts are essential for the connection? This practice explores the concept of the \"backbone,\" the load-bearing core of a cluster, by computationally removing the \"dangling ends.\" Mastering this iterative pruning technique  is crucial for understanding transport phenomena, like electrical conductivity, on percolating networks.",
            "id": "2380623",
            "problem": "Consider site percolation on a finite two-dimensional (2D) square lattice with nearest-neighbor connectivity. Each lattice site has an occupation variable $n_{ij} \\in \\{0,1\\}$, where $n_{ij} = 1$ denotes an occupied site at row $i$ and column $j$, and $n_{ij} = 0$ denotes an empty site. Two occupied sites are connected if they differ by exactly one in either row or column index (that is, $4$-neighbor connectivity). A cluster is a maximal connected set of occupied sites.\n\nYour task is to implement, from first principles, a complete computational procedure that:\n- Labels all clusters of occupied sites using a consistent connected-components labeling scheme grounded in the definition of connectivity above (for example, by scanning the lattice and merging label equivalences using a disjoint-set data structure, also known as Union–Find).\n- Determines whether there exists at least one cluster that connects the top boundary (row $0$) to the bottom boundary (row $L-1$), where $L$ is the linear size of the lattice.\n- For the percolating cluster(s), computes the backbone by identifying and removing all dangling ends after the initial labeling. Define the backbone as the set of occupied sites in the percolating cluster that remain after iteratively removing all non-terminal sites of graph degree $1$ within the subgraph induced by the percolating cluster, where terminals are defined as all occupied sites in that subgraph that lie on the top or bottom boundary. The iteration continues until no such non-terminal leaves remain. If more than one distinct labeled cluster independently connects the top and bottom boundaries, treat the percolating set as the union of these clusters when computing the backbone.\n\nFundamental base you may assume:\n- The graph-theoretic definition of connected components on a lattice induced by $4$-neighbor adjacency.\n- The correctness of the disjoint-set (Union–Find) data structure for maintaining and merging equivalence classes during a single pass over the lattice.\n- The correctness of iterative pruning of degree-$1$ nodes (excluding designated terminals) for computing the two-terminal $2$-core.\n\nYour program must be self-contained, take no input, and apply the above procedure to the following test suite. Each test case is specified as an explicit binary matrix $A$ of size $L \\times L$ with entries in $\\{0,1\\}$, given as lists of lists with each entry shown. Interpret each $A$ as $n_{ij}$ with the first list being row $0$ (top). For each case, you must determine a boolean indicating whether a top-to-bottom percolation exists, and an integer equal to the backbone size, which is defined to be $0$ if there is no top-to-bottom percolation.\n\nTest Suite:\n- Case $1$ ($L=5$):\n  $A_1 =$\n  [\n  [1,1,0,0,0],\n  [0,1,0,1,1],\n  [0,0,0,1,0],\n  [1,0,0,1,0],\n  [1,1,0,0,0]\n  ].\n- Case $2$ ($L=6$): a single vertical percolating path with side branches (dangling ends).\n  $A_2 =$\n  [\n  [0,0,1,0,0,0],\n  [0,0,1,0,0,0],\n  [1,1,1,0,0,0],\n  [0,0,1,0,0,0],\n  [0,0,1,1,1,0],\n  [0,0,1,0,0,0]\n  ].\n- Case $3$ ($L=5$): two parallel vertical rails connected by a single rung (an “H” shape), which percolates from top to bottom.\n  $A_3 =$\n  [\n  [0,1,0,1,0],\n  [0,1,0,1,0],\n  [0,1,1,1,0],\n  [0,1,0,1,0],\n  [0,1,0,1,0]\n  ].\n- Case $4$ ($L=4$): a fully occupied lattice.\n  $A_4 =$\n  [\n  [1,1,1,1],\n  [1,1,1,1],\n  [1,1,1,1],\n  [1,1,1,1]\n  ].\n- Case $5$ ($L=5$): a horizontal band that does not percolate top-to-bottom.\n  $A_5 =$\n  [\n  [0,0,0,0,0],\n  [0,0,0,0,0],\n  [1,1,1,1,1],\n  [0,0,0,0,0],\n  [0,0,0,0,0]\n  ].\n\nAngle units and physical units are not applicable. All requested outputs are unitless.\n\nYour program must produce, for the five cases above in order, a single line of output containing the results as a comma-separated list enclosed in square brackets, where each item is itself a two-element list $[b, s]$ with $b$ a boolean (True if there is a top-to-bottom percolating cluster, False otherwise) and $s$ the integer backbone size as defined above. For example, a valid output format for three hypothetical cases would be [[True, 5], [False, 0], [True, 8]]. Your actual output must be a single line exactly matching the five computed results for the specified test suite.",
            "solution": "The problem statement is a valid, well-posed computational exercise grounded in the principles of statistical physics, specifically percolation theory. It requests the implementation of a standard procedure for cluster analysis on a two-dimensional lattice. The task is to identify clusters, determine top-to-bottom percolation, and compute the size of the percolating backbone. The definitions, constraints, and test cases are clear, complete, and scientifically sound. No invalidating flaws are present.\n\nThe solution is constructed as a three-step computational procedure applied to each given lattice configuration $A$.\n\n**Step 1: Cluster Labeling using a Disjoint-Set Algorithm**\n\nThe first step is to partition the set of all occupied sites into disjoint clusters. A cluster is a maximal set of connected occupied sites, where connectivity is defined by the $4$-neighbor adjacency rule. The Hoshen-Kopelman algorithm, which is based on a Disjoint-Set Union (DSU) or Union-Find data structure, is an efficient method for this task.\n\nThe procedure is as follows:\n$1$. A labels matrix, `labels`, of the same dimensions $L \\times L$ as the input lattice $A$, is initialized with zeros. A DSU data structure, which maintains a collection of disjoint sets, is also initialized. Each set will correspond to a cluster, and we will use integer labels to identify them.\n\n$2$. The lattice is scanned site-by-site, for instance, from row $i=0$ to $L-1$ and for each row from column $j=0$ to $L-1$.\n\n$3$. At each site $(i,j)$, if it is empty ($n_{ij}=0$), we proceed to the next site. If the site is occupied ($n_{ij}=1$), we examine its already scanned neighbors: the site above, $(i-1, j)$, and the site to the left, $(i, j-1)$.\n    - If neither of these neighbors is occupied, the site $(i,j)$ is considered the start of a new cluster. It is assigned a new, unique label, and a new set containing this label is created in the DSU structure.\n    - If exactly one of these neighbors is occupied, the site $(i,j)$ belongs to the same cluster as that neighbor. It is assigned the label of that neighbor.\n    - If both neighbors are occupied, the site $(i,j)$ connects their respective clusters. It is assigned the label of one of them (e.g., the top neighbor). The crucial step is to merge the sets of the two neighbors' labels using the `union` operation of the DSU data structure. This records the fact that the two formerly separate clusters are, in fact, part of the same larger cluster.\n\n$4$. After this single pass, the `labels` matrix may contain different labels for sites that belong to the same cluster. A second pass over the `labels` matrix is performed. For each site $(i,j)$ with a non-zero label $k$, its label is replaced by the canonical representative of its set, found using the DSU's `find` operation, `find(k)`. This ensures that all sites within a single physical cluster are marked with the same unique integer label.\n\n**Step 2: Percolation Detection**\n\nWith all clusters consistently labeled, we can determine if any cluster percolates from the top boundary (row $i=0$) to the bottom boundary (row $i=L-1$).\n\n$1$. We construct two sets of labels. The first set, $\\mathcal{L}_{\\text{top}}$, contains all unique cluster labels found on the top row ($i=0$) of the lattice. The second set, $\\mathcal{L}_{\\text{bottom}}$, contains all unique cluster labels on the bottom row ($i=L-1$).\n\n$2$. The set of percolating cluster labels, $\\mathcal{L}_p$, is the intersection of these two sets: $\\mathcal{L}_p = \\mathcal{L}_{\\text{top}} \\cap \\mathcal{L}_{\\text{bottom}}$.\n\n$3$. If $\\mathcal{L}_p$ is empty, no cluster spans the lattice from top to bottom. In this case, percolation does not occur, and by the problem's definition, the backbone size is $0$. If $\\mathcal{L}_p$ is non-empty, percolation has occurred.\n\n**Step 3: Backbone Identification and Sizing**\n\nIf percolation is established, we proceed to compute the backbone of the percolating cluster(s). The backbone is the subset of the percolating cluster that is robust against the removal of \"dangling ends.\"\n\n$1$. The percolating set, $S_p$, is defined as the union of all sites belonging to clusters whose labels are in $\\mathcal{L}_p$.\n\n$2$. Within this set $S_p$, we identify the terminal sites, $T$. A site is a terminal if it belongs to $S_p$ and is located on either the top boundary ($i=0$) or the bottom boundary ($i=L-1$). These sites are the anchors of the percolating path and are protected from removal.\n\n$3$. The backbone is found by an iterative pruning process. In each iteration, we identify all non-terminal sites ($s \\in S_p \\setminus T$) that have a degree of $1$. The degree of a site, $\\text{deg}_{S_p}(s)$, is the number of its $4$-neighbors that are also in the current percolating set $S_p$. These degree-$1$ non-terminal sites are the \"dangling ends.\"\n\n$4$. All such identified sites are removed from $S_p$. This process is repeated—calculating degrees in the newly reduced set and removing new dangling ends—until an iteration occurs where no sites are removed. At this point, the process has converged.\n\n$5$. The remaining set of sites constitutes the backbone. Its size is simply the number of sites in this final set.\n\nThis three-step procedure provides a complete and deterministic algorithm to solve the problem for any given lattice configuration.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to process all test cases and print the final output.\n    \"\"\"\n\n    class UnionFind:\n        \"\"\"\n        A simple Union-Find data structure for tracking cluster equivalences.\n        Uses a dictionary for the parent mapping to dynamically add new labels.\n        Path compression is implemented in the find method.\n        \"\"\"\n        def __init__(self):\n            self.parent = {}\n\n        def find(self, i):\n            if i not in self.parent:\n                self.parent[i] = i\n                return i\n            \n            if self.parent[i] == i:\n                return i\n            \n            # Path compression\n            self.parent[i] = self.find(self.parent[i])\n            return self.parent[i]\n\n        def union(self, i, j):\n            root_i = self.find(i)\n            root_j = self.find(j)\n            if root_i != root_j:\n                self.parent[root_j] = root_i\n\n    def analyze_lattice(grid: np.ndarray):\n        \"\"\"\n        Analyzes a given lattice grid for percolation and backbone size.\n\n        Args:\n            grid: A 2D numpy array of 0s and 1s representing the lattice.\n\n        Returns:\n            A tuple (bool, int) where the bool indicates top-to-bottom percolation\n            and the int is the size of the backbone.\n        \"\"\"\n        L = grid.shape[0]\n        if L == 0:\n            return (False, 0)\n            \n        labels = np.zeros_like(grid, dtype=int)\n        uf = UnionFind()\n        next_label = 1\n\n        # Step 1: Cluster Labeling (Hoshen-Kopelman algorithm)\n        for i in range(L):\n            for j in range(L):\n                if grid[i, j] == 1:\n                    # Get labels of occupied neighbors (top and left)\n                    top_neighbor_label = labels[i - 1, j] if i > 0 and grid[i-1, j] == 1 else 0\n                    left_neighbor_label = labels[i, j - 1] if j > 0 and grid[i, j-1] == 1 else 0\n\n                    if top_neighbor_label == 0 and left_neighbor_label == 0:\n                        # New cluster\n                        labels[i, j] = next_label\n                        uf.find(next_label) # Initialize set for the new label\n                        next_label += 1\n                    elif top_neighbor_label != 0 and left_neighbor_label == 0:\n                        # Part of top neighbor's cluster\n                        labels[i, j] = top_neighbor_label\n                    elif top_neighbor_label == 0 and left_neighbor_label != 0:\n                        # Part of left neighbor's cluster\n                        labels[i, j] = left_neighbor_label\n                    else:\n                        # Both neighbors are occupied, merge clusters\n                        labels[i, j] = top_neighbor_label\n                        uf.union(top_neighbor_label, left_neighbor_label)\n\n        # Second pass to resolve all labels to their root\n        for i in range(L):\n            for j in range(L):\n                if labels[i, j] != 0:\n                    labels[i, j] = uf.find(labels[i, j])\n\n        # Step 2: Percolation Check\n        top_labels = set(labels[0, :][grid[0, :] == 1])\n        bottom_labels = set(labels[L - 1, :][grid[L - 1, :] == 1])\n\n        percolating_labels = top_labels.intersection(bottom_labels)\n\n        if not percolating_labels:\n            return (False, 0)\n\n        # Step 3: Backbone Calculation\n        percolating_mask = np.isin(labels, list(percolating_labels))\n        terminals_mask = np.zeros_like(grid, dtype=bool)\n        terminals_mask[0, :] = percolating_mask[0, :]\n        terminals_mask[L-1, :] = percolating_mask[L-1, :]\n\n        while True:\n            to_prune = []\n            # Find occupied, non-terminal sites\n            non_terminals = np.argwhere(percolating_mask  ~terminals_mask)\n            \n            for i, j in non_terminals:\n                degree = 0\n                # Check 4-neighbors\n                if i > 0 and percolating_mask[i-1, j]: degree += 1\n                if i  L-1 and percolating_mask[i+1, j]: degree += 1\n                if j > 0 and percolating_mask[i, j-1]: degree += 1\n                if j  L-1 and percolating_mask[i, j+1]: degree += 1\n                \n                if degree == 1:\n                    to_prune.append((i,j))\n            \n            if not to_prune:\n                break # No more sites to prune, backbone is stable\n\n            for i, j in to_prune:\n                percolating_mask[i, j] = False\n        \n        backbone_size = np.sum(percolating_mask)\n        return (True, int(backbone_size))\n\n    # --- Test Suite ---\n    test_cases = [\n        np.array([\n            [1,1,0,0,0],\n            [0,1,0,1,1],\n            [0,0,0,1,0],\n            [1,0,0,1,0],\n            [1,1,0,0,0]\n        ]),\n        np.array([\n            [0,0,1,0,0,0],\n            [0,0,1,0,0,0],\n            [1,1,1,0,0,0],\n            [0,0,1,0,0,0],\n            [0,0,1,1,1,0],\n            [0,0,1,0,0,0]\n        ]),\n        np.array([\n            [0,1,0,1,0],\n            [0,1,0,1,0],\n            [0,1,1,1,0],\n            [0,1,0,1,0],\n            [0,1,0,1,0]\n        ]),\n        np.array([\n            [1,1,1,1],\n            [1,1,1,1],\n            [1,1,1,1],\n            [1,1,1,1]\n        ]),\n        np.array([\n            [0,0,0,0,0],\n            [0,0,0,0,0],\n            [1,1,1,1,1],\n            [0,0,0,0,0],\n            [0,0,0,0,0]\n        ]),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = analyze_lattice(case)\n        results.append(list(result)) # Convert tuple to list for output format\n\n    # Final print statement in the exact required format without spaces\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```"
        },
        {
            "introduction": "Percolation clusters are famous for their complex, fractal geometry. This final exercise introduces a powerful tool from physics to quantify the shape of these clusters: the gyration tensor, $G$. By calculating the eigenvalues of this tensor, you can measure a cluster's anisotropy, distinguishing between stringy, one-dimensional structures and more compact, isotropic shapes . This practice provides a bridge from simple cluster identification to the advanced geometric characterization of critical phenomena.",
            "id": "2380616",
            "problem": "Consider independent site percolation on a finite square lattice. Let $L \\in \\mathbb{N}$ denote the linear size of the lattice, with sites indexed by integer coordinates $(x,y)$ where $x \\in \\{0,1,\\dots,L-1\\}$ and $y \\in \\{0,1,\\dots,L-1\\}$. Let $p \\in [0,1]$ be the occupation probability. A pseudorandom generator seeded by an integer $s$ independently occupies each site with probability $p$, producing a binary field $n(x,y) \\in \\{0,1\\}$. Two occupied sites are connected if and only if they are nearest neighbors horizontally or vertically (that is, at Manhattan distance $1$). A cluster is a maximal set of occupied sites that are pairwise connected by such nearest-neighbor steps. Open boundary conditions are used.\n\nFor a cluster comprising $n \\ge 1$ occupied sites with coordinates $\\{(x_i,y_i)\\}_{i=1}^n$, define the center of mass\n$$\n\\mathbf{r}_{\\mathrm{cm}} = \\frac{1}{n} \\sum_{i=1}^{n} \\begin{bmatrix} x_i \\\\ y_i \\end{bmatrix},\n$$\nand the $2 \\times 2$ gyration tensor\n$$\nG = \\sum_{i=1}^{n} \\left( \\begin{bmatrix} x_i \\\\ y_i \\end{bmatrix} - \\mathbf{r}_{\\mathrm{cm}} \\right) \\left( \\begin{bmatrix} x_i \\\\ y_i \\end{bmatrix} - \\mathbf{r}_{\\mathrm{cm}} \\right)^{\\!\\top}.\n$$\nLet $\\lambda_{\\max}$ and $\\lambda_{\\min}$ denote the larger and smaller eigenvalues of $G$, respectively, so that $\\lambda_{\\max} \\ge \\lambda_{\\min} \\ge 0$. For each cluster with $n \\ge 3$ and $\\lambda_{\\min} > 0$, define the shape anisotropy ratio\n$$\nR = \\frac{\\lambda_{\\max}}{\\lambda_{\\min}}.\n$$\nClusters with $n  3$ or with $\\lambda_{\\min} = 0$ are excluded from the list of ratios.\n\nImplement a program that, for each specified test case $(L,p,s)$, generates one percolation configuration, identifies all clusters under the connectivity definition above, computes the list of shape anisotropy ratios $\\{R\\}$ over all clusters that satisfy the inclusion criteria, sorts this list in nondecreasing order, and rounds each $R$ to $6$ decimal places.\n\nUse the following test suite:\n- Test $1$: $L=4$, $p=0$, $s=42$.\n- Test $2$: $L=4$, $p=1$, $s=0$.\n- Test $3$: $L=8$, $p=0.5$, $s=12345$.\n- Test $4$: $L=12$, $p=0.592746$, $s=777$.\n- Test $5$: $L=6$, $p=0.3$, $s=2024$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each entry is itself a bracketed, comma-separated list of the rounded ratios for that test case, in the same order as the test suite (for example, `[[],[1.000000],...]`). No additional text should be printed.",
            "solution": "The problem requires the computation of shape anisotropy ratios for clusters in a site percolation model on a two-dimensional square lattice. The problem statement is rigorously defined, scientifically sound, and computationally tractable. It is therefore deemed valid. The solution proceeds according to the following systematic method.\n\nFirst, the percolation configuration is generated. For a given lattice of size $L \\times L$, occupation probability $p \\in [0,1]$, and seed $s \\in \\mathbb{N}$, a pseudorandom number generator is initialized. An $L \\times L$ grid is populated with values from a uniform distribution on $[0,1]$. Each site $(x,y)$, where $x, y \\in \\{0,1,\\dots,L-1\\}$, is considered occupied, $n(x,y)=1$, if its corresponding random value is less than $p$; otherwise, it is unoccupied, $n(x,y)=0$. The use of a fixed seed $s$ ensures the complete reproducibility of the configuration, making the problem deterministic.\n\nSecond, clusters of connected occupied sites are identified. A cluster is defined as a maximal set of occupied sites connected by paths of nearest neighbors, where neighbors are adjacent horizontally or vertically. This is a standard connected-components labeling problem. For algorithmic efficiency and clarity, we employ the `scipy.ndimage.label` function. This function requires a structuring element to define connectivity; we specify a kernel that represents $4$-connectivity, corresponding to the problem's definition of neighbors at Manhattan distance $1$. This process partitions the set of all occupied sites into disjoint clusters and assigns a unique integer label to each.\n\nThird, each identified cluster is analyzed for its geometric properties, subject to specific inclusion criteria. The analysis is restricted to clusters with size $n \\ge 3$. For each qualifying cluster, defined by its set of $n$ site coordinates $\\{(x_i, y_i)\\}_{i=1}^n$, we compute the center of mass $\\mathbf{r}_{\\mathrm{cm}}$ and the gyration tensor $G$. The center of mass is the arithmetic mean of the site coordinates:\n$$\n\\mathbf{r}_{\\mathrm{cm}} = \\frac{1}{n} \\sum_{i=1}^{n} \\begin{bmatrix} x_i \\\\ y_i \\end{bmatrix}\n$$\nThe gyration tensor $G$, a $2 \\times 2$ real symmetric matrix, is then computed:\n$$\nG = \\sum_{i=1}^{n} \\left( \\mathbf{r}_i - \\mathbf{r}_{\\mathrm{cm}} \\right) \\left( \\mathbf{r}_i - \\mathbf{r}_{\\mathrm{cm}} \\right)^{\\!\\top}\n$$\nwhere $\\mathbf{r}_i = [x_i, y_i]^\\top$. This tensor is the discrete analogue of the moment of inertia tensor and fundamentally characterizes the spatial distribution of the cluster's mass (sites) around its center. Its eigenvalues, $\\lambda_{\\max}$ and $\\lambda_{\\min}$, are the squared principal radii of gyration and quantify the cluster's spatial extent along its principal axes. A second inclusion criterion, $\\lambda_{\\min} > 0$, is applied. This condition is crucial as it excludes degenerate, one-dimensional clusters where all sites are perfectly collinear. For such structures, the set of vectors $\\{\\mathbf{r}_i - \\mathbf{r}_{\\mathrm{cm}}\\}$ spans only a $1$-dimensional subspace, causing the gyration tensor to be rank-deficient, which results in $\\lambda_{\\min} = 0$ and an undefined anisotropy ratio.\n\nFor all non-degenerate clusters satisfying both $n \\ge 3$ and $\\lambda_{\\min} > 0$, the shape anisotropy ratio is calculated as:\n$$\nR = \\frac{\\lambda_{\\max}}{\\lambda_{\\min}}\n$$\nA value of $R=1$ signifies a perfectly isotropic shape (e.g., a square), while $R > 1$ indicates increasing elongation or anisotropy.\n\nFinally, for each test case $(L, p, s)$, the computed ratios $\\{R\\}$ are collected into a list, sorted in nondecreasing order, and each value is rounded to $6$ decimal places as required. The resulting lists of ratios, one for each test case, are then formatted into the specified final output string.",
            "answer": "```python\nimport numpy as np\nfrom scipy.ndimage import label\n\ndef solve():\n    \"\"\"\n    Main function to solve the percolation problem for the given test suite.\n    \"\"\"\n    test_cases = [\n        (4, 0, 42),\n        (4, 1, 0),\n        (8, 0.5, 12345),\n        (12, 0.592746, 777),\n        (6, 0.3, 2024),\n    ]\n\n    all_results = []\n    for L, p, s in test_cases:\n        ratios = process_case(L, p, s)\n        all_results.append(ratios)\n\n    # Format the final output string according to the problem specification.\n    outer_parts = []\n    for res_list in all_results:\n        # Format each ratio to 6 decimal places.\n        formatted_nums = [f\"{num:.6f}\" for num in res_list]\n        outer_parts.append(f\"[{','.join(formatted_nums)}]\")\n    \n    final_output = f\"[{','.join(outer_parts)}]\"\n    print(final_output)\n\ndef process_case(L, p, s):\n    \"\"\"\n    Generates a percolation configuration, finds clusters, and computes\n    shape anisotropy ratios for a single test case.\n    \"\"\"\n    # 1. Generate the lattice using a seeded pseudorandom number generator.\n    rng = np.random.default_rng(s)\n    grid = rng.random((L, L))  p\n\n    # 2. Identify clusters using 4-connectivity (von Neumann neighborhood).\n    # The structuring element defines connectivity to horizontal/vertical neighbors.\n    structure = np.array([[0, 1, 0], [1, 1, 1], [0, 1, 0]])\n    labeled_grid, num_labels = label(grid, structure=structure)\n    \n    if num_labels == 0:\n        return []\n\n    ratios = []\n    \n    # 3. Process each found cluster.\n    for i in range(1, num_labels + 1):\n        # Find all coordinates (row, col) for the current cluster label.\n        coords = np.argwhere(labeled_grid == i)\n        \n        # The problem statement uses (x, y) coordinates. Numpy's (row, col)\n        # corresponds to (y, x). We convert to (x, y) for consistency.\n        xy_coords = coords[:, ::-1].astype(np.float64)\n        \n        n = xy_coords.shape[0]\n\n        # Inclusion criterion 1: Cluster size n >= 3.\n        if n  3:\n            continue\n        \n        # Calculate the center of mass.\n        r_cm = np.mean(xy_coords, axis=0)\n        \n        # Center the coordinates and compute the gyration tensor G.\n        # G = sum_i (r_i - r_cm)(r_i - r_cm)^T\n        centered_coords = xy_coords - r_cm\n        G = centered_coords.T @ centered_coords\n        \n        # Eigenvalues of G are the squared principal radii of gyration.\n        # `eigvalsh` is used for real symmetric matrices.\n        eigenvalues = np.linalg.eigvalsh(G)\n        \n        lambda_min, lambda_max = eigenvalues[0], eigenvalues[1]\n        \n        # Inclusion criterion 2: Exclude collinear (degenerate) clusters.\n        # This corresponds to lambda_min > 0.\n        if lambda_min > 1e-12: # Using a small tolerance for floating point stability\n            R = lambda_max / lambda_min\n            ratios.append(R)\n            \n    # 4. Sort the list of ratios in nondecreasing order.\n    ratios.sort()\n    \n    return ratios\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}