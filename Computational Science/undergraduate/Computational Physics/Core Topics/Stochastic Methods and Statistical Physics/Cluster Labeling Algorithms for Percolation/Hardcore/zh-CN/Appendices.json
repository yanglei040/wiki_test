{
    "hands_on_practices": [
        {
            "introduction": "在计算物理学中，一项关键技能是将算法从简单的二维（$d=2$）模型推广到更符合现实的三维（$d=3$）系统。本练习 () 旨在挑战你将 Hoshen-Kopelman 算法应用于三维立方晶格。这需要你重新思考扫描顺序以及在每个站点需要检查的相邻站点集合，从而深化对算法核心逻辑的理解。",
            "id": "2380636",
            "problem": "您需要为一个位点逾渗问题，实现并分析一个从二维方格晶格推广到三维立方晶格的团簇标记算法。请从以下基本定义和事实出发，推导出一个正确且高效的算法。\n\n基本基础：\n- 在指定的邻域下，团簇是占据位点的最大连通集合。在维度 $d=3$ 的立方晶格中，标准的最近邻连接使用 $6$ 个面相邻的邻居。\n- 如果存在一个团簇同时接触到与某个笛卡尔坐标轴正交的两个边界超平面，则称位点沿该坐标轴逾渗。\n- Hoshen–Kopelman (HK) 算法（将由您定义和改编）是一种单遍团簇标记算法，它在指定的扫描顺序下，根据已访问的邻居建立标签等价关系，并使用不相交集数据结构（也称为并查集）来解析这些关系。\n\n您的任务：\n- 将团簇标记算法从 $d=2$ 推广到 $d=3$，用于线性尺寸为 $L$ 的立方晶格。使用包含 $6$ 个面相邻邻居的最近邻连接。采用确定性的扫描顺序，即按 $z$ 递增、$y$ 递增、再按 $x$ 递增的顺序访问位点。在每个占据位点，分配和合并标签时，仅考虑此顺序下已访问的邻居，即 $(x-1,y,z)$、$(x,y-1,z)$ 和 $(x,y,z-1)$。\n- 在扫描过程中，使用不相交集表示来管理标签等价关系，并在扫描结束后，将所有标签解析为其规范代表（根）。\n- 根据第一性原理，按如下方式编码每个轴的逾渗判据：沿 $x$ 轴，一个团簇发生逾渗当且仅当存在一个根标签，其对应的团簇中至少包含一个 $x=0$ 的位点和至少一个 $x=L-1$ 的位点。为 $y$ 轴和 $z$ 轴定义类似的判据。对于 $L=1$，请注意 $0=L-1$，因此单个占据位点即满足所有轴的逾渗判据。\n- 对每个测试晶格，计算团簇数量、最大团簇的大小，以及沿 $x$、$y$ 和 $z$ 轴的三个逾渗布尔值。\n\n实现约束：\n- 晶格是形状为 $(L,L,L)$ 的三维数组，其元素为表示占据状态的布尔值。\n- 邻居连接严格限定为 $6$ 个面相邻的邻居。\n- 边界条件是开放的（非周期性的）。\n\n测试套件：\n实现您的算法，并将其应用于以下五个确定性测试用例。每个用例都是一个线性尺寸为 $L$ 的立方晶格，并有预设的占据位点集合。坐标表示为有序三元组 $(x,y,z)$，其中 $x,y,z \\in \\{0,1,\\dots,L-1\\}$。\n\n- 测试 $1$（空晶格）：$L=3$，占据集合 $\\varnothing$。\n- 测试 $2$（单位点，最小系统）：$L=1$，占据集合 $\\{(0,0,0)\\}$。\n- 测试 $3$（沿 $z$ 轴的单条逾渗线）：$L=3$，占据集合 $\\{(1,1,0),(1,1,1),(1,1,2)\\}$。\n- 测试 $4$（位于相对面上的两个不连通的 $2\\times 2$ 正方形）：$L=4$，占据集合 $\\{(0,0,0),(1,0,0),(0,1,0),(1,1,0),(2,2,3),(3,2,3),(2,3,3),(3,3,3)\\}$。\n- 测试 $5$（完全占据的晶格）：$L=3$，占据集合等于整个晶格，即所有 $L^3=27$ 个位点均被占据。\n\n每个测试的所需输出：\n- 团簇数量（一个整数）。\n- 最大团簇的大小（一个整数）。\n- 三个布尔值，分别表示沿 $x$、$y$ 和 $z$ 轴是否存在逾渗。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含五个测试的结果，格式为一个由方括号括起来的逗号分隔列表。其中每个元素本身是一个形式为 $[n\\_c, s\\_{\\max}, b\\_x, b\\_y, b\\_z]$ 的列表，$n\\_c$ 是团簇数量，$s\\_{\\max}$ 是最大团簇大小，$b\\_x,b\\_y,b\\_z$ 分别是该测试沿 $x,y,z$ 轴的逾渗布尔值。例如，一个有效的整体格式是 $[[1,8,\\mathrm{True},\\mathrm{False},\\mathrm{True}],[\\dots],\\dots]$，打印的字符串中没有空白字符。",
            "solution": "对提供的问题陈述进行严格验证。\n\n**步骤 1：提取已知条件**\n\n- **领域**：计算物理，特别是用于逾渗的团簇标记算法。\n- **晶格**：线性尺寸为 $L$ 的三维立方晶格。\n- **连通性**：最近邻，由 $6$ 个面相邻位点定义。\n- **边界条件**：开放（非周期性）。\n- **算法**：Hoshen–Kopelman (HK) 算法的推广。\n- **扫描顺序**：确定性，按坐标 $(z, y, x)$ 的字典序。\n- **用于标记的邻居集合**：对于位于 $(x, y, z)$ 的位点，需要考虑的已访问邻居集合为 $\\{(x-1, y, z), (x, y-1, z), (x, y, z-1)\\}$。\n- **标签等价性**：使用不相交集（并查集）数据结构进行管理。\n- **标签解析**：初次扫描后，所有标签必须解析为其规范代表（根）。\n- **逾渗定义**：如果一个团簇沿某个轴（例如 $x$ 轴）逾渗，则它至少包含一个位于边界超平面 $x=0$ 上的位点和至少一个位于边界超平面 $x=L-1$ 上的位点。同样的逻辑适用于 $y$ 轴和 $z$ 轴。\n- **特殊情况 $L=1$**：对于大小为 $L=1$ 的系统，位于 $(0,0,0)$ 的占据位点满足所有三个轴的逾渗判据，因为条件 $x=0$ 与 $x=L-1$ 等同。\n- **所需输出**：对每个测试用例，计算：\n    1. 不同团簇的总数，$n_c$。\n    2. 最大团簇的大小，$s_{\\max}$。\n    3. 三个布尔值，指示沿 $x$、$y$ 和 $z$ 轴的逾渗情况，$(b_x, b_y, b_z)$。\n- **测试用例**：\n    - **测试 1**：$L=3$，占据集合 $\\varnothing$。\n    - **测试 2**：$L=1$，占据集合 $\\{(0,0,0)\\}$。\n    - **测试 3**：$L=3$，占据集合 $\\{(1,1,0), (1,1,1), (1,1,2)\\}$。\n    - **测试 4**：$L=4$，占据集合 $\\{(0,0,0), (1,0,0), (0,1,0), (1,1,0), (2,2,3), (3,2,3), (2,3,3), (3,3,3)\\}$。\n    - **测试 5**：$L=3$，占据集合是包含 $27$ 个位点的整个晶格。\n- **实现约束**：晶格是形状为 $(L,L,L)$ 的布尔数组。\n\n**步骤 2：使用提取的已知条件进行验证**\n\n根据验证标准对问题进行审查：\n\n1.  **科学性**：该问题基于 Hoshen-Kopelman 算法和逾渗理论，这些是计算物理和统计物理中的标准、成熟的课题。从二维扩展到三维是典型的练习。团簇、连通性和逾渗的定义都是标准的。该问题是科学合理的。\n2.  **适定性**：问题的规定非常精确。它定义了确定性的扫描顺序、要检查的特定邻居集合、处理标签等价关系的清晰方法，以及所需输出的明确判据。给定的测试用例是确定性的。每个测试用例都存在唯一且稳定的解。\n3.  **客观性**：语言正式、精确，没有任何主观性或歧义。\n4.  **完整性与一致性**：提供了所有必要信息。晶格尺寸、占据位点、连通性规则和输出要求都已完全指定。对 $L=1$ 的特殊情况进行了明确处理，以防止歧义。算法的描述是内部一致的；指定的邻居集合与给定扫描顺序下已访问位点的集合完全对应。\n5.  **无其他缺陷**：该问题不是比喻性的、琐碎的或结构不良的。它要求从第一性原理出发实现一个非平凡的算法。\n\n**步骤 3：结论与行动**\n\n该问题是**有效的**。这是一个计算物理学中适定且科学合理的问题。将按照规定构建解决方案。\n\n**算法解决方案**\n\n该任务要求实现三维 Hoshen-Kopelman (HK) 算法。这将通过对晶格数据进行三次主要遍历来完成。\n\n设立方晶格由一个形状为 $(L, L, L)$ 的三维布爾數組 $\\mathcal{G}$ 表示，其中如果位点 $(x, y, z)$ 被占据，则 $\\mathcal{G}[z, y, x] = \\mathrm{True}$。我们将创建一个相同形状的相应整数数组 $\\Lambda$ 来存储团簇标签，并初始化为 $0$。\n\n需要一个不相交集并 (DSU) 或并查集数据结构来管理标签等价关系。这将使用一个父数组 $P$ 来实现，其中 $P[i]$ 存储标签 $i$ 的父节点。基本操作是 `find(i)`（返回包含 $i$ 的集合的规范代表（根），为提高效率使用路径压缩）和 `union(i, j)`（合并包含标签 $i$ 和 $j$ 的集合）。\n\n**第一遍：位点标记与等价关系记录**\n\n晶格 $\\mathcal{G}$ 按照指定的索引字典序 $(z, y, x)$进行扫描，从 $(0, 0, 0)$ 到 $(L-1, L-1, L-1)$。用于新标签的计数器 `next_label` 初始化为 $1$。\n\n对于每个位点 $(x, y, z)$：\n如果 $\\mathcal{G}[z, y, x]$ 未被占据，则 $\\Lambda[z, y, x]$ 保持为 $0$。\n如果 $\\mathcal{G}[z, y, x]$ 被占据，我们检查其先前扫描过的邻居。由于扫描顺序，这些邻居位于 $(x-1, y, z)$、$(x, y-1, z)$ 和 $(x, y, z-1)$。设 $N(z, y, x)$ 为已占据且已访问的邻居的标签集合：\n$$\nN(z, y, x) = \\{ \\Lambda[z, y, k] \\mid k=x-1, \\mathcal{G}[z, y, k]=\\mathrm{True}, x>0 \\} \\cup \\\\ \\{ \\Lambda[z, l, x] \\mid l=y-1, \\mathcal{G}[z, l, x]=\\mathrm{True}, y>0 \\} \\cup \\\\ \\{ \\Lambda[k, y, x] \\mid k=z-1, \\mathcal{G}[k, y, x]=\\mathrm{True}, z>0 \\}\n$$\n$N(z, y, x)$ 集合存在两种情况：\n1.  **$N(z, y, x)$ 为空**：当前位点未与任何先前标记的团簇相连。它会启动一个新团簇。我们为其分配一个新标签：$\\Lambda[z, y, x] \\leftarrow \\text{next\\_label}$。通过设置 $P[\\text{next\\_label}] \\leftarrow \\text{next\\_label}$ 来更新 DSU。然后 `next_label` 计数器递增。\n2.  **$N(z, y, x)$ 非空**：当前位点与一个或多个现有团簇相连。我们为其分配 $N(z,y,x)$ 中的最小标签：$\\Lambda[z, y, x] \\leftarrow \\min(N)$。随后，必须将 $N$ 中的所有标签声明为等价。对于 $N$ 中的每个标签 $l$，我们执行 `union(min(N), l)` 操作。这确保了目前为止找到的所有连通分量都在 DSU 数据结构中被合并。\n\n**第二遍：标签解析**\n\n第一遍结束后，数组 $\\Lambda$ 包含临时标签，而 DSU 的父数组 $P$ 持有完整的等价关系集合。第二遍解析这些等价关系。\n首先，通过对每个标签应用路径压缩来扁平化 DSU 结构。对于从 $1$ 到 `next_label`$-1$ 的每个标签 $i$，我们设置 $P[i] \\leftarrow \\text{find}(i)$。\n接下来，更新标签数组 $\\Lambda$。我们遍历每个位点 $(x, y, z)$。如果该位点被占据（即 $\\Lambda[z, y, x] > 0$），则其标签被替换为其规范代表：$\\Lambda[z, y, x] \\leftarrow P[\\Lambda[z, y, x]]$。此遍完成后，属于同一团簇的所有位点都共享完全相同的标签，即其等价类的根。\n\n**第三遍：指标计算**\n\n利用解析后的标签网格 $\\Lambda$，我们可以计算所需的指标。我们使用两个字典：`cluster_sizes` 用于将每个规范标签映射到其大小，`cluster_boundaries` 用于将每个规范标签映射到其接触的边界超平面集合。\n\n我们最后一次遍历晶格。对于每个位点 $(x, y, z)$：\n如果该位点被占据且其规范标签为 $k = \\Lambda[z, y, x]$：\n- 在 `cluster_sizes` 中增加团簇 $k$ 的大小。\n- 检查该位点是否位于边界上。如果 $x=0$，则记录团簇 $k$ 接触 '$x_0$' 边界。如果 $x=L-1$，则记录其接触 '$x_{L-1}$' 边界。对 $y$ 轴和 $z$ 轴也进行同样的操作。\n\n最后，计算输出量：\n- **团簇数量 $n_c$**：这是唯一规范标签的总数，即 `cluster_sizes` 字典中的条目数。如果没有位点被占据，则 $n_c=0$。\n- **最大团簇大小 $s_{\\max}$**：这是 `cluster_sizes` 字典中的最大值。如果没有位点被占据，则 $s_{\\max}=0$。\n- **逾渗布尔值 $(b_x, b_y, b_z)$**：对于每个规范团簇 $k$，我们检查其记录的边界交集。\n    - 如果存在任何 $k$ 同时接触 $x=0$ 和 $x=L-1$ 边界，则 $b_x = \\mathrm{True}$。特殊情况：如果 $L=1$，接触 $x=0$ 边界即足够。\n    - 如果存在任何 $k$ 同时接触 $y=0$ 和 $y=L-1$ 边界，则 $b_y = \\mathrm{True}$。特殊情况：如果 $L=1$，接触 $y=0$ 边界即足够。\n    - 如果存在任何 $k$ 同时接触 $z=0$ 和 $z=L-1$ 边界，则 $b_z = \\mathrm{True}$。特殊情况：如果 $L=1$，接触 $z=0$ 边界即足够。\n\n至此，完成了从指定的第一性原理推导算法的过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and print results in the required format.\n    \"\"\"\n    test_cases = [\n        # Test 1: L=3, empty lattice\n        (3, set()),\n        # Test 2: L=1, single site\n        (1, {(0, 0, 0)}),\n        # Test 3: L=3, single percolating line along z\n        (3, {(1, 1, 0), (1, 1, 1), (1, 1, 2)}),\n        # Test 4: L=4, two disconnected 2x2 squares\n        (4, {(0, 0, 0), (1, 0, 0), (0, 1, 0), (1, 1, 0), \n             (2, 2, 3), (3, 2, 3), (2, 3, 3), (3, 3, 3)}),\n        # Test 5: L=3, fully occupied lattice\n        (3, {(x, y, z) for x in range(3) for y in range(3) for z in range(3)}),\n    ]\n\n    results_str = []\n    for L, occupied_sites in test_cases:\n        result = analyze_lattice(L, occupied_sites)\n        # Format each result list as a string, e.g., \"[1,27,True,True,True]\"\n        results_str.append(f\"[{result[0]},{result[1]},{result[2]},{result[3]},{result[4]}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_str)}]\")\n\ndef analyze_lattice(L, occupied_sites):\n    \"\"\"\n    Implements the 3D Hoshen-Kopelman algorithm and computes cluster statistics.\n    \"\"\"\n    if not occupied_sites:\n        return [0, 0, False, False, False]\n\n    # Create a boolean grid for occupied sites\n    grid = np.zeros((L, L, L), dtype=bool)\n    for x, y, z in occupied_sites:\n        grid[z, y, x] = True\n\n    labels = np.zeros_like(grid, dtype=int)\n    \n    # Disjoint-Set Union (DSU) implementation\n    # The max number of labels is the number of occupied sites.\n    # We add 1 for 1-based indexing, and another 1 for range safety.\n    max_labels = L * L * L + 1\n    parent = list(range(max_labels))\n\n    def find(i):\n        if parent[i] == i:\n            return i\n        parent[i] = find(parent[i]) # Path compression\n        return parent[i]\n\n    def union(i, j):\n        root_i = find(i)\n        root_j = find(j)\n        if root_i != root_j:\n            # A simple union rule: smaller root points to larger root\n            if root_i > root_j:\n                parent[root_j] = root_i\n            else:\n                parent[root_i] = root_j\n\n    # --- Pass 1: Labeling and Equivalence Recording ---\n    next_label = 1\n    # Scan in order z, then y, then x\n    for z in range(L):\n        for y in range(L):\n            for x in range(L):\n                if not grid[z, y, x]:\n                    continue\n\n                neighbor_labels = set()\n                # Check neighbors that have already been visited\n                # Neighbor (x-1, y, z) -> grid[z, y, x-1]\n                if x > 0 and grid[z, y, x-1]:\n                    neighbor_labels.add(labels[z, y, x-1])\n                # Neighbor (x, y-1, z) -> grid[z, y-1, x]\n                if y > 0 and grid[z, y-1, x]:\n                    neighbor_labels.add(labels[z, y-1, x])\n                # Neighbor (x, y, z-1) -> grid[z-1, y, x]\n                if z > 0 and grid[z-1, y, x]:\n                    neighbor_labels.add(labels[z-1, y, x])\n\n                if not neighbor_labels:\n                    # New cluster\n                    labels[z, y, x] = next_label\n                    next_label += 1\n                else:\n                    # Connected to existing clusters\n                    min_label = min(neighbor_labels)\n                    labels[z, y, x] = min_label\n                    for label in neighbor_labels:\n                        if label != min_label:\n                            union(min_label, label)\n    \n    # --- Pass 2  3: Label Resolution and Metric Computation ---\n    cluster_sizes = {}\n    cluster_boundaries = {}\n\n    for z in range(L):\n        for y in range(L):\n            for x in range(L):\n                if not grid[z, y, x]:\n                    continue\n                \n                # Find the canonical root label for the current site\n                root = find(labels[z, y, x])\n                labels[z, y, x] = root # Resolve label in place (optional but good practice)\n                \n                if root not in cluster_sizes:\n                    cluster_sizes[root] = 0\n                    cluster_boundaries[root] = set()\n\n                cluster_sizes[root] += 1\n                \n                # Record boundary intersections\n                if x == 0: cluster_boundaries[root].add('x0')\n                if x == L - 1: cluster_boundaries[root].add('xL')\n                if y == 0: cluster_boundaries[root].add('y0')\n                if y == L - 1: cluster_boundaries[root].add('yL')\n                if z == 0: cluster_boundaries[root].add('z0')\n                if z == L - 1: cluster_boundaries[root].add('zL')\n\n    # --- Final Calculation of Metrics ---\n    n_clusters = len(cluster_sizes)\n    s_max = max(cluster_sizes.values()) if cluster_sizes else 0\n    \n    b_x, b_y, b_z = False, False, False\n    for root in cluster_boundaries:\n        boundaries = cluster_boundaries[root]\n        if L == 1:\n            if 'x0' in boundaries: b_x = True\n            if 'y0' in boundaries: b_y = True\n            if 'z0' in boundaries: b_z = True\n        else:\n            if 'x0' in boundaries and 'xL' in boundaries: b_x = True\n            if 'y0' in boundaries and 'yL' in boundaries: b_y = True\n            if 'z0' in boundaries and 'zL' in boundaries: b_z = True\n\n    return [n_clusters, s_max, b_x, b_y, b_z]\n\n\nsolve()\n```"
        },
        {
            "introduction": "算法效率是计算科学的核心。虽然“先标记，后分析”的两遍法很简单，但许多物理量可以在标记过程中同步计算。本练习 () 的核心是改造 Union-Find 数据结构，使其在单次扫描中就能累积计算回转半径 $R_g^2$ 所需的统计量。这不仅能提高计算效率，更展示了一种将物理分析与算法过程紧密集成的优雅编程思想。",
            "id": "2380614",
            "problem": "给定一个线性尺寸为 $L$ 的方形晶格上的二维位点渗流问题，边界为开放边界（无周期性环绕）。每个晶格位点以概率 $p$ 被独立占据，使用以指定整数种子 $s$ 初始化的伪随机数生成器。当且仅当两个被占据的位点是冯·诺依曼邻域（即 $4$-连通：上、下、左、右）中的最近邻时，它们被认为是相连的。一个团簇是一个由被占据位点组成的极大 $4$-连通集合。\n\n对于任何由位于整数坐标 $\\{(x_i,y_i)\\}_{i=1}^N$（其中 $x_i,y_i \\in \\{0,1,\\dots,L-1\\}$）的 $N$ 个位点组成的团簇，其质心 $\\mathbf{r}_{\\mathrm{cm}}$ 和回转半径的平方 $R_g^2$ 定义为\n$$\n\\mathbf{r}_{\\mathrm{cm}}=\\frac{1}{N}\\sum_{i=1}^N \\begin{pmatrix}x_i\\\\ y_i\\end{pmatrix},\\qquad\nR_g^2=\\frac{1}{N}\\sum_{i=1}^N \\left\\|\\begin{pmatrix}x_i\\\\ y_i\\end{pmatrix}-\\mathbf{r}_{\\mathrm{cm}}\\right\\|^2.\n$$\n\n设计一个程序，在对晶格进行单次光栅扫描的过程中，为被占据的位点分配团簇标签，并同时累积足够的统计数据，以计算每个团簇的回转半径平方 $R_g^2$，而无需对已处理的位点进行任何额外的遍历。扫描结束后，根据其基数 $N$ 识别出最大的团簇。如果 $N$ 出现平局，则在并列的团簇中选择其最早出现的位点（按行主序，即先递增 $i$ 再递增 $j$）具有最小线性索引 $i\\cdot L + j$ 的那个团簇。对于没有被占据位点的构型，将结果定义为 $0$。\n\n对于下面的每个测试用例，使用指定的 $L$、$p$ 和种子 $s$ 生成位点占据构型，计算所选团簇的回转半径平方 $R_g^2$，并将该值作为浮点数输出，精确到小数点后 $6$ 位。\n\n测试套件：\n- 用例 1：$L=8$, $p=0.5$, $s=17$。\n- 用例 2：$L=8$, $p=0.0$, $s=1$。\n- 用例 3：$L=8$, $p=1.0$, $s=1$。\n- 用例 4：$L=1$, $p=1.0$, $s=123$。\n- 用例 5：$L=12$, $p=0.59$, $s=2024$。\n\n您的程序应生成单行输出，其中包含用例 1 到 5 的结果，形式为方括号括起来的逗号分隔列表，每个条目都四舍五入到小数点后恰好 $6$ 位，例如 $[x_1,x_2,x_3,x_4,x_5]$，其中每个 $x_k$ 是用例 $k$ 的四舍五入值。",
            "solution": "物理模型是线性尺寸为 $L$ 的方形晶格上的位点渗流，每个位点以概率 $p$ 独立占据。团簇是通过冯·诺依曼邻域（即 $4$-连通）连接的被占据位点的极大集合。任务是在单次扫描中为团簇分配标签的同时，并行计算必要量，以确定最大团簇的回转半径平方 $R_g^2$。\n\n根据第一性原理，对于一个包含 $N$ 个位点、位置为 $\\{(x_i,y_i)\\}_{i=1}^N$ 的团簇，其质心为\n$$\n\\mathbf{r}_{\\mathrm{cm}}=\\frac{1}{N}\\sum_{i=1}^N \\begin{pmatrix}x_i\\\\ y_i\\end{pmatrix}\n=\\begin{pmatrix}\\frac{1}{N}\\sum_{i=1}^N x_i\\\\ \\frac{1}{N}\\sum_{i=1}^N y_i\\end{pmatrix}.\n$$\n回转半径的平方是\n$$\nR_g^2=\\frac{1}{N}\\sum_{i=1}^N \\left[(x_i - \\bar{x})^2 + (y_i - \\bar{y})^2\\right],\n$$\n其中 $\\bar{x}=\\frac{1}{N}\\sum_{i=1}^N x_i$ 且 $\\bar{y}=\\frac{1}{N}\\sum_{i=1}^N y_i$。展开平方项并重新整理，可以得到一个依赖于可加性团簇统计量的表达式：\n$$\nR_g^2=\\left(\\frac{1}{N}\\sum_{i=1}^N (x_i^2+y_i^2)\\right) - \\left(\\left(\\frac{1}{N}\\sum_{i=1}^N x_i\\right)^2 + \\left(\\frac{1}{N}\\sum_{i=1}^N y_i\\right)^2\\right).\n$$\n为团簇定义累加器：\n- $N$：团簇中的位点数，\n- $S_x=\\sum_{i=1}^N x_i$，\n- $S_y=\\sum_{i=1}^N y_i$，\n- $Q=\\sum_{i=1}^N (x_i^2+y_i^2)$。\n\n那么\n$$\nR_g^2=\\frac{Q}{N}-\\left(\\frac{S_x}{N}\\right)^2-\\left(\\frac{S_y}{N}\\right)^2.\n$$\n因此，如果在为位点分配团簇时维护这些累加器，就可以在不重新访问团簇位点的情况下计算出 $R_g^2$。\n\n为了在支持动态合并的同时通过单次扫描分配团簇标签，应按行主序处理晶格。在每个被占据的位点 $(i,j)$，检查已处理的邻居（上方和左侧）。有四种情况：\n- 两个邻居都未被占据：以标签 $\\ell$ 开始一个新的团簇，并将其累加器初始化为 $N=1$, $S_x=j$, $S_y=i$, $Q=i^2+j^2$。\n- 只有一个邻居属于根标签为 $r$ 的团簇：将当前位点分配给 $r$，并通过 $N\\leftarrow N+1$, $S_x\\leftarrow S_x+j$, $S_y\\leftarrow S_y+i$, $Q\\leftarrow Q+i^2+j^2$ 更新该团簇的累加器。\n- 两个邻居都在同一个根团簇 $r$ 中：分配给 $r$ 并如上更新。\n- 两个邻居在不同的根团簇 $r_1\\neq r_2$ 中：通过将其累加器相加，将这两个团簇合并（统一）为一个根 $r$，$N\\leftarrow N_1+N_2$, $S_x\\leftarrow S_{x,1}+S_{x,2}$, $S_y\\leftarrow S_{y,1}+S_{y,2}$, $Q\\leftarrow Q_1+Q_2$，然后将当前位点分配给 $r$，并像前一种情况一样用当前位点的贡献更新累加器。\n\n这种动态合并可以通过带有路径压缩和按大小合并的并查集（union–find）数据结构来实现，以确保每次操作的摊销时间接近常数。联合操作被扩展为将两个根团簇的累加器相加，并保留团簇中位点的最小行主序索引 $m=\\min(i\\cdot L + j)$。维护 $m$ 支持一种确定性的平局决胜规则：标记完成后，选择具有最大 $N$ 的团簇，如果出现平局，则选择其 $m$ 最小的团簇。\n\n正确性源于累加器的可加性。当两个团簇合并时，新的累加器恰好是合并前各团簇累加器之和，从而在并集上保留了 $N$, $S_x$, $S_y$ 和 $Q$ 的值。因为 $R_g^2$ 完全由这些累加器计算得出，所以它与定义相符。单次遍历的要求得到满足，因为在处理一个位点时，它要么被添加到一个现有团簇，要么触发一次合并；所有对团簇累加器的必要更新都在那一刻发生，不需要后续对团簇位点的重新遍历。\n\n边界情况：\n- 如果没有被占据的位点，则不存在团簇；根据规定，返回 $0$。\n- 如果只有一个被占据的位点，则 $N=1$, $S_x=x_1$, $S_y=y_1$, $Q=x_1^2+y_1^2$，且 $R_g^2=\\frac{Q}{1}-\\left(\\frac{S_x}{1}\\right)^2-\\left(\\frac{S_y}{1}\\right)^2=0$。\n- 对于一个完全被占据的晶格（$p=1$），只有一个包含 $N=L^2$ 个位点的团簇。其解析的回转半径平方为\n$$\nR_g^2=\\operatorname{Var}(x)+\\operatorname{Var}(y)=2\\cdot\\frac{L^2-1}{12}=\\frac{L^2-1}{6},\n$$\n因为在团簇中，$x$ 和 $y$ 均在 $\\{0,1,\\dots,L-1\\}$ 上均匀分布。对于 $L=8$，这给出 $R_g^2=\\frac{64-1}{6}=\\frac{63}{6}=10.5$。\n\n计算复杂度：每个位点被处理一次。每次并查集操作的摊销时间接近常数，具体为 $\\mathcal{O}(\\alpha(M))$，其中 $\\alpha$ 是反阿克曼函数，$M=L^2$ 是位点数。因此，总时间为 $\\mathcal{O}(L^2\\alpha(L^2))$，实际上与位点数成线性关系，而用于标签和占据状态的内存使用量为 $\\mathcal{O}(L^2)$。\n\n对于五个指定参数 $(L,p,s)$ 中的每一个测试用例，程序使用给定的种子 $s$ 生成构型，计算所选团簇的 $R_g^2$，并将结果打印为单个方括号列表 $[x_1,x_2,x_3,x_4,x_5]$，其中每个 $x_k$ 四舍五入到小数点后恰好 6 位。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef largest_cluster_rg2(L: int, p: float, seed: int) -> float:\n    \"\"\"\n    Generate an LxL site percolation configuration with occupation prob p (seeded),\n    label clusters with 4-neighbor connectivity in a single scan while maintaining\n    per-cluster accumulators, and return the squared radius of gyration (Rg^2)\n    of the largest cluster (tie-broken by earliest row-major site). If no occupied\n    sites, return 0.0.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    occ = (rng.random((L, L))  p)\n\n    # Label grid (0 = empty/unlabeled)\n    labels = np.zeros((L, L), dtype=np.int32)\n\n    # Disjoint set (union-find) with accumulators. 1-based labels.\n    parent = [0]  # index 0 unused\n    size = [0]    # number of sites N for root\n    sum_x = [0.0] # sum of x coordinates\n    sum_y = [0.0] # sum of y coordinates\n    sum_r2 = [0.0]# sum of x^2 + y^2\n    min_idx = [10**18]  # earliest row-major index i*L + j for tie-breaking\n\n    def find(a: int) -> int:\n        # Path compression\n        while parent[a] != a:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n\n    def union(a: int, b: int) -> int:\n        ra, rb = find(a), find(b)\n        if ra == rb:\n            return ra\n        # Union by size: attach smaller to larger\n        if size[ra]  size[rb]:\n            ra, rb = rb, ra\n        parent[rb] = ra\n        # Merge accumulators into ra\n        size[ra] += size[rb]\n        sum_x[ra] += sum_x[rb]\n        sum_y[ra] += sum_y[rb]\n        sum_r2[ra] += sum_r2[rb]\n        if min_idx[rb]  min_idx[ra]:\n            min_idx[ra] = min_idx[rb]\n        return ra\n\n    next_label = 0\n\n    for i in range(L):\n        for j in range(L):\n            if not occ[i, j]:\n                continue\n            # Neighbor labels (up, left)\n            up = labels[i-1, j] if i > 0 else 0\n            left = labels[i, j-1] if j > 0 else 0\n            up_root = find(up) if up != 0 else 0\n            left_root = find(left) if left != 0 else 0\n\n            idx = i * L + j\n            if up_root == 0 and left_root == 0:\n                # New cluster\n                next_label += 1\n                lbl = next_label\n                if lbl >= len(parent):\n                    parent.append(lbl)\n                    size.append(0)\n                    sum_x.append(0.0)\n                    sum_y.append(0.0)\n                    sum_r2.append(0.0)\n                    min_idx.append(10**18)\n                else:\n                    parent[lbl] = lbl\n                    size[lbl] = 0\n                    sum_x[lbl] = 0.0\n                    sum_y[lbl] = 0.0\n                    sum_r2[lbl] = 0.0\n                    min_idx[lbl] = 10**18\n                labels[i, j] = lbl\n                # Add current site to accumulators\n                size[lbl] = 1\n                sum_x[lbl] = float(j)\n                sum_y[lbl] = float(i)\n                sum_r2[lbl] = float(i * i + j * j)\n                min_idx[lbl] = idx\n            elif up_root != 0 and left_root == 0:\n                # Attach to up_root\n                labels[i, j] = up_root\n                size[up_root] += 1\n                sum_x[up_root] += float(j)\n                sum_y[up_root] += float(i)\n                sum_r2[up_root] += float(i * i + j * j)\n                if idx  min_idx[up_root]:\n                    min_idx[up_root] = idx\n            elif up_root == 0 and left_root != 0:\n                # Attach to left_root\n                labels[i, j] = left_root\n                size[left_root] += 1\n                sum_x[left_root] += float(j)\n                sum_y[left_root] += float(i)\n                sum_r2[left_root] += float(i * i + j * j)\n                if idx  min_idx[left_root]:\n                    min_idx[left_root] = idx\n            else:\n                # Both neighbors belong to clusters\n                if up_root == left_root:\n                    r = up_root\n                else:\n                    r = union(up_root, left_root)\n                labels[i, j] = r\n                size[r] += 1\n                sum_x[r] += float(j)\n                sum_y[r] += float(i)\n                sum_r2[r] += float(i * i + j * j)\n                if idx  min_idx[r]:\n                    min_idx[r] = idx\n\n    # Identify roots and select largest cluster (tie-break by earliest index)\n    best_rg2 = 0.0\n    best_size = -1\n    best_minidx = 10**18\n\n    for lbl in range(1, next_label + 1):\n        if parent[lbl] != lbl:\n            continue  # not a root\n        n = size[lbl]\n        if n = 0:\n            continue\n        mi = min_idx[lbl]\n        # Select by size, then by earliest site index\n        if (n > best_size) or (n == best_size and mi  best_minidx):\n            # Compute Rg^2\n            sx = sum_x[lbl]\n            sy = sum_y[lbl]\n            q = sum_r2[lbl]\n            rg2 = (q / n) - (sx / n) ** 2 - (sy / n) ** 2\n            best_rg2 = float(rg2)\n            best_size = n\n            best_minidx = mi\n\n    # Handle no occupied sites: best_size remains -1\n    if best_size == -1:\n        return 0.0\n    return best_rg2\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (L, p, seed)\n    test_cases = [\n        (8, 0.5, 17),\n        (8, 0.0, 1),\n        (8, 1.0, 1),\n        (1, 1.0, 123),\n        (12, 0.59, 2024),\n    ]\n\n    results = []\n    for L, p, s in test_cases:\n        rg2 = largest_cluster_rg2(L, p, s)\n        results.append(f\"{rg2:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "渗流现象并不仅限于常规晶格。这项高级练习 () 将带领你探索准晶体这种非周期性结构上的渗流问题。其挑战在于，系统的连通性不再由简单的网格邻接定义，而是通过几何条件（即 Delaunay 三角剖分）来确定。解决这个问题能让你体会到团簇分析方法在现代物理研究中的广泛适用性，并将其应用于非传统、更复杂的系统中。",
            "id": "2380602",
            "problem": "您将研究一个非周期准晶点集上的位点逾渗，该点集表现出类似于 Penrose 铺砖的长程有序性。该点集被定义为两个通过替换和度量嵌入构建的一维斐波那契链的笛卡尔积。令黄金比例为 $\\varphi = \\frac{1+\\sqrt{5}}{2}$。定义两种线段长度：长度为 $\\varphi$ 的长线段 $L$ 和长度为 $1$ 的短线段 $S$。对于一个非负整数 $k$，从 $W_0 = L$ 开始，通过替换规则 $L \\mapsto L\\,S$ 和 $S \\mapsto L$ 在字母表 $\\{L,S\\}$ 上构造一个词 $W_k$，并精确迭代 $k$ 次。根据 $W_k$，在实数线上定义一个坐标序列，其中 $x_0 = 0$ 且对于 $i = 0,1,\\dots,|W_k|-1$，$x_{i+1} = x_i + \\ell_i$，当 $W_k$ 的第 $i$ 个符号是 $L$ 时 $\\ell_i = \\varphi$，当它是 $S$ 时 $\\ell_i = 1$。这将生成一个严格递增的坐标列表 $\\{x_i\\}_{i=0}^{|W_k|}$。给定两个迭代次数 $k_x$ 和 $k_y$，二维点集为\n$$\n\\mathcal{P} = \\{(x_i, y_j) \\mid 0 \\le i \\le |W_{k_x}|,\\ 0 \\le j \\le |W_{k_y}|\\},\n$$\n其中 $\\{y_j\\}$ 的构造方式与 $\\{x_i\\}$ 相同，基于 $W_{k_y}$。这个 $\\mathcal{P}$ 是一个具有非周期结构和长程有序性的准晶格。\n\n定义两个不同位点 $u, v \\in \\mathcal{P}$ 之间的邻域关系如下：$u$ 和 $v$ 是邻居，当且仅当平面上存在至少一个通过 $u$ 和 $v$ 的圆，其开圆盘内不包含 $\\mathcal{P}$ 中的任何位点。等价地，如果 $u$ 和 $v$ 满足平面几何图意义下的空外接圆性质，则它们由一条边连接。\n\n以占据概率 $p \\in [0,1]$ 执行位点逾渗，每个位点以概率 $p$ 被独立地宣告为已占据。使用以整数种子 $s$ 初始化的确定性伪随机序列来抽取 $[0,1)$ 上的独立均匀随机数，当且仅当对应的抽取值严格小于 $p$ 时，宣告一个位点为已占据。簇被定义为通过邻域关系连接的已占据位点的极大集合。令 $x_{\\min} = \\min\\{x \\mid (x,y) \\in \\mathcal{P}\\}$ 和 $x_{\\max} = \\max\\{x \\mid (x,y) \\in \\mathcal{P}\\}$，并令 $\\Delta_x$ 为 $\\{x_i\\}$ 中连续不同 $x$ 坐标之间最小间距的一半。定义左边界为满足 $x \\le x_{\\min} + \\Delta_x$ 的位点集合，右边界为满足 $x \\ge x_{\\max} - \\Delta_x$ 的位点集合。我们关注的逾渗事件是，是否存在至少一个同时与左边界和右边界相交的已占据簇。对于每个参数集，所需的输出是一个布尔值，指示此事件是否发生。\n\n您的任务是实现一个完整的程序，对于下面测试套件中的每个参数元组 $(k_x, k_y, p, s)$，该程序需构建 $\\mathcal{P}$，通过空外接圆条件确定邻域关系，按规定执行位点逾渗，标记簇，并判断是否存在从左到右贯穿的已占据簇。此问题不涉及任何物理单位。\n\n用于覆盖一般行为和边界情况的测试套件参数：\n- 情况 A (完全占据): $(k_x, k_y, p, s) = (2, 2, 1.0, 0)$。\n- 情况 B (没有占据): $(k_x, k_y, p, s) = (2, 2, 0.0, 0)$。\n- 情况 C (亚临界示例): $(k_x, k_y, p, s) = (4, 3, 0.4, 12345)$。\n- 情况 D (近临界示例): $(k_x, k_y, p, s) = (5, 5, 0.55, 2468)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，且无空格，结果按上述情况的顺序排列。例如，格式必须与 $[r_A,r_B,r_C,r_D]$ 完全一样，其中每个 $r_\\cdot$ 是 True 或 False。",
            "solution": "用户提供了一个问题陈述，要求对二维准晶格上的位点逾渗进行计算研究。问题在于，对于几组参数集，确定是否存在一个贯穿的已占据位点簇连接系统的左右边界。\n\n该问题陈述在算法上是明确的，在科学上是合理的。它深深植根于计算物理学的既定原理，特别是逾渗理论和准晶体研究。所有术语都经过了精确的数学定义，参数是完整的，目标是明确的。因此，该问题被认为是有效的，有必要给出一个完整的解决方案。\n\n解决方案的开发遵循了一系列逻辑步骤，从构建物理系统到执行逾渗分析。\n\n**1. 准晶点集的构建**\n\n系统的基础是一种称为斐波那契链的一维非周期链。该链由一个符号序列构建，然后映射到物理坐标。\n\n*   **斐波那契词生成**：我们从一个符号字母表 $\\{L, S\\}$ 开始，它们分别代表长线段和短线段。线段序列，即一个词 $W_k$，是通过从 $W_0=L$ 开始的迭代替换过程生成的。对于一个给定的整数 $k \\ge 0$，词 $W_{k+1}$ 是通过对 $W_k$ 应用替换规则 $L \\mapsto LS$ 和 $S \\mapsto L$ 得到的。例如，$W_0=L$，$W_1=LS$，$W_2=LSL$，依此类推。\n\n*   **一维坐标生成**：将符号词 $W_k$ 嵌入到实数线上以创建一组坐标。线段长度定义为 $L$ 为 $\\varphi = \\frac{1+\\sqrt{5}}{2}$，$S$ 为 $1$。通过设置 $x_0=0$ 并随后令 $x_{i+1} = x_i + \\ell_i$ 来生成一个严格递增的坐标序列 $\\{x_i\\}_{i=0}^{|W_k|}$，其中 $\\ell_i$ 是 $W_k$ 中第 $i$ 个符号的长度。\n\n*   **二维点集构建**：二维准晶点集，记为 $\\mathcal{P}$，是由两个一维斐波那契链的笛卡尔积形成的。给定迭代次数 $k_x$ 和 $k_y$，我们从 $W_{k_x}$ 生成坐标集 $\\{x_i\\}$，从 $W_{k_y}$ 生成坐标集 $\\{y_j\\}$。点集则为 $\\mathcal{P} = \\{(x_i, y_j) \\mid 0 \\le i \\le |W_{k_x}|, 0 \\le j \\le |W_{k_y}|\\}$。\n\n**2. 定义邻域图**\n\n$\\mathcal{P}$ 中位点之间的连通性由一个特定的几何条件定义。如果可以通过两个不同的位点 $u, v \\in \\mathcal{P}$ 画出一个空外接圆，即存在一个通过 $u$ 和 $v$ 的圆，其开圆盘内不包含来自 $\\mathcal{P}$ 的任何其他位点，则认为这两个位点是邻居。这个“空外接圆”性质是点集德劳内三角剖分中边的定义特征。因此，我们系统的邻域结构正是由 $\\mathcal{P}$ 的德劳内三角剖分的边所形成的图。这个图为逾渗过程提供了底层网络。\n\n**3. 位点逾渗和簇识别**\n\n在集合 $\\mathcal{P}$ 的位点上模拟逾渗。\n\n*   **位点占据**：每个位点以概率 $p \\in [0,1]$ 被独立地宣告为“已占据”。为确保结果的确定性和可复现性，使用一个给定的整数种子 $s$ 初始化一个伪随机数生成器。对于每个位点，抽取一个随机数 $r \\in [0,1)$；当且仅当 $r  p$ 时，该位点被占据。\n\n*   **簇定义**：簇是一个连通的已占据位点的极大集合。如果两个已占据位点之间存在一条完全由已占据位点和邻域图（德劳内三角剖分）中的边组成的路径，则它们属于同一个簇。\n\n**4. 贯穿条件**\n\n主要目标是检查是否存在一个“贯穿簇”。\n\n*   **边界定义**：左边界被定义为位点 $(x,y) \\in \\mathcal{P}$ 的集合，其中 $x \\le x_{\\min} + \\Delta_x$。这里，$x_{\\min} = \\min\\{x \\mid (x,y) \\in \\mathcal{P}\\} = 0$。值 $\\Delta_x$ 是连续不同 $x$ 坐标之间最小间距的一半。间距为 $1$ 或 $\\varphi$，所以最小值为 $1$，使得 $\\Delta_x = 0.5$。条件 $x \\le 0.5$ 只会选择 $x=0$ 的位点。\n类似地，右边界由满足 $x \\ge x_{\\max} - \\Delta_x$ 的位点组成。由于 $x_{\\max}$ 前一个坐标最多为 $x_{\\max}-1$，此条件仅选择 $x=x_{\\max}$ 的位点。\n\n*   **贯穿事件**：如果存在至少一个簇，它既包含来自左边界的位点，也包含来自右边界的位点，则发生贯穿事件。\n\n**5. 算法实现**\n\n设计了一个计算算法来实现此模型并测试贯穿条件。\n\n1.  **系统生成**：对于每个参数集 $(k_x, k_y, p, s)$，算法首先生成一维坐标集 $\\{x_i\\}$ 和 $\\{y_j\\}$，然后构建二维点集 $\\mathcal{P}$。\n2.  **图构建**：然后使用科学计算库（例如 `scipy.spatial.Delaunay`）计算 $\\mathcal{P}$ 的德劳内三角剖分。三角剖分的边存储在邻域图的邻接表表示中。\n3.  **逾渗模拟**：创建一个布尔值数组来表示每个位点的占据状态，该状态根据概率 $p$ 和种子 $s$ 确定。\n4.  **贯穿检查**：为了有效地测试贯穿簇，采用了广度优先搜索（BFS）算法。\n    a. 用所有位于左边界上的已占据位点初始化一个队列。使用一个 `visited` 数组来避免重复探索。\n    b. BFS通过探索队列中位点的邻居来进行。搜索被限制为仅遍历同样被占据的邻居。\n    c. 如果BFS到达右边界上的任何位点，则说明已经找到了一条从左到右通过已占据位点的路径。这表示存在一个贯穿簇，该测试用例的结果为 `True`。\n    d. 如果BFS完成而没有到达右边界，则不存在这样的贯穿簇，结果为 `False`。\n\n该算法为所提出的问题提供了一个完整且正确的解决方案。德劳内三角剖分的使用正确地解释了邻域定义，而从一个边界开始的BFS是检测贯穿簇的有效方法。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.spatial import Delaunay\nfrom collections import deque\n\ndef solve():\n    \"\"\"\n    Main function to solve the percolation problem for the given test cases.\n    It iterates through each parameter set, determines if a spanning cluster exists,\n    and prints the results in the specified format.\n    \"\"\"\n    test_cases = [\n        # (k_x, k_y, p, s)\n        (2, 2, 1.0, 0),        # Case A: fully occupied\n        (2, 2, 0.0, 0),        # Case B: no occupation\n        (4, 3, 0.4, 12345),    # Case C: subcritical example\n        (5, 5, 0.55, 2468),    # Case D: near-critical example\n    ]\n\n    results = []\n    for kx, ky, p, s in test_cases:\n        result = check_percolation(kx, ky, p, s)\n        results.append(str(result))\n\n    # Format the final output as specified.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef check_percolation(kx, ky, p, s):\n    \"\"\"\n    Performs the full percolation simulation for a single parameter set.\n\n    Args:\n        kx (int): Iteration count for the x-dimension Fibonacci chain.\n        ky (int): Iteration count for the y-dimension Fibonacci chain.\n        p (float): Occupation probability.\n        s (int): Seed for the pseudo-random number generator.\n\n    Returns:\n        bool: True if a left-to-right spanning cluster exists, False otherwise.\n    \"\"\"\n    phi = (1.0 + np.sqrt(5.0)) / 2.0\n\n    def generate_word(k):\n        \"\"\"Generates the k-th Fibonacci word.\"\"\"\n        if k == 0:\n            return \"L\"\n        w = \"L\"\n        for _ in range(k):\n            next_w = []\n            for char in w:\n                if char == 'L':\n                    next_w.append('LS')\n                else:  # char == 'S'\n                    next_w.append('L')\n            w = \"\".join(next_w)\n        return w\n\n    def generate_coords(word):\n        \"\"\"Generates 1D coordinates from a Fibonacci word.\"\"\"\n        coords = [0.0]\n        current_pos = 0.0\n        for char in word:\n            if char == 'L':\n                current_pos += phi\n            else:  # char == 'S'\n                current_pos += 1.0\n            coords.append(current_pos)\n        return np.array(coords, dtype=np.float64)\n\n    # 1. Generate 1D and 2D point sets\n    word_x = generate_word(kx)\n    word_y = generate_word(ky)\n    x_coords = generate_coords(word_x)\n    y_coords = generate_coords(word_y)\n\n    nx, ny = len(x_coords), len(y_coords)\n    num_points = nx * ny\n    points = np.zeros((num_points, 2), dtype=np.float64)\n    point_idx = 0\n    for i in range(nx):\n        for j in range(ny):\n            points[point_idx] = [x_coords[i], y_coords[j]]\n            point_idx += 1\n\n    # Handle trivial case of p=0.0 early\n    if p == 0.0:\n        return False\n        \n    # Handle single column case, no spanning possible unless nx=1\n    if nx = 1:\n        return p == 1.0 # True if fully occupied (and nx=1), False otherwise\n        \n    # 2. Determine neighborhood graph (Delaunay triangulation)\n    delaunay = Delaunay(points)\n    adj = {i: set() for i in range(num_points)}\n    for simplex in delaunay.simplices:\n        p1, p2, p3 = simplex\n        adj[p1].add(p2)\n        adj[p1].add(p3)\n        adj[p2].add(p1)\n        adj[p2].add(p3)\n        adj[p3].add(p1)\n        adj[p3].add(p2)\n\n    # 3. Perform site percolation\n    rng = np.random.default_rng(s)\n    random_values = rng.random(num_points)\n    occupied = random_values  p\n\n    # 4. Identify boundary sites\n    x_min, x_max = x_coords[0], x_coords[-1]\n    \n    # As derived, left boundary is x=x_min and right is x=x_max\n    left_boundary_indices = np.where(points[:, 0] == x_min)[0]\n    right_boundary_indices = set(np.where(points[:, 0] == x_max)[0])\n\n    # 5. Find spanning cluster using BFS\n    q = deque()\n    visited = np.full(num_points, False, dtype=bool)\n\n    # Initialize queue with occupied sites on the left boundary\n    for idx in left_boundary_indices:\n        if occupied[idx] and not visited[idx]:\n            q.append(idx)\n            visited[idx] = True\n\n    while q:\n        current_idx = q.popleft()\n\n        # Check if the cluster has reached the right boundary\n        if current_idx in right_boundary_indices:\n            return True\n\n        # Explore neighbors\n        for neighbor_idx in adj[current_idx]:\n            if occupied[neighbor_idx] and not visited[neighbor_idx]:\n                visited[neighbor_idx] = True\n                q.append(neighbor_idx)\n\n    # If BFS completes without reaching the right boundary\n    return False\n\nif __name__ == '__main__':\n    solve()\n\n```"
        }
    ]
}