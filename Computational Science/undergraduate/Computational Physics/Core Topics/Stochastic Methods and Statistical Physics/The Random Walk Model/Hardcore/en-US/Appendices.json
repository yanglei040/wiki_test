{
    "hands_on_practices": [
        {
            "introduction": "This first exercise explores the most fundamental property of a random walk. By modeling a lost hiker, we will derive the famous scaling law that governs diffusive processes, showing how the expected distance from the origin grows with the number of steps. This practice solidifies the core mathematical result that the root-mean-square displacement scales as the square root of time or steps, $R_{\\mathrm{RMS}} \\propto \\sqrt{N}$, a cornerstone of statistical physics .",
            "id": "1942197",
            "problem": "A lost hiker is wandering in a large, flat, and featureless desert. The hiker's movement can be modeled as a series of discrete steps. Every hour, the hiker walks for a fixed distance of $L = 2.0$ km in a random direction. The direction of each one-hour walk is independent of the previous ones.\n\nAfter $N$ hours, the hiker's total displacement from the starting point is the vector sum of $N$ individual hourly displacements. A common measure for the typical distance from the starting point after $N$ steps is the root-mean-square (RMS) distance.\n\nCalculate the integer number of hours, $N$, it would take for the hiker's RMS distance from the starting point to be at least $D_{target} = 10$ km. Provide your answer as an integer.",
            "solution": "Let the hourly displacement vectors be $\\{\\mathbf{s}_{i}\\}_{i=1}^{N}$ with $|\\mathbf{s}_{i}|=L$ and independent, isotropically distributed directions. The total displacement after $N$ hours is $\\mathbf{R}_{N}=\\sum_{i=1}^{N}\\mathbf{s}_{i}$. The mean squared displacement is\n$$\n\\mathbb{E}\\left(|\\mathbf{R}_{N}|^{2}\\right)=\\mathbb{E}\\left(\\left(\\sum_{i=1}^{N}\\mathbf{s}_{i}\\right)\\cdot\\left(\\sum_{j=1}^{N}\\mathbf{s}_{j}\\right)\\right)=\\sum_{i=1}^{N}\\mathbb{E}\\left(|\\mathbf{s}_{i}|^{2}\\right)+\\sum_{i\\neq j}\\mathbb{E}\\left(\\mathbf{s}_{i}\\cdot\\mathbf{s}_{j}\\right).\n$$\nIndependence and isotropy imply $\\mathbb{E}(\\mathbf{s}_{i})=\\mathbf{0}$ and $\\mathbb{E}(\\mathbf{s}_{i}\\cdot\\mathbf{s}_{j})=0$ for $i\\neq j$. Since $|\\mathbf{s}_{i}|^{2}=L^{2}$, this yields\n$$\n\\mathbb{E}\\left(|\\mathbf{R}_{N}|^{2}\\right)=N L^{2}.\n$$\nThe RMS distance is therefore\n$$\nR_{\\mathrm{RMS}}=\\sqrt{\\mathbb{E}\\left(|\\mathbf{R}_{N}|^{2}\\right)}=L\\sqrt{N}.\n$$\nWe require $R_{\\mathrm{RMS}}\\geq D_{\\mathrm{target}}$, i.e.,\n$$\nL\\sqrt{N}\\geq D_{\\mathrm{target}}\\quad\\Longrightarrow\\quad N\\geq\\left(\\frac{D_{\\mathrm{target}}}{L}\\right)^{2}.\n$$\nWith $D_{\\mathrm{target}}=10$ and $L=2.0$, we obtain $N\\geq(10/2)^{2}=25$. The minimal integer $N$ satisfying the condition is $25$.",
            "answer": "$$\\boxed{25}$$"
        },
        {
            "introduction": "Having established the basic scaling law, we now introduce a simple but insightful variation: the \"lazy\" random walk. This model includes a probability of the walker remaining stationary at any given step, a feature that can represent physical hesitation or trapping in a medium. This problem challenges you to adapt the standard derivation to see how microscopic rules directly impact the macroscopic diffusion rate, providing a deeper understanding of the model's flexibility .",
            "id": "1942147",
            "problem": "A theoretical physicist is modeling the diffusion of a tardigrade in a dormant state on a two-dimensional surface. The model treats the tardigrade as a point particle on an infinite square lattice, starting at the origin $(0,0)$. The lattice spacing, which is the length of a single step, is denoted by $a$. This particular tardigrade exhibits a \"lazy\" random walk. At each discrete time step, the particle has a probability $p$ of remaining at its current position. If it does decide to move (with probability $1-p$), it moves to one of its four nearest-neighboring lattice sites (up, down, left, or right) with equal probability. This process is repeated for a total of $N$ time steps.\n\nDetermine the mean squared distance of the particle from the origin after $N$ steps. Express your answer as a symbolic expression in terms of $N$, $p$, and $a$.",
            "solution": "Let $\\mathbf{s}_{k}$ denote the random displacement vector during the $k$-th step. The position after $N$ steps is $\\mathbf{R}_{N}=\\sum_{k=1}^{N}\\mathbf{s}_{k}$. The mean squared distance from the origin is\n$$\n\\mathbb{E}\\left[|\\mathbf{R}_{N}|^{2}\\right]=\\mathbb{E}\\left[\\left(\\sum_{k=1}^{N}\\mathbf{s}_{k}\\right)\\cdot\\left(\\sum_{\\ell=1}^{N}\\mathbf{s}_{\\ell}\\right)\\right]\n=\\sum_{k=1}^{N}\\mathbb{E}\\left[|\\mathbf{s}_{k}|^{2}\\right]+2\\sum_{1\\leq k<\\ell\\leq N}\\mathbb{E}\\left[\\mathbf{s}_{k}\\cdot\\mathbf{s}_{\\ell}\\right].\n$$\nBy the step rule, for each $k$,\n- with probability $p$, $\\mathbf{s}_{k}=(0,0)$;\n- with total probability $1-p$, $\\mathbf{s}_{k}$ equals one of $(\\pm a,0)$ or $(0,\\pm a)$, each with probability $\\frac{1-p}{4}$.\n\nBy symmetry, $\\mathbb{E}[\\mathbf{s}_{k}]=\\mathbf{0}$. Hence, using independence of steps,\n$$\n\\mathbb{E}\\left[\\mathbf{s}_{k}\\cdot\\mathbf{s}_{\\ell}\\right]=\\mathbb{E}[\\mathbf{s}_{k}]\\cdot\\mathbb{E}[\\mathbf{s}_{\\ell}]=0 \\quad \\text{for } k\\neq \\ell.\n$$\nMoreover,\n$$\n\\mathbb{E}\\left[|\\mathbf{s}_{k}|^{2}\\right]=a^{2}\\cdot(1-p),\n$$\nsince $|\\mathbf{s}_{k}|^{2}=a^{2}$ whenever a move occurs and $0$ otherwise. Therefore,\n$$\n\\mathbb{E}\\left[|\\mathbf{R}_{N}|^{2}\\right]=\\sum_{k=1}^{N}\\mathbb{E}\\left[|\\mathbf{s}_{k}|^{2}\\right]=N\\,a^{2}(1-p).\n$$\nThus, the mean squared distance from the origin after $N$ steps is $N a^{2}(1-p)$.",
            "answer": "$$\\boxed{N\\,a^{2}\\,(1-p)}$$"
        },
        {
            "introduction": "Many realistic physical systems, such as polymer chains, cannot be described by simple random walks because of constraints like self-avoidance. These models are often analytically intractable, making computational methods essential. This final practice moves from pen-and-paper theory to hands-on programming, where you will implement a \"greedy\" self-avoiding walk and use Monte Carlo simulation to estimate its propertiesâ€”a core technique in computational physics research .",
            "id": "2445687",
            "problem": "Consider a greedy self-avoiding walk on the $d$-dimensional integer lattice $\\mathbb{Z}^d$. Let the walk start at the origin $\\mathbf{0} \\in \\mathbb{Z}^d$. At discrete time $t \\in \\{0,1,2,\\dots\\}$, the position is $\\mathbf{X}_t \\in \\mathbb{Z}^d$, with $\\mathbf{X}_0 = \\mathbf{0}$. Define the set of previously visited sites up to time $t$ as $V_t = \\{\\mathbf{X}_0,\\mathbf{X}_1,\\dots,\\mathbf{X}_t\\}$. The neighbor set of a site $\\mathbf{x} \\in \\mathbb{Z}^d$ is the set of $2d$ lattice sites obtained by adding $\\pm 1$ to exactly one coordinate of $\\mathbf{x}$ and leaving the other coordinates unchanged. The greedy self-avoiding rule is: at time $t$, if there exists at least one neighbor of $\\mathbf{X}_t$ that is not in $V_t$, then $\\mathbf{X}_{t+1}$ is chosen uniformly at random from the unvisited neighbors; otherwise, the walk terminates and we say the walk is trapped. Let $T$ denote the random variable equal to the number of steps taken before the walk becomes trapped (that is, the smallest $t \\in \\{0,1,2,\\dots\\}$ such that all $2d$ neighbors of $\\mathbf{X}_t$ are in $V_t$).\n\nYour tasks are:\n- From the basic definitions of a lattice, nearest-neighbor structure, and uniform selection among available unvisited neighbors, derive an algorithm to simulate a single realization of the greedy self-avoiding walk in $\\mathbb{Z}^d$ starting at $\\mathbf{0}$, and to compute the corresponding path length $T$ for that realization.\n- Using independent repetitions of this simulation, construct an empirical estimator of the expected path length $\\mathbb{E}[T]$ for given dimension $d$ and a specified number of trials $N$. Use a fixed seed for the pseudorandom number generator to ensure reproducibility of the results across runs. No physical units are involved in this problem.\n- Implement a complete, runnable program that, for each parameter triplet $(d,N,s)$ in the test suite below, runs exactly $N$ independent walks in dimension $d$ using pseudorandom seed $s$, computes the empirical mean of the $N$ values of $T$, and reports that mean rounded to $6$ decimal places.\n\nTest suite (each case is a triplet $(d,N,s)$):\n- Case $1$: $(2,200,12345)$.\n- Case $2$: $(2,50,7)$.\n- Case $3$: $(3,20,2024)$.\n- Case $4$: $(2,1,42)$.\n- Case $5$: $(3,1,424242)$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results for the $5$ cases as a comma-separated list enclosed in square brackets, in the same order as listed above (for example, $\\texttt{[result1,result2,result3,result4,result5]}$). Each result must be the empirical mean path length for that case, rounded to $6$ decimal places. Angles are not involved, so there is no angle unit specification. Express all numeric outputs as plain decimal numbers without any percentage signs.",
            "solution": "The problem statement has been subjected to rigorous validation and is determined to be valid. It is scientifically grounded, well-posed, and objective. It describes a clear computational task based on the established model of a greedy self-avoiding random walk. The request to compute an empirical mean path length is a well-defined statistical estimation problem, regardless of whether the true expected path length is finite or infinite. We now proceed to the derivation and implementation of the solution.\n\nThe problem requires the development of an algorithm to simulate a greedy self-avoiding walk on a $d$-dimensional integer lattice, $\\mathbb{Z}^d$. The primary objective is to compute the empirical mean of the path length, $T$, over a specified number of trials, $N$. The path length $T$ is defined as the number of steps taken until the walker becomes trapped.\n\nThe core of the solution is a function that simulates a single realization of the walk. To ensure computational efficiency, specific data structures are chosen. A position vector $\\mathbf{x} \\in \\mathbb{Z}^d$ is represented as a tuple of $d$ integers, which is an immutable type suitable for use as a key in a hash map or an element in a set. The set of all visited sites, $V_t$, is maintained as a Python `set` object to allow for average $O(1)$ time complexity for insertion and membership testing, which are the fundamental operations in a self-avoiding walk simulation.\n\nThe simulation of a single walk proceeds as follows:\n$1$. Initialization: The walk begins at the origin, so the initial position is $\\mathbf{X}_0 = (0, 0, \\dots, 0)$. The current time step $t$ is initialized to $0$. The set of visited sites is initialized as $V_0 = \\{ \\mathbf{X}_0 \\}$.\n$2$. Iterative Process: The simulation advances in a loop. At each time step $t$, with the walker at position $\\mathbf{X}_t$:\n    a. Neighbor Identification: The set of all $2d$ nearest neighbors of $\\mathbf{X}_t$ is generated. A neighbor is a site reached by changing a single coordinate of $\\mathbf{X}_t$ by $\\pm 1$.\n    b. Filtering for Available Moves: This set of neighbors is filtered to produce a list of unvisited neighbors, i.e., those sites not present in the current visited set $V_t$.\n    c. Trapping Condition: If the list of unvisited neighbors is empty, it signifies that the walker is trapped. The walk terminates. The path length for this realization is $T = t$, which is the total number of steps taken.\n    d. State Transition: If unvisited neighbors exist, the next position, $\\mathbf{X}_{t+1}$, is chosen uniformly at random from this list. The time step is incremented, $t \\leftarrow t + 1$. The new position $\\mathbf{X}_{t+1}$ becomes the current position for the next iteration, and it is added to the visited set, $V_{t+1} = V_t \\cup \\{ \\mathbf{X}_{t+1} \\}$.\n$3$. Termination: The loop continues until the trapping condition is met. The final value of $t$ is returned as the path length $T$.\n\nTo estimate the expected path length, $\\mathbb{E}[T]$, we employ the Monte Carlo method. For each test case, specified by a triplet $(d, N, s)$ for dimension, number of trials, and random seed respectively, the following procedure is executed:\n$1$. A pseudo-random number generator is initialized with the given seed $s$ to ensure reproducibility. For this task, `numpy.random.default_rng` is the appropriate tool.\n$2$. A loop runs for $N$ iterations. In each iteration $i \\in \\{1, \\dots, N\\}$, a single walk is simulated as described above, yielding a path length $T_i$.\n$3$. The empirical mean path length is computed as the arithmetic mean of the observed path lengths:\n$$\n\\hat{\\mu}_T = \\frac{1}{N} \\sum_{i=1}^{N} T_i\n$$\n$4$. This mean value is then rounded to $6$ decimal places as required.\n\nThis entire procedure is encapsulated within a program that processes the given test suite. For each case, it computes the corresponding mean path length and aggregates the results into a single output line in the specified format.",
            "answer": "```python\nimport numpy as np\n\ndef calculate_mean_path_length(dimension, num_trials, seed):\n    \"\"\"\n    Simulates N greedy self-avoiding walks in d dimensions and calculates the\n    empirical mean path length.\n\n    Args:\n        dimension (int): The dimension d of the lattice Z^d.\n        num_trials (int): The number of independent walks N to simulate.\n        seed (int): The seed for the pseudorandom number generator.\n\n    Returns:\n        float: The empirical mean path length, rounded to 6 decimal places.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    path_lengths = []\n\n    for _ in range(num_trials):\n        path_lengths.append(_simulate_one_walk(dimension, rng))\n\n    mean_length = np.mean(path_lengths)\n    return round(mean_length, 6)\n\ndef _get_neighbors(pos, dimension):\n    \"\"\"\n    Generates all 2d nearest neighbors for a given position on the lattice.\n\n    Args:\n        pos (tuple): The current position coordinates.\n        dimension (int): The dimension of the lattice.\n\n    Yields:\n        tuple: A neighbor's coordinates.\n    \"\"\"\n    pos_list = list(pos)\n    for i in range(dimension):\n        # Positive direction\n        pos_list[i] += 1\n        yield tuple(pos_list)\n        pos_list[i] -= 1  # Reset coordinate\n\n        # Negative direction\n        pos_list[i] -= 1\n        yield tuple(pos_list)\n        pos_list[i] += 1  # Reset coordinate\n\ndef _simulate_one_walk(dimension, rng):\n    \"\"\"\n    Simulates a single greedy self-avoiding walk until it is trapped.\n\n    Args:\n        dimension (int): The dimension of the lattice.\n        rng (numpy.random.Generator): The random number generator to use.\n\n    Returns:\n        int: The number of steps (path length T) until trapping.\n    \"\"\"\n    # Start at the origin\n    current_pos = tuple([0] * dimension)\n    # Keep track of visited sites for self-avoidance\n    visited_sites = {current_pos}\n    steps = 0\n\n    while True:\n        # Find all unvisited neighbors\n        unvisited_neighbors = [\n            n for n in _get_neighbors(current_pos, dimension) if n not in visited_sites\n        ]\n\n        # If no unvisited neighbors exist, the walk is trapped\n        if not unvisited_neighbors:\n            return steps\n\n        # Choose the next step uniformly at random from available neighbors\n        next_pos_index = rng.integers(len(unvisited_neighbors))\n        current_pos = unvisited_neighbors[next_pos_index]\n        \n        visited_sites.add(current_pos)\n        steps += 1\n\ndef solve():\n    \"\"\"\n    Runs the simulation for all test cases and prints the results\n    in the specified format.\n    \"\"\"\n    test_cases = [\n        (2, 200, 12345),\n        (2, 50, 7),\n        (3, 20, 2024),\n        (2, 1, 42),\n        (3, 1, 424242),\n    ]\n\n    results = []\n    for d, N, s in test_cases:\n        result = calculate_mean_path_length(d, N, s)\n        results.append(result)\n\n    # Format and print the final output string\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}