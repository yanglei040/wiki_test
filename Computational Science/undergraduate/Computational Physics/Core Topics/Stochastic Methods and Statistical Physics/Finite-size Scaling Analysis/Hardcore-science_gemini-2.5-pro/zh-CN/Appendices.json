{
    "hands_on_practices": [
        {
            "introduction": "二维伊辛模型是统计物理学中研究相变的典范模型。本练习将通过精确计算小尺寸系统的热力学量，带你深入探索有限尺寸标度的基础。你将亲手计算磁化率，并观察系统尺寸和边界条件（开放与周期性）如何实实在在地影响其峰值位置，即伪临界温度 。",
            "id": "2394487",
            "problem": "考虑一个在$L\\times L$方格点阵上的铁磁二维伊辛模型，其自旋变量为$s_i\\in\\{-1,+1\\}$，耦合常数$J0$，且外场为零。其哈密顿量为\n$$\n\\mathcal{H}(\\{s\\})=-J\\sum_{\\langle i,j\\rangle}s_is_j,\n$$\n其中，求和遍及所有最近邻对$\\langle i,j\\rangle$，每对只计算一次。需要考虑两种边界条件：开放边界条件和周期性边界条件。在开放边界条件下，一个格点的邻居仅指在$L\\times L$网格内与之相邻且没有任何环绕连接的格点。在周期性边界条件下，邻居关系包含环绕连接，因此该点阵在拓扑上构成一个环面。\n\n对于给定的温度$T0$和系统尺寸$L$，定义配分函数\n$$\nZ(T,L)=\\sum_{\\{s\\}}\\exp\\left(-\\frac{\\mathcal{H}(\\{s\\})}{k_{\\mathrm{B}}T}\\right),\n$$\n以及总磁化强度$M(\\{s\\})=\\sum_i s_i$的热力学平均值为\n$$\n\\langle M\\rangle_{T,L}=\\frac{1}{Z(T,L)}\\sum_{\\{s\\}} M(\\{s\\})\\exp\\left(-\\frac{\\mathcal{H}(\\{s\\})}{k_{\\mathrm{B}}T}\\right),\n$$\n$$\n\\langle M^2\\rangle_{T,L}=\\frac{1}{Z(T,L)}\\sum_{\\{s\\}} M(\\{s\\})^2\\exp\\left(-\\frac{\\mathcal{H}(\\{s\\})}{k_{\\mathrm{B}}T}\\right).\n$$\n单位自旋的零场磁化率定义为\n$$\n\\chi(T,L)=\\frac{1}{k_{\\mathrm{B}}TN}\\left(\\langle M^2\\rangle_{T,L}-\\langle M\\rangle_{T,L}^2\\right),\\quad N=L^2.\n$$\n\n对于本问题，采用无量纲单位$J=1$和$k_{\\mathrm{B}}=1$，因此温度以$J/k_{\\mathrm{B}}$为单位进行度量。对于每个指定的$(L,\\text{边界})$对，将有限尺寸赝临界温度$T_c(L)$操作上定义为离散温度集合\n$$\n\\mathcal{T}=\\{T\\,\\mid\\,T=1.00+0.02\\,n,\\ n\\in\\mathbb{Z},\\ 0\\le n\\le 150\\}\n$$\n中使$\\chi(T,L)$达到其最大值的温度。如果$\\chi(T,L)$在$\\mathcal{T}$中的多个温度下都达到最大值，则取$T_c(L)$为这些温度中的最小值。\n\n您的任务是为以下测试套件中的每种情况计算$T_c(L)$：\n- 情况 $1$：$L=2$，开放边界条件。\n- 情况 $2$：$L=2$，周期性边界条件。\n- 情况 $3$：$L=3$，开放边界条件。\n- 情况 $4$：$L=3$，周期性边界条件。\n- 情况 $5$：$L=4$，开放边界条件。\n- 情况 $6$：$L=4$，周期性边界条件。\n\n所有结果必须以$J/k_{\\mathrm{B}}$为单位表示，并四舍五入到小数点后$3$位。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按情况$1$到$6$的顺序列出结果（例如，$[x_1,x_2,x_3,x_4,x_5,x_6]$），其中每个$x_i$是按规定格式表示的浮点数。",
            "solution": "问题陈述已经过严格验证。我们发现它具有科学依据、是适定的且客观的。它植根于统计力学的标准框架，特别是二维伊辛模型，该模型是该领域的基石。所有参数、定义和步骤都已足够清晰和精确地指定，从而能够得出一个唯一的、可验证的解。因此，该问题被认为是有效的，采用直接计算方法是合适的。\n\n任务是计算$L \\times L$点阵上铁磁二维伊辛模型的有限尺寸赝临界温度$T_c(L)$。该温度被定义为在指定的离散集合$\\mathcal{T}$内，使单位自旋的零场磁化率$\\chi(T,L)$达到最大值的点。\n\n指定的系统尺寸（$L=2, 3, 4$）很小，使得问题可以通过精确枚举来解决。可能的自旋构型（或称微观态）总数为$2^N$，其中$N=L^2$。对于最大的系统$L=4$，这相当于$2^{16} = 65536$个状态，这个数量在计算上是微不足道的，易于处理。\n\n系统化的方法如下：\n\n首先，对于由系统尺寸$L$和边界条件类型（开放或周期性）定义的每种指定情况，我们将构建精确的态密度，记为$g(E, M)$。此函数计算具有特定总能量$E$和特定总磁化强度$M$的不同自旋构型$\\{\\text{s}\\}$的数量。能量由哈密顿量在无量纲单位$J=1$下计算得出：\n$$ E = \\mathcal{H}(\\{s\\}) = -\\sum_{\\langle i,j \\rangle} s_i s_j $$\n磁化强度是所有自旋的总和：\n$$ M = \\sum_{i=1}^{N} s_i $$\n态密度通过系统地遍历所有$2^N$种可能的构型，为每种构型计算$(E,M)$，并增加相应计数器的值来计算。\n\n其次，在确定了态密度$g(E,M)$之后，我们可以高效地计算任何温度$T$下所需的热力学量。配分函数$Z(T,L)$由对所有唯一的能量和磁化强度对的求和给出：\n$$ Z(T,L) = \\sum_{E, M} g(E,M) \\exp\\left(-\\frac{E}{T}\\right) $$\n这里，我们使用了无量纲设定，其中玻尔兹曼常数$k_{\\mathrm{B}}=1$。\n\n第三，我们计算单位自旋的磁化率$\\chi(T,L)$。其一般定义为：\n$$ \\chi(T,L) = \\frac{1}{T N} \\left( \\langle M^2 \\rangle_{T,L} - \\langle M \\rangle_{T,L}^2 \\right) $$\n由于在零外磁场中哈密顿量具有自旋翻转对称性，对于任何有限系统在非零温度下，平均磁化强度$\\langle M \\rangle_{T,L}$恒等于零。因此，磁化率的表达式简化为：\n$$ \\chi(T,L) = \\frac{1}{T N} \\langle M^2 \\rangle_{T,L} $$\n磁化强度平方的热平均值$\\langle M^2 \\rangle_{T,L}$计算如下：\n$$ \\langle M^2 \\rangle_{T,L} = \\frac{1}{Z(T,L)} \\sum_{E, M} g(E,M) M^2 \\exp\\left(-\\frac{E}{T}\\right) $$\n\n最后，为了确定$T_c(L)$，我们对所提供的离散集合$\\mathcal{T} = \\{T \\mid T=1.00+0.02n, n \\in \\{0, 1, \\dots, 150\\}\\}$中的每个温度$T$计算$\\chi(T,L)$。$T_c(L)$的值是$\\chi(T,L)$达到其最大值时的温度。问题规定，在出现平局的情况下，应选择产生最大磁化率的最小温度。通过按升序遍历温度，并且仅在发现$\\chi$的严格更大值时才更新$T_c(L)$的候选值，我们严格遵守了此规则。\n\n这个完整的算法将为六个测试用例中的每一个实现，以生成所需的结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import defaultdict\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n    test_cases = [\n        (2, 'obc'), (2, 'pbc'),\n        (3, 'obc'), (3, 'pbc'),\n        (4, 'obc'), (4, 'pbc'),\n    ]\n\n    temperatures = np.linspace(1.0, 1.00 + 0.02 * 150, 151)\n    \n    final_results = []\n\n    for L, bc in test_cases:\n        N = L * L\n        dos = defaultdict(int)\n        \n        # Iterate through all 2^N spin configurations\n        for i in range(1  N):\n            spins = [(2 * ((i >> j)  1) - 1) for j in range(N)]\n            \n            energy = 0\n            # Calculate energy by summing over right and down neighbors to avoid double counting\n            for idx in range(N):\n                y, x = divmod(idx, L)\n                \n                # Interaction with right neighbor\n                if x  L - 1:\n                    energy -= spins[idx] * spins[idx + 1]\n                elif bc == 'pbc':\n                    energy -= spins[idx] * spins[y * L]\n\n                # Interaction with down neighbor\n                if y  L - 1:\n                    energy -= spins[idx] * spins[idx + L]\n                elif bc == 'pbc':\n                    energy -= spins[idx] * spins[x]\n            \n            magnetization = sum(spins)\n            dos[(energy, magnetization)] += 1\n\n        max_chi = -1.0\n        tc = -1.0\n        \n        for T in temperatures:\n            Z = 0.0\n            M2_sum = 0.0\n            for (energy_val, mag_val), count in dos.items():\n                if T == 0: continue\n                boltzmann_factor = np.exp(-energy_val / T)\n                Z += count * boltzmann_factor\n                M2_sum += count * (mag_val**2) * boltzmann_factor\n            \n            if Z > 0:\n                m2_avg = M2_sum / Z\n                chi = m2_avg / (N * T)\n            else:\n                chi = 0.0\n            \n            if chi > max_chi:\n                max_chi = chi\n                tc = T\n        \n        final_results.append(tc)\n\n    formatted_results = [f\"{res:.3f}\" for res in final_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在上一个练习中我们看到，有限系统的伪临界温度会随尺寸变化。那么，如何从这些有限尺寸的数据中推断出无限大系统（即热力学极限）中真实的临界温度 $T_c$ 呢？本练习将指导你运用基于标度理论的拟合方法，对有限尺寸数据进行外推，这是有限尺寸标度分析中的一个核心应用 。",
            "id": "2394503",
            "problem": "您的任务是执行一个基于原理的有限尺寸标度 (FSS) 分析，来估计一个在方形晶格上具有竞争性最近邻 ($J_1$) 和次近邻 ($J_2$) 相互作用的二维 (2D) Ising 模型的热力学极限相界。考虑铁磁区 $J_1  0$ 和 $J_2 \\ge 0$ 的情况，其中当 $J_2/J_1$ 低于某一阈值时，有限温度相变是连续的，并且属于标准的二维 Ising 普适类。温度以 $J_1/k_{\\mathrm{B}}$ 为单位表示。\n\n从平衡相关长度 $\\xi$ 在连续相变附近发散的基本定义 $\\xi \\sim \\xi_0 \\lvert t \\rvert^{-\\nu}$ 出发，其中 $t = (T - T_{\\mathrm{c}})/T_{\\mathrm{c}}$ 是约化温度，$\\nu$ 是相关长度临界指数，并利用一个经过充分检验的事实，即对于二维 Ising 普适类有 $\\nu = 1$，请从第一性原理出发，论证一个线性尺寸为 $L$ 的有限系统如何对 $\\xi$ 施加一个截断，从而使热力学奇点变得圆滑和发生偏移。特别地，对于由有限尺寸 $L$ 下磁化率最大值位置定义的赝临界温度 $T^*_L$，请在 $L \\to \\infty$ 的极限下，为热力学临界温度 $T_{\\mathrm{c}}$ 给出一个合理的估计量。您的估计量必须遵循当 $\\xi(T) \\sim \\mathcal{O}(L)$ 时奇点被圆滑处理的逻辑，并且可以包含与此框架一致的次领头解析修正。\n\n实现一个程序，该程序在给定固定 $J_2/J_1$ 下多个 $L$ 的有限尺寸赝临界温度 $T^*_L$ 后，拟合一个与 FSS 推理一致的模型，然后将 $T^*_L$ 外推到 $L \\to \\infty$ 以估计 $T_{\\mathrm{c}}(J_2/J_1)$。为了数值稳定性和考虑次领头修正，您必须使用一个关于 $L^{-1}$ 的最高到二次的多项式来对 $T^*_L$ 作为 $L$ 的函数进行建模，并在此表示中提取 $L \\to \\infty$ 极限作为截距。报告所有温度，以 $J_1/k_{\\mathrm{B}}$ 为单位，并四舍五入到 $9$ 位小数。\n\n测试套件和数据（所有温度均以 $J_1/k_{\\mathrm{B}}$ 为单位）：\n- 使用系统尺寸 $L \\in \\{10, 20, 40, 80\\}$。\n- 对于 $J_2/J_1 = 0.0$，当 $L = 10, 20, 40, 80$ 时，赝临界温度分别为 $2.394185314$、$2.330435314$、$2.299497814$、$2.284263439$。\n- 对于 $J_2/J_1 = 0.1$，当 $L = 10, 20, 40, 80$ 时，赝临界温度分别为 $2.16795863574$、$2.11570863574$、$2.09014613574$、$2.07750551074$。\n- 对于 $J_2/J_1 = 0.2$，当 $L = 10, 20, 40, 80$ 时，赝临界温度分别为 $1.94273195748$、$1.90123195748$、$1.88085695748$、$1.87076320748$。\n\n您的程序必须：\n- 在每个 $J_2/J_1$ 值下，实现 $T^*_L$ 对一个最高到二次的 $L^{-1}$ 多项式基的回归，以估计对应于 $L \\to \\infty$ 的截距。\n- 以单行形式生成最终输出，其中包含三个估计的 $T_{\\mathrm{c}}$ 值（以 $J_1/k_{\\mathrm{B}}$ 为单位）的逗号分隔列表，四舍五入到 $9$ 位小数，并用方括号括起来。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，例如，“[x0,x1,x2]”。请将“x0,x1,x2”替换为您的三个浮点数结果，每个结果都精确显示小数点后 $9$ 位，且不含空格。",
            "solution": "所提出的问题是计算统计力学中的一个标准练习，具体涉及应用有限尺寸标度理论将有限系统的数值数据外推到热力学极限。该问题具有科学依据，提法明确，并包含获得唯一解所需的所有信息。因此，我将着手对求解方法进行基于原理的推导。\n\n连续相变理论的基石是，当温度 $T$ 接近临界温度 $T_{\\mathrm{c}}$ 时，平衡相关长度 $\\xi$ 会发散。这种发散由一个幂律描述：\n$$\n\\xi(T) \\sim \\xi_0 \\lvert t \\rvert^{-\\nu}\n$$\n其中 $t = (T - T_{\\mathrm{c}})/T_{\\mathrm{c}}$ 是约化温度，$\\xi_0$ 是一个非普适振幅，$\\nu$ 是一个普适临界指数。对于指定的问题，系统属于二维 ($2\\mathrm{D}$) Ising 普适类，对于该普适类，相关长度指数为 $\\nu = 1$ 是一个精确结果。因此，在 $T_{\\mathrm{c}}$ 附近，相关长度的行为如下：\n$$\n\\xi(T) \\sim \\xi_0 \\lvert T - T_{\\mathrm{c}} \\rvert^{-1}\n$$\n\n在任何实际的模拟或实验中，系统尺寸都是有限的，由一个线性维度 $L$ 来表征。一个有限系统无法维持比其自身尺寸更大的长度尺度上的涨落。这给相关长度施加了一个有效截断，$\\xi_L(T) \\le L$。因此，在热力学极限 ($L \\to \\infty$) 下存在于 $T_{\\mathrm{c}}$ 处的尖锐奇点，在有限系统中会被圆滑化并发生偏移。响应函数（如磁化率）在 $L \\to \\infty$ 时于 $T_{\\mathrm{c}}$ 处发散，但在有限系统中，它们会在一个依赖于系统尺寸的赝临界温度 $T^*_L$ 处呈现一个有限的峰值。\n\n有限尺寸标度假设假定，当热力学相关长度 $\\xi(T)$ 变得与系统尺寸 $L$ 相当时，这种圆滑效应起主导作用。因此，峰值的位置 $T^*_L$ 由以下条件确定：\n$$\n\\xi(T^*_L) \\sim L\n$$\n将 $\\xi$ 的标度形式代入，并设 $\\nu = 1$，可得：\n$$\n\\xi_0 \\lvert T^*_L - T_{\\mathrm{c}} \\rvert^{-1} \\sim L\n$$\n重新整理这个关系式可以揭示，随着 $L$ 的增加，赝临界温度 $T^*_L$ 是如何趋近于真实临界温度 $T_{\\mathrm{c}}$ 的：\n$$\n\\lvert T^*_L - T_{\\mathrm{c}} \\rvert \\sim L^{-1}\n$$\n这意味着对于大的 $L$，$T^*_L$ 相对于 $L^{-1}$ 的图像应是线性的，并且在 $L^{-1} = 0$（即 $L \\to \\infty$）处的截距将给出热力学临界温度 $T_{\\mathrm{c}}$。我们可以将其写成一个形式展开式：\n$$\nT^*_L = T_{\\mathrm{c}} + c_1 L^{-1} + \\dots\n$$\n其中 $c_1$ 是一个非普适常数。\n\n更高级的标度理论考虑了次领头修正，这些修正来源于非相关标度场或解析背景贡献。赝临界温度偏移的一般形式为：\n$$\nT^*_L = T_{\\mathrm{c}} + a_{1} L^{-1/\\nu} + a_{2} L^{-(\\omega + 1/\\nu)} + \\dots\n$$\n其中 $\\omega  0$ 是领头的标度修正指数。对于二维 Ising 普适类，$\\nu=1$，该式变为：\n$$\nT^*_L = T_{\\mathrm{c}} + a_{1} L^{-1} + a_{2} L^{-(1+\\omega)} + \\dots\n$$\n问题指定使用一个关于 $L^{-1}$ 的最高到二次的多项式作为模型。这是一种务实且稳健的方法，特别是当 $\\omega$ 的值没有高精度已知，或者数据质量不足以解析多个非整数指数时。因此，我们采用以下拟合函数：\n$$\nT^*_L = C_0 + C_1 L^{-1} + C_2 L^{-2}\n$$\n在这个模型中，参数 $C_0$ 代表在热力学极限 $L \\to \\infty$ 下的外推值，因此它就是我们对真实临界温度 $T_{\\mathrm{c}}$ 的估计量。$C_1 L^{-1}$ 项捕捉了领头的有限尺寸标度行为，而 $C_2 L^{-2}$ 项则为领头的次领头修正（无论其确切来源如何）提供了一个有效的表示。\n\n为了确定系数 $C_0, C_1$ 和 $C_2$，我们执行线性最小二乘回归。对于每个对应于固定比率 $J_2/J_1$ 的数据集，我们都有一组测量值 $(L_i, T^*_{L_i})$。我们寻求系数向量 $\\mathbf{C} = [C_0, C_1, C_2]^T$，以最小化残差平方和：\n$$\n\\chi^2 = \\sum_{i} \\left( T^*_{L_i} - (C_0 + C_1 L_i^{-1} + C_2 L_i^{-2}) \\right)^2\n$$\n这是一个标准的线性代数问题，可以通过构建一个设计矩阵 $\\mathbf{A}$ 来求解，其中每一行对应一个系统尺寸 $L_i$ 并由 $[1, L_i^{-1}, L_i^{-2}]$ 给出，同时构建一个观测向量 $\\mathbf{b}$，其元素为 $T^*_{L_i}$。通过求解正规方程组 $(\\mathbf{A}^T \\mathbf{A})\\mathbf{C} = \\mathbf{A}^T \\mathbf{b}$ 即可找到解。得到的系数 $C_0$ 就是所求的 $T_{\\mathrm{c}}$ 的估计值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Performs a finite-size scaling analysis to estimate the critical temperature\n    of a 2D Ising model with J1-J2 interactions.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each case includes system sizes L and corresponding pseudocritical\n    # temperatures T_star. Temperatures are in units of J1/k_B.\n    test_cases = [\n        {\n            # Case for J2/J1 = 0.0\n            'L': np.array([10, 20, 40, 80], dtype=np.float64),\n            'T_star': np.array([2.394185314, 2.330435314, 2.299497814, 2.284263439], dtype=np.float64)\n        },\n        {\n            # Case for J2/J1 = 0.1\n            'L': np.array([10, 20, 40, 80], dtype=np.float64),\n            'T_star': np.array([2.16795863574, 2.11570863574, 2.09014613574, 2.07750551074], dtype=np.float64)\n        },\n        {\n            # Case for J2/J1 = 0.2\n            'L': np.array([10, 20, 40, 80], dtype=np.float64),\n            'T_star': np.array([1.94273195748, 1.90123195748, 1.88085695748, 1.87076320748], dtype=np.float64)\n        }\n    ]\n\n    estimated_tc_values = []\n\n    for case in test_cases:\n        L = case['L']\n        T_star = case['T_star']\n\n        # The fitting model is a polynomial in L^-1 up to quadratic order:\n        # T_star(L) = C0 + C1 * L^-1 + C2 * L^-2\n        # We need to solve a linear least-squares problem for the coefficients [C0, C1, C2].\n        # C0 is the estimate for T_c in the thermodynamic limit (L -> infinity).\n\n        # Construct the design matrix 'A' for the linear system A*x = b.\n        # The columns of A are the basis functions: L^0, L^-1, L^-2.\n        L_inv = 1.0 / L\n        A = np.vstack([np.ones_like(L), L_inv, L_inv**2]).T\n        \n        # The vector of observations 'b' contains the T_star values.\n        b = T_star\n        \n        # Solve the linear least squares problem A*x = b for x = [C0, C1, C2].\n        # numpy.linalg.lstsq returns the solution vector as the first element.\n        coeffs = np.linalg.lstsq(A, b, rcond=None)[0]\n        \n        # The extrapolated critical temperature Tc is the intercept, C0.\n        tc_estimate = coeffs[0]\n        estimated_tc_values.append(tc_estimate)\n\n    # Format the results as specified: a list of floats rounded to 9 decimal places,\n    # comma-separated, and enclosed in square brackets. No spaces.\n    formatted_results = [f\"{tc:.9f}\" for tc in estimated_tc_values]\n    output_string = f\"[{','.join(formatted_results)}]\"\n    \n    # Final print statement in the exact required format.\n    print(output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "数据坍缩是验证有限尺寸标度假设的最有力证据，它能将不同尺寸下的数据曲线“折叠”到一条普适的标度函数曲线上。这个高级练习将引导你实现一个自动化算法，通过数值优化来寻找最佳的标度指数，从而实现最优的数据坍缩。这不仅是一个定性的视觉检查，更是一种强大的定量分析工具 。",
            "id": "2394510",
            "problem": "给定一个通用的有限尺寸标度问题，其核心是通过重标定坐标轴，将一个可观测量的多条曲线塌缩到一条主曲线上。其科学背景是连续相变点附近的有限尺寸标度假设。设某个可观测量记为 $m(L,t)$，其中 $L$ 是系统尺寸，$t$ 是一个无量纲的约化控制参数（例如，约化温度）。有限尺寸标度假设指出，存在指数组合 $p$ 和 $q$ 以及一个无量纲的标度函数 $F(\\cdot)$，使得重标定的变量\n$$\nx = t \\, L^{p}, \\quad y = m(L,t) \\, L^{q}\n$$\n在使用正确的指数 $p$ 和 $q$ 时，能够将来自不同 $L$ 的数据塌缩到一条共同的、与尺寸无关的主曲线 $y = F(x)$ 上。在热力学极限下，这一论述得到了重整化群论证的支持，并且是计算物理学中标准有限尺寸标度范式的一部分。\n\n您的任务是实现一个算法，通过数值优化 $p$ 和 $q$ 的选择，来最小化塌缩后曲线的上下包络线之间的面积，从而自动执行数据塌缩。为了精确定义这个算法目标：给定一组由 $j$ 索引的曲线，在按上述方式重标定为 $(x_j, y_j)$ 后，将其公共定义域 $[x_{\\min}, x_{\\max}]$ 定义为所有单个 $x$ 区间的交集。在 $[x_{\\min}, x_{\\max}]$ 内的一个包含 $N_g$ 个点的均匀网格上，对每条曲线 $y_j(x)$ 进行线性插值，计算每个网格点上的散布 $w(x) = \\max_j y_j(x) - \\min_j y_j(x)$，并将目标定义为定义域上的平均散布\n$$\n\\mathcal{A}(p,q) = \\frac{1}{x_{\\max} - x_{\\min}} \\int_{x_{\\min}}^{x_{\\max}} \\left[ \\max_j y_j(x) - \\min_j y_j(x) \\right] \\, dx.\n$$\n使用梯形法则对该积分进行数值近似。如果公共定义域为空或小到可以忽略，则将 $\\mathcal{A}(p,q)$ 视为一个非常大的值，以避免选择此类参数。该算法必须搜索能最小化 $\\mathcal{A}(p,q)$ 的 $p$ 和 $q$。\n\n算法和实现要求：\n- 使用适合非凸问题的无导数数值优化器。\n- 使用包含 $N_g = 401$ 个点的均匀网格来评估积分和包络线宽度。\n- 在公共定义域上对 $y_j(x)$ 使用线性插值。\n- 将 $p$ 和 $q$ 的搜索范围限制在合理的边界内：$p \\in [0.5, 1.5]$，$q \\in [0.05, 0.25]$。\n- 不涉及物理单位；所有变量均为无量纲。\n\n测试套件：\n根据以下公式构建合成数据集\n$$\nm(L,t) = L^{-q_{\\mathrm{true}}} \\, F\\!\\left(t \\, L^{p_{\\mathrm{true}}}\\right),\n$$\n其中标度函数为\n$$\nF(u) = \\left[ 1 + (a\\,u)^2 \\right]^{-b},\n$$\n该函数对于所有实数 $u$ 都是平滑且为正的。对于有噪声的情况，添加独立的、均值为零的高斯噪声，其标准差等于该数据集无噪声 $m(L,t)$ 值中位数的一个指定分数。为保证可复现性，每个案例使用固定的随机种子。\n\n提供以下三个测试案例。对于每个案例，构建 $n_L$ 个系统尺寸 $\\{L\\}$，一个在 $[t_{\\min}, t_{\\max}]$ 上包含 $N_t$ 个点的均匀网格 $t$，然后按上述方式计算 $m(L,t)$。\n\n- 案例 1（无噪声，典型指数）：\n  - 参数：$p_{\\mathrm{true}} = 1.0$, $q_{\\mathrm{true}} = 0.125$, $a = 2.0$, $b = 0.5$。\n  - 系统尺寸：$L \\in \\{16, 32, 64, 128\\}$（即 $n_L = 4$）。\n  - 网格：$t \\in [-0.30, 0.30]$，包含 $N_t = 241$ 个均匀分布的点。\n  - 噪声：无（标准差等于 $0$），种子不适用。\n\n- 案例 2（有噪声，指数与案例 1 相同）：\n  - 参数：$p_{\\mathrm{true}} = 1.0$, $q_{\\mathrm{true}} = 0.125$, $a = 2.0$, $b = 0.5$。\n  - 系统尺寸：$L \\in \\{16, 32, 64, 128\\}$。\n  - 网格：$t \\in [-0.30, 0.30]$，包含 $N_t = 241$ 个均匀分布的点。\n  - 噪声：高斯噪声，标准差为每个 $L$ 的无噪声 $m(L,t)$ 值中位数的 $0.02$ 倍，种子为 $123$。\n\n- 案例 3（不同指数和中等噪声）：\n  - 参数：$p_{\\mathrm{true}} = 0.9$, $q_{\\mathrm{true}} = 0.2$, $a = 1.5$, $b = 0.8$。\n  - 系统尺寸：$L \\in \\{12, 24, 48, 96\\}$。\n  - 网格：$t \\in [-0.40, 0.40]$，包含 $N_t = 241$ 个均匀分布的点。\n  - 噪声：高斯噪声，标准差为每个 $L$ 的无噪声 $m(L,t)$ 值中位数的 $0.01$ 倍，种子为 $456$。\n\n您的程序必须：\n- 按照上述规范为每个测试案例实现合成数据生成。\n- 实现目标函数 $\\mathcal{A}(p,q)$，即在一个包含 $N_g = 401$ 个点的网格上，使用线性插值和梯形积分计算的定义域平均包络线宽度。当公共定义域为空或极小时，返回一个大的惩罚值。\n- 在 $p \\in [0.5, 1.5]$ 和 $q \\in [0.05, 0.25]$ 的范围内数值最小化 $\\mathcal{A}(p,q)$，以估计每个案例的 $(p, q)$。\n- 生成单行输出，其中包含一个逗号分隔的列表，列表被方括号包围。每个结果必须是一个包含两个浮点数 $[p_{\\mathrm{est}}, q_{\\mathrm{est}}]$ 的列表，并四舍五入到恰好三位小数。对于这三个案例，输出格式必须为\n  $$\n  \\left[ [p_{\\mathrm{est}}^{(1)}, q_{\\mathrm{est}}^{(1)}], [p_{\\mathrm{est}}^{(2)}, q_{\\mathrm{est}}^{(2)}], [p_{\\mathrm{est}}^{(3)}, q_{\\mathrm{est}}^{(3)}] \\right].\n  $$\n除了这一行包含列表的输出外，不应打印任何其他文本。",
            "solution": "我们从核心的有限尺寸标度假设出发：在连续相变点附近，对于一个可观测量 $m(L,t)$，存在指数组合 $p$ 和 $q$ 以及一个标度函数 $F(\\cdot)$，使得 $m(L,t) = L^{-q} F(t L^{p})$。这一论述基于重整化群的考虑以及一个假设，即在临界点，唯一相关的尺度是系统尺寸与关联长度之比，这为在适当重标定变量后数据能够塌缩提供了理论依据。\n\n为了通过计算来检测正确的指数，我们定义一个量化指标来衡量重标定后曲线的塌缩程度。如果我们使用 $x = t L^{p}$ 和 $y = m L^{q}$ 来重标定每条曲线，完美的塌缩将产生一条与 $L$ 无关的单一曲线 $y = F(x)$。一种实用的、与模型无关的量化塌缩质量的方法是，在相同的 $x$ 值上比较不同曲线的 $y$ 值散布情况。在给定的 $x$ 处，上包络线是 $\\max_j y_j(x)$，下包络线是 $\\min_j y_j(x)$，其中 $j$ 索引不同 $L$ 的曲线。在 $x$ 处的散布是其差值 $\\max_j y_j(x) - \\min_j y_j(x)$。我们将这个散布在所有曲线共有的 $x$ 值定义域上进行累加，以避免在数据支持范围之外进行外推。\n\n由于数据是离散的，我们采用数值方法处理。对于给定的猜测 $(p,q)$，我们：\n- 对每条曲线 $j$，计算 $x_j = t_j L_j^{p}$ 和 $y_j = m_j L_j^{q}$。\n- 确定公共定义域 $[x_{\\min}, x_{\\max}]$，作为所有重标定后的 $x_j$ 所覆盖区间的交集；即 $x_{\\min} = \\max_j \\min(x_j)$ 和 $x_{\\max} = \\min_j \\max(x_j)$。\n- 如果公共定义域为空或小到可以忽略，我们返回一个大的惩罚值，以避免选择此类参数。\n- 否则，在 $[x_{\\min}, x_{\\max}]$ 上构建一个包含 $N_g$ 个点的均匀网格。\n- 对于每条曲线 $j$，使用稳定的单调插值将其 $y_j$ 作为 $x_j$ 的函数线性插值到这个网格上（数据在 $x$ 上自然是单调的，因为 $t$ 是单调的且 $L^{p}  0$）。这样就得到了在公共网格上所有 $j$ 的 $y_j(x)$。\n- 在每个网格点 $x$ 处，计算散布 $w(x) = \\max_j y_j(x) - \\min_j y_j(x)$。\n- 将目标函数计算为定义域上的平均包络线宽度，\n$$\n\\mathcal{A}(p,q) = \\frac{1}{x_{\\max} - x_{\\min}} \\int_{x_{\\min}}^{x_{\\max}} w(x) \\, dx,\n$$\n我们通过在均匀网格上使用梯形法则来近似该值。通过除以 $(x_{\\max} - x_{\\min})$ 进行归一化，可以防止算法通过将定义域塌缩到一个极小的区间来人为地减小目标函数值，从而使得该度量在不同的 $(p,q)$ 之间具有可比性。\n\n有了这个目标函数，我们选择一个适合非凸问题的无导数优化器。像标准科学计算库中实现的 Powell 方法或 Nelder–Mead 方法是合适的，因为目标函数涉及插值和积分，这使得导数的计算不方便或带有噪声。我们强制执行简单的边界约束 $p \\in [0.5, 1.5]$ 和 $q \\in [0.05, 0.25]$，这反映了许多模型的典型取值范围，并能防止病态的重标定。\n\n为了测试和验证，我们从一个已知的标度函数和已知的指数生成合成数据。具体来说，我们使用\n$$\nm(L,t) = L^{-q_{\\mathrm{true}}} \\, F(t L^{p_{\\mathrm{true}}}), \\quad F(u) = \\left[1 + (a u)^2 \\right]^{-b}.\n$$\n我们提供三个测试案例：一个无噪声的数据集，其 $p_{\\mathrm{true}} = 1.0$, $q_{\\mathrm{true}} = 0.125$, $a = 2.0$, $b = 0.5$；一个有噪声的数据集，其指数相同，噪声标准差为每个 $L$ 信号中位数的 $0.02$ 倍；以及第三个数据集，具有不同的指数 $p_{\\mathrm{true}} = 0.9$, $q_{\\mathrm{true}} = 0.2$，参数 $a = 1.5$, $b = 0.8$，以及中等噪声，其大小为每个 $L$ 信号中位数的 $0.01$ 倍。对于有噪声的情况，我们使用固定的随机种子以确保可复现性。$t$ 的网格是均匀的，$L$ 值的选择使得在真实指数下重标定的定义域有足够的重叠。\n\n对每个测试案例，算法按以下步骤进行：\n- 使用给定的 $p_{\\mathrm{true}}$, $q_{\\mathrm{true}}$, $a$, 和 $b$，为指定集合中的每个 $L_j$ 生成 $\\{(t_j, m_j, L_j)\\}$，并在需要时添加噪声。\n- 将目标函数 $\\mathcal{A}(p,q)$ 定义为在公共 $x$ 定义域上，一个包含 $N_g = 401$ 个点的均匀网格上计算的平均包络线宽度。\n- 使用一个带有箱式约束 $p \\in [0.5, 1.5]$ 和 $q \\in [0.05, 0.25]$ 的无导数优化器，对 $\\mathcal{A}(p,q)$ 关于 $(p,q)$ 进行最小化，可能从多个初始猜测值开始以提高稳健性。\n- 将得到的估计值 $(p_{\\mathrm{est}}, q_{\\mathrm{est}})$ 四舍五入到三位小数。\n\n最后，我们将三个 $(p_{\\mathrm{est}}, q_{\\mathrm{est}})$ 对聚合到一个列表中，并以要求的格式单行打印出来：\n$$\n\\left[ [p_{\\mathrm{est}}^{(1)}, q_{\\mathrm{est}}^{(1)}], [p_{\\mathrm{est}}^{(2)}, q_{\\mathrm{est}}^{(2)}], [p_{\\mathrm{est}}^{(3)}, q_{\\mathrm{est}}^{(3)}] \\right].\n$$\n这种方法是有原则的，因为它直接源于有限尺寸标度假设，并通过一种基于包络线的散布度量将数据塌缩操作化，而数值实现则利用了标准的插值和求积方法，并结合了稳健的优化技术。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\n# Finite-size scaling data collapse by minimizing the average envelope width.\n\ndef scaling_function(u, a, b):\n    # F(u) = [1 + (a u)^2]^{-b}\n    return (1.0 + (a * u) ** 2) ** (-b)\n\ndef generate_synthetic_case(L_values, t_min, t_max, N_t, p_true, q_true, a, b, noise_frac=0.0, seed=None):\n    \"\"\"\n    Generate synthetic data for a single case:\n    m(L,t) = L^{-q_true} * F(t * L^{p_true}), F(u) = [1 + (a u)^2]^{-b}\n    Optionally add Gaussian noise with std = noise_frac * median(noiseless_m(L,t)) per L.\n    \"\"\"\n    t_grid = np.linspace(t_min, t_max, N_t)\n    datasets = []\n    rng = np.random.default_rng(seed) if seed is not None else None\n    for L in L_values:\n        u = t_grid * (L ** p_true)\n        m_clean = (L ** (-q_true)) * scaling_function(u, a, b)\n        if noise_frac > 0 and rng is not None:\n            sigma = noise_frac * np.median(m_clean)\n            noise = rng.normal(loc=0.0, scale=sigma, size=m_clean.shape)\n            m_noisy = m_clean + noise\n        else:\n            m_noisy = m_clean.copy()\n        datasets.append((t_grid.copy(), m_noisy, float(L)))\n    return datasets\n\ndef average_envelope_width(params, datasets, Ng=401, penalty=1e6):\n    \"\"\"\n    Compute the average envelope width over the common x-domain for given (p, q).\n    Uses linear interpolation and trapezoidal integration on a uniform grid.\n    Returns a large penalty if the common domain is empty or too small.\n    \"\"\"\n    p, q = params\n    # Rescale each dataset\n    x_list = []\n    y_list = []\n    for (t, m, L) in datasets:\n        x = t * (L ** p)\n        y = m * (L ** q)\n        # Ensure increasing x order for interpolation\n        # t_grid is monotonic, but if p is negative (not allowed) or pathological bounds, this prevents issues.\n        idx = np.argsort(x)\n        x_list.append(x[idx])\n        y_list.append(y[idx])\n\n    # Determine common domain\n    x_min_common = max(min(xi) for xi in x_list)\n    x_max_common = min(max(xi) for xi in x_list)\n\n    if not np.isfinite(x_min_common) or not np.isfinite(x_max_common):\n        return penalty\n    if x_max_common = x_min_common:\n        return penalty\n\n    # Uniform grid on the common domain\n    grid = np.linspace(x_min_common, x_max_common, Ng)\n    # Interpolate y on the grid\n    Y = np.empty((len(y_list), Ng))\n    for i, (xi, yi) in enumerate(zip(x_list, y_list)):\n        # np.interp assumes xi is ascending\n        Y[i, :] = np.interp(grid, xi, yi)\n    # Envelope width at each grid point\n    width = np.max(Y, axis=0) - np.min(Y, axis=0)\n    domain_length = x_max_common - x_min_common\n    # Average envelope width: integral divided by domain length\n    avg_width = np.trapz(width, grid) / domain_length\n    # Numerical safety\n    if not np.isfinite(avg_width):\n        return penalty\n    return float(avg_width)\n\ndef estimate_exponents(datasets, bounds=((0.5, 1.5), (0.05, 0.25))):\n    \"\"\"\n    Estimate (p, q) by minimizing the average envelope width with respect to params.\n    Uses Powell's method with bounds and multiple starting points for robustness.\n    \"\"\"\n    # Multiple initial guesses to reduce risk of local minima\n    initial_guesses = [\n        np.array([1.0, 0.1]),\n        np.array([0.8, 0.2]),\n        np.array([1.2, 0.15]),\n    ]\n    best_val = np.inf\n    best_params = None\n    for x0 in initial_guesses:\n        res = minimize(\n            average_envelope_width,\n            x0=x0,\n            args=(datasets,),\n            method=\"Powell\",\n            bounds=bounds,\n            options={\"xtol\": 1e-4, \"ftol\": 1e-6, \"maxiter\": 200, \"disp\": False},\n        )\n        if res.fun  best_val:\n            best_val = res.fun\n            best_params = res.x\n    # Clip to bounds for numerical safety\n    p_est = float(np.clip(best_params[0], bounds[0][0], bounds[0][1]))\n    q_est = float(np.clip(best_params[1], bounds[1][0], bounds[1][1]))\n    return p_est, q_est\n\ndef solve():\n    # Define the three test cases\n\n    # Case 1: Clean, canonical exponents\n    case1 = generate_synthetic_case(\n        L_values=[16, 32, 64, 128],\n        t_min=-0.30, t_max=0.30, N_t=241,\n        p_true=1.0, q_true=0.125, a=2.0, b=0.5,\n        noise_frac=0.0, seed=None\n    )\n\n    # Case 2: Noisy, same exponents as case 1\n    case2 = generate_synthetic_case(\n        L_values=[16, 32, 64, 128],\n        t_min=-0.30, t_max=0.30, N_t=241,\n        p_true=1.0, q_true=0.125, a=2.0, b=0.5,\n        noise_frac=0.02, seed=123\n    )\n\n    # Case 3: Different exponents, moderate noise\n    case3 = generate_synthetic_case(\n        L_values=[12, 24, 48, 96],\n        t_min=-0.40, t_max=0.40, N_t=241,\n        p_true=0.9, q_true=0.2, a=1.5, b=0.8,\n        noise_frac=0.01, seed=456\n    )\n\n    # Estimate exponents for each case\n    results_pairs = []\n    for datasets in [case1, case2, case3]:\n        p_est, q_est = estimate_exponents(datasets)\n        # Round to three decimals for final output format\n        results_pairs.append([round(p_est, 3), round(q_est, 3)])\n\n    # Format output as a single-line list of lists with exactly three decimals\n    formatted = \"[\" + \",\".join(\n        \"[\" + \",\".join(f\"{v:.3f}\" for v in pair) + \"]\" for pair in results_pairs\n    ) + \"]\"\n    print(formatted)\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}