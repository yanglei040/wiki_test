{
    "hands_on_practices": [
        {
            "introduction": "线性同余生成器 (LCG) 是一个确定性序列，这意味着每一个状态都由其前一个状态唯一确定。这自然引出一个问题：我们可以“时间倒流”吗？也就是说，给定一个状态 $X_{n+1}$，我们能否找到其所有可能的前驱状态 $X_n$？这个练习将引导你从第一性原理出发，推导并实现一个反向 LCG。通过求解线性同余方程 $a X_n \\equiv X_{n+1} - c \\pmod{m}$，你将深入理解模逆元和最大公约数在决定 LCG 结构和可逆性中的核心作用。",
            "id": "2408806",
            "problem": "你的任务是，从第一性原理出发，推断线性同余生成器 (LCG) 的可逆性，然后实现一个程序，为给定的后继状态计算其所有单步前驱的完整集合。线性同余生成器 (LCG) 通过以下递推关系在模 $m$ 整数环中生成一个序列 $\\{X_n\\}$：\n$$\nX_{n+1} \\equiv a X_n + c \\pmod{m},\n$$\n其中 $a, c, m$ 是固定的整数，满足 $m \\ge 2$，并且对于所有 $n$，都有 $X_n \\in \\{0,1,2,\\dots,m-1\\}$。同余关系是在整数上定义的等价关系，即 $u \\equiv v \\pmod{m}$ 当且仅当 $m$ 整除 $u - v$。\n\n你的任务：\n\n1) 仅从同余的基本性质、最大公约数 (gcd) 的概念，以及“整数 $a$ 存在模 $m$ 的乘法逆元当且仅当 $\\gcd(a,m) = 1$”这一事实出发，推导出对于给定的 $X_{n+1}$，其单步前驱 $X_n$ 存在的充分必要条件，并确定当存在前驱时，在 $\\{0,1,\\dots,m-1\\}$ 中有多少个不同的前驱。你不能假设任何现成的“捷径”公式；相反，你必须从同余的定义和最大公约数所蕴含的整除性质出发进行推理。\n\n2) 基于你的推导，设计一个算法。给定整数 $m, a, c$ 和一个特定的后继状态 $X_{n+1}$，该算法计算所有满足单步关系 $X_{n+1} \\equiv a X_n + c \\pmod{m}$ 的 $X_n \\in \\{0,1,\\dots,m-1\\}$ 的完整集合。你的算法必须：\n- 判断解是否存在。\n- 如果不存在解，返回空集。\n- 如果存在解，使用数论推理和扩展欧几里得算法返回所有解，而不是对 $\\{0,1,\\dots,m-1\\}$ 进行暴力迭代。\n- 按严格递增顺序对返回的解进行排序。\n\n3) 将你的算法实现为一个完整的、可运行的程序，以解决以下测试套件。对于每个测试用例，输入包括 $(m, a, c, X_{n+1})$。你的程序应计算并返回所有满足该单步关系的 $X_n \\in \\{0,\\dots,m-1\\}$ 的列表。测试用例如下：\n- 案例 A (理想情况，素数模，乘法 LCG): $m = 2147483647$, $a = 16807$, $c = 0$, $X_{n+1} = 16807$。\n- 案例 B (2的幂的模，奇数乘数): $m = 2147483648$, $a = 65539$, $c = 0$, $X_{n+1} = 1663592255$。\n- 案例 C (不存在前驱，$a$ 和 $m$ 不互素): $m = 12$, $a = 8$, $c = 3$, $X_{n+1} = 5$。\n- 案例 D (存在多个前驱，$a$ 和 $m$ 不互素): $m = 12$, $a = 8$, $c = 4$, $X_{n+1} = 8$。\n- 案例 E (全周期 Java 风格参数，加法 LCG): $m = 281474976710656$, $a = 25214903917$, $c = 11$, $X_{n+1} = 11$。\n\n为保证数值稳健性，所有算术运算必须在整数上精确完成；此任务中不含浮点数。\n\n输出规范：\n- 对于每个测试用例，输出所有能映射到给定 $X_{n+1}$ 的整数前驱 $X_n \\in \\{0,1,\\dots,m-1\\}$ 的完整列表，并按升序排序。如果没有前驱，则输出空列表。\n- 你的程序应生成单行输出，其中包含所有测试用例的结果，形式为一个用方括号括起来的逗号分隔列表，每个元素本身也是一个列表，例如：$[ [x_{A,1},x_{A,2}], [x_{B,1}], [], [x_{D,1},x_{D,2},x_{D,3}], [x_{E,1}] ]$。仅使用整数；不要打印任何解释性文本或单位。\n\n你的最终程序不得从用户读取输入，也不得访问外部文件或网络。它必须能直接运行，并严格按照指定格式打印一行输出。",
            "solution": "所述问题是有效的。这是一个在计算数论中定义明确的问题，其基础是线性同余的既定原理。所有定义都是标准的，所提供的参数明确且在计算上是可行的。我们现在将进行解法的形式化推导。\n\n问题的核心是，对于给定的后继状态 $X_{n+1}$，求解所有在范围 $\\{0, 1, \\dots, m-1\\}$ 内满足线性同余生成器 (LCG) 单步递推关系的整数 $X_n$ 的集合。该关系定义为：\n$$\nX_{n+1} \\equiv a X_n + c \\pmod{m}\n$$\n这里，$a$、$c$ 和 $m$ 是给定的整数，且 $m \\ge 2$。我们的目标是解出 $X_n$。为此，可以首先重排同余式，以分离出包含未知数 $X_n$ 的项：\n$$\na X_n \\equiv X_{n+1} - c \\pmod{m}\n$$\n这是一个标准形式为 $Ax \\equiv B \\pmod{N}$ 的线性同余式，其中我们对应地有 $A=a$, $x=X_n$, $B = X_{n+1} - c$, 以及 $N=m$。为简洁起见，我们定义 $b = X_{n+1} - c$。需要求解的同余式为：\n$$\na X_n \\equiv b \\pmod{m}\n$$\n$X_n$ 解的存在性及其数量完全由系数 $a$ 和模 $m$ 的最大公约数的性质决定。我们记 $d = \\gcd(a, m)$。\n\n根据同余的定义，$a X_n \\equiv b \\pmod{m}$ 等价于 $m$ 整除 $(a X_n - b)$。这又等价于存在一个整数 $k$ 使得：\n$$\na X_n - b = k m\n$$\n整理后得到一个关于两个变量 $X_n$ 和 $k$ 的线性丢番图方程：\n$$\na X_n - k m = b\n$$\n根据线性丢番图方程的基本理论（裴蜀等式的一个推论），形如 $Ax + By = C$ 的方程有整数解 $(x, y)$ 当且仅当 $\\gcd(A, B)$ 整除 $C$。在我们的例子中，$A=a$，$B=-m$，$C=b$。由于 $\\gcd(a, -m) = \\gcd(a, m) = d$，所以 $X_n$（和 $k$）的解存在当且仅当 $d$ 整除 $b$。\n\n这就建立了解存在至少一个前驱的充分必要条件：\n前驱 $X_n$ 存在，当且仅当 $\\gcd(a, m)$ 整除 $(X_{n+1} - c)$。\n\n如果条件 $d | b$ 不满足，则不存在 $X_n$ 的整数解，因此在 $\\{0, 1, \\dots, m-1\\}$ 中的前驱集合为空。\n\n如果条件 $d | b$ 满足，则解存在，我们必须找出所有解。由于 $d$ 是 $a$、$m$ 和 $b$ 的公约数，我们可以将整个同余式 $a X_n \\equiv b \\pmod{m}$ 两边同时除以 $d$。同余式 $aX_n \\equiv b \\pmod{m}$ 意味着对于某个整数 $k$，有 $aX_n = b + km$。两边除以 $d$ 得到 $(a/d)X_n = (b/d) + k(m/d)$，这意味着 $(a/d)X_n \\equiv (b/d) \\pmod{m/d}$。我们定义 $a' = a/d$，$b' = b/d$，以及 $m' = m/d$。化简后的同余式为：\n$$\na' X_n \\equiv b' \\pmod{m'}\n$$\n根据最大公约数的性质，我们知道 $\\gcd(a/d, m/d) = \\gcd(a', m') = 1$。这是关键的一步，因为它确保了 $a'$ 存在唯一的模 $m'$ 乘法逆元。这个逆元的存在使我们能够直接求解化简后的同余式。\n\n我们使用扩展欧几里得算法来寻找 $a'$ 模 $m'$ 的逆元。该算法找到一对整数，比如 $(u, v)$，使得 $a'u + m'v = \\gcd(a', m') = 1$。将此等式模 $m'$，我们得到 $a'u \\equiv 1 \\pmod{m'}$。整数 $u$（或 $u \\pmod{m'}$）就是所需的模逆元，我们记为 $(a')^{-1}$。\n\n现在，我们将化简后的同余式 $a' X_n \\equiv b' \\pmod{m'}$ 的两边乘以这个逆元 $(a')^{-1}$：\n$$\n(a')^{-1} a' X_n \\equiv (a')^{-1} b' \\pmod{m'}\n$$\n$$\n1 \\cdot X_n \\equiv (a')^{-1} b' \\pmod{m'}\n$$\n这为我们提供了一族 $X_n$ 的解。所有满足此关系的整数 $X_n$ 都是化简后同余式的解。最小非负解，我们称之为特解 $x_0$，由下式给出：\n$$\nx_0 = ((a')^{-1} \\cdot b') \\pmod{m'}\n$$\n这意味着任何解 $X_n$ 必为 $X_n = x_0 + j \\cdot m'$ 的形式，其中 $j$ 为某个整数。我们关心的是位于集合 $\\{0, 1, \\dots, m-1\\}$ 中的解。我们将解的形式代入这个范围约束中：\n$$\n0 \\le x_0 + j \\cdot m' \\le m-1\n$$\n由于 $m' = m/d$，我们寻找的是 $0 \\le x_0 + j \\cdot (m/d) \\le m-1$。考虑到 $0 \\le x_0 < m' = m/d$， $j$ 的有效整数值为 $0, 1, 2, \\dots, d-1$。当 $j=d$ 时，解变为 $x_0 + d \\cdot (m/d) = x_0 + m$，超出了所需范围。\n\n因此，如果解存在，那么在集合 $\\{0, 1, \\dots, m-1\\}$ 中恰好有 $d = \\gcd(a, m)$ 个不同的解。这些解是：\n$$\n\\{ x_0 + j \\cdot (m/d) \\mid j = 0, 1, \\dots, d-1 \\}\n$$\n这个集合自然是按升序排列的。\n\n寻找前驱的算法如下：\n1.  给定 $m, a, c, X_{n+1}$，计算 $b = X_{n+1} - c$。\n2.  计算 $d = \\gcd(a, m)$。\n3.  检查 $b$是否能被 $d$ 整除。如果不能（即 $b \\pmod d \\neq 0$），返回一个空解集。\n4.  如果 $b$能被 $d$ 整除，继续。定义 $a' = a/d$，$b' = b/d$，以及 $m' = m/d$。\n5.  使用扩展欧几里得算法找到 $a'$ 模 $m'$ 的模逆元。设其为 $inv\\_a'$。\n6.  计算特解 $x_0 = (b' \\cdot inv\\_a') \\pmod{m'}$。\n7.  生成完整的 $d$ 个解的集合：$\\{x_0, x_0+m', x_0+2m', \\dots, x_0+(d-1)m'\\}$。\n8.  返回这个已经排好序的解集。\n该算法避免了暴力搜索，完全依赖于高效的数论计算。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport math\n# from scipy import ...\n\ndef extended_gcd(a, b):\n    \"\"\"\n    Computes the extended greatest common divisor of integers a and b.\n    Returns a tuple (g, x, y) such that a*x + b*y = g, where g = gcd(a, b).\n    \"\"\"\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        g, y, x = extended_gcd(b % a, a)\n        return (g, x - (b // a) * y, y)\n\ndef find_predecessors(m, a, c, X_next):\n    \"\"\"\n    Solves for all X_n in {0,...,m-1} such that X_{n+1} = (a * X_n + c) mod m.\n    \n    This function solves the linear congruence a*x = b (mod m),\n    where x = X_n and b = X_next - c.\n    \"\"\"\n    if m  2:\n        raise ValueError(\"Modulus m must be >= 2\")\n\n    # The congruence to solve is a * X_n = X_next - c (mod m)\n    # Let's put it in the standard form a*x = b (mod m)\n    # Note that all arithmetic is done with Python's arbitrary-precision integers.\n    a_mod_m = a % m\n    b = X_next - c\n\n    # Let d = gcd(a, m). Solutions exist iff d divides b.\n    d = math.gcd(a_mod_m, m)\n\n    if b % d != 0:\n        # No solutions exist.\n        return []\n\n    # If we are here, there are exactly d solutions.\n    # We reduce the congruence to a' * x = b' (mod m'), where gcd(a', m') = 1.\n    a_prime = a_mod_m // d\n    b_prime = b // d\n    m_prime = m // d\n\n    # Find the modular multiplicative inverse of a' mod m'\n    # using the Extended Euclidean Algorithm.\n    # eea(a', m') returns (g, x, y) s.t. a'*x + m'*y = g. Here g is 1.\n    g, inv_a_prime_raw, _ = extended_gcd(a_prime, m_prime)\n    \n    if g != 1:\n        # This case should not be reachable due to the definition of gcd.\n        # It is a logical impossibility.\n        raise RuntimeError(\"Mathematical inconsistency: gcd(a/d, m/d) is not 1.\")\n\n    inv_a_prime = inv_a_prime_raw % m_prime\n\n    # A particular solution x0 for the reduced congruence is:\n    # x0 = b' * (a')^{-1} (mod m')\n    x0 = (b_prime * inv_a_prime) % m_prime\n\n    # The d solutions for the original congruence are x0 + k*m' for k in {0, ..., d-1}.\n    # This list is generated in increasing order.\n    solutions = [x0 + k * m_prime for k in range(d)]\n    \n    return solutions\n\ndef solve():\n    \"\"\"\n    Runs the predefined test suite and prints the results in the specified format.\n    \"\"\"\n    test_cases = [\n        # Case A: happy path, prime modulus, mult LCG\n        (2147483647, 16807, 0, 16807),\n        # Case B: power-of-two modulus, odd multiplier\n        (2147483648, 65539, 0, 1663592255),\n        # Case C: no predecessor exists\n        (12, 8, 3, 5),\n        # Case D: multiple predecessors exist\n        (12, 8, 4, 8),\n        # Case E: full-period Java-style parameters\n        (281474976710656, 25214903917, 11, 11),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        m, a, c, X_next = case\n        predecessors = find_predecessors(m, a, c, X_next)\n        all_results.append(predecessors)\n\n    # Format the results into a single string as specified in the problem.\n    # Each sub-list must be formatted without spaces, e.g., [1,2,3] not [1, 2, 3].\n    def format_list(lst):\n        return f\"[{','.join(map(str, lst))}]\"\n\n    final_output_string = f\"[{','.join(map(format_list, all_results))}]\"\n\n    # Final print statement in the exact required format.\n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "在理想的数学世界中，我们可以使用无限精度的整数，但在真实的计算机上，我们受限于固定宽度的整数算法，这会导致“整数溢出”问题。这个看似微小的实现细节可能会对 LCG 的行为产生灾难性影响。在此实践中，你将实现一个正确的 LCG 和一个模拟整数溢出的“有缺陷” LCG，并比较它们的周期长度。这个练习是一个关于算法理论与实际编程之间差距的重要课程，揭示了为何必须谨慎处理数值计算中的硬件限制。",
            "id": "2408851",
            "problem": "你需要实现一个线性同余生成器 (LCG)，并严格量化在定宽整数算术中执行乘法会如何缩短序列最终达到的周期。从 LCG 的核心定义开始，它是一个关于整数模一个模数的一阶递推关系，由以下映射给出\n$$\nX_{n+1} = (a X_n + c) \\bmod m,\n$$\n其中，对于所有 $n$，$X_n \\in \\{0,1,\\dots,m-1\\}$，$a$ 是乘数，$c$ 是增量，$m$ 是模数。在具有无限精度（或精确模算术）的正确实现中，此递推关系在大小为 $m$ 的有限状态空间上定义了一个确定性映射，因此由于状态空间的有限性，每个轨道最终都是周期性的。在定宽硬件上运行的实际代码中，乘积 $a \\cdot X_n$ 在以 $w$ 位算术计算时可能会溢出。一个不正确的实现，它在无符号 $w$ 位算术中计算乘积，然后才对 $m$ 取模，这实际上是根据修改后的映射进行演化的\n$$\nX_{n+1}^{\\text{bug}} \\;=\\; \\big( \\, \\big( (a X_n) \\bmod 2^w \\big) + c \\, \\big) \\bmod m,\n$$\n这可能会破坏预期的周期属性。\n\n任务：\n- 实现两种更新规则：正确的 LCG 更新 $X_{n+1} = (a X_n + c) \\bmod m$ 和错误的更新 $X_{n+1}^{\\text{bug}} = \\big( \\big( (a X_n) \\bmod 2^w \\big) + c \\big) \\bmod m$。\n- 对于每个测试用例，从提供的种子 $X_0$ 开始，通过迭代更新计算最终达到的周期长度。具体来说，将该映射视为有限集上的一个确定性函数，并确定从 $X_0$ 开始的轨道所遇到的周期长度（忽略任何不重复的瞬态前缀）。对于每种情况，报告两个整数：正确更新的周期长度和错误更新的周期长度，以及一个布尔值，表示错误周期是否严格短于正确周期。\n\n你可以假设的基础理论：\n- 状态空间 $\\{0,1,\\dots,m-1\\}$ 是有限的，因此其上的任何确定性映射产生的轨道最终都是周期性的。\n- 整数模 $n$ 算术定义了环 $\\mathbb{Z}/n\\mathbb{Z}$，而对 2 的幂 $2^w$ 取模则模拟了 $w$ 位无符号整数算术的回绕行为。\n\n算法要求：\n- 使用有限状态迭代的基本原理来检测周期：跟踪访问过的状态及其首次出现的索引；当一个状态重复时，周期长度等于当前步数索引与该重复状态首次出现索引之差。\n\n测试套件：\n实现你的程序，以精确运行以下四个测试用例，每个用例指定为一个元组 $\\big(m,a,c,X_0,w\\big)：$\n1. $\\big( m = 2^{16} = 65536,\\; a = 5,\\; c = 1,\\; X_0 = 0,\\; w = 12 \\big)$.\n2. $\\big( m = 2^{15} = 32768,\\; a = 1,\\; c = 1,\\; X_0 = 12345,\\; w = 8 \\big)$.\n3. $\\big( m = 2^{12} = 4096,\\; a = 109,\\; c = 0,\\; X_0 = 1,\\; w = 8 \\big)$.\n4. $\\big( m = 10007,\\; a = 1,\\; c = 4567,\\; X_0 = 789,\\; w = 32 \\big)$.\n\n输出规范：\n- 对于每个测试用例，计算并收集一个包含三个条目的列表：正确的周期长度（整数）、错误的周期长度（整数）和一个布尔值，该布尔值当且仅当错误的长度严格小于正确的长度时为真。\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个元素本身就是如上所述的列表。例如，包含两个用例的输出应如下所示：“[[L1_correct,L1_bug,B1],[L2_correct,L2_bug,B2]]”。不得有任何额外文本，且不需要空格。\n\n此问题不涉及任何物理单位或角度，因此不应报告。所有数值必须以纯整数形式生成，布尔值应呈现为 \"True\" 或 \"False\"。",
            "solution": "该问题是有效的。它在科学上是合理的、定义明确且客观的。它探讨了计算科学中的一个标准课题：伪随机数生成器的属性，特别是线性同余生成器（LCG）的周期结构。将正确实现与一个模拟了整数溢出错误的实现进行比较，是理解数值稳定性和实现陷阱的一个实用且有意义的练习。所有定义和参数均已提供，使得问题清晰明确且可解。\n\n解决方案是通过直接模拟两种 LCG 更新规则生成的状态序列来获得的。在有限状态空间上，任何确定性序列的周期长度都可以通过检测第一个重复状态来找到。\n\n设状态空间为 $S = \\{0, 1, \\dots, m-1\\}$。序列 $\\{X_n\\}_{n=0}^\\infty$ 由函数 $f: S \\to S$ 生成，其中 $X_{n+1} = f(X_n)$。因为 $S$ 是一个有限集，所以任何这样的序列最终都必须重复一个状态，此时它就变得周期性。目标是确定这个周期的长度，即周期长度。\n\n我们采用一种标准的周期检测算法。我们从初始种子 $X_0$ 开始迭代映射 $f$。我们维护一个字典（可称之为 $visited$），用于存储遇到的每个唯一状态及其首次出现的步数索引。在每一步 $n \\ge 0$，我们计算状态 $X_n$。如果 $X_n$ 已经存在于 $visited$ 字典中，则说明找到了一个周期。该周期的长度由 $L = n - visited[X_n]$ 给出。从索引 $visited[X_n]$ 到 $n-1$ 的状态序列构成了遇到的第一个完整周期。\n\n问题指定了 2 个不同的更新函数 $f$。\n\n$1$. 正确的 LCG 更新规则由整数环模 $m$ 上的仿射变换给出：\n$$\nf_{\\text{correct}}(X_n) = (a X_n + c) \\bmod m\n$$\n此计算预设乘积 $a X_n$ 在最终对 $m$ 取模之前，是以足够高的精度计算的（即，使用可以超过机器字长的整数）。\n\n$2$. 错误的 LCG 更新规则模拟了定宽 $w$ 位无符号整数算术的行为，其中乘法可能会溢出。它由以下映射定义：\n$$\nf_{\\text{bugged}}(X_n) = \\big( \\big( (a X_n) \\bmod 2^w \\big) + c \\big) \\bmod m\n$$\n在这种情况下，乘积 $a X_n$ 首先被隐式地对 $2^w$ 取模，这正确地模拟了 $w$ 位无符号整数的回绕行为。这个中间结果随后被用于 LCG 计算的其余部分。\n\n设计了一个单一的计算过程来寻找周期长度。该过程接受生成器参数 $(m, a, c, X_0, w)$ 和一个布尔标志，用于在 $f_{\\text{correct}}$ 和 $f_{\\text{bugged}}$ 之间进行选择。\n\n该算法的结构如下：\n设函数为 `find_cycle_length(m, a, c, x0, w, use_bugged_rule)`。\n$1$. 初始化一个空字典，$visited$。\n$2$. 初始化当前状态 $x = x_0$ 和步数计数器 $step = 0$。\n$3$. 进入一个循环，只要状态 $x$ 尚未记录在 $visited$ 中就继续：\n    a. 记录当前状态和步数：$visited[x] = step$。\n    b. 计算下一个状态。如果 $use\\_bugged\\_rule$ 为真，则应用 $f_{\\text{bugged}}(x)$。否则，应用 $f_{\\text{correct}}(x)$。Python 的任意精度整数对此非常理想，因为它们自然地处理了正确乘积 $a \\cdot x$ 的“无限精度”要求。更新规则实现如下：\n       - 正确： `x = (a * x + c) % m`\n       - 错误： `x = (((a * x) % (2**w)) + c) % m`\n    c. 增加步数计数器：$step = step + 1$。\n$4$. 当新计算出的状态 $x$ 在 $visited$ 中被找到时，循环终止。其首次出现的索引是 $first\\_occurrence = visited[x]$。\n$5$. 周期长度计算为 $length = step - first\\_occurrence$。返回此值。\n\n对提供的 4 个测试用例中的每一个执行此过程。对于每种情况，我们使用 $f_{\\text{correct}}$ 计算周期长度 $L_{\\text{correct}}$，并使用 $f_{\\text{bugged}}$ 计算周期长度 $L_{\\text{bugged}}$。然后生成一个布尔值，该值当且仅当 $L_{\\text{bugged}}  L_{\\text{correct}}$ 时为真。将最终结果收集并格式化为精确指定的字符串输出。",
            "answer": "```python\ndef find_cycle_length(m, a, c, x0, w, is_bugged):\n    \"\"\"\n    Computes the cycle length of an LCG sequence.\n\n    Args:\n        m (int): The modulus.\n        a (int): The multiplier.\n        c (int): The increment.\n        x0 (int): The seed or starting value.\n        w (int): The bit width for the bugged multiplication.\n        is_bugged (bool): If True, use the bugged update rule.\n\n    Returns:\n        int: The length of the cycle.\n    \"\"\"\n    visited = {}\n    x = x0\n    step = 0\n    mod_w = 2**w\n\n    while x not in visited:\n        visited[x] = step\n        if is_bugged:\n            # Intermediate product overflows at w bits\n            term = (a * x) % mod_w\n            x = (term + c) % m\n        else:\n            # Correct update rule with exact intermediate product\n            x = (a * x + c) % m\n        step += 1\n\n    cycle_start_step = visited[x]\n    cycle_length = step - cycle_start_step\n    return cycle_length\n\ndef solve():\n    \"\"\"\n    Runs the specified test cases and prints the results.\n    \"\"\"\n    # Test suite: tuples of (m, a, c, X0, w)\n    test_cases = [\n        (2**16, 5, 1, 0, 12),\n        (2**15, 1, 1, 12345, 8),\n        (2**12, 109, 0, 1, 8),\n        (10007, 1, 4567, 789, 32),\n    ]\n\n    results = []\n    for m, a, c, x0, w in test_cases:\n        # Calculate cycle length for the correct LCG\n        l_correct = find_cycle_length(m, a, c, x0, w, is_bugged=False)\n        \n        # Calculate cycle length for the bugged LCG\n        l_bugged = find_cycle_length(m, a, c, x0, w, is_bugged=True)\n        \n        # Determine if the bugged cycle is strictly shorter\n        is_shorter = l_bugged  l_correct\n        \n        results.append([l_correct, l_bugged, is_shorter])\n\n    # Format the output string precisely as required, with no spaces.\n    formatted_results = []\n    for r in results:\n        # Python's str(bool) gives 'True' or 'False' as needed.\n        formatted_results.append(f\"[{r[0]},{r[1]},{str(r[2])}]\")\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "前面练习中探讨的生成器结构和实现缺陷，在科学应用中会造成怎样的后果？这个最终实践将通过一个物理学中的一维随机游走模拟，来生动地回答这个问题。你将使用历史上一个臭名昭著的坏生成器 `RANDU` 来驱动这个模拟，并观察其产生的非物理行为，例如系统性的漂移。这个案例研究强有力地说明了，一个伪随机数生成器中的微小数学瑕疵，是如何导致科学结论完全错误的，这凸显了在科学计算中选择和验证高质量 PRNG 的极端重要性。",
            "id": "2408840",
            "problem": "为了应用于计算物理学，我们构建一个一维随机游走模型。行走者在整数时间点上进行离散步进。伪随机数由线性同余生成器 (LCG) 生成，对于整数，其定义为\n$$\nx_{n+1} \\equiv (a x_n + c) \\bmod m,\n$$\n其中包含参数 $a$、$c$、$m$ 和一个初始种子 $x_0$。在时间 $n$ 的模拟步长仅由 $x_n$ 的奇偶性决定，具体如下：\n$$\ns_n =\n\\begin{cases}\n+1,  \\text{如果 } x_n \\bmod 2 = 0,\\\\\n-1,  \\text{如果 } x_n \\bmod 2 = 1.\n\\end{cases}\n$$\n$N$ 步后的净位移为\n$$\nS_N = \\sum_{n=1}^{N} s_n.\n$$\n在一个物理上无偏的一维随机游走中，期望位移应为零，因此大的系统性漂移在此背景下是非物理的。\n\n请编写一个完整的程序，针对下面的每个测试用例，计算以下量：\n- 整数 $S_N$。\n- 浮点数 $f_{\\mathrm{even}}$，即在 $\\{x_1,\\dots,x_N\\}$ 中生成的偶数值的比例，定义为\n$$\nf_{\\mathrm{even}} =\n\\begin{cases}\n\\frac{1}{N}\\left|\\{n \\in \\{1,\\dots,N\\} : x_n \\bmod 2 = 0\\}\\right|,  \\text{如果 } N  0,\\\\\n0.0,  \\text{如果 } N = 0,\n\\end{cases}\n$$\n以小数形式报告。\n- 布尔值 $D$，如果每步的平均位移绝对值满足\n$$\n\\left|\\frac{S_N}{\\max(N,1)}\\right| \\ge \\theta,\n$$\n则为 $\\mathrm{True}$，否则为 $\\mathrm{False}$，其中阈值为 $\\theta = 0.9$（无量纲）。\n- 布尔值 $R$，当且仅当 LCG 参数与历史性的 RANDU 参数选择 $a = 65539$、$c = 0$、$m = 2^{31}$ 匹配时为 $\\mathrm{True}$，否则为 $\\mathrm{False}$。\n\n使用以下测试用例，每个用例均以 $(a,c,m,x_0,N)$ 的形式给出，所有量均为整数：\n- 测试 $1$：$a = 65539$，$c = 0$，$m = 2^{31}$，$x_0 = 1$，$N = 10000$。\n- 测试 $2$：$a = 65539$，$c = 0$，$m = 2^{31}$，$x_0 = 2$，$N = 10000$。\n- 测试 $3$：$a = 1664525$，$c = 1013904223$，$m = 2^{32}$，$x_0 = 123456789$，$N = 200000$。\n- 测试 $4$：$a = 16807$，$c = 0$，$m = 2147483647$，$x_0 = 1$，$N = 200000$。\n- 测试 $5$（边界情况）：$a = 65539$，$c = 0$，$m = 2^{31}$，$x_0 = 1$，$N = 0$。\n\n最终输出格式：您的程序应生成一行输出，其中包含一个顶级列表，每个测试用例对应一个条目，并保持上述顺序。每个条目本身必须是一个形式为\n$$\n[S_N,\\ f_{\\mathrm{even}},\\ D,\\ R]\n$$\n的列表。例如，整个打印行必须类似于\n$$\n[[S_1,f_{\\mathrm{even},1},D_1,R_1],[S_2,f_{\\mathrm{even},2},D_2,R_2],\\dots,[S_5,f_{\\mathrm{even},5},D_5,R_5]],\n$$\n无需空格，所有布尔值打印为 $\\mathrm{True}$ 或 $\\mathrm{False}$。不涉及物理单位，所有报告的量均为无量纲。",
            "solution": "所述问题是有效的。这是一个定义明确的计算练习，其基础是计算物理学和数论的基本原理，特别是使用线性同余生成器 (LCG) 生成和分析伪随机数。所有参数、定义和要求的输出都经过了数学上的精确规定，不存在科学或逻辑上的矛盾、歧义或信息缺失。问题是自洽的，并且在计算上是可行的。\n\n任务是模拟一个随机游走，其步长由 LCG 生成的数字的奇偶性决定，并计算该游走的几个统计特性。LCG 由以下递推关系定义：\n$$\nx_{n+1} \\equiv (a x_n + c) \\pmod m\n$$\n其中 $a$ 是乘数，$c$ 是增量，$m$ 是模数，$x_0$ 是初始种子。所有这些都是整数。\n\n模拟进行 $N$ 步。对于从 $1$ 到 $N$ 的每一步 $n$，我们首先生成数字 $x_n$，然后确定行走者的步长 $s_n$。伪随机数序列为 $\\{x_1, x_2, \\dots, x_N\\}$，该序列从给定的种子 $x_0$ 开始生成。步长 $s_n$ 根据 $x_n$ 的奇偶性定义：\n$$\ns_n =\n\\begin{cases}\n+1,  \\text{如果 } x_n \\bmod 2 = 0 \\text{ (偶数)}\\\\\n-1,  \\text{如果 } x_n \\bmod 2 = 1 \\text{ (奇数)}\n\\end{cases}\n$$\n$N$ 步后的总位移 $S_N$ 是各步长之和：\n$$\nS_N = \\sum_{n=1}^{N} s_n\n$$\n\n解决方案需要为每个给定的测试用例 $(a, c, m, x_0, N)$ 计算四个量：\n1.  $S_N$：净整数位移。\n2.  $f_{\\mathrm{even}}$：生成的数字 $\\{x_1, \\dots, x_N\\}$ 中偶数的比例。\n3.  $D$：一个指示是否存在显著漂移的布尔值。\n4.  $R$：一个指示 LCG 参数是否与历史上的 RANDU 生成器相对应的布尔值。\n\n对于给定的一个测试用例，算法流程如下：\n\n首先，我们处理 $N=0$ 的边界情况。此时不生成数字。总位移 $S_0$ 是一个空和，即为 $0$。偶数比例 $f_{\\mathrm{even}}$ 定义为 $0.0$。漂移条件 $D$ 是 $\\left|\\frac{S_0}{\\max(0,1)}\\right| \\ge \\theta$，计算结果为 $\\left|\\frac{0}{1}\\right| \\ge 0.9$，即 $0 \\ge 0.9$，这是假的。所以，$D = \\mathrm{False}$。RANDU 检查 $R$ 仅依赖于输入参数 $a$、$c$ 和 $m$。\n\n对于 $N  0$ 的一般情况，我们执行一个迭代模拟：\n1.  初始化状态变量：设当前 LCG 值为 `current_x` $= x_0$。初始化总位移 `displacement` $= 0$ 和偶数计数器 `num_even` $= 0$。\n2.  从 $n=1$ 到 $N$ 进行迭代：\n    a. 在序列中生成下一个数：`current_x` $= (a \\cdot \\text{current\\_x} + c) \\pmod m$。该值对应于 $x_n$。请注意，Python的 `%` 运算符对负数的处理方式与数学上的模运算不同，但由于 $a, c, m, x_0$ 都是非负的，这不成问题。中间乘积 $a \\cdot \\text{current\\_x}$ 可能会超过标准64位整数的容量，但 Python 的任意精度整数会自动处理这一点。\n    b. 检查 `current_x` 的奇偶性。如果 `current_x` $\\bmod 2 = 0$，则步长为 $s_n = +1$，并且 `num_even` 加一。否则，步长为 $s_n = -1$。\n    c. 更新总位移：`displacement` = `displacement` $+ s_n$。\n3.  循环完成后，最终的 `displacement` 即为 $S_N$，偶数的总数即为 `num_even`。\n\n计算出 $S_N$ 和 `num_even`后，其余的输出如下确定：\n1.  $S_N$ 是 `displacement` 的最终值。\n2.  $f_{\\mathrm{even}} = \\frac{\\text{num\\_even}}{N}$。这必须是浮点数除法。\n3.  如果 $\\left|\\frac{S_N}{N}\\right| \\ge 0.9$，则 $D$ 为 $\\mathrm{True}$，否则为 $\\mathrm{False}$。需要使用绝对值。\n4.  如果 $a = 65539$、$c = 0$ 且 $m = 2^{31}$，则 $R$ 为 $\\mathrm{True}$，否则为 $\\mathrm{False}$。这是一个对输入参数的直接比较。\n\n某些测试用例表现出的特性可以通过解析方法推导出来。例如，RANDU 生成器（$a=65539$, $c=0$, $m=2^{31}$）若使用奇数种子，将只产生奇数。这是因为 $a$ 是奇数，对于任何奇数 $x_n$，乘积 $a \\cdot x_n$ 也是奇数。模数 $m=2^{31}$ 是2的幂。一个奇数除以2的幂，其其余数总是奇数。因此，所有的步长 $s_n$ 都将是 $-1$，导致 $S_N = -N$ 且 $f_{\\mathrm{even}} = 0.0$。反之，如果种子是偶数，所有后续的数都将是偶数，导致 $S_N = N$ 且 $f_{\\mathrm{even}} = 1.0$。\n\n另一个案例涉及参数（$a=1664525$，$c=1013904223$，$m=2^{32}$），其中 $a$ 和 $c$ 是奇数，而 $m$ 是2的幂。如果 $x_n$ 是偶数，则 $x_{n+1} = (a \\cdot x_n + c) \\pmod m = (\\text{奇} \\cdot \\text{偶} + \\text{奇}) \\pmod {\\text{偶}} = \\text{奇} \\pmod{\\text{偶}}$，结果为奇数。如果 $x_n$ 是奇数，则 $x_{n+1} = (\\text{奇} \\cdot \\text{奇} + \\text{奇}) \\pmod {\\text{偶}} = \\text{偶} \\pmod{\\text{偶}}$，结果为偶数。序列 $\\{x_n\\}$ 的奇偶性将严格交替。这将导致完全平衡的步长和净位移 $S_N$ 为 $0$ 或 $\\pm 1$，具体取决于 $N$ 和初始的奇偶性。\n\n对于通用目的的 LCG，例如使用素数模数 $m=2^{31}-1$ 的 LCG，这些简单的相关性就不存在了，需要进行直接模拟。下面的程序为所有测试用例实现了这种完整的模拟。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\n\ndef solve():\n    \"\"\"\n    Solves the random walk problem for the given test cases.\n    \"\"\"\n    # Test cases are given as (a, c, m, x_0, N)\n    test_cases = [\n        # Test 1: RANDU, odd seed\n        (65539, 0, 2**31, 1, 10000),\n        # Test 2: RANDU, even seed\n        (65539, 0, 2**31, 2, 10000),\n        # Test 3: Numerical Recipes LCG\n        (1664525, 1013904223, 2**32, 123456789, 200000),\n        # Test 4: Park-Miller LCG\n        (16807, 0, 2147483647, 1, 200000),\n        # Test 5: Boundary case N=0\n        (65539, 0, 2**31, 1, 0),\n    ]\n\n    results = []\n    \n    # Threshold for drift detection\n    theta = 0.9\n\n    for case in test_cases:\n        a, c, m, x_0, N = case\n\n        # Initialize results\n        S_N = 0\n        f_even = 0.0\n        \n        # Handle the N > 0 case\n        if N > 0:\n            num_even = 0\n            current_x = x_0\n            \n            for _ in range(N):\n                # Generate the next number in the LCG sequence\n                # Python's integers handle arbitrary size, which is essential here\n                current_x = (a * current_x + c) % m\n                \n                # Determine step based on parity and update accumulators\n                if current_x % 2 == 0:\n                    S_N += 1\n                    num_even += 1\n                else:\n                    S_N -= 1\n            \n            f_even = float(num_even) / N\n        \n        # For N=0, S_N remains 0 and f_even is defined as 0.0\n        \n        # Calculate boolean D for drift\n        # The denominator is max(N, 1) to avoid division by zero for N=0\n        mean_displacement_abs = abs(S_N / max(N, 1))\n        D = mean_displacement_abs >= theta\n        \n        # Calculate boolean R for RANDU parameters\n        is_randu = (a == 65539 and c == 0 and m == 2**31)\n        R = is_randu\n        \n        results.append([S_N, f_even, D, R])\n\n    # Final print statement in the exact required format.\n    # The str() representation of a list includes spaces. \n    # To meet the \"no spaces required\" rule, we remove them.\n    # Example: str([[1, 2], [3, 4]]) -> \"[[1, 2], [3, 4]]\"\n    # After replace: \"[[1,2],[3,4]]\"\n    output_str = str(results).replace(' ', '')\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}