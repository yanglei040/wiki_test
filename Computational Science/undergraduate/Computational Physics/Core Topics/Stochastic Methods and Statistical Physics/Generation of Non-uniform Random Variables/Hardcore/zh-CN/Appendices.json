{
    "hands_on_practices": [
        {
            "introduction": "逆变换采样法是生成非均匀随机数的基本方法之一。该方法的核心思想是，如果一个随机变量的累积分布函数（CDF）$F(x)$是已知的并且可以求逆，那么通过将一个在$[0,1]$上均匀分布的随机数$U$代入反函数$F^{-1}(U)$，我们就能得到一个服从该分布的随机变量$X$。本练习  将通过一个具体实例——三角分布，来引导你实践这一重要技术，你将从第一性原理出发，推导其CDF和逆CDF，并编写代码将均匀随机数转换为符合特定三角分布的样本。",
            "id": "2398091",
            "problem": "您需要编写一个完整的、可运行的程序，该程序可以从三角形概率分布中生成独立样本，且不能使用任何直接生成此类样本的库函数。只允许使用单位区间上的连续均匀分布的独立样本作为基本要素。\n\n设三角形分布由三个实数参数 $a$、$c$ 和 $b$ 定义，其中 $a  b$ 且 $a \\le c \\le b$。其概率密度函数在 $[a,b]$ 区间之外为零，在 $[a,b]$ 区间内，在 $[a,c]$ 上线性递增，在 $[c,b]$ 上线性递减，并经过缩放以使在 $[a,b]$ 上的积分等于 $1$。具体而言，对于 $x \\in \\mathbb{R}$，\n$$\nf(x; a,c,b) =\n\\begin{cases}\n\\dfrac{2(x-a)}{(b-a)(c-a)},  a \\le x \\le c, \\quad \\text{if } c > a, \\\\[6pt]\n\\dfrac{2(b-x)}{(b-a)(b-c)},  c \\le x \\le b, \\quad \\text{if } c  b, \\\\[6pt]\n0,  \\text{otherwise}.\n\\end{cases}\n$$\n\n对于每个指定的测试用例，您的程序必须仅使用第一性原理完成以下所有操作：\n1. 从给定参数 $(a,c,b)$ 的三角形分布中生成 $N$ 个独立样本。\n2. 计算样本均值和样本方差（使用总体归一化，即除以 $N$）。\n3. 通过对给定的密度函数进行积分，计算精确的累积分布函数 $F(x; a,c,b)$，然后计算柯尔莫哥洛夫-斯米尔诺夫统计量 $D_N = \\sup_x \\lvert F_N(x) - F(x)\\rvert$，其中 $F_N$ 是所生成样本的经验累积分布函数。\n4. 将样本均值的绝对误差与指定容差 $\\delta_\\mu$ 进行比较，将样本方差的绝对误差与指定容差 $\\delta_{\\sigma^2}$ 进行比较，并将柯尔莫哥洛夫-斯米尔诺夫统计量与指定容差 $\\delta_{\\mathrm{KS}}$ 进行比较。当且仅当所有三个比较都满足时，测试用例才被视为通过。\n\n仅使用 $[0,1]$ 上的独立均匀变量来构建非均匀样本。您的程序必须是确定性的：为底层的均匀随机数生成器使用固定的种子 $123456$（十进制整数）。\n\n测试套件。对下面的每个元组 $(a,c,b,N,\\delta_\\mu,\\delta_{\\sigma^2},\\delta_{\\mathrm{KS}})$，执行上述过程：\n- 测试 1：$(0.0,\\,0.5,\\,1.0,\\,200000,\\,0.002,\\,0.003,\\,0.01)$\n- 测试 2：$(0.0,\\,0.0,\\,5.0,\\,150000,\\,0.01,\\,0.03,\\,0.02)$\n- 测试 3：$(-2.0,\\,1.0,\\,1.0,\\,140000,\\,0.01,\\,0.03,\\,0.02)$\n- 测试 4：$(-3.0,\\,-1.0,\\,2.0,\\,160000,\\,0.008,\\,0.03,\\,0.02)$\n\n答案规范和最终输出格式。对于四个测试中的每一个，返回一个布尔值，指示测试是否通过。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按测试顺序排列结果；例如，一个有效的输出行如下所示\n$[{\\tt True},{\\tt False},{\\tt True},{\\tt True}]$。",
            "solution": "问题陈述已经过验证，被认为是有效的。它构成了一个计算物理学中适定（well-posed）的问题，特别是在非均匀随机变量的生成方面。任务是使用逆变换采样法从三角形分布中生成样本，然后使用标准统计检验，根据理论属性验证生成的样本。该问题具有科学依据、客观，并为得出唯一的、可验证的解决方案提供了所有必要信息。在众数 $c$ 等于端点 $a$ 或 $b$ 的边界情况下，概率密度函数（PDF）缺乏明确定义，这是一个微小的不精确之处，但任何有能力的从业者都可以通过考虑极限或分布的几何形状来严格解决，这是一项标准的练习。\n\n解决方案分几个步骤进行：首先，我们推导累积分布函数（CDF）及其反函数，这对于逆变换采样法至关重要。其次，我们陈述分布的理论均值和方差。第三，我们详细说明计算柯尔莫哥洛夫-斯米尔诺夫统计量的算法。\n\n三角形分布由支撑集 $x \\in [a,b]$ 上的概率密度函数（PDF）$f(x; a,c,b)$ 定义：\n$$\nf(x; a,c,b) =\n\\begin{cases}\n\\dfrac{2(x-a)}{(b-a)(c-a)},  a \\le x \\le c \\\\\n\\dfrac{2(b-x)}{(b-a)(b-c)},  c  x \\le b\n\\end{cases}\n$$\n这在 $a  c  b$ 时有效。我们将在推导过程中处理 $c=a$ 和 $c=b$ 的边界情况。\n\n选择的样本生成方法是逆变换采样法。该方法依赖于这样一个事实：如果 $X$ 是一个具有累积分布函数 $F_X(x)$ 的连续随机变量，那么随机变量 $U = F_X(X)$ 在 $[0,1]$ 上均匀分布。因此，我们可以通过生成均匀随机变量 $u \\in [0,1]$ 并计算 $x = F_X^{-1}(u)$ 来生成 $X$ 的样本。\n\n累积分布函数（CDF）的推导，$F(x) = \\int_{-\\infty}^x f(t) dt$：\n对于 $x  a$，有 $F(x)=0$。\n对于 $a \\le x \\le c$：\n$$\nF(x) = \\int_a^x \\frac{2(t-a)}{(b-a)(c-a)} dt = \\frac{2}{(b-a)(c-a)} \\left[ \\frac{(t-a)^2}{2} \\right]_a^x = \\frac{(x-a)^2}{(b-a)(c-a)}\n$$\n在众数 $c$ 处的值为 $F(c) = \\frac{(c-a)^2}{(b-a)(c-a)} = \\frac{c-a}{b-a}$。\n\n对于 $c  x \\le b$：\n$$\nF(x) = F(c) + \\int_c^x \\frac{2(b-t)}{(b-a)(b-c)} dt = \\frac{c-a}{b-a} + \\left[ \\frac{-(b-t)^2}{(b-a)(b-c)} \\right]_c^x\n$$\n$$\nF(x) = \\frac{c-a}{b-a} + \\frac{-(b-x)^2 - (-(b-c)^2)}{(b-a)(b-c)} = \\frac{c-a}{b-a} + \\frac{(b-c)^2 - (b-x)^2}{(b-a)(b-c)}\n$$\n这个表达式可以简化为一个更优雅的形式：\n$$\nF(x) = 1 - \\frac{(b-x)^2}{(b-a)(b-c)}\n$$\n对于 $x > b$，有 $F(x)=1$。\n总而言之，对于一般情况 $a  c  b$：\n$$\nF(x; a,c,b) =\n\\begin{cases}\n0,  x  a \\\\\n\\frac{(x-a)^2}{(b-a)(c-a)},  a \\le x \\le c \\\\\n1 - \\frac{(b-x)^2}{(b-a)(b-c)},  c  x \\le b \\\\\n1,  x > b\n\\end{cases}\n$$\n对于边界情况 $c=a$（一个从 $a$ 到 $b$ 递减的直角三角形分布），PDF 仅在 $x \\in [a,b]$ 上非零，由 $f(x) = \\frac{2(b-x)}{(b-a)^2}$ 给出。对于 $x \\in [a,b]$，CDF 变为 $F(x) = 1 - \\frac{(b-x)^2}{(b-a)^2}$。\n对于边界情况 $c=b$（一个从 $a$ 到 $b$ 递增的直角三角形分布），对于 $x \\in [a,b]$，PDF 为 $f(x) = \\frac{2(x-a)}{(b-a)^2}$。对于 $x \\in [a,b]$，CDF 变为 $F(x) = \\frac{(x-a)^2}{(b-a)^2}$。\n\n逆 CDF 的推导，$x = F^{-1}(u)$：\n我们设 $u = F(x)$，其中 $u \\in [0,1]$，然后解出 $x$。\n设 $F_c = F(c) = \\frac{c-a}{b-a}$。\n如果 $0 \\le u \\le F_c$，这对应于 $a \\le x \\le c$。\n$$ u = \\frac{(x-a)^2}{(b-a)(c-a)} \\implies x = a + \\sqrt{u(b-a)(c-a)} $$\n如果 $F_c  u \\le 1$，这对应于 $c  x \\le b$。\n$$ u = 1 - \\frac{(b-x)^2}{(b-a)(b-c)} \\implies x = b - \\sqrt{(1-u)(b-a)(b-c)} $$\n对于边界情况，这些公式会简化。\n如果 $c=a$，那么 $F_c=0$，对任意 $u \\in [0,1]$ 我们使用第二种形式，它变为 $x = b - \\sqrt{(1-u)(b-a)^2} = b - (b-a)\\sqrt{1-u}$。\n如果 $c=b$，那么 $F_c=1$，对任意 $u \\in [0,1]$ 我们使用第一种形式，它变为 $x = a + \\sqrt{u(b-a)^2} = a + (b-a)\\sqrt{u}$。\n\n理论与样本统计：\n三角形分布的理论均值 $\\mu$ 和方差 $\\sigma^2$ 由以下公式给出：\n$$ \\mu = \\frac{a+b+c}{3} $$\n$$ \\sigma^2 = \\frac{(a-b)^2 + (b-c)^2 + (c-a)^2}{36} $$\n给定一组 $N$ 个生成的样本 $\\{X_i\\}_{i=1}^N$，样本均值 $\\bar{X}$ 和样本方差 $S_N^2$（使用总体归一化）为：\n$$ \\bar{X} = \\frac{1}{N} \\sum_{i=1}^N X_i $$\n$$ S_N^2 = \\frac{1}{N} \\sum_{i=1}^N (X_i - \\bar{X})^2 $$\n那么绝对误差为 $|\\bar{X} - \\mu|$ 和 $|S_N^2 - \\sigma^2|$。\n\n柯尔莫哥洛夫-斯米尔诺夫统计量：\n柯尔莫哥洛夫-斯米尔诺夫（KS）统计量 $D_N$ 衡量经验分布函数（EDF）$F_N(x)$ 与理论累积分布函数（CDF）$F(x)$ 之间的最大距离。\n$$ D_N = \\sup_x |F_N(x) - F(x)| $$\n一组样本的经验分布函数为 $F_N(x) = \\frac{1}{N}\\sum_{i=1}^N I(X_i \\le x)$，其中 $I(\\cdot)$ 是指示函数。\n为了计算方便，如果我们将样本排序使得 $X_{(1)} \\le X_{(2)} \\le \\dots \\le X_{(N)}$，则可以使用以下公式高效地计算统计量 $D_N$：\n$$ D_N = \\max_{i=1,\\dots,N} \\left( \\frac{i}{N} - F(X_{(i)}) , F(X_{(i)}) - \\frac{i-1}{N} \\right) $$\n每个测试用例的流程是：生成 $N$ 个样本，计算样本均值、样本方差和 KS 统计量，并验证它们与理论值各自的偏差是否在指定的容差 $\\delta_\\mu$、$\\delta_{\\sigma^2}$ 和 $\\delta_{\\mathrm{KS}}$ 之内。当且仅当所有三个条件都满足时，测试才算通过。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that executes the validation tests for generating\n    samples from a triangular distribution.\n    \"\"\"\n    test_cases = [\n        (0.0, 0.5, 1.0, 200000, 0.002, 0.003, 0.01),\n        (0.0, 0.0, 5.0, 150000, 0.01, 0.03, 0.02),\n        (-2.0, 1.0, 1.0, 140000, 0.01, 0.03, 0.02),\n        (-3.0, -1.0, 2.0, 160000, 0.008, 0.03, 0.02)\n    ]\n\n    results = []\n    \n    # Use a fixed seed for the random number generator for deterministic output.\n    seed = 123456\n    rng = np.random.default_rng(seed)\n\n    for case in test_cases:\n        a, c, b, N, tol_mu, tol_var, tol_ks = case\n        \n        # Step 1: Generate N independent samples from the triangular distribution.\n        samples = _generate_triangular_samples(a, c, b, N, rng)\n        \n        # Step 2: Compute the sample mean and the sample variance.\n        sample_mean = np.mean(samples)\n        sample_var = np.var(samples) # Uses N in the denominator by default (ddof=0).\n\n        # Compute theoretical mean and variance.\n        true_mean = (a + b + c) / 3.0\n        true_var = ((a - b)**2 + (b - c)**2 + (c - a)**2) / 36.0\n\n        # Step 3: Compute the Kolmogorov–Smirnov statistic.\n        sorted_samples = np.sort(samples)\n        cdf_at_samples = _get_triangular_cdf(sorted_samples, a, c, b)\n        \n        i_vals = np.arange(1, N + 1)\n        d_plus = np.max(i_vals / N - cdf_at_samples)\n        d_minus = np.max(cdf_at_samples - (i_vals - 1) / N)\n        ks_stat = max(d_plus, d_minus)\n        \n        # Step 4: Compare errors with tolerances.\n        err_mean = abs(sample_mean - true_mean)\n        err_var = abs(sample_var - true_var)\n        \n        test_passed = (err_mean = tol_mu) and \\\n                      (err_var = tol_var) and \\\n                      (ks_stat = tol_ks)\n                      \n        results.append(test_passed)\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef _generate_triangular_samples(a, c, b, N, rng):\n    \"\"\"\n    Generates N samples from a triangular distribution using inverse transform sampling.\n    \"\"\"\n    u = rng.uniform(0.0, 1.0, N)\n    samples = np.zeros(N, dtype=float)\n    \n    # Handle the edge cases of right-triangular distributions\n    if a == c:\n        # Decreasing right-triangular distribution\n        samples = b - (b - a) * np.sqrt(1 - u)\n    elif b == c:\n        # Increasing right-triangular distribution\n        samples = a + (b - a) * np.sqrt(u)\n    else:\n        # General scalene-triangular distribution\n        fc = (c - a) / (b - a)\n        term1_factor = (b - a) * (c - a)\n        term2_factor = (b - a) * (b - c)\n        \n        # Create a boolean mask for u = fc\n        mask = u = fc\n        \n        # For u = fc, use the first part of the inverse CDF\n        samples[mask] = a + np.sqrt(u[mask] * term1_factor)\n        \n        # For u > fc, use the second part\n        samples[~mask] = b - np.sqrt((1.0 - u[~mask]) * term2_factor)\n        \n    return samples\n\ndef _get_triangular_cdf(x, a, c, b):\n    \"\"\"\n    Computes the exact Cumulative Distribution Function (CDF) for a triangular distribution.\n    The input x can be a scalar or a numpy array for vectorized computation.\n    \"\"\"\n    x = np.asarray(x, dtype=float)\n    cdf_vals = np.zeros_like(x, dtype=float)\n    \n    # Handle the edge cases of right-triangular distributions\n    if a == c:\n        # Mask for values within the support [a, b]\n        mask_mid = (x >= a)  (x = b)\n        cdf_vals[mask_mid] = 1.0 - ((b - x[mask_mid])**2 / (b - a)**2)\n    elif b == c:\n        # Mask for values within the support [a, b]\n        mask_mid = (x >= a)  (x = b)\n        cdf_vals[mask_mid] = (x[mask_mid] - a)**2 / (b - a)**2\n    else:\n        # General scalene-triangular distribution\n        mask1 = (x >= a)  (x = c)\n        mask2 = (x > c)  (x = b)\n        \n        cdf_vals[mask1] = (x[mask1] - a)**2 / ((b - a) * (c - a))\n        cdf_vals[mask2] = 1.0 - (b - x[mask2])**2 / ((b - a) * (b - c))\n\n    # For values outside the support [a, b]\n    cdf_vals[x > b] = 1.0\n    cdf_vals[x  a] = 0.0\n\n    return cdf_vals\n\nsolve()\n```"
        },
        {
            "introduction": "许多物理模型的核心是正态（高斯）分布，但我们如何从基本的均匀分布生成器中得到它呢？本练习  将介绍精妙的Box-Muller变换，它能将一对独立的均匀随机数转换为一对独立的标准正态随机数。更进一步，我们将学习如何通过线性变换（具体来说，使用Cholesky分解）将这些独立样本转化为具有任意均值和协方差的多元正态分布样本，这是模拟具有内部相互作用的复杂系统的关键一步。",
            "id": "2398116",
            "problem": "您需要编写一个完整、可运行的程序，仅从开区间 $(0,1)$ 上的独立均匀随机数开始，构建二维非均匀随机变量，然后根据指定的目标属性验证生成的样本。任务如下。\n\n任务。给定 $(0,1)$ 上的独立均匀随机输入，生成二维向量 $\\mathbf{X} \\in \\mathbb{R}^{2}$ 的样本，使得：\n- 在独立情况下，$\\mathbf{X}$ 服从标准二元正态分布，其均值向量为 $\\boldsymbol{\\mu}=\\begin{bmatrix}0 \\\\ 0\\end{bmatrix}$，协方差矩阵为 $\\boldsymbol{\\Sigma}=\\mathbf{I}_{2}$，其中 $\\mathbf{I}_{2}$ 表示 $2 \\times 2$ 单位矩阵。\n- 在相关情况下，$\\mathbf{X}$ 服从一个二元正态分布，其均值向量为指定的 $\\boldsymbol{\\mu}\\in\\mathbb{R}^{2}$，协方差矩阵为指定的对称正定矩阵 $\\boldsymbol{\\Sigma}\\in\\mathbb{R}^{2\\times 2}$。\n\n验证。对于给定的样本量 $N$，计算经验均值\n$$\n\\hat{\\boldsymbol{\\mu}}=\\frac{1}{N}\\sum_{i=1}^{N}\\mathbf{X}_{i}\n$$\n和经验协方差（使用总体归一化）\n$$\n\\hat{\\boldsymbol{\\Sigma}}=\\frac{1}{N}\\sum_{i=1}^{N}\\left(\\mathbf{X}_{i}-\\hat{\\boldsymbol{\\mu}}\\right)\\left(\\mathbf{X}_{i}-\\hat{\\boldsymbol{\\mu}}\\right)^{\\top}.\n$$\n定义均值误差 $e_{\\mu}=\\max_{j\\in\\{1,2\\}}\\left|\\hat{\\mu}_{j}-\\mu_{j}\\right|$ 和协方差误差 $e_{\\Sigma}=\\max_{j,k\\in\\{1,2\\}}\\left|\\hat{\\Sigma}_{jk}-\\Sigma_{jk}\\right|$。如果对于为该测试指定的容差 $\\varepsilon_{\\mu}$ 和 $\\varepsilon_{\\Sigma}$，均满足 $e_{\\mu}\\varepsilon_{\\mu}$ 和 $e_{\\Sigma}\\varepsilon_{\\Sigma}$，则认为测试通过。\n\n随机性与可复现性。使用固定的伪随机种子 $s$ 来初始化均匀生成器，以确保结果是可复现的。使用整数种子 $s=123456789$。\n\n测试套件。您的程序必须按顺序运行以下四个测试，每个测试根据上述通过/失败规则产生一个布尔值。\n\n- 测试 $\\mathbf{T1}$（独立，大样本）：\n  - 目标参数：$\\boldsymbol{\\mu}=\\begin{bmatrix}0 \\\\ 0\\end{bmatrix}$，$\\boldsymbol{\\Sigma}=\\begin{bmatrix}1  0 \\\\ 0  1\\end{bmatrix}$。\n  - 样本量：$N=200{,}000$。\n  - 容差：$\\varepsilon_{\\mu}=0.02$，$\\varepsilon_{\\Sigma}=0.02$。\n\n- 测试 $\\mathbf{T2}$（独立，小样本边缘情况）：\n  - 目标参数：$\\boldsymbol{\\mu}=\\begin{bmatrix}0 \\\\ 0\\end{bmatrix}$，$\\boldsymbol{\\Sigma}=\\begin{bmatrix}1  0 \\\\ 0  1\\end{bmatrix}$。\n  - 样本量：$N=100$。\n  - 容差：$\\varepsilon_{\\mu}=0.30$，$\\varepsilon_{\\Sigma}=0.30$。\n\n- 测试 $\\mathbf{T3}$（相关，一般情况）：\n  - 目标参数：$\\boldsymbol{\\mu}=\\begin{bmatrix}1.5 \\\\ -0.5\\end{bmatrix}$，$\\boldsymbol{\\Sigma}=\\begin{bmatrix}4.0  1.2 \\\\ 1.2  1.0\\end{bmatrix}$。\n  - 样本量：$N=300{,}000$。\n  - 容差：$\\varepsilon_{\\mu}=0.03$，$\\varepsilon_{\\Sigma}=0.03$。\n\n- 测试 $\\mathbf{T4}$（相关，近边界相关性）：\n  - 目标参数：$\\boldsymbol{\\mu}=\\begin{bmatrix}0 \\\\ 0\\end{bmatrix}$，$\\boldsymbol{\\Sigma}=\\begin{bmatrix}1.0  -0.95 \\\\ -0.95  1.0\\end{bmatrix}$。\n  - 样本量：$N=300{,}000$。\n  - 容差：$\\varepsilon_{\\mu}=0.03$，$\\varepsilon_{\\Sigma}=0.04$。\n\n输出规范。您的程序应产生单行输出，其中包含四个测试 $\\mathbf{T1}$、$\\mathbf{T2}$、$\\mathbf{T3}$ 和 $\\mathbf{T4}$ 的结果，形式为一个逗号分隔的布尔值列表，并用方括号括起来，例如\n$[\\text{True},\\text{False},\\text{True},\\text{True}]$。\n不允许有其他输出。",
            "solution": "对问题陈述进行验证。\n\n逐字提取给定条件：\n- 任务是从开区间 $(0,1)$ 上的独立均匀随机数生成二维向量 $\\mathbf{X} \\in \\mathbb{R}^{2}$ 的样本。\n- 在独立情况下，目标是均值向量为 $\\boldsymbol{\\mu}=\\begin{bmatrix}0 \\\\ 0\\end{bmatrix}$、协方差矩阵为 $\\boldsymbol{\\Sigma}=\\mathbf{I}_{2}$ 的标准二元正态分布。\n- 在相关情况下，目标是具有指定均值向量 $\\boldsymbol{\\mu}\\in\\mathbb{R}^{2}$ 和指定对称正定协方差矩阵 $\\boldsymbol{\\Sigma}\\in\\mathbb{R}^{2\\times 2}$ 的二元正态分布。\n- 验证要求对于大小为 $N$ 的样本，计算经验均值 $\\hat{\\boldsymbol{\\mu}}=\\frac{1}{N}\\sum_{i=1}^{N}\\mathbf{X}_{i}$ 和经验协方差 $\\hat{\\boldsymbol{\\Sigma}}=\\frac{1}{N}\\sum_{i=1}^{N}\\left(\\mathbf{X}_{i}-\\hat{\\boldsymbol{\\mu}}\\right)\\left(\\mathbf{X}_{i}-\\hat{\\boldsymbol{\\mu}}\\right)^{\\top}$。\n- 误差定义为 $e_{\\mu}=\\max_{j\\in\\{1,2\\}}\\left|\\hat{\\mu}_{j}-\\mu_{j}\\right|$ 和 $e_{\\Sigma}=\\max_{j,k\\in\\{1,2\\}}\\left|\\hat{\\Sigma}_{jk}-\\Sigma_{jk}\\right|$。\n- 如果 $e_{\\mu}\\varepsilon_{\\mu}$ 和 $e_{\\Sigma}\\varepsilon_{\\Sigma}$，则测试通过。\n- 必须使用固定的伪随机种子 $s=123456789$。\n- 指定了四个测试用例（$\\mathbf{T1}$, $\\mathbf{T2}$, $\\mathbf{T3}$, $\\mathbf{T4}$）及其各自的参数（$\\boldsymbol{\\mu}$, $\\boldsymbol{\\Sigma}$, $N$, $\\varepsilon_{\\mu}$, $\\varepsilon_{\\Sigma}$）。\n\n根据所需标准对问题进行验证。该问题具有科学依据，提法明确且客观。它涉及计算物理和统计学中的一个标准且基本的技术：非均匀随机变量的生成。其理论基础稳固，利用了 Box-Muller 变换和 Cholesky 分解等方法。提供了唯一、可验证解所需的所有参数和定义。经确认，为相关测试指定的协方差矩阵是对称正定的，这确保了有效的 Cholesky 分解存在。对于测试 $\\mathbf{T3}$，$\\det(\\boldsymbol{\\Sigma}) = 4.0 \\times 1.0 - 1.2^2 = 2.56  0$。对于测试 $\\mathbf{T4}$，$\\det(\\boldsymbol{\\Sigma}) = 1.0 \\times 1.0 - (-0.95)^2 = 0.0975  0$。因此，该问题被认定为有效。\n\n解决方案分三部分构建：标准正态随机变量的生成、到一般二元正态分布的转换以及经验验证。\n\n首先，我们处理从均匀分布生成独立标准正态随机变量的问题。该问题要求从开区间 $(0,1)$ 上的均匀分布中抽取的独立随机数 $U_{1}, U_{2}$ 开始。一种标准且高效的方法是 Box-Muller 变换。该变换接收两个这样的均匀变量，并通过以下关系生成两个独立的标准正态变量 $Z_{1}, Z_{2} \\sim \\mathcal{N}(0,1)$：\n$$\nZ_1 = \\sqrt{-2 \\ln U_1} \\cos(2 \\pi U_2)\n$$\n$$\nZ_2 = \\sqrt{-2 \\ln U_1} \\sin(2 \\pi U_2)\n$$\n这两个变量构成一个随机向量 $\\mathbf{Z} = \\begin{bmatrix} Z_1 \\\\ Z_2 \\end{bmatrix}$，它服从标准二元正态分布 $\\mathbf{Z} \\sim \\mathcal{N}(\\mathbf{0}, \\mathbf{I}_2)$。此过程足以生成测试 $\\mathbf{T1}$ 和 $\\mathbf{T2}$ 所需的样本，其中目标分布确实是 $\\mathcal{N}(\\mathbf{0}, \\mathbf{I}_2)$。\n\n其次，我们发展从一般二元正态分布 $\\mathcal{N}(\\boldsymbol{\\mu}, \\boldsymbol{\\Sigma})$ 生成样本的方法，这是测试 $\\mathbf{T3}$ 和 $\\mathbf{T4}$ 所要求的。这是通过对第一步中生成的标准正态向量 $\\mathbf{Z}$ 应用仿射变换来实现的。设所需随机向量为 $\\mathbf{X}$。我们寻求一个形式为 $\\mathbf{X} = \\mathbf{A}\\mathbf{Z} + \\mathbf{b}$ 的变换，其中 $\\mathbf{A}$ 是某个矩阵，$\\mathbf{b}$ 是某个向量。$\\mathbf{X}$ 的期望为 $E[\\mathbf{X}] = E[\\mathbf{A}\\mathbf{Z} + \\mathbf{b}] = \\mathbf{A}E[\\mathbf{Z}] + \\mathbf{b}$。由于 $E[\\mathbf{Z}] = \\mathbf{0}$，这简化为 $E[\\mathbf{X}] = \\mathbf{b}$。为了匹配目标均值 $\\boldsymbol{\\mu}$，我们必须设置 $\\mathbf{b} = \\boldsymbol{\\mu}$。$\\mathbf{X}$ 的协方差矩阵由以下公式给出：\n$$\n\\text{Cov}(\\mathbf{X}) = E\\left[ (\\mathbf{X}-\\boldsymbol{\\mu})(\\mathbf{X}-\\boldsymbol{\\mu})^{\\top} \\right] = E\\left[ (\\mathbf{A}\\mathbf{Z})(\\mathbf{A}\\mathbf{Z})^{\\top} \\right] = E\\left[ \\mathbf{A}\\mathbf{Z}\\mathbf{Z}^{\\top}\\mathbf{A}^{\\top} \\right] = \\mathbf{A} E[\\mathbf{Z}\\mathbf{Z}^{\\top}] \\mathbf{A}^{\\top}\n$$\n矩阵 $E[\\mathbf{Z}\\mathbf{Z}^{\\top}]$ 是 $\\mathbf{Z}$ 的协方差矩阵，即单位矩阵 $\\mathbf{I}_2$。因此，$\\text{Cov}(\\mathbf{X}) = \\mathbf{A}\\mathbf{A}^{\\top}$。为了匹配目标协方差矩阵 $\\boldsymbol{\\Sigma}$，我们必须找到一个矩阵 $\\mathbf{A}$ 使得 $\\mathbf{A}\\mathbf{A}^{\\top} = \\boldsymbol{\\Sigma}$。由于问题指定 $\\boldsymbol{\\Sigma}$ 是对称正定矩阵，可以使用 Cholesky 分解找到 $\\mathbf{A}$ 的一个解。$\\boldsymbol{\\Sigma}$ 的 Cholesky 分解产生一个唯一的、对角线元素为正的下三角矩阵 $\\mathbf{L}$，使得 $\\boldsymbol{\\Sigma} = \\mathbf{L}\\mathbf{L}^{\\top}$。我们选择 $\\mathbf{A} = \\mathbf{L}$。\n因此，完整的变换是：\n$$\n\\mathbf{X} = \\mathbf{L}\\mathbf{Z} + \\boldsymbol{\\mu}\n$$\n其中 $\\mathbf{Z} \\sim \\mathcal{N}(\\mathbf{0}, \\mathbf{I}_2)$ 且 $\\mathbf{L}$ 是 $\\boldsymbol{\\Sigma}$ 的 Cholesky 因子。要为给定测试生成 $N$ 个样本 $\\mathbf{X}_i$，我们首先使用 Box-Muller 变换生成 $N$ 个独立向量 $\\mathbf{Z}_i$，然后对每个向量应用仿射变换。\n\n第三，按规定实施验证程序。对于每个测试，在生成大小为 $N$ 的样本 $\\{\\mathbf{X}_1, \\dots, \\mathbf{X}_N\\}$ 后，计算经验均值向量 $\\hat{\\boldsymbol{\\mu}}$ 作为样本的算术平均值。然后通过减去该经验均值来对数据进行中心化。设中心化后的数据矩阵为 $\\mathbf{D}_{\\text{cent}}$，大小为 $N \\times 2$，其中每一行是 $(\\mathbf{X}_i - \\hat{\\boldsymbol{\\mu}})^T$。然后使用矩阵乘法高效地计算经验协方差矩阵 $\\hat{\\boldsymbol{\\Sigma}}$，这等价于所提供的求和公式：\n$$\n\\hat{\\boldsymbol{\\Sigma}} = \\frac{1}{N} \\mathbf{D}_{\\text{cent}}^{\\top} \\mathbf{D}_{\\text{cent}}\n$$\n最后，计算元素级的最大绝对误差 $e_{\\mu} = \\max_{j} |\\hat{\\mu}_j - \\mu_j|$ 和 $e_{\\Sigma} = \\max_{j,k} |\\hat{\\Sigma}_{jk} - \\Sigma_{jk}|$，并与指定的容差 $\\varepsilon_{\\mu}$ 和 $\\varepsilon_{\\Sigma}$ 进行比较，以确定测试是否通过。对四个测试用例中的每一个都使用固定的随机种子 $s=123456789$ 执行整个过程，以保证可复现性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of generating and validating non-uniform random variables.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # T1: independent, large sample\n        {\n            \"name\": \"T1\",\n            \"mu\": np.array([0.0, 0.0]),\n            \"Sigma\": np.array([[1.0, 0.0], [0.0, 1.0]]),\n            \"N\": 200000,\n            \"eps_mu\": 0.02,\n            \"eps_Sigma\": 0.02,\n        },\n        # T2: independent, small sample\n        {\n            \"name\": \"T2\",\n            \"mu\": np.array([0.0, 0.0]),\n            \"Sigma\": np.array([[1.0, 0.0], [0.0, 1.0]]),\n            \"N\": 100,\n            \"eps_mu\": 0.30,\n            \"eps_Sigma\": 0.30,\n        },\n        # T3: correlated, general case\n        {\n            \"name\": \"T3\",\n            \"mu\": np.array([1.5, -0.5]),\n            \"Sigma\": np.array([[4.0, 1.2], [1.2, 1.0]]),\n            \"N\": 300000,\n            \"eps_mu\": 0.03,\n            \"eps_Sigma\": 0.03,\n        },\n        # T4: correlated, near-boundary correlation\n        {\n            \"name\": \"T4\",\n            \"mu\": np.array([0.0, 0.0]),\n            \"Sigma\": np.array([[1.0, -0.95], [-0.95, 1.0]]),\n            \"N\": 300000,\n            \"eps_mu\": 0.03,\n            \"eps_Sigma\": 0.04,\n        },\n    ]\n\n    # Initialize the random number generator with the specified seed for reproducibility.\n    seed = 123456789\n    rng = np.random.default_rng(seed)\n\n    results = []\n\n    for case in test_cases:\n        N = case[\"N\"]\n        mu_target = case[\"mu\"]\n        Sigma_target = case[\"Sigma\"]\n        eps_mu = case[\"eps_mu\"]\n        eps_Sigma = case[\"eps_Sigma\"]\n\n        # Step 1: Generate uniform random numbers in (0, 1).\n        # We need N pairs of uniform numbers for the Box-Muller transform.\n        # To strictly be in (0, 1), we use np.nextafter to avoid log(0).\n        u = rng.uniform(low=np.nextafter(0, 1), high=1, size=(N, 2))\n        U1 = u[:, 0]\n        U2 = u[:, 1]\n        \n        # Step 2: Apply Box-Muller transform to get standard normal variates.\n        R = np.sqrt(-2.0 * np.log(U1))\n        theta = 2.0 * np.pi * U2\n        \n        Z1 = R * np.cos(theta)\n        Z2 = R * np.sin(theta)\n        \n        # Z is an (N, 2) matrix of standard normal samples.\n        Z = np.vstack([Z1, Z2]).T\n\n        # Step 3: Transform standard normal samples to the target distribution.\n        # X = L @ Z.T + mu, where L is the Cholesky factor of Sigma.\n        if np.array_equal(Sigma_target, np.eye(2)):\n            # For the standard normal case, L is the identity matrix.\n            L = np.eye(2)\n        else:\n            # For the general case, compute the Cholesky decomposition.\n            L = np.linalg.cholesky(Sigma_target)\n\n        # Apply the affine transformation.\n        # Z.T is (2, N). L @ Z.T is (2, N). Transpose to get (N, 2).\n        # Add mu (broadcasts over rows).\n        X = (L @ Z.T).T + mu_target\n\n        # Step 4: Validate the generated samples.\n        # Compute empirical mean.\n        mu_hat = np.mean(X, axis=0)\n\n        # Compute empirical covariance with population normalization (ddof=0).\n        # np.cov calculates this directly. rowvar=False treats columns as variables.\n        Sigma_hat = np.cov(X, rowvar=False, ddof=0)\n        \n        # Compute errors.\n        e_mu = np.max(np.abs(mu_hat - mu_target))\n        e_Sigma = np.max(np.abs(Sigma_hat - Sigma_target))\n        \n        # Check against tolerances.\n        test_passed = (e_mu  eps_mu) and (e_Sigma  eps_Sigma)\n        results.append(test_passed)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "尽管逆变换采样法非常强大，但在许多实际问题中，我们可能无法得到累积分布函数（CDF）反函数的解析表达式。本练习  直面这一挑战，要求我们从一个通用的非负多项式定义的概率密度中进行采样。你将学习如何将逆变换采样的思想与数值方法（如求根算法）相结合，当解析解不存在时，通过数值计算来“反转”CDF，这种方法极大地扩展了该技术的适用范围，使其成为一个处理复杂分布的通用工具。",
            "id": "2398130",
            "problem": "给定一个定义在有限区间 $[a,b]$ 上的非负多项式 $P(x) = \\sum_{i=0}^{N} c_i x^i$，其中 $N$ 是一个非负整数，且对于所有 $i \\in \\{0,1,\\dots,N\\}$ 都有 $c_i \\in \\mathbb{R}$。假设对于所有 $x \\in [a,b]$ 都有 $P(x) \\ge 0$，并且 $\\int_a^b P(x)\\,dx  0$。在 $[a,b]$ 上定义归一化概率密度函数 $p(x)$ 如下：\n$$\np(x) = \\frac{P(x)}{Z}, \\quad \\text{其中 } Z = \\int_a^b P(x)\\,dx.\n$$\n设 $p(x)$ 的累积分布函数 (CDF) $F(x)$ 为\n$$\nF(x) = \\int_a^x p(t)\\,dt, \\quad x \\in [a,b].\n$$\n您的任务是实现一个程序，该程序针对下述的每个测试用例，生成在 $[a,b]$ 上服从 $p(x)$ 分布的独立随机变量，然后评估定量诊断指标，将生成的样本与从 $P(x)$ 导出的精确分布进行比较。\n\n对于每个测试用例，您必须：\n- 使用所提供的多项式系数 $\\{c_i\\}_{i=0}^N$、区间端点 $a$ 和 $b$、样本大小 $n$ 以及随机种子 $s$。\n- 生成 $n$ 个在 $[a,b]$ 上具有密度 $p(x)$ 的独立样本。\n- 计算精确的归一化常数 $Z = \\int_a^b P(x)\\,dx$。\n- 通过以下公式计算在 $p(x)$ 分布下的精确矩 $\\mathbb{E}[X]$ 和 $\\mathbb{E}[X^2]$：\n$$\n\\mathbb{E}[X^m] = \\frac{\\int_a^b x^m P(x)\\,dx}{\\int_a^b P(x)\\,dx}, \\quad \\text{for } m \\in \\{1,2\\}.\n$$\n- 根据生成的样本，计算经验均值和经验二阶矩（即样本中 $X^2$ 的平均值）。\n- 为每个测试用例报告三个实数：\n  1) 样本均值相对于精确值 $\\mathbb{E}[X]$ 的绝对误差，\n  2) 样本二阶矩相对于精确值 $\\mathbb{E}[X^2]$ 的绝对误差，\n  3) Kolmogorov–Smirnov 统计量 $D_n = \\sup_{x \\in \\mathbb{R}} |F_n(x) - F(x)|$，其中 $F_n$ 是基于 $n$ 个样本的经验累积分布函数，$F$ 是由 $P(x)$ 在 $[a,b]$ 上导出的精确 CDF，并扩展为当 $x  a$ 时为 $0$、当 $x  b$ 时为 $1$。\n\n测试套件：\n- 用例 $1$：$N = 0$，系数 $[c_0] = [1.0]$，区间 $[a,b] = [0.0, 1.0]$，样本大小 $n = 20000$，种子 $s = 12345$。\n- 用例 $2$：$N = 1$，系数 $[c_0,c_1] = [0.0, 1.0]$，区间 $[a,b] = [0.0, 1.0]$，样本大小 $n = 30000$，种子 $s = 2024$。\n- 用例 $3$：$N = 2$，系数 $[c_0,c_1,c_2] = [0.35, -1.0, 1.0]$，区间 $[a,b] = [0.0, 1.0]$，样本大小 $n = 40000$，种子 $s = 424242$。\n- 用例 $4$：$N = 2$，系数 $[c_0,c_1,c_2] = [2.0, 1.0, -1.0]$，区间 $[a,b] = [-1.0, 2.0]$，样本大小 $n = 50000$，种子 $s = 731$。\n\n最终输出格式：\n- 您的程序必须生成单行输出，其中按顺序包含所有汇总结果，形式为用方括号括起来的逗号分隔列表。\n- 从用例 1 到用例 4 的顺序必须是：$[\\Delta \\mu_1, \\Delta m_{2,1}, D_{n,1}, \\Delta \\mu_2, \\Delta m_{2,2}, D_{n,2}, \\Delta \\mu_3, \\Delta m_{2,3}, D_{n,3}, \\Delta \\mu_4, \\Delta m_{2,4}, D_{n,4}]$，其中 $\\Delta \\mu_k$ 是用例 $k$ 的样本均值的绝对误差，$\\Delta m_{2,k}$ 是用例 $k$ 的样本二阶矩的绝对误差，而 $D_{n,k}$ 是用例 $k$ 的 Kolmogorov–Smirnov 统计量。\n- 输出中的每个实数必须四舍五入到恰好 $6$ 位小数。\n- 例如，格式类似于 $[r_1,r_2,\\dots,r_{12}]$，其中每个 $r_j$ 是一个打印为恰好 $6$ 位小数的实数。",
            "solution": "问题陈述已经过验证，并被认为是可接受的。它具有科学依据、提法明确，并且包含推导唯一且可验证解所需的所有必要信息。该问题属于计算物理学的标准领域，涉及非均匀随机变量的生成。每个测试用例的前提条件——即多项式 $P(x)$ 在指定区间 $[a,b]$ 上的非负性——已经过验证并且成立。\n\n求解过程系统地进行，基于概率论和数值方法的基本原理。\n\n首先，我们形式化与区间 $[a,b]$ 上的给定多项式 $P(x) = \\sum_{i=0}^{N} c_i x^i$ 相关的概率分布。未归一化的密度是 $P(x)$。为了创建一个有效的概率密度函数 (PDF) $p(x)$，我们必须用 $P(x)$ 在其定义域上的积分来对其进行归一化。归一化常数 $Z$ 由下式给出：\n$$\nZ = \\int_a^b P(x) \\,dx\n$$\n由于 $P(x)$ 是一个多项式，其不定积分（我们记为 $Q(x) = \\int P(x) \\,dx$）也是一个多项式。具体来说，\n$$\nQ(x) = \\sum_{i=0}^{N} c_i \\frac{x^{i+1}}{i+1}\n$$\n根据微积分基本定理，归一化常数就是 $Z = Q(b) - Q(a)$。于是，PDF 可以被正确地定义为当 $x \\in [a,b]$ 时 $p(x) = P(x) / Z$，其他情况下 $p(x) = 0$。\n\n累积分布函数 (CDF) $F(x)$ 是 PDF 从区间下界到 $x$ 的积分：\n$$\nF(x) = \\int_a^x p(t) \\,dt = \\frac{1}{Z} \\int_a^x P(t) \\,dt = \\frac{Q(x) - Q(a)}{Z}\n$$\n这个函数 $F(x)$ 将区间 $[a,b]$ 映射到 $[0,1]$，并且是单调不减的。\n\n其次，我们处理从 $p(x)$ 分布生成随机变量的问题。当 CDF 已知时，完成此任务最直接有效的方法是逆变换采样法。该方法指出，如果 $U$ 是一个从 $[0,1]$ 上的均匀分布中抽取的随机变量，那么随机变量 $X = F^{-1}(U)$ 将服从 PDF 为 $p(x)$、CDF 为 $F(x)$ 的分布。为了生成一个样本，我们首先从 $\\mathcal{U}(0,1)$ 中抽取一个值 $u$，然后求解方程 $F(x) = u$ 以得到 $x$。这等价于求解以下多项式方程：\n$$\n\\frac{Q(x) - Q(a)}{Z} = u \\implies Q(x) - (Z u + Q(a)) = 0\n$$\n对于问题中指定的多项式次数 ($N \\le 2$)，$Q(x)$ 的次数最多为 $3$。尽管三次方程存在解析解，但数值方法更为稳健和通用。由于 $F(x)$ 是一个单调函数，对于任意 $u \\in [0,1]$，方程 $F(x) - u = 0$ 在 $[a,b]$ 上存在唯一的根 $x$。这个根可以通过数值求根算法可靠地找到，例如 Brent 方法，只要根被限定在一个区间内（如此处的 $[a,b]$），该方法就能保证收敛。\n\n第三，我们计算分布的精确矩以供比较。分布的 $m$ 阶矩 $\\mathbb{E}[X^m]$ 定义为：\n$$\n\\mathbb{E}[X^m] = \\int_a^b x^m p(x) \\,dx = \\frac{1}{Z} \\int_a^b x^m P(x) \\,dx\n$$\n被积函数 $x^m P(x)$ 是另一个多项式，因此其定积分可以精确计算而没有数值误差。\n$$\n\\int_a^b x^m P(x) \\,dx = \\int_a^b \\left( \\sum_{i=0}^{N} c_i x^{i+m} \\right) \\,dx = \\sum_{i=0}^{N} c_i \\left[ \\frac{x^{i+m+1}}{i+m+1} \\right]_a^b\n$$\n这使得我们可以精确计算理论均值 $\\mathbb{E}[X]$（当 $m=1$ 时）和二阶矩 $\\mathbb{E}[X^2]$（当 $m=2$ 时）。\n\n最后，我们评估生成的样本集 $\\{x_j\\}_{j=1}^n$ 的质量。经验均值 $\\hat{\\mu}$ 和经验二阶矩 $\\hat{m}_2$ 计算如下：\n$$\n\\hat{\\mu} = \\frac{1}{n} \\sum_{j=1}^n x_j \\quad \\text{and} \\quad \\hat{m}_2 = \\frac{1}{n} \\sum_{j=1}^n x_j^2\n$$\n绝对误差 $|\\hat{\\mu} - \\mathbb{E}[X]|$ 和 $|\\hat{m}_2 - \\mathbb{E}[X^2]|$ 量化了样本矩与其理论值的偏差。此外，Kolmogorov-Smirnov (KS) 统计量 $D_n$ 用于衡量整体的拟合优度。它被定义为在整个实数线上，经验 CDF $F_n(x)$ 与理论 CDF $F(x)$ 之间的最大绝对差：\n$$\nD_n = \\sup_{x \\in \\mathbb{R}} |F_n(x) - F(x)|\n$$\n此处，$F_n(x) = \\frac{1}{n}\\sum_{j=1}^{n}\\mathbb{I}(x_j \\le x)$，其中 $\\mathbb{I}$ 是指示函数。KS 统计量为随机数生成过程的质量提供了一个稳健的度量。\n\n实现将精确地遵循这些步骤，对每个测试用例使用提供的参数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import stats\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    It generates samples from polynomial-based probability distributions,\n    calculates exact and empirical statistics, and reports the errors.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'N': 0, 'coeffs': [1.0], 'interval': [0.0, 1.0], 'n': 20000, 's': 12345},\n        {'N': 1, 'coeffs': [0.0, 1.0], 'interval': [0.0, 1.0], 'n': 30000, 's': 2024},\n        {'N': 2, 'coeffs': [0.35, -1.0, 1.0], 'interval': [0.0, 1.0], 'n': 40000, 's': 424242},\n        {'N': 2, 'coeffs': [2.0, 1.0, -1.0], 'interval': [-1.0, 2.0], 'n': 50000, 's': 731}\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        # Note: coeffs are [c0, c1, ..., cN]. numpy.poly1d wants [cN, ..., c0].\n        coeffs = np.array(case['coeffs'])\n        a, b = case['interval']\n        n = case['n']\n        seed = case['s']\n\n        # 1. Theoretical Calculations\n        # Represent the polynomial P(x)\n        P_poly = np.poly1d(coeffs[::-1])\n        \n        # Q(x) is the indefinite integral of P(x)\n        Q_poly = P_poly.integ()\n        \n        # Z is the normalization constant\n        Z = Q_poly(b) - Q_poly(a)\n        \n        # Calculate theoretical moments E[X^m] = (1/Z) * integral(x^m * P(x) dx)\n        # The integrand for E[X^m] is x^m * P(x)\n        P_moment1 = np.poly1d([1.0, 0.0]) * P_poly  # This is x * P(x)\n        Q_moment1 = P_moment1.integ()\n        exact_mean = (Q_moment1(b) - Q_moment1(a)) / Z\n        \n        P_moment2 = np.poly1d([1.0, 0.0, 0.0]) * P_poly # This is x^2 * P(x)\n        Q_moment2 = P_moment2.integ()\n        exact_mean_sq = (Q_moment2(b) - Q_moment2(a)) / Z\n        \n        # Define the theoretical CDF, F(x)\n        def cdf(x):\n            # Handle array inputs for kstest\n            x = np.asarray(x)\n            # Clip x to the interval [a, b] for calculation, assuming 0 before a and 1 after b\n            vals = np.clip(x, a, b)\n            f_vals = (Q_poly(vals) - Q_poly(a)) / Z\n            # Apply boundary conditions of a CDF\n            f_vals[x  a] = 0.0\n            f_vals[x > b] = 1.0\n            return f_vals\n\n        # 2. Sample Generation\n        rng = np.random.default_rng(seed)\n        uniform_samples = rng.random(size=n)\n        \n        # Function to find root of: F(x) - u = 0\n        def root_fn(x, u):\n            return (Q_poly(x) - Q_poly(a)) / Z - u\n        \n        # Generate samples using inverse transform sampling with a numerical root finder\n        samples = np.zeros(n)\n        for i in range(n):\n            u = uniform_samples[i]\n            # Brent's method is robust for finding the unique root in [a,b]\n            samples[i] = brentq(root_fn, a, b, args=(u,))\n        \n        # 3. Empirical Diagnostics\n        sample_mean = np.mean(samples)\n        sample_mean_sq = np.mean(samples**2)\n        \n        mean_abs_error = abs(sample_mean - exact_mean)\n        mean_sq_abs_error = abs(sample_mean_sq - exact_mean_sq)\n        \n        # Kolmogorov-Smirnov test\n        ks_result = stats.kstest(samples, cdf)\n        ks_stat = ks_result.statistic\n        \n        # 4. Store the results for this case\n        all_results.extend([mean_abs_error, mean_sq_abs_error, ks_stat])\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{res:.6f}\" for res in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}