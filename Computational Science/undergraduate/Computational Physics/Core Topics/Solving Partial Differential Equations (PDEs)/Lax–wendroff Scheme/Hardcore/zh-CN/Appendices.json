{
    "hands_on_practices": [
        {
            "introduction": "任何有意义的数值模拟都必须以稳定性为前提。这个实践旨在探索Lax-Wendroff格式最基本的性质：其稳定性受到著名的Courant-Friedrichs-Lewy (CFL)条件的制约。通过这个练习，你将通过数值实验来验证理论稳定性条件 $|C| \\le 1$ 并亲眼观察到不稳定所带来的灾难性后果，从而将抽象的理论与具体的计算结果联系起来。",
            "id": "2407699",
            "problem": "考虑一维线性平流方程 $u_t + a\\,u_x = 0$，其中平流速度 $a \\in \\mathbb{R}$ 为常数，定义在周期性域 $x \\in [0,1)$ 上。使用包含 $N$ 个点的均匀网格对空间进行离散化，其中 $N = 256$，网格索引 $j \\in \\{0,1,\\dots,N-1\\}$，网格间距 $\\Delta x = 1/N$。时间以步长 $\\Delta t$ 离散化，并定义库朗数 $C = a\\,\\Delta t/\\Delta x$。所有量均为无量纲。\n\n使用二阶Lax–Wendroff格式\n$$\nu_j^{n+1}\n=\nu_j^n\n-\n\\frac{C}{2}\\left(u_{j+1}^n - u_{j-1}^n\\right)\n+\n\\frac{C^2}{2}\\left(u_{j+1}^n - 2u_j^n + u_{j-1}^n\\right),\n$$\n其中索引为周期性，即 $u_{j\\pm N}^n \\equiv u_j^n$。\n\n设初始条件为一个光滑傅里叶模态与一个植入的最高波数模态的组合，\n$$\nu_j^0 = \\sin\\!\\left(2\\pi m \\frac{j}{N}\\right) + \\varepsilon\\,(-1)^j,\n$$\n其中 $m = 4$ 且 $\\varepsilon = 10^{-6}$。\n\n对于下方的每组参数集，选择 $\\Delta t$ 以使库朗数通过 $C = a\\,\\Delta t/\\Delta x$ 等于指定的 $C$ 值。对于每组参数集，计算并报告以下四个量：\n- 一个指示von Neumann意义下不稳定性的布尔值，如果 $|C| > 1$ 则为 $\\mathrm{True}$，否则为 $\\mathrm{False}$。\n- 所有傅里叶模态上的理论最大单步放大因子，即 $\\max_{\\theta \\in [0,2\\pi)} |G(\\theta)|$，其中 $G(\\theta)$ 是波数角 $\\theta$ 对应的Lax–Wendroff放大因子。\n- 波数指数为 $m$ 的特定光滑模态的理论单步放大因子，即 $|G(\\theta_m)|$，其中 $\\theta_m = 2\\pi m/N$。\n- 在恰好一个时间步后，对同一光滑模态进行数值测量的单步放大因子，通过比较该模态在应用格式前后一个步长的振幅得到。\n\n测试套件（每种情况为 $(a,C)$）：\n- 情况 1：$(a,C) = (1,\\,0.5)$。\n- 情况 2：$(a,C) = (1,\\,1.0)$。\n- 情况 3：$(a,C) = (1,\\,1.1)$。\n- 情况 4：$(a,C) = (1,\\,1.5)$。\n- 情况 5：$(a,C) = (-1,\\,-1.1)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个情况的条目本身也是一个形如 $[b,g_{\\max},g_m^{\\mathrm{theory}},g_m^{\\mathrm{meas}}]$ 的列表，顺序与上述相同。元素 $b$ 必须是 $\\mathrm{True}$ 或 $\\mathrm{False}$；三个实数必须四舍五入到小数点后恰好六位数字。输出行中任何地方都不允许有空格。例如，包含两种情况的一行输出应如下所示：$[[\\mathrm{False},1.000000,0.999000,0.999001],[\\mathrm{True},1.420000,1.000010,1.000012]]$。",
            "solution": "所述问题是偏微分方程数值分析领域中一个适定且有科学依据的练习。它涉及将Lax–Wendroff格式应用于一维线性平流方程。所有给定的参数和条件都是一致且充分的，足以得到唯一解。因此，我将进行完整的推导和计算求解。\n\n该问题要求分析用于线性平流方程 $u_t + a\\,u_x = 0$ 的二阶Lax–Wendroff格式。该格式由下式给出\n$$\nu_j^{n+1} = u_j^n - \\frac{C}{2}\\left(u_{j+1}^n - u_{j-1}^n\\right) + \\frac{C^2}{2}\\left(u_{j+1}^n - 2u_j^n + u_{j-1}^n\\right)\n$$\n其中 $u_j^n$ 是在网格点 $j$ 和时间步 $n$ 的数值解，而 $C = a\\,\\Delta t/\\Delta x$ 是库朗数。\n\n为了确定此格式的理论性质，我们进行von Neumann稳定性分析。我们考虑单个傅里叶模态的演化，$u_j^n = \\hat{u}^n(k) e^{i k x_j}$，其中 $x_j = j\\Delta x$，$k$ 是波数。我们定义无量纲波数角 $\\theta = k \\Delta x$。解的拟设变为 $u_j^n = \\hat{u}^n(\\theta) e^{ij\\theta}$。放大因子 $G(\\theta)$ 由关系式 $\\hat{u}^{n+1}(\\theta) = G(\\theta) \\hat{u}^n(\\theta)$ 定义。将拟设代入格式中得到：\n$$\nG(\\theta)e^{ij\\theta} = e^{ij\\theta} - \\frac{C}{2}\\left(e^{i(j+1)\\theta} - e^{i(j-1)\\theta}\\right) + \\frac{C^2}{2}\\left(e^{i(j+1)\\theta} - 2e^{ij\\theta} + e^{i(j-1)\\theta}\\right)\n$$\n两边同除以 $e^{ij\\theta}$，我们得到放大因子：\n$$\nG(\\theta) = 1 - \\frac{C}{2}\\left(e^{i\\theta} - e^{-i\\theta}\\right) + \\frac{C^2}{2}\\left(e^{i\\theta} - 2 + e^{-i\\theta}\\right)\n$$\n使用恒等式 $e^{i\\theta} - e^{-i\\theta} = 2i\\sin\\theta$ 和 $e^{i\\theta} + e^{-i\\theta} = 2\\cos\\theta$，上式可简化为：\n$$\nG(\\theta) = 1 - iC\\sin\\theta + C^2(\\cos\\theta - 1)\n$$\n放大因子的模 $|G(\\theta)|$ 决定了格式的稳定性。稳定性要求对所有 $\\theta$ 都有 $|G(\\theta)| \\le 1$。模的平方是：\n$$\n|G(\\theta)|^2 = \\text{Re}(G(\\theta))^2 + \\text{Im}(G(\\theta))^2 = (1 + C^2(\\cos\\theta - 1))^2 + (-C\\sin\\theta)^2\n$$\n$$\n|G(\\theta)|^2 = 1 + 2C^2(\\cos\\theta - 1) + C^4(\\cos\\theta - 1)^2 + C^2\\sin^2\\theta\n$$\n$$\n|G(\\theta)|^2 = 1 - 2C^2(1 - \\cos\\theta) + C^4(1 - 2\\cos\\theta + \\cos^2\\theta) + C^2(1 - \\cos^2\\theta)\n$$\n$$\n|G(\\theta)|^2 = 1 - 2C^2 + 2C^2\\cos\\theta + C^4 - 2C^4\\cos\\theta + C^4\\cos^2\\theta + C^2 - C^2\\cos^2\\theta\n$$\n$$\n|G(\\theta)|^2 = 1 - C^2 + (2C^2 - 2C^4)\\cos\\theta + (C^4 - C^2)\\cos^2\\theta\n$$\n一个更简洁的推导使用半角恒等式 $1 - \\cos\\theta = 2\\sin^2(\\theta/2)$:\n$$\nG(\\theta) = 1 - 2C^2\\sin^2(\\theta/2) - iC(2\\sin(\\theta/2)\\cos(\\theta/2))\n$$\n$$\n|G(\\theta)|^2 = (1 - 2C^2\\sin^2(\\theta/2))^2 + 4C^2\\sin^2(\\theta/2)\\cos^2(\\theta/2)\n$$\n$$\n|G(\\theta)|^2 = 1 - 4C^2\\sin^2(\\theta/2) + 4C^4\\sin^4(\\theta/2) + 4C^2\\sin^2(\\theta/2)(1-\\sin^2(\\theta/2))\n$$\n$$\n|G(\\theta)|^2 = 1 - 4C^2\\sin^2(\\theta/2) + 4C^4\\sin^4(\\theta/2) + 4C^2\\sin^2(\\theta/2) - 4C^2\\sin^4(\\theta/2)\n$$\n这可以简化为一个非常紧凑的形式：\n$$\n|G(\\theta)|^2 = 1 - 4C^2(1-C^2)\\sin^4(\\theta/2)\n$$\n我们现在计算所需的四个量。\n\n1.  **不稳定性条件**：如果对所有 $\\theta \\in [0, 2\\pi)$ 都有 $|G(\\theta)|^2 \\le 1$，则格式是稳定的。项 $\\sin^4(\\theta/2)$ 是非负的。如果 $C^2 \\le 1$，则 $(1-C^2) \\ge 0$，这使得第二项 $-4C^2(1-C^2)\\sin^4(\\theta/2) \\le 0$。因此， $|G(\\theta)|^2 \\le 1$，格式是稳定的。如果 $C^2 > 1$，则 $(1-C^2)  0$，使得第二项为正。在这种情况下， $|G(\\theta)|^2$ 可以超过 $1$。因此，不稳定性的条件是 $|C| > 1$。\n\n2.  **理论最大放大因子, $\\max_{\\theta} |G(\\theta)|$**:\n    -   如果 $|C| \\le 1$: 由于 $|G(\\theta)|^2$ 表达式中的第二项是非正的，最大值为 $1$（在 $\\theta=0$ 处取得）。\n    -   如果 $|C| > 1$: 第二项为正，因此当 $\\sin^4(\\theta/2)$ 最大化时， $|G(\\theta)|^2$ 也达到最大值。$\\sin^4(\\theta/2)$ 的最大值为 $1$（在 $\\theta=\\pi$ 处取得）。\n        $$\n        \\max |G(\\theta)|^2 = |G(\\pi)|^2 = 1 - 4C^2(1-C^2) = 1 - 4C^2 + 4C^4 = (2C^2 - 1)^2\n        $$\n        因此，$\\max_{\\theta} |G(\\theta)| = \\sqrt{(2C^2-1)^2} = |2C^2-1|$。由于 $C^2 > 1$，所以 $2C^2-1 > 1$，因此最大因子是 $2C^2-1$。\n\n3.  **模态 $m$ 的理论放大因子**:\n    问题指定了一个包含 $N=256$ 个点的网格和一个波数指数为 $m=4$ 的光滑模态。相应的波数角是 $\\theta_m = 2\\pi m/N = 2\\pi(4)/256 = \\pi/32$。该模态的理论放大因子是 $|G(\\theta_m)|$，可直接从推导出的公式计算：\n    $$\n    |G(\\theta_m)| = \\sqrt{1 - 4C^2(1-C^2)\\sin^4(\\theta_m/2)} = \\sqrt{1 - 4C^2(1-C^2)\\sin^4(\\pi/64)}\n    $$\n\n4.  **模态 $m$ 的数值测量放大因子**:\n    这需要一个单步数值实验。\n    -   首先，我们根据 $u_j^0 = \\sin(2\\pi m j/N) + \\varepsilon (-1)^j$ 构建大小为 $N=256$ 的初始条件向量 $u^0$，其中 $m=4$ 且 $\\varepsilon=10^{-6}$。\n    -   我们计算初始状态的离散傅里叶变换 (DFT)，$\\hat{u}^0 = \\text{FFT}(u^0)$。模态 $m$ 的初始复振幅是 $\\hat{u}^0_m$。其振幅为 $|\\hat{u}^0_m|$。\n    -   接下来，我们将Lax–Wendroff格式应用于 $u^0$ 一步，以获得下一时间步的状态 $u^1$。此计算必须遵循周期性边界条件，这可以通过数组的循环移位（例如，`numpy.roll`）来高效实现。\n    -   然后我们计算新状态的DFT，$\\hat{u}^1 = \\text{FFT}(u^1)$，并找到模态 $m$ 的复振幅的模，即 $|\\hat{u}^1_m|$。\n    -   数值测量的放大因子是这些振幅的比值：$g_m^{\\mathrm{meas}} = |\\hat{u}^1_m| / |\\hat{u}^0_m|$。该值预计将与理论值 $|G(\\theta_m)|$ 极为接近，任何偏差都可归因于浮点精度限制。\n\n对于每个测试用例 $(a,C)$，计算这四个量并按要求格式化。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by analyzing the Lax-Wendroff scheme for five test cases.\n\n    For each case, it calculates:\n    1. A boolean for von Neumann instability.\n    2. The theoretical maximum amplification factor over all modes.\n    3. The theoretical amplification factor for a specific mode m.\n    4. The numerically measured amplification factor for mode m after one time step.\n    \"\"\"\n    # Define constants from the problem statement\n    N = 256\n    m = 4\n    eps = 1e-6\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple (a, C), where 'a' is advection speed and 'C' is Courant number.\n    test_cases = [\n        (1.0, 0.5),\n        (1.0, 1.0),\n        (1.0, 1.1),\n        (1.0, 1.5),\n        (-1.0, -1.1),\n    ]\n\n    results = []\n    \n    # Grid for initial condition\n    j = np.arange(N)\n    \n    # Wavenumber angle for the smooth mode m\n    theta_m = 2.0 * np.pi * m / N\n\n    for a, C in test_cases:\n        # 1. Instability (von Neumann sense)\n        # The scheme is unstable if and only if |C| > 1.\n        is_unstable = np.abs(C) > 1.0\n\n        # 2. Theoretical maximum per-step amplification factor\n        if np.abs(C) = 1.0:\n            g_max = 1.0\n        else:\n            g_max = 2.0 * C**2 - 1.0\n\n        # 3. Theoretical per-step amplification factor for mode m\n        # |G|^2 = 1 - 4*C^2*(1-C^2)*sin^4(theta/2)\n        # We need to compute the square root of this for a complex result when C > 1\n        # The term under the square root can be negative if C^2 outside of [0,1]\n        # and sin^4 is not zero. Let's use complex arithmetic to be safe.\n        term_inside_sqrt = 1.0 - 4.0 * C**2 * (1.0 - C**2) * np.sin(theta_m / 2.0)**4\n        g_m_theory = np.sqrt(np.abs(term_inside_sqrt))\n        \n        # 4. Numerically measured per-step amplification factor for mode m\n        # Initial condition\n        u0 = np.sin(2.0 * np.pi * m * j / N) + eps * (-1)**j\n\n        # Compute initial amplitude of mode m via FFT\n        u0_fft = np.fft.fft(u0)\n        A0_m = np.abs(u0_fft[m])\n\n        # Apply one step of the Lax-Wendroff scheme\n        u_jp1 = np.roll(u0, -1)\n        u_jm1 = np.roll(u0, 1)\n        u1 = u0 - (C / 2.0) * (u_jp1 - u_jm1) + (C**2 / 2.0) * (u_jp1 - 2.0 * u0 + u_jm1)\n\n        # Compute final amplitude of mode m via FFT\n        u1_fft = np.fft.fft(u1)\n        A1_m = np.abs(u1_fft[m])\n\n        # Calculate the measured amplification factor\n        g_m_measured = A1_m / A0_m if A0_m != 0 else 0.0\n        \n        # Store results for this case\n        results.append([\n            is_unstable,\n            g_max,\n            g_m_theory,\n            g_m_measured\n        ])\n    \n    # Format the output string precisely as required, with no spaces and\n    # with floating-point numbers rounded to exactly six decimal places.\n    case_strings = []\n    for res in results:\n        b_val, gmax_val, gm_th_val, gm_ms_val = res\n        s_bool = str(b_val)\n        s_gmax = f\"{gmax_val:.6f}\"\n        s_gm_th = f\"{gm_th_val:.6f}\"\n        s_gm_ms = f\"{gm_ms_val:.6f}\"\n        case_strings.append(f\"[{s_bool},{s_gmax},{s_gm_th},{s_gm_ms}]\")\n        \n    final_output = f\"[{','.join(case_strings)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "在确保了格式的稳定性之后，我们进而研究其在稳定区域内的误差特性。Lax-Wendroff格式的一个显著特点是其色散性，即不同波长的数值波会以略微不同的速度传播，从而导致相位误差。这个练习提供了一种定量的方法来测量这种相位误差，让你更深入地理解即使在稳定的情况下，该格式仍会如何扭曲真实解。",
            "id": "2407698",
            "problem": "考虑在周期性空间域 $x \\in [0,1]$ 上的线性平流方程 $u_t + u_x = 0$，其无量纲波速 $a=1$ 并具有周期性边界条件。初始条件为 $u(x,0) = \\sin(10 \\pi x)$。其精确解由特征线位移给出，$u(x,t) = \\sin(10 \\pi (x - t))$。一个完整的时间周期对应于 $T=1$，因为在周期性域上，一个域长度的位移会使解恢复到其自身。\n\n你需要在由 $N$ 个点组成的均匀网格（间距 $\\Delta x = 1/N$）上计算在时间 $t=T$ 时的全离散数值解。使用的时间步长 $\\Delta t$ 应使得库朗数 $C = \\Delta t / \\Delta x$ 等于一个给定值，并且经过整数步数后达到最终时间 $T$。假设在所有测试用例中 $N/C$ 都是整数，因此步数 $n_{\\text{steps}} = N/C$，时间步长 $\\Delta t = T / n_{\\text{steps}}$。使用与守恒律 $u_t + u_x = 0$ 的时间二阶泰勒展开相一致的二阶精度显式方法，在周期性边界条件下，将解从 $t=0$ 推进到 $t=T$。\n\n在时间 $t=T$ 时，在网格点 $x_j = j \\Delta x$（其中 $j=0,1,\\dots,N-1$）上获得数值解 $u_j^{\\text{num}}$ 后，通过拟合一个相移 $\\varphi \\in (-\\pi,\\pi]$ 来量化相位误差，使得 $u_j^{\\text{num}}$ 在最小二乘意义上能被一个形式为 $A \\sin(10 \\pi x_j - \\varphi)$ 且振幅 $A \\in \\mathbb{R}$ 可自由变化的位移正弦波最佳逼近。形式上，将相位误差 $\\varphi^\\star$ 定义为\n$$\n\\min_{\\varphi \\in (-\\pi,\\pi],\\, A \\in \\mathbb{R}} \\sum_{j=0}^{N-1} \\left[u_j^{\\text{num}} - A \\sin(10 \\pi x_j - \\varphi)\\right]^2\n$$\n的任何一个最小值点。以弧度为单位报告相位误差 $\\varphi^\\star$。每个报告的相位误差必须四舍五入到八位小数。\n\n使用以下参数对 $(N,C)$ 的测试套件：\n- $(N,C) = (200, 0.5)$，\n- $(N,C) = (100, 1.0)$，\n- $(N,C) = (20, 0.8)$，\n- $(N,C) = (90, 0.9)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表顺序与测试套件相同，例如 $[\\varphi_1,\\varphi_2,\\varphi_3,\\varphi_4]$，其中每个 $\\varphi_i$ 是如上所述四舍五入后的相位误差（以弧度为单位）。",
            "solution": "所提出的问题是计算物理中的一个标准练习：量化用于求解线性平流方程的有限差分格式的数值误差。该问题是适定的，有科学依据，并包含了获得其唯一解所需的所有信息。我将开始进行求解。\n\n控制偏微分方程 (PDE) 是具有恒定波速 $a$ 的线性平流方程：\n$$ \\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = 0 $$\n问题指定了无量纲波速 $a=1$，周期性空间域 $x \\in [0,1]$，以及初始条件 $u(x,0) = \\sin(10 \\pi x)$。积分的最终时间为 $T=1$，这对应于波穿过长度为 $1$ 的域所需的一个完整周期。此时，精确解 $u(x,t) = \\sin(10 \\pi (x-at))$ 返回到其初始状态：\n$$ u(x,T) = u(x,1) = \\sin(10 \\pi (x-1)) = \\sin(10 \\pi x - 10 \\pi) = \\sin(10 \\pi x) $$\n因此，在 $t=T$ 时，精确解相对于初始条件的相移为 $0$。在数值解中观察到的任何相移都代表了该格式的累积相位误差。\n\n问题要求使用一种由泰勒展开导出的二阶精度显式方法。标准的选择是 Lax-Wendroff 格式。我们从 $u(x, t+\\Delta t)$ 的泰勒级数开始：\n$$ u(x, t+\\Delta t) = u(x,t) + \\Delta t \\frac{\\partial u}{\\partial t} + \\frac{(\\Delta t)^2}{2} \\frac{\\partial^2 u}{\\partial t^2} + \\mathcal{O}((\\Delta t)^3) $$\n从 PDE 中，我们有 $\\frac{\\partial u}{\\partial t} = -a \\frac{\\partial u}{\\partial x}$。假设具有足够的光滑性，对时间求导可得二阶时间导数：\n$$ \\frac{\\partial^2 u}{\\partial t^2} = \\frac{\\partial}{\\partial t}\\left(-a \\frac{\\partial u}{\\partial x}\\right) = -a \\frac{\\partial}{\\partial x}\\left(\\frac{\\partial u}{\\partial t}\\right) = -a \\frac{\\partial}{\\partial x}\\left(-a \\frac{\\partial u}{\\partial x}\\right) = a^2 \\frac{\\partial^2 u}{\\partial x^2} $$\n将这些代入泰勒展开，得到一个半离散格式：\n$$ u(x, t+\\Delta t) = u(x,t) - a \\Delta t \\frac{\\partial u}{\\partial x} + \\frac{a^2 (\\Delta t)^2}{2} \\frac{\\partial^2 u}{\\partial x^2} + \\mathcal{O}((\\Delta t)^3) $$\n为了获得全离散格式，我们引入均匀网格 $x_j = j \\Delta x$ 和时间层 $t_n = n \\Delta t$。令 $u_j^n \\approx u(x_j, t_n)$。我们使用二阶中心有限差分来逼近空间导数：\n$$ \\frac{\\partial u}{\\partial x}\\bigg|_{x_j, t_n} \\approx \\frac{u_{j+1}^n - u_{j-1}^n}{2 \\Delta x} $$\n$$ \\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{x_j, t_n} \\approx \\frac{u_{j+1}^n - 2u_j^n + u_{j-1}^n}{(\\Delta x)^2} $$\n代入这些逼近值，得到 $u_j^{n+1}$ 的显式更新规则：\n$$ u_j^{n+1} = u_j^n - a \\Delta t \\left( \\frac{u_{j+1}^n - u_{j-1}^n}{2 \\Delta x} \\right) + \\frac{a^2 (\\Delta t)^2}{2} \\left( \\frac{u_{j+1}^n - 2u_j^n + u_{j-1}^n}{(\\Delta x)^2} \\right) $$\n引入库朗数 $C = a \\Delta t / \\Delta x$（在此问题中 $a=1$，所以 $C = \\Delta t / \\Delta x$），我们可以通过合并关于 $u_{j-1}^n$、$u_j^n$ 和 $u_{j+1}^n$ 的项来重排该格式：\n$$ u_j^{n+1} = u_j^n - \\frac{C}{2} (u_{j+1}^n - u_{j-1}^n) + \\frac{C^2}{2} (u_{j+1}^n - 2u_j^n + u_{j-1}^n) $$\n$$ u_j^{n+1} = \\left(\\frac{C^2}{2} + \\frac{C}{2}\\right) u_{j-1}^n + (1 - C^2) u_j^n + \\left(\\frac{C^2}{2} - \\frac{C}{2}\\right) u_{j+1}^n $$\n这就是 Lax-Wendroff 格式。它是一个显式的、三点模板的、在空间和时间上均为二阶精度的格式，并且在 $|C| \\le 1$ 时是 von Neumann 稳定的。周期性边界条件通过在每个时间步设置 $u_{-1}^n = u_{N-1}^n$ 和 $u_N^n = u_0^n$ 来实施。\n\n在使用 $n_{\\text{steps}}=T/\\Delta t = N/C$ 步将解从 $t=0$ 推进到 $t=T$ 后，我们得到了在网格点 $x_j$ 上的数值解 $u_j^{\\text{num}}$。最后一步是通过将此数值数据拟合到形式为 $f(x_j; A, \\varphi) = A \\sin(k x_j - \\varphi)$（其中 $k=10\\pi$）的模型来量化相位误差。我们必须找到使残差平方和最小化的参数 $A$ 和 $\\varphi$：\n$$ \\min_{\\varphi \\in (-\\pi,\\pi],\\, A \\in \\mathbb{R}} \\sum_{j=0}^{N-1} \\left[u_j^{\\text{num}} - A \\sin(k x_j - \\varphi)\\right]^2 $$\n这个关于 $\\varphi$ 的非线性最小二乘问题可以被线性化。使用三角恒等式 $\\sin(\\alpha - \\beta) = \\sin\\alpha \\cos\\beta - \\cos\\alpha \\sin\\beta$，模型函数可以重写为：\n$$ A \\sin(k x_j - \\varphi) = (A \\cos\\varphi) \\sin(k x_j) - (A \\sin\\varphi) \\cos(k x_j) $$\n我们定义新的线性系数 $c_1 = A \\cos\\varphi$ 和 $c_2 = -A \\sin\\varphi$。模型在这些系数下变为线性：$f(x_j) = c_1 \\sin(k x_j) + c_2 \\cos(k x_j)$。任务现在是一个标准的线性最小二乘问题：\n$$ \\min_{c_1, c_2} \\sum_{j=0}^{N-1} \\left[u_j^{\\text{num}} - \\left(c_1 \\sin(k x_j) + c_2 \\cos(k x_j)\\right)\\right]^2 $$\n设基向量为 $S_j = \\sin(k x_j)$ 和 $C_j = \\cos(k x_j)$。系数 $(c_1, c_2)$ 的解由正规方程给出：\n$$ \\begin{pmatrix} \\sum S_j^2  \\sum S_j C_j \\\\ \\sum S_j C_j  \\sum C_j^2 \\end{pmatrix} \\begin{pmatrix} c_1 \\\\ c_2 \\end{pmatrix} = \\begin{pmatrix} \\sum u_j^{\\text{num}} S_j \\\\ \\sum u_j^{\\text{num}} C_j \\end{pmatrix} $$\n解这个 $2 \\times 2$ 系统可得到 $c_1$ 和 $c_2$。然后可以从 $c_1$ 和 $c_2$ 的定义中恢复相位 $\\varphi$：\n$$ \\tan\\varphi = \\frac{\\sin\\varphi}{\\cos\\varphi} = \\frac{-c_2/A}{c_1/A} = \\frac{-c_2}{c_1} $$\n相位误差 $\\varphi^\\star$ 可使用双参数反正切函数在区间 $(-\\pi, \\pi]$ 内唯一确定：\n$$ \\varphi^\\star = \\operatorname{atan2}(-c_2, c_1) $$\n这个值 $\\varphi^\\star$ 表示数值解相对于 $t=T$ 时精确解的相位滞后或超前，是需要报告的量。正值表示相位滞后（数值波较慢）。对于 $C=1$ 的特殊情况，Lax-Wendroff 格式在网格上是精确的，得到 $u_j^{n+1} = u_{j-1}^n$，经过 $n_{\\text{steps}} = N$ 步后，结果为 $u_j^{\\text{final}} = u_{j-N}^0 = u_j^0$。在这种情况下，相位误差必须恰好为零。\n对每个给定的参数对 $(N, C)$，整个过程都通过计算来实现。",
            "answer": "```python\nimport numpy as np\n\ndef run_lax_wendroff(N, C):\n    \"\"\"\n    Solves the linear advection equation u_t + u_x = 0 on a periodic\n    domain [0,1] using the Lax-Wendroff scheme.\n\n    Args:\n        N (int): Number of grid points.\n        C (float): Courant number.\n\n    Returns:\n        numpy.ndarray: The numerical solution at the final time T=1.\n    \"\"\"\n    # Parameters definition\n    T_final = 1.0\n    wave_number = 10.0 * np.pi\n    \n    # Spatial grid setup\n    dx = 1.0 / N\n    x_grid = np.arange(N) * dx\n    \n    # Initial condition\n    u0 = np.sin(wave_number * x_grid)\n    \n    # Time stepping setup\n    # The problem statement guarantees N/C is an integer.\n    num_steps = int(round(N / C))\n    \n    # Pre-calculate Lax-Wendroff coefficients\n    # u_j^{n+1} = coeff_jm1 * u_{j-1} + coeff_j * u_j + coeff_jp1 * u_{j+1}\n    courant_sq = C * C\n    coeff_jm1 = 0.5 * (courant_sq + C)  # Coefficient for u_{j-1}\n    coeff_j = 1.0 - courant_sq           # Coefficient for u_j\n    coeff_jp1 = 0.5 * (courant_sq - C)  # Coefficient for u_{j+1}\n    \n    u = u0.copy()\n    \n    # Time-marching loop\n    for _ in range(num_steps):\n        # Periodic boundary conditions are handled by np.roll\n        u_jm1 = np.roll(u, 1)\n        u_jp1 = np.roll(u, -1)\n        \n        u = coeff_jm1 * u_jm1 + coeff_j * u + coeff_jp1 * u_jp1\n        \n    return u\n\ndef calculate_phase_error(u_final, N):\n    \"\"\"\n    Calculates the phase error by fitting the numerical solution to the model\n    A * sin(k*x - phi) using linear least-squares.\n\n    Args:\n        u_final (numpy.ndarray): The numerical solution at the final time.\n        N (int): Number of grid points.\n\n    Returns:\n        float: The calculated phase error phi in radians.\n    \"\"\"\n    # Define basis functions for the least-squares fit\n    wave_number = 10.0 * np.pi\n    dx = 1.0 / N\n    x_grid = np.arange(N) * dx\n    \n    # Model: c1*sin(k*x) + c2*cos(k*x)\n    S_basis = np.sin(wave_number * x_grid)\n    C_basis = np.cos(wave_number * x_grid)\n\n    # Set up and solve the normal equations: (M^T * M) * c = M^T * u\n    # where M = [S_basis, C_basis], c = [c1, c2]^T, u = u_final\n    \n    # M^T * M matrix components\n    S2 = np.dot(S_basis, S_basis)\n    C2 = np.dot(C_basis, C_basis)\n    SC = np.dot(S_basis, C_basis)\n    \n    M_T_M = np.array([[S2, SC], \n                      [SC, C2]])\n                      \n    # M^T * u vector components\n    uS = np.dot(u_final, S_basis)\n    uC = np.dot(u_final, C_basis)\n    \n    M_T_u = np.array([uS, uC])\n    \n    # Solve for coefficients c1, c2\n    # c1 = A*cos(phi), c2 = -A*sin(phi)\n    try:\n        c1, c2 = np.linalg.solve(M_T_M, M_T_u)\n    except np.linalg.LinAlgError:\n        # This is unlikely to happen with sine and cosine bases\n        return np.nan\n\n    # Recover the phase phi from the coefficients\n    # phi = atan2(-c2, c1)\n    phase_error = np.arctan2(-c2, c1)\n    \n    return phase_error\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (200, 0.5),\n        (100, 1.0),\n        (20, 0.8),\n        (90, 0.9),\n    ]\n\n    results = []\n    for N, C in test_cases:\n        # Run the numerical simulation\n        u_final = run_lax_wendroff(N, C)\n        \n        # Calculate the phase error from the final state\n        phase_err = calculate_phase_error(u_final, N)\n        \n        results.append(phase_err)\n\n    # Format and print the final results as specified.\n    formatted_results = \",\".join([f\"{r:.8f}\" for r in results])\n    print(f\"[{formatted_results}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "从光滑解过渡到包含急剧梯度或不连续性的情况，是检验数值格式性能的关键一步。高阶线性格式（如Lax-Wendroff）通常不满足单调性保持原理，这会导致其在不连续点附近产生伪振荡（吉布斯现象）。这个实践突出了该格式的一个重要局限性，展示了在模拟必须保持非负的物理量（如粒子密度）时，它如何可能产生非物理的负值结果。",
            "id": "2407736",
            "problem": "考虑一个非负标量数密度 $n(x,t)$ 在长度为 $L$ 的周期性定义域上以恒定速度 $a>0$ 进行的一维线性平流，该过程由守恒律\n$$\n\\partial_t n(x,t) + a\\,\\partial_x n(x,t) = 0,\\quad x\\in[0,L],\\ t\\ge 0,\n$$\n控制，并采用周期性边界条件和均匀空间离散化。精确解保持非负性：如果对所有 $x$ 都有 $n(x,0)\\ge 0$，则对所有 $t\\ge 0$ 都有 $n(x,t)\\ge 0$。您需要在一个周期性网格上，使用在时间和空间上均为二阶精度的显式方法，在均匀网格上计算一个全离散的数值解。该网格由 $N$ 个网格点组成，间距为 $\\Delta x = L/N$，节点为 $x_j = j\\,\\Delta x$，其中 $j=0,1,\\dots,N-1$。使用由 Courant–Friedrichs–Lewy (CFL) 数 $c = a\\,\\Delta t/\\Delta x$ 定义的均匀时间步长 $\\Delta t$，其中 $c\\in(0,1]$，并将解推进至不超过目标时间 $T$ 的最大整数时间步数 $K=\\lfloor T/\\Delta t\\rfloor$。\n\n您的程序必须对每个指定的测试用例，从给定的非负初始数据开始演化离散解，并检测在演化至时间 $T$ 的过程中，数值解在任何网格点上是否曾达到小于一个小的负阈值。为避免浮点舍入误差导致的假阳性，当且仅当在某个时间步 $m\\in\\{0,1,\\dots,K\\}$ 时，$\\min_j n_j^m  -\\varepsilon$ 成立，才声明出现了非物理的负值。其中容差 $\\varepsilon = 10^{-12}$，$n_j^m$ 表示在网格节点 $x_j$ 和时间层 $t^m=m\\,\\Delta t$ 的离散解。\n\n使用无量纲单位（不需要物理单位）。不涉及角度。以下所有参数值均为无量纲。在每个测试中，定义域在 $[0,L]$ 上都是周期性的。\n\n测试套件（每项列出 $(L,a,N,c,T,\\text{初始剖面})$）：\n- 情况 A（光滑剖面，“理想路径”）：$(L,a,N,c,T) = (1.0,\\,1.0,\\,400,\\,0.5,\\,1.0)$。初始条件：$n(x,0) = \\exp\\!\\left(-\\left(\\dfrac{x-0.3}{0.05}\\right)^2\\right)$，对于 $x\\in[0,L)$。\n- 情况 B（单间断对，接近 Courant 边界）：$(L,a,N,c,T) = (1.0,\\,1.0,\\,400,\\,0.9,\\,0.2)$。初始条件：当 $x\\in[0.25,0.55]$ 时 $n(x,0) = 1$，否则在 $[0,L)$ 上 $n(x,0)=0$。\n- 情况 C（多重间断，较粗网格）：$(L,a,N,c,T) = (1.0,\\,1.0,\\,200,\\,0.5,\\,0.2)$。初始条件：在并集 $[0.10,0.20]\\cup[0.60,0.80]$ 上 $n(x,0) = 1$，否则在 $[0,L)$ 上 $n(x,0)=0$。\n\n您的程序必须为每个情况计算一个布尔指示符，说明在从 $t=0$ 到 $t=K\\,\\Delta t$ 的时间步进过程中，是否在任何网格点上观测到任何非物理的负值（由阈值 $\\varepsilon$ 定义）。最终输出必须是一行，按 A、B、C 的顺序包含三个结果，格式为一个用方括号括起来的逗号分隔的整数列表，如果该情况检测到非物理负值，则对应条目为 $1$，否则为 $0$。例如，要求的输出格式为 $[x_1,x_2,x_3]$，其中 $x_i\\in\\{0,1\\}$。",
            "solution": "所提出的问题是计算物理学中一个适定的练习。它要求实现一类特定的数值方法来求解一维线性平流方程，并测试数值解的一个基本性质：非负性的保持。\n\n控制方程是标量密度 $n(x,t)$ 在具有恒定正波速 $a$ 下的线性平流方程：\n$$\n\\partial_t n + a\\,\\partial_x n = 0\n$$\n问题要求一个在时间和空间上都是显式且二阶精度的数值格式。对于这个方程，满足这些性质的典型方法是 Lax-Wendroff 格式。我们将推导这个格式并用它来解决问题。\n\n我们从解 $n(x, t+\\Delta t)$ 在时间上关于 $t$ 的泰勒级数展开开始：\n$$\nn(x, t+\\Delta t) = n(x,t) + \\Delta t \\frac{\\partial n}{\\partial t} + \\frac{(\\Delta t)^2}{2} \\frac{\\partial^2 n}{\\partial t^2} + O((\\Delta t)^3)\n$$\n为了在时间上达到二阶精度，我们必须使用控制偏微分方程来近似时间导数。一阶时间导数由偏微分方程直接给出：\n$$\n\\frac{\\partial n}{\\partial t} = -a \\frac{\\partial n}{\\partial x}\n$$\n二阶时间导数通过对偏微分方程关于时间求导并代回得到：\n$$\n\\frac{\\partial^2 n}{\\partial t^2} = \\frac{\\partial}{\\partial t}\\left(-a \\frac{\\partial n}{\\partial x}\\right) = -a \\frac{\\partial}{\\partial x}\\left(\\frac{\\partial n}{\\partial t}\\right) = -a \\frac{\\partial}{\\partial x}\\left(-a \\frac{\\partial n}{\\partial x}\\right) = a^2 \\frac{\\partial^2 n}{\\partial x^2}\n$$\n将这些表达式代回泰勒展开，得到一个在 $\\Delta t$ 上达到二阶精度的半离散方程：\n$$\nn(x, t+\\Delta t) = n(x,t) - a \\Delta t \\frac{\\partial n}{\\partial x} + \\frac{(a \\Delta t)^2}{2} \\frac{\\partial^2 n}{\\partial x^2} + O((\\Delta t)^3)\n$$\n为了创建一个全离散格式，我们将空间域离散化为网格点 $x_j = j\\Delta x$，并用 $n_j^m \\approx n(x_j, t^m)$ 来近似在这些点上于时间 $t^m=m\\Delta t$ 的解。我们用二阶精度的中心有限差分替换空间导数：\n$$\n\\left.\\frac{\\partial n}{\\partial x}\\right|_{x_j} \\approx \\frac{n_{j+1}^m - n_{j-1}^m}{2\\Delta x}\n$$\n$$\n\\left.\\frac{\\partial^2 n}{\\partial x^2}\\right|_{x_j} \\approx \\frac{n_{j+1}^m - 2n_j^m + n_{j-1}^m}{(\\Delta x)^2}\n$$\n将这些有限差分代入半离散方程，得到 $n_j^{m+1}$ 的显式更新规则：\n$$\nn_j^{m+1} = n_j^m - a \\Delta t \\left( \\frac{n_{j+1}^m - n_{j-1}^m}{2\\Delta x} \\right) + \\frac{(a \\Delta t)^2}{2} \\left( \\frac{n_{j+1}^m - 2n_j^m + n_{j-1}^m}{(\\Delta x)^2} \\right)\n$$\n引入无量纲的 Courant–Friedrichs–Lewy (CFL) 数 $c = a\\Delta t/\\Delta x$，我们可以简化该表达式：\n$$\nn_j^{m+1} = n_j^m - \\frac{c}{2} (n_{j+1}^m - n_{j-1}^m) + \\frac{c^2}{2} (n_{j+1}^m - 2n_j^m + n_{j-1}^m)\n$$\n按当前时间层 $m$ 的空间索引对各项进行分组：\n$$\nn_j^{m+1} = \\left( \\frac{c^2}{2} + \\frac{c}{2} \\right) n_{j-1}^m + (1 - c^2) n_j^m + \\left( \\frac{c^2}{2} - \\frac{c}{2} \\right) n_{j+1}^m\n$$\n这就是 Lax-Wendroff 格式。要使该格式是保正的（即，如果所有 $n_k^m \\ge 0$，则保证 $n_j^{m+1} \\ge 0$），模板中的所有系数都必须是非负的。我们分析在稳定性范围 $c \\in (0,1]$ 内的系数：\n- $n_{j-1}^m$ 的系数：$\\frac{c(c+1)}{2}$。当 $c \\ge 0$ 时，此项为非负。\n- $n_j^m$ 的系数：$1 - c^2$。当 $c \\le 1$ 时，此项为非负。\n- $n_{j+1}^m$ 的系数：$\\frac{c(c-1)}{2}$。当 $c \\in [0,1]$ 时，此项为非正。\n\n$n_{j+1}^m$ 的系数对于任何 $c \\in (0,1)$ 都是负的。这意味着 Lax-Wendroff 格式通常不是保正的。它是一种非单调格式，会在解的陡峭梯度或间断附近引入伪振荡（下冲和过冲）。这是 Godunov 定理的一种表现，该定理指出，对于守恒律，任何精度高于一阶的线性数值格式都不可能是保单调的。因此，我们预计当初始条件包含间断时（如情况 B 和 C），会观察到负值。对于像情况 A 中的高斯函数这样的光滑初始条件，任何振荡都应该小得多，并且可能不会低于指定的负阈值 $\\varepsilon = 10^{-12}$。\n\n解决该问题的算法如下：\n1. 对每个测试用例，定义参数 $L, a, N, c, T$。\n2. 计算网格间距 $\\Delta x = L/N$、时间步长 $\\Delta t = c \\Delta x / a$ 和总时间步数 $K = \\lfloor T/\\Delta t \\rfloor$。\n3. 创建一个均匀空间网格 $x_j = j\\Delta x$，其中 $j=0, \\dots, N-1$。\n4. 根据指定情况的初始条件初始化离散解数组 $n^0$。\n5. 设置一个标志 `negative_detected = 0`。\n6. 从时间步 $m=0$ 迭代到 $K-1$：\n   a. 使用 Lax-Wendroff 公式计算下一个时间步的解 $n^{m+1}$。通过循环处理网格索引来强制执行周期性边界条件（例如，$n_{-1}^m \\equiv n_{N-1}^m$ 和 $n_N^m \\equiv n_0^m$）。\n   b. 计算出新数组 $n^{m+1}$ 后，找到其最小值 $\\min_j n_j^{m+1}$。\n   c. 如果该最小值小于 $-\\varepsilon = -10^{-12}$，则设置 `negative_detected = 1` 并终止此用例的时间步进。\n   d. 为下一次迭代更新解数组。\n7. 记录该用例的 `negative_detected` 的最终值。\n8. 处理完所有用例后，将结果报告为这些标志的列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D linear advection equation using the Lax-Wendroff scheme\n    and detects the occurrence of unphysical negative values.\n    \"\"\"\n\n    # Define the tolerance for detecting negative values.\n    epsilon = 1.0e-12\n\n    def run_simulation(L, a, N, c, T, initial_profile_func):\n        \"\"\"\n        Runs a single simulation case.\n\n        Returns:\n            int: 1 if a negative value below the threshold is detected, 0 otherwise.\n        \"\"\"\n        # Grid and time step parameters\n        dx = L / N\n        dt = c * dx / a\n        num_steps = int(T // dt)\n\n        # Spatial grid (uniform and periodic)\n        # x corresponds to nodes x_j = j*dx for j=0, ..., N-1\n        x = np.linspace(0, L, N, endpoint=False)\n\n        # Initialize the solution array n from the initial condition\n        n = initial_profile_func(x)\n\n        # Lax-Wendroff coefficients\n        # n_j^{m+1} = c_j-1 * n_{j-1}^m + c_j * n_j^m + c_j+1 * n_{j+1}^m\n        # Note: np.roll(n, 1) corresponds to n_{j-1}\n        #       np.roll(n, -1) corresponds to n_{j+1}\n        c_j_minus_1 = c * (c + 1.0) / 2.0\n        c_j = 1.0 - c**2\n        c_j_plus_1 = c * (c - 1.0) / 2.0\n        \n        # Check initial state (t=0)\n        if np.min(n)  -epsilon:\n            return 1\n\n        # Time-stepping loop\n        for _ in range(num_steps):\n            # Apply the Lax-Wendroff update rule\n            # np.roll handles periodic boundary conditions efficiently\n            n_new = (c_j_minus_1 * np.roll(n, 1) +\n                     c_j * n +\n                     c_j_plus_1 * np.roll(n, -1))\n            \n            n = n_new\n            \n            # Check for unphysical negative values\n            if np.min(n)  -epsilon:\n                return 1\n\n        return 0\n\n    # Define test cases based on the problem statement\n    test_cases = [\n        # Case A: Smooth Gaussian profile\n        {\n            \"L\": 1.0, \"a\": 1.0, \"N\": 400, \"c\": 0.5, \"T\": 1.0,\n            \"initial_profile_func\": lambda x: np.exp(-((x - 0.3) / 0.05)**2)\n        },\n        # Case B: Single discontinuity pair (square pulse)\n        {\n            \"L\": 1.0, \"a\": 1.0, \"N\": 400, \"c\": 0.9, \"T\": 0.2,\n            \"initial_profile_func\": lambda x: np.where((x >= 0.25)  (x  0.55), 1.0, 0.0)\n        },\n        # Case C: Multiple discontinuities, coarser grid\n        {\n            \"L\": 1.0, \"a\": 1.0, \"N\": 200, \"c\": 0.5, \"T\": 0.2,\n            \"initial_profile_func\": lambda x: np.where(\n                ((x >= 0.10)  (x  0.20)) | ((x >= 0.60)  (x  0.80)), 1.0, 0.0\n            )\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation(\n            case[\"L\"], case[\"a\"], case[\"N\"], case[\"c\"], case[\"T\"], case[\"initial_profile_func\"]\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}