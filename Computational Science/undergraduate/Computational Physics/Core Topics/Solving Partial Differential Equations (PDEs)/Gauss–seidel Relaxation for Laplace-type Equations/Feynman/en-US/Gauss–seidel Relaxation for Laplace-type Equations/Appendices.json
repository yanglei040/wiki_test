{
    "hands_on_practices": [
        {
            "introduction": "The journey from a continuous physical model to a numerical solution begins with discretization. This first practice challenges you to model the deformation of a stretched elastic membrane under a concentrated load, a system governed by the Poisson equation. By implementing a Gauss-Seidel solver from first principles, you will gain hands-on experience in converting a partial differential equation with a source term into a working computational simulation .",
            "id": "2397056",
            "problem": "You are to implement a numerical solver based on Gauss-Seidel relaxation to compute the static out-of-plane displacement of a stretched, clamped, thin elastic membrane subjected to a point-like load. The governing Partial Differential Equation (PDE) is the two-dimensional Poisson equation for a membrane under uniform tension. The mathematical model is as follows.\n\nA square membrane occupies the domain $[0,L]\\times[0,L]$ and is clamped at the boundary, so the boundary displacement satisfies $u(x,y)=0$ for $(x,y)\\in\\partial([0,L]\\times[0,L])$. The membrane tension is a positive constant $T$ measured in $\\mathrm{N/m}$. Under a transverse load per area $p(x,y)$ measured in $\\mathrm{N/m^2}$, the static displacement $u(x,y)$ measured in meters satisfies the Poisson equation\n$$\nT\\,\\nabla^2 u(x,y) = -\\,p(x,y)\n$$\nwith the Laplace operator defined by $\\nabla^2 = \\frac{\\partial^2}{\\partial x^2}+\\frac{\\partial^2}{\\partial y^2}$. A point-like load of magnitude $P$ measured in $\\mathrm{N}$ applied at $(x_0,y_0)$ is represented by\n$$\np(x,y) = P\\,\\delta(x-x_0)\\,\\delta(y-y_0),\n$$\nwhere $\\delta$ is the Dirac delta distribution.\n\nStarting from the definitions of second derivatives and their central finite difference approximations on a uniform grid, derive a five-point finite difference discretization of the Poisson equation on a uniform grid with spacing $h=L/(N+1)$ using $N$ interior points in each spatial direction. Discretize the domain with grid nodes $(x_i,y_j)=(ih,jh)$ for $i,j\\in\\{0,1,\\dots,N+1\\}$ and enforce $u_{i,j}=0$ whenever $i\\in\\{0,N+1\\}$ or $j\\in\\{0,N+1\\}$. Represent the point-like load by injecting the total load into the nearest interior grid node $(i_0,j_0)$ to $(x_0,y_0)$, and derive the correctly scaled discrete right-hand side at that node from the requirement that the continuum load integrates to $P$ and the discrete update is consistent in physical units. Your derivation must proceed from the central finite difference approximations and the definition of the Dirac delta function without assuming any pre-given discrete update formula.\n\nDesign an iterative Gauss-Seidel relaxation algorithm that updates the interior grid values in-place until convergence. You may optionally use the Successive Over-Relaxation variant with a fixed relaxation parameter $\\omega\\in(1,2)$ to accelerate convergence while preserving the Gauss-Seidel structure. Use a convergence criterion based on the maximum absolute change in $u$ over all interior nodes in a full sweep, and stop when this maximum absolute change is less than a given threshold $\\tau$ measured in meters. Ensure that your algorithm is numerically stable and that all steps are justified from the discretized equations you derived.\n\nYour program must compute, for each test case below, the displacement at the interior grid node nearest to the applied point load, measured in meters. For each test case, round the result to exactly six decimal places. No user input is allowed; all parameters are hard-coded. Angles are not used in this problem. All physical quantities must be used with the units specified above, and all displacements reported in meters.\n\nUse the following test suite that must be embedded into your program:\n\n- Test case $1$: $L=1.0$ $\\mathrm{m}$, $N=63$, $T=100.0$ $\\mathrm{N/m}$, $P=1.0$ $\\mathrm{N}$, $(x_0,y_0)=(0.5,0.5)$ $\\mathrm{m}$, convergence threshold $\\tau=1\\times 10^{-8}$ $\\mathrm{m}$.\n- Test case $2$: $L=1.0$ $\\mathrm{m}$, $N=63$, $T=100.0$ $\\mathrm{N/m}$, $P=5.0$ $\\mathrm{N}$, $(x_0,y_0)=(0.5,0.5)$ $\\mathrm{m}$, convergence threshold $\\tau=1\\times 10^{-8}$ $\\mathrm{m}$.\n- Test case $3$: $L=1.0$ $\\mathrm{m}$, $N=63$, $T=100.0$ $\\mathrm{N/m}$, $P=1.0$ $\\mathrm{N}$, $(x_0,y_0)=(0.2,0.3)$ $\\mathrm{m}$, convergence threshold $\\tau=1\\times 10^{-8}$ $\\mathrm{m}$.\n- Test case $4$: $L=1.0$ $\\mathrm{m}$, $N=63$, $T=100.0$ $\\mathrm{N/m}$, $P=0.0$ $\\mathrm{N}$, $(x_0,y_0)=(0.5,0.5)$ $\\mathrm{m}$, convergence threshold $\\tau=1\\times 10^{-10}$ $\\mathrm{m}$.\n- Test case $5$: $L=1.0$ $\\mathrm{m}$, $N=127$, $T=100.0$ $\\mathrm{N/m}$, $P=1.0$ $\\mathrm{N}$, $(x_0,y_0)=(0.5,0.5)$ $\\mathrm{m}$, convergence threshold $\\tau=1\\times 10^{-8}$ $\\mathrm{m}$.\n\nFinal output format: Your program should produce a single line of output containing the five rounded results as a comma-separated list enclosed in square brackets, in the order of the test cases, for example $[u_1,u_2,u_3,u_4,u_5]$, where each $u_k$ is a floating-point number with exactly six digits after the decimal point representing meters.",
            "solution": "The problem is subjected to validation and is found to be scientifically grounded, well-posed, and complete. A solution will be constructed.\n\nThe governing equation for the static displacement $u(x,y)$ of the membrane is the $2$-dimensional Poisson equation:\n$$ T\\,\\nabla^2 u(x,y) = -p(x,y) $$\nwhere $T$ is the tension, $p(x,y)$ is the load per unit area, and $\\nabla^2 = \\frac{\\partial^2}{\\partial x^2}+\\frac{\\partial^2}{\\partial y^2}$ is the Laplace operator. The domain is a square $[0,L]\\times[0,L]$ with clamped boundary conditions, $u=0$ on the boundary.\n\nFirst, we discretize the domain and the differential operator. A uniform grid with $N$ interior points in each direction is established. The grid spacing is $h = L/(N+1)$. The grid nodes are located at $(x_i, y_j) = (ih, jh)$ for integers $i, j \\in \\{0, 1, \\dots, N+1\\}$. The displacement at these nodes is denoted by $u_{i,j} = u(x_i, y_j)$. The boundary conditions imply $u_{i,j} = 0$ if $i \\in \\{0, N+1\\}$ or $j \\in \\{0, N+1\\}$.\n\nThe second partial derivatives are approximated using the second-order central difference formula. For a function $f(z)$, the second derivative is $f''(z) \\approx (f(z+h) - 2f(z) + f(z-h))/h^2$. Applying this to $u(x,y)$ at node $(i,j)$:\n$$ \\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{(i,j)} \\approx \\frac{u(x_i+h, y_j) - 2u(x_i, y_j) + u(x_i-h, y_j)}{h^2} = \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h^2} $$\n$$ \\frac{\\partial^2 u}{\\partial y^2}\\bigg|_{(i,j)} \\approx \\frac{u(x_i, y_j+h) - 2u(x_i, y_j) + u(x_i, y_j-h)}{h^2} = \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h^2} $$\nThe discretized Laplacian, known as the $5$-point stencil, becomes:\n$$ \\nabla^2 u \\bigg|_{(i,j)} \\approx \\frac{u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j}}{h^2} $$\nSubstituting this into the Poisson equation yields the linear system for the interior nodes ($i,j \\in \\{1, \\dots, N\\}$):\n$$ T \\left( \\frac{u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j}}{h^2} \\right) = -p_{i,j} $$\nwhere $p_{i,j}$ is the discrete representation of the load density $p(x,y)$ at node $(i,j)$.\n\nThe load is a point-like force of magnitude $P$ at $(x_0, y_0)$, described by the Dirac delta distribution: $p(x,y) = P\\,\\delta(x-x_0)\\,\\delta(y-y_0)$. To find the discrete load $p_{i,j}$, we must preserve the integral property of the delta function. The total force is the integral of the load density over the area. On the discrete grid, the total force is the sum of forces at each node, where the force at a node is the density $p_{i,j}$ multiplied by the area element $h^2$ associated with that node.\n$$ \\sum_{i=1}^{N} \\sum_{j=1}^{N} p_{i,j} h^2 \\approx \\iint_{\\text{domain}} p(x,y) \\,dx\\,dy = \\iint_{\\text{domain}} P\\,\\delta(x-x_0)\\,\\delta(y-y_0) \\,dx\\,dy = P $$\nThe problem specifies that the entire load $P$ is applied to the single interior grid node $(i_0, j_0)$ nearest to $(x_0, y_0)$. This means we must have $p_{i_0,j_0}h^2 = P$ and $p_{i,j}=0$ for all other nodes $(i,j) \\neq (i_0, j_0)$. This gives the discrete load density at the point of application as $p_{i_0,j_0} = P/h^2$.\n\nWith this, the discretized Poisson equation at the load point $(i_0,j_0)$ is:\n$$ T \\left( \\frac{u_{i_0+1,j_0} + u_{i_0-1,j_0} + u_{i_0,j_0+1} + u_{i_0,j_0-1} - 4u_{i_0,j_0}}{h^2} \\right) = -\\frac{P}{h^2} $$\nFor any other interior node $(i,j) \\neq (i_0,j_0)$, we have $p_{i,j}=0$, so the equation simplifies to the discrete Laplace equation:\n$$ \\frac{u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j}}{h^2} = 0 $$\nTo formulate an iterative scheme, we rearrange the discretized equation to solve for $u_{i,j}$:\n$$ 4u_{i,j} = u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} + \\frac{p_{i,j} h^2}{T} $$\n$$ u_{i,j} = \\frac{1}{4} \\left( u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} + f_{i,j} \\right) $$\nwhere we define a source term $f_{i,j} = p_{i,j} h^2 / T$. Based on our load discretization, this source term is non-zero only at $(i_0, j_0)$:\n$$ f_{i,j} = \\begin{cases} P/T & \\text{if } (i,j) = (i_0,j_0) \\\\ 0 & \\text{otherwise} \\end{cases} $$\n\nThe Gauss-Seidel method is an iterative technique to solve this linear system. It updates the value of $u_{i,j}$ at each node using the most recently computed values of its neighbors. For iteration $k+1$, the update for $u_{i,j}$ is:\n$$ u_{i,j}^{(k+1)} = \\frac{1}{4} \\left( u_{i+1,j}^{(k)} + u_{i-1,j}^{(k+1)} + u_{i,j+1}^{(k)} + u_{i,j-1}^{(k+1)} + f_{i,j} \\right) $$\nassuming a lexicographical sweep (e.g., increasing $i$, then increasing $j$). This is implemented by overwriting the values of $u_{i,j}$ in-place within a single array.\n\nTo accelerate convergence, Successive Over-Relaxation (SOR) is used. This method modifies the Gauss-Seidel update by introducing a relaxation parameter $\\omega \\in (1,2)$. First, a provisional value is computed via the Gauss-Seidel step, let's call it $u_{i,j}^{\\text{GS}}$:\n$$ u_{i,j}^{\\text{GS}} = \\frac{1}{4} \\left( u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} + f_{i,j} \\right) $$\nThe new value $u_{i,j}^{\\text{new}}$ is then a weighted average of the old value $u_{i,j}^{\\text{old}}$ and $u_{i,j}^{\\text{GS}}$:\n$$ u_{i,j}^{\\text{new}} = (1-\\omega) u_{i,j}^{\\text{old}} + \\omega u_{i,j}^{\\text{GS}} $$\nFor a square domain with Dirichlet boundary conditions, the optimal relaxation parameter is known to be:\n$$ \\omega_{\\text{opt}} = \\frac{2}{1 + \\sin(\\pi h/L)} = \\frac{2}{1 + \\sin(\\pi / (N+1))} $$\nUsing this value for $\\omega$ significantly reduces the number of iterations required for convergence compared to standard Gauss-Seidel where $\\omega=1$.\n\nThe algorithm proceeds as follows:\n$1$. Initialize an $(N+2) \\times (N+2)$ grid $u$ with all elements set to $0$. This automatically satisfies the boundary conditions $u_{i,j}=0$ on the edges.\n$2$. Determine the grid parameters: $h = L/(N+1)$ and the indices $(i_0,j_0)$ of the node nearest to the load application point $(x_0,y_0)$. These are given by $i_0 = \\text{round}(x_0/h)$ and $j_0 = \\text{round}(y_0/h)$. An assertion must be made that $1 \\le i_0, j_0 \\le N$.\n$3$. Construct a source grid $f$ of the same size, with $f_{j_0,i_0} = P/T$ and all other elements $0$. Note that array indexing `(row, col)` corresponds to `(j, i)`.\n$4$. Calculate the optimal relaxation parameter $\\omega$ using the formula for $\\omega_{\\text{opt}}$.\n$5$. Iterate until convergence:\n    a. Initialize a variable $\\text{max\\_abs\\_change} = 0$.\n    b. Sweep through all interior grid points, for $j=1, \\dots, N$ and $i=1, \\dots, N$.\n    c. At each point $(i,j)$, store the current value $u_{j,i}^{\\text{old}}$.\n    d. Calculate the new value $u_{j,i}^{\\text{new}}$ using the SOR update formula.\n    e. Update the grid in-place: $u_{j,i} = u_{j,i}^{\\text{new}}$.\n    f. Update the maximum change: $\\text{max\\_abs\\_change} = \\max(\\text{max\\_abs\\_change}, |u_{j,i}^{\\text{new}} - u_{j,i}^{\\text{old}}|)$.\n    g. After one full sweep over all interior nodes, check the convergence criterion: if $\\text{max\\_abs\\_change} < \\tau$, terminate the iteration.\n$6$. Once converged, the required displacement is the value at the load point, $u_{j_0,i_0}$. This value is then rounded to $6$ decimal places as requested.\n\nThis procedure is implemented for each provided test case.",
            "answer": "```python\nimport numpy as np\nimport math\n\ndef run_simulation(L, N, T, P, x0, y0, tau):\n    \"\"\"\n    Solves the Poisson equation for membrane displacement using the\n    Successive Over-Relaxation (SOR) method.\n\n    Args:\n        L (float): Side length of the square membrane [m].\n        N (int): Number of interior grid points in each direction.\n        T (float): Tension in the membrane [N/m].\n        P (float): Magnitude of the point load [N].\n        x0 (float): x-coordinate of the load application point [m].\n        y0 (float): y-coordinate of the load application point [m].\n        tau (float): Convergence threshold for displacement [m].\n\n    Returns:\n        float: The displacement at the node nearest to the load point.\n    \"\"\"\n    # Handle the trivial case where there is no load.\n    if P == 0.0:\n        return 0.0\n\n    # 1. Initialize grid and parameters\n    # The grid size is (N+2) x (N+2) to include the clamped boundaries.\n    grid_size = N + 2\n    u = np.zeros((grid_size, grid_size), dtype=np.float64)\n    \n    # Calculate the grid spacing h.\n    h = L / (N + 1)\n    \n    # 2. Determine load point and create the discrete source term grid `f`.\n    # Numpy array indexing is (row, col), which corresponds to (j, i).\n    # The variable i corresponds to the x-direction, and j to the y-direction.\n    # We find the nearest grid indices (i0, j0) to the physical point (x0, y0).\n    i0 = int(round(x0 / h))\n    j0 = int(round(y0 / h))\n    \n    # Verify that the calculated load point is an interior node.\n    if not (1 = i0 = N and 1 = j0 = N):\n        raise ValueError(f\"Load point ({x0}, {y0}) maps to a boundary node.\")\n\n    # The source term f is zero everywhere except at the load point.\n    # As derived, f_i0,j0 = P/T.\n    f_source_value = P / T\n    \n    # 3. Calculate the optimal relaxation parameter omega for SOR.\n    omega = 2.0 / (1.0 + math.sin(math.pi / (N + 1)))\n\n    # 4. Main SOR iteration loop.\n    # A safety break is included to prevent infinite loops.\n    max_iterations = 20000 \n    for _ in range(max_iterations):\n        max_abs_change = 0.0\n        \n        # Sweep over all interior grid points.\n        for j in range(1, N + 1):\n            for i in range(1, N + 1):\n                u_old = u[j, i]\n                \n                # Apply the source term only at the specific load point.\n                source = f_source_value if i == i0 and j == j0 else 0.0\n                \n                # Calculate the update using the Gauss-Seidel formula.\n                u_gs = 0.25 * (u[j, i+1] + u[j, i-1] + u[j+1, i] + u[j-1, i] + source)\n                \n                # Apply the SOR formula. The update is done in-place.\n                u[j, i] = (1.0 - omega) * u_old + omega * u_gs\n                \n                # Track the maximum change in displacement over the grid for this iteration.\n                max_abs_change = max(max_abs_change, abs(u[j, i] - u_old))\n\n        # 5. Check for convergence.\n        if max_abs_change  tau:\n            break\n            \n    # 6. Return the displacement at the node nearest to the load application point.\n    return u[j0, i0]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        {'L': 1.0, 'N': 63, 'T': 100.0, 'P': 1.0, 'x0': 0.5, 'y0': 0.5, 'tau': 1e-8},\n        {'L': 1.0, 'N': 63, 'T': 100.0, 'P': 5.0, 'x0': 0.5, 'y0': 0.5, 'tau': 1e-8},\n        {'L': 1.0, 'N': 63, 'T': 100.0, 'P': 1.0, 'x0': 0.2, 'y0': 0.3, 'tau': 1e-8},\n        {'L': 1.0, 'N': 63, 'T': 100.0, 'P': 0.0, 'x0': 0.5, 'y0': 0.5, 'tau': 1e-10},\n        {'L': 1.0, 'N': 127, 'T': 100.0, 'P': 1.0, 'x0': 0.5, 'y0': 0.5, 'tau': 1e-8},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation(\n            L=case['L'], N=case['N'], T=case['T'], P=case['P'],\n            x0=case['x0'], y0=case['y0'], tau=case['tau']\n        )\n        # Format the result to exactly six decimal places.\n        results.append(f\"{result:.6f}\")\n\n    # Print the final output in the required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "Real-world physical systems are often defined by a mix of constraints at their boundaries. This exercise moves beyond simple fixed-value (Dirichlet) conditions to explore insulated boundaries, which are described by Neumann conditions specifying the flux. You will implement the \"ghost point\" method to correctly model a thermally insulated edge on a heated plate, a vital technique for accurately simulating systems involving heat flow, electrostatics, and fluid dynamics .",
            "id": "2397045",
            "problem": "Consider the steady-state temperature field on a rectangular plate described by the scalar field $T(x,y)$ that satisfies the Laplace equation $\\nabla^2 T = 0$ in the interior of the domain $\\Omega = [0,L_x] \\times [0,L_y]$. Temperatures are dimensionless. The boundary of the plate, $\\partial \\Omega$, may have either fixed temperatures (Dirichlet conditions) or perfect thermal insulation (Neumann conditions with zero normal derivative). A uniform Cartesian grid with $N_x$ nodes in the $x$-direction and $N_y$ nodes in the $y$-direction covers the full rectangle, including its boundary, with spacings $\\Delta x = L_x/(N_x - 1)$ and $\\Delta y = L_y/(N_y - 1)$. Let $T_{i,j}$ denote the discrete approximation to $T$ at grid node $(x_i,y_j)$ with $x_i = i \\,\\Delta x$ for $i = 0,1,\\dots,N_x-1$ and $y_j = j \\,\\Delta y$ for $j = 0,1,\\dots,N_y-1$.\n\nYour task is to compute a discrete solution $T_{i,j}$ for several boundary-value configurations specified below such that the discrete equation corresponding to $\\nabla^2 T = 0$ is satisfied throughout the interior to within a prescribed tolerance. The discrete five-point Laplacian should be interpreted consistently with the boundary conditions imposed on $\\partial \\Omega$. For nodes that are on a boundary with a Dirichlet condition, the value $T_{i,j}$ must equal the prescribed boundary value. For nodes adjacent to an insulated boundary, zero normal derivative must be enforced so that the interior solution satisfies the Laplace equation in a way that is consistent with this constraint. The numerical solution must satisfy the discrete residual bound\n$$\n\\max_{i,j \\text{ not Dirichlet}} \\left| \\frac{T_{i+1,j} - 2T_{i,j} + T_{i-1,j}}{\\Delta x^2} + \\frac{T_{i,j+1} - 2T_{i,j} + T_{i,j-1}}{\\Delta y^2} \\right| \\le \\varepsilon,\n$$\nwith the understanding that the finite difference expressions at boundaries must be consistent with the boundary data, and where $\\varepsilon$ is given in each test case.\n\nFor each test case, you must report two numbers:\n- The scalar value $T_{\\mathrm{center}}$, defined as the computed temperature at the grid node closest to the geometric center of the domain. When $N_x$ and $N_y$ are odd, this is the node with indices $i_c = (N_x-1)/2$ and $j_c = (N_y-1)/2$, so $T_{\\mathrm{center}} = T_{i_c, j_c}$.\n- The scalar $S_{\\mathrm{Neu}}$, defined as the maximum absolute value of the discrete normal derivative taken over all nodes on all insulated (Neumann) edges, using the second-order one-sided finite difference. For a top boundary at $y = L_y$, this discrete derivative at node $i$ is\n$$\n\\left.\\frac{\\partial T}{\\partial n}\\right|_{\\mathrm{top},i} \\approx \\frac{-3 T_{i,N_y-1} + 4 T_{i,N_y-2} - T_{i,N_y-3}}{2 \\,\\Delta y}.\n$$\nFor a bottom boundary at $y = 0$,\n$$\n\\left.\\frac{\\partial T}{\\partial n}\\right|_{\\mathrm{bottom},i} \\approx \\frac{3 T_{i,0} - 4 T_{i,1} + T_{i,2}}{2 \\,\\Delta y}.\n$$\nFor a left boundary at $x = 0$,\n$$\n\\left.\\frac{\\partial T}{\\partial n}\\right|_{\\mathrm{left},j} \\approx \\frac{3 T_{0,j} - 4 T_{1,j} + T_{2,j}}{2 \\,\\Delta x}.\n$$\nFor a right boundary at $x = L_x$,\n$$\n\\left.\\frac{\\partial T}{\\partial n}\\right|_{\\mathrm{right},j} \\approx \\frac{-3 T_{N_x-1,j} + 4 T_{N_x-2,j} - T_{N_x-3,j}}{2 \\,\\Delta x}.\n$$\nThen\n$$\nS_{\\mathrm{Neu}} = \\max \\left( \\{\\left| \\left.\\frac{\\partial T}{\\partial n}\\right|_{\\mathrm{edge,node}} \\right| \\;\\text{over all insulated edges and their nodes}\\} \\right).\n$$\n\nUse the following test suite. Each test case specifies $(L_x,L_y,N_x,N_y)$, the boundary conditions on all four edges in the order $(\\text{left},\\text{right},\\text{bottom},\\text{top})$, the residual tolerance $\\varepsilon$, and an iteration cap $I_{\\max}$ to ensure termination. A Dirichlet boundary is denoted $D$ with a value, and an insulated boundary is denoted $N$ with zero normal derivative. At corners that are part of a Dirichlet edge, the Dirichlet value applies at the corner node.\n\n- Test case A:\n  - Geometry: $L_x = 1$, $L_y = 1$, $N_x = 33$, $N_y = 33$.\n  - Boundaries: $(D:1,\\; D:0,\\; N:0,\\; N:0)$.\n  - Tolerance and cap: $\\varepsilon = 10^{-8}$, $I_{\\max} = 20000$.\n\n- Test case B:\n  - Geometry: $L_x = 2$, $L_y = 1$, $N_x = 31$, $N_y = 17$.\n  - Boundaries: $(N:0,\\; N:0,\\; D:1,\\; D:0)$.\n  - Tolerance and cap: $\\varepsilon = 10^{-8}$, $I_{\\max} = 20000$.\n\n- Test case C:\n  - Geometry: $L_x = 1$, $L_y = 1$, $N_x = 25$, $N_y = 25$.\n  - Boundaries: $(D:0.5,\\; D:0.5,\\; N:0,\\; N:0)$.\n  - Tolerance and cap: $\\varepsilon = 10^{-8}$, $I_{\\max} = 20000$.\n\nYour program must compute $(T_{\\mathrm{center}}, S_{\\mathrm{Neu}})$ for each test case in the order A, B, C, and produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The output should list the six numbers in the order $[T_{\\mathrm{center}}^{(A)}, S_{\\mathrm{Neu}}^{(A)}, T_{\\mathrm{center}}^{(B)}, S_{\\mathrm{Neu}}^{(B)}, T_{\\mathrm{center}}^{(C)}, S_{\\mathrm{Neu}}^{(C)}]$. No units are required because all quantities are dimensionless. Angles, if any, are not used.",
            "solution": "The user requires the numerical solution of the two-dimensional, steady-state Laplace equation for a scalar temperature field $T(x,y)$, defined on a rectangular domain $\\Omega = [0,L_x] \\times [0,L_y]$. The governing equation is:\n$$ \\nabla^2 T = \\frac{\\partial^2 T}{\\partial x^2} + \\frac{\\partial^2 T}{\\partial y^2} = 0 $$\nThis problem is to be solved on a discrete Cartesian grid with mixed Dirichlet and Neumann boundary conditions.\n\nThe solution will be obtained using a finite difference method. The domain is discretized into a grid of $N_x \\times N_y$ nodes, with uniform spacings $\\Delta x = L_x/(N_x - 1)$ and $\\Delta y = L_y/(N_y - 1)$. The temperature at a grid node $(x_i, y_j) = (i\\Delta x, j\\Delta y)$ is denoted by $T_{i,j}$.\n\nThe partial derivatives in the Laplace equation are approximated using second-order central differences. This yields the well-known five-point stencil for the discrete Laplacian at an interior node $(i,j)$:\n$$ \\frac{T_{i+1,j} - 2T_{i,j} + T_{i-1,j}}{(\\Delta x)^2} + \\frac{T_{i,j+1} - 2T_{i,j} + T_{i,j-1}}{(\\Delta y)^2} = 0 $$\nThis equation forms a system of linear algebraic equations for the unknown temperatures $T_{i,j}$ at all non-Dirichlet nodes.\n\nThis system is solved using the Gauss-Seidel iterative method. The equation is rearranged to express $T_{i,j}$ in terms of its neighbors. During the iterative process, we sweep through the grid, updating each $T_{i,j}$ using the most recently computed values of its neighbors. The update formula for an interior node is:\n$$ T_{i,j}^{(k+1)} = \\frac{1}{2\\left(\\frac{1}{(\\Delta x)^2} + \\frac{1}{(\\Delta y)^2}\\right)} \\left[ \\frac{T_{i+1,j}^{(k)} + T_{i-1,j}^{(k+1)}}{(\\Delta x)^2} + \\frac{T_{i,j+1}^{(k)} + T_{i,j-1}^{(k+1)}}{(\\Delta y)^2} \\right] $$\nwhere the superscripts denote the iteration number, and the update is performed in-place by scanning through indices $j$ and then $i$.\n\nBoundary conditions are incorporated as follows:\n- **Dirichlet boundaries**: Nodes on these boundaries have their temperatures fixed to the prescribed values. They do not participate in the iterative update process. The problem statement clarifies that any corner node adjacent to a Dirichlet edge is treated as a Dirichlet point. For all specified test cases, this means all four corners are Dirichlet points.\n- **Neumann boundaries**: A zero normal derivative condition ($\\frac{\\partial T}{\\partial n}=0$) is imposed. This is implemented using \"ghost points\". For instance, on a left boundary ($i=0$), the condition $\\frac{\\partial T}{\\partial x}=0$ is discretized via a central difference as $\\frac{T_{1,j} - T_{-1,j}}{2\\Delta x} = 0$, implying a ghost point value $T_{-1,j} = T_{1,j}$. Substituting this into the five-point stencil at $(0,j)$ yields the update rule for that boundary node:\n$$ T_{0,j}^{(k+1)} = \\frac{1}{2\\left(\\frac{1}{(\\Delta x)^2} + \\frac{1}{(\\Delta y)^2}\\right)} \\left[ \\frac{2 T_{1,j}^{(k)}}{(\\Delta x)^2} + \\frac{T_{0,j+1}^{(k)} + T_{0,j-1}^{(k+1)}}{(\\Delta y)^2} \\right] $$\nAnalogous formulae are derived for the other three insulated boundaries (right, top, bottom).\n\nThe iterative process continues until the solution converges. Convergence is achieved when the maximum absolute value of the discrete residual, evaluated over all non-Dirichlet nodes, falls below a specified tolerance $\\varepsilon$. The residual at node $(i,j)$ is the value of the discrete Laplacian calculated with the current temperature field $T_{i,j}$, using ghost points where necessary for Neumann boundaries. The iteration is also capped at $I_{\\max}$ to prevent infinite loops.\n\nUpon convergence, two quantities are calculated:\n1.  $T_{\\mathrm{center}}$: The temperature at the grid node closest to the geometric center of the plate, specifically at indices $i_c = (N_x-1)/2$ and $j_c = (N_y-1)/2$.\n2.  $S_{\\mathrm{Neu}}$: The maximum absolute value of the normal derivative on all insulated boundaries. This is computed using the specific second-order one-sided finite difference formulas provided in the problem statement. The maximum is taken over all nodes on the insulated segments, which, due to the corner rule, excludes the corner nodes themselves. If no boundaries are of the Neumann type, $S_{\\mathrm{Neu}}$ is taken to be $0$.\n\nThe implementation will consist of a primary routine that iterates through the test cases. For each case, a solver function will be called. This function will:\n1.  Initialize the temperature grid and identify Dirichlet nodes.\n2.  Perform the Gauss-Seidel iterations, updating all non-Dirichlet nodes in each sweep according to the interior or Neumann boundary formulae.\n3.  Periodically compute the maximum residual to check for convergence against $\\varepsilon$.\n4.  After the loop terminates, calculate and return $T_{\\mathrm{center}}$ and $S_{\\mathrm{Neu}}$.\nThe final results from all test cases will be aggregated and printed in the specified format.",
            "answer": "```python\nimport numpy as np\n\ndef compute_case(Lx, Ly, Nx, Ny, boundaries, epsilon, max_iter):\n    \"\"\"\n    Solves the 2D Laplace equation on a rectangular grid with mixed boundary conditions.\n    \"\"\"\n    dx = Lx / (Nx - 1)\n    dy = Ly / (Ny - 1)\n\n    T = np.zeros((Ny, Nx), dtype=np.float64)\n    is_dirichlet = np.zeros((Ny, Nx), dtype=bool)\n    \n    bc_map = {'left': boundaries[0], 'right': boundaries[1], \n              'bottom': boundaries[2], 'top': boundaries[3]}\n\n    # Set Dirichlet boundary conditions and mask\n    if bc_map['left'].startswith('D'):\n        val = float(bc_map['left'].split(':')[1])\n        T[:, 0] = val\n        is_dirichlet[:, 0] = True\n    if bc_map['right'].startswith('D'):\n        val = float(bc_map['right'].split(':')[1])\n        T[:, -1] = val\n        is_dirichlet[:, -1] = True\n    if bc_map['bottom'].startswith('D'):\n        val = float(bc_map['bottom'].split(':')[1])\n        T[0, :] = val\n        is_dirichlet[0, :] = True\n    if bc_map['top'].startswith('D'):\n        val = float(bc_map['top'].split(':')[1])\n        T[-1, :] = val\n        is_dirichlet[-1, :] = True\n\n    # Pre-calculate coefficients for the update rule\n    cx = 1 / (dx**2)\n    cy = 1 / (dy**2)\n    c = 1 / (2 * (cx + cy))\n    \n    # Identify Neumann boundaries for convenience\n    is_left_N = bc_map['left'].startswith('N')\n    is_right_N = bc_map['right'].startswith('N')\n    is_bottom_N = bc_map['bottom'].startswith('N')\n    is_top_N = bc_map['top'].startswith('N')\n\n    for k in range(max_iter):\n        # Gauss-Seidel update sweep\n        for j in range(Ny):\n            for i in range(Nx):\n                if is_dirichlet[j, i]:\n                    continue\n                \n                # Interior points\n                if 1 = j  Ny - 1 and 1 = i  Nx - 1:\n                    T[j,i] = c * (cx * (T[j, i+1] + T[j, i-1]) + cy * (T[j+1, i] + T[j-1, i]))\n                # Neumann boundary points (corners are Dirichlet for all test cases)\n                elif is_bottom_N and j == 0 and 1 = i  Nx - 1:\n                    T[j,i] = c * (cx * (T[j,i+1] + T[j,i-1]) + cy * (2 * T[j+1,i]))\n                elif is_top_N and j == Ny - 1 and 1 = i  Nx - 1:\n                    T[j,i] = c * (cx * (T[j,i+1] + T[j,i-1]) + cy * (2 * T[j-1,i]))\n                elif is_left_N and i == 0 and 1 = j  Ny - 1:\n                    T[j,i] = c * (cx * (2 * T[j,i+1]) + cy * (T[j+1,i] + T[j-1,i]))\n                elif is_right_N and i == Nx - 1 and 1 = j  Ny - 1:\n                    T[j,i] = c * (cx * (2 * T[j,i-1]) + cy * (T[j+1,i] + T[j-1,i]))\n        \n        # Check for convergence every 10 iterations to reduce overhead\n        if k % 10 == 0 or k == max_iter - 1:\n            max_res = 0.0\n            for j in range(Ny):\n                for i in range(Nx):\n                    if is_dirichlet[j, i]:\n                        continue\n                    \n                    res_val = 0.0\n                    # Interior residual\n                    if 1 = j  Ny - 1 and 1 = i  Nx - 1:\n                        res_val = cx*(T[j,i+1]+T[j,i-1]-2*T[j,i]) + cy*(T[j+1,i]+T[j-1,i]-2*T[j,i])\n                    # Neumann boundary residuals\n                    elif is_bottom_N and j == 0 and 1 = i  Nx-1:\n                        res_val = cx*(T[j,i+1]+T[j,i-1]-2*T[j,i]) + cy*(2*T[j+1,i]-2*T[j,i])\n                    elif is_top_N and j == Ny-1 and 1 = i  Nx-1:\n                        res_val = cx*(T[j,i+1]+T[j,i-1]-2*T[j,i]) + cy*(2*T[j-1,i]-2*T[j,i])\n                    elif is_left_N and i == 0 and 1 = j  Ny-1:\n                        res_val = cx*(2*T[j,i+1]-2*T[j,i]) + cy*(T[j+1,i]+T[j-1,i]-2*T[j,i])\n                    elif is_right_N and i == Nx-1 and 1 = j  Ny-1:\n                        res_val = cx*(2*T[j,i-1]-2*T[j,i]) + cy*(T[j+1,i]+T[j-1,i]-2*T[j,i])\n                    \n                    max_res = max(max_res, abs(res_val))\n\n            if max_res = epsilon:\n                break\n    \n    # Calculate output values\n    ic, jc = (Nx - 1) // 2, (Ny - 1) // 2\n    T_center = T[jc, ic]\n\n    s_neu_max = 0.0\n    if is_left_N:\n        if Ny > 3 : # Ensure slice is not empty and indices are valid\n            deriv = (3 * T[1:-1, 0] - 4 * T[1:-1, 1] + T[1:-1, 2]) / (2 * dx)\n            s_neu_max = max(s_neu_max, np.max(np.abs(deriv)))\n    if is_right_N:\n        if Ny > 3:\n            deriv = (-3 * T[1:-1, -1] + 4 * T[1:-1, -2] - T[1:-1, -3]) / (2 * dx)\n            s_neu_max = max(s_neu_max, np.max(np.abs(deriv)))\n    if is_bottom_N:\n        if Nx > 3:\n            deriv = (3 * T[0, 1:-1] - 4 * T[1, 1:-1] + T[2, 1:-1]) / (2 * dy)\n            s_neu_max = max(s_neu_max, np.max(np.abs(deriv)))\n    if is_top_N:\n        if Nx > 3:\n            deriv = (-3 * T[-1, 1:-1] + 4 * T[-2, 1:-1] - T[-3, 1:-1]) / (2 * dy)\n            s_neu_max = max(s_neu_max, np.max(np.abs(deriv)))\n\n    return T_center, s_neu_max\n\ndef solve():\n    test_cases = [\n        {'Lx': 1, 'Ly': 1, 'Nx': 33, 'Ny': 33, 'boundaries': ('D:1', 'D:0', 'N:0', 'N:0'), 'epsilon': 1e-8, 'max_iter': 20000},\n        {'Lx': 2, 'Ly': 1, 'Nx': 31, 'Ny': 17, 'boundaries': ('N:0', 'N:0', 'D:1', 'D:0'), 'epsilon': 1e-8, 'max_iter': 20000},\n        {'Lx': 1, 'Ly': 1, 'Nx': 25, 'Ny': 25, 'boundaries': ('D:0.5', 'D:0.5', 'N:0', 'N:0'), 'epsilon': 1e-8, 'max_iter': 20000},\n    ]\n\n    results = []\n    for case in test_cases:\n        T_center, S_neu = compute_case(**case)\n        results.extend([T_center, S_neu])\n\n    print(f\"[{','.join(f'{x:.8g}' for x in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A correct numerical solution is good, but a correct and fast solution is better. This final practice introduces Successive Over-Relaxation (SOR), a powerful technique to accelerate the convergence of the Gauss-Seidel method. You will not only implement the SOR algorithm but also perform a numerical experiment to empirically determine the optimal relaxation parameter $\\omega$, learning a crucial skill in high-performance scientific computing: tuning an algorithm for a specific problem geometry .",
            "id": "2397060",
            "problem": "You are to implement a numerical solver for the two-dimensional Laplace equation using Successive Over-Relaxation (SOR) to accelerate Gauss-Seidel iteration. Your implementation must empirically determine the optimal relaxation parameter $\\,\\omega_{\\mathrm{opt}}\\,\\in(0,2)\\,$ for specific rectangular geometries with Dirichlet boundary conditions. The task must be carried out from first principles starting from the definition of the Laplace equation and a standard five-point finite difference discretization on a uniform Cartesian grid.\n\nYou must adhere to the following requirements.\n\n- Start from the definition of the Laplace equation in two spatial dimensions, $\\,\\nabla^2 u = 0\\,$, and the five-point uniform-grid finite difference discretization on a rectangular lattice. Use Gauss-Seidel iteration enhanced by Successive Over-Relaxation (SOR). Do not assume any pre-derived formulas beyond these foundations.\n- Use red–black ordering (checkerboard updates) so that within each iteration you update all red interior points first, then all black interior points, with in-place updates.\n- Adopt the following convergence criterion. Let one “iteration” be one complete red–black sweep. After each sweep, define the iteration-to-iteration change as the maximum absolute difference between the updated values and their previous values over the set of updated interior points (exclude Dirichlet-fixed boundary points and any internal Dirichlet obstacles). Stop when this infinity norm of the update falls below the tolerance $\\,\\tau = 10^{-5}\\,$, or when the number of iterations reaches the maximum $\\,I_{\\max} = 5000\\,$, whichever comes first.\n- Use a zero initial guess for all interior unknowns, i.e., $\\,u_{i,j}=0\\,$ for interior points at the start of each solve. Apply the Dirichlet boundary values and any internal Dirichlet obstacle values before iterations begin and keep them fixed during iterations.\n- Define the empirical search for $\\,\\omega_{\\mathrm{opt}}\\,$ as a two-stage search:\n  - Coarse stage: test $\\,\\omega\\,$ on the grid $\\,\\{1.0, 1.1, 1.2, \\dots, 1.9\\}\\,$.\n  - Fine stage: let $\\,\\omega_c\\,$ be the coarse-stage minimizer of the iteration count to convergence (break ties by choosing the smallest $\\,\\omega\\,$). Then test $\\,\\omega\\,$ on the uniform grid $\\,\\max(1.0,\\omega_c-0.05),\\,\\max(1.0,\\omega_c-0.05)+0.01,\\,\\dots,\\,\\min(1.95,\\omega_c+0.05)\\,$. Choose $\\,\\omega_{\\mathrm{opt}}\\,$ as the minimizer of the iteration count over the fine grid (again breaking ties by choosing the smallest $\\,\\omega\\,$). Report $\\,\\omega_{\\mathrm{opt}}\\,$ rounded to two decimals, and report the corresponding minimal iteration count as an integer. Only round after selecting the minimizer.\n- Use a uniform grid spacing in both directions. You do not need to report physical units, and you should not use angular quantities.\n\nTest suite. Implement your program to compute and report results for the following three ($3$) test cases.\n\n- Case A (square with a hot top edge):\n  - Grid: $\\,N_x = 50\\,$, $\\,N_y = 50\\,$.\n  - Dirichlet boundary values: top edge $\\,u=1.0\\,$, and bottom, left, right edges $\\,u=0.0\\,$.\n  - No internal obstacle.\n- Case B (rectangle with a hot left edge):\n  - Grid: $\\,N_x = 60\\,$, $\\,N_y = 30\\,$.\n  - Dirichlet boundary values: left edge $\\,u=1.0\\,$, and top, bottom, right edges $\\,u=0.0\\,$.\n  - No internal obstacle.\n- Case C (square with a warm internal obstacle):\n  - Grid: $\\,N_x = 40\\,$, $\\,N_y = 40\\,$.\n  - Dirichlet boundary values: all four outer edges $\\,u=0.0\\,$.\n  - Internal Dirichlet obstacle: a centered square of side length $\\,8\\,$ interior grid points (i.e., indices $\\,x\\in\\{16,17,\\dots,23\\}\\,$ and $\\,y\\in\\{16,17,\\dots,23\\}\\,$ in zero-based indexing) held at fixed value $\\,u=0.5\\,$.\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case result must be a two-element list $[\\omega_{\\mathrm{opt}}, I_{\\min}]$, where $\\,\\omega_{\\mathrm{opt}}\\,$ is rounded to two decimals and $\\,I_{\\min}\\,$ is the minimal iteration count as an integer. The final line must therefore look like\n$\\,\\big[[\\omega^{(A)}_{\\mathrm{opt}}, I^{(A)}_{\\min}], [\\omega^{(B)}_{\\mathrm{opt}}, I^{(B)}_{\\min}], [\\omega^{(C)}_{\\mathrm{opt}}, I^{(C)}_{\\min}]\\big]\\,$\nwith no additional text. For example, a syntactically correct output would be\n$\\,\\big[[1.80, 250], [1.90, 180], [1.75, 310]\\big]\\,$\nalthough these are not the expected numerical values for this problem.",
            "solution": "We begin from the Laplace equation in two spatial dimensions,\n$$\n\\nabla^2 u \\;=\\; \\frac{\\partial^2 u}{\\partial x^2} \\;+\\; \\frac{\\partial^2 u}{\\partial y^2} \\;=\\; 0,\n$$\nposed on a rectangle with Dirichlet boundary data. On a uniform Cartesian grid with spacing $\\,h\\,$ in both directions and interior indices $\\,i=1,\\dots,N_x-2\\,$ and $\\,j=1,\\dots,N_y-2\\,$ (with the outermost indices reserved for Dirichlet boundaries), the classical five-point finite difference (FD) approximation yields the discrete Laplace operator\n$$\n\\frac{u_{i+1,j} - 2\\,u_{i,j} + u_{i-1,j}}{h^2} \\;+\\; \\frac{u_{i,j+1} - 2\\,u_{i,j} + u_{i,j-1}}{h^2} \\;=\\; 0,\n$$\nwhich simplifies, for uniform $\\,h\\,$ and pure Laplace (no source term), to the fixed-point relation\n$$\nu_{i,j} \\;=\\; \\frac{1}{4}\\,\\big( u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} \\big).\n$$\nThis identity suggests an iterative method: Gauss-Seidel (GS) iteration updates each interior $\\,u_{i,j}\\,$ in-place using the most recently available neighbor values. When some grid points are Dirichlet-fixed (boundaries or internal obstacles), they are excluded from updates and retained as constants so that their values participate in neighbor sums without changing.\n\nSuccessive Over-Relaxation (SOR) accelerates GS by convex extrapolation of the GS update towards the fixed point. Denote the Gauss-Seidel update at $\\,\\{i,j\\}\\,$ by\n$$\nu^{\\mathrm{GS}}_{i,j} \\;=\\; \\frac{1}{4}\\,\\big( u_{i+1,j}^{\\star} + u_{i-1,j}^{\\star} + u_{i,j+1}^{\\star} + u_{i,j-1}^{\\star} \\big),\n$$\nwhere each neighbor $\\,u^{\\star}\\,$ is the current in-place value (some neighbors already updated in the same sweep, others not yet). The SOR update with relaxation parameter $\\,\\omega\\in(0,2)\\,$ is\n$$\nu^{\\mathrm{new}}_{i,j} \\;=\\; (1-\\omega)\\,u^{\\mathrm{old}}_{i,j} \\;+\\; \\omega\\,u^{\\mathrm{GS}}_{i,j}.\n$$\nFor red–black ordering, the grid is partitioned into two interleaved sets based on parity of $\\,i+j\\,$. All red points are updated first using only black neighbors (since each red point’s nearest neighbors are black), then all black points are updated using the newly updated red neighbors, completing one iteration (one sweep). This ordering enables vectorized updates and preserves the Gauss-Seidel dependency structure.\n\nConvergence is monitored by the infinity norm of the per-iteration change. Let $\\,\\Delta^{(k)}\\,$ be the maximum absolute difference between updated and previous values across all updated interior points during iteration $\\,k\\,$. We terminate when\n$$\n\\Delta^{(k)} \\;\\; \\tau \\;=\\; 10^{-5},\n$$\nor when the number of iterations reaches the cap $\\,I_{\\max}=5000\\,$. The initial guess is set to $\\,u_{i,j}=0\\,$ for all interior points, with Dirichlet boundaries and internal obstacle values imposed and held fixed.\n\nTo empirically determine $\\,\\omega_{\\mathrm{opt}}\\,$, we minimize the number of iterations required to satisfy the stopping criterion over a prescribed set of $\\,\\omega\\,$ values. We adopt a two-stage search to balance robustness and computational cost:\n\n- Coarse stage: evaluate $\\,\\omega \\in \\{1.0, 1.1, \\dots, 1.9\\}\\,$ and select the minimizer $\\,\\omega_c\\,$ of the iteration count (breaking ties towards the smaller $\\,\\omega\\,$).\n- Fine stage: evaluate the neighborhood $\\,\\omega \\in [\\max(1.0,\\omega_c-0.05), \\min(1.95,\\omega_c+0.05)]\\,$ on a uniform grid with step $\\,0.01\\,$, and select the minimizer $\\,\\omega_{\\mathrm{opt}}\\,$ (again breaking ties to the smaller $\\,\\omega\\,$). Only after selecting the minimizer do we round $\\,\\omega_{\\mathrm{opt}}\\,$ to two decimals for reporting.\n\nWe implement three geometries.\n\n- Case A: $\\,N_x=50\\,$, $\\,N_y=50\\,$. Top edge fixed to $\\,u=1.0\\,$; other edges fixed to $\\,u=0.0\\,$; no obstacle.\n- Case B: $\\,N_x=60\\,$, $\\,N_y=30\\,$. Left edge fixed to $\\,u=1.0\\,$; other edges fixed to $\\,u=0.0\\,$; no obstacle.\n- Case C: $\\,N_x=40\\,$, $\\,N_y=40\\,$. All outer edges fixed to $\\,u=0.0\\,$. A centered internal Dirichlet obstacle of side $\\,8\\,$ interior grid points, indices $\\,x\\in\\{16,\\dots,23\\},\\,y\\in\\{16,\\dots,23\\}\\,$, fixed to $\\,u=0.5\\,$.\n\nAlgorithmic details for efficiency and correctness:\n\n- Construct boolean masks over interior points to identify red and black update locations, and optionally to exclude obstacle cells from updates.\n- In each red (respectively black) half-sweep, compute the neighbor sum $\\,u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1}\\,$ over the entire interior, then apply the SOR update only on the red (respectively black) mask. For the red half-sweep, the neighbor sum uses values where all red neighbors are actually black cells; thus the sum correctly employs the most recent black values. After red updates, recompute the neighbor sum so that black updates see the updated red neighbors.\n- Track the maximum absolute change across updates in that sweep as $\\,\\Delta^{(k)}\\,$.\n\nThe program then executes the two-stage search for each test case, records the best $\\,\\omega_{\\mathrm{opt}}\\,$ and its minimal iteration count $\\,I_{\\min}\\,$, rounds $\\,\\omega_{\\mathrm{opt}}\\,$ to two decimals, and prints a single line with the list\n$$\n\\big[[\\omega^{(A)}_{\\mathrm{opt}}, I^{(A)}_{\\min}], [\\omega^{(B)}_{\\mathrm{opt}}, I^{(B)}_{\\min}], [\\omega^{(C)}_{\\mathrm{opt}}, I^{(C)}_{\\min}]\\big].\n$$\nThis procedure is universal for Laplace-type problems on uniform grids with Dirichlet data and demonstrates how Successive Over-Relaxation (SOR) accelerates Gauss-Seidel iteration and how the relaxation parameter $\\,\\omega\\,$ can be empirically tuned for a given discrete geometry.",
            "answer": "```python\nimport numpy as np\n\ndef sor_red_black(\n    nx: int,\n    ny: int,\n    boundary_values: dict,\n    obstacle_mask: np.ndarray | None = None,\n    obstacle_value: float | None = None,\n    omega: float = 1.5,\n    tol: float = 1e-5,\n    max_iters: int = 5000,\n) -> int:\n    \"\"\"\n    Perform red-black SOR for Laplace's equation on an nx-by-ny grid.\n    - boundary_values: dict with any of 'top','bottom','left','right' mapping to floats.\n      Edges not specified default to 0.0.\n    - obstacle_mask: full-size boolean array (ny, nx), True where Dirichlet-fixed internal obstacle exists.\n    - obstacle_value: float value assigned to obstacle cells (required if obstacle_mask is provided).\n    - omega: relaxation parameter in (0,2).\n    - tol: stopping tolerance on infinity norm of per-iteration change.\n    - max_iters: maximum number of red-black sweeps.\n    Returns: number of iterations (sweeps) taken to reach tol (or max_iters if not reached).\n    \"\"\"\n    # Initialize potential field\n    u = np.zeros((ny, nx), dtype=np.float64)\n\n    # Apply boundary conditions (unspecified edges are zero)\n    if 'bottom' in boundary_values:\n        u[0, :] = boundary_values['bottom']\n    if 'top' in boundary_values:\n        u[-1, :] = boundary_values['top']\n    if 'left' in boundary_values:\n        u[:, 0] = boundary_values['left']\n    if 'right' in boundary_values:\n        u[:, -1] = boundary_values['right']\n\n    # Internal Dirichlet obstacle\n    if obstacle_mask is not None:\n        if obstacle_value is None:\n            raise ValueError(\"obstacle_value must be provided when obstacle_mask is given.\")\n        u[obstacle_mask] = obstacle_value\n\n    # Interior masks (exclude outer boundary)\n    # Boolean mask of interior points that are updatable (not obstacle)\n    interior_shape = (ny - 2, nx - 2)\n    if interior_shape[0] = 0 or interior_shape[1] = 0:\n        return 0  # no interior to update\n\n    # Build interior obstacle mask\n    if obstacle_mask is not None:\n        obsI = obstacle_mask[1:-1, 1:-1].copy()\n    else:\n        obsI = np.zeros(interior_shape, dtype=bool)\n\n    update_mask = ~obsI  # True where we update\n\n    # Red-black masks over the interior\n    ii = np.arange(1, ny - 1)[:, None]\n    jj = np.arange(1, nx - 1)[None, :]\n    parity = (ii + jj)  1  # 0 for even (red), 1 for odd (black)\n    red_mask = (parity == 0)[1 - 1:ny - 1 - 1 + 1, 1 - 1:nx - 1 - 1 + 1]  # same shape as interior\n    black_mask = ~red_mask\n    red_mask = red_mask  update_mask\n    black_mask = black_mask  update_mask\n\n    # Helper to compute neighbor sum over interior\n    def neighbor_sum(U):\n        return (U[2:, 1:-1] + U[:-2, 1:-1] + U[1:-1, 2:] + U[1:-1, :-2])\n\n    # Iterate\n    iters = 0\n    for k in range(1, max_iters + 1):\n        max_change = 0.0\n\n        # Red half-sweep\n        s = neighbor_sum(u)\n        uI = u[1:-1, 1:-1]\n        if np.any(red_mask):\n            old_vals = uI[red_mask]\n            gs_vals = 0.25 * s[red_mask]\n            new_vals = (1.0 - omega) * old_vals + omega * gs_vals\n            change = np.max(np.abs(new_vals - old_vals)) if new_vals.size else 0.0\n            max_change = max(max_change, float(change))\n            uI[red_mask] = new_vals\n\n        # Black half-sweep\n        s = neighbor_sum(u)  # recompute after red updates\n        if np.any(black_mask):\n            old_vals = uI[black_mask]\n            gs_vals = 0.25 * s[black_mask]\n            new_vals = (1.0 - omega) * old_vals + omega * gs_vals\n            change = np.max(np.abs(new_vals - old_vals)) if new_vals.size else 0.0\n            max_change = max(max_change, float(change))\n            uI[black_mask] = new_vals\n\n        iters = k\n        if max_change  tol:\n            break\n\n    return iters\n\n\ndef empirical_omega_opt(\n    nx: int,\n    ny: int,\n    boundary_values: dict,\n    obstacle_mask: np.ndarray | None,\n    obstacle_value: float | None,\n    tol: float = 1e-5,\n    max_iters: int = 5000,\n):\n    \"\"\"\n    Two-stage empirical search for omega_opt minimizing iteration count.\n    Returns (omega_opt_rounded_to_2_decimals, min_iterations).\n    \"\"\"\n    # Coarse grid: 1.0 to 1.9 step 0.1\n    coarse_candidates = [round(1.0 + 0.1 * i, 10) for i in range(0, 10)]  # [1.0, ..., 1.9]\n    coarse_results = []\n    for w in coarse_candidates:\n        it = sor_red_black(\n            nx, ny, boundary_values,\n            obstacle_mask=obstacle_mask,\n            obstacle_value=obstacle_value,\n            omega=w, tol=tol, max_iters=max_iters\n        )\n        coarse_results.append((w, it))\n    # Select best coarse (min iters, tie-break by smallest omega)\n    min_it_coarse = min(it for _, it in coarse_results)\n    best_coarse = min([w for (w, it) in coarse_results if it == min_it_coarse])\n\n    # Fine grid around best_coarse: step 0.01 within [1.0, 1.95]\n    start = max(1.0, best_coarse - 0.05)\n    end = min(1.95, best_coarse + 0.05)\n    n_steps = int(round((end - start) / 0.01))  # inclusive range\n    fine_candidates = [round(start + 0.01 * i, 10) for i in range(n_steps + 1)]\n    fine_results = []\n    for w in fine_candidates:\n        it = sor_red_black(\n            nx, ny, boundary_values,\n            obstacle_mask=obstacle_mask,\n            obstacle_value=obstacle_value,\n            omega=w, tol=tol, max_iters=max_iters\n        )\n        fine_results.append((w, it))\n    min_it_fine = min(it for _, it in fine_results)\n    best_fine = min([w for (w, it) in fine_results if it == min_it_fine])\n\n    return round(best_fine, 2), int(min_it_fine)\n\n\ndef build_obstacle_mask(ny: int, nx: int, y0: int, y1: int, x0: int, x1: int) -> np.ndarray:\n    \"\"\"\n    Build a full-size boolean mask with True on [y0:y1, x0:x1] inclusive of endpoints if using slice semantics.\n    Here, we assume x1, y1 are exclusive upper bounds for numpy slicing.\n    \"\"\"\n    mask = np.zeros((ny, nx), dtype=bool)\n    mask[y0:y1, x0:x1] = True\n    return mask\n\n\ndef solve():\n    results = []\n\n    # Common solver settings\n    tol = 1e-5\n    max_iters = 5000\n\n    # Case A: Nx=50, Ny=50, top=1.0, others=0.0, no obstacle\n    nx_A, ny_A = 50, 50\n    bvals_A = {'top': 1.0, 'bottom': 0.0, 'left': 0.0, 'right': 0.0}\n    omega_A, it_A = empirical_omega_opt(\n        nx_A, ny_A, bvals_A,\n        obstacle_mask=None, obstacle_value=None,\n        tol=tol, max_iters=max_iters\n    )\n    results.append([omega_A, it_A])\n\n    # Case B: Nx=60, Ny=30, left=1.0, others=0.0, no obstacle\n    nx_B, ny_B = 60, 30\n    bvals_B = {'left': 1.0, 'top': 0.0, 'bottom': 0.0, 'right': 0.0}\n    omega_B, it_B = empirical_omega_opt(\n        nx_B, ny_B, bvals_B,\n        obstacle_mask=None, obstacle_value=None,\n        tol=tol, max_iters=max_iters\n    )\n    results.append([omega_B, it_B])\n\n    # Case C: Nx=40, Ny=40, all edges 0.0, centered 8x8 obstacle at 0.5\n    nx_C, ny_C = 40, 40\n    bvals_C = {'top': 0.0, 'bottom': 0.0, 'left': 0.0, 'right': 0.0}\n    # Center indices for obstacle: 8x8 block\n    side = 8\n    x0 = nx_C // 2 - side // 2\n    x1 = x0 + side\n    y0 = ny_C // 2 - side // 2\n    y1 = y0 + side\n    obstacle_C = build_obstacle_mask(ny_C, ny_C, y0, y1, x0, x1)\n    omega_C, it_C = empirical_omega_opt(\n        nx_C, ny_C, bvals_C,\n        obstacle_mask=obstacle_C, obstacle_value=0.5,\n        tol=tol, max_iters=max_iters\n    )\n    results.append([omega_C, it_C])\n\n    # Final output in the exact required format\n    # Print a single line: [[omegaA,iterA],[omegaB,iterB],[omegaC,iterC]]\n    print(str(results).replace(' ', ''))\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}