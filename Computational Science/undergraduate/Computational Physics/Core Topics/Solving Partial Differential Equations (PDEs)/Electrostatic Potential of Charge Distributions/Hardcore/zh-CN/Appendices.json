{
    "hands_on_practices": [
        {
            "introduction": "我们从最基本的方法开始：基于叠加原理的直接求和。这个练习将通过一个随机过程（三维随机行走）来创建一个电荷分布，然后通过累加每个电荷的贡献来计算其产生的电势。这项实践引入了随机建模和为处理奇点而采用的正则化等关键计算思想，是将物理模型与直接数值实现相结合的绝佳起点 。",
            "id": "2388140",
            "problem": "你的任务是设计并实现一个完整的数值实验，该实验通过三维随机游走构建电荷分布，然后计算在指定观测点产生的静电势。该实验必须完全可复现且数值稳定。\n\n请按照以下步骤，从一个基本框架开始，构建一系列点电荷。首先基于物理定义，即由静态点电荷产生的在位置$\\mathbf{r}$处的静电势由叠加原理确定。在此任务中，你需要通过三维随机游走建立一个离散的电荷分布：从原点开始，以固定长度$a$在单位球面上各向同性分布的独立同分布方向上进行$N$步移动。每走一步后，在到达的位置放置一个点电荷。为每个点分配相等的电荷，使得所有点的总电荷为1。使用无量纲单位，其中库仑常数等于1。由于点电荷在零距离处对电势有奇异贡献，你必须引入一个严格为正的软化长度$\\eta$来对计算进行正则化；请选择与欧几里得距离一致的最简单的各向同性正则化方法。使用提供的整数种子来初始化伪随机数生成器，以确保可复现性。\n\n你的程序必须：\n- 从$\\mathbf{r}_0=\\mathbf{0}$开始，生成步长固定为$a$的$\\mathbb{R}^3$空间中的游走位置$\\{\\mathbf{r}_i\\}_{i=1}^{N}$。\n- 分配相等的电荷$q_i$，使得$\\sum_{i=1}^{N} q_i = 1$。\n- 仅使用叠加原理、点电荷对电势贡献的定义以及所选的正则化方法，计算每个指定观测点的静电势。使用由参数$\\eta0$指定的各向同性软化。\n- 使用无量纲单位，总电荷等于$1$。\n- 使用指定的种子初始化伪随机数生成器，以保持每个测试用例的确定性。\n\n测试套件。你的程序必须将上述方法应用于以下参数集，并返回所需的值：\n- 情景A（通用“理想路径”）：种子$314159$，$N=200$，$a=0.5$，$\\eta=0.05$，观测点$\\mathbf{r}^{(A)}_{\\text{obs}} \\in \\{(0,0,0),(1,1,1),(2,0,-1)\\}$。\n- 情景B（单个电荷的边界情况）：种子$7$，$N=1$，$a=1.0$，$\\eta=0.01$，观测点$\\mathbf{r}^{(B)}_{\\text{obs}} \\in \\{(0,0,0),(0.1,0,0),(10,0,0)\\}$。\n- 情景C（步长为零的退化游走）：种子$99$，$N=50$，$a=0.0$，$\\eta=0.1$，观测点$\\mathbf{r}^{(C)}_{\\text{obs}} \\in \\{(0,0,0),(10^{-6},0,0),(1,0,0)\\}$。\n\n对于每个情景，计算三个观测点各自的静电势，并将其作为四舍五入到$6$位小数的浮点数返回。按A、B、C的顺序汇总所有情景的结果。\n\n最终输出格式。你的程序应生成单行输出，其中包含一个逗号分隔的列表的列表，不含空格。每个内部列表对应A、B、C顺序中的一个情景，并按每个情景观测点的相同顺序包含三个四舍五入后的浮点值。例如，打印的行必须如下所示：\n[[v11,v12,v13],[v21,v22,v23],[v31,v32,v33]]\n其中每个$v_{ij}$是四舍五入到$6$位小数的浮点数。不得打印任何其他文本。",
            "solution": "问题陈述已经过分析，并被认为是有效的。它在科学上基于静电学和计算物理学的原理，定义了所有必要参数，问题设定良好，并且其表述是客观的。我们现在将着手解决。\n\n任务是计算由三维随机游走产生的电荷分布在指定观测点上引起的静电势。解决方案是基于基本原理系统地构建的。\n\n首先，我们解决电荷位置的生成问题。从原点$\\mathbf{r}_0 = \\mathbf{0}$开始，构建一个包含$N$步的随机游走。第$i$步之后的位置$\\mathbf{r}_i$由前一个位置$\\mathbf{r}_{i-1}$和一个长度固定为$a$、方向为各向同性随机的步长向量决定：\n$$\n\\mathbf{r}_i = \\mathbf{r}_{i-1} + a \\cdot \\mathbf{u}_i, \\quad i \\in \\{1, 2, \\dots, N\\}\n$$\n其中$\\mathbf{u}_i$是从三维球面表面均匀采样的单位向量，$\\mathbf{u}_i \\in S^2 \\subset \\mathbb{R}^3$。生成这样一个向量的稳健方法是，从标准正态分布$\\mathcal{N}(0,1)$中抽取三个独立的随机变量$(z_1, z_2, z_3)$，形成一个向量$\\mathbf{v} = (z_1, z_2, z_3)$，然后将其归一化：\n$$\n\\mathbf{u}_i = \\frac{\\mathbf{v}}{||\\mathbf{v}||_2}\n$$\n这个过程保证了各向同性分布。这组$N$个点电荷被放置在位置$\\{\\mathbf{r}_i\\}_{i=1}^{N}$上。\n问题规定必须为随机数生成器设定种子以确保可复现性。\n\n其次，我们考虑电荷值和叠加原理。系统的总电荷规定为1。这个总电荷被平均分配给$N$个点电荷。因此，每个单独电荷$q_i$的值是：\n$$\nq_i = \\frac{1}{N} \\quad \\forall i \\in \\{1, 2, \\dots, N\\}\n$$\n根据静电学中的叠加原理，观测点$\\mathbf{r}_{\\text{obs}}$处的总电势$V$是每个点电荷独立产生的电势$V_i$的代数和：\n$$\nV(\\mathbf{r}_{\\text{obs}}) = \\sum_{i=1}^{N} V_i(\\mathbf{r}_{\\text{obs}})\n$$\n\n第三，我们定义单个点电荷的电势，并包含所需的正则化。在库仑常数$k=1$的无量纲单位中，静电势由$q/d$给出，其中$d$是与电荷的距离。当$d \\to 0$时，此表达式是奇异的。为了防止数值不稳定，引入了一个软化参数$\\eta  0$。问题要求“与欧几里得距离一致的最简单的各向同性正则化”。这通过将距离$d = ||\\mathbf{r}_{\\text{obs}} - \\mathbf{r}_i||_2$替换为正则化距离$\\sqrt{d^2 + \\eta^2}$来实现。因此，位于位置$\\mathbf{r}_i$的单个电荷$q_i$贡献的电势是：\n$$\nV_i(\\mathbf{r}_{\\text{obs}}) = \\frac{q_i}{\\sqrt{||\\mathbf{r}_{\\text{obs}} - \\mathbf{r}_i||_2^2 + \\eta^2}}\n$$\n\n综合这些原理，观测点$\\mathbf{r}_{\\text{obs}}$处总静电势的完整表达式为：\n$$\nV(\\mathbf{r}_{\\text{obs}}) = \\sum_{i=1}^{N} \\frac{1/N}{\\sqrt{||\\mathbf{r}_{\\text{obs}} - \\mathbf{r}_i||_2^2 + \\eta^2}}\n$$\n该公式将为每个测试用例进行计算实现。\n\n算法如下：\n1. 对于每个测试用例，获取参数：种子(seed)、$N$、$a$、$\\eta$以及观测点集合$\\{\\mathbf{r}_{\\text{obs}}\\}$。\n2. 使用给定的种子初始化伪随机数生成器。\n3. 初始化游走位置$\\mathbf{r}_{\\text{current}} = (0, 0, 0)$。\n4. 创建一个列表以存储$N$个电荷位置。\n5. 迭代$N$次：\n    a. 如上所述，生成一个随机单位向量$\\mathbf{u}$。\n    b. 更新当前位置：$\\mathbf{r}_{\\text{current}} \\leftarrow \\mathbf{r}_{\\text{current}} + a \\cdot \\mathbf{u}$。\n    c. 将新的$\\mathbf{r}_{\\text{current}}$存储在电荷位置列表中。\n6. 对于每个给定的观测点$\\mathbf{r}_{\\text{obs}}$：\n    a. 初始化总电势$V_{\\text{total}} = 0$。\n    b. 对于生成的列表中的每个电荷位置$\\mathbf{r}_i$：\n        i. 计算欧几里得距离的平方：$d^2 = ||\\mathbf{r}_{\\text{obs}} - \\mathbf{r}_i||_2^2$。\n        ii. 计算正则化的电势贡献：$V_i = \\frac{1/N}{\\sqrt{d^2 + \\eta^2}}$。\n        iii. 累加电势：$V_{\\text{total}} \\leftarrow V_{\\text{total}} + V_i$。\n    c. 将计算出的$V_{\\text{total}}$四舍五入到$6$位小数并存储。\n7. 收集所有测试用例的结果列表，并将它们格式化为指定的最终输出字符串。\n\n一个特殊情况是情景C，其中步长$a=0$。在这里，随机游走不会离开原点。所有$N$个电荷都共存于$\\mathbf{r}_i = \\mathbf{0}$处。该系统表现为一个位于原点的总电荷为$\\sum q_i = 1$的单点电荷。电势简化为：\n$$\nV(\\mathbf{r}_{\\text{obs}}) = \\frac{1}{\\sqrt{||\\mathbf{r}_{\\text{obs}}||_2^2 + \\eta^2}}\n$$\n这为数值实现提供了一个有价值的解析检验。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the computational physics problem by generating charge distributions\n    from 3D random walks and calculating the electrostatic potential at specified points.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"name\": \"Case A\",\n            \"seed\": 314159,\n            \"N\": 200,\n            \"a\": 0.5,\n            \"eta\": 0.05,\n            \"obs_points\": [(0, 0, 0), (1, 1, 1), (2, 0, -1)],\n        },\n        {\n            \"name\": \"Case B\",\n            \"seed\": 7,\n            \"N\": 1,\n            \"a\": 1.0,\n            \"eta\": 0.01,\n            \"obs_points\": [(0, 0, 0), (0.1, 0, 0), (10, 0, 0)],\n        },\n        {\n            \"name\": \"Case C\",\n            \"seed\": 99,\n            \"N\": 50,\n            \"a\": 0.0,\n            \"eta\": 0.1,\n            \"obs_points\": [(0, 0, 0), (1e-6, 0, 0), (1, 0, 0)],\n        },\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        seed = case[\"seed\"]\n        N = case[\"N\"]\n        a = case[\"a\"]\n        eta = case[\"eta\"]\n        obs_points = np.array(case[\"obs_points\"])\n\n        # Initialize the pseudo-random number generator for reproducibility\n        rng = np.random.default_rng(seed)\n\n        # Generate the charge positions from the 3D random walk\n        charge_positions = np.zeros((N, 3))\n        current_pos = np.zeros(3)\n        \n        # Handle the N=0 case gracefully, although not in test suite.\n        if N > 0:\n            for i in range(N):\n                # Generate an isotropic random direction vector\n                rand_vec = rng.standard_normal(3)\n                norm = np.linalg.norm(rand_vec)\n                \n                # A norm of zero is statistically impossible but good practice to handle.\n                if norm == 0:\n                    # Default to an arbitrary axis if the unlikely happens.\n                    unit_vec = np.array([1.0, 0.0, 0.0])\n                else:\n                    unit_vec = rand_vec / norm\n\n                # Take a step and update position\n                current_pos += a * unit_vec\n                charge_positions[i] = current_pos\n\n        case_results = []\n        for obs_point in obs_points:\n            if N == 0:\n                total_potential = 0.0\n            else:\n                # Calculate the potential using vectorized operations\n                # Charge of each point is 1/N\n                q = 1.0 / N\n\n                # Calculate squared distances from the observation point to all charges\n                diffs = charge_positions - obs_point\n                sq_dists = np.sum(diffs**2, axis=1)\n\n                # Calculate potential from each charge and sum them up (superposition)\n                # V = sum(q / sqrt(d^2 + eta^2))\n                potentials = q / np.sqrt(sq_dists + eta**2)\n                total_potential = np.sum(potentials)\n            \n            # Round the result to 6 decimal places\n            case_results.append(round(total_potential, 6))\n        \n        all_results.append(case_results)\n\n    # Format the final output string exactly as required, with no spaces.\n    output_str = str(all_results).replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了如何计算点电荷系的电势后，我们可以将其应用于一个有实际物理意义的量：功。虽然直接对力进行路径积分是一种可行但繁琐的方法，但本练习旨在揭示一个更深刻的物理见解：静电场是保守场。这个特性使得功的计算可以极大地简化为只与起点和终点的电势差有关，展示了物理洞察力与高效算法设计之间的关键相互作用 。",
            "id": "2388108",
            "problem": "一个大小为 $q_{\\mathrm{test}}$ 的点状测试电荷，在真空中由固定点电荷产生的电场内，沿着指定的路径移动。电场 $\\vec{E}(\\vec{r})$ 是由位于位置 $\\{\\vec{r}_i\\}_{i=1}^N$ 处的 $N$ 个静止点电荷 $\\{q_i\\}_{i=1}^N$ 产生的。将测试电荷沿路径 $\\mathcal{C}$ 从点 $A$ 移动到点 $B$ 所需做的功定义为\n$$\nW = q_{\\mathrm{test}} \\int_{\\mathcal{C}} \\vec{E}(\\vec{r}) \\cdot d\\vec{l}.\n$$\n电场由库仑定律（Coulomb's law）给出，\n$$\n\\vec{E}(\\vec{r}) = \\frac{1}{4\\pi \\varepsilon_0} \\sum_{i=1}^N q_i \\frac{\\vec{r} - \\vec{r}_i}{\\lVert \\vec{r} - \\vec{r}_i \\rVert^3},\n$$\n其中 $\\varepsilon_0$ 是真空介电常数。\n\n所有量都必须用国际单位制（SI）表示。使用 $\\varepsilon_0 = 8.8541878128\\times 10^{-12}\\ \\mathrm{F/m}$，位置单位为米。计算出的功值必须以焦耳为单位表示。\n\n固定源电荷：\n- $q_1 = +2.0\\times 10^{-6}\\ \\mathrm{C}$ 位于 $\\vec{r}_1 = (0.00, 0.00, 0.00)\\ \\mathrm{m}$。\n- $q_2 = -1.0\\times 10^{-6}\\ \\mathrm{C}$ 位于 $\\vec{r}_2 = (0.10, 0.00, 0.00)\\ \\mathrm{m}$。\n- $q_3 = +5.0\\times 10^{-7}\\ \\mathrm{C}$ 位于 $\\vec{r}_3 = (0.05, 0.06, 0.00)\\ \\mathrm{m}$。\n\n测试电荷：\n- $q_{\\mathrm{test}} = +1.0\\times 10^{-9}\\ \\mathrm{C}$。\n\n假设使用三维笛卡尔坐标 $(x,y,z)$；所有列出的点都位于 $z=0$ 平面内。\n\n计算以下每个独立测试路径所做的功 $W$。对于任何分段定义的路径，积分按顺序沿每个线段进行并求和。保证路径不会穿过任何源电荷的位置。\n\n测试集（角度必须以弧度为单位解释；距离以米为单位；功以焦耳为单位报告）：\n1. 从 $A=(0.02,\\,0.01,\\,0.00)$ 到 $B=(0.08,\\,0.01,\\,0.00)$ 的直线。\n2. 从 $A=(0.03,\\,0.03,\\,0.00)$ 到 $M=(0.06,\\,0.07,\\,0.00)$ 再到 $B=(0.09,\\,0.04,\\,0.00)$ 的两段折线，按此顺序。\n3. 顶点为 $P_0=(0.07,\\,0.02,\\,0.00)\\to P_1=(0.09,\\,0.02,\\,0.00)\\to P_2=(0.09,\\,0.05,\\,0.00)\\to P_3=(0.07,\\,0.05,\\,0.00)\\to P_0$ 的闭合矩形回路，按所列顺序遍历。\n4. 从 $A=(0.04,\\,0.04,\\,0.00)$ 到同一点 $B=(0.04,\\,0.04,\\,0.00)$ 的退化路径。\n5. 以 $C=(0.02,\\,0.02,\\,0.00)$ 为中心、半径为 $R=0.02$ 的圆弧，起始极角为 $\\theta_0=0$，终止极角为 $\\theta_1=\\frac{\\pi}{2}$，即路径为 $\\vec{r}(\\theta)=C + (R\\cos\\theta,\\,R\\sin\\theta,\\,0)$，其中 $\\theta\\in[0,\\,\\frac{\\pi}{2}]$。\n\n您的程序必须按所列顺序计算这五个功值，并生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，单位为焦耳，每个数字都采用科学记数法格式，并精确到 $10$ 位有效数字（例如，$[\\text{val}_1,\\text{val}_2,\\text{val}_3,\\text{val}_4,\\text{val}_5]$）。",
            "solution": "所述问题需要进行验证。\n\n**步骤1：提取已知条件**\n- **常数：** 真空介电常数 $\\varepsilon_0 = 8.8541878128\\times 10^{-12}\\ \\mathrm{F/m}$。\n- **公式：**\n    - 功：$W = q_{\\mathrm{test}} \\int_{\\mathcal{C}} \\vec{E}(\\vec{r}) \\cdot d\\vec{l}$。\n    - 电场：$\\vec{E}(\\vec{r}) = \\frac{1}{4\\pi \\varepsilon_0} \\sum_{i=1}^N q_i \\frac{\\vec{r} - \\vec{r}_i}{\\lVert \\vec{r} - \\vec{r}_i \\rVert^3}$。\n- **源电荷：**\n    - $q_1 = +2.0\\times 10^{-6}\\ \\mathrm{C}$ 位于 $\\vec{r}_1 = (0.00, 0.00, 0.00)\\ \\mathrm{m}$。\n    - $q_2 = -1.0\\times 10^{-6}\\ \\mathrm{C}$ 位于 $\\vec{r}_2 = (0.10, 0.00, 0.00)\\ \\mathrm{m}$。\n    - $q_3 = +5.0\\times 10^{-7}\\ \\mathrm{C}$ 位于 $\\vec{r}_3 = (0.05, 0.06, 0.00)\\ \\mathrm{m}$。\n- **测试电荷：** $q_{\\mathrm{test}} = +1.0\\times 10^{-9}\\ \\mathrm{C}$。\n- **路径：**\n    1.  从 $A=(0.02,\\,0.01,\\,0.00)$到 $B=(0.08,\\,0.01,\\,0.00)$ 的直线。\n    2.  从 $A=(0.03,\\,0.03,\\,0.00)$ 经 $M=(0.06,\\,0.07,\\,0.00)$ 到 $B=(0.09,\\,0.04,\\,0.00)$ 的折线。\n    3.  闭合矩形回路 $P_0=(0.07,\\,0.02,\\,0.00)\\to P_1\\to P_2\\to P_3\\to P_0$。\n    4.  从 $A=(0.04,\\,0.04,\\,0.00)$ 到 $B=(0.04,\\,0.04,\\,0.00)$ 的退化路径。\n    5.  圆心为 $C=(0.02,\\,0.02,\\,0.00)$，半径为 $R=0.02$，从 $\\theta=0$ 到 $\\theta=\\frac{\\pi}{2}$ 的圆弧。\n\n**步骤2：验证**\n该问题在科学上基于经典静电学。所提供的功和电场的方程是标准的。所有必要的参数——电荷、位置、常数和路径——都得到了清晰且一致的规定。不存在矛盾、歧义或违反物理原理的情况。该问题是适定的，并且有唯一且有意义的解。\n\n**步骤3：结论**\n该问题是有效的。\n\n**求解推导**\n该问题要求计算在静电场中移动测试电荷所做的功。静电场的一个基本性质是它是保守场。这是因为由静止电荷分布产生的电场可以表示为一个标量势的负梯度，即 $\\vec{E} = -\\vec{\\nabla}V$。因此，将电荷从点 $\\vec{r}_A$ 移动到点 $\\vec{r}_B$ 所做的功与路径无关，由势能的变化给出：\n$$\nW_{A \\to B} = q_{\\mathrm{test}} \\int_{\\vec{r}_A}^{\\vec{r}_B} \\vec{E} \\cdot d\\vec{l} = -q_{\\mathrm{test}} \\int_{\\vec{r}_A}^{\\vec{r}_B} (\\vec{\\nabla}V) \\cdot d\\vec{l} = -q_{\\mathrm{test}} (V(\\vec{r}_B) - V(\\vec{r}_A)) = q_{\\mathrm{test}} (V(\\vec{r}_A) - V(\\vec{r}_B))\n$$\n这个关系避免了进行显式路径积分的需要。问题简化为计算每条路径起点和终点的电势 $V$。\n\n由位于位置 $\\{\\vec{r}_i\\}$ 的一组 $N$ 个点电荷 $\\{q_i\\}$ 在位置 $\\vec{r}$ 处产生的电势 $V(\\vec{r})$ 由下式给出：\n$$\nV(\\vec{r}) = \\frac{1}{4\\pi \\varepsilon_0} \\sum_{i=1}^N \\frac{q_i}{\\lVert \\vec{r} - \\vec{r}_i \\rVert}\n$$\n我们将库仑常数表示为 $k_e = \\frac{1}{4\\pi \\varepsilon_0}$。给定 $\\varepsilon_0 = 8.8541878128 \\times 10^{-12}\\ \\mathrm{F/m}$，我们得到 $k_e \\approx 8.987551787 \\times 10^9\\ \\mathrm{N \\cdot m^2 / C^2}$。\n\n计算步骤如下：\n1.  定义一个函数，根据给定的三个源电荷计算任意点 $\\vec{r}=(x,y,z)$ 的电势 $V(\\vec{r})$。\n2.  对每个测试用例，确定起始点 $\\vec{r}_A$ 和终止点 $\\vec{r}_B$。\n3.  计算功 $W = q_{\\mathrm{test}} (V(\\vec{r}_A) - V(\\vec{r}_B))$。\n\n**测试路径分析：**\n\n**路径1：直线**\n- 起始点：$\\vec{r}_A = (0.02, 0.01, 0.00)\\ \\mathrm{m}$。\n- 终止点：$\\vec{r}_B = (0.08, 0.01, 0.00)\\ \\mathrm{m}$。\n- 功为 $W_1 = q_{\\mathrm{test}} (V(\\vec{r}_A) - V(\\vec{r}_B))$。\n\n**路径2：两段折线**\n- 起始点：$\\vec{r}_A = (0.03, 0.03, 0.00)\\ \\mathrm{m}$。\n- 终止点：$\\vec{r}_B = (0.09, 0.04, 0.00)\\ \\mathrm{m}$。\n- 由于电场是保守场，中间点 $M$ 是无关紧要的。功只取决于端点。\n- 功为 $W_2 = q_{\\mathrm{test}} (V(\\vec{r}_A) - V(\\vec{r}_B))$。\n\n**路径3：闭合矩形回路**\n- 路径是闭合的，意味着起始点和终止点相同：$\\vec{r}_A = \\vec{r}_B = P_0 = (0.07, 0.02, 0.00)\\ \\mathrm{m}$。\n- 保守场沿任何闭合回路的线积分为零。\n- 因此，$V(\\vec{r}_A) - V(\\vec{r}_B) = 0$，功为 $W_3 = 0\\ \\mathrm{J}$。\n\n**路径4：退化路径**\n- 起始点和终止点相同：$\\vec{r}_A = \\vec{r}_B = (0.04, 0.04, 0.00)\\ \\mathrm{m}$。\n- 这是一个平凡的闭合路径。\n- 功为 $W_4 = 0\\ \\mathrm{J}$。\n\n**路径5：圆弧**\n- 路径参数化为 $\\vec{r}(\\theta) = (0.02, 0.02, 0) + (0.02\\cos\\theta, 0.02\\sin\\theta, 0)$。\n- 起始点 ($ \\theta=0 $): $\\vec{r}_A = (0.02+0.02\\cos(0), 0.02+0.02\\sin(0), 0) = (0.04, 0.02, 0.00)\\ \\mathrm{m}$。\n- 终止点 ($ \\theta=\\frac{\\pi}{2} $): $\\vec{r}_B = (0.02+0.02\\cos(\\frac{\\pi}{2}), 0.02+0.02\\sin(\\frac{\\pi}{2}), 0) = (0.02, 0.04, 0.00)\\ \\mathrm{m}$。\n- 功为 $W_5 = q_{\\mathrm{test}} (V(\\vec{r}_A) - V(\\vec{r}_B))$。\n\n实现将创建一个用于计算 $V(\\vec{r})$ 的函数，并将其应用于每条路径的端点以确定功。对 $\\vec{E} \\cdot d\\vec{l}$ 进行暴力数值积分效率低下，数值稳定性较差，并且表明对基本静电学原理的理解不足。基于电势的方法在所有方面都更优越。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the work done moving a test charge along various paths in an electrostatic field.\n    The solution leverages the conservative nature of the electrostatic field, calculating work\n    from the difference in electric potential between the start and end points of each path.\n    \"\"\"\n    # Define physical constants and problem parameters in SI units.\n    EPSILON_0 = 8.8541878128e-12  # Vacuum permittivity (F/m)\n    K_E = 1.0 / (4.0 * np.pi * EPSILON_0)  # Coulomb's constant (N*m^2/C^2)\n\n    # Source charges {q_i} and their positions {r_i}\n    SOURCE_CHARGES = np.array([\n        2.0e-6,   # q1 in Coulombs\n        -1.0e-6,  # q2 in Coulombs\n        5.0e-7    # q3 in Coulombs\n    ])\n    \n    SOURCE_POSITIONS = np.array([\n        [0.00, 0.00, 0.00],  # r1 in meters\n        [0.10, 0.00, 0.00],  # r2 in meters\n        [0.05, 0.06, 0.00]   # r3 in meters\n    ])\n\n    # Test charge\n    Q_TEST = 1.0e-9  # in Coulombs\n\n    def calculate_potential(point):\n        \"\"\"\n        Calculates the total electric potential at a given point in space.\n        \n        Args:\n            point (np.ndarray): A 3D vector representing the position (x, y, z).\n            \n        Returns:\n            float: The electric potential in Volts.\n        \"\"\"\n        point = np.array(point)\n        # Calculate distances from the point to each source charge\n        distances = np.linalg.norm(SOURCE_POSITIONS - point, axis=1)\n        \n        # Calculate potential from each charge: V_i = q_i / r_i\n        potentials = SOURCE_CHARGES / distances\n        \n        # Sum potentials and multiply by Coulomb's constant\n        total_potential = K_E * np.sum(potentials)\n        return total_potential\n\n    # Define the start and end points for each test case.\n    test_cases = [\n        # Case 1: Straight line\n        {'start': (0.02, 0.01, 0.00), 'end': (0.08, 0.01, 0.00)},\n        \n        # Case 2: Polyline (only endpoints matter)\n        {'start': (0.03, 0.03, 0.00), 'end': (0.09, 0.04, 0.00)},\n        \n        # Case 3: Closed rectangular loop (Work is zero)\n        {'start': (0.07, 0.02, 0.00), 'end': (0.07, 0.02, 0.00)},\n        \n        # Case 4: Degenerate path (Work is zero)\n        {'start': (0.04, 0.04, 0.00), 'end': (0.04, 0.04, 0.00)},\n        \n        # Case 5: Circular arc\n        {\n            'start': (0.02 + 0.02 * np.cos(0), 0.02 + 0.02 * np.sin(0), 0.00),\n            'end': (0.02 + 0.02 * np.cos(np.pi / 2), 0.02 + 0.02 * np.sin(np.pi / 2), 0.00)\n        }\n    ]\n\n    results = []\n    for i, case in enumerate(test_cases):\n        # For closed loops, work is analytically zero.\n        if i == 2 or i == 3:\n            work = 0.0\n        else:\n            potential_start = calculate_potential(case['start'])\n            potential_end = calculate_potential(case['end'])\n            work = Q_TEST * (potential_start - potential_end)\n        results.append(work)\n\n    # Format the results as specified: scientific notation with 10 significant digits.\n    formatted_results = [f\"{res:.9e}\" for res in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "现在，我们从分立的电荷分布转向由偏微分方程描述的连续介质和边值问题，这是工程和物理领域中更常见的情景。这个高级练习模拟了一个内部填充有复杂弯曲介质界面的电容器。它要求我们使用有限差分法，一种强大且广泛应用于在网格上求解偏微分方程的数值技术，来求解广义的泊松方程 。",
            "id": "2388116",
            "problem": "考虑一个二维平行板电容器，它占据矩形域 $\\Omega = \\{(x,y)\\mid 0 \\le x \\le W,\\; 0 \\le y \\le H\\}$，在平面外方向上不变（进行单位深度分析）。位于 $y=0$ 的下极板保持在电势 $\\phi(x,0) = V_0$，位于 $y=H$ 的上极板保持在 $\\phi(x,H) = 0$。位于 $x=0$ 和 $x=W$ 的左右边界是电绝缘的，即对于所有 $y\\in[0,H]$，有 $\\partial \\phi/\\partial x(0,y)=0$ 和 $\\partial \\phi/\\partial x(W,y)=0$。其内部填充了两种线性的、各向同性的电介质材料，其空间变化的介电常数 $\\varepsilon(x,y)$ 由一个弯曲的材料界面定义。静电势 $\\phi(x,y)$ 满足用于静电学的无源、散度形式的高斯定律：\n$$\n\\nabla \\cdot \\left(\\varepsilon(x,y)\\,\\nabla \\phi(x,y)\\right) = 0 \\quad \\text{in } \\Omega,\n$$\n以及上述边界条件。\n\n设两种材料之间的界面由以下曲线给出：\n$$\nx = x_\\Gamma(y) = \\frac{W}{2} + A \\cos\\!\\left(\\frac{2\\pi y}{H}\\right),\n$$\n因此\n$$\n\\varepsilon(x,y) = \\begin{cases}\n\\varepsilon_0\\,\\kappa_1,  \\text{if } x  x_\\Gamma(y), \\\\\n\\varepsilon_0\\,\\kappa_2,  \\text{if } x \\ge x_\\Gamma(y),\n\\end{cases}\n$$\n其中 $\\varepsilon_0$ 是真空介电常数，$\\kappa_1, \\kappa_2$ 是两种材料的相对介电常数（无量纲）。\n\n通过比率 $C' = Q'/V_0$ 定义单位平面外深度的电容 $C'$，其中下电极上单位深度的自由电荷为\n$$\nQ' = -\\int_{0}^{W} \\varepsilon\\!\\left(x,0^+\\right)\\,\\frac{\\partial \\phi}{\\partial y}(x,0^+)\\,dx.\n$$\n等效地，单位深度的静电能量为 $U'=\\frac{1}{2}\\int_\\Omega \\varepsilon(x,y)\\,|\\nabla\\phi|^2\\,dx\\,dy$，并满足 $C' = 2U'/V_0^2$。所有物理量必须用国际单位制（SI units）表示。使用 $\\varepsilon_0 = 8.854187817\\times 10^{-12}\\,\\mathrm{F/m}$，$W=0.1\\,\\mathrm{m}$，$H=0.1\\,\\mathrm{m}$，以及 $V_0=1.0\\,\\mathrm{V}$。所需的输出中不使用角度。\n\n任务：编写一个完整的、可运行的程序，对下面的每个测试用例，通过求解上述边值问题来计算静电势 $\\phi(x,y)$，并输出单位深度的电容 $C'$，单位为 $\\mathrm{F/m}$。\n\n测试组：\n- 案例 $\\#1$：$(\\kappa_1,\\kappa_2,A) = (3.0,\\,3.0,\\,0.0)$。\n- 案例 $\\#2$：$(\\kappa_1,\\kappa_2,A) = (2.0,\\,5.0,\\,0.0)$。\n- 案例 $\\#3$：$(\\kappa_1,\\kappa_2,A) = (2.0,\\,5.0,\\,0.02\\,W)$。\n- 案例 $\\#4$：$(\\kappa_1,\\kappa_2,A) = (1.0,\\,10.0,\\,0.02\\,W)$。\n\n答案规格：\n- 对每个案例，计算一个浮点数值 $C'$，单位为 $\\mathrm{F/m}$。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，按案例 $\\#1$ 到 $\\#4$ 的顺序排列，每个数字采用科学记数法，小数点后恰好有 $8$ 位数字（例如，`[1.23456789e-03,2.34567890e-04,...]`）。",
            "solution": "对问题陈述进行验证。\n\n**1. 提取已知条件：**\n- 控制方程：在域 $\\Omega = \\{(x,y)\\mid 0 \\le x \\le W,\\; 0 \\le y \\le H\\}$ 内，$\\nabla \\cdot \\left(\\varepsilon(x,y)\\,\\nabla \\phi(x,y)\\right) = 0$。\n- 边界条件：\n  - $\\phi(x,0) = V_0$\n  - $\\phi(x,H) = 0$\n  - $\\frac{\\partial \\phi}{\\partial x}(0,y) = 0$\n  - $\\frac{\\partial \\phi}{\\partial x}(W,y) = 0$\n- 介电常数函数：当 $x  x_\\Gamma(y)$ 时为 $\\varepsilon(x,y) = \\varepsilon_0\\,\\kappa_1$，当 $x \\ge x_\\Gamma(y)$ 时为 $\\varepsilon(x,y) = \\varepsilon_0\\,\\kappa_2$，其中界面为 $x_\\Gamma(y) = \\frac{W}{2} + A \\cos\\left(\\frac{2\\pi y}{H}\\right)$。\n- 电容定义：$C' = Q'/V_0$，其中 $Q' = -\\int_{0}^{W} \\varepsilon\\left(x,0^+\\right)\\,\\frac{\\partial \\phi}{\\partial y}(x,0^+)\\,dx$。\n- 常数：$\\varepsilon_0 = 8.854187817\\times 10^{-12}\\,\\mathrm{F/m}$，$W=0.1\\,\\mathrm{m}$，$H=0.1\\,\\mathrm{m}$，$V_0=1.0\\,\\mathrm{V}$。\n- 测试案例：$(\\kappa_1, \\kappa_2, A)$ 的特定元组。\n\n**2. 验证：**\n- 该问题是**有科学依据的**。它描述了一个由介电介质中的高斯定律控制的标准静电边值问题。所有方程和定义在根本上都是正确的。\n- 该问题是**适定的**。它是一个在封闭有界域上的二阶椭圆型偏微分方程，具有狄利克雷（Dirichlet）和诺伊曼（Neumann）边界条件的有效组合，这保证了电势 $\\phi(x,y)$ 存在唯一且稳定的解。\n- 该问题是**客观且完整的**。它使用精确的数学语言进行规定，并且提供了数值求解所需的所有参数。\n- 该问题在**计算上是可行的**，其条件在物理上是现实的。\n\n**3. 结论：**\n该问题被认定为有效。将构建一个数值解。\n\n**基于原理的求解设计**\n该问题需要求解一个关于静电势 $\\phi(x,y)$ 的二阶、线性、椭圆型偏微分方程（PDE）。我们将采用基于均匀笛卡尔网格的有限差分法（FDM）。\n\n控制方程是无源区域的散度形式高斯定律：\n$$\n\\nabla \\cdot \\left(\\varepsilon(x,y)\\,\\nabla \\phi(x,y)\\right) = 0\n$$\n在笛卡尔坐标系中，这展开为：\n$$\n\\frac{\\partial}{\\partial x}\\left(\\varepsilon(x,y) \\frac{\\partial \\phi}{\\partial x}\\right) + \\frac{\\partial}{\\partial y}\\left(\\varepsilon(x,y) \\frac{\\partial \\phi}{\\partial y}\\right) = 0\n$$\n将域 $\\Omega = [0,W] \\times [0,H]$ 离散化为节点网格 $(x_i, y_j) = (i\\Delta x, j\\Delta y)$，其中 $i=0, \\dots, N_x$ 和 $j=0, \\dots, N_y$，$\\Delta x = W/N_x$ 且 $\\Delta y = H/N_y$。这些节点上的电势记为 $\\phi_{i,j} \\approx \\phi(x_i, y_j)$。\n\n使用中心差分近似来处理导数，其中介电常数 $\\varepsilon$ 在网格单元的中点处求值，以恰当处理其空间变化，内部节点 $(i,j)$ 处的偏微分方程离散化如下：\n$$\n\\frac{1}{\\Delta x^2} \\left[ \\varepsilon_{i+1/2, j} (\\phi_{i+1,j} - \\phi_{i,j}) - \\varepsilon_{i-1/2, j} (\\phi_{i,j} - \\phi_{i-1,j}) \\right] + \\frac{1}{\\Delta y^2} \\left[ \\varepsilon_{i, j+1/2} (\\phi_{i,j+1} - \\phi_{i,j}) - \\varepsilon_{i, j-1/2} (\\phi_{i,j} - \\phi_{i,j-1}) \\right] = 0\n$$\n例如，此处的 $\\varepsilon_{i+1/2, j} = \\varepsilon(x_i + \\Delta x/2, y_j)$。\n\n边界条件按如下方式并入：\n- **狄利克雷边界：** 在底板（$j=0$），$\\phi_{i,0} = V_0$。在顶板（$j=N_y$），$\\phi_{i,N_y} = 0$。这些值是已知的，不属于未知数系统。它们为其相邻节点贡献了线性系统中的常数向量。\n- **诺伊曼边界：** 在 $x=0$ 和 $x=W$ 处的绝缘条件 $\\partial \\phi/\\partial x = 0$ 通过“虚拟点”法实现。对于左边界（$i=0$），引入一个位于 $i=-1$ 的虚拟点，使得 $\\phi_{-1,j} = \\phi_{1,j}$。这修改了 $i=0$ 处节点的有限差分格式。对于右边界（$i=N_x$）处的节点也进行类似修改。\n\n这种离散化将连续的偏微分方程转换为一个线性代数方程组 $M\\mathbf{\\Phi} = \\mathbf{b}$，其中 $\\mathbf{\\Phi}$ 是包含所有未知电势值 $\\phi_{i,j}$ 的向量，其中 $i \\in \\{0, \\dots, N_x\\}$ 且 $j \\in \\{1, \\dots, N_y-1\\}$。矩阵 $M$ 是一个大型、稀疏且对角占优的矩阵，这使得可以使用迭代求解器或稀疏直接求解器进行高效求解。\n\n一旦计算出电势场 $\\phi$，单位深度的电容 $C'$ 就由底电极上单位深度的自由电荷 $Q'$ 确定。\n$$\nQ' = -\\int_{0}^{W} \\varepsilon(x,0^+)\\,\\frac{\\partial \\phi}{\\partial y}(x,0^+)\\,dx\n$$\n这将进行数值计算。积分使用梯形法则在 $y=0$ 处的网格点上近似。边界 $y=0$ 处的导数 $\\partial \\phi/\\partial y$ 使用二阶精度的单边有限差分公式进行近似，这需要 $y$ 方向上前三层网格点（$j=0,1,2$）的电势值：\n$$\n\\frac{\\partial \\phi}{\\partial y}(x_i, 0^+) \\approx \\frac{-\\phi_{i,2} + 4\\phi_{i,1} - 3\\phi_{i,0}}{2\\Delta y}\n$$\n最后，电容计算为 $C' = Q' / V_0$。\n\n实现将使用 $N_x=150$ 和 $N_y=150$ 的网格分辨率，这在精度和计算成本之间提供了一个很好的折衷。使用 `scipy.sparse` 库来构建稀疏矩阵 $M$，并使用 `scipy.sparse.linalg.spsolve` 来求解线性系统。",
            "answer": "```python\nimport numpy as np\nfrom scipy.sparse import lil_matrix, csc_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Solves the 2D electrostatic BVP for a capacitor with a curved dielectric interface\n    and computes the capacitance per unit depth for several test cases.\n    \"\"\"\n    # Physical and geometrical constants\n    EPS0 = 8.854187817e-12  # Vacuum permittivity in F/m\n    W = 0.1  # Width in m\n    H = 0.1  # Height in m\n    V0 = 1.0  # Potential at the bottom plate in V\n\n    # Numerical grid parameters\n    Nx = 150  # Number of intervals in x-direction\n    Ny = 150  # Number of intervals in y-direction\n\n    # Test cases from the problem statement\n    test_cases = [\n        # (kappa1, kappa2, A)\n        (3.0, 3.0, 0.0),\n        (2.0, 5.0, 0.0),\n        (2.0, 5.0, 0.02 * W),\n        (1.0, 10.0, 0.02 * W),\n    ]\n\n    results = []\n\n    for kappa1, kappa2, A in test_cases:\n        # 1. Setup Grid\n        dx = W / Nx\n        dy = H / Ny\n        \n        # Grid node coordinates\n        x_coords = np.linspace(0, W, Nx + 1)\n        y_coords = np.linspace(0, H, Ny + 1)\n        \n        # 2. Define Permittivity Function\n        # This function will be evaluated at mid-grid points during matrix assembly.\n        def get_epsilon(x, y):\n            x_gamma = W / 2 + A * np.cos(2 * np.pi * y / H)\n            if x  x_gamma:\n                return EPS0 * kappa1\n            else:\n                return EPS0 * kappa2\n\n        # 3. Assemble the Linear System M*phi = b\n        # Unknowns are phi at interior nodes, including Neumann boundaries.\n        # Nodes at y=0 and y=H are known (Dirichlet).\n        num_unknowns = (Nx + 1) * (Ny - 1)\n        M = lil_matrix((num_unknowns, num_unknowns))\n        b = np.zeros(num_unknowns)\n\n        # Iterate over grid points corresponding to unknowns\n        # j runs from 1 to Ny-1, covering rows y=dy, ..., y=H-dy.\n        # i runs from 0 to Nx, covering columns x=0, ..., x=W.\n        for j in range(1, Ny):\n            for i in range(0, Nx + 1):\n                # Map 2D grid index (i,j) to 1D vector index k\n                k = i + (j - 1) * (Nx + 1)\n                \n                # Get permittivity at mid-grid points around (i,j)\n                eps_y_p = get_epsilon(x_coords[i], y_coords[j] + dy / 2)\n                eps_y_m = get_epsilon(x_coords[i], y_coords[j] - dy / 2)\n                \n                if i > 0:\n                    eps_x_m = get_epsilon(x_coords[i] - dx / 2, y_coords[j])\n                if i  Nx:\n                    eps_x_p = get_epsilon(x_coords[i] + dx / 2, y_coords[j])\n\n                # Assemble coefficients for the FDM equation at node (i,j)\n                # Diagonal contribution from y-derivatives\n                M[k, k] = (eps_y_p + eps_y_m) / dy**2\n                \n                # Off-diagonal y-neighbors\n                if j  Ny - 1: # Upper neighbor (phi_{i, j+1}) is an unknown\n                    k_up = i + j * (Nx + 1)\n                    M[k, k_up] = -eps_y_p / dy**2\n                # Lower neighbor (phi_{i, j-1})\n                if j > 1: # Lower neighbor is an unknown\n                    k_down = i + (j - 2) * (Nx + 1)\n                    M[k, k_down] = -eps_y_m / dy**2\n                else: # j=1, lower neighbor is on the Dirichlet boundary (y=0)\n                    b[k] += (eps_y_m / dy**2) * V0\n\n                # Add contributions from x-derivatives based on boundary type\n                if i == 0:  # Left Neumann boundary (x=0)\n                    M[k, k] += (2 * eps_x_p) / dx**2\n                    M[k, k + 1] = (-2 * eps_x_p) / dx**2\n                elif i == Nx:  # Right Neumann boundary (x=W)\n                    M[k, k] += (2 * eps_x_m) / dx**2\n                    M[k, k - 1] = (-2 * eps_x_m) / dx**2\n                else:  # Interior point in x\n                    M[k, k] += (eps_x_p + eps_x_m) / dx**2\n                    M[k, k + 1] = -eps_x_p / dx**2\n                    M[k, k - 1] = -eps_x_m / dx**2\n\n        # 4. Solve the sparse linear system\n        M_csc = csc_matrix(M)\n        phi_vec = spsolve(M_csc, b)\n\n        # 5. Reconstruct the 2D potential field from the solution vector\n        phi = np.zeros((Nx + 1, Ny + 1))\n        phi[:, 0] = V0   # Bottom plate\n        phi[:, Ny] = 0.0  # Top plate\n        # Un-flatten the solution vector into the grid of unknowns\n        phi[:, 1:Ny] = phi_vec.reshape((Ny - 1, Nx + 1)).T\n        \n        # 6. Calculate Capacitance per unit depth\n        # Use a 2nd-order accurate one-sided FD for the derivative d(phi)/dy at y=0\n        dphi_dy_at_y0 = (-phi[:, 2] + 4 * phi[:, 1] - 3 * phi[:, 0]) / (2 * dy)\n\n        # Evaluate permittivity along the bottom plate (y=0)\n        eps_at_y0 = np.array([get_epsilon(x, 0.0) for x in x_coords])\n        \n        # Numerically integrate to find charge Q'\n        integrand = eps_at_y0 * dphi_dy_at_y0\n        Q_prime = -np.trapz(integrand, x=x_coords)\n        \n        # Compute capacitance C'\n        C_prime = Q_prime / V0\n        \n        results.append(C_prime)\n    \n    # 7. Format and print the final output as specified\n    print(f\"[{','.join([f'{r:.8e}' for r in results])}]\")\n\nsolve()\n```"
        }
    ]
}