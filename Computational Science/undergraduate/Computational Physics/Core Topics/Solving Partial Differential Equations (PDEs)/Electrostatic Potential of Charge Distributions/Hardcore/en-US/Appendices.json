{
    "hands_on_practices": [
        {
            "introduction": "This first exercise provides a practical application of one of the most elegant concepts in electrostatics: the relationship between the electric field $\\vec{E}$, work $W$, and the scalar potential $V$. While the work required to move a charge can be found by directly integrating the force along a path, the conservative nature of the electrostatic field allows for a much simpler method using potential differences. This practice challenges you to implement the more efficient potential-based approach, reinforcing the fundamental idea that $W = q(V_A - V_B)$ and highlighting why the scalar potential is such a powerful tool in physics. ",
            "id": "2388108",
            "problem": "A point-like test charge with magnitude $q_{\\mathrm{test}}$ moves along specified paths within the electric field generated by fixed point charges in vacuum. The electric field $\\vec{E}(\\vec{r})$ is due to $N$ stationary point charges $\\{q_i\\}_{i=1}^N$ located at positions $\\{\\vec{r}_i\\}_{i=1}^N$. The work required to move the test charge from point $A$ to point $B$ along a path $\\mathcal{C}$ is defined by\n$$\nW = q_{\\mathrm{test}} \\int_{\\mathcal{C}} \\vec{E}(\\vec{r}) \\cdot d\\vec{l}.\n$$\nThe electric field is given by Coulomb's law,\n$$\n\\vec{E}(\\vec{r}) = \\frac{1}{4\\pi \\varepsilon_0} \\sum_{i=1}^N q_i \\frac{\\vec{r} - \\vec{r}_i}{\\lVert \\vec{r} - \\vec{r}_i \\rVert^3},\n$$\nwhere $\\varepsilon_0$ is the vacuum permittivity.\n\nAll quantities must be expressed in the International System of Units (SI). Use $\\varepsilon_0 = 8.8541878128\\times 10^{-12}\\ \\mathrm{F/m}$ and positions in meters. The computed work values must be expressed in joules.\n\nFixed source charges:\n- $q_1 = +2.0\\times 10^{-6}\\ \\mathrm{C}$ at $\\vec{r}_1 = (0.00, 0.00, 0.00)\\ \\mathrm{m}$.\n- $q_2 = -1.0\\times 10^{-6}\\ \\mathrm{C}$ at $\\vec{r}_2 = (0.10, 0.00, 0.00)\\ \\mathrm{m}$.\n- $q_3 = +5.0\\times 10^{-7}\\ \\mathrm{C}$ at $\\vec{r}_3 = (0.05, 0.06, 0.00)\\ \\mathrm{m}$.\n\nTest charge:\n- $q_{\\mathrm{test}} = +1.0\\times 10^{-9}\\ \\mathrm{C}$.\n\nAssume three-dimensional Cartesian coordinates $(x,y,z)$; all listed points lie in the plane $z=0$.\n\nCompute the work $W$ for each of the following independent test paths. For any piecewise-defined path, the integral is taken along each segment in order and summed. Paths are guaranteed not to pass through any source charge location.\n\nTest suite (angles must be interpreted in radians; distances in meters; work reported in joules):\n1. Straight line from $A=(0.02,\\,0.01,\\,0.00)$ to $B=(0.08,\\,0.01,\\,0.00)$.\n2. Two-segment polyline from $A=(0.03,\\,0.03,\\,0.00)$ to $M=(0.06,\\,0.07,\\,0.00)$ to $B=(0.09,\\,0.04,\\,0.00)$, in that order.\n3. Closed rectangular loop with vertices $P_0=(0.07,\\,0.02,\\,0.00)\\to P_1=(0.09,\\,0.02,\\,0.00)\\to P_2=(0.09,\\,0.05,\\,0.00)\\to P_3=(0.07,\\,0.05,\\,0.00)\\to P_0$, traversed in the listed order.\n4. Degenerate path from $A=(0.04,\\,0.04,\\,0.00)$ to the same point $B=(0.04,\\,0.04,\\,0.00)$.\n5. Circular arc centered at $C=(0.02,\\,0.02,\\,0.00)$ with radius $R=0.02$, starting at polar angle $\\theta_0=0$ and ending at $\\theta_1=\\frac{\\pi}{2}$, i.e., the path is $\\vec{r}(\\theta)=C + (R\\cos\\theta,\\,R\\sin\\theta,\\,0)$ for $\\theta\\in[0,\\,\\frac{\\pi}{2}]$.\n\nYour program must compute the five work values in the order listed and produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in joules, with each number formatted in scientific notation with exactly $10$ significant digits (for example, $[\\text{val}_1,\\text{val}_2,\\text{val}_3,\\text{val}_4,\\text{val}_5]$).",
            "solution": "The problem as stated is subjected to validation.\n\n**Step 1: Extracted Givens**\n- **Constants:** Vacuum permittivity $\\varepsilon_0 = 8.8541878128\\times 10^{-12}\\ \\mathrm{F/m}$.\n- **Formulations:**\n    - Work: $W = q_{\\mathrm{test}} \\int_{\\mathcal{C}} \\vec{E}(\\vec{r}) \\cdot d\\vec{l}$.\n    - Electric Field: $\\vec{E}(\\vec{r}) = \\frac{1}{4\\pi \\varepsilon_0} \\sum_{i=1}^N q_i \\frac{\\vec{r} - \\vec{r}_i}{\\lVert \\vec{r} - \\vec{r}_i \\rVert^3}$.\n- **Source Charges:**\n    - $q_1 = +2.0\\times 10^{-6}\\ \\mathrm{C}$ at $\\vec{r}_1 = (0.00, 0.00, 0.00)\\ \\mathrm{m}$.\n    - $q_2 = -1.0\\times 10^{-6}\\ \\mathrm{C}$ at $\\vec{r}_2 = (0.10, 0.00, 0.00)\\ \\mathrm{m}$.\n    - $q_3 = +5.0\\times 10^{-7}\\ \\mathrm{C}$ at $\\vec{r}_3 = (0.05, 0.06, 0.00)\\ \\mathrm{m}$.\n- **Test Charge:** $q_{\\mathrm{test}} = +1.0\\times 10^{-9}\\ \\mathrm{C}$.\n- **Paths:**\n    1.  Straight line from $A=(0.02,\\,0.01,\\,0.00)$ to $B=(0.08,\\,0.01,\\,0.00)$.\n    2.  Polyline from $A=(0.03,\\,0.03,\\,0.00)$ to $M=(0.06,\\,0.07,\\,0.00)$ to $B=(0.09,\\,0.04,\\,0.00)$.\n    3.  Closed rectangular loop $P_0=(0.07,\\,0.02,\\,0.00)\\to P_1\\to P_2\\to P_3\\to P_0$.\n    4.  Degenerate path from $A=(0.04,\\,0.04,\\,0.00)$ to $B=(0.04,\\,0.04,\\,0.00)$.\n    5.  Circular arc, center $C=(0.02,\\,0.02,\\,0.00)$, radius $R=0.02$, from $\\theta=0$ to $\\theta=\\frac{\\pi}{2}$.\n\n**Step 2: Validation**\nThe problem is scientifically grounded in classical electrostatics. The provided equations for work and the electric field are standard. All necessary parameters—charges, positions, constants, and paths—are specified clearly and consistently. There are no contradictions, ambiguities, or violations of physical principles. The problem is well-posed and has a unique, meaningful solution.\n\n**Step 3: Verdict**\nThe problem is valid.\n\n**Solution Derivation**\nThe problem requires the computation of work done on a test charge moving in a static electric field. A fundamental property of the electrostatic field is that it is conservative. This is because the electric field from a static distribution of charges can be expressed as the negative gradient of a scalar potential, $\\vec{E} = -\\vec{\\nabla}V$. Consequently, the work done in moving a charge from point $\\vec{r}_A$ to point $\\vec{r}_B$ is path-independent and is given by the change in potential energy:\n$$\nW_{A \\to B} = q_{\\mathrm{test}} \\int_{\\vec{r}_A}^{\\vec{r}_B} \\vec{E} \\cdot d\\vec{l} = -q_{\\mathrm{test}} \\int_{\\vec{r}_A}^{\\vec{r}_B} (\\vec{\\nabla}V) \\cdot d\\vec{l} = -q_{\\mathrm{test}} (V(\\vec{r}_B) - V(\\vec{r}_A)) = q_{\\mathrm{test}} (V(\\vec{r}_A) - V(\\vec{r}_B))\n$$\nThis relation obviates the need for explicit path integration. The problem reduces to calculating the electric potential $V$ at the start and end points of each path.\n\nThe electric potential $V(\\vec{r})$ at a position $\\vec{r}$ due to a set of $N$ point charges $\\{q_i\\}$ at positions $\\{\\vec{r}_i\\}$ is given by:\n$$\nV(\\vec{r}) = \\frac{1}{4\\pi \\varepsilon_0} \\sum_{i=1}^N \\frac{q_i}{\\lVert \\vec{r} - \\vec{r}_i \\rVert}\n$$\nLet's denote the Coulomb constant as $k_e = \\frac{1}{4\\pi \\varepsilon_0}$. Given $\\varepsilon_0 = 8.8541878128 \\times 10^{-12}\\ \\mathrm{F/m}$, we have $k_e \\approx 8.987551787 \\times 10^9\\ \\mathrm{N \\cdot m^2 / C^2}$.\n\nThe computational procedure is as follows:\n1.  Define a function to compute the potential $V(\\vec{r})$ at an arbitrary point $\\vec{r}=(x,y,z)$ based on the given three source charges.\n2.  For each test case, identify the start point $\\vec{r}_A$ and end point $\\vec{r}_B$.\n3.  Calculate the work as $W = q_{\\mathrm{test}} (V(\\vec{r}_A) - V(\\vec{r}_B))$.\n\n**Analysis of Test Paths:**\n\n**Path 1: Straight line**\n- Start point: $\\vec{r}_A = (0.02, 0.01, 0.00)\\ \\mathrm{m}$.\n- End point: $\\vec{r}_B = (0.08, 0.01, 0.00)\\ \\mathrm{m}$.\n- The work is $W_1 = q_{\\mathrm{test}} (V(\\vec{r}_A) - V(\\vec{r}_B))$.\n\n**Path 2: Two-segment polyline**\n- Start point: $\\vec{r}_A = (0.03, 0.03, 0.00)\\ \\mathrm{m}$.\n- End point: $\\vec{r}_B = (0.09, 0.04, 0.00)\\ \\mathrm{m}$.\n- The intermediate point $M$ is irrelevant due to the conservative nature of the field. The work depends only on the endpoints.\n- The work is $W_2 = q_{\\mathrm{test}} (V(\\vec{r}_A) - V(\\vec{r}_B))$.\n\n**Path 3: Closed rectangular loop**\n- The path is closed, meaning the start point and end point are identical: $\\vec{r}_A = \\vec{r}_B = P_0 = (0.07, 0.02, 0.00)\\ \\mathrm{m}$.\n- The line integral of a conservative field over any closed loop is zero.\n- Thus, $V(\\vec{r}_A) - V(\\vec{r}_B) = 0$, and the work is $W_3 = 0\\ \\mathrm{J}$.\n\n**Path 4: Degenerate path**\n- The start and end points are the same: $\\vec{r}_A = \\vec{r}_B = (0.04, 0.04, 0.00)\\ \\mathrm{m}$.\n- This is a trivial closed path.\n- The work is $W_4 = 0\\ \\mathrm{J}$.\n\n**Path 5: Circular arc**\n- The path is parameterized by $\\vec{r}(\\theta) = (0.02, 0.02, 0) + (0.02\\cos\\theta, 0.02\\sin\\theta, 0)$.\n- Start point ($ \\theta=0 $): $\\vec{r}_A = (0.02+0.02\\cos(0), 0.02+0.02\\sin(0), 0) = (0.04, 0.02, 0.00)\\ \\mathrm{m}$.\n- End point ($ \\theta=\\frac{\\pi}{2} $): $\\vec{r}_B = (0.02+0.02\\cos(\\frac{\\pi}{2}), 0.02+0.02\\sin(\\frac{\\pi}{2}), 0) = (0.02, 0.04, 0.00)\\ \\mathrm{m}$.\n- The work is $W_5 = q_{\\mathrm{test}} (V(\\vec{r}_A) - V(\\vec{r}_B))$.\n\nThe implementation will create a function for $V(\\vec{r})$ and apply it to the endpoints of each path to determine the work. The brute-force numerical integration of $\\vec{E} \\cdot d\\vec{l}$ is inefficient, numerically less stable, and demonstrates a poor understanding of fundamental electrostatic principles. The potential-based method is superior in all aspects.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the work done moving a test charge along various paths in an electrostatic field.\n    The solution leverages the conservative nature of the electrostatic field, calculating work\n    from the difference in electric potential between the start and end points of each path.\n    \"\"\"\n    # Define physical constants and problem parameters in SI units.\n    EPSILON_0 = 8.8541878128e-12  # Vacuum permittivity (F/m)\n    K_E = 1.0 / (4.0 * np.pi * EPSILON_0)  # Coulomb's constant (N*m^2/C^2)\n\n    # Source charges {q_i} and their positions {r_i}\n    SOURCE_CHARGES = np.array([\n        2.0e-6,   # q1 in Coulombs\n        -1.0e-6,  # q2 in Coulombs\n        5.0e-7    # q3 in Coulombs\n    ])\n    \n    SOURCE_POSITIONS = np.array([\n        [0.00, 0.00, 0.00],  # r1 in meters\n        [0.10, 0.00, 0.00],  # r2 in meters\n        [0.05, 0.06, 0.00]   # r3 in meters\n    ])\n\n    # Test charge\n    Q_TEST = 1.0e-9  # in Coulombs\n\n    def calculate_potential(point):\n        \"\"\"\n        Calculates the total electric potential at a given point in space.\n        \n        Args:\n            point (np.ndarray): A 3D vector representing the position (x, y, z).\n            \n        Returns:\n            float: The electric potential in Volts.\n        \"\"\"\n        point = np.array(point)\n        # Calculate distances from the point to each source charge\n        distances = np.linalg.norm(SOURCE_POSITIONS - point, axis=1)\n        \n        # Calculate potential from each charge: V_i = q_i / r_i\n        potentials = SOURCE_CHARGES / distances\n        \n        # Sum potentials and multiply by Coulomb's constant\n        total_potential = K_E * np.sum(potentials)\n        return total_potential\n\n    # Define the start and end points for each test case.\n    test_cases = [\n        # Case 1: Straight line\n        {'start': (0.02, 0.01, 0.00), 'end': (0.08, 0.01, 0.00)},\n        \n        # Case 2: Polyline (only endpoints matter)\n        {'start': (0.03, 0.03, 0.00), 'end': (0.09, 0.04, 0.00)},\n        \n        # Case 3: Closed rectangular loop (Work is zero)\n        {'start': (0.07, 0.02, 0.00), 'end': (0.07, 0.02, 0.00)},\n        \n        # Case 4: Degenerate path (Work is zero)\n        {'start': (0.04, 0.04, 0.00), 'end': (0.04, 0.04, 0.00)},\n        \n        # Case 5: Circular arc\n        {\n            'start': (0.02 + 0.02 * np.cos(0), 0.02 + 0.02 * np.sin(0), 0.00),\n            'end': (0.02 + 0.02 * np.cos(np.pi / 2), 0.02 + 0.02 * np.sin(np.pi / 2), 0.00)\n        }\n    ]\n\n    results = []\n    for i, case in enumerate(test_cases):\n        # For closed loops, work is analytically zero.\n        if i == 2 or i == 3:\n            work = 0.0\n        else:\n            potential_start = calculate_potential(case['start'])\n            potential_end = calculate_potential(case['end'])\n            work = Q_TEST * (potential_start - potential_end)\n        results.append(work)\n\n    # Format the results as specified: scientific notation with 10 significant digits.\n    formatted_results = [f\"{res:.9e}\" for res in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Moving beyond simple, fixed arrangements of charges, this exercise introduces a method for creating complex charge distributions using a stochastic process. You will generate a system of charges using a three-dimensional random walk and then compute the resulting electrostatic potential via direct superposition. This practice introduces two crucial techniques from large-scale scientific simulation: procedural generation of a physical system and the use of a softening parameter $\\eta$ to regularize the potential, preventing the singularities associated with true point charges. ",
            "id": "2388140",
            "problem": "You are tasked with designing and implementing a complete numerical experiment that constructs a charge distribution from a three-dimensional random walk and then computes the resulting electrostatic potential at specified observation points. The experiment must be fully reproducible and numerically stable.\n\nConstruct a sequence of point charges by the following procedure, starting from a fundamental base. Begin with the physical definition that the electrostatic potential at a position $\\mathbf{r}$ due to static point charges is determined by superposition. In this task, build a discrete charge distribution from a three-dimensional random walk: start at the origin and take $N$ steps of fixed length $a$ in independently and identically distributed directions that are isotropically distributed on the unit sphere. Place one point charge at the position reached after each step. Assign equal charge to each point so that the total charge across all points is unity. Use dimensionless units in which the Coulomb constant equals one. Because point charges induce a singular contribution to the potential at zero separation, you must regularize the calculation by introducing a strictly positive softening length $\\eta$; choose the simplest isotropic regularization consistent with Euclidean distance. Use a pseudo-random number generator with the provided integer seeds to ensure reproducibility.\n\nYour program must:\n- Generate the walk positions $\\{\\mathbf{r}_i\\}_{i=1}^{N}$ in $\\mathbb{R}^3$ with fixed step length $a$, starting from $\\mathbf{r}_0=\\mathbf{0}$.\n- Assign equal charges $q_i$ so that $\\sum_{i=1}^{N} q_i = 1$.\n- Compute the electrostatic potential at each specified observation point using only superposition, the definition of a point charge’s contribution to potential, and the chosen regularization. Use the isotropic softening specified by the parameter $\\eta>0$.\n- Use dimensionless units with total charge equal to $1$.\n- Use the specified seeds for the pseudo-random number generator to keep each test case deterministic.\n\nTest suite. Your program must apply the above to the following parameter sets and return the required values:\n- Case A (general “happy path”): seed $314159$, $N=200$, $a=0.5$, $\\eta=0.05$, observation points $\\mathbf{r}^{(A)}_{\\text{obs}} \\in \\{(0,0,0),(1,1,1),(2,0,-1)\\}$.\n- Case B (boundary with a single charge): seed $7$, $N=1$, $a=1.0$, $\\eta=0.01$, observation points $\\mathbf{r}^{(B)}_{\\text{obs}} \\in \\{(0,0,0),(0.1,0,0),(10,0,0)\\}$.\n- Case C (degenerate walk with zero step size): seed $99$, $N=50$, $a=0.0$, $\\eta=0.1$, observation points $\\mathbf{r}^{(C)}_{\\text{obs}} \\in \\{(0,0,0),(10^{-6},0,0),(1,0,0)\\}$.\n\nFor each case, compute the electrostatic potential at each of the three observation points and return them as floating-point numbers rounded to $6$ decimal places. Aggregate the results across cases in order A, B, C.\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated list of lists with no spaces, where each inner list corresponds to one case in the order A, B, C and contains the three rounded floating-point values in the same order as each case’s observation points. For example, the printed line must look like:\n[[v11,v12,v13],[v21,v22,v23],[v31,v32,v33]]\nwhere each $v_{ij}$ is a floating-point number rounded to $6$ decimal places. No other text may be printed.",
            "solution": "The problem statement has been analyzed and is deemed valid. It is scientifically grounded in the principles of electrostatics and computational physics, well-posed with all necessary parameters defined, and objective in its formulation. We will now proceed with the solution.\n\nThe task is to compute the electrostatic potential at specified observation points, arising from a charge distribution generated by a three-dimensional random walk. The solution is constructed methodically based on fundamental principles.\n\nFirst, we address the generation of the charge positions. A random walk of $N$ steps starting from the origin $\\mathbf{r}_0 = \\mathbf{0}$ is constructed. The position after the $i$-th step, $\\mathbf{r}_i$, is determined by the previous position $\\mathbf{r}_{i-1}$ and a step vector of fixed length $a$ in an isotropic random direction:\n$$\n\\mathbf{r}_i = \\mathbf{r}_{i-1} + a \\cdot \\mathbf{u}_i, \\quad i \\in \\{1, 2, \\dots, N\\}\n$$\nwhere $\\mathbf{u}_i$ is a unit vector sampled uniformly from the surface of a three-dimensional sphere, $\\mathbf{u}_i \\in S^2 \\subset \\mathbb{R}^3$. A robust method to generate such a vector is to draw three independent random variates $(z_1, z_2, z_3)$ from the standard normal distribution $\\mathcal{N}(0,1)$, form a vector $\\mathbf{v} = (z_1, z_2, z_3)$, and normalize it:\n$$\n\\mathbf{u}_i = \\frac{\\mathbf{v}}{||\\mathbf{v}||_2}\n$$\nThis procedure guarantees an isotropic distribution. The set of $N$ point charges is placed at the positions $\\{\\mathbf{r}_i\\}_{i=1}^{N}$.\nThe problem specifies that the random number generator must be seeded to ensure reproducibility.\n\nSecond, we consider the charge values and the principle of superposition. The total charge of the system is stipulated to be unity. This total charge is distributed equally among the $N$ point charges. Therefore, the value of each individual charge $q_i$ is:\n$$\nq_i = \\frac{1}{N} \\quad \\forall i \\in \\{1, 2, \\dots, N\\}\n$$\nAccording to the principle of superposition in electrostatics, the total potential $V$ at an observation point $\\mathbf{r}_{\\text{obs}}$ is the algebraic sum of the potentials $V_i$ created by each point charge independently:\n$$\nV(\\mathbf{r}_{\\text{obs}}) = \\sum_{i=1}^{N} V_i(\\mathbf{r}_{\\text{obs}})\n$$\n\nThird, we define the potential of a single point charge, incorporating the required regularization. The electrostatic potential in dimensionless units where the Coulomb constant is $k=1$ is given by $q/d$, where $d$ is the distance from the charge. This expression is singular as $d \\to 0$. To prevent numerical instability, a softening parameter $\\eta > 0$ is introduced. The problem requests the \"simplest isotropic regularization consistent with Euclidean distance.\" This is achieved by replacing the distance $d = ||\\mathbf{r}_{\\text{obs}} - \\mathbf{r}_i||_2$ with a regularized distance $\\sqrt{d^2 + \\eta^2}$. The potential contributed by a single charge $q_i$ at position $\\mathbf{r}_i$ is therefore:\n$$\nV_i(\\mathbf{r}_{\\text{obs}}) = \\frac{q_i}{\\sqrt{||\\mathbf{r}_{\\text{obs}} - \\mathbf{r}_i||_2^2 + \\eta^2}}\n$$\n\nCombining these principles, the complete expression for the total electrostatic potential at an observation point $\\mathbf{r}_{\\text{obs}}$ is:\n$$\nV(\\mathbf{r}_{\\text{obs}}) = \\sum_{i=1}^{N} \\frac{1/N}{\\sqrt{||\\mathbf{r}_{\\text{obs}} - \\mathbf{r}_i||_2^2 + \\eta^2}}\n$$\nThis formula is computationally implemented for each test case.\n\nThe algorithm is as follows:\n$1$. For each test case, retrieve the parameters: seed, $N$, $a$, $\\eta$, and the set of observation points $\\{\\mathbf{r}_{\\text{obs}}\\}$.\n$2$. Initialize a pseudo-random number generator with the given seed.\n$3$. Initialize the walk position $\\mathbf{r}_{\\text{current}} = (0, 0, 0)$.\n$4$. Create a list to store the $N$ charge positions.\n$5$. Iterate $N$ times:\n    a. Generate a random unit vector $\\mathbf{u}$ as described above.\n    b. Update the current position: $\\mathbf{r}_{\\text{current}} \\leftarrow \\mathbf{r}_{\\text{current}} + a \\cdot \\mathbf{u}$.\n    c. Store the new $\\mathbf{r}_{\\text{current}}$ in the list of charge positions.\n$6$. For each given observation point $\\mathbf{r}_{\\text{obs}}$:\n    a. Initialize total potential $V_{\\text{total}} = 0$.\n    b. For each charge position $\\mathbf{r}_i$ in the generated list:\n        i. Compute the squared Euclidean distance: $d^2 = ||\\mathbf{r}_{\\text{obs}} - \\mathbf{r}_i||_2^2$.\n        ii. Calculate the regularized potential contribution: $V_i = \\frac{1/N}{\\sqrt{d^2 + \\eta^2}}$.\n        iii. Accumulate the potential: $V_{\\text{total}} \\leftarrow V_{\\text{total}} + V_i$.\n    c. Round the computed $V_{\\text{total}}$ to $6$ decimal places and store it.\n$7$. Collect the lists of results from all test cases and format them into the specified final output string.\n\nA special case is Case C, where the step length $a=0$. Here, the random walk does not move from the origin. All $N$ charges are collocated at $\\mathbf{r}_i = \\mathbf{0}$. The system acts as a single point charge of magnitude $\\sum q_i = 1$ at the origin. The potential simplifies to:\n$$\nV(\\mathbf{r}_{\\text{obs}}) = \\frac{1}{\\sqrt{||\\mathbf{r}_{\\text{obs}}||_2^2 + \\eta^2}}\n$$\nThis provides a valuable analytical check for the numerical implementation.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the computational physics problem by generating charge distributions\n    from 3D random walks and calculating the electrostatic potential at specified points.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"name\": \"Case A\",\n            \"seed\": 314159,\n            \"N\": 200,\n            \"a\": 0.5,\n            \"eta\": 0.05,\n            \"obs_points\": [(0, 0, 0), (1, 1, 1), (2, 0, -1)],\n        },\n        {\n            \"name\": \"Case B\",\n            \"seed\": 7,\n            \"N\": 1,\n            \"a\": 1.0,\n            \"eta\": 0.01,\n            \"obs_points\": [(0, 0, 0), (0.1, 0, 0), (10, 0, 0)],\n        },\n        {\n            \"name\": \"Case C\",\n            \"seed\": 99,\n            \"N\": 50,\n            \"a\": 0.0,\n            \"eta\": 0.1,\n            \"obs_points\": [(0, 0, 0), (1e-6, 0, 0), (1, 0, 0)],\n        },\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        seed = case[\"seed\"]\n        N = case[\"N\"]\n        a = case[\"a\"]\n        eta = case[\"eta\"]\n        obs_points = np.array(case[\"obs_points\"])\n\n        # Initialize the pseudo-random number generator for reproducibility\n        rng = np.random.default_rng(seed)\n\n        # Generate the charge positions from the 3D random walk\n        charge_positions = np.zeros((N, 3))\n        current_pos = np.zeros(3)\n        \n        # Handle the N=0 case gracefully, although not in test suite.\n        if N > 0:\n            for i in range(N):\n                # Generate an isotropic random direction vector\n                rand_vec = rng.standard_normal(3)\n                norm = np.linalg.norm(rand_vec)\n                \n                # A norm of zero is statistically impossible but good practice to handle.\n                if norm == 0:\n                    # Default to an arbitrary axis if the unlikely happens.\n                    unit_vec = np.array([1.0, 0.0, 0.0])\n                else:\n                    unit_vec = rand_vec / norm\n\n                # Take a step and update position\n                current_pos += a * unit_vec\n                charge_positions[i] = current_pos\n\n        case_results = []\n        for obs_point in obs_points:\n            if N == 0:\n                total_potential = 0.0\n            else:\n                # Calculate the potential using vectorized operations\n                # Charge of each point is 1/N\n                q = 1.0 / N\n\n                # Calculate squared distances from the observation point to all charges\n                diffs = charge_positions - obs_point\n                sq_dists = np.sum(diffs**2, axis=1)\n\n                # Calculate potential from each charge and sum them up (superposition)\n                # V = sum(q / sqrt(d^2 + eta^2))\n                potentials = q / np.sqrt(sq_dists + eta**2)\n                total_potential = np.sum(potentials)\n            \n            # Round the result to 6 decimal places\n            case_results.append(round(total_potential, 6))\n        \n        all_results.append(case_results)\n\n    # Format the final output string exactly as required, with no spaces.\n    output_str = str(all_results).replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "This final practice advances from discrete charges to continuous media, tackling a realistic engineering problem: calculating the capacitance of a device with a complex internal structure. You will solve for the electrostatic potential $\\phi$ within a capacitor containing two different dielectric materials separated by a curved interface. The governing equation is the generalized form of Gauss's law, $\\nabla \\cdot (\\varepsilon \\nabla \\phi) = 0$, a partial differential equation that you will solve numerically using the Finite Difference Method. This comprehensive exercise will guide you through the process of discretizing a domain, implementing boundary conditions, solving a large linear system, and post-processing the results to extract a physical quantity. ",
            "id": "2388116",
            "problem": "Consider a two-dimensional, parallel-plate capacitor occupying the rectangular domain $\\Omega = \\{(x,y)\\mid 0 \\le x \\le W,\\; 0 \\le y \\le H\\}$, invariant in the out-of-plane direction (per-unit-depth analysis). The lower plate at $y=0$ is held at electric potential $\\phi(x,0) = V_0$ and the upper plate at $y=H$ is held at $\\phi(x,H) = 0$. The left and right boundaries at $x=0$ and $x=W$ are electrically insulating, that is, $\\partial \\phi/\\partial x(0,y)=0$ and $\\partial \\phi/\\partial x(W,y)=0$ for all $y\\in[0,H]$. The interior is filled by two linear, isotropic dielectric materials with spatially varying permittivity $\\varepsilon(x,y)$ defined by a curved material interface. The electrostatic potential $\\phi(x,y)$ satisfies the divergence-form, source-free Gauss law for electrostatics:\n$$\n\\nabla \\cdot \\left(\\varepsilon(x,y)\\,\\nabla \\phi(x,y)\\right) = 0 \\quad \\text{in } \\Omega,\n$$\nwith the boundary conditions stated above.\n\nLet the interface between the two materials be given by the curve\n$$\nx = x_\\Gamma(y) = \\frac{W}{2} + A \\cos\\!\\left(\\frac{2\\pi y}{H}\\right),\n$$\nso that\n$$\n\\varepsilon(x,y) = \\begin{cases}\n\\varepsilon_0\\,\\kappa_1, & \\text{if } x < x_\\Gamma(y)\\\\\n\\varepsilon_0\\,\\kappa_2, & \\text{if } x \\ge x_\\Gamma(y),\n\\end{cases}\n$$\nwhere $\\varepsilon_0$ is the vacuum permittivity and $\\kappa_1,\\kappa_2$ are the relative permittivities (dimensionless) of the two materials.\n\nDefine the capacitance per unit out-of-plane depth $C'$ via the ratio $C' = Q'/V_0$, where the free charge per unit depth on the lower electrode is\n$$\nQ' = -\\int_{0}^{W} \\varepsilon\\!\\left(x,0^+\\right)\\,\\frac{\\partial \\phi}{\\partial y}(x,0^+)\\,dx.\n$$\nEquivalently, the electrostatic energy per unit depth is $U'=\\frac{1}{2}\\int_\\Omega \\varepsilon(x,y)\\,|\\nabla\\phi|^2\\,dx\\,dy$ and satisfies $C' = 2U'/V_0^2$. All physical quantities must be expressed in the International System of Units (SI units). Use $\\varepsilon_0 = 8.854187817\\times 10^{-12}\\,\\mathrm{F/m}$, $W=0.1\\,\\mathrm{m}$, $H=0.1\\,\\mathrm{m}$, and $V_0=1.0\\,\\mathrm{V}$. Angles are not used in the required outputs.\n\nTask: Write a complete, runnable program that, for each test case below, computes the electrostatic potential $\\phi(x,y)$ by solving the boundary value problem above and outputs the capacitance per unit depth $C'$ in $\\mathrm{F/m}$.\n\nTest suite:\n- Case $\\#1$: $(\\kappa_1,\\kappa_2,A) = (3.0,\\,3.0,\\,0.0)$.\n- Case $\\#2$: $(\\kappa_1,\\kappa_2,A) = (2.0,\\,5.0,\\,0.0)$.\n- Case $\\#3$: $(\\kappa_1,\\kappa_2,A) = (2.0,\\,5.0,\\,0.02\\,W)$.\n- Case $\\#4$: $(\\kappa_1,\\kappa_2,A) = (1.0,\\,10.0,\\,0.02\\,W)$.\n\nAnswer specification:\n- For each case, compute a single floating-point value $C'$ in $\\mathrm{F/m}$.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the cases $\\#1$ through $\\#4$, with each number in scientific notation and exactly $8$ digits after the decimal point (for example, $\\texttt{[1.23456789e-03,2.34567890e-04,...]}$).",
            "solution": "The problem statement is subjected to validation.\n\n**1. Extraction of Givens:**\n- Governing Equation: $\\nabla \\cdot \\left(\\varepsilon(x,y)\\,\\nabla \\phi(x,y)\\right) = 0$ in the domain $\\Omega = \\{(x,y)\\mid 0 \\le x \\le W,\\; 0 \\le y \\le H\\}$.\n- Boundary Conditions:\n  - $\\phi(x,0) = V_0$\n  - $\\phi(x,H) = 0$\n  - $\\frac{\\partial \\phi}{\\partial x}(0,y) = 0$\n  - $\\frac{\\partial \\phi}{\\partial x}(W,y) = 0$\n- Permittivity Function: $\\varepsilon(x,y) = \\varepsilon_0\\,\\kappa_1$ for $x < x_\\Gamma(y)$ and $\\varepsilon(x,y) = \\varepsilon_0\\,\\kappa_2$ for $x \\ge x_\\Gamma(y)$, where the interface is $x_\\Gamma(y) = \\frac{W}{2} + A \\cos\\left(\\frac{2\\pi y}{H}\\right)$.\n- Capacitance Definition: $C' = Q'/V_0$, with $Q' = -\\int_{0}^{W} \\varepsilon\\left(x,0^+\\right)\\,\\frac{\\partial \\phi}{\\partial y}(x,0^+)\\,dx$.\n- Constants: $\\varepsilon_0 = 8.854187817\\times 10^{-12}\\,\\mathrm{F/m}$, $W=0.1\\,\\mathrm{m}$, $H=0.1\\,\\mathrm{m}$, and $V_0=1.0\\,\\mathrm{V}$.\n- Test Cases: Specific tuples of $(\\kappa_1, \\kappa_2, A)$.\n\n**2. Validation:**\n- The problem is **scientifically grounded**. It describes a standard electrostatic boundary value problem governed by Gauss's law in a dielectric medium. All equations and definitions are fundametally correct.\n- The problem is **well-posed**. It is a second-order elliptic partial differential equation on a closed, bounded domain with a valid combination of Dirichlet and Neumann boundary conditions, which guarantees a unique and stable solution for the potential $\\phi(x,y)$.\n- The problem is **objective and complete**. It is specified using precise mathematical language, and all parameters required for a numerical solution are provided.\n- The problem is **computationally feasible** and its conditions are physically realistic.\n\n**3. Verdict:**\nThe problem is deemed valid. A numerical solution will be constructed.\n\n**Principle-Based Solution Design**\nThe problem requires solving a second-order, linear, elliptic partial differential equation (PDE) for the electrostatic potential $\\phi(x,y)$. We will employ the Finite Difference Method (FDM) on a uniform Cartesian grid.\n\nThe governing equation is the divergence-form Gauss's law for a source-free region:\n$$\n\\nabla \\cdot \\left(\\varepsilon(x,y)\\,\\nabla \\phi(x,y)\\right) = 0\n$$\nIn Cartesian coordinates, this expands to:\n$$\n\\frac{\\partial}{\\partial x}\\left(\\varepsilon(x,y) \\frac{\\partial \\phi}{\\partial x}\\right) + \\frac{\\partial}{\\partial y}\\left(\\varepsilon(x,y) \\frac{\\partial \\phi}{\\partial y}\\right) = 0\n$$\nThe domain $\\Omega = [0,W] \\times [0,H]$ is discretized into a grid of nodes $(x_i, y_j) = (i\\Delta x, j\\Delta y)$ for $i=0, \\dots, N_x$ and $j=0, \\dots, N_y$, where $\\Delta x = W/N_x$ and $\\Delta y = H/N_y$. The potential at these nodes is denoted $\\phi_{i,j} \\approx \\phi(x_i, y_j)$.\n\nUsing a central difference approximation for the derivatives, where the permittivity $\\varepsilon$ is evaluated at the midpoints of grid cells to properly handle its spatial variation, the PDE at an interior node $(i,j)$ is discretized as follows:\n$$\n\\frac{1}{\\Delta x^2} \\left[ \\varepsilon_{i+1/2, j} (\\phi_{i+1,j} - \\phi_{i,j}) - \\varepsilon_{i-1/2, j} (\\phi_{i,j} - \\phi_{i-1,j}) \\right] + \\frac{1}{\\Delta y^2} \\left[ \\varepsilon_{i, j+1/2} (\\phi_{i,j+1} - \\phi_{i,j}) - \\varepsilon_{i, j-1/2} (\\phi_{i,j} - \\phi_{i,j-1}) \\right] = 0\n$$\nHere, for example, $\\varepsilon_{i+1/2, j} = \\varepsilon(x_i + \\Delta x/2, y_j)$.\n\nThe boundary conditions are incorporated as follows:\n- **Dirichlet boundaries:** At the bottom plate ($j=0$), $\\phi_{i,0} = V_0$. At the top plate ($j=N_y$), $\\phi_{i,N_y} = 0$. These values are known and are not part of the system of unknowns. They contribute to the constant vector in the linear system for their neighboring nodes.\n- **Neumann boundaries:** The insulating conditions $\\partial \\phi/\\partial x = 0$ at $x=0$ and $x=W$ are implemented using the method of \"ghost points\". For the left boundary ($i=0$), a ghost point at $i=-1$ is introduced such that $\\phi_{-1,j} = \\phi_{1,j}$. This modifies the finite difference stencil for nodes at $i=0$. A similar modification is made for nodes at the right boundary ($i=N_x$).\n\nThis discretization transforms the continuous PDE into a system of linear algebraic equations, $M\\mathbf{\\Phi} = \\mathbf{b}$, where $\\mathbf{\\Phi}$ is a vector containing all unknown potential values $\\phi_{i,j}$ for $i \\in \\{0, \\dots, N_x\\}$ and $j \\in \\{1, \\dots, N_y-1\\}$. The matrix $M$ is large, sparse, and diagonally dominant, which allows for efficient solution using iterative or sparse direct solvers.\n\nOnce the potential field $\\phi$ is computed, the capacitance per unit depth $C'$ is determined from the free charge per unit depth $Q'$ on the bottom electrode.\n$$\nQ' = -\\int_{0}^{W} \\varepsilon(x,0^+)\\,\\frac{\\partial \\phi}{\\partial y}(x,0^+)\\,dx\n$$\nThis is computed numerically. The integral is approximated using the trapezoidal rule over the grid points at $y=0$. The derivative $\\partial \\phi/\\partial y$ at the boundary $y=0$ is approximated using a second-order accurate one-sided finite difference formula, which requires the potential values at the first three layers of grid points in the $y$-direction ($j=0,1,2$):\n$$\n\\frac{\\partial \\phi}{\\partial y}(x_i, 0^+) \\approx \\frac{-\\phi_{i,2} + 4\\phi_{i,1} - 3\\phi_{i,0}}{2\\Delta y}\n$$\nFinally, the capacitance is calculated as $C' = Q' / V_0$.\n\nThe implementation will use a grid resolution of $N_x=150$ and $N_y=150$, which offers a good compromise between accuracy and computational cost. The `scipy.sparse` library is used to construct the sparse matrix $M$ and `scipy.sparse.linalg.spsolve` is used to solve the linear system.",
            "answer": "```python\nimport numpy as np\nfrom scipy.sparse import lil_matrix, csc_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Solves the 2D electrostatic BVP for a capacitor with a curved dielectric interface\n    and computes the capacitance per unit depth for several test cases.\n    \"\"\"\n    # Physical and geometrical constants\n    EPS0 = 8.854187817e-12  # Vacuum permittivity in F/m\n    W = 0.1  # Width in m\n    H = 0.1  # Height in m\n    V0 = 1.0  # Potential at the bottom plate in V\n\n    # Numerical grid parameters\n    Nx = 150  # Number of intervals in x-direction\n    Ny = 150  # Number of intervals in y-direction\n\n    # Test cases from the problem statement\n    test_cases = [\n        # (kappa1, kappa2, A)\n        (3.0, 3.0, 0.0),\n        (2.0, 5.0, 0.0),\n        (2.0, 5.0, 0.02 * W),\n        (1.0, 10.0, 0.02 * W),\n    ]\n\n    results = []\n\n    for kappa1, kappa2, A in test_cases:\n        # 1. Setup Grid\n        dx = W / Nx\n        dy = H / Ny\n        \n        # Grid node coordinates\n        x_coords = np.linspace(0, W, Nx + 1)\n        y_coords = np.linspace(0, H, Ny + 1)\n        \n        # 2. Define Permittivity Function\n        # This function will be evaluated at mid-grid points during matrix assembly.\n        def get_epsilon(x, y):\n            x_gamma = W / 2 + A * np.cos(2 * np.pi * y / H)\n            if x < x_gamma:\n                return EPS0 * kappa1\n            else:\n                return EPS0 * kappa2\n\n        # 3. Assemble the Linear System M*phi = b\n        # Unknowns are phi at interior nodes, including Neumann boundaries.\n        # Nodes at y=0 and y=H are known (Dirichlet).\n        num_unknowns = (Nx + 1) * (Ny - 1)\n        M = lil_matrix((num_unknowns, num_unknowns))\n        b = np.zeros(num_unknowns)\n\n        # Iterate over grid points corresponding to unknowns\n        # j runs from 1 to Ny-1, covering rows y=dy, ..., y=H-dy.\n        # i runs from 0 to Nx, covering columns x=0, ..., x=W.\n        for j in range(1, Ny):\n            for i in range(0, Nx + 1):\n                # Map 2D grid index (i,j) to 1D vector index k\n                k = i + (j - 1) * (Nx + 1)\n                \n                # Get permittivity at mid-grid points around (i,j)\n                eps_y_p = get_epsilon(x_coords[i], y_coords[j] + dy / 2)\n                eps_y_m = get_epsilon(x_coords[i], y_coords[j] - dy / 2)\n                \n                if i > 0:\n                    eps_x_m = get_epsilon(x_coords[i] - dx / 2, y_coords[j])\n                if i < Nx:\n                    eps_x_p = get_epsilon(x_coords[i] + dx / 2, y_coords[j])\n\n                # Assemble coefficients for the FDM equation at node (i,j)\n                # Diagonal contribution from y-derivatives\n                M[k, k] = (eps_y_p + eps_y_m) / dy**2\n                \n                # Off-diagonal y-neighbors\n                if j < Ny - 1: # Upper neighbor (phi_{i, j+1}) is an unknown\n                    k_up = i + j * (Nx + 1)\n                    M[k, k_up] = -eps_y_p / dy**2\n                # Lower neighbor (phi_{i, j-1})\n                if j > 1: # Lower neighbor is an unknown\n                    k_down = i + (j - 2) * (Nx + 1)\n                    M[k, k_down] = -eps_y_m / dy**2\n                else: # j=1, lower neighbor is on the Dirichlet boundary (y=0)\n                    b[k] += (eps_y_m / dy**2) * V0\n\n                # Add contributions from x-derivatives based on boundary type\n                if i == 0:  # Left Neumann boundary (x=0)\n                    M[k, k] += (2 * eps_x_p) / dx**2\n                    M[k, k + 1] = (-2 * eps_x_p) / dx**2\n                elif i == Nx:  # Right Neumann boundary (x=W)\n                    M[k, k] += (2 * eps_x_m) / dx**2\n                    M[k, k - 1] = (-2 * eps_x_m) / dx**2\n                else:  # Interior point in x\n                    M[k, k] += (eps_x_p + eps_x_m) / dx**2\n                    M[k, k + 1] = -eps_x_p / dx**2\n                    M[k, k - 1] = -eps_x_m / dx**2\n\n        # 4. Solve the sparse linear system\n        M_csc = csc_matrix(M)\n        phi_vec = spsolve(M_csc, b)\n\n        # 5. Reconstruct the 2D potential field from the solution vector\n        phi = np.zeros((Nx + 1, Ny + 1))\n        phi[:, 0] = V0   # Bottom plate\n        phi[:, Ny] = 0.0  # Top plate\n        # Un-flatten the solution vector into the grid of unknowns\n        phi[:, 1:Ny] = phi_vec.reshape((Ny - 1, Nx + 1)).T\n        \n        # 6. Calculate Capacitance per unit depth\n        # Use a 2nd-order accurate one-sided FD for the derivative d(phi)/dy at y=0\n        dphi_dy_at_y0 = (-phi[:, 2] + 4 * phi[:, 1] - 3 * phi[:, 0]) / (2 * dy)\n\n        # Evaluate permittivity along the bottom plate (y=0)\n        eps_at_y0 = np.array([get_epsilon(x, 0.0) for x in x_coords])\n        \n        # Numerically integrate to find charge Q'\n        integrand = eps_at_y0 * dphi_dy_at_y0\n        Q_prime = -np.trapz(integrand, x=x_coords)\n        \n        # Compute capacitance C'\n        C_prime = Q_prime / V0\n        \n        results.append(C_prime)\n    \n    # 7. Format and print the final output as specified\n    print(f\"[{','.join([f'{r:.8e}' for r in results])}]\")\n\nsolve()\n```"
        }
    ]
}