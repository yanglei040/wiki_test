{
    "hands_on_practices": [
        {
            "introduction": "本章的第一个练习将引导你直接模拟热量随时间的传导过程。通过构建一个二维热方程的数值解法器，你将实践如何正确地实现有限差分格式，并处理周期性和绝热（诺伊曼）等不同类型的边界条件。这项练习是掌握热传导建模基本技能的关键一步，为更复杂的应用打下坚实基础。",
            "id": "2445101",
            "problem": "考虑一个厚度均匀的薄导电板，该板被建模为一个二维域，坐标为 $x \\in [0,L_x)$ 和 $y \\in [0,L_y]$。温度场 $T(x,y,t)$ 的演化遵循热传导方程，这是一个偏微分方程（PDE），具体形式如下：\n$$\n\\frac{\\partial T}{\\partial t} = \\alpha \\left( \\frac{\\partial^2 T}{\\partial x^2} + \\frac{\\partial^2 T}{\\partial y^2} \\right) + s(x,y,t),\n$$\n其中 $\\alpha$ 是恒定的热扩散率，$s(x,y,t)$ 是一个体积热源项，单位为温度速率。$x$ 方向的边界条件是周期性的，即对于所有的 $y$ 和 $t$，都有 $T(0,y,t) = T(L_x,y,t)$。这模拟了一个通过将边 $x=0$ 和 $x=L_x$ 对接而获得的薄圆柱壳。$y$ 方向的边界是热绝缘的（法向热通量为零），即对于所有的 $x$ 和 $t$，都有 $\\frac{\\partial T}{\\partial y}(x,0,t)=0$ 和 $\\frac{\\partial T}{\\partial y}(x,L_y,t)=0$。初始条件是均匀的：处处 $T(x,y,0) = T_0$。\n\n源项 $s(x,y,t)$ 代表一个沿 $x$ 方向均匀分布、在 $y$ 方向上局限于一个带状区域的线性加热条。其定义如下：\n$$\ns(x,y,t) =\n\\begin{cases}\nH,  \\text{若 } y \\in [y_1,y_2] \\text{ 且 } t \\in [0,\\tau],\\\\\n0,  \\text{其他情况},\n\\end{cases}\n$$\n其中 $H$ 是一个恒定的加热速率。所有温度必须以开尔文（Kelvin）表示，所有长度以米表示，所有时间以秒表示。本问题不涉及角度。材料和几何形状在空间上是均匀的，板的属性不随时间变化。\n\n您的程序必须对几组参数集，将 $T(x,y,t)$ 数值演化到指定的最终时间 $t=t_f$，然后为每组参数报告：\n- 在时间 $t_f$ 时，点 $(x^\\ast,y^\\ast) = (L_x/4, L_y/2)$ 处的温度（以开尔文计）。\n- 在时间 $t_f$ 时，点 $(x^\\ast,y^\\ast) = (3L_x/4, L_y/2)$ 处的温度（以开尔文计）。\n- 在时间 $t_f$ 时，$T(\\cdot,\\cdot,t_f)$ 在整个板上的空间面积平均值（以开尔文计）。\n\n为确保对所需点值的无歧义评估，请在 $x$ 和 $y$ 方向上使用均匀网格，其节点坐标定义为 $x_i = i\\,L_x/N_x$（对于 $i \\in \\{0,1,\\dots,N_x-1\\}$）和 $y_j = j\\,L_y/(N_y-1)$（对于 $j \\in \\{0,1,\\dots,N_y-1\\}$）。对于以下所有测试用例，根据此约定，点 $(L_x/4, L_y/2)$ 和 $(3L_x/4, L_y/2)$ 均与网格节点重合。面积平均值是矩形域上的连续空间平均，并且必须以开尔文报告。\n\n所有测试均使用以下材料参数：\n- 热扩散率 $\\alpha = 1.11\\times 10^{-4}\\ \\text{m}^2/\\text{s}$。\n\n使用以下参数集测试套件。在每种情况下，板的初始温度为 $T_0 = 300\\ \\text{K}$，$s(x,y,t)$ 由如上所述的宽度为 $w$、持续时间为 $\\tau$ 的加热条指定。所有输出必须以开尔文表示，并四舍五入到三位小数。\n\n测试用例 A（中心加热条，加热在 $t_f$ 之前关闭）：\n- $L_x = 0.2\\ \\text{m}$，$L_y = 0.1\\ \\text{m}$。\n- $N_x = 64$，$N_y = 33$，$\\Delta t = 0.002\\ \\text{s}$，$t_f=1.0\\ \\text{s}$。\n- $H = 50\\ \\text{K/s}$，$w = 0.01\\ \\text{m}$，$\\tau = 0.5\\ \\text{s}$。\n- 加热条占据 $y \\in [y_1,y_2]$，其中 $y_1 = (L_y - w)/2$ 且 $y_2 = (L_y + w)/2$。\n\n测试用例 B（位于下方绝缘边界的加热条）：\n- $L_x = 0.2\\ \\text{m}$，$L_y = 0.1\\ \\text{m}$。\n- $N_x = 48$，$N_y = 25$，$\\Delta t = 0.002\\ \\text{s}$，$t_f=0.4\\ \\text{s}$。\n- $H = 100\\ \\text{K/s}$，$w = 0.01\\ \\text{m}$，$\\tau = 0.2\\ \\text{s}$。\n- 加热条占据 $y \\in [y_1,y_2]$，其中 $y_1 = 0$ 且 $y_2 = w$。\n\n测试用例 C（无加热）：\n- $L_x = 0.2\\ \\text{m}$，$L_y = 0.1\\ \\text{m}$。\n- $N_x = 32$，$N_y = 17$，$\\Delta t = 0.002\\ \\text{s}$，$t_f=0.3\\ \\text{s}$。\n- $H = 0\\ \\text{K/s}$，$w = 0.01\\ \\text{m}$，$\\tau = 0.0\\ \\text{s}$。\n- 加热条位置无关紧要。\n\n您的程序应生成单行输出，其中包含所有测试用例的结果，形式为方括号括起来的逗号分隔列表。列表必须按以下顺序排列\n$$\n[\\ T^{(A)}(L_x/4,L_y/2,t_f),\\ T^{(A)}(3L_x/4,L_y/2,t_f),\\ \\overline{T}^{(A)}(t_f),\\ T^{(B)}(L_x/4,L_y/2,t_f),\\ T^{(B)}(3L_x/4,L_y/2,t_f),\\ \\overline{T}^{(B)}(t_f),\\ T^{(C)}(L_x/4,L_y/2,t_f),\\ T^{(C)}(3L_x/4,L_y/2,t_f),\\ \\overline{T}^{(C)}(t_f)\\ ],\n$$\n其中每个条目均以开尔文为单位，四舍五入到三位小数，$T^{(\\cdot)}$ 表示指定测试用例中的温度场，$\\overline{T}^{(\\cdot)}(t_f)$ 表示时间 $t_f$ 时的空间面积平均值。",
            "solution": "所提出的问题是一个适定的二维线性热传导方程的初边值问题。它具有科学依据，需要数值求解，并提供了所有必要的参数和条件。因此，该问题是有效的。我将继续进行求解。\n\n控制偏微分方程（PDE）是带有源项 $s(x,y,t)$ 的热传导方程：\n$$\n\\frac{\\partial T}{\\partial t} = \\alpha \\left( \\frac{\\partial^2 T}{\\partial x^2} + \\frac{\\partial^2 T}{\\partial y^2} \\right) + s(x,y,t)\n$$\n该方程描述了在域 $x \\in [0,L_x)$、$y \\in [0,L_y]$ 中，热扩散率为 $\\alpha$ 的温度场 $T(x,y,t)$ 的演化。\n\n数值解将使用有限差分法（FDM）获得。我将采用显式的前向时间、中心空间（FTCS）格式，因为它易于直接实现。连续域被离散化为点 $(x_i, y_j, t_n)$ 构成的网格，其中 $x_i = i \\Delta x$，$y_j = j \\Delta y$，$t_n = n \\Delta t$。网格参数由 $N_x$ 和 $N_y$ 给出，因此空间步长为 $\\Delta x = L_x / N_x$ 和 $\\Delta y = L_y / (N_y - 1)$。网格点上的温度记为 $T_{i,j}^n \\approx T(x_i, y_j, t_n)$。\n\n偏导数近似如下：\n- 时间导数（一阶前向差分）：\n$$\n\\frac{\\partial T}{\\partial t} \\approx \\frac{T_{i,j}^{n+1} - T_{i,j}^n}{\\Delta t}\n$$\n- 空间导数（二阶中心差分）：\n$$\n\\frac{\\partial^2 T}{\\partial x^2} \\approx \\frac{T_{i+1,j}^n - 2T_{i,j}^n + T_{i-1,j}^n}{\\Delta x^2}\n$$\n$$\n\\frac{\\partial^2 T}{\\partial y^2} \\approx \\frac{T_{i,j+1}^n - 2T_{i,j}^n + T_{i,j-1}^n}{\\Delta y^2}\n$$\n将这些近似代入热传导方程，得到下一时间步温度 $T_{i,j}^{n+1}$ 的显式更新规则：\n$$\nT_{i,j}^{n+1} = T_{i,j}^n + \\Delta t \\left[ \\alpha \\left( \\frac{T_{i+1,j}^n - 2T_{i,j}^n + T_{i-1,j}^n}{\\Delta x^2} + \\frac{T_{i,j+1}^n - 2T_{i,j}^n + T_{i,j-1}^n}{\\Delta y^2} \\right) + s_{i,j}^n \\right]\n$$\n该格式在 Courant-Friedrichs-Lewy (CFL) 条件下是稳定的，对于二维热传导方程，该条件为 $\\alpha \\Delta t \\left( \\frac{1}{\\Delta x^2} + \\frac{1}{\\Delta y^2} \\right) \\le \\frac{1}{2}$。所有测试用例给出的参数都满足此条件，从而保证了数值解的稳定性。\n\n边界条件必须在有限差分格式中正确实现：\n1.  **$x$方向的周期性边界：** $T(0,y,t) = T(L_x,y,t)$。在离散网格上，这意味着 $T_{0,j}^n = T_{N_x,j}^n$。$i=0$ 处点的邻居是 $i=1$ 和 $i=N_x-1$。对于 $i=N_x-1$ 处的点，其邻居是 $i=N_x-2$ 和 $i=0$。这可以通过对与 $x$ 轴对应的数据数组执行循环移位操作来高效实现。\n\n2.  **$y$方向的绝缘（诺伊曼）边界：** 在 $y=0$（$j=0$）和 $y=L_y$（$j=N_y-1$）处，$\\frac{\\partial T}{\\partial y} = 0$。使用域外“虚拟点”的方法来构造二阶精度的中心差分导数。对于 $j=0$，条件 $\\frac{T_{i,1}^n - T_{i,-1}^n}{2\\Delta y} = 0$ 意味着虚拟点的值 $T_{i,-1}^n = T_{i,1}^n$。在 $j=0$ 处的拉普拉斯项变为：\n    $$\n    \\left. \\frac{\\partial^2 T}{\\partial y^2} \\right|_{j=0} \\approx \\frac{T_{i,1}^n - 2T_{i,0}^n + T_{i,-1}^n}{\\Delta y^2} = \\frac{2(T_{i,1}^n - T_{i,0}^n)}{\\Delta y^2}\n    $$\n    类似地，对于 $j=N_y-1$，虚拟点 $T_{i,N_y}^n = T_{i,N_y-2}^n$，拉普拉斯项为：\n    $$\n    \\left. \\frac{\\partial^2 T}{\\partial y^2} \\right|_{j=N_y-1} \\approx \\frac{2(T_{i,N_y-2}^n - T_{i,N_y-1}^n)}{\\Delta y^2}\n    $$\n\n模拟从均匀初始条件 $T(x,y,0) = T_0$ 开始。FTCS 更新规则被迭代应用，总步数等于 $t_f/ \\Delta t$。源项 $s_{i,j}^n$ 在每一步施加，如果网格点 $(x_i, y_j)$ 位于加热条内且当前时间 $t_n$ 小于 $\\tau$，则其值为 $H$，否则为 0。\n\n达到最终时间 $t_f$ 后，从最终温度场 $T_{i,j}^{final}$ 中提取所需的量：\n-   **点温度：** 直接从对应于 $(L_x/4, L_y/2)$ 和 $(3L_x/4, L_y/2)$ 的网格节点读取数值。网格的构建方式使得这些点是精确的网格点，其索引为 $i = N_x/4$（或 $i=3N_x/4$）和 $j = (N_y-1)/2$。\n-   **空间面积平均值：** 连续平均值 $\\overline{T}(t_f) = \\frac{1}{L_x L_y} \\iint T(x,y,t_f) \\,dx\\,dy$ 通过数值计算得出。该积分使用复合求积法则进行评估。由于 $x$ 方向的周期性，积分 $\\int_0^{L_x} f(x) dx$ 最好用矩形法则来近似：$\\Delta x \\sum_{i=0}^{N_x-1} f(x_i)$。对于非周期的 $y$ 方向，梯形法则是合适的：$\\int_0^{L_y} g(y) dy \\approx \\text{np.trapz}(g, \\text{dx=}\\Delta y)$。结合这两者，二重积分的计算方法是：首先使用梯形法则对每个 $x_i$ 沿 $y$ 轴积分，然后将结果沿 $x$ 轴求和，并乘以 $\\Delta x$。最终值是该积分除以总面积 $L_x L_y$。\n\n作为验证，面积平均温度的演化可以解析确定。将 PDE 在整个域上积分，并应用散度定理和给定的零通量边界条件，可得当 $t \\le \\tau$ 时 $\\frac{d\\overline{T}}{dt} = \\frac{1}{L_y} H w$，当 $t > \\tau$ 时为 0。其解为 $\\overline{T}(t_f) = T_0 + \\frac{Hw}{L_y} \\min(t_f, \\tau)$。对于 $H=0$ 的情况 C，温度场在任何时候都必须保持恒定的 $T_0=300\\,\\text{K}$。这些解析结果可作为对数值实现的严格检验。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 2D heat equation for the specified test cases and prints the results.\n    \"\"\"\n    \n    # Material parameter\n    ALPHA = 1.11e-4  # m^2/s\n    T0 = 300.0  # K\n\n    test_cases = [\n        # Test Case A\n        {\n            \"Lx\": 0.2, \"Ly\": 0.1, \"Nx\": 64, \"Ny\": 33, \n            \"dt\": 0.002, \"tf\": 1.0, \n            \"H\": 50.0, \"w\": 0.01, \"tau\": 0.5,\n            \"strip_type\": \"central\"\n        },\n        # Test Case B\n        {\n            \"Lx\": 0.2, \"Ly\": 0.1, \"Nx\": 48, \"Ny\": 25, \n            \"dt\": 0.002, \"tf\": 0.4, \n            \"H\": 100.0, \"w\": 0.01, \"tau\": 0.2,\n            \"strip_type\": \"lower_edge\"\n        },\n        # Test Case C\n        {\n            \"Lx\": 0.2, \"Ly\": 0.1, \"Nx\": 32, \"Ny\": 17, \n            \"dt\": 0.002, \"tf\": 0.3,\n            \"H\": 0.0, \"w\": 0.01, \"tau\": 0.0,\n            \"strip_type\": \"irrelevant\"\n        }\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        # Extract parameters\n        Lx, Ly, Nx, Ny = case[\"Lx\"], case[\"Ly\"], case[\"Nx\"], case[\"Ny\"]\n        dt, tf = case[\"dt\"], case[\"tf\"]\n        H, w, tau = case[\"H\"], case[\"w\"], case[\"tau\"]\n        strip_type = case[\"strip_type\"]\n\n        # Grid setup\n        dx = Lx / Nx\n        dy = Ly / (Ny - 1)\n        \n        # Grid coordinates\n        y_coords = np.linspace(0, Ly, Ny)\n        x_coords = np.linspace(0, Lx, Nx, endpoint=False)\n\n        # Initialize temperature field\n        T = np.full((Ny, Nx), T0, dtype=np.float64)\n\n        # Define heating strip location\n        if strip_type == \"central\":\n            y1 = (Ly - w) / 2\n            y2 = (Ly + w) / 2\n        elif strip_type == \"lower_edge\":\n            y1 = 0.0\n            y2 = w\n        else: # \"irrelevant\" or other\n            y1, y2 = -1.0, -1.0 # No heating should occur\n\n        # Pre-calculate source term mask\n        source_mask = np.zeros_like(T)\n        if H > 0:\n            # Add a small epsilon for robust float comparison at boundaries\n            y_indices = np.where((y_coords >= y1 - 1e-9) & (y_coords <= y2 + 1e-9))[0]\n            source_mask[y_indices, :] = H\n\n        # Time-stepping loop\n        num_steps = int(round(tf / dt))\n        for n in range(num_steps):\n            # Calculate laplacian\n            # x-direction (periodic)\n            T_xx = (np.roll(T, -1, axis=1) - 2 * T + np.roll(T, 1, axis=1)) / (dx * dx)\n            \n            # y-direction (Neumann)\n            T_yy = np.zeros_like(T)\n            # Interior points\n            T_yy[1:-1, :] = (T[2:, :] - 2 * T[1:-1, :] + T[:-2, :]) / (dy * dy)\n            # Boundary y=0\n            T_yy[0, :] = 2 * (T[1, :] - T[0, :]) / (dy * dy)\n            # Boundary y=Ly\n            T_yy[-1, :] = 2 * (T[-2, :] - T[-1, :]) / (dy * dy)\n            \n            laplacian = T_xx + T_yy\n            \n            # Current source term\n            current_time = (n + 1) * dt # time at end of step\n            s_current = source_mask if current_time <= tau else 0.0\n            \n            # Update temperature using FTCS scheme\n            T += dt * (ALPHA * laplacian + s_current)\n        \n        # --- Post-processing ---\n        \n        # 1. Pointwise temperatures\n        # Indices for (Lx/4, Ly/2) and (3Lx/4, Ly/2)\n        ix1 = Nx // 4\n        ix2 = 3 * Nx // 4\n        iy = (Ny - 1) // 2\n        \n        T_pt1 = T[iy, ix1]\n        T_pt2 = T[iy, ix2]\n        \n        # 2. Spatial area average\n        # Integrate along y (non-periodic) using trapezoidal rule\n        integral_y = np.trapz(T, dx=dy, axis=0) # Result is a 1D array of size Nx\n        # Integrate along x (periodic) using rectangular rule (summation)\n        total_integral = np.sum(integral_y) * dx\n        avg_T = total_integral / (Lx * Ly)\n\n        # Store results for this case\n        all_results.extend([T_pt1, T_pt2, avg_T])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{val:.3f}' for val in all_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了正向模拟后，我们将转向一个实际的工程设计问题。在这个练习中，你不再仅仅是预测物理过程，而是要利用模型来优化一个冷却系统。通过求解稳态热方程（泊松方程），你将探索如何通过穷举搜索来确定冷却通道的最佳布局，以实现对特定区域的最有效降温。这个练习旨在展示如何将计算模型应用于解决实际的设计和优化挑战。",
            "id": "2445124",
            "problem": "要求您对一个薄的、均匀的、各向同性的方形导热板中的稳态温度场构建、离散化并求解一个优化问题。该导热板在指定的受热区域有内部热生成，并有一组离散的候选位置用于放置内部冷却通道（理想化为单位厚度的线汇）。您的任务是，对于几个指定的测试用例，在板边界环境温度固定的情况下，通过在不同的候选节点上放置固定数量的冷却通道，计算可以在受热区域上实现的最低平均温度。您必须实现一个完整的程序，执行以下操作：(i) 基于第一性原理构建一个数学上一致的模型，(ii) 使用有限差分法 (FDM) 在均匀网格上离散化稳态控制方程，(iii) 对给定基数的所有冷却通道放置组合，求解由此产生的线性系统，以及 (iv) 报告每个测试用例在受热区域上的最低平均温度，以开尔文表示并四舍五入到三位小数。\n\n基本建模基础。从能量守恒和傅里叶热传导定律开始。对于一个薄板，其导热系数为常数 $k$ (单位 $\\mathrm{W\\,m^{-1}\\,K^{-1}}$)，忽略内部的对流和辐射，其稳态温度场 $T(x,y)$ 满足\n$$\n\\nabla \\cdot \\left( k \\nabla T \\right) + q_{\\text{hot}}(x,y) - q_{\\text{sink}}(x,y) = 0,\n$$\n其中 $q_{\\text{hot}}(x,y)$ 是局限于指定受热区域的体积热生成率 (单位 $\\mathrm{W\\,m^{-3}}$)，而 $q_{\\text{sink}}(x,y)$ 是代表单位厚度冷却通道的局部体积热汇项之和。当 $k$ 为常数时，方程变为\n$$\n\\nabla^2 T(x,y) = \\frac{q_{\\text{sink}}(x,y) - q_{\\text{hot}}(x,y)}{k}.\n$$\n在整个板边界上施加狄利克雷边界条件 (BCs) $T = T_{\\text{amb}}$ (单位 $\\mathrm{K}$)。\n\n离散化。考虑一个边长为 $L$ (单位 $\\mathrm{m}$) 的方形区域，在 $N \\times N$ 个节点的均匀网格上进行离散化，网格间距为 $h = L/(N-1)$。使用标准的 5 点模板对拉普拉斯算子进行有限差分离散化。对于索引为 $(i,j)$ 的内部网格节点，令 $T_{i,j}$ 表示离散温度。离散方程为\n$$\n\\frac{T_{i+1,j} + T_{i-1,j} + T_{i,j+1} + T_{i,j-1} - 4 T_{i,j}}{h^2} = \\frac{q_{\\text{sink},i,j} - q_{\\text{hot},i,j}}{k}.\n$$\n对于边界节点，强制执行狄利克雷条件 $T_{i,j} = T_{\\text{amb}}$。将 $q_{\\text{hot},i,j}$ 表示为在指定受热区域索引上为常数 $q_{\\text{hot}}$ (单位 $\\mathrm{W\\,m^{-3}}$)，在其他地方为零。将每个冷却通道在其节点处贡献一个恒定的体积汇 $s$ (单位 $\\mathrm{W\\,m^{-3}}$)；如果通道放置在集合 $\\mathcal{S}$ 中的节点索引处，则对于 $(i,j) \\in \\mathcal{S}$，有 $q_{\\text{sink},i,j} = s$，否则为零。\n\n优化任务。对于下面的每个测试用例，您将获得：\n- 板边长 $L$ (单位 $\\mathrm{m}$)，\n- 网格大小 $N$ (无量纲)，\n- 导热系数 $k$ (单位 $\\mathrm{W\\,m^{-1}\\,K^{-1}}$)，\n- 环境边界温度 $T_{\\text{amb}}$ (单位 $\\mathrm{K}$)，\n- 受热区域索引范围 $\\{i_{\\min}..i_{\\max}\\}$ 和 $\\{j_{\\min}..j_{\\max}\\}$ (包含边界)，\n- 受热区域上的均匀内部体积热生成率 $q_{\\text{hot}}$ (单位 $\\mathrm{W\\,m^{-3}}$)，\n- 允许放置冷却通道的候选节点列表 $\\mathcal{C} = \\{(i,j)\\}$，\n- 要放置的通道数量 $m$ (一个整数，满足 $0 \\le m \\le |\\mathcal{C}|$)，以及\n- 每个通道节点的汇强度 $s$ (单位 $\\mathrm{W\\,m^{-3}}$)。\n\n对于每个测试用例，评估从 $\\mathcal{C}$ 中选出的 $m$ 个不同节点的所有组合，为每种组合求解线性系统，计算受热区域节点集 $\\mathcal{H}$ 上的平均温度 $T_{i,j}$，并报告在所有组合中实现的 $\\mathcal{H}$ 上的最低平均温度。\n\n数值单位和输出。所有温度必须以开尔文表示，并且每个测试用例的最终答案必须四舍五入到三位小数。不使用角度。您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，例如 `[300.123,299.876,305.000]`。\n\n测试套件。请精确使用以下三个测试用例；索引是从零开始且包含边界的：\n- 测试用例 1 (正常情况):\n  - $L = 0.20$ $\\mathrm{m}$， $N = 20$， $k = 200$ $\\mathrm{W\\,m^{-1}\\,K^{-1}}$，$T_{\\text{amb}} = 300$ $\\mathrm{K}$，\n  - 受热区域行 $i \\in \\{7,8,9,10,11,12\\}$ 和列 $j \\in \\{7,8,9,10,11,12\\}$，\n  - $q_{\\text{hot}} = 1.0 \\times 10^{6}$ $\\mathrm{W\\,m^{-3}}$，\n  - 候选集 $\\mathcal{C}_1 = \\{(6,7),(6,9),(6,12),(13,7),(13,9),(13,12),(7,6),(9,6),(12,13),(9,13)\\}$，\n  - 通道数量 $m = 2$，\n  - 汇强度 $s = 5.0 \\times 10^{6}$ $\\mathrm{W\\,m^{-3}}$。\n- 测试用例 2 (无通道的边界情况):\n  - $L = 0.20$ $\\mathrm{m}$， $N = 20$， $k = 200$ $\\mathrm{W\\,m^{-1}\\,K^{-1}}$，$T_{\\text{amb}} = 300$ $\\mathrm{K}$，\n  - 受热区域行 $i \\in \\{7,8,9,10,11,12\\}$ 和列 $j \\in \\{7,8,9,10,11,12\\}$，\n  - $q_{\\text{hot}} = 1.0 \\times 10^{6}$ $\\mathrm{W\\,m^{-3}}$，\n  - 候选集 $\\mathcal{C}_2 = \\mathcal{C}_1$ (与测试用例 1 相同)，\n  - 通道数量 $m = 0$，\n  - 汇强度 $s = 5.0 \\times 10^{6}$ $\\mathrm{W\\,m^{-3}}$ (由于 $m=0$ 无关紧要)。\n- 测试用例 3 (不同材料和几何形状):\n  - $L = 0.16$ $\\mathrm{m}$， $N = 16$， $k = 60$ $\\mathrm{W\\,m^{-1}\\,K^{-1}}$，$T_{\\text{amb}} = 300$ $\\mathrm{K}$，\n  - 受热区域行 $i \\in \\{6,7,8,9\\}$ 和列 $j \\in \\{6,7,8,9\\}$，\n  - $q_{\\text{hot}} = 1.2 \\times 10^{6}$ $\\mathrm{W\\,m^{-3}}$，\n  - 候选集 $\\mathcal{C}_3 = \\{(5,5),(5,7),(5,8),(5,10),(10,5),(10,7),(10,8),(10,10),(7,5),(8,5),(7,10),(8,10)\\}$，\n  - 通道数量 $m = 3$，\n  - 汇强度 $s = 8.0 \\times 10^{6}$ $\\mathrm{W\\,m^{-3}}$。\n\n最终输出格式。您的程序应生成单行输出，其中包含三个测试用例的受热区域最低平均温度，格式为方括号括起来的逗号分隔列表，每个条目均以开尔文为单位四舍五入到三位小数，例如 $[T_1,T_2,T_3]$，其中每个 $T_i$ 是以开尔文为单位并四舍五入到三位小数的浮点数。",
            "solution": "所提出的问题是一个定义明确的优化任务，其根源在于热传递的基本原理。它要求找到离散数量的冷却通道的最佳布局，以最小化导热板上指定区域的平均温度。求解过程首先将物理问题表述为一个线性方程组，然后对每种可能的冷却通道配置求解该系统，以确定目标函数的全局最小值。\n\n控制物理定律是稳态热方程，对于具有恒定导热系数 $k$ 的均匀各向同性介质，该方程简化为泊松方程：\n$$\n\\nabla^2 T(x,y) = -\\frac{q(x,y)}{k}\n$$\n其中 $T(x,y)$ 是温度场，$q(x,y) = q_{\\text{hot}}(x,y) - q_{\\text{sink}}(x,y)$ 是净体积热源密度，单位为 $\\mathrm{W\\,m^{-3}}$。该板是一个边长为 $L$ 的方形区域，其边界上的温度由狄利克雷条件 $T = T_{\\text{amb}}$ 固定。\n\n为了数值求解此偏微分方程，将区域离散化为 $N \\times N$ 个节点的均匀网格，网格间距为 $h = L/(N-1)$。拉普拉斯算子 $\\nabla^2$ 使用标准的 5 点有限差分模板进行近似。对于内部节点 $(i,j)$，其中 $i,j \\in \\{1, \\dots, N-2\\}$，泊松方程的离散形式为：\n$$\n\\frac{T_{i+1,j} + T_{i-1,j} + T_{i,j+1} + T_{i,j-1} - 4T_{i,j}}{h^2} = -\\frac{q_{i,j}}{k}\n$$\n对所有 $(N-2)^2$ 个内部节点重新排列此方程，得到一个线性代数方程组，$\\mathbf{A}\\mathbf{T}_{\\text{int}} = \\mathbf{b}$。\n- $\\mathbf{T}_{\\text{int}}$ 是一个维度为 $(N-2)^2$ 的向量，包含内部节点的未知温度。\n- $\\mathbf{A}$ 是一个大小为 $(N-2)^2 \\times (N-2)^2$ 的稀疏、块三对角矩阵，表示离散化的负拉普拉斯算子。对于一个展平索引为 $p$ 的内部节点，矩阵方程的对应行源自 $4T_p - \\sum_{n \\in \\text{neighbors}} T_n = \\frac{h^2}{k}q_p$。因此，$\\mathbf{A}$ 的对角元素为 $4$，而对应于相邻内部节点的非对角元素为 $-1$。\n- $\\mathbf{b}$ 是维度为 $(N-2)^2$ 的右侧向量。每个元素 $b_p$ 由两部分组成：来自热源/汇项的贡献 $\\frac{h^2}{k}q_{i,j}$，以及来自任何相邻边界节点的贡献，其温度已知 ($T_{\\text{amb}}$)。如果内部节点 $(i,j)$ 与边界相邻，则已知温度 $T_{\\text{amb}}$ 会移到方程的右侧。\n\n优化通过组合搜索来执行。对于每个测试用例，我们给定一组候选位置 $\\mathcal{C}$ 和要放置的通道数量 $m$。算法计算放置 $m$ 个冷却通道的所有 $\\binom{|\\mathcal{C}|}{m}$ 种组合。对于每种组合：\n1.  构建总源项网格 $q_{i,j} = q_{\\text{hot},i,j} - q_{\\text{sink},i,j}$。$q_{\\text{hot},i,j}$ 仅在指定的受热区域 $\\mathcal{H}$ 中非零，而 $q_{\\text{sink},i,j}$ 仅在当前组合选择的节点处非零。\n2.  使用当前的 $q_{i,j}$ 分布和固定的边界温度 $T_{\\text{amb}}$ 来组装向量 $\\mathbf{b}$。矩阵 $\\mathbf{A}$ 与源/汇的配置无关，每个测试用例只构建一次。\n3.  求解稀疏线性系统 $\\mathbf{A}\\mathbf{T}_{\\text{int}} = \\mathbf{b}$，得到内部温度向量 $\\mathbf{T}_{\\text{int}}$。`scipy.sparse.linalg.spsolve` 是完成此任务的合适且高效的求解器。\n4.  通过将解 $\\mathbf{T}_{\\text{int}}$ 放置在边界设置为 $T_{\\text{amb}}$ 的网格内部来重构完整的温度网格。\n5.  通过对 $\\mathcal{H}$ 中节点的温度求和并除以节点数 $|\\mathcal{H}|$ 来计算受热区域 $\\mathcal{H}$ 上的平均温度。\n6.  将此平均温度与先前组合中找到的最小值进行比较，并在必要时更新最小值。\n\n在遍历所有组合后，报告受热区域的最终最低平均温度。对问题陈述中提供的每个测试用例重复此过程。$m=0$ 的情况会自然处理，因为只有一种组合（无通道），系统只需求解一次。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import lil_matrix\nfrom scipy.sparse.linalg import spsolve\nfrom itertools import combinations\n\ndef solve():\n    \"\"\"\n    Solves the optimization problem for three test cases.\n    For each case, it finds the optimal placement of cooling channels\n    to minimize the average temperature of a hot area on a conducting plate.\n    \"\"\"\n    test_cases = [\n        # Test case 1 (happy path)\n        {\n            \"L\": 0.20, \"N\": 20, \"k\": 200, \"T_amb\": 300,\n            \"hot_area_rows\": (7, 12), \"hot_area_cols\": (7, 12),\n            \"q_hot\": 1.0e6,\n            \"C\": [(6, 7), (6, 9), (6, 12), (13, 7), (13, 9), (13, 12), (7, 6), (9, 6), (12, 13), (9, 13)],\n            \"m\": 2, \"s\": 5.0e6\n        },\n        # Test case 2 (boundary case with no channels)\n        {\n            \"L\": 0.20, \"N\": 20, \"k\": 200, \"T_amb\": 300,\n            \"hot_area_rows\": (7, 12), \"hot_area_cols\": (7, 12),\n            \"q_hot\": 1.0e6,\n            \"C\": [(6, 7), (6, 9), (6, 12), (13, 7), (13, 9), (13, 12), (7, 6), (9, 6), (12, 13), (9, 13)],\n            \"m\": 0, \"s\": 5.0e6\n        },\n        # Test case 3 (different material and geometry)\n        {\n            \"L\": 0.16, \"N\": 16, \"k\": 60, \"T_amb\": 300,\n            \"hot_area_rows\": (6, 9), \"hot_area_cols\": (6, 9),\n            \"q_hot\": 1.2e6,\n            \"C\": [(5, 5), (5, 7), (5, 8), (5, 10), (10, 5), (10, 7), (10, 8), (10, 10), (7, 5), (8, 5), (7, 10), (8, 10)],\n            \"m\": 3, \"s\": 8.0e6\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        L, N, k, T_amb = case[\"L\"], case[\"N\"], case[\"k\"], case[\"T_amb\"]\n        hot_area_rows, hot_area_cols = case[\"hot_area_rows\"], case[\"hot_area_cols\"]\n        q_hot, C, m, s = case[\"q_hot\"], case[\"C\"], case[\"m\"], case[\"s\"]\n        \n        h = L / (N - 1)\n        N_int = N - 2\n        num_unknowns = N_int * N_int\n\n        # Define hot area grid and node list\n        q_hot_grid = np.zeros((N, N))\n        hot_area_nodes = []\n        for i in range(hot_area_rows[0], hot_area_rows[1] + 1):\n            for j in range(hot_area_cols[0], hot_area_cols[1] + 1):\n                q_hot_grid[i, j] = q_hot\n                if i > 0 and i < N -1 and j > 0 and j < N-1:\n                    hot_area_nodes.append((i, j))\n\n        # Construct the A matrix (sparse). This is constant for each case.\n        A = lil_matrix((num_unknowns, num_unknowns))\n        for i in range(1, N - 1):\n            for j in range(1, N - 1):\n                p = (i - 1) * N_int + (j - 1)\n                A[p, p] = 4\n                if i > 1: A[p, p - N_int] = -1\n                if i < N - 2: A[p, p + N_int] = -1\n                if j > 1: A[p, p - 1] = -1\n                if j < N - 2: A[p, p + 1] = -1\n        A_csc = A.tocsc()\n\n        min_avg_temp = float('inf')\n        \n        if m == 0:\n            sink_combinations = [[]]\n        else:\n            sink_combinations = combinations(C, m)\n\n        for sink_placement in sink_combinations:\n            q_sink_grid = np.zeros((N, N))\n            for r, c in sink_placement:\n                q_sink_grid[r, c] = s\n\n            q_total_grid = q_hot_grid - q_sink_grid\n\n            # Construct the b vector\n            b = np.zeros(num_unknowns)\n            for i in range(1, N - 1):\n                for j in range(1, N - 1):\n                    p = (i - 1) * N_int + (j - 1)\n                    \n                    source_term = (h**2 / k) * q_total_grid[i, j]\n                    \n                    boundary_term = 0\n                    if i == 1: boundary_term += T_amb\n                    if i == N - 2: boundary_term += T_amb\n                    if j == 1: boundary_term += T_amb\n                    if j == N - 2: boundary_term += T_amb\n                    \n                    b[p] = -source_term + boundary_term\n            \n            # Solve the sparse linear system\n            T_int_vec = spsolve(A_csc, b)\n            \n            # Reconstruct the full temperature grid\n            T_full = np.full((N, N), T_amb, dtype=float)\n            T_full[1:N-1, 1:N-1] = T_int_vec.reshape((N_int, N_int))\n\n            # Calculate average temperature over the hot area\n            current_hot_area_temp_sum = 0\n            for r, c in hot_area_nodes:\n                current_hot_area_temp_sum += T_full[r, c]\n            \n            avg_temp = current_hot_area_temp_sum / len(hot_area_nodes) if hot_area_nodes else T_amb\n            min_avg_temp = min(min_avg_temp, avg_temp)\n        \n        results.append(min_avg_temp)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{val:.3f}' for val in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "最后一个练习将带你进入一个更高级的领域：逆问题，这就像是扮演一名科学侦探。与根据原因预测结果不同，你将需要根据最终的温度分布（结果）来反推热源的位置（原因）。这个挑战性练习不仅要求你构建一个稳定的前向求解器，还将引导你利用该模型来解释“测量”数据，从而揭示问题的根源。这展示了计算模型在数据分析和系统辨识中的强大威力。",
            "id": "2445154",
            "problem": "您将解决一个关于薄的、均匀、各向同性的导热板中温度演化的逆问题。请以能量守恒和 Fourier 热传导定律为基本出发点。考虑一个边长为 $L$ 的方形板，其热扩散系数 $\\alpha$ 为常数，边界温度在所有时刻始终保持为零，且初始温度也为零。一个位置未知的恒定点热源从时间 $t=0$ 开始以恒定速率注入热量，直到最终时间 $t=T$。该板在二维空间中建模，且足够薄，以至于可以忽略平面外的热传导。目标是仅根据时间 $t=T$ 时的最终温度场来确定热源的网格位置。\n\n您的程序必须在纯数学术语中实现以下流程：\n- 从能量平衡和 Fourier 定律出发，推导二维热方程的一致离散演化形式，并在覆盖方形区域 $[0,L]\\times[0,L]$ 的 $N_x \\times N_x$ 节点的均匀网格上，使用一个无条件稳定的时间推进格式，边界条件为在 $x=0$、$x=L$、$y=0$ 和 $y=L$ 处为零 Dirichlet 边界条件。\n- 将恒定点源表示为某个未知内部网格节点上的单个节点强迫项。该节点强迫项的振幅在时间上是恒定的，但在其他方面是未知的。\n- 利用离散演化的线性结构，构建一个逆估计器。对于每个候选内部节点，该估计器计算测量得到的最终场与该节点上具有最优恒定振幅的热源所产生的预测场之间的最小二乘残差。选择使该残差最小的节点。\n\n下面的测试套件指定了参数集和真实源位置。对于每个测试用例，您必须：\n- 在均匀网格上构建离散算子。\n- 通过求解正问题在内部生成“测量”的最终温度场。求解时使用相同的离散模型、零初始条件，并在整个积分区间内，在真实源位置施加指定的恒定振幅的恒定热源。\n- 通过解决上述逆选择问题来恢复源位置。\n\n不要使用任何外部输入。使用从零开始的索引，原点位于左下角。以整数网格索引 $(i_x,i_y)$ 的形式报告源在大小为 $N_x \\times N_x$ 的完整网格上的位置，其中 $i_x \\in \\{0,1,\\dots,N_x-1\\}$ 随着 $x$ 从左到右递增，$i_y \\in \\{0,1,\\dots,N_x-1\\}$ 随着 $y$ 从下到上递增。热源将始终严格位于内部，即 $1 \\le i_x \\le N_x-2$ 且 $1 \\le i_y \\le N_x-2$。您的输出中不需要物理单位。\n\n测试套件（五个案例）：\n- 案例 1：$L=1$，$N_x=25$，$\\alpha=10^{-3}$，时间步长 $\\Delta t=2\\times 10^{-2}$，步数 $N_t=200$，源振幅 $q=1$，真实源位置 $(i_x,i_y)=(12,9)$。\n- 案例 2：$L=1$，$N_x=25$，$\\alpha=2\\times 10^{-3}$，时间步长 $\\Delta t=1.5\\times 10^{-2}$，步数 $N_t=160$，源振幅 $q=0.8$，真实源位置 $(i_x,i_y)=(1,7)$。\n- 案例 3：$L=1$，$N_x=21$，$\\alpha=5\\times 10^{-4}$，时间步长 $\\Delta t=10^{-2}$，步数 $N_t=80$，源振幅 $q=1.2$，真实源位置 $(i_x,i_y)=(10,10)$。\n- 案例 4：$L=1$，$N_x=27$，$\\alpha=1.5\\times 10^{-3}$，时间步长 $\\Delta t=10^{-2}$，步数 $N_t=150$，源振幅 $q=0.5$，真实源位置 $(i_x,i_y)=(2,2)$。\n- 案例 5：$L=1$，$N_x=17$，$\\alpha=10^{-3}$，时间步长 $\\Delta t=2.5\\times 10^{-2}$，步数 $N_t=60$，源振幅 $q=1$，真实源位置 $(i_x,i_y)=(8,1)$。\n\n最终输出格式：\n- 您的程序应生成单行文本，其中包含五个案例的估计源位置列表，按顺序排列，格式为包含5个项目的逗号分隔列表，每个项目是一个包含两个整数的列表 $[i_x,i_y]$。例如，输出格式必须与 $[[i_{x,1},i_{y,1}],[i_{x,2},i_{y,2}],[i_{x,3},i_{y,3}],[i_{x,4},i_{y,4}],[i_{x,5},i_{y,5}]]$ 完全一样。",
            "solution": "该问题经评估在科学上是合理的、适定的和自洽的。这是一个计算物理学中的标准逆问题，基于热传递的基本原理。所有必要的参数和条件均已提供。我现在将开始求解。\n\n均匀、各向同性导热板中的温度演化由二维热方程控制。我们首先推导其离散形式。\n\n**1. 控制方程与离散化**\n\n推导从应用于板内微小控制体积 $d A=dx\\,dy$ 的能量守恒原理开始。热能的时间变化率必须等于流入该体积的净热流加上内部产生的任何热量。这表示为：\n$$\n\\rho c_p \\frac{\\partial u}{\\partial t} = -\\nabla \\cdot \\mathbf{q} + Q\n$$\n其中 $u(x,y,t)$ 是温度场，$\\rho$ 是密度，$c_p$ 是比热容，$\\mathbf{q}$ 是热通量矢量，$Q$ 是体热源密度。Fourier 热传导定律将热通量与温度梯度联系起来：$\\mathbf{q} = -k \\nabla u$，其中 $k$ 是热导率。对于性质恒定的均匀材料，代入可得：\n$$\n\\rho c_p \\frac{\\partial u}{\\partial t} = \\nabla \\cdot (k \\nabla u) + Q = k \\nabla^2 u + Q\n$$\n两边除以 $\\rho c_p$ 并定义热扩散系数 $\\alpha = k/(\\rho c_p)$ 和源项 $S = Q/(\\rho c_p)$（单位为温度/时间），我们得到标准热方程：\n$$\n\\frac{\\partial u}{\\partial t} = \\alpha \\nabla^2 u + S(x,y,t)\n$$\n我们使用一个包含 $N_x \\times N_x$ 个节点的均匀网格对空间域 $[0,L]\\times[0,L]$ 进行离散化。网格间距为 $\\Delta x = \\Delta y = h = L/(N_x-1)$。令 $u_{i,j}^n$ 表示在时间 $t_n = n\\Delta t$ 时，网格点 $(x_i, y_j) = (ih, jh)$ 处的温度。拉普拉斯算子 $\\nabla^2$ 使用五点中心差分格式进行近似：\n$$\n\\nabla^2 u \\Big|_{(i,j)} \\approx \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h^2} + \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h^2}\n$$\n\n**2. 时间离散化与矩阵表示**\n\n为确保所要求的无条件稳定性，我们使用隐式时间推进格式。选择后向 Euler 方法因其简单性和稳定性。该方法在未来的时间步 $n+1$ 处计算空间导数：\n$$\n\\frac{u_{i,j}^{n+1} - u_{i,j}^n}{\\Delta t} = \\alpha \\left( \\frac{u_{i+1,j}^{n+1} + u_{i-1,j}^{n+1} + u_{i,j+1}^{n+1} + u_{i,j-1}^{n+1} - 4u_{i,j}^{n+1}}{h^2} \\right) + S_{i,j}^{n+1}\n$$\n重新排列各项，将时间 $n+1$ 的未知数置于左侧，我们得到每个内部网格点 $(i,j)$ 的一个线性方程，其中 $i,j \\in \\{1, \\dots, N_x-2\\}$：\n$$\n(1 + 4c)u_{i,j}^{n+1} - c(u_{i+1,j}^{n+1} + u_{i-1,j}^{n+1} + u_{i,j+1}^{n+1} + u_{i,j-1}^{n+1}) = u_{i,j}^n + \\Delta t S_{i,j}^{n+1}\n$$\n其中 $c = \\alpha \\Delta t / h^2$ 是扩散数。零 Dirichlet 边界条件（在所有边界上 $u=0$）被隐式处理，因为任何索引在边界上的项 $u^{n+1}$ 都为零，并从方程中消失。\n\n这个由 $(N_x-2)^2$ 个线性方程组成的系统必须在每个时间步求解。我们可以将其表示为矩阵形式。设 $\\mathbf{u}^n$ 是一个大小为 $N_{int} = (N_x-2)^2$ 的向量，表示所有内部节点的温度，并被展平为一个单列。该系统变为：\n$$\n\\mathbf{A} \\mathbf{u}^{n+1} = \\mathbf{u}^n + \\Delta t \\mathbf{S}^{n+1}\n$$\n矩阵 $\\mathbf{A}$ 是一个表示离散隐式算子的稀疏块三对角矩阵。它不随时间变化。向量 $\\mathbf{S}^{n+1}$ 代表节点源强迫项。由于热源在时间和空间上是恒定的（位于单个节点），我们可以写成 $\\mathbf{S}^{n+1} = q \\, \\mathbf{e}_{k_s}$，其中 $k_s$ 是源节点的展平索引，$\\mathbf{e}_{k_s}$ 是对应的标准基向量，$q$ 是源振幅。\n\n**3. 正问题求解**\n\n正问题在于，给定初始条件 $\\mathbf{u}^0 = \\mathbf{0}$ 以及已知位置 $k_s$ 和振幅 $q$ 的热源，求解最终温度场 $\\mathbf{u}_{final} = \\mathbf{u}^{N_t}$。时间演化通过迭代求解以下线性系统来计算：\n$$\n\\mathbf{u}^{n+1} = \\mathbf{A}^{-1}(\\mathbf{u}^n + q \\Delta t \\, \\mathbf{e}_{k_s})\n$$\n对于 $n=0, \\dots, N_t-1$。为了高效地执行此操作，矩阵 $\\mathbf{A}$ 只需分解一次（例如，使用 LU 分解），然后在每个时间步通过前向和后向代入重复使用该分解来求解 $\\mathbf{u}^{n+1}$。此过程用于使用每个测试用例中提供的真实源参数来生成“测量的”最终温度场 $\\mathbf{u}_{meas}$。\n\n**4. 逆问题构建**\n\n逆问题的目标是在给定 $\\mathbf{u}_{meas}$ 的情况下找到源位置 $k_s$。源振幅 $q$ 也是未知的。该问题被构建为对所有可能的内部节点进行搜索。对于每个候选源位置 $k_c$，我们找到在最小二乘意义上能最好地解释测量数据的最优源振幅。\n\n设 $\\mathbf{U}_{k_c}$ 是由位于 $k_c$ 的单位源（$q=1$）产生的最终温度场，使用相同的正向模型计算得出。由于线性关系，位于 $k_c$ 处振幅为 $q_c$ 的源所预测的场为 $\\mathbf{u}_{pred} = q_c \\mathbf{U}_{k_c}$。我们必须找到使残差最小化的 $k_c$ 和 $q_c$：\n$$\nR(k_c, q_c) = \\| \\mathbf{u}_{meas} - q_c \\mathbf{U}_{k_c} \\|_2^2\n$$\n对于一个固定的候选位置 $k_c$，最优振幅 $q_c^*$ 可以通过将 $R$ 对 $q_c$ 的导数设为零来找到：\n$$\n\\frac{\\partial R}{\\partial q_c} = 0 \\implies q_c^* = \\frac{\\mathbf{U}_{k_c}^T \\mathbf{u}_{meas}}{\\mathbf{U}_{k_c}^T \\mathbf{U}_{k_c}} = \\frac{\\langle \\mathbf{U}_{k_c}, \\mathbf{u}_{meas} \\rangle}{\\| \\mathbf{U}_{k_c} \\|_2^2}\n$$\n这个最优振幅是 $\\mathbf{u}_{meas}$ 在基向量 $\\mathbf{U}_{k_c}$ 上的标量投影。\n\n**5. 算法流程**\n\n最终估计的源位置是代入其最优振幅后使残差最小化的候选节点：\n$$\nk_{est} = \\arg\\min_{k_c} \\| \\mathbf{u}_{meas} - q_c^*(k_c) \\, \\mathbf{U}_{k_c} \\|_2^2\n$$\n完整的算法如下：\n1.  **生成数据**：对于每个测试用例，构建矩阵 $\\mathbf{A}$。使用真实的源参数模拟 $N_t$ 个时间步的温度演化，以生成测量向量 $\\mathbf{u}_{meas}$。\n2.  **迭代和测试候选点**：遍历每个内部网格节点 $(i_c, j_c)$ 作为候选源位置。\n    a.  对于每个候选点 $(i_c, j_c)$，在该位置使用单位源（$q=1$）模拟正问题，以计算相应的最终温度分布 $\\mathbf{U}_{k_c}$。\n    b.  使用推导出的投影公式计算最优源振幅 $q_c^*$。\n    c.  计算 $\\mathbf{u}_{meas}$ 与预测值 $q_c^* \\mathbf{U}_{k_c}$ 之间残差的 L2 范数平方。\n3.  **选择最佳拟合**：估计的源位置是产生最小残差的候选点 $(i_c, j_c)$。程序为每个指定的测试用例实现此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import diags\nfrom scipy.sparse.linalg import splu\n\ndef solve():\n    \"\"\"\n    Main function to solve the inverse heat source problem for all test cases.\n    \"\"\"\n    test_cases = [\n        {'L': 1, 'Nx': 25, 'alpha': 1e-3, 'dt': 2e-2, 'Nt': 200, 'q': 1, 'true_loc': (12, 9)},\n        {'L': 1, 'Nx': 25, 'alpha': 2e-3, 'dt': 1.5e-2, 'Nt': 160, 'q': 0.8, 'true_loc': (1, 7)},\n        {'L': 1, 'Nx': 21, 'alpha': 5e-4, 'dt': 1e-2, 'Nt': 80, 'q': 1.2, 'true_loc': (10, 10)},\n        {'L': 1, 'Nx': 27, 'alpha': 1.5e-3, 'dt': 1e-2, 'Nt': 150, 'q': 0.5, 'true_loc': (2, 2)},\n        {'L': 1, 'Nx': 17, 'alpha': 1e-3, 'dt': 2.5e-2, 'Nt': 60, 'q': 1, 'true_loc': (8, 1)},\n    ]\n\n    results = []\n    for case in test_cases:\n        estimated_loc = find_source_location(**case)\n        results.append(list(estimated_loc))\n\n    formatted_results = [f'[{r[0]},{r[1]}]' for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef run_forward_simulation(solver, Nt, dt, source_amplitude, source_k, N_int):\n    \"\"\"\n    Simulates the heat equation forward in time.\n    \n    Args:\n        solver: Pre-factorized sparse matrix solver (from splu).\n        Nt: Number of time steps.\n        dt: Time step size.\n        source_amplitude: The 'q' value for the source.\n        source_k: The flattened index of the source node.\n        N_int: Total number of interior nodes.\n\n    Returns:\n        The final temperature field as a 1D numpy array.\n    \"\"\"\n    f_vec = np.zeros(N_int)\n    if source_k is not None:\n        f_vec[source_k] = source_amplitude * dt\n\n    u_n = np.zeros(N_int)\n    for _ in range(Nt):\n        b = u_n + f_vec\n        u_n = solver.solve(b)\n    \n    return u_n\n\ndef find_source_location(L, Nx, alpha, dt, Nt, q, true_loc):\n    \"\"\"\n    Finds the heat source location for a single test case.\n    \"\"\"\n    # 1. Setup grid and parameters\n    h = L / (Nx - 1)\n    c = alpha * dt / h**2\n    N_int_dim = Nx - 2\n    N_int = N_int_dim**2\n\n    # 2. Build the sparse matrix A for the implicit scheme (I - c*L)\n    M = N_int_dim\n    N = M * M\n    main_diag = np.full(N, 1 + 4 * c)\n    sub_diag = np.full(N - 1, -c)\n    sup_diag = np.full(N - 1, -c)\n    # Remove fictitious connections between grid rows\n    sub_diag[M-1::M] = 0\n    sup_diag[M-1::M] = 0\n    lower_M_diag = np.full(N - M, -c)\n    upper_M_diag = np.full(N - M, -c)\n    \n    diagonals_data = [upper_M_diag, sup_diag, main_diag, sub_diag, lower_M_diag]\n    offsets = [M, 1, 0, -1, -M]\n    A = diags(diagonals_data, offsets, shape=(N, N), format='csc')\n    \n    # Pre-factorize the matrix for efficient solves\n    solver = splu(A)\n\n    # 3. Generate \"measured\" data by solving the forward problem with true parameters\n    k_true = (true_loc[0] - 1) + (true_loc[1] - 1) * N_int_dim\n    u_meas = run_forward_simulation(solver, Nt, dt, q, k_true, N_int)\n\n    # 4. Inverse search for the source location\n    min_residual = float('inf')\n    best_location = None\n    \n    # Iterate through all possible interior nodes as candidates\n    for j_c in range(1, Nx - 1):\n        for i_c in range(1, Nx - 1):\n            k_c = (i_c - 1) + (j_c - 1) * N_int_dim\n            \n            # a. Simulate the final field for a unit source at the candidate location\n            U_kc = run_forward_simulation(solver, Nt, dt, 1.0, k_c, N_int)\n            \n            dot_Ukc_Ukc = np.dot(U_kc, U_kc)\n            # If the response is negligible, this is not a viable candidate\n            if dot_Ukc_Ukc < 1e-30:\n                continue\n\n            # b. Calculate the optimal source amplitude and the corresponding residual\n            q_star = np.dot(U_kc, u_meas) / dot_Ukc_Ukc\n            residual = np.sum((u_meas - q_star * U_kc)**2)\n\n            # c. Update the best-fit location if the current candidate is better\n            if residual < min_residual:\n                min_residual = residual\n                best_location = (i_c, j_c)\n                \n    return best_location\n\nsolve()\n```"
        }
    ]
}