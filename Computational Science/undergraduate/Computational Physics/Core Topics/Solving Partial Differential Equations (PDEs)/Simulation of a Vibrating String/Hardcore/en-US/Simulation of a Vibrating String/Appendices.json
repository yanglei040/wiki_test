{
    "hands_on_practices": [
        {
            "introduction": "Before we can accurately simulate the dynamics of a vibrating string, we must first master the tools for describing its shape. This practice focuses on the cornerstone of finite difference methods: the approximation of spatial derivatives. By comparing a standard second-order method with a more sophisticated fourth-order one, you will gain a quantitative understanding of numerical accuracy and see firsthand how a wider stencil can dramatically improve the fidelity of your simulation for a given grid resolution .",
            "id": "2438535",
            "problem": "Consider the small transverse vibrations of an ideal, taut, uniform string on a one-dimensional closed loop of length $L$, so that the displacement $u(x,t)$ is periodic in space with period $L$. The spatial operator governing the restoring force is the second spatial derivative $\\partial^2 u / \\partial x^2$. On a uniform grid of $N$ points with spacing $\\Delta x = L/N$ and periodic boundary conditions, approximate the action of the spatial operator on a smooth periodic function $u(x)$ by constructing two discrete approximation operators for $\\partial^2 u / \\partial x^2$: one that is second-order accurate in $\\Delta x$ and one that is fourth-order accurate in $\\Delta x$. For each approximation, quantify the error against the exact second derivative using the root-mean-square (RMS) error over the grid. Angles used within trigonometric functions must be interpreted in radians.\n\nDefine the test function by $u(x) = \\sin(k x)$, where $k = 2\\pi m / L$ for an integer mode number $m \\ge 1$. The exact second derivative is $\\partial^2 u / \\partial x^2 = -k^2 \\sin(k x)$. For each specified parameter set $(L, m, N)$, compute the RMS error of the second-order approximation, $E_2$, and of the fourth-order approximation, $E_4$, and then compute the improvement factor $I = E_2 / E_4$ for that parameter set.\n\nYour program must implement these computations for each parameter set in the following test suite, where all quantities are real numbers and integers as indicated:\n- Test $1$: $L = 1.0$, $m = 3$, $N = 256$.\n- Test $2$: $L = 1.0$, $m = 1$, $N = 5$.\n- Test $3$: $L = 2.0$, $m = 7$, $N = 64$.\n- Test $4$: $L = 2.0$, $m = 15$, $N = 64$.\n\nFor each test, use the uniform grid $x_j = j \\Delta x$ for $j = 0, 1, \\dots, N-1$ with $\\Delta x = L/N$ and periodic boundary conditions. For each test, compute the improvement factor $I$ as a floating-point number. The final program output must be a single line containing a comma-separated list of the four improvement factors, enclosed in square brackets, with each number rounded to eight decimal places (for example, $[1.23456789,2.34567891,3.45678912,4.56789123]$). No other text should be printed. All computed quantities in this problem are dimensionless, so no physical units are required in the output.",
            "solution": "The problem statement is scientifically grounded, well-posed, objective, and self-contained. It presents a standard exercise in computational physics: the comparison of numerical differentiation schemes. All required parameters and definitions are provided. The problem is valid.\n\nThe central task is to quantify the improvement in accuracy when moving from a second-order to a fourth-order finite difference approximation for the second spatial derivative $\\frac{\\partial^2 u}{\\partial x^2}$. This is done in the context of a periodic domain, which simplifies the application of the finite difference stencils.\n\nFirst, we establish the discrete domain and the finite difference operators. The problem is defined on a one-dimensional periodic domain of length $L$. We discretize this domain into a uniform grid of $N$ points, $x_j = j \\Delta x$ for $j = 0, 1, \\dots, N-1$, where the grid spacing is $\\Delta x = L/N$. The periodic boundary condition implies that $u_{j+N} = u_j$ for any integer $j$.\n\nThe second derivative of a function $u(x)$ at a grid point $x_j$ can be approximated using its neighbors. The stencils for the required operators are derived from Taylor series expansions.\n\nThe second-order accurate central difference approximation, $(D_2 u)_j$, is given by:\n$$ (D_2 u)_j = \\frac{u_{j+1} - 2u_j + u_{j-1}}{(\\Delta x)^2} $$\nThe leading error term of this approximation is proportional to $(\\Delta x)^2$, hence it is a second-order method.\n\nThe fourth-order accurate central difference approximation, $(D_4 u)_j$, requires a wider five-point stencil:\n$$ (D_4 u)_j = \\frac{-u_{j+2} + 16u_{j+1} - 30u_j + 16u_{j-1} - u_{j-2}}{12(\\Delta x)^2} $$\nThe leading error term here is proportional to $(\\Delta x)^4$, resulting in a more accurate fourth-order method, particularly for sufficiently small $\\Delta x$.\n\nThe problem specifies a test function $u(x) = \\sin(kx)$, where the wavenumber $k = 2\\pi m / L$ is determined by the integer mode number $m \\ge 1$. The choice of a sinusoidal function is ideal because it is an eigenfunction of the spatial differentiation operator. The exact second derivative is trivial to compute analytically:\n$$ \\frac{\\partial^2 u}{\\partial x^2} = -k^2 \\sin(kx) $$\n\nTo perform the computation, we first evaluate the test function $u(x)$ and its exact second derivative on the discrete grid, obtaining the vectors $u_j = \\sin(k x_j)$ and $(u''_{\\text{exact}})_j = -k^2 u_j$.\n\nNext, we apply the discrete operators $D_2$ and $D_4$ to the vector $u_j$. The periodic boundary conditions are handled by treating the indices modulo $N$. For example, the value at index $j-1$ for $j=0$ is $u_{-1} = u_{N-1}$, and the value at index $j+1$ for $j=N-1$ is $u_N = u_0$. This wrap-around indexing can be implemented efficiently using a circular shift or roll operation on the vector $u_j$.\n\nWith the exact derivative $(u''_{\\text{exact}})_j$ and the two approximations, $(D_2 u)_j$ and $(D_4 u)_j$, we can quantify the error of each scheme. The problem requires the root-mean-square (RMS) error, which is computed for the second-order scheme as:\n$$ E_2 = \\sqrt{\\frac{1}{N} \\sum_{j=0}^{N-1} \\left( (D_2 u)_j - (u''_{\\text{exact}})_j \\right)^2} $$\nAnd similarly for the fourth-order scheme:\n$$ E_4 = \\sqrt{\\frac{1}{N} \\sum_{j=0}^{N-1} \\left( (D_4 u)_j - (u''_{\\text{exact}})_j \\right)^2} $$\n\nFinally, the improvement factor, $I$, is the ratio of these errors:\n$$ I = \\frac{E_2}{E_4} $$\nThis dimensionless factor measures how many times more accurate the fourth-order scheme is compared to the second-order one for the given set of parameters $(L, m, N)$. The computational procedure involves calculating this factor for each of the four specified test cases. The implementation will use `numpy` for efficient array operations, particularly `numpy.roll` for handling the periodic boundary conditions.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the improvement factor of a fourth-order finite difference scheme over a\n    second-order scheme for approximating the second derivative of a sine function\n    on a periodic grid.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (L, m, N)\n        (1.0, 3, 256),\n        (1.0, 1, 5),\n        (2.0, 7, 64),\n        (2.0, 15, 64),\n    ]\n\n    results = []\n    for L, m, N in test_cases:\n        # 1. Define grid and function parameters\n        delta_x = L / N\n        k = 2.0 * np.pi * m / L\n        \n        # 2. Evaluate the function and its exact second derivative on the grid\n        x_grid = np.arange(N) * delta_x\n        u = np.sin(k * x_grid)\n        u_xx_exact = -k**2 * u\n        \n        # 3. Compute the second-order approximation\n        # The stencil is [1, -2, 1] / dx^2\n        # np.roll handles periodic boundary conditions\n        u_jp1 = np.roll(u, -1)\n        u_jm1 = np.roll(u, 1)\n        u_xx_2 = (u_jp1 - 2.0 * u + u_jm1) / delta_x**2\n        \n        # 4. Compute the fourth-order approximation\n        # The stencil is [-1, 16, -30, 16, -1] / (12 * dx^2)\n        u_jp2 = np.roll(u, -2)\n        u_jm2 = np.roll(u, 2)\n        u_xx_4 = (-u_jp2 + 16.0 * u_jp1 - 30.0 * u + 16.0 * u_jm1 - u_jm2) / (12.0 * delta_x**2)\n        \n        # 5. Calculate the Root-Mean-Square (RMS) error for each approximation\n        error_2 = u_xx_2 - u_xx_exact\n        E2 = np.sqrt(np.mean(error_2**2))\n        \n        error_4 = u_xx_4 - u_xx_exact\n        E4 = np.sqrt(np.mean(error_4**2))\n        \n        # 6. Compute the improvement factor I = E2 / E4\n        # If E4 is extremely close to zero, this could be a large number, which is expected.\n        # The problem setup ensures E4 is not exactly zero for the given test cases.\n        improvement_factor = E2 / E4\n        results.append(improvement_factor)\n\n    # Final print statement in the exact required format.\n    # Each number is rounded to eight decimal places.\n    print(f\"[{','.join([f'{r:.8f}' for r in results])}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "With a solid understanding of spatial discretization, we can now build a complete time-evolving simulation. This exercise challenges you to model one of the most fundamental phenomena in wave physics: interference. You will set up two counter-propagating Gaussian wave packets and observe how they superpose, verifying the principles of constructive and destructive interference, as well as the conservation of energy in a closed system . This is a quintessential computational physics problem that combines numerical implementation with physical verification.",
            "id": "2438583",
            "problem": "You are to derive, implement, and test a numerical simulation of a taut, uniform string subject to small transverse vibrations, in which two localized Gaussian wave packets travel in opposite directions, superpose, and interfere. Your program must implement an explicit finite-difference time-domain scheme for the one-dimensional wave equation with fixed-end boundary conditions. The program must run without user input and must output a single line containing the results for the specified test suite.\n\nPhysical and mathematical base:\n- Start from Newton’s second law applied to a uniformly dense string: a small segment of linear mass density $\\mu$ subject to nearly horizontal tension $T$ yields the continuum equation $\\mu \\partial^2 u / \\partial t^2 = T \\partial^2 u / \\partial x^2$, where $u(x,t)$ is the transverse displacement. Define the wave speed $c$ by $c^2 = T/\\mu$ to obtain the wave equation $\\partial^2 u / \\partial t^2 = c^2 \\partial^2 u / \\partial x^2$.\n- Impose fixed-end (Dirichlet) boundary conditions $u(0,t)=0$ and $u(L,t)=0$, with $L$ the string length.\n- Use a uniform spatial grid with spacing $\\Delta x$ and a uniform time step $\\Delta t$ satisfying the Courant–Friedrichs–Lewy (CFL) condition for stability.\n- Discretize the wave equation using centered second-order differences in space and time, producing an explicit update for $u_i^{n+1}$ in terms of $u_i^n$ and $u_i^{n-1}$, where $u_i^n$ approximates $u(x_i, t_n)$ at $x_i = i \\Delta x$ and $t_n = n \\Delta t$. Derive the second-order accurate first-step formula for $u_i^1$ from a Taylor expansion using the initial velocity $v(x)=\\partial u/\\partial t(x,0)$.\n- Choose the initial displacement $u(x,0)$ to be the sum of two Gaussian profiles centered at $x=x_1$ and $x=x_2$ with amplitudes $A_1$ and $A_2$ and widths $\\sigma_1$ and $\\sigma_2$. Choose the initial velocity $v(x)$ so that the first Gaussian travels to the right with speed $c$ and the second Gaussian travels to the left with speed $c$. Derive the needed $v(x)$ explicitly in terms of $u(x,0)$ constructed from the two Gaussians and their spatial derivatives. Do not use any shortcut formulas beyond the fundamental laws and definitions described above; derive what you need from first principles and standard calculus.\n- The total mechanical energy of the string (per unit width out of plane) is $E(t) = \\int_0^L \\tfrac{1}{2}\\left[(\\partial u/\\partial t)^2 + c^2 (\\partial u/\\partial x)^2\\right] \\, dx$. For fixed ends and no external forcing, $E(t)$ should be approximately conserved in the numerical simulation as long as wave packets do not reach the boundaries during the simulated time.\n\nNumerical specifications:\n- Use units of meters for $x$ and $u$, and seconds for $t$. The wave speed $c$ is in meters per second. All reported displacement quantities and errors must be in meters. Any reported energy changes are dimensionless ratios. No angles are involved.\n- Use a spatial grid of $N_x$ points on $[0,L]$ with $x_i = i \\Delta x$, where $\\Delta x = L/(N_x-1)$.\n- Use a time step $\\Delta t$ satisfying $0  \\lambda \\le 1$, where $\\lambda = c \\Delta t / \\Delta x$ is the Courant number. Use $\\lambda$ strictly less than $1$ for stability. Define and use a specific $\\lambda$ of your choice in your implementation, and compute $\\Delta t$ accordingly.\n\nObservables to compute:\n- Let $t_\\star$ be the time when the centers of the two Gaussian wave packets coincide, and let $x_\\star$ be the collision location. Compute the simulated string displacement at $(x_\\star, t_\\star)$ by temporal interpolation if $t_\\star$ does not land exactly on a time step and by using the nearest grid point to $x_\\star$ if $x_\\star$ is not exactly a grid point. Report the absolute error at the collision for two test cases: one with constructive interference (both amplitudes positive) and one with destructive interference (opposite-sign amplitudes). Errors must be in meters.\n- For a third test case (different parameter set), compute the relative change in total energy between $t=0$ and $t=t_\\star$, defined as $|E(t_\\star)-E(0)|/E(0)$, and report whether this relative change is strictly less than a chosen tolerance (return a boolean). Choose the simulation parameters and $t_\\star$ so that the wave packets remain well separated from the boundaries for $0 \\le t \\le t_\\star$.\n\nTest suite:\nProvide three parameter sets. In each case, the domain is $[0,L]$ with $L$ in meters, wave speed $c$ in meters per second, and Gaussian parameters in meters.\n- Case A (constructive interference):\n  - $L = 1.0$, $c = 1.0$, $A_1 = 0.010$, $A_2 = 0.020$, $\\sigma_1 = 0.050$, $\\sigma_2 = 0.050$, $x_1 = 0.300$, $x_2 = 0.700$.\n  - The expected collision occurs at $t_\\star = (x_2 - x_1)/(2c)$ and $x_\\star = (x_1 + x_2)/2$. The expected displacement at $(x_\\star, t_\\star)$ is $A_1 + A_2$. Your program must output the absolute error in meters for this case as the first number.\n- Case B (destructive interference):\n  - $L = 1.0$, $c = 1.0$, $A_1 = 0.015$, $A_2 = -0.015$, $\\sigma_1 = 0.040$, $\\sigma_2 = 0.040$, $x_1 = 0.350$, $x_2 = 0.650$.\n  - The expected displacement at $(x_\\star, t_\\star)$ is $0.0$. Your program must output the absolute error in meters for this case as the second number.\n- Case C (energy check):\n  - $L = 1.0$, $c = 1.0$, $A_1 = 0.010$, $A_2 = 0.013$, $\\sigma_1 = 0.030$, $\\sigma_2 = 0.070$, $x_1 = 0.250$, $x_2 = 0.750$.\n  - Compute the relative energy change $|E(t_\\star)-E(0)|/E(0)$ at $t_\\star = (x_2 - x_1)/(2c)$ and return a boolean that is true if this value is strictly less than a tolerance of $0.02$ and false otherwise. This boolean must be the third output.\n\nImplementation requirements:\n- Use a second-order accurate explicit scheme in time and space, enforce $u(0,t)=0$ and $u(L,t)=0$ at all time steps, and initialize $u(x,0)$ as the sum of the two Gaussians. Derive and implement $v(x)=\\partial u/\\partial t(x,0)$ so that the first Gaussian travels rightward with speed $c$ and the second travels leftward with speed $c$.\n- Use a Courant number $\\lambda$ strictly less than $1$ for stability. Explicitly compute $\\Delta t$ from $\\lambda$, $c$, and $\\Delta x$.\n- Compute $E(0)$ using $v(x)$ and the spatial gradient of $u(x,0)$, and compute $E(t_\\star)$ using a consistent discrete approximation to $\\partial u/\\partial t$ and $\\partial u/\\partial x$ at $t_\\star$. Ensure that the simulated time span does not allow the packets to interact with the boundaries for any test case.\n- Your program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order: Case A error (meters), Case B error (meters), Case C energy-conservation boolean. For example: \"[0.00012,0.00003,True]\". Do not print any other text.\n\nAssumptions and constraints:\n- Use $N_x$ sufficiently large that $x_\\star$ lies on or very near a grid point and the Gaussians are well resolved. You must ensure $\\lambda \\in (0,1)$ and that $t_\\star$ is reached by the time integration for each case.\n- All floating-point outputs are to be given as raw decimal numbers; do not append units in the printed output. Internally, all quantities must be handled with the physically correct units as specified above.",
            "solution": "We begin from Newton’s second law applied to a differential element of a taut uniform string. Let $\\mu$ be the linear mass density (mass per unit length) and $T$ the constant tension. For small transverse displacements $u(x,t)$, the vertical force due to tension is $T \\partial^2 u / \\partial x^2 \\, \\mathrm{d}x$, which equals the element’s mass $\\mu \\, \\mathrm{d}x$ times its vertical acceleration $\\partial^2 u / \\partial t^2$. Dividing by $\\mu \\, \\mathrm{d}x$ yields the standard wave equation\n$$\n\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}, \\quad c^2 = \\frac{T}{\\mu}.\n$$\nWe impose fixed ends $u(0,t)=0$ and $u(L,t)=0$, and choose initial conditions $u(x,0) = u_0(x)$ and $u_t(x,0)=v_0(x)$ to launch two oppositely traveling Gaussian wave packets.\n\nFinite-difference scheme:\nDiscretize space on a uniform grid $x_i = i \\Delta x$, $i=0,\\dots,N_x-1$ with $\\Delta x = L/(N_x-1)$, and time $t_n = n \\Delta t$, $n=0,1,2,\\dots$. Denote $u_i^n \\approx u(x_i,t_n)$. Use centered differences in space and time. The wave equation becomes\n$$\n\\frac{u_i^{n+1} - 2 u_i^n + u_i^{n-1}}{\\Delta t^2} = c^2 \\frac{u_{i+1}^n - 2 u_i^n + u_{i-1}^n}{\\Delta x^2},\n$$\nor equivalently the explicit update\n$$\nu_i^{n+1} = 2 u_i^n - u_i^{n-1} + \\lambda^2 \\left(u_{i+1}^n - 2 u_i^n + u_{i-1}^n \\right), \\quad \\lambda = \\frac{c \\Delta t}{\\Delta x}.\n$$\nThe Courant–Friedrichs–Lewy (CFL) condition requires $0\\lambda \\le 1$ for stability; we choose $\\lambda  1$ strictly. Fixed ends are enforced by setting $u_0^n = 0$ and $u_{N_x-1}^n = 0$ for all $n$.\n\nInitialization:\nWe require $u_i^0 = u_0(x_i)$ and $u_i^1$ to start the recurrence. A second-order Taylor expansion in time gives\n$$\nu(x,t+\\Delta t) = u(x,t) + \\Delta t \\, u_t(x,t) + \\frac{\\Delta t^2}{2} \\, u_{tt}(x,t) + \\mathcal{O}(\\Delta t^3).\n$$\nUsing the wave equation $u_{tt} = c^2 u_{xx}$ and the centered spatial Laplacian, we obtain the second-order accurate first step\n$$\nu_i^1 = u_i^0 + \\Delta t \\, v_0(x_i) + \\frac{\\lambda^2}{2}\\left(u_{i+1}^0 - 2 u_i^0 + u_{i-1}^0\\right),\n$$\nwith boundary enforcement $u_0^1 = u_{N_x-1}^1 = 0$.\n\nConstructing counter-propagating Gaussians:\nWe define two Gaussian profiles\n$$\nf(x) = A_1 \\exp\\!\\left(-\\frac{(x - x_1)^2}{2 \\sigma_1^2}\\right), \\quad\ng(x) = A_2 \\exp\\!\\left(-\\frac{(x - x_2)^2}{2 \\sigma_2^2}\\right),\n$$\nand set the initial displacement to their sum $u_0(x) = f(x) + g(x)$. To make $f$ propagate rightward at speed $c$ and $g$ propagate leftward at speed $c$, we use the d’Alembert decomposition derived from the wave equation’s linearity and invariance: $u(x,t) = F(x - c t) + G(x + c t)$, where $F$ and $G$ are determined by initial data. Matching to $u_0(x) = f(x) + g(x)$ gives $F(x) = f(x)$ and $G(x) = g(x)$. Differentiating in time at $t=0$ yields\n$$\nv_0(x) = \\left.\\frac{\\partial u}{\\partial t}\\right|_{t=0} = - c F'(x) + c G'(x) = - c f'(x) + c g'(x).\n$$\nFor the Gaussian derivative,\n$$\n\\frac{d}{dx}\\left[A \\exp\\!\\left(-\\frac{(x - x_0)^2}{2 \\sigma^2}\\right)\\right]\n= - A \\frac{x - x_0}{\\sigma^2} \\exp\\!\\left(-\\frac{(x - x_0)^2}{2 \\sigma^2}\\right).\n$$\nThus we construct $v_0(x) = - c f'(x) + c g'(x)$ explicitly from the above expression.\n\nCollision time and location:\nThe centers of $f$ and $g$ are at $x_f(t) = x_1 + c t$ and $x_g(t) = x_2 - c t$. They meet when $x_f(t_\\star) = x_g(t_\\star)$, giving $t_\\star = (x_2 - x_1)/(2 c)$ and $x_\\star = (x_1 + x_2)/2$. At $(x_\\star,t_\\star)$, the continuous solution evaluates to $u(x_\\star,t_\\star) = f(x_1) + g(x_2) = A_1 + A_2$, independent of $\\sigma_1$ and $\\sigma_2$. For destructive interference with $A_1 = -A_2$ and symmetric widths, the sum is $0$.\n\nEnergy and its discrete approximation:\nThe total energy is\n$$\nE(t) = \\int_0^L \\frac{1}{2}\\left[\\left(\\frac{\\partial u}{\\partial t}\\right)^2 + c^2 \\left(\\frac{\\partial u}{\\partial x}\\right)^2 \\right] dx,\n$$\nwhich is conserved for the continuous wave equation with fixed ends. Discretely, we approximate\n$$\nE^n \\approx \\sum_{i=0}^{N_x-1} \\frac{1}{2} \\left[ (v_i^n)^2 + c^2 (D_x u_i^n)^2 \\right] \\Delta x,\n$$\nwhere $D_x u_i^n$ is a centered spatial difference for interior points,\n$$\nD_x u_i^n = \\frac{u_{i+1}^n - u_{i-1}^n}{2 \\Delta x} \\quad \\text{for } 1 \\le i \\le N_x-2,\n$$\nwith one-sided differences at boundaries consistent with $u=0$. For $E^0$ we use $v_i^0 = v_0(x_i)$. For $E^n$ at later times, a centered time difference $v_i^n \\approx \\left(u_i^{n+1} - u_i^{n-1}\\right)/(2 \\Delta t)$ is second-order; in a two-level marching implementation, an accurate proxy is $v_i^{n} \\approx \\left(u_i^{n} - u_i^{n-1}\\right)/\\Delta t$ at the available time level, which suffices to monitor near-conservation over modest times before boundary interaction.\n\nAlgorithmic design:\n1. Choose $N_x$ large and $\\lambda = c \\Delta t / \\Delta x$ strictly less than $1$; compute $\\Delta t$ from $\\lambda$.\n2. Build the grid $x_i$ on $[0,L]$ and assemble $u_i^0$ from the two Gaussians. Compute $v_i^0 = -c f'(x_i) + c g'(x_i)$. Enforce $u_0^0=u_{N_x-1}^0=0$ and $v_0^0=v_{N_x-1}^0=0$.\n3. Compute $u_i^1$ using the Taylor-based first-step formula and enforce boundary values.\n4. March in time with the explicit update until just past $t_\\star$. Detect the step where $t$ crosses $t_\\star$ and linearly interpolate in time at the grid index nearest to $x_\\star$ to estimate $u(x_\\star,t_\\star)$.\n5. Compute $E(0)$ from $u^0$ and $v^0$. Compute $E(t_\\star)$ from the two most recent time levels and spatial gradients. Form the relative energy change.\n6. Repeat for the three test cases.\n\nTest suite and outputs:\n- Case A: $L = 1.0$, $c = 1.0$, $A_1 = 0.010$, $A_2 = 0.020$, $\\sigma_1 = 0.050$, $\\sigma_2 = 0.050$, $x_1 = 0.300$, $x_2 = 0.700$. Compute the absolute error $|u(x_\\star,t_\\star) - (A_1 + A_2)|$ in meters.\n- Case B: $L = 1.0$, $c = 1.0$, $A_1 = 0.015$, $A_2 = -0.015$, $\\sigma_1 = 0.040$, $\\sigma_2 = 0.040$, $x_1 = 0.350$, $x_2 = 0.650$. Compute the absolute error $|u(x_\\star,t_\\star) - 0.0|$ in meters.\n- Case C: $L = 1.0$, $c = 1.0$, $A_1 = 0.010$, $A_2 = 0.013$, $\\sigma_1 = 0.030$, $\\sigma_2 = 0.070$, $x_1 = 0.250$, $x_2 = 0.750$. Compute the boolean that is true if $|E(t_\\star)-E(0)|/E(0) lt; 0.02$ and false otherwise.\n\nThe program outputs one line: a list with the Case A error (meters), the Case B error (meters), and the Case C boolean, in that order, formatted as a comma-separated list in square brackets with no extra text. The chosen grid and time step ensure that the wave packets do not reach the boundaries before $t_\\star$, making interference and energy diagnostics meaningful and boundary-reflection-free within the simulated window.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef gaussian(x, A, x0, sigma):\n    return A * np.exp(-0.5 * ((x - x0) / sigma) ** 2)\n\ndef gaussian_derivative(x, A, x0, sigma):\n    # d/dx of Gaussian profile\n    return gaussian(x, A, x0, sigma) * (-(x - x0) / (sigma ** 2))\n\ndef discrete_energy(u, v, c, dx):\n    # Spatial derivative with centered differences (one-sided at boundaries)\n    du_dx = np.empty_like(u)\n    du_dx[0] = (u[1] - u[0]) / dx\n    du_dx[-1] = (u[-1] - u[-2]) / dx\n    du_dx[1:-1] = (u[2:] - u[:-2]) / (2.0 * dx)\n    energy_density = 0.5 * (v ** 2 + (c ** 2) * (du_dx ** 2))\n    return np.sum(energy_density) * dx\n\ndef simulate_case(L, c, A1, A2, sigma1, sigma2, x1, x2, Nx=2001, CFL=0.9):\n    # Grid setup\n    x = np.linspace(0.0, L, Nx)\n    dx = x[1] - x[0]\n    dt = CFL * dx / c\n    lam2 = (c * dt / dx) ** 2\n\n    # Initial conditions u0 and v0 to produce right- and left-moving Gaussians\n    f = gaussian(x, A1, x1, sigma1)  # right-moving\n    g = gaussian(x, A2, x2, sigma2)  # left-moving\n    u0 = f + g\n    v0 = -c * gaussian_derivative(x, A1, x1, sigma1) + c * gaussian_derivative(x, A2, x2, sigma2)\n\n    # Enforce fixed ends\n    u0[0] = 0.0\n    u0[-1] = 0.0\n    v0[0] = 0.0\n    v0[-1] = 0.0\n\n    # First time step (second-order accurate)\n    u1 = np.empty_like(u0)\n    u1[1:-1] = u0[1:-1] + dt * v0[1:-1] + 0.5 * lam2 * (u0[2:] - 2.0 * u0[1:-1] + u0[:-2])\n    u1[0] = 0.0\n    u1[-1] = 0.0\n\n    # Collision time and location\n    t_star = (x2 - x1) / (2.0 * c)\n    x_star = 0.5 * (x1 + x2)\n    # Index nearest to x_star\n    i_star = int(np.round((x_star - x[0]) / dx))\n    i_star = max(0, min(Nx - 1, i_star))\n\n    # Energy at t=0\n    E0 = discrete_energy(u0, v0, c, dx)\n\n    # Time march until just past t_star\n    t_prev = 0.0\n    t_curr = dt\n    u_prev = u0.copy()\n    u_curr = u1.copy()\n\n    u_at_tstar = None\n\n    # If t_star is before dt (unlikely with these parameters), handle interpolation from u0 and u1\n    if t_prev = t_star = t_curr:\n        alpha = (t_star - t_prev) / (t_curr - t_prev)\n        u_at_tstar = (1.0 - alpha) * u_prev[i_star] + alpha * u_curr[i_star]\n\n    # March forward\n    # Target to go slightly beyond t_star\n    t_end = t_star + 2.0 * dt\n    n_steps = int(np.ceil((t_end - t_curr) / dt))\n    for _ in range(n_steps):\n        u_next = np.empty_like(u_curr)\n        # Interior update\n        u_next[1:-1] = (2.0 * u_curr[1:-1] - u_prev[1:-1] +\n                        lam2 * (u_curr[2:] - 2.0 * u_curr[1:-1] + u_curr[:-2]))\n        # Fixed ends\n        u_next[0] = 0.0\n        u_next[-1] = 0.0\n\n        # Advance times\n        t_next = t_curr + dt\n\n        # Capture u at t_star by temporal interpolation when crossed\n        if u_at_tstar is None and (t_curr = t_star = t_next):\n            alpha = (t_star - t_curr) / (t_next - t_curr)\n            u_at_tstar = (1.0 - alpha) * u_curr[i_star] + alpha * u_next[i_star]\n\n        # Shift\n        u_prev, u_curr = u_curr, u_next\n        t_prev, t_curr = t_curr, t_next\n\n    # Safety: if u_at_tstar still None due to rounding, take nearest\n    if u_at_tstar is None:\n        u_at_tstar = u_curr[i_star]\n\n    # Approximate velocity at final time level for energy at t_star\n    v_end = (u_curr - u_prev) / dt\n    E_end = discrete_energy(u_curr, v_end, c, dx)\n\n    return u_at_tstar, E0, E_end\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Case A: constructive interference\n    case_A = dict(L=1.0, c=1.0, A1=0.010, A2=0.020, sigma1=0.050, sigma2=0.050, x1=0.300, x2=0.700)\n    # Case B: destructive interference\n    case_B = dict(L=1.0, c=1.0, A1=0.015, A2=-0.015, sigma1=0.040, sigma2=0.040, x1=0.350, x2=0.650)\n    # Case C: energy check\n    case_C = dict(L=1.0, c=1.0, A1=0.010, A2=0.013, sigma1=0.030, sigma2=0.070, x1=0.250, x2=0.750)\n\n    # Common numerical parameters\n    Nx = 2001\n    CFL = 0.9\n\n    # Run simulations\n    uA_at_star, EA0, EAend = simulate_case(Nx=Nx, CFL=CFL, **case_A)\n    uB_at_star, EB0, EBend = simulate_case(Nx=Nx, CFL=CFL, **case_B)\n    uC_at_star, EC0, ECend = simulate_case(Nx=Nx, CFL=CFL, **case_C)\n\n    # Expected values at collision\n    expected_A = case_A[\"A1\"] + case_A[\"A2\"]  # constructive\n    expected_B = 0.0  # destructive\n\n    err_A = abs(uA_at_star - expected_A)  # meters\n    err_B = abs(uB_at_star - expected_B)  # meters\n\n    rel_energy_change_C = abs(ECend - EC0) / EC0 if EC0 != 0.0 else float('inf')\n    energy_ok_C = bool(rel_energy_change_C  0.02)\n\n    results = [err_A, err_B, energy_ok_C]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "Our final practice moves beyond the idealized uniform string to explore a more complex and dynamic system. Here, we model a string whose properties are not constant, but are instead modulated by an external factor—in this case, a moving \"spotlight\" that alters the local wave speed $c(x,t)$. This exercise will teach you how to implement a robust, conservative numerical scheme for wave equations with variable coefficients, a powerful technique essential for modeling the inhomogeneities found in many real-world physical systems .",
            "id": "2438557",
            "problem": "You are asked to model a one-dimensional vibrating string whose local wave speed is modulated by light. The transverse displacement field is denoted by $u(x,t)$ on a spatial domain $x \\in [0,L]$ with fixed ends. Starting from Newton's second law and the definition of local wave speed $c(x,t)$, derive a conservative, second-order accurate finite difference scheme in space and time for the partial differential equation\n$$\nu_{tt}(x,t) \\;=\\; \\partial_x\\!\\big(c^2(x,t)\\,u_x(x,t)\\big),\n$$\nwith homogeneous Dirichlet boundary conditions $u(0,t)=u(L,t)=0$ and given initial data $u(x,0)=u_0(x)$, $u_t(x,0)=v_0(x)$. The light-sensitive wave speed is specified by\n$$\nc(x,t) \\;=\\; c_0\\,\\sqrt{\\,1 - \\beta\\,I(x,t)\\,},\\quad\nI(x,t) \\;=\\; \\exp\\!\\left(-\\dfrac{(x - x_s(t))^2}{2\\sigma^2}\\right),\\quad\nx_s(t) \\;=\\; x_{\\text{start}} + v_s\\,t,\n$$\nwhere $c_0$ is the baseline wave speed in $\\mathrm{m/s}$, $0 \\le \\beta  1$ is the light sensitivity coefficient (dimensionless), $\\sigma$ is the spotlight width in $\\mathrm{m}$, and $v_s$ is the spotlight speed in $\\mathrm{m/s}$. You may assume all parameters are such that $c(x,t)$ remains real and strictly positive for all $x$ and $t$ of interest.\n\nYour tasks are:\n1) From the balance of forces on a small string element and the definition $c^2(x,t) = T(x,t)/\\rho$, where $T(x,t)$ is the local tension and $\\rho$ is the mass density per unit length, show that the governing equation above follows in the small-slope limit when light modulates tension as $T(x,t)=\\rho\\,c^2(x,t)$ with $c(x,t)$ as given.\n\n2) Discretize the equation on a uniform grid $x_i = i\\,\\Delta x$ for $i=0,1,\\dots,N-1$ with $\\Delta x = L/(N-1)$ and uniform time steps $t^n = n\\,\\Delta t$ for $n=0,1,2,\\dots$. Use centered differences in space on the flux $\\partial_x\\!\\big(c^2 u_x\\big)$ with half-node coefficients and centered differences in time for $u_{tt}$. That is, approximate\n$$\n\\big(c^2 u_x\\big)_x\\Big|_{x=x_i,\\,t=t^{n+\\tfrac{1}{2}}} \\;\\approx\\; \\dfrac{1}{\\Delta x^2}\\left[a^{n+\\tfrac{1}{2}}_{i+\\tfrac{1}{2}}\\,(u^n_{i+1}-u^n_i)-a^{n+\\tfrac{1}{2}}_{i-\\tfrac{1}{2}}\\,(u^n_i-u^n_{i-1})\\right],\n$$\nwhere $a^{n+\\tfrac{1}{2}}_{i\\pm \\tfrac{1}{2}}$ approximates $c^2\\!\\left(x_{i\\pm \\tfrac{1}{2}},t^{n+\\tfrac{1}{2}}\\right)$ using arithmetic averages of nodal values of $a=c^2$. Derive the explicit update for $u^{n+1}_i$ at interior nodes $i=1,\\dots,N-2$, and a consistent second-order start-up formula for $u^1_i$ that uses $u^0_i$, $v^0_i$ and the spatial operator evaluated at $t^{\\tfrac{1}{2}}$.\n\n3) State a sufficient Courant–Friedrichs–Lewy (CFL) condition for stability in terms of $\\Delta t$, $\\Delta x$, and the maximum wave speed. Use it to choose $\\Delta t$ via $\\Delta t = C_{\\mathrm{CFL}}\\,\\Delta x/\\max_{x,t} c(x,t)$ with $0  C_{\\mathrm{CFL}} \\le 1$. For this problem, you must take $C_{\\mathrm{CFL}} = 0.9$ and note that $\\max_{x,t} c(x,t) = c_0$ for the given model.\n\n4) Implement the explicit scheme in a program that runs three specified test cases. Use fixed-end boundary conditions $u_0^n = u_{N-1}^n = 0$ for all $n$. The required observables and units are specified below.\n\nImplementation details and physical units:\n- All lengths must be in $\\mathrm{m}$, time in $\\mathrm{s}$, and wave speed in $\\mathrm{m/s}$. Report displacements in $\\mathrm{m}$ and frequency in $\\mathrm{Hz}$.\n- Angles, if used, must be in radians.\n- The final program must produce a single line of output containing a Python-style list with three floating-point numbers in the order of the test cases, each rounded to six decimal places.\n\nTest suite (each test set must be simulated independently with the provided parameters):\n- Test $1$ (happy path; moving spotlight, Gaussian initial bump):\n  - $L = 1.0\\,\\mathrm{m}$, $c_0 = 100.0\\,\\mathrm{m/s}$, $\\beta = 0.3$, $\\sigma = 0.05\\,\\mathrm{m}$, $v_s = 2.0\\,\\mathrm{m/s}$, $x_{\\text{start}} = 0.0\\,\\mathrm{m}$.\n  - Grid: $N = 401$ points, so $\\Delta x = L/(N-1)$.\n  - Time step: $\\Delta t = 0.9\\,\\Delta x/c_0$.\n  - Final time: $T_{\\text{end}} = 0.015\\,\\mathrm{s}$.\n  - Initial conditions: $u_0(x) = A\\,\\exp\\!\\left(-\\dfrac{(x-x_c)^2}{2w^2}\\right)$ with $A = 1.0\\times 10^{-3}\\,\\mathrm{m}$, $x_c = 0.25\\,L$, $w = 0.02\\,\\mathrm{m}$, and $v_0(x)=0$.\n  - Output: the final-time spatial $\\mathrm{L}^2$ norm of the displacement, defined by $\\|u(\\cdot,T_{\\text{end}})\\|_2 = \\left(\\sum_{i=0}^{N-1} u_i^2(T_{\\text{end}})\\,\\Delta x\\right)^{1/2}$ in $\\mathrm{m}$.\n\n- Test $2$ (boundary-interaction edge case; spotlight present, bump near boundary):\n  - $L = 1.0\\,\\mathrm{m}$, $c_0 = 100.0\\,\\mathrm{m/s}$, $\\beta = 0.5$, $\\sigma = 0.03\\,\\mathrm{m}$, $v_s = 3.0\\,\\mathrm{m/s}$, $x_{\\text{start}} = 0.0\\,\\mathrm{m}$.\n  - Grid: $N = 401$.\n  - Time step: $\\Delta t = 0.9\\,\\Delta x/c_0$.\n  - Final time: $T_{\\text{end}} = 0.010\\,\\mathrm{s}$.\n  - Initial conditions: $u_0(x) = A\\,\\exp\\!\\left(-\\dfrac{(x-x_c)^2}{2w^2}\\right)$ with $A = 1.0\\times 10^{-3}\\,\\mathrm{m}$, $x_c = 0.02\\,\\mathrm{m}$, $w = 0.01\\,\\mathrm{m}$, and $v_0(x)=0$.\n  - Output: the maximum absolute displacement observed anywhere on the string over the entire simulation interval, $\\max_{0\\le n \\le T_{\\text{end}}/\\Delta t}\\max_{0\\le i \\le N-1} |u_i^n|$, in $\\mathrm{m}$.\n\n- Test $3$ (consistency check; no spotlight, first normal mode and frequency extraction):\n  - $L = 1.0\\,\\mathrm{m}$, $c_0 = 100.0\\,\\mathrm{m/s}$, $\\beta = 0.0$ (so $c(x,t)\\equiv c_0$), $\\sigma$ and $v_s$ arbitrary and unused.\n  - Grid: $N = 601$.\n  - Time step: $\\Delta t = 0.9\\,\\Delta x/c_0$.\n  - Final time: $T_{\\text{end}} = 0.100\\,\\mathrm{s}$.\n  - Initial conditions: $u_0(x) = A\\,\\sin\\!\\left(\\dfrac{\\pi x}{L}\\right)$ with $A=1.0\\times 10^{-3}\\,\\mathrm{m}$ and $v_0(x)=0$.\n  - Track $u$ at the antinode $x=L/2$ over time, estimate the dominant oscillation frequency by detecting zero crossings and linearly interpolating crossing times to estimate the average period. The theoretical first-mode frequency is $f_1 = c_0/(2L)$ in $\\mathrm{Hz}$.\n  - Output: the absolute error $|f_{\\text{num}} - f_1|$ in $\\mathrm{Hz}$.\n\nFinal output format:\n- Your program should produce a single line of output containing a Python list with three numbers corresponding to Tests $1$, $2$, and $3$ in that order, rounded to six decimal places, for example: `[0.001234,0.001345,0.000120]`.",
            "solution": "The problem proposed is a standard, well-posed initial-boundary value problem from computational physics. It is scientifically sound, mathematically consistent, and all parameters and conditions required for a unique, stable numerical solution are provided. The problem is therefore deemed **valid**, and a solution will be provided.\n\nThe primary task is to derive and implement a finite difference scheme for the one-dimensional wave equation with a variable coefficient, given by\n$$\nu_{tt}(x,t) \\;=\\; \\partial_x\\!\\big(c^2(x,t)\\,u_x(x,t)\\big)\n$$\nwhere $u(x,t)$ is the transverse displacement of a string, and $c(x,t)$ is the non-uniform, time-dependent wave speed.\n\n**1. Derivation of the Governing Equation**\n\nWe begin from Newton's second law applied to an infinitesimal element of the string of length $\\Delta s$ between horizontal positions $x$ and $x+\\Delta x$. Let $\\rho$ be the constant linear mass density. The mass of the element is $\\Delta m = \\rho \\Delta s$. For small displacements, the slope $u_x = \\partial u/\\partial x$ is small, so the element length is approximately its horizontal projection, $\\Delta s \\approx \\Delta x$. The mass is then $\\Delta m \\approx \\rho \\Delta x$.\n\nThe net vertical force on the element is the difference in the vertical components of the tension force $T(x,t)$ acting at its ends. The vertical component of tension at a point is $T \\sin\\theta$, where $\\theta$ is the angle of the string with the horizontal. In the small-slope approximation, $\\sin\\theta \\approx \\tan\\theta = u_x$.\nThe net vertical force $\\Delta F_v$ is therefore\n$$\n\\Delta F_v \\;=\\; T(x+\\Delta x, t)\\,u_x(x+\\Delta x, t) - T(x,t)\\,u_x(x,t).\n$$\nAccording to Newton's second law, $F=ma$, the net force equals mass times acceleration, where the acceleration is the second partial derivative of displacement with respect to time, $u_{tt}$.\n$$\n(\\rho \\Delta x)\\, u_{tt}(x,t) \\;=\\; T(x+\\Delta x, t)\\,u_x(x+\\Delta x, t) - T(x,t)\\,u_x(x,t).\n$$\nDividing by $\\Delta x$ and taking the limit as $\\Delta x \\to 0$ gives the definition of the partial derivative with respect to $x$:\n$$\n\\rho\\,u_{tt}(x,t) \\;=\\; \\partial_x \\big( T(x,t)\\,u_x(x,t) \\big).\n$$\nThe problem states that the wave speed squared is defined by $c^2(x,t) = T(x,t)/\\rho$, implying the tension is modulated as $T(x,t) = \\rho\\,c^2(x,t)$. Substituting this into the equation of motion yields\n$$\n\\rho\\,u_{tt}(x,t) \\;=\\; \\partial_x \\big( \\rho\\,c^2(x,t)\\,u_x(x,t) \\big).\n$$\nSince $\\rho$ is a constant, it can be factored out of the spatial derivative and canceled from both sides, which results in the specified governing equation:\n$$\nu_{tt}(x,t) \\;=\\; \\partial_x\\big(c^2(x,t)\\,u_x(x,t)\\big).\n$$\nThis completes the derivation. The form of the equation is conservative because the spatial part is the divergence of a flux, in this case the flux of transverse momentum.\n\n**2. Derivation of the Finite Difference Scheme**\n\nWe discretize the domain with a uniform spatial grid $x_i = i\\,\\Delta x$ for $i=0, 1, \\dots, N-1$, where $\\Delta x = L/(N-1)$, and uniform time steps $t^n = n\\,\\Delta t$. The displacement is denoted by $u_i^n \\approx u(x_i, t^n)$.\n\nThe second time derivative $u_{tt}$ at $(x_i, t^n)$ is approximated using a second-order accurate centered difference:\n$$\nu_{tt}(x_i, t^n) \\;\\approx\\; \\frac{u_i^{n+1} - 2u_i^n + u_i^{n-1}}{\\Delta t^2}.\n$$\nThe spatial operator $\\partial_x(c^2 u_x)$ is discretized as specified in the problem statement. This is a second-order accurate centered difference scheme for a flux term. Let $a(x,t) = c^2(x,t)$. The flux is $F(x,t) = a(x,t)u_x(x,t)$. We have $\\partial_x F \\approx (F_{i+1/2} - F_{i-1/2})/\\Delta x$. The fluxes at half-grid points are approximated as $F_{i\\pm 1/2} \\approx a_{i\\pm 1/2} (u_{i\\pm 1} - u_i)/\\Delta x$. This results in the specified form, which we denote $\\mathcal{L}[u]$. The problem requires evaluating the coefficients $a = c^2$ at the half-time step $t^{n+1/2}$, while using the displacement $u$ at time $t^n$. The full discrete equation is:\n$$\n\\frac{u_i^{n+1} - 2u_i^n + u_i^{n-1}}{\\Delta t^2} \\;=\\; \\frac{1}{\\Delta x^2}\\left[a^{n+\\tfrac{1}{2}}_{i+\\tfrac{1}{2}}\\,(u^n_{i+1}-u^n_i)-a^{n+\\tfrac{1}{2}}_{i-\\tfrac{1}{2}}\\,(u^n_i-u^n_{i-1})\\right],\n$$\nwhere the coefficients at half-nodes are arithmetic averages of the nodal values:\n$$\na^{n+\\tfrac{1}{2}}_{i\\pm\\tfrac{1}{2}} \\;=\\; \\frac{1}{2}\\left( a(x_i, t^{n+\\tfrac{1}{2}}) + a(x_{i\\pm 1}, t^{n+\\tfrac{1}{2}}) \\right).\n$$\nThis scheme is explicit. Solving for $u_i^{n+1}$ gives the update rule for interior nodes ($i=1, \\dots, N-2$):\n$$\nu_i^{n+1} \\;=\\; 2u_i^n - u_i^{n-1} + \\left(\\frac{\\Delta t}{\\Delta x}\\right)^2 \\left[a^{n+\\tfrac{1}{2}}_{i+\\tfrac{1}{2}}(u^n_{i+1}-u^n_i)-a^{n+\\tfrac{1}{2}}_{i-\\tfrac{1}{2}}(u^n_i-u^n_{i-1})\\right].\n$$\nThe boundary conditions are $u_0^n = 0$ and $u_{N-1}^n = 0$ for all $n \\ge 0$.\n\nFor the first time step ($n=0$), we need $u^1_i$. The general update requires $u^{-1}_i$, which is not given. We use the initial velocity $v_0(x) = u_t(x,0)$ and a centered difference approximation at $t=0$:\n$$\nv_i^0 \\;\\approx\\; \\frac{u_i^1 - u_i^{-1}}{2\\Delta t} \\quad\\implies\\quad u_i^{-1} \\;=\\; u_i^1 - 2\\Delta t v_i^0.\n$$\nSubstituting this into the update rule for $n=0$ gives:\n$$\nu_i^1 \\;=\\; 2u_i^0 - (u_i^1 - 2\\Delta t v_i^0) + \\Delta t^2 \\mathcal{L}^{1/2}[u^0]_i,\n$$\nwhere $\\mathcal{L}^{1/2}[u^0]_i$ is the spatial operator with coefficients evaluated at $t^{1/2}=\\Delta t/2$ and applied to $u^0$. Solving for $u_i^1$ yields the second-order accurate start-up formula:\n$$\nu_i^1 \\;=\\; u_i^0 + \\Delta t v_i^0 + \\frac{\\Delta t^2}{2} \\mathcal{L}^{1/2}[u^0]_i.\n$$\nThis formula is consistent with the problem's requirements.\n\n**3. Stability Condition**\n\nFor an explicit finite difference scheme for the wave equation, stability is governed by the Courant–Friedrichs–Lewy (CFL) condition. For a variable wave speed $c(x,t)$, a sufficient condition for stability is that the numerical domain of dependence must contain the physical domain of dependence. This leads to the requirement:\n$$\nC_{\\text{CFL}} \\;=\\; \\frac{\\max_{x,t} c(x,t) \\cdot \\Delta t}{\\Delta x} \\;\\le\\; 1.\n$$\nThe wave speed is given by $c(x,t) = c_0\\sqrt{1 - \\beta I(x,t)}$. Since $0 \\le \\beta  1$ and the intensity term $I(x,t) = \\exp(\\dots)$ is non-negative, the maximum value of $c(x,t)$ occurs where $I(x,t)$ is minimum. The minimum value of $I(x,t)$ is $0$, which occurs as $|x-x_s(t)| \\to \\infty$. Thus, $\\max_{x,t} c(x,t) = c_0$.\nThe stability condition simplifies to $c_0 \\Delta t / \\Delta x \\le 1$. The problem specifies choosing the time step as\n$$\n\\Delta t = 0.9 \\frac{\\Delta x}{c_0},\n$$\nwhich corresponds to a Courant number $C_{\\text{CFL}} = 0.9$. Since $0.9 \\le 1$, the scheme is stable under this choice.\n\n**4. Implementation Strategy**\n\nThe numerical scheme is implemented in Python using the `numpy` library for efficient array operations.\n- The simulation state is maintained by three arrays: `u_prev` ($u^{n-1}$), `u_curr` ($u^n$), and `u_next` ($u^{n+1}$).\n- The simulation starts by initializing `u_curr` from the initial condition $u_0(x)$ and applying boundary conditions.\n- The first time step computes $u^1$ using the derived start-up formula, which is a special case since the initial velocity $v_0(x)=0$ for all test cases.\n- The main loop then iterates from $n=1$ to the final time step. In each iteration, it computes $u^{n+1}$ from $u^n$ and $u^{n-1}$ using the general update rule.\n- In each step, the time-dependent coefficients $a(x, t^{n+1/2})$ are calculated first, followed by the averaged half-node coefficients. The spatial operator is then computed using vectorized `numpy` operations on the interior grid points.\n- Boundary conditions $u_0=0, u_{N-1}=0$ are enforced after each update.\n- The required observables for each test case are computed:\n  - **Test 1:** The final spatial $\\mathrm{L}^2$ norm, $\\|u(\\cdot, T_{\\text{end}})\\|_2 = \\left(\\sum_i (u_i^{\\text{final}})^2 \\Delta x\\right)^{1/2}$, is computed after the loop finishes.\n  - **Test 2:** The maximum absolute displacement, $\\max_{n,i}|u_i^n|$, is updated within the loop at each time step.\n  - **Test 3:** The displacement at the string's midpoint, $u(L/2, t)$, is recorded. After the simulation, these time series data are processed to detect zero-crossings via sign changes. Linear interpolation is used to estimate the precise time of each crossing. The average time difference between crossings gives the half-period, from which the numerical frequency $f_{\\text{num}}$ is calculated. The final result is the absolute error $|f_{\\text{num}} - f_1|$, where $f_1 = c_0/(2L)$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that runs three test cases for the vibrating string simulation.\n    \"\"\"\n\n    def run_simulation(L, c0, beta, sigma, vs, x_start, N, T_end, u0_func, v0_func, C_CFL=0.9):\n        \"\"\"\n        Generic simulation engine for the 1D wave equation with variable coefficients.\n        \"\"\"\n        dx = L / (N - 1)\n        x = np.linspace(0, L, N)\n        \n        c_max = c0\n        dt = C_CFL * dx / c_max\n        \n        num_steps = int(np.ceil(T_end / dt))\n        \n        def x_s(t):\n            \"\"\"Calculates the center of the moving spotlight at a given time.\"\"\"\n            return x_start + vs * t\n\n        def I(x_nodes, t):\n            \"\"\"Calculates the light intensity profile on the grid at a given time.\"\"\"\n            return np.exp(-(x_nodes - x_s(t))**2 / (2 * sigma**2))\n\n        def a(x_nodes, t):\n            \"\"\"Calculates the square of the wave speed, c^2, on the grid.\"\"\"\n            if beta == 0:\n                return np.full_like(x_nodes, c0**2)\n            return c0**2 * (1 - beta * I(x_nodes, t))\n\n        # Initialize displacement fields\n        u_prev = np.zeros(N)\n        u_curr = u0_func(x)\n        u_next = np.zeros(N)\n        v0 = v0_func(x)\n        \n        # Apply boundary conditions to initial state\n        u_curr[0] = 0\n        u_curr[-1] = 0\n\n        # Storage for observables\n        max_abs_u = np.max(np.abs(u_curr))\n        u_mid_history = []\n        time_history = []\n        mid_point_idx = (N - 1) // 2\n\n        # First step (n=0 to n=1) using the second-order start-up formula\n        t_half = 0.5 * dt\n        a_vals_t_half = a(x, t_half)\n        \n        a_half_p = 0.5 * (a_vals_t_half[1:-1] + a_vals_t_half[2:])\n        a_half_m = 0.5 * (a_vals_t_half[:-2] + a_vals_t_half[1:-1])\n\n        spatial_op_u0 = (a_half_p * (u_curr[2:] - u_curr[1:-1]) - \n                         a_half_m * (u_curr[1:-1] - u_curr[:-2]))\n        \n        u_next[1:-1] = (u_curr[1:-1] + dt * v0[1:-1] + \n                        0.5 * (dt / dx)**2 * spatial_op_u0)\n\n        # Update state variables for the main loop\n        u_prev[:] = u_curr\n        u_curr[:] = u_next\n        \n        # Update observables after first step\n        max_abs_u = max(max_abs_u, np.max(np.abs(u_curr)))\n        if beta == 0.0:  # For Test 3\n            u_mid_history.append(u_curr[mid_point_idx])\n            time_history.append(dt)\n        \n        # Main time-stepping loop (n=1, 2, ..., num_steps-1)\n        for n in range(1, num_steps):\n            t_n_plus_half = (n + 0.5) * dt\n            \n            a_vals_n_plus_half = a(x, t_n_plus_half)\n            \n            a_half_p = 0.5 * (a_vals_n_plus_half[1:-1] + a_vals_n_plus_half[2:])\n            a_half_m = 0.5 * (a_vals_n_plus_half[:-2] + a_vals_n_plus_half[1:-1])\n\n            spatial_op_un = (a_half_p * (u_curr[2:] - u_curr[1:-1]) -\n                             a_half_m * (u_curr[1:-1] - u_curr[:-2]))\n            \n            u_next[1:-1] = (2 * u_curr[1:-1] - u_prev[1:-1] + \n                            (dt / dx)**2 * spatial_op_un)\n            \n            u_prev[:] = u_curr\n            u_curr[:] = u_next\n            \n            max_abs_u = max(max_abs_u, np.max(np.abs(u_curr)))\n            if beta == 0.0:\n                u_mid_history.append(u_curr[mid_point_idx])\n                time_history.append((n + 1) * dt)\n\n        return u_curr, dx, max_abs_u, u_mid_history, time_history\n\n    # --- Test Case 1 ---\n    L1, c0_1, beta1, sigma1, vs1, x_start1 = 1.0, 100.0, 0.3, 0.05, 2.0, 0.0\n    N1, T_end1 = 401, 0.015\n    A1, xc1, w1 = 1.0e-3, 0.25 * L1, 0.02\n    u0_1 = lambda x: A1 * np.exp(-(x - xc1)**2 / (2 * w1**2))\n    v0_1 = lambda x: np.zeros_like(x)\n    u_final1, dx1, _, _, _ = run_simulation(L1, c0_1, beta1, sigma1, vs1, x_start1, N1, T_end1, u0_1, v0_1)\n    l2_norm = np.sqrt(np.sum(u_final1**2) * dx1)\n    result1 = round(l2_norm, 6)\n\n    # --- Test Case 2 ---\n    L2, c0_2, beta2, sigma2, vs2, x_start2 = 1.0, 100.0, 0.5, 0.03, 3.0, 0.0\n    N2, T_end2 = 401, 0.010\n    A2, xc2, w2 = 1.0e-3, 0.02, 0.01\n    u0_2 = lambda x: A2 * np.exp(-(x - xc2)**2 / (2 * w2**2))\n    v0_2 = lambda x: np.zeros_like(x)\n    _, _, max_u, _, _ = run_simulation(L2, c0_2, beta2, sigma2, vs2, x_start2, N2, T_end2, u0_2, v0_2)\n    result2 = round(max_u, 6)\n\n    # --- Test Case 3 ---\n    L3, c0_3, beta3, N3, T_end3, A3 = 1.0, 100.0, 0.0, 601, 0.100, 1.0e-3\n    u0_3 = lambda x: A3 * np.sin(np.pi * x / L3)\n    v0_3 = lambda x: np.zeros_like(x)\n    _, _, _, u_mid, t_hist = run_simulation(L3, c0_3, beta3, 1.0, 0.0, 0.0, N3, T_end3, u0_3, v0_3)\n    \n    u_mid = np.array(u_mid)\n    t_hist = np.array(t_hist)\n    \n    # Find zero crossings by detecting sign changes\n    crossings_indices = np.where(np.diff(np.sign(u_mid)))[0]\n    \n    crossing_times = []\n    for idx in crossings_indices:\n        t1, t2 = t_hist[idx], t_hist[idx+1]\n        u1, u2 = u_mid[idx], u_mid[idx+1]\n        # Linear interpolation to find precise time of zero crossing\n        if u2 - u1 != 0:\n            t_cross = t1 - u1 * (t2 - t1) / (u2 - u1)\n            crossing_times.append(t_cross)\n            \n    if len(crossing_times)  2:\n        f_num = np.nan\n    else:\n        half_periods = np.diff(crossing_times)\n        avg_period = 2 * np.mean(half_periods)\n        f_num = 1 / avg_period\n        \n    f_theory = c0_3 / (2 * L3)\n    abs_error = abs(f_num - f_theory)\n    result3 = round(abs_error, 6)\n    \n    results = [f\"{result1:.6f}\", f\"{result2:.6f}\", f\"{result3:.6f}\"]\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}