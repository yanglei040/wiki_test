{
    "hands_on_practices": [
        {
            "introduction": "在模拟振动弦的完整动力学之前，精确地表示驱动其运动的空间曲率是至关重要的。本练习聚焦于空间离散化的核心，要求你比较标准的二阶和更高阶的四阶有限差分近似在计算二阶导数时的精度。通过完成这项练习 ，你将对数值模板的选择如何影响模拟保真度获得定量的理解。",
            "id": "2438535",
            "problem": "考虑一根理想、拉紧、均匀的弦在一个长度为 $L$ 的一维闭环上的小横向振动，因此位移 $u(x,t)$ 在空间上是周期性的，周期为 $L$。控制恢复力的空间算子是二阶空间导数 $\\partial^2 u / \\partial x^2$。在一个具有 $N$ 个点、间距为 $\\Delta x = L/N$ 且满足周期性边界条件的均匀网格上，通过构建两个用于 $\\partial^2 u / \\partial x^2$ 的离散近似算子，来近似该空间算子对一个光滑周期函数 $u(x)$ 的作用：一个算子在 $\\Delta x$ 上是二阶精度的，另一个在 $\\Delta x$ 上是四阶精度的。对于每种近似，使用网格上的均方根（RMS）误差来量化其与精确二阶导数的误差。三角函数中使用的角度必须解释为弧度。\n\n定义测试函数为 $u(x) = \\sin(k x)$，其中 $k = 2\\pi m / L$，整数模数 $m \\ge 1$。精确的二阶导数是 $\\partial^2 u / \\partial x^2 = -k^2 \\sin(k x)$。对于每个指定的参数集 $(L, m, N)$，计算二阶近似的RMS误差 $E_2$ 和四阶近似的RMS误差 $E_4$，然后计算该参数集的改善因子 $I = E_2 / E_4$。\n\n您的程序必须为以下测试套件中的每个参数集实现这些计算，其中所有量均为指定的实数和整数：\n- 测试 $1$：$L = 1.0$，$m = 3$，$N = 256$。\n- 测试 $2$：$L = 1.0$，$m = 1$，$N = 5$。\n- 测试 $3$：$L = 2.0$，$m = 7$，$N = 64$。\n- 测试 $4$：$L = 2.0$，$m = 15$，$N = 64$。\n\n对于每个测试，使用均匀网格 $x_j = j \\Delta x$，其中 $j = 0, 1, \\dots, N-1$，$\\Delta x = L/N$，并采用周期性边界条件。对于每个测试，将改善因子 $I$ 计算为一个浮点数。最终的程序输出必须是单行，包含一个逗号分隔的四个改善因子列表，用方括号括起来，每个数字四舍五入到八位小数（例如，$[1.23456789,2.34567891,3.45678912,4.56789123]$）。不应打印任何其他文本。本问题中所有计算量都是无量纲的，因此输出中不需要物理单位。",
            "solution": "该问题陈述具有科学依据，问题明确、客观且内容完整。它提出了一个计算物理学中的标准练习：比较数值微分格式。所有必需的参数和定义都已提供。该问题是有效的。\n\n核心任务是量化在为二阶空间导数 $\\frac{\\partial^2 u}{\\partial x^2}$ 使用有限差分近似时，从二阶精度方法过渡到四阶精度方法所带来的精度提升。这是在周期性域的背景下完成的，这简化了有限差分模板的应用。\n\n首先，我们建立离散域和有限差分算子。问题定义在一个长度为 $L$ 的一维周期性域上。我们将此域离散化为一个包含 $N$ 个点的均匀网格，$x_j = j \\Delta x$，其中 $j = 0, 1, \\dots, N-1$，网格间距为 $\\Delta x = L/N$。周期性边界条件意味着对于任何整数 $j$，都有 $u_{j+N} = u_j$。\n\n函数 $u(x)$ 在网格点 $x_j$ 处的二阶导数可以用其邻近点来近似。所需算子的模板源于泰勒级数展开。\n\n二阶精度的中心差分近似 $(D_2 u)_j$ 由下式给出：\n$$ (D_2 u)_j = \\frac{u_{j+1} - 2u_j + u_{j-1}}{(\\Delta x)^2} $$\n此近似的主误差项与 $(\\Delta x)^2$ 成正比，因此它是一种二阶方法。\n\n四阶精度的中心差分近似 $(D_4 u)_j$ 需要一个更宽的五点模板：\n$$ (D_4 u)_j = \\frac{-u_{j+2} + 16u_{j+1} - 30u_j + 16u_{j-1} - u_{j-2}}{12(\\Delta x)^2} $$\n这里的主误差项与 $(\\Delta x)^4$ 成正比，从而得到一种更精确的四阶方法，特别是对于足够小的 $\\Delta x$。\n\n问题指定了一个测试函数 $u(x) = \\sin(kx)$，其中波数 $k = 2\\pi m / L$ 由整数模数 $m \\ge 1$ 确定。选择正弦函数是理想的，因为它是空间微分算子的本征函数。其精确的二阶导数可以很容易地通过解析方法计算：\n$$ \\frac{\\partial^2 u}{\\partial x^2} = -k^2 \\sin(kx) $$\n\n为了执行计算，我们首先在离散网格上评估测试函数 $u(x)$ 及其精确的二阶导数，得到向量 $u_j = \\sin(k x_j)$ 和 $(u''_{\\text{exact}})_j = -k^2 u_j$。\n\n接下来，我们将离散算子 $D_2$ 和 $D_4$ 应用到向量 $u_j$ 上。周期性边界条件通过对索引进行模 $N$ 运算来处理。例如，当 $j=0$ 时，索引 $j-1$ 处的值是 $u_{-1} = u_{N-1}$；当 $j=N-1$ 时，索引 $j+1$ 处的值是 $u_N = u_0$。这种环绕索引可以通过对向量 $u_j$ 使用循环移位或滚动操作来高效实现。\n\n有了精确导数 $(u''_{\\text{exact}})_j$ 和两种近似 $(D_2 u)_j$ 和 $(D_4 u)_j$，我们就可以量化每种格式的误差。问题要求计算均方根（RMS）误差，对于二阶格式，其计算如下：\n$$ E_2 = \\sqrt{\\frac{1}{N} \\sum_{j=0}^{N-1} \\left( (D_2 u)_j - (u''_{\\text{exact}})_j \\right)^2} $$\n对于四阶格式，计算方式类似：\n$$ E_4 = \\sqrt{\\frac{1}{N} \\sum_{j=0}^{N-1} \\left( (D_4 u)_j - (u''_{\\text{exact}})_j \\right)^2} $$\n\n最后，改善因子 $I$ 是这些误差的比率：\n$$ I = \\frac{E_2}{E_4} $$\n这个无量纲因子衡量了对于给定的参数集 $(L, m, N)$，四阶格式相对于二阶格式的精确度提高了多少倍。计算过程包括为四个指定的测试案例分别计算这个因子。实现将使用 `numpy` 进行高效的数组操作，特别是使用 `numpy.roll` 来处理周期性边界条件。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the improvement factor of a fourth-order finite difference scheme over a\n    second-order scheme for approximating the second derivative of a sine function\n    on a periodic grid.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (L, m, N)\n        (1.0, 3, 256),\n        (1.0, 1, 5),\n        (2.0, 7, 64),\n        (2.0, 15, 64),\n    ]\n\n    results = []\n    for L, m, N in test_cases:\n        # 1. Define grid and function parameters\n        delta_x = L / N\n        k = 2.0 * np.pi * m / L\n        \n        # 2. Evaluate the function and its exact second derivative on the grid\n        x_grid = np.arange(N) * delta_x\n        u = np.sin(k * x_grid)\n        u_xx_exact = -k**2 * u\n        \n        # 3. Compute the second-order approximation\n        # The stencil is [1, -2, 1] / dx^2\n        # np.roll handles periodic boundary conditions\n        u_jp1 = np.roll(u, -1)\n        u_jm1 = np.roll(u, 1)\n        u_xx_2 = (u_jp1 - 2.0 * u + u_jm1) / delta_x**2\n        \n        # 4. Compute the fourth-order approximation\n        # The stencil is [-1, 16, -30, 16, -1] / (12 * dx^2)\n        u_jp2 = np.roll(u, -2)\n        u_jm2 = np.roll(u, 2)\n        u_xx_4 = (-u_jp2 + 16.0 * u_jp1 - 30.0 * u + 16.0 * u_jm1 - u_jm2) / (12.0 * delta_x**2)\n        \n        # 5. Calculate the Root-Mean-Square (RMS) error for each approximation\n        error_2 = u_xx_2 - u_xx_exact\n        E2 = np.sqrt(np.mean(error_2**2))\n        \n        error_4 = u_xx_4 - u_xx_exact\n        E4 = np.sqrt(np.mean(error_4**2))\n        \n        # 6. Compute the improvement factor I = E2 / E4\n        # If E4 is extremely close to zero, this could be a large number, which is expected.\n        # The problem setup ensures E4 is not exactly zero for the given test cases.\n        improvement_factor = E2 / E4\n        results.append(improvement_factor)\n\n    # Final print statement in the exact required format.\n    # Each number is rounded to eight decimal places.\n    print(f\"[{','.join([f'{r:.8f}' for r in results])}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "掌握了空间离散化之后，我们现在可以构建一个完整的时间域模拟来观察波的丰富动力学。本练习将指导你模拟最基本的波现象之一：两个反向传播波包的叠加与干涉。通过从第一性原理出发实现一个有限差分格式，并根据理论结果验证其预测 ，你将巩固对波动方程和数值模拟核心原则的理解。",
            "id": "2438583",
            "problem": "你的任务是推导、实现并测试一个数值模拟，模拟一根拉紧、均匀的弦在小横向振动下的行为。模拟中，两个局域高斯波包沿相反方向传播、叠加和干涉。你的程序必须为具有固定端点边界条件的一维波动方程实现一个显式的时域有限差分格式。程序必须在没有用户输入的情况下运行，并且必须输出一行包含指定测试套件结果的文本。\n\n物理和数学基础：\n- 从应用于均匀密度弦的牛顿第二定律开始：一个线质量密度为 $\\mu$ 的小段，在近似水平的张力 $T$ 作用下，得到连续介质方程 $\\mu \\partial^2 u / \\partial t^2 = T \\partial^2 u / \\partial x^2$，其中 $u(x,t)$ 是横向位移。通过 $c^2 = T/\\mu$ 定义波速 $c$，得到波动方程 $\\partial^2 u / \\partial t^2 = c^2 \\partial^2 u / \\partial x^2$。\n- 施加固定端点（Dirichlet）边界条件 $u(0,t)=0$ 和 $u(L,t)=0$，其中 $L$ 是弦的长度。\n- 使用空间间距为 $\\Delta x$ 的均匀空间网格和时间步长为 $\\Delta t$ 的均匀时间步，并满足 Courant–Friedrichs–Lewy (CFL) 条件（Courant–Friedrichs–Lewy (CFL) 必须在首次使用时定义）以保证稳定性。\n- 使用空间和时间上的中心二阶差分来离散化波动方程，从而生成一个关于 $u_i^n$ 和 $u_i^{n-1}$ 的 $u_i^{n+1}$ 的显式更新公式，其中 $u_i^n$ 是 $u(x_i, t_n)$ 在 $x_i = i \\Delta x$ 和 $t_n = n \\Delta t$ 处的近似值。利用初始速度 $v(x)=\\partial u/\\partial t(x,0)$，通过泰勒展开推导计算 $u_i^1$ 的二阶精确的初始步公式。\n- 选择初始位移 $u(x,0)$ 为两个高斯分布之和，中心分别位于 $x=x_1$ 和 $x=x_2$，振幅分别为 $A_1$ 和 $A_2$，宽度分别为 $\\sigma_1$ 和 $\\sigma_2$。选择初始速度 $v(x)$，使得第一个高斯波包以速度 $c$向右传播，第二个高斯波包以速度 $c$ 向左传播。根据由两个高斯函数及其空间导数构造的 $u(x,0)$，显式地推导出所需的 $v(x)$。除了上述基本定律和定义外，不要使用任何快捷公式；从第一性原理和标准微积分推导你所需要的一切。\n- 弦的总机械能（每单位平面外宽度）为 $E(t) = \\int_0^L \\tfrac{1}{2}\\left[(\\partial u/\\partial t)^2 + c^2 (\\partial u/\\partial x)^2\\right] \\, dx$。对于固定端点且无外力的情况，只要波包在模拟时间内不触及边界，$E(t)$ 在数值模拟中应近似守恒。\n\n数值规格：\n- 对 $x$ 和 $u$ 使用米为单位，对 $t$ 使用秒为单位。波速 $c$ 的单位是米/秒。所有报告的位移量和误差都必须以米为单位。任何报告的能量变化都是无量纲的比率。不涉及角度。\n- 在 $[0,L]$ 上使用一个包含 $N_x$ 个点的空间网格，其中 $x_i = i \\Delta x$，$\\Delta x = L/(N_x-1)$。\n- 使用满足 $0 < \\lambda \\le 1$ 的时间步长 $\\Delta t$，其中 $\\lambda = c \\Delta t / \\Delta x$ 是 Courant 数。为保证稳定性，使用严格小于 $1$ 的 $\\lambda$。在你的实现中，定义并使用一个你选择的特定 $\\lambda$ 值，并据此计算 $\\Delta t$。\n\n需要计算的观测量：\n- 设 $t_\\star$ 为两个高斯波包中心重合的时间，设 $x_\\star$ 为碰撞位置。如果 $t_\\star$ 不恰好在一个时间步上，则通过时间插值计算 $(x_\\star, t_\\star)$ 处的模拟弦位移；如果 $x_\\star$ 不恰好是一个网格点，则使用离 $x_\\star$ 最近的网格点。报告两个测试案例在碰撞时的绝对误差：一个是有建设性干涉（两个振幅均为正），另一个是有破坏性干涉（振幅符号相反）。误差必须以米为单位。\n- 对于第三个测试案例（不同的参数集），计算 $t=0$ 和 $t=t_\\star$ 之间的总能量相对变化，定义为 $|E(t_\\star)-E(0)|/E(0)$，并报告该相对变化是否严格小于一个选定的容差（返回一个布尔值）。选择模拟参数和 $t_\\star$，使得波包在 $0 \\le t \\le t_\\star$ 期间与边界保持足够远的距离。\n\n测试套件：\n提供三组参数集。在每种情况下，域为 $[0,L]$，其中 $L$ 以米为单位，波速 $c$ 以米/秒为单位，高斯参数以米为单位。\n- 案例 A（建设性干涉）：\n  - $L = 1.0$, $c = 1.0$, $A_1 = 0.010$, $A_2 = 0.020$, $\\sigma_1 = 0.050$, $\\sigma_2 = 0.050$, $x_1 = 0.300$, $x_2 = 0.700$。\n  - 预期的碰撞发生在 $t_\\star = (x_2 - x_1)/(2c)$ 和 $x_\\star = (x_1 + x_2)/2$。在 $(x_\\star, t_\\star)$ 处的预期位移是 $A_1 + A_2$。你的程序必须输出此案例的绝对误差（以米为单位）作为第一个数字。\n- 案例 B（破坏性干涉）：\n  - $L = 1.0$, $c = 1.0$, $A_1 = 0.015$, $A_2 = -0.015$, $\\sigma_1 = 0.040$, $\\sigma_2 = 0.040$, $x_1 = 0.350$, $x_2 = 0.650$。\n  - 在 $(x_\\star, t_\\star)$ 处的预期位移是 $0.0$。你的程序必须输出此案例的绝对误差（以米为单位）作为第二个数字。\n- 案例 C（能量检验）：\n  - $L = 1.0$, $c = 1.0$, $A_1 = 0.010$, $A_2 = 0.013$, $\\sigma_1 = 0.030$, $\\sigma_2 = 0.070$, $x_1 = 0.250$, $x_2 = 0.750$。\n  - 在 $t_\\star = (x_2 - x_1)/(2c)$ 时计算相对能量变化 $|E(t_\\star)-E(0)|/E(0)$，如果该值严格小于 $0.02$ 的容差，则返回布尔值 true，否则返回 false。这个布尔值必须是第三个输出。\n\n实现要求：\n- 在时间和空间上使用二阶精确的显式格式，在所有时间步强制 $u(0,t)=0$ 和 $u(L,t)=0$，并将 $u(x,0)$ 初始化为两个高斯函数的和。推导并实现 $v(x)=\\partial u/\\partial t(x,0)$，使得第一个高斯波包以速度 $c$ 向右传播，第二个以速度 $c$ 向左传播。\n- 为保证稳定性，使用严格小于 $1$ 的 Courant 数 $\\lambda$。从 $\\lambda$、$c$ 和 $\\Delta x$ 显式计算 $\\Delta t$。\n- 使用 $v(x)$ 和 $u(x,0)$ 的空间梯度计算 $E(0)$，并使用与 $t_\\star$ 处 $\\partial u/\\partial t$ 和 $\\partial u/\\partial x$ 一致的离散近似计算 $E(t_\\star)$。确保对于任何测试案例，模拟的时间跨度都不允许波包与边界相互作用。\n- 你的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为：案例 A 误差（米），案例 B 误差（米），案例 C 能量守恒布尔值。例如：\"[0.00012,0.00003,True]\"。不要打印任何其他文本。\n\n假设和约束：\n- 使用足够大的 $N_x$，使得 $x_\\star$ 位于或非常接近一个网格点，并且高斯函数得到很好的解析。你必须确保 $\\lambda \\in (0,1)$，并且对于每个案例，时间积分都能达到 $t_\\star$。\n- 所有浮点输出都应以原始十进制数给出；不要在打印输出中附加单位。在内部，所有量必须按照上述规定的物理上正确的单位进行处理。",
            "solution": "我们从应用于拉紧均匀弦的微分元的牛顿第二定律开始。设 $\\mu$ 为线质量密度（单位长度的质量），$T$ 为恒定张力。对于小的横向位移 $u(x,t)$，由张力引起的垂直力为 $T \\partial^2 u / \\partial x^2 \\, \\mathrm{d}x$，这等于该元的质量 $\\mu \\, \\mathrm{d}x$ 乘以其垂直加速度 $\\partial^2 u / \\partial t^2$。两边除以 $\\mu \\, \\mathrm{d}x$ 得到标准的波动方程\n$$\n\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}, \\quad c^2 = \\frac{T}{\\mu}.\n$$\n我们施加固定端点条件 $u(0,t)=0$ 和 $u(L,t)=0$，并选择初始条件 $u(x,0) = u_0(x)$ 和 $u_t(x,0)=v_0(x)$ 来产生两个相向传播的高斯波包。\n\n有限差分格式：\n在均匀网格 $x_i = i \\Delta x$（其中 $i=0,\\dots,N_x-1$，$\\Delta x = L/(N_x-1)$）上离散化空间，在时间上离散为 $t_n = n \\Delta t$（其中 $n=0,1,2,\\dots$）。记 $u_i^n \\approx u(x_i,t_n)$。在空间和时间上使用中心差分。波动方程变为\n$$\n\\frac{u_i^{n+1} - 2 u_i^n + u_i^{n-1}}{\\Delta t^2} = c^2 \\frac{u_{i+1}^n - 2 u_i^n + u_{i-1}^n}{\\Delta x^2},\n$$\n或者等价地，显式更新公式为\n$$\nu_i^{n+1} = 2 u_i^n - u_i^{n-1} + \\lambda^2 \\left(u_{i+1}^n - 2 u_i^n + u_{i-1}^n \\right), \\quad \\lambda = \\frac{c \\Delta t}{\\Delta x}.\n$$\nCourant–Friedrichs–Lewy (CFL) 条件要求 $0<\\lambda \\le 1$ 以保证稳定性；我们严格选择 $\\lambda < 1$。通过为所有 $n$ 设置 $u_0^n = 0$ 和 $u_{N_x-1}^n = 0$ 来强制固定端点。\n\n初始化：\n我们需要 $u_i^0 = u_0(x_i)$ 和 $u_i^1$ 来启动递推。在时间上进行二阶泰勒展开得到\n$$\nu(x,t+\\Delta t) = u(x,t) + \\Delta t \\, u_t(x,t) + \\frac{\\Delta t^2}{2} \\, u_{tt}(x,t) + \\mathcal{O}(\\Delta t^3).\n$$\n利用波动方程 $u_{tt} = c^2 u_{xx}$ 和中心空间拉普拉斯算子，我们得到二阶精确的初始步\n$$\nu_i^1 = u_i^0 + \\Delta t \\, v_0(x_i) + \\frac{\\lambda^2}{2}\\left(u_{i+1}^0 - 2 u_i^0 + u_{i-1}^0\\right),\n$$\n并强制边界条件 $u_0^1 = u_{N_x-1}^1 = 0$。\n\n构造反向传播的高斯波包：\n我们定义两个高斯分布\n$$\nf(x) = A_1 \\exp\\!\\left(-\\frac{(x - x_1)^2}{2 \\sigma_1^2}\\right), \\quad\ng(x) = A_2 \\exp\\!\\left(-\\frac{(x - x_2)^2}{2 \\sigma_2^2}\\right),\n$$\n并将初始位移设为它们的和 $u_0(x) = f(x) + g(x)$。为了使 $f$ 以速度 $c$ 向右传播，使 $g$ 以速度 $c$ 向左传播，我们使用从波动方程的线性和不变性推导出的 d’Alembert 分解：$u(x,t) = F(x - c t) + G(x + c t)$，其中 $F$ 和 $G$ 由初始数据确定。匹配 $u_0(x) = f(x) + g(x)$ 得到 $F(x) = f(x)$ 和 $G(x) = g(x)$。在 $t=0$ 时对时间求导得到\n$$\nv_0(x) = \\left.\\frac{\\partial u}{\\partial t}\\right|_{t=0} = - c F'(x) + c G'(x) = - c f'(x) + c g'(x).\n$$\n对于高斯函数的导数，\n$$\n\\frac{d}{dx}\\left[A \\exp\\!\\left(-\\frac{(x - x_0)^2}{2 \\sigma^2}\\right)\\right]\n= - A \\frac{x - x_0}{\\sigma^2} \\exp\\!\\left(-\\frac{(x - x_0)^2}{2 \\sigma^2}\\right).\n$$\n因此，我们从上述表达式显式地构造 $v_0(x) = - c f'(x) + c g'(x)$。\n\n碰撞时间和位置：\n$f$ 和 $g$ 的中心分别位于 $x_f(t) = x_1 + c t$ 和 $x_g(t) = x_2 - c t$。它们在 $x_f(t_\\star) = x_g(t_\\star)$ 时相遇，得到 $t_\\star = (x_2 - x_1)/(2 c)$ 和 $x_\\star = (x_1 + x_2)/2$。在 $(x_\\star,t_\\star)$ 处，连续解的值为 $u(x_\\star,t_\\star) = f(x_1) + g(x_2) = A_1 + A_2$，与 $\\sigma_1$ 和 $\\sigma_2$ 无关。对于 $A_1 = -A_2$ 且宽度对称的破坏性干涉，和为 $0$。\n\n能量及其离散近似：\n总能量为\n$$\nE(t) = \\int_0^L \\frac{1}{2}\\left[\\left(\\frac{\\partial u}{\\partial t}\\right)^2 + c^2 \\left(\\frac{\\partial u}{\\partial x}\\right)^2 \\right] dx,\n$$\n对于具有固定端点的连续波动方程，该能量是守恒的。在离散情况下，我们近似为\n$$\nE^n \\approx \\sum_{i=0}^{N_x-1} \\frac{1}{2} \\left[ (v_i^n)^2 + c^2 (D_x u_i^n)^2 \\right] \\Delta x,\n$$\n其中 $D_x u_i^n$ 是内部点的中心空间差分，\n$$\nD_x u_i^n = \\frac{u_{i+1}^n - u_{i-1}^n}{2 \\Delta x} \\quad \\text{for } 1 \\le i \\le N_x-2,\n$$\n在边界处使用与 $u=0$ 一致的单边差分。对于 $E^0$，我们使用 $v_i^0 = v_0(x_i)$。对于之后时间的 $E^n$，中心时间差分 $v_i^n \\approx \\left(u_i^{n+1} - u_i^{n-1}\\right)/(2 \\Delta t)$ 是二阶的；在一个两层推进的实现中，一个精确的代理是在可用的时间层级上使用 $v_i^{n} \\approx \\left(u_i^{n} - u_i^{n-1}\\right)/\\Delta t$，这足以在与边界相互作用之前的适度时间内监测近似守恒。\n\n算法设计：\n1. 选择一个较大的 $N_x$ 和严格小于 $1$ 的 $\\lambda = c \\Delta t / \\Delta x$；从 $\\lambda$ 计算 $\\Delta t$。\n2. 在 $[0,L]$ 上构建网格 $x_i$，并从两个高斯函数组合成 $u_i^0$。计算 $v_i^0 = -c f'(x_i) + c g'(x_i)$。强制 $u_0^0=u_{N_x-1}^0=0$ 和 $v_0^0=v_{N_x-1}^0=0$。\n3. 使用基于泰勒展开的初始步公式计算 $u_i^1$ 并强制边界值。\n4. 使用显式更新公式进行时间推进，直到刚过 $t_\\star$。检测 $t$ 穿过 $t_\\star$ 的步，并在最接近 $x_\\star$ 的网格索引处进行时间线性插值，以估计 $u(x_\\star,t_\\star)$。\n5. 从 $u^0$ 和 $v^0$ 计算 $E(0)$。从最近的两个时间层和空间梯度计算 $E(t_\\star)$。构成相对能量变化。\n6. 对三个测试案例重复此过程。\n\n测试套件和输出：\n- 案例 A: $L = 1.0$, $c = 1.0$, $A_1 = 0.010$, $A_2 = 0.020$, $\\sigma_1 = 0.050$, $\\sigma_2 = 0.050$, $x_1 = 0.300$, $x_2 = 0.700$。计算绝对误差 $|u(x_\\star,t_\\star) - (A_1 + A_2)|$（以米为单位）。\n- 案例 B: $L = 1.0$, $c = 1.0$, $A_1 = 0.015$, $A_2 = -0.015$, $\\sigma_1 = 0.040$, $\\sigma_2 = 0.040$, $x_1 = 0.350$, $x_2 = 0.650$。计算绝对误差 $|u(x_\\star,t_\\star) - 0.0|$（以米为单位）。\n- 案例 C: $L = 1.0$, $c = 1.0$, $A_1 = 0.010$, $A_2 = 0.013$, $\\sigma_1 = 0.030$, $\\sigma_2 = 0.070$, $x_1 = 0.250$, $x_2 = 0.750$。计算一个布尔值，如果 $|E(t_\\star)-E(0)|/E(0) < 0.02$ 则为 true，否则为 false。\n\n程序输出一行：一个列表，包含案例 A 误差（米）、案例 B 误差（米）和案例 C 的布尔值，按此顺序排列，格式为方括号内的逗号分隔列表，无额外文本。所选的网格和时间步长确保波包在 $t_\\star$ 之前不会到达边界，从而使干涉和能量诊断在模拟窗口内有意义且不受边界反射影响。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef gaussian(x, A, x0, sigma):\n    return A * np.exp(-0.5 * ((x - x0) / sigma) ** 2)\n\ndef gaussian_derivative(x, A, x0, sigma):\n    # d/dx of Gaussian profile\n    return gaussian(x, A, x0, sigma) * (-(x - x0) / (sigma ** 2))\n\ndef discrete_energy(u, v, c, dx):\n    # Spatial derivative with centered differences (one-sided at boundaries)\n    du_dx = np.empty_like(u)\n    du_dx[0] = (u[1] - u[0]) / dx\n    du_dx[-1] = (u[-1] - u[-2]) / dx\n    du_dx[1:-1] = (u[2:] - u[:-2]) / (2.0 * dx)\n    energy_density = 0.5 * (v ** 2 + (c ** 2) * (du_dx ** 2))\n    return np.sum(energy_density) * dx\n\ndef simulate_case(L, c, A1, A2, sigma1, sigma2, x1, x2, Nx=2001, CFL=0.9):\n    # Grid setup\n    x = np.linspace(0.0, L, Nx)\n    dx = x[1] - x[0]\n    dt = CFL * dx / c\n    lam2 = (c * dt / dx) ** 2\n\n    # Initial conditions u0 and v0 to produce right- and left-moving Gaussians\n    f = gaussian(x, A1, x1, sigma1)  # right-moving\n    g = gaussian(x, A2, x2, sigma2)  # left-moving\n    u0 = f + g\n    v0 = -c * gaussian_derivative(x, A1, x1, sigma1) + c * gaussian_derivative(x, A2, x2, sigma2)\n\n    # Enforce fixed ends\n    u0[0] = 0.0\n    u0[-1] = 0.0\n    v0[0] = 0.0\n    v0[-1] = 0.0\n\n    # First time step (second-order accurate)\n    u1 = np.empty_like(u0)\n    u1[1:-1] = u0[1:-1] + dt * v0[1:-1] + 0.5 * lam2 * (u0[2:] - 2.0 * u0[1:-1] + u0[:-2])\n    u1[0] = 0.0\n    u1[-1] = 0.0\n\n    # Collision time and location\n    t_star = (x2 - x1) / (2.0 * c)\n    x_star = 0.5 * (x1 + x2)\n    # Index nearest to x_star\n    i_star = int(np.round((x_star - x[0]) / dx))\n    i_star = max(0, min(Nx - 1, i_star))\n\n    # Energy at t=0\n    E0 = discrete_energy(u0, v0, c, dx)\n\n    # Time march until just past t_star\n    t_prev = 0.0\n    t_curr = dt\n    u_prev = u0.copy()\n    u_curr = u1.copy()\n\n    u_at_tstar = None\n\n    # If t_star is before dt (unlikely with these parameters), handle interpolation from u0 and u1\n    if t_prev = t_star = t_curr:\n        alpha = (t_star - t_prev) / (t_curr - t_prev)\n        u_at_tstar = (1.0 - alpha) * u_prev[i_star] + alpha * u_curr[i_star]\n\n    # March forward\n    # Target to go slightly beyond t_star\n    t_end = t_star + 2.0 * dt\n    n_steps = int(np.ceil((t_end - t_curr) / dt))\n    for _ in range(n_steps):\n        u_next = np.empty_like(u_curr)\n        # Interior update\n        u_next[1:-1] = (2.0 * u_curr[1:-1] - u_prev[1:-1] +\n                        lam2 * (u_curr[2:] - 2.0 * u_curr[1:-1] + u_curr[:-2]))\n        # Fixed ends\n        u_next[0] = 0.0\n        u_next[-1] = 0.0\n\n        # Advance times\n        t_next = t_curr + dt\n\n        # Capture u at t_star by temporal interpolation when crossed\n        if u_at_tstar is None and (t_curr = t_star = t_next):\n            alpha = (t_star - t_curr) / (t_next - t_curr)\n            u_at_tstar = (1.0 - alpha) * u_curr[i_star] + alpha * u_next[i_star]\n\n        # Shift\n        u_prev, u_curr = u_curr, u_next\n        t_prev, t_curr = t_curr, t_next\n\n    # Safety: if u_at_tstar still None due to rounding, take nearest\n    if u_at_tstar is None:\n        u_at_tstar = u_curr[i_star]\n\n    # Approximate velocity at final time level for energy at t_star\n    v_end = (u_curr - u_prev) / dt\n    E_end = discrete_energy(u_curr, v_end, c, dx)\n\n    return u_at_tstar, E0, E_end\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Case A: constructive interference\n    case_A = dict(L=1.0, c=1.0, A1=0.010, A2=0.020, sigma1=0.050, sigma2=0.050, x1=0.300, x2=0.700)\n    # Case B: destructive interference\n    case_B = dict(L=1.0, c=1.0, A1=0.015, A2=-0.015, sigma1=0.040, sigma2=0.040, x1=0.350, x2=0.650)\n    # Case C: energy check\n    case_C = dict(L=1.0, c=1.0, A1=0.010, A2=0.013, sigma1=0.030, sigma2=0.070, x1=0.250, x2=0.750)\n\n    # Common numerical parameters\n    Nx = 2001\n    CFL = 0.9\n\n    # Run simulations\n    uA_at_star, EA0, EAend = simulate_case(Nx=Nx, CFL=CFL, **case_A)\n    uB_at_star, EB0, EBend = simulate_case(Nx=Nx, CFL=CFL, **case_B)\n    uC_at_star, EC0, ECend = simulate_case(Nx=Nx, CFL=CFL, **case_C)\n\n    # Expected values at collision\n    expected_A = case_A[\"A1\"] + case_A[\"A2\"]  # constructive\n    expected_B = 0.0  # destructive\n\n    err_A = abs(uA_at_star - expected_A)  # meters\n    err_B = abs(uB_at_star - expected_B)  # meters\n\n    rel_energy_change_C = abs(ECend - EC0) / EC0 if EC0 != 0.0 else float('inf')\n    energy_ok_C = bool(rel_energy_change_C  0.02)\n\n    results = [err_A, err_B, energy_ok_C]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "真实世界的物理系统很少是均匀的。这个高级实践将我们的模型扩展到具有非均匀、时变波速的弦，仿佛一束移动的“聚光灯”正在改变其物理属性。你将学习如何实现一个更稳健的守恒型数值格式来处理这些可变系数 ，这为模拟波在复杂、非均匀介质中的传播以及观察散射和部分反射等现象打开了大门。",
            "id": "2438557",
            "problem": "要求您对一维振动弦进行建模，其局部波速受光调制。横向位移场表示为 $u(x,t)$，定义在空间域 $x \\in [0,L]$ 上，两端固定。从牛顿第二定律和局部波速 $c(x,t)$ 的定义出发，为以下偏微分方程推导一个在空间和时间上保守的、二阶精确的有限差分格式\n$$\nu_{tt}(x,t) \\;=\\; \\partial_x\\!\\big(c^2(x,t)\\,u_x(x,t)\\big),\n$$\n边界条件为齐次 Dirichlet 条件 $u(0,t)=u(L,t)=0$，初始数据给定为 $u(x,0)=u_0(x)$，$u_t(x,0)=v_0(x)$。光敏波速由下式给出\n$$\nc(x,t) \\;=\\; c_0\\,\\sqrt{\\,1 - \\beta\\,I(x,t)\\,},\\quad\nI(x,t) \\;=\\; \\exp\\!\\left(-\\dfrac{(x - x_s(t))^2}{2\\sigma^2}\\right),\\quad\nx_s(t) \\;=\\; x_{\\text{start}} + v_s\\,t,\n$$\n其中 $c_0$ 是基准波速，单位为 $\\mathrm{m/s}$；$0 \\le \\beta  1$ 是光敏系数（无量纲）；$\\sigma$ 是光斑宽度，单位为 $\\mathrm{m}$；$v_s$ 是光斑速度，单位为 $\\mathrm{m/s}$。您可以假设所有参数都使得 $c(x,t)$ 在所有关心的 $x$ 和 $t$ 上保持为实数且严格为正。\n\n您的任务是：\n1) 从微小弦元上的力平衡以及定义 $c^2(x,t) = T(x,t)/\\rho$ 出发（其中 $T(x,t)$ 是局部张力，$\\rho$ 是单位长度的质量密度），证明在小斜率极限下，当光通过给定的 $c(x,t)$ 以 $T(x,t)=\\rho\\,c^2(x,t)$ 的方式调制张力时，可以得到上述控制方程。\n\n2) 在均匀网格 $x_i = i\\,\\Delta x$（$i=0,1,\\dots,N-1$，$\\Delta x = L/(N-1)$）和均匀时间步长 $t^n = n\\,\\Delta t$（$n=0,1,2,\\dots$）上对方程进行离散化。对通量 $\\partial_x\\!\\big(c^2 u_x\\big)$ 使用带有半节点系数的空间中心差分，对 $u_{tt}$ 使用时间中心差分。即，近似为\n$$\n\\big(c^2 u_x\\big)_x\\Big|_{x=x_i,\\,t=t^{n+\\tfrac{1}{2}}} \\;\\approx\\; \\dfrac{1}{\\Delta x^2}\\left[a^{n+\\tfrac{1}{2}}_{i+\\tfrac{1}{2}}\\,(u^n_{i+1}-u^n_i)-a^{n+\\tfrac{1}{2}}_{i-\\tfrac{1}{2}}\\,(u^n_i-u^n_{i-1})\\right],\n$$\n其中 $a^{n+\\tfrac{1}{2}}_{i\\pm \\tfrac{1}{2}}$ 使用节点值 $a=c^2$ 的算術平均来近似 $c^2\\!\\left(x_{i\\pm \\tfrac{1}{2}},t^{n+\\tfrac{1}{2}}\\right)$。推导内部节点 $i=1,\\dots,N-2$ 处 $u^{n+1}_i$ 的显式更新公式，以及一个相容的二阶启动公式用于计算 $u^1_i$，该公式使用 $u^0_i$、$v^0_i$ 以及在 $t^{\\tfrac{1}{2}}$ 处计算的空间算子。\n\n3) 以 $\\Delta t$、$\\Delta x$ 和最大波速的形式，陈述一个充分的 Courant–Friedrichs–Lewy (CFL) 稳定性条件。使用该条件通过 $\\Delta t = C_{\\mathrm{CFL}}\\,\\Delta x/\\max_{x,t} c(x,t)$（其中 $0  C_{\\mathrm{CFL}} \\le 1$）来选择 $\\Delta t$。对于本问题，您必须取 $C_{\\mathrm{CFL}} = 0.9$，并注意对于给定的模型，$\\max_{x,t} c(x,t) = c_0$。\n\n4) 在一个程序中实现该显式格式，并运行三个指定的测试用例。对所有 $n$ 使用固定端点边界条件 $u_0^n = u_{N-1}^n = 0$。所需的观测量和单位在下面指定。\n\n实现细节和物理单位：\n- 所有长度单位必须是 $\\mathrm{m}$，时间单位是 $\\mathrm{s}$，波速单位是 $\\mathrm{m/s}$。位移以 $\\mathrm{m}$ 报告，频率以 $\\mathrm{Hz}$ 报告。\n- 如果使用角度，单位必须是弧度。\n- 最终程序必须产生单行输出，包含一个 Python 风格的列表，内含按测试用例顺序排列的三个浮点数，每个数四舍五入到六位小数。\n\n测试套件（每个测试集必须使用提供的参数独立模拟）：\n- 测试 $1$（正常路径；移动光斑，高斯初始凸起）：\n  - $L = 1.0\\,\\mathrm{m}$，$c_0 = 100.0\\,\\mathrm{m/s}$，$\\beta = 0.3$，$\\sigma = 0.05\\,\\mathrm{m}$，$v_s = 2.0\\,\\mathrm{m/s}$，$x_{\\text{start}} = 0.0\\,\\mathrm{m}$。\n  - 网格：$N = 401$ 个点，因此 $\\Delta x = L/(N-1)$。\n  - 时间步长：$\\Delta t = 0.9\\,\\Delta x/c_0$。\n  - 结束时间：$T_{\\text{end}} = 0.015\\,\\mathrm{s}$。\n  - 初始条件：$u_0(x) = A\\,\\exp\\!\\left(-\\dfrac{(x-x_c)^2}{2w^2}\\right)$，其中 $A = 1.0\\times 10^{-3}\\,\\mathrm{m}$，$x_c = 0.25\\,L$，$w = 0.02\\,\\mathrm{m}$，以及 $v_0(x)=0$。\n  - 输出：位移在结束时刻的空间 $\\mathrm{L}^2$ 范数，定义为 $\\|u(\\cdot,T_{\\text{end}})\\|_2 = \\left(\\sum_{i=0}^{N-1} u_i^2(T_{\\text{end}})\\,\\Delta x\\right)^{1/2}$，单位为 $\\mathrm{m}$。\n\n- 测试 $2$（边界相互作用边缘情况；存在光斑，凸起靠近边界）：\n  - $L = 1.0\\,\\mathrm{m}$，$c_0 = 100.0\\,\\mathrm{m/s}$，$\\beta = 0.5$，$\\sigma = 0.03\\,\\mathrm{m}$，$v_s = 3.0\\,\\mathrm{m/s}$，$x_{\\text{start}} = 0.0\\,\\mathrm{m}$。\n  - 网格：$N = 401$。\n  - 时间步长：$\\Delta t = 0.9\\,\\Delta x/c_0$。\n  - 结束时间：$T_{\\text{end}} = 0.010\\,\\mathrm{s}$。\n  - 初始条件：$u_0(x) = A\\,\\exp\\!\\left(-\\dfrac{(x-x_c)^2}{2w^2}\\right)$，其中 $A = 1.0\\times 10^{-3}\\,\\mathrm{m}$，$x_c = 0.02\\,\\mathrm{m}$，$w = 0.01\\,\\mathrm{m}$，以及 $v_0(x)=0$。\n  - 输出：在整个模拟区间内，在弦上任意位置观测到的最大绝对位移，$\\max_{0\\le n \\le T_{\\text{end}}/\\Delta t}\\max_{0\\le i \\le N-1} |u_i^n|$，单位为 $\\mathrm{m}$。\n\n- 测试 $3$（一致性检查；无光斑，第一简正模和频率提取）：\n  - $L = 1.0\\,\\mathrm{m}$，$c_0 = 100.0\\,\\mathrm{m/s}$，$\\beta = 0.0$（因此 $c(x,t)\\equiv c_0$），$\\sigma$ 和 $v_s$ 为任意值且未使用。\n  - 网格：$N = 601$。\n  - 时间步长：$\\Delta t = 0.9\\,\\Delta x/c_0$。\n  - 结束时间：$T_{\\text{end}} = 0.100\\,\\mathrm{s}$。\n  - 初始条件：$u_0(x) = A\\,\\sin\\!\\left(\\dfrac{\\pi x}{L}\\right)$，其中 $A=1.0\\times 10^{-3}\\,\\mathrm{m}$ 以及 $v_0(x)=0$。\n  - 随时间跟踪波腹 $x=L/2$ 处的 $u$，通过检测零点交叉并对交叉时间进行线性插值来估计平均周期，从而估算主导振荡频率。理论上的第一模式频率是 $f_1 = c_0/(2L)$，单位为 $\\mathrm{Hz}$。\n  - 输出：绝对误差 $|f_{\\text{num}} - f_1|$，单位为 $\\mathrm{Hz}$。\n\n最终输出格式：\n- 您的程序应产生单行输出，包含一个 Python 列表，其中有三个数字，按顺序对应测试 $1$、$2$ 和 $3$，四舍五入到六位小数，例如：$\\texttt{[0.001234,0.001345,0.000120]}$。",
            "solution": "所提出的问题是计算物理学中一个标准的、适定的初边值问题。它在科学上是合理的，数学上是一致的，并且提供了获得唯一、稳定数值解所需的所有参数和条件。因此，该问题被认为是**有效的**，并将提供一个解。\n\n主要任务是推导并实现一个用于一维变系数波动方程的有限差分格式，该方程由下式给出\n$$\nu_{tt}(x,t) \\;=\\; \\partial_x\\!\\big(c^2(x,t)\\,u_x(x,t)\\big)\n$$\n其中 $u(x,t)$ 是弦的横向位移，$c(x,t)$ 是非均匀、随时间变化的波速。\n\n**1. 控制方程的推导**\n\n我们从牛顿第二定律应用于水平位置 $x$ 和 $x+\\Delta x$ 之间长度为 $\\Delta s$ 的弦的无穷小元开始。设 $\\rho$ 为恒定的线质量密度。该元的质量为 $\\Delta m = \\rho \\Delta s$。对于小位移，斜率 $u_x = \\partial u/\\partial x$ 很小，因此弦元的长度约等于其水平投影，即 $\\Delta s \\approx \\Delta x$。那么质量为 $\\Delta m \\approx \\rho \\Delta x$。\n\n作用在弦元上的净垂直力是其两端张力 $T(x,t)$ 垂直分量的差。在某一点，张力的垂直分量是 $T \\sin\\theta$，其中 $\\theta$ 是弦与水平方向的夹角。在小斜率近似下，$\\sin\\theta \\approx \\tan\\theta = u_x$。\n因此，净垂直力 $\\Delta F_v$ 为\n$$\n\\Delta F_v \\;=\\; T(x+\\Delta x, t)\\,u_x(x+\\Delta x, t) - T(x,t)\\,u_x(x,t).\n$$\n根据牛顿第二定律 $F=ma$，净力等于质量乘以加速度，其中加速度是位移对时间的二阶偏导数 $u_{tt}$。\n$$\n(\\rho \\Delta x)\\, u_{tt}(x,t) \\;=\\; T(x+\\Delta x, t)\\,u_x(x+\\Delta x, t) - T(x,t)\\,u_x(x,t).\n$$\n两边同除以 $\\Delta x$ 并取 $\\Delta x \\to 0$ 的极限，得到对 $x$ 的偏导数定义：\n$$\n\\rho\\,u_{tt}(x,t) \\;=\\; \\partial_x \\big( T(x,t)\\,u_x(x,t) \\big).\n$$\n问题陈述中定义了波速的平方为 $c^2(x,t) = T(x,t)/\\rho$，这意味着张力被调制为 $T(x,t) = \\rho\\,c^2(x,t)$。将此代入运动方程得到\n$$\n\\rho\\,u_{tt}(x,t) \\;=\\; \\partial_x \\big( \\rho\\,c^2(x,t)\\,u_x(x,t) \\big).\n$$\n由于 $\\rho$ 是常数，可以从空间导数中提出并在等式两边消去，从而得到指定的控制方程：\n$$\nu_{tt}(x,t) \\;=\\; \\partial_x\\big(c^2(x,t)\\,u_x(x,t)\\big).\n$$\n推导完成。该方程的形式是保守的，因为其空间部分是一个通量的散度，在这里是横向动量的通量。\n\n**2. 有限差分格式的推导**\n\n我们将区域离散化，使用均匀空间网格 $x_i = i\\,\\Delta x$ ($i=0, 1, \\dots, N-1$，其中 $\\Delta x = L/(N-1)$) 和均匀时间步长 $t^n = n\\,\\Delta t$。位移表示为 $u_i^n \\approx u(x_i, t^n)$。\n\n在 $(x_i, t^n)$ 处的二阶时间导数 $u_{tt}$ 使用二阶精确的中心差分近似：\n$$\nu_{tt}(x_i, t^n) \\;\\approx\\; \\frac{u_i^{n+1} - 2u_i^n + u_i^{n-1}}{\\Delta t^2}.\n$$\n空间算子 $\\partial_x(c^2 u_x)$ 按照问题陈述中的規定进行离散化。这是一个针对通量项的二阶精确中心差分格式。令 $a(x,t) = c^2(x,t)$。通量为 $F(x,t) = a(x,t)u_x(x,t)$。我们有 $\\partial_x F \\approx (F_{i+1/2} - F_{i-1/2})/\\Delta x$。半网格点上的通量近似为 $F_{i\\pm 1/2} \\approx a_{i\\pm 1/2} (u_{i\\pm 1} - u_i)/\\Delta x$。这就得到了指定的形式，我们将其表示为 $\\mathcal{L}[u]$。问题要求在半时间步 $t^{n+1/2}$ 处计算系数 $a = c^2$，同时使用时间 $t^n$ 处的位移 $u$。完整的离散方程为：\n$$\n\\frac{u_i^{n+1} - 2u_i^n + u_i^{n-1}}{\\Delta t^2} \\;=\\; \\frac{1}{\\Delta x^2}\\left[a^{n+\\tfrac{1}{2}}_{i+\\tfrac{1}{2}}\\,(u^n_{i+1}-u^n_i)-a^{n+\\tfrac{1}{2}}_{i-\\tfrac{1}{2}}\\,(u^n_i-u^n_{i-1})\\right],\n$$\n其中半节点上的系数是节点值的算术平均：\n$$\na^{n+\\tfrac{1}{2}}_{i\\pm\\tfrac{1}{2}} \\;=\\; \\frac{1}{2}\\left( a(x_i, t^{n+\\tfrac{1}{2}}) + a(x_{i\\pm 1}, t^{n+\\tfrac{1}{2}}) \\right).\n$$\n该格式是显式的。求解 $u_i^{n+1}$ 可得内部节点（$i=1, \\dots, N-2$）的更新规则：\n$$\nu_i^{n+1} \\;=\\; 2u_i^n - u_i^{n-1} + \\left(\\frac{\\Delta t}{\\Delta x}\\right)^2 \\left[a^{n+\\tfrac{1}{2}}_{i+\\tfrac{1}{2}}(u^n_{i+1}-u^n_i)-a^{n+\\tfrac{1}{2}}_{i-\\tfrac{1}{2}}(u^n_i-u^n_{i-1})\\right].\n$$\n边界条件为对所有 $n \\ge 0$，$u_0^n = 0$ 和 $u_{N-1}^n = 0$。\n\n对于第一个时间步（$n=0$），我们需要 $u^1_i$。通用更新公式需要 $u^{-1}_i$，但该值未给出。我们使用初始速度 $v_0(x) = u_t(x,0)$ 以及在 $t=0$ 处的中心差分近似：\n$$\nv_i^0 \\;\\approx\\; \\frac{u_i^1 - u_i^{-1}}{2\\Delta t} \\quad\\implies\\quad u_i^{-1} \\;=\\; u_i^1 - 2\\Delta t v_i^0.\n$$\n将此代入 $n=0$ 的更新规则中得到：\n$$\nu_i^1 \\;=\\; 2u_i^0 - (u_i^1 - 2\\Delta t v_i^0) + \\Delta t^2 \\mathcal{L}^{1/2}[u^0]_i,\n$$\n其中 $\\mathcal{L}^{1/2}[u^0]_i$ 是空间算子，其系数在 $t^{1/2}=\\Delta t/2$ 处计算，并作用于 $u^0$。求解 $u_i^1$ 得到二阶精确的启动公式：\n$$\nu_i^1 \\;=\\; u_i^0 + \\Delta t v_i^0 + \\frac{\\Delta t^2}{2} \\mathcal{L}^{1/2}[u^0]_i.\n$$\n此公式与问题要求相符。\n\n**3. 稳定性条件**\n\n对于波动方程的显式有限差分格式，稳定性由 Courant–Friedrichs–Lewy (CFL) 条件决定。对于可变波速 $c(x,t)$，一个充分的稳定性条件是数值依赖域必须包含物理依赖域。这导致了以下要求：\n$$\nC_{\\text{CFL}} \\;=\\; \\frac{\\max_{x,t} c(x,t) \\cdot \\Delta t}{\\Delta x} \\;\\le\\; 1.\n$$\n波速由 $c(x,t) = c_0\\sqrt{1 - \\beta I(x,t)}$ 给出。由于 $0 \\le \\beta  1$ 且强度项 $I(x,t) = \\exp(\\dots)$ 是非负的，所以 $c(x,t)$ 的最大值出现在 $I(x,t)$ 取最小值处。$I(x,t)$ 的最小值为 $0$，发生在 $|x-x_s(t)| \\to \\infty$ 时。因此，$\\max_{x,t} c(x,t) = c_0$。\n稳定性条件简化为 $c_0 \\Delta t / \\Delta x \\le 1$。问题指定选择时间步长为\n$$\n\\Delta t = 0.9 \\frac{\\Delta x}{c_0},\n$$\n这对应于 Courant 数 $C_{\\text{CFL}} = 0.9$。由于 $0.9 \\le 1$，在此选择下格式是稳定的。\n\n**4. 实现策略**\n\n数值格式使用 Python 和 `numpy` 库来实现，以进行高效的数组运算。\n- 模拟状态由三个数组维持：`u_prev` ($u^{n-1}$)、`u_curr` ($u^n$) 和 `u_next` ($u^{n+1}$)。\n- 模拟开始时，根据初始条件 $u_0(x)$ 初始化 `u_curr` 并应用边界条件。\n- 第一个时间步使用推导出的启动公式计算 $u^1$，由于所有测试用例的初始速度 $v_0(x)=0$，这是一个特殊情况。\n- 然后主循环从 $n=1$ 迭代到最后一个时间步。在每次迭代中，它使用通用更新规则从 $u^n$ 和 $u^{n-1}$ 计算 $u^{n+1}$。\n- 在每一步中，首先计算随时间变化的系数 $a(x, t^{n+1/2})$，然后计算平均的半节点系数。接着，使用向量化的 `numpy` 操作在内部网格点上计算空间算子。\n- 每次更新后都强制执行边界条件 $u_0=0, u_{N-1}=0$。\n- 计算每个测试用例所需的观测量：\n  - **测试 1：** 在循环结束后计算最终的空间 $\\mathrm{L}^2$ 范数 $\\|u(\\cdot, T_{\\text{end}})\\|_2 = \\left(\\sum_i (u_i^{\\text{final}})^2 \\Delta x\\right)^{1/2}$。\n  - **测试 2：** 在每个时间步的循环内更新最大绝对位移 $\\max_{n,i}|u_i^n|$。\n  - **测试 3：** 记录弦中点 $u(L/2, t)$ 的位移。模拟结束后，处理这些时间序列数据，通过符号变化检测零点交叉。使用线性插值来估计每次交叉的精确时间。交叉点之间的时间差的平均值给出半周期，由此计算出数值频率 $f_{\\text{num}}$。最终结果是绝对误差 $|f_{\\text{num}} - f_1|$，其中 $f_1 = c_0/(2L)$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that runs three test cases for the vibrating string simulation.\n    \"\"\"\n\n    def run_simulation(L, c0, beta, sigma, vs, x_start, N, T_end, u0_func, v0_func, C_CFL=0.9):\n        \"\"\"\n        Generic simulation engine for the 1D wave equation with variable coefficients.\n        \"\"\"\n        dx = L / (N - 1)\n        x = np.linspace(0, L, N)\n        \n        c_max = c0\n        dt = C_CFL * dx / c_max\n        \n        num_steps = int(np.ceil(T_end / dt))\n        \n        def x_s(t):\n            \"\"\"Calculates the center of the moving spotlight at a given time.\"\"\"\n            return x_start + vs * t\n\n        def I(x_nodes, t):\n            \"\"\"Calculates the light intensity profile on the grid at a given time.\"\"\"\n            return np.exp(-(x_nodes - x_s(t))**2 / (2 * sigma**2))\n\n        def a(x_nodes, t):\n            \"\"\"Calculates the square of the wave speed, c^2, on the grid.\"\"\"\n            if beta == 0:\n                return np.full_like(x_nodes, c0**2)\n            return c0**2 * (1 - beta * I(x_nodes, t))\n\n        # Initialize displacement fields\n        u_prev = np.zeros(N)\n        u_curr = u0_func(x)\n        u_next = np.zeros(N)\n        v0 = v0_func(x)\n        \n        # Apply boundary conditions to initial state\n        u_curr[0] = 0\n        u_curr[-1] = 0\n\n        # Storage for observables\n        max_abs_u = np.max(np.abs(u_curr))\n        u_mid_history = []\n        time_history = []\n        mid_point_idx = (N - 1) // 2\n\n        # First step (n=0 to n=1) using the second-order start-up formula\n        t_half = 0.5 * dt\n        a_vals_t_half = a(x, t_half)\n        \n        a_half_p = 0.5 * (a_vals_t_half[1:-1] + a_vals_t_half[2:])\n        a_half_m = 0.5 * (a_vals_t_half[:-2] + a_vals_t_half[1:-1])\n\n        spatial_op_u0 = (a_half_p * (u_curr[2:] - u_curr[1:-1]) - \n                         a_half_m * (u_curr[1:-1] - u_curr[:-2]))\n        \n        u_next[1:-1] = (u_curr[1:-1] + dt * v0[1:-1] + \n                        0.5 * (dt / dx)**2 * spatial_op_u0)\n\n        # Update state variables for the main loop\n        u_prev[:] = u_curr\n        u_curr[:] = u_next\n        \n        # Update observables after first step\n        max_abs_u = max(max_abs_u, np.max(np.abs(u_curr)))\n        if beta == 0.0:  # For Test 3\n            u_mid_history.append(u_curr[mid_point_idx])\n            time_history.append(dt)\n        \n        # Main time-stepping loop (n=1, 2, ..., num_steps-1)\n        for n in range(1, num_steps):\n            t_n_plus_half = (n + 0.5) * dt\n            \n            a_vals_n_plus_half = a(x, t_n_plus_half)\n            \n            a_half_p = 0.5 * (a_vals_n_plus_half[1:-1] + a_vals_n_plus_half[2:])\n            a_half_m = 0.5 * (a_vals_n_plus_half[:-2] + a_vals_n_plus_half[1:-1])\n\n            spatial_op_un = (a_half_p * (u_curr[2:] - u_curr[1:-1]) -\n                             a_half_m * (u_curr[1:-1] - u_curr[:-2]))\n            \n            u_next[1:-1] = (2 * u_curr[1:-1] - u_prev[1:-1] + \n                            (dt / dx)**2 * spatial_op_un)\n            \n            u_prev[:] = u_curr\n            u_curr[:] = u_next\n            \n            max_abs_u = max(max_abs_u, np.max(np.abs(u_curr)))\n            if beta == 0.0:\n                u_mid_history.append(u_curr[mid_point_idx])\n                time_history.append((n + 1) * dt)\n\n        return u_curr, dx, max_abs_u, u_mid_history, time_history\n\n    # --- Test Case 1 ---\n    L1, c0_1, beta1, sigma1, vs1, x_start1 = 1.0, 100.0, 0.3, 0.05, 2.0, 0.0\n    N1, T_end1 = 401, 0.015\n    A1, xc1, w1 = 1.0e-3, 0.25 * L1, 0.02\n    u0_1 = lambda x: A1 * np.exp(-(x - xc1)**2 / (2 * w1**2))\n    v0_1 = lambda x: np.zeros_like(x)\n    u_final1, dx1, _, _, _ = run_simulation(L1, c0_1, beta1, sigma1, vs1, x_start1, N1, T_end1, u0_1, v0_1)\n    l2_norm = np.sqrt(np.sum(u_final1**2) * dx1)\n    result1 = round(l2_norm, 6)\n\n    # --- Test Case 2 ---\n    L2, c0_2, beta2, sigma2, vs2, x_start2 = 1.0, 100.0, 0.5, 0.03, 3.0, 0.0\n    N2, T_end2 = 401, 0.010\n    A2, xc2, w2 = 1.0e-3, 0.02, 0.01\n    u0_2 = lambda x: A2 * np.exp(-(x - xc2)**2 / (2 * w2**2))\n    v0_2 = lambda x: np.zeros_like(x)\n    _, _, max_u, _, _ = run_simulation(L2, c0_2, beta2, sigma2, vs2, x_start2, N2, T_end2, u0_2, v0_2)\n    result2 = round(max_u, 6)\n\n    # --- Test Case 3 ---\n    L3, c0_3, beta3, N3, T_end3, A3 = 1.0, 100.0, 0.0, 601, 0.100, 1.0e-3\n    u0_3 = lambda x: A3 * np.sin(np.pi * x / L3)\n    v0_3 = lambda x: np.zeros_like(x)\n    _, _, _, u_mid, t_hist = run_simulation(L3, c0_3, beta3, 1.0, 0.0, 0.0, N3, T_end3, u0_3, v0_3)\n    \n    u_mid = np.array(u_mid)\n    t_hist = np.array(t_hist)\n    \n    # Find zero crossings by detecting sign changes\n    crossings_indices = np.where(np.diff(np.sign(u_mid)))[0]\n    \n    crossing_times = []\n    for idx in crossings_indices:\n        t1, t2 = t_hist[idx], t_hist[idx+1]\n        u1, u2 = u_mid[idx], u_mid[idx+1]\n        # Linear interpolation to find precise time of zero crossing\n        if u2 - u1 != 0:\n            t_cross = t1 - u1 * (t2 - t1) / (u2 - u1)\n            crossing_times.append(t_cross)\n            \n    if len(crossing_times)  2:\n        f_num = np.nan\n    else:\n        half_periods = np.diff(crossing_times)\n        avg_period = 2 * np.mean(half_periods)\n        f_num = 1 / avg_period\n        \n    f_theory = c0_3 / (2 * L3)\n    abs_error = abs(f_num - f_theory)\n    result3 = round(abs_error, 6)\n    \n    results = [f\"{result1:.6f}\", f\"{result2:.6f}\", f\"{result3:.6f}\"]\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}