{
    "hands_on_practices": [
        {
            "introduction": "The Crank-Nicolson scheme is celebrated for its unconditional stability when applied to the heat equation, but does this guarantee a physically meaningful solution for any choice of time step? This exercise critically examines the distinction between numerical stability, which ensures the solution remains bounded, and physical fidelity. By simulating the diffusion of a sharp, discontinuous profile with a large time step, you will directly observe and detect the emergence of non-physical oscillations, even as the solution remains numerically stable . This practice imparts a crucial lesson on the practical limitations of the scheme and the importance of solution quality over mere stability.",
            "id": "2443615",
            "problem": "Consider the one-dimensional heat equation\n$$\n\\frac{\\partial u}{\\partial t} = \\alpha \\frac{\\partial^2 u}{\\partial x^2}, \\quad x \\in (0,1), \\quad t &gt; 0,\n$$\nwith homogeneous Dirichlet boundary conditions\n$$\nu(0,t) = 0, \\quad u(1,t) = 0, \\quad t \\ge 0,\n$$\nand initial condition given by a compactly supported top-hat profile\n$$\nu(x,0) = \\begin{cases}\n1, & |x - 1/2| \\le w/2,\\\\\n0, & \\text{otherwise},\n\\end{cases}\n$$\nwhere the width is $w = 0.1$. Use a uniform spatial grid with $M$ equal subintervals on $[0,1]$, so that the spatial step size is $\\Delta x = 1/M$ and the grid points are $x_i = i \\,\\Delta x$ for $i = 0,1,\\ldots,M$. The interior unknowns are at indices $i = 1,2,\\ldots,M-1$. Time integration is to be performed by the trapezoidal rule in time (also known as the Crank–Nicolson scheme) applied to the semi-discrete system that arises from second-order centered finite differences in space. Let the diffusion number be\n$$\nr = \\frac{\\alpha \\,\\Delta t}{(\\Delta x)^2},\n$$\nwith a fixed $\\alpha = 1$. Evolve the numerical solution from $t=0$ up to $t = T_{\\text{end}}$ with a constant time step $\\Delta t$ determined by the specified value of $r$. The objective is to detect physically inaccurate oscillations in time that may arise for large $r$, manifested as the appearance of negative values in the numerical solution even though the exact solution remains nonnegative for $t&gt;0$ under the given conditions.\n\nDefine an “oscillation detected” boolean for a given parameter set as follows: after each time step, if any interior grid value strictly falls below a tolerance threshold of $-10^{-10}$ at any time $t \\in (0, T_{\\text{end}}]$, then set the boolean to $\\text{True}$; otherwise set it to $\\text{False}$. The boundary values at $x=0$ and $x=1$ are fixed at $0$ and should not be used for the detection criterion.\n\nYour program must implement the above mathematical model and detection rule for the following test suite of parameter values $(M, r, T_{\\text{end}})$, with $\\alpha = 1$ and $w = 0.1$ held fixed:\n- Test A (happy path, small diffusion number): $(M, r, T_{\\text{end}}) = (100, 0.1, 0.05)$.\n- Test B (boundary regime near sign-change threshold): $(M, r, T_{\\text{end}}) = (100, 0.5, 0.05)$.\n- Test C (moderately large diffusion number): $(M, r, T_{\\text{end}}) = (100, 0.6, 0.05)$.\n- Test D (very large diffusion number): $(M, r, T_{\\text{end}}) = (100, 5.0, 0.05)$.\n\nFor each test, the single result is the boolean “oscillation detected” as defined above. Your program should produce a single line of output containing the four boolean results for Tests A–D, in order, as a comma-separated list enclosed in square brackets (e.g., “[False,True,True,False]”). No physical units are required in the output. Angles are not involved. Percentages are not involved. The output must adhere exactly to the specified format.",
            "solution": "The problem presented is valid. It is a well-defined problem in computational science, based on fundamental principles of numerical analysis for partial differential equations. All necessary parameters and conditions are provided, and there are no scientific or logical contradictions. We will proceed with the solution.\n\nThe problem requires the numerical solution of the one-dimensional heat equation:\n$$\n\\frac{\\partial u}{\\partial t} = \\alpha \\frac{\\partial^2 u}{\\partial x^2}, \\quad x \\in (0,1), \\quad t > 0\n$$\nThe thermal diffusivity is given as $\\alpha = 1$. The boundary conditions are of homogeneous Dirichlet type:\n$$\nu(0,t) = 0, \\quad u(1,t) = 0, \\quad t \\ge 0\n$$\nThe initial condition is a top-hat function of width $w = 0.1$:\n$$\nu(x,0) = \\begin{cases}\n1, & \\text{if } |x - 1/2| \\le 0.1/2 \\\\\n0, & \\text{otherwise}\n\\end{cases}\n$$\nThis corresponds to $u(x,0)=1$ for $x \\in [0.45, 0.55]$.\n\nFirst, we perform a semi-discretization in space. The spatial domain $[0,1]$ is discretized into $M$ subintervals of equal length $\\Delta x = 1/M$. The grid points are $x_i = i \\Delta x$ for $i = 0, 1, \\ldots, M$. Let $u_i(t)$ be the numerical approximation of $u(x_i, t)$. The second spatial derivative is approximated using a second-order central difference formula:\n$$\n\\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{x=x_i} \\approx \\frac{u_{i+1}(t) - 2u_i(t) + u_{i-1}(t)}{(\\Delta x)^2}\n$$\nApplying this to the interior grid points $i = 1, 2, \\ldots, M-1$, we obtain a system of ordinary differential equations (ODEs):\n$$\n\\frac{d u_i}{dt} = \\frac{\\alpha}{(\\Delta x)^2} (u_{i+1} - 2u_i + u_{i-1})\n$$\nLet $\\mathbf{u}(t) = [u_1(t), u_2(t), \\ldots, u_{M-1}(t)]^T$ be the vector of solutions at the interior points. The ODE system can be written in matrix form as:\n$$\n\\frac{d\\mathbf{u}}{dt} = \\frac{\\alpha}{(\\Delta x)^2} L_{1D} \\mathbf{u}\n$$\nwhere $L_{1D}$ is the $(M-1) \\times (M-1)$ tridiagonal matrix representing the discrete Laplacian with homogeneous Dirichlet boundary conditions:\n$$\nL_{1D} = \\begin{pmatrix}\n-2 & 1 & 0 & \\dots & 0 \\\\\n1 & -2 & 1 & \\dots & 0 \\\\\n0 & 1 & -2 & \\dots & 0 \\\\\n\\vdots & \\ddots & \\ddots & \\ddots & \\vdots \\\\\n0 & \\dots & 0 & 1 & -2\n\\end{pmatrix}\n$$\n\nNext, we discretize in time using the trapezoidal rule, also known as the Crank-Nicolson method. Given a time step $\\Delta t$, let $\\mathbf{u}^n$ denote the solution vector at time $t_n = n \\Delta t$. The scheme is:\n$$\n\\frac{\\mathbf{u}^{n+1} - \\mathbf{u}^n}{\\Delta t} = \\frac{1}{2} \\left( \\frac{\\alpha}{(\\Delta x)^2} L_{1D} \\mathbf{u}^{n+1} + \\frac{\\alpha}{(\\Delta x)^2} L_{1D} \\mathbf{u}^n \\right)\n$$\nIntroducing the diffusion number $r = \\frac{\\alpha \\Delta t}{(\\Delta x)^2}$, we can rearrange the equation to solve for $\\mathbf{u}^{n+1}$:\n$$\n\\left(I - \\frac{r}{2} L_{1D}\\right) \\mathbf{u}^{n+1} = \\left(I + \\frac{r}{2} L_{1D}\\right) \\mathbf{u}^n\n$$\nwhere $I$ is the $(M-1) \\times (M-1)$ identity matrix. At each time step, we must solve a linear system of the form $A \\mathbf{x} = \\mathbf{b}$, where:\n- The system matrix is $A_{CN} = I - \\frac{r}{2} L_{1D}$.\n- The unknown vector is $\\mathbf{x} = \\mathbf{u}^{n+1}$.\n- The right-hand side vector is $\\mathbf{b}_{CN} = (I + \\frac{r}{2} L_{1D}) \\mathbf{u}^n$.\n\nThe matrix $A_{CN}$ is tridiagonal with $(1+r)$ on the main diagonal and $-r/2$ on the sub- and super-diagonals. This system is non-singular and diagonally dominant for any $r > 0$, and thus can be solved efficiently using an algorithm for tridiagonal systems, such as the Thomas algorithm.\n\nThe simulation proceeds as follows:\n1.  For each test case, specified by $(M, r, T_{\\text{end}})$, we set $\\alpha=1$ and $w=0.1$.\n2.  The spatial step is $\\Delta x = 1/M$. The time step is determined by the diffusion number, $\\Delta t = r (\\Delta x)^2 / \\alpha$.\n3.  The initial solution vector $\\mathbf{u}^0$ is assembled by sampling the top-hat function at the interior grid points $x_i$ for $i=1, \\ldots, M-1$.\n4.  The matrices for the Crank-Nicolson step are constructed. The left-hand side matrix $A_{CN}$ is constant throughout the simulation.\n5.  A time-stepping loop evolves the solution from $t=0$ to $t=T_{\\text{end}}$. In each step:\n    a. The right-hand side vector $\\mathbf{b}_{CN}$ is computed by applying the operator $(I + \\frac{r}{2} L_{1D})$ to the current solution $\\mathbf{u}^n$.\n    b. The linear system $A_{CN} \\mathbf{u}^{n+1} = \\mathbf{b}_{CN}$ is solved for $\\mathbf{u}^{n+1}$.\n    c. The new solution vector $\\mathbf{u}^{n+1}$ is checked for oscillations. If any of its components are less than the tolerance $-10^{-10}$, a boolean flag `oscillation_detected` is set to `True`, and the simulation for this test case terminates.\n6.  If the time loop completes without the flag being set, its value remains `False`.\n\nThe Crank-Nicolson scheme is unconditionally stable in the $L_2$-norm sense for any $r > 0$. However, for non-smooth initial conditions, it may fail to preserve positivity and can introduce spurious oscillations unless the time step is sufficiently small. A Fourier stability analysis for non-negativity shows that oscillations are avoided if the amplification factor for all modes is non-negative. For the highest frequency mode, this leads to the condition $1 - 2r \\ge 0$, or $r \\le 0.5$. Therefore, we anticipate that oscillations will be detected for test cases with $r > 0.5$. Specifically, for Test C ($r=0.6$) and Test D ($r=5.0$), we expect to find negative values. For Test A ($r=0.1$) and Test B ($r=0.5$), we expect the solution to remain non-negative.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n\n    def run_simulation(M, r, T_end, alpha, w):\n        \"\"\"\n        Solves the 1D heat equation using the Crank-Nicolson method for one set of parameters.\n\n        Args:\n            M (int): Number of spatial subintervals.\n            r (float): Diffusion number.\n            T_end (float): End time for the simulation.\n            alpha (float): Thermal diffusivity.\n            w (float): Width of the initial top-hat profile.\n\n        Returns:\n            bool: True if oscillations are detected, False otherwise.\n        \"\"\"\n        # --- 1. Setup simulation parameters ---\n        dx = 1.0 / M\n        dt = r * dx**2 / alpha\n        num_steps = int(np.ceil(T_end / dt))\n        tol = -1.0e-10\n        \n        # --- 2. Create spatial grid and initial condition ---\n        # Grid consists of M-1 interior points.\n        x_interior = np.linspace(dx, 1.0 - dx, M - 1)\n        \n        u = np.zeros(M - 1)\n        left_bound = 0.5 - w / 2.0\n        right_bound = 0.5 + w / 2.0\n        \n        # Set initial condition u(x,0) based on the top-hat profile.\n        # N.B. Using a small epsilon for float comparison safety is good practice,\n        # but for M=100, the boundaries 0.45 and 0.55 are exact grid points.\n        u[(x_interior >= left_bound) & (x_interior <= right_bound)] = 1.0\n        \n        # --- 3. Construct matrices for the Crank-Nicolson scheme ---\n        # The scheme is (I - r/2 * L) u_next = (I + r/2 * L) u_current\n        # Let A = (I - r/2 * L) and B = (I + r/2 * L). We solve A * u_next = B * u_current.\n        \n        # A matrix in banded form for Scipy's solver.\n        # It has 1 lower, 1 upper diagonal. Shape (3, M-1).\n        # Row 0: super-diagonal, Row 1: main diagonal, Row 2: sub-diagonal.\n        A_banded = np.zeros((3, M - 1))\n        A_banded[0, 1:] = -r / 2.0\n        A_banded[1, :] = 1.0 + r\n        A_banded[2, :-1] = -r / 2.0\n        \n        # --- 4. Time-stepping loop ---\n        u_current = u\n        oscillation_detected = False\n        \n        for _ in range(num_steps):\n            # Calculate the right-hand side vector: rhs = B * u_current\n            # B is tridiagonal with (1-r) on the main diagonal and r/2 on off-diagonals.\n            # We compute the matrix-vector product efficiently without forming B.\n            rhs = np.zeros(M - 1)\n            \n            # For interior points of the u_current vector (indices 1 to M-3)\n            rhs[1:-1] = (r / 2.0) * u_current[:-2] + \\\n                        (1.0 - r) * u_current[1:-1] + \\\n                        (r / 2.0) * u_current[2:]\n            \n            # Handle endpoints with homogeneous Dirichlet BCs (u_0=0, u_M=0)\n            if M - 1 > 0: # Ensure u_current is not empty\n                rhs[0] = (1.0 - r) * u_current[0] + (r / 2.0) * u_current[1] if M - 1 > 1 else (1.0 - r) * u_current[0]\n            if M - 1 > 1:\n                rhs[-1] = (r / 2.0) * u_current[-2] + (1.0 - r) * u_current[-1]\n            \n            # Solve the tridiagonal system A * u_next = rhs\n            u_next = solve_banded((1, 1), A_banded, rhs)\n            \n            # Check for oscillations\n            if np.any(u_next < tol):\n                oscillation_detected = True\n                break\n            \n            u_current = u_next\n            \n        return oscillation_detected\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (100, 0.1, 0.05),  # Test A\n        (100, 0.5, 0.05),  # Test B\n        (100, 0.6, 0.05),  # Test C\n        (100, 5.0, 0.05),  # Test D\n    ]\n\n    # Fixed parameters\n    alpha = 1.0\n    w = 0.1\n    \n    results = []\n    for case in test_cases:\n        M, r, T_end = case\n        result = run_simulation(M, r, T_end, alpha, w)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Moving from purely diffusive systems, this practice explores the performance of the Crank-Nicolson scheme on a fundamentally different type of equation: the time-dependent Schrödinger equation, which governs quantum wave mechanics. For this problem, the scheme is unitary, meaning it perfectly preserves the total probability (the squared amplitude of the wavefunction), but this does not mean it is error-free. You will quantify the numerical *phase error* by comparing the propagation of a wave packet to its exact analytical counterpart . This exercise illuminates the concept of numerical dispersion and highlights that for wave phenomena, correctly capturing the phase is as critical as conserving the amplitude.",
            "id": "2383915",
            "problem": "Consider the free-particle time-dependent Schrödinger equation in one spatial dimension,\n$$\\mathrm{i}\\,\\frac{\\partial \\psi(x,t)}{\\partial t} \\;=\\; -\\,\\frac{\\partial^2 \\psi(x,t)}{\\partial x^2},$$\nposed on the periodic domain $x\\in[0,L]$, with nondimensional units such that $\\hbar=1$ and $m=\\tfrac{1}{2}$. The initial condition is a Gaussian wave packet with central wavenumber $k_0$, spatial center $x_0$, and width parameter $\\sigma$,\n$$\\psi(x,0) \\;=\\; \\exp\\!\\Big(-\\frac{(x-x_0)^2}{4\\sigma^2}\\Big)\\,\\exp\\!\\big(\\mathrm{i}\\,k_0\\,(x-x_0)\\big).$$\nLet the exact dispersion relation be $\\omega(k)=k^2$. Let $c_n(t)$ denote the complex Fourier coefficient of $\\psi(x,t)$ associated with the discrete wavenumber $k_n$ on a uniform grid of $N$ points over $[0,L]$ with periodic boundary conditions, where $k_n=\\tfrac{2\\pi}{L}n$ for integer $n$ in the discrete Fourier basis. Define $n_0$ as the unique integer index whose associated $k_{n_0}$ is closest to $k_0$.\n\nAdvance the solution from $t=0$ to $t=T$ using the Crank–Nicolson scheme in time with time step $\\Delta t$ on the periodic domain, and quantify the phase error of the dominant carrier mode by comparing the numerical phase change of the Fourier coefficient $c_{n_0}(t)$ to the exact phase change prescribed by $\\omega(k_{n_0})$ over the same time interval. Specifically, define the signed phase error $\\Delta\\theta$ (in radians) as the principal value in $(-\\pi,\\pi]$ of\n$$\\Delta\\theta \\;=\\; \\arg\\!\\Big(\\frac{c_{n_0}(T)}{c_{n_0}(0)}\\Big) \\;-\\; \\big(-\\,\\omega(k_{n_0})\\,T\\big).$$\nAll angles must be expressed in radians.\n\nYour program must compute $\\Delta\\theta$ for each of the following test cases, using the definitions above. In all cases, the spatial grid is uniform with $N$ points covering $[0,L]$, and the solution is advanced exactly to $t=T$ using the time step $\\Delta t$ (assume that $T/\\Delta t$ is an integer in each case). The required parameters for each test case are:\n- Case $1$: $L=2\\pi$, $N=1024$, $x_0=\\tfrac{L}{3}$, $\\sigma=0.4$, $k_0=4$, $T=0.5$, $\\Delta t=0.1$.\n- Case $2$: $L=2\\pi$, $N=1024$, $x_0=\\tfrac{L}{3}$, $\\sigma=0.4$, $k_0=4$, $T=0.5$, $\\Delta t=0.05$.\n- Case $3$: $L=2\\pi$, $N=1024$, $x_0=\\tfrac{L}{3}$, $\\sigma=0.4$, $k_0=4$, $T=0.5$, $\\Delta t=0.025$.\n- Case $4$: $L=2\\pi$, $N=1024$, $x_0=\\tfrac{L}{3}$, $\\sigma=0.4$, $k_0=16$, $T=0.5$, $\\Delta t=0.05$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the same order as the cases above. Each entry must be a floating-point number giving $\\Delta\\theta$ in radians. For example, the output format must be exactly like\n\"[r1,r2,r3,r4]\"\nwith $r1$, $r2$, $r3$, and $r4$ replaced by the computed floating-point values in radians (no units symbol, no additional text). Angles must be in radians and should be reported as the principal values in $(-\\pi,\\pi]$.",
            "solution": "The problem presented is a standard exercise in the analysis of numerical methods for partial differential equations, specifically for the time-dependent Schrödinger equation. It is well-posed, scientifically sound, and contains all necessary information for a unique solution. My task is to validate its premises and, if valid, to furnish a rigorous solution. The problem is indeed valid.\n\nWe begin with the one-dimensional free-particle Schrödinger equation in nondimensional units, as given:\n$$ \\mathrm{i}\\,\\frac{\\partial \\psi(x,t)}{\\partial t} \\;=\\; -\\,\\frac{\\partial^2 \\psi(x,t)}{\\partial x^2} $$\nThis equation is posed on a periodic domain $x \\in [0, L]$. We will analyze the equation in Fourier space, which is the natural basis for a periodic domain and for analyzing the action of the constant-coefficient differential operator $\\frac{\\partial^2}{\\partial x^2}$.\n\nA function $\\psi(x,t)$ on this domain can be expanded in a Fourier series:\n$$ \\psi(x,t) = \\sum_n c_n(t) \\exp(\\mathrm{i}k_n x) $$\nwhere $c_n(t)$ are the time-dependent Fourier coefficients and $k_n = \\frac{2\\pi n}{L}$ are the discrete wavenumbers for integer $n$. Substituting this expansion into the Schrödinger equation, the spatial derivative $\\frac{\\partial^2}{\\partial x^2}$ acts on each basis function $\\exp(\\mathrm{i}k_n x)$ as multiplication by $(\\mathrm{i}k_n)^2 = -k_n^2$. The partial differential equation is thus transformed into a set of independent ordinary differential equations for each Fourier coefficient $c_n(t)$:\n$$ \\mathrm{i}\\,\\frac{d c_n(t)}{dt} = -(-k_n^2) c_n(t) $$\n$$ \\frac{d c_n(t)}{dt} = -\\mathrm{i}k_n^2 c_n(t) $$\nThe operator $\\hat{H}$ in the abstract form $\\frac{\\partial\\psi}{\\partial t} = \\hat{H}\\psi$ is therefore represented in the Fourier basis by multiplication by the scalar $-\\mathrm{i}k_n^2$ for each mode $n$.\n\nThe exact solution to this ODE is found by direct integration:\n$$ c_n(t) = c_n(0) \\exp(-\\mathrm{i}k_n^2 t) $$\nThe term $\\exp(-\\mathrm{i}k_n^2 t)$ represents the time evolution operator for the mode $c_n$. The phase of this coefficient changes by $-\\omega(k_n)t = -k_n^2 t$ over a time interval $t$.\n\nNow, we apply the Crank-Nicolson scheme for time evolution with a time step $\\Delta t$. For an equation of the form $\\frac{dy}{dt} = \\Lambda y$, where $\\Lambda$ is a constant (here, $\\Lambda_n = -\\mathrm{i}k_n^2$), the scheme is:\n$$ \\frac{c_n(t+\\Delta t) - c_n(t)}{\\Delta t} = \\frac{1}{2} \\left( \\Lambda_n c_n(t+\\Delta t) + \\Lambda_n c_n(t) \\right) $$\nRearranging to solve for $c_n(t+\\Delta t)$:\n$$ \\left(1 - \\frac{\\Delta t}{2}\\Lambda_n\\right) c_n(t+\\Delta t) = \\left(1 + \\frac{\\Delta t}{2}\\Lambda_n\\right) c_n(t) $$\n$$ c_n(t+\\Delta t) = \\frac{1 + \\frac{\\Delta t}{2}\\Lambda_n}{1 - \\frac{\\Delta t}{2}\\Lambda_n} c_n(t) $$\nSubstituting $\\Lambda_n = -\\mathrm{i}k_n^2$:\n$$ c_n(t+\\Delta t) = \\frac{1 - \\mathrm{i}\\frac{\\Delta t}{2}k_n^2}{1 + \\mathrm{i}\\frac{\\Delta t}{2}k_n^2} c_n(t) $$\nThis equation gives the numerical amplification factor for a single time step. Note that the a priori information about the initial wave packet shape, its center $x_0$, and its width $\\sigma$, is irrelevant for this analysis, as we are concerned only with the evolution of a single Fourier mode, $c_{n_0}(t)$, whose dynamics are decoupled from all other modes in this linear problem.\n\nAfter $M$ time steps, such that $T=M\\Delta t$, the coefficient $c_{n_0}(T)$ is related to its initial value $c_{n_0}(0)$ by:\n$$ \\frac{c_{n_0}(T)}{c_{n_0}(0)} = \\left( \\frac{1 - \\mathrm{i}\\frac{\\Delta t}{2}k_{n_0}^2}{1 + \\mathrm{i}\\frac{\\Delta t}{2}k_{n_0}^2} \\right)^M $$\nwhere $k_{n_0}$ is the discrete wavenumber closest to the specified carrier wavenumber $k_0$.\n\nThe problem requires the calculation of the signed phase error $\\Delta\\theta$, defined as the principal value in $(-\\pi, \\pi]$ of:\n$$ \\Delta\\theta = \\arg\\!\\Big(\\frac{c_{n_0}(T)}{c_{n_0}(0)}\\Big) - \\big(-\\omega(k_{n_0})T\\big) $$\nThe calculation proceeds as follows:\n1. For each test case, identify the parameters $L$, $N$, $k_0$, $T$, and $\\Delta t$.\n2. Construct the set of discrete wavenumbers $\\{k_n\\}$ corresponding to the spatial grid using the standard convention for the Discrete Fourier Transform, which is implemented in `numpy.fft.fftfreq`.\n3. Find the index $n_0$ such that $|k_{n_0} - k_0|$ is minimized, and identify the corresponding wavenumber $k_{n_0}$.\n4. Calculate the number of time steps, $M = T/\\Delta t$.\n5. Compute the complex ratio $R = \\frac{c_{n_0}(T)}{c_{n_0}(0)}$ using the formula derived above.\n6. Determine the numerical phase change, $\\phi_{num} = \\arg(R)$, which is the principal argument of the complex number $R$.\n7. Calculate the exact phase change, $\\phi_{exact} = -\\omega(k_{n_0})T = -k_{n_0}^2 T$.\n8. Compute the raw phase error, $D = \\phi_{num} - \\phi_{exact}$.\n9. Finally, find the principal value of $D$ in the interval $(-\\pi, \\pi]$ to obtain $\\Delta\\theta$.\n\nThis procedure is deterministic and will be implemented directly.\nThe Crank-Nicolson method is second-order accurate in time, meaning the local truncation error is $O((\\Delta t)^3)$ and the global error is $O((\\Delta t)^2)$. We should expect the phase error $\\Delta\\theta$ to scale with $(\\Delta t)^2$, which can be verified by comparing the results from cases $1$, $2$, and $3$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the phase error of the Crank-Nicolson scheme for the 1D free-particle\n    Schrödinger equation for several test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: L=2pi, N=1024, x0=L/3, sigma=0.4, k0=4, T=0.5, dt=0.1\n        (2 * np.pi, 1024, 4.0, 0.5, 0.1),\n        # Case 2: L=2pi, N=1024, x0=L/3, sigma=0.4, k0=4, T=0.5, dt=0.05\n        (2 * np.pi, 1024, 4.0, 0.5, 0.05),\n        # Case 3: L=2pi, N=1024, x0=L/3, sigma=0.4, k0=4, T=0.5, dt=0.025\n        (2 * np.pi, 1024, 4.0, 0.5, 0.025),\n        # Case 4: L=2pi, N=1024, x0=L/3, sigma=0.4, k0=16, T=0.5, dt=0.05\n        (2 * np.pi, 1024, 16.0, 0.5, 0.05),\n    ]\n\n    results = []\n    for case in test_cases:\n        L, N, k0, T, dt = case\n\n        # The problem statement guarantees T/dt is an integer.\n        # Use round() to handle potential floating point inaccuracies.\n        num_steps = int(round(T / dt))\n\n        # 1. Construct the discrete wavenumbers for the grid.\n        # The grid spacing is dx = L / N.\n        # The wavenumbers for numpy's DFT are given by fftfreq.\n        k = 2 * np.pi * np.fft.fftfreq(N, d=L / N)\n\n        # 2. Find the wavenumber k_n0 closest to the carrier wavenumber k0.\n        n0_idx = np.argmin(np.abs(k - k0))\n        kn0 = k[n0_idx]\n\n        # 3. Define the exact dispersion relation omega(k) = k^2.\n        omega_kn0 = kn0**2\n\n        # 4. Calculate the numerical amplification factor for a single step.\n        # A_num = (1 - i*dt/2 * kn0^2) / (1 + i*dt/2 * kn0^2)\n        numerator = 1 - 1j * (dt / 2) * omega_kn0\n        denominator = 1 + 1j * (dt / 2) * omega_kn0\n        A_num = numerator / denominator\n\n        # 5. Compute the total numerical amplification factor after M steps.\n        # This is the ratio c_n0(T) / c_n0(0).\n        total_A_num = A_num**num_steps\n\n        # 6. Calculate the numerical phase change (principal value).\n        # This is arg(c_n0(T) / c_n0(0)).\n        phi_num = np.angle(total_A_num)\n\n        # 7. Calculate the exact phase change.\n        # This is -omega(k_n0) * T.\n        phi_exact = -omega_kn0 * T\n\n        # 8. Compute the signed phase error as defined in the problem.\n        # delta_theta = PrincipalValue[ phi_num - phi_exact ]\n        delta_theta_raw = phi_num - phi_exact\n        \n        # Bring the raw difference into the interval (-pi, pi].\n        # (x + pi) % (2*pi) - pi maps x to [-pi, pi), we need (-pi, pi]\n        # This is a standard way to compute the principal value of an angle.\n        delta_theta = (delta_theta_raw + np.pi) % (2 * np.pi) - np.pi\n\n        results.append(delta_theta)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Many physical systems involve the interplay of multiple processes, such as the simultaneous transport (advection) and spreading (diffusion) of a substance. This exercise introduces operator splitting, a powerful and widely used strategy for constructing solvers for such multi-physics problems. You will implement a scheme that \"splits\" the advection-diffusion equation into two subproblems, handling the stiff diffusion part with the implicit Crank-Nicolson method and the non-stiff advection part with a simple explicit upwind method . This hands-on practice demonstrates a modular approach to algorithm design, where different numerical methods are chosen to best suit the mathematical character of each underlying physical process.",
            "id": "2383981",
            "problem": "You are to implement an operator-splitting time integrator for the one-dimensional, linear advection–diffusion equation\n$$\nu_t + v\\,u_x = D\\,u_{xx},\n$$\non a periodic domain with uniform grid. The splitting will separate the advection and diffusion operators and advance each subproblem with a method appropriate to its character: the advection subproblem with an explicit first-order upwind method, and the diffusion subproblem with the Crank–Nicolson (CN) method. Treat all quantities as dimensionless. Your implementation must be a complete, runnable program that produces a single line of output as specified below.\n\nStart from the following fundamental bases:\n- The conservation form of transport for a scalar field $u(x,t)$, the definition of spatial derivatives $u_x$ and $u_{xx}$, and the initial value problem formulation $u(x,0)$.\n- The method-of-lines for semi-discretization and the principle of local flux balance on a uniform grid.\n- The superposition principle for linear constant-coefficient partial differential equations.\n- The Lie product formula for operator splitting of exponentials of linear operators.\n\nRequirements for modeling assumptions and numerical design:\n- Use a spatially uniform grid with $N$ points on the periodic interval $[0,2\\pi)$ with grid spacing $\\Delta x = 2\\pi/N$ and grid nodes $x_j = j\\,\\Delta x$ for $j=0,1,\\dots,N-1$.\n- Use first-order Lie splitting in time with a uniform time step $\\Delta t$, applying one full advection substep followed by one full diffusion substep at each time step.\n- For the advection substep of $u_t + v\\,u_x = 0$, use an explicit first-order upwind finite difference that is consistent with the sign of the constant velocity $v$. Ensure the Courant–Friedrichs–Lewy (CFL) condition $|v|\\,\\Delta t/\\Delta x \\le 1$ holds in all tests.\n- For the diffusion substep of $u_t = D\\,u_{xx}$, use the Crank–Nicolson method with the standard centered second difference for $u_{xx}$. Enforce periodic boundary conditions by using a circulant (wrap-around) stencil.\n- Use the initial condition $u(x,0) = \\sin(k x)$ where $k$ is an integer wavenumber. This choice ensures periodicity on $[0,2\\pi)$.\n- For verification, use the analytical solution of the combined advection–diffusion dynamics for a single Fourier mode: \n$$\nu_{\\text{exact}}(x,t) = e^{-D k^2 t}\\,\\sin\\!\\big(k(x - v t)\\big).\n$$\n- Evolve the numerical solution to time $T$ with $T/\\Delta t$ an integer in all tests.\n\nOutput quantity and units:\n- Compute the discrete root-mean-square (RMS) error between the numerical solution $u_j^N$ at final time $T$ and the analytical solution sampled on the same grid $u_{\\text{exact}}(x_j,T)$:\n$$\n\\varepsilon = \\sqrt{\\frac{1}{N}\\sum_{j=0}^{N-1} \\left(u_j^N - u_{\\text{exact}}(x_j,T)\\right)^2}.\n$$\n- Report this RMS error as a dimensionless floating-point number rounded to six decimal places.\n\nTest suite:\nImplement your program to run the following four independent test cases and output their RMS errors in the order listed. For each case, use the specified parameters $(v,D,k,N,\\Delta t,T)$:\n- Case A (advection–diffusion, positive velocity): $(v,D,k,N,\\Delta t,T) = (1.0,\\,0.05,\\,3,\\,128,\\,0.002,\\,0.5)$.\n- Case B (advection–diffusion, negative velocity): $(v,D,k,N,\\Delta t,T) = (-0.8,\\,0.02,\\,5,\\,256,\\,0.0015,\\,0.3)$.\n- Case C (pure diffusion): $(v,D,k,N,\\Delta t,T) = (0.0,\\,0.1,\\,2,\\,128,\\,0.0025,\\,0.4)$.\n- Case D (pure advection): $(v,D,k,N,\\Delta t,T) = (1.0,\\,0.0,\\,4,\\,256,\\,0.001,\\,0.6)$.\n\nFinal output format specification:\n- Your program should produce a single line of output containing the four RMS errors for Cases A–D, rounded to six decimal places, as a comma-separated list enclosed in square brackets. For example, the output must look like \n$$\n[\\varepsilon_A,\\varepsilon_B,\\varepsilon_C,\\varepsilon_D],\n$$\nwith each $\\varepsilon$ printed with exactly six digits after the decimal point and no additional text.",
            "solution": "The problem presented is a standard, well-posed exercise in computational physics. It is scientifically grounded, internally consistent, and contains all necessary information for its resolution. We will therefore proceed with a complete solution.\n\nThe task is to numerically solve the one-dimensional linear advection–diffusion equation for a scalar field $u(x,t)$:\n$$\n\\frac{\\partial u}{\\partial t} + v \\frac{\\partial u}{\\partial x} = D \\frac{\\partial^2 u}{\\partial x^2}\n$$\nHere, $v$ is the constant advection velocity and $D$ is the constant diffusion coefficient. The problem is posed on a periodic domain $x \\in [0, 2\\pi)$ with the initial condition $u(x,0) = \\sin(k x)$.\n\nThe fundamental approach for solving this partial differential equation (PDE) is operator splitting. The time evolution of the solution can be formally written as $u(t) = e^{t\\mathcal{L}}u(0)$, where $\\mathcal{L}$ is the spatial differential operator. Our governing equation is linear with constant coefficients, and its operator $\\mathcal{L}$ can be additively decomposed into an advection operator $\\mathcal{L}_A = -v \\frac{\\partial}{\\partial x}$ and a diffusion operator $\\mathcal{L}_D = D \\frac{\\partial^2}{\\partial x^2}$, such that $\\mathcal{L} = \\mathcal{L}_A + \\mathcal{L}_D$.\n\nThe Lie product formula provides a basis for approximating the exponential of a sum of operators. For a single time step $\\Delta t$, the first-order Lie splitting approximates the full evolution operator as:\n$$\ne^{\\Delta t (\\mathcal{L}_A + \\mathcal{L}_D)} \\approx e^{\\Delta t \\mathcal{L}_D} e^{\\Delta t \\mathcal{L}_A}\n$$\nThis means we can advance the solution from time $t_n$ to $t_{n+1} = t_n + \\Delta t$ by solving two simpler subproblems in sequence:\n$1$. First, solve the pure advection problem $u_t = \\mathcal{L}_A u$ over $\\Delta t$, starting from $u^n(x)$, to obtain an intermediate solution $u^*(x)$.\n$2$. Second, solve the pure diffusion problem $u_t = \\mathcal{L}_D u$ over the same $\\Delta t$, using $u^*(x)$ as the initial condition, to find the final solution $u^{n+1}(x)$.\n\nWe employ the method of lines, which involves first discretizing the spatial domain and then integrating the resulting system of ordinary differential equations (ODEs) in time. The spatial domain $[0, 2\\pi)$ is discretized into a uniform grid of $N$ points $x_j = j \\Delta x$ for $j = 0, 1, \\dots, N-1$, where the grid spacing is $\\Delta x = 2\\pi / N$. The solution at each grid point is denoted $u_j(t) \\approx u(x_j, t)$.\n\n**Substep 1: Advection**\n\nThe first subproblem is the pure advection equation:\n$$\n\\frac{\\partial u}{\\partial t} + v \\frac{\\partial u}{\\partial x} = 0\n$$\nWe discretize this using an explicit first-order upwind scheme. This scheme respects the direction of information flow dictated by the sign of the velocity $v$, which is a direct consequence of the principle of local flux balance. The spatial derivative $u_x$ is approximated by a one-sided finite difference.\n\nIf $v > 0$, information propagates in the positive $x$ direction. We use a backward difference: $\\frac{\\partial u}{\\partial x} \\approx \\frac{u_j - u_{j-1}}{\\Delta x}$. Discretizing in time with forward Euler, we get:\n$$\n\\frac{u_j^* - u_j^n}{\\Delta t} + v \\frac{u_j^n - u_{j-1}^n}{\\Delta x} = 0\n$$\nwhere $u_j^n$ is the solution at time step $n$ and $u_j^*$ is the intermediate solution. Rearranging for $u_j^*$:\n$$\nu_j^* = u_j^n - C (u_j^n - u_{j-1}^n)\n$$\nwhere $C = v \\Delta t / \\Delta x$ is the Courant number.\n\nIf $v < 0$, information propagates in the negative $x$ direction. We use a forward difference: $\\frac{\\partial u}{\\partial x} \\approx \\frac{u_{j+1} - u_j}{\\Delta x}$. The scheme becomes:\n$$\n\\frac{u_j^* - u_j^n}{\\Delta t} + v \\frac{u_{j+1}^n - u_j^n}{\\Delta x} = 0\n$$\nleading to the update rule:\n$$\nu_j^* = u_j^n - C (u_{j+1}^n - u_j^n)\n$$\nIf $v=0$, the advection step is trivial: $u_j^* = u_j^n$. The scheme is stable provided the CFL condition $|C| = |v| \\Delta t / \\Delta x \\le 1$ is met, which is satisfied by all test cases. Periodicity is enforced by treating indices modulo $N$, i.e., $u_{-1} \\equiv u_{N-1}$ and $u_N \\equiv u_0$.\n\n**Substep 2: Diffusion**\n\nThe second subproblem is the pure diffusion (heat) equation:\n$$\n\\frac{\\partial u}{\\partial t} = D \\frac{\\partial^2 u}{\\partial x^2}\n$$\nWe solve this using the Crank–Nicolson (CN) method, which is second-order accurate in time and unconditionally stable. The method averages the spatial derivative at the current time level (using $u^*$) and the next time level (using $u^{n+1}$). The time derivative is approximated by a central difference, and the spatial second derivative $u_{xx}$ by the standard three-point central difference stencil:\n$$\n\\frac{u_j^{n+1} - u_j^*}{\\Delta t} = \\frac{D}{2} \\left( \\left[\\frac{u_{j+1}^* - 2u_j^* + u_{j-1}^*}{\\Delta x^2}\\right] + \\left[\\frac{u_{j+1}^{n+1} - 2u_j^{n+1} + u_{j-1}^{n+1}}{\\Delta x^2}\\right] \\right)\n$$\nLetting $\\alpha = \\frac{D \\Delta t}{2 \\Delta x^2}$, and rearranging the equation to separate terms at level $n+1$ (unknown) from terms at the intermediate level (known):\n$$\n-\\alpha u_{j-1}^{n+1} + (1+2\\alpha) u_j^{n+1} - \\alpha u_{j+1}^{n+1} = \\alpha u_{j-1}^* + (1-2\\alpha) u_j^* + \\alpha u_{j+1}^*\n$$\nThis represents a system of $N$ linear equations for the unknown vector $\\mathbf{u}^{n+1} = [u_0^{n+1}, \\dots, u_{N-1}^{n+1}]^T$. The system has the form $A \\mathbf{u}^{n+1} = \\mathbf{b}$, where the right-hand side is $\\mathbf{b} = B \\mathbf{u}^*$. Due to the periodic boundary conditions, the matrices $A$ and $B$ are circulant:\n- $A$ is defined by its first row $[1+2\\alpha, -\\alpha, 0, \\dots, 0, -\\alpha]$.\n- $B$ is defined by its first row $[1-2\\alpha, \\alpha, 0, \\dots, 0, \\alpha]$.\n\nA linear system with a circulant matrix can be solved efficiently. Instead of general-purpose methods like LU decomposition, which would be $\\mathcal{O}(N^3)$, or a tridiagonal solver, which is not directly applicable due to the corner elements, we can use a specialized algorithm. The required `scipy.linalg.solve_circulant` function leverages the property that circulant matrices are diagonalized by the Discrete Fourier Transform, reducing the computational complexity to $\\mathcal{O}(N \\log N)$.\n\nIf $D=0$, then $\\alpha=0$, $A$ becomes the identity matrix, $B$ also becomes the identity matrix, and the diffusion step correctly reduces to $u_j^{n+1} = u_j^*$.\n\n**Verification**\n\nThe implementation integrates the solution from $t=0$ to a final time $T$. The accuracy is then evaluated by computing the discrete root-mean-square (RMS) error $\\varepsilon$ between the final numerical solution $u_j^{N_{steps}}$ and the provided analytical solution $u_{\\text{exact}}(x_j, T)$ sampled at the grid points:\n$$\n\\varepsilon = \\sqrt{\\frac{1}{N}\\sum_{j=0}^{N-1} \\left(u_j^{N_{steps}} - u_{\\text{exact}}(x_j,T)\\right)^2}\n$$\nwhere $u_{\\text{exact}}(x,t) = e^{-D k^2 t}\\,\\sin(k(x - v t))$. This procedure is repeated for all specified test cases to produce the final output.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_circulant\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final output.\n    \"\"\"\n\n    def solve_case(v, D, k, N, dt, T):\n        \"\"\"\n        Solves the 1D advection-diffusion equation for a single test case.\n\n        Args:\n            v (float): Advection velocity.\n            D (float): Diffusion coefficient.\n            k (int): Wavenumber of initial condition.\n            N (int): Number of grid points.\n            dt (float): Time step size.\n            T (float): Final time.\n\n        Returns:\n            float: The RMS error between the numerical and analytical solutions.\n        \"\"\"\n        # 1. Setup Grid and Initial Condition\n        dx = 2.0 * np.pi / N\n        x = np.arange(N) * dx\n        u = np.sin(k * x)\n\n        # 2. Determine number of time steps\n        # Use round to handle potential floating-point inaccuracies\n        num_steps = round(T / dt)\n\n        # 3. Pre-calculate constants for efficiency in the time loop\n        \n        # Advection substep constant\n        courant = v * dt / dx\n        \n        # Diffusion substep constants\n        circ_A_col = None\n        alpha = 0.0\n        if D > 0:\n            alpha = D * dt / (2.0 * dx**2)\n            # First column of the circulant matrix A for the solver\n            circ_A_col = np.zeros(N)\n            circ_A_col[0] = 1.0 + 2.0 * alpha\n            circ_A_col[1] = -alpha\n            circ_A_col[-1] = -alpha # Corresponds to the (0, N-1) element\n\n        # 4. Time Integration Loop\n        for _ in range(num_steps):\n            # --- Substep 1: Advection (Explicit First-Order Upwind) ---\n            if v > 0:\n                # Flow to the right, use backward difference in space\n                u_star = u - courant * (u - np.roll(u, 1))\n            elif v < 0:\n                # Flow to the left, use forward difference in space\n                u_star = u - courant * (np.roll(u, -1) - u)\n            else:  # v == 0, no advection\n                u_star = u\n\n            # --- Substep 2: Diffusion (Crank-Nicolson) ---\n            if D > 0:\n                # Construct the right-hand side vector b = B @ u_star\n                rhs_b = (\n                    alpha * np.roll(u_star, 1) +\n                    (1.0 - 2.0 * alpha) * u_star +\n                    alpha * np.roll(u_star, -1)\n                )\n                # Solve the circulant system A @ u_next = b for u_next\n                u_next = solve_circulant(circ_A_col, rhs_b)\n            else:  # D == 0, no diffusion\n                u_next = u_star\n            \n            u = u_next\n\n        # 5. Verification\n        # Calculate the analytical solution at the final time T\n        u_exact = np.exp(-D * k**2 * T) * np.sin(k * (x - v * T))\n        \n        # Calculate the discrete Root-Mean-Square (RMS) error\n        rms_error = np.sqrt(np.mean((u - u_exact)**2))\n        \n        return rms_error\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: (v, D, k, N, dt, T)\n        (1.0, 0.05, 3, 128, 0.002, 0.5),\n        # Case B: (v, D, k, N, dt, T)\n        (-0.8, 0.02, 5, 256, 0.0015, 0.3),\n        # Case C: (v, D, k, N, dt, T)\n        (0.0, 0.1, 2, 128, 0.0025, 0.4),\n        # Case D: (v, D, k, N, dt, T)\n        (1.0, 0.0, 4, 256, 0.001, 0.6),\n    ]\n\n    results = []\n    for case in test_cases:\n        error = solve_case(*case)\n        # Format the result to six decimal places\n        results.append(f\"{error:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}