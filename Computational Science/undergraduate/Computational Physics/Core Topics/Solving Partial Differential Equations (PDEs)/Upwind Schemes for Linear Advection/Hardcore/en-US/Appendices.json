{
    "hands_on_practices": [
        {
            "introduction": "This first practice is a fundamental starting point for any student of computational fluid dynamics. You will implement the 1D first-order upwind scheme to simulate the movement of a step function, which represents a sharp shock or front. This exercise is a classic \"acid test\" for advection schemes, as it vividly reveals the impact of numerical diffusion, a primary source of error in first-order methods that causes sharp features to smear out over time .",
            "id": "2448567",
            "problem": "Consider the one-dimensional linear advection equation for a scalar field $u(x,t)$ with constant advection speed $a$,\n$$\n\\partial_t u(x,t) + a\\,\\partial_x u(x,t) = 0,\\quad x \\in [x_{\\min},x_{\\max}],\\ t \\ge 0,\n$$\nwith the initial condition given by the Heaviside step function\n$$\nu(x,0) = H(x - x_0),\\quad H(\\xi) = \\begin{cases}\n1, \\xi \\ge 0,\\\\\n0, \\xi  0.\n\\end{cases}\n$$\nImpose inflow boundary conditions consistent with the far-field states of the initial data: if $a  0$, enforce $u(x_{\\min},t)=0$ for all $t \\ge 0$; if $a  0$, enforce $u(x_{\\max},t)=1$ for all $t \\ge 0$. All quantities are dimensionless.\n\nAdvance the solution in time on a uniform spatial grid of $N$ points in $[x_{\\min},x_{\\max}]$ up to a final time $T$, with a time step $\\Delta t$ chosen to satisfy a specified Courant–Friedrichs–Lewy (CFL) number $C$, where\n$$\nC = \\frac{|a|\\,\\Delta t}{\\Delta x},\\quad \\Delta x = \\frac{x_{\\max} - x_{\\min}}{N-1}.\n$$\nUse a first-order upwind discretization consistent with the sign of $a$. For each test case below, compute the discrete $\\ell^1$ error at time $T$ defined by\n$$\nE_1 = \\sum_{i=0}^{N-1} \\left| u_i^{\\text{num}}(T) - u^{\\text{exact}}(x_i,T) \\right|\\,\\Delta x,\n$$\nwhere $x_i$ are the grid points, $u_i^{\\text{num}}(T)$ is the numerical solution at time $T$, and the analytical solution is the translated step\n$$\nu^{\\text{exact}}(x,T) = H\\!\\left( x - (x_0 + a\\,T) \\right),\n$$\nwhich is valid for the times and parameters given below because the advected discontinuity remains strictly inside the interval $[x_{\\min},x_{\\max}]$ and does not interact with the boundaries.\n\nTest Suite (each test case is a tuple $(a,x_{\\min},x_{\\max},x_0,N,T,C)$):\n- Test $1$: $(1.0,\\,0.0,\\,1.0,\\,0.25,\\,401,\\,0.2,\\,0.5)$.\n- Test $2$: $(-0.7,\\,0.0,\\,1.0,\\,0.8,\\,401,\\,0.15,\\,0.8)$.\n- Test $3$: $(1.0,\\,0.0,\\,1.0,\\,0.3,\\,201,\\,0.3,\\,1.0)$.\n\nYour program must compute $E_1$ for each test in the order listed and produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each number rounded to six decimal places (for example, $[0.123456,0.000000,1.234568]$).",
            "solution": "The problem is valid as it is scientifically grounded, well-posed, and objective. It presents a standard task in computational physics: solving the linear advection equation using a first-order upwind scheme and evaluating the numerical error. All parameters and conditions are clearly defined.\n\nThe governing equation is the one-dimensional linear advection equation for a scalar field $u(x,t)$ with a constant advection speed $a$:\n$$\n\\partial_t u(x,t) + a\\,\\partial_x u(x,t) = 0\n$$\nTo solve this equation numerically, we discretize the spatio-temporal domain. The spatial domain $[x_{\\min}, x_{\\max}]$ is divided into a uniform grid of $N$ points, $x_i = x_{\\min} + i\\Delta x$ for $i=0, 1, \\dots, N-1$, where the grid spacing is $\\Delta x = (x_{\\max} - x_{\\min}) / (N-1)$. Time is advanced in discrete steps, and we denote the numerical approximation of $u(x_i, t^n)$ as $u_i^n$.\n\nThe time derivative $\\partial_t u$ is approximated using a first-order forward difference (Forward Euler method):\n$$\n\\partial_t u(x_i, t^n) \\approx \\frac{u_i^{n+1} - u_i^n}{\\Delta t}\n$$\nThe first-order upwind scheme approximates the spatial derivative $\\partial_x u$ using a one-sided finite difference. The choice of the one-sided stencil depends on the direction of information propagation, which is given by the sign of the advection speed $a$. This ensures that the numerical method draws information from the \"upwind\" direction, a crucial property for the stability of hyperbolic solvers.\n\nCase 1: $a  0$\nInformation propagates from left to right (in the positive $x$ direction). The spatial derivative at $x_i$ is approximated using a backward difference, which involves the point upwind, $x_{i-1}$:\n$$\n\\partial_x u(x_i, t^n) \\approx \\frac{u_i^n - u_{i-1}^n}{\\Delta x}\n$$\nSubstituting these discrete approximations into the partial differential equation yields the update rule:\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} + a \\frac{u_i^n - u_{i-1}^n}{\\Delta x} = 0\n$$\nSolving for the solution at the next time step, $u_i^{n+1}$:\n$$\nu_i^{n+1} = u_i^n - \\frac{a \\Delta t}{\\Delta x} (u_i^n - u_{i-1}^n) = u_i^n - C (u_i^n - u_{i-1}^n)\n$$\nwhere $C = \\frac{a \\Delta t}{\\Delta x}$ is the Courant–Friedrichs–Lewy (CFL) number, as $a0$. This scheme is applied for $i=1, \\dots, N-1$.\n\nCase 2: $a  0$\nInformation propagates from right to left (in the negative $x$ direction). The spatial derivative is approximated using a forward difference, involving the upwind point $x_{i+1}$:\n$$\n\\partial_x u(x_i, t^n) \\approx \\frac{u_{i+1}^n - u_i^n}{\\Delta x}\n$$\nThe corresponding update rule is:\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} + a \\frac{u_{i+1}^n - u_i^n}{\\Delta x} = 0\n$$\nSolving for $u_i^{n+1}$:\n$$\nu_i^{n+1} = u_i^n - \\frac{a \\Delta t}{\\Delta x} (u_{i+1}^n - u_i^n) = u_i^n + C (u_{i+1}^n - u_i^n)\n$$\nHere, the CFL number is defined as $C = \\frac{|a| \\Delta t}{\\Delta x} = \\frac{-a \\Delta t}{\\Delta x}$, which means $\\frac{a \\Delta t}{\\Delta x} = -C$. This scheme is applied for $i=0, \\dots, N-2$.\n\nThe stability of this explicit time-stepping scheme is guaranteed if the CFL condition, $C \\le 1$, is met. All test cases provided satisfy this condition.\n\nThe simulation proceeds as follows:\n1.  **Initialization**: For each test case $(a, x_{\\min}, x_{\\max}, x_0, N, T, C)$, the grid spacing $\\Delta x$ and nominal time step $\\Delta t = C \\Delta x / |a|$ are calculated. The solution array $u$ is initialized with the Heaviside function $u(x,0) = H(x - x_0)$.\n2.  **Time Evolution**: A loop advances the solution from $t=0$ to $T$. To ensure the final time $T$ is reached precisely, the time step for each iteration is calculated as $\\Delta t_{\\text{curr}} = \\min(\\Delta t, T - t)$. This handles cases where $T$ is not an integer multiple of $\\Delta t$.\n3.  **Update Step**: Inside the loop, a copy of the solution $u^n$ is made. The new solution $u^{n+1}$ is computed for all interior points using the appropriate upwind formula, with the update coefficient scaled by $\\Delta t_{\\text{curr}}$.\n4.  **Boundary Conditions**: After computing the interior-point updates, the inflow boundary condition is enforced. If $a  0$, the value at the left boundary is set: $u_0^{n+1} = 0$. If $a  0$, the value at the right boundary is set: $u_{N-1}^{n+1} = 1$. The outflow boundary requires no special treatment as it is handled by the one-sided nature of the upwind stencil.\n5.  **Error Calculation**: Once the simulation reaches $t=T$, the final numerical solution $u_i^{\\text{num}}(T)$ is obtained. The analytical solution $u^{\\text{exact}}(x_i,T) = H(x_i - (x_0 + aT))$ is computed on the same grid. The discrete $\\ell^1$ error is then calculated using the formula:\n    $$\n    E_1 = \\sum_{i=0}^{N-1} \\left| u_i^{\\text{num}}(T) - u^{\\text{exact}}(x_i,T) \\right|\\,\\Delta x\n    $$\nFor the test case where $C=1.0$, the scheme (for $a0$) simplifies to $u_i^{n+1} = u_{i-1}^n$. This corresponds to an exact shift of the discrete data by one grid cell per time step. Since the total time $T$ is chosen such that the total advection distance $aT$ is an integer multiple of $\\Delta x$, the numerical solution on the grid is identical to the exact solution, resulting in zero error. For $C  1$, the scheme introduces numerical diffusion, which smears the sharp step and produces a non-zero error.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D linear advection equation for multiple test cases\n    using a first-order upwind scheme and computes the l1 error.\n    \"\"\"\n    test_cases = [\n        # (a, x_min, x_max, x_0, N, T, C)\n        (1.0, 0.0, 1.0, 0.25, 401, 0.2, 0.5),\n        (-0.7, 0.0, 1.0, 0.8, 401, 0.15, 0.8),\n        (1.0, 0.0, 1.0, 0.3, 201, 0.3, 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        error = solve_case(*case)\n        # Append result formatted to six decimal places.\n        results.append(f\"{error:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef solve_case(a, x_min, x_max, x_0, N, T, C):\n    \"\"\"\n    Runs a single simulation case for the 1D linear advection equation.\n\n    Args:\n        a (float): Advection speed.\n        x_min (float): Minimum of the spatial domain.\n        x_max (float): Maximum of the spatial domain.\n        x_0 (float): Initial position of the step in the Heaviside function.\n        N (int): Number of grid points.\n        T (float): Final time.\n        C (float): Courant–Friedrichs–Lewy (CFL) number.\n\n    Returns:\n        float: The discrete l1 error at the final time T.\n    \"\"\"\n    # 1. Setup grid and initial condition\n    dx = (x_max - x_min) / (N - 1)\n    x = np.linspace(x_min, x_max, N)\n    # The problem defines H(xi) = 1 for xi >= 0. np.heaviside with second arg 1.0 does this.\n    u = np.heaviside(x - x_0, 1.0)\n\n    # 2. Setup time stepping\n    # The advection speed 'a' is non-zero in all test cases.\n    dt_nominal = C * dx / abs(a)\n    \n    # 3. Time integration loop\n    t = 0.0\n    # Use a small tolerance for floating point comparison to ensure loop termination.\n    while t  T:\n        # Determine current time step to not step over T.\n        current_dt = min(dt_nominal, T - t)\n        \n        # Make a copy of the solution at the current time step 'n'.\n        u_n = u.copy()\n        \n        # The update coefficient nu = a * dt / dx\n        nu = a * current_dt / dx\n        \n        if a > 0:\n            # FTBS (Forward-Time, Backward-Space) for a > 0\n            # u_i^{n+1} = u_i^n - nu * (u_i^n - u_{i-1}^n)\n            u[1:] = u_n[1:] - nu * (u_n[1:] - u_n[:-1])\n            # Apply inflow boundary condition at x_min\n            u[0] = 0.0\n        else: # a  0\n            # FTFS (Forward-Time, Forward-Space) for a  0\n            # u_i^{n+1} = u_i^n - nu * (u_{i+1}^n - u_i^n)\n            u[:-1] = u_n[:-1] - nu * (u_n[1:] - u_n[:-1])\n            # Apply inflow boundary condition at x_max\n            u[-1] = 1.0\n            \n        t += current_dt\n\n    # 4. Calculate exact solution at time T\n    x_final_discontinuity = x_0 + a * T\n    u_exact = np.heaviside(x - x_final_discontinuity, 1.0)\n    \n    # 5. Compute the discrete l1 error\n    error = np.sum(np.abs(u - u_exact)) * dx\n    \n    return error\n\nsolve()\n```"
        },
        {
            "introduction": "Having observed the qualitative effects of numerical diffusion in the previous exercise, we now move to quantify it. For the continuous linear advection equation, the total \"energy\" of the wave, represented by the integral $\\int u^2 dx$, is a conserved quantity. This practice demonstrates that the discrete version of this quantity is not conserved by the upwind scheme, providing a direct measure of the scheme's dissipative nature .",
            "id": "2448571",
            "problem": "Consider the linear advection equation with constant velocity on a one-dimensional periodic domain,\n$$\n\\partial_t u(x,t) + a\\,\\partial_x u(x,t) = 0,\\qquad x\\in[0,L],\\ t\\ge 0,\n$$\nwith periodic boundary conditions and the initial condition\n$$\nu(x,0)=\\sin\\!\\left(\\tfrac{2\\pi x}{L}\\right)+\\tfrac{1}{2}\\sin\\!\\left(\\tfrac{4\\pi x}{L}\\right).\n$$\nOn a uniform grid with $N$ points at positions $x_i=i\\,\\Delta x$ for $i=0,1,\\dots,N-1$ and $\\Delta x=L/N$, define the discrete solution values $u_i^n\\approx u(x_i,t^n)$ at time levels $t^n=n\\,\\Delta t$, where the time step is chosen through a Courant number $s\\in(0,1]$ by\n$$\n\\Delta t=\\frac{s\\,\\Delta x}{|a|}.\n$$\nUse the first-order upwind finite difference scheme with periodic wrapping for the update from time level $n$ to $n+1$:\n- If $a0$,\n$$\nu_i^{n+1} = u_i^{n} - s\\left(u_i^{n}-u_{i-1}^{n}\\right),\n$$\n- If $a0$,\n$$\nu_i^{n+1} = u_i^{n} - s\\left(u_i^{n}-u_{i+1}^{n}\\right),\n$$\nwhere indices are understood modulo $N$ due to periodicity. Evolve the discrete solution from $t=0$ to the final time\n$$\nt_{\\mathrm{final}}=\\frac{L}{|a|},\n$$\nwhich corresponds to exactly $N_t=N/s$ time steps (all test cases below ensure that $N/s$ is an integer), so that the exact continuous solution has completed one full wrap around the domain.\n\nDefine the discrete second moment at time level $n$ by\n$$\nM_2^n=\\sum_{i=0}^{N-1} \\left(u_i^n\\right)^2 \\,\\Delta x,\n$$\nand the diagnostic ratio\n$$\nR=\\frac{M_2^{N_t}}{M_2^0}.\n$$\nIn the continuous equation with periodic boundaries, the quantity $\\int_0^L u(x,t)^2\\,\\mathrm{d}x$ is conserved in time. This problem examines how the numerical diffusion introduced by the upwind scheme affects the conservation of the discrete second moment $M_2^n$ over one domain traversal.\n\nAll quantities in this problem are dimensionless.\n\nImplement a program that, for each parameter set in the test suite below, computes the ratio $R$ as defined above.\n\nTest suite (each tuple lists $(L,a,N,s)$):\n1. $(1,\\ 1,\\ 200,\\ 0.5)$,\n2. $(1,\\ 1,\\ 100,\\ 1)$,\n3. $(1,\\ -1,\\ 200,\\ 0.5)$,\n4. $(1,\\ 1,\\ 20,\\ 0.5)$,\n5. $(1,\\ 1,\\ 200,\\ 0.25)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[r_1,r_2,r_3,r_4,r_5]$), where each $r_k$ is the floating-point value of $R$ for the $k$-th test case in the order listed above.",
            "solution": "The problem presented is a standard exercise in computational physics, concerning the numerical solution of the linear advection equation. It is well-posed, scientifically sound, and all parameters and conditions are specified unambiguously. Therefore, a solution can be constructed.\n\nThe core of the problem is to quantify the numerical dissipation inherent in the first-order upwind finite difference scheme. The governing partial differential equation is the linear advection equation:\n$$\n\\partial_t u(x,t) + a\\,\\partial_x u(x,t) = 0\n$$\non a one-dimensional domain $x\\in[0,L]$ with periodic boundary conditions. For such a system, the integrated square of the solution, $\\int_0^L u(x,t)^2\\,\\mathrm{d}x$, is a conserved quantity. The numerical scheme, however, introduces artificial diffusion which causes the discrete analogue of this quantity to decay over time.\n\nWe discretize the domain using a uniform grid of $N$ points, $x_i = i\\,\\Delta x$ for $i \\in \\{0, 1, \\dots, N-1\\}$, where the grid spacing is $\\Delta x = L/N$. The solution $u(x,t)$ is approximated by discrete values $u_i^n \\approx u(x_i, t^n)$, where $t^n = n\\,\\Delta t$ are the discrete time levels.\n\nFirst, we establish the initial state of the system at time $t=0$. The initial condition is given by:\n$$\nu(x,0)=\\sin\\!\\left(\\tfrac{2\\pi x}{L}\\right)+\\tfrac{1}{2}\\sin\\!\\left(\\tfrac{4\\pi x}{L}\\right)\n$$\nIn discrete form, the initial solution vector $u^0 = [u_0^0, u_1^0, \\dots, u_{N-1}^0]^T$ is initialized as:\n$$\nu_i^0 = \\sin\\!\\left(\\tfrac{2\\pi x_i}{L}\\right)+\\tfrac{1}{2}\\sin\\!\\left(\\tfrac{4\\pi x_i}{L}\\right) = \\sin\\!\\left(\\tfrac{2\\pi i}{N}\\right)+\\tfrac{1}{2}\\sin\\!\\left(\\tfrac{4\\pi i}{N}\\right)\n$$\nfor each grid point $i=0, 1, \\dots, N-1$.\n\nNext, we evolve the solution in time using the first-order upwind scheme. The time step $\\Delta t$ is determined by the Courant number $s \\in (0,1]$:\n$$\n\\Delta t=\\frac{s\\,\\Delta x}{|a|}\n$$\nThe upwind scheme's update rule depends on the sign of the advection velocity $a$, which determines the direction of information propagation.\n\nCase 1: $a0$ (propagation to the right). The spatial derivative $\\partial_x u$ is approximated using a backward difference, as information comes from the \"upwind\" direction, i.e., from smaller $x$. The update rule is:\n$$\nu_i^{n+1} = u_i^{n} - s\\left(u_i^{n}-u_{i-1}^{n}\\right)\n$$\nHere, $s = a \\frac{\\Delta t}{\\Delta x}$ since $a0$. Due to periodic boundary conditions, the index $i-1$ is evaluated modulo $N$, meaning $u_{-1}^n = u_{N-1}^n$.\n\nCase 2: $a0$ (propagation to the left). The spatial derivative is approximated using a forward difference, as information comes from larger $x$. The update rule is:\n$$\nu_i^{n+1} = u_i^{n} - s\\left(u_i^{n}-u_{i+1}^{n}\\right)\n$$\nHere, $s = |a| \\frac{\\Delta t}{\\Delta x} = -a \\frac{\\Delta t}{\\Delta x}$. Due to periodicity, the index $i+1$ is evaluated modulo $N$, meaning $u_{N}^n = u_0^n$.\n\nThe simulation proceeds from $t=0$ to a final time $t_{\\mathrm{final}}=L/|a|$. This time corresponds to one full periodic transit of a wave across the domain. The total number of time steps, $N_t$, is:\n$$\nN_t = \\frac{t_{\\mathrm{final}}}{\\Delta t} = \\frac{L/|a|}{s\\,\\Delta x/|a|} = \\frac{L}{s\\,\\Delta x} = \\frac{L}{s(L/N)} = \\frac{N}{s}\n$$\nThe problem guarantees that $N_t$ is an integer for all test cases. A loop will execute this update step $N_t$ times to obtain the final discrete solution $u^{N_t}$.\n\nFinally, we compute the diagnostic ratio $R$. This requires calculating the discrete second moment, defined as:\n$$\nM_2^n=\\sum_{i=0}^{N-1} \\left(u_i^n\\right)^2 \\,\\Delta x\n$$\nWe compute this quantity at the initial time, $M_2^0$, using the initial solution $u^0$, and at the final time, $M_2^{N_t}$, using the final solution $u^{N_t}$. The ratio $R$ is then given by:\n$$\nR=\\frac{M_2^{N_t}}{M_2^0}\n$$\nThis ratio $R$ quantifies the decay of the discrete squared $L_2$-norm due to numerical dissipation over one traversal period. For a non-dissipative scheme, $R$ would be exactly $1$. For the first-order upwind scheme, we expect $R1$ for $s1$, with the deviation from $1$ indicating the magnitude of dissipation.\n\nThe algorithm for each test case $(L, a, N, s)$ is as follows:\n1.  Define grid parameters: $\\Delta x = L/N$ and $N_t = \\text{int}(N/s)$.\n2.  Generate the spatial grid $x_i = i \\Delta x$ for $i = 0, \\dots, N-1$.\n3.  Compute the initial solution vector $u^0$ using the given formula.\n4.  Calculate the initial second moment $M_2^0 = \\Delta x \\sum_{i=0}^{N-1} (u_i^0)^2$.\n5.  Iterate $N_t$ times: in each step, update the solution vector $u$ using the appropriate upwind formula based on the sign of $a$, respecting periodic boundaries. This is efficiently implemented using vectorized array operations.\n6.  After the loop, calculate the final second moment $M_2^{N_t}$ from the final solution vector.\n7.  Compute and store the ratio $R = M_2^{N_t} / M_2^0$.\n\nThis procedure is repeated for all provided test cases.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the linear advection equation using the first-order upwind scheme\n    and computes the diagnostic ratio R for several test cases.\n    \"\"\"\n    # Test suite from the problem statement: (L, a, N, s)\n    test_cases = [\n        (1, 1, 200, 0.5),\n        (1, 1, 100, 1),\n        (1, -1, 200, 0.5),\n        (1, 1, 20, 0.5),\n        (1, 1, 200, 0.25),\n    ]\n\n    results = []\n    \n    for L, a, N, s in test_cases:\n        # Step 1: Define grid parameters and number of time steps.\n        dx = L / N\n        # The problem statement guarantees that N/s is an integer.\n        num_time_steps = int(N / s)\n        \n        # Step 2: Set the initial condition on the grid.\n        # Grid points x_i = i * dx for i = 0, ..., N-1.\n        x = np.linspace(0, L, N, endpoint=False)\n        u_initial = np.sin(2 * np.pi * x / L) + 0.5 * np.sin(4 * np.pi * x / L)\n        \n        # Step 3: Calculate the initial discrete second moment M_2^0.\n        m2_initial = np.sum(u_initial**2) * dx\n        \n        # Step 4: Evolve the solution in time using the upwind scheme.\n        u_current = np.copy(u_initial)\n        \n        # The update rule depends on the sign of the velocity 'a'.\n        if a > 0:\n            # For a > 0, the scheme uses the backward difference (u_i - u_{i-1}).\n            # u_i^{n+1} = u_i^n - s * (u_i^n - u_{i-1}^n)\n            # np.roll(u, 1) provides u_{i-1} with periodic wrapping.\n            for _ in range(num_time_steps):\n                u_previous = np.roll(u_current, 1)\n                u_current = u_current - s * (u_current - u_previous)\n        else: # a  0\n            # For a  0, the scheme uses the forward difference (u_{i+1} - u_i).\n            # The problem statement gives u_i^{n+1} = u_i^n - s * (u_i^n - u_{i+1}^n)\n            # which is equivalent to u_i^{n+1} = u_i^n + s * (u_{i+1}^n - u_i^n).\n            # np.roll(u, -1) provides u_{i+1} with periodic wrapping.\n            for _ in range(num_time_steps):\n                u_next = np.roll(u_current, -1)\n                u_current = u_current - s * (u_current - u_next)\n                \n        # Step 5: Calculate the final discrete second moment M_2^{N_t}.\n        m2_final = np.sum(u_current**2) * dx\n        \n        # Step 6: Compute the diagnostic ratio R.\n        # A check is included for the theoretical case of M_2^0 = 0, though not\n        # possible with the given initial condition.\n        if m2_initial == 0:\n            ratio = 1.0 if m2_final == 0 else np.inf\n        else:\n            ratio = m2_final / m2_initial\n            \n        results.append(ratio)\n        \n    # Final print statement in the exact required format.\n    # Results are formatted as floating-point numbers to ensure consistency.\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\n# Execute the solver function.\nsolve()\n```"
        },
        {
            "introduction": "We have seen that the first-order upwind scheme is diffusive, while higher-order schemes like Lax-Wendroff can be oscillatory near sharp gradients. This final practice introduces a powerful idea from modern shock-capturing methods: creating a hybrid scheme that adapts to the local solution behavior. By implementing a \"gradient detector,\" your code will learn to switch between the accurate Lax-Wendroff scheme in smooth regions and the robust upwind scheme near discontinuities, combining the best of both worlds .",
            "id": "2448587",
            "problem": "Consider the linear advection equation on a periodic domain,\n$$\n\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = 0,\\quad x \\in [0,1],\\ t \\ge 0,\n$$\nwith constant advection speed $a \\in \\mathbb{R}$ and periodic boundary conditions. Let a uniform spatial grid with $N$ points be defined by\n$$\nx_j = \\frac{j}{N},\\quad j=0,1,\\dots,N-1,\n$$\nwith grid spacing $\\Delta x = \\frac{1}{N}$. Let the time step be chosen by a Courant–Friedrichs–Lewy (CFL) number $\\text{CFL} \\in (0,1]$ through\n$$\n\\Delta t = \\frac{\\text{CFL}\\,\\Delta x}{|a|}.\n$$\nIntegrate in time to the final time\n$$\nT = \\frac{1}{|a|},\n$$\nthat is, one domain traversal, using exactly\n$$\nM = \\frac{N}{\\text{CFL}}\n$$\ntime steps (the parameter sets below are chosen so that $M$ is an integer).\n\nConstruct a hybrid finite difference time-marching scheme that, at each grid point $x_j$ and time level $t^n = n \\Delta t$, selects between a second-order central method and a first-order upwind method based on a local gradient detector. Define the non-dimensional local gradient detector $S_j^n$ by\n$$\nS_j^n = \\frac{\\left|u_{j+1}^n - 2 u_j^n + u_{j-1}^n\\right|}{\\left|u_{j+1}^n - u_j^n\\right| + \\left|u_j^n - u_{j-1}^n\\right| + \\delta},\n$$\nwhere indices are taken modulo $N$ to enforce periodicity, and $\\delta = 10^{-12}$ prevents division by zero. For a user-specified threshold $\\theta  0$, the update at grid point $j$ uses:\n- The second-order Lax–Wendroff formula when $S_j^n \\le \\theta$:\n$$\nu_j^{n+1} = u_j^n - \\frac{\\lambda}{2}\\left(u_{j+1}^n - u_{j-1}^n\\right) + \\frac{\\lambda^2}{2}\\left(u_{j+1}^n - 2u_j^n + u_{j-1}^n\\right),\n$$\n- The first-order upwind formula when $S_j^n  \\theta$, expressed via flux splitting with\n$$\na^+ = \\frac{a + |a|}{2},\\quad a^- = \\frac{a - |a|}{2},\\quad \\lambda = \\frac{a \\Delta t}{\\Delta x},\n$$\nand numerical fluxes\n$$\nf_{j+\\frac{1}{2}}^n = a^+ u_j^n + a^- u_{j+1}^n,\\quad f_{j-\\frac{1}{2}}^n = a^+ u_{j-1}^n + a^- u_j^n,\n$$\nso that\n$$\nu_j^{n+1} = u_j^n - \\frac{\\Delta t}{\\Delta x}\\left(f_{j+\\frac{1}{2}}^n - f_{j-\\frac{1}{2}}^n\\right).\n$$\nAll index arithmetic is modulo $N$.\n\nFor each test case below, initialize $u_j^0 = u_0(x_j)$ and advance to time $T$ as specified. Because of periodicity and the choice of $T$, the exact solution at time $T$ equals the initial condition, so the discrete error can be measured by\n$$\nE = \\frac{1}{N} \\sum_{j=0}^{N-1} \\left|u_j^M - u_j^0\\right|.\n$$\nYour program must compute $E$ for each test case and output the results.\n\nTest suite:\n- Case $1$ (smooth wave, predominantly central): $a = 1$, $N = 100$, $\\text{CFL} = 0.5$, $\\theta = 5.0$, $u_0(x) = \\sin(2\\pi x)$.\n- Case $2$ (discontinuous wave, strong detection): $a = 1$, $N = 120$, $\\text{CFL} = 0.75$, $\\theta = 0.2$, \n$$\nu_0(x) = \\begin{cases}\n1, 0.25 \\le x  0.75,\\\\\n0, \\text{otherwise},\n\\end{cases}\n$$\nwith periodicity on $[0,1]$.\n- Case $3$ (smooth wave, negative advection): $a = -1$, $N = 64$, $\\text{CFL} = 0.5$, $\\theta = 1.0$, $u_0(x) = \\cos(4\\pi x) + \\tfrac{1}{2}\\sin(2\\pi x)$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each error $E$ rounded to $8$ decimal places, in the order of Cases $1,2,3$ (for example, $[0.00000000,0.01234567,0.00012345]$). All quantities in this problem are non-dimensional; no physical units are required.",
            "solution": "The problem as stated is valid. It is a well-posed, scientifically grounded problem in the field of computational physics that asks for the implementation and testing of a hybrid numerical scheme for the linear advection equation. All parameters and conditions are specified without ambiguity or contradiction. We shall proceed with the derivation and implementation of the required algorithm.\n\nThe governing partial differential equation is the linear advection equation,\n$$\n\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = 0\n$$\non a periodic domain $x \\in [0,1]$. This equation models the transport of a quantity $u$ with a constant velocity $a$. The spatial domain is discretized using a uniform grid with $N$ points $x_j = j/N$ for $j=0, 1, \\dots, N-1$, with grid spacing $\\Delta x = 1/N$. Time is advanced in discrete steps of size $\\Delta t$. The problem specifies a final time $T = 1/|a|$, which corresponds to exactly one full advection of the initial profile across the periodic domain. Consequently, the exact solution at time $T$ is identical to the initial condition, $u(x, T) = u_0(x)$, providing a direct way to measure the numerical error of the scheme.\n\nThe core of the problem is to implement a hybrid numerical scheme. Such schemes are designed to combine the strengths of different numerical methods. Here, we combine a second-order accurate method, which provides high fidelity in smooth regions of the solution, with a first-order accurate method, which offers greater stability and monotonicity near sharp gradients or discontinuities, thereby preventing non-physical oscillations.\n\nThe choice between the two methods at each grid point $x_j$ and time level $t^n$ is dictated by a local gradient detector, $S_j^n$. It is defined as\n$$\nS_j^n = \\frac{\\left|u_{j+1}^n - 2 u_j^n + u_{j-1}^n\\right|}{\\left|u_{j+1}^n - u_j^n\\right| + \\left|u_j^n - u_{j-1}^n\\right| + \\delta}.\n$$\nThe numerator is an approximation of the second spatial derivative, $|\\Delta x^2 \\frac{\\partial^2 u}{\\partial x^2}|$, which measures the local curvature of the solution profile. The denominator is a measure of the total local variation, related to the first derivative. A large value of $S_j^n$ signifies a region of high curvature relative to the local slope, such as a sharp peak, a discontinuity, or a numerical oscillation. A user-defined threshold $\\theta  0$ determines the switch: if $S_j^n$ is large, the more dissipative scheme is used. Otherwise, the more accurate scheme is employed. The small constant $\\delta = 10^{-12}$ is a standard regularization term to prevent division by zero in regions where the solution is flat.\n\nIf $S_j^n \\le \\theta$, the scheme employs the second-order Lax-Wendroff method. The update formula is\n$$\nu_j^{n+1} = u_j^n - \\frac{\\lambda}{2}\\left(u_{j+1}^n - u_{j-1}^n\\right) + \\frac{\\lambda^2}{2}\\left(u_{j+1}^n - 2u_j^n + u_{j-1}^n\\right).\n$$\nHere, $\\lambda = a \\Delta t / \\Delta x$ is the signed Courant number. Given the definition $\\Delta t = \\text{CFL}\\,\\Delta x/|a|$, it simplifies to $\\lambda = \\text{CFL} \\cdot \\text{sgn}(a)$. The stability of this method requires $|\\lambda| \\le 1$, which is satisfied since $\\text{CFL} \\le 1$. The Lax-Wendroff scheme is derived from a Taylor series expansion in time and space, making it second-order accurate in both, but it is known to produce spurious oscillations near sharp gradients.\n\nIf $S_j^n  \\theta$, the scheme switches to the first-order upwind method. The problem provides a compact flux-splitting formulation:\n$$\nu_j^{n+1} = u_j^n - \\frac{\\Delta t}{\\Delta x}\\left(f_{j+\\frac{1}{2}}^n - f_{j-\\frac{1}{2}}^n\\right),\n$$\nwith numerical fluxes $f_{j\\pm\\frac{1}{2}}^n$ defined using split velocities $a^+ = (a+|a|)/2$ and $a^- = (a-|a|)/2$. This formulation is equivalent to the standard upwind schemes:\n- If $a  0$, then $a^+ = a$ and $a^- = 0$. The update becomes $u_j^{n+1} = u_j^n - \\lambda(u_j^n - u_{j-1}^n)$. Information propagates from the left (upwind).\n- If $a  0$, then $a^+ = 0$ and $a^- = a$. The update becomes $u_j^{n+1} = u_j^n - \\lambda(u_{j+1}^n - u_j^n)$. Information propagates from the right (upwind).\nThis method is only first-order accurate but is robust and does not generate new extrema (monotonicity), making it suitable for regions with large gradients.\n\nThe overall algorithm proceeds as follows. First, the spatial grid and the initial condition $u_j^0 = u_0(x_j)$ are defined. Then, a loop executes for $M = N/\\text{CFL}$ time steps to reach the final time $T$. In each time step from $t^n$ to $t^{n+1}$:\n1. An auxiliary array, representing $u^{n+1}$, is prepared.\n2. For each grid point $j$, the gradient detector $S_j^n$ is computed using the values of $u^n$ at points $j-1$, $j$, and $j+1$. The periodic boundary conditions are enforced by taking indices modulo $N$.\n3. The value of $S_j^n$ is compared to $\\theta$. Based on this comparison, either the Lax-Wendroff or the upwind formula is used to calculate $u_j^{n+1}$.\n4. This process is repeated for all points $j=0, \\dots, N-1$. In a vectorized implementation, the gradient detector $S^n$ is calculated for all points simultaneously. A boolean mask is created from the condition $S^n  \\theta$, and this mask is used to select the appropriate update term from pre-calculated Lax-Wendroff and upwind update arrays.\n5. The solution array $u^n$ is replaced by the newly computed $u^{n+1}$.\n\nAfter $M$ steps, the numerical solution $u^M$ is obtained. The error $E$ is calculated as the discrete $L^1$-norm of the difference between the final numerical solution and the initial condition, averaged over the grid:\n$$\nE = \\frac{1}{N} \\sum_{j=0}^{N-1} \\left|u_j^M - u_j^0\\right|.\n$$\nThis procedure is applied to each of the three test cases specified in the problem statement.",
            "answer": "```python\nimport numpy as np\n\ndef run_simulation(a, N, CFL, theta, u0_func):\n    \"\"\"\n    Runs a single simulation of the hybrid advection scheme.\n\n    Args:\n        a (float): Advection speed.\n        N (int): Number of grid points.\n        CFL (float): Courant–Friedrichs–Lewy number.\n        theta (float): Switching threshold for the gradient detector.\n        u0_func (callable): Function to generate the initial condition u0(x).\n\n    Returns:\n        float: The computed L1 error.\n    \"\"\"\n    # Constants and parameters\n    delta = 1e-12\n    dx = 1.0 / N\n    # The number of time steps M is guaranteed to be an integer by the problem spec.\n    M = int(N / CFL)\n    dt = CFL * dx / np.abs(a)\n    lambda_val = CFL * np.sign(a)\n    \n    a_plus = (a + np.abs(a)) / 2.0\n    a_minus = (a - np.abs(a)) / 2.0\n\n    # Grid and Initial Condition\n    x = np.linspace(0.0, 1.0, N, endpoint=False)\n    u0 = u0_func(x)\n    u = u0.copy()\n\n    # Time-marching loop\n    for _ in range(M):\n        # Stencil points with periodic boundaries\n        u_jp1 = np.roll(u, -1)\n        u_jm1 = np.roll(u, 1)\n\n        # Gradient detector S_j^n\n        s_numerator = np.abs(u_jp1 - 2*u + u_jm1)\n        s_denominator = np.abs(u_jp1 - u) + np.abs(u - u_jm1) + delta\n        S = s_numerator / s_denominator\n        \n        # Boolean mask for switching between schemes\n        switch_to_upwind = S > theta\n\n        # Lax-Wendroff update contribution\n        # u_j^{n+1} = u_j^n + lw_update\n        lw_update = -0.5 * lambda_val * (u_jp1 - u_jm1) + \\\n                     0.5 * lambda_val**2 * (u_jp1 - 2*u + u_jm1)\n\n        # First-order upwind update contribution\n        # u_j^{n+1} = u_j^n + upwind_update\n        upwind_update = -(dt / dx) * (a_plus * (u - u_jm1) + a_minus * (u_jp1 - u))\n\n        # Apply hybrid update based on the mask\n        update_term = np.where(switch_to_upwind, upwind_update, lw_update)\n        u = u + update_term\n    \n    # Calculate final error\n    error = np.mean(np.abs(u - u0))\n    return error\n\ndef solve():\n    \"\"\"\n    Defines test cases, runs simulations, and prints the results.\n    \"\"\"\n    test_cases = [\n        # Case 1 (smooth wave, predominantly central)\n        {'a': 1.0, 'N': 100, 'CFL': 0.5, 'theta': 5.0, \n         'u0_func': lambda x: np.sin(2 * np.pi * x)},\n        # Case 2 (discontinuous wave, strong detection)\n        {'a': 1.0, 'N': 120, 'CFL': 0.75, 'theta': 0.2, \n         'u0_func': lambda x: np.where((x >= 0.25)  (x  0.75), 1.0, 0.0)},\n        # Case 3 (smooth wave, negative advection)\n        {'a': -1.0, 'N': 64, 'CFL': 0.5, 'theta': 1.0, \n         'u0_func': lambda x: np.cos(4 * np.pi * x) + 0.5 * np.sin(2 * np.pi * x)},\n    ]\n\n    results = []\n    for case in test_cases:\n        error = run_simulation(\n            case['a'], case['N'], case['CFL'], case['theta'], case['u0_func']\n        )\n        results.append(f\"{error:.8f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}