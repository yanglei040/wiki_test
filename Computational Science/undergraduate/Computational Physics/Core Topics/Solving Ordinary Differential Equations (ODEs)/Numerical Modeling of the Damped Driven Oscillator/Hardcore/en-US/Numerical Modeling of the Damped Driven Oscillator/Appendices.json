{
    "hands_on_practices": [
        {
            "introduction": "Our exploration begins with a step beyond the familiar linear oscillator into the realm of nonlinear dynamics. This first practice introduces the Duffing oscillator, a system that adds a simple cubic term to the restoring force, yet reveals profoundly different behavior. By computing the phase lag between the oscillator and its driver, you will discover firsthand how nonlinearity makes the system's response dependent on the driving amplitude, a crucial departure from linear theory. ",
            "id": "2419785",
            "problem": "Consider the forced, damped, nonlinear oscillator governed by the ordinary differential equation (ODE)\n$$\nm\\,\\ddot{x}(t) + c\\,\\dot{x}(t) + k\\,x(t) + \\alpha\\,x^{3}(t) = F_{0}\\cos(\\omega t),\n$$\nwith mass $m$, damping coefficient $c$, linear stiffness $k$, cubic stiffness $\\alpha$, forcing amplitude $F_{0}$, and driving angular frequency $\\omega$. Take the following fixed parameter values in International System of Units (SI) units: $m = 1.0\\,\\mathrm{kg}$, $c = 0.3\\,\\mathrm{kg/s}$, $k = 1.0\\,\\mathrm{N/m}$, $\\alpha = 1.0\\,\\mathrm{N/m^{3}}$, and $\\omega = 1.2\\,\\mathrm{rad/s}$. The initial conditions are $x(0) = 0.0\\,\\mathrm{m}$ and $\\dot{x}(0) = 0.0\\,\\mathrm{m/s}$, and time $t$ is in $\\mathrm{s}$. Define the phase lag $\\delta$ between the driver and the oscillator as follows. In the steady-state, define the fundamental (at angular frequency $\\omega$) in-phase and quadrature projections of the displacement $x(t)$ over a finite averaging window of length $T_{\\mathrm{w}}$ by\n$$\nA = \\frac{2}{T_{\\mathrm{w}}}\\int_{t_{0}}^{t_{0} + T_{\\mathrm{w}}} x(t)\\cos(\\omega t)\\,dt, \\qquad\nB = \\frac{2}{T_{\\mathrm{w}}}\\int_{t_{0}}^{t_{0} + T_{\\mathrm{w}}} x(t)\\sin(\\omega t)\\,dt,\n$$\nand set\n$$\n\\delta = \\operatorname{atan2}(B, A),\n$$\nmapped into the interval $[0, 2\\pi)$ by adding $2\\pi$ if the computed value is negative. The averaging must be performed after transients have decayed, using $t_{0} = 200.0\\,\\mathrm{s}$ and a window $T_{\\mathrm{w}} = N_{\\mathrm{avg}} \\,\\frac{2\\pi}{\\omega}$ with $N_{\\mathrm{avg}} = 20$. Angles must be expressed in radians. Your task is to compute the phase lag $\\delta$ for each of the following forcing amplitudes $F_{0}$ (expressed in $\\mathrm{N}$): $F_{0} \\in \\{\\,0.05,\\,0.20,\\,0.50,\\,0.80\\,\\}$. Use the fixed values of $(m,c,k,\\alpha,\\omega)$ and the initial conditions given above, and evaluate the integrals defining $A$ and $B$ over the specified averaging window starting at $t_{0}$.\n\nTest Suite and Answer Specification:\n- Use the four forcing amplitudes $F_{0}$ given above as the test suite.\n- For each case, produce a single real number corresponding to the phase lag $\\delta$ in radians, mapped to $[0, 2\\pi)$ as prescribed.\n- The final program output must be one line containing the four values of $\\delta$ corresponding to the test cases, in the same order as listed, rounded to exactly $6$ decimal places.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example $[0.123456,1.234567,2.345678,3.456789]$.",
            "solution": "The problem statement is subjected to validation and is found to be valid. It describes a well-posed initial value problem for the forced, damped Duffing oscillator, a canonical system in the study of nonlinear dynamics. All parameters, initial conditions, and procedures for analysis are defined with scientific and mathematical rigor. There are no contradictions, ambiguities, or factual inaccuracies.\n\nThe task is to compute the steady-state phase lag $\\delta$ between the response $x(t)$ and the driving force for a nonlinear oscillator. The governing equation is the second-order ordinary differential equation (ODE):\n$$\nm\\,\\ddot{x}(t) + c\\,\\dot{x}(t) + k\\,x(t) + \\alpha\\,x^{3}(t) = F_{0}\\cos(\\omega t)\n$$\nThe solution requires a numerical approach, which proceeds as follows.\n\nFirst, we convert the second-order ODE into a system of two first-order ODEs. Let us define a state vector $\\mathbf{y}(t) = [y_1(t), y_2(t)]^T$, where $y_1(t) = x(t)$ represents the position and $y_2(t) = \\dot{x}(t)$ represents the velocity. The time evolution of this state vector is given by the system:\n$$\n\\dot{\\mathbf{y}}(t) = \n\\begin{pmatrix} \\dot{y}_1(t) \\\\ \\dot{y}_2(t) \\end{pmatrix} =\n\\begin{pmatrix} y_2(t) \\\\ \\frac{1}{m} \\left( F_{0}\\cos(\\omega t) - c\\,y_2(t) - k\\,y_1(t) - \\alpha\\,y_1^3(t) \\right) \\end{pmatrix}\n$$\nThis system is to be solved with the initial conditions $x(0) = y_1(0) = 0.0\\,\\mathrm{m}$ and $\\dot{x}(0) = y_2(0) = 0.0\\,\\mathrm{m/s}$. The given parameters are $m = 1.0\\,\\mathrm{kg}$, $c = 0.3\\,\\mathrm{kg/s}$, $k = 1.0\\,\\mathrm{N/m}$, $\\alpha = 1.0\\,\\mathrm{N/m^{3}}$, and $\\omega = 1.2\\,\\mathrm{rad/s}$. The problem is to be solved for four different values of the forcing amplitude $F_{0} \\in \\{0.05, 0.20, 0.50, 0.80\\}\\,\\mathrm{N}$.\n\nThis initial value problem (IVP) is solved numerically using an appropriate algorithm. The `scipy.integrate.solve_ivp` function, which implements a high-order adaptive step-size Runge-Kutta method (e.g., `RK45`), is a suitable choice for this task. The integration must be performed over a time interval sufficient to allow transients to decay and to cover the specified averaging window. The integration interval is from $t=0$ to $t_{f} = t_{0} + T_{w}$. The start time for averaging is $t_{0} = 200.0\\,\\mathrm{s}$, and the window duration is $T_{\\mathrm{w}} = N_{\\mathrm{avg}} \\frac{2\\pi}{\\omega}$, with $N_{\\mathrm{avg}} = 20$. This gives $t_{f} = 200.0 + 20 \\frac{2\\pi}{1.2} \\approx 304.7198\\,\\mathrm{s}$. To facilitate the subsequent integral calculations, the ODE solver is configured to produce a dense output, which provides a continuous interpolating function for the solution $x(t)$.\n\nOnce the numerical solution for $x(t)$ is obtained, the in-phase and quadrature projections, $A$ and $B$, are computed. These are defined as the fundamental Fourier coefficients of the steady-state response:\n$$\nA = \\frac{2}{T_{\\mathrm{w}}}\\int_{t_{0}}^{t_{0} + T_{\\mathrm{w}}} x(t)\\cos(\\omega t)\\,dt\n$$\n$$\nB = \\frac{2}{T_{\\mathrm{w}}}\\int_{t_{0}}^{t_{0} + T_{\\mathrm{w}}} x(t)\\sin(\\omega t)\\,dt\n$$\nThese definite integrals are computed numerically using a robust quadrature method. The `scipy.integrate.quad` function, which employs an adaptive quadrature scheme, is an excellent choice. It operates on the integrand functions, where $x(t)$ is provided by the interpolant from the `solve_ivp` output.\n\nFinally, the phase lag $\\delta$ is determined from the coefficients $A$ and $B$ using the two-argument arctangent function:\n$$\n\\delta = \\operatorname{atan2}(B, A)\n$$\nThe use of `atan2` correctly places the angle in the proper quadrant, yielding a result in the range $(-\\pi, \\pi]$. As per the problem specification, this value is then mapped into the interval $[0, 2\\pi)$ by adding $2\\pi$ to any negative result.\n\nThis entire procedure—numerical solution of the ODE, numerical evaluation of the integrals for $A$ and $B$, and calculation of $\\delta$—is repeated for each specified value of $F_{0}$. The final numerical results are rounded to six decimal places.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp, quad\n\ndef solve():\n    \"\"\"\n    Solves the damped, driven Duffing oscillator equation for several forcing\n    amplitudes and computes the steady-state phase lag for each case.\n    \"\"\"\n\n    # --- Define problem parameters in SI units ---\n    m = 1.0        # mass (kg)\n    c = 0.3        # damping coefficient (kg/s)\n    k = 1.0        # linear stiffness (N/m)\n    alpha = 1.0    # cubic stiffness (N/m^3)\n    omega = 1.2    # driving angular frequency (rad/s)\n\n    # --- Define simulation and analysis parameters ---\n    x0 = 0.0       # initial position (m)\n    v0 = 0.0       # initial velocity (m/s)\n    y0 = [x0, v0]  # initial state vector [x, v]\n\n    t0 = 200.0     # start time for averaging (s)\n    N_avg = 20     # number of cycles for averaging\n    T_w = N_avg * (2 * np.pi / omega)  # averaging window duration (s)\n    t_final = t0 + T_w               # end time for simulation\n\n    # --- Test cases for forcing amplitude ---\n    test_cases_F0 = [0.05, 0.20, 0.50, 0.80]  # (N)\n\n    results = []\n\n    def duffing_ode_system(t, y, F0):\n        \"\"\"\n        Defines the system of first-order ODEs for the Duffing oscillator.\n        y[0] = x (position), y[1] = v (velocity).\n        \"\"\"\n        x, v = y\n        # Equation: m*x_ddot + c*v + k*x + alpha*x^3 = F0*cos(omega*t)\n        # Transformed to: x_ddot = (F0*cos(omega*t) - c*v - k*x - alpha*x^3) / m\n        dv_dt = (F0 * np.cos(omega * t) - c * v - k * x - alpha * x**3) / m\n        return [v, dv_dt]\n\n    for F0 in test_cases_F0:\n        # Numerically solve the ODE system.\n        # dense_output=True creates an interpolant for the solution,\n        # which is needed for accurate quadrature.\n        # Stricter tolerances are used for higher accuracy of the final result.\n        solution = solve_ivp(\n            fun=lambda t, y: duffing_ode_system(t, y, F0),\n            t_span=(0, t_final),\n            y0=y0,\n            dense_output=True,\n            method='RK45',\n            rtol=1e-8,\n            atol=1e-10\n        )\n\n        # The solution object `sol.sol` is a callable interpolating function.\n        x_t = lambda t: solution.sol(t)[0]\n\n        # Define the integrands for the Fourier projections A and B.\n        integrand_A = lambda t: x_t(t) * np.cos(omega * t)\n        integrand_B = lambda t: x_t(t) * np.sin(omega * t)\n\n        # Compute the integrals using `scipy.integrate.quad`.\n        # `quad` returns (integral_value, error_estimate), we only need the value.\n        A_integral, _ = quad(integrand_A, t0, t_final)\n        B_integral, _ = quad(integrand_B, t0, t_final)\n\n        # Calculate the A and B coefficients based on their definition.\n        A = (2 / T_w) * A_integral\n        B = (2 / T_w) * B_integral\n\n        # Calculate the phase lag delta using atan2(B, A).\n        delta = np.arctan2(B, A)\n\n        # Map delta from (-pi, pi] to the required interval [0, 2pi).\n        if delta  0:\n            delta += 2 * np.pi\n\n        results.append(delta)\n\n    # Format the final output string to exactly 6 decimal places.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Having examined steady-state nonlinear oscillations, we now turn to a different class of behavior: transient dynamics and escape. This problem models a particle in a potential well that is stable for small motions but has a finite barrier, a common scenario in physics and chemistry. You will simulate how a periodic driving force can push the particle out of the well and learn to use event detection within an ODE solver to efficiently determine the moment of escape. ",
            "id": "2419806",
            "problem": "A point particle of mass $m$ moves along the $x$ axis in a one-dimensional cubic potential well subject to linear viscous damping and a periodic external drive. The potential energy is $U(x)=\\tfrac{1}{2}k x^{2}-\\tfrac{1}{3}\\mu x^{3}$ with $k0$ and $\\mu0$. The equation of motion, derived from Newton's second law and the conservative force $-\\partial U/\\partial x$, is\n$$\nm\\,\\ddot{x}(t)+\\gamma\\,\\dot{x}(t)+k\\,x(t)-\\mu\\,x(t)^{2}=F_{0}\\cos\\big(\\omega t+\\phi\\big),\n$$\nwhere $\\gamma\\ge 0$ is the linear damping coefficient, $F_{0}\\ge 0$ is the driving amplitude, $\\omega0$ is the driving angular frequency, and $\\phi$ is a constant phase. Angles must be expressed in radians.\n\nThe cubic potential has a local minimum at $x=0$ and a barrier (local maximum) at position $x_{b}=\\dfrac{k}{\\mu}$. Define “escape” to occur if there exists a time $t$ in the closed interval $[0,T_{\\mathrm{end}}]$ such that $x(t)\\ge x_{b}$.\n\nYour task is to model the motion governed by the above ordinary differential equation (ODE) and, for each parameter set in the test suite below, determine whether the particle escapes within the specified time horizon. Use International System of Units (SI): $m$ in kilograms, $\\gamma$ in kilograms per second, $k$ in newtons per meter, $\\mu$ in newtons per square meter, $F_{0}$ in newtons, $\\omega$ in radians per second, $x$ in meters, $t$ in seconds, and $\\phi$ in radians. Initial conditions are $x(0)=x_{0}$ and $\\dot{x}(0)=v_{0}$. Report results as boolean values, where $\\mathrm{True}$ indicates escape ($x(t)\\ge x_{b}$ for some $t\\in[0,T_{\\mathrm{end}}]$) and $\\mathrm{False}$ indicates no escape on $[0,T_{\\mathrm{end}}]$.\n\nTest suite (each line lists $(m,\\gamma,k,\\mu,F_{0},\\omega,\\phi,x_{0},v_{0},T_{\\mathrm{end}})$):\n- $(\\;m=\\;1.0,\\;\\gamma=\\;0.1,\\;k=\\;1.0,\\;\\mu=\\;1.0,\\;F_{0}=\\;0.30,\\;\\omega=\\;1.0,\\;\\phi=\\;0.0,\\;x_{0}=\\;0.0,\\;v_{0}=\\;0.0,\\;T_{\\mathrm{end}}=\\;20.0\\;)$\n- $(\\;m=\\;1.0,\\;\\gamma=\\;0.1,\\;k=\\;1.0,\\;\\mu=\\;1.0,\\;F_{0}=\\;0.05,\\;\\omega=\\;1.0,\\;\\phi=\\;0.0,\\;x_{0}=\\;0.0,\\;v_{0}=\\;0.0,\\;T_{\\mathrm{end}}=\\;50.0\\;)$\n- $(\\;m=\\;1.0,\\;\\gamma=\\;0.5,\\;k=\\;2.0,\\;\\mu=\\;1.0,\\;F_{0}=\\;1.10,\\;\\omega=\\;1.2,\\;\\phi=\\;0.0,\\;x_{0}=\\;0.0,\\;v_{0}=\\;0.0,\\;T_{\\mathrm{end}}=\\;10.0\\;)$\n- $(\\;m=\\;1.0,\\;\\gamma=\\;1.5,\\;k=\\;1.0,\\;\\mu=\\;1.0,\\;F_{0}=\\;0.22,\\;\\omega=\\;1.0,\\;\\phi=\\;0.0,\\;x_{0}=\\;0.0,\\;v_{0}=\\;0.0,\\;T_{\\mathrm{end}}=\\;60.0\\;)$\n- $(\\;m=\\;1.0,\\;\\gamma=\\;0.1,\\;k=\\;1.0,\\;\\mu=\\;1.0,\\;F_{0}=\\;0.26,\\;\\omega=\\;3.0,\\;\\phi=\\;0.0,\\;x_{0}=\\;0.0,\\;v_{0}=\\;0.0,\\;T_{\\mathrm{end}}=\\;5.0\\;)$\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $[\\mathrm{True},\\mathrm{False},\\mathrm{True},\\mathrm{False},\\mathrm{True}]$ in the order of the test suite above.",
            "solution": "The problem presented is a standard exercise in computational physics, specifically the numerical analysis of a nonlinear, damped, and driven oscillator. It is scientifically sound and well-posed. We must determine whether a particle, whose motion is governed by a given second-order ordinary differential equation (ODE), escapes from a potential well within a specified time.\n\nThe equation of motion is:\n$$\nm\\,\\ddot{x}(t)+\\gamma\\,\\dot{x}(t)+k\\,x(t)-\\mu\\,x(t)^{2}=F_{0}\\cos\\big(\\omega t+\\phi\\big)\n$$\nThis is an initial value problem, as the initial state of the system, defined by the position $x(0) = x_{0}$ and velocity $\\dot{x}(0) = v_{0}$, is provided. Analytical solution of this nonlinear equation is not feasible, so a numerical approach is required.\n\nThe standard procedure for numerically solving an $n$-th order ODE is to convert it into a system of $n$ first-order ODEs. For our second-order equation, we introduce a state vector $\\mathbf{y}(t)$ with two components: $y_{1}(t) = x(t)$, the position, and $y_{2}(t) = \\dot{x}(t)$, the velocity. The state of the system at any time $t$ is completely described by this vector $\\mathbf{y}(t) = [y_{1}(t), y_{2}(t)]^{T}$.\n\nThe first-order system is derived as follows:\nThe time derivative of the first component is simply the definition of velocity:\n$$\n\\dot{y}_{1}(t) = \\frac{dx}{dt} = \\dot{x}(t) = y_{2}(t)\n$$\nThe time derivative of the second component is the acceleration, $\\ddot{x}(t)$, which we obtain by rearranging the original equation of motion:\n$$\n\\ddot{x}(t) = \\frac{1}{m} \\left( F_{0}\\cos(\\omega t + \\phi) - \\gamma\\,\\dot{x}(t) - k\\,x(t) + \\mu\\,x(t)^{2} \\right)\n$$\nSubstituting $y_{1}$ and $y_{2}$, we get:\n$$\n\\dot{y}_{2}(t) = \\frac{1}{m} \\left( F_{0}\\cos(\\omega t + \\phi) - \\gamma\\,y_{2}(t) - k\\,y_{1}(t) + \\mu\\,y_{1}(t)^{2} \\right)\n$$\nThis gives us the system $\\dot{\\mathbf{y}}(t) = \\mathbf{f}(t, \\mathbf{y})$, which can be solved using standard numerical integrators. The initial condition for this system is $\\mathbf{y}(0) = [x_{0}, v_{0}]^{T}$.\n\nThe problem requires us to determine if the particle \"escapes\". Escape is defined by the condition $x(t) \\ge x_{b}$ for some time $t \\in [0, T_{\\mathrm{end}}]$, where the escape boundary is $x_{b} = k/\\mu$. Instead of integrating the system for the full duration $T_{\\mathrm{end}}$ and then checking the entire trajectory, a more computationally efficient method is to use event detection, a feature available in modern ODE solvers such as `scipy.integrate.solve_ivp`.\n\nAn event function, let us call it $g(t, \\mathbf{y})$, is defined such that the event of interest occurs when $g(t, \\mathbf{y}) = 0$. For our escape condition, we define the event function as:\n$$\ng(t, \\mathbf{y}) = y_{1}(t) - x_{b}\n$$\nWe are interested in the point where the particle's position $y_{1}(t)$ crosses the boundary $x_{b}$ from below. This corresponds to the event function $g(t, \\mathbf{y})$ crossing zero with a positive slope. We instruct the solver to treat this event as \"terminal,\" meaning the integration will halt as soon as the condition is met.\n\nThe algorithm for each test case is therefore as follows:\n$1$. For a given set of parameters $(m, \\gamma, k, \\mu, F_{0}, \\omega, \\phi, x_{0}, v_{0}, T_{\\mathrm{end}})$, calculate the escape boundary $x_{b} = k/\\mu$.\n$2$. Define the vector function $\\mathbf{f}(t, \\mathbf{y})$ for the system of first-order ODEs.\n$3$. Define the terminal event function $g(t, \\mathbf{y}) = y_{1}(t) - x_{b}$.\n$4$. Use a numerical solver, specifically `scipy.integrate.solve_ivp`, to integrate the system from $t=0$ to $t=T_{\\mathrm{end}}$ with initial condition $\\mathbf{y}(0)=[x_{0}, v_{0}]^{T}$, while monitoring for the terminal event.\n$5$. If the solver returns because the event was triggered, it means that $x(t)$ reached $x_{b}$ at some $t \\le T_{\\mathrm{end}}$. The result is $\\mathrm{True}$.\n$6$. If the solver completes the integration up to $T_{\\mathrm{end}}$ without the event being triggered, the particle did not escape within the given time horizon. The result is $\\mathrm{False}$.\n\nThis procedure provides a rigorous and efficient way to solve the problem. The provided Python code implements this exact logic.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves the damped driven oscillator problem for a suite of test cases.\n    \"\"\"\n    \n    # Test suite (m, gamma, k, mu, F0, omega, phi, x0, v0, T_end)\n    test_cases = [\n        (1.0, 0.1, 1.0, 1.0, 0.30, 1.0, 0.0, 0.0, 0.0, 20.0),\n        (1.0, 0.1, 1.0, 1.0, 0.05, 1.0, 0.0, 0.0, 0.0, 50.0),\n        (1.0, 0.5, 2.0, 1.0, 1.10, 1.2, 0.0, 0.0, 0.0, 10.0),\n        (1.0, 1.5, 1.0, 1.0, 0.22, 1.0, 0.0, 0.0, 0.0, 60.0),\n        (1.0, 0.1, 1.0, 1.0, 0.26, 3.0, 0.0, 0.0, 0.0, 5.0),\n    ]\n\n    results = []\n\n    for params in test_cases:\n        m, gamma, k, mu, F0, omega, phi, x0, v0, T_end = params\n\n        # Escape boundary position\n        x_b = k / mu\n\n        def ode_system(t, y):\n            \"\"\"\n            Defines the system of first-order ODEs.\n            y[0] = x (position)\n            y[1] = v (velocity)\n            \"\"\"\n            x, v = y\n            \n            # Driving force\n            F_drive = F0 * np.cos(omega * t + phi)\n            \n            # Acceleration (d^2x/dt^2), from rearranging the equation of motion\n            # m*x_ddot + gamma*x_dot + k*x - mu*x^2 = F_drive\n            # x_ddot = (1/m) * (F_drive - gamma*x_dot - k*x + mu*x^2)\n            acceleration = (F_drive - gamma * v - k * x + mu * x**2) / m\n            \n            return [v, acceleration]\n\n        def escape_event(t, y):\n            \"\"\"\n            Event function to detect when the particle reaches the escape boundary.\n            Event occurs when this function is zero.\n            \"\"\"\n            return y[0] - x_b\n        \n        # The event is terminal: integration stops when the particle escapes.\n        escape_event.terminal = True\n        # We only care about crossing from below (increasing position).\n        escape_event.direction = 1\n\n        # Initial conditions for the state vector [x, v]\n        y0 = [x0, v0]\n        \n        # Time span for the integration\n        t_span = [0, T_end]\n\n        # Solve the initial value problem\n        # We use solve_ivp, a modern, robust ODE solver in SciPy.\n        sol = solve_ivp(\n            fun=ode_system,\n            t_span=t_span,\n            y0=y0,\n            method='RK45',  # Standard Runge-Kutta adaptive method\n            events=escape_event,\n            dense_output=True # Necessary for precise event location\n        )\n\n        # Check if the escape event was triggered.\n        # sol.t_events is a list of arrays, one for each event function.\n        # If the array for our event is non-empty, the event occurred.\n        if sol.t_events[0].size  0:\n            results.append(True)  # Particle escaped\n        else:\n            results.append(False) # Particle did not escape within T_end\n\n    # Format the final output as specified\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Our journey culminates with a model that reveals how simple deterministic rules can lead to the complexities of chaos. We will simulate a dripping faucet, a system characterized by continuous growth punctuated by discrete 'reset' events when a drop detaches. By analyzing the sequence of inter-drip times, you will observe the famous period-doubling bifurcation sequence—a classic route to chaos—and develop skills in modeling more complex, hybrid dynamical systems. ",
            "id": "2419756",
            "problem": "You are asked to build a complete, runnable program that numerically models a dripping faucet through the lens of a damped driven oscillator. The model is constructed from Newton’s second law, under the following simplifying and widely used assumptions: while a drop remains attached to the faucet, it behaves as a point mass connected to a linear spring and damper, subject to a constant gravitational force. The faucet adds mass at a constant flow rate, and the drop detaches when the elongation exceeds a mass-dependent rupture threshold. After detachment, a small residue remains as the seed of the next drop. This setting is a standard computational physics exercise and leads to a nonautonomous ordinary differential equation (ODE) with state resets. The goal is to simulate the dynamics as the flow rate changes and to extract the number of distinct inter-drip times after transients, thereby revealing a period-doubling sequence.\n\nStart from Newton’s second law and the definitions of linear damping and linear elasticity. While the drop is attached, assume the following:\n- The position of the drop relative to the faucet is a scalar displacement $x(t)$ measured downward, with velocity $v(t) = \\frac{dx}{dt}$.\n- The instantaneous mass $m(t)$ increases at a constant inflow rate $q$, i.e., $\\frac{dm}{dt} = q$.\n- The forces on the drop are due to gravity, a linear spring, and a linear damper, with coefficients $g$, $\\kappa$, and $\\gamma$, respectively.\n- The newly added mass is assumed to attach with negligible relative momentum effect, giving a commonly used approximation where the left-hand side uses $m(t)\\,x''(t)$ without an additional jet-momentum term.\n\nUnder these assumptions, the governing equations while attached are\n$$\n\\frac{dx}{dt} = v, \\quad \n\\frac{dv}{dt} = \\frac{m(t)\\,g - \\gamma\\,v - \\kappa\\,x}{m(t)}, \\quad\n\\frac{dm}{dt} = q.\n$$\nA rupture (detachment) occurs when the elongation $x(t)$ reaches a threshold $x_{\\mathrm{break}}(m)$ from below, with\n$$\nx_{\\mathrm{break}}(m) = x_0 - \\beta\\,m,\n$$\nwhere $x_0$ and $\\beta$ are positive constants. At detachment time $t_d$, the state is reset to model a remnant (residual) mass sticking to the faucet neck and a relaxed, motionless initial condition for the next drop:\n$$\nx(t_d^+) = 0, \\quad v(t_d^+) = 0, \\quad m(t_d^+) = \\alpha\\,m(t_d^-),\n$$\nwhere $0  \\alpha  1$ is the residual-mass fraction and the superscripts $^-$ and $^+$ denote limits from before and after the event, respectively.\n\nYour tasks are:\n1) From Newton’s second law, justify the above ODE system and reset rule under the stated assumptions. Clarify how the variable mass enters the acceleration equation and why the chosen simplification is appropriate in this context.\n2) Design and implement a robust event-driven numerical integrator to:\n   - Integrate the ODE until the rupture event $x(t) - x_{\\mathrm{break}}(m(t)) = 0$ is detected with increasing $x$.\n   - Apply the reset rule and continue simulating to generate a long sequence of drip times.\n3) For each specified flow rate $q$, compute the inter-drip times $\\Delta t_n = t_{n} - t_{n-1}$. Discard an initial transient and then determine the number of distinct inter-drip times present within a tolerance, which is an integer diagnostic of the period-$k$ behavior (e.g., $k=1$ for period-1, $k=2$ for period-2 after a period-doubling, etc.). Use a tolerance that combines absolute and relative components to avoid false distinctions due to numerical noise.\n4) Use the following dimensionless parameters for the oscillator and rupture model, and specify the test suite of flow rates:\n   - Oscillator parameters: $\\kappa = 1.0$, $\\gamma = 0.05$, $g = 0.34$.\n   - Rupture parameters: $x_0 = 0.50$, $\\beta = 0.10$, $\\alpha = 0.30$.\n   - Initial conditions at the very start: $x(0) = 0$, $v(0) = 0$, $m(0) = 0.40$.\n   - Flow-rate test suite (four cases): $q \\in \\{\\,0.010,\\,0.025,\\,0.050,\\,0.080\\,\\}$.\n   - Integrate long enough to observe at least $N_{\\mathrm{total}} = 60$ drips per case, discarding the first $N_{\\mathrm{trans}} = 30$ as transient, and analyzing the next $N_{\\mathrm{keep}} = 30$ drips.\n   - Use a detection tolerance that clusters inter-drip times $\\Delta t$ into distinct groups using the rule “same group if $|\\Delta t_i - \\Delta t_j| \\le \\max(\\varepsilon_{\\mathrm{abs}}, \\varepsilon_{\\mathrm{rel}}\\cdot \\max(|\\Delta t_i|,|\\Delta t_j|))$” with $\\varepsilon_{\\mathrm{abs}}=10^{-3}$ and $\\varepsilon_{\\mathrm{rel}}=10^{-3}$.\n5) Your program must produce a single line of output containing the results as a comma-separated list of integers enclosed in square brackets (e.g., “[1,2,4,1]”), where each integer is the counted number of distinct inter-drip times for the corresponding flow rate in the order given above.\n\nThe problem must be solved in purely mathematical and algorithmic terms so that it is implementable in any programming language. All quantities above are dimensionless, so no physical unit conversion is required. Ensure scientific realism in parameters and discuss in your solution why the approach captures the period-doubling sequence. The final answers for each test case are integers that quantify the distinct inter-drip times found after transients.",
            "solution": "The problem presented is a valid exercise in computational physics. It is scientifically sound, well-posed, and all necessary parameters and conditions are specified. It represents a standard simplification of a complex physical phenomenon—the dripping faucet—into a non-autonomous system of ordinary differential equations with state resets, a model known to exhibit period-doubling bifurcations and chaos. We shall proceed with a rigorous derivation and algorithmic design.\n\nFirst, we must justify the governing equations from fundamental principles. The system described is a point mass whose mass $m(t)$ changes with time. Newton's second law for a body of variable mass is most generally stated as the rate of change of momentum $\\vec{p}$ being equal to the net external force $\\vec{F}_{\\mathrm{ext}}$, i.e., $\\vec{F}_{\\mathrm{ext}} = \\frac{d\\vec{p}}{dt}$. In our one-dimensional system, the momentum is $p(t) = m(t)v(t)$, where $v(t) = \\frac{dx}{dt}$ is the velocity. Applying the product rule for differentiation, we get:\n$$\n\\frac{dp}{dt} = \\frac{d(mv)}{dt} = m(t)\\frac{dv}{dt} + v(t)\\frac{dm}{dt} = m(t)a(t) + v(t)q\n$$\nwhere $a(t) = \\frac{dv}{dt}$ is the acceleration and $\\frac{dm}{dt} = q$ is the constant mass inflow rate. The term $v(t)q$ represents the force required to accelerate the incoming fluid (which is assumed to have zero initial vertical velocity) to the current velocity $v(t)$ of the drop. The problem statement directs us to use a common simplification where this \"jet-momentum\" term is neglected. This is a reasonable approximation if the velocity $v(t)$ is small or if the primary dynamics are dominated by other forces, which is often the case. Under this simplification, Newton's second law reduces to:\n$$\nm(t)a(t) \\approx F_{\\mathrm{ext}}\n$$\nThe external forces acting on the mass are gravity ($F_g = m(t)g$), the restoring force of a linear spring ($F_s = -\\kappa x$), and a linear viscous damping force ($F_d = -\\gamma v$). The spring constant is $\\kappa$, the damping coefficient is $\\gamma$, and $g$ is the acceleration due to gravity. The displacement $x$ is measured downwards from the faucet, so the gravitational force is positive. The sum of these forces is:\n$$\nF_{\\mathrm{ext}} = m(t)g - \\kappa x - \\gamma v\n$$\nEquating this with the simplified expression for the rate of change of momentum gives the equation of motion for the drop:\n$$\nm(t)\\frac{dv}{dt} = m(t)g - \\kappa x - \\gamma v\n$$\nDividing by the instantaneous mass $m(t)$ yields the acceleration:\n$$\n\\frac{dv}{dt} = g - \\frac{\\gamma}{m(t)}v - \\frac{\\kappa}{m(t)}x\n$$\nThis is precisely the equation provided. This equation, combined with the definitions $\\frac{dx}{dt} = v$ and $\\frac{dm}{dt} = q$, forms a system of three coupled, first-order, non-autonomous ordinary differential equations. The system is non-autonomous because the coefficients of $v$ and $x$ in the acceleration equation depend explicitly on time through the mass $m(t) = m(0) + qt$.\n\nThe simulation proceeds by integrating this system until a rupture event occurs. The condition for rupture is that the elongation $x(t)$ reaches a mass-dependent threshold $x_{\\mathrm{break}}(m) = x_0 - \\beta m$. The physical intuition is that as the drop gets heavier, surface tension is less able to support a large elongation. The event function is therefore $ G(t, x, m) = x(t) - x_{\\mathrm{break}}(m(t)) = 0$. We are interested in the event where $x(t)$ crosses this threshold from below, so we must detect a zero-crossing in the increasing direction.\n\nUpon detachment at a time $t_d$, the system state is reset. The new drop begins with zero displacement and velocity, $x(t_d^+) = 0$ and $v(t_d^+) = 0$. This is a simplification that assumes the remnant fluid settles instantly to a quiescent state. Crucially, not all mass detaches. A fraction $\\alpha$ of the drop's mass at rupture, $m(t_d^-)$, remains attached to the faucet: $m(t_d^+) = \\alpha m(t_d^-)$. This remnant mass $m(t_d^+)$ serves as the initial condition for the next drop and provides a \"memory\" between successive drip events. It is this memory, coupled with the nonlinear nature of the reset mechanism and the driving force of the mass influx, that allows the system to exhibit complex dynamics. The mass of the $n$-th drop at its formation, $m_n(0)$, depends on the mass of the $(n-1)$-th drop at its rupture, $m_{n-1}(t_{\\text{rupture}})$. This creates a mapping from one drip to the next, which for certain parameter regimes, such as the flow rate $q$, undergoes a period-doubling cascade, a hallmark of the route to chaos. For a low flow rate $q$, the system settles into a period-$1$ limit cycle, where each drop is identical and the time between drips is constant. As $q$ is increased, the system may bifurcate to a period-$2$ cycle, where inter-drip times (and drop sizes) alternate between two distinct values. Further increases in $q$ can lead to period-$4$, period-$8$, and eventually chaotic behavior where the inter-drip times appear random. Our task is to count these distinct inter-drip times for given values of $q$.\n\nThe algorithm is as follows:\n1.  Define a function for the system of ODEs: $\\frac{dY}{dt} = F(t, Y)$, where $Y = [x, v, m]^T$.\n2.  Define an event function for the rupture condition $x - (x_0 - \\beta m) = 0$. This function must be terminal and detect crossing from negative to positive values.\n3.  For each flow rate $q$ in the test suite:\n    a. Initialize the state vector $Y_0 = [0, 0, 0.40]^T$, current time $t_{\\mathrm{current}} = 0$, and a list to store drip times, `drip_times`.\n    b. Loop $N_{\\mathrm{total}} = 60$ times to collect data for $60$ drips.\n        i. Use a numerical ODE solver (such as `scipy.integrate.solve_ivp`) to integrate the system from $t_{\\mathrm{current}}$ with the current state, until the rupture event is triggered.\n        ii. Record the event time $t_{\\mathrm{event}}$. Add it to `drip_times`.\n        iii. Update the state vector according to the reset rules: $x_{\\mathrm{new}} = 0$, $v_{\\mathrm{new}} = 0$, $m_{\\mathrm{new}} = \\alpha \\cdot m_{\\mathrm{event}}$, where $m_{\\mathrm{event}}$ is the mass at the time of rupture. The new current time is $t_{\\mathrm{current}} = t_{\\mathrm{event}}$.\n    c. Compute the inter-drip times $\\Delta t_i = \\text{drip\\_times}[i] - \\text{drip\\_times}[i-1]$ for $i=1, \\dots, N_{\\mathrm{total}}-1$. We also need the first interval $\\text{drip\\_times}[0] - 0$. This yields $N_{\\mathrm{total}}$ intervals.\n    d. Discard the first $N_{\\mathrm{trans}} = 30$ intervals as transient dynamics.\n    e. Analyze the subsequent $N_{\\mathrm{keep}} = 30$ intervals. To count the number of distinct values, sort the intervals and iterate through the sorted list, counting groups of values that are close to each other based on the specified tolerance: $|\\Delta t_i - \\Delta t_j| \\le \\max(\\varepsilon_{\\mathrm{abs}}, \\varepsilon_{\\mathrm{rel}}\\cdot \\max(|\\Delta t_i|,|\\Delta t_j|))$. A simple way is to count how many times an element is significantly different from the previous one in the sorted list.\n    f. Record this count as the result for the given $q$.\n4.  Format the final list of counts as specified.\nThis robust, event-driven approach correctly models the physics and allows for the accurate determination of the system's periodic behavior.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Numerically models a dripping faucet to observe period-doubling.\n\n    The model treats a growing water drop as a damped, driven harmonic oscillator\n    with variable mass. The system is described by a non-autonomous ODE with\n    state resets upon drop detachment. This function simulates the dynamics for\n    a set of flow rates and determines the periodicity of the drip intervals.\n    \"\"\"\n\n    # Define physical and numerical parameters as per the problem statement.\n    # Oscillator parameters\n    kappa = 1.0  # Spring constant\n    gamma = 0.05 # Damping coefficient\n    g = 0.34     # Gravitational acceleration\n\n    # Rupture and reset parameters\n    x0 = 0.50    # Rupture threshold constant\n    beta = 0.10  # Rupture threshold mass dependency\n    alpha = 0.30 # Residual mass fraction\n\n    # Initial conditions for the very first drop\n    x_init = 0.0\n    v_init = 0.0\n    m_init = 0.40\n\n    # Simulation control\n    N_total = 60  # Total number of drips to simulate per case\n    N_trans = 30  # Number of transient drips to discard\n    \n    # Tolerance for clustering inter-drip times\n    eps_abs = 1e-3\n    eps_rel = 1e-3\n    \n    # Test suite of flow rates\n    test_cases = [0.010, 0.025, 0.050, 0.080]\n\n    results = []\n\n    # ODE system definition: dy/dt = f(t, y)\n    # y = [x, v, m]\n    def ode_system(t, y, q_val):\n        x, v, m = y\n        # Avoid division by zero if mass is ever zero, though m_init  0.\n        if m = 0:\n            return [0.0, 0.0, q_val]\n        \n        dxdt = v\n        dvdt = g - (gamma * v / m) - (kappa * x / m)\n        dmdt = q_val\n        return [dxdt, dvdt, dmdt]\n\n    # Event function: fires when x(t) = x_break(m(t))\n    # x_break(m) = x0 - beta * m\n    def rupture_event(t, y, q_val):\n        x, v, m = y\n        return x - (x0 - beta * m)\n    \n    rupture_event.terminal = True  # Stop integration at the event\n    rupture_event.direction = 1    # Event triggers when x is increasing\n\n    # Main loop over each flow rate\n    for q_flow in test_cases:\n        \n        # Initialize state for this test case\n        current_time = 0.0\n        y_current = np.array([x_init, v_init, m_init])\n        \n        drip_times = []\n\n        # Simulate N_total drips\n        for _ in range(N_total):\n            # Define a sufficiently long time span for the next drip\n            t_span = (current_time, current_time + 100.0)\n            \n            # Integrate until the next rupture event\n            sol = solve_ivp(\n                fun=lambda t, y: ode_system(t, y, q_flow),\n                t_span=t_span,\n                y0=y_current,\n                events=lambda t, y: rupture_event(t, y, q_flow),\n                dense_output=True,\n                max_step=0.1\n            )\n            \n            # Check if an event was found\n            if sol.t_events[0].size  0:\n                event_time = sol.t_events[0][0]\n                drip_times.append(event_time)\n                \n                # State at the moment of rupture\n                y_event = sol.sol(event_time)\n                m_rupture = y_event[2]\n                \n                # Apply reset rules\n                current_time = event_time\n                y_current = np.array([0.0, 0.0, alpha * m_rupture])\n            else:\n                # Should not happen with given parameters and t_span\n                # Break if no drip is found in the time window\n                break\n\n        # Analyze the collected drip times\n        if len(drip_times)  N_total:\n             # If simulation failed, append an error code (e.g., -1)\n             results.append(-1)\n             continue\n        \n        # Calculate inter-drip times\n        all_times = np.insert(np.array(drip_times), 0, 0.0)\n        inter_drip_times = np.diff(all_times)\n\n        # Discard transients and keep the part for analysis\n        analysis_times = inter_drip_times[N_trans:]\n\n        if len(analysis_times) == 0:\n            results.append(0)\n            continue\n        \n        # Cluster the inter-drip times to count distinct values\n        sorted_times = np.sort(analysis_times)\n        \n        num_distinct_times = 1\n        # The first time interval starts the first cluster\n        cluster_representative = sorted_times[0]\n        \n        for i in range(1, len(sorted_times)):\n            dt_current = sorted_times[i]\n            dt_prev = sorted_times[i-1]\n            \n            # Check if current time is \"far\" from previous one using the tolerance rule\n            tolerance = max(eps_abs, eps_rel * max(abs(dt_current), abs(dt_prev)))\n            if abs(dt_current - dt_prev)  tolerance:\n                num_distinct_times += 1\n        \n        results.append(num_distinct_times)\n\n    # Print the final result in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}