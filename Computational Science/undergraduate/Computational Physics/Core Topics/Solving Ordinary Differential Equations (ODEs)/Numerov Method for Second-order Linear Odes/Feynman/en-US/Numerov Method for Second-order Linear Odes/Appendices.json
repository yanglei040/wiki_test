{
    "hands_on_practices": [
        {
            "introduction": "The shape of a hanging chain, or catenary, is a classic problem in physics that offers a perfect entry point for applying the Numerov method. This exercise  first guides you through a clever analytical transformation to show that the catenary's governing equation can be expressed in the linear form $y''(x) = g(x)y(x)$, ideal for this numerical technique. By comparing your numerical solution to the known analytical form, you can directly verify your implementation and gain an intuitive understanding of the method's high accuracy.",
            "id": "2421976",
            "problem": "A uniform, perfectly flexible, inextensible chain of linear mass density $\\lambda$ hangs in a vertical gravitational field of magnitude $g$ and is in static equilibrium. Consider a Cartesian coordinate system with the horizontal axis $x$ and the vertical axis $y(x)$ describing the shape of the chain. Let the constant horizontal component of the tension be $T_0$, and define the parameter $a = T_0 / (\\lambda g)$, which has dimensions of length. From force balance and geometry, derive the governing equation for the curve:\n$$\na\\,y''(x) = \\sqrt{1 + \\left(y'(x)\\right)^2}.\n$$\nThen, by choosing the vertical origin so that the lowest point is at $x=0$ with $y(0)=a$ and $y'(0)=0$, transform this equation into a linear, homogeneous second-order ordinary differential equation that contains no first-derivative term and is therefore amenable to the Numerov method.\n\nNext, compute the shape numerically on the interval $x \\in [0, X]$ using the Numerov method for second-order linear ordinary differential equations without a first-derivative term. Use the initial conditions $y(0)=a$ and $y'(0)=0$, and initialize the second point using a Taylor expansion about $x=0$ up to and including the term of order $h^4$, where $h$ is the uniform grid spacing. Compare your numerical solution with the analytical reference solution implied by the derivation, $y(x) = a \\cosh(x/a)$, and report the maximum absolute error over the grid.\n\nYour program must implement the Numerov scheme from first principles and may not call any black-box ordinary differential equation solvers. All computations are dimensionless in the sense that no specific unit conversions are required; treat $x$ and $y$ consistently in the same length unit, and $a$ and $X$ are given in that same unit.\n\nTest suite:\n- Case $1$ (happy path): $a=2.0$, $X=1.0$, $h=0.01$.\n- Case $2$ (coarse grid boundary check): $a=2.0$, $X=1.0$, $h=0.2$.\n- Case $3$ (near-flat curve): $a=50.0$, $X=1.0$, $h=0.05$.\n- Case $4$ (steep curvature): $a=0.5$, $X=1.0$, $h=0.01$.\n\nFor each case, compute the maximum absolute error \n$$\nE = \\max_{0 \\le n \\le N} \\left| y_n - a \\cosh\\!\\left(\\frac{x_n}{a}\\right) \\right|,\n$$ \nwhere $x_n = n h$ and $N = X/h$ is an integer by construction in the cases provided.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each error rounded to $10$ decimal places (for example, $\\left[0.0000001234,0.0012345678,0.0,0.0\\right]$).",
            "solution": "We begin from fundamental statics. Let $T(x)$ denote the tension magnitude at position $x$, and let $\\theta(x)$ be the angle of the chain with the horizontal. The horizontal component $T_x = T(x)\\cos\\theta(x)$ is constant in static equilibrium, so $T_x = T_0$. The vertical component is $T_y = T(x)\\sin\\theta(x)$. Over a differential arc length $\\mathrm{d}s$, the vertical component of the internal force changes to balance the weight $\\lambda g\\,\\mathrm{d}s$ of the element:\n$$\n\\mathrm{d}T_y = \\lambda g\\,\\mathrm{d}s.\n$$\nUsing geometry, $\\tan\\theta = y'$, $\\cos\\theta = 1/\\sqrt{1+(y')^2}$, and $\\sin\\theta = y'/\\sqrt{1+(y')^2}$, and the relation $T \\cos\\theta = T_0$, we get $T = T_0 \\sqrt{1+(y')^2}$. Then\n$$\nT_y = T \\sin\\theta = T_0 \\sqrt{1+(y')^2} \\cdot \\frac{y'}{\\sqrt{1+(y')^2}} = T_0\\, y'.\n$$\nDifferentiating with respect to $x$ and using $\\mathrm{d}s = \\sqrt{1+(y')^2}\\,\\mathrm{d}x$ yields\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}x}\\left(T_y\\right) = T_0\\, y'' = \\lambda g \\sqrt{1+(y')^2}.\n$$\nDefining $a = \\dfrac{T_0}{\\lambda g}$, we obtain the nonlinear second-order ordinary differential equation\n$$\na\\, y'' = \\sqrt{1 + (y')^2}.\n$$\n\nTo render this equation integrable and connect it to a linear form suitable for the Numerov method, set $p(x) = y'(x)$. Then the equation reads\n$$\na \\frac{\\mathrm{d}p}{\\mathrm{d}x} = \\sqrt{1+p^2}.\n$$\nIntroduce the substitution $u(x) = \\operatorname{arsinh}(p) = \\ln\\!\\left(p + \\sqrt{1+p^2}\\right)$. Since $\\dfrac{\\mathrm{d}}{\\mathrm{d}p}\\operatorname{arsinh}(p) = \\dfrac{1}{\\sqrt{1+p^2}}$, we have\n$$\n\\frac{\\mathrm{d}u}{\\mathrm{d}x} = \\frac{1}{\\sqrt{1+p^2}} \\frac{\\mathrm{d}p}{\\mathrm{d}x} = \\frac{1}{a}.\n$$\nIntegrating gives $u(x) = \\dfrac{x-x_0}{a}$ for some constant $x_0$, hence\n$$\ny'(x) = p(x) = \\sinh\\!\\left(\\frac{x-x_0}{a}\\right).\n$$\nIntegrating once more,\n$$\ny(x) = a \\cosh\\!\\left(\\frac{x-x_0}{a}\\right) + C,\n$$\nwith constants determined by boundary conditions and the choice of vertical origin. If we require symmetry about $x=0$ with the lowest point at $x=0$ and choose the vertical origin so that $y(0)=a$ and $y'(0)=0$, then $x_0=0$ and $C=0$, yielding the canonical catenary form $y(x) = a \\cosh(x/a)$. For this choice, note that the second derivative is $y''(x) = \\frac{d}{dx}(\\sinh(x/a)) = \\frac{1}{a}\\cosh(x/a)$. Since $\\cosh(x/a) = y(x)/a$, this simplifies to $y''(x) = y(x)/a^2$. Thus, after an appropriate choice of vertical origin, the nonlinear governing equation is equivalent to the linear homogeneous equation\n$$\ny''(x) = g\\, y(x), \\quad \\text{with } g = \\frac{1}{a^2}.\n$$\nThis is a second-order linear ordinary differential equation without a first-derivative term, which is in the canonical form for the Numerov method.\n\nNumerov method derivation for $y''(x) = f(x) y(x)$:\nConsider a uniform grid $x_n = x_0 + n h$ with spacing $h$. Taylor expand $y_{n\\pm 1} = y(x_{n\\pm 1})$ about $x_n$:\n$$\ny_{n\\pm 1} = y_n \\pm h y'_n + \\frac{h^2}{2} y''_n \\pm \\frac{h^3}{6} y'''_n + \\frac{h^4}{24} y''''_n + \\mathcal{O}(h^5).\n$$\nAdd the expansions for $y_{n+1}$ and $y_{n-1}$ to eliminate odd derivatives:\n$$\ny_{n+1} + y_{n-1} = 2 y_n + h^2 y''_n + \\frac{h^4}{12} y''''_n + \\mathcal{O}(h^6).\n$$\nUsing $y'' = f y$ and approximating the fourth derivative term yields the Numerov recurrence. For an equation of the form $y''=f(x)y$, the recurrence can be written as:\n$$\n\\left(1 - \\frac{h^2}{12} f_{n+1}\\right) y_{n+1} = 2\\left(1 + \\frac{5h^2}{12} f_{n}\\right) y_{n} - \\left(1 - \\frac{h^2}{12} f_{n-1}\\right) y_{n-1} + \\mathcal{O}(h^6).\n$$\nwhere $f_n = f(x_n)$. In our application $f(x) = g = 1/a^2$ is constant, so $f_{n-1} = f_n = f_{n+1} = g$, and the recurrence simplifies to\n$$\n\\left(1 - \\frac{h^2 g}{12}\\right) y_{n+1}\n= 2\\left(1 + \\frac{5h^2 g}{12}\\right) y_{n} - \\left(1 - \\frac{h^2 g}{12}\\right) y_{n-1}.\n$$\nTo start the recurrence, we need $y_0$ and $y_1$. The initial condition is $y(0) = a$ and $y'(0) = 0$. Using a Taylor expansion at $x=0$ up to and including $\\mathcal{O}(h^4)$,\n$$\ny(h) = y(0) + h y'(0) + \\frac{h^2}{2} y''(0) + \\frac{h^3}{6} y'''(0) + \\frac{h^4}{24} y''''(0) + \\mathcal{O}(h^5).\n$$\nWith $y''(0) = g y(0) = g a$, $y'''(0) = g y'(0) = 0$, and $y''''(0) = g y''(0) = g^2 a$ (since $g$ is constant), we obtain\n$$\ny(h) = a + \\frac{h^2}{2} g a + \\frac{h^4}{24} g^2 a + \\mathcal{O}(h^5)\n= a \\left(1 + \\frac{h^2 g}{2} + \\frac{h^4 g^2}{24}\\right) + \\mathcal{O}(h^5).\n$$\nThus, set $y_0 = a$ and \n$$\ny_1 = a \\left(1 + \\frac{h^2 g}{2} + \\frac{h^4 g^2}{24}\\right).\n$$\n\nFor validation, we compare against the exact solution $y(x) = a \\cosh(x/a)$ and compute the maximum absolute error over the grid:\n$$\nE = \\max_{0 \\le n \\le N} \\left| y_n - a \\cosh\\!\\left(\\frac{x_n}{a}\\right) \\right|,\n\\quad x_n = n h, \\quad N = \\frac{X}{h}.\n$$\n\nTest suite and coverage:\n- Case $1$ tests the general, well-resolved scenario ($a=2.0$, $X=1.0$, $h=0.01$), where Numerov’s $\\mathcal{O}(h^6)$ accuracy should yield a very small error.\n- Case $2$ uses a coarse grid ($h=0.2$) to stress the scheme and observe decreased accuracy but continued stability.\n- Case $3$ explores small curvature ($a=50.0$), where $g = 1/a^2$ is small and the solution is nearly flat; this tests sensitivity to small $g$.\n- Case $4$ uses strong curvature ($a=0.5$), testing numerical stability for larger $g$ over the same span.\n\nThe program implements the Numerov recurrence specialized to constant $g$ with the fourth-order Taylor start and reports the list of $E$ values, each rounded to $10$ decimal places, in a single bracketed, comma-separated line as required.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef numerov_constant_g(g, a, X, h):\n    \"\"\"\n    Solve y'' = g * y on x in [0, X] with y(0)=a, y'(0)=0 using Numerov's method.\n    Initialize y(h) using a 4th-order Taylor expansion.\n    Return max absolute error vs exact y(x) = a cosh(x/a).\n    \"\"\"\n    # Number of steps, ensure integer\n    N = int(round(X / h))\n    X_effective = N * h  # Adjusted X to match grid if needed\n    x = np.linspace(0.0, X_effective, N + 1)\n\n    # Initial conditions\n    y = np.empty(N + 1, dtype=float)\n    y[0] = a\n    # Taylor-based start: y(h) = a*(1 + (h^2 g)/2 + (h^4 g^2)/24)\n    y1 = a * (1.0 + 0.5 * (h*h*g) + (h**4) * (g**2) / 24.0)\n    if N >= 1:\n        y[1] = y1\n\n    if N >= 2:\n        # Precompute coefficients for y'' = g*y. The recurrence is:\n        # y_{n+1} (1-h^2*g/12) = 2*y_n (1+5*h^2*g/12) - y_{n-1} (1-h^2*g/12)\n        # We use a rearranged form for direct computation, as implemented in the code:\n        # y_{n+1} = ( (2 + 10/12*h^2*g)*y_n + (-1 + h^2*g/12)*y_{n-1} ) / (1-h^2*g/12)\n        c_denom = 1.0 - (h*h*g)/12.0\n        c_y_n = 2.0 * (1.0 + 5.0 * h*h*g / 12.0)\n        c_y_nm1 = -(1.0 - h*h*g / 12.0)\n\n        for n in range(1, N):\n            y[n+1] = (c_y_n * y[n] + c_y_nm1 * y[n-1]) / c_denom\n\n    # Exact solution for comparison: y(x) = a cosh(x/a)\n    y_exact = a * np.cosh(x / a)\n    err = np.max(np.abs(y - y_exact))\n    return err\n\ndef solve():\n    # Define the test cases from the problem statement: (a, X, h)\n    test_cases = [\n        (2.0, 1.0, 0.01),   # Case 1: happy path\n        (2.0, 1.0, 0.2),    # Case 2: coarse grid\n        (50.0, 1.0, 0.05),  # Case 3: near-flat curve\n        (0.5, 1.0, 0.01),   # Case 4: steep curvature\n    ]\n\n    results = []\n    for a, X, h in test_cases:\n        g = 1.0 / (a * a)\n        err = numerov_constant_g(g, a, X, h)\n        # Round to 10 decimal places for output formatting\n        results.append(err)\n\n    # Final print statement in the exact required format: bracketed, comma-separated, 10 decimals\n    formatted = \"[\" + \",\".join(f\"{val:.10f}\" for val in results) + \"]\"\n    print(formatted)\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "Having established a working Numerov solver, we now apply it to a cornerstone of quantum mechanics: finding the energy eigenvalues of a confined particle. This exercise  introduces the powerful shooting method, where the Numerov algorithm is used to solve the Schrödinger equation for a particle in a box as an initial value problem, and a root-finding algorithm locates the specific energies that satisfy the boundary conditions. This practice demonstrates how to extract fundamental quantum properties, such as the density of states and quantum capacitance, directly from numerical solutions.",
            "id": "2421997",
            "problem": "A one-dimensional quantum nanowire of length $L$ is modeled by a particle of mass $m$ confined in a box with perfectly hard walls at $x=0$ and $x=L$. The potential energy function is $V(x)=0$ for $0xL$ and $V(x)=+\\infty$ elsewhere. Consider the time-independent Schrödinger equation\n$$-\\frac{\\hbar^2}{2m}\\frac{d^2\\psi(x)}{dx^2}+V(x)\\psi(x)=E\\,\\psi(x),$$\nsubject to the boundary conditions $\\psi(0)=0$ and $\\psi(L)=0$. You will compute the Lorentzian-broadened density of states and the quantum capacitance per unit length as a function of the chemical potential at zero temperature by numerically finding the eigenenergies with the Numerov method.\n\nFundamental basis to use:\n- The time-independent Schrödinger equation written as \n$$\\psi''(x)=\\frac{2m}{\\hbar^2}\\left[V(x)-E\\right]\\psi(x),$$\nwith boundary conditions $\\psi(0)=0$ and $\\psi(L)=0$ for a particle in an infinite potential well.\n- The definition of the density of states (DoS) for a discrete spectrum broadened into a continuous function via a Lorentzian representation of the Dirac delta function. With a small positive broadening half-width $\\Gamma$, use\n$$\\delta(E-E_n)\\approx \\frac{1}{\\pi}\\frac{\\Gamma}{(E-E_n)^2+\\Gamma^2}.$$\n- The definition of quantum capacitance (per unit length) at zero temperature as the derivative of linear charge density with respect to the chemical potential $\\mu$,\n$$\\frac{C_Q}{L}=e^2 \\frac{\\partial n}{\\partial \\mu}=e^2 D(\\mu),$$\nwhere $D(E)$ is the density of states per unit length at energy $E$ and $e$ is the elementary charge.\n\nYour tasks:\n1) Starting from the Schrödinger equation in the form $\\psi''(x)=S\\,\\psi(x)$, with $S(x)=\\frac{2m}{\\hbar^2}\\left[V(x)-E\\right]$, derive a Numerov-type algorithm appropriate for a second-order linear ordinary differential equation of this form, ensuring local truncation error of order $h^6$ in the step size $h$. Implement a shooting method that integrates from $x=0$ to $x=L$ and enforces $\\psi(0)=0$ with an arbitrary small nonzero $\\psi(h)$, then locates energies $E$ where the boundary value $\\psi(L)$ vanishes. Use a robust root-bracketing and refinement strategy to identify all bound-state energies $E_n$ up to a specified energy ceiling.\n2) Using the bound-state energies $\\{E_n\\}$, construct the Lorentzian-broadened density of states per unit length with spin degeneracy factor $g_s=2$,\n$$D(E)=\\frac{g_s}{L}\\sum_n \\frac{1}{\\pi}\\frac{\\Gamma}{(E-E_n)^2+\\Gamma^2}.$$\n3) Compute the zero-temperature quantum capacitance per unit length via\n$$\\frac{C_Q}{L}=e^2 D(\\mu).$$\n\nImportant implementation and unit requirements:\n- Use the following constants: $m=m_e$ (free-electron mass), $\\hbar$ as the reduced Planck constant, and $e$ as the elementary charge, all in the International System of Units (SI).\n- All internal energies in your computation must be in joules; if parameters are given in electronvolts (eV) or millielectronvolts (meV), convert them to joules using $1\\,\\mathrm{eV}=e\\,\\mathrm{J}$.\n- Express the final quantum capacitance per unit length in farads per meter (F/m), and round each reported value to six digits in scientific notation.\n- You must implement the eigenenergy search using the Numerov method for the boundary value $\\psi(L)$ combined with a bracketing plus bisection (or equivalent monotone) root finder. Do not use closed-form eigenenergies in your code.\n\nTest suite:\nFor each parameter triple $(L,\\Gamma,\\mu)$, compute $\\frac{C_Q}{L}$ in $\\mathrm{F/m}$ to the required precision. The length $L$ is given in meters, the broadening half-width $\\Gamma$ is given in millielectronvolts (meV), and the chemical potential $\\mu$ is given in electronvolts (eV). Use $g_s=2$.\n\n- Case 1 (happy path, below first level): $(L, \\Gamma, \\mu)=(1.0\\times 10^{-8}, 2.0, 0.020)$.\n- Case 2 (near a resonance): $(L, \\Gamma, \\mu)=(1.0\\times 10^{-8}, 2.0, 0.0235)$.\n- Case 3 (several subbands contributing): $(L, \\Gamma, \\mu)=(1.0\\times 10^{-8}, 2.0, 0.100)$.\n- Case 4 (shorter wire, higher first level): $(L, \\Gamma, \\mu)=(5.0\\times 10^{-9}, 2.0, 0.050)$.\n- Case 5 (longer wire, smaller broadening): $(L, \\Gamma, \\mu)=(2.0\\times 10^{-8}, 1.0, 0.010)$.\n\nFinal output format:\nYour program should produce a single line of output containing the five results as a comma-separated list enclosed in square brackets and formatted in scientific notation with exactly six digits after the decimal point (for example, \"[1.234567e-08,2.345678e-07,3.456789e-06,4.567890e-05,5.678901e-04]\").",
            "solution": "The problem posed is a standard exercise in computational quantum physics, requiring the determination of eigenenergies for the time-independent Schrödinger equation and the subsequent calculation of the density of states and quantum capacitance. The problem is well-defined, scientifically sound, and internally consistent. We shall proceed with a rigorous solution.\n\nThe problem centers on the one-dimensional time-independent Schrödinger equation (TISE) for a particle of mass $m$ in a region of length $L$ with zero potential, confined by infinite potential walls. The equation is given by:\n$$\n\\psi''(x) + \\frac{2m}{\\hbar^2}(E - V(x))\\psi(x) = 0\n$$\nsubject to the boundary conditions $\\psi(0) = 0$ and $\\psi(L) = 0$. Inside the nanowire, from $x=0$ to $x=L$, the potential $V(x)=0$. The equation simplifies to the form of a harmonic oscillator equation:\n$$\n\\psi''(x) + k^2\\psi(x) = 0\n$$\nwhere $k^2 = \\frac{2mE}{\\hbar^2}$. The problem requests a numerical solution using the Numerov method, which is specifically designed for second-order ordinary differential equations (ODEs) of this form, lacking a first-derivative term.\n\nFirst, we derive the Numerov recurrence relation. The standard method yields a local truncation error of order $\\mathcal{O}(h^6)$, as requested. We begin with the Taylor series expansions of the wavefunction $\\psi(x)$ around a grid point $x_i$:\n$$\n\\psi(x_i \\pm h) = \\psi_i \\pm h\\psi'_i + \\frac{h^2}{2!}\\psi''_i \\pm \\frac{h^3}{3!}\\psi'''_i + \\frac{h^4}{4!}\\psi^{(4)}_i \\pm \\frac{h^5}{5!}\\psi^{(5)}_i + \\mathcal{O}(h^6)\n$$\nSumming the expansions for $\\psi(x_i+h)$ and $\\psi(x_i-h)$ eliminates the odd-derivative terms:\n$$\n\\psi_{i+1} + \\psi_{i-1} = 2\\psi_i + h^2\\psi''_i + \\frac{h^4}{12}\\psi^{(4)}_i + \\mathcal{O}(h^6)\n$$\nWe can obtain an expression for $\\psi^{(4)}_i$ by differentiating the original ODE twice: $\\psi^{(4)}(x) = \\frac{d^2}{dx^2}(-k^2(x)\\psi(x))$. Approximating this second derivative with the finite difference operator gives:\n$$\n\\psi^{(4)}_i \\approx \\frac{1}{h^2}( (k^2\\psi)_{i+1} - 2(k^2\\psi)_i + (k^2\\psi)_{i-1} )\n$$\nSubstituting this into the summed Taylor expansion and rearranging terms yields the Numerov recurrence relation:\n$$\n\\psi_{i+1}\\left(1 + \\frac{h^2}{12}k_{i+1}^2\\right) = 2\\psi_i\\left(1 - \\frac{5h^2}{12}k_i^2\\right) - \\psi_{i-1}\\left(1 + \\frac{h^2}{12}k_{i-1}^2\\right)\n$$\nFor the specific case of the infinite potential well, $V(x)=0$ and the energy $E$ is constant for a given trial, making $k^2 = \\frac{2mE}{\\hbar^2}$ constant across the grid inside the well. Let us denote this constant $k_E^2$. The recurrence simplifies to:\n$$\n\\psi_{i+1}\\left(1 + \\frac{h^2}{12}k_E^2\\right) = \\psi_i\\left(2 - \\frac{10h^2}{12}k_E^2\\right) - \\psi_{i-1}\\left(1 + \\frac{h^2}{12}k_E^2\\right)\n$$\nThis relation allows us to compute $\\psi_{i+1}$ given the two preceding values, $\\psi_i$ and $\\psi_{i-1}$.\n\nTo find the eigenenergies, we employ the shooting method. This method transforms the boundary value problem into an initial value problem. We enforce the first boundary condition, $\\psi(0)=0$, and choose a small, arbitrary non-zero value for the wavefunction at the first step, for instance $\\psi(h) = \\text{const}$, because the linearity of the Schrödinger equation means the solution's normalization is arbitrary until determined. For a given trial energy $E$, we integrate the wavefunction from $x=0$ to $x=L$ using the Numerov recurrence. The second boundary condition, $\\psi(L)=0$, will only be satisfied for specific discrete values of $E$, which are the sought-after eigenenergies.\nWe define a function $\\Phi(E) = \\psi(L; E)$, which represents the value of the numerically computed wavefunction at $x=L$ for a given energy $E$. The eigenenergies are the roots of this function, i.e., $E_n$ such that $\\Phi(E_n) = 0$.\n\nTo find these roots, a robust two-stage process is implemented. First, we bracket the roots by scanning an appropriate energy range $[E_{min}, E_{max}]$ with a small step $\\Delta E$. A root is considered bracketed within an interval $[E_j, E_{j+1}]$ if $\\Phi(E_j) \\cdot \\Phi(E_{j+1})  0$. Second, once a root is bracketed, its precise value is found using the bisection method. This iterative method repeatedly halves the interval while ensuring the root remains within the new, smaller interval, until the interval's width is less than a prescribed tolerance.\n\nAfter computing the set of eigenenergies $\\{E_n\\}$ up to a specified energy ceiling (chosen to be sufficiently larger than the largest chemical potential in the test cases), we compute the Lorentzian-broadened density of states (DoS) per unit length, $D(E)$. Including a spin degeneracy factor of $g_s=2$, the DoS at an energy $E$ is given by:\n$$\nD(E) = \\frac{g_s}{L} \\sum_{n} \\frac{1}{\\pi} \\frac{\\Gamma}{(E - E_n)^2 + \\Gamma^2}\n$$\nwhere $\\Gamma$ is the broadening half-width.\n\nFinally, the quantum capacitance per unit length, $C_Q/L$, at zero temperature is directly proportional to the density of states at the chemical potential, $\\mu$. The relationship is:\n$$\n\\frac{C_Q}{L} = e^2 D(\\mu)\n$$\nwhere $e$ is the elementary charge. We compute this value for each test case using the numerically determined eigenenergies and the provided parameters. All physical constants are taken in SI units, and energy parameters provided in eV or meV are converted to joules for internal computation. The final result for $C_Q/L$ is expressed in farads per meter (F/m).",
            "answer": "```python\nimport numpy as np\nfrom scipy.constants import hbar, m_e, e\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n\n    # Physical constants in SI units\n    # hbar: Reduced Planck constant (J.s)\n    # m_e: Electron mass (kg)\n    # e: Elementary charge (C)\n\n    def solve_bvp_numerov(energy_J, L, N_grid, m):\n        \"\"\"\n        Solves the Schrodinger equation for a given energy E using the Numerov method.\n        Returns the wavefunction value at x=L.\n\n        Args:\n            energy_J (float): Trial energy in Joules.\n            L (float): Length of the nanowire in meters.\n            N_grid (int): Number of grid points for discretization.\n            m (float): Mass of the particle in kg.\n\n        Returns:\n            float: Value of psi at x=L.\n        \"\"\"\n        if energy_J = 0:\n            return 0.0\n\n        h = L / N_grid\n        k2 = (2.0 * m * energy_J) / (hbar**2)\n        \n        # Numerov method coefficients for constant k^2\n        h2_k2_12 = h**2 * k2 / 12.0\n        c1 = 1.0 + h2_k2_12\n        c2 = 2.0 * (1.0 - 5.0 * h2_k2_12)\n        \n        # Initial conditions: psi(0) = 0, psi(h) = small constant\n        psi_prev = 0.0\n        psi_curr = 1e-5\n        \n        for _ in range(1, N_grid):\n            psi_next = (c2 * psi_curr - c1 * psi_prev) / c1\n            psi_prev, psi_curr = psi_curr, psi_next\n            \n        return psi_curr\n\n    def bisection(func, a, b, tol=1e-10):\n        \"\"\"\n        Finds a root of func in the interval [a, b] using the bisection method.\n        'tol' is relative to the size of the interval.\n        \"\"\"\n        fa, fb = func(a), func(b)\n        if fa * fb >= 0:\n            return None  # No root or multiple roots in the interval\n\n        while (b - a) / (abs(a) + abs(b)) > tol:\n            c = (a + b) / 2.0\n            fc = func(c)\n            if fc == 0.0:\n                return c\n            if fa * fc  0:\n                b, fb = c, fc\n            else:\n                a, fa = c, fc\n        return (a + b) / 2.0\n\n    def find_eigenenergies(L, m, E_max_J, N_grid, N_scan_steps=2000):\n        \"\"\"\n        Finds all eigenenergies up to E_max_J by scanning and using bisection.\n        \n        Args:\n            L (float): Length of the nanowire in meters.\n            m (float): Mass of the particle in kg.\n            E_max_J (float): Maximum energy to scan for eigenvalues, in Joules.\n            N_grid (int): Number of grid points for Numerov.\n            N_scan_steps (int): Number of steps for the initial energy scan.\n\n        Returns:\n            list: A list of eigenenergies in Joules.\n        \"\"\"\n        energies = []\n        target_func = lambda E: solve_bvp_numerov(E, L, N_grid, m)\n\n        E_scan = np.linspace(1e-24, E_max_J, N_scan_steps) # Start slightly above zero\n        psi_L_prev = target_func(E_scan[0])\n        \n        for i in range(1, len(E_scan)):\n            E_curr = E_scan[i]\n            psi_L_curr = target_func(E_curr)\n            \n            if psi_L_prev * psi_L_curr  0:\n                E_prev = E_scan[i-1]\n                root = bisection(target_func, E_prev, E_curr)\n                if root is not None:\n                    energies.append(root)\n            \n            psi_L_prev = psi_L_curr\n            \n        return energies\n\n    def compute_cq_per_l(mu_J, Gamma_J, L, eigenenergies):\n        \"\"\"\n        Computes the quantum capacitance per unit length.\n\n        Args:\n            mu_J (float): Chemical potential in Joules.\n            Gamma_J (float): Broadening half-width in Joules.\n            L (float): Length of the nanowire in meters.\n            eigenenergies (list): List of eigenenergies in Joules.\n\n        Returns:\n            float: Quantum capacitance per unit length in F/m.\n        \"\"\"\n        g_s = 2.0  # Spin degeneracy\n        \n        dos_sum = 0.0\n        for En in eigenenergies:\n            lorentzian = (1.0 / np.pi) * (Gamma_J / ((mu_J - En)**2 + Gamma_J**2))\n            dos_sum += lorentzian\n            \n        dos_per_length = (g_s / L) * dos_sum\n        \n        # C_Q/L = e^2 * D(mu), with D(mu) being per unit length and energy.\n        # D(mu) is in units of (J^-1 m^-1)\n        # e^2 is in C^2. C^2 / J is Farad. So result is F/m.\n        cq_per_l = e**2 * dos_per_length\n        return cq_per_l\n\n    # Test suite from the problem statement\n    test_cases = [\n        (1.0e-8, 2.0, 0.020),  # Case 1\n        (1.0e-8, 2.0, 0.0235), # Case 2\n        (1.0e-8, 2.0, 0.100),  # Case 3\n        (5.0e-9, 2.0, 0.050),  # Case 4\n        (2.0e-8, 1.0, 0.010),  # Case 5\n    ]\n    \n    # Parameters for the numerical solution\n    N_GRID_POINTS = 1000\n    # Set energy ceiling high enough for all test cases\n    E_CEILING_EV = 0.5 \n    E_CEILING_J = E_CEILING_EV * e\n\n    results = []\n    \n    # Run simulation for each test case\n    for case in test_cases:\n        L_m, Gamma_meV, mu_eV = case\n        \n        # Convert parameters to SI units (Joules)\n        Gamma_J = Gamma_meV * 1e-3 * e\n        mu_J = mu_eV * e\n        \n        # 1. Find the eigenenergies\n        eigenenergies = find_eigenenergies(L_m, m_e, E_CEILING_J, N_GRID_POINTS)\n        \n        # 2. Compute quantum capacitance per unit length\n        result = compute_cq_per_l(mu_J, Gamma_J, L_m, eigenenergies)\n        results.append(result)\n\n    # Format the final output as specified\n    print(f\"[{','.join(['{:.6e}'.format(r) for r in results])}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Our final practice demonstrates how the Numerov method serves as a powerful tool for research and exploration into complex phenomena that defy analytical solution. This exercise  delves into the concept of Anderson localization by simulating a quantum particle moving through a one-dimensional random potential. You will implement the solver to map the particle's wavefunction and then use quantitative measures like the inverse participation ratio to distinguish between extended and localized states, gaining insight into a key principle of condensed matter physics.",
            "id": "2422024",
            "problem": "Consider the time-independent one-dimensional Schrödinger equation (a second-order ordinary differential equation (ODE)) for a particle moving in a random potential on a finite interval:\n$$\n\\psi''(x) + k(x)\\,\\psi(x) = 0,\n$$\nwhere \n$$\nk(x) = \\frac{2m}{\\hbar^2}\\left(E - V(x)\\right).\n$$\nUse dimensionless units with reduced Planck constant set to $\\,\\hbar = 1\\,$ and mass set to $\\,m = \\tfrac{1}{2}\\,$ so that $\\,\\tfrac{2m}{\\hbar^2} = 1\\,$ and hence $\\,k(x) = E - V(x)\\,$. The potential $\\,V(x)\\,$ is piecewise-constant on a uniform grid and is defined at the grid points $\\,x_i = i\\,h\\,$ for $\\,i = 0,1,\\dots,M\\,$, with $\\,h = L/M\\,$ and $\\,L > 0\\,$. For a given disorder strength $\\,W \\ge 0\\,$ and a given integer pseudorandom seed $\\,s\\,$, the values $\\,V_i = V(x_i)\\,$ are independently drawn from a uniform distribution on the interval $\\,[-W/2,\\,W/2]\\,$ using a pseudorandom number generator initialized with the seed $\\,s\\,$. Impose the initial conditions\n$$\n\\psi(0) = 0,\\quad \\psi'(0) = 1,\n$$\nwhich determine a unique solution for any given $\\,E\\,$ and realization of $\\,V(x)\\,$. After computing the discrete solution $\\,\\{\\psi_i\\}_{i=0}^{M}\\,$ on the grid, normalize it to obtain $\\,\\tilde{\\psi}_i = \\psi_i \\big/ \\sqrt{\\sum_{j=0}^{M} \\psi_j^2}\\,$. Using this normalized discrete wavefunction, compute the following two dimensionless diagnostics that quantify localization:\n1. The inverse participation ratio,\n$$\n\\mathrm{IPR} = \\sum_{i=0}^{M} \\tilde{\\psi}_i^4,\n$$\n2. The right-tail norm fraction,\n$$\nT = \\sum_{i=\\lfloor 0.9\\,M \\rfloor}^{M} \\tilde{\\psi}_i^2.\n$$\nAll quantities are dimensionless in these units.\n\nYour task is to write a complete program that, for each test case below, constructs the random potential as specified, solves for $\\,\\psi(x)\\,$ on $[0,L]$ using the given initial conditions, normalizes the result, and outputs the pair of floats $\\,(\\mathrm{IPR}, T)\\,$.\n\nUse the following test suite. Each test case is a tuple $\\,\\left(L,\\,M,\\,W,\\,E,\\,s\\right)\\,$ where $\\,L\\,$ is the interval length, $\\,M\\,$ is the number of uniform steps, $\\,W\\,$ is the disorder strength, $\\,E\\,$ is the energy, and $\\,s\\,$ is the integer seed:\n- Test case $\\,1\\,$: $\\,\\left(200.0,\\,4000,\\,0.0,\\,1.0,\\,123\\right)\\,$\n- Test case $\\,2\\,$: $\\,\\left(200.0,\\,4000,\\,1.0,\\,1.0,\\,456\\right)\\,$\n- Test case $\\,3\\,$: $\\,\\left(200.0,\\,4000,\\,4.0,\\,1.0,\\,789\\right)\\,$\n- Test case $\\,4\\,$: $\\,\\left(200.0,\\,4000,\\,2.0,\\,{-0.5},\\,321\\right)\\,$\n\nYour program must produce a single line of output containing the results aggregated across all test cases in order, as a comma-separated list enclosed in square brackets. For each test case, output the two floats $\\,\\mathrm{IPR}\\,$ and $\\,T\\,$ in that order. The final format must therefore be\n$$\n\\big[\\mathrm{IPR}_1,\\,T_1,\\,\\mathrm{IPR}_2,\\,T_2,\\,\\mathrm{IPR}_3,\\,T_3,\\,\\mathrm{IPR}_4,\\,T_4\\big].\n$$",
            "solution": "The starting point is the time-independent one-dimensional Schrödinger equation,\n$$\n\\psi''(x) + k(x)\\,\\psi(x) = 0,\\quad k(x) = \\frac{2m}{\\hbar^2}\\left(E - V(x)\\right).\n$$\nIn the specified dimensionless units, one sets $\\,\\hbar = 1\\,$ and $\\,m = \\tfrac{1}{2}\\,$, so that $\\,\\tfrac{2m}{\\hbar^2} = 1\\,$ and the equation simplifies to\n$$\n\\psi''(x) + \\big(E - V(x)\\big)\\,\\psi(x) = 0.\n$$\nOn a uniform grid $\\,x_i = i\\,h\\,$ for $\\,i = 0,1,\\dots,M\\,$ with $\\,h = L/M\\,$, define $\\,k_i = E - V_i\\,$, where $\\,V_i\\,$ are independently sampled from the uniform distribution on $\\,[-W/2,\\,W/2]\\,$, using a pseudorandom number generator initialized with the given seed for each test case. The initial conditions $\\,\\psi(0) = 0\\,$ and $\\,\\psi'(0) = 1\\,$ specify a unique solution of the ODE. To initialize a two-step recurrence on the grid, a Taylor expansion at $\\,x = 0\\,$ gives\n$$\n\\psi(h) = \\psi(0) + h\\,\\psi'(0) + \\frac{h^2}{2}\\,\\psi''(0) + \\mathcal{O}(h^3).\n$$\nSince $\\,\\psi''(0) = -k_0\\,\\psi(0) = 0\\,$, one obtains the leading-order accurate starting value\n$$\n\\psi_0 = 0,\\qquad \\psi_1 = h.\n$$\nFor second-order linear ODEs of the form $\\,\\psi''(x) + k(x)\\,\\psi(x) = 0\\,$, a high-accuracy three-point integration scheme is given by the Numerov method. On a uniform grid it reads\n$$\n\\psi_{i+1} = \\frac{2\\,\\psi_i\\,\\Big(1 - \\frac{h^2}{12}\\,5\\,k_i\\Big) - \\psi_{i-1}\\,\\Big(1 + \\frac{h^2}{12}\\,k_{i-1}\\Big)}{1 + \\frac{h^2}{12}\\,k_{i+1}},\\quad i = 1,2,\\dots,M-1,\n$$\nwhich is algebraically equivalent to the standard Numerov update\n$$\n\\left(1 + \\frac{h^2}{12}\\,k_{i+1}\\right)\\psi_{i+1} = 2\\left(1 - \\frac{5h^2}{12}\\,k_i\\right)\\psi_i - \\left(1 + \\frac{h^2}{12}\\,k_{i-1}\\right)\\psi_{i-1}.\n$$\nThis scheme is consistent with the ODE and attains a local truncation error of order $\\,\\mathcal{O}(h^6)\\,$ for sufficiently smooth $\\,k(x)\\,$. In the present setting, $\\,k(x)\\,$ is piecewise constant on the grid, which maintains the high-order accuracy as $\\,h \\to 0\\,$.\n\nDuring forward integration from $\\,i=1\\,$ to $\\,i=M-1\\,$, the amplitude $\\,\\psi_i\\,$ can grow or decay exponentially depending on the sign and spatial variation of $\\,k_i\\,$. To avoid numerical overflow or underflow while preserving the shape of the solution, one can rescale the partially computed sequence $\\{\\psi_j\\}_{j\\le i}$ by a large factor when its magnitude exceeds a preselected threshold. This rescaling does not affect the normalized wavefunction or any dimensionless diagnostic computed from it.\n\nAfter computing $\\,\\{\\psi_i\\}_{i=0}^{M}\\,$, normalize the discrete wavefunction by\n$$\n\\tilde{\\psi}_i = \\frac{\\psi_i}{\\sqrt{\\sum_{j=0}^{M} \\psi_j^2}},\n$$\nwhich is consistent with the continuous $\\,L^2\\,$ normalization since the uniform grid factor cancels in ratios such as the inverse participation ratio. The inverse participation ratio is then\n$$\n\\mathrm{IPR} = \\sum_{i=0}^{M} \\tilde{\\psi}_i^4,\n$$\nand the right-tail norm fraction, measuring the weight of the wavefunction in the last $\\,10\\%\\,$ of the domain, is\n$$\nT = \\sum_{i=\\lfloor 0.9\\,M \\rfloor}^{M} \\tilde{\\psi}_i^2.\n$$\nBoth $\\,\\mathrm{IPR}\\,$ and $\\,T\\,$ are dimensionless. For an extended state spread over the entire interval, one expects $\\,\\mathrm{IPR}\\,$ to be small (scaling like $\\,1/M\\,$) and $\\,T\\,$ to be close to $\\,0.1\\,$, while for a localized state, $\\,\\mathrm{IPR}\\,$ is larger and $\\,T\\,$ strongly depends on the localization center relative to the right boundary.\n\nThe test suite exercises several regimes: with $\\,W = 0\\,$ and $\\,E = 1\\,$, the solution in free space is oscillatory and extended; with $\\,W = 1\\,$ and $\\,W = 4\\,$ at fixed $\\,E = 1\\,$, increasing disorder promotes localization; with $\\,E = -0.5\\,$ and moderate disorder $\\,W = 2\\,$, the solution exhibits evanescent behavior, concentrating toward the right boundary under the given initial conditions. The program implements the described construction, integration, normalization, and diagnostic computation for each test case, and outputs the results in the prescribed single-line list format.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef numerov_solve_ipr_tail(L, M, W, E, seed):\n    \"\"\"\n    Solve psi''(x) + (E - V(x)) psi(x) = 0 on [0, L] with psi(0)=0, psi'(0)=1\n    using a uniform grid of M steps (M+1 points), random piecewise-constant V,\n    and return (IPR, T) where T is the right-tail norm fraction.\n    \"\"\"\n    # Grid setup\n    N = M  # number of steps\n    h = L / N\n    # Random potential at grid nodes: V_i ~ U[-W/2, W/2]\n    rng = np.random.default_rng(seed)\n    if W == 0.0:\n        V = np.zeros(N + 1, dtype=np.float64)\n    else:\n        V = rng.uniform(-W / 2.0, W / 2.0, size=N + 1).astype(np.float64)\n    k = (E - V).astype(np.float64)\n\n    # Allocate solution array\n    psi = np.empty(N + 1, dtype=np.float64)\n\n    # Initial conditions: psi(0)=0, psi'(0)=1 -> psi(h) ~ h (since psi''(0)=0)\n    psi[0] = 0.0\n    psi[1] = h\n\n    h2 = h * h\n    # Safety parameters for rescaling to avoid overflow\n    rescale_threshold = 1e100\n    rescale_factor = 1e50\n\n    # Numerov integration\n    # (1 + h^2 k_{i+1}/12) psi_{i+1} = 2(1 - 5 h^2 k_i/12) psi_i - (1 + h^2 k_{i-1}/12) psi_{i-1}\n    for i in range(1, N):\n        kim1 = k[i - 1]\n        ki = k[i]\n        kip1 = k[i + 1] if i + 1 = N else k[i]  # safe guard, though loop stops at i=N-1\n\n        denom = 1.0 + (h2 * kip1) / 12.0\n        num = 2.0 * (1.0 - (5.0 * h2 * ki) / 12.0) * psi[i] - (1.0 + (h2 * kim1) / 12.0) * psi[i - 1]\n\n        psi[i + 1] = num / denom\n\n        # Rescale to avoid overflow; scaling entire prefix preserves shape\n        if not np.isfinite(psi[i + 1]) or abs(psi[i + 1]) > rescale_threshold or abs(psi[i]) > rescale_threshold:\n            psi[: i + 2] /= rescale_factor\n\n    # Normalize\n    norm2 = float(np.dot(psi, psi))\n    if norm2 == 0.0 or not np.isfinite(norm2):\n        # Fallback in pathological cases\n        return float('nan'), float('nan')\n    psi /= np.sqrt(norm2)\n\n    # Inverse Participation Ratio (IPR)\n    ipr = float(np.sum(psi * psi * psi * psi))\n    # Right-tail norm fraction: last 10% of the grid\n    tail_start = int(np.floor(0.9 * N))\n    tail = float(np.sum(psi[tail_start:] * psi[tail_start:]))\n\n    return ipr, tail\n\ndef solve():\n    # Define the test cases from the problem statement: (L, M, W, E, seed)\n    test_cases = [\n        (200.0, 4000, 0.0, 1.0, 123),\n        (200.0, 4000, 1.0, 1.0, 456),\n        (200.0, 4000, 4.0, 1.0, 789),\n        (200.0, 4000, 2.0, -0.5, 321),\n    ]\n\n    results = []\n    for case in test_cases:\n        L, M, W, E, seed = case\n        ipr, tail = numerov_solve_ipr_tail(L, M, W, E, seed)\n        results.append(ipr)\n        results.append(tail)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}