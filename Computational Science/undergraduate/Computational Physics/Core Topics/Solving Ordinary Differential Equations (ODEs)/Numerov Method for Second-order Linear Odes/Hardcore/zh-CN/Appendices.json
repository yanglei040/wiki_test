{
    "hands_on_practices": [
        {
            "introduction": "Numerov 方法的强大之处在于其不仅限于量子力学的深奥领域，它同样适用于形式为 $y''(x) = g(x)y(x)$ 的任何二阶常微分方程。悬链线问题是一个绝佳的经典力学范例，它展示了如何将一个描述悬挂链条形状的非线性物理问题，通过巧妙的数学变换，转化为适合使用 Numerov 方法求解的线性方程。通过这个练习 ，你将亲手实现该方法，并将其数值解与精确的解析解进行比较，从而直观地验证该算法的高精度和有效性。",
            "id": "2421976",
            "problem": "一条均匀、完全柔韧、不可伸长的链条，其线质量密度为 $\\lambda$，悬挂在大小为 $g$ 的竖直引力场中并处于静力平衡状态。考虑一个笛卡尔坐标系，其中水平轴为 $x$ 轴，竖直轴 $y(x)$ 描述链条的形状。设张力的恒定水平分量为 $T_0$，并定义参数 $a = T_0 / (\\lambda g)$，其量纲为长度。从力平衡和几何关系出发，推导出该曲线的控制方程：\n$$\na\\,y''(x) = \\sqrt{1 + \\left(y'(x)\\right)^2}.\n$$\n然后，通过选择竖直原点，使最低点位于 $x=0$ 处，且满足 $y(0)=a$ 和 $y'(0)=0$，将此方程转换为一个不含一阶导数项的线性齐次二阶常微分方程，从而适用于 Numerov 方法。\n\n接下来，使用针对不含一阶导数项的二阶线性常微分方程的 Numerov 方法，在区间 $x \\in [0, X]$ 上数值计算链条的形状。使用初始条件 $y(0)=a$ 和 $y'(0)=0$，并通过在 $x=0$ 处的泰勒展开（展开至并包括 $h^4$ 阶项）来初始化第二个点，其中 $h$ 是均匀的网格间距。将您的数值解与推导中得到的解析参考解 $y(x) = a \\cosh(x/a)$ 进行比较，并报告在整个网格上的最大绝对误差。\n\n您的程序必须从第一性原理实现 Numerov 方案，不得调用任何黑箱常微分方程求解器。所有计算都是无量纲的，即不需要进行特定的单位转换；$x$ 和 $y$ 采用相同的长度单位，$a$ 和 $X$ 也以该单位给出。\n\n测试套件：\n- 情况1（理想路径）：$a=2.0$, $X=1.0$, $h=0.01$。\n- 情况2（粗网格边界检查）：$a=2.0$, $X=1.0$, $h=0.2$。\n- 情况3（近乎平坦的曲线）：$a=50.0$, $X=1.0$, $h=0.05$。\n- 情况4（大曲率）：$a=0.5$, $X=1.0$, $h=0.01$。\n\n对于每种情况，计算最大绝对误差\n$$\nE = \\max_{0 \\le n \\le N} \\left| y_n - a \\cosh\\!\\left(\\frac{x_n}{a}\\right) \\right|,\n$$ \n其中 $x_n = n h$，并且在所提供的情况中，$N = X/h$ 根据构造是一个整数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个误差值都四舍五入到10位小数（例如，$\\left[0.0000001234,0.0012345678,0.0,0.0\\right]$）。",
            "solution": "我们从基本静力学开始。设 $T(x)$ 表示在位置 $x$ 处的张力大小，$\\theta(x)$ 表示链条与水平方向的夹角。在静力平衡中，水平分量 $T_x = T(x)\\cos\\theta(x)$ 是恒定的，因此 $T_x = T_0$。竖直分量为 $T_y = T(x)\\sin\\theta(x)$。在一个微分弧长 $\\mathrm{d}s$ 上，内力的竖直分量发生变化，以平衡元素重量 $\\lambda g\\,\\mathrm{d}s$：\n$$\n\\mathrm{d}T_y = \\lambda g\\,\\mathrm{d}s.\n$$\n利用几何关系 $\\tan\\theta = y'$，$\\cos\\theta = 1/\\sqrt{1+(y')^2}$ 和 $\\sin\\theta = y'/\\sqrt{1+(y')^2}$，以及关系式 $T \\cos\\theta = T_0$，我们得到 $T = T_0 \\sqrt{1+(y')^2}$。于是\n$$\nT_y = T \\sin\\theta = T_0 \\sqrt{1+(y')^2} \\cdot \\frac{y'}{\\sqrt{1+(y')^2}} = T_0\\, y'.\n$$\n对 $x$ 求导，并利用 $\\mathrm{d}s = \\sqrt{1+(y')^2}\\,\\mathrm{d}x$ 可得\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}x}\\left(T_y\\right) = T_0\\, y'' = \\lambda g \\sqrt{1+(y')^2}.\n$$\n定义 $a = \\dfrac{T_0}{\\lambda g}$，我们得到非线性二阶常微分方程\n$$\na\\, y'' = \\sqrt{1 + (y')^2}.\n$$\n\n为了使该方程可积，并将其与适用于 Numerov 方法的线性形式联系起来，我们设 $p(x) = y'(x)$。于是方程变为\n$$\na \\frac{\\mathrm{d}p}{\\mathrm{d}x} = \\sqrt{1+p^2}.\n$$\n引入代换 $u(x) = \\operatorname{arsinh}(p) = \\ln\\!\\left(p + \\sqrt{1+p^2}\\right)$。由于 $\\dfrac{\\mathrm{d}}{\\mathrm{d}p}\\operatorname{arsinh}(p) = \\dfrac{1}{\\sqrt{1+p^2}}$，我们有\n$$\n\\frac{\\mathrm{d}u}{\\mathrm{d}x} = \\frac{1}{\\sqrt{1+p^2}} \\frac{\\mathrm{d}p}{\\mathrm{d}x} = \\frac{1}{a}.\n$$\n积分可得 $u(x) = \\dfrac{x-x_0}{a}$，其中 $x_0$ 为某个常数，因此\n$$\ny'(x) = p(x) = \\sinh\\!\\left(\\frac{x-x_0}{a}\\right).\n$$\n再次积分，\n$$\ny(x) = a \\cosh\\!\\left(\\frac{x-x_0}{a}\\right) + C,\n$$\n其中常数由边界条件和竖直原点的选择决定。如果我们要求曲线关于 $x=0$ 对称，最低点在 $x=0$ 处，并选择竖直原点使得 $y(0)=a$ 和 $y'(0)=0$，那么 $x_0=0$ 且 $C=0$，从而得到标准的悬链线形式 $y(x) = a \\cosh(x/a)$。对于此选择，请注意\n$$\ny''(x) = \\frac{1}{a^2} y(x),\n$$\n因为对 $y(x) = a \\cosh(x/a)$ 求导两次可得 $y''(x) = \\frac{1}{a}\\cosh(x/a)$。由于 $\\cosh(x/a) = y(x)/a$，代入可得 $y''(x) = \\frac{1}{a^2}y(x)$。因此，在适当选择竖直原点后，非线性控制方程等价于线性齐次方程\n$$\ny''(x) = g\\, y(x), \\quad \\text{with } g = \\frac{1}{a^2}.\n$$\n这是一个不含一阶导数项的二阶线性常微分方程，其形式为 Numerov 方法的标准形式。\n\n$y''(x) = f(x) y(x)$ 的 Numerov 方法推导：\n考虑一个间距为 $h$ 的均匀网格 $x_n = x_0 + n h$。将 $y_{n\\pm 1} = y(x_{n\\pm 1})$ 在 $x_n$ 附近进行泰勒展开：\n$$\ny_{n\\pm 1} = y_n \\pm h y'_n + \\frac{h^2}{2} y''_n \\pm \\frac{h^3}{6} y'''_n + \\frac{h^4}{24} y''''_n + \\mathcal{O}(h^5).\n$$\n将 $y_{n+1}$ 和 $y_{n-1}$ 的展开式相加，以消除奇数阶导数项：\n$$\ny_{n+1} + y_{n-1} = 2 y_n + h^2 y''_n + \\frac{h^4}{12} y''''_n + \\mathcal{O}(h^6).\n$$\n使用 $y'' = f y$ 并求导两次，得到 $y'''' = \\frac{\\mathrm{d}^2}{\\mathrm{d}x^2}(f y) = f'' y + 2 f' y' + f y''$。对于足够光滑的 $f$，Numerov 的思想是通过使用相邻点处的微分方程来近似 $y''''$，从而得到一个六阶方法。对于齐次情况 $y'' = f(x) y$，标准的 Numerov 递推关系为\n$$\n\\left(1 - \\frac{h^2}{12} f_{n+1}\\right) y_{n+1}\n= 2 y_n - y_{n-1} + \\frac{h^2}{12} \\left(10 f_n y_n + f_{n-1} y_{n-1}\\right) + \\mathcal{O}(h^6),\n$$\n其中 $f_n = f(x_n)$。在我们的应用中，$f(x) = g = 1/a^2$ 是常数，所以 $f_{n-1} = f_n = f_{n+1} = g$，递推关系简化为\n$$\n\\left(1 - \\frac{h^2 g}{12}\\right) y_{n+1}\n= 2 y_n - y_{n-1} + \\frac{h^2 g}{12} \\left(10 y_n + y_{n-1}\\right).\n$$\n为了启动递推，我们需要 $y_0$ 和 $y_1$。初始条件为 $y(0) = a$ 和 $y'(0) = 0$。在 $x=0$ 处使用泰勒展开，并包括到 $\\mathcal{O}(h^4)$ 项，\n$$\ny(h) = y(0) + h y'(0) + \\frac{h^2}{2} y''(0) + \\frac{h^3}{6} y'''(0) + \\frac{h^4}{24} y''''(0) + \\mathcal{O}(h^5).\n$$\n由于 $y''(0) = g y(0) = g a$，$y'''(0) = g y'(0) = 0$，以及 $y''''(0) = g y''(0) = g^2 a$（因为 $g$ 是常数），我们得到\n$$\ny(h) = a + \\frac{h^2}{2} g a + \\frac{h^4}{24} g^2 a + \\mathcal{O}(h^5)\n= a \\left(1 + \\frac{h^2 g}{2} + \\frac{h^4 g^2}{24}\\right) + \\mathcal{O}(h^5).\n$$\n因此，设 $y_0 = a$ 和\n$$\ny_1 = a \\left(1 + \\frac{h^2 g}{2} + \\frac{h^4 g^2}{24}\\right).\n$$\n\n为了验证，我们将其与精确解 $y(x) = a \\cosh(x/a)$ 进行比较，并计算在整个网格上的最大绝对误差：\n$$\nE = \\max_{0 \\le n \\le N} \\left| y_n - a \\cosh\\!\\left(\\frac{x_n}{a}\\right) \\right|,\n\\quad x_n = n h, \\quad N = \\frac{X}{h}.\n$$\n\n测试套件和覆盖范围：\n- 情况1 测试了一般情况，即解析良好的场景（$a=2.0$, $X=1.0$, $h=0.01$），此时 Numerov 方法的 $\\mathcal{O}(h^6)$ 精度应该会产生非常小的误差。\n- 情况2 使用粗网格（$h=0.2$）来对方案进行压力测试，并观察其精度下降但仍保持稳定。\n- 情况3 探究了小曲率情况（$a=50.0$），此时 $g=1/a^2$很小，解近似为一条平线；这测试了对小 $g$ 值的敏感度。\n- 情况4 使用大曲率情况（$a=0.5$），测试在相同区间内对于较大 $g$ 值的数值稳定性。\n\n程序实现了针对常数 $g$ 的专用 Numerov 递推关系，使用四阶泰勒展开进行启动，并按要求将 $E$ 值的列表以单行、方括号括起、逗号分隔的形式报告，每个值四舍五入到10位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef numerov_constant_g(g, a, X, h):\n    \"\"\"\n    Solve y'' = g * y on x in [0, X] with y(0)=a, y'(0)=0 using Numerov's method.\n    Initialize y(h) using a 4th-order Taylor expansion.\n    Return max absolute error vs exact y(x) = a cosh(x/a).\n    \"\"\"\n    # Number of steps, ensure integer\n    N = int(round(X / h))\n    X_effective = N * h  # Adjusted X to match grid if needed\n    x = np.linspace(0.0, X_effective, N + 1)\n\n    # Initial conditions\n    y = np.empty(N + 1, dtype=float)\n    y[0] = a\n    # Taylor-based start: y(h) = a*(1 + (h^2 g)/2 + (h^4 g^2)/24)\n    y1 = a * (1.0 + 0.5 * (h*h*g) + (h**4) * (g**2) / 24.0)\n    if N >= 1:\n        y[1] = y1\n\n    if N >= 2:\n        # Precompute coefficients since g is constant\n        c_denom = 1.0 - (h*h*g)/12.0\n        c_y_n = 2.0 + (h*h*g) * (10.0/12.0)\n        c_y_nm1 = -1.0 + (h*h*g) * (1.0/12.0)\n\n        for n in range(1, N):\n            # Numerov recurrence specialized to constant g:\n            # (1 - h^2 g / 12) y_{n+1} = (2 + 10 h^2 g / 12) y_n - (1 - h^2 g / 12) y_{n-1}\n            # Rearranged in terms of coefficients c_y_n and c_y_nm1\n            y[n+1] = (c_y_n * y[n] + c_y_nm1 * y[n-1]) / c_denom\n\n    # Exact solution for comparison: y(x) = a cosh(x/a)\n    y_exact = a * np.cosh(x / a)\n    err = np.max(np.abs(y - y_exact))\n    return err\n\ndef solve():\n    # Define the test cases from the problem statement: (a, X, h)\n    test_cases = [\n        (2.0, 1.0, 0.01),   # Case 1: happy path\n        (2.0, 1.0, 0.2),    # Case 2: coarse grid\n        (50.0, 1.0, 0.05),  # Case 3: near-flat curve\n        (0.5, 1.0, 0.01),   # Case 4: steep curvature\n    ]\n\n    results = []\n    for a, X, h in test_cases:\n        g = 1.0 / (a * a)\n        err = numerov_constant_g(g, a, X, h)\n        # Round to 10 decimal places for output formatting\n        results.append(err)\n\n    # Final print statement in the exact required format: bracketed, comma-separated, 10 decimals\n    formatted = \"[\" + \",\".join(f\"{val:.10f}\" for val in results) + \"]\"\n    print(formatted)\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "在掌握了基本应用之后，我们将把 Numerov 方法应用于一个更复杂的量子现象：安德森局域化。这个练习  让你探索当一个量子粒子在无序环境中运动时，其波函数会发生什么变化。通过在一个随机变化的势能景观中求解薛定谔方程，你将看到 Numerov 方法如何轻松处理非平滑、空间变化的系数，并计算出用于量化波函数局域化程度的关键指标，从而亲眼“看见”凝聚态物理中的一个深刻概念。",
            "id": "2422024",
            "problem": "考虑一个粒子在有限区间内的随机势中运动，其时间无关的一维薛定谔方程（一个二阶常微分方程(ODE)）为：\n$$\n\\psi''(x) + k(x)\\,\\psi(x) = 0,\n$$\n其中\n$$\nk(x) = \\frac{2m}{\\hbar^2}\\left(E - V(x)\\right).\n$$\n使用无量纲单位，令约化普朗克常数 $\\,\\hbar = 1\\,$，质量 $\\,m = \\tfrac{1}{2}\\,$，因此 $\\,\\tfrac{2m}{\\hbar^2} = 1\\,$，从而 $\\,k(x) = E - V(x)\\,$。势 $\\,V(x)\\,$ 在均匀网格上是分段常数，定义在网格点 $\\,x_i = i\\,h\\,$（其中 $\\,i = 0,1,\\dots,M\\,$，$\\,h = L/M\\,$ 且 $\\,L  0\\,$）上。对于给定的无序强度 $\\,W \\ge 0\\,$ 和给定的整数伪随机种子 $\\,s\\,$，数值 $\\,V_i = V(x_i)\\,$ 是使用以种子 $\\,s\\,$ 初始化的伪随机数生成器，从区间 $\\,[-W/2,\\,W/2]\\,$ 上的均匀分布中独立抽取的。施加初始条件\n$$\n\\psi(0) = 0,\\quad \\psi'(0) = 1,\n$$\n对于任意给定的 $\\,E\\,$ 和 $\\,V(x)\\,$ 的实现，这些条件确定了唯一的解。在网格上计算出离散解 $\\,\\{\\psi_i\\}_{i=0}^{M}\\,$ 后，将其归一化以得到 $\\,\\tilde{\\psi}_i = \\psi_i \\big/ \\sqrt{\\sum_{j=0}^{M} \\psi_j^2}\\,$。使用这个归一化的离散波函数，计算以下两个量化局域化的无量纲诊断量：\n1. 逆参与率，\n$$\n\\mathrm{IPR} = \\sum_{i=0}^{M} \\tilde{\\psi}_i^4,\n$$\n2. 右尾范数分数，\n$$\nT = \\sum_{i=\\lfloor 0.9\\,M \\rfloor}^{M} \\tilde{\\psi}_i^2.\n$$\n在这些单位下，所有量都是无量纲的。\n\n您的任务是编写一个完整的程序，对下面的每个测试用例，按规定构建随机势，使用给定的初始条件求解在 $[0,L]$ 上的 $\\,\\psi(x)\\,$，将结果归一化，并输出浮点数对 $\\,(\\mathrm{IPR}, T)\\,$。\n\n使用以下测试套件。每个测试用例是一个元组 $\\,\\left(L,\\,M,\\,W,\\,E,\\,s\\right)\\,$，其中 $\\,L\\,$ 是区间长度，$\\,M\\,$ 是均匀步数，$\\,W\\,$ 是无序强度，$\\,E\\,$ 是能量，$\\,s\\,$ 是整数种子：\n- 测试用例 $\\,1\\,$：$\\,\\left(200.0,\\,4000,\\,0.0,\\,1.0,\\,123\\right)\\,$\n- 测试用例 $\\,2\\,$：$\\,\\left(200.0,\\,4000,\\,1.0,\\,1.0,\\,456\\right)\\,$\n- 测试用例 $\\,3\\,$：$\\,\\left(200.0,\\,4000,\\,4.0,\\,1.0,\\,789\\right)\\,$\n- 测试用例 $\\,4\\,$：$\\,\\left(200.0,\\,4000,\\,2.0,\\,{-0.5},\\,321\\right)\\,$\n\n您的程序必须生成单行输出，其中包含按顺序聚合的所有测试用例的结果，形式为方括号内以逗号分隔的列表。对于每个测试用例，按顺序输出两个浮点数 $\\,\\mathrm{IPR}\\,$ 和 $\\,T\\,$。因此，最终格式必须是\n$$\n\\big[\\mathrm{IPR}_1,\\,T_1,\\,\\mathrm{IPR}_2,\\,T_2,\\,\\mathrm{IPR}_3,\\,T_3,\\,\\mathrm{IPR}_4,\\,T_4\\big].\n$$",
            "solution": "出发点是时间无关的一维薛定谔方程，\n$$\n\\psi''(x) + k(x)\\,\\psi(x) = 0,\\quad k(x) = \\frac{2m}{\\hbar^2}\\left(E - V(x)\\right).\n$$\n在指定的无量纲单位中，设 $\\,\\hbar = 1\\,$ 和 $\\,m = \\tfrac{1}{2}\\,$，因此 $\\,\\tfrac{2m}{\\hbar^2} = 1\\,$，方程简化为\n$$\n\\psi''(x) + \\big(E - V(x)\\big)\\,\\psi(x) = 0.\n$$\n在均匀网格 $\\,x_i = i\\,h\\,$（其中 $\\,i = 0,1,\\dots,M\\,$ 且 $\\,h = L/M\\,$）上，定义 $\\,k_i = E - V_i\\,$，其中 $\\,V_i\\,$ 是使用为每个测试用例给定的种子初始化的伪随机数生成器，从 $\\,[-W/2,\\,W/2]\\,$ 上的均匀分布中独立抽样的。初始条件 $\\,\\psi(0) = 0\\,$ 和 $\\,\\psi'(0) = 1\\,$ 指定了该常微分方程的唯一解。为了在网格上初始化一个两步递推，在 $\\,x = 0\\,$ 处进行泰勒展开可得\n$$\n\\psi(h) = \\psi(0) + h\\,\\psi'(0) + \\frac{h^2}{2}\\,\\psi''(0) + \\mathcal{O}(h^3).\n$$\n由于 $\\,\\psi''(0) = -k_0\\,\\psi(0) = 0\\,$，可以得到主阶精确的起始值\n$$\n\\psi_0 = 0,\\qquad \\psi_1 = h.\n$$\n对于形如 $\\,\\psi''(x) + k(x)\\,\\psi(x) = 0\\,$ 的二阶线性常微分方程，Numerov 方法提供了一种高精度的三点积分格式。在均匀网格上，它表示为\n$$\n\\psi_{i+1} = \\frac{2\\,\\psi_i\\,\\Big(1 - \\frac{5 h^2}{12}\\,k_i\\Big) - \\psi_{i-1}\\,\\Big(1 + \\frac{h^2}{12}\\,k_{i-1}\\Big)}{1 + \\frac{h^2}{12}\\,k_{i+1}},\\quad i = 1,2,\\dots,M-1,\n$$\n这在代数上等价于标准的 Numerov 更新\n$$\n\\left(1 + \\frac{h^2}{12}\\,k_{i+1}\\right)\\psi_{i+1} = 2\\left(1 - \\frac{5h^2}{12}\\,k_i\\right)\\psi_i - \\left(1 + \\frac{h^2}{12}\\,k_{i-1}\\right)\\psi_{i-1}.\n$$\n该格式与常微分方程是一致的，对于足够光滑的 $\\,k(x)\\,$，其局部截断误差为 $\\,\\mathcal{O}(h^6)\\,$ 阶。在当前设置中，$\\,k(x)\\,$ 在网格上是分段常数，这在 $\\,h \\to 0\\,$ 时保持了高阶精度。\n\n在从 $\\,i=1\\,$ 到 $\\,i=M-1\\,$ 的前向积分过程中，振幅 $\\,\\psi_i\\,$ 会根据 $\\,k_i\\,$ 的符号和空间变化呈指数级增长或衰减。为了在保持解的形状的同时避免数值上溢或下溢，当其量级超过预选阈值时，可以通过一个大因子来重缩放部分计算出的序列 $\\{\\psi_j\\}_{j\\le i}$。这种重缩放不影响归一化的波函数或由其计算的任何无量纲诊断量。\n\n计算出 $\\,\\{\\psi_i\\}_{i=0}^{M}\\,$ 后，通过\n$$\n\\tilde{\\psi}_i = \\frac{\\psi_i}{\\sqrt{\\sum_{j=0}^{M} \\psi_j^2}},\n$$\n来归一化离散波函数，这与连续的 $\\,L^2\\,$ 归一化是一致的，因为均匀网格因子在诸如逆参与率之类的比率中被消除了。于是逆参与率为\n$$\n\\mathrm{IPR} = \\sum_{i=0}^{M} \\tilde{\\psi}_i^4,\n$$\n而右尾范数分数，用于衡量波函数在定义域最后 $\\,10\\%\\,$ 的权重，是\n$$\nT = \\sum_{i=\\lfloor 0.9\\,M \\rfloor}^{M} \\tilde{\\psi}_i^2.\n$$\n$\\,\\mathrm{IPR}\\,$ 和 $\\,T\\,$ 都是无量纲的。对于一个扩展到整个区间的扩展态，我们预期 $\\,\\mathrm{IPR}\\,$ 很小（与 $\\,1/M\\,$ 同阶），而 $\\,T\\,$ 接近 $\\,0.1\\,$。而对于一个局域态，$\\,\\mathrm{IPR}\\,$ 较大，且 $\\,T\\,$ 强烈依赖于局域化中心相对于右边界的位置。\n\n该测试套件涵盖了几个不同情形：当 $\\,W = 0\\,$ 和 $\\,E = 1\\,$ 时，自由空间中的解是振荡且扩展的；在固定的 $\\,E = 1\\,$ 下，当 $\\,W = 1\\,$ 和 $\\,W = 4\\,$ 时，增加无序会促进局域化；当 $\\,E = -0.5\\,$ 和中等无序 $\\,W = 2\\,$ 时，解表现出渐逝行为，在给定的初始条件下向右边界集中。该程序为每个测试用例实现了所述的构造、积分、归一化和诊断量计算，并以规定的单行列表格式输出结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef numerov_solve_ipr_tail(L, M, W, E, seed):\n    \"\"\"\n    Solve psi''(x) + (E - V(x)) psi(x) = 0 on [0, L] with psi(0)=0, psi'(0)=1\n    using a uniform grid of M steps (M+1 points), random piecewise-constant V,\n    and return (IPR, T) where T is the right-tail norm fraction.\n    \"\"\"\n    # Grid setup\n    N = M  # number of steps\n    h = L / N\n    # Random potential at grid nodes: V_i ~ U[-W/2, W/2]\n    rng = np.random.default_rng(seed)\n    if W == 0.0:\n        V = np.zeros(N + 1, dtype=np.float64)\n    else:\n        V = rng.uniform(-W / 2.0, W / 2.0, size=N + 1).astype(np.float64)\n    k = (E - V).astype(np.float64)\n\n    # Allocate solution array\n    psi = np.empty(N + 1, dtype=np.float64)\n\n    # Initial conditions: psi(0)=0, psi'(0)=1 -> psi(h) ~ h (since psi''(0)=0)\n    psi[0] = 0.0\n    psi[1] = h\n\n    h2 = h * h\n    # Safety parameters for rescaling to avoid overflow\n    rescale_threshold = 1e100\n    rescale_factor = 1e50\n\n    # Numerov integration\n    # (1 + h^2 k_{i+1}/12) psi_{i+1} = 2(1 - 5 h^2 k_i/12) psi_i - (1 + h^2 k_{i-1}/12) psi_{i-1}\n    for i in range(1, N):\n        kim1 = k[i - 1]\n        ki = k[i]\n        kip1 = k[i + 1]\n\n        denom = 1.0 + (h2 * kip1) / 12.0\n        num = 2.0 * (1.0 - (5.0 * h2 * ki) / 12.0) * psi[i] - (1.0 + (h2 * kim1) / 12.0) * psi[i - 1]\n\n        psi[i + 1] = num / denom\n\n        # Rescale to avoid overflow; scaling entire prefix preserves shape\n        if not np.isfinite(psi[i + 1]) or abs(psi[i + 1]) > rescale_threshold or abs(psi[i]) > rescale_threshold:\n            psi[: i + 2] /= rescale_factor\n\n    # Normalize\n    norm2 = float(np.dot(psi, psi))\n    if norm2 == 0.0 or not np.isfinite(norm2):\n        # Fallback in pathological cases\n        return float('nan'), float('nan')\n    psi /= np.sqrt(norm2)\n\n    # Inverse Participation Ratio (IPR)\n    ipr = float(np.sum(psi * psi * psi * psi))\n    # Right-tail norm fraction: last 10% of the grid\n    tail_start = int(np.floor(0.9 * N))\n    tail = float(np.sum(psi[tail_start:] * psi[tail_start:]))\n\n    return ipr, tail\n\ndef solve():\n    # Define the test cases from the problem statement: (L, M, W, E, seed)\n    test_cases = [\n        (200.0, 4000, 0.0, 1.0, 123),\n        (200.0, 4000, 1.0, 1.0, 456),\n        (200.0, 4000, 4.0, 1.0, 789),\n        (200.0, 4000, 2.0, -0.5, 321),\n    ]\n\n    results = []\n    for case in test_cases:\n        L, M, W, E, seed = case\n        ipr, tail = numerov_solve_ipr_tail(L, M, W, E, seed)\n        results.append(ipr)\n        results.append(tail)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "最后的练习是一个综合性的挑战，它将 Numerov 方法置于一个现代计算物理研究的前沿场景中。你将不再仅仅求解一个初值问题，而是将 Numerov 积分器作为一个核心模块，嵌入到一个更大的“打靶法”算法中，以寻找量子纳米线中的束缚态能量本征值。这项任务  不仅能巩固你对 Numerov 方法的掌握，还将引导你学习如何解决物理学中常见的边界值问题，并最终将数值计算结果与一个前沿的物理量——量子电容——联系起来，完整地体验一次从理论模型到物理预测的全过程。",
            "id": "2421997",
            "problem": "一维量子纳米线的长度为 $L$，其模型为一个质量为 $m$ 的粒子，该粒子被限制在 $x=0$ 和 $x=L$ 处具有无限高硬壁的盒子中。其势能函数为：当 $0xL$ 时 $V(x)=0$，其他地方 $V(x)=+\\infty$。考虑定态薛定谔方程\n$$-\\frac{\\hbar^2}{2m}\\frac{d^2\\psi(x)}{dx^2}+V(x)\\psi(x)=E\\,\\psi(x),$$\n其须满足边界条件 $\\psi(0)=0$ 和 $\\psi(L)=0$。您将通过使用 Numerov 方法数值求解本征能量，来计算在零温下作为化学势函数的洛伦兹展宽态密度和单位长度的量子电容。\n\n使用的基本原理：\n- 写成如下形式的定态薛定谔方程\n$$\\psi''(x)=\\frac{2m}{\\hbar^2}\\left[V(x)-E\\right]\\psi(x),$$\n具有 $\\psi(0)=0$ 和 $\\psi(L)=0$ 的边界条件，描述一个无限深势阱中的粒子。\n- 态密度 (DoS) 的定义，其中离散谱通过狄拉克 delta 函数的洛伦兹表示展宽为连续函数。使用一个小的正展宽半峰宽 $\\Gamma$，\n$$\\delta(E-E_n)\\approx \\frac{1}{\\pi}\\frac{\\Gamma}{(E-E_n)^2+\\Gamma^2}。$$\n- 零温下单位长度量子电容的定义，为线电荷密度对化学势 $\\mu$ 的导数，\n$$\\frac{C_Q}{L}=e^2 \\frac{\\partial n}{\\partial \\mu}=e^2 D(\\mu),$$\n其中 $D(E)$ 是能量为 $E$ 时的单位长度态密度，$e$ 是元电荷。\n\n您的任务：\n1) 从 $\\psi''(x)=S\\,\\psi(x)$ 形式的薛定谔方程出发，其中 $S(x)=\\frac{2m}{\\hbar^2}\\left[V(x)-E\\right]$，推导一个适用于这种形式的二阶线性常微分方程的 Numerov 型算法，确保步长 $h$ 的局部截断误差为 $h^6$ 阶。实现一个打靶法，该方法从 $x=0$ 到 $x=L$ 进行积分，并通过一个任意小的非零值 $\\psi(h)$ 来强制满足 $\\psi(0)=0$，然后找到使边界值 $\\psi(L)$ 为零的能量 $E$。使用一个稳健的根区间划定和细化策略来识别所有达到指定能量上限的束缚态能量 $E_n$。\n2) 使用束缚态能量 $\\{E_n\\}$，构建具有自旋简并因子 $g_s=2$ 的单位长度洛伦兹展宽态密度，\n$$D(E)=\\frac{g_s}{L}\\sum_n \\frac{1}{\\pi}\\frac{\\Gamma}{(E-E_n)^2+\\Gamma^2}。$$\n3) 通过下式计算零温单位长度量子电容\n$$\\frac{C_Q}{L}=e^2 D(\\mu)。$$\n\n重要的实现和单位要求：\n- 使用以下常量：$m=m_e$（自由电子质量）、$\\hbar$（约化普朗克常数）和 $e$（元电荷），所有单位均采用国际单位制（SI）。\n- 您计算中的所有内部能量都必须以焦耳为单位；如果参数以电子伏特 (eV) 或毫电子伏特 (meV) 给出，请使用 $1\\,\\mathrm{eV}=e\\,\\mathrm{J}$ 将它们转换为焦耳。\n- 最终的单位长度量子电容以法拉每米 (F/m) 表示，并将每个报告值以科学记数法格式化，保留小数点后六位数字。\n- 您必须使用 Numerov 方法计算边界值 $\\psi(L)$，并结合区间划定加二分法（或等效的单调）求根器来实现本征能量搜索。请勿在代码中使用闭合形式的本征能量。\n\n测试套件：\n对于每个参数三元组 $(L,\\Gamma,\\mu)$，计算 $\\frac{C_Q}{L}$（单位为 $\\mathrm{F/m}$），并达到所要求的精度。长度 $L$ 以米为单位，展宽半峰宽 $\\Gamma$ 以毫电子伏特 (meV) 为单位，化学势 $\\mu$ 以电子伏特 (eV) 为单位。使用 $g_s=2$。\n\n- 情况1（正常路径，低于第一能级）：$(L, \\Gamma, \\mu)=(1.0\\times 10^{-8}, 2.0, 0.020)$。\n- 情况2（接近共振）：$(L, \\Gamma, \\mu)=(1.0\\times 10^{-8}, 2.0, 0.0235)$。\n- 情况3（多个子带贡献）：$(L, \\Gamma, \\mu)=(1.0\\times 10^{-8}, 2.0, 0.100)$。\n- 情况4（较短的线，较高的第一能级）：$(L, \\Gamma, \\mu)=(5.0\\times 10^{-9}, 2.0, 0.050)$。\n- 情况5（较长的线，较小的展宽）：$(L, \\Gamma, \\mu)=(2.0\\times 10^{-8}, 1.0, 0.010)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含五个结果，形式为一个用方括号括起来的逗号分隔列表，并以科学记数法格式化，小数点后精确到六位数字（例如，“[1.234567e-08,2.345678e-07,3.456789e-06,4.567890e-05,5.678901e-04]”）。",
            "solution": "所提出的问题是计算量子物理学中的一个标准练习，要求确定定态薛定谔方程的本征能量，并随后计算态密度和量子电容。该问题定义明确，科学上合理，且内部一致。我们将着手进行严谨的求解。\n\n问题的核心是关于一个质量为 $m$ 的粒子在一维无限势壁限制下、长度为 $L$ 的零势区域中的定态薛定谔方程（TISE）。该方程由下式给出：\n$$\n\\psi''(x) + \\frac{2m}{\\hbar^2}(E - V(x))\\psi(x) = 0\n$$\n并满足边界条件 $\\psi(0) = 0$ 和 $\\psi(L) = 0$。在纳米线内部，从 $x=0$ 到 $x=L$，势能 $V(x)=0$。方程简化为谐振子方程的形式：\n$$\n\\psi''(x) + k^2\\psi(x) = 0\n$$\n其中 $k^2 = \\frac{2mE}{\\hbar^2}$。问题要求使用 Numerov 方法进行数值求解，该方法是专门为这种缺少一阶导数项的二阶常微分方程（ODE）设计的。\n\n首先，我们推导 Numerov 递推关系。如题目所要求，标准方法产生的局部截断误差为 $\\mathcal{O}(h^6)$ 阶。我们从波函数 $\\psi(x)$ 在网格点 $x_i$ 附近的泰勒级数展开开始：\n$$\n\\psi(x_i \\pm h) = \\psi_i \\pm h\\psi'_i + \\frac{h^2}{2!}\\psi''_i \\pm \\frac{h^3}{3!}\\psi'''_i + \\frac{h^4}{4!}\\psi^{(4)}_i \\pm \\frac{h^5}{5!}\\psi^{(5)}_i + \\mathcal{O}(h^6)\n$$\n将 $\\psi(x_i+h)$ 和 $\\psi(x_i-h)$ 的展开式相加，可以消除奇数阶导数项：\n$$\n\\psi_{i+1} + \\psi_{i-1} = 2\\psi_i + h^2\\psi''_i + \\frac{h^4}{12}\\psi^{(4)}_i + \\mathcal{O}(h^6)\n$$\n我们可以通过对原始常微分方程求导两次来获得 $\\psi^{(4)}_i$ 的表达式：$\\psi^{(4)}(x) = \\frac{d^2}{dx^2}(-k^2(x)\\psi(x))$。用有限差分算子近似这个二阶导数，得到：\n$$\n\\psi^{(4)}_i \\approx \\frac{1}{h^2}( -(k^2\\psi)_{i+1} + 2(k^2\\psi)_i - (k^2\\psi)_{i-1} )\n$$\n将此式代入泰勒展开式的和中并重新整理各项，即可得到 Numerov 递推关系：\n$$\n\\psi_{i+1}\\left(1 + \\frac{h^2}{12}k_{i+1}^2\\right) = 2\\psi_i\\left(1 - \\frac{5h^2}{12}k_i^2\\right) - \\psi_{i-1}\\left(1 + \\frac{h^2}{12}k_{i-1}^2\\right)\n$$\n对于无限深势阱的特定情况，$V(x)=0$ 且对于给定的尝试能量 $E$ 是一个常数，这使得 $k^2 = \\frac{2mE}{\\hbar^2}$ 在阱内整个网格上都是恒定的。我们把这个常数记为 $k_E^2$。递推关系简化为：\n$$\n\\psi_{i+1}\\left(1 + \\frac{h^2}{12}k_E^2\\right) = \\psi_i\\left(2 - \\frac{10h^2}{12}k_E^2\\right) - \\psi_{i-1}\\left(1 + \\frac{h^2}{12}k_E^2\\right)\n$$\n这个关系允许我们根据前两个值 $\\psi_i$ 和 $\\psi_{i-1}$ 来计算 $\\psi_{i+1}$。\n\n为了找到本征能量，我们采用打靶法。该方法将边值问题转化为初值问题。我们强制满足第一个边界条件 $\\psi(0)=0$，并在第一步为波函数选择一个小的、任意的非零值，例如 $\\psi(h) = \\text{const}$，因为薛定谔方程的线性特性意味着在归一化确定之前，解的尺度是任意的。对于一个给定的尝试能量 $E$，我们使用 Numerov 递推关系从 $x=0$ 到 $x=L$ 对波函数进行积分。第二个边界条件 $\\psi(L)=0$ 将仅对特定的离散能量值 $E$ 成立，这些能量值就是我们所寻求的本征能量。\n我们定义一个函数 $\\Phi(E) = \\psi(L; E)$，它表示对于给定的能量 $E$，在 $x=L$ 处数值计算出的波函数的值。本征能量就是这个函数的根，即满足 $\\Phi(E_n) = 0$ 的 $E_n$。\n\n为了找到这些根，我们实现了一个稳健的两阶段过程。首先，我们通过以一个小的步长 $\\Delta E$ 扫描一个合适的能量范围 $[E_{min}, E_{max}]$ 来划定根的区间。如果 $\\Phi(E_j) \\cdot \\Phi(E_{j+1})  0$，则认为在区间 $[E_j, E_{j+1}]$ 内存在一个根。其次，一旦根被限定在某个区间内，就使用二分法来找到其精确值。这种迭代方法会重复地将区间减半，同时确保根始终位于新的、更小的区间内，直到区间宽度小于预设的容差为止。\n\n在计算出达到指定能量上限（选择的值要足够大于测试用例中最大的化学势）的一组本征能量 $\\{E_n\\}$ 后，我们计算单位长度的洛伦兹展宽态密度 (DoS) $D(E)$。包含自旋简并因子 $g_s=2$ 后，能量为 $E$ 时的态密度由下式给出：\n$$\nD(E) = \\frac{g_s}{L} \\sum_{n} \\frac{1}{\\pi} \\frac{\\Gamma}{(E - E_n)^2 + \\Gamma^2}\n$$\n其中 $\\Gamma$ 是展宽半峰宽。\n\n最后，零温下的单位长度量子电容 $C_Q/L$ 与化学势 $\\mu$ 处的态密度成正比。其关系为：\n$$\n\\frac{C_Q}{L} = e^2 D(\\mu)\n$$\n其中 $e$ 是元电荷。我们使用数值方法确定的本征能量和给定的参数为每个测试用例计算这个值。所有物理常数均采用国际单位制（SI），而以 eV 或 meV 为单位提供的能量参数在内部计算时会转换为焦耳。$C_Q/L$ 的最终结果以法拉每米（F/m）表示。",
            "answer": "```python\nimport numpy as np\nfrom scipy.constants import hbar, m_e, e\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n\n    # Physical constants in SI units\n    # hbar: Reduced Planck constant (J.s)\n    # m_e: Electron mass (kg)\n    # e: Elementary charge (C)\n\n    def solve_bvp_numerov(energy_J, L, N_grid, m):\n        \"\"\"\n        Solves the Schrodinger equation for a given energy E using the Numerov method.\n        Returns the wavefunction value at x=L.\n\n        Args:\n            energy_J (float): Trial energy in Joules.\n            L (float): Length of the nanowire in meters.\n            N_grid (int): Number of grid points for discretization.\n            m (float): Mass of the particle in kg.\n\n        Returns:\n            float: Value of psi at x=L.\n        \"\"\"\n        if energy_J = 0:\n            return 0.0\n\n        h = L / N_grid\n        k2 = (2.0 * m * energy_J) / (hbar**2)\n        \n        # Numerov method coefficients for constant k^2\n        h2_k2_12 = h**2 * k2 / 12.0\n        c1 = 1.0 + h2_k2_12\n        c2 = 2.0 * (1.0 - 5.0 * h2_k2_12)\n        \n        # Initial conditions: psi(0) = 0, psi(h) = small constant\n        psi_prev = 0.0\n        psi_curr = 1e-5\n        \n        for _ in range(1, N_grid):\n            psi_next = (c2 * psi_curr - c1 * psi_prev) / c1\n            psi_prev, psi_curr = psi_curr, psi_next\n            \n        return psi_curr\n\n    def bisection(func, a, b, tol=1e-10):\n        \"\"\"\n        Finds a root of func in the interval [a, b] using the bisection method.\n        'tol' is relative to the size of the interval.\n        \"\"\"\n        fa, fb = func(a), func(b)\n        if fa * fb >= 0:\n            return None  # No root or multiple roots in the interval\n\n        while (b - a) / (abs(a) + abs(b)) > tol:\n            c = (a + b) / 2.0\n            fc = func(c)\n            if fc == 0.0:\n                return c\n            if fa * fc  0:\n                b, fb = c, fc\n            else:\n                a, fa = c, fc\n        return (a + b) / 2.0\n\n    def find_eigenenergies(L, m, E_max_J, N_grid, N_scan_steps=2000):\n        \"\"\"\n        Finds all eigenenergies up to E_max_J by scanning and using bisection.\n        \n        Args:\n            L (float): Length of the nanowire in meters.\n            m (float): Mass of the particle in kg.\n            E_max_J (float): Maximum energy to scan for eigenvalues, in Joules.\n            N_grid (int): Number of grid points for Numerov.\n            N_scan_steps (int): Number of steps for the initial energy scan.\n\n        Returns:\n            list: A list of eigenenergies in Joules.\n        \"\"\"\n        energies = []\n        target_func = lambda E: solve_bvp_numerov(E, L, N_grid, m)\n\n        E_scan = np.linspace(1e-24, E_max_J, N_scan_steps) # Start slightly above zero\n        psi_L_prev = target_func(E_scan[0])\n        \n        for i in range(1, len(E_scan)):\n            E_curr = E_scan[i]\n            psi_L_curr = target_func(E_curr)\n            \n            if psi_L_prev * psi_L_curr  0:\n                E_prev = E_scan[i-1]\n                root = bisection(target_func, E_prev, E_curr)\n                if root is not None:\n                    energies.append(root)\n            \n            psi_L_prev = psi_L_curr\n            \n        return energies\n\n    def compute_cq_per_l(mu_J, Gamma_J, L, eigenenergies):\n        \"\"\"\n        Computes the quantum capacitance per unit length.\n\n        Args:\n            mu_J (float): Chemical potential in Joules.\n            Gamma_J (float): Broadening half-width in Joules.\n            L (float): Length of the nanowire in meters.\n            eigenenergies (list): List of eigenenergies in Joules.\n\n        Returns:\n            float: Quantum capacitance per unit length in F/m.\n        \"\"\"\n        g_s = 2.0  # Spin degeneracy\n        \n        dos_sum = 0.0\n        for En in eigenenergies:\n            lorentzian = (1.0 / np.pi) * (Gamma_J / ((mu_J - En)**2 + Gamma_J**2))\n            dos_sum += lorentzian\n            \n        dos_per_length = (g_s / L) * dos_sum\n        \n        # C_Q/L = e^2 * D(mu), with D(mu) being per unit length and energy.\n        # D(mu) is in units of (J^-1 m^-1)\n        # e^2 is in C^2. C^2 / J is Farad. So result is F/m.\n        cq_per_l = e**2 * dos_per_length\n        return cq_per_l\n\n    # Test suite from the problem statement\n    test_cases = [\n        (1.0e-8, 2.0, 0.020),  # Case 1\n        (1.0e-8, 2.0, 0.0235), # Case 2\n        (1.0e-8, 2.0, 0.100),  # Case 3\n        (5.0e-9, 2.0, 0.050),  # Case 4\n        (2.0e-8, 1.0, 0.010),  # Case 5\n    ]\n    \n    # Parameters for the numerical solution\n    N_GRID_POINTS = 1000\n    # Set energy ceiling high enough for all test cases\n    E_CEILING_EV = 0.5 \n    E_CEILING_J = E_CEILING_EV * e\n\n    results = []\n    \n    # Run simulation for each test case\n    for case in test_cases:\n        L_m, Gamma_meV, mu_eV = case\n        \n        # Convert parameters to SI units (Joules)\n        Gamma_J = Gamma_meV * 1e-3 * e\n        mu_J = mu_eV * e\n        \n        # 1. Find the eigenenergies\n        eigenenergies = find_eigenenergies(L_m, m_e, E_CEILING_J, N_GRID_POINTS)\n        \n        # 2. Compute quantum capacitance per unit length\n        result = compute_cq_per_l(mu_J, Gamma_J, L_m, eigenenergies)\n        results.append(result)\n\n    # Format the final output as specified\n    print(f\"[{','.join(['{:.6e}'.format(r) for r in results])}]\")\n\nsolve()\n```"
        }
    ]
}