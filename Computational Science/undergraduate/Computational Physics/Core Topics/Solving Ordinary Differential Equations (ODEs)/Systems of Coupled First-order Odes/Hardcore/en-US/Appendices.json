{
    "hands_on_practices": [
        {
            "introduction": "Many fundamental systems in physics are described by second-order ODEs. This first exercise tackles a classic mass-spring oscillator but with a twist: a nonlinear damping force proportional to velocity squared. You will practice the essential skill of converting this second-order equation into a system of two first-order ODEs, which is the standard form required by most numerical solvers. By tracking the system's mechanical energy, you will also explore how to use physical conservation laws (or the lack thereof) to verify the accuracy and behavior of your simulation .",
            "id": "2444882",
            "problem": "A one-dimensional mass–spring oscillator with quadratic velocity-proportional damping is governed by the second-order ordinary differential equation (ODE), where the damping force is nonlinear: $$m\\,\\ddot{x}(t) + k\\,x(t) + b\\,\\dot{x}(t)\\lvert \\dot{x}(t)\\rvert = 0,$$ with displacement $x(t)$, velocity $\\dot{x}(t)$, mass $m$, spring constant $k$, and nonlinear damping coefficient $b \\ge 0$. Work in dimensionless units by setting $m=1$. Convert this to a system of coupled first-order ODEs by defining the state vector $y(t) = \\big(x(t), v(t)\\big)$ with $v(t) = \\dot{x}(t)$. The system is $$\\dot{x}(t) = v(t), \\quad \\dot{v}(t) = -k\\,x(t) - b\\,v(t)\\lvert v(t)\\rvert.$$\n\nDefine the mechanical energy $$E(t) = \\tfrac{1}{2}v(t)^2 + \\tfrac{1}{2}k\\,x(t)^2.$$ For each parameter set below, integrate the system from time $t=0$ to time $t=T$ with the initial conditions $x(0)=A$ and $v(0)=V_0$. For each case, compute three quantities:\n1) the final-to-initial energy ratio $R = E(T)/E(0)$, rounded to six decimal places,\n2) a boolean $M$ indicating whether the discrete energy sequence along the computed trajectory is nonincreasing within a per-step absolute tolerance $\\tau = 10^{-9}$, that is, $E_{n+1} \\le E_n + \\tau$ for all successive sampled times,\n3) the integer number $Z$ of zero-crossings of $x(t)$ over $t \\in [0,T]$ (count sign changes of $x$; values of $x$ whose magnitude is below a threshold should be treated as zero to avoid counting numerical noise; you must use a fixed absolute threshold of $10^{-8}$).\n\nUse the following test suite of parameter sets, each specified as $(A, V_0, b, k, T)$:\n- Case $1$: $(1, 0, 0, 1, 40)$,\n- Case $2$: $(1, 0, 0.1, 1, 40)$,\n- Case $3$: $(1, 0, 1, 1, 40)$,\n- Case $4$: $(0, 2, 0.5, 1, 40)$,\n- Case $5$: $(2, 0, 0.5, 1, 40)$.\n\nYour program must output a single line containing a list of results, one per case, where each result is a list $[R,M,Z]$ in that order. The overall output must therefore be a single line of the form\n[[R1,M1,Z1],[R2,M2,Z2],[R3,M3,Z3],[R4,M4,Z4],[R5,M5,Z5]]\nwith no additional text. All computations and outputs are dimensionless, and no physical units are required.",
            "solution": "The problem presented is a well-defined initial value problem in computational physics, requiring the numerical integration of a system of coupled first-order ordinary differential equations (ODEs). The problem is scientifically grounded, internally consistent, and contains all necessary information to proceed with a unique solution. Therefore, it is deemed valid.\n\nThe governing equation for the one-dimensional mass–spring oscillator with quadratic damping is given as:\n$$m\\,\\ddot{x}(t) + k\\,x(t) + b\\,\\dot{x}(t)\\lvert \\dot{x}(t)\\rvert = 0$$\nwhere $x(t)$ is the displacement, $m$ is the mass, $k$ is the spring constant, and $b$ is the nonlinear damping coefficient. The problem specifies using dimensionless units by setting the mass $m=1$.\n\nTo solve this second-order ODE numerically, we convert it into a system of two first-order ODEs. We define a state vector $y(t)$ and its components as:\n$$y(t) = \\begin{pmatrix} y_0(t) \\\\ y_1(t) \\end{pmatrix} = \\begin{pmatrix} x(t) \\\\ v(t) \\end{pmatrix}$$\nwhere $v(t) = \\dot{x}(t)$ is the velocity. The time derivatives of these components form the system:\n$$\n\\begin{align*}\n\\dot{y_0}(t) &= \\dot{x}(t) = v(t) = y_1(t) \\\\\n\\dot{y_1}(t) &= \\dot{v}(t) = \\ddot{x}(t) = -k\\,x(t) - b\\,v(t)\\lvert v(t)\\rvert = -k\\,y_0(t) - b\\,y_1(t)\\lvert y_1(t)\\rvert\n\\end{align*}\n$$\nThis system, $\\dot{y}(t) = f(t, y(t))$, can be integrated numerically given initial conditions $y(0) = (x(0), v(0)) = (A, V_0)$.\n\nThe total mechanical energy of the system is defined as the sum of kinetic and potential energy:\n$$E(t) = \\frac{1}{2}m\\,v(t)^2 + \\frac{1}{2}k\\,x(t)^2$$\nWith $m=1$, this becomes:\n$$E(t) = \\frac{1}{2}v(t)^2 + \\frac{1}{2}k\\,x(t)^2$$\nThe rate of change of energy, $\\dot{E}(t)$, reveals the dissipative nature of the damping force. Differentiating $E(t)$ with respect to time gives:\n$$\\dot{E}(t) = v(t)\\,\\dot{v}(t) + k\\,x(t)\\,\\dot{x}(t)$$\nSubstituting $\\dot{x}(t) = v(t)$ and $\\dot{v}(t) = -k\\,x(t) - b\\,v(t)\\lvert v(t)\\rvert$:\n$$\\dot{E}(t) = v(t) \\left( -k\\,x(t) - b\\,v(t)\\lvert v(t)\\rvert \\right) + k\\,x(t)\\,v(t)$$\n$$\\dot{E}(t) = -k\\,x(t)v(t) - b\\,v(t)^2\\lvert v(t)\\rvert + k\\,x(t)v(t)$$\n$$\\dot{E}(t) = -b\\,v(t)^2\\lvert v(t)\\rvert$$\nSince the damping coefficient $b \\ge 0$ and the term $v(t)^2\\lvert v(t)\\rvert \\ge 0$, the rate of change of energy $\\dot{E}(t)$ is always less than or equal to zero. This confirms that the mechanical energy is a non-increasing function of time. Energy is conserved only if $b=0$. This physical principle provides a basis for validating the numerical solution via the monotonicity check, $M$.\n\nThe solution will be obtained by employing a high-precision numerical integrator. The `scipy.integrate.solve_ivp` function is well-suited for this task. To ensure accuracy for the required calculations, particularly the energy monotonicity check (with tolerance $\\tau=10^{-9}$) and the zero-crossing count, tight relative and absolute tolerances (e.g., $10^{-12}$) for the solver are necessary. Furthermore, the solution must be evaluated on a fine time grid to reliably capture all zero-crossings.\n\nThe algorithm for each test case is as follows:\n1.  Define the system of ODEs as a Python function `f(t, y, b, k)`.\n2.  Use `scipy.integrate.solve_ivp` to integrate the system from $t=0$ to $t=T$ with the given initial conditions $(A, V_0)$ and parameters $(b, k)$. A dense time grid for evaluation is specified using the `t_eval` argument.\n3.  From the numerical solution for $x(t_i)$ and $v(t_i)$, calculate the required quantities:\n    a.  **Energy Ratio ($R$)**: Compute the initial energy $E(0) = \\frac{1}{2}V_0^2 + \\frac{1}{2}kA^2$ and final energy $E(T) = \\frac{1}{2}v(T)^2 + \\frac{1}{2}k\\,x(T)^2$. The ratio is $R = E(T)/E(0)$, rounded to six decimal places.\n    b.  **Energy Monotonicity ($M$)**: Compute the energy $E(t_i)$ at each time step $t_i$. Iterate through the sequence and verify if $E(t_{i+1}) \\le E(t_i) + \\tau$ for all $i$, where the tolerance $\\tau = 10^{-9}$. $M$ is `True` if the condition holds for all steps, and `False` otherwise.\n    c.  **Zero-Crossings ($Z$)**: To count the number of times $x(t)$ crosses zero, we first filter the position array $x(t_i)$ to remove points where the magnitude is below the specified threshold of $10^{-8}$. This prevents numerical noise near zero from being counted as a crossing. Then, we count the number of times the sign of consecutive elements in this filtered array changes. This is robustly implemented by checking where the product of consecutive elements is negative.\n\nThis procedure is applied to each of the five specified parameter sets to generate the final output.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves the mass-spring oscillator problem for a suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (A, V0, b, k, T)\n    test_cases = [\n        (1.0, 0.0, 0.0, 1.0, 40.0),   # Case 1\n        (1.0, 0.0, 0.1, 1.0, 40.0),   # Case 2\n        (1.0, 0.0, 1.0, 1.0, 40.0),   # Case 3\n        (0.0, 2.0, 0.5, 1.0, 40.0),   # Case 4\n        (2.0, 0.0, 0.5, 1.0, 40.0),   # Case 5\n    ]\n\n    results = []\n    \n    # Define constants from the problem\n    energy_monotonicity_tolerance = 1e-9\n    zero_crossing_threshold = 1e-8\n    \n    # Number of points for the time evaluation grid.\n    # A high number is chosen to ensure accuracy for zero-crossing and monotonicity checks.\n    num_points = 20001\n            \n    for case in test_cases:\n        A, V0, b, k, T = case\n\n        # Define the system of first-order ODEs\n        # y[0] = x, y[1] = v\n        # dx/dt = v\n        # dv/dt = -k*x - b*v*|v|\n        def ode_system(t, y, b_param, k_param):\n            x, v = y\n            dxdt = v\n            dvdt = -k_param * x - b_param * v * abs(v)\n            return [dxdt, dvdt]\n\n        # Set initial conditions\n        y0 = [A, V0]\n        \n        # Set time span and evaluation points\n        t_span = [0, T]\n        t_eval = np.linspace(t_span[0], t_span[1], num_points)\n\n        # Solve the ODE system\n        # Use tight tolerances for high accuracy\n        sol = solve_ivp(\n            ode_system, \n            t_span, \n            y0, \n            args=(b, k), \n            t_eval=t_eval, \n            rtol=1e-12, \n            atol=1e-12,\n            method='DOP853' # A high-order accurate method\n        )\n        \n        x_t = sol.y[0, :]\n        v_t = sol.y[1, :]\n\n        # 1. Calculate final-to-initial energy ratio (R)\n        E_t = 0.5 * v_t**2 + 0.5 * k * x_t**2\n        E0 = E_t[0]\n        ET = E_t[-1]\n        \n        # Handle the theoretical case of zero initial energy to avoid division by zero.\n        # This is not triggered by the given test cases.\n        if E0 == 0:\n            R = 0.0 if ET == 0 else float('inf')\n        else:\n            R = round(ET / E0, 6)\n\n        # 2. Check for energy monotonicity (M)\n        M = True\n        for i in range(len(E_t) - 1):\n            if E_t[i+1] > E_t[i] + energy_monotonicity_tolerance:\n                M = False\n                break\n        \n        # 3. Count zero-crossings (Z)\n        # Filter out values whose magnitude is below the threshold\n        x_filtered = x_t[np.abs(x_t) > zero_crossing_threshold]\n        \n        if len(x_filtered)  2:\n            Z = 0\n        else:\n            # A sign change occurs where sign(x_i) != sign(x_{i+1})\n            Z = np.sum(np.sign(x_filtered[:-1]) != np.sign(x_filtered[1:]))\n\n        results.append([R, M, Z])\n\n    # Final print statement in the exact required format.\n    # repr() produces a string representation that includes brackets and commas.\n    # .replace(\" \", \"\") removes all spaces to match the required dense format.\n    print(repr(results).replace(\" \", \"\"))\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "Real-world dynamics are not always smooth. This exercise models a bouncing ball, a system whose evolution is punctuated by discrete events—the impacts with the ground. You will learn to simulate such a hybrid system by integrating the continuous motion between bounces and using event-finding capabilities of modern ODE solvers to handle the instantaneous velocity change at impact. This practice is key to modeling a wide range of phenomena, from mechanical collisions to switching circuits .",
            "id": "2444852",
            "problem": "Consider a rigid point-mass ball constrained to one-dimensional vertical motion under a uniform gravitational field. Let the vertical position be $y(t)$ in meters and the vertical velocity be $v(t)$ in meters per second. Between impacts with a perfectly rigid, horizontal ground at $y=0$, the motion obeys Newton's second law with optional linear air drag, resulting in the coupled system of first-order Ordinary Differential Equations (ODEs): \n$$\n\\frac{d y}{d t} = v, \\qquad \\frac{d v}{d t} = -g - \\frac{c}{m} v,\n$$\nwhere $g$ is the magnitude of the gravitational acceleration in meters per second squared, $c$ is the linear drag coefficient in kilogram per second, and $m$ is the mass in kilogram. An impact occurs when $y(t) = 0$ with $v(t^-)  0$, at which point the post-impact velocity satisfies the impact map\n$$\nv(t^+) = - e \\, v(t^-),\n$$\nwhere $0 \\le e  1$ is the coefficient of restitution (dimensionless). The position is continuous, so $y(t^+) = y(t^-) = 0$. For the special case $e = 0$, after the first impact, the ball remains at $y(t) = 0$ with $v(t) = 0$ for all subsequent times.\n\nGiven initial conditions $y(0) = y_0$ and $v(0) = v_0$, simulate the motion until a specified final time $T$ and determine the following for each parameter set:\n- The total number of impacts $N$ that have occurred in the interval $[0,T]$.\n- The final position $y(T)$ in meters.\n- The final velocity $v(T)$ in meters per second.\n\nAll outputs must use the International System of Units (SI). Report $y(T)$ in meters and $v(T)$ in meters per second. Express $y(T)$ and $v(T)$ rounded to exactly six decimal places. The integer $N$ should be reported as an integer without rounding. Angles do not appear in this problem.\n\nUse the following constant gravitational acceleration for all cases: $g = 9.81$ meters per second squared.\n\nTest suite parameter sets to be evaluated, each specified as $(y_0, v_0, e, c, m, T)$ with units $(\\text{m}, \\text{m/s}, -, \\text{kg/s}, \\text{kg}, \\text{s})$:\n- Case A (general case, no drag): $(y_0, v_0, e, c, m, T) = (10.0, 0.0, 0.8, 0.0, 1.0, 5.0)$.\n- Case B (linear drag present, upward initial velocity): $(y_0, v_0, e, c, m, T) = (2.0, 1.0, 0.9, 0.1, 0.2, 3.0)$.\n- Case C (perfectly inelastic impacts): $(y_0, v_0, e, c, m, T) = (1.0, 0.0, 0.0, 0.0, 1.0, 2.0)$.\n- Case D (short horizon, no impact expected): $(y_0, v_0, e, c, m, T) = (0.5, 4.0, 0.7, 0.0, 1.0, 0.3)$.\n\nYour program must compute, for each case, the triple $[N, y(T), v(T)]$, where $N$ is an integer, and $y(T)$ and $v(T)$ are floats rounded to six decimal places. The final program output must aggregate the four case results, in the same order as listed above, into a single line formatted exactly as a comma-separated list of lists enclosed in square brackets. For example, the output should look like\n$[ [N_A, y_A, v_A], [N_B, y_B, v_B], [N_C, y_C, v_C], [N_D, y_D, v_D] ]$\nwith $y_{\\cdot}$ in meters and $v_{\\cdot}$ in meters per second, where each float is rounded to six decimal places and each $N$ is an integer.",
            "solution": "The vertical motion is governed by Newton's second law, and modeling it as a system of coupled first-order Ordinary Differential Equations (ODEs) is standard. Let $y(t)$ denote the vertical position and $v(t)$ the vertical velocity. The kinematic relation yields $\\frac{d y}{d t} = v$. The dynamic equation follows from Newton's second law, $m \\frac{d v}{d t} = - m g - c v$, where the forces are gravity of magnitude $m g$ and linear drag $c v$ opposing the motion. Dividing by $m$ produces the first-order system\n$$\n\\frac{d y}{d t} = v, \\qquad \\frac{d v}{d t} = -g - \\frac{c}{m} v.\n$$\n\nThe ground is an impenetrable boundary at $y=0$; thus, when the solution reaches $y=0$ with downward velocity $v(t^-)  0$, a mechanical impact occurs. We model the impact as instantaneous with a coefficient of restitution $e \\in [0,1)$, which scales the normal relative speed at impact. The post-impact velocity is\n$$\nv(t^+) = - e \\, v(t^-),\n$$\nwhile the position remains continuous through the impact, $y(t^+) = y(t^-) = 0$. For $e=0$, energy is maximally dissipated at the first impact and the velocity becomes zero; a rigid ground then prevents penetration, so the ball remains at $y=0$ with $v=0$ for all subsequent times, consistent with $y(t) = 0$ and $v(t) = 0$ for $t$ after the first impact.\n\nThis is a hybrid dynamical system: continuous evolution governed by the ODEs on the open set $\\{ y  0\\}$, and discrete jumps in $v$ at the boundary $\\{ y = 0, v  0\\}$. To simulate it up to a final time $T$, we proceed as follows in principle:\n- Start from the initial condition $(y(0), v(0)) = (y_0, v_0)$.\n- Evolve the ODE system forward in time while $y(t)  0$. This evolution is well-posed because the right-hand side is Lipschitz continuous in $(y, v)$.\n- Detect the first time $t_\\star$ at which $y(t_\\star) = 0$ with $v(t_\\star^-)  0$. At this time, apply the impact map to get $(y(t_\\star^+), v(t_\\star^+)) = (0, - e \\, v(t_\\star^-))$. Increment the impact counter $N$ by one.\n- Restart the ODE evolution from $(0, v(t_\\star^+))$. If $e=0$, then after the first impact $v(t_\\star^+) = 0$, and the system sticks at $y=0$, $v=0$ for all subsequent time; hence one can directly set $(y(T), v(T)) = (0,0)$ with $N=1$ for any $T \\ge t_\\star$.\n- Repeat the process of continuous evolution and discrete impact updates until the final time $T$ is reached. The final state $(y(T), v(T))$ is the state obtained at time $T$, and the total number of impacts $N$ is the count of impact events in $[0, T]$.\n\nBetween impacts, the exact solution can be written in closed form if desired. For instance, with linear drag, the velocity solution is\n$$\nv(t) = \\left(v(t_0) + \\frac{m g}{c}\\right) e^{-\\frac{c}{m}(t - t_0)} - \\frac{m g}{c},\n$$\nand the corresponding position is obtained by integrating $v(t)$ once. However, because of impacts at unknown times, a general numerical method that detects when $y(t)$ reaches $0$ (from above with $v0$) and then applies the impact rule is the most robust approach. The event condition is simply $y(t) = 0$ with required sign of the velocity. Each event triggers the discrete jump $v \\mapsto -e v$ and increments the count $N$ by one.\n\nFor each test case, the inputs $(y_0, v_0, e, c, m, T)$ are specified in SI units, and $g = 9.81$ in meters per second squared is fixed. The simulation yields for each case:\n- The integer number of impacts $N$ in $[0, T]$.\n- The final state $(y(T), v(T))$ in meters and meters per second, respectively.\n\nFinally, round $y(T)$ and $v(T)$ to six decimal places. Aggregate the four triples in the order of the given test suite into a single list-of-lists printed on one line, in the exact format required. This approach directly implements the physical model of a bouncing ball with dissipation both during flight (via linear drag) and at impact (via the coefficient of restitution), formulated as a system of coupled first-order ODEs with a boundary-triggered state reset at impacts.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef simulate_case(y0, v0, e, c, m, T, g=9.81):\n    \"\"\"\n    Simulate the hybrid ODE system for a bouncing ball with linear drag and\n    coefficient of restitution e, up to time T.\n\n    Parameters:\n        y0 (float): initial height [m]\n        v0 (float): initial vertical velocity [m/s]\n        e (float): coefficient of restitution in [0,1)\n        c (float): linear drag coefficient [kg/s]\n        m (float): mass [kg]\n        T (float): final time [s]\n        g (float): gravitational acceleration [m/s^2]\n\n    Returns:\n        (N, yT, vT): number of impacts, final height, final velocity\n    \"\"\"\n    # Continuous dynamics between impacts: dy/dt = v, dv/dt = -g - (c/m) v\n    c_over_m = c / m if m != 0 else 0.0\n\n    def f(t, s):\n        y, v = s\n        return np.array([v, -g - c_over_m * v])\n\n    # Event for hitting the ground from above (downward crossing)\n    def ground_event(t, s):\n        # Event when y = 0; we only want downward crossings to avoid spurious triggers\n        return s[0]\n\n    ground_event.terminal = True\n    ground_event.direction = -1\n\n    # Initialize\n    t = 0.0\n    s = np.array([y0, v0], dtype=float)\n    impacts = 0\n\n    # If initially below ground (should not happen), project to ground\n    if s[0]  0.0:\n        s[0] = 0.0\n\n    # Main loop: integrate piecewise between impacts until time T\n    while t  T:\n        # If at ground with nonpositive velocity, and e == 0 implies sticking immediately.\n        # Otherwise, evolve as usual; the event function will handle impacts properly.\n        # Integrate until next event or final time\n        sol = solve_ivp(\n            f,\n            (t, T),\n            s,\n            method=\"RK45\",\n            rtol=1e-10,\n            atol=1e-12,\n            events=ground_event,\n            dense_output=False,\n            max_step=np.inf\n        )\n\n        # Update current time and state to the end of this segment\n        t = float(sol.t[-1])\n        s = sol.y[:, -1].copy()\n\n        # Numerical safety: avoid tiny negative heights from integration error\n        if s[0]  0 and abs(s[0])  1e-12:\n            s[0] = 0.0\n\n        # If an impact occurred, apply the restitution law\n        if sol.t_events and len(sol.t_events[0]) > 0:\n            # At the event, y = 0 by definition. Use the state at event time for pre-impact velocity.\n            t_event = float(sol.t_events[0][-1])\n            # The solver state at the last time equals the event state because terminal=True\n            # But to be robust, force y to exactly 0 at event.\n            s[0] = 0.0\n            v_pre = float(sol.y[1, -1])\n            # Only count true downward impacts (v_pre  0)\n            if v_pre  0.0:\n                impacts += 1\n                # Apply impact map\n                v_post = -e * v_pre\n                # Handle perfectly inelastic case: stick at ground after first impact\n                if e == 0.0:\n                    # Remain at rest at the ground for the rest of the interval\n                    s = np.array([0.0, 0.0], dtype=float)\n                    t = T\n                    break\n                else:\n                    s = np.array([0.0, v_post], dtype=float)\n                    # Proceed to integrate from the event time\n                    t = t_event\n            else:\n                # No valid downward impact; continue\n                pass\n\n        # If no impact and we reached final time, exit\n        if t >= T or (not sol.t_events) or (len(sol.t_events[0]) == 0):\n            # Already updated t and s to end of integration segment\n            if t >= T:\n                break\n            # Otherwise, continue; loop will integrate the remaining time\n            # If the solver ended early without event due to numerical reasons, continue\n            # But with given settings, this should not happen.\n            pass\n\n    # Ensure we have the state at T: If we exited due to reaching T during integration, s is already at T.\n    # If we exited due to e == 0 sticking, s is set to [0, 0] at T.\n    yT, vT = float(s[0]), float(s[1])\n\n    return impacts, yT, vT\n\ndef fmt_float(x):\n    # Round to six decimals and avoid printing negative zero\n    if abs(x)  0.5e-6:\n        x = 0.0\n    return f\"{x:.6f}\"\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each tuple: (y0, v0, e, c, m, T)\n    test_cases = [\n        (10.0, 0.0, 0.8, 0.0, 1.0, 5.0),  # Case A\n        (2.0, 1.0, 0.9, 0.1, 0.2, 3.0),   # Case B\n        (1.0, 0.0, 0.0, 0.0, 1.0, 2.0),   # Case C\n        (0.5, 4.0, 0.7, 0.0, 1.0, 0.3),   # Case D\n    ]\n\n    results = []\n    for case in test_cases:\n        y0, v0, e, c, m, T = case\n        N, yT, vT = simulate_case(y0, v0, e, c, m, T, g=9.81)\n        # Round the floats to exactly six decimal places for output\n        results.append([N, fmt_float(yT), fmt_float(vT)])\n\n    # Build the exact required single-line output as a list of lists\n    # Ensure integers are printed as integers, floats with six decimals\n    out_items = []\n    for item in results:\n        N_str = str(item[0])\n        y_str = item[1]\n        v_str = item[2]\n        out_items.append(f\"[{N_str},{y_str},{v_str}]\")\n    print(f\"[{','.join(out_items)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "We now scale up from single-particle dynamics to the collective behavior of a many-body system. This exercise challenges you to recreate the famous Fermi-Pasta-Ulam-Tsingou (FPU) experiment, simulating a chain of masses coupled by nonlinear springs. By initializing the system in a single long-wavelength mode and tracking the energy distribution among all modes, you will explore the surprising and profound FPU recurrence phenomenon. This practice demonstrates how systems of coupled ODEs can be used to investigate complex, emergent behavior at the frontier of chaos and statistical mechanics .",
            "id": "2444879",
            "problem": "Consider a one-dimensional Fermi-Pasta-Ulam-Tsingou (FPUT) $\\alpha$-model consisting of a chain of $N$ identical point masses with fixed boundary conditions and nearest-neighbor springs that include a weak nonlinear correction. Let $u_n(t)$ denote the displacement of the $n$-th mass from equilibrium at time $t$, for $n \\in \\{1,2,\\dots,N\\}$, and let $v_n(t) = \\dot{u}_n(t)$ denote its velocity. The end points satisfy fixed boundaries $u_0(t) = 0$ and $u_{N+1}(t) = 0$ for all $t$. Assume unit mass and unit linear spring constant so that all quantities are dimensionless.\n\nThe equations of motion are the coupled first-order system\n$\n\\dot{u}_n = v_n,\n$\n$\n\\dot{v}_n = \\left(u_{n+1} - 2u_n + u_{n-1}\\right) + \\alpha\\left[\\left(u_{n+1} - u_n\\right)^2 - \\left(u_n - u_{n-1}\\right)^2\\right],\n$\nfor $n \\in \\{1,2,\\dots,N\\}$, with $u_0 = 0$ and $u_{N+1} = 0$, where $\\alpha$ is the nonlinearity parameter.\n\nDefine the linear normal modes of the corresponding purely linear chain (i.e., with $\\alpha = 0$) by\n$\n\\phi_k(n) = \\sqrt{\\frac{2}{N+1}} \\sin\\!\\left(\\frac{k\\pi n}{N+1}\\right),\n$\nwith modal frequencies\n$\n\\omega_k = 2\\sin\\!\\left(\\frac{k\\pi}{2(N+1)}\\right),\n$\nfor $k \\in \\{1,2,\\dots,N\\}$. For any state $\\{u_n,v_n\\}_{n=1}^N$, define the linear modal coordinates\n$\nq_k = \\sum_{n=1}^{N} u_n \\, \\phi_k(n), \\quad p_k = \\sum_{n=1}^{N} v_n \\, \\phi_k(n),\n$\nand the associated linear modal energies\n$\nE_k = \\frac{1}{2}\\left(p_k^2 + \\omega_k^2 q_k^2\\right).\n$\nLet $E_{\\mathrm{sum}}(t) = \\sum_{k=1}^{N} E_k(t)$ and let $E_1(t)$ denote the energy of the first mode. The initial condition is a single-mode excitation in the first linear mode with zero initial velocities:\n$\nu_n(0) = A \\sin\\!\\left(\\frac{\\pi n}{N+1}\\right), \\quad v_n(0) = 0,\n$\nfor all $n \\in \\{1,2,\\dots,N\\}$, where $A$ is the initial amplitude.\n\nDefine a recurrence detection criterion as follows. Given tolerance parameters $\\epsilon \\in (0,1)$ and $\\eta \\in (0,1)$ and a time horizon $T_{\\max}  0$, a recurrence is said to be observed if there exist times $t_a$ and $t_b$ with $0  t_a  t_b \\le T_{\\max}$ such that:\n- Departure: $E_1(t_a)/E_{\\mathrm{sum}}(t_a) \\le 1 - \\eta$,\n- Return: $E_1(t_b)/E_{\\mathrm{sum}}(t_b) \\ge 1 - \\epsilon$,\nand $t_b$ is the smallest time satisfying the return condition that occurs after some departure time $t_a$. The recurrence time is defined to be $t_b$. If no such $t_b$ exists in the interval $(0, T_{\\max}]$, the recurrence time is defined to be $-1$.\n\nAll quantities are dimensionless. Report all times in dimensionless units as real numbers.\n\nTest Suite. For each of the following parameter sets $(N,\\alpha,A,T_{\\max},\\epsilon,\\eta)$, compute the recurrence time as defined above:\n- Case $1$: $(N,\\alpha,A,T_{\\max},\\epsilon,\\eta) = (8,\\,0.25,\\,0.3,\\,300,\\,0.1,\\,0.1)$.\n- Case $2$: $(N,\\alpha,A,T_{\\max},\\epsilon,\\eta) = (8,\\,0,\\,0.3,\\,100,\\,0.1,\\,0.1)$.\n- Case $3$: $(N,\\alpha,A,T_{\\max},\\epsilon,\\eta) = (8,\\,1.0,\\,0.3,\\,300,\\,0.1,\\,0.1)$.\n\nFinal Output Format. Your program should produce a single line of output containing the three recurrence times for the cases above, as a comma-separated list enclosed in square brackets, for example, $[t_1,t_2,t_3]$, where each $t_i$ is a real number in dimensionless units and equals $-1$ if no recurrence is observed within the specified horizon.",
            "solution": "The problem presented is a well-posed and scientifically sound exercise in computational physics. It requires the numerical integration of the equations of motion for the Fermi-Pasta-Ulam-Tsingou (FPUT) $\\alpha$-model, followed by an analysis of the system's trajectory in linear normal mode space to determine a recurrence time. The problem is self-contained, with all parameters, equations, initial conditions, and analysis criteria explicitly defined. It is a canonical problem in the study of nonlinear dynamics and is free from any scientific or logical flaws. We may therefore proceed with a solution.\n\nThe core of the problem is to solve a system of $2N$ coupled first-order ordinary differential equations (ODEs). Let the state of the system be represented by a vector $Y(t) \\in \\mathbb{R}^{2N}$, where $Y = [u_1, \\dots, u_N, v_1, \\dots, v_N]^T$. The components $u_n(t)$ are the displacements and $v_n(t) = \\dot{u}_n(t)$ are the velocities of the $N$ masses. The time evolution of the system is governed by $\\dot{Y}(t) = f(t, Y)$. The function $f(t, Y)$ is derived from the equations of motion:\n$$\n\\dot{u}_n = v_n\n$$\n$$\n\\dot{v}_n = (u_{n+1} - 2u_n + u_{n-1}) + \\alpha\\left[(u_{n+1} - u_n)^2 - (u_n - u_{n-1})^2\\right]\n$$\nThese equations hold for $n \\in \\{1, \\dots, N\\}$, with the fixed boundary conditions $u_0(t) = 0$ and $u_{N+1}(t) = 0$. The state vector derivative $\\dot{Y}$ can be constructed by setting its first $N$ components to $[v_1, \\dots, v_N]$ and its last $N$ components to $[\\dot{v}_1, \\dots, \\dot{v}_N]$, where $\\dot{v}_n$ is calculated using the formula above. For numerical implementation, the boundary conditions are handled by creating a padded displacement array $[0, u_1, \\dots, u_N, 0]$.\n\nTo solve this initial value problem, we employ a high-quality numerical ODE solver. The `solve_ivp` function from the SciPy library is an appropriate choice, as it provides robust, adaptive-step-size integration methods (such as the Runge-Kutta-Fehlberg method, RK45) suitable for the oscillatory nature of this system. We set stringent relative and absolute error tolerances (e.g., $10^{-9}$) to ensure the numerical trajectory is accurate over the specified time horizon $T_{\\max}$. The `dense_output=True` option is utilized to obtain a continuous representation of the solution, which can then be evaluated at a high frequency of points for analysis.\n\nThe initial condition is specified as a pure excitation of the first linear normal mode with zero initial velocities:\n$$\nu_n(0) = A \\sin\\left(\\frac{\\pi n}{N+1}\\right), \\quad v_n(0) = 0\n$$\nThis defines the initial state vector $Y(0)$.\n\nAfter numerically integrating the system from $t=0$ to $t=T_{\\max}$, the resulting trajectory $\\{u_n(t), v_n(t)\\}$ must be analyzed in the basis of the linear normal modes. The modal coordinates $(q_k, p_k)$ are obtained via a linear transformation:\n$$\nq_k(t) = \\sum_{n=1}^{N} u_n(t) \\phi_k(n), \\quad p_k(t) = \\sum_{n=1}^{N} v_n(t) \\phi_k(n)\n$$\nwhere $\\phi_k(n) = \\sqrt{\\frac{2}{N+1}} \\sin\\left(\\frac{k\\pi n}{N+1}\\right)$ are the orthonormal mode shapes. This transformation can be efficiently computed as a matrix-vector product, $q(t) = T u(t)$ and $p(t) = T v(t)$, where $T$ is the transformation matrix with elements $T_{kn} = \\phi_k(n)$.\n\nFrom these modal coordinates, the linear modal energies $E_k(t)$ are calculated:\n$$\nE_k(t) = \\frac{1}{2}\\left(p_k(t)^2 + \\omega_k^2 q_k(t)^2\\right)\n$$\nwhere $\\omega_k = 2\\sin\\left(\\frac{k\\pi}{2(N+1)}\\right)$ are the linear mode frequencies. The quantity of interest is the ratio of the energy in the first mode to the sum of all linear modal energies, $R(t) = E_1(t) / E_{\\mathrm{sum}}(t)$, where $E_{\\mathrm{sum}}(t) = \\sum_{k=1}^{N} E_k(t)$. It is important to note that for the nonlinear system ($\\alpha \\ne 0$), $E_{\\mathrm{sum}}(t)$ is not a conserved quantity, unlike the true total Hamiltonian of the system.\n\nFinally, the recurrence time is determined by analyzing the time series of the ratio $R(t)$. According to the problem definition, we must find the smallest time $t_b \\in (0, T_{\\max}]$ such that $R(t_b) \\ge 1 - \\epsilon$, with the condition that there exists some prior time $t_a \\in (0, t_b)$ where $R(t_a) \\le 1 - \\eta$. This is implemented by iterating through the computed time points, first waiting for the `departure` condition ($R(t) \\le 1 - \\eta$) to be met, and then searching for the first subsequent time that satisfies the `return` condition ($R(t) \\ge 1 - \\epsilon$). If no such event sequence occurs within the time horizon, the recurrence time is defined as $-1$.\n\nFor the special case where $\\alpha=0$ (Case 2), the system is linear, and the normal modes are uncoupled. Since the initial condition excites only the first mode, all energy remains in that mode for all time. Thus, $E_k(t) = 0$ for $k  1$, and $E_1(t)$ is constant. The ratio $R(t)$ is identically $1$ for all $t$. Consequently, the departure condition $R(t) \\le 1 - \\eta$ (for $\\eta  0$) is never satisfied, and the recurrence time is, by definition, $-1$. This known analytical result serves as a valuable validation for our understanding of the problem.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef find_recurrence_time(N, alpha, A, T_max, epsilon, eta):\n    \"\"\"\n    Computes the FPUT recurrence time for a given set of parameters.\n    \"\"\"\n    # For the linear case (alpha=0), the modes are uncoupled.\n    # The initial condition is a pure mode 1 excitation, so energy never leaves\n    # mode 1. The departure condition is never met.\n    if alpha == 0:\n        return -1.0\n\n    # 1. Pre-calculate constants for the given N\n    N_plus_1 = N + 1\n    k = np.arange(1, N + 1)\n    n = np.arange(1, N + 1)\n    \n    # Square of angular frequencies for linear modes\n    omega_k_sq = (2 * np.sin(k * np.pi / (2 * N_plus_1)))**2\n    \n    # Modal transformation matrix T_kn = phi_k(n)\n    k_col = k[:, np.newaxis]\n    n_row = n[np.newaxis, :]\n    T_matrix = np.sqrt(2 / N_plus_1) * np.sin(k_col * np.pi * n_row / N_plus_1)\n    \n    # 2. Define the initial state vector Y0 = [u0, v0]\n    u0 = A * np.sin(np.pi * n / N_plus_1)\n    v0 = np.zeros(N)\n    Y0 = np.concatenate((u0, v0))\n    \n    # 3. Define the derivative function for the ODE system\n    def fput_eom(t, Y, N_val, alpha_val):\n        u = Y[:N_val]\n        v = Y[N_val:]\n        \n        dudt = v\n        \n        # Pad u with fixed boundaries u_0 = 0, u_{N+1} = 0\n        u_padded = np.concatenate(([0], u, [0]))\n        \n        # Linear part of acceleration\n        accel_linear = u_padded[2:] - 2 * u_padded[1:-1] + u_padded[:-2]\n        \n        # Nonlinear part of acceleration\n        diff_u = np.diff(u_padded)  # u_{i+1} - u_i\n        accel_nonlinear = alpha_val * (diff_u[1:]**2 - diff_u[:-1]**2)\n        \n        dvdt = accel_linear + accel_nonlinear\n        \n        return np.concatenate((dudt, dvdt))\n\n    # 4. Integrate the ODE system using a high-precision solver\n    sol = solve_ivp(\n        fput_eom, \n        [0, T_max], \n        Y0, \n        args=(N, alpha), \n        dense_output=True, \n        rtol=1e-9,  # Relative tolerance\n        atol=1e-9   # Absolute tolerance\n    )\n    \n    # 5. Post-process the solution to find recurrence\n    # Evaluate the solution on a fine time grid for analysis\n    num_eval_points = int(T_max * 20) + 1  # Use a fine grid for accuracy\n    t_eval = np.linspace(0, T_max, num_eval_points)\n    Y_t = sol.sol(t_eval)\n    \n    u_t = Y_t[:N, :]\n    v_t = Y_t[N:, :]\n    \n    # Transform to modal coordinates (q, p)\n    q_t = T_matrix @ u_t\n    p_t = T_matrix @ v_t\n    \n    # Calculate linear modal energies E_k(t)\n    # The term omega_k_sq[:, np.newaxis] ensures correct broadcasting\n    E_k_t = 0.5 * (p_t**2 + omega_k_sq[:, np.newaxis] * q_t**2)\n    \n    E1_t = E_k_t[0, :]\n    E_sum_t = np.sum(E_k_t, axis=0)\n    \n    # To prevent division by zero, although not expected for this problem\n    E_sum_t[E_sum_t == 0] = 1.0\n    \n    ratio_t = E1_t / E_sum_t\n    \n    # 6. Find the recurrence time based on the problem's definition\n    departure_threshold = 1.0 - eta\n    return_threshold = 1.0 - epsilon\n    \n    departure_observed = False\n    for i, t in enumerate(t_eval):\n        if t == 0:\n            continue\n        \n        # Check for departure condition\n        if not departure_observed and ratio_t[i] = departure_threshold:\n            departure_observed = True\n            \n        # If departed, check for return condition\n        if departure_observed and ratio_t[i] >= return_threshold:\n            return round(t, 4)  # Return first time return condition is met after departure\n            \n    return -1.0  # No recurrence found within T_max\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, alpha, A, T_max, epsilon, eta)\n        (8, 0.25, 0.3, 300, 0.1, 0.1),\n        (8, 0.0, 0.3, 100, 0.1, 0.1),\n        (8, 1.0, 0.3, 300, 0.1, 0.1),\n    ]\n\n    results = []\n    for case in test_cases:\n        recurrence_time = find_recurrence_time(*case)\n        results.append(recurrence_time)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}