{
    "hands_on_practices": [
        {
            "introduction": "Our journey into hands-on practice begins with a system familiar to every physicist: the mass-spring oscillator. This exercise moves beyond the idealized linear model to a more realistic scenario involving nonlinear damping, a force common in fluid dynamics. By converting this second-order ODE into a system of two first-order equations, you will practice the fundamental skill at the heart of this topic and use your numerical solution to verify a core physical principle: the dissipation of energy. ",
            "id": "2444882",
            "problem": "A one-dimensional mass–spring oscillator with quadratic velocity-proportional damping is governed by the second-order ordinary differential equation (ODE), where the damping force is nonlinear: $$m\\,\\ddot{x}(t) + k\\,x(t) + b\\,\\dot{x}(t)\\lvert \\dot{x}(t)\\rvert = 0,$$ with displacement $x(t)$, velocity $\\dot{x}(t)$, mass $m$, spring constant $k$, and nonlinear damping coefficient $b \\ge 0$. Work in dimensionless units by setting $m=1$. Convert this to a system of coupled first-order ODEs by defining the state vector $y(t) = \\big(x(t), v(t)\\big)$ with $v(t) = \\dot{x}(t)$. The system is $$\\dot{x}(t) = v(t), \\quad \\dot{v}(t) = -k\\,x(t) - b\\,v(t)\\lvert v(t)\\rvert.$$\n\nDefine the mechanical energy $$E(t) = \\tfrac{1}{2}v(t)^2 + \\tfrac{1}{2}k\\,x(t)^2.$$ For each parameter set below, integrate the system from time $t=0$ to time $t=T$ with the initial conditions $x(0)=A$ and $v(0)=V_0$. For each case, compute three quantities:\n1) the final-to-initial energy ratio $R = E(T)/E(0)$, rounded to six decimal places,\n2) a boolean $M$ indicating whether the discrete energy sequence along the computed trajectory is nonincreasing within a per-step absolute tolerance $\\tau = 10^{-9}$, that is, $E_{n+1} \\le E_n + \\tau$ for all successive sampled times,\n3) the integer number $Z$ of zero-crossings of $x(t)$ over $t \\in [0,T]$ (count sign changes of $x$; values of $x$ whose magnitude is below a threshold should be treated as zero to avoid counting numerical noise; you must use a fixed absolute threshold of $10^{-8}$).\n\nUse the following test suite of parameter sets, each specified as $(A, V_0, b, k, T)$:\n- Case $1$: $(1, 0, 0, 1, 40)$,\n- Case $2$: $(1, 0, 0.1, 1, 40)$,\n- Case $3$: $(1, 0, 1, 1, 40)$,\n- Case $4$: $(0, 2, 0.5, 1, 40)$,\n- Case $5$: $(2, 0, 0.5, 1, 40)$.\n\nYour program must output a single line containing a list of results, one per case, where each result is a list $[R,M,Z]$ in that order. The overall output must therefore be a single line of the form\n[[R1,M1,Z1],[R2,M2,Z2],[R3,M3,Z3],[R4,M4,Z4],[R5,M5,Z5]]\nwith no additional text. All computations and outputs are dimensionless, and no physical units are required.",
            "solution": "The problem presented is a well-defined initial value problem in computational physics, requiring the numerical integration of a system of coupled first-order ordinary differential equations (ODEs). The problem is scientifically grounded, internally consistent, and contains all necessary information to proceed with a unique solution. Therefore, it is deemed valid.\n\nThe governing equation for the one-dimensional mass–spring oscillator with quadratic damping is given as:\n$$m\\,\\ddot{x}(t) + k\\,x(t) + b\\,\\dot{x}(t)\\lvert \\dot{x}(t)\\rvert = 0$$\nwhere $x(t)$ is the displacement, $m$ is the mass, $k$ is the spring constant, and $b$ is the nonlinear damping coefficient. The problem specifies using dimensionless units by setting the mass $m=1$.\n\nTo solve this second-order ODE numerically, we convert it into a system of two first-order ODEs. We define a state vector $y(t)$ and its components as:\n$$y(t) = \\begin{pmatrix} y_0(t) \\\\ y_1(t) \\end{pmatrix} = \\begin{pmatrix} x(t) \\\\ v(t) \\end{pmatrix}$$\nwhere $v(t) = \\dot{x}(t)$ is the velocity. The time derivatives of these components form the system:\n$$\n\\begin{align*}\n\\dot{y_0}(t) = \\dot{x}(t) = v(t) = y_1(t) \\\\\n\\dot{y_1}(t) = \\dot{v}(t) = \\ddot{x}(t) = -k\\,x(t) - b\\,v(t)\\lvert v(t)\\rvert = -k\\,y_0(t) - b\\,y_1(t)\\lvert y_1(t)\\rvert\n\\end{align*}\n$$\nThis system, $\\dot{y}(t) = f(t, y(t))$, can be integrated numerically given initial conditions $y(0) = (x(0), v(0)) = (A, V_0)$.\n\nThe total mechanical energy of the system is defined as the sum of kinetic and potential energy:\n$$E(t) = \\frac{1}{2}m\\,v(t)^2 + \\frac{1}{2}k\\,x(t)^2$$\nWith $m=1$, this becomes:\n$$E(t) = \\frac{1}{2}v(t)^2 + \\frac{1}{2}k\\,x(t)^2$$\nThe rate of change of energy, $\\dot{E}(t)$, reveals the dissipative nature of the damping force. Differentiating $E(t)$ with respect to time gives:\n$$\\dot{E}(t) = v(t)\\,\\dot{v}(t) + k\\,x(t)\\,\\dot{x}(t)$$\nSubstituting $\\dot{x}(t) = v(t)$ and $\\dot{v}(t) = -k\\,x(t) - b\\,v(t)\\lvert v(t)\\rvert$:\n$$\\dot{E}(t) = v(t) \\left( -k\\,x(t) - b\\,v(t)\\lvert v(t)\\rvert \\right) + k\\,x(t)\\,v(t)$$\n$$\\dot{E}(t) = -k\\,x(t)v(t) - b\\,v(t)^2\\lvert v(t)\\rvert + k\\,x(t)v(t)$$\n$$\\dot{E}(t) = -b\\,v(t)^2\\lvert v(t)\\rvert$$\nSince the damping coefficient $b \\ge 0$ and the term $v(t)^2\\lvert v(t)\\rvert \\ge 0$, the rate of change of energy $\\dot{E}(t)$ is always less than or equal to zero. This confirms that the mechanical energy is a non-increasing function of time. Energy is conserved only if $b=0$. This physical principle provides a basis for validating the numerical solution via the monotonicity check, $M$.\n\nThe solution will be obtained by employing a high-precision numerical integrator. The `scipy.integrate.solve_ivp` function is well-suited for this task. To ensure accuracy for the required calculations, particularly the energy monotonicity check (with tolerance $\\tau=10^{-9}$) and the zero-crossing count, tight relative and absolute tolerances (e.g., $10^{-12}$) for the solver are necessary. Furthermore, the solution must be evaluated on a fine time grid to reliably capture all zero-crossings.\n\nThe algorithm for each test case is as follows:\n1.  Define the system of ODEs as a Python function `f(t, y, b, k)`.\n2.  Use `scipy.integrate.solve_ivp` to integrate the system from $t=0$ to $t=T$ with the given initial conditions $(A, V_0)$ and parameters $(b, k)$. A dense time grid for evaluation is specified using the `t_eval` argument.\n3.  From the numerical solution for $x(t_i)$ and $v(t_i)$, calculate the required quantities:\n    a.  **Energy Ratio ($R$)**: Compute the initial energy $E(0) = \\frac{1}{2}V_0^2 + \\frac{1}{2}kA^2$ and final energy $E(T) = \\frac{1}{2}v(T)^2 + \\frac{1}{2}k\\,x(T)^2$. The ratio is $R = E(T)/E(0)$, rounded to six decimal places.\n    b.  **Energy Monotonicity ($M$)**: Compute the energy $E(t_i)$ at each time step $t_i$. Iterate through the sequence and verify if $E(t_{i+1}) \\le E(t_i) + \\tau$ for all $i$, where the tolerance $\\tau = 10^{-9}$. $M$ is `True` if the condition holds for all steps, and `False` otherwise.\n    c.  **Zero-Crossings ($Z$)**: To count the number of times $x(t)$ crosses zero, we first filter the position array $x(t_i)$ to remove points where the magnitude is below the specified threshold of $10^{-8}$. This prevents numerical noise near zero from being counted as a crossing. Then, we count the number of times the sign of consecutive elements in this filtered array changes. This is robustly implemented by checking where the product of consecutive elements is negative.\n\nThis procedure is applied to each of the five specified parameter sets to generate the final output.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves the mass-spring oscillator problem for a suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (A, V0, b, k, T)\n    test_cases = [\n        (1.0, 0.0, 0.0, 1.0, 40.0),   # Case 1\n        (1.0, 0.0, 0.1, 1.0, 40.0),   # Case 2\n        (1.0, 0.0, 1.0, 1.0, 40.0),   # Case 3\n        (0.0, 2.0, 0.5, 1.0, 40.0),   # Case 4\n        (2.0, 0.0, 0.5, 1.0, 40.0),   # Case 5\n    ]\n\n    results = []\n    \n    # Define constants from the problem\n    energy_monotonicity_tolerance = 1e-9\n    zero_crossing_threshold = 1e-8\n    \n    # Number of points for the time evaluation grid.\n    # A high number is chosen to ensure accuracy for zero-crossing and monotonicity checks.\n    num_points = 20001\n            \n    for case in test_cases:\n        A, V0, b, k, T = case\n\n        # Define the system of first-order ODEs\n        # y[0] = x, y[1] = v\n        # dx/dt = v\n        # dv/dt = -k*x - b*v*|v|\n        def ode_system(t, y, b_param, k_param):\n            x, v = y\n            dxdt = v\n            dvdt = -k_param * x - b_param * v * abs(v)\n            return [dxdt, dvdt]\n\n        # Set initial conditions\n        y0 = [A, V0]\n        \n        # Set time span and evaluation points\n        t_span = [0, T]\n        t_eval = np.linspace(t_span[0], t_span[1], num_points)\n\n        # Solve the ODE system\n        # Use tight tolerances for high accuracy\n        sol = solve_ivp(\n            ode_system, \n            t_span, \n            y0, \n            args=(b, k), \n            t_eval=t_eval, \n            rtol=1e-12, \n            atol=1e-12,\n            method='DOP853' # A high-order accurate method\n        )\n        \n        x_t = sol.y[0, :]\n        v_t = sol.y[1, :]\n\n        # 1. Calculate final-to-initial energy ratio (R)\n        E_t = 0.5 * v_t**2 + 0.5 * k * x_t**2\n        E0 = E_t[0]\n        ET = E_t[-1]\n        \n        # Handle the theoretical case of zero initial energy to avoid division by zero.\n        # This is not triggered by the given test cases.\n        if E0 == 0:\n            R = 0.0 if ET == 0 else float('inf')\n        else:\n            R = round(ET / E0, 6)\n\n        # 2. Check for energy monotonicity (M)\n        M = True\n        for i in range(len(E_t) - 1):\n            if E_t[i+1] > E_t[i] + energy_monotonicity_tolerance:\n                M = False\n                break\n        \n        # 3. Count zero-crossings (Z)\n        # Filter out values whose magnitude is below the threshold\n        x_filtered = x_t[np.abs(x_t) > zero_crossing_threshold]\n        \n        if len(x_filtered)  2:\n            Z = 0\n        else:\n            # A sign change occurs where sign(x_i) != sign(x_{i+1})\n            Z = np.sum(np.sign(x_filtered[:-1]) != np.sign(x_filtered[1:]))\n\n        results.append([R, M, Z])\n\n    # Final print statement in the exact required format.\n    # repr() produces a string representation that includes brackets and commas.\n    # .replace(\" \", \"\") removes all spaces to match the required dense format.\n    print(repr(results).replace(\" \", \"\"))\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "Having mastered the conversion of a single ODE, we now tackle a more profound question: not just *how* a system evolves, but whether its evolution is stable. This practice explores the dynamics of a charged particle in a Paul trap, a system governed by the Mathieu equation with time-periodic coefficients. You will apply Floquet theory by constructing and solving a larger system of ODEs for the fundamental matrix, a powerful method that reveals the long-term stability of the trap for any initial condition. ",
            "id": "2444845",
            "problem": "A singly charged particle in a radio-frequency quadrupole (Paul) trap can be modeled in one spatial coordinate by the Mathieu equation, which is a linear second-order ordinary differential equation with periodic coefficients. Starting from Newton’s second law and the definition of velocity as the time derivative of position, a one-dimensional, dimensionless form for the displacement $u(t)$ is given as\n$$\n\\ddot{u}(t) + \\big(a - 2 q \\cos(2 t)\\big) u(t) = 0,\n$$\nwhere $a$ and $q$ are real, dimensionless parameters, and the argument of the cosine is in radians. The coefficient is $\\pi$-periodic in time because $\\cos(2 t)$ has period $\\pi$. To analyze stability in the sense of boundedness of all solutions for all time, one may convert the second-order equation to a system of coupled first-order equations and apply the fundamental matrix and monodromy matrix concepts from Floquet theory on linear systems with periodic coefficients.\n\nUsing only foundational principles and definitions (Newton’s laws, $v = \\frac{dx}{dt}$, the definition of a state-space representation for ordinary differential equations, and the definition of Floquet multipliers for linear systems with periodic coefficients), do the following:\n\n1) Convert the Mathieu equation above to a first-order system of the form\n$$\n\\dot{\\mathbf{y}}(t) = A(t)\\,\\mathbf{y}(t),\n$$\nwhere $\\mathbf{y}(t) \\in \\mathbb{R}^2$ and $A(t)$ is a $2 \\times 2$ matrix that is $\\pi$-periodic. State $A(t)$ explicitly in terms of $a$, $q$, and $t$.\n\n2) Let $\\Phi(t)$ denote a fundamental matrix solution satisfying $\\Phi(0) = I$, where $I$ is the $2 \\times 2$ identity. The monodromy matrix is defined as $M = \\Phi(T)$ with $T = \\pi$. Explain why the eigenvalues $\\lambda_1, \\lambda_2$ of $M$ (the Floquet multipliers) determine the stability of the origin: all solutions remain bounded for all $t$ if and only if both multipliers have modulus less than or equal to $1$, with equality corresponding to neutral bounded oscillations. Provide a computationally robust decision rule that uses a small tolerance to handle numerical round-off when comparing $|\\lambda_i|$ to $1$.\n\n3) Design an algorithm that constructs and integrates the first-order system for the evolution of $\\Phi(t)$ directly, using the matrix differential equation\n$$\n\\dot{\\Phi}(t) = A(t)\\,\\Phi(t), \\quad \\Phi(0) = I,\n$$\nover one period $T = \\pi$. Represent $\\Phi(t)$ as a length-$4$ vector by stacking its columns to obtain a system of coupled first-order equations suitable for numerical integration. After integration, reshape the result back into a $2 \\times 2$ matrix to obtain $M$, compute its eigenvalues, and apply your stability decision rule.\n\n4) Implement the algorithm as a complete, runnable program that, for each parameter pair $(a, q)$ in the test suite below, outputs a boolean indicating stability (true if stable, false if unstable) according to your decision rule.\n\nUse radians for all trigonometric evaluations. No physical units need to be reported because the equation is dimensionless.\n\nTest suite (each entry is a pair $(a, q)$):\n- Case 1 (happy path, constant-coefficient positive stiffness): $(1.0, 0.0)$\n- Case 2 (happy path, constant-coefficient negative stiffness): $(-1.0, 0.0)$\n- Case 3 (near-constant positive stiffness with a very small periodic perturbation): $(0.5, 10^{-6})$\n- Case 4 (near-constant negative stiffness with a very small periodic perturbation): $(-0.5, 10^{-6})$\n- Case 5 (boundary case with double root characteristic equation): $(0.0, 0.0)$\n\nFinal output format requirement:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, \"[true,false,...]\"). In Python, booleans are printed as \"True\" or \"False\". The order must match the test suite above: Case $1$ through Case $5$.\n\nYour program must be fully self-contained, require no user input, and follow the execution environment constraints specified separately.",
            "solution": "The problem statement is assessed to be valid. It is scientifically grounded in the principles of classical mechanics and the theory of ordinary differential equations, specifically Floquet theory for linear systems with periodic coefficients. The problem is well-posed, objective, and contains all necessary information to derive a unique, verifiable solution for the provided test cases. We will proceed with the solution.\n\nThe analysis is structured according to the four tasks specified in the problem.\n\n1) Conversion of the Mathieu Equation to a First-Order System\n\nThe given second-order ordinary differential equation (ODE) is the Mathieu equation:\n$$\n\\ddot{u}(t) + \\big(a - 2 q \\cos(2 t)\\big) u(t) = 0\n$$\nTo convert this into a system of two coupled first-order ODEs, we define a state vector $\\mathbf{y}(t) \\in \\mathbb{R}^2$. A standard choice, based on the principles of mechanics, is to select the generalized position and generalized velocity as the state variables. Let $y_1(t) = u(t)$ be the displacement and $y_2(t) = \\dot{u}(t)$ be the velocity.\n\nThe time derivative of the first state variable is, by definition:\n$$\n\\dot{y}_1(t) = \\frac{d}{dt}u(t) = \\dot{u}(t) = y_2(t)\n$$\nThe time derivative of the second state variable is obtained by rearranging the Mathieu equation:\n$$\n\\dot{y}_2(t) = \\frac{d}{dt}\\dot{u}(t) = \\ddot{u}(t) = -\\big(a - 2 q \\cos(2 t)\\big) u(t) = -\\big(a - 2 q \\cos(2 t)\\big) y_1(t)\n$$\nWe can now write this system of two first-order equations in matrix form, $\\dot{\\mathbf{y}}(t) = A(t)\\,\\mathbf{y}(t)$:\n$$\n\\frac{d}{dt} \\begin{pmatrix} y_1(t) \\\\ y_2(t) \\end{pmatrix} = \\begin{pmatrix} 0  1 \\\\ -(a - 2q\\cos(2t))  0 \\end{pmatrix} \\begin{pmatrix} y_1(t) \\\\ y_2(t) \\end{pmatrix}\n$$\nThus, the state vector is $\\mathbf{y}(t) = \\begin{pmatrix} u(t) \\\\ \\dot{u}(t) \\end{pmatrix}$ and the time-dependent matrix $A(t)$ is:\n$$\nA(t) = \\begin{pmatrix} 0  1 \\\\ -a + 2q\\cos(2t)  0 \\end{pmatrix}\n$$\nThe coefficient matrix $A(t)$ is periodic with period $T = \\pi$, since the term $\\cos(2t)$ has period $\\pi$:\n$$\n\\cos(2(t+\\pi)) = \\cos(2t + 2\\pi) = \\cos(2t)\n$$\nThis confirms that $A(t+\\pi) = A(t)$, as required.\n\n2) Stability Analysis using Floquet Theory\n\nFor a linear system $\\dot{\\mathbf{y}}(t) = A(t)\\mathbf{y}(t)$ with $A(t)$ being $T$-periodic, Floquet theory provides the framework for stability analysis. A fundamental matrix solution, $\\Phi(t)$, is a $2 \\times 2$ matrix whose columns are linearly independent solutions to the system. It satisfies the matrix differential equation $\\dot{\\Phi}(t) = A(t)\\Phi(t)$. With the initial condition $\\Phi(0) = I$, where $I$ is the $2 \\times 2$ identity matrix, the solution to any initial value problem $\\mathbf{y}(0) = \\mathbf{y}_0$ is given by $\\mathbf{y}(t) = \\Phi(t)\\mathbf{y}_0$.\n\nThe monodromy matrix, $M$, is defined as the fundamental matrix evaluated after one full period, $M = \\Phi(T)$. For the Mathieu equation, the period is $T=\\pi$. The state of the system at integer multiples of the period is given by $\\mathbf{y}(k T) = M^k \\mathbf{y}_0$. The long-term behavior of the solution is therefore determined by the powers of $M$, which are governed by its eigenvalues $\\lambda_1, \\lambda_2$, known as the Floquet multipliers.\n\nA solution is bounded for all time if and only if the sequence $\\|\\mathbf{y}(kT)\\|$ is bounded for all integers $k \\ge 0$. This occurs if and only if the eigenvalues of $M$ satisfy specific conditions. If any eigenvalue $\\lambda_i$ has a modulus greater than $1$, $|\\lambda_i|  1$, the corresponding mode will grow exponentially, leading to an unbounded solution (instability). If all eigenvalues have moduli less than or equal to $1$, the solution is bounded (stable).\n\nThe problem specifies the stability criterion: all solutions are bounded if and only if $|\\lambda_i| \\le 1$ for both multipliers. The case $|\\lambda_i| = 1$ is stated to correspond to neutral bounded oscillations. For the system at hand, the trace of the matrix $A(t)$ is $\\mathrm{tr}(A(t)) = 0 + 0 = 0$. According to Liouville's formula, the determinant of the fundamental matrix is given by $\\det(\\Phi(t)) = \\det(\\Phi(0)) \\exp\\left(\\int_0^t \\mathrm{tr}(A(\\tau)) d\\tau\\right)$. Since $\\Phi(0) = I$, we have $\\det(\\Phi(0)) = 1$. With a zero trace, we find $\\det(\\Phi(t)) = 1$ for all $t$. Consequently, the determinant of the monodromy matrix is $\\det(M) = \\det(\\Phi(\\pi)) = 1$. The product of the eigenvalues of $M$ is its determinant, so $\\lambda_1 \\lambda_2 = 1$. This implies that either the eigenvalues are real and of the form $(\\lambda, 1/\\lambda)$ or they are a complex conjugate pair on the unit circle $(e^{i\\theta}, e^{-i\\theta})$. Instability ($|\\lambda_i|1$) can only occur in the former case when $|\\lambda| \\ne 1$.\n\nBased on the problem's stability rule, a solution is stable if `max(|λ₁, |λ₂|) ≤ 1`. Due to numerical integration and floating-point arithmetic errors, a direct comparison to $1$ is not robust. We establish a decision rule with a small tolerance $\\varepsilon  0$.\n\nComputationally Robust Decision Rule: The system is deemed stable if and only if $\\max(|\\lambda_1|, |\\lambda_2|) \\le 1 + \\varepsilon$. A suitable value for the tolerance is $\\varepsilon = 10^{-9}$. This accounts for small numerical errors that might push a true value of $1$ slightly higher, while still detecting genuine exponential instability where an eigenvalue's modulus is significantly greater than $1$.\n\n3) Algorithm Design for Monodromy Matrix Computation\n\nThe task is to find the monodromy matrix $M=\\Phi(\\pi)$ by numerically integrating the matrix ODE $\\dot{\\Phi}(t) = A(t)\\Phi(t)$ with the initial condition $\\Phi(0) = I$ over the interval $[0, \\pi]$. Standard numerical ODE solvers operate on vector-valued functions. Therefore, we must convert the $2 \\times 2$ matrix equation into a system of first-order ODEs for a single vector.\n\nLet the components of $\\Phi(t)$ be\n$$\n\\Phi(t) = \\begin{pmatrix} \\phi_{11}(t)  \\phi_{12}(t) \\\\ \\phi_{21}(t)  \\phi_{22}(t) \\end{pmatrix}\n$$\nThe matrix equation $\\dot{\\Phi} = A\\Phi$ expands to:\n$$\n\\frac{d}{dt} \\begin{pmatrix} \\phi_{11}  \\phi_{12} \\\\ \\phi_{21}  \\phi_{22} \\end{pmatrix} = \\begin{pmatrix} 0  1 \\\\ -a + 2q\\cos(2t)  0 \\end{pmatrix} \\begin{pmatrix} \\phi_{11}  \\phi_{12} \\\\ \\phi_{21}  \\phi_{22} \\end{pmatrix} = \\begin{pmatrix} \\phi_{21}  \\phi_{22} \\\\ (-a+2q\\cos(2t))\\phi_{11}  (-a+2q\\cos(2t))\\phi_{12} \\end{pmatrix}\n$$\nThis yields four coupled scalar ODEs. We form a state vector $\\mathbf{z}(t) \\in \\mathbb{R}^4$ by stacking the columns of $\\Phi(t)$:\n$$\n\\mathbf{z}(t) = \\begin{pmatrix} \\phi_{11}(t) \\\\ \\phi_{21}(t) \\\\ \\phi_{12}(t) \\\\ \\phi_{22}(t) \\end{pmatrix}\n$$\nThe system of ODEs for $\\mathbf{z}(t) = [z_1, z_2, z_3, z_4]^T$ is:\n$$\n\\dot{z}_1 = \\dot{\\phi}_{11} = \\phi_{21} = z_2 \\\\\n\\dot{z}_2 = \\dot{\\phi}_{21} = (-a+2q\\cos(2t))\\phi_{11} = (-a+2q\\cos(2t))z_1 \\\\\n\\dot{z}_3 = \\dot{\\phi}_{12} = \\phi_{22} = z_4 \\\\\n\\dot{z}_4 = \\dot{\\phi}_{22} = (-a+2q\\cos(2t))\\phi_{12} = (-a+2q\\cos(2t))z_3\n$$\nThe initial condition $\\Phi(0) = I = \\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix}$ translates to the initial vector:\n$$\n\\mathbf{z}(0) = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\\\ 1 \\end{pmatrix}\n$$\nThe algorithm is as follows:\n1.  For a given pair of parameters $(a, q)$, define the $4$-dimensional ODE system for $\\mathbf{z}(t)$.\n2.  Use a numerical ODE solver (such as a Runge-Kutta method) to integrate this system over the time interval $[0, \\pi]$ with the initial condition $\\mathbf{z}(0) = [1, 0, 0, 1]^T$.\n3.  The solver returns the state vector at the final time, $\\mathbf{z}(\\pi)$.\n4.  Reshape the resulting vector $\\mathbf{z}(\\pi) = [z_1(\\pi), z_2(\\pi), z_3(\\pi), z_4(\\pi)]^T$ back into the $2 \\times 2$ monodromy matrix $M$:\n    $$\n    M = \\begin{pmatrix} z_1(\\pi)  z_3(\\pi) \\\\ z_2(\\pi)  z_4(\\pi) \\end{pmatrix}\n    $$\n5.  Compute the eigenvalues, $\\lambda_1, \\lambda_2$, of the matrix $M$.\n6.  Apply the decision rule from Part 2: calculate $\\max(|\\lambda_1|, |\\lambda_2|)$ and check if it is less than or equal to $1 + \\varepsilon$.\n\n4) Implementation\nThe algorithm described above will be implemented in a Python program, adhering to the specified format and execution environment constraints. This involves using the `scipy.integrate.solve_ivp` function for numerical integration and `numpy` for linear algebra operations. The final output for each test case will be a boolean value representing stability.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves for the stability of the Mathieu equation for several parameter sets\n    using Floquet theory and numerical integration.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each entry is a tuple (a, q).\n    test_cases = [\n        (1.0, 0.0),       # Case 1\n        (-1.0, 0.0),      # Case 2\n        (0.5, 1.0e-6),    # Case 3\n        (-0.5, 1.0e-6),   # Case 4\n        (0.0, 0.0)        # Case 5\n    ]\n    \n    # Numerical tolerance for stability check.\n    # This accounts for floating point inaccuracies in the integration and\n    # eigenvalue calculation.\n    TOLERANCE = 1.0e-9\n\n    results = []\n\n    def flattened_ode_system(t, z, a, q):\n        \"\"\"\n        Defines the 4-dimensional system of first-order ODEs for the \n        flattened fundamental matrix Phi(t).\n        \n        The state vector z represents the column-stacked elements of Phi:\n        z = [phi_11, phi_21, phi_12, phi_22]^T\n        The original 2x2 system is dot(y) = A(t) * y, where\n        A(t) = [[0, 1], [-(a - 2q*cos(2t)), 0]].\n        \n        This function computes dot(z).\n        \"\"\"\n        # Unpack the state vector\n        # z1 = phi_11, z2 = phi_21, z3 = phi_12, z4 = phi_22\n        z1, z2, z3, z4 = z\n        \n        # This is the (2,1) element of the matrix A(t)\n        a21 = -(a - 2.0 * q * np.cos(2.0 * t))\n        \n        # Derivatives from the matrix equation dot(Phi) = A * Phi\n        dz1_dt = z2                 # dot(phi_11) = phi_21\n        dz2_dt = a21 * z1           # dot(phi_21) = a21 * phi_11\n        dz3_dt = z4                 # dot(phi_12) = phi_22\n        dz4_dt = a21 * z3           # dot(phi_22) = a21 * phi_12\n        \n        return np.array([dz1_dt, dz2_dt, dz3_dt, dz4_dt])\n\n    for a, q in test_cases:\n        # Set the time span for one period T = pi\n        t_span = (0.0, np.pi)\n        \n        # Initial condition Phi(0) = I, which flattens to z0.\n        # z0 = [phi_11(0), phi_21(0), phi_12(0), phi_22(0)]\n        z0 = np.array([1.0, 0.0, 0.0, 1.0])\n        \n        # Numerically integrate the system of ODEs\n        # We use a high-precision method with tight tolerances to ensure\n        # accuracy for the monodromy matrix calculation.\n        sol = solve_ivp(\n            fun=lambda t, z: flattened_ode_system(t, z, a, q),\n            t_span=t_span,\n            y0=z0,\n            method='DOP853',\n            rtol=1e-12,\n            atol=1e-12\n        )\n        \n        # The final state vector z(pi)\n        z_final = sol.y[:, -1]\n        \n        # Reshape the flattened final state vector back into the 2x2\n        # monodromy matrix M = Phi(pi).\n        # We use 'F' (Fortran) order because we stacked the columns.\n        monodromy_matrix = z_final.reshape((2, 2), order='F')\n        \n        # Compute the eigenvalues (Floquet multipliers) of M\n        eigenvalues = np.linalg.eigvals(monodromy_matrix)\n        \n        # Compute the moduli (absolute values) of the eigenvalues\n        abs_eigenvalues = np.abs(eigenvalues)\n        \n        # Apply the stability criterion:\n        # The solution is stable if the modulus of all eigenvalues is\n        # less than or equal to 1 (within a numerical tolerance).\n        is_stable = np.max(abs_eigenvalues) = 1.0 + TOLERANCE\n        \n        results.append(is_stable)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "Our final practice scales up our approach to a many-body system, recreating the famous Fermi-Pasta-Ulam-Tsingou (FPUT) experiment. This landmark problem in computational physics involves a chain of non-linearly coupled oscillators and led to the unexpected discovery of recurrence, a phenomenon that challenged the foundations of statistical mechanics. By modeling this chain as a large system of coupled ODEs, you will not only see how these numerical methods apply to complex, multi-particle dynamics but also experience firsthand how computation serves as a modern laboratory for scientific discovery. ",
            "id": "2444879",
            "problem": "Consider a one-dimensional Fermi-Pasta-Ulam-Tsingou (FPUT) $\\alpha$-model consisting of a chain of $N$ identical point masses with fixed boundary conditions and nearest-neighbor springs that include a weak nonlinear correction. Let $u_n(t)$ denote the displacement of the $n$-th mass from equilibrium at time $t$, for $n \\in \\{1,2,\\dots,N\\}$, and let $v_n(t) = \\dot{u}_n(t)$ denote its velocity. The end points satisfy fixed boundaries $u_0(t) = 0$ and $u_{N+1}(t) = 0$ for all $t$. Assume unit mass and unit linear spring constant so that all quantities are dimensionless.\n\nThe equations of motion are the coupled first-order system\n$\n\\dot{u}_n = v_n,\n$\n$\n\\dot{v}_n = \\left(u_{n+1} - 2u_n + u_{n-1}\\right) + \\alpha\\left[\\left(u_{n+1} - u_n\\right)^2 - \\left(u_n - u_{n-1}\\right)^2\\right],\n$\nfor $n \\in \\{1,2,\\dots,N\\}$, with $u_0 = 0$ and $u_{N+1} = 0$, where $\\alpha$ is the nonlinearity parameter.\n\nDefine the linear normal modes of the corresponding purely linear chain (i.e., with $\\alpha = 0$) by\n$\n\\phi_k(n) = \\sqrt{\\frac{2}{N+1}} \\sin\\!\\left(\\frac{k\\pi n}{N+1}\\right),\n$\nwith modal frequencies\n$\n\\omega_k = 2\\sin\\!\\left(\\frac{k\\pi}{2(N+1)}\\right),\n$\nfor $k \\in \\{1,2,\\dots,N\\}$. For any state $\\{u_n,v_n\\}_{n=1}^N$, define the linear modal coordinates\n$\nq_k = \\sum_{n=1}^{N} u_n \\, \\phi_k(n), \\quad p_k = \\sum_{n=1}^{N} v_n \\, \\phi_k(n),\n$\nand the associated linear modal energies\n$\nE_k = \\frac{1}{2}\\left(p_k^2 + \\omega_k^2 q_k^2\\right).\n$\nLet $E_{\\mathrm{sum}}(t) = \\sum_{k=1}^{N} E_k(t)$ and let $E_1(t)$ denote the energy of the first mode. The initial condition is a single-mode excitation in the first linear mode with zero initial velocities:\n$\nu_n(0) = A \\sin\\!\\left(\\frac{\\pi n}{N+1}\\right), \\quad v_n(0) = 0,\n$\nfor all $n \\in \\{1,2,\\dots,N\\}$, where $A$ is the initial amplitude.\n\nDefine a recurrence detection criterion as follows. Given tolerance parameters $\\epsilon \\in (0,1)$ and $\\eta \\in (0,1)$ and a time horizon $T_{\\max}  0$, a recurrence is said to be observed if there exist times $t_a$ and $t_b$ with $0  t_a  t_b \\le T_{\\max}$ such that:\n- Departure: $E_1(t_a)/E_{\\mathrm{sum}}(t_a) \\le 1 - \\eta$,\n- Return: $E_1(t_b)/E_{\\mathrm{sum}}(t_b) \\ge 1 - \\epsilon$,\nand $t_b$ is the smallest time satisfying the return condition that occurs after some departure time $t_a$. The recurrence time is defined to be $t_b$. If no such $t_b$ exists in the interval $(0, T_{\\max}]$, the recurrence time is defined to be $-1$.\n\nAll quantities are dimensionless. Report all times in dimensionless units as real numbers.\n\nTest Suite. For each of the following parameter sets $(N,\\alpha,A,T_{\\max},\\epsilon,\\eta)$, compute the recurrence time as defined above:\n- Case $1$: $(N,\\alpha,A,T_{\\max},\\epsilon,\\eta) = (8,\\,0.25,\\,0.3,\\,300,\\,0.1,\\,0.1)$.\n- Case $2$: $(N,\\alpha,A,T_{\\max},\\epsilon,\\eta) = (8,\\,0,\\,0.3,\\,100,\\,0.1,\\,0.1)$.\n- Case $3$: $(N,\\alpha,A,T_{\\max},\\epsilon,\\eta) = (8,\\,1.0,\\,0.3,\\,300,\\,0.1,\\,0.1)$.\n\nFinal Output Format. Your program should produce a single line of output containing the three recurrence times for the cases above, as a comma-separated list enclosed in square brackets, for example, $[t_1,t_2,t_3]$, where each $t_i$ is a real number in dimensionless units and equals $-1$ if no recurrence is observed within the specified horizon.",
            "solution": "The problem presented is a well-posed and scientifically sound exercise in computational physics. It requires the numerical integration of the equations of motion for the Fermi-Pasta-Ulam-Tsingou (FPUT) $\\alpha$-model, followed by an analysis of the system's trajectory in linear normal mode space to determine a recurrence time. The problem is self-contained, with all parameters, equations, initial conditions, and analysis criteria explicitly defined. It is a canonical problem in the study of nonlinear dynamics and is free from any scientific or logical flaws. We may therefore proceed with a solution.\n\nThe core of the problem is to solve a system of $2N$ coupled first-order ordinary differential equations (ODEs). Let the state of the system be represented by a vector $Y(t) \\in \\mathbb{R}^{2N}$, where $Y = [u_1, \\dots, u_N, v_1, \\dots, v_N]^T$. The components $u_n(t)$ are the displacements and $v_n(t) = \\dot{u}_n(t)$ are the velocities of the $N$ masses. The time evolution of the system is governed by $\\dot{Y}(t) = f(t, Y)$. The function $f(t, Y)$ is derived from the equations of motion:\n$$\n\\dot{u}_n = v_n\n$$\n$$\n\\dot{v}_n = (u_{n+1} - 2u_n + u_{n-1}) + \\alpha\\left[(u_{n+1} - u_n)^2 - (u_n - u_{n-1})^2\\right]\n$$\nThese equations hold for $n \\in \\{1, \\dots, N\\}$, with the fixed boundary conditions $u_0(t) = 0$ and $u_{N+1}(t) = 0$. The state vector derivative $\\dot{Y}$ can be constructed by setting its first $N$ components to $[v_1, \\dots, v_N]$ and its last $N$ components to $[\\dot{v}_1, \\dots, \\dot{v}_N]$, where $\\dot{v}_n$ is calculated using the formula above. For numerical implementation, the boundary conditions are handled by creating a padded displacement array $[0, u_1, \\dots, u_N, 0]$.\n\nTo solve this initial value problem, we employ a high-quality numerical ODE solver. The `solve_ivp` function from the SciPy library is an appropriate choice, as it provides robust, adaptive-step-size integration methods (such as the Runge-Kutta-Fehlberg method, RK45) suitable for the oscillatory nature of this system. We set stringent relative and absolute error tolerances (e.g., $10^{-9}$) to ensure the numerical trajectory is accurate over the specified time horizon $T_{\\max}$. The `dense_output=True` option is utilized to obtain a continuous representation of the solution, which can then be evaluated at a high frequency of points for analysis.\n\nThe initial condition is specified as a pure excitation of the first linear normal mode with zero initial velocities:\n$$\nu_n(0) = A \\sin\\left(\\frac{\\pi n}{N+1}\\right), \\quad v_n(0) = 0\n$$\nThis defines the initial state vector $Y(0)$.\n\nAfter numerically integrating the system from $t=0$ to $t=T_{\\max}$, the resulting trajectory $\\{u_n(t), v_n(t)\\}$ must be analyzed in the basis of the linear normal modes. The modal coordinates $(q_k, p_k)$ are obtained via a linear transformation:\n$$\nq_k(t) = \\sum_{n=1}^{N} u_n(t) \\phi_k(n), \\quad p_k(t) = \\sum_{n=1}^{N} v_n(t) \\phi_k(n)\n$$\nwhere $\\phi_k(n) = \\sqrt{\\frac{2}{N+1}} \\sin\\left(\\frac{k\\pi n}{N+1}\\right)$ are the orthonormal mode shapes. This transformation can be efficiently computed as a matrix-vector product, $q(t) = T u(t)$ and $p(t) = T v(t)$, where $T$ is the transformation matrix with elements $T_{kn} = \\phi_k(n)$.\n\nFrom these modal coordinates, the linear modal energies $E_k(t)$ are calculated:\n$$\nE_k(t) = \\frac{1}{2}\\left(p_k(t)^2 + \\omega_k^2 q_k(t)^2\\right)\n$$\nwhere $\\omega_k = 2\\sin\\left(\\frac{k\\pi}{2(N+1)}\\right)$ are the linear mode frequencies. The quantity of interest is the ratio of the energy in the first mode to the sum of all linear modal energies, $R(t) = E_1(t) / E_{\\mathrm{sum}}(t)$, where $E_{\\mathrm{sum}}(t) = \\sum_{k=1}^{N} E_k(t)$. It is important to note that for the nonlinear system ($\\alpha \\ne 0$), $E_{\\mathrm{sum}}(t)$ is not a conserved quantity, unlike the true total Hamiltonian of the system.\n\nFinally, the recurrence time is determined by analyzing the time series of the ratio $R(t)$. According to the problem definition, we must find the smallest time $t_b \\in (0, T_{\\max}]$ such that $R(t_b) \\ge 1 - \\epsilon$, with the condition that there exists some prior time $t_a \\in (0, t_b)$ where $R(t_a) \\le 1 - \\eta$. This is implemented by iterating through the computed time points, first waiting for the `departure` condition ($R(t) \\le 1 - \\eta$) to be met, and then searching for the first subsequent time that satisfies the `return` condition ($R(t) \\ge 1 - \\epsilon$). If no such event sequence occurs within the time horizon, the recurrence time is defined as $-1$.\n\nFor the special case where $\\alpha=0$ (Case 2), the system is linear, and the normal modes are uncoupled. Since the initial condition excites only the first mode, all energy remains in that mode for all time. Thus, $E_k(t) = 0$ for $k  1$, and $E_1(t)$ is constant. The ratio $R(t)$ is identically $1$ for all $t$. Consequently, the departure condition $R(t) \\le 1 - \\eta$ (for $\\eta  0$) is never satisfied, and the recurrence time is, by definition, $-1$. This known analytical result serves as a valuable validation for our understanding of the problem.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef find_recurrence_time(N, alpha, A, T_max, epsilon, eta):\n    \"\"\"\n    Computes the FPUT recurrence time for a given set of parameters.\n    \"\"\"\n    # For the linear case (alpha=0), the modes are uncoupled.\n    # The initial condition is a pure mode 1 excitation, so energy never leaves\n    # mode 1. The departure condition is never met.\n    if alpha == 0:\n        return -1.0\n\n    # 1. Pre-calculate constants for the given N\n    N_plus_1 = N + 1\n    k = np.arange(1, N + 1)\n    n = np.arange(1, N + 1)\n    \n    # Square of angular frequencies for linear modes\n    omega_k_sq = (2 * np.sin(k * np.pi / (2 * N_plus_1)))**2\n    \n    # Modal transformation matrix T_kn = phi_k(n)\n    k_col = k[:, np.newaxis]\n    n_row = n[np.newaxis, :]\n    T_matrix = np.sqrt(2 / N_plus_1) * np.sin(k_col * np.pi * n_row / N_plus_1)\n    \n    # 2. Define the initial state vector Y0 = [u0, v0]\n    u0 = A * np.sin(np.pi * n / N_plus_1)\n    v0 = np.zeros(N)\n    Y0 = np.concatenate((u0, v0))\n    \n    # 3. Define the derivative function for the ODE system\n    def fput_eom(t, Y, N_val, alpha_val):\n        u = Y[:N_val]\n        v = Y[N_val:]\n        \n        dudt = v\n        \n        # Pad u with fixed boundaries u_0 = 0, u_{N+1} = 0\n        u_padded = np.concatenate(([0], u, [0]))\n        \n        # Linear part of acceleration\n        accel_linear = u_padded[2:] - 2 * u_padded[1:-1] + u_padded[:-2]\n        \n        # Nonlinear part of acceleration\n        diff_u = np.diff(u_padded)  # u_{i+1} - u_i\n        accel_nonlinear = alpha_val * (diff_u[1:]**2 - diff_u[:-1]**2)\n        \n        dvdt = accel_linear + accel_nonlinear\n        \n        return np.concatenate((dudt, dvdt))\n\n    # 4. Integrate the ODE system using a high-precision solver\n    sol = solve_ivp(\n        fput_eom, \n        [0, T_max], \n        Y0, \n        args=(N, alpha), \n        dense_output=True, \n        rtol=1e-9,  # Relative tolerance\n        atol=1e-9   # Absolute tolerance\n    )\n    \n    # 5. Post-process the solution to find recurrence\n    # Evaluate the solution on a fine time grid for analysis\n    num_eval_points = int(T_max * 20) + 1  # Use a fine grid for accuracy\n    t_eval = np.linspace(0, T_max, num_eval_points)\n    Y_t = sol.sol(t_eval)\n    \n    u_t = Y_t[:N, :]\n    v_t = Y_t[N:, :]\n    \n    # Transform to modal coordinates (q, p)\n    q_t = T_matrix @ u_t\n    p_t = T_matrix @ v_t\n    \n    # Calculate linear modal energies E_k(t)\n    # The term omega_k_sq[:, np.newaxis] ensures correct broadcasting\n    E_k_t = 0.5 * (p_t**2 + omega_k_sq[:, np.newaxis] * q_t**2)\n    \n    E1_t = E_k_t[0, :]\n    E_sum_t = np.sum(E_k_t, axis=0)\n    \n    # To prevent division by zero, although not expected for this problem\n    E_sum_t[E_sum_t == 0] = 1.0\n    \n    ratio_t = E1_t / E_sum_t\n    \n    # 6. Find the recurrence time based on the problem's definition\n    departure_threshold = 1.0 - eta\n    return_threshold = 1.0 - epsilon\n    \n    departure_observed = False\n    for i, t in enumerate(t_eval):\n        if t == 0:\n            continue\n        \n        # Check for departure condition\n        if not departure_observed and ratio_t[i] = departure_threshold:\n            departure_observed = True\n            \n        # If departed, check for return condition\n        if departure_observed and ratio_t[i] >= return_threshold:\n            return round(t, 4)  # Return first time return condition is met after departure\n            \n    return -1.0  # No recurrence found within T_max\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, alpha, A, T_max, epsilon, eta)\n        (8, 0.25, 0.3, 300, 0.1, 0.1),\n        (8, 0.0, 0.3, 100, 0.1, 0.1),\n        (8, 1.0, 0.3, 300, 0.1, 0.1),\n    ]\n\n    results = []\n    for case in test_cases:\n        recurrence_time = find_recurrence_time(*case)\n        results.append(recurrence_time)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}