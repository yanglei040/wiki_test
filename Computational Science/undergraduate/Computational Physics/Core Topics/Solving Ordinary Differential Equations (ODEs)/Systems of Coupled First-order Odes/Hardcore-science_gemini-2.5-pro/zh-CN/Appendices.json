{
    "hands_on_practices": [
        {
            "introduction": "物理世界中的许多基本定律，例如牛顿第二定律，都以二阶常微分方程的形式出现。为了使用计算机进行数值求解，标准的第一步是将这些高阶方程转化为等价的一阶常微分方程组。本练习将通过一个带有非线性阻尼的振子模型，带你实践这一核心技能 。你不仅将学习如何构建和求解状态空间方程，还将通过分析能量随时间的变化来验证物理原理，例如能量耗散。",
            "id": "2444882",
            "problem": "一个具有二次速度比例阻尼的一维质量-弹簧振子由以下二阶常微分方程 (ODE) 控制，其中阻尼力是非线性的：$$m\\,\\ddot{x}(t) + k\\,x(t) + b\\,\\dot{x}(t)\\lvert \\dot{x}(t)\\rvert = 0,$$ 其中位移为 $x(t)$，速度为 $\\dot{x}(t)$，质量为 $m$，弹簧常数为 $k$，非线性阻尼系数为 $b \\ge 0$。通过设置 $m=1$ 在无量纲单位下进行计算。通过定义状态向量 $y(t) = \\big(x(t), v(t)\\big)$（其中 $v(t) = \\dot{x}(t)$），将其转换为一阶耦合常微分方程组。该方程组为 $$\\dot{x}(t) = v(t), \\quad \\dot{v}(t) = -k\\,x(t) - b\\,v(t)\\lvert v(t)\\rvert.$$\n\n定义机械能 $$E(t) = \\tfrac{1}{2}v(t)^2 + \\tfrac{1}{2}k\\,x(t)^2.$$ 对于下方的每组参数，使用初始条件 $x(0)=A$ 和 $v(0)=V_0$ 对系统从时间 $t=0$ 到时间 $t=T$ 进行积分。对于每种情况，计算三个量：\n1) 末-初能量比 $R = E(T)/E(0)$，四舍五入到六位小数，\n2) 一个布尔值 $M$，指示计算轨迹上的离散能量序列在每步绝对容差 $\\tau = 10^{-9}$ 内是否为非增，即对于所有连续的采样时间，都有 $E_{n+1} \\le E_n + \\tau$，\n3) 在 $t \\in [0,T]$ 范围内 $x(t)$ 的过零点整数数量 $Z$（计算 $x$ 的符号变化次数；幅值低于阈值的 $x$ 值应被视为零，以避免计算数值噪声；您必须使用 $10^{-8}$ 的固定绝对阈值）。\n\n使用以下参数集测试套件，每组参数指定为 $(A, V_0, b, k, T)$：\n- 情况 1：$(1, 0, 0, 1, 40)$，\n- 情况 2：$(1, 0, 0.1, 1, 40)$，\n- 情况 3：$(1, 0, 1, 1, 40)$，\n- 情况 4：$(0, 2, 0.5, 1, 40)$，\n- 情况 5：$(2, 0, 0.5, 1, 40)$。\n\n您的程序必须输出单行结果列表，每种情况一个结果，其中每个结果都是按 $[R,M,Z]$ 顺序排列的列表。因此，总输出必须是形如\n[[R1,M1,Z1],[R2,M2,Z2],[R3,M3,Z3],[R4,M4,Z4],[R5,M5,Z5]]\n的单行，无附加文本。所有计算和输出都是无量纲的，不需要物理单位。",
            "solution": "所提出的问题是计算物理学中一个定义明确的初值问题，需要对一个一阶耦合常微分方程组 (ODEs) 进行数值积分。该问题具有科学依据，内部一致，并包含获得唯一解所需的所有必要信息。因此，它被认为是有效的。\n\n具有二次阻尼的一维质量-弹簧振子的控制方程如下：\n$$m\\,\\ddot{x}(t) + k\\,x(t) + b\\,\\dot{x}(t)\\lvert \\dot{x}(t)\\rvert = 0$$\n其中 $x(t)$ 是位移， $m$ 是质量， $k$ 是弹簧常数， $b$ 是非线性阻尼系数。问题指定通过设置质量 $m=1$ 来使用无量纲单位。\n\n为了数值求解这个二阶常微分方程，我们将其转换为一个由两个一阶常微分方程组成的方程组。我们定义一个状态向量 $y(t)$ 及其分量如下：\n$$y(t) = \\begin{pmatrix} y_0(t) \\\\ y_1(t) \\end{pmatrix} = \\begin{pmatrix} x(t) \\\\ v(t) \\end{pmatrix}$$\n其中 $v(t) = \\dot{x}(t)$ 是速度。这些分量的时间导数构成了以下方程组：\n$$\n\\begin{align*}\n\\dot{y_0}(t) = \\dot{x}(t) = v(t) = y_1(t) \\\\\n\\dot{y_1}(t) = \\dot{v}(t) = \\ddot{x}(t) = -k\\,x(t) - b\\,v(t)\\lvert v(t)\\rvert = -k\\,y_0(t) - b\\,y_1(t)\\lvert y_1(t)\\rvert\n\\end{align*}\n$$\n这个方程组 $\\dot{y}(t) = f(t, y(t))$，在给定初始条件 $y(0) = (x(0), v(0)) = (A, V_0)$ 的情况下，可以进行数值积分。\n\n系统的总机械能定义为动能和势能之和：\n$$E(t) = \\frac{1}{2}m\\,v(t)^2 + \\frac{1}{2}k\\,x(t)^2$$\n当 $m=1$ 时，它变为：\n$$E(t) = \\frac{1}{2}v(t)^2 + \\frac{1}{2}k\\,x(t)^2$$\n能量变化率 $\\dot{E}(t)$ 揭示了阻尼力的耗散性质。对 $E(t)$ 关于时间求导可得：\n$$\\dot{E}(t) = v(t)\\,\\dot{v}(t) + k\\,x(t)\\,\\dot{x}(t)$$\n代入 $\\dot{x}(t) = v(t)$ 和 $\\dot{v}(t) = -k\\,x(t) - b\\,v(t)\\lvert v(t)\\rvert$：\n$$\\dot{E}(t) = v(t) \\left( -k\\,x(t) - b\\,v(t)\\lvert v(t)\\rvert \\right) + k\\,x(t)\\,v(t)$$\n$$\\dot{E}(t) = -k\\,x(t)v(t) - b\\,v(t)^2\\lvert v(t)\\rvert + k\\,x(t)v(t)$$\n$$\\dot{E}(t) = -b\\,v(t)^2\\lvert v(t)\\rvert$$\n由于阻尼系数 $b \\ge 0$ 且项 $v(t)^2\\lvert v(t)\\rvert \\ge 0$，能量变化率 $\\dot{E}(t)$ 总是小于或等于零。这证实了机械能是时间的非增函数。仅当 $b=0$ 时能量守恒。这一物理原理为通过单调性检查 $M$ 来验证数值解提供了基础。\n\n解将通过使用高精度数值积分器获得。`scipy.integrate.solve_ivp` 函数非常适合这项任务。为确保所需计算的准确性，特别是能量单调性检查（容差为 $\\tau=10^{-9}$）和过零点计数，求解器需要使用严格的相对和绝对容差（例如，$10^{-12}$）。此外，必须在精细的时间网格上评估解，以可靠地捕捉所有过零点。\n\n每个测试用例的算法如下：\n1.  将常微分方程组定义为一个 Python 函数 `f(t, y, b, k)`。\n2.  使用 `scipy.integrate.solve_ivp`，以给定的初始条件 $(A, V_0)$ 和参数 $(b, k)$，对系统从 $t=0$ 到 $t=T$ 进行积分。使用 `t_eval` 参数指定一个密集的评估时间网格。\n3.  根据 $x(t_i)$ 和 $v(t_i)$ 的数值解，计算所需的量：\n    a.  **能量比 ($R$)**: 计算初始能量 $E(0) = \\frac{1}{2}V_0^2 + \\frac{1}{2}kA^2$ 和最终能量 $E(T) = \\frac{1}{2}v(T)^2 + \\frac{1}{2}k\\,x(T)^2$。该比率为 $R = E(T)/E(0)$，四舍五入到六位小数。\n    b.  **能量单调性 ($M$)**: 计算每个时间步 $t_i$ 的能量 $E(t_i)$。遍历该序列并验证是否对所有 $i$ 都满足 $E(t_{i+1}) \\le E(t_i) + \\tau$，其中容差为 $\\tau = 10^{-9}$。如果所有步骤都满足条件，则 $M$ 为 `True`，否则为 `False`。\n    c.  **过零点 ($Z$)**: 为计算 $x(t)$ 过零的次数，我们首先筛选位置数组 $x(t_i)$，移除幅值低于指定阈值 $10^{-8}$ 的点。这可以防止将零附近的数值噪声计为过零。然后，我们计算这个筛选后数组中连续元素符号变化的次数。通过检查连续元素的乘积是否为负来稳健地实现这一点。\n\n将此过程应用于五个指定的参数集中的每一个，以生成最终输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves the mass-spring oscillator problem for a suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (A, V0, b, k, T)\n    test_cases = [\n        (1.0, 0.0, 0.0, 1.0, 40.0),   # Case 1\n        (1.0, 0.0, 0.1, 1.0, 40.0),   # Case 2\n        (1.0, 0.0, 1.0, 1.0, 40.0),   # Case 3\n        (0.0, 2.0, 0.5, 1.0, 40.0),   # Case 4\n        (2.0, 0.0, 0.5, 1.0, 40.0),   # Case 5\n    ]\n\n    results = []\n    \n    # Define constants from the problem\n    energy_monotonicity_tolerance = 1e-9\n    zero_crossing_threshold = 1e-8\n    \n    # Number of points for the time evaluation grid.\n    # A high number is chosen to ensure accuracy for zero-crossing and monotonicity checks.\n    num_points = 20001\n            \n    for case in test_cases:\n        A, V0, b, k, T = case\n\n        # Define the system of first-order ODEs\n        # y[0] = x, y[1] = v\n        # dx/dt = v\n        # dv/dt = -k*x - b*v*|v|\n        def ode_system(t, y, b_param, k_param):\n            x, v = y\n            dxdt = v\n            dvdt = -k_param * x - b_param * v * abs(v)\n            return [dxdt, dvdt]\n\n        # Set initial conditions\n        y0 = [A, V0]\n        \n        # Set time span and evaluation points\n        t_span = [0, T]\n        t_eval = np.linspace(t_span[0], t_span[1], num_points)\n\n        # Solve the ODE system\n        # Use tight tolerances for high accuracy\n        sol = solve_ivp(\n            ode_system, \n            t_span, \n            y0, \n            args=(b, k), \n            t_eval=t_eval, \n            rtol=1e-12, \n            atol=1e-12,\n            method='DOP853' # A high-order accurate method\n        )\n        \n        x_t = sol.y[0, :]\n        v_t = sol.y[1, :]\n\n        # 1. Calculate final-to-initial energy ratio (R)\n        E_t = 0.5 * v_t**2 + 0.5 * k * x_t**2\n        E0 = E_t[0]\n        ET = E_t[-1]\n        \n        # Handle the theoretical case of zero initial energy to avoid division by zero.\n        # This is not triggered by the given test cases.\n        if E0 == 0:\n            R = 0.0 if ET == 0 else float('inf')\n        else:\n            R = round(ET / E0, 6)\n\n        # 2. Check for energy monotonicity (M)\n        M = True\n        for i in range(len(E_t) - 1):\n            if E_t[i+1] > E_t[i] + energy_monotonicity_tolerance:\n                M = False\n                break\n        \n        # 3. Count zero-crossings (Z)\n        # Filter out values whose magnitude is below the threshold\n        x_filtered = x_t[np.abs(x_t) > zero_crossing_threshold]\n        \n        if len(x_filtered)  2:\n            Z = 0\n        else:\n            # A sign change occurs where sign(x_i) != sign(x_{i+1})\n            Z = np.sum(np.sign(x_filtered[:-1]) != np.sign(x_filtered[1:]))\n\n        results.append([R, M, Z])\n\n    # Final print statement in the exact required format.\n    # repr() produces a string representation that includes brackets and commas.\n    # .replace(\" \", \"\") removes all spaces to match the required dense format.\n    print(repr(results).replace(\" \", \"\"))\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "在解决了简单的自治系统之后，让我们转向一个更复杂的场景：系统参数随时间周期性变化。马蒂厄方程是描述带电粒子在保罗陷阱中运动的经典模型，对于这类系统，我们通常更关心其长期稳定性，而非某条特定轨迹 。本练习将引导你运用强大的弗洛凯理论 (Floquet theory)，通过计算单值矩阵的本征值来判断粒子是否会被稳定囚禁，这展示了常微分方程组在理论分析中的深刻应用。",
            "id": "2444845",
            "problem": "在射频四极（Paul）阱中的单电荷粒子，其在一个空间坐标上的运动可以通过马丢方程（Mathieu equation）来建模，这是一个带有周期性系数的线性二阶常微分方程。从牛顿第二定律以及速度是位置对时间导数的定义出发，位移 $u(t)$ 的一维无量纲形式表示为\n$$\n\\ddot{u}(t) + \\big(a - 2 q \\cos(2 t)\\big) u(t) = 0,\n$$\n其中 $a$ 和 $q$ 是无量纲实数参数，余弦函数的参数单位是弧度。因为 $\\cos(2 t)$ 的周期是 $\\pi$，所以该方程的系数是时间上 $\\pi$-周期的。为了分析所有解在所有时间上有界意义下的稳定性，可以将该二阶方程转换为一个耦合的一阶方程组，并应用来自 Floquet 理论中关于周期系数线性系统的基本矩阵和单值矩阵概念。\n\n仅使用基本原理和定义（牛顿定律、$v = \\frac{dx}{dt}$、常微分方程的状态空间表示法定义，以及周期系数线性系统的 Floquet 乘子定义），完成以下任务：\n\n1) 将上述马丢方程转换为 $\\dot{\\mathbf{y}}(t) = A(t)\\,\\mathbf{y}(t)$ 形式的一阶系统，其中 $\\mathbf{y}(t) \\in \\mathbb{R}^2$ 且 $A(t)$ 是一个 $\\pi$-周期的 $2 \\times 2$ 矩阵。用 $a$、$q$ 和 $t$ 明确地表示出 $A(t)$。\n\n2) 令 $\\Phi(t)$ 表示满足 $\\Phi(0) = I$ 的一个基本矩阵解，其中 $I$ 是 $2 \\times 2$ 的单位矩阵。单值矩阵定义为 $M = \\Phi(T)$，其中 $T = \\pi$。解释为什么 $M$ 的特征值 $\\lambda_1, \\lambda_2$（即 Floquet 乘子）决定了原点的稳定性：所有解在所有时间 $t$ 上保持有界的充要条件是两个乘子的模都小于或等于 $1$，等号成立时对应于中性有界振荡。提供一个计算上鲁棒的决策规则，该规则在比较 $|\\lambda_i|$ 与 $1$ 时使用一个小的容差来处理数值舍入误差。\n\n3) 设计一个算法，使用矩阵微分方程\n$$\n\\dot{\\Phi}(t) = A(t)\\,\\Phi(t), \\quad \\Phi(0) = I,\n$$\n在一个周期 $T = \\pi$ 上直接构建并积分用于 $\\Phi(t)$ 演化的一阶系统。通过将其列堆叠，将 $\\Phi(t)$ 表示为一个长度为 4 的向量，以获得一个适合数值积分的耦合一阶方程组。积分后，将结果重塑回一个 $2 \\times 2$ 矩阵以获得 $M$，计算其特征值，并应用你的稳定性决策规则。\n\n4) 将该算法实现为一个完整、可运行的程序，该程序对于下面测试套件中的每个参数对 $(a, q)$，根据你的决策规则输出一个布尔值来表示稳定性（稳定为 true，不稳定为 false）。\n\n所有三角函数求值均使用弧度。因为该方程是无量纲的，所以无需报告任何物理单位。\n\n测试套件（每个条目是一个参数对 $(a, q)$）：\n- 案例 1（理想情况，常系数正刚度）：$(1.0, 0.0)$\n- 案例 2（理想情况，常系数负刚度）：$(-1.0, 0.0)$\n- 案例 3（具有极小周期性扰动的近常数正刚度）：$(0.5, 10^{-6})$\n- 案例 4（具有极小周期性扰动的近常数负刚度）：$(-0.5, 10^{-6})$\n- 案例 5（具有双重根特征方程的边界情况）：$(0.0, 0.0)$\n\n最终输出格式要求：\n你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，\"[true,false,...]\"）。在 Python 中，布尔值打印为 \"True\" 或 \"False\"。顺序必须与上面的测试套件匹配：案例 1 到案例 5。\n\n你的程序必须是完全自包含的，不需要用户输入，并且遵守另外指定的执行环境约束。",
            "solution": "问题陈述经评估有效。它在科学上基于经典力学原理和常微分方程理论，特别是针对周期系数线性系统的 Floquet 理论。该问题是适定的、客观的，并包含为所提供的测试案例推导出唯一、可验证解所需的所有信息。我们将开始进行解答。\n\n本分析根据问题中指定的四项任务进行组织。\n\n1) 将马丢方程转换为一阶系统\n\n给定的二阶常微分方程（ODE）是马丢方程：\n$$\n\\ddot{u}(t) + \\big(a - 2 q \\cos(2 t)\\big) u(t) = 0\n$$\n为将其转换为一个包含两个耦合一阶常微分方程的系统，我们定义一个状态向量 $\\mathbf{y}(t) \\in \\mathbb{R}^2$。基于力学原理，一个标准的选择是选取广义位置和广义速度作为状态变量。令 $y_1(t) = u(t)$ 为位移，$y_2(t) = \\dot{u}(t)$ 为速度。\n\n根据定义，第一个状态变量的时间导数是：\n$$\n\\dot{y}_1(t) = \\frac{d}{dt}u(t) = \\dot{u}(t) = y_2(t)\n$$\n第二个状态变量的时间导数通过重新整理马丢方程得到：\n$$\n\\dot{y}_2(t) = \\frac{d}{dt}\\dot{u}(t) = \\ddot{u}(t) = -\\big(a - 2 q \\cos(2 t)\\big) u(t) = -\\big(a - 2 q \\cos(2 t)\\big) y_1(t)\n$$\n我们现在可以将这个由两个一阶方程组成的系统写成矩阵形式 $\\dot{\\mathbf{y}}(t) = A(t)\\,\\mathbf{y}(t)$：\n$$\n\\frac{d}{dt} \\begin{pmatrix} y_1(t) \\\\ y_2(t) \\end{pmatrix} = \\begin{pmatrix} 0  1 \\\\ -(a - 2q\\cos(2t))  0 \\end{pmatrix} \\begin{pmatrix} y_1(t) \\\\ y_2(t) \\end{pmatrix}\n$$\n因此，状态向量为 $\\mathbf{y}(t) = \\begin{pmatrix} u(t) \\\\ \\dot{u}(t) \\end{pmatrix}$，随时间变化的矩阵 $A(t)$ 为：\n$$\nA(t) = \\begin{pmatrix} 0  1 \\\\ -a + 2q\\cos(2t)  0 \\end{pmatrix}\n$$\n系数矩阵 $A(t)$ 以 $T = \\pi$ 为周期，因为项 $\\cos(2t)$ 的周期为 $\\pi$：\n$$\n\\cos(2(t+\\pi)) = \\cos(2t + 2\\pi) = \\cos(2t)\n$$\n这证实了 $A(t+\\pi) = A(t)$，符合要求。\n\n2) 使用 Floquet 理论进行稳定性分析\n\n对于一个线性系统 $\\dot{\\mathbf{y}}(t) = A(t)\\mathbf{y}(t)$，其中 $A(t)$ 是 $T$-周期的，Floquet 理论为稳定性分析提供了框架。一个基本矩阵解 $\\Phi(t)$ 是一个 $2 \\times 2$ 矩阵，其列是该系统的线性无关解。它满足矩阵微分方程 $\\dot{\\Phi}(t) = A(t)\\Phi(t)$。在初始条件 $\\Phi(0) = I$（其中 $I$ 是 $2 \\times 2$ 单位矩阵）下，任何初值问题 $\\mathbf{y}(0) = \\mathbf{y}_0$ 的解都由 $\\mathbf{y}(t) = \\Phi(t)\\mathbf{y}_0$ 给出。\n\n单值矩阵 $M$ 定义为基本矩阵在一个完整周期后的值，即 $M = \\Phi(T)$。对于马丢方程，周期是 $T=\\pi$。系统在周期的整数倍时刻的状态由 $\\mathbf{y}(k T) = M^k \\mathbf{y}_0$ 给出。因此，解的长期行为由 $M$ 的幂决定，而 $M$ 的幂又受其特征值 $\\lambda_1, \\lambda_2$（称为 Floquet 乘子）控制。\n\n一个解在所有时间上有界的充要条件是序列 $\\|\\mathbf{y}(kT)\\|$ 对所有整数 $k \\ge 0$ 有界。这发生的充要条件是 $M$ 的特征值满足特定条件。如果任何一个特征值 $\\lambda_i$ 的模大于 $1$，$|\\lambda_i| > 1$，则对应的模式将呈指数增长，导致解无界（不稳定）。如果所有特征值的模都小于或等于 $1$，则解是有界的（稳定）。\n\n问题指定了稳定性判据：所有解有界的充要条件是两个乘子的 $|\\lambda_i| \\le 1$。问题中说明了 $|\\lambda_i| = 1$ 的情况对应于中性有界振荡。对于当前系统，矩阵 $A(t)$ 的迹为 $\\mathrm{tr}(A(t)) = 0 + 0 = 0$。根据刘维尔公式（Liouville's formula），基本矩阵的行列式由 $\\det(\\Phi(t)) = \\det(\\Phi(0)) \\exp\\left(\\int_0^t \\mathrm{tr}(A(\\tau)) d\\tau\\right)$ 给出。由于 $\\Phi(0) = I$，我们有 $\\det(\\Phi(0)) = 1$。由于迹为零，我们发现对所有 $t$ 都有 $\\det(\\Phi(t)) = 1$。因此，单值矩阵的行列式为 $\\det(M) = \\det(\\Phi(\\pi)) = 1$。$M$ 的特征值之积是其行列式，所以 $\\lambda_1 \\lambda_2 = 1$。这意味着特征值要么是 $(\\lambda, 1/\\lambda)$ 形式的实数，要么是单位圆上的共轭复数对 $(e^{i\\theta}, e^{-i\\theta})$。不稳定性（$|\\lambda_i|>1$）只可能在前一种情况下发生，即当 $|\\lambda| \\ne 1$ 时。\n\n根据问题的稳定性规则，如果 `max(|λ₁, |λ₂|) ≤ 1`，则解是稳定的。由于数值积分和浮点运算误差，与 $1$ 的直接比较并不鲁棒。我们建立一个带有小容差 $\\varepsilon > 0$ 的决策规则。\n\n计算上鲁棒的决策规则：系统被认为是稳定的，当且仅当 $\\max(|\\lambda_1|, |\\lambda_2|) \\le 1 + \\varepsilon$。容差的一个合适值为 $\\varepsilon = 10^{-9}$。这考虑到了可能将真实值 $1$ 推得略高的微小数值误差，同时仍能检测到特征值模数显著大于 $1$ 的真正指数不稳定性。\n\n3) 单值矩阵计算的算法设计\n\n任务是通过在区间 $[0, \\pi]$ 上对初始条件为 $\\Phi(0) = I$ 的矩阵常微分方程 $\\dot{\\Phi}(t) = A(t)\\Phi(t)$ 进行数值积分，来求得单值矩阵 $M=\\Phi(\\pi)$。标准的数值常微分方程求解器作用于向量值函数。因此，我们必须将这个 $2 \\times 2$ 矩阵方程转换为一个关于单个向量的一阶常微分方程组。\n\n令 $\\Phi(t)$ 的分量为\n$$\n\\Phi(t) = \\begin{pmatrix} \\phi_{11}(t)  \\phi_{12}(t) \\\\ \\phi_{21}(t)  \\phi_{22}(t) \\end{pmatrix}\n$$\n矩阵方程 $\\dot{\\Phi} = A\\Phi$ 展开为：\n$$\n\\frac{d}{dt} \\begin{pmatrix} \\phi_{11}  \\phi_{12} \\\\ \\phi_{21}  \\phi_{22} \\end{pmatrix} = \\begin{pmatrix} 0  1 \\\\ -a + 2q\\cos(2t)  0 \\end{pmatrix} \\begin{pmatrix} \\phi_{11}  \\phi_{12} \\\\ \\phi_{21}  \\phi_{22} \\end{pmatrix} = \\begin{pmatrix} \\phi_{21}  \\phi_{22} \\\\ (-a+2q\\cos(2t))\\phi_{11}  (-a+2q\\cos(2t))\\phi_{12} \\end{pmatrix}\n$$\n这产生了四个耦合的标量常微分方程。我们通过堆叠 $\\Phi(t)$ 的列来形成一个状态向量 $\\mathbf{z}(t) \\in \\mathbb{R}^4$：\n$$\n\\mathbf{z}(t) = \\begin{pmatrix} \\phi_{11}(t) \\\\ \\phi_{21}(t) \\\\ \\phi_{12}(t) \\\\ \\phi_{22}(t) \\end{pmatrix}\n$$\n针对 $\\mathbf{z}(t) = [z_1, z_2, z_3, z_4]^T$ 的常微分方程组是：\n$$\n\\dot{z}_1 = \\dot{\\phi}_{11} = \\phi_{21} = z_2 \\\\\n\\dot{z}_2 = \\dot{\\phi}_{21} = (-a+2q\\cos(2t))\\phi_{11} = (-a+2q\\cos(2t))z_1 \\\\\n\\dot{z}_3 = \\dot{\\phi}_{12} = \\phi_{22} = z_4 \\\\\n\\dot{z}_4 = \\dot{\\phi}_{22} = (-a+2q\\cos(2t))\\phi_{12} = (-a+2q\\cos(2t))z_3\n$$\n初始条件 $\\Phi(0) = I = \\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix}$ 转化为初始向量：\n$$\n\\mathbf{z}(0) = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\\\ 1 \\end{pmatrix}\n$$\n算法如下：\n1. 对于给定的参数对 $(a, q)$，定义关于 $\\mathbf{z}(t)$ 的四维常微分方程组。\n2. 使用数值常微分方程求解器（例如龙格-库塔法 Runge-Kutta method）在时间区间 $[0, \\pi]$ 上对初始条件为 $\\mathbf{z}(0) = [1, 0, 0, 1]^T$ 的该系统进行积分。\n3. 求解器返回最终时刻的状态向量 $\\mathbf{z}(\\pi)$。\n4. 将结果向量 $\\mathbf{z}(\\pi) = [z_1(\\pi), z_2(\\pi), z_3(\\pi), z_4(\\pi)]^T$ 重塑回 $2 \\times 2$ 的单值矩阵 $M$：\n    $$\n    M = \\begin{pmatrix} z_1(\\pi)  z_3(\\pi) \\\\ z_2(\\pi)  z_4(\\pi) \\end{pmatrix}\n    $$\n5. 计算矩阵 $M$ 的特征值 $\\lambda_1, \\lambda_2$。\n6. 应用第 2 部分的决策规则：计算 $\\max(|\\lambda_1|, |\\lambda_2|)$ 并检查它是否小于或等于 $1 + \\varepsilon$。\n\n4) 实现\n上述算法将用 Python 程序实现，并遵循指定的格式和执行环境约束。这将涉及使用 `scipy.integrate.solve_ivp` 函数进行数值积分，以及使用 `numpy` 进行线性代数运算。每个测试案例的最终输出将是一个表示稳定性的布尔值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves for the stability of the Mathieu equation for several parameter sets\n    using Floquet theory and numerical integration.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each entry is a tuple (a, q).\n    test_cases = [\n        (1.0, 0.0),       # Case 1\n        (-1.0, 0.0),      # Case 2\n        (0.5, 1.0e-6),    # Case 3\n        (-0.5, 1.0e-6),   # Case 4\n        (0.0, 0.0)        # Case 5\n    ]\n    \n    # Numerical tolerance for stability check.\n    # This accounts for floating point inaccuracies in the integration and\n    # eigenvalue calculation.\n    TOLERANCE = 1.0e-9\n\n    results = []\n\n    def flattened_ode_system(t, z, a, q):\n        \"\"\"\n        Defines the 4-dimensional system of first-order ODEs for the \n        flattened fundamental matrix Phi(t).\n        \n        The state vector z represents the column-stacked elements of Phi:\n        z = [phi_11, phi_21, phi_12, phi_22]^T\n        The original 2x2 system is dot(y) = A(t) * y, where\n        A(t) = [[0, 1], [-(a - 2q*cos(2t)), 0]].\n        \n        This function computes dot(z).\n        \"\"\"\n        # Unpack the state vector\n        # z1 = phi_11, z2 = phi_21, z3 = phi_12, z4 = phi_22\n        z1, z2, z3, z4 = z\n        \n        # This is the (2,1) element of the matrix A(t)\n        a21 = -(a - 2.0 * q * np.cos(2.0 * t))\n        \n        # Derivatives from the matrix equation dot(Phi) = A * Phi\n        dz1_dt = z2                 # dot(phi_11) = phi_21\n        dz2_dt = a21 * z1           # dot(phi_21) = a21 * phi_11\n        dz3_dt = z4                 # dot(phi_12) = phi_22\n        dz4_dt = a21 * z3           # dot(phi_22) = a21 * phi_12\n        \n        return np.array([dz1_dt, dz2_dt, dz3_dt, dz4_dt])\n\n    for a, q in test_cases:\n        # Set the time span for one period T = pi\n        t_span = (0.0, np.pi)\n        \n        # Initial condition Phi(0) = I, which flattens to z0.\n        # z0 = [phi_11(0), phi_21(0), phi_12(0), phi_22(0)]\n        z0 = np.array([1.0, 0.0, 0.0, 1.0])\n        \n        # Numerically integrate the system of ODEs\n        # We use a high-precision method with tight tolerances to ensure\n        # accuracy for the monodromy matrix calculation.\n        sol = solve_ivp(\n            fun=lambda t, z: flattened_ode_system(t, z, a, q),\n            t_span=t_span,\n            y0=z0,\n            method='DOP853',\n            rtol=1e-12,\n            atol=1e-12\n        )\n        \n        # The final state vector z(pi)\n        z_final = sol.y[:, -1]\n        \n        # Reshape the flattened final state vector back into the 2x2\n        # monodromy matrix M = Phi(pi).\n        # We use 'F' (Fortran) order because we stacked the columns.\n        monodromy_matrix = z_final.reshape((2, 2), order='F')\n        \n        # Compute the eigenvalues (Floquet multipliers) of M\n        eigenvalues = np.linalg.eigvals(monodromy_matrix)\n        \n        # Compute the moduli (absolute values) of the eigenvalues\n        abs_eigenvalues = np.abs(eigenvalues)\n        \n        # Apply the stability criterion:\n        # The solution is stable if the modulus of all eigenvalues is\n        # less than or equal to 1 (within a numerical tolerance).\n        is_stable = np.max(abs_eigenvalues) = 1.0 + TOLERANCE\n        \n        results.append(is_stable)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(lambda x: str(x).lower(), results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "从单个粒子的动力学，我们现在将视野扩展到由许多相互作用的粒子组成的复杂系统。费米-帕斯塔-乌拉姆-钦戈 (Fermi-Pasta-Ulam-Tsingou, FPUT) 问题是计算物理学史上的一个里程碑，它揭示了简单的非线性相互作用如何引出意想不到的集体行为。在这个练习中，你将模拟一个耦合振子链，并分析能量如何在不同振动模式之间流动，从而亲身体验著名的“FPU回归”现象，并触及非线性动力学和遍历性等前沿概念 。",
            "id": "2444879",
            "problem": "考虑一个一维 Fermi-Pasta-Ulam-Tsingou (FPUT) $\\alpha$-模型，它由一个包含 $N$ 个相同质点的链组成，具有固定边界条件和包含弱非线性修正的最近邻弹簧。令 $u_n(t)$ 表示第 $n$ 个质点在时间 $t$ 时偏离平衡位置的位移（$n \\in \\{1,2,\\dots,N\\}$），并令 $v_n(t) = \\dot{u}_n(t)$ 表示其速度。链的端点满足固定边界条件 $u_0(t) = 0$ 和 $u_{N+1}(t) = 0$（对所有 $t$）。假设质量和线性弹簧常数均为单位1，因此所有量都是无量纲的。\n\n运动方程为以下耦合一阶系统：\n$\n\\dot{u}_n = v_n,\n$\n$\n\\dot{v}_n = \\left(u_{n+1} - 2u_n + u_{n-1}\\right) + \\alpha\\left[\\left(u_{n+1} - u_n\\right)^2 - \\left(u_n - u_{n-1}\\right)^2\\right],\n$\n其中 $n \\in \\{1,2,\\dots,N\\}$，且 $u_0 = 0$ 和 $u_{N+1} = 0$，$\\alpha$ 是非线性参数。\n\n定义相应纯线性链（即 $\\alpha = 0$ 时）的线性简正模为：\n$\n\\phi_k(n) = \\sqrt{\\frac{2}{N+1}} \\sin\\!\\left(\\frac{k\\pi n}{N+1}\\right),\n$\n其模态频率为：\n$\n\\omega_k = 2\\sin\\!\\left(\\frac{k\\pi}{2(N+1)}\\right),\n$\n其中 $k \\in \\{1,2,\\dots,N\\}$。对于任意状态 $\\{u_n,v_n\\}_{n=1}^N$，定义线性模态坐标为：\n$\nq_k = \\sum_{n=1}^{N} u_n \\, \\phi_k(n), \\quad p_k = \\sum_{n=1}^{N} v_n \\, \\phi_k(n),\n$\n以及相关的线性模态能量：\n$\nE_k = \\frac{1}{2}\\left(p_k^2 + \\omega_k^2 q_k^2\\right).\n$\n令 $E_{\\mathrm{sum}}(t) = \\sum_{k=1}^{N} E_k(t)$，并令 $E_1(t)$ 表示第一模态的能量。初始条件为在第一线性模态上的单模激发，且初始速度为零：\n$\nu_n(0) = A \\sin\\!\\left(\\frac{\\pi n}{N+1}\\right), \\quad v_n(0) = 0,\n$\n对所有 $n \\in \\{1,2,\\dots,N\\}$ 成立，其中 $A$ 是初始振幅。\n\n定义回归检测准则如下。给定容差参数 $\\epsilon \\in (0,1)$ 和 $\\eta \\in (0,1)$ 以及时间范围 $T_{\\max} > 0$，如果存在时间 $t_a$ 和 $t_b$ 满足 $0  t_a  t_b \\le T_{\\max}$ 且符合以下条件，则称观测到一次回归：\n- 偏离：$E_1(t_a)/E_{\\mathrm{sum}}(t_a) \\le 1 - \\eta$，\n- 回归：$E_1(t_b)/E_{\\mathrm{sum}}(t_b) \\ge 1 - \\epsilon$，\n并且 $t_b$ 是在某个偏离时间 $t_a$ 之后满足回归条件的最小时间。回归时间定义为 $t_b$。如果在区间 $(0, T_{\\max}]$ 内不存在这样的 $t_b$，则回归时间定义为 $-1$。\n\n所有量均为无量纲。所有时间均以无量纲单位的实数形式报告。\n\n测试套件。对于以下每个参数集 $(N,\\alpha,A,T_{\\max},\\epsilon,\\eta)$，计算如上定义的回归时间：\n- 情况 1：$(N,\\alpha,A,T_{\\max},\\epsilon,\\eta) = (8,\\,0.25,\\,0.3,\\,300,\\,0.1,\\,0.1)$。\n- 情况 2：$(N,\\alpha,A,T_{\\max},\\epsilon,\\eta) = (8,\\,0,\\,0.3,\\,100,\\,0.1,\\,0.1)$。\n- 情况 3：$(N,\\alpha,A,T_{\\max},\\epsilon,\\eta) = (8,\\,1.0,\\,0.3,\\,300,\\,0.1,\\,0.1)$。\n\n最终输出格式。您的程序应生成单行输出，其中包含上述三种情况的回归时间，形式为用方括号括起来的逗号分隔列表，例如 $[t_1,t_2,t_3]$，其中每个 $t_i$ 是一个无量纲单位的实数，如果在指定的时间范围内未观测到回归，则其值为 $-1$。",
            "solution": "所提出的问题是计算物理学中一个适定且科学上合理的问题。它要求对 Fermi-Pasta-Ulam-Tsingou (FPUT) $\\alpha$-模型的运动方程进行数值积分，然后在线性简正模空间中分析系统轨迹以确定回归时间。该问题是自洽的，所有参数、方程、初始条件和分析准则都有明确定义。它是非线性动力学研究中的一个典型问题，没有任何科学或逻辑上的缺陷。因此，我们可以着手求解。\n\n问题的核心是求解一个包含 $2N$ 个耦合一阶常微分方程（ODE）的系统。令系统状态由向量 $Y(t) \\in \\mathbb{R}^{2N}$ 表示，其中 $Y = [u_1, \\dots, u_N, v_1, \\dots, v_N]^T$。分量 $u_n(t)$ 是 $N$ 个质点的位移，$v_n(t) = \\dot{u}_n(t)$ 是它们的速度。系统的时间演化由 $\\dot{Y}(t) = f(t, Y)$ 控制。函数 $f(t, Y)$ 从运动方程导出：\n$$\n\\dot{u}_n = v_n\n$$\n$$\n\\dot{v}_n = (u_{n+1} - 2u_n + u_{n-1}) + \\alpha\\left[(u_{n+1} - u_n)^2 - (u_n - u_{n-1})^2\\right]\n$$\n这些方程对 $n \\in \\{1, \\dots, N\\}$ 成立，并具有固定边界条件 $u_0(t) = 0$ 和 $u_{N+1}(t) = 0$。状态向量导数 $\\dot{Y}$ 可以通过将其前 $N$ 个分量设置为 $[v_1, \\dots, v_N]$，后 $N$ 个分量设置为 $[\\dot{v}_1, \\dots, \\dot{v}_N]$ 来构造，其中 $\\dot{v}_n$ 使用上述公式计算。对于数值实现，通过创建一个填充后的位移数组 $[0, u_1, \\dots, u_N, 0]$ 来处理边界条件。\n\n为了解决这个初值问题，我们使用一个高质量的数值 ODE 求解器。SciPy 库中的 `solve_ivp` 函数是一个合适的选择，因为它提供了鲁棒的、自适应步长的积分方法（例如 Runge-Kutta-Fehlberg 方法，RK45），适合该系统的振荡特性。我们设置严格的相对和绝对误差容限（例如，$10^{-9}$），以确保数值轨迹在指定的时间范围 $T_{\\max}$ 内是准确的。利用 `dense_output=True` 选项可以获得解的连续表示，然后可以在高频率点上对其进行求值以进行分析。\n\n初始条件被指定为第一线性简正模的纯激发，且初始速度为零：\n$$\nu_n(0) = A \\sin\\left(\\frac{\\pi n}{N+1}\\right), \\quad v_n(0) = 0\n$$\n这定义了初始状态向量 $Y(0)$。\n\n在将系统从 $t=0$ 到 $t=T_{\\max}$ 进行数值积分后，必须在线性简正模的基下分析所得的轨迹 $\\{u_n(t), v_n(t)\\}$。模态坐标 $(q_k, p_k)$ 通过线性变换获得：\n$$\nq_k(t) = \\sum_{n=1}^{N} u_n(t) \\phi_k(n), \\quad p_k(t) = \\sum_{n=1}^{N} v_n(t) \\phi_k(n)\n$$\n其中 $\\phi_k(n) = \\sqrt{\\frac{2}{N+1}} \\sin\\left(\\frac{k\\pi n}{N+1}\\right)$ 是正交归一的模态形状。这种变换可以高效地计算为矩阵-向量乘积，$q(t) = T u(t)$ 和 $p(t) = T v(t)$，其中 $T$ 是变换矩阵，其元素为 $T_{kn} = \\phi_k(n)$。\n\n根据这些模态坐标，可以计算出线性模态能量 $E_k(t)$：\n$$\nE_k(t) = \\frac{1}{2}\\left(p_k(t)^2 + \\omega_k^2 q_k(t)^2\\right)\n$$\n其中 $\\omega_k = 2\\sin\\left(\\frac{k\\pi}{2(N+1)}\\right)$ 是线性模态频率。我们感兴趣的量是第一模态的能量与所有线性模态能量之和的比值，$R(t) = E_1(t) / E_{\\mathrm{sum}}(t)$，其中 $E_{\\mathrm{sum}}(t) = \\sum_{k=1}^{N} E_k(t)$。需要注意的是，对于非线性系统（$\\alpha \\ne 0$），$E_{\\mathrm{sum}}(t)$ 不是一个守恒量，这与系统的真实总哈密顿量不同。\n\n最后，通过分析比值 $R(t)$ 的时间序列来确定回归时间。根据问题定义，我们必须找到最小的时间 $t_b \\in (0, T_{\\max}]$，使得 $R(t_b) \\ge 1 - \\epsilon$，且存在某个更早的时间 $t_a \\in (0, t_b)$ 使得 $R(t_a) \\le 1 - \\eta$。这可以通过遍历计算出的时间点来实现，首先等待满足“偏离”条件（$R(t) \\le 1 - \\eta$），然后搜索第一个满足“回归”条件（$R(t) \\ge 1 - \\epsilon$）的后续时间。如果在时间范围内没有发生这样的事件序列，则回归时间定义为 $-1$。\n\n对于 $\\alpha=0$ 的特殊情况（情况2），系统是线性的，简正模是解耦的。由于初始条件仅激发第一模态，所有能量将永远保留在该模态中。因此，对于 $k > 1$，$E_k(t) = 0$，而 $E_1(t)$ 是一个常数。比值 $R(t)$ 对所有 $t$ 恒等于 $1$。因此，偏离条件 $R(t) \\le 1 - \\eta$（对于 $\\eta > 0$）永远不会被满足，根据定义，回归时间为 $-1$。这个已知的解析结果为我们对问题的理解提供了一个有价值的验证。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef find_recurrence_time(N, alpha, A, T_max, epsilon, eta):\n    \"\"\"\n    Computes the FPUT recurrence time for a given set of parameters.\n    \"\"\"\n    # For the linear case (alpha=0), the modes are uncoupled.\n    # The initial condition is a pure mode 1 excitation, so energy never leaves\n    # mode 1. The departure condition is never met.\n    if alpha == 0:\n        return -1.0\n\n    # 1. Pre-calculate constants for the given N\n    N_plus_1 = N + 1\n    k = np.arange(1, N + 1)\n    n = np.arange(1, N + 1)\n    \n    # Square of angular frequencies for linear modes\n    omega_k_sq = (2 * np.sin(k * np.pi / (2 * N_plus_1)))**2\n    \n    # Modal transformation matrix T_kn = phi_k(n)\n    k_col = k[:, np.newaxis]\n    n_row = n[np.newaxis, :]\n    T_matrix = np.sqrt(2 / N_plus_1) * np.sin(k_col * np.pi * n_row / N_plus_1)\n    \n    # 2. Define the initial state vector Y0 = [u0, v0]\n    u0 = A * np.sin(np.pi * n / N_plus_1)\n    v0 = np.zeros(N)\n    Y0 = np.concatenate((u0, v0))\n    \n    # 3. Define the derivative function for the ODE system\n    def fput_eom(t, Y, N_val, alpha_val):\n        u = Y[:N_val]\n        v = Y[N_val:]\n        \n        dudt = v\n        \n        # Pad u with fixed boundaries u_0 = 0, u_{N+1} = 0\n        u_padded = np.concatenate(([0], u, [0]))\n        \n        # Linear part of acceleration\n        accel_linear = u_padded[2:] - 2 * u_padded[1:-1] + u_padded[:-2]\n        \n        # Nonlinear part of acceleration\n        diff_u = np.diff(u_padded)  # u_{i+1} - u_i\n        accel_nonlinear = alpha_val * (diff_u[1:]**2 - diff_u[:-1]**2)\n        \n        dvdt = accel_linear + accel_nonlinear\n        \n        return np.concatenate((dudt, dvdt))\n\n    # 4. Integrate the ODE system using a high-precision solver\n    sol = solve_ivp(\n        fput_eom, \n        [0, T_max], \n        Y0, \n        args=(N, alpha), \n        dense_output=True, \n        rtol=1e-9,  # Relative tolerance\n        atol=1e-9   # Absolute tolerance\n    )\n    \n    # 5. Post-process the solution to find recurrence\n    # Evaluate the solution on a fine time grid for analysis\n    num_eval_points = int(T_max * 20) + 1  # Use a fine grid for accuracy\n    t_eval = np.linspace(0, T_max, num_eval_points)\n    Y_t = sol.sol(t_eval)\n    \n    u_t = Y_t[:N, :]\n    v_t = Y_t[N:, :]\n    \n    # Transform to modal coordinates (q, p)\n    q_t = T_matrix @ u_t\n    p_t = T_matrix @ v_t\n    \n    # Calculate linear modal energies E_k(t)\n    # The term omega_k_sq[:, np.newaxis] ensures correct broadcasting\n    E_k_t = 0.5 * (p_t**2 + omega_k_sq[:, np.newaxis] * q_t**2)\n    \n    E1_t = E_k_t[0, :]\n    E_sum_t = np.sum(E_k_t, axis=0)\n    \n    # To prevent division by zero, although not expected for this problem\n    E_sum_t[E_sum_t == 0] = 1.0\n    \n    ratio_t = E1_t / E_sum_t\n    \n    # 6. Find the recurrence time based on the problem's definition\n    departure_threshold = 1.0 - eta\n    return_threshold = 1.0 - epsilon\n    \n    departure_observed = False\n    for i, t in enumerate(t_eval):\n        if t == 0:\n            continue\n        \n        # Check for departure condition\n        if not departure_observed and ratio_t[i] = departure_threshold:\n            departure_observed = True\n            \n        # If departed, check for return condition\n        if departure_observed and ratio_t[i] >= return_threshold:\n            return round(t, 4)  # Return first time return condition is met after departure\n            \n    return -1.0  # No recurrence found within T_max\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, alpha, A, T_max, epsilon, eta)\n        (8, 0.25, 0.3, 300, 0.1, 0.1),\n        (8, 0.0, 0.3, 100, 0.1, 0.1),\n        (8, 1.0, 0.3, 300, 0.1, 0.1),\n    ]\n\n    results = []\n    for case in test_cases:\n        recurrence_time = find_recurrence_time(*case)\n        results.append(recurrence_time)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}