{
    "hands_on_practices": [
        {
            "introduction": "自适应算法的核心是根据局部误差动态调整步长的控制器。最直接的方法是使用标准的比例控制器，但其响应可能过于剧烈。本练习  将引导您探索一种更平滑、更稳定的策略——比例积分（PI）控制器，它借鉴了控制理论的思想，通过引入对前一步误差的“记忆”来优化步长选择，从而让您通过具体计算来量化比较这两种控制器的性能差异。",
            "id": "2153291",
            "problem": "在数值分析领域，自适应步长控制是高效求解常微分方程（ODE）的一项关键技术。自适应算法在每一步调整其步长 $h$，以使局部误差估计 $E$ 保持在期望的容差 TOL 附近。\n\n一种常见的方法是标准比例控制器（控制器 S），它根据已完成步骤 $k$ 的误差 $E_k$ 将步长从 $h_k$ 更新为 $h_{k+1}$：\n$$h_{k+1} = \\gamma h_k \\left( \\frac{\\text{TOL}}{E_k} \\right)^p$$\n其中 $\\gamma$ 是一个安全因子，$p$ 是一个与积分方法阶数相关的常数。\n\n另一种选择是比例积分（PI）控制器（控制器 PI），它结合了前一步的误差 $E_{k-1}$ 信息来平滑步长的选择。其更新规则是：\n$$h_{k+1} = \\gamma h_k \\left( \\frac{\\text{TOL}}{E_k} \\right)^{k_P} \\left( \\frac{\\text{TOL}}{E_{k-1}} \\right)^{k_I}$$\n其中 $k_P$ 和 $k_I$ 分别是比例增益和积分增益。\n\n考虑一个具有以下参数的数值模拟：\n- 期望容差，TOL $= 1.0 \\times 10^{-5}$\n- 安全因子，$\\gamma = 0.9$\n- 控制器 S 的指数，$p = 0.2$\n- 控制器 PI 的增益，$k_P = 0.4$ 和 $k_I = 0.3$\n\n该模拟运行了几个步骤。在步骤 $n$ 开始时，步长为 $h_n = 0.1$。执行此步骤后，得到的局部误差估计为 $E_n = 2.0 \\times 10^{-5}$。基于此误差，使用控制器 S 计算下一步的步长 $h_{n+1}$。然后，模拟继续使用这个新的步长执行步骤 $n+1$，发现得到的误差为 $E_{n+1} = 4.0 \\times 10^{-6}$。\n\n此时，为了确定后续的步长 $h_{n+2}$，基于当前状态（步长 $h_{n+1}$ 和误差历史）考虑了两种方案：\n1.  方案 S：通过继续使用控制器 S 计算 $h_{n+2}^{(S)}$。\n2.  方案 PI：通过切换到 PI 控制器计算 $h_{n+2}^{(PI)}$。\n\n你的任务是确定 PI 控制器提出的步长与标准控制器提出的步长之比。计算 $\\frac{h_{n+2}^{(PI)}}{h_{n+2}^{(S)}}$ 的值。\n\n将你的最终答案四舍五入到三位有效数字。",
            "solution": "我们使用给定的更新法则。对于在步骤 $n+1$ 应用的控制器 S，建议的下一步是\n$$h_{n+2}^{(S)}=\\gamma h_{n+1}\\left(\\frac{\\text{TOL}}{E_{n+1}}\\right)^{p}。$$\n对于在步骤 $n+1$ 应用的控制器 PI，建议的下一步是\n$$h_{n+2}^{(PI)}=\\gamma h_{n+1}\\left(\\frac{\\text{TOL}}{E_{n+1}}\\right)^{k_{P}}\\left(\\frac{\\text{TOL}}{E_{n}}\\right)^{k_{I}}。$$\n因此，它们的比值为\n$$\\frac{h_{n+2}^{(PI)}}{h_{n+2}^{(S)}}=\\left(\\frac{\\text{TOL}}{E_{n+1}}\\right)^{k_{P}-p}\\left(\\frac{\\text{TOL}}{E_{n}}\\right)^{k_{I}}。$$\n根据给定值 $\\text{TOL}=1.0\\times 10^{-5}$、$E_{n}=2.0\\times 10^{-5}$、$E_{n+1}=4.0\\times 10^{-6}$、$p=0.2$、$k_{P}=0.4$ 和 $k_{I}=0.3$，我们有\n$$\\frac{\\text{TOL}}{E_{n+1}}=\\frac{1.0\\times 10^{-5}}{4.0\\times 10^{-6}}=2.5,\\qquad \\frac{\\text{TOL}}{E_{n}}=\\frac{1.0\\times 10^{-5}}{2.0\\times 10^{-5}}=0.5,$$\n所以\n$$\\frac{h_{n+2}^{(PI)}}{h_{n+2}^{(S)}}=(2.5)^{0.2}(0.5)^{0.3}。$$\n通过对数计算，\n$$\\ln\\!\\left(\\frac{h_{n+2}^{(PI)}}{h_{n+2}^{(S)}}\\right)=0.2\\ln(2.5)+0.3\\ln(0.5)\\approx 0.2\\cdot 0.9162907319+0.3\\cdot(-0.6931471806)\\approx -0.024686,$$\n因此\n$$\\frac{h_{n+2}^{(PI)}}{h_{n+2}^{(S)}}=\\exp(-0.024686)\\approx 0.9756,$$\n四舍五入到三位有效数字为 $0.976$。",
            "answer": "$$\\boxed{0.976}$$"
        },
        {
            "introduction": "任何自适应步长控制器的运行都离不开对局部误差的有效估计。本练习  旨在通过动手实践，让您比较两种经典的误差估计算法：步长加倍法和嵌入式龙格-库塔-费尔贝格（RKF45）方法。通过从零开始实现这两种策略并量化它们的计算成本，您将深刻理解为什么嵌入式方法因其高效率而成为现代科学计算中的主流选择。",
            "id": "2372273",
            "problem": "你需要编写一个完整的程序，比较两种自适应步长策略，用于求解一个常微分方程的标量初值问题。考虑一个形式为 $y'(t)=f(t,y)$ 且满足 $y(t_0)=y_0$ 的初值问题，其定义在有限区间 $[t_0,t_f]$ 上。对于下文的每个测试用例，从 $t_0$ 积分到 $t_f$，并为嵌入式 Runge–Kutta–Fehlberg $4(5)$ 方法和基于经典四阶 Runge–Kutta 方法构建的步长加倍策略分别生成一份总结。对于每种策略，报告函数求值的总次数以及所有被接受步长的算术平均值。\n\n两种策略都必须严格遵守以下数学规范：\n- 误差缩放：对于从 $(t,y)$ 开始、步长为 $h$ 的一个试探步，定义标量尺度 $s=\\max\\{|y|,|y_{\\mathrm{trial}}|\\}$，容差 $T=\\text{atol}+\\text{rtol}\\cdot s$，以及由该策略计算出的误差估计 $E\\ge 0$。一个试探步被接受当且仅当 $E\\le T$。如果被接受，则更新 $(t,y)\\leftarrow (t+h,y_{\\mathrm{accept}})$。如果试探步将超过 $t_f$，则在试探前将 $h$ 替换为 $t_f-t$。\n- 步长更新：设方法的有效局部误差阶为 $q=5$，因此局部误差表现为 $\\mathcal{O}(h^q)$。在任何一次试探（无论接受或拒绝）之后，定义增长因子\n$$\ng=\n\\begin{cases}\n\\max(g_{\\min},\\min(g_{\\max},\\,\\sigma\\,(T/\\max(E,\\varepsilon))^{1/q} )),  E>0,\\\\\ng_{\\max},  E=0,\n\\end{cases}\n$$\n其中固定常数 $\\sigma=0.9$, $g_{\\min}=0.2$, $g_{\\max}=5$, 以及 $\\varepsilon=10^{-30}$。然后将下一个试探步长设置为 $h\\leftarrow \\max(h_{\\min},\\min(h_{\\max},g\\,h))$，其中 $h_{\\min}=10^{-12}$ 且 $h_{\\max}=t_f-t_0$。对于所有测试用例，初始步长必须为 $h_0=(t_f-t_0)/50$。\n- 角度单位：所有出现的三角函数均使用弧度。\n\n嵌入式 Runge–Kutta–Fehlberg $4(5)$ 方法详情：\n- 使用经典的 Fehlberg 系数，共 $6$ 级。给定 $h$，内部各级计算如下\n$$\n\\begin{aligned}\nk_1=f(t, y),\\\\\nk_2=f\\!\\left(t+\\tfrac{1}{4}h,\\,y+h\\left(\\tfrac{1}{4}k_1\\right)\\right),\\\\\nk_3=f\\!\\left(t+\\tfrac{3}{8}h,\\,y+h\\left(\\tfrac{3}{32}k_1+\\tfrac{9}{32}k_2\\right)\\right),\\\\\nk_4=f\\!\\left(t+\\tfrac{12}{13}h,\\,y+h\\left(\\tfrac{1932}{2197}k_1-\\tfrac{7200}{2197}k_2+\\tfrac{7296}{2197}k_3\\right)\\right),\\\\\nk_5=f\\!\\left(t+h,\\,y+h\\left(\\tfrac{439}{216}k_1-8k_2+\\tfrac{3680}{513}k_3-\\tfrac{845}{4104}k_4\\right)\\right),\\\\\nk_6=f\\!\\left(t+\\tfrac{1}{2}h,\\,y+h\\left(-\\tfrac{8}{27}k_1+2k_2-\\tfrac{3544}{2565}k_3+\\tfrac{1859}{4104}k_4-\\tfrac{11}{40}k_5\\right)\\right).\n\\end{aligned}\n$$\n四阶和五阶的试探解为\n$$\n\\begin{aligned}\ny_4=y+h\\left(\\tfrac{25}{216}k_1+\\tfrac{1408}{2565}k_3+\\tfrac{2197}{4104}k_4-\\tfrac{1}{5}k_5\\right),\\\\\ny_5=y+h\\left(\\tfrac{16}{135}k_1+\\tfrac{6656}{12825}k_3+\\tfrac{28561}{56430}k_4-\\tfrac{9}{50}k_5+\\tfrac{2}{55}k_6\\right).\n\\end{aligned}\n$$\n使用 $y_{\\mathrm{trial}}=y_5$，$y_{\\mathrm{accept}}=y_5$，以及误差估计 $E=|y_5-y_4|$。每次试探步精确计算 $6$ 次函数求值（无论是否接受）。\n\n步长加倍策略（基于经典的四阶 Runge–Kutta 方法）：\n- 对于步长 $h$，经典的四阶 Runge–Kutta 步长计算如下\n$$\n\\begin{aligned}\nK_1=f(t,y),\\quad K_2=f\\!\\left(t+\\tfrac{h}{2},y+\\tfrac{h}{2}K_1\\right),\\quad K_3=f\\!\\left(t+\\tfrac{h}{2},y+\\tfrac{h}{2}K_2\\right),\\\\\nK_4=f\\!\\left(t+h,y+hK_3\\right),\\quad \\Phi_h(y)=y+\\tfrac{h}{6}\\left(K_1+2K_2+2K_3+K_4\\right).\n\\end{aligned}\n$$\n对于每个试探步，计算 $y^{(1)}=\\Phi_h(y)$ 和 $y^{(2)}=\\Phi_{h/2}(\\Phi_{h/2}(y))$。使用 $y_{\\mathrm{trial}}=y^{(2)}$，$y_{\\mathrm{accept}}=y^{(2)}$，以及 Richardson 误差估计\n$$\nE=\\frac{|\\,y^{(2)}-y^{(1)}\\,|}{2^4-1}=\\frac{|\\,y^{(2)}-y^{(1)}\\,|}{15}.\n$$\n每次试探步精确计算 $12$ 次函数求值（一个整步需要 4 次求值，两个半步需要 8 次求值），无论是否接受。\n\n测试套件：\n对于下面的每种情况 $i\\in\\{1,2,3\\}$，程序必须使用相同的 $(t_0,t_f,y_0,\\text{rtol},\\text{atol})$ 运行两种策略，并生成“要求的最终输出格式”下指定的输出。\n- 情况 1 (平滑线性): $f(t,y)=-2y+t$, $t_0=0$, $t_f=10$, $y_0=1$, $\\text{rtol}=10^{-6}$, $\\text{atol}=10^{-9}$。\n- 情况 2 (振荡强迫项，弧度): $f(t,y)=50\\cos(50t)-y$, $t_0=0$, $t_f=2$, $y_0=0$, $\\text{rtol}=10^{-5}$, $\\text{atol}=10^{-7}$。\n- 情况 3 (逻辑斯谛增长): $f(t,y)=y(1-y)$, $t_0=0$, $t_f=10$, $y_0=10^{-6}$, $\\text{rtol}=10^{-7}$, $\\text{atol}=10^{-12}$。\n\n要求的最终输出格式：\n你的程序应生成单行输出，其中包含一个有三个条目（每个测试用例一个）的列表，每个条目是以下形式的列表\n$$\n[\\;N_{\\mathrm{RKF45}},\\;N_{\\mathrm{SD}},\\;\\overline{h}_{\\mathrm{RKF45}},\\;\\overline{h}_{\\mathrm{SD}}\\;],\n$$\n其中 $N_{\\mathrm{RKF45}}$ 是嵌入式 Runge–Kutta–Fehlberg 方法使用的函数求值总次数，$N_{\\mathrm{SD}}$ 是步长加倍策略使用的函数求值总次数，$\\overline{h}_{\\mathrm{RKF45}}$ 是嵌入式 Runge–Kutta–Fehlberg 方法在 $[t_0,t_f]$ 上的所有被接受步长的算术平均值，$\\overline{h}_{\\mathrm{SD}}$ 是步长加倍策略在 $[t_0,t_f]$ 上的所有被接受步长的算术平均值。输出必须以 Python 列表的精确格式打印为单行，例如：\n[[N1_RKF45,N1_SD,mean_h1_RKF45,mean_h1_SD],[N2_RKF45,N2_SD,mean_h2_RKF45,mean_h2_SD],[N3_RKF45,N3_SD,mean_h3_RKF45,mean_h3_SD]]\n\n不应打印任何额外文本。",
            "solution": "此任务是实现并比较两种用于求解标量常微分方程（ODE）的自适应步长控制策略。自适应积分的基本原理是动态调整步长 $h$，以确保每步的局部截断误差保持在用户定义的容差范围内。这种方法比使用固定步长效率显著更高，因为它允许积分器在解平滑时采用大步长，在解快速变化时采用小步长。\n\n两种策略的控制机制均由一个通用框架所控制。在每个时间点 $t$ 及其解 $y$ 处，尝试一个大小为 $h$ 的试探步。这将产生一个试探解 $y_{\\mathrm{trial}}$ 和一个局部误差的估计值 $E \\ge 0$。如果 $E \\le T$，则该步长被认为是可接受的，其中 $T$ 是容差，定义为相对容差和绝对容差的组合：$T = \\text{atol} + \\text{rtol} \\cdot s$，尺度因子 $s = \\max\\{|y|, |y_{\\mathrm{trial}}|\\}$。如果步长被接受，解就推进到 $(t+h, y_{\\mathrm{accept}})$。\n\n无论步长被接受还是拒绝，下一个试探步的步长 $h_{\\text{new}}$ 都将根据观测到的误差进行计算。题目指定了一个标准的更新规则：\n$$\nh_{\\text{new}} = g \\cdot h_{\\text{old}}\n$$\n其中 $g$ 是一个增长因子。对于一个局部误差估计表现为 $\\mathcal{O}(h^q)$ 的方法，理想的因子应为 $(T/E)^{1/q}$。为确保稳定性，该因子被调节：\n$$\ng =\n\\begin{cases}\n\\max\\left(g_{\\min}, \\min\\left(g_{\\max}, \\sigma \\left(\\frac{T}{\\max(E, \\varepsilon)}\\right)^{1/q}\\right)\\right),  E > 0 \\\\\ng_{\\max},  E = 0\n\\end{cases}\n$$\n这里，$\\sigma  1$ 是一个安全因子，$\\varepsilon$ 是一个非常小的数以防止除以零，而 $g_{\\min}, g_{\\max}$ 是防止步长发生剧烈变化的界限。题目指定了 $q=5$, $\\sigma=0.9$, $g_{\\min}=0.2$, $g_{\\max}=5$, 以及 $\\varepsilon=10^{-30}$。新的步长也被限制在 $[h_{\\min}, h_{\\max}]$ 范围内。\n\n这两种策略的唯一区别在于它们如何计算试探解和误差估计 $E$。\n\n**1. 嵌入式 Runge–Kutta–Fehlberg $4(5)$ 方法 (RKF45)**\n\n这是一种“嵌入式”方法，它使用一对不同阶数（$p=4$ 和 $p+1=5$）的 Runge-Kutta 公式，这些公式共享中间的函数求值（级），以最小化计算成本。对于一个步长 $h$，该方法计算六个级 $k_1, \\dots, k_6$，然后将它们线性组合以产生两种近似解：一个四阶解 $y_4$ 和一个五阶解 $y_5$。\n$$\ny_4 = y + h \\sum_{i=1}^6 b_i k_i, \\quad y_5 = y + h \\sum_{i=1}^6 b_i^* k_i\n$$\n题目指定使用高阶解来推进积分，因此 $y_{\\mathrm{trial}} = y_5$ 且 $y_{\\mathrm{accept}} = y_5$。这两个解之间的差值为低阶方法的局部截断误差提供了一个渐近正确的估计：\n$$\nE = |y_5 - y_4| = \\mathcal{O}(h^5)\n$$\n该误差估计用于步长控制逻辑。由于误差估计是 5 阶的，指定的控制器参数 $q=5$ 是合适的。整个过程每次试探步需要 $6$ 次函数求值。\n\n**2. 基于经典四阶 Runge-Kutta (RK4) 的步长加倍法**\n\n该策略基于 Richardson 外推法，使用单一的基础方法（RK4，阶数 $p=4$）来生成误差估计。对于一个期望的步长 $h$，解通过两种不同的方式从 $t$ 推进到 $t+h$：\n- 一个大小为 $h$ 的单步，得到 $y^{(1)} = \\Phi_h(y)$。\n- 两个大小为 $h/2$ 的连续步，得到 $y^{(2)} = \\Phi_{h/2}(\\Phi_{h/2}(y))$。\n\n更精确的解 $y^{(2)}$ 的局部截断误差可以通过两个结果之间的差来估计：\n$$\nE = \\frac{|y^{(2)} - y^{(1)}|}{2^p - 1} = \\frac{|y^{(2)} - y^{(1)}|}{15}\n$$\n该误差估计的阶数也是 $\\mathcal{O}(h^{p+1}) = \\mathcal{O}(h^5)$，因此为步长控制器选择 $q=5$ 是正确的。题目指定用更精确的结果来推进解，即 $y_{\\text{accept}} = y^{(2)}$。这种技术是计算密集型的；一次试探需要一个整步（$4$ 次函数求值）和两个半步（$2 \\times 4 = 8$ 次求值），总共需要 $12$ 次函数求值，因为没有任何级的计算被共享。\n\n程序围绕一个实现主控制循环的通用自适应积分函数构建。该函数接受一个“步进器”函数作为参数，此函数封装了特定于 RKF45 或步长加倍法的逻辑。这种设计将控制逻辑与误差估计方法清晰地分离开来。主脚本定义了三个指定的 ODE 问题，并对每个问题调用积分器两次——一次使用 RKF45 步进器，一次使用步长加倍步进器——以计算并报告所需的性能指标。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\n# --- Global constants for step-size control ---\nSIGMA = 0.9\nG_MIN = 0.2\nG_MAX = 5.0\nEPSILON = 1e-30\nH_MIN = 1e-12\nQ_ORDER = 5.0\n\n# --- Stepper implementation for RKF45 ---\ndef rkf45_step(f, t, y, h):\n    \"\"\"\n    Performs one trial step using the Runge-Kutta-Fehlberg 4(5) method.\n    \"\"\"\n    # Fehlberg coefficients\n    k1 = f(t, y)\n    k2 = f(t + 1/4 * h, y + h * (1/4 * k1))\n    k3 = f(t + 3/8 * h, y + h * (3/32 * k1 + 9/32 * k2))\n    k4 = f(t + 12/13 * h, y + h * (1932/2197 * k1 - 7200/2197 * k2 + 7296/2197 * k3))\n    k5 = f(t + h, y + h * (439/216 * k1 - 8 * k2 + 3680/513 * k3 - 845/4104 * k4))\n    k6 = f(t + 1/2 * h, y + h * (-8/27 * k1 + 2 * k2 - 3544/2565 * k3 + 1859/4104 * k4 - 11/40 * k5))\n\n    # 4th and 5th order solutions\n    y4 = y + h * (25/216 * k1 + 1408/2565 * k3 + 2197/4104 * k4 - 1/5 * k5)\n    y5 = y + h * (16/135 * k1 + 6656/12825 * k3 + 28561/56430 * k4 - 9/50 * k5 + 2/55 * k6)\n\n    # Use 5th order for trial and acceptance\n    y_trial = y5\n    y_accept = y5\n\n    # Error estimate is the difference between the two\n    error_est = abs(y5 - y4)\n    \n    # 6 function evaluations per trial step\n    f_evals = 6\n    \n    return y_trial, y_accept, error_est, f_evals\n\n# --- Stepper implementation for Step-Doubling RK4 ---\ndef rk4_single_step(f, t, y, h):\n    \"\"\"\n    Performs a single step of the classical 4th order Runge-Kutta method.\n    \"\"\"\n    k1 = f(t, y)\n    k2 = f(t + h/2.0, y + h/2.0 * k1)\n    k3 = f(t + h/2.0, y + h/2.0 * k2)\n    k4 = f(t + h, y + h * k3)\n    return y + h/6.0 * (k1 + 2*k2 + 2*k3 + k4)\n\ndef sd_rk4_step(f, t, y, h):\n    \"\"\"\n    Performs one trial step using step-doubling with the RK4 method.\n    \"\"\"\n    # One step of size h\n    y1 = rk4_single_step(f, t, y, h)\n    \n    # Two steps of size h/2\n    y_mid = rk4_single_step(f, t, y, h/2.0)\n    y2 = rk4_single_step(f, t + h/2.0, y_mid, h/2.0)\n\n    # Use the more accurate solution for trial and acceptance\n    y_trial = y2\n    y_accept = y2\n    \n    # Richardson error estimate\n    error_est = abs(y2 - y1) / 15.0\n    \n    # 12 function evaluations per trial step (4 for full step, 8 for two half-steps)\n    f_evals = 12\n    \n    return y_trial, y_accept, error_est, f_evals\n\n# --- Generic adaptive ODE integrator ---\ndef integrate(f, t0, tf, y0, rtol, atol, stepper_func):\n    \"\"\"\n    Integrates an ODE using an adaptive step-size strategy.\n    \"\"\"\n    t = float(t0)\n    y = float(y0)\n    \n    h_max = float(tf - t0)\n    h = h_max / 50.0\n\n    total_f_evals = 0\n    accepted_h_sum = 0.0\n    accepted_steps_count = 0\n\n    while t  tf:\n        if t + h > tf:\n            h = tf - t\n\n        y_trial, y_accept, E, f_evals = stepper_func(f, t, y, h)\n        total_f_evals += f_evals\n        \n        s = max(abs(y), abs(y_trial))\n        T = atol + rtol * s\n\n        accepted = (E = T)\n\n        if accepted:\n            accepted_h_sum += h\n            accepted_steps_count += 1\n            t += h\n            y = y_accept\n\n        # Step-size update logic\n        if E > 0:\n            g = max(G_MIN, min(G_MAX, SIGMA * (T / max(E, EPSILON))**(1.0/Q_ORDER)))\n        else: # E == 0 implies error is smaller than machine precision\n            g = G_MAX\n        \n        h = max(H_MIN, min(h_max, g * h))\n\n    mean_h = accepted_h_sum / accepted_steps_count if accepted_steps_count > 0 else 0.0\n    \n    return total_f_evals, mean_h\n\n# --- Main solution function ---\ndef solve():\n    \"\"\"\n    Defines test cases and runs the comparison, printing the final result.\n    \"\"\"\n    # Define the ODE functions for the test cases\n    def f1(t, y): return -2.0 * y + t\n    def f2(t, y): return 50.0 * math.cos(50.0 * t) - y\n    def f3(t, y): return y * (1.0 - y)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: smooth linear\n        (f1, 0.0, 10.0, 1.0, 1e-6, 1e-9),\n        # Case 2: oscillatory forcing\n        (f2, 0.0, 2.0, 0.0, 1e-5, 1e-7),\n        # Case 3: logistic growth\n        (f3, 0.0, 10.0, 1e-6, 1e-7, 1e-12)\n    ]\n\n    results = []\n    for case in test_cases:\n        f, t0, tf, y0, rtol, atol = case\n        \n        # Run RKF45 strategy\n        n_rkf45, h_avg_rkf45 = integrate(f, t0, tf, y0, rtol, atol, rkf45_step)\n        \n        # Run Step-Doubling RK4 strategy\n        n_sd, h_avg_sd = integrate(f, t0, tf, y0, rtol, atol, sd_rk4_step)\n        \n        results.append([n_rkf45, n_sd, h_avg_rkf45, h_avg_sd])\n\n    # Final print statement in the exact required format.\n    print(str(results))\n\nsolve()\n```"
        },
        {
            "introduction": "虽然自适应求解器功能强大，但它们并非绝对可靠，有时会与问题本身的特性发生意想不到的相互作用。本练习  探讨了一种被称为“相位锁定”或“数值共振”的微妙现象，即求解器的步长选择可能与常微分方程中的周期性驱动力发生非预期的同步。通过对求解器内部时间步进行统计分析，您将学会如何诊断这种复杂的数值伪影，从而培养对计算结果的批判性思维。",
            "id": "2372241",
            "problem": "设计并实现一个程序，对于一个周期驱动的二阶常微分方程，定量评估由可变步长积分器生成的内部时间网格是否与驱动力存在锁相现象。考虑由以下方程描述的线性振子\n$$\n\\ddot{x}(t) + 2\\zeta \\,\\omega_0 \\,\\dot{x}(t) + \\omega_0^2 \\, x(t) = F \\cos(\\omega t),\n$$\n其初始条件为\n$$\nx(0) = 0 \\ \\text{and}\\ \\dot{x}(0) = 0.\n$$\n设质量 $m=1$，因此所有参数均按给定值代入。时间单位为秒，所有角度单位为弧度。按标准方法将该二阶方程转换为一阶系统。对于一组给定的参数 $(\\omega_0,\\zeta,F,\\omega)$，从 $t=0$ 积分到 $t=t_{\\text{end}}$，其中\n$$\nt_{\\text{end}} = N_{\\text{periods}} \\cdot \\frac{2\\pi}{\\omega},\n$$\n使用一个可变步长积分器，该积分器通过控制局部截断误差来满足指定的绝对和相对容差。您必须只使用积分器自身的内部时间网格；不要强加外部指定的输出时间点。\n\n对于每次积分，舍弃前 $N_{\\text{burn}}$ 个周期以消除暂态效应。从积分器使用的剩余内部时间戳 $\\{t_k\\}$ 中，计算相对于驱动周期的模 $2\\pi$ 相角：\n$$\n\\phi_k = \\left(\\omega t_k \\right) \\bmod 2\\pi,\n$$\n所有角度均以弧度为单位。通过计算瑞利合成值 $R$ 来量化积分器内部网格与驱动力之间的锁相关系：\n$$\nR = \\frac{1}{N}\\left|\\sum_{k=1}^{N} e^{i \\phi_k}\\right|,\n$$\n其中 $N$ 是暂态结束后的时间戳数量。较大的 $R$ 值表示更强的相位聚集（完全锁相时 $R=1$），而接近 $0$ 的值表示近似均匀的相位分布。\n\n实现您的程序以处理以下测试组。对于每个案例，积分器必须强制执行给定的相对容差 $r_{\\text{tol}}$ 和绝对容差 $a_{\\text{tol}}$，积分 $N_{\\text{periods}}$ 个周期，舍弃 $N_{\\text{burn}}$ 个周期，然后计算并报告相应的 $R$ 值（以浮点数形式）。\n\n- 测试案例 1（一般共振驱动）：\n  - $\\omega_0 = 1.0$\n  - $\\zeta = 0.02$\n  - $F = 1.0$\n  - $\\omega = 1.0$\n  - $r_{\\text{tol}} = 1\\times 10^{-6}$\n  - $a_{\\text{tol}} = 1\\times 10^{-9}$\n  - $N_{\\text{periods}} = 200$\n  - $N_{\\text{burn}} = 5$\n- 测试案例 2（离共振驱动）：\n  - $\\omega_0 = 1.0$\n  - $\\zeta = 0.02$\n  - $F = 1.0$\n  - $\\omega = \\sqrt{2}$\n  - $r_{\\text{tol}} = 1\\times 10^{-6}$\n  - $a_{\\text{tol}} = 1\\times 10^{-9}$\n  - $N_{\\text{periods}} = 200$\n  - $N_{\\text{burn}} = 5$\n- 测试案例 3（无外部驱动）：\n  - $\\omega_0 = 1.0$\n  - $\\zeta = 0.05$\n  - $F = 0.0$\n  - $\\omega = 1.0$\n  - $r_{\\text{tol}} = 1\\times 10^{-6}$\n  - $a_{\\text{tol}} = 1\\times 10^{-9}$\n  - $N_{\\text{periods}} = 200$\n  - $N_{\\text{burn}} = 5$\n- 测试案例 4（共振附近的高精度容差）：\n  - $\\omega_0 = 1.0$\n  - $\\zeta = 0.05$\n  - $F = 10.0$\n  - $\\omega = 1.0$\n  - $r_{\\text{tol}} = 1\\times 10^{-9}$\n  - $a_{\\text{tol}} = 1\\times 10^{-12}$\n  - $N_{\\text{periods}} = 200$\n  - $N_{\\text{burn}} = 5$\n\n您的程序应生成单行输出，其中包含四个瑞利 $R$ 值（无单位）的结果，以逗号分隔列表的形式呈现，并用方括号括起来。每个值需四舍五入到 $6$ 位小数，并按照上述测试案例的顺序排列（例如 `\"[0.123456,0.234567,0.345678,0.456789]\"`）。不允许有任何其他输出。",
            "solution": "所述问题在科学上是合理的、自洽的且定义明确。它提出了一个计算物理学中的标准问题：常微分方程积分中数值伪影的分析。具体来说，它要求量化锁相现象，即自适应积分器的内部时间步长与系统的周期性特征（如外部驱动力）同步。所用方法定义清晰，使用瑞利合成值作为循环数据的标准统计度量。所有参数和测试案例都已明确指定。因此，我们可以开始求解。\n\n问题的核心是描述受驱阻尼谐振子的二阶线性常微分方程（ODE）：\n$$\n\\ddot{x}(t) + 2\\zeta \\,\\omega_0 \\,\\dot{x}(t) + \\omega_0^2 \\, x(t) = F \\cos(\\omega t)\n$$\n初始条件为 $x(0) = 0$ 和 $\\dot{x}(0) = 0$。\n\n为进行数值求解，我们必须首先将其转换为一个由两个一阶 ODE 组成的系统。设状态向量为 $\\mathbf{y}(t) = [y_1(t), y_2(t)]^T$，其中 $y_1(t) = x(t)$ 是位置， $y_2(t) = \\dot{x}(t)$ 是速度。其时间导数则为：\n$$\n\\dot{y}_1(t) = \\frac{d}{dt}x(t) = \\dot{x}(t) = y_2(t)\n$$\n$$\n\\dot{y}_2(t) = \\frac{d}{dt}\\dot{x}(t) = \\ddot{x}(t) = F \\cos(\\omega t) - 2\\zeta \\omega_0 \\dot{x}(t) - \\omega_0^2 x(t) = F \\cos(\\omega t) - 2\\zeta \\omega_0 y_2(t) - \\omega_0^2 y_1(t)\n$$\n这可以写成向量形式 $\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(t, \\mathbf{y})$：\n$$\n\\frac{d}{dt}\n\\begin{pmatrix}\ny_1 \\\\\ny_2\n\\end{pmatrix}\n=\n\\begin{pmatrix}\ny_2 \\\\\nF \\cos(\\omega t) - \\omega_0^2 y_1 - 2\\zeta \\omega_0 y_2\n\\end{pmatrix}\n$$\n初始条件为 $\\mathbf{y}(0) = [0, 0]^T$。\n\n该系统需使用可变步长积分器从 $t=0$ 积分到最终时间 $t_{\\text{end}} = N_{\\text{periods}} \\cdot (2\\pi/\\omega)$。此类积分器，如 Runge-Kutta-Fehlberg 或 Dormand-Prince 方法，在每一步 $k$ 都会调整步长 $h_k = t_{k+1} - t_k$，以确保估计的局部截断误差保持在用户指定的相对容差 $r_{\\text{tol}}$ 和绝对容差 $a_{\\text{tol}}$ 所定义的界限内。因此，时间点序列 $\\{t_k\\}$ 不是均匀的，而是由求解器根据解的局部行为动态确定的。\n\n核心假设是求解器的步长选择算法可能会“锁定”到驱动力的周期 $T_{drive} = 2\\pi/\\omega$ 上。为研究此现象，我们分析求解器选择的内部时间步 $\\{t_k\\}$ 的分布。首先，我们舍弃对应于前 $N_{\\text{burn}}$ 个周期的初始积分部分，以消除暂态行为的影响，该行为以与 $( \\zeta \\omega_0 )^{-1}$ 相关的时间常数衰减。截止时间为 $t_{\\text{burn}} = N_{\\text{burn}} \\cdot (2\\pi/\\omega)$。\n\n对于满足 $t_k > t_{\\text{burn}}$ 的剩余 $N$ 个时间戳 $\\{t_k\\}$，我们计算相对于驱动周期的相应相角 $\\phi_k$：\n$$\n\\phi_k = (\\omega t_k) \\pmod{2\\pi}\n$$\n此计算将每个时间点映射到区间 $[0, 2\\pi)$ 上，表示其在一个驱动周期内的位置。\n\n为了量化这些相位的聚集程度，我们采用瑞利合成值 $R$。每个相位 $\\phi_k$ 在复平面中表示为一个单位向量 $e^{i\\phi_k}$。瑞利合成值是这些向量平均值的大小：\n$$\nR = \\frac{1}{N}\\left|\\sum_{k=1}^{N} e^{i \\phi_k}\\right|\n$$\n如果相位 $\\{\\phi_k\\}$ 均匀分布，这些向量将趋于相互抵消，导致 $R$ 值接近 $0$。相反，如果相位紧密聚集在某个特定值周围，这些向量将相长叠加，产生接近 $1$ 的 $R$ 值。这为锁相提供了一个鲁棒的度量标准。\n\n在实现上，我们将使用 `scipy.integrate.solve_ivp` 函数，这是 SciPy 库中的一个高质量常微分方程数值求解器。通过以 `t_eval=None`（默认值）调用它，求解器会在其内部选择的时间步长上返回解，这些时间步存储在输出对象的 `t` 属性中。这正是问题所要求的内部时间网格。我们使用 `'RK45'` 方法，这是一种自适应步长算法的标准选择。\n\n每个测试案例的流程如下：\n1. 定义参数 $(\\omega_0, \\zeta, F, \\omega, r_{\\text{tol}}, a_{\\text{tol}}, N_{\\text{periods}}, N_{\\text{burn}})$。\n2. 设置 ODE 函数 $\\mathbf{f}(t, \\mathbf{y})$ 和积分时间区间 $[0, t_{\\text{end}}]$。\n3. 调用 `solve_ivp` 执行数值积分并获取内部时间网格 $\\{t_k\\}$。\n4. 筛选此网格，仅保留 $t_k > t_{\\text{burn}}$ 的点。\n5. 为筛选后的时间点计算相位 $\\phi_k = (\\omega t_k) \\pmod{2\\pi}$。\n6. 根据相位计算瑞利合成值 $R$。\n然后将所有四个测试案例的结果按要求格式化并打印。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for phase locking analysis.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: general resonant driving\n        {\n            \"omega0\": 1.0, \"zeta\": 0.02, \"F\": 1.0, \"omega\": 1.0,\n            \"rtol\": 1e-6, \"atol\": 1e-9, \"N_periods\": 200, \"N_burn\": 5\n        },\n        # Case 2: off-resonance driving\n        {\n            \"omega0\": 1.0, \"zeta\": 0.02, \"F\": 1.0, \"omega\": np.sqrt(2.0),\n            \"rtol\": 1e-6, \"atol\": 1e-9, \"N_periods\": 200, \"N_burn\": 5\n        },\n        # Case 3: no external driving\n        {\n            \"omega0\": 1.0, \"zeta\": 0.05, \"F\": 0.0, \"omega\": 1.0,\n            \"rtol\": 1e-6, \"atol\": 1e-9, \"N_periods\": 200, \"N_burn\": 5\n        },\n        # Case 4: tight tolerance near resonance\n        {\n            \"omega0\": 1.0, \"zeta\": 0.05, \"F\": 10.0, \"omega\": 1.0,\n            \"rtol\": 1e-9, \"atol\": 1e-12, \"N_periods\": 200, \"N_burn\": 5\n        },\n    ]\n\n    results = []\n    \n    for params in test_cases:\n        omega0 = params[\"omega0\"]\n        zeta = params[\"zeta\"]\n        F = params[\"F\"]\n        omega = params[\"omega\"]\n        rtol = params[\"rtol\"]\n        atol = params[\"atol\"]\n        N_periods = params[\"N_periods\"]\n        N_burn = params[\"N_burn\"]\n\n        # Define the system of first-order ODEs\n        # y[0] = x, y[1] = x_dot\n        def ode_system(t, y):\n            y1, y2 = y\n            dy1_dt = y2\n            dy2_dt = F * np.cos(omega * t) - omega0**2 * y1 - 2 * zeta * omega0 * y2\n            return [dy1_dt, dy2_dt]\n\n        # Set initial conditions and integration time span\n        y0 = [0.0, 0.0]\n        t_end = N_periods * 2 * np.pi / omega\n        t_span = [0, t_end]\n        \n        # Integrate using a variable step-size method.\n        # By not specifying t_eval, solve_ivp returns results at its internal steps.\n        sol = solve_ivp(\n            ode_system,\n            t_span,\n            y0,\n            method='RK45',\n            rtol=rtol,\n            atol=atol,\n            dense_output=False  # Not needed, we only want the time steps\n        )\n\n        internal_times = sol.t\n\n        # Discard the burn-in period to remove transients\n        t_burn = N_burn * 2 * np.pi / omega\n        post_transient_times = internal_times[internal_times > t_burn]\n\n        if len(post_transient_times) == 0:\n            # Handle case where no points remain after burn-in\n            R = 0.0 \n        else:\n            # Form the phase angles modulo the driving period\n            phases = (omega * post_transient_times) % (2 * np.pi)\n\n            # Quantify phase locking by computing the Rayleigh resultant\n            # R = (1/N) * |sum(exp(i * phi_k))|\n            # This is equivalent to the absolute value of the mean of the complex phasors.\n            R = np.abs(np.mean(np.exp(1j * phases)))\n        \n        results.append(R)\n\n    # Final print statement in the exact required format.\n    # The output string should be like \"[0.123456,0.234567,...]\"\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}