{
    "hands_on_practices": [
        {
            "introduction": "掌握一个数值方法的最好途径莫过于亲手计算一遍。本练习将引导你对一个具有物理背景的常微分方程，细致地执行一次经典的四阶龙格-库塔（RK4）方法的完整步骤。通过这个过程，你将加深对RK4方法中四个阶段（$k_1, k_2, k_3, k_4$）如何协同工作以获得高精度近似的理解。",
            "id": "2174156",
            "problem": "一个小探测器进入行星大气层时，其温度 $T$（单位为摄氏度）由一个简化的微分方程建模。其温度随时间 $t$（单位为秒）的变化率受到大气摩擦加热和辐射冷却的共同影响。其控制方程如下：\n$$ \\frac{dT}{dt} = \\alpha t^{2} - \\beta T $$\n其中 $\\alpha = 0.50 \\text{ C/s}^3$ 是与摩擦加热相关的系数，$\\beta = 0.20 \\text{ s}^{-1}$ 是一个冷却常数。\n在进入时刻 $t_0 = 0 \\text{ s}$，探测器的初始温度为 $T_0 = 100.0 \\text{ C}$。\n\n使用步长为 $h = 0.4 \\text{ s}$ 的四阶龙格－库塔 (RK4) 方法进行单步计算，估计在时间 $t_1 = 0.4 \\text{ s}$ 时探测器的温度。将您的答案以摄氏度表示，并四舍五入到四位有效数字。",
            "solution": "我们给定的初值问题是 $T^{\\prime}(t)=f(t,T)=\\alpha t^{2}-\\beta T$，其中 $\\alpha=0.50$，$\\beta=0.20$，$t_{0}=0$，$T_{0}=100.0$，步长 $h=0.4$。单步四阶龙格－库塔法的计算公式为\n$$\nT_{1}=T_{0}+\\frac{h}{6}\\left(k_{1}+2k_{2}+2k_{3}+k_{4}\\right),\n$$\n其中\n$$\nk_{1}=f(t_{0},T_{0}),\\quad\nk_{2}=f\\!\\left(t_{0}+\\frac{h}{2},\\,T_{0}+\\frac{h}{2}k_{1}\\right),\\quad\nk_{3}=f\\!\\left(t_{0}+\\frac{h}{2},\\,T_{0}+\\frac{h}{2}k_{2}\\right),\\quad\nk_{4}=f(t_{0}+h,\\,T_{0}+hk_{3}).\n$$\n\n计算每个阶段：\n$$\nk_{1}=\\alpha t_{0}^{2}-\\beta T_{0}=0.50\\cdot 0^{2}-0.20\\cdot 100.0=-20.\n$$\n$$\nt_{0}+\\frac{h}{2}=0.2,\\quad T_{0}+\\frac{h}{2}k_{1}=100.0+0.2(-20)=96.0,\n$$\n$$\nk_{2}=f(0.2,96.0)=0.50\\cdot(0.2)^{2}-0.20\\cdot 96.0=0.02-19.2=-19.18.\n$$\n$$\nt_{0}+\\frac{h}{2}=0.2,\\quad T_{0}+\\frac{h}{2}k_{2}=100.0+0.2(-19.18)=96.164,\n$$\n$$\nk_{3}=f(0.2,96.164)=0.50\\cdot(0.2)^{2}-0.20\\cdot 96.164=0.02-19.2328=-19.2128.\n$$\n$$\nt_{0}+h=0.4,\\quad T_{0}+hk_{3}=100.0+0.4(-19.2128)=92.31488,\n$$\n$$\nk_{4}=f(0.4,92.31488)=0.50\\cdot(0.4)^{2}-0.20\\cdot 92.31488=0.08-18.462976=-18.382976.\n$$\n\n合并更新：\n$$\nT_{1}=100.0+\\frac{0.4}{6}\\left((-20)+2(-19.18)+2(-19.2128)+(-18.382976)\\right).\n$$\n计算括号内的加权和：\n$$\nk_{1}+2k_{2}+2k_{3}+k_{4}=-20-38.36-38.4256-18.382976=-115.168576.\n$$\n因此，\n$$\nT_{1}=100.0+\\frac{0.4}{6}\\left(-115.168576\\right)=100.0-\\frac{115.168576}{15}=92.322094933\\ldots\n$$\n四舍五入到四位有效数字，估计值为 $92.32$。",
            "answer": "$$\\boxed{92.32}$$"
        },
        {
            "introduction": "物理世界中的许多问题都以耦合微分方程组的形式出现，并且往往伴随着能量、动量等守恒量。这个练习将经典的RK4方法从标量方程推广到方程组，并以简谐振子为例，探讨数值解在多大程度上能够保持物理系统的总能量守恒。这揭示了数值方法的一个重要特性：即使是高精度方法，也可能无法完美维持理论上的守恒律。",
            "id": "2158985",
            "problem": "一个粒子的一维运动由一个简化的无量纲模型描述，该模型由以下一阶常微分方程组表示：\n$$\n\\frac{dx}{dt} = v\n$$\n$$\n\\frac{dv}{dt} = -x\n$$\n其中 $x$ 是粒子的位置，$v$ 是其速度。系统的总能量由表达式 $E = \\frac{1}{2}(x^2 + v^2)$ 定义。\n\n在时间 $t=0$ 时，系统具有初始条件 $x(0) = 0$ 和 $v(0) = 1$。\n\n使用步长 $h = 0.2$，通过执行单步经典四阶龙格-库塔 (RK4) 方法，近似计算系统在时间 $t=0.2$ 时的状态 $(x(t), v(t))$。\n\n使用 $x(0.2)$ 和 $v(0.2)$ 的近似值，计算这一步之后总能量的相对误差。相对误差定义为 $\\frac{|E_1 - E_0|}{E_0}$，其中 $E_0$ 是 $t=0$ 时的初始能量，$E_1$ 是根据在 $t=0.2$ 时的数值近似计算出的能量。\n\n将最终答案四舍五入到四位有效数字。",
            "solution": "我们有自治系统 $x' = v$, $v' = -x$，初始值为 $x(0) = 0$, $v(0) = 1$，步长为 $h = 0.2$。对于系统 $y' = f(y)$，其中 $y = \\begin{pmatrix} x \\\\ v \\end{pmatrix}$ 且 $f(y) = \\begin{pmatrix} v \\\\ -x \\end{pmatrix}$，经典的 RK4 方法计算如下\n$$\nk_{1} = f(y_{0}),\\quad\nk_{2} = f\\left(y_{0} + \\frac{h}{2}k_{1}\\right),\\quad\nk_{3} = f\\left(y_{0} + \\frac{h}{2}k_{2}\\right),\\quad\nk_{4} = f\\left(y_{0} + h\\,k_{3}\\right),\n$$\n并更新 $y_{1} = y_{0} + \\frac{h}{6}\\left(k_{1} + 2k_{2} + 2k_{3} + k_{4}\\right)$。\n\n当 $y_{0} = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix}$ 时：\n- $k_{1} = f\\left(\\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix}\\right) = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}$。\n- $y_{0} + \\frac{h}{2}k_{1} = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} + 0.1\\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 0.1 \\\\ 1 \\end{pmatrix}$，因此 $k_{2} = f\\left(\\begin{pmatrix} 0.1 \\\\ 1 \\end{pmatrix}\\right) = \\begin{pmatrix} 1 \\\\ -0.1 \\end{pmatrix}$。\n- $y_{0} + \\frac{h}{2}k_{2} = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} + 0.1\\begin{pmatrix} 1 \\\\ -0.1 \\end{pmatrix} = \\begin{pmatrix} 0.1 \\\\ 0.99 \\end{pmatrix}$，因此 $k_{3} = f\\left(\\begin{pmatrix} 0.1 \\\\ 0.99 \\end{pmatrix}\\right) = \\begin{pmatrix} 0.99 \\\\ -0.1 \\end{pmatrix}$。\n- $y_{0} + h\\,k_{3} = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} + 0.2\\begin{pmatrix} 0.99 \\\\ -0.1 \\end{pmatrix} = \\begin{pmatrix} 0.198 \\\\ 0.98 \\end{pmatrix}$，因此 $k_{4} = f\\left(\\begin{pmatrix} 0.198 \\\\ 0.98 \\end{pmatrix}\\right) = \\begin{pmatrix} 0.98 \\\\ -0.198 \\end{pmatrix}$。\n\n结合起来得到\n$$\nx(0.2) \\approx x_{1} = 0 + \\frac{0.2}{6}\\left(1 + 2\\cdot 1 + 2\\cdot 0.99 + 0.98\\right) = \\frac{1}{30}\\cdot 5.96 = \\frac{149}{750},\n$$\n$$\nv(0.2) \\approx v_{1} = 1 + \\frac{0.2}{6}\\left(0 + 2\\cdot(-0.1) + 2\\cdot(-0.1) + (-0.198)\\right) = 1 + \\frac{1}{30}\\cdot(-0.598) = \\frac{14701}{15000}.\n$$\n\n能量为 $E = \\frac{1}{2}(x^{2} + v^{2})$。初始时，\n$$\nE_{0} = \\frac{1}{2}(0^{2} + 1^{2}) = \\frac{1}{2}.\n$$\n经过一步 RK4 后，\n$$\nx_{1}^{2} = \\frac{22201}{562500} = \\frac{8880400}{225000000},\\quad v_{1}^{2} = \\frac{216119401}{225000000},\n$$\n所以\n$$\nE_{1} = \\frac{1}{2}\\left(x_{1}^{2} + v_{1}^{2}\\right) = \\frac{1}{2}\\cdot\\frac{224999801}{225000000} = \\frac{224999801}{450000000}.\n$$\n因此，\n$$\n|E_{1} - E_{0}| = \\left|\\frac{224999801}{450000000} - \\frac{1}{2}\\right| = \\frac{199}{450000000},\n$$\n相对误差为\n$$\n\\frac{|E_{1} - E_{0}|}{E_{0}} = \\frac{\\frac{199}{450000000}}{\\frac{1}{2}} = \\frac{199}{225000000} \\approx 8.844444\\ldots \\times 10^{-7}.\n$$\n四舍五入到四位有效数字得到 $8.844 \\times 10^{-7}$。",
            "answer": "$$\\boxed{8.844 \\times 10^{-7}}$$"
        },
        {
            "introduction": "龙格-库塔方法是为求解初值问题（IVP）而设计的，但它的威力远不止于此。本练习将展示如何将RK4方法作为一个核心部件，嵌入到更高级的“打靶法”算法中，以解决在工程和物理学中同样重要的边值问题（BVP）。通过求解流体力学中的经典Blasius方程，你将体会到组合不同数值技术以攻克复杂问题的强大威力。",
            "id": "2395918",
            "problem": "你需要实现一个求解器，用于解决经典的 Blasius 边界层问题。解决方法是将其简化为一个初值问题，并应用打靶法与经典的四阶龙格-库塔方法相结合。Blasius 函数满足以下三阶非线性常微分方程：\n$$\nf'''(\\eta) + \\tfrac{1}{2} f(\\eta) f''(\\eta) = 0,\n$$\n其边界条件为：\n$$\nf(0) = 0,\\quad f'(0) = 0,\\quad f'(\\infty) = 1.\n$$\n通过将计算域截断至一个有限的终点 $$\\eta_{\\max} > 0$$ 来处理无穷远处的条件。引入变量 $$y_1(\\eta) = f(\\eta),\\ y_2(\\eta) = f'(\\eta),\\ y_3(\\eta) = f''(\\eta)$$，将三阶方程转换为一个一阶系统，使系统呈现以下形式：\n$$\n\\frac{d}{d\\eta}\n\\begin{bmatrix}\ny_1 \\\\\ny_2 \\\\\ny_3\n\\end{bmatrix}\n=\n\\begin{bmatrix}\ny_2 \\\\\ny_3 \\\\\n-\\tfrac{1}{2} y_1 y_3\n\\end{bmatrix},\n$$\n初始条件为：\n$$\ny_1(0) = 0,\\quad y_2(0) = 0,\\quad y_3(0) = s,\n$$\n其中 $$s = f''(0)$$ 是一个未知的打靶参数。对于给定的 $$s$$，使用经典的四阶龙格-库塔方法，以均匀步长 $$h > 0$$，将系统从 $$\\eta = 0$$ 积分到 $$\\eta = \\eta_{\\max}$$。定义残差函数\n$$\nR(s) \\equiv y_2(\\eta_{\\max}; s) - 1,\n$$\n并通过使用基于打靶法的一维求根迭代（例如，区间割线法或试位法迭代）来确定 $$s$$，使得对于给定的容差 $$\\varepsilon > 0$$，满足 $$|R(s)| \\le \\varepsilon$$。所有计算均为无量纲；不需要物理单位。\n\n测试套件和要求的输出：\n- 对于下面的每一组参数 $$(\\eta_{\\max}, h, \\varepsilon, s_a, s_b)$$，找到使 $$|R(s)| \\le \\varepsilon$$ 成立的 $$s$$ 值，其中 $$s_a$$ 和 $$s_b$$ 是用于启动求根器的两个不同初始猜测值。使用均匀步长，以使终点恰好与 $$\\eta_{\\max}$$ 重合。\n- 使用的参数组：\n    1. $$(\\eta_{\\max}, h, \\varepsilon, s_a, s_b) = (8.0, 0.01, 10^{-8}, 0.30, 0.35)$$\n    2. $$(\\eta_{\\max}, h, \\varepsilon, s_a, s_b) = (6.0, 0.02, 10^{-6}, 0.20, 0.50)$$\n    3. $$(\\eta_{\\max}, h, \\varepsilon, s_a, s_b) = (10.0, 0.005, 10^{-10}, 0.32, 0.34)$$\n    4. $$(\\eta_{\\max}, h, \\varepsilon, s_a, s_b) = (12.0, 0.02, 10^{-8}, 0.10, 0.60)$$\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含四个参数组计算出的 $$s$$ 值，顺序与上面列出的一致，四舍五入到恰好九位小数，并以逗号分隔的列表形式包含在方括号内；例如，$$[0.332000000,0.332000000,0.332000000,0.332000000]$$。",
            "solution": "所提出的问题是流体动力学领域的一个经典边值问题，具体涉及平板上的层流边界层。其控制方程 Blasius 方程是一个三阶非线性常微分方程。我们的任务是找到未知初始条件 $$s = f''(0)$$ 的值，使得在无穷远处的边界条件（近似为 $$f'(\\eta_{\\max})=1$$）得到满足。这是打靶法的一个典型应用。\n\n问题陈述已经过验证，并且被认为是科学上可靠、适定且完整的。所有必要的参数和方法都已指定，从而可以得到唯一且可验证的解。我们将继续系统地推导数值算法。\n\n首先，将三阶常微分方程\n$$\nf'''(\\eta) + \\tfrac{1}{2} f(\\eta) f''(\\eta) = 0,\n$$\n转换为一个包含三个一阶常微分方程的系统。通过定义状态向量 $$\\mathbf{y}(\\eta) = [y_1(\\eta), y_2(\\eta), y_3(\\eta)]^T$$，其中 $$y_1 = f$$，$$y_2 = f' = y_1'$$，以及 $$y_3 = f'' = y_2'$$，可以很容易地看出该系统为：\n$$\n\\frac{d\\mathbf{y}}{d\\eta} =\n\\begin{bmatrix}\ny_2 \\\\\ny_3 \\\\\n-\\tfrac{1}{2} y_1 y_3\n\\end{bmatrix}\n= \\mathbf{F}(\\mathbf{y}).\n$$\n请注意，该系统是自治的，因为右侧的 $$\\mathbf{F}$$ 不显式依赖于自变量 $$\\eta$$。\n\n原始的边界条件是 $$f(0)=0$$，$$f'(0)=0$$ 和 $$f'(\\infty)=1$$。用我们的状态向量表示，这些条件变为 $$y_1(0)=0$$，$$y_2(0)=0$$ 和 $$y_2(\\infty)=1$$。通过引入未知的打靶参数 $$s = f''(0) = y_3(0)$$，该问题被转化为一个初值问题 (IVP)。现在，IVP 在 $$\\eta=0$$ 处的初始条件已完全指定：\n$$\n\\mathbf{y}(0) = [0, 0, s]^T.\n$$\n打靶法的目标是确定 $$s$$ 的值，使得该 IVP 的解在积分到指定的有限边界 $$\\eta_{\\max}$$ 时，满足终端条件 $$y_2(\\eta_{\\max}) = 1$$。为此，我们定义一个残差函数 $$R(s)$$，并寻求其根：\n$$\nR(s) = y_2(\\eta_{\\max}; s) - 1 = 0.\n$$\n在这里，记号 $$y_2(\\eta_{\\max}; s)$$ 明确表示解依赖于参数 $$s$$ 的选择。\n\n为了求解任意给定猜测值 $$s$$ 的初值问题，我们必须使用一个数值积分器。问题要求使用经典的四阶龙格-库塔 (RK4) 方法。对于一个通用的一阶常微分方程系统 $$\\mathbf{y}' = \\mathbf{F}(\\eta, \\mathbf{y})$$，RK4 算法使用以下步骤将解从 $$\\eta_n$$推进到 $$\\eta_{n+1} = \\eta_n + h$$：\n$$\n\\begin{aligned}\n\\mathbf{k}_1 = h \\mathbf{F}(\\eta_n, \\mathbf{y}_n) \\\\\n\\mathbf{k}_2 = h \\mathbf{F}(\\eta_n + \\tfrac{h}{2}, \\mathbf{y}_n + \\tfrac{\\mathbf{k}_1}{2}) \\\\\n\\mathbf{k}_3 = h \\mathbf{F}(\\eta_n + \\tfrac{h}{2}, \\mathbf{y}_n + \\tfrac{\\mathbf{k}_2}{2}) \\\\\n\\mathbf{k}_4 = h \\mathbf{F}(\\eta_n + h, \\mathbf{y}_n + \\mathbf{k}_3) \\\\\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\tfrac{1}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n\\end{aligned}\n$$\n这个过程重复进行 $$N = \\eta_{\\max} / h$$ 次，以将解从 $$\\eta=0$$ 积分到 $$\\eta=\\eta_{\\max}$$。\n\n为了找到 $$R(s)=0$$ 的根，需要一个一维求根算法。问题建议使用一种区间方法，如试位法 (regula falsi)，从两个初始猜测值 $$s_a$$ 和 $$s_b$$ 开始，并假定这两个值将根置于区间内，即 $$R(s_a) R(s_b)  0$$。试位法通过在点 $$(s_a, R(s_a))$$ 和 $$(s_b, R(s_b))$$ 之间构造一条割线，并找到其与 s 轴的交点，来迭代地精化根的估计值。根的下一个近似值 $$s_{next}$$ 由下式给出：\n$$\ns_{next} = s_b - R(s_b) \\frac{s_b - s_a}{R(s_b) - R(s_a)} = \\frac{s_a R(s_b) - s_b R(s_a)}{R(s_b) - R(s_a)}.\n$$\n然后，通过用 $$s_{next}$$ 替换 $$s_a$$ 或 $$s_b$$ 来更新区间，确保新的区间 $$[s_a, s_b]$$ 继续将根包含在内。这个迭代过程持续进行，直到新估计值的残差绝对值小于或等于指定的容差 $$\\varepsilon$$，即 $$|R(s_{next})| \\le \\varepsilon$$。\n\n完整的数值计算步骤如下：\n1.  使用提供的区间猜测值 $$s_a$$ 和 $$s_b$$ 初始化试位法算法。\n2.  在算法的每次迭代中，使用试位法公式计算下一个猜测值 $$s_{next}$$。\n3.  对于这个 $$s_{next}$$，使用 RK4 方法，以初始条件 $$\\mathbf{y}(0) = [0, 0, s_{next}]^T$$，将初值问题从 $$\\eta=0$$ 求解到 $$\\eta=\\eta_{\\max}$$。\n4.  评估残差 $$R(s_{next}) = y_2(\\eta_{\\max}) - 1$$。\n5.  如果 $$|R(s_{next})| \\le \\varepsilon$$，则过程终止，$$s_{next}$$ 即为所求的解。\n6.  否则，更新区间 $$[s_a, s_b]$$ 并进入下一次迭代。\n\n我们将实现这种稳健的方法组合，为每个指定的参数组求解 $$s$$ 的值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Blasius boundary layer problem for multiple parameter sets\n    using a shooting method with RK4 and a regula falsi root-finder.\n    \"\"\"\n\n    test_cases = [\n        (8.0, 0.01, 1e-8, 0.30, 0.35),\n        (6.0, 0.02, 1e-6, 0.20, 0.50),\n        (10.0, 0.005, 1e-10, 0.32, 0.34),\n        (12.0, 0.02, 1e-8, 0.10, 0.60),\n    ]\n\n    results = []\n    for params in test_cases:\n        s_final = find_blasius_s(*params)\n        results.append(s_final)\n    \n    formatted_results = [f\"{r:.9f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef find_blasius_s(eta_max, h, epsilon, s_a, s_b, max_iter=100):\n    \"\"\"\n    Finds the shooting parameter s = f''(0) for the Blasius equation.\n\n    Args:\n        eta_max (float): The finite value to approximate infinity.\n        h (float): The step size for the RK4 method.\n        epsilon (float): The tolerance for the residual |R(s)|.\n        s_a (float): The first initial guess for s (part of the bracket).\n        s_b (float): The second initial guess for s (part of the bracket).\n        max_iter (int): Maximum number of iterations for the root-finder.\n\n    Returns:\n        float: The value of s that satisfies the boundary condition within the tolerance.\n    \"\"\"\n\n    def blasius_ode(y_vec):\n        \"\"\"\n        Defines the right-hand side of the Blasius system of ODEs.\n        y_vec = [y1, y2, y3] = [f, f', f'']\n        Returns dy/d(eta) = [y2, y3, -0.5*y1*y3]\n        \"\"\"\n        return np.array([y_vec[1], y_vec[2], -0.5 * y_vec[0] * y_vec[2]], dtype=np.float64)\n\n    def evaluate_residual(s_guess):\n        \"\"\"\n        Solves the IVP for a given s_guess using RK4 and returns the residual R(s).\n        \"\"\"\n        y = np.array([0.0, 0.0, s_guess], dtype=np.float64)\n        num_steps = int(round(eta_max / h))\n\n        for _ in range(num_steps):\n            k1 = h * blasius_ode(y)\n            k2 = h * blasius_ode(y + 0.5 * k1)\n            k3 = h * blasius_ode(y + 0.5 * k2)\n            k4 = h * blasius_ode(y + k3)\n            y += (k1 + 2.0 * k2 + 2.0 * k3 + k4) / 6.0\n        \n        # Residual is R(s) = y2(eta_max; s) - 1\n        return y[1] - 1.0\n\n    r_a = evaluate_residual(s_a)\n    r_b = evaluate_residual(s_b)\n\n    if np.sign(r_a) == np.sign(r_b):\n        # This case should not occur with the provided problem inputs.\n        raise ValueError(\"Initial guesses s_a and s_b do not bracket the root.\")\n    \n    s_next = s_a\n    for _ in range(max_iter):\n        s_next = (s_a * r_b - s_b * r_a) / (r_b - r_a)\n        r_next = evaluate_residual(s_next)\n\n        if abs(r_next) = epsilon:\n            return s_next\n\n        if np.sign(r_next) == np.sign(r_a):\n            s_a = s_next\n            r_a = r_next\n        else: # np.sign(r_next) == np.sign(r_b)\n            s_b = s_next\n            r_b = r_next\n    \n    # Return the last computed value if max_iter is reached\n    return s_next\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}