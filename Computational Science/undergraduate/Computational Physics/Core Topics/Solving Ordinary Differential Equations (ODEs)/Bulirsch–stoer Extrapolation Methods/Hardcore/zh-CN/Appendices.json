{
    "hands_on_practices": [
        {
            "introduction": "在将 Bulirsch-Stoer 方法应用于复杂的微分方程之前，掌握其核心原理——理查森外推法 (Richardson extrapolation)——至关重要。本练习  提供了一个独特的机会，将这个概念应用于一个我们熟悉的场景：几何级数的收敛。通过将部分和中的项数视为一个类似于步长的参数，我们可以练习使用外推技术来加速收敛，从而对该方法的工作原理获得更深刻、更直观的理解。",
            "id": "2378481",
            "problem": "设 $x$ 是一个满足 $|x|  1$ 的实参数。定义几何级数和 $S(x)$ 及其第 $N$ 项部分和 $S_{N}(x)$ 如下\n$$\nS(x) = \\sum_{k=0}^{\\infty} x^{k}, \\qquad S_{N}(x) = \\sum_{k=0}^{N} x^{k}.\n$$\n考虑定义在离散集 $\\{h = 1/N : N \\in \\mathbb{N}\\}$ 上的映射 $h \\mapsto S(h)$，其定义为 $S(h) := S_{1/h}(x) = S_{N}(x)$，并将 $h$ 视为一个步长参数。本着Bulirsch–Stoer外推法的精神，构建唯一的二次多项式 $P_{2}(h)$，该多项式对以下三个数据点进行插值：$\\big(h_{1},S(h_{1})\\big)$、$\\big(h_{2},S(h_{2})\\big)$ 和 $\\big(h_{3},S(h_{3})\\big)$，其位置在\n$$\nh_{1}=\\frac{1}{N}, \\qquad h_{2}=\\frac{1}{2N}, \\qquad h_{3}=\\frac{1}{3N},\n$$\n其中 $N \\in \\mathbb{N}$ 是一个固定的值。确定 $P_{2}(0)$ 的一个仅用 $x$ 和 $N$ 表示的完全简化的闭式解析表达式。\n\n答案规格：\n- 以单个闭式解析表达式的形式提供您的最终答案。\n- 不需要四舍五入，也不涉及单位。",
            "solution": "必须首先验证问题陈述的科学性和逻辑完整性。\n\n步骤1：提取给定条件\n- 一个实参数 $x$，约束条件为 $|x|  1$。\n- 几何级数和定义为 $S(x) = \\sum_{k=0}^{\\infty} x^{k}$。\n- 第 $N$ 项部分和定义为 $S_{N}(x) = \\sum_{k=0}^{N} x^{k}$。\n- 函数 $S(h)$ 定义在离散点集 $h = 1/M$（$M \\in \\mathbb{N}$）上，关系式为 $S(h) := S_{1/h}(x)$。\n- 一个唯一的二次多项式，记为 $P_{2}(h)$，对三个特定点进行插值：\n  - $(h_{1}, S(h_{1}))$，其中 $h_{1} = \\frac{1}{N}$\n  - $(h_{2}, S(h_{2}))$，其中 $h_{2} = \\frac{1}{2N}$\n  - $(h_{3}, S(h_{3}))$，其中 $h_{3} = \\frac{1}{3N}$\n- 整数 $N$ 是一个固定的自然数，$N \\in \\mathbb{N}$。\n- 目标是确定该多项式在 $h=0$ 处的值，即 $P_{2}(0)$，并表示为仅含 $x$ 和 $N$ 的简化闭式解析表达式。\n\n步骤2：使用提取的给定条件进行验证\n- **科学依据：** 该问题是在分析和数值方法的标准数学框架内提出的。几何级数、部分和以及多项式插值都是基本概念。将一系列近似值外推到其极限的想法是Bulirsch–Stoer方法的核心，也是计算科学中一个成熟的技术。条件 $|x|  1$ 正确地确保了几何级数的收敛性。该问题在科学上是合理的。\n- **适定性：** 三个不同的点可以确定一个唯一的二次多项式。对于任何 $N \\in \\mathbb{N}$，$h_{1} = 1/N$、$h_{2} = 1/(2N)$ 和 $h_{3} = 1/(3N)$ 的值都是不同的。因此，存在一个唯一的插值多项式 $P_2(h)$。任务是找到它在特定点 $h=0$ 处的值，这是一个唯一定义的量。该问题是适定的。\n- **目标：** 问题陈述是精确的、定量的，并且没有主观或含糊不清的语言。\n\n步骤3：结论与行动\n该问题是有效的。这是一个关于多项式插值和外推的定义明确的数学练习。我将继续进行求解。\n\n任务是找到 $P_{2}(0)$ 的值，其中 $P_{2}(h)$ 是通过三个点 $(h_1, A_1)$、$(h_2, A_2)$ 和 $(h_3, A_3)$ 的唯一二次多项式，这里的 $h_k$ 是给定的步长，$A_k = S(h_k)$ 是对应的部分和的值。\n设 $h_1 = \\frac{1}{N}$，$h_2 = \\frac{1}{2N}$，$h_3 = \\frac{1}{3N}$。\n对应的函数值为：\n$A_1 = S(h_1) = S_N(x) = \\sum_{k=0}^{N} x^k$\n$A_2 = S(h_2) = S_{2N}(x) = \\sum_{k=0}^{2N} x^k$\n$A_3 = S(h_3) = S_{3N}(x) = \\sum_{k=0}^{3N} x^k$\n\n我们寻求在 $h=0$ 处计算插值多项式的值。这是一种外推，因为 $h=0$ 位于插值点定义的区间之外。一个直接的方法是使用 $P_2(h)$ 的拉格朗日插值公式，然后令 $h=0$。\n拉格朗日形式的插值多项式为：\n$$\nP_2(h) = A_1 \\frac{(h-h_2)(h-h_3)}{(h_1-h_2)(h_1-h_3)} + A_2 \\frac{(h-h_1)(h-h_3)}{(h_2-h_1)(h_2-h_3)} + A_3 \\frac{(h-h_1)(h-h_2)}{(h_3-h_1)(h_3-h_2)}\n$$\n在 $h=0$ 处求值，我们得到：\n$$\nP_2(0) = A_1 \\frac{h_2 h_3}{(h_1-h_2)(h_1-h_3)} + A_2 \\frac{h_1 h_3}{(h_2-h_1)(h_2-h_3)} + A_3 \\frac{h_1 h_2}{(h_3-h_1)(h_3-h_2)}\n$$\n这将 $P_2(0)$ 表示为 $A_1$、$A_2$ 和 $A_3$ 的线性组合。我们必须计算这些系数。为简单起见，设 $h_0 = 1/N$。那么 $h_1=h_0$，$h_2=h_0/2$，$h_3=h_0/3$。\n\n$A_1$ 的系数：\n$$\nc_1 = \\frac{(\\frac{h_0}{2})(\\frac{h_0}{3})}{(h_0-\\frac{h_0}{2})(h_0-\\frac{h_0}{3})} = \\frac{\\frac{1}{6}h_0^2}{(\\frac{1}{2}h_0)(\\frac{2}{3}h_0)} = \\frac{\\frac{1}{6}h_0^2}{\\frac{1}{3}h_0^2} = \\frac{1}{2}\n$$\n$A_2$ 的系数：\n$$\nc_2 = \\frac{(h_0)(\\frac{h_0}{3})}{(\\frac{h_0}{2}-h_0)(\\frac{h_0}{2}-\\frac{h_0}{3})} = \\frac{\\frac{1}{3}h_0^2}{(-\\frac{1}{2}h_0)(\\frac{1}{6}h_0)} = \\frac{\\frac{1}{3}h_0^2}{-\\frac{1}{12}h_0^2} = -4\n$$\n$A_3$ 的系数：\n$$\nc_3 = \\frac{(h_0)(\\frac{h_0}{2})}{(\\frac{h_0}{3}-h_0)(\\frac{h_0}{3}-\\frac{h_0}{2})} = \\frac{\\frac{1}{2}h_0^2}{(-\\frac{2}{3}h_0)(-\\frac{1}{6}h_0)} = \\frac{\\frac{1}{2}h_0^2}{\\frac{1}{9}h_0^2} = \\frac{9}{2}\n$$\n因此，外推值为：\n$$\nP_2(0) = \\frac{1}{2}A_1 - 4A_2 + \\frac{9}{2}A_3\n$$\n系数之和为 $c_1+c_2+c_3 = \\frac{1}{2}-4+\\frac{9}{2} = 5-4=1$ 的条件得到满足，这对于一个外推公式是符合预期的。\n\n接下来，我们代入 $A_k = S_{kN}(x)$ 的表达式。有限几何级数的和由 $S_M(x) = \\frac{1-x^{M+1}}{1-x}$ 给出。\n各项为：\n$A_1 = S_N(x) = \\frac{1-x^{N+1}}{1-x}$\n$A_2 = S_{2N}(x) = \\frac{1-x^{2N+1}}{1-x}$\n$A_3 = S_{3N}(x) = \\frac{1-x^{3N+1}}{1-x}$\n\n将这些代入 $P_2(0)$ 的表达式中：\n$$\nP_2(0) = \\frac{1}{2}\\left(\\frac{1-x^{N+1}}{1-x}\\right) - 4\\left(\\frac{1-x^{2N+1}}{1-x}\\right) + \\frac{9}{2}\\left(\\frac{1-x^{3N+1}}{1-x}\\right)\n$$\n我们可以提出公分母 $\\frac{1}{1-x}$：\n$$\nP_2(0) = \\frac{1}{1-x} \\left[ \\frac{1}{2}(1-x^{N+1}) - 4(1-x^{2N+1}) + \\frac{9}{2}(1-x^{3N+1}) \\right]\n$$\n现在，我们简化方括号内的表达式。首先，合并常数项：\n$$\n\\frac{1}{2} - 4 + \\frac{9}{2} = \\frac{10}{2} - 4 = 5 - 4 = 1\n$$\n接下来，合并包含 $x$ 的幂的项：\n$$\n-\\frac{1}{2}x^{N+1} + 4x^{2N+1} - \\frac{9}{2}x^{3N+1}\n$$\n综合这些结果，方括号内的表达式变为：\n$$\n1 - \\frac{1}{2}x^{N+1} + 4x^{2N+1} - \\frac{9}{2}x^{3N+1}\n$$\n因此，$P_2(0)$ 的最终闭式表达式为：\n$$\nP_2(0) = \\frac{1 - \\frac{1}{2}x^{N+1} + 4x^{2N+1} - \\frac{9}{2}x^{3N+1}}{1-x}\n$$\n该表达式仅是 $x$ 和 $N$ 的函数，并且是其最简解析形式。\n作为检验，在极限 $N \\to \\infty$ 时，由于 $|x|1$，我们有 $x^{N+1} \\to 0$，$x^{2N+1} \\to 0$ 和 $x^{3N+1} \\to 0$。$P_2(0)$ 的表达式趋近于 $\\frac{1}{1-x}$，这正是级数 $S(x)$ 的真实和。对于一个有效的外推方案，这是正确的行为。",
            "answer": "$$\n\\boxed{\\frac{1 - \\frac{1}{2}x^{N+1} + 4x^{2N+1} - \\frac{9}{2}x^{3N+1}}{1-x}}\n$$"
        },
        {
            "introduction": "像 Bulirsch-Stoer 这样的高阶方法的强大威力，依赖于对所求解问题的平滑性所做出的某些假设。本实践问题  探讨了一个关键的边界情况，其中这些假设不再成立。通过看似简单的常微分方程 $y' = \\sqrt{y}$，我们将研究其在 $y=0$ 附近的数值行为，此处解的唯一性无法保证，这有助于我们理解确定性求解器的局限性，以及 Lipschitz 条件对于确保其可靠性的重要性。",
            "id": "2378472",
            "problem": "考虑一个常微分方程（ODE）的初值问题，该问题由 $y^{\\prime}(t) = \\sqrt{y(t)}$（$t \\ge 0$）和初始条件 $y(0)=0$ 给出。设光滑正分支定义为函数族 $y(t) = \\left(\\dfrac{t + C}{2}\\right)^{2}$，其中常数 $C \\in \\mathbb{R}$ 的选择是为了满足给定的初始条件。对于在 $t=t_{0}$ 处的一般初始条件 $y(t_{0})=y_{0} \\ge 0$，选择 $C = 2\\sqrt{y_{0}} - t_{0}$，使得该分支对于所有 $t \\ge t_{0}$ 均为 $y(t) = \\left(\\dfrac{t + 2\\sqrt{y_{0}} - t_{0}}{2}\\right)^{2}$。请设计一个高精度时间积分程序，使用您选择的确定性方法，将绝对误差控制在指定容差内，来近似下文所述测试套件的终端值 $y(T)$。对于每个测试用例，您的程序还必须计算计算出的 $y(T)$ 与在 $T$ 处评估的光滑正分支值之间的绝对偏差，其中常数 $C$ 由相应的初始条件确定。此问题不涉及物理单位。\n\n测试套件：\n- 情况 A（锁定在平衡点）：$t_{0}=0$，$y_{0}=0$，$T=1$，绝对容差 $10^{-12}$。\n- 情况 B（极小的正初始值）：$t_{0}=0$，$y_{0}=10^{-12}$，$T=1$，绝对容差 $10^{-12}$。\n- 情况 C（远离非李普希茨点）：$t_{0}=10^{-6}$，$y_{0}=\\dfrac{(10^{-6})^{2}}{4}$，$T=1$，绝对容差 $10^{-12}$。\n- 情况 D（平衡点处的短时目标）：$t_{0}=0$，$y_{0}=0$，$T=10^{-3}$，绝对容差 $10^{-12}$。\n\n对于每种情况，您的程序必须返回两个实数：计算出的 $y(T)$ 和与在 $T$ 处的光滑正分支值的绝对偏差。最终输出必须是包含这八个数字的单行逗号分隔的扁平列表，按 A、B、C、D 的顺序排列，每个数字都以浮点数形式报告。具体来说，您的程序应产生一行输出，包含\n$[y_{A}(T),\\ \\lvert y_{A}(T)-y^{\\mathrm{branch}}_{A}(T)\\rvert,\\ y_{B}(T),\\ \\lvert y_{B}(T)-y^{\\mathrm{branch}}_{B}(T)\\rvert,\\ y_{C}(T),\\ \\lvert y_{C}(T)-y^{\\mathrm{branch}}_{C}(T)\\rvert,\\ y_{D}(T),\\ \\lvert y_{D}(T)-y^{\\mathrm{branch}}_{D}(T)\\rvert]$，\n其中对于每种情况对应的 $(t_{0},y_{0},T)$，有 $y^{\\mathrm{branch}}(T) = \\left(\\dfrac{T + 2\\sqrt{y_{0}} - t_{0}}{2}\\right)^{2}$。角度单位不适用。百分比不适用；所有量均为实数。",
            "solution": "问题陈述是有效的。它提出了一个关于常微分方程（ODE）解的明确定义的数值实验。\n\n这个问题的核心在于数值积分器在面对违反李普希茨条件的ODE时的行为。给定的ODE是 $y^{\\prime}(t) = \\sqrt{y(t)}$。其右侧函数 $f(t, y) = \\sqrt{y}$ 在 $y=0$ 处关于 $y$ 不是李普希茨连续的。这是因为其偏导数 $\\frac{\\partial f}{\\partial y} = \\frac{1}{2\\sqrt{y}}$ 在 $y \\to 0^{+}$ 时是无界的。保证初值问题（IVP）解存在且唯一的 Picard–Lindelöf 定理要求函数是李普希茨连续的。对于给定的ODE，在 $y=0$ 处不满足此条件，允许多个解的存在。\n\n对于初始条件为 $y(0)=0$ 的初值问题，对于 $t \\ge 0$ 至少存在两个不同的解：\n1. 平凡解，$y_{1}(t) = 0$。\n2. “光滑正分支”解，对于这个特定的初始条件，它对应于 $y_{2}(t) = (t/2)^{2}$。\n\n一个确定性数值方法，就其本质而言，是将下一个状态计算为当前状态的函数。如果初始状态是一个平衡点，即导数为零（即 $f(t_0, y_0) = 0$），那么计算出的增量将为零。因此，在所有后续步骤中，数值解将保持在平衡点。对于情况A和D，初始条件是 $(t_0, y_0) = (0, 0)$，这是一个平衡点，因为 $y'(0) = \\sqrt{0} = 0$。因此，一个标准的确定性积分器预计会产生平凡解 $y(T)=0$。\n\n对于情况B和C，初始值 $y_0$ 是一个小的正数。导数 $y'(t_0) = \\sqrt{y_0}$ 非零，因此数值积分将继续进行，远离 $y=0$ 轴。在这些情况下，求解器预计会跟踪由初始条件确定的唯一正解分支。\n\n为了解决这个问题，由于 $10^{-12}$ 的严格绝对容差要求，使用高阶自适应步长龙格-库塔方法是合适的。我将使用 `DOP853` 方法，这是一种8阶 Dormand-Prince 方法，可通过 `scipy.integrate.solve_ivp` 函数获得。该方法是确定性的，并提供稳健的误差控制。绝对容差（`atol`）和相对容差（`rtol`）都将设置为 $10^{-12}$ 以确保高精度。\n\n实现过程如下：\n1. ODE函数定义为 `ode_func(t, y)`，它返回 $\\sqrt{\\max(0, y)}$ 以防止由数值噪声产生的微小负值可能引起的平方根定义域错误。\n2. 创建一个函数来计算光滑正分支的解析值，$y^{\\mathrm{branch}}(t) = \\left(\\frac{t + 2\\sqrt{y_{0}} - t_{0}}{2}\\right)^{2}$。\n3. 遍历四个测试用例。对于每个用例，使用相应的参数（$t_0$, $y_0$, $T$ 和容差）调用 `scipy.integrate.solve_ivp`。\n4. 从求解器的输出中提取数值计算的终端值 $y(T)$。\n5. 使用解析公式计算光滑正分支的值 $y^{\\mathrm{branch}}(T)$。\n6. 计算绝对偏差 $|y(T) - y^{\\mathrm{branch}}(T)|$。\n7. 存储计算出的 $y(T)$ 和偏差。最后，将所有八个结果数字按要求格式化为单个扁平列表。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves the ODE y'(t) = sqrt(y(t)) for a suite of test cases,\n    comparing numerical results to a specified analytical branch.\n    \"\"\"\n\n    def ode_func(t, y):\n        \"\"\"\n        Defines the right-hand side of the ODE y'(t) = sqrt(y(t)).\n        The input y is a 1-element array.\n        np.maximum is used to prevent domain errors from numerical noise.\n        \"\"\"\n        return np.sqrt(np.maximum(0, y[0]))\n\n    def get_branch_solution(t, t0, y0):\n        \"\"\"\n        Calculates the value of the \"smooth positive branch\" solution.\n        The constant C is determined by the initial condition (t0, y0).\n        \"\"\"\n        # C = 2*sqrt(y0) - t0\n        # y(t) = ((t + C)/2)^2\n        val = (t + 2 * np.sqrt(y0) - t0) / 2\n        return val**2\n\n    # Test Suite: (t0, y0, T, tolerance)\n    test_cases = [\n        # Case A: locking at the equilibrium\n        (0.0, 0.0, 1.0, 1e-12),\n        # Case B: vanishingly small positive start\n        (0.0, 1e-12, 1.0, 1e-12),\n        # Case C: away from the non-Lipschitz point\n        (1e-6, (1e-6)**2 / 4.0, 1.0, 1e-12),\n        # Case D: short-time target at the equilibrium\n        (0.0, 0.0, 1e-3, 1e-12),\n    ]\n\n    results = []\n    for case in test_cases:\n        t0, y0, T, tol = case\n        \n        # Integrate the ODE\n        sol = solve_ivp(\n            fun=ode_func,\n            t_span=(t0, T),\n            y0=[y0],\n            method='DOP853',  # High-order deterministic method\n            atol=tol,\n            rtol=tol\n        )\n        \n        # Extract the computed value at the terminal time T\n        computed_y_T = sol.y[0, -1]\n        \n        # Calculate the corresponding value from the smooth positive branch\n        branch_y_T = get_branch_solution(T, t0, y0)\n        \n        # Calculate the absolute deviation\n        deviation = np.abs(computed_y_T - branch_y_T)\n        \n        results.append(computed_y_T)\n        results.append(deviation)\n    \n    # Format the final output as a comma-separated list in a single line\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "本练习  可作为一个综合性项目，挑战你完整实现 Bulirsch-Stoer 算法，以模拟一个真实的物理系统：带电粒子在匀强磁场中的运动。你不仅需要从零开始构建积分器，还将用它来分析该系统的一个关键物理特性——拉莫尔半径 (Larmor radius) 的守恒性。这项实践将巩固你对算法实现的理解，并揭示非几何积分器在长期模拟中所表现出的重要特征。",
            "id": "2378480",
            "problem": "实现一个完整的、可运行的程序，使用 Bulirsch–Stoer (BS) 外推法积分计算带电粒子在均匀磁场中的运动。物理模型必须基于洛伦兹力定律以及速度作为位置对时间导数的运动学定义。使用以下基本定律作为基础：\n\n- 洛伦兹力：$\\mathbf{F} = q\\,\\mathbf{v} \\times \\mathbf{B}$。\n- 牛顿第二定律：$m\\,\\dfrac{d\\mathbf{v}}{dt} = \\mathbf{F}$。\n- 运动学：$\\dfrac{d\\mathbf{x}}{dt} = \\mathbf{v}$。\n\n假设存在一个沿 $z$ 轴方向的空间均匀、不随时间变化的磁场 $\\mathbf{B}$，即 $\\mathbf{B} = (0,0,B_0)$，并且没有电场。设粒子质量为 $m$（单位：千克），电荷为 $q$（单位：库仑），位置为 $\\mathbf{x}(t)$（单位：米），速度为 $\\mathbf{v}(t)$（单位：米/秒），时间为 $t$（单位：秒）。所有物理量必须在国际单位制（SI）中处理。所有角度（如果适用）必须以弧度为单位。\n\n您的程序必须实现 Bulirsch–Stoer 外推算法，结合修正中点法和理查森外推法，以在时间上推进状态 $(\\mathbf{x},\\mathbf{v})$。该实现必须遵循上述基本定义从头开始，不得使用任何预构建的常微分方程（ODE）求解器。明确常微分方程（ODE）指的是形如 $\\dfrac{d\\mathbf{y}}{dt} = \\mathbf{f}(t,\\mathbf{y})$ 的方程组。代码必须是数值稳定的，并且必须能自适应调整步长以满足相对容差参数 $r_{\\text{tol}}$。\n\n在均匀磁场中的精确圆周运动具有恒定的拉莫尔半径（回旋半径）。对于 $\\mathbf{B} = (0,0,B_0)$，导心位置为\n$$\n\\mathbf{R}_{\\mathrm{gc}} = \\mathbf{x} + \\frac{m}{q B_0^2}\\,\\mathbf{v} \\times \\mathbf{B},\n$$\n在精确动力学下，该值不随时间变化，而轨道半径为\n$$\nr_{\\mathrm{L}} = \\left\\| \\mathbf{x} - \\mathbf{R}_{\\mathrm{gc}} \\right\\|.\n$$\n使用此特性来评估数值方法是否精确地保持轨道半径守恒。\n\n测试套件规范（所有常数和初始条件均采用 SI 单位）：\n- 使用电子参数 $q = -1.602176634\\times 10^{-19}$ C 和 $m = 9.1093837015\\times 10^{-31}$ kg，磁场大小 $B_0 = 1$ 特斯拉，初始位置 $\\mathbf{x}(0) = (0,0,0)$ 米，初始速度 $\\mathbf{v}(0) = (1.0\\times 10^{6}, 0, 0)$ 米/秒。定义回旋频率 $\\omega_c = \\dfrac{|q| B_0}{m}$ 和回旋周期 $T = \\dfrac{2\\pi}{\\omega_c}$，其中 $\\pi$ 是圆周率。\n\n- 您的程序必须在均匀分布的时间点上评估轨迹，并计算半径与初始拉莫尔半径的最大相对偏差，\n$$\n\\max_{t \\in [0,t_{\\text{final}}]} \\frac{\\left| r_{\\mathrm{L}}(t) - r_{\\mathrm{L}}(0) \\right|}{r_{\\mathrm{L}}(0)},\n$$\n在每个周期内使用固定数量的采样点。相对偏差是无量纲的；请以浮点数形式报告。\n\n提供四个测试用例以探究不同方面：\n- 测试 A（标准路径）：$t_{\\text{final}} = T$，相对容差 $r_{\\text{tol}} = 10^{-10}$，每个周期使用 $400$ 个样本点。\n- 测试 B（更严的容差）：$t_{\\text{final}} = T$，相对容差 $r_{\\text{tol}} = 10^{-12}$，每个周期使用 $400$ 个样本点。\n- 测试 C（更宽松的容差）：$t_{\\text{final}} = T$，相对容差 $r_{\\text{tol}} = 10^{-8}$，每个周期使用 $400$ 个样本点。\n- 测试 D（多周期累积）：$t_{\\text{final}} = 10\\,T$，相对容差 $r_{\\text{tol}} = 10^{-10}$，每个周期使用 $400$ 个样本点。\n\n所有 $T$ 的计算都必须使用弧度。四个测试的最终输出是按上述顺序排列的测试 A–D 的最大相对半径偏差的四个浮点数值。此外，计算一个布尔值来回答这个概念性问题：“Bulirsch–Stoer 方法是否精确地保持圆形轨道半径守恒？”定义此布尔值为真，当且仅当在机器运算精度内，所有四个计算出的最大相对偏差都精确等于 $0$，否则为假。\n\n最终输出格式要求：\n- 您的程序应生成单行输出，其中包含一个列表，按顺序包含五个结果，用方括号括起并用逗号分隔，例如 $[a,b,c,d,e]$，其中 $a$、$b$、$c$ 和 $d$ 是浮点数（测试 A-D 的最大相对偏差），$e$ 是回答上述守恒问题的布尔值。不应打印任何其他文本。\n\n程序必须完全自包含且可直接运行，无需用户输入。确保所有选定值和计算在科学上具有现实性，在数值上具有一致性。所有物理参数均以 SI 单位表示，并为相对偏差生成无量纲的输出。是否实现精确守恒的概念性论证将单独评估；在此您必须按规定计算数值证据和布尔值。",
            "solution": "用户要求实现 Bulirsch-Stoer (BS) 外推法，以求解带电粒子在均匀磁场中的运动轨迹。该问题在科学上是合理的、适定的，并为完整求解提供了所有必要信息。\n\n质量为 $m$、电荷为 $q$ 的粒子的运动遵循牛顿第二定律，其中作用力为洛伦兹力。给定均匀磁场 $\\mathbf{B} = (0, 0, B_0)$ 且无电场，该系统可描述为：\n$$ \\frac{d\\mathbf{x}}{dt} = \\mathbf{v} $$\n$$ m\\,\\frac{d\\mathbf{v}}{dt} = q(\\mathbf{v} \\times \\mathbf{B}) $$\n这构成了一个一阶常微分方程组（ODEs）。设状态向量为 $\\mathbf{y}(t) = (\\mathbf{x}(t), \\mathbf{v}(t)) = (x, y, z, v_x, v_y, v_z)$。该系统可以写成 $\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(t, \\mathbf{y})$。$\\mathbf{f}$ 的分量为：\n$$\n\\mathbf{f}(t, \\mathbf{y}) =\n\\begin{pmatrix}\nv_x \\\\\nv_y \\\\\nv_z \\\\\n\\frac{q B_0}{m} v_y \\\\\n-\\frac{q B_0}{m} v_x \\\\\n0\n\\end{pmatrix}\n$$\n无量纲量 $\\omega_c = \\frac{|q| B_0}{m}$ 是回旋频率。通过从初始状态 $\\mathbf{y}(0) = (\\mathbf{x}(0), \\mathbf{v}(0))$ 开始对该常微分方程组进行数值积分，即可解决该问题。\n\nBulirsch-Stoer 方法是一种求解常微分方程的先进数值技术，它结合了三个关键思想：\n1.  **修正中点法**：此方法用于在从 $t$ 到 $t+H$ 的一个大区间 $H$ 上获得解的低阶近似。它通过将 $H$ 分成 $n$ 个大小为 $h = H/n$ 的更小子步来实现。状态序列 $z_0, z_1, \\dots, z_n$ 的计算如下：\n    $$ z_0 = \\mathbf{y}(t) $$\n    $$ z_1 = z_0 + h \\cdot \\mathbf{f}(t, z_0) $$\n    $$ z_{m+1} = z_{m-1} + 2h \\cdot \\mathbf{f}(t+mh, z_m) \\quad \\text{for } m=1, \\dots, n-1 $$\n    最后通过一个平滑步骤得出对 $\\mathbf{y}(t+H)$ 的估计：\n    $$ \\mathbf{y}_n(H) = \\frac{1}{2}\\left(z_n + z_{n-1} + h \\cdot \\mathbf{f}(t+H, z_n)\\right) $$\n    此方法的误差有一个关于子步长偶数次幂的级数展开，即 $\\mathbf{y}_{true}(t+H) - \\mathbf{y}_n(H) = \\sum_{i=1}^{\\infty} c_i h^{2i} = \\sum_{i=1}^{\\infty} c_i (H/n)^{2i}$。\n\n2.  **理查森外推法**：该技术利用已知的误差结构来系统地消除误差项。我们为一系列递增的子步数（例如 $n \\in \\{2, 4, 6, 8, \\dots\\}$）计算估计值 $\\mathbf{y}_n(H)$，然后将结果外推到极限 $n \\to \\infty$（等价于 $h \\to 0$）。这是一种关于变量 $h^2$ 的多项式外推。我们构建一个表格（通常使用 Neville 算法），其中对角线项代表了逐步更高阶的近似。设 $T_{k,1}$ 是使用 $n_k$ 个子步的修正中点法得到的结果。外推表格为：\n    $$ T_{k,j} = T_{k,j-1} + \\frac{T_{k,j-1} - T_{k-1,j-1}}{(n_k/n_{k-j+1})^2 - 1} $$\n    表格项 $T_{k,k}$ 是真实解的一个高阶估计。\n\n3.  **自适应步长控制**：BS 方法单步计算量较大。为保持效率，整体步长 $H$ 会自适应调整，以最小的计算量满足指定的容差。在使用 $k$ 次外推成功计算从 $t$ 到 $t+H$ 的一步，得到解 $T_{k,k}$ 和估计误差 $\\epsilon$ 后，选择下一个步长 $H_{next}$ 以使单位步长的误差接近期望的容差。一种常见的控制策略是：\n    $$ H_{next} = H \\cdot S \\cdot \\left(\\frac{\\text{tol}}{\\epsilon}\\right)^{1/(2k+1)} $$\n    其中 $S$ 是一个安全因子（例如 $0.9$），`tol` 是该步的目标容差，$2k$ 是方法的近似阶数。如果一步失败（误差超过容差），则用一个更小的 $H$ 重新计算。\n\n在 $xy$ 平面内运动的轨道半径，即拉莫尔半径，由 $r_L = \\frac{v_\\perp}{\\omega_c} = \\frac{\\sqrt{v_x^2 + v_y^2}}{\\omega_c}$ 给出。解析上，对于此系统，动能和垂直速度的大小都是守恒的，这意味着 $r_L$ 是一个运动不变量。然而，BS 方法作为一个通用的数值积分器，并非“几何积分器”，因此本质上不能精确地保持这类量守恒。由于截断误差和浮点误差，数值解将显示出与真实恒定半径的微小偏差。这种偏差的大小可作为衡量该方法准确性和稳定性的实用指标。我们计算最大相对偏差来测试实现。关于精确守恒的概念性问题，可以通过检查这些数值计算出的偏差是否恒等于零来回答，而这通常是预料之外的。\n\n实现将包括一个驱动函数，该函数管理从一个用户指定的输出时间到下一个时间的自适应步进。其核心是，该驱动函数调用一个执行单步 Bulirsch-Stoer 的函数，该函数又使用修正中点法和理查森外推法，直到满足局部误差容差。在每个输出点计算拉莫尔半径，以确定整个积分区间上的最大相对误差。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the Bulirsch-Stoer simulation for all test cases.\n    \"\"\"\n    # Physical constants (SI units)\n    Q = -1.602176634e-19  # Electron charge in Coulombs\n    M = 9.1093837015e-31   # Electron mass in kg\n    B0 = 1.0               # Magnetic field in Tesla\n\n    # Initial conditions (SI units)\n    X0 = np.array([0.0, 0.0, 0.0])\n    V0 = np.array([1.0e6, 0.0, 0.0])\n    Y0 = np.concatenate([X0, V0])\n\n    # Derived parameters\n    OMEGA_C = np.abs(Q) * B0 / M\n    T_PERIOD = 2.0 * np.pi / OMEGA_C\n\n    # ODE function: dy/dt = f(t, y)\n    q_over_m = Q / M\n    def lorentz_force_ode(t, y):\n        \"\"\"\n        Describes the motion of a charged particle in a uniform B-field.\n        y = [x, y, z, vx, vy, vz]\n        \"\"\"\n        vx, vy = y[3], y[4]\n        ax = q_over_m * B0 * vy\n        ay = -q_over_m * B0 * vx\n        return np.array([y[3], y[4], y[5], ax, ay, 0.0])\n\n    # Test cases from the problem statement.\n    # (t_final_factor, rtol, samples_per_period)\n    test_cases_spec = [\n        (1.0, 1e-10, 400),  # Test A\n        (1.0, 1e-12, 400),  # Test B\n        (1.0, 1e-8, 400),   # Test C\n        (10.0, 1e-10, 400), # Test D\n    ]\n\n    all_results = []\n    \n    # --- Bulirsch-Stoer Implementation ---\n\n    def _modified_midpoint(func, y0, t, H, n):\n        \"\"\"\n        Performs n steps of the modified midpoint method over interval H.\n        \"\"\"\n        h = H / n\n        \n        # First step\n        z0 = y0\n        k1 = func(t, z0)\n        z1 = z0 + h * k1\n        \n        # Main loop\n        z_prev = z0\n        z_curr = z1\n        t_curr = t + h\n        for _ in range(1, n):\n            k = func(t_curr, z_curr)\n            z_next = z_prev + 2.0 * h * k\n            z_prev = z_curr\n            z_curr = z_next\n            t_curr += h\n        \n        # Final smoothing step\n        k_final = func(t + H, z_curr)\n        y_final = 0.5 * (z_prev + z_curr + h * k_final)\n        \n        return y_final\n\n    def _bs_step(func, y, t, H_try, rtol, atol_abs):\n        \"\"\"\n        Performs a single adaptive Bulirsch-Stoer step.\n        \"\"\"\n        MAX_K = 8  # Maximum order of extrapolation\n        N_SEQ = [2 * (k + 1) for k in range(MAX_K)]  # Sequence of substeps: 2, 4, 6,...\n        \n        table = np.zeros((MAX_K, MAX_K, len(y)))\n        \n        for k in range(MAX_K):\n            n_k = N_SEQ[k]\n            y_est = _modified_midpoint(func, y, t, H_try, n_k)\n            table[k, 0] = y_est\n\n            # Richardson extrapolation (Neville's algorithm)\n            for j in range(1, k + 1):\n                n_k_minus_j = N_SEQ[k-j]\n                factor = (n_k / n_k_minus_j)**2\n                num = table[k, j-1] - table[k-1, j-1]\n                den = factor - 1.0\n                table[k, j] = table[k, j-1] + num / den\n\n            # Check for convergence\n            y_new = table[k, k]\n            \n            # error estimation\n            if k == 0:\n                err_est = np.inf\n            else:\n                y_prev = table[k-1, k-1]\n                err_est = np.linalg.norm(y_new - y_prev)\n\n            atol = atol_abs\n            y_scale = np.linalg.norm(y) \n            tol = atol + rtol * y_scale\n\n            if err_est  tol:\n                # Converged\n                order = 2 * (k + 1)\n                return y_new, err_est, order, True\n\n        # Did not converge\n        return y, np.inf, 0, False\n\n    def integrate_bs(func, y0, t_eval, rtol):\n        \"\"\"\n        Main Bulirsch-Stoer ODE integrator with adaptive step size.\n        \"\"\"\n        t_start = t_eval[0]\n        t_end = t_eval[-1]\n        \n        t = t_start\n        y = y0\n        \n        results = [y0]\n        \n        # Initial step size guess (heuristic)\n        H = 0.1 * (t_end - t_start)\n        \n        # Safety and step control factors\n        S = 0.9 \n        MIN_FACTOR = 0.2\n        MAX_FACTOR = 5.0\n\n        current_out_idx = 1\n        while t  t_end and current_out_idx  len(t_eval):\n            t_out = t_eval[current_out_idx]\n            while t  t_out:\n                H_try = min(H, t_out - t)\n                \n                # Absolute tolerance for a step is relative to current state\n                atol_step = rtol * np.linalg.norm(y) + 1e-14\n\n                y_new, err, order, success = _bs_step(func, y, t, H_try, rtol, atol_step)\n\n                if success:\n                    # Step successful, update state and next step size\n                    t += H_try\n                    y = y_new\n                    \n                    if err == 0.0:\n                        factor = MAX_FACTOR\n                    else:\n                        factor = S * (atol_step / err)**(1.0 / (order + 1))\n                    \n                    H = H_try * min(MAX_FACTOR, max(MIN_FACTOR, factor))\n\n                else:\n                    # Step failed, reduce step size and retry\n                    H = H_try * 0.25\n            \n            # The integration has now passed t_out.\n            # For simplicity, we append the state at the end of the successful step.\n            # A more complex implementation would interpolate. This is sufficient.\n            results.append(y)\n            current_out_idx += 1\n\n\n        return np.array(results)\n\n    # Execute test cases\n    deviations = []\n    for t_factor, rtol, samples_per_period in test_cases_spec:\n        t_final = t_factor * T_PERIOD\n        num_samples = int(samples_per_period * t_factor)\n        if t_factor == 1.0:\n            num_samples +=1 # ensure endpoint is included for single period\n        t_eval = np.linspace(0.0, t_final, num_samples, endpoint=True)\n        \n        y_traj = integrate_bs(lorentz_force_ode, Y0, t_eval, rtol)\n\n        # Ensure y_traj has the same length as t_eval\n        if len(y_traj) != len(t_eval):\n             # Simple resampling if lengths mismatch. For this problem, they should align.\n             y_traj_resampled = np.zeros((len(t_eval), len(Y0)))\n             y_traj_resampled[0:len(y_traj)] = y_traj\n             y_traj = y_traj_resampled\n\n        # Calculate Larmor radius at each sample point\n        v_perp_sq = y_traj[:, 3]**2 + y_traj[:, 4]**2\n        rL_t = np.sqrt(v_perp_sq) / OMEGA_C\n\n        # Calculate initial Larmor radius\n        rL0 = rL_t[0]\n\n        # Calculate max relative deviation\n        if rL0 == 0.0:\n            max_rel_dev = np.max(np.abs(rL_t))\n        else:\n            max_rel_dev = np.max(np.abs(rL_t - rL0) / rL0)\n        \n        deviations.append(max_rel_dev)\n\n    # Conceptual question: Does the BS method conserve the radius exactly?\n    # True if and only if all deviations are *exactly* 0.0\n    is_conserved_exactly = all(d == 0.0 for d in deviations)\n\n    final_results = deviations + [is_conserved_exactly]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```"
        }
    ]
}