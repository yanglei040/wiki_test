{
    "hands_on_practices": [
        {
            "introduction": "首先，让我们将事件检测应用于一个熟悉的场景：抛体运动。这个练习将模拟一个抛体的飞行，并精确确定其撞击一个非平坦表面（本例中为一个抛物线形山丘）的瞬间 。通过基于抛体相对于地面的位置定义一个事件函数，你将练习将物理条件转化为常微分方程（ODE）求解器的数学触发器的基本技能。",
            "id": "2390630",
            "problem": "考虑一个质点射弹在无空气阻力的均匀引力场中的弹道运动。设射弹的状态由其位置 $(x(t), y(t))$（单位：米）和速度 $(v_x(t), v_y(t))$（单位：米/秒）给出。其动力学遵循牛顿第二定律，其中存在一个指向下方的恒定重力加速度 $g$。地面是一个由高度函数 $h(x) = a x^2 + b$ 描述的确定性、完全刚性的抛物面，其中 $a$ 的单位是米分之一，$b$ 的单位是米。撞击事件发生在满足 $y(t_{\\text{hit}}) = h(x(t_{\\text{hit}}))$ 的最早时间 $t_{\\text{hit}} > 0$，且该事件仅在轨迹从上往下穿过表面时被检测到。撞击后没有反弹。假设射弹的初始状态由初始位置 $(x(0), y(0)) = (x_0, y_0)$（单位：米）和初始速率 $v_0$（单位：米/秒）指定，发射角 $\\theta$ 是相对于正 $x$ 轴测量的（角度以度为单位）。\n\n根据第一性原理，该运动由以下常微分方程（ordinary differential equation (ODE)）控制：\n- $dx/dt = v_x$,\n- $dy/dt = v_y$,\n- $dv_x/dt = 0$,\n- $dv_y/dt = -g$.\n\n定义事件函数 $\\phi(t) = y(t) - h(x(t))$。撞击时间 $t_{\\text{hit}}$ 是 $\\phi(t)$ 的最小正根，且在该根处方向性穿越为负（即 $\\phi$ 从正值穿越到负值）。\n\n您的任务是编写一个完整的程序，对于下方的每个测试用例，从 $t = 0$ 开始对常微分方程进行时间上的正向积分，直到发生第一次撞击事件，或者如果未发生事件则直到达到有限的截止时间 $t_{\\max}$。请使用以下规则：\n- 使用 $g = 9.81$ 米/秒平方。\n- 在使用三角函数之前，将发射角 $\\theta$ 从度转换为弧度。\n- 事件由 $\\phi(t) = y(t) - (a x(t)^2 + b)$ 定义，并且检测仅限于向下的穿越。\n- 如果检测到事件，返回四元组 $[t_{\\text{hit}}, x_{\\text{hit}}, y_{\\text{hit}}, v_{\\text{hit}}]$，其中 $v_{\\text{hit}} = \\sqrt{v_x(t_{\\text{hit}})^2 + v_y(t_{\\text{hit}})^2}$ 是撞击时的速率。\n- 如果在 $[0, t_{\\max}]$ 区间内没有事件发生，返回 $[\\mathrm{nan}, \\mathrm{nan}, \\mathrm{nan}, \\mathrm{nan}]$。\n\n所有答案必须以国际单位制（SI）表示：时间单位为秒，位置单位为米，速率单位为米/秒。角度以度为单位提供，必须在内部转换为弧度。您的程序必须将报告的每个浮点值四舍五入到六位小数。\n\n测试套件（每个用例为 $(a, b, x_0, y_0, v_0, \\theta, t_{\\max})$）：\n- 用例 A（一般“顺利路径”）：$(0.02, 0.0, 0.0, 2.0, 20.0, 30.0, 10.0)$。\n- 用例 B（在凸起小山上方近水平发射）：$(0.05, 1.0, 0.0, 1.5, 10.0, 0.0, 10.0)$。\n- 用例 C（陡峭发射；随着山坡升高，撞击稍后发生）：$(0.001, 0.0, 0.0, 1.0, 50.0, 60.0, 30.0)$。\n- 用例 D（在固定水平位置垂直下落）：$(0.01, 2.0, 5.0, 5.0, 0.0, 90.0, 10.0)$。\n\n最终输出格式：您的程序应生成单行输出，其中包含四个用例的结果，形式为一个用方括号括起来的逗号分隔列表，其中每个元素本身就是 $[t_{\\text{hit}}, x_{\\text{hit}}, y_{\\text{hit}}, v_{\\text{hit}}]$ 形式的列表。例如：$[[t_1,x_1,y_1,v_1],[t_2,x_2,y_2,v_2],[t_3,x_3,y_3,v_3],[t_4,x_4,y_4,v_4]]$。每个数字必须按要求四舍五入到六位小数。",
            "solution": "所提出的问题是有效的。这是一个在经典力学和计算物理学中适定（well-posed）的问题，其基础是运动学和常微分方程的既定原理。所有必要的条件和参数都已提供，并且没有科学或逻辑上的不一致之处。我们将继续提供解决方案。\n\n该问题要求对一个描述射弹运动的常微分方程（ODE）系统进行数值求解，积分过程在一个特定事件发生时终止：即射弹与抛物面发生撞击。任务的核心是正确地构建动力学系统并实现一个事件检测算法。\n\n首先，我们定义系统在任意时间 $t \\ge 0$ 的状态。状态向量 $S(t)$ 由射弹的位置和速度分量给出：\n$$\nS(t) = \\begin{bmatrix} x(t) \\\\ y(t) \\\\ v_x(t) \\\\ v_y(t) \\end{bmatrix}\n$$\n系统的动力学由牛顿第二定律描述，适用于在加速度为 $g$ 的均匀引力场中的质点。这产生一个包含四个一阶常微分方程的系统：\n$$\n\\frac{dS}{dt} = \\frac{d}{dt} \\begin{bmatrix} x \\\\ y \\\\ v_x \\\\ v_y \\end{bmatrix} = \\begin{bmatrix} v_x \\\\ v_y \\\\ 0 \\\\ -g \\end{bmatrix} = F(S)\n$$\n初始状态 $S(0)$ 由给定的初始条件确定：位置 $(x_0, y_0)$，速率 $v_0$，以及发射角 $\\theta$。角度 $\\theta$ 必须首先从度转换为弧度，我们称之为 $\\theta_{\\text{rad}}$。初始速度分量则为：\n$$\nv_x(0) = v_0 \\cos(\\theta_{\\text{rad}})\n$$\n$$\nv_y(0) = v_0 \\sin(\\theta_{\\text{rad}})\n$$\n因此，初始状态向量被完全指定为 $S(0) = [x_0, y_0, v_x(0), v_y(0)]^T$。\n\n撞击事件由射弹的垂直位置 $y(t)$ 等于抛物线形地面的高度 $h(x(t)) = ax(t)^2 + b$ 这一条件定义。我们定义一个事件函数 $\\phi(t)$，其根对应于轨迹与地面的交点：\n$$\n\\phi(t) = y(t) - h(x(t)) = y(t) - (a \\cdot x(t)^2 + b)\n$$\n如果 $\\phi(t_{\\text{hit}}) = 0$，则在时间 $t_{\\text{hit}}$ 发生撞击。该问题还规定了两个额外约束：\n$1$. 撞击必须是 $t > 0$ 时最早发生的此类事件。\n$2$. 事件仅在向下穿越时被检测到，这意味着射弹从表面上方移动到其下方。这可以转换为事件函数在根处递减的条件，即 $\\frac{d\\phi}{dt} \\bigg|_{t=t_{\\text{hit}}}  0$。\n\n解决此类问题的标准且最稳健的方法是使用包含用于事件检测的求根功能的数值常微分方程积分器。SciPy 库中的 `scipy.integrate.solve_ivp` 函数正是为此目的而设计的。\n\n对于每个测试用例，算法按以下步骤进行：\n$1$. **初始化**：参数 $(a, b, x_0, y_0, v_0, \\theta, t_{\\max})$ 用于定义具体的问题实例。重力常数为 $g = 9.81 \\, \\text{m/s}^2$。如上所述计算初始状态向量 $S(0)$。积分时间区间为 $[0, t_{\\max}]$。\n\n$2$. **常微分方程系统定义**：定义一个函数，例如 `ode_system(t, S)`，用于计算导数向量 $\\frac{dS}{dt}$。该函数实现运动方程，返回 $[S_2, S_3, 0, -g]$，其中 $S_i$ 是状态向量的第 $i$ 个分量（为清晰起见，使用基于 1 的索引）。\n\n$3$. **事件函数定义**：定义一个函数，例如 `event_func(t, S)`，用于计算事件函数 $\\phi(t, S(t)) = S_1 - (a \\cdot S_0^2 + b)$ 的值。为满足问题的约束，我们为求解器配置此事件函数：\n    - 我们将其 `terminal` 属性设置为 `True`。这指示求解器在找到事件时终止积分。\n    - 我们将其 `direction` 属性设置为 $-1$。这指示求解器仅报告事件函数递减（从正值穿越到负值）的根，这与物理要求相匹配。\n\n$4$. **数值积分**：使用常微分方程系统、时间区间、初始状态向量和配置好的事件函数调用 `solve_ivp` 函数。我们还必须请求 `dense_output=True`，以确保求解器能够在积分步之间准确定位根。\n\n$5$. **结果提取**：求解器返回后，我们检查其输出。\n    - 如果 `sol.t_events` 列表不为空，则表示成功检测到事件。第一个元素 `sol.t_events[0][0]` 给出撞击时间 $t_{\\text{hit}}$。撞击时的相应状态 $S(t_{\\text{hit}})$ 可以在 `sol.y_events[0][0]` 中找到。\n    - 从撞击时的状态中，我们提取出位置 $(x_{\\text{hit}}, y_{\\text{hit}})$ 和速度 $(v_{x,\\text{hit}}, v_{y,\\text{hit}})$。最终的撞击速率计算为 $v_{\\text{hit}} = \\sqrt{v_{x,\\text{hit}}^2 + v_{y,\\text{hit}}^2}$。\n    - 如果 `sol.t_events` 列表为空，则表示在区间 $[0, t_{\\max}]$ 内没有满足条件的事件发生。在这种情况下，所有四个输出值都报告为非数字（`nan`）。\n\n$6$. **格式化**：最终的数值结果 $[t_{\\text{hit}}, x_{\\text{hit}}, y_{\\text{hit}}, v_{\\text{hit}}]$ 按要求四舍五入到六位小数。\n\n此过程为该问题提供了一个完整、正确且稳健的解决方案，它使用标准的、经过验证的计算工具直接实现了物理原理。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves for the impact time and state of a projectile on a parabolic surface.\n    \"\"\"\n    # Gravitational constant in m/s^2\n    G = 9.81\n\n    # Test suite: (a, b, x0, y0, v0, theta, t_max)\n    test_cases = [\n        # Case A (general “happy path”)\n        (0.02, 0.0, 0.0, 2.0, 20.0, 30.0, 10.0),\n        # Case B (near-horizontal launch above a raised hill)\n        (0.05, 1.0, 0.0, 1.5, 10.0, 0.0, 10.0),\n        # Case C (steep launch; impact occurs later as the hill rises)\n        (0.001, 0.0, 0.0, 1.0, 50.0, 60.0, 30.0),\n        # Case D (vertical drop at fixed horizontal position)\n        (0.01, 2.0, 5.0, 5.0, 0.0, 90.0, 10.0),\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        a, b, x0, y0, v0, theta_deg, t_max = case\n\n        # Convert angle to radians for trigonometric functions\n        theta_rad = np.deg2rad(theta_deg)\n\n        # Calculate initial velocity components\n        vx0 = v0 * np.cos(theta_rad)\n        vy0 = v0 * np.sin(theta_rad)\n\n        # Initial state vector: [x, y, vx, vy]\n        s0 = [x0, y0, vx0, vy0]\n\n        def ode_system(t, s):\n            \"\"\"\n            Defines the system of ordinary differential equations for projectile motion.\n            s = [x, y, vx, vy]\n            \"\"\"\n            # dx/dt = vx\n            # dy/dt = vy\n            # dvx/dt = 0\n            # dvy/dt = -g\n            return [s[2], s[3], 0, -G]\n\n        def event_func(t, s):\n            \"\"\"\n            Event function for impact detection.\n            The event occurs when y(t) - h(x(t)) = 0.\n            h(x) = a*x^2 + b\n            \"\"\"\n            return s[1] - (a * s[0]**2 + b)\n\n        # Set event properties: terminate on event, detect downward crossing\n        event_func.terminal = True\n        event_func.direction = -1\n\n        # Integrate the ODE system\n        sol = solve_ivp(\n            fun=ode_system,\n            t_span=[0, t_max],\n            y0=s0,\n            events=event_func,\n            dense_output=True,\n        )\n\n        # Process the results\n        if sol.t_events and len(sol.t_events[0]) > 0:\n            # Event was detected\n            t_hit = sol.t_events[0][0]\n            s_hit = sol.y_events[0][0]\n            x_hit, y_hit, vx_hit, vy_hit = s_hit\n\n            # The problem asks for the height of the impact to be y_hit,\n            # which is guaranteed by the event function to be a*x_hit**2 + b\n            # at the located root.\n            \n            # Calculate final speed at impact\n            v_hit = np.sqrt(vx_hit**2 + vy_hit**2)\n\n            case_result = [t_hit, x_hit, y_hit, v_hit]\n        else:\n            # No event detected within t_max\n            case_result = [np.nan, np.nan, np.nan, np.nan]\n\n        all_results.append(case_result)\n\n    # Format the final output string\n    formatted_results = []\n    for case_res in all_results:\n        str_vals = []\n        for val in case_res:\n            if np.isnan(val):\n                str_vals.append(\"nan\")\n            else:\n                str_vals.append(f\"{val:.6f}\")\n        formatted_results.append(f\"[{','.join(str_vals)}]\")\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "接下来，我们将探讨混合动力系统，其中连续的运动被离散的事件所中断。在一个振动平台上的弹跳球的经典例子  完美地展示了这一点。这个练习不仅要求你检测碰撞——一个具有时变边界的事件——还要求你通过在继续仿真前重置系统状态来实施碰撞的物理后果。",
            "id": "2390644",
            "problem": "要求您在常微分方程积分中，为在一维振动平台上方弹跳的小球实现事件检测。小球的垂直位置由源自牛顿第二定律的重力作用下运动的二阶常微分方程建模。平台根据一个预设的运动学函数进行垂直运动。当小球从上方接近平台且其高度与平台高度相等时，发生碰撞事件。碰撞时，小球的速度根据恢复系数的定义发生改变。您的任务是检测有限时间区间内的所有此类事件，并在每次碰撞时根据碰撞定律更新小球的速度。必须为一小组指定的测试用例计算最终输出。\n\n使用以下基本依据：\n- 匀速重力场中垂直运动的牛顿第二定律：小球的垂直位置 $y(t)$ 和垂直速度 $v(t)$ 服从 $\\dot{y}(t) = v(t)$ 和 $\\dot{v}(t) = -g$，其中 $g$ 是重力加速度。\n- 平台高度为 $y_{p}(t)$，是一个已知的时间函数。平台速度为 $v_{p}(t) = \\dot{y}_{p}(t)$。\n- 恢复系数 $e \\in [0,1]$ 定义为碰撞后相对法向速度的大小与碰撞前相对法向速度大小之比。\n\n数学设置：\n- 状态向量：$\\mathbf{x}(t) = \\begin{bmatrix} y(t) \\\\ v(t) \\end{bmatrix}$，其控制方程为\n$$\n\\dot{\\mathbf{x}}(t) = \\begin{bmatrix} v(t) \\\\ -g \\end{bmatrix}.\n$$\n- 平台运动：$y_{p}(t) = A \\sin(\\omega t)$，其中 $\\omega = 2\\pi f$，$A$ 是振幅，$f$ 是频率。平台速度为 $v_{p}(t) = A \\omega \\cos(\\omega t)$。\n- 事件定义：当小球从上方接近平台时，在满足 $y(t) = y_{p}(t)$ 的时刻 $t$ 发生事件。必须通过一个标量函数的零点来检测事件，并且您的检测必须强制执行接近方向以避免伪接触。\n- 碰撞更新：如果在时刻 $t_{\\mathrm{imp}}$ 发生事件，设 $v^{-}$ 为碰撞前瞬间的小球速度，$v^{+}$ 为碰撞后瞬间的速度。设 $v_{p}$ 为同一时刻的平台速度。使用恢复系数的定义从 $v^{-}$ 和 $v_{p}$ 更新 $v^{+}$。\n- 粘连判据：为避免当碰撞后相对速度可忽略时出现的数值颤振，如果 $|v^{+} - v_{p}|  \\varepsilon_{v}$，则认为小球“粘”在了平台上。在这种情况下，在模拟的剩余时间里，小球与平台一起运动，即 $y(t) = y_{p}(t)$。\n\n数值说明：\n- 使用一个支持事件的自适应常微分方程积分器，将状态从 $t=0$ 推进到 $t=T$，并在此过程中重复处理发生的碰撞。确保事件包围和方向性被配置为仅在 $y(t) - y_{p}(t)$ 递减穿过零时检测到穿越。\n- 在每次处理完碰撞后，使用一个小的正时间偏移来重新初始化积分器，使其离开事件表面。\n- 使用足够小的相对和绝对容差，以可靠地定位事件时间。\n\n输出：\n对每个测试用例，计算以下量：\n1. 在 $t \\in [0,T]$ 内检测到的碰撞事件总数 $N$（整数）。\n2. 第一次碰撞的时间 $t_{\\mathrm{first}}$（秒），如果至少发生一次碰撞；否则报告 $-1.0$。\n3. 最后一次碰撞的时间 $t_{\\mathrm{last}}$（秒），如果至少发生一次碰撞；否则报告 $-1.0$。\n4. 模拟结束时小球的最终高度 $y(T)$（米）。\n\n物理和数值单位及格式：\n- 所有时间必须以秒报告，所有长度以米报告。\n- 报告 $t_{\\mathrm{first}}$, $t_{\\mathrm{last}}$ 和 $y(T)$，四舍五入到六位小数。\n- 恢复系数 $e$ 是无量纲的。重力加速度 $g$ 的单位是 $\\mathrm{m}/\\mathrm{s}^2$。振幅 $A$ 的单位是米，频率 $f$ 的单位是赫兹，角频率 $\\omega$ 的单位是弧度/秒。\n\n测试套件：\n模拟以下四种情况，每种情况指定为 $(g, A, f, e, y_{0}, v_{0}, T)$，其中 $y_{0}$ 和 $v_{0}$ 分别是 $t=0$ 时的初始高度（米）和初始垂直速度（米/秒）：\n\n- 情况1（一般振动平台）：$(9.81, 0.10, 1.5, 0.8, 1.0, 0.0, 3.0)$。\n- 情况2（边界：初始接触且向下接近）：$(9.81, 0.05, 2.0, 0.9, 0.0, -1.0, 1.0)$。\n- 情况3（边缘：时间范围内无碰撞）：$(9.81, 0.05, 1.0, 0.8, -0.5, 2.0, 0.5)$。\n- 情况4（边缘：在静止地面上的完全非弹性碰撞）：$(9.81, 0.0, 0.0, 0.0, 1.0, 0.0, 2.0)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含四个案例的结果，形式为一个逗号分隔的列表，该列表包含四个子列表，每个子列表的顺序为 $[N, t_{\\mathrm{first}}, t_{\\mathrm{last}}, y(T)]$，并且浮点数值四舍五入到六位小数。例如，输出必须看起来像：\"[ [N1,tfirst1,tlast1,yT1], [N2,tfirst2,tlast2,yT2], [N3,tfirst3,tlast3,yT3], [N4,tfirst4,tlast4,yT4] ]\"，但除了列表分隔符所需的空格外，不含额外空格。将每个占位符替换为计算出的数字。",
            "solution": "问题陈述已经过分析，并被确定为有效。这是一个计算物理学中定义明确的问题，基于经典力学的基本原理。目标明确，所提供的数据足以构建数值解且前后一致。任务是模拟小球在重力作用下的一维运动，该运动受到与振动平台的碰撞影响，并报告此运动的特定度量指标。\n\n该方法涉及对控制常微分方程（ODE）进行数值积分，并结合事件检测机制来处理离散的碰撞。解决方案是按部就班地构建的，从物理模型开始，然后到数值算法。\n\n在任何时刻 $t$，小球的状态由其垂直位置 $y(t)$ 和速度 $v(t)$ 描述。状态向量为 $\\mathbf{x}(t) = \\begin{bmatrix} y(t) \\\\ v(t) \\end{bmatrix}$。根据物体在匀强重力场中的牛顿第二定律，运动方程为：\n$$\n\\dot{\\mathbf{x}}(t) = \\frac{d\\mathbf{x}}{dt} = \\begin{bmatrix} v(t) \\\\ -g \\end{bmatrix}\n$$\n其中 $g$ 是重力加速度。这是一个一阶常微分方程组。\n\n平台的运动被规定为时间的正弦函数：\n$$\ny_{p}(t) = A \\sin(\\omega t)\n$$\n其中 $A$ 是振幅，$\\omega = 2\\pi f$ 是角频率。平台的速度是其位置对时间的导数：\n$$\nv_{p}(t) = \\dot{y}_{p}(t) = A \\omega \\cos(\\omega t)\n$$\n\n当小球与平台接触时，发生碰撞事件。问题为有效碰撞指定了两个条件：\n1. 小球的位置等于平台的位置：$y(t) = y_{p}(t)$。\n2. 小球从上方接近平台。这意味着就在碰撞前，相对速度 $v(t) - v_{p}(t)$ 是负的。\n\n这些条件由一个标量事件函数 $E(t, \\mathbf{x}(t)) = y(t) - y_{p}(t)$ 捕捉。碰撞对应于此函数的根，$E(t, \\mathbf{x}(t))=0$。接近方向的条件意味着只有当函数 $E(t, \\mathbf{x}(t))$ 递减穿过零时才必须检测到事件。\n\n常微分方程组的数值积分是使用一个自适应步长积分器执行的，具体来说是 SciPy 库中的 `solve_ivp` 函数，该函数因其内置的事件检测功能而非常适合此类问题。模拟在一个循环中进行。在循环的每一步中，积分器将解从当前时间 $t_{current}$ 向前推进，直到达到最终时间 $T$ 或检测到事件为止。\n\n如果在时间 $t_{\\mathrm{imp}}$ 检测到事件，积分将停止。获得碰撞前瞬间小球的状态 $\\mathbf{x}^{-}(t_{\\mathrm{imp}}) = \\begin{bmatrix} y(t_{\\mathrm{imp}}) \\\\ v^{-}(t_{\\mathrm{imp}}) \\end{bmatrix}$。然后根据恢复定律瞬时更新小球的速度。恢复系数 $e$ 由以下公式定义：\n$$\nv_{\\mathrm{rel, post}} = -e \\cdot v_{\\mathrm{rel, pre}}\n$$\n其中 $v_{\\mathrm{rel, pre}} = v^{-} - v_{p}$ 和 $v_{\\mathrm{rel, post}} = v^{+} - v_{p}$ 分别是碰撞前后的相对速度。这里，$v_{p}$ 是在 $t_{\\mathrm{imp}}$ 时的平台速度，$v^{+}$ 是碰撞后瞬间的小球速度。这得出了小球速度的更新规则：\n$$\nv^{+} = v_{p}(t_{\\mathrm{imp}}) - e \\left( v^{-} - v_{p}(t_{\\mathrm{imp}}) \\right)\n$$\n小球的位置在碰撞过程中保持连续，$y^{+}(t_{\\mathrm{imp}}) = y^{-}(t_{\\mathrm{imp}})$。\n\n速度更新后，执行“粘连”检查。如果碰撞后的相对速度 $|v^{+} - v_{p}(t_{\\mathrm{imp}})|  \\varepsilon_{v}$，则认为小球已粘在平台上。在这种情况下，弹道运动的模拟终止。对于所有后续时间 $t > t_{\\mathrm{imp}}$，小球的轨迹由平台的运动学决定，即 $y(t) = y_{p}(t)$。那么在时间 $T$ 的最终高度就是 $y(T) = y_p(T)$。\n\n如果小球没有粘连，则用新状态 $\\mathbf{x}^{+}(t_{\\mathrm{imp}}) = \\begin{bmatrix} y(t_{\\mathrm{imp}}) \\\\ v^{+} \\end{bmatrix}$ 重新初始化积分器，并将时间从 $t_{\\mathrm{imp}}$ 推进一个小偏移量，以防止立即再次检测到该事件。然后积分循环继续。\n\n重复此过程，直到模拟时间 $t$ 达到最终时间 $T$。对于在初始时间 $t=0$ 发生碰撞的边界情况，需要特别注意，在开始主积分循环之前执行碰撞更新计算。\n\n在此过程中收集所需的输出——碰撞总数 $N$、第一次和最后一次碰撞的时间（$t_{\\mathrm{first}}$, $t_{\\mathrm{last}}$）以及最终的小球高度 $y(T)$。如果没有发生碰撞，$N$ 为 $0$，$t_{\\mathrm{first}}$ 和 $t_{\\mathrm{last}}$ 报告为 $-1.0$。ODE 求解器的数值容差（`rtol`, `atol`）被设置为一个很小的值 $10^{-12}$，以确保轨迹和事件时间定位的高精度。粘连容差 $\\varepsilon_v$ 设置为 $10^{-8}$。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n\n    def run_simulation(g, A, f, e, y0, v0, T):\n        \"\"\"\n        Solves the bouncing ball problem for a single set of parameters.\n        \"\"\"\n        omega = 2.0 * np.pi * f\n        sticking_tolerance = 1e-8\n        time_offset = 1e-12\n\n        # Define platform kinematics\n        def platform_pos(t):\n            if A == 0.0:\n                return 0.0\n            return A * np.sin(omega * t)\n\n        def platform_vel(t):\n            if A == 0.0:\n                return 0.0\n            return A * omega * np.cos(omega * t)\n\n        # Define ODE system for the ball\n        def dynamics(t, state):\n            # state = [y, v]\n            return [state[1], -g]\n\n        # Define event function for impact detection\n        def impact_event(t, state):\n            # Event function is zero when ball height equals platform height\n            return state[0] - platform_pos(t)\n        \n        impact_event.terminal = True  # Stop integration at event\n        impact_event.direction = -1   # Trigger only when function is decreasing\n\n        # Initialize simulation variables\n        t_current = 0.0\n        state_current = np.array([y0, v0], dtype=float)\n        impact_times = []\n        is_sticking = False\n\n        # Handle potential impact at t=0, which solve_ivp might ignore.\n        # Check if positions match and relative velocity is negative.\n        if np.isclose(state_current[0], platform_pos(0.0)):\n            v_rel_initial = state_current[1] - platform_vel(0.0)\n            if v_rel_initial  0:\n                impact_times.append(0.0)\n                v_minus = state_current[1]\n                v_p = platform_vel(0.0)\n                v_plus = v_p - e * (v_minus - v_p)\n                \n                if abs(v_plus - v_p)  sticking_tolerance:\n                    is_sticking = True\n                    t_current = 0.0\n                else:\n                    state_current[1] = v_plus\n                    t_current += time_offset\n\n        # Main simulation loop\n        while t_current  T and not is_sticking:\n            sol = solve_ivp(\n                dynamics,\n                (t_current, T),\n                state_current,\n                events=impact_event,\n                dense_output=True,\n                rtol=1e-12,\n                atol=1e-12\n            )\n            \n            t_current = sol.t[-1]\n            state_current = sol.y[:, -1]\n\n            # Check if an event was found\n            if sol.status == 1 and sol.t_events[0].size > 0:\n                t_event = sol.t_events[0][0]\n                impact_times.append(t_event)\n                \n                # State right before impact\n                state_at_event = sol.sol(t_event)\n                v_minus = state_at_event[1]\n                v_p = platform_vel(t_event)\n                \n                # Apply restitution law\n                v_plus = v_p - e * (v_minus - v_p)\n                \n                # Check for sticking\n                if abs(v_plus - v_p)  sticking_tolerance:\n                    is_sticking = True\n                    t_current = t_event # Set time for final height calculation\n                    break\n                \n                # Re-initialize state for next integration segment\n                t_current = t_event + time_offset\n                state_current[0] = state_at_event[0]\n                state_current[1] = v_plus\n                \n                if t_current >= T:\n                    break\n        \n        # Calculate final reported values\n        N = len(impact_times)\n        t_first = -1.0 if N == 0 else impact_times[0]\n        t_last = -1.0 if N == 0 else impact_times[-1]\n        \n        if is_sticking:\n            y_final = platform_pos(T)\n        else:\n            y_final = state_current[0]\n\n        return [\n            N,\n            round(t_first, 6),\n            round(t_last, 6),\n            round(y_final, 6)\n        ]\n\n    test_cases = [\n        (9.81, 0.10, 1.5, 0.8, 1.0, 0.0, 3.0),\n        (9.81, 0.05, 2.0, 0.9, 0.0, -1.0, 1.0),\n        (9.81, 0.05, 1.0, 0.8, -0.5, 2.0, 0.5),\n        (9.81, 0.0, 0.0, 0.0, 1.0, 0.0, 2.0)\n    ]\n    \n    results = []\n    for case in test_cases:\n        result = run_simulation(*case)\n        results.append(result)\n    \n    # Format the final output string exactly as required, with no extra spaces.\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```"
        },
        {
            "introduction": "最后，我们将处理一个更高级的模型，它展示了事件检测如何成为揭示复杂物理现象的关键。通过模拟一个简化的水龙头滴水模型 ，你将研究一个系统的行为如何随着单个参数的改变而发生巨大变化，从而导致倍周期分岔和混沌。这个练习展示了事件驱动模拟在非线性动力学和复杂系统研究中的强大威力。",
            "id": "2419756",
            "problem": "要求您构建一个完整的、可运行的程序，通过阻尼驱动振子的视角对滴水的水龙头进行数值模拟。该模型基于牛顿第二定律构建，并采用以下简化且广泛使用的假设：当水滴仍附着在水龙头上时，其行为如同一个连接到线性弹簧和阻尼器上的质点，并受到恒定的引力作用。水龙头以恒定的流速增加质量，当伸长量超过一个与质量相关的断裂阈值时，水滴脱落。脱落后，会残留一小部分作为下一滴水滴的“种子”。这是一个标准的计算物理练习，它导出一个带有状态重置的非自治常微分方程（ODE）。目标是模拟随流速变化的动力学过程，并提取暂态过程后不同滴水间隔时间的数量，从而揭示一个倍周期序列。\n\n从牛顿第二定律以及线性阻尼和线性弹性的定义出发。当水滴附着时，假设如下：\n- 水滴相对于水龙头的位置是一个标量位移 $x(t)$，向下为正，其速度为 $v(t) = \\frac{dx}{dt}$。\n- 瞬时质量 $m(t)$ 以恒定的流入速率 $q$ 增加，即 $\\frac{dm}{dt} = q$。\n- 水滴受到的力来自重力、线性弹簧和线性阻尼器，其系数分别为 $g$、$\\kappa$ 和 $\\gamma$。\n- 新增质量被假定为在附着时相对动量效应可忽略不计，这给出了一个常用的近似，即等式左侧使用 $m(t)\\,x''(t)$，而没有额外的喷射动量项。\n\n在这些假设下，附着时的控制方程为\n$$\n\\frac{dx}{dt} = v, \\quad \n\\frac{dv}{dt} = \\frac{m(t)\\,g - \\gamma\\,v - \\kappa\\,x}{m(t)}, \\quad\n\\frac{dm}{dt} = q.\n$$\n当伸长量 $x(t)$ 从下方达到阈值 $x_{\\mathrm{break}}(m)$ 时，发生断裂（脱落），其中\n$$\nx_{\\mathrm{break}}(m) = x_0 - \\beta\\,m,\n$$\n$x_0$ 和 $\\beta$ 是正常数。在脱落时间 $t_d$，状态被重置，以模拟残余质量附着在水龙头颈部，并为下一滴水滴提供一个松弛、静止的初始条件：\n$$\nx(t_d^+) = 0, \\quad v(t_d^+) = 0, \\quad m(t_d^+) = \\alpha\\,m(t_d^-),\n$$\n其中 $0  \\alpha  1$ 是残余质量分数，上标 $^-$ 和 $^+$ 分别表示事件发生前后的极限。\n\n您的任务是：\n1) 从牛顿第二定律出发，在所述假设下，论证上述ODE系统和重置规则的合理性。阐明可变质量如何进入加速度方程，并解释为何所选的简化在此背景下是合适的。\n2) 设计并实现一个稳健的事件驱动数值积分器，以：\n   - 积分ODE，直到检测到 $x$ 递增的断裂事件 $x(t) - x_{\\mathrm{break}}(m(t)) = 0$。\n   - 应用重置规则并继续模拟，以生成一个长的滴水时间序列。\n3) 对于每个指定的流速 $q$，计算滴水间隔时间 $\\Delta t_n = t_{n} - t_{n-1}$。舍去初始暂态，然后在某个容差范围内确定不同滴水间隔时间的数量，该数量是周期-$k$ 行为（例如，周期-1时为 $k=1$，倍周期后周期-2时为 $k=2$ 等）的整数诊断指标。使用一个结合了绝对和相对分量的容差，以避免因数值噪声造成的错误区分。\n4) 使用以下无量纲参数用于振子和断裂模型，并指定流速的测试套件：\n   - 振子参数：$\\kappa = 1.0$, $\\gamma = 0.05$, $g = 0.34$。\n   - 断裂参数：$x_0 = 0.50$, $\\beta = 0.10$, $\\alpha = 0.30$。\n   - 最初始条件：$x(0) = 0$, $v(0) = 0$, $m(0) = 0.40$。\n   - 流速测试套件（四种情况）：$q \\in \\{\\,0.010,\\,0.025,\\,0.050,\\,0.080\\,\\}$。\n   - 积分足够长的时间以观察每种情况下至少 $N_{\\mathrm{total}} = 60$ 次滴落，舍弃前 $N_{\\mathrm{trans}} = 30$ 次作为暂态，并分析接下来的 $N_{\\mathrm{keep}} = 30$ 次滴落。\n   - 使用检测容差，通过规则“如果 $|\\Delta t_i - \\Delta t_j| \\le \\max(\\varepsilon_{\\mathrm{abs}}, \\varepsilon_{\\mathrm{rel}}\\cdot \\max(|\\Delta t_i|,|\\Delta t_j|))$ 则属于同一组”来将滴水间隔时间 $\\Delta t$ 聚类成不同的组，其中 $\\varepsilon_{\\mathrm{abs}}=10^{-3}$ 和 $\\varepsilon_{\\mathrm{rel}}=10^{-3}$。\n5) 您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔的整数列表（例如，“[1,2,4,1]”），每个整数是按上述顺序对应流速下计算出的不同滴水间隔时间的数量。\n\n该问题必须以纯数学和算法的方式解决，以便可以在任何编程语言中实现。以上所有量都是无量纲的，因此不需要进行物理单位转换。确保参数具有科学真实性，并在您的解决方案中讨论为什么该方法能够捕捉到倍周期序列。每个测试用例的最终答案是整数，量化了在暂态过程后发现的不同滴水间隔时间的数量。",
            "solution": "所提出的问题是计算物理学中一个有效的练习。它在科学上是合理的，问题提法是适定的，并且所有必要的参数和条件都已指定。它代表了将一个复杂的物理现象——滴水的水龙头——简化为一个带有状态重置的非自治常微分方程组，该模型已知会表现出倍周期分岔和混沌。我们将进行严谨的推导和算法设计。\n\n首先，我们必须从基本原理出发来论证控制方程的合理性。所描述的系统是一个质量 $m(t)$ 随时间变化的质点。对于可变质量物体，牛顿第二定律最一般的表述是动量 $\\vec{p}$ 的变化率等于净外力 $\\vec{F}_{\\mathrm{ext}}$，即 $\\vec{F}_{\\mathrm{ext}} = \\frac{d\\vec{p}}{dt}$。在我们的以为系统中，动量是 $p(t) = m(t)v(t)$，其中 $v(t) = \\frac{dx}{dt}$ 是速度。应用微分的乘法法则，我们得到：\n$$\n\\frac{dp}{dt} = \\frac{d(mv)}{dt} = m(t)\\frac{dv}{dt} + v(t)\\frac{dm}{dt} = m(t)a(t) + v(t)q\n$$\n其中 $a(t) = \\frac{dv}{dt}$ 是加速度，$\\frac{dm}{dt} = q$ 是恒定的质量流入速率。项 $v(t)q$ 代表了将流入的流体（假定其初始垂直速度为零）加速到水滴当前速度 $v(t)$ 所需的力。问题陈述指导我们使用一个常见的简化，即忽略这个“喷射动量”项。如果速度 $v(t)$ 很小，或者如果主动力学主要由其他力主导，这是一个合理的近似，通常情况下确实如此。在此简化下，牛顿第二定律简化为：\n$$\nm(t)a(t) \\approx F_{\\mathrm{ext}}\n$$\n作用在质量上的外力包括重力 ($F_g = m(t)g$)、线性弹簧的恢复力 ($F_s = -\\kappa x$) 和线性粘性阻尼力 ($F_d = -\\gamma v$)。弹簧常数为 $\\kappa$，阻尼系数为 $\\gamma$，$g$ 是重力加速度。位移 $x$ 从水龙头向下测量，因此重力为正。这些力的总和是：\n$$\nF_{\\mathrm{ext}} = m(t)g - \\kappa x - \\gamma v\n$$\n将此与动量变化率的简化表达式相等，得到水滴的运动方程：\n$$\nm(t)\\frac{dv}{dt} = m(t)g - \\kappa x - \\gamma v\n$$\n两边除以瞬时质量 $m(t)$ 得到加速度：\n$$\n\\frac{dv}{dt} = g - \\frac{\\gamma}{m(t)}v - \\frac{\\kappa}{m(t)}x\n$$\n这正是所提供的方程。该方程与定义 $\\frac{dx}{dt} = v$ 和 $\\frac{dm}{dt} = q$ 相结合，构成了一个包含三个耦合、一阶、非自治的常微分方程组。该系统是非自治的，因为加速度方程中 $v$ 和 $x$ 的系数通过质量 $m(t) = m(0) + qt$ 显式地依赖于时间。\n\n模拟通过积分该系统直到发生断裂事件来进行。断裂的条件是伸长量 $x(t)$ 达到一个依赖于质量的阈值 $x_{\\mathrm{break}}(m) = x_0 - \\beta m$。其物理直觉是，随着水滴变重，表面张力越来越无法支撑大的伸长。因此，事件函数为 $ G(t, x, m) = x(t) - x_{\\mathrm{break}}(m(t)) = 0$。我们关心的是 $x(t)$ 从下方穿过此阈值的事件，因此我们必须检测一个递增方向的零点穿越。\n\n在脱落时间 $t_d$，系统状态被重置。新的水滴以零位移和零速度开始，$x(t_d^+) = 0$ 和 $v(t_d^+) = 0$。这是一个简化，假设残余流体瞬间稳定到静止状态。至关重要的是，并非所有质量都脱落。在断裂时，水滴质量 $m(t_d^-)$ 的一部分 $\\alpha$ 仍附着在水龙头上：$m(t_d^+) = \\alpha m(t_d^-)$。这个残余质量 $m(t_d^+)$ 作为下一滴水滴的初始条件，并在连续的滴水事件之间提供了“记忆”。正是这种记忆，加上重置机制的非线性特性和质量流入的驱动力，使得系统能够展现出复杂的动力学行为。第 $n$ 滴水滴形成时的质量 $m_n(0)$ 取决于第 $(n-1)$ 滴水滴断裂时的质量 $m_{n-1}(t_{\\text{rupture}})$。这就创建了一个从一滴水到下一滴水的映射，在某些参数区间（例如流速 $q$），这个映射会经历倍周期级联，这是通向混沌的一个标志。对于低流速 $q$，系统会稳定到一个周期-1的极限环，其中每滴水都相同，滴水间隔时间恒定。当 $q$ 增加时，系统可能会分岔到一个周期-2的循环，其中滴水间隔时间（和水滴大小）在两个不同的值之间交替。进一步增加 $q$ 会导致周期-4、周期-8，并最终导致混沌行为，此时滴水间隔时间看起来是随机的。我们的任务是为给定的 $q$ 值计算这些不同滴水间隔时间的数量。\n\n算法如下：\n1.  定义ODE系统函数：$\\frac{dY}{dt} = F(t, Y)$，其中 $Y = [x, v, m]^T$。\n2.  为断裂条件 $x - (x_0 - \\beta m) = 0$ 定义一个事件函数。该函数必须是终止性的，并检测从负值到正值的穿越。\n3.  对于测试套件中的每个流速 $q$：\n    a. 初始化状态向量 $Y_0 = [0, 0, 0.40]^T$，当前时间 $t_{\\mathrm{current}} = 0$，以及一个用于存储滴水时间的列表 `drip_times`。\n    b. 循环 $N_{\\mathrm{total}} = 60$ 次以收集 $60$ 次滴水的数据。\n        i. 使用数值ODE求解器（例如`scipy.integrate.solve_ivp`）从 $t_{\\mathrm{current}}$ 和当前状态开始积分系统，直到触发断裂事件。\n        ii. 记录事件时间 $t_{\\mathrm{event}}$。将其添加到 `drip_times`。\n        iii. 根据重置规则更新状态向量：$x_{\\mathrm{new}} = 0$, $v_{\\mathrm{new}} = 0$, $m_{\\mathrm{new}} = \\alpha \\cdot m_{\\mathrm{event}}$，其中 $m_{\\mathrm{event}}$ 是断裂时的质量。新的当前时间为 $t_{\\mathrm{current}} = t_{\\mathrm{event}}$。\n    c. 计算滴水间隔时间 $\\Delta t_i = \\text{drip\\_times}[i] - \\text{drip\\_times}[i-1]$ 对于 $i=1, \\dots, N_{\\mathrm{total}}-1$。我们还需要第一个间隔 $\\text{drip\\_times}[0] - 0$。这样可以得到 $N_{\\mathrm{total}}$ 个间隔。\n    d. 舍弃前 $N_{\\mathrm{trans}} = 30$ 个间隔作为暂态动力学。\n    e. 分析后续的 $N_{\\mathrm{keep}} = 30$ 个间隔。要计算不同值的数量，对间隔进行排序并遍历排序后的列表，根据指定的容差将彼此接近的值分组计数：$|\\Delta t_i - \\Delta t_j| \\le \\max(\\varepsilon_{\\mathrm{abs}}, \\varepsilon_{\\mathrm{rel}}\\cdot \\max(|\\Delta t_i|,|\\Delta t_j|))$。一个简单的方法是，在排序后的列表中，计算一个元素与前一个元素存在显著差异的次数。\n    f. 将此计数记录为给定 $q$ 的结果。\n4.  按指定格式化最终的计数列表。\n这种稳健的、事件驱动的方法正确地模拟了物理过程，并能够准确地确定系统的周期性行为。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Numerically models a dripping faucet to observe period-doubling.\n\n    The model treats a growing water drop as a damped, driven harmonic oscillator\n    with variable mass. The system is described by a non-autonomous ODE with\n    state resets upon drop detachment. This function simulates the dynamics for\n    a set of flow rates and determines the periodicity of the drip intervals.\n    \"\"\"\n\n    # Define physical and numerical parameters as per the problem statement.\n    # Oscillator parameters\n    kappa = 1.0  # Spring constant\n    gamma = 0.05 # Damping coefficient\n    g = 0.34     # Gravitational acceleration\n\n    # Rupture and reset parameters\n    x0 = 0.50    # Rupture threshold constant\n    beta = 0.10  # Rupture threshold mass dependency\n    alpha = 0.30 # Residual mass fraction\n\n    # Initial conditions for the very first drop\n    x_init = 0.0\n    v_init = 0.0\n    m_init = 0.40\n\n    # Simulation control\n    N_total = 60  # Total number of drips to simulate per case\n    N_trans = 30  # Number of transient drips to discard\n    \n    # Tolerance for clustering inter-drip times\n    eps_abs = 1e-3\n    eps_rel = 1e-3\n    \n    # Test suite of flow rates\n    test_cases = [0.010, 0.025, 0.050, 0.080]\n\n    results = []\n\n    # ODE system definition: dy/dt = f(t, y)\n    # y = [x, v, m]\n    def ode_system(t, y, q_val):\n        x, v, m = y\n        # Avoid division by zero if mass is ever zero, though m_init > 0.\n        if m = 0:\n            return [0.0, 0.0, q_val]\n        \n        dxdt = v\n        dvdt = g - (gamma * v / m) - (kappa * x / m)\n        dmdt = q_val\n        return [dxdt, dvdt, dmdt]\n\n    # Event function: fires when x(t) = x_break(m(t))\n    # x_break(m) = x0 - beta * m\n    def rupture_event(t, y, q_val):\n        x, v, m = y\n        return x - (x0 - beta * m)\n    \n    rupture_event.terminal = True  # Stop integration at the event\n    rupture_event.direction = 1    # Event triggers when x is increasing\n\n    # Main loop over each flow rate\n    for q_flow in test_cases:\n        \n        # Initialize state for this test case\n        current_time = 0.0\n        y_current = np.array([x_init, v_init, m_init])\n        \n        drip_times = []\n\n        # Simulate N_total drips\n        for _ in range(N_total):\n            # Define a sufficiently long time span for the next drip\n            t_span = (current_time, current_time + 100.0)\n            \n            # Integrate until the next rupture event\n            sol = solve_ivp(\n                fun=lambda t, y: ode_system(t, y, q_flow),\n                t_span=t_span,\n                y0=y_current,\n                events=lambda t, y: rupture_event(t, y, q_flow),\n                dense_output=True,\n                max_step=0.1\n            )\n            \n            # Check if an event was found\n            if sol.t_events[0].size > 0:\n                event_time = sol.t_events[0][0]\n                drip_times.append(event_time)\n                \n                # State at the moment of rupture\n                y_event = sol.sol(event_time)\n                m_rupture = y_event[2]\n                \n                # Apply reset rules\n                current_time = event_time\n                y_current = np.array([0.0, 0.0, alpha * m_rupture])\n            else:\n                # Should not happen with given parameters and t_span\n                # Break if no drip is found in the time window\n                break\n\n        # Analyze the collected drip times\n        if len(drip_times)  N_total:\n             # If simulation failed, append an error code (e.g., -1)\n             results.append(-1)\n             continue\n        \n        # Calculate inter-drip times\n        all_times = np.insert(np.array(drip_times), 0, 0.0)\n        inter_drip_times = np.diff(all_times)\n\n        # Discard transients and keep the part for analysis\n        analysis_times = inter_drip_times[N_trans:]\n\n        if len(analysis_times) == 0:\n            results.append(0)\n            continue\n        \n        # Cluster the inter-drip times to count distinct values\n        sorted_times = np.sort(analysis_times)\n        \n        num_distinct_times = 1\n        # The first time interval starts the first cluster\n        cluster_representative = sorted_times[0]\n        \n        for i in range(1, len(sorted_times)):\n            dt_current = sorted_times[i]\n            dt_prev = sorted_times[i-1]\n            \n            # Check if current time is \"far\" from previous one using the tolerance rule\n            tolerance = max(eps_abs, eps_rel * max(abs(dt_current), abs(dt_prev)))\n            if abs(dt_current - dt_prev) > tolerance:\n                num_distinct_times += 1\n        \n        results.append(num_distinct_times)\n\n    # Print the final result in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}