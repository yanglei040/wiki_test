{
    "hands_on_practices": [
        {
            "introduction": "在深入研究复杂的数值算法之前，通过一个经典的物理问题来手工解决一个边值问题（BVP）是非常有益的。本练习将探讨悬索桥在均布水平荷载下的形状，这是一个源于静力学的典型例子。通过从物理第一性原理（静态平衡）出发推导出控制微分方程，并利用边界条件求解，本练习将加深您对边值问题基本构成（即控制方程和边界条件）的理解。",
            "id": "2377575",
            "problem": "一根完全柔性、无质量且不可伸长的缆索，承受集度为 $w$（每单位水平长度）的均布垂直荷载。缆索跨越位于 $x=-\\frac{L}{2}$ 和 $x=+\\frac{L}{2}$ 的两个等高支座。选择一个笛卡尔坐标系，其中水平轴为 $x$，竖直轴为 $y$，并将缆索的最低点作为原点 $(x,y)=(0,0)$。支座位于最低点上方 $y=H$ 的高度，因此缆索满足 $y\\left(\\pm \\frac{L}{2}\\right)=H$ 和 $y(0)=0$。\n\n请确定在此荷载下缆索的竖向轮廓 $y(x)$，并将其表示为仅包含 $x$、$L$ 和 $H$ 的单个闭式解析表达式。",
            "solution": "考虑缆索从最低点 $(0,0)$ 到任意点 $(x,y)$ 的一段。作用在其上的力有：位于原点的水平拉力 $T_0$、位于 $(x,y)$ 处的切向拉力 $T$，以及总的均布荷载 $W = wx$。\n根据静态平衡条件，水平和竖直方向的力必须平衡：\n$$ T \\cos\\theta = T_0 $$\n$$ T \\sin\\theta = wx $$\n其中 $\\theta$ 是缆索在点 $(x,y)$ 处的切线角。\n两式相除得到缆索的斜率：\n$$ \\frac{dy}{dx} = \\tan\\theta = \\frac{wx}{T_0} $$\n对该方程关于 $x$ 积分，我们得到：\n$$ y(x) = \\int \\frac{w}{T_0} x \\,dx = \\frac{w}{2T_0}x^2 + C $$\n利用边界条件 $y(0)=0$，我们发现积分常数 $C=0$。因此，缆索的形状为 $y(x) = \\frac{w}{2T_0}x^2$。\n现在，应用另一个边界条件 $y(\\frac{L}{2}) = H$：\n$$ H = \\frac{w}{2T_0}\\left(\\frac{L}{2}\\right)^2 = \\frac{wL^2}{8T_0} $$\n由此，我们可以解出系数项：$\\frac{w}{2T_0} = \\frac{8H}{L^2}$。\n将此系数代回 $y(x)$ 的表达式中，我们得到最终的缆索轮廓：\n$$ y(x) = \\frac{4H}{L^2}x^2 $$",
            "answer": "$$\n\\boxed{y(x) = \\frac{4H}{L^2}x^2}\n$$"
        },
        {
            "introduction": "许多重要的物理问题，特别是量子力学中的问题，最终都归结为无法解析求解的边值问题。本练习将带您进入计算物理学的核心领域，通过数值方法求解量子谐振子的定态薛定谔方程。您将学习并应用一种强大的技术——有限差分法，将微分方程转化为一个矩阵特征值问题，然后通过计算得到系统的能级。这项实践不仅能让您掌握一种核心的数值方法，还能通过将计算结果与精确解析解进行比较，来评估数值近似的准确性。",
            "id": "2377652",
            "problem": "考虑势为 $V(x) = \\tfrac{1}{2} m \\omega^{2} x^{2}$ 的量子谐振子的一维定态薛定谔边值问题：\n$$\n-\\frac{\\hbar^{2}}{2 m}\\,\\frac{d^{2}\\psi}{dx^{2}} + \\frac{1}{2} m \\omega^{2} x^{2}\\,\\psi(x) = E\\,\\psi(x),\n$$\n其束缚态条件为当 $x \\to \\pm \\infty$ 时 $\\psi(x) \\to 0$。为将其转化为有限区间上的计算边值问题，我们将域截断为 $x \\in [-L,L]$，并施加齐次狄利克雷边界条件 $\\psi(-L)=\\psi(L)=0$。在 $[-L,L]$ 上使用包含 $N$ 个内部点的均匀网格，通过对称二阶有限差分离散化二阶导数，并构建哈密顿算符的相应对称矩阵表示。然后，计算最低的 $K$ 个能量本征值，并将其与已知的精确谐振子能谱 $E_n^{(\\mathrm{exact})} = \\hbar \\omega \\left(n + \\tfrac{1}{2}\\right)$（其中 $n \\in \\{0,1,\\dots\\}$）进行比较。\n\n你的程序必须：\n- 从不含时薛定谔方程出发，并强制施加 $x=\\pm L$ 处的边界条件。\n- 使用包含 $N$ 个内部点的均匀网格和对称二阶有限差分来近似内部的二阶导数算符。\n- 将离散哈密顿矩阵组装为离散动能算符与在网格点上求值的对角势能算符之和。\n- 计算该矩阵的最低 $K$ 个本征值。\n- 对于每个测试用例，计算前 $K$ 个能级的最大绝对相对误差：\n$$\n\\varepsilon_{\\max} = \\max_{0 \\le n  K} \\left| \\frac{E_n^{(\\mathrm{num})} - E_n^{(\\mathrm{exact})}}{E_n^{(\\mathrm{exact})}} \\right|.\n$$\n所有误差都必须以无量纲十进制数的形式报告（最终报告的值不需要物理单位）。\n\n测试套件：\n- 案例 1：$(\\hbar, m, \\omega, L, N, K) = (1, 1, 1, 8, 300, 6)$\n- 案例 2：$(\\hbar, m, \\omega, L, N, K) = (1, 1, 1, 6, 60, 4)$\n- 案例 3：$(\\hbar, m, \\omega, L, N, K) = (1, 1, 2.3, 8, 300, 5)$\n- 案例 4：$(\\hbar, m, \\omega, L, N, K) = (1, 1, 1, 3, 300, 4)$\n\n注释和约束：\n- 你必须将 $N$ 视为内部网格点的数量（因此包括边界在内的总点数为 $N+2$），并在 $x=\\pm L$ 处使用齐次狄利克雷值。\n- 为保证数值稳定性，请使用双精度实数算術。\n- 不涉及角度；不需要角度单位。\n- 最终答案必须以无量纲数的形式报告。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，其顺序与测试用例相同。每个数字必须以包含六位有效数字的科学记数法打印。例如：$[1.23457\\mathrm{e}{-04},3.21000\\mathrm{e}{-03},\\dots]$。\n\n你的任务：实现上述要求，并按规定为四个测试用例生成单行输出。",
            "solution": "问题的核心是通过在有限域上求解不含时薛定谔方程来找到量子谐振子的离散谱。控制方程为：\n$$\n-\\frac{\\hbar^{2}}{2 m}\\,\\frac{d^{2}\\psi}{dx^{2}} + V(x)\\,\\psi(x) = E\\,\\psi(x)\n$$\n其中势为 $V(x) = \\frac{1}{2} m \\omega^{2} x^{2}$。在无限域 $x \\in (-\\infty, \\infty)$ 上的解析解给出了能量本征值 $E_n = \\hbar \\omega (n + \\frac{1}{2})$，其中 $n$ 为非负整数。对于数值计算，问题必须被限制在有限区间 $x \\in [-L, L]$ 上，并带有边界条件 $\\psi(-L) = \\psi(L) = 0$。\n\n第一步是离散化域。我们定义一个包含 $N$ 个内部点的均匀网格。包括边界在内的总网格点数为 $N+2$。区间长度为 $2L$，它被划分为 $N+1$ 个子区间。因此，网格间距或步长为：\n$$\n\\Delta x = \\frac{L - (-L)}{N+1} = \\frac{2L}{N+1}\n$$\n网格点为 $x_i = -L + i \\cdot \\Delta x$，其中 $i \\in \\{0, 1, \\dots, N+1\\}$。波函数 $\\psi(x)$ 由其在这些点上的值 $\\psi_i = \\psi(x_i)$ 表示。问题关注的是 $N$ 个内部点 $x_1, \\dots, x_N$，在这些点上波函数是未知的。边界条件规定了 $\\psi_0 = \\psi(-L) = 0$ 和 $\\psi_{N+1} = \\psi(L) = 0$。\n\n通过离散化算符，连续薛定谔方程被转换为矩阵本征值问题。在每个内部网格点 $x_i$ 处，二阶导数算符使用对称二阶有限差分公式进行近似：\n$$\n\\left. \\frac{d^2\\psi}{dx^2} \\right|_{x_i} \\approx \\frac{\\psi(x_{i-1}) - 2\\psi(x_i) + \\psi(x_{i+1})}{(\\Delta x)^2} = \\frac{\\psi_{i-1} - 2\\psi_i + \\psi_{i+1}}{(\\Delta x)^2}\n$$\n将此代入内部点 $x_i$ 的薛定谔方程中，得到：\n$$\n-\\frac{\\hbar^2}{2m} \\left( \\frac{\\psi_{i-1} - 2\\psi_i + \\psi_{i+1}}{(\\Delta x)^2} \\right) + V(x_i)\\psi_i = E \\psi_i\n$$\n这组关于未知值 $\\psi_1, \\dots, \\psi_N$ 的 $N$ 个线性方程组可以写成矩阵形式 $\\mathbf{H}\\vec{\\psi} = E\\vec{\\psi}$，其中 $\\vec{\\psi} = [\\psi_1, \\dots, \\psi_N]^T$ 是内部点上波函数值的向量，而 $\\mathbf{H}$ 是 $N \\times N$ 的离散哈密顿矩阵。\n\n哈密顿矩阵 $\\mathbf{H}$ 是动能矩阵 $\\mathbf{T}$ 和势能矩阵 $\\mathbf{V}$ 的和。\n\n势能算符变成一个对角矩阵 $\\mathbf{V}$，其元素对应于在每个内部网格点上求得的势：\n$$\nV_{ij} = \\delta_{ij} V(x_i) = \\delta_{ij} \\left( \\frac{1}{2} m \\omega^2 x_i^2 \\right)\n$$\n\n动能算符产生一个三对角矩阵 $\\mathbf{T}$。其元素由有限差分公式导出：\n$$\n\\mathbf{T}_{ij} =\n\\begin{cases}\n\\frac{\\hbar^2}{m(\\Delta x)^2}  \\text{如果 } i=j \\\\\n-\\frac{\\hbar^2}{2m(\\Delta x)^2} \\text{如果 } |i-j|=1 \\\\\n0 \\text{否则}\n\\end{cases}\n$$\n边界条件 $\\psi_0=0$ 和 $\\psi_{N+1}=0$ 被直接并入第一个（$i=1$）和最后一个（$i=N$）内部点的方程中，从而确保了三对角结构的维持。\n\n因此，完整的哈密顿矩阵 $\\mathbf{H} = \\mathbf{T} + \\mathbf{V}$ 是一个实对称三对角矩阵，其元素为：\n$$\nH_{ij} =\n\\begin{cases}\n\\frac{\\hbar^2}{m(\\Delta x)^2} + \\frac{1}{2} m \\omega^2 x_i^2 \\text{如果 } i=j \\\\\n-\\frac{\\hbar^2}{2m(\\Delta x)^2} \\text{如果 } |i-j|=1 \\\\\n0 \\text{否则}\n\\end{cases}\n$$\n问题简化为求解该矩阵 $\\mathbf{H}$ 的本征值。由于 $\\mathbf{H}$ 是对称且三对角的，其本征值可以非常高效地计算出来。$\\mathbf{H}$ 的最低 $K$ 个本征值对应于该量子系统前 $K$ 个能级的数值估计，$E_n^{(\\mathrm{num})}$（其中 $n \\in \\{0, 1, \\dots, K-1\\}$）。\n\n最后，将这些数值本征值与精确解析本征值 $E_n^{(\\mathrm{exact})} = \\hbar \\omega (n + \\frac{1}{2})$ 进行比较。数值近似的质量由最低 $K$ 个态的最大绝对相对误差来量化：\n$$\n\\varepsilon_{\\max} = \\max_{0 \\le n  K} \\left| \\frac{E_n^{(\\mathrm{num})} - E_n^{(\\mathrm{exact})}}{E_n^{(\\mathrm{exact})}} \\right|\n$$\n实现将使用 `scipy.linalg.eigh_tridiagonal` 函数，该函数专门为寻找对称三对角矩阵的本征值而优化。我们将为每个测试用例请求最低的 $K$ 个本征值，计算精确值，然后计算 $\\varepsilon_{\\max}$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh_tridiagonal\n\ndef solve():\n    \"\"\"\n    Solves the stationary Schrödinger boundary value problem for the quantum\n    harmonic oscillator using a finite difference method.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (hbar, m, omega, L, N, K)\n    test_cases = [\n        (1.0, 1.0, 1.0, 8.0, 300, 6),\n        (1.0, 1.0, 1.0, 6.0, 60, 4),\n        (1.0, 1.0, 2.3, 8.0, 300, 5),\n        (1.0, 1.0, 1.0, 3.0, 300, 4),\n    ]\n\n    results = []\n    for case in test_cases:\n        hbar, m, omega, L, N, K = case\n\n        # 1. Discretize the spatial domain [-L, L] with N interior points.\n        # The total number of intervals is N+1.\n        delta_x = 2.0 * L / (N + 1)\n        \n        # Grid of N interior points x_i for i=1, ..., N.\n        # The numpy array will be 0-indexed, corresponding to i=1...N.\n        x_interior = np.linspace(-L + delta_x, L - delta_x, N)\n\n        # 2. Construct the discrete Hamiltonian matrix H as a tridiagonal matrix.\n        # H is the sum of the kinetic matrix T and potential matrix V.\n\n        # The potential energy V(x) = 0.5 * m * omega^2 * x^2 evaluated\n        # at the interior grid points gives the diagonal of V.\n        potential_diagonal = 0.5 * m * (omega**2) * (x_interior**2)\n\n        # The finite difference approximation of the kinetic energy operator\n        # gives the diagonal and off-diagonal elements of T.\n        # T_ii = hbar^2 / (m * delta_x^2)\n        # T_{i, i-1} = T_{i, i+1} = -hbar^2 / (2 * m * delta_x^2)\n        kinetic_diag_term = hbar**2 / (m * delta_x**2)\n        kinetic_off_diag_term = -hbar**2 / (2.0 * m * delta_x**2)\n\n        # The main diagonal of H is the sum of the diagonals of T and V.\n        main_diagonal = kinetic_diag_term + potential_diagonal\n        \n        # The off-diagonal of H is the same as the off-diagonal of T.\n        off_diagonal = np.full(N - 1, kinetic_off_diag_term)\n\n        # 3. Solve the eigenvalue problem for the lowest K eigenvalues.\n        # eigh_tridiagonal is highly efficient for symmetric tridiagonal matrices.\n        # 'select=\"i\"' and 'select_range=(0, K-1)' computes the K smallest\n        # eigenvalues (indices 0 to K-1). Eigenvalues are returned in ascending order.\n        eigenvalues_numerical = eigh_tridiagonal(\n            main_diagonal, \n            off_diagonal, \n            select='i', \n            select_range=(0, K - 1), \n            eigvals_only=True\n        )\n\n        # 4. Calculate the corresponding exact eigenvalues for comparison.\n        # E_n = hbar * omega * (n + 0.5) for n = 0, 1, ..., K-1.\n        n_levels = np.arange(K)\n        eigenvalues_exact = hbar * omega * (n_levels + 0.5)\n\n        # 5. Compute the maximum absolute relative error over the K levels.\n        relative_errors = np.abs((eigenvalues_numerical - eigenvalues_exact) / eigenvalues_exact)\n        max_relative_error = np.max(relative_errors)\n        \n        results.append(max_relative_error)\n\n    # Final print statement in the exact required format.\n    # Format each number in scientific notation with 6 significant digits (1 before, 5 after decimal).\n    formatted_results = [f\"{res:.5e}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "与线性边值问题通常具有唯一解不同，非线性边值问题常常展现出更复杂的行为，例如可能存在多个解。本练习通过一个非线性方程 $y''(x) + y(x)^3 = 0$ 来揭示这种非唯一性，并介绍一种直观且强大的数值技术——打靶法。打靶法将边值问题巧妙地转化为一个初值问题，并通过迭代调整初始条件（“发射角度”），直到解的轨迹“击中”远端的边界目标。在这个练习中，您将通过寻找两个不同的初始斜率 $s=y'(0)$，它们都能满足相同的终端边界条件 $y(L)=0$，从而亲手揭示非线性世界的多解现象。",
            "id": "2377656",
            "problem": "考虑一个有限区间上的常微分方程非线性边值问题：寻找一个满足以下条件的函数 $y(x)$\n$$\ny''(x) + y(x)^3 = 0 \\quad \\text{for } x \\in [0,L], \\quad \\text{with} \\quad y(0)=0, \\; y(L)=0,\n$$\n其中 $L0$ 是一个给定的长度。该问题是一个单位质量粒子在四次势 $V(y)=\\tfrac{1}{4}y^4$ 中运动的模型，其中 $x$ 扮演时间的角色。请根据经典力学和常微分方程的第一性原理，完成以下任务。\n\n1) 从牛顿第二定律和单位质量的机械能定义出发，利用势能 $V(y)=\\tfrac{1}{4}y^4$ 证明，对于初始条件为 $y(0)=0$ 和 $y'(0)=s$ 的初值问题，其能量\n$$\nE = \\tfrac{1}{2}\\,[y'(x)]^2 + \\tfrac{1}{4}\\, [y(x)]^4,\n$$\n是守恒的，并且对于 $s0$，解 $y(x)$ 是关于 $x$ 的周期函数，并在由能量决定的对称转折点 $\\pm A$ 之间振荡。然后，仅使用这些基本事实（不引用任何预先推导的周期公式），定性地论证为何对于一个固定的 $L$，该边值问题可以有多个不同的解：初始斜率 $s$ 的不同选择可以产生不同的轨迹，使得一个或多个半振荡恰好落在区间 $[0,L]$ 内，并且都满足相同的最终边界条件 $y(L)=0$。\n\n2) 实现一个打靶法，以数值方式揭示这种非唯一性。将初始斜率 $s=y'(0)$ 视为可调节的打靶参数，并定义残差\n$$\nR(s;L) := y(L;s),\n$$\n其中 $y(x;s)$ 是初值问题在 $y(0)=0$ 和 $y'(0)=s$ 条件下的解。对与二阶方程等价的一阶系统使用一个数值稳定的常微分方程积分器，并使用一个稳健的基于区间的一维求根器来定位 $R(s;L)=0$ 的不同正根。具体要求如下：\n- 将二阶方程转换为一阶系统 $y_1' = y_2$, $y_2' = -y_1^3$，初始条件为 $y_1(0)=0$ 和 $y_2(0)=s$。\n- 对于每个给定的 $L$，计算两个最小的不同正打靶值 $s_1(L)$ 和 $s_2(L)$，满足 $s_2(L)  s_1(L)  0$，使得 $|R(s_k;L)| \\le \\varepsilon$，其中容差 $\\varepsilon = 10^{-8}$。\n- 不考虑平凡解 $s=0$。\n\n3) 测试套件。在以下三组定义域长度上运行您的程序：\n- $L_1 = 1.00$，\n- $L_2 = 1.20$，\n- $L_3 = 0.75$。\n对于每个 $L_i$，返回列表 $[s_1(L_i), s_2(L_i)]$，四舍五入到 $6$ 位小数。您的最终程序输出必须是单行，包含一个按 $L_1, L_2, L_3$ 顺序排列、用逗号分隔并包含在方括号内的列表，例如：\n$[[s_1(L_1),s_2(L_1)],[s_1(L_2),s_2(L_2)],[s_1(L_3),s_2(L_3)]]$。\n所有数字必须以十进制表示法书写。不应打印任何额外文本。\n\n附加实现要求：\n- 使用标准的自适应步长常微分方程求解器，绝对和相对容差不高于 $10^{-9}$。\n- 使用区间求根方法，对 $s$ 的解的绝对容差不高于 $10^{-10}$。\n- 通过在足够大的 $s$ 区间内进行符号变化扫描，确保为每个 $L_i$ 分离出至少两个不同的正根，以保证稳健性。",
            "solution": "解法分为两部分：首先，基于第一性原理的理论论证；其次，为解决该问题而设计的数值打靶法的描述。\n\n**1. 理论论证与定性分析**\n\n该问题涉及一个单位质量（$m=1$）的粒子，在源于势能函数 $V(y)$ 的力 $F(y)$ 作用下的运动。牛顿第二定律指出 $ma = F$，其中加速度为 $a = y''(x)$，$x$ 代表时间。该力是保守的，由 $F(y) = -V'(y)$ 给出。对于给定的势能 $V(y) = \\frac{1}{4}y^4$，相应的力为 $F(y) = -\\frac{d}{dy}(\\frac{1}{4}y^4) = -y^3$。将这些代入 $m=1$ 的牛顿定律，可得：\n$$\n(1) y''(x) = -y(x)^3\n$$\n整理后即为指定的常微分方程（ODE）：\n$$\ny''(x) + y(x)^3 = 0.\n$$\n这证实了控制方程的物理来源。\n\n为了证明机械能守恒，我们将该常微分方程两边同乘以速度 $y'(x)$：\n$$\ny''(x) y'(x) + y(x)^3 y'(x) = 0.\n$$\n这个表达式等价于能量对时间的全导数。注意到 $y'' y' = \\frac{d}{dx}(\\frac{1}{2}[y'(x)]^2)$ 和 $y^3 y' = \\frac{d}{dx}(\\frac{1}{4}[y(x)]^4)$，我们有：\n$$\n\\frac{d}{dx} \\left( \\frac{1}{2}[y'(x)]^2 + \\frac{1}{4}[y(x)]^4 \\right) = 0.\n$$\n这意味着括号内的量，即总机械能 $E$，是一个运动常量：\n$$\nE = \\frac{1}{2}[y'(x)]^2 + \\frac{1}{4}[y(x)]^4 = \\text{constant}.\n$$\n能量 $E$ 由初始条件确定。对于初值问题（IVP），其初始条件为 $y(0)=0$ 和 $y'(0)=s$，能量为：\n$$\nE = \\frac{1}{2}[y'(0)]^2 + \\frac{1}{4}[y(0)]^4 = \\frac{1}{2}s^2 + \\frac{1}{4}(0)^4 = \\frac{1}{2}s^2.\n$$\n对于任意 $s  0$，能量 $E  0$。粒子的运动受势能限制。振荡的转折点（记为 $\\pm A$）发生在速度 $y'(x)$ 为零的地方。在这些点，动能为零，所有能量都是势能：$E = V(A) = \\frac{1}{4}A^4$。令两种能量表达式相等，可得：\n$$\n\\frac{1}{2}s^2 = \\frac{1}{4}A^4 \\implies A = (2s^2)^{1/4}.\n$$\n粒子从 $y(0)=0$ 处以正速度 $s$ 开始运动，朝正转折点 $+A$ 移动，然后反向，以速度 $-s$ 通过 $y=0$，到达负转折点 $-A$，再返回到 $y=0$。这个循环构成了一个周期性运动。\n\n边值问题（BVP）解的非唯一性源于初值问题（IVP）解的周期性。边界条件 $y(L)=0$ 要求粒子在时间 $x=L$ 时位于原点。从 $y(0)=0$ 出发，粒子在经过一个半周期、两个半周期（一个完整周期）、三个半周期等等之后，会再次到达 $y=0$。设 $T_{1/2}(s)$ 表示对应于初始斜率 $s$ 的振荡的半周期。如果区间长度 $L$ 是半周期的整数倍，则边界条件 $y(L)=0$ 得到满足：\n$$\nL = k \\cdot T_{1/2}(s) \\quad \\text{for } k = 1, 2, 3, \\dots\n$$\n这个非谐振子的周期取决于其能量，因此也取决于 $s$。通过改变 $s$，我们可以改变周期。对于一个固定的长度 $L$，上述方程变成一个关于 $s$ 的隐式方程。这个方程很可能对不同的 $s$ 值有解，每个解对应一个不同的整数 $k$。对于 $k=1$，我们寻找一个初始斜率 $s_1$，使得粒子在区间 $[0, L]$ 内恰好完成其第一个半振荡。这会产生基解，一个单拱形。对于 $k=2$，我们寻找另一个不同的斜率 $s_2$，使得粒子在 $[0, L]$ 内完成两个半振荡（一个全波）。这些不同的值 $s_1, s_2, \\dots$ 都产生满足两个边界条件 $y(0)=0$ 和 $y(L)=0$ 的解 $y(x; s_k)$，从而解释了 BVP 存在多个非平凡解的原因。\n\n**2. 数值设计：打靶法**\n\n为了数值化地找到这些不同的初始斜率，我们采用打靶法。该方法将边值问题（BVP）重新构造为一个求根问题。\n\n打靶参数是未知的初始斜率 $s = y'(0)$。\n初值问题（IVP）定义如下：\n$$\ny''(x) + y(x)^3 = 0, \\quad y(0)=0, \\quad y'(0)=s.\n$$\n为了数值求解，我们将二阶常微分方程转换为一个等价的一阶系统。设 $y_1(x) = y(x)$ 和 $y_2(x) = y'(x)$。该系统为：\n$$\n\\begin{cases}\ny_1'(x) = y_2(x) \\\\\ny_2'(x) = -y_1(x)^3\n\\end{cases}\n$$\n在 $x=0$ 处的初始条件为：\n$$\n\\begin{pmatrix} y_1(0) \\\\ y_2(0) \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ s \\end{pmatrix}.\n$$\n我们将该系统从 $x=0$ 积分到 $x=L$。在 $x=L$ 处的解（我们记为 $y(L;s)$）取决于 $s$ 的选择。第二个边界条件 $y(L)=0$（或 $y_1(L)=0$）仅对特定的 $s$ 值成立。我们定义一个残差函数 $R(s;L)$，它衡量在最终边界上的失配程度：\n$$\nR(s;L) = y_1(L;s).\n$$\n问题现在转化为寻找方程 $R(s;L) = 0$ 的根。\n\n数值步骤如下：\n1.  **定义残差函数**：创建一个函数，对于给定的 $s$ 和 $L$，使用一个高精度的自适应步长 ODE 积分器（例如 `scipy.integrate.solve_ivp`，其绝对和相对容差设为 $10^{-10}$）从 $x=0$到 $x=L$ 对 IVP 进行数值求解。该函数返回 $y_1(L)$ 的值。\n2.  **为根划定区间**：如前定性分析所述，残差 $R(s;L)$ 将是 $s$ 的一个振荡函数。为了找到它的根，我们首先需要将它们隔离在不同的区间内。我们通过在一系列 $s$ 值的网格上评估 $R(s;L)$，并找出相邻点对 $(s_a, s_b)$，使得 $R(s_a;L)$ 和 $R(s_b;L)$ 的符号相反，来实现这一点。每个这样的区间 $[s_a, s_b]$ 都保证包含至少一个根。\n3.  **求解根**：对于找到的每个区间 $[s_a, s_b]$，使用一个稳健的一维区间求根器（例如 Brent's method，`scipy.optimize.brentq`）以高精度（对 $s$ 的容差设为 $10^{-11}$）定位根 $s_k$。\n4.  **收集并报告**：我们对每个给定的长度 $L_i$ 应用此过程，以找到两个最小的不同正根 $s_{1}(L_i)$ 和 $s_{2}(L_i)$，将它们四舍五入到指定的精度，并按要求格式化输出。平凡解 $s=0$被明确排除。\n\n这种高保真度 ODE 求解器和可靠求根算法的组合，为确定非线性 BVP 的非唯一解提供了一种稳健而准确的方法。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Solves the nonlinear BVP y'' + y^3 = 0 with y(0)=0, y(L)=0\n    using a shooting method to find the first two non-trivial positive\n    initial slopes s = y'(0) for given lengths L.\n    \"\"\"\n\n    # --- 1. Define the core components of the shooting method ---\n\n    # ODE system: y' = f(x, y), where y = [y_1, y_2] = [y, y']\n    def ode_system(t, y):\n        \"\"\"First-order system for y'' = -y^3\"\"\"\n        return [y[1], -y[0]**3]\n\n    # Residual function R(s; L) = y(L; s)\n    def residual(s, L):\n        \"\"\"\n        Computes the residual R(s;L) = y(L;s) by solving the IVP.\n\n        Args:\n            s (float): The initial slope y'(0), our shooting parameter.\n            L (float): The length of the interval [0, L].\n\n        Returns:\n            float: The value of y(L), which we want to be zero.\n        \"\"\"\n        if s == 0:\n            return 0.0 # Trivial solution y(x)=0 for all x\n\n        # Initial conditions for the IVP: y(0)=0, y'(0)=s\n        y0 = [0.0, s]\n        \n        # Integration interval\n        t_span = [0, L]\n        \n        # High-precision ODE solver settings\n        atol = 1e-10\n        rtol = 1e-10\n\n        # Solve the initial value problem\n        sol = solve_ivp(\n            fun=ode_system,\n            t_span=t_span,\n            y0=y0,\n            method='DOP853',\n            atol=atol,\n            rtol=rtol,\n        )\n        \n        # Return the final value of y(x), which is y_1(L)\n        # sol.y is a 2xN array. We need the first component at the last time step.\n        return sol.y[0, -1]\n\n    # --- 2. Implement the root-finding logic ---\n\n    def find_shooting_values(L, num_roots=2):\n        \"\"\"\n        Finds the first `num_roots` positive values of s for a given L.\n        \"\"\"\n        roots = []\n        \n        # Scan for sign changes to find brackets for the roots.\n        # The required s values increase as L decreases. The scan range\n        # must be large enough to find the required number of roots.\n        s_scan_points = np.linspace(0.1, 100.0, 500)\n        r_values = np.array([residual(s, L) for s in s_scan_points])\n        \n        # Find intervals where the sign of the residual changes\n        for i in range(len(s_scan_points) - 1):\n            if np.sign(r_values[i]) != np.sign(r_values[i+1]):\n                s_a, s_b = s_scan_points[i], s_scan_points[i+1]\n                \n                try:\n                    # Use a robust bracketing root-finder\n                    root = brentq(\n                        residual, \n                        a=s_a, \n                        b=s_b, \n                        args=(L,), \n                        xtol=1e-11 # Tolerance on the root s\n                    )\n                    roots.append(root)\n                    \n                    if len(roots) == num_roots:\n                        break\n                except ValueError:\n                    # brentq can fail if signs are not opposite, though our check prevents this.\n                    continue\n        \n        if len(roots)  num_roots:\n            raise RuntimeError(f\"Could not find {num_roots} roots for L={L}. Try increasing the scan range for s.\")\n        \n        return sorted(roots)\n\n    # --- 3. Execute for the test suite ---\n\n    # Define the test cases from the problem statement.\n    test_cases = [1.00, 1.20, 0.75]\n    \n    all_results = []\n    \n    for L_val in test_cases:\n        # Find the two smallest positive shooting values\n        s1, s2 = find_shooting_values(L_val, num_roots=2)\n        \n        # Round to 6 decimal places as required\n        result_pair = [round(s1, 6), round(s2, 6)]\n        all_results.append(result_pair)\n    \n    # Format the final output string exactly as specified\n    # e.g., [[val1,val2],[val3,val4]]\n    output_str = \"[\" + \",\".join([str(pair) for pair in all_results]) + \"]\"\n    \n    # Final print statement in the exact required format.\n    print(output_str.replace(\" \", \"\"))\n\nsolve()\n```"
        }
    ]
}