{
    "hands_on_practices": [
        {
            "introduction": "在选择数值积分方法时，其准确性是一个核心考量。一个方法的“收敛阶”描述了其全局误差如何随着步长 $h$ 的减小而减小。本练习  将指导你通过一个具体的计算实验，来验证广受欢迎的四阶龙格-库塔（RK4）方法的理论性质。你将通过编程计算不同步长下的误差，并最终从数据中确定该方法的实际收敛阶，从而深入理解数值精度的实际意义。",
            "id": "2420941",
            "problem": "考虑一个长度为 $L$ 的非线性单摆，它处于大小为 $g$ 的均匀引力场中，其运动由二阶常微分方程 $ \\dfrac{\\mathrm{d}^2 \\theta}{\\mathrm{d} t^2} + \\dfrac{g}{L} \\sin(\\theta) = 0 $ 描述，其中 $\\theta(t)$ 是以弧度为单位的角位移， $t$ 是以秒为单位的时间。定义状态向量 $ \\mathbf{y}(t) = \\begin{bmatrix} \\theta(t) \\\\ \\omega(t) \\end{bmatrix} $，其中 $ \\omega(t) = \\dfrac{\\mathrm{d} \\theta}{\\mathrm{d} t} $。这得到了一个一阶系统 $ \\dfrac{\\mathrm{d}}{\\mathrm{d} t} \\mathbf{y}(t) = \\begin{bmatrix} \\omega(t) \\\\ -\\dfrac{g}{L} \\sin(\\theta(t)) \\end{bmatrix} $，给定初始条件为 $ \\mathbf{y}(0) = \\begin{bmatrix} \\theta_0 \\\\ \\omega_0 \\end{bmatrix} $。角度必须以弧度为单位，时间以秒为单位。\n\n对于固定的总模拟时间 $T$，设 $N$ 是一个正整数，$h = T / N$ 是均匀的时间步长。设 $ \\Phi_h^N(\\mathbf{y}_0) $ 表示从 $ \\mathbf{y}_0 $ 开始，使用步长为 $h$ 的显式经典四阶单步法计算 $N$ 步后在时间 $T$ 得到的数值状态。该方法定义为，从 $(t_n, \\mathbf{y}_n)$ 到 $(t_{n+1}, \\mathbf{y}_{n+1})$ 的每一步，其中 $t_{n+1} = t_n + h$，\n$$\n\\begin{aligned}\n\\mathbf{k}_1 = \\mathbf{f}(t_n, \\mathbf{y}_n), \\\\\n\\mathbf{k}_2 = \\mathbf{f}\\!\\left(t_n + \\tfrac{h}{2}, \\mathbf{y}_n + \\tfrac{h}{2}\\mathbf{k}_1\\right), \\\\\n\\mathbf{k}_3 = \\mathbf{f}\\!\\left(t_n + \\tfrac{h}{2}, \\mathbf{y}_n + \\tfrac{h}{2}\\mathbf{k}_2\\right), \\\\\n\\mathbf{k}_4 = \\mathbf{f}\\!\\left(t_n + h, \\mathbf{y}_n + h\\,\\mathbf{k}_3\\right), \\\\\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\tfrac{h}{6}\\left(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4\\right),\n\\end{aligned}\n$$\n其中 $ \\mathbf{f}(t,\\mathbf{y}) = \\begin{bmatrix} \\omega \\\\ -\\dfrac{g}{L}\\sin(\\theta) \\end{bmatrix} $。\n\n定义步长为 $h$ 时的最终状态误差为\n$$\nE(h) = \\left\\| \\Phi_h^N(\\mathbf{y}_0) - \\Phi_{h_{\\mathrm{ref}}}^{N_{\\mathrm{ref}}}(\\mathbf{y}_0) \\right\\|_2,\n$$\n其中 $h_{\\mathrm{ref}} = T / N_{\\mathrm{ref}}$，$N_{\\mathrm{ref}}$ 是一个足够大的正整数，使得 $ \\Phi_{h_{\\mathrm{ref}}}^{N_{\\mathrm{ref}}}(\\mathbf{y}_0) $ 可作为时间 $T$ 时的参考解。欧几里得范数 $ \\| \\cdot \\|_2 $ 是在 $ \\mathbb{R}^2 $ 中计算的。\n\n对于一个固定的问题实例，将观测到的全局误差阶 $p$ 定义为映射 $ \\log(h) \\mapsto \\log(E(h)) $ 的最小二乘最佳拟合直线的斜率，该映射是根据对应于 $ N \\in \\{ 64, 128, 256, 512, 1024 \\} $ 的有限步长集合计算得出的。\n\n您的任务是编写一个完整的、可运行的程序，对以下每个测试用例，计算如上定义的观测全局误差阶 $p$。使用 $ g = 9.81 \\,\\mathrm{m/s^2} $，并用弧度表示角度，用弧度/秒表示角速度。每个测试用例的参考离散化必须使用 $ N_{\\mathrm{ref}} = 65536 $。\n\n测试套件（所有角度单位为弧度，时间单位为秒，长度单位为米，角速度单位为弧度/秒）：\n- 测试 A：$L = 1.0$，$\\theta_0 = 0.3$，$\\omega_0 = 0.0$， $T = 10.0$。\n- 测试 B：$L = 1.0$，$\\theta_0 = 2.5$，$\\omega_0 = 0.0$， $T = 10.0$。\n- 测试 C：$L = 2.0$，$\\theta_0 = 1.0$，$\\omega_0 = 1.0$， $T = 20.0$。\n- 测试 D：$L = 1.0$，$\\theta_0 = 1.2$，$\\omega_0 = 0.0$， $T = 40.0$。\n\n您的程序必须产生单行输出，其中包含四个结果，按测试 A、B、C、D 的顺序排列，以逗号分隔并用方括号括起来，每个值四舍五入到小数点后两位（无单位），例如，“[4.00,4.01,3.99,3.98]”。",
            "solution": "所述问题是有效的。它在科学上基于经典力学和数值分析，提法得当，提供了所有必要的条件和参数，并以客观明确的语言表述。不存在矛盾、信息缺失或逻辑缺陷。因此，我们可以着手求解。\n\n该问题要求计算经典的四阶Runge-Kutta (RK4)方法应用于非线性摆方程时的观测实验收敛阶 $p$。控制方程是一个二阶常微分方程 (ODE)：\n$$\n\\frac{\\mathrm{d}^2 \\theta}{\\mathrm{d} t^2} + \\frac{g}{L} \\sin(\\theta) = 0\n$$\n通过定义状态向量 $\\mathbf{y}(t) = [\\theta(t), \\omega(t)]^T$，其中 $\\omega(t) = \\frac{\\mathrm{d}\\theta}{\\mathrm{d}t}$ 是角速度，该方程可转换为一个包含两个一阶常微分方程的系统。该系统为：\n$$\n\\frac{\\mathrm{d}\\mathbf{y}}{\\mathrm{d}t} = \\mathbf{f}(\\mathbf{y}) = \\begin{bmatrix} \\omega \\\\ -\\frac{g}{L}\\sin(\\theta) \\end{bmatrix}\n$$\n这构成了一个初值问题 (IVP)，其初始条件为 $\\mathbf{y}(0) = [\\theta_0, \\omega_0]^T$。函数 $\\mathbf{f}$ 是自治的，意味着它不显式地依赖于时间 $t$。\n\n数值方法的收敛阶表征了当步长 $h$ 减小时全局误差减小的速率。对于一个 $p$ 阶方法，在固定的最终时间 $T$，全局误差 $E(h)$ 预期会根据关系式 $E(h) \\propto h^p$ 进行缩放。问题将误差 $E(h)$ 定义为数值解 $\\Phi_h^N(\\mathbf{y}_0)$ 与高精度参考解 $\\Phi_{h_{\\mathrm{ref}}}^{N_{\\mathrm{ref}}}(\\mathbf{y}_0)$之差的欧几里得范数：\n$$\nE(h) = \\left\\| \\Phi_h^N(\\mathbf{y}_0) - \\Phi_{h_{\\mathrm{ref}}}^{N_{\\mathrm{ref}}}(\\mathbf{y}_0) \\right\\|_2\n$$\n为了从数值数据中确定阶数 $p$，我们可以对误差关系式取对数：\n$$\n\\log(E(h)) \\approx p \\log(h) + C'\n$$\n其中 $C'$ 是一个常数。这个方程揭示了 $\\log(E(h))$ 和 $\\log(h)$ 之间的线性关系，其斜率即为收敛阶 $p$。问题指定 $p$ 应计算为对预设步长集生成的数据点 $(\\log(h), \\log(E(h)))$ 进行最小二乘最佳拟合所得直线的斜率。经典的Runge-Kutta方法是已知的四阶方法，因此我们预计计算出的 $p$ 值将非常接近于 $4$。\n\n解决每个测试用例的计算步骤如下：\n\n1.  **定义系统参数**：对每个测试用例，指定参数 $L$、$\\theta_0$、$\\omega_0$ 和 $T$。重力加速度固定为 $g = 9.81 \\, \\mathrm{m/s^2}$。初始状态向量为 $\\mathbf{y}_0 = [\\theta_0, \\omega_0]^T$。\n\n2.  **实现 RK4 积分器**：将创建一个函数来实现问题陈述中定义的单步 RK4 格式。该函数将在一个时间步长 $h$ 内将状态向量 $\\mathbf{y}_n$推进到 $\\mathbf{y}_{n+1}$。另一个函数将通过重复应用单步函数 $N = T/h$ 次来协调整个区间 $[0, T]$ 上的积分。\n\n3.  **计算参考解**：对每个测试用例，在最终时间 $T$ 计算一个高精度的参考解 $\\mathbf{y}_{\\mathrm{ref}} = \\Phi_{h_{\\mathrm{ref}}}^{N_{\\mathrm{ref}}}(\\mathbf{y}_0)$。问题指定了大量的步数 $N_{\\mathrm{ref}} = 65536$，以确保该解是一个可靠的基准。\n\n4.  **计算近似解和误差**：对于步数集合 $N \\in \\{ 64, 128, 256, 512, 1024 \\}$，确定相应的步长 $h = T/N$。对每个 $N$，计算数值解 $\\mathbf{y}_N = \\Phi_h^N(\\mathbf{y}_0)$。然后计算误差 $E(h) = \\| \\mathbf{y}_N - \\mathbf{y}_{\\mathrm{ref}} \\|_2$，并与其对应的步长 $h$ 一起存储。\n\n5.  **确定收敛阶**：利用这组配对 $(h, E(h))$，我们计算出相应的对数配对 $(\\log(h), \\log(E(h)))$。对这些对数数据点进行线性最小二乘回归。所得最佳拟合线的斜率即为观测到的收敛阶 $p$。\n\n对所有四个提供的测试用例（测试 A、B、C、D）重复此完整过程。收集最终的 $p$ 值结果，四舍五入到小数点后两位，并格式化为所需的输出字符串。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the observed global error order for the RK4 method applied\n    to the nonlinear pendulum problem for a suite of test cases.\n    \"\"\"\n    # Define gravitational constant\n    g = 9.81  # m/s^2\n\n    # Test cases: (L, theta0, omega0, T)\n    test_cases = [\n        (1.0, 0.3, 0.0, 10.0),  # Test A\n        (1.0, 2.5, 0.0, 10.0),  # Test B\n        (2.0, 1.0, 1.0, 20.0),  # Test C\n        (1.0, 1.2, 0.0, 40.0),  # Test D\n    ]\n\n    # Parameters for the numerical experiment\n    N_values = [64, 128, 256, 512, 1024]\n    N_ref = 65536\n\n    results = []\n    \n    # Define the system of ODEs: d(y)/dt = f(t, y)\n    # y = [theta, omega]\n    # f returns [d(theta)/dt, d(omega)/dt]\n    # The system is autonomous, so t is not used.\n    def f(t, y, g_over_L):\n        theta, omega = y\n        return np.array([omega, -g_over_L * np.sin(theta)])\n\n    def integrate_rk4(y0, T, N, g_over_L):\n        \"\"\"\n        Solves the ODE system from t=0 to t=T using N steps of RK4.\n        \"\"\"\n        h = T / N\n        y = np.copy(y0)\n        t = 0.0\n        \n        for _ in range(N):\n            k1 = f(t, y, g_over_L)\n            k2 = f(t + h / 2.0, y + h / 2.0 * k1, g_over_L)\n            k3 = f(t + h / 2.0, y + h / 2.0 * k2, g_over_L)\n            k4 = f(t + h, y + h * k3, g_over_L)\n            \n            y += (h / 6.0) * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n            t += h\n            \n        return y\n\n    for case in test_cases:\n        L, theta0, omega0, T = case\n        g_over_L = g / L\n        y0 = np.array([theta0, omega0])\n\n        # 1. Compute the reference solution with N_ref steps\n        y_ref = integrate_rk4(y0, T, N_ref, g_over_L)\n\n        h_values = []\n        errors = []\n\n        # 2. Compute solutions and errors for a range of N\n        for N in N_values:\n            h = T / N\n            y_approx = integrate_rk4(y0, T, N, g_over_L)\n            \n            # 3. Calculate the Euclidean norm of the error vector\n            error = np.linalg.norm(y_approx - y_ref, 2)\n            \n            h_values.append(h)\n            errors.append(error)\n        \n        # 4. Perform linear regression on log(error) vs log(h)\n        # We expect log(error) = p * log(h) + C\n        log_h = np.log(h_values)\n        log_E = np.log(errors)\n        \n        # numpy.polyfit returns [slope, intercept] for degree 1\n        p, _ = np.polyfit(log_h, log_E, 1)\n        \n        results.append(p)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(lambda x: f'{x:.2f}', results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "对于像单摆这样的保守系统，能量在理论上是守恒的。然而，在长时间的数值模拟中，许多积分方法会导致能量的系统性漂移。本练习  介绍了一种特殊的辛积分方法——欧拉-克罗默法（Euler-Cromer method），它虽然阶数较低，却具有卓越的长期稳定性。你将通过模拟数千个周期，亲眼见证该方法如何将能量误差限制在有界范围内振荡，而不是无限增长，这对于哈密顿系统的长期模拟至关重要。",
            "id": "2420954",
            "problem": "考虑一个在竖直平面内无摩擦运动的、由点质量和无质量杆构成的无阻尼刚性摆。设其与垂直向下方向的角位移为 $ \\theta(t) $（单位为弧度），角速度为 $ \\omega(t) = \\dot{\\theta}(t) $（单位为弧度/秒）。其运动方程为非线性二阶常微分方程\n$$\n\\ddot{\\theta}(t) + \\frac{g}{L} \\sin\\!\\big(\\theta(t)\\big) = 0 ,\n$$\n其中 $ L $ 是摆的长度（单位为米），$ g $ 是重力加速度（单位为米/平方秒）。对于质量为 $ m $ 的物体，其总机械能为\n$$\nE(\\theta,\\omega) = m g L \\big(1 - \\cos\\theta\\big) + \\frac{1}{2} m L^2 \\omega^2 .\n$$\n在整个问题中，取 $ m = 1 $ 千克。所有角度均使用弧度，所有时间均使用秒。\n\n根据小角度周期 $ T_0 $ 定义以下时间离散化：\n$$\nT_0 = 2\\pi \\sqrt{\\frac{L}{g}}, \\quad \\Delta t = \\frac{T_0}{N_{\\text{pp}}}, \\quad N_{\\text{steps}} = N_{\\text{pp}} \\times N_{\\text{per}} ,\n$$\n其中 $ N_{\\text{pp}} $ 是每个小角度周期的时间步数，$ N_{\\text{per}} $ 是要模拟的周期数（周期以 $ T_0 $ 为单位计数）。使用离散时间更新规则\n$$\n\\omega_{n+1} = \\omega_n - \\frac{g}{L} \\sin(\\theta_n)\\,\\Delta t, \\qquad\n\\theta_{n+1} = \\theta_n + \\omega_{n+1}\\,\\Delta t ,\n$$\n初始条件为\n$$\n\\theta_0 = \\theta(0) = \\theta_{\\text{init}}, \\qquad \\omega_0 = \\omega(0) = 0 .\n$$\n在每一步，计算总能量\n$$\nE_n = g L \\big(1 - \\cos\\theta_n\\big) + \\frac{1}{2} L^2 \\omega_n^2,\n$$\n并定义相对于初始能量 $ E_0 $ 的相对能量偏差为\n$$\n\\varepsilon_n = \n\\begin{cases}\n\\left| \\dfrac{E_n - E_0}{E_0} \\right|,  \\text{若 } E_0 \\neq 0, \\\\\n0,  \\text{若 } E_0 = 0 .\n\\end{cases}\n$$\n对于下述测试套件中的每组参数，模拟 $ N_{\\text{steps}} $ 步，并报告最大相对能量偏差\n$$\n\\varepsilon_{\\max} = \\max_{0 \\le n \\le N_{\\text{steps}}} \\varepsilon_n .\n$$\n\n测试套件（每个元组为 $ (L \\ \\text{单位 m}, \\ g \\ \\text{单位 m/s}^2, \\ \\theta_{\\text{init}} \\ \\text{单位 rad}, \\ N_{\\text{pp}}, \\ N_{\\text{per}}) $）：\n- 情况 1：$(1.0, \\ 9.81, \\ 0.3, \\ 64, \\ 2500)$，\n- 情况 2：$(1.0, \\ 9.81, \\ 1.2, \\ 64, \\ 2500)$，\n- 情况 3：$(2.0, \\ 9.81, \\ 2.5, \\ 96, \\ 2000)$，\n- 情况 4：$(0.5, \\ 9.81, \\ 0.1, \\ 32, \\ 3000)$，\n- 情况 5：$(1.0, \\ 9.81, \\ 3.0, \\ 128, \\ 1500)$。\n\n您的程序必须对每种情况计算 $ \\varepsilon_{\\max} $ 作为一个浮点数，并生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来，每个数字四舍五入到八位小数（例如，$ [0.00123456,0.01234567] $）。$ L $ 使用米，$ g $ 使用米/平方秒，$ \\theta $ 使用弧度，时间使用秒。输出必须按测试套件案例的顺序汇总结果，格式为 $ [\\varepsilon_{\\max}^{(1)}, \\varepsilon_{\\max}^{(2)}, \\varepsilon_{\\max}^{(3)}, \\varepsilon_{\\max}^{(4)}, \\varepsilon_{\\max}^{(5)}] $。",
            "solution": "该问题陈述已经过严格验证，被认为是有效的。它在科学上是合理的、适定的、客观的，并包含获得唯一解所需的所有必要信息。该问题是计算物理中的一个标准练习，涉及保守动力系统的数值积分。\n\n该物理系统是一个简单的刚性摆，其运动由非线性二阶常微分方程描述\n$$\n\\ddot{\\theta}(t) + \\frac{g}{L} \\sin(\\theta(t)) = 0,\n$$\n其中 $ \\theta(t) $ 是角位移，$ \\omega(t) = \\dot{\\theta}(t) $ 是角速度，$ L $ 是摆的长度，$ g $ 是重力加速度。由于该系统是保守的（无阻尼且无外力），其总机械能 $ E(\\theta, \\omega) $ 是一个运动常数。对于一个点质量 $ m $，该能量是势能和动能之和：\n$$\nE(\\theta,\\omega) = \\underbrace{m g L (1 - \\cos\\theta)}_{\\text{势能}} + \\underbrace{\\frac{1}{2} m L^2 \\omega^2}_{\\text{动能}}。\n$$\n在指定的质量 $ m = 1 \\ \\text{kg} $ 下，能量表达式简化为\n$$\nE(\\theta,\\omega) = g L (1 - \\cos\\theta) + \\frac{1}{2} L^2 \\omega^2.\n$$\n任务是使用特定的数值方法模拟摆的动力学，并通过计算能量计算值与其初始值的最大相对偏差来量化该方法的准确性。一个理想的保守系统数值积分器应能精确地保持能量守恒。实际的积分器会引入误差，导致数值计算的能量发生偏差。\n\n指定的数值积分方案是\n$$\n\\omega_{n+1} = \\omega_n - \\frac{g}{L} \\sin(\\theta_n)\\,\\Delta t,\n$$\n$$\n\\theta_{n+1} = \\theta_n + \\omega_{n+1}\\,\\Delta t,\n$$\n其中 $ (\\theta_n, \\omega_n) $ 是在时间 $ t_n = n \\Delta t $ 的状态，$ \\Delta t $ 是离散时间步长。此方案被称为欧拉-克罗默（Euler-Cromer）方法。它是标准欧拉方法的一个修改，其中更新后的速度 $ \\omega_{n+1} $ 被用来计算新的位置 $ \\theta_{n+1} $。这个看似微小的改变使积分器成为辛积分器。辛积分器特别适用于哈密顿系统（如此处的摆）的长期模拟。虽然它们不守恒于精确的能量 $ E $，但它们确实守恒于一个邻近的量，即“影子”哈密顿量。因此，辛积分器的能量误差通常随时间保持有界，围绕初始值振荡，而对于像前向欧拉法这样的非辛方法，能量误差往往会无界增长。该问题要求的是这种能量振荡的最大振幅，用 $ \\varepsilon_{\\max} $ 来量化。\n\n为每个给定的参数集计算 $ \\varepsilon_{\\max} $ 的算法如下：\n\n1.  **初始化**：给定一个包含参数 $(L, g, \\theta_{\\text{init}}, N_{\\text{pp}}, N_{\\text{per}})$ 的测试用例，首先计算派生的模拟常数：\n    - 小角度振荡周期：$ T_0 = 2\\pi\\sqrt{L/g} $。\n    - 时间步长：$ \\Delta t = T_0 / N_{\\text{pp}} $。\n    - 模拟总步数：$ N_{\\text{steps}} = N_{\\text{pp}} \\times N_{\\text{per}} $。\n\n2.  **初始条件**：设置系统在时间 $ t=0 $（$n=0$）的初始状态：\n    - 初始角度：$ \\theta_0 = \\theta_{\\text{init}} $。\n    - 初始角速度：$ \\omega_0 = 0 $。\n\n3.  **初始能量和误差**：使用初始状态计算初始能量 $ E_0 $：\n    $$\n    E_0 = g L (1 - \\cos\\theta_0).\n    $$\n    相对能量偏差 $ \\varepsilon_n $ 定义为 $ \\varepsilon_n = |(E_n - E_0) / E_0| $（对于 $ E_0 \\ne 0 $）。对于给定的初始条件，$ E_0 $ 是非零的，因为 $ \\theta_{\\text{init}} $ 从不是 $ 2\\pi $ 的倍数。初始偏差为 $ \\varepsilon_0 = 0 $。迄今为止找到的最大偏差初始化为 $ \\varepsilon_{\\max} = 0 $。\n\n4.  **时间演化循环**：从 $n=0$ 到 $ N_{\\text{steps}}-1 $ 进行迭代以模拟运动。在每次迭代中，从状态 $(\\theta_n, \\omega_n)$ 开始：\n    a.  使用欧拉-克罗默更新规则计算新状态 $ (\\theta_{n+1}, \\omega_{n+1}) $。\n    b.  计算新步骤的总能量 $ E_{n+1} = g L (1 - \\cos\\theta_{n+1}) + \\frac{1}{2} L^2 \\omega_{n+1}^2 $。\n    c.  计算相对能量偏差 $ \\varepsilon_{n+1} = |(E_{n+1} - E_0) / E_0| $。\n    d.  更新最大偏差：$ \\varepsilon_{\\max} = \\max(\\varepsilon_{\\max}, \\varepsilon_{n+1}) $。\n    e.  新状态 $ (\\theta_{n+1}, \\omega_{n+1}) $ 成为下一次迭代的当前状态。\n\n5.  **结果**：经过 $ N_{\\text{steps}} $ 次迭代后，$ \\varepsilon_{\\max} $ 的最终值即为给定测试用例的结果。对所有五个测试套件重复此过程，并收集结果。最终输出格式化为这些值的列表，四舍五入到八位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the nonlinear pendulum problem for a suite of test cases.\n    \"\"\"\n    # Test Suite (L in m, g in m/s^2, theta_init in rad, N_pp, N_per)\n    test_cases = [\n        (1.0, 9.81, 0.3, 64, 2500),\n        (1.0, 9.81, 1.2, 64, 2500),\n        (2.0, 9.81, 2.5, 96, 2000),\n        (0.5, 9.81, 0.1, 32, 3000),\n        (1.0, 9.81, 3.0, 128, 1500),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        L, g, theta_init, N_pp, N_per = case\n        \n        # Calculate simulation parameters\n        T0 = 2.0 * np.pi * np.sqrt(L / g)\n        dt = T0 / N_pp\n        N_steps = N_pp * N_per\n        \n        # Initial conditions\n        theta = theta_init\n        omega = 0.0\n        \n        # Calculate initial energy\n        # The problem states m=1, so we omit it.\n        # E = g * L * (1 - cos(theta)) + 0.5 * L**2 * omega**2\n        E0 = g * L * (1.0 - np.cos(theta_init))\n        \n        # Initialize maximum relative energy deviation\n        # Epsilon_0 is 0 by definition.\n        epsilon_max = 0.0\n\n        # Handle the case where initial energy is zero to avoid division by zero.\n        # For the given test cases, theta_init is never a multiple of 2*pi, so E0 is not zero.\n        if E0 == 0.0:\n            results.append(0.0)\n            continue\n\n        # Simulation loop\n        for _ in range(N_steps):\n            # Update state using the Euler-Cromer method\n            omega = omega - (g / L) * np.sin(theta) * dt\n            theta = theta + omega * dt\n            \n            # Calculate total energy at the current step\n            E_n = g * L * (1.0 - np.cos(theta)) + 0.5 * L**2 * omega**2\n            \n            # Calculate relative energy deviation\n            epsilon_n = np.abs((E_n - E0) / E0)\n            \n            # Update the maximum deviation\n            if epsilon_n > epsilon_max:\n                epsilon_max = epsilon_n\n        \n        results.append(epsilon_max)\n\n    # Format results to eight decimal places and print\n    formatted_results = [f\"{res:.8f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "无阻尼单摆的运动方程具有时间可逆性，这意味着物理定律在时间向前或向后流动时是相同的。一个优秀的数值积分方法应当能反映这种基础物理对称性。本练习  旨在通过韦尔莱（Verlet）积分法来展示时间可逆性这一特性。你将执行一个“前进-后退”的模拟：首先让系统演化一段时间，然后反转速度并演化相同的时间，最终你会发现系统能够以极高的精度回到其初始状态，这有力地证明了该方法的几何保真度。",
            "id": "2420944",
            "problem": "您需要研究无阻尼非线性单摆，其角位移 $\\theta(t)$ 由二阶常微分方程 $\\ddot{\\theta}(t) + \\dfrac{g}{L}\\sin(\\theta(t)) = 0$ 控制，其中 $g$ 是重力加速度，$L$ 是摆长。角度必须以弧度表示，时间以秒表示，角速度 $\\dot{\\theta}$ 以弧度/秒表示。任务是通过将系统从一个初始状态正向演化固定的步数，然后反向演化回到初始状态，来演示一个辛、二阶更新格式的时间可逆性，并量化正向再反向演化后与初始状态的偏差。\n\n定义如下：\n- 状态为 $(\\theta,\\dot{\\theta})$，其中 $\\theta \\in \\mathbb{R}$ 且 $\\dot{\\theta} \\in \\mathbb{R}$。\n- 角加速度函数为 $a(\\theta) = -\\dfrac{g}{L}\\sin(\\theta)$。\n- 正向演化包含 $N$ 个大小为 $\\Delta t$ 的离散时间步，其中 $N$ 是一个正整数，$T = N\\,\\Delta t$ 是总模拟时间。\n- 反向演化包含 $N$ 个步长，这些步长在时间反演对称的意义上精确地逆转正向演化：从正向演化的终末状态 $(\\theta_T,\\dot{\\theta}_T)$ 开始，将速度反转为 $-\\dot{\\theta}_T$，然后应用相同的 $N$ 个步长，最后再次反转速度，以便与初始状态 $(\\theta_0,\\dot{\\theta}_0)$ 进行比较。\n\n使用如下定义的无量纲误差来衡量最终偏差。设 $\\omega_0 = \\sqrt{g/L}$ 为小角度自然频率。设 $\\Delta \\theta$ 为恢复的角度与初始角度之间的主值角差，必要时通过加上 $2\\pi$ 的整数倍将其归约到 $(-\\pi,\\pi]$ 区间。设 $\\Delta \\dot{\\theta}$ 为恢复的角速度与初始角速度之差。定义无量纲误差为\n$$\nE = \\sqrt{(\\Delta \\theta)^2 + \\left(\\dfrac{\\Delta \\dot{\\theta}}{\\omega_0}\\right)^2}.\n$$\n角度必须以弧度为单位，角速度以弧度/秒为单位，$\\omega_0$ 以弧度/秒为单位，这样 $E$ 就是无量纲的。您的程序必须为下面列出的每个测试用例计算 $E$。\n\n测试套件。对于每个测试用例，使用指定的参数 $(g, L, \\theta_0, \\dot{\\theta}_0, T, \\Delta t)$，所有参数均采用国际单位制 (SI)，角度以弧度表示。对于每个测试，$T/\\Delta t$ 均为整数。\n- 测试 1 (小角度，典型步长): $g = 9.81\\ \\mathrm{m/s^2}$, $L = 1.0\\ \\mathrm{m}$, $\\theta_0 = 0.2\\ \\mathrm{rad}$, $\\dot{\\theta}_0 = 0.0\\ \\mathrm{rad/s}$, $T = 10.0\\ \\mathrm{s}$, $\\Delta t = 0.005\\ \\mathrm{s}$。\n- 测试 2 (接近直立的大角度，精细步长): $g = 9.81\\ \\mathrm{m/s^2}$, $L = 1.0\\ \\mathrm{m}$, $\\theta_0 = 2.9\\ \\mathrm{rad}$, $\\dot{\\theta}_0 = 0.0\\ \\mathrm{rad/s}$, $T = 10.0\\ \\mathrm{s}$, $\\Delta t = 0.001\\ \\mathrm{s}$。\n- 测试 3 (非零初始速度): $g = 9.81\\ \\mathrm{m/s^2}$, $L = 0.7\\ \\mathrm{m}$, $\\theta_0 = 0.0\\ \\mathrm{rad}$, $\\dot{\\theta}_0 = 1.5\\ \\mathrm{rad/s}$, $T = 12.0\\ \\mathrm{s}$, $\\Delta t = 0.002\\ \\mathrm{s}$。\n- 测试 4 (接近线性稳定性边界的粗略步长): $g = 9.81\\ \\mathrm{m/s^2}$, $L = 2.0\\ \\mathrm{m}$, $\\theta_0 = 0.01\\ \\mathrm{rad}$, $\\dot{\\theta}_0 = 0.0\\ \\mathrm{rad/s}$, $T = 18.0\\ \\mathrm{s}$, $\\Delta t = 0.9\\ \\mathrm{s}$。\n\n您的程序必须：\n- 实现所述的无阻尼非线性摆动力学。\n- 对每个测试执行：正向演化 $N = T/\\Delta t$ 步，然后如所述进行反向演化，接着计算上面定义的无量纲误差 $E$。\n- 将结果汇总为单行输出，其中包含按上述顺序排列的测试误差列表，四舍五入到 $12$ 位有效数字，并以科学记数法的十进制数打印。\n\n最终输出格式。您的程序应生成一行包含结果的字符串，格式为逗号分隔的列表，并用方括号括起来，例如 `\"[e_1,e_2,e_3,e_4]\"`，其中每个 $e_k$ 是测试 $k$ 的无量纲误差，按上述定义，并以 $12$ 位有效数字的科学记数法格式化。",
            "solution": "问题陈述是有效的。它描述了一个基于经典力学和数值分析标准原理的、良定的计算物理数值实验。\n\n所考虑的物理系统是简单的非线性摆，其运动由以下二阶常微分方程控制：\n$$\n\\ddot{\\theta}(t) + \\frac{g}{L}\\sin(\\theta(t)) = 0\n$$\n其中 $\\theta(t)$ 是角位移，$g$ 是重力加速度，$L$ 是摆的长度。通过定义状态向量 $(\\theta, \\dot{\\theta})$，该方程可以写成一个一阶方程组：\n$$\n\\begin{cases}\n\\frac{d\\theta}{dt} = \\dot{\\theta} \\\\\n\\frac{d\\dot{\\theta}}{dt} = -\\frac{g}{L}\\sin(\\theta)\n\\end{cases}\n$$\n该系统描述了在二维相空间中的运动。这是一个哈密顿系统，意味着其动力学过程守恒一个量，即比能（单位质量的能量），由 $E = \\frac{1}{2}L^2\\dot{\\theta}^2 - gL\\cos(\\theta)$ 给出。用于积分此类系统的数值方法理想上应保持相空间中流的几何性质。辛积分器就是为此目的设计的。它们不一定能精确守恒能量，但它们确实守恒一个邻近的“影子”哈密顿量，这可以防止能量的长期漂移，并确保相空间体积的保持。许多辛积分器的一个关键特性是时间可逆性。如果从状态 $(\\theta_n, \\dot{\\theta}_n)$ 正向演化一个时间步到 $(\\theta_{n+1}, \\dot{\\theta}_{n+1})$，然后从一个时间反演的状态 $(\\theta_{n+1}, -\\dot{\\theta}_{n+1})$ 再正向演化一个时间步，结果是状态 $(\\theta_n, -\\dot{\\theta}_n)$，那么该算法是时间可逆的。\n\n问题要求使用一个二阶、辛更新格式。Velocity Verlet 算法是一个标准且合适的选择。它是 Verlet 积分族的一员，以其在应用于形式为 $\\ddot{\\mathbf{q}} = \\mathbf{F}(\\mathbf{q})$ 的哈密顿系统时良好的稳定性和辛性质而闻名。对于我们的摆系统，其状态为 $(\\theta, \\dot{\\theta})$，加速度为 $a(\\theta) = -\\frac{g}{L}\\sin(\\theta)$，从时间 $t_n$ 到 $t_{n+1} = t_n + \\Delta t$ 的单个积分步骤如下：\n$1$. 首先，计算时间间隔中点的速度：\n$$\n\\dot{\\theta}_{n+1/2} = \\dot{\\theta}_n + a(\\theta_n) \\frac{\\Delta t}{2}\n$$\n$2$. 接着，使用此中点速度更新位置：\n$$\n\\theta_{n+1} = \\theta_n + \\dot{\\theta}_{n+1/2} \\, \\Delta t\n$$\n$3$. 最后，使用新的位置 $\\theta_{n+1}$ 将速度更新到时间间隔的末端：\n$$\n\\dot{\\theta}_{n+1} = \\dot{\\theta}_{n+1/2} + a(\\theta_{n+1}) \\frac{\\Delta t}{2}\n$$\n该算法是显式时间可逆的，并且在 $\\Delta t$ 上具有二阶精度。\n\n为了演示数值模拟的时间可逆性，对每个测试用例实施以下过程：\n$1$. **正向演化：** 使用 Velocity Verlet 算法，将系统从初始状态 $(\\theta_0, \\dot{\\theta}_0)$ 演化总时间 $T$，共计 $N = T/\\Delta t$ 步。这会得到最终状态 $(\\theta_T, \\dot{\\theta}_T)$。\n$2$. **反向演化：** 为了逆转过程，我们从状态 $(\\theta_T, -\\dot{\\theta}_T)$ 开始——注意速度的反转。然后我们应用*相同*的 Velocity Verlet 算法再进行 $N$ 步。这将产生一个状态 $(\\theta'_{\\text{rec}}, \\dot{\\theta}'_{\\text{rec}})$。\n$3$. **最终状态恢复：** 再次反转最终速度以获得恢复状态 $(\\theta_{\\text{rec}}, \\dot{\\theta}_{\\text{rec}}) = (\\theta'_{\\text{rec}}, -\\dot{\\theta}'_{\\text{rec}})$。在精确算术中，由于算法的时间可逆性，我们将得到 $(\\theta_{\\text{rec}}, \\dot{\\theta}_{\\text{rec}}) = (\\theta_0, \\dot{\\theta}_0)$。实际上，浮点舍入误差会导致微小的偏差。\n\n偏差由无量纲误差 $E$ 量化：\n$$\nE = \\sqrt{(\\Delta \\theta)^2 + \\left(\\frac{\\Delta \\dot{\\theta}}{\\omega_0}\\right)^2}\n$$\n其中 $\\omega_0 = \\sqrt{g/L}$ 是小角度振荡的自然频率。差值为 $\\Delta \\dot{\\theta} = \\dot{\\theta}_{\\text{rec}} - \\dot{\\theta}_0$ 和 $\\Delta \\theta$，后者是主值角差，计算为 $\\Delta\\theta_{\\text{raw}} = \\theta_{\\text{rec}} - \\theta_0$，然后映射到区间 $(-\\pi, \\pi]$。这可以通过双参数反正切函数稳健地计算：$\\Delta\\theta = \\text{atan2}(\\sin(\\Delta\\theta_{\\text{raw}}), \\cos(\\Delta\\theta_{\\text{raw}}))$。\n\n实现过程为每个提供的测试用例精确地遵循这些步骤。得到的误差 $E$ 是累积浮点不精确性的度量，预计会很小，这证实了辛积分器优异的数值稳定性和可逆性。最终程序实现了这一完整过程。对于每个测试用例，它设置参数，运行正向然后反向的模拟，计算误差，并按规定格式化结果。创建了一个实现 Velocity Verlet 步骤的函数。对每个测试用例调用两次：一次用于正向演化，一次用于反向演化。收集所有测试用例的计算误差，并以所需格式打印。获得的数值应该非常小，证实了与完美时间反演的偏差在机器精度的数量级上，这对于正确实现的时间可逆算法是符合预期的。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the time-reversibility error for the nonlinear pendulum simulation\n    using a symplectic Velocity Verlet integrator.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (g, L, theta_0, v_theta_0, T, dt)\n        # Test 1\n        (9.81, 1.0, 0.2, 0.0, 10.0, 0.005),\n        # Test 2\n        (9.81, 1.0, 2.9, 0.0, 10.0, 0.001),\n        # Test 3\n        (9.81, 0.7, 0.0, 1.5, 12.0, 0.002),\n        # Test 4\n        (9.81, 2.0, 0.01, 0.0, 18.0, 0.9),\n    ]\n\n    results = []\n\n    def run_simulation(theta_init, v_theta_init, g, L, dt, N):\n        \"\"\"\n        Evolves the pendulum state for N steps using the Velocity Verlet algorithm.\n        \n        Args:\n            theta_init (float): Initial angle in radians.\n            v_theta_init (float): Initial angular velocity in rad/s.\n            g (float): Gravitational acceleration in m/s^2.\n            L (float): Pendulum length in m.\n            dt (float): Time step in s.\n            N (int): Number of steps.\n\n        Returns:\n            tuple[float, float]: Final angle and angular velocity.\n        \"\"\"\n        theta = theta_init\n        v_theta = v_theta_init\n        accel_factor = -g / L\n\n        for _ in range(N):\n            # Velocity Verlet half-step for velocity\n            v_theta_half = v_theta + 0.5 * dt * accel_factor * np.sin(theta)\n            # Full-step for position\n            theta = theta + dt * v_theta_half\n            # Second half-step for velocity, using the updated position\n            v_theta = v_theta_half + 0.5 * dt * accel_factor * np.sin(theta)\n        \n        return theta, v_theta\n\n    for case in test_cases:\n        g, L, theta_0, v_theta_0, T, dt = case\n        \n        # Number of steps. The problem guarantees T/dt is an integer.\n        N = int(round(T / dt))\n\n        # 1. Forward evolution from initial state (theta_0, v_theta_0)\n        theta_T, v_theta_T = run_simulation(theta_0, v_theta_0, g, L, dt, N)\n\n        # 2. Backward evolution\n        # Initial state for backward run: reverse velocity at the end of forward run\n        theta_B0 = theta_T\n        v_theta_B0 = -v_theta_T\n        \n        # Evolve \"forward\" in time from this new state\n        theta_rec_raw, v_theta_rec_raw = run_simulation(theta_B0, v_theta_B0, g, L, dt, N)\n        \n        # The true recovered state is obtained by re-reversing the final velocity\n        theta_rec = theta_rec_raw\n        v_theta_rec = -v_theta_rec_raw\n\n        # 3. Calculate dimensionless error E\n        omega_0 = np.sqrt(g / L)\n        \n        # Calculate deviation from initial state\n        delta_v_theta = v_theta_rec - v_theta_0\n        \n        # Calculate raw angular difference. Angle can wrap around many times.\n        delta_theta_raw = theta_rec - theta_0\n        \n        # Normalize angular difference to the principal-value interval (-pi, pi]\n        delta_theta = np.arctan2(np.sin(delta_theta_raw), np.cos(delta_theta_raw))\n        \n        # Calculate dimensionless error\n        E = np.sqrt(delta_theta**2 + (delta_v_theta / omega_0)**2)\n        results.append(E)\n\n    # Format output as specified: a list of errors in scientific notation with 12 significant digits.\n    # The format specifier {:.11e} gives 1 digit before the decimal and 11 after,\n    # totaling 12 significant digits for a normalized scientific number.\n    formatted_results = [\"{:.11e}\".format(r) for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}