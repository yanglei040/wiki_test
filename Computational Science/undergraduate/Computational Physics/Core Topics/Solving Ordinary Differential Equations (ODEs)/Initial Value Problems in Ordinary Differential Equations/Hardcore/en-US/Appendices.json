{
    "hands_on_practices": [
        {
            "introduction": "The journey into numerically solving differential equations begins with the most intuitive approach: the forward Euler method. This method approximates the solution curve by taking short, straight-line steps, with the direction of each step determined by the tangent at its starting point. This foundational exercise  provides a concrete, single-step calculation to build your intuition for this iterative process, which is the conceptual building block for nearly all advanced techniques.",
            "id": "2180117",
            "problem": "Consider the initial value problem given by the ordinary differential equation $y' = x + \\cos(\\pi y)$ with the initial condition $y(0) = 1$. Use a single step of Euler's method to approximate the value of $y(0.1)$.",
            "solution": "We use a single Euler step from $x_{0}=0$ to $x_{1}=0.1$ with step size $h=0.1=\\frac{1}{10}$. Euler’s method updates via\n$$\ny_{1}=y_{0}+h\\,f(x_{0},y_{0}),\n$$\nwhere $f(x,y)=x+\\cos(\\pi y)$. With the initial condition $y_{0}=1$ at $x_{0}=0$, we compute\n$$\nf(0,1)=0+\\cos(\\pi\\cdot 1)=\\cos(\\pi)=-1.\n$$\nTherefore,\n$$\ny(0.1)\\approx y_{1}=1+\\frac{1}{10}\\cdot(-1)=1-\\frac{1}{10}=\\frac{9}{10}.\n$$",
            "answer": "$$\\boxed{\\frac{9}{10}}$$"
        },
        {
            "introduction": "While simple, the forward Euler method's accuracy is limited by its reliance on the slope at the beginning of an interval. Predictor-corrector methods offer a significant improvement by using a more representative slope. This practice  walks you through a single step of such a method, where you first \"predict\" a tentative future point and then use it to calculate a better, averaged slope to \"correct\" the final step, illustrating a powerful strategy for increasing accuracy.",
            "id": "2194250",
            "problem": "Consider the initial value problem defined by the ordinary differential equation $y'(t) = t - y(t)$ with the initial condition $y(0) = 2$. You are to approximate the value of $y(0.5)$ using a single step of a predictor-corrector method with a step size of $h=0.5$. For this method, use the explicit Euler method as the predictor and the one-step trapezoidal rule as the corrector. What is the corrected value for $y(0.5)$?",
            "solution": "We are given the initial value problem $y'(t) = t - y(t)$ with $y(0) = 2$, and we want to approximate $y(0.5)$ using one predictor-corrector step with step size $h = 0.5$, where the predictor is the explicit Euler method and the corrector is the one-step trapezoidal rule.\n\nLet $f(t,y) = t - y$. With $t_{0} = 0$, $y_{0} = 2$, and $h = \\frac{1}{2}$, the explicit Euler predictor is\n$$\ny_{1}^{(p)} = y_{0} + h f(t_{0}, y_{0}).\n$$\nCompute $f(t_{0}, y_{0})$:\n$$\nf(0,2) = 0 - 2 = -2,\n$$\nso\n$$\ny_{1}^{(p)} = 2 + \\frac{1}{2}(-2) = 2 - 1 = 1.\n$$\n\nThe one-step trapezoidal corrector uses\n$$\ny_{1} = y_{0} + \\frac{h}{2}\\left[f(t_{0}, y_{0}) + f(t_{1}, y_{1}^{(p)})\\right], \\quad t_{1} = t_{0} + h = \\frac{1}{2}.\n$$\nCompute $f(t_{1}, y_{1}^{(p)})$:\n$$\nf\\!\\left(\\frac{1}{2}, 1\\right) = \\frac{1}{2} - 1 = -\\frac{1}{2}.\n$$\nTherefore,\n$$\ny_{1} = 2 + \\frac{1}{4}\\left[-2 + \\left(-\\frac{1}{2}\\right)\\right] = 2 + \\frac{1}{4}\\left(-\\frac{5}{2}\\right) = 2 - \\frac{5}{8} = \\frac{11}{8}.\n$$\n\nThus, the corrected value for $y(0.5)$ is $\\frac{11}{8}$.",
            "answer": "$$\\boxed{\\frac{11}{8}}$$"
        },
        {
            "introduction": "The true power of numerical methods is realized when we move from single-step calculations to simulating complex physical systems. This computational practice  tackles the simulation of a beautiful physics demonstration: the pendulum wave. You will apply your knowledge to model the nonlinear dynamics of multiple pendula, investigate how design choices affect their collective behavior, and observe how nonlinearity causes the system to dephase from its ideal, synchronized motion.",
            "id": "2403226",
            "problem": "Consider a collection of simple pendula modeled as point masses attached to massless rigid rods of varying lengths. For each pendulum indexed by $n \\in \\{1,2,\\dots,N\\}$, let $\\theta_n(t)$ denote its angular displacement from the downward vertical at time $t$, with positive direction chosen consistently. Assume planar motion, no driving, and no dissipation. By Newton’s second law for rotational motion, the dynamics of each pendulum are governed by the ordinary differential equation (ODE) \n$$\n\\frac{d^2 \\theta_n}{dt^2} + \\frac{g}{L_n} \\sin\\big(\\theta_n(t)\\big) = 0,\n$$\nwith initial conditions \n$$\n\\theta_n(0)=\\theta_0,\\quad \\frac{d\\theta_n}{dt}(0)=0,\n$$\nwhere $g$ is the gravitational acceleration in $\\mathrm{m/s^2}$, $L_n$ is the length of the $n$–th pendulum in $\\mathrm{m}$, and angles are expressed in radians. To generate a pendulum-wave pattern, consider a set of target periods $\\{T_n\\}_{n=1}^N$ designed so that, in the small-angle limit, each pendulum completes an integer number of oscillations over a common alignment time $T_{\\mathrm{align}}$, namely $T_n = \\frac{T_{\\mathrm{align}}}{K_n}$ with integers $K_n$. In the small-angle approximation, the period is $T_n = 2\\pi \\sqrt{\\frac{L_n}{g}}$, which implies the length choice \n$$\nL_n = g \\left(\\frac{T_n}{2\\pi}\\right)^2 = g \\left(\\frac{T_{\\mathrm{align}}}{2\\pi K_n}\\right)^2.\n$$\nIn all tasks below, use the full nonlinear ODE with the exact $\\sin(\\theta_n)$ term, not the small-angle approximation. Use units: lengths in $\\mathrm{m}$, $g$ in $\\mathrm{m/s^2}$, time in $\\mathrm{s}$, and angles in radians.\n\nTest suite and required outputs:\n\n- Test case A (small-amplitude rephasing in the linear-design limit):\n  - Parameters: $N=15$, $g=9.81\\,\\mathrm{m/s^2}$, $\\theta_0=0.05\\,\\mathrm{rad}$, $T_{\\mathrm{align}}=60\\,\\mathrm{s}$, and $K_n = K_0 + N - n$ with $K_0=46$. Thus, $K_1=60$, $K_{15}=46$, and $L_n = g \\left(\\frac{T_{\\mathrm{align}}}{2\\pi K_n}\\right)^2$ for $n \\in \\{1,\\dots,15\\}$. Simulate each pendulum over $t \\in [0,T_{\\mathrm{align}}]$. Define the scalar\n  $$\n  E_A = \\max_{1 \\le n \\le N} \\left|\\theta_n(T_{\\mathrm{align}}) - \\theta_0\\right|.\n  $$\n  Report $E_A$ as a floating-point number in radians.\n\n- Test case B (nonlinear dephasing at larger amplitude):\n  - Parameters: identical to Test case A except $\\theta_0=0.5\\,\\mathrm{rad}$. Simulate over $t \\in [0,T_{\\mathrm{align}}]$. Define\n  $$\n  E_B = \\max_{1 \\le n \\le N} \\left|\\theta_n(T_{\\mathrm{align}}) - \\theta_0\\right|.\n  $$\n  Report $E_B$ as a floating-point number in radians.\n\n- Test case C (degenerate pair with identical lengths):\n  - Parameters: $N=2$, $L_1=L_2=1.0\\,\\mathrm{m}$, $g=9.81\\,\\mathrm{m/s^2}$, $\\theta_0=0.1\\,\\mathrm{rad}$, and simulation interval $t \\in [0,T]$ with $T=10\\,\\mathrm{s}$. For these two pendula with identical initial conditions and lengths, define\n  $$\n  E_C = \\max_{t \\in [0,T]} \\left|\\theta_1(t) - \\theta_2(t)\\right|.\n  $$\n  Report $E_C$ as a floating-point number in radians.\n\nYour program must compute $(E_A, E_B, E_C)$ using the ODE stated above with the specified parameters and initial conditions. The final output must be a single line containing a comma-separated list enclosed in square brackets in the order $[E_A,E_B,E_C]$, for example $[x_A,x_B,x_C]$, where each entry is a floating-point number in radians. No other text should be printed.",
            "solution": "The starting point is the torque balance for a simple pendulum, which is derived from first principles. For a point mass $m$ at the end of a rigid massless rod of length $L_n$ under gravity $g$, the gravitational torque about the pivot is $\\tau = - m g L_n \\sin(\\theta_n)$. The moment of inertia is $I = m L_n^2$. Newton’s second law for rotation gives $I \\frac{d^2 \\theta_n}{dt^2} = \\tau$, hence\n$$\nm L_n^2 \\frac{d^2 \\theta_n}{dt^2} = - m g L_n \\sin(\\theta_n)\n\\quad \\Rightarrow \\quad\n\\frac{d^2 \\theta_n}{dt^2} + \\frac{g}{L_n} \\sin(\\theta_n) = 0.\n$$\nThis is a second-order nonlinear ordinary differential equation (ODE) initial value problem (IVP). With the initial conditions $\\theta_n(0) = \\theta_0$ and $\\frac{d\\theta_n}{dt}(0) = 0$, the solution is uniquely determined for each $n$.\n\nTo produce a pendulum-wave pattern, one selects lengths so that, in the small-angle limit, each pendulum completes an integer number of oscillations over a common alignment time $T_{\\mathrm{align}}$. If the small-angle period is $T_n = 2\\pi \\sqrt{L_n/g}$ and we enforce $T_n = \\frac{T_{\\mathrm{align}}}{K_n}$ for integers $K_n$, then the lengths follow\n$$\nL_n = g \\left(\\frac{T_n}{2\\pi}\\right)^2 = g \\left(\\frac{T_{\\mathrm{align}}}{2\\pi K_n}\\right)^2.\n$$\nChoosing a strictly decreasing sequence of integers $K_n$ with $n$ ensures strictly increasing lengths $L_n$ with $n$. In Test cases A and B, the choice $K_n = K_0 + N - n$ yields $K_1 = K_0 + N - 1$ down to $K_N = K_0$, and thus $L_1 < L_2 < \\cdots < L_N$.\n\nFor Test case A, the initial displacement $\\theta_0$ is small. In the linear limit, after $K_n$ complete oscillations, each pendulum returns to its initial state at $t = T_{\\mathrm{align}}$, implying $\\theta_n(T_{\\mathrm{align}}) = \\theta_0$ and thus $E_A = 0$. However, solving the exact nonlinear ODE with $\\sin(\\theta_n)$ produces a small deviation because the period depends on amplitude in the nonlinear regime; the numerical value $E_A$ quantifies this deviation.\n\nFor Test case B, the initial displacement $\\theta_0$ is larger, and the amplitude-dependent period shift is more significant. The sequence of $L_n$ is unchanged, but $E_B$ is expected to be larger because the nonlinear effects induce dephasing relative to the linear-design alignment time $T_{\\mathrm{align}}$.\n\nFor Test case C, with two pendula of identical length $L_1 = L_2$ and identical initial data $\\theta_1(0) = \\theta_2(0) = \\theta_0$ and $\\frac{d\\theta_1}{dt}(0) = \\frac{d\\theta_2}{dt}(0) = 0$, the ODEs are identical, and by uniqueness of solutions for smooth ODEs, $\\theta_1(t) \\equiv \\theta_2(t)$ for all $t$. Therefore, analytically $E_C = 0$. A numerical solution will yield a value close to zero, with any deviation attributable to numerical error and sampling.\n\nAlgorithmic outline consistent with these principles:\n- Express each second-order ODE as a first-order system by introducing $\\omega_n = \\frac{d\\theta_n}{dt}$:\n  $$\n  \\frac{d\\theta_n}{dt} = \\omega_n,\\quad \\frac{d\\omega_n}{dt} = -\\frac{g}{L_n} \\sin(\\theta_n).\n  $$\n- For Test cases A and B, for each $n \\in \\{1,\\dots,N\\}$, integrate the system from $t=0$ to $t=T_{\\mathrm{align}}$ with initial conditions $(\\theta_n(0),\\omega_n(0)) = (\\theta_0,0)$, and evaluate $\\theta_n(T_{\\mathrm{align}})$. Compute $E_A$ or $E_B$ as the maximum absolute deviation from $\\theta_0$ across $n$.\n- For Test case C, integrate both identical pendula over $t \\in [0,T]$ with the same initial conditions, sample $\\theta_1(t)$ and $\\theta_2(t)$ on a sufficiently fine time grid, and compute $E_C$ as the maximum absolute difference $|\\theta_1(t)-\\theta_2(t)|$ over the grid.\n- Use the specified units: $g$ in $\\mathrm{m/s^2}$, lengths in $\\mathrm{m}$, time in $\\mathrm{s}$, angles in radians.\n\nThe final program computes the three scalars $(E_A,E_B,E_C)$ and prints them in a single line as a comma-separated list in the required order $[E_A,E_B,E_C]$, with values in radians.",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef pendulum_rhs(t, y, g, L):\n    theta, omega = y\n    return [omega, -(g / L) * np.sin(theta)]\n\ndef simulate_endpoint_theta(L, theta0, g, t_end, rtol=1e-10, atol=1e-12, method=\"DOP853\"):\n    # Integrate one pendulum to time t_end and return theta(t_end)\n    sol = solve_ivp(\n        fun=lambda t, y: pendulum_rhs(t, y, g, L),\n        t_span=(0.0, t_end),\n        y0=[theta0, 0.0],\n        method=method,\n        rtol=rtol,\n        atol=atol,\n        t_eval=[t_end],\n        dense_output=False,\n        vectorized=False,\n    )\n    theta_T = sol.y[0, -1]\n    return theta_T\n\ndef simulate_theta_time_series(L, theta0, g, T, num_points=5001, rtol=1e-11, atol=1e-13, method=\"DOP853\"):\n    # Integrate one pendulum over [0,T] and return time grid and theta(t) array\n    t_eval = np.linspace(0.0, T, num_points)\n    sol = solve_ivp(\n        fun=lambda t, y: pendulum_rhs(t, y, g, L),\n        t_span=(0.0, T),\n        y0=[theta0, 0.0],\n        method=method,\n        rtol=rtol,\n        atol=atol,\n        t_eval=t_eval,\n        dense_output=False,\n        vectorized=False,\n    )\n    return sol.t, sol.y[0, :]\n\ndef compute_lengths_for_alignment(N, g, T_align, K0):\n    # K_n = K0 + N - n yields increasing lengths with n\n    Ks = np.array([K0 + N - n for n in range(1, N + 1)], dtype=float)\n    # L_n = g * (T_align / (2*pi*K_n))^2\n    Ls = g * (T_align / (2.0 * np.pi * Ks))**2\n    return Ls\n\ndef main():\n    # Constants\n    g = 9.81  # m/s^2\n\n    results = []\n\n    # Test case A\n    N_A = 15\n    T_align_A = 60.0  # s\n    K0_A = 46\n    theta0_A = 0.05  # rad\n    Ls_A = compute_lengths_for_alignment(N_A, g, T_align_A, K0_A)\n    deviations_A = []\n    for L in Ls_A:\n        theta_T = simulate_endpoint_theta(L, theta0_A, g, T_align_A)\n        deviations_A.append(abs(theta_T - theta0_A))\n    E_A = float(np.max(deviations_A))\n    results.append(E_A)\n\n    # Test case B (same lengths, larger amplitude)\n    theta0_B = 0.5  # rad\n    deviations_B = []\n    for L in Ls_A:\n        theta_T = simulate_endpoint_theta(L, theta0_B, g, T_align_A)\n        deviations_B.append(abs(theta_T - theta0_B))\n    E_B = float(np.max(deviations_B))\n    results.append(E_B)\n\n    # Test case C (two identical pendula)\n    L_C = 1.0  # m\n    theta0_C = 0.1  # rad\n    T_C = 10.0  # s\n    t_grid, theta1 = simulate_theta_time_series(L_C, theta0_C, g, T_C)\n    _, theta2 = simulate_theta_time_series(L_C, theta0_C, g, T_C)  # identical parameters\n    E_C = float(np.max(np.abs(theta1 - theta2)))\n    results.append(E_C)\n\n    # Print results in required format\n    print(f\"[{','.join(f'{x:.12g}' for x in results)}]\")\n\nif __name__ == \"__main__\":\n    main()\n```"
        }
    ]
}