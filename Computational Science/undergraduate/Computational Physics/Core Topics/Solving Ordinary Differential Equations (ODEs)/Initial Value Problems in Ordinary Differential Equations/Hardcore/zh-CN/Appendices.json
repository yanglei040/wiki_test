{
    "hands_on_practices": [
        {
            "introduction": "欧拉方法是求解常微分方程初值问题最基础、最直观的数值方法。本练习通过一个具体的单步计算，展示了如何用一系列切线段来近似求解曲线，这对于掌握时域推进的核心思想至关重要。通过这个基础实践 ，你将亲手体验数值求解的第一步。",
            "id": "2180117",
            "problem": "考虑由常微分方程 $y' = x + \\cos(\\pi y)$ 和初始条件 $y(0) = 1$ 给出的初值问题。使用欧拉方法的单步来近似 $y(0.1)$ 的值。",
            "solution": "我们使用欧拉方法的单步，从 $x_{0}=0$ 到 $x_{1}=0.1$，步长为 $h=0.1=\\frac{1}{10}$。欧拉方法的更新公式为\n$$\ny_{1}=y_{0}+h\\,f(x_{0},y_{0}),\n$$\n其中 $f(x,y)=x+\\cos(\\pi y)$。根据初始条件 $x_{0}=0$ 时 $y_{0}=1$，我们计算\n$$\nf(0,1)=0+\\cos(\\pi\\cdot 1)=\\cos(\\pi)=-1.\n$$\n因此，\n$$\ny(0.1)\\approx y_{1}=1+\\frac{1}{10}\\cdot(-1)=1-\\frac{1}{10}=\\frac{9}{10}.\n$$",
            "answer": "$$\\boxed{\\frac{9}{10}}$$"
        },
        {
            "introduction": "在欧拉法的基础上，我们可以引入预测-校正方案来提升计算精度。这种方法首先“预测”一个未来值，然后利用更多关于导数的信息来“校正”这个预测，从而得到更准确的结果。本练习  旨在演示这种强大且广泛使用的策略，让你理解如何通过迭代思想改进数值解。",
            "id": "2194250",
            "problem": "考虑由常微分方程 $y'(t) = t - y(t)$ 和初始条件 $y(0) = 2$ 定义的初值问题。要求使用步长为 $h=0.5$ 的单步预测-校正方法来近似计算 $y(0.5)$ 的值。在此方法中，使用显式欧拉法作为预测子，使用单步梯形法则作为校正子。$y(0.5)$ 的校正后值是多少？",
            "solution": "给定初值问题 $y'(t) = t - y(t)$ 及 $y(0) = 2$，我们希望使用步长为 $h = 0.5$ 的单步预测-校正方法来近似计算 $y(0.5)$，其中预测子为显式欧拉法，校正子为单步梯形法则。\n\n令 $f(t,y) = t - y$。对于 $t_{0} = 0$，$y_{0} = 2$ 和 $h = \\frac{1}{2}$，显式欧拉预测子为\n$$\ny_{1}^{(p)} = y_{0} + h f(t_{0}, y_{0}).\n$$\n计算 $f(t_{0}, y_{0})$：\n$$\nf(0,2) = 0 - 2 = -2,\n$$\n所以\n$$\ny_{1}^{(p)} = 2 + \\frac{1}{2}(-2) = 2 - 1 = 1.\n$$\n\n单步梯形校正子为：\n$$\ny_{1} = y_{0} + \\frac{h}{2}\\left[f(t_{0}, y_{0}) + f(t_{1}, y_{1}^{(p)})\\right], \\quad t_{1} = t_{0} + h = \\frac{1}{2}.\n$$\n计算 $f(t_{1}, y_{1}^{(p)})$：\n$$\nf\\!\\left(\\frac{1}{2}, 1\\right) = \\frac{1}{2} - 1 = -\\frac{1}{2}.\n$$\n因此，\n$$\ny_{1} = 2 + \\frac{1}{4}\\left[-2 + \\left(-\\frac{1}{2}\\right)\\right] = 2 + \\frac{1}{4}\\left(-\\frac{5}{2}\\right) = 2 - \\frac{5}{8} = \\frac{11}{8}.\n$$\n\n因此，$y(0.5)$ 的校正后值为 $\\frac{11}{8}$。",
            "answer": "$$\\boxed{\\frac{11}{8}}$$"
        },
        {
            "introduction": "从单步计算走向完整的计算物理问题，本练习将应用常微分方程求解器来模拟一个迷人的物理现象——钟摆波。这个实践  要求你建立并求解一个非线性常微分方程组，突显了稳健的数值方法在物理和工程中的核心作用。它也提供了一个探索共振、线性近似与非线性现实之间差异的绝佳机会。",
            "id": "2403226",
            "problem": "考虑一个由简单摆组成的集合，每个摆被建模为附着在不同长度的无质量刚性杆上的质点。对于每个由 $n \\in \\{1,2,\\dots,N\\}$ 索引的摆，令 $\\theta_n(t)$ 表示其在时间 $t$ 相对于垂直向下的角位移，正方向的选择保持一致。假设为平面运动，无驱动，无耗散。根据牛顿第二定律的转动形式，每个摆的动力学由以下常微分方程（ODE）决定\n$$\n\\frac{d^2 \\theta_n}{dt^2} + \\frac{g}{L_n} \\sin\\big(\\theta_n(t)\\big) = 0,\n$$\n初始条件为\n$$\n\\theta_n(0)=\\theta_0,\\quad \\frac{d\\theta_n}{dt}(0)=0,\n$$\n其中 $g$ 是以 $\\mathrm{m/s^2}$ 为单位的重力加速度，$L_n$ 是第 $n$ 个摆的摆长（以 $\\mathrm{m}$ 为单位），角度以弧度表示。为产生摆波图案，考虑一组目标周期 $\\{T_n\\}_{n=1}^N$，其设计使得在小角度近似下，每个摆在一个共同的对齐时间 $T_{\\mathrm{align}}$ 内完成整数次振荡，即 $T_n = \\frac{T_{\\mathrm{align}}}{K_n}$，其中 $K_n$ 为整数。在小角度近似下，周期为 $T_n = 2\\pi \\sqrt{\\frac{L_n}{g}}$，这意味着摆长的选择为\n$$\nL_n = g \\left(\\frac{T_n}{2\\pi}\\right)^2 = g \\left(\\frac{T_{\\mathrm{align}}}{2\\pi K_n}\\right)^2.\n$$\n在以下所有任务中，请使用包含精确 $\\sin(\\theta_n)$ 项的完整非线性常微分方程，而非小角度近似。使用单位：长度以 $\\mathrm{m}$ 为单位，$g$ 以 $\\mathrm{m/s^2}$ 为单位，时间以 $\\mathrm{s}$ 为单位，角度以弧度为单位。\n\n测试套件和要求的输出：\n\n- 测试用例 A（线性设计极限下的小振幅重相位）：\n  - 参数：$N=15$，$g=9.81\\,\\mathrm{m/s^2}$，$\\theta_0=0.05\\,\\mathrm{rad}$，$T_{\\mathrm{align}}=60\\,\\mathrm{s}$，以及 $K_n = K_0 + N - n$，其中 $K_0=46$。因此，$K_1=60$，$K_{15}=46$，且对于 $n \\in \\{1,\\dots,15\\}$，$L_n = g \\left(\\frac{T_{\\mathrm{align}}}{2\\pi K_n}\\right)^2$。在 $t \\in [0,T_{\\mathrm{align}}]$ 上模拟每个摆的运动。定义标量\n  $$\n  E_A = \\max_{1 \\le n \\le N} \\left|\\theta_n(T_{\\mathrm{align}}) - \\theta_0\\right|.\n  $$\n  以浮点数形式报告 $E_A$ 的值，单位为弧度。\n\n- 测试用例 B（较大振幅下的非线性失相）：\n  - 参数：与测试用例 A 相同，除了 $\\theta_0=0.5\\,\\mathrm{rad}$。在 $t \\in [0,T_{\\mathrm{align}}]$ 上进行模拟。定义\n  $$\n  E_B = \\max_{1 \\le n \\le N} \\left|\\theta_n(T_{\\mathrm{align}}) - \\theta_0\\right|.\n  $$\n  以浮点数形式报告 $E_B$ 的值，单位为弧度。\n\n- 测试用例 C（长度相同的简并对）：\n  - 参数：$N=2$，$L_1=L_2=1.0\\,\\mathrm{m}$，$g=9.81\\,\\mathrm{m/s^2}$，$\\theta_0=0.1\\,\\mathrm{rad}$，模拟区间为 $t \\in [0,T]$，其中 $T=10\\,\\mathrm{s}$。对于这两个初始条件和摆长都相同的摆，定义\n  $$\n  E_C = \\max_{t \\in [0,T]} \\left|\\theta_1(t) - \\theta_2(t)\\right|.\n  $$\n  以浮点数形式报告 $E_C$ 的值，单位为弧度。\n\n您的程序必须使用上述常微分方程以及指定的参数和初始条件来计算 $(E_A, E_B, E_C)$。最终输出必须是单行文本，包含一个用方括号括起来的逗号分隔列表，顺序为 $[E_A,E_B,E_C]$，例如 $[x_A,x_B,x_C]$，其中每个条目都是一个以弧度为单位的浮点数。不应打印任何其他文本。",
            "solution": "出发点是单摆的力矩平衡，这可以从第一性原理推导得出。对于一个质量为 $m$ 的质点，位于长度为 $L_n$ 的无质量刚性杆的末端，在重力 $g$ 的作用下，其绕支点的引力力矩为 $\\tau = - m g L_n \\sin(\\theta_n)$。转动惯量为 $I = m L_n^2$。根据牛顿第二定律的转动形式，有 $I \\frac{d^2 \\theta_n}{dt^2} = \\tau$，因此\n$$\nm L_n^2 \\frac{d^2 \\theta_n}{dt^2} = - m g L_n \\sin(\\theta_n)\n\\quad \\Rightarrow \\quad\n\\frac{d^2 \\theta_n}{dt^2} + \\frac{g}{L_n} \\sin(\\theta_n) = 0.\n$$\n这是一个二阶非线性常微分方程（ODE）的初值问题（IVP）。给定初始条件 $\\theta_n(0) = \\theta_0$ 和 $\\frac{d\\theta_n}{dt}(0) = 0$，对于每个 $n$，解都是唯一确定的。\n\n为了产生摆波图案，选择的摆长应使得在小角度近似下，每个摆在一个共同的对齐时间 $T_{\\mathrm{align}}$ 内完成整数次振荡。如果小角度周期为 $T_n = 2\\pi \\sqrt{L_n/g}$，并且我们强制要求 $T_n = \\frac{T_{\\mathrm{align}}}{K_n}$（其中 $K_n$ 为整数），那么摆长遵循\n$$\nL_n = g \\left(\\frac{T_n}{2\\pi}\\right)^2 = g \\left(\\frac{T_{\\mathrm{align}}}{2\\pi K_n}\\right)^2.\n$$\n选择一个随 $n$ 严格递减的整数序列 $K_n$ 可以确保摆长 $L_n$ 随 $n$ 严格递增。在测试用例 A 和 B 中，选择 $K_n = K_0 + N - n$ 会得到从 $K_1 = K_0 + N - 1$ 一直递减到 $K_N = K_0$ 的序列，因此有 $L_1  L_2  \\cdots  L_N$。\n\n对于测试用例 A，初始位移 $\\theta_0$ 很小。在线性极限下，经过 $K_n$ 次完整振荡后，每个摆在 $t = T_{\\mathrm{align}}$ 时回到其初始状态，这意味着 $\\theta_n(T_{\\mathrm{align}}) = \\theta_0$，因此 $E_A = 0$。然而，求解包含 $\\sin(\\theta_n)$ 的精确非线性常微分方程会产生一个微小的偏差，因为在非线性区域，周期依赖于振幅；数值 $E_A$ 量化了这一偏差。\n\n对于测试用例 B，初始位移 $\\theta_0$ 更大，振幅相关的周期偏移也更显著。摆长 $L_n$ 的序列保持不变，但预计 $E_B$ 会更大，因为非线性效应会相对于线性设计的对齐时间 $T_{\\mathrm{align}}$ 引起失相。\n\n对于测试用例 C，两个摆的摆长相同 ($L_1 = L_2$)，初始数据也相同 ($\\theta_1(0) = \\theta_2(0) = \\theta_0$ 和 $\\frac{d\\theta_1}{dt}(0) = \\frac{d\\theta_2}{dt}(0) = 0$)，因此它们的常微分方程是完全相同的。根据光滑常微分方程解的唯一性，对于所有 $t$，都有 $\\theta_1(t) \\equiv \\theta_2(t)$。因此，从解析上讲 $E_C = 0$。数值解将得到一个接近于零的值，任何偏差都可归因于数值误差和采样。\n\n与这些原理一致的算法大纲：\n- 通过引入 $\\omega_n = \\frac{d\\theta_n}{dt}$，将每个二阶常微分方程表示为一阶方程组：\n  $$\n  \\frac{d\\theta_n}{dt} = \\omega_n,\\quad \\frac{d\\omega_n}{dt} = -\\frac{g}{L_n} \\sin(\\theta_n).\n  $$\n- 对于测试用例 A 和 B，对每个 $n \\in \\{1,\\dots,N\\}$，将方程组从 $t=0$ 积分到 $t=T_{\\mathrm{align}}$，初始条件为 $(\\theta_n(0),\\omega_n(0)) = (\\theta_0,0)$，并计算 $\\theta_n(T_{\\mathrm{align}})$。计算 $E_A$ 或 $E_B$ 作为所有 $n$ 中与 $\\theta_0$ 的最大绝对偏差。\n- 对于测试用例 C，在 $t \\in [0,T]$ 上对两个相同的摆使用相同的初始条件进行积分，在足够精细的时间网格上采样 $\\theta_1(t)$ 和 $\\theta_2(t)$，并计算 $E_C$ 作为网格上 $|\\theta_1(t)-\\theta_2(t)|$ 的最大绝对差。\n- 使用指定的单位：$g$ 以 $\\mathrm{m/s^2}$ 为单位，摆长以 $\\mathrm{m}$ 为单位，时间以 $\\mathrm{s}$ 为单位，角度以弧度为单位。\n\n最终的程序计算三个标量 $(E_A,E_B,E_C)$，并按要求的顺序 $[E_A,E_B,E_C]$ 将它们作为逗号分隔的列表打印在单行中，其值以弧度为单位。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef pendulum_rhs(t, y, g, L):\n    theta, omega = y\n    return [omega, -(g / L) * np.sin(theta)]\n\ndef simulate_endpoint_theta(L, theta0, g, t_end, rtol=1e-10, atol=1e-12, method=\"DOP853\"):\n    # Integrate one pendulum to time t_end and return theta(t_end)\n    sol = solve_ivp(\n        fun=lambda t, y: pendulum_rhs(t, y, g, L),\n        t_span=(0.0, t_end),\n        y0=[theta0, 0.0],\n        method=method,\n        rtol=rtol,\n        atol=atol,\n        t_eval=[t_end],\n        dense_output=False,\n        vectorized=False,\n    )\n    theta_T = sol.y[0, -1]\n    return theta_T\n\ndef simulate_theta_time_series(L, theta0, g, T, num_points=5001, rtol=1e-11, atol=1e-13, method=\"DOP853\"):\n    # Integrate one pendulum over [0,T] and return time grid and theta(t) array\n    t_eval = np.linspace(0.0, T, num_points)\n    sol = solve_ivp(\n        fun=lambda t, y: pendulum_rhs(t, y, g, L),\n        t_span=(0.0, T),\n        y0=[theta0, 0.0],\n        method=method,\n        rtol=rtol,\n        atol=atol,\n        t_eval=t_eval,\n        dense_output=False,\n        vectorized=False,\n    )\n    return sol.t, sol.y[0, :]\n\ndef compute_lengths_for_alignment(N, g, T_align, K0):\n    # K_n = K0 + N - n yields increasing lengths with n\n    Ks = np.array([K0 + N - n for n in range(1, N + 1)], dtype=float)\n    # L_n = g * (T_align / (2*pi*K_n))^2\n    Ls = g * (T_align / (2.0 * np.pi * Ks))**2\n    return Ls\n\ndef main():\n    # Constants\n    g = 9.81  # m/s^2\n\n    results = []\n\n    # Test case A\n    N_A = 15\n    T_align_A = 60.0  # s\n    K0_A = 46\n    theta0_A = 0.05  # rad\n    Ls_A = compute_lengths_for_alignment(N_A, g, T_align_A, K0_A)\n    deviations_A = []\n    for L in Ls_A:\n        theta_T = simulate_endpoint_theta(L, theta0_A, g, T_align_A)\n        deviations_A.append(abs(theta_T - theta0_A))\n    E_A = float(np.max(deviations_A))\n    results.append(E_A)\n\n    # Test case B (same lengths, larger amplitude)\n    theta0_B = 0.5  # rad\n    deviations_B = []\n    for L in Ls_A:\n        theta_T = simulate_endpoint_theta(L, theta0_B, g, T_align_A)\n        deviations_B.append(abs(theta_T - theta0_B))\n    E_B = float(np.max(deviations_B))\n    results.append(E_B)\n\n    # Test case C (two identical pendula)\n    L_C = 1.0  # m\n    theta0_C = 0.1  # rad\n    T_C = 10.0  # s\n    t_grid, theta1 = simulate_theta_time_series(L_C, theta0_C, g, T_C)\n    _, theta2 = simulate_theta_time_series(L_C, theta0_C, g, T_C)  # identical parameters\n    E_C = float(np.max(np.abs(theta1 - theta2)))\n    results.append(E_C)\n\n    # Print results in required format\n    print(f\"[{','.join(f'{x:.12g}' for x in results)}]\")\n\nif __name__ == \"__main__\":\n    main()\n```"
        }
    ]
}