{
    "hands_on_practices": [
        {
            "introduction": "Before diving into complex signal processing, it's crucial to understand the Discrete Fourier Transform (DFT) at its most fundamental level: as a linear transformation. This first exercise  treats the DFT as a matrix multiplication, allowing you to compute a transformed signal component by hand. By focusing on the first component of the output, you will uncover the special role of the $k=0$ frequency, often called the DC component, and see how it relates directly to the sum of the input signal's values.",
            "id": "976215",
            "problem": "Consider the vector $\\mathbf{v} = (1, 1, 0, 0)$ and let $U$ be the unitary discrete Fourier transform (DFT) matrix of order $N=4$. The unitary DFT matrix $U$ is defined by its entries:\n\n$$\nU_{j,k} = \\frac{1}{\\sqrt{N}} \\exp\\left(-2\\pi i \\frac{jk}{N}\\right),\n$$\n\nwhere $j,k = 0,1,2,\\dots,N-1$, and $i$ is the imaginary unit. The indexing of vectors is 1-based, meaning the first component is at position 1. Compute the squared modulus of the first component of the transformed vector $U\\mathbf{v}$, denoted $\\left| (U\\mathbf{v})_1 \\right|^2$.",
            "solution": "The vector $\\mathbf{v}$ is given as $\\mathbf{v} = \\begin{pmatrix} v_1 \\\\ v_2 \\\\ v_3 \\\\ v_4 \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ 1 \\\\ 0 \\\\ 0 \\end{pmatrix}$. The unitary DFT matrix $U$ for $N=4$ has entries:\n\n$$\nU_{j,k} = \\frac{1}{2} \\exp\\left(-2\\pi i \\frac{(j-1)(k-1)}{4}\\right), \\quad j,k=1,2,3,4,\n$$\n\nsince $\\sqrt{4} = 2$. The first component of $U\\mathbf{v}$ is:\n\n$$\n(U\\mathbf{v})_1 = \\sum_{m=1}^{4} U_{1,m} v_m.\n$$\n\nFor the first row ($j=1$), the exponent simplifies because $j-1=0$:\n\n$$\nU_{1,m} = \\frac{1}{2} \\exp\\left(-2\\pi i \\frac{0 \\cdot (m-1)}{4}\\right) = \\frac{1}{2} \\cdot 1 = \\frac{1}{2}, \\quad m=1,2,3,4.\n$$\n\nSubstituting the values of $\\mathbf{v}$:\n\n$$\n(U\\mathbf{v})_1 = \\sum_{m=1}^{4} \\frac{1}{2} v_m = \\frac{1}{2} v_1 + \\frac{1}{2} v_2 + \\frac{1}{2} v_3 + \\frac{1}{2} v_4 = \\frac{1}{2}(1) + \\frac{1}{2}(1) + \\frac{1}{2}(0) + \\frac{1}{2}(0) = \\frac{1}{2} + \\frac{1}{2} = 1.\n$$\n\nThe squared modulus is:\n\n$$\n\\left| (U\\mathbf{v})_1 \\right|^2 = |1|^2 = 1.\n$$",
            "answer": "$$\\boxed{1}$$"
        },
        {
            "introduction": "The power of the DFT lies in its predictable behavior when the input signal is manipulated. This practice  explores the fundamental time-frequency scaling properties of the DFT by having you computationally verify them. You will investigate how stretching a signal in time (upsampling) and compressing it (downsampling) affects its frequency spectrum, revealing key concepts like spectral repetition and aliasing. Mastering these relationships is essential for applications in multirate signal processing and understanding the consequences of changing a signal's sampling rate.",
            "id": "2431109",
            "problem": "You are given the task of verifying precise relationships between the Discrete Fourier Transform (DFT) of a sequence and the DFTs of versions of the sequence that are compressed or stretched in the discrete-time sense. Work only with finite-length sequences and the DFT as defined below. All indices are integer, and all transforms are computed exactly as finite sums.\n\nDefinition of the Discrete Fourier Transform (DFT): For a sequence $x[n]$ of length $N$, its DFT $X[k]$ is defined by\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n] \\, e^{-j \\, 2\\pi \\, k \\, n / N}, \\quad k=0,1,\\dots,N-1,\n$$\nand the inverse DFT is\n$$\nx[n] = \\frac{1}{N} \\sum_{k=0}^{N-1} X[k] \\, e^{j \\, 2\\pi \\, k \\, n / N}, \\quad n=0,1,\\dots,N-1.\n$$\n\nDefine the following three operations on sequences:\n\n1. Discrete-time expansion (upsampling by factor $L$): Given a sequence $x[n]$ of length $N$ and an integer $L \\ge 1$, define a sequence $y_{\\text{exp}}[n]$ of length $N' = L N$ by\n$$\ny_{\\text{exp}}[n] = \n\\begin{cases}\nx\\!\\left[\\dfrac{n}{L}\\right], & \\text{if } n \\text{ is a multiple of } L, \\\\\n0, & \\text{otherwise},\n\\end{cases}\n\\quad n=0,1,\\dots,N'-1.\n$$\n\n2. Discrete-time compression (downsampling by factor $M$): Given a sequence $x[n]$ of length $N$ and an integer $M \\ge 1$ that divides $N$, define a sequence $y_{\\text{comp}}[n]$ of length $Q = N/M$ by\n$$\ny_{\\text{comp}}[n] = x[M n], \\quad n=0,1,\\dots,Q-1.\n$$\n\n3. Circular index scaling modulo $N$ (with $a$ coprime to $N$): Given a sequence $x[n]$ of length $N$ and an integer $a$ such that $\\gcd(a,N)=1$, define a sequence $y_{\\text{circ}}[n]$ of length $N$ by\n$$\ny_{\\text{circ}}[n] = x[(a n) \\bmod N], \\quad n=0,1,\\dots,N-1.\n$$\n\nYour program must verify the following properties directly from the definitions above, with a numerical absolute tolerance of $\\varepsilon = 10^{-9}$ on complex-valued equality:\n\n- Expansion property: If $Y_{\\text{exp}}[k]$ is the DFT of $y_{\\text{exp}}[n]$ of length $N' = L N$ and $X[k]$ is the DFT of $x[n]$ of length $N$, then\n$$\nY_{\\text{exp}}[k] = X[k \\bmod N], \\quad k=0,1,\\dots,N'-1.\n$$\n\n- Compression property: If $Y_{\\text{comp}}[k]$ is the DFT of $y_{\\text{comp}}[n]$ of length $Q = N/M$ and $X[k]$ is the DFT of $x[n]$ of length $N$, then\n$$\nY_{\\text{comp}}[k] = \\frac{1}{M} \\sum_{r=0}^{M-1} X[k + r Q], \\quad k=0,1,\\dots,Q-1,\n$$\nwhere all indices of $X[\\cdot]$ are taken in the range $0$ to $N-1$ and $Q = N/M$ is an integer.\n\n- Circular index scaling property: If $Y_{\\text{circ}}[k]$ is the DFT of $y_{\\text{circ}}[n]$ of length $N$ and $X[k]$ is the DFT of $x[n]$ of length $N$, then\n$$\nY_{\\text{circ}}[k] = X[(k \\, a^{-1}) \\bmod N], \\quad k=0,1,\\dots,N-1,\n$$\nwhere $a^{-1}$ is the multiplicative inverse of $a$ modulo $N$ (that is, $a \\, a^{-1} \\equiv 1 \\pmod{N}$).\n\nTest Suite. For each test, compute the necessary DFTs and verify the corresponding property by checking that the maximum absolute difference between the two sides is at most $\\varepsilon = 10^{-9}$. Produce one boolean result per test case.\n\n- Test $1$ (Expansion, general): $N=8$, $L=3$, $x[n] = \\cos\\!\\left(2\\pi \\cdot 1 \\cdot n / 8\\right) + \\tfrac{1}{2}\\sin\\!\\left(2\\pi \\cdot 2 \\cdot n / 8\\right)$ for $n=0,1,\\dots,7$.\n\n- Test $2$ (Compression, general): $N=12$, $M=3$, $x[n] = (-1)^n + \\tfrac{1}{4} n$ for $n=0,1,\\dots,11$.\n\n- Test $3$ (Boundary, identity scaling): $N=10$, $a=1$. Define $x[n] = \\cos\\!\\left(2\\pi \\cdot 4 \\cdot n / 10\\right) + \\sin\\!\\left(2\\pi \\cdot 3 \\cdot n / 10\\right)$ for $n=0,1,\\dots,9$. Verify both the expansion property with $L=1$ and the compression property with $M=1$ simultaneously; the test result is true if and only if both verifications succeed at tolerance $\\varepsilon$.\n\n- Test $4$ (Circular scaling, coprime factor): $N=10$, $a=3$ with $\\gcd(3,10)=1$. Define $x[n] = \\cos\\!\\left(2\\pi \\cdot 4 \\cdot n / 10\\right) + \\sin\\!\\left(2\\pi \\cdot 3 \\cdot n / 10\\right)$ for $n=0,1,\\dots,9$.\n\nFinal Output Format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4]\"). Each result must be a boolean corresponding to the tests in the order listed above. No additional text or whitespace is permitted in the output line. No physical units are involved in this problem; all quantities are dimensionless real or complex numbers. Angles in trigonometric functions are in radians.",
            "solution": "The problem statement is subjected to validation and is found to be valid. It is scientifically grounded, well-posed, objective, and self-contained. The problem concerns the verification of standard, well-established properties of the Discrete Fourier Transform (DFT) in the context of digital signal processing and computational physics. The definitions, operations, and claimed properties are stated with mathematical precision and are theoretically sound. We shall now proceed with the solution.\n\nThe core of the problem is to verify three properties of the DFT related to time-domain scaling operations: expansion (upsampling), compression (downsampling), and circular index scaling. We will first provide a brief analytical proof for each property, as rigor dictates, and then outline the numerical procedure for verification.\n\nLet $x[n]$ be a sequence of length $N$, and its DFT be $X[k] = \\sum_{n=0}^{N-1} x[n] e^{-j 2\\pi k n / N}$, where $j = \\sqrt{-1}$.\n\n**1. Expansion Property**\n\nGiven a sequence $x[n]$ of length $N$, the expanded sequence $y_{\\text{exp}}[n]$ of length $N' = LN$ is defined as:\n$$\ny_{\\text{exp}}[n] = \n\\begin{cases}\nx[n/L], & \\text{if } n \\text{ is a multiple of } L, \\\\\n0, & \\text{otherwise}.\n\\end{cases}\n$$\nThe property to verify is $Y_{\\text{exp}}[k] = X[k \\bmod N]$ for $k=0, 1, \\dots, N'-1$.\n\n**Derivation:**\nThe DFT of $y_{\\text{exp}}[n]$ is given by:\n$$\nY_{\\text{exp}}[k] = \\sum_{n=0}^{N'-1} y_{\\text{exp}}[n] e^{-j 2\\pi k n / N'}\n$$\nSince $y_{\\text{exp}}[n]$ is non-zero only for $n$ that are multiples of $L$, we can substitute $n = mL$ where $m$ ranges from $0$ to $N-1$:\n$$\nY_{\\text{exp}}[k] = \\sum_{m=0}^{N-1} y_{\\text{exp}}[mL] e^{-j 2\\pi k (mL) / (LN)}\n$$\nBy definition of $y_{\\text{exp}}$, $y_{\\text{exp}}[mL] = x[m]$. Substituting this into the equation:\n$$\nY_{\\text{exp}}[k] = \\sum_{m=0}^{N-1} x[m] e^{-j 2\\pi k m / N}\n$$\nThe right-hand side is the definition of the DFT of $x[n]$, which we denote as $X[\\cdot]$ evaluated at frequency index $k$. The DFT $X[k]$ is inherently periodic with period $N$, meaning $X[k] = X[k+aN]$ for any integer $a$. Therefore, for any $k$, the expression is equivalent to $X[k \\bmod N]$. Thus, the property $Y_{\\text{exp}}[k] = X[k \\bmod N]$ is correct.\n\n**2. Compression Property**\n\nGiven a sequence $x[n]$ of length $N$ and an integer $M$ that divides $N$, the compressed sequence $y_{\\text{comp}}[n]$ of length $Q = N/M$ is defined as $y_{\\text{comp}}[n] = x[Mn]$ for $n=0, 1, \\dots, Q-1$.\nThe property to verify is $Y_{\\text{comp}}[k] = \\frac{1}{M} \\sum_{r=0}^{M-1} X[k + rQ]$ for $k=0, 1, \\dots, Q-1$.\n\n**Derivation:**\nWe start with the inverse DFT expression for $x[n]$ and substitute it into the definition of $y_{\\text{comp}}[n]$:\n$$\ny_{\\text{comp}}[n] = x[Mn] = \\frac{1}{N} \\sum_{p=0}^{N-1} X[p] e^{j 2\\pi p (Mn) / N}\n$$\nSince $N = MQ$, this simplifies to:\n$$\ny_{\\text{comp}}[n] = \\frac{1}{N} \\sum_{p=0}^{N-1} X[p] e^{j 2\\pi p n / Q}\n$$\nNow, we compute the DFT of $y_{\\text{comp}}[n]$:\n$$\nY_{\\text{comp}}[k] = \\sum_{n=0}^{Q-1} y_{\\text{comp}}[n] e^{-j 2\\pi k n / Q} = \\sum_{n=0}^{Q-1} \\left( \\frac{1}{N} \\sum_{p=0}^{N-1} X[p] e^{j 2\\pi p n / Q} \\right) e^{-j 2\\pi k n / Q}\n$$\nReordering the sums:\n$$\nY_{\\text{comp}}[k] = \\frac{1}{N} \\sum_{p=0}^{N-1} X[p] \\left( \\sum_{n=0}^{Q-1} e^{j 2\\pi (p-k) n / Q} \\right)\n$$\nThe inner sum is a geometric series sum, which equals $Q$ if $p-k$ is a multiple of $Q$ (i.e., $p-k = rQ$ for some integer $r$), and $0$ otherwise. Therefore, we only need to sum over values of $p$ such that $p = k + rQ$. Since $0 \\le p < N$, the possible values of $r$ are $0, 1, \\dots, M-1$.\n$$\nY_{\\text{comp}}[k] = \\frac{1}{N} \\sum_{r=0}^{M-1} X[k+rQ] \\cdot Q\n$$\nSince $Q/N = 1/M$, we arrive at the desired property:\n$$\nY_{\\text{comp}}[k] = \\frac{1}{M} \\sum_{r=0}^{M-1} X[k+rQ]\n$$\nThis confirms the correctness of the compression property.\n\n**3. Circular Index Scaling Property**\n\nGiven a sequence $x[n]$ of length $N$ and an integer $a$ coprime to $N$, the scaled sequence is $y_{\\text{circ}}[n] = x[(an) \\bmod N]$.\nThe property to verify is $Y_{\\text{circ}}[k] = X[(k a^{-1}) \\bmod N]$, where $a a^{-1} \\equiv 1 \\pmod{N}$.\n\n**Derivation:**\nThe DFT of $y_{\\text{circ}}[n]$ is:\n$$\nY_{\\text{circ}}[k] = \\sum_{n=0}^{N-1} y_{\\text{circ}}[n] e^{-j 2\\pi k n / N} = \\sum_{n=0}^{N-1} x[(an) \\bmod N] e^{-j 2\\pi k n / N}\n$$\nSince $\\gcd(a,N)=1$, the mapping $m = (an) \\bmod N$ is a permutation of the set $\\{0, 1, \\dots, N-1\\}$. We can perform a change of summation variable from $n$ to $m$. The inverse mapping is $n = (a^{-1}m) \\bmod N$, where $a^{-1}$ is the multiplicative inverse of $a$ modulo $N$.\n$$\nY_{\\text{circ}}[k] = \\sum_{m=0}^{N-1} x[m] e^{-j 2\\pi k ((a^{-1}m) \\bmod N) / N}\n$$\nDue to the periodicity of the complex exponential, $e^{-j 2\\pi \\theta} = e^{-j 2\\pi (\\theta \\bmod 1)}$, we can remove the modulo operation in the exponent's numerator if we let $a^{-1}_{int}$ be the integer representative of the inverse in $\\{1, \\dots, N-1\\}$:\n$$\nY_{\\text{circ}}[k] = \\sum_{m=0}^{N-1} x[m] e^{-j 2\\pi k (a^{-1}_{int} m) / N} = \\sum_{m=0}^{N-1} x[m] e^{-j 2\\pi (k a^{-1}_{int}) m / N}\n$$\nThis expression is precisely the DFT of $x[m]$ evaluated at the frequency index $k' = (k a^{-1}_{int}) \\bmod N$.\n$$\nY_{\\text{circ}}[k] = X[(k a^{-1}) \\bmod N]\n$$\nThe property is thus analytically correct.\n\n**Numerical Verification Procedure:**\nFor each test case, the verification follows a consistent procedure:\n1.  Generate the base signal $x[n]$ of length $N$ according to the given formula.\n2.  Compute its DFT, $X[k]$, using a standard Fast Fourier Transform (FFT) algorithm, as provided by `numpy.fft.fft`.\n3.  Construct the transformed signal ($y_{\\text{exp}}$, $y_{\\text{comp}}$, or $y_{\\text{circ}}$) according to its definition.\n4.  Compute the DFT of the transformed signal ($Y_{\\text{exp}}$, $Y_{\\text{comp}}$, or $Y_{\\text{circ}}$). This forms the left-hand side (LHS) of the identity.\n5.  Construct the right-hand side (RHS) of the identity using the pre-computed $X[k]$ and the specified formula.\n6.  Calculate the maximum absolute difference between the complex-valued LHS and RHS arrays: $\\max_k | \\text{LHS}[k] - \\text{RHS}[k] |$.\n7.  The property is considered verified if this difference is less than or equal to the specified tolerance $\\varepsilon = 10^{-9}$.\n\nThis procedure is applied to each of the four test cases described in the problem statement. For Test $3$, verification of both the expansion and compression properties for the trivial cases ($L=1$, $M=1$) must succeed for the overall test to be true. The modular multiplicative inverse required for Test $4$ is computed using `pow(a, -1, N)`.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the DFT properties verification problem.\n    \"\"\"\n    epsilon = 1e-9\n    results = []\n\n    # Test 1: Expansion property\n    def test_1():\n        N = 8\n        L = 3\n        n = np.arange(N)\n        x = np.cos(2 * np.pi * 1 * n / N) + 0.5 * np.sin(2 * np.pi * 2 * n / N)\n        X = np.fft.fft(x)\n\n        N_prime = L * N\n        y_exp = np.zeros(N_prime, dtype=np.float64)\n        for n_prime in range(N_prime):\n            if n_prime % L == 0:\n                y_exp[n_prime] = x[n_prime // L]\n        \n        # LHS: DFT of the expanded sequence\n        Y_exp_lhs = np.fft.fft(y_exp)\n\n        # RHS: Periodically repeated original DFT\n        Y_exp_rhs = np.zeros(N_prime, dtype=np.complex128)\n        k_prime = np.arange(N_prime)\n        Y_exp_rhs = X[k_prime % N]\n        \n        max_diff = np.max(np.abs(Y_exp_lhs - Y_exp_rhs))\n        return max_diff <= epsilon\n\n    results.append(test_1())\n\n    # Test 2: Compression property\n    def test_2():\n        N = 12\n        M = 3\n        n = np.arange(N)\n        x = (-1)**n + 0.25 * n\n        X = np.fft.fft(x)\n\n        Q = N // M\n        y_comp = x[::M]\n        \n        # LHS: DFT of the compressed sequence\n        Y_comp_lhs = np.fft.fft(y_comp)\n        \n        # RHS: Sum of aliased components\n        Y_comp_rhs = np.zeros(Q, dtype=np.complex128)\n        for k in range(Q):\n            for r in range(M):\n                Y_comp_rhs[k] += X[k + r * Q]\n        Y_comp_rhs /= M\n        \n        max_diff = np.max(np.abs(Y_comp_lhs - Y_comp_rhs))\n        return max_diff <= epsilon\n\n    results.append(test_2())\n\n    # Test 3: Boundary cases (L=1, M=1)\n    def test_3():\n        N = 10\n        n = np.arange(N)\n        x = np.cos(2 * np.pi * 4 * n / N) + np.sin(2 * np.pi * 3 * n / N)\n        X = np.fft.fft(x)\n\n        # Part A: Expansion with L=1\n        L = 1\n        N_prime = L * N\n        y_exp = x # y_exp is just x\n        Y_exp_lhs = np.fft.fft(y_exp)\n        k_prime = np.arange(N_prime)\n        Y_exp_rhs = X[k_prime % N]\n        check_L1 = np.max(np.abs(Y_exp_lhs - Y_exp_rhs)) <= epsilon\n\n        # Part B: Compression with M=1\n        M = 1\n        Q = N // M\n        y_comp = x # y_comp is just x\n        Y_comp_lhs = np.fft.fft(y_comp)\n        Y_comp_rhs = np.zeros(Q, dtype=np.complex128)\n        for k in range(Q):\n            for r in range(M):\n                Y_comp_rhs[k] += X[k + r * Q]\n        Y_comp_rhs /= M\n        check_M1 = np.max(np.abs(Y_comp_lhs - Y_comp_rhs)) <= epsilon\n        \n        return check_L1 and check_M1\n\n    results.append(test_3())\n\n    # Test 4: Circular index scaling property\n    def test_4():\n        N = 10\n        a = 3\n        n = np.arange(N)\n        x = np.cos(2 * np.pi * 4 * n / N) + np.sin(2 * np.pi * 3 * n / N)\n        X = np.fft.fft(x)\n        \n        # In Python 3.8+, pow(a, -1, m) computes modular inverse\n        a_inv = pow(a, -1, N)\n\n        y_circ = np.zeros(N, dtype=np.float64)\n        for n_val in range(N):\n            y_circ[n_val] = x[(a * n_val) % N]\n\n        # LHS: DFT of the circularly scaled sequence\n        Y_circ_lhs = np.fft.fft(y_circ)\n\n        # RHS: Permuted original DFT\n        Y_circ_rhs = np.zeros(N, dtype=np.complex128)\n        for k in range(N):\n            Y_circ_rhs[k] = X[(k * a_inv) % N]\n        \n        max_diff = np.max(np.abs(Y_circ_lhs - Y_circ_rhs))\n        return max_diff <= epsilon\n\n    results.append(test_4())\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A common technique in practical spectrum analysis is to zero-pad a signal before taking its Fourier transform. This often gives the appearance of a \"higher-resolution\" spectrum, but what does it actually do? This advanced practice  demystifies zero-padding by demonstrating its exact mathematical equivalence to frequency-domain interpolation using the Dirichlet kernel. By completing this exercise, you will gain a deep conceptual insight, understanding that zero-padding doesn't create new information, but rather provides a denser, more detailed view of the signal's existing frequency content.",
            "id": "2431114",
            "problem": "You are given a finite-length discrete-time signal $x_n$ of length $N$, where $n \\in \\{0,1,\\dots,N-1\\}$. Define its length-$N$ Discrete Fourier Transform (DFT) $X^{(N)}_k$ by\n$$\nX^{(N)}_k = \\sum_{n=0}^{N-1} x_n \\, e^{-i 2\\pi k n / N}, \\quad k \\in \\{0,1,\\dots,N-1\\}.\n$$\nDefine the zero-padded sequence $\\tilde{x}_n$ of length $M$ by\n$$\n\\tilde{x}_n = \\begin{cases}\nx_n, & 0 \\le n \\le N-1,\\\\\n0, & N \\le n \\le M-1,\n\\end{cases}\n$$\nand its length-$M$ Discrete Fourier Transform $X^{(M)}_r$ by\n$$\nX^{(M)}_r = \\sum_{n=0}^{M-1} \\tilde{x}_n \\, e^{-i 2\\pi r n / M}, \\quad r \\in \\{0,1,\\dots,M-1\\}.\n$$\nUsing only first principles (the definitions of the Discrete Fourier Transform and its inverse), your program must demonstrate the exact relationship between $X^{(M)}_r$ and the $N$-point spectrum $X^{(N)}_k$ that arises from zero-padding in the time domain. For each test case below, compute two quantities for the same pair $(N,M)$ and sequence $x_n$: \n(1) the length-$M$ spectrum obtained directly from the zero-padded sequence by the definition of the Discrete Fourier Transform, and \n(2) the length-$M$ spectrum expressed entirely in terms of $X^{(N)}_k$ and elementary finite sums implied by the Discrete Fourier Transform and its inverse. \nThen return, for each test case, the maximal absolute difference between these two spectra across all indices $r \\in \\{0,1,\\dots,M-1\\}$, as a floating-point decimal.\n\nTest suite:\n- Case A (general composite real sinusoid): $N=16$, $M=128$, and $x_n = \\cos\\!\\left(2\\pi \\cdot 3.5 \\, n / 16\\right) + 0.6 \\, \\sin\\!\\left(2\\pi \\cdot 5 \\, n / 16\\right)$ for all integer $n$ with $0 \\le n \\le 15$.\n- Case B (Kronecker delta): $N=9$, $M=27$, and $x_n = 1$ if $n=0$ and $x_n=0$ otherwise, for $0 \\le n \\le 8$.\n- Case C (bin-centered complex exponential): $N=10$, $M=100$, and $x_n = e^{i 2\\pi \\cdot 3 \\, n / 10}$ for $0 \\le n \\le 9$.\n- Case D (non-sinusoidal, alternating component): $N=12$, $M=50$, and $x_n = (n+1)/12 + 0.1\\,(-1)^n$ for $0 \\le n \\le 11$.\n\nNo physical units are involved. Angles are in radians. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[resultA,resultB,resultC,resultD]\"). Each entry must be the maximal absolute difference for the corresponding case, represented as a floating-point number.",
            "solution": "Let $x_n$ be given for $n \\in \\{0,1,\\dots,N-1\\}$. The length-$N$ Discrete Fourier Transform (DFT) is\n$$\nX^{(N)}_k = \\sum_{n=0}^{N-1} x_n \\, e^{-i 2\\pi k n / N}, \\quad k=0,1,\\dots,N-1.\n$$\nThe inverse Discrete Fourier Transform (IDFT) on this convention is\n$$\nx_n = \\frac{1}{N}\\sum_{k=0}^{N-1} X^{(N)}_k \\, e^{i 2\\pi k n / N}, \\quad n=0,1,\\dots,N-1.\n$$\nDefine the zero-padded sequence $\\tilde{x}_n$ of length $M \\ge N$ by $\\tilde{x}_n=x_n$ for $0 \\le n \\le N-1$ and $\\tilde{x}_n=0$ for $N \\le n \\le M-1$. Its length-$M$ DFT is\n$$\nX^{(M)}_r = \\sum_{n=0}^{M-1} \\tilde{x}_n \\, e^{-i 2\\pi r n / M} = \\sum_{n=0}^{N-1} x_n \\, e^{-i 2\\pi r n / M}, \\quad r=0,1,\\dots,M-1,\n$$\nsince $\\tilde{x}_n=0$ for $n \\ge N$. Substitute the inverse DFT for $x_n$:\n$$\nX^{(M)}_r = \\sum_{n=0}^{N-1} \\left(\\frac{1}{N} \\sum_{k=0}^{N-1} X^{(N)}_k \\, e^{i 2\\pi k n / N}\\right) e^{-i 2\\pi r n / M}\n= \\frac{1}{N} \\sum_{k=0}^{N-1} X^{(N)}_k \\sum_{n=0}^{N-1} e^{i 2\\pi n \\left(\\frac{k}{N} - \\frac{r}{M}\\right)}.\n$$\nThe inner finite geometric sum is the Dirichlet kernel in complex-exponential form:\n$$\nD_N(\\alpha) \\equiv \\sum_{n=0}^{N-1} e^{i 2\\pi n \\alpha}\n= e^{i \\pi \\alpha (N-1)} \\, \\frac{\\sin(\\pi N \\alpha)}{\\sin(\\pi \\alpha)},\n$$\nwith the continuous extension $D_N(0)=N$ obtained by the limit $\\alpha \\to 0$. Therefore,\n$$\nX^{(M)}_r = \\frac{1}{N} \\sum_{k=0}^{N-1} X^{(N)}_k \\, D_N\\!\\left(\\frac{k}{N}-\\frac{r}{M}\\right).\n$$\nThis shows that $X^{(M)}_r$ is obtained from the length-$N$ DFT samples $X^{(N)}_k$ by interpolation with the Dirichlet kernel, which is a periodic sinc. In other words, zero-padding the time-domain sequence produces a finer sampling in frequency that equals the Dirichlet (periodic sinc) interpolation of the coarse DFT samples. The identity is exact for all integers $N \\ge 1$ and $M \\ge N$ and all sequences $x_n$.\n\nAlgorithmic plan grounded in the above principles:\n- Compute $X^{(M)}_r$ directly from the zero-padded time-domain sequence via the Discrete Fourier Transform definition (implemented by a standard Fast Fourier Transform, which is computationally equivalent to the definition).\n- Separately compute $X^{(N)}_k$ for the original length-$N$ sequence, and then construct\n$$\n\\widehat{X}^{(M)}_r = \\frac{1}{N} \\sum_{k=0}^{N-1} X^{(N)}_k \\, D_N\\!\\left(\\frac{k}{N}-\\frac{r}{M}\\right),\n$$\nwhere $D_N(\\alpha)$ is evaluated either by the finite sum definition or by the closed form above with the continuous extension at $\\alpha=0$.\n- For each test case, report\n$$\n\\max_{0 \\le r \\le M-1} \\left| X^{(M)}_r - \\widehat{X}^{(M)}_r \\right|\n$$\nas a floating-point decimal.\n\nBecause the identity is exact, the reported maximal absolute differences are expected to be at the level of floating-point rounding error (on the order of the machine precision, typically around $10^{-15}$ to $10^{-13}$ for double-precision computations), including at indices where $\\frac{k}{N}-\\frac{r}{M}=0$, for which the limit $D_N(0)=N$ must be used. The test suite covers:\n- A general composite real sinusoid (Case A),\n- A Kronecker delta (Case B),\n- A bin-centered complex exponential (Case C),\n- A non-sinusoidal sequence with an alternating component (Case D).\nIn all cases, the maximal discrepancy should be numerically negligible, validating that zero-padding in the time domain corresponds to Dirichlet (periodic sinc) interpolation in the frequency domain.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef dirichlet_kernel(N: int, alpha: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute D_N(alpha) = sum_{n=0}^{N-1} exp(i 2π n alpha)\n    using the closed-form expression with robust handling at alpha=0.\n\n    Parameters:\n        N: int, sequence length\n        alpha: ndarray of floats, same shape as output\n\n    Returns:\n        ndarray of complex128 with same shape as alpha\n    \"\"\"\n    alpha = np.asarray(alpha, dtype=np.float64)\n    # Compute using closed-form: e^{iπ alpha (N-1)} * sin(π N alpha) / sin(π alpha)\n    numer = np.sin(np.pi * N * alpha)\n    denom = np.sin(np.pi * alpha)\n\n    # General case\n    with np.errstate(divide='ignore', invalid='ignore'):\n        kernel = np.exp(1j * np.pi * alpha * (N - 1)) * (numer / denom)\n\n    # Handle alpha near integer multiples (here only near 0 under our alpha range) where denom ~ 0\n    # Limit as alpha -> 0 is N.\n    mask = np.isclose(denom, 0.0, atol=1e-12)\n    if np.any(mask):\n        kernel = kernel.astype(np.complex128, copy=False)\n        kernel[mask] = N + 0j\n    return kernel\n\ndef zero_padded_spectrum_direct(x: np.ndarray, M: int) -> np.ndarray:\n    \"\"\"\n    Compute the M-point DFT of x zero-padded to length M.\n    \"\"\"\n    N = x.shape[0]\n    padded = np.zeros(M, dtype=np.complex128)\n    padded[:N] = x.astype(np.complex128)\n    return np.fft.fft(padded, n=M)\n\ndef spectrum_interpolated_from_XN(x: np.ndarray, M: int) -> np.ndarray:\n    \"\"\"\n    Compute the M-point spectrum from the N-point spectrum X^{(N)}_k\n    using the Dirichlet-kernel interpolation identity:\n        X^{(M)}_r = (1/N) sum_k X^{(N)}_k D_N(k/N - r/M)\n    \"\"\"\n    N = x.shape[0]\n    XN = np.fft.fft(x, n=N)  # X^{(N)}_k\n    # Build alpha grid: shape (M, N) for r in [0..M-1], k in [0..N-1]\n    r = np.arange(M, dtype=np.float64).reshape(-1, 1)  # (M,1)\n    k = np.arange(N, dtype=np.float64).reshape(1, -1)  # (1,N)\n    alpha = k / N - r / M                              # (M,N)\n    D = dirichlet_kernel(N, alpha)                     # (M,N)\n    X_interp = (D @ XN) / N                            # (M,)\n    return X_interp\n\ndef max_abs_diff_between_methods(x: np.ndarray, M: int) -> float:\n    \"\"\"\n    Compute max_r |X_zp(r) - X_interp(r)| as a float.\n    \"\"\"\n    X_direct = zero_padded_spectrum_direct(x, M)\n    X_interp = spectrum_interpolated_from_XN(x, M)\n    diff = np.abs(X_direct - X_interp)\n    return float(np.max(diff))\n\ndef make_test_cases():\n    \"\"\"\n    Construct the test cases as specified in the problem statement.\n    Returns a list of tuples (x, M) with x as np.ndarray (complex128) of length N.\n    \"\"\"\n    cases = []\n\n    # Case A: N=16, M=128, x_n = cos(2π*3.5*n/16) + 0.6*sin(2π*5*n/16)\n    N_A, M_A = 16, 128\n    nA = np.arange(N_A, dtype=np.float64)\n    xA = np.cos(2.0 * np.pi * 3.5 * nA / N_A) + 0.6 * np.sin(2.0 * np.pi * 5.0 * nA / N_A)\n    cases.append((xA.astype(np.complex128), M_A))\n\n    # Case B: N=9, M=27, Kronecker delta at n=0\n    N_B, M_B = 9, 27\n    xB = np.zeros(N_B, dtype=np.complex128)\n    xB[0] = 1.0 + 0.0j\n    cases.append((xB, M_B))\n\n    # Case C: N=10, M=100, x_n = exp(i 2π*3*n/10)\n    N_C, M_C = 10, 100\n    nC = np.arange(N_C, dtype=np.float64)\n    xC = np.exp(1j * 2.0 * np.pi * 3.0 * nC / N_C)\n    cases.append((xC.astype(np.complex128), M_C))\n\n    # Case D: N=12, M=50, x_n = (n+1)/12 + 0.1*(-1)^n\n    N_D, M_D = 12, 50\n    nD = np.arange(N_D, dtype=np.float64)\n    xD = (nD + 1.0) / 12.0 + 0.1 * ((-1.0) ** nD)\n    cases.append((xD.astype(np.complex128), M_D))\n\n    return cases\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = make_test_cases()\n\n    results = []\n    for x, M in test_cases:\n        result = max_abs_diff_between_methods(x, M)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}