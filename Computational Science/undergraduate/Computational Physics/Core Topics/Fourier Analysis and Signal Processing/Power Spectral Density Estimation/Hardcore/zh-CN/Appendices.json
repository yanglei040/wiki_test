{
    "hands_on_practices": [
        {
            "introduction": "在信号分析中，理解随机噪声的频谱特性是一个基础的出发点。本练习提供了一个动手机会，通过分析一个模拟随机“掷硬币”过程产生的信号，来验证白噪声具有平坦功率谱的理论概念，即其在所有频率上都包含相等的功率。这项实践不仅能加深对随机过程和周期图谱估计的理解，也为从复杂信号中识别非随机成分提供了重要的基准。",
            "id": "2428968",
            "problem": "考虑一个离散时间随机过程，该过程通过对一个独立同分布的公平硬币投掷序列进行采样，并将结果映射到两个固定振幅而获得。设采样间隔为 $\\Delta t$ 秒，因此采样频率为 $1/\\Delta t$ 赫兹。设 $N$ 为样本数量。设两个结果振幅为 $a$ 和 $b$，视为无量纲。设生成的序列为 $s[n] \\in \\{a,b\\}$，其中 $n \\in \\{0,1,\\dots,N-1\\}$，并定义零均值序列 $x[n] = s[n] - \\overline{s}$，其中 $\\overline{s}$ 是 $s[n]$ 的样本均值。定义离散傅里叶变换 $X[k] = \\sum_{n=0}^{N-1} x[n] e^{-i 2\\pi k n / N}$，其中整数 $k \\in \\{0,1,\\dots,N-1\\}$，并为偶数 $N$ 在正频率仓处定义单边功率谱密度估计（单位为振幅平方每赫兹）为\n$$\n\\widehat{S}[k] = \\frac{2\\,\\Delta t}{N} \\left| X[k] \\right|^2 \\quad \\text{for} \\quad k \\in \\{1,2,\\dots,N/2-1\\}.\n$$\n定义平坦度度量为估计的功率谱密度在正频率仓上的变异系数，不包括直流分量仓和 Nyquist 仓，\n$$\nF = \\frac{\\operatorname{std}\\left(\\{\\widehat{S}[k]\\}_{k=1}^{N/2-1}\\right)}{\\operatorname{mean}\\left(\\{\\widehat{S}[k]\\}_{k=1}^{N/2-1}\\right)},\n$$\n该度量是无量纲的。白过程表现为平坦谱，因此随着 $N$ 的增加，预期 $F$ 会减小。\n\n为确保不同实现之间的测试用例具有确定性，序列 $s[n]$ 必须通过转换一个均匀伪随机数生成器来生成，定义如下。设一个整数线性同余生成器通过 $x_{n+1} = (a_{\\mathrm{LCG}} x_n) \\bmod m$ 生成序列 $\\{x_n\\}$，其中 $a_{\\mathrm{LCG}} = 16807$，$m = 2147483647$，从种子 $x_0$ 开始，$x_0$ 是一个小于 $m$ 的严格正整数。定义 $u_n = x_n / m$，如果 $u_n  0.5$ 则设 $s[n] = a$，否则设 $s[n] = b$。谱估计步骤中的所有算术运算必须以实数或复数浮点数进行，且不应应用除上述规定之外的任何额外加窗或平均处理。\n\n实现一个程序，对于每个指定的测试用例，生成 $s[n]$，构造 $x[n]$，计算 $k \\in \\{1,2,\\dots,N/2-1\\}$ 的 $\\widehat{S}[k]$，并以浮点数形式输出平坦度度量 $F$。频率应以赫兹为单位解释，功率谱密度以振幅平方每赫兹为单位解释，但报告的 $F$ 是无量纲的。如果在中间计算中出现角度，必须以弧度为单位。\n\n使用以下参数值的测试套件，其中每个测试用例是一个元组 $(N,\\Delta t,a,b,x_0)$：\n- 测试用例 1：$(4096, 1.0 \\times 10^{-3}, 0, 1, 12345)$。\n- 测试用例 2：$(256, 1.0 \\times 10^{-3}, 0, 1, 67890)$。\n- 测试用例 3：$(65536, 1.0 \\times 10^{-4}, -1, 1, 13579)$。\n- 测试用例 4：$(8192, 1.0, 0, 1, 24680)$。\n\n你的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，顺序与上述测试用例一致。例如，输出格式必须与 $[r_1,r_2,r_3,r_4]$ 完全一样，其中每个 $r_j$ 是为测试用例 $j$ 计算出的 $F$ 的浮点值。",
            "solution": "对所述问题进行验证。\n\n**第1步：提取已知条件**\n-   随机过程：一个离散时间序列 $s[n]$，$n \\in \\{0,1,\\dots,N-1\\}$，源自映射到振幅 $a$ 和 $b$ 的 i.i.d. 公平硬币投掷。\n-   采样参数：采样间隔 $\\Delta t$（秒）；样本数 $N$。\n-   信号生成：线性同余生成器（LCG）定义为 $x_{n+1} = (a_{\\mathrm{LCG}} x_n) \\bmod m$，其中 $a_{\\mathrm{LCG}} = 16807$，$m = 2147483647$。种子 $x_0$ 是一个小于 $m$ 的正整数。生成序列 $u_n = x_n / m$，如果 $u_n  0.5$，则 $s[n] = a$，否则 $s[n] = b$。\n-   零均值信号：$x[n] = s[n] - \\overline{s}$，其中 $\\overline{s} = \\frac{1}{N}\\sum_{n=0}^{N-1} s[n]$。\n-   离散傅里叶变换（DFT）：$X[k] = \\sum_{n=0}^{N-1} x[n] e^{-i 2\\pi k n / N}$，其中 $k \\in \\{0,1,\\dots,N-1\\}$。\n-   功率谱密度（PSD）估计：对于偶数 $N$，单边PSD估计为 $\\widehat{S}[k] = \\frac{2\\,\\Delta t}{N} \\left| X[k] \\right|^2$，其中 $k \\in \\{1,2,\\dots,N/2-1\\}$。\n-   平坦度度量：$F = \\frac{\\operatorname{std}\\left(\\{\\widehat{S}[k]\\}_{k=1}^{N/2-1}\\right)}{\\operatorname{mean}\\left(\\{\\widehat{S}[k]\\}_{k=1}^{N/2-1}\\right)}$。\n-   测试用例 $(N,\\Delta t,a,b,x_0)$:\n    1.  $(4096, 1.0 \\times 10^{-3}, 0, 1, 12345)$\n    2.  $(256, 1.0 \\times 10^{-3}, 0, 1, 67890)$\n    3.  $(65536, 1.0 \\times 10^{-4}, -1, 1, 13579)$\n    4.  $(8192, 1.0, 0, 1, 24680)$\n\n**第2步：使用提取的已知条件进行验证**\n根据验证标准对问题进行评估。\n-   **科学依据**：问题描述了离散信号的功率谱密度估计过程，这是数字信号处理和计算物理学中的一个标准课题。信号模型（一个 Bernoulli 过程）和分析工具（DFT、周期图）都是基本概念。指定的LCG是一个有详细文档记录的生成器。该问题牢固地建立在公认的科学和数学原理之上。\n-   **良态问题**：所有参数、常数和计算步骤都得到了明确无歧义的定义。使用带有给定种子的特定伪随机数生成器确保了信号生成是确定性的，从而为每个测试用例带来唯一的、可计算的解。\n-   **客观性**：问题以精确、客观的数学语言陈述，不含主观论断。定义是形式化的，对所需计算只允许一种正确的解释。\n\n**第3步：结论与行动**\n问题被判定为**有效**。它是自洽的，科学上合理，并且是良态的。该任务是信号分析中的一个标准计算练习。将提供一个解决方案。\n\n**基于原理的解决方案设计**\n\n问题要求计算一个确定性生成的随机信号的估计功率谱密度（PSD）的统计度量，即平坦度 $F$。解决方案是通过遵循所提供的物理和数学定义的顺序来构建的。\n\n**1. 信号生成**\n问题的基础是生成一个离散时间信号 $s[n]$。该信号旨在模仿一个随机过程，使用一个特定的线性同余生成器（LCG）进行确定性地生成。LCG由递推关系定义：\n$$\nx_{i+1} = (a_{\\mathrm{LCG}} \\cdot x_i) \\pmod m\n$$\n其中乘数为 $a_{\\mathrm{LCG}} = 16807$，模数为 $m = 2147483647$。从给定的种子 $x_0$ 开始，我们生成状态序列 $x_0, x_1, \\dots, x_{N-1}$。对于每个时间步 $n$，我们将状态 $x_n$ 归一化为 $u_n = x_n/m$，然后使用一个基于0.5的阈值将此均匀序列映射为具有振幅 $a$ 和 $b$ 的双电平信号 $s[n]$：\n$$\ns[n] = \\begin{cases} a  \\text{if } u_n  0.5 \\\\ b  \\text{if } u_n \\ge 0.5 \\end{cases}\n$$\n\n**2. 信号调理**\n原始信号 $s[n]$ 具有非零均值，这对应于其频谱中的一个大的直流分量（$k=0$）。为了分析信号的波动（交流）部分，需要移除此直流偏移。我们计算样本均值 $\\overline{s} = \\frac{1}{N}\\sum_{n=0}^{N-1} s[n]$ 并创建一个零均值信号 $x[n]$：\n$$\nx[n] = s[n] - \\overline{s}\n$$\n这一步确保了零频率处的功率 $X[0]$ 为零，从而将分析重点放在信号的动态特性上。\n\n**3. 通过离散傅里叶变换进行谱分析**\n离散信号 $x[n]$ 的频率内容通过其离散傅里叶变换（DFT）$X[k]$ 来揭示：\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n] e^{-i 2\\pi k n / N}\n$$\nDFT系数的幅度平方 $|X[k]|^2$ 被称为周期图，它与信号在对应于索引 $k$ 的离散频率上的功率成正比。为了计算效率，DFT使用快速傅里叶变换（FFT）算法进行计算。\n\n**4. 功率谱密度估计**\n周期图必须被正确缩放以表示物理上的功率谱密度，其单位是单位频率的功率（此处为 振幅$^2$/Hz）。对于一个长度为 $N$ 的有限实值信号，远离直流（$k=0$）和 Nyquist 频率（$k=N/2$）的正频率的单边PSD估计 $\\widehat{S}[k]$ 由下式给出：\n$$\n\\widehat{S}[k] = \\frac{2\\,\\Delta t}{N} |X[k]|^2\n$$\n因子 $2$ 是因为将负频率（对于实信号是冗余的）的功率折叠到了正频率上。因子 $\\Delta t / N$ 将单位从每个DFT仓的振幅$^2$ 转换为每赫兹的振幅$^2$，因为DFT的频率分辨率为 $\\Delta f = 1/(N\\Delta t)$。此计算针对频率索引 $k \\in \\{1, 2, \\dots, N/2 - 1\\}$ 执行。\n\n**5. 平坦度度量计算**\n被建模的过程是白噪声过程的一个近似，理论上白噪声具有平坦的功率谱（所有频率上的功率相等）。估计谱的平坦度由平坦度度量 $F$ 来量化，定义为计算出的PSD值集合 $\\{\\widehat{S}[k]\\}$ 的变异系数（标准差与均值的比值）。\n$$\nF = \\frac{\\operatorname{std}\\left(\\{\\widehat{S}[k]\\}_{k=1}^{N/2-1}\\right)}{\\operatorname{mean}\\left(\\{\\widehat{S}[k]\\}_{k=1}^{N/2-1}\\right)}\n$$\n接近 $0$ 的 $F$ 值意味着一个近似恒定（平坦）的谱，而较大的值表示在不同频率仓之间功率有显著变化。对于白噪声的周期图估计，不同频率下的 $\\widehat{S}[k]$ 值近似独立且呈指数分布，其理论变异系数为 $1$。样本变异系数 $F$ 是该值的估计。\n\n该实现将对问题陈述中指定的每个测试用例系统地执行这五个步骤。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the power spectral density flatness problem for a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        (4096, 1.0e-3, 0.0, 1.0, 12345),\n        (256, 1.0e-3, 0.0, 1.0, 67890),\n        (65536, 1.0e-4, -1.0, 1.0, 13579),\n        (8192, 1.0, 0.0, 1.0, 24680),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, delta_t, a, b, x0 = case\n        result = calculate_flatness(N, delta_t, a, b, x0)\n        results.append(result)\n\n    # Format the output as a comma-separated list in brackets.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calculate_flatness(N, delta_t, a, b, x0):\n    \"\"\"\n    Calculates the spectral flatness metric F for a given set of parameters.\n\n    Args:\n        N (int): Number of samples.\n        delta_t (float): Sampling interval in seconds.\n        a (float): First outcome amplitude.\n        b (float): Second outcome amplitude.\n        x0 (int): Seed for the pseudo-random number generator.\n\n    Returns:\n        float: The computed flatness metric F.\n    \"\"\"\n    \n    # LCG parameters from the problem statement\n    A_LCG = 16807\n    M = 2147483647\n\n    # Step 1: Generate the signal sequence s[n] using the LCG.\n    # The problem specifies that u_n = x_n / m, so we use the state x_current\n    # to generate s[n] and then update x_current for the next iteration.\n    s = np.zeros(N, dtype=np.float64)\n    x_current = x0\n    for n in range(N):\n        u_n = x_current / M\n        if u_n  0.5:\n            s[n] = a\n        else:\n            s[n] = b\n        x_current = (A_LCG * x_current) % M\n\n    # Step 2: Create the zero-mean sequence x[n].\n    s_mean = np.mean(s)\n    x = s - s_mean\n\n    # Step 3: Compute the Discrete Fourier Transform (DFT).\n    #\n    # np.fft.fft provides an efficient implementation (FFT).\n    X = np.fft.fft(x)\n\n    # Step 4: Compute the single-sided Power Spectral Density (PSD) estimate.\n    # The problem specifies the range for k from 1 to N/2 - 1.\n    # In Python's 0-based indexing, this corresponds to the slice [1:N//2].\n    # N is guaranteed to be even in all test cases.\n    N_div_2 = N // 2\n    \n    # Extract the relevant DFT components.\n    X_pos = X[1:N_div_2]\n    \n    # Calculate the PSD S_hat[k] = (2 * dt / N) * |X[k]|^2.\n    S_hat = (2 * delta_t / N) * np.abs(X_pos)**2\n\n    # Step 5: Compute the flatness metric F.\n    # F is the coefficient of variation (std/mean) of the PSD values.\n    # np.std uses a divisor of M (number of elements) by default (ddof=0),\n    # which is appropriate here.\n    mean_S = np.mean(S_hat)\n    std_S = np.std(S_hat)\n\n    # Handle the case where the mean is zero to avoid division by zero.\n    if mean_S == 0:\n        return 0.0\n\n    F = std_S / mean_S\n    return F\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "在处理真实数据时，我们总是受限于有限的观测时间，这会在频谱估计中引入被称为“谱泄漏”的人为效应。本练习直接探讨了这一关键的实际问题，展示了谱泄漏如何将一个纯正弦波的能量扩散到多个频率仓中，从而模糊其真实的频谱特征。通过比较矩形窗和汉宁窗的效果，你将亲身体验到窗函数在减轻谱泄漏和提高频率估计精度方面的关键作用。",
            "id": "2429045",
            "problem": "给定一个在时间上均匀采样的纯正弦波，您的任务是使用离散傅里叶变换（DFT）通过功率谱密度估计来演示频谱泄漏。从基本定义开始：一个长度为 $N$ 的离散时间序列 $x[n]$ 的离散傅里叶变换（DFT）是 $X[k] = \\sum_{n=0}^{N-1} x[n] e^{-j 2\\pi kn/N}$，其中 $k \\in \\{0,1,\\dots,N-1\\}$，$j$ 是虚数单位。采样频率为 $F_s$，因此采样间隔为 $\\Delta t = 1/F_s$，DFT的频率分辨率为 $\\Delta f = F_s/N$。加窗由一个实数序列 $w[n]$ 定义，它逐点应用于 $x[n]$，产生 $x_w[n]=w[n]x[n]$。使用离散时间下的能量守恒（Parseval 关系）以及这些定义，构建一个具有适当窗函数功率归一化的功率谱密度（PSD）的单边周期图估计器。所有三角函数参数必须以弧度为单位。\n\n您的程序必须：\n- 构建离散时间信号 $x[n] = \\sin(2\\pi f_0 n / F_s)$，对于 $n \\in \\{0,1,\\dots,N-1\\}$。\n- 应用一个选定的窗函数 $w[n]$（矩形窗 $w[n]=1$ 或 Hann 窗 $w[n] = \\frac{1}{2}\\left(1 - \\cos\\left(\\frac{2\\pi n}{N-1}\\right)\\right)$）来形成 $x_w[n]=w[n]x[n]$。\n- 计算一个 $N$ 点DFT（无零填充），并为频率 $f_k = k \\Delta f$（其中 $k \\in \\{0,1,\\dots,\\tfrac{N}{2}\\}$）形成一个单边周期图PSD估计 $P[k]$，使用基于窗函数均方值的窗函数功率归一化。确保当 $N$ 为偶数时，单边谱通过将严格介于直流（DC）和奈奎斯特频率之间的频率仓的功率加倍，来正确地计入被丢弃的负频率内容。\n- 将泄漏比 $\\mathcal{L}$ 定义为总单边频谱功率中位于峰值周围主瓣之外的部分，其中主瓣在操作上定义为PSD值在峰值 $-6$ 分贝范围内的频率仓集合。用符号表示：找到峰值仓索引 $k_{\\max}$ 使得 $P[k_{\\max}]$ 最大；定义主瓣索引集 $\\mathcal{M} = \\{k : 10 \\log_{10}(P[k]/P[k_{\\max}]) \\ge -6\\}$；然后计算泄漏比 $\\mathcal{L} = 1 - \\dfrac{\\sum_{k \\in \\mathcal{M}} P[k]}{\\sum_{k} P[k]}$。分贝转换使用 $10 \\log_{10}(\\cdot)$ 应用于功率比。\n- 对于每个测试用例，输出泄漏比，形式为一个浮点数。正弦波的振幅为 $1$。\n\n测试套件：\n- 案例 $1$ (非整数仓，矩形窗): $F_s = 1024 \\,\\mathrm{Hz}$, $N = 1024$, $f_0 = 128.5 \\,\\mathrm{Hz}$, 窗类型 “rectangular”。\n- 案例 $2$ (非整数仓，Hann 窗): $F_s = 1024 \\,\\mathrm{Hz}$, $N = 1024$, $f_0 = 128.5 \\,\\mathrm{Hz}$, 窗类型 “Hann”。\n- 案例 $3$ (精确仓，矩形窗): $F_s = 1024 \\,\\mathrm{Hz}$, $N = 1024$, $f_0 = 128.0 \\,\\mathrm{Hz}$, 窗类型 “rectangular”。\n- 案例 $4$ (小偏移，矩形窗): $F_s = 1024 \\,\\mathrm{Hz}$, $N = 1024$, $f_0 = 128.01 \\,\\mathrm{Hz}$, 窗类型 “rectangular”。\n- 案例 $5$ (短记录，非整数仓，矩形窗): $F_s = 256 \\,\\mathrm{Hz}$, $N = 256$, $f_0 = 50.3 \\,\\mathrm{Hz}$, 窗类型 “rectangular”。\n\n角度单位要求：所有用于三角函数的角度必须是弧度。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含按上述顺序列出的五个案例的泄漏比，格式为用方括号括起来的逗号分隔列表，每个泄漏比四舍五入到六位小数，例如，“$[0.123456,0.234567,0.345678,0.456789,0.567890]$”。",
            "solution": "所提出的问题是计算物理领域，特别是在数字信号处理领域中，一个有效且适定的练习。它要求在不同条件下，从纯正弦波信号的周期图估计中计算频谱泄漏。所提供的定义是标准的、自洽的，能够得出一个直接而明确的解。\n\n解决方案从基本原理出发，系统地进行。\n\n**1. 信号与加窗模型**\n\n离散时间信号是一个振幅为 $A=1$ 的纯正弦波，以频率 $F_s$ 在 $N$ 个点上采样。该信号定义为：\n$$x[n] = \\sin\\left(\\frac{2\\pi f_0 n}{F_s}\\right), \\quad n \\in \\{0, 1, \\dots, N-1\\}$$\n其中 $f_0$ 是正弦波的频率。\n\n该信号随后与一个窗函数 $w[n]$ 相乘，得到加窗信号 $x_w[n]$：\n$$x_w[n] = w[n] x[n]$$\n问题指定了两种窗类型：\n- **矩形窗**：对于所有 $n$，$w[n] = 1$。\n- **Hann 窗**：$w[n] = \\frac{1}{2}\\left(1 - \\cos\\left(\\frac{2\\pi n}{N-1}\\right)\\right)$。\n\n**2. 功率谱估计**\n\n问题的核心是构建一个适当归一化的单边功率谱。我们从加窗信号的离散傅里叶变换（DFT）开始：\n$$X_w[k] = \\sum_{n=0}^{N-1} x_w[n] e^{-j 2\\pi kn/N}$$\n\n为确保估计的功率独立于窗函数的增益，我们必须对频谱进行归一化。Parseval 定理对于离散信号，将信号在时域中的能量与其在频域中的能量联系起来：\n$$\\sum_{n=0}^{N-1} |x_w[n]|^2 = \\frac{1}{N} \\sum_{k=0}^{N-1} |X_w[k]|^2$$\n加窗信号在 $N$ 个采样点上的平均功率是 $P_{\\text{avg},w} = \\frac{1}{N} \\sum_{n=0}^{N-1} |x_w[n]|^2$。因此：\n$$P_{\\text{avg},w} = \\frac{1}{N^2} \\sum_{k=0}^{N-1} |X_w[k]|^2$$\n原始信号 $x[n]$ 的平均功率与加窗信号的平均功率相关。对于正弦信号，加窗过程会按一个等于窗函数均方值的因子来缩放功率。因此，原始信号的估计平均功率 $P_{\\text{avg},x}$ 为：\n$$P_{\\text{avg},x} = \\frac{P_{\\text{avg},w}}{\\frac{1}{N}\\sum_{n=0}^{N-1} w[n]^2} = \\frac{N}{\\sum_{n=0}^{N-1} w[n]^2} P_{\\text{avg},w}$$\n我们用 $S_2 = \\sum_{n=0}^{N-1} w[n]^2$ 表示窗权重平方和。原始信号的总估计功率为：\n$$P_{\\text{total}} = P_{\\text{avg},x} = \\frac{N}{S_2} \\left( \\frac{1}{N^2} \\sum_{k=0}^{N-1} |X_w[k]|^2 \\right) = \\frac{1}{S_2 N} \\sum_{k=0}^{N-1} |X_w[k]|^2$$\n对于一个实值输入信号 $x[n]$，其DFT是共轭对称的：$X_w[k] = X_w^*[N-k]$。这意味着 $|X_w[k]|^2 = |X_w[N-k]|^2$。我们可以为 $k \\in \\{0, 1, \\dots, N/2\\}$ 构建一个保持总功率的单边功率谱 $P[k]$。对双边谱的求和可以重写为（对于偶数 $N$）：\n$$\\sum_{k=0}^{N-1} |X_w[k]|^2 = |X_w[0]|^2 + |X_w[N/2]|^2 + 2\\sum_{k=1}^{N/2-1} |X_w[k]|^2$$\n我们定义单边功率谱 $P[k]$，使其和等于总平均功率 $P_{\\text{total}}$。$P[k]$ 的分量是包含在每个频率仓 $k$ 中的功率：\n$$P[k] = \\begin{cases} \\frac{1}{S_2 N} |X_w[k]|^2  \\text{对于 } k=0 \\text{ 和 } k=N/2 \\\\ \\frac{2}{S_2 N} |X_w[k]|^2  \\text{对于 } k=1, 2, \\dots, N/2-1 \\end{cases}$$\n和 $\\sum_{k=0}^{N/2} P[k]$ 正确地得出了原始信号的总平均功率。鉴于 $x[n]$ 是一个振幅为 $A=1$ 的正弦波，其真实平均功率为 $A^2/2 = 1/2$。我们的估计量 $\\sum P[k]$ 将近似于这个值。\n\n**3. 泄漏比计算**\n\n频谱泄漏比 $\\mathcal{L}$ 定义为位于频谱峰值主瓣之外的总功率部分。\n首先，我们找到功率谱的最大值，$P_{\\max} = \\max_k P[k]$。主瓣在操作上被定义为功率在峰值 $-6$ 分贝范围内的频率仓集合 $\\mathcal{M}$：\n$$\\mathcal{M} = \\left\\{k \\mid 10 \\log_{10}\\left(\\frac{P[k]}{P_{\\max}}\\right) \\ge -6\\right\\}$$\n这个不等式等价于 $P[k] \\ge P_{\\max} \\cdot 10^{-0.6}$。\n\n主瓣中的总功率为 $P_{\\text{lobe}} = \\sum_{k \\in \\mathcal{M}} P[k]$。整个频谱的总功率为 $P_{\\text{total}} = \\sum_{k=0}^{N/2} P[k]$。\n泄漏比随后计算为：\n$$\\mathcal{L} = 1 - \\frac{P_{\\text{lobe}}}{P_{\\text{total}}}$$\n\n对每个测试用例实施此程序，以确定在指定条件下的泄漏比。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the spectral leakage ratio for a sinusoidal signal under various\n    windowing and frequency conditions.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (Fs, N, f0, window_type)\n        (1024.0, 1024, 128.5, \"rectangular\"),\n        (1024.0, 1024, 128.5, \"Hann\"),\n        (1024.0, 1024, 128.0, \"rectangular\"),\n        (1024.0, 1024, 128.01, \"rectangular\"),\n        (256.0, 256, 50.3, \"rectangular\"),\n    ]\n\n    results = []\n    for case in test_cases:\n        Fs, N, f0, window_type = case\n        \n        # 1. Signal Generation\n        # Construct the time vector for N samples.\n        n = np.arange(N)\n        # Generate the sinusoidal signal with amplitude 1.\n        x = np.sin(2 * np.pi * f0 * n / Fs)\n\n        # 2. Windowing\n        # Apply the specified window function.\n        if window_type == \"rectangular\":\n            w = np.ones(N)\n        elif window_type == \"Hann\":\n            # Per problem: w[n] = 1/2 * (1 - cos(2*pi*n / (N-1)))\n            w = 0.5 * (1 - np.cos(2 * np.pi * n / (N - 1)))\n        \n        x_w = x * w\n\n        # 3. N-point DFT\n        # Compute the DFT of the windowed signal.\n        X_w = np.fft.fft(x_w, n=N)\n\n        # 4. One-sided Power Spectrum Estimation\n        # All test cases have even N. The one-sided spectrum has N/2 + 1 points.\n        num_freq_bins = N // 2 + 1\n        X_w_mag_sq = np.abs(X_w[0:num_freq_bins])**2\n        \n        # Calculate the sum of squares of the window for normalization.\n        S2 = np.sum(w**2)\n        \n        # Initialize the power spectrum array.\n        P = np.zeros(num_freq_bins)\n        \n        # Normalization ensures the sum of P[k] approximates the true signal power (0.5).\n        # Normalization constant for DC and Nyquist bins.\n        norm_const_dc_nyquist = 1.0 / (S2 * N)\n        # Normalization constant for other bins (doubled for one-sided spectrum).\n        norm_const_other = 2.0 / (S2 * N)\n\n        # Calculate power for bins from k=1 to k=N/2 - 1.\n        P[1:-1] = norm_const_other * X_w_mag_sq[1:-1]\n        \n        # Calculate power for DC (k=0) and Nyquist (k=N/2) bins.\n        P[0] = norm_const_dc_nyquist * X_w_mag_sq[0]\n        P[-1] = norm_const_dc_nyquist * X_w_mag_sq[-1]\n\n        # 5. Leakage Ratio Calculation\n        P_total = np.sum(P)\n        \n        # Handle the ideal case where total power is numerically zero.\n        if P_total  1e-15:\n            leakage_ratio = 0.0\n        else:\n            P_max = np.max(P)\n            # Main lobe is defined as all bins within -6 dB of the peak value.\n            # This corresponds to a linear magnitude ratio of 10^(-6/10).\n            db_threshold_ratio = 10**(-6.0 / 10.0)\n            main_lobe_mask = P >= P_max * db_threshold_ratio\n            \n            # Sum the power within the main lobe.\n            P_lobe = np.sum(P[main_lobe_mask])\n            \n            # Leakage ratio is the fraction of power outside the main lobe.\n            leakage_ratio = 1.0 - (P_lobe / P_total)\n            \n        results.append(leakage_ratio)\n\n    # Final print statement in the exact required format.\n    # Format each result to six decimal places.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "许多物理系统表现出非线性行为，导致诸如频率混合等现象，即系统中会产生新的频率成分。本练习模拟了这样一个过程，通过对一个包含两个正弦波的信号进行平方运算——这是一个简单的非线性检波器的常见模型。你将使用更稳健的韦尔奇方法来分析得到的信号，并从中发现理论上预测的和频与差频成分，这展示了功率谱密度估计如何成为探索系统内部物理规律的强大工具。",
            "id": "2429016",
            "problem": "您将使用功率谱密度估计，在离散时域中实现并分析一个非线性混频实验。您必须依赖的基础理论包括：傅里叶变换作为连接时域和频域描述的线性变换的定义，奈奎斯特采样定理（该定理约束了在给定采样率下可分辨的频率），功率谱密度（PSD）作为自相关函数的傅里叶变换的定义（Wiener–Khinchin 定理），以及时域中的乘法对应于频域中的卷积这一性质。在您的推导中，不得使用任何其他预先推导的或简化的公式。角度必须以弧度为单位。\n\n构建一个离散时间信号，该信号是具有用户指定的频率、采样率和相位的两个正弦波之和。添加零均值白高斯噪声，对带噪信号进行平方，使用 Welch 方法估计平方信号的单边功率谱密度（PSD），并检测由非线性混频预测出的和频与差频对应的频谱峰值。\n\n任务和约束：\n- 信号模型和单位：\n  - 设采样频率为 $f_s$（单位 $\\mathrm{Hz}$），样本数为 $N$（无量纲）。定义离散时间点为 $t_n = n / f_s$（单位 $\\mathrm{s}$），其中 $n \\in \\{0,1,\\dots,N-1\\}$。\n  - 构建一个纯净信号 $x[n] = A_1 \\sin\\!\\left(2\\pi f_1 t_n + \\phi_1\\right) + A_2 \\sin\\!\\left(2\\pi f_2 t_n + \\phi_2\\right)$，其中 $A_1$ 和 $A_2$ 是振幅（无量纲），$f_1$ 和 $f_2$ 是频率（单位 $\\mathrm{Hz}$），$\\phi_1, \\phi_2$ 是相位（单位 $\\mathrm{rad}$）。\n  - 添加标准差为 $\\sigma_n$（无量纲）的零均值白高斯噪声 $\\eta[n]$，形成 $u[n] = x[n] + \\eta[n]$。\n  - 形成平方信号 $y[n] = \\left(u[n]\\right)^2$。\n- PSD 估计：\n  - 使用 Welch 方法和 Hann 窗估计单边 PSD $S_{yy}(f)$。使用一个段长度 $L$，其值为不超过 $N/2$ 的最大 2 的幂，但至少为 256 个样本。使用段长度的 $0.5$ 重叠。使用密度缩放，以使 $S_{yy}(f)$ 的单位为信号功率/$\\mathrm{Hz}$。\n  - 频率轴必须以 $\\mathrm{Hz}$ 为单位。\n- 非线性混频的峰值检测：\n  - 定义理论目标频率 $f_{\\mathrm{sum}} = f_1 + f_2$ 和 $f_{\\mathrm{diff}} = |f_1 - f_2|$，单位均为 $\\mathrm{Hz}$。确保所有指定情况都满足 $f_{\\mathrm{sum}} \\le f_s/2$，这样和频分量就不会超出奈奎斯特频率。\n  - 设 Welch 频率仓间距为 $\\Delta f = f_s / L$。对于每个目标频率 $f_0 \\in \\{f_{\\mathrm{sum}}, f_{\\mathrm{diff}}\\}$，在 $f_0$ 周围一个半宽为 $w = \\max\\{5, 3\\Delta f\\}$（单位 $\\mathrm{Hz}$）的对称频率窗口内搜索主要的 PSD 峰值。如果 $f_0 = 0$，则在 $[0, w]$ 范围内搜索。\n  - 设正确检测的容差为 $\\tau = \\max\\{\\Delta f, 0.5\\}$（单位 $\\mathrm{Hz}$）。如果估计的峰值位置 $\\hat f$ 与目标 $f_0$ 之间的绝对差最多为 $\\tau$，则报告一个为“真”的检测布尔值。\n- 输出规范：\n  - 对于每个测试用例，返回一个包含四个值的列表：估计的和频峰值 $\\hat f_{\\mathrm{sum}}$（单位 $\\mathrm{Hz}$，四舍五入到三位小数），估计的差频峰值 $\\hat f_{\\mathrm{diff}}$（单位 $\\mathrm{Hz}$，四舍五入到三位小数），和频分量的检测布尔值，以及差频分量的检测布尔值。\n  - 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。顶层列表必须为每个测试用例包含一个这样的四元素列表。例如，总输出必须看起来像 $[\\,[\\hat f_{\\mathrm{sum}}^{(1)}, \\hat f_{\\mathrm{diff}}^{(1)}, \\mathrm{det}_{\\mathrm{sum}}^{(1)}, \\mathrm{det}_{\\mathrm{diff}}^{(1)}], \\dots ]$。\n- 角度单位：所有角度必须以 $\\mathrm{rad}$ 为单位。所有频率必须以 $\\mathrm{Hz}$ 表示。\n\n测试套件：\n对于每个测试用例，参数元组为 $(f_s, N, f_1, f_2, A_1, A_2, \\sigma_n, \\mathrm{seed})$，其值如下：\n- 情况 1：$(2000, 4096, 123, 278, 1.0, 0.8, 0.2, 42)$，因此 $f_{\\mathrm{sum}} = 401$ 且 $f_{\\mathrm{diff}} = 155$。\n- 情况 2：$(1200, 4096, 280, 300, 1.0, 1.0, 0.15, 7)$，因此 $f_{\\mathrm{sum}} = 580$ 且 $f_{\\mathrm{diff}} = 20$。\n- 情况 3：$(1000, 4096, 200, 200, 0.7, 0.7, 0.1, 0)$，因此 $f_{\\mathrm{sum}} = 400$ 且 $f_{\\mathrm{diff}} = 0$。\n- 情况 4：$(2000, 16384, 245, 250, 0.9, 1.0, 0.3, 123)$，因此 $f_{\\mathrm{sum}} = 495$ 且 $f_{\\mathrm{diff}} = 5$。\n\n要求：\n- 将您的解决方案实现为一个完整的、可运行的程序，该程序能够构建信号，使用指定的 Welch 配置计算 PSD 估计，按规定在 $f_{\\mathrm{sum}}$ 和 $f_{\\mathrm{diff}}$ 附近搜索峰值，并以所描述的精确格式输出结果。使用提供的种子进行随机数生成，以确保可复现性。",
            "solution": "所提出的问题是计算物理和信号处理领域中一个定义明确的练习。它要求实现一个数值实验来演示非线性混频现象。在进行计算求解之前，必须先建立分析所依据的理论基础。问题陈述被认为是有效的，因为它具有科学依据、自成体系且在算法上是明确的。关于信号相位的一个小模糊之处，通过采用将其设置为零的标准约定得以解决，因为在指定条件下，所得信号的功率谱对此选择基本不敏感。\n\n问题的核心在于对复合正弦信号进行平方，这是一个非线性操作。让我们首先在没有噪声的情况下分析此操作的效果。信号由 $x[n] = A_1 \\sin(2\\pi f_1 t_n + \\phi_1) + A_2 \\sin(2\\pi f_2 t_n + \\phi_2)$ 给出。为简单起见，且不失此功率谱分析的一般性，我们设置相位 $\\phi_1=0$ 和 $\\phi_2=0$。记 $\\omega_i = 2\\pi f_i$ 和 $t_n = n/f_s$，平方后的信号为：\n$$\ny[n] = (x[n])^2 = \\left( A_1 \\sin(\\omega_1 t_n) + A_2 \\sin(\\omega_2 t_n) \\right)^2\n$$\n展开此表达式可得：\n$$\ny[n] = A_1^2 \\sin^2(\\omega_1 t_n) + A_2^2 \\sin^2(\\omega_2 t_n) + 2 A_1 A_2 \\sin(\\omega_1 t_n) \\sin(\\omega_2 t_n)\n$$\n我们应用标准三角恒等式：$\\sin^2\\theta = \\frac{1}{2}(1 - \\cos(2\\theta))$ 和 $\\sin\\alpha\\sin\\beta = \\frac{1}{2}(\\cos(\\alpha-\\beta) - \\cos(\\alpha+\\beta))$。代入这些可得：\n$$\ny[n] = \\frac{A_1^2}{2} (1 - \\cos(2\\omega_1 t_n)) + \\frac{A_2^2}{2} (1 - \\cos(2\\omega_2 t_n)) + A_1 A_2 \\left(\\cos((\\omega_1 - \\omega_2)t_n) - \\cos((\\omega_1 + \\omega_2)t_n)\\right)\n$$\n根据频率内容收集各项，我们发现：\n$$\ny[n] = \\underbrace{\\frac{A_1^2 + A_2^2}{2}}_{\\text{在 } 0\\,\\mathrm{Hz} \\text{ 的直流分量}} - \\underbrace{\\frac{A_1^2}{2}\\cos(2\\omega_1 t_n) - \\frac{A_2^2}{2}\\cos(2\\omega_2 t_n)}_{\\text{在 } 2f_1, 2f_2 \\text{ 的二次谐波}} + \\underbrace{A_1 A_2 \\cos((\\omega_1 - \\omega_2)t_n)}_{\\text{在 } |f_1-f_2| \\text{ 的差频}} - \\underbrace{A_1 A_2 \\cos((\\omega_1 + \\omega_2)t_n)}_{\\text{在 } f_1+f_2 \\text{ 的和频}}\n$$\n此推导严谨地表明，非线性平方运算会产生新的频谱分量。具体来说，我们期望在和频 $f_{\\mathrm{sum}} = f_1+f_2$ 和差频 $f_{\\mathrm{diff}} = |f_1-f_2|$ 处看到功率集中。问题要求检测这两个分量。\n\n引入加性白高斯噪声 $\\eta[n]$ 会改变待平方的信号：$u[n] = x[n] + \\eta[n]$。得到的信号是 $y[n] = u[n]^2 = x[n]^2 + 2x[n]\\eta[n] + \\eta[n]^2$。项 $x[n]^2$ 包含上述推导出的确定性峰值。交叉项 $2x[n]\\eta[n]$ 和噪声平方项 $\\eta[n]^2$ 会导致功率谱中噪声基底的展宽，从而使峰值检测变得复杂。$\\eta[n]^2$ 项作为一个零均值高斯过程的平方，其均值非零 $\\mathbb{E}[\\eta[n]^2] = \\sigma_n^2$，这会增加 $y[n]$ 的直流分量。\n\n为了估计功率谱密度（PSD）$S_{yy}(f)$，我们按照规定采用 Welch 方法。该方法可以减轻像周期图这样的简单估计器所固有的高方差。步骤如下：\n$1$. 将长度为 $N$ 的信号 $y[n]$ 分割成长度为 $L$ 的重叠段。\n$2$. 每个段都乘以一个窗函数（在此情况下为 Hann 窗），以减少由有限段长度引起的频谱泄漏。\n$3$. 对每个加窗段计算快速傅里叶变换（FFT），其结果的幅值平方提供了该段的周期图。\n$4$. 最终的 PSD 估计通过对所有段的周期图进行平均得到。应用归一化以产生单位为功率/赫兹的单边 PSD。\n\n每个测试用例的计算实现将按以下步骤进行：\n$1$. **信号生成**：创建一个离散时间向量 $t_n$。使用提供的参数合成无噪声信号 $x[n]$。使用指定的种子和标准差 $\\sigma_n$ 生成零均值高斯噪声 $\\eta[n]$，并将其加到 $x[n]$ 上形成 $u[n]$。用于分析的最终信号是 $y[n] = u[n]^2$。\n$2$. **PSD 估计**：段长度 $L$ 被确定为不超过 $N/2$ 的最大 2 的幂，且最小为 256。使用 `scipy.signal.welch` 函数计算单边 PSD $S_{yy}(f)$，配置为使用 Hann 窗、50% 重叠和 'density' 缩放。\n$3$. **峰值检测**：对于每个目标频率 $f_0 \\in \\{f_{\\mathrm{sum}}, f_{\\mathrm{diff}}\\}$，其中 $f_{\\mathrm{sum}} = f_1+f_2$ 且 $f_{\\mathrm{diff}} = |f_1-f_2|$，进行搜索以找到最大 PSD 值。搜索在频率窗口 $[f_0 - w, f_0 + w]$ 内执行，其中半宽 $w = \\max\\{5, 3\\Delta f\\}$ 且 $\\Delta f = f_s/L$ 是 Welch 估计的频率分辨率。对于 $f_0=0$ 的特殊情况，搜索窗口为 $[0, w]$。\n$4$. **结果验证**：将检测到的峰值对应的频率 $\\hat{f}$ 与理论目标 $f_0$ 进行比较。如果 $|\\hat{f} - f_0| \\le \\tau$，则认为检测成功，其中容差 $\\tau = \\max\\{\\Delta f, 0.5\\}$。\n$5$. **输出格式化**：收集发现的峰值频率 $\\hat{f}_{\\mathrm{sum}}$ 和 $\\hat{f}_{\\mathrm{diff}}$（四舍五入到三位小数）及其对应的布尔检测状态，并按规定格式化。\n\n这种结构化的方法确保了分析严格按照问题要求进行，并基于成熟的信号处理原理。",
            "answer": "```python\nimport numpy as np\nfrom scipy.signal import welch\n\ndef solve():\n    \"\"\"\n    Implements and analyzes a nonlinear frequency-mixing experiment.\n    \"\"\"\n    # Test cases: (fs, N, f1, f2, A1, A2, sigma_n, seed)\n    test_cases = [\n        (2000, 4096, 123, 278, 1.0, 0.8, 0.2, 42),\n        (1200, 4096, 280, 300, 1.0, 1.0, 0.15, 7),\n        (1000, 4096, 200, 200, 0.7, 0.7, 0.1, 0),\n        (2000, 16384, 245, 250, 0.9, 1.0, 0.3, 123),\n    ]\n\n    results = []\n\n    def find_peak(freqs, syy, f_target, w, tau):\n        \"\"\"\n        Searches for a peak in the PSD within a specified window and validates it.\n        \"\"\"\n        if f_target == 0:\n            search_min, search_max = 0.0, w\n        else:\n            search_min, search_max = f_target - w, f_target + w\n        \n        search_indices = np.where((freqs >= search_min)  (freqs = search_max))[0]\n        \n        if len(search_indices) == 0:\n            f_peak = -1.0  # Sentinel for not found\n            detected = False\n        else:\n            peak_idx_local = np.argmax(syy[search_indices])\n            peak_idx_global = search_indices[peak_idx_local]\n            f_peak = freqs[peak_idx_global]\n            detected = abs(f_peak - f_target) = tau\n            \n        return f_peak, detected\n\n    for case in test_cases:\n        fs, N, f1, f2, A1, A2, sigma_n, seed = case\n        \n        # As phases are not specified, they are set to 0 radians.\n        phi1, phi2 = 0.0, 0.0\n\n        # Step 1: Signal Generation\n        t = np.arange(N) / fs\n        x_n = A1 * np.sin(2 * np.pi * f1 * t + phi1) + A2 * np.sin(2 * np.pi * f2 * t + phi2)\n        \n        rng = np.random.default_rng(seed)\n        eta_n = rng.normal(loc=0.0, scale=sigma_n, size=N)\n        u_n = x_n + eta_n\n        \n        y_n = u_n**2\n        \n        # Step 2: PSD Estimation using Welch's method\n        l0 = 2**int(np.log2(N / 2))\n        L = max(l0, 256)\n        n_overlap = L // 2\n        \n        freqs, Syy = welch(\n            y_n,\n            fs=fs,\n            window='hann',\n            nperseg=L,\n            noverlap=n_overlap,\n            scaling='density',\n            return_onesided=True\n        )\n        \n        # Step 3  4: Peak Detection and Validation\n        f_sum_target = f1 + f2\n        f_diff_target = abs(f1 - f2)\n        \n        delta_f = fs / L\n        w = max(5, 3 * delta_f)\n        tau = max(delta_f, 0.5)\n        \n        f_sum_peak, sum_detected = find_peak(freqs, Syy, f_sum_target, w, tau)\n        f_diff_peak, diff_detected = find_peak(freqs, Syy, f_diff_target, w, tau)\n\n        results.append([\n            round(f_sum_peak, 3), \n            round(f_diff_peak, 3), \n            sum_detected, \n            diff_detected\n        ])\n\n    # Final print statement in the exact required format.\n    inner_strs = []\n    for res in results:\n        f_sum_p, f_diff_p, s_det, d_det = res\n        inner_strs.append(f\"[{f_sum_p},{f_diff_p},{str(s_det).lower()},{str(d_det).lower()}]\")\n    print(f\"[{','.join(inner_strs)}]\")\n\nsolve()\n```"
        }
    ]
}