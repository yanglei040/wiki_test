{
    "hands_on_practices": [
        {
            "introduction": "在深入研究快速傅里叶变换 (FFT) 的高效算法之前，首先构建一个坚实的理论基础至关重要。本练习将带您回到离散傅里叶变换 (DFT) 的基本定义，即将其视为一个矩阵向量乘法。通过亲手实现这个“慢速”但直观的变换 ，并用它来验证一个标准库中的“快速”FFT函数，您不仅能深刻理解DFT的数学本质，还能掌握计算科学中一项关键的技能：通过参照实现来对优化代码进行测试和验证。",
            "id": "2391694",
            "problem": "您需要实现并使用一个基于线性代数定义的参考离散傅里叶变换，以在小规模问题上验证一个现成的快速傅里叶变换 (FFT) 实现的正确性。请从以下基本原则出发：\n\n- 复指数 $e^{j 2 \\pi k n / N}$ 在离散网格 $n \\in \\{0,1,\\dots,N-1\\}$ 上，关于离散内积构成一个正交基，并且它们在 $n$ 和 $k$ 上是 $N$-周期的。\n- 离散傅里叶变换是时域中的标准基与频域中的复指数基之间的线性基变换。\n- 离散时间信号被建模为长度为 $N$ 的复数值有限序列，角度以弧度为单位。\n\n任务：\n\n1) 实现一个函数，该函数使用一个显式构造的 $N \\times N$ 复数矩阵，通过纯粹的矩阵向量乘法来计算离散傅里叶变换。这必须是直接的、时间复杂度为平方级的方法，不含任何分治优化。将输入向量记为 $x \\in \\mathbb{C}^N$，输出记为 $X \\in \\mathbb{C}^N$。选择与标准库 FFT 默认归一化一致的正变换约定：正变换不进行缩放，逆变换包含一个 $1/N$ 的因子。\n\n2) 以与所选正变换约定一致的方式，通过使用正变换矩阵的逆矩阵，将相应的逆变换实现为纯粹的矩阵向量乘法。\n\n3) 使用您基于矩阵的变换，通过为下面列出的每个测试用例检查以下属性，来验证一个现成的 FFT 实现（使用您所用语言中可用的标准库 FFT；在 Python 中，这是 numpy.fft.fft 的默认行为）的正确性：\n- 正向一致性：您的直接变换结果 $X$ 与现成的 FFT 结果在数值容差范围内相匹配。\n- 逆向一致性：将您的直接逆变换应用于现成的 FFT 结果，可以在相同的容差范围内重构原始信号。\n- 能量守恒（对于所采用的归一化方式的帕塞瓦尔关系）：$\\sum_{n=0}^{N-1} |x_n|^2$ 在容差范围内等于 $\\frac{1}{N} \\sum_{k=0}^{N-1} |X_k|^2$。\n- 实数输入的埃尔米特对称性：如果 $x$ 是实数值的，那么对于所有的 $k$，$X_k = \\overline{X_{(-k) \\bmod N}}$ 在容差范围内成立。\n\n数值细节：\n\n- 使用绝对容差 $10^{-10}$ 和相对容差 $10^{-10}$。\n- 角度以弧度为单位。\n\n测试套件：\n\n对每个案例，令 $n \\in \\{0,1,\\dots,N-1\\}$。\n\n- 案例 A（理想情况，复标量）：$N = 1$，$x_0 = 3 - 2j$。\n- 案例 B（边界大小，实数交替）：$N = 2$，$x_0 = 1$，$x_1 = -1$。\n- 案例 C（素数长度，复数混合）：$N = 3$，$x_0 = 1 + 2j$，$x_1 = -3 + 0.5j$，$x_2 = -j$。\n- 案例 D（2的幂，单频余弦）：$N = 4$，$x_n = \\cos(2 \\pi \\cdot 1 \\cdot n / 4)$。\n- 案例 E（稀疏脉冲）：$N = 5$，如果 $n = 2$，则 $x_n = 2$，否则 $x_n = 0$。\n- 案例 F（复线性调频信号）：$N = 8$，$x_n = \\exp(j \\pi n (n-1) / 8)$。\n- 案例 G（随机复数，可复现）：$N = 16$，$x_n = a_n + j b_n$，其中 $\\{a_n\\}$ 和 $\\{b_n\\}$ 是使用固定种子 $12345$ 生成的独立标准正态离差。\n\n对每个案例，生成一个布尔值，表示所有适用的检查是否都通过。容差比较必须使用指定的绝对和相对容差。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含一个方括号括起来的逗号分隔列表，布尔字面量写作 $\\text{True}$ 或 $\\text{False}$，并按案例 A 到 G 的顺序排列。例如：\"[True,False,True]\"。",
            "solution": "对问题陈述进行验证。\n\n**步骤 1：提取已知信息**\n- **原则**：离散傅里叶变换 (DFT) 是从标准基到离散网格 $n \\in \\{0, 1, \\dots, N-1\\}$ 上的复指数 $e^{j 2 \\pi k n / N}$ 正交基的线性变换。\n- **任务 1**：通过显式构造 $N \\times N$ 的 DFT 矩阵 $W$ 来实现正向 DFT，$X = Wx$。这是一个直接的、$O(N^2)$ 算法。\n- **任务 2**：通过构造逆矩阵 $W_{\\text{inv}}$ 来实现相应的逆 DFT，$x = W_{\\text{inv}}X$。\n- **归一化约定**：正变换不缩放。逆变换按因子 $1/N$ 进行缩放。\n- **任务 3**：通过为一系列测试用例检查四个属性来验证一个现成的快速傅里叶变换 (FFT) 实现：\n    1.  **正向一致性**：直接 DFT 结果必须与现成的 FFT 结果匹配。\n    2.  **逆向一致性**：将直接 IDFT 应用于现成的 FFT 结果必须能重构原始信号。\n    3.  **能量守恒（帕塞瓦尔关系）**：$\\sum_{n=0}^{N-1} |x_n|^2 = \\frac{1}{N} \\sum_{k=0}^{N-1} |X_k|^2$。\n    4.  **埃尔米特对称性**：对于实数值输入 $x$，变换必须满足 $X_k = \\overline{X_{(-k) \\bmod N}}$。\n- **数值容差**：绝对容差 $10^{-10}$，相对容差 $10^{-10}$。\n- **测试用例**：\n    - **A**: $N=1$, $x_0 = 3 - 2j$。\n    - **B**: $N=2$, $x = [1, -1]$。\n    - **C**: $N=3$, $x = [1 + 2j, -3 + 0.5j, -j]$。\n    - **D**: $N=4$, $x_n = \\cos(2 \\pi n / 4)$。\n    - **E**: $N=5$, $x = [0, 0, 2, 0, 0]$。\n    - **F**: $N=8$, $x_n = \\exp(j \\pi n(n-1) / 8)$。\n    - **G**: $N=16$, $x_n = a_n + jb_n$，来自种子为 $12345$ 的标准正态离差。\n- **最终输出**：每个测试用例对应一个布尔结果，表示所有适用的检查是否都通过。\n\n**步骤 2：验证**\n对问题的科学有效性、良置性 (well-posedness) 和客观性进行评估。\n- **科学基础**：该问题在根本上是合理的。它基于离散傅里叶变换的标准数学定义、其矩阵表示以及帕塞瓦尔定理和埃尔米特对称性等核心属性。指定的归一化是一种常见的约定。\n- **良置性**：该问题是明确且自洽的。它提供了所有必要的数据（信号、大小 $N$）、要实现的算法、要验证的属性以及严格的数值容差。预期会有一个唯一的、可验证的结果（一个布尔值列表）。\n- **客观性**：语言精确，没有主观论断。任务是纯粹计算性的和可验证的。\n\n**步骤 3：结论**\n该问题被判定为**有效**。这是一个定义明确的数值验证练习，植根于傅里叶分析的基本原理。我现在将提供解决方案。\n\n---\n\n解决方案要求将离散傅里叶变换 (DFT) 及其逆变换实现为直接的矩阵向量乘法，以此作为验证快速傅里叶变换 (FFT) 实现的参考。\n\n**1. 正向离散傅里叶变换 (DFT)**\nDFT 将长度为 $N$ 的离散信号向量 $x \\in \\mathbb{C}^N$ 映射到其频域表示 $X \\in \\mathbb{C}^N$。对于每个频率分量 $k \\in \\{0, 1, \\dots, N-1\\}$，其值 $X_k$ 是通过将信号 $x$ 投影到与频率 $k$ 对应的复指数基向量上计算得出的。遵循标准定义，即：\n$$\nX_k = \\sum_{n=0}^{N-1} x_n e^{-j 2 \\pi k n / N}\n$$\n这组 $N$ 个线性方程可以用矩阵形式表示为 $X = Wx$，其中 $W$ 是 $N \\times N$ 的 DFT 矩阵。该矩阵的元素（由行 $k$ 和列 $n$ 索引）由下式给出：\n$$\nW_{kn} = e^{-j 2 \\pi k n / N}\n$$\n实现将显式构造该矩阵并执行矩阵向量乘法，其计算复杂度为 $O(N^2)$。这与 FFT 算法形成对比，后者以 $O(N \\log N)$ 的时间计算相同的变换。\n\n**2. 逆离散傅里叶变换 (IDFT)**\n逆变换从频谱 $X$ 重构原始信号 $x$。根据指定的归一化约定（正变换无缩放），逆变换必须包含一个 $1/N$ 的缩放因子，以确保正变换和逆变换的复合运算产生单位操作。其公式为：\n$$\nx_n = \\frac{1}{N} \\sum_{k=0}^{N-1} X_k e^{j 2 \\pi k n / N}\n$$\n用矩阵形式表示，即 $x = W_{\\text{inv}}X$。逆矩阵 $W_{\\text{inv}}$ 的元素为：\n$$\n(W_{\\text{inv}})_{nk} = \\frac{1}{N} e^{j 2 \\pi n k / N}\n$$\nDFT 矩阵的一个基本性质是 $W^{-1} = \\frac{1}{N}W^*$，其中 $W^*$ 是 $W$ 的共轭转置。这是由 $W$ 的列向量的正交性得出的。我们的实现将构造用于逆变换的矩阵并应用它。\n\n**3. 验证过程**\n通过对每个测试用例执行四项检查，来对照我们的直接矩阵实现验证一个现成 FFT 例程的正确性。所有数值比较都使用相对容差 $r_{tol} = 10^{-10}$ 和绝对容差 $a_{tol} = 10^{-10}$。\n\n- **正向一致性：** 我们计算 $X_{\\text{direct}} = Wx$ 并从标准库函数获得 $X_{\\text{FFT}}$。然后我们验证 $X_{\\text{direct}}$ 和 $X_{\\text{FFT}}$ 在指定容差内是逐元素相等的。\n\n- **逆向一致性：** 我们验证当将我们的直接逆变换应用于现成 FFT 的结果 $X_{\\text{FFT}}$ 时，原始信号 $x$ 是否被恢复。我们计算 $x_{\\text{rec}} = W_{\\text{inv}} X_{\\text{FFT}}$ 并检查 $x$ 和 $x_{\\text{rec}}$ 在容差内是否逐元素相等。\n\n- **能量守恒（帕塞瓦尔关系）：** 对于指定的归一化，信号元素的平方幅值之和与变换系数的平方幅值之和通过以下恒等式相关联：\n$$\n\\sum_{n=0}^{N-1} |x_n|^2 = \\frac{1}{N} \\sum_{k=0}^{N-1} |X_k|^2\n$$\n我们计算此方程的左侧和右侧，并验证它们在给定容差内是否相等。\n\n- **埃尔米特对称性：** 此属性仅适用于纯实数值的信号 $x$（即对所有 $n$ 都有 $x_n \\in \\mathbb{R}$）。对于此类信号，DFT 频谱表现出共轭对称性：\n$$\nX_k = \\overline{X_{(-k) \\pmod{N}}}\n$$\n对所有 $k \\in \\{0, 1, \\dots, N-1\\}$ 进行检查。这意味着 $X_0$ 是实数，如果 $N$ 是偶数，$X_{N/2}$ 也是实数。此检查仅对具有实数值输入的测试用例执行。\n\n对于每个测试用例，最终结果是一个单一的布尔值，当且仅当所有适用的检查都通过时，该值为真。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the DFT verification process.\n    \"\"\"\n    \n    # Define test cases as a list of dictionaries.\n    # Each dictionary specifies the signal size N and a function to generate the signal x.\n    test_cases = [\n        {\n            \"id\": \"A\",\n            \"N\": 1,\n            \"x_func\": lambda N: np.array([3.0 - 2.0j]),\n            \"is_real\": False,\n        },\n        {\n            \"id\": \"B\",\n            \"N\": 2,\n            \"x_func\": lambda N: np.array([1.0, -1.0]),\n            \"is_real\": True,\n        },\n        {\n            \"id\": \"C\",\n            \"N\": 3,\n            \"x_func\": lambda N: np.array([1.0 + 2.0j, -3.0 + 0.5j, -1.0j]),\n            \"is_real\": False,\n        },\n        {\n            \"id\": \"D\",\n            \"N\": 4,\n            \"x_func\": lambda N: np.cos(2 * np.pi * 1 * np.arange(N) / N),\n            \"is_real\": True,\n        },\n        {\n            \"id\": \"E\",\n            \"N\": 5,\n            \"x_func\": lambda N: np.array([0.0, 0.0, 2.0, 0.0, 0.0]),\n            \"is_real\": True,\n        },\n        {\n            \"id\": \"F\",\n            \"N\": 8,\n            \"x_func\": lambda N: np.exp(1j * np.pi * np.arange(N) * (np.arange(N) - 1) / N),\n            \"is_real\": False,\n        },\n        {\n            \"id\": \"G\",\n            \"N\": 16,\n            \"x_func\": lambda N: (\n                (rng := np.random.default_rng(12345)).standard_normal(N) +\n                1j * rng.standard_normal(N)\n            ),\n            \"is_real\": False,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        N = case[\"N\"]\n        x = case[\"x_func\"](N)\n        is_real_input = case[\"is_real\"]\n        \n        # Run all verification checks for the current case.\n        passed = run_verification(x, N, is_real_input)\n        results.append(passed)\n\n    # Print the final results in the specified format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_verification(x, N, is_real_input):\n    \"\"\"\n    Performs all DFT verification checks for a given signal x of size N.\n    \"\"\"\n    rtol = 1e-10\n    atol = 1e-10\n    \n    checks_passed = []\n\n    # --- 1. Forward Agreement Check ---\n    # Construct the direct DFT matrix W\n    k = np.arange(N).reshape((N, 1))\n    n = np.arange(N)\n    W = np.exp(-2j * np.pi * k * n / N)\n\n    # Compute direct DFT and canned FFT\n    X_direct = W @ x\n    X_fft = np.fft.fft(x)\n    \n    forward_agreement = np.allclose(X_direct, X_fft, rtol=rtol, atol=atol)\n    checks_passed.append(forward_agreement)\n\n    # --- 2. Inverse Agreement Check ---\n    # Construct the direct IDFT matrix W_inv\n    # The unscaled matrix is the conjugate transpose of W, or simply change the sign of the exponent.\n    W_inv_unscaled = np.exp(2j * np.pi * k * n / N)\n    W_inv = (1 / N) * W_inv_unscaled\n    \n    # Reconstruct the signal from the canned FFT result\n    x_reconstructed = W_inv @ X_fft\n    \n    inverse_agreement = np.allclose(x, x_reconstructed, rtol=rtol, atol=atol)\n    checks_passed.append(inverse_agreement)\n\n    # --- 3. Energy Conservation (Parseval's Relation) Check ---\n    energy_x = np.sum(np.abs(x)**2)\n    energy_X = (1 / N) * np.sum(np.abs(X_direct)**2)\n\n    parseval_check = np.isclose(energy_x, energy_X, rtol=rtol, atol=atol)\n    checks_passed.append(parseval_check)\n\n    # --- 4. Hermitian Symmetry Check (for real inputs only) ---\n    if is_real_input:\n        # Check that the input signal is indeed real, as a sanity check.\n        assert np.all(np.abs(x.imag)  atol)\n        \n        # Check X_k = conj(X_{(-k) mod N})\n        indices = np.arange(N)\n        neg_indices_mod_N = (-indices) % N\n        X_conj_symmetric = np.conj(X_direct[neg_indices_mod_N])\n        \n        hermitian_check = np.allclose(X_direct, X_conj_symmetric, rtol=rtol, atol=atol)\n        checks_passed.append(hermitian_check)\n\n    # Return True only if all executed checks passed.\n    return all(checks_passed)\n\nsolve()\n```"
        },
        {
            "introduction": "直接计算DFT的复杂度为 $O(N^2)$，在处理大规模数据时效率低下，而FFT算法则带来了革命性的提速。本练习的核心任务是亲手实现Cooley-Tukey快速傅里叶变换算法 ，这是最经典的FFT算法之一。通过实践“分而治之”策略，将一个大问题递归地分解为更小的问题，您将揭开FFT之所以“快速”的神秘面纱，并深刻体会到其从 $O(N^2)$ 到 $O(N \\log N)$ 复杂度优化的精妙之处。",
            "id": "2387187",
            "problem": "设 $N$ 是一个正整数，其形式为 $N = 2^m$，其中 $m$ 为非负整数。对于一个长度为 $N$ 的复数值序列 $x = \\{x_n\\}_{n=0}^{N-1}$，其离散傅里叶变换 (DFT) $X = \\{X_k\\}_{k=0}^{N-1}$ 定义为\n$$\nX_k = \\sum_{n=0}^{N-1} x_n \\, e^{-2\\pi j \\, k n / N} \\quad \\text{for } k = 0,1,\\dots,N-1,\n$$\n且其逆离散傅里叶变换 (IDFT) 定义为\n$$\nx_n = \\frac{1}{N} \\sum_{k=0}^{N-1} X_k \\, e^{+2\\pi j \\, k n / N} \\quad \\text{for } n = 0,1,\\dots,N-1,\n$$\n其中所有角度均以弧度为单位。\n\n编写一个完整的程序，在不调用任何库傅里叶变换例程的情况下，为长度为 $N = 2^m$ 的序列计算 DFT 和 IDFT。您的程序还必须仅使用这些定义，通过明确的测试用例验证以下基本性质：\n\n- 循环卷积定理：对于长度为 $N$ 的序列 $a$ 和 $b$，它们的长度为 $N$ 的循环卷积 $c$ 定义为 $c_n = \\sum_{m=0}^{N-1} a_m \\, b_{(n-m) \\bmod N}$，满足 $C_k = A_k B_k$，其中 $A$、$B$ 和 $C$ 分别是 $a$、$b$ 和 $c$ 的 DFT。\n- 帕塞瓦尔恒等式（使用上述归一化）：$\\sum_{n=0}^{N-1} |x_n|^2 = \\frac{1}{N} \\sum_{k=0}^{N-1} |X_k|^2$。\n\n您的程序必须实现自己的快速算法来计算 $N = 2^m$ 的 DFT 和 IDFT，并且必须包含一个直接的 $\\mathcal{O}(N^2)$ DFT 用于验证。在需要布尔验证的地方，使用数值容差 $\\varepsilon = 10^{-9}$。所有角度必须解释为弧度。\n\n使用以下测试套件，并按下面给出的顺序生成输出：\n\n- 测试 1 (DFT 正确性与直接 DFT 对比，正常路径)：设 $N = 8$ 且 $x = [0,1,2,3,4,3,2,1]$。使用您的快速实现计算 $X$，使用直接 DFT 计算 $\\tilde{X}$。如果 $\\max_k |X_k - \\tilde{X}_k| \\le \\varepsilon$，则输出布尔值 $\\text{True}$，否则输出 $\\text{False}$。\n- 测试 2 (逆变换恢复)：使用与测试 1 中相同的 $N$ 和 $x$，通过将您的 IDFT 应用于您快速实现得到的 $X$ 来计算 $x'$。如果 $\\max_n |x'_n - x_n| \\le \\varepsilon$，则输出布尔值 $\\text{True}$，否则输出 $\\text{False}$。\n- 测试 3 (通过频域进行循环卷积)：设 $N = 8$，$a = [1,2,3,0,0,0,0,0]$ 且 $b = [0,1,0,0,0,0,0,0]$。直接根据其定义计算长度为 $N$ 的循环卷积 $c$。另外，通过计算 $a$ 和 $b$ 的 DFT，逐点相乘，然后应用 IDFT 来计算 $\\hat{c}$。以浮点数形式输出标量 $\\max_n |c_n - \\hat{c}_n|$。\n- 测试 4 (帕塞瓦尔恒等式)：设 $N = 16$ 且对于 $n = 0,1,\\dots,15$，$x_n = \\sin\\!\\left( \\frac{2\\pi \\cdot 3 \\, n}{N} \\right) + \\frac{1}{2} \\cos\\!\\left( \\frac{2\\pi \\cdot 5 \\, n}{N} \\right)$。通过您的快速实现计算 $X$。以浮点数形式输出标量 $\\left| \\sum_{n=0}^{N-1} |x_n|^2 - \\frac{1}{N} \\sum_{k=0}^{N-1} |X_k|^2 \\right|$。\n- 测试 5 (边缘情况 $N=1$)：设 $N=1$ 且 $x = [3 + 4j]$。计算 $X$，然后通过 IDFT 计算 $x'$。如果 $|x'_0 - x_0| \\le \\varepsilon$，则输出布尔值 $\\text{True}$，否则输出 $\\text{False}$。\n- 测试 6 (最小非平凡大小 $N=2$)：设 $N = 2$ 且 $x = [1,-1]$。通过您的快速实现计算 $X$。在给定约定下，确切的 DFT 是 $[0,2]$。以浮点数形式输出标量 $\\max_k |X_k - [0,2]_k|$。\n\n最终输出格式：您的程序应生成单行输出，其中包含六个结果，按顺序排列，形式为用方括号括起来的逗号分隔列表，例如 $[r_1,r_2,r_3,r_4,r_5,r_6]$。所有布尔条目必须是 $\\text{True}$ 或 $\\text{False}$，所有实数值条目必须以标准十进制或科学记数法打印。不应打印其他任何文本。",
            "solution": "所提出的问题是计算物理学领域，特别是在信号处理领域中，一个定义明确且科学合理练习。它要求实现和验证离散傅里叶变换 (DFT)、其逆变换 (IDFT) 以及相关的基本定理。该问题是完整的、客观的，并且其解决方案是可验证的。我们将着手进行求解。\n\n问题的核心是为一个给定的长度为 $N$ 的离散复数值序列 $x = \\{x_n\\}_{n=0}^{N-1}$ 计算其 DFT $X$。其定义如下：\n$$\nX_k = \\sum_{n=0}^{N-1} x_n \\, e^{-2\\pi j \\, k n / N} \\quad \\text{for } k = 0,1,\\dots,N-1.\n$$\n该公式的直接实现涉及两个嵌套循环，一个用于从 $0$ 到 $N-1$ 的每个索引 $k$，另一个用于从 $0$ 到 $N-1$ 的每个索引 $n$。这导致计算复杂度为 $\\mathcal{O}(N^2)$，对于大的 $N$ 来说效率低下。为了验证目的，我们将实现这样一种直接方法。\n\n问题指明 $N$ 是 2 的幂，即 $N = 2^m$，其中 $m$ 是非负整数。这种结构是采用快速傅里叶变换 (FFT) 算法的关键，特别是 Cooley-Tukey 时域抽取算法。该算法将复杂度从 $\\mathcal{O}(N^2)$ 降低到 $\\mathcal{O}(N \\log N)$。其原理是分治法。长度为 $N$ 的 DFT被递归地分解为两个长度为 $(N/2)$ 的 DFT。\n\n设序列 $x_n$ 被分解为其偶数索引元素，形成序列 $x'_m = x_{2m}$，以及其奇数索引元素，形成序列 $x''_m = x_{2m+1}$，每个序列的长度都为 $N/2$。DFT 求和可以重写为：\n$$\nX_k = \\sum_{m=0}^{N/2-1} x_{2m} e^{-2\\pi j k (2m) / N} + \\sum_{m=0}^{N/2-1} x_{2m+1} e^{-2\\pi j k (2m+1) / N}\n$$\n$$\nX_k = \\sum_{m=0}^{N/2-1} x'_m e^{-2\\pi j k m / (N/2)} + e^{-2\\pi j k/N} \\sum_{m=0}^{N/2-1} x''_m e^{-2\\pi j k m / (N/2)}\n$$\n设 $X'_k$ 和 $X''_k$ 分别是 $x'_m$ 和 $x''_m$ 的长度为 $(N/2)$ 的 DFT。上述表达式变为：\n$$\nX_k = X'_{k \\bmod (N/2)} + W_N^k X''_{k \\bmod (N/2)}\n$$\n其中 $W_N^k = e^{-2\\pi j k/N}$ 是“旋转因子”。对于索引的前半部分，$0 \\le k  N/2$，我们有：\n$$\nX_k = X'_k + W_N^k X''_k\n$$\n对于后半部分，其中索引为 $k+N/2$（$0 \\le k  N/2$），我们使用性质 $X'_{k+N/2} = X'_k$、$X''_{k+N/2} = X''_k$ 和 $W_N^{k+N/2} = -W_N^k$。这得出：\n$$\nX_{k+N/2} = X'_k - W_N^k X''_k\n$$\n这个递归定义允许构建完整的 DFT。递归在基例 $N=1$ 时终止，此时序列 $\\{x_0\\}$ 的 DFT 就是 $\\{X_0\\} = \\{x_0\\}$。我们的实现将遵循这种递归结构。\n\n逆离散傅里叶变换 (IDFT) 定义为：\n$$\nx_n = \\frac{1}{N} \\sum_{k=0}^{N-1} X_k \\, e^{+2\\pi j \\, k n / N}\n$$\n不需要单独实现。我们可以将 IDFT 与正向 DFT 联系起来。观察以下推导：\n$$\nN \\cdot \\overline{x_n} = \\overline{\\sum_{k=0}^{N-1} X_k e^{+2\\pi j k n / N}} = \\sum_{k=0}^{N-1} \\overline{X_k} e^{-2\\pi j k n / N}\n$$\n右侧是复共轭序列 $\\{\\overline{X_k}\\}_{k=0}^{N-1}$ 的 DFT。因此，我们可以通过计算 $\\overline{X}$ 的 DFT，取结果的复共轭，然后乘以 $1/N$ 来找到 $x_n$。也就是说，$x = \\frac{1}{N} \\overline{\\text{DFT}(\\overline{X})}$。这也允许我们使用我们高效的 FFT 实现来计算逆变换 (IFFT)。\n\n该问题还要求验证两个基本定理。\n\n首先是循环卷积定理。两个长度为 $N$ 的序列 $a$ 和 $b$ 的循环卷积 $c$ 由 $c_n = \\sum_{m=0}^{N-1} a_m b_{(n-m) \\bmod N}$ 给出。该定理指出，卷积的 DFT 是各个 DFT 的逐点乘积：$C_k = A_k B_k$。因此，可以通过频域计算 $c$：$c = \\text{IDFT}(\\text{DFT}(a) \\odot \\text{DFT}(b))$，其中 $\\odot$ 表示逐元素乘法。我们将通过直接计算 $c$ 和通过频域路径计算 $c$ 并比较结果来对此进行测试。\n\n其次是帕塞瓦尔恒等式。对于给定的 DFT 归一化，该恒等式为：\n$$\n\\sum_{n=0}^{N-1} |x_n|^2 = \\frac{1}{N} \\sum_{k=0}^{N-1} |X_k|^2\n$$\n该定理将信号在时域中的总能量与其在频域中的能量联系起来。我们将对一个特定的测试信号验证这一点。\n\n程序将首先定义必要的函数：一个直接的 $\\mathcal{O}(N^2)$ DFT、一个递归的 $\\mathcal{O}(N \\log N)$ FFT、一个基于 FFT 的 IFFT，以及一个直接的循环卷积函数。然后，它将使用这些函数和一个数值容差 $\\varepsilon = 10^{-9}$ 进行比较，执行指定的 6 个测试用例。结果将被收集并以所需格式打印。",
            "answer": "```python\nimport numpy as np\n\ndef direct_dft(x):\n    \"\"\"\n    Computes the Discrete Fourier Transform of a sequence x using the direct O(N^2) method.\n    \"\"\"\n    x = np.asarray(x, dtype=complex)\n    N = x.shape[0]\n    n = np.arange(N)\n    k = n.reshape((N, 1))\n    W = np.exp(-2j * np.pi * k * n / N)\n    X = np.dot(W, x)\n    return X\n\ndef fft(x):\n    \"\"\"\n    Computes the Discrete Fourier Transform of a sequence x using the recursive\n    Cooley-Tukey FFT algorithm. Assumes N is a power of 2.\n    \"\"\"\n    x = np.asarray(x, dtype=complex)\n    N = x.shape[0]\n\n    if N == 1:\n        return x\n\n    # Decimate: split into even and odd subsequences\n    x_even = fft(x[0::2])\n    x_odd = fft(x[1::2])\n\n    # Combine\n    k = np.arange(N // 2)\n    twiddle_factors = np.exp(-2j * np.pi * k / N)\n    \n    X = np.concatenate([x_even + twiddle_factors * x_odd,\n                          x_even - twiddle_factors * x_odd])\n    return X\n\ndef ifft(X):\n    \"\"\"\n    Computes the Inverse Discrete Fourier Transform using the forward FFT algorithm.\n    \"\"\"\n    X = np.asarray(X, dtype=complex)\n    N = X.shape[0]\n    \n    # Use the property: IDFT(X) = (1/N) * conj(DFT(conj(X)))\n    x = np.conjugate(fft(np.conjugate(X))) / N\n    return x\n\ndef circular_conv(a, b):\n    \"\"\"\n    Computes the circular convolution of two sequences a and b directly.\n    \"\"\"\n    a = np.asarray(a, dtype=complex)\n    b = np.asarray(b, dtype=complex)\n    N = len(a)\n    c = np.zeros(N, dtype=complex)\n    for n in range(N):\n        for m in range(N):\n            c[n] += a[m] * b[(n - m) % N]\n    return c\n\ndef solve():\n    \"\"\"\n    Runs the full test suite and prints the formatted results.\n    \"\"\"\n    epsilon = 1e-9\n    results = []\n\n    # Test 1: DFT correctness versus direct DFT\n    N1 = 8\n    x1 = np.array([0, 1, 2, 3, 4, 3, 2, 1], dtype=float)\n    X_fast = fft(x1)\n    X_direct = direct_dft(x1)\n    err1 = np.max(np.abs(X_fast - X_direct))\n    results.append(err1 = epsilon)\n\n    # Test 2: Inverse transform recovery\n    x_prime = ifft(X_fast)\n    err2 = np.max(np.abs(x_prime - x1))\n    results.append(err2 = epsilon)\n\n    # Test 3: Circular convolution via frequency domain\n    N3 = 8\n    a3 = np.array([1, 2, 3, 0, 0, 0, 0, 0], dtype=float)\n    b3 = np.array([0, 1, 0, 0, 0, 0, 0, 0], dtype=float)\n    c_direct = circular_conv(a3, b3)\n    A3 = fft(a3)\n    B3 = fft(b3)\n    C_freq = A3 * B3\n    c_hat = ifft(C_freq)\n    err3 = np.max(np.abs(c_direct - c_hat))\n    results.append(err3)\n\n    # Test 4: Parseval identity\n    N4 = 16\n    n4 = np.arange(N4)\n    x4 = np.sin(2 * np.pi * 3 * n4 / N4) + 0.5 * np.cos(2 * np.pi * 5 * n4 / N4)\n    X4 = fft(x4)\n    sum_sq_x = np.sum(np.abs(x4)**2)\n    sum_sq_X_scaled = np.sum(np.abs(X4)**2) / N4\n    err4 = np.abs(sum_sq_x - sum_sq_X_scaled)\n    results.append(err4)\n\n    # Test 5: Edge case N=1\n    x5 = np.array([3 + 4j])\n    X5 = fft(x5)\n    x5_prime = ifft(X5)\n    err5 = np.abs(x5_prime[0] - x5[0])\n    results.append(err5 = epsilon)\n\n    # Test 6: Smallest nontrivial size N=2\n    x6 = np.array([1, -1], dtype=float)\n    X6 = fft(x6)\n    X_exact = np.array([0, 2], dtype=complex)\n    err6 = np.max(np.abs(X6 - X_exact))\n    results.append(err6)\n\n    # Format and print final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "快速傅里叶变换最强大的应用之一是高效地计算卷积。根据卷积定理，时域中的卷积等效于频域中的乘积，这使得我们可以用FFT来极大地加速卷积运算。然而，这一过程存在一个关键的细节：FFT直接计算的是循环卷积，而非通常我们所需要的线性卷积。 这个练习将引导您辨析这两种卷积的区别，并掌握如何通过零填充（zero-padding）这一关键技巧，正确地使用FFT来获得线性卷积的结果。",
            "id": "2391693",
            "problem": "在计算物理学中，离散卷积通常通过使用快速傅里叶变换 (FFT) 来加速离散傅里叶变换 (DFT) 进行计算。设长度为 $L$ 的序列 $x[n]$（索引 $n \\in \\{0,1,\\dots,L-1\\}$）的长度为 $L$ 的 DFT 定义为\n$$\nX[k] \\equiv \\sum_{n=0}^{L-1} x[n] \\, e^{-2\\pi j kn/L}, \\quad k \\in \\{0,1,\\dots,L-1\\},\n$$\n并且逆 DFT 定义为\n$$\nx[n] \\equiv \\frac{1}{L} \\sum_{k=0}^{L-1} X[k] \\, e^{2\\pi j kn/L}.\n$$\n给定两个实数、有限长度的序列\n$$\nx[n] = \\begin{cases}\n1,  n=0,\\\\\n2,  n=1,\\\\\n1,  n=2,\\\\\n0,  \\text{其他情况},\n\\end{cases}\n\\qquad\nh[n] = \\begin{cases}\n1,  n=0,\\\\\n0,  n=1,\\\\\n-1,  n=2,\\\\\n1,  n=3,\\\\\n0,  \\text{其他情况},\n\\end{cases}\n$$\n考虑通过基于 FFT 的过程计算它们的卷积：将 $x[n]$ 和 $h[n]$ 补零至一个共同的长度 $L$，计算它们的长度为 $L$ 的 DFT，在频域中进行逐点相乘，然后应用长度为 $L$ 的逆 DFT 以获得时域中一个长度为 $L$ 的序列。根据定义，这个过程得到的是长度为 $L$ 的循环卷积。\n\n设 $N$ 和 $M$ 分别表示 $x[n]$ 和 $h[n]$ 的非零长度。对于上述序列，$N=3$ 且 $M=4$。\n\n下列哪个陈述是正确的？\n\nA. 如果将 $x[n]$ 和 $h[n]$ 都补零到一个满足 $L \\ge N+M-1$ 的共同长度 $L$，那么逐点乘积的逆 DFT 在其前 $N+M-1$ 个采样点上等于线性卷积 $x[n] * h[n]$，而在剩下的 $L-(N+M-1)$ 个采样点上恒等于零。\n\nB. 如果将两个序列都补零到长度 $L=N+M-2$，那么只有最后一个采样点受到循环回绕的影响；逆 DFT 的前 $N+M-2$ 个采样点等于线性卷积 $x[n]*h[n]$。\n\nC. 对于给定的特定 $x[n]$ 和 $h[n]$，如果将它们都补零到长度 $L=4$，那么逐点乘积的逆 DFT 等于长度为 4 的循环卷积\n$$\n[\\,2,\\,3,\\,0,\\,-1\\,].\n$$\n\nD. 对于给定的特定 $x[n]$ 和 $h[n]$，如果将它们都补零到长度 $L=6$，那么逐点乘积的逆 DFT 完全等于长度为 6 的线性卷积 $x[n]*h[n]$。\n\nE. 只将其中一个序列补零到任意 $L \\ge N+M-1$，而保持另一个序列的原始长度，就足以通过基于 FFT 的过程获得线性卷积，而不会产生循环混叠。",
            "solution": "对问题陈述进行验证。\n\n**第一步：提取已知条件**\n- 长度为 $L$ 的离散傅里叶变换 (DFT) 定义：$X[k] \\equiv \\sum_{n=0}^{L-1} x[n] \\, e^{-2\\pi j kn/L}$，其中 $k \\in \\{0,1,\\dots,L-1\\}$。\n- 长度为 $L$ 的逆离散傅里叶变换 (IDFT) 定义：$x[n] \\equiv \\frac{1}{L} \\sum_{k=0}^{L-1} X[k] \\, e^{2\\pi j kn/L}$。\n- 序列 $x[n]$: $x[0]=1$, $x[1]=2$, $x[2]=1$，其他情况下 $x[n]=0$。其非零长度为 $N=3$。\n- 序列 $h[n]$: $h[0]=1$, $h[1]=0$, $h[2]=-1$, $h[3]=1$，其他情况下 $h[n]=0$。其非零长度为 $M=4$。\n- 基于 FFT 的卷积过程：将 $x[n]$ 和 $h[n]$ 补零到一个共同的长度 $L$，计算它们的长度为 $L$ 的 DFT，逐点相乘，然后应用长度为 $L$ 的 IDFT。\n- 该过程得到长度为 $L$ 的循环卷积。\n\n**第二步：使用已知条件进行验证**\n- **科学依据**：该问题基于离散卷积定理，这是数字信号处理和计算科学的基石。所提供的 DFT 和 IDFT 定义是标准的。通过补零建立线性卷积和循环卷积之间关系是一种成熟的技术。该问题具有科学合理性。\n- **适定性**：该问题提供了所有必要的定义和数据来评估每个陈述的正确性。对于每个选项都可以得出一个唯一且可验证的结论。\n- **客观性**：这些陈述以精确的数学语言表述，没有歧义或主观解释的余地。\n\n**第三步：结论与行动**\n问题陈述内部一致，有科学依据，且具有适定性。因此，它被认为是**有效的**。我们继续进行完整解答。\n\n基本原理是离散卷积定理，该定理指出，对于两个长度为 $L$ 的序列 $x_p[n]$ 和 $h_p[n]$，它们的循环卷积（表示为 $(x_p \\circledast_L h_p)[n]$）由它们 DFT 的逐点乘积的 IDFT 给出：\n$$\n(x_p \\circledast_L h_p)[n] = \\text{IDFT}\\{ X_p[k] \\cdot H_p[k] \\}\n$$\n其中 $X_p[k] = \\text{DFT}\\{x_p[n]\\}$ 且 $H_p[k] = \\text{DFT}\\{h_p[n]\\}$。\n\n原始序列 $x[n]$（长度 $N$）和 $h[n]$（长度 $M$）的线性卷积，表示为 $(x * h)[n]$，是一个长度为 $N+M-1$ 的序列。补零序列的长度为 $L$ 的循环卷积与原始序列的线性卷积之间的关系由下式给出\n$$\n(x_p \\circledast_L h_p)[n] = \\sum_{r=-\\infty}^{\\infty} (x * h)[n + rL] \\quad \\text{for } n \\in \\{0, 1, \\dots, L-1\\}\n$$\n这个公式表明，循环卷积是线性卷积的一个周期化（混叠）版本。为确保循环卷积结果与线性卷积结果相同，我们必须防止混叠。由于线性卷积 $(x * h)[n]$ 的有限长度为 $N+M-1$（即，它仅在 $n \\in \\{0, 1, \\dots, N+M-2\\}$ 时非零），如果补零长度 $L$ 至少这么大，就可以避免混叠：$L \\ge N+M-1$。\n\n对于给定的序列，$N=3$ 且 $M=4$。线性卷积 $(x*h)[n]$ 的长度为 $N+M-1 = 3+4-1=6$。从循环卷积获得线性卷积的条件是使用至少为 $L \\ge 6$ 的补零长度。\n\n我们现在将逐一评估每个陈述。\n\n**A. 如果将 $x[n]$ 和 $h[n]$ 都补零到一个满足 $L \\ge N+M-1$ 的共同长度 $L$，那么逐点乘积的逆 DFT 在其前 $N+M-1$ 个采样点上等于线性卷积 $x[n] * h[n]$，而在剩下的 $L-(N+M-1)$ 个采样点上恒等于零。**\n\n这个陈述描述了使用 FFT 计算线性卷积的标准方法。条件 $L \\ge N+M-1$ 确保没有时域混叠。基于 FFT 的过程的输出是一个长度为 $L$ 的序列。线性卷积 $(x*h)[n]$ 的长度为 $N+M-1$。\n- 对于 $n \\in \\{0, 1, \\dots, N+M-2\\}$，和 $\\sum_{r=-\\infty}^{\\infty} (x * h)[n + rL]$ 只包含 $r=0$ 这一项，因为所有其他 $r \\ne 0$ 的项 $(x * h)[n+rL]$ 都为零。因此，对于这前 $N+M-1$ 个采样点，结果与线性卷积匹配。\n- 对于 $n \\in \\{N+M-1, \\dots, L-1\\}$，和 $\\sum_{r=-\\infty}^{\\infty} (x * h)[n + rL]$ 为零，因为当 $r=0$ 时，$(x*h)[n]$ 为零，而对于所有其他的 $r$，索引超出了 $(x*h)$ 的支撑集。\n因此，得到的长度为 $L$ 的序列是线性卷积的结果，并用 $L-(N+M-1)$ 个零进行填充。这个陈述是对这一事实的精确和正确的描述。\n结论：**正确**。\n\n**B. 如果将两个序列都补零到长度 $L=N+M-2$，那么只有最后一个采样点受到循环回绕的影响；逆 DFT 的前 $N+M-2$ 个采样点等于线性卷积 $x[n]*h[n]$。**\n\n对于给定的序列，$L = N+M-2 = 3+4-2=5$。线性卷积的长度为 $N+M-1=6$。该过程的输出是一个长度为 5 的循环卷积 $y_c[n]$。线性卷积是 $y_l[n] = (x*h)[n]$。\n关系式为 $y_c[n] = y_l[n] + y_l[n+5] + y_l[n-5] + \\dots$ (对于 $n \\in \\{0,1,2,3,4\\}$)。\n由于 $y_l[n]$ 仅在 $n \\in \\{0,1,2,3,4,5\\}$ 时非零，这可以简化为：\n- $y_c[0] = y_l[0] + y_l[5]$。这个采样点被混叠了。\n- $y_c[1] = y_l[1]$。\n- $y_c[2] = y_l[2]$。\n- $y_c[3] = y_l[3]$。\n- $y_c[4] = y_l[4]$。\n该陈述声称“只有最后一个采样点受到影响”。最后一个采样点是 $y_c[4]$，它没有受到影响。第一个采样点 $y_c[0]$ 受到影响。该陈述在事实上是不正确的。\n结论：**不正确**。\n\n**C. 对于给定的特定 $x[n]$ 和 $h[n]$，如果将它们都补零到长度 $L=4$，那么逐点乘积的逆 DFT 等于长度为 4 的循环卷积 $[\\,2,\\,3,\\,0,\\,-1\\,]$。**\n\n我们必须计算补零序列的长度为 4 的循环卷积。\n$x_p[n] = \\{1, 2, 1, 0\\}$\n$h_p[n] = h[n] = \\{1, 0, -1, 1\\}$\n设 $y_c[n] = (x_p \\circledast_4 h_p)[n] = \\sum_{m=0}^{3} x_p[m] h_p[(n-m) \\pmod 4]$。\n- $y_c[0] = x_p[0]h_p[0] + x_p[1]h_p[3] + x_p[2]h_p[2] + x_p[3]h_p[1] = (1)(1) + (2)(1) + (1)(-1) + (0)(0) = 1+2-1 = 2$。\n- $y_c[1] = x_p[0]h_p[1] + x_p[1]h_p[0] + x_p[2]h_p[3] + x_p[3]h_p[2] = (1)(0) + (2)(1) + (1)(1) + (0)(-1) = 0+2+1 = 3$。\n- $y_c[2] = x_p[0]h_p[2] + x_p[1]h_p[1] + x_p[2]h_p[0] + x_p[3]h_p[3] = (1)(-1) + (2)(0) + (1)(1) + (0)(1) = -1+0+1 = 0$。\n- $y_c[3] = x_p[0]h_p[3] + x_p[1]h_p[2] + x_p[2]h_p[1] + x_p[3]h_p[0] = (1)(1) + (2)(-1) + (1)(0) + (0)(1) = 1-2+0 = -1$。\n得到的序列是 $\\{2, 3, 0, -1\\}$。陈述中给出的序列是 $[\\,2,\\,3,\\,0,\\,-1\\,]$，与我们的计算结果相符。\n结论：**正确**。\n\n**D. 对于给定的特定 $x[n]$ 和 $h[n]$，如果将它们都补零到长度 $L=6$，那么逐点乘积的逆 DFT 完全等于长度为 6 的线性卷积 $x[n]*h[n]$。**\n\n这里，补零长度是 $L=6$。避免混叠所需的最小长度是 $N+M-1=3+4-1=6$。由于 $L = N+M-1$，条件得到满足。该过程计算长度为 6 的循环卷积，在这种情况下，它将与长度为 6 的线性卷积完全相同。该陈述声称结果“完全等于长度为 6 的线性卷积”。这是该理论的正确推论。IDFT 的输出序列长度（$L=6$）与线性卷积的长度（$N+M-1=6$）相匹配，并且由于避免了混叠，序列本身是相同的。\n结论：**正确**。\n\n**E. 只将其中一个序列补零到任意 $L \\ge N+M-1$，而保持另一个序列的原始长度，就足以通过基于 FFT 的过程获得线性卷积，而不会产生循环混叠。**\n\n所描述的基于 FFT 的过程涉及 DFT 的逐点乘积：$X_p[k] \\cdot H_p[k]$。此操作仅在两个 DFT，$X_p[k]$ 和 $H_p[k]$，具有相同长度时才有定义。不同长度序列的 DFT 将具有不同数量的频率点，使得逐点乘积没有意义。该过程要求将两个序列都补零到一个*共同的*长度 $L$。因此，所提议的修改与该过程不兼容。\n结论：**不正确**。\n\n总结一下，陈述 A、C 和 D 是正确的。",
            "answer": "$$\\boxed{ACD}$$"
        }
    ]
}