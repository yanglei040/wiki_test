{
    "hands_on_practices": [
        {
            "introduction": "Many real-world signals, from financial market data to climate records, are composed of a slow-moving trend mixed with rapid, high-frequency fluctuations. Fourier-domain filtering provides a powerful method to separate these components. This exercise guides you through the practical workflow of applying an ideal high-pass filter to a synthetic time series, allowing you to remove the low-frequency trend and isolate its \"volatility\" . This practice reinforces the core procedure of transforming a signal to the frequency domain, applying a filter by multiplication, and transforming back to the time domain.",
            "id": "2395589",
            "problem": "Consider a real-valued discrete-time signal defined over $N$ equally spaced samples by\n$$\nx[n] = a_0 + a_1 \\left(\\frac{n}{N}\\right) + a_2 \\left(\\frac{n}{N}\\right)^2 + A_1 \\sin\\!\\left(2\\pi \\frac{m_1 n}{N}\\right) + A_2 \\sin\\!\\left(2\\pi \\frac{m_2 n}{N}\\right), \\quad n = 0,1,\\dots,N-1,\n$$\nwhere all angles are in radians. Let $N = 1024$, $a_0 = 2.0$, $a_1 = 0.5$, $a_2 = -1.0$, $A_1 = 1.0$, $A_2 = 0.5$, $m_1 = 40$, and $m_2 = 160$. Define the Discrete Fourier Transform (DFT) and the Inverse Discrete Fourier Transform (IDFT) on $N$ samples by\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n] \\, e^{-i 2\\pi \\frac{k n}{N}}, \\quad k = 0,1,\\dots,N-1,\n$$\n$$\nx[n] = \\frac{1}{N} \\sum_{k=0}^{N-1} X[k] \\, e^{i 2\\pi \\frac{k n}{N}}, \\quad n = 0,1,\\dots,N-1.\n$$\nLet the corresponding frequency (in cycles per sample) for index $k$ be\n$$\nf[k] = \\begin{cases}\n\\frac{k}{N}, & 0 \\le k \\le \\frac{N}{2},\\\\\n-\\frac{N-k}{N}, & \\frac{N}{2} < k \\le N-1.\n\\end{cases}\n$$\nAn ideal high-pass filter with cutoff $f_c$ (in cycles per sample) is specified in the Fourier domain by the mask\n$$\nM[k] = \\begin{cases}\n1, & |f[k]| \\ge f_c,\\\\\n0, & |f[k]| < f_c,\n\\end{cases}\n\\quad k = 0,1,\\dots,N-1.\n$$\nApplying this filter to $x[n]$ produces the filtered signal $y[n]$ by\n$$\nY[k] = M[k] \\, X[k], \\quad y[n] = \\frac{1}{N} \\sum_{k=0}^{N-1} Y[k] \\, e^{i 2\\pi \\frac{k n}{N}}.\n$$\nDefine the volatility metric of the filtered signal $y[n]$ as the population standard deviation\n$$\n\\sigma = \\sqrt{\\frac{1}{N} \\sum_{n=0}^{N-1} \\left(y[n] - \\mu\\right)^2}, \\quad \\mu = \\frac{1}{N} \\sum_{n=0}^{N-1} y[n].\n$$\nYour task is to compute $\\sigma$ for each of the following five test cutoff frequencies:\n- Test $1$: $f_c = 0$,\n- Test $2$: $f_c = 0.02$,\n- Test $3$: $f_c = 0.10$,\n- Test $4$: $f_c = 0.50$,\n- Test $5$: $f_c = \\frac{m_1}{N}$.\n\nAll quantities are dimensionless. Angles in all trigonometric functions must be interpreted in radians. The final numerical answers for $\\sigma$ in each test must be rounded to exactly $6$ decimal places.\n\nYour program should produce a single line of output containing the five rounded values as a comma-separated list enclosed in square brackets (for example, $\"[v_1,v_2,v_3,v_4,v_5]\"$), where each $v_j$ is the rounded value for Test $j$ in the order given above.",
            "solution": "The problem statement is parsed and validated.\n\n### Step 1: Extract Givens\n- **Signal Definition**: $x[n] = a_0 + a_1 \\left(\\frac{n}{N}\\right) + a_2 \\left(\\frac{n}{N}\\right)^2 + A_1 \\sin\\!\\left(2\\pi \\frac{m_1 n}{N}\\right) + A_2 \\sin\\!\\left(2\\pi \\frac{m_2 n}{N}\\right)$, for $n = 0,1,\\dots,N-1$.\n- **Parameters**: $N = 1024$, $a_0 = 2.0$, $a_1 = 0.5$, $a_2 = -1.0$, $A_1 = 1.0$, $A_2 = 0.5$, $m_1 = 40$, $m_2 = 160$.\n- **Discrete Fourier Transform (DFT)**: $X[k] = \\sum_{n=0}^{N-1} x[n] \\, e^{-i 2\\pi \\frac{k n}{N}}$.\n- **Inverse Discrete Fourier Transform (IDFT)**: $x[n] = \\frac{1}{N} \\sum_{k=0}^{N-1} X[k] \\, e^{i 2\\pi \\frac{k n}{N}}$.\n- **Frequency Mapping**: $f[k] = \\frac{k}{N}$ for $0 \\le k \\le \\frac{N}{2}$, and $f[k] = -\\frac{N-k}{N}$ for $\\frac{N}{2} < k \\le N-1$.\n- **Filter Mask**: $M[k] = 1$ if $|f[k]| \\ge f_c$, and $M[k] = 0$ if $|f[k]| < f_c$.\n- **Filtering Operation**: $Y[k] = M[k] \\, X[k]$, followed by $y[n] = \\text{IDFT}(Y[k])$.\n- **Volatility Metric**: $\\sigma = \\sqrt{\\frac{1}{N} \\sum_{n=0}^{N-1} \\left(y[n] - \\mu\\right)^2}$, where $\\mu = \\frac{1}{N} \\sum_{n=0}^{N-1} y[n]$. This is the population standard deviation of the filtered signal $y[n]$.\n- **Test Cases for Cutoff Frequency $f_c$**:\n  1. $f_c = 0$\n  2. $f_c = 0.02$\n  3. $f_c = 0.10$\n  4. $f_c = 0.50$\n  5. $f_c = \\frac{m_1}{N}$\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded, well-posed, and objective. It describes a standard procedure in digital signal processing: applying a frequency-domain filter to a discrete signal. All constants and functions are clearly defined. The DFT/IDFT definitions and the frequency mapping are standard conventions used in computational libraries. The task is to implement this procedure numerically. There are no violations of scientific principles, contradictions, or ambiguities.\n\n### Step 3: Verdict and Action\nThe problem is valid. A solution will be provided.\n\n### Solution Derivation\nThe problem requires the computation of the volatility, defined as the population standard deviation $\\sigma$, of a filtered signal $y[n]$ for several high-pass filter cutoff frequencies $f_c$. The procedure involves a sequence of standard operations in digital signal processing.\n\n**1. Signal Generation**\nFirst, the discrete-time signal $x[n]$ is synthesized over $N=1024$ samples. The signal is a superposition of a quadratic polynomial and two sinusoids:\n$$\nx[n] = a_0 + a_1 \\left(\\frac{n}{N}\\right) + a_2 \\left(\\frac{n}{N}\\right)^2 + A_1 \\sin\\!\\left(2\\pi \\frac{m_1 n}{N}\\right) + A_2 \\sin\\!\\left(2\\pi \\frac{m_2 n}{N}\\right)\n$$\nThe polynomial component represents low-frequency content, while the sinusoidal components correspond to discrete frequencies $f_1 = m_1/N = 40/1024 \\approx 0.039$ cycles/sample and $f_2 = m_2/N = 160/1024 \\approx 0.156$ cycles/sample.\n\n**2. Fourier Transform**\nThe signal is transformed into the frequency domain using the Discrete Fourier Transform (DFT) to obtain its spectrum, $X[k]$.\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n] \\, e^{-i 2\\pi \\frac{k n}{N}}\n$$\nNumerically, this is efficiently computed using the Fast Fourier Transform (FFT) algorithm.\n\n**3. Frequency-Domain Filtering**\nA high-pass filter is applied in the frequency domain. This is achieved by element-wise multiplication of the signal's spectrum $X[k]$ with a filter mask $M[k]$.\n$$\nY[k] = M[k] \\, X[k]\n$$\nThe mask $M[k]$ is defined based on a frequency vector $f[k]$ and the cutoff frequency $f_c$. The definition of $f[k]$ corresponds to the standard convention for ordering frequencies in an FFT output, where positive frequencies are followed by negative frequencies. The mask is designed to pass frequencies whose absolute values are greater than or equal to $f_c$:\n$$\nM[k] = \\begin{cases}\n1, & |f[k]| \\ge f_c \\\\\n0, & |f[k]| < f_c\n\\end{cases}\n$$\nThis operation attenuates or eliminates frequency components below the cutoff $f_c$.\n\n**4. Inverse Fourier Transform**\nThe filtered signal $y[n]$ is recovered in the time domain by applying the Inverse Discrete Fourier Transform (IDFT) to the filtered spectrum $Y[k]$.\n$$\ny[n] = \\frac{1}{N} \\sum_{k=0}^{N-1} Y[k] \\, e^{i 2\\pi \\frac{k n}{N}}\n$$\nThis is computed numerically using the Inverse Fast Fourier Transform (IFFT) algorithm. Since the original signal $x[n]$ is real-valued and the filter mask $M[k]$ is real and symmetric (i.e., $M[k] = M[N-k]$ for $k=1,\\dots,N/2-1$), the filtered spectrum $Y[k]$ will exhibit Hermitian symmetry ($Y[k] = Y[N-k]^*$). Consequently, the resulting time-domain signal $y[n]$ must be real-valued. Numerical computations might introduce a negligible imaginary part due to floating-point inaccuracies, which must be discarded.\n\n**5. Volatility Calculation**\nFinally, the volatility $\\sigma$ of the real-valued filtered signal $y[n]$ is calculated. This is defined as the population standard deviation:\n$$\n\\sigma = \\sqrt{\\frac{1}{N} \\sum_{n=0}^{N-1} \\left(y[n] - \\mu\\right)^2}, \\quad \\text{where} \\quad \\mu = \\frac{1}{N} \\sum_{n=0}^{N-1} y[n]\n$$\nThis entire procedure is repeated for each of the five specified values of $f_c$. The DFT/IDFT definitions and the population standard deviation formula are consistent with the default implementations in the `numpy` library, which simplifies the computational implementation.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the volatility of a filtered signal for several cutoff frequencies.\n    \"\"\"\n    # 1. Define parameters and test cases from the problem statement.\n    N = 1024\n    a0 = 2.0\n    a1 = 0.5\n    a2 = -1.0\n    A1 = 1.0\n    A2 = 0.5\n    m1 = 40\n    m2 = 160\n\n    test_fcs_raw = [\n        0.0,\n        0.02,\n        0.10,\n        0.50,\n        m1 / N,\n    ]\n\n    # 2. Generate the time-domain signal x[n].\n    n = np.arange(N)\n    x = (a0 +\n         a1 * (n / N) +\n         a2 * (n / N)**2 +\n         A1 * np.sin(2 * np.pi * m1 * n / N) +\n         A2 * np.sin(2 * np.pi * m2 * n / N))\n\n    # 3. Compute the Discrete Fourier Transform (DFT) of the signal.\n    # The result is the spectrum X[k].\n    X = np.fft.fft(x)\n\n    # 4. Define the corresponding frequency vector f[k].\n    # np.fft.fftfreq(N, d=1) gives frequencies in cycles/sample, matching the problem.\n    f = np.fft.fftfreq(N, d=1.0)\n\n    results = []\n    # 5. Process each test case for the cutoff frequency fc.\n    for fc in test_fcs_raw:\n        # a. Create the ideal high-pass filter mask M[k].\n        # The mask is 1 where |f[k]| >= fc, and 0 otherwise.\n        mask = (np.abs(f) >= fc).astype(np.float64)\n\n        # b. Apply the filter in the frequency domain.\n        # The filtered spectrum is Y[k] = M[k] * X[k].\n        Y = X * mask\n\n        # c. Compute the Inverse DFT to get the filtered time-domain signal y[n].\n        # np.fft.ifft correctly applies the 1/N normalization.\n        y = np.fft.ifft(Y)\n        \n        # The resulting signal should be real. We take the real part to discard\n        # negligible imaginary components from floating-point errors.\n        y_real = np.real(y)\n\n        # d. Calculate the volatility (population standard deviation) of y[n].\n        # np.std calculates the population standard deviation by default.\n        sigma = np.std(y_real)\n\n        # e. Append the rounded result to the list.\n        results.append(f\"{sigma:.6f}\")\n\n    # 6. Format the final output as specified.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Moving from one-dimensional signals to two-dimensional images, we often need filters that act differently depending on the orientation of features. This practice explores the design of an anisotropic filterâ€”one that applies a Gaussian blur only in the horizontal direction, leaving vertical details intact . By testing the filter's response to pure plane waves, you will see how the problem elegantly reduces to evaluating the filter's transfer function, providing a direct insight into the fundamental behavior of linear, shift-invariant systems.",
            "id": "2395613",
            "problem": "You are given the task to construct and apply an anisotropic two-dimensional Fourier-domain filter that performs blurring exclusively along the horizontal direction. Consider discrete, periodic, square fields of size $N \\times N$ with $N = 128$, indexed by integer coordinates $(x,y)$ where $x,y \\in \\{0,1,\\dots,N-1\\}$. For any discrete scalar field $f[x,y]$ (which may be real- or complex-valued), define its two-dimensional Discrete Fourier Transform (DFT) $F[u,v]$ and inverse DFT $f[x,y]$ by\n$$\nF[u,v] = \\sum_{x=0}^{N-1}\\sum_{y=0}^{N-1} f[x,y] \\, \\exp\\!\\left(-i 2\\pi \\left(\\frac{u x}{N} + \\frac{v y}{N}\\right)\\right),\n$$\n$$\nf[x,y] = \\frac{1}{N^2} \\sum_{u=0}^{N-1}\\sum_{v=0}^{N-1} F[u,v] \\, \\exp\\!\\left(i 2\\pi \\left(\\frac{u x}{N} + \\frac{v y}{N}\\right)\\right).\n$$\nDefine the anisotropic horizontal-only blur as a Fourier-domain transfer function $H[u,v]$ that depends solely on the horizontal angular spatial wavenumber $k_x$, with no dependence on the vertical wavenumber $k_y$. Let the angular wavenumber associated with the column index $u$ be $k_x(u) = \\frac{2\\pi}{N}\\,u$ interpreted on the $2\\pi$-periodic circle (angles are in radians). The filter is\n$$\nH[u,v] = \\exp\\!\\left(-\\frac{k_x(u)^2}{2\\,\\sigma_{k_x}^2}\\right),\n$$\nwhere $\\sigma_{k_x} > 0$ is the horizontal angular wavenumber scale (in radians per sample). Given an input field $f[x,y]$ with DFT $F[u,v]$, the filtered field $g[x,y]$ is defined by\n$$\nG[u,v] = H[u,v]\\,F[u,v], \\qquad g[x,y] = \\frac{1}{N^2} \\sum_{u=0}^{N-1}\\sum_{v=0}^{N-1} G[u,v] \\, \\exp\\!\\left(i 2\\pi \\left(\\frac{u x}{N} + \\frac{v y}{N}\\right)\\right).\n$$\nYour program must construct and apply this filter and then quantify its response on a set of monochromatic plane-wave test fields. For integers $(f_x,f_y)$ with $0 \\le f_x \\le N-1$ and $0 \\le f_y \\le N-1$, define the unit-amplitude plane wave\n$$\nf^{(f_x,f_y)}[x,y] = \\exp\\!\\left(i 2\\pi \\left(\\frac{f_x x}{N} + \\frac{f_y y}{N}\\right)\\right).\n$$\nFor each test case, let $F$ and $G$ be the DFTs of the input and filtered fields, respectively. Define the amplitude ratio\n$$\nr = \\frac{\\lvert G[f_x,f_y]\\rvert}{\\lvert F[f_x,f_y]\\rvert}.\n$$\nAll angles must be in radians. The quantity $\\sigma_{k_x}$ is an angular wavenumber in radians per sample.\n\nTest suite (each entry is $(f_x,f_y,\\sigma_{k_x})$):\n- Test $1$: $(0,\\,8,\\,1.2)$\n- Test $2$: $(8,\\,0,\\,1.2)$\n- Test $3$: $(12,\\,7,\\,0.3)$\n- Test $4$: $(64,\\,0,\\,1.2)$\n- Test $5$: $(23,\\,15,\\,10.0)$\n\nFor each test case, construct $f^{(f_x,f_y)}[x,y]$, apply the specified horizontal-only anisotropic filter with the given $\\sigma_{k_x}$, compute the amplitude ratio $r$ as defined above, and report it as a floating-point number.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list of the five amplitude ratios, rounded to six decimal places, enclosed in square brackets, in the order of Tests $1$ through $5$ (e.g., \"[r1,r2,r3,r4,r5]\").",
            "solution": "The problem statement has been analyzed and is deemed to be valid. It is scientifically grounded, well-posed, objective, and self-contained. It describes a standard application of Fourier-domain filtering in computational physics, and all necessary parameters and definitions for a unique solution are provided. The task is to calculate the attenuation of specific monochromatic plane waves after applying a directional Gaussian blur in the frequency domain.\n\nThe core of the problem lies in the convolution theorem, which states that a convolution in the spatial domain is equivalent to a pointwise multiplication in the Fourier domain. The filtered field's Discrete Fourier Transform (DFT), $G[u,v]$, is given by the product of the input field's DFT, $F[u,v]$, and the filter's transfer function, $H[u,v]$.\n$$\nG[u,v] = H[u,v] F[u,v]\n$$\nThe problem simplifies significantly upon analyzing the DFT of the specified input fields. The input fields are monochromatic plane waves of the form:\n$$\nf^{(f_x,f_y)}[x,y] = \\exp\\!\\left(i 2\\pi \\left(\\frac{f_x x}{N} + \\frac{f_y y}{N}\\right)\\right)\n$$\nwhere $f_x$ and $f_y$ are integer frequency components. Let us compute the DFT, $F[u,v]$, of this input field.\n$$\nF[u,v] = \\sum_{x=0}^{N-1}\\sum_{y=0}^{N-1} \\exp\\!\\left(i 2\\pi \\left(\\frac{f_x x}{N} + \\frac{f_y y}{N}\\right)\\right) \\exp\\!\\left(-i 2\\pi \\left(\\frac{u x}{N} + \\frac{v y}{N}\\right)\\right)\n$$\n$$\nF[u,v] = \\sum_{x=0}^{N-1}\\sum_{y=0}^{N-1} \\exp\\!\\left(i 2\\pi \\frac{(f_x - u)x}{N}\\right) \\exp\\!\\left(i 2\\pi \\frac{(f_y - v)y}{N}\\right)\n$$\n$$\nF[u,v] = \\left( \\sum_{x=0}^{N-1} \\exp\\!\\left(i 2\\pi \\frac{(f_x - u)x}{N}\\right) \\right) \\left( \\sum_{y=0}^{N-1} \\exp\\!\\left(i 2\\pi \\frac{(f_y - v)y}{N}\\right) \\right)\n$$\nThe orthogonal property of discrete complex exponentials states that $\\sum_{k=0}^{N-1} \\exp(i 2\\pi jk/N)$ equals $N$ if $j$ is an integer multiple of $N$, and $0$ otherwise. Since the indices $u,v,f_x,f_y$ are all in the range $\\{0, 1, \\dots, N-1\\}$, the term $(f_x - u)$ is a multiple of $N$ only if $f_x=u$, and similarly for the $y$ and $v$ terms. Thus, the sums are non-zero only at the specific frequency $(u,v) = (f_x,f_y)$.\n$$\nF[u,v] = (N \\delta_{u,f_x}) (N \\delta_{v,f_y}) = N^2 \\delta_{u,f_x} \\delta_{v,f_y}\n$$\nwhere $\\delta_{j,k}$ is the Kronecker delta. This shows that the DFT of a monochromatic plane wave is a single, non-zero point at the coordinates corresponding to its frequencies. All other frequency components are zero.\n\nThe problem asks for the amplitude ratio $r$ at the frequency $(f_x, f_y)$:\n$$\nr = \\frac{\\lvert G[f_x,f_y]\\rvert}{\\lvert F[f_x,f_y]\\rvert} = \\frac{\\lvert H[f_x,f_y] F[f_x,f_y]\\rvert}{\\lvert F[f_x,f_y]\\rvert}\n$$\nSince $F[f_x,f_y] = N^2 \\neq 0$, we can simplify this to:\n$$\nr = \\lvert H[f_x,f_y]\\rvert\n$$\nThis is a critical simplification. The problem reduces to evaluating the magnitude of the transfer function at the specific frequency point $(f_x, f_y)$ of the input plane wave. A full numerical simulation involving FFTs is unnecessary.\n\nThe transfer function is defined as:\n$$\nH[u,v] = \\exp\\!\\left(-\\frac{k_x(u)^2}{2\\,\\sigma_{k_x}^2}\\right)\n$$\nNote that $H[u,v]$ is independent of the vertical frequency index $v$. Its magnitude is simply itself, as the function is real and positive. Therefore, the ratio $r$ is:\n$$\nr = H[f_x,f_y] = \\exp\\!\\left(-\\frac{k_x(f_x)^2}{2\\,\\sigma_{k_x}^2}\\right)\n$$\nThe final step is to correctly determine the value of the horizontal angular wavenumber $k_x(u)$ for a given discrete frequency index $u$. The problem defines $k_x(u) = \\frac{2\\pi u}{N}$ interpreted on a $2\\pi$-periodic circle. For a discrete grid of size $N$, frequency indices from $0$ to $N/2$ represent positive wavenumbers, while indices from $N/2+1$ to $N-1$ represent negative wavenumbers due to aliasing. The index $N/2$ corresponds to the Nyquist frequency, which can be interpreted as either positive or negative $\\pi$ radians per sample. The standard convention, as implemented in numerical libraries like NumPy, maps the DFT index $u \\in \\{0, \\dots, N-1\\}$ to a physical frequency. For an index $u$, the frequency in cycles per sample is $u/N$ for $0 \\le u < N/2$ and $(u-N)/N$ for $N/2 \\le u < N$. To convert this to an angular wavenumber in radians per sample, we multiply by $2\\pi$.\nGiven $N=128$, the angular wavenumber $k_x(u)$ for an index $u$ can be computed via the discrete Fourier transform frequency conventions:\n$$\nk_x(u) = \n\\begin{cases} \n\\frac{2\\pi u}{N} & \\text{for } 0 \\le u \\le 64 \\\\\n\\frac{2\\pi (u-N)}{N} & \\text{for } 65 \\le u \\le 127\n\\end{cases}\n$$\nIn practice, standard library functions for FFT frequencies (`numpy.fft.fftfreq`) handle this mapping correctly. The vector of angular wavenumbers corresponding to indices $u=0,1,\\dots,N-1$ is given by $k = 2\\pi \\times \\texttt{fftfreq}(N)$. We select the element of this vector at index $f_x$ for our calculation.\n\nFor each test case $(f_x, f_y, \\sigma_{k_x})$, we calculate:\n$1$. The horizontal angular wavenumber $k_x(f_x)$.\n$2$. The ratio $r = \\exp(-k_x(f_x)^2 / (2 \\sigma_{k_x}^2))$.\nThis procedure is followed for all five test cases.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs and applies an anisotropic Fourier-domain filter and quantifies its response.\n    \"\"\"\n    # Define constants from the problem statement.\n    N = 128\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (f_x, f_y, sigma_kx)\n        (0, 8, 1.2),\n        (8, 0, 1.2),\n        (12, 7, 0.3),\n        (64, 0, 1.2),\n        (23, 15, 10.0),\n    ]\n\n    results = []\n    \n    # As derived in the solution, a full FFT simulation is not required.\n    # The amplitude ratio r is simply the value of the transfer function H[fx, fy].\n    # H[u,v] depends only on the horizontal wavenumber k_x(u).\n    # r = exp(-k_x(fx)^2 / (2 * sigma_kx^2))\n\n    # Pre-compute the array of discrete angular wavenumbers in radians per sample.\n    # The numpy.fft.fftfreq function computes the discrete frequencies in cycles/sample.\n    # We multiply by 2*pi to get angular wavenumbers in radians/sample.\n    # The array k_x_all will have entries corresponding to indices u = 0, 1, ..., N-1.\n    k_x_all = 2 * np.pi * np.fft.fftfreq(N)\n\n    for case in test_cases:\n        fx, _, sigma_kx = case\n        \n        # 1. Get the horizontal angular wavenumber k_x corresponding to the frequency index fx.\n        # This correctly handles the aliasing of frequencies beyond Nyquist.\n        kx = k_x_all[fx]\n        \n        # 2. Calculate the square of the wavenumber scale.\n        sigma_kx_sq = sigma_kx**2\n        \n        # 3. Calculate the amplitude ratio, r.\n        # The filter is Gaussian, so the expression is exp(-arg).\n        # The argument is (k_x^2) / (2 * sigma_kx^2).\n        if sigma_kx <= 0:\n            # Although the problem states sigma_kx > 0, handle this case for robustness.\n            # Division by zero would occur.\n            # If kx is zero, r=1. If kx is not zero, the filter has zero width, so r=0.\n            r = 1.0 if kx == 0 else 0.0\n        else:\n            exponent = -(kx**2) / (2 * sigma_kx_sq)\n            r = np.exp(exponent)\n        \n        results.append(r)\n\n    # Format the final output as a comma-separated list of floats,\n    # rounded to six decimal places, enclosed in square brackets.\n    output_str = \",\".join([f\"{res:.6f}\" for res in results])\n    print(f\"[{output_str}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "This final practice tackles a sophisticated and crucial task in scientific imaging: reversing the effect of blurring in the presence of noise. This process, known as deconvolution, is a classic example of an \"ill-posed\" inverse problem, where a naive attempt at inversion can lead to catastrophic amplification of noise. You will implement a robust solution using Tikhonov regularization, a foundational technique for finding a stable and physically meaningful estimate of an original image from a degraded observation . This exercise demonstrates how Fourier-domain methods can be adapted to solve complex, real-world restoration problems.",
            "id": "2395571",
            "problem": "Consider a two-dimensional discrete imaging model on a square grid of size $N \\times N$ with periodic boundary conditions (circular convolution). Let $f[m,n]$ denote the unknown clean image, $h[m,n]$ the true point spread function, and $g[m,n]$ the observed image. The measurement model is\n$$\ng = f * h + \\eta,\n$$\nwhere $*$ denotes circular convolution, and $\\eta[m,n]$ is zero-mean additive noise. The point spread function is not directly available; instead, a noisy measurement $\\tilde{h}[m,n]$ is provided.\n\nYour task is to estimate $f$ from $g$ and $\\tilde{h}$ by solving the following regularized least-squares problem over all $N \\times N$ real arrays $x$:\n$$\n\\hat{f} = \\arg\\min_{x} \\left\\|g - \\tilde{h} * x\\right\\|_2^2 + \\lambda \\left\\|x\\right\\|_2^2,\n$$\nwhere $\\lambda &gt; 0$ is a given regularization parameter. After computing $\\hat{f}$, evaluate the reconstruction quality using the root-mean-square error (RMSE)\n$$\n\\mathrm{RMSE} = \\sqrt{\\frac{1}{N^2}\\sum_{m=0}^{N-1}\\sum_{n=0}^{N-1}\\big(\\hat{f}[m,n] - f[m,n]\\big)^2}.\n$$\n\nConstruct the synthetic data as follows:\n\n1. Grid size: $N = 128$.\n\n2. Clean image $f[m,n]$:\n   - Let $i \\in \\{0,1,\\ldots,N-1\\}$ and $j \\in \\{0,1,\\ldots,N-1\\}$ index rows and columns.\n   - Define the wrap-around distance on the discrete torus for any real center $c$ by\n     $$\n     d(i,c) = \\min\\left(\\lvert i - c\\rvert,\\, N - \\lvert i - c\\rvert\\right).\n     $$\n   - Define two Gaussian components\n     $$\n     G_1[i,j] = \\exp\\!\\left(-\\frac{d(i,N/2)^2 + d(j,N/2)^2}{2\\sigma_1^2}\\right), \\quad \\sigma_1 = 3,\n     $$\n     $$\n     G_2[i,j] = \\exp\\!\\left(-\\frac{d(i,N/3)^2 + d(j,2N/3)^2}{2\\sigma_2^2}\\right), \\quad \\sigma_2 = 5.\n     $$\n   - Define a sinusoidal component\n     $$\n     S[i,j] = \\cos\\!\\left(2\\pi \\left(\\frac{f_x\\, i}{N} + \\frac{f_y\\, j}{N}\\right)\\right), \\quad f_x = 5,\\; f_y = 9.\n     $$\n   - Form the unscaled image\n     $$\n     f_0[i,j] = 0.9\\,G_1[i,j] + 0.7\\,G_2[i,j] + 0.3\\,S[i,j].\n     $$\n   - Min-max normalize to $[0,1]$ by\n     $$\n     f[i,j] = \\frac{f_0[i,j] - \\min(f_0)}{\\max(f_0) - \\min(f_0)},\n     $$\n     where $\\min(f_0)$ and $\\max(f_0)$ denote the minimum and maximum of $f_0$ over all grid points.\n\n3. True point spread function $h[m,n]$:\n   - Using the wrap-around (torus) radial distance from the origin,\n     $$\n     r(i,j) = \\sqrt{\\min(i,N-i)^2 + \\min(j,N-j)^2},\n     $$\n     define the isotropic Gaussian\n     $$\n     h[i,j] = \\exp\\!\\left(-\\frac{r(i,j)^2}{2\\sigma_h^2}\\right),\n     $$\n     and then normalize so that $\\sum_{i,j} h[i,j] = 1$. The blur width $\\sigma_h$ is specified in each test case below.\n\n4. Noisy point spread function $\\tilde{h}[m,n]$:\n   - Generate independent, identically distributed Gaussian noise $\\nu[i,j] \\sim \\mathcal{N}(0,\\sigma_p^2)$ and set\n     $$\n     \\tilde{h}_{\\text{raw}}[i,j] = h[i,j] + \\nu[i,j].\n     $$\n   - Enforce nonnegativity by setting all negative entries of $\\tilde{h}_{\\text{raw}}$ to $0$, obtaining $\\tilde{h}_+[i,j]$.\n   - Renormalize to unit sum to obtain $\\tilde{h}[i,j] = \\tilde{h}_+[i,j]\\Big/\\sum_{m,n}\\tilde{h}_+[m,n]$.\n\n5. Observed image $g[m,n]$:\n   - Generate independent, identically distributed Gaussian noise $\\eta[i,j] \\sim \\mathcal{N}(0,\\sigma_n^2)$.\n   - Form the observation as\n     $$\n     g = f * h + \\eta,\n     $$\n     where $*$ is circular convolution.\n\n6. Randomness and reproducibility:\n   - For each test case with identifier $t \\in \\{1,2,3,4\\}$, initialize a pseudorandom number generator with seed $S_t = 123456 + t$. Use this generator to produce all Gaussian random variables for that test case (both $\\nu$ and $\\eta$).\n\nTest suite (four cases), each specified by the quadruple $(\\sigma_h,\\sigma_n,\\sigma_p,\\lambda)$:\n- Case 1 ($t=1$): $(2.0,\\,0.02,\\,0.01,\\,0.001)$.\n- Case 2 ($t=2$): $(2.0,\\,0.08,\\,0.03,\\,0.02)$.\n- Case 3 ($t=3$): $(0.7,\\,0.02,\\,0.05,\\,0.005)$.\n- Case 4 ($t=4$): $(3.0,\\,0.05,\\,0.02,\\,0.02)$.\n\nYour program must, for each test case, construct $f$, $h$, $\\tilde{h}$, and $g$ exactly as specified; compute the minimizer $\\hat{f}$ of the given objective; and then compute the corresponding $\\mathrm{RMSE}$. The final program output must be a single line containing the list of the four $\\mathrm{RMSE}$ values, in the order of the cases $t=1,2,3,4$, each rounded to six decimal places, as a comma-separated list enclosed in square brackets (for example, \"[0.012345,0.067890,0.001234,0.056789]\"). No other text should be printed.",
            "solution": "The problem presented is a standard exercise in computational image restoration, specifically, deconvolution under uncertainty in the point spread function. The objective is to recover a true image $f$ from a blurred and noisy observation $g$, where the blurring kernel $h$ is also known only through a noisy measurement $\\tilde{h}$. The problem is formulated as a regularized least-squares optimization, which is a robust and well-established method for dealing with such ill-posed inverse problems.\n\nThe problem is entirely self-contained, scientifically grounded in the principles of linear systems and Fourier analysis, and well-posed. All parameters and procedures are specified with sufficient precision to ensure a unique, reproducible result. Therefore, the problem is deemed valid and a solution will be provided.\n\nThe task is to find the minimizer $\\hat{f}$ of the objective function $J(x)$:\n$$\n\\hat{f} = \\arg\\min_{x} J(x) = \\arg\\min_{x} \\left\\|g - \\tilde{h} * x\\right\\|_2^2 + \\lambda \\left\\|x\\right\\|_2^2\n$$\nwhere $x$ is a real-valued $N \\times N$ array, $*$ denotes a $2$D circular convolution, and $\\|\\cdot\\|_2^2$ is the squared Euclidean norm (sum of squared elements). The regularization parameter $\\lambda$ is positive, which ensures the objective function is strictly convex and thus has a unique minimum.\n\nThe presence of the circular convolution operator strongly suggests a solution in the Fourier domain. The Convolution Theorem for the $2$D Discrete Fourier Transform (DFT), denoted by $\\mathcal{F}$, states that for any two discrete signals $a$ and $b$ on the $N \\times N$ grid, $\\mathcal{F}\\{a * b\\} = \\mathcal{F}\\{a\\} \\cdot \\mathcal{F}\\{b\\}$, where the product on the right is element-wise multiplication.\n\nLet us denote the DFTs of the respective signals by capital letters: $X = \\mathcal{F}\\{x\\}$, $G = \\mathcal{F}\\{g\\}$, and $\\tilde{H} = \\mathcal{F}\\{\\tilde{h}\\}$. Using Parseval's theorem, which relates the sum of squares in the spatial domain to the sum of squares in the Fourier domain, we can transform the objective function. The squared $\\ell_2$-norm of a signal $a$ is proportional to the squared norm of its DFT $A$, i.e., $\\|a\\|_2^2 \\propto \\|A\\|_2^2$. Since we are minimizing, we can ignore the constant scaling factor and write the objective function in the Fourier domain as:\n$$\nJ(X) = \\left\\| G - \\tilde{H} \\cdot X \\right\\|_F^2 + \\lambda \\left\\|X\\right\\|_F^2\n$$\nwhere $\\|\\cdot\\|_F^2$ is the squared Frobenius norm, equivalent to the sum of squared magnitudes of the elements of the complex-valued matrix. This can be written as a sum over all frequency components $(k,l)$:\n$$\nJ(X) = \\sum_{k=0}^{N-1}\\sum_{l=0}^{N-1} \\left( \\left| G[k,l] - \\tilde{H}[k,l] X[k,l] \\right|^2 + \\lambda \\left| X[k,l] \\right|^2 \\right)\n$$\nSince each term in the sum depends only on a single frequency component $X[k,l]$, we can minimize the total sum by minimizing each term independently. For a specific frequency $(k,l)$, we minimize:\n$$\nJ_{kl}(X_{kl}) = | G_{kl} - \\tilde{H}_{kl} X_{kl} |^2 + \\lambda | X_{kl} |^2\n$$\nTo find the complex value $X_{kl}$ that minimizes this expression, we take the complex derivative with respect to its conjugate $X_{kl}^*$ and set it to zero:\n$$\n\\frac{\\partial J_{kl}}{\\partial X_{kl}^*} = \\frac{\\partial}{\\partial X_{kl}^*} \\left( (G_{kl} - \\tilde{H}_{kl} X_{kl})(G_{kl}^* - \\tilde{H}_{kl}^* X_{kl}^*) + \\lambda X_{kl} X_{kl}^* \\right) = 0\n$$\n$$\n- (G_{kl} - \\tilde{H}_{kl} X_{kl}) \\tilde{H}_{kl}^* + \\lambda X_{kl} = 0\n$$\n$$\n-G_{kl}\\tilde{H}_{kl}^* + |\\tilde{H}_{kl}|^2 X_{kl} + \\lambda X_{kl} = 0\n$$\nSolving for $X_{kl}$ gives the optimal solution for the DFT of the estimated image $\\hat{f}$:\n$$\n\\hat{X}[k,l] = \\frac{G[k,l] \\tilde{H}[k,l]^*}{|\\tilde{H}[k,l]|^2 + \\lambda}\n$$\nThis is the well-known solution for Tikhonov-regularized deconvolution. Since the input signals $g$ and $\\tilde{h}$ are real, their DFTs $G$ and $\\tilde{H}$ exhibit Hermitian symmetry. This property ensures that the resulting $\\hat{X}$ also has Hermitian symmetry, and therefore its inverse DFT, $\\hat{f}$, is a real-valued image, consistent with the problem's constraints.\n\nThe algorithmic procedure is thus as follows:\n$1$. For each test case, synthesize the data ($f$, $h$, $\\tilde{h}$, $g$) according to the precise specifications, using the designated random seed for reproducibility.\n$2$. Compute the $2$D DFTs of the observed image $g$ and the noisy point spread function $\\tilde{h}$ to obtain $G$ and $\\tilde{H}$.\n$3$. Apply the derived filter in the frequency domain to compute each component of the estimated image's DFT, $\\hat{X}$.\n$4$. Compute the inverse $2$D DFT of $\\hat{X}$ to obtain the spatial-domain estimate $\\hat{f}$. The result will be real, but taking the real part explicitly is good practice to discard negligible imaginary components arising from floating-point inaccuracies.\n$5$. Finally, evaluate the reconstruction quality by computing the Root-Mean-Square Error (RMSE) between the estimate $\\hat{f}$ and the true clean image $f$.\n\nThis procedure will be implemented for each of the four test cases provided.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the regularized deconvolution problem for four test cases and\n    computes the RMSE for each.\n    \"\"\"\n\n    test_cases = [\n        # (sigma_h, sigma_n, sigma_p, lambda)\n        (2.0, 0.02, 0.01, 0.001),  # Case 1 (t=1)\n        (2.0, 0.08, 0.03, 0.02),   # Case 2 (t=2)\n        (0.7, 0.02, 0.05, 0.005),  # Case 3 (t=3)\n        (3.0, 0.05, 0.02, 0.02),   # Case 4 (t=4)\n    ]\n\n    # --- Static parameters for data generation ---\n    N = 128\n    # Clean image parameters\n    sigma1 = 3.0\n    sigma2 = 5.0\n    fx = 5.0\n    fy = 9.0\n    \n    results = []\n\n    # --- Generate common components for clean image f ---\n    ii, jj = np.indices((N, N))\n\n    def torus_dist(idx, center):\n        d = np.abs(idx - center)\n        return np.minimum(d, N - d)\n\n    # Component G1\n    d_i1 = torus_dist(ii, N / 2.0)\n    d_j1 = torus_dist(jj, N / 2.0)\n    G1 = np.exp(-(d_i1**2 + d_j1**2) / (2.0 * sigma1**2))\n\n    # Component G2\n    d_i2 = torus_dist(ii, N / 3.0)\n    d_j2 = torus_dist(jj, 2.0 * N / 3.0)\n    G2 = np.exp(-(d_i2**2 + d_j2**2) / (2.0 * sigma2**2))\n\n    # Component S\n    S = np.cos(2.0 * np.pi * (fx * ii / N + fy * jj / N))\n\n    # Unscaled image f0\n    f0 = 0.9 * G1 + 0.7 * G2 + 0.3 * S\n\n    # Normalized clean image f\n    f_min, f_max = f0.min(), f0.max()\n    f = (f0 - f_min) / (f_max - f_min)\n\n    # --- Generate common components for true PSF h ---\n    i_coords = np.arange(N)\n    j_coords = np.arange(N)\n    i_dist = np.minimum(i_coords, N - i_coords)\n    j_dist = np.minimum(j_coords, N - j_coords)\n    # Using broadcasting for robust grid creation\n    r = np.sqrt(i_dist[:, np.newaxis]**2 + j_dist[np.newaxis, :]**2)\n\n    for t, case in enumerate(test_cases, 1):\n        sigma_h, sigma_n, sigma_p, lambda_reg = case\n        \n        # --- Initialize PRNG for reproducibility ---\n        seed = 123456 + t\n        rng = np.random.default_rng(seed)\n\n        # --- Generate true PSF h ---\n        h_unnormalized = np.exp(-r**2 / (2.0 * sigma_h**2))\n        h = h_unnormalized / np.sum(h_unnormalized)\n\n        # --- Generate noisy PSF h_tilde ---\n        nu = rng.normal(0.0, sigma_p, size=(N, N))\n        h_tilde_raw = h + nu\n        h_tilde_nonneg = np.maximum(0.0, h_tilde_raw)\n        h_tilde = h_tilde_nonneg / np.sum(h_tilde_nonneg)\n\n        # --- Generate observed image g ---\n        # Circular convolution via FFT\n        f_conv_h = np.real(np.fft.ifft2(np.fft.fft2(f) * np.fft.fft2(h)))\n        eta = rng.normal(0.0, sigma_n, size=(N, N))\n        g = f_conv_h + eta\n        \n        # --- Solve for estimated image f_hat ---\n        # Transform to Fourier domain\n        G = np.fft.fft2(g)\n        H_tilde = np.fft.fft2(h_tilde)\n\n        # Apply regularized inverse filter\n        H_tilde_conj = np.conj(H_tilde)\n        H_tilde_mag_sq = np.abs(H_tilde)**2\n        \n        F_hat_fourier = (G * H_tilde_conj) / (H_tilde_mag_sq + lambda_reg)\n        \n        # Transform back to spatial domain\n        f_hat = np.real(np.fft.ifft2(F_hat_fourier))\n        \n        # --- Calculate RMSE ---\n        rmse = np.sqrt(np.mean((f_hat - f)**2))\n        results.append(rmse)\n    \n    # --- Format and print final output ---\n    output_str = \",\".join([f\"{r:.6f}\" for r in results])\n    print(f\"[{output_str}]\")\n\nsolve()\n```"
        }
    ]
}