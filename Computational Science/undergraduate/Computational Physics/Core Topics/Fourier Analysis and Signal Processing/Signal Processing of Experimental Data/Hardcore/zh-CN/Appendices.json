{
    "hands_on_practices": [
        {
            "introduction": "将物理世界的连续信号转换为数字信号是所有现代实验数据采集的第一步。这个被称为模数转换的过程并非完美，它会引入一种被称为“量化噪声”的误差。本练习旨在通过模拟一个理想正弦波的数字化过程，让您亲手量化这种误差，探索用于表示信号的比特数（即分辨率）如何直接影响信号的保真度，并通过计算信噪比（SQNR）来评估其质量。",
            "id": "2438146",
            "problem": "一个代表单音测试输入的连续时间正弦信号由函数 $x(t) = A \\sin(2 \\pi f_{0} t + \\varphi)$ 定义，其幅度为 $A$，频率为 $f_{0}$，相位为 $\\varphi = 0$ 弧度。该信号以采样频率 $f_{s}$ 在时间上进行均匀采样，持续时间为 $T$，从而在时间点 $t_{n} = n / f_{s}$（其中 $n = 0, 1, \\ldots, N-1$）产生 $N = \\lfloor f_{s} T \\rfloor$ 个离散时间样本 $x[n] = x(t_{n})$。接着，这些样本由一个具有 $B$ 比特和满量程峰值幅度 $L$（单位为伏特）的理想、均匀、中置型量化器进行数字化，过程如下。定义 $K = 2^{B-1} - 1$ 和步长 $\\Delta = L / K$。重构电平为 $k \\Delta$，其中整数 $k$ 满足 $-K \\leq k \\leq K$。量化样本 $y_{q}[n]$ 的获取过程是：首先通过四舍五入将 $x[n]$ 映射到最近的电平 $k \\Delta$，然后在必要时饱和到极限电平：\n$$\nk[n] = \\mathrm{clip}\\left(\\mathrm{round}\\left(\\frac{x[n]}{\\Delta}\\right), -K, K\\right), \\quad y_{q}[n] = k[n] \\Delta,\n$$\n其中 $\\mathrm{round}(\\cdot)$ 表示四舍五入到最近的整数，$\\mathrm{clip}(u, a, b)$ 将 $u$ 限制在区间 $[a, b]$ 内。量化误差为 $e[n] = y_{q}[n] - x[n]$。使用采样数据，定义平均信号功率和平均误差功率为\n$$\nP_{s} = \\frac{1}{N} \\sum_{n=0}^{N-1} x[n]^{2}, \\quad P_{e} = \\frac{1}{N} \\sum_{n=0}^{N-1} e[n]^{2},\n$$\n并将以分贝为单位的信号与量化噪声比（SQNR）定义为\n$$\n\\mathrm{SQNR} = 10 \\log_{10}\\left(\\frac{P_{s}}{P_{e}}\\right).\n$$\n所有角度单位必须是弧度。所有电压单位必须是伏特。\n\n你的任务是为下面测试套件中的每一组参数计算 $\\mathrm{SQNR}$。对于每个测试用例，其幅度是相对于满量程峰值幅度指定的，为 $L$ 的一个倍数；也就是说，使用的绝对幅度 $A$ 等于指定的倍数乘以 $L$。将最终的 $\\mathrm{SQNR}$ 值以分贝表示，并以浮点数形式呈现，四舍五入到小数点后恰好六位。\n\n测试套件（每个用例是一个元组 $(B, f_{0}, f_{s}, T, L, \\text{幅度倍数})$）：\n- 用例 1：$(16, 1234, 48000, 1.0, 1.0, 0.9)$\n- 用例 2：$(12, 1000, 44100, 0.5, 2.0, 0.8)$\n- 用例 3：$(8, 5000, 96000, 0.25, 1.0, 0.5)$\n- 用例 4：$(3, 200, 8000, 1.0, 1.0, 0.95)$\n- 用例 5：$(16, 3000, 48000, 0.75, 1.0, 0.01)$\n\n你的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表，不含空格，其顺序与测试套件相同（例如，“[r1,r2,r3,r4,r5]”），其中每个 $r_i$ 是用例 $i$ 的 $\\mathrm{SQNR}$ 值，四舍五入到小数点后恰好六位。",
            "solution": "问题陈述已经过验证，并被确认为有效。这是一个数字信号处理领域的良构问题，提供了清晰且完整的定义、参数和约束集。所有参数在物理上和计算上都是合理的，其基本原理在科学上是可靠的。任务是为一组给定的场景计算信号与量化噪声比（SQNR）。我们着手进行求解。\n\n问题的核心是仿真一个信号采集链，该链包括采样和量化。解决方案是通过对每个测试用例算法化地执行问题中定义的步骤来获得的。\n\n1.  **信号生成**:\n    连续时间信号是一个纯正弦波，定义为 $x(t) = A \\sin(2 \\pi f_{0} t)$，因为相位 $\\varphi$ 给定为 $0$。幅度 $A$ 由量化器的满量程峰值幅度 $L$ 和指定的幅度倍数确定，即 $A = (\\text{幅度倍数}) \\times L$。\n    该信号以频率 $f_{s}$ 均匀采样，持续时间为 $T$。离散样本的总数为 $N = \\lfloor f_{s} T \\rfloor$。样本在时间点 $t_{n} = n/f_{s}$（其中 $n = 0, 1, \\ldots, N-1$）处采集。得到的离散时间信号为：\n    $$x[n] = x(t_{n}) = A \\sin\\left(2 \\pi f_{0} \\frac{n}{f_{s}}\\right)$$\n\n2.  **量化器定义**:\n    系统使用一个具有 $B$ 比特分辨率和满量程峰值幅度 $L$ 伏特的均匀中置型量化器。正（和负）量化电平的数量由 $K = 2^{B-1} - 1$ 确定。重构电平的总数为 $2K+1$。量化步长 $\\Delta$，即相邻重构电平之间的电压差，由以下公式给出：\n    $$\\Delta = \\frac{L}{K}$$\n    那么重构电平为 $\\{k\\Delta \\mid k \\in \\{-K, -K+1, \\ldots, K-1, K\\}\\}$。\n\n3.  **量化过程与误差计算**:\n    每个样本 $x[n]$ 都被映射到最近的重构电平。这是一个两步过程。首先，将样本电压除以步长 $\\Delta$ 进行归一化，然后将结果四舍五入到最近的整数。接着，对此整数进行限幅，以确保其保持在有效电平索引的范围 $[-K, K]$ 内。得到的索引为 $k[n]$：\n    $$k[n] = \\mathrm{clip}\\left(\\mathrm{round}\\left(\\frac{x[n]}{\\Delta}\\right), -K, K\\right)$$\n    然后，通过将此索引乘以步长来重构量化样本 $y_{q}[n]$：\n    $$y_{q}[n] = k[n] \\Delta$$\n    每个样本的量化误差是量化值与原始样本值之差：\n    $$e[n] = y_{q}[n] - x[n]$$\n\n4.  **功率与SQNR计算**:\n    原始离散时间信号的平均功率 $P_{s}$ 和量化误差信号的平均功率 $P_{e}$，是通过对所有 $N$ 个样本各自样本值的平方求平均来计算的：\n    $$P_{s} = \\frac{1}{N} \\sum_{n=0}^{N-1} x[n]^{2}$$\n    $$P_{e} = \\frac{1}{N} \\sum_{n=0}^{N-1} e[n]^{2}$$\n    最后，使用以下公式以分贝（dB）为单位计算信号与量化噪声比（SQNR）：\n    $$\\mathrm{SQNR} = 10 \\log_{10}\\left(\\frac{P_{s}}{P_{e}}\\right)$$\n    对测试套件中提供的每一组参数，都通过计算实现这整个过程。数值结果按要求四舍五入到小数点后六位。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Signal-to-Quantization-Noise Ratio (SQNR) for a series\n    of test cases involving a sampled and quantized sinusoidal signal.\n    \"\"\"\n    # Test suite: each case is a tuple (B, f0, fs, T, L, amplitude_multiple)\n    test_cases = [\n        (16, 1234, 48000, 1.0, 1.0, 0.9),\n        (12, 1000, 44100, 0.5, 2.0, 0.8),\n        (8, 5000, 96000, 0.25, 1.0, 0.5),\n        (3, 200, 8000, 1.0, 1.0, 0.95),\n        (16, 3000, 48000, 0.75, 1.0, 0.01)\n    ]\n\n    results = []\n\n    for case in test_cases:\n        B, f0, fs, T, L, amp_multiple = case\n\n        # Step 1: Signal Generation\n        # Amplitude of the sinusoidal signal\n        A = amp_multiple * L\n        # Number of samples, N = floor(fs * T)\n        N = int(fs * T)\n        # Time vector\n        t = np.arange(N) / fs\n        # Discrete-time signal x[n]\n        x_n = A * np.sin(2 * np.pi * f0 * t)\n\n        # Step 2: Quantizer Definition\n        # K determines the number of quantization levels on one side of zero\n        K = (2**(B - 1)) - 1\n        # Quantization step size\n        delta = L / K\n\n        # Step 3: Quantization Process\n        # Normalize signal and round to nearest integer to get level index\n        # np.round() implements rounding to the nearest integer, with .5 cases\n        # rounded to the nearest even integer.\n        k_n_unclipped = np.round(x_n / delta)\n        # Clip the indices to the valid range [-K, K]\n        k_n = np.clip(k_n_unclipped, -K, K)\n        # Reconstruct the quantized signal\n        y_q_n = k_n * delta\n\n        # Calculate the quantization error signal\n        e_n = y_q_n - x_n\n\n        # Step 4: Power and SQNR Calculation\n        # Average signal power\n        Ps = np.mean(x_n**2)\n        # Average error (noise) power\n        Pe = np.mean(e_n**2)\n        \n        # The problem setup ensures Pe > 0 for the given test cases.\n        # Otherwise, an if Pe == 0 check would be needed.\n        sqnr = 10 * np.log10(Ps / Pe)\n\n        results.append(sqnr)\n\n    # Format the final results as a comma-separated list of strings,\n    # with each number rounded to exactly six decimal places.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "当信号被采样成离散数据点后，我们有时需要改变其采样率，例如通过降采样来减少数据量。然而，这个过程隐藏着一个巨大的陷阱：混叠（aliasing）。本练习将通过一个思想实验——仅保留信号的偶数索引样本——来揭示混叠现象。通过在频域中分析处理后信号的变化，您将亲眼见证高频成分如何“伪装”成低频信号，这是数据分析中必须警惕的关键错误。",
            "id": "2438167",
            "problem": "一个有限长度的离散时间信号被定义为离散傅里叶变换 (DFT) 谱斌频率上余弦分量的和。设 $N$ 为一个正偶数，且 $n \\in \\{0,1,\\dots,N-1\\}$。该信号为\n$$\nx[n] = \\sum_{k=1}^{K} A_k \\cos\\!\\left(\\omega_k n + \\varphi_k\\right),\n$$\n其中每个角频率的形式为 $\\omega_k = \\dfrac{2\\pi m_k}{N}$，整数 $m_k \\in \\{0,1,\\dots,N-1\\}$，振幅 $A_k > 0$ 为实数，相位 $\\varphi_k$ 是以弧度为单位的实数。仅考虑从偶数索引样本进行的重建，定义为\n$$\ny[n] =\n\\begin{cases}\nx[n],  \\text{如果 $n$ 是偶数},\\\\\n0,  \\text{如果 $n$ 是奇数}。\n\\end{cases}\n$$\n将序列 $z[n]$ 的长度为 $N$ 的离散傅里叶变换 (DFT) 定义为\n$$\nZ[m] = \\sum_{n=0}^{N-1} z[n]\\, e^{-i\\,2\\pi\\, m n / N},\\quad m \\in \\{0,1,\\dots,N-1\\}。\n$$\n设 $X[m]$ 和 $Y[m]$ 分别表示 $x[n]$ 和 $y[n]$ 的 DFT。设原始频谱斌的集合为\n$$\n\\mathcal{S} = \\bigcup_{k=1}^{K} \\left\\{\\, m_k,\\; (-m_k)\\pmod N \\,\\right\\},\n$$\n（已移除重复项）。定义信号斌功率为\n$$\nP_{\\text{signal}} = \\sum_{m \\in \\mathcal{S}} \\left| Y[m] \\right|^2,\n$$\n总功率为\n$$\nP_{\\text{total}} = \\sum_{m=0}^{N-1} \\left| Y[m] \\right|^2,\n$$\n以及混叠伪影功率为\n$$\nP_{\\text{alias}} = P_{\\text{total}} - P_{\\text{signal}}。\n$$\n所要求的性能指标是混叠-信号功率比，\n$$\nR = \\frac{P_{\\text{alias}}}{P_{\\text{signal}}},\n$$\n该比值为无量纲。所有角度必须以弧度为单位进行解释。\n\n您的任务是编写一个完整的程序，对下面的每个测试用例，构造 $x[n]$，仅从偶数索引样本形成 $y[n]$，计算 $Y[m]$，并以浮点数形式输出比率 $R$，四舍五入到小数点后六位。\n\n测试套件（每个用例是一个元组 $(N,\\; \\{m_k\\},\\; \\{A_k\\},\\; \\{\\varphi_k\\})$）：\n- 用例 1：$(1024,\\; \\{50\\},\\; \\{1.0\\},\\; \\{0.0\\})$。\n- 用例 2：$(1024,\\; \\{30,\\,100\\},\\; \\{1.0,\\,0.8\\},\\; \\{0.0,\\,0.3\\})$。\n- 用例 3：$(1024,\\; \\{256\\},\\; \\{1.0\\},\\; \\{0.7\\})$。\n- 用例 4：$(1024,\\; \\{0\\},\\; \\{1.2\\},\\; \\{0.0\\})$。\n- 用例 5：$(1024,\\; \\{60,\\,572\\},\\; \\{1.0,\\,0.5\\},\\; \\{0.0,\\,1.0\\})$。\n\n您的程序必须生成单行输出，其中包含按顺序排列的五个比率，格式为方括号内以逗号分隔的列表，例如 $[r_1,r_2,r_3,r_4,r_5]$，其中每个 $r_j$ 都四舍五入到小数点后六位。不涉及物理单位。所有角度均以弧度为单位。最终输出必须与此单行格式完全匹配。",
            "solution": "所提出的问题是离散信号处理中一个明确定义的练习，涉及对特定形式下采样后信号的频谱分析。它具有科学依据，逻辑上一致，并且提供了所有必要的参数。因此，该问题是有效的，下面将给出一个解决方案。\n\n设长度为 $N$ 的离散时间信号表示为 $x[n]$，其中 $n \\in \\{0, 1, \\dots, N-1\\}$。该信号是 $K$ 个余弦分量的叠加：\n$$\nx[n] = \\sum_{k=1}^{K} A_k \\cos(\\omega_k n + \\varphi_k)\n$$\n每个角频率都是基本 DFT 频率的倍数，$\\omega_k = \\frac{2\\pi m_k}{N}$，其中 $m_k$ 是一个整数谱斌索引。\n\n使用欧拉恒等式 $e^{i\\theta} = \\cos(\\theta) + i\\sin(\\theta)$，我们可以将余弦函数表示为：\n$$\n\\cos(\\theta) = \\frac{e^{i\\theta} + e^{-i\\theta}}{2}\n$$\n因此，信号 $x[n]$ 可以用复指数的形式写出：\n$$\nx[n] = \\sum_{k=1}^{K} \\frac{A_k}{2} \\left( e^{i(\\frac{2\\pi m_k n}{N} + \\varphi_k)} + e^{-i(\\frac{2\\pi m_k n}{N} + \\varphi_k)} \\right) = \\sum_{k=1}^{K} \\left( \\frac{A_k e^{i\\varphi_k}}{2} e^{i\\frac{2\\pi m_k n}{N}} + \\frac{A_k e^{-i\\varphi_k}}{2} e^{-i\\frac{2\\pi m_k n}{N}} \\right)\n$$\n$x[n]$ 的长度为 $N$ 的离散傅里叶变换 (DFT) $X[m]$ 定义为：\n$$\nX[m] = \\sum_{n=0}^{N-1} x[n]\\, e^{-i\\frac{2\\pi mn}{N}}\n$$\n给定复指数的 DFT 为 $\\sum_{n=0}^{N-1} e^{i\\frac{2\\pi k_0 n}{N}} e^{-i\\frac{2\\pi mn}{N}} = N \\delta[m - k_0]$，其中 $\\delta[\\cdot]$ 是离散脉冲，则 $x[n]$ 的 DFT 是一系列位于谱斌 $\\pm m_k$ (模 $N$) 处的脉冲：\n$$\nX[m] = \\sum_{k=1}^{K} \\left( \\frac{N A_k e^{i\\varphi_k}}{2} \\delta[m - m_k] + \\frac{N A_k e^{-i\\varphi_k}}{2} \\delta[m - ((-m_k) \\pmod N)] \\right)\n$$\n频谱 $X[m]$ 仅在 $m$ 属于原始频谱斌集合 $\\mathcal{S} = \\bigcup_{k=1}^{K} \\{m_k, (-m_k) \\pmod N\\}$ 时非零。\n\n信号 $y[n]$ 是通过将 $x[n]$ 的奇数索引样本设置为零而形成的：\n$$\ny[n] = x[n] \\cdot p[n], \\quad \\text{其中} \\quad p[n] = \\frac{1 + (-1)^n}{2} = \\frac{1 + e^{i\\pi n}}{2}\n$$\n序列 $p[n]$ 充当采样函数。两个序列乘积的 DFT 是它们各自 DFT 的循环卷积，并按 $1/N$ 缩放。$p[n]$ 的 DFT 为 $P[m] = \\frac{N}{2} (\\delta[m] + \\delta[m - N/2])$，因为 $e^{i\\pi n} = e^{i\\frac{2\\pi(N/2)n}{N}}$ 且 $N$ 为偶数。\n$y[n]$ 的 DFT，表示为 $Y[m]$，则为：\n$$\nY[m] = \\frac{1}{N} (X * P)[m] = \\frac{1}{N} \\sum_{k=0}^{N-1} X[k] P[(m-k) \\pmod N]\n$$\n代入 $P[m]$ 的表达式，可得到该操作著名的混叠公式：\n$$\nY[m] = \\frac{1}{N} \\left( X[m] \\cdot \\frac{N}{2} + X[(m - N/2) \\pmod N] \\cdot \\frac{N}{2} \\right) = \\frac{1}{2} \\left( X[m] + X[(m - N/2) \\pmod N] \\right)\n$$\n这个基本关系表明，在给定频率斌 $m$ 处的频谱 $Y[m]$ 是原始频谱 $X[m]$ 在谱斌 $m$ 处和在谱斌 $(m - N/2) \\pmod N$ 处的值的平均值。这是混叠的一种表现。$m'$ 处的频率分量的能量被折叠到 $m = (m' \\pm N/2) \\pmod N$。\n\n为了解决这个问题，我们将根据问题定义对每个测试用例实施直接模拟：\n1.  对于一组给定的参数 $(N, \\{m_k\\}, \\{A_k\\}, \\{\\varphi_k\\})$，构造信号 $x[n]$，其中 $n=0, 1, \\dots, N-1$。\n2.  通过设置当 $n$ 为偶数时 $y[n] = x[n]$，当 $n$ 为奇数时 $y[n]=0$ 来构造信号 $y[n]$。\n3.  使用标准的快速傅里叶变换 (FFT) 算法计算 DFT $Y[m] = \\text{DFT}\\{y[n]\\}$。\n4.  从给定的 $\\{m_k\\}$ 构造信号斌集合 $\\mathcal{S}$。\n5.  计算 $y[n]$ 频谱中的总功率为 $P_{\\text{total}} = \\sum_{m=0}^{N-1} |Y[m]|^2$。\n6.  计算集中在原始信号斌中的功率为 $P_{\\text{signal}} = \\sum_{m \\in \\mathcal{S}} |Y[m]|^2$。\n7.  混叠伪影功率是差值：$P_{\\text{alias}} = P_{\\text{total}} - P_{\\text{signal}}$。\n8.  最终的度量指标是比率 $R = P_{\\text{alias}} / P_{\\text{signal}}$。虽然在所提供的测试用例中不会发生，但处理了潜在的除零情况。\n9.  每个用例计算出的 $R$ 值按要求四舍五入到小数点后六位。\n\n此过程精确地模拟了所描述的物理和数学过程，并将产生正确的数值结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ... No scipy functions beyond fft which is in numpy are needed.\n\ndef solve():\n    \"\"\"\n    Solves the signal processing problem for a suite of test cases.\n    For each case, it computes the aliasing-to-signal power ratio R.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (N, {m_k}, {A_k}, {phi_k})\n    test_cases = [\n        (1024, [50], [1.0], [0.0]),\n        (1024, [30, 100], [1.0, 0.8], [0.0, 0.3]),\n        (1024, [256], [1.0], [0.7]),\n        (1024, [0], [1.2], [0.0]),\n        (1024, [60, 572], [1.0, 0.5], [0.0, 1.0]),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, m_k_list, A_k_list, phi_k_list = case\n        \n        # Step 1: Construct the signal x[n]\n        n_indices = np.arange(N)\n        x = np.zeros(N, dtype=float)\n        for m_k, A_k, phi_k in zip(m_k_list, A_k_list, phi_k_list):\n            omega_k = (2 * np.pi * m_k) / N\n            x += A_k * np.cos(omega_k * n_indices + phi_k)\n            \n        # Step 2: Construct the signal y[n] from even-indexed samples\n        y = np.zeros(N, dtype=float)\n        y[::2] = x[::2]\n        \n        # Step 3: Compute the DFT of y[n]\n        Y = np.fft.fft(y)\n        \n        # Step 4: Define the set of original spectral bins S\n        S = set()\n        for m_k in m_k_list:\n            S.add(m_k)\n            S.add((-m_k) % N)\n            \n        # Step 5: Calculate total power\n        P_total = np.sum(np.abs(Y)**2)\n        \n        # Step 6: Calculate signal-bin power\n        P_signal = 0.0\n        for m in S:\n            P_signal += np.abs(Y[m])**2\n            \n        # Step 7: Calculate aliasing-artifact power\n        P_alias = P_total - P_signal\n        \n        # Step 8: Calculate the ratio R\n        # Handle the case where P_signal might be zero to avoid division by zero.\n        if P_signal == 0:\n            # If there is no signal power but there is alias power, the ratio is infinite.\n            # If there is no alias power either, the ratio is undefined, which we can treat as 0.\n            R = np.inf if P_alias > 0 else 0.0\n        else:\n            R = P_alias / P_signal\n            \n        # Append the rounded result. Add a small epsilon for rounding stability,\n        # especially for values extremely close to x.5 * 10^-n.\n        results.append(round(R + 1e-9, 6))\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "从实验数据中计算变化率——例如从位置计算速度——是物理学中一项常见的任务，这在数学上对应于求导。本练习直面一个真实世界中的挑战：如何对充满噪声的信号进行数值微分。您将对比直接应用差分公式所导致的灾难性结果与一种更为稳健的方法——先进行高斯平滑滤波再求导——的效果，从而深刻理解在降噪与保持信号真实性之间的重要权衡。",
            "id": "2438105",
            "problem": "提供一个标量实验测量的合成时间序列模型，该测量含有加性噪声，并在时间上进行离散采样。设采样频率为 $f_s = 1000 \\, \\text{s}^{-1}$，采样点数为 $N = 4096$，采样间隔为 $\\Delta t = 1/f_s$。定义连续时间底层信号 $x(t)$ 及其精确时间导数 $x'(t)$ 如下：\n$$\nx(t) = A_1 \\sin(2\\pi f_1 t) + A_2 \\cos(2\\pi f_2 t) + A_3 t,\n$$\n其中 $A_1 = 1$， $f_1 = 5 \\, \\text{s}^{-1}$，$A_2 = 0.3$，$f_2 = 40$ $\\text{s}^{-1}$，以及 $A_3 = 0.2 \\, \\text{s}^{-1}$。角度单位为弧度。精确导数为\n$$\nx'(t) = 2\\pi f_1 A_1 \\cos(2\\pi f_1 t) - 2\\pi f_2 A_2 \\sin(2\\pi f_2 t) + A_3.\n$$\n设离散采样时间为 $t_n = n \\Delta t$，其中整数 $n \\in \\{0,1,\\dots,N-1\\}$。测量的离散时间信号 $y[n]$ 定义为\n$$\ny[n] = x(t_n) + \\eta[n],\n$$\n其中 $\\eta[n]$ 是独立同分布的零均值高斯随机变量，其标准差 $\\sigma_{\\eta}$ 的单位与 $x(t)$ 相同。为确保所有测试用例中 $\\eta[n]$ 的可复现性，请使用固定的伪随机数生成器种子 $S = 1337$。\n\n您的任务是使用两种方法估计含噪测量的时间导数，并将其准确性与精确导数 $x'(t_n)$ 进行比较：\n1. 对含噪数据进行直接中心差分：\n$$\n\\widehat{d}_{\\text{direct}}[n] = \\frac{y[n+1] - y[n-1]}{2\\Delta t},\n$$\n定义域为 $n \\in \\{1,2,\\dots,N-2\\}$。\n2. 先进行高斯平滑，然后进行相同的中心差分：\n   - 定义离散零相高斯核，其标准差为 $\\sigma_g$（以采样点为单位），如下：\n   $$\n   g[k] = \\frac{\\exp\\!\\left(-\\frac{k^2}{2\\sigma_g^2}\\right)}{\\sum_{m=-K}^{K} \\exp\\!\\left(-\\frac{m^2}{2\\sigma_g^2}\\right)},\n   $$\n   其中 $K = \\lceil 3\\sigma_g \\rceil$ 且 $k \\in \\{-K,-K+1,\\dots,0,\\dots,K-1,K\\}$。如果 $\\sigma_g = 0$，则定义 $g[0] = 1$ 且对于 $k \\neq 0$ 有 $g[k] = 0$。\n   - 将平滑后信号定义为离散卷积\n   $$\n   z[n] = \\sum_{k=-K}^{K} g[k]\\, y[n-k],\n   $$\n   此处的理解是，$\\{0,\\dots,N-1\\}$ 范围外的索引被隐式处理，方法是只考虑后续差分有明确定义的有效样本，并且仅对 $n \\in \\{1,2,\\dots,N-2\\}$ 的范围比较误差。\n   - 对 $z[n]$ 应用相同的中心差分：\n   $$ \n   \\widehat{d}_{\\text{smooth}}[n] = \\frac{z[n+1] - z[n-1]}{2\\Delta t},\n   $$\n   对于 $n \\in \\{1,2,\\dots,N-2\\}$。\n\n对于每种方法，使用相对均方根误差（rRMSE）来量化其准确性：\n$$\n\\mathrm{rRMSE}_{\\text{method}} = \\frac{\\sqrt{\\frac{1}{M}\\sum_{n=n_{\\min}}^{n_{\\max}}\\left(\\widehat{d}_{\\text{method}}[n] - x'(t_n)\\right)^2}}{\\sqrt{\\frac{1}{M}\\sum_{n=n_{\\min}}^{n_{\\max}} \\left(x'(t_n)\\right)^2}},\n$$\n其中 $n_{\\min} = 1$，$n_{\\max} = N-2$，且 $M = n_{\\max}-n_{\\min}+1$。该值为无量纲量。同时计算改进因子\n$$\n\\rho = \\frac{\\mathrm{rRMSE}_{\\text{direct}}}{\\mathrm{rRMSE}_{\\text{smooth}}}.\n$$\n\n实现一个完整、可运行的程序，该程序按定义构建信号和噪声，应用两种估计方法，并为以下每个测试用例计算指标。每个测试用例由 $(\\sigma_{\\eta}, \\sigma_g)$ 唯一指定，其中 $\\sigma_{\\eta}$ 是噪声标准差，$\\sigma_g$ 是高斯核标准差（以采样点为单位）：\n- 用例 1：$(\\sigma_{\\eta}, \\sigma_g) = (0.5, 0.0)$。\n- 用例 2：$(\\sigma_{\\eta}, \\sigma_g) = (0.5, 2.0)$。\n- 用例 3：$(\\sigma_{\\eta}, \\sigma_g) = (2.0, 4.0)$。\n- 用例 4：$(\\sigma_{\\eta}, \\sigma_g) = (0.0, 4.0)$。\n\n所有最终数值输出必须是无单位的，并表示为十进制浮点数。对于每个测试用例，返回一个包含三个值的列表 $[\\mathrm{rRMSE}_{\\text{direct}}, \\mathrm{rRMSE}_{\\text{smooth}}, \\rho]$，每个值都四舍五入到恰好 6 位小数。您的程序应生成单行输出，其中包含四个测试用例的结果，形式为方括号括起来的逗号分隔列表，其中每个测试用例的结果本身也是一个方括号括起来的逗号分隔列表。例如，格式必须是\n\"[ [d1,s1,r1],[d2,s2,r2],[d3,s3,r3],[d4,s4,r4] ]\"\n其中每个 $d_i$、$s_i$ 和 $r_i$ 都被相应的四舍五入后的十进制值替换。",
            "solution": "所提出的问题是计算物理学领域中的一个定义明确的练习，具体涉及实验数据的信号处理领域。它要求使用两种不同的方法来估计含噪信号的时间导数，并对其准确性进行定量比较。该问题具有科学依据、客观，并为计算出唯一解提供了所有必要信息。因此，该问题被认为是有效的。\n\n我将通过以下步骤来解决问题：首先构建信号及其导数，然后实现两种估计方法，最后为每个测试用例计算指定的误差指标。\n\n**1. 预备知识：信号与系统定义**\n\n问题为模拟提供了一组固定参数。\n- 采样频率：$f_s = 1000$ s$^{-1}$\n- 采样点数：$N = 4096$\n- 采样间隔：$\\Delta t = 1/f_s = 0.001$ s\n- 时间向量：$t_n = n \\Delta t$，对于 $n \\in \\{0, 1, \\dots, N-1\\}$\n- 伪随机数生成器种子：$S = 1337$\n\n连续时间信号 $x(t)$ 是两个正弦波和一个线性趋势的总和：\n$$\nx(t) = A_1 \\sin(2\\pi f_1 t) + A_2 \\cos(2\\pi f_2 t) + A_3 t\n$$\n参数为 $A_1 = 1.0$，$f_1 = 5.0$ s$^{-1}$，$A_2 = 0.3$，$f_2 = 40.0$ s$^{-1}$，以及 $A_3 = 0.2$ s$^{-1}$。\n\n其精确时间导数由下式给出：\n$$\nx'(t) = 2\\pi f_1 A_1 \\cos(2\\pi f_1 t) - 2\\pi f_2 A_2 \\sin(2\\pi f_2 t) + A_3\n$$\n\n测得的信号 $y[n]$ 是离散时间的纯净信号 $x(t_n)$ 被标准差为 $\\sigma_{\\eta}$ 的加性高斯白噪声 $\\eta[n]$ 所污染的结果：\n$$\ny[n] = x(t_n) + \\eta[n]\n$$\n\n**2. 导数估计方法**\n\n任务的核心是比较估计导数 $x'(t_n)$ 的两种方法。两种方法都在区间 $n \\in \\{1, 2, \\dots, N-2\\}$ 上进行评估。\n\n**方法 1：直接中心差分**\n\n此方法使用直接应用于含噪数据 $y[n]$ 的标准中心差分公式来近似导数：\n$$\n\\widehat{d}_{\\text{direct}}[n] = \\frac{y[n+1] - y[n-1]}{2\\Delta t}\n$$\n这个计算很简单。然而，众所周知，对含噪信号应用差分算子会放大噪声。导数估计中噪声分量的方差与 $\\sigma_{\\eta}^2 / (\\Delta t)^2$ 成正比，对于小的 $\\Delta t$ 来说，这个值可能相当大。\n\n**方法 2：先平滑后中心差分**\n\n该方法试图通过首先对信号 $y[n]$ 应用低通滤波器，然后对平滑后的结果进行微分，来减轻噪声放大效应。\n\n- **平滑处理**：通过与一个零相高斯核 $g[k]$ 进行离散卷积来完成平滑。\n  - 核的宽度由参数 $\\sigma_g$（以采样点为单位）控制。\n  - 核的定义域为 $k \\in \\{-K, \\dots, K\\}$，其中 $K = \\lceil 3\\sigma_g \\rceil$。\n  - 公式为：\n    $$\n    g[k] = \\frac{\\exp\\!\\left(-\\frac{k^2}{2\\sigma_g^2}\\right)}{Z}, \\quad \\text{其中 } Z = \\sum_{m=-K}^{K} \\exp\\!\\left(-\\frac{m^2}{2\\sigma_g^2}\\right)\n    $$\n  - 对于 $\\sigma_g = 0$ 定义了一个特殊情况，此时核函数变成一个离散的 delta 函数，$g[0]=1$ 且对于 $k \\neq 0$ 有 $g[k]=0$。在这种情况下，与 $g[k]$ 进行卷积不会改变信号。\n  - 平滑后的信号为 $z[n] = (y * g)[n] = \\sum_{k=-K}^{K} g[k] y[n-k]$。这是一个标准的卷积运算。为了生成与 $y[n]$ 长度相同的输出 $z[n]$，我们使用 'same' 卷积模式，该模式通过填充输入信号（通常用零填充）来隐式处理边界效应。这些边界效应会在平滑后信号 $z[n]$ 的开始和结束处引入误差。\n\n- **微分处理**：然后将相同的中心差分公式应用于平滑后的信号 $z[n]$：\n  $$\n  \\widehat{d}_{\\text{smooth}}[n] = \\frac{z[n+1] - z[n-1]}{2\\Delta t}\n  $$\n\n这个两步过程体现了一个经典的权衡：平滑滤波器减少了噪声（方差），但同时也可能通过衰减其高频分量而扭曲底层信号，从而引入系统误差（偏差）。$\\sigma_g$ 的最优选择取决于信号的频率内容和噪声水平。\n\n**3. 误差量化**\n\n每种方法的准确性通过相对均方根误差 (rRMSE) 来衡量。该指标在评估区间 $n \\in \\{1, \\dots, N-2\\}$ 上，比较了估计误差的均方根值与真实导数信号的均方根值。\n\n$$\n\\mathrm{rRMSE}_{\\text{method}} = \\frac{\\sqrt{\\frac{1}{M}\\sum_{n=1}^{N-2}\\left(\\widehat{d}_{\\text{method}}[n] - x'(t_n)\\right)^2}}{\\sqrt{\\frac{1}{M}\\sum_{n=1}^{N-2} \\left(x'(t_n)\\right)^2}}\n$$\n其中 $M = N-2$。\n\n改进因子 $\\rho$ 量化了平滑方法相对于直接方法的性能增益：\n$$\n\\rho = \\frac{\\mathrm{rRMSE}_{\\text{direct}}}{\\mathrm{rRMSE}_{\\text{smooth}}}\n$$\n$\\rho > 1$ 的值表明平滑处理改进了导数估计。\n\n**4. 实现策略**\n\n解决方案将使用 Python 实现，其中 `numpy` 库用于数值运算和数组处理，`scipy.signal` 用于卷积。一个单一函数将为每个指定的测试用例执行整个处理流程。\n\n- **初始化**：设置所有常量和伪随机数生成器（使用指定的种子）。\n- **信号生成**：生成离散时间向量 `t`、纯净信号 `x` 和精确导数 `x_prime`。\n- **主循环**：遍历所提供的测试用例 $(\\sigma_{\\eta}, \\sigma_g)$。\n- **循环内部**：\n  1. 生成由 $\\sigma_{\\eta}$ 缩放的噪声向量 $\\eta$，并将其加到 `x` 上以创建含噪信号 `y`。\n  2. **方法 1**：通过对 `y` 应用中心差分来计算 `d_direct_est`。\n  3. **方法 2**：\n     - 如果 $\\sigma_g > 0$，构建高斯核 `g`，然后使用 `scipy.signal.convolve(y, g, mode='same')` 计算平滑信号 `z`。\n     - 如果 $\\sigma_g = 0$，设置 `z = y`。\n     - 通过对 `z` 应用中心差分来计算 `d_smooth_est`。\n  4. **误差计算**：\n     - 通过对 `x_prime` 进行切片以匹配评估区间，来定义目标导数 `d_exact`。\n     - 计算两种方法的误差均方根值以及精确导数信号的均方根值。\n     - 计算 $\\mathrm{rRMSE}_{\\text{direct}}$、$\\mathrm{rRMSE}_{\\text{smooth}}$ 和 $\\rho$。\n  5. 存储当前测试用例的四舍五入结果。\n- **输出**：将收集到的结果格式化为指定的字符串格式并打印到标准输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import signal\n\ndef solve():\n    \"\"\"\n    Solves the signal processing problem as defined.\n    Constructs a synthetic signal, adds noise, and compares two methods\n    for estimating its time derivative.\n    \"\"\"\n    # Define problem constants\n    f_s = 1000.0  # Sampling frequency in s^-1\n    N = 4096      # Number of samples\n    dt = 1.0 / f_s  # Sampling interval in s\n\n    A1 = 1.0\n    f1 = 5.0      # s^-1\n    A2 = 0.3\n    f2 = 40.0     # s^-1\n    A3 = 0.2      # s^-1\n\n    S = 1337      # Pseudorandom number generator seed\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (sigma_eta, sigma_g)\n        (0.5, 0.0),\n        (0.5, 2.0),\n        (2.0, 4.0),\n        (0.0, 4.0),\n    ]\n\n    # Generate time vector, clean signal, and its exact derivative\n    t = np.arange(N) * dt\n    x = (A1 * np.sin(2 * np.pi * f1 * t) +\n         A2 * np.cos(2 * np.pi * f2 * t) +\n         A3 * t)\n    x_prime = (2 * np.pi * f1 * A1 * np.cos(2 * np.pi * f1 * t) -\n               2 * np.pi * f2 * A2 * np.sin(2 * np.pi * f2 * t) +\n               A3)\n\n    # Initialize the random number generator\n    rng = np.random.default_rng(seed=S)\n    \n    results = []\n    \n    # Process each test case\n    for sigma_eta, sigma_g in test_cases:\n        # Generate the noisy measurement\n        # The problem statement implies the stochastic process should be reproducible,\n        # which is achieved by using the same generator instance over the loop.\n        noise = sigma_eta * rng.standard_normal(N)\n        y = x + noise\n\n        # Method 1: Direct central differencing\n        # Valid for n in {1, ..., N-2}, resulting in N-2 points\n        d_direct_est = (y[2:] - y[:-2]) / (2 * dt)\n\n        # Method 2: Gaussian smoothing followed by central differencing\n        if sigma_g == 0.0:\n            z = y  # No smoothing\n        else:\n            # Define the discrete zero-phase Gaussian kernel\n            K = int(np.ceil(3 * sigma_g))\n            k = np.arange(-K, K + 1)\n            kernel_vals = np.exp(-k**2 / (2 * sigma_g**2))\n            g = kernel_vals / np.sum(kernel_vals)\n            \n            # Convolve the signal with the kernel\n            # 'same' mode ensures output length is N, with boundary effects\n            z = signal.convolve(y, g, mode='same')\n        \n        # Apply central difference to the smoothed signal\n        d_smooth_est = (z[2:] - z[:-2]) / (2 * dt)\n\n        # Quantify accuracy using relative RMS error\n        # The evaluation range is n in {1, ..., N-2}, so we slice the exact derivative\n        d_exact_eval = x_prime[1:-1]\n        \n        # Denominator for rRMSE: RMS of the exact derivative\n        rms_exact_deriv = np.sqrt(np.mean(d_exact_eval**2))\n\n        # Calculate rRMSE for the direct method\n        rms_err_direct = np.sqrt(np.mean((d_direct_est - d_exact_eval)**2))\n        rRMSE_direct = rms_err_direct / rms_exact_deriv\n\n        # Calculate rRMSE for the smoothed method\n        rms_err_smooth = np.sqrt(np.mean((d_smooth_est - d_exact_eval)**2))\n        rRMSE_smooth = rms_err_smooth / rms_exact_deriv\n        \n        # Handle potential division by zero if rRMSE_smooth is zero\n        if rRMSE_smooth == 0.0:\n            # This can happen in noise-free cases if the method is perfect.\n            # If direct is also zero, improvement is 1. Otherwise, infinite.\n            # Given the nature of the problem, this is unlikely.\n            rho = 1.0 if rRMSE_direct == 0.0 else np.inf\n        else:\n            rho = rRMSE_direct / rRMSE_smooth\n            \n        case_result = [\n            round(rRMSE_direct, 6),\n            round(rRMSE_smooth, 6),\n            round(rho, 6)\n        ]\n        results.append(case_result)\n\n    # Format the final output string as per requirements\n    inner_strings = [f\"[{','.join(map(str, res))}]\" for res in results]\n    final_output = f\"[{','.join(inner_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n\n```"
        }
    ]
}