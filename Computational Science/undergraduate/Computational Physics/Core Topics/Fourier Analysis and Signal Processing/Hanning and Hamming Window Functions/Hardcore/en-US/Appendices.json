{
    "hands_on_practices": [
        {
            "introduction": "The choice between window functions often involves navigating a fundamental trade-off between frequency resolution and spectral leakage suppression. This practice provides a hands-on way to explore this trade-off by constructing a hybrid window that smoothly interpolates between the Hanning and Hamming types . By calculating key performance metrics like mainlobe width and peak sidelobe level, you will gain a quantitative understanding of how these properties are balanced in window design.",
            "id": "2399871",
            "problem": "You are given the task of constructing and analyzing a hybrid discrete-time window function formed by a convex combination of the Hanning window and the Hamming window. Let the window length be $N=128$, and let the sample index be $n \\in \\{0,1,\\ldots,N-1\\}$. Define the Hanning window $W_{Hanning}(n)$ and the Hamming window $W_{Hamming}(n)$ by\n$$\nW_{Hanning}(n) = \\tfrac{1}{2} - \\tfrac{1}{2}\\cos\\!\\left(\\tfrac{2\\pi n}{N-1}\\right), \\quad\nW_{Hamming}(n) = 0.54 - 0.46\\cos\\!\\left(\\tfrac{2\\pi n}{N-1}\\right).\n$$\nFor a mixing parameter $\\alpha \\in [0,1]$, define the hybrid window\n$$\nW(n;\\alpha) = \\alpha\\, W_{Hanning}(n) + (1-\\alpha)\\, W_{Hamming}(n).\n$$\nLet $x[n]$ be the zero-padded sequence of length $L=262144$ defined by $x[n]=W(n;\\alpha)$ for $0 \\le n \\le N-1$ and $x[n]=0$ otherwise. Let $X[k]$ denote the $L$-point Discrete Fourier Transform (DFT) of $x[n]$:\n$$\nX[k] = \\sum_{n=0}^{L-1} x[n]\\,e^{-i\\,2\\pi kn/L}, \\quad k=0,1,\\ldots,L-1.\n$$\nDefine the centered spectrum $X_s[m]$ by a circular shift\n$$\nX_s[m] = X\\big((m + \\tfrac{L}{2}) \\bmod L\\big), \\quad m=0,1,\\ldots,L-1,\n$$\nand let the corresponding magnitude be $A[m]=|X_s[m]|$. Let $m_0 = \\tfrac{L}{2}$ denote the index of the direct current (DC) component in the centered spectrum. Define $m_L$ and $m_R$ as the nearest indices with $m_L &lt; m_0 &lt; m_R$ such that $A[m_L]$ and $A[m_R]$ are strict local minima of the discrete sequence $A[m]$, and there is no other strict local minimum in the open intervals $(m_L,m_0)$ and $(m_0,m_R)$, respectively.\n\nUsing these definitions, for each given value of $\\alpha$, compute the following three scalar metrics:\n1. The mainlobe width in normalized frequency (cycles per sample), defined by\n$$\nw(\\alpha) = \\frac{m_R - m_L}{L}.\n$$\n2. The peak sidelobe level in decibels, defined by\n$$\n\\mathrm{PSL}(\\alpha) = 20 \\log_{10} \\left( \\frac{\\max\\big\\{\\max_{0 \\le m &lt; m_L} A[m],\\ \\max_{m_R &lt; m \\le L-1} A[m]\\big\\}}{A[m_0]} \\right).\n$$\n3. The equivalent noise bandwidth (ENBW) in DFT-bin units, defined by\n$$\n\\mathrm{ENBW}(\\alpha) = N\\, \\frac{\\sum_{n=0}^{N-1} W(n;\\alpha)^2}{\\left(\\sum_{n=0}^{N-1} W(n;\\alpha)\\right)^2}.\n$$\n\nAll quantities above are dimensionless. The decibel scale for $\\mathrm{PSL}(\\alpha)$ must be computed using the base-$10$ logarithm of the amplitude ratio as given. Angles are not used in the final answers and therefore no angle unit is required.\n\nTest Suite:\nEvaluate the triple $[w(\\alpha), \\mathrm{PSL}(\\alpha), \\mathrm{ENBW}(\\alpha)]$ for the following five values of $\\alpha$:\n- $\\alpha = 0.0$,\n- $\\alpha = 0.5$,\n- $\\alpha = 1.0$,\n- $\\alpha = 0.2$,\n- $\\alpha = 0.8$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is itself a list of three floating-point numbers $[w(\\alpha), \\mathrm{PSL}(\\alpha), \\mathrm{ENBW}(\\alpha)]$ for the corresponding $\\alpha$ in the order listed above. Each floating-point number must be rounded to six decimal places. For example, a valid output format is\n$$\n\\big[\\,[w_1,\\mathrm{PSL}_1,\\mathrm{ENBW}_1],[w_2,\\mathrm{PSL}_2,\\mathrm{ENBW}_2],\\ldots\\,\\big],\n$$\nwith the exact numeric values determined by your computation.",
            "solution": "The problem as stated is well-defined, internally consistent, and scientifically sound. It presents a standard exercise in the analysis of digital window functions, a fundamental topic in signal processing and computational physics. We shall proceed with the solution.\n\nThe objective is to synthesize and analyze a hybrid window function, which is a convex combination of the Hanning and Hamming windows, by computing three standard performance metrics: mainlobe width, peak sidelobe level, and equivalent noise bandwidth.\n\nFirst, we define the constituent windows and the hybrid window. The window length is given as $N=128$, and the sample index is $n \\in \\{0, 1, \\dots, N-1\\}$. The Hanning window, $W_{Hanning}(n)$, and the Hamming window, $W_{Hamming}(n)$, are defined as:\n$$\nW_{Hanning}(n) = \\frac{1}{2} - \\frac{1}{2}\\cos\\left(\\frac{2\\pi n}{N-1}\\right) = 0.5 - 0.5\\cos\\left(\\frac{2\\pi n}{127}\\right)\n$$\n$$\nW_{Hamming}(n) = 0.54 - 0.46\\cos\\left(\\frac{2\\pi n}{N-1}\\right) = 0.54 - 0.46\\cos\\left(\\frac{2\\pi n}{127}\\right)\n$$\nThese are \"symmetric\" or \"DFT-even\" versions of the windows, which are zero at the first and last samples for Hanning, and near-zero for Hamming. The hybrid window, $W(n;\\alpha)$, is formed by a linear interpolation controlled by the parameter $\\alpha \\in [0,1]$:\n$$\nW(n;\\alpha) = \\alpha\\, W_{Hanning}(n) + (1-\\alpha)\\, W_{Hamming}(n)\n$$\nFor $\\alpha=1$, the window is pure Hanning, and for $\\alpha=0$, it is pure Hamming. The Hanning window is known for its good sidelobe roll-off, while the Hamming window is optimized to minimize the peak sidelobe level, at the cost of a slightly wider mainlobe. The parameter $\\alpha$ thus navigates the trade-off between these properties.\n\nTo analyze the spectral characteristics of this window, we examine its Discrete Fourier Transform (DFT). The window sequence of length $N$ is zero-padded to a much larger length $L=262144$. This creates a new sequence $x[n]$ of length $L$. Zero-padding does not alter the underlying continuous spectrum of the window, but it interpolates the spectrum by computing the DFT at a finer frequency grid. This dense sampling is essential for accurately measuring features like lobe widths and peak levels. The $L$-point DFT, $X[k]$, is computed as:\n$$\nX[k] = \\sum_{n=0}^{L-1} x[n]\\,e^{-i\\,2\\pi kn/L}\n$$\nFor analysis, the spectrum is circularly shifted to place the zero-frequency (DC) component at the center of the array. The centered spectrum $X_s[m]$ and its magnitude $A[m]$ are given by:\n$$\nX_s[m] = X\\big((m + \\tfrac{L}{2}) \\bmod L\\big), \\quad A[m] = |X_s[m]|\n$$\nThe peak of the mainlobe is located at the center index $m_0 = L/2$.\n\nWith these definitions in place, we proceed to calculate the three specified metrics for each given value of $\\alpha$.\n\n1.  **Equivalent Noise Bandwidth (ENBW)**: This metric measures the effective bandwidth of the window as if it were an ideal rectangular filter, in units of DFT bins. It is calculated directly from the window coefficients (not the zero-padded sequence) using the formula:\n    $$\n    \\mathrm{ENBW}(\\alpha) = N\\, \\frac{\\sum_{n=0}^{N-1} W(n;\\alpha)^2}{\\left(\\sum_{n=0}^{N-1} W(n;\\alpha)\\right)^2}\n    $$\n    This calculation does not require the DFT. It is a measure of how the window spreads the energy of a white noise signal.\n\n2.  **Mainlobe Width ($w$)**: The mainlobe width is a key indicator of frequency resolution. It is defined by the distance between the first nulls (minima) on either side of the central peak. We must find the indices $m_L$ and $m_R$ which are the nearest strict local minima to the central peak at $m_0$. A strict local minimum at index $m$ is defined by the condition $A[m] < A[m-1]$ and $A[m] < A[m+1]$. We find $m_L$ by searching downwards from $m_0-1$ and $m_R$ by searching upwards from $m_0+1$. The mainlobe width is then the normalized frequency difference:\n    $$\n    w(\\alpha) = \\frac{m_R - m_L}{L}\n    $$\n\n3.  **Peak Sidelobe Level (PSL)**: The PSL quantifies the spectral leakage, which can obscure weak signals. It is the magnitude of the highest sidelobe peak relative to the mainlobe peak, expressed in decibels. The sidelobes exist in the spectral regions outside the mainlobe, i.e., for indices $m \\in [0, m_L-1] \\cup [m_R+1, L-1]$. The peak sidelobe magnitude is found by taking the maximum of $A[m]$ over these regions. The PSL is then:\n    $$\n    \\mathrm{PSL}(\\alpha) = 20 \\log_{10} \\left( \\frac{\\max\\left\\{\\max_{0 \\le m < m_L} A[m], \\max_{m_R < m \\le L-1} A[m]\\right\\}}{A[m_0]} \\right)\n    $$\n    A more negative value in dB indicates better sidelobe suppression.\n\nThe computational procedure involves implementing these steps for each value of $\\alpha$ in the test suite $\\{0.0, 0.5, 1.0, 0.2, 0.8\\}$, and collecting the resulting triple $[w(\\alpha), \\mathrm{PSL}(\\alpha), \\mathrm{ENBW}(\\alpha)]$. Numerical computations are performed using the `NumPy` library in `Python`.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs and analyzes a hybrid Hanning-Hamming window function.\n    \n    For several mixing parameters alpha, it computes three metrics:\n    1. Mainlobe width (w)\n    2. Peak Sidelobe Level (PSL)\n    3. Equivalent Noise Bandwidth (ENBW)\n    \"\"\"\n\n    # --- Problem Parameters ---\n    N = 128           # Window length\n    L = 262144        # DFT length (zero-padding)\n    test_alphas = [0.0, 0.5, 1.0, 0.2, 0.8] # Mixing parameters\n\n    # --- Container for results ---\n    results = []\n\n    # --- Main loop over test cases ---\n    for alpha in test_alphas:\n        # Step 1: Construct the hybrid window function W(n; alpha)\n        n = np.arange(N, dtype=np.float64)\n        \n        w_hanning = 0.5 - 0.5 * np.cos(2 * np.pi * n / (N - 1))\n        w_hamming = 0.54 - 0.46 * np.cos(2 * np.pi * n / (N - 1))\n        \n        W = alpha * w_hanning + (1 - alpha) * w_hamming\n\n        # Step 2: Calculate Equivalent Noise Bandwidth (ENBW)\n        # This is calculated from the original window coefficients.\n        sum_W = np.sum(W)\n        sum_W_sq = np.sum(W**2)\n        enbw = N * sum_W_sq / (sum_W**2)\n\n        # Step 3: Compute the L-point DFT of the zero-padded window\n        # Create zero-padded sequence x[n]\n        x = np.zeros(L, dtype=np.float64)\n        x[:N] = W\n        \n        # Compute DFT and then shift it to center the DC component\n        X = np.fft.fft(x)\n        Xs = np.fft.fftshift(X)\n        A = np.abs(Xs)\n\n        # Step 4: Analyze the magnitude spectrum A[m] to find mainlobe width (w)\n        m0 = L // 2  # Index of the DC component (mainlobe peak)\n\n        # Find m_L, the first strict local minimum to the left of the peak\n        m_L = -1\n        # Search from m0-1 down to 1. Index m=0 is not checked for minimum.\n        for m in range(m0 - 1, 0, -1):\n            if A[m] < A[m - 1] and A[m] < A[m + 1]:\n                m_L = m\n                break\n        \n        # Find m_R, the first strict local minimum to the right of the peak\n        m_R = -1\n        # Search from m0+1 up to L-2. Index L-1 is not checked.\n        for m in range(m0 + 1, L - 1):\n            if A[m] < A[m - 1] and A[m] < A[m + 1]:\n                m_R = m\n                break\n\n        # A check for robustness, though minima should exist for these windows.\n        if m_L == -1 or m_R == -1:\n            raise ValueError(f\"Could not find mainlobe nulls for alpha = {alpha}\")\n\n        # Calculate mainlobe width in normalized frequency\n        w = (m_R - m_L) / L\n        \n        # Step 5: Calculate Peak Sidelobe Level (PSL)\n        A_m0 = A[m0] # Magnitude of the mainlobe peak\n        \n        # Find peak magnitude in the sidelobe regions\n        sidelobe_region_left = A[0:m_L]\n        sidelobe_region_right = A[m_R + 1:]\n        \n        peak_sidelobe = max(np.max(sidelobe_region_left), np.max(sidelobe_region_right))\n        \n        # Calculate PSL in decibels\n        psl = 20 * np.log10(peak_sidelobe / A_m0)\n\n        # Store the triple of metrics for this alpha\n        results.append([w, psl, enbw])\n    \n    # --- Final Output Formatting ---\n    # The output format is a string representation of a list of lists,\n    # with each float formatted to 6 decimal places.\n    outer_list_parts = []\n    for res_tuple in results:\n        inner_list_str = f\"[{res_tuple[0]:.6f},{res_tuple[1]:.6f},{res_tuple[2]:.6f}]\"\n        outer_list_parts.append(inner_list_str)\n\n    final_output_string = f\"[{','.join(outer_list_parts)}]\"\n\n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "Moving from theoretical metrics to a practical scenario, this exercise challenges you to resolve a very faint signal in the presence of a much stronger one—a common task in experimental physics and engineering. You will use a quantitative \"detection advantage\" metric to determine whether the Hanning or Hamming window is more effective for signals with different frequency separations . This practice powerfully demonstrates the real-world consequences of the sidelobe behavior for each window type.",
            "id": "2399897",
            "problem": "A continuous-time signal is defined by the superposition of two sinusoidal components with markedly different amplitudes: $$x(t) = \\sin(2\\pi f_1 t) + 10^{-4}\\,\\sin(2\\pi f_2 t),$$ where $t$ is time in seconds, and $f_1$ and $f_2$ are frequencies in Hertz. Consider the uniformly sampled discrete-time sequence of length $N$ obtained with sampling frequency $f_s$ as $$x[n] = \\sin\\!\\left(2\\pi \\frac{f_1}{f_s} n\\right) + 10^{-4}\\,\\sin\\!\\left(2\\pi \\frac{f_2}{f_s} n\\right), \\quad n=0,1,\\dots,N-1,$$ where all angles are in radians. To suppress spectral leakage when estimating the spectrum, the data are multiplied by a window $w[n]$ prior to computing the Discrete Fourier Transform (DFT). Two classical windows are to be compared:\n\n- The Hann (sometimes called “Hanning”) window: $$w_{\\mathrm{Hann}}[n] = \\tfrac{1}{2}\\left(1 - \\cos\\!\\left(2\\pi \\frac{n}{N-1}\\right)\\right), \\quad n=0,1,\\dots,N-1.$$\n- The Hamming window: $$w_{\\mathrm{Hamm}}[n] = 0.54 - 0.46 \\cos\\!\\left(2\\pi \\frac{n}{N-1}\\right), \\quad n=0,1,\\dots,N-1.$$\n\nStart from the fundamental definitions that windowing in the time domain is multiplication of $x[n]$ by $w[n]$, and that the DFT of a windowed signal $x[n]w[n]$ at frequency bin $k$ of an $N_{\\mathrm{FFT}}$-point transform is $$X_w[k] = \\sum_{n=0}^{N-1} x[n]\\,w[n]\\,e^{-j 2\\pi \\frac{k n}{N_{\\mathrm{FFT}}}}, \\quad k=0,1,\\dots,N_{\\mathrm{FFT}}-1,$$ where $j$ is the imaginary unit and $N_{\\mathrm{FFT}}$ is a positive integer used for zero-padding to refine spectral sampling. Use the one-sided magnitude spectrum computed via a Fast Fourier Transform (FFT) consistent with the DFT definition.\n\nYour task is to design and implement an algorithm that, for each specified test case, decides which window better “reveals” the weak component at frequency $f_2$ in the presence of the much stronger component at $f_1$. To make this decision precise and reproducible, define the following detection advantage metric for a given window $w$:\n\n1. Choose an FFT length $N_{\\mathrm{FFT}} = L N$ for a fixed integer zero-padding factor $L$.\n2. Map frequency $f$ in Hertz to the nearest integer FFT bin index $k(f) = \\left\\lfloor \\frac{f}{f_s} N_{\\mathrm{FFT}} + \\tfrac{1}{2}\\right\\rfloor$.\n3. Define a local signal band around $f_2$ as the bins $k \\in \\{k(f_2)-K, \\dots, k(f_2)+K\\}$ for a fixed small integer $K$ and take $$P_{\\mathrm{sig}}(w) = \\max_{k \\in \\{k(f_2)-K,\\dots,k(f_2)+K\\}} |X_w[k]|.$$\n4. Define a local floor band around $f_2$ as the bins $k \\in \\{k(f_2)-B, \\dots, k(f_2)+B\\}$ excluding a guard band around $f_2$ of half-width $G$ bins, that is, exclude $k \\in \\{k(f_2)-G, \\dots, k(f_2)+G\\}$. If indices fall outside the valid range, clamp them to the nearest valid index. Compute $$F_{\\mathrm{floor}}(w) = \\max_{\\substack{k \\in \\{k(f_2)-B,\\dots,k(f_2)+B\\} \\\\ k \\notin \\{k(f_2)-G,\\dots,k(f_2)+G\\}}} |X_w[k]|.$$\n5. The detection advantage is $$R(w) = \\frac{P_{\\mathrm{sig}}(w)}{F_{\\mathrm{floor}}(w)}.$$\n\nUsing this metric, declare the better window for a test case as follows: output $1$ if $R(w_{\\mathrm{Hann}}) > R(w_{\\mathrm{Hamm}})$ by more than a relative tolerance $\\varepsilon$, output $2$ if $R(w_{\\mathrm{Hamm}}) > R(w_{\\mathrm{Hann}})$ by more than the same tolerance, and output $0$ if the two advantages are within tolerance. Use $$\\varepsilon = 10^{-3}.$$ The tolerance comparison must be performed as $$\\left|R(w_{\\mathrm{Hann}}) - R(w_{\\mathrm{Hamm}})\\right| \\le \\varepsilon \\,\\max\\!\\left(R(w_{\\mathrm{Hann}}), R(w_{\\mathrm{Hamm}})\\right).$$\n\nImplement the computation using the following fixed analysis parameters for all test cases:\n- Zero-padding factor $L = 8$, so that $N_{\\mathrm{FFT}} = 8N$.\n- Signal-band half-width $K = 2$.\n- Floor-band half-width $B = 400$.\n- Guard-band half-width $G = 5$.\n\nPhysical and numerical units:\n- Frequencies $f_s$, $f_1$, $f_2$ are in Hertz.\n- Time is in seconds.\n- Angles inside trigonometric functions are in radians.\n\nTest suite:\n- Case $1$: $f_s = 32768$, $N = 8192$, $f_1 = 1000$, $f_2 = 10000$.\n- Case $2$: $f_s = 32768$, $N = 8192$, $f_1 = 5000$, $f_2 = 5000.5$.\n- Case $3$: $f_s = 48000$, $N = 4096$, $f_1 = 1000$, $f_2 = 1234$.\n\nYour program must compute the decision for each case as an integer in $\\{0,1,2\\}$ using the rule above and produce a single line of output containing the three results as a comma-separated list enclosed in square brackets, for example, $$[r_1,r_2,r_3],$$ where $r_i$ corresponds to Case $i$ in order. No other text should be printed.",
            "solution": "The problem as stated is valid. It is a well-posed, scientifically grounded problem in the domain of digital signal processing, a fundamental area of computational physics and engineering. All parameters, definitions, and procedures are specified with sufficient mathematical and algorithmic rigor to permit a unique and verifiable solution. There are no contradictions, ambiguities, or violations of established scientific principles. We may therefore proceed with the solution.\n\nThe objective is to compare the efficacy of the Hann and Hamming window functions in resolving a weak sinusoidal signal component at frequency $f_2$ in the presence of a strong sinusoidal component at frequency $f_1$. The comparison is not qualitative but is based on a quantitative detection advantage metric, $R(w)$, which is defined as the ratio of the peak signal magnitude in a narrow band around $f_2$ to the peak spectral floor magnitude in a nearby, but non-contiguous, band. The spectral floor is predominantly composed of leakage from the strong signal at $f_1$. A higher value of $R(w)$ signifies a better ability to distinguish the weak signal from this leakage background.\n\nThe theoretical basis for this comparison lies in the differing properties of the two windows in the frequency domain. Windowing in the time domain is equivalent to convolution in the frequency domain. The Discrete Fourier Transform (DFT) of a windowed sinusoid is a shifted version of the window's own transform.\n- The **Hann window**, with coefficients derived from a raised cosine, has side-lobes that decay rapidly (approximately $18$ dB per octave). This property is advantageous for resolving signals with large frequency separation, as the leakage from the strong signal diminishes quickly with distance.\n- The **Hamming window**, a modification of the Hann window, is optimized to minimize the level of the highest side-lobe (to approximately $-42.7$ dB relative to the main lobe peak). This comes at the cost of a slower side-lobe decay rate. This is beneficial for resolving closely spaced signals, where the nearest side-lobes of the strong signal create the most significant interference.\n\nThe problem, therefore, presents test cases that probe these different regimes: large frequency separation (Case $1$), extremely small separation (Case $2$), and intermediate separation (Case $3$). The solution requires a direct numerical implementation of the specified algorithm.\n\nThe procedure for each test case is as follows:\n\n1.  **Signal and Window Generation**: For a given set of parameters $\\{f_s, N, f_1, f_2\\}$, we generate the discrete-time signal $x[n]$ of length $N$ according to the formula:\n    $$x[n] = \\sin\\!\\left(2\\pi \\frac{f_1}{f_s} n\\right) + 10^{-4}\\,\\sin\\!\\left(2\\pi \\frac{f_2}{f_s} n\\right), \\quad n=0,1,\\dots,N-1.$$\n    The Hann and Hamming window functions, $w_{\\mathrm{Hann}}[n]$ and $w_{\\mathrm{Hamm}}[n]$, of length $N$ are generated according to their definitions:\n    $$w_{\\mathrm{Hann}}[n] = 0.5 - 0.5 \\cos\\!\\left(2\\pi \\frac{n}{N-1}\\right)$$\n    $$w_{\\mathrm{Hamm}}[n] = 0.54 - 0.46 \\cos\\!\\left(2\\pi \\frac{n}{N-1}\\right)$$\n\n2.  **Spectral Analysis**: For each window $w[n]$, the windowed signal $x[n]w[n]$ is computed. The $N_{\\mathrm{FFT}}$-point DFT of this signal is then calculated using a Fast Fourier Transform (FFT) algorithm, with zero-padding up to length $N_{\\mathrm{FFT}} = L N = 8N$. This gives the complex spectrum $X_w[k]$. The magnitude spectrum $|X_w[k]|$ is used for the subsequent calculations.\n\n3.  **Metric Calculation**: The detection advantage metric $R(w)$ is computed.\n    a. The frequency $f_2$ is mapped to the nearest integer FFT bin index $k(f_2) = \\left\\lfloor \\frac{f_2}{f_s} N_{\\mathrm{FFT}} + \\frac{1}{2}\\right\\rfloor$.\n    b. The peak signal magnitude, $P_{\\mathrm{sig}}(w)$, is found by taking the maximum of $|X_w[k]|$ over the signal band, defined as the set of bins $\\{k | k \\in [k(f_2)-K, k(f_2)+K]\\}$, with $K=2$.\n    c. The peak floor magnitude, $F_{\\mathrm{floor}}(w)$, is found by taking the maximum of $|X_w[k]|$ over the floor-band region. This region includes bins from $k(f_2)-B$ to $k(f_2)+B$ ($B=400$) but excludes a central guard band from $k(f_2)-G$ to $k(f_2)+G$ ($G=5$). Specifically, the search for the maximum is over the union of two disjoint index ranges: $[k(f_2)-B, k(f_2)-G-1]$ and $[k(f_2)+G+1, k(f_2)+B]$. Any indices falling outside the valid range $[0, N_{\\mathrm{FFT}}-1]$ are clamped to the nearest boundary.\n    d. The detection advantage is the ratio $R(w) = P_{\\mathrm{sig}}(w) / F_{\\mathrm{floor}}(w)$.\n\n4.  **Decision**: The calculated advantages $R(w_{\\mathrm{Hann}})$ and $R(w_{\\mathrm{Hamm}})$ are compared. A decision is made based on the specified relative tolerance rule with $\\varepsilon = 10^{-3}$:\n    - If $|\\,R(w_{\\mathrm{Hann}}) - R(w_{\\mathrm{Hamm}})\\,| \\le \\varepsilon \\max(R(w_{\\mathrm{Hann}}), R(w_{\\mathrm{Hamm}}))$, the windows are considered equivalent in performance, and the result is $0$.\n    - If $R(w_{\\mathrm{Hann}})$ is greater than $R(w_{\\mathrm{Hamm}})$ beyond this tolerance, the Hann window is superior, and the result is $1$.\n    - If $R(w_{\\mathrm{Hamm}})$ is greater than $R(w_{\\mathrm{Hann}})$ beyond this tolerance, the Hamming window is superior, and the result is $2$.\n\nThis complete procedure is executed for each of the three test cases provided. The final output is an ordered list of these integer results.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.fft import fft\n\ndef solve():\n    # Define the fixed analysis parameters from the problem statement.\n    L = 8\n    K = 2\n    B = 400\n    G = 5\n    epsilon = 1e-3\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (f_s, N, f_1, f_2)\n        (32768, 8192, 1000, 10000),\n        (32768, 8192, 5000, 5000.5),\n        (48000, 4096, 1000, 1234),\n    ]\n\n    results = []\n\n    for case in test_cases:\n        f_s, N, f_1, f_2 = case\n        \n        N_fft = L * N\n        n = np.arange(N)\n        \n        # Generate the discrete-time signal\n        x_n = np.sin(2 * np.pi * f_1 / f_s * n) + 1e-4 * np.sin(2 * np.pi * f_2 / f_s * n)\n        \n        # Define the windows\n        windows = {\n            \"hann\": 0.5 * (1 - np.cos(2 * np.pi * n / (N - 1))),\n            \"hamm\": 0.54 - 0.46 * np.cos(2 * np.pi * n / (N - 1)),\n        }\n        \n        adv_ratios = {}\n        \n        for name, w in windows.items():\n            # Apply the window to the signal\n            x_w = x_n * w\n            \n            # Compute the FFT and its magnitude\n            X_w = fft(x_w, n=N_fft)\n            mag_X_w = np.abs(X_w)\n            \n            # Map frequency f2 to the nearest integer bin index\n            k_f2 = int(np.round((f_2 / f_s) * N_fft))\n            \n            # 1. Compute P_sig(w)\n            sig_band_start = np.clip(k_f2 - K, 0, N_fft - 1)\n            sig_band_end = np.clip(k_f2 + K, 0, N_fft - 1)\n            P_sig = np.max(mag_X_w[sig_band_start : sig_band_end + 1])\n            \n            # 2. Compute F_floor(w)\n            # The floor is the max over two bands:\n            # [k_f2 - B, k_f2 - G - 1] and [k_f2 + G + 1, k_f2 + B]\n            \n            # Lower band\n            lower_band_start = k_f2 - B\n            lower_band_end = k_f2 - G - 1\n            \n            # Upper band\n            upper_band_start = k_f2 + G + 1\n            upper_band_end = k_f2 + B\n            \n            # Clamp indices to valid range [0, N_fft - 1]\n            c_lower_start = np.clip(lower_band_start, 0, N_fft - 1)\n            c_lower_end = np.clip(lower_band_end, 0, N_fft - 1)\n            c_upper_start = np.clip(upper_band_start, 0, N_fft - 1)\n            c_upper_end = np.clip(upper_band_end, 0, N_fft - 1)\n            \n            max_lower = 0.0\n            if c_lower_start <= c_lower_end:\n                max_lower = np.max(mag_X_w[c_lower_start : c_lower_end + 1])\n            \n            max_upper = 0.0\n            if c_upper_start <= c_upper_end:\n                max_upper = np.max(mag_X_w[c_upper_start : c_upper_end + 1])\n            \n            F_floor = np.max([max_lower, max_upper])\n            \n            # 3. Compute detection advantage R(w)\n            adv_ratios[name] = P_sig / F_floor if F_floor > 0 else np.inf\n\n        # Compare R(w_hann) and R(w_hamm)\n        R_hann = adv_ratios[\"hann\"]\n        R_hamm = adv_ratios[\"hamm\"]\n        \n        # Apply the decision rule with relative tolerance\n        if abs(R_hann - R_hamm) <= epsilon * max(R_hann, R_hamm):\n            results.append(0)\n        elif R_hann > R_hamm:\n            results.append(1)\n        else: # R_hamm > R_hann\n            results.append(2)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The specific coefficients that define the Hamming window, $0.54$ and $0.46$, are not arbitrary; they are the result of an optimization process designed to minimize the highest sidelobe. This final practice invites you to look \"under the hood\" of window design by exploring the sensitivity of this optimization . By numerically calculating the change in the peak sidelobe level when a coefficient is altered, you will gain insight into the core principles that guide the creation of high-performance window functions.",
            "id": "2399950",
            "problem": "A finite-length windowed signal of length $N$ is defined by a sequence $\\{w[n]\\}_{n=0}^{N-1}$. Consider the family of Hamming-type windows parameterized by a coefficient $a_0 \\in (0,1)$ given by\n$$\nw_{a_0}[n] = a_0 - \\left(1 - a_0\\right)\\cos\\!\\left(\\frac{2\\pi n}{N-1}\\right), \\quad 0 \\le n \\le N-1.\n$$\nLet $W_{a_0}(\\omega)$ denote the discrete-time Fourier transform (DTFT) of $w_{a_0}[n]$,\n$$\nW_{a_0}(\\omega) = \\sum_{n=0}^{N-1} w_{a_0}[n]\\, e^{-i \\omega n}, \\quad \\omega \\in \\mathbb{R},\n$$\nwhere all angles are in radians. Define the main-lobe interval as follows: let $\\omega_{-} < 0 < \\omega_{+}$ be the two nonzero angular frequencies closest to $0$ such that $\\left|W_{a_0}(\\omega_{\\pm})\\right| = 0$. The main lobe is the interval $[\\omega_{-},\\omega_{+}]$, and the side lobes are the complement in frequency of this interval. Define the peak side-lobe level (in decibels) relative to the main-lobe peak as\n$$\nL(a_0;N) = 20 \\log_{10}\\!\\left(\\frac{\\displaystyle \\sup_{\\omega \\notin (\\omega_{-},\\omega_{+})} \\left|W_{a_0}(\\omega)\\right|}{\\displaystyle \\max_{\\omega \\in \\mathbb{R}} \\left|W_{a_0}(\\omega)\\right|}\\right).\n$$\nConsider the standard Hamming window with $a_0 = 0.54$ and a modified window with $a_0 = 0.53$. For each case, define the change in peak side-lobe level (in decibels) when moving from the standard to the modified coefficient as\n$$\n\\Delta L(N) = L(0.53;N) - L(0.54;N).\n$$\nAll angles must be treated in radians. Your task is to write a complete program that, for each specified $N$ in the test suite below, computes a numerical approximation to $\\Delta L(N)$ and reports the results rounded to $3$ decimal places.\n\nTest suite (window lengths $N$):\n- $N = 16$,\n- $N = 64$,\n- $N = 65$,\n- $N = 257$.\n\nRequired final output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[r_1,r_2,r_3,r_4]$), where each $r_k$ is the computed value of $\\Delta L(N)$ for the corresponding test case, expressed in decibels as a decimal number rounded to $3$ decimal places.",
            "solution": "The problem statement is subjected to validation.\n\n**Step 1: Extracted Givens**\n- Window function definition: $w_{a_0}[n] = a_0 - \\left(1 - a_0\\right)\\cos\\!\\left(\\frac{2\\pi n}{N-1}\\right)$, for $0 \\le n \\le N-1$.\n- Parameter range: $a_0 \\in (0,1)$.\n- Discrete-Time Fourier Transform (DTFT): $W_{a_0}(\\omega) = \\sum_{n=0}^{N-1} w_{a_0}[n]\\, e^{-i \\omega n}$, for $\\omega \\in \\mathbb{R}$.\n- Main-lobe interval: $[\\omega_{-},\\omega_{+}]$, where $\\omega_{-} < 0 < \\omega_{+}$ are the two nonzero angular frequencies closest to $0$ such that $\\left|W_{a_0}(\\omega_{\\pm})\\right| = 0$.\n- Peak side-lobe level (PSLL): $L(a_0;N) = 20 \\log_{10}\\!\\left(\\frac{\\displaystyle \\sup_{\\omega \\notin (\\omega_{-},\\omega_{+})} \\left|W_{a_0}(\\omega)\\right|}{\\displaystyle \\max_{\\omega \\in \\mathbb{R}} \\left|W_{a_0}(\\omega)\\right|}\\right)$.\n- Window coefficients: Standard Hamming with $a_0 = 0.54$, and a modified window with $a_0 = 0.53$.\n- Target quantity: $\\Delta L(N) = L(0.53;N) - L(0.54;N)$.\n- Test cases for window length $N$: $16$, $64$, $65$, $257$.\n\n**Step 2: Validation Using Extracted Givens**\nThe problem is assessed against the required criteria.\n- **Scientifically Grounded**: The problem is based on the principles of digital signal processing, specifically the Fourier analysis of window functions. The Hamming-type window is a standard construction, and the definitions of DTFT and peak side-lobe level are correct and conventional. The problem is fundamentally sound.\n- **Well-Posed**: The problem provides all necessary definitions, constants, and test parameters. The objective is clearly stated: to compute a numerical approximation for a well-defined quantity, $\\Delta L(N)$. A unique, stable solution exists for each test case.\n- **Objective**: The language is precise, mathematical, and free of ambiguity or subjectivity.\n\n**Step 3: Verdict and Action**\nThe problem is scientifically valid, objective, and well-posed. There are no contradictions, missing information, or pseudoscientific elements. Therefore, we proceed to construct a solution.\n\n**Principle-Based Solution**\n\nThe objective is to compute the change in peak side-lobe level, $\\Delta L(N)$, when the window coefficient $a_0$ is changed from $0.54$ to $0.53$. This requires computing the spectral properties of the window function for each case.\n\n**1. Analytical Form of the Spectrum**\nThe window function is given by\n$$\nw_{a_0}[n] = a_0 - (1 - a_0)\\cos\\left(\\frac{2\\pi n}{N-1}\\right), \\quad 0 \\le n \\le N-1.\n$$\nUsing Euler's identity, $\\cos(x) = \\frac{e^{ix} + e^{-ix}}{2}$, the window can be expressed as a sum of complex exponentials:\n$$\nw_{a_0}[n] = a_0 \\cdot e^{-i \\cdot 0 \\cdot n} - \\frac{1-a_0}{2} e^{i \\frac{2\\pi n}{N-1}} - \\frac{1-a_0}{2} e^{-i \\frac{2\\pi n}{N-1}}.\n$$\nThe Discrete-Time Fourier Transform (DTFT), $W_{a_0}(\\omega)$, is the sum of the DTFTs of these three components. The DTFT of a finite complex exponential sequence $e^{i\\omega_c n}$ is a shifted Dirichlet kernel. Let $D_N(\\omega) = \\sum_{n=0}^{N-1} e^{-i\\omega n} = e^{-i\\omega (N-1)/2} \\frac{\\sin(N\\omega/2)}{\\sin(\\omega/2)}$. The DTFT of the window is then:\n$$\nW_{a_0}(\\omega) = a_0 D_N(\\omega) - \\frac{1-a_0}{2} D_N\\left(\\omega - \\frac{2\\pi}{N-1}\\right) - \\frac{1-a_0}{2} D_N\\left(\\omega + \\frac{2\\pi}{N-1}\\right).\n$$\nThis expression shows that the window's spectrum is a superposition of three shifted Dirichlet kernels. While this analytical form is useful for theoretical analysis, for numerical computation it is more direct and robust to use the Fast Fourier Transform (FFT) algorithm on a zero-padded version of the window sequence. This provides a finely sampled version of the DTFT magnitude spectrum.\n\n**2. Numerical Computation Strategy**\n\nWe will implement a function to compute $L(a_0;N)$ for given parameters. The procedure is as follows:\n\n**Step 2.1: Spectrum Calculation**\nFor a window of length $N$, we generate the sequence $w_{a_0}[n]$. We then embed this sequence in a much larger array of zeros of length $M \\gg N$ (a technique known as zero-padding) and compute the $M$-point Discrete Fourier Transform (DFT) using the FFT algorithm. The magnitude of the resulting complex array, $|W[k]|$, provides $M$ samples of the DTFT spectrum $|W_{a_0}(\\omega)|$ at discrete angular frequencies $\\omega_k = \\frac{2\\pi k}{M}$ for $k=0, \\dots, M-1$. A large $M$ ensures high frequency resolution.\n\n**Step 2.2: Main-Lobe Peak**\nThe maximum of the spectrum occurs at $\\omega=0$ ($k=0$). This peak value, $|W_{a_0}(0)|$, is the DC component of the signal, equal to the sum of the window coefficients.\n$$\n\\max_{\\omega \\in \\mathbb{R}} |W_{a_0}(\\omega)| = |W_{a_0}(0)| = \\sum_{n=0}^{N-1} w_{a_0}[n] = a_0 N - (1-a_0) \\sum_{n=0}^{N-1} \\cos\\left(\\frac{2\\pi n}{N-1}\\right).\n$$\nThe summation term $\\sum_{n=0}^{N-1} \\cos(\\frac{2\\pi n}{N-1})$ is equal to $1$. Thus, the peak of the main lobe is $a_0 N - (1-a_0) = a_0(N+1)-1$. This corresponds to the FFT result at index $k=0$.\n\n**Step 2.3: Side-Lobe Identification**\nThe main lobe is the central peak of the spectrum, defined by the interval between the first nulls (zeros) on either side of $\\omega=0$. The side lobes are all other peaks outside this interval. To find the boundary of the main lobe numerically:\n1.  We consider the positive frequency portion of the spectrum, i.e., indices $k=0, \\dots, M/2-1$.\n2.  We find the indices of all local maxima (peaks) in the spectrum, excluding the main-lobe peak at $k=0$. The `scipy.signal.find_peaks` function is suitable for this.\n3.  The first such peak corresponds to the first side lobe. Let its index be $k_{\\text{side-peak}}$.\n4.  The first null, which separates the main lobe and the first side lobe, must lie between $k=0$ and $k=k_{\\text{side-peak}}$. We find its index, $k_{\\text{null}}$, by locating the minimum value of the spectrum in this range.\n5.  The side-lobe region is then defined as all frequencies corresponding to indices $k \\ge k_{\\text{null}}$.\n\n**Step 2.4: Peak Side-Lobe Level (PSLL) Calculation**\nThe peak side lobe is the supremum of the spectrum magnitude over the entire side-lobe region. Numerically, this is the maximum value of the spectrum samples for all indices $k \\ge k_{\\text{null}}$.\n$$\n\\text{Peak Side Lobe} = \\max_{k \\ge k_{\\text{null}}} |W[k]|\n$$\nThe PSLL in decibels is then calculated as:\n$$\nL(a_0;N) = 20 \\log_{10}\\left(\\frac{\\text{Peak Side Lobe}}{\\text{Peak Main Lobe}}\\right).\n$$\n\n**Step 2.5: Final Computation of $\\Delta L(N)$**\nThe above procedure is executed for the standard coefficient $a_0 = 0.54$ and the modified coefficient $a_0 = 0.53$, yielding $L(0.54;N)$ and $L(0.53;N)$, respectively. The desired difference, $\\Delta L(N) = L(0.53;N) - L(0.54;N)$, is then computed. This process is repeated for each specified window length $N \\in \\{16, 64, 65, 257\\}$. The final results are rounded to $3$ decimal places as required.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.signal import find_peaks\n\ndef calculate_psll(a0: float, N: int, M: int) -> float:\n    \"\"\"\n    Calculates the peak side-lobe level (PSLL) in dB for a Hamming-type window.\n\n    Args:\n        a0 (float): The window parameter.\n        N (int): The length of the window.\n        M (int): The size of the FFT for spectral analysis (must be >> N).\n\n    Returns:\n        float: The peak side-lobe level in decibels.\n    \"\"\"\n    \n    # 1. Generate the window sequence.\n    # The case N=1 is not in the test suite and would lead to division by zero.\n    if N == 1:\n        window = np.array([1.0])\n    else:\n        n = np.arange(N)\n        window = a0 - (1 - a0) * np.cos(2 * np.pi * n / (N - 1))\n\n    # 2. Compute the spectrum using a zero-padded FFT.\n    spectrum = np.abs(np.fft.fft(window, M))\n    \n    # We analyze the positive frequency response (first half of the FFT output).\n    response = spectrum[:M // 2]\n\n    # 3. The main lobe peak is the DC component.\n    peak_main_lobe = response[0]\n    \n    if peak_main_lobe == 0:\n        return -np.inf # Should not happen for these windows\n\n    # 4. Find the first side-lobe peak to identify the main-lobe boundary.\n    # We search for peaks starting from index 1 to exclude the main lobe.\n    # The spectra for these windows are well-behaved with clear side lobes.\n    peak_indices, _ = find_peaks(response[1:])\n    \n    if len(peak_indices) == 0:\n        # No side lobes found, theoretically occurs for infinitesimally narrow main lobes.\n        # This case is not expected here.\n        return -np.inf\n\n    # The index returned by find_peaks is relative to the sliced array 'response[1:]'.\n    # Add 1 to get the index in the original 'response' array.\n    first_side_lobe_peak_index = peak_indices[0] + 1\n\n    # 5. Find the null separating the main lobe from the side lobes.\n    # The null is the minimum value between the main lobe peak (index 0) \n    # and the first side lobe peak.\n    # Add 1 to argmin result because the slice starts at index 1.\n    null_index = np.argmin(response[1:first_side_lobe_peak_index]) + 1\n    \n    # 6. The peak side-lobe is the maximum of the spectrum from the first null onwards.\n    # This correctly implements the 'sup' over the side-lobe region.\n    peak_side_lobe = np.max(response[null_index:])\n    \n    # 7. Calculate the PSLL in decibels.\n    psll_db = 20 * np.log10(peak_side_lobe / peak_main_lobe)\n    \n    return psll_db\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [16, 64, 65, 257]\n    \n    a0_standard = 0.54\n    a0_modified = 0.53\n\n    # Use a large, fixed FFT size for high frequency resolution.\n    # A power of 2 is computationally efficient. M = 2^18 is sufficient.\n    M = 2**18\n\n    results = []\n    for N in test_cases:\n        # Calculate PSLL for the standard and modified windows.\n        L_standard = calculate_psll(a0_standard, N, M)\n        L_modified = calculate_psll(a0_modified, N, M)\n        \n        # Calculate the change in PSLL.\n        delta_L = L_modified - L_standard\n        \n        # Round to 3 decimal places as required.\n        results.append(round(delta_L, 3))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}