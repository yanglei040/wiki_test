{
    "hands_on_practices": [
        {
            "introduction": "深入理解任何关键算法的最佳方式之一就是亲手实现它。这个练习将引导你从零开始，基于其“分治”核心思想，构建蝶形运算的库利-图基快速傅里叶变换（FFT）算法。通过这个过程，你不仅将验证其与直接计算（$O(N^2)$）相比的正确性，还将通过验证卷积定理和帕塞瓦尔恒等式等基本属性，加深对傅里叶变换内在数学原理的理解。",
            "id": "2387187",
            "problem": "设 $N$ 是一个正整数，其形式为 $N = 2^m$，其中 $m$ 为非负整数。对于一个长度为 $N$ 的复值序列 $x = \\{x_n\\}_{n=0}^{N-1}$，其离散傅里叶变换 (DFT) $X = \\{X_k\\}_{k=0}^{N-1}$ 定义为\n$$\nX_k = \\sum_{n=0}^{N-1} x_n \\, e^{-2\\pi i \\, k n / N} \\quad \\text{对于 } k = 0,1,\\dots,N-1,\n$$\n且其离散傅里叶逆变换 (IDFT) 定义为\n$$\nx_n = \\frac{1}{N} \\sum_{k=0}^{N-1} X_k \\, e^{+2\\pi i \\, k n / N} \\quad \\text{对于 } n = 0,1,\\dots,N-1,\n$$\n其中所有角度均以弧度为单位。\n\n编写一个完整的程序，在不调用任何库傅里叶变换例程的情况下，计算长度为 $N = 2^m$ 的序列的 DFT 和 IDFT。您的程序还必须使用这些定义，通过明确的测试用例来验证以下基本性质：\n\n- 循环卷积定理：对于长度为 $N$ 的序列 $a$ 和 $b$，它们的长度为 $N$ 的循环卷积 $c$ 定义为 $c_n = \\sum_{m=0}^{N-1} a_m \\, b_{(n-m) \\bmod N}$，满足 $C_k = A_k B_k$，其中 $A$、$B$ 和 $C$ 分别是 $a$、$b$ 和 $c$ 的 DFT。\n- 帕塞瓦尔恒等式（使用上述归一化）：$\\sum_{n=0}^{N-1} |x_n|^2 = \\frac{1}{N} \\sum_{k=0}^{N-1} |X_k|^2$。\n\n您的程序必须实现自己的快速算法来计算 $N = 2^m$ 时的 DFT 和 IDFT，并且必须包含一个直接的$O(N^2)$ DFT 用于验证。在需要布尔验证的地方，使用数值容差 $\\varepsilon = 10^{-9}$。所有角度必须以弧度为单位进行解释。\n\n使用以下测试套件，并按下面给出的顺序生成输出：\n\n- 测试 1（DFT 与直接 DFT 的正确性比较，正常路径）：设 $N = 8$ 且 $x = [0,1,2,3,4,3,2,1]$。使用您的快速实现计算 $X$，并使用直接 DFT 计算 $\\tilde{X}$。如果 $\\max_k |X_k - \\tilde{X}_k| \\le \\varepsilon$，则输出布尔值 $\\text{True}$，否则输出 $\\text{False}$。\n- 测试 2（逆变换恢复）：使用与测试 1 相同的 $N$ 和 $x$，将您的 IDFT 应用于您快速实现得到的 $X$ 来计算 $x'$。如果 $\\max_n |x'_n - x_n| \\le \\varepsilon$，则输出布尔值 $\\text{True}$，否则输出 $\\text{False}$。\n- 测试 3（通过频域进行循环卷积）：设 $N = 8$，$a = [1,2,3,0,0,0,0,0]$，$b = [0,1,0,0,0,0,0,0]$。直接根据其定义计算长度为 $N$ 的循环卷积 $c$。另外，通过对 $a$ 和 $b$ 进行 DFT、逐点相乘并应用 IDFT 来计算 $\\hat{c}$。以浮点数形式输出标量 $\\max_n |c_n - \\hat{c}_n|$。\n- 测试 4（帕塞瓦尔恒等式）：设 $N = 16$ 且 $x_n = \\sin\\!\\left( \\frac{2\\pi \\cdot 3 \\, n}{N} \\right) + \\frac{1}{2} \\cos\\!\\left( \\frac{2\\pi \\cdot 5 \\, n}{N} \\right)$，其中 $n = 0,1,\\dots,15$。通过您的快速实现计算 $X$。以浮点数形式输出标量 $\\left| \\sum_{n=0}^{N-1} |x_n|^2 - \\frac{1}{N} \\sum_{k=0}^{N-1} |X_k|^2 \\right|$。\n- 测试 5（边界情况 $N=1$）：设 $N = 1$ 且 $x = [3 + 4i]$。计算 $X$，然后通过 IDFT 计算 $x'$。如果 $|x'_0 - x_0| \\le \\varepsilon$，则输出布尔值 $\\text{True}$，否则输出 $\\text{False}$。\n- 测试 6（最小非平凡尺寸 $N=2$）：设 $N = 2$ 且 $x = [1,-1]$。通过您的快速实现计算 $X$。在给定约定下，确切的 DFT 是 $[0,2]$。以浮点数形式输出标量 $\\max_k |X_k - [0,2]_k|$。\n\n最终输出格式：您的程序应生成单行输出，其中包含按顺序排列的六个结果，形式为用方括号括起来的逗号分隔列表，例如 $[r_1,r_2,r_3,r_4,r_5,r_6]$。所有布尔条目必须是 $\\text{True}$ 或 $\\text{False}$，所有实值条目必须以标准十进制或科学记数法打印。不应打印任何其他文本。",
            "solution": "所提出的问题是计算物理学领域，特别是在信号处理领域中，一个定义明确且科学严谨的练习。它要求实现和验证离散傅里叶变换 (DFT)、其逆变换 (IDFT) 以及相关的基本定理。该问题是完整的、客观的，其解决方案是可验证的。我们将着手解决。\n\n问题的核心是为一个给定的长度为 $N$ 的离散复值序列 $x = \\{x_n\\}_{n=0}^{N-1}$ 计算其 DFT $X$。定义如下：\n$$\nX_k = \\sum_{n=0}^{N-1} x_n \\, e^{-2\\pi i \\, k n / N} \\quad \\text{对于 } k = 0,1,\\dots,N-1.\n$$\n该公式的直接实现涉及两个嵌套循环，一个用于从 $0$ 到 $N-1$ 的每个索引 $k$，另一个用于从 $0$ 到 $N-1$ 的每个索引 $n$。这导致计算复杂度为$O(N^2)$，对于较大的 $N$ 来说效率低下。为了验证目的，将实现这种直接方法。\n\n问题规定 $N$ 是 2 的幂，即 $N = 2^m$，其中 $m$ 是非负整数。这种结构是采用快速傅里叶变换 (FFT) 算法的关键，特别是 Cooley-Tukey 时域抽取算法。该算法将复杂度从$O(N^2)$降低到$O(N \\log N)$。其原理是分而治之。长度为 $N$ 的 DFT被递归地分解为两个长度为 $(N/2)$ 的 DFT。\n\n设序列 $x_n$ 被分解为其偶数索引元素，形成一个序列 $x'_m = x_{2m}$，以及其奇数索引元素，形成一个序列 $x''_m = x_{2m+1}$，每个序列的长度都为 $N/2$。DFT 的求和可以改写为：\n$$\nX_k = \\sum_{m=0}^{N/2-1} x_{2m} e^{-2\\pi i k (2m) / N} + \\sum_{m=0}^{N/2-1} x_{2m+1} e^{-2\\pi i k (2m+1) / N}\n$$\n$$\nX_k = \\sum_{m=0}^{N/2-1} x'_m e^{-2\\pi i k m / (N/2)} + e^{-2\\pi i k/N} \\sum_{m=0}^{N/2-1} x''_m e^{-2\\pi i k m / (N/2)}\n$$\n设 $X'_k$ 和 $X''_k$ 分别是 $x'_m$ 和 $x''_m$ 的长度为 $(N/2)$ 的 DFT。上述表达式变为：\n$$\nX_k = X'_{k \\bmod (N/2)} + W_N^k X''_{k \\bmod (N/2)}\n$$\n其中 $W_N^k = e^{-2\\pi i k/N}$ 是“旋转因子”。对于索引的前半部分，$0 \\le k  N/2$，我们有：\n$$\nX_k = X'_k + W_N^k X''_k\n$$\n对于后半部分，其中索引为 $k+N/2$ 且 $0 \\le k  N/2$，我们使用性质 $X'_{k+N/2} = X'_k$、$X''_{k+N/2} = X''_k$ 和 $W_N^{k+N/2} = -W_N^k$。这得出：\n$$\nX_{k+N/2} = X'_k - W_N^k X''_k\n$$\n这个递归定义允许构建完整的 DFT。当递归达到基例 $N=1$ 时终止，此时序列 $\\{x_0\\}$ 的 DFT 仅为 $\\{X_0\\} = \\{x_0\\}$。我们的实现将遵循这种递归结构。\n\n离散傅里叶逆变换 (IDFT) 定义为：\n$$\nx_n = \\frac{1}{N} \\sum_{k=0}^{N-1} X_k \\, e^{+2\\pi i \\, k n / N}\n$$\n没有必要单独实现。我们可以将 IDFT 与正向 DFT 关联起来。观察以下推导：\n$$\nN \\cdot \\overline{x_n} = \\overline{\\sum_{k=0}^{N-1} X_k e^{+2\\pi i k n / N}} = \\sum_{k=0}^{N-1} \\overline{X_k} e^{-2\\pi i k n / N}\n$$\n等式右边是复共轭序列 $\\{\\overline{X_k}\\}_{k=0}^{N-1}$ 的 DFT。因此，我们可以通过计算 $\\overline{X}$ 的 DFT，取结果的复共轭，再乘以 $1/N$ 来求得 $x_n$。即，$x = \\frac{1}{N} \\overline{\\text{DFT}(\\overline{X})}$。这使我们能够使用我们高效的 FFT 实现来计算逆变换 (IFFT)。\n\n该问题还要求验证两个基本定理。\n\n首先是循环卷积定理。两个长度为 $N$ 的序列 $a$ 和 $b$ 的循环卷积 $c$ 由 $c_n = \\sum_{m=0}^{N-1} a_m b_{(n-m) \\bmod N}$ 给出。该定理指出，卷积的 DFT 是各个 DFT 的逐点乘积：$C_k = A_k B_k$。因此，可以通过频域计算 $c$：$c = \\text{IDFT}(\\text{DFT}(a) \\odot \\text{DFT}(b))$，其中 $\\odot$ 表示逐元素乘法。我们将通过直接计算和通过频域路径计算 $c$ 并比较结果来测试这一点。\n\n其次是帕塞瓦尔恒等式。对于给定的 DFT 归一化，该恒等式为：\n$$\n\\sum_{n=0}^{N-1} |x_n|^2 = \\frac{1}{N} \\sum_{k=0}^{N-1} |X_k|^2\n$$\n该定理将信号在时域中的总能量与其在频域中的能量联系起来。我们将对一个特定的测试信号验证这一点。\n\n程序将首先定义必要的函数：一个直接的$O(N^2)$ DFT、一个递归的$O(N \\log N)$ FFT、一个基于 FFT 的 IFFT，以及一个直接的循环卷积函数。然后，它将使用这些函数和一个数值容差 $\\varepsilon = 10^{-9}$ 来执行指定的 6 个测试用例以进行比较。结果将被收集并以要求的格式打印出来。",
            "answer": "```python\nimport numpy as np\n\ndef direct_dft(x):\n    \"\"\"\n    Computes the Discrete Fourier Transform of a sequence x using the direct O(N^2) method.\n    \"\"\"\n    x = np.asarray(x, dtype=complex)\n    N = x.shape[0]\n    n = np.arange(N)\n    k = n.reshape((N, 1))\n    W = np.exp(-2j * np.pi * k * n / N)\n    X = np.dot(W, x)\n    return X\n\ndef fft(x):\n    \"\"\"\n    Computes the Discrete Fourier Transform of a sequence x using the recursive\n    Cooley-Tukey FFT algorithm. Assumes N is a power of 2.\n    \"\"\"\n    x = np.asarray(x, dtype=complex)\n    N = x.shape[0]\n\n    if N == 1:\n        return x\n\n    # Decimate: split into even and odd subsequences\n    x_even = fft(x[0::2])\n    x_odd = fft(x[1::2])\n\n    # Combine\n    k = np.arange(N // 2)\n    twiddle_factors = np.exp(-2j * np.pi * k / N)\n    \n    X = np.concatenate([x_even + twiddle_factors * x_odd,\n                          x_even - twiddle_factors * x_odd])\n    return X\n\ndef ifft(X):\n    \"\"\"\n    Computes the Inverse Discrete Fourier Transform using the forward FFT algorithm.\n    \"\"\"\n    X = np.asarray(X, dtype=complex)\n    N = X.shape[0]\n    \n    # Use the property: IDFT(X) = (1/N) * conj(DFT(conj(X)))\n    x = np.conjugate(fft(np.conjugate(X))) / N\n    return x\n\ndef circular_conv(a, b):\n    \"\"\"\n    Computes the circular convolution of two sequences a and b directly.\n    \"\"\"\n    a = np.asarray(a, dtype=complex)\n    b = np.asarray(b, dtype=complex)\n    N = len(a)\n    c = np.zeros(N, dtype=complex)\n    for n in range(N):\n        for m in range(N):\n            c[n] += a[m] * b[(n - m) % N]\n    return c\n\ndef solve():\n    \"\"\"\n    Runs the full test suite and prints the formatted results.\n    \"\"\"\n    epsilon = 1e-9\n    results = []\n\n    # Test 1: DFT correctness versus direct DFT\n    N1 = 8\n    x1 = np.array([0, 1, 2, 3, 4, 3, 2, 1], dtype=float)\n    X_fast = fft(x1)\n    X_direct = direct_dft(x1)\n    err1 = np.max(np.abs(X_fast - X_direct))\n    results.append(err1 = epsilon)\n\n    # Test 2: Inverse transform recovery\n    x_prime = ifft(X_fast)\n    err2 = np.max(np.abs(x_prime - x1))\n    results.append(err2 = epsilon)\n\n    # Test 3: Circular convolution via frequency domain\n    N3 = 8\n    a3 = np.array([1, 2, 3, 0, 0, 0, 0, 0], dtype=float)\n    b3 = np.array([0, 1, 0, 0, 0, 0, 0, 0], dtype=float)\n    c_direct = circular_conv(a3, b3)\n    A3 = fft(a3)\n    B3 = fft(b3)\n    C_freq = A3 * B3\n    c_hat = ifft(C_freq)\n    err3 = np.max(np.abs(c_direct - c_hat))\n    results.append(err3)\n\n    # Test 4: Parseval identity\n    N4 = 16\n    n4 = np.arange(N4)\n    x4 = np.sin(2 * np.pi * 3 * n4 / N4) + 0.5 * np.cos(2 * np.pi * 5 * n4 / N4)\n    X4 = fft(x4)\n    sum_sq_x = np.sum(np.abs(x4)**2)\n    sum_sq_X_scaled = np.sum(np.abs(X4)**2) / N4\n    err4 = np.abs(sum_sq_x - sum_sq_X_scaled)\n    results.append(err4)\n\n    # Test 5: Edge case N=1\n    x5 = np.array([3 + 4j])\n    X5 = fft(x5)\n    x5_prime = ifft(X5)\n    err5 = np.abs(x5_prime[0] - x5[0])\n    results.append(err5 = epsilon)\n\n    # Test 6: Smallest nontrivial size N=2\n    x6 = np.array([1, -1], dtype=float)\n    X6 = fft(x6)\n    X_exact = np.array([0, 2], dtype=complex)\n    err6 = np.max(np.abs(X6 - X_exact))\n    results.append(err6)\n\n    # Format and print final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在亲手实现了FFT算法之后，下一个关键问题是：它究竟有多“快”？这个练习将你的视角从算法实现转移到性能分析。你将为一个常见的图像处理任务——二维卷积——建立计算成本模型，并从第一性原理出发，推导直接卷积法与基于FFT的卷积法的浮点运算（FLOPs）次数。通过比较这两种方法的成本，你将亲眼见证FFT在处理大规模数据时，从$O(NMk^2)$到$O(NM \\log(NM))$的巨大计算优势。",
            "id": "2419119",
            "problem": "考虑将两种二维卷积方法应用于图像：一种是直接空域法，另一种是通过快速傅里叶变换（FFT）的频域法。假设以下建模假设，它们构成本问题中使用的计算成本模型：(i) 每次实数浮点乘法消耗 $1$ 次浮点运算（FLOP），每次实数浮点加法消耗 $1$ FLOP；(ii) 一次复数加法消耗 $2$ FLOPs；(iii) 一次复数乘法消耗 $6$ FLOPs；(iv) 一个大小为 $N \\times M$ 的二维复数FFT，若使用经典Cooley–Tukey算法通过标准行列法计算，则消耗 $5\\,N\\,M\\left(\\log_2 N + \\log_2 M\\right)$ FLOPs，且逆变换的成本相同。为了避免边界效应和零填充，请完全在离散环面上进行循环（周期性）卷积；这意味着两种方法都应在周期性边界条件下，从一个 $N \\times M$ 的图像和一个 $k \\times k$ 的滤波器核生成一个 $N \\times M$ 的输出。\n\n从有限周期网格上的离散二维卷积定义和卷积定理出发，根据第一性原理推导以下方法所需的总FLOP数表达式：\n- 对一个 $N \\times M$ 的图像与一个 $k \\times k$ 的核进行直接循环卷积，以及\n- 基于FFT的循环卷积，该方法计算两次正向FFT（图像和核）、一次频域中的逐元素复数乘法和一次逆FFT。\n\n你的推导必须仅基于上述模型以及离散卷积和卷积定理的基本定义。推导出公式后，实现一个程序，对于一组给定的测试用例 $(N, M, k)$，计算：\n- 直接法的FLOP计数 $D$，\n- 基于FFT的方法的FLOP计数 $F$，\n- 比率 $R = D/F$，\n- 一个布尔值 $B$，指示基于FFT的方法是否更经济，即 $F  D$ 是否成立。\n\n使用以下测试套件来检验 $(N, M, k)$ 的不同情况，包括小尺寸核、中等尺寸核和矩形图像：\n- $(N, M, k) = (512, 512, 1)$,\n- $(N, M, k) = (512, 512, 15)$,\n- $(N, M, k) = (512, 512, 63)$,\n- $(N, M, k) = (512, 512, 255)$,\n- $(N, M, k) = (300, 500, 7)$,\n- $(N, M, k) = (300, 500, 127)$.\n\n你的程序必须根据你推导的公式计算并报告每个测试用例的四个量 $(D, F, R, B)$。最终输出格式必须是单行，包含一个用方括号括起来的逗号分隔列表，其中每个元素对应一个测试用例，并且本身是一个形式为 $[N, M, k, D, F, R, B]$ 的列表。将 $D$ 和 $F$ 作为浮点数打印，四舍五入到一位小数；将 $R$ 作为浮点数打印，四舍五入到六位小数；将 $B$ 作为字面量 $True$ 或 $False$ 打印。例如，整体输出应类似于 $[[N_1,M_1,k_1,D_1,F_1,R_1,B_1],[N_2,M_2,k_2,D_2,F_2,R_2,B_2],\\dots]$，显示在单行上且无空格。",
            "solution": "问题陈述经评估有效。它在科学上基于计算物理学和信号处理的原理，特别是关于数值卷积和快速傅里叶变换（FFT）。该问题是适定的，提供了一套清晰、自洽且客观的假设、定义和目标。所有提供的数据和约束条件都是一致的，并允许推导出唯一且有意义的解。不存在逻辑矛盾、事实错误或模糊之处。因此，我们可以进行推导和求解。\n\n本任务是基于一个指定的成本模型，从第一性原理推导两种二维循环卷积方法的计算成本（以浮点运算次数，即FLOPs为单位）。\n\n**直接循环卷积的计算成本分析 ($D$)**\n\n一个 $N \\times M$ 的图像（记为 $I$）与一个 $k \\times k$ 的核（记为 $H$）的离散二维循环卷积，产生一个 $N \\times M$ 的输出图像（记为 $O$）。每个输出像素 $O(i, j)$ 的值由以下公式给出：\n$$ O(i, j) = \\sum_{u=0}^{k-1} \\sum_{v=0}^{k-1} H(u, v) I((i-u) \\pmod N, (j-v) \\pmod M) $$\n其中索引 $i$ 和 $j$ 的范围分别为 $i \\in \\{0, 1, \\dots, N-1\\}$ 和 $j \\in \\{0, 1, \\dots, M-1\\}$。\n\n我们首先分析计算单个输出像素 $O(i, j)$ 的成本。双重求和包含 $k \\times k = k^2$ 个项。每一项 $H(u, v) I(\\dots)$ 都涉及一次实数浮点乘法。根据成本模型，这部分贡献了 $k^2 \\times 1 = k^2$ FLOPs。\n然后必须将这 $k^2$ 个乘积相加。对 $n$ 个数求和需要 $n-1$ 次加法。在这种情况下，我们需要 $k^2 - 1$ 次实数加法。这部分贡献了 $(k^2 - 1) \\times 1 = k^2 - 1$ FLOPs。\n用于计算带模运算符索引的整数算术不被视为浮点运算，因此在此模型中成本为零。\n\n计算一个输出像素所需的总FLOPs是乘法和加法成本的总和：\n$$ \\text{FLOPs per pixel} = k^2 + (k^2 - 1) = 2k^2 - 1 $$\n\n由于输出图像由 $N \\times M$ 个像素组成，直接卷积方法的总计算成本（我们记为 $D$）是每个像素的成本乘以总像素数：\n$$ D(N, M, k) = NM(2k^2 - 1) $$\n\n**基于FFT的卷积的计算成本分析 ($F$)**\n\n该方法利用卷积定理。按规定，该算法包括四个主要步骤：\n1.  计算 $N \\times M$ 图像 $I$ 的二维FFT。\n2.  计算 $k \\times k$ 核 $H$ 的二维FFT，该核必须首先用零填充到 $N \\times M$ 大小。\n3.  在频域中对得到的两个 $N \\times M$ 复数矩阵进行逐元素乘法。\n4.  计算乘积的二维逆FFT，以获得空间域中的最终图像。\n\n我们使用给定的成本模型分析每一步的FLOP计数。输入（$I$ 和 $H$）是实值的，但我们使用为*复数*FFT提供的成本，将输入视为虚部为零的复数数组。\n\n步骤1：图像的正向FFT\n一个 $N \\times M$ 矩阵的二维复数FFT的成本明确给出为：\n$$ C_{\\text{FFT}} = 5NM(\\log_2 N + \\log_2 M) \\text{ FLOPs} $$\n\n步骤2：填充后核的正向FFT\n$k \\times k$ 的核被填充到 $N \\times M$ 大小。随后的FFT是在这个更大的矩阵上执行的。因此，其成本与图像FFT的成本相同：\n$$ C_{\\text{FFT (kernel)}} = 5NM(\\log_2 N + \\log_2 M) \\text{ FLOPs} $$\n\n步骤3：逐元素复数乘法\n此步骤涉及两个大小为 $N \\times M$ 的复数矩阵的乘法。这相当于 $NM$ 次独立的复数乘法。模型规定，一次复数乘法消耗 $6$ FLOPs。此步骤的总成本为：\n$$ C_{\\text{mult}} = NM \\times 6 \\text{ FLOPs} $$\n\n步骤4：结果的逆FFT\n频域乘法产生的矩阵是复数矩阵，大小为 $N \\times M$。问题陈述指出，逆FFT的成本与正向FFT相同：\n$$ C_{\\text{IFFT}} = 5NM(\\log_2 N + \\log_2 M) \\text{ FLOPs} $$\n\n基于FFT的方法的总成本 $F$ 是这些步骤成本的总和：\n$$ F = (\\text{FFT of } I) + (\\text{FFT of } H) + (\\text{Multiplication}) + (\\text{IFFT of result}) $$\n$$ F = C_{\\text{FFT}} + C_{\\text{FFT (kernel)}} + C_{\\text{mult}} + C_{\\text{IFFT}} $$\n代入成本表达式：\n$$ F = 5NM(\\log_2 N + \\log_2 M) + 5NM(\\log_2 N + \\log_2 M) + 6NM + 5NM(\\log_2 N + \\log_2 M) $$\n$$ F = 3 \\times [5NM(\\log_2 N + \\log_2 M)] + 6NM $$\n$$ F = 15NM(\\log_2 N + \\log_2 M) + 6NM $$\n提取公因式 $NM$：\n$$ F(N, M, k) = NM[15(\\log_2 N + \\log_2 M) + 6] $$\n注意到成本 $F$ 与核大小 $k$ 无关。\n\n**推导公式总结**\n将要实现的FLOP计数公式为：\n-   直接法：$D = NM(2k^2 - 1)$\n-   基于FFT的方法：$F = NM(15(\\log_2 N + \\log_2 M) + 6)$",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and computes the FLOP counts for direct and FFT-based 2D circular convolution.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (512, 512, 1),\n        (512, 512, 15),\n        (512, 512, 63),\n        (512, 512, 255),\n        (300, 500, 7),\n        (300, 500, 127),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, M, k = case\n\n        # Calculate FLOP count for the direct convolution method (D)\n        # D = N * M * (2 * k^2 - 1)\n        # All inputs are integers, ensuring this calculation is exact before rounding.\n        d_flops = float(N * M * (2 * k**2 - 1))\n\n        # Calculate FLOP count for the FFT-based convolution method (F)\n        # F = N * M * (15 * (log2(N) + log2(M)) + 6)\n        log_term = np.log2(N) + np.log2(M)\n        f_flops = float(N * M * (15 * log_term + 6))\n\n        # Calculate the ratio R = D / F\n        # Handle division by zero, though f_flops should always be positive.\n        ratio = d_flops / f_flops if f_flops != 0 else 0.0\n\n        # Determine if the FFT-based method is cheaper\n        is_fft_cheaper = f_flops  d_flops\n\n        # Format the results according to the problem specification\n        # D and F rounded to one decimal place\n        # R rounded to six decimal places\n        # B as a boolean literal\n        formatted_result = [\n            N,\n            M,\n            k,\n            round(d_flops, 1),\n            round(f_flops, 1),\n            round(ratio, 6),\n            is_fft_cheaper\n        ]\n        results.append(formatted_result)\n\n    # Final print statement in the exact required format.\n    # The output is a single line, list-of-lists format, with no spaces.\n    # str(results) produces Python's default representation, including spaces.\n    # We replace spaces to match the strict output format.\n    output_string = str(results).replace(' ', '')\n    print(output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "掌握了FFT的实现和效率优势之后，是时候将其作为强大工具，应用于解决真实的物理问题了。本练习将引导你使用分裂步傅里叶方法（split-step Fourier method）来求解含时薛定谔方程，模拟量子波包隧穿势垒这一经典的量子现象。在这里，FFT是算法的核心，它高效地在位置空间和动量空间之间切换，从而能够精确模拟波函数的演化。这个实践展示了FFT如何将一个抽象的数学工具转化为探索量子世界奥秘的钥匙。",
            "id": "2383392",
            "problem": "你需要推导、实现并验证一个数值求解器，该求解器使用分步傅里叶方法求解一维矩形势垒中高斯波包的量子隧穿问题。你的实现必须通过调用标准数值库来依赖 Cooley–Tukey 快速傅里叶变换 (FFT) 算法。请从含时薛定谔方程出发，并基于第一性原理构建该方法。\n\n使用以下基本和建模假设：\n- 一维含时薛定谔方程为\n$$\ni\\,\\hbar\\,\\frac{\\partial \\psi(x,t)}{\\partial t} \\;=\\; -\\frac{\\hbar^2}{2m}\\,\\frac{\\partial^2 \\psi(x,t)}{\\partial x^2} \\;+\\; V(x)\\,\\psi(x,t).\n$$\n- 在原子单位制下进行计算，其中约化普朗克常数和质量设为 $ \\hbar = 1 $ 和 $ m = 1 $，因此方程简化为\n$$\ni\\,\\frac{\\partial \\psi(x,t)}{\\partial t} \\;=\\; -\\frac{1}{2}\\,\\frac{\\partial^2 \\psi(x,t)}{\\partial x^2} \\;+\\; V(x)\\,\\psi(x,t).\n$$\n- 所有复指数中的角度必须以弧度为单位。\n\n离散化和数值设计要求：\n- 空间域：一个长度为 $ L = 100 $ 的周期性区间，由 $ N = 1024 $ 个均匀间隔的格点 $ x_j \\in [-L/2,\\,L/2) $ 表示，间距为 $ \\Delta x = L/N $。周期性边界条件是使基于傅里叶的方法在数学上保持一致性所必需的。\n- 傅里叶波数必须与周期性格点上的离散傅里叶变换对保持一致，以使动能算符在傅里叶空间中是对角的，其色散关系为 $ \\omega(k) = k^2/2 $。使用的波数格点 $ k_n $ 须与长度为 $ L $ 的域上的离散变换在数学上一致。\n- 初始条件：一个归一化的高斯波包，其平均位置为 $ x_0 = -L/4 $，空间宽度为 $ \\sigma = 1 $，中心波数为 $ k_0 = 1.5 $，\n$$\n\\psi(x,0) \\;=\\; C\\,\\exp\\!\\Big(-\\frac{(x-x_0)^2}{4\\sigma^2}\\Big)\\,\\exp(i\\,k_0\\,x),\n$$\n其中 $ C $ 的选择应满足 $ \\int_{-L/2}^{L/2} |\\psi(x,0)|^2\\,dx = 1 $。归一化必须在离散格点上以数值方式进行。\n- 势垒：一个以 $ x=0 $ 为中心的矩形势垒，其高度为 $ V_0 \\ge 0 $，宽度为 $ a \\ge 0 $，\n$$\nV(x) \\;=\\; \\begin{cases}\nV_0,  |x| \\le a/2,\\\\\n0,  \\text{otherwise}.\n\\end{cases}\n$$\n- 时间步进：选择时间步长 $ \\Delta t = 0.01 $ 和总模拟时间 $ T = 30 $，步数为整数 $ M = T/\\Delta t $。使用一种二阶、时间可逆的算符分裂（分步）方法，该方法在位置空间中交替应用势能演化，在傅里叶空间中交替应用动能演化。动能演化必须使用 Cooley–Tukey FFT 实现来执行。确保离散化是一致的，以便在预期的数值精度范围内保持模守恒。\n\n需要计算的量：\n- 将最终时刻 $ T $ 的透射概率定义为在势垒右侧（即 $ x  a/2 $）概率密度的离散积分，\n$$\n\\mathcal{T} \\;=\\; \\int_{xa/2} |\\psi(x,T)|^2\\,dx,\n$$\n实现为在间距为 $ \\Delta x $ 的格点上的黎曼和。报告 $ \\mathcal{T} $，四舍五入至六位小数。\n\n测试套件：\n- 对 $ L $、$ N $、$ \\Delta t $、$ T $、$ x_0 $、$ \\sigma $ 和 $ k_0 $ 使用上述固定设置。\n- 针对以下三组参数 $ (V_0, a) $ 对求解器进行评估：\n  1. $ (0.5,\\,5.0) $：势垒高度低于波包的标称中心动能，这是一个透射主导的“理想路径”情况。\n  2. $ (1.3,\\,5.0) $：势垒高度略高于中心动能，这是一个隧穿主导的情况。\n  3. $ (0.0,\\,5.0) $：零高度势垒，这是一个应产生接近单位透射率的边界情况。\n- 对于每种情况，计算上文定义的相应透射概率 $ \\mathcal{T} $。\n\n最终程序输出格式：\n- 您的程序应生成单行输出，其中包含按上述顺序列出的三个透射概率。每个概率都四舍五入至六位小数，并以逗号分隔列表的形式置于方括号内，例如：\n`\"[0.952341,0.007812,0.999998]\"`。\n- 不允许有任何其他输出。\n\n在所选的原子单位制下，所有物理量均为无量纲。所有角度均以弧度为单位。最终的数值答案必须是浮点数，并四舍五入至六位小数。",
            "solution": "问题陈述经过了严格的验证。\n\n步骤1：提取给定条件\n- **控制方程**：一维含时薛定谔方程，采用原子单位制（$\\hbar=1$, $m=1$）：\n$$\ni\\,\\frac{\\partial \\psi(x,t)}{\\partial t} \\;=\\; -\\frac{1}{2}\\,\\frac{\\partial^2 \\psi(x,t)}{\\partial x^2} \\;+\\; V(x)\\,\\psi(x,t)\n$$\n- **离散化参数**：\n  - 空间域长度：$L = 100$。\n  - 格点数：$N = 1024$。\n  - 格点间距：$\\Delta x = L/N$。\n  - 空间格点：$x_j \\in [-L/2, L/2)$。\n  - 边界条件：周期性。\n  - 时间步长：$\\Delta t = 0.01$。\n  - 总模拟时间：$T = 30$。\n- **初始条件（$t=0$）**：\n  - 波函数形式：$\\psi(x,0) = C\\,\\exp\\left(-\\frac{(x-x_0)^2}{4\\sigma^2}\\right)\\,\\exp(i\\,k_0\\,x)$。\n  - 平均位置：$x_0 = -L/4$。\n  - 空间宽度：$\\sigma = 1$。\n  - 中心波数：$k_0 = 1.5$。\n  - 归一化：$\\int_{-L/2}^{L/2} |\\psi(x,0)|^2\\,dx = 1$，在离散格点上以数值方式进行。\n- **势垒**：\n  - 函数形式：矩形势垒，\n  $$\n  V(x) \\;=\\; \\begin{cases}\n  V_0,  |x| \\le a/2,\\\\\n  0,  \\text{otherwise}.\n  \\end{cases}\n  $$\n  - 参数：高度 $V_0 \\ge 0$，宽度 $a \\ge 0$。\n- **数值方法**：\n  - 二阶、时间可逆的分步傅里叶方法。\n  - 动能演化在傅里叶空间中使用 Cooley–Tukey FFT 算法执行。\n- **需要计算的量**：\n  - 在 $t=T$ 时的透射概率：$\\mathcal{T} = \\int_{xa/2} |\\psi(x,T)|^2\\,dx$，实现为离散和。\n- **测试套件**：\n  - 情况 1：$(V_0, a) = (0.5, 5.0)$。\n  - 情况 2：$(V_0, a) = (1.3, 5.0)$。\n  - 情况 3：$(V_0, a) = (0.0, 5.0)$。\n\n步骤2：使用提取的给定条件进行验证\n- **科学依据**：该问题基于薛定谔方程，这是量子力学的一个基本原理。波包隧穿的物理场景是一个经典问题。所提出的数值技术，即分步傅里叶方法，是求解此类偏微分方程的一种标准且稳健的算法。在计算物理中，使用原子单位制是一种常见且有效的简化方法。该问题在科学上是合理的。\n- **适定性**：模拟所需的所有参数（$L$、$N$、$\\Delta t$、$T$）以及定义初始状态和势的参数均已提供。初值问题是明确定义的。需要计算的量（$\\mathcal{T}$）也被明确地指定。\n- **客观性**：该问题使用精确的数学和物理术语陈述。没有主观或模糊的陈述。\n- **总体评估**：该问题不违反任何无效标准。它是计算物理学中一个完整、一致且适定的问题。\n\n步骤3：结论与行动\n该问题是**有效的**。将推导并实现一个解决方案。\n\n含时薛定谔方程由下式给出\n$$\ni\\,\\frac{\\partial \\psi(x,t)}{\\partial t} = \\hat{H}\\psi(x,t)\n$$\n其中哈密顿算符 $\\hat{H}$ 是动能算符 $\\hat{T}$ 和势能算符 $\\hat{V}$ 的和。在给定的单位制（$\\hbar=1$, $m=1$）下，它们是：\n$$\n\\hat{T} = -\\frac{1}{2}\\frac{\\partial^2}{\\partial x^2}, \\quad \\hat{V} = V(x)\n$$\n在一个小的时间步长 $\\Delta t$ 内，波函数演化的形式解为\n$$\n\\psi(x, t + \\Delta t) = e^{-i\\hat{H}\\Delta t} \\psi(x,t) = e^{-i(\\hat{T} + \\hat{V})\\Delta t} \\psi(x,t)\n$$\n由于动能算符和势能算符不对易，即 $[\\hat{T}, \\hat{V}] \\neq 0$，因此和的指数不能简单地因式分解。分步法为时间演化算符提供了一个近似。问题指定了一个二阶精确的对称格式（Strang 分裂）：\n$$\ne^{-i(\\hat{T} + \\hat{V})\\Delta t} \\approx e^{-i\\hat{V}\\frac{\\Delta t}{2}} e^{-i\\hat{T}\\Delta t} e^{-i\\hat{V}\\frac{\\Delta t}{2}}\n$$\n对于单步，该近似的精度为 $\\mathcal{O}(\\Delta t^3)$ 阶，并且是幺正的，因此能够保持波函数的模，这对物理上的一致性至关重要。通过应用此操作 $M = T/\\Delta t$ 次，可以实现从 $t=0$ 到 $t=T$ 的完整时间演化。\n\n该算法通过实现分裂算符的每个分量来推进：\n1.  **势能演化**：算符 $e^{-i\\hat{V}\\frac{\\Delta t}{2}}$ 涉及势能 $V(x)$，它是位置 $x$ 的函数。在位置表象中，该算符是对角的。其作用是简单的乘法：\n    $$\n    \\psi(x,t) \\rightarrow e^{-iV(x)\\frac{\\Delta t}{2}} \\psi(x,t)\n    $$\n2.  **动能演化**：算符 $e^{-i\\hat{T}\\Delta t}$ 包含一个二阶导数，这使得它在位置表象中是非局域的且难以应用。然而，傅里叶变换将动量（并因此将动能）算符对角化。令 $\\tilde{\\psi}(k,t)$ 为 $\\psi(x,t)$ 的傅里叶变换：\n    $$\n    \\tilde{\\psi}(k,t) = \\mathcal{F}\\{\\psi(x,t)\\} = \\frac{1}{\\sqrt{2\\pi}} \\int_{-\\infty}^{\\infty} \\psi(x,t) e^{-ikx} dx\n    $$\n    在傅里叶空间中，动能算符变为与 $\\frac{k^2}{2}$ 的简单乘法。因此，动能演化步骤为：\n    $$\n    \\tilde{\\psi}(k,t) \\rightarrow e^{-i\\frac{k^2}{2}\\Delta t} \\tilde{\\psi}(k,t)\n    $$\n    要实现这一点，必须：\n    a.  将波函数变换到傅里叶空间：$\\psi(x) \\rightarrow \\tilde{\\psi}(k) = \\text{FFT}(\\psi(x))$。\n    b.  在傅里叶空间中应用动能演化相位因子。\n    c.  变换回位置空间：$\\tilde{\\psi}(k) \\rightarrow \\psi(x) = \\text{IFFT}(\\tilde{\\psi}(k))$。\n该问题要求使用 Cooley-Tukey 算法，这是诸如 NumPy 等数值库中快速傅里叶变换（FFT）的标准实现。\n\n数值实现需要对所有连续变量进行离散化。\n- **空间格点**：域 $[-L/2, L/2)$ 被离散化为 $N$ 个点 $x_j = -L/2 + j\\Delta x$（$j=0, \\dots, N-1$），格点间距为 $\\Delta x = L/N$。波函数由其在这些点上的值组成的向量 $\\psi_j = \\psi(x_j)$ 表示。\n- **波数格点**：为与长度为 $L$、包含 $N$ 个点的域上的离散傅里叶变换保持一致，相应的波数格点 $k_n$ 由 $k_n = 2\\pi f_n$ 给出，其中 $f_n$ 是标准FFT例程提供的频率。对于采样间距 $\\Delta x$，这些频率是 $f_n = n/(N\\Delta x)$（对于 $n = 0, \\dots, N/2-1$）和 $f_n = (n-N)/(N\\Delta x)$（对于 $n=N/2, \\dots, N-1$）。`numpy.fft.fftfreq` 函数会处理这种排序。\n- **初始条件**：初始波包在空间格点 $x_j$ 上构建：\n$$\n\\psi_j(0) = C \\exp\\left(-\\frac{(x_j - x_0)^2}{4\\sigma^2}\\right) \\exp(i k_0 x_j)\n$$\n归一化常数 $C$ 通过数值方法强制满足条件 $\\sum_{j=0}^{N-1} |\\psi_j(0)|^2 \\Delta x = 1$ 来找到。这得到 $C = 1 / \\sqrt{\\sum_{j=0}^{N-1} \\left|\\exp\\left(-\\frac{(x_j - x_0)^2}{4\\sigma^2}\\right) \\exp(i k_0 x_j)\\right|^2 \\Delta x}$。\n- **势垒**：矩形势垒 $V(x)$ 在空间格点 $x_j$ 上定义。对于给定的 $V_0$ 和 $a$，如果 $|x_j| \\le a/2$，则 $V_j = V_0$，否则 $V_j = 0$。\n\n传播算法如下：\n1.  初始化参数：$L=100$，$N=1024$，$\\Delta t=0.01$，$T=30$。计算 $\\Delta x = L/N$ 和步数 $M = \\text{int}(T/\\Delta t)$。\n2.  构建空间格点 $x_j$ 和波数格点 $k_n$。\n3.  对于每个测试用例 $(V_0, a)$：\n    a. 构建势能数组 $V_j$。\n    b. 构建初始波函数数组 $\\psi_j(0)$ 并对其进行数值归一化。\n    c. 预先计算演化算符：$U_V = \\exp(-i V_j \\Delta t/2)$ 和 $U_T = \\exp(-i k_n^2 \\Delta t/2)$。\n    d. 在一个从 $m=0$ 到 $M-1$ 的循环中进行演化：\n        i.   应用前半个势能步：$\\psi \\leftarrow \\psi \\cdot U_V$。\n        ii.  变换到 k 空间：$\\tilde{\\psi} \\leftarrow \\text{FFT}(\\psi)$。\n        iii. 应用动能步：$\\tilde{\\psi} \\leftarrow \\tilde{\\psi} \\cdot U_T$。\n        iv.  变换到 x 空间：$\\psi \\leftarrow \\text{IFFT}(\\tilde{\\psi})$。\n        v.   应用后半个势能步：$\\psi \\leftarrow \\psi \\cdot U_V$。\n4.  在最终时刻 $T$，波函数为 $\\psi_j(T)$。\n5.  通过对势垒右侧格点上的概率密度求和来计算透射概率 $\\mathcal{T}$：\n    $$\n    \\mathcal{T} = \\sum_{j \\text{ where } x_j  a/2} |\\psi_j(T)|^2 \\Delta x\n    $$\n对三组给定的参数 $(V_0, a)$ 中的每一组重复此过程。波包的中心动能为 $E_k = k_0^2/2 = (1.5)^2/2 = 1.125$。所选的势垒高度分别低于（$V_0=0.5$）、高于（$V_0=1.3$）和等于零（相对于此能量），从而正确地探测了经典透射、量子隧穿和自由传播这几种情况。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives, implements, and validates a numerical solver for 1D quantum tunneling\n    of a Gaussian wavepacket through a rectangular potential barrier using the\n    split-step Fourier method.\n    \"\"\"\n\n    # Discretization and numerical design parameters\n    L = 100.0         # Spatial domain length\n    N = 1024          # Number of grid points\n    dx = L / N        # Spatial grid spacing\n    x = np.arange(-L/2, L/2, dx) # Spatial grid\n\n    # Wavenumber grid consistent with numpy's FFT\n    # k = 2 * pi * f, where f are the frequencies from fftfreq\n    k = 2 * np.pi * np.fft.fftfreq(N, d=dx)\n\n    # Initial condition parameters\n    x0 = -L / 4.0     # Mean position\n    sigma = 1.0       # Spatial width\n    k0 = 1.5          # Central wavenumber\n\n    # Time stepping parameters\n    dt = 0.01         # Time step\n    T = 30.0          # Total simulation time\n    num_steps = int(T / dt)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.5, 5.0),  # V0, a: Barrier height  central energy\n        (1.3, 5.0),  # V0, a: Barrier height  central energy (tunneling)\n        (0.0, 5.0),  # V0, a: Zero-height barrier (free propagation)\n    ]\n\n    results = []\n    \n    # Pre-compute the kinetic energy evolution operator (independent of V0, a)\n    # This is U_T = exp(-i * T_op * dt) where T_op = k^2 / 2\n    kinetic_evolution_op = np.exp(-1j * k**2 * dt / 2.0)\n\n    for V0, a in test_cases:\n        # 1. Set up the potential barrier\n        V = np.zeros_like(x)\n        V[np.abs(x) = a / 2.0] = V0\n        \n        # Pre-compute the potential energy evolution operator for this case\n        # This is U_V = exp(-i * V_op * dt/2)\n        potential_evolution_op = np.exp(-1j * V * dt / 2.0)\n\n        # 2. Set up the initial wavefunction\n        # Un-normalized Gaussian wavepacket\n        psi_0_unnormalized = np.exp(-(x - x0)**2 / (4 * sigma**2)) * np.exp(1j * k0 * x)\n        \n        # Numerically normalize the wavefunction\n        norm_squared = np.sum(np.abs(psi_0_unnormalized)**2) * dx\n        C = 1.0 / np.sqrt(norm_squared)\n        psi = C * psi_0_unnormalized\n        psi = psi.astype(np.complex128)\n\n        # 3. Time evolution using the split-step Fourier method\n        for _ in range(num_steps):\n            # First half potential step\n            psi = psi * potential_evolution_op\n\n            # Full kinetic step in Fourier space\n            psi_k = np.fft.fft(psi)\n            psi_k = psi_k * kinetic_evolution_op\n            psi = np.fft.ifft(psi_k)\n\n            # Second half potential step\n            psi = psi * potential_evolution_op\n        \n        # 4. Compute the transmission probability\n        # Find indices for x  a/2\n        transmission_indices = np.where(x > a / 2.0)\n        \n        # Calculate probability density in the transmission region\n        prob_density_transmitted = np.abs(psi[transmission_indices])**2\n        \n        # Integrate (sum) over the transmission region\n        transmission_probability = np.sum(prob_density_transmitted) * dx\n        \n        results.append(round(transmission_probability, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}