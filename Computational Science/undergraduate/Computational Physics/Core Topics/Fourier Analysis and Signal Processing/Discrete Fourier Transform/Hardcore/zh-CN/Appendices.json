{
    "hands_on_practices": [
        {
            "introduction": "理论学习之后，最好的检验方式莫过于亲自动手计算。本节的第一个实践将引导你根据离散傅里叶变换 (DFT) 的基本定义式，为一个简单的 4 点序列计算其 DFT。这个练习旨在加深你对求和公式以及复指数在其中所扮演的“分析”角色的理解，为后续掌握更高效的算法（如 FFT）打下坚实的数学直觉基础。",
            "id": "2213509",
            "problem": "在数字信号处理中，离散傅里叶变换（DFT）是一种基本工具，用于将有限的数据点序列分解为其组成频率分量。\n\n考虑一个由 $N=4$ 个采样点组成的离散时间复信号序列：$x_0 = 1$，$x_1 = 2i$，$x_2 = 3$ 和 $x_3 = -i$，其中 $i = \\sqrt{-1}$。\n\n序列 $x_n$（其中 $n=0, 1, \\dots, N-1$）的 $N$ 点 DFT 是一个序列 $X_k$（其中 $k=0, 1, \\dots, N-1$），由以下分析方程给出：\n$$X_k = \\sum_{n=0}^{N-1} x_n \\exp\\left(-i \\frac{2\\pi nk}{N}\\right)$$\n计算给定信号 $x_n$ 的 4 点 DFT 序列 $X_k = [X_0, X_1, X_2, X_3]$。最终答案应为一个包含四个复数的序列，以单行矩阵的形式呈现。",
            "solution": "我们使用 $N=4$ 的 DFT 分析方程：\n$$X_{k}=\\sum_{n=0}^{3}x_{n}\\exp\\left(-i\\frac{2\\pi nk}{4}\\right), \\quad k=0,1,2,3.$$\n定义 $4$ 次本原单位根 $W=\\exp\\left(-i\\frac{2\\pi}{4}\\right)=\\exp(-i\\frac{\\pi}{2})=-i$。那么 $W^{0}=1$，$W^{1}=-i$，$W^{2}=-1$，$W^{3}=i$ 且 $W^{4}=1$。\n\n对于 $k=0$：\n$$X_{0}=x_{0}W^{0\\cdot 0}+x_{1}W^{1\\cdot 0}+x_{2}W^{2\\cdot 0}+x_{3}W^{3\\cdot 0}=1+2i+3+(-i)=4+i.$$\n\n对于 $k=1$：\n$$X_{1}=x_{0}W^{0}+x_{1}W^{1}+x_{2}W^{2}+x_{3}W^{3}=1+(2i)(-i)+3(-1)+(-i)(i)=1+2-3+1=1.$$\n\n对于 $k=2$：\n$$X_{2}=x_{0}W^{0}+x_{1}W^{2}+x_{2}W^{4}+x_{3}W^{6}=1+(2i)(-1)+3(1)+(-i)(-1)=(1+3)+(-2i+i)=4-i.$$\n\n对于 $k=3$：\n$$X_{3}=x_{0}W^{0}+x_{1}W^{3}+x_{2}W^{6}+x_{3}W^{9}=1+(2i)(i)+3(-1)+(-i)(-i)=1-2-3-1=-5.$$\n\n因此，4 点 DFT 序列为\n$$\\begin{pmatrix}4+i  1  4-i  -5\\end{pmatrix}.$$",
            "answer": "$$\\boxed{\\begin{pmatrix}4+i  1  4-i  -5\\end{pmatrix}}$$"
        },
        {
            "introduction": "在掌握了如何计算 DFT 后，我们必须关注一个在实际应用中至关重要的问题：采样。当我们将一个连续信号转换为离散序列时，可能会出现“混叠”现象，即高频信号伪装成低频信号，从而导致错误的频谱分析。通过这个实践 ，你将具体看到两个频率完全不同的正弦波如何在低于奈奎斯特频率采样时，产生完全相同的离散样本，从而直观地理解混叠这一关键概念。",
            "id": "2387236",
            "problem": "考虑一个连续时间正弦波 $x(t) = \\sin\\!\\big(2\\pi f\\, t + \\phi\\big)$，以采样频率 $f_s$ 进行均匀采样，因此在时间 $t_n = n/f_s$（其中 $n$ 为整数）处采集样本。得到的离散时间序列为 $x[n] = x(t_n)$。在计算物理学中，离散傅里叶变换（DFT）应用于 $x[n]$ 以分析其频率成分。请选择一个选项，该选项指定了两个不同的正弦波（一个低频，一个高频），当以 $f_s$ 采样时，它们对所有整数 $n$ 都产生完全相同的样本 $x[n]$，从而展示低于奈奎斯特速率的混叠现象。\n\n在整个问题中，假设采样频率为 $f_s = 200\\,\\text{Hz}$，振幅等于 $1$，相位如各选项所述。奈奎斯特频率为 $f_s/2$。\n\nA. $x_{\\text{low}}(t) = \\sin\\!\\big(2\\pi \\cdot 30\\, t\\big)$ 和 $x_{\\text{high}}(t) = \\sin\\!\\big(2\\pi \\cdot 230\\, t\\big)$\n\nB. $x_{\\text{low}}(t) = \\sin\\!\\big(2\\pi \\cdot 30\\, t\\big)$ 和 $x_{\\text{high}}(t) = \\sin\\!\\big(2\\pi \\cdot 170\\, t\\big)$\n\nC. $x_{\\text{low}}(t) = \\sin\\!\\big(2\\pi \\cdot 40\\, t\\big)$ 和 $x_{\\text{high}}(t) = \\sin\\!\\big(2\\pi \\cdot 240\\, t + \\pi/3\\big)$\n\nD. $x_{\\text{low}}(t) = \\sin\\!\\big(2\\pi \\cdot 75\\, t\\big)$ 和 $x_{\\text{high}}(t) = \\sin\\!\\big(2\\pi \\cdot 275\\, t + \\pi\\big)$",
            "solution": "首先将对问题陈述的科学合理性和一致性进行验证。\n\n### 步骤 1：提取已知条件\n- 连续时间正弦波：$x(t) = \\sin(2\\pi f t + \\phi)$\n- 采样频率：$f_s$\n- 采样时间：$t_n = n/f_s$，其中 $n$ 为整数\n- 离散时间序列：$x[n] = x(t_n)$\n- 主题：计算物理学中的离散傅里叶变换（DFT），特别是展示混叠现象。\n- 任务：确定哪个选项给出了两个不同的正弦波（一个低频，一个高频），它们能产生“对所有整数 $n$ 都完全相同的样本 $x[n]$”。\n- 具体数值：\n    - 采样频率 $f_s = 200\\,\\text{Hz}$。\n    - 振幅等于 $1$。\n    - 相位 $\\phi$ 如各选项所述。\n- 定义：奈奎斯特频率为 $f_s/2$。\n\n### 步骤 2：使用提取的已知条件进行验证\n根据所需标准对问题进行评估。\n- **科学依据**：该问题涉及混叠现象，这是数字信号处理中的一个基本且公认的概念，也是计算物理学的核心组成部分。其数学框架基于标准的傅里叶分析和三角学。该问题在科学上是合理的。\n- **适定性**：问题陈述清晰。它要求从一个有限的选项列表中找到一对特定的函数，这对函数满足一个精确定义的数学条件（产生相同的样本序列）。预期在选项中有一个唯一解。该问题是适定的。\n- **客观性**：该问题使用精确的数学语言和客观参数（$f_s$、信号形式、频率、相位）进行描述。没有主观或模糊的术语。\n- **其他缺陷**：问题陈述完整、一致，不含事实错误或不切实际的数值。短语“低于奈奎斯特速率的混叠”在上下文中被理解为一个高频信号表现为频率低于奈奎斯特频率的混叠信号，这是描述混叠结果的标准术语。\n\n### 步骤 3：结论与行动\n问题陈述有效。下面将进行求解。\n\n一个连续时间信号 $x(t) = \\sin(2\\pi f t + \\phi)$ 在以频率 $f_s$ 采样时，产生的离散时间序列为 $x[n] = x(t_n) = \\sin(2\\pi f \\frac{n}{f_s} + \\phi)$。\n\n两个不同的连续时间正弦波 $x_1(t) = \\sin(2\\pi f_1 t + \\phi_1)$ 和 $x_2(t) = \\sin(2\\pi f_2 t + \\phi_2)$，将会产生相同的样本序列，即对所有整数 $n$ 都有 $x_1[n] = x_2[n]$，如果它们在离散域中的各自参数满足适当的关系。离散时间序列为：\n$x_1[n] = \\sin\\left(2\\pi \\frac{f_1}{f_s}n + \\phi_1\\right)$\n$x_2[n] = \\sin\\left(2\\pi \\frac{f_2}{f_s}n + \\phi_2\\right)$\n\n要使这两个序列相同，基于正弦函数的性质，必须满足两个主要条件之一。\n\n**条件 I：非反相混叠**\n参数在模 $2\\pi$ 的意义下是等价的。当频率满足 $f_1 = f_2 + k f_s$（其中 $k$ 为某个非零整数）时，会发生这种情况。在这种情况下：\n$x_1[n] = \\sin\\left(2\\pi \\frac{f_2+kf_s}{f_s}n + \\phi_1\\right) = \\sin\\left(2\\pi \\frac{f_2}{f_s}n + 2\\pi k n + \\phi_1\\right)$\n由于 $k$ 和 $n$ 都是整数，所以 $2\\pi k n$ 是 $2\\pi$ 的整数倍。因为正弦函数是周期为 $2\\pi$ 的周期函数，所以这可以简化为：\n$x_1[n] = \\sin\\left(2\\pi \\frac{f_2}{f_s}n + \\phi_1\\right)$\n要使 $x_1[n]$ 与 $x_2[n]$ 相同，相位必须相等：$\\phi_1 \\equiv \\phi_2 \\pmod{2\\pi}$。\n\n**条件 II：反相混叠**\n参数通过恒等式 $\\sin(\\theta) = \\sin(\\pi - \\theta)$ 相关联。当频率满足 $f_1 = -f_2 + k f_s$（其中 $k$ 为某个非零整数）时，会发生这种情况。在这种情况下：\n$x_1[n] = \\sin\\left(2\\pi \\frac{-f_2+kf_s}{f_s}n + \\phi_1\\right) = \\sin\\left(-2\\pi \\frac{f_2}{f_s}n + 2\\pi k n + \\phi_1\\right) = \\sin\\left(-2\\pi \\frac{f_2}{f_s}n + \\phi_1\\right)$\n使用恒等式 $\\sin(-x) = \\sin(x+\\pi)$，我们得到：\n$x_1[n] = \\sin\\left(2\\pi \\frac{f_2}{f_s}n - \\phi_1 + \\pi\\right)$\n要使 $x_1[n]$ 与 $x_2[n]$ 相同，得到的相位必须相等：$-\\phi_1 + \\pi \\equiv \\phi_2 \\pmod{2\\pi}$，这等价于 $\\phi_1 + \\phi_2 \\equiv \\pi \\pmod{2\\pi}$。\n\n给定 $f_s = 200\\,\\text{Hz}$。我们用这两个条件来检验每个选项。在所有选项中，$f_1$ 将是 $f_{\\text{high}}$，$f_2$ 将是 $f_{\\text{low}}$。\n\n**A. $x_{\\text{low}}(t) = \\sin(2\\pi \\cdot 30\\, t)$ 和 $x_{\\text{high}}(t) = \\sin(2\\pi \\cdot 230\\, t)$**\n这里，$f_{\\text{low}} = 30\\,\\text{Hz}$，$\\phi_{\\text{low}} = 0$，以及 $f_{\\text{high}} = 230\\,\\text{Hz}$，$\\phi_{\\text{high}} = 0$。\n- 检验条件 I：$f_{\\text{high}} = f_{\\text{low}} + k f_s$ 是否对某个整数 $k$ 成立？\n$230 = 30 + k(200) \\implies 200 = k(200) \\implies k=1$。是。\n- 检验条件 I 的相位要求：$\\phi_{\\text{high}} = \\phi_{\\text{low}}$ 是否成立？\n$0 = 0$。是。\n条件 I 的两个部分都满足。样本是相同的。\n结论：**正确**。\n\n**B. $x_{\\text{low}}(t) = \\sin(2\\pi \\cdot 30\\, t)$ 和 $x_{\\text{high}}(t) = \\sin(2\\pi \\cdot 170\\, t)$**\n这里，$f_{\\text{low}} = 30\\,\\text{Hz}$，$\\phi_{\\text{low}} = 0$，以及 $f_{\\text{high}} = 170\\,\\text{Hz}$，$\\phi_{\\text{high}} = 0$。\n- 检验条件 I：$f_{\\text{high}} = f_{\\text{low}} + k f_s$ 是否成立？\n$170 = 30 + k(200) \\implies 140 = k(200) \\implies k = 0.7$。不是整数。条件 I 不成立。\n- 检验条件 II：$f_{\\text{high}} = -f_{\\text{low}} + k f_s$ 是否成立？\n$170 = -30 + k(200) \\implies 200 = k(200) \\implies k=1$。是。\n- 检验条件 II 的相位要求：$\\phi_{\\text{high}} + \\phi_{\\text{low}} = \\pi$ 是否成立？\n$0 + 0 = 0 \\neq \\pi$。相位要求不成立。\n样本不相同。在这种情况下，$x_{\\text{high}}[n] = -x_{\\text{low}}[n]$。\n结论：**不正确**。\n\n**C. $x_{\\text{low}}(t) = \\sin(2\\pi \\cdot 40\\, t)$ 和 $x_{\\text{high}}(t) = \\sin(2\\pi \\cdot 240\\, t + \\pi/3)$**\n这里，$f_{\\text{low}} = 40\\,\\text{Hz}$，$\\phi_{\\text{low}} = 0$，以及 $f_{\\text{high}} = 240\\,\\text{Hz}$，$\\phi_{\\text{high}} = \\pi/3$。\n- 检验条件 I：$f_{\\text{high}} = f_{\\text{low}} + k f_s$ 是否成立？\n$240 = 40 + k(200) \\implies 200 = k(200) \\implies k=1$。是。\n- 检验条件 I 的相位要求：$\\phi_{\\text{high}} = \\phi_{\\text{low}}$ 是否成立？\n$\\pi/3 \\neq 0$。相位要求不成立。\n- 检验条件 II：$f_{\\text{high}} = -f_{\\text{low}} + k f_s$ 是否成立？\n$240 = -40 + k(200) \\implies 280 = k(200) \\implies k=1.4$。不是整数。\n样本不相同。\n结论：**不正确**。\n\n**D. $x_{\\text{low}}(t) = \\sin(2\\pi \\cdot 75\\, t)$ 和 $x_{\\text{high}}(t) = \\sin(2\\pi \\cdot 275\\, t + \\pi)$**\n这里，$f_{\\text{low}} = 75\\,\\text{Hz}$，$\\phi_{\\text{low}} = 0$，以及 $f_{\\text{high}} = 275\\,\\text{Hz}$，$\\phi_{\\text{high}} = \\pi$。\n- 检验条件 I：$f_{\\text{high}} = f_{\\text{low}} + k f_s$ 是否成立？\n$275 = 75 + k(200) \\implies 200 = k(200) \\implies k=1$。是。\n- 检验条件 I 的相位要求：$\\phi_{\\text{high}} = \\phi_{\\text{low}}$ 是否成立？\n$\\pi \\neq 0$。相位要求不成立。\n- 检验条件 II：$f_{\\text{high}} = -f_{\\text{low}} + k f_s$ 是否成立？\n$275 = -75 + k(200) \\implies 350 = k(200) \\implies k=1.75$。不是整数。\n样本不相同。\n结论：**不正确**。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "直接计算 DFT 的复杂度为 $\\mathcal{O}(N^2)$，在处理大数据集时效率低下。快速傅里叶变换 (FFT) 算法的出现是数字信号处理领域的一场革命，它将计算复杂度降至 $\\mathcal{O}(N \\log N)$。这个综合性实践  将指导你从零开始实现核心的 Cooley-Tukey FFT 算法。更重要的是，你将运用自己编写的程序来验证 DFT 的两个基石性质——卷积定理和帕塞瓦尔恒等式，深刻体会到 DFT 在连接时域与频域方面的强大威力。",
            "id": "2387187",
            "problem": "设 $N$ 是一个正整数，其形式为 $N = 2^m$，其中 $m$ 为非负整数。对于一个长度为 $N$ 的复值序列 $x = \\{x_n\\}_{n=0}^{N-1}$，其离散傅里叶变换 (DFT) $X = \\{X_k\\}_{k=0}^{N-1}$ 定义为\n$$\nX_k = \\sum_{n=0}^{N-1} x_n \\, e^{-2\\pi i \\, k n / N} \\quad \\text{for } k = 0,1,\\dots,N-1,\n$$\n其逆离散傅里叶变换 (IDFT) 定义为\n$$\nx_n = \\frac{1}{N} \\sum_{k=0}^{N-1} X_k \\, e^{+2\\pi i \\, k n / N} \\quad \\text{for } n = 0,1,\\dots,N-1,\n$$\n其中所有角度均以弧度为单位。\n\n编写一个完整的程序，在不调用任何库中的傅里叶变换例程的情况下，计算长度为 $N = 2^m$ 的序列的 DFT 和 IDFT。您的程序还必须仅使用这些定义，通过明确的测试用例来验证以下基本性质：\n\n- 循环卷积定理：对于长度为 $N$ 的序列 $a$ 和 $b$，其长度为 $N$ 的循环卷积 $c$ 定义为 $c_n = \\sum_{m=0}^{N-1} a_m \\, b_{(n-m) \\bmod N}$，满足 $C_k = A_k B_k$，其中 $A$、$B$ 和 $C$ 分别是 $a$、$b$ 和 $c$ 的 DFT。\n- 帕塞瓦尔恒等式 (使用上述归一化)：$\\sum_{n=0}^{N-1} |x_n|^2 = \\frac{1}{N} \\sum_{k=0}^{N-1} |X_k|^2$。\n\n您的程序必须实现自己的快速算法来计算 $N = 2^m$ 的 DFT 和 IDFT，并且必须包含一个直接的 $\\mathcal{O}(N^2)$ DFT 用于验证。在需要布尔验证的地方，使用数值公差 $\\varepsilon = 10^{-9}$。所有角度都必须解释为弧度。\n\n使用以下测试套件，并按下面给出的顺序生成输出：\n\n- 测试 1 (DFT 与直接 DFT 的正确性比较，正常路径)：设 $N = 8$ 且 $x = [0,1,2,3,4,3,2,1]$。使用您的快速实现计算 $X$，并使用直接 DFT 计算 $\\tilde{X}$。如果 $\\max_k |X_k - \\tilde{X}_k| \\le \\varepsilon$ 则输出布尔值 $\\text{True}$，否则输出 $\\text{False}$。\n- 测试 2 (逆变换恢复)：使用与测试 1 相同的 $N$ 和 $x$，将您的 IDFT 应用于快速实现得到的 $X$ 来计算 $x'$。如果 $\\max_n |x'_n - x_n| \\le \\varepsilon$ 则输出布尔值 $\\text{True}$，否则输出 $\\text{False}$。\n- 测试 3 (通过频域进行循环卷积)：设 $N = 8$，$a = [1,2,3,0,0,0,0,0]$，$b = [0,1,0,0,0,0,0,0]$。直接根据定义计算长度为 $N$ 的循环卷积 $c$。另外，通过计算 $a$ 和 $b$ 的 DFT，逐点相乘，然后应用 IDFT 来计算 $\\hat{c}$。输出标量 $\\max_n |c_n - \\hat{c}_n|$，作为浮点数。\n- 测试 4 (帕塞瓦尔恒等式)：设 $N = 16$ 且对于 $n = 0,1,\\dots,15$ 有 $x_n = \\sin\\!\\left( \\frac{2\\pi \\cdot 3 \\, n}{N} \\right) + \\frac{1}{2} \\cos\\!\\left( \\frac{2\\pi \\cdot 5 \\, n}{N} \\right)$。通过您的快速实现计算 $X$。输出标量 $\\left| \\sum_{n=0}^{N-1} |x_n|^2 - \\frac{1}{N} \\sum_{k=0}^{N-1} |X_k|^2 \\right|$，作为浮点数。\n- 测试 5 (边界情况 $N=1$)：设 $N = 1$ 且 $x = [3 + 4i]$。计算 $X$ 然后通过 IDFT 计算 $x'$。如果 $|x'_0 - x_0| \\le \\varepsilon$ 则输出布尔值 $\\text{True}$，否则输出 $\\text{False}$。\n- 测试 6 (最小非平凡尺寸 $N=2$)：设 $N = 2$ 且 $x = [1,-1]$。通过您的快速实现计算 $X$。在给定约定下，确切的 DFT 是 $[0,2]$。输出标量 $\\max_k |X_k - [0,2]_k|$，作为浮点数。\n\n最终输出格式：您的程序应生成单行输出，其中包含按顺序排列的六个结果，形式为用方括号括起来的逗号分隔列表，例如 $[r_1,r_2,r_3,r_4,r_5,r_6]$。所有布尔条目必须是 $\\text{True}$ 或 $\\text{False}$，所有实数值条目必须以标准十进制或科学记数法打印。不应打印其他任何文本。",
            "solution": "所提出的问题是计算物理学领域中一个定义明确且科学严谨的练习，特别是在信号处理方面。它要求实现和验证离散傅里叶变换 (DFT)、其逆变换 (IDFT) 以及相关的基本定理。该问题是完整的、客观的，并且其解决方案是可验证的。我们将继续进行解答。\n\n问题的核心是为给定长度为 $N$ 的离散复值序列 $x = \\{x_n\\}_{n=0}^{N-1}$ 计算其 DFT $X$。其定义如下：\n$$\nX_k = \\sum_{n=0}^{N-1} x_n \\, e^{-2\\pi i \\, k n / N} \\quad \\text{for } k = 0,1,\\dots,N-1.\n$$\n该公式的直接实现涉及两个嵌套循环，一个用于从 $0$ 到 $N-1$ 的每个索引 $k$，另一个用于从 $0$ 到 $N-1$ 的每个索引 $n$。这导致计算复杂度为 $\\mathcal{O}(N^2)$，对于大的 $N$ 来说效率低下。为了验证，我们将实现这样一个直接方法。\n\n问题指定 $N$ 是 2 的幂，即 $N = 2^m$，其中 $m$ 是非负整数。这种结构是采用快速傅里叶变换 (FFT) 算法的关键，特别是 Cooley-Tukey 时域抽取算法。该算法将复杂度从 $\\mathcal{O}(N^2)$ 降低到 $\\mathcal{O}(N \\log N)$。其原理是分而治之。长度为 $N$ 的 DFT被递归地分解为两个长度为 $(N/2)$ 的 DFT。\n\n将序列 $x_n$ 分解为其偶数索引元素，形成序列 $x'_m = x_{2m}$，以及其奇数索引元素，形成序列 $x''_m = x_{2m+1}$，每个序列的长度都为 $N/2$。DFT 的求和可以重写为：\n$$\nX_k = \\sum_{m=0}^{N/2-1} x_{2m} e^{-2\\pi i k (2m) / N} + \\sum_{m=0}^{N/2-1} x_{2m+1} e^{-2\\pi i k (2m+1) / N}\n$$\n$$\nX_k = \\sum_{m=0}^{N/2-1} x'_m e^{-2\\pi i k m / (N/2)} + e^{-2\\pi i k/N} \\sum_{m=0}^{N/2-1} x''_m e^{-2\\pi i k m / (N/2)}\n$$\n设 $X'_k$ 和 $X''_k$ 分别是 $x'_m$ 和 $x''_m$ 的长度为 $(N/2)$ 的 DFT。上述表达式变为：\n$$\nX_k = X'_{k \\bmod (N/2)} + W_N^k X''_{k \\bmod (N/2)}\n$$\n其中 $W_N^k = e^{-2\\pi i k/N}$ 是“旋转因子”(twiddle factor)。对于索引的前半部分，$0 \\le k  N/2$，我们有：\n$$\nX_k = X'_k + W_N^k X''_k\n$$\n对于后半部分，其中索引为 $k+N/2$ (对于 $0 \\le k  N/2$)，我们使用性质 $X'_{k+N/2} = X'_k$、$X''_{k+N/2} = X''_k$ 和 $W_N^{k+N/2} = -W_N^k$。这得出：\n$$\nX_{k+N/2} = X'_k - W_N^k X''_k\n$$\n这个递归定义允许构建完整的 DFT。递归在基例 $N=1$ 时终止，此时序列 $\\{x_0\\}$ 的 DFT 就是 $\\{X_0\\} = \\{x_0\\}$。我们的实现将遵循这种递归结构。\n\n逆离散傅里叶变换 (IDFT) 定义为：\n$$\nx_n = \\frac{1}{N} \\sum_{k=0}^{N-1} X_k \\, e^{+2\\pi i \\, k n / N}\n$$\n没有必要单独实现。我们可以将 IDFT 与正向 DFT 联系起来。观察以下推导：\n$$\nN \\cdot \\overline{x_n} = \\overline{\\sum_{k=0}^{N-1} X_k e^{+2\\pi i k n / N}} = \\sum_{k=0}^{N-1} \\overline{X_k} e^{-2\\pi i k n / N}\n$$\n右边是复共轭序列 $\\{\\overline{X_k}\\}_{k=0}^{N-1}$ 的 DFT。因此，我们可以通过计算 $\\overline{X}$ 的 DFT，取结果的复共轭，再乘以 $1/N$ 来求得 $x_n$。即 $x = \\frac{1}{N} \\overline{\\text{DFT}(\\overline{X})}$。这也允许我们使用我们高效的 FFT 实现来计算逆变换 (IFFT)。\n\n该问题进一步要求验证两个基本定理。\n\n首先是循环卷积定理。两个长度为 $N$ 的序列 $a$ 和 $b$ 的循环卷积 $c$ 由 $c_n = \\sum_{m=0}^{N-1} a_m b_{(n-m) \\bmod N}$ 给出。该定理指出，卷积的 DFT 是各个 DFT 的逐点乘积：$C_k = A_k B_k$。因此，可以通过频域计算 $c$：$c = \\text{IDFT}(\\text{DFT}(a) \\odot \\text{DFT}(b))$，其中 $\\odot$ 表示逐元素乘法。我们将通过直接计算 $c$ 和通过频域路径计算 $c$ 并比较结果来测试这一点。\n\n其次是帕塞瓦尔恒等式。对于给定的 DFT 归一化，该恒等式为：\n$$\n\\sum_{n=0}^{N-1} |x_n|^2 = \\frac{1}{N} \\sum_{k=0}^{N-1} |X_k|^2\n$$\n该定理将信号在时域中的总能量与其在频域中的能量联系起来。我们将对一个特定的测试信号验证这一点。\n\n程序将首先定义必要的函数：一个直接的 $\\mathcal{O}(N^2)$ DFT、一个递归的 $\\mathcal{O}(N \\log N)$ FFT、一个基于 FFT 的 IFFT，以及一个直接的循环卷积函数。然后，它将使用这些函数和 $\\varepsilon = 10^{-9}$ 的数值公差进行比较，执行 6 个指定的测试用例。结果将被收集并按要求的格式打印。",
            "answer": "```python\nimport numpy as np\n\ndef direct_dft(x):\n    \"\"\"\n    Computes the Discrete Fourier Transform of a sequence x using the direct O(N^2) method.\n    \"\"\"\n    x = np.asarray(x, dtype=complex)\n    N = x.shape[0]\n    n = np.arange(N)\n    k = n.reshape((N, 1))\n    W = np.exp(-2j * np.pi * k * n / N)\n    X = np.dot(W, x)\n    return X\n\ndef fft(x):\n    \"\"\"\n    Computes the Discrete Fourier Transform of a sequence x using the recursive\n    Cooley-Tukey FFT algorithm. Assumes N is a power of 2.\n    \"\"\"\n    x = np.asarray(x, dtype=complex)\n    N = x.shape[0]\n\n    if N == 1:\n        return x\n\n    # Decimate: split into even and odd subsequences\n    x_even = fft(x[0::2])\n    x_odd = fft(x[1::2])\n\n    # Combine\n    k = np.arange(N // 2)\n    twiddle_factors = np.exp(-2j * np.pi * k / N)\n    \n    X = np.concatenate([x_even + twiddle_factors * x_odd,\n                          x_even - twiddle_factors * x_odd])\n    return X\n\ndef ifft(X):\n    \"\"\"\n    Computes the Inverse Discrete Fourier Transform using the forward FFT algorithm.\n    \"\"\"\n    X = np.asarray(X, dtype=complex)\n    N = X.shape[0]\n    \n    # Use the property: IDFT(X) = (1/N) * conj(DFT(conj(X)))\n    x = np.conjugate(fft(np.conjugate(X))) / N\n    return x\n\ndef circular_conv(a, b):\n    \"\"\"\n    Computes the circular convolution of two sequences a and b directly.\n    \"\"\"\n    a = np.asarray(a, dtype=complex)\n    b = np.asarray(b, dtype=complex)\n    N = len(a)\n    c = np.zeros(N, dtype=complex)\n    for n in range(N):\n        for m in range(N):\n            c[n] += a[m] * b[(n - m) % N]\n    return c\n\ndef solve():\n    \"\"\"\n    Runs the full test suite and prints the formatted results.\n    \"\"\"\n    epsilon = 1e-9\n    results = []\n\n    # Test 1: DFT correctness versus direct DFT\n    N1 = 8\n    x1 = np.array([0, 1, 2, 3, 4, 3, 2, 1], dtype=float)\n    X_fast = fft(x1)\n    X_direct = direct_dft(x1)\n    err1 = np.max(np.abs(X_fast - X_direct))\n    results.append(err1 = epsilon)\n\n    # Test 2: Inverse transform recovery\n    x_prime = ifft(X_fast)\n    err2 = np.max(np.abs(x_prime - x1))\n    results.append(err2 = epsilon)\n\n    # Test 3: Circular convolution via frequency domain\n    N3 = 8\n    a3 = np.array([1, 2, 3, 0, 0, 0, 0, 0], dtype=float)\n    b3 = np.array([0, 1, 0, 0, 0, 0, 0, 0], dtype=float)\n    c_direct = circular_conv(a3, b3)\n    A3 = fft(a3)\n    B3 = fft(b3)\n    C_freq = A3 * B3\n    c_hat = ifft(C_freq)\n    err3 = np.max(np.abs(c_direct - c_hat))\n    results.append(err3)\n\n    # Test 4: Parseval identity\n    N4 = 16\n    n4 = np.arange(N4)\n    x4 = np.sin(2 * np.pi * 3 * n4 / N4) + 0.5 * np.cos(2 * np.pi * 5 * n4 / N4)\n    X4 = fft(x4)\n    sum_sq_x = np.sum(np.abs(x4)**2)\n    sum_sq_X_scaled = np.sum(np.abs(X4)**2) / N4\n    err4 = np.abs(sum_sq_x - sum_sq_X_scaled)\n    results.append(err4)\n\n    # Test 5: Edge case N=1\n    x5 = np.array([3 + 4j])\n    X5 = fft(x5)\n    x5_prime = ifft(X5)\n    err5 = np.abs(x5_prime[0] - x5[0])\n    results.append(err5 = epsilon)\n\n    # Test 6: Smallest nontrivial size N=2\n    x6 = np.array([1, -1], dtype=float)\n    X6 = fft(x6)\n    X_exact = np.array([0, 2], dtype=complex)\n    err6 = np.max(np.abs(X6 - X_exact))\n    results.append(err6)\n\n    # Format and print final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}