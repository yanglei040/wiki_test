{
    "hands_on_practices": [
        {
            "introduction": "要真正理解自适应算法的精髓，最好的方法莫过于亲手模拟其执行过程。本练习将带你手动跟踪一个自适应梯形法则的计算步骤，通过一个简单的二次函数积分，你将清晰地看到算法如何根据设定的容差，来决定是接受当前的近似值，还是对区间进行细分以追求更高的精度。",
            "id": "2153105",
            "problem": "自适应求积算法会细化其计算网格，以满足所需的误差容限。考虑以下为近似计算定积分 $I = \\int_a^b f(x) \\,dx$ 而设计的递归算法。\n\n**自适应积分算法：**\n函数 `AdaptiveIntegrate(f, a, b, ε)` 接收一个函数 $f$、一个区间 $[a, b]$ 和一个容限 $\\epsilon$ 作为输入。\n\n1.  使用宽度为 $h_1 = b-a$ 的单个区间，根据梯形法则计算近似值 $S_1$。其公式为 $S_1 = \\frac{h_1}{2}(f(a) + f(b))$。\n2.  令 $c = (a+b)/2$ 为区间的中点。使用两个宽度均为 $h_2 = (b-a)/2$ 的子区间 $[a, c]$ 和 $[c, b]$，根据复化梯形法则计算近似值 $S_2$。其公式为 $S_2 = \\frac{h_2}{2}(f(a) + f(c)) + \\frac{h_2}{2}(f(c) + f(b))$。\n3.  更精确的近似值 $S_2$ 的误差估计是基于两个近似值之间的差值。停止准则为 $|S_2 - S_1|  3\\epsilon$。\n4.  如果满足该准则，则此区间上的过程终止，并返回值 $S_2$。\n5.  如果未满足该准则，算法将细化该区间。它对两个子区间进行递归调用，并将每个子区间的容限减半。区间 $[a, b]$ 的结果是这两个调用结果的和：\n    `AdaptiveIntegrate(f, a, c, ε/2) + AdaptiveIntegrate(f, c, b, ε/2)`\n\n你的任务是手动追踪此算法，以初始容限 $\\epsilon = 2$ 计算积分\n$$ I = \\int_0^4 x^2 \\,dx $$\n的数值近似值。\n\n计算算法返回的积分的最终数值近似值。以精确的整数或分数形式给出你的答案。",
            "solution": "我们将给定的自适应梯形算法应用于 $[0,4]$ 上的函数 $f(x)=x^{2}$，初始容限为 $\\epsilon=2$。在 $[a,b]$ 上使用单个分块的梯形近似值为 $S_{1}=\\frac{h_{1}}{2}\\left(f(a)+f(b)\\right)$，其中 $h_{1}=b-a$；使用两个分块的近似值为\n$$\nS_{2}=\\frac{h_{2}}{2}\\left(f(a)+f(c)\\right)+\\frac{h_{2}}{2}\\left(f(c)+f(b)\\right),\n$$\n其中 $c=\\frac{a+b}{2}$ 且 $h_{2}=\\frac{b-a}{2}$。一个区间的停止准则是 $|S_{2}-S_{1}|  3\\epsilon$。如果不满足，我们对 $[a,c]$ 和 $[c,b]$ 进行递归，每个子区间的容限为 $\\epsilon/2$，并将返回的值相加。\n\n顶层区间 $[0,4]$，$\\epsilon=2$：\n- 计算 $h_{1}=4$，$S_{1}=\\frac{4}{2}\\left(f(0)+f(4)\\right)=2\\left(0+16\\right)=32$。\n- 中点 $c=2$，$h_{2}=2$，且\n$$\nS_{2}=\\frac{2}{2}\\left(f(0)+f(2)\\right)+\\frac{2}{2}\\left(f(2)+f(4)\\right)=1\\left(0+4\\right)+1\\left(4+16\\right)=4+20=24.\n$$\n- 误差检查：$\\left|S_{2}-S_{1}\\right|=\\left|24-32\\right|=8$，而 $3\\epsilon=3\\cdot 2=6$。由于 $8 \\not 6$，我们对 $[0,2]$ 和 $[2,4]$ 进行递归，每个子区间的容限为 $\\epsilon/2=1$。\n\n子区间 $[0,2]$，$\\epsilon=1$：\n- 计算 $h_{1}=2$，$S_{1}=\\frac{2}{2}\\left(f(0)+f(2)\\right)=1\\left(0+4\\right)=4$。\n- 中点 $c=1$，$h_{2}=1$，且\n$$\nS_{2}=\\frac{1}{2}\\left(f(0)+f(1)\\right)+\\frac{1}{2}\\left(f(1)+f(2)\\right)=\\frac{1}{2}\\left(0+1\\right)+\\frac{1}{2}\\left(1+4\\right)=\\frac{1}{2}+\\frac{5}{2}=3.\n$$\n- 误差检查：$\\left|S_{2}-S_{1}\\right|=\\left|3-4\\right|=1$，而 $3\\epsilon=3\\cdot 1=3$。由于 $1  3$，接受 $S_{2}=3$ 作为 $[0,2]$ 的结果。\n\n子区间 $[2,4]$，$\\epsilon=1$：\n- 计算 $h_{1}=2$，$S_{1}=\\frac{2}{2}\\left(f(2)+f(4)\\right)=1\\left(4+16\\right)=20$。\n- 中点 $c=3$，$h_{2}=1$，且\n$$\nS_{2}=\\frac{1}{2}\\left(f(2)+f(3)\\right)+\\frac{1}{2}\\left(f(3)+f(4)\\right)=\\frac{1}{2}\\left(4+9\\right)+\\frac{1}{2}\\left(9+16\\right)=\\frac{13}{2}+\\frac{25}{2}=19.\n$$\n- 误差检查：$\\left|S_{2}-S_{1}\\right|=\\left|19-20\\right|=1$，而 $3\\epsilon=3$。由于 $1  3$，接受 $S_{2}=19$ 作为 $[2,4]$ 的结果。\n\n最后，顶层调用返回已接受的子区间结果之和：\n$$\n\\text{Result} = 3+19=22.\n$$\n这就是算法返回的最终数值近似值。",
            "answer": "$$\\boxed{22}$$"
        },
        {
            "introduction": "虽然自适应方法非常强大，但它们并非万无一失。其核心的误差估计是一种启发式策略，而非绝对保证。本练习将挑战你的认知，通过一个精心设计的“病态”函数，它能巧妙地“欺骗”辛普森法则的误差估计，导致算法在未达到真正精度要求时就提前终止。这个例子深刻地揭示了理解算法背后假设与局限性的重要性。",
            "id": "2153040",
            "problem": "一个自适应求积算法被设计用于在指定的容差 $\\epsilon  0$ 内数值逼近连续函数 $f(x)$ 的定积分 $I = \\int_a^b f(x)\\,dx$。该算法基于辛普森法则，在任意给定区间 $[u, v]$ 上的运算如下：\n\n1.  使用辛普森法则计算整个区间的粗略近似值：\n    $$S_1 = \\frac{v-u}{6}\\left(f(u) + 4f\\left(\\frac{u+v}{2}\\right) + f(v)\\right)$$\n2.  通过将两个半区间 $[u, w]$ 和 $[w, v]$（其中 $w = (u+v)/2$）上的辛普森法则结果相加，计算一个更精确的近似值：\n    $$S_2 = \\frac{w-u}{6}\\left(f(u) + 4f\\left(\\frac{u+w}{2}\\right) + f(w)\\right) + \\frac{v-w}{6}\\left(f(w) + 4f\\left(\\frac{w+v}{2}\\right) + f(v)\\right)$$\n3.  使用以下公式估计精确近似值 $S_2$ 的误差：\n    $$E = \\frac{1}{15}|S_2 - S_1|$$\n4.  如果估计误差 $E$ 小于分配给区间 $[u,v]$ 的容差，则算法在该区间上终止并返回 $S_2$ 作为其值。否则，算法将递归地应用于子区间 $[u, w]$ 和 $[w, v]$，每个子区间的容差为原先的一半。\n\n考虑在区间 $[-1, 1]$ 上计算一个函数的积分。假设初始容差 $\\epsilon$ 是任意小的正数，下列哪个连续函数会使得该算法在第一次检查时就终止（即不进行任何递归）并返回一个不正确的值 0？\n\nA. $f(x) = 3x^2 - 1$\n\nB. $f(x) = \\sin(\\pi x)$\n\nC. $f(x) = \\cos\\left(\\frac{\\pi}{2} x\\right)$\n\nD. $f(x) = 16x^6 - 20x^4 + x^2 + 1$\n\nE. $f(x) = x^5 - x^3 + x$",
            "solution": "要使算法在第一次检查时对任意小的正容差 $\\epsilon$ 都终止，估计误差在初始区间上必须恰好为零。当 $[u,v]=[-1,1]$ 且 $w=0$ 时，两个辛普森近似值为\n$$\nS_{1}=\\frac{1}{3}\\left(f(-1)+4f(0)+f(1)\\right),\n$$\n$$\nS_{2}=\\frac{1}{6}\\left(f(-1)+4f\\left(-\\frac{1}{2}\\right)+f(0)\\right)+\\frac{1}{6}\\left(f(0)+4f\\left(\\frac{1}{2}\\right)+f(1)\\right)\n=\\frac{1}{6}\\left(f(-1)+f(1)+2f(0)+4f\\left(-\\frac{1}{2}\\right)+4f\\left(\\frac{1}{2}\\right)\\right).\n$$\n误差估计为\n$$\nE=\\frac{1}{15}|S_{2}-S_{1}|.\n$$\n为了对任意 $\\epsilon0$ 终止，我们需要 $E=0$，即 $S_{2}=S_{1}$。为了让算法返回不正确的值 0，我们还必须有 $S_{2}=0$，而真实积分 $\\int_{-1}^{1}f(x)\\,dx\\neq 0$。\n\n对每个选项计算 $S_{1}$ 和 $S_{2}$：\n\nA. $f(x)=3x^{2}-1$。计算 $f(-1)=2$，$f(0)=-1$，$f(1)=2$ 以及 $f\\left(\\pm\\frac{1}{2}\\right)=3\\cdot\\frac{1}{4}-1=-\\frac{1}{4}$。则\n$$\nS_{1}=\\frac{1}{3}(2+4(-1)+2)=0,\\quad\nS_{2}=\\frac{1}{6}\\left(2+2+2(-1)+4\\left(-\\frac{1}{4}\\right)+4\\left(-\\frac{1}{4}\\right)\\right)=0.\n$$\n此外，$\\int_{-1}^{1}(3x^{2}-1)\\,dx=\\left[x^{3}-x\\right]_{-1}^{1}=0$，所以返回 0 是正确的，不是不正确的。\n\nB. $f(x)=\\sin(\\pi x)$。计算 $f(-1)=0$，$f(0)=0$，$f(1)=0$，$f\\left(-\\frac{1}{2}\\right)=-1$，$f\\left(\\frac{1}{2}\\right)=1$。则\n$$\nS_{1}=0,\\quad S_{2}=\\frac{1}{6}\\left(0+0+0+4(-1)+4(1)\\right)=0,\n$$\n并且 $\\int_{-1}^{1}\\sin(\\pi x)\\,dx=0$（被积函数为奇函数），所以返回 0 是正确的。\n\nC. $f(x)=\\cos\\left(\\frac{\\pi}{2}x\\right)$。计算 $f(-1)=0$，$f(0)=1$，$f(1)=0$，$f\\left(\\pm\\frac{1}{2}\\right)=\\cos\\left(\\pm\\frac{\\pi}{4}\\right)=\\frac{\\sqrt{2}}{2}$。则\n$$\nS_{1}=\\frac{1}{3}(0+4\\cdot 1+0)=\\frac{4}{3},\\quad\nS_{2}=\\frac{1}{6}\\left(0+0+2\\cdot 1+4\\cdot\\frac{\\sqrt{2}}{2}+4\\cdot\\frac{\\sqrt{2}}{2}\\right)=\\frac{1}{6}\\left(2+4\\sqrt{2}\\right)=\\frac{1}{3}\\left(1+2\\sqrt{2}\\right)\\neq 0,\n$$\n所以算法不会返回 0。\n\nD. $f(x)=16x^{6}-20x^{4}+x^{2}+1$。计算 $f(-1)=-2$，$f(0)=1$，$f(1)=-2$ 以及 $f\\left(\\pm\\frac{1}{2}\\right)=16\\left(\\frac{1}{64}\\right)-20\\left(\\frac{1}{16}\\right)+\\frac{1}{4}+1=\\frac{1}{4}$。则\n$$\nS_{1}=\\frac{1}{3}(-2+4\\cdot 1-2)=0,\\quad\nS_{2}=\\frac{1}{6}\\left(-2-2+2\\cdot 1+4\\cdot\\frac{1}{4}+4\\cdot\\frac{1}{4}\\right)=\\frac{1}{6}(-4+2+1+1)=0.\n$$\n因此 $E=0$ 且算法立即终止，返回 0。真实的积分值为\n$$\n\\int_{-1}^{1}\\left(16x^{6}-20x^{4}+x^{2}+1\\right)dx\n=2\\int_{0}^{1}\\left(16x^{6}-20x^{4}+x^{2}+1\\right)dx\n=2\\left(\\frac{16}{7}-4+\\frac{1}{3}+1\\right)\n=2\\left(\\frac{16}{7}-\\frac{8}{3}\\right)\n=-\\frac{16}{21}\\neq 0,\n$$\n所以返回值 0 是不正确的。\n\nE. $f(x)=x^{5}-x^{3}+x$ 是奇函数，因此 $S_{1}=0$，$S_{2}=0$（根据节点和权重的对称性），并且 $\\int_{-1}^{1}f(x)\\,dx=0$，所以返回 0 是正确的。\n\n只有选项 D 满足要求：在 $E=0$ 时立即终止，返回 0，而真实的积分非零。",
            "answer": "$$\\boxed{D}$$"
        },
        {
            "introduction": "在认识到标准算法的局限性后，一个自然的问题是：我们如何使其变得更加稳健？本练习将我们带入计算问题求解的高级领域，展示了如何通过编程，将函数的已知难点（例如跳跃间断点）明确告知积分器。这是一种更“智能”的积分策略，它能在一个朴素算法可能失败的地方，确保我们得到准确可靠的结果。",
            "id": "2371893",
            "problem": "您需要编写一个完整的程序，对在指定点存在单个已知跳跃间断点的分段定义函数进行定积分的数值计算。每个被积函数由两个解析分支定义，分别对应 $x  x_0$ 和 $x  x_0$ 的区域。在间断点 $x_0$ 本身，函数值是未定义的，因此您的求解方法必须避免在该点进行函数求值。",
            "solution": "问题陈述已经过严格验证，被认为是科学上合理、适定、客观和自洽的。它提出了一个计算物理和数值分析中的标准任务：对具有有限跳跃间断点的函数进行定积分求值。\n\n完成此任务的基本定理是定积分的可加性。对于一个在区间 $[a, b]$ 上积分的函数 $f(x)$，以及任意点 $x_0 \\in (a, b)$，该积分可以分解为：\n$$\n\\int_a^b f(x) \\, dx = \\int_a^{x_0} f(x) \\, dx + \\int_{x_0}^b f(x) \\, dx\n$$\n问题指定了一个在 $x=x_0$ 处有跳跃间断点的分段函数 $f(x)$，定义如下：\n$$\nf(x) =\n\\begin{cases}\nf_{\\mathrm{L}}(x)  \\text{if } x  x_0 \\\\\nf_{\\mathrm{R}}(x)  \\text{if } x > x_0\n\\end{cases}\n$$\n$f(x_0)$ 的值未定义，这对于黎曼积分或勒贝格积分无关紧要，因为单一点的值不影响积分值。\n\n策略方法取决于间断点 $x_0$ 相对于积分区间 $[a, b]$ 的位置。\n\n1.  **内部间断点 ($a  x_0  b$)**：直接应用可加性。原积分被拆分为两个在被积函数连续的子区间上的独立积分：\n    $$\n    I = \\int_a^b f(x) \\, dx = \\int_a^{x_0} f_{\\mathrm{L}}(x) \\, dx + \\int_{x_0}^b f_{\\mathrm{R}}(x) \\, dx\n    $$\n    这些积分中的每一个，$I_L = \\int_a^{x_0} f_{\\mathrm{L}}(x) \\, dx$ 和 $I_R = \\int_{x_0}^b f_{\\mathrm{R}}(x) \\, dx$，现在都可以使用针对连续函数的标准求积方法进行数值计算。\n\n2.  **间断点在区间外部或边界上 ($x_0 \\le a$ 或 $x_0 \\ge b$)**：\n    *   如果 $x_0 \\ge b$，那么对于所有 $x \\in [a, b]$，条件 $x \\le x_0$ 成立（如果 $x_0 > b$，则为 $x  x_0$）。因此，在整个区间 $[a, b]$ 上，被积函数 $f(x)$ 与单个连续分支 $f_{\\mathrm{L}}(x)$ 完全相同。积分即为：\n        $$\n        I = \\int_a^b f_{\\mathrm{L}}(x) \\, dx\n        $$\n    *   如果 $x_0 \\le a$，那么对于所有 $x \\in [a, b]$，条件 $x \\ge x_0$ 成立（如果 $x_0  a$，则为 $x > x_0$）。被积函数 $f(x)$ 在 $[a, b]$ 上与连续分支 $f_{\\mathrm{R}}(x)$ 完全相同。积分即为：\n        $$\n        I = \\int_a^b f_{\\mathrm{R}}(x) \\, dx\n        $$\n\n对于数值计算，需要一个稳健的自适应求积算法来满足严格的误差容差（$\\varepsilon_{\\mathrm{abs}}$ 和 $\\varepsilon_{\\mathrm{rel}}$）。`scipy.integrate.quad` 函数是高度可靠的 FORTRAN 库 QUADPACK 的 Python 接口，是一个理想的选择。\n\n`quad` 的一个关键特性是其 `points` 参数。当提供一个已知难点（如间断点或奇点）的列表时，积分器会在这些点上划分区间。然后，它会分别计算每个子区间上的积分并对结果求和，同时管理总误差预算。这种方法正是在内部间断点情况 ($a  x_0  b$) 下所需要的。通过调用 `quad(f, a, b, points=[x_0], ...)`，我们指示算法计算 $\\int_a^{x_0} f(x) \\, dx + \\int_{x_0}^b f(x) \\, dx$。这能正确处理跳跃，并且重要的是，避免了在 $x_0$ 点本身进行任何函数求值，从而满足了问题的一个关键约束。\n\n总体算法如下：\n对于每个具有参数 $\\{f_{\\mathrm{L}}, f_{\\mathrm{R}}, [a, b], x_0, \\varepsilon_{\\mathrm{abs}}, \\varepsilon_{\\mathrm{rel}}\\}$ 的测试用例：\n1.  检查 $x_0$ 相对于 $[a, b]$ 的位置。\n2.  如果 $a  x_0  b$，定义一个单一的分段函数 `f(x)`，它根据情况返回 `fL(x)` 或 `fR(x)`。在 $[a, b]$ 上对 `f(x)` 调用 `scipy.integrate.quad`，并将 `x0` 传递给 `points` 参数。\n3.  如果 $x_0 \\le a$，函数在 $(a, b]$ 上连续且等于 $f_{\\mathrm{R}}(x)$。在 $[a, b]$ 上对 $f_{\\mathrm{R}}(x)$ 调用 `scipy.integrate.quad`。\n4.  如果 $x_0 \\ge b$，函数在 $[a, b)$ 上连续且等于 $f_{\\mathrm{L}}(x)$。在 $[a, b]$ 上对 $f_{\\mathrm{L}}(x)$ 调用 `scipy.integrate.quad`。\n5.  在所有对 `quad` 的调用中，通过 `epsabs` 和 `epsrel` 参数指定给定的容差 $\\varepsilon_{\\mathrm{abs}}$ 和 $\\varepsilon_{\\mathrm{rel}}$。\n6.  积分结果是 `quad` 返回的元组中的第一个元素。收集结果，格式化为 $12$ 位小数并打印。\n\n这种有原则的方法确保了正确性、准确性以及对所有问题约束的遵守。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Solves a series of definite integrals for piecewise functions with\n    a single jump discontinuity, adhering to specified error tolerances.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"id\": 1,\n            \"fL\": lambda x: np.exp(-x**2),\n            \"fR\": lambda x: np.exp(-x**2) + 1.5,\n            \"interval\": [-2.0, 2.0],\n            \"x0\": 0.25,\n            \"epsabs\": 1e-9,\n            \"epsrel\": 1e-9,\n        },\n        {\n            \"id\": 2,\n            \"fL\": lambda x: np.cos(x),\n            \"fR\": lambda x: np.cos(x) + 3.0,\n            \"interval\": [0.0, np.pi],\n            \"x0\": 0.0,\n            \"epsabs\": 1e-10,\n            \"epsrel\": 1e-10,\n        },\n        {\n            \"id\": 3,\n            \"fL\": lambda x: np.log(1 + x**2),\n            \"fR\": lambda x: np.log(1 + x**2) + 10.0,\n            \"interval\": [-1.0, 1.0],\n            \"x0\": 5.0,\n            \"epsabs\": 1e-10,\n            \"epsrel\": 1e-10,\n        },\n        {\n            \"id\": 4,\n            \"fL\": lambda x: np.sqrt(1 + x),\n            \"fR\": lambda x: np.sqrt(1 + x) - 0.75,\n            \"interval\": [-1.0, 1.0],\n            \"x0\": 0.3,\n            \"epsabs\": 1e-10,\n            \"epsrel\": 1e-10,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        fL = case[\"fL\"]\n        fR = case[\"fR\"]\n        a, b = case[\"interval\"]\n        x0 = case[\"x0\"]\n        epsabs = case[\"epsabs\"]\n        epsrel = case[\"epsrel\"]\n        \n        integral_val = 0.0\n\n        if a  x0  b:\n            # Case when the discontinuity is inside the integration interval.\n            # Define the full piecewise function. np.where handles vector inputs from quad.\n            def f(x):\n                return np.where(x  x0, fL(x), fR(x))\n            \n            # Use the 'points' argument to tell the integrator about the discontinuity.\n            # This ensures the interval is split at x0 and avoids evaluating f(x0).\n            integral_val, _ = quad(f, a, b, points=[x0], epsabs=epsabs, epsrel=epsrel)\n        elif x0 = a:\n            # Discontinuity is at or before the start of the interval.\n            # The integrand is fR(x) over the entire interval (a, b].\n            integral_val, _ = quad(fR, a, b, epsabs=epsabs, epsrel=epsrel)\n        else:  # x0 >= b\n            # Discontinuity is at or after the end of the interval.\n            # The integrand is fL(x) over the entire interval [a, b).\n            integral_val, _ = quad(fL, a, b, epsabs=epsabs, epsrel=epsrel)\n            \n        results.append(integral_val)\n\n    # Format the results to exactly 12 decimal places as required.\n    formatted_results = [f\"{res:.12f}\" for res in results]\n\n    # Print the final output in the specified format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}