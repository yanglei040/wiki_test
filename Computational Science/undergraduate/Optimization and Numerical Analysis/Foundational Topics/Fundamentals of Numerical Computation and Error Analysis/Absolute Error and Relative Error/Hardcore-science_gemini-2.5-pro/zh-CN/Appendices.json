{
    "hands_on_practices": [
        {
            "introduction": "理论知识需要通过实践来巩固。在数值分析中，我们经常使用近似方法来求解问题，因此量化这些近似的误差至关重要。本练习将通过一个具体实例——使用前向差分法逼近函数导数——来引导你计算相对误差，从而将理论定义与实际计算联系起来。",
            "id": "2152036",
            "problem": "一位数值分析师的任务是评估用于计算函数一阶导数的前向差分近似的准确性。所考虑的函数为 $f(x) = 2x^3 + x^2 - 4x + 1$。该分析师决定使用步长 $h = 0.2$ 来近似计算在特定点 $x_0 = 1$ 处的导数。\n\n前向差分近似公式为：\n$$\nf'_{\\text{approx}}(x_0) = \\frac{f(x_0+h) - f(x_0)}{h}\n$$\n该近似值将与通过解析微分求得的导数真实值 $f'_{\\text{true}}(x_0)$ 进行比较。\n\n计算此近似的相对误差。相对误差 $E_{\\text{rel}}$ 定义为近似值与真实值之差的绝对值除以真实值的绝对值。\n\n将最终答案保留三位有效数字。",
            "solution": "给定 $f(x)=2x^{3}+x^{2}-4x+1$，通过解析微分求得真实导数：\n$$\nf'(x)=6x^{2}+2x-4.\n$$\n在 $x_{0}=1$ 处，\n$$\nf'_{\\text{true}}(1)=6\\cdot 1^{2}+2\\cdot 1-4=4.\n$$\n使用步长 $h=0.2$ 的前向差分法，计算：\n$$\nf(1)=2\\cdot 1^{3}+1^{2}-4\\cdot 1+1=0,\n$$\n$$\nf(1.2)=2\\cdot (1.2)^{3}+(1.2)^{2}-4\\cdot 1.2+1=2\\cdot 1.728+1.44-4.8+1=3.456+1.44-4.8+1=1.096.\n$$\n因此，前向差分近似值为\n$$\nf'_{\\text{approx}}(1)=\\frac{f(1.2)-f(1)}{0.2}=\\frac{1.096-0}{0.2}=5.48.\n$$\n相对误差为\n$$\nE_{\\text{rel}}=\\frac{|f'_{\\text{approx}}(1)-f'_{\\text{true}}(1)|}{|f'_{\\text{true}}(1)|}=\\frac{|5.48-4|}{4}=\\frac{1.48}{4}=0.37.\n$$\n保留三位有效数字，结果为 $0.370$。",
            "answer": "$$\\boxed{0.370}$$"
        },
        {
            "introduction": "掌握了误差的计算方法后，我们还需要学会如何正确地解读它。当处理数量级差异巨大的数值时，绝对误差可能会产生误导。这个练习  提供了一个思想实验，挑战你判断在特定场景下，绝对误差和相对误差哪一个能更真实地反映算法的精度。",
            "id": "2198986",
            "problem": "在分析一个阻尼振荡系统时，得到其特征多项式为 $P(x) = x^2 - (10 + 10^{-6})x + 10^{-5} = 0$。该方程的两个精确根代表了系统的特征频率，它们分别是一个大根 $\\beta = 10$ 和一个非常小的根 $\\alpha = 10^{-6}$。\n\n使用两种不同的数值算法来寻找这些根的近似值。\n-   算法A用于近似小根 $\\alpha$，其返回值为 $\\tilde{\\alpha} = 2 \\times 10^{-6}$。\n-   算法B用于近似大根 $\\beta$，其返回值为 $\\tilde{\\beta} = 10.01$。\n\n基于这些结果，以下哪个陈述对这两种算法的准确性提供了最有意义的评估？\n\nA. 算法A更准确，因为其绝对误差显著小于算法B的绝对误差。\n\nB. 算法B更准确，因为其相对误差显著小于算法A的相对误差。\n\nC. 两种算法都表现出较差的准确性，因为两种近似都导致相对误差大于0.0001。\n\nD. 两种算法的准确性无法进行有意义的比较，因为它们近似的根在数量级上差异巨大。\n\nE. 两种算法具有相当的准确性，因为算法A的绝对误差与算法B的相对误差在同一数量级上。",
            "solution": "我们得到二次方程 $P(x) = x^{2} - (10 + 10^{-6})x + 10^{-5} = 0$，其精确根为 $\\alpha = 10^{-6}$ 和 $\\beta = 10$。数值近似值为 $\\tilde{\\alpha} = 2 \\times 10^{-6}$ 和 $\\tilde{\\beta} = 10.01$。\n\n为了评估准确性，我们计算每种算法的绝对误差和相对误差。对于小根：\n$$|\\tilde{\\alpha} - \\alpha| = |2 \\times 10^{-6} - 10^{-6}| = 10^{-6},$$\n$\\alpha$ 的相对误差为：\n$$ \\frac{|\\tilde{\\alpha} - \\alpha|}{|\\alpha|} = \\frac{10^{-6}}{10^{-6}} = 1.$$\n\n对于大根：\n$$|\\tilde{\\beta} - \\beta| = |10.01 - 10| = 0.01,$$\n$\\beta$ 的相对误差为：\n$$ \\frac{|\\tilde{\\beta} - \\beta|}{|\\beta|} = \\frac{0.01}{10} = 0.001.$$\n\n在比较数量级差异巨大的量的近似值时，相对误差是更有意义的度量标准。算法A的相对误差为 $1$，而算法B的相对误差为 $0.001$。因此，算法B更准确，因为其相对误差显著小于算法A的相对误差。\n\n评估选项：\n- A 是不正确的，因为它依赖于绝对误差，而绝对误差在不同尺度下进行比较是不合适的，并且实际上算法A的相对误差要差得多。\n- B 是正确的：由于相对误差小得多，算法B更准确。\n- C 不是最有意义的评估；尽管两个相对误差都超过了 $0.0001$，但在没有指定容差的情况下宣布两者都很差是武断的，并且忽略了它们在相对准确性上的巨大差异。\n- D 是不正确的；相对误差允许跨尺度的有意义比较。\n- E 是不正确的；$10^{-6}$ 和 $0.001$ 不在同一数量级上，并且混合使用绝对误差和相对误差进行比较是没有意义的。\n\n因此，最有意义的评估由B给出。",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "在数值计算中，一个看似无害的公式有时会隐藏着“灾难性抵消”的陷阱，导致计算结果的相对精度严重损失。本练习  以我们熟知的二次方程求根公式为例，揭示了这种数值不稳定性。你将亲手诊断问题所在，并利用韦达定理推导和实现一个数值稳定的替代算法，从而深刻理解保证计算结果可靠性的重要性。",
            "id": "2370392",
            "problem": "一个具有实系数的首一二次方程的形式为 $a x^2 + b x + c = 0$ 且 $a \\neq 0$。当判别式 $D = b^2 - 4ac \\ge 0$ 时，方程存在精确的实数根。在浮点（FP）运算中，当 $b^2 \\gg 4ac$ 时，直接计算求根公式可能会遭受灾难性抵消，因为其中一个根是通过两个几乎相等的数相减得到的。本问题要求您量化那个易于发生抵消的根的绝对误差和相对误差，并通过从第一性原理推导出的代数等价重构形式来减轻该误差。\n\n您可以使用的基本原理：\n- 二次方程的韦达定理：如果 $r_1$ 和 $r_2$ 是精确根，则 $r_1 + r_2 = -\\dfrac{b}{a}$ 且 $r_1 r_2 = \\dfrac{c}{a}$。\n- 在实数运算中，当 $D \\ge 0$ 时，表示精确根的二次求根公式。\n- 绝对误差和相对误差的定义。对于一个非零精确值 $x$ 的近似值 $\\tilde{x}$，绝对误差为 $|\\tilde{x} - x|$，相对误差为 $\\dfrac{|\\tilde{x} - x|}{|x|}$。如果 $x = 0$，则定义相对误差为绝对误差。\n\n您的任务：\n1. 对下方的每个测试用例，通过在标准双精度下直接应用二次求根公式（即，以最直接的方式计算 $\\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}$）来计算两个根的浮点近似值。按如下方式确定易于发生抵消的根：如果 $b > 0$，则易于发生抵消的根是使用 $+$ 号计算的；如果 $b  0$，则它是使用 $-$ 号计算的。这种确定方法反映了当 $b^2 \\gg 4ac$ 时，哪个公式会减去两个几乎相等的量。\n2. 严格从韦达定理和基础代数出发，为易于发生抵消的根推导出一个避免两相近数相减的数值稳定重构形式，并予以实现。您的实现不得依赖任何“给定”的稳定化公式，必须遵循您的推导。但是，您可以用推导中隐含的任何稳定方式计算另一个根，然后使用 $r_1 r_2 = \\dfrac{c}{a}$ 来恢复易于发生抵消的根。\n3. 为了获得基准真相（ground truth），使用至少80位十进制精度的实数运算来计算精确根的高精度近似值，然后转换为双精度值以进行比较。对于每个测试用例，选择与易于发生抵消的根相对应的那个精确根（即当 $b^2 \\gg 4ac$ 时量级较小的那个根），并计算其对于朴素计算（任务1）和您的稳定重构（任务2）的绝对误差和相对误差。\n4. 您的程序必须将所有测试用例的结果汇总到一个单一的浮点数扁平列表中，每个测试用例的顺序为：$[\\text{绝对误差\\_朴素}, \\text{相对误差\\_朴素}, \\text{绝对误差\\_稳定}, \\text{相对误差\\_稳定}]$，并按照下面列出的测试用例顺序进行拼接。\n\n测试套件（每个三元组为 $(a,b,c)$）：\n- 用例1：$(a,b,c) = (\\,1\\,,\\,10^8\\,,\\,1\\,)$。\n- 用例2：$(a,b,c) = (\\,1\\,,\\,-10^8\\,,\\,1\\,)$。\n- 用例3：$(a,b,c) = (\\,1\\,,\\,3\\,,\\,10^{-3}\\,)$。\n- 用例4：$(a,b,c) = (\\,10^{-3}\\,,\\,10^5\\,,\\,10^{-3}\\,)$。\n\n数值与输出要求：\n- 如果出现任何角度计算，请使用弧度，尽管这里预计不会有。\n- 不涉及物理单位。\n- 所有输出必须是原始数字；不要使用百分号。相对误差必须是一个纯数（例如，对于千分之一，输出 $0.001$）。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[r_1,r_2,\\dots]$）。最终列表必须精确包含 $\\;16\\;$ 个浮点数，对应 $\\;4\\;$ 个测试用例中每个用例的 $\\;4\\;$ 个值，顺序与测试套件中的顺序相同。",
            "solution": "所提出的问题是数值分析中的一个经典练习，涉及使用浮点运算求解二次方程 $a x^2 + b x + c = 0$ 时的精度损失问题。对问题有效性的分析证实了其科学性、适定性和客观性。我们将以严谨的方式进行求解。\n\n标准的二次求根公式给出了两个精确根 $r_1$ 和 $r_2$：\n$$\nr_{1,2} = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}\n$$\n问题关注 $b^2 \\gg 4ac$ 的情况。在这种情况下，判别式 $D = b^2 - 4ac$ 由 $b^2$ 项主导。因此，平方根 $\\sqrt{b^2 - 4ac}$ 可以通过泰勒级数展开来近似：\n$$\n\\sqrt{b^2 - 4ac} = |b| \\sqrt{1 - \\frac{4ac}{b^2}} \\approx |b| \\left(1 - \\frac{2ac}{b^2}\\right) = |b| - \\frac{2ac}{|b|}\n$$\n这个近似表明 $\\sqrt{b^2 - 4ac}$ 是一个非常接近 $|b|$ 的量。\n\n这种相近性是数值不稳定性的根源。这种现象被称为灾难性抵消。\n\\begin{itemize}\n    \\item 如果 $b > 0$，其中一个根的分子是 $-b + \\sqrt{b^2-4ac}$。由于 $\\sqrt{b^2-4ac} \\approx b$，该表达式涉及两个几乎相等的数相减。此操作会导致计算结果的相对精度显著损失。受影响的根是 $r_1 = \\frac{-b + \\sqrt{b^2-4ac}}{2a}$。\n    \\item 如果 $b  0$，那么 $-b$ 是一个正数。项 $\\sqrt{b^2-4ac} \\approx \\sqrt{b^2} = |b| = -b$。其中一个根的分子变为 $-b - \\sqrt{b^2-4ac}$，这同样是两个几乎相等的正数相减（例如，如果 $b=-10^8$，那么 $-b=10^8$ 且 $\\sqrt{D} \\approx 10^8$）。这会影响根 $r_2 = \\frac{-b - \\sqrt{b^2-4ac}}{2a}$。\n\\end{itemize}\n在这两种情况下，量级较小的根更容易受到这种灾难性抵消的影响。另一个根涉及同号项的相加（如果 $b>0$ 则为 $-b$ 和 $-\\sqrt{D}$，如果 $b0$ 则为 $-b$ 和 $+\\sqrt{D}$），因此可以稳定地计算。\n\n为了减轻这种数值误差，我们必须推导一个替代公式。问题要求此推导从第一性原理开始，特别是韦达定理。策略是首先精确计算“稳定”的根，然后用它来找到“不稳定”（易于抵消）的根。\n\n设 $r_{\\text{stable}}$ 是不经过减法抵消计算的根。它可以用符号函数 $\\text{sgn}(b)$ 以统一的方式表示：\n$$\nr_{\\text{stable}} = \\frac{-b - \\text{sgn}(b)\\sqrt{b^2-4ac}}{2a}\n$$\n这个公式确保了分子中的两项，$-b$ 和 $-\\text{sgn}(b)\\sqrt{D}$，具有相同的符号，它们的和可以被稳健地计算。对于 $b^2 \\gg 4ac$ 的非平凡情况，$b$ 非零，因此 $\\text{sgn}(b)$ 为 $1$ 或 $-1$。\n\n在获得 $r_{\\text{stable}}$ 的精确值后，我们使用韦达定理的根之积公式 $r_1 r_2 = c/a$。如果 $r_{\\text{prone}}$ 是另一个根（易于抵消的那个），那么：\n$$\nr_{\\text{prone}} \\cdot r_{\\text{stable}} = \\frac{c}{a}\n$$\n由此，我们可以解出 $r_{\\text{prone}}$：\n$$\nr_{\\text{prone}} = \\frac{c/a}{r_{\\text{stable}}} = \\frac{c}{a \\cdot r_{\\text{stable}}}\n$$\n这个 $r_{\\text{prone}}$ 的表达式只涉及除法和乘法，这些在此上下文中是数值稳定的运算，从而避免了朴素公式中固有的灾难性抵消。\n\n解决该问题的计算步骤如下：\n\\begin{enumerate}\n    \\item 对于每个测试用例 $(a, b, c)$，我们首先为易于抵消的根建立一个基准真相值。这是通过使用标准的二次求根公式，但采用高精度算术（至少80个十进制数字，使用Python的 `decimal` 模块）来计算根来实现的。与相近数相减相对应的根被确定为精确值 $x_{\\text{exact}}$，并转换为标准的双精度浮点数。\n\n    \\item 我们使用标准的双精度浮点运算，通过直接的二次求根公式计算易于抵消的根 $\\tilde{x}_{\\text{naive}}$。\n\n    \\item 我们使用推导出的稳定方法计算易于抵消的根 $\\tilde{x}_{\\text{stable}}$。首先，计算稳定的根 $\\tilde{r}_{\\text{stable}}$。然后，通过 $\\tilde{x}_{\\text{stable}} = (c/a) / \\tilde{r}_{\\text{stable}}$ 求得易于抵消的根。\n\n    \\item 对于朴素方法和稳定方法，我们都计算绝对误差 $|\\tilde{x} - x_{\\text{exact}}|$ 和相对误差 $|\\tilde{x} - x_{\\text{exact}}| / |x_{\\text{exact}}|$。如果 $x_{\\text{exact}}=0$，则相对误差取为绝对误差。\n\\end{enumerate}\n然后为每个测试用例收集这四个误差度量，并汇总到一个单一列表中作为最终输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom decimal import Decimal, getcontext\n\ndef solve():\n    \"\"\"\n    Solves for the roots of a quadratic equation using naive and stable methods,\n    and calculates the absolute and relative errors for the cancellation-prone root.\n    \"\"\"\n    # Set the precision for the decimal module to 85, which is more than the required 80 digits,\n    # to ensure accuracy of the ground truth calculations.\n    getcontext().prec = 85\n\n    # Define the test cases from the problem statement. Each tuple is (a, b, c).\n    test_cases = [\n        (1.0, 1e8, 1.0),\n        (1.0, -1e8, 1.0),\n        (1.0, 3.0, 1e-3),\n        (1e-3, 1e5, 1e-3),\n    ]\n\n    all_results = []\n    for a, b, c in test_cases:\n        # Use standard double-precision floats for coefficients in FP calculations\n        a_fp, b_fp, c_fp = float(a), float(b), float(c)\n\n        # Task 3: Ground truth using high-precision arithmetic\n        a_d, b_d, c_d = Decimal(a), Decimal(b), Decimal(c)\n        discriminant_d = (b_d**2 - 4 * a_d * c_d).sqrt()\n\n        # Identify the exact cancellation-prone root based on the sign of b.\n        # This is the root with the smaller magnitude.\n        if b_fp > 0:\n            # The root from (-b + sqrt(D)) suffers cancellation\n            x_exact_d = (-b_d + discriminant_d) / (2 * a_d)\n        else: # b  0 or b = 0\n            # The root from (-b - sqrt(D)) suffers cancellation\n            x_exact_d = (-b_d - discriminant_d) / (2 * a_d)\n        \n        # Cast the high-precision ground truth to a standard float for comparison\n        x_exact = float(x_exact_d)\n\n        # Task 1: Naive evaluation using the standard quadratic formula in double precision\n        discriminant_fp = np.sqrt(b_fp**2 - 4 * a_fp * c_fp)\n        \n        # Identify the cancellation-prone root from the naive calculation\n        if b_fp > 0:\n            x_naive_prone = (-b_fp + discriminant_fp) / (2 * a_fp)\n        else:\n            x_naive_prone = (-b_fp - discriminant_fp) / (2 * a_fp)\n\n        # Task 2: Stable reformulation derived from first principles\n        # First, compute the stable root (the one without subtractive cancellation)\n        # np.copysign is robust and correctly applies the sign of b.\n        # It's equivalent to sgn(b) for b!=0.\n        stable_root = (-b_fp - np.copysign(1.0, b_fp) * discriminant_fp) / (2 * a_fp)\n        \n        # Then, use Vieta's formula (r1 * r2 = c/a) to find the cancellation-prone root.\n        # This avoids the subtraction of nearly equal numbers.\n        if stable_root == 0:\n            # Handle the unlikely case of the stable root being exactly zero\n            # This would imply c=0, in which case the prone root is also 0.\n            x_stable_prone = 0.0\n        else:\n            x_stable_prone = (c_fp / a_fp) / stable_root\n\n        # Task 4: Compute absolute and relative errors for both methods\n        # Naive method errors\n        abs_err_naive = abs(x_naive_prone - x_exact)\n        # Per problem spec, if x_exact is 0, relative error is absolute error\n        if x_exact != 0:\n            rel_err_naive = abs_err_naive / abs(x_exact)\n        else:\n            rel_err_naive = abs_err_naive\n        \n        # Stable method errors\n        abs_err_stable = abs(x_stable_prone - x_exact)\n        if x_exact != 0:\n            rel_err_stable = abs_err_stable / abs(x_exact)\n        else:\n            rel_err_stable = abs_err_stable\n\n        # Aggregate the results for this test case\n        all_results.extend([abs_err_naive, rel_err_naive, abs_err_stable, rel_err_stable])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.17e}' for r in all_results)}]\")\n\nsolve()\n```"
        }
    ]
}