{
    "hands_on_practices": [
        {
            "introduction": "掌握任何算法的最佳方式都是通过手动执行来加深理解。这个练习将引导你逐步完成霍纳方法计算多项式值的每一步，从而将抽象的递推关系具体化。通过追踪中间值的变化()，你将对该方法的核心机制建立起一个坚实而直观的认识。",
            "id": "2177814",
            "problem": "一个$n$次多项式的一般形式为 $P(x) = \\sum_{i=0}^{n} a_i x^i = a_n x^n + a_{n-1} x^{n-1} + \\dots + a_1 x + a_0$。一种用于计算该多项式在特定点 $x=c$ 处的值的计算高效方法，是生成一个中间值序列，该方法通常被称为霍纳（Horner）方法。这个记为 $y_0, y_1, \\dots, y_n$ 的序列是通过以下递推关系构建的：\n- $y_0 = a_n$\n- $y_k = y_{k-1} \\cdot c + a_{n-k}$，其中 $k = 1, 2, \\dots, n$。\n\n该序列的最后一项 $y_n$ 是多项式在 $c$ 处的值，即 $y_n = P(c)$。\n\n对于多项式 $P(x) = 4x^3 - 2x^2 + 5x - 1$，请确定在点 $x=2$ 处计算 $P(x)$ 时，通过此方法生成的完整值序列 $(y_0, y_1, y_2, y_3)$。",
            "solution": "给定多项式 $P(x) = 4x^{3} - 2x^{2} + 5x - 1$，其次数为 $n=3$。因此，系数为 $a_{3} = 4$, $a_{2} = -2$, $a_{1} = 5$ 和 $a_{0} = -1$。我们使用霍纳（Horner）递推公式在 $c=2$ 处求值：\n$$\ny_{0} = a_{3} = 4,\n$$\n并且对于 $k=1,2,3$，\n$$\ny_{k} = y_{k-1}\\cdot c + a_{3-k}.\n$$\n\n分步计算如下：\n$$\ny_{1} = y_{0}\\cdot 2 + a_{2} = 4\\cdot 2 + (-2) = 8 - 2 = 6,\n$$\n$$\ny_{2} = y_{1}\\cdot 2 + a_{1} = 6\\cdot 2 + 5 = 12 + 5 = 17,\n$$\n$$\ny_{3} = y_{2}\\cdot 2 + a_{0} = 17\\cdot 2 + (-1) = 34 - 1 = 33.\n$$\n\n因此，该序列为 $(y_{0}, y_{1}, y_{2}, y_{3}) = (4, 6, 17, 33)$，且 $y_{3} = P(2) = 33$。",
            "answer": "$$\\boxed{\\begin{pmatrix} 4  6  17  33 \\end{pmatrix}}$$"
        },
        {
            "introduction": "理论上的完美算法在实际计算机上运行时会面临有限精度算术的挑战，这可能导致意想不到的误差。这个练习模拟了在有限精度环境下使用霍纳方法的情景，揭示了其在处理特定类型的多项式时可能出现的“灾难性相消”问题()。完成这个练习对于培养对数值稳定性的敏锐洞察力至关重要，这是连接理论与实践的关键一步。",
            "id": "2177809",
            "problem": "在数值分析中，算法的选择会极大地影响结果的精度，尤其是在有限精度算术中。考虑求值由下式给出的多项式 $P(x)$：\n$$P(x) = a_4 x^4 + a_3 x^3 + a_2 x^2 + a_1 x + a_0$$\n其中系数为：\n$a_4 = 1.000000$\n$a_3 = -4.001000$\n$a_2 = 6.001500$\n$a_1 = -4.003000$\n$a_0 = 1.001001$\n\n你的任务是使用霍纳方法计算该多项式在点 $x = 1.000150$ 处的值。你必须在一台具有7位有效数字精度的浮点算术系统的机器上模拟此计算。具体来说，在每次基本算术运算（加法、减法和乘法）之后，你必须将中间结果舍入到7位有效数字，然后再用于下一次运算。\n\n遵循此过程计算 $P(1.000150)$ 的值。将你的最终答案表示为一个舍入到四位有效数字的数。",
            "solution": "我们通过霍纳方法计算 $P(x)$ 在 $x=1.000150$ 处的值，并在每次基本运算后舍入到7位有效数字：\n$$P(x)=((((a_{4}x)+a_{3})x+a_{2})x+a_{1})x+a_{0}.$$\n\n已知 $a_{4}=1.000000$，$a_{3}=-4.001000$，$a_{2}=6.001500$，$a_{1}=-4.003000$，$a_{0}=1.001001$ 及 $x=1.000150$。\n\n从 $b_{4}=a_{4}=1.000000$ 开始。\n\n1) 乘法并舍入：\n$$t_{1}=\\operatorname{round}_{7}(b_{4}x)=\\operatorname{round}_{7}(1.000000\\cdot 1.000150)=1.000150.$$\n\n2) 加法并舍入：\n$$b_{3}=\\operatorname{round}_{7}(t_{1}+a_{3})=\\operatorname{round}_{7}(1.000150-4.001000)=-3.000850.$$\n\n3) 乘法并舍入：\n$$t_{2}=\\operatorname{round}_{7}(b_{3}x)=\\operatorname{round}_{7}((-3.000850)\\cdot 1.000150)=\\operatorname{round}_{7}(-3.0013001275)=-3.001300.$$\n\n4) 加法并舍入：\n$$b_{2}=\\operatorname{round}_{7}(t_{2}+a_{2})=\\operatorname{round}_{7}((-3.001300)+6.001500)=3.000200.$$\n\n5) 乘法并舍入：\n$$t_{3}=\\operatorname{round}_{7}(b_{2}x)=\\operatorname{round}_{7}(3.000200\\cdot 1.000150)=\\operatorname{round}_{7}(3.00065003)=3.000650.$$\n\n6) 加法并舍入：\n$$b_{1}=\\operatorname{round}_{7}(t_{3}+a_{1})=\\operatorname{round}_{7}(3.000650-4.003000)=-1.002350.$$\n\n7) 乘法并舍入：\n$$t_{4}=\\operatorname{round}_{7}(b_{1}x)=\\operatorname{round}_{7}((-1.002350)\\cdot 1.000150)=\\operatorname{round}_{7}(-1.0025003525)=-1.002500.$$\n\n8) 加法并舍入：\n$$b_{0}=\\operatorname{round}_{7}(t_{4}+a_{0})=\\operatorname{round}_{7}((-1.002500)+1.001001)=-0.001499000.$$\n\n因此，在指定的每次运算后舍入的步骤下，$P(1.000150)=-0.001499000$。将此结果舍入到四位有效数字得到 $-0.001499$。",
            "answer": "$$\\boxed{-0.001499}$$"
        },
        {
            "introduction": "虽然霍纳方法在单核处理器上非常高效，但它的串行特性在多核处理器日益普及的今天也成为其局限。这个练习将引导你跳出传统串行计算的框架，探索一种“分治”并行算法来评估多项式()。通过理论上比较这两种方法在理想并行环境下的计算效率，你将学会如何从并行计算的角度分析和设计算法，并理解不同计算模型之间的性能权衡。",
            "id": "2177838",
            "problem": "在数值分析中，求多项式 $P(x) = \\sum_{i=0}^{N} a_i x^i$ 的值是一项基本运算。虽然霍纳法 (Horner's method) 提供了一种高效的串行算法，但其结构难以并行化。我们考虑一种用于在现代多核处理器上求值的替代方法。\n\n设 $P(x)$ 是一个具有 $n$ 个系数 $\\{a_0, a_1, \\dots, a_{n-1}\\}$ 的多项式，使得 $P(x) = \\sum_{i=0}^{n-1} a_i x^i$。对于本问题，假设 $n$ 是 2 的幂，即 $n = 2^m$，其中 $m$ 为某个正整数且 $m \\ge 1$。\n\n我们将基于一个简化的计算模型来比较两种计算 $P(x)$ 的方法，在该模型中，单次浮点乘法和单次浮点加法均消耗一个“计算步骤”。\n\n1.  **霍纳法 (Horner's Method)**：这种标准的串行方法将多项式计算为 $P(x) = a_0 + x(a_1 + x(a_2 + \\dots + x(a_{n-1}))\\dots)$。由于它是串行的，总计算步骤数 $T_{Horner}$ 是在单个核心上执行的所有运算的总和。\n\n2.  **递归并行分裂 (Recursive Parallel Splitting, RPS)**：这种分治算法的工作原理如下。多项式根据偶数和奇数索引的系数进行分裂：\n    $P(x) = \\left(\\sum_{k=0}^{n/2-1} a_{2k} x^{2k}\\right) + \\left(\\sum_{k=0}^{n/2-1} a_{2k+1} x^{2k+1}\\right)$\n    这可以重写为：\n    $P(x) = P_{even}(x^2) + x \\cdot P_{odd}(x^2)$，\n    其中 $P_{even}(y) = \\sum_{k=0}^{n/2-1} a_{2k} y^k$ 且 $P_{odd}(y) = \\sum_{k=0}^{n/2-1} a_{2k+1} y^k$。\n    $P_{even}$ 和 $P_{odd}$ 都是具有 $n/2$ 个系数的多项式。RPS 方法在不同的处理器核心上递归地并行计算 $P_{even}(x^2)$ 和 $P_{odd}(x^2)$。我们假设一个理想的并行环境，其中有足够数量的核心来利用每个递归步骤中的所有并行性，并且核心之间的通信开销为零。RPS 方法的总时间 $T_{RPS}$ 是最长相关运算链中的步骤数。\n\n确定比率 $\\mathcal{R}(n) = \\frac{T_{RPS}}{T_{Horner}}$，并将其表示为系数数量 $n$ 的函数。",
            "solution": "问题要求计算递归并行分裂 (RPS) 方法与霍纳法在计算一个具有 $n$ 项的多项式时所需计算时间的比率，其中 $n=2^m$ 且 $m \\ge 1$。一个计算步骤被定义为一次加法或一次乘法。\n\n**步骤 1：分析霍纳法**\n\n霍纳法使用嵌套形式计算一个 $n-1$ 次多项式 $P(x) = \\sum_{i=0}^{n-1} a_i x^i$：\n$P(x) = ((\\dots(a_{n-1}x + a_{n-2})x + \\dots + a_1)x + a_0)$。\n\n我们来计算运算次数。从最内层的括号开始，有一次乘法 ($a_{n-1}x$) 和一次加法 ($+ a_{n-2}$)。对于从 $a_{n-2}$ 到 $a_0$ 的每个系数，这个过程都会重复。\n- 为了计算 $a_{n-1}x + a_{n-2}$，我们执行 1 次乘法和 1 次加法。\n- 为了将结果乘以 $x$ 并加上 $a_{n-3}$，我们再执行 1 次乘法和 1 次加法。\n- 这个过程一直持续到最后加上 $a_0$。\n\n对于一个有 $n$ 个系数 ($a_0, \\dots, a_{n-1}$) 的多项式，共有 $n-1$ 个这样的阶段。因此，总共有 $n-1$ 次乘法和 $n-1$ 次加法。\n由于霍纳法本质上是串行的，总计算步骤数是所有运算的总和。\n$T_{Horner}(n) = (n-1) \\text{ 次乘法} + (n-1) \\text{ 次加法} = 2(n-1)$ 个步骤。\n\n**步骤 2：分析递归并行分裂 (RPS) 方法**\n\nRPS 方法基于递推关系 $P(x) = P_{even}(x^2) + x \\cdot P_{odd}(x^2)$。\n设 $T_{RPS}(n)$ 是计算一个具有 $n$ 个系数的多项式所需的并行计算步骤数。\n\n计算过程如下：\n1.  计算 $y = x^2$ 的值。这需要 1 次乘法。这一步是为子问题提供参数所必需的。\n2.  递归地计算 $P_{even}(y)$ 和 $P_{odd}(y)$。由于处理器有足够的核心，这两个计算可以并行进行。$P_{even}$ 和 $P_{odd}$ 都是具有 $n/2$ 个系数的多项式。此阶段所花费的时间是计算其中一个所需的时间，即 $T_{RPS}(n/2)$。\n3.  合并结果。一旦获得 $V_{even} = P_{even}(y)$ 和 $V_{odd} = P_{odd}(y)$ 的值，我们必须计算 $P(x) = V_{even} + x \\cdot V_{odd}$。这涉及一次乘法 ($x \\cdot V_{odd}$) 和随后的一次加法。这些是串行操作，因此需要 $1 + 1 = 2$ 个步骤。\n\n这三个阶段中的运算是相互依赖的。计算 $y=x^2$ 必须在递归调用开始之前完成。递归调用必须在最终合并开始之前完成。因此，总时间是每个阶段时间的总和。\n这给出了 $T_{RPS}(n)$ 的递推关系：\n$T_{RPS}(n) = (\\text{计算 } x^2 \\text{ 的时间}) + (\\text{子问题的时间}) + (\\text{合并的时间})$\n$T_{RPS}(n) = 1 + T_{RPS}(n/2) + 2 = T_{RPS}(n/2) + 3$。\n\n这个递推关系在 $n > 2$ 时有效。我们需要确定一个基本情况。\n我们考虑递归的最小可能 $n$ 值，即 $n=2$ (因为 $m \\ge 1$）。\n对于 $n=2$，多项式为 $P(x) = a_0 + a_1x$。\nRPS 方法会将其分裂为 $P_{even}(y) = a_0$ 和 $P_{odd}(y) = a_1$。这些是系数个数 $n=1$ 的多项式。\n计算一个 1-系数多项式 $P(x) = a_0$ 的时间为 $T_{RPS}(1) = 0$，因为不需要任何运算。\n所以对于 $n=2$，“递归”步骤耗时 $T_{RPS}(1)=0$。合并步骤是 $P(x) = P_{even} + x \\cdot P_{odd} = a_0 + x \\cdot a_1$。这需要一次乘法和一次加法，耗时 2 个步骤。注意，对于这个基本情况，不需要计算 $y=x^2$，因为子问题是常数。\n所以，我们递推关系的基本情况是 $T_{RPS}(2) = 2$。\n\n现在我们求解递推关系 $T_{RPS}(n) = T_{RPS}(n/2) + 3$ (其中 $n = 2^m$ 且 $m > 1$)，并使用基本情况 $T_{RPS}(2) = 2$。\n设 $n = 2^m$。对于 $m > 1$，递推关系变为 $T_{RPS}(2^m) = T_{RPS}(2^{m-1}) + 3$。\n我们可以展开这个递推关系：\n$T_{RPS}(2^m) = T_{RPS}(2^{m-1}) + 3$\n$= (T_{RPS}(2^{m-2}) + 3) + 3 = T_{RPS}(2^{m-2}) + 2 \\cdot 3$\n$= \\dots$\n$= T_{RPS}(2^1) + (m-1) \\cdot 3$\n\n代入基本情况 $T_{RPS}(2^1) = T_{RPS}(2) = 2$：\n$T_{RPS}(2^m) = 2 + 3(m-1) = 2 + 3m - 3 = 3m - 1$。\n\n因为 $n = 2^m$，所以我们有 $m = \\log_2(n)$。将其代回，得到 $T_{RPS}(n)$ 的闭式解：\n$T_{RPS}(n) = 3\\log_2(n) - 1$。\n该公式对 $m \\ge 1$ (即 $n \\ge 2$) 均有效。\n我们来验证 $m=1$ ($n=2$) 的情况：$T_{RPS}(2) = 3\\log_2(2) - 1 = 3(1) - 1 = 2$。这与我们的基本情况相符。\n\n**步骤 3：计算比率**\n\n我们得到了两种方法的计算步骤表达式：\n- $T_{Horner}(n) = 2(n-1)$\n- $T_{RPS}(n) = 3\\log_2(n) - 1$\n\n所求比率 $\\mathcal{R}(n)$ 为：\n$\\mathcal{R}(n) = \\frac{T_{RPS}(n)}{T_{Horner}(n)} = \\frac{3\\log_2(n) - 1}{2(n-1)}$。",
            "answer": "$$\\boxed{\\frac{3\\log_{2}(n) - 1}{2(n-1)}}$$"
        }
    ]
}