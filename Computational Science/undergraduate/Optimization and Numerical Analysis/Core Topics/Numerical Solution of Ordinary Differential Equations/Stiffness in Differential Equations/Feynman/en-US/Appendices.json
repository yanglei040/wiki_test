{
    "hands_on_practices": [
        {
            "introduction": "The first step in tackling a challenging numerical problem is often learning to recognize its signature symptoms. This practice presents a common scenario where an adaptive explicit solver exhibits a disproportionate increase in computational effort for a modest increase in accuracy requirements. By analyzing the expected scaling of step count with tolerance versus the observed behavior, this exercise hones your ability to diagnose numerical stiffness from solver output alone, a crucial skill for any computational scientist or engineer. ",
            "id": "2206398",
            "problem": "An undergraduate student is tasked with numerically solving a system of first-order Ordinary Differential Equations (ODEs) that models the concentration of two interacting chemical species over a time interval from $t=0$ to $t=T$. The student uses a standard adaptive explicit Runge-Kutta method of order $p=4$. The solver adjusts its step size, $h$, to keep the estimated local error below a user-specified tolerance, $\\epsilon$.\n\nThe student performs two simulations:\n\n1.  **Run 1:** With a tolerance of $\\epsilon_1 = 10^{-5}$, the solver successfully integrates the system to $t=T$, requiring a total of $N_1 = 5,200$ steps.\n2.  **Run 2:** The student refines the tolerance to $\\epsilon_2 = 10^{-6}$ and runs the simulation again over the same interval. This time, the solver requires a total of $N_2 = 985,000$ steps to reach $t=T$.\n\nThe student is surprised by the dramatic increase in the number of steps, which is far greater than the modest change in tolerance would suggest for a well-behaved problem. Without performing a formal analysis of the system's Jacobian matrix, which of the following is the most likely explanation for the observed behavior?\n\nA. The solution to the ODE system is highly oscillatory, causing the solver to require smaller steps to resolve the oscillations.\n\nB. The ODE system is numerically stiff.\n\nC. The order of the numerical method ($p=4$) is too low for this class of problem.\n\nD. A bug exists in the solver's time-stepping algorithm, causing it to malfunction at lower tolerances.\n\nE. The solution to the ODE system possesses a singularity within the integration interval $[0, T]$.",
            "solution": "We consider an adaptive explicit Runge–Kutta method of order $p=4$ with a local error control tolerance $\\epsilon$. For an order-$p$ method, the local truncation error per step satisfies\n$$\n\\mathrm{LTE} \\approx C h^{p+1},\n$$\nfor some problem-dependent constant $C$. To keep the estimated local error below $\\epsilon$, the step size is adjusted so that\n$$\nC h^{p+1} \\approx \\epsilon \\quad \\Longrightarrow \\quad h_{\\mathrm{acc}} \\propto \\epsilon^{\\frac{1}{p+1}}.\n$$\nOver a fixed interval of length $T$, the number of steps is therefore\n$$\nN \\approx \\frac{T}{h_{\\mathrm{acc}}} \\propto \\epsilon^{-\\frac{1}{p+1}}.\n$$\nWith $p=4$, this predicts the scaling\n$$\n\\frac{N_{2}}{N_{1}} \\approx \\left(\\frac{\\epsilon_{2}}{\\epsilon_{1}}\\right)^{-\\frac{1}{5}} = \\left(\\frac{\\epsilon_{1}}{\\epsilon_{2}}\\right)^{\\frac{1}{5}}.\n$$\nSince $\\epsilon_{2} = \\epsilon_{1}/10$, the expected factor is $10^{\\frac{1}{5}}$, i.e., a modest increase. However, the observed ratio $N_{2}/N_{1}$ is far larger than $10^{\\frac{1}{5}}$, indicating that the step size is not primarily limited by accuracy.\n\nFor explicit Runge–Kutta methods applied to stiff systems, stability constraints dominate the step size selection. Specifically, stability of the method requires\n$$\nh \\lesssim h_{\\mathrm{stab}} \\approx \\frac{\\kappa}{|\\lambda_{\\max}|},\n$$\nwhere $\\lambda_{\\max}$ is an eigenvalue of the Jacobian with the largest magnitude (typically with negative real part for dissipative stiff modes), and $\\kappa$ is a method-dependent constant determined by the stability region. In this regime, the step size is constrained by stability rather than by the accuracy tolerance, and tightening $\\epsilon$ can produce behavior such as:\n- order reduction, so that the effective accuracy order drops and the controller drastically reduces $h$;\n- excessive step rejections and very small accepted steps to damp stiff modes;\n- dominance of fast decaying modes in the error estimate, which forces $h$ well below $h_{\\mathrm{stab}}$ to meet the tighter tolerance.\n\nThese effects together can produce a dramatic increase in the number of steps far beyond the $10^{\\frac{1}{5}}$ factor predicted for nonstiff, accuracy-limited integration.\n\nBy contrast:\n- Highly oscillatory but nonstiff dynamics would impose a resolution limit that is largely independent of $\\epsilon$, so a tenfold decrease in tolerance would not cause an increase by orders of magnitude in $N$.\n- A singularity in $[0,T]$ would typically prevent reaching $T$ (or cause failure in both runs), which is not observed.\n- Using order $p=4$ is not by itself a cause of such a disproportionate change; increasing the order helps efficiency but does not explain the discontinuity in $N$ versus $\\epsilon$.\n- A software bug is possible, but the phenomenon described is a classic symptom of stiffness for explicit solvers, and chemical kinetics models are well known to be stiff due to disparate time scales of reactions.\n\nTherefore, the most likely explanation is that the ODE system is numerically stiff, and the explicit method’s step sizes are governed by stability and stiffness-induced order reduction rather than the nominal accuracy tolerance.",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "Once stiffness is suspected, it is useful to have a method to quantify its severity. A defining characteristic of stiff systems is the vast difference in performance between explicit and implicit numerical methods. This exercise introduces a practical \"Stiffness Factor\" based on this disparity. By comparing the computational work (measured in function evaluations) required by an explicit solver versus an implicit one to solve the same problem to the same accuracy, you will calculate a tangible metric of how \"stiff\" the system truly is. ",
            "id": "2206397",
            "problem": "In a simplified model of a catalytic converter, a toxic gas species $A$ is adsorbed onto a catalytic surface and slowly converts to an intermediate species $B$. This intermediate species $B$ is highly unstable and rapidly transforms into a non-toxic gas species $C$. The concentrations of these species, denoted by $y_A(t)$, $y_B(t)$, and $y_C(t)$, can be modeled by the following system of first-order ordinary differential equations:\n\n$$\n\\begin{align*}\n\\frac{dy_A}{dt} = -k_1 y_A \\\\\n\\frac{dy_B}{dt} = k_1 y_A - k_2 y_B \\\\\n\\frac{dy_C}{dt} = k_2 y_B\n\\end{align*}\n$$\n\nThe rate constants are given as $k_1 = 0.8 \\text{ s}^{-1}$ and $k_2 = 200 \\text{ s}^{-1}$. At time $t=0$, the initial concentrations are $y_A(0) = 1.0 \\text{ mol/L}$, $y_B(0) = 0$, and $y_C(0) = 0$.\n\nTo analyze the \"stiffness\" of this system, it is integrated from $t=0$ to $t=4.0$ seconds using two different numerical methods with adaptive step-size control. Both methods are configured to achieve the same final accuracy.\n\n1.  An **adaptive explicit solver** (based on a Runge-Kutta method) is used. To meet the accuracy target over the integration interval, it required a total of $318,550$ evaluations of the system's right-hand-side function.\n2.  An **adaptive implicit solver** (based on Backward Differentiation Formulas) is used. To meet the same accuracy target, it required a total of $472$ evaluations of the system's right-hand-side function.\n\nA quantitative \"Stiffness Factor\" for a given problem can be defined as the ratio of the computational effort of the explicit solver to that of the implicit solver. Using the number of function evaluations as a proxy for computational effort, calculate this Stiffness Factor.\n\nRound your final answer to three significant figures.",
            "solution": "The stiffness factor is defined as the ratio of the computational effort of the explicit solver to that of the implicit solver, using the number of right-hand-side evaluations as the measure of effort. Denote this factor by $S$. With $N_{\\text{exp}}=318{,}550$ and $N_{\\text{imp}}=472$, we have\n$$\nS=\\frac{N_{\\text{exp}}}{N_{\\text{imp}}}=\\frac{318{,}550}{472}.\n$$\nFactor the denominator as $472=8\\cdot 59$ and perform Euclidean division on the numerator by $59$:\n$$\n\\frac{318{,}550}{59}=5{,}399+\\frac{9}{59}.\n$$\nThus,\n$$\nS=\\frac{5{,}399+\\frac{9}{59}}{8}=\\frac{5{,}399}{8}+\\frac{9}{472}=674.875+\\frac{9}{472}.\n$$\nSince $\\frac{9}{472}\\approx 0.0190677966$, it follows that\n$$\nS\\approx 674.8940677966\\ldots\n$$\nRounding to three significant figures gives\n$$\nS\\approx 675.\n$$",
            "answer": "$$\\boxed{675}$$"
        },
        {
            "introduction": "Theory and observation are powerful, but direct computational verification provides the deepest understanding. This hands-on coding exercise challenges you to witness the failure mode of an explicit solver firsthand. You will implement a standard adaptive Runge-Kutta method and apply it to both stiff and non-stiff systems to see how stability constraints, dictated by the system's eigenvalues, can force the step size to become drastically small. This practice provides concrete evidence for why stiffness poses such a significant challenge and solidifies the theoretical concepts with practical demonstration. ",
            "id": "2439135",
            "problem": "Construct a program that analyzes step-size behavior of an explicit adaptive integrator on initial value problems exhibiting stiffness. For each given initial value problem, integrate the system and record the minimal accepted time step during the integration. Use an explicit Runge–Kutta–Fehlberg method of order five with an embedded order four estimator (Runge–Kutta–Fehlberg (RKF45)) with standard absolute and relative error control. For all problems, require absolute tolerance $\\mathrm{atol} = 10^{-9}$ and relative tolerance $\\mathrm{rtol} = 10^{-6}$. Define an accepted step as one for which the embedded local error estimate satisfies a standard weighted root-mean-square criterion less than or equal to $1$. Define “extreme step-size reduction” as the occurrence of a minimal accepted time step strictly less than $10^{-4}$ over the specified integration interval.\n\nYou must evaluate the following test suite of initial value problems:\n\n- Test A (nonstiff scalar): $$y'(t) = -y(t), \\quad y(0) = 1, \\quad t \\in [0, 10].$$\n- Test B (stiff scalar, forced linear): $$y'(t) = -10000\\,y(t) + 30000 - 20000\\,e^{-t}, \\quad y(0) = 0, \\quad t \\in [0, 0.1].$$\n- Test C (stiff linear two-component system): $$\\begin{aligned} y_1'(t) = -15\\,y_1(t), \\\\ y_2'(t) = -10000\\left(y_2(t) - y_1(t)\\right), \\end{aligned} \\quad \\begin{bmatrix} y_1(0) \\\\ y_2(0) \\end{bmatrix} = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}, \\quad t \\in [0, 0.2].$$\n\nFor each test, compute the minimal accepted step size $h_{\\min}$ encountered over the integration and determine a boolean value according to whether $h_{\\min}  10^{-4}$ holds. The required final output is a single line containing a comma-separated list of these three boolean results in order $\\text{[A,B,C]}$, enclosed in square brackets. For example, an output of the form $\\text{[False,True,True]}$ indicates that extreme step-size reduction occurred for Test B and Test C but not for Test A.\n\nThere are no physical units in this problem. Angles do not appear. Percentages are not used. Your program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets, exactly in the order $\\text{[A,B,C]}$ as described above.",
            "solution": "Stiffness in an initial value problem arises when the solution contains components that vary on vastly different time scales. This poses a significant challenge for explicit numerical integration methods. While the rapidly decaying components (transients) may become negligible very quickly, their presence in the system's Jacobian matrix continues to impose a severe restriction on the integrator's step size to maintain numerical stability. The step size is constrained by the fastest time scale, even when accuracy considerations for the smooth, slow-varying part of the solution would permit a much larger step. This leads to computationally inefficient integrations, as the solver is forced to take an excessive number of very small steps.\n\nThe task is to demonstrate this phenomenon by analyzing the step-size behavior of an explicit adaptive integrator on three distinct ODE problems. The chosen integrator is a Runge-Kutta-Fehlberg method of order five with an embedded order-four error estimator, commonly known as RKF45. A modern, high-quality implementation of this class of method is the Dormand-Prince 5(4) pair, which is available in the `scipy` library as `scipy.integrate.solve_ivp` with `method='RK45'`. This will be the tool used for the numerical integration.\n\nThe integration process uses adaptive step-size control based on a local error estimate. At each step, an error is estimated by comparing the fifth-order solution with the embedded fourth-order one. This error, $E$, is measured using a weighted root-mean-square norm, and the step is accepted only if $E \\le 1$. The weights are functions of the specified absolute tolerance, $\\mathrm{atol} = 10^{-9}$, and relative tolerance, $\\mathrm{rtol} = 10^{-6}$. Specifically, for a solution vector $y$, the error is scaled by $\\mathrm{atol} + \\mathrm{rtol} \\times |y|$. After an accepted step of size $h$, the next step size is chosen to keep the estimated error near the target of $1$. If the error is too large, the step is rejected and retried with a smaller $h$.\n\nWe will analyze three initial value problems and record the minimum accepted step size, $h_{\\min}$, for each. The condition for \"extreme step-size reduction\" is defined as $h_{\\min}  10^{-4}$.\n\nTest A: Nonstiff scalar problem\nThe ODE is $y'(t) = -y(t)$ with $y(0)=1$ on $t \\in [0, 10]$.\nThe system's Jacobian is simply the scalar $J = [-1]$. The only eigenvalue is $\\lambda = -1$, corresponding to a time constant of $\\tau = 1/|\\lambda| = 1$. The solution is $y(t) = e^{-t}$. There is only one time scale, and it is not particularly fast. The step size selected by the adaptive integrator will be governed primarily by the accuracy requirements defined by $\\mathrm{atol}$ and $\\mathrm{rtol}$. We do not expect stability to force the step size to be pathologically small. Therefore, it is predicted that $h_{\\min}$ will not fall below the threshold of $10^{-4}$.\n\nTest B: Stiff scalar problem\nThe ODE is $y'(t) = -10000\\,y(t) + 30000 - 20000\\,e^{-t}$ with $y(0)=0$ on $t \\in [0, 0.1]$.\nThe Jacobian is $J = [-10000]$. The eigenvalue is $\\lambda = -10000$, corresponding to an extremely fast time constant of $\\tau = 1/|\\lambda| = 10^{-4}\\,$s. The stability region of an explicit Runge-Kutta method requires that the product of the step size $h$ and the eigenvalue $\\lambda$ lies within a bounded region in the complex plane. For real negative eigenvalues, this imposes a constraint of the form $h \\lesssim C/|\\lambda|$ for some constant $C$ of order $1$, which for this problem is $h \\lesssim C \\times 10^{-4}$. Even after the initial transient associated with this eigenvalue has decayed (which happens very quickly, within a few multiples of $10^{-4}$), this stability constraint remains in effect for the explicit integrator. Consequently, the step size will be severely limited throughout the entire integration interval. It is strongly predicted that $h_{\\min}$ will be less than $10^{-4}$.\n\nTest C: Stiff linear system\nThe system is given by:\n$$\n\\begin{aligned}\ny_1'(t) = -15\\,y_1(t) \\\\\ny_2'(t) = -10000\\left(y_2(t) - y_1(t)\\right)\n\\end{aligned}\n\\quad \\text{with} \\quad\n\\begin{bmatrix} y_1(0) \\\\ y_2(0) \\end{bmatrix} = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}\n\\quad \\text{on} \\quad t \\in [0, 0.2].\n$$\nThe Jacobian matrix of this system is:\n$$\nJ = \\frac{\\partial \\mathbf{f}}{\\partial \\mathbf{y}} = \\begin{bmatrix} -15  0 \\\\ 10000  -10000 \\end{bmatrix}\n$$\nSince this matrix is lower triangular, its eigenvalues are its diagonal entries: $\\lambda_1 = -15$ and $\\lambda_2 = -10000$. These correspond to two very different time scales: a slow one $\\tau_1 = 1/15 \\approx 0.067$ and a very fast one $\\tau_2 = 1/10000 = 10^{-4}$. The ratio of the magnitudes of the eigenvalues, the stiffness ratio, is $|\\lambda_2|/|\\lambda_1| = 10000/15 \\approx 667$, which is large and confirms the system is stiff. As with Test B, the stability of the explicit integrator is governed by the eigenvalue with the largest magnitude, $\\lambda_2 = -10000$. The step size $h$ will be constrained by the stability limit associated with this eigenvalue, forcing $h$ to remain on the order of $10^{-4}$ or smaller. Thus, it is predicted that $h_{\\min}  10^{-4}$.\n\nThe program will implement this analysis by calling `scipy.integrate.solve_ivp` for each case. The returned solution object contains an array `sol.t` of the time points at which the solution was computed. The sequence of accepted step sizes is then calculated as the successive differences in this array, `np.diff(sol.t)`. The minimum of these values is $h_{\\min}$, which is then compared against the $10^{-4}$ threshold to produce the required boolean output.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Analyzes step-size behavior of an explicit adaptive integrator on\n    initial value problems exhibiting stiffness, as per the problem description.\n    \"\"\"\n\n    # Define common parameters for the analysis.\n    atol = 1e-9\n    rtol = 1e-6\n    step_size_threshold = 1e-4\n\n    # Define the test cases.\n    test_cases = [\n        {\n            \"name\": \"A\",\n            \"fun\": lambda t, y: -y,\n            \"t_span\": [0, 10],\n            \"y0\": [1],\n        },\n        {\n            \"name\": \"B\",\n            \"fun\": lambda t, y: -10000 * y[0] + 30000 - 20000 * np.exp(-t),\n            \"t_span\": [0, 0.1],\n            \"y0\": [0],\n        },\n        {\n            \"name\": \"C\",\n            \"fun\": lambda t, y: np.array([-15 * y[0], -10000 * (y[1] - y[0])]),\n            \"t_span\": [0, 0.2],\n            \"y0\": [1, 0],\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        # Integrate the ODE system using the specified method and tolerances.\n        # The 'RK45' method in SciPy is the Dormand-Prince 5(4) pair, a standard\n        # high-quality implementation of the class of methods described in the problem.\n        sol = solve_ivp(\n            fun=case[\"fun\"],\n            t_span=case[\"t_span\"],\n            y0=case[\"y0\"],\n            method='RK45',\n            atol=atol,\n            rtol=rtol,\n        )\n\n        # The 'sol.t' attribute contains the time points of the accepted steps.\n        # The differences between consecutive time points are the accepted step sizes.\n        if len(sol.t)  2:\n            # This case should not occur for the given problems but is a safe check.\n            # If only one point (initial) exists, there are no steps.\n            # We can treat this as no extreme reduction, or handle as an error.\n            # For this problem's context, it indicates no steps were taken or needed,\n            # so no small steps were taken.\n            h_min = np.inf\n        else:\n            step_sizes = np.diff(sol.t)\n            h_min = np.min(step_sizes)\n\n        # Determine if extreme step-size reduction occurred.\n        # The problem defines this as h_min strictly less than the threshold.\n        extreme_reduction = h_min  step_size_threshold\n        results.append(extreme_reduction)\n\n    # Format the final output string as a comma-separated list of booleans.\n    # Python's `str(bool)` converts True to 'True' and False to 'False'.\n    # The example [False,True,True] uses capitalized boolean literals.\n    # This formatting matches the example.\n    results_str = [str(r) for r in results]\n    \n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```"
        }
    ]
}