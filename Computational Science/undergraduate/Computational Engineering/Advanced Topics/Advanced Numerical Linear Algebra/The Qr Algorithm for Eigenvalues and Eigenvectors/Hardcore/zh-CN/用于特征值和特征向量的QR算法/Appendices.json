{
    "hands_on_practices": [
        {
            "introduction": "要真正掌握QR算法，没有什么比亲手计算一遍更有效了。这个练习  将引导你对一个简单的 $2 \\times 2$ 矩阵执行两轮无位移的QR迭代。通过这个过程，你将对矩阵如何通过QR分解和重组，逐步向揭示其特征值的形式演化，建立起直观的理解。",
            "id": "1057107",
            "problem": "QR算法是一种用于求解矩阵特征值和特征向量的迭代方法。基本的（无位移）算法从一个矩阵 $A_0$ 开始，通过以下过程生成一个矩阵序列 $\\{A_k\\}_{k=0}^\\infty$：\n1. 对于给定的矩阵 $A_k$，计算其QR分解，即 $A_k = Q_k R_k$，其中 $Q_k$ 是一个正交矩阵，$R_k$ 是一个对角线元素非负的上三角矩阵。\n2. 序列中的下一个矩阵由 $A_{k+1} = R_k Q_k$ 给出。\n\n可以证明，所有的矩阵 $A_k$ 都与 $A_0$ 相似，因为 $A_{k+1} = R_k Q_k = (Q_k^{-1} A_k) Q_k = Q_k^T A_k Q_k$。在某些条件下，序列 $A_k$ 会收敛到一个上三角或准上三角矩阵（Schur型），从而揭示 $A_0$ 的特征值。\n\n考虑 $\\mathbb{R}^2$ 上的一个线性算子，其在标准基下的矩阵表示为\n$$\nA_0 = \\begin{pmatrix} 1 & 4 \\\\ 1 & 1 \\end{pmatrix}\n$$\n执行两步连续的无位移QR算法来生成序列 $A_0 \\to A_1 \\to A_2$，这会涉及到正交矩阵 $Q_0$ 和 $Q_1$。\n\n你的任务是计算这两个初始正交矩阵乘积的迹，即 $\\text{Tr}(Q_0 Q_1)$。",
            "solution": "我们对矩阵\n$$A_0=\\begin{pmatrix}1 & 4\\\\1 & 1\\end{pmatrix}$$\n执行两步无位移QR算法。\n1. 对 $A_0$ 进行QR分解。设\n\n$$\na_1=(1,1)^T,\\quad\\|a_1\\|=\\sqrt{2},\\quad e_1=\\frac{a_1}{\\sqrt2}=(1/\\sqrt2,1/\\sqrt2)^T.\n$$\n\n\n$$\na_2=(4,1)^T,\\quad e_1^Ta_2=\\frac{5}{\\sqrt2},\\quad\n\\mathrm{proj}_{e_1}a_2=\\frac{5}{2}(1,1)^T,\n$$\n\n\n$$\nu_2=a_2-\\mathrm{proj}_{e_1}a_2=(3/2,-3/2)^T,\\quad\\|u_2\\|=\\frac{3}{\\sqrt2},\\quad\ne_2=\\frac{u_2}{\\|u_2\\|}=(1/\\sqrt2,-1/\\sqrt2)^T.\n$$\n\n因此\n\n$$\nQ_0=\\frac1{\\sqrt2}\\begin{pmatrix}1 & 1\\\\1 & -1\\end{pmatrix},\\quad\nR_0=Q_0^TA_0=\\begin{pmatrix}2/\\sqrt{2} & 5/\\sqrt{2}\\\\0 & 3/\\sqrt{2}\\end{pmatrix},\n$$\n\n\n$$\nA_1=R_0Q_0\n=\\begin{pmatrix}7/2 & -3/2\\\\3/2 & -3/2\\end{pmatrix}.\n$$\n\n\n2. 对 $A_1$ 进行QR分解。设\n\n$$\na_1'=(7/2,\\,3/2)^T,\\quad\\|a_1'\\|=\\frac{\\sqrt{58}}2,\\quad\ne_1'=\\frac{1}{\\sqrt{58}}(7,3)^T,\n$$\n\n\n$$\na_2'=(-3/2,-3/2)^T,\\quad\ne_1'^Ta_2'=-\\frac{15}{\\sqrt{58}},\\quad\n\\mathrm{proj}_{e_1'}a_2'=-\\frac{15}{58}(7,3)^T,\n$$\n\n\n$$\nu_2'=a_2'-\\mathrm{proj}_{e_1'}a_2'=\\bigl(9/29,-21/29\\bigr)^T,\\quad\n\\|u_2'\\|=\\frac{3\\sqrt{58}}{29},\\quad\ne_2'=\\frac{1}{\\sqrt{58}}(3,-7)^T.\n$$\n\n因此\n\n$$\nQ_1=\\frac1{\\sqrt{58}}\\begin{pmatrix}7 & 3\\\\3 & -7\\end{pmatrix}.\n$$\n\n\n3. $Q_0Q_1$ 的迹。计算\n\n$$\nQ_0Q_1\n=\\begin{pmatrix}1/\\sqrt{2} & 1/\\sqrt{2}\\\\1/\\sqrt{2} & -1/\\sqrt{2}\\end{pmatrix}\n\\frac1{\\sqrt{58}}\\begin{pmatrix}7 & 3\\\\3 & -7\\end{pmatrix}\n=\\begin{pmatrix}5/\\sqrt{29} & \\ast\\\\\\ast & 5/\\sqrt{29}\\end{pmatrix},\n$$\n\n所以\n\n$$\n\\mathrm{Tr}(Q_0Q_1)\n=\\frac{5}{\\sqrt{29}}+\\frac{5}{\\sqrt{29}}\n=\\frac{10}{\\sqrt{29}}.\n$$",
            "answer": "$$\\boxed{\\frac{10}{\\sqrt{29}}}$$"
        },
        {
            "introduction": "基础的QR算法虽然有效，但收敛速度可能很慢。为了加速，我们引入了“位移”技术，这是使得QR算法在实践中如此高效的关键。这个思想实验  探讨了一种理想情况：当我们选择的位移量恰好是矩阵的一个特征值时会发生什么？理解这个特殊情况将揭示“收缩”（deflation）这一强大机制的原理，即算法如何锁定一个已找到的特征值并简化问题。",
            "id": "2445523",
            "problem": "设 $A \\in \\mathbb{R}^{n\\times n}$ 是一个未约化上Hessenberg矩阵，并考虑在精确算术下，使用一个实位移 $\\sigma \\in \\mathbb{R}$ 执行一步隐式单步位移Francis QR（正交三角）分解步骤。根据Francis步的定义，我们计算QR（正交三角）分解\n$$A - \\sigma I = Q R,$$\n其中 $Q \\in \\mathbb{R}^{n\\times n}$ 是正交矩阵，$R \\in \\mathbb{R}^{n\\times n}$ 是上三角矩阵，然后形成更新后的矩阵\n$$A_{+} = R Q + \\sigma I = Q^{\\mathsf T} A Q,$$\n该矩阵与 $A$ 正交相似并保持上Hessenberg结构。假设所选的位移 $\\sigma$ 恰好等于 $A$ 的一个特征值，即 $\\det(A - \\sigma I) = 0$。在精确算术下，以下哪个陈述是正确的？\n\nA. 经过这一单步迭代后，更新后的矩阵 $A_{+}$ 与 $A$ 正交相似，并且其末尾的次对角线元素 $a^{(+)}_{n,n-1}$ 恰好等于 $0$，因此 $A_{+}$ 是一个分块上三角矩阵，其末尾的 $1\\times 1$ 分块等于 $\\sigma$（立即紧缩）。\n\nB. 由于 $A - \\sigma I$ 是奇异的，分解 $A - \\sigma I = Q R$ 不存在，因此Francis步是未定义的。\n\nC. 更新后的矩阵满足 $A_{+} = A$，因此迭代停滞，没有任何进展。\n\nD. 这一步破坏了上Hessenberg结构；即使在精确算术下，$A_{+}$ 通常也是稠密矩阵。\n\nE. 在 $A - \\sigma I = Q R$ 中得到的矩阵 $Q$ 不是正交的，即 $Q^{\\mathsf T} Q \\neq I$，因为 $A - \\sigma I$ 是奇异的。",
            "solution": "在尝试求解之前，必须首先验证问题陈述的科学合理性、自洽性和清晰性。\n\n### 步骤1：提取已知条件\n\n已知条件如下：\n1. $A \\in \\mathbb{R}^{n\\times n}$ 是一个未约化上Hessenberg矩阵。这意味着对于 $i > j+1$，有 $a_{i,j} = 0$，且对于所有 $i \\in \\{1, 2, \\dots, n-1\\}$，有 $a_{i+1,i} \\neq 0$。\n2. 在精确算术下，使用一个实位移 $\\sigma \\in \\mathbb{R}$ 执行一步Francis QR步。\n3. 该步骤由QR分解 $A - \\sigma I = Q R$ 定义，其中 $Q$ 是正交矩阵（$Q^{\\mathsf T} Q = I$），$R$ 是上三角矩阵。\n4. 更新后的矩阵为 $A_{+} = R Q + \\sigma I$。\n5. 已知 $A_{+} = Q^{\\mathsf T} A Q$，这证实了正交相似性和上Hessenberg结构的保持。\n6. 位移 $\\sigma$ 是 $A$ 的一个精确特征值：$\\det(A - \\sigma I) = 0$。\n7. 任务是确定在这些条件下，哪个陈述是正确的。\n\n### 步骤2：使用提取的已知条件进行验证\n\n该问题陈述描述了数值线性代数中一个众所周知的情形：当使用精确特征值作为位移时，QR算法的行为。所涉及的概念——未约化Hessenberg矩阵、QR分解、Francis步、特征值——都是标准的且有精确定义。精确算术的假设是一种常见的理论工具，用于在没有浮点误差复杂性的情况下分析算法。这些前提条件是相互一致的，并且足以推导出唯一的结论。该问题具有科学依据，是适定的、客观的。因此，该问题是有效的。\n\n### 步骤3：推导正确答案\n\n问题的核心在于奇异矩阵 $M = A - \\sigma I$ 的QR分解的性质。\n\n首先，让我们分析 $M = A - \\sigma I$ 的结构。由于 $A$ 是一个未约化上Hessenberg矩阵，其所有次对角线元素 $a_{i+1,i}$ 对于 $i = 1, \\dots, n-1$ 都是非零的。矩阵 $M$ 也是上Hessenberg矩阵，其次对角线元素与 $A$ 的相同，所以对于 $i=1, \\dots, n-1$，$m_{i+1,i} = a_{i+1,i} \\neq 0$。因此，$M$ 也是一个未约化上Hessenberg矩阵。\n\n一个 $n \\times n$ 未约化上Hessenberg矩阵的一个关键性质是它的前 $n-1$ 列是线性无关的。我们可以用反证法来证明这一点。假设前 $k$ 列的某个非平凡线性组合是零向量，其中 $k \\le n-1$：$\\sum_{j=1}^{k} c_j \\mathbf{m}_j = \\mathbf{0}$，其中 $\\mathbf{m}_j$ 是 $M$ 的第 $j$ 列，且并非所有 $c_j$ 都为零。设 $k$ 是使得 $c_k \\neq 0$ 的最大索引。观察这个向量方程的第 $(k+1)$ 行，我们有 $\\sum_{j=1}^{k} c_j m_{k+1,j} = 0$。由于 $M$ 是上Hessenberg矩阵，$m_{k+1,j} = 0$ 对 $j < k$ 成立。方程简化为 $c_k m_{k+1,k} = 0$。由于 $M$ 是未约化的，$m_{k+1,k} \\neq 0$。这迫使 $c_k=0$，与我们的假设 $c_k \\neq 0$ 矛盾。因此，$M$ 的前 $n-1$ 列必须是线性无关的。\n\n我们已知 $\\sigma$ 是 $A$ 的一个特征值，这意味着矩阵 $M = A - \\sigma I$ 是奇异的，即其秩小于 $n$。由于我们已经确定其前 $n-1$ 列是线性无关的，所以 $M$ 的秩必须恰好为 $n-1$。这意味着最后一列 $\\mathbf{m}_n$ 必定是前面 $n-1$ 列的线性组合。\n\n现在，考虑QR分解 $M = QR$。$Q$ 的列，记为 $\\mathbf{q}_1, \\dots, \\mathbf{q}_n$，构成一个标准正交基。$M$ 和 $R$ 之间的关系由 $R = Q^{\\mathsf T} M$ 给出。上三角矩阵 $R$ 的对角线元素是 $r_{kk} = \\mathbf{q}_k^{\\mathsf T} \\mathbf{m}_k$。在Gram-Schmidt过程的背景下， $|r_{kk}|$ 是 $\\mathbf{m}_k$ 在与由 $\\{\\mathbf{m}_1, \\dots, \\mathbf{m}_{k-1}\\}$ 张成的子空间正交的分量的范数。\n由于 $M$ 的前 $n-1$ 列是线性无关的，对于 $k=1, \\dots, n-1$，$r_{kk} \\neq 0$。\n然而，对于最后一列，$\\mathbf{m}_n$ 位于 $\\{\\mathbf{m}_1, \\dots, \\mathbf{m}_{n-1}\\}$ 的张成空间中。由 $\\{\\mathbf{m}_1, \\dots, \\mathbf{m}_{n-1}\\}$ 张成的子空间与由标准正交向量 $\\{\\mathbf{q}_1, \\dots, \\mathbf{q}_{n-1}\\}$ 张成的子空间是相同的。因此，$\\mathbf{m}_n$ 与 $\\mathbf{q}_n$ 正交。所以，$R$ 的最后一个对角线元素为 $r_{nn} = \\mathbf{q}_n^{\\mathsf T} \\mathbf{m}_n = 0$。\n\n由于 $R$ 是一个上三角矩阵且其最后一个对角元素 $r_{nn}$ 为零，所以 $R$ 的整个最后一行必须为零。即，对于所有 $j=1, \\dots, n$，$R_{n,j} = 0$。\n\n现在我们分析更新后的矩阵 $A_{+} = R Q + \\sigma I$。让我们检查它的最后一行。\n乘积 $RQ$ 的最后一行是 $R$ 的最后一行与矩阵 $Q$ 的乘积。由于 $R$ 的最后一行是零向量，所以 $RQ$ 的最后一行也是一个零向量。\n$\\sigma I$ 的最后一行是 $[0, 0, \\dots, 0, \\sigma]$。\n因此，$A_{+}$ 的最后一行是这两行之和，即 $[0, 0, \\dots, 0, \\sigma]$。\n\n这个关于 $A_{+}$ 最后一行的结果意味着两件事：\n1. 元素 $a^{(+)}_{n,n-1} = 0$。\n2. 元素 $a^{(+)}_{n,n} = \\sigma$。\n\n$a^{(+)}_{n,n-1} = 0$ 这个事实意味着矩阵 $A_+$ 不再是未约化的。它具有分块上三角结构：\n$$ A_{+} =\n\\begin{pmatrix}\nA'_{11} & A'_{12} \\\\\n\\mathbf{0} & \\sigma\n\\end{pmatrix}\n$$\n其中 $A'_{11}$ 是一个 $(n-1) \\times (n-1)$ 的上Hessenberg矩阵。这种现象被称为紧缩（deflation），因为特征值 $\\sigma$ 已被成功分离出来，问题被简化为求解更小的矩阵 $A'_{11}$ 的特征值。\n\n### 选项评估\n\n**A. 经过这一单步迭代后，更新后的矩阵 $A_{+}$ 与 $A$ 正交相似，并且其末尾的次对角线元素 $a^{(+)}_{n,n-1}$ 恰好等于 $0$，因此 $A_{+}$ 是一个分块上三角矩阵，其末尾的 $1\\times 1$ 分块等于 $\\sigma$（立即紧缩）。**\n该陈述是我们推导过程的完美总结。\n- $A_{+} = Q^{\\mathsf T} A Q$，因此它与 $A$ 正交相似。正确。\n- $a^{(+)}_{n,n-1} = 0$。正确。\n- $A_{+}$ 是一个分块上三角矩阵，其末尾的 $1 \\times 1$ 分块 $a^{(+)}_{n,n} = \\sigma$。正确。\n这个过程被称为立即紧缩。因此，该陈述完全正确。\n**结论：正确。**\n\n**B. 由于 $A - \\sigma I$ 是奇异的，分解 $A - \\sigma I = Q R$ 不存在，因此Francis步是未定义的。**\n对于任何实数或复数矩阵，无论其秩或是否奇异，QR分解都存在。矩阵的奇异性仅意味着 $R$ 因子中至少有一个对角线元素为零。该陈述根本上是错误的。\n**结论：不正确。**\n\n**C. 更新后的矩阵满足 $A_{+} = A$，因此迭代停滞，没有任何进展。**\n$A_{+} = R Q + \\sigma I$ 而 $A = Q R + \\sigma I$。$A_{+} = A$ 意味着 $RQ=QR$。通常情况下，矩阵乘法不满足交换律。$Q$ 和 $R$ 不会交换，除非它们具有非常特殊的结构，而这里并非如此。正如我们对A的推导所示，$A_{+} \\neq A$，并且取得了显著进展（紧缩）。\n**结论：不正确。**\n\n**D. 这一步破坏了上Hessenberg结构；即使在精确算术下，$A_{+}$ 通常也是稠密矩阵。**\n这与Francis QR步的一个基本性质相矛盾。正如问题陈述中所给出和理论上所知，如果 $A$ 是上Hessenberg矩阵，那么 $A_{+} = Q^{\\mathsf T} A Q$ 也是上Hessenberg矩阵。根据隐式Q定理，该结构是保持不变的。\n**结论：不正确。**\n\n**E. 在 $A - \\sigma I = Q R$ 中得到的矩阵 $Q$ 不是正交的，即 $Q^{\\mathsf T} Q \\neq I$，因为 $A - \\sigma I$ 是奇异的。**\n根据其定义，QR分解会产生一个正交矩阵 $Q$。计算它的标准算法，例如基于Householder反射或Givens旋转的算法，将 $Q$ 构造为正交矩阵的乘积，其本身也是正交的。被分解矩阵的奇异性影响的是 $R$ 因子，而不是 $Q$ 因子的正交性。\n**结论：不正确。**",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "现在，我们将理论付诸实践。结合前两个练习中获得的对算法力学的理解和对位移收缩策略的洞察，你将构建一个功能完整的特征值求解器。这个编程任务  要求你实现一个带位移的QR算法，专门用于求解实对称矩阵的特征值。你将使用Wilkinson位移（一种在未知确切特征值时的高效策略）并实现收缩逻辑，这是现代数值计算库中QR算法的核心组成部分。",
            "id": "2445542",
            "problem": "实现一个完整的程序，该程序使用带压缩（deflation）的正交三角（QR）分解法来计算实对称矩阵的实特征值。核心计算任务是设计一个鲁棒的相似性迭代方案，该方案仅基于以下经过充分检验的事实和核心定义：\n\n- 对于一个实方阵 $A \\in \\mathbb{R}^{n \\times n}$，如果存在一个非零向量 $x \\in \\mathbb{R}^{n}$ 使得 $A x = \\lambda x$，则一个标量 $\\lambda \\in \\mathbb{R}$ 是一个特征值。\n- 对于任意实方阵 $A$，存在一个正交矩阵 $Q$ 和一个上三角矩阵 $R$ 使得 $A = Q R$。\n- 正交相似变换保持特征值不变：如果 $Q^{\\top} Q = I$，则 $A$ 和 $Q^{\\top} A Q$ 具有相同的特征值多重集。\n- 如果一个实对称矩阵是（精确或近似）块对角矩阵，其特征值是其对角块特征值的并集；这为次对角线元素足够小时进行压缩（deflation）提供了动机。\n\n您的程序必须实现带显式压缩的移位 QR 迭代：\n\n- 在每一步中，对一个大小为 $m \\times m$ 的活动主子矩阵，应用一个单移位 QR 步骤，该步骤使用一个由末尾的 $2 \\times 2$ 主子矩阵构造的 Wilkinson 型移位 $\\mu$。\n- 构造 $A_{k} - \\mu I = Q R$，然后更新 $A_{k+1} = R Q + \\mu I$，它与 $A_{k}$ 正交相似。\n- 使用一个压缩准则，当次对角线元素 $|a_{m-1,m-2}|$ 满足 $|a_{m-1,m-2}| \\le \\tau \\cdot (|a_{m-2,m-2}| + |a_{m-1,m-1}|)$ 时，将其视为可忽略，其中 $\\tau$ 是用户指定的容差。进行压缩时，将 $a_{m-1,m-1}$ 锁定为一个已收敛的特征值，将 $m$ 减为 $m - 1$，并在缩减后的主子矩阵上继续。当 $m = 1$ 时，锁定最后一个对角线元素。\n- 假设所有输入矩阵都是实对称矩阵。此任务不涉及角度。不涉及物理单位。\n\n数值要求和约束：\n\n- 使用相对压缩容差 $\\tau = 10^{-12}$ 以及对单个矩阵的整个运行设置硬性迭代上限 $K_{\\max} = 10000$ 次。如果在所有压缩完成之前达到迭代上限，则返回活动块的当前对角线元素作为剩余特征值的估计。\n- 在每个相似性步骤之后，您可以通过将其与转置矩阵求平均来强制活动块的对称性，以抵消浮点不对称性。\n\n测试套件：\n\n您的程序必须在以下矩阵上运行。每个矩阵必须被视为一个独立的测试用例。\n\n- 测试用例 $1$ (大小为 $3 \\times 3$): \n  $$\n  A_{1} = \\begin{bmatrix}\n  4  1  0 \\\\\n  1  3  1 \\\\\n  0  1  2\n  \\end{bmatrix}.\n  $$\n- 测试用例 $2$ (大小为 $5 \\times 5$): 一个三对角托普利茨（Toeplitz）矩阵，其主对角线元素为 $2$，第一亚对角线和第一超对角线元素为 $-1$，\n  $$\n  A_{2} = \\begin{bmatrix}\n  2  -1  0  0  0 \\\\\n  -1  2  -1  0  0 \\\\\n  0  -1  2  -1  0 \\\\\n  0  0  -1  2  -1 \\\\\n  0  0  0  -1  2\n  \\end{bmatrix}.\n  $$\n- 测试用例 $3$ (大小为 $2 \\times 2$): 近似对角矩阵，其亚对角线元素可立即压缩，\n  $$\n  A_{3} = \\begin{bmatrix}\n  2  10^{-12} \\\\\n  10^{-12}  2\n  \\end{bmatrix}.\n  $$\n- 测试用例 $4$ (大小为 $1 \\times 1$): \n  $$\n  A_{4} = \\begin{bmatrix}\n  7\n  \\end{bmatrix}.\n  $$\n\n所需输出格式：\n\n- 对于每个测试用例，使用所述的带压缩的 QR 迭代法计算所有实特征值。将特征值按非递减顺序排序，并将每个特征值四舍五入到 $8$ 位小数。\n- 您的程序应生成单行输出，包含用方括号括起来的逗号分隔列表形式的结果，其中每个元素是按 $A_{1}, A_{2}, A_{3}, A_{4}$ 顺序排列的一个测试用例的四舍五入后的特征值列表。例如，整体形式必须是\n  $$\n  [ [\\cdot,\\cdots,\\cdot], [\\cdot,\\cdots,\\cdot], [\\cdot,\\cdots,\\cdot], [\\cdot] ].\n  $$\n\n答案类型：\n\n- 每个测试用例的答案是一个浮点数列表。因此，最终输出是一个浮点数列表的列表，并以上述确切格式打印在单行上。",
            "solution": "所述问题具有科学依据、提法恰当、客观且自成体系。它描述了计算线性代数中一个标准且重要的数值算法，即用于寻找实对称矩阵特征值的带 Wilkinson 移位的 QR 迭代法。所有参数、基本原理和测试用例都以足够的清晰度和精确度提供，从而能够得出一个唯一且可验证的解。因此，该问题是有效的。\n\n任务是计算给定实对称矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 的实特征值。指定的方法是带有特定移位策略和压缩准则的 QR 算法。该迭代算法生成一个矩阵序列 $A_0, A_1, A_2, \\dots$，它们都与原始矩阵 $A_0 = A$ 正交相似，并且收敛到一个对角矩阵，其对角线元素是 $A$ 的特征值。\n\n基本原理是正交相似变换保持特征值不变。如果 $A = Q R$，其中 $Q$ 是正交矩阵（$Q^{\\top}Q = I$），$R$ 是上三角矩阵，则基本 QR 迭代将序列中的下一个矩阵定义为 $A_1 = R Q$。这个新矩阵 $A_1$ 与 $A$ 正交相似，因为 $A_1 = R Q = (Q^{\\top}A) Q = Q^{\\top}A Q$。对于对称矩阵 $A$，序列 $\\{A_k\\}$ 收敛于一个对角矩阵。\n\n为了加速收敛，特别是对于对称矩阵，在每一步 $k$ 引入一个原点移位 $\\mu_k$。迭代过程变为：\n1. 选择一个移位 $\\mu_k$。\n2. 分解移位后的矩阵：$A_k - \\mu_k I = Q_k R_k$。\n3. 计算下一个迭代矩阵：$A_{k+1} = R_k Q_k + \\mu_k I$。\n这种变换同样保持特征值不变：$A_{k+1} = R_k Q_k + \\mu_k I = (Q_k^{\\top}(A_k - \\mu_k I))Q_k + \\mu_k I = Q_k^{\\top}A_k Q_k - \\mu_k Q_k^{\\top}I Q_k + \\mu_k I = Q_k^{\\top}A_k Q_k - \\mu_k I + \\mu_k I = Q_k^{\\top}A_k Q_k$。因此，$A_{k+1}$ 与 $A_k$ 正交相似。一个好的移位 $\\mu_k$ 选择可以显著提高收敛速度。\n\n按规定，该算法在一个尺寸为 $m \\times m$ 的、逐渐变小的前导主子矩阵上操作，其中 $m$ 初始等于 $n$。主过程持续进行，直到找到所有特征值（$m=0$）或达到最大迭代次数 $K_{\\max} = 10000$。\n\n在每个阶段，算法首先检查是否可以进行压缩。这是提高效率的关键步骤。如果相应的非对角线元素变得可以忽略不计，则认为一个特征值已经收敛。问题指定了一个明确的压缩策略，该策略关注活动子矩阵的末尾元素。如果次对角线元素 $|a_{m-1,m-2}|$ 满足条件\n$$\n|a_{m-1,m-2}| \\le \\tau \\cdot \\left(|a_{m-2,m-2}| + |a_{m-1,m-1}|\\right)\n$$\n且容差为 $\\tau = 10^{-12}$，则末尾的对角线元素 $a_{m-1,m-1}$ 被接受为一个已收敛的特征值。然后活动矩阵的大小减一（$m \\leftarrow m - 1$），并在新的、更小的 $(m-1) \\times (m-1)$ 子矩阵上继续该过程。如果 $m=1$，单个元素 $a_{0,0}$ 立即被声明为一个特征值。\n\n如果未满足压缩准则，则对当前的 $m \\times m$ 活动子矩阵执行一次移位 QR 步骤。指定的移位是 Wilkinson 移位，这是对称矩阵的一个高效选择，已知可以产生渐近三次收敛。Wilkinson 移位 $\\mu$ 是通过检查活动块的末尾 $2 \\times 2$ 主子矩阵来确定的：\n$$\n\\begin{bmatrix}\na_{m-2,m-2} & a_{m-2,m-1} \\\\\na_{m-1,m-2} & a_{m-1,m-1}\n\\end{bmatrix}\n$$\n令 $d = a_{m-1,m-1}$，$a = a_{m-2,m-2}$，$b = a_{m-1,m-2}$，以及 $\\delta = (a - d)/2$，移位 $\\mu$ 是这个 $2 \\times 2$ 矩阵中更接近 $d$ 的那个特征值。该移位的一个数值稳定公式是：\n$$\n\\mu = d - \\frac{b^2}{\\delta + \\operatorname{sgn}(\\delta) \\sqrt{\\delta^2 + b^2}}\n$$\n如果 $\\delta = 0$，公式简化为 $\\mu = d - |b|$。计算出 $\\mu$ 后，在 $m \\times m$ 子矩阵上执行 QR 步骤 $A_k - \\mu I = QR$ 和更新 $A_{k+1} = RQ + \\mu I$。\n\n由于浮点运算，矩阵在更新后可能会失去完美的对称性。为了抵消这一点，在每一步之后通过将矩阵与其转置求平均来强制对称性：$A \\leftarrow (A + A^{\\top}) / 2$。\n\n如果在所有特征值收敛之前（即 $m>0$）迭代次数 $K_{\\max}$ 已用尽，则算法终止，并返回剩余的 $m \\times m$ 活动子矩阵的对角线元素作为剩余特征值的估计值。\n\n最后，收集给定矩阵的所有计算出的特征值，按非递减顺序排序，并按要求四舍五入到 $8$ 位小数。此过程独立应用于每个测试用例矩阵。",
            "answer": "```python\nimport numpy as np\nimport scipy.linalg\n\ndef solve():\n    \"\"\"\n    Main function to run the eigenvalue computation on the test suite.\n    \"\"\"\n\n    def qr_eigenvalues(A_orig: np.ndarray, tol: float, max_iter: int):\n        \"\"\"\n        Computes the eigenvalues of a real symmetric matrix using the QR algorithm\n        with Wilkinson shifts and explicit deflation.\n\n        Args:\n            A_orig: The input real symmetric matrix.\n            tol: The relative tolerance for deflation.\n            max_iter: The maximum number of iterations allowed for the entire matrix.\n\n        Returns:\n            A list of computed eigenvalues, sorted in nondecreasing order.\n        \"\"\"\n        A = A_orig.copy().astype(np.float64)\n        n = A.shape[0]\n        m = n\n        eigenvalues = []\n        total_iters = 0\n\n        while m > 0:\n            if total_iters >= max_iter:\n                # Iteration cap reached, return current diagonal entries of active block.\n                for i in range(m):\n                    eigenvalues.append(A[i, i])\n                break\n\n            if m == 1:\n                eigenvalues.append(A[0, 0])\n                m = 0\n                continue\n\n            # Check for deflation at the bottom of the active submatrix\n            sub_diag_val = A[m - 1, m - 2]\n            diag1 = A[m - 2, m - 2]\n            diag2 = A[m - 1, m - 1]\n            \n            # The deflation criterion check. The epsilon is to prevent division by zero in rare cases.\n            if abs(sub_diag_val) <= tol * (abs(diag1) + abs(diag2)) + np.finfo(float).eps:\n                eigenvalues.append(diag2)\n                m -= 1\n                # After deflation, we might be able to deflate again, so continue the loop\n                continue\n\n            # No deflation, perform a shifted QR step on the active m x m submatrix\n            active_block = A[:m, :m]\n\n            # Calculate the Wilkinson shift from the trailing 2x2 submatrix\n            d = active_block[m - 1, m - 1]\n            a = active_block[m - 2, m - 2]\n            b = active_block[m - 1, m - 2]\n            \n            delta = (a - d) / 2.0\n            \n            if delta == 0.0:\n                 # Handle the case where the denominator in the main formula would be zero.\n                 # This can happen if delta is zero. Eigenvalues are d +/- |b|.\n                 # Convention is to pick one, e.g., the one further from d.\n                 mu = d - abs(b)\n            else:\n                 # Numerically stable formula for the eigenvalue of the 2x2 submatrix closer to d.\n                 mu = d - (b**2) / (delta + np.sign(delta) * np.sqrt(delta**2 + b**2))\n\n            # Perform the QR decomposition and update step\n            I = np.identity(m)\n            Q, R = scipy.linalg.qr(active_block - mu * I, mode='full')\n            \n            updated_block = R @ Q + mu * I\n            \n            # Enforce symmetry to counteract floating-point errors\n            A[:m, :m] = (updated_block + updated_block.T) / 2.0\n            \n            total_iters += 1\n            \n        return sorted(eigenvalues)\n\n    # Numerical requirements and constraints from the problem\n    tau = 1e-12\n    K_max = 10000\n\n    # Test suite\n    test_cases = [\n        np.array([[4, 1, 0], \n                  [1, 3, 1], \n                  [0, 1, 2]]),\n        \n        np.array([[2, -1, 0, 0, 0], \n                  [-1, 2, -1, 0, 0], \n                  [0, -1, 2, -1, 0], \n                  [0, 0, -1, 2, -1], \n                  [0, 0, 0, -1, 2]]),\n        \n        np.array([[2, 1e-12], \n                  [1e-12, 2]]),\n        \n        np.array([[7]])\n    ]\n\n    results = []\n    for A in test_cases:\n        eigs = qr_eigenvalues(A, tol=tau, max_iter=K_max)\n        rounded_eigs = [round(val, 8) for val in eigs]\n        results.append(rounded_eigs)\n\n    # Format the final output as a single-line string\n    print(f\"[[{', '.join(map(str, results[0]))}], [{', '.join(map(str, results[1]))}], [{', '.join(map(str, results[2]))}], [{', '.join(map(str, results[3]))}]]\")\n\nsolve()\n```"
        }
    ]
}