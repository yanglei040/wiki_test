{
    "hands_on_practices": [
        {
            "introduction": "本实践聚焦于一个核心数值方法——带位移的反迭代法，用于寻找矩阵的特定特征对。在许多工程应用中，我们并非对所有特征值都感兴趣，而是更关心最接近某个特定值（如共振频率）的那个特征值。本练习将指导你实现这一强大的算法，包括处理如病态等实际数值问题，以开发一个稳健的特征求解器 。",
            "id": "2442752",
            "problem": "实现一个程序，该程序使用带实数位移的反迭代法为多个实数矩阵计算近似的特征对。目标是逼近矩阵 $A$ 的特征值中最接近给定目标共振频率（位移）$\\sigma$ 的那个特征对。程序必须遵循植根于代数特征值问题和谱分解的原则性算法设计。\n\n从以下基本原理开始：\n- 一个实数方阵 $A \\in \\mathbb{R}^{n \\times n}$ 的特征对 $(\\lambda, v)$ 满足 $A v = \\lambda v$，其中 $v \\neq 0$。\n- 如果 $A$ 是可对角化的，则存在一个由特征向量组成的基 $\\{v_i\\}_{i=1}^n$，其对应的特征值为 $\\{\\lambda_i\\}_{i=1}^n$，因此对于任何向量 $x \\in \\mathbb{R}^n$，可以写作 $x = \\sum_{i=1}^n \\alpha_i v_i$。\n- 对于一个实数标量位移 $\\sigma \\in \\mathbb{R}$，若 $A - \\sigma I$ 可逆，则矩阵 $(A - \\sigma I)^{-1}$ 与 $A$ 具有相同的特征向量，其特征值为 $\\{(\\lambda_i - \\sigma)^{-1}\\}_{i=1}^n$。\n\n您必须按如下方式实现带位移 $\\sigma$ 的反迭代法：\n- 在第 $k$ 次迭代中使用位移后的线性系统 $(A - \\sigma I) y^{(k)} = x^{(k-1)}$，其中 $x^{(0)}$ 等于归一化为单位二范数（欧几里得范数）的全一向量。\n- 为了在多次迭代中稳健且高效地求解线性系统，对相同的系数矩阵进行一次 LU（下三角-上三角）分解并复用它。如果 $(A - \\sigma I)$ 是奇异的或数值病态的，则用 $(A - \\sigma I + \\delta I)$ 替换它，其中 $\\delta$ 是序列 $\\{0, 10^{-12}, 10^{-10}, 10^{-8}, 10^{-6}, 10^{-4}\\}$ 中能使其二范数条件数小于 $10^{12}$ 的最小非负数。\n- 在每次迭代中归一化 $x^{(k)} = y^{(k)} / \\| y^{(k)} \\|_2$。\n- 在每次迭代中，计算瑞利商 $\\mu^{(k)} = (x^{(k)})^\\top A x^{(k)}$ 作为特征值估计，并计算残差二范数 $r^{(k)} = \\| A x^{(k)} - \\mu^{(k)} x^{(k)} \\|_2$。\n- 当 $r^{(k)} \\le \\tau$（其中 $\\tau = 10^{-10}$）或迭代次数达到 $k_{\\max} = 100$ 时终止。\n\n您的程序必须为每个测试用例生成最终的特征值估计 $\\mu^{(*)}$，该值应为四舍五入到六位小数的浮点数。特征向量估计无需打印。\n\n本问题不涉及角度单位。没有物理单位；所有计算均在实数算术中进行，输出是无量纲的。\n\n测试套件（矩阵 $A$ 和位移 $\\sigma$）：\n- 情况 $1$（对称三对角）：\n  $$A_1 = \\begin{bmatrix} 4  1  0 \\\\ 1  3  1 \\\\ 0  1  2 \\end{bmatrix}, \\quad \\sigma_1 = 3.2.$$\n- 情况 $2$（上三角，非对称；精确位移奇异性）：\n  $$A_2 = \\begin{bmatrix} 1  2  0 \\\\ 0  3  1 \\\\ 0  0  5 \\end{bmatrix}, \\quad \\sigma_2 = 3.0.$$\n- 情况 $3$（对角矩阵，特征值在位移附近聚集）：\n  $$A_3 = \\operatorname{diag}(2.0, 2.1, 10.0), \\quad \\sigma_3 = 2.08.$$\n- 情况 $4$（对称稠密）：\n  $$A_4 = \\begin{bmatrix} 6  2  1 \\\\ 2  3  1 \\\\ 1  1  1 \\end{bmatrix}, \\quad \\sigma_4 = 6.5.$$\n\n实现要求：\n- 每个测试用例使用对所选系数矩阵的单次 LU（下三角-上三角）分解，并在迭代中复用。\n- 从指定序列中选择最小的 $\\delta$，以确保 $A - \\sigma I + \\delta I$ 的二范数条件数小于 $10^{12}$。如果没有满足此条件的 $\\delta$，则使用最后一个值 $\\delta = 10^{-4}$。\n- 初始化 $x^{(0)}$ 为全一向量，并归一化为单位二范数。整个过程使用实数算术。\n\n最终输出格式：\n- 您的程序应生成单行输出，包含用方括号括起来的逗号分隔的结果列表，例如：\n  $$[\\mu_1,\\mu_2,\\mu_3,\\mu_4],$$\n  其中每个 $\\mu_i$ 是第 $i$ 个情况的最终特征值估计，四舍五入到六位小数，以十进制数表示（而不是分数）。\n\n您的程序必须是自包含的，且不需要任何输入。它必须执行指定的四个测试用例，并严格按照上述格式打印一行。",
            "solution": "该问题是计算线性代数中的一个标准任务：对于一个方阵 $A$，找到一个近似的特征对 $(\\lambda, v)$，其中特征值 $\\lambda$ 最接近一个指定的实数 $\\sigma$（称为位移）。指定的方法是带位移的反迭代算法，这是一种稳健且广泛使用的数值技术。\n\n该方法的基础是矩阵求逆和位移操作下特征值的性质。标准的特征值问题由方程 $A v = \\lambda v$ 定义，其中 $\\lambda$ 是标量特征值， $v$ 是对应的非零特征向量。如果我们考虑一个位移矩阵 $(A - \\sigma I)$，其中 $\\sigma \\in \\mathbb{R}$ 是位移， $I$ 是单位矩阵，其特征值为 $(\\lambda_i - \\sigma)$，其中 $\\{\\lambda_i\\}$ 是 $A$ 的特征值。特征向量保持不变。\n\n假设位移矩阵 $(A - \\sigma I)$ 是可逆的，我们可以考虑它的逆矩阵 $(A - \\sigma I)^{-1}$。这个逆矩阵的特征值是 $(A - \\sigma I)$ 特征值的倒数，即 $\\{(\\lambda_i - \\sigma)^{-1}\\}$。幂迭代法应用于一个矩阵时，会迭代收敛到与模最大的特征值相关联的特征向量。因此，将幂迭代法应用于 $(A - \\sigma I)^{-1}$ 将会收敛到对应于绝对值最大的特征值 $(\\lambda_j - \\sigma)^{-1}$ 的特征向量。这种情况发生在分母 $|\\lambda_j - \\sigma|$ 最小时。因此，该过程分离出了原始矩阵 $A$ 的特征值 $\\lambda_j$（最接近位移 $\\sigma$）所对应的特征向量 $v_j$。这就是位移反转法或带位移的反迭代法的原理。\n\n迭代过程由 $x^{(k)} = c_k (A - \\sigma I)^{-1} x^{(k-1)}$ 给出，其中 $c_k$ 是一个归一化常数。在实践中，计算矩阵的逆在计算上是昂贵的且数值上不稳定。求解等价的线性方程组要高效得多：\n$$\n(A - \\sigma I) y^{(k)} = x^{(k-1)}\n$$\n然后通过对解向量 $y^{(k)}$ 进行归一化来获得新的迭代向量：\n$$\nx^{(k)} = \\frac{y^{(k)}}{\\|y^{(k)}\\|_2}\n$$\n为了在多次迭代中高效地求解线性系统，系数矩阵（我们称之为 $M = A - \\sigma I$）只进行一次分解。问题指定使用 LU 分解。这种分解找到一个下三角矩阵 $L$、一个上三角矩阵 $U$ 和一个置换矩阵 $P$，使得 $PM = LU$。线性系统 $My^{(k)} = x^{(k-1)}$ 于是被重写为 $P^{-1}LU y^{(k)} = x^{(k-1)}$，或 $LU y^{(k)} = P x^{(k-1)}$。这个求解过程分两个阶段：首先，在 $Lz = P x^{(k-1)}$ 中通过前向替换求解 $z$；其次，在 $Uy^{(k)} = z$ 中通过后向替换求解 $y^{(k)}$。这个两步过程比在每次迭代中从头重新求解系统要快得多。\n\n一个关键的考虑是当位移 $\\sigma$ 非常接近或等于 $A$ 的一个特征值时。在这种情况下，矩阵 $M = A - \\sigma I$ 会变得病态或奇异，使得线性系统无法求解或其解对误差高度敏感。问题要求采用一个特定的、稳健的协议来处理这种情况。我们必须计算 $M$ 在二范数下的条件数 $\\kappa_2(M)$。如果 $\\kappa_2(M) \\ge 10^{12}$，则该矩阵被认为是病态的。为了对其进行正则化，我们引入一个小的扰动 $\\delta  0$ 并使用矩阵 $M' = A - \\sigma I + \\delta I$。我们必须从提供的序列 $\\{0, 10^{-12}, 10^{-10}, 10^{-8}, 10^{-6}, 10^{-4}\\}$ 中选择最小的 $\\delta$，使得 $\\kappa_2(M')  10^{12}$。然后对这个正则化后的矩阵 $M'$ 执行 LU 分解。\n\n对于每个测试用例 $(A, \\sigma)$，算法流程如下：\n$1.$ 定义扰动序列 $\\Delta = \\{0, 10^{-12}, 10^{-10}, 10^{-8}, 10^{-6}, 10^{-4}\\}$。\n$2.$ 对于 $\\Delta$ 中的每个 $\\delta$，构造矩阵 $M = A - \\sigma I + \\delta I$。计算其条件数 $\\kappa_2(M)$。选择第一个使得 $\\kappa_2(M)  10^{12}$ 的 $\\delta$，并将这个矩阵 $M$ 用于迭代。如果不存在这样的 $\\delta$，则使用最后一个，即 $\\delta = 10^{-4}$。\n$3.$ 计算所选矩阵 $M$ 的 LU 分解。\n$4.$ 初始化迭代向量 $x^{(0)}$ 为全一向量，并将其归一化，使其欧几里得范数为 $1$。\n$5.$ 对于 $k = 1, 2, \\ldots, k_{\\max}$：\n    a. 使用预先计算的 LU 分解求解线性系统 $M y^{(k)} = x^{(k-1)}$。\n    b. 归一化结果向量：$x^{(k)} = y^{(k)} / \\| y^{(k)} \\|_2$。\n    c. 使用瑞利商计算特征值估计：$\\mu^{(k)} = (x^{(k)})^\\top A x^{(k)}$。\n    d. 计算残差范数：$r^{(k)} = \\| A x^{(k)} - \\mu^{(k)} x^{(k)} \\|_2$。\n    e. 检查收敛性：如果 $r^{(k)} \\le 10^{-10}$，则终止迭代。\n$6.$ 如果达到最大迭代次数 $k_{\\max} = 100$，迭代也会终止。\n$7.$ 最终的特征值估计 $\\mu^{(*)}$ 是最后计算出的 $\\mu^{(k)}$ 的值，然后将其四舍五入到六位小数用于输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Computes an approximate eigenpair for several matrices using inverse iteration with a real shift.\n    - An eigenpair (lambda, v) satisfies A v = lambda v.\n    - Inverse iteration with shift sigma finds the eigenvalue of A closest to sigma.\n    - The method iteratively solves (A - sigma I) y_k = x_{k-1} and normalizes x_k = y_k / ||y_k||.\n    - LU factorization is used for efficient solving of the linear system.\n    - Ill-conditioning is handled by perturbing the matrix with a small delta.\n    \"\"\"\n\n    test_cases = [\n        # Case 1 (symmetric tridiagonal)\n        (np.array([[4, 1, 0], [1, 3, 1], [0, 1, 2]], dtype=float), 3.2),\n        # Case 2 (upper triangular, non-symmetric; exact-shift singularity)\n        (np.array([[1, 2, 0], [0, 3, 1], [0, 0, 5]], dtype=float), 3.0),\n        # Case 3 (diagonal, clustered eigenvalues near the shift)\n        (np.diag([2.0, 2.1, 10.0]), 2.08),\n        # Case 4 (symmetric dense)\n        (np.array([[6, 2, 1], [2, 3, 1], [1, 1, 1]], dtype=float), 6.5)\n    ]\n\n    results = []\n    \n    # Constants defined in the problem\n    k_max = 100\n    tau = 1e-10\n    cond_threshold = 1e12\n    deltas = [0, 1e-12, 1e-10, 1e-8, 1e-6, 1e-4]\n\n    for A, sigma in test_cases:\n        n = A.shape[0]\n        I = np.identity(n)\n        \n        # Step 1: Select coefficient matrix M by handling ill-conditioning\n        M = None\n        chosen_delta = None\n        \n        for delta in deltas:\n            M_candidate = A - sigma * I + delta * I\n            # The problem specifies condition number in the two-norm\n            cond_num = np.linalg.cond(M_candidate, p=2)\n            \n            if cond_num  cond_threshold:\n                M = M_candidate\n                chosen_delta = delta\n                break\n        \n        # If no delta satisfied the condition, use the last one\n        if M is None:\n            delta = deltas[-1]\n            M = A - sigma * I + delta * I\n            chosen_delta = delta\n            \n        # Step 2: Perform LU factorization once\n        lu_factor = linalg.lu_factor(M)\n        \n        # Step 3: Initialize the vector x_0\n        x = np.ones(n, dtype=float)\n        x = x / np.linalg.norm(x, 2)\n        \n        mu_final = 0.0\n        \n        # Step 4: Inverse Iteration Loop\n        for k in range(k_max):\n            # Solve (A - sigma*I + delta*I) y_k = x_{k-1} using LU decomposition\n            y = linalg.lu_solve(lu_factor, x)\n            \n            # Normalize to get the next iterate x_k\n            x = y / np.linalg.norm(y, 2)\n            \n            # Compute Rayleigh quotient as eigenvalue estimate\n            mu = (x.T @ A @ x)\n            mu_final = mu\n            \n            # Compute residual norm for convergence check\n            residual_norm = np.linalg.norm(A @ x - mu * x, 2)\n            \n            # Termination condition\n            if residual_norm = tau:\n                break\n        \n        results.append(round(mu_final, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "特征值不仅仅是矩阵的静态属性，它们对于理解系统的动态行为至关重要。本实践将探讨放大矩阵的特征值如何决定用于求解微分方程的数值方法的稳定性。通过分析谱半径，你将获得预测模拟是会保持稳定还是会发散的实践经验，这是计算建模中的一项基本技能 。",
            "id": "2442744",
            "problem": "考虑线性自治系统 $ \\dot{\\mathbf{u}}(t) = A \\mathbf{u}(t) $，其中 $ A \\in \\mathbb{C}^{n \\times n} $。步长为 $ \\Delta t \\in \\mathbb{R}_{0} $ 的显式前向 Euler 时间步进格式产生递推关系 $ \\mathbf{u}^{k+1} = G \\mathbf{u}^{k} $，其放大矩阵为\n$$\nG = I + \\Delta t \\, A,\n$$\n其中 $ I $ 是大小为 $ n $ 的单位矩阵。令 $ \\{ \\lambda_i(G) \\}_{i=1}^n $ 表示 $ G $ 的特征值，并定义谱半径为\n$$\n\\rho(G) = \\max_{1 \\le i \\le n} |\\lambda_i(G)|.\n$$\n\n对该显式格式的线性不稳定性采用以下数学上精确的分类标准：\n- 如果 $ \\rho(G)  1 $，则声明该格式“不稳定”。\n- 如果 $ \\rho(G) = 1 $，当且仅当 $ G $ 在 $ \\mathbb{C} $ 上不可对角化时，声明该格式“不稳定”。\n- 否则，声明该格式“非不稳定”。\n\n所有涉及与 $ 1 $ 相等和可对角化性的判断都必须使用容差 $ \\varepsilon = 10^{-10} $ 来考虑有限精度，具体如下：\n- 如果 $ |x - 1| \\le \\varepsilon $，则视实数 $ x $ 等于 $ 1 $。\n- 如果 $ \\rho(G) \\ge 1 + \\varepsilon $，则视 $ \\rho(G)  1 $。\n- 如果 $ \\rho(G) \\le 1 - \\varepsilon $，则视 $ \\rho(G)  1 $。\n- 当且仅当特征向量矩阵具有满列秩 $ n $（秩检验使用容差 $ \\varepsilon $ 进行评估）时，视 $ G $ 在 $ \\mathbb{C} $ 上可对角化。\n\n对于下方的每个测试用例，计算：\n$ (i) $ 谱半径 $ \\rho(G) $，\n$ (ii) $ 一个布尔标志，指示根据上述标准该格式是否不稳定，以及\n$ (iii) $ 一个布尔标志，指示 $ G $ 是否在 $ \\mathbb{C} $ 上可对角化。\n\n测试套件（每个用例为一对 $ (A, \\Delta t) $，其中 $ A \\in \\mathbb{R}^{2 \\times 2} $ 且 $ \\Delta t \\in \\mathbb{R}_{0} $）：\n- 用例 $ 1 $：\n$$\nA_1 = \\begin{bmatrix} -2  0 \\\\ 0  -5 \\end{bmatrix}, \\quad \\Delta t_1 = 0.2.\n$$\n- 用例 $ 2 $：\n$$\nA_2 = \\begin{bmatrix} 0  1 \\\\ 1  0 \\end{bmatrix}, \\quad \\Delta t_2 = 0.6.\n$$\n- 用例 $ 3 $：\n$$\nA_3 = \\begin{bmatrix} 0  1 \\\\ 0  0 \\end{bmatrix}, \\quad \\Delta t_3 = 0.5.\n$$\n- 用例 $ 4 $：\n$$\nA_4 = \\begin{bmatrix} -4  0 \\\\ 0  0 \\end{bmatrix}, \\quad \\Delta t_4 = 0.5.\n$$\n\n最终输出格式：\n您的程序必须生成单行输出，其中包含按顺序排列的 $ 4 $ 个测试用例的结果列表。每个测试用例的结果必须是列表 $ [\\rho(G),\\ \\text{is\\_unstable},\\ \\text{is\\_diagonalizable}] $。整个输出必须是包含这 $ 4 $ 个列表的单个方括号列表，打印在一行上，无额外文本。例如，包含 $ 2 $ 个用例的输出应如下所示：\n[[1.0,False,True],[1.2,True,True]]",
            "solution": "该问题要求对线性常微分方程组 $ \\dot{\\mathbf{u}}(t) = A \\mathbf{u}(t) $ 的显式前向 Euler 方法进行稳定性分析。需要对给定的几个测试用例执行此分析。\n\n前向 Euler 格式通过有限差分来近似时间导数，$ \\dot{\\mathbf{u}}(t) \\approx (\\mathbf{u}^{k+1} - \\mathbf{u}^{k}) / \\Delta t $，其中 $ \\mathbf{u}^k $ 表示在时间 $ t_k = k \\Delta t $ 处的数值解，$ \\Delta t $ 是时间步长。将此代入控制微分方程，得到递推关系：\n$$ \\frac{\\mathbf{u}^{k+1} - \\mathbf{u}^{k}}{\\Delta t} = A \\mathbf{u}^{k} $$\n$$ \\mathbf{u}^{k+1} = \\mathbf{u}^{k} + \\Delta t A \\mathbf{u}^{k} = (I + \\Delta t A) \\mathbf{u}^{k} $$\n矩阵 $ G = I + \\Delta t A $ 是放大矩阵，它将第 $ k $ 步的解映射到第 $ k+1 $ 步。数值格式的稳定性由该矩阵 $ G $ 的性质决定。\n\n当 $ k \\to \\infty $ 时，解的行为由 $ G $ 的特征值决定。如果 $ \\left\\{ \\mu_j \\right\\}_{j=1}^n $ 是矩阵 $ A $ 的特征值，那么 $ G $ 的特征值（记为 $ \\left\\{ \\lambda_j \\right\\}_{j=1}^n $）由关系式 $ \\lambda_j = 1 + \\Delta t \\, \\mu_j $ 给出。该格式的稳定性取决于这些特征值的模。\n\n该问题指定了一套精确的标准，用于根据 $ G $ 的谱半径 $ \\rho(G) = \\max_j |\\lambda_j(G)| $ 及其可对角化性来分类格式的稳定性。所有浮点数比较都强制要求使用 $ \\varepsilon = 10^{-10} $ 的数值容差。\n\n稳定性标准如下：\n1. 如果 $ \\rho(G) \\ge 1 + \\varepsilon $，则该格式被声明为“不稳定”。至少有一个特征值位于复平面的单位圆外，导致数值解呈指数增长。\n2. 如果 $ |\\rho(G) - 1| \\le \\varepsilon $，则稳定性取决于 $ G $ 的特征空间的结构。\n    - 如果 $ G $ 不可对角化，它对模为 $1$ 的特征值拥有至少一个尺寸大于 $1$ 的 Jordan 块。这会导致长期增长（例如，形如 $ c k \\lambda^k $），该格式是“不稳定”的。\n    - 如果 $ G $ 可对角化，所有模为 $1$ 的特征值对应的模式都是非增长的，该格式是“非不稳定”的。\n3. 如果 $ \\rho(G) \\le 1 - \\varepsilon $，所有特征值都严格位于单位圆内，确保数值解衰减至零。该格式是“非不稳定”的。\n\n一个矩阵 $ G \\in \\mathbb{C}^{n \\times n} $ 可对角化的充要条件是它拥有一组 $ n $ 个线性无关的特征向量。这等价于其特征向量矩阵 $V$ 具有满秩，即 $ \\text{rank}(V) = n $。在数值上，通过计算 $V$ 的奇异值中大于给定容差 $ \\varepsilon $ 的数量，可以稳健地计算秩。\n\n现在我们根据这些原则分析每个测试用例。\n\n**用例 1:** $ A_1 = \\begin{bmatrix} -2  0 \\\\ 0  -5 \\end{bmatrix} $, $ \\Delta t_1 = 0.2 $。\n- 放大矩阵为 $ G_1 = I + 0.2 A_1 = \\begin{bmatrix} 1+0.2(-2)  0 \\\\ 0  1+0.2(-5) \\end{bmatrix} = \\begin{bmatrix} 0.6  0 \\\\ 0  0 \\end{bmatrix} $。\n- 这个对角矩阵的特征值可见于对角线上：$ \\lambda_1 = 0.6 $ 和 $ \\lambda_2 = 0 $。\n- 谱半径为 $ \\rho(G_1) = \\max(|0.6|, |0|) = 0.6 $。\n- 由于 $ 0.6 \\le 1 - \\varepsilon $，该格式“非不稳定”。\n- $G_1$ 是一个对角矩阵，所有对角矩阵都是可对角化的。\n- 结果：$ [\\rho(G_1) = 0.6, \\text{is\\_unstable} = \\text{False}, \\text{is\\_diagonalizable} = \\text{True}] $。\n\n**用例 2:** $ A_2 = \\begin{bmatrix} 0  1 \\\\ 1  0 \\end{bmatrix} $, $ \\Delta t_2 = 0.6 $。\n- 放大矩阵为 $ G_2 = I + 0.6 A_2 = \\begin{bmatrix} 1  0.6 \\\\ 0.6  1 \\end{bmatrix} $。\n- 特征方程是 $ \\det(G_2 - \\lambda I) = (1-\\lambda)^2 - 0.6^2 = 0 $，这给出了特征值 $ \\lambda = 1 \\pm 0.6 $。因此，$ \\lambda_1 = 1.6 $ 和 $ \\lambda_2 = 0.4 $。\n- 谱半径为 $ \\rho(G_2) = \\max(|1.6|, |0.4|) = 1.6 $。\n- 由于 $ 1.6 \\ge 1 + \\varepsilon $，该格式“不稳定”。\n- $G_2$ 是一个实对称矩阵，这保证了它在 $ \\mathbb{R} $ 上可对角化，因此在 $ \\mathbb{C} $ 上也可对角化。\n- 结果：$ [\\rho(G_2) = 1.6, \\text{is\\_unstable} = \\text{True}, \\text{is\\_diagonalizable} = \\text{True}] $。\n\n**用例 3:** $ A_3 = \\begin{bmatrix} 0  1 \\\\ 0  0 \\end{bmatrix} $, $ \\Delta t_3 = 0.5 $。\n- 放大矩阵为 $ G_3 = I + 0.5 A_3 = \\begin{bmatrix} 1  0.5 \\\\ 0  1 \\end{bmatrix} $。\n- 这个矩阵是上三角矩阵，所以其特征值是其对角线元素：$ \\lambda_1 = \\lambda_2 = 1 $。\n- 谱半径为 $ \\rho(G_3) = |1| = 1.0 $。\n- 我们现在评估其可对角化性。对于 $ \\lambda=1 $ 的特征空间是 $ G_3 - 1I = \\begin{bmatrix} 0  0.5 \\\\ 0  0 \\end{bmatrix} $ 的零空间。方程 $ (G_3 - I)\\mathbf{v} = \\mathbf{0} $ 要求 $ 0.5 v_2 = 0 $。这意味着特征空间由单个向量 $ [1, 0]^T $ 张成。几何重数（$1$）小于代数重数（$2$），因此矩阵 $ G_3 $ 不可对角化。\n- 根据标准，由于 $ \\rho(G_3) = 1 $ 且 $ G_3 $ 不可对角化，该格式“不稳定”。\n- 结果：$ [\\rho(G_3) = 1.0, \\text{is\\_unstable} = \\text{True}, \\text{is\\_diagonalizable} = \\text{False}] $。\n\n**用例 4:** $ A_4 = \\begin{bmatrix} -4  0 \\\\ 0  0 \\end{bmatrix} $, $ \\Delta t_4 = 0.5 $。\n- 放大矩阵为 $ G_4 = I + 0.5 A_4 = \\begin{bmatrix} 1+0.5(-4)  0 \\\\ 0  1+0.5(0) \\end{bmatrix} = \\begin{bmatrix} -1  0 \\\\ 0  1 \\end{bmatrix} $。\n- 特征值为 $ \\lambda_1 = -1 $ 和 $ \\lambda_2 = 1 $。\n- 谱半径为 $ \\rho(G_4) = \\max(|-1|, |1|) = 1.0 $。\n- $G_4$ 是一个对角矩阵，因此是可对角化的。\n- 由于 $ \\rho(G_4) = 1 $ 且 $ G_4 $ 可对角化，该格式“非不稳定”。\n- 结果：$ [\\rho(G_4) = 1.0, \\text{is\\_unstable} = \\text{False}, \\text{is\\_diagonalizable} = \\text{True}] $。\n\n结果是基于这些推导通过算法计算得出的。",
            "answer": "```python\nimport numpy as np\n\ndef analyze_stability(A, dt, epsilon):\n    \"\"\"\n    Analyzes the stability of the forward Euler scheme for a given matrix A and time step dt.\n\n    Args:\n        A (np.ndarray): The matrix from the ODE system.\n        dt (float): The time step size.\n        epsilon (float): The tolerance for floating-point comparisons.\n\n    Returns:\n        list: A list containing [rho(G), is_unstable, is_diagonalizable].\n    \"\"\"\n    n = A.shape[0]\n    I = np.identity(n)\n    G = I + dt * A\n\n    # (i) Compute eigenvalues of G and its spectral radius\n    eigenvalues_G = np.linalg.eigvals(G)\n    rho_G = np.max(np.abs(eigenvalues_G))\n\n    # (iii) Check diagonalizability of G\n    # A matrix is diagonalizable if and only if it has a full set of n linearly independent eigenvectors.\n    # We compute the eigenvector matrix V and check its rank.\n    # The rank is determined by counting singular values greater than the tolerance.\n    _, V = np.linalg.eig(G)\n    singular_values = np.linalg.svd(V, compute_uv=False)\n    rank_V = np.sum(singular_values > epsilon)\n    is_diagonalizable = (rank_V == n)\n\n    # (ii) Determine instability based on the given criteria\n    is_unstable = False\n    if rho_G >= 1 + epsilon:\n        is_unstable = True\n    elif np.abs(rho_G - 1) = epsilon:\n        if not is_diagonalizable:\n            is_unstable = True\n    # Otherwise, rho_G is = 1 - epsilon, for which the scheme is \"not unstable\".\n\n    return [rho_G, is_unstable, is_diagonalizable]\n\ndef solve():\n    \"\"\"\n    Main function to run the analysis for all test cases and print the results.\n    \"\"\"\n    epsilon = 1e-10\n\n    # Test cases defined in the problem statement\n    test_cases = [\n        (np.array([[-2.0, 0.0], [0.0, -5.0]]), 0.2), # Case 1\n        (np.array([[0.0, 1.0], [1.0, 0.0]]), 0.6),   # Case 2\n        (np.array([[0.0, 1.0], [0.0, 0.0]]), 0.5),   # Case 3\n        (np.array([[-4.0, 0.0], [0.0, 0.0]]), 0.5),   # Case 4\n    ]\n\n    results = []\n    for A, dt in test_cases:\n        result = analyze_stability(A, dt, epsilon)\n        results.append(result)\n\n    # Format the output string as required by the problem.\n    # e.g., [[rho1,False,True],[rho2,True,True]]\n    # Python's str() for booleans produces capitalized True/False, which matches the example.\n    # The list-to-string conversion with f-strings and join creates the exact format.\n    inner_lists_str = [f\"[{res[0]},{res[1]},{res[2]}]\" for res in results]\n    final_output_str = f\"[{','.join(inner_lists_str)}]\"\n\n    print(final_output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "谱分解通过将复杂系统分解为基本模式，为分析和操控这些系统提供了强大的框架。这项高级实践将此概念应用于一个机械振动问题，你将设计一个“谱滤波器”以移除不想要的振动模式。你将处理广义特征值问题以及在自定义内积空间中的投影，展示如何通过在模态坐标中操作来精确控制系统行为 。",
            "id": "2442802",
            "problem": "一个有限维、无阻尼的机械系统，其质量矩阵 $M \\in \\mathbb{R}^{n \\times n}$ 和刚度矩阵 $K \\in \\mathbb{R}^{n \\times n}$ 均为对称正定（SPD）矩阵，其微小自由振动由以下代数广义特征值问题描述：求解非零向量 $v \\in \\mathbb{R}^{n}$ 和标量 $\\lambda \\in \\mathbb{R}$，使得 $K v = \\lambda M v$。在计算工程中，振动模态是该问题的特征向量，并且可以使用一组由特征向量构成的 $M$-正交归一基进行谱分解。\n\n你的任务是设计一个谱滤波器，通过在 $M$-内积下的投影来移除一组指定的振动模态，并仅使用线性代数中的基本定义：\n\n- 向量 $x,y \\in \\mathbb{R}^{n}$ 的 $M$-内积为 $\\langle x, y \\rangle_{M} = x^{\\mathsf{T}} M y$。\n- 一组特征向量 $\\{v_{i}\\}_{i=1}^{n}$ 可以被选择为 $M$-正交归一的，使得 $v_{i}^{\\mathsf{T}} M v_{j} = \\delta_{ij}$，其中 $\\delta_{ij}$ 是克罗内克（Kronecker）δ。\n- 相对于一个内积，到某个子空间上的投影算子是线性的、幂等的（即 $P^{2} = P$），并且它使目标子空间中的向量保持不变，同时将其正交补（通过该内积定义）中的向量湮灭。\n\n从这些定义出发（不引入任何未经证明的快捷公式），推导出作为谱滤波器的线性算子。该算子移除一个向量沿着选定特征向量子集的分量（相对于 $M$-内积），并保持在该子集的 $M$-正交补中的分量不变。然后，通过计算广义特征分解、选择适当的特征向量并应用你推导出的投影，来通过算法实现它。\n\n使用以下特定的无量纲矩阵和数据，以实现一个完全指定且可测试的实现：\n\n- 维度 $n = 4$。\n- 质量矩阵\n$$\nM = \\begin{bmatrix}\n2   0   0   0 \\\\\n0   1   0   0 \\\\\n0   0   1.5   0 \\\\\n0   0   0   1.2\n\\end{bmatrix}.\n$$\n- 刚度矩阵\n$$\nK = \\begin{bmatrix}\n2   -1   0   0 \\\\\n-1   2   -1   0 \\\\\n0   -1   2   -1 \\\\\n0   0   -1   2\n\\end{bmatrix}.\n$$\n- 设广义特征对 $(\\lambda_{i}, v_{i})$ 按特征值 $\\lambda_{i}$ 升序排列，索引为 $i \\in \\{0,1,2,3\\}$。确保你的特征向量被缩放，以满足对所有 $i$ 有 $v_{i}^{\\mathsf{T}} M v_{i} = 1$，以及对 $i \\neq j$ 有 $v_{i}^{\\mathsf{T}} M v_{j} = 0$。\n\n对于下方的每个测试用例，你必须：\n- 构建谱滤波器，以移除由索引集 $S$ 指示的模态集合。\n- 将该滤波器应用于给定的输入向量 $u$，得到滤波后的向量 $\\hat{u}$。\n- 计算所要求的标量诊断值。\n\n测试套件（涵盖典型情况、混合模态移除和两个边界情况）：\n\n- 测试用例 1：$u = \\begin{bmatrix}1 \\\\ 0 \\\\ 0 \\\\ 0\\end{bmatrix}$，$S = \\{0\\}$。输出标量\n$$\nr_{1} = \\max_{i \\in S} \\left| \\alpha_{i} \\right|, \\quad \\text{其中 } \\alpha = V^{\\mathsf{T}} M \\hat{u} \\text{ 是滤波后的模态坐标，且 } V = [v_{0}\\ v_{1}\\ v_{2}\\ v_{3}]。\n$$\n- 测试用例 2：$u = \\begin{bmatrix}1 \\\\ 2 \\\\ -1 \\\\ 0.5\\end{bmatrix}$，$S = \\{0,2\\}$。输出标量\n$$\nr_{2} = \\max_{i \\in S} \\left| \\alpha_{i} \\right| \\text{，按上述方式计算}。\n$$\n- 测试用例 3（边界情况：不移除任何模态）：$u = \\begin{bmatrix}-0.2 \\\\ 0.4 \\\\ 0.6 \\\\ -0.8\\end{bmatrix}$，$S = \\varnothing$。输出标量\n$$\nr_{3} = \\left\\| \\hat{u} - u \\right\\|_{2}。\n$$\n- 测试用例 4（边界情况：移除所有模态）：$u = \\begin{bmatrix}3 \\\\ -1 \\\\ 0.5 \\\\ 2\\end{bmatrix}$，$S = \\{0,1,2,3\\}$。输出标量\n$$\nr_{4} = \\left\\| \\hat{u} \\right\\|_{2}。\n$$\n\n你的程序应产生单行输出，包含一个用方括号括起来的逗号分隔列表（例如，$[r_{1},r_{2},r_{3},r_{4}]$）。所有计算都是无量纲的；无需报告物理单位。$r_{1}$、$r_{2}$、$r_{3}$ 和 $r_{4}$ 的最终数值答案必须是你的程序计算出的浮点数。设计必须是通用的，并严格基于上述基本原理和定义，而非本声明中任何预先提供的投影公式。",
            "solution": "问题陈述已经过严格评估，被认为是有效的。它具有科学依据，提法恰当，并包含了获得唯一且有意义解所需的所有信息。我们将着手进行推导和实现。\n\n基本背景是一个有限维向量空间 $\\mathbb{R}^n$，其上装备了一个由对称正定（SPD）质量矩阵 $M$ 定义的内积。这就是 $M$-内积，对于任意向量 $x,y \\in \\mathbb{R}^n$ 均由 $\\langle x, y \\rangle_M = x^{\\mathsf{T}} M y$ 给出。\n\n对于对称矩阵 $K$ 和对称正定矩阵 $M$ 的广义特征值问题 $K v = \\lambda M v$，保证了存在 $n$ 个实特征值 $\\lambda_i$ 和一组相应的特征向量 $\\{v_i\\}_{i=0}^{n-1}$。这些特征向量可以被选择来构成 $\\mathbb{R}^n$ 的一个 $M$-正交归一基。这意味着它们满足条件 $\\langle v_i, v_j \\rangle_M = v_i^{\\mathsf{T}} M v_j = \\delta_{ij}$，其中 $\\delta_{ij}$ 是克罗内克（Kronecker）δ。\n\n任何向量 $u \\in \\mathbb{R}^n$ 都可以唯一地表示为这些基向量的线性组合：\n$$\nu = \\sum_{i=0}^{n-1} \\alpha_i v_i\n$$\n系数 $\\alpha_i$ 被称为 $u$ 的模态坐标，它们是通过使用 $M$-内积将 $u$ 投影到每个基向量上来确定的。将上述方程与一个基向量 $v_j$ 作 $M$-内积：\n$$\n\\langle u, v_j \\rangle_M = \\left\\langle \\sum_{i=0}^{n-1} \\alpha_i v_i, v_j \\right\\rangle_M\n$$\n根据内积的线性性质，这变为：\n$$\n\\langle u, v_j \\rangle_M = \\sum_{i=0}^{n-1} \\alpha_i \\langle v_i, v_j \\rangle_M = \\sum_{i=0}^{n-1} \\alpha_i \\delta_{ij} = \\alpha_j\n$$\n因此，第 $j$ 个模态坐标为 $\\alpha_j = \\langle u, v_j \\rangle_M = u^{\\mathsf{T}} M v_j$。\n\n任务是设计一个谱滤波器，移除向量 $u$ 中对应于由集合 $S$ 索引的指定模态组的分量。设 $V_S$ 是由待移除的特征向量 $\\{v_i\\}_{i \\in S}$ 张成的子空间，设 $V_{S^\\perp}$ 是其 $M$-正交补，由待保留的特征向量 $\\{v_j\\}_{j \\notin S}$ 张成。\n$$\nV_S = \\text{span}\\{v_i \\mid i \\in S\\}\n$$\n$$\nV_{S^\\perp} = \\text{span}\\{v_j \\mid j \\notin S\\}\n$$\n空间 $\\mathbb{R}^n$ 是这两个子空间的直和，即 $\\mathbb{R}^n = V_S \\oplus V_{S^\\perp}$。因此，任何向量 $u$ 都可以唯一地分解为 $u = u_S + u_{S^\\perp}$，其中 $u_S \\in V_S$ 且 $u_{S^\\perp} \\in V_{S^\\perp}$。根据模态展开，这些分量是：\n$$\nu_S = \\sum_{i \\in S} \\alpha_i v_i \\quad \\text{和} \\quad u_{S^\\perp} = \\sum_{j \\notin S} \\alpha_j v_j\n$$\n问题要求滤波器“移除”在 $V_S$ 中的分量，并“保持不变”在 $V_{S^\\perp}$ 中的分量。这正是关于 $M$-内积到子空间 $V_{S^\\perp}$ 上的投影的定义。设此投影算子为 $P$。因此，滤波后的向量 $\\hat{u}$ 由 $\\hat{u} = P(u)$ 给出。\n\n根据定义，$u$ 到 $V_{S^\\perp}$ 上的投影是向量 $\\hat{u} \\in V_{S^\\perp}$，使得误差向量 $u - \\hat{u}$ 与 $V_{S^\\perp}$ 中的每个向量都是 $M$-正交的。\n由于 $\\hat{u} \\in V_{S^\\perp}$，它可以展开为 $\\hat{u} = \\sum_{j \\notin S} \\beta_j v_j$ 的形式，其中 $\\beta_j$ 为某些系数。\n正交条件是对于所有 $k \\notin S$，有 $\\langle u - \\hat{u}, v_k \\rangle_M = 0$。\n代入 $u$ 和 $\\hat{u}$ 的展开式：\n$$\n\\left\\langle \\sum_{i=0}^{n-1} \\alpha_i v_i - \\sum_{j \\notin S} \\beta_j v_j, v_k \\right\\rangle_M = 0 \\quad \\text{for } k \\notin S\n$$\n利用线性和 $M$-正交归一性：\n$$\n\\alpha_k - \\beta_k = 0 \\implies \\beta_k = \\alpha_k \\quad \\text{for all } k \\notin S\n$$\n这表明投影向量在基 $\\{v_j\\}_{j \\notin S}$ 下的系数就是原始的模态坐标 $\\alpha_j$。因此，滤波后的向量是：\n$$\n\\hat{u} = \\sum_{j \\notin S} \\alpha_j v_j\n$$\n为了构造算子 $P$ 使得 $\\hat{u} = P u$，我们代入 $\\alpha_j$ 的表达式：\n$$\n\\hat{u} = \\sum_{j \\notin S} (v_j^{\\mathsf{T}} M u) v_j = \\sum_{j \\notin S} v_j (v_j^{\\mathsf{T}} M u) = \\left( \\sum_{j \\notin S} v_j v_j^{\\mathsf{T}} M \\right) u\n$$\n因此，谱滤波算子的显式矩阵形式为：\n$$\nP = \\sum_{j \\notin S} v_j v_j^{\\mathsf{T}} M\n$$\n该算子是线性的、幂等的（$P^2=P$），并将任何向量投影到子空间 $V_{S^\\perp}$ 上，其方向沿着它的 $M$-正交补 $V_S$，这符合要求。\n\n在算法上，构建并应用矩阵 $P$ 的效率不高。一个更直接的步骤是：\n1.  求解广义特征值问题 $K v = \\lambda M v$，找到特征值 $\\lambda_i$ 和 $M$-正交归一的特征向量矩阵 $V = [v_0, v_1, \\dots, v_{n-1}]$。\n2.  对于给定的输入向量 $u$，计算其完整的模态坐标向量：$\\alpha = V^{\\mathsf{T}} M u$。\n3.  通过将要移除的模态（即 $i \\in S$）对应的坐标设置为零来构建滤波后的模态坐标向量 $\\hat{\\alpha}$：如果 $i \\in S$，则 $\\hat{\\alpha}_i = 0$；如果 $i \\notin S$，则 $\\hat{\\alpha}_i = \\alpha_i$。\n4.  通过乘以特征向量矩阵来重构滤波后的向量：$\\hat{u} = V \\hat{\\alpha}$。\n\n将此逻辑应用于具体的测试用例：\n- 对于测试用例1和2，我们对向量 $u$ 进行滤波得到 $\\hat{u}$。诊断值为 $r = \\max_{i \\in S} |(V^{\\mathsf{T}} M \\hat{u})_i|$。由于 $V^{\\mathsf{T}} M \\hat{u} = V^{\\mathsf{T}} M (V \\hat{\\alpha}) = (V^{\\mathsf{T}} M V) \\hat{\\alpha} = I \\hat{\\alpha} = \\hat{\\alpha}$，并且我们已明确地将所有 $i \\in S$ 的 $\\hat{\\alpha}_i$ 设置为 0，因此该诊断值必须为 0。\n- 对于测试用例3，$S = \\varnothing$。没有模态被移除。算子 $P$ 是单位算子，所以 $\\hat{u} = u$。因此，诊断值 $r_3 = \\|\\hat{u} - u\\|_2$ 必须为 0。\n- 对于测试用例4，$S = \\{0, 1, 2, 3\\}$。所有模态都被移除。算子 $P$ 是零算子，所以 $\\hat{u} = 0$。因此，诊断值 $r_4 = \\|\\hat{u}\\|_2$ 必须为 0。\n\n该实现将展示这些理论推论。数值结果应为零，或由于浮点运算而处于机器精度量级的值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef solve():\n    \"\"\"\n    Solves the spectral filtering problem by deriving and applying a projection operator.\n    \"\"\"\n    # Define problem parameters for n=4 as specified.\n    M = np.array([\n        [2.0, 0.0, 0.0, 0.0],\n        [0.0, 1.0, 0.0, 0.0],\n        [0.0, 0.0, 1.5, 0.0],\n        [0.0, 0.0, 0.0, 1.2]\n    ])\n\n    K = np.array([\n        [2.0, -1.0, 0.0, 0.0],\n        [-1.0, 2.0, -1.0, 0.0],\n        [0.0, -1.0, 2.0, -1.0],\n        [0.0, 0.0, -1.0, 2.0]\n    ])\n\n    # Define the test suite.\n    test_cases = [\n        {'u': np.array([1.0, 0.0, 0.0, 0.0]), 'S': {0}},\n        {'u': np.array([1.0, 2.0, -1.0, 0.5]), 'S': {0, 2}},\n        {'u': np.array([-0.2, 0.4, 0.6, -0.8]), 'S': set()},\n        {'u': np.array([3.0, -1.0, 0.5, 2.0]), 'S': {0, 1, 2, 3}},\n    ]\n\n    # Step 1: Solve the generalized eigenvalue problem Kv = lambda*M*v.\n    # eigh returns eigenvalues in ascending order and M-orthonormal eigenvectors.\n    # That is, for eigenvectors V, the condition V.T @ M @ V = I holds.\n    eigenvalues, V = eigh(K, b=M)\n    \n    results = []\n\n    for i, case in enumerate(test_cases):\n        u = case['u']\n        S = case['S']\n        \n        # Step 2: Compute the full vector of modal coordinates.\n        alpha = V.T @ M @ u\n        \n        # Step 3: Filter by setting modal coordinates in S to zero.\n        alpha_hat = alpha.copy()\n        if S: # If S is not empty\n            indices_to_remove = list(S)\n            alpha_hat[indices_to_remove] = 0.0\n            \n        # Step 4: Reconstruct the filtered vector.\n        u_hat = V @ alpha_hat\n\n        # Compute the requested scalar diagnostic for each test case.\n        if i == 0 or i == 1: # Test cases 1 and 2\n            # Diagnostic: max(|alpha_i|) for i in S, where alpha are modal coordinates of u_hat.\n            # As derived, modal coordinates of u_hat are alpha_hat.\n            alpha_post_filter = V.T @ M @ u_hat\n            indices_to_check = list(S)\n            result = np.max(np.abs(alpha_post_filter[indices_to_check]))\n            results.append(result)\n\n        elif i == 2: # Test case 3\n            # Diagnostic: ||u_hat - u||_2\n            result = np.linalg.norm(u_hat - u)\n            results.append(result)\n            \n        elif i == 3: # Test case 4\n            # Diagnostic: ||u_hat||_2\n            result = np.linalg.norm(u_hat)\n            results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}