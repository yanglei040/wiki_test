{
    "hands_on_practices": [
        {
            "introduction": "无容量设施选址问题（UFLP）是一个经典的优化挑战，在物流和商业战略中有广泛应用。这个问题的目标是在开设设施的固定成本与服务客户的可变成本之间取得平衡。其组合特性意味着其计算复杂度会呈指数级增长，这使其成为启发式方法处理的理想候选。这项练习  要求您为小规模实例找到精确解，从而在尝试使用启发式方法解决问题之前，对问题的结构和所涉及的权衡有一个基础性的理解。",
            "id": "2399266",
            "problem": "给定一个有限无容量设施选址问题族。设有一组由 $i \\in \\{1,\\dots,m\\}$ 索引的客户，以及一组由 $j \\in \\{1,\\dots,n\\}$ 索引的候选设施。每个客户 $i$ 有一个非负需求 $d_i$。开设设施 $j$ 会产生一个非负的固定成本 $f_j$。将客户 $i$ 分配给设施 $j$ 会产生一个非负的单位分配成本 $a_{ij}$。每个设施的决策变量为 $y_j \\in \\{0,1\\}$，表示设施 $j$ 是否开放。每个客户必须被分配到某个开放的设施。一个解 $\\mathbf{y} = (y_1,\\dots,y_n)$ 的总成本定义为\n$$\nF(\\mathbf{y}) \\;=\\; \\sum_{j=1}^{n} f_j \\, y_j \\;+\\; \\sum_{i=1}^{m} d_i \\, \\min_{\\{j \\,:\\, y_j = 1\\}} a_{ij},\n$$\n需满足可行性条件 $\\sum_{j=1}^{n} y_j \\ge 1$，即至少要开放一个设施。所有输入均为无量纲的非负数。您的任务是编写一个确定性程序，对于下方的每个测试用例，返回最小可能的目标值 $F(\\mathbf{y})$，结果为实数。如果您的程序内部使用了随机性，您必须使用固定的种子 $42$ 来初始化任何伪随机数生成器，以确保确定性的输出。\n\n请使用以下测试套件。对于每个测试用例，其实例由元组 $(m, n, \\mathbf{d}, \\mathbf{f}, \\mathbf{A})$ 给出，其中 $\\mathbf{d} = (d_1,\\dots,d_m)$，$\\mathbf{f} = (f_1,\\dots,f_n)$，且 $\\mathbf{A} = [a_{ij}] \\in \\mathbb{R}_{\\ge 0}^{m \\times n}$。\n\n- 测试用例 1 (只有一个候选设施的边界情况)：\n  - $m = 2$, $n = 1$。\n  - $\\mathbf{d} = (\\,1,\\,1\\,)$。\n  - $\\mathbf{f} = (\\,1\\,)$。\n  - $\\mathbf{A}$ 行：\n    - 客户 1：$(\\,1\\,)$，\n    - 客户 2：$(\\,1\\,)$。\n\n- 测试用例 2 (开放成本和分配成本之间的权衡)：\n  - $m = 4$, $n = 3$。\n  - $\\mathbf{d} = (\\,1,\\,1,\\,1,\\,1\\,)$。\n  - $\\mathbf{f} = (\\,2,\\,2,\\,2\\,)$。\n  - $\\mathbf{A}$ 行：\n    - 客户 1：$(\\,1,\\,4,\\,4\\,)$，\n    - 客户 2：$(\\,4,\\,1,\\,4\\,)$，\n    - 客户 3：$(\\,4,\\,4,\\,1\\,)$，\n    - 客户 4：$(\\,2,\\,2,\\,2\\,)$。\n\n- 测试用例 3 (需求异质且开放成本高的边缘情况)：\n  - $m = 5$, $n = 4$。\n  - $\\mathbf{d} = (\\,2,\\,1,\\,3,\\,2,\\,1\\,)$。\n  - $\\mathbf{f} = (\\,8,\\,8,\\,8,\\,8\\,)$。\n  - $\\mathbf{A}$ 行：\n    - 客户 1：$(\\,1,\\,5,\\,6,\\,7\\,)$，\n    - 客户 2：$(\\,5,\\,1,\\,6,\\,7\\,)$，\n    - 客户 3：$(\\,6,\\,6,\\,1,\\,7\\,)$，\n    - 客户 4：$(\\,7,\\,7,\\,7,\\,1\\,)$，\n    - 客户 5：$(\\,2,\\,2,\\,2,\\,2\\,)$。\n\n您的程序应为每个测试用例计算最小目标值 $F(\\mathbf{y})$，结果为浮点数，四舍五入到小数点后一位。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，“[x,y,z]”）。结果必须按测试用例 1、2、3 的顺序打印。",
            "solution": "所呈现的问题是无容量设施选址问题（UFLP）的经典表述，这是运筹学和组合优化领域的一个著名课题。\n\n首先，对问题陈述进行验证。\n已知条件如下：\n- 一组 $m$ 个客户，由 $i \\in \\{1,\\dots,m\\}$ 索引。\n- 一组 $n$ 个候选设施，由 $j \\in \\{1,\\dots,n\\}$ 索引。\n- 每个客户的非负需求，$d_i \\ge 0$。\n- 开放每个设施的非负固定成本，$f_j \\ge 0$。\n- 从客户 $i$ 到设施 $j$ 的非负单位分配成本，$a_{ij} \\ge 0$。\n- 每个设施的二元决策变量 $y_j \\in \\{0,1\\}$。\n- 一个要最小化的目标函数：$F(\\mathbf{y}) = \\sum_{j=1}^{n} f_j y_j + \\sum_{i=1}^{m} d_i \\min_{\\{j : y_j = 1\\}} a_{ij}$。\n- 一个可行性约束：$\\sum_{j=1}^{n} y_j \\ge 1$。\n- 提供了三个具体的测试用例及所有必需的数据。\n\n该问题在科学上和数学上都是合理的。这是一个标准的NP难优化问题，但所提供的实例规模很小。定义是精确的，并且所有必要的数据都已提供。该问题是适定的：对于有限数量的设施 $n$，开放设施的集合存在 $2^n$ 种可能的配置。可行性约束只排除了没有设施开放的平凡情况，剩下 $2^n - 1$ 种有效配置。由于这是一个有限的可能性集合，保证存在一个最小成本的解。因此，该问题被认为是有效的。\n\n将通过对所有可行解空间进行穷举搜索来找到解决方案。这种方法虽然对于大的 $n$ 来说在计算上是不可行的，但对于测试用例中的小 $n$ 值（$n=1, n=3, n=4$）来说是完全适用的，并能提供一个精确的、确定性的解。需要检查的配置数量分别为 $2^1-1=1$，$2^3-1=7$ 和 $2^4-1=15$。这些在计算上是微不足道的。\n\n算法流程如下：\n设所有候选设施的集合为 $\\mathcal{N} = \\{1, \\dots, n\\}$。一个可行解对应于开放一个非空设施子集 $S \\subseteq \\mathcal{N}$，$S \\neq \\emptyset$。\n对于每个这样的子集 $S$，我们计算总成本，即设施开放成本和客户分配成本之和。\n\n给定子集 $S$ 的总开放成本为：\n$$\nC_{open}(S) = \\sum_{j \\in S} f_j\n$$\n\n对于同一子集 $S$ 的总分配成本，是通过将每个客户 $i$ 分配给具有最小分配成本 $a_{ij}$ 的开放设施 $j \\in S$ 来计算的。因此，客户 $i$ 的成本是 $d_i \\min_{j \\in S} a_{ij}$。对所有客户求和，得到总分配成本：\n$$\nC_{assign}(S) = \\sum_{i=1}^{m} d_i \\min_{j \\in S} a_{ij}\n$$\n\n配置 $S$ 的总成本是这两个部分之和：\n$$\nF(S) = C_{open}(S) + C_{assign}(S)\n$$\n\n该算法遍历 $\\mathcal{N}$ 的所有 $2^n - 1$ 个非空子集 $S$，为每个子集计算 $F(S)$，并找出最小值。\n\n例如，让我们考虑测试用例 2，其中 $m=4$，$n=3$，$\\mathbf{d}=(1,1,1,1)$，$\\mathbf{f}=(2,2,2)$，并且给定了 $\\mathbf{A}$。我们必须检查 $2^3 - 1 = 7$ 种配置。\n如果我们考虑开放所有三个设施，即 $S=\\{1,2,3\\}$，则成本为：\n- 开放成本：$C_{open}(\\{1,2,3\\}) = f_1 + f_2 + f_3 = 2+2+2 = 6$。\n- 分配成本：\n    - 客户 1：$d_1 \\min(a_{11}, a_{12}, a_{13}) = 1 \\times \\min(1,4,4) = 1$。\n    - 客户 2：$d_2 \\min(a_{21}, a_{22}, a_{23}) = 1 \\times \\min(4,1,4) = 1$。\n    - 客户 3：$d_3 \\min(a_{31}, a_{32}, a_{33}) = 1 \\times \\min(4,4,1) = 1$。\n    - 客户 4：$d_4 \\min(a_{41}, a_{42}, a_{43}) = 1 \\times \\min(2,2,2) = 2$。\n- 总分配成本：$C_{assign}(\\{1,2,3\\}) = 1+1+1+2 = 5$。\n- 总成本：$F(\\{1,2,3\\}) = 6+5 = 11$。\n\n通过系统地评估所有 7 种配置，我们发现这个值 11 确实是该测试用例的最小值。将相同的过程应用于所有三个测试用例，以找到它们各自的最小成本。最终的实现将遵循这一确切逻辑。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves a series of uncapacitated facility location problems.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        (\n            2, 4, # m, n are dummy values, overridden by array shapes\n            np.array([1, 1]),\n            np.array([1]),\n            np.array([[1], [1]])\n        ),\n        # Test case 2\n        (\n            4, 3,\n            np.array([1, 1, 1, 1]),\n            np.array([2, 2, 2]),\n            np.array([[1, 4, 4], \n                      [4, 1, 4], \n                      [4, 4, 1], \n                      [2, 2, 2]])\n        ),\n        # Test case 3\n        (\n            5, 4,\n            np.array([2, 1, 3, 2, 1]),\n            np.array([8, 8, 8, 8]),\n            np.array([[1, 5, 6, 7], \n                      [5, 1, 6, 7], \n                      [6, 6, 1, 7], \n                      [7, 7, 7, 1], \n                      [2, 2, 2, 2]])\n        )\n    ]\n\n    results = []\n    for _, _, d, f, A in test_cases:\n        m, n = A.shape\n        min_total_cost = float('inf')\n\n        # Iterate through all non-empty subsets of facilities.\n        # An integer 'i' from 1 to 2^n - 1 represents a unique subset,\n        # where the j-th bit of 'i' indicates if facility j is open.\n        for i in range(1, 1  n):\n            \n            # Create a boolean vector representing the open facilities\n            open_facilities_mask = np.array([bool(i  (1  j)) for j in range(n)])\n            \n            # 1. Calculate the total cost of opening facilities\n            opening_cost = np.sum(f[open_facilities_mask])\n            \n            # 2. Calculate the total cost of assigning customers\n            \n            # Select columns of the assignment cost matrix for open facilities\n            assignment_costs_to_open_facilities = A[:, open_facilities_mask]\n            \n            # For each customer, find the minimum assignment cost to an open facility\n            min_assignment_costs_per_customer = np.min(assignment_costs_to_open_facilities, axis=1)\n            \n            # The total assignment cost is the sum of (demand * min_cost) for all customers\n            assignment_cost = np.dot(d, min_assignment_costs_per_customer)\n            \n            # 3. Calculate the total cost for the current configuration\n            total_cost = opening_cost + assignment_cost\n            \n            # 4. Update the overall minimum cost\n            if total_cost  min_total_cost:\n                min_total_cost = total_cost\n                \n        results.append(min_total_cost)\n\n    # Format the results to one decimal place as required and print\n    # Expected output based on manual/code execution: [3.0, 11.0, 42.0]\n    formatted_results = [f\"{r:.1f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "当使用遗传算法（GA）等启发式方法解决约束优化问题时，交叉和变异等算子产生的解可能会变得不可行。一个有效的“修复算子”是算法的关键组成部分，它能将不可行的解修正为可行解，从而引导搜索回到解空间的有效区域。这项练习  挑战您为集合覆盖问题分析并选择最有效的修复策略，从而培养您在设计能够平衡可行性和解质量的稳健算法组件方面的技能。",
            "id": "2399283",
            "problem": "在经典的集合覆盖问题中，给定一个有限基集 $U = \\{1,2,\\dots,m\\}$ 和一个带有正成本 $\\{c_j\\}_{j=1}^n$ 的子集族 $\\{S_j \\subseteq U\\}_{j=1}^n$。一个二进制决策向量 $x \\in \\{0,1\\}^n$ 表示子集的选择，其中 $x_j = 1$ 意味着选择子集 $S_j$。可行性要求基集 $U$ 中的每个元素 $i$ 都至少被一个选定的子集覆盖，即对于所有 $i \\in U$，$\\sum_{j : i \\in S_j} x_j \\ge 1$。目标是在满足可行性的前提下，最小化 $\\sum_{j=1}^n c_j x_j$。假设 $\\bigcup_{j=1}^n S_j = U$，以确保至少存在一个可行解。\n\n遗传算法 (GA) 维护一个由染色体 $x \\in \\{0,1\\}^n$ 组成的种群。交叉和变异可能会产生不可行的后代，这些后代违反了一个或多个覆盖约束。在评估之前，会应用一个修复算子将不可行的染色体映射为可行的染色体。\n\n考虑一个具体实例，其中 $U = \\{1,2,3,4,5\\}$，子集和成本如下：\n- $S_1 = \\{1,2\\}$，成本 $c_1 = 3$，\n- $S_2 = \\{2,3,4\\}$，成本 $c_2 = 4$，\n- $S_3 = \\{3,5\\}$，成本 $c_3 = 2$，\n- $S_4 = \\{1,4,5\\}$，成本 $c_4 = 5$，\n- $S_5 = \\{2,5\\}$，成本 $c_5 = 2$，\n以及一个不可行的后代染色体 $x = (x_1,x_2,x_3,x_4,x_5) = (1,0,0,0,1)$，它仅选择了 $S_1$ 和 $S_5$。当前已覆盖的集合是 $S_1 \\cup S_5 = \\{1,2,5\\}$；元素 $\\{3,4\\}$ 未被覆盖。\n\n你需要选择一个修复算子，该算子需要基于第一性原理（即可行性和覆盖的定义）有合理的依据，并能在成本意识和保证达到可行性之间取得平衡。\n\n下列哪种修复机制同时满足以下两个条件：\n(i) 保证在每个添加步骤中，未覆盖元素的数量严格减少（因此最多在 $|U|$ 次添加后终止），并且绝不接受任何会破坏可行性的移除操作，以及\n(ii) 应用于给定实例和染色体 $x$ 时，能在所列机制中得到最低的总成本？\n\nA. 带冗余消除的贪心单位成本覆盖未覆盖元素策略：\n- 当存在未覆盖元素时，选择一个索引 $j \\in \\{1,\\dots,5\\}$（其中 $x_j = 0$），使得比率 $c_j / |\\;S_j \\cap \\text{Uncovered}\\;|$ 最小，其中 $\\text{Uncovered} \\subseteq U$ 是当前未覆盖元素的集合（若比率相同，则选择 $|\\;S_j \\cap \\text{Uncovered}\\;|$ 较大的一个）。设置 $x_j \\leftarrow 1$ 并更新 $\\text{Uncovered}$。\n- 达到可行性后，尝试消除冗余：按 $c_j / |S_j|$ 的非增序考虑已选择的集合，当且仅当保持可行性时，设置 $x_j \\leftarrow 0$；当没有可移除的集合时停止。\n\nB. 优先添加成本最低的集合，不考虑边际未覆盖元素覆盖率：\n- 当解不可行时，重复选择尚未选择的成本最低的集合（在 $x_j = 0$ 的 $j$ 中选择 $c_j$ 最小的），设置 $x_j \\leftarrow 1$，一旦达到可行性即停止；不移除任何集合。\n\nC. 重叠最大化添加：\n- 当解不可行时，重复选择能最大化 $|\\;S_j \\cap (\\bigcup_{k : x_k = 1} S_k)\\;|$ 的未选择集合 $S_j$（若存在平局，则选择 $c_j$ 最小的），设置 $x_j \\leftarrow 1$，一旦达到可行性即停止；不移除任何集合。\n\nD. 仅罚分处理：\n- 不改变 $x$；而是在适应度评估时，为目标函数分配一个大的加性惩罚项 $\\rho \\cdot |\\text{Uncovered}|$，其中 $\\rho \\gg \\max_j c_j$。\n\n请根据上述基本定义，而不是任何未说明的启发式方法或外部公式，选择满足条件 (i) 和 (ii) 的唯一最佳选项。仅提供一个答案选项。",
            "solution": "问题陈述已经过验证，是自洽的、有科学依据且定义明确的。我们可以开始求解。\n\n该问题要求我们评估四种用于解决集合覆盖问题特定实例的遗传算法修复机制。目标是找出满足以下两个条件的机制：\n(i) 它通过在每个添加步骤中严格减少未覆盖元素的数量来保证收敛到可行解，并在任何移除步骤中保持可行性。\n(ii) 对于给定的实例，它在四种所列机制中产生总成本最低的修复解。\n\n该具体实例定义如下：\n- 基集 $U = \\{1, 2, 3, 4, 5\\}$。\n- 子集和成本：\n  - $S_1 = \\{1, 2\\}$，成本 $c_1 = 3$。\n  - $S_2 = \\{2, 3, 4\\}$，成本 $c_2 = 4$。\n  - $S_3 = \\{3, 5\\}$，成本 $c_3 = 2$。\n  - $S_4 = \\{1, 4, 5\\}$，成本 $c_4 = 5$。\n  - $S_5 = \\{2, 5\\}$，成本 $c_5 = 2$。\n- 初始的不可行染色体是 $x = (1, 0, 0, 0, 1)$。这对应于选择集合 $S_1$ 和 $S_5$。\n\n初始状态如下：\n- 已选集合：$\\{S_1, S_5\\}$。\n- 初始成本：$c_1 + c_5 = 3 + 2 = 5$。\n- 已覆盖集合：$C_0 = S_1 \\cup S_5 = \\{1, 2\\} \\cup \\{2, 5\\} = \\{1, 2, 5\\}$。\n- 未覆盖集合：$\\text{Uncovered}_0 = U \\setminus C_0 = \\{3, 4\\}$。\n\n我们现在逐一分析每个选项。\n\n**A. 带冗余消除的贪心单位成本覆盖未覆盖元素策略**\n\n首先，我们评估条件 (i)。添加阶段选择一个集合 $S_j$ 来最小化比率 $c_j / |S_j \\cap \\text{Uncovered}|$。由于所有成本 $c_j$ 都是正数，要使该比率为有限且最小，分母 $|S_j \\cap \\text{Uncovered}|$ 必须是正整数。这意味着任何添加的集合 $S_j$ 都必须至少覆盖一个当前未覆盖的元素，从而严格减少未覆盖元素的数量。移除阶段被明确约束为保持可行性。因此，条件 (i) 得到满足。\n\n接下来，我们将此机制应用于该实例。\n1.  **添加阶段：** 初始未覆盖元素集合为 $\\text{Uncovered}_0 = \\{3, 4\\}$。我们必须从 $\\{S_2, S_3, S_4\\}$（即那些 $x_j=0$ 的集合）中选择一个集合来添加。我们为每个集合计算选择指标 $c_j / |S_j \\cap \\text{Uncovered}_0|$：\n    - $S_2$：$c_2 = 4$，$S_2 \\cap \\{3, 4\\} = \\{3, 4\\}$，所以 $|S_2 \\cap \\{3, 4\\}| = 2$。比率为 $4/2 = 2$。\n    - $S_3$：$c_3 = 2$，$S_3 \\cap \\{3, 4\\} = \\{3\\}$，所以 $|S_3 \\cap \\{3, 4\\}| = 1$。比率为 $2/1 = 2$。\n    - $S_4$：$c_4 = 5$，$S_4 \\cap \\{3, 4\\} = \\{4\\}$，所以 $|S_4 \\cap \\{3, 4\\}| = 1$。比率为 $5/1 = 5$。\n    $S_2$ 和 $S_3$ 的最小比率均为 $2$，出现了平局。平局打破规则是选择 $|S_j \\cap \\text{Uncovered}|$ 值较大的一个。对于 $S_2$，这个值是 $2$，对于 $S_3$，这个值是 $1$。因此，我们选择 $S_2$。\n    我们设置 $x_2 \\leftarrow 1$。新的已选子集集合是 $\\{S_1, S_2, S_5\\}$。已覆盖集合是 $S_1 \\cup S_2 \\cup S_5 = \\{1, 2\\} \\cup \\{2, 3, 4\\} \\cup \\{2, 5\\} = \\{1, 2, 3, 4, 5\\} = U$。解现在是可行的。\n\n2.  **冗余消除阶段：** 当前解是 $x=(1, 1, 0, 0, 1)$，选择了 $\\{S_1, S_2, S_5\\}$。总成本是 $c_1 + c_2 + c_5 = 3 + 4 + 2 = 9$。我们按 $c_j/|S_j|$ 的非增序考虑移除集合：\n    - $S_1$：$c_1/|S_1| = 3/2 = 1.5$。\n    - $S_2$：$c_2/|S_2| = 4/3 \\approx 1.33$。\n    - $S_5$：$c_5/|S_5| = 2/2 = 1$。\n    考虑的顺序是 $S_1, S_2, S_5$。\n    - 尝试移除 $S_1$：剩余的集合 $\\{S_2, S_5\\}$ 覆盖了 $S_2 \\cup S_5 = \\{2, 3, 4, 5\\}$。元素 $1$ 变为未覆盖。移除被拒绝。\n    - 尝试移除 $S_2$：剩余的集合 $\\{S_1, S_5\\}$ 覆盖了 $S_1 \\cup S_5 = \\{1, 2, 5\\}$。元素 $3$ 和 $4$ 变为未覆盖。移除被拒绝。\n    - 尝试移除 $S_5$：剩余的集合 $\\{S_1, S_2\\}$ 覆盖了 $S_1 \\cup S_2 = \\{1, 2, 3, 4\\}$。元素 $5$ 变为未覆盖。移除被拒绝。\n    没有集合可以被移除。最终的修复解是 $x = (1, 1, 0, 0, 1)$，总成本为 $9$。\n\nA 的结论：该机制满足条件 (i)。对于给定实例，它产生一个总成本为 $9$ 的可行解。\n\n**B. 优先添加成本最低的集合，不考虑边际未覆盖元素覆盖率**\n\n首先，我们评估条件 (i)。该机制添加成本最低的可用集合，而不管它是否覆盖任何当前未覆盖的元素。成本最低的集合 $S_j$ 有可能已经是已覆盖集合的子集（$S_j \\subseteq \\bigcup_{k:x_k=1} S_k$）。在这种情况下，添加 $S_j$ 不会减少未覆盖元素的数量。因此，该机制不保证每一步都严格减少。条件 (i) 被违反。\n\n接下来，我们将此机制应用于该实例。\n1.  **添加阶段：** 未覆盖集合是 $\\{3, 4\\}$。可供添加的集合是 $\\{S_2, S_3, S_4\\}$，其成本分别为 $c_2 = 4, c_3 = 2, c_4 = 5$。成本最低的是 $S_3$。我们添加 $S_3$。\n    现在已选集合为 $\\{S_1, S_3, S_5\\}$。已覆盖集合为 $S_1 \\cup S_3 \\cup S_5 = \\{1, 2, 3, 5\\}$。未覆盖集合为 $\\{4\\}$。解仍然不可行。\n2.  我们重复此过程。可供添加的集合是 $\\{S_2, S_4\\}$，成本分别为 $c_2 = 4, c_4 = 5$。成本最低的是 $S_2$。我们添加 $S_2$。\n    现在已选集合为 $\\{S_1, S_2, S_3, S_5\\}$。已覆盖集合为 $S_1 \\cup S_2 \\cup S_3 \\cup S_5 = \\{1, 2, 3, 4, 5\\} = U$。解是可行的。\n机制停止。没有移除阶段。最终解是 $x = (1, 1, 1, 0, 1)$。总成本为 $c_1 + c_2 + c_3 + c_5 = 3 + 4 + 2 + 2 = 11$。\n\nB 的结论：该机制违反了条件 (i)。对于给定实例，它产生一个总成本为 $11$ 的可行解。\n\n**C. 重叠最大化添加**\n\n首先，我们评估条件 (i)。该机制添加与*当前已覆盖*元素重叠最大的集合。其目标是加强现有覆盖，而不一定是覆盖新元素。具有最大重叠的集合 $S_j$ 可能不覆盖任何新元素（$S_j \\cap \\text{Uncovered} = \\emptyset$）。在这种情况下，未覆盖元素的数量不会减少。因此，该机制不保证每一步都严格减少。条件 (i) 被违反。\n\n接下来，我们将此机制应用于该实例。\n1.  **添加阶段：** 初始已覆盖集合为 $K_0 = \\{1, 2, 5\\}$，未覆盖集合为 $\\{3, 4\\}$。我们根据最大化 $|S_j \\cap K_0|$ 从 $\\{S_2, S_3, S_4\\}$ 中选择。\n    - $S_2$：$|S_2 \\cap K_0| = |\\{2, 3, 4\\} \\cap \\{1, 2, 5\\}| = |\\{2\\}| = 1$。\n    - $S_3$：$|S_3 \\cap K_0| = |\\{3, 5\\} \\cap \\{1, 2, 5\\}| = |\\{5\\}| = 1$。\n    - $S_4$：$|S_4 \\cap K_0| = |\\{1, 4, 5\\} \\cap \\{1, 2, 5\\}| = |\\{1, 5\\}| = 2$。\n    $S_4$ 的重叠最大。我们添加 $S_4$。现在已选集合为 $\\{S_1, S_4, S_5\\}$，已覆盖集合为 $K_1 = S_1 \\cup S_4 \\cup S_5 = \\{1, 2, 4, 5\\}$。未覆盖集合为 $\\{3\\}$。解仍然不可行。\n2.  我们重复此过程。当前已覆盖集合为 $K_1 = \\{1, 2, 4, 5\\}$。可供添加的集合是 $\\{S_2, S_3\\}$。\n    - $S_2$：$|S_2 \\cap K_1| = |\\{2, 3, 4\\} \\cap \\{1, 2, 4, 5\\}| = |\\{2, 4\\}| = 2$。\n    - $S_3$：$|S_3 \\cap K_1| = |\\{3, 5\\} \\cap \\{1, 2, 4, 5\\}| = |\\{5\\}| = 1$。\n    $S_2$ 的重叠最大。我们添加 $S_2$。现在已选集合为 $\\{S_1, S_2, S_4, S_5\\}$，已覆盖集合为 $S_1 \\cup S_2 \\cup S_4 \\cup S_5 = \\{1, 2, 3, 4, 5\\} = U$。解是可行的。\n没有移除阶段。最终解是 $x = (1, 1, 0, 1, 1)$。总成本为 $c_1 + c_2 + c_4 + c_5 = 3 + 4 + 5 + 2 = 14$。\n\nC 的结论：该机制违反了条件 (i)。对于给定实例，它产生一个总成本为 $14$ 的可行解。\n\n**D. 仅罚分处理**\n\n该机制不改变染色体。它只是在目标函数中添加一个惩罚项用于评估。问题将修复算子定义为一个“将不可行染色体映射为可行染色体”的过程。该机制没有做到这一点。它不包含任何“添加步骤”，因此不能满足条件 (i) 中的保证。它在实现可行性方面没有任何进展。因此，它不是问题所要求意义上的修复算子，并且不满足条件 (i)。\n\n此外，由于它不产生可行解，其在集合覆盖目标 $\\sum c_j x_j$ 下的成本无法与其他产生可行解的机制相比较。可以认为其有效成本是无限的。在任何情况下，它都不可能得到最低的总成本。其带惩罚的成本将是 $5 + 2\\rho$，根据定义这是一个非常大的值。所以它也不满足条件 (ii)。\n\nD 的结论：该机制违反了条件 (i)，因为它没有将不可行解映射为可行解。它也违反了条件 (ii)。\n\n**结论**\n\n我们总结一下研究结果：\n- **机制 A：** 满足条件 (i)。产生一个成本为 $9$ 的可行解。\n- **机制 B：** 违反条件 (i)。产生一个成本为 $11$ 的可行解。\n- **机制 C：** 违反条件 (i)。产生一个成本为 $14$ 的可行解。\n- **机制 D：** 违反条件 (i) 且不产生可行解。\n\n只有机制 A 满足条件 (i)。\n对于条件 (ii)，我们比较这些机制产生的解的成本：成本(A) = $9$，成本(B) = $11$，成本(C) = $14$。其中的最低成本是 $9$，由机制 A 实现。因为机制 D 不产生有效的、有限成本的可行解，所以它不能成为最低成本的竞争者。\n因此，机制 A 是唯一一个同时满足条件 (i) 和 (ii) 的。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "许多强大的启发式算法，如粒子群优化（PSO），其原生设计是针对连续搜索空间的。将这类算法应用于离散域需要仔细思考，以保留算法的核心搜索行为——就PSO而言，即保留粒子朝向个体最优和全局最优位置移动的吸引力。通过这项练习 ，您将探索不同的适配方法，学会区分临时的修复手段和能够将连续动态正确映射到离散可行集上的原则性方法。",
            "id": "2399268",
            "problem": "要求您将粒子群优化 (PSO) 算法应用于离散整数规划问题。考虑一个约束优化问题，其决策向量为 $x \\in \\mathbb{Z}^d$：\n最小化 $f(x)$，约束条件为：对所有 $j \\in \\{1,\\dots,d\\}$ 都有 $0 \\le x_j \\le 5$，且 $\\sum_{j=1}^d x_j = 12$。在连续形式中，标准的 PSO 算法为每个粒子 $i$ 维护一个位置 $x_i^t \\in \\mathbb{R}^d$ 和一个速度 $v_i^t \\in \\mathbb{R}^d$，其更新方式如下：\n$$\nv_i^{t+1} = \\omega\\, v_i^{t} + c_1\\, r_{1}^{t} \\odot \\big(p_i^{t} - x_i^{t}\\big) + c_2\\, r_{2}^{t} \\odot \\big(g^{t} - x_i^{t}\\big), \\quad\nx_i^{t+1} = x_i^{t} + v_i^{t+1},\n$$\n其中 $\\omega, c_1, c_2 \\in \\mathbb{R}$ 是参数，$r_1^{t}, r_2^{t} \\in [0,1]^d$ 是分量级采样的随机向量，$\\odot$ 表示分量级乘法，$p_i^{t}$ 是粒子 $i$ 的个体最优解，$g^{t}$ 是全局最优解。您需要调整这些更新规则，使得在每次迭代后，每个粒子的位置都是一个整数向量，并且满足边界约束和总和约束。以下哪种策略能提供一个适定（well-posed）的调整方案，既能确保每个更新后的位置都位于可行集 $X = \\{x \\in \\mathbb{Z}^d: 0 \\le x_j \\le 5,\\ \\sum_{j=1}^d x_j = 12\\}$ 内，又能保持离散更新是连续吸引步骤的“最近可行对应体”这一解释？请选择唯一的最佳选项。\n\nA. 计算出连续候选解 $y_i^{t+1} = x_i^{t} + v_i^{t+1}$ 后，将其每个分量四舍五入到最近的整数，并裁剪到 $[0,5]$ 区间内。如果总和约束 $\\sum_{j=1}^d x_{i,j}^{t+1} = 12$ 被违反，则重复随机选择一对不同的索引 $(j,k)$，并在遵守边界约束的前提下，将 $x_{i,j}^{t+1}$ 调整 $+1$ 同时将 $x_{i,k}^{t+1}$ 调整 $-1$（或根据差值的符号反向操作），直到总和等于 $12$。\n\nB. 将实值位置替换为 $\\{0,1\\}^d$ 中的二进制向量，并通过 sigmoid 映射将每个速度分量解释为翻转概率。根据这些概率独立地翻转比特位来进行更新。如果 $\\sum_{j=1}^d x_{i,j}^{t+1} \\ne 12$，则重复重新采样翻转操作，直到等式成立。\n\nC. 通过将标准 PSO 速度方程的右侧四舍五入到最近的整数来定义一个整值的“速度”。通过 $x_i^{t+1} = x_i^{t} + v_i^{t+1}$ 进行分量级的位置更新，然后对每个分量进行模 $6$ 运算以强制满足 $0 \\le x_{i,j}^{t+1} \\le 5$。在更新过程中忽略总和约束。\n\nD. 将 $x$ 编码为 $\\{1,\\dots,d\\}$ 的一个排列，并将速度表示为一个交换序列，该序列将一个排列移向其个体最优和全局最优排列。在应用一个组合的交换序列来更新粒子后，通过“缩放”该排列以满足 $\\sum_{j=1}^d x_j = 12$ 并裁剪到 $[0,5]$，将其解码回整数向量。\n\nE. 计算出连续候选解 $y_i^{t+1} = x_i^{t} + v_i^{t+1}$ 后，通过求解以下问题将其映射到一个整数可行向量：\n$$\n\\min_{z \\in \\mathbb{Z}^d} \\ \\|z - y_i^{t+1}\\|_2 \\quad \\text{subject to} \\quad 0 \\le z_j \\le 5,\\ \\sum_{j=1}^d z_j = 12,\n$$\n该问题通过以下方式高效实现：首先将 $y_i^{t+1}$ 四舍五入到最近的整数，然后通过将总和的差值分配给具有最大（绝对值）小数部分的那些分量来调整舍入后的向量，同时遵守边界约束，从而使得最终的 $z$ 的总和为 $12$，并且在欧几里得范数意义下尽可能地接近 $y_i^{t+1}$。",
            "solution": "必须首先确定问题陈述的有效性。\n\n### 步骤1：提取已知条件\n- 该问题是一个针对函数 $f(x)$ 的约束优化问题，其中决策向量为 $x \\in \\mathbb{Z}^d$。\n- 可行集 $X$ 由两类约束定义：\n    1. 边界约束：对所有 $j \\in \\{1,\\dots,d\\}$，有 $0 \\le x_j \\le 5$。\n    2. 一个线性等式约束（总和约束）：$\\sum_{j=1}^d x_j = 12$。\n- 任务是为该离散域调整标准的连续粒子群优化 (PSO) 算法。\n- 对于时间步 $t$ 的粒子 $i$，标准的连续 PSO 更新方程如下：\n$$\nv_i^{t+1} = \\omega\\, v_i^{t} + c_1\\, r_{1}^{t} \\odot \\big(p_i^{t} - x_i^{t}\\big) + c_2\\, r_{2}^{t} \\odot \\big(g^{t} - x_i^{t}\\big)\n$$\n$$\nx_i^{t+1} = x_i^{t} + v_i^{t+1}\n$$\n- 调整必须满足两个条件：\n    1. 更新后的位置必须始终属于可行集 $X = \\{x \\in \\mathbb{Z}^d: 0 \\le x_j \\le 5, \\sum_{j=1}^d x_j = 12\\}$。\n    2. 调整必须保留离散更新是连续吸引步骤的“最近可行对应体”这一解释。\n\n### 步骤2：使用提取的已知条件进行验证\n- **科学依据：** 该问题牢固地植根于计算工程和启发式优化领域。将像 PSO 这样的连续元启发式算法应用于离散或受约束的问题是一个标准且重要的研究课题。问题表述使用了成熟的数学概念和一个著名的算法。约束条件定义了一个有效的整数规划可行域。该问题在科学上是合理的。\n- **适定性：** 问题提供了所有必要的信息。它清晰地定义了搜索空间、需要调整的更新规则以及成功调整的标准（可行性和“最近对应体”）。术语“最近可行对应体”通过与连续吸引步骤相关联而被赋予了明确的上下文，这明确指向了距离最小化原则。问题的结构使得在选项中存在一组唯一的正确答案。\n- **客观性：** 语言精确且专业。评估标准是客观的，可以通过数学和算法推理进行评估。\n\n### 步骤3：结论与行动\n问题陈述是有效的。它具有科学依据、适定性和客观性。我现在将通过评估每个选项来解决问题。\n\n问题的核心是将一个连续候选解 $y_i^{t+1} = x_i^{t} + v_i^{t+1}$ 映射到点 $z \\in X$，该点既可行又在概念上“接近”$y_i^{t+1}$。作为“最近可行对应体”的标准最严格的解释是，找到一个向量 $z$，它在 $z \\in X$ 的约束下，最小化与 $y_i^{t+1}$ 之间的某个距离度量。对此，标准的选择是欧几里得距离（或其平方），这导出了投影问题：$\\min_{z \\in X} \\|z - y_i^{t+1}\\|_2^2$。\n\n### 逐项分析\n\n**选项 A：**\n该策略首先通过四舍五入和裁剪创建一个中间整数向量，这强制满足了边界约束 $0 \\le x_j \\le 5$ 和整数要求。然而，它随后试图通过一系列随机调整来满足总和约束 $\\sum x_j = 12$。具体来说，它随机选择索引对 $(j,k)$ 并应用 $(x_j, x_k) \\to (x_j+1, x_k-1)$ 或 $(x_j-1, x_k+1)$ 形式的更新。虽然这种修复机制最终会强制满足总和约束并维持边界约束，但其调整的随机性是其关键缺陷。通过随机选择索引，该过程并未试图最小化与原始连续候选解 $y_i^{t+1}$ 的偏差。最终的向量可能与真正的“最近”可行点相距甚远，这取决于随机选择的序列。这违反了保留“最近可行对应体”解释的原则。该过程是临时的（ad-hoc），而不是基于原则的。\n**结论：不正确。**\n\n**选项 B：**\n该策略存在根本性缺陷，因为它重新定义了问题。原始问题指定了整数变量 $x_j \\in \\{0, 1, 2, 3, 4, 5\\}$。该选项建议使用二进制向量 $x_j \\in \\{0, 1\\}$，这是一个不同的搜索空间。它用一个二进制规划问题取代了整数规划问题。此外，它提出了一种“拒绝采样”方法（“重复重新采样翻转操作”）来满足总和约束，这种方法计算效率低下，并且可能无法保证在合理时间内终止。这不是对给定问题的有效调整。\n**结论：不正确。**\n\n**选项 C：**\n该策略在两个方面失败了。首先，它明确指出要“忽略总和约束”。这意味着得到的粒子位置 $x_i^{t+1}$ 不保证在可行集 $X$ 内，违反了调整的一个主要要求。其次，它使用模运算符 $x_{i,j}^{t+1} \\pmod 6$ 来强制满足边界约束。模运算符会产生“环绕”效应。例如，值 $6$ 变为 $0$，值 $-1$ 变为 $5$。这不等同于在区间 $[0,5]$ 中找到最近的整数。对此的标准操作应该是裁剪，即 $\\max(0, \\min(5, x_j))$。环绕行为与 PSO 的吸引原则不一致，在吸引原则中，一个大的速度应该将粒子移动到搜索空间的边界，而不是将其传送到另一侧。\n**结论：不正确。**\n\n**选项 D：**\n该策略建议将整数向量 $x$ 编码为一个排列。这是一种适用于组合优化问题的技术，例如旅行商问题或调度问题，在这些问题中解是元素的排序。当前的问题是一个整数规划问题，而不是基于排列的问题。在这里使用排列编码是不自然的，并将问题强行纳入一个它不适合的框架中。此外，描述很模糊，提到了用“交换序列”表示速度，以及通过“缩放”排列来解码回整数向量。这不是对给定的基于向量的 PSO 更新规则的直接调整，并且完全放弃了粒子在 $d$ 维空间中移动的几何解释。它未能保留“连续吸引步骤”的概念。\n**结论：不正确。**\n\n**选项 E：**\n该策略提供了最严谨和最有原则的方法。它通过将“最近可行对应体”的概念形式化为求解一个最小化问题的解来定义它：在可行集 $X$ 中找到一个点 $z$，使得其到连续候选解 $y_i^{t+1}$ 的欧几里得距离最小。这正是在可行集 $X$ 上的一个投影 $y_i^{t+1}$。这保证了更新后的粒子位置在构造上是可行的，并且是与连续 PSO 动态会将其放置的位置最接近的可行点。该选项接着描述了一个著名且高效的贪心算法来解决这个特定的投影问题：首先将 $y_i^{t+1}$ 四舍五入到最近的整数，然后通过将总和差值分配给那些在调整时导致欧几里得距离平方增加最小的分量，迭代地调整分量以满足总和约束。这对应于根据其小数部分的大小（或更准确地说，是原始连续值和舍入值之间的差异）来调整分量。该策略是适定的，保证了可行性，并且完美地符合“最近对应体”原则。\n**结论：正确。**",
            "answer": "$$\\boxed{E}$$"
        }
    ]
}