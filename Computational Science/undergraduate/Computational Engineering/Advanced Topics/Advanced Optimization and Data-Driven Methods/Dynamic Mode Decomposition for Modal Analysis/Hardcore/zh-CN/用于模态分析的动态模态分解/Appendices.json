{
    "hands_on_practices": [
        {
            "introduction": "理论是实践的基石。在深入探讨动态模态分解 (DMD) 的复杂应用之前，我们首先通过一个基础实践来验证其核心理论的正确性。这个练习旨在证明，在理想的无噪声条件下，当数据确实由一个线性时不变系统生成时，DMD 能够精确地重构出该系统的动态演化算子，从而实现零重构误差 。通过亲手实现并验证这一“精确DMD”的特性，您将对该算法的数学基础建立起坚实的信心。",
            "id": "2387371",
            "problem": "您的任务是评估通过精确动态模态分解 (DMD) 获得的数据驱动线性模型，在应用于由线性时不变离散时间系统生成的无噪声快照时，是否能实现零重构误差。考虑一个状态序列 $\\{x_k\\}_{k=0}^{m-1}$（在 $\\mathbb{C}^n$ 中），它由递推关系 $x_{k+1} = A x_k$ 生成，其中 $A \\in \\mathbb{C}^{n \\times n}$ 是一个常数矩阵。定义快照矩阵 $X_1 = [x_0, x_1, \\dots, x_{m-2}] \\in \\mathbb{C}^{n \\times (m-1)}$ 和 $X_2 = [x_1, x_2, \\dots, x_{m-1}] \\in \\mathbb{C}^{n \\times (m-1)}$。令 $\\widehat{A}$ 表示通过精确动态模态分解从数据对 $(X_1, X_2)$ 中产生的线性算子，该分解使用 $X_1$ 的完整数值秩。将归一化重构误差定义为\n$$\n\\varepsilon = \\frac{\\lVert X_2 - \\widehat{A} X_1 \\rVert_F}{\\lVert X_2 \\rVert_F},\n$$\n其中 $\\lVert \\cdot \\rVert_F$ 表示 Frobenius 范数。如果一个数据集是无噪声的，由上述线性时不变模型生成，并且算子 $\\widehat{A}$ 是使用 $X_1$ 的完整数值秩构建的，则该数据集满足精确 DMD 的条件。\n\n通过指定满足这些条件的 $A$、$x_0$ 和 $m$ 来构建三个合成数据集。对于每个数据集，通过 $x_{k+1} = A x_k$ 生成快照 $\\{x_k\\}$，并按上述定义构建 $X_1$ 和 $X_2$。对于每个数据集，计算 $\\varepsilon$ 并返回一个布尔值，指示 $\\varepsilon \\leq 10^{-12}$ 是否成立。\n\n您的程序必须为以下测试套件实现此过程。在所有出现复数的情况下，角度均以弧度为单位，并且所有计算都在 $\\mathbb{C}$ 上进行。\n\n测试套件 (每个要点完全指定一个数据集)：\n\n- 数据集 1 (具有实特征值的可对角化矩阵):\n  - 维度 $n = 3$，快照数量 $m = 6$。\n  - 选择 $W_1 = \\begin{bmatrix} 1  2  0 \\\\ 0  1  1 \\\\ 1  0  1 \\end{bmatrix}$ 和 $\\Lambda_1 = \\mathrm{diag}(0.8,\\, 1.2,\\, -0.5)$，并定义 $A_1 = W_1 \\Lambda_1 W_1^{-1}$。\n  - 初始状态 $x_0^{(1)} = \\begin{bmatrix} 1 \\\\ -1 \\\\ 2 \\end{bmatrix}$。\n\n- 数据集 2 (包含一个振荡的复共轭对):\n  - 维度 $n = 3$，快照数量 $m = 7$。\n  - 选择 $W_2 = I_3$ ($3 \\times 3$ 单位矩阵)，$\\Lambda_2 = \\mathrm{diag}\\!\\left(\\mathrm{e}^{\\mathrm{i}\\pi/6},\\, \\mathrm{e}^{-\\mathrm{i}\\pi/6},\\, 0.9\\right)$，并定义 $A_2 = \\Lambda_2$。\n  - 初始状态 $x_0^{(2)} = \\begin{bmatrix} 2 \\\\ 1 \\\\ -1 \\end{bmatrix}$。\n\n- 数据集 3 (由于未激发的模态导致的秩亏快照):\n  - 维度 $n = 4$，快照数量 $m = 5$。\n  - 选择 $W_3 = I_4$ ($4 \\times 4$ 单位矩阵)，$\\Lambda_3 = \\mathrm{diag}(0.7,\\, 0.7,\\, 0.3,\\, 1.1)$，并定义 $A_3 = \\Lambda_3$。\n  - 初始状态 $x_0^{(3)} = \\begin{bmatrix} 3 \\\\ -2 \\\\ 0 \\\\ 0 \\end{bmatrix}$。\n\n对于每个数据集，您必须：\n1. 构建 $A$，通过 $x_{k+1} = A x_k$（其中 $k = 0, 1, \\dots, m-2$）生成 $x_k$，并构建 $X_1$ 和 $X_2$。\n2. 应用精确动态模态分解于 $(X_1, X_2)$，并使用 $X_1$ 的完整数值秩来计算 $\\widehat{A}$。\n3. 按上述定义计算 $\\varepsilon$，并将其与 $10^{-12}$ 进行比较以获得一个布尔结果。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个数据集对应一个布尔值，顺序如上所述。例如，一个有效的输出形如“[True,True,True]”。",
            "solution": "目标是验证当精确动态模态分解 (DMD) 方法使用数据的完整数值秩时，对于由线性时不变系统生成的无噪声快照，它能够产生零重构误差。数据构建和误差度量规定如下。给定 $A \\in \\mathbb{C}^{n \\times n}$，一个初始状态 $x_0 \\in \\mathbb{C}^n$，以及一个整数 $m \\ge 2$，定义 $x_{k+1} = A x_k$（其中 $k = 0, \\dots, m-2$），并设置\n$$\nX_1 = [x_0, x_1, \\dots, x_{m-2}] \\in \\mathbb{C}^{n \\times (m-1)}, \\quad\nX_2 = [x_1, x_2, \\dots, x_{m-1}] \\in \\mathbb{C}^{n \\times (m-1)}.\n$$\n根据构造，有 $X_2 = A X_1$。\n\n精确 DMD 算子 $\\widehat{A}$ 是作用于 $X_1$ 列空间上的数据驱动线性映射，它将 $X_1$ 中的每个 $x_k$ 映射到 $X_2$ 中的 $x_{k+1}$。为了从数据中构建 $\\widehat{A}$，需要使用 $X_1$ 的奇异值分解 (SVD)。令 $X_1$ 具有（细）SVD\n$$\nX_1 = U_r S_r V_r^*,\n$$\n其中 $U_r \\in \\mathbb{C}^{n \\times r}$，$S_r \\in \\mathbb{R}^{r \\times r}$ 是对角矩阵，其对角元素严格为正，$V_r \\in \\mathbb{C}^{(m-1) \\times r}$ 具有标准正交列，并且 $r = \\mathrm{rank}(X_1)$ 是由奇异值决定的完整数值秩。精确 DMD 算子则定义为\n$$\n\\widehat{A} = X_2 V_r S_r^{-1} U_r^*.\n$$\n现在我们证明，对于无噪声的序列数据，在精确算术下，这个选择保证了零重构误差。\n\n首先，观察到\n$$\n\\widehat{A} X_1 = X_2 V_r S_r^{-1} U_r^* \\, (U_r S_r V_r^*) = X_2 V_r V_r^*.\n$$\n矩阵 $V_r V_r^*$ 是 $\\mathbb{C}^{(m-1) \\times (m-1)}$ 中到 $X_1$ 行空间的正交投影算子。对于序列化的无噪声数据，$X_2 = A X_1$，这意味着 $X_2$ 的行空间包含于 $X_1$ 的行空间，因为左乘 $A$ 构成了 $X_1$ 各行的线性组合。因此，将 $X_2$ 投影到 $X_1$ 的行空间上并不会改变它：\n$$\nX_2 V_r V_r^* = X_2.\n$$\n因此，\n$$\n\\widehat{A} X_1 = X_2,\n$$\n这意味着定义的重构误差\n$$\n\\varepsilon = \\frac{\\lVert X_2 - \\widehat{A} X_1 \\rVert_F}{\\lVert X_2 \\rVert_F}\n$$\n在精确算术中恰好为零。\n\n在有限精度算术中，数值舍入误差会导致一个小的非零值。使用像 $10^{-12}$ 这样的严格容差可以捕捉到这一点并验证理论结果。\n\n接下来，我们证明测试套件中的每个数据集都满足所需条件：\n\n- 数据集 1：$A_1 = W_1 \\Lambda_1 W_1^{-1}$，其中 $W_1$ 可逆，$\\Lambda_1$ 是对角矩阵，具有互异的实特征值。这确保了 $A_1$ 是可对角化的。快照是无噪声的，并满足 $X_2 = A_1 X_1$。$X_1$ 的数值秩等于由 $x_0^{(1)}$ 激发的不变子空间的维度，由于 $x_0^{(1)}$ 的选择和互异的特征值，这里的秩将是满秩。\n\n- 数据集 2：$A_2 = \\Lambda_2$，其中 $\\Lambda_2 = \\mathrm{diag}\\!\\left(\\mathrm{e}^{\\mathrm{i}\\pi/6}, \\mathrm{e}^{-\\mathrm{i}\\pi/6}, 0.9\\right)$。该矩阵在 $\\mathbb{C}$ 上是对角的，因此是可对角化的，具有一个振荡的复共轭特征对和一个实数衰减特征值。快照是无噪声的，并由 $x_{k+1} = A_2 x_k$ 生成，因此 $X_2 = A_2 X_1$。数值秩从 $X_1$ 的奇异值中检测。\n\n- 数据集 3：$A_3 = \\Lambda_3$，其中 $\\Lambda_3 = \\mathrm{diag}(0.7, 0.7, 0.3, 1.1)$ 且 $x_0^{(3)} = [3, -2, 0, 0]^T$。只有前两个特征模态被激发，因此快照位于一个二维不变子空间内，使得 $X_1$ 秩亏（秩等于 $2$），尽管 $n = 4$。使用完整数值秩 $r = 2$ 构建的精确 DMD 仍然精确满足 $\\widehat{A} X_1 = X_2$，因为数据仍然是无噪声的，且 $X_2 = A_3 X_1$，$X_2$ 的行空间包含于 $X_1$ 的行空间。\n\n程序的算法计划：\n1. 对于每个数据集，按规定构建 $A$，迭代生成 $x_k$，并构建 $X_1$ 和 $X_2$。\n2. 计算 $X_1$ 的细 SVD 以获得 $U, S, V^*$，使用阈值 $S_i > \\tau$ 来确定数值秩 $r$，其中 $\\tau = \\max(n, m-1) \\cdot \\epsilon \\cdot S_1$，$\\epsilon$ 是机器精度。\n3. 截断为 $U_r, S_r, V_r$ 并计算 $\\widehat{A} = X_2 V_r S_r^{-1} U_r^*$。\n4. 计算 $\\varepsilon$ 并与 $10^{-12}$ 比较，为每个数据集生成布尔结果。\n5. 以要求的单行格式输出布尔值列表。\n\n因为这些数据集满足精确 DMD 的条件，所以对于所有三种情况，重构误差在指定的容差范围内应为数值零。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef numerical_rank(S, shape, eps=None):\n    \"\"\"\n    Determine the numerical rank based on singular values S and matrix shape.\n    Uses threshold tau = max(shape) * eps * S[0].\n    \"\"\"\n    if eps is None:\n        eps = np.finfo(float).eps\n    if S.size == 0:\n        return 0\n    tau = max(shape) * eps * S[0]\n    return int(np.sum(S > tau))\n\ndef exact_dmd_operator(X1, X2):\n    \"\"\"\n    Compute the exact DMD operator A_hat = X2 V_r S_r^{-1} U_r^* using the full numerical rank.\n    \"\"\"\n    # Compute SVD of X1\n    U, s, Vh = np.linalg.svd(X1, full_matrices=False)\n    # Determine numerical rank\n    r = numerical_rank(s, X1.shape)\n    if r == 0:\n        # Degenerate case: no information\n        return np.zeros((X2.shape[0], X1.shape[0]), dtype=X1.dtype)\n    U_r = U[:, :r]\n    S_r_inv = np.diag(1.0 / s[:r])\n    V_r = Vh.conj().T[:, :r]\n    # Exact DMD operator\n    A_hat = X2 @ V_r @ S_r_inv @ U_r.conj().T\n    return A_hat\n\ndef generate_snapshots(A, x0, m):\n    \"\"\"\n    Generate snapshots x_0, x_1, ..., x_{m-1} using x_{k+1} = A x_k.\n    Returns X1 = [x0 ... x_{m-2}] and X2 = [x1 ... x_{m-1}].\n    \"\"\"\n    n = A.shape[0]\n    X = np.zeros((n, m), dtype=complex)\n    X[:, 0] = x0\n    for k in range(m - 1):\n        X[:, k + 1] = A @ X[:, k]\n    X1 = X[:, :-1]\n    X2 = X[:, 1:]\n    return X1, X2\n\ndef build_dataset_1():\n    # Dataset 1: A = W * Lambda * W^{-1}, real diagonalizable\n    W = np.array([[1, 2, 0],\n                  [0, 1, 1],\n                  [1, 0, 1]], dtype=float)\n    Lambda = np.diag([0.8, 1.2, -0.5])\n    Winv = np.linalg.inv(W)\n    A = (W @ Lambda @ Winv).astype(complex)\n    x0 = np.array([1, -1, 2], dtype=complex)\n    m = 6\n    return A, x0, m\n\ndef build_dataset_2():\n    # Dataset 2: complex conjugate pair and a real eigenvalue\n    lam1 = np.exp(1j * np.pi / 6.0)\n    lam2 = np.exp(-1j * np.pi / 6.0)\n    lam3 = 0.9 + 0j\n    A = np.diag([lam1, lam2, lam3]).astype(complex)\n    x0 = np.array([2, 1, -1], dtype=complex)\n    m = 7\n    return A, x0, m\n\ndef build_dataset_3():\n    # Dataset 3: rank-deficient snapshots (only first two modes excited)\n    A = np.diag([0.7, 0.7, 0.3, 1.1]).astype(complex)\n    x0 = np.array([3, -2, 0, 0], dtype=complex)\n    m = 5\n    return A, x0, m\n\ndef reconstruction_boolean(X1, X2, tol=1e-12):\n    A_hat = exact_dmd_operator(X1, X2)\n    diff = X2 - (A_hat @ X1)\n    num = np.linalg.norm(diff, ord='fro')\n    den = np.linalg.norm(X2, ord='fro')\n    # Handle the degenerate case where X2 is zero matrix\n    rel_err = 0.0 if den == 0.0 else (num / den)\n    return rel_err = tol\n\ndef solve():\n    # Define the test cases from the problem statement.\n    datasets = [\n        build_dataset_1(),\n        build_dataset_2(),\n        build_dataset_3(),\n    ]\n\n    results = []\n    for A, x0, m in datasets:\n        X1, X2 = generate_snapshots(A, x0, m)\n        results.append(reconstruction_boolean(X1, X2, tol=1e-12))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "从理想的理论走向复杂的现实，DMD 的有效性在很大程度上取决于一个关键参数：SVD 截断秩 $r$ 的选择。这个练习将引导您探索 $r$ 的选择如何直接影响模态辨识的结果，尤其是在处理具有挑战性的系统时，例如那些包含频率相近或能量较低的模态的系统 。通过观察不同 $r$ 值对结果的影响，您将深刻理解在构建 DMD 模型时所面临的权衡，并掌握调整这一核心参数以获得最佳分析效果的关键技能。",
            "id": "2387367",
            "problem": "您需要设计并实现一个程序，研究在低秩分解中截断秩如何影响使用动态模态分解 (DMD) 进行的模态辨识。从离散时间线性时不变演化模型和核心线性代数定义（即可以从数据中推断出将一个快照推进到下一个快照的最佳拟合线性算子）开始。以此为基础，推导出一个计算流程，该流程在给定用户指定的截断秩 $r$ 的情况下，从快照数据中估计主导模态及其相关的离散时间特征值。您的程序必须量化在几个精心构建的测试案例中正确辨识出的真实模态数量，这些案例包括具有相近频率的系统和具有低能量模态的系统。所有角度必须以弧度处理。\n\n该任务必须纯粹用数学和算法术语来表述：\n\n- 考虑由 $p$ 个模态线性叠加生成的一系列复值快照 $\\{x_k\\}_{k=0}^{m-1}$，其中 $x_k \\in \\mathbb{C}^n$，\n  $$x_k = \\sum_{j=1}^{p} a_j \\, \\phi_j \\, e^{(\\sigma_j + \\mathrm{i}\\,\\omega_j)\\,k},$$\n  此处 $\\phi_j \\in \\mathbb{C}^n$ 是空间模态形状，$a_j \\in \\mathbb{R}_+$ 是模态振幅（能量代理），$\\sigma_j \\in \\mathbb{R}$ 是每样本的离散时间增长率，$\\omega_j \\in \\mathbb{R}$ 是每样本的角频率（以弧度为单位）。与模态 $j$ 相关的离散时间特征值为 $\\lambda_j^\\star = e^{\\sigma_j + \\mathrm{i}\\,\\omega_j}$。这些快照被堆叠成数据矩阵 $X = [x_0,\\dots,x_{m-2}] \\in \\mathbb{C}^{n \\times (m-1)}$ 和 $Y = [x_1,\\dots,x_{m-1}] \\in \\mathbb{C}^{n \\times (m-1)}$。\n- 从线性算子 $A$ 的最小二乘拟合定义（使得 $Y \\approx A X$）以及使用奇异值分解 (SVD) 来稳定并实现低秩近似出发，推导出一个计算流程，用于在用户选择的截断秩 $r$ 下估计降维算子及其特征值。除了线性时不变模型和标准线性代数外，不引入任何其他假设。\n- 实现一个匹配规则来计算正确辨识的数量：一个计算出的特征值 $\\mu$ 被认为与一个真实值 $\\lambda_j^\\star$ 匹配，如果以下两条同时成立：\n  1) 其辐角之间的环绕绝对角差异最多为一个容差 $\\tau_\\omega$，即 $\\arg(\\mu)$ 和 $\\omega_j$ 模 $2\\pi$ 的最小绝对差 $\\le \\tau_\\omega$（角度以弧度为单位）。\n  2) 幅值差异满足 $\\big|\\,|\\mu| - e^{\\sigma_j}\\,\\big| \\le \\tau_m$。\n  使用 $\\tau_\\omega = 10^{-3}$ 和 $\\tau_m = 10^{-3}$。\n- 为保证可复现性，当使用随机量时（例如，空间模态 $\\phi_j$），在构建测试案例之前，将随机数生成器种子固定为 $12345$。\n\n测试套件。您的程序必须构建以下五个测试案例，生成相应的快照，执行秩-$r$ DMD 流程，并为每个案例计算正确辨识的模态的整数数量。使用 $n=6$ 个传感器和复值快照。在所有案例中，将附加噪声水平设置为零。角度以弧度为单位，时间以整数样本步长计数。\n\n- 案例 $1$ (基准，良好分离): $m=300$, $p=3$, $\\omega=[0.40,\\,1.10,\\,2.20]$, $\\sigma=[0.00,\\,0.00,\\,0.00]$, $a=[1.00,\\,0.80,\\,0.50]$, $r=3$。\n- 案例 $2$ (频率相近对，秩充足): $m=400$, $p=3$, $\\omega=[0.20,\\,0.205,\\,1.00]$, $\\sigma=[0.00,\\,0.00,\\,0.00]$, $a=[1.00,\\,1.00,\\,0.30]$, $r=3$。\n- 案例 $3$ (频率相近对，秩不足): $m=400$, $p=3$, $\\omega=[0.20,\\,0.205,\\,1.00]$, $\\sigma=[0.00,\\,0.00,\\,0.00]$, $a=[1.00,\\,1.00,\\,0.30]$, $r=2$。\n- 案例 $4$ (低能量，衰减模态): $m=300$, $p=3$, $\\omega=[0.50,\\,1.20,\\,1.80]$, $\\sigma=[0.00,\\,0.00,\\,-0.02]$, $a=[1.00,\\,0.80,\\,0.05]$, $r=3$。\n- 案例 $5$ (边界秩): $m=300$, $p=3$, $\\omega=[0.25,\\,0.80,\\,1.60]$, $\\sigma=[0.00,\\,0.00,\\,0.00]$, $a=[1.00,\\,0.80,\\,0.50]$, $r=1$。\n\n对于每个案例：\n- 构建 $p$ 个单位 $2$-范数的随机空间模态 $\\phi_j \\in \\mathbb{C}^n$。\n- 使用上述叠加公式（无噪声）为 $k=0,\\dots,m-1$ 生成快照 $x_k$。\n- 从连续的快照构建 $X$ 和 $Y$。\n- 应用您的秩-$r$ DMD 流程来计算特征值集合 $\\{\\mu_\\ell\\}$。\n- 在规定的容差下，通过在 $\\{\\mu_\\ell\\}$ 和 $\\{\\lambda_j^\\star\\}$ 之间进行一对一匹配，计算正确辨识的模态的整数数量。\n\n最终输出格式。您的程序应生成包含一个Python风格的5个整数列表的单行输出，其中第 $i$ 个整数是案例 $i$ 正确辨识的模态数量。输出必须严格符合以下格式：\n\"[v1,v2,v3,v4,v5]\"\n不得有多余的空格或文本。所有角度计算必须以弧度为单位。除了所有角度均为弧度的指令外，不需要任何物理单位。",
            "solution": "所述问题在科学上是合理的，在数学上是适定的，并包含了唯一且可验证解所需的所有信息。它提出了计算工程领域中的一个标准任务：动态模态分解 (DMD) 算法的实现与分析。研究的重点是 DMD 的一个关键参数——秩截断——如何影响动态模态的辨识，特别是在涉及频率相近、低能量模态和秩严重受限等挑战性场景中。因此，我将首先从第一性原理出发推导所需的算法，然后进行实现。\n\nDMD 的基本前提是，一个由状态向量（快照）序列 $\\{x_k\\}_{k=0}^{m-1}$（其中 $x_k \\in \\mathbb{C}^n$）表示的系统演化，可以由一个线性时不变算子 $A \\in \\mathbb{C}^{n \\times n}$ 来近似。这意味着以下关系：\n$$\nx_{k+1} \\approx A x_k\n$$\n通过构建两个数据矩阵 $X = [x_0, x_1, \\dots, x_{m-2}]$ 和 $Y = [x_1, x_2, \\dots, x_{m-1}]$（均为 $\\mathbb{C}^{n \\times (m-1)}$），可以将此关系扩展到整个快照序列。系统动力学随后可以紧凑地表示为：\n$$\nY \\approx A X\n$$\n通过求解最小二乘问题 $\\min_A \\| Y - A X \\|_F$（其中 $\\| \\cdot \\|_F$ 是弗罗贝尼乌斯范数），可以找到最能模拟从 $X$ 到 $Y$ 的转变的算子 $A$。解由 $A = Y X^+$ 给出，其中 $X^+$ 表示 $X$ 的摩尔-彭若斯伪逆。\n\n对于状态维度 $n$ 很大的系统，构建和分析 $n \\times n$ 矩阵 $A$ 的计算成本很高，且通常难以处理。目标是在不显式构建 $A$ 的情况下，确定 $A$ 的谱特性（其特征值和特征向量），这些特性表征了系统的动态模态。这是通过使用数据矩阵 $X$ 的奇异值分解 (SVD) 的投影方法来实现的。\n\n$X$ 的 SVD 由 $X = U \\Sigma V^H$ 给出，其中 $U \\in \\mathbb{C}^{n \\times q}$ 和 $V \\in \\mathbb{C}^{(m-1) \\times q}$ 是具有标准正交列的矩阵，$\\Sigma \\in \\mathbb{R}^{q \\times q}$ 是一个由正奇异值 $\\sigma_i$ 构成的对角矩阵，其中 $q = \\min(n, m-1)$。$U$ 的列构成了一个能最优地捕捉快照中能量的基。降秩 DMD 的核心思想是将动力学投影到由 $U$ 的前 $r$ 列张成的 $r \\le q$ 秩的低维子空间上。这通过截断 SVD 来实现：\n$$\nX \\approx X_r = U_r \\Sigma_r V_r^H\n$$\n其中 $U_r \\in \\mathbb{C}^{n \\times r}$、$\\Sigma_r \\in \\mathbb{R}^{r \\times r}$ 和 $V_r \\in \\mathbb{C}^{(m-1) \\times r}$ 是截断后的 SVD 矩阵。秩-$r$ 近似数据矩阵的伪逆是 $X_r^+ = V_r \\Sigma_r^{-1} U_r^H$。算子 $A$ 的低秩近似则是：\n$$\nA \\approx Y X_r^+ = Y V_r \\Sigma_r^{-1} U_r^H\n$$\n动力学被投影到由 POD 模态（$U_r$ 的列）张成的子空间上。降维算子 $\\tilde{A} \\in \\mathbb{C}^{r \\times r}$ 表示 $A$ 在此投影子空间中的作用，定义为 $\\tilde{A} = U_r^H A U_r$。$\\tilde{A}$ 的特征值近似于 $A$ 的主导特征值。代入 $A$ 的表达式并利用 $U_r^H U_r = I_r$（大小为 $r$ 的单位矩阵）的性质，我们得到降维算子的最终表达式：\n$$\n\\tilde{A} = U_r^H (Y V_r \\Sigma_r^{-1} U_r^H) U_r = U_r^H Y V_r \\Sigma_r^{-1}\n$$\n这个小的 $r \\times r$ 矩阵 $\\tilde{A}$ 的特征值就是秩-$r$ DMD 特征值。\n\n因此，计算流程如下：\n$1$. 从快照的时间序列构建数据矩阵 $X, Y$。\n$2$. 计算 $X$ 的 SVD：$X = U \\Sigma V^H$。\n$3$. 将 SVD 分量截断至指定的秩 $r$，得到 $U_r$、$\\Sigma_r$ 和 $V_r$。\n$4$. 计算低秩系统算子表示 $\\tilde{A} = U_r^H Y V_r \\Sigma_r^{-1}$。\n$5$. 计算 $\\tilde{A}$ 的特征值，即所需的 DMD 特征值 $\\{\\mu_\\ell\\}_{\\ell=1}^r$。\n\n对于给定的问题，合成数据由已知模态的叠加生成，$x_k = \\sum_{j=1}^{p} a_j \\phi_j \\lambda_j^{\\star k}$，其中 $\\lambda_j^\\star = e^{\\sigma_j + \\mathrm{i}\\omega_j}$ 是真实的离散时间特征值。计算出的 DMD 特征值 $\\{\\mu_\\ell\\}$ 与真实特征值集合 $\\{\\lambda_j^\\star\\}$ 进行比较。如果幅值差 $|\\,|\\mu_\\ell| - |\\lambda_j^\\star|\\,| \\le \\tau_m$ 和环绕角差异 $\\min(|\\arg(\\mu_\\ell) - \\arg(\\lambda_j^\\star)|, 2\\pi - |\\arg(\\mu_\\ell) - \\arg(\\lambda_j^\\star)|) \\le \\tau_\\omega$ 都满足，则声明匹配，使用指定的容差 $\\tau_m=10^{-3}$ 和 $\\tau_\\omega=10^{-3}$。使用一对一匹配协议来计算正确辨识的模态数量。以下代码为五个指定的测试案例实现了此流程。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the DMD problem for a suite of test cases.\n    Derives DMD eigenvalues for different ranks and physical parameters,\n    and counts the number of correctly identified modes.\n    \"\"\"\n\n    # Global parameters as defined in the problem statement\n    n_sensors = 6\n    tau_omega = 1e-3\n    tau_m = 1e-3\n    rng_seed = 12345\n\n    # Define the five test cases\n    test_cases = [\n        # Case 1 (baseline, well-separated)\n        {'m': 300, 'p': 3, 'omega': np.array([0.40, 1.10, 2.20]), \n         'sigma': np.array([0.00, 0.00, 0.00]), 'a': np.array([1.00, 0.80, 0.50]), 'r': 3},\n        # Case 2 (closely spaced pair, adequate rank)\n        {'m': 400, 'p': 3, 'omega': np.array([0.20, 0.205, 1.00]), \n         'sigma': np.array([0.00, 0.00, 0.00]), 'a': np.array([1.00, 1.00, 0.30]), 'r': 3},\n        # Case 3 (closely spaced pair, insufficient rank)\n        {'m': 400, 'p': 3, 'omega': np.array([0.20, 0.205, 1.00]), \n         'sigma': np.array([0.00, 0.00, 0.00]), 'a': np.array([1.00, 1.00, 0.30]), 'r': 2},\n        # Case 4 (low-energy, decaying mode)\n        {'m': 300, 'p': 3, 'omega': np.array([0.50, 1.20, 1.80]), \n         'sigma': np.array([0.00, 0.00, -0.02]), 'a': np.array([1.00, 0.80, 0.05]), 'r': 3},\n        # Case 5 (boundary rank)\n        {'m': 300, 'p': 3, 'omega': np.array([0.25, 0.80, 1.60]), \n         'sigma': np.array([0.00, 0.00, 0.00]), 'a': np.array([1.00, 0.80, 0.50]), 'r': 1},\n    ]\n\n    # Fix the random number generator seed for reproducibility\n    np.random.seed(rng_seed)\n\n    # Generate spatial modes once, as they are used across all cases\n    # The problem implies new random modes for each case. The seed is reset before each construction.\n    # To be safe and compliant, let's create random modes inside the loop.\n\n    results = []\n    for case_params in test_cases:\n        # Unpack parameters for the current case\n        m = case_params['m']\n        p = case_params['p']\n        omega_true = case_params['omega']\n        sigma_true = case_params['sigma']\n        a_true = case_params['a']\n        r = case_params['r']\n\n        # --- 1. Generate Data ---\n        # Generate p random, orthonormal spatial modes phi_j in C^n\n        # Set seed before each case to ensure case-specific reproducibility\n        np.random.seed(rng_seed)\n        phi_modes = np.zeros((n_sensors, p), dtype=np.complex128)\n        for j in range(p):\n            vec = np.random.randn(n_sensors) + 1j * np.random.randn(n_sensors)\n            phi_modes[:, j] = vec / np.linalg.norm(vec)\n\n        # True discrete-time eigenvalues\n        lambda_true = np.exp(sigma_true + 1j * omega_true)\n        \n        # Time steps\n        k_steps = np.arange(m)\n        \n        # Temporal evolution of each mode (Vandermonde matrix)\n        temporal_dynamics = np.exp(np.outer(k_steps, sigma_true + 1j * omega_true))\n        \n        # Superposition of modes to generate snapshots\n        # snapshots = phi * diag(a) * V.T\n        snapshots = phi_modes @ np.diag(a_true) @ temporal_dynamics.T\n\n        # Create data matrices X and Y\n        X = snapshots[:, :-1]\n        Y = snapshots[:, 1:]\n\n        # --- 2. Apply Rank-r DMD ---\n        # SVD of X\n        U, s, Vh = np.linalg.svd(X, full_matrices=False)\n\n        # Truncate to rank r\n        Ur = U[:, :r]\n        Sr = s[:r]\n        Vr = Vh[:r, :].conj().T\n        \n        # Compute reduced operator A_tilde\n        # A_tilde = Ur^H * Y * Vr * inv(Sr)\n        Sr_inv = np.diag(1.0 / Sr)\n        A_tilde = Ur.conj().T @ Y @ Vr @ Sr_inv\n        \n        # Compute DMD eigenvalues\n        dmd_eigvals = np.linalg.eig(A_tilde)[0]\n        \n        # --- 3. Match Eigenvalues and Count ---\n        true_mags = np.exp(sigma_true)\n        true_angles = omega_true\n\n        computed_mags = np.abs(dmd_eigvals)\n        computed_angles = np.angle(dmd_eigvals)\n\n        count = 0\n        matched_computed_indices = set()\n        \n        # One-to-one matching: for each true mode, find one unique matching computed mode\n        for j in range(p):\n            for i in range(r):\n                if i in matched_computed_indices:\n                    continue\n\n                # Check magnitude condition\n                mag_diff = np.abs(computed_mags[i] - true_mags[j])\n                is_mag_match = mag_diff = tau_m\n\n                # Check angle condition (wrapped difference)\n                angle_diff = computed_angles[i] - true_angles[j]\n                wrapped_angle_diff = np.abs((angle_diff + np.pi) % (2 * np.pi) - np.pi)\n                is_angle_match = wrapped_angle_diff = tau_omega\n                \n                if is_mag_match and is_angle_match:\n                    count += 1\n                    matched_computed_indices.add(i)\n                    break # Move to the next true mode\n\n        results.append(count)\n\n    # Print the final results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "掌握一个工具的强大功能固然重要，但理解其局限性则更为关键。这项练习将挑战您对 DMD 的认知边界，探讨当它被应用于一个纯随机过程（如随机游走）时会发生什么 。DMD 旨在提取数据中确定性的、连贯的结构，但当数据本身缺乏这种结构时，它所“发现”的模态究竟代表什么？通过这个思想实验，您将学会审慎地解读 DMD 的输出，区分真实的物理动态与随机性产生的统计假象，这是成为一名负责任的计算科学家所必备的批判性思维能力。",
            "id": "2387414",
            "problem": "考虑一个$m$维向量值离散时间过程，由纯随机游走定义\n$$\n\\mathbf{x}_{k+1} = \\mathbf{x}_{k} + \\boldsymbol{\\eta}_{k},\n$$\n其中 $\\{\\boldsymbol{\\eta}_{k}\\}$ 是一个独立同分布的零均值随机向量序列，其协方差矩阵 $\\boldsymbol{\\Sigma} \\in \\mathbb{R}^{m \\times m}$ 是正定的，并且与 $\\mathbf{x}_{k}$ 独立。您收集了 $n$ 个连续快照 $\\{\\mathbf{x}_{0}, \\mathbf{x}_{1}, \\dots, \\mathbf{x}_{n}\\}$，并构成快照矩阵 $\\mathbf{X} = [\\mathbf{x}_{0}\\ \\mathbf{x}_{1}\\ \\dots\\ \\mathbf{x}_{n-1}]$ 和 $\\mathbf{X}^{\\prime} = [\\mathbf{x}_{1}\\ \\mathbf{x}_{2}\\ \\dots\\ \\mathbf{x}_{n}]$。标准动态模态分解 (DMD) 旨在寻找一个线性映射 $\\mathbf{A}$，该映射在最小二乘意义上将状态从 $\\mathbf{X}$ 推进到 $\\mathbf{X}^{\\prime}$，然后将 $\\mathbf{A}$ 的特征值和特征向量解释为时间速率和空间模态。\n\n仅使用上述定义、最小二乘法的基本性质、独立性以及大数定律，推断此随机游走的DMD拟合的渐近行为（当 $n \\to \\infty$ 时）以及所得模态的可解释性。以下哪个陈述最为准确？选择所有适用项。\n\nA. 在期望意义上，当 $n \\to \\infty$ 时，最小二乘DMD算子收敛于单位映射，因此其特征值聚集在1附近，且相关联的模态不是唯一确定的，也不代表动力学的相干确定性结构。\n\nB. 即使对于白噪声驱动的随机游走，DMD通常也会识别出由采样间隔决定的频率上的振荡模态，反映了过程中的隐藏周期性。\n\nC. 随着 $n$ 的增加，DMD模态收敛于噪声协方差的主成分，因此代表了底层动力学中具有物理意义的相干结构。\n\nD. 对随机游走数据采用时间延迟嵌入（Hankel-DMD）将揭示一个严格位于单位圆内部的占主导地位的稳定特征值，从而暴露过程的潜在衰减率。\n\nE. 在具有各向异性噪声协方差的更高维度中，估计的DMD模态倾向于与数据中最大方差的方向对齐；然而，这些方向是随机强迫造成的假象，而非确定性演化中具有物理意义的模态形状。",
            "solution": "对问题陈述进行验证。\n\n**步骤1：提取已知条件**\n-   $m$维向量值离散时间过程：$\\{\\mathbf{x}_k\\}$。\n-   动力学方程：$\\mathbf{x}_{k+1} = \\mathbf{x}_{k} + \\boldsymbol{\\eta}_{k}$。\n-   噪声过程 $\\{\\boldsymbol{\\eta}_{k}\\}$ 是一个独立同分布（i.i.d.）的随机向量序列。\n-   噪声性质：$\\mathbb{E}[\\boldsymbol{\\eta}_{k}] = \\mathbf{0}$ 和 $\\mathbb{E}[\\boldsymbol{\\eta}_{k} \\boldsymbol{\\eta}_{k}^T] = \\boldsymbol{\\Sigma}$，其中 $\\boldsymbol{\\Sigma}$ 是 $\\mathbb{R}^{m \\times m}$ 中的一个正定矩阵。\n-   独立性：$\\boldsymbol{\\eta}_{k}$ 与 $\\mathbf{x}_{k}$ 独立。\n-   数据矩阵：$\\mathbf{X} = [\\mathbf{x}_{0}\\ \\mathbf{x}_{1}\\ \\dots\\ \\mathbf{x}_{n-1}]$ 和 $\\mathbf{X}^{\\prime} = [\\mathbf{x}_{1}\\ \\mathbf{x}_{2}\\ \\dots\\ \\mathbf{x}_{n}]$。\n-   DMD算子定义：$\\mathbf{A}$ 是最小二乘问题 $\\min_{\\mathbf{A}} \\|\\mathbf{X}^{\\prime} - \\mathbf{A}\\mathbf{X}\\|_F^2$ 的解。\n-   任务：分析DMD算子 $\\mathbf{A}$ 的渐近行为（当 $n \\to \\infty$ 时）及其模态的解释。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题具有科学依据，定义了一个标准随机游走过程和标准动态模态分解（DMD）算法。这些概念来自随机过程和计算工程等成熟领域。该问题是适定的，为分析DMD估计量的渐近性质提供了足够的信息。语言客观且精确。问题设定是自洽的，没有矛盾。该问题适合进行分析。\n\n**步骤3：结论与行动**\n该问题有效。我们开始求解。\n\n最小化残差的弗罗贝尼乌斯范数 $\\|\\mathbf{X}^{\\prime} - \\mathbf{A}\\mathbf{X}\\|_F$ 的DMD算子 $\\mathbf{A}$ 由表达式 $\\mathbf{A} = \\mathbf{X}^{\\prime}\\mathbf{X}^{\\dagger}$ 给出，其中 $\\mathbf{X}^{\\dagger}$ 表示 $\\mathbf{X}$ 的摩尔-彭若斯伪逆。对于大量快照 $n$（其中 $n  m$），伪逆通常计算为 $\\mathbf{X}^{\\dagger} = \\mathbf{X}^T(\\mathbf{X}\\mathbf{X}^T)^{-1}$。因此，该算子为：\n$$ \\mathbf{A} = (\\mathbf{X}^{\\prime}\\mathbf{X}^T)(\\mathbf{X}\\mathbf{X}^T)^{-1} $$\n让我们定义样本相关矩阵（相差一个 $1/n$ 的缩放因子）：\n$$ \\mathbf{C}_{X'X} = \\mathbf{X}^{\\prime}\\mathbf{X}^T = \\sum_{k=0}^{n-1} \\mathbf{x}_{k+1}\\mathbf{x}_k^T $$\n$$ \\mathbf{C}_{XX} = \\mathbf{X}\\mathbf{X}^T = \\sum_{k=0}^{n-1} \\mathbf{x}_{k}\\mathbf{x}_k^T $$\n所以，$\\mathbf{A} = \\mathbf{C}_{X'X}\\mathbf{C}_{XX}^{-1}$。\n\n我们将过程定义 $\\mathbf{x}_{k+1} = \\mathbf{x}_{k} + \\boldsymbol{\\eta}_{k}$ 代入 $\\mathbf{C}_{X'X}$ 的表达式中：\n$$ \\mathbf{C}_{X'X} = \\sum_{k=0}^{n-1} (\\mathbf{x}_{k} + \\boldsymbol{\\eta}_{k})\\mathbf{x}_k^T = \\sum_{k=0}^{n-1} \\mathbf{x}_{k}\\mathbf{x}_k^T + \\sum_{k=0}^{n-1} \\boldsymbol{\\eta}_{k}\\mathbf{x}_k^T = \\mathbf{C}_{XX} + \\sum_{k=0}^{n-1} \\boldsymbol{\\eta}_{k}\\mathbf{x}_k^T $$\n于是DMD算子可以写成：\n$$ \\mathbf{A} = \\left(\\mathbf{C}_{XX} + \\sum_{k=0}^{n-1} \\boldsymbol{\\eta}_{k}\\mathbf{x}_k^T\\right) \\mathbf{C}_{XX}^{-1} = \\mathbf{I} + \\left(\\sum_{k=0}^{n-1} \\boldsymbol{\\eta}_{k}\\mathbf{x}_k^T\\right) \\left(\\sum_{k=0}^{n-1} \\mathbf{x}_{k}\\mathbf{x}_k^T\\right)^{-1} $$\n为了理解当 $n \\to \\infty$ 时的渐近行为，我们必须分析第二项。过程 $\\mathbf{x}_k$ 是一个随机游走，一个非平稳过程。$\\mathbf{x}_k$ 的协方差（为便于分析，不失一般性地假设 $\\mathbf{x}_0 = \\mathbf{0}$）为 $\\mathbb{E}[\\mathbf{x}_k \\mathbf{x}_k^T] = k\\boldsymbol{\\Sigma}$。\n分母项 $\\sum_{k=0}^{n-1} \\mathbf{x}_{k}\\mathbf{x}_k^T$ 是一个矩阵之和，其“大小”随 $k$ 增长。该和的量级为 $O(n^2)$。具体而言，单位根计量经济学的结果表明，$\\frac{1}{n^2}\\sum_{k=0}^{n-1} \\mathbf{x}_{k}\\mathbf{x}_k^T$ 依分布收敛到一个与维纳过程的积分相关的随机矩阵。\n分子项是 $\\sum_{k=0}^{n-1} \\boldsymbol{\\eta}_{k}\\mathbf{x}_k^T$。可以证明该项的方差量级为 $O(n^2)$，这意味着该项本身的随机量级为 $O(n)$。\n\n因此，扰动项的表现为 $O(n) / O(n^2) = O(1/n)$。当 $n \\to \\infty$ 时，该项依概率收敛于零矩阵。\n$$ \\mathbf{A}_n \\xrightarrow{p} \\mathbf{I} \\quad \\text{当 } n \\to \\infty \\text{ 时} $$\nDMD算子一致地估计出单位算子 $\\mathbf{I}$，这正确地表示了动力学的条件期望：$\\mathbb{E}[\\mathbf{x}_{k+1}|\\mathbf{x}_k] = \\mathbf{x}_k = \\mathbf{I}\\mathbf{x}_k$。\n\n在此基础上，我们评估每个选项。\n\n**A. 在期望意义上，当 $n \\to \\infty$ 时，最小二乘DMD算子收敛于单位映射，因此其特征值聚集在1附近，且相关联的模态不是唯一确定的，也不代表动力学的相干确定性结构。**\n如上所推导，当 $n \\to \\infty$ 时，算子 $\\mathbf{A}$ 收敛于单位矩阵 $\\mathbf{I}$。这意味着 $\\mathbf{A}$ 的特征值必须收敛于 $\\mathbf{I}$ 的特征值，而 $\\mathbf{I}$ 的特征值全部为1。与单位矩阵特征值1相关联的特征空间是整个空间 $\\mathbb{R}^m$。这意味着 $\\mathbb{R}^m$ 的任何一组基都构成了一组有效的特征向量。因此，在极限情况下，特征向量（DMD模态）不是唯一确定的。由于底层过程是纯随机的，这些模态不能代表“相干的确定性结构”，因为这样的结构根本不存在。“在期望意义上...收敛”是一种稍微宽松但常见的说法，用以表明估计量是一致的，而它确实是一致的。这个陈述是对数学极限的正确描述。\n**结论：正确**\n\n**B. 即使对于白噪声驱动的随机游走，DMD通常也会识别出由采样间隔决定的频率上的振荡模态，反映了过程中的隐藏周期性。**\n随机游走是白噪声过程的离散时间积分。其功率谱与 $1/f^2$（对于连续时间下的对应情况，即布朗运动）或 $|\\sin(\\omega/2)|^{-2}$（对于离散情况）成正比，显示出功率集中在低频区域。它不包含任何周期性，无论是隐藏的还是其他的。虽然有限数据的DMD可能会产生虚假的共轭复数特征值对（意味着振荡），但这些是噪声和有限采样的假象，而不是任何底层周期性动力学的反映。当 $n \\to \\infty$ 时，主要行为是所有特征值都聚集在1附近。该陈述错误地断言了隐藏周期性的存在。\n**结论：不正确**\n\n**C. 随着 $n$ 的增加，DMD模态收敛于噪声协方差的主成分，因此代表了底层动力学中具有物理意义的相干结构。**\n噪声协方差的主成分是 $\\boldsymbol{\\Sigma}$ 的特征向量。随机游走数据 $\\{\\mathbf{x}_k\\}$ 中的主要方差方向，即所谓的主正交分解（POD）模态，确实与 $\\boldsymbol{\\Sigma}$ 的特征向量对齐。一个已知的现象是，对于噪声系统，DMD模态倾向于近似POD模态。因此，陈述的第一部分是合理的。然而，“这些模态代表了底层动力学中具有物理意义的相干结构”这一结论根本上是错误的。这些方向完全由随机强迫项 $\\boldsymbol{\\eta}_k$ 的统计各向异性决定，而不对应于任何确定性的、相干的演化。它们是统计假象。\n**结论：不正确**\n\n**D. 对随机游走数据采用时间延迟嵌入（Hankel-DMD）将揭示一个严格位于单位圆内部的占主导地位的稳定特征值，从而暴露过程的潜在衰减率。**\n随机游走是一个积分过程，其特征是存在单位根。用自回归模型的术语来说，它是一个系数为1的AR(1)过程。应用Hankel-DMD类似于拟合一个高阶自回归模型。对于一个单位根过程，任何这样的拟合都会得出一个非常接近1的估计主导特征值。它将位于单位圆上或极度靠近单位圆。关于它会“严格位于内部”并揭示“潜在衰减率”的说法是不正确的。该过程是非平稳的，其方差是增长的，而不是衰减的。一个小于1的估计特征值（例如0.999）将是一个众所周知​​的有限样本偏差，而不是真实稳定动力学的证据。\n**结论：不正确**\n\n**E. 在具有各向异性噪声协方差的更高维度中，估计的DMD模态倾向于与数据中最大方差的方向对齐；然而，这些方向是随机强迫造成的假象，而非确定性演化中具有物理意义的模态形状。**\n这个陈述正确地综合了几个要点。“各向异性噪声协方差”意味着 $\\boldsymbol{\\Sigma}$ 与 $\\mathbf{I}$ 不成正比。 “数据中最大方差的方向”是主导POD模态。正如在对选项C的分析中指出的，对于随机游走，这些方向由 $\\boldsymbol{\\Sigma}$ 的特征向量决定。声称估计的DMD模态“倾向于与”这些POD模态对齐，是对在 $n$ 较大但有限的情况下实践中观察到的行为的正确描述。该陈述的关键部分是其解释：“这些方向是随机强迫造成的假象，而非具有物理意义的模态形状。”这正是正确的结论。DMD发现的结构源于噪声的统计特性，而非确定性系统。这个选项对DMD应用于此过程时会发现什么，提供了一个微妙且物理上正确的说明。\n**结论：正确**",
            "answer": "$$\\boxed{AE}$$"
        }
    ]
}