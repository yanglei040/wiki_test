{
    "hands_on_practices": [
        {
            "introduction": "物理信息神经网络（PINN）的核心在于其损失函数，它将物理定律和数据约束转化为一个可优化的目标。本练习将指导您从零开始构建一个复合损失函数。您将亲手组合三个关键部分：偏微分方程（PDE）的残差、初始条件的数据失配，以及一个作为软约束的物理守恒定律。通过这个实践，您将清晰地理解如何将不同的物理要求编码到一个统一的机器学习框架中。",
            "id": "2411025",
            "problem": "考虑周期域上的一维热方程。设 $x \\in [0,1]$ 且 $t \\in [0,0.1]$。场 $u(x,t)$ 由一个在物理信息神经网络 (PINN) 中使用的代理模型建模，其参数形式如下：\n$$\nu(x,t;\\theta) \\;=\\; \\theta_1 \\cdot 1 \\;+\\; \\theta_2 \\sin(2\\pi x) \\;+\\; \\theta_3 \\cos(2\\pi x) \\;+\\; \\theta_4\\, t\\, \\sin(2\\pi x) \\;+\\; \\theta_5\\, t\\, \\cos(2\\pi x),\n$$\n其中 $\\theta = (\\theta_1,\\theta_2,\\theta_3,\\theta_4,\\theta_5) \\in \\mathbb{R}^5$ 是可训练参数。其控制偏微分方程 (PDE) 为热方程：\n$$\nu_t \\;-\\; \\nu\\, u_{xx} \\;=\\; 0,\n$$\n其中粘度 $\\nu \\ge 0$，且在 $x$ 方向上具有周期性边界条件。初始条件指定为\n$$\nu(x,0) \\;=\\; u_0(x) \\;=\\; 0.5 \\;+\\; \\sin(2\\pi x),\n$$\n因此，由周期性所蕴含的守恒空间积分（总质量）为\n$$\nM_0 \\;=\\; \\int_0^1 u(x,0)\\,dx \\;=\\; 0.5.\n$$\n\n定义一个复合 PINN 损失函数，它将 PDE、初始条件数据和守恒定律作为软约束来强制执行：\n$$\n\\mathcal{L}_{\\text{total}}(\\theta;\\nu,w_{\\text{pde}},w_{\\text{data}},w_{\\text{cons}}) \\;=\\; w_{\\text{pde}}\\,\\mathcal{L}_{\\text{pde}}(\\theta;\\nu) \\;+\\; w_{\\text{data}}\\,\\mathcal{L}_{\\text{data}}(\\theta) \\;+\\; w_{\\text{cons}}\\,\\mathcal{L}_{\\text{cons}}(\\theta),\n$$\n其中\n- PDE 残差损失 $\\mathcal{L}_{\\text{pde}}$ 是在固定配置点网格上评估的残差 $r(x,t;\\theta,\\nu) = u_t(x,t;\\theta) - \\nu\\,u_{xx}(x,t;\\theta)$ 的均方值：\n$$\n\\mathcal{L}_{\\text{pde}}(\\theta;\\nu) \\;=\\; \\frac{1}{|\\mathcal{G}|} \\sum_{(x,t)\\in \\mathcal{G}} \\left[ u_t(x,t;\\theta) \\;-\\; \\nu\\,u_{xx}(x,t;\\theta) \\right]^2,\n$$\n配置点网格为 $\\mathcal{G} = \\{0,\\, 0.25,\\, 0.5,\\, 0.75,\\, 1.0\\} \\times \\{0,\\, 0.05,\\, 0.1\\}$。\n- 数据损失 $\\mathcal{L}_{\\text{data}}$ 是在指定数据点上与初始条件的均方不匹配：\n$$\n\\mathcal{L}_{\\text{data}}(\\theta) \\;=\\; \\frac{1}{|\\mathcal{D}|} \\sum_{x\\in \\mathcal{D}} \\left[ u(x,0;\\theta) \\;-\\; u_0(x) \\right]^2,\n$$\n初始数据集为 $\\mathcal{D} = \\{0,\\, 0.25,\\, 0.5,\\, 0.75,\\, 1.0\\}$。\n- 守恒软约束损失 $\\mathcal{L}_{\\text{cons}}$ 强制 $u$ 在选定时间点上对 $x$ 的积分保持等于 $M_0$：\n$$\n\\mathcal{L}_{\\text{cons}}(\\theta) \\;=\\; \\frac{1}{|\\mathcal{T}_{\\text{mass}}|} \\sum_{t\\in \\mathcal{T}_{\\text{mass}}} \\left[ \\left( \\int_0^1 u(x,t;\\theta)\\,dx \\right) - M_0 \\right]^2,\n$$\n其中 $\\mathcal{T}_{\\text{mass}} = \\{0,\\, 0.05,\\, 0.1\\}$。对于给定的代理模型 $u$，积分 $\\int_0^1 u(x,t;\\theta)\\,dx$ 必须精确计算。\n\n所需的导数由代理模型通过常规微积分法则定义：\n$$\nu_t(x,t;\\theta) \\;=\\; \\theta_4\\,\\sin(2\\pi x) \\;+\\; \\theta_5\\,\\cos(2\\pi x),\n$$\n$$\nu_{xx}(x,t;\\theta) \\;=\\; - (2\\pi)^2 \\left[ \\theta_2 \\sin(2\\pi x) \\;+\\; \\theta_3 \\cos(2\\pi x) \\;+\\; \\theta_4\\,t\\,\\sin(2\\pi x) \\;+\\; \\theta_5\\,t\\,\\cos(2\\pi x) \\right].\n$$\n对于所用基函数，在一个空间周期上的精确积分满足\n$$\n\\int_0^1 \\sin(2\\pi x)\\,dx \\;=\\; 0,\\quad \\int_0^1 \\cos(2\\pi x)\\,dx \\;=\\; 0,\\quad \\int_0^1 1\\,dx \\;=\\; 1,\n$$\n因此对于指定的代理模型，\n$$\n\\int_0^1 u(x,t;\\theta)\\,dx \\;=\\; \\theta_1.\n$$\n\n您的程序必须为以下每个测试用例计算 $\\mathcal{L}_{\\text{total}}$，每个用例由一个元组 $(\\theta,\\nu,w_{\\text{pde}},w_{\\text{data}},w_{\\text{cons}})$ 给出：\n- 测试用例 1：$\\theta = (0.3,\\, 0.8,\\, -0.2,\\, 0.1,\\, 0.05)$，$\\nu = 0.1$，$w_{\\text{pde}} = 1.0$，$w_{\\text{data}} = 1.0$，$w_{\\text{cons}} = 0.0$。\n- 测试用例 2：$\\theta = (0.3,\\, 0.8,\\, -0.2,\\, 0.1,\\, 0.05)$，$\\nu = 0.1$，$w_{\\text{pde}} = 1.0$，$w_{\\text{data}} = 1.0$，$w_{\\text{cons}} = 10.0$。\n- 测试用例 3：$\\theta = (0.7,\\, -0.5,\\, 0.25,\\, 0.0,\\, 0.0)$，$\\nu = 0.0$，$w_{\\text{pde}} = 1.0$，$w_{\\text{data}} = 1.0$，$w_{\\text{cons}} = 5.0$。\n- 测试用例 4：$\\theta = (0.5,\\, 0.0,\\, 1.0,\\, 0.0,\\, 0.0)$，$\\nu = 0.05$，$w_{\\text{pde}} = 0.5$，$w_{\\text{data}} = 2.0$，$w_{\\text{cons}} = 2.0$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $[r_1,r_2,r_3,r_4]$），其中 $r_i$ 是测试用例 $i$ 的 $\\mathcal{L}_{\\text{total}}$ 计算值。不得打印任何额外文本。",
            "solution": "问题陈述已被解析并确定为有效。该问题具有科学依据、良定、客观且自洽，是计算科学与工程领域中的一个标准任务，特别涉及物理信息神经网络 (PINN)。我们可以继续进行求解。\n\n目标是为四个不同的测试用例计算总损失函数 $\\mathcal{L}_{\\text{total}}$。总损失是三个分量的加权和：PDE 残差损失 $\\mathcal{L}_{\\text{pde}}$、数据不匹配损失 $\\mathcal{L}_{\\text{data}}$ 和守恒定律损失 $\\mathcal{L}_{\\text{cons}}$。\n$$\n\\mathcal{L}_{\\text{total}}(\\theta;\\nu,w_{\\text{pde}},w_{\\text{data}},w_{\\text{cons}}) = w_{\\text{pde}}\\,\\mathcal{L}_{\\text{pde}}(\\theta;\\nu) + w_{\\text{data}}\\,\\mathcal{L}_{\\text{data}}(\\theta) + w_{\\text{cons}}\\,\\mathcal{L}_{\\text{cons}}(\\theta)\n$$\n我们将为每个分量损失分析并推导显式计算公式。\n\n**1. 数据损失 $\\mathcal{L}_{\\text{data}}(\\theta)$**\n\n数据损失衡量了代理模型在时间 $t=0$ 时的预测值与给定初始条件 $u_0(x)$ 之间的均方误差。在 $t=0$ 时的代理模型为\n$$\nu(x,0;\\theta) = \\theta_1 + \\theta_2 \\sin(2\\pi x) + \\theta_3 \\cos(2\\pi x).\n$$\n初始条件为 $u_0(x) = 0.5 + \\sin(2\\pi x)$。在点 $x$ 处的误差为\n$$\ne_d(x;\\theta) = u(x,0;\\theta) - u_0(x) = (\\theta_1 - 0.5) + (\\theta_2 - 1)\\sin(2\\pi x) + \\theta_3 \\cos(2\\pi x).\n$$\n损失是在离散点集 $\\mathcal{D} = \\{0, 0.25, 0.5, 0.75, 1.0\\}$ 上 $e_d(x;\\theta)^2$ 的平均值。该集合的大小为 $|\\mathcal{D}| = 5$。\n$$\n\\mathcal{L}_{\\text{data}}(\\theta) = \\frac{1}{5} \\sum_{x \\in \\mathcal{D}} \\left[ e_d(x;\\theta) \\right]^2.\n$$\n我们在 $\\mathcal{D}$ 中的点上计算三角函数值：\n- 对于 $x \\in \\{0, 1.0\\}$，$\\sin(2\\pi x)=0$，$\\cos(2\\pi x)=1$。\n- 对于 $x = 0.25$，$\\sin(2\\pi x)=1$，$\\cos(2\\pi x)=0$。\n- 对于 $x = 0.5$，$\\sin(2\\pi x)=0$，$\\cos(2\\pi x)=-1$。\n- 对于 $x = 0.75$，$\\sin(2\\pi x)=-1$，$\\cos(2\\pi x)=0$。\n平方误差之和为：\n$$\n\\sum_{x \\in \\mathcal{D}} [e_d(x;\\theta)]^2 = [(\\theta_1-0.5)+\\theta_3]^2_{x=0} + [(\\theta_1-0.5)+(\\theta_2-1)]^2_{x=0.25} + [(\\theta_1-0.5)-\\theta_3]^2_{x=0.5} + [(\\theta_1-0.5)-(\\theta_2-1)]^2_{x=0.75} + [(\\theta_1-0.5)+\\theta_3]^2_{x=1.0}.\n$$\n该表达式可以直接实现。\n\n**2. 守恒损失 $\\mathcal{L}_{\\text{cons}}(\\theta)$**\n\n守恒损失惩罚了对守恒量 $M_0 = 0.5$ 的偏离。代理模型在空间域 $[0,1]$ 上的积分给出如下：\n$$\n\\int_0^1 u(x,t;\\theta)\\,dx = \\int_0^1 \\left( \\theta_1 + \\theta_2 \\sin(2\\pi x) + \\theta_3 \\cos(2\\pi x) + \\theta_4 t \\sin(2\\pi x) + \\theta_5 t \\cos(2\\pi x) \\right) dx.\n$$\n根据正交关系 $\\int_0^1 \\sin(2\\pi x)dx = 0$ 和 $\\int_0^1 \\cos(2\\pi x)dx = 0$，积分简化为：\n$$\n\\int_0^1 u(x,t;\\theta)\\,dx = \\theta_1 \\int_0^1 1\\,dx = \\theta_1.\n$$\n此结果与时间 $t$ 无关。损失定义为：\n$$\n\\mathcal{L}_{\\text{cons}}(\\theta) = \\frac{1}{|\\mathcal{T}_{\\text{mass}}|} \\sum_{t \\in \\mathcal{T}_{\\text{mass}}} \\left[ \\left( \\int_0^1 u(x,t;\\theta)\\,dx \\right) - M_0 \\right]^2 = \\frac{1}{3} \\sum_{t \\in \\mathcal{T}_{\\text{mass}}} [\\theta_1 - 0.5]^2.\n$$\n由于要求和的项不依赖于 $t$，因此简化为：\n$$\n\\mathcal{L}_{\\text{cons}}(\\theta) = \\frac{1}{3} \\cdot 3 \\cdot (\\theta_1 - 0.5)^2 = (\\theta_1 - 0.5)^2.\n$$\n\n**3. PDE 残差损失 $\\mathcal{L}_{\\text{pde}}(\\theta; \\nu)$**\n\nPDE 残差为 $r(x,t;\\theta,\\nu) = u_t - \\nu u_{xx}$。使用所提供的导数：\n$$\nu_t(x,t;\\theta) = \\theta_4 \\sin(2\\pi x) + \\theta_5 \\cos(2\\pi x)\n$$\n$$\nu_{xx}(x,t;\\theta) = -(2\\pi)^2 \\left( (\\theta_2 + \\theta_4 t) \\sin(2\\pi x) + (\\theta_3 + \\theta_5 t) \\cos(2\\pi x) \\right)\n$$\n残差为：\n$$\nr(x,t) = [\\theta_4 + \\nu(2\\pi)^2(\\theta_2 + \\theta_4 t)]\\sin(2\\pi x) + [\\theta_5 + \\nu(2\\pi)^2(\\theta_3 + \\theta_5 t)]\\cos(2\\pi x).\n$$\n为简洁起见，我们定义与时间相关的系数：\n$$\nC_s(t) = \\theta_4 + \\nu(2\\pi)^2(\\theta_2 + \\theta_4 t)\n$$\n$$\nC_c(t) = \\theta_5 + \\nu(2\\pi)^2(\\theta_3 + \\theta_5 t)\n$$\n因此，$r(x,t) = C_s(t)\\sin(2\\pi x) + C_c(t)\\cos(2\\pi x)$。损失是在配置点网格 $\\mathcal{G} = \\{0, 0.25, 0.5, 0.75, 1.0\\} \\times \\{0, 0.05, 0.1\\}$ 上 $r(x,t)^2$ 的平均值。网格大小为 $|\\mathcal{G}| = 5 \\times 3 = 15$。\n$$\n\\mathcal{L}_{\\text{pde}}(\\theta; \\nu) = \\frac{1}{15} \\sum_{t \\in \\mathcal{T}_{\\text{pde}}} \\sum_{x \\in \\mathcal{D}} [r(x,t)]^2,\n$$\n其中 $\\mathcal{T}_{\\text{pde}} = \\{0, 0.05, 0.1\\}$。对于固定的时间 $t$，通过计算三角函数项的值，可以简化在 $x \\in \\mathcal{D}$ 上的求和：\n$$\n\\sum_{x \\in \\mathcal{D}} [r(x,t)]^2 = [C_c(t)]^2_{x=0} + [C_s(t)]^2_{x=0.25} + [-C_c(t)]^2_{x=0.5} + [-C_s(t)]^2_{x=0.75} + [C_c(t)]^2_{x=1.0}\n= 3[C_c(t)]^2 + 2[C_s(t)]^2.\n$$\n因此，总的残差平方和为：\n$$\n\\sum_{(x,t) \\in \\mathcal{G}} [r(x,t)]^2 = \\sum_{t \\in \\mathcal{T}_{\\text{pde}}} (3[C_c(t)]^2 + 2[C_s(t)]^2).\n$$\n这提供了一种计算 $\\mathcal{L}_{\\text{pde}}$ 的直接方法。\n\n利用这些显式公式，我们可以通过代入给定的参数值为每个测试用例计算 $\\mathcal{L}_{\\text{total}}$。以下程序实现了这一逻辑。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the total PINN loss for several test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: (theta, nu, w_pde, w_data, w_cons)\n        ((0.3, 0.8, -0.2, 0.1, 0.05), 0.1, 1.0, 1.0, 0.0),\n        # Case 2\n        ((0.3, 0.8, -0.2, 0.1, 0.05), 0.1, 1.0, 1.0, 10.0),\n        # Case 3\n        ((0.7, -0.5, 0.25, 0.0, 0.0), 0.0, 1.0, 1.0, 5.0),\n        # Case 4\n        ((0.5, 0.0, 1.0, 0.0, 0.0), 0.05, 0.5, 2.0, 2.0),\n    ]\n\n    # Define grids and constants\n    X_grid = np.array([0.0, 0.25, 0.5, 0.75, 1.0])\n    T_grid = np.array([0.0, 0.05, 0.1])\n    M0 = 0.5\n    \n    results = []\n\n    for case in test_cases:\n        theta_vec, nu, w_pde, w_data, w_cons = case\n        th1, th2, th3, th4, th5 = theta_vec\n\n        # -- 1. Compute Data Loss (L_data) --\n        # u(x,0) = th1 + th2*sin(2*pi*x) + th3*cos(2*pi*x)\n        # u0(x)  = 0.5 + sin(2*pi*x)\n        # error(x) = (th1-0.5) + (th2-1)*sin(2*pi*x) + th3*cos(2*pi*x)\n        \n        sin_vals = np.sin(2 * np.pi * X_grid)\n        cos_vals = np.cos(2 * np.pi * X_grid)\n        \n        error_data = (th1 - M0) + (th2 - 1.0) * sin_vals + th3 * cos_vals\n        L_data = np.mean(error_data**2)\n        \n        # -- 2. Compute Conservation Loss (L_cons) --\n        # integral u(x,t) dx = th1\n        # L_cons = (th1 - M0)^2\n        L_cons = (th1 - M0)**2\n        \n        # -- 3. Compute PDE Residual Loss (L_pde) --\n        # r(x,t) = u_t - nu * u_xx\n        # u_t = th4*sin(2*pi*x) + th5*cos(2*pi*x)\n        # u_xx = -(2*pi)^2 * [ (th2 + th4*t)*sin(2*pi*x) + (th3 + th5*t)*cos(2*pi*x) ]\n        \n        k = (2 * np.pi)**2\n        \n        sum_sq_res = 0.0\n        for t in T_grid:\n            # Coefficients of sin(2*pi*x) and cos(2*pi*x) in the residual\n            C_s_t = th4 + nu * k * (th2 + th4 * t)\n            C_c_t = th5 + nu * k * (th3 + th5 * t)\n            \n            # r(x,t) = C_s_t * sin(2*pi*x) + C_c_t * cos(2*pi*x)\n            # We calculated the sum over x analytically to simplify:\n            # sum_{x in D} r(x,t)^2 = 2 * C_s_t^2 + 3 * C_c_t^2\n            sum_sq_res_t = 2 * C_s_t**2 + 3 * C_c_t**2\n            sum_sq_res += sum_sq_res_t\n            \n        L_pde = sum_sq_res / (len(X_grid) * len(T_grid))\n\n        # -- 4. Compute Total Loss (L_total) --\n        L_total = w_pde * L_pde + w_data * L_data + w_cons * L_cons\n        results.append(L_total)\n\n    # Format the final output string\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "通过损失函数施加物理约束是一种通用方法，但并非唯一方法。一种更巧妙、更强大的技术是“硬约束”，即通过精心设计网络架构，使其输出天生就满足某些物理属性。本练习将带您实践这一思想，我们将为管流问题构建一个满足轴对称性和无滑移边界条件的模型。通过将物理知识直接嵌入模型结构，我们不仅简化了优化问题，还常常能获得更精确的解。",
            "id": "2411045",
            "problem": "您的任务是设计并实现一个物理信息神经网络 (PINN)，该网络结合已知的轴对称性来降低直圆形管道中稳态、充分发展、不可压缩层流的输入空间维度。除非另有明确定义，否则将所有量视为无量纲。目标是在架构层面利用几何对称性和边界条件，然后通过最小化控制方程残差来确定模型参数。\n\n起点（基本基础）：在轴对称、无旋流、无径向或周向速度以及轴向速度 $u(r)$ 充分发展的假设下，柱坐标系中的稳态、不可压缩 Navier–Stokes 方程可简化为以下标量常微分方程\n$$ \\frac{1}{r}\\frac{d}{dr}\\left(r \\frac{du}{dr}\\right) = S, $$\n其中 $r \\in [0,R]$ 是径向坐标，$R$ 是管道半径，$S = \\frac{1}{\\mu}\\frac{dp}{dx}$ 是一个常数，与轴向压力梯度 $\\frac{dp}{dx}$ 成正比，与动力粘度 $\\mu$ 成反比。符合物理实际的边界和正则性条件是\n$$ u(R) = 0, \\quad \\left|\\frac{du}{dr}(0)\\right|  \\infty. $$\n\n对称性感知架构：通过使用轴对称不变量 $s = r^2$ 来降低有效输入维度，并通过构造将边界和正则性条件嵌入到试探解中：\n$$ u_{\\theta}(r) = \\phi(r)\\, g_{\\theta}(s), \\quad \\phi(r) = 1 - \\left(\\frac{r}{R}\\right)^2, \\quad s = r^2. $$\n这种选择对所有参数值强制施加了 $u_{\\theta}(R)=0$，并得出 $\\frac{du_{\\theta}}{dr}(0)=0$，这与轴对称性和轴心处的光滑性一致。\n\n模型类别：使用仿射模型\n$$ g_{\\theta}(s) = \\theta_0 + \\theta_1 s, $$\n因此\n$$ u_{\\theta}(r) = \\left(1 - \\left(\\frac{r}{R}\\right)^2\\right)\\left(\\theta_0 + \\theta_1 r^2\\right). $$\n\n物理损失：将控制方程的残差定义为\n$$ \\mathcal{R}(r;\\theta) = \\left(\\frac{d^2}{dr^2} + \\frac{1}{r}\\frac{d}{dr}\\right) u_{\\theta}(r) - S, \\quad r \\in (0,R]. $$\n在一组内部配置点 $\\{r_i\\}_{i=1}^N \\subset (0,R]$ 上最小化均方残差：\n$$ \\min_{\\theta \\in \\mathbb{R}^2} \\frac{1}{N} \\sum_{i=1}^N \\left(\\mathcal{R}(r_i;\\theta)\\right)^2. $$\n请注意，该架构消除了对独立边界损失项的需求。\n\n推导要求：仅从所述的微分算子和架构定义出发，推导出模型参数的线性系统，该系统源于在仿射选择 $g_{\\theta}(s)$ 下，残差对 $\\theta$ 是线性的。展示如何计算应用于两个基函数\n$$ u_1(r) = \\phi(r), \\quad u_2(r) = \\phi(r)\\, r^2, $$\n的算子，从而\n$$ \\left(\\frac{d^2}{dr^2} + \\frac{1}{r}\\frac{d}{dr}\\right)u_{\\theta}(r) = \\theta_0\\, \\mathcal{L}[u_1](r) + \\theta_1\\, \\mathcal{L}[u_2](r), $$\n其中 $\\mathcal{L}[\\cdot]$ 表示微分算子。利用此结果构建一个超定线性系统 $A \\theta \\approx b$，其中 $A_{i0} = \\mathcal{L}[u_1](r_i)$，$A_{i1} = \\mathcal{L}[u_2](r_i)$，以及 $b_i = S$，并通过最小二乘法估计 $\\theta$。\n\n评估：对于下面的每个测试用例，在估计 $\\theta$ 之后，在一个足够大的均匀评估网格 $\\{r_j\\}_{j=1}^{M}$ 上，计算学习到的 $u_{\\theta}(r)$ 与精确解之间的最大绝对逐点误差：\n$$ u_{\\text{exact}}(r) = -\\frac{S R^2}{4} \\left(1 - \\left(\\frac{r}{R}\\right)^2\\right), \\quad \\varepsilon_{\\infty} = \\max_{1 \\le j \\le M} \\left| u_{\\theta}(r_j) - u_{\\text{exact}}(r_j) \\right|. $$\n\n角度单位：不适用。物理单位：将所有变量视为无量纲；以无单位十进制数报告误差。\n\n测试套件：使用以下参数集，每个集均指定为 $(R,\\mu,dpdx)$，其中 $S = \\frac{dpdx}{\\mu}$：\n- 用例 1：$(R,\\mu,dpdx) = (1.0, 1.0, -8.0)$。\n- 用例 2：$(R,\\mu,dpdx) = (0.5, 2.0, -5.0)$。\n- 用例 3（边界情况：零强迫项）：$(R,\\mu,dpdx) = (1.0, 1.0, 0.0)$。\n- 用例 4：$(R,\\mu,dpdx) = (1.25, 0.8, -3.333333333333333)$。\n\n您的程序必须：\n- 按照描述构建对称性感知模型并建立最小二乘系统。\n- 使用不包括 $r=0$ 的内部配置点集，以避免中间表达式中出现除以零的情况，但在需要时通过使用闭式表达式来评估包括 $r=0$ 的误差，以避免奇异点。\n- 对每个测试用例，计算如上定义的 $\\varepsilon_{\\infty}$。\n\n最终输出格式：您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，结果采用科学记数法，保留六位有效数字，顺序与测试用例一致，例如，$[a_1,a_2,a_3,a_4]$，其中每个 $a_k$ 是用例 $k$ 的 $\\varepsilon_{\\infty}$ 值。",
            "solution": "此问题已经过验证。\n\n### 步骤 1：提取已知条件\n- **控制方程：** 稳态、不可压缩、轴对称、充分发展的层流管流由以下常微分方程 (ODE) 描述：\n$$ \\frac{1}{r}\\frac{d}{dr}\\left(r \\frac{du}{dr}\\right) = S, \\quad r \\in [0,R] $$\n- **常数和变量：**\n    - $u(r)$：轴向速度剖面。\n    - $r$：径向坐标。\n    - $R$：管道半径。\n    - $S = \\frac{1}{\\mu}\\frac{dp}{dx}$：与轴向压力梯度 $\\frac{dp}{dx}$ 和动力粘度 $\\mu$ 相关的常数。\n- **边界与正则性条件：**\n    - 无滑移条件：$u(R) = 0$。\n    - 中心线处的光滑性：$\\left|\\frac{du}{dr}(0)\\right|  \\infty$。\n- **对称性感知架构：**\n    - 试探解形式：$u_{\\theta}(r) = \\phi(r)\\, g_{\\theta}(s)$。\n    - 输入不变量：$s = r^2$。\n    - 边界条件强制函数：$\\phi(r) = 1 - \\left(\\frac{r}{R}\\right)^2$。\n    - 网络的模型类别：$g_{\\theta}(s) = \\theta_0 + \\theta_1 s$。\n    - 组合试探解：$u_{\\theta}(r) = \\left(1 - \\left(\\frac{r}{R}\\right)^2\\right)\\left(\\theta_0 + \\theta_1 r^2\\right)$，其中 $\\theta = [\\theta_0, \\theta_1]^T$ 是可学习的参数。\n- **物理损失函数公式：**\n    - 微分算子：$\\mathcal{L}[\\cdot] = \\frac{d^2}{dr^2} + \\frac{1}{r}\\frac{d}{dr}$。\n    - 残差：$\\mathcal{R}(r;\\theta) = \\mathcal{L}[u_{\\theta}(r)] - S$。\n    - 目标函数：在 $N$ 个内部配置点 $\\{r_i\\}_{i=1}^N \\subset (0,R]$ 上最小化均方残差：$\\min_{\\theta} \\frac{1}{N} \\sum_{i=1}^N \\left(\\mathcal{R}(r_i;\\theta)\\right)^2$。\n- **推导要求：**\n    - 分解算子的作用：$\\mathcal{L}[u_{\\theta}(r)] = \\theta_0\\, \\mathcal{L}[u_1](r) + \\theta_1\\, \\mathcal{L}[u_2](r)$。\n    - 基函数：$u_1(r) = \\phi(r)$，$u_2(r) = \\phi(r)\\, r^2$。\n    - 形成超定线性系统 $A \\theta \\approx b$，其中 $A_{i0} = \\mathcal{L}[u_1](r_i)$，$A_{i1} = \\mathcal{L}[u_2](r_i)$，$b_i = S$。\n- **评估指标：**\n    - 精确解：$u_{\\text{exact}}(r) = -\\frac{S R^2}{4} \\left(1 - \\left(\\frac{r}{R}\\right)^2\\right)$。\n    - 最大绝对逐点误差：$\\varepsilon_{\\infty} = \\max_{j} \\left| u_{\\theta}(r_j) - u_{\\text{exact}}(r_j) \\right|$，在一个精细网格 $\\{r_j\\}_{j=1}^{M}$ 上计算。\n- **测试套件：**\n    - 用例 1：$(R,\\mu,dpdx) = (1.0, 1.0, -8.0)$。\n    - 用例 2：$(R,\\mu,dpdx) = (0.5, 2.0, -5.0)$。\n    - 用例 3：$(R,\\mu,dpdx) = (1.0, 1.0, 0.0)$。\n    - 用例 4：$(R,\\mu,dpdx) = (1.25, 0.8, -3.333333333333333)$。\n\n### 步骤 2：使用提取的已知条件进行验证\n此问题根据验证标准进行评估。\n- **科学基础扎实：** 此问题基于为 Hagen-Poiseuille 流简化的 Navier-Stokes 方程，这是流体动力学的基石。求解方法，一种加权残差法（特别是最小二乘配置法），是计算科学与工程中的标准且严谨的技术。“PINN”术语被正确地应用于一个通过最小化基于物理的残差来确定模型参数的场景。\n- **适定的：** 此问题提供了一个定义明确的二阶常微分方程，并带有充分的边界条件。所提出的模型架构和损失函数导致了一个线性最小二乘问题，已知该问题有唯一且稳定的解。所有必要的数据和定义都已提供。\n- **客观性：** 此问题以精确、形式化和客观的数学和物理语言陈述。它不含主观或模棱两可的术语。\n- **其他缺陷：** 此问题是自洽、一致且计算上可行的。给定的模型架构足以精确表示已知的解析解，这构成了对该方法的可靠检验。\n\n### 步骤 3：结论与操作\n此问题是 **有效的**。这是一个在科学计算领域中阐述良好的练习，正确地展示了物理信息建模的原理。将提供一个解决方案。\n\n### 求解推导\n任务是通过最小化控制方程的残差来找到参数 $\\theta = [\\theta_0, \\theta_1]^T$。试探解是基函数的线性组合：\n$$ u_{\\theta}(r) = \\theta_0 u_1(r) + \\theta_1 u_2(r) $$\n其中基函数为\n$$ u_1(r) = 1 - \\frac{r^2}{R^2} $$\n$$ u_2(r) = \\left(1 - \\frac{r^2}{R^2}\\right)r^2 = r^2 - \\frac{r^4}{R^2} $$\n微分算子是 $\\mathcal{L}[\\cdot] = \\frac{d^2}{dr^2} + \\frac{1}{r}\\frac{d}{dr}$。我们必须计算它对每个基函数的作用。\n\n对于 $u_1(r)$:\n首先，我们求导数：\n$$ \\frac{du_1}{dr} = -\\frac{2r}{R^2} $$\n$$ \\frac{d^2u_1}{dr^2} = -\\frac{2}{R^2} $$\n现在，我们应用算子 $\\mathcal{L}$：\n$$ \\mathcal{L}[u_1](r) = \\frac{d^2u_1}{dr^2} + \\frac{1}{r}\\frac{du_1}{dr} = \\left(-\\frac{2}{R^2}\\right) + \\frac{1}{r}\\left(-\\frac{2r}{R^2}\\right) = -\\frac{2}{R^2} - \\frac{2}{R^2} = -\\frac{4}{R^2} $$\n\n对于 $u_2(r)$:\n首先，我们求导数：\n$$ \\frac{du_2}{dr} = 2r - \\frac{4r^3}{R^2} $$\n$$ \\frac{d^2u_2}{dr^2} = 2 - \\frac{12r^2}{R^2} $$\n现在，我们应用算子 $\\mathcal{L}$：\n$$ \\mathcal{L}[u_2](r) = \\frac{d^2u_2}{dr^2} + \\frac{1}{r}\\frac{du_2}{dr} = \\left(2 - \\frac{12r^2}{R^2}\\right) + \\frac{1}{r}\\left(2r - \\frac{4r^3}{R^2}\\right) $$\n$$ \\mathcal{L}[u_2](r) = 2 - \\frac{12r^2}{R^2} + 2 - \\frac{4r^2}{R^2} = 4 - \\frac{16r^2}{R^2} $$\n\n控制方程的残差由 $\\mathcal{R}(r;\\theta) = \\mathcal{L}[u_{\\theta}(r)] - S$ 给出。利用算子 $\\mathcal{L}$ 的线性性：\n$$ \\mathcal{R}(r;\\theta) = \\theta_0 \\mathcal{L}[u_1](r) + \\theta_1 \\mathcal{L}[u_2](r) - S $$\n代入推导出的表达式：\n$$ \\mathcal{R}(r;\\theta) = \\theta_0 \\left(-\\frac{4}{R^2}\\right) + \\theta_1 \\left(4 - \\frac{16r^2}{R^2}\\right) - S $$\n为了在一组 $N$ 个配置点 $\\{r_i\\}_{i=1}^N$ 上最小化残差的平方和，我们以最小二乘意义求解线性系统 $A\\theta \\approx b$。对于对应于点 $r_i$ 的每一行 $i$，系统是：\n$$ \\begin{pmatrix} \\mathcal{L}[u_1](r_i)  \\mathcal{L}[u_2](r_i) \\end{pmatrix} \\begin{pmatrix} \\theta_0 \\\\ \\theta_1 \\end{pmatrix} = S $$\n因此，矩阵 $A$ 和向量 $b$ 的构造如下：\n$$ A = \\begin{pmatrix} -4/R^2  4 - 16r_1^2/R^2 \\\\ -4/R^2  4 - 16r_2^2/R^2 \\\\ \\vdots  \\vdots \\\\ -4/R^2  4 - 16r_N^2/R^2 \\end{pmatrix}, \\quad b = \\begin{pmatrix} S \\\\ S \\\\ \\vdots \\\\ S \\end{pmatrix} $$\n最优参数 $\\theta$ 通过求解正规方程 $(A^TA)\\theta = A^Tb$ 来找到。\n\n一个关键的观察是，解析解 $u_{\\text{exact}}(r)$ 可以写成：\n$$ u_{\\text{exact}}(r) = \\left(-\\frac{SR^2}{4}\\right)\\left(1 - \\frac{r^2}{R^2}\\right) $$\n这与特定参数选择 $\\theta_0 = -SR^2/4$ 和 $\\theta_1 = 0$ 时的试探解 $u_{\\theta}(r)$ 形式相匹配。对于此选择，残差对所有 $r$ 恒为零：\n$$ \\mathcal{R}(r; \\theta_{exact}) = \\left(-\\frac{SR^2}{4}\\right)\\left(-\\frac{4}{R^2}\\right) + (0)\\left(4 - \\frac{16r^2}{R^2}\\right) - S = S - S = 0 $$\n因为模型类别包含了精确解，所以残差的最小二乘最小化必须找到这些精确参数，从而得到一个与 $u_{\\text{exact}}(r)$ 完全相同的解 $u_{\\theta}(r)$。因此，最大绝对误差 $\\varepsilon_{\\infty}$ 预期为零，直到浮点精度的限制。实现将验证这一点。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are permitted.\n\ndef solve():\n    \"\"\"\n    Designs and implements a physics-informed model for laminar pipe flow,\n    solves for its parameters using a linear least-squares formulation on the\n    governing equation's residual, and evaluates the error against the\n    analytical solution for several test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each case is a tuple (R, mu, dpdx).\n    test_cases = [\n        (1.0, 1.0, -8.0),\n        (0.5, 2.0, -5.0),\n        (1.0, 1.0, 0.0),\n        (1.25, 0.8, -3.333333333333333),\n    ]\n\n    # Parameters for the numerical method\n    N_collocation = 100  # Number of interior collocation points\n    M_evaluation = 1001 # Number of points for error evaluation grid\n\n    results = []\n\n    for case in test_cases:\n        R, mu, dpdx = case\n        S = dpdx / mu\n\n        # 1. Set up the least-squares problem to find theta = [theta_0, theta_1]\n        \n        # Create a set of N interior collocation points in (0, R].\n        # Avoiding r=0 as per problem, although derived expressions are safe.\n        r_colloc = np.linspace(R / N_collocation, R, N_collocation)\n\n        # Construct the matrix A for the linear system A*theta = b.\n        # A has shape (N_collocation, 2).\n        A = np.zeros((N_collocation, 2))\n\n        # Column 0 corresponds to the operator applied to the first basis function u_1.\n        # L[u_1](r) = -4 / R^2, a constant.\n        A[:, 0] = -4.0 / (R**2)\n\n        # Column 1 corresponds to the operator applied to the second basis function u_2.\n        # L[u_2](r) = 4 - 16 * r^2 / R^2.\n        A[:, 1] = 4.0 - 16.0 * (r_colloc**2) / (R**2)\n\n        # Construct the vector b.\n        # b_i = S for all i.\n        b = np.full(N_collocation, S)\n        \n        # 2. Solve for the model parameters theta using linear least squares.\n        # This minimizes the L2 norm of the residual ||A*theta - b||^2.\n        theta, _, _, _ = np.linalg.lstsq(A, b, rcond=None)\n        theta_0, theta_1 = theta[0], theta[1]\n\n        # 3. Evaluate the error between the learned and exact solutions.\n        \n        # Create a fine grid of M evaluation points over [0, R].\n        r_eval = np.linspace(0.0, R, M_evaluation)\n\n        # Calculate the learned solution u_theta(r) on the evaluation grid.\n        # u_theta(r) = (1 - (r/R)^2) * (theta_0 + theta_1 * r^2)\n        phi_r = 1.0 - (r_eval / R)**2\n        g_theta_s = theta_0 + theta_1 * (r_eval**2)\n        u_theta = phi_r * g_theta_s\n\n        # Calculate the exact analytical solution u_exact(r) on the evaluation grid.\n        # u_exact(r) = -S * R^2 / 4 * (1 - (r/R)^2)\n        if S == 0.0:\n            u_exact = np.zeros_like(r_eval)\n        else:\n            u_exact = (-S * R**2 / 4.0) * (1.0 - (r_eval / R)**2)\n\n        # Compute the maximum absolute pointwise error.\n        epsilon_inf = np.max(np.abs(u_theta - u_exact))\n        results.append(epsilon_inf)\n\n    # Final print statement in the exact required format.\n    # Format: [a_1,a_2,...] with each value in scientific notation with 6 significant digits.\n    # The format specifier \".5e\" gives 1 digit before decimal and 5 after, a total of 6.\n    formatted_results = [f\"{res:.5e}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了通过损失函数施加“软约束”和通过架构施加“硬约束”这两种方法后，是时候对它们进行一次实战对比了。本练习聚焦于流体力学中至关重要的不可压缩条件（即无散度约束）。您将实现并比较两种截然不同的策略来求解斯托克斯流问题：一种是使用流函数公式从结构上保证无散度（硬约束），另一种则是在损失函数中加入散度惩罚项（软约束）。通过这次直接比较，您将对这两种方法的优劣和适用场景获得深刻的实践性认识。",
            "id": "2411040",
            "problem": "您将实现并比较两种物理信息神经网络（PINN）公式，用于求解蠕动流极限（斯托克斯方程）下的稳态二维不可压缩纳维-斯托克斯方程，并特别关注无散度约束的强制施加。您的实现必须是一个完整、可运行的程序。\n\n控制方程是在单位正方形域上的稳态斯托克斯系统，其无量纲形式写作\n$$\n-\\nabla p + \\nu \\nabla^2 \\mathbf{u} + \\mathbf{f} = \\mathbf{0}, \\quad \\nabla \\cdot \\mathbf{u} = 0,\n$$\n其中 $\\mathbf{u} = (u,v)$ 是速度， $p$ 是压力， $\\nu$ 是运动粘度（一个正常数），而 $\\mathbf{f}$ 是一个给定的体力。\n\n为提供一个科学上可靠且可测试的设置，请使用制造解方法。将精确的流函数、速度和压力定义为\n$$\n\\psi(x,y) = \\sin(\\pi x)\\sin(\\pi y), \\\\\nu^\\star(x,y) = \\frac{\\partial \\psi}{\\partial y} = \\pi \\sin(\\pi x)\\cos(\\pi y), \\\\\nv^\\star(x,y) = -\\frac{\\partial \\psi}{\\partial x} = -\\pi \\cos(\\pi x)\\sin(\\pi y), \\\\\np^\\star(x,y) = \\cos(\\pi x)\\cos(\\pi y),\n$$\n对于 $(x,y) \\in [0,1]^2$。设运动粘度为 $\\nu = 0.01$ （一个正实数）。通过将 $(u^\\star,v^\\star,p^\\star)$ 代入斯托克斯动量平衡方程来定义体力：\n$$\n\\mathbf{f} = \\nabla p^\\star - \\nu \\nabla^2 \\mathbf{u}^\\star,\n$$\n从而使得 $(\\mathbf{u}^\\star,p^\\star)$ 在此体力 $\\mathbf{f}$ 下精确满足稳态斯托克斯方程。\n\n您将构建两种 PINN 变体，它们通过稀疏数据锚定，在一组配置点上最小化残差平方和。两种方法都使用一个小的、固定的特征基（可解释为具有三角函数激活的单隐藏层网络），以使问题在计算上易于处理，并且对于输入是可解析微分的。\n\n- 方法 A（软散度惩罚）：将 $u$、$v$ 和 $p$ 作为三角特征的线性组合独立进行参数化，\n$$\nu(x,y) = \\sum_{k=1}^{4} a_k \\,\\phi_k(x,y), \\quad v(x,y) = \\sum_{k=1}^{4} b_k \\,\\psi_k(x,y), \\quad p(x,y) = \\sum_{k=1}^{4} c_k \\,\\chi_k(x,y),\n$$\n其基函数与模态对 $(m,n)\\in\\{(1,1),(2,1),(1,2),(2,2)\\}$ 相关联：\n$$\n\\phi_{(m,n)}(x,y) = \\sin(m\\pi x)\\cos(n\\pi y), \\\\\n\\psi_{(m,n)}(x,y) = -\\cos(m\\pi x)\\sin(n\\pi y), \\\\\n\\chi_{(m,n)}(x,y) = \\cos(m\\pi x)\\cos(n\\pi y).\n$$\n最小化加权残差平方和，该和由内部配置点 $(x_i,y_i)$ 处的斯托克斯动量残差、一组锚点 $(\\tilde{x}_j,\\tilde{y}_j)$ 处与 $(u^\\star,v^\\star)$ 的稀疏速度数据失配、一个在 $(\\hat{x},\\hat{y})$ 处的标量压力锚点以及一个权重为 $\\lambda \\ge 0$ 的散度惩罚项组成：\n$$\n\\mathcal{L}_\\text{soft} = \\frac{1}{N_\\Omega}\\sum_{i=1}^{N_\\Omega} \\left( r_u(x_i,y_i)^2 + r_v(x_i,y_i)^2 \\right) + \\alpha \\frac{1}{N_D}\\sum_{j=1}^{N_D} \\left[ \\left(u(\\tilde{x}_j,\\tilde{y}_j)-u^\\star(\\tilde{x}_j,\\tilde{y}_j)\\right)^2 + \\left(v(\\tilde{x}_j,\\tilde{y}_j)-v^\\star(\\tilde{x}_j,\\tilde{y}_j)\\right)^2 \\right] \\\\\n+ \\alpha_p \\left(p(\\hat{x},\\hat{y})-p^\\star(\\hat{x},\\hat{y})\\right)^2 + \\lambda \\frac{1}{N_\\Omega}\\sum_{i=1}^{N_\\Omega} \\left(\\frac{\\partial u}{\\partial x}(x_i,y_i) + \\frac{\\partial v}{\\partial y}(x_i,y_i)\\right)^2,\n$$\n其中\n$$\nr_u = -\\frac{\\partial p}{\\partial x} + \\nu \\nabla^2 u + f_x, \\quad r_v = -\\frac{\\partial p}{\\partial y} + \\nu \\nabla^2 v + f_y.\n$$\n三角基的所有空间导数都是解析的，且必须使用。权重 $\\alpha$ 和 $\\alpha_p$ 是正实数。使用 $\\alpha = 10$ 和 $\\alpha_p = 10$。选择 $N_\\Omega = 64$ 个内部点，定义在 $(0,1)^2$ 上的一个 $8\\times 8$ 均匀网格上，并选择 $N_D = 10$ 个锚点，使用固定的伪随机种子在 $(0,1)^2$ 内均匀采样。\n\n- 方法 B（通过流函数实现的硬散度约束）：通过使用流函数展开来构造性地强制 $\\nabla \\cdot \\mathbf{u} = 0$，\n$$\n\\psi(x,y) = \\sum_{k=1}^{4} s_k \\,\\sigma_k(x,y), \\quad \\sigma_{(m,n)}(x,y) = \\sin(m\\pi x)\\sin(n\\pi y),\n$$\n并定义\n$$\nu(x,y) = \\frac{\\partial \\psi}{\\partial y}(x,y), \\quad v(x,y) = -\\frac{\\partial \\psi}{\\partial x}(x,y), \\quad p(x,y) = \\sum_{k=1}^{4} c_k \\,\\chi_k(x,y),\n$$\n使用相同的压力基 $\\chi_k$。最小化\n$$\n\\mathcal{L}_\\text{hard} = \\frac{1}{N_\\Omega}\\sum_{i=1}^{N_\\Omega} \\left( r_u(x_i,y_i)^2 + r_v(x_i,y_i)^2 \\right) + \\alpha \\frac{1}{N_D}\\sum_{j=1}^{N_D} \\left[ \\left(u(\\tilde{x}_j,\\tilde{y}_j)-u^\\star(\\tilde{x}_j,\\tilde{y}_j)\\right)^2 + \\left(v(\\tilde{x}_j,\\tilde{y}_j)-v^\\star(\\tilde{x}_j,\\tilde{y}_j)\\right)^2 \\right] \\\\\n+ \\alpha_p \\left(p(\\hat{x},\\hat{y})-p^\\star(\\hat{x},\\hat{y})\\right)^2,\n$$\n其中 $r_u$ 和 $r_v$ 的定义如上，且基的所有导数都是解析的。\n\n因为斯托克斯方程在 $(u,v,p)$ 上是线性的，并且上述参数化在系数上是线性的，所以残差在系数上也是线性的。因此，上述每个优化问题都简化为一个标准线性最小二乘问题，形式如下\n$$\n\\min_{\\boldsymbol{\\theta}} \\left\\| \\mathbf{W}(\\mathbf{A}\\boldsymbol{\\theta} - \\mathbf{b}) \\right\\|_2^2,\n$$\n其中 $\\boldsymbol{\\theta}$ 汇集了所有系数。您必须根据基函数的解析导数显式地构建设计矩阵 $\\mathbf{A}$ 和右端项 $\\mathbf{b}$，并使用一个稳健的线性最小二乘方法求解。\n\n测试套件规范：\n\n- 使用上述设置，其中 $\\nu = 0.01$ （无量纲）。使用所定义的精确解 $(u^\\star,v^\\star,p^\\star)$ 和体力 $\\mathbf{f}$。\n\n- 对于方法 A（软散度），运行三个案例，其散度惩罚权重为\n$$\n\\lambda \\in \\{0.0, 1.0, 100.0\\}.\n$$\n\n- 对于方法 B（硬散度），求解一次（不需要参数 $\\lambda$）。\n\n为了进行评估，在 $(0,1)^2$ 上定义一个 $20\\times 20$ 的均匀间隔点验证网格。对于每个案例，计算：\n\n- 散度范数\n$$\n\\mathcal{N}_\\text{div} = \\sqrt{ \\frac{1}{N_V} \\sum_{q=1}^{N_V} \\left( \\frac{\\partial u}{\\partial x}(x_q,y_q) + \\frac{\\partial v}{\\partial y}(x_q,y_q) \\right)^2 },\n$$\n其中 $N_V = 400$ 是验证点的数量。\n\n- 动量残差范数\n$$\n\\mathcal{N}_\\text{mom} = \\sqrt{ \\frac{1}{N_V} \\sum_{q=1}^{N_V} \\left[ r_u(x_q,y_q)^2 + r_v(x_q,y_q)^2 \\right] }.\n$$\n\n- 相对速度误差\n$$\n\\mathcal{E}_\\mathbf{u} = \\frac{ \\sqrt{ \\frac{1}{N_V} \\sum_{q=1}^{N_V} \\left[ \\left(u(x_q,y_q)-u^\\star(x_q,y_q)\\right)^2 + \\left(v(x_q,y_q)-v^\\star(x_q,y_q)\\right)^2 \\right] } }{ \\sqrt{ \\frac{1}{N_V} \\sum_{q=1}^{N_V} \\left[ \\left(u^\\star(x_q,y_q)\\right)^2 + \\left(v^\\star(x_q,y_q)\\right)^2 \\right] } }.\n$$\n\n最终输出格式：\n\n- 您的程序必须产生单行输出，其中包含一个包含十二个浮点数的列表，四舍五入到六位小数，顺序如下：\n$$\n\\left[ \\mathcal{N}_\\text{div}^{(\\lambda=0)}, \\mathcal{N}_\\text{mom}^{(\\lambda=0)}, \\mathcal{E}_\\mathbf{u}^{(\\lambda=0)}, \\mathcal{N}_\\text{div}^{(\\lambda=1)}, \\mathcal{N}_\\text{mom}^{(\\lambda=1)}, \\mathcal{E}_\\mathbf{u}^{(\\lambda=1)}, \\mathcal{N}_\\text{div}^{(\\lambda=100)}, \\mathcal{N}_\\text{mom}^{(\\lambda=100)}, \\mathcal{E}_\\mathbf{u}^{(\\lambda=100)}, \\mathcal{N}_\\text{div}^\\text{(hard)}, \\mathcal{N}_\\text{mom}^\\text{(hard)}, \\mathcal{E}_\\mathbf{u}^\\text{(hard)} \\right].\n$$\n- 数字必须按照此确切顺序和格式生成，包括外围的方括号和逗号分隔符。\n\n角度单位不适用。不需要物理单位；所有量都是无量纲实数。所有随机抽样必须使用固定的种子，以确保输出是确定性的。您的代码必须是自包含的，并且不需要用户交互。",
            "solution": "所提出的问题是计算科学领域一个明确定义的练习，具体涉及应用于计算流体动力学的物理信息神经网络（PINN）。它要求实现并比较两种在单位正方形上求解稳态斯托克斯方程的方法，并使用制造解方法进行验证。\n\n**问题验证**\n\n该问题被验证为具有科学依据、适定且客观。它基于流体力学中的基本斯托克斯方程。使用制造解是一种标准的验证技术。通过有限的类傅里叶基进行参数化（可解释为具有固定三角激活函数的简单神经网络）是展示 PINN 概念的有效方法。问题简化为求解一个线性最小二乘系统，这是一个适定的数学问题。所有常数、方程和评估指标都已足够精确地指定。关于单个压力锚点位置的微小模糊性通过选择一个固定的代表性点，如域中心 $(0.5, 0.5)$ 来解决，这是一种标准做法，不会影响问题的完整性。因此，该问题被认为是有效的，可以制定出严谨的解决方案。\n\n**基于原理的解决方案设计**\n\n问题的核心是通过将未知场表示为具有未知系数的预定基函数的线性组合，来找到斯托克斯方程的近似解 $(\\mathbf{u}, p)$：\n$$\n-\\nabla p + \\nu \\nabla^2 \\mathbf{u} + \\mathbf{f} = \\mathbf{0} \\\\\n\\nabla \\cdot \\mathbf{u} = 0\n$$\n这些系数通过最小化一个由控制方程的残差和数据失配项组成的损失函数来确定。这个过程等同于求解一个线性最小二乘问题。\n\n**1. 制造解与强迫项**\n\n为了提供评估方法准确性的基准，定义了一个制造解：\n$$\n\\psi(x,y) = \\sin(\\pi x)\\sin(\\pi y) \\\\\nu^\\star(x,y) = \\pi \\sin(\\pi x)\\cos(\\pi y) \\\\\nv^\\star(x,y) = -\\pi \\cos(\\pi x)\\sin(\\pi y) \\\\\np^\\star(x,y) = \\cos(\\pi x)\\cos(\\pi y)\n$$\n如果体力 $\\mathbf{f} = (f_x, f_y)$ 定义为：\n$$\n\\mathbf{f} = \\nabla p^\\star - \\nu \\nabla^2 \\mathbf{u}^\\star\n$$\n这些场便能精确满足斯托克斯方程。通过解析计算必要的导数，我们得到强迫函数：\n$$\nf_x(x,y) = \\frac{\\partial p^\\star}{\\partial x} - \\nu \\left( \\frac{\\partial^2 u^\\star}{\\partial x^2} + \\frac{\\partial^2 u^\\star}{\\partial y^2} \\right) = (-\\pi + 2\\nu\\pi^3) \\sin(\\pi x)\\cos(\\pi y) \\\\\nf_y(x,y) = \\frac{\\partial p^\\star}{\\partial y} - \\nu \\left( \\frac{\\partial^2 v^\\star}{\\partial x^2} + \\frac{\\partial^2 v^\\star}{\\partial y^2} \\right) = (-\\pi - 2\\nu\\pi^3) \\cos(\\pi x)\\sin(\\pi y)\n$$\n其中粘度 $\\nu = 0.01$。\n\n**2. 点离散化**\n\n连续问题使用三组点进行离散化：\n- **配置点 ($N_\\Omega = 64$)**：在 $(0,1)^2$ 内部的一个 $8 \\times 8$ 均匀网格，用于强制物理残差。\n- **数据锚点 ($N_D = 10$)**：从 $(0,1)^2$ 上的均匀随机分布中采样的点（使用固定种子以保证可复现性），在这些点上，速度解被约束以匹配制造解 $u^\\star$ 和 $v^\\star$。\n- **压力锚点**：一个单点，选择为 $(\\hat{x}, \\hat{y}) = (0.5, 0.5)$，以固定压力水平，否则压力仅能确定至一个附加常数。\n\n**3. 线性最小二乘公式**\n\n方法 A 和方法 B 都旨在找到一个系数向量 $\\boldsymbol{\\theta}$，以最小化加权误差平方和。这可以表示为一个标准的线性最小二乘问题：\n$$\n\\min_{\\boldsymbol{\\theta}} \\| \\mathbf{A}\\boldsymbol{\\theta} - \\mathbf{b} \\|_2^2\n$$\n此处，$\\mathbf{A}$ 是设计矩阵，其条目是基函数或其导数在离散点上的评价值；$\\mathbf{b}$ 是右端向量，包含来自强迫项或制造解的值。来自损失函数的权重，如 $\\alpha$、$\\alpha_p$ 和 $\\lambda$，通过将 $\\mathbf{A}$ 和 $\\mathbf{b}$ 的相应行乘以所述权重的平方根来并入。该系统是超定的，并使用像 `scipy.linalg.lstsq` 这样的稳健方法来求解。\n\n**方法 A：软散度约束**\n\n速度分量 $(u,v)$ 和压力 $p$ 被独立参数化：\n$$\nu(x,y) = \\sum_{k=1}^{4} a_k \\phi_k(x,y), \\quad v(x,y) = \\sum_{k=1}^{4} b_k \\psi_k(x,y), \\quad p(x,y) = \\sum_{k=1}^{4} c_k \\chi_k(x,y)\n$$\n系数向量为 $\\boldsymbol{\\theta}_A = [a_1, ..., a_4, b_1, ..., b_4, c_1, ..., c_4]^T$，大小为 12。线性系统由以下方程构建：\n- **动量残差（$2N_\\Omega$ 个方程）**：在每个配置点 $(x_i, y_i)$，\n$$\n\\nu \\sum_{k=1}^{4} a_k \\nabla^2\\phi_k(x_i,y_i) - \\sum_{k=1}^{4} c_k \\frac{\\partial\\chi_k}{\\partial x}(x_i,y_i) = -f_x(x_i,y_i) \\\\\n\\nu \\sum_{k=1}^{4} b_k \\nabla^2\\psi_k(x_i,y_i) - \\sum_{k=1}^{4} c_k \\frac{\\partial\\chi_k}{\\partial y}(x_i,y_i) = -f_y(x_i,y_i)\n$$\n这些行由 $\\sqrt{1/N_\\Omega}$ 加权。\n- **速度数据约束（$2N_D$ 个方程）**：在每个锚点 $(\\tilde{x}_j, \\tilde{y}_j)$，\n$$\n\\sum_{k=1}^{4} a_k \\phi_k(\\tilde{x}_j,\\tilde{y}_j) = u^\\star(\\tilde{x}_j,\\tilde{y}_j) \\\\\n\\sum_{k=1}^{4} b_k \\psi_k(\\tilde{x}_j,\\tilde{y}_j) = v^\\star(\\tilde{x}_j,\\tilde{y}_j)\n$$\n这些行由 $\\sqrt{\\alpha/N_D}$ 加权。\n- **压力锚点约束（1 个方程）**：在 $(\\hat{x}, \\hat{y})$，\n$$\n\\sum_{k=1}^{4} c_k \\chi_k(\\hat{x},\\hat{y}) = p^\\star(\\hat{x},\\hat{y})\n$$\n该行由 $\\sqrt{\\alpha_p}$ 加权。\n- **散度惩罚项（$N_\\Omega$ 个方程）**：在每个配置点 $(x_i, y_i)$，\n$$\n\\sum_{k=1}^{4} a_k \\frac{\\partial\\phi_k}{\\partial x}(x_i,y_i) + \\sum_{k=1}^{4} b_k \\frac{\\partial\\psi_k}{\\partial y}(x_i,y_i) = 0\n$$\n这些行由 $\\sqrt{\\lambda/N_\\Omega}$ 加权。对 $\\lambda \\in \\{0.0, 1.0, 100.0\\}$ 重复此过程。\n\n**方法 B：硬散度约束**\n\n不可压缩约束 $\\nabla \\cdot \\mathbf{u} = 0$ 通过使用流函数公式得到精确满足（通过构造）：\n$$\n\\psi(x,y) = \\sum_{k=1}^{4} s_k \\sigma_k(x,y) \\implies u = \\frac{\\partial \\psi}{\\partial y}, v = -\\frac{\\partial \\psi}{\\partial x}\n$$\n压力参数化方式同前。系数向量为 $\\boldsymbol{\\theta}_B = [s_1, ..., s_4, c_1, ..., c_4]^T$，大小为 8。线性系统由以下部分构建：\n- **动量残差（$2N_\\Omega$ 个方程）**：在每个配置点 $(x_i, y_i)$，\n$$\n\\nu \\sum_{k=1}^{4} s_k \\frac{\\partial(\\nabla^2\\sigma_k)}{\\partial y}(x_i,y_i) - \\sum_{k=1}^{4} c_k \\frac{\\partial\\chi_k}{\\partial x}(x_i,y_i) = -f_x(x_i,y_i) \\\\\n\\nu \\sum_{k=1}^{4} s_k \\left(-\\frac{\\partial(\\nabla^2\\sigma_k)}{\\partial x}\\right)(x_i,y_i) - \\sum_{k=1}^{4} c_k \\frac{\\partial\\chi_k}{\\partial y}(x_i,y_i) = -f_y(x_i,y_i)\n$$\n这些行由 $\\sqrt{1/N_\\Omega}$ 加权。\n- **速度数据约束（$2N_D$ 个方程）**：在每个锚点 $(\\tilde{x}_j, \\tilde{y}_j)$，\n$$\n\\sum_{k=1}^{4} s_k \\frac{\\partial\\sigma_k}{\\partial y}(\\tilde{x}_j,\\tilde{y}_j) = u^\\star(\\tilde{x}_j,\\tilde{y}_j) \\\\\n\\sum_{k=1}^{4} s_k \\left(-\\frac{\\partial\\sigma_k}{\\partial x}\\right)(\\tilde{x}_j,\\tilde{y}_j) = v^\\star(\\tilde{x}_j,\\tilde{y}_j)\n$$\n这些行由 $\\sqrt{\\alpha/N_D}$ 加权。\n- **压力锚点约束（1 个方程）**：与方法 A 相同，由 $\\sqrt{\\alpha_p}$ 加权。\n没有散度惩罚方程，因为该约束在结构上已得到满足。\n\n**4. 评估**\n\n在每种情况下求解系数 $\\boldsymbol{\\theta}$ 后，得到的近似解 $(u,v,p)$ 在一个精细的 $20 \\times 20$ 验证网格上进行评估。计算三个指标：速度散度的均方根范数 $\\mathcal{N}_\\text{div}$，动量残差的均方根范数 $\\mathcal{N}_\\text{mom}$，以及速度场的相对 $L_2$ 误差 $\\mathcal{E}_\\mathbf{u}$。对于方法 B，$\\mathcal{N}_\\text{div}$ 预期在机器精度范围内为零，这为实现提供了验证。然后，将所有四种情况（方法 A 的三个 $\\lambda$ 值，以及方法 B）的结果汇总并按指定格式输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import lstsq\n\ndef solve():\n    # --- Problem Parameters ---\n    NU = 0.01\n    ALPHA = 10.0\n    ALPHA_P = 10.0\n    N_OMEGA_SIDE = 8\n    N_OMEGA = N_OMEGA_SIDE * N_OMEGA_SIDE\n    N_D = 10\n    N_VALID_SIDE = 20\n    N_V = N_VALID_SIDE * N_VALID_SIDE\n    SEED = 42\n    MODES = [(1, 1), (2, 1), (1, 2), (2, 2)]\n    LAMBDA_VALS = [0.0, 1.0, 100.0]\n\n    # --- Grids ---\n    # Collocation points\n    x_omega_1d = np.linspace(0, 1, N_OMEGA_SIDE + 2)[1:-1]\n    y_omega_1d = np.linspace(0, 1, N_OMEGA_SIDE + 2)[1:-1]\n    x_omega_grid, y_omega_grid = np.meshgrid(x_omega_1d, y_omega_1d)\n    collocation_pts = np.vstack([x_omega_grid.ravel(), y_omega_grid.ravel()]).T\n\n    # Data anchor points\n    rng = np.random.default_rng(SEED)\n    data_pts = rng.uniform(0, 1, size=(N_D, 2))\n\n    # Pressure anchor point\n    pressure_pt = np.array([[0.5, 0.5]])\n\n    # Validation points\n    x_val_1d = np.linspace(0, 1, N_VALID_SIDE + 2)[1:-1]\n    y_val_1d = np.linspace(0, 1, N_VALID_SIDE + 2)[1:-1]\n    x_val_grid, y_val_grid = np.meshgrid(x_val_1d, y_val_1d)\n    validation_pts = np.vstack([x_val_grid.ravel(), y_val_grid.ravel()]).T\n\n    # --- Manufactured Solution and Forcing Term ---\n    def u_star(x, y):\n        return np.pi * np.sin(np.pi * x) * np.cos(np.pi * y)\n\n    def v_star(x, y):\n        return -np.pi * np.cos(np.pi * x) * np.sin(np.pi * y)\n\n    def p_star(x, y):\n        return np.cos(np.pi * x) * np.cos(np.pi * y)\n\n    def f_x(x, y):\n        return (-np.pi + 2 * NU * np.pi**3) * np.sin(np.pi * x) * np.cos(np.pi * y)\n\n    def f_y(x, y):\n        return (-np.pi - 2 * NU * np.pi**3) * np.cos(np.pi * x) * np.sin(np.pi * y)\n\n    # --- Basis Functions and Derivatives ---\n    pi = np.pi\n\n    # Method A basis\n    def phi(x, y, m, n): return np.sin(m*pi*x) * np.cos(n*pi*y)\n    def dphi_dx(x, y, m, n): return m*pi * np.cos(m*pi*x) * np.cos(n*pi*y)\n    def lapl_phi(x, y, m, n): return -(m*pi)**2 * phi(x,y,m,n) - (n*pi)**2 * phi(x,y,m,n)\n\n    def psi(x, y, m, n): return -np.cos(m*pi*x) * np.sin(n*pi*y)\n    def dpsi_dy(x, y, m, n): return -n*pi * np.cos(m*pi*x) * np.cos(n*pi*y)\n    def lapl_psi(x, y, m, n): return -(m*pi)**2 * psi(x,y,m,n) - (n*pi)**2 * psi(x,y,m,n)\n\n    # Method B basis (streamfunction)\n    def sigma(x, y, m, n): return np.sin(m*pi*x) * np.sin(n*pi*y)\n    def dsigma_dx(x, y, m, n): return m*pi * np.cos(m*pi*x) * np.sin(n*pi*y)\n    def dsigma_dy(x, y, m, n): return n*pi * np.sin(m*pi*x) * np.cos(n*pi*y)\n    def lapl_dsigma_dx(x, y, m, n): return -(n*pi)**2 * dsigma_dx(x,y,m,n) - (m*pi)**2 * dsigma_dx(x,y,m,n)\n    def lapl_dsigma_dy(x, y, m, n): return -(m*pi)**2 * dsigma_dy(x,y,m,n) - (n*pi)**2 * dsigma_dy(x,y,m,n)\n\n    # Common pressure basis\n    def chi(x, y, m, n): return np.cos(m*pi*x) * np.cos(n*pi*y)\n    def dchi_dx(x, y, m, n): return -m*pi * np.sin(m*pi*x) * np.cos(n*pi*y)\n    def dchi_dy(x, y, m, n): return -n*pi * np.cos(m*pi*x) * np.sin(n*pi*y)\n\n    # --- Solver for Method A ---\n    def solve_method_A(lambda_val):\n        num_coeffs = 12\n        num_rows = 2 * N_OMEGA + 2 * N_D + 1 + N_OMEGA\n        A = np.zeros((num_rows, num_coeffs))\n        b = np.zeros(num_rows)\n        \n        x_c, y_c = collocation_pts[:, 0], collocation_pts[:, 1]\n        x_d, y_d = data_pts[:, 0], data_pts[:, 1]\n        x_p, y_p = pressure_pt[0, 0], pressure_pt[0, 1]\n\n        w_mom = np.sqrt(1 / N_OMEGA)\n        w_data = np.sqrt(ALPHA / N_D)\n        w_p = np.sqrt(ALPHA_P)\n        w_div = np.sqrt(lambda_val / N_OMEGA)\n\n        row = 0\n        # Momentum residual (u)\n        for i in range(N_OMEGA):\n            for k, (m, n) in enumerate(MODES):\n                A[row, k] = w_mom * NU * lapl_phi(x_c[i], y_c[i], m, n)\n                A[row, k + 8] = w_mom * -dchi_dx(x_c[i], y_c[i], m, n)\n            b[row] = w_mom * -f_x(x_c[i], y_c[i])\n            row += 1\n        # Momentum residual (v)\n        for i in range(N_OMEGA):\n            for k, (m, n) in enumerate(MODES):\n                A[row, k + 4] = w_mom * NU * lapl_psi(x_c[i], y_c[i], m, n)\n                A[row, k + 8] = w_mom * -dchi_dy(x_c[i], y_c[i], m, n)\n            b[row] = w_mom * -f_y(x_c[i], y_c[i])\n            row += 1\n        # Velocity data\n        for i in range(N_D):\n            for k, (m, n) in enumerate(MODES):\n                A[row, k] = w_data * phi(x_d[i], y_d[i], m, n)\n            b[row] = w_data * u_star(x_d[i], y_d[i])\n            row += 1\n            for k, (m, n) in enumerate(MODES):\n                A[row, k + 4] = w_data * psi(x_d[i], y_d[i], m, n)\n            b[row] = w_data * v_star(x_d[i], y_d[i])\n            row += 1\n        # Pressure anchor\n        for k, (m, n) in enumerate(MODES):\n            A[row, k + 8] = w_p * chi(x_p, y_p, m, n)\n        b[row] = w_p * p_star(x_p, y_p)\n        row += 1\n        # Divergence penalty\n        for i in range(N_OMEGA):\n            for k, (m, n) in enumerate(MODES):\n                A[row, k] = w_div * dphi_dx(x_c[i], y_c[i], m, n)\n                A[row, k + 4] = w_div * dpsi_dy(x_c[i], y_c[i], m, n)\n            b[row] = 0\n            row += 1\n        \n        coeffs, _, _, _ = lstsq(A, b)\n        return coeffs\n\n    # --- Solver for Method B ---\n    def solve_method_B():\n        num_coeffs = 8\n        num_rows = 2 * N_OMEGA + 2 * N_D + 1\n        A = np.zeros((num_rows, num_coeffs))\n        b = np.zeros(num_rows)\n        \n        x_c, y_c = collocation_pts[:, 0], collocation_pts[:, 1]\n        x_d, y_d = data_pts[:, 0], data_pts[:, 1]\n        x_p, y_p = pressure_pt[0, 0], pressure_pt[0, 1]\n\n        w_mom = np.sqrt(1 / N_OMEGA)\n        w_data = np.sqrt(ALPHA / N_D)\n        w_p = np.sqrt(ALPHA_P)\n\n        row = 0\n        # Momentum residual (u)\n        for i in range(N_OMEGA):\n            for k, (m, n) in enumerate(MODES):\n                A[row, k] = w_mom * NU * lapl_dsigma_dy(x_c[i], y_c[i], m, n)\n                A[row, k + 4] = w_mom * -dchi_dx(x_c[i], y_c[i], m, n)\n            b[row] = w_mom * -f_x(x_c[i], y_c[i])\n            row += 1\n        # Momentum residual (v)\n        for i in range(N_OMEGA):\n            for k, (m, n) in enumerate(MODES):\n                A[row, k] = w_mom * NU * -lapl_dsigma_dx(x_c[i], y_c[i], m, n)\n                A[row, k + 4] = w_mom * -dchi_dy(x_c[i], y_c[i], m, n)\n            b[row] = w_mom * -f_y(x_c[i], y_c[i])\n            row += 1\n        # Velocity data\n        for i in range(N_D):\n            for k, (m, n) in enumerate(MODES):\n                A[row, k] = w_data * dsigma_dy(x_d[i], y_d[i], m, n)\n            b[row] = w_data * u_star(x_d[i], y_d[i])\n            row += 1\n            for k, (m, n) in enumerate(MODES):\n                A[row, k] = w_data * -dsigma_dx(x_d[i], y_d[i], m, n)\n            b[row] = w_data * v_star(x_d[i], y_d[i])\n            row += 1\n        # Pressure anchor\n        for k, (m, n) in enumerate(MODES):\n            A[row, k + 4] = w_p * chi(x_p, y_p, m, n)\n        b[row] = w_p * p_star(x_p, y_p)\n        row += 1\n        \n        coeffs, _, _, _ = lstsq(A, b)\n        return coeffs\n\n    # --- Evaluation ---\n    def evaluate(coeffs, method):\n        x_v, y_v = validation_pts[:, 0], validation_pts[:, 1]\n        \n        u_pred, v_pred, p_pred = np.zeros(N_V), np.zeros(N_V), np.zeros(N_V)\n        du_dx, dv_dy = np.zeros(N_V), np.zeros(N_V)\n        lapl_u, lapl_v = np.zeros(N_V), np.zeros(N_V)\n        dp_dx, dp_dy = np.zeros(N_V), np.zeros(N_V)\n\n        if method == 'A':\n            a_coeffs, b_coeffs, c_coeffs = coeffs[0:4], coeffs[4:8], coeffs[8:12]\n            for k, (m, n) in enumerate(MODES):\n                u_pred += a_coeffs[k] * phi(x_v, y_v, m, n)\n                v_pred += b_coeffs[k] * psi(x_v, y_v, m, n)\n                p_pred += c_coeffs[k] * chi(x_v, y_v, m, n)\n                du_dx += a_coeffs[k] * dphi_dx(x_v, y_v, m, n)\n                dv_dy += b_coeffs[k] * dpsi_dy(x_v, y_v, m, n)\n                lapl_u += a_coeffs[k] * lapl_phi(x_v, y_v, m, n)\n                lapl_v += b_coeffs[k] * lapl_psi(x_v, y_v, m, n)\n                dp_dx += c_coeffs[k] * dchi_dx(x_v, y_v, m, n)\n                dp_dy += c_coeffs[k] * dchi_dy(x_v, y_v, m, n)\n        elif method == 'B':\n            s_coeffs, c_coeffs = coeffs[0:4], coeffs[4:8]\n            for k, (m, n) in enumerate(MODES):\n                u_pred += s_coeffs[k] * dsigma_dy(x_v, y_v, m, n)\n                v_pred += s_coeffs[k] * -dsigma_dx(x_v, y_v, m, n)\n                p_pred += c_coeffs[k] * chi(x_v, y_v, m, n)\n                du_dx += s_coeffs[k] * n*pi * m*pi * np.cos(m*pi*x_v)*np.cos(n*pi*y_v) # d/dx(dsigma/dy)\n                dv_dy += s_coeffs[k] * -m*pi * n*pi * np.cos(m*pi*x_v)*np.cos(n*pi*y_v) # d/dy(-dsigma/dx)\n                lapl_u += s_coeffs[k] * lapl_dsigma_dy(x_v, y_v, m, n)\n                lapl_v += s_coeffs[k] * -lapl_dsigma_dx(x_v, y_v, m, n)\n                dp_dx += c_coeffs[k] * dchi_dx(x_v, y_v, m, n)\n                dp_dy += c_coeffs[k] * dchi_dy(x_v, y_v, m, n)\n        \n        # N_div\n        div_u = du_dx + dv_dy\n        n_div = np.sqrt(np.mean(div_u**2))\n        \n        # N_mom\n        r_u = -dp_dx + NU * lapl_u + f_x(x_v, y_v)\n        r_v = -dp_dy + NU * lapl_v + f_y(x_v, y_v)\n        n_mom = np.sqrt(np.mean(r_u**2 + r_v**2))\n        \n        # E_u\n        u_s, v_s = u_star(x_v, y_v), v_star(x_v, y_v)\n        error_num = np.sqrt(np.mean((u_pred - u_s)**2 + (v_pred - v_s)**2))\n        error_den = np.sqrt(np.mean(u_s**2 + v_s**2))\n        e_u = error_num / error_den if error_den > 0 else 0.0\n\n        return n_div, n_mom, e_u\n\n    # --- Main Execution Logic ---\n    results = []\n    \n    # Method A cases\n    for lambda_val in LAMBDA_VALS:\n        coeffs_A = solve_method_A(lambda_val)\n        metrics_A = evaluate(coeffs_A, 'A')\n        results.extend(metrics_A)\n        \n    # Method B case\n    coeffs_B = solve_method_B()\n    metrics_B = evaluate(coeffs_B, 'B')\n    results.extend(metrics_B)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{val:.6f}' for val in results)}]\")\n\nsolve()\n```"
        }
    ]
}