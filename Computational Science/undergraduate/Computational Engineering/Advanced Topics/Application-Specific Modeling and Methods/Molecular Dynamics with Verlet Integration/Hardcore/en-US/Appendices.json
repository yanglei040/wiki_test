{
    "hands_on_practices": [
        {
            "introduction": "The first step in mastering any numerical integrator is to apply it to a well-understood, conservative system where its performance can be clearly benchmarked. This practice challenges you to implement the Velocity Verlet algorithm to simulate the gravitational two-body problem, a classic scenario from celestial mechanics. By tracking the total energy of the system, you will gain direct, hands-on experience in how numerical parameters, like the time step $\\Delta t$, influence the accuracy and long-term stability of the simulation .",
            "id": "2414438",
            "problem": "Consider a closed, isolated, planar two-body system governed by Newtonian gravity. Two point masses with masses $m_1$ and $m_2$ move in two spatial dimensions under their mutual gravitational attraction, with no other forces present and no external torques. Let the universal gravitational constant (in Astronomical Units, Solar Masses, and Years) be $G = 4\\pi^2$, where distance is measured in Astronomical Units (AU), mass in Solar Masses ($M_{\\odot}$), and time in Years (yr). Let the positions be $\\mathbf{r}_1(t), \\mathbf{r}_2(t) \\in \\mathbb{R}^2$, and velocities be $\\mathbf{v}_1(t), \\mathbf{v}_2(t) \\in \\mathbb{R}^2$. The equations of motion are defined by Newton’s second law and the law of universal gravitation. The total energy at time $t$ is given by\n$$\nE(t) = \\tfrac{1}{2} m_1 \\|\\mathbf{v}_1(t)\\|^2 + \\tfrac{1}{2} m_2 \\|\\mathbf{v}_2(t)\\|^2 - \\frac{G m_1 m_2}{\\|\\mathbf{r}_1(t) - \\mathbf{r}_2(t)\\|}.\n$$\nDefine the maximum relative energy deviation over a simulation interval $[0, T_{\\text{end}}]$ with time step $\\Delta t$ as\n$$\n\\varepsilon_{\\max} = \\max_{t_k \\in \\{0, \\Delta t, 2\\Delta t, \\dots\\}} \\frac{|E(t_k) - E(0)|}{|E(0)|}.\n$$\nSimulate the system for the following test suite. For each case, initialize the state at $t = 0$ with the given masses, positions (in AU), velocities (in AU/yr), time step $\\Delta t$ (in yr), and total simulation duration $T_{\\text{end}}$ (in yr). Compute $\\varepsilon_{\\max}$ as defined above. Express each result as a decimal float rounded to six significant digits (dimensionless).\n\nTest Suite (each line defines one case):\n- Case $1$ (equal-mass circular configuration, short step): $m_1 = 1.0$, $m_2 = 1.0$, $\\mathbf{r}_1(0) = (-0.5, 0.0)$, $\\mathbf{r}_2(0) = (0.5, 0.0)$, $\\mathbf{v}_1(0) = (0.0, 4.442882938)$, $\\mathbf{v}_2(0) = (0.0, -4.442882938)$, $\\Delta t = 0.001$, $T_{\\text{end}} = 0.707106781$.\n- Case $2$ (equal-mass circular configuration, larger step): $m_1 = 1.0$, $m_2 = 1.0$, $\\mathbf{r}_1(0) = (-0.5, 0.0)$, $\\mathbf{r}_2(0) = (0.5, 0.0)$, $\\mathbf{v}_1(0) = (0.0, 4.442882938)$, $\\mathbf{v}_2(0) = (0.0, -4.442882938)$, $\\Delta t = 0.01$, $T_{\\text{end}} = 0.707106781$.\n- Case $3$ (extreme mass ratio, wide separation circular configuration): $m_1 = 1.0$, $m_2 = 0.001$, $\\mathbf{r}_1(0) = (-0.005194805195, 0.0)$, $\\mathbf{r}_2(0) = (5.194805195, 0.0)$, $\\mathbf{v}_1(0) = (0.0, 0.002754177)$, $\\mathbf{v}_2(0) = (0.0, -2.754177)$, $\\Delta t = 0.01$, $T_{\\text{end}} = 11.86$.\n- Case $4$ (equal-mass circular configuration, long duration and coarse step): $m_1 = 1.0$, $m_2 = 1.0$, $\\mathbf{r}_1(0) = (-0.5, 0.0)$, $\\mathbf{r}_2(0) = (0.5, 0.0)$, $\\mathbf{v}_1(0) = (0.0, 4.442882938)$, $\\mathbf{v}_2(0) = (0.0, -4.442882938)$, $\\Delta t = 0.05$, $T_{\\text{end}} = 7.071067811$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test suite, for example, $[\\varepsilon_1,\\varepsilon_2,\\varepsilon_3,\\varepsilon_4]$, where each $\\varepsilon_i$ is $\\varepsilon_{\\max}$ for Case $i$ rounded to six significant digits.",
            "solution": "The problem presented is a well-posed and scientifically grounded task in computational mechanics. It requires the numerical simulation of a planar two-body system under mutual Newtonian gravitational attraction. The objective is to compute the maximum relative energy deviation over the course of the simulation, which serves as a metric for the numerical accuracy and energy conservation of the integration method.\n\nThe system is governed by Newton's second law and the law of universal gravitation. For two point masses $m_1$ and $m_2$ at positions $\\mathbf{r}_1$ and $\\mathbf{r}_2$, the force exerted on $m_1$ by $m_2$ is\n$$\n\\mathbf{F}_1 = \\frac{G m_1 m_2}{\\|\\mathbf{r}_2 - \\mathbf{r}_1\\|^3} (\\mathbf{r}_2 - \\mathbf{r}_1).\n$$\nBy Newton's third law, $\\mathbf{F}_2 = -\\mathbf{F}_1$. The accelerations are thus given by:\n$$\n\\mathbf{a}_1(t) = \\frac{\\mathbf{F}_1}{m_1} = \\frac{G m_2}{\\|\\mathbf{r}_2(t) - \\mathbf{r}_1(t)\\|^3} (\\mathbf{r}_2(t) - \\mathbf{r}_1(t))\n$$\n$$\n\\mathbf{a}_2(t) = \\frac{\\mathbf{F}_2}{m_2} = \\frac{G m_1}{\\|\\mathbf{r}_1(t) - \\mathbf{r}_2(t)\\|^3} (\\mathbf{r}_1(t) - \\mathbf{r}_2(t)).\n$$\nHere, $G = 4\\pi^2$ is the gravitational constant in the specified units of AU, Solar Masses, and Years.\n\nTo solve this system of ordinary differential equations numerically, a suitable integration scheme must be employed. The Velocity Verlet algorithm is an excellent choice for this type of problem. It is a time-reversible, symplectic integrator known for its superior long-term energy conservation compared to simpler methods like the Euler integrator. The algorithm updates positions and velocities from time $t$ to $t + \\Delta t$ as follows:\n\n1.  First, update the positions using the current velocities and accelerations:\n    $$\n    \\mathbf{r}_i(t + \\Delta t) = \\mathbf{r}_i(t) + \\mathbf{v}_i(t) \\Delta t + \\frac{1}{2} \\mathbf{a}_i(t) (\\Delta t)^2 \\quad \\text{for } i \\in \\{1, 2\\}.\n    $$\n\n2.  Next, compute the accelerations $\\mathbf{a}_i(t + \\Delta t)$ at the new positions $\\mathbf{r}_i(t + \\Delta t)$.\n\n3.  Finally, update the velocities using the average of the old and new accelerations:\n    $$\n    \\mathbf{v}_i(t + \\Delta t) = \\mathbf{v}_i(t) + \\frac{1}{2} (\\mathbf{a}_i(t) + \\mathbf{a}_i(t + \\Delta t)) \\Delta t \\quad \\text{for } i \\in \\{1, 2\\}.\n    $$\n\nThe simulation proceeds by iteratively applying these steps. The algorithm is as follows:\n\n1.  Initialize the state of the system at $t=0$ using the provided masses $m_1, m_2$, initial positions $\\mathbf{r}_1(0), \\mathbf{r}_2(0)$, and initial velocities $\\mathbf{v}_1(0), \\mathbf{v}_2(0)$.\n2.  Calculate the initial total energy $E(0)$. The total energy is the sum of the kinetic and potential energies:\n    $$\n    E(t) = \\frac{1}{2} m_1 \\|\\mathbf{v}_1(t)\\|^2 + \\frac{1}{2} m_2 \\|\\mathbf{v}_2(t)\\|^2 - \\frac{G m_1 m_2}{\\|\\mathbf{r}_1(t) - \\mathbf{r}_2(t)\\|}.\n    $$\n    If $E(0)=0$, the relative error is undefined. However, for the provided initial conditions corresponding to bound (circular) orbits, the total energy is negative, so this is not a concern.\n3.  Calculate the initial accelerations $\\mathbf{a}_1(0)$ and $\\mathbf{a}_2(0)$ using the initial positions.\n4.  Initialize the maximum relative energy deviation $\\varepsilon_{\\max}$ to $0$.\n5.  Begin a time-stepping loop from $t=0$ to $T_{\\text{end}}$ with a time step of $\\Delta t$. The number of steps is given by $N = \\text{round}(T_{\\text{end}} / \\Delta t)$.\n6.  In each step of the loop, update the positions and velocities of both masses using the Velocity Verlet algorithm.\n7.  After each update, calculate the new total energy $E(t_k)$ for the current time step $t_k = k\\Delta t$.\n8.  Compute the relative energy deviation for the current step: $\\varepsilon_k = \\frac{|E(t_k) - E(0)|}{|E(0)|}$.\n9.  Update $\\varepsilon_{\\max}$ such that $\\varepsilon_{\\max} = \\max(\\varepsilon_{\\max}, \\varepsilon_k)$.\n10. After the loop completes, the final value of $\\varepsilon_{\\max}$ is the result for the given test case.\n\nThis procedure is applied to each of the four test cases specified in the problem statement. The resulting values of $\\varepsilon_{\\max}$ are then formatted to six significant digits and presented in the required output format.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the two-body problem for the given test cases and prints the results.\n    \"\"\"\n\n    # Define the gravitational constant in AU, M_sun, yr units.\n    G = 4.0 * np.pi**2\n\n    # Test suite from the problem statement.\n    test_cases = [\n        # Case 1: m1, m2, r1(0), r2(0), v1(0), v2(0), dt, T_end\n        (1.0, 1.0, [-0.5, 0.0], [0.5, 0.0], [0.0, 4.442882938], [0.0, -4.442882938], 0.001, 0.707106781),\n        # Case 2\n        (1.0, 1.0, [-0.5, 0.0], [0.5, 0.0], [0.0, 4.442882938], [0.0, -4.442882938], 0.01, 0.707106781),\n        # Case 3\n        (1.0, 0.001, [-0.005194805195, 0.0], [5.194805195, 0.0], [0.0, 0.002754177], [0.0, -2.754177], 0.01, 11.86),\n        # Case 4\n        (1.0, 1.0, [-0.5, 0.0], [0.5, 0.0], [0.0, 4.442882938], [0.0, -4.442882938], 0.05, 7.071067811),\n    ]\n\n    def run_simulation(m1, m2, r1_0, r2_0, v1_0, v2_0, dt, T_end):\n        \"\"\"\n        Runs a single two-body simulation using the Velocity Verlet integrator.\n        \"\"\"\n        r1, r2 = np.array(r1_0, dtype=float), np.array(r2_0, dtype=float)\n        v1, v2 = np.array(v1_0, dtype=float), np.array(v2_0, dtype=float)\n\n        def get_energy(cur_r1, cur_r2, cur_v1, cur_v2):\n            r_vec = cur_r1 - cur_r2\n            dist = np.linalg.norm(r_vec)\n            kinetic_energy = 0.5 * m1 * np.dot(cur_v1, cur_v1) + 0.5 * m2 * np.dot(cur_v2, cur_v2)\n            potential_energy = -G * m1 * m2 / dist\n            return kinetic_energy + potential_energy\n\n        def get_accelerations(cur_r1, cur_r2):\n            r_vec = cur_r2 - cur_r1\n            dist_cubed = np.linalg.norm(r_vec)**3\n            if dist_cubed == 0:\n                raise ValueError(\"Collision detected: distance between bodies is zero.\")\n            a1 = G * m2 * r_vec / dist_cubed\n            a2 = -G * m1 * r_vec / dist_cubed\n            return a1, a2\n\n        # Initial conditions\n        E0 = get_energy(r1, r2, v1, v2)\n        if E0 == 0:\n            return 0.0  # Relative error is undefined, but max deviation would be 0 if energy is conserved.\n\n        a1, a2 = get_accelerations(r1, r2)\n        \n        max_rel_error = 0.0\n        num_steps = int(round(T_end / dt))\n\n        for _ in range(num_steps):\n            # Velocity Verlet Integration\n            # 1. Update positions\n            r1_new = r1 + v1 * dt + 0.5 * a1 * dt**2\n            r2_new = r2 + v2 * dt + 0.5 * a2 * dt**2\n\n            # 2. Compute new accelerations\n            a1_new, a2_new = get_accelerations(r1_new, r2_new)\n\n            # 3. Update velocities\n            v1_new = v1 + 0.5 * (a1 + a1_new) * dt\n            v2_new = v2 + 0.5 * (a2 + a2_new) * dt\n            \n            # Update state for next iteration\n            r1, r2 = r1_new, r2_new\n            v1, v2 = v1_new, v2_new\n            a1, a2 = a1_new, a2_new\n\n            # Calculate energy and update max relative error\n            E_t = get_energy(r1, r2, v1, v2)\n            rel_error = abs((E_t - E0) / E0)\n            if rel_error > max_rel_error:\n                max_rel_error = rel_error\n\n        return max_rel_error\n\n    results = []\n    for case in test_cases:\n        epsilon_max = run_simulation(*case)\n        results.append(epsilon_max)\n\n    # Format results to six significant digits. The 'g' format specifier achieves this.\n    formatted_results = [f\"{res:.6g}\" for res in results]\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While the Verlet algorithm excels in conservative systems, many physical phenomena involve non-conservative forces, such as friction or viscosity, which cause energy to dissipate. This exercise guides you to extend the core Verlet framework to handle a system with a velocity-dependent drag force. You will derive and implement a modified integrator for a damped harmonic oscillator, shifting the focus from verifying energy conservation to accurately modeling energy dissipation, a crucial capability for simulating more realistic systems .",
            "id": "2414487",
            "problem": "Consider a single point particle of mass $m$ moving along a line under a harmonic potential $U(x) = \\tfrac{1}{2} k x^2$ and a linear drag force $F_{\\text{drag}} = - \\gamma v$. The total force is $F(x,v) = -k x - \\gamma v$. The motion is governed by Newton's second law $m \\ddot{x}(t) = F\\big(x(t), \\dot{x}(t)\\big)$. The mechanical energy is $E(t) = \\tfrac{1}{2} m \\, v(t)^2 + \\tfrac{1}{2} k \\, x(t)^2$. Use nondimensional units for all quantities.\n\nYour task is to derive from first principles a discrete-time update map $\\big(x_n, v_n\\big) \\mapsto \\big(x_{n+1}, v_{n+1}\\big)$ with a uniform time step $\\Delta t$ that is consistent with the given dynamics, reduces to the standard Verlet family of schemes when $\\gamma \\to 0$, and advances the system through time levels $t_n = n \\, \\Delta t$ for $n \\in \\{0,1,2,\\dots\\}$. Implement this update to simulate the system for the parameter sets listed below. The initial conditions are $x(0) = x_0$ and $v(0) = v_0$, which define $x_0 = x_{n=0}$ and $v_0 = v_{n=0}$.\n\nFor each simulation, compute the discrete mechanical energy $E_n = \\tfrac{1}{2} m \\, v_n^2 + \\tfrac{1}{2} k \\, x_n^2$ and evaluate the requested quantitative metric. All outputs are dimensionless. Angles do not appear. When computing any logarithm, use the natural logarithm.\n\nTest suite and required outputs:\n- Case A (energy dissipation rate estimation): $m = 1$, $k = 1$, $\\gamma = 0.1$, $x_0 = 1$, $v_0 = 0$, $\\Delta t = 0.01$, total time $T = 50$, so that the number of steps is $N = T / \\Delta t$. Form the time series $\\{(t_n, E_n)\\}_{n=0}^{N}$ with $t_n = n \\Delta t$. Perform an unweighted linear least-squares fit of $\\ln E_n$ versus $t_n$ over the subset $n \\ge N_b$ with burn-in $N_b = 200$ to obtain slope $s$. Output the float $|s + \\gamma/m|$.\n- Case B (conservative limit energy drift): $m = 1$, $k = 1$, $\\gamma = 0$, $x_0 = 1$, $v_0 = 0$, $\\Delta t = 0.01$, $T = 50$. Output the float $\\max_{0 \\le n \\le N} \\big|E_n - E_0\\big| / E_0$.\n- Case C (monotonic energy decrease under strong damping): $m = 1$, $k = 1$, $\\gamma = 5$, $x_0 = 1$, $v_0 = 0$, $\\Delta t = 0.001$, $T = 5$. Output the boolean indicating whether $E_{n+1} \\le E_n + \\varepsilon$ holds for all $0 \\le n  N$, with absolute tolerance $\\varepsilon = 10^{-12}$.\n- Case D (numerical stability under coarse time step): $m = 1$, $k = 1$, $\\gamma = 0.5$, $x_0 = 1$, $v_0 = 0$, $\\Delta t = 0.2$, $T = 100$. Output the boolean indicating whether all simulated states remain finite and bounded in magnitude, specifically $\\max_n \\{|x_n|, |v_n|\\}  B$ with $B = 10^3$, and all energies satisfy $E_n \\ge - \\delta$ with $\\delta = 10^{-12}$.\n\nFinal output format:\nYour program should produce a single line of output containing the results for Cases A through D, in order, as a comma-separated list enclosed in square brackets, for example $[a,b,c,d]$, where $a$ and $b$ are floats and $c$ and $d$ are booleans. No other text should be printed.",
            "solution": "The provided problem statement is subjected to validation and is found to be scientifically grounded, well-posed, and objective. It describes a damped harmonic oscillator, a canonical system in classical mechanics, governed by the second-order linear ordinary differential equation $m \\ddot{x} + \\gamma \\dot{x} + kx = 0$. The task is to derive a suitable numerical integration scheme and apply it to several test cases. All parameters are provided, and the requested metrics are well-defined. The problem is valid.\n\nThe derivation of the discrete-time update map proceeds as follows. The equation of motion is $m \\ddot{x}(t) = -k x(t) - \\gamma \\dot{x}(t)$. Let $a(t) = \\ddot{x}(t)$ be the acceleration, $v(t) = \\dot{x}(t)$ be the velocity, and $x(t)$ be the position. The state of the system at time $t_n = n \\Delta t$ is given by the pair $(x_n, v_n)$. We seek a map $(x_n, v_n) \\mapsto (x_{n+1}, v_{n+1})$.\n\nA standard method for molecular dynamics is the Velocity Verlet algorithm. For a general time-dependent acceleration $a(t)$, its update rules are:\n$$\nx_{n+1} = x_n + v_n \\Delta t + \\frac{1}{2} a_n \\Delta t^2\n$$\n$$\nv_{n+1} = v_n + \\frac{1}{2} (a_n + a_{n+1}) \\Delta t\n$$\nIn our system, the acceleration $a(t)$ depends on both position and velocity: $a(t) = \\frac{1}{m}(-k x(t) - \\gamma v(t))$. Therefore, $a_n = \\frac{1}{m}(-k x_n - \\gamma v_n)$ and $a_{n+1} = \\frac{1}{m}(-k x_{n+1} - \\gamma v_{n+1})$.\n\nThe position update is explicit: $x_{n+1}$ can be computed directly from $x_n$ and $v_n$. However, the velocity update becomes implicit because $a_{n+1}$ depends on $v_{n+1}$, the quantity we wish to compute:\n$$\nv_{n+1} = v_n + \\frac{\\Delta t}{2} \\left( a_n + \\frac{-k x_{n+1} - \\gamma v_{n+1}}{m} \\right)\n$$\nThis equation can be rearranged to solve for $v_{n+1}$:\n$$\nv_{n+1} = v_n + \\frac{\\Delta t}{2} a_n - \\frac{k \\Delta t}{2m} x_{n+1} - \\frac{\\gamma \\Delta t}{2m} v_{n+1}\n$$\n$$\nv_{n+1} \\left(1 + \\frac{\\gamma \\Delta t}{2m}\\right) = v_n + \\frac{\\Delta t}{2} \\left( a_n - \\frac{k}{m} x_{n+1} \\right)\n$$\nSince the dependence is linear, we can find an explicit expression for $v_{n+1}$:\n$$\nv_{n+1} = \\left(1 + \\frac{\\gamma \\Delta t}{2m}\\right)^{-1} \\left[ v_n + \\frac{\\Delta t}{2} \\left( \\frac{-k x_n - \\gamma v_n}{m} - \\frac{k x_{n+1}}{m} \\right) \\right]\n$$\nThis can be simplified by regrouping terms involving $v_n$:\n$$\nv_{n+1} = \\left(1 + \\frac{\\gamma \\Delta t}{2m}\\right)^{-1} \\left[ v_n \\left(1 - \\frac{\\gamma \\Delta t}{2m}\\right) - \\frac{k \\Delta t}{2m} (x_n + x_{n+1}) \\right]\n$$\nThis scheme, often known as the Brünger-Brooks-Karplus (BBK) integrator, provides a fully explicit update procedure. First, $x_{n+1}$ is calculated from $(x_n, v_n)$. Then, this new position $x_{n+1}$ is used along with $(x_n, v_n)$ to calculate $v_{n+1}$.\n\nWe must verify that this scheme reduces to the standard Velocity Verlet algorithm in the limit $\\gamma \\to 0$. If we set $\\gamma=0$, the equations become:\n$$\nx_{n+1} = x_n + v_n \\Delta t + \\frac{1}{2} \\left( \\frac{-k x_n}{m} \\right) \\Delta t^2 = x_n + v_n \\Delta t + \\frac{1}{2} a_n \\Delta t^2\n$$\n$$\nv_{n+1} = (1+0)^{-1} \\left[ v_n(1-0) - \\frac{k \\Delta t}{2m}(x_n + x_{n+1}) \\right] = v_n + \\frac{\\Delta t}{2} \\left( \\frac{-k x_n}{m} + \\frac{-k x_{n+1}}{m} \\right) = v_n + \\frac{1}{2} (a_n + a_{n+1}) \\Delta t\n$$\nThese are precisely the equations for Velocity Verlet in a conservative field with force $F(x) = -kx$. Thus, the derived integrator satisfies all the problem's requirements.\n\nThe simulation algorithm is as follows:\nGiven initial conditions $(x_0, v_0)$ and parameters $m, k, \\gamma, \\Delta t, T$. The number of steps is $N = \\text{round}(T/\\Delta t)$.\nInitialize arrays for position $x$, velocity $v$, and energy $E$ of size $N+1$. Set $x[0]=x_0, v[0]=v_0$.\nFor $n$ from $0$ to $N-1$:\n$1$. Compute the next position $x_{n+1}$:\n   $$\n   x_{n+1} = x_n + v_n \\Delta t + \\frac{\\Delta t^2}{2m}(-k x_n - \\gamma v_n)\n   $$\n$2$. Compute the next velocity $v_{n+1}$:\n   $$\n   c = \\frac{\\gamma \\Delta t}{2m}\n   $$\n   $$\n   v_{n+1} = \\frac{1}{1+c} \\left[ v_n(1-c) - \\frac{k \\Delta t}{2m}(x_n + x_{n+1}) \\right]\n   $$\n$3$. Store $x_{n+1}$ and $v_{n+1}$ in the arrays.\nAfter the loop, compute the energy time series $E_n = \\frac{1}{2} m v_n^2 + \\frac{1}{2} k x_n^2$ for all $n \\in \\{0, 1, \\dots, N\\}$.\nThis procedure is applied to each of the four test cases specified.\n\nFor Case A, an unweighted linear least-squares fit of $\\ln E_n$ vs $t_n$ is performed for $n \\geq N_b=200$. The slope $s$ is obtained. The analytical decay of energy for small damping is approximately $E(t) \\approx E_0 e^{-(\\gamma/m) t}$, implying $\\ln E(t) \\approx \\ln E_0 - (\\gamma/m)t$. We thus expect the slope $s$ to be close to $-\\gamma/m$. The metric is $|s + \\gamma/m|$.\n\nFor Case B, the system is conservative ($\\gamma = 0$), so energy should be conserved. The metric is the maximum relative deviation of energy from its initial value, $\\max_n |E_n - E_0|/E_0$.\n\nFor Case C, the system is strongly damped. Analytically, energy must be a non-increasing function of time since $\\frac{dE}{dt} = -\\gamma v^2 \\le 0$. The metric checks if $E_{n+1} \\le E_n + \\varepsilon$ for all steps, verifying that the numerical scheme preserves this property up to a small floating-point tolerance $\\varepsilon = 10^{-12}$.\n\nFor Case D, the stability of the integrator is tested with a large time step. The metric verifies that the trajectory remains bounded (i.e., $|x_n|, |v_n|  B = 10^3$) and that the energy remains non-negative (i.e., $E_n \\ge -\\delta = -10^{-12}$), which confirms the absence of numerical explosion or unphysical behavior.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n\n    def simulate(m, k, gamma, x0, v0, dt, T):\n        \"\"\"\n        Simulates the damped harmonic oscillator using the derived integrator.\n        \n        Args:\n            m (float): Mass of the particle.\n            k (float): Spring constant.\n            gamma (float): Damping coefficient.\n            x0 (float): Initial position.\n            v0 (float): Initial velocity.\n            dt (float): Time step.\n            T (float): Total simulation time.\n            \n        Returns:\n            tuple: A tuple containing arrays for time, position, velocity, and energy.\n        \"\"\"\n        num_steps = int(round(T / dt))\n        ts = np.linspace(0, T, num_steps + 1)\n        xs = np.zeros(num_steps + 1)\n        vs = np.zeros(num_steps + 1)\n        \n        xs[0] = x0\n        vs[0] = v0\n\n        # Precompute constants for the loop\n        c = (gamma * dt) / (2.0 * m)\n        k_dt_2m = (k * dt) / (2.0 * m)\n\n        for n in range(num_steps):\n            # Current state\n            x_n, v_n = xs[n], vs[n]\n            \n            # 1. Update position\n            a_n = (-k * x_n - gamma * v_n) / m\n            x_n_plus_1 = x_n + v_n * dt + 0.5 * a_n * dt**2\n            \n            # 2. Update velocity\n            # The derived formula:\n            # v_{n+1} = (1/(1+c)) * [v_n*(1-c) - (k*dt/(2*m))*(x_n + x_{n+1})]\n            v_n_plus_1 = (1.0 / (1.0 + c)) * (v_n * (1.0 - c) - k_dt_2m * (x_n + x_n_plus_1))\n            \n            xs[n + 1] = x_n_plus_1\n            vs[n + 1] = v_n_plus_1\n            \n        Es = 0.5 * m * vs**2 + 0.5 * k * xs**2\n        return ts, xs, vs, Es\n\n    # --- Test Cases ---\n    test_cases = [\n        {'m': 1.0, 'k': 1.0, 'gamma': 0.1, 'x0': 1.0, 'v0': 0.0, 'dt': 0.01, 'T': 50.0}, # Case A\n        {'m': 1.0, 'k': 1.0, 'gamma': 0.0, 'x0': 1.0, 'v0': 0.0, 'dt': 0.01, 'T': 50.0}, # Case B\n        {'m': 1.0, 'k': 1.0, 'gamma': 5.0, 'x0': 1.0, 'v0': 0.0, 'dt': 0.001, 'T': 5.0}, # Case C\n        {'m': 1.0, 'k': 1.0, 'gamma': 0.5, 'x0': 1.0, 'v0': 0.0, 'dt': 0.2, 'T': 100.0} # Case D\n    ]\n    \n    results = []\n\n    # Case A: Energy dissipation rate estimation\n    pA = test_cases[0]\n    ts_A, _, _, Es_A = simulate(**pA)\n    N_b = 200\n    # Filter out any non-positive energies before taking the log to avoid warnings/errors\n    valid_indices = (Es_A[N_b:] > 0)\n    t_fit = ts_A[N_b:][valid_indices]\n    log_E_fit = np.log(Es_A[N_b:][valid_indices])\n    \n    # Perform linear least-squares fit (slope is the first element of the result)\n    if len(t_fit) > 1:\n        slope_s = np.polyfit(t_fit, log_E_fit, 1)[0]\n        result_A = abs(slope_s + pA['gamma'] / pA['m'])\n    else: # Handle case where no data is available for fit\n        result_A = np.nan\n    results.append(result_A)\n\n    # Case B: Conservative limit energy drift\n    pB = test_cases[1]\n    _, _, _, Es_B = simulate(**pB)\n    E0_B = Es_B[0]\n    if E0_B > 0:\n        result_B = np.max(np.abs(Es_B - E0_B)) / E0_B\n    else: # Avoid division by zero if initial energy is zero\n        result_B = 0.0 if np.all(Es_B == 0) else np.nan\n    results.append(result_B)\n\n    # Case C: Monotonic energy decrease under strong damping\n    pC = test_cases[2]\n    _, _, _, Es_C = simulate(**pC)\n    epsilon_C = 1e-12\n    result_C = np.all(Es_C[1:] = Es_C[:-1] + epsilon_C)\n    results.append(result_C)\n\n    # Case D: Numerical stability under coarse time step\n    pD = test_cases[3]\n    _, xs_D, vs_D, Es_D = simulate(**pD)\n    bound_B = 1e3\n    delta_D = 1e-12\n    is_bounded = np.max(np.abs(xs_D))  bound_B and np.max(np.abs(vs_D))  bound_B\n    is_energy_physical = np.all(Es_D >= -delta_D)\n    result_D = is_bounded and is_energy_physical\n    results.append(result_D)\n    \n    # Final print statement in the exact required format.\n    # We must explicitly convert booleans to lowercase 'true'/'false' as per common conventions\n    # although standard str() in Python would give 'True'/'False'. The problem is ambiguous.\n    # Assuming standard Python string conversion for bools.\n    results_str = [str(r).lower() if isinstance(r, bool) else f\"{r:.6g}\" for r in results]\n    print(f\"[{','.join(results_str)}]\")\n\n\nsolve()\n```"
        },
        {
            "introduction": "The remarkable long-term stability of the Verlet integrator stems from its ability to conserve a \"shadow\" Hamiltonian, which relies on the smoothness of the underlying potential energy function. This conceptual problem explores a critical subtlety often encountered in practical molecular dynamics: the consequences of using a non-differentiable potential. By analyzing a common \"truncated-and-shifted\" Lennard-Jones potential, you will discover how a discontinuity in the force, even if the potential itself is continuous, can break the integrator's ideal conservation properties and lead to systematic energy drift .",
            "id": "2414466",
            "problem": "Consider a three-dimensional Molecular Dynamics (MD) simulation of $N$ identical particles of mass $m$ in a cubic periodic box evolved in the constant particle number, volume, and energy (NVE) ensemble using the velocity-Verlet integrator with time step $\\Delta t$. Particles interact via the Lennard-Jones (LJ) pair potential\n$$\nU_{\\mathrm{LJ}}(r)=4\\epsilon\\left[\\left(\\frac{\\sigma}{r}\\right)^{12}-\\left(\\frac{\\sigma}{r}\\right)^{6}\\right],\n$$\nwhich is truncated at a cutoff $r_{\\mathrm{c}}$ and shifted so that the potential is continuous at $r_{\\mathrm{c}}$:\n$$\nU_{\\mathrm{TS}}(r)=\n\\begin{cases}\nU_{\\mathrm{LJ}}(r)-U_{\\mathrm{LJ}}(r_{\\mathrm{c}}),  rr_{\\mathrm{c}},\\\\\n0,  r\\ge r_{\\mathrm{c}}.\n\\end{cases}\n$$\nHere $r$ is the pair separation, $\\epsilon$ sets the energy scale, and $\\sigma$ sets the length scale. No thermostats or barostats are applied, and neighbor lists are updated at finite intervals.\n\nWhich statement best describes the expected effect of using this truncated-and-shifted LJ potential on the conservation of the total energy $E(t)$ in this NVE simulation, for finite but small $\\Delta t$?\n\nA. Because the potential is shifted to zero at $r_{\\mathrm{c}}$, both $U$ and the force are continuous; velocity-Verlet therefore conserves the total energy exactly up to roundoff, with no long-time drift.\n\nB. Although the potential $U$ is continuous at $r_{\\mathrm{c}}$, the force is discontinuous there; as particle pairs cross the cutoff between force evaluations, the missed impulsive contribution leads to a small but systematic drift of the total energy over long times, which is reduced by smaller $\\Delta t$, more frequent neighbor-list updates, or by using a force-smoothed cutoff.\n\nC. There is no systematic drift in the total energy; one observes only bounded oscillations around a constant mean, identical to simulations with an untruncated potential, because symplectic integrators always conserve a modified Hamiltonian.\n\nD. Energy conservation is catastrophically broken by truncation and shifting; even with very small $\\Delta t$ the total energy grows without bound on short time scales.",
            "solution": "The problem requires an analysis of energy conservation in a Molecular Dynamics simulation using a velocity-Verlet integrator and a specific form of truncated-and-shifted Lennard-Jones potential. The validity of the problem statement must first be established.\n\n### Step 1: Extract Givens\n- Ensemble: Constant $N$, $V$, $E$ (NVE).\n- Particles: $N$ identical particles of mass $m$.\n- Integrator: Velocity-Verlet with time step $\\Delta t$.\n- Potential: Lennard-Jones (LJ) pair potential, $U_{\\mathrm{LJ}}(r)=4\\epsilon\\left[\\left(\\frac{\\sigma}{r}\\right)^{12}-\\left(\\frac{\\sigma}{r}\\right)^{6}\\right]$.\n- Cutoff scheme: The potential is truncated at $r_{\\mathrm{c}}$ and shifted, defined as:\n$$\nU_{\\mathrm{TS}}(r)=\n\\begin{cases}\nU_{\\mathrm{LJ}}(r)-U_{\\mathrm{LJ}}(r_{\\mathrm{c}}),  rr_{\\mathrm{c}},\\\\\n0,  r\\ge r_{\\mathrm{c}}.\n\\end{cases}\n$$\n- Additional conditions: No thermostats or barostats; neighbor lists updated at finite intervals.\n- Question: What is the effect of this potential on the conservation of total energy $E(t)$ for a finite but small $\\Delta t$?\n\n### Step 2: Validate Using Extracted Givens\nThe problem statement describes a standard computational experiment in molecular simulation. The NVE ensemble, the velocity-Verlet algorithm, the Lennard-Jones potential, and the use of a truncated-and-shifted potential are all well-established concepts. The question poses a non-trivial but well-defined problem regarding the numerical stability and accuracy of the simulation, which is a key topic in computational science. The problem is scientifically grounded, well-posed, objective, and internally consistent. It does not violate any principles of physics or mathematics and contains sufficient information for a rigorous analysis.\n\n### Step 3: Verdict and Action\nThe problem statement is valid. A full solution will be derived.\n\n### Derivation\nThe total energy of the system is the sum of the kinetic energy $K$ and the potential energy $U$, $E = K + U$. In an NVE simulation with a conservative force field, the total energy must be a constant of motion. However, we are using a numerical integrator, which approximates the solution to the equations of motion.\n\nThe velocity-Verlet integrator is a symplectic method. For a Hamiltonian system with a sufficiently smooth potential energy function (e.g., continuously differentiable to a certain order), a symplectic integrator does not conserve the true Hamiltonian (energy) $E$ exactly. Instead, it exactly conserves a nearby \"shadow\" Hamiltonian, $E_{\\text{shadow}}$, which differs from $E$ by a small amount, typically of the order of the time step squared, $O(\\Delta t^2)$. This property ensures that the true energy $E(t)$ exhibits bounded oscillations around its initial value, without any systematic long-term drift.\n\nThe critical point of this problem is to examine the smoothness of the specified potential, $U_{\\mathrm{TS}}(r)$.\nThe potential is defined as:\n$$\nU_{\\mathrm{TS}}(r)=\n\\begin{cases}\nU_{\\mathrm{LJ}}(r)-U_{\\mathrm{LJ}}(r_{\\mathrm{c}}),  rr_{\\mathrm{c}},\\\\\n0,  r\\ge r_{\\mathrm{c}}.\n\\end{cases}\n$$\nLet us check for continuity of the potential at the cutoff radius $r = r_{\\mathrm{c}}$.\nThe limit from below is $\\lim_{r \\to r_{\\mathrm{c}}^{-}} U_{\\mathrm{TS}}(r) = U_{\\mathrm{LJ}}(r_{\\mathrm{c}}) - U_{\\mathrm{LJ}}(r_{\\mathrm{c}}) = 0$.\nThe value from above is $U_{\\mathrm{TS}}(r) = 0$ for $r \\ge r_{\\mathrm{c}}$.\nSince the limits from both sides are equal to the value at the point, the potential $U_{\\mathrm{TS}}(r)$ is continuous everywhere. This is the purpose of the \"shift\" term $-U_{\\mathrm{LJ}}(r_{\\mathrm{c}})$. Without it, a simple truncation would lead to a discontinuity in the potential, which implies an infinite force, a catastrophic numerical artifact.\n\nNext, we must examine the force, which is the negative gradient of the potential. For a pair potential, the force magnitude is $F(r) = - \\frac{d U(r)}{dr}$.\nThe force derived from $U_{\\mathrm{TS}}(r)$ is:\n$$\nF_{\\mathrm{TS}}(r) = - \\frac{d U_{\\mathrm{TS}}(r)}{dr} =\n\\begin{cases}\n- \\frac{d}{dr} \\left[ U_{\\mathrm{LJ}}(r) - U_{\\mathrm{LJ}}(r_{\\mathrm{c}}) \\right] = - \\frac{d U_{\\mathrm{LJ}}(r)}{dr},  rr_{\\mathrm{c}},\\\\\n- \\frac{d}{dr} (0) = 0,  r  r_{\\mathrm{c}}.\n\\end{cases}\n$$\nThe force for $r  r_{\\mathrm{c}}$ is simply the standard Lennard-Jones force, $F_{\\mathrm{LJ}}(r) = - \\frac{d U_{\\mathrm{LJ}}(r)}{dr}$.\nLet us check the continuity of the force at $r=r_{\\mathrm{c}}$.\nThe limit from below is $\\lim_{r \\to r_{\\mathrm{c}}^{-}} F_{\\mathrm{TS}}(r) = F_{\\mathrm{LJ}}(r_{\\mathrm{c}})$.\nThe value from above is $\\lim_{r \\to r_{\\mathrm{c}}^{+}} F_{\\mathrm{TS}}(r) = 0$.\nIn general, the Lennard-Jones force at a typical cutoff distance (e.g., $r_{\\mathrm{c}} = 2.5\\sigma$) is not zero. $F_{\\mathrm{LJ}}(r_{\\mathrm{c}}) \\neq 0$. Therefore, the force $F_{\\mathrm{TS}}(r)$ has a step discontinuity at $r = r_{\\mathrm{c}}$.\n\nThis discontinuity in the force means that the potential energy function $U_{\\mathrm{TS}}(r)$ is not continuously differentiable ($C^1$). This violates the smoothness conditions required for the theorem on conservation of a shadow Hamiltonian by a symplectic integrator. Consequently, the excellent long-term energy conservation property of the velocity-Verlet algorithm is lost.\n\nWhen a pair of particles crosses the cutoff radius $r_{\\mathrm{c}}$ during a time step $\\Delta t$, the integrator, which evaluates forces at discrete times, fails to account for the work done correctly due to the abrupt change in force. This error is not random noise that averages to zero; it is a systematic effect. Each time a particle pair crosses the cutoff, a small amount of energy is incorrectly added to or removed from the system. Over long simulation times, these small errors accumulate, leading to a systematic drift in the total energy $E(t)$. The rate of this drift is proportional to the rate of cutoff crossings and the magnitude of the error per crossing. Reducing the time step $\\Delta t$ reduces the distance a particle travels in one step, thus reducing the error per crossing and slowing the rate of energy drift. To restore good energy conservation, one must use a potential that is at least $C^1$ at the cutoff, for example, by using a switching function to smoothly attenuate the force to zero—a technique known as force-smoothing or force-shifting.\n\n### Option-by-Option Analysis\n\n**A. Because the potential is shifted to zero at $r_{\\mathrm{c}}$, both $U$ and the force are continuous; velocity-Verlet therefore conserves the total energy exactly up to roundoff, with no long-time drift.**\nThis statement is incorrect. While the potential $U$ is continuous, the analysis above proves that the force is discontinuous at $r_{\\mathrm{c}}$. Furthermore, even with a smooth potential, velocity-Verlet does not conserve energy exactly; it produces bounded oscillations. The claim of continuity for the force and exact energy conservation are both false.\n\n**B. Although the potential $U$ is continuous at $r_{\\mathrm{c}}$, the force is discontinuous there; as particle pairs cross the cutoff between force evaluations, the missed impulsive contribution leads to a small but systematic drift of the total energy over long times, which is reduced by smaller $\\Delta t$, more frequent neighbor-list updates, or by using a force-smoothed cutoff.**\nThis statement is entirely consistent with our derivation. It correctly identifies that the potential is continuous but the force is not. It correctly attributes the systematic energy drift to the force discontinuity being improperly handled by the discrete-time integrator. It also correctly lists the standard remedies for this problem: reducing the time step $\\Delta t$ to decrease the error per step, more frequent neighbor-list updates to reduce errors from stale pair lists, and using a smoothly varying potential (force-smoothed) to eliminate the root cause of the problem. This statement is a precise and accurate description of the phenomenon.\n\n**C. There is no systematic drift in the total energy; one observes only bounded oscillations around a constant mean, identical to simulations with an untruncated potential, because symplectic integrators always conserve a modified Hamiltonian.**\nThis statement is incorrect. The assertion that \"symplectic integrators always conserve a modified Hamiltonian\" is a misapplication of the principle. This property relies on the Hamiltonian being sufficiently smooth, a condition which is violated by the non-differentiable potential $U_{\\mathrm{TS}}(r)$ at $r=r_{\\mathrm{c}}$. Therefore, the conclusion that there is no systematic drift is false. A systematic drift is precisely what is expected.\n\n**D. Energy conservation is catastrophically broken by truncation and shifting; even with very small $\\Delta t$ the total energy grows without bound on short time scales.**\nThis statement is an exaggeration and thus incorrect. The energy drift is systematic and problematic for long simulations, but it is not typically \"catastrophic\" on \"short time scales,\" especially for a small time step $\\Delta t$. The drift rate is proportional to some power of $\\Delta t$, so a smaller time step improves, not worsens, the situation. The term \"grows without bound\" is technically true over an infinite time horizon, but the description of the effect as a catastrophic, short-time-scale failure is inaccurate. The effect is a slow, cumulative drift.\n\nBased on the rigorous analysis, option B is the only correct and complete description of the physical and numerical situation.",
            "answer": "$$\\boxed{B}$$"
        }
    ]
}