{
    "hands_on_practices": [
        {
            "introduction": "在物理系统的长期模拟中，并非所有数值方法都能表现出色。本练习旨在揭示传统积分器（如四阶龙格-库塔法）和属于几何积分器的辛积分器（如速度Verlet算法）在能量守恒方面的根本差异。通过模拟一个简单的粒子碰撞问题，你将亲眼见证并量化辛积分器在抑制长期能量漂移方面的卓越性能，从而理解其在计算物理中的重要性。",
            "id": "2444593",
            "problem": "考虑一个一维哈密顿系统，该系统由两个相同的点粒子组成，其位置为 $x_1(t)$ 和 $x_2(t)$，速度为 $v_1(t)$ 和 $v_2(t)$，质量为 $m$。相互作用是一个陡峭的排斥势垒，由势能描述：\n$$\nV(r) \\;=\\; \\varepsilon \\left(\\frac{\\sigma}{\\sqrt{r^2+\\delta^2}}\\right)^{12},\n$$\n其中 $r = x_2 - x_1$ 是带符号的间距，$\\varepsilon > 0$ 设定了能量标度，$\\sigma > 0$ 设定了长度标度，$\\delta > 0$ 是一个小的软化参数，确保当 $r \\to 0$ 时 $V(r)$ 保持有限。哈密顿量为\n$$\nH \\;=\\; \\frac{p_1^2}{2m} + \\frac{p_2^2}{2m} + V(x_2 - x_1),\n$$\n其中正则动量为 $p_i = m v_i$。运动方程为哈密顿方程，\n$$\n\\dot{x}_i \\;=\\; \\frac{\\partial H}{\\partial p_i} \\;=\\; \\frac{p_i}{m}, \\qquad \\dot{p}_i \\;=\\; -\\frac{\\partial H}{\\partial x_i},\n$$\n这等价于牛顿第二定律，其中力由势能导出。对于给定的 $V(r)$ 和带符号的 $r = x_2 - x_1$，粒子1受到的力为 $F_1 = -\\frac{\\partial V}{\\partial x_1} = \\frac{\\mathrm{d}V}{\\mathrm{d}r}$，对粒子2的力为 $F_2 = -\\frac{\\mathrm{d}V}{\\mathrm{d}r}$，其中\n$$\n\\frac{\\mathrm{d}V}{\\mathrm{d}r} \\;=\\; -12\\,\\varepsilon\\,\\sigma^{12}\\,\\frac{r}{\\left(r^2+\\delta^2\\right)^{7}}.\n$$\n\n使用约化单位，其中 $\\varepsilon = 1$、$\\sigma = 1$ 和 $m = 1$，因此能量是 $\\varepsilon$ 的无量纲倍数，长度以 $\\sigma$ 为单位，时间以 $\\tau = \\sigma \\sqrt{m/\\varepsilon}$ 为单位。本系统中不涉及角度。在时间 $t = 0$ 时初始化系统，参数如下：\n$$\nx_1(0) = -2.0, \\quad x_2(0) = +2.0, \\quad v_1(0) = +0.8, \\quad v_2(0) = -0.8,\n$$\n并使用 $\\delta = 10^{-2}$。设总积分时间为 $T = 8.0$。\n\n您的程序必须对每个指定的时间步长 $\\Delta t$ 对上述系统进行两次独立的数值时间积分：一次使用速度Verlet（辛，二阶）方法，另一次使用经典的显式四阶龙格-库塔方法。对于每次积分，计算以下量化诊断指标：\n- 绝对末端能量误差 $|H(T) - H(0)|$。\n- 轨迹上的最大相对能量误差 $\\max_{0 \\le t \\le T} |H(t) - H(0)| / |H(0)|$。\n- 末端时间的速度交换误差，定义为末端速度与相同质量粒子在中心排斥力作用下发生正碰弹性散射的预期结果之间的欧几里得范数。在此设置的约化单位下，相互作用并重新分离后的预期末端速度为 $v_1^\\star = -0.8$ 和 $v_2^\\star = +0.8$。速度交换误差为\n$$\nE_{\\mathrm{swap}} \\;=\\; \\sqrt{\\left(v_1(T) - v_1^\\star\\right)^2 + \\left(v_2(T) - v_2^\\star\\right)^2}.\n$$\n- 时间可逆性误差，通过从初始状态以固定的 $\\Delta t$ 向前积分时间 $T$，然后使用相同的算法和步长大小但为负的步长 $-\\Delta t$ 向后积分时间 $T$，并将结果与初始状态进行比较来计算。将时间可逆性误差定义为相空间中的欧几里得范数，\n$$\nE_{\\mathrm{rev}} \\;=\\; \\sqrt{\\left(x_1^{\\mathrm{back}} - x_1(0)\\right)^2 + \\left(x_2^{\\mathrm{back}} - x_2(0)\\right)^2 + \\left(v_1^{\\mathrm{back}} - v_1(0)\\right)^2 + \\left(v_2^{\\mathrm{back}} - v_2(0)\\right)^2 }.\n$$\n\n测试套件：\n使用以下三个时间步长 $\\Delta t$：\n- $\\Delta t = 0.02$,\n- $\\Delta t = 0.005$,\n- $\\Delta t = 0.0005$。\n对于每个 $\\Delta t$，执行两种积分（速度Verlet和经典的显式四阶龙格-库塔），并按此顺序报告包含八个浮点数的列表\n$$\n\\left[\\, |H(T) - H(0)|_{\\mathrm{Verlet}},\\; |H(T) - H(0)|_{\\mathrm{RK4}},\\; \\max\\frac{|H - H(0)|}{|H(0)|}_{\\mathrm{Verlet}},\\; \\max\\frac{|H - H(0)|}{|H(0)|}_{\\mathrm{RK4}},\\; E_{\\mathrm{swap}}^{\\mathrm{Verlet}},\\; E_{\\mathrm{swap}}^{\\mathrm{RK4}},\\; E_{\\mathrm{rev}}^{\\mathrm{Verlet}},\\; E_{\\mathrm{rev}}^{\\mathrm{RK4}} \\,\\right].\n$$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。该列表必须为每个测试用例包含一个元素，其中每个元素本身是一个用方括号括起来的、包含八个所要求的浮点值的逗号分隔列表。例如，总体格式必须是\n$$\n\\big[\\, [a_{11},a_{12},\\dots,a_{18}],\\; [a_{21},\\dots,a_{28}],\\; [a_{31},\\dots,a_{38}] \\,\\big].\n$$\n在指定的约化单位中，所有值都是无量纲的。不要打印任何附加文本。答案必须是执行这些计算并打印所需单行输出的完整可运行程序。",
            "solution": "所提出的问题是计算物理学中的一个典型练习，具体涉及哈密顿系统的数值积分。它要求对两种不同的积分算法进行比较分析：速度Verlet方法，属于二阶辛积分器类；以及经典的显式四阶龙格-库塔 (RK4) 方法，一种通用的非辛格式。目的是评估它们在一个由陡峭排斥势能控制的一维双粒子系统上的性能。评估基于数值积分器的标准度量：能量守恒、相空间轨迹的准确性和时间可逆性。该问题定义明确，具有科学依据，并为完整求解提供了所有必要的参数和初始条件。\n\n该系统由约化单位下的哈密顿量描述（$m=1, \\varepsilon=1, \\sigma=1$）：\n$$\nH(x_1, x_2, p_1, p_2) \\;=\\; \\frac{1}{2}(p_1^2 + p_2^2) + V(x_2 - x_1)\n$$\n其中 $p_i = v_i$ 是正则动量（因为 $m=1$），势能由下式给出：\n$$\nV(r) \\;=\\; \\left(\\frac{1}{\\sqrt{r^2+\\delta^2}}\\right)^{12} \\;=\\; (r^2+\\delta^2)^{-6}\n$$\n其中 $r=x_2-x_1$ 是带符号的间距，$\\delta=10^{-2}$ 是一个软化参数。\n\n哈密顿运动方程为 $\\dot{x}_i = \\partial H / \\partial p_i$ 和 $\\dot{p}_i = -\\partial H / \\partial x_i$。由此可得：\n$$\n\\dot{x}_i \\;=\\; p_i\n$$\n$$\n\\dot{p}_1 \\;=\\; -\\frac{\\partial V}{\\partial x_1} \\;=\\; -\\frac{\\mathrm{d}V}{\\mathrm{d}r}\\frac{\\partial r}{\\partial x_1} \\;=\\; -\\frac{\\mathrm{d}V}{\\mathrm{d}r}(-1) \\;=\\; \\frac{\\mathrm{d}V}{\\mathrm{d}r}\n$$\n$$\n\\dot{p}_2 \\;=\\; -\\frac{\\partial V}{\\partial x_2} \\;=\\; -\\frac{\\mathrm{d}V}{\\mathrm{d}r}\\frac{\\partial r}{\\partial x_2} \\;=\\; -\\frac{\\mathrm{d}V}{\\mathrm{d}r}(1) \\;=\\; -\\frac{\\mathrm{d}V}{\\mathrm{d}r}\n$$\n势能对间距 $r$ 的导数为：\n$$\n\\frac{\\mathrm{d}V}{\\mathrm{d}r} \\;=\\; -12\\,r\\,(r^2+\\delta^2)^{-7}\n$$\n由于质量是单位量，加速度为 $a_i = \\dot{p}_i$。因此：$a_1(r) = -12\\,r\\,(r^2+\\delta^2)^{-7}$ 且 $a_2(r) = 12\\,r\\,(r^2+\\delta^2)^{-7}$。\n这些运动方程从初始状态 $(x_1(0), x_2(0), v_1(0), v_2(0)) = (-2.0, 2.0, 0.8, -0.8)$ 开始进行数值积分，直到最终时间 $T=8.0$。\n\n两种数值积分方法的实现如下：\n\n1.  **速度Verlet算法**：这是一种几何积分器，具体来说是一种二阶辛方法，它也是时间可逆的。它对于哈密顿系统的关键特性是能够长期保持一个附近的“影子”哈密顿量守恒，从而防止长期的能量漂移。对于时间步长 $\\Delta t$，状态通过以下三个步骤从时间 $t$推进到 $t+\\Delta t$：\n    1.  将速度更新半步：$v_i(t + \\Delta t/2) = v_i(t) + \\frac{1}{2} a_i(\\mathbf{x}(t)) \\Delta t$。\n    2.  将位置更新一整步：$x_i(t + \\Delta t) = x_i(t) + v_i(t + \\Delta t/2) \\Delta t$。\n    3.  计算新的加速度 $a_i(\\mathbf{x}(t+\\Delta t))$ 并为后半步更新速度：$v_i(t + \\Delta t) = v_i(t + \\Delta t/2) + \\frac{1}{2} a_i(\\mathbf{x}(t + \\Delta t)) \\Delta t$。\n\n2.  **经典四阶龙格-库塔 (RK4) 算法**：这是一种广泛使用的高精度、通用积分器。它不是辛的，也不是时间可逆的。对于给定的步长，它通常在短期积分中表现出优越的准确性，但在哈密顿系统的长期模拟中会遭受系统性能量漂移。对于常微分方程组 $\\dot{\\mathbf{y}} = \\mathbf{f}(t, \\mathbf{y})$，其中状态向量为 $\\mathbf{y} = (x_1, x_2, v_1, v_2)^T$，从 $\\mathbf{y}_n$ 到 $\\mathbf{y}_{n+1}$ 的更新为：\n    $$\n    \\mathbf{k}_1 = \\mathbf{f}(t_n, \\mathbf{y}_n)\n    $$\n    $$\n    \\mathbf{k}_2 = \\mathbf{f}(t_n + \\frac{\\Delta t}{2}, \\mathbf{y}_n + \\frac{\\Delta t}{2}\\mathbf{k}_1)\n    $$\n    $$\n    \\mathbf{k}_3 = \\mathbf{f}(t_n + \\frac{\\Delta t}{2}, \\mathbf{y}_n + \\frac{\\Delta t}{2}\\mathbf{k}_2)\n    $$\n    $$\n    \\mathbf{k}_4 = \\mathbf{f}(t_n + \\Delta t, \\mathbf{y}_n + \\Delta t \\mathbf{k}_3)\n    $$\n    $$\n    \\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{\\Delta t}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n    $$\n    这里，导数函数为 $\\mathbf{f}(\\mathbf{y}) = (v_1, v_2, a_1(x_1,x_2), a_2(x_1,x_2))^T$。\n\n对于每种积分器和每个指定的时间步长 $\\Delta t \\in \\{0.02, 0.005, 0.0005\\}$，计算四个诊断量：\n- **绝对末端能量误差**：$|H(T) - H(0)|$。对于辛积分器，这个值预计会很小，但可能不是最小值，因为误差是振荡的。对于 RK4，这个误差预计会显示出漂移，随时间增长。\n- **最大相对能量误差**：$\\max_{0 \\le t \\le T} |H(t) - H(0)| / |H(0)|$。该值测量整个轨迹上的能量峰值偏差。\n- **速度交换误差**：$E_{\\mathrm{swap}} = \\sqrt{(v_1(T) - v_1^\\star)^2 + (v_2(T) - v_2^\\star)^2}$，其中 $(v_1^\\star, v_2^\\star)=(-0.8, 0.8)$ 是理想弹性碰撞的预期末端速度。该度量量化了相空间轨迹的准确性。\n- **时间可逆性误差**：$E_{\\mathrm{rev}}$。通过向前积分到时间 $T$，然后使用负步长 $-\\Delta t$ 向后积分到时间 $0$ 来计算。误差是最终状态与初始状态偏差的范数。像Verlet这样的时间可逆算法应该产生非常小的误差，接近机器精度，而非可逆算法如 RK4 将显示一个随 $\\Delta t$ 变化的显著误差。\n\n根据这些原则进行计算，并按规定汇总结果。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the two-particle collision problem using Velocity Verlet and RK4 integrators.\n    \"\"\"\n    \n    # System parameters in reduced units\n    m = 1.0\n    epsilon = 1.0\n    sigma = 1.0\n    delta = 1.0e-2\n\n    # Initial conditions\n    x1_0, x2_0 = -2.0, 2.0\n    v1_0, v2_0 = 0.8, -0.8\n    initial_state = np.array([x1_0, x2_0, v1_0, v2_0])\n\n    # Simulation parameters\n    T_final = 8.0\n    test_dts = [0.02, 0.005, 0.0005]\n    \n    v1_star, v2_star = -0.8, 0.8\n\n    # Helper functions\n    def get_potential(r):\n        return (r**2 + delta**2)**(-6)\n\n    def get_accelerations(x1, x2):\n        r = x2 - x1\n        common_factor = -12.0 * r * (r**2 + delta**2)**(-7.0)\n        a1 = common_factor / m\n        a2 = -common_factor / m\n        return a1, a2\n\n    def get_hamiltonian(state):\n        x1, x2, v1, v2 = state\n        kinetic = 0.5 * m * (v1**2 + v2**2)\n        potential = get_potential(x2 - x1)\n        return kinetic + potential\n\n    def step_verlet(state, dt):\n        x1, x2, v1, v2 = state\n        a1_t, a2_t = get_accelerations(x1, x2)\n        \n        v1_half = v1 + 0.5 * a1_t * dt\n        v2_half = v2 + 0.5 * a2_t * dt\n        \n        x1_new = x1 + v1_half * dt\n        x2_new = x2 + v2_half * dt\n        \n        a1_t_dt, a2_t_dt = get_accelerations(x1_new, x2_new)\n        \n        v1_new = v1_half + 0.5 * a1_t_dt * dt\n        v2_new = v2_half + 0.5 * a2_t_dt * dt\n        \n        return np.array([x1_new, x2_new, v1_new, v2_new])\n        \n    def f_ode(state):\n        x1, x2, v1, v2 = state\n        a1, a2 = get_accelerations(x1, x2)\n        return np.array([v1, v2, a1, a2])\n\n    def step_rk4(state, dt):\n        k1 = f_ode(state)\n        k2 = f_ode(state + 0.5 * dt * k1)\n        k3 = f_ode(state + 0.5 * dt * k2)\n        k4 = f_ode(state + dt * k3)\n        return state + (dt / 6.0) * (k1 + 2*k2 + 2*k3 + k4)\n\n    def run_simulation(stepper, dt):\n        num_steps = int(round(T_final / dt))\n        state = np.copy(initial_state)\n        \n        H0 = get_hamiltonian(state)\n        max_rel_H_err = 0.0\n\n        for _ in range(num_steps):\n            state = stepper(state, dt)\n            H_t = get_hamiltonian(state)\n            rel_H_err = abs(H_t - H0) / abs(H0)\n            if rel_H_err > max_rel_H_err:\n                max_rel_H_err = rel_H_err\n        \n        H_T = get_hamiltonian(state)\n        abs_term_H_err = abs(H_T - H0)\n        \n        v1_T, v2_T = state[2], state[3]\n        swap_err = np.sqrt((v1_T - v1_star)**2 + (v2_T - v2_star)**2)\n\n        # Time-reversibility test\n        state_fwd = np.copy(state) # state at T from forward run\n        state_bwd = np.copy(state_fwd)\n        for _ in range(num_steps):\n            state_bwd = stepper(state_bwd, -dt)\n        \n        rev_err = np.linalg.norm(state_bwd - initial_state)\n\n        return abs_term_H_err, max_rel_H_err, swap_err, rev_err\n\n    all_results = []\n    for dt in test_dts:\n        verlet_diags = run_simulation(step_verlet, dt)\n        rk4_diags = run_simulation(step_rk4, dt)\n\n        case_results = [\n            verlet_diags[0], rk4_diags[0],\n            verlet_diags[1], rk4_diags[1],\n            verlet_diags[2], rk4_diags[2],\n            verlet_diags[3], rk4_diags[3]\n        ]\n        all_results.append(case_results)\n    \n    # Format output string exactly as required\n    output_str = f\"[{','.join([f'[{\",\".join(map(str, res))}]' for res in all_results])}]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "当系统的几何结构已知时，我们有时可以推导出动力学的精确解，并将其用作一个“完美”的数值积分器。本练习将探讨一个约束在单位球面上的质点运动，这是一个哈密顿系统精确几何流的典型例子。你将实现这个精确的流映射，以体验如何构建一个在理论上能将能量、角动量和几何约束都精确保持到机器精度水平的积分器。",
            "id": "2389083",
            "problem": "给定一个质点在单位球面上的约束运动。设其位置为 $q(t)\\in\\mathbb{R}^3$，速度为 $\\dot{q}(t)\\in\\mathbb{R}^3$。完整约束 (holonomic constraint) 为对所有 $t$ 都有 $q(t)^{\\top}q(t)=1$。质点质量为 $m=1$，且无外部势能。机械能为 $E=\\tfrac{1}{2}\\,\\dot{q}^{\\top}\\dot{q}$。角动量为 $L=q\\times\\dot{q}$。初始速度必须满足 $q(0)^{\\top}\\dot{q}(0)=0$。角度必须以弧度为单位。使用无量纲单位。\n\n任务：编写一个完整的程序，对每个测试用例，使用一个时间积分器将动力学系统推进 $N$ 个大小为 $h$ 的固定步长。该积分器需在每一步都保持约束 $q^{\\top}q=1$，并对此系统保持能量和动量守恒。对于每个测试用例，计算在所有时间步长（包括初始状态）中，以下三种偏差的最大值：\n- 约束偏差 $\\delta_c=\\left|\\lVert q\\rVert-1\\right|$，\n- 能量偏差 $\\delta_e=\\left|E(t)-E(0)\\right|$，\n- 角动量偏差 $\\delta_{\\ell}=\\left\\|L(t)-L(0)\\right\\|$。\n对于每个测试用例，输出一个浮点数，其值为整个轨迹上的 $\\varepsilon=\\max\\{\\delta_c,\\delta_e,\\delta_{\\ell}\\}$。\n\n测试集。使用以下初始条件和参数。所有向量均写为 $\\mathbb{R}^3$ 中的列向量：\n- 测试用例 1 (一般情况)：$$q_0=\\begin{bmatrix}1\\\\0\\\\0\\end{bmatrix}, \\quad \\dot{q}_0=\\begin{bmatrix}0\\\\1\\\\0\\end{bmatrix}, \\quad h=0.01, \\quad N=100。$$\n- 测试用例 2 (零速度边界情况)：$$q_0=\\begin{bmatrix}0\\\\1\\\\0\\end{bmatrix}, \\quad \\dot{q}_0=\\begin{bmatrix}0\\\\0\\\\0\\end{bmatrix}, \\quad h=0.1, \\quad N=50。$$\n- 测试用例 3 (完整旋转)：$$q_0=\\begin{bmatrix}0\\\\0\\\\1\\end{bmatrix}, \\quad \\dot{q}_0=\\begin{bmatrix}\\pi\\\\0\\\\0\\end{bmatrix}, \\quad h=0.2, \\quad N=10。$$\n- 测试用例 4 (斜轴，长时积分)：$$q_0=\\dfrac{1}{\\sqrt{3}}\\begin{bmatrix}1\\\\1\\\\1\\end{bmatrix}, \\quad \\dot{q}_0=s\\,\\dfrac{1}{\\sqrt{2}}\\begin{bmatrix}1\\\\-1\\\\0\\end{bmatrix}, \\quad \\text{其中 } s=0.75, \\quad h=0.037, \\quad N=1000。$$\n\n最终输出格式。您的程序应生成单行输出，其中包含按测试集顺序排列的结果，形式为逗号分隔的列表并用方括号括起，例如 $[\\varepsilon_1,\\varepsilon_2,\\varepsilon_3,\\varepsilon_4]$。每个 $\\varepsilon_i$ 必须是一个实数（浮点数）。",
            "solution": "问题陈述已经过分析，并被确定为有效。这是一个计算力学中的适定问题，没有科学或逻辑上的不一致之处。它提供了所有必要的数据，并定义了一个清晰、客观的任务。\n\n所考虑的系统是一个质量为 $m=1$ 的质点，被约束在单位球面上运动，由完整约束 $g(q) = q(t)^{\\top}q(t) - 1 = 0$ 描述。由于没有外部势能，因此拉格朗日量（Lagrangian）纯粹是动能：$L(q, \\dot{q}) = \\frac{1}{2}\\dot{q}^{\\top}\\dot{q}$。运动方程由约束系统的欧拉-拉格朗日方程导出，即 $\\ddot{q} = \\lambda \\nabla_q g(q)$，其中 $\\lambda$ 是一个用于实施约束的拉格朗日乘子。将约束对时间求导两次，得到 $q^{\\top}\\ddot{q} + \\dot{q}^{\\top}\\dot{q} = 0$。代入运动方程并利用 $q^{\\top} q=1$，我们发现拉格朗日乘子为 $\\lambda = -\\dot{q}^{\\top}\\dot{q}$。因此，连续运动方程为：\n$$ \\ddot{q} = -(\\dot{q}^{\\top}\\dot{q}) q $$\n该方程描述了球面上的测地运动。质点的轨迹遵循一个大圆。\n\n问题要求一个能精确守恒以下三个量的时间积分器：\n$1$. 几何约束：$\\lVert q(t) \\rVert = 1$。\n$2$. 机械能：$E(t) = \\frac{1}{2}\\dot{q}(t)^{\\top}\\dot{q}(t) = E(0)$。\n$3$. 角动量向量：$L(t) = q(t) \\times \\dot{q}(t) = L(0)$。\n\n标准的数值积分器，如欧拉法或 Verlet 法，对于该系统不能满足这些严格的守恒性质。有必要基于运动方程的精确解来构造一个积分器。球面上测地流的精确解是一个旋转。\n\n设时间 $t_n$ 的状态为 $(q_n, \\dot{q}_n)$。设速率为 $\\omega_n = \\lVert \\dot{q}_n \\rVert$。能量为 $E_n = \\frac{1}{2}\\omega_n^2$。如果 $\\omega_n = 0$，则质点处于静止状态，并在所有未来时间里保持静止。如果 $\\omega_n > 0$，则运动发生在由正交单位向量 $q_n$ 和 $v_n = \\dot{q}_n / \\omega_n$ 张成的平面内。初始条件 $q(0)^{\\top}\\dot{q}(0)=0$ 确保了这些向量是正交的，并且动力学过程保持此属性，因为 $d/dt(q^{\\top}\\dot{q}) = \\dot{q}^{\\top}\\dot{q} + q^{\\top}\\ddot{q} = \\dot{q}^{\\top}\\dot{q} - q^{\\top}((\\dot{q}^{\\top}\\dot{q})q) = \\|\\dot{q}\\|^2 - \\|\\dot{q}\\|^2 \\|q\\|^2 = 0$。\n\n从 $q_n$ 开始、速度为 $\\dot{q}_n$ 的精确轨迹由罗德里格斯旋转公式给出，描述了沿大圆的旋转：\n$$ q(t_n + \\tau) = q_n \\cos(\\omega_n \\tau) + v_n \\sin(\\omega_n \\tau) $$\n速度是其时间导数：\n$$ \\dot{q}(t_n + \\tau) = -\\omega_n \\sin(\\omega_n \\tau) q_n + \\omega_n \\cos(\\omega_n \\tau) v_n $$\n这个解析解提供了一个从时间 $t_n$ 的状态到时间 $t_{n+1} = t_n + h$ 状态的精确映射。通过将此映射用作我们的积分器，我们在构造上满足了所有的守恒要求，其精度仅受浮点运算精度的限制。\n\n将状态从第 $n$ 步推进到第 $n+1$ 步的算法如下：\n$1$. 给定状态 $(q_n, \\dot{q}_n)$，计算速率 $\\omega_n = \\lVert \\dot{q}_n \\rVert$。\n$2$. 如果 $\\omega_n$ 为零（或在数值上与零无法区分），则质点是静止的。状态不发生改变：$q_{n+1} = q_n$ 且 $\\dot{q}_{n+1} = \\dot{q}_n = 0$。\n$3$. 如果 $\\omega_n > 0$，定义归一化速度向量 $v_n = \\dot{q}_n / \\omega_n$。\n$4$. 计算时间步长 $h$ 的旋转角度：$\\theta = \\omega_n h$。\n$5$. 使用精确解映射更新位置和速度：\n$$ q_{n+1} = q_n \\cos(\\theta) + v_n \\sin(\\theta) $$\n$$ \\dot{q}_{n+1} = -\\omega_n \\sin(\\theta) q_n + \\omega_n \\cos(\\theta) v_n $$\n\n该方法将为每个测试用例实现。将生成一个包含 $N+1$ 个状态（从 $t=0$ 到 $t=Nh$）的轨迹。对于轨迹中的每个状态 $(q_k, \\dot{q}_k)$，将计算偏差 $\\delta_c = |\\lVert q_k \\rVert-1|$、$\\delta_e = |E_k - E_0|$ 和 $\\delta_{\\ell} = \\lVert L_k - L_0 \\rVert$。每个测试用例的最终结果 $\\varepsilon$ 将是这三种偏差在整个轨迹上的最大值。任何非零的 $\\varepsilon$ 值都将仅归因于浮点算术误差，因为所选的积分器是解析精确的。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of integrating the motion of a point mass on a unit sphere\n    using an energy-momentum conserving integrator and calculating deviations.\n    \"\"\"\n    # Test suite definition\n    # Format: (q0, v0, h, N) where q0 and v0 are lists.\n    test_cases = [\n        (\n            [1.0, 0.0, 0.0],\n            [0.0, 1.0, 0.0],\n            0.01,\n            100\n        ),\n        (\n            [0.0, 1.0, 0.0],\n            [0.0, 0.0, 0.0],\n            0.1,\n            50\n        ),\n        (\n            [0.0, 0.0, 1.0],\n            [np.pi, 0.0, 0.0],\n            0.2,\n            10\n        ),\n        (\n            [1/np.sqrt(3), 1/np.sqrt(3), 1/np.sqrt(3)],\n            [0.75/np.sqrt(2), -0.75/np.sqrt(2), 0.0],\n            0.037,\n            1000\n        )\n    ]\n\n    results = []\n\n    for case in test_cases:\n        q0_list, v0_list, h, N = case\n        q0 = np.array(q0_list, dtype=np.float64)\n        v0 = np.array(v0_list, dtype=np.float64)\n\n        # Store trajectory of positions and velocities\n        qs = [q0]\n        vs = [v0]\n\n        q_curr = q0\n        v_curr = v0\n\n        # Time integration loop\n        for _ in range(N):\n            omega = np.linalg.norm(v_curr)\n\n            # Epsilon for checking if omega is close to zero\n            if omega < np.finfo(float).eps:\n                q_next = q_curr\n                v_next = v_curr\n            else:\n                unit_v = v_curr / omega\n                theta = h * omega\n                \n                cos_theta = np.cos(theta)\n                sin_theta = np.sin(theta)\n\n                # Exact flow map for geodesic motion on a sphere\n                q_next = q_curr * cos_theta + unit_v * sin_theta\n                v_next = -omega * sin_theta * q_curr + omega * cos_theta * unit_v\n            \n            qs.append(q_next)\n            vs.append(v_next)\n            q_curr = q_next\n            v_curr = v_next\n\n        # Calculate initial conserved quantities\n        E0 = 0.5 * np.dot(v0, v0)\n        L0 = np.cross(q0, v0)\n\n        max_delta_c = 0.0\n        max_delta_e = 0.0\n        max_delta_l = 0.0\n\n        # Calculate maximum deviations over the trajectory\n        for i in range(N + 1):\n            q_i = qs[i]\n            v_i = vs[i]\n\n            # Constraint deviation\n            delta_c = np.abs(np.linalg.norm(q_i) - 1.0)\n\n            # Energy deviation\n            E_i = 0.5 * np.dot(v_i, v_i)\n            delta_e = np.abs(E_i - E0)\n            \n            # Angular momentum deviation\n            L_i = np.cross(q_i, v_i)\n            delta_l = np.linalg.norm(L_i - L0)\n\n            if delta_c > max_delta_c:\n                max_delta_c = delta_c\n            if delta_e > max_delta_e:\n                max_delta_e = delta_e\n            if delta_l > max_delta_l:\n                max_delta_l = delta_l\n        \n        epsilon = max(max_delta_c, max_delta_e, max_delta_l)\n        results.append(epsilon)\n\n    # Format and print the final output\n    print(f\"[{','.join(f'{r:.17e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "对于复杂系统，推导精确的流映射往往是不现实的。本练习介绍了一种强大而通用的替代方案：投影方法。你将首先使用一个简单的非守恒积分器（前向欧拉法）进行“预测”，然后增加一个“校正”步骤，将预测结果投影回正确的能量恒定面上，从而强制实现能量守恒。这个过程将揭示在计算成本与守恒精度之间进行权衡的实用策略。",
            "id": "2389046",
            "problem": "考虑一个一维哈密顿系统，其广义坐标为 $q(t)$，动量为 $p(t)$，由以下二次哈密顿量给出\n$$\nH(q,p) = \\frac{p^2}{2 m} + \\frac{k}{2} q^2,\n$$\n其中 $m > 0$ 和 $k > 0$ 是常数。其正则运动方程为\n$$\n\\dot{q} = \\frac{\\partial H}{\\partial p} = \\frac{p}{m}, \\qquad \\dot{p} = -\\frac{\\partial H}{\\partial q} = -k q.\n$$\n令 $H_0 = H(q(0), p(0))$ 表示初始能量。您将比较在有限时间区间 $[0, T]$ 内，使用均匀步长 $h$ 的两种时间推进格式，其中如果使用三角函数，所有角度必须以弧度为单位。\n\n方案 A (朴素显式积分器)：使用前向欧拉法，从 $(q_n, p_n)$ 生成中间状态 $(q_{n+1}^{\\star}, p_{n+1}^{\\star})$ 如下\n$$\nq_{n+1}^{\\star} = q_n + h \\frac{p_n}{m}, \\qquad p_{n+1}^{\\star} = p_n - h k q_n.\n$$\n\n方案 B (能量投影显式积分器)：从相同的前向欧拉中间状态 $(q_{n+1}^{\\star}, p_{n+1}^{\\star})$ 出发，通过将其替换为以下形式的校正状态 $(q_{n+1}, p_{n+1})$ 来施加能量约束\n$$\nq_{n+1} = q_{n+1}^{\\star} + \\alpha \\, \\frac{\\partial H}{\\partial q}(q_{n+1}^{\\star}, p_{n+1}^{\\star}), \\qquad\np_{n+1} = p_{n+1}^{\\star} + \\alpha \\, \\frac{\\partial H}{\\partial p}(q_{n+1}^{\\star}, p_{n+1}^{\\star}),\n$$\n其中标量 $\\alpha \\in \\mathbb{R}$ 的选择需满足\n$$\nH(q_{n+1}, p_{n+1}) = H_0.\n$$\n这在每一步都为 $\\alpha$ 定义了一个一维代数方程，必须精确求解。\n\n精度度量：对于给定的 $T$ 和 $h$，令 $N = T / h \\in \\mathbb{N}$。从相同的初始条件 $(q_0, p_0)$ 出发，对两种方案演化 $N$ 步，以获得终端状态 $(q^{A}(T), p^{A}(T))$ 和 $(q^{B}(T), p^{B}(T))$。对于方案 $X \\in \\{A,B\\}$，其终端状态误差定义为\n$$\nE_X = \\sqrt{\\left(q^{X}(T) - q_{\\text{exact}}(T)\\right)^2 + \\left(p^{X}(T) - p_{\\text{exact}}(T)\\right)^2},\n$$\n其中 $(q_{\\text{exact}}(t), p_{\\text{exact}}(t))$ 表示哈密顿系统的精确解，并且必须使用弧度进行计算。\n\n成本模型：按如下方式计算计算成本。在方案 A 中，每个时间步计为一次导数求值，总成本为 $C_A = N$。在方案 B 中，每个时间步包含一次导数求值和一次针对 $\\alpha$ 的标量非线性求解，后者计为一个额外单位，因此总成本为 $C_B = 2 N$。\n\n任务：\n- 实现指定的两种方案及投影。\n- 对每个测试案例，计算 $(E_A, E_B, C_A, C_B)$。\n\n测试套件：\n- 案例 1 (理想情况)：$m = 1$, $k = 1$, $q_0 = 1$, $p_0 = 0$, $T = 1$, $h = 0.05$。\n- 案例 2 (小步长边界)：$m = 1$, $k = 1$, $q_0 = 1$, $p_0 = 0$, $T = 1$, $h = 0.005$。\n- 案例 3 (动能初始条件)：$m = 1$, $k = 1$, $q_0 = 0$, $p_0 = 1$, $T = 1$, $h = 0.05$。\n- 案例 4 (更刚性的系统)：$m = 1$, $k = 100$, $q_0 = 1$, $p_0 = 0$, $T = 0.5$, $h = 0.002$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含四个测试案例的汇总结果，形式为列表的列表。每个内部列表为该测试案例的 $[E_A, E_B, C_A, C_B]$，其中 $E_A$ 和 $E_B$ 是四舍五入到八位小数的浮点数，$C_A$ 和 $C_B$ 是整数。输出中不应出现任何单位。该行必须采用以下形式\n$$\n\\big[ [$E_A^{(1)}$, $E_B^{(1)}$, $C_A^{(1)}$, $C_B^{(1)}$], [$E_A^{(2)}$, $E_B^{(2)}$, $C_A^{(2)}$, $C_B^{(2)}$], [$E_A^{(3)}$, $E_B^{(3)}$, $C_A^{(3)}$, $C_B^{(3)}$], [$E_A^{(4)}$, $E_B^{(4)}$, $C_A^{(4)}$, $C_B^{(4)}$] \\big].\n$$",
            "solution": "任务是比较两种用于简谐振子的数值积分格式与其精确解析解。\n\n**1. 精确解析解**\n\n运动方程为 $\\dot{q} = p/m$ 和 $\\dot{p} = -kq$。对第一个方程关于时间 $t$ 求导，得到 $\\ddot{q} = \\dot{p}/m$。代入第二个方程，得到简谐振子的二阶常微分方程：\n$$\n\\ddot{q} + \\frac{k}{m} q = 0.\n$$\n令 $\\omega = \\sqrt{k/m}$ 为角频率。坐标 $q(t)$ 的通解是\n$$\nq(t) = C_1 \\cos(\\omega t) + C_2 \\sin(\\omega t).\n$$\n对应的动量 $p(t) = m\\dot{q}(t)$ 是\n$$\np(t) = m\\omega \\left(-C_1 \\sin(\\omega t) + C_2 \\cos(\\omega t)\\right).\n$$\n常数 $C_1$ 和 $C_2$ 由 $t=0$ 时的初始条件 $(q_0, p_0)$ 确定：\n$$\nq(0) = q_0 \\implies C_1 = q_0,\n$$\n$$\np(0) = p_0 \\implies m\\omega C_2 = p_0 \\implies C_2 = \\frac{p_0}{m\\omega}.\n$$\n因此，在任意时间 $t$ 的精确解是：\n$$\nq_{\\text{exact}}(t) = q_0 \\cos(\\omega t) + \\frac{p_0}{m\\omega} \\sin(\\omega t),\n$$\n$$\np_{\\text{exact}}(t) = p_0 \\cos(\\omega t) - m\\omega q_0 \\sin(\\omega t).\n$$\n这个解提供了在最终时间 $T$ 用来评估数值格式的基准。\n\n**2. 数值方案 A：前向欧拉法**\n\n这是一个显式一阶方法。给定时间 $t_n = n h$ 的状态 $(q_n, p_n)$，时间 $t_{n+1}$ 的状态近似为：\n$$\nq_{n+1} = q_n + h \\dot{q}_n = q_n + h \\frac{p_n}{m},\n$$\n$$\np_{n+1} = p_n + h \\dot{p}_n = p_n - h k q_n.\n$$\n该方案易于实现，但众所周知，对于保守系统来说是数值不稳定的，因为它会系统性地增加系统的能量。\n\n**3. 数值方案 B：能量投影欧拉法**\n\n该方案是一种预估-校正方法。\n- **预估步**：使用一步前向欧拉法计算中间状态 $(q_{n+1}^{\\star}, p_{n+1}^{\\star})$，与方案 A 相同：\n  $$q_{n+1}^{\\star} = q_n + h \\frac{p_n}{m}, \\qquad p_{n+1}^{\\star} = p_n - h k q_n.$$\n- **校正步**：然后将这个中间状态投影到由初始能量 $H_0$ 定义的恒定能量曲面上。校正沿着在中间点评估的哈密顿量梯度 $\\nabla H(q_{n+1}^{\\star}, p_{n+1}^{\\star})$ 的方向进行。偏导数为：\n  $$\n  \\frac{\\partial H}{\\partial q}(q_{n+1}^{\\star}, p_{n+1}^{\\star}) = k q_{n+1}^{\\star}, \\qquad\n  \\frac{\\partial H}{\\partial p}(q_{n+1}^{\\star}, p_{n+1}^{\\star}) = \\frac{p_{n+1}^{\\star}}{m}.\n  $$\n校正后的状态 $(q_{n+1}, p_{n+1})$ 由下式给出：\n$$\nq_{n+1} = q_{n+1}^{\\star} + \\alpha (k q_{n+1}^{\\star}) = q_{n+1}^{\\star} (1 + \\alpha k),\n$$\n$$\np_{n+1} = p_{n+1}^{\\star} + \\alpha \\left(\\frac{p_{n+1}^{\\star}}{m}\\right) = p_{n+1}^{\\star} \\left(1 + \\frac{\\alpha}{m}\\right),\n$$\n其中标量参数 $\\alpha$ 通过施加能量守恒约束 $H(q_{n+1}, p_{n+1}) = H_0$ 来确定：\n$$\n\\frac{p_{n+1}^2}{2m} + \\frac{k}{2} q_{n+1}^2 = H_0.\n$$\n代入 $q_{n+1}$ 和 $p_{n+1}$ 的表达式得到：\n$$\n\\frac{1}{2m} \\left[p_{n+1}^{\\star} \\left(1 + \\frac{\\alpha}{m}\\right)\\right]^2 + \\frac{k}{2} \\left[q_{n+1}^{\\star} (1 + \\alpha k)\\right]^2 = H_0.\n$$\n展开并按 $\\alpha$ 的幂次收集项，得到一个二次方程 $C_2 \\alpha^2 + C_1 \\alpha + C_0 = 0$，其中：\n- $C_2 = \\frac{1}{2}\\left[\\frac{(p_{n+1}^{\\star})^2}{m^3} + k^3 (q_{n+1}^{\\star})^2\\right]$\n- $C_1 = \\frac{(p_{n+1}^{\\star})^2}{m^2} + k^2(q_{n+1}^{\\star})^2$\n- $C_0 = \\left[\\frac{(p_{n+1}^{\\star})^2}{2m} + \\frac{k}{2}(q_{n+1}^{\\star})^2\\right] - H_0 = H(q_{n+1}^{\\star}, p_{n+1}^{\\star}) - H_0$\n\n必须解这个关于 $\\alpha$ 的二次方程。对于小时间步长 $h$，中间状态 $(q_{n+1}^{\\star}, p_{n+1}^{\\star})$ 接近真实轨迹，所以 $H(q_{n+1}^{\\star}, p_{n+1}^{\\star})$ 接近 $H_0$。因此，$C_0$ 很小，校正参数 $\\alpha$ 也应该很小。我们必须选择与这个小校正量相对应的二次方程的根。一种数值上稳定的计算较小根的方法由以下公式给出：\n$$\n\\alpha = \\frac{2 C_0}{-C_1 - \\operatorname{sgn}(C_1) \\sqrt{C_1^2 - 4 C_2 C_0}}.\n$$\n由于 $C_1$ 是平方和，它是非负的（$C_1 \\ge 0$）。因此，我们使用：\n$$\n\\alpha = \\frac{2 C_0}{-C_1 - \\sqrt{C_1^2 - 4 C_2 C_0}}.\n$$\n一旦找到 $\\alpha$，就将状态更新为 $(q_{n+1}, p_{n+1})$。此过程保证了在每一步中，数值解的能量都精确地保持在 $H_0$（在机器精度范围内）。\n\n**4. 度量与实现**\n\n对于每个测试案例，系统使用方案 A 和方案 B 从 $(q_0,p_0)$ 在区间 $[0, T]$ 上以步长 $h$ 演化总共 $N = T/h$ 步。\n得到最终状态 $(q^A(T), p^A(T))$ 和 $(q^B(T), p^B(T))$。\n计算精确状态 $(q_{\\text{exact}}(T), p_{\\text{exact}}(T))$。\n终端误差 $E_A$ 和 $E_B$ 作为数值解最终状态与精确解最终状态在相空间中的欧几里得距离来计算。\n计算成本报告为 $C_A = N$ 和 $C_B = 2N$。\n实现过程将精确遵循此方法，应用于所有 4 个指定的测试案例。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the given problem by implementing and comparing two numerical integration schemes\n    for a simple harmonic oscillator.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: m=1, k=1, q0=1, p0=0, T=1, h=0.05\n        (1.0, 1.0, 1.0, 0.0, 1.0, 0.05),\n        # Case 2: m=1, k=1, q0=1, p0=0, T=1, h=0.005\n        (1.0, 1.0, 1.0, 0.0, 1.0, 0.005),\n        # Case 3: m=1, k=1, q0=0, p0=1, T=1, h=0.05\n        (1.0, 1.0, 0.0, 1.0, 1.0, 0.05),\n        # Case 4: m=1, k=100, q0=1, p0=0, T=0.5, h=0.002\n        (1.0, 100.0, 1.0, 0.0, 0.5, 0.002),\n    ]\n\n    results = []\n    for case in test_cases:\n        m, k, q0, p0, T, h = case\n        \n        N = int(round(T / h))\n        omega = np.sqrt(k / m)\n        H0 = p0**2 / (2 * m) + k * q0**2 / 2\n\n        # Scheme A: Forward Euler\n        q_a, p_a = q0, p0\n        for _ in range(N):\n            q_next = q_a + h * p_a / m\n            p_next = p_a - h * k * q_a\n            q_a, p_a = q_next, p_next\n\n        # Scheme B: Energy-Projected Euler\n        q_b, p_b = q0, p0\n        for _ in range(N):\n            # Predictor step (Forward Euler)\n            q_star = q_b + h * p_b / m\n            p_star = p_b - h * k * q_b\n            \n            # Special case: if the intermediate state is the origin, no projection needed or possible\n            if q_star == 0 and p_star == 0:\n                q_b, p_b = q_star, p_star\n                continue\n\n            # Corrector step (Projection)\n            # Solve C2 * alpha^2 + C1 * alpha + C0 = 0 for alpha\n            H_star = p_star**2 / (2 * m) + k * q_star**2 / 2\n            \n            C0 = H_star - H0\n            C1 = p_star**2 / m**2 + k**2 * q_star**2\n            C2 = 0.5 * (p_star**2 / m**3 + k**3 * q_star**2)\n\n            # Use numerically stable quadratic formula for the root near zero\n            discriminant = C1**2 - 4 * C2 * C0\n            # The discriminant should be non-negative for a valid physical projection\n            if discriminant < 0:\n                # Handle potential floating point inaccuracies making it slightly negative\n                discriminant = 0\n                \n            sqrt_disc = np.sqrt(discriminant)\n            \n            # Denominator should not be zero unless C1 and discriminant are both zero\n            # which is unlikely in a dynamic simulation.\n            denominator = -C1 - sqrt_disc\n            if abs(denominator) < 1e-15:\n                 alpha = 0 # No correction needed, or C0 is also 0\n            else:\n                 alpha = 2 * C0 / denominator\n\n            q_next = q_star * (1 + alpha * k)\n            p_next = p_star * (1 + alpha / m)\n            q_b, p_b = q_next, p_next\n\n        # Exact solution at time T\n        q_exact_T = q0 * np.cos(omega * T) + (p0 / (m * omega)) * np.sin(omega * T)\n        p_exact_T = p0 * np.cos(omega * T) - m * omega * q0 * np.sin(omega * T)\n\n        # Accuracy Metric\n        E_A = np.sqrt((q_a - q_exact_T)**2 + (p_a - p_exact_T)**2)\n        E_B = np.sqrt((q_b - q_exact_T)**2 + (p_b - p_exact_T)**2)\n\n        # Cost Model\n        C_A = N\n        C_B = 2 * N\n\n        results.append([round(E_A, 8), round(E_B, 8), C_A, C_B])\n\n    # Format the output string as per requirements\n    inner_strings = []\n    for res in results:\n        inner_strings.append(f\"[{res[0]:.8f},{res[1]:.8f},{res[2]},{res[3]}]\")\n    \n    final_output = f\"[[{','.join(inner_strings)}]]\"\n    # A quick correction on the output format to match the example precisely.\n    # The example is `[ [..], [..], .. ]`, not `[[ [..], [..] ]]`\n    final_output = f\"[{','.join(inner_strings)}]\"\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}