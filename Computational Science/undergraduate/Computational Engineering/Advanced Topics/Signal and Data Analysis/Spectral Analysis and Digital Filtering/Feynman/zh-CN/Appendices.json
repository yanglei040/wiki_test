{
    "hands_on_practices": [
        {
            "introduction": "我们如何才能高效地判断一段录音中是否存在特定的音调，例如电话键盘发出的DTMF信号？我们无需使用完整的快速傅里叶变换（$FFT$）来计算整个频谱，而是可以直接应用离散时间傅里叶变换（$DTFT$）的定义，仅计算信号在目标频率点上的能量。这项练习  阐释了这种“精确打击”的方法，它不仅是 Goertzel 等高效算法背后的核心原理，也让学生从根本上理解傅里叶变换的实际作用——即衡量特定频率成分的强度。",
            "id": "2436633",
            "problem": "你需要编写一个完整的、可运行的程序，对于一组给定的离散时间信号和参数，通过将离散时间傅里叶变换在单个角频率下的平方幅值与预设阈值进行比较，来判断指定的频率分量是否存在。所有推理必须基于第一性原理。频率必须以赫兹（Hz）表示，时长以秒（s）表示，相位以弧度（rad）表示。当涉及随机噪声时，它必须是指定方差的零均值、白高斯噪声，并使用固定的种子 $0$ 生成以确保确定性。\n\n对于每个测试用例，你必须：\n1. 在采样频率为 $f_s$ Hz 的条件下，合成一个长度为 $N$ 个样本的实值离散时间信号 $x[n]$。该信号是一系列具有给定振幅、频率和相位的实正弦波之和，再加上具有指定方差的加性噪声。\n2. 设目标频率为 $f_t$ Hz，对应的角频率为 $\\omega_t = 2\\pi f_t / f_s$ 弧度/样本。\n3. 计算 $x[n]$ 在 $\\omega_t$ 处的离散时间傅里叶变换的平方幅值，即等于该单频率下变换值的复数量的平方幅值。\n4. 将这个非负实数与给定的阈值 $\\Theta$ 进行比较。当且仅当计算值严格大于 $\\Theta$ 时，判定该频率分量存在。\n\n你的程序必须处理以下所有测试用例，并输出一行包含方括号内的、逗号分隔的布尔值列表，其顺序与测试用例的顺序相同（例如， $[$True,False,True$]$）。\n\n测试套件（除非另有说明，所有相位均为 $0$ 弧度）：\n- 案例 A（理想情况，精确匹配，整周期）：$f_s = 8000$ Hz，$N = 800$，目标频率 $f_t = 800$ Hz。信号分量：一个振幅为 $0.5$、频率为 $800$ Hz 的余弦波。噪声方差 $0$。阈值 $\\Theta = 10000$。\n- 案例 B（不存在情况，正交音调，整周期）：$f_s = 8000$ Hz，$N = 800$，目标频率 $f_t = 800$ Hz。信号分量：一个振幅为 $0.5$、频率为 $1000$ Hz 的余弦波。噪声方差 $0$。阈值 $\\Theta = 10000$。\n- 案例 C（频率相近，短窗口，无噪声）：$f_s = 8000$ Hz，$N = 205$，目标频率 $f_t = 697$ Hz。信号分量：一个振幅为 $0.5$、频率为 $700$ Hz 的余弦波。噪声方差 $0$。阈值 $\\Theta = 2700$。\n- 案例 D（直流分量）：$f_s = 4000$ Hz，$N = 400$，目标频率 $f_t = 0$ Hz。信号分量：一个振幅为 $0.3$ 的恒定偏移。噪声方差 $0$。阈值 $\\Theta = 3600$。\n- 案例 E（Nyquist 频率分量）：$f_s = 4000$ Hz，$N = 400$，目标频率 $f_t = 2000$ Hz。信号分量：一个振幅为 $0.4$、频率为 $2000$ Hz 的余弦波。噪声方差 $0$。阈值 $\\Theta = 6400$。\n- 案例 F（带噪声的短窗口，精确匹配，整周期）：$f_s = 8000$ Hz，$N = 80$，目标频率 $f_t = 1000$ Hz。信号分量：一个振幅为 $0.4$、频率为 $1000$ Hz 的余弦波。噪声方差 $0.01$。阈值 $\\Theta = 128$。\n\n任何相位的角度单位都是弧度。你的程序应生成一行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如， $[$True,False,True$]$）。",
            "solution": "此问题要求判断离散时间信号中是否存在特定的频率分量。该方法基于数字信号处理的一个基础工具：离散时间傅里叶变换（DTFT）。其步骤是在单个目标频率处计算 DTFT 的平方幅值，并将此能量值与给定阈值进行比较。该问题是适定的且科学上合理的，允许直接进行解析和计算求解。\n\n我们首先建立数学框架。\n\n一个定义在 $n \\in \\{0, 1, \\dots, N-1\\}$ 上的实值离散时间信号 $x[n]$，被合成为一个确定性信号 $s[n]$ 和一个加性噪声分量 $w[n]$ 之和。\n$$x[n] = s[n] + w[n]$$\n确定性部分 $s[n]$ 是 $M$ 个正弦分量的叠加：\n$$s[n] = \\sum_{k=1}^{M} A_k \\cos(2\\pi \\frac{f_k}{f_s} n + \\phi_k) = \\sum_{k=1}^{M} A_k \\cos(\\omega_k n + \\phi_k)$$\n其中 $A_k$、$f_k$ 和 $\\phi_k$ 分别是第 $k$ 个正弦波的振幅、频率（单位 Hz）和相位（单位 弧度）。采样频率为 $f_s$（单位 Hz），$\\omega_k = 2\\pi f_k / f_s$ 是角频率（单位 弧度/样本）。\n噪声 $w[n]$ 是一个零均值、白高斯过程，其方差为 $\\sigma^2$，记作 $w[n] \\sim \\mathcal{N}(0, \\sigma^2)$。\n\n信号 $x[n]$ 的离散时间傅里叶变换是一个关于频率 $\\omega$ 的复值函数，由下式给出：\n$$X(e^{j\\omega}) = \\sum_{n=0}^{N-1} x[n] e^{-j\\omega n}$$\n该变换将 $N$ 点时域信号 $x[n]$ 映射到其频域表示。为了测试目标频率 $f_t$ （或角频率 $\\omega_t = 2\\pi f_t / f_s$）处的频率分量是否存在，我们在 $\\omega = \\omega_t$ 处计算 DTFT：\n$$X(e^{j\\omega_t}) = \\sum_{n=0}^{N-1} x[n] e^{-j\\omega_t n}$$\n这个复数的平方幅值 $|X(e^{j\\omega_t})|^2$ 代表了信号在频率 $\\omega_t$ 处的能量。判定规则是：当且仅当该值严格大于指定的阈值 $\\Theta$ 时，判定频率分量存在：\n$$\\text{Presence} \\iff |X(e^{j\\omega_t})|^2 > \\Theta$$\n\n根据 DTFT 的线性性质，我们可以写出：\n$$X(e^{j\\omega_t}) = S(e^{j\\omega_t}) + W(e^{j\\omega_t})$$\n其中 $S(e^{j\\omega_t})$ 和 $W(e^{j\\omega_t})$ 分别是信号分量和噪声分量的 DTFT。每个项都可以进行分析。对于单个正弦分量 $s[n] = A \\cos(\\omega_0 n)$，其 DTFT 为：\n$$S(e^{j\\omega}) = \\frac{A}{2} \\left[ \\sum_{n=0}^{N-1} e^{j(\\omega_0 - \\omega)n} + \\sum_{n=0}^{N-1} e^{-j(\\omega_0 + \\omega)n} \\right]$$\n该变换的幅值在 $\\omega = \\omega_0$ 和 $\\omega = -\\omega_0$ 处有尖锐的峰值。如果信号频率 $f_0$ 和样本数 $N$ 使得整数个周期恰好落在观测窗口内（即 $f_0 \\cdot N/f_s = k$，其中 $k$ 为整数），那么 $f_0$ 就是 $N$ 点离散傅里叶变换（DFT）的一个“频率仓中心”（bin center）。在这种特殊情况下，如果我们在 $\\omega_t = \\omega_0$ 处进行测试（且 $\\omega_0$ 不为 $0$ 或 $\\pi$），则幅值达到最大，且 $|S(e^{j\\omega_0})|^2 = (A N/2)^2$。如果我们在另一个频率仓中心 $\\omega_t \\neq \\omega_0$ 处测试，那么由于 DFT 基向量的正交性，$S(e^{j\\omega_t}) = 0$。对于不位于频率仓中心的频率，能量会“泄漏”到相邻频率中，这种现象称为频谱泄漏。\n\n噪声的变换 $W(e^{j\\omega_t}) = \\sum_{n=0}^{N-1} w[n] e^{-j\\omega_t n}$ 是加权高斯随机变量之和。其期望值为 $0$，对于足够大的 $N$，其性质是众所周知。然而，对于使用固定种子的单次实现，它是一个确定性的复数，会加到信号的变换值上。\n\n每个测试用例的计算过程如下：\n1. 定义时间向量 $n = [0, 1, \\dots, N-1]$。\n2. 根据指定的参数，通过对给定的正弦分量求和来合成信号 $s[n]$。\n3. 如果噪声方差 $\\sigma^2 > 0$，则使用以种子 $0$ 初始化的随机数生成器生成噪声向量 $w[n]$。生成器的标准差为 $\\sigma = \\sqrt{\\sigma^2}$。\n4. 形成最终信号 $x[n] = s[n] + w[n]$。\n5. 计算目标角频率 $\\omega_t = 2\\pi f_t / f_s$。\n6. 通过执行求和 $\\sum_{n=0}^{N-1} x[n] e^{-j\\omega_t n}$ 来计算复数 DTFT 值 $X(e^{j\\omega_t})$。\n7. 计算其平方幅值 $|X(e^{j\\omega_t})|^2 = (\\text{Re}\\{X(e^{j\\omega_t})\\})^2 + (\\text{Im}\\{X(e^{j\\omega_t})\\})^2$。\n8. 将结果与阈值 $\\Theta$ 进行比较，以做出最终的布尔决策。\n\n此过程构成了解决该问题的完整算法。实现将针对每个提供的测试用例精确地遵循这些步骤。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the frequency component detection problem for a suite of test cases.\n    \"\"\"\n    \n    # Test cases defined as tuples:\n    # (f_s, N, f_t, components, noise_variance, threshold)\n    # where components is a list of (amplitude, frequency, phase) tuples.\n    test_cases = [\n        # Case A: happy path, exact match, integer cycles\n        (8000, 800, 800, [(0.5, 800, 0)], 0, 10000),\n        # Case B: absence case, orthogonal tone, integer cycles\n        (8000, 800, 800, [(0.5, 1000, 0)], 0, 10000),\n        # Case C: nearby frequency, short window, no noise\n        (8000, 205, 697, [(0.5, 700, 0)], 0, 2700),\n        # Case D: direct current component\n        (4000, 400, 0, [(0.3, 0, 0)], 0, 3600),\n        # Case E: Nyquist frequency component\n        (4000, 400, 2000, [(0.4, 2000, 0)], 0, 6400),\n        # Case F: short window with noise, exact match, integer cycles\n        (8000, 80, 1000, [(0.4, 1000, 0)], 0.01, 128)\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        f_s, N, f_t, components, noise_var, threshold = case\n        \n        # 1. Synthesize the discrete-time signal x[n]\n        \n        # Time vector from n=0 to N-1\n        n = np.arange(N)\n        \n        # Initialize signal s[n] with zeros\n        s_n = np.zeros(N)\n        \n        # Add sinusoidal components\n        for amp, freq, phase in components:\n            # Angular frequency of the component: omega = 2*pi*f/f_s\n            omega_k = 2 * np.pi * freq / f_s\n            s_n += amp * np.cos(omega_k * n + phase)\n            \n        # Add additive white Gaussian noise (AWGN) if specified\n        if noise_var > 0:\n            # Set the seed for reproducibility. It is reset for each case involving noise.\n            np.random.seed(0)\n            std_dev = np.sqrt(noise_var)\n            w_n = np.random.normal(0, std_dev, N)\n            x_n = s_n + w_n\n        else:\n            x_n = s_n\n            \n        # 2. Define the target angular frequency omega_t\n        omega_t = 2 * np.pi * f_t / f_s\n        \n        # 3. Compute the squared magnitude of the DTFT at omega_t\n        \n        # Complex exponential term for the DTFT calculation\n        # exp(-j * omega_t * n)\n        complex_exp = np.exp(-1j * omega_t * n)\n        \n        # DTFT value X(exp(j*omega_t)) = sum(x[n] * exp(-j*omega_t*n))\n        dtft_val = np.sum(x_n * complex_exp)\n        \n        # Squared magnitude\n        squared_magnitude = np.abs(dtft_val)**2\n        \n        # 4. Compare with the threshold and store the boolean result\n        is_present = squared_magnitude > threshold\n        results.append(is_present)\n\n    # Final print statement in the exact required format.\n    # The map(str, ...) converts boolean values True/False to strings \"True\"/\"False\".\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "在掌握了如何检测单一频率后，我们将探索如何利用整个频谱来完成一项强大而普遍的应用：信号去噪。这项实践  将引导你完成一个完整的工作流程：将一个带噪的音频信号变换到频域，通过移除低能量的频率成分对其进行“净化”，然后再将其变换回清晰的时域信号。这个过程直观地展示了频谱分析与滤波的强大能力，揭示了如何在频域中实现那些在时域中难以甚至无法完成的信号操作。",
            "id": "2383381",
            "problem": "设一个离散时间信号定义在一个包含 $N$ 个样本的均匀采样网格上，采样频率为 $F_s$（单位：赫兹）。该网格为 $t_n = \\dfrac{n}{F_s}$，其中 $n \\in \\{0,1,\\dots,N-1\\}$，所有角度均以弧度为单位。考虑一个纯净的音符，其被建模为单位振幅、频率为 $f_0$（单位：赫兹）的单个正弦波 $s_n = \\sin(2\\pi f_0 t_n)$。观测信号是纯净音符与一个由两个正弦波组成的确定性加性噪声之和：\n$$\nx_n = s_n + 0.15\\,\\sin(2\\pi \\cdot 1000\\, t_n) + 0.10\\,\\sin(2\\pi \\cdot 3000\\, t_n).\n$$\n对于序列 $\\{x_n\\}_{n=0}^{N-1}$，定义离散傅里叶变换（DFT）及其逆变换如下：\n$$\nX_k = \\sum_{n=0}^{N-1} x_n\\, e^{-i 2\\pi kn/N},\\quad k=0,1,\\dots,N-1,\n$$\n$$\n\\widehat{x}_n = \\frac{1}{N} \\sum_{k=0}^{N-1} X_k\\, e^{i 2\\pi kn/N},\\quad n=0,1,\\dots,N-1.\n$$\n对于给定的阈值比例 $\\tau \\in [0,1]$，通过将所有幅值低于最大谱幅值 $\\tau$ 倍的系数置零，来定义滤波后的频谱：\n$$\nM = \\max_{0 \\le k \\le N-1} |X_k|,\\qquad\nY_k = \\begin{cases}\nX_k,& \\text{若 } |X_k| \\ge \\tau M,\\\\\n0,& \\text{否则。}\n\\end{cases}\n$$\n滤波后的时域信号由下式给出：\n$$\ny_n = \\frac{1}{N} \\sum_{k=0}^{N-1} Y_k\\, e^{i 2\\pi kn/N}.\n$$\n对于每个测试用例，计算滤波后信号与纯净信号之间的均方根误差（RMSE），\n$$\n\\mathrm{RMSE} = \\sqrt{\\frac{1}{N} \\sum_{n=0}^{N-1} \\left(y_n - s_n\\right)^2},\n$$\n该值是无量纲的。\n\n所有三角函数中的角度参数必须以弧度为单位。频率单位为赫兹。输出不需要其他物理单位。\n\n测试套件：\n- 用例 $1$：$(F_s, N, f_0, \\tau) = (8192,\\ 1024,\\ 440,\\ 0.25)$。\n- 用例 $2$：$(F_s, N, f_0, \\tau) = (8192,\\ 1024,\\ 512,\\ 0.90)$。\n- 用例 $3$：$(F_s, N, f_0, \\tau) = (8192,\\ 1024,\\ 440,\\ 0.00)$。\n- 用例 $4$：$(F_s, N, f_0, \\tau) = (8192,\\ 1024,\\ 2048,\\ 0.75)$。\n\n您的程序必须：\n- 对于每个测试用例，使用相应的 $F_s$、$N$ 和 $f_0$ 值，严格按照上述定义构建 $s_n$ 和 $x_n$。\n- 计算 $x_n$ 的离散傅里叶变换 $X_k$，应用由 $\\tau$ 参数化的频谱阈值规则，计算逆变换得到 $y_n$，然后计算相对于 $s_n$ 的 $\\mathrm{RMSE}$。\n\n最终输出格式：\n- 生成单行输出，其中包含与上述用例相对应的四个 $\\mathrm{RMSE}$ 值。这些值应四舍五入到恰好 $6$ 位小数，并以逗号分隔的列表形式用方括号括起来，例如 $[r_1,r_2,r_3,r_4]$，其中每个 $r_j$ 在小数点后恰好有 $6$ 位数字。",
            "solution": "该问题要求将带噪正弦信号变换到频域，去除相对于最大谱幅值而言幅值较小的频谱分量，然后变换回时域，通过计算相对于纯净信号的均方根误差（RMSE）来评估去噪性能。此过程直接依赖于离散傅里叶变换（DFT）及其逆变换的定义。\n\n从基本定义开始。对于 $N$ 个时间样本 $\\{x_n\\}_{n=0}^{N-1}$，离散傅里叶变换（DFT）为\n$$\nX_k = \\sum_{n=0}^{N-1} x_n\\, e^{-i 2\\pi kn/N},\\quad k=0,1,\\dots,N-1,\n$$\n其逆变换为\n$$\n\\widehat{x}_n = \\frac{1}{N} \\sum_{k=0}^{N-1} X_k\\, e^{i 2\\pi kn/N},\\quad n=0,1,\\dots,N-1.\n$$\nDFT 是一种线性基变换，它将时域序列转换为频率为 $2\\pi k/N$ 的离散复指数之和。对于实数序列，频谱分量以共轭对称对的形式出现，但上述通用形式在所有情况下都成立。\n\n信号模型。纯净信号为 $s_n = \\sin(2\\pi f_0 t_n)$，具有单位振幅和频率 $f_0$，在 $t_n = n/F_s$ 处采样。噪声是确定性的，定义为两个正弦波之和：\n$$\nn_n = 0.15\\,\\sin(2\\pi \\cdot 1000\\, t_n) + 0.10\\,\\sin(2\\pi \\cdot 3000\\, t_n).\n$$\n观测信号是 $x_n = s_n + n_n$。由于 $F_s = 8192$ 且 $N = 1024$，频率分辨率为 $\\Delta f = F_s/N = 8$。所选频率 $f_0 \\in \\{440, 512, 2048\\}$ 以及噪声频率 $1000$ 和 $3000$ 都是 $\\Delta f$ 的整数倍，这确保了在 $N$ 个样本中每个正弦波都完成整数个周期。这使得相应的 DFT 能量集中在精确的频率仓（bin）中，并保证了不同正弦波在有限序列上的正交性。特别地，在用例 3 中，当 $\\tau = 0$ 时，不执行任何滤波，此时相对于纯净信号的 RMSE 等于噪声的均方根值：\n$$\n\\mathrm{RMSE}_{\\tau=0} = \\sqrt{\\frac{1}{N}\\sum_{n=0}^{N-1} n_n^2} = \\sqrt{\\frac{(0.15)^2}{2} + \\frac{(0.10)^2}{2}},\n$$\n因为这些正弦波是正交的，并且 $\\sin^2$ 在整数个周期内的均值为 $1/2$。\n\n滤波规则。给定频谱 $X_k$，定义 $M = \\max_k |X_k|$，并通过仅保留那些满足 $|X_k| \\ge \\tau M$ 的频谱系数来进行阈值处理。滤波后的频谱为\n$$\nY_k = \\begin{cases}\nX_k,& \\text{若 } |X_k| \\ge \\tau M,\\\\\n0,& \\text{否则。}\n\\end{cases}\n$$\n滤波后的时域信号通过逆变换获得：\n$$\ny_n = \\frac{1}{N} \\sum_{k=0}^{N-1} Y_k\\, e^{i 2\\pi kn/N}.\n$$\n去噪性能由均方根误差量化：\n$$\n\\mathrm{RMSE} = \\sqrt{\\frac{1}{N} \\sum_{n=0}^{N-1} (y_n - s_n)^2}.\n$$\n\n高效计算。根据定义直接计算 DFT 及其逆变换的复杂度为 $\\mathcal{O}(N^2)$。当 $N$ 是 $2$ 的幂时，可以通过将求和递归地划分为偶数索引和奇数索引的子序列，并使用旋转因子 $e^{-i 2\\pi k/N}$ 将它们组合起来，从而在 $\\mathcal{O}(N \\log_2 N)$ 时间内完成变换。这是基-2 分治法的原理。令 $x^{(e)}_m = x_{2m}$ 和 $x^{(o)}_m = x_{2m+1}$，其中 $m=0,\\dots,N/2-1$。则\n$$\nX_k = E_k + W_N^k O_k,\\quad X_{k+N/2} = E_k - W_N^k O_k,\\quad k=0,\\dots,N/2-1,\n$$\n其中 $E_k$ 和 $O_k$ 分别是偶数和奇数子序列的 DFT，且 $W_N^k = e^{-i 2\\pi k/N}$。逆变换可以类似地计算，或者通过共轭和缩放来计算：\n$$\n\\mathrm{iDFT}(X)_n = \\frac{1}{N} \\overline{\\mathrm{DFT}(\\overline{X})_n}.\n$$\n\n基于基本原理的实现计划：\n- 对于每个测试用例，构造 $t_n = n/F_s$，$s_n = \\sin(2\\pi f_0 t_n)$，$x_n = s_n + 0.15\\,\\sin(2\\pi \\cdot 1000\\, t_n) + 0.10\\,\\sin(2\\pi \\cdot 3000\\, t_n)$。\n- 对于 $N=1024$，使用基-2 分治法计算 DFT 得到 $X_k$。\n- 计算 $M = \\max_k |X_k|$ 并根据阈值规则 $|X_k| \\ge \\tau M$ 定义 $Y_k$。\n- 通过逆变换计算 $y_n$ 并提取其实部（虚部是数值舍入误差）。\n- 按定义计算 $\\mathrm{RMSE}$。\n- 将每个 $\\mathrm{RMSE}$ 四舍五入到恰好 $6$ 位小数，并将四个结果以单列表 $[r_1,r_2,r_3,r_4]$ 的形式打印。\n\n该过程为每个测试用例生成一组四个浮点数值，量化了在给定的确定性噪声下，阈值参数 $\\tau$ 和音符频率 $f_0$ 如何影响去噪质量。$\\tau = 0$ 的情况再现了未滤波的基线，而较大的 $\\tau$ 值会抑制较弱的频谱内容，并且对于这些频率仓对齐的正弦波信号，能更有效地保留主导的音符分量。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef fft_radix2(x: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute the DFT of a 1-D complex array x using a radix-2 Cooley–Tukey algorithm.\n    Length of x must be a power of two.\n    \"\"\"\n    x = np.asarray(x, dtype=np.complex128)\n    N = x.shape[0]\n    if N == 1:\n        return x.copy()\n    if N % 2 != 0:\n        raise ValueError(\"Input length must be a power of two for radix-2 FFT.\")\n    # Recursively compute FFT of even and odd indexed elements\n    X_even = fft_radix2(x[::2])\n    X_odd = fft_radix2(x[1::2])\n    # Twiddle factors\n    k = np.arange(N // 2, dtype=np.float64)\n    twiddle = np.exp(-2j * np.pi * k / N)\n    top = X_even + twiddle * X_odd\n    bottom = X_even - twiddle * X_odd\n    return np.concatenate((top, bottom))\n\ndef ifft_radix2(X: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute the inverse DFT using the conjugate trick and the radix-2 FFT.\n    \"\"\"\n    X = np.asarray(X, dtype=np.complex128)\n    N = X.shape[0]\n    # iDFT(x) = conj(DFT(conj(x))) / N\n    return np.conjugate(fft_radix2(np.conjugate(X))) / N\n\ndef is_power_of_two(n: int) -> bool:\n    return n > 0 and (n & (n - 1)) == 0\n\ndef generate_signals(Fs: int, N: int, f0: float):\n    \"\"\"\n    Generate clean sinusoid s_n and observed x_n = s_n + deterministic noise.\n    Noise frequencies are 1000 Hz and 3000 Hz with amplitudes 0.15 and 0.10, respectively.\n    \"\"\"\n    if not is_power_of_two(N):\n        raise ValueError(\"N must be a power of two.\")\n    t = np.arange(N, dtype=np.float64) / float(Fs)\n    s = np.sin(2.0 * np.pi * f0 * t)\n    noise = 0.15 * np.sin(2.0 * np.pi * 1000.0 * t) + 0.10 * np.sin(2.0 * np.pi * 3000.0 * t)\n    x = s + noise\n    return s, x\n\ndef spectral_threshold_filter(x: np.ndarray, tau: float) -> np.ndarray:\n    \"\"\"\n    Apply frequency-domain thresholding: zero coefficients below tau * max |X_k|.\n    Returns the filtered time-domain signal y (real-valued).\n    \"\"\"\n    X = fft_radix2(x.astype(np.complex128))\n    mags = np.abs(X)\n    M = mags.max() if X.size > 0 else 0.0\n    threshold = tau * M\n    mask = mags >= threshold\n    Y = X * mask\n    y = ifft_radix2(Y)\n    # Numerical residual imaginary part may appear due to finite precision.\n    return np.real(y)\n\ndef rmse(a: np.ndarray, b: np.ndarray) -> float:\n    diff = a - b\n    return float(np.sqrt(np.mean(diff * diff)))\n\ndef solve():\n    # Define the test cases from the problem statement: (Fs, N, f0, tau)\n    test_cases = [\n        (8192, 1024, 440.0, 0.25),\n        (8192, 1024, 512.0, 0.90),\n        (8192, 1024, 440.0, 0.00),\n        (8192, 1024, 2048.0, 0.75),\n    ]\n\n    results = []\n    for Fs, N, f0, tau in test_cases:\n        s, x = generate_signals(Fs, N, f0)\n        y = spectral_threshold_filter(x, tau)\n        value = rmse(y, s)\n        results.append(f\"{value:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "许多现实世界中的信号都是非平稳的，这意味着它们的统计特性（例如主导频率）会随时间变化。在这种情况下，固定的滤波器或基于块的$FFT$处理方法可能会失效。这最后一项实践  将挑战你以系统设计者的视角进行思考，评估不同策略，以设计一个能够实时跟踪并抑制频率漂移干扰的自适应滤波器。通过分析不同滤波器设计在延迟和性能之间的权衡，你将深入理解自适应信号处理的核心原理，这是现代计算工程应用中的一个关键领域。",
            "id": "2436687",
            "problem": "一个以 $f_s = 8\\,\\text{kHz}$ 速率采样的实时传感器数据流包含一个期望的宽带分量 $s[n]$、一个单一的窄带干扰 $i[n]$ 和加性白噪声 $w[n]$。观测到的信号为 $x[n] = s[n] + i[n] + w[n]$，其中干扰可以建模为 $i[n] = A[n]\\cos(\\phi[n])$，其幅值 $A[n]$ 和相位 $\\phi[n]$ 缓慢变化。瞬时角频率为 $\\omega_0[n] = \\phi[n]-\\phi[n-1]$，它会缓慢漂移，且满足 $|\\omega_0[n+1]-\\omega_0[n]| \\le \\Delta_\\omega$，其中 $\\Delta_\\omega$ 很小。应用要求对干扰的抑制不低于 $30\\,\\text{dB}$，同时保持延迟低于 $10\\,\\text{ms}$，并最小化对 $\\omega_0[n]$ 周围极窄频带之外的 $s[n]$ 的失真。\n\n从频谱分析和数字滤波的基本原理出发，仅假设：\n\n- 干扰在局部可以很好地建模为参数缓慢变化的单正弦波，意味着在短时间内其行为近似于 $A\\cos(\\omega_0 n + \\varphi)$。\n- 最小化滤波器输出的均方值（相对于可调参数）会引导这些参数去衰减持续存在的窄带分量。\n- 块谱分析方法的时频分辨率随分析窗的加长而提高，而这会增加延迟。\n\n下列哪种设计策略最能满足在延迟约束内跟踪并滤除时变干扰信号，同时失真最小的要求？\n\nA. 使用加窗sinc方法，设计一个以标称干扰频率为中心的固定有限冲激响应 (FIR) 陷波滤波器，通过增加滤波器阶数获得非常窄的过渡带，并将其部署而不作更改。\n\nB. 实现一个二阶自适应陷波器，其传递函数为 $H(z;n) = \\dfrac{1 - 2\\cos(\\hat{\\omega}[n])z^{-1} + z^{-2}}{1 - 2 r \\cos(\\hat{\\omega}[n])z^{-1} + r^{2} z^{-2}}$，其中 $r$ 为接近 $1$ 的固定值，陷波频率估计值 $\\hat{\\omega}[n]$ 由数控振荡器 (NCO) 生成。在线使用随机梯度下降法更新 $\\hat{\\omega}[n]$ 以降低输出功率，此时利用从内部状态计算出的输出对 $\\hat{\\omega}[n]$ 的瞬时梯度，同时保持零点在单位圆上以维持陷波深度。\n\nC. 使用带有Hann窗的短时傅里叶变换 (STFT)，在每个块中找到上一次检测到的干扰频率附近幅度最大的频率点，将该点置零，并通过重叠相加法重构信号。选择窗长以实现大约 $1\\,\\text{Hz}$ 的频率分辨率，从而使陷波非常窄。\n\nD. 运行一个高阶最小均方 (LMS) 自适应FIR滤波器，采用单输入单输出配置，通过将期望信号设置为零来最小化输出功率，从而不论频谱内容如何都将输出趋向于零，并依靠收敛来最大程度地衰减作为最相干分量的干扰。\n\n选择最佳答案。",
            "solution": "必须首先验证问题陈述的科学合理性、清晰性和完整性。\n\n**步骤1：提取已知条件**\n- 采样率: $f_s = 8\\,\\text{kHz}$。\n- 观测信号: $x[n] = s[n] + i[n] + w[n]$。\n- $s[n]$: 期望的宽带分量。\n- $i[n]$: 单一窄带干扰，建模为 $i[n] = A[n]\\cos(\\phi[n])$。\n- $w[n]$: 加性白噪声。\n- $A[n]$ 和 $\\phi[n]$ 为缓慢变化的幅度和相位。\n- 瞬时角频率: $\\omega_0[n] = \\phi[n]-\\phi[n-1]$。\n- 频率漂移率: $|\\omega_0[n+1]-\\omega_0[n]| \\le \\Delta_\\omega$，其中 $\\Delta_\\omega$ 很小。\n- 性能要求1 (衰减): 抑制干扰至少 $30\\,\\text{dB}$。\n- 性能要求2 (延迟): 延迟必须低于 $10\\,\\text{ms}$。\n- 性能要求3 (失真): 最小化在 $\\omega_0[n]$ 周围极窄频带之外对 $s[n]$ 的失真。\n- 假设1: 干扰在局部被建模为缓慢变化的正弦波。\n- 假设2: 最小化可调滤波器的均方输出会衰减持续存在的窄带信号。\n- 假设3: 块处理方法的时间-频率分辨率与窗长成反比，而窗长决定了延迟。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题描述了自适应信号处理中一个经典且被充分理解的任务：从宽带信号中去除一个时变的窄带干扰。\n- **科学上成立:** 信号模型、干扰的描述以及性能要求（衰减、延迟、失真）在通信、音频处理和生物医学工程等领域都是标准且现实的。所述的假设是数字信号处理的基本原理。\n- **提法恰当:** 这个问题提法恰当。它明确指出了清晰但相互竞争的约束条件，并要求对不同的设计策略进行评估。这是一个典型的工程设计权衡问题。\n- **客观性:** 语言是定量的 ($f_s = 8\\,\\text{kHz}$，延迟 $< 10\\,\\text{ms}$，衰减 $\\ge 30\\,\\text{dB}$) 和标准的定性术语（“缓慢变化”、“最小失真”）的混合，这些术语在此上下文中定义明确。\n\n**步骤3：结论与行动**\n问题陈述有效。它在科学上是合理的，内容自洽，并提出了一个不小的工程挑战。开始进行求解。\n\n**需求分析**\n问题的核心在于同时满足三个相互竞争的要求：\n1.  **跟踪:** 干扰的频率 $\\omega_0[n]$ 不是固定的。因此，任何解决方案都必须是自适应的。\n2.  **低延迟:** 延迟必须小于 $10\\,\\text{ms}$。在 $f_s = 8\\,\\text{kHz}$ 的采样率下，采样周期为 $T_s = 1/8000\\,\\text{s} = 0.125\\,\\text{ms}$。最大允许延迟对应的总样本数为 $10\\,\\text{ms} / 0.125\\,\\text{ms/sample} = 80$ 个样本。任何引入超过此延迟（例如，由滤波器群延迟或块处理引起）的方法都是不可接受的。\n3.  **深而窄的陷波:** 滤波器必须在非常窄的频带内提供至少 $30\\,\\text{dB}$ 的衰减，以避免扭曲宽带信号 $s[n]$。\n\n**选项评估**\n\n**选项A：固定的FIR陷波滤波器**\n该策略提出了一个*固定*的有限冲激响应 (FIR) 滤波器。其根本缺陷在于其非自适应性。问题明确指出干扰的频率 $\\omega_0[n]$ 会随时间漂移。一个以标称频率为中心的固定滤波器，一旦 $\\omega_0[n]$ 漂移出其陷波范围，就会失效。此外，使用FIR滤波器实现一个窄而深的陷波（要求最小失真和 $>30\\,\\text{dB}$ 衰减）需要非常高的滤波器阶数 $N$。一个 $N$ 阶线性相位FIR滤波器的群延迟为 $N/2$ 个样本。为了保持在 $80$ 个样本的延迟约束内，阶数必须满足 $N < 160$。这个阶数可能不足以满足所需的陷波特性。然而，最主要的失败之处在于无法跟踪频率漂移。\n**结论：不正确。**\n\n**选项B：二阶自适应IIR陷波滤波器**\n该选项提出了一个具有自适应陷波频率的二阶无限冲激响应 (IIR) 滤波器。让我们分析其结构和特性。\n- **传递函数:** $H(z;n) = \\dfrac{1 - 2\\cos(\\hat{\\omega}[n])z^{-1} + z^{-2}}{1 - 2 r \\cos(\\hat{\\omega}[n])z^{-1} + r^{2} z^{-2}}$。\n- **陷波深度:** 分子多项式在 $z = e^{\\pm j\\hat{\\omega}[n]}$ 处有复共轭零点，这些零点位于单位圆上。这种布局在角频率 $\\hat{\\omega}[n]$ 处产生了一个理论上无限深的陷波，可以轻松满足 $\\ge 30\\,\\text{dB}$ 的衰减要求。\n- **陷波宽度:** 分母在 $z = r e^{\\pm j\\hat{\\omega}[n]}$ 处有极点。通过选择 $r$ 为一个接近 $1$ 的常数（例如，$r = 0.99$），极点被放置得非常靠近零点。这种几何结构产生了一个非常尖锐和狭窄的陷波，满足了最小化对宽带信号 $s[n]$ 失真的要求。\n- **自适应性:** 陷波频率 $\\hat{\\omega}[n]$ 使用随机梯度下降算法在线更新。目标是最小化输出功率 $E[y^2[n]]$。根据假设2，这将导致算法调整 $\\hat{\\omega}[n]$，直到它与持续存在的高功率干扰的频率 $\\omega_0[n]$ 相匹配。逐样本的更新机制使滤波器能够跟踪干扰的缓慢漂移。\n- **延迟:** 作为一个二阶IIR滤波器，其计算复杂度非常低，群延迟极小（约为几个样本）。这完全在 $10\\,\\text{ms}$（$80$个样本）的延迟约束之内。\n对于这个确切的问题，这种设计是典范且高效的解决方案。它直接解决了所有陈述的要求。\n**结论：正确。**\n\n**选项C：基于STFT的频谱编辑**\n该选项使用基于短时傅里叶变换 (STFT) 的块处理方法。该方法包括将信号块转换到频域，将对应于干扰的频率点置零，然后转换回时域。\n其致命缺陷在于频率分辨率和时间分辨率（延迟）之间的权衡，如假设3所述。该选项建议频率分辨率约为 $1\\,\\text{Hz}$ 以确保陷波很窄。为达到频率分辨率 $\\Delta f$，所需的FFT长度 $N$ 由 $N \\approx f_s / \\Delta f$ 给出。当 $f_s = 8000\\,\\text{Hz}$ 和 $\\Delta f = 1\\,\\text{Hz}$ 时，所需的FFT长度为 $N \\approx 8000$ 个样本。这种块处理方案的延迟至少是块长度的一半（由于加窗），即 $N/2 \\times T_s = 4000 \\times 0.125\\,\\text{ms} = 500\\,\\text{ms}$。这比所允许的最大延迟 $10\\,\\text{ms}$ 大 $50$ 倍。如果选择一个窗长来满足延迟约束（例如， $N=128$，延迟 $\\approx 64 \\times 0.125\\,\\text{ms} = 8\\,\\text{ms}$），频率分辨率将变为 $\\Delta f \\approx 8000 / 128 = 62.5\\,\\text{Hz}$。将这么宽的一个频率点置零会对宽带信号 $s[n]$ 造成显著失真，违反了另一个关键要求。所提出的方法与问题的约束条件内部矛盾。\n**结论：不正确。**\n\n**选项D：高阶LMS自适应FIR滤波器**\n该选项建议使用最小均方 (LMS) 算法的通用自适应FIR滤波器，并配置为最小化输出功率。虽然这种方法可以在主导频率处形成一个陷波，但与选项B相比，它有几个缺点。\n- **延迟:** 该选项指明了“高阶”滤波器。如选项A所讨论，高阶FIR滤波器固有地具有较大的群延迟（$N/2$ 个样本），这直接与小于 $80$ 个样本的严格延迟要求相冲突。\n- **陷波质量:** FIR滤波器无法将零点直接放置在单位圆上（在某些自适应方案中，这会带来稳定性/系数范围问题），因此对于给定的复杂度，它无法达到与选项B中专用IIR结构相同的陷波深度和锐度。要实现深而窄的陷波，需要非常高的阶数，这会加剧延迟问题。\n- **效率:** 选项B中的自适应IIR滤波器是为这类问题高度特化的结构。它只调整一个参数，即 $\\hat{\\omega}[n]$，这正是我们关心的量。选项D中的FIR滤波器必须调整大量的系数（$N+1$ 个），使得优化问题维度更高，与选项B的针对性方法相比，对于给定的计算预算，可能导致收敛更慢、跟踪性能更差。虽然原则上可行，但对于这项特定任务来说，它是一个低效且较差的工具。\n**结论：不正确。**\n\n**结论**\n选项B提供了最合适的解决方案。二阶自适应IIR陷波滤波器是在严格的延迟和失真约束下，用于跟踪和消除单个、缓慢漂移的窄带干扰的标准、高效和最优结构。",
            "answer": "$$\\boxed{B}$$"
        }
    ]
}