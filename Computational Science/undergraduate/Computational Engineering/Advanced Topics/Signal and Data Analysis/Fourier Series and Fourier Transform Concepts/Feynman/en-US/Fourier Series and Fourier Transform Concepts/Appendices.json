{
    "hands_on_practices": [
        {
            "introduction": "The power of Fourier series lies in their ability to approximate complex periodic functions with a sum of simple sinusoids. However, this approximation has fascinating subtleties. This exercise explores the famous Gibbs phenomenon, where the Fourier series of a function with a jump discontinuity exhibits a persistent overshoot near the jump, regardless of how many terms are added. By quantifying this overshoot for a sawtooth wave, you will gain a deeper, practical understanding of the convergence properties of Fourier series, a crucial concept for avoiding misinterpretation in engineering models. ",
            "id": "2395550",
            "problem": "Consider the real-valued sawtooth wave defined by the function $f:\\mathbb{R}\\to\\mathbb{R}$ with fundamental period $2\\pi$ and one period given by $f(x)=\\dfrac{x}{\\pi}$ for $x\\in(-\\pi,\\pi)$, extended periodically so that $f(x+2\\pi)=f(x)$ for all $x\\in\\mathbb{R}$. All angles must be interpreted in radians. For each positive integer $N$, let $S_N(x)$ denote the $N$-th partial sum of the Fourier series of $f$, constructed from the Fourier series definition: \n$$\na_0=\\frac{1}{\\pi}\\int_{-\\pi}^{\\pi} f(x)\\,dx,\\quad a_k=\\frac{1}{\\pi}\\int_{-\\pi}^{\\pi} f(x)\\cos(kx)\\,dx,\\quad b_k=\\frac{1}{\\pi}\\int_{-\\pi}^{\\pi} f(x)\\sin(kx)\\,dx,\n$$\nfor $k\\in\\mathbb{N}$, and\n$$\nS_N(x)=\\frac{a_0}{2}+\\sum_{k=1}^{N}\\left(a_k\\cos(kx)+b_k\\sin(kx)\\right).\n$$\nAt the jump discontinuity at $x=\\pi$ of the $2\\pi$-periodic extension, the left-hand limit is $\\lim_{x\\to\\pi^-}f(x)=1$ and the right-hand limit is $\\lim_{x\\to\\pi^+}f(x)=-1$, so the jump magnitude is $J=2$. To quantify the Gibbs phenomenon near this jump, define the overshoot ratio for the $N$-th partial sum by\n$$\n\\rho_N=\\frac{\\max\\{S_N(x)-1: x\\in(\\pi-\\frac{\\pi}{2},\\pi)\\}_+}{J},\n$$\nwhere $(z)_+=\\max(z,0)$ and $J=2$. The task is to compute $\\rho_N$ for a given set of $N$ values. Use the following test suite of partial-sum orders: $N\\in\\{1,5,25,101\\}$. Your program must produce a single line of output containing the results as a comma-separated list of floating-point numbers, rounded to $6$ decimal places, enclosed in square brackets, in the same order as the test suite (for example, $[r_1,r_2,r_3,r_4]$). No other output is permitted.",
            "solution": "The supplied problem is subjected to rigorous validation and is determined to be valid. It is scientifically grounded in the established theory of Fourier analysis, mathematically well-posed, and formulated with objective, unambiguous language. All necessary information is provided for a unique solution. We may therefore proceed with the derivation and computation.\n\nThe problem requires the computation of the Gibbs phenomenon overshoot ratio for a sawtooth wave. The function is given as $f(x) = \\frac{x}{\\pi}$ for $x \\in (-\\pi, \\pi)$, with a fundamental period of $T = 2\\pi$. The analysis will proceed in steps: first, the determination of the Fourier series coefficients; second, the construction of the $N$-th partial sum $S_N(x)$; third, the analytical location of the maximum overshoot; and finally, the computation of the specified ratio $\\rho_N$ for the given values of $N$.\n\nFirst, we calculate the Fourier coefficients $a_0$, $a_k$, and $b_k$ for $k \\in \\mathbb{N}$. The function $f(x)=x/\\pi$ is an odd function, since $f(-x) = (-x)/\\pi = -f(x)$. The integral of an odd function over a symmetric interval such as $[-\\pi, \\pi]$ is zero.\nThe coefficient $a_0$ is given by:\n$$ a_0 = \\frac{1}{\\pi} \\int_{-\\pi}^{\\pi} f(x) \\,dx = \\frac{1}{\\pi} \\int_{-\\pi}^{\\pi} \\frac{x}{\\pi} \\,dx = 0 $$\nThe coefficients $a_k$ are given by:\n$$ a_k = \\frac{1}{\\pi} \\int_{-\\pi}^{\\pi} f(x) \\cos(kx) \\,dx = \\frac{1}{\\pi} \\int_{-\\pi}^{\\pi} \\frac{x}{\\pi} \\cos(kx) \\,dx $$\nSince $x/\\pi$ is an odd function and $\\cos(kx)$ is an even function, their product is odd. The integral of this odd product over the symmetric interval $[-\\pi, \\pi]$ is zero. Thus, $a_k = 0$ for all $k \\geq 1$.\n\nThe coefficients $b_k$ are given by:\n$$ b_k = \\frac{1}{\\pi} \\int_{-\\pi}^{\\pi} f(x) \\sin(kx) \\,dx = \\frac{1}{\\pi} \\int_{-\\pi}^{\\pi} \\frac{x}{\\pi} \\sin(kx) \\,dx $$\nThe product of two odd functions, $x/\\pi$ and $\\sin(kx)$, is an even function. Therefore, the integral is non-zero and can be simplified:\n$$ b_k = \\frac{2}{\\pi^2} \\int_{0}^{\\pi} x \\sin(kx) \\,dx $$\nWe use integration by parts, $\\int u \\,dv = uv - \\int v \\,du$, with $u=x$ and $dv=\\sin(kx)dx$. This yields $du=dx$ and $v = -\\frac{1}{k}\\cos(kx)$.\n$$ \\int_{0}^{\\pi} x \\sin(kx) \\,dx = \\left[ -\\frac{x}{k}\\cos(kx) \\right]_{0}^{\\pi} - \\int_{0}^{\\pi} \\left(-\\frac{1}{k}\\cos(kx)\\right) \\,dx $$\n$$ = -\\frac{\\pi}{k}\\cos(k\\pi) + \\frac{1}{k} \\int_{0}^{\\pi} \\cos(kx) \\,dx = -\\frac{\\pi}{k}(-1)^k + \\frac{1}{k} \\left[ \\frac{1}{k}\\sin(kx) \\right]_{0}^{\\pi} $$\n$$ = \\frac{\\pi}{k}(-1)^{k+1} + \\frac{1}{k^2}(\\sin(k\\pi) - \\sin(0)) = \\frac{\\pi}{k}(-1)^{k+1} $$\nSubstituting this back into the expression for $b_k$:\n$$ b_k = \\frac{2}{\\pi^2} \\left( \\frac{\\pi}{k}(-1)^{k+1} \\right) = \\frac{2}{\\pi k}(-1)^{k+1} $$\n\nThe $N$-th partial sum of the Fourier series, $S_N(x)$, is therefore:\n$$ S_N(x) = \\frac{a_0}{2} + \\sum_{k=1}^{N} (a_k \\cos(kx) + b_k \\sin(kx)) = \\sum_{k=1}^{N} \\frac{2}{\\pi k}(-1)^{k+1} \\sin(kx) $$\n\nThe problem asks for the overshoot ratio $\\rho_N$, defined as:\n$$ \\rho_N = \\frac{\\max\\{S_N(x)-1: x \\in (\\pi/2, \\pi)\\}_+}{2} $$\nTo find this, we must find the maximum value of $S_N(x)$ on the open interval $x \\in (\\pi/2, \\pi)$. We find the critical points by setting the derivative of $S_N(x)$ to zero:\n$$ \\frac{dS_N(x)}{dx} = \\frac{d}{dx} \\left( \\frac{2}{\\pi} \\sum_{k=1}^{N} \\frac{(-1)^{k+1}}{k} \\sin(kx) \\right) = \\frac{2}{\\pi} \\sum_{k=1}^{N} (-1)^{k+1} \\cos(kx) = 0 $$\nLet us analyze the sum. We use the transformation $x = \\pi - y$, where $y \\in (0, \\pi/2)$.\n$$ \\cos(kx) = \\cos(k(\\pi - y)) = \\cos(k\\pi)\\cos(ky) + \\sin(k\\pi)\\sin(ky) = (-1)^k\\cos(ky) $$\nThe sum becomes:\n$$ \\sum_{k=1}^{N} (-1)^{k+1} (-1)^k \\cos(ky) = \\sum_{k=1}^{N} (-1) \\cos(ky) = -\\sum_{k=1}^{N} \\cos(ky) $$\nThe critical points are the solutions to $\\sum_{k=1}^{N} \\cos(ky) = 0$. This is a known sum, which has a closed form:\n$$ \\sum_{k=1}^{N} \\cos(ky) = \\text{Re}\\left(\\sum_{k=1}^{N} e^{iky}\\right) = \\frac{\\sin(Ny/2)\\cos((N+1)y/2)}{\\sin(y/2)} $$\nThis expression is zero when $\\sin(Ny/2) = 0$ or $\\cos((N+1)y/2) = 0$, for $y \\neq 0$.\nThe solutions are $y = 2m\\pi/N$ and $y = (2m+1)\\pi/(N+1)$ for integer $m$.\nThe extrema of $S_N(x)$ near $x=\\pi$ correspond to these values of $y=\\pi-x$. The Gibbs overshoot manifests as the first peak to the left of the discontinuity. This corresponds to the smallest positive value of $y$, which is $y = \\pi/(N+1)$ for $m=0$. The location of this first maximum is $x_{max} = \\pi - \\frac{\\pi}{N+1}$.\nFor $N>1$, this point lies within the interval $(\\pi/2, \\pi)$. For $N=1$, the location is $x=\\pi/2$, which is on the boundary of the interval.\n\nCase $N=1$: $S_1(x) = \\frac{2}{\\pi}\\sin(x)$. On the interval $(\\pi/2, \\pi)$, its derivative $S'_1(x) = \\frac{2}{\\pi}\\cos(x)$ is strictly negative. Thus, $S_1(x)$ is a decreasing function on this interval. The supremum is at the boundary $x=\\pi/2$, with value $S_1(\\pi/2)=2/\\pi \\approx 0.637 < 1$. Consequently, $S_1(x) - 1 < 0$ for all $x \\in (\\pi/2, \\pi)$. The term $\\max\\{S_1(x)-1, \\dots\\}_+$ is zero, so $\\rho_1 = 0$.\n\nCase $N > 1$: The maximum value of $S_N(x)$ in the interval occurs at $x_{max} = \\pi - \\frac{\\pi}{N+1}$. We evaluate $S_N(x_{max})$:\n$$ S_N(x_{max}) = \\frac{2}{\\pi} \\sum_{k=1}^{N} \\frac{(-1)^{k+1}}{k} \\sin\\left(k\\left(\\pi - \\frac{\\pi}{N+1}\\right)\\right) $$\nUsing the identity $\\sin(k\\pi - \\alpha) = (-1)^{k+1}\\sin(\\alpha)$:\n$$ \\sin\\left(k\\pi - \\frac{k\\pi}{N+1}\\right) = (-1)^{k+1}\\sin\\left(\\frac{k\\pi}{N+1}\\right) $$\nThe expression for $S_N(x_{max})$ simplifies to:\n$$ S_N(x_{max}) = \\frac{2}{\\pi} \\sum_{k=1}^{N} \\frac{1}{k}\\sin\\left(\\frac{k\\pi}{N+1}\\right) $$\nThis is the maximum value of the partial sum. The overshoot is $O_N = S_N(x_{max}) - 1$. Since this value is positive for $N > 1$, the ratio is $\\rho_N = (S_N(x_{max}) - 1)/2$.\n\nThe algorithm for computation is as follows:\n1. For $N=1$, $\\rho_1=0$.\n2. For $N \\in \\{5, 25, 101\\}$, compute $S_N_max = \\frac{2}{\\pi} \\sum_{k=1}^{N} \\frac{1}{k}\\sin(\\frac{k\\pi}{N+1})$.\n3. Compute $\\rho_N = (S_N_max - 1)/2$.\n\nThis provides a complete analytical foundation for the implementing code.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Gibbs phenomenon overshoot ratio for a sawtooth wave's Fourier series.\n\n    The sawtooth wave is f(x) = x/pi on (-pi, pi), with period 2*pi.\n    The N-th partial sum is S_N(x) = sum_{k=1 to N} (2/(pi*k))*(-1)^(k+1)*sin(kx).\n    The overshoot ratio is rho_N = max(S_N(x_max) - 1, 0) / 2, where x_max is the location\n    of the first peak to the left of the jump at x=pi.\n\n    The maximum for S_N(x) on (pi/2, pi) is analytically found to be at\n    x_max = pi - pi/(N+1) for N > 1.\n    For N=1, the maximum on the open interval does not exist, and the supremum\n    is less than 1, resulting in zero overshoot.\n    \"\"\"\n\n    test_cases = [1, 5, 25, 101]\n    results = []\n\n    for N in test_cases:\n        if N == 1:\n            # For N=1, S_1(x) = (2/pi)*sin(x). On the interval (pi/2, pi), this\n            # function is strictly decreasing. The supremum is S_1(pi/2) = 2/pi, which\n            # is less than 1. Thus, the overshoot (S_1(x) - 1) is always negative\n            # on the interval. The definition max(overshoot, 0) leads to 0.\n            rho = 0.0\n        else:\n            # For N > 1, the maximum of S_N(x) in the interval (pi/2, pi) occurs\n            # at x = pi - pi/(N+1).\n            # The value at this maximum is S_N(x_max).\n            # S_N(x_max) = (2/pi) * sum_{k=1 to N} (1/k) * sin(k*pi/(N+1)).\n            k_vals = np.arange(1, N + 1)\n            \n            # The argument to the sine function in the simplified sum\n            sin_arg = k_vals * np.pi / (N + 1)\n            \n            # The terms of the sum\n            terms = np.sin(sin_arg) / k_vals\n            \n            # The maximum value of the N-th partial sum\n            s_n_max = (2 / np.pi) * np.sum(terms)\n            \n            # The problem defines the overshoot relative to the limit f(pi-) = 1.\n            overshoot = s_n_max - 1\n            \n            # The jump J is 2. The overshoot ratio rho_N includes max(overshoot, 0).\n            # For N > 1, the overshoot is positive.\n            rho = overshoot / 2.0\n        \n        results.append(rho)\n\n    # Format the results to 6 decimal places as required.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    \n    # Print the final output in the specified format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "In the real world, we analyze signals over finite time intervals, which can introduce artifacts in the frequency domain through a phenomenon called spectral leakage. This can make it difficult to distinguish between two closely spaced frequencies. This practice delves into the critical role of \"window functions\" in mitigating these artifacts. By exploring how different windows, like the Hamming and Blackman windows, affect our ability to resolve sinusoids in a noisy signal, you will develop a core skill for any practical application of the Discrete Fourier Transform. ",
            "id": "2395553",
            "problem": "Write a complete program that, for a discrete-time signal composed of two closely spaced sinusoids corrupted by additive noise and multiplied by a window function, determines whether the two sinusoids are resolved according to a precise spectral criterion, for specified parameter sets. Use first principles based on the definition of the Discrete Fourier Transform (DFT) and well-defined window functions.\n\nThe discrete-time signal is\n$$\nx[n] \\;=\\; A \\cos\\!\\left(2\\pi \\frac{f_1}{F_s} n \\right) \\;+\\; A \\cos\\!\\left(2\\pi \\frac{f_2}{F_s} n \\right) \\;+\\; \\sigma\\, z[n], \\quad n=0,1,\\dots,N-1,\n$$\nwhere $A$ is the sinusoid amplitude, $F_s$ is the sampling frequency in hertz, $f_1$ and $f_2$ are sinusoid frequencies in hertz, $\\sigma$ is the noise standard deviation, and $z[n]$ is a deterministic pseudorandom sequence with a standard normal distribution (zero mean and unit variance). All angles are in radians.\n\nThe deterministic pseudorandom sequence $z[n]$ must be constructed as follows for each test case:\n- Generate a sequence of independent uniform random variables $u[n]$ in the open interval $(0,1)$ using a Linear Congruential Generator (LCG) defined by\n$$\nx_{n+1} \\equiv (a x_n + c) \\bmod m,\n$$\nwith modulus $m=2^{32}$, multiplier $a=1664525$, increment $c=1013904223$, and a given seed $x_0$. For each $n$, map $x_n$ to $u[n]$ by\n$$\nu[n] \\;=\\; \\frac{x_n + 0.5}{m}.\n$$\n- Transform $u[n]$ to a standard normal variate by $z[n] = \\Phi^{-1}(u[n])$, where $\\Phi^{-1}$ is the inverse cumulative distribution function of the standard normal distribution.\n\nFor a window $w[n]$, define the windowed sequence $y[n] = w[n]\\,x[n]$. Consider the $N$-point Discrete Fourier Transform (DFT)\n$$\nY[k] \\;=\\; \\sum_{n=0}^{N-1} y[n]\\, e^{-j 2\\pi kn/N}, \\quad k=0,1,\\dots,N-1.\n$$\nDefine the one-sided magnitude spectrum for real-valued signals as\n$$\nM[k] \\;=\\; |Y[k]|, \\quad k=0,1,\\dots,\\left\\lfloor \\frac{N}{2} \\right\\rfloor.\n$$\n\nUse the following two window functions:\n- Hamming window: $w_{\\mathrm{Ham}}[n] = 0.54 - 0.46 \\cos\\!\\left(\\frac{2\\pi n}{N-1}\\right)$ for $n=0,1,\\dots,N-1$.\n- Blackman window: $w_{\\mathrm{Blk}}[n] = 0.42 - 0.5 \\cos\\!\\left(\\frac{2\\pi n}{N-1}\\right) + 0.08 \\cos\\!\\left(\\frac{4\\pi n}{N-1}\\right)$ for $n=0,1,\\dots,N-1$.\n\nDefine the target DFT bin indices associated with $f_1$ and $f_2$ by\n$$\nk_1 \\;=\\; \\left\\lfloor \\frac{f_1 N}{F_s} + \\tfrac{1}{2} \\right\\rfloor, \n\\quad\nk_2 \\;=\\; \\left\\lfloor \\frac{f_2 N}{F_s} + \\tfrac{1}{2} \\right\\rfloor,\n$$\nthat is, the nearest integers to the exact frequencies mapped to the $N$-point DFT grid.\n\nResolution criterion. The two sinusoids are declared resolved under window $w[n]$ if and only if there exist two distinct indices $k_a$ and $k_b$ in the set $\\{1,2,\\dots,\\lfloor N/2 \\rfloor - 1\\}$ such that:\n1. $k_a \\neq k_b$ and both are strict local maxima of $M[k]$:\n$$\nM[k_a] > M[k_a - 1] \\;\\text{ and }\\; M[k_a] > M[k_a + 1], \\quad\nM[k_b] > M[k_b - 1] \\;\\text{ and }\\; M[k_b] > M[k_b + 1].\n$$\n2. Each is near its corresponding target bin:\n$$\n|k_a - k_1| \\le 1 \\quad \\text{and} \\quad |k_b - k_2| \\le 1.\n$$\n3. The valley between them is sufficiently deep. Let\n$$\nk_{\\min} \\in \\arg\\min_{k \\in [\\min(k_a,k_b),\\,\\max(k_a,k_b)]} M[k].\n$$\nThen\n$$\nM[k_{\\min}] \\;\\le\\; \\gamma \\cdot \\min\\{M[k_a],\\,M[k_b]\\},\n$$\nwith $\\gamma = 0.5$.\n\nYou must evaluate the resolution outcome for each of the following test cases. In every test case, use $A=1.0$ and $N=1024$. Frequencies are in hertz, and $F_s$ is in hertz. The two tones are constructed using integer-bin spacing: $f_1 = \\frac{k_1 F_s}{N}$ and $f_2 = \\frac{(k_1+\\Delta) F_s}{N}$ for the specified $k_1$ and bin separation $\\Delta$.\n\nTest suite:\n- Case $1$: $F_s=1024$, $k_1=200$, $\\Delta=3$, $\\sigma=0.01$, seed $x_0=13579$.\n- Case $2$: $F_s=1024$, $k_1=200$, $\\Delta=1$, $\\sigma=0.01$, seed $x_0=24680$.\n- Case $3$: $F_s=1024$, $k_1=150$, $\\Delta=2$, $\\sigma=0.05$, seed $x_0=12345$.\n- Case $4$: $F_s=1024$, $k_1=300$, $\\Delta=4$, $\\sigma=0.20$, seed $x_0=54321$.\n\nFor each test case, your program must compute two boolean results in the order $[$Hamming, Blackman$]$ indicating whether the pair of sinusoids is resolved with each window function according to the above criterion.\n\nFinal output format: Your program should produce a single line of output containing the results for all test cases as a comma-separated list of lists enclosed in square brackets, for example, $[[\\text{result}_{1,\\mathrm{Ham}}, \\text{result}_{1,\\mathrm{Blk}}],[\\text{result}_{2,\\mathrm{Ham}}, \\text{result}_{2,\\mathrm{Blk}}],\\dots]$, using the literal keywords True and False for booleans. No additional text should be printed.",
            "solution": "The problem presented is a well-defined exercise in computational signal processing. It is scientifically grounded, self-contained, and objective. We will proceed to construct a solution based on first principles. The task requires us to determine if two closely spaced sinusoids, embedded in noise and observed through a finite-duration window, can be resolved in the frequency domain. This is a fundamental problem in spectral estimation.\n\nThe discrete-time signal is given by the model:\n$$\nx[n] \\;=\\; A \\cos\\!\\left(2\\pi \\frac{f_1}{F_s} n \\right) \\;+\\; A \\cos\\!\\left(2\\pi \\frac{f_2}{F_s} n \\right) \\;+\\; \\sigma\\, z[n], \\quad n=0,1,\\dots,N-1\n$$\nwhere $A$ is the amplitude, $F_s$ is the sampling frequency, $f_1$ and $f_2$ are the frequencies of the two sinusoids, $\\sigma$ is the noise standard deviation, and $z[n]$ is a standard normal noise sequence.\n\nThe algorithmic solution is constructed in a sequence of logical steps:\n\n**1. Deterministic Noise Generation**\nThe noise sequence $z[n]$ is not truly random but is a deterministic pseudorandom sequence generated for reproducibility. This is a standard practice in simulation and verification. The generation proceeds in two stages:\na. A sequence of integers $x_n$ is generated using a Linear Congruential Generator (LCG):\n$$\nx_{n+1} \\equiv (a x_n + c) \\bmod m\n$$\nwith specified parameters $m=2^{32}$, $a=1664525$, $c=1013904223$, and a given integer seed $x_0$.\nb. This integer sequence is transformed into a sequence of standard normal variates $z[n]$. First, we map $x_n$ to a uniform distribution over $(0,1)$ using the given formula:\n$$\nu[n] \\;=\\; \\frac{x_n + 0.5}{m}\n$$\nThen, we apply the inverse transform sampling method. The value $u[n]$ is treated as a probability, and we find the corresponding variate $z[n]$ from a standard normal distribution using its inverse cumulative distribution function (CDF), denoted $\\Phi^{-1}$:\n$$\nz[n] = \\Phi^{-1}(u[n])\n$$\nThis is implemented using the `ppf` (percent point function) from SciPy's statistics module.\n\n**2. Signal Synthesis and Windowing**\nFor each test case, we are given the parameters $F_s$, $N$, $A$, $\\sigma$, a seed $x_0$, and the definition of the frequencies $f_1$ and $f_2$ in terms of integer bin indices $k_1$ and a separation $\\Delta$:\n$$\nf_1 = \\frac{k_1 F_s}{N}, \\quad f_2 = \\frac{(k_1+\\Delta) F_s}{N}\n$$\nThe time-domain signal $x[n]$ is constructed by summing the two cosine terms and the scaled noise sequence $z[n]$.\n\nBefore spectral analysis, the signal $x[n]$ is multiplied by a window function $w[n]$ to produce $y[n] = w[n]x[n]$. This is necessary because the Discrete Fourier Transform (DFT) assumes periodicity, and windowing mitigates the spectral leakage caused by observing a signal for a finite duration. We evaluate two standard windows:\n- Hamming: $w_{\\mathrm{Ham}}[n] = 0.54 - 0.46 \\cos\\!\\left(\\frac{2\\pi n}{N-1}\\right)$\n- Blackman: $w_{\\mathrm{Blk}}[n] = 0.42 - 0.5 \\cos\\!\\left(\\frac{2\\pi n}{N-1}\\right) + 0.08 \\cos\\!\\left(\\frac{4\\pi n}{N-1}\\right)$\n\n**3. Spectral Analysis via DFT**\nThe spectrum of the windowed signal $y[n]$ is computed using the $N$-point DFT:\n$$\nY[k] \\;=\\; \\sum_{n=0}^{N-1} y[n]\\, e^{-j 2\\pi kn/N}\n$$\nFor a real-valued input signal, the magnitude spectrum is symmetric. We are interested in the one-sided magnitude spectrum, $M[k] = |Y[k]|$, for frequency bins $k=0, 1, \\dots, \\lfloor N/2 \\rfloor$. This computation is efficiently performed using the Fast Fourier Transform (FFT) algorithm, available in NumPy.\n\n**4. Implementation of the Resolution Criterion**\nThe core of the problem is to apply the specified multi-part resolution criterion. We must find if there exist two distinct spectral peaks, $k_a$ and $k_b$, that satisfy all three conditions:\n1.  **Local Maxima**: Both $k_a$ and $k_b$ must correspond to strict local maxima of the magnitude spectrum $M[k]$. We identify these by iterating through the bins $k \\in \\{1, \\dots, \\lfloor N/2 \\rfloor - 1\\}$ and checking if $M[k] > M[k-1]$ and $M[k] > M[k+1]$.\n2.  **Proximity to Targets**: The found peaks must be near their expected locations. The target bin indices are defined as the nearest integers to the normalized frequencies:\n    $$\n    k_1^{\\text{target}} \\;=\\; \\left\\lfloor \\frac{f_1 N}{F_s} + \\tfrac{1}{2} \\right\\rfloor = k_1, \\quad k_2^{\\text{target}} \\;=\\; \\left\\lfloor \\frac{f_2 N}{F_s} + \\tfrac{1}{2} \\right\\rfloor = k_1+\\Delta\n    $$\n    We must find a pair of peaks $(k_a, k_b)$ such that one is close to $k_1^{\\text{target}}$ and the other is close to $k_2^{\\text{target}}$. The precise condition is $|k_a - k_1^{\\text{target}}| \\le 1$ and $|k_b - k_2^{\\text{target}}| \\le 1$. To implement this, we form two sets of candidate peaks: those within one bin of $k_1^{\\text{target}}$ and those within one bin of $k_2^{\\text{target}}$. We then search for a distinct pair $(k_a, k_b)$, with one element from each set.\n3.  **Valley Depth**: The spectral valley between the two peaks must be sufficiently deep. For a candidate pair $(k_a, k_b)$, we find the minimum magnitude $M[k_{\\min}]$ in the inclusive bin range $[\\min(k_a,k_b), \\max(k_a,k_b)]$. This minimum must satisfy:\n    $$\n    M[k_{\\min}] \\;\\le\\; \\gamma \\cdot \\min\\{M[k_a],\\,M[k_b]\\}\n    $$\n    with the given threshold $\\gamma = 0.5$.\n\nIf a pair $(k_a, k_b)$ satisfying all three conditions is found, the sinusoids are declared \"resolved\"; otherwise, they are not. This entire procedure is implemented in a Python function, which is then applied to each test case for both window functions. The final results are aggregated and formatted into the specified string output.",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    It iterates through test cases, checks resolution for Hamming and Blackman\n    windows, and prints the formatted results.\n    \"\"\"\n\n    def generate_noise(seed, num_samples, m, a, c):\n        \"\"\"\n        Generates a deterministic pseudorandom standard normal sequence using\n        an LCG and inverse transform sampling.\n        \"\"\"\n        z = np.zeros(num_samples)\n        x_n = seed\n        for i in range(num_samples):\n            x_n = (a * x_n + c) % m\n            # Map LCG output to uniform (0,1)\n            u_n = (x_n + 0.5) / m\n            # Transform uniform to standard normal via inverse CDF\n            z[i] = norm.ppf(u_n)\n        return z\n\n    def get_window(name, num_samples):\n        \"\"\"\n        Returns the specified window function as a numpy array.\n        \"\"\"\n        n = np.arange(num_samples)\n        if name == 'Hamming':\n            return 0.54 - 0.46 * np.cos(2 * np.pi * n / (num_samples - 1))\n        elif name == 'Blackman':\n            return 0.42 - 0.5 * np.cos(2 * np.pi * n / (num_samples - 1)) + 0.08 * np.cos(4 * np.pi * n / (num_samples - 1))\n        else:\n            raise ValueError(\"Unknown window type\")\n\n    def check_resolution(Fs, N, A, k1_int, delta, sigma, seed, window_name, gamma):\n        \"\"\"\n        Performs the full analysis for a single configuration to determine\n        if two sinusoids are resolved according to the problem's criterion.\n        \"\"\"\n        # --- 1. Derive parameters and generate signal ---\n        f1 = k1_int * Fs / N\n        f2 = (k1_int + delta) * Fs / N\n        k1_target = int(round(f1 * N / Fs))\n        k2_target = int(round(f2 * N / Fs))\n\n        # LCG parameters\n        m_lcg, a_lcg, c_lcg = 2**32, 1664525, 1013904223\n        noise = generate_noise(seed, N, m_lcg, a_lcg, c_lcg)\n\n        n = np.arange(N)\n        signal_clean = A * np.cos(2 * np.pi * f1 / Fs * n) + A * np.cos(2 * np.pi * f2 / Fs * n)\n        x = signal_clean + sigma * noise\n\n        # --- 2. Windowing and DFT ---\n        w = get_window(window_name, N)\n        y = x * w\n        \n        Y = np.fft.fft(y, N)\n        # One-sided magnitude spectrum\n        M = np.abs(Y[:N // 2 + 1])\n\n        # --- 3. Apply Resolution Criterion ---\n        # Condition 1: Find all strict local maxima in the specified range.\n        local_maxima_indices = []\n        for k in range(1, N // 2):\n            if M[k] > M[k-1] and M[k] > M[k+1]:\n                local_maxima_indices.append(k)\n\n        # Condition 2: Find candidate peaks near target frequencies.\n        candidates_k1 = [k for k in local_maxima_indices if abs(k - k1_target) <= 1]\n        candidates_k2 = [k for k in local_maxima_indices if abs(k - k2_target) <= 1]\n\n        # Search for a valid pair (ka, kb).\n        for ka in candidates_k1:\n            for kb in candidates_k2:\n                if ka == kb:\n                    continue  # Peaks must be distinct.\n\n                # This pair (ka, kb) fulfills conditions 1 and 2.\n                # Now check Condition 3: Valley depth.\n                k_start = min(ka, kb)\n                k_end = max(ka, kb)\n                \n                # Find the minimum magnitude in the valley (inclusive range).\n                valley_slice = M[k_start : k_end + 1]\n                m_min_val = np.min(valley_slice)\n                \n                # Check the depth condition.\n                if m_min_val <= gamma * min(M[ka], M[kb]):\n                    return True  # Resolution is achieved.\n        \n        # If loops complete, no pair satisfied all conditions.\n        return False\n\n    # Common parameters for all test cases\n    A_const = 1.0\n    N_const = 1024\n    gamma_const = 0.5\n    \n    test_cases = [\n        # (Fs, k1, delta, sigma, seed)\n        (1024, 200, 3, 0.01, 13579),\n        (1024, 200, 1, 0.01, 24680),\n        (1024, 150, 2, 0.05, 12345),\n        (1024, 300, 4, 0.20, 54321),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        Fs, k1, delta, sigma, seed = case\n        \n        # Check resolution for Hamming window\n        res_ham = check_resolution(Fs, N_const, A_const, k1, delta, sigma, seed, 'Hamming', gamma_const)\n        \n        # Check resolution for Blackman window\n        res_blk = check_resolution(Fs, N_const, A_const, k1, delta, sigma, seed, 'Blackman', gamma_const)\n        \n        all_results.append([res_ham, res_blk])\n\n    # Format the final output string exactly as required.\n    inner_strings = [str(item).replace(\" \", \"\") for item in all_results]\n    final_output = f\"[{','.join(inner_strings)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "This practice challenges you to apply your knowledge to build a system inspired by real-world audio recognition technologies like Shazam. You will implement a complete, albeit simplified, audio fingerprinting algorithm from first principles. By using the Short-Time Fourier Transform (STFT) to identify a robust time-frequency \"constellation\" of spectral peaks, you will create a method for matching audio clips that is resilient to noise, time shifts, and amplitude changes. This project demonstrates the remarkable power of Fourier analysis in solving complex, modern engineering problems. ",
            "id": "2395481",
            "problem": "You are given the task of formalizing and implementing a simplified audio fingerprinting and matching system based on time-frequency peak constellations derived from the Short-Time Fourier Transform (STFT). The goal is to design a mathematically precise matching criterion that is robust to time shifts and moderate amplitude changes but not to pitch shifts, and to apply it to a small synthetic test suite of signals. All definitions and parameter values below must be used exactly as stated, and all mathematical entities must be interpreted in the sense of standard complex analysis and linear systems theory.\n\nConstruct a finite set of discrete-time signals sampled at sampling frequency $f_s = 8000$ hertz and of finite duration measured in seconds. For a discrete-time signal $x[n]$, define the Short-Time Fourier Transform (STFT) as\n$$\nX[k,m] = \\sum_{n=0}^{N-1} x[n+mH] \\, w[n] \\, e^{-j 2\\pi kn/N},\n$$\nwhere $N$ is the window length in samples, $H$ is the hop size in samples, $w[n]$ is the Hann window, $k \\in \\{0,1,\\dots,N/2\\}$ indexes the nonnegative frequency bins, and $m \\in \\mathbb{N}$ indexes the time frames. Let the magnitude spectrogram be $S[k,m] = |X[k,m]|$.\n\nDefine spectral peaks as strict local maxima in the two-dimensional array $S[k,m]$ using a rectangular neighborhood of $\\Delta_f$ frequency bins and $\\Delta_t$ time bins, together with a global magnitude threshold. Formally, a time-frequency bin $(k^\\star,m^\\star)$ is a peak if and only if\n- $S[k^\\star,m^\\star] \\ge \\tau$, where $\\tau = \\alpha \\cdot \\max_{k,m} S[k,m]$ with $\\alpha = 0.1$, and\n- $S[k^\\star,m^\\star] \\ge S[k,m]$ for all $(k,m)$ with $|k-k^\\star| \\le \\Delta_f$ and $|m-m^\\star| \\le \\Delta_t$.\nUse $\\Delta_f = 5$ and $\\Delta_t = 3$.\n\nFrom the set of detected peaks, define a constellation fingerprint as follows. For each peak designated as anchor $(k_a,m_a)$ and for each target peak $(k_b,m_b)$ satisfying the time constraint $t_{\\min} \\le (m_b - m_a) \\le t_{\\max}$ with $t_{\\min} = 1$ and $t_{\\max} = 10$, form a hash triple\n$$\nh = (k_a, k_b, \\Delta m), \\quad \\Delta m = m_b - m_a.\n$$\nTo limit combinatorial growth, for each anchor $(k_a,m_a)$ and its candidate targets $(k_b,m_b)$ that satisfy the time constraint, select at most $K$ pairs having the largest magnitudes $S[k_b,m_b]$, where $K = 5$. The fingerprint of a signal is the multiset of all such triples $h$.\n\nDefine a matching score between a query fingerprint $\\mathcal{F}_Q$ and a reference fingerprint $\\mathcal{F}_R$ as the multiset intersection cardinality,\n$$\nm(\\mathcal{F}_Q,\\mathcal{F}_R) = \\sum_{h} \\min\\big(c_Q(h), c_R(h)\\big),\n$$\nwhere $c_Q(h)$ and $c_R(h)$ are the multiplicities of triple $h$ in $\\mathcal{F}_Q$ and $\\mathcal{F}_R$, respectively. Given a set of references $\\{\\mathcal{F}_{R_i}\\}_{i=0}^{2}$, declare the predicted match index for a query $\\mathcal{F}_Q$ as the index $i^\\star$ that maximizes $m(\\mathcal{F}_Q,\\mathcal{F}_{R_i})$, provided that $\\max_i m(\\mathcal{F}_Q,\\mathcal{F}_{R_i}) \\ge M_{\\min}$ with $M_{\\min} = 10$. If the maximum score is strictly less than $M_{\\min}$, return $-1$.\n\nUse the following fixed STFT parameters:\n- Sampling frequency $f_s = 8000$ hertz.\n- Window length $N = 1024$ samples.\n- Hop size $H = 256$ samples.\n- Window $w[n]$ equal to the Hann window of length $N$.\n- One-sided discrete Fourier transform with $N$ frequency bins retained as $k \\in \\{0,1,\\dots,N/2\\}$.\n\nConstruct the following continuous-time signals and sample them at $f_s$ hertz to obtain the discrete-time signals of the specified durations, where $t$ is time in seconds and all angles are in radians:\n- References (each of duration $T_R = 3.0$ seconds):\n  - Reference $R_0$: $x_{R_0}(t) = \\sin(2\\pi \\cdot 440\\, t) + 0.7\\sin(2\\pi \\cdot 660\\, t)$.\n  - Reference $R_1$: $x_{R_1}(t) = \\sin(2\\pi \\cdot 554.365\\, t) + 0.6\\sin(2\\pi \\cdot 659.255\\, t)$.\n  - Reference $R_2$: $x_{R_2}(t) = \\sin(2\\pi \\cdot 300\\, t) + 0.6\\sin(2\\pi \\cdot 900\\, t)$.\n- Queries (each of duration $T_Q = 1.5$ seconds):\n  - Query $Q_0$: a time-shifted excerpt of $x_{R_0}$ from $t \\in [0.8, 2.3)$ seconds, with additive zero-mean Gaussian noise of standard deviation $0.02$.\n  - Query $Q_1$: a time-shifted excerpt of $x_{R_1}$ from $t \\in [0.5, 2.0)$ seconds, noise-free.\n  - Query $Q_2$: a time-shifted excerpt of $x_{R_2}$ from $t \\in [1.0, 2.5)$ seconds, multiplied by an amplitude factor of $0.5$.\n  - Query $Q_3$: a pitch-shifted variant of $x_{R_0}$, defined as $x_{Q_3}(t) = \\sin(2\\pi \\cdot 484\\, t) + 0.7\\sin(2\\pi \\cdot 726\\, t)$, noise-free.\n  - Query $Q_4$: silence, i.e., $x_{Q_4}(t) = 0$ for all $t$.\n\nDefine the reference indices as $0$ for $R_0$, $1$ for $R_1$, and $2$ for $R_2$. For each query $Q_j$ with $j \\in \\{0,1,2,3,4\\}$, compute the predicted reference index according to the matching rule above, returning $-1$ for no match.\n\nYour program must produce a single line of output containing the predicted indices for $[Q_0,Q_1,Q_2,Q_3,Q_4]$ as a comma-separated list of integers enclosed in square brackets and with no spaces, for example $[r_0,r_1,r_2,r_3,r_4]$. No other output is permitted.\n\nThe test suite and coverage are as follows:\n- Time-shift invariance: $Q_0$ is an excerpt of $R_0$ with additive noise.\n- Nominal matching: $Q_1$ is an excerpt of $R_1$.\n- Amplitude scaling: $Q_2$ is an excerpt of $R_2$ scaled by $0.5$.\n- Non-match due to pitch shift: $Q_3$ uses different frequencies than $R_0$.\n- Boundary condition: $Q_4$ is silence.\n\nAll durations must be expressed in seconds and all frequencies in hertz. Angles in sinusoidal definitions are in radians. The final outputs are integers as specified and therefore unitless.",
            "solution": "The problem statement presented is subjected to rigorous validation.\n\n**Step 1: Extraction of Givens**\n\nThe problem provides the following definitions and parameters:\n- **Sampling Frequency**: $f_s = 8000$ hertz.\n- **STFT Definition**: $X[k,m] = \\sum_{n=0}^{N-1} x[n+mH] \\, w[n] \\, e^{-j 2\\pi kn/N}$.\n- **STFT Parameters**:\n    - Window length: $N = 1024$ samples.\n    - Hop size: $H = 256$ samples.\n    - Window function: $w[n]$ is the Hann window of length $N$.\n    - Frequency bins: $k \\in \\{0, 1, \\dots, N/2\\}$.\n- **Magnitude Spectrogram**: $S[k,m] = |X[k,m]|$.\n- **Spectral Peak Definition**: A point $(k^\\star,m^\\star)$ is a peak if:\n    1.  Magnitude threshold: $S[k^\\star,m^\\star] \\ge \\tau$, where $\\tau = \\alpha \\cdot \\max_{k,m} S[k,m]$ and $\\alpha = 0.1$.\n    2.  Local maximum condition: $S[k^\\star,m^\\star] \\ge S[k,m]$ for all $(k,m)$ where $|k-k^\\star| \\le \\Delta_f$ and $|m-m^\\star| \\le \\Delta_t$.\n    3.  Neighborhood size: $\\Delta_f = 5$ bins, $\\Delta_t = 3$ frames.\n- **Fingerprint Hash Definition**:\n    - Hash triple: $h = (k_a, k_b, \\Delta m)$, where $(k_a, m_a)$ is an anchor peak, $(k_b, m_b)$ is a target peak, and $\\Delta m = m_b - m_a$.\n    - Time constraint for pairs: $t_{\\min} \\le \\Delta m \\le t_{\\max}$, with $t_{\\min} = 1$ and $t_{\\max} = 10$.\n    - Target reduction: For each anchor, select at most $K = 5$ target peaks with the largest magnitudes $S[k_b, m_b]$.\n- **Matching Criterion**:\n    - Score: $m(\\mathcal{F}_Q,\\mathcal{F}_R) = \\sum_{h} \\min\\big(c_Q(h), c_R(h)\\big)$, the cardinality of the multiset intersection of fingerprints $\\mathcal{F}_Q$ and $\\mathcal{F}_R$.\n    - Match declaration: The predicted index is $\\arg\\max_i m(\\mathcal{F}_Q, \\mathcal{F}_{R_i})$ if the maximum score is $\\ge M_{\\min}$. Otherwise, the prediction is $-1$.\n    - Minimum score threshold: $M_{\\min} = 10$.\n- **Reference Signals** (Duration $T_R = 3.0$ s):\n    - $R_0$: $x_{R_0}(t) = \\sin(2\\pi \\cdot 440\\, t) + 0.7\\sin(2\\pi \\cdot 660\\, t)$.\n    - $R_1$: $x_{R_1}(t) = \\sin(2\\pi \\cdot 554.365\\, t) + 0.6\\sin(2\\pi \\cdot 659.255\\, t)$.\n    - $R_2$: $x_{R_2}(t) = \\sin(2\\pi \\cdot 300\\, t) + 0.6\\sin(2\\pi \\cdot 900\\, t)$.\n- **Query Signals** (Duration $T_Q = 1.5$ s):\n    - $Q_0$: Excerpt of $x_{R_0}(t)$ from $[0.8, 2.3)$, with added Gaussian noise of standard deviation $0.02$.\n    - $Q_1$: Excerpt of $x_{R_1}(t)$ from $[0.5, 2.0)$, noise-free.\n    - $Q_2$: Excerpt of $x_{R_2}(t)$ from $[1.0, 2.5)$, scaled by amplitude factor $0.5$.\n    - $Q_3$: $x_{Q_3}(t) = \\sin(2\\pi \\cdot 484\\, t) + 0.7\\sin(2\\pi \\cdot 726\\, t)$.\n    - $Q_4$: $x_{Q_4}(t) = 0$ (silence).\n- **Output Format**: A comma-separated list of integers $[r_0,r_1,r_2,r_3,r_4]$.\n\n**Step 2: Validation of Givens**\n\nThe problem is evaluated against the specified criteria:\n- **Scientifically Grounded**: The problem is well-grounded in the principles of digital signal processing and computational engineering. The proposed audio fingerprinting method, using a constellation map of spectral peaks from an STFT, is a standard and well-understood technique. All mathematical formulations are correct.\n- **Well-Posed**: The problem is completely specified. All parameters, functions, and constraints required to produce a deterministic output are provided. There is no ambiguity that would prevent the existence of a unique solution.\n- **Objective**: The problem statement is written in precise, objective, and formal language, free of any subjective or non-technical content.\n\nThe problem exhibits **none** of the invalidity flags. It is scientifically sound, formalizable, complete, feasible, and well-posed. The description of \"strict local maxima\" followed by a non-strict inequality $S[k^\\star,m^\\star] \\ge S[k,m]$ is a minor terminological inconsistency, but the formal definition is unambiguous and must be followed. Therefore, it does not render the problem invalid.\n\n**Step 3: Verdict and Action**\n\nThe problem is **valid**. A solution will be constructed according to the specified procedure.\n\n**Solution Methodology**\n\nThe solution will be implemented by following a sequence of discrete steps, adhering strictly to the definitions provided.\n\n**1. Signal Synthesis**\nFirst, we generate the discrete-time signals $\\{x_{R_i}[n]\\}$ and $\\{x_{Q_j}[n]\\}$ from their continuous-time definitions. A time vector $t$ is created for each signal with a sampling period of $1/f_s$. For a signal of duration $T$, the number of samples is $L = \\lfloor T \\cdot f_s \\rfloor$. The continuous-time functions are evaluated at these discrete time points. For $Q_0$, zero-mean Gaussian noise is added.\n\n**2. Short-Time Fourier Transform (STFT)**\nFor each discrete-time signal $x[n]$, we compute its STFT, $X[k,m]$, according to the given formula. This is efficiently accomplished using standard library functions, specifically `scipy.signal.stft`. The parameters must map correctly:\n- `fs` = $f_s = 8000$.\n- `window` = `'hann'`.\n- `nperseg` = $N = 1024$.\n- `noverlap` = $N - H = 1024 - 256 = 768$.\n- `nfft` = $N = 1024$.\nThe output of this computation is a complex-valued matrix $X[k,m]$. We then compute the magnitude spectrogram $S[k,m] = |X[k,m]|$.\n\n**3. Spectral Peak Identification**\nPeaks are identified in each spectrogram $S[k,m]$. This is a two-step process. First, we handle the degenerate case of silence ($Q_4$). If $\\max(S) = 0$, no peaks exist. Otherwise, we proceed.\n- **Magnitude Thresholding**: We compute the global threshold $\\tau = \\alpha \\cdot \\max(S)$ with $\\alpha = 0.1$. Only points $(k,m)$ with $S[k,m] \\ge \\tau$ are considered as potential peaks.\n- **Local Maximum Filtering**: We enforce the local maximum condition. A point $(k^\\star, m^\\star)$ is a peak only if its value $S[k^\\star, m^\\star]$ is maximal within a rectangular neighborhood of size $(2\\Delta_f+1) \\times (2\\Delta_t+1)$, which is $11 \\times 7$. This is efficiently implemented using a maximum filter, such as `scipy.ndimage.maximum_filter`. A point is a peak if it passes the threshold test and its value is equal to the output of the maximum filter centered at that point. The coordinates $(k,m)$ of all such peaks are stored.\n\n**4. Fingerprint Generation**\nFor each signal, its fingerprint, a multiset of hash triples, is constructed from its list of spectral peaks.\n- The set of peaks is iterated, with each peak $(k_a, m_a)$ serving as an \"anchor\".\n- For each anchor, all other peaks $(k_b, m_b)$ are considered as potential \"targets\".\n- A target is valid if its time offset from the anchor, $\\Delta m = m_b - m_a$, falls within the specified range: $1 \\le \\Delta m \\le 10$.\n- For a given anchor, all valid targets are collected. These target candidates are then sorted in descending order based on their spectrogram magnitude, $S[k_b, m_b]$.\n- The top $K=5$ targets are selected. If fewer than $K$ targets exist, all are selected.\n- For each selected anchor-target pair, a hash triple $h = (k_a, k_b, \\Delta m)$ is formed and added to the signal's fingerprint.\n\n**5. Matching and Identification**\nThe final step is to match each query fingerprint against the set of reference fingerprints.\n- The fingerprints, which are multisets, are efficiently represented using frequency maps (e.g., Python's `collections.Counter`).\n- For each query $Q_j$ and each reference $R_i$, the matching score $m(\\mathcal{F}_{Q_j}, \\mathcal{F}_{R_i})$ is computed. This score is the sum of minimum counts for each common hash, which is equivalent to the size of the multiset intersection.\n- For a given query $Q_j$, we find the reference index $i^\\star$ that maximizes the score: $i^\\star = \\arg\\max_i m(\\mathcal{F}_{Q_j}, \\mathcal{F}_{R_i})$.\n- This match is confirmed only if the maximum score is greater than or equal to the minimum threshold: $\\max_i m(\\mathcal{F}_{Q_j}, \\mathcal{F}_{R_i}) \\ge M_{\\min} = 10$.\n- If the condition is met, the predicted index is $i^\\star$. Otherwise, the prediction is $-1$.\n\nThis procedure is applied to all queries $Q_0$ through $Q_4$, and the resulting list of predicted indices is formatted as the final output. The design is robust to time shifts and amplitude scaling by construction, as the hashes depend on relative time differences and frequency bin indices, not absolute time or amplitude. It is correctly not robust to pitch shifts, which alter the frequency bin indices $k$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import signal\nfrom scipy.ndimage import maximum_filter\nfrom collections import Counter\n\ndef solve():\n    \"\"\"\n    Solves the audio fingerprinting problem as specified.\n    \"\"\"\n\n    #\n    # Global Parameters\n    #\n    FS = 8000  # Sampling frequency in Hz\n    N = 1024  # Window length in samples\n    H = 256  # Hop size in samples\n    \n    # Peak finding parameters\n    ALPHA = 0.1  # Relative threshold for peak magnitude\n    DELTA_F = 5  # Frequency neighborhood in bins\n    DELTA_T = 3  # Time neighborhood in frames\n    \n    # Fingerprinting parameters\n    T_MIN = 1  # Minimum time delta in frames\n    T_MAX = 10  # Maximum time delta in frames\n    K_TARGETS = 5  # Max number of targets per anchor\n    \n    # Matching parameters\n    M_MIN = 10  # Minimum match score\n\n    def generate_signals():\n        \"\"\"Generates all reference and query signals.\"\"\"\n        signals = {}\n        T_R = 3.0\n        T_Q = 1.5\n\n        # Reference Signals\n        t_r = np.arange(0, T_R, 1 / FS)\n        signals['R0'] = np.sin(2 * np.pi * 440 * t_r) + 0.7 * np.sin(2 * np.pi * 660 * t_r)\n        signals['R1'] = np.sin(2 * np.pi * 554.365 * t_r) + 0.6 * np.sin(2 * np.pi * 659.255 * t_r)\n        signals['R2'] = np.sin(2 * np.pi * 300 * t_r) + 0.6 * np.sin(2 * np.pi * 900 * t_r)\n\n        # Query Signals\n        # Q0: Excerpt of R0 with noise\n        t_q0 = np.arange(0.8, 2.3, 1 / FS)\n        x_q0 = np.sin(2 * np.pi * 440 * t_q0) + 0.7 * np.sin(2 * np.pi * 660 * t_q0)\n        np.random.seed(0) # for reproducibility\n        noise = np.random.normal(0, 0.02, len(x_q0))\n        signals['Q0'] = x_q0 + noise\n\n        # Q1: Excerpt of R1\n        t_q1 = np.arange(0.5, 2.0, 1 / FS)\n        signals['Q1'] = np.sin(2 * np.pi * 554.365 * t_q1) + 0.6 * np.sin(2 * np.pi * 659.255 * t_q1)\n\n        # Q2: Excerpt of R2, scaled\n        t_q2 = np.arange(1.0, 2.5, 1 / FS)\n        signals['Q2'] = 0.5 * (np.sin(2 * np.pi * 300 * t_q2) + 0.6 * np.sin(2 * np.pi * 900 * t_q2))\n        \n        # Q3: Pitch-shifted R0\n        t_q = np.arange(0, T_Q, 1 / FS)\n        signals['Q3'] = np.sin(2 * np.pi * 484 * t_q) + 0.7 * np.sin(2 * np.pi * 726 * t_q)\n\n        # Q4: Silence\n        signals['Q4'] = np.zeros(int(T_Q * FS))\n\n        return signals\n\n    def compute_fingerprint(x):\n        \"\"\"Computes the fingerprint for a single discrete-time signal x.\"\"\"\n        \n        # Step 1: STFT\n        _, _, Zxx = signal.stft(\n            x,\n            fs=FS,\n            window='hann',\n            nperseg=N,\n            noverlap=N - H,\n            nfft=N,\n            boundary=None,\n            padded=False\n        )\n        S = np.abs(Zxx)\n\n        # Handle silence case\n        max_S = S.max()\n        if max_S == 0:\n            return []\n\n        # Step 2: Peak Finding\n        # Create a boolean mask for peaks\n        # Condition 1: Magnitude threshold\n        threshold = max_S * ALPHA\n        peaks_mask = (S >= threshold)\n        \n        # Condition 2: Local maximum\n        S_max_filtered = maximum_filter(S, size=(2 * DELTA_F + 1, 2 * DELTA_T + 1), mode='constant')\n        peaks_mask = (S == S_max_filtered)\n        \n        # Get peak coordinates\n        peak_coords = np.argwhere(peaks_mask) # (k, m) pairs\n        \n        # Step 3: Fingerprint (Hash) Generation\n        hashes = []\n        # Sort peaks by time frame index for efficient pairing\n        peak_coords = sorted(peak_coords, key=lambda p: p[1])\n        num_peaks = len(peak_coords)\n\n        for i in range(num_peaks):\n            k_a, m_a = peak_coords[i]\n            \n            candidate_targets = []\n            for j in range(i + 1, num_peaks):\n                k_b, m_b = peak_coords[j]\n                delta_m = m_b - m_a\n                \n                if T_MIN = delta_m = T_MAX:\n                    magnitude_b = S[k_b, m_b]\n                    candidate_targets.append(((k_b, m_b), magnitude_b))\n                \n                # Optimization: since peaks are sorted by time, we can break early\n                if delta_m > T_MAX:\n                    break\n            \n            # Sort candidate targets by magnitude and select top K\n            candidate_targets.sort(key=lambda item: item[1], reverse=True)\n            \n            for (k_b, m_b), _ in candidate_targets[:K_TARGETS]:\n                delta_m = m_b - m_a\n                hashes.append((int(k_a), int(k_b), int(delta_m)))\n                \n        return hashes\n\n    # --- Main Execution Logic ---\n    \n    # Generate signals\n    all_signals = generate_signals()\n    \n    # Compute fingerprints for reference tracks\n    ref_fingerprints = []\n    for i in range(3):\n        fp = compute_fingerprint(all_signals[f'R{i}'])\n        ref_fingerprints.append(Counter(fp))\n\n    # Process queries\n    results = []\n    for j in range(5):\n        query_fp_list = compute_fingerprint(all_signals[f'Q{j}'])\n        query_fp_counter = Counter(query_fp_list)\n        \n        scores = []\n        for ref_fp_counter in ref_fingerprints:\n            intersection = query_fp_counter  ref_fp_counter\n            score = sum(intersection.values())\n            scores.append(score)\n            \n        max_score = 0\n        if scores:\n            max_score = max(scores)\n        \n        if max_score >= M_MIN:\n            best_match_idx = np.argmax(scores)\n            results.append(best_match_idx)\n        else:\n            results.append(-1)\n            \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}