{
    "hands_on_practices": [
        {
            "introduction": "The Fourier transform exhibits a profound symmetry between the time and frequency domains, elegantly captured by the duality property. This property states that applying the Fourier transform twice to a function essentially returns the original function, but time-reversed and scaled. In this practice, you will move beyond the abstract mathematical proof by numerically verifying this property from first principles . By implementing the transform integral yourself and testing it on various functions, you will gain a concrete understanding of the transform's definition and develop an intuition for this fundamental symmetry.",
            "id": "2395492",
            "problem": "Consider the continuous-time Fourier transform defined for an absolutely integrable function $f(t)$ by\n$$\\mathcal{F}\\{f\\}(\\omega) = \\int_{-\\infty}^{\\infty} f(t)\\, e^{-i \\omega t}\\, dt,$$\nwhere $\\omega$ is the angular frequency in radians, and $i$ is the imaginary unit. The duality property states that applying the same transform twice yields\n$$\\mathcal{F}\\{\\mathcal{F}\\{f\\}\\}(t) = 2\\pi\\, f(-t).$$\nYour task is to numerically verify this property by computing $\\mathcal{F}\\{f\\}(\\omega)$ and then $\\mathcal{F}\\{\\mathcal{F}\\{f\\}\\}(t)$ as integrals, and comparing the result against $2\\pi\\, f(-t)$ on a specified finite interval for time $t$ and angular frequency $\\omega$. All angles are to be treated in radians.\n\nYou must implement a single program that, for each test case described below, approximates the two integrals directly from first principles and reports the maximum absolute discrepancy between the numerically obtained $\\mathcal{F}\\{\\mathcal{F}\\{f\\}\\}(t)$ and $2\\pi\\, f(-t)$ over a specified central subinterval of the time grid. The discrepancy for a test case is defined as\n$$\\max_{t \\in [-\\alpha T, \\alpha T]} \\left| \\widehat{\\widehat{f}}(t) - 2\\pi f(-t) \\right|,$$\nwhere $\\widehat{\\widehat{f}}(t)$ denotes the second transform computed by numerically evaluating the integral $\\int_{-W}^{W} \\mathcal{F}\\{f\\}(\\omega) e^{-i t \\omega} d\\omega$ on the given angular frequency grid, $T$ and $W$ are the given finite half-widths for time and angular frequency integration, respectively, and $\\alpha \\in (0,1)$ specifies the central fraction of the time interval to be used for the error computation. Each integral must be evaluated over the corresponding specified finite interval using a uniform grid with the given number of points; all computations must use the same kernel $e^{-i \\cdot \\cdot}$ as defined above. No other assumptions are to be made.\n\nTest suite (for each case, specify $f(t)$, parameters for $f$, the time-domain half-width $T$, the angular-frequency half-width $W$, the number of grid points $N$ in each domain, and the central fraction $\\alpha$):\n- Case A (general, smooth, even): $f(t) = e^{-a t^2}$ with $a = 0.5$, use $T = 12.0$, $W = 12.0$, $N = 801$, and $\\alpha = 0.9$.\n- Case B (odd function): $f(t) = t \\, e^{-a t^2}$ with $a = 1.0$, use $T = 10.0$, $W = 10.0$, $N = 801$, and $\\alpha = 0.9$.\n- Case C (oscillatory, modulated): $f(t) = \\cos(\\omega_0 t)\\, e^{-a t^2}$ with $a = 0.3$ and $\\omega_0 = 5.0$, use $T = 14.0$, $W = 14.0$, $N = 1001$, and $\\alpha = 0.85$.\n\nFor each test case:\n- Build a uniform time grid on $[-T,T]$ with $N$ points and a uniform angular frequency grid on $[-W,W]$ with $N$ points.\n- Numerically approximate $\\mathcal{F}\\{f\\}(\\omega)$ over the angular frequency grid by evaluating the defining integral over the time grid.\n- Numerically approximate $\\mathcal{F}\\{\\mathcal{F}\\{f\\}\\}(t)$ over the time grid by evaluating the defining integral over the angular frequency grid.\n- Compute the maximum absolute discrepancy on the central time subinterval $[-\\alpha T, \\alpha T]$.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as $[\\text{Case A result}, \\text{Case B result}, \\text{Case C result}]$. Each result must be a float printed in scientific notation with exactly six digits after the decimal point (for example, $[1.234567e-04,2.345678e-05,3.456789e-06]$). All angles must be in radians throughout.",
            "solution": "The problem statement is subjected to validation and is found to be scientifically sound, well-posed, and objective. It presents a verifiable task within the domain of computational engineering, specifically related to the numerical verification of a fundamental property of the continuous-time Fourier transform. All necessary parameters and definitions are provided. The problem is therefore valid, and a solution is provided below.\n\nThe core of the problem is to numerically verify the duality property of the Fourier transform, $\\mathcal{F}\\{\\mathcal{F}\\{f\\}\\}(t) = 2\\pi f(-t)$, for three distinct functions. The verification involves a two-step numerical integration process implemented from first principles.\n\nFirst, the time domain is discretized. A uniform grid of $N$ points, denoted $\\{t_k\\}$, is established over the finite interval $[-T, T]$. The grid spacing is $\\Delta t = \\frac{2T}{N-1}$. Similarly, the angular frequency domain is discretized into a uniform grid of $N$ points, $\\{\\omega_j\\}$, over the interval $[-W, W]$, with spacing $\\Delta \\omega = \\frac{2W}{N-1}$.\n\nThe first stage is the numerical computation of the Fourier transform of the given function $f(t)$, denoted as $\\widehat{f}(\\omega) = \\mathcal{F}\\{f\\}(\\omega)$. The defining integral, $\\mathcal{F}\\{f\\}(\\omega) = \\int_{-\\infty}^{\\infty} f(t)\\, e^{-i \\omega t}\\, dt$, is approximated over the finite time interval for each discrete frequency $\\omega_j$:\n$$ \\widehat{f}(\\omega_j) \\approx \\int_{-T}^{T} f(t) e^{-i \\omega_j t} dt $$\nThis integral is calculated using the trapezoidal rule over the time grid $\\{t_k\\}$. The aforementioned rule approximates the integral of a function $g(x)$ over a set of ordered points $\\{x_i\\}$ with non-uniform spacing. For a uniform grid, it is equivalent to $\\int_a^b g(x) dx \\approx \\Delta x \\left( \\frac{g(x_0) + g(x_{N-1})}{2} + \\sum_{i=1}^{N-2} g(x_i) \\right)$. We utilize the `scipy.integrate.trapezoid` function which implements this rule.\n\nThe second stage is the computation of the Fourier transform of the result from the first stage, which we denote $\\widehat{\\widehat{f}}(t) = \\mathcal{F}\\{\\widehat{f}\\}(t)$. The previously computed discrete values $\\widehat{f}(\\omega_j)$ are treated as samples of a function defined on the frequency grid. The integral is approximated over the finite frequency interval:\n$$ \\widehat{\\widehat{f}}(t_k) \\approx \\int_{-W}^{W} \\widehat{f}(\\omega) e^{-i t_k \\omega} d\\omega $$\nThis integral is computed for each discrete time point $t_k$ using the trapezoidal rule over the frequency grid $\\{\\omega_j\\}$, with the values of $\\widehat{f}(\\omega)$ in the integrand being the numerical results from the first stage.\n\nFor computational efficiency, this two-stage process is vectorized. A kernel matrix $K$ of size $N \\times N$ is constructed with elements $K_{kj} = e^{-i t_k \\omega_j}$. The array of values for the first transform, $\\widehat{f}(\\omega_j)$, is computed by performing an operation equivalent to a matrix-vector multiplication involving the sampled function $f(t_k)$ and the kernel, followed by numerical integration along the time axis. The second transform is computed similarly by using the resulting transform values $\\widehat{f}(\\omega_j)$ and integrating along the frequency axis.\n\nFinally, the numerical result $\\widehat{\\widehat{f}}(t_k)$ is compared to the exact theoretical result given by the duality property, which is $g(t_k) = 2\\pi f(-t_k)$. The discrepancy is quantified by the maximum absolute error over the specified central subinterval of the time grid, $[-\\alpha T, \\alpha T]$:\n$$ \\text{Discrepancy} = \\max_{k \\text{ s.t. } t_k \\in [-\\alpha T, \\alpha T]} \\left| \\widehat{\\widehat{f}}(t_k) - 2\\pi f(-t_k) \\right| $$\nThis value is computed for each of the three test cases provided in the problem statement. The primary sources of error are the truncation of the infinite integration domains to finite intervals $[-T, T]$ and $[-W, W]$, and the discretization error inherent to the trapezoidal integration rule.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import trapezoid\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It computes the discrepancy for the Fourier transform duality property.\n    \"\"\"\n\n    def calculate_discrepancy(f_func, T, W, N, alpha):\n        \"\"\"\n        Calculates the maximum absolute discrepancy for a single test case.\n\n        Args:\n            f_func (callable): The function f(t) to be transformed.\n            T (float): The half-width of the time integration interval.\n            W (float): The half-width of the frequency integration interval.\n            N (int): The number of points in the grids.\n            alpha (float): The central fraction of the time interval for error computation.\n\n        Returns:\n            float: The maximum absolute discrepancy.\n        \"\"\"\n        # Step 1: Create uniform grids for time and frequency\n        t_grid = np.linspace(-T, T, N)\n        w_grid = np.linspace(-W, W, N)\n\n        # Evaluate the input function on the time grid\n        f_on_t_grid = f_func(t_grid)\n\n        # For efficient computation, we vectorize the two-stage integration.\n        # Create kernel matrix K_kj = exp(-i * t_k * w_j)\n        t_col = t_grid.reshape((N, 1))\n        w_row = w_grid.reshape((1, N))\n        kernel = np.exp(-1j * t_col @ w_row)\n\n        # Step 2: First Fourier Transform\n        # Compute F_hat(w_j) = integral(f(t) * exp(-i * w_j * t), t) from -T to T\n        # The integrands for all w_j are computed at once.\n        # Shape: (N_t, N_w), where N_t=N and N_w=N.\n        integrands1 = f_on_t_grid.reshape((N, 1)) * kernel\n        \n        # Integrate along the time axis (axis=0) to get the transform at each w_j\n        F_hat_on_w_grid = trapezoid(integrands1, t_grid, axis=0)\n\n        # Step 3: Second Fourier Transform\n        # Compute F_hat_hat(t_k) = integral(F_hat(w) * exp(-i * t_k * w), w) from -W to W\n        # The integrands for all t_k are computed at once.\n        # Shape: (N_t, N_w)\n        integrands2 = F_hat_on_w_grid.reshape((1, N)) * kernel\n        \n        # Integrate along the frequency axis (axis=1) to get the double transform at each t_k\n        F_hat_hat_on_t_grid = trapezoid(integrands2, w_grid, axis=1)\n\n        # Step 4: Compute the theoretical result based on the duality property\n        # Theoretical result is 2 * pi * f(-t)\n        theoretical_result = 2 * np.pi * f_func(-t_grid)\n\n        # Step 5: Compute the maximum discrepancy on the central subinterval\n        # Identify indices within the central interval [-alpha*T, alpha*T]\n        central_indices = np.where(np.abs(t_grid) = alpha * T)\n\n        # Calculate the absolute difference between numerical and theoretical results\n        # The result of the transform might have a small imaginary part due to numerical errors.\n        # np.abs computes the complex magnitude, as required.\n        abs_diff = np.abs(F_hat_hat_on_t_grid[central_indices] - theoretical_result[central_indices])\n        \n        max_discrepancy = np.max(abs_diff)\n        \n        return max_discrepancy\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: Gaussian function\n        {\"f\": lambda t: np.exp(-0.5 * t**2), \"T\": 12.0, \"W\": 12.0, \"N\": 801, \"alpha\": 0.9},\n        # Case B: Odd function\n        {\"f\": lambda t: t * np.exp(-1.0 * t**2), \"T\": 10.0, \"W\": 10.0, \"N\": 801, \"alpha\": 0.9},\n        # Case C: Modulated Gaussian\n        {\"f\": lambda t: np.cos(5.0 * t) * np.exp(-0.3 * t**2), \"T\": 14.0, \"W\": 14.0, \"N\": 1001, \"alpha\": 0.85},\n    ]\n\n    results = []\n    for case in test_cases:\n        discrepancy = calculate_discrepancy(case[\"f\"], case[\"T\"], case[\"W\"], case[\"N\"], case[\"alpha\"])\n        results.append(f\"{discrepancy:.6e}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While Fourier series are incredibly powerful for representing periodic functions, their convergence behavior near discontinuities reveals a fascinating subtlety known as the Gibbs phenomenon. When a truncated Fourier series approximates a function with a jump, it consistently overshoots the true value, and this overshoot does not diminish even as more terms are added to the series. This hands-on exercise allows you to observe and quantify this behavior for a classic sawtooth wave . By deriving the Fourier coefficients and numerically calculating the partial sums, you will see firsthand how smooth sinusoids struggle to represent sharp edges and gain a deeper appreciation for the nuances of function approximation.",
            "id": "2395550",
            "problem": "Consider the real-valued sawtooth wave defined by the function $f:\\mathbb{R}\\to\\mathbb{R}$ with fundamental period $2\\pi$ and one period given by $f(x)=\\dfrac{x}{\\pi}$ for $x\\in(-\\pi,\\pi)$, extended periodically so that $f(x+2\\pi)=f(x)$ for all $x\\in\\mathbb{R}$. All angles must be interpreted in radians. For each positive integer $N$, let $S_N(x)$ denote the $N$-th partial sum of the Fourier series of $f$, constructed from the Fourier series definition: \n$$\na_0=\\frac{1}{\\pi}\\int_{-\\pi}^{\\pi} f(x)\\,dx,\\quad a_k=\\frac{1}{\\pi}\\int_{-\\pi}^{\\pi} f(x)\\cos(kx)\\,dx,\\quad b_k=\\frac{1}{\\pi}\\int_{-\\pi}^{\\pi} f(x)\\sin(kx)\\,dx,\n$$\nfor $k\\in\\mathbb{N}$, and\n$$\nS_N(x)=\\frac{a_0}{2}+\\sum_{k=1}^{N}\\left(a_k\\cos(kx)+b_k\\sin(kx)\\right).\n$$\nAt the jump discontinuity at $x=\\pi$ of the $2\\pi$-periodic extension, the left-hand limit is $\\lim_{x\\to\\pi^-}f(x)=1$ and the right-hand limit is $\\lim_{x\\to\\pi^+}f(x)=-1$, so the jump magnitude is $J=2$. To quantify the Gibbs phenomenon near this jump, define the overshoot ratio for the $N$-th partial sum by\n$$\n\\rho_N=\\frac{\\max\\{S_N(x)-1: x\\in(\\pi-\\frac{\\pi}{2},\\pi)\\}_+}{J},\n$$\nwhere $(z)_+=\\max(z,0)$ and $J=2$. The task is to compute $\\rho_N$ for a given set of $N$ values. Use the following test suite of partial-sum orders: $N\\in\\{1,5,25,101\\}$. Your program must produce a single line of output containing the results as a comma-separated list of floating-point numbers, rounded to $6$ decimal places, enclosed in square brackets, in the same order as the test suite (for example, $[r_1,r_2,r_3,r_4]$). No other output is permitted.",
            "solution": "The supplied problem is subjected to rigorous validation and is determined to be valid. It is scientifically grounded in the established theory of Fourier analysis, mathematically well-posed, and formulated with objective, unambiguous language. All necessary information is provided for a unique solution. We may therefore proceed with the derivation and computation.\n\nThe problem requires the computation of the Gibbs phenomenon overshoot ratio for a sawtooth wave. The function is given as $f(x) = \\frac{x}{\\pi}$ for $x \\in (-\\pi, \\pi)$, with a fundamental period of $T = 2\\pi$. The analysis will proceed in steps: first, the determination of the Fourier series coefficients; second, the construction of the $N$-th partial sum $S_N(x)$; third, the analytical location of the maximum overshoot; and finally, the computation of the specified ratio $\\rho_N$ for the given values of $N$.\n\nFirst, we calculate the Fourier coefficients $a_0$, $a_k$, and $b_k$ for $k \\in \\mathbb{N}$. The function $f(x)=x/\\pi$ is an odd function, since $f(-x) = (-x)/\\pi = -f(x)$. The integral of an odd function over a symmetric interval such as $[-\\pi, \\pi]$ is zero.\nThe coefficient $a_0$ is given by:\n$$ a_0 = \\frac{1}{\\pi} \\int_{-\\pi}^{\\pi} f(x) \\,dx = \\frac{1}{\\pi} \\int_{-\\pi}^{\\pi} \\frac{x}{\\pi} \\,dx = 0 $$\nThe coefficients $a_k$ are given by:\n$$ a_k = \\frac{1}{\\pi} \\int_{-\\pi}^{\\pi} f(x) \\cos(kx) \\,dx = \\frac{1}{\\pi} \\int_{-\\pi}^{\\pi} \\frac{x}{\\pi} \\cos(kx) \\,dx $$\nSince $x/\\pi$ is an odd function and $\\cos(kx)$ is an even function, their product is odd. The integral of this odd product over the symmetric interval $[-\\pi, \\pi]$ is zero. Thus, $a_k = 0$ for all $k \\geq 1$.\n\nThe coefficients $b_k$ are given by:\n$$ b_k = \\frac{1}{\\pi} \\int_{-\\pi}^{\\pi} f(x) \\sin(kx) \\,dx = \\frac{1}{\\pi} \\int_{-\\pi}^{\\pi} \\frac{x}{\\pi} \\sin(kx) \\,dx $$\nThe product of two odd functions, $x/\\pi$ and $\\sin(kx)$, is an even function. Therefore, the integral is non-zero and can be simplified:\n$$ b_k = \\frac{2}{\\pi^2} \\int_{0}^{\\pi} x \\sin(kx) \\,dx $$\nWe use integration by parts, $\\int u \\,dv = uv - \\int v \\,du$, with $u=x$ and $dv=\\sin(kx)dx$. This yields $du=dx$ and $v = -\\frac{1}{k}\\cos(kx)$.\n$$ \\int_{0}^{\\pi} x \\sin(kx) \\,dx = \\left[ -\\frac{x}{k}\\cos(kx) \\right]_{0}^{\\pi} - \\int_{0}^{\\pi} \\left(-\\frac{1}{k}\\cos(kx)\\right) \\,dx $$\n$$ = -\\frac{\\pi}{k}\\cos(k\\pi) + \\frac{1}{k} \\int_{0}^{\\pi} \\cos(kx) \\,dx = -\\frac{\\pi}{k}(-1)^k + \\frac{1}{k} \\left[ \\frac{1}{k}\\sin(kx) \\right]_{0}^{\\pi} $$\n$$ = \\frac{\\pi}{k}(-1)^{k+1} + \\frac{1}{k^2}(\\sin(k\\pi) - \\sin(0)) = \\frac{\\pi}{k}(-1)^{k+1} $$\nSubstituting this back into the expression for $b_k$:\n$$ b_k = \\frac{2}{\\pi^2} \\left( \\frac{\\pi}{k}(-1)^{k+1} \\right) = \\frac{2}{\\pi k}(-1)^{k+1} $$\n\nThe $N$-th partial sum of the Fourier series, $S_N(x)$, is therefore:\n$$ S_N(x) = \\frac{a_0}{2} + \\sum_{k=1}^{N} (a_k \\cos(kx) + b_k \\sin(kx)) = \\sum_{k=1}^{N} \\frac{2}{\\pi k}(-1)^{k+1} \\sin(kx) $$\n\nThe problem asks for the overshoot ratio $\\rho_N$, defined as:\n$$ \\rho_N = \\frac{\\max\\{S_N(x)-1: x \\in (\\pi/2, \\pi)\\}_+}{2} $$\nTo find this, we must find the maximum value of $S_N(x)$ on the open interval $x \\in (\\pi/2, \\pi)$. We find the critical points by setting the derivative of $S_N(x)$ to zero:\n$$ \\frac{dS_N(x)}{dx} = \\frac{d}{dx} \\left( \\frac{2}{\\pi} \\sum_{k=1}^{N} \\frac{(-1)^{k+1}}{k} \\sin(kx) \\right) = \\frac{2}{\\pi} \\sum_{k=1}^{N} (-1)^{k+1} \\cos(kx) = 0 $$\nLet us analyze the sum. We use the transformation $x = \\pi - y$, where $y \\in (0, \\pi/2)$.\n$$ \\cos(kx) = \\cos(k(\\pi - y)) = \\cos(k\\pi)\\cos(ky) + \\sin(k\\pi)\\sin(ky) = (-1)^k\\cos(ky) $$\nThe sum becomes:\n$$ \\sum_{k=1}^{N} (-1)^{k+1} (-1)^k \\cos(ky) = \\sum_{k=1}^{N} (-1) \\cos(ky) = -\\sum_{k=1}^{N} \\cos(ky) $$\nThe critical points are the solutions to $\\sum_{k=1}^{N} \\cos(ky) = 0$. This is a known sum, which has a closed form:\n$$ \\sum_{k=1}^{N} \\cos(ky) = \\text{Re}\\left(\\sum_{k=1}^{N} e^{iky}\\right) = \\frac{\\sin(Ny/2)\\cos((N+1)y/2)}{\\sin(y/2)} $$\nThis expression is zero when $\\sin(Ny/2) = 0$ or $\\cos((N+1)y/2) = 0$, for $y \\neq 0$.\nThe solutions are $y = 2m\\pi/N$ and $y = (2m+1)\\pi/(N+1)$ for integer $m$.\nThe extrema of $S_N(x)$ near $x=\\pi$ correspond to these values of $y=\\pi-x$. The Gibbs overshoot manifests as the first peak to the left of the discontinuity. This corresponds to the smallest positive value of $y$, which is $y = \\pi/(N+1)$ for $m=0$. The location of this first maximum is $x_{max} = \\pi - \\frac{\\pi}{N+1}$.\nFor $N1$, this point lies within the interval $(\\pi/2, \\pi)$. For $N=1$, the location is $x=\\pi/2$, which is on the boundary of the interval.\n\nCase $N=1$: $S_1(x) = \\frac{2}{\\pi}\\sin(x)$. On the interval $(\\pi/2, \\pi)$, its derivative $S'_1(x) = \\frac{2}{\\pi}\\cos(x)$ is strictly negative. Thus, $S_1(x)$ is a decreasing function on this interval. The supremum is at the boundary $x=\\pi/2$, with value $S_1(\\pi/2)=2/\\pi \\approx 0.637  1$. Consequently, $S_1(x) - 1  0$ for all $x \\in (\\pi/2, \\pi)$. The term $\\max\\{S_1(x)-1, \\dots\\}_+$ is zero, so $\\rho_1 = 0$.\n\nCase $N  1$: The maximum value of $S_N(x)$ in the interval occurs at $x_{max} = \\pi - \\frac{\\pi}{N+1}$. We evaluate $S_N(x_{max})$:\n$$ S_N(x_{max}) = \\frac{2}{\\pi} \\sum_{k=1}^{N} \\frac{(-1)^{k+1}}{k} \\sin\\left(k\\left(\\pi - \\frac{\\pi}{N+1}\\right)\\right) $$\nUsing the identity $\\sin(k\\pi - \\alpha) = (-1)^{k+1}\\sin(\\alpha)$:\n$$ \\sin\\left(k\\pi - \\frac{k\\pi}{N+1}\\right) = (-1)^{k+1}\\sin\\left(\\frac{k\\pi}{N+1}\\right) $$\nThe expression for $S_N(x_{max})$ simplifies to:\n$$ S_N(x_{max}) = \\frac{2}{\\pi} \\sum_{k=1}^{N} \\frac{(-1)^{k+1}}{k} (-1)^{k+1}\\sin\\left(\\frac{k\\pi}{N+1}\\right) = \\frac{2}{\\pi} \\sum_{k=1}^{N} \\frac{1}{k}\\sin\\left(\\frac{k\\pi}{N+1}\\right) $$\nThis is the maximum value of the partial sum. The overshoot is $O_N = S_N(x_{max}) - 1$. Since this value is positive for $N  1$, the ratio is $\\rho_N = (S_N(x_{max}) - 1)/2$.\n\nThe algorithm for computation is as follows:\n1. For $N=1$, $\\rho_1=0$.\n2. For $N \\in \\{5, 25, 101\\}$, compute $S_{N,\\max} = \\frac{2}{\\pi} \\sum_{k=1}^{N} \\frac{1}{k}\\sin(\\frac{k\\pi}{N+1})$.\n3. Compute $\\rho_N = (S_{N,\\max} - 1)/2$.\n\nThis provides a complete analytical foundation for the implementing code.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Gibbs phenomenon overshoot ratio for a sawtooth wave's Fourier series.\n\n    The sawtooth wave is f(x) = x/pi on (-pi, pi), with period 2*pi.\n    The N-th partial sum is S_N(x) = sum_{k=1 to N} (2/(pi*k))*(-1)^(k+1)*sin(kx).\n    The overshoot ratio is rho_N = max(S_N(x_max) - 1, 0) / 2, where x_max is the location\n    of the first peak to the left of the jump at x=pi.\n\n    The maximum for S_N(x) on (pi/2, pi) is analytically found to be at\n    x_max = pi - pi/(N+1) for N  1.\n    For N=1, the maximum on the open interval does not exist, and the supremum\n    is less than 1, resulting in zero overshoot.\n    \"\"\"\n\n    test_cases = [1, 5, 25, 101]\n    results = []\n\n    for N in test_cases:\n        if N == 1:\n            # For N=1, S_1(x) = (2/pi)*sin(x). On the interval (pi/2, pi), this\n            # function is strictly decreasing. The supremum is S_1(pi/2) = 2/pi, which\n            # is less than 1. Thus, the overshoot (S_1(x) - 1) is always negative\n            # on the interval. The definition max(overshoot, 0) leads to 0.\n            rho = 0.0\n        else:\n            # For N  1, the maximum of S_N(x) in the interval (pi/2, pi) occurs\n            # at x = pi - pi/(N+1).\n            # The value at this maximum is S_N(x_max).\n            # S_N(x_max) = (2/pi) * sum_{k=1 to N} (1/k) * sin(k*pi/(N+1)).\n            k_vals = np.arange(1, N + 1)\n            \n            # The argument to the sine function in the simplified sum\n            sin_arg = k_vals * np.pi / (N + 1)\n            \n            # The terms of the sum\n            terms = np.sin(sin_arg) / k_vals\n            \n            # The maximum value of the N-th partial sum\n            s_n_max = (2 / np.pi) * np.sum(terms)\n            \n            # The problem defines the overshoot relative to the limit f(pi-) = 1.\n            overshoot = s_n_max - 1\n            \n            # The jump J is 2. The overshoot ratio rho_N includes max(overshoot, 0).\n            # For N  1, the overshoot is positive.\n            rho = overshoot / 2.0\n        \n        results.append(rho)\n\n    # Format the results to 6 decimal places as required.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    \n    # Print the final output in the specified format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A central task in signal processing is distinguishing between two closely spaced frequencies, akin to discerning two musical notes that are very close in pitch. In practice, our ability to do so is limited by the finite duration of our signal observation, which causes spectral \"blurring\" or leakage. This exercise  simulates this exact scenario, challenging you to resolve two nearby sinusoids in a noisy signal. You will explore how applying different window functions, such as the Hamming or Blackman windows, can manage spectral leakage and directly impact the resolution of the resulting spectrum, demonstrating a fundamental trade-off in practical spectral analysis.",
            "id": "2395553",
            "problem": "Write a complete program that, for a discrete-time signal composed of two closely spaced sinusoids corrupted by additive noise and multiplied by a window function, determines whether the two sinusoids are resolved according to a precise spectral criterion, for specified parameter sets. Use first principles based on the definition of the Discrete Fourier Transform (DFT) and well-defined window functions.\n\nThe discrete-time signal is\n$$\nx[n] \\;=\\; A \\cos\\!\\left(2\\pi \\frac{f_1}{F_s} n \\right) \\;+\\; A \\cos\\!\\left(2\\pi \\frac{f_2}{F_s} n \\right) \\;+\\; \\sigma\\, z[n], \\quad n=0,1,\\dots,N-1,\n$$\nwhere $A$ is the sinusoid amplitude, $F_s$ is the sampling frequency in hertz, $f_1$ and $f_2$ are sinusoid frequencies in hertz, $\\sigma$ is the noise standard deviation, and $z[n]$ is a deterministic pseudorandom sequence with a standard normal distribution (zero mean and unit variance). All angles are in radians.\n\nThe deterministic pseudorandom sequence $z[n]$ must be constructed as follows for each test case:\n- Generate a sequence of independent uniform random variables $u[n]$ in the open interval $(0,1)$ using a Linear Congruential Generator (LCG) defined by\n$$\nx_{n+1} \\equiv (a x_n + c) \\bmod m,\n$$\nwith modulus $m=2^{32}$, multiplier $a=1664525$, increment $c=1013904223$, and a given seed $x_0$. For each $n$, map $x_n$ to $u[n]$ by\n$$\nu[n] \\;=\\; \\frac{x_n + 0.5}{m}.\n$$\n- Transform $u[n]$ to a standard normal variate by $z[n] = \\Phi^{-1}(u[n])$, where $\\Phi^{-1}$ is the inverse cumulative distribution function of the standard normal distribution.\n\nFor a window $w[n]$, define the windowed sequence $y[n] = w[n]\\,x[n]$. Consider the $N$-point Discrete Fourier Transform (DFT)\n$$\nY[k] \\;=\\; \\sum_{n=0}^{N-1} y[n]\\, e^{-j 2\\pi kn/N}, \\quad k=0,1,\\dots,N-1.\n$$\nDefine the one-sided magnitude spectrum for real-valued signals as\n$$\nM[k] \\;=\\; |Y[k]|, \\quad k=0,1,\\dots,\\left\\lfloor \\frac{N}{2} \\right\\rfloor.\n$$\n\nUse the following two window functions:\n- Hamming window: $w_{\\mathrm{Ham}}[n] = 0.54 - 0.46 \\cos\\!\\left(\\frac{2\\pi n}{N-1}\\right)$ for $n=0,1,\\dots,N-1$.\n- Blackman window: $w_{\\mathrm{Blk}}[n] = 0.42 - 0.5 \\cos\\!\\left(\\frac{2\\pi n}{N-1}\\right) + 0.08 \\cos\\!\\left(\\frac{4\\pi n}{N-1}\\right)$ for $n=0,1,\\dots,N-1$.\n\nDefine the target DFT bin indices associated with $f_1$ and $f_2$ by\n$$\nk_1 \\;=\\; \\left\\lfloor \\frac{f_1 N}{F_s} + \\tfrac{1}{2} \\right\\rfloor, \n\\quad\nk_2 \\;=\\; \\left\\lfloor \\frac{f_2 N}{F_s} + \\tfrac{1}{2} \\right\\rfloor,\n$$\nthat is, the nearest integers to the exact frequencies mapped to the $N$-point DFT grid.\n\nResolution criterion. The two sinusoids are declared resolved under window $w[n]$ if and only if there exist two distinct indices $k_a$ and $k_b$ in the set $\\{1,2,\\dots,\\lfloor N/2 \\rfloor - 1\\}$ such that:\n1. $k_a \\neq k_b$ and both are strict local maxima of $M[k]$:\n$$\nM[k_a]  M[k_a - 1] \\;\\text{ and }\\; M[k_a]  M[k_a + 1], \\quad\nM[k_b]  M[k_b - 1] \\;\\text{ and }\\; M[k_b]  M[k_b + 1].\n$$\n2. Each is near its corresponding target bin:\n$$\n|k_a - k_1| \\le 1 \\quad \\text{and} \\quad |k_b - k_2| \\le 1.\n$$\n3. The valley between them is sufficiently deep. Let\n$$\nk_{\\min} \\in \\arg\\min_{k \\in [\\min(k_a,k_b),\\,\\max(k_a,k_b)]} M[k].\n$$\nThen\n$$\nM[k_{\\min}] \\;\\le\\; \\gamma \\cdot \\min\\{M[k_a],\\,M[k_b]\\},\n$$\nwith $\\gamma = 0.5$.\n\nYou must evaluate the resolution outcome for each of the following test cases. In every test case, use $A=1.0$ and $N=1024$. Frequencies are in hertz, and $F_s$ is in hertz. The two tones are constructed using integer-bin spacing: $f_1 = \\frac{k_1 F_s}{N}$ and $f_2 = \\frac{(k_1+\\Delta) F_s}{N}$ for the specified $k_1$ and bin separation $\\Delta$.\n\nTest suite:\n- Case $1$: $F_s=1024$, $k_1=200$, $\\Delta=3$, $\\sigma=0.01$, seed $x_0=13579$.\n- Case $2$: $F_s=1024$, $k_1=200$, $\\Delta=1$, $\\sigma=0.01$, seed $x_0=24680$.\n- Case $3$: $F_s=1024$, $k_1=150$, $\\Delta=2$, $\\sigma=0.05$, seed $x_0=12345$.\n- Case $4$: $F_s=1024$, $k_1=300$, $\\Delta=4$, $\\sigma=0.20$, seed $x_0=54321$.\n\nFor each test case, your program must compute two boolean results in the order $[$Hamming, Blackman$]$ indicating whether the pair of sinusoids is resolved with each window function according to the above criterion.\n\nFinal output format: Your program should produce a single line of output containing the results for all test cases as a comma-separated list of lists enclosed in square brackets, for example, $[[\\text{result}_{1,\\mathrm{Ham}}, \\text{result}_{1,\\mathrm{Blk}}],[\\text{result}_{2,\\mathrm{Ham}}, \\text{result}_{2,\\mathrm{Blk}}],\\dots]$, using the literal keywords True and False for booleans. No additional text should be printed.",
            "solution": "The problem presented is a well-defined exercise in computational signal processing. It is scientifically grounded, self-contained, and objective. We will proceed to construct a solution based on first principles. The task requires us to determine if two closely spaced sinusoids, embedded in noise and observed through a finite-duration window, can be resolved in the frequency domain. This is a fundamental problem in spectral estimation.\n\nThe discrete-time signal is given by the model:\n$$\nx[n] \\;=\\; A \\cos\\!\\left(2\\pi \\frac{f_1}{F_s} n \\right) \\;+\\; A \\cos\\!\\left(2\\pi \\frac{f_2}{F_s} n \\right) \\;+\\; \\sigma\\, z[n], \\quad n=0,1,\\dots,N-1\n$$\nwhere $A$ is the amplitude, $F_s$ is the sampling frequency, $f_1$ and $f_2$ are the frequencies of the two sinusoids, $\\sigma$ is the noise standard deviation, and $z[n]$ is a standard normal noise sequence.\n\nThe algorithmic solution is constructed in a sequence of logical steps:\n\n**1. Deterministic Noise Generation**\nThe noise sequence $z[n]$ is not truly random but is a deterministic pseudorandom sequence generated for reproducibility. This is a standard practice in simulation and verification. The generation proceeds in two stages:\na. A sequence of integers $x_n$ is generated using a Linear Congruential Generator (LCG):\n$$\nx_{n+1} \\equiv (a x_n + c) \\bmod m\n$$\nwith specified parameters $m=2^{32}$, $a=1664525$, $c=1013904223$, and a given integer seed $x_0$.\nb. This integer sequence is transformed into a sequence of standard normal variates $z[n]$. First, we map $x_n$ to a uniform distribution over $(0,1)$ using the given formula:\n$$\nu[n] \\;=\\; \\frac{x_n + 0.5}{m}\n$$\nThen, we apply the inverse transform sampling method. The value $u[n]$ is treated as a probability, and we find the corresponding variate $z[n]$ from a standard normal distribution using its inverse cumulative distribution function (CDF), denoted $\\Phi^{-1}$:\n$$\nz[n] = \\Phi^{-1}(u[n])\n$$\nThis is implemented using the `ppf` (percent point function) from SciPy's statistics module.\n\n**2. Signal Synthesis and Windowing**\nFor each test case, we are given the parameters $F_s$, $N$, $A$, $\\sigma$, a seed $x_0$, and the definition of the frequencies $f_1$ and $f_2$ in terms of integer bin indices $k_1$ and a separation $\\Delta$:\n$$\nf_1 = \\frac{k_1 F_s}{N}, \\quad f_2 = \\frac{(k_1+\\Delta) F_s}{N}\n$$\nThe time-domain signal $x[n]$ is constructed by summing the two cosine terms and the scaled noise sequence $z[n]$.\n\nBefore spectral analysis, the signal $x[n]$ is multiplied by a window function $w[n]$ to produce $y[n] = w[n]x[n]$. This is necessary because the Discrete Fourier Transform (DFT) assumes periodicity, and windowing mitigates the spectral leakage caused by observing a signal for a finite duration. We evaluate two standard windows:\n- Hamming: $w_{\\mathrm{Ham}}[n] = 0.54 - 0.46 \\cos\\!\\left(\\frac{2\\pi n}{N-1}\\right)$\n- Blackman: $w_{\\mathrm{Blk}}[n] = 0.42 - 0.5 \\cos\\!\\left(\\frac{2\\pi n}{N-1}\\right) + 0.08 \\cos\\!\\left(\\frac{4\\pi n}{N-1}\\right)$\n\n**3. Spectral Analysis via DFT**\nThe spectrum of the windowed signal $y[n]$ is computed using the $N$-point DFT:\n$$\nY[k] \\;=\\; \\sum_{n=0}^{N-1} y[n]\\, e^{-j 2\\pi kn/N}\n$$\nFor a real-valued input signal, the magnitude spectrum is symmetric. We are interested in the one-sided magnitude spectrum, $M[k] = |Y[k]|$, for frequency bins $k=0, 1, \\dots, \\lfloor N/2 \\rfloor$. This computation is efficiently performed using the Fast Fourier Transform (FFT) algorithm, available in NumPy.\n\n**4. Implementation of the Resolution Criterion**\nThe core of the problem is to apply the specified multi-part resolution criterion. We must find if there exist two distinct spectral peaks, $k_a$ and $k_b$, that satisfy all three conditions:\n1.  **Local Maxima**: Both $k_a$ and $k_b$ must correspond to strict local maxima of the magnitude spectrum $M[k]$. We identify these by iterating through the bins $k \\in \\{1, \\dots, \\lfloor N/2 \\rfloor - 1\\}$ and checking if $M[k]  M[k-1]$ and $M[k]  M[k+1]$.\n2.  **Proximity to Targets**: The found peaks must be near their expected locations. The target bin indices are defined as the nearest integers to the normalized frequencies:\n    $$\n    k_1^{\\text{target}} \\;=\\; \\left\\lfloor \\frac{f_1 N}{F_s} + \\tfrac{1}{2} \\right\\rfloor = k_1, \\quad k_2^{\\text{target}} \\;=\\; \\left\\lfloor \\frac{f_2 N}{F_s} + \\tfrac{1}{2} \\right\\rfloor = k_1+\\Delta\n    $$\n    We must find a pair of peaks $(k_a, k_b)$ such that one is close to $k_1^{\\text{target}}$ and the other is close to $k_2^{\\text{target}}$. The precise condition is $|k_a - k_1^{\\text{target}}| \\le 1$ and $|k_b - k_2^{\\text{target}}| \\le 1$. To implement this, we form two sets of candidate peaks: those within one bin of $k_1^{\\text{target}}$ and those within one bin of $k_2^{\\text{target}}$. We then search for a distinct pair $(k_a, k_b)$, with one element from each set.\n3.  **Valley Depth**: The spectral valley between the two peaks must be sufficiently deep. For a candidate pair $(k_a, k_b)$, we find the minimum magnitude $M[k_{\\min}]$ in the inclusive bin range $[\\min(k_a,k_b), \\max(k_a,k_b)]$. This minimum must satisfy:\n    $$\n    M[k_{\\min}] \\;\\le\\; \\gamma \\cdot \\min\\{M[k_a],\\,M[k_b]\\}\n    $$\n    with the given threshold $\\gamma = 0.5$.\n\nIf a pair $(k_a, k_b)$ satisfying all three conditions is found, the sinusoids are declared \"resolved\"; otherwise, they are not. This entire procedure is implemented in a Python function, which is then applied to each test case for both window functions. The final results are aggregated and formatted into the specified string output.",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    It iterates through test cases, checks resolution for Hamming and Blackman\n    windows, and prints the formatted results.\n    \"\"\"\n\n    def generate_noise(seed, num_samples, m, a, c):\n        \"\"\"\n        Generates a deterministic pseudorandom standard normal sequence using\n        an LCG and inverse transform sampling.\n        \"\"\"\n        z = np.zeros(num_samples)\n        x_n = seed\n        for i in range(num_samples):\n            x_n = (a * x_n + c) % m\n            # Map LCG output to uniform (0,1)\n            u_n = (x_n + 0.5) / m\n            # Transform uniform to standard normal via inverse CDF\n            z[i] = norm.ppf(u_n)\n        return z\n\n    def get_window(name, num_samples):\n        \"\"\"\n        Returns the specified window function as a numpy array.\n        \"\"\"\n        n = np.arange(num_samples)\n        if name == 'Hamming':\n            return 0.54 - 0.46 * np.cos(2 * np.pi * n / (num_samples - 1))\n        elif name == 'Blackman':\n            return 0.42 - 0.5 * np.cos(2 * np.pi * n / (num_samples - 1)) + 0.08 * np.cos(4 * np.pi * n / (num_samples - 1))\n        else:\n            raise ValueError(\"Unknown window type\")\n\n    def check_resolution(Fs, N, A, k1_int, delta, sigma, seed, window_name, gamma):\n        \"\"\"\n        Performs the full analysis for a single configuration to determine\n        if two sinusoids are resolved according to the problem's criterion.\n        \"\"\"\n        # --- 1. Derive parameters and generate signal ---\n        f1 = k1_int * Fs / N\n        f2 = (k1_int + delta) * Fs / N\n        k1_target = int(round(f1 * N / Fs))\n        k2_target = int(round(f2 * N / Fs))\n\n        # LCG parameters\n        m_lcg, a_lcg, c_lcg = 2**32, 1664525, 1013904223\n        noise = generate_noise(seed, N, m_lcg, a_lcg, c_lcg)\n\n        n = np.arange(N)\n        signal_clean = A * np.cos(2 * np.pi * f1 / Fs * n) + A * np.cos(2 * np.pi * f2 / Fs * n)\n        x = signal_clean + sigma * noise\n\n        # --- 2. Windowing and DFT ---\n        w = get_window(window_name, N)\n        y = x * w\n        \n        Y = np.fft.fft(y, N)\n        # One-sided magnitude spectrum\n        M = np.abs(Y[:N // 2 + 1])\n\n        # --- 3. Apply Resolution Criterion ---\n        # Condition 1: Find all strict local maxima in the specified range.\n        local_maxima_indices = []\n        for k in range(1, N // 2):\n            if M[k]  M[k-1] and M[k]  M[k+1]:\n                local_maxima_indices.append(k)\n\n        # Condition 2: Find candidate peaks near target frequencies.\n        candidates_k1 = [k for k in local_maxima_indices if abs(k - k1_target) = 1]\n        candidates_k2 = [k for k in local_maxima_indices if abs(k - k2_target) = 1]\n\n        # Search for a valid pair (ka, kb).\n        for ka in candidates_k1:\n            for kb in candidates_k2:\n                if ka == kb:\n                    continue  # Peaks must be distinct.\n\n                # This pair (ka, kb) fulfills conditions 1 and 2.\n                # Now check Condition 3: Valley depth.\n                k_start = min(ka, kb)\n                k_end = max(ka, kb)\n                \n                # Find the minimum magnitude in the valley (inclusive range).\n                valley_slice = M[k_start : k_end + 1]\n                m_min_val = np.min(valley_slice)\n                \n                # Check the depth condition.\n                if m_min_val = gamma * min(M[ka], M[kb]):\n                    return True  # Resolution is achieved.\n        \n        # If loops complete, no pair satisfied all conditions.\n        return False\n\n    # Common parameters for all test cases\n    A_const = 1.0\n    N_const = 1024\n    gamma_const = 0.5\n    \n    test_cases = [\n        # (Fs, k1, delta, sigma, seed)\n        (1024, 200, 3, 0.01, 13579),\n        (1024, 200, 1, 0.01, 24680),\n        (1024, 150, 2, 0.05, 12345),\n        (1024, 300, 4, 0.20, 54321),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        Fs, k1, delta, sigma, seed = case\n        \n        # Check resolution for Hamming window\n        res_ham = check_resolution(Fs, N_const, A_const, k1, delta, sigma, seed, 'Hamming', gamma_const)\n        \n        # Check resolution for Blackman window\n        res_blk = check_resolution(Fs, N_const, A_const, k1, delta, sigma, seed, 'Blackman', gamma_const)\n        \n        all_results.append([res_ham, res_blk])\n\n    # Format the final output string exactly as required.\n    inner_strings = [str(item).replace(\" \", \"\") for item in all_results]\n    final_output = f\"[{','.join(inner_strings)}]\"\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}