{
    "hands_on_practices": [
        {
            "introduction": "最基础的验证测试之一，是将计算结果与已知的精确解析解进行比较。本练习将经典的一维热方程作为一个基准问题 。通过计算预测解与精确解之间的误差，您将实践一项核心验证技能，该技能适用于任何数值求解器或新兴的数据驱动模型，是评估其准确性的第一步。",
            "id": "2373647",
            "problem": "您正在通过与一个典型的、可精确求解的案例进行基准比较，来验证一个偏微分方程的数据驱动代理模型。考虑一个周期域上的一维（1D）热方程，\n$$\n\\frac{\\partial u}{\\partial t}(x,t) = \\alpha \\,\\frac{\\partial^2 u}{\\partial x^2}(x,t), \\quad x \\in [0,L), \\quad t \\ge 0,\n$$\n其在 $[0,L)$ 上具有周期性边界条件，以及正弦初始条件\n$$\nu(x,0) = A \\,\\sin\\!\\big(m\\,x + \\phi\\big).\n$$\n所有角度必须以弧度为单位进行解释。所有量均为无量纲。域长度为 $L = 2\\pi$。\n\n您的任务是编写一个完整的程序，对于一组给定的测试用例，计算给定预测场相对于具有相同参数的热方程精确解的相对离散 $L^2$ 误差。使用一个包含 $N_x$ 个点的均匀网格，\n$$\nx_i = \\frac{i\\,L}{N_x}, \\quad i = 0,1,\\dots,N_x-1,\n$$\n并将网格函数 $v_i$ 的离散 $L^2$ 范数定义为\n$$\n\\|v\\|_2 = \\sqrt{\\sum_{i=0}^{N_x-1} v_i^2},\n$$\n相对误差定义为\n$$\nE = \\frac{\\|u_{\\mathrm{pred}} - u_{\\mathrm{exact}}\\|_2}{\\|u(\\cdot,0)\\|_2}.\n$$\n这里，$u_{\\mathrm{pred}}$ 表示为测试提供的预测场，$u_{\\mathrm{exact}}$ 表示在相同网格点和时间上评估的精确解，而 $u(\\cdot,0)$ 表示在相同网格点上评估的初始条件。角度必须以弧度为单位。\n\n测试套件。请为以下四个测试用例中的每一个评估相对误差 $E$。在所有情况下，域长度为 $L = 2\\pi$，网格使用 $N_x = 64$ 个点。\n\n- 测试用例 A（正常路径）：\n  - 参数：$\\alpha = 0.3$, $A = 1.0$, $m = 3$, $\\phi = \\pi/6$, $t = 0.5$。\n  - 预测场：$u_{\\mathrm{pred}}$ 等于这些参数下的精确解。\n\n- 测试用例 B（小型结构化扰动）：\n  - 参数：$\\alpha = 0.3$, $A = 1.0$, $m = 3$, $\\phi = \\pi/6$, $t = 0.5$。\n  - 预测场：$u_{\\mathrm{pred}}(x) = u_{\\mathrm{exact}}(x,t) + \\varepsilon\\,A\\,\\sin(r\\,x)$，其中 $\\varepsilon = 0.01$ 且 $r = 7$。\n\n- 测试用例 C（扩散系数不匹配）：\n  - 参数：$\\alpha = 0.3$, $A = 1.0$, $m = 3$, $\\phi = \\pi/6$, $t = 0.5$。\n  - 预测场：$u_{\\mathrm{pred}}(x) = A\\,\\exp\\!\\big(-(1+\\delta)\\,\\alpha\\,m^2\\,t\\big)\\,\\sin(m\\,x + \\phi)$，其中 $\\delta = 0.2$。\n\n- 测试用例 D（初始时间的相位误差）：\n  - 参数：$\\alpha = 0.3$, $A = 1.0$, $m = 5$, $\\phi = \\pi/4$, $t = 0$。\n  - 预测场：$u_{\\mathrm{pred}}(x) = A\\,\\sin\\!\\big(m\\,x + (\\phi + \\Delta\\phi)\\big)$，其中 $\\Delta\\phi = \\pi/12$。\n\n实现要求：\n- 对于每个测试用例，在指定的时间 $t$ 和网格点 $x_i$ 处，计算由热方程、周期性边界条件和给定初始条件所隐含的精确解 $u_{\\mathrm{exact}}(x,t)$。\n- 对于每个测试用例，计算如上定义的相对误差 $E$。\n- 最终输出格式：您的程序应生成一行输出，其中包含测试用例 A、B、C 和 D 的四个相对误差，按此顺序排列，四舍五入到 $10$ 位小数，格式为用方括号括起来的逗号分隔列表，例如，“[e_A,e_B,e_C,e_D]”。",
            "solution": "问题陈述已经过分析，并被确定为有效。它具有科学依据、提法恰当、客观，并包含唯一解所需的所有必要信息。我们可以继续。\n\n任务是通过计算相对于一维热方程的精确解析解的相对离散 $L^2$ 误差，来为一个代理模型计算基准。\n\n首先，我们必须找到控制偏微分方程的精确解，\n$$\n\\frac{\\partial u}{\\partial t}(x,t) = \\alpha \\,\\frac{\\partial^2 u}{\\partial x^2}(x,t)\n$$\n在域 $x \\in [0,L)$ 上，其中 $L=2\\pi$，受周期性边界条件和初始条件约束\n$$\nu(x,0) = A \\,\\sin(m\\,x + \\phi).\n$$\n这是一个线性偏微分方程。我们可以尝试一个能保持初始条件正弦空间结构形式的解。让我们假设一个形式如下的解：\n$$\nu(x,t) = f(t) \\sin(m\\,x + \\phi).\n$$\n将此代入热方程需要计算偏导数：\n$$\n\\frac{\\partial u}{\\partial t} = f'(t) \\sin(m\\,x + \\phi)\n$$\n$$\n\\frac{\\partial u}{\\partial x} = f(t) \\cos(m\\,x + \\phi) \\cdot m\n$$\n$$\n\\frac{\\partial^2 u}{\\partial x^2} = -f(t) \\sin(m\\,x + \\phi) \\cdot m^2 = -m^2 u(x,t) / f(t)\n$$\n热方程变为：\n$$\nf'(t) \\sin(m\\,x + \\phi) = \\alpha \\, (-m^2 f(t) \\sin(m\\,x + \\phi))\n$$\n$$\nf'(t) = -\\alpha m^2 f(t)\n$$\n这是一个关于 $f(t)$ 的一阶常微分方程，其解为 $f(t) = C e^{-\\alpha m^2 t}$，其中 $C$ 是某个常数。为了找到 $C$，我们应用 $t=0$ 时的初始条件：\n$$\nu(x,0) = f(0) \\sin(m\\,x + \\phi) = C e^0 \\sin(m\\,x + \\phi) = C \\sin(m\\,x + \\phi).\n$$\n将此与给定的初始条件 $u(x,0) = A \\sin(m\\,x + \\phi)$ 相比较，我们发现 $C=A$。\n\n因此，精确解析解为：\n$$\nu_{\\mathrm{exact}}(x,t) = A\\,e^{-\\alpha m^2 t} \\sin(m\\,x + \\phi).\n$$\n此解满足在 $[0, 2\\pi)$ 上的周期性边界条件，因为对于所有测试用例，参数 $m$ 都被给定为整数，从而确保 $\\sin(m(x+2\\pi)+\\phi) = \\sin(mx+2\\pi m+\\phi) = \\sin(mx+\\phi)$。\n\n问题要求在 $N_x$ 个点的离散网格上进行计算：\n$$\nx_i = \\frac{i L}{N_x} = \\frac{i \\cdot 2\\pi}{N_x}, \\quad i = 0, 1, \\dots, N_x-1.\n$$\n在此网格上求值的函数 $v$（$v_i = v(x_i)$）的离散 $L^2$ 范数定义为：\n$$\n\\|v\\|_2 = \\sqrt{\\sum_{i=0}^{N_x-1} v_i^2}.\n$$\n相对误差 $E$ 定义为预测误差的范数与初始条件范数的比值：\n$$\nE = \\frac{\\|u_{\\mathrm{pred}} - u_{\\mathrm{exact}}\\|_2}{\\|u(\\cdot,0)\\|_2}.\n$$\n对于所有测试用例，域长度为 $L=2\\pi$，网格大小为 $N_x = 64$。我们现在将为四个指定的测试用例中的每一个评估误差 $E$。\n\n**测试用例 A：**\n参数：$\\alpha = 0.3$, $A = 1.0$, $m = 3$, $\\phi = \\pi/6$, $t = 0.5$。\n给定的预测场 $u_{\\mathrm{pred}}$ 等于这些参数下的精确解 $u_{\\mathrm{exact}}(x, t)$。\n分子是 $\\|u_{\\mathrm{exact}} - u_{\\mathrm{exact}}\\|_2 = \\|0\\|_2 = 0$。\n因此，相对误差为 $E_A = 0$。\n\n**测试用例 B：**\n参数：$\\alpha = 0.3$, $A = 1.0$, $m = 3$, $\\phi = \\pi/6$, $t = 0.5$。\n精确解为 $u_{\\mathrm{exact}}(x,t) = A e^{-\\alpha m^2 t} \\sin(mx+\\phi)$。\n预测场为 $u_{\\mathrm{pred}}(x) = u_{\\mathrm{exact}}(x,t) + \\varepsilon A \\sin(rx)$，其中 $\\varepsilon = 0.01$ 且 $r = 7$。\n差值为 $u_{\\mathrm{pred}} - u_{\\mathrm{exact}} = \\varepsilon A \\sin(rx)$。\n初始条件为 $u(x,0) = A \\sin(mx+\\phi)$。\n相对误差为：\n$$\nE_B = \\frac{\\|\\varepsilon A \\sin(rx)\\|_2}{\\|A \\sin(mx+\\phi)\\|_2} = \\varepsilon \\frac{\\|\\sin(rx)\\|_2}{\\|\\sin(mx+\\phi)\\|_2}.\n$$\n对于一个完整周期上的均匀网格，正弦曲线的离散 $L^2$ 范数与其相位和整数波数 $k$无关（前提是 $2k$ 不是 $N_x$ 的倍数）。对于 $r=7$ 和 $m=3$ 且 $N_x=64$ 的情况，此条件成立。因此，$\\|\\sin(rx)\\|_2 = \\|\\sin(mx+\\phi)\\|_2$。\n误差简化为 $E_B = \\varepsilon = 0.01$。\n\n**测试用例 C：**\n参数：$\\alpha = 0.3$, $A = 1.0$, $m = 3$, $\\phi = \\pi/6$, $t = 0.5$。\n精确解为 $u_{\\mathrm{exact}}(x,t) = A e^{-\\alpha m^2 t} \\sin(mx+\\phi)$。\n预测场为 $u_{\\mathrm{pred}}(x) = A e^{-(1+\\delta)\\alpha m^2 t} \\sin(mx+\\phi)$，其中 $\\delta = 0.2$。\n差值为 $u_{\\mathrm{pred}} - u_{\\mathrm{exact}} = A \\left( e^{-(1+\\delta)\\alpha m^2 t} - e^{-\\alpha m^2 t} \\right) \\sin(mx+\\phi)$。\n初始条件为 $u(x,0) = A \\sin(mx+\\phi)$。\n相对误差为：\n$$\nE_C = \\frac{\\|A \\left( e^{-(1+\\delta)\\alpha m^2 t} - e^{-\\alpha m^2 t} \\right) \\sin(mx+\\phi)\\|_2}{\\|A \\sin(mx+\\phi)\\|_2}\n$$\n$$\nE_C = \\frac{|A \\left( e^{-(1+\\delta)\\alpha m^2 t} - e^{-\\alpha m^2 t} \\right)| \\cdot \\|\\sin(mx+\\phi)\\|_2}{|A| \\cdot \\|\\sin(mx+\\phi)\\|_2}\n$$\n范数项相消，得到：\n$$\nE_C = |e^{-(1+\\delta)\\alpha m^2 t} - e^{-\\alpha m^2 t}| = e^{-\\alpha m^2 t} |e^{-\\delta\\alpha m^2 t} - 1|.\n$$\n代入数值 $\\alpha=0.3$, $m=3$, $t=0.5$, $\\delta=0.2$：\n$\\alpha m^2 t = 0.3 \\cdot 9 \\cdot 0.5 = 1.35$。\n$\\delta\\alpha m^2 t = 0.2 \\cdot 1.35 = 0.27$。\n$E_C = e^{-1.35} (1 - e^{-0.27})$。\n\n**测试用例 D：**\n参数：$\\alpha = 0.3$, $A = 1.0$, $m = 5$, $\\phi = \\pi/4$, $t = 0$。\n在 $t=0$ 时，精确解即为初始条件本身：$u_{\\mathrm{exact}}(x,0) = u(x,0) = A \\sin(mx+\\phi)$。\n预测场为 $u_{\\mathrm{pred}}(x) = A \\sin(mx + \\phi + \\Delta\\phi)$，其中 $\\Delta\\phi = \\pi/12$。\n差值为 $u_{\\mathrm{pred}} - u_{\\mathrm{exact}} = A (\\sin(mx+\\phi+\\Delta\\phi) - \\sin(mx+\\phi))$。\n相对误差为：\n$$\nE_D = \\frac{\\|A (\\sin(mx+\\phi+\\Delta\\phi) - \\sin(mx+\\phi))\\|_2}{\\|A \\sin(mx+\\phi)\\|_2} = \\frac{\\|\\sin(mx+\\phi+\\Delta\\phi) - \\sin(mx+\\phi)\\|_2}{\\|\\sin(mx+\\phi)\\|_2}.\n$$\n使用三角恒等式 $\\sin(B) - \\sin(A) = 2 \\cos\\left(\\frac{A+B}{2}\\right) \\sin\\left(\\frac{B-A}{2}\\right)$，分子项变为：\n$2 \\cos\\left(mx+\\phi+\\frac{\\Delta\\phi}{2}\\right) \\sin\\left(\\frac{\\Delta\\phi}{2}\\right)$。\n误差的范数为 $|2 \\sin(\\frac{\\Delta\\phi}{2})| \\cdot \\|\\cos(mx+\\phi+\\frac{\\Delta\\phi}{2})\\|_2$。\n与情况B类似，在此网格上，具有相同波数的正弦和余弦函数的范数相等。\n$$\nE_D = \\frac{|2 \\sin(\\frac{\\Delta\\phi}{2})| \\cdot \\|\\cos(mx+\\phi+\\frac{\\Delta\\phi}{2})\\|_2}{\\|\\sin(mx+\\phi)\\|_2} = |2 \\sin(\\frac{\\Delta\\phi}{2})|.\n$$\n当 $\\Delta\\phi = \\pi/12$ 时，误差为 $E_D = 2 \\sin(\\pi/24)$。\n\n下面的程序将根据其定义，对每种情况的误差 $E$ 进行直接数值计算，这将证实这些分析结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the relative discrete L2-error for four test cases of the\n    1D heat equation against various predicted fields.\n    \"\"\"\n\n    # Domain and grid parameters common to all test cases\n    L = 2.0 * np.pi\n    Nx = 64\n\n    # Grid points\n    x = np.linspace(0, L, Nx, endpoint=False)\n\n    # Test case definitions\n    test_cases = [\n        {\n            'name': 'A',\n            'alpha': 0.3, 'A': 1.0, 'm': 3, 'phi': np.pi / 6, 't': 0.5,\n            'pred_type': 'exact'\n        },\n        {\n            'name': 'B',\n            'alpha': 0.3, 'A': 1.0, 'm': 3, 'phi': np.pi / 6, 't': 0.5,\n            'pred_type': 'structured_perturbation',\n            'eps': 0.01, 'r': 7\n        },\n        {\n            'name': 'C',\n            'alpha': 0.3, 'A': 1.0, 'm': 3, 'phi': np.pi / 6, 't': 0.5,\n            'pred_type': 'diffusivity_mismatch',\n            'delta': 0.2\n        },\n        {\n            'name': 'D',\n            'alpha': 0.3, 'A': 1.0, 'm': 5, 'phi': np.pi / 4, 't': 0.0,\n            'pred_type': 'phase_error',\n            'dphi': np.pi / 12\n        }\n    ]\n\n    results = []\n\n    def discrete_L2_norm(v):\n        \"\"\"Computes the discrete L2-norm of a vector.\"\"\"\n        return np.sqrt(np.sum(v**2))\n\n    def get_exact_solution(x_grid, t_val, A, alpha, m, phi):\n        \"\"\"Computes the analytical solution on the grid.\"\"\"\n        decay = np.exp(-alpha * m**2 * t_val)\n        spatial = A * np.sin(m * x_grid + phi)\n        return decay * spatial\n\n    for case in test_cases:\n        # Extract parameters for the current test case\n        alpha = case['alpha']\n        A = case['A']\n        m = case['m']\n        phi = case['phi']\n        t = case['t']\n\n        # 1. Calculate the exact solution at time t\n        u_exact = get_exact_solution(x, t, A, alpha, m, phi)\n\n        # 2. Calculate the initial condition at t=0\n        u_initial = get_exact_solution(x, 0, A, alpha, m, phi)\n        \n        # 3. Calculate the predicted field u_pred based on the test case\n        pred_type = case['pred_type']\n        if pred_type == 'exact':\n            u_pred = u_exact\n        elif pred_type == 'structured_perturbation':\n            eps = case['eps']\n            r = case['r']\n            perturbation = eps * A * np.sin(r * x)\n            u_pred = u_exact + perturbation\n        elif pred_type == 'diffusivity_mismatch':\n            delta = case['delta']\n            decay_pred = np.exp(-(1 + delta) * alpha * m**2 * t)\n            u_pred = A * decay_pred * np.sin(m * x + phi)\n        elif pred_type == 'phase_error':\n            dphi = case['dphi']\n            u_pred = A * np.sin(m * x + phi + dphi)\n        else:\n            raise ValueError(f\"Unknown prediction type: {pred_type}\")\n\n        # 4. Compute the relative L2 error\n        # Denominator is the norm of the initial condition\n        norm_initial = discrete_L2_norm(u_initial)\n        \n        # Numerator is the norm of the difference between predicted and exact\n        error_field = u_pred - u_exact\n        norm_error = discrete_L2_norm(error_field)\n        \n        if norm_initial == 0:\n            # Handle trivial case of zero initial condition\n            relative_error = 0.0 if norm_error == 0.0 else np.inf\n        else:\n            relative_error = norm_error / norm_initial\n        \n        # Round to 10 decimal places as required\n        results.append(round(relative_error, 10))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "除了验证最终的完整解，验证构成复杂模拟的各个计算算子也至关重要。本练习聚焦于卷积，这是信号处理和物理模拟中的一个基本运算 。您将通过实现一个数值卷积算法，并将其结果与一个特定情况下的精确解析解进行对比，从而直接洞察数值近似所引入的误差及其来源。",
            "id": "2373609",
            "problem": "设计一个用于数字信号处理（DSP）中基准卷积测试的自包含验证程序。考虑由 $H(t - t_0) = 0$（当 $t < t_0$）和 $H(t - t_0) = 1$（当 $t \\ge t_0$）定义的赫维赛德阶跃函数 $H(t - t_0)$，以及由下式定义的归一化高斯核 $g_{\\sigma}(t)$：\n$$\ng_{\\sigma}(t) = \\frac{1}{\\sqrt{2\\pi}\\,\\sigma}\\exp\\!\\left(-\\frac{t^2}{2\\sigma^2}\\right),\n$$\n其中 $\\sigma > 0$。令 $H$ 和 $g_{\\sigma}$ 的连续时间卷积对每个实数 $t$ 定义如下：\n$$\n(H * g_{\\sigma})(t) = \\int_{-\\infty}^{\\infty} H(\\tau - t_0)\\,g_{\\sigma}(t - \\tau)\\,d\\tau.\n$$\n仅使用上述定义和第一性原理，确定 $(H * g_{\\sigma})(t)$ 以标准特殊函数表示的精确闭式表达式，并在一个均匀网格上计算其值。此外，使用积分的黎曼和近似，在同一网格上独立计算该卷积的离散时间数值近似值。对于每个指定的测试用例，报告在定义域内所有网格点上，数值近似与精确表达式之间的最大绝对误差。\n\n网格规范：对于每个测试用例，一个均匀网格由实数 $T_{\\min}$、$T_{\\max}$ 和一个采样间隔 $\\Delta t > 0$ 定义，使得 $\\frac{T_{\\max} - T_{\\min}}{\\Delta t}$ 是一个整数。令 $N = 1 + \\frac{T_{\\max} - T_{\\min}}{\\Delta t}$ 且 $t_k = T_{\\min} + k\\,\\Delta t$，其中 $k \\in \\{0,1,\\dots,N-1\\}$。所有计算都应在集合 $\\{t_k\\}_{k=0}^{N-1}$ 上执行。\n\n对于每个测试用例，您的程序必须计算：\n- 从第一性原理推导出的 $(H * g_{\\sigma})(t_k)$ 的精确值 $c_{\\text{exact}}(t_k)$，\n- 使用网格 $\\{t_k\\}$ 上的均匀网格黎曼和得到的卷积数值近似值 $c_{\\text{num}}(t_k)$，\n- 以及最大绝对误差\n$$\nE = \\max_{0 \\le k \\le N-1} \\left| c_{\\text{num}}(t_k) - c_{\\text{exact}}(t_k) \\right|.\n$$\n\n测试套件（每个用例是一个元组 $(T_{\\min}, T_{\\max}, \\Delta t, \\sigma, t_0)$）：\n- 用例 1：$( -1.0,\\, 1.0,\\, 0.001,\\, 0.1,\\, 0.0 )$。\n- 用例 2：$( -1.0,\\, 1.0,\\, 0.001,\\, 0.1,\\, -0.9 )$。\n- 用例 3：$( -0.1,\\, 0.1,\\, 0.0002,\\, 0.005,\\, 0.02 )$。\n- 用例 4：$( -3.0,\\, 3.0,\\, 0.002,\\, 0.5,\\, 0.3 )$。\n\n答案格式：您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。对于每个测试用例，将 $E$ 的值四舍五入到八位小数，并以十进制数形式输出。例如，输出格式必须为：\n$$\n[\\text{E\\_case1},\\text{E\\_case2},\\text{E\\_case3},\\text{E\\_case4}],\n$$\n其中每个 $\\text{E\\_casei}$ 都四舍五入到八位小数。此问题中不涉及物理单位或角度，因此不需要单位转换。",
            "solution": "用户提供了一个需要严格验证的问题。\n\n### 第 1 步：提取已知条件\n- **赫维赛德阶跃函数：** $H(t - t_0)$ 定义为当 $t < t_0$ 时为 $0$，当 $t \\ge t_0$ 时为 $1$。\n- **归一化高斯核：** $g_{\\sigma}(t) = \\frac{1}{\\sqrt{2\\pi}\\,\\sigma}\\exp(-\\frac{t^2}{2\\sigma^2})$，其中 $\\sigma > 0$。\n- **连续卷积：** $(H * g_{\\sigma})(t) = \\int_{-\\infty}^{\\infty} H(\\tau - t_0)\\,g_{\\sigma}(t - \\tau)\\,d\\tau$。\n- **网格规范：** 均匀网格 $\\{t_k\\}_{k=0}^{N-1}$，其中 $t_k = T_{\\min} + k\\,\\Delta t$ 且 $N = 1 + \\frac{T_{\\max} - T_{\\min}}{\\Delta t}$。\n- **数值近似：** 在指定网格上对卷积积分的黎曼和近似。\n- **误差度量：** $E = \\max_{0 \\le k \\le N-1} \\left| c_{\\text{num}}(t_k) - c_{\\text{exact}}(t_k) \\right|$。\n- **测试用例**（元组 $(T_{\\min}, T_{\\max}, \\Delta t, \\sigma, t_0)$）：\n    1.  $(-1.0, 1.0, 0.001, 0.1, 0.0)$\n    2.  $(-1.0, 1.0, 0.001, 0.1, -0.9)$\n    3.  $(-0.1, 0.1, 0.0002, 0.005, 0.02)$\n    4.  $(-3.0, 3.0, 0.002, 0.5, 0.3)$\n\n### 第 2 步：使用提取的已知条件进行验证\n1.  **科学依据：** 该问题基于数学和数字信号处理中的基本概念：卷积、赫维赛德函数和高斯函数。所有定义都是标准且正确的。\n2.  **适定性：** 这是一个适定问题。它要求推导一个已知的解析结果，并将其与指定的数值方案进行比较。任务定义清晰，且存在唯一解。“黎曼和近似”一词被解释为在所提供网格上的标准离散卷积和，这是对网格定义域上积分的直接且有效的离散化。\n3.  **客观性：** 问题以客观、精确的数学语言陈述。所有参数均以数值形式给出。\n4.  **完整性和一致性：** 该问题提供了所有必要信息，包括函数定义、参数、网格规范和误差度量，可以毫无歧义地解决它。\n5.  **可行性：** 所要求的计算是标准的，并且可以使用指定的 Python 环境（`numpy`、`scipy`）来实现。\n\n### 第 3 步：结论与行动\n问题是有效的。将提供一个解决方案。\n\n### 基于原理的解决方案设计\n\n该问题需要一个分为两部分的计算，然后进行比较。首先，我们推导卷积的精确解析表达式。其次，我们实现一个指定的数值近似。最后，我们在一个离散网格上计算两者之间的最大绝对误差。\n\n**1. 精确闭式表达式的推导**\n\n赫维赛德阶跃函数 $H(t-t_0)$ 和高斯核 $g_{\\sigma}(t)$ 的卷积由下式给出：\n$$\nc_{\\text{exact}}(t) = (H * g_{\\sigma})(t) = \\int_{-\\infty}^{\\infty} H(\\tau - t_0)\\,g_{\\sigma}(t - \\tau)\\,d\\tau\n$$\n根据定义，$H(\\tau - t_0) = 1$（当 $\\tau \\ge t_0$ 时），否则为 $0$。此性质允许我们将积分下限从 $-\\infty$ 更改为 $t_0$：\n$$\nc_{\\text{exact}}(t) = \\int_{t_0}^{\\infty} g_{\\sigma}(t - \\tau)\\,d\\tau = \\int_{t_0}^{\\infty} \\frac{1}{\\sqrt{2\\pi}\\,\\sigma}\\exp\\left(-\\frac{(t - \\tau)^2}{2\\sigma^2}\\right)\\,d\\tau\n$$\n为计算此积分，我们进行变量替换。令 $u = \\frac{\\tau - t}{\\sigma}$。这意味着 $\\tau = t + \\sigma u$ 且 $d\\tau = \\sigma du$。$\\tau$ 的积分限变换为 $u$ 的积分限：\n- 当 $\\tau \\to t_0$ 时，$u \\to \\frac{t_0 - t}{\\sigma}$。\n- 当 $\\tau \\to \\infty$ 时，$u \\to \\infty$。\n\n积分变为：\n$$\nc_{\\text{exact}}(t) = \\int_{(t_0 - t)/\\sigma}^{\\infty} \\frac{1}{\\sqrt{2\\pi}\\,\\sigma} \\exp\\left(-\\frac{(-u\\sigma)^2}{2\\sigma^2}\\right) (\\sigma\\,du) = \\frac{1}{\\sqrt{2\\pi}} \\int_{(t_0 - t)/\\sigma}^{\\infty} e^{-u^2/2}\\,du\n$$\n对于偶函数 $f(x)$，利用高斯函数的对称性 $\\int_a^\\infty f(x)dx = \\int_{-\\infty}^{-a} f(x)dx$，我们有：\n$$\nc_{\\text{exact}}(t) = \\frac{1}{\\sqrt{2\\pi}} \\int_{-\\infty}^{-(t_0 - t)/\\sigma} e^{-u^2/2}\\,du = \\frac{1}{\\sqrt{2\\pi}} \\int_{-\\infty}^{(t - t_0)/\\sigma} e^{-u^2/2}\\,du\n$$\n这正是标准正态分布的累积分布函数（CDF）的定义，记为 $\\Phi(z)$，其中 $z = \\frac{t - t_0}{\\sigma}$。\n$$\nc_{\\text{exact}}(t) = \\Phi\\left(\\frac{t - t_0}{\\sigma}\\right)\n$$\nCDF $\\Phi(z)$ 通过恒等式 $\\Phi(z) = \\frac{1}{2}\\left[1 + \\text{erf}\\left(\\frac{z}{\\sqrt{2}}\\right)\\right]$ 与标准误差函数 $\\text{erf}(z)$ 相关。代入 $z$，我们得到最终的闭式表达式：\n$$\nc_{\\text{exact}}(t) = \\frac{1}{2}\\left[1 + \\text{erf}\\left(\\frac{t - t_0}{\\sigma\\sqrt{2}}\\right)\\right]\n$$\n该表达式将用于计算网格上的精确值 $c_{\\text{exact}}(t_k)$。\n\n**2. 数值近似**\n\n问题在网格 $\\{t_k\\}_{k=0}^{N-1}$ 上指定了一个“黎曼和近似”。这对应于对卷积积分进行离散化。对 $\\tau$ 的积分通过一个和来近似，其中 $\\tau$ 在网格点 $t_j$ 处采样。微分量 $d\\tau$ 被网格间距 $\\Delta t$ 替换。\n$$\nc_{\\text{num}}(t_k) \\approx \\int_{T_{\\min}}^{T_{\\max}} H(\\tau - t_0)\\,g_{\\sigma}(t_k - \\tau)\\,d\\tau \\approx \\sum_{j=0}^{N-1} H(t_j - t_0)\\,g_{\\sigma}(t_k - t_j)\\,\\Delta t\n$$\n这个和是一个离散线性卷积。对于输出网格上的每个点 $t_k$，我们对来自输入网格上所有点 $t_j$ 的贡献求和。这可以通过嵌套循环结构实现。外层循环遍历输出点 $t_k$（索引为 $k$），内层循环遍历输入点 $t_j$（索引为 $j$）。\n\n**3. 误差分析**\n\n最大绝对误差 $E$ 按规定计算：\n$$\nE = \\max_{0 \\le k \\le N-1} \\left| c_{\\text{num}}(t_k) - c_{\\text{exact}}(t_k) \\right|\n$$\n认识到此误差来自两个来源至关重要：\n1.  **离散化误差：** 用有限和近似积分所产生的误差（即黎曼和本身固有的误差），当 $\\Delta t \\to 0$ 时该误差减小。\n2.  **截断误差：** 将精确公式中的积分域 $(-\\infty, \\infty)$ 限制为数值求和中的 $[T_{\\min}, T_{\\max}]$ 所产生的误差。\n\n在给定的测试用例中，网格边界 $[T_{\\min}, T_{\\max}]$ 距离计算域的中心有几个标准差（$\\sigma$），这最小化了高斯核本身的截断误差。然而，一个显著的截断误差源于赫维赛德积分的半无限性质。数值求和只考虑 $[T_{\\min}, T_{\\max}]$ 范围内的输入信号 $H(\\tau - t_0)$，而精确解是在 $[t_0, \\infty)$ 上对其进行积分。这导致在网格边界处，特别是在 $t_k = T_{\\max}$ 处，出现一个巨大的、且是故意的差异，这凸显了有限域信号处理的后果。这种边界效应是正在测试的一个关键特性。\n\n程序将被构造成对每个测试用例执行这些计算，并报告由此产生的最大误差。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erf\n\ndef g_sigma(t, sigma):\n    \"\"\"\n    Computes the normalized Gaussian kernel.\n    \"\"\"\n    return (1 / (np.sqrt(2 * np.pi) * sigma)) * np.exp(-t**2 / (2 * sigma**2))\n\ndef H_func(t, t0):\n    \"\"\"\n    Computes the Heaviside step function, H(t-t0).\n    The value is 1 at t=t0, matching the problem definition.\n    \"\"\"\n    return np.heaviside(t - t0, 1)\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (-1.0, 1.0, 0.001, 0.1, 0.0),\n        (-1.0, 1.0, 0.001, 0.1, -0.9),\n        (-0.1, 0.1, 0.0002, 0.005, 0.02),\n        (-3.0, 3.0, 0.002, 0.5, 0.3)\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        T_min, T_max, dt, sigma, t0 = case\n        \n        # 1. Grid Specification\n        # Use a robust method to define the grid to avoid floating point issues.\n        num_points = int(round((T_max - T_min) / dt)) + 1\n        t_grid = np.linspace(T_min, T_max, num_points)\n        \n        # 2. Exact Closed-Form Solution\n        # c_exact(t) = 0.5 * (1 + erf((t - t0) / (sigma * sqrt(2))))\n        arg_erf = (t_grid - t0) / (sigma * np.sqrt(2))\n        c_exact = 0.5 * (1.0 + erf(arg_erf))\n        \n        # 3. Numerical Approximation using Riemann Sum\n        # This implements the discrete convolution sum:\n        # c_num(t_k) = sum_{j=0}^{N-1} H(t_j - t0) * g_sigma(t_k - t_j) * dt\n        H_grid = H_func(t_grid, t0)\n        N = len(t_grid)\n        c_num = np.zeros(N)\n        \n        # This O(N^2) approach is a direct implementation of the sum.\n        # The inner loop is vectorized for performance.\n        for k in range(N):\n            shifted_times = t_grid[k] - t_grid\n            g_values = g_sigma(shifted_times, sigma)\n            c_num[k] = np.sum(H_grid * g_values) * dt\n            \n        # 4. Compute Maximum Absolute Error\n        max_error = np.max(np.abs(c_num - c_exact))\n        results.append(f\"{max_error:.8f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "对于许多前沿的非线性问题，精确的解析解往往是不存在的。本练习将介绍一种强大的验证策略：将完整的数值求解器与一个简化的、但物理上相关的解析模型进行比较 。您将通过一项实践，验证一个用于大变形分析的非线性有限元方法 (FEM) 求解器，将其计算出的力-位移曲线与均质压缩的理论模型进行核对，这是计算力学领域验证复杂代码的基石技术。",
            "id": "2373682",
            "problem": "设计并实现一个非线性有限元方法 (FEM) 求解器的基准验证，该求解器用于简单弹性体块的大变形压缩。其目标是通过将计算出的反力-位移曲线与根据可压缩超弹性材料的均匀变形推导出的参考曲线进行比较，来验证求解器的准确性。所有计算都是无量纲的；不使用物理单位。\n\n您必须严格基于基本原理进行推导和算法设计：准静态平衡中的虚功原理、有限变形运动学以及下文指定的超弹性本构模型。在这些基础之外，请勿使用任何预先推导的简化公式。\n\n假设和模型：\n- 该块体占据一个初始矩形域，沿加载方向（$x$轴）的初始长度为 $L_0$，在横向上的初始宽度和高度分别为 $W_0$ 和 $H_0$。初始横截面积为 $A_0 = W_0 H_0$。\n- 侧面无牵引力，刚性压板沿 $x$ 轴通过规定的末端位移来压缩块体。\n- 材料是均匀的、超弹性的，其可压缩 Neo-Hookean 应变能密度为\n$$\n\\psi(\\mathbf{F}) = \\frac{\\mu}{2}\\left(I_1 - 3\\right) - \\mu \\ln J + \\frac{\\kappa}{2} \\left(\\ln J\\right)^2,\n$$\n其中 $\\mathbf{F}$ 是变形梯度，$I_1 = \\mathrm{tr}\\left(\\mathbf{C}\\right)$，其中 $\\mathbf{C} = \\mathbf{F}^\\top \\mathbf{F}$，$J = \\det \\mathbf{F}$，$\\mu$ 是剪切模量，$\\kappa$ 是体积模量。\n\n目标推导和离散化要求：\n- 从最小势能原理和定义 $\\mathbf{P} = \\partial \\psi / \\partial \\mathbf{F}$ 出发，推导名义应力 $\\mathbf{P}$。\n- 通过在横向强制名义牵引力为零来施加侧面无牵引力的条件。对于具有主拉伸 $\\lambda_x$, $\\lambda_y$, $\\lambda_z$ 的均匀变形，这意味着存在两个标量方程，它们将横向拉伸 $\\lambda_t$（假设 $\\lambda_y = \\lambda_z = \\lambda_t$）确定为轴向拉伸 $\\lambda_x$ 的函数。\n- 沿 $x$ 轴实现一个由 $n$ 个线性单元组成的一维全拉格朗日双节点杆单元网格（节点数为 $n+1$）。使用轴向名义应力分量 $P_{xx}$，并组装全局内力向量和一致切线刚度矩阵。单元 $e$ 中的轴向单元拉伸为 $\\lambda_x = \\ell_e / L_e$，其中 $L_e$ 是初始单元长度，$\\ell_e$ 是当前单元长度。\n- 对于一致算法切线，在此验证中，可以通过使用小的相对扰动进行数值微分来计算 $\\mathrm{d}P_{xx}/\\mathrm{d}\\lambda_x$。\n- 以增量方式施加准静态载荷。施加 Dirichlet 条件 $u(0) = 0$ 和 $u(L_0) = -\\Delta$，其中 $\\Delta$ 从 $0$ 单调增加到 $L_0$ 的指定最大分数。通过对自由度进行 Newton–Raphson 迭代来求解每个载荷步。\n- 将加载端的反力计算为平衡相应 Dirichlet 自由度处节点内力的支座反力。定义正的反力为压缩力（即，在平衡压缩内力时为正）。\n- 使用均匀变形解计算每个载荷水平的参考反力：对于给定的轴向拉伸 $\\lambda_x = (L_0-\\Delta)/L_0$，求解侧向无牵引力条件以得到 $\\lambda_t$，然后评估轴向名义应力 $P_{xx}$；参考反力为 $R_\\mathrm{ref} = -A_0 P_{xx}$。\n- 对于每个测试用例，评估所有载荷步中的最大绝对相对误差，\n$$\n\\varepsilon_\\mathrm{max} = \\max_{\\text{steps}} \\frac{\\left|R_\\mathrm{FEM} - R_\\mathrm{ref}\\right|}{\\max\\left(\\left|R_\\mathrm{ref}\\right|, \\epsilon\\right)},\n$$\n其中有一个小的 $\\epsilon = 10^{-12}$ 以避免在载荷为零时出现除以零的情况。\n\n边界条件：\n- 左端固定：$u(0) = 0$。\n- 右端规定位移：$u(L_0) = -\\Delta$，$\\Delta$ 在指定的步数内线性增加。\n\n不使用角度。所有量均为无量纲。\n\n测试套件：\n实现您的程序以运行以下三个测试用例。对于每个用例，载荷在指定的步数内线性施加到指定的最终压缩率。每个测试用例指定为一个元组 $(\\mu,\\kappa,L_0,W_0,H_0,n,\\text{final\\_compression},\\text{n\\_steps})$：\n- 测试用例 A（一般情况）：$(\\mu,\\kappa,L_0,W_0,H_0,n,\\text{final\\_compression},\\text{n\\_steps}) = (\\,1.2,\\,120.0,\\,1.0,\\,0.5,\\,0.5,\\,8,\\,0.30,\\,15\\,)$。\n- 测试用例 B（大压缩边缘情况）：$(\\,0.8,\\,8.0,\\,1.0,\\,0.5,\\,0.5,\\,3,\\,0.60,\\,20\\,)$。\n- 测试用例 C（近乎不可压缩）：$(\\,1.0,\\,1000.0,\\,1.0,\\,0.5,\\,0.5,\\,20,\\,0.20,\\,20\\,)$。\n\n要求的最终输出：\n- 您的程序必须输出一行，其中包含按 A、B、C 顺序排列的三个测试用例的结果，形式为逗号分隔的列表并用方括号括起，例如 $\\left[r_1,r_2,r_3\\right]$，其中每个 $r_i$ 是该测试用例的最大绝对相对误差 $\\varepsilon_\\mathrm{max}$，四舍五入到八位小数。",
            "solution": "我们为应用于单轴压缩下弹性体块的非线性大变形有限元方法 (FEM) 求解器开发一个基准验证。目标是将计算出的反力-位移曲线与在可压缩 Neo-Hookean 模型下从均匀变形推导出的参考值进行比较。所有量都是无量纲的。\n\n基础理论：\n- 准静态平衡源于虚功原理：对于任意容许虚位移，内虚功等于外虚功。在没有体力且在加载边界处采用位移控制的情况下，弱形式简化为内力与边界反力的平衡。\n- 有限变形运动学：变形梯度为 $\\mathbf{F} = \\partial \\mathbf{x} / \\partial \\mathbf{X}$，其中 $J = \\det \\mathbf{F} > 0$。右 Cauchy–Green 张量为 $\\mathbf{C} = \\mathbf{F}^\\top \\mathbf{F}$，其第一不变量为 $I_1 = \\mathrm{tr}\\,\\mathbf{C}$。\n- 超弹性本构定律：应变能密度为\n$$\n\\psi(\\mathbf{F}) = \\frac{\\mu}{2}\\left(I_1 - 3\\right) - \\mu \\ln J + \\frac{\\kappa}{2}\\left(\\ln J\\right)^2,\n$$\n其中剪切模量为 $\\mu$，体积模量为 $\\kappa$。名义（第一 Piola–Kirchhoff）应力由能量共轭关系得出，\n$$\n\\mathbf{P} = \\frac{\\partial \\psi}{\\partial \\mathbf{F}}。\n$$\n\n名义应力的推导：\n我们通过标准操作，使用 $\\partial I_1 / \\partial \\mathbf{F} = 2\\mathbf{F}$、$\\partial J / \\partial \\mathbf{F} = J \\mathbf{F}^{-\\top}$ 和 $\\partial \\ln J / \\partial \\mathbf{F} = \\mathbf{F}^{-\\top}$ 来计算 $\\partial \\psi / \\partial \\mathbf{F}$。结果是\n$$\n\\mathbf{P} = \\mu\\left(\\mathbf{F} - \\mathbf{F}^{-\\top}\\right) + \\kappa \\left(\\ln J\\right)\\mathbf{F}^{-\\top}。\n$$\n这个表达式被广泛使用，并可从给定的能量密度推导出来。\n\n均匀变形与侧向无牵引力条件：\n对于具有主拉伸 $\\lambda_x$, $\\lambda_y$, $\\lambda_z$ 的均匀单轴压缩，我们利用对称性并设 $\\lambda_y = \\lambda_z = \\lambda_t$ 和 $\\mathbf{F} = \\mathrm{diag}(\\lambda_x,\\lambda_t,\\lambda_t)$。行列式为 $J = \\lambda_x \\lambda_t^2$，名义应力是对角阵，其分量为\n$$\nP_{ii} = \\mu\\left(\\lambda_i - \\frac{1}{\\lambda_i}\\right) + \\kappa \\frac{\\ln J}{\\lambda_i}。\n$$\n侧面无牵引力意味着 $P_{yy} = 0$ 和 $P_{zz} = 0$，由于对称性，这两个条件是重合的。标量形式的侧向无牵引力条件为\n$$\ng(\\lambda_t;\\lambda_x) \\equiv \\mu\\left(\\lambda_t - \\frac{1}{\\lambda_t}\\right) + \\kappa \\frac{\\ln\\left(\\lambda_x \\lambda_t^2\\right)}{\\lambda_t} = 0。\n$$\n给定 $\\lambda_x$，可以求解这个标量非线性方程以得到 $\\lambda_t > 0$。一个稳健的初始猜测值是不可压缩极限 $\\lambda_t^{(0)} = \\lambda_x^{-1/2}$。那么轴向名义应力为\n$$\nP_{xx}(\\lambda_x) = \\mu\\left(\\lambda_x - \\frac{1}{\\lambda_x}\\right) + \\kappa \\frac{\\ln\\left(\\lambda_x \\lambda_t^2(\\lambda_x)\\right)}{\\lambda_x}。\n$$\n对于初始横截面积为 $A_0$ 的块体，参考反力为 $R_\\mathrm{ref} = -A_0 P_{xx}(\\lambda_x)$，符号约定为压缩产生正反力。\n\n一维全拉格朗日 FEM 离散化：\n我们将沿 $x$ 轴的杆离散为 $n$ 个线性双节点单元（节点 $i=0,\\dots,n$）。初始节点位置为 $X_i = i\\,L_0/n$，节点 $i$ 处唯一的自由度是轴向位移 $u_i$。对于连接节点 $a$ 和 $b$ 的单元 $e$，初始长度为 $L_e = L_0/n$，轴向拉伸为\n$$\n\\lambda_x^{(e)} = \\frac{\\ell_e}{L_e} = \\frac{(X_b + u_b) - (X_a + u_a)}{L_e} = 1 + \\frac{u_b - u_a}{L_e}。\n$$\n在全拉格朗日形式下，单元 $e$ 的内力向量（假设 $P_{xx}$ 在单元上为常数）是\n$$\n\\mathbf{f}_\\mathrm{int}^{(e)} = A_0 P_{xx}\\left(\\lambda_x^{(e)}\\right)\\begin{bmatrix}-1\\\\+1\\end{bmatrix}。\n$$\n单元 $e$ 的一致算法切线通过对节点位移使用链式法则求导得到：\n$$\n\\mathbf{K}^{(e)} = \\frac{A_0}{L_e} \\frac{\\mathrm{d}P_{xx}}{\\mathrm{d}\\lambda_x}\\Big|_{\\lambda_x^{(e)}} \\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix}\n$$\n在此验证中，我们通过使用小的相对扰动的中心有限差分来数值计算 $\\mathrm{d}P_{xx}/\\mathrm{d}\\lambda_x$。全局组装得到内力向量 $\\mathbf{f}_\\mathrm{int}(\\mathbf{u})$ 和切线刚度矩阵 $\\mathbf{K}(\\mathbf{u})$。\n\n边界条件与求解过程：\n在每个载荷步，我们施加 $u_0 = 0$ 和 $u_n = -\\Delta$，其中 $\\Delta$ 从 $0$ 线性增加到最终压缩量。自由度是内部节点。在每个载荷步，Newton–Raphson 迭代通过以下方式更新自由度：\n$$\n\\mathbf{K}_{ff}(\\mathbf{u})\\,\\Delta\\mathbf{u}_f = -\\mathbf{r}_f(\\mathbf{u}), \\quad \\mathbf{r} \\equiv \\mathbf{f}_\\mathrm{int},\n$$\n直到收敛，其中下标 $f$ 表示自由度。通过残差范数或位移增量范数检查收敛；一个典型的标准是 $\\|\\Delta \\mathbf{u}_f\\|_\\infty < 10^{-12} L_0$。加载端的反力计算为平衡 Dirichlet 节点处内力的支座反力，即 $R = -f_{\\mathrm{int},n}$，对于负的 $P_{xx}$，该反力在压缩时为正。\n\n参考解与误差度量：\n在每个载荷水平，末端缩短量为 $\\Delta$，均匀轴向拉伸为 $\\lambda_x = (L_0 - \\Delta)/L_0$。通过标量 Newton 法求解 $g(\\lambda_t;\\lambda_x) = 0$ 得到 $\\lambda_t$。然后计算 $P_{xx}(\\lambda_x)$ 和参考反力 $R_\\mathrm{ref} = -A_0 P_{xx}(\\lambda_x)$。测试度量是所有步骤中的最大绝对相对误差，\n$$\n\\varepsilon_\\mathrm{max} = \\max_{\\text{steps}} \\frac{\\left|R_\\mathrm{FEM} - R_\\mathrm{ref}\\right|}{\\max\\left(\\left|R_\\mathrm{ref}\\right|, 10^{-12}\\right)}。\n$$\n\n为保证稳健性的算法细节：\n- 求解 $\\lambda_t$ 的标量 Newton 法使用导数\n$$\n\\frac{\\mathrm{d}g}{\\mathrm{d}\\lambda_t} = \\mu\\left(1 + \\frac{1}{\\lambda_t^2}\\right) + \\kappa \\frac{2 - \\ln\\left(\\lambda_x \\lambda_t^2\\right)}{\\lambda_t^2},\n$$\n必要时进行回溯以保持 $\\lambda_t > 0$ 并减小 $|g|$。\n- 数值导数 $\\mathrm{d}P_{xx}/\\mathrm{d}\\lambda_x$ 使用中心差分，并对 $\\lambda_x$ 进行小的相对扰动，以确保尺度不变性和稳定性。\n\n测试套件与预期行为：\n我们运行三个用例：\n- 测试 A：$(\\mu,\\kappa,L_0,W_0,H_0,n,\\text{final\\_compression},\\text{n\\_steps}) = (\\,1.2,\\,120.0,\\,1.0,\\,0.5,\\,0.5,\\,8,\\,0.30,\\,15\\,)$。这是一个良态情况，具有中等可压缩性。\n- 测试 B：$(\\,0.8,\\,8.0,\\,1.0,\\,0.5,\\,0.5,\\,3,\\,0.60,\\,20\\,)$。这探究了具有更高非线性的大压缩情况。\n- 测试 C：$(\\,1.0,\\,1000.0,\\,1.0,\\,0.5,\\,0.5,\\,20,\\,0.20,\\,20\\,)$。这探究了近乎不可压缩的刚度。\n\n因为在位移控制下，给定本构更新的杆单元离散化在平衡时强制每个单元具有相同的轴向拉伸，所以 FEM 反力应在数值公差范围内与均匀参考值匹配。因此，最大相对误差 $\\varepsilon_\\mathrm{max}$ 应该很小，对于测试 A 和 C，通常接近机器精度，而对于测试 B，由于非线性更强，误差会稍大但仍然非常小。程序将这三个误差四舍五入到八位小数，以单行列表 $\\left[r_A,r_B,r_C\\right]$ 的形式报告。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_lateral_stretch(lambda_x, mu, kappa, tol=1e-12, max_iter=100):\n    \"\"\"\n    Solve for lateral stretch lambda_t given axial stretch lambda_x\n    under traction-free lateral faces for compressible Neo-Hookean.\n    g(lambda_t) = mu*(lambda_t - 1/lambda_t) + kappa * ln(J)/lambda_t = 0\n    with J = lambda_x * lambda_t^2.\n    \"\"\"\n    # Robust initial guess: incompressible estimate\n    lam_t = max(lambda_x ** (-0.5), 1e-12)\n    for _ in range(max_iter):\n        J = lambda_x * lam_t * lam_t\n        if J = 0 or not np.isfinite(J):\n            # Recover with small positive perturbation\n            lam_t = max(lam_t, 1e-8)\n            J = lambda_x * lam_t * lam_t\n        g = mu * (lam_t - 1.0 / lam_t) + kappa * (np.log(J)) / lam_t\n        if abs(g)  tol:\n            return lam_t\n        # Derivative of g with respect to lambda_t\n        dg = mu * (1.0 + 1.0 / (lam_t * lam_t)) + kappa * (2.0 - np.log(J)) / (lam_t * lam_t)\n        # Newton step with backtracking if needed\n        delta = -g / dg\n        lam_new = lam_t + delta\n        if lam_new = 0 or not np.isfinite(lam_new):\n            # Backtracking line search on lambda_t to keep positivity and reduce |g|\n            alpha = 1.0\n            success = False\n            while alpha > 1e-8:\n                cand = lam_t + alpha * delta\n                if cand > 0 and np.isfinite(cand):\n                    Jc = lambda_x * cand * cand\n                    if Jc > 0 and np.isfinite(Jc):\n                        gc = mu * (cand - 1.0 / cand) + kappa * (np.log(Jc)) / cand\n                        if abs(gc)  abs(g):\n                            lam_new = cand\n                            success = True\n                            break\n                alpha *= 0.5\n            if not success:\n                # Fallback small positive update\n                lam_new = max(lam_t * 0.5, 1e-10)\n        lam_t = lam_new\n    # If not converged, return current estimate (still positive)\n    return max(lam_t, 1e-10)\n\ndef Pxx_given_lambda(lambda_x, mu, kappa):\n    \"\"\"\n    Compute axial nominal stress P_xx for compressible Neo-Hookean\n    under uniaxial stretch lambda_x with traction-free lateral faces.\n    \"\"\"\n    lam_t = solve_lateral_stretch(lambda_x, mu, kappa)\n    J = lambda_x * lam_t * lam_t\n    # P_xx = mu*(lambda_x - 1/lambda_x) + kappa * ln(J) / lambda_x\n    return mu * (lambda_x - 1.0 / lambda_x) + kappa * (np.log(J)) / lambda_x\n\ndef dPxx_dlambda_numeric(lambda_x, mu, kappa, rel_eps=1e-7):\n    \"\"\"\n    Numerical derivative dPxx/dlambda_x via central relative finite difference.\n    \"\"\"\n    h = rel_eps\n    lp = lambda_x * (1.0 + h)\n    lm = lambda_x * (1.0 - h)\n    # Ensure positivity\n    if lm = 0:\n        lm = lambda_x * (1.0 - 0.5 * h)\n        lp = lambda_x * (1.0 + 0.5 * h)\n        h = 0.5 * h\n    Pp = Pxx_given_lambda(lp, mu, kappa)\n    Pm = Pxx_given_lambda(lm, mu, kappa)\n    return (Pp - Pm) / (2.0 * h * lambda_x)\n\ndef assemble_internal_and_tangent(u, L0, A0, n_el, mu, kappa):\n    \"\"\"\n    Assemble global internal force vector and tangent stiffness matrix\n    for a 1D bar with n_el elements and n_el+1 nodes.\n    \"\"\"\n    n_nodes = n_el + 1\n    f_int = np.zeros(n_nodes)\n    K = np.zeros((n_nodes, n_nodes))\n    L_e0 = L0 / n_el\n\n    # Nodal positions in reference\n    # X_i = i * L_e0\n    for e in range(n_el):\n        a = e\n        b = e + 1\n        ua = u[a]\n        ub = u[b]\n        # Axial stretch in element e: lambda_x = 1 + (ub - ua)/L_e0\n        lambda_x = 1.0 + (ub - ua) / L_e0\n        # Compute stress and tangent\n        P = Pxx_given_lambda(lambda_x, mu, kappa)\n        dP = dPxx_dlambda_numeric(lambda_x, mu, kappa)\n\n        # Element internal force: A0 * P * [-1, +1]\n        fe = A0 * P * np.array([-1.0, +1.0])\n        f_int[a] += fe[0]\n        f_int[b] += fe[1]\n\n        # Element tangent: A0 * dP/dlambda * [[1/L_e0, -1/L_e0], [-1/L_e0, 1/L_e0]]\n        coef = A0 * dP / L_e0\n        Ke = coef * np.array([[1.0, -1.0], [-1.0, 1.0]])\n        K[a, a] += Ke[0, 0]\n        K[a, b] += Ke[0, 1]\n        K[b, a] += Ke[1, 0]\n        K[b, b] += Ke[1, 1]\n\n    return f_int, K\n\ndef solve_bar(mu, kappa, L0, W0, H0, n_el, final_compression, n_steps):\n    \"\"\"\n    Solve displacement-controlled compression and return the maximum absolute relative\n    error between FEM reaction and the homogeneous-reference reaction over all steps.\n    \"\"\"\n    A0 = W0 * H0\n    n_nodes = n_el + 1\n    # Initialize displacements\n    u = np.zeros(n_nodes)\n    left = 0\n    right = n_nodes - 1\n    free = np.arange(1, n_nodes - 1, dtype=int)\n    # Track maximum relative error\n    max_rel_err = 0.0\n    # Load path\n    for step in range(1, n_steps + 1):\n        frac = step / n_steps\n        Delta = final_compression * L0 * frac\n        # Apply boundary conditions\n        u[left] = 0.0\n        u[right] = -Delta\n        # Newton-Raphson on free DOFs\n        for it in range(60):\n            f_int, K = assemble_internal_and_tangent(u, L0, A0, n_el, mu, kappa)\n            # Residual on free DOFs: internal forces must vanish on free DOFs\n            r = f_int[free]\n            # Convergence check on displacement increment norm later\n            if free.size > 0:\n                Kff = K[np.ix_(free, free)]\n                # Solve for update\n                try:\n                    du = -np.linalg.solve(Kff, r)\n                except np.linalg.LinAlgError:\n                    # Regularize slightly if singular (should not occur with proper setup)\n                    Kff_reg = Kff + 1e-12 * np.eye(Kff.shape[0])\n                    du = -np.linalg.solve(Kff_reg, r)\n                u[free] += du\n                if np.linalg.norm(du, ord=np.inf)  1e-12 * L0:\n                    break\n            else:\n                # No free DOFs; skip\n                break\n        # Post-converged internal forces for reaction\n        f_int, _ = assemble_internal_and_tangent(u, L0, A0, n_el, mu, kappa)\n        R_fem = -f_int[right]  # reaction at right end, positive in compression\n        # Reference reaction from homogeneous solution\n        lambda_x = (L0 - Delta) / L0\n        P_ref = Pxx_given_lambda(lambda_x, mu, kappa)\n        R_ref = -A0 * P_ref\n        denom = max(abs(R_ref), 1e-12)\n        rel_err = abs(R_fem - R_ref) / denom\n        if rel_err > max_rel_err:\n            max_rel_err = rel_err\n    return max_rel_err\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each tuple: (mu, kappa, L0, W0, H0, n_el, final_compression, n_steps)\n    test_cases = [\n        (1.2, 120.0, 1.0, 0.5, 0.5, 8, 0.30, 15),   # Test A: general case\n        (0.8, 8.0, 1.0, 0.5, 0.5, 3, 0.60, 20),     # Test B: large compression\n        (1.0, 1000.0, 1.0, 0.5, 0.5, 20, 0.20, 20), # Test C: nearly incompressible\n    ]\n\n    results = []\n    for case in test_cases:\n        mu, kappa, L0, W0, H0, n_el, final_comp, n_steps = case\n        err = solve_bar(mu, kappa, L0, W0, H0, n_el, final_comp, n_steps)\n        results.append(round(float(err), 8))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}