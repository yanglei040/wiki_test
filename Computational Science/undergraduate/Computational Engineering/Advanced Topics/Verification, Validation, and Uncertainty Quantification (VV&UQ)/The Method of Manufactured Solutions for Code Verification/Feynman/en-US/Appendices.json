{
    "hands_on_practices": [
        {
            "introduction": "A powerful first step in code verification is to test your solver against a problem it should solve exactly. The standard second-order finite difference scheme for the Laplacian has a truncation error that depends on the fourth and higher-order derivatives of the solution. This practice  cleverly exploits this by using a manufactured quadratic polynomial solution, for which these higher-order derivatives are zero. This creates an elegant \"sanity check\" where your numerical solver should produce the exact solution, with any deviation being attributable to floating-point arithmetic error, thus providing a stringent test of your code's basic implementation.",
            "id": "2444972",
            "problem": "Consider the two-dimensional Poisson problem on the unit square domain $\\Omega = [0,1] \\times [0,1]$ with Dirichlet boundary conditions. You are to apply the method of manufactured solutions for code verification as follows. Let the manufactured solution be the quadratic polynomial\n$$\nu_m(x,y) = a x^2 + b x y + c y^2 + d x + e y + f,\n$$\nwhere $a$, $b$, $c$, $d$, $e$, and $f$ are real constants. Define the source term $s(x,y)$ so that $u_m$ exactly satisfies the Poisson equation with a negative Laplacian,\n$$\n- \\Delta u(x,y) = s(x,y) \\quad \\text{in } \\Omega,\n$$\ntogether with Dirichlet boundary conditions\n$$\nu(x,y) = u_m(x,y) \\quad \\text{for } (x,y) \\in \\partial \\Omega.\n$$\nDiscretize $- \\Delta$ using the standard second-order central finite difference scheme on a uniform Cartesian grid with $N$ interior nodes in each spatial direction and grid spacing $h = \\frac{1}{N+1}$. Let the interior grid points be $\\{(x_i,y_j)\\}_{i,j=1}^N$ with $x_i = i h$ and $y_j = j h$. The discrete interior equations to be enforced are, for each interior node $(i,j)$,\n$$\n\\frac{-u_{i+1,j} - u_{i-1,j} - u_{i,j+1} - u_{i,j-1} + 4 u_{i,j}}{h^2} = s(x_i,y_j),\n$$\nwith Dirichlet boundary values prescribed from $u_m$ on $\\partial \\Omega$. Here $u_{i,j}$ denotes the discrete approximation to $u(x_i,y_j)$.\n\nFor each test case below, compute the discrete solution on the full grid including boundary nodes and then report the maximum absolute nodal error\n$$\nE_\\infty = \\max_{0 \\le i \\le N+1,\\; 0 \\le j \\le N+1} \\left| u_{i,j} - u_m(x_i,y_j) \\right|.\n$$\nThere are no physical units involved. All angles, if any arise, must be interpreted in radians, but none are required here.\n\nTest suite (each case is $(N, a, b, c, d, e, f)$):\n- Case $1$: $(\\,10,\\, 1.0,\\, 0.5,\\, 2.0,\\, -1.0,\\, 0.25,\\, -0.75\\,)$\n- Case $2$: $(\\,15,\\, 0.0,\\, 3.0,\\, 0.0,\\, 0.0,\\, 0.0,\\, 0.0\\,)$\n- Case $3$: $(\\,8,\\, 0.0,\\, 0.0,\\, 0.0,\\, -2.0,\\, 1.5,\\, 0.1\\,)$\n- Case $4$: $(\\,12,\\, -0.7,\\, 0.0,\\, 0.4,\\, 0.0,\\, 0.0,\\, 2.0\\,)$\n\nYour program must compute $E_\\infty$ for each case, in the order listed above, and produce a single line of output containing the four results as a comma-separated list enclosed in square brackets, for example \"[$r_1$,$r_2$,$r_3$,$r_4$]\". Each $r_k$ must be a floating-point number. No other output is permitted.",
            "solution": "The user has provided a problem in computational engineering that requires the application of the Method of Manufactured Solutions (MMS) for code verification. The task is to compute the maximum nodal error of a finite difference solution to the 2D Poisson equation, where the exact solution is a chosen manufactured polynomial.\n\n**Problem Validation**\n\nFirst, I must subject the problem to rigorous validation.\n\n**Step 1: Extract Givens**\n- **Governing Equation**: 2D Poisson equation $-\\Delta u(x,y) = s(x,y)$ on $\\Omega = [0,1] \\times [0,1]$.\n- **Manufactured Solution**: $u_m(x,y) = a x^2 + b x y + c y^2 + d x + e y + f$.\n- **Source Term**: $s(x,y)$ derived from $-\\Delta u_m(x,y)$.\n- **Boundary Conditions**: Dirichlet, $u(x,y) = u_m(x,y)$ on $\\partial \\Omega$.\n- **Discretization**: Second-order central finite difference scheme on a uniform grid.\n- **Grid**: $N$ interior nodes in each direction, spacing $h = 1/(N+1)$. Grid points $(x_i, y_j) = (ih, jh)$.\n- **Discrete Equation**: $\\frac{4u_{i,j} - u_{i+1,j} - u_{i-1,j} - u_{i,j+1} - u_{i,j-1}}{h^2} = s(x_i,y_j)$ for interior nodes $i,j \\in \\{1, \\dots, N\\}$.\n- **Error Metric**: $E_\\infty = \\max_{0 \\le i,j \\le N+1} | u_{i,j} - u_m(x_i,y_j) |$.\n- **Test Cases**: Four sets of parameters $(N, a, b, c, d, e, f)$ are provided.\n\n**Step 2: Validate Using Extracted Givens**\n- **Scientific Grounding**: The problem is fundamentally sound. It uses the Poisson equation, the Method of Manufactured Solutions, and the finite difference method, all of which are standard concepts in numerical analysis and computational engineering.\n- **Well-Posedness**: The problem is well-posed. The Poisson equation with Dirichlet conditions has a unique solution. The corresponding linear system from the finite difference discretization is non-singular and also has a unique solution. The request to compute the error is a standard procedure in code verification.\n- **Objectivity**: The problem is stated using precise, objective mathematical language, with no ambiguity or subjective elements.\n\nThe problem is self-contained, consistent, and scientifically valid. All necessary information is provided.\n\n**Step 3: Verdict and Action**\nThe problem is valid. I will proceed with the solution.\n\n**Principle-Based Solution Design**\n\nThe core of this problem lies in understanding the truncation error of the finite difference scheme. The method of manufactured solutions is specifically designed to test a code's implementation by providing a problem for which the exact solution is known.\n\n1.  **Derivation of the Source Term**:\n    The manufactured solution is $u_m(x,y) = a x^2 + b x y + c y^2 + d x + e y + f$. We must first compute its Laplacian to define the source term $s(x,y) = -\\Delta u_m(x,y)$.\n    The partial derivatives are:\n    $\\frac{\\partial u_m}{\\partial x} = 2ax + by + d$\n    $\\frac{\\partial^2 u_m}{\\partial x^2} = 2a$\n    $\\frac{\\partial u_m}{\\partial y} = bx + 2cy + e$\n    $\\frac{\\partial^2 u_m}{\\partial y^2} = 2c$\n    The Laplacian is $\\Delta u_m = \\frac{\\partial^2 u_m}{\\partial x^2} + \\frac{\\partial^2 u_m}{\\partial y^2} = 2a + 2c$.\n    Therefore, the source term is a constant: $s(x,y) = -(2a + 2c)$.\n\n2.  **Analysis of Truncation Error**:\n    The discrete operator for the negative Laplacian is $L_h u_{i,j} = \\frac{4u_{i,j} - u_{i+1,j} - u_{i-1,j} - u_{i,j+1} - u_{i,j-1}}{h^2}$.\n    The truncation error $\\tau$ of this operator is given by $\\tau = L_h u - (-\\Delta u)$. For a sufficiently smooth function $u$, Taylor series expansions show that $\\tau = -\\frac{h^2}{12}(\\frac{\\partial^4 u}{\\partial x^4} + \\frac{\\partial^4 u}{\\partial y^4}) + \\mathcal{O}(h^4)$.\n    The scheme is second-order accurate. However, for our specific manufactured solution $u_m(x,y)$, which is a quadratic polynomial, all partial derivatives of order three or higher are identically zero.\n    Specifically, $\\frac{\\partial^4 u_m}{\\partial x^4} = 0$ and $\\frac{\\partial^4 u_m}{\\partial y^4} = 0$.\n    This implies that the leading term of the truncation error is zero. In fact, all higher-order terms are also zero. The truncation error for a quadratic polynomial is exactly zero: $\\tau = 0$.\n    This means the finite difference operator exactly reproduces the continuous differential operator when applied to any quadratic polynomial:\n    $$\n    L_h u_m(x_i, y_j) = -\\Delta u_m(x_i, y_j) = s(x_i, y_j)\n    $$\n    This identity is the key to the problem. It demonstrates that the manufactured solution, when evaluated at the grid points, is an exact solution to the discrete system of equations.\n\n3.  **Numerical Implementation Strategy**:\n    The task is to compute the discrete solution $u_{i,j}$ and compare it to the exact solution $u_m(x_i, y_j)$. The procedure is as follows:\n    a.  **Grid Setup**: Define a uniform grid with $(N+2) \\times (N+2)$ points covering the domain $[0,1] \\times [0,1]$.\n    b.  **System Formulation**: Formulate the linear system $A \\mathbf{u} = \\mathbf{b}$ for the $N^2$ unknown values at the interior grid points. The matrix $A$ represents the coefficients of the 5-point stencil ($4$ on the diagonal, $-1$ for neighbors). The vector $\\mathbf{b}$ contains the source term values $h^2 s(x_i,y_j)$ and the known boundary values derived from $u_m$.\n    c.  **System Solution**: Solve the sparse linear system for the vector of interior unknowns $\\mathbf{u}$.\n    d.  **Error Calculation**: Reconstruct the full solution grid $u_{i,j}$ by combining the solved interior values with the prescribed boundary values. Then, compute the maximum absolute difference between this numerical solution and the manufactured solution evaluated on the grid: $E_\\infty = \\max |u_{i,j} - u_m(x_i,y_j)|$.\n\n    Given the zero truncation error, the numerical solution $u_{i,j}$ must be identical to $u_m(x_i,y_j)$ at all grid points, up to the limits of floating-point precision. Therefore, the expected error $E_\\infty$ will be a very small number, on the order of machine epsilon. A non-zero result would indicate an error in the implementation of the linear system solver or the problem setup. The provided code implements this procedure robustly.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import diags\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n    test_cases = [\n        # (N, a, b, c, d, e, f)\n        (10, 1.0, 0.5, 2.0, -1.0, 0.25, -0.75),\n        (15, 0.0, 3.0, 0.0, 0.0, 0.0, 0.0),\n        (8, 0.0, 0.0, 0.0, -2.0, 1.5, 0.1),\n        (12, -0.7, 0.0, 0.4, 0.0, 0.0, 2.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, a, b, c, d, e, f = case\n        error = calculate_max_error(N, a, b, c, d, e, f)\n        results.append(f\"{error:.15e}\")\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calculate_max_error(N, a, b, c, d, e, f):\n    \"\"\"\n    Calculates the maximum absolute nodal error for a single test case by\n    setting up and solving the discrete Poisson equation.\n    \"\"\"\n    h = 1.0 / (N + 1)\n\n    # 1. Set up the grid and coordinates.\n    # The grid is indexed by (j, i) corresponding to (y, x) for standard\n    # row-major array ordering.\n    x_coords = np.linspace(0.0, 1.0, N + 2)\n    y_coords = np.linspace(0.0, 1.0, N + 2)\n    X, Y = np.meshgrid(x_coords, y_coords, indexing='xy')\n\n    # 2. Define manufactured solution and evaluate on the grid.\n    u_m_func = lambda x, y: a*x**2 + b*x*y + c*y**2 + d*x + e*y + f\n    u_m_grid = u_m_func(X, Y)\n\n    # The source term s(x,y) = -Laplacian(u_m) = -(2a + 2c) is a constant.\n    s_val = -(2*a + 2*c)\n\n    # 3. Set up the linear system A*u = b for interior nodes.\n    # The N*N unknowns correspond to interior grid points, flattened using\n    # row-major ordering: k = (j-1)*N + (i-1).\n    \n    # Construct the sparse matrix A for the 5-point stencil:\n    # 4*u_ji - u_{j,i-1} - u_{j,i+1} - u_{j-1,i} - u_{j+1,i}\n    \n    d_main = np.full(N*N, 4.0)\n    d_h_off = np.full(N*N - 1, -1.0)\n    d_v_off = np.full(N*N - N, -1.0)\n    \n    # Zero out connections between the end of a grid row and the start of the next.\n    for j in range(1, N):\n        d_h_off[j*N - 1] = 0.0\n    \n    diagonals = [d_main, d_h_off, d_h_off, d_v_off, d_v_off]\n    offsets = [0, -1, 1, -N, N]\n    A = diags(diagonals, offsets, shape=(N*N, N*N), format='csr')\n\n    # 4. Construct the RHS vector b.\n    b = np.zeros(N*N)\n    for j in range(1, N + 1):      # y-index on grid\n        for i in range(1, N + 1):  # x-index on grid\n            k = (j - 1) * N + (i - 1)  # row-major vector index\n            \n            # Source term contribution\n            b[k] = h**2 * s_val\n            \n            # Add contributions from known boundary values\n            if i == 1:   # Left boundary (x=0)\n                b[k] += u_m_grid[j, 0]\n            if i == N:   # Right boundary (x=1)\n                b[k] += u_m_grid[j, N+1]\n            if j == 1:   # Bottom boundary (y=0)\n                b[k] += u_m_grid[0, i]\n            if j == N:   # Top boundary (y=1)\n                b[k] += u_m_grid[N+1, i]\n\n    # 5. Solve the linear system for interior node values.\n    u_interior_vec = spsolve(A, b)\n\n    # 6. Reconstruct the full solution grid.\n    u_discrete = np.zeros((N + 2, N + 2))\n    \n    # Set boundary values from manufactured solution\n    u_discrete[0, :] = u_m_grid[0, :]\n    u_discrete[N+1, :] = u_m_grid[N+1, :]\n    u_discrete[:, 0] = u_m_grid[:, 0]\n    u_discrete[:, N+1] = u_m_grid[:, N+1]\n    \n    # Fill interior with the solved values, reshaped according to row-major order.\n    u_discrete[1:N+1, 1:N+1] = u_interior_vec.reshape((N, N), order='C')\n\n    # 7. Calculate the maximum absolute error over the entire grid.\n    error = np.max(np.abs(u_discrete - u_m_grid))\n    \n    return error\n\nsolve()\n\n```"
        },
        {
            "introduction": "After confirming your solver's correctness with an exact polynomial solution, the next step is to verify its performance on a general problem where a discretization error is expected. This practice  guides you through the canonical workflow of MMS for a 2D Poisson equation using a more complex, non-polynomial manufactured solution. By performing a grid refinement study, you will measure the error norms and compute the observed order of accuracy, confirming that your code converges at the theoretically predicted rate, a cornerstone of rigorous code verification.",
            "id": "2444940",
            "problem": "Consider the two-dimensional Poisson equation on the square domain $\\Omega = [0,1] \\times [0,1]$,\n$$\\nabla^2 u(x,y) = f(x,y), \\quad (x,y) \\in \\Omega,$$\nwith Dirichlet boundary conditions prescribed by a manufactured solution $u_{m}(x,y)$,\n$$u(x,y)\\big|_{\\partial \\Omega} = u_{m}(x,y),$$\nwhere\n$$u_{m}(x,y) = \\sin(\\pi x)\\,\\cosh(y) + x^2 y^3.$$\nAll trigonometric function arguments must be interpreted in radians.\n\nYour task is to verify a numerical solver for the Poisson equation by the method of manufactured solutions. Specifically:\n- Derive the source term $f(x,y)$ exactly from the manufactured solution $u_{m}(x,y)$ by applying the Laplacian operator $\\nabla^2$.\n- Solve the boundary value problem with the derived $f(x,y)$ on uniform Cartesian grids of size $N \\times N$ nodes that include the boundary, for specified values of $N$.\n- On each grid, enforce the Dirichlet boundary condition exactly by setting $u(x,y)$ equal to $u_{m}(x,y)$ on $\\partial \\Omega$.\n- Compare the computed numerical solution $u_{\\text{num}}$ to the exact manufactured solution $u_{m}$ at the grid nodes to quantify the error.\n\nDefine the following error measures for a grid with $N \\times N$ nodes and uniform spacing $h = 1/(N-1)$:\n- The discrete maximum norm (infinity norm) over all grid nodes,\n$$E_{\\infty}(N) = \\max_{0 \\le i,j \\le N-1} \\left| u_{\\text{num}}(x_i,y_j) - u_{m}(x_i,y_j) \\right|.$$\n- The discrete $L^2$ norm over all grid nodes,\n$$E_{2}(N) = \\left( \\sum_{i=0}^{N-1} \\sum_{j=0}^{N-1} \\left( u_{\\text{num}}(x_i,y_j) - u_{m}(x_i,y_j) \\right)^2 \\, h^2 \\right)^{1/2}.$$\n\nCompute the observed order of accuracy $p$ between two grids of sizes $N_1$ and $N_2$ (with $N_2 = 2N_1 - 1$ so that the mesh spacing halves) using the discrete $L^2$ error as\n$$p = \\frac{\\log\\left( \\dfrac{E_{2}(N_1)}{E_{2}(N_2)} \\right)}{\\log(2)}.$$\n\nAngle unit specification: All angles are in radians.\n\nTest suite and required outputs:\n- Test case $1$: $N = 3$. Report $E_{\\infty}(3)$.\n- Test case $2$: $N = 9$. Report $E_{2}(9)$.\n- Test case $3$: $N_1 = 17$ and $N_2 = 33$. Report the observed order $p$ computed from $E_{2}(17)$ and $E_{2}(33)$ according to the formula above.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order $[E_{\\infty}(3), E_{2}(9), p]$.\n- Each numeric entry must be formatted as a decimal number with exactly $10$ digits after the decimal point.\n- For example, a valid output line has the form: $[0.1234567890,0.0123456789,1.9876543210]$.",
            "solution": "The problem as stated constitutes a well-posed, scientifically grounded task for the verification of a numerical method. It adheres to established principles of computational engineering, specifically the method of manufactured solutions for verifying the implementation of a finite difference solver for the Poisson equation. All necessary data, equations, and definitions are provided, and there are no internal contradictions or facts contrary to science. Therefore, the problem is valid, and a solution will be constructed.\n\nThe methodology is comprised of two principal stages: first, the analytical derivation of the source term required by the manufactured solution; second, the numerical solution of the resulting boundary-value problem and the computation of error metrics.\n\nFirst, we derive the source term $f(x,y)$ by applying the Laplacian operator, $\\nabla^2 = \\frac{\\partial^2}{\\partial x^2} + \\frac{\\partial^2}{\\partial y^2}$, to the specified manufactured solution $u_{m}(x,y)$.\nThe manufactured solution is given as:\n$$u_{m}(x,y) = \\sin(\\pi x)\\cosh(y) + x^2 y^3$$\nWe compute the partial derivatives with respect to $x$ and $y$.\nFor the $x$-derivatives:\n$$ \\frac{\\partial u_{m}}{\\partial x} = \\pi \\cos(\\pi x)\\cosh(y) + 2x y^3 $$\n$$ \\frac{\\partial^2 u_{m}}{\\partial x^2} = -\\pi^2 \\sin(\\pi x)\\cosh(y) + 2 y^3 $$\nFor the $y$-derivatives:\n$$ \\frac{\\partial u_{m}}{\\partial y} = \\sin(\\pi x)\\sinh(y) + 3x^2 y^2 $$\n$$ \\frac{\\partial^2 u_{m}}{\\partial y^2} = \\sin(\\pi x)\\cosh(y) + 6x^2 y $$\nThe source term $f(x,y)$ is the sum of these second derivatives:\n$$ f(x,y) = \\nabla^2 u_{m} = \\frac{\\partial^2 u_{m}}{\\partial x^2} + \\frac{\\partial^2 u_{m}}{\\partial y^2} $$\n$$ f(x,y) = \\left(-\\pi^2 \\sin(\\pi x)\\cosh(y) + 2 y^3\\right) + \\left(\\sin(\\pi x)\\cosh(y) + 6x^2 y\\right) $$\nCombining terms yields the exact source function:\n$$ f(x,y) = (1 - \\pi^2)\\sin(\\pi x)\\cosh(y) + 6x^2 y + 2y^3 $$\n\nSecond, we solve the Poisson equation $\\nabla^2 u(x,y) = f(x,y)$ on a uniform Cartesian grid of $N \\times N$ nodes covering the domain $\\Omega = [0,1] \\times [0,1]$. The grid coordinates are $x_j = j h$ and $y_i = i h$ for $i,j \\in \\{0, 1, \\dots, N-1\\}$, with grid spacing $h = 1/(N-1)$. Let $U_{i,j}$ denote the numerical approximation of $u(y_i, x_j)$. The Laplacian operator is approximated at each interior node $(y_i, x_j)$, where $i,j \\in \\{1, \\dots, N-2\\}$, using a second-order central finite difference scheme:\n$$ \\frac{U_{i,j+1} - 2U_{i,j} + U_{i,j-1}}{h^2} + \\frac{U_{i+1,j} - 2U_{i,j} + U_{i-1,j}}{h^2} = f(y_i, x_j) $$\nRearranging this stencil gives a linear equation for each interior node:\n$$ U_{i,j-1} + U_{i,j+1} + U_{i-1,j} + U_{i+1,j} - 4U_{i,j} = h^2 f(y_i, x_j) $$\nThis set of $(N-2)^2$ equations for the $(N-2)^2$ unknown interior node values forms a linear system of the form $A \\mathbf{u} = \\mathbf{b}$. The vector $\\mathbf{u}$ contains the unknown values $U_{i,j}$ ordered, for example, in a row-major sequence. The matrix $A$ is a sparse, block-tridiagonal matrix representing the connectivity of the finite difference stencil. The right-hand-side vector $\\mathbf{b}$ contains the values of $h^2 f(y_i, x_j)$ adjusted for the known boundary conditions. For an interior node $(y_i, x_j)$ adjacent to a boundary, the corresponding term in the stencil (e.g., $U_{0,j}$ if $i=1$) is a known value from the Dirichlet condition, $u_m(y_0, x_j)$, and is moved to the right-hand side of the equation.\n\nThe complete numerical solution $u_{\\text{num}}$ is assembled by solving this linear system for the interior values and combining them with the exact boundary values prescribed by $u_m(x,y)$.\n\nThe error is quantified using the specified discrete norms. The discrete maximum norm, $E_{\\infty}(N)$, is calculated as:\n$$ E_{\\infty}(N) = \\max_{0 \\le i,j \\le N-1} | u_{\\text{num}}(y_i, x_j) - u_{m}(y_i, x_j) | $$\nThe discrete $L^2$ norm, $E_{2}(N)$, is calculated as:\n$$ E_{2}(N) = \\left( \\sum_{i=0}^{N-1} \\sum_{j=0}^{N-1} ( u_{\\text{num}}(y_i, x_j) - u_{m}(y_i, x_j) )^2 h^2 \\right)^{1/2} $$\nThe observed order of accuracy $p$ is then computed by comparing the $L^2$ error on two successively refined grids, $N_1$ and $N_2=2N_1-1$, which corresponds to halving the mesh spacing $h$:\n$$ p = \\frac{\\log( E_{2}(N_1) / E_{2}(N_2) )}{\\log(2)} $$\nThis value is expected to be approximately $2$, consistent with the second-order accuracy of the finite difference scheme.\n\nThe implementation will construct and solve the linear system for the specified values of $N$ ($N=3, 9, 17, 33$) to compute the requested error metrics.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the solution process for all test cases.\n    \"\"\"\n    \n    # Define PI for use in trigonometric functions.\n    PI = np.pi\n\n    def u_m(x, y):\n        \"\"\"\n        Computes the manufactured solution u_m(x,y).\n        - x, y can be NumPy arrays.\n        \"\"\"\n        return np.sin(PI * x) * np.cosh(y) + x**2 * y**3\n\n    def f_source(x, y):\n        \"\"\"\n        Computes the source term f(x,y) derived from grad^2(u_m).\n        - x, y can be NumPy arrays.\n        \"\"\"\n        term1 = (1.0 - PI**2) * np.sin(PI * x) * np.cosh(y)\n        term2 = 6.0 * x**2 * y\n        term3 = 2.0 * y**3\n        return term1 + term2 + term3\n\n    def solve_poisson(N):\n        \"\"\"\n        Solves the Poisson equation on an N x N grid using finite differences.\n        \n        Args:\n            N (int): The number of nodes along one dimension of the grid.\n\n        Returns:\n            tuple: A tuple containing:\n                - u_num (np.ndarray): The N x N numerical solution array.\n                - u_exact (np.ndarray): The N x N exact manufactured solution array.\n                - h (float): The grid spacing.\n        \"\"\"\n        if N  2:\n            raise ValueError(\"Grid size N must be at least 2.\")\n        if N == 2: # No interior points\n            h = 1.0\n            x = np.linspace(0.0, 1.0, N)\n            y = np.linspace(0.0, 1.0, N)\n            xx, yy = np.meshgrid(x, y, indexing='xy')\n            u_exact = u_m(xx, yy)\n            return u_exact, u_exact, h\n\n        # 1. Grid setup\n        h = 1.0 / (N - 1)\n        x = np.linspace(0.0, 1.0, N)\n        y = np.linspace(0.0, 1.0, N)\n        xx, yy = np.meshgrid(x, y, indexing='xy')\n\n        # 2. Evaluate exact solution and source term\n        u_exact = u_m(xx, yy)\n        f_vals = f_source(xx, yy)\n\n        # 3. Setup linear system Ax = b for interior points\n        num_interior_nodes_1d = N - 2\n        num_unknowns = num_interior_nodes_1d**2\n        \n        A = np.zeros((num_unknowns, num_unknowns))\n        b = np.zeros(num_unknowns)\n\n        # The mapping from 2D interior grid index (i_int, j_int) to 1D vector index k\n        # is row-major: k = i_int * num_interior_nodes_1d + j_int\n        # This corresponds to full grid index (i, j) where i = i_int + 1, j = j_int + 1\n        for k in range(num_unknowns):\n            i_int = k // num_interior_nodes_1d\n            j_int = k % num_interior_nodes_1d\n            \n            i = i_int + 1\n            j = j_int + 1\n\n            # Main diagonal coefficient for -4*U_ij\n            A[k, k] = -4.0\n\n            # Right-hand side from source term f(y_i, x_j)\n            b[k] = h**2 * f_vals[i, j]\n\n            # Neighbor contribution (x-direction, j-1)\n            if j == 1:\n                b[k] -= u_exact[i, 0]\n            else:\n                A[k, k - 1] = 1.0\n\n            # Neighbor contribution (x-direction, j+1)\n            if j == N - 2:\n                b[k] -= u_exact[i, N - 1]\n            else:\n                A[k, k + 1] = 1.0\n\n            # Neighbor contribution (y-direction, i-1)\n            if i == 1:\n                b[k] -= u_exact[0, j]\n            else:\n                A[k, k - num_interior_nodes_1d] = 1.0\n\n            # Neighbor contribution (y-direction, i+1)\n            if i == N - 2:\n                b[k] -= u_exact[N - 1, j]\n            else:\n                A[k, k + num_interior_nodes_1d] = 1.0\n\n        # 4. Solve the linear system\n        u_interior_flat = np.linalg.solve(A, b)\n        u_interior = u_interior_flat.reshape((num_interior_nodes_1d, num_interior_nodes_1d))\n\n        # 5. Construct the full numerical solution grid\n        u_num = np.copy(u_exact)  # Initialize with correct boundary values\n        u_num[1:N-1, 1:N-1] = u_interior\n\n        return u_num, u_exact, h\n\n    # Test case 1: N = 3, compute E_infinity\n    u_num_3, u_exact_3, _ = solve_poisson(N=3)\n    e_inf_3 = np.max(np.abs(u_num_3 - u_exact_3))\n\n    # Test case 2: N = 9, compute E_2\n    u_num_9, u_exact_9, h_9 = solve_poisson(N=9)\n    e_2_9 = np.sqrt(np.sum((u_num_9 - u_exact_9)**2) * h_9**2)\n\n    # Test case 3: N1=17, N2=33, compute order of accuracy p\n    # Compute E_2 for N=17\n    u_num_17, u_exact_17, h_17 = solve_poisson(N=17)\n    e_2_17 = np.sqrt(np.sum((u_num_17 - u_exact_17)**2) * h_17**2)\n    \n    # Compute E_2 for N=33\n    u_num_33, u_exact_33, h_33 = solve_poisson(N=33)\n    e_2_33 = np.sqrt(np.sum((u_num_33 - u_exact_33)**2) * h_33**2)\n    \n    # Compute order of accuracy p\n    p = np.log(e_2_17 / e_2_33) / np.log(2.0)\n    \n    # Compile and format results\n    results = [e_inf_3, e_2_9, p]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{x:.10f}' for x in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The principles of MMS extend seamlessly from steady-state to time-dependent problems, allowing for verification of more complex simulations. This exercise  demonstrates this by applying the method to the 1D transient heat equation, a fundamental parabolic PDE. You will manufacture a solution that evolves in both space and time, which requires deriving a corresponding time-dependent source term and verifying the combined accuracy of your spatial discretization and temporal integration scheme, a crucial skill for developing reliable simulations of dynamic phenomena.",
            "id": "2445001",
            "problem": "You will apply the Method of Manufactured Solutions (MMS) to verify a one-dimensional numerical solver for the transient heat equation. Consider the dimensionless heat equation with a source term on a finite interval,\n$$\nu_t = \\alpha\\,u_{xx} + s(x,t), \\quad x \\in [0,L], \\ t \\in [0,T],\n$$\nwith Dirichlet boundary conditions and a known initial condition. The Method of Manufactured Solutions (MMS) prescribes selecting a smooth, exact solution $u_m(x,t)$, inserting it into the differential equation, and defining the source term $s(x,t)$ so that $u_m(x,t)$ satisfies the equation identically. This enables objective code verification by comparing the numerical solution against $u_m(x,t)$.\n\nUse the manufactured solution\n$$\nu_m(x,t) = e^{-k t}\\,\\cos(a x),\n$$\nwhere $a \\ge 0$ and $k \\ge 0$ are real parameters, and the argument of $\\cos(\\cdot)$ is in radians. All quantities are dimensionless. The task is to:\n\n- Derive the source term $s(x,t)$ implied by the choice of $u_m(x,t)$, using only calculus and the differential operator definitions.\n- Discretize the partial differential equation using the Crank–Nicolson method in time and second-order central differences in space on a uniform grid. Impose Dirichlet boundary conditions from $u_m(x,t)$ and the initial condition $u(x,0)=u_m(x,0)$. The time step $\\Delta t$ must be chosen proportional to $\\Delta x$ to balance temporal and spatial errors.\n- For each test case, compute the numerical solution at the final time $t=T$ on two successively refined meshes whose numbers of spatial intervals differ by a factor of $2$, and estimate the observed order of accuracy $p$ by\n$$\np \\;=\\; \\frac{\\log\\left(E_{\\mathrm{coarse}}/E_{\\mathrm{fine}}\\right)}{\\log(2)},\n$$\nwhere $E$ is the discrete root-mean-square error over all grid nodes at $t=T$,\n$$\nE \\;=\\; \\sqrt{\\frac{1}{N+1}\\sum_{j=0}^{N}\\left(u_j^N - u_m(x_j,T)\\right)^2},\n$$\nwith $N$ the number of spatial intervals, $x_j=j\\,\\Delta x$, and $u_j^N$ the numerical solution at node $j$ and time level $N$.\n- Your time step choice must satisfy $\\Delta t = \\gamma\\,\\Delta x$ approximately, implemented by taking $N_t = \\lceil T/(\\gamma\\,\\Delta x)\\rceil$ time steps and then setting $\\Delta t = T/N_t$. Use the Crank–Nicolson scheme with source term evaluated via the trapezoidal rule in time.\n\nBase your derivations on the following foundational facts only:\n- The definition of partial derivatives and the chain rule for time and space.\n- The second derivative in space of $\\cos(a x)$ is $-a^2 \\cos(a x)$.\n- The Crank–Nicolson method is the trapezoidal rule in time applied to the semi-discrete system, and second-order central differences approximate $u_{xx}$.\n\nAngle unit specification: evaluate $\\cos(\\cdot)$ with its argument in radians.\n\nTest suite:\n- Case $1$ (general): $\\alpha=0.7$, $a=3.0$, $k=2.5$, $L=\\pi$, $T=0.2$, $N_{\\text{coarse}}=50$, $\\gamma=0.4$.\n- Case $2$ (weak diffusion): $\\alpha=0.001$, $a=4.0$, $k=0.5$, $L=\\pi$, $T=0.05$, $N_{\\text{coarse}}=60$, $\\gamma=0.4$.\n- Case $3$ (spatially constant solution): $\\alpha=0.9$, $a=0.0$, $k=1.2$, $L=1.0$, $T=0.3$, $N_{\\text{coarse}}=40$, $\\gamma=0.4$.\n\nFor each case, use two meshes: the coarse mesh with $N_{\\text{coarse}}$ spatial intervals and the fine mesh with $2N_{\\text{coarse}}$ intervals, with the time step chosen as described. Compute the observed order $p$ from the two errors at $t=T$.\n\nFinal output format:\n- Your program should produce a single line of output containing the observed orders for the three cases as a comma-separated list enclosed in square brackets, with each value rounded to three decimal places, for example, $\\texttt{[2.001,1.998,2.004]}$.",
            "solution": "The problem statement is first subjected to rigorous validation.\n\n**Step 1: Extract Givens**\n- **Governing Equation:** $u_t = \\alpha\\,u_{xx} + s(x,t)$, for $x \\in [0,L]$ and $t \\in [0,T]$.\n- **Manufactured Solution:** $u_m(x,t) = e^{-k t}\\,\\cos(a x)$, with $a \\ge 0$, $k \\ge 0$.\n- **Observed Order of Accuracy Formula:** $p \\;=\\; \\frac{\\log\\left(E_{\\mathrm{coarse}}/E_{\\mathrm{fine}}\\right)}{\\log(2)}$.\n- **Error Metric:** The discrete root-mean-square error is $E \\;=\\; \\sqrt{\\frac{1}{N+1}\\sum_{j=0}^{N}\\left(u_j^N - u_m(x_j,T)\\right)^2}$.\n- **Numerical Method:** Crank–Nicolson in time, second-order central differences in space. Dirichlet boundary conditions and initial condition are imposed from $u_m(x,t)$.\n- **Time Step Rule:** $\\Delta t = \\gamma\\,\\Delta x$ approximately, achieved via $N_t = \\lceil T/(\\gamma\\,\\Delta x)\\rceil$ and $\\Delta t = T/N_t$. The source term is evaluated using the trapezoidal rule in time.\n- **Test Suite:**\n    - Case $1$: $\\alpha=0.7$, $a=3.0$, $k=2.5$, $L=\\pi$, $T=0.2$, $N_{\\text{coarse}}=50$, $\\gamma=0.4$.\n    - Case $2$: $\\alpha=0.001$, $a=4.0$, $k=0.5$, $L=\\pi$, $T=0.05$, $N_{\\text{coarse}}=60$, $\\gamma=0.4$.\n    - Case $3$: $\\alpha=0.9$, $a=0.0$, $k=1.2$, $L=1.0$, $T=0.3$, $N_{\\text{coarse}}=40$, $\\gamma=0.4$.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem statement is evaluated against the established criteria for validity.\n- **Scientific Grounding:** The problem is based on the one-dimensional heat equation, a fundamental partial differential equation in physics. The Method of Manufactured Solutions (MMS) is a standard, accepted technique for code verification in computational science. The numerical methods specified—Crank-Nicolson and central differencing—are canonical, well-understood algorithms. The problem is scientifically sound.\n- **Well-Posedness and Completeness:** The problem describes a well-posed initial-boundary value problem. All necessary parameters, functions, boundary conditions, and discretization rules are explicitly defined. The task of calculating the observed order of accuracy is unambiguous. The problem is self-contained and complete.\n- **Objectivity:** The problem is stated in precise, objective mathematical language, free from subjective or ambiguous interpretations.\n\n**Step 3: Verdict and Action**\nThe problem is valid. It is a standard exercise in the verification of numerical methods for partial differential equations. We proceed to the solution.\n\n**Derivation of the Source Term**\n\nThe source term $s(x,t)$ is defined to ensure that the manufactured solution $u_m(x,t)$ satisfies the partial differential equation identically. We rearrange the PDE to solve for $s(x,t)$:\n$$\ns(x,t) = u_t - \\alpha\\,u_{xx}\n$$\nThe manufactured solution is $u_m(x,t) = e^{-k t}\\,\\cos(a x)$. We compute its partial derivatives with respect to time and space.\n\nThe partial derivative with respect to time $t$ is:\n$$\nu_t = \\frac{\\partial}{\\partial t}\\left(e^{-k t}\\,\\cos(a x)\\right) = -k\\,e^{-k t}\\,\\cos(a x)\n$$\nThe first partial derivative with respect to space $x$ is:\n$$\nu_x = \\frac{\\partial}{\\partial x}\\left(e^{-k t}\\,\\cos(a x)\\right) = -a\\,e^{-k t}\\,\\sin(a x)\n$$\nThe second partial derivative with respect to space $x$ is:\n$$\nu_{xx} = \\frac{\\partial}{\\partial x}\\left(-a\\,e^{-k t}\\,\\sin(a x)\\right) = -a^2\\,e^{-k t}\\,\\cos(a x)\n$$\nSubstituting the expressions for $u_t$ and $u_{xx}$ into the equation for $s(x,t)$ yields:\n$$\ns(x,t) = \\left(-k\\,e^{-k t}\\,\\cos(a x)\\right) - \\alpha\\,\\left(-a^2\\,e^{-k t}\\,\\cos(a x)\\right)\n$$\nFactoring out the common terms, we obtain the final expression for the source term:\n$$\ns(x,t) = (\\alpha\\,a^2 - k)\\,e^{-k t}\\,\\cos(a x)\n$$\n\n**Numerical Discretization**\n\nThe PDE is discretized on a uniform grid with spatial step $\\Delta x = L/N$ and time step $\\Delta t = T/N_t$. Let $u_j^n$ approximate the solution $u(x_j, t_n)$ at grid point $x_j=j\\Delta x$ and time $t_n=n\\Delta t$.\n\nThe Crank-Nicolson method is applied to the semi-discrete equation $u_t = F(u,t)$, where $F(u,t) = \\alpha u_{xx} + s(x,t)$. This results in:\n$$\n\\frac{u^{n+1} - u^n}{\\Delta t} = \\frac{1}{2}\\left( F(u^n, t_n) + F(u^{n+1}, t_{n+1}) \\right)\n$$\nThe spatial derivative $u_{xx}$ is approximated using a second-order central difference:\n$$\n(u_{xx})_j \\approx \\frac{u_{j+1} - 2u_j + u_{j-1}}{(\\Delta x)^2}\n$$\nSubstituting this into the Crank-Nicolson scheme gives the fully discrete equation for an interior node $j \\in \\{1, 2, \\dots, N-1\\}$:\n$$\n\\frac{u_j^{n+1} - u_j^n}{\\Delta t} = \\frac{\\alpha}{2}\\left( \\frac{u_{j+1}^n - 2u_j^n + u_{j-1}^n}{(\\Delta x)^2} + \\frac{u_{j+1}^{n+1} - 2u_j^{n+1} + u_{j-1}^{n+1}}{(\\Delta x)^2} \\right) + \\frac{1}{2}(s_j^n + s_j^{n+1})\n$$\nwhere $s_j^n = s(x_j, t_n)$. We rearrange the equation to group unknown terms at time level $n+1$ on the left-hand side (LHS) and known terms at time level $n$ on the right-hand side (RHS). Define the dimensionless parameter $\\lambda = \\frac{\\alpha \\Delta t}{2(\\Delta x)^2}$.\n$$\n-\\lambda u_{j-1}^{n+1} + (1+2\\lambda)u_j^{n+1} - \\lambda u_{j+1}^{n+1} = \\lambda u_{j-1}^n + (1-2\\lambda)u_j^n + \\lambda u_{j+1}^n + \\frac{\\Delta t}{2}(s_j^n + s_j^{n+1})\n$$\nThis constitutes a tridiagonal system of linear equations for the unknown vector of internal nodal values $\\mathbf{u}_{\\text{int}}^{n+1} = [u_1^{n+1}, u_2^{n+1}, \\dots, u_{N-1}^{n+1}]^T$. The system is of the form $A \\mathbf{u}_{\\text{int}}^{n+1} = \\mathbf{d}$. The matrix $A$ is an $(N-1) \\times (N-1)$ tridiagonal matrix with main diagonal entries of $(1+2\\lambda)$ and off-diagonal entries of $-\\lambda$.\n\nThe RHS vector $\\mathbf{d}$ depends on the solution at time $n$ and the boundary conditions at time $n+1$. The Dirichlet boundary conditions are given by the manufactured solution:\n$$\nu_0^{n+1} = u_m(0, t_{n+1}) \\quad \\text{and} \\quad u_N^{n+1} = u_m(L, t_{n+1})\n$$\nThe $j$-th component of the RHS vector $\\mathbf{d}$ (for $j \\in \\{1, \\dots, N-1\\}$) is:\n$$\nd_{j-1} = \\lambda u_{j-1}^n + (1-2\\lambda)u_j^n + \\lambda u_{j+1}^n + \\frac{\\Delta t}{2}(s_j^n + s_j^{n+1})\n$$\nThe boundary terms from the LHS are moved to the RHS. For the first equation ($j=1$), the term $-\\lambda u_0^{n+1}$ is moved, so we add $\\lambda u_0^{n+1}$ to $d_0$. For the last equation ($j=N-1$), the term $-\\lambda u_N^{n+1}$ is moved, so we add $\\lambda u_N^{n+1}$ to $d_{N-2}$.\n\nThe overall algorithm is as follows:\n1.  For a given test case, set the parameters $\\alpha, a, k, L, T, N, \\gamma$.\n2.  Calculate grid parameters: $\\Delta x = L/N$, $N_t = \\lceil T/(\\gamma \\Delta x) \\rceil$, $\\Delta t = T/N_t$.\n3.  Initialize the solution at $t=0$: $u_j^0 = u_m(x_j, 0)$ for all $j \\in \\{0, \\dots, N\\}$.\n4.  Construct the constant tridiagonal matrix $A$.\n5.  Iterate from $n=0$ to $N_t-1$:\n    a. Construct the RHS vector $\\mathbf{d}$ using the solution $u^n$ and the boundary values at $t_{n+1}$.\n    b. Solve the linear system $A \\mathbf{u}_{\\text{int}}^{n+1} = \\mathbf{d}$ for the internal nodes. A specialized tridiagonal solver is used for efficiency.\n    c. Update the full solution vector $u^{n+1}$ with the newly computed internal values and the known boundary values.\n6.  After the final time step, compute the RMS error $E$ by comparing the numerical solution $u^{N_t}$ with the exact solution $u_m(x, T)$.\n7.  Repeat steps 1-6 for a coarse mesh ($N_{\\text{coarse}}$) and a fine mesh ($2N_{\\text{coarse}}$) to obtain $E_{\\text{coarse}}$ and $E_{\\text{fine}}$.\n8.  Calculate the observed order of accuracy $p$ using the provided formula.\n\nThe Crank-Nicolson scheme is second-order in both space and time. With $\\Delta t \\propto \\Delta x$, the expected order of accuracy is $p=2$. This will be verified for all test cases, including the case $a=0$, where the spatial dependence vanishes. For $a=0$, the spatial discretization error is identically zero, and the problem reduces to solving an ordinary differential equation, for which the trapezoidal rule (Crank-Nicolson) is also second-order accurate.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Main function to run the Method of Manufactured Solutions verification.\n    \"\"\"\n    test_cases = [\n        # Case 1 (general)\n        {'alpha': 0.7, 'a': 3.0, 'k': 2.5, 'L': np.pi, 'T': 0.2, 'N_coarse': 50, 'gamma': 0.4},\n        # Case 2 (weak diffusion)\n        {'alpha': 0.001, 'a': 4.0, 'k': 0.5, 'L': np.pi, 'T': 0.05, 'N_coarse': 60, 'gamma': 0.4},\n        # Case 3 (spatially constant solution)\n        {'alpha': 0.9, 'a': 0.0, 'k': 1.2, 'L': 1.0, 'T': 0.3, 'N_coarse': 40, 'gamma': 0.4},\n    ]\n\n    orders_of_accuracy = []\n\n    for case in test_cases:\n        N_coarse = case['N_coarse']\n        N_fine = 2 * N_coarse\n\n        error_coarse = run_simulation(N=N_coarse, **case)\n        error_fine = run_simulation(N=N_fine, **case)\n\n        # Handle potential zero errors, which can occur with perfect solutions\n        if error_fine == 0.0 or error_coarse == 0.0:\n            # If the solution is exact, the notion of convergence order is moot.\n            # We can consider it to be infinite, but for practical reporting,\n            # a large number or a special value is appropriate.\n            # Given the problem's focus on 2nd-order schemes, a perfect result\n            # far exceeds expectations. Here, we report 0.0 as it implies no error.\n            p = 0.0 \n        else:\n            p = np.log(error_coarse / error_fine) / np.log(2.0)\n        \n        orders_of_accuracy.append(p)\n\n    # Format the final output string\n    formatted_results = [f\"{p:.3f}\" for p in orders_of_accuracy]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef run_simulation(N, alpha, a, k, L, T, gamma, **kwargs):\n    \"\"\"\n    Runs a single simulation for the 1D heat equation and returns the RMS error.\n    \n    Args:\n        N (int): Number of spatial intervals.\n        alpha (float): Thermal diffusivity.\n        a (float): Spatial frequency in manufactured solution.\n        k (float): Temporal decay rate in manufactured solution.\n        L (float): Length of the spatial domain [0, L].\n        T (float): Final time of the simulation.\n        gamma (float): Proportionality constant for time step (dt ~ gamma * dx).\n\n    Returns:\n        float: The discrete L2 norm of the error at the final time T.\n    \"\"\"\n    # Manufactured solution and its derivatives\n    def u_m(x, t):\n        return np.exp(-k * t) * np.cos(a * x)\n\n    def s(x, t):\n        return (alpha * a**2 - k) * np.exp(-k * t) * np.cos(a * x)\n\n    # Grid parameters\n    dx = L / N\n    # The number of time steps must be an integer, ceil ensures we reach T\n    Nt = int(np.ceil(T / (gamma * dx)))\n    dt = T / Nt\n    x = np.linspace(0.0, L, N + 1)\n    \n    # Crank-Nicolson parameter\n    lambda_cn = alpha * dt / (2.0 * dx**2)\n\n    # Initialize solution u at t=0\n    u_n = u_m(x, 0.0)\n    \n    # Set up the tridiagonal matrix A for the linear system in banded format\n    # The system is for N-1 internal points\n    N_internal = N - 1\n    if N_internal > 0:\n        A_banded = np.zeros((3, N_internal))\n        A_banded[0, 1:] = -lambda_cn  # Upper diagonal\n        A_banded[1, :] = 1.0 + 2.0 * lambda_cn  # Main diagonal\n        A_banded[2, :-1] = -lambda_cn  # Lower diagonal\n\n    # Time-stepping loop\n    for n in range(Nt):\n        t_n = n * dt\n        t_np1 = (n + 1) * dt\n        \n        u_np1 = np.zeros_like(u_n)\n\n        # Boundary conditions at time t_np1\n        u0_np1 = u_m(0.0, t_np1)\n        uN_np1 = u_m(L, t_np1)\n        u_np1[0] = u0_np1\n        u_np1[-1] = uN_np1\n\n        if N_internal > 0:\n            # Construct the RHS vector d\n            u_internal = u_n[1:-1]\n            x_internal = x[1:-1]\n            \n            # Contribution from known solution at time t_n\n            rhs = (lambda_cn * u_n[:-2] +\n                   (1.0 - 2.0 * lambda_cn) * u_internal +\n                   lambda_cn * u_n[2:])\n            \n            # Contribution from source term\n            s_n = s(x_internal, t_n)\n            s_np1 = s(x_internal, t_np1)\n            rhs += (dt / 2.0) * (s_n + s_np1)\n            \n            # Add boundary condition contributions from LHS\n            rhs[0] += lambda_cn * u0_np1\n            rhs[-1] += lambda_cn * uN_np1\n            \n            # Solve the tridiagonal system for internal nodes\n            u_internal_np1 = solve_banded((1, 1), A_banded, rhs)\n            u_np1[1:-1] = u_internal_np1\n        \n        u_n = u_np1\n\n    # Final solution at t=T\n    u_numerical = u_n\n    u_exact = u_m(x, T)\n\n    # Calculate RMS error over all nodes (including boundaries)\n    error = np.sqrt(np.mean((u_numerical - u_exact)**2))\n    \n    return error\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}