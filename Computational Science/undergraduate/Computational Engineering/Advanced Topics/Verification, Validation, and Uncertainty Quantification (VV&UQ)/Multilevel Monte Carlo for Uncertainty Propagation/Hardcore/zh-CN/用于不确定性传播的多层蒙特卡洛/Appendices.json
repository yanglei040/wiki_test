{
    "hands_on_practices": [
        {
            "introduction": "在深入研究 MLMC 的实现细节之前，通过一个理论计算来巩固其核心优势至关重要。本练习旨在量化比较在达到相同精度要求下，多层蒙特卡洛（MLMC）方法与标准蒙特卡洛（MC）方法的计算成本，从而揭示 MLMC 效率增益的来源与条件。",
            "id": "2416330",
            "problem": "一位计算工程师使用多层蒙特卡洛（MLMC）和标准蒙特卡洛（MC）方法来估计一个由随机偏微分方程产生的无量纲感兴趣量（QoI）的均值，该方程在一系列层级化网格上进行数值求解。在层级 $l \\in \\{0,1,\\dots,L\\}$ 上的数值近似使用网格尺寸 $h_l \\propto 2^{-l}$。绝对离散化偏差满足 $|\\mathbb{E}[Q - Q_L]| \\leq c_b 2^{-\\alpha L}$，其中 $c_b = 0.5$ 且 $\\alpha = 2$。在层级 $l$ 上的单个样本成本为 $C_l = 2^{2l}$（两种方法均使用任意但相同的单位）。\n\n对于 MLMC，层级差为 $Y_0 = Q_0$ 和 $Y_l = Q_l - Q_{l-1}$（对于 $l \\ge 1$），通过独立实现进行抽样。层级差的方差为 $V_0 = \\operatorname{Var}(Y_0) = 1.0$ 以及 $V_l = \\operatorname{Var}(Y_l) = 2^{-2l}$（对于 $l \\ge 1$）。对于在最精细层级 $L$ 上的标准 MC，QoI 的方差为 $s^2 = \\operatorname{Var}(Q_L) = 1.0$。假设所有样本在所有层级和实现中都是独立的。\n\n两种方法都必须为连续均值 $\\mathbb{E}[Q]$ 生成一个总宽度为 $W = 1.0 \\times 10^{-2}$ 的双边 $95\\%$ 置信区间。使用保守要求，即离散化偏差的量级以 $W/4$ 为界，且统计半宽度等于 $W/4$。取满足偏差要求的最小整数 $L$，并比较在该 $L$ 下，标准 MC 和 MLMC 为满足统计半宽度要求所需的最小期望计算功。\n\n在这些假设下，标准 MC 的最小期望功与 MLMC 的最小期望功之比是多少？将您的答案四舍五入到三位有效数字。",
            "solution": "该问题要求比较标准蒙特卡洛（MC）和多层蒙特卡洛（MLMC）方法在给定的总误差容限下，估计感兴趣量均值 $\\mathbb{E}[Q]$ 所需的最小计算功。\n\n首先，我们验证问题陈述。\n给定条件如下：\n- 层级体系 $l \\in \\{0, 1, \\dots, L\\}$。\n- 网格尺寸 $h_l \\propto 2^{-l}$。\n- 离散化偏差界：$|\\mathbb{E}[Q - Q_L]| \\le c_b 2^{-\\alpha L}$，其中 $c_b = 0.5$ 且 $\\alpha = 2$。\n- 层级 $l$ 上的每样本成本：$C_l = 2^{2l}$。\n- MLMC 差分：$Y_0 = Q_0$，$Y_l = Q_l - Q_{l-1}$（对于 $l \\ge 1$）。\n- MLMC 方差：$V_0 = \\operatorname{Var}(Y_0) = 1.0$，$V_l = \\operatorname{Var}(Y_l) = 2^{-2l}$（对于 $l \\ge 1$）。\n- 标准 MC 方差：$s^2 = \\operatorname{Var}(Q_L) = 1.0$。\n- $\\mathbb{E}[Q]$ 的总置信区间宽度：$W = 1.0 \\times 10^{-2}$。\n- 偏差约束：$|\\mathbb{E}[Q - Q_L]| \\le W/4$。\n- 统计半宽度约束：统计半宽度 $= W/4$。\n\n该问题具有科学依据，描述了蒙特卡洛方法在计算工程中的一个标准应用。问题提法得当，目标明确，数据充分。语言客观、精确。因此，该问题被认为是有效的。\n\n求解过程分四步进行：\n1.  确定最精细的分辨率层级 $L$。\n2.  计算标准 MC 的最小功，$\\text{Work}_{MC}$。\n3.  计算 MLMC 的最小功，$\\text{Work}_{MLMC}$。\n4.  计算比率 $\\frac{\\text{Work}_{MC}}{\\text{Work}_{MLMC}}$。\n\n步骤 1：确定最精细层级 $L$。\n选择层级 $L$ 以满足离散化偏差约束。给定偏差以 $c_b 2^{-\\alpha L}$ 为界，并且该值必须小于或等于 $W/4$。我们必须找到满足此不等式的最小整数 $L$。\n$$c_b 2^{-\\alpha L} \\le \\frac{W}{4}$$\n代入给定值 $c_b = 0.5$，$\\alpha = 2$ 和 $W = 1.0 \\times 10^{-2}$：\n$$0.5 \\times 2^{-2L} \\le \\frac{1.0 \\times 10^{-2}}{4}$$\n$$0.5 \\times (2^2)^{-L} \\le 0.0025$$\n$$0.5 \\times 4^{-L} \\le 0.0025$$\n$$4^{-L} \\le \\frac{0.0025}{0.5} = 0.005$$\n$$4^L \\ge \\frac{1}{0.005} = 200$$\n我们测试 $L$ 的整数值：$4^3 = 64$ 和 $4^4 = 256$。满足 $4^L \\ge 200$ 的最小整数 $L$ 是 $L=4$。\n\n步骤 2：标准 MC 的最小功。\n标准 MC 估计量在最精细层级 $L=4$ 上使用 $N_{MC}$ 个样本。该估计量为 $\\hat{E}_{MC} = \\frac{1}{N_{MC}} \\sum_{i=1}^{N_{MC}} Q_L^{(i)}$。此估计量的方差为：\n$$\\operatorname{Var}(\\hat{E}_{MC}) = \\frac{\\operatorname{Var}(Q_L)}{N_{MC}} = \\frac{s^2}{N_{MC}}$$\n给定 $s^2 = 1.0$。\n问题陈述，$\\mathbb{E}[Q]$ 的 $95\\%$ 置信区间的总宽度应为 $W$。这个总误差由离散化偏差和统计误差组成。问题为每项误差提供了预算：偏差 $|\\mathbb{E}[Q - Q_L]|$ 以 $W/4$ 为界，$\\mathbb{E}[Q_L]$ 的置信区间的统计半宽度为 $W/4$。\n一个双边 $95\\%$ 置信区间的半宽度为 $z \\sqrt{\\operatorname{Var}(\\text{Estimator})}$，其中 $z \\approx 1.96$ 是 z 分数。因此，统计约束为：\n$$z \\sqrt{\\operatorname{Var}(\\hat{E}_{MC})} = \\frac{W}{4}$$\n$$z \\sqrt{\\frac{s^2}{N_{MC}}} = \\frac{W}{4}$$\n求解所需的样本数 $N_{MC}$：\n$$N_{MC} = \\frac{s^2 z^2}{(W/4)^2}$$\n标准 MC 的计算功（成本）是样本数乘以层级 $L$ 上的每样本成本：\n$$\\text{Work}_{MC} = N_{MC} \\times C_L = \\frac{s^2 z^2}{(W/4)^2} C_L$$\n当 $L=4$ 时，每样本成本为 $C_4 = 2^{2 \\times 4} = 2^8 = 256$。\n\n步骤 3：MLMC 的最小功。\nMLMC 估计量为 $\\hat{E}_{MLMC} = \\sum_{l=0}^{L} \\frac{1}{N_l} \\sum_{i=1}^{N_l} Y_l^{(i)}$。其方差为：\n$$\\operatorname{Var}(\\hat{E}_{MLMC}) = \\sum_{l=0}^{L} \\frac{\\operatorname{Var}(Y_l)}{N_l} = \\sum_{l=0}^{L} \\frac{V_l}{N_l}$$\n统计误差约束与 MC 的相同：\n$$z \\sqrt{\\operatorname{Var}(\\hat{E}_{MLMC})} = \\frac{W}{4} \\implies \\sum_{l=0}^{L} \\frac{V_l}{N_l} = \\frac{(W/4)^2}{z^2}$$\nMLMC 的总功为 $\\text{Work}_{MLMC} = \\sum_{l=0}^{L} N_l C_l$。我们使用拉格朗日乘子法，在方差约束下最小化此功。每个层级 $l$ 的最优样本数 $N_l$ 与 $\\sqrt{V_l / C_l}$ 成正比。\n得到的最小功由以下公式给出：\n$$\\text{Work}_{MLMC} = \\frac{z^2}{(W/4)^2} \\left( \\sum_{l=0}^{L} \\sqrt{V_l C_l} \\right)^2$$\n我们需要计算当 $L=4$ 时的总和 $\\sum_{l=0}^{L} \\sqrt{V_l C_l}$。\n给定值为 $C_l = 2^{2l}$，$V_0 = 1.0$，以及当 $l \\ge 1$ 时 $V_l = 2^{-2l}$。\n对于层级 $l=0$：\n$$\\sqrt{V_0 C_0} = \\sqrt{1.0 \\times 2^{2 \\times 0}} = \\sqrt{1.0 \\times 1} = 1$$\n对于层级 $l \\ge 1$：\n$$\\sqrt{V_l C_l} = \\sqrt{2^{-2l} \\times 2^{2l}} = \\sqrt{1} = 1$$\n当 $L=4$ 时的总和为：\n$$\\sum_{l=0}^{4} \\sqrt{V_l C_l} = \\sqrt{V_0 C_0} + \\sum_{l=1}^{4} \\sqrt{V_l C_l} = 1 + (1+1+1+1) = 5$$\n因此，MLMC 的最小功为：\n$$\\text{Work}_{MLMC} = \\frac{z^2}{(W/4)^2} (5)^2 = \\frac{25 z^2}{(W/4)^2}$$\n\n步骤 4：计算比率。\n我们现在计算标准 MC 的最小功与 MLMC 的最小功之比。\n$$\\frac{\\text{Work}_{MC}}{\\text{Work}_{MLMC}} = \\frac{\\frac{s^2 z^2}{(W/4)^2} C_L}{\\frac{z^2}{(W/4)^2} \\left( \\sum_{l=0}^{L} \\sqrt{V_l C_l} \\right)^2} = \\frac{s^2 C_L}{\\left( \\sum_{l=0}^{L} \\sqrt{V_l C_l} \\right)^2}$$\n注意，包含 $z$ 和 $W$ 的项会消掉。\n代入已知值：$s^2=1.0$, $L=4$, $C_L=C_4=256$ 以及 $\\sum_{l=0}^4 \\sqrt{V_l C_l} = 5$：\n$$\\frac{\\text{Work}_{MC}}{\\text{Work}_{MLMC}} = \\frac{1.0 \\times 256}{5^2} = \\frac{256}{25} = 10.24$$\n问题要求将答案四舍五入到三位有效数字。\n$$10.24 \\approx 10.2$$",
            "answer": "$$\\boxed{10.2}$$"
        },
        {
            "introduction": "MLMC 方法的精髓在于其跨层级的“智能”样本分配策略，该策略旨在以最小的计算代价达到预设的统计精度。本练习将指导您通过编程实现 MLMC 的核心样本数分配公式，并探索在不同参数下，尤其是在方差衰减率与成本增长率接近的“病态”情况下，样本如何在各层级间分布。",
            "id": "2416356",
            "problem": "您正在研究一个通过多层蒙特卡罗估计量在不确定性传播的背景下估计的标量感兴趣量 (QoI)。对于层级 $l \\in \\{0,1,\\dots,L\\}$，假设成本、方差和偏差具有以下模型：\n- 层级 $l$ 的每样本成本为 $C_l = c_c \\, 2^{\\gamma l}$，其中常数 $c_c > 0$ 且 $\\gamma > 0$。\n- 层级 $l$ 的层级差异估计量的方差为 $V_l = c_v \\, 2^{-\\beta l}$，其中常数 $c_v > 0$ 且 $\\beta > 0$。\n- 在层级 $L$ 截断后的绝对偏差为 $B_L = c_b \\, 2^{-\\alpha L}$，其中常数 $c_b > 0$ 且 $\\alpha > 0$。\n\n给定一个均方误差容差 $\\varepsilon > 0$。定义最小截断层级 $L$ 为满足偏差约束 $B_L \\le \\varepsilon / \\sqrt{2}$ 的最小整数 $L \\ge 0$。在方差约束 $\\sum_{l=0}^{L} V_l / N_l \\le \\varepsilon^2 / 2$ 的条件下（其中 $N_l$ 是在层级 $l$ 抽取的独立样本数量），确定能最小化总期望成本 $\\sum_{l=0}^{L} C_l N_l$ 的整数样本数 $\\{N_0,\\dots,N_L\\}$。返回的样本数必须是此约束问题对应实值最小化子的逐分量向上取整。\n\n重点关注方差衰减率 $\\beta$ 非常接近成本增长率 $\\gamma$ 的情况。分析这如何影响样本 $\\{N_l\\}$ 在各层级间的分布。\n\n使用以下参数化测试套件。在所有测试用例中，使用 $c_b = 1.0$、$c_v = 1.0$、$c_c = 1.0$ 和 $\\alpha = 1.0$。\n- 测试 A（速率均衡）：$\\beta = 1.0$，$\\gamma = 1.0$，$\\varepsilon = 2^{-4}$。\n- 测试 B（方差衰减略慢于成本增长）：$\\beta = 0.95$，$\\gamma = 1.0$，$\\varepsilon = 2^{-4}$。\n- 测试 C（方差衰减略快于成本增长）：$\\beta = 1.05$，$\\gamma = 1.0$，$\\varepsilon = 2^{-4}$。\n- 测试 D（粗略容差边界情况）：$\\beta = 1.0$，$\\gamma = 1.0$，$\\varepsilon = 1.5$。\n\n您的程序必须为每个测试用例计算指定的整数向量 $[N_0,\\dots,N_L]$。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个元素是对应一个测试用例（按 A、B、C、D 的顺序）的方括号括起来的逗号分隔整数列表。例如，要求的格式为 $[[n_{A,0},\\dots,n_{A,L_A}],[n_{B,0},\\dots,n_{B,L_B}],[n_{C,0},\\dots,n_{C,L_C}],[n_{D,0},\\dots,n_{D,L_D}]]$，不含空格。",
            "solution": "该问题首先经过严格的验证过程。\n\n已知条件明确陈述如下：\n一个标量感兴趣量 (QoI) 被估计。\n层级由 $l \\in \\{0, 1, \\dots, L\\}$ 表示。\n层级 $l$ 的每样本成本为 $C_l = c_c \\, 2^{\\gamma l}$，其中常数 $c_c > 0$ 且 $\\gamma > 0$。\n层级 $l$ 的层级差异估计量的方差为 $V_l = c_v \\, 2^{-\\beta l}$，其中常数 $c_v > 0$ 且 $\\beta > 0$。\n在层级 $L$ 截断后的绝对偏差为 $B_L = c_b \\, 2^{-\\alpha L}$，其中常数 $c_b > 0$ 且 $\\alpha > 0$。\n均方误差容差为 $\\varepsilon > 0$。\n截断层级 $L$ 是满足偏差约束 $B_L \\le \\varepsilon / \\sqrt{2}$ 的最小整数 $L \\ge 0$。\n方差约束为 $\\sum_{l=0}^{L} V_l / N_l \\le \\varepsilon^2 / 2$，其中 $N_l$ 是层级 $l$ 的样本数。\n目标是确定能最小化总成本 $\\sum_{l=0}^{L} C_l N_l$ 的整数样本数 $\\{N_0, \\dots, N_L\\}$。\n最终的样本数必须是实值最小化子的逐分量向上取整。\n感兴趣的特定情况是当 $\\beta$ 接近 $\\gamma$ 时。\n测试套件参数为：$c_b = 1.0$、$c_v = 1.0$、$c_c = 1.0$、$\\alpha = 1.0$。\n测试 A：$\\beta = 1.0$，$\\gamma = 1.0$，$\\varepsilon = 2^{-4}$。\n测试 B：$\\beta = 0.95$，$\\gamma = 1.0$，$\\varepsilon = 2^{-4}$。\n测试 C：$\\beta = 1.05$，$\\gamma = 1.0$，$\\varepsilon = 2^{-4}$。\n测试 D：$\\beta = 1.0$，$\\gamma = 1.0$，$\\varepsilon = 1.5$。\n\n该问题被认定为有效。它在科学上基于已建立的用于不确定性量化的多层蒙特卡罗 (MLMC) 方法理论。该问题是适定的，构成一个可解的凸优化问题。其语言客观且数学上精确。不存在矛盾、信息缺失或无效前提。因此，我们可以继续推导解答。\n\n总均方误差 (MSE) 的上界是偏差平方与总方差之和。该问题使用总 MSE 容差 $\\varepsilon^2$ 的标准划分，使得 $\\text{Bias}^2 \\le \\varepsilon^2/2$ 且 $\\text{Variance} \\le \\varepsilon^2/2$。\n\n首先，我们确定最小截断层级 $L$。偏差约束为 $B_L \\le \\varepsilon / \\sqrt{2}$。代入 $B_L$ 的模型：\n$$c_b \\, 2^{-\\alpha L} \\le \\frac{\\varepsilon}{\\sqrt{2}}$$\n为求解 $L$，我们对两边取以 2 为底的对数：\n$$-\\alpha L \\le \\log_2\\left(\\frac{\\varepsilon}{c_b\\sqrt{2}}\\right)$$\n$$\\alpha L \\ge -\\log_2\\left(\\frac{\\varepsilon}{c_b\\sqrt{2}}\\right) = \\log_2\\left(\\frac{c_b\\sqrt{2}}{\\varepsilon}\\right)$$\n$$L \\ge \\frac{1}{\\alpha} \\log_2\\left(\\frac{c_b\\sqrt{2}}{\\varepsilon}\\right)$$\n由于 $L$ 必须是满足此不等式的最小非负整数，我们得到：\n$$L = \\max\\left(0, \\left\\lceil \\frac{1}{\\alpha} \\log_2\\left(\\frac{c_b\\sqrt{2}}{\\varepsilon}\\right) \\right\\rceil\\right)$$\n$\\max(0, \\dots)$ 确保了符合条件 $L \\ge 0$，这在容差 $\\varepsilon$ 较大时是相关的。\n\n其次，我们确定对于 $l \\in \\{0, \\dots, L\\}$ 的最优样本数 $N_l$。我们必须在方差约束 $\\sum_{l=0}^{L} V_l/N_l \\le \\varepsilon^2/2$ 下最小化总成本 $\\mathcal{C} = \\sum_{l=0}^{L} C_l N_l$。为了在固定预算下最小化线性成本函数，约束必须是活动的，即取等式：$\\sum_{l=0}^{L} V_l/N_l = \\varepsilon^2/2$。\n我们使用拉格朗日乘子法。拉格朗日函数 $\\mathcal{L}$ 为：\n$$\\mathcal{L}(\\{N_l\\}_{l=0}^L, \\lambda) = \\sum_{l=0}^{L} C_l N_l + \\lambda \\left(\\sum_{l=0}^{L} \\frac{V_l}{N_l} - \\frac{\\varepsilon^2}{2}\\right)$$\n对于一个通用层级 $k$，对 $N_k$ 求导并将结果设为零，得到实值 $N_k$ 的最优分配：\n$$\\frac{\\partial \\mathcal{L}}{\\partial N_k} = C_k - \\lambda \\frac{V_k}{N_k^2} = 0 \\implies N_k = \\sqrt{\\lambda} \\sqrt{\\frac{V_k}{C_k}}$$\n为了找到拉格朗日乘子 $\\lambda$，我们将 $N_l$ 的这个表达式代回方差约束中：\n$$\\sum_{l=0}^{L} \\frac{V_l}{\\sqrt{\\lambda} \\sqrt{V_l/C_l}} = \\frac{1}{\\sqrt{\\lambda}} \\sum_{l=0}^{L} \\sqrt{V_l C_l} = \\frac{\\varepsilon^2}{2}$$\n求解 $\\sqrt{\\lambda}$：\n$$\\sqrt{\\lambda} = \\frac{2}{\\varepsilon^2} \\sum_{l=0}^{L} \\sqrt{V_l C_l}$$\n将此代回 $N_k$ 的表达式中：\n$$N_k = \\left(\\frac{2}{\\varepsilon^2} \\sum_{l=0}^{L} \\sqrt{V_l C_l}\\right) \\sqrt{\\frac{V_k}{C_k}}$$\n这就给出了最优的实值样本数。\n\n第三，我们代入给定的成本模型 $C_l = c_c 2^{\\gamma l}$ 和方差模型 $V_l = c_v 2^{-\\beta l}$：\n$$\\sqrt{V_l C_l} = \\sqrt{(c_v 2^{-\\beta l})(c_c 2^{\\gamma l})} = \\sqrt{c_v c_c} \\, 2^{(\\gamma-\\beta)l/2}$$\n$$\\sqrt{\\frac{V_k}{C_k}} = \\sqrt{\\frac{c_v 2^{-\\beta k}}{c_c 2^{\\gamma k}}} = \\sqrt{\\frac{c_v}{c_c}} \\, 2^{-(\\beta+\\gamma)k/2}$$\n求和项变成一个几何级数：\n$$S = \\sum_{l=0}^{L} \\sqrt{V_l C_l} = \\sqrt{c_v c_c} \\sum_{l=0}^{L} \\left(2^{(\\gamma-\\beta)/2}\\right)^l$$\n如果 $\\gamma = \\beta$，则公比为 1，和为 $S = \\sqrt{c_v c_c} (L+1)$。\n如果 $\\gamma \\ne \\beta$，令 $r = 2^{(\\gamma-\\beta)/2}$。和为 $S = \\sqrt{c_v c_c} \\frac{r^{L+1}-1}{r-1}$。\n那么实值 $N_k$ 为：\n$$N_k = \\frac{2 S}{\\varepsilon^2} \\sqrt{\\frac{c_v}{c_c}} \\, 2^{-(\\beta+\\gamma)k/2}$$\n问题陈述整数样本数是通过对此实值最小化子进行逐分量向上取整得到的：$N_k^{\\text{int}} = \\lceil N_k \\rceil$。\n\n对于 $\\beta \\approx \\gamma$ 的分析是有启发性的。总成本为 $\\mathcal{C} = \\sum C_l N_l = \\sum C_l \\sqrt{\\lambda}\\sqrt{V_l/C_l} = \\sqrt{\\lambda} \\sum \\sqrt{C_l V_l} = \\frac{2}{\\varepsilon^2}S^2$。总成本与和 $S$ 的平方成正比。表达式 $\\sqrt{V_l C_l} \\propto 2^{(\\gamma-\\beta)l/2}$ 指示了在层级 $l$ 每减少一个单位标准差所需的计算工作量。仅当 $\\gamma = \\beta$ 时，这个工作量在所有层级上是恒定的。在这种情况下，对于固定的 $L$，和 $S$ 以及总成本都达到最小化。如果 $\\gamma \\ne \\beta$，成本效益随层级变化，从而增加了所需的总工作量。由于项 $2^{-(\\beta+\\gamma)k/2}$，样本分布 $N_k$ 总是随 $k$ 指数衰减，因为 $\\beta > 0$ 且 $\\gamma > 0$。大多数样本被分配到更粗糙、成本更低的层级。\n\n我们现在为给定的测试用例计算结果。对于所有情况，$c_b=1.0, c_v=1.0, c_c=1.0, \\alpha=1.0$。\n$L$ 的公式简化为 $L = \\max(0, \\lceil 0.5 - \\log_2(\\varepsilon) \\rceil)$。\n$N_k$ 的公式简化为 $N_k = \\frac{2}{\\varepsilon^2} \\left(\\sum_{l=0}^{L} 2^{(\\gamma - \\beta)l/2}\\right) 2^{-(\\beta + \\gamma)k/2}$。\n\n测试 A：$\\beta = 1.0, \\gamma = 1.0, \\varepsilon = 2^{-4}$。\n$L = \\max(0, \\lceil 0.5 - (-4) \\rceil) = \\lceil 4.5 \\rceil = 5$。\n$\\gamma = \\beta$，所以和为 $L+1 = 6$。\n$N_k = \\frac{2}{(2^{-4})^2} (6) 2^{-(1.0+1.0)k/2} = 2 \\cdot 2^8 \\cdot 6 \\cdot 2^{-k} = 12 \\cdot 2^{8-k} = 3 \\cdot 2^{10-k}$。\n$N_0=3072, N_1=1536, N_2=768, N_3=384, N_4=192, N_5=96$。\n这些都是整数，所以向上取整没有影响。结果：$[3072, 1536, 768, 384, 192, 96]$。\n\n测试 B：$\\beta = 0.95, \\gamma = 1.0, \\varepsilon = 2^{-4}$。\n$L=5$。$\\gamma - \\beta = 0.05$。$\\beta + \\gamma = 1.95$。\n令 $r = 2^{0.025}$。和为 $\\frac{r^6-1}{r-1} \\approx 6.2683$。\n$N_k = \\frac{2}{2^{-8}} (6.2683) 2^{-1.95k/2} = 512 \\cdot (6.2683) \\cdot 2^{-0.975k} \\approx 3209.33 \\cdot 2^{-0.975k}$。\n$N_0 \\approx 3209.33 \\implies \\lceil N_0 \\rceil = 3210$。\n$N_1 \\approx 1632.74 \\implies \\lceil N_1 \\rceil = 1633$。\n$N_2 \\approx 830.61 \\implies \\lceil N_2 \\rceil = 831$。\n$N_3 \\approx 422.58 \\implies \\lceil N_3 \\rceil = 423$。\n$N_4 \\approx 214.97 \\implies \\lceil N_4 \\rceil = 215$。\n$N_5 \\approx 109.37 \\implies \\lceil N_5 \\rceil = 110$。\n结果：$[3210, 1633, 831, 423, 215, 110]$。\n\n测试 C：$\\beta = 1.05, \\gamma = 1.0, \\varepsilon = 2^{-4}$。\n$L=5$。$\\gamma - \\beta = -0.05$。$\\beta + \\gamma = 2.05$。\n令 $r = 2^{-0.025}$。和为 $\\frac{r^6-1}{r-1} \\approx 5.7480$。\n$N_k = \\frac{2}{2^{-8}} (5.7480) 2^{-2.05k/2} = 512 \\cdot (5.7480) \\cdot 2^{-1.025k} \\approx 2942.99 \\cdot 2^{-1.025k}$。\n$N_0 \\approx 2942.99 \\implies \\lceil N_0 \\rceil = 2943$。\n$N_1 \\approx 1445.56 \\implies \\lceil N_1 \\rceil = 1446$。\n$N_2 \\approx 709.97 \\implies \\lceil N_2 \\rceil = 710$。\n$N_3 \\approx 348.72 \\implies \\lceil N_3 \\rceil = 349$。\n$N_4 \\approx 171.27 \\implies \\lceil N_4 \\rceil = 172$。\n$N_5 \\approx 84.11 \\implies \\lceil N_5 \\rceil = 85$。\n结果：$[2943, 1446, 710, 349, 172, 85]$。\n\n测试 D：$\\beta = 1.0, \\gamma = 1.0, \\varepsilon = 1.5$。\n$L = \\max(0, \\lceil 0.5 - \\log_2(1.5) \\rceil) = \\max(0, \\lceil 0.5 - 0.585 \\rceil) = \\max(0, \\lceil -0.085 \\rceil) = \\max(0, 0) = 0$。\n问题简化为单层蒙特卡罗 ($l=0$)。求和只有一个项。\n$N_0 = \\frac{2 V_0}{\\varepsilon^2} = \\frac{2 \\cdot (1.0 \\cdot 2^{-1.0 \\cdot 0})}{1.5^2} = \\frac{2}{2.25} = \\frac{8}{9} \\approx 0.888...$\n$N_0^{\\text{int}} = \\lceil 8/9 \\rceil = 1$。\n结果：$[1]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes optimal integer sample counts for Multilevel Monte Carlo (MLMC)\n    based on given cost, variance, and bias models.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'name': 'A', 'beta': 1.0, 'gamma': 1.0, 'eps': 2**(-4)},\n        {'name': 'B', 'beta': 0.95, 'gamma': 1.0, 'eps': 2**(-4)},\n        {'name': 'C', 'beta': 1.05, 'gamma': 1.0, 'eps': 2**(-4)},\n        {'name': 'D', 'beta': 1.0, 'gamma': 1.0, 'eps': 1.5},\n    ]\n\n    # Common parameters for all test cases\n    cb = 1.0\n    cv = 1.0\n    cc = 1.0\n    alpha = 1.0\n    \n    results = []\n    \n    for case in test_cases:\n        beta = case['beta']\n        gamma = case['gamma']\n        eps = case['eps']\n\n        # Step 1: Determine the truncation level L\n        # L is the smallest non-negative integer satisfying the bias constraint:\n        # cb * 2**(-alpha*L) = eps / sqrt(2)\n        # which implies L >= (1/alpha) * log2(cb*sqrt(2)/eps).\n        log_arg = cb * np.sqrt(2) / eps\n        # The formula for L can result in a negative value if eps is large,\n        # so we take the max with 0 as L must be a non-negative integer.\n        L_val = (1.0 / alpha) * np.log2(log_arg)\n        L = max(0, int(np.ceil(L_val)))\n        \n        levels = np.arange(L + 1)\n        \n        # Step 2: Calculate the sum term for the optimal N_l formula\n        # sum_term = sum_{l=0 to L} sqrt(V_l * C_l)\n        # V_l*C_l = (cv * 2**(-beta*l)) * (cc * 2**(gamma*l)) = cv*cc*2**((gamma-beta)*l)\n        # sqrt(V_l*C_l) = sqrt(cv*cc) * 2**((gamma-beta)*l/2)\n        sum_base = np.sqrt(cv * cc)\n        \n        if gamma == beta:\n            sum_val = sum_base * (L + 1)\n        else:\n            r = 2**((gamma - beta) / 2.0)\n            sum_val = sum_base * (r**(L + 1) - 1) / (r - 1)\n\n        # Step 3: Calculate the integer sample counts N_k for k=0,...,L\n        # N_k = (2/eps^2) * sum_val * sqrt(V_k/C_k)\n        # sqrt(V_k/C_k) = sqrt(cv/cc) * 2**(-(beta+gamma)*k/2)\n        \n        Nk_list = []\n        for k in levels:\n            sqrt_vk_ck_ratio = np.sqrt(cv / cc) * (2**(- (beta + gamma) * k / 2.0))\n            Nk_real = (2.0 / eps**2) * sum_val * sqrt_vk_ck_ratio\n            Nk_int = int(np.ceil(Nk_real))\n            Nk_list.append(Nk_int)\n        \n        results.append(Nk_list)\n\n    # Final print statement in the exact required format.\n    # Format: [[n_A_0,...,n_A_L_A],[n_B_0,...,n_B_L_B],...] with no spaces.\n    results_str_parts = []\n    for res_list in results:\n        part = f\"[{','.join(map(str, res_list))}]\"\n        results_str_parts.append(part)\n    \n    final_output = f\"[{','.join(results_str_parts)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "理论的最终目的是解决实际问题，这个综合性练习将引导您将 MLMC 方法应用于一个真实的工程场景：超大规模集成电路（VLSI）的信号延迟分析。您需要从建立物理模型、设计数值求解器开始，最终将整个仿真流程嵌入 MLMC 框架中，以高效地评估因制造变异引起的不确定性对电路性能的影响。",
            "id": "2416335",
            "problem": "您需要实现一个完整、可运行的程序，该程序使用多层蒙特卡洛（MLMC）方法，在存在制造可变性的情况下，估算超大规模集成（VLSI）互连线中的预期信号延迟。估算目标是远端节点电压达到单位阶跃输入指定阈值分数所需时间的期望值，以秒为单位，四舍五入到浮点精度。\n\n物理模型应基于以下基本原理和核心定义：\n- 电阻介质中的欧姆定律：对于长度为 $L$、横截面积为 $A$ 的均匀导体，其电阻为 $R = \\rho \\, L / A$，其中 $\\rho$ 是电阻率。\n- 平行板电容：对于面积为 $A$、由厚度为 $h$、介电常数为 $\\varepsilon$ 的电介质隔开的极板，其电容为 $C = \\varepsilon \\, A / h$。针对边缘（Fringing）场的常见工程修正是使用有效板宽 $W_{\\text{eff}} = W + 2h/\\pi$，其中 $W$ 是物理宽度。\n- 一阶系统阶跃响应：对于单位阶跃输入 $u(t)$，单个电阻-电容网络遵循线性微分方程 $C \\, \\mathrm{d}v/\\mathrm{d}t + (1/R)\\,v = (1/R)\\,u(t)$，达到固定阈值（例如 $v^\\star = 0.5$）的时间通过求解阶跃响应中的 $t$ 来确定。在分布式互连线中，该线路被建模为通过空间离散化得到的电阻-电容梯形网络；所得到的半离散线性微分系统可以使用无条件稳定的后向欧拉法进行时间积分。\n\n数学和数值模型：\n- 几何与材料：一根长度为 $L$、矩形横截面宽度为 $W$、厚度为 $T$ 的互连线，运行在接地平面之上，由厚度为 $h$、介电常数为 $\\varepsilon = \\varepsilon_{0}\\varepsilon_{r}$ 的电介质隔开，其中 $\\varepsilon_{0}$ 是真空介电常数，$\\varepsilon_{r}$ 是相对介电常数。电阻率为 $\\rho$。\n- 随机输入：由于制造可变性，宽度 $W$ 和厚度 $T$ 是独立的，服从均值为 $\\mu_{W}$ 和 $\\mu_{T}$、标准差为 $\\sigma_{W}$ 和 $\\sigma_{T}$ 的正态分布，并在严格为正的下界 $w_{\\min}$ 和 $t_{\\min}$ 处进行截断，以强制符合物理现实。也就是说，通过拒绝采样法抽取 $W \\sim \\max(\\mathcal{N}(\\mu_{W}, \\sigma_{W}^{2}), w_{\\min})$ 和 $T \\sim \\max(\\mathcal{N}(\\mu_{T}, \\sigma_{T}^{2}), t_{\\min})$。\n- 空间离散化层次结构：为层级 $\\ell \\in \\{0,1,\\dots,L\\}$ 构建 $L+1$ 个级别的均匀空间网格，每层有 $N_{\\ell} = N_{0}\\, 2^{\\ell}$ 个分段，其中 $N_{0} \\in \\mathbb{N}$。令 $\\Delta x_{\\ell} = L/N_{\\ell}$。在每个层级上，将互连线表示为电阻-电容梯形网络：每个分段的电阻为 $r_{\\text{seg}} = \\rho \\, \\Delta x_{\\ell} /(W T)$，每个内部节点到地的电容为 $c_{\\text{node}} = \\varepsilon \\, W_{\\text{eff}} \\, \\Delta x_{\\ell} / h$，其中 $W_{\\text{eff}} = W + 2h/\\pi$。\n- 时间积分：对节点电压的半离散线性系统应用时间步长为 $\\Delta t_{\\ell}$ 的后向欧拉法。输入端的驱动节点是一个幅值为1的单位阶跃的狄利克雷边界；远端开路（无负载）。使用固定阈值 $v^{\\star} = 0.5$ 来定义延迟可观测量 $P_{\\ell}(W,T)$，即远端节点电压首次达到 $v^{\\star}$ 的时间 $t$，该值在时间步之间进行线性插值。选择与扩散时间尺度 $r' c' L^{2}$ 成比例的仿真时域 $T_{\\max}$，其中 $r' = \\rho/(W T)$ 和 $c' = \\varepsilon W_{\\text{eff}}/h$，即对于一个固定因子 $\\alpha0$，有 $T_{\\max} = \\alpha \\, r' c' L^{2}$。使用与层级相关的步数 $M_{\\ell} = M_{0}\\,2^{\\ell}$ 和 $\\Delta t_{\\ell} = T_{\\max}/M_{\\ell}$。\n- 目标量：对于任何实现 $(W,T)$ 和层级 $\\ell$，计算 $Y_{\\ell}(W,T) := P_{\\ell}(W,T)$，即估算的 $v^{\\star}$ 穿越时间，单位为秒。\n\n多层蒙特卡洛（MLMC）估算器：\n- 使用伸缩和表示最精细层级 $L$ 的期望值：$$\\mathbb{E}[Y_{L}] = \\mathbb{E}[Y_{0}] + \\sum_{\\ell=1}^{L} \\mathbb{E}[Y_{\\ell} - Y_{\\ell-1}]$$并通过蒙特卡洛样本均值来估算每个期望值，其中层级间的耦合在同一采样索引下对 $Y_{\\ell}$ 和 $Y_{\\ell-1}$ 使用共享的随机输入 $(W,T)$。\n- 方差驱动的样本分配：令 $V_{\\ell}$ 表示 $\\ell=0$ 时 $Y_{0}$ 的方差以及 $\\ell \\ge 1$ 时 $(Y_{\\ell}-Y_{\\ell-1})$ 的方差，$C_{\\ell}$ 表示层级 $\\ell$ 上每个样本的工作量（与 $N_{\\ell} M_{\\ell}$ 成正比）。给定一个均方根误差容限 $\\varepsilon$，将其分解为方差和偏差目标。使用 $V_{\\ell}$ 和 $C_{\\ell}$ 的试点估算值，根据标准的渐近最优法则 $N_{\\ell} \\propto \\sqrt{V_{\\ell}/C_{\\ell}}$ 来分配每层的样本数量 $N_{\\ell}$，并进行归一化以达到方差目标。通过限制最大层级 $L$ 并确保 $(Y_{L}-Y_{L-1})$ 的均值相对于 $\\varepsilon$ 足够小来控制偏差。\n\n实现要求：\n- 您的程序必须实现上述模型和估算器。它必须使用固定的伪随机数生成器种子，以确保每次运行结果的可复现性。\n- 为保证数值鲁棒性，通过拒绝采样法确保 $W \\ge w_{\\min}$ 和 $T \\ge t_{\\min}$。\n- 最终答案必须以秒为单位，表示为浮点数。\n\n测试套件：\n实现您的程序，为以下三种情况运行MLMC估算器。在所有情况下，均使用 $v^{\\star} = 0.5$，$\\alpha = 10$，$N_{0} = 8$，$M_{0} = 80$，$L_{\\max} = 3$，$w_{\\min} = \\mu_{W}/3$ 和 $t_{\\min} = \\mu_{T}/3$。真空介电常数为 $\\varepsilon_{0} = 8.8541878128 \\times 10^{-12}\\ \\text{F/m}$。最终输出必须是单行文本，包含一个Python风格的列表，其中按以下案例顺序包含三个预期的延迟时间（以秒为单位），不含任何其他文本。\n\n- 案例 A (理想情况):\n  - $L = 5.0 \\times 10^{-4}\\ \\text{m}$, $h = 2.0 \\times 10^{-7}\\ \\text{m}$, $\\rho = 1.68 \\times 10^{-8}\\ \\Omega\\cdot\\text{m}$, $\\varepsilon_{r} = 3.9$,\n  - $\\mu_{W} = 1.2 \\times 10^{-7}\\ \\text{m}$, $\\sigma_{W} = 1.2 \\times 10^{-8}\\ \\text{m}$,\n  - $\\mu_{T} = 6.0 \\times 10^{-8}\\ \\text{m}$, $\\sigma_{T} = 8.0 \\times 10^{-9}\\ \\text{m}$,\n  - MLMC 容限 $\\varepsilon = 1.0 \\times 10^{-12}\\ \\text{s}$。\n\n- 案例 B (薄金属，延迟较大；高电阻的边缘情况):\n  - $L = 5.0 \\times 10^{-4}\\ \\text{m}$, $h = 2.0 \\times 10^{-7}\\ \\text{m}$, $\\rho = 1.68 \\times 10^{-8}\\ \\Omega\\cdot\\text{m}$, $\\varepsilon_{r} = 3.9$,\n  - $\\mu_{W} = 1.2 \\times 10^{-7}\\ \\text{m}$, $\\sigma_{W} = 1.2 \\times 10^{-8}\\ \\text{m}$,\n  - $\\mu_{T} = 4.0 \\times 10^{-8}\\ \\text{m}$, $\\sigma_{T} = 6.0 \\times 10^{-9}\\ \\text{m}$,\n  - MLMC 容限 $\\varepsilon = 1.5 \\times 10^{-12}\\ \\text{s}$。\n\n- 案例 C (低k电介质，延迟较小；电容减小的边缘情况):\n  - $L = 5.0 \\times 10^{-4}\\ \\text{m}$, $h = 2.0 \\times 10^{-7}\\ \\text{m}$, $\\rho = 1.68 \\times 10^{-8}\\ \\Omega\\cdot\\text{m}$, $\\varepsilon_{r} = 2.5$,\n  - $\\mu_{W} = 1.2 \\times 10^{-7}\\ \\text{m}$, $\\sigma_{W} = 1.2 \\times 10^{-8}\\ \\text{m}$,\n  - $\\mu_{T} = 6.0 \\times 10^{-8}\\ \\text{m}$, $\\sigma_{T} = 8.0 \\times 10^{-9}\\ \\text{m}$,\n  - MLMC 容限 $\\varepsilon = 1.0 \\times 10^{-12}\\ \\text{s}$。\n\n输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，格式为 [案例A结果, 案例B结果, 案例C结果]，例如“[resultA,resultB,resultC]”。每个结果都必须是单个浮点数，单位为秒。\n\n所有角度（如有）必须以弧度为单位。本问题中没有百分比；任何分数量都必须以小数形式表示。\n\n您的程序必须完全自包含，不得要求任何用户输入，也不得访问文件或网络。它必须遵守指定的执行环境。",
            "solution": "该问题要求使用多层蒙特卡洛（MLMC）方法估算VLSI互连线中信号传播延迟的期望值。互连线的几何参数，即宽度 $W$ 和厚度 $T$，受制造可变性影响，并被建模为随机变量。\n\n解决方案的制定首先为互连线的单次实现建立物理和数值模型，然后将此模型嵌入MLMC统计框架中。\n\n### 1. 物理和数值模型\n\n一根长度为 $L$、宽度为 $W$、厚度为 $T$ 且位于接地平面上方的互连线，被建模为分布式电阻-电容（RC）线路。为了进行数值模拟，这条连续线路在给定的细化层级 $\\ell$ 上被离散化为一个包含 $S_{\\ell}$ 个分段的梯形网络。\n\n**1.1. RC梯形网络参数**\n\n对于层级 $\\ell$，均匀空间分段的数量为 $S_{\\ell} = N_{0} 2^{\\ell}$，其中 $N_{0}$ 是基础分段数。每个分段的长度为 $\\Delta x_{\\ell} = L / S_{\\ell}$。\n\n- **每分段电阻 ($r_{\\text{seg}}$)**: 根据欧姆定律，单个分段的电阻由以下公式给出：\n$$r_{\\text{seg}} = \\frac{\\rho \\Delta x_{\\ell}}{W T}$$\n其中 $\\rho$ 是电阻率， $W$ 和 $T$ 是给定样本的随机宽度和厚度。\n\n- **每节点电容 ($c_{\\text{node}}$)**: 到接地平面的电容采用带有边缘场修正的平行板公式进行建模。一个分段的总电容归属于其节点。我们采用标准的 $\\Pi$ 模型，其中一个分段的电容平均分配给其两端的节点。因此，梯形网络的内部节点会从两个相邻分段累积电容，而末端节点只从一个分段接收电容。\n用于电容计算的有效宽度为 $W_{\\text{eff}} = W + 2h/\\pi$，其中 $h$ 是电介质厚度。长度为 $\\Delta x_{\\ell}$ 的电容为：\n$$c_{\\text{node}} = \\frac{\\varepsilon W_{\\text{eff}} \\Delta x_{\\ell}}{h}$$\n其中 $\\varepsilon = \\varepsilon_{0}\\varepsilon_{r}$ 是介电常数。\n根据 $\\Pi$ 模型，每个内部节点 ($i=1, \\dots, S_{\\ell}-1$) 的电容为 $C_i = c_{\\text{node}}$，远端节点 ($i=S_{\\ell}$) 的电容为 $C_{S_{\\ell}} = c_{\\text{node}}/2$。\n\n**1.2. 半离散方程组**\n\nRC梯形网络由 $S_{\\ell}$ 个电压未知的节点组成，标记为 $v_1, \\dots, v_{S_{\\ell}}$。输入节点 $v_0$ 由单位阶跃电压源驱动，对于 $t \\ge 0$，$v_0(t)=1$。在每个节点 $i$ 应用基尔霍夫电流定律，得到一个一阶常微分方程（ODE）组：\n- 对于内部节点 $i \\in \\{1, \\dots, S_{\\ell}-1\\}$：\n$$C_i \\frac{\\mathrm{d}v_i}{\\mathrm{d}t} = \\frac{v_{i-1} - v_i}{r_{\\text{seg}}} - \\frac{v_i - v_{i+1}}{r_{\\text{seg}}}$$\n- 对于开路远端节点 $i = S_{\\ell}$：\n$$C_{S_{\\ell}} \\frac{\\mathrm{d}v_{S_{\\ell}}}{\\mathrm{d}t} = \\frac{v_{S_{\\ell}-1} - v_{S_{\\ell}}}{r_{\\text{seg}}}$$\n\n该系统可以写成矩阵形式：$\\mathbf{C} \\frac{\\mathrm{d}\\mathbf{v}}{\\mathrm{d}t} = -\\mathbf{K}\\mathbf{v} + \\mathbf{b}$，其中 $\\mathbf{v} = [v_1, \\dots, v_{S_{\\ell}}]^T$，$\\mathbf{C}$ 是节点电容的对角矩阵，$\\mathbf{K}$ 是对称正定的电导矩阵，$\\mathbf{b}$ 是来自输入 $v_0$ 的源向量。\n\n**1.3. 时间积分**\n\n该ODE系统使用后向欧拉法进行时间积分，该方法是无条件稳定的，因此适用于可能存在的刚性RC网络。时域被离散化为 $M_{\\ell} = M_{0} 2^{\\ell}$ 个步长，步长大小为 $\\Delta t_{\\ell} = T_{\\max} / M_{\\ell}$。选择足够长的仿真时域 $T_{\\max} = \\alpha r' c' L^2$ 以观察延迟，其中 $r' = \\rho/(WT)$ 且 $c' = \\varepsilon W_{\\text{eff}}/h$。\n\n从时间步 $k$ 到 $k+1$ 的后向欧拉更新由下式给出：\n$$\\mathbf{C} \\frac{\\mathbf{v}^{k+1} - \\mathbf{v}^k}{\\Delta t_{\\ell}} = -\\mathbf{K}\\mathbf{v}^{k+1} + \\mathbf{b}$$\n重新整理后，在每个时间步都需要为 $\\mathbf{v}^{k+1}$ 求解一个线性系统：\n$$(\\mathbf{C} + \\Delta t_{\\ell} \\mathbf{K}) \\mathbf{v}^{k+1} = \\mathbf{C}\\mathbf{v}^k + \\Delta t_{\\ell} \\mathbf{b}$$\n从初始条件 $\\mathbf{v}^0 = \\mathbf{0}$ 开始，我们迭代此方程。矩阵 $\\mathbf{A}_{\\text{BE}} = \\mathbf{C} + \\Delta t_{\\ell} \\mathbf{K}$ 是三对角的，因此该系统可以在 $O(S_{\\ell})$ 次运算内高效求解。\n\n目标量 $P_{\\ell}(W,T)$ 是远端节点电压 $v_{S_{\\ell}}(t)$ 首次达到阈值 $v^{\\star}=0.5$ 的时间。如果 $v_{S_{\\ell}}$ 在时间步 $k$ 和 $k+1$ 之间穿过阈值，则通过线性插值计算延迟。\n\n### 2. 多层蒙特卡洛（MLMC）估算器\n\n目标是计算 $\\mathbb{E}[Y_L]$，其中 $Y_\\ell = P_\\ell(W,T)$ 是在层级 $\\ell$ 计算的延迟，$L=L_{\\max}$ 是最精细的层级。MLMC基于伸缩和：\n$$\\mathbb{E}[Y_L] = \\mathbb{E}[Y_0] + \\sum_{\\ell=1}^{L} \\mathbb{E}[Y_\\ell - Y_{\\ell-1}]$$\n$\\mathbb{E}[Y_L]$ 的MLMC估算器 $\\hat{Y}_{L}^{\\text{MLMC}}$ 为：\n$$\\hat{Y}_{L}^{\\text{MLMC}} = \\frac{1}{K_0}\\sum_{i=1}^{K_0} Y_0^{(i)} + \\sum_{\\ell=1}^{L} \\frac{1}{K_\\ell}\\sum_{i=1}^{K_\\ell} (Y_\\ell^{(i)} - Y_{\\ell-1}^{(i)})$$\n此处，$K_\\ell$ 是层级 $\\ell$ 的蒙特卡洛样本数。关键在于耦合：对于层级 $\\ell \\ge 1$ 的求和中的每个样本 $i$，使用相同的随机输入 $(W^{(i)}, T^{(i)})$ 来计算 $Y_\\ell^{(i)}$ 和 $Y_{\\ell-1}^{(i)}$。这确保了差值的方差 $V_\\ell = \\text{Var}[Y_\\ell - Y_{\\ell-1}]$ 随着层级 $\\ell$ 的增加而减小。\n\n**2.1. 最优样本分配**\n\n估算器的总均方误差（MSE）为 $\\text{MSE} = \\text{Var}[\\hat{Y}_{L}^{\\text{MLMC}}] + (\\text{Bias})^2 \\le \\varepsilon^2$，其中 $\\varepsilon$ 是期望的均方根误差。方差为 $\\text{Var}[\\hat{Y}_{L}^{\\text{MLMC}}] = \\sum_{\\ell=0}^{L} V_\\ell/K_\\ell$，其中 $V_0 = \\text{Var}[Y_0]$。偏差是由层级 $L$ 的有限离散化引起的。\n\n我们将一半的误差预算分配给方差，即 $\\sum_{\\ell=0}^{L} V_\\ell/K_\\ell \\le \\varepsilon^2/2$。选择每个层级的样本数 $K_\\ell$ 以最小化总计算成本 $\\sum_{\\ell=0}^{L} K_\\ell C_\\ell$，其中 $C_\\ell \\propto S_\\ell M_\\ell$ 是层级 $\\ell$ 上每个样本的成本。最优样本数由以下公式给出：\n$$K_\\ell = \\left\\lceil \\frac{2}{\\varepsilon^2} \\left(\\sum_{k=0}^{L} \\sqrt{V_k C_k}\\right) \\sqrt{\\frac{V_\\ell}{C_\\ell}} \\right\\rceil$$\n\n**2.2. 算法**\n\n实际算法流程如下：\n1.  **试点阶段**：在所有层级 $\\ell=0, \\dots, L$ 上模拟少量样本（$K_{\\text{pilot}}$）。这用于获取均值 $\\mathbb{E}[Y_\\ell - Y_{\\ell-1}]$ 和方差 $V_\\ell$ 的初始估算。成本 $C_\\ell = S_\\ell M_\\ell$ 是先验已知的。\n2.  **样本分配**：使用 $V_\\ell$ 的试点估算和已知的成本 $C_\\ell$，根据上述公式计算每个层级的最优样本数 $K_\\ell$。\n3.  **主要模拟**：对于每个层级 $\\ell$，运行额外的模拟，直到总样本数达到 $K_\\ell$。计算 $Y_0$ 的样本均值和差值 $(Y_\\ell - Y_{\\ell-1})$ 的样本均值。\n4.  **最终估算**：根据伸缩和公式，将上一步计算出的样本均值相加，得到最终的MLMC估算值。\n\n随机输入 $W$ 和 $T$ 是使用拒绝采样法从截断正态分布中抽取的，以确保它们在物理上是现实的（$W \\ge w_{\\min}, T \\ge t_{\\min}$）。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve_banded\nfrom math import pi\n\ndef solve():\n    \"\"\"\n    Main function to solve the VLSI delay estimation problem for all test cases.\n    \"\"\"\n    # Physical and numerical constants\n    EPS0 = 8.8541878128e-12\n    V_STAR = 0.5\n    ALPHA = 10.0\n    N0 = 8\n    M0 = 80\n    L_MAX = 3\n    \n    test_cases = [\n        # Case A\n        {\n            'L': 5.0e-4, 'h': 2.0e-7, 'rho': 1.68e-8, 'eps_r': 3.9,\n            'mu_W': 1.2e-7, 'sigma_W': 1.2e-8,\n            'mu_T': 6.0e-8, 'sigma_T': 8.0e-9,\n            'mlmc_tol': 1.0e-12\n        },\n        # Case B\n        {\n            'L': 5.0e-4, 'h': 2.0e-7, 'rho': 1.68e-8, 'eps_r': 3.9,\n            'mu_W': 1.2e-7, 'sigma_W': 1.2e-8,\n            'mu_T': 4.0e-8, 'sigma_T': 6.0e-9,\n            'mlmc_tol': 1.5e-12\n        },\n        # Case C\n        {\n            'L': 5.0e-4, 'h': 2.0e-7, 'rho': 1.68e-8, 'eps_r': 2.5,\n            'mu_W': 1.2e-7, 'sigma_W': 1.2e-8,\n            'mu_T': 6.0e-8, 'sigma_T': 8.0e-9,\n            'mlmc_tol': 1.0e-12\n        }\n    ]\n\n    results = []\n    for params in test_cases:\n        # Add constants to the parameter dictionary\n        params.update({'v_star': V_STAR, 'alpha': ALPHA, 'N0': N0, 'M0': M0, 'eps0': EPS0})\n        result = mlmc_estimator(params, L_MAX)\n        results.append(result)\n\n    # Print results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef generate_wt_sample(params, rng):\n    \"\"\"\n    Generates a sample of (W, T) using rejection sampling from a truncated normal distribution.\n    \"\"\"\n    mu_W, sigma_W = params['mu_W'], params['sigma_W']\n    w_min = mu_W / 3.0\n    while True:\n        W = rng.normal(mu_W, sigma_W)\n        if W >= w_min:\n            break\n            \n    mu_T, sigma_T = params['mu_T'], params['sigma_T']\n    t_min = mu_T / 3.0\n    while True:\n        T = rng.normal(mu_T, sigma_T)\n        if T >= t_min:\n            break\n            \n    return W, T\n\ndef compute_delay(params, W, T, level):\n    \"\"\"\n    Computes the signal delay for a single sample (W, T) at a given discretization level.\n    \"\"\"\n    S_l = params['N0'] * (2**level)\n    M_l = params['M0'] * (2**level)\n    \n    eps = params['eps0'] * params['eps_r']\n    W_eff = W + 2 * params['h'] / pi\n    \n    r_prime = params['rho'] / (W * T)\n    c_prime = eps * W_eff / params['h']\n    \n    delta_x = params['L'] / S_l\n    r_seg = r_prime * delta_x\n    c_node = c_prime * delta_x\n    \n    T_max = params['alpha'] * r_prime * c_prime * params['L']**2\n    delta_t = T_max / M_l\n    \n    if r_seg == 0 or c_node == 0: return 0.0\n    g = 1.0 / r_seg\n\n    # Coefficients for the backward Euler tridiagonal system\n    k1 = delta_t * g / c_node\n    k2 = delta_t * g / (c_node / 2.0)\n    \n    # SciPy's banded solver format: ab[u+i-j, j] = A[i,j]\n    # For u=1, l=1: ab[0,:]=super, ab[1,:]=main, ab[2,:]=sub\n    ab = np.zeros((3, S_l))\n    # Super-diagonal (A[i, i+1]) -> ab[0, i+1]\n    ab[0, 1:] = -k1\n    # Main-diagonal (A[i, i]) -> ab[1, i]\n    ab[1, :S_l-1] = 1.0 + 2.0 * k1\n    ab[1, S_l-1] = 1.0 + k2\n    # Sub-diagonal (A[i+1, i]) -> ab[2, i]\n    ab[2, :S_l-1] = -k1\n    if S_l > 1:\n        ab[2, S_l-2] = -k2\n\n    # Time stepping\n    v = np.zeros(S_l)\n    \n    for k in range(int(M_l)):\n        v_old = v.copy()\n        \n        rhs = v_old\n        rhs[0] += k1 # Add source term\n        \n        v = solve_banded((1, 1), ab, rhs, check_finite=False)\n        \n        if v[-1] >= params['v_star']:\n            v_far_end_old = v_old[-1]\n            v_far_end_new = v[-1]\n            \n            t_old = k * delta_t\n            t_new = (k + 1) * delta_t\n\n            if v_far_end_new == v_far_end_old: return t_new\n            \n            delay = t_old + (t_new - t_old) * (params['v_star'] - v_far_end_old) / (v_far_end_new - v_far_end_old)\n            return delay\n\n    return T_max # Should not be reached with adequate alpha\n\ndef mlmc_estimator(params, L_max):\n    \"\"\"\n    Implements the Multilevel Monte Carlo estimator for a given test case.\n    \"\"\"\n    K_pilot = 200\n    eps = params['mlmc_tol']\n    rng = np.random.default_rng(seed=12345)\n\n    # --- Pilot Stage ---\n    means = [0.0] * (L_max + 1)\n    variances = [0.0] * (L_max + 1)\n    costs = [0.0] * (L_max + 1)\n\n    Y_samples = [np.zeros(K_pilot) for _ in range(L_max + 1)]\n    for i in range(K_pilot):\n        W, T = generate_wt_sample(params, rng)\n        for l in range(L_max + 1):\n            Y_samples[l][i] = compute_delay(params, W, T, l)\n\n    for l in range(L_max + 1):\n        if l == 0:\n            diff_samples = Y_samples[0]\n        else:\n            diff_samples = Y_samples[l] - Y_samples[l-1]\n        \n        means[l] = np.mean(diff_samples)\n        variances[l] = np.var(diff_samples)\n        S_l = params['N0'] * (2**l)\n        M_l = params['M0'] * (2**l)\n        costs[l] = float(S_l * M_l)\n\n    # --- Sample Allocation ---\n    optimal_K = [0] * (L_max + 1)\n    sum_sqrt_V_C = sum(np.sqrt(variances[l] * costs[l]) for l in range(L_max + 1) if variances[l] > 0)\n    \n    for l in range(L_max + 1):\n        if variances[l] > 1e-30: # If variance is non-negligible\n            num = 2.0 / (eps**2) * sum_sqrt_V_C * np.sqrt(variances[l] / costs[l])\n            optimal_K[l] = int(np.ceil(num))\n        else:\n            optimal_K[l] = 0\n    \n    # --- Main Simulation ---\n    final_estimate = 0.0\n    for l in range(L_max + 1):\n        K_l = optimal_K[l]\n        \n        # If variance is zero or negligible, the pilot mean is exact enough for the difference term\n        if K_l == 0:\n            final_estimate += means[l]\n            continue\n\n        sum_of_diffs = 0.0\n        for _ in range(K_l):\n            W, T = generate_wt_sample(params, rng)\n            y_fine = compute_delay(params, W, T, l)\n            if l == 0:\n                y_coarse = 0.0\n            else:\n                y_coarse = compute_delay(params, W, T, l-1)\n            sum_of_diffs += y_fine - y_coarse\n        \n        final_estimate += sum_of_diffs / K_l\n        \n    return final_estimate\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}