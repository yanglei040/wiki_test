{
    "hands_on_practices": [
        {
            "introduction": "The bedrock principle of a conservation law is that a given physical quantity, such as mass or momentum, is conserved. It is paramount that our numerical methods respect this fundamental property. This first practice provides a direct, tangible experience of what happens when a scheme is \"non-conservative\" by asking you to implement a deliberately flawed numerical flux and measure the resulting artificial creation or destruction of mass, making an abstract concept vividly concrete .",
            "id": "2385236",
            "problem": "Consider the scalar conservation law in one spatial dimension,\n$$\n\\partial_t u(x,t) + \\partial_x f\\big(u(x,t)\\big) = 0,\n$$\nposed on the periodic domain $[0,L]$ with period $L$. Let the physical flux be $f(u)=a\\,u$, with constant advection speed $a>0$. Discretize the domain into $N$ uniform cells of width $h=L/N$, and approximate $u$ by piecewise constant cell averages. Initialize with\n$$\nu(x,0) = 1 + 0.2 \\sin\\!\\big(2\\pi x/L\\big),\n$$\nwhere angles are in radians. Evolve the cell averages by an explicit forward Euler time integrator from $t=0$ to $t=T$, using the following intentionally non-conservative interface flux pair at each inter-cell interface with left and right traces $u_L$ and $u_R$:\n$$\n\\widehat{F}^{-}(u_L,u_R) = a\\,u_L - \\varepsilon,\\qquad\n\\widehat{F}^{+}(u_L,u_R) = a\\,u_L + \\varepsilon,\n$$\nwhere $\\varepsilon$ is a real parameter. Use $\\widehat{F}^{-}$ only on the right face of a cell (the interface where the current cell is the left state), and use $\\widehat{F}^{+}$ only on the left face of a cell (the interface where the current cell is the right state). With these definitions, the semi-discrete update for cell $i$ with periodic indexing is\n$$\n\\frac{d}{dt}\\,\\bar{u}_i(t) \\;=\\; -\\frac{1}{h}\\left[\\,\\widehat{F}^{-}\\big(\\bar{u}_i,\\bar{u}_{i+1}\\big)\\;-\\;\\widehat{F}^{+}\\big(\\bar{u}_{i-1},\\bar{u}_i\\big)\\,\\right],\n$$\nand the forward Euler step is\n$$\n\\bar{u}_i^{n+1} \\;=\\; \\bar{u}_i^{n} \\;-\\; \\frac{\\Delta t}{h}\\left[\\,\\widehat{F}^{-}\\big(\\bar{u}_i^{n},\\bar{u}_{i+1}^{n}\\big)\\;-\\;\\widehat{F}^{+}\\big(\\bar{u}_{i-1}^{n},\\bar{u}_i^{n}\\big)\\,\\right].\n$$\nChoose the time step by the Courant–Friedrichs–Lewy (CFL) condition with a user-specified constant $\\mathrm{CFL}\\in(0,1]$:\n$$\n\\Delta t \\le \\mathrm{CFL}\\,\\frac{h}{a}.\n$$\nDefine the discrete total mass at time $t^n$ as\n$$\nM^n = \\sum_{i=0}^{N-1} \\bar{u}_i^{n}\\,h,\n$$\nand define the measured mass-creation rate over $[0,T]$ as the time-averaged quantity\n$$\nR = \\frac{M(T) - M^0}{T}.\n$$\nImplement the above and, for each test case, output the measured rate $R$ as a floating-point number.\n\nUse the following fixed parameters: $L=1$, $a=1$, $T=0.2$, and $\\mathrm{CFL}=0.9$. The test suite to be run consists of the four $(N,\\varepsilon)$ pairs:\n- $(20,\\,0.05)$,\n- $(20,\\,-0.05)$,\n- $(50,\\,0.01)$,\n- $(37,\\,0.0)$.\n\nYour program should produce a single line of output containing the four measured rates corresponding to these test cases, as a comma-separated list enclosed in square brackets (e.g., \"[r1,r2,r3,r4]\"), with each entry being a floating-point number.",
            "solution": "The problem statement has been critically examined and is determined to be valid. It presents a well-posed numerical experiment in computational engineering, designed to investigate the properties of an intentionally non-conservative finite volume scheme for a scalar conservation law. The problem is scientifically grounded, objective, and contains all necessary information to proceed with a unique and meaningful solution. The minor ambiguity regarding the exact time-stepping procedure to reach the final time $T$ is a common detail in numerical implementations, and a standard, rigorous approach will be adopted. The notation $M^N$ is interpreted as a typographical error for the mass at the final time, $M(T)$.\n\nThe core of the problem is to quantify the mass generation or destruction caused by a non-conservative numerical flux. A theoretical analysis must precede the numerical implementation.\n\nLet us analyze the semi-discrete scheme provided for the cell average $\\bar{u}_i$:\n$$\n\\frac{d}{dt}\\,\\bar{u}_i(t) \\;=\\; -\\frac{1}{h}\\left[\\,\\widehat{F}^{-}\\big(\\bar{u}_i,\\bar{u}_{i+1}\\big)\\;-\\;\\widehat{F}^{+}\\big(\\bar{u}_{i-1},\\bar{u}_i\\big)\\,\\right]\n$$\nThe numerical fluxes are defined as $\\widehat{F}^{-}(u_L,u_R) = a\\,u_L - \\varepsilon$ and $\\widehat{F}^{+}(u_L,u_R) = a\\,u_L + \\varepsilon$. The flux on the right face of cell $i$ (interface $i+1/2$) uses the left state $\\bar{u}_i$ and the right state $\\bar{u}_{i+1}$. The flux on the left face of cell $i$ (interface $i-1/2$) uses the left state $\\bar{u}_{i-1}$ and the right state $\\bar{u}_i$.\nSubstituting the specific flux definitions:\n- The flux at the right face, $i+1/2$, is $\\widehat{F}^{-}\\big(\\bar{u}_i,\\bar{u}_{i+1}\\big) = a\\,\\bar{u}_i - \\varepsilon$.\n- The flux at the left face, $i-1/2$, is $\\widehat{F}^{+}\\big(\\bar{u}_{i-1},\\bar{u}_i\\big) = a\\,\\bar{u}_{i-1} + \\varepsilon$.\n\nThe semi-discrete equation for cell $i$ becomes:\n$$\n\\frac{d}{dt}\\,\\bar{u}_i(t) \\;=\\; -\\frac{1}{h}\\left[ (a\\,\\bar{u}_i - \\varepsilon) - (a\\,\\bar{u}_{i-1} + \\varepsilon) \\right] \\;=\\; -\\frac{a}{h}(\\bar{u}_i - \\bar{u}_{i-1}) + \\frac{2\\varepsilon}{h}\n$$\nThis reveals that the scheme is equivalent to a standard first-order upwind discretization of the advection term $\\partial_x f(u) = a \\partial_x u$ (since $a>0$, the upwind information comes from cell $i-1$), supplemented by a constant source term of $\\frac{2\\varepsilon}{h}$.\n\nThe primary task is to find the rate of change of total mass, $M(t) = \\sum_{i=0}^{N-1} \\bar{u}_i(t)\\,h$. Let us compute its time derivative:\n$$\n\\frac{dM}{dt} = \\frac{d}{dt} \\sum_{i=0}^{N-1} \\bar{u}_i(t)\\,h = h \\sum_{i=0}^{N-1} \\frac{d\\bar{u}_i}{dt}\n$$\nSubstituting the expression for $\\frac{d\\bar{u}_i}{dt}$:\n$$\n\\frac{dM}{dt} = h \\sum_{i=0}^{N-1} \\left( -\\frac{a}{h}(\\bar{u}_i - \\bar{u}_{i-1}) + \\frac{2\\varepsilon}{h} \\right) = -a \\sum_{i=0}^{N-1} (\\bar{u}_i - \\bar{u}_{i-1}) + \\sum_{i=0}^{N-1} 2\\varepsilon\n$$\nThe first summation, $\\sum_{i=0}^{N-1} (\\bar{u}_i - \\bar{u}_{i-1})$, is a telescoping series. Due to the periodic boundary conditions, where $\\bar{u}_{-1} = \\bar{u}_{N-1}$, this sum is identically zero.\nThe second summation is over $N$ identical terms: $\\sum_{i=0}^{N-1} 2\\varepsilon = 2N\\varepsilon$.\nTherefore, the rate of change of total mass is constant and given by:\n$$\n\\frac{dM}{dt} = 2N\\varepsilon\n$$\nThis is a powerful analytical result. It shows that the mass of the system changes linearly with time. Integrating from $t=0$ to $t=T$ gives:\n$$\nM(T) - M(0) = \\int_0^T (2N\\varepsilon) \\, dt = 2N\\varepsilon T\n$$\nThe problem defines the measured mass-creation rate $R$ as $R = \\frac{M(T) - M(0)}{T}$. From our derivation, this yields a simple, exact expression:\n$$\nR = \\frac{2N\\varepsilon T}{T} = 2N\\varepsilon\n$$\nThis result is independent of the initial data, the advection speed $a$, the cell width $h$ (as long as $N$ is fixed), the CFL number, and the details of the time integration scheme, provided the scheme correctly integrates the constant source term. The numerical simulation is thus a verification of this theoretical result.\n\nThe algorithm to implement is as follows:\n1.  For each test case with parameters $(N, \\varepsilon)$, set the global parameters $L=1$, $a=1$, $T=0.2$, and $\\mathrm{CFL}=0.9$.\n2.  Define the spatial grid. The domain $[0,L]$ is divided into $N$ cells. Cell $i$ spans the interval $[i h, (i+1)h]$, where $h=L/N$.\n3.  Calculate the initial cell averages $\\bar{u}_i(0)$. This requires integrating the initial condition $u(x,0) = 1 + 0.2 \\sin(2\\pi x/L)$ over each cell:\n    $$\n    \\bar{u}_i(0) = \\frac{1}{h} \\int_{ih}^{(i+1)h} \\left(1 + 0.2 \\sin\\left(\\frac{2\\pi x}{L}\\right)\\right) dx = 1 - \\frac{0.2 L}{2\\pi h} \\left[ \\cos\\left(\\frac{2\\pi(i+1)h}{L}\\right) - \\cos\\left(\\frac{2\\pi ih}{L}\\right) \\right]\n    $$\n4.  Calculate the initial total mass $M^0 = h \\sum_{i=0}^{N-1} \\bar{u}_i(0)$.\n5.  Set the time step $\\Delta t = \\mathrm{CFL} \\frac{h}{a}$.\n6.  Evolve the solution from $t=0$ to $t=T$. A fixed time step $\\Delta t$ is used for as many full steps as possible. A final, smaller step is taken to land exactly at $t=T$. The `Forward Euler` update is:\n    $$\n    \\bar{u}_i^{n+1} = \\bar{u}_i^{n} + \\Delta t \\left( -\\frac{a}{h}(\\bar{u}_i^n - \\bar{u}_{i-1}^n) + \\frac{2\\varepsilon}{h} \\right)\n    $$\n    This is applied for each time step, respecting the periodic boundary condition $\\bar{u}_{-1}^n = \\bar{u}_{N-1}^n$. This update can be efficiently vectorized.\n7.  After evolving to $t=T$, calculate the final total mass $M^T = h \\sum_{i=0}^{N-1} \\bar{u}_i(T)$.\n8.  Compute the measured mass-creation rate $R = \\frac{M^T - M^0}{T}$.\n9.  The results for all test cases are collected and printed in the specified format. The numerical results are expected to match the analytical prediction $R=2N\\varepsilon$ to within floating-point precision.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the given problem for a set of test cases.\n    It simulates a 1D linear advection equation with a non-conservative\n    numerical scheme and calculates the rate of mass creation.\n    \"\"\"\n\n    # Define fixed parameters from the problem statement.\n    L = 1.0\n    a = 1.0\n    T = 0.2\n    CFL = 0.9\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (20, 0.05),\n        (20, -0.05),\n        (50, 0.01),\n        (37, 0.0),\n    ]\n\n    results = []\n    for N, epsilon in test_cases:\n        # 1. Discretization parameters\n        h = L / N\n        dt = CFL * h / a\n\n        # 2. Initial condition: cell averages\n        # u(x,0) = 1 + 0.2 * sin(2*pi*x/L)\n        # We need the integral of u(x,0) over each cell.\n        # The antiderivative of u(x,0) is x - 0.2 * (L/(2*pi)) * cos(2*pi*x/L)\n        x_boundaries = np.linspace(0.0, L, N + 1)\n        \n        # Vectorized calculation of initial cell averages\n        # integral_u(x) = x - (0.2*L/(2*pi)) * cos(2*pi*x/L)\n        antiderivative_vals = x_boundaries - 0.2 * (L / (2.0 * np.pi)) * np.cos(2.0 * np.pi * x_boundaries / L)\n        # The integral over cell i is integral_u(x_{i+1}) - integral_u(x_i)\n        u0 = np.diff(antiderivative_vals) / h\n        \n        # 3. Initial mass calculation\n        M0 = np.sum(u0) * h\n\n        # 4. Time evolution using Forward Euler\n        u = u0.copy()\n        current_time = 0.0\n\n        num_steps = int(T / dt)\n        \n        # Vectorized update terms\n        advection_coeff = -a / h\n        source_term = 2.0 * epsilon / h\n\n        # Main time loop for full steps\n        for _ in range(num_steps):\n            u_prev = np.roll(u, 1)\n            dudt = advection_coeff * (u - u_prev) + source_term\n            u += dt * dudt\n            current_time += dt\n\n        # Take one final partial step to reach T exactly\n        last_dt = T - current_time\n        if last_dt > 1e-12: # Tolerance for floating point inaccuracy\n            u_prev = np.roll(u, 1)\n            dudt = advection_coeff * (u - u_prev) + source_term\n            u += last_dt * dudt\n\n        # 5. Final mass calculation\n        M_final = np.sum(u) * h\n\n        # 6. Measured mass-creation rate\n        R = (M_final - M0) / T\n        results.append(R)\n\n    # Final print statement in the exact required format.\n    # The format specifier ensures standard float representation.\n    print(f\"[{','.join(f'{r:.15f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Having seen the critical importance of conservation, we now delve deeper into the engine of the DG method: the numerical flux. What makes one flux \"better\" than another? This comprehensive exercise challenges you to assemble a novel \"Frankenstein flux\" from standard components and then systematically analyze its essential properties, including consistency and monotonicity, which are the theoretical cornerstones for building stable and reliable schemes .",
            "id": "2385227",
            "problem": "Consider the scalar conservation law $u_t + f(u)_x = 0$ on a one-dimensional periodic domain with piecewise-constant approximation (polynomial degree $0$) in the discontinuous Galerkin method, which reduces to a finite volume semidiscretization with interface numerical flux. Let $f:\\mathbb{R}\\to\\mathbb{R}$ be continuously differentiable. Define the following numerical fluxes for left and right traces $u_L,u_R\\in\\mathbb{R}$.\n\n- The Rusanov (local Lax–Friedrichs) flux is\n$$\nF_{\\mathrm{R}}(u_L,u_R) \\;=\\; \\tfrac{1}{2}\\big(f(u_L)+f(u_R)\\big) \\;-\\; \\tfrac{1}{2}\\,\\alpha(u_L,u_R)\\,\\big(u_R-u_L\\big),\n$$\nwhere $\\alpha(u_L,u_R)\\ge \\max_{\\xi\\in [\\min(u_L,u_R),\\max(u_L,u_R)]}\\lvert f'(\\xi)\\rvert$. For the inviscid Burgers flux $f(u)=\\tfrac{1}{2}u^2$, it is admissible to take $\\alpha(u_L,u_R)=\\max\\{\\lvert u_L\\rvert,\\lvert u_R\\rvert\\}$.\n\n- The Godunov flux $F_{\\mathrm{G}}(u_L,u_R)$ is the exact flux through the interface for the Riemann problem with initial data $(u_L,u_R)$. For the inviscid Burgers flux $f(u)=\\tfrac{1}{2}u^2$, it is given by the exact self-similar solution and equals:\n  - If $u_L \\le u_R$ (rarefaction), then\n    $$\n    F_{\\mathrm{G}}(u_L,u_R) \\;=\\; \n    \\begin{cases}\n    f(u_L), & \\text{if } 0 \\le u_L,\\\\\n    f(u_R), & \\text{if } 0 \\ge u_R,\\\\\n    f(0),   & \\text{if } u_L \\le 0 \\le u_R,\n    \\end{cases}\n    $$\n  - If $u_L > u_R$ (shock), then with shock speed $s=\\dfrac{f(u_L)-f(u_R)}{u_L-u_R}=\\dfrac{u_L+u_R}{2}$,\n    $$\n    F_{\\mathrm{G}}(u_L,u_R) \\;=\\;\n    \\begin{cases}\n    f(u_L), & \\text{if } s>0,\\\\\n    f(u_R), & \\text{if } s\\le 0.\n    \\end{cases}\n    $$\n\nDefine the Frankenstein flux as the arithmetic mean of the Rusanov and Godunov fluxes:\n$$\nF_{\\mathrm{F}}(u_L,u_R) \\;=\\; \\tfrac{1}{2}\\Big(F_{\\mathrm{R}}(u_L,u_R) + F_{\\mathrm{G}}(u_L,u_R)\\Big).\n$$\n\nTasks.\n\n- Consistency. A numerical flux $F(u_L,u_R)$ is consistent if $F(u,u)=f(u)$ for all $u\\in\\mathbb{R}$. Using $f(u)=\\tfrac{1}{2}u^2$, determine the maximum absolute consistency error $\\max_{u\\in\\mathcal{U}} \\lvert F_{\\mathrm{F}}(u,u)-f(u)\\rvert$ over the set $\\mathcal{U}=\\{-3,-2,-1,0,1,2,3\\}$, and report this maximum as a floating-point number.\n\n- Monotonicity. A numerical flux $F(u_L,u_R)$ is monotone if it is nondecreasing in its first argument and nonincreasing in its second argument, that is, $\\dfrac{\\partial F}{\\partial u_L}\\ge 0$ and $\\dfrac{\\partial F}{\\partial u_R}\\le 0$ wherever these partial derivatives exist. Using $f(u)=\\tfrac{1}{2}u^2$, determine, over the Cartesian grid $\\mathcal{G}=\\{(u_L,u_R): u_L\\in\\mathcal{V}, u_R\\in\\mathcal{V}\\}$ with $\\mathcal{V}=\\{-2,-1,0,1,2\\}$, whether $F_{\\mathrm{F}}$ satisfies both inequalities on all sampled pairs up to a tolerance $\\varepsilon=10^{-6}$, and report two booleans: one indicating whether $\\dfrac{\\partial F_{\\mathrm{F}}}{\\partial u_L}\\ge -\\varepsilon$ for all sampled pairs, and one indicating whether $\\dfrac{\\partial F_{\\mathrm{F}}}{\\partial u_R}\\le \\varepsilon$ for all sampled pairs.\n\n- Discrete total variation under an explicit Euler step. On the periodic domain $[0,2\\pi)$, let the number of cells be $N=200$ with uniform cell width $\\Delta x=\\dfrac{2\\pi}{N}$. Define the initial cell averages by $u_i^0 = A\\sin(x_i)$ with $A=1.5$ and $x_i=(i+\\tfrac{1}{2})\\Delta x$ for $i=0,1,\\dots,N-1$. Using the piecewise-constant discontinuous Galerkin semidiscretization (which coincides with the finite volume method) and the Frankenstein flux $F_{\\mathrm{F}}$ for $f(u)=\\tfrac{1}{2}u^2$, perform one explicit Euler time update with time step \n$$\n\\Delta t \\;=\\; 0.9 \\,\\frac{\\Delta x}{\\max_i \\lvert u_i^0\\rvert},\n$$\nand determine whether the discrete periodic total variation $\\mathrm{TV}(u)=\\sum_{i=0}^{N-1}\\lvert u_{i+1}-u_i\\rvert$ (with periodic indexing $u_N=u_0$) does not increase, that is, whether $\\mathrm{TV}(u^1)\\le \\mathrm{TV}(u^0)+10^{-10}$. Report a boolean indicating this outcome.\n\n- Linear advection identity check. For the linear flux $f(u)=a\\,u$ with $a=2.3>0$, the Godunov and Rusanov fluxes both equal the upwind flux $a\\,u_L$. For the Frankenstein flux built from these two fluxes, compute the maximum absolute discrepancy\n$$\n\\max_{(u_L,u_R)\\in\\mathcal{S}} \\big\\lvert F_{\\mathrm{F}}(u_L,u_R) - a\\,u_L \\big\\rvert\n$$\nover the finite set $\\mathcal{S}$ consisting of $100$ pairs $(u_L,u_R)$ drawn independently and uniformly from $[-3,3]\\times[-3,3]$ with pseudorandom seed $42$. Report this maximum as a floating-point number.\n\nTest suite and required output.\n\n- Use the sets, parameters, and constants exactly as specified above: $\\mathcal{U}=\\{-3,-2,-1,0,1,2,3\\}$, $\\mathcal{V}=\\{-2,-1,0,1,2\\}$, $N=200$, $\\Delta t$ as given, $A=1.5$, $a=2.3$, and seed $42$ for the linear advection identity check.\n\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the following order and types: \n  1. the maximum absolute consistency error for $F_{\\mathrm{F}}$ on $\\mathcal{U}$ (float), \n  2. the monotonicity boolean for nondecreasing in the first argument over $\\mathcal{G}$ (boolean), \n  3. the monotonicity boolean for nonincreasing in the second argument over $\\mathcal{G}$ (boolean), \n  4. the boolean indicating nonincrease of total variation after one explicit Euler step (boolean), \n  5. the maximum absolute discrepancy for the linear advection identity check on $\\mathcal{S}$ (float).\n\nThe domain is nondimensional; no physical units are required. Angles are in radians. Express booleans as literal true or false and floating-point numbers in standard decimal notation.",
            "solution": "The problem statement has been analyzed and is determined to be valid. It is scientifically grounded in the theory of numerical methods for conservation laws, is well-posed with all necessary information provided, and contains no contradictions or ambiguities that would prevent a rigorous, objective solution. I will proceed to solve the four tasks as specified.\n\nThe core of the problem is the analysis of a \"Frankenstein\" numerical flux $F_{\\mathrm{F}}$, defined as the arithmetic mean of the Rusanov flux $F_{\\mathrm{R}}$ and the Godunov flux $F_{\\mathrm{G}}$. All tasks are performed for specific flux functions $f(u)$, primarily the inviscid Burgers' flux $f(u) = \\frac{1}{2}u^2$.\n\nThe solution is structured by addressing each of the four tasks sequentially. For each task, the underlying theoretical principles are stated, followed by the description of the computational method used to obtain the required result.\n\n**1. Consistency Check**\n\nA numerical flux $F(u_L, u_R)$ is consistent with the conservation law $u_t + f(u)_x=0$ if it reproduces the physical flux when the left and right states are identical, i.e., $F(u, u) = f(u)$ for all $u$.\n\nThe Rusanov flux is defined as $F_{\\mathrm{R}}(u_L, u_R) = \\frac{1}{2}(f(u_L)+f(u_R)) - \\frac{1}{2}\\alpha(u_L, u_R)(u_R-u_L)$. When $u_L=u_R=u$, the second term vanishes, yielding $F_{\\mathrm{R}}(u, u) = \\frac{1}{2}(f(u)+f(u)) = f(u)$. Thus, the Rusanov flux is consistent.\n\nThe Godunov flux $F_{\\mathrm{G}}(u_L, u_R)$ is the exact flux from the solution of the Riemann problem. For a constant state $u_L=u_R=u$, the solution is trivially $u(x,t)=u$ everywhere, and the flux is $f(u)$. Thus, the Godunov flux is also consistent.\n\nThe Frankenstein flux is $F_{\\mathrm{F}}(u_L, u_R) = \\frac{1}{2}(F_{\\mathrm{R}}(u_L, u_R) + F_{\\mathrm{G}}(u_L, u_R))$. For $u_L=u_R=u$, we have $F_{\\mathrm{F}}(u, u) = \\frac{1}{2}(F_{\\mathrm{R}}(u, u) + F_{\\mathrm{G}}(u, u)) = \\frac{1}{2}(f(u) + f(u)) = f(u)$. Analytically, the Frankenstein flux is perfectly consistent.\n\nThe task requires computing the maximum absolute consistency error $\\max_{u \\in \\mathcal{U}} |F_{\\mathrm{F}}(u, u) - f(u)|$ over the set $\\mathcal{U}=\\{-3, -2, -1, 0, 1, 2, 3\\}$. The implementation will calculate this value numerically. Any non-zero result will be attributable to floating-point arithmetic limitations.\n\n**2. Monotonicity Test**\n\nA numerical flux $F(u_L, u_R)$ is monotone if it is a non-decreasing function of its first argument $u_L$ and a non-increasing function of its second argument $u_R$. Mathematically, $\\frac{\\partial F}{\\partial u_L} \\ge 0$ and $\\frac{\\partial F}{\\partial u_R} \\le 0$, where the derivatives exist. Monotone fluxes are crucial for constructing schemes that do not create spurious oscillations, such as Total Variation Diminishing (TVD) schemes.\n\nThe Rusanov and Godunov fluxes are known to be monotone fluxes under the given conditions. The arithmetic mean of two monotone fluxes is also a monotone flux. Therefore, $F_{\\mathrm{F}}$ is expected to be monotone.\n\nThe task is to verify this property numerically on the grid $\\mathcal{G}=\\mathcal{V} \\times \\mathcal{V}$ where $\\mathcal{V}=\\{-2, -1, 0, 1, 2\\}$. The partial derivatives are approximated using finite differences on this grid.\n- At interior points of $\\mathcal{V}$, a second-order central difference is used: e.g., $\\frac{\\partial F}{\\partial u_L}(u_{L,i}, u_R) \\approx \\frac{F(u_{L,i+1}, u_R) - F(u_{L,i-1}, u_R)}{u_{L,i+1} - u_{L,i-1}}$.\n- At boundary points, a first-order forward or backward difference is used: e.g., $\\frac{F(u_{L,1}, u_R) - F(u_{L,0}, u_R)}{u_{L,1}-u_{L,0}}$.\n\nFor each pair $(u_L, u_R) \\in \\mathcal{G}$, the approximated derivatives are compared against the tolerance $\\varepsilon=10^{-6}$ to determine if $\\frac{\\partial F_{\\mathrm{F}}}{\\partial u_L} \\ge -\\varepsilon$ and $\\frac{\\partial F_{\\mathrm{F}}}{\\partial u_R} \\le \\varepsilon$.\n\n**3. Discrete Total Variation (TVD) Property**\n\nThe semi-discretization of the conservation law for piecewise-constant elements is the finite volume method:\n$$\n\\frac{d u_i}{dt} = -\\frac{1}{\\Delta x} \\left( F_{i+1/2} - F_{i-1/2} \\right),\n$$\nwhere $u_i$ is the cell average in cell $i$, and $F_{i+1/2} = F_{\\mathrm{F}}(u_i, u_{i+1})$ is the numerical flux at the interface between cells $i$ and $i+1$.\n\nApplying an explicit Euler time step gives the update formula:\n$$\nu_i^{1} = u_i^{0} - \\frac{\\Delta t}{\\Delta x} \\left( F_{\\mathrm{F}}(u_i^0, u_{i+1}^0) - F_{\\mathrm{F}}(u_{i-1}^0, u_i^0) \\right).\n$$\n\nA numerical scheme is Total Variation Diminishing (TVD) if the total variation of the discrete solution does not increase with time, i.e., $\\mathrm{TV}(u^{n+1}) \\le \\mathrm{TV}(u^n)$. The discrete periodic total variation is defined as $\\mathrm{TV}(u) = \\sum_{i=0}^{N-1} |u_{i+1} - u_i|$, with periodic indexing $u_N=u_0$.\n\nFor a scheme with a monotone flux, the TVD property is guaranteed if the CFL condition is satisfied. The specified time step $\\Delta t = 0.9 \\frac{\\Delta x}{\\max_i |u_i^0|}$ ensures the CFL condition for the Burgers' equation is met.\n\nThe implementation will compute the initial total variation $\\mathrm{TV}(u^0)$, perform one step of the explicit Euler update to find $u^1$, compute the final total variation $\\mathrm{TV}(u^1)$, and check if $\\mathrm{TV}(u^1) \\le \\mathrm{TV}(u^0) + 10^{-10}$.\n\n**4. Linear Advection Identity Check**\n\nFor the linear advection equation $u_t + (au)_x = 0$ with constant speed $a > 0$, the characteristic speed is $f'(u)=a$.\n- The Godunov flux is the upwind flux $F_{\\mathrm{G}}(u_L, u_R) = f(u_L) = au_L$, as information propagates from left to right.\n- The Rusanov flux requires $\\alpha \\ge \\max|f'| = a$. Choosing the minimum allowable dissipation $\\alpha=a$, the flux becomes $F_{\\mathrm{R}}(u_L, u_R) = \\frac{1}{2}(au_L + au_R) - \\frac{1}{2}a(u_R - u_L) = au_L$.\n\nSince both constituent fluxes simplify to $au_L$, the Frankenstein flux must also be $F_{\\mathrm{F}}(u_L, u_R) = \\frac{1}{2}(au_L + au_L) = au_L$.\n\nThe task is to verify this numerically. A set $\\mathcal{S}$ of $100$ random pairs $(u_L, u_R)$ is generated. For each pair, the Frankenstein flux is computed from its fundamental definition using the linear physical flux $f(u)=au$. The absolute difference $|F_{\\mathrm{F}}(u_L, u_R) - au_L|$ is calculated, and the maximum of these differences over the set $\\mathcal{S}$ is reported. This serves as a verification of the implementation and a measure of floating-point error.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the four tasks related to the Frankenstein numerical flux.\n    \"\"\"\n\n    # ---- Helper functions for Burgers' equation ----\n    def f_burgers(u):\n        return 0.5 * u**2\n\n    def rusanov_flux_burgers(uL, uR):\n        fL = f_burgers(uL)\n        fR = f_burgers(uR)\n        alpha = np.maximum(np.abs(uL), np.abs(uR))\n        return 0.5 * (fL + fR) - 0.5 * alpha * (uR - uL)\n\n    def godunov_flux_burgers(uL, uR):\n        # This vectorized implementation handles scalar and array inputs.\n        uL = np.atleast_1d(uL)\n        uR = np.atleast_1d(uR)\n        out = np.zeros_like(uL, dtype=float)\n\n        # Rarefaction case: uL <= uR\n        rare_mask = uL <= uR\n        if np.any(rare_mask):\n            uL_r, uR_r = uL[rare_mask], uR[rare_mask]\n            # Conditions for rarefaction\n            # f(uL) if uL >= 0\n            # f(uR) if uR <= 0\n            # f(0) if uL < 0 < uR\n            out_r = np.where(uL_r >= 0, f_burgers(uL_r),\n                             np.where(uR_r <= 0, f_burgers(uR_r), f_burgers(0.0)))\n            out[rare_mask] = out_r\n\n        # Shock case: uL > uR\n        shock_mask = ~rare_mask\n        if np.any(shock_mask):\n            uL_s, uR_s = uL[shock_mask], uR[shock_mask]\n            s = 0.5 * (uL_s + uR_s)\n            # f(uL) if s > 0, else f(uR)\n            out_s = np.where(s > 0, f_burgers(uL_s), f_burgers(uR_s))\n            out[shock_mask] = out_s\n        \n        return out[0] if out.size == 1 else out\n\n    def frankenstein_flux_burgers(uL, uR):\n        is_scalar = np.isscalar(uL)\n        fr = rusanov_flux_burgers(uL, uR)\n        fg = godunov_flux_burgers(uL, uR)\n        result = 0.5 * (fr + fg)\n        return result.item() if is_scalar else result\n\n    # ---- Task 1: Consistency ----\n    def solve_consistency():\n        U = np.array([-3, -2, -1, 0, 1, 2, 3], dtype=float)\n        errors = np.abs(frankenstein_flux_burgers(U, U) - f_burgers(U))\n        return np.max(errors)\n\n    # ---- Task 2: Monotonicity ----\n    def solve_monotonicity():\n        V = np.array([-2, -1, 0, 1, 2], dtype=float)\n        epsilon = 1e-6\n        is_nondecreasing = True\n        is_nonincreasing = True\n        \n        # Check dF/duL >= -epsilon\n        for uR in V:\n            for i in range(len(V)):\n                uL = V[i]\n                if i == 0:\n                    deriv = (frankenstein_flux_burgers(V[i+1], uR) - frankenstein_flux_burgers(uL, uR)) / (V[i+1] - uL)\n                elif i == len(V) - 1:\n                    deriv = (frankenstein_flux_burgers(uL, uR) - frankenstein_flux_burgers(V[i-1], uR)) / (uL - V[i-1])\n                else:\n                    deriv = (frankenstein_flux_burgers(V[i+1], uR) - frankenstein_flux_burgers(V[i-1], uR)) / (V[i+1] - V[i-1])\n                \n                if deriv  -epsilon:\n                    is_nondecreasing = False\n                    break\n            if not is_nondecreasing: break\n            \n        # Check dF/duR = epsilon\n        for uL in V:\n            for i in range(len(V)):\n                uR = V[i]\n                if i == 0:\n                    deriv = (frankenstein_flux_burgers(uL, V[i+1]) - frankenstein_flux_burgers(uL, uR)) / (V[i+1] - uR)\n                elif i == len(V) - 1:\n                    deriv = (frankenstein_flux_burgers(uL, uR) - frankenstein_flux_burgers(uL, V[i-1])) / (uR - V[i-1])\n                else:\n                    deriv = (frankenstein_flux_burgers(uL, V[i+1]) - frankenstein_flux_burgers(uL, V[i-1])) / (V[i+1] - V[i-1])\n                \n                if deriv > epsilon:\n                    is_nonincreasing = False\n                    break\n            if not is_nonincreasing: break\n            \n        return is_nondecreasing, is_nonincreasing\n\n    # ---- Task 3: Total Variation ----\n    def solve_tv():\n        N = 200\n        A = 1.5\n        dx = 2.0 * np.pi / N\n        x = (np.arange(N) + 0.5) * dx\n        u0 = A * np.sin(x)\n        \n        max_abs_u0 = np.max(np.abs(u0))\n        dt = 0.9 * dx / max_abs_u0\n        \n        def tv(u):\n            return np.sum(np.abs(np.roll(u, -1) - u))\n            \n        tv0 = tv(u0)\n        \n        flux_right = frankenstein_flux_burgers(u0, np.roll(u0, -1))\n        flux_left = np.roll(flux_right, 1)\n        \n        u1 = u0 - (dt / dx) * (flux_right - flux_left)\n        \n        tv1 = tv(u1)\n        \n        return tv1 = tv0 + 1e-10\n\n    # ---- Task 4: Linear Advection ----\n    def solve_linear_advection():\n        a = 2.3\n        \n        def f_linear(u): return a * u\n        \n        def rusanov_flux_linear(uL, uR):\n            # For f(u)=au, a0, alpha=a is a valid choice.\n            return 0.5 * (f_linear(uL) + f_linear(uR)) - 0.5 * a * (uR - uL)\n\n        def godunov_flux_linear(uL, uR):\n            # For a0, upwind flux is f(uL).\n            return f_linear(uL)\n        \n        def frankenstein_flux_linear(uL, uR):\n            fr = rusanov_flux_linear(uL, uR)\n            fg = godunov_flux_linear(uL, uR)\n            return 0.5 * (fr + fg)\n\n        np.random.seed(42)\n        uL_samples = np.random.uniform(-3, 3, 100)\n        uR_samples = np.random.uniform(-3, 3, 100)\n        \n        max_discrepancy = 0.0\n        for uL, uR in zip(uL_samples, uR_samples):\n            ff_val = frankenstein_flux_linear(uL, uR)\n            ideal_val = a * uL\n            discrepancy = np.abs(ff_val - ideal_val)\n            if discrepancy > max_discrepancy:\n                max_discrepancy = discrepancy\n                \n        return max_discrepancy\n\n    # Execute all tasks and collect results\n    res1 = solve_consistency()\n    res2_1, res2_2 = solve_monotonicity()\n    res3 = solve_tv()\n    res4 = solve_linear_advection()\n    \n    # Format for final output\n    final_results = [\n        res1,\n        str(res2_1).lower(),\n        str(res2_2).lower(),\n        str(res3).lower(),\n        res4\n    ]\n\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While higher-order DG methods promise greater accuracy, they introduce new challenges, most notably the tendency to produce non-physical oscillations near sharp gradients or discontinuities. This practice explores the vital role of slope limiters—the mechanisms designed to tame these oscillations. Through a compelling thought experiment involving an \"anti-limiter,\" you will gain crucial intuition about nonlinear stability and why simply choosing a steeper reconstruction can lead to catastrophic failure .",
            "id": "2385285",
            "problem": "Consider the one-dimensional scalar conservation law $u_t + f(u)_x = 0$ on a periodic domain $x \\in [0,1]$ with a uniform mesh of $N$ cells of size $h = 1/N$, constant advection speed $a > 0$, and an upwind numerical flux consistent with $f(u) = a u$. A piecewise-linear discontinuous Galerkin (DG) discretization is used with cellwise linear reconstructions. To control spurious oscillations, a slope limiter is applied to each cell $i$ by replacing the raw DG slope $\\sigma_i^{\\mathrm{raw}}$ with a limited slope $\\sigma_i = \\phi(v_1,v_2,v_3)$ constructed from the three arguments $v_1 = \\theta \\,(u_i - u_{i-1})/h$, $v_2 = \\frac{1}{2}\\,(u_{i+1} - u_{i-1})/h$, and $v_3 = \\theta \\,(u_{i+1} - u_i)/h$, where $\\theta \\in [1,2]$ and $u_i$ denotes the cell average in cell $i$. The limiter function is the classical $\\mathrm{minmod}$ function\n$$\n\\mathrm{minmod}(v_1,v_2,v_3) = \n\\begin{cases}\n\\mathrm{sign}(v_1)\\,\\min\\{|v_1|,|v_2|,|v_3|\\},  \\text{if } \\mathrm{sign}(v_1) = \\mathrm{sign}(v_2) = \\mathrm{sign}(v_3),\\\\\n0,  \\text{otherwise},\n\\end{cases}\n$$\nknown to enforce monotonicity and bound total variation under Courant–Friedrichs–Lewy (CFL) conditions with Strong Stability Preserving (SSP) time stepping.\n\nSuppose instead that the limiter is modified by replacing $\\mathrm{minmod}$ with the $\\mathrm{maxmod}$ function\n$$\n\\mathrm{maxmod}(v_1,v_2,v_3) = \n\\begin{cases}\n\\mathrm{sign}(v_1)\\,\\max\\{|v_1|,|v_2|,|v_3|\\},  \\text{if } \\mathrm{sign}(v_1) = \\mathrm{sign}(v_2) = \\mathrm{sign}(v_3),\\\\\n0,  \\text{otherwise}.\n\\end{cases}\n$$\nAssume explicit time integration by a Strong Stability Preserving Runge–Kutta method of order $2$ with time step $\\Delta t$ satisfying a standard CFL condition $a\\,\\Delta t/h \\le 1$.\n\nWhich statement best characterizes the effect of using $\\mathrm{maxmod}$ in place of $\\mathrm{minmod}$ on the nonlinear stability of the DG method for discontinuous data (for example, a square wave initial condition), keeping all other components unchanged?\n\nA. The limiter becomes anti-diffusive: the total variation increases with time even under CFL-compliant time steps, leading to growing Gibbs-type oscillations near discontinuities, overshoots/undershoots that violate a maximum principle, and possible blow-up in $L^\\infty$.\n\nB. The method remains total variation diminishing (TVD) but produces sharper, nonoscillatory shocks and strictly reduced numerical diffusion compared to $\\mathrm{minmod}$.\n\nC. The method becomes more diffusive but unconditionally stable, effectively reverting to first order everywhere and suppressing oscillations.\n\nD. The method remains linearly stable in the $L^2$ norm for all CFL numbers $a\\,\\Delta t/h \\le 1$, exhibiting only a benign phase error without growth of spurious oscillations near discontinuities.",
            "solution": "The problem statement describes a piecewise-linear discontinuous Galerkin (DG) method for the scalar linear advection equation, $u_t + (au)_x = 0$. The core of the question is the replacement of a standard monotonicity-preserving slope limiter, the $\\mathrm{minmod}$ function, with a non-standard function, $\\mathrm{maxmod}$. We must analyze the consequence of this modification on the nonlinear stability of the numerical scheme.\n\nLet us begin with a formal validation of the problem statement.\n\n**Step 1: Extract Givens**\n- Conservation Law: $u_t + f(u)_x = 0$\n- Domain: periodic, $x \\in [0,1]$\n- Mesh: uniform with $N$ cells of size $h = 1/N$\n- Flux Function: $f(u) = a u$, with constant advection speed $a > 0$\n- Spatial Discretization: Piecewise-linear discontinuous Galerkin (DG) method\n- Numerical Flux: Upwind\n- Slope Limiter Modification: The raw DG slope $\\sigma_i^{\\mathrm{raw}}$ in each cell $i$ is replaced by a limited slope $\\sigma_i = \\phi(v_1, v_2, v_3)$.\n- Limiter inputs: $v_1 = \\theta \\,(u_i - u_{i-1})/h$, $v_2 = \\frac{1}{2}\\,(u_{i+1} - u_{i-1})/h$, $v_3 = \\theta \\,(u_{i+1} - u_i)/h$, where $u_i$ is the cell average in cell $i$ and $\\theta \\in [1,2]$.\n- Standard Limiter: $\\phi = \\mathrm{minmod}$, defined as\n$$\n\\mathrm{minmod}(v_1,v_2,v_3) = \n\\begin{cases}\n\\mathrm{sign}(v_1)\\,\\min\\{|v_1|,|v_2|,|v_3|\\},  \\text{if } \\mathrm{sign}(v_1) = \\mathrm{sign}(v_2) = \\mathrm{sign}(v_3),\\\\\n0,  \\text{otherwise}.\n\\end{cases}\n$$\n- Modified Limiter: $\\phi = \\mathrm{maxmod}$, defined as\n$$\n\\mathrm{maxmod}(v_1,v_2,v_3) = \n\\begin{cases}\n\\mathrm{sign}(v_1)\\,\\max\\{|v_1|,|v_2|,|v_3|\\},  \\text{if } \\mathrm{sign}(v_1) = \\mathrm{sign}(v_2) = \\mathrm{sign}(v_3),\\\\\n0,  \\text{otherwise}.\n\\end{cases}\n$$\n- Time Integration: Strong Stability Preserving Runge–Kutta method of order $2$ (SSP-RK2) with time step $\\Delta t$ satisfying the CFL condition $a\\,\\Delta t/h \\le 1$.\n- Question: Characterize the effect of using $\\mathrm{maxmod}$ instead of $\\mathrm{minmod}$ on nonlinear stability for discontinuous initial data.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is well-defined within the field of numerical methods for partial differential equations, specifically for hyperbolic conservation laws. The concepts of DG methods, slope limiting, Total Variation Diminishing (TVD) properties, SSP time integrators, and CFL conditions are standard. The limiter inputs $v_1$, $v_2$, and $v_3$ represent backward, central, and forward difference approximations to the solution's spatial derivative, respectively, which are common ingredients in limiters for finite volume and DG methods. The functions $\\mathrm{minmod}$ and $\\mathrm{maxmod}$ are mathematically precise. The question asks for an analysis of the stability properties resulting from a specific, well-defined modification to the algorithm. The problem is scientifically grounded, well-posed, and objective. It contains no contradictions or missing information required for a qualitative analysis.\n\n**Step 3: Verdict and Action**\nThe problem statement is valid. I will proceed with the derivation of the solution.\n\n**Derivation of Solution**\n\nThe purpose of a slope limiter in a high-order scheme (like second-order DG) for conservation laws is to enforce nonlinear stability by preventing the formation of spurious oscillations near discontinuities. This is typically achieved by making the scheme monotonicity-preserving. A scheme is monotonicity-preserving if, given a monotonic discrete solution at time $t^n$, the solution at time $t^{n+1}$ remains monotonic. For scalar problems, this property implies that the total variation (TV) of the solution does not increase, i.e., the scheme is TVD.\n$TV(u) = \\sum_i |u_{i+1} - u_i|$.\n\nThe reconstruction within cell $i$ is a linear polynomial: $u_h(x) = u_i + \\sigma_i \\frac{x-x_i}{h}$. To preserve monotonicity, the values of this polynomial at the cell edges, $x_{i \\pm 1/2}$, must not create new local extrema. This means the edge values must be bounded by the cell averages of the adjacent cells. For example, at the right cell edge $x_{i+1/2}$, the reconstructed value from within cell $i$, $u_h(x_{i+1/2}^-) = u_i + \\sigma_i h/2$, must lie between $u_i$ and $u_{i+1}$.\n\nLet us assume a locally monotonic profile, for instance $u_{i-1}  u_i  u_{i+1}$. The monotonicity constraints require:\n$u_{i-1} \\le u_i - \\sigma_i h/2$ and $u_i + \\sigma_i h/2 \\le u_{i+1}$.\nThese inequalities give bounds on the slope $\\sigma_i$:\n$\\sigma_i \\le \\frac{u_i - u_{i-1}}{h/2}$ and $\\sigma_i \\le \\frac{u_{i+1} - u_i}{h/2}$.\nSo the slope must be bounded by $2(u_i - u_{i-1})/h$ and $2(u_{i+1} - u_i)/h$. Note that the limiter inputs $v_1$ and $v_3$ for $\\theta=2$ correspond exactly to these bounds.\n\nThe $\\mathrm{minmod}$ limiter is designed to satisfy such constraints. When the candidate slopes ($v_1$, $v_2$, $v_3$) all have the same sign (indicating a locally monotonic region), $\\mathrm{minmod}$ selects the one with the smallest magnitude. This is a conservative choice that limits the 'steepness' of the reconstruction, ensuring the resulting scheme is TVD. This limiting action introduces numerical diffusion, which is the price paid for preventing oscillations.\n\nNow, consider the modified limiter, $\\mathrm{maxmod}$. In a region where the solution is monotonic and the candidate slopes $v_1, v_2, v_3$ are non-zero with the same sign, $\\mathrm{maxmod}$ selects the slope with the largest magnitude. This is an \"anti-limiting\" or \"compressive\" behavior. Instead of restricting the slope to prevent overshoots, it actively chooses the steepest possible reconstruction among the candidates.\n\nThis choice will almost certainly violate the monotonicity-preserving bounds. By selecting the maximum slope, the reconstructed value at a cell edge, e.g., $u_i + \\sigma_i h/2$, is highly likely to overshoot the neighboring cell average $u_{i+1}$ (or undershoot it). This creates new, spurious local extrema in the solution.\n\nThe creation of new extrema means the scheme is not monotonicity-preserving. Consequently, the scheme is not TVD; its total variation will increase with time, $TV(u^{n+1}) > TV(u^n)$. This increase in total variation manifests as growing oscillations, particularly near discontinuities where the differences in cell averages are large. These oscillations resemble the Gibbs phenomenon but grow in amplitude over time, rather than being damped. This uncontrolled growth is a sign of nonlinear instability. The values can grow beyond the initial maximum and minimum values of the data (violating the maximum principle), and may eventually lead to a numerical blow-up, where the solution magnitude tends to infinity. This behavior is characteristic of an anti-diffusive scheme.\n\nThe use of an SSP time integrator and a CFL-compliant time step does not remedy this fundamental flaw in the spatial discretization. SSP methods are only guaranteed to preserve stability properties (like the TVD property) that are already held by the simple forward Euler update with the same spatial operator. If the spatial operator itself is TV-increasing, an SSP method will faithfully reproduce this instability.\n\n**Evaluation of Options**\n\nA. **The limiter becomes anti-diffusive: the total variation increases with time even under CFL-compliant time steps, leading to growing Gibbs-type oscillations near discontinuities, overshoots/undershoots that violate a maximum principle, and possible blow-up in $L^\\infty$.**\nThis statement accurately describes the consequences of using the $\\mathrm{maxmod}$ limiter. The selection of the maximum magnitude slope is an anti-diffusive action that leads to a violation of monotonicity, an increase in total variation, and the growth of spurious oscillations, which can ultimately cause the solution to blow up. **Correct.**\n\nB. **The method remains total variation diminishing (TVD) but produces sharper, nonoscillatory shocks and strictly reduced numerical diffusion compared to `minmod`.**\nThis is incorrect. The core premise that the method remains TVD is false. The `maxmod` function inherently violates the conditions required for a limiter to be TVD. While it attempts to produce sharper features (by being anti-diffusive or compressive), this comes at the cost of introducing severe, growing oscillations. **Incorrect.**\n\nC. **The method becomes more diffusive but unconditionally stable, effectively reverting to first order everywhere and suppressing oscillations.**\nThis statement describes the opposite behavior. The `maxmod` limiter is anti-diffusive, not more diffusive. A more diffusive limiter would choose an even smaller slope than `minmod`, or simply zero (reverting to a first-order scheme). The method is unstable, not unconditionally stable. **Incorrect.**\n\nD. **The method remains linearly stable in the $L^2$ norm for all CFL numbers $a\\,\\Delta t/h \\le 1$, exhibiting only a benign phase error without growth of spurious oscillations near discontinuities.**\nThis is incorrect. The primary issue here is nonlinear stability, which is not captured by linear stability analysis. The problem specifically asks about discontinuous data, where nonlinear effects are dominant. The oscillations are not benign and do not represent a mere phase error; they are a manifestation of amplitude growth and a severe nonlinear instability. **Incorrect.**",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}