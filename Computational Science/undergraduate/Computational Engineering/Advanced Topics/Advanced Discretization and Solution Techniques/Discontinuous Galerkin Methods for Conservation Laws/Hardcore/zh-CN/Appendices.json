{
    "hands_on_practices": [
        {
            "introduction": "数值通量是间断 Galerkin (DG) 方法和有限体积方法的核心。本练习通过将两种著名的数值通量（Rusanov 通量和 Godunov 通量）进行组合，构建一个“混合”通量，旨在加深你对通量基本性质的理解。通过分析这个新通量的一致性、单调性和总变差 (TVD) 特性，你将掌握评估任何数值格式稳定性和准确性的关键技能。",
            "id": "2385227",
            "problem": "考虑一维周期性区域上的标量守恒律 $u_t + f(u)_x = 0$ ，在间断 Galerkin 方法中使用分片常数近似（0次多项式），这可以简化为带有界面数值通量的有限体积半离散化。设 $f:\\mathbb{R}\\to\\mathbb{R}$ 是连续可微的。为左右迹 $u_L,u_R\\in\\mathbb{R}$ 定义以下数值通量。\n\n- Rusanov（局部 Lax–Friedrichs）通量为\n$$\nF_{\\mathrm{R}}(u_L,u_R) \\;=\\; \\tfrac{1}{2}\\big(f(u_L)+f(u_R)\\big) \\;-\\; \\tfrac{1}{2}\\,\\alpha(u_L,u_R)\\,\\big(u_R-u_L\\big),\n$$\n其中 $\\alpha(u_L,u_R)\\ge \\max_{\\xi\\in [\\min(u_L,u_R),\\max(u_L,u_R)]}\\lvert f'(\\xi)\\rvert$。对于无粘 Burgers 通量 $f(u)=\\tfrac{1}{2}u^2$，可以取 $\\alpha(u_L,u_R)=\\max\\{\\lvert u_L\\rvert,\\lvert u_R\\rvert\\}$。\n\n- Godunov 通量 $F_{\\mathrm{G}}(u_L,u_R)$ 是初始数据为 $(u_L,u_R)$ 的 Riemann 问题穿过界面的精确通量。对于无粘 Burgers 通量 $f(u)=\\tfrac{1}{2}u^2$，它由精确的自相似解给出，等于：\n  - 如果 $u_L \\le u_R$ (稀疏波)，那么\n    $$\n    F_{\\mathrm{G}}(u_L,u_R) \\;=\\; \n    \\begin{cases}\n    f(u_L),  \\text{如果 } 0 \\le u_L,\\\\\n    f(u_R),  \\text{如果 } 0 \\ge u_R,\\\\\n    f(0),    \\text{如果 } u_L \\le 0 \\le u_R,\n    \\end{cases}\n    $$\n  - 如果 $u_L > u_R$ (激波)，那么激波速度为 $s=\\dfrac{f(u_L)-f(u_R)}{u_L-u_R}=\\dfrac{u_L+u_R}{2}$，\n    $$\n    F_{\\mathrm{G}}(u_L,u_R) \\;=\\;\n    \\begin{cases}\n    f(u_L),  \\text{如果 } s>0,\\\\\n    f(u_R),  \\text{如果 } s\\le 0.\n    \\end{cases}\n    $$\n\n将 Frankenstein 通量定义为 Rusanov 通量和 Godunov 通量的算术平均值：\n$$\nF_{\\mathrm{F}}(u_L,u_R) \\;=\\; \\tfrac{1}{2}\\Big(F_{\\mathrm{R}}(u_L,u_R) + F_{\\mathrm{G}}(u_L,u_R)\\Big).\n$$\n\n任务。\n\n- 相容性。如果对于所有 $u\\in\\mathbb{R}$ 都有 $F(u,u)=f(u)$，则数值通量 $F(u_L,u_R)$ 是相容的。使用 $f(u)=\\tfrac{1}{2}u^2$，确定在集合 $\\mathcal{U}=\\{-3,-2,-1,0,1,2,3\\}$ 上的最大绝对相容性误差 $\\max_{u\\in\\mathcal{U}} \\lvert F_{\\mathrm{F}}(u,u)-f(u)\\rvert$，并将此最大值报告为浮点数。\n\n- 单调性。如果一个数值通量 $F(u_L,u_R)$ 对其第一个参数是非递减的，对其第二个参数是非递增的，即在这些偏导数存在的地方有 $\\dfrac{\\partial F}{\\partial u_L}\\ge 0$ 和 $\\dfrac{\\partial F}{\\partial u_R}\\le 0$，那么它是单调的。使用 $f(u)=\\tfrac{1}{2}u^2$，在笛卡尔网格 $\\mathcal{G}=\\{(u_L,u_R): u_L\\in\\mathcal{V}, u_R\\in\\mathcal{V}\\}$（其中 $\\mathcal{V}=\\{-2,-1,0,1,2\\}$）上，判断 $F_{\\mathrm{F}}$ 是否在所有采样点对上都满足这两个不等式（容差为 $\\varepsilon=10^{-6}$），并报告两个布尔值：一个表示是否对所有采样点对都有 $\\dfrac{\\partial F_{\\mathrm{F}}}{\\partial u_L}\\ge -\\varepsilon$，另一个表示是否对所有采样点对都有 $\\dfrac{\\partial F_{\\mathrm{F}}}{\\partial u_R}\\le \\varepsilon$。\n\n- 显式欧拉步下的离散总变差。在周期性区域 $[0,2\\pi)$ 上，设网格单元数为 $N=200$，均匀网格单元宽度为 $\\Delta x=\\dfrac{2\\pi}{N}$。通过 $u_i^0 = A\\sin(x_i)$ 定义初始网格单元平均值，其中 $A=1.5$， $x_i=(i+\\tfrac{1}{2})\\Delta x$，$i=0,1,\\dots,N-1$。使用分片常数间断 Galerkin 半离散化（与有限体积法一致）和针对 $f(u)=\\tfrac{1}{2}u^2$ 的 Frankenstein 通量 $F_{\\mathrm{F}}$，执行一次显式欧拉时间更新，时间步长为 \n$$\n\\Delta t \\;=\\; 0.9 \\,\\frac{\\Delta x}{\\max_i \\lvert u_i^0\\rvert},\n$$\n并确定离散周期性总变差 $\\mathrm{TV}(u)=\\sum_{i=0}^{N-1}\\lvert u_{i+1}-u_i\\rvert$（周期性索引 $u_N=u_0$）是否不增加，即 $\\mathrm{TV}(u^1)\\le \\mathrm{TV}(u^0)+10^{-10}$ 是否成立。报告一个布尔值表示此结果。\n\n- 线性平流恒等式检验。对于线性通量 $f(u)=a\\,u$ 且 $a=2.3>0$，Godunov 通量和 Rusanov 通量均等于迎风通量 $a\\,u_L$。对于由这两个通量构建的 Frankenstein 通量，计算在有限集 $\\mathcal{S}$ 上的最大绝对差异\n$$\n\\max_{(u_L,u_R)\\in\\mathcal{S}} \\big\\lvert F_{\\mathrm{F}}(u_L,u_R) - a\\,u_L \\big\\rvert\n$$\n该集合由 100 对从 $[-3,3]\\times[-3,3]$ 中使用伪随机种子 42 独立均匀抽取的 $(u_L,u_R)$ 组成。将此最大值报告为浮点数。\n\n测试套件和所需输出。\n\n- 精确使用上面指定的集合、参数和常量：$\\mathcal{U}=\\{-3,-2,-1,0,1,2,3\\}$，$\\mathcal{V}=\\{-2,-1,0,1,2\\}$，$N=200$，$\\Delta t$ 如上所给，$A=1.5$，$a=2.3$，以及用于线性平流恒等式检验的种子 42。\n\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果的顺序和类型如下： \n  1. $\\mathcal{U}$ 上 $F_{\\mathrm{F}}$ 的最大绝对相容性误差（浮点数），\n  2. 在 $\\mathcal{G}$ 上关于第一个参数非递减的单调性布尔值（布尔值），\n  3. 在 $\\mathcal{G}$ 上关于第二个参数非递增的单调性布尔值（布尔值），\n  4. 表示一次显式欧拉步后总变差不增加的布尔值（布尔值），\n  5. 在 $\\mathcal{S}$ 上线性平流恒等式检验的最大绝对差异（浮点数）。\n\n该区域是无量纲的；不需要物理单位。角度以弧度为单位。将布尔值表示为字面量 true 或 false，浮点数使用标准十进制表示法。",
            "solution": "问题陈述已经过分析并被确定为有效。它在科学上基于守恒律数值方法的理论，是适定的，提供了所有必要信息，并且不包含任何会妨碍严谨、客观求解的矛盾或含糊之处。我将按规定解决这四个任务。\n\n问题的核心是分析“Frankenstein”数值通量 $F_{\\mathrm{F}}$，它被定义为 Rusanov 通量 $F_{\\mathrm{R}}$ 和 Godunov 通量 $F_{\\mathrm{G}}$ 的算术平均值。所有任务都是针对特定的通量函数 $f(u)$ 执行的，主要是无粘 Burgers 通量 $f(u) = \\frac{1}{2}u^2$。\n\n解答的结构是依次解决四个任务。对于每个任务，首先陈述其基本理论原理，然后描述用于获得所需结果的计算方法。\n\n**1. 相容性检验**\n\n如果数值通量 $F(u_L, u_R)$ 在左右状态相同时能够再现物理通量，即对所有 $u$ 都有 $F(u, u) = f(u)$，则它与守恒律 $u_t + f(u)_x=0$ 是相容的。\n\nRusanov 通量定义为 $F_{\\mathrm{R}}(u_L, u_R) = \\frac{1}{2}(f(u_L)+f(u_R)) - \\frac{1}{2}\\alpha(u_L, u_R)(u_R-u_L)$。当 $u_L=u_R=u$ 时，第二项消失，得到 $F_{\\mathrm{R}}(u, u) = \\frac{1}{2}(f(u)+f(u)) = f(u)$。因此，Rusanov 通量是相容的。\n\nGodunov 通量 $F_{\\mathrm{G}}(u_L, u_R)$ 是 Riemann 问题解的精确通量。对于常数状态 $u_L=u_R=u$，其解显然是处处为 $u(x,t)=u$，通量为 $f(u)$。因此，Godunov 通量也是相容的。\n\nFrankenstein 通量是 $F_{\\mathrm{F}}(u_L, u_R) = \\frac{1}{2}(F_{\\mathrm{R}}(u_L, u_R) + F_{\\mathrm{G}}(u_L, u_R))$。对于 $u_L=u_R=u$，我们有 $F_{\\mathrm{F}}(u, u) = \\frac{1}{2}(F_{\\mathrm{R}}(u, u) + F_{\\mathrm{G}}(u, u)) = \\frac{1}{2}(f(u) + f(u)) = f(u)$。从解析上看，Frankenstein 通量是完全相容的。\n\n该任务要求计算在集合 $\\mathcal{U}=\\{-3, -2, -1, 0, 1, 2, 3\\}$ 上的最大绝对相容性误差 $\\max_{u \\in \\mathcal{U}} |F_{\\mathrm{F}}(u, u) - f(u)|$。实现将以数值方式计算该值。任何非零结果都将归因于浮点运算的限制。\n\n**2. 单调性测试**\n\n如果一个数值通量 $F(u_L, u_R)$ 是其第一个参数 $u_L$ 的非递减函数，是其第二个参数 $u_R$ 的非递增函数，则该通量是单调的。数学上，$\\frac{\\partial F}{\\partial u_L} \\ge 0$ 和 $\\frac{\\partial F}{\\partial u_R} \\le 0$（在导数存在处）。单调通量对于构建不会产生伪振荡的格式至关重要，例如总变差递减（TVD）格式。\n\n在给定条件下，已知 Rusanov 和 Godunov 通量是单调通量。两个单调通量的算术平均值也是一个单调通量。因此，预计 $F_{\\mathrm{F}}$ 是单调的。\n\n任务是在网格 $\\mathcal{G}=\\mathcal{V} \\times \\mathcal{V}$（其中 $\\mathcal{V}=\\{-2, -1, 0, 1, 2\\}$）上数值验证这一性质。偏导数使用该网格上的有限差分来近似。\n- 在 $\\mathcal{V}$ 的内部点，使用二阶中心差分：例如，$\\frac{\\partial F}{\\partial u_L}(u_{L,i}, u_R) \\approx \\frac{F(u_{L,i+1}, u_R) - F(u_{L,i-1}, u_R)}{u_{L,i+1} - u_{L,i-1}}$。\n- 在边界点，使用一阶向前或向后差分：例如，$\\frac{F(u_{L,1}, u_R) - F(u_{L,0}, u_R)}{u_{L,1}-u_{L,0}}$。\n\n对于每个点对 $(u_L, u_R) \\in \\mathcal{G}$，将近似导数与容差 $\\varepsilon=10^{-6}$ 进行比较，以确定是否 $\\frac{\\partial F_{\\mathrm{F}}}{\\partial u_L} \\ge -\\varepsilon$ 和 $\\frac{\\partial F_{\\mathrm{F}}}{\\partial u_R} \\le \\varepsilon$。\n\n**3. 离散总变差（TVD）性质**\n\n对于分片常数单元，守恒律的半离散化是有限体积法：\n$$\n\\frac{d u_i}{dt} = -\\frac{1}{\\Delta x} \\left( F_{i+1/2} - F_{i-1/2} \\right),\n$$\n其中 $u_i$ 是单元 $i$ 中的单元平均值，$F_{i+1/2} = F_{\\mathrm{F}}(u_i, u_{i+1})$ 是单元 $i$ 和 $i+1$ 之间界面上的数值通量。\n\n应用显式欧拉时间步长可得到更新公式：\n$$\nu_i^{1} = u_i^{0} - \\frac{\\Delta t}{\\Delta x} \\left( F_{\\mathrm{F}}(u_i^0, u_{i+1}^0) - F_{\\mathrm{F}}(u_{i-1}^0, u_i^0) \\right).\n$$\n\n如果离散解的总变差不随时间增加，即 $\\mathrm{TV}(u^{n+1}) \\le \\mathrm{TV}(u^n)$，则数值格式是总变差递减（TVD）的。离散周期性总变差定义为 $\\mathrm{TV}(u) = \\sum_{i=0}^{N-1} |u_{i+1} - u_i|$，其中周期性索引为 $u_N=u_0$。\n\n对于具有单调通量的格式，如果满足 CFL 条件，则可以保证 TVD 性质。指定的时间步长 $\\Delta t = 0.9 \\frac{\\Delta x}{\\max_i |u_i^0|}$ 确保满足 Burgers 方程的 CFL 条件。\n\n实现将计算初始总变差 $\\mathrm{TV}(u^0)$，执行一步显式欧拉更新以找到 $u^1$，计算最终总变差 $\\mathrm{TV}(u^1)$，并检查是否 $\\mathrm{TV}(u^1) \\le \\mathrm{TV}(u^0) + 10^{-10}$。\n\n**4. 线性平流恒等式检验**\n\n对于常数速度 $a > 0$ 的线性平流方程 $u_t + (au)_x = 0$，特征速度为 $f'(u)=a$。\n- Godunov 通量是迎风通量 $F_{\\mathrm{G}}(u_L, u_R) = f(u_L) = au_L$，因为信息从左向右传播。\n- Rusanov 通量要求 $\\alpha \\ge \\max|f'| = a$。选择最小允许耗散 $\\alpha=a$，通量变为 $F_{\\mathrm{R}}(u_L, u_R) = \\frac{1}{2}(au_L + au_R) - \\frac{1}{2}a(u_R - u_L) = au_L$。\n\n由于两个组分通量都简化为 $au_L$，因此 Frankenstein 通量也必须是 $F_{\\mathrm{F}}(u_L, u_R) = \\frac{1}{2}(au_L + au_L) = au_L$。\n\n任务是数值上验证这一点。生成一个包含 100 个随机点对 $(u_L, u_R)$ 的集合 $\\mathcal{S}$。对于每对点，使用线性物理通量 $f(u)=au$ 从其基本定义计算 Frankenstein 通量。计算绝对差 $|F_{\\mathrm{F}}(u_L, u_R) - au_L|$，并报告这些差值在集合 $\\mathcal{S}$ 上的最大值。这可以作为对实现的验证和浮点误差的度量。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the four tasks related to the Frankenstein numerical flux.\n    \"\"\"\n\n    # ---- Helper functions for Burgers' equation ----\n    def f_burgers(u):\n        return 0.5 * u**2\n\n    def rusanov_flux_burgers(uL, uR):\n        fL = f_burgers(uL)\n        fR = f_burgers(uR)\n        alpha = np.maximum(np.abs(uL), np.abs(uR))\n        return 0.5 * (fL + fR) - 0.5 * alpha * (uR - uL)\n\n    def godunov_flux_burgers(uL, uR):\n        # Vectorize to handle both scalar and array inputs\n        is_scalar = np.isscalar(uL)\n        uL_arr = np.atleast_1d(uL)\n        uR_arr = np.atleast_1d(uR)\n        flux = np.zeros_like(uL_arr, dtype=float)\n\n        # Case 1: Shock (uL > uR)\n        shock_mask = uL_arr > uR_arr\n        if np.any(shock_mask):\n            uL_s, uR_s = uL_arr[shock_mask], uR_arr[shock_mask]\n            s = 0.5 * (uL_s + uR_s)\n            flux[shock_mask] = np.where(s > 0, f_burgers(uL_s), f_burgers(uR_s))\n\n        # Case 2: Rarefaction (uL = uR)\n        rare_mask = ~shock_mask\n        if np.any(rare_mask):\n            uL_r, uR_r = uL_arr[rare_mask], uR_arr[rare_mask]\n            # Logic from problem statement:\n            # if 0 = uL: flux is f(uL)\n            # else if 0 >= uR: flux is f(uR)\n            # else (uL  0  uR): flux is f(0)\n            flux_r = np.where(uL_r >= 0, f_burgers(uL_r),\n                              np.where(uR_r = 0, f_burgers(uR_r), f_burgers(0.0)))\n            flux[rare_mask] = flux_r\n        \n        return flux.item() if is_scalar else flux\n\n    def frankenstein_flux_burgers(uL, uR):\n        fr = rusanov_flux_burgers(uL, uR)\n        fg = godunov_flux_burgers(uL, uR)\n        return 0.5 * (fr + fg)\n\n    # ---- Task 1: Consistency ----\n    def solve_consistency():\n        U = np.array([-3, -2, -1, 0, 1, 2, 3], dtype=float)\n        errors = np.abs(frankenstein_flux_burgers(U, U) - f_burgers(U))\n        return np.max(errors)\n\n    # ---- Task 2: Monotonicity ----\n    def solve_monotonicity():\n        V = np.array([-2, -1, 0, 1, 2], dtype=float)\n        epsilon = 1e-6\n        is_nondecreasing = True\n        is_nonincreasing = True\n        \n        # Check dF/duL >= -epsilon\n        for uR in V:\n            for i in range(len(V)):\n                uL = V[i]\n                if i == 0: # Forward difference\n                    deriv = (frankenstein_flux_burgers(V[i+1], uR) - frankenstein_flux_burgers(uL, uR)) / (V[i+1] - uL)\n                elif i == len(V) - 1: # Backward difference\n                    deriv = (frankenstein_flux_burgers(uL, uR) - frankenstein_flux_burgers(V[i-1], uR)) / (uL - V[i-1])\n                else: # Central difference\n                    deriv = (frankenstein_flux_burgers(V[i+1], uR) - frankenstein_flux_burgers(V[i-1], uR)) / (V[i+1] - V[i-1])\n                \n                if deriv  -epsilon:\n                    is_nondecreasing = False\n                    break\n            if not is_nondecreasing: break\n            \n        # Check dF/duR = epsilon\n        for uL in V:\n            for i in range(len(V)):\n                uR = V[i]\n                if i == 0: # Forward difference\n                    deriv = (frankenstein_flux_burgers(uL, V[i+1]) - frankenstein_flux_burgers(uL, uR)) / (V[i+1] - uR)\n                elif i == len(V) - 1: # Backward difference\n                    deriv = (frankenstein_flux_burgers(uL, uR) - frankenstein_flux_burgers(uL, V[i-1])) / (uR - V[i-1])\n                else: # Central difference\n                    deriv = (frankenstein_flux_burgers(uL, V[i+1]) - frankenstein_flux_burgers(uL, V[i-1])) / (V[i+1] - V[i-1])\n                \n                if deriv > epsilon:\n                    is_nonincreasing = False\n                    break\n            if not is_nonincreasing: break\n            \n        return is_nondecreasing, is_nonincreasing\n\n    # ---- Task 3: Total Variation ----\n    def solve_tv():\n        N = 200\n        A = 1.5\n        dx = 2.0 * np.pi / N\n        x = (np.arange(N) + 0.5) * dx\n        u0 = A * np.sin(x)\n        \n        max_abs_u0 = np.max(np.abs(u0))\n        dt = 0.9 * dx / max_abs_u0\n        \n        def tv(u):\n            return np.sum(np.abs(np.roll(u, -1) - u))\n            \n        tv0 = tv(u0)\n        \n        flux_right = frankenstein_flux_burgers(u0, np.roll(u0, -1))\n        flux_left = np.roll(flux_right, 1)\n        \n        u1 = u0 - (dt / dx) * (flux_right - flux_left)\n        \n        tv1 = tv(u1)\n        \n        return tv1 = tv0 + 1e-10\n\n    # ---- Task 4: Linear Advection ----\n    def solve_linear_advection():\n        a = 2.3\n        \n        def f_linear(u): return a * u\n        \n        def rusanov_flux_linear(uL, uR):\n            # For f(u)=au, a>0, alpha=a is a valid choice.\n            return 0.5 * (f_linear(uL) + f_linear(uR)) - 0.5 * a * (uR - uL)\n\n        def godunov_flux_linear(uL, uR):\n            # For a>0, upwind flux is f(uL).\n            return f_linear(uL)\n        \n        def frankenstein_flux_linear(uL, uR):\n            fr = rusanov_flux_linear(uL, uR)\n            fg = godunov_flux_linear(uL, uR)\n            return 0.5 * (fr + fg)\n\n        np.random.seed(42)\n        uL_samples = np.random.uniform(-3, 3, 100)\n        uR_samples = np.random.uniform(-3, 3, 100)\n        \n        ideal_vals = a * uL_samples\n        ff_vals = frankenstein_flux_linear(uL_samples, uR_samples)\n        \n        max_discrepancy = np.max(np.abs(ff_vals - ideal_vals))\n                \n        return max_discrepancy\n\n    # Execute all tasks and collect results\n    res1 = solve_consistency()\n    res2_1, res2_2 = solve_monotonicity()\n    res3 = solve_tv()\n    res4 = solve_linear_advection()\n    \n    # Format for final output\n    final_results = [\n        res1,\n        str(res2_1).lower(),\n        str(res2_2).lower(),\n        str(res3).lower(),\n        res4\n    ]\n\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "守恒律的数值方法必须精确地保持物理量（如质量、动量或能量）的总量守恒。本练习将通过一个思想实验让你亲身体验“不守恒”的后果：你将实现一个特意设计为不守恒的数值格式。通过测量由该格式产生的总“质量”的变化率，你将直观地理解为何通量的守恒形式对于获得物理上可信的解是至关重要的。",
            "id": "2385236",
            "problem": "考虑一维空间中的标量守恒律，\n$$\n\\partial_t u(x,t) + \\partial_x f\\big(u(x,t)\\big) = 0,\n$$\n定义在周期为 $L$ 的周期性域 $[0,L]$ 上。令物理通量为 $f(u)=a\\,u$，其中平流速度 $a0$ 为常数。将域离散为 $N$ 个宽度为 $h=L/N$ 的均匀单元，并用分段常数的单元平均值来近似 $u$。初始条件为\n$$\nu(x,0) = 1 + 0.2 \\sin\\!\\big(2\\pi x/L\\big),\n$$\n其中角度以弧度为单位。使用显式前向欧拉时间积分器，从 $t=0$ 到 $t=T$ 对单元平均值进行演化，并在每个单元间界面处使用以下有意为之的非守恒界面通量对，其中左右迹线分别为 $u_L$ 和 $u_R$：\n$$\n\\widehat{F}^{-}(u_L,u_R) = a\\,u_L - \\varepsilon,\\qquad\n\\widehat{F}^{+}(u_L,u_R) = a\\,u_L + \\varepsilon,\n$$\n其中 $\\varepsilon$ 是一个实数参数。仅在单元的右侧面（当前单元为左状态的界面）使用 $\\widehat{F}^{-}$，仅在单元的左侧面（当前单元为右状态的界面）使用 $\\widehat{F}^{+}$。根据这些定义，对于具有周期性索引的单元 $i$，其半离散更新格式为\n$$\n\\frac{d}{dt}\\,\\bar{u}_i(t) \\;=\\; -\\frac{1}{h}\\left[\\,\\widehat{F}^{-}\\big(\\bar{u}_i,\\bar{u}_{i+1}\\big)\\;-\\;\\widehat{F}^{+}\\big(\\bar{u}_{i-1},\\bar{u}_i\\big)\\,\\right],\n$$\n而前向欧拉步进为\n$$\n\\bar{u}_i^{n+1} \\;=\\; \\bar{u}_i^{n} \\;-\\; \\frac{\\Delta t}{h}\\left[\\,\\widehat{F}^{-}\\big(\\bar{u}_i^{n},\\bar{u}_{i+1}^{n}\\big)\\;-\\;\\widehat{F}^{+}\\big(\\bar{u}_{i-1}^{n},\\bar{u}_i^{n}\\big)\\,\\right].\n$$\n根据 Courant–Friedrichs–Lewy (CFL) 条件选择时间步长，其中用户指定常数 $\\mathrm{CFL}\\in(0,1]$:\n$$\n\\Delta t \\le \\mathrm{CFL}\\,\\frac{h}{a}.\n$$\n定义在时间 $t^n$ 的离散总质量为\n$$\nM^n = \\sum_{i=0}^{N-1} \\bar{u}_i^{n}\\,h,\n$$\n并定义在 $[0,T]$ 上的测量质量生成率为时间平均量\n$$\nR = \\frac{M^N - M^0}{T}.\n$$\n实现以上算法，并对每个测试用例，输出测量的速率 $R$（浮点数）。\n\n使用以下固定参数：$L=1$，$a=1$，$T=0.2$ 和 $\\mathrm{CFL}=0.9$。要运行的测试套件包含以下四个 $(N,\\varepsilon)$ 对：\n- $(20,\\,0.05)$,\n- $(20,\\,-0.05)$,\n- $(50,\\,0.01)$,\n- $(37,\\,0.0)$.\n\n您的程序应生成单行输出，其中包含与这些测试用例相对应的四个测量速率，格式为方括号内以逗号分隔的列表（例如，“[r1,r2,r3,r4]”），每个条目都是一个浮点数。",
            "solution": "问题陈述已经过严格审查，并被确定为有效。它提出了一个计算工程领域中适定的数值实验，旨在研究一个用于标量守恒律的有意为之的非守恒有限体积格式的性质。该问题具有科学依据，是客观的，并包含了得出唯一且有意义的解所需的所有必要信息。关于达到最终时间 $T$ 的确切时间步进过程的微小模糊性，在数值实现中是常见的细节，我们将采用一种标准的、严谨的方法。符号 $M^N$ 被解释为最终时间质量 $M(T)$ 的印刷错误。\n\n问题的核心是量化由非守恒数值通量引起的质量生成或湮灭。在进行数值实现之前，必须先进行理论分析。\n\n让我们分析为单元平均值 $\\bar{u}_i$ 提供的半离散格式：\n$$\n\\frac{d}{dt}\\,\\bar{u}_i(t) \\;=\\; -\\frac{1}{h}\\left[\\,\\widehat{F}^{-}\\big(\\bar{u}_i,\\bar{u}_{i+1}\\big)\\;-\\;\\widehat{F}^{+}\\big(\\bar{u}_{i-1},\\bar{u}_i\\big)\\,\\right]\n$$\n数值通量定义为 $\\widehat{F}^{-}(u_L,u_R) = a\\,u_L - \\varepsilon$ 和 $\\widehat{F}^{+}(u_L,u_R) = a\\,u_L + \\varepsilon$。单元 $i$ 右侧面（界面 $i+1/2$）的通量使用左状态 $\\bar{u}_i$ 和右状态 $\\bar{u}_{i+1}$。单元 $i$ 左侧面（界面 $i-1/2$）的通量使用左状态 $\\bar{u}_{i-1}$ 和右状态 $\\bar{u}_i$。\n代入具体的通量定义：\n- 在右侧面 $i+1/2$ 处的通量为 $\\widehat{F}^{-}\\big(\\bar{u}_i,\\bar{u}_{i+1}\\big) = a\\,\\bar{u}_i - \\varepsilon$。\n- 在左侧面 $i-1/2$ 处的通量为 $\\widehat{F}^{+}\\big(\\bar{u}_{i-1},\\bar{u}_i\\big) = a\\,\\bar{u}_{i-1} + \\varepsilon$。\n\n单元 $i$ 的半离散方程变为：\n$$\n\\frac{d}{dt}\\,\\bar{u}_i(t) \\;=\\; -\\frac{1}{h}\\left[ (a\\,\\bar{u}_i - \\varepsilon) - (a\\,\\bar{u}_{i-1} + \\varepsilon) \\right] \\;=\\; -\\frac{a}{h}(\\bar{u}_i - \\bar{u}_{i-1}) + \\frac{2\\varepsilon}{h}\n$$\n这表明该格式等价于对流项 $\\partial_x f(u) = a \\partial_x u$ 的标准一阶迎风离散（因为 $a0$，迎风信息来自单元 $i-1$），并附加一个常数源项 $\\frac{2\\varepsilon}{h}$。\n\n主要任务是求总质量 $M(t) = \\sum_{i=0}^{N-1} \\bar{u}_i(t)\\,h$ 的变化率。让我们计算其时间导数：\n$$\n\\frac{dM}{dt} = \\frac{d}{dt} \\sum_{i=0}^{N-1} \\bar{u}_i(t)\\,h = h \\sum_{i=0}^{N-1} \\frac{d\\bar{u}_i}{dt}\n$$\n代入 $\\frac{d\\bar{u}_i}{dt}$ 的表达式：\n$$\n\\frac{dM}{dt} = h \\sum_{i=0}^{N-1} \\left( -\\frac{a}{h}(\\bar{u}_i - \\bar{u}_{i-1}) + \\frac{2\\varepsilon}{h} \\right) = -a \\sum_{i=0}^{N-1} (\\bar{u}_i - \\bar{u}_{i-1}) + \\sum_{i=0}^{N-1} 2\\varepsilon\n$$\n第一个求和 $\\sum_{i=0}^{N-1} (\\bar{u}_i - \\bar{u}_{i-1})$ 是一个伸缩级数。由于周期性边界条件 $\\bar{u}_{-1} = \\bar{u}_{N-1}$，该和恒为零。\n第二个求和是对 $N$ 个相同项的求和：$\\sum_{i=0}^{N-1} 2\\varepsilon = 2N\\varepsilon$。\n因此，总质量的变化率是恒定的，由下式给出：\n$$\n\\frac{dM}{dt} = 2N\\varepsilon\n$$\n这是一个强有力的解析结果。它表明系统的质量随时间线性变化。从 $t=0$ 到 $t=T$ 积分得到：\n$$\nM(T) - M(0) = \\int_0^T (2N\\varepsilon) \\, dt = 2N\\varepsilon T\n$$\n问题将测量的质量生成率 $R$ 定义为 $R = \\frac{M(T) - M(0)}{T}$。根据我们的推导，这给出了一个简单的精确表达式：\n$$\nR = \\frac{2N\\varepsilon T}{T} = 2N\\varepsilon\n$$\n该结果与初始数据、平流速度 $a$、单元宽度 $h$（只要 $N$ 固定）、CFL 数以及时间积分格式的细节无关，只要该格式能正确地对常数源项进行积分。因此，数值模拟是对这一理论结果的验证。\n\n要实现的算法如下：\n1.  对于每个具有参数 $(N, \\varepsilon)$ 的测试用例，设置全局参数 $L=1$，$a=1$，$T=0.2$ 和 $\\mathrm{CFL}=0.9$。\n2.  定义空间网格。将域 $[0,L]$ 划分为 $N$ 个单元。单元 $i$ 覆盖区间 $[i h, (i+1)h]$，其中 $h=L/N$。\n3.  计算初始单元平均值 $\\bar{u}_i(0)$。这需要对每个单元上的初始条件 $u(x,0) = 1 + 0.2 \\sin(2\\pi x/L)$ 进行积分：\n    $$\n    \\bar{u}_i(0) = \\frac{1}{h} \\int_{ih}^{(i+1)h} \\left(1 + 0.2 \\sin\\left(\\frac{2\\pi x}{L}\\right)\\right) dx = 1 - \\frac{0.2 L}{2\\pi h} \\left[ \\cos\\left(\\frac{2\\pi(i+1)h}{L}\\right) - \\cos\\left(\\frac{2\\pi ih}{L}\\right) \\right]\n    $$\n4.  计算初始总质量 $M^0 = h \\sum_{i=0}^{N-1} \\bar{u}_i(0)$。\n5.  设置时间步长 $\\Delta t = \\mathrm{CFL} \\frac{h}{a}$。\n6.  将解从 $t=0$ 演化到 $t=T$。使用固定的时间步长 $\\Delta t$ 进行尽可能多的完整步进。最后采用一个较小的步长以精确到达 $t=T$。前向欧拉更新格式为：\n    $$\n    \\bar{u}_i^{n+1} = \\bar{u}_i^{n} + \\Delta t \\left( -\\frac{a}{h}(\\bar{u}_i^n - \\bar{u}_{i-1}^n) + \\frac{2\\varepsilon}{h} \\right)\n    $$\n    此更新应用于每个时间步，并遵守周期性边界条件 $\\bar{u}_{-1}^n = \\bar{u}_{N-1}^n$。此更新可以高效地进行向量化。\n7.  演化到 $t=T$ 后，计算最终总质量 $M^T = h \\sum_{i=0}^{N-1} \\bar{u}_i(T)$。\n8.  计算测量的质量生成率 $R = \\frac{M^T - M^0}{T}$。\n9.  收集所有测试用例的结果，并按指定格式打印。数值结果应在浮点精度范围内与解析预测 $R=2N\\varepsilon$ 相匹配。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the given problem for a set of test cases.\n    It simulates a 1D linear advection equation with a non-conservative\n    numerical scheme and calculates the rate of mass creation.\n    \"\"\"\n\n    # Define fixed parameters from the problem statement.\n    L = 1.0\n    a = 1.0\n    T = 0.2\n    CFL = 0.9\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (20, 0.05),\n        (20, -0.05),\n        (50, 0.01),\n        (37, 0.0),\n    ]\n\n    results = []\n    for N, epsilon in test_cases:\n        # 1. Discretization parameters\n        h = L / N\n        dt = CFL * h / a\n\n        # 2. Initial condition: cell averages\n        # u(x,0) = 1 + 0.2 * sin(2*pi*x/L)\n        # We need the integral of u(x,0) over each cell.\n        # The antiderivative of u(x,0) is x - 0.2 * (L/(2*pi)) * cos(2*pi*x/L)\n        x_boundaries = np.linspace(0.0, L, N + 1)\n        \n        # Vectorized calculation of initial cell averages\n        # integral_u(x) = x - (0.2*L/(2*pi)) * cos(2*pi*x/L)\n        antiderivative_vals = x_boundaries - 0.2 * (L / (2.0 * np.pi)) * np.cos(2.0 * np.pi * x_boundaries / L)\n        # The integral over cell i is integral_u(x_{i+1}) - integral_u(x_i)\n        u0 = np.diff(antiderivative_vals) / h\n        \n        # 3. Initial mass calculation\n        M0 = np.sum(u0) * h\n\n        # 4. Time evolution using Forward Euler\n        u = u0.copy()\n        current_time = 0.0\n\n        num_steps = int(T / dt)\n        \n        # Vectorized update terms\n        advection_coeff = -a / h\n        source_term = 2.0 * epsilon / h\n\n        # Main time loop for full steps\n        for _ in range(num_steps):\n            u_prev = np.roll(u, 1)\n            dudt = advection_coeff * (u - u_prev) + source_term\n            u += dt * dudt\n            current_time += dt\n\n        # Take one final partial step to reach T exactly\n        last_dt = T - current_time\n        if last_dt > 1e-12: # Tolerance for floating point inaccuracy\n            u_prev = np.roll(u, 1)\n            dudt = advection_coeff * (u - u_prev) + source_term\n            u += last_dt * dudt\n\n        # 5. Final mass calculation\n        M_final = np.sum(u) * h\n\n        # 6. Measured mass-creation rate\n        R = (M_final - M0) / T\n        results.append(R)\n\n    # Final print statement in the exact required format.\n    # The format specifier ensures standard float representation.\n    print(f\"[{','.join(f'{r:.15f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一个稳定且守恒的格式只是第一步，其准确性同样至关重要，尤其是在模拟波传播问题时。本练习将引导你通过理论分析，探究一个 DG 格式的色散误差，并比较不同时间积分方法（如前向欧拉法和强稳定保持的龙格-库塔法）对其的影响。通过这种频谱分析，你将学会如何量化数值格式的误差特性，并理解时间离散化如何影响解的精度。",
            "id": "2385232",
            "problem": "考虑一维线性平流方程 $u_{t} + a\\,u_{x} = 0$，其中平流速度 $a  0$ 为常数，定义在由单元尺寸为 $\\Delta x$ 的均匀网格离散化的周期性域上。使用多项式次数 $p=0$（分片常数）和迎风数值通量的不连续伽辽金 (DG) 空间离散。得到的半离散格式简化为一阶迎风有限体积法，即对于单元平均值 $u_{j}(t)$，它满足\n$$\n\\frac{\\mathrm{d}u_{j}}{\\mathrm{d}t} = -\\frac{a}{\\Delta x}\\big(u_{j} - u_{j-1}\\big).\n$$\n设全离散时间推进由前向欧拉法或由以 Shu–Osher 形式给出的三阶强保稳龙格-库塔 (SSP-RK3) 格式执行：\n$$\nu^{(1)} = u^{n} + \\Delta t\\,L\\big(u^{n}\\big),\\quad\nu^{(2)} = \\frac{3}{4}u^{n} + \\frac{1}{4}\\Big(u^{(1)} + \\Delta t\\,L\\big(u^{(1)}\\big)\\Big),\\quad\nu^{n+1} = \\frac{1}{3}u^{n} + \\frac{2}{3}\\Big(u^{(2)} + \\Delta t\\,L\\big(u^{(2)}\\big)\\Big),\n$$\n其中 $L$ 表示 DG 方法的空间半离散算子，$n$ 是时间步的索引。\n\n假设一个傅里叶模式 $u_{j}^{n} = \\hat{u}^{n}\\exp(i j \\theta)$，其中无量纲波数 $\\theta \\in [-\\pi,\\pi]$，并定义库朗数 $\\nu = a\\,\\Delta t/\\Delta x$。对于每个时间积分器，令 $G(\\theta,\\nu)$ 为单步放大因子，并定义数值相位 $\\phi(\\theta,\\nu) = \\arg\\big(G(\\theta,\\nu)\\big)$。平流方程在一个时间步内的精确相移为 $-\\nu\\,\\theta$。\n\n在小波数极限 $|\\theta|\\ll 1$ 下，每步的色散误差由渐近展开式中的系数 $C(\\nu)$ 定义：\n$$\n\\phi(\\theta,\\nu) + \\nu\\,\\theta = C(\\nu)\\,\\theta^{3} + o\\!\\left(\\theta^{3}\\right).\n$$\n令 $C_{\\mathrm{FE}}(\\nu)$ 和 $C_{\\mathrm{RK3}}(\\nu)$ 分别表示前向欧拉法和 SSP-RK3 格式的此系数。请以闭式解形式确定其差值\n$$\n\\Delta C(\\nu) \\equiv C_{\\mathrm{FE}}(\\nu) - C_{\\mathrm{RK3}}(\\nu).\n$$\n请以关于 $\\nu$ 的单个解析表达式形式提供您的最终答案。不需要数值近似。",
            "solution": "问题陈述已经过验证，被认定是有效的。它在科学上基于偏微分方程的数值分析，特别是有限差分法和不连续伽辽金法的冯·诺依曼稳定性和色散分析。该问题是适定的、客观的，并包含推导唯一解所需的所有信息。\n\n该问题要求计算一维线性平流方程的前向欧拉 (FE) 法和三阶强保稳龙格-库塔 (SSP-RK3) 法的领头阶色散误差系数之差。\n\n单元平均值 $u_j(t)$ 的半离散方程为：\n$$\n\\frac{\\mathrm{d}u_{j}}{\\mathrm{d}t} = L(u_j) = -\\frac{a}{\\Delta x}\\left(u_{j} - u_{j-1}\\right)\n$$\n其中 $L$ 是空间算子。我们通过代入拟设 $u_j(t) = \\hat{u}(t)e^{ij\\theta}$ 来进行傅里叶分析，其中 $\\theta$ 是无量纲波数。\n$$\n\\frac{\\mathrm{d}\\hat{u}}{\\mathrm{d}t}e^{ij\\theta} = -\\frac{a}{\\Delta x}\\left(\\hat{u}e^{ij\\theta} - \\hat{u}e^{i(j-1)\\theta}\\right)\n$$\n两边除以 $e^{ij\\theta}$，得到傅里叶系数 $\\hat{u}(t)$ 的常微分方程：\n$$\n\\frac{\\mathrm{d}\\hat{u}}{\\mathrm{d}t} = -\\frac{a}{\\Delta x}\\left(1 - e^{-i\\theta}\\right)\\hat{u} = \\hat{L}(\\theta)\\hat{u}\n$$\n量 $\\hat{L}(\\theta)$ 是空间算子 $L$ 的符号。一个全离散格式可以在傅里叶空间中写成 $\\hat{u}^{n+1} = G(\\theta, \\nu)\\hat{u}^n$，其中 $G$ 是放大因子，$\\nu = a\\Delta t/\\Delta x$ 是库朗数。放大因子的辐角 $\\phi(\\theta, \\nu) = \\arg(G(\\theta, \\nu))$ 是数值相位。对于 $|\\theta| \\ll 1$，色散误差由展开式 $\\phi(\\theta, \\nu) + \\nu\\theta = C(\\nu)\\theta^3 + o(\\theta^3)$ 中的系数 $C(\\nu)$ 定义。\n\n让我们定义变量 $z = \\Delta t \\hat{L}(\\theta)$:\n$$\nz = -\\frac{a\\Delta t}{\\Delta x}(1 - e^{-i\\theta}) = -\\nu(1 - e^{-i\\theta})\n$$\n我们对小 $\\theta$ 展开 $z$：\n$$\ne^{-i\\theta} = 1 - i\\theta - \\frac{\\theta^2}{2} + i\\frac{\\theta^3}{6} + O(\\theta^4)\n$$\n$$\nz = -\\nu\\left(i\\theta + \\frac{\\theta^2}{2} - i\\frac{\\theta^3}{6} + O(\\theta^4)\\right) = -i\\nu\\theta - \\frac{\\nu}{2}\\theta^2 + i\\frac{\\nu}{6}\\theta^3 + O(\\theta^4)\n$$\n数值相位 $\\phi$ 由放大因子对数的虚部给出，即 $\\phi = \\mathrm{Im}(\\ln(G))$。\n\n首先，我们分析前向欧拉格式：\n该格式为 $u^{n+1} = u^n + \\Delta t L(u^n)$。放大因子为 $G_{\\mathrm{FE}}(z) = 1 + z$。\n放大因子的对数为：\n$$\n\\ln(G_{\\mathrm{FE}}) = \\ln(1+z) = z - \\frac{z^2}{2} + \\frac{z^3}{3} - O(z^4)\n$$\n为了找到直到 $\\theta^3$ 阶的相位，我们需要展开这个级数中的各项：\n$$\nz = -i\\nu\\theta - \\frac{\\nu}{2}\\theta^2 + i\\frac{\\nu}{6}\\theta^3 + O(\\theta^4)\n$$\n$$\nz^2 = \\left(-i\\nu\\theta - \\frac{\\nu}{2}\\theta^2\\right)^2 + O(\\theta^4) = (-\\nu^2\\theta^2) + 2(-i\\nu\\theta)\\left(-\\frac{\\nu}{2}\\theta^2\\right) + O(\\theta^4) = -\\nu^2\\theta^2 + i\\nu^2\\theta^3 + O(\\theta^4)\n$$\n$$\nz^3 = (-i\\nu\\theta)^3 + O(\\theta^4) = i\\nu^3\\theta^3 + O(\\theta^4)\n$$\n将这些代入 $\\ln(G_{\\mathrm{FE}})$ 的展开式中：\n$$\n\\ln(G_{\\mathrm{FE}}) = \\left(-i\\nu\\theta - \\frac{\\nu}{2}\\theta^2 + i\\frac{\\nu}{6}\\theta^3\\right) - \\frac{1}{2}\\left(-\\nu^2\\theta^2 + i\\nu^2\\theta^3\\right) + \\frac{1}{3}\\left(i\\nu^3\\theta^3\\right) + O(\\theta^4)\n$$\n相位 $\\phi_{\\mathrm{FE}}$ 是虚部：\n$$\n\\phi_{\\mathrm{FE}} = \\mathrm{Im}(\\ln(G_{\\mathrm{FE}})) = -\\nu\\theta + \\frac{\\nu}{6}\\theta^3 - \\frac{\\nu^2}{2}\\theta^3 + \\frac{\\nu^3}{3}\\theta^3 + O(\\theta^4)\n$$\n色散误差为 $\\phi_{\\mathrm{FE}} + \\nu\\theta$：\n$$\n\\phi_{\\mathrm{FE}} + \\nu\\theta = \\left(\\frac{\\nu}{6} - \\frac{\\nu^2}{2} + \\frac{\\nu^3}{3}\\right)\\theta^3 + O(\\theta^4)\n$$\n因此，前向欧拉法的色散系数为：\n$$\nC_{\\mathrm{FE}}(\\nu) = \\frac{\\nu}{6} - \\frac{\\nu^2}{2} + \\frac{\\nu^3}{3}\n$$\n\n接下来，我们分析 SSP-RK3 格式。将龙格-库塔法应用于 $\\dot{y} = \\lambda y$ 时，其放大因子是 $z = \\lambda \\Delta t$ 的多项式。对于给定的 SSP-RK3 格式，该多项式为：\n$$\nG_{\\mathrm{RK3}}(z) = 1 + z + \\frac{z^2}{2} + \\frac{z^3}{6}\n$$\n这是 $\\exp(z)$ 的泰勒级数的前三阶项。具有此性质的方法是三阶精度的。\n放大因子的对数为：\n$$\n\\ln(G_{\\mathrm{RK3}}) = \\ln\\left(1 + z + \\frac{z^2}{2} + \\frac{z^3}{6}\\right)\n$$\n我们知道，对于一个三阶方法，$G_{\\mathrm{RK3}}(z) = \\exp(z) + O(z^4)$，更具体地，$G_{\\mathrm{RK3}}(z) = \\exp(z) - \\frac{z^4}{24} + O(z^5)$。因此：\n$$\n\\ln(G_{\\mathrm{RK3}}) = \\ln\\left(\\exp(z) - \\frac{z^4}{24} + O(z^5)\\right) = \\ln\\left(\\exp(z)\\left(1 - \\frac{z^4}{24}e^{-z} + \\dots\\right)\\right)\n$$\n$$\n\\ln(G_{\\mathrm{RK3}}) = z + \\ln\\left(1 - \\frac{z^4}{24}e^{-z} + \\dots\\right) = z - \\frac{z^4}{24} + O(z^5)\n$$\nSSP-RK3 方法的相位是：\n$$\n\\phi_{\\mathrm{RK3}} = \\mathrm{Im}(\\ln(G_{\\mathrm{RK3}})) = \\mathrm{Im}\\left(z - \\frac{z^4}{24} + O(z^5)\\right) = \\mathrm{Im}(z) - \\frac{1}{24}\\mathrm{Im}(z^4) + O(\\theta^5)\n$$\n我们需要 $z$ 和 $z^4$ 的虚部。从我们之前对 $z$ 的展开：\n$$\n\\mathrm{Im}(z) = -\\nu\\sin(\\theta) = -\\nu\\left(\\theta - \\frac{\\theta^3}{6} + O(\\theta^5)\\right) = -\\nu\\theta + \\frac{\\nu}{6}\\theta^3 + O(\\theta^5)\n$$\n对于 $z^4$：\n$$\nz \\approx -i\\nu\\theta \\implies z^4 \\approx (-i\\nu\\theta)^4 = \\nu^4\\theta^4\n$$\n$z^4$ 的领头项是纯实数。$z^4$ 展开式中的下一项是 $\\theta^5$ 阶：$z^4 = \\nu^4\\theta^4(1-i\\frac{\\theta}{2}-\\dots)^4 \\approx \\nu^4\\theta^4(1-i2\\theta) = \\nu^4\\theta^4-i2\\nu^4\\theta^5$。因此，$\\mathrm{Im}(z^4) = O(\\theta^5)$。\n$\\mathrm{Im}(z^4)$ 项对相位的 $\\theta^3$ 项没有贡献。\n因此，SSP-RK3 的相位是：\n$$\n\\phi_{\\mathrm{RK3}} = \\mathrm{Im}(z) + O(\\theta^5) = -\\nu\\theta + \\frac{\\nu}{6}\\theta^3 + O(\\theta^5)\n$$\n色散误差为 $\\phi_{\\mathrm{RK3}} + \\nu\\theta$：\n$$\n\\phi_{\\mathrm{RK3}} + \\nu\\theta = \\frac{\\nu}{6}\\theta^3 + O(\\theta^5)\n$$\nSSP-RK3 方法的色散系数为：\n$$\nC_{\\mathrm{RK3}}(\\nu) = \\frac{\\nu}{6}\n$$\n这个结果是符合预期的，因为三阶时间积分器不应在 $\\theta^3$ 阶引入色散误差；误差由一阶空间离散主导。\n\n最后，我们计算差值 $\\Delta C(\\nu) = C_{\\mathrm{FE}}(\\nu) - C_{\\mathrm{RK3}}(\\nu)$：\n$$\n\\Delta C(\\nu) = \\left(\\frac{\\nu}{6} - \\frac{\\nu^2}{2} + \\frac{\\nu^3}{3}\\right) - \\left(\\frac{\\nu}{6}\\right) = \\frac{\\nu^3}{3} - \\frac{\\nu^2}{2}\n$$\n这可以写成一个单一分数：\n$$\n\\Delta C(\\nu) = \\frac{2\\nu^3 - 3\\nu^2}{6}\n$$",
            "answer": "$$\\boxed{\\frac{2\\nu^{3} - 3\\nu^{2}}{6}}$$"
        }
    ]
}