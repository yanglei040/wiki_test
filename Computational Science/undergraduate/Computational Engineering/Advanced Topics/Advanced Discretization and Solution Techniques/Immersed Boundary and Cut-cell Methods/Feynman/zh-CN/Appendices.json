{
    "hands_on_practices": [
        {
            "introduction": "在我们深入研究复杂的实现细节之前，理解这些方法的理论基础至关重要。这个练习将引导你通过“纸笔”推导，揭示一个标准数值格式应用于切割单元时的潜在陷阱：精度损失。这项基础分析阐明了为何需要更精密的浸入边界和切割单元技术，为我们后续的实践提供了理论依据。",
            "id": "2401460",
            "problem": "考虑守恒形式的一维线性平流偏微分方程 (PDE) $u_{t} + (a u)_{x} = 0$，其中平流速度 $a > 0$ 为常数。设空间网格主要由尺寸为 $h$ 的均匀网格单元组成，但在一个长度为 $h$ 的常规网格单元右侧，存在一个长度为 $\\alpha h$（其中 $\\alpha \\in (0,1)$）的单个切割网格单元。记常规网格单元与切割网格单元之间的共享界面（面）为 $x_{f}$。设 $\\bar{u}_{L}(t)$ 为 $u(x,t)$ 在紧邻 $x_{f}$ 左侧的常规网格单元（长度为 $h$）上的精确网格单元平均值，设 $\\bar{u}_{C}(t)$ 为 $u(x,t)$ 在 $x_{f}$ 右侧的切割网格单元（长度为 $\\alpha h$）上的精确网格单元平均值。考虑标准的一阶迎风有限体积半离散化（采用等于网格单元平均值的分段常数重构的 Godunov 通量）：\n$$\n\\frac{d \\bar{u}_{C}}{d t} = -\\frac{a}{\\alpha h}\\left(\\bar{u}_{C} - \\bar{u}_{L}\\right),\n$$\n该方法在界面 $x_{f}$ 处使用数值通量 $F_{f} = a \\bar{u}_{L}$，在切割网格单元的右界面处使用 $F_{C+1/2} = a \\bar{u}_{C}$。\n\n将切割网格单元处的局部空间截断误差定义为将精确解代入离散算子后减去精确的有限体积平衡式所得到的残差，即：\n$$\n\\tau_{C} = \\left[-\\frac{a}{\\alpha h}\\left(u(x_{f}+\\alpha h,t) - u(x_{f},t)\\right)\\right] - \\left[-\\frac{a}{\\alpha h}\\left(\\bar{u}_{C}(t) - \\bar{u}_{L}(t)\\right)\\right]\n$$\n请从第一性原理出发，使用泰勒级数和网格单元平均值的定义，推导当 $h \\to 0$ 时 $\\tau_{C}$ 的主阶项。该主阶项应以 $a$、$\\alpha$ 以及在界面位置 $x_{f}$ 处求值的 $u$ 的空间导数来表示。请将最终答案表示为仅含 $a$、$\\alpha$ 和 $u_{x}(x_{f},t)$ 的主阶截断误差项的单个闭式解析表达式（省略大-$\\mathcal{O}$表示法）。不需要进行数值近似。答案必须是无单位的单个解析表达式。",
            "solution": "该问题要求推导在一维线性平流方程 $u_t + a u_x = 0$ 上，当网格包含一个切割网格单元时，一阶迎风有限体积格式的局部空间截断误差 $\\tau_C$ 的主阶项。\n\n首先，我们建立必要的定义和关系。切割网格单元 $[x_f, x_f + \\alpha h]$ 上的网格单元平均值 $\\bar{u}_C(t)$ 的精确时间演化可以通过在该网格单元上对偏微分方程 $u_t = -a u_x$ 进行积分得到：\n$$\n\\int_{x_f}^{x_f + \\alpha h} u_t(x,t) \\,dx = -a \\int_{x_f}^{x_f + \\alpha h} u_x(x,t) \\,dx\n$$\n使用定义 $\\bar{u}_C(t) = \\frac{1}{\\alpha h} \\int_{x_f}^{x_f + \\alpha h} u(x,t) \\,dx$ 和微积分基本定理，我们得到：\n$$\n\\frac{d}{dt} (\\alpha h \\bar{u}_C(t)) = -a \\left[ u(x_f + \\alpha h, t) - u(x_f, t) \\right]\n$$\n这给出了 $\\bar{u}_C(t)$ 演化方程的精确空间算子部分：\n$$\n\\left(\\frac{d\\bar{u}_C}{dt}\\right)_{\\text{exact}} = -\\frac{a}{\\alpha h} \\left[ u(x_f + \\alpha h, t) - u(x_f, t) \\right]\n$$\n问题给出了数值格式所使用的半离散化：\n$$\n\\left(\\frac{d\\bar{u}_C}{dt}\\right)_{\\text{numerical}} = -\\frac{a}{\\alpha h} \\left( \\bar{u}_C(t) - \\bar{u}_L(t) \\right)\n$$\n根据问题陈述，局部空间截断误差 $\\tau_C$ 定义为当精确空间算子和数值空间算子都使用精确解 $u(x,t)$ 进行求值时，二者之差。注意，问题的定义是 $\\tau_C = (\\text{精确}) - (\\text{数值})$，这与某些惯例的定义符号相反。我们严格遵循问题的定义：\n$$\n\\tau_C = \\left[-\\frac{a}{\\alpha h}\\left(u(x_{f}+\\alpha h,t) - u(x_{f},t)\\right)\\right] - \\left[-\\frac{a}{\\alpha h}\\left(\\bar{u}_{C}(t) - \\bar{u}_{L}(t)\\right)\\right]\n$$\n这可以简化为：\n$$\n\\tau_C = \\frac{a}{\\alpha h} \\left[ \\left( \\bar{u}_C(t) - \\bar{u}_L(t) \\right) - \\left( u(x_f + \\alpha h, t) - u(x_f, t) \\right) \\right]\n$$\n为了找到当 $h \\to 0$ 时 $\\tau_C$ 的主阶项，我们对解 $u(x,t)$ 在界面位置 $x=x_f$ 附近进行泰勒级数展开，并保持时间 $t$ 固定。设 $u_f = u(x_f, t)$，$u_{x,f} = u_x(x_f, t)$ 等。展开式为：\n$$\nu(x,t) = u_f + (x-x_f) u_{x,f} + \\frac{(x-x_f)^2}{2} u_{xx,f} + \\mathcal{O}((x-x_f)^3)\n$$\n现在我们展开 $\\tau_C$ 表达式中的各项。首先，我们展开精确的网格单元平均值 $\\bar{u}_L(t)$ 和 $\\bar{u}_C(t)$。\n左侧常规网格单元 $[x_f-h, x_f]$ 上的网格单元平均值为：\n$$\n\\bar{u}_L(t) = \\frac{1}{h} \\int_{x_f-h}^{x_f} u(x,t) \\,dx = \\frac{1}{h} \\int_{x_f-h}^{x_f} \\left( u_f + (x-x_f) u_{x,f} + \\frac{(x-x_f)^2}{2} u_{xx,f} + \\dots \\right) dx\n$$\n$$\n\\bar{u}_L(t) = \\frac{1}{h} \\left[ (x-x_f) u_f + \\frac{(x-x_f)^2}{2} u_{x,f} + \\frac{(x-x_f)^3}{6} u_{xx,f} + \\dots \\right]_{x_f-h}^{x_f}\n$$\n$$\n\\bar{u}_L(t) = \\frac{1}{h} \\left[ (0 - (-h))u_f + \\left(0 - \\frac{(-h)^2}{2}\\right)u_{x,f} + \\dots \\right] = u_f - \\frac{h}{2} u_{x,f} + \\mathcal{O}(h^2)\n$$\n切割网格单元 $[x_f, x_f+\\alpha h]$ 上的网格单元平均值为：\n$$\n\\bar{u}_C(t) = \\frac{1}{\\alpha h} \\int_{x_f}^{x_f+\\alpha h} u(x,t) \\,dx = \\frac{1}{\\alpha h} \\int_{x_f}^{x_f+\\alpha h} \\left( u_f + (x-x_f) u_{x,f} + \\dots \\right) dx\n$$\n$$\n\\bar{u}_C(t) = \\frac{1}{\\alpha h} \\left[ (x-x_f) u_f + \\frac{(x-x_f)^2}{2} u_{x,f} + \\dots \\right]_{x_f}^{x_f+\\alpha h}\n$$\n$$\n\\bar{u}_C(t) = \\frac{1}{\\alpha h} \\left[ (\\alpha h) u_f + \\frac{(\\alpha h)^2}{2} u_{x,f} + \\dots \\right] = u_f + \\frac{\\alpha h}{2} u_{x,f} + \\mathcal{O}(h^2)\n$$\n网格单元平均值的差为：\n$$\n\\bar{u}_C(t) - \\bar{u}_L(t) = \\left( u_f + \\frac{\\alpha h}{2} u_{x,f} \\right) - \\left( u_f - \\frac{h}{2} u_{x,f} \\right) + \\mathcal{O}(h^2) = \\frac{h}{2}(1+\\alpha) u_{x,f} + \\mathcal{O}(h^2)\n$$\n接下来，我们展开包含精确解点值的项：\n$$\nu(x_f+\\alpha h, t) - u(x_f, t) = \\left( u_f + (\\alpha h) u_{x,f} + \\mathcal{O}(h^2) \\right) - u_f = \\alpha h \\, u_{x,f} + \\mathcal{O}(h^2)\n$$\n现在，将这些展开式代入 $\\tau_C$ 的公式中：\n$$\n\\tau_C = \\frac{a}{\\alpha h} \\left[ \\left( \\frac{h}{2}(1+\\alpha) u_{x,f} + \\mathcal{O}(h^2) \\right) - \\left( \\alpha h \\, u_{x,f} + \\mathcal{O}(h^2) \\right) \\right]\n$$\n$$\n\\tau_C = \\frac{a}{\\alpha h} \\left[ h u_{x,f} \\left( \\frac{1+\\alpha}{2} - \\alpha \\right) + \\mathcal{O}(h^2) \\right]\n$$\n简化 $h u_{x,f}$ 项的系数：\n$$\n\\frac{1+\\alpha}{2} - \\alpha = \\frac{1+\\alpha-2\\alpha}{2} = \\frac{1-\\alpha}{2}\n$$\n所以，$\\tau_C$ 的表达式变为：\n$$\n\\tau_C = \\frac{a}{\\alpha h} \\left[ h \\frac{1-\\alpha}{2} u_{x,f} + \\mathcal{O}(h^2) \\right] = a \\frac{1-\\alpha}{2\\alpha} u_{x,f} + \\mathcal{O}(h)\n$$\n当 $h \\to 0$ 时，截断误差的主阶项是不随 $h$ 消失的项。因为 $\\alpha \\in (0,1)$，所以 $\\alpha \\neq 1$，这个主阶项通常不为零。它的阶数为 $\\mathcal{O}(h^0)$，即相对于 $h$ 是一个常数。\n这表明该格式在切割网格单元处是不相容的（零阶精度），这是标准一阶 Godunov 方法在简单应用于非均匀网格时的一个已知缺陷。\n\n因此，主阶项为：\n$$\na \\frac{1-\\alpha}{2\\alpha} u_{x}(x_{f},t)\n$$",
            "answer": "$$\n\\boxed{a \\frac{1-\\alpha}{2\\alpha} u_{x}(x_{f},t)}\n$$"
        },
        {
            "introduction": "掌握了理论上的挑战之后，让我们转向一个非常实际且核心的应用：计算浸入物体上的作用力。本练习将指导你动手实现并比较两种主流方法——锐利界面的切割单元法和弥散界面的浸入边界法。通过将数值结果与精确解进行对比，你将对这两种方法的实现方式及其在精度上的权衡获得具体而深刻的理解。",
            "id": "2401412",
            "problem": "给定一条闭合光滑曲线 $\\Gamma \\subset \\mathbb{R}^2$，该曲线定义为以 $(c_x,c_y)$ 为中心、半径为 $R$ 的圆，即有向距离函数 $\\phi(x,y)=\\sqrt{(x-c_x)^2+(y-c_y)^2}-R$ 的零水平集。定义平面上的矢量力密度为 $\\mathbf{f}(x,y)=\\begin{bmatrix}\\cos(3\\theta(x,y))+\\tfrac{1}{2}\\\\ \\sin(2\\theta(x,y))\\end{bmatrix}$，其中 $\\theta(x,y)=\\mathrm{atan2}(y-c_y,x-c_x)$ 是围绕中心的极角，以弧度表示。总力由曲线积分 $\\mathbf{F}=\\int_{\\Gamma}\\mathbf{f}\\,ds$ 定义。\n\n您的任务是在覆盖方形域 $\\Omega=[-L,L]^2$ 的均匀笛卡尔网格上，使用两种不同的方法计算并比较 $\\mathbf{F}$ 的近似值：\n\n- 一种基于正则化狄拉克-德尔塔函数的扩散界面浸入边界近似。设正则化德尔塔函数为\n$$\n\\delta_\\varepsilon(\\phi)=\n\\begin{cases}\n\\dfrac{1}{2\\varepsilon}\\left(1+\\cos\\left(\\dfrac{\\pi\\phi}{\\varepsilon}\\right)\\right), & |\\phi|\\le \\varepsilon, \\\\[6pt]\n0, & |\\phi|>\\varepsilon,\n\\end{cases}\n$$\n并设对于有向距离 $\\phi$ 有 $|\\nabla \\phi|=1$。在一个包含 $N\\times N$ 个点、间距为 $h=\\dfrac{2L}{N-1}$ 的均匀网格上，用单元面积为 $h^2$ 的黎曼和来近似以下积分：\n$$\n\\mathbf{F}_{\\mathrm{IB}}(\\varepsilon,h)\\approx \\iint_{\\Omega}\\mathbf{f}(x,y)\\,\\delta_\\varepsilon(\\phi(x,y))\\,|\\nabla\\phi(x,y)|\\,dx\\,dy\n$$\n\n- 一种锐利界面切割单元近似，它将 $\\Gamma=\\{\\phi=0\\}$ 替换为一条多段线。该多段线通过在每个其顶点跨越零水平集的网格单元上对 $\\phi$ 进行线性插值得到。对于每个生成的长度为 $|s|$、中点为 $\\mathbf{m}_s$ 的线段 $s$，通过以下公式近似曲线积分：\n$$\n\\mathbf{F}_{\\mathrm{CC}}(h)\\approx \\sum_{s}\\mathbf{f}(\\mathbf{m}_s)\\,|s|.\n$$\n\n所有角度量均使用弧度。对于此人工测试，精确总力为\n$$\n\\mathbf{F}_{\\mathrm{true}}=\\int_{0}^{2\\pi}\\begin{bmatrix}\\cos(3\\theta)+\\tfrac{1}{2}\\\\ \\sin(2\\theta)\\end{bmatrix}R\\,d\\theta=\\begin{bmatrix}\\pi R\\\\ 0\\end{bmatrix}.\n$$\n\n实现一个程序，用于评估以下参数集测试套件的欧几里得范数误差，其中 $\\varepsilon=k_\\varepsilon\\,h$：\n$$\ne_{\\mathrm{IB}}=\\left\\|\\mathbf{F}_{\\mathrm{IB}}(\\varepsilon,h)-\\mathbf{F}_{\\mathrm{true}}\\right\\|_2,\\qquad\ne_{\\mathrm{CC}}=\\left\\|\\mathbf{F}_{\\mathrm{CC}}(h)-\\mathbf{F}_{\\mathrm{true}}\\right\\|_2\n$$\n\n- 测试 1：$L=1.2$，$R=0.9$，$N=33$，$(c_x,c_y)=(0.0,0.0)$，$k_\\varepsilon=1.5$。\n- 测试 2：$L=1.2$，$R=0.9$，$N=33$，$(c_x,c_y)=(0.2,-0.15)$，$k_\\varepsilon=0.5$。\n- 测试 3：$L=1.2$，$R=0.9$，$N=65$，$(c_x,c_y)=(0.2,-0.15)$，$k_\\varepsilon=1.5$。\n- 测试 4：$L=1.2$，$R=0.9$，$N=129$，$(c_x,c_y)=(0.37,0.22)$，$k_\\varepsilon=1.5$。\n\n您的程序必须生成单行输出，其中包含一个由方括号括起来的逗号分隔列表，内含 8 个浮点数结果，顺序为 $[e_{\\mathrm{IB}}^{(1)},e_{\\mathrm{CC}}^{(1)},e_{\\mathrm{IB}}^{(2)},e_{\\mathrm{CC}}^{(2)},e_{\\mathrm{IB}}^{(3)},e_{\\mathrm{CC}}^{(3)},e_{\\mathrm{IB}}^{(4)},e_{\\mathrm{CC}}^{(4)}]$，其中上标表示测试编号。每个值必须四舍五入到 6 位小数。不应打印任何其他文本。由于在此设置中所有量都是无量纲的，因此不需要物理单位。",
            "solution": "该问题要求计算矢量力密度 $\\mathbf{f}(x,y)$ 沿圆周 $\\Gamma$ 的曲线积分。需要在均匀笛卡尔网格上使用两种不同的数值方法来近似该积分：扩散界面浸入边界（IB）方法和锐利界面切割单元（CC）方法。这些方法的精度将通过将其结果与精确解析解进行比较来评估。\n\n首先，定义每个测试用例所需的参数：域半宽 $L$、圆半径 $R$、中心坐标 $(c_x, c_y)$、网格大小 $N \\times N$ 以及狄拉克-德尔塔函数宽度参数 $k_\\varepsilon$。由此可以推导出网格间距 $h = \\frac{2L}{N-1}$ 和德尔塔函数支撑半径 $\\varepsilon = k_\\varepsilon h$。计算网格由点 $(x_i, y_j)$ 组成，其中 $x_i = -L + i \\cdot h$ 且 $y_j = -L + j \\cdot h$，对于 $i, j \\in \\{0, 1, \\dots, N-1\\}$。\n\n精确总力 $\\mathbf{F}_{\\mathrm{true}}$ 由力密度沿由极角 $\\theta$ 参数化的曲线的积分给出：\n$$\n\\mathbf{F}_{\\mathrm{true}} = \\int_{0}^{2\\pi} \\mathbf{f}(\\theta) R \\, d\\theta = \\int_{0}^{2\\pi} \\begin{bmatrix} \\cos(3\\theta) + \\frac{1}{2} \\\\ \\sin(2\\theta) \\end{bmatrix} R \\, d\\theta = \\begin{bmatrix} \\pi R \\\\ 0 \\end{bmatrix}\n$$\n此结果用作比较数值近似值的基准。\n\n第一种数值方法是**浸入边界（IB）方法**。此方法将集中在曲线 $\\Gamma$ 上的奇异力表示为一个分布在曲线小邻域内的正则化力场。这是通过使用正则化的狄拉克-德尔塔函数 $\\delta_\\varepsilon(\\phi)$ 实现的，其中 $\\phi$ 是到曲线 $\\Gamma$ 的有向距离函数。然后，通过在整个计算域 $\\Omega$ 上对此正则化力场进行积分来近似总力：\n$$\n\\mathbf{F}_{\\mathrm{IB}}(\\varepsilon, h) = \\iint_{\\Omega} \\mathbf{f}(x,y) \\, \\delta_\\varepsilon(\\phi(x,y)) \\, |\\nabla\\phi(x,y)| \\, dx \\, dy\n$$\n鉴于对于有向距离函数有 $|\\nabla \\phi| = 1$，这简化了积分。我们将此积分在网格单元上离散化为黎曼和。对于每个网格点 $(x_i, y_j)$，我们计算力密度 $\\mathbf{f}(x_i, y_j)$、有向距离 $\\phi(x_i, y_j)$ 和德尔塔函数 $\\delta_\\varepsilon(\\phi(x_i, y_j))$。总力则是这些贡献值乘以单元面积 $h^2$ 后的总和：\n$$\n\\mathbf{F}_{\\mathrm{IB}} \\approx \\sum_{i=0}^{N-1} \\sum_{j=0}^{N-1} \\mathbf{f}(x_i, y_j) \\, \\delta_\\varepsilon(\\phi(x_i, y_j)) \\, h^2\n$$\n实现过程涉及在 $N \\times N$ 网格上计算这些量并执行求和。\n\n第二种数值方法是**切割单元（CC）方法**。此方法通过在每个相交的网格单元内显式地重建曲线 $\\Gamma$，从而提供几何的锐利表示。其过程如下：\n$1$. 遍历域中的每个网格单元。一个单元由四个相邻的网格点定义。\n$2$. 对每个单元，确定它是否被曲线 $\\Gamma$“切割”。这可以通过检查有向距离函数 $\\phi$ 是否在单元的顶点之间变号来检测。如果所有顶点的 $\\phi$ 值符号相同，则该单元完全位于曲线内部或外部，对曲线积分没有贡献。\n$3$. 如果一个单元被切割，则找出 $\\Gamma$ 与该单元边的交点。这是通过沿每条边对 $\\phi$ 进行线性插值来完成的。对于连接顶点 $\\mathbf{p}_1$ 和 $\\mathbf{p}_2$（其有向距离值分别为 $\\phi_1$ 和 $\\phi_2$）的边，$\\phi=0$ 处的交点 $\\mathbf{p}_{\\text{int}}$ 由下式给出：\n$$\n\\mathbf{p}_{\\text{int}} = \\frac{\\phi_2 \\mathbf{p}_1 - \\phi_1 \\mathbf{p}_2}{\\phi_2 - \\phi_1}\n$$\n$4$. 对于像圆这样的光滑曲线和足够精细的网格，每个被切割的单元将恰好有两个交点。这两点定义了一个线段 $s$，该线段近似了该单元内 $\\Gamma$ 的部分。\n$5$. 曲线积分随后通过对所有这些线段的贡献求和来近似：\n$$\n\\mathbf{F}_{\\mathrm{CC}}(h) \\approx \\sum_{s} \\mathbf{f}(\\mathbf{m}_s) \\, |s|\n$$\n其中 $|s|$ 是线段 $s$ 的长度，$\\mathbf{m}_s$ 是它的中点。\n\n对于每个测试用例，计算 $\\mathbf{F}_{\\mathrm{IB}}$ 和 $\\mathbf{F}_{\\mathrm{CC}}$。然后，误差计算为数值近似值与精确力 $\\mathbf{F}_{\\mathrm{true}}$ 之差的欧几里得范数：\n$$\ne_{\\mathrm{IB}} = \\left\\|\\mathbf{F}_{\\mathrm{IB}} - \\mathbf{F}_{\\mathrm{true}}\\right\\|_2, \\qquad e_{\\mathrm{CC}} = \\left\\|\\mathbf{F}_{\\mathrm{CC}} - \\mathbf{F}_{\\mathrm{true}}\\right\\|_2\n$$\n收集所有指定测试用例的这些误差值，并作为最终输出呈现。值得注意的是，在测试 4 中，圆略微超出了计算域 $\\Omega$。两种数值方法都严格在 $\\Omega$ 内运行，因此它们将近似计算截断曲线 $\\Gamma \\cap \\Omega$ 上的积分。比较仍然是与 $\\mathbf{F}_{\\mathrm{true}}$ 进行的，后者是整个圆 $\\Gamma$ 上的积分。这为该特定测试用例的计算误差度量引入了域截断误差。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and compares immersed-boundary and cut-cell approximations of a line integral.\n    \"\"\"\n    test_cases = [\n        # (L, R, N, (cx, cy), k_eps)\n        (1.2, 0.9, 33, (0.0, 0.0), 1.5),\n        (1.2, 0.9, 33, (0.2, -0.15), 0.5),\n        (1.2, 0.9, 65, (0.2, -0.15), 1.5),\n        (1.2, 0.9, 129, (0.37, 0.22), 1.5),\n    ]\n\n    results = []\n    for L, R, N, (cx, cy), k_eps in test_cases:\n        h = (2 * L) / (N - 1)\n        eps = k_eps * h\n        \n        # Grid setup\n        x_coords = np.linspace(-L, L, N)\n        y_coords = np.linspace(-L, L, N)\n        xx, yy = np.meshgrid(x_coords, y_coords)\n\n        # Signed distance function\n        phi = np.sqrt((xx - cx)**2 + (yy - cy)**2) - R\n        \n        # Exact force\n        F_true = np.array([np.pi * R, 0.0])\n\n        # --- Immersed Boundary (IB) Calculation ---\n        F_ib = np.zeros(2)\n        \n        # Active region for delta function\n        active_mask = np.abs(phi) = eps\n\n        phi_active = phi[active_mask]\n        xx_active = xx[active_mask]\n        yy_active = yy[active_mask]\n\n        delta_eps = (1.0 / (2.0 * eps)) * (1.0 + np.cos(np.pi * phi_active / eps))\n        \n        theta_active = np.arctan2(yy_active - cy, xx_active - cx)\n        \n        fx_active = np.cos(3 * theta_active) + 0.5\n        fy_active = np.sin(2 * theta_active)\n\n        F_ib[0] = np.sum(fx_active * delta_eps) * h**2\n        F_ib[1] = np.sum(fy_active * delta_eps) * h**2\n        \n        e_ib = np.linalg.norm(F_ib - F_true)\n        \n        # --- Cut-Cell (CC) Calculation ---\n        F_cc = np.zeros(2)\n        \n        phi_grid = phi\n\n        for j in range(N - 1):\n            for i in range(N - 1):\n                # Vertices (BL, BR, TR, TL) and their phi values\n                points = [\n                    np.array([x_coords[i], y_coords[j]]),\n                    np.array([x_coords[i+1], y_coords[j]]),\n                    np.array([x_coords[i+1], y_coords[j+1]]),\n                    np.array([x_coords[i], y_coords[j+1]])\n                ]\n                phis = [\n                    phi_grid[j, i], \n                    phi_grid[j, i+1], \n                    phi_grid[j+1, i+1], \n                    phi_grid[j+1, i]\n                ]\n\n                # If all phi values have the same sign, cell is not cut\n                if not (np.all(np.array(phis) > 0) or np.all(np.array(phis)  0)):\n                    intersections = []\n                    for k in range(4):\n                        p1, p2 = points[k], points[(k + 1) % 4]\n                        phi1, phi2 = phis[k], phis[(k + 1) % 4]\n\n                        if phi1 * phi2  0:\n                            # Linear interpolation to find the zero-crossing at phi=0\n                            p_int = (p1 * phi2 - p2 * phi1) / (phi2 - phi1)\n                            intersections.append(p_int)\n                    \n                    if len(intersections) == 2:\n                        p_a, p_b = intersections\n                        \n                        # Segment length\n                        length_s = np.linalg.norm(p_a - p_b)\n                        \n                        # Midpoint\n                        m_s = (p_a + p_b) / 2.0\n                        \n                        # Force at midpoint\n                        theta_m = np.arctan2(m_s[1] - cy, m_s[0] - cx)\n                        f_m = np.array([\n                            np.cos(3 * theta_m) + 0.5,\n                            np.sin(2 * theta_m)\n                        ])\n                        \n                        F_cc += f_m * length_s\n\n        e_cc = np.linalg.norm(F_cc - F_true)\n        \n        results.extend([e_ib, e_cc])\n\n    # Format output\n    formatted_results = [f\"{val:.6f}\" for val in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "精度不是唯一的障碍，稳定性是另一个关键挑战，尤其是在使用显式时间积分方法时。微小的切割单元会迫使整个模拟采用极小的时间步长，严重影响计算效率。本练习聚焦于一种优雅且高效的解决方案——局部时间步进（Local Time-Stepping）。你将设计一个算法，为不同大小的单元分配合适的时间步长，从而在保证稳定性的前提下，显著提升计算性能。",
            "id": "2401456",
            "problem": "考虑一维线性平流方程 $\\partial_t q + a\\,\\partial_x q = 0$，该方程定义在一个周期性区间上，并使用标称网格宽度为 $h$ 的均匀笛卡尔网格进行离散。一个浸入边界切割了部分网格，因此网格 $j$ 只有其标称体积的一小部分 $\\alpha_j \\in (0,1]$ 包含流体。在一维空间中，被切割网格的有效流体长度为 $h_j = \\alpha_j h$。假设对每个网格应用守恒的显式有限体积更新，并令 $\\nu \\in (0,1]$ 表示一个给定的库朗数。对于未切割的网格，其基础时间步长由均匀网格稳定性限制定义为 $\\Delta t_{\\text{base}} = \\nu h / |a|$。通过为每个网格分配一个整数子循环因子 $r_j \\in \\{1,2,4,8,\\dots\\}$（2的幂），引入了局部时间步进，因此网格的时间步长为 $\\Delta t_j = \\Delta t_{\\text{base}}/r_j$。稳定性要求每个网格都满足 Courant–Friedrichs–Lewy 不等式 $|a|\\,\\Delta t_j / h_j \\le \\nu$。设 $T_{\\text{end}}$ 为一个最终时间，使得 $N_{\\text{base}} = T_{\\text{end}} / \\Delta t_{\\text{base}}$ 为一个整数，这样每个未切割的网格都将精确执行 $N_{\\text{base}}$ 个基础步数。\n\n您的任务是，对于下面列出的每个测试用例，确定一组子循环因子 $r_j$ 的选择，该选择需满足稳定性不等式和2的幂次约束，最小化在 $[0,T_{\\text{end}}]$ 上的网格更新总数，并量化局部时间步进相对于统一小步长方案的效率。在这里，一次网格更新意味着将该网格按其局部时间步长推进一次。对于统一小步长方案，所有网格都以 $\\Delta t_{\\text{uniform}} = \\Delta t_{\\text{base}} / R_{\\max}$ 推进，其中 $R_{\\max} = \\max_j r_j$。\n\n对于每个测试用例，计算并报告：\n- 子循环因子列表 $[r_1,\\dots,r_M]$（整数）。\n- 局部方案执行的总更新次数 $N_{\\text{local}} = N_{\\text{base}} \\sum_{j=1}^M r_j$（整数）。\n- 统一小步长方案执行的总更新次数 $N_{\\text{uniform}} = N_{\\text{base}}\\,M\\,R_{\\max}$（整数）。\n- 效率增益 $G = N_{\\text{uniform}}/N_{\\text{local}}$，四舍五入到六位小数（浮点数）。\n- 一个布尔值，指示在您选择的 $r_j$ 下，所有网格是否满足稳定性不等式 $|a|\\,\\Delta t_j / h_j \\le \\nu$（布尔值）。\n\n使用以下测试套件。所有长度单位必须是米（$\\mathrm{m}$），速度单位是米/秒（$\\mathrm{m/s}$），时间单位是秒（$\\mathrm{s}$）。\n- 测试用例 A (理想情况)：$h = 1.0\\,\\mathrm{m}$，$a = 1.0\\,\\mathrm{m/s}$，$\\nu = 0.5$，$T_{\\text{end}} = 1.0\\,\\mathrm{s}$，$\\boldsymbol{\\alpha} = [\\,1.0,\\,0.5,\\,0.25,\\,0.125\\,]$。\n- 测试用例 B (全部未切割)：$h = 0.5\\,\\mathrm{m}$，$a = 2.0\\,\\mathrm{m/s}$，$\\nu = 0.5$，$T_{\\text{end}} = 1.0\\,\\mathrm{s}$，$\\boldsymbol{\\alpha} = [\\,1.0,\\,1.0,\\,1.0\\,]$。\n- 测试用例 C (极端切割)：$h = 1.0\\,\\mathrm{m}$，$a = 2.0\\,\\mathrm{m/s}$，$\\nu = 0.4$，$T_{\\text{end}} = 1.0\\,\\mathrm{s}$，$\\boldsymbol{\\alpha} = [\\,1.0,\\,0.2,\\,0.03\\,]$。\n- 测试用例 D (边界相等)：$h = 2.0\\,\\mathrm{m}$，$a = 1.0\\,\\mathrm{m/s}$，$\\nu = 1.0$，$T_{\\text{end}} = 4.0\\,\\mathrm{s}$，$\\boldsymbol{\\alpha} = [\\,1.0,\\,0.5,\\,0.25,\\,0.125\\,]$。\n\n您的程序必须生成单行输出，其中包含按相同顺序排列的测试用例结果，并聚合到一个外部列表中。每个测试用例的结果本身必须是一个列表，结构为 [r_list, N_local, N_uniform, G, stable_flag]。该单行输出必须是位于方括号内的逗号分隔列表，例如 \"[[...],[...],[...],[...]]\"。",
            "solution": "首先，将对所述问题进行严格的验证过程。\n\n**步骤1：提取已知条件**\n\n基本物理模型是一维线性平流方程：$\\partial_t q + a\\,\\partial_x q = 0$。\n问题通过一个均匀笛卡尔网格进行离散，网格宽度为 $h$。\n浸入边界导致了被切割网格的产生，其中网格 $j$ 的流体体积分数为 $\\alpha_j \\in (0,1]$，有效长度为 $h_j = \\alpha_j h$。\n使用守恒的显式有限体积更新。\n给定的库朗数为 $\\nu \\in (0,1]$。\n未切割网格（其中 $\\alpha_j=1$）的时间步长为 $\\Delta t_{\\text{base}} = \\nu h / |a|$。\n采用局部时间步进，每个网格 $j$ 拥有一个子循环因子 $r_j$ 和一个局部时间步长 $\\Delta t_j = \\Delta t_{\\text{base}}/r_j$。\n子循环因子被约束为2的幂：$r_j \\in \\{1, 2, 4, \\dots\\}$。\n每个网格的 Courant–Friedrichs–Lewy (CFL) 稳定性条件是 $|a|\\,\\Delta t_j / h_j \\le \\nu$。\n模拟运行至最终时间 $T_{\\text{end}}$。量 $N_{\\text{base}} = T_{\\text{end}} / \\Delta t_{\\text{base}}$ 被指定为一个整数。\n目标是选择子循环因子集合 $\\{r_j\\}$ 以最小化总网格更新次数 $N_{\\text{local}} = N_{\\text{base}} \\sum_{j=1}^M r_j$。\n定义了一个参考的统一小步长方案，其时间步长为 $\\Delta t_{\\text{uniform}} = \\Delta t_{\\text{base}} / R_{\\max}$，其中 $R_{\\max} = \\max_j r_j$。此方案的总更新次数为 $N_{\\text{uniform}} = N_{\\text{base}}\\,M\\,R_{\\max}$。\n效率增益定义为 $G = N_{\\text{uniform}}/N_{\\text{local}}$。\n每个测试用例要求的输出是：因子列表 $[r_1,\\dots,r_M]$、总更新次数 $N_{\\text{local}}$ 和 $N_{\\text{uniform}}$、增益 $G$ 以及一个布尔稳定性标志。\n测试用例为 $h$、$a$、$\\nu$、$T_{\\text{end}}$ 和向量 $\\boldsymbol{\\alpha}$ 提供了具体值。\n\n**步骤2：问题陈述的验证**\n\n该问题具有科学依据，基于标准的平流方程和成熟的有限体积方法，并结合局部时间步进以处理浸入边界情境中的小网格问题。CFL 条件是显式数值方法的一个基本原理。该问题是适定的，提出了一个具有明确目标函数（最小化 $N_{\\text{local}}$）和对变量 ($r_j$) 有明确约束的约束优化问题。语言客观且数学上精确。设定是自洽的，没有矛盾。所提供的数据量纲一致且物理上合理。该问题不违反任何指定的无效标准。\n\n**步骤3：结论与行动**\n\n该问题被认为是有效的。将构建一个解决方案。\n\n**最优子循环因子的推导**\n\n目标是最小化在模拟时间 $[0, T_{\\text{end}}]$ 内的总网格更新次数，其表达式为：\n$$\nN_{\\text{local}} = N_{\\text{base}} \\sum_{j=1}^M r_j\n$$\n由于对于任何给定的测试用例，$N_{\\text{base}}$ 是一个正常数，因此最小化 $N_{\\text{local}}$ 等同于最小化子循环因子的总和 $\\sum_{j=1}^M r_j$。由于每个 $r_j$ 的选择与其他因子相互独立，因此通过为每个网格 $j$ 选择最小的可能有效 $r_j$ 值，可以使总和最小化。\n\n对每个 $r_j$ 的约束是：\n1. $r_j$ 必须是2的幂，即对于某个非负整数 $k$，$r_j = 2^k$。\n2. $r_j$ 必须满足局部 CFL 稳定性不等式：$|a|\\,\\Delta t_j / h_j \\le \\nu$。\n\n我们通过代入 $\\Delta t_j$ 和 $h_j$ 的定义来分析稳定性不等式：\n$$\n\\frac{|a|}{h_j} \\Delta t_j = \\frac{|a|}{\\alpha_j h} \\left( \\frac{\\Delta t_{\\text{base}}}{r_j} \\right) \\le \\nu\n$$\n现在，代入 $\\Delta t_{\\text{base}} = \\nu h / |a|$ 的定义：\n$$\n\\frac{|a|}{\\alpha_j h} \\left( \\frac{1}{r_j} \\frac{\\nu h}{|a|} \\right) \\le \\nu\n$$\n假设 $a \\ne 0$ 且 $h, \\nu  0$，我们可以简化表达式：\n$$\n\\frac{1}{\\alpha_j r_j} \\le 1\n$$\n由于 $\\alpha_j  0$ 且 $r_j$ 必须为正，这等价于：\n$$\nr_j \\ge \\frac{1}{\\alpha_j}\n$$\n将此与2的幂约束相结合，网格 $j$ 的最优子循环因子 $r_j$是大于或等于 $1/\\alpha_j$ 的最小的2的整数次幂。\n\n这可以形式上地表达。设所需的最小值为 $s_j = 1/\\alpha_j$。我们寻求最小的非负整数 $k$，使得 $2^k \\ge s_j$。取以2为底的对数，我们发现 $k \\ge \\log_2(s_j)$。由于 $k$ 必须是整数，因此最小的这样的 $k$ 是 $\\lceil \\log_2(s_j) \\rceil$。因此，网格 $j$ 的最优子循环因子是：\n$$\nr_j = 2^{\\lceil \\log_2(1/\\alpha_j) \\rceil}\n$$\n对于未切割的网格，$\\alpha_j=1$，这得到 $1/\\alpha_j=1$。由于 $\\log_2(1)=0$，我们有 $\\lceil 0 \\rceil = 0$ 和 $r_j = 2^0 = 1$，这是正确的。这对应于一个网格采用基础时间步长 $\\Delta t_{\\text{base}}$。对于被切割的网格，$\\alpha_j  1$，这要求 $r_j  1$。\n\n**性能指标计算与稳定性检查**\n\n一旦确定了给定测试用例的最优因子列表 $\\boldsymbol{r} = [r_1, \\dots, r_M]$，剩余的量按如下方式计算：\n1. 最大子循环因子为 $R_{\\max} = \\max_j r_j$。\n2. 基础步数为 $N_{\\text{base}} = T_{\\text{end}} / \\Delta t_{\\text{base}} = T_{\\text{end}} / (\\nu h / |a|)$。\n3. 局部时间步进方案的总更新次数为 $N_{\\text{local}} = N_{\\text{base}} \\sum_{j=1}^M r_j$。\n4. 统一小步长方案的总更新次数为 $N_{\\text{uniform}} = N_{\\text{base}} M R_{\\max}$。\n5. 效率增益为 $G = N_{\\text{uniform}} / N_{\\text{local}}$。\n6. 通过检查所有网格 $j=1,\\dots,M$ 是否满足 CFL 条件 $|a|\\,\\Delta t_j / h_j \\le \\nu$ 来确定布尔稳定性标志。根据我们的构造方法，$r_j \\ge 1/\\alpha_j$，这等价于 CFL 条件被满足。因此，此标志将始终为真。\n\n该算法将应用于每个测试用例以产生所需的结果。最终的实现将执行这些计算并按规定格式化输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the local time stepping optimization problem for a series of test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case A: h, a, nu, T_end, alpha_list\n        (1.0, 1.0, 0.5, 1.0, [1.0, 0.5, 0.25, 0.125]),\n        # Test Case B\n        (0.5, 2.0, 0.5, 1.0, [1.0, 1.0, 1.0]),\n        # Test Case C\n        (1.0, 2.0, 0.4, 1.0, [1.0, 0.2, 0.03]),\n        # Test Case D\n        (2.0, 1.0, 1.0, 4.0, [1.0, 0.5, 0.25, 0.125]),\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        h, a, nu, T_end, alpha_list = case\n        \n        # Determine the optimal subcycling factor r_j for each cell\n        r_list = []\n        for alpha_j in alpha_list:\n            # The stability condition r_j >= 1/alpha_j must be satisfied.\n            # We want the smallest power of two that meets this condition.\n            min_r_val = 1.0 / alpha_j\n            \n            # Efficiently find the smallest power of two >= min_r_val\n            # Can be found with logarithms: r = 2**ceil(log2(min_r_val))\n            # or with a simple loop.\n            r_j = 1\n            while r_j  min_r_val:\n                r_j *= 2\n            r_list.append(int(r_j))\n            \n        # Calculate performance metrics\n        M = len(alpha_list)\n        abs_a = abs(a)\n        \n        # Base time step and number of base steps\n        delta_t_base = nu * h / abs_a\n        N_base = int(round(T_end / delta_t_base))\n\n        # Total updates for local and uniform schemes\n        sum_r = sum(r_list)\n        N_local = N_base * sum_r\n        \n        R_max = max(r_list) if r_list else 1\n        N_uniform = N_base * M * R_max\n        \n        # Efficiency gain\n        G = N_uniform / N_local if N_local > 0 else 0.0\n        G_rounded = round(G, 6)\n        \n        # Verify stability for the chosen r_j\n        stable_flag = True\n        for r_j, alpha_j in zip(r_list, alpha_list):\n            h_j = alpha_j * h\n            delta_t_j = delta_t_base / r_j\n            cfl_val = abs_a * delta_t_j / h_j\n            # Use a small tolerance for floating point comparison\n            if cfl_val > nu + 1e-9:\n                stable_flag = False\n                break\n                \n        # Aggregate results for this case\n        case_result = [r_list, int(N_local), int(N_uniform), G_rounded, stable_flag]\n        all_results.append(case_result)\n\n    # Convert each element of the result lists to a string for join\n    def format_results(results):\n        formatted_list = []\n        for item in results:\n            if isinstance(item, list):\n                formatted_list.append(f\"[{','.join(map(str, item))}]\")\n            elif isinstance(item, float):\n                # Ensure float has required decimal places in string representation\n                formatted_list.append(f\"{item:.6f}\")\n            else:\n                 formatted_list.append(str(item))\n        return f\"[{','.join(formatted_list)}]\"\n\n    # Final print statement in the exact required format.\n    final_output_str = f\"[{','.join(map(format_results, all_results))}]\"\n    print(final_output_str)\n\nsolve()\n```"
        }
    ]
}