{
    "hands_on_practices": [
        {
            "introduction": "A cornerstone of any finite element or isogeometric method is the assembly of system matrices, which involves integrating products of basis functions. This exercise  challenges you to determine the precise numerical integration scheme required for exactness in IGA. Understanding this fundamental relationship between spline degree and quadrature rules is essential for writing efficient and accurate IGA code.",
            "id": "2405752",
            "problem": "In the context of Isogeometric Analysis (IGA), consider a $1$D model problem on the parametric domain $\\xi \\in [0,1]$ discretized using a B-spline basis $\\{B_{i}^{p}(\\xi)\\}$ of degree $p$ defined on an open, nondecreasing knot vector with simple internal knots. Focus on a single nonzero knot span $[\\xi_{a},\\xi_{b}] \\subset [0,1]$. Assume the physical domain mapping is the identity, i.e., $x=\\xi$, so the Jacobian is $1$, and that the mass density $\\rho$ is constant on $[\\xi_{a},\\xi_{b}]$. The element mass matrix over this knot span has entries\n$$\nM_{ij}^{(e)} \\;=\\; \\int_{\\xi_{a}}^{\\xi_{b}} \\rho\\, B_{i}^{p}(\\xi)\\, B_{j}^{p}(\\xi)\\, \\mathrm{d}\\xi.\n$$\nUsing Gauss–Legendre quadrature with $n$ points per knot span to assemble $M_{ij}^{(e)}$ exactly for every pair of indices $(i,j)$ whose supports intersect $[\\xi_{a},\\xi_{b}]$, determine the minimum number of Gauss points $n$ per knot span required for exact integration as a function of the spline degree $p$. Provide your answer as a single closed-form expression in terms of $p$.",
            "solution": "The problem requires the determination of the minimum number of Gauss–Legendre quadrature points, denoted by $n$, needed for the exact evaluation of the element mass matrix entries $M_{ij}^{(e)}$ over a single knot span $[\\xi_{a},\\xi_{b}]$. The formula for these entries is given by\n$$\nM_{ij}^{(e)} = \\int_{\\xi_{a}}^{\\xi_{b}} \\rho\\, B_{i}^{p}(\\xi)\\, B_{j}^{p}(\\xi)\\, \\mathrm{d}\\xi\n$$\nwhere $\\rho$ is a constant mass density and $B_{i}^{p}(\\xi)$ are B-spline basis functions of degree $p$.\n\nThe core of the problem lies in analyzing the integrand of this integral. The mass density $\\rho$ is stated to be constant. The functions $B_{i}^{p}(\\xi)$ are B-spline basis functions of degree $p$. A key property of B-splines is that on any given non-zero knot span, such as $[\\xi_{a}, \\xi_{b}]$, each basis function $B_{i}^{p}(\\xi)$ that has support on this span is a single polynomial of degree exactly $p$.\n\nThe integrand is the product of three terms: $\\rho$, $B_{i}^{p}(\\xi)$, and $B_{j}^{p}(\\xi)$. Since $\\rho$ is a constant (a polynomial of degree $0$), the degree of the entire integrand, let's call it $f(\\xi) = \\rho\\, B_{i}^{p}(\\xi)\\, B_{j}^{p}(\\xi)$, is determined by the product of the two B-spline basis functions. The degree of a product of polynomials is the sum of their individual degrees.\nTherefore, the degree of the polynomial $B_{i}^{p}(\\xi)\\, B_{j}^{p}(\\xi)$ on the interval $[\\xi_{a}, \\xi_{b}]$ is $p + p = 2p$. The integrand $f(\\xi)$ is thus a polynomial of degree $2p$.\n\nThe problem specifies the use of Gauss–Legendre quadrature for numerical integration. A fundamental theorem of numerical analysis states that a Gauss–Legendre quadrature rule with $n$ integration points can exactly integrate any polynomial of degree up to, and including, $2n-1$.\n\nFor the integral of $M_{ij}^{(e)}$ to be computed exactly, the degree of the quadrature rule must be sufficient to handle the degree of the integrand. This leads to the following inequality:\n$$\n2n-1 \\ge \\deg(f(\\xi))\n$$\nSubstituting the degree of our integrand, we have:\n$$\n2n-1 \\ge 2p\n$$\nWe must find the minimum integer value of $n$ that satisfies this condition. Rearranging the inequality to solve for $n$:\n$$\n2n \\ge 2p + 1\n$$\n$$\nn \\ge p + \\frac{1}{2}\n$$\nSince the number of quadrature points $n$ must be an integer, we must take the smallest integer value that is greater than or equal to $p + \\frac{1}{2}$. This is equivalent to taking the ceiling of $p + 0.5$.\n$$\nn_{\\min} = \\lceil p + 0.5 \\rceil\n$$\nGiven that the spline degree $p$ is an integer (e.g., $1$, $2$, $3$, ...), the quantity $p+0.5$ is never an integer. Therefore, the ceiling function will always round up to the next integer.\n$$\nn_{\\min} = p + 1\n$$\nTo verify this result: if we choose $n = p+1$ points, the Gauss-Legendre rule will exactly integrate polynomials of degree up to $2(p+1) - 1 = 2p+2-1=2p+1$. Since our integrand is a polynomial of degree $2p$, and $2p+1 \\ge 2p$, this number of points is sufficient. If we were to choose $n=p$ points, the rule would only guarantee exactness for polynomials of degree up to $2p-1$, which is insufficient for a polynomial of degree $2p$.\n\nThus, the minimum number of Gauss points required per knot span for the exact assembly of the mass matrix is $p+1$. This result is independent of the specific indices $i$ and $j$, as long as their corresponding basis functions have overlapping support on the knot span in question, and is also independent of the constant density $\\rho$ and the identity mapping.",
            "answer": "$$\\boxed{p+1}$$"
        },
        {
            "introduction": "Real-world engineering problems often involve sharp material interfaces, which pose a challenge for the inherently smooth basis functions of Isogeometric Analysis. This practice problem  explores the consequences of naively approximating a discontinuous field, leading to the well-known Gibbs phenomenon. By comparing different strategies, you will gain insight into robust methods for handling such discontinuities, a critical skill for practical modeling.",
            "id": "2405715",
            "problem": "Consider the one-dimensional diffusion problem on the physical domain $[0,1]$: find $u:[0,1]\\to\\mathbb{R}$ such that\n$$\n-\\frac{\\mathrm{d}}{\\mathrm{d}x}\\Big(a(x)\\,\\frac{\\mathrm{d}u}{\\mathrm{d}x}(x)\\Big)=f(x)\\quad\\text{in }(0,1),\\qquad u(0)=0,\\quad u(1)=1,\n$$\nwith body force $f(x)=0$ and a discontinuous, positive material property\n$$\na(x)=\\begin{cases}\na_1, x\\xi,\\\\\na_2, x\\xi,\n\\end{cases}\n$$\nwhere $a_10$, $a_20$, and the jump location $\\xi\\in(0,1)$ is not a knot of the discretization described below. In an Isogeometric Analysis (IGA) discretization, the trial and test spaces are chosen as a univariate B-spline space of polynomial degree $p\\ge 2$ with an open, uniform knot vector over $[0,1]$ and maximum inter-element continuity $C^{p-1}$. Assume a standard Galerkin method with bilinear form\n$$\nB(u,v)=\\int_0^1 a(x)\\,u'(x)\\,v'(x)\\,\\mathrm{d}x,\n$$\nand the IGA approximations $u_h$ and $v_h$ taken from the aforementioned B-spline space.\n\nIn practice, two assembly variants are considered:\n\n(i) Coefficient projection: the discontinuous coefficient $a(x)$ is replaced by its $L^2$-projection $a_h\\in S_p$ onto the same $C^{p-1}$ B-spline space $S_p$, defined by\n$$\n\\int_0^1\\big(a(x)-a_h(x)\\big)\\,w(x)\\,\\mathrm{d}x=0\\quad\\forall w\\in S_p,\n$$\nand the bilinear form is assembled with $a_h(x)$.\n\n(ii) Interface-aware integration: the exact discontinuous $a(x)$ is used under the integral sign by splitting quadrature at $x=\\xi$ inside any cut element (no projection of $a$), while keeping the same smooth trial and test spaces for $u_h$ and $v_h$.\n\nThe term “Gibbs phenomenon” refers here to spurious oscillatory overshoots and undershoots near $x=\\xi$ when a discontinuous function is approximated by a globally smooth expansion.\n\nWhich of the following statements are correct in this setting?\n\nA. Under variant (i), the projected coefficient $a_h(x)$ typically exhibits overshoot and undershoot near $x=\\xi$ relative to the true values $a_1$ and $a_2$, and this can induce localized oscillations in the computed flux $q_h(x)=a_h(x)\\,u_h'(x)$ near $x=\\xi$.\n\nB. If one performs uniform $h$-refinement of the same $C^{p-1}$ space without inserting a knot at $x=\\xi$, then the overshoot in the maximum norm $\\|a-a_h\\|_{L^\\infty(0,1)}$ is completely eliminated as $h\\to 0$.\n\nC. If one inserts a knot at $x=\\xi$ with multiplicity $p$ (reducing the trial/test space continuity to $C^0$ at $x=\\xi$) and computes $a_h$ as a piecewise representation that is constant on each knot span (so that a jump at $x=\\xi$ is allowed), then the Gibbs-type overshoot in $a_h$ is removed.\n\nD. At fixed knot locations (with $\\xi$ not a knot) and fixed mesh size, increasing the spline degree $p$ while keeping the inter-element continuity $C^{p-1}$ necessarily reduces the amplitude of the overshoot in the projected coefficient $a_h$.\n\nE. Under variant (ii), the assembly employs the exact discontinuous $a(x)$ by quadrature splitting, so there is no oscillatory approximation of $a$ near $x=\\xi$, while the smoothness of the IGA solution space for $u_h$ is unchanged.\n\nSelect all that apply.",
            "solution": "The problem statement has been analyzed and is determined to be valid. It presents a clear, scientifically grounded, and well-posed problem in computational science, specifically concerning Isogeometric Analysis for a diffusion problem with a discontinuous coefficient. The problem is suitable for rigorous analysis. I will proceed to derive the solution.\n\nThe governing equation is a one-dimensional, steady-state diffusion equation, $-\\frac{\\mathrm{d}}{\\mathrm{d}x}\\big(a(x)\\,\\frac{\\mathrm{d}u}{\\mathrm{d}x}(x)\\big)=0$, on the domain $[0,1]$ with Dirichlet boundary conditions $u(0)=0$ and $u(1)=1$. The coefficient $a(x)$ is a piecewise constant function with a jump discontinuity at $x=\\xi \\in (0,1)$, where $a(x)=a_1$ for $x\\xi$ and $a(x)=a_2$ for $x\\xi$.\nThe exact solution $u(x)$ for this problem is continuous and piecewise linear, with a discontinuous first derivative (a \"kink\") at $x=\\xi$. Specifically, $u(x) \\in H^1(0,1)$ but $u(x) \\notin H^2(0,1)$. The numerical approximation $u_h$ is sought in a B-spline space $S_p$ of degree $p \\ge 2$ with maximal inter-element continuity $C^{p-1}$. Since the discontinuity location $\\xi$ is not a knot, any function in $S_p$ is $C^{p-1}$ smooth across the entire domain, including at $x=\\xi$.\n\nWe must evaluate each statement based on these facts.\n\n**Analysis of Option A**\nThis option describes variant (i), where the discontinuous coefficient $a(x)$ is first approximated by its $L^2$-projection $a_h(x)$ onto the smooth spline space $S_p$. An $L^2$-projection of a discontinuous function onto a space of globally smooth functions (in this case, $C^{p-1}$ continuous splines where $p-1 \\ge 1$) is a canonical example leading to the Gibbs phenomenon. This phenomenon is characterized by spurious oscillations, including overshooting and undershooting the true values, in the vicinity of the discontinuity. Thus, the projected coefficient $a_h(x)$ will indeed exhibit such oscillations near $x=\\xi$.\n\nThe computed flux in this variant is $q_h(x) = a_h(x)u_h'(x)$. The numerical solution for the gradient, $u_h'(x)$, is a smooth function in the space of splines of degree $p-1$ with $C^{p-2}$ continuity. Near the interface $x=\\xi$, $u_h'(x)$ will be some smooth, non-zero function. When this is multiplied by the oscillatory approximation $a_h(x)$, the resulting flux $q_h(x)$ will inherit these oscillations. The exact flux for this problem is constant, meaning these oscillations in $q_h(x)$ are purely numerical artifacts. Therefore, the statement is a correct description of the behavior of this numerical scheme.\n\nVerdict on A: **Correct**.\n\n**Analysis of Option B**\nThis option claims that uniform $h$-refinement (i.e., making the mesh finer by letting the knot spacing $h \\to 0$) will cause the maximum error in the coefficient approximation, $\\|a-a_h\\|_{L^\\infty(0,1)}$, to converge to zero. This is a defining fallacy regarding the Gibbs phenomenon. While the approximation $a_h$ does converge to $a$ in the $L^2$ norm, it does not converge in the $L^\\infty$ norm (uniformly). The magnitude of the primary overshoot near the discontinuity remains a fixed percentage of the jump height $|a_2 - a_1|$ and does not diminish as $h \\to 0$. The oscillations simply become confined to a smaller interval around $\\xi$. The statement is therefore factually incorrect.\n\nVerdict on B: **Incorrect**.\n\n**Analysis of Option C**\nThis option proposes a different strategy. First, it suggests modifying the spline space for the solution $u_h$ by inserting a knot of multiplicity $p$ at the location of the discontinuity, $x=\\xi$. For a B-spline of degree $p$, this reduces the continuity at that knot to $C^{p-p} = C^0$. This allows the approximation $u_h$ to form a kink (a continuous function with a discontinuous derivative) at $x=\\xi$, which correctly mimics the regularity of the true solution. Second, it proposes to represent the coefficient $a(x)$ as a piecewise constant function on the elements of this new mesh. Since $x=\\xi$ is now a knot, it marks a boundary between elements. A piecewise constant function can represent the original piecewise constant coefficient $a(x)$ exactly. That is, we can set $a_h(x) = a(x)$ for all $x$. This eliminates any approximation error in the coefficient, and thus there is no Gibbs phenomenon, no overshoot, and no undershoot. This is a standard and sound technique in finite element and isogeometric analysis to handle material interfaces.\n\nVerdict on C: **Correct**.\n\n**Analysis of Option D**\nThis option claims that, for a fixed mesh, increasing the spline degree $p$ (while maintaining $C^{p-1}$ continuity) *necessarily* reduces the overshoot amplitude in $a_h$. This is incorrect. This procedure is known as $p$-refinement. When applied to a problem with a discontinuity that is not aligned with the mesh, $p$-refinement with high-continuity basis functions can perform poorly. The approximation of the discontinuous function $a(x)$ by smoother and higher-degree polynomials does not guarantee better point-wise behavior at the jump. The amplitude of the Gibbs oscillations is not guaranteed to decrease monotonically with $p$; it can fluctuate and even increase. The claim is too strong and is not supported by approximation theory for splines.\n\nVerdict on D: **Incorrect**.\n\n**Analysis of Option E**\nThis option correctly describes variant (ii), the \"interface-aware integration\" method. In this method, the integral for the bilinear form, $B(u_h, v_h) = \\int_0^1 a(x) u_h'(x) v_h'(x) \\mathrm{d}x$, is computed using numerical quadrature that is aware of the discontinuity. Specifically, for any element that is \"cut\" by the interface at $x=\\xi$, the integral over that element is split into two sub-integrals, one from the element start to $\\xi$ and the other from $\\xi$ to the element end. This allows the exact values of $a_1$ and $a_2$ to be used in their respective sub-domains. Consequently, no oscillatory approximation of $a(x)$ (like $a_h(x)$ from variant (i)) is ever constructed. The statement also correctly notes that the approximation space for the solution, $S_p$, remains the original globally $C^{p-1}$ smooth space. The entire statement is a factually accurate description of the procedure.\n\nVerdict on E: **Correct**.",
            "answer": "$$\\boxed{ACE}$$"
        },
        {
            "introduction": "After obtaining a numerical solution, a crucial question arises: how accurate is it? This exercise  introduces a practical method for *a posteriori* error estimation in IGA by examining the jumps in the higher derivatives of the solution. Calculating these local error indicators is the first step toward adaptive mesh refinement, an advanced technique that automatically refines the mesh only where needed to improve efficiency and accuracy.",
            "id": "2405738",
            "problem": "You are given a one-dimensional setting in Isogeometric Analysis (IGA) where the trial space consists of piecewise cubic, globally continuously differentiable splines (that is, $C^1$ splines) on a partition of the interval $[0,1]$. For a piecewise cubic function $u(x)$ of class $C^1$, the third derivative $u^{(3)}(x)$ is constant on each element and may be discontinuous at element interfaces. Define a local, jump-based error indicator per element using only the jumps of $u^{(3)}(x)$ across element boundaries.\n\nLet the mesh be defined by nodes $x_0, x_1, \\dots, x_N$ with $0 = x_0  x_1  \\dots  x_N = 1$. For element $e \\in \\{1, \\dots, N\\}$, define $E_e = [x_{e-1}, x_e]$ and element size $h_e = x_e - x_{e-1}$. On each element $E_e$, the third derivative is constant and denoted $g_e = u^{(3)}|_{E_e}$. At an internal node $x_i$ with $i \\in \\{1, \\dots, N-1\\}$, define the jump of the third derivative by\n$$\n[u^{(3)}]_{x_i} = \\lim_{x \\to x_i^+} u^{(3)}(x) - \\lim_{x \\to x_i^-} u^{(3)}(x) = g_{i+1} - g_i.\n$$\nAt the boundary nodes $x_0$ and $x_N$, set the jump to zero:\n$$\n[u^{(3)}]_{x_0} = 0, \\quad [u^{(3)}]_{x_N} = 0.\n$$\nDefine the local indicator for element $e$ by\n$$\n\\eta_e = \\sqrt{h_e} \\, \\sqrt{ \\left( [u^{(3)}]_{x_{e-1}} \\right)^2 + \\left( [u^{(3)}]_{x_e} \\right)^2 }.\n$$\n\nYour task is to compute the list of local indicators $\\eta_e$ for each element for each of the following test cases. Each test case is fully specified by its node coordinates and the per-element constants $g_e$ for $u^{(3)}$.\n\nTest Suite (each case gives $(x_0, \\dots, x_N)$ and $(g_1, \\dots, g_N)$):\n- Case $1$ (uniform mesh, nontrivial internal jumps): nodes $[0, 0.25, 0.5, 0.75, 1]$, values $[2, 2, 5, 1]$.\n- Case $2$ (uniform mesh, no jumps): nodes $[0, \\tfrac{1}{3}, \\tfrac{2}{3}, 1]$, values $[-1.2, -1.2, -1.2]$.\n- Case $3$ (nonuniform mesh, large contrast): nodes $[0, 0.1, 0.4, 1]$, values $[0, 7, -7]$.\n- Case $4$ (single element, boundary-only): nodes $[0, 1]$, values $[3.14]$.\n\nAll computations are dimensionless; no physical units are required. Angles are not involved. The result for each test case is the list $[\\eta_1, \\dots, \\eta_N]$ of floats.\n\nFinal Output Format: Your program should produce a single line of output containing the results for the four cases as a list of lists, where each inner list corresponds to one test case, in the same order as specified above. Each floating-point number must be rounded to $6$ decimal places. The printed format must have no spaces. For example: \n$$\n[[0.000000,1.500000,2.500000,2.000000],[0.000000,0.000000,0.000000],[2.213594,8.573214,10.844353],[0.000000]]\n$$",
            "solution": "The problem presented is scientifically grounded and well-posed, falling squarely within the domain of a posteriori error estimation for the numerical solution of differential equations. Specifically, it concerns the computation of a local error indicator for one-dimensional, $C^1$-continuous cubic splines, a common scenario in Isogeometric Analysis (IGA). The problem is entirely formal and procedural, requiring the direct application of the provided mathematical definitions. We will proceed with a systematic exposition of the computational method.\n\nLet the domain of interest be the interval $[0,1]$. This domain is partitioned by a mesh defined by a set of $N+1$ nodes, $x_0, x_1, \\dots, x_N$, such that $0 = x_0  x_1  \\dots  x_N = 1$. This partition creates $N$ elements, where the $e$-th element is the subinterval $E_e = [x_{e-1}, x_e]$ for $e \\in \\{1, \\dots, N\\}$. The length, or size, of element $E_e$ is given by $h_e = x_e - x_{e-1}$.\n\nThe approximate solution, $u(x)$, is a piecewise cubic spline that is globally continuously differentiable (of class $C^1$). This implies that its third derivative, $u^{(3)}(x)$, is a piecewise constant function. The problem provides these constant values for each element, denoted as $g_e = u^{(3)}|_{E_e}$.\n\nThe error indicator is based on the discontinuities, or jumps, of this third derivative at the element interfaces (the nodes). At any internal node $x_i$ for $i \\in \\{1, \\dots, N-1\\}$, the jump is defined as the difference between the value of $u^{(3)}(x)$ to the right and to the left of the node:\n$$\n[u^{(3)}]_{x_i} = \\lim_{x \\to x_i^+} u^{(3)}(x) - \\lim_{x \\to x_i^-} u^{(3)}(x) = g_{i+1} - g_i.\n$$\nAs per the problem statement, the jumps at the boundary nodes $x_0$ and $x_N$ are defined to be zero:\n$$\n[u^{(3)}]_{x_0} = 0, \\quad [u^{(3)}]_{x_N} = 0.\n$$\n\nWith these definitions, the local error indicator $\\eta_e$ for an element $E_e$ is constructed from its size $h_e$ and the jumps at its two boundary nodes, $x_{e-1}$ and $x_e$. The explicit formula is:\n$$\n\\eta_e = \\sqrt{h_e} \\sqrt{ \\left( [u^{(3)}]_{x_{e-1}} \\right)^2 + \\left( [u^{(3)}]_{x_e} \\right)^2 }.\n$$\n\nTo compute the indicators $\\eta_e$ for the provided test cases, we implement a clear, step-by-step algorithm:\n1.  From the input data for a test case, we identify the node coordinates $(x_0, \\dots, x_N)$ and the piecewise constant third derivative values $(g_1, \\dots, g_N)$. The number of elements is $N$.\n2.  We calculate the vector of element sizes, $\\mathbf{h}$, of length $N$, where the component $h_e$ corresponds to the size of element $E_e$.\n3.  We compute the vector of nodal jumps, $\\mathbf{J}$, of length $N+1$. The components $J_i = [u^{(3)}]_{x_i}$ for $i \\in \\{0, \\dots, N\\}$ are populated as follows:\n    - The boundary components are set to zero: $J_0 = 0$ and $J_N = 0$.\n    - The internal components are calculated from the derivative values: $J_i = g_{i+1} - g_i$ for $i \\in \\{1, \\dots, N-1\\}$.\n    - For a single-element mesh ($N=1$), there are no internal nodes, and the jump vector is simply $\\mathbf{J} = [0, 0]$.\n4.  Finally, we compute the vector of local indicators, $\\boldsymbol{\\eta}$, of length $N$. For each element $E_e$ (where $e \\in \\{1, \\dots, N\\}$), we apply the formula using the pre-computed sizes and jumps:\n    $$\n    \\eta_e = \\sqrt{h_e} \\sqrt{ (J_{e-1})^2 + (J_e)^2 }.\n    $$\nThe Python program provided in the final answer executes this well-defined algorithm for each test case, producing the required list of local indicators.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes local, jump-based error indicators for C^1 cubic splines\n    for a series of test cases in a 1D setting.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (list of node coordinates, list of g_e values).\n    test_cases = [\n        ([0, 0.25, 0.5, 0.75, 1], [2, 2, 5, 1]),\n        ([0, 1/3, 2/3, 1], [-1.2, -1.2, -1.2]),\n        ([0, 0.1, 0.4, 1], [0, 7, -7]),\n        ([0, 1], [3.14])\n    ]\n\n    all_results = []\n    for nodes_list, g_values_list in test_cases:\n        nodes = np.array(nodes_list, dtype=np.float64)\n        g_values = np.array(g_values_list, dtype=np.float64)\n\n        # N is the number of elements\n        N = len(g_values)\n        \n        # Calculate element sizes h_e = x_e - x_{e-1}\n        # h has N elements. h[i] corresponds to h_{i+1}.\n        h = np.diff(nodes)\n        \n        # Calculate jumps of the third derivative at each node.\n        # The jumps array has N+1 elements, for nodes x_0 to x_N.\n        # jumps[i] corresponds to the jump at node x_i.\n        jumps = np.zeros(N + 1, dtype=np.float64)\n        \n        # Jumps at internal nodes x_i for i=1,...,N-1\n        # Formula: [u^(3)]_{x_i} = g_{i+1} - g_i\n        # In 0-based indexing for g_values array:\n        # g_i corresponds to g_values[i-1]\n        # g_{i+1} corresponds to g_values[i]\n        # So jump at node x_i is g_values[i] - g_values[i-1].\n        for i in range(1, N):\n            jumps[i] = g_values[i] - g_values[i-1]\n        \n        # Jumps at boundary nodes x_0 and x_N are 0, which is the default\n        # value from np.zeros.\n        \n        # Calculate local indicators eta_e for each element e=1,...,N.\n        # The indicators array has N elements.\n        # Formula: eta_e = sqrt(h_e) * sqrt(([u^(3)]_{x_{e-1}})^2 + ([u^(3)]_{x_e})^2)\n        # In 0-based indexing:\n        # e_idx from 0 to N-1 refers to element E_{e_idx+1}.\n        # h_{e_idx+1} is h[e_idx].\n        # Jumps at its ends (x_{e_idx}, x_{e_idx+1}) are jumps[e_idx] and jumps[e_idx+1].\n        indicators = []\n        for e_idx in range(N):\n            h_e = h[e_idx]\n            jump_left = jumps[e_idx]\n            jump_right = jumps[e_idx+1]\n            eta_e = np.sqrt(h_e) * np.sqrt(jump_left**2 + jump_right**2)\n            indicators.append(eta_e)\n            \n        all_results.append(indicators)\n\n    # Format the final output string as specified.\n    # e.g., [[0.000000,1.500000],[...]] without spaces.\n    formatted_inner_lists = []\n    for res_list in all_results:\n        formatted_numbers = [f\"{num:.6f}\" for num in res_list]\n        formatted_inner_lists.append(f\"[{','.join(formatted_numbers)}]\")\n    \n    final_output = f\"[{','.join(formatted_inner_lists)}]\"\n\n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}