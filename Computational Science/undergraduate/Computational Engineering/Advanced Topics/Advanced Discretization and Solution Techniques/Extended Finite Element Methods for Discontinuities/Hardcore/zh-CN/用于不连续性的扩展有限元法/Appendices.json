{
    "hands_on_practices": [
        {
            "introduction": "在应用特殊的富集函数之前，我们必须首先确定网格中的哪些单元受到了不连续性的影响。本练习将指导您创建一个稳健的算法，以自动将单元分类为标准单元、被裂纹体切割的单元（需要亥维赛富集）或包含裂纹尖端的单元（需要尖端富集）。这种分类是任何 XFEM 模拟中至关重要的第一步，确保计算资源仅集中在需要的地方 。",
            "id": "2551522",
            "problem": "给定一个二维凸四边形有限元，其节点按逆时针顺序索引为 $i \\in \\{0,1,2,3\\}$。设 $\\phi(\\mathbf{x})$ 和 $\\psi(\\mathbf{x})$ 是用于表示裂纹的两个水平集场：裂纹面是零等值线 $\\{\\mathbf{x} : \\phi(\\mathbf{x}) = 0\\}$，裂纹尖端是零等值线的交集 $\\{\\mathbf{x} : \\phi(\\mathbf{x}) = 0\\} \\cap \\{\\mathbf{x} : \\psi(\\mathbf{x}) = 0\\}$。假设在每个单元内，水平集沿每条边根据其节点值进行线性插值。您的任务是推导、论证并实现一个稳健的分类准则，该准则将每个单元分配到扩展有限元法中使用的三个不相交集合之一：尖端增强、Heaviside增强或标准。\n\n基本依据与可接受的假设：\n- 扩展有限元法 (XFEM) 采用单位分解法 (PUM) 来增强不连续区域附近的近似空间。裂纹内部通过Heaviside函数增强来表示，而裂纹尖端则通过反映渐近近尖端场的函数来表示。\n- 在直边上线性插值的标量场，如果其节点值符号相反，则该场是严格单调的，因此在该边上恰好有一个零点。如果两个节点值符号相同且非零，则在该边上没有零点。如果一个节点值为零，则零等值线穿过该节点。这些陈述与单元的各向异性无关。\n- 设 $\\tau$ 表示一个小的容差，$\\tau = 10^{-12}$，用于判断浮点数值是否可被视为零。\n\n任务1：基于这些依据，仅使用节点坐标 $\\{(x_i,y_i)\\}_{i=0}^3$ 和节点水平集值 $\\{(\\phi_i,\\psi_i)\\}_{i=0}^3$ 构建一个分类准则，将单元分类为：\n- 尖端增强：当且仅当 $\\phi$ 和 $\\psi$ 的零等值线在闭合单元内部相交，即它们的交点位于包括边界在内的多边形内。此外，如果存在一个节点 $k$ 使得 $|\\phi_k| \\le \\tau$ 且 $|\\psi_k| \\le \\tau$，则该单元必须被分类为尖端增强。\n- Heaviside增强：当且仅当 $\\phi$ 的零等值线穿过该单元，但该单元不属于尖端增强。\n- 标准：其他所有情况。\n\n您的准则必须从水平集沿边插值的第一性原理推导得出。具体来说，沿每条边 $(i,j)$，使用节点值的符号来判断 $\\ell \\in \\{\\phi,\\psi\\}$ 是否变号，如果是，则通过线性插值计算唯一的零点穿越位置，使用\n$$\nt = \\frac{\\ell_i}{\\ell_i - \\ell_j}, \\qquad \\mathbf{p}_{\\ell,ij} = (1-t)\\,\\mathbf{x}_i + t\\,\\mathbf{x}_j,\n$$\n在 $\\ell_i \\cdot \\ell_j  0$ 的情况下使用，并将 $\\ell_i = 0$ 或 $\\ell_j = 0$（在容差 $\\tau$ 内）视为在相应节点处的零点。使用单元边界上所有 $\\phi$ 的零点集合，通过连接两个相距最远的独立边界零点，生成一条线段来近似单元内的 $\\{\\mathbf{x}:\\phi(\\mathbf{x})=0\\}$（如果存在的独立零点少于两个，则零等值线不穿过该单元）。对 $\\psi$ 进行同样的操作。当且仅当生成的 $\\phi$-线段和 $\\psi$-线段在闭合单元内相交，或者存在一个节点的 $\\phi$ 和 $\\psi$ 值在容差 $\\tau$ 内同时为零时，声明为“尖端增强”。当且仅当 $\\phi$-线段存在但单元不属于尖端增强时，声明为“Heaviside增强”。否则，声明为“标准”。\n\n任务2：仅通过上述基本依据，论证这个基于边、符号变化和插值的准则在网格各向异性下是稳健的。具体来说，需要论证沿边的符号变化检测和线性插值对于单元的拉伸和扭曲是不变的，并且线段相交逻辑仅依赖于边界上零点穿越的几何形状。\n\n任务3：实现一个程序，将您的分类准则应用于以下测试套件。每个测试用例都按固定的节点顺序 $i=0,1,2,3$ 提供了节点坐标 $(x_i,y_i)$ 和节点水平集值 $(\\phi_i,\\psi_i)$。\n\n- 测试用例 1 (Heaviside增强，“理想情况”)：\n  - $(x_i,y_i) = [ (\\,0\\,,\\,0\\,), (\\,1\\,,\\,0\\,), (\\,1\\,,\\,1\\,), (\\,0\\,,\\,1\\,) ]$\n  - $\\phi_i = [ -1, 1, 1, -1 ]$\n  - $\\psi_i = [ 2, 2, 2, 2 ]$\n\n- 测试用例 2 (尖端增强，内部相交)：\n  - $(x_i,y_i) = [ (\\,0\\,,\\,0\\,), (\\,1\\,,\\,0\\,), (\\,1\\,,\\,1\\,), (\\,0\\,,\\,1\\,) ]$\n  - $\\phi_i = [ -0.5, 0.5, 0.5, -0.5 ]$\n  - $\\psi_i = [ -0.5, -0.5, 0.5, 0.5 ]$\n\n- 测试用例 3 (标准，无裂纹穿过)：\n  - $(x_i,y_i) = [ (\\,0\\,,\\,0\\,), (\\,1\\,,\\,0\\,), (\\,1\\,,\\,1\\,), (\\,0\\,,\\,1\\,) ]$\n  - $\\phi_i = [ -1, -1, -1, -1 ]$\n  - $\\psi_i = [ -1, -1, -1, -1 ]$\n\n- 测试用例 4 (尖端增强，退化尖端位于节点上)：\n  - $(x_i,y_i) = [ (\\,0\\,,\\,0\\,), (\\,1\\,,\\,0\\,), (\\,1\\,,\\,1\\,), (\\,0\\,,\\,1\\,) ]$\n  - $\\phi_i = [ 0, 1, 1, 0 ]$\n  - $\\psi_i = [ 0, 0, 1, 1 ]$\n\n- 测试用例 5 (Heaviside增强，各向异性矩形)：\n  - $(x_i,y_i) = [ (\\,0\\,,\\,0\\,), (\\,10\\,,\\,0\\,), (\\,10\\,,\\,1\\,), (\\,0\\,,\\,1\\,) ]$\n  - $\\phi_i = [ -5, 5, 5, -5 ]$\n  - $\\psi_i = [ 1, 1, 1, 1 ]$\n\n- 测试用例 6 (Heaviside增强，两条等值线均穿过但不在单元内相交)：\n  - $(x_i,y_i) = [ (\\,0\\,,\\,0\\,), (\\,1\\,,\\,0\\,), (\\,1\\,,\\,1\\,), (\\,0\\,,\\,1\\,) ]$\n  - $\\phi_i = [ -0.5, 0.5, 0.5, -0.5 ]$\n  - $\\psi_i = [ -0.4, 0.6, 1.6, 0.6 ]$\n\n使用以下整数代码进行分类：尖端增强 $\\to 2$，Heaviside增强 $\\to 1$，标准 $\\to 0$。您的程序必须使用上述通用准则处理所有测试用例，并生成仅包含一行结果的输出，格式为方括号内以逗号分隔的列表，例如 $[a_1,a_2,\\dots,a_6]$，其中每个 $a_k$ 是按顺序排列的测试用例 $k$ 的整数代码。此问题不涉及单位或角度，也无需外部输入。在需要时，对零值测试和几何谓词使用容差 $\\tau = 10^{-12}$。",
            "solution": "此任务是为扩展有限元法 (XFEM) 中使用的二维四边形有限元制定、论证并实现一个稳健的分类准则。分类取决于单元与由两个水平集函数 $\\phi(\\mathbf{x})$ 和 $\\psi(\\mathbf{x})$ 表示的裂纹之间的关系。必须仅根据节点坐标 $\\{\\mathbf{x}_i\\}_{i=0}^3$ 和水平集函数的节点值 $\\{(\\phi_i, \\psi_i)\\}_{i=0}^3$ 将单元归类为尖端增强、Heaviside增强或标准。\n\n推导过程遵循第一性原理，并遵守所给出的关于水平集场沿单元边进行线性插值的假设。最终算法分三个阶段构建：边界零点穿越的识别、等值线的近似以及分类逻辑的应用。\n\n**1. 准则推导**\n\n**步骤 1.1：边界零点穿越的识别**\n设 $\\ell(\\mathbf{x})$ 代表 $\\phi(\\mathbf{x})$ 或 $\\psi(\\mathbf{x})$ 水平集场。在单元内部，真实的等值线 $\\{\\mathbf{x} : \\ell(\\mathbf{x})=0\\}$ 是未知的。然而，在沿边线性插值的假设下，可以精确确定其与单元边界的交点。我们检查四边形的四条边，由节点对 $(0,1)$、$(1,2)$、$(2,3)$ 和 $(3,0)$ 表示。对于连接节点 $i$ 和 $j$ 的任意一条边，其坐标为 $\\mathbf{x}_i$ 和 $\\mathbf{x}_j$，节点水平集值为 $\\ell_i$ 和 $\\ell_j$：\n\n- 如果一个节点值在给定的容差 $\\tau$ 内为零，即对于 $k \\in \\{i, j\\}$ 有 $|\\ell_k| \\le \\tau$，则等值线穿过该节点 $\\mathbf{x}_k$。\n- 如果节点值符号相反，即 $\\ell_i \\cdot \\ell_j  0$，线性插值函数必须在该边内部有且仅有一个零点。通过求解参数 $t \\in (0,1)$ 的方程 $\\ell(t) = (1-t)\\ell_i + t\\ell_j = 0$ 来找到这个零点穿越的位置。这得出 $t = \\ell_i / (\\ell_i - \\ell_j)$。对应的坐标为 $\\mathbf{p}_{\\ell,ij} = (1-t)\\mathbf{x}_i + t\\mathbf{x}_j$。\n- 如果节点值符号相同且非零，即 $\\ell_i \\cdot \\ell_j > 0$，则等值线不穿过该边。\n\n通过将此逻辑应用于 $\\phi$ 和 $\\psi$ 的所有四条边，我们生成两组唯一的边界零点穿越点集 $Z_\\phi$ 和 $Z_\\psi$。\n\n**步骤 1.2：线性等值线近似的构建**\n边界点集 $Z_\\ell$ 代表等值线 $\\{\\mathbf{x} : \\ell(\\mathbf{x})=0\\}$ 与单元边界的离散交点。为了近似等值线穿过单元内部的路径，我们连接这些点中的两个。根据规定，如果集合 $Z_\\ell$ 包含少于两个不同的点，则认为等值线不穿过该单元，不形成线段。如果 $|Z_\\ell| \\ge 2$，我们通过找出 $Z_\\ell$ 中欧几里得距离最大的点对 $\\{\\mathbf{p}_{\\ell,1}, \\mathbf{p}_{\\ell,2}\\} \\subseteq Z_\\ell$ 来构建一条线段：\n$$\n(\\mathbf{p}_{\\ell,1}, \\mathbf{p}_{\\ell,2}) = \\arg\\max_{\\mathbf{p}_a, \\mathbf{p}_b \\in Z_\\ell} \\|\\mathbf{p}_a - \\mathbf{p}_b\\|_2\n$$\n此过程产生一条连接 $\\mathbf{p}_{\\phi,1}$ 和 $\\mathbf{p}_{\\phi,2}$ 的 $\\phi$-线段 $S_\\phi$，以及一条连接 $\\mathbf{p}_{\\psi,1}$ 和 $\\mathbf{p}_{\\psi,2}$ 的 $\\psi$-线段 $S_\\psi$，前提是它们各自的零点穿越集合至少包含两个点。\n\n**步骤 1.3：分类算法**\n在必要的几何构造就绪后，根据以下分层准则对单元进行分类：\n\n1.  **尖端增强 (代码 2):** 如果裂纹尖端位于其域内（包括边界），则单元被分类为尖端增强。这通过满足以下两个条件之一来确定：\n    a. **节点尖端：** 存在一个节点 $k \\in \\{0,1,2,3\\}$，其两个水平集函数在容差 $\\tau$ 内同时为零：$|\\phi_k| \\le \\tau$ 且 $|\\psi_k| \\le \\tau$。这表示裂纹尖端正好位于一个节点上。\n    b. **内部尖端：** 如果不满足节点尖端条件，我们检查近似的等值线是否相交。如果 $\\phi$-线段 $S_\\phi$ 和 $\\psi$-线段 $S_\\psi$ 都存在，并且它们相交 ($S_\\phi \\cap S_\\psi \\neq \\emptyset$)，则该单元为尖端增强。这需要一个标准的计算几何算法来判断线段相交。\n\n2.  **Heaviside增强 (代码 1):** 如果单元未被分类为尖端增强，则检查其是否需要用不连续的Heaviside函数进行增强。如果裂纹体穿过该单元但尖端不在其中，则适合进行此增强。当且仅当 $\\phi$-等值线穿过该单元时满足此条件，即边界穿越点集 $Z_\\phi$ 包含至少两个不同的点（即 $S_\\phi$ 线段存在）。\n\n3.  **标准 (代码 0):** 如果一个单元既不是尖端增强也不是Heaviside增强，那么它就是一个标准的、未增强的单元。这种情况发生在 $\\phi$-等值线没有在两个或更多不同点上穿过单元边界时。\n\n**2. 稳健性论证**\n\n所提出的准则相对于网格各向异性（即单元拉伸和扭曲）是稳健的，因为其基本操作在仿射变换下是不变的。\n\n一个仿射变换 $T(\\mathbf{x}) = A\\mathbf{x} + \\mathbf{b}$（其中 $A$ 是可逆矩阵，$\\mathbf{b}$ 是平移向量）将直线映射为直线，并保持平行性和沿线距离的比率。一个通用的凸四边形将被映射为另一个凸四边形。\n\n1.  **符号变化检测：** 第一步，检测两个节点之间水平集函数的符号变化，是一个纯粹的拓扑操作。它仅取决于标量值 $\\ell_i$ 和 $\\ell_j$，这些值在坐标系变换下是不变的。因此，边上是否存在零点穿越与单元的几何形状无关。\n\n2.  **线性插值：** 插值参数 $t = \\ell_i/(\\ell_i - \\ell_j)$ 的计算仅依赖于标量水平集值，因此是不变的。零点穿越的位置是节点坐标的凸组合，$\\mathbf{p} = (1-t)\\mathbf{x}_i + t\\mathbf{x}_j$。如果单元经历一个仿射变换 $T$，新的节点坐标为 $\\mathbf{x}'_i = T(\\mathbf{x}_i)$ 和 $\\mathbf{x}'_j = T(\\mathbf{x}_j)$。新的零点穿越点为：\n    $$\n    \\mathbf{p}' = (1-t)\\mathbf{x}'_i + t\\mathbf{x}'_j = (1-t)T(\\mathbf{x}_i) + tT(\\mathbf{x}_j) = T((1-t)\\mathbf{x}_i + t\\mathbf{x}_j) = T(\\mathbf{p})\n    $$\n    这表明变换后边上的零点穿越点正是原始零点穿越点的变换。穿越点在边上的相对位置得以保持。\n\n3.  **线段构建与相交：** 后续步骤——识别最远点对和检查线段相交——是纯粹的几何过程。由于仿射变换将边界零点穿越集合 $Z_\\ell$ 映射到一个新集合 $Z'_\\ell = \\{T(\\mathbf{p}) : \\mathbf{p} \\in Z_\\ell\\}$，并且由于仿射映射通常不保持距离，因此“最远”点对的选择可能会改变。然而，对于一个凸四边形，等值线的线性近似通常穿过两条边，导致 $|Z_\\ell| = 2$。在这种常见且稳定的情况下，线段端点的选择是唯一的，因此其变换也是唯一的。即使有更多的穿越点，相交测试本身也是基于方向谓词（共线性和转向方向）的，这些谓词在仿射变换下是保持不变的。如果两条线段相交，它们的变换版本也会相交。\n\n因此，整个分类逻辑建立在仿射不变操作之上，是稳健的，并且对任意形状的单元（包括具有高纵横比或扭曲的单元）都能产生一致的结果。",
            "answer": "```python\nimport numpy as np\n\n# Geometric helper functions with a tolerance for floating-point comparisons\n_GEOM_TOL = 1e-9\n\ndef orientation(p, q, r):\n    \"\"\"\n    Computes the orientation of the ordered triplet (p, q, r).\n    Returns:\n     > 0 for counter-clockwise\n      0 for clockwise\n     = 0 for collinear\n    \"\"\"\n    val = (q[1] - p[1]) * (r[0] - q[0]) - \\\n          (q[0] - p[0]) * (r[1] - q[1])\n    if abs(val)  _GEOM_TOL:\n        return 0\n    return 1 if val > 0 else -1\n\ndef on_segment(p, q, r):\n    \"\"\"Given three collinear points p, q, r, checks if q lies on segment pr.\"\"\"\n    return (q[0] = max(p[0], r[0]) + _GEOM_TOL and q[0] >= min(p[0], r[0]) - _GEOM_TOL and\n            q[1] = max(p[1], r[1]) + _GEOM_TOL and q[1] >= min(p[1], r[1]) - _GEOM_TOL)\n\ndef segments_intersect(seg1, seg2):\n    \"\"\"Checks if two segments, seg1=(p1, q1) and seg2=(p2, q2), intersect.\"\"\"\n    p1, q1 = seg1\n    p2, q2 = seg2\n\n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n\n    # General case: segments cross each other\n    if o1 != o2 and o3 != o4:\n        return True\n\n    # Special Cases for collinearity\n    if o1 == 0 and on_segment(p1, p2, q1): return True\n    if o2 == 0 and on_segment(p1, q2, q1): return True\n    if o3 == 0 and on_segment(p2, p1, q2): return True\n    if o4 == 0 and on_segment(p2, q1, q2): return True\n\n    return False\n\ndef classify_element(coords, phi_vals, psi_vals, tau):\n    \"\"\"\n    Classifies an element as standard (0), Heaviside-enriched (1), or tip-enriched (2).\n    \"\"\"\n    coords = np.array(coords, dtype=float)\n    phi_vals = np.array(phi_vals, dtype=float)\n    psi_vals = np.array(psi_vals, dtype=float)\n\n    # Primary Criterion: Check for tip located at a node\n    for i in range(4):\n        if abs(phi_vals[i]) = tau and abs(psi_vals[i]) = tau:\n            return 2  # Tip-enriched\n\n    def find_zeros(ls_vals):\n        points = []\n        # Check nodes for zero value\n        for i in range(4):\n            if abs(ls_vals[i]) = tau:\n                points.append(coords[i])\n        \n        # Check edges for sign change\n        for i in range(4):\n            j = (i + 1) % 4\n            val_i, val_j = ls_vals[i], ls_vals[j]\n            if val_i * val_j  0:\n                # Denominator is non-zero if signs are strictly opposite\n                t = val_i / (val_i - val_j)\n                p_ij = (1.0 - t) * coords[i] + t * coords[j]\n                points.append(p_ij)\n        \n        if not points:\n            return []\n        \n        # Filter for unique points using a distance tolerance\n        unique_points = [points[0]]\n        for p in points[1:]:\n            is_duplicate = any(np.linalg.norm(p - up)  _GEOM_TOL for up in unique_points)\n            if not is_duplicate:\n                unique_points.append(p)\n        return unique_points\n\n    def form_segment(zero_points):\n        if len(zero_points)  2:\n            return None\n        \n        max_dist_sq = -1.0\n        best_pair = (None, None)\n        for i in range(len(zero_points)):\n            for j in range(i + 1, len(zero_points)):\n                p1, p2 = zero_points[i], zero_points[j]\n                dist_sq = np.sum((p1 - p2)**2)\n                if dist_sq > max_dist_sq:\n                    max_dist_sq = dist_sq\n                    best_pair = (p1, p2)\n        return best_pair\n\n    # Find zero crossings for phi and psi\n    phi_zeros = find_zeros(phi_vals)\n    psi_zeros = find_zeros(psi_vals)\n    \n    # Form segments by connecting the two farthest zero-crossing points\n    phi_segment = form_segment(phi_zeros)\n    psi_segment = form_segment(psi_zeros)\n\n    # Tip-Enriched Criterion: Check for segment intersection\n    if phi_segment is not None and psi_segment is not None:\n        if segments_intersect(phi_segment, psi_segment):\n            return 2  # Tip-enriched\n\n    # Heaviside-Enriched Criterion: Check if phi-isocontour crosses the element\n    if phi_segment is not None:\n        return 1  # Heaviside-enriched\n\n    # Otherwise, it's a standard element\n    return 0  # Standard\n\ndef solve():\n    test_cases = [\n        # 1. Heaviside-enriched, \"happy path\"\n        {'coords': [[0,0], [1,0], [1,1], [0,1]], 'phi': [-1, 1, 1, -1], 'psi': [2, 2, 2, 2]},\n        # 2. Tip-enriched, interior intersection\n        {'coords': [[0,0], [1,0], [1,1], [0,1]], 'phi': [-0.5, 0.5, 0.5, -0.5], 'psi': [-0.5, -0.5, 0.5, 0.5]},\n        # 3. Standard, no crack crossing\n        {'coords': [[0,0], [1,0], [1,1], [0,1]], 'phi': [-1, -1, -1, -1], 'psi': [-1, -1, -1, -1]},\n        # 4. Tip-enriched, degenerate tip at a node\n        {'coords': [[0,0], [1,0], [1,1], [0,1]], 'phi': [0, 1, 1, 0], 'psi': [0, 0, 1, 1]},\n        # 5. Heaviside-enriched, anisotropic rectangle\n        {'coords': [[0,0], [10,0], [10,1], [0,1]], 'phi': [-5, 5, 5, -5], 'psi': [1, 1, 1, 1]},\n        # 6. Heaviside-enriched, both isocontours cross but do not intersect within the element\n        {'coords': [[0,0], [1,0], [1,1], [0,1]], 'phi': [-0.5, 0.5, 0.5, -0.5], 'psi': [-0.4, 0.6, 1.6, 0.6]}\n    ]\n    tau = 1e-12\n\n    results = []\n    for case in test_cases:\n        result = classify_element(case['coords'], case['phi'], case['psi'], tau)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一旦确定一个单元被不连续面切割，我们就需要修改其近似基函数，以捕捉解场中的跳跃。本练习聚焦于 XFEM 的核心：为一个简单的四边形单元实现亥维赛富集基函数。通过完成此练习，您将具体理解单位分解性质是如何被用来将不连续性引入标准有限元框架的 。",
            "id": "2390842",
            "problem": "实现一个完整的程序，用于构建在扩展有限元方法 (XFEM) 中使用的二维双线性四边形单元的 Heaviside 增强。从有限元形函数和不连续性的水平集表示的基本定义开始。考虑一个占据单位正方形域 $\\Omega_{e} = [0,1] \\times [0,1]$ 的单个等参四边形单元，其四个节点位于 $\\mathbf{x}_1 = (0,0)$、$\\mathbf{x}_2 = (1,0)$、$\\mathbf{x}_3 = (1,1)$ 和 $\\mathbf{x}_4 = (0,1)$。标准的双线性形函数为\n$$\nN_1(x,y) = (1-x)(1-y),\\quad N_2(x,y) = x(1-y),\\quad N_3(x,y) = xy,\\quad N_4(x,y) = (1-x)y,\n$$\n这些函数满足单位分解性质 $\\sum_{i=1}^{4} N_i(x,y) = 1$，对所有 $(x,y) \\in \\Omega_{e}$ 成立。材料界面由水平集函数 $\\phi(\\mathbf{x})$ 隐式表示，其零等值线 $\\{\\mathbf{x} \\mid \\phi(\\mathbf{x}) = 0\\}$ 定义了不连续性。\n\n将 Heaviside 函数 $H(\\phi)$ 定义为\n$$\nH(\\phi) = \\begin{cases}\n+1,  \\phi > 0,\\\\\n0,  \\phi = 0,\\\\\n-1,  \\phi  0.\n\\end{cases}\n$$\n将节点 $i$ 的 Heaviside 增强基函数定义为\n$$\n\\psi_i(\\mathbf{x}) = \\begin{cases}\nN_i(\\mathbf{x})\\left(H(\\phi(\\mathbf{x})) - H(\\phi(\\mathbf{x}_i))\\right),  \\text{如果单元被切割},\\\\\n0,  \\text{其他情况},\n\\end{cases}\n$$\n其中，如果 $\\min_{j \\in \\{1,2,3,4\\}} \\phi(\\mathbf{x}_j)  0$ 且 $\\max_{j \\in \\{1,2,3,4\\}} \\phi(\\mathbf{x}_j) > 0$，则认为该单元被切割。该准则确保了增强仅在不连续性穿过单元内部时才被激活。该定义满足对所有节点 $j$ 都有 $\\psi_i(\\mathbf{x}_j) = 0$，并引入了一个与 $H(\\phi)$ 符号变化一致的位移跳跃。\n\n您的任务是实现：\n- 下方测试套件中指定的水平集函数 $\\phi(\\mathbf{x})$。\n- Heaviside 函数 $H(\\phi)$。\n- 节点 $i = 1$ 的增强基函数 $\\psi_i(\\mathbf{x})$。\n- 在 $\\Omega_e$ 上一个 $M \\times M$ 的网格上进行均匀采样，其中 $M = 101$，即 $x_k = k/(M-1)$ 和 $y_\\ell = \\ell/(M-1)$，对于 $k,\\ell \\in \\{0,1,\\dots,M-1\\}$。\n\n对于下方的每个测试用例，计算 $\\psi_1(\\mathbf{x})$ 的以下量化诊断指标：\n1. $z_{\\text{nodes}}$：最大节点绝对值 $\\max_{j \\in \\{1,2,3,4\\}} \\left|\\psi_1(\\mathbf{x}_j)\\right|$。这验证了增强在节点处为零的特性。\n2. $z_{\\text{grid}}$：网格上的最大绝对值 $\\max_{(x,y)\\in \\mathcal{G}} \\left|\\psi_1(x,y)\\right|$，其中 $\\mathcal{G}$ 是网格点集。\n3. $z_{\\text{jump}}$：$\\psi_1$ 在单元中心 $\\mathbf{p}_c=(0.5,0.5)$ 处穿过界面的近似跳跃，计算如下。如果 $\\left|\\phi(\\mathbf{p}_c)\\right| \\le \\tau$，容差为 $\\tau = 10^{-12}$，则通过以下公式近似跳跃\n$$\nz_{\\text{jump}} \\approx \\psi_1(\\mathbf{p}_c + \\varepsilon \\mathbf{n}) - \\psi_1(\\mathbf{p}_c - \\varepsilon \\mathbf{n}),\n$$\n其中 $\\mathbf{n} = \\nabla \\phi(\\mathbf{p}_c)/\\|\\nabla \\phi(\\mathbf{p}_c)\\|$ 是单位法向量，通过步长为 $h = 10^{-8}$ 的中心有限差分计算，且 $\\varepsilon = 10^{-6}$。如果 $\\left|\\phi(\\mathbf{p}_c)\\right| > \\tau$，则设 $z_{\\text{jump}} = 0$。\n4. $z_{\\text{L2}}$：$\\psi_1$ 在单元上的 $L^2$ 范数的离散近似，\n$$\nz_{\\text{L2}} \\approx \\left(\\sum_{(x,y) \\in \\mathcal{G}} \\psi_1(x,y)^2 \\,\\Delta x \\,\\Delta y \\right)^{1/2},\n$$\n其中 $\\Delta x = \\Delta y = 1/(M-1)$。\n\n测试套件 (在所有情况下均使用节点索引 $i=1$)：\n- 情况 A (穿过中心的内部切割)：$\\phi(x,y) = x + y - 1$。\n- 情况 B (与边界对齐的零水平集，无内部切割)：$\\phi(x,y) = x$。\n- 情况 C (无任何切割)：$\\phi(x,y) = x + y + 1$。\n\n科学真实性：上述定义在扩展有限元方法 (XFEM) 中是标准的，基于网格的诊断通过表征增强基在单元上的大小和跳跃，作为可视化的数值代理。\n\n您的程序必须输出一行包含结果列表的内容，每个测试用例一个列表，格式严格为\n$[ [z_{\\text{nodes}}^{(A)}, z_{\\text{grid}}^{(A)}, z_{\\text{jump}}^{(A)}, z_{\\text{L2}}^{(A)}], [z_{\\text{nodes}}^{(B)}, z_{\\text{grid}}^{(B)}, z_{\\text{jump}}^{(B)}, z_{\\text{L2}}^{(B)}], [z_{\\text{nodes}}^{(C)}, z_{\\text{grid}}^{(C)}, z_{\\text{jump}}^{(C)}, z_{\\text{L2}}^{(C)} ] ]$，每个数字四舍五入到六位小数。本问题不使用物理单位。不使用角度。输出必须是单行，没有任何附加文本。",
            "solution": "用户已提交问题陈述以进行验证和求解。\n\n### 第 1 步：提取已知条件\n- **域**：由单位正方形 $[0,1] \\times [0,1]$ 定义的二维双线性等参四边形单元 $\\Omega_{e}$。\n- **节点**：位于坐标 $\\mathbf{x}_1 = (0,0)$、$\\mathbf{x}_2 = (1,0)$、$\\mathbf{x}_3 = (1,1)$ 和 $\\mathbf{x}_4 = (0,1)$ 的四个节点。\n- **标准基函数**：标准的双线性形函数为 $N_1(x,y) = (1-x)(1-y)$、$N_2(x,y) = x(1-y)$、$N_3(x,y) = xy$ 和 $N_4(x,y) = (1-x)y$。\n- **不连续性表示**：使用水平集函数 $\\phi(\\mathbf{x})$，不连续性由零等值线 $\\phi(\\mathbf{x}) = 0$ 定义。\n- **Heaviside 函数**：Heaviside 函数定义为：当 $\\phi > 0$ 时 $H(\\phi) = +1$，当 $\\phi  0$ 时 $H(\\phi) = -1$，当 $\\phi = 0$ 时 $H(\\phi) = 0$。\n- **增强基函数**：节点 $i$ 的 Heaviside 增强基函数为 $\\psi_i(\\mathbf{x}) = N_i(\\mathbf{x})\\left(H(\\phi(\\mathbf{x})) - H(\\phi(\\mathbf{x}_i))\\right)$（如果单元被切割），否则 $\\psi_i(\\mathbf{x})=0$。\n- **单元切割准则**：如果水平集函数在其节点处同时具有正值和负值，即 $\\min_{j} \\phi(\\mathbf{x}_j)  0$ 且 $\\max_{j} \\phi(\\mathbf{x}_j) > 0$，则认为单元被切割。\n- **任务细节**：实现必须专注于节点 $i=1$ 的增强。\n- **数值网格**：域 $\\Omega_e$ 将被离散化为一个 $M \\times M$ 点的均匀网格，其中 $M=101$。\n- **$\\psi_1(\\mathbf{x})$ 的诊断量**：\n    1. $z_{\\text{nodes}} = \\max_{j \\in \\{1,2,3,4\\}} \\left|\\psi_1(\\mathbf{x}_j)\\right|$。\n    2. $z_{\\text{grid}} = \\max_{(x,y)\\in \\mathcal{G}} \\left|\\psi_1(x,y)\\right|$，在网格 $\\mathcal{G}$ 上。\n    3. $z_{\\text{jump}}$：在单元中心 $\\mathbf{p}_c=(0.5,0.5)$ 处的跳跃近似值。仅当 $|\\phi(\\mathbf{p}_c)| \\le \\tau=10^{-12}$ 时非零。跳跃计算为 $\\psi_1(\\mathbf{p}_c + \\varepsilon \\mathbf{n}) - \\psi_1(\\mathbf{p}_c - \\varepsilon \\mathbf{n})$，其中 $\\varepsilon = 10^{-6}$，$\\mathbf{n}$ 是在 $\\mathbf{p}_c$ 处 $\\phi$ 的归一化梯度。梯度通过步长为 $h=10^{-8}$ 的中心差分计算。\n    4. $z_{\\text{L2}}$：离散 $L^2$ 范数，$z_{\\text{L2}} \\approx \\left(\\sum_{(x,y) \\in \\mathcal{G}} \\psi_1(x,y)^2 \\,\\Delta x \\,\\Delta y \\right)^{1/2}$，网格间距为 $\\Delta x = \\Delta y = 1/(M-1)$。\n- **测试套件**：\n    - 情况 A：$\\phi(x,y) = x + y - 1$ (内部切割)。\n    - 情况 B：$\\phi(x,y) = x$ (与边界对齐，无内部切割)。\n    - 情况 C：$\\phi(x,y) = x + y + 1$ (无切割)。\n\n### 第 2 步：使用提取的已知条件进行验证\n问题陈述经过严格验证。\n1.  **科学基础**：该问题牢固地植根于扩展有限元方法 (XFEM) 的既定原理，这是一种用于模拟不连续性问题的计算力学标准技术。水平集、Heaviside 增强和基函数的定义都是规范的。\n2.  **适定性**：该问题是一个定义明确的计算任务。所有函数、参数和测试用例都得到了明确的指定，确保可以确定一组唯一的数值结果。\n3.  **客观性**：语言是客观和数学化的。不需要主观解释。\n4.  **完整性与一致性**：该问题是自包含的。提供了所有必要信息。定义在内部是一致的；例如，增强基函数 $\\psi_i(\\mathbf{x})$ 在设计上就在所有节点位置 $\\mathbf{x}_j$ 处为零，而诊断指标 $z_{\\text{nodes}}$ 正是为了验证这一属性。\n5.  **可行性**：所需的计算在计算上是可行的，并且是数值分析的标准操作。\n\n满足有效问题的所有标准。没有科学、逻辑或结构上的缺陷。\n\n### 第 3 步：结论与行动\n该问题是 **有效的**。将提供一个解决方案。\n\n---\n\n### 基于原理的解决方案设计\n\n目标是为双线性四边形单元实现并分析一个 Heaviside 增强基函数 $\\psi_1(\\mathbf{x})$。这是扩展有限元方法 (XFEM) 的一个基本组成部分，它通过增强有限元方法 (FEM) 的标准多项式逼近空间来模拟不连续性，而无需网格与不连续性几何形状相符。\n\n算法设计直接源于所提供的定义。\n\n**1. 单元和基函数定义**\n基础是在单位正方形 $\\Omega_e = [0,1] \\times [0,1]$ 上的标准双线性单元。节点 1（位于原点 $(0,0)$）的形函数为 $N_1(x,y) = (1-x)(1-y)$。Heaviside 函数 $H(\\phi)$ 实现为符号函数，它将水平集函数 $\\phi$ 的正、负和零值分别映射到 $+1$、$-1$ 和 $0$。\n\n**2. 增强激活**\nXFEM 的核心思想是仅对实际被不连续性穿过的单元应用增强。这由`单元切割准则`确定。算法首先在四个单元节点 $\\mathbf{x}_j$ 处计算水平集函数 $\\phi(\\mathbf{x})$。如果 $\\phi(\\mathbf{x}_j)$ 的符号不全相同（且不全为零），特别是如果 $\\min_j \\phi(\\mathbf{x}_j)  0$ 且 $\\max_j \\phi(\\mathbf{x}_j) > 0$，则该单元被标记为“已切割”。对于所有其他情况（例如，不连续性位于单元外部或在边界上相切但未穿过），增强是无效的，增强基函数 $\\psi_1(\\mathbf{x})$ 在整个单元上恒为零。\n\n**3. 增强基函数 $\\psi_1(\\mathbf{x})$ 的构建**\n如果单元被切割，节点 1 的增强基函数构建如下：\n$$\n\\psi_1(\\mathbf{x}) = N_1(\\mathbf{x}) \\left( H(\\phi(\\mathbf{x})) - H(\\phi(\\mathbf{x}_1)) \\right)\n$$\n在这里，$H(\\phi(\\mathbf{x}_1))$ 是由节点 1 处水平集的符号决定的一个常数标量值。$H(\\phi(\\mathbf{x}))$ 项在单元内空间变化，从而产生所需的跳跃。与形函数 $N_1(\\mathbf{x})$ 的乘积确保了增强是局部的，并且其影响在远离节点 1 的地方消失。关键是，这种公式保证了在所有节点 $j=1,2,3,4$ 处都有 $\\psi_1(\\mathbf{x}_j) = 0$，因为当 $j \\neq 1$ 时，$N_1(\\mathbf{x}_j)=0$，而当 $j=1$ 时，括号中的项变为零。\n\n**4. 诊断指标的计算**\n四个诊断指标用于表征 $\\psi_1(\\mathbf{x})$ 的行为。\n- $z_{\\text{nodes}}$：这验证了 $\\psi_1(\\mathbf{x})$ 在所有节点处都为零的理论性质。通过在四个节点处计算 $|\\psi_1(\\mathbf{x}_j)|$ 并找到最大值来计算。预期结果始终为 $0$。\n- $z_{\\text{grid}}$：这测量了增强函数在单元上的最大振幅。通过在一个 $101 \\times 101$ 点的精细网格上计算 $|\\psi_1(x,y)|$ 并确定最大值来找到。\n- $z_{\\text{jump}}$：该诊断量化了函数 $\\psi_1$ 穿过不连续线 $\\phi=0$ 时的跳跃大小，特别是在单元中心 $\\mathbf{p}_c=(0.5,0.5)$ 附近。如果不连续性不通过中心（即 $|\\phi(\\mathbf{p}_c)| > \\tau$），则跳跃定义为 $0$。否则，使用关于 $\\phi$ 的中心有限差分来近似不连续性的法向量 $\\mathbf{n}$。然后通过在界面两侧的两个点 $\\mathbf{p}_c \\pm \\varepsilon\\mathbf{n}$ 采样 $\\psi_1$ 并取其差来计算跳跃。对于 Heaviside 增强，$\\psi_1$ 穿过界面的跳跃预期约为 $N_1(\\mathbf{x}) \\times (H(\\phi>0) - H(\\phi0)) = N_1(\\mathbf{x}) \\times (1 - (-1)) = 2 N_1(\\mathbf{x})$。在中心点，这预测的跳跃为 $2 \\times N_1(0.5,0.5) = 2 \\times 0.25 = 0.5$。\n- $z_{\\text{L2}}$：这计算了增强函数的能量。它通过网格点上的离散和来近似，这对应于积分 $\\int_{\\Omega_e} \\psi_1(x,y)^2 \\, dA$ 的数值求积（黎曼和）。\n\n**5. 测试用例分析**\n- **情况 A ($\\phi = x+y-1$)**：$\\phi$ 的节点值为 $\\{-1, 0, 1, 0\\}$。由于存在负值和正值，单元被切割。预计所有诊断指标都非零（除了 $z_{\\text{nodes}}$）。界面穿过中心，因此将计算 $z_{\\text{jump}}$，并且应接近 $0.5$。\n- **情况 B ($\\phi = x$)**：节点值为 $\\{0, 1, 1, 0\\}$。由于 $\\min_j \\phi(\\mathbf{x}_j)$ 不小于 $0$，不满足`切割`准则。增强无效，$\\psi_1(\\mathbf{x})=0$。所有诊断指标都将为 $0$。\n- **情况 C ($\\phi = x+y+1$)**：节点值为 $\\{1, 2, 3, 2\\}$。所有值均为正。单元未被切割。所有诊断指标都将为 $0$。\n\n这个系统化的过程使得对指定的 XFEM 构造及其数值分析能够进行稳健和正确的实现。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and evaluates a Heaviside-enriched basis function for a bilinear\n    quadrilateral element in XFEM.\n    \"\"\"\n\n    test_cases = [\n        {'name': 'A', 'phi': lambda x, y: x + y - 1},\n        {'name': 'B', 'phi': lambda x, y: x},\n        {'name': 'C', 'phi': lambda x, y: x + y + 1},\n    ]\n\n    all_results = []\n\n    M = 101\n    tau = 1e-12\n    h_grad = 1e-8\n    epsilon_jump = 1e-6\n    \n    nodes = np.array([[0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0]])\n    node_of_interest_idx = 0  # Node 1 is at index 0\n\n    x_grid_vals = np.linspace(0.0, 1.0, M)\n    y_grid_vals = np.linspace(0.0, 1.0, M)\n    xx, yy = np.meshgrid(x_grid_vals, y_grid_vals, indexing='xy')\n    dx = 1.0 / (M - 1)\n    dy = 1.0 / (M - 1)\n\n    def N1_func(x, y):\n        return (1.0 - x) * (1.0 - y)\n\n    def H_func(val):\n        return np.sign(val)\n\n    for case in test_cases:\n        phi_func = case['phi']\n\n        # Determine if the element is cut\n        phi_at_nodes = np.array([phi_func(n[0], n[1]) for n in nodes])\n        is_cut = np.min(phi_at_nodes)  0 and np.max(phi_at_nodes) > 0\n\n        # Pre-calculate values for the enriched basis function psi_1\n        phi_at_node1 = phi_at_nodes[node_of_interest_idx]\n        H_phi_at_node1 = H_func(phi_at_node1)\n\n        # --- Define psi_1 for pointwise and grid evaluation ---\n        \n        # Pointwise function for z_jump calculation\n        def psi_1_pointwise(x, y):\n            if not is_cut:\n                return 0.0\n            phi_val = phi_func(x, y)\n            H_phi_val = H_func(phi_val)\n            return N1_func(x, y) * (H_phi_val - H_phi_at_node1)\n\n        # Vectorized grid evaluation for z_grid and z_L2\n        if not is_cut:\n            psi_grid = np.zeros_like(xx)\n        else:\n            phi_grid = phi_func(xx, yy)\n            H_phi_grid = H_func(phi_grid)\n            N1_grid = N1_func(xx, yy)\n            psi_grid = N1_grid * (H_phi_grid - H_phi_at_node1)\n\n        # --- Compute diagnostics ---\n\n        # 1. z_nodes\n        psi_at_nodes = np.array([psi_1_pointwise(n[0], n[1]) for n in nodes])\n        z_nodes = np.max(np.abs(psi_at_nodes))\n\n        # 2. z_grid\n        z_grid = np.max(np.abs(psi_grid))\n\n        # 3. z_jump\n        pc = np.array([0.5, 0.5])\n        phi_at_pc = phi_func(pc[0], pc[1])\n        \n        if np.abs(phi_at_pc) > tau or not is_cut:\n            z_jump = 0.0\n        else:\n            # Gradient by central finite differences\n            dphi_dx = (phi_func(pc[0] + h_grad, pc[1]) - phi_func(pc[0] - h_grad, pc[1])) / (2 * h_grad)\n            dphi_dy = (phi_func(pc[0], pc[1] + h_grad) - phi_func(pc[0], pc[1] - h_grad)) / (2 * h_grad)\n            grad_phi = np.array([dphi_dx, dphi_dy])\n            \n            norm_grad = np.linalg.norm(grad_phi)\n            if norm_grad  1e-15: # Avoid division by zero\n                n_vec = np.array([0.0, 0.0])\n            else:\n                n_vec = grad_phi / norm_grad\n            \n            p_plus = pc + epsilon_jump * n_vec\n            p_minus = pc - epsilon_jump * n_vec\n            \n            psi_plus = psi_1_pointwise(p_plus[0], p_plus[1])\n            psi_minus = psi_1_pointwise(p_minus[0], p_minus[1])\n            \n            z_jump = psi_plus - psi_minus\n\n        # 4. z_L2\n        z_L2 = np.sqrt(np.sum(psi_grid**2) * dx * dy)\n\n        all_results.append([z_nodes, z_grid, z_jump, z_L2])\n\n    # Format the final output string as specified in the problem\n    formatted_cases = []\n    for case_result in all_results:\n        formatted_numbers = ', '.join([f'{num:.6f}' for num in case_result])\n        formatted_cases.append(f'[{formatted_numbers}]')\n    \n    final_string = f\"[{', '.join(formatted_cases)}]\"\n    print(final_string)\n\nsolve()\n```"
        },
        {
            "introduction": "在 XFEM 中组装系统方程的最后一步，涉及到在被不连续面任意切割的单元上进行函数积分。标准的求积法则不再适用于此任务，因此我们必须开发定制的积分方案。本练习要求您创建一个方法，来精确地对一个线性不连续面切割三角形单元所产生的复杂多边形子域上的函数进行积分 。",
            "id": "2390826",
            "problem": "在扩展有限元法 (XFEM) 的背景下，考虑一个二维空间中的单个三角形有限元。该单元被一条代表不连续性（例如，裂纹面）的直线所切割。设该三角形的顶点位于平面坐标系中，直线由标量函数 $\\phi(x,y) = a x + b y + c$ 隐式表示，其正半平面定义为 $\\{(x,y) \\, | \\, \\phi(x,y) \\ge 0\\}$。将单位阶跃（亥维赛）富集域定义为三角形单元与此正半平面的交集。目标是构建一个自定义的数值积分法则，能够对位于亥维赛域内的那部分三角形单元上的多项式场进行积分。\n\n对于每个给定的测试用例，计算标量积分\n$$\nI \\;=\\; \\iint_{\\Omega_+} f(x,y) \\,\\mathrm{d}A,\n$$\n其中 $\\Omega_+ = \\{(x,y) \\in T \\, | \\, \\phi(x,y) \\ge 0\\}$ 且 $T$ 是由测试用例中提供的三个顶点构成的闭合三角形区域。所有测试用例的被积函数均为多项式\n$$\nf(x,y) \\;=\\; x^2 + y.\n$$\n量 $I$ 没有物理单位；以实数形式报告数值。问题中不涉及角度。每个测试用例的最终答案必须以浮点数形式返回。\n\n使用以下测试套件。在每个案例中，三角形由一个有序的顶点三元组给出，直线由其隐式形式 $\\phi(x,y) = a x + b y + c$ 中的系数 $(a,b,c)$ 给出。\n\n- 测试用例 $1$ (一般切割，产生一个凸四边形子域):\n  - 三角形顶点：$(0,0)$, $(1,0)$, $(0,1)$。\n  - 直线系数：$(a,b,c) = (1,1,-0.5)$，即 $\\phi(x,y) = x + y - 0.5$。\n\n- 测试用例 $2$ (无切割，整个三角形位于正半平面内):\n  - 三角形顶点：$(0,0)$, $(1,0)$, $(0,1)$。\n  - 直线系数：$(a,b,c) = (1,1,1)$，即 $\\phi(x,y) = x + y + 1$。\n\n- 测试用例 $3$ (边界情况，直线穿过一个顶点并切割单元):\n  - 三角形顶点：$(0,0)$, $(2,0)$, $(0,1)$。\n  - 直线系数：$(a,b,c) = (-1,1,0)$，即 $\\phi(x,y) = -x + y$。\n\n- 测试用例 $4$ (交集为空，正半平面不与三角形内部相交):\n  - 三角形顶点：$(0,0)$, $(1,0)$, $(0,1)$。\n  - 直线系数：$(a,b,c) = (1,1,-2)$，即 $\\phi(x,y) = x + y - 2$。\n\n您的程序必须按上述顺序为每个测试用例计算 $I$，并生成一行输出，其中包含四个结果，以逗号分隔并用方括号括起来，例如 [$r_1$,$r_2$,$r_3$,$r_4$]，其中每个 $r_i$ 是对应于测试用例 $i$ 的浮点结果。",
            "solution": "问题陈述提出了一个计算工程领域中明确定义的任务，特别是在扩展有限元法 (XFEM) 的背景下。它要求计算一个多项式函数在由三角形和半平面交集定义的域上的定积分。\n\n### 第1步：提取已知信息\n- **积分域**：区域 $\\Omega_+ = \\{(x,y) \\in T \\, | \\, \\phi(x,y) \\ge 0\\}$，其中 $T$ 是一个闭合三角形区域，$\\phi(x,y) = ax + by + c$ 是一个线性函数。\n- **被积函数**：$f(x,y) = x^2 + y$。\n- **待计算的积分**：$I = \\iint_{\\Omega_+} f(x,y) \\, \\mathrm{d}A$。\n- **测试用例**：\n    1. $T_1$：顶点 $\\{(0,0), (1,0), (0,1)\\}$；$\\phi_1(x,y) = x + y - 0.5$。\n    2. $T_2$：顶点 $\\{(0,0), (1,0), (0,1)\\}$；$\\phi_2(x,y) = x + y + 1$。\n    3. $T_3$：顶点 $\\{(0,0), (2,0), (0,1)\\}$；$\\phi_3(x,y) = -x + y$。\n    4. $T_4$：顶点 $\\{(0,0), (1,0), (0,1)\\}$；$\\phi_4(x,y) = x + y - 2$。\n\n### 第2步：使用提取的已知信息进行验证\n对问题进行验证：\n- **科学依据**：该问题是 XFEM 中处理不与网格贴合的不连续性的标准程序。它基于微积分和计算几何的基本原理。问题有效。\n- **适定性**：积分域 $\\Omega_+$ 是一个紧致的凸集（一个多边形、完整的三角形或空集）。被积函数 $f(x,y)$ 是一个多项式，因此在 $\\Omega_+$ 上是连续且有界的。该积分是明确定义的，并且具有唯一的值。问题有效。\n- **客观性**：问题使用精确的数学语言陈述，没有任何主观或模棱两可的术语。问题有效。\n- **完整性与一致性**：为每个测试用例提供了所有必要的数据（顶点、直线系数、被积函数）。没有矛盾之处。问题有效。\n\n### 第3步：结论与行动\n问题被判定为 **有效**。将构建一个严谨的解决方案。\n\n### 求解方法论\n\n问题的核心是计算积分 $I = \\iint_{\\Omega_+} (x^2+y) \\, \\mathrm{d}A$。积分域 $\\Omega_+$ 是父三角形 $T$ 中水平集函数 $\\phi(x,y)$ 为非负的部分。$\\Omega_+$ 的性质取决于在 $T$ 的顶点处计算出的 $\\phi$ 值的符号。设三角形顶点为 $V_1, V_2, V_3$。我们计算 $i=1,2,3$ 对应的 $\\phi_i = \\phi(V_i)$。\n\n策略是根据有多少顶点位于正半平面（即 $\\phi \\ge 0$ 的区域）内对构型进行分类。\n\n1.  **所有顶点位于正半平面**：如果所有的 $\\phi_i \\ge 0$，则整个三角形 $T$ 就是积分域，即 $\\Omega_+ = T$。\n2.  **所有顶点位于负半平面**：如果所有的 $\\phi_i  0$，则 $\\Omega_+$ 是空集，积分为 $0$。\n3.  **直线切割三角形**：如果顶点的 $\\phi$ 值有正有负，则直线 $\\phi(x,y)=0$ 与三角形相交。积分域 $\\Omega_+$ 是一个凸多边形（三角形或四边形）。\n    - **一个顶点位于正半平面**：如果一个顶点（例如 $V_p$）满足 $\\phi(V_p) \\ge 0$，而另外两个顶点（$V_{n1}, V_{n2}$）的 $\\phi$ 值为负，则积分域 $\\Omega_+$ 是一个较小的三角形。其顶点是 $V_p$ 以及直线 $\\phi=0$ 与边 $(V_p, V_{n1})$ 和 $(V_p, V_{n2})$ 的两个交点。\n    - **两个顶点位于正半平面**：如果两个顶点（例如 $V_{p1}, V_{p2}$）满足 $\\phi \\ge 0$，而一个顶点（$V_n$）的 $\\phi$ 值为负，则积分域 $\\Omega_+$ 是一个四边形。一种直接且稳健的计算积分的方法是从整个三角形的积分中减去被切掉的小部分上的积分。被切掉的部分是一个三角形，其顶点为 $V_n$ 以及直线 $\\phi=0$ 与边 $(V_n, V_{p1})$ 和 $(V_n, V_{p2})$ 的两个交点。\n\n连接顶点 $A$ 和 $B$ 的边上的交点 $P_{int}$ 可以通过将该边参数化为 $P(t) = A + t(B-A)$（其中 $t \\in [0,1]$）来找到。根据 $\\phi$ 的线性性质，我们有 $\\phi(P(t)) = (1-t)\\phi(A) + t\\phi(B) = 0$。解出 $t$ 得到 $t = \\phi(A) / (\\phi(A) - \\phi(B))$。那么交点就是 $P_{int} = A + t(B-A)$。\n\n为了计算多项式 $f(x,y)=x^2+y$ 在任意三角形上的积分，我们使用一个对二次多项式精确的数值积分法则。一个位于三角形各边中点的三点积分法则满足此要求。对于面积为 $A'$ 的三角形 $T'$，其积分由下式给出：\n$$\n\\iint_{T'} f(x,y) \\, \\mathrm{d}A = \\frac{A'}{3} \\sum_{k=1}^{3} f(m_k)\n$$\n其中 $m_k$ 是 $T'$ 三条边的中点。具有顶点 $(x_1, y_1), (x_2, y_2), (x_3, y_3)$ 的三角形的面积 $A'$ 计算公式为 $A' = \\frac{1}{2} |x_1(y_2 - y_3) + x_2(y_3 - y_1) + x_3(y_1 - y_2)|$。\n\n该方法论为解决所有给定测试用例提供了完整而系统的方法。\n\n### 逐案分析\n\n- **测试用例 1**：顶点 $V_1(0,0), V_2(1,0), V_3(0,1)$。直线 $\\phi(x,y) = x+y-0.5$。\n$\\phi(V_1) = -0.5$, $\\phi(V_2) = 0.5$, $\\phi(V_3)=0.5$。\n这是一个“两正一负”的情况。我们计算整个父三角形 $T$ 上的积分，然后减去由 $V_1$ 和在边 $(V_1,V_2)$、$(V_1,V_3)$ 上的交点构成的小切割三角形上的积分。\n- **测试用例 2**：顶点 $V_1(0,0), V_2(1,0), V_3(0,1)$。直线 $\\phi(x,y) = x+y+1$。\n$\\phi(V_1)=1$, $\\phi(V_2)=2$, $\\phi(V_3)=2$。全部为正。积分在整个三角形 $T$ 上进行。\n- **测试用例 3**：顶点 $V_1(0,0), V_2(2,0), V_3(0,1)$。直线 $\\phi(x,y) = -x+y$。\n$\\phi(V_1)=0$, $\\phi(V_2)=-2$, $\\phi(V_3)=1$。这被视为“两正（$\\phi \\ge 0$）一负”的情况。\n- **测试用例 4**：顶点 $V_1(0,0), V_2(1,0), V_3(0,1)$。直线 $\\phi(x,y) = x+y-2$。\n$\\phi(V_1)=-2$, $\\phi(V_2)=-1$, $\\phi(V_3)=-1$。全部为负。积分域为空集，因此积分为 $0$。\n\n实现将遵循此逻辑来计算所需的值。",
            "answer": "```python\nimport numpy as np\n\ndef integrate_over_triangle(vertices):\n    \"\"\"\n    Computes the integral of f(x,y) = x^2 + y over a triangle using a\n    3-point midpoint quadrature rule, which is exact for quadratic polynomials.\n    \n    Args:\n        vertices (list of tuples): A list of three (x, y) tuples for the triangle vertices.\n\n    Returns:\n        float: The value of the integral.\n    \"\"\"\n    p1, p2, p3 = np.array(vertices[0]), np.array(vertices[1]), np.array(vertices[2])\n\n    # Integrand function\n    f = lambda p: p[0]**2 + p[1]\n\n    # Area of the triangle\n    area = 0.5 * abs(p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1]))\n\n    if area  1e-12:  # Degenerate triangle\n        return 0.0\n\n    # Midpoints of the edges\n    m1 = (p1 + p2) / 2.0\n    m2 = (p2 + p3) / 2.0\n    m3 = (p3 + p1) / 2.0\n\n    # Evaluate function at midpoints\n    f_vals = [f(m1), f(m2), f(m3)]\n\n    # Apply quadrature rule\n    integral = (area / 3.0) * sum(f_vals)\n    return integral\n\n\ndef calculate_integral_for_case(triangle_verts, line_coeffs):\n    \"\"\"\n    Calculates the integral for a single test case by determining the\n    integration domain and applying the appropriate integration strategy.\n    \n    Args:\n        triangle_verts (list of tuples): Vertices of the parent triangle.\n        line_coeffs (tuple): Coefficients (a, b, c) of the line ax+by+c=0.\n    \n    Returns:\n        float: The final computed integral.\n    \"\"\"\na, b, c = line_coeffs\n    phi = lambda p: a*p[0] + b*p[1] + c\n    \n    V = [np.array(v) for v in triangle_verts]\n    phi_vals = np.array([phi(v) for v in V])\n    \n    pos_indices = [i for i, pv in enumerate(phi_vals) if pv >= 0]\n    neg_indices = [i for i, pv in enumerate(phi_vals) if pv  0]\n\n    # Case 1: All vertices in the positive half-plane (phi >= 0)\n    if len(pos_indices) == 3:\n        return integrate_over_triangle(V)\n        \n    # Case 2: All vertices in the negative half-plane (phi  0)\n    if len(neg_indices) == 3:\n        return 0.0\n\n    # Case 3: Line cuts the triangle.\n    # Case 3a: One vertex has phi >= 0, two have phi  0.\n    # The integration domain is a small triangle.\n    if len(pos_indices) == 1:\n        p_idx = pos_indices[0]\n        n_idx1, n_idx2 = neg_indices\n        \n        Vp, Vn1, Vn2 = V[p_idx], V[n_idx1], V[n_idx2]\n        phi_p, phi_n1, phi_n2 = phi_vals[p_idx], phi_vals[n_idx1], phi_vals[n_idx2]\n        \n        # Intersection on edge (Vp, Vn1)\n        t1 = phi_p / (phi_p - phi_n1)\n        I1 = Vp + t1 * (Vn1 - Vp)\n        \n        # Intersection on edge (Vp, Vn2)\n        t2 = phi_p / (phi_p - phi_n2)\n        I2 = Vp + t2 * (Vn2 - Vp)\n        \n        integration_triangle = [Vp, I1, I2]\n        return integrate_over_triangle(integration_triangle)\n\n    # Case 3b: Two vertices have phi >= 0, one has phi  0.\n    # The integration domain is a quadrilateral. We compute its integral by subtraction.\n    if len(pos_indices) == 2:\n        n_idx = neg_indices[0]\n        p_idx1, p_idx2 = pos_indices\n        \n        integral_total = integrate_over_triangle(V)\n        \n        Vn, Vp1, Vp2 = V[n_idx], V[p_idx1], V[p_idx2]\n        phi_n, phi_p1, phi_p2 = phi_vals[n_idx], phi_vals[p_idx1], phi_vals[p_idx2]\n        \n        # Intersection on edge (Vn, Vp1)\n        t1 = phi_n / (phi_n - phi_p1)\n        I1 = Vn + t1 * (Vp1 - Vn)\n        \n        # Intersection on edge (Vn, Vp2)\n        t2 = phi_n / (phi_n - phi_p2)\n        I2 = Vn + t2 * (Vp2 - Vn)\n        \n        cutoff_triangle = [Vn, I1, I2]\n        integral_cutoff = integrate_over_triangle(cutoff_triangle)\n\n        return integral_total - integral_cutoff\n    \n    return 0.0 # Should not be reached with valid triangle inputs\n\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        ([(0, 0), (1, 0), (0, 1)], (1, 1, -0.5)),\n        # Test case 2\n        ([(0, 0), (1, 0), (0, 1)], (1, 1, 1)),\n        # Test case 3\n        ([(0, 0), (2, 0), (0, 1)], (-1, 1, 0)),\n        # Test case 4\n        ([(0, 0), (1, 0), (0, 1)], (1, 1, -2)),\n    ]\n\n    results = []\n    for triangle_verts, line_coeffs in test_cases:\n        result = calculate_integral_for_case(triangle_verts, line_coeffs)\n        results.append(result)\n\n    # Format and print the final output\n    print(f\"[{','.join(f'{r:.16f}'.rstrip('0').rstrip(\".\") for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}