{
    "hands_on_practices": [
        {
            "introduction": "从点云生成高质量的网格是许多计算工程应用的起点。本练习将指导您实现经典的Bowyer-Watson算法，这是一种用于构建二维德劳内(Delaunay)三角剖分的增量方法。通过从头开始构建此算法，您将不仅学习网格生成的核心逻辑，还将直面处理数值稳定性的挑战，深刻理解保证网格质量的“空外接圆”准则。 ",
            "id": "2412570",
            "problem": "实现一个完整的程序，该程序使用 Bowyer–Watson 增量插入法为给定的有限平面点集构建二维 Delaunay 三角剖分，然后定量地验证所得网格的关键属性。您的实现必须从平面三角剖分和 Delaunay 空外接圆条件的基本定义出发，并且必须是自包含的。\n\n从以下基本概念开始：\n- $\\mathbb{R}^2$ 中有限点集的平面三角剖分，是该点集凸包的一种分解，将其分解为多个不重叠的三角形，这些三角形的顶点是点集中的点，且它们的并集等于该凸包。\n- $\\mathbb{R}^2$ 中有限点集的 Delaunay 三角剖分（由 Boris Delaunay 首次定义）是满足以下条件的任意一种三角剖分：每个三角形的开放外接圆内不包含点集中的任何其他点。等价地，对于每个顶点为 $\\mathbf{a}$、$\\mathbf{b}$ 和 $\\mathbf{c}$ 的三角形，若 $\\mathbf{o}$ 是其外心，$r$ 是其外接圆半径，则对于任何其他点 $\\mathbf{p}$，必须满足 $\\|\\mathbf{p}-\\mathbf{o}\\|_2 > r$。允许 $\\|\\mathbf{p}-\\mathbf{o}\\|_2 = r$ 作为一种非唯一性的边界情况。\n- 非退化三角形的外心是其三条边的垂直平分线的唯一交点。\n\n您的程序必须：\n1. 从基本原理出发，按如下方式实现 Bowyer–Watson 插入方案。首先，创建一个严格包含所有输入点的外围超级三角形。然后逐一插入点。对于每个插入的点，找出其外接圆包含该点的所有当前三角形（这些是“坏”三角形），删除它们，计算生成的空腔的边界多边形（即那些恰好只与一个被删除三角形相邻的边），最后通过将新点连接到每个边界边来对空腔进行重新三角化。所有点插入完毕后，移除任何包含超级三角形顶点的三角形。\n2. 使用基于上述定义构建的稳定数值谓词。在测试点 $\\mathbf{p}$ 是否位于外接圆内时，计算外心 $\\mathbf{o}$ 和外接圆半径的平方 $r^2$，并使用一个小的容差 $\\varepsilon > 0$ 来比较 $\\|\\mathbf{p}-\\mathbf{o}\\|_2^2$ 和 $r^2$，以将严格的“内部”不等式实现为 $\\|\\mathbf{p}-\\mathbf{o}\\|_2^2 \\le r^2 - \\varepsilon$。面积小于某个容差的退化三角形应在包含性测试中被忽略。\n3. 在一个小的容差范围内对输入点进行去重，以避免重复的顶点，并确保算法在遇到近似共线和近似共圆配置时保持稳健。\n\n对于下面的每个测试用例，您的程序必须返回三个量：\n- 最终三角剖分中的三角形数量 $T$（一个整数）。\n- 一个布尔值，指示在使用上述带容差的严格内部定义对所有其他点进行检查时，空外接圆条件是否对所有三角形都成立。\n- 所有三角形的面积之和（一个浮点数），四舍五入到 $6$ 位小数。该数值必须从基本原理出发，使用每个顶点为 $\\mathbf{a}$、$\\mathbf{b}$ 和 $\\mathbf{c}$ 的三角形的欧几里得面积公式 $\\frac{1}{2}\\left|(\\mathbf{b}-\\mathbf{a}) \\times (\\mathbf{c}-\\mathbf{a})\\right|$ 计算，其中 $\\times$ 表示二维叉积的标量 $z$ 分量。\n\n此问题中不使用角度单位。所有量均为无量纲量。\n\n测试套件：\n- 案例 A（带内部点的凸正方形）：点 $[(0,0),(1,0),(1,1),(0,1),(0.5,0.5)]$。\n- 案例 B（单位圆上的正五边形，一个近似共圆的压力测试）：点 $\\left(\\cos\\left(\\frac{2\\pi k}{5}\\right),\\sin\\left(\\frac{2\\pi k}{5}\\right)\\right)$，其中 $k \\in \\{0,1,2,3,4\\}$。\n- 案例 C（沿一条凸包边的共线子集）：点 $[(0,0),(1,0),(2,0),(2,1),(0,1)]$。\n- 案例 D（存在重复点）：点 $[(0,0),(1,0),(1,1),(0,1),(1,1)]$。\n- 案例 E（单位正方形内的一般内部点集）：点 $[(0.1,0.1),(0.9,0.1),(0.9,0.9),(0.1,0.9),(0.5,0.2),(0.8,0.5),(0.3,0.6),(0.5,0.8)]$。\n\n输出规范：\n- 对于每个案例，输出一个形式为 $[T,\\texttt{delaunay\\_ok},\\texttt{area\\_sum}]$ 的列表，其中 $T$ 是整数，$\\texttt{delaunay\\_ok}$ 是布尔值，$\\texttt{area\\_sum}$ 是如上定义的四舍五入到 $6$ 位小数的浮点数。\n- 您的程序应生成单行输出，其中包含所有五个案例的结果，形式为一个用方括号括起来的逗号分隔列表，例如：$[[\\dots],[\\dots],[\\dots],[\\dots],[\\dots]]$。",
            "solution": "所提出的问题要求实现用于二维 Delaunay 三角剖分的 Bowyer-Watson 算法。该解决方案必须从基本原理构建，并包含对最终网格属性的验证。该问题被验证为科学上合理、定义明确且客观。它涉及计算几何中的一个标准主题，并提供了清晰、可测试的要求。\n\n解决方案的核心是 Bowyer-Watson 算法的逐步实现。该算法是一种增量方法，通过一次添加一个点来构建三角剖分。首先定义基本的几何构造。一个点是一个向量 $\\mathbf{p} \\in \\mathbb{R}^2$。一个三角形由三个顶点 $(\\mathbf{v}_1, \\mathbf{v}_2, \\mathbf{v}_3)$ 定义，这些顶点是点坐标主列表中的索引。\n\n具有顶点 $\\mathbf{a}=(a_x, a_y)$、$\\mathbf{b}=(b_x, b_y)$ 和 $\\mathbf{c}=(c_x, c_y)$ 的三角形面积使用二维叉积公式计算：\n$$ A = \\frac{1}{2} |a_x(b_y - c_y) + b_x(c_y - a_y) + c_x(a_y - b_y)| $$\n如果一个三角形的面积小于一个小的容差 $\\tau_{area}$，则认为该三角形是退化的，这种情况发生在顶点几乎共线时。\n\n对于非退化三角形，其外接圆是唯一定义的。外心 $\\mathbf{o}=(o_x, o_y)$ 是三角形边的垂直平分线的交点。其坐标可以直接从顶点坐标计算得出：\n$$ D = 2 (a_x(b_y - c_y) + b_x(c_y - a_y) + c_x(a_y - b_y)) $$\n$$ o_x = \\frac{1}{D} ( (a_x^2+a_y^2)(b_y-c_y) + (b_x^2+b_y^2)(c_y-a_y) + (c_x^2+c_y^2)(a_y-b_y) ) $$\n$$ o_y = \\frac{1}{D} ( (a_x^2+a_y^2)(c_x-b_x) + (b_x^2+b_y^2)(a_x-c_x) + (c_x^2+c_y^2)(b_x-a_x) ) $$\n分母 $D$ 是有向面积的两倍。如果 $|D|$ 小于一个容差，则外心计算是病态的，并会中止。然后，外接圆半径的平方为 $r^2 = \\|\\mathbf{a} - \\mathbf{o}\\|_2^2$。\n\nBowyer-Watson 算法中的关键测试是确定一个点 $\\mathbf{p}$ 是否位于三角形的外接圆内。根据问题陈述，这被实现为一个带容差 $\\varepsilon > 0$ 的严格“内部”测试：\n$$ \\|\\mathbf{p}-\\mathbf{o}\\|_2^2 \\le r^2 - \\varepsilon $$\n这种公式通过将位于圆边界上或非常靠近边界的点分类为“外部”，来稳健地处理点几乎共圆的情况。\n\n算法流程如下：\n$1$。**预处理**：对输入点进行去重。如果点 $\\mathbf{p}_i, \\mathbf{p}_j$ 之间的欧几里得距离 $\\|\\mathbf{p}_i - \\mathbf{p}_j\\|_2$ 小于一个容差 $\\tau_{dist}$，则认为它们是相同的。\n$2$。**初始化**：创建一个保证能包围所有输入点的“超级三角形”。这是通过找到点的边界框并在其周围构建一个大得多的三角形来完成的。初始三角剖分仅包含这个超级三角形。其顶点被添加到全局点列表中。\n$3$。**增量插入**：将每个输入点 $\\mathbf{p}_{new}$ 插入到三角剖分中：\n    a. 找到“坏”三角形的集合。如果 $\\mathbf{p}_{new}$ 位于一个三角形的外接圆内，则该三角形是坏的。\n    b. 移除坏三角形，形成一个多边形空腔。该空腔的边界由恰好属于一个坏三角形的边组成。\n    c. 通过创建新三角形来对空腔进行重新三角化，每个新三角形由边界多边形的一条边和点 $\\mathbf{p}_{new}$ 构成。\n    d. 用新三角形替换坏三角形，从而更新活动三角形列表。\n$4$。**终结处理**：插入所有点后，丢弃任何与超级三角形共享顶点的三角形。剩余的集合就是输入点的 Delaunay 三角剖分。\n\n最后，对于每个测试用例，从生成的三角剖分中计算所需的度量：\n- $T$：最终网格中的三角形总数。\n- $\\texttt{delaunay\\_ok}$：一个布尔标志。如果对于网格中的每个三角形，输入集中的没有其他点严格位于其外接圆内部（使用相同的带容差检查进行验证），则设置为 $\\texttt{True}$。否则，设置为 $\\texttt{False}$。\n- $\\texttt{area\\_sum}$：最终网格中所有三角形的面积之和，四舍五入到 $6$ 位小数。在最终四舍五入之前，使用保持精度的方法计算总和。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\nfrom collections import Counter\n\n# Global tolerances for numerical stability\nEPSILON_CIRCUMCIRCLE = 1e-9\nDEDUPLICATION_TOL = 1e-9\nAREA_TOL = 1e-12\n\nclass Triangle:\n    \"\"\"\n    Represents a triangle with vertices and its circumcircle.\n    Vertices are stored as indices into a global list of points.\n    \"\"\"\n    def __init__(self, v1_idx, v2_idx, v3_idx, points):\n        self.v_indices = (v1_idx, v2_idx, v3_idx)\n        self.vertices = (points[v1_idx], points[v2_idx], points[v3_idx])\n        \n        self.circumcenter = None\n        self.radius_sq = None\n        \n        self.area = self._calculate_area()\n        if self.area  AREA_TOL:\n            self.is_degenerate = True\n        else:\n            self.is_degenerate = False\n            self._calculate_circumcircle()\n\n    def _calculate_area(self):\n        a, b, c = self.vertices\n        # Using the Shoelace formula for area\n        return 0.5 * abs(a[0]*(b[1]-c[1]) + b[0]*(c[1]-a[1]) + c[0]*(a[1]-b[1]))\n\n    def _calculate_circumcircle(self):\n        a, b, c = self.vertices\n        ax, ay = a\n        bx, by = b\n        cx, cy = c\n        \n        D = 2 * (ax * (by - cy) + bx * (cy - ay) + cx * (ay - by))\n\n        if abs(D)  AREA_TOL:\n            # This should be caught by the area check, but as a safeguard\n            self.is_degenerate = True\n            return\n\n        asq = ax**2 + ay**2\n        bsq = bx**2 + by**2\n        csq = cx**2 + cy**2\n\n        ux = (asq * (by - cy) + bsq * (cy - ay) + csq * (ay - by)) / D\n        uy = (asq * (cx - bx) + bsq * (ax - cx) + csq * (bx - ax)) / D\n        \n        self.circumcenter = np.array([ux, uy])\n        self.radius_sq = (ax - ux)**2 + (ay - uy)**2\n\n    def contains_point_in_circumcircle(self, p):\n        if self.is_degenerate or self.circumcenter is None:\n            return False\n        \n        dist_sq = np.sum((p - self.circumcenter)**2)\n        # Strict inequality check with tolerance\n        return dist_sq = self.radius_sq - EPSILON_CIRCUMCIRCLE\n\n    def get_edges(self):\n        # Return edges with sorted vertex indices to make them canonical for comparison\n        v1, v2, v3 = self.v_indices\n        return [\n            tuple(sorted((v1, v2))),\n            tuple(sorted((v2, v3))),\n            tuple(sorted((v3, v1)))\n        ]\n\ndef bowyer_watson(points):\n    \"\"\"\n    Constructs a Delaunay triangulation of a set of 2D points.\n    \"\"\"\n    # 1. Deduplicate points\n    unique_points_list = []\n    if points:\n        unique_points_list.append(points[0])\n        for p_in in points[1:]:\n            p_arr = np.array(p_in)\n            is_duplicate = False\n            for up in unique_points_list:\n                if np.linalg.norm(p_arr - np.array(up))  DEDUPLICATION_TOL:\n                    is_duplicate = True\n                    break\n            if not is_duplicate:\n                unique_points_list.append(p_in)\n    \n    unique_points = [np.array(p) for p in unique_points_list]\n    num_input_points = len(unique_points)\n    \n    if num_input_points  3:\n        return [], unique_points\n\n    # 2. Create super-triangle\n    min_x = min(p[0] for p in unique_points)\n    max_x = max(p[0] for p in unique_points)\n    min_y = min(p[1] for p in unique_points)\n    max_y = max(p[1] for p in unique_points)\n    \n    dx = max_x - min_x\n    dy = max_y - min_y\n    delta_max = max(dx, dy, 1.0) # Ensure non-zero for single-point case\n    center = np.array([(min_x + max_x) / 2, (min_y + max_y) / 2])\n    \n    # Large triangle enclosing the bounding box\n    s_v1 = center + np.array([-3 * delta_max, -3 * delta_max])\n    s_v2 = center + np.array([3 * delta_max, -3 * delta_max])\n    s_v3 = center + np.array([0, 3 * delta_max])\n    \n    all_points = unique_points + [s_v1, s_v2, s_v3]\n    st_idx1, st_idx2, st_idx3 = num_input_points, num_input_points + 1, num_input_points + 2\n\n    triangulation = [Triangle(st_idx1, st_idx2, st_idx3, all_points)]\n\n    # 3. Incremental insertion\n    for i in range(num_input_points):\n        point_to_add = all_points[i]\n        \n        bad_triangles = [t for t in triangulation if t.contains_point_in_circumcircle(point_to_add)]\n        \n        polygon_edges = []\n        for t in bad_triangles:\n            polygon_edges.extend(t.get_edges())\n        \n        edge_counts = Counter(polygon_edges)\n        boundary_edges = [edge for edge, count in edge_counts.items() if count == 1]\n        \n        triangulation = [t for t in triangulation if t not in bad_triangles]\n        \n        for edge in boundary_edges:\n            new_triangle = Triangle(edge[0], edge[1], i, all_points)\n            triangulation.append(new_triangle)\n            \n    # 4. Finalization\n    final_triangulation = []\n    for t in triangulation:\n        is_super_triangle = any(v_idx >= num_input_points for v_idx in t.v_indices)\n        if not is_super_triangle:\n            final_triangulation.append(t)\n            \n    return final_triangulation, all_points[:num_input_points]\n\ndef process_case(points):\n    \"\"\"\n    Runs the full process for one test case and returns the required metrics.\n    \"\"\"\n    final_triangulation, final_points = bowyer_watson(points)\n    \n    # 1. Number of triangles\n    T = len(final_triangulation)\n    \n    # 2. Verify Delaunay condition\n    delaunay_ok = True\n    if T > 0:\n        for t in final_triangulation:\n            # We don't verify against degenerate triangles in the mesh\n            if t.is_degenerate:\n                continue\n            \n            for i, p in enumerate(final_points):\n                if i in t.v_indices:\n                    continue\n                \n                if t.contains_point_in_circumcircle(p):\n                    delaunay_ok = False\n                    break\n            if not delaunay_ok:\n                break\n    \n    # 3. Sum of areas\n    area_sum = math.fsum(t.area for t in final_triangulation)\n    \n    return [T, delaunay_ok, round(area_sum, 6)]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: convex square with interior point\n        [(0,0),(1,0),(1,1),(0,1),(0.5,0.5)],\n        # Case B: regular pentagon\n        [(np.cos(2 * np.pi * k / 5), np.sin(2 * np.pi * k / 5)) for k in range(5)],\n        # Case C: collinear subset\n        [(0,0),(1,0),(2,0),(2,1),(0,1)],\n        # Case D: duplicate point present\n        [(0,0),(1,0),(1,1),(0,1),(1,1)],\n        # Case E: general interior set\n        [(0.1,0.1),(0.9,0.1),(0.9,0.9),(0.1,0.9),(0.5,0.2),(0.8,0.5),(0.3,0.6),(0.5,0.8)]\n    ]\n\n    results = []\n    for case in test_cases:\n        result = process_case(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The format is a list of lists, which str() handles correctly.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "成功生成网格仅仅是第一步；确保其质量对于后续的仿真精度和稳定性至关重要。本练习将引导您为三维四面体网格实现一套核心的几何质量评估指标，包括纵横比、偏斜度和雅可比行列式。通过亲手编写代码来量化单元的变形与有效性，您将掌握验证网格和诊断仿真问题的关键实用技能。 ",
            "id": "2412640",
            "problem": "您的任务是设计并实现一个完整、可运行的程序，用于评估非结构化三维线性四面体网格中单元的三个几何质量度量。该网格由三维欧几里得空间 $\\mathbb{R}^3$ 中的节点坐标和单元连接关系定义。您的实现必须从线性映射和欧几里得几何的第一性原理出发，并且必须为每个四面体单元计算以下指标，然后在网格级别上进行聚合：纵横比、偏斜度和等参映射的雅可比行列式。所有计算都应使用无量纲量进行；不涉及物理单位。\n\n基本定义和假设：\n\n- 一个线性四面体单元由四个不同的节点定义，其坐标为 $\\mathbf{x}_1,\\mathbf{x}_2,\\mathbf{x}_3,\\mathbf{x}_4 \\in \\mathbb{R}^3$。从参考四面体到物理四面体的相应仿射映射为\n$$\n\\mathbf{x}(\\boldsymbol{\\xi}) \\;=\\; \\mathbf{x}_1 \\;+\\; J \\,\\boldsymbol{\\xi},\n$$\n其中 $J \\in \\mathbb{R}^{3 \\times 3}$ 是雅可比矩阵，其列为 $J = \\begin{bmatrix} \\mathbf{x}_2-\\mathbf{x}_1  \\mathbf{x}_3-\\mathbf{x}_1  \\mathbf{x}_4-\\mathbf{x}_1 \\end{bmatrix}$，且 $\\boldsymbol{\\xi}\\in\\mathbb{R}^3$ 位于参考四面体内。对于线性四面体，$J$ 在整个单元上是恒定的。单元的有符号体积 $V$ 满足 $V = \\det(J)/6$。\n\n- 向量 $\\mathbf{v}\\in\\mathbb{R}^3$ 的欧几里得范数为 $\\lVert \\mathbf{v}\\rVert_2 = \\sqrt{\\mathbf{v}^\\top \\mathbf{v}}$。\n\n- 奇异值分解 (SVD) 将 $J$ 写为 $J = U \\Sigma V^\\top$，其中 $U,V\\in\\mathbb{R}^{3\\times 3}$ 是正交矩阵，$\\Sigma = \\operatorname{diag}(\\sigma_1,\\sigma_2,\\sigma_3)$，奇异值为 $\\sigma_1 \\ge \\sigma_2 \\ge \\sigma_3 \\ge 0$。行列式满足 $\\det(J) = \\sigma_1 \\sigma_2 \\sigma_3 \\cdot \\det(U)\\det(V)$，其绝对值为 $\\lvert \\det(J)\\rvert = \\sigma_1 \\sigma_2 \\sigma_3$。\n\n需要从第一性原理计算的单元级质量度量：\n\n1. 纵横比 (Aspect ratio)。设六条边的长度为 $l_{ij} = \\lVert \\mathbf{x}_i - \\mathbf{x}_j\\rVert_2$，其中索引对 $(i,j)\\in\\{(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)\\}$。单元纵横比定义为\n$$\n\\mathrm{AR} \\;=\\; \\frac{\\max l_{ij}}{\\min l_{ij}}.\n$$\n如果任何 $l_{ij} = 0$（退化边），则定义 $\\mathrm{AR}$ 为 $+\\infty$。\n\n2. 偏斜度 (Skewness)。使用 $J$ 的奇异值，将偏斜度定义为\n$$\n\\mathrm{SK} \\;=\\; 1 - \\frac{\\sigma_{\\min}(J)}{\\sigma_{\\max}(J)} \\;=\\; 1 - \\frac{\\sigma_3}{\\sigma_1}.\n$$\n如果 $\\sigma_1 = 0$（完全退化），则定义 $\\mathrm{SK} = 1$。对于非退化单元，该度量位于 $[0,1]$ 区间内，其中 $\\mathrm{SK}=0$ 表示映射列的各向同性，而接近 $1$ 的值表示严重的各向异性或接近退化。\n\n3. 雅可比行列式 (Jacobian determinant)。对每个单元，计算有符号雅可比行列式\n$$\n\\mathrm{JAC} \\;=\\; \\det(J).\n$$\n负值表示方向反转。单元体积为 $V = \\mathrm{JAC}/6$。\n\n网格级聚合：\n\n- 对于给定网格，将其最差纵横比定义为所有单元中最大的 $\\mathrm{AR}$。\n- 将其最差偏斜度定义为所有单元中最大的 $\\mathrm{SK}$。\n- 将其最小雅可比行列式定义为所有单元中最小的 $\\mathrm{JAC}$。\n\n程序要求：\n\n- 为一个简单的内存中网格描述格式实现一个解析器，该格式代表一个非结构化四面体网格。每个网格包含一组节点和一组引用这些节点的四面体单元。您的程序必须将网格作为字符串常量内嵌在内部；它不能读取外部文件或要求用户输入。格式如下：\n  - 一行 \"NODES $N$\"，后跟 $N$ 行，每行包含 \"$\\text{id}\\; x\\; y\\; z$\"，其中 $\\text{id}$ 为整数， $x,y,z$ 为实数坐标。\n  - 一行 \"ELEMENTS $M$\"，后跟 $M$ 行，每行包含 \"$\\text{id}\\; n_1\\; n_2\\; n_3\\; n_4$\"，其中 $\\text{id}$ 为整数， $n_k$ 为整数节点索引。\n\n- 对每个四面体单元，仅使用提供的基本运算和定义来计算上述的 $\\mathrm{AR}$、$\\mathrm{SK}$ 和 $\\mathrm{JAC}$。\n\n- 按照规定对每个网格进行聚合，为每个网格生成三个值：最差纵横比、最差偏斜度和最小雅可比行列式。\n\n需要由您的程序内嵌并评估的测试套件：\n\n- 测试网格 A（形状良好，类似等边）。节点：\n  - $\\mathbf{x}_1 = (0,\\,0,\\,0)$,\n  - $\\mathbf{x}_2 = (1,\\,0,\\,0)$,\n  - $\\mathbf{x}_3 = \\left(\\tfrac{1}{2},\\,\\tfrac{\\sqrt{3}}{2},\\,0\\right)$,\n  - $\\mathbf{x}_4 = \\left(\\tfrac{1}{2},\\,\\tfrac{\\sqrt{3}}{6},\\,\\tfrac{\\sqrt{6}}{3}\\right)$.\n  一个单元，连接关系为 $(1,2,3,4)$。\n\n- 测试网格 B（接近退化的细条状单元，体积非常小）。节点：\n  - $\\mathbf{x}_1 = (0,\\,0,\\,0)$,\n  - $\\mathbf{x}_2 = (2,\\,0,\\,0)$,\n  - $\\mathbf{x}_3 = (0,\\,2,\\,0)$,\n  - $\\mathbf{x}_4 = (1,\\,1,\\,10^{-6})$.\n  一个单元，连接关系为 $(1,2,3,4)$。\n\n- 测试网格 C（方向反转）。节点坐标与测试网格 A 相同，但单个单元的连接关系为 $(1,3,2,4)$，因此映射方向是反转的。\n\n要求的最终输出格式：\n\n- 您的程序必须生成单行输出，其中包含一个含三个列表的列表，每个列表对应一个测试网格，严格按照 A、B、C 的顺序。每个内部列表必须包含三个浮点数，顺序为该网格的 $[\\mathrm{AR}_\\text{worst}, \\mathrm{SK}_\\text{worst}, \\mathrm{JAC}_\\text{min}]$。将每个数字四舍五入到六位小数。整体输出格式必须严格为\n$$\n\\big[ [a_1,s_1,j_1], [a_2,s_2,j_2], [a_3,s_3,j_3] \\big]\n$$\n其中数值条目以四舍五入到六位小数的小数形式呈现，且无附加文本。例如，一个可接受的结构是\n$[[1.000000,0.375000,0.707107],[\\dots],[\\dots]]$。",
            "solution": "该问题要求设计并实现一个程序，以评估三维四面体网格的三个基本几何质量度量：纵横比、偏斜度和等参映射的雅可比行列式。评估必须针对几个测试网格进行，并且结果要在网格级别上进行聚合。问题陈述的验证已经完成，确认其具有科学依据、提法明确且完整。我们现在开始详细的解答，从指定的基础原理入手。\n\n任务的核心是分析每个四面体单元的几何形状。一个线性四面体由四个节点 $\\mathbf{x}_1, \\mathbf{x}_2, \\mathbf{x}_3, \\mathbf{x}_4 \\in \\mathbb{R}^3$ 定义。其几何特性由一个仿射变换来表征，该变换将一个标准的参考四面体映射到 $\\mathbb{R}^3$ 中的物理单元。该映射由 $\\mathbf{x}(\\boldsymbol{\\xi}) = \\mathbf{x}_1 + J \\boldsymbol{\\xi}$ 给出，其中 $\\boldsymbol{\\xi}$ 是参考空间中的坐标，$J \\in \\mathbb{R}^{3 \\times 3}$ 是该变换的雅可比矩阵。对于线性四面体，此雅可比矩阵在整个单元上是常数。\n\n在计算力学中，标准的参考四面体其顶点位于坐标元组 $(0,0,0)$, $(1,0,0)$, $(0,1,0)$ 和 $(0,0,1)$ 处。仿射映射的构造方式是使这些参考顶点分别映射到物理节点 $\\mathbf{x}_1, \\mathbf{x}_2, \\mathbf{x}_3, \\mathbf{x}_4$。这导致雅可比矩阵的列被定义为从第一个节点 $\\mathbf{x}_1$ 出发的物理四面体的边向量：\n$$\nJ = \\begin{bmatrix} (\\mathbf{x}_2 - \\mathbf{x}_1)  (\\mathbf{x}_3 - \\mathbf{x}_1)  (\\mathbf{x}_4 - \\mathbf{x}_1) \\end{bmatrix}.\n$$\n这个矩阵 $J$ 和单元的边长集合是推导所有所需度量的基础量。\n\n计算过程结构如下：\n1.  解析所提供的网格数据（以特定的字符串格式给出），以建立节点坐标和单元连接关系。\n2.  对于网格中的每个单元，检索其四个定义节点的坐标。\n3.  计算三个指定的单元级质量度量：纵横比 (AR)、偏斜度 (SK) 和雅可比行列式 (JAC)。\n4.  在网格的所有单元上聚合这些度量，以找到最差纵横比、最差偏斜度和最小雅可比行列式。\n5.  对所有测试网格重复此过程，并按要求格式化最终结果。\n\n我们现在详细说明每个度量的计算方法。\n\n1.  **纵横比 ($\\mathrm{AR}$)**\n    纵横比是衡量一个单元与理想形状（例如，等边四面体）相比扭曲程度的度量。它基于单元的六条边的长度定义。对于具有节点 $\\mathbf{x}_1, \\mathbf{x}_2, \\mathbf{x}_3, \\mathbf{x}_4$ 的四面体，六条边的长度为 $l_{ij} = \\lVert \\mathbf{x}_i - \\mathbf{x}_j \\rVert_2$，其中索引对 $(i,j)$ 在 $\\{(1,2), (1,3), (1,4), (2,3), (2,4), (3,4)\\}$ 中。向量 $\\mathbf{v} = (v_x, v_y, v_z)$ 的欧几里得范数 $\\lVert \\mathbf{v} \\rVert_2$ 是 $\\sqrt{v_x^2 + v_y^2 + v_z^2}$。\n    纵横比则是最长边与最短边的比率：\n    $$\n    \\mathrm{AR} = \\frac{\\max_{i,j} l_{ij}}{\\min_{i,j} l_{ij}}.\n    $$\n    一个理想的等边四面体的 $\\mathrm{AR}$ 为 $1$。更高的值表示更大的扭曲。如果任何边的长度为零，即 $\\min l_{ij} = 0$，则该单元是退化的，其纵横比定义为无穷大 ($\\infty$)。\n\n2.  **雅可比行列式 ($\\mathrm{JAC}$)**\n    雅可比矩阵的行列式 $\\mathrm{JAC} = \\det(J)$ 与单元的体积直接相关。四面体的有符号体积为 $V = \\det(J)/6$。\n    -   正行列式 $\\det(J)  0$ 表示单元的节点排序（连接关系）保持了参考单元的方向。这是有效网格的标准。\n    -   负行列式 $\\det(J)  0$ 表示一个反转或“内外翻转”的单元，对于大多数模拟目的而言，这在几何上和物理上都是无效的。\n    -   零行列式 $\\det(J) = 0$ 意味着一个体积为零的退化单元（例如，所有四个节点共面）。\n\n3.  **偏斜度 ($\\mathrm{SK}$)**\n    偏斜度测量从参考单元到物理单元的仿射映射的各向异性程度。它使用雅可比矩阵 $J$ 的奇异值来定义。$J$ 的奇异值分解 (SVD) 为 $J = U \\Sigma V^\\top$，其中 $\\Sigma = \\operatorname{diag}(\\sigma_1, \\sigma_2, \\sigma_3)$ 并且 $\\sigma_1 \\ge \\sigma_2 \\ge \\sigma_3 \\ge 0$ 是奇异值。这些值表示沿主方向变换的缩放因子。\n    偏斜度定义为：\n    $$\n    \\mathrm{SK} = 1 - \\frac{\\sigma_{\\min}(J)}{\\sigma_{\\max}(J)} = 1 - \\frac{\\sigma_3}{\\sigma_1}.\n    $$\n    该度量范围为 $0$ 到 $1$。当 $\\sigma_1=\\sigma_2=\\sigma_3$ 时，$\\mathrm{SK}=0$，这对应于纯粹的各向同性缩放（尽管不一定是等边四面体，因为参考单元本身不是等边的）。接近 $1$ 的值表示严重的各向异性或接近退化（即 $\\sigma_3 \\ll \\sigma_1$）。如果 $\\sigma_1 = 0$，则单元完全退化，$\\mathrm{SK}$ 定义为 $1$。\n\n实现将利用 `numpy` 库进行高效的向量和矩阵运算，包括范数、行列式和奇异值分解的计算，这些都是这些第一性原理的标准数值实现。\n\n最后，对于每个网格，逐单元的度量被聚合：\n-   最差纵横比：$\\mathrm{AR}_{\\text{worst}} = \\max_{\\text{elements}} \\mathrm{AR}$。\n-   最差偏斜度：$\\mathrm{SK}_{\\text{worst}} = \\max_{\\text{elements}} \\mathrm{SK}$。\n-   最小雅可比行列式：$\\mathrm{JAC}_{\\text{min}} = \\min_{\\text{elements}} \\mathrm{JAC}$。\n\n这三个聚合值提供了整个网格质量的简明摘要。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to define, process, and evaluate the quality of test meshes.\n    \"\"\"\n    \n    # Test suite to be embedded and evaluated.\n    mesh_A_string = \"\"\"\n    NODES 4\n    1 0.0 0.0 0.0\n    2 1.0 0.0 0.0\n    3 0.5 0.8660254037844386 0.0\n    4 0.5 0.2886751345948129 0.816496580927726\n    ELEMENTS 1\n    1 1 2 3 4\n    \"\"\"\n\n    mesh_B_string = \"\"\"\n    NODES 4\n    1 0.0 0.0 0.0\n    2 2.0 0.0 0.0\n    3 0.0 2.0 0.0\n    4 1.0 1.0 0.000001\n    ELEMENTS 1\n    1 1 2 3 4\n    \"\"\"\n\n    mesh_C_string = \"\"\"\n    NODES 4\n    1 0.0 0.0 0.0\n    2 1.0 0.0 0.0\n    3 0.5 0.8660254037844386 0.0\n    4 0.5 0.2886751345948129 0.816496580927726\n    ELEMENTS 1\n    1 1 3 2 4\n    \"\"\"\n    \n    test_cases = [mesh_A_string, mesh_B_string, mesh_C_string]\n\n    all_results = []\n    for mesh_data in test_cases:\n        result = process_mesh(mesh_data)\n        all_results.append(result)\n\n    # Format the final output string as specified.\n    list_of_lists_str = []\n    for res in all_results:\n        # Format each number to 6 decimal places.\n        formatted_res = [f\"{x:.6f}\" for x in res]\n        list_of_lists_str.append(f\"[{','.join(formatted_res)}]\")\n    \n    final_output_str = f\"[{','.join(list_of_lists_str)}]\"\n    print(final_output_str)\n\ndef parse_mesh(mesh_string: str) -> (dict, list):\n    \"\"\"\n    Parses a mesh description from a string into node and element data structures.\n    \n    Args:\n        mesh_string: A multiline string containing the mesh definition.\n        \n    Returns:\n        A tuple containing:\n        - A dictionary of nodes {node_id: np.array([x, y, z])}.\n        - A list of element connectivities [(n1, n2, n3, n4), ...].\n    \"\"\"\n    lines = mesh_string.strip().split('\\n')\n    nodes = {}\n    elements = []\n    \n    mode = None # \"NODES\" or \"ELEMENTS\"\n\n    for line in lines:\n        line = line.strip()\n        if not line:\n            continue\n        \n        parts = line.split()\n        if parts[0] == \"NODES\":\n            mode = \"NODES\"\n            continue\n        elif parts[0] == \"ELEMENTS\":\n            mode = \"ELEMENTS\"\n            continue\n\n        if mode == \"NODES\":\n            node_id = int(parts[0])\n            coords = np.array([float(p) for p in parts[1:]])\n            nodes[node_id] = coords\n        elif mode == \"ELEMENTS\":\n            # Element ID is ignored as per logic, only connectivity matters\n            node_ids = tuple(int(p) for p in parts[1:])\n            elements.append(node_ids)\n            \n    return nodes, elements\n\ndef compute_aspect_ratio(node_coords: list) -> float:\n    \"\"\"\n    Computes the aspect ratio for a single tetrahedral element.\n    Aspect Ratio = max_edge_length / min_edge_length.\n    \"\"\"\n    points = [np.array(c) for c in node_coords]\n    \n    edge_indices = [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)]\n    edge_lengths = [np.linalg.norm(points[i] - points[j]) for i, j in edge_indices]\n        \n    min_len = min(edge_lengths)\n    max_len = max(edge_lengths)\n    \n    if min_len  1e-12: # Treat very small lengths as zero to handle degeneracy\n        return np.inf\n    \n    return max_len / min_len\n\ndef compute_jacobian_metrics(node_coords: list) -> (float, float):\n    \"\"\"\n    Computes the Jacobian determinant and skewness for a single tetrahedral element.\n    \"\"\"\n    x1, x2, x3, x4 = [np.array(c) for c in node_coords]\n    \n    # Construct the Jacobian matrix J = [x2-x1, x3-x1, x4-x1], where each\n    # difference vector is a column.\n    J = np.vstack((x2 - x1, x3 - x1, x4 - x1)).T\n    \n    # Compute the signed Jacobian determinant.\n    jac_det = np.linalg.det(J)\n    \n    # Compute singular values for skewness. np.linalg.svd returns them sorted.\n    singular_values = np.linalg.svd(J, compute_uv=False)\n    \n    sigma_max = singular_values[0]\n    sigma_min = singular_values[-1]\n    \n    if sigma_max  1e-12:\n        skewness = 1.0\n    else:\n        skewness = 1.0 - (sigma_min / sigma_max)\n        \n    return jac_det, skewness\n\ndef process_mesh(mesh_string: str) -> list:\n    \"\"\"\n    Processes a mesh, computes quality metrics for all its elements,\n    and returns the aggregated mesh-level quality indicators.\n    \n    Args:\n        mesh_string: The string defining the mesh.\n        \n    Returns:\n        A list containing [worst_aspect_ratio, worst_skewness, min_jacobian_determinant].\n    \"\"\"\n    nodes, elements = parse_mesh(mesh_string)\n    \n    worst_ar = 0.0\n    worst_sk = 0.0\n    min_jac = np.inf\n    \n    for elem_node_ids in elements:\n        # Node IDs in the mesh file are 1-based.\n        node_coords = [nodes[nid] for nid in elem_node_ids]\n        \n        # 1. Aspect Ratio\n        ar = compute_aspect_ratio(node_coords)\n        if ar > worst_ar:\n            worst_ar = ar\n\n        # 2. Jacobian Determinant and 3. Skewness\n        jac, sk = compute_jacobian_metrics(node_coords)\n        if sk > worst_sk:\n            worst_sk = sk\n        if jac  min_jac:\n            min_jac = jac\n            \n    return [worst_ar, worst_sk, min_jac]\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "在进行物理仿真时，我们必须能够在模型的边界上施加特定的条件，如力和热源。这个过程的第一步就是准确地识别出这些边界。本练习将带您探索一个纯粹基于拓扑学原理的方法，仅通过分析单元之间的连接关系来找出三维非结构网格的边界。通过实现一个面片邻接计数算法，您将掌握一种不依赖几何坐标的强大技术，以用于有限元分析前处理中的关键步骤。 ",
            "id": "2412652",
            "problem": "给定一个由四面体组成的三维非结构化单纯形网格，但只提供其单元到节点的连接关系。没有坐标信息。一个四面体单元由四个不同的非负整数的有序四元组表示，每个整数是一个全局节点标识符。根据代数拓扑学中关于单纯复形的基本原理，在不考虑定向的情况下，一个四面体集合的边界由那些关联于奇数个四面体的三角面组成；在通常的流形情况下，这意味着恰好关联一个。形式上，对于一个节点集为 $\\{i,j,k,\\ell\\}$ 的四面体，其三角面片集合是 2-单纯形集合 $\\{\\{i,j,k\\},\\{i,j,\\ell\\},\\{i,k,\\ell\\},\\{j,k,\\ell\\}\\}$。给定网格中所有四面体的所有此类面片三元组的多重集并集，一个面是边界面的充要条件是它在该多重集中恰好出现一次，等价地，其关联计数等于 $1$。\n \n任务：编写一个完整的程序，为每个提供的测试用例识别所有边界三角面，并为每个这样的面标记一个值为 $1$ 的边界标签。请使用以下基础和要求。\n \n用于您推理和算法设计的基础原理：\n- 单纯复形及其面的定义：一个 3-单纯形的边界由其四个 2-单纯形组成。\n- 关联计数原理：在一个四面体集合中，如果一个三角面的关联计数为 $1$，则它位于边界上；否则它位于内部。由于我们将每个三角面都视为一个无序节点集，因此这个定义与局部定向无关，始终保持一致。\n- 集合与多重集计数规则：三角面是否相等由其无序节点标识符三元组是否相等决定，计数是在这些规范化的无序三元组上进行的。\n \n算法要求：\n- 对于每个具有节点 $\\{a,b,c,d\\}$ 的四面体，枚举其四个三角面，即无序三元组 $\\{a,b,c\\}$、$\\{a,b,d\\}$、$\\{a,c,d\\}$ 和 $\\{b,c,d\\}$。\n- 通过将其三个节点标识符按升序排序来规范化每个面，以将该面表示为一个唯一的键。这消除了对单元定向的依赖。\n- 统计整个网格连接关系中每个面键的出现次数。面键计数等于 $1$ 的即为边界面。\n- 标记规则：为每个边界面附加整数边界标签 $1$。在此问题中，每个边界面的标签值就是整数 $1$。\n- 面的输出表示：每个面必须输出为一个包含三个严格递增的节点标识符及其标签的列表，即形式为 $[i,j,k,1]$，其中 $ijk$。\n \n测试套件：\n为以下五个独立的测试用例提供结果，每个用例都是一个四面体列表，每个四面体是一个节点的有序四元组。所有节点标识符都是非负整数。\n- 用例 1（单个四面体）：$[[0,1,2,3]]$。\n- 用例 2（两个四面体共享一个面，在该共享面上的局部定向相反）：$[[0,1,2,3],[0,2,1,4]]$。\n- 用例 3（三个四面体非流形地交于一个公共面）：$[[1,2,3,0],[2,1,3,4],[3,1,2,5]]$。\n- 用例 4（不连通网格：一个孤立的四面体和一对共享面的四面体）：$[[10,11,12,13],[20,21,22,23],[22,21,20,24]]$。\n- 用例 5（重复的四面体占据相同的连接关系，测试鲁棒性）：$[[0,1,2,3],[0,1,2,3]]$。\n \n对于每个测试用例，您的程序必须计算：\n- 边界面的整数数量。\n- 按字典序排序的边界面列表，每个面的形式为 $[i,j,k,1]$，其中 $ijk$。\n \n最终输出格式：\n- 您的程序应生成单行输出，其中包含所有五个用例的结果，形式为一个用方括号括起来的逗号分隔列表。每个用例的结果本身必须是一个双元素列表：$[\\text{boundary\\_count}, \\text{boundary\\_faces}]$，其中 $\\text{boundary\\_faces}$ 是按规定格式标记的面的字典序排序列表。例如，整体输出格式为 $[[c_1,F_1],[c_2,F_2],[c_3,F_3],[c_4,F_4],[c_5,F_5]]$，其中 $c_m$ 是一个整数，$F_m$ 是一个整数列表的列表。\n \n角度和物理单位不适用于此问题。所有输出均为整数值或整数列表。您的程序必须完全自包含，无需输入，并且必须精确计算上述五个用例的结果。",
            "solution": "所提出的问题是计算拓扑学中一个明确定义的练习，该学科是计算工程和物理学的基础学科。任务是识别一个由其构成的 3-单纯形（四面体）列表定义的三维单纯复形的边界面。我们只被提供了组合连接性数据，具体来说是每个四面体的节点标识符，而没有几何坐标。\n\n该问题基于代数拓扑学中关于单纯复形上边界算子的一个基本原理。单纯复形是单纯形（顶点、边、三角形、四面体及其高维对应物）的集合，该集合在取面和非空交集操作下是封闭的。设 $K$ 是一个单纯复形。一个 $p$-链是 $K$ 中 $p$-单纯形的一个形式和，记作 $\\sum_{i} c_i \\sigma_i^p$，其中 $\\sigma_i^p$ 是 $p$-单纯形，$c_i$ 是来自一个环的系数，通常是整数环 $\\mathbb{Z}$ 或像 $\\mathbb{Z}_2 = \\{0, 1\\}$ 这样的有限域。\n\n边界算子 $\\partial_p$ 将一个 $p$-单纯形映射为其 $(p-1)$-维面（面片）的和。对于由其 $p+1$ 个顶点定义的 $p$-单纯形 $\\sigma^p = [v_0, v_1, \\dots, v_p]$，其边界是由以下公式给出的 $(p-1)$-链：\n$$\n\\partial_p(\\sigma^p) = \\sum_{j=0}^{p} (-1)^j [v_0, \\dots, \\hat{v}_j, \\dots, v_p]\n$$\n其中 $[v_0, \\dots, \\hat{v}_j, \\dots, v_p]$ 表示省略顶点 $v_j$ 后形成的 $(p-1)$-单纯形。符号 $(-1)^j$ 用于说明定向。\n\n问题陈述通过有效地考虑域 $\\mathbb{Z}_2$ 上的链来简化了这一点。在这种情况下，加法是模 $2$ 的，因此可以忽略定向符号（因为 $-1 \\equiv 1 \\pmod 2$）。一个 3-单纯形（四面体）$\\sigma^3 = [v_0, v_1, v_2, v_3]$ 的边界就是其四个 2-单纯形（三角）面之和：\n$$\n\\partial_3(\\sigma^3) = [v_1, v_2, v_3] + [v_0, v_2, v_3] + [v_0, v_1, v_3] + [v_0, v_1, v_2]\n$$\n现在，考虑一个 3-链 $C = \\sum_{i} \\sigma_i^3$，它代表我们网格中所有四面体的集合。整个集合的边界 $\\partial_3(C)$ 可以通过利用边界算子的线性性质找到：\n$$\n\\partial_3(C) = \\partial_3\\left(\\sum_{i} \\sigma_i^3\\right) = \\sum_{i} \\partial_3(\\sigma_i^3)\n$$\n在 $\\mathbb{Z}_2$ 上的这个求和中，一个给定的三角面 $\\tau$ 每被一个包含它的四面体作为面片，就会出现一次。如果 $\\tau$ 是集合中偶数个（比如 $2k$ 个）四面体的面片，其对总和的贡献为 $2k \\cdot \\tau \\equiv 0 \\pmod 2$。如果 $\\tau$ 是奇数个（比如 $2k+1$ 个）四面体的面片，其总贡献为 $(2k+1) \\cdot \\tau \\equiv 1 \\cdot \\tau \\pmod 2$。因此，边界 $\\partial_3(C)$ 精确地是那些在网格中各自关联于奇数个四面体的三角面集合。\n\n问题将“边界面”定义为关联计数恰好为 $1$ 的面。这是针对单纯伪流形这种常见情况的一般原理的特例，在单纯伪流形中，任何内部面都恰好由两个四面体共享。算法要求正确地将此原理形式化以用于计算实现。\n\n算法如下：\n$1$。我们需要一个数据结构来存储每个唯一三角面的关联计数。哈希映射（在 Python 中是字典）是理想的选择，其中键代表面，值存储其计数。\n$2$。为了处理定向无关性并为每个面提供唯一的表示，我们必须将其规范化。由三个节点标识符 $\\{i, j, k\\}$ 定义的面通过将这些整数排序成一个元组来进行规范化，例如 $(i', j', k')$，其中 $i'  j'  k'$。这个排序后的元组将作为我们哈希映射中的唯一键。\n$3$。我们遍历输入连接关系列表中的每个四面体。对于由其四个节点标识符 $\\{v_0, v_1, v_2, v_3\\}$ 表示的每个四面体，我们生成其四个三角面：$\\{v_0, v_1, v_2\\}$、$\\{v_0, v_1, v_3\\}$、$\\{v_0, v_2, v_3\\}$ 和 $\\{v_1, v_2, v_3\\}$。\n$4$。对于每个生成的面，我们按照步骤 $2$ 中所述生成其规范键。然后我们更新哈希映射：如果键已存在，我们增加其关联的计数值；否则，我们将该键添加到映射中，计数值为 $1$。\n$5$。处理完所有四面体后，哈希映射包含了网格中每个唯一的面及其总关联计数。然后我们遍历该映射。任何计数恰好为 $1$ 的面（键）都被识别为边界面。\n$6$。收集这些已识别的边界面，它们是三个已排序节点标识符的元组。给每个面追加一个值为 $1$ 的边界标签，形成一个列表 $[i', j', k', 1]$。\n$7$。最终的带标签边界面列表按字典序排序，以确保输出是唯一且有序的，符合要求。同时计算这些面的总数。\n\n这个过程是确定性的，对于给定的约束条件计算效率高，并且正确地实现了底层的拓扑原理。例如，在用例 2 中，四面体为 $[[0,1,2,3],[0,2,1,4]]$，由节点 $\\{0,1,2\\}$ 定义的面会从两个四面体中生成。其规范形式，即元组 $(0,1,2)$，其计数将被增加两次，最终计数为 $2$。因此，它被正确地识别为内部面。所有其他面，例如来自第一个四面体的 $\\{0,1,3\\}$ 和来自第二个四面体的 $\\{0,1,4\\}$，都只出现一次，并被正确地识别为边界面。这个逻辑可以推广到所有测试用例，包括非流形构型（用例 3，其中一个面可能被两个以上单元共享）和重复单元（用例 5，其中每个面的计数只是加倍）。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport collections\nfrom itertools import combinations\n\ndef solve():\n    \"\"\"\n    Solves for boundary faces in five test cases of tetrahedral meshes.\n    \"\"\"\n    test_cases = [\n        # Case 1: single tetrahedron\n        [[0, 1, 2, 3]],\n        # Case 2: two tetrahedra sharing one face\n        [[0, 1, 2, 3], [0, 2, 1, 4]],\n        # Case 3: three tetrahedra meeting non-manifoldly on one common face\n        [[1, 2, 3, 0], [2, 1, 3, 4], [3, 1, 2, 5]],\n        # Case 4: disconnected mesh\n        [[10, 11, 12, 13], [20, 21, 22, 23], [22, 21, 20, 24]],\n        # Case 5: duplicate tetrahedra\n        [[0, 1, 2, 3], [0, 1, 2, 3]],\n    ]\n\n    results = []\n    for connectivity in test_cases:\n        # Use a dictionary to store face counts.\n        # Key: canonical face (sorted tuple of 3 node IDs)\n        # Value: incidence count\n        face_counts = collections.defaultdict(int)\n\n        # Iterate through each tetrahedron in the mesh\n        for tet_nodes in connectivity:\n            # A tetrahedron has 4 nodes. A triangular face is formed by 3 nodes.\n            # We generate all combinations of 3 nodes from the 4.\n            for face_nodes in combinations(tet_nodes, 3):\n                # Canonicalize the face by sorting its node IDs.\n                # This makes the representation unique regardless of orientation.\n                canonical_face = tuple(sorted(face_nodes))\n                face_counts[canonical_face] += 1\n\n        # Identify boundary faces\n        # A face is a boundary face if its incidence count is exactly 1.\n        boundary_faces = []\n        for face, count in face_counts.items():\n            if count == 1:\n                # The output format for a face is [i, j, k, 1]\n                tagged_face = list(face) + [1]\n                boundary_faces.append(tagged_face)\n        \n        # Sort the boundary faces lexicographically for a consistent output.\n        boundary_faces.sort()\n        \n        # Get the count of boundary faces.\n        boundary_count = len(boundary_faces)\n\n        # Store the result for this test case.\n        results.append([boundary_count, boundary_faces])\n\n    # The final output must be a single line string representation of the list\n    # of results, with no spaces. str() adds spaces, so we remove them.\n    final_output_string = str(results).replace(\" \", \"\")\n    print(final_output_string)\n\nsolve()\n```"
        }
    ]
}