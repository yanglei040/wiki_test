{
    "hands_on_practices": [
        {
            "introduction": "在评估网格质量时，诸如宽高比之类的度量可以快速检查单元的形状。然而，“好”的形状并不总是意味着一个对模拟“有效”的单元。本实践探讨了雅可比行列式 ($Jacobian determinant$) 这一关键概念，它衡量了从参考单元到物理单元映射的有效性。通过完成这个练习 ，你将看到一个拥有完美宽高比的单元如何仍然可能是“翻转”的，因而是无效的。",
            "id": "2412959",
            "problem": "在计算工程中，网格质量通常通过将几何形状度量（如纵横比）与基于映射的度量（如等参变换的雅可比行列式）相结合进行评估。考虑一个二维 ($2$D) 双线性等参四边形单元，它将具有参数坐标 $(\\xi,\\eta) \\in [-1,1] \\times [-1,1]$ 的参考正方形映射到物理平面中的一个直边四边形。使用以下构造来说明完美的纵横比并不保证映射有效。\n\n将物理节点坐标（按逆时针参考节点顺序）定义为\n$$\n(x_1,y_1)=(0,a),\\quad (x_2,y_2)=(a,0),\\quad (x_3,y_3)=(0,-a),\\quad (x_4,y_4)=(-a,0),\n$$\n其中 $a>0$。对于网格质量评估，采用基于边长的纵横比\n$$\nr=\\frac{\\max\\{\\ell_1,\\ell_2,\\ell_3,\\ell_4\\}}{\\min\\{\\ell_1,\\ell_2,\\ell_3,\\ell_4\\}},\n$$\n其中 $\\ell_i$ 是由连续节点 $i$ 和 $i+1$ 形成的第 $i$ 条物理边的欧几里得长度（节点 $5$ 与节点 $1$ 等同）。\n\n从 $4$ 节点四边形的标准双线性等参映射和映射的雅可比矩阵 $J(\\xi,\\eta)$ 的定义出发，完成以下操作：\n- 证明所构造的单元具有 $r=1$。\n- 计算单元中心 $(\\xi,\\eta)=(0,0)$ 处的雅可比行列式，并用 $a$ 精确表示。\n\n请以关于 $a$ 的单个闭式表达式的形式提供单元中心处雅可比行列式的最终答案。不包括单位。无需四舍五入。",
            "solution": "该问题要求对一个特定的二维双线性等参四边形单元进行分析，以证明完美的纵横比并不排除无效映射的可能性。这将通过首先计算单元基于边长的纵横比 $r$，然后计算单元中心处映射的雅可比行列式来完成。\n\n首先，我们证明纵横比 $r=1$。四个节点的物理坐标按逆时针参考节点顺序给出，分别为 $(x_1, y_1) = (0, a)$、$(x_2, y_2) = (a, 0)$、$(x_3, y_3) = (0, -a)$ 和 $(x_4, y_4) = (-a, 0)$，其中常数 $a > 0$。纵横比定义为最大边长与最小边长之比，$r = \\frac{\\max\\{\\ell_i\\}}{\\min\\{\\ell_i\\}}$。我们使用欧几里得距离公式 $\\ell = \\sqrt{\\Delta x^2 + \\Delta y^2}$ 计算四条边中每条边的长度 $\\ell_i$。\n\n节点 $1$ 和节点 $2$ 之间的第一条边 $\\ell_1$ 的长度为：\n$$\n\\ell_1 = \\sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2} = \\sqrt{(a - 0)^2 + (0 - a)^2} = \\sqrt{a^2 + (-a)^2} = \\sqrt{2a^2} = a\\sqrt{2}\n$$\n\n节点 $2$ 和节点 $3$ 之间的第二条边 $\\ell_2$ 的长度为：\n$$\n\\ell_2 = \\sqrt{(x_3 - x_2)^2 + (y_3 - y_2)^2} = \\sqrt{(0 - a)^2 + (-a - 0)^2} = \\sqrt{(-a)^2 + (-a)^2} = \\sqrt{2a^2} = a\\sqrt{2}\n$$\n\n节点 $3$ 和节点 $4$ 之间的第三条边 $\\ell_3$ 的长度为：\n$$\n\\ell_3 = \\sqrt{(x_4 - x_3)^2 + (y_4 - y_3)^2} = \\sqrt{(-a - 0)^2 + (0 - (-a))^2} = \\sqrt{(-a)^2 + a^2} = \\sqrt{2a^2} = a\\sqrt{2}\n$$\n\n节点 $4$ 和节点 $1$ 之间的第四条边 $\\ell_4$ 的长度为：\n$$\n\\ell_4 = \\sqrt{(x_1 - x_4)^2 + (y_1 - y_4)^2} = \\sqrt{(0 - (-a))^2 + (a - 0)^2} = \\sqrt{a^2 + a^2} = \\sqrt{2a^2} = a\\sqrt{2}\n$$\n\n由于所有边长相等，$\\ell_1 = \\ell_2 = \\ell_3 = \\ell_4 = a\\sqrt{2}$，最大和最小长度相同。因此，纵横比为：\n$$\nr = \\frac{\\max\\{\\ell_i\\}}{\\min\\{\\ell_i\\}} = \\frac{a\\sqrt{2}}{a\\sqrt{2}} = 1\n$$\n这表明该单元具有完美的纵横比 $1$。\n\n接下来，我们计算雅可比行列式。从参考坐标 $(\\xi, \\eta)$ 到物理坐标 $(x, y)$ 的等参映射定义为：\n$$\nx(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) x_i \\quad \\text{和} \\quad y(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) y_i\n$$\n对于参考正方形 $[-1,1] \\times [-1,1]$，标准双线性形函数 $N_i(\\xi, \\eta)$ 与从 $(\\xi, \\eta) = (-1,-1)$ 开始逆时针排列的节点相关联：\n$N_1(\\xi, \\eta) = \\frac{1}{4}(1-\\xi)(1-\\eta)$\n$N_2(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1-\\eta)$\n$N_3(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1+\\eta)$\n$N_4(\\xi, \\eta) = \\frac{1}{4}(1-\\xi)(1+\\eta)$\n\n代入给定的物理节点坐标：\n$x(\\xi, \\eta) = N_1(0) + N_2(a) + N_3(0) + N_4(-a) = a N_2 - a N_4$\n$y(\\xi, \\eta) = N_1(a) + N_2(0) + N_3(-a) + N_4(0) = a N_1 - a N_3$\n\n代入形函数的表达式：\n$$\nx(\\xi, \\eta) = a \\left( \\frac{1}{4}(1+\\xi)(1-\\eta) \\right) - a \\left( \\frac{1}{4}(1-\\xi)(1+\\eta) \\right) = \\frac{a}{4} ((1-\\eta+\\xi-\\xi\\eta) - (1+\\eta-\\xi-\\xi\\eta)) = \\frac{a}{4}(2\\xi - 2\\eta) = \\frac{a}{2}(\\xi - \\eta)\n$$\n$$\ny(\\xi, \\eta) = a \\left( \\frac{1}{4}(1-\\xi)(1-\\eta) \\right) - a \\left( \\frac{1}{4}(1+\\xi)(1+\\eta) \\right) = \\frac{a}{4} ((1-\\eta-\\xi+\\xi\\eta) - (1+\\eta+\\xi+\\xi\\eta)) = \\frac{a}{4}(-2\\eta - 2\\xi) = -\\frac{a}{2}(\\xi + \\eta)\n$$\n变换的雅可比矩阵为 $J(\\xi, \\eta) = \\begin{pmatrix} \\frac{\\partial x}{\\partial \\xi} & \\frac{\\partial x}{\\partial \\eta} \\\\ \\frac{\\partial y}{\\partial \\xi} & \\frac{\\partial y}{\\partial \\eta} \\end{pmatrix}$。我们计算偏导数：\n$$\n\\frac{\\partial x}{\\partial \\xi} = \\frac{\\partial}{\\partial \\xi}\\left(\\frac{a}{2}(\\xi - \\eta)\\right) = \\frac{a}{2}\n$$\n$$\n\\frac{\\partial x}{\\partial \\eta} = \\frac{\\partial}{\\partial \\eta}\\left(\\frac{a}{2}(\\xi - \\eta)\\right) = -\\frac{a}{2}\n$$\n$$\n\\frac{\\partial y}{\\partial \\xi} = \\frac{\\partial}{\\partial \\xi}\\left(-\\frac{a}{2}(\\xi + \\eta)\\right) = -\\frac{a}{2}\n$$\n$$\n\\frac{\\partial y}{\\partial \\eta} = \\frac{\\partial}{\\partial \\eta}\\left(-\\frac{a}{2}(\\xi + \\eta)\\right) = -\\frac{a}{2}\n$$\n因此，雅可比矩阵在整个单元上是恒定的：\n$$\nJ = \\begin{pmatrix} \\frac{a}{2} & -\\frac{a}{2} \\\\ -\\frac{a}{2} & -\\frac{a}{2} \\end{pmatrix}\n$$\n雅可比行列式 $\\det(J)$ 为：\n$$\n\\det(J) = \\left(\\frac{a}{2}\\right)\\left(-\\frac{a}{2}\\right) - \\left(-\\frac{a}{2}\\right)\\left(-\\frac{a}{2}\\right) = -\\frac{a^2}{4} - \\frac{a^2}{4} = -\\frac{2a^2}{4} = -\\frac{a^2}{2}\n$$\n由于雅可比行列式是常数，其在单元中心 $(\\xi, \\eta)=(0,0)$ 处的值为 $-\\frac{a^2}{2}$。负的雅可比行列式表示映射是局部方向反转的，意味着单元是“纠缠的”或“翻转的”。在有限元法的背景下，这是一个无效单元。该练习正确地证明了完美的几何纵横比 ($r=1$) 并不保证映射有效。",
            "answer": "$$\n\\boxed{-\\frac{a^2}{2}}\n$$"
        },
        {
            "introduction": "当你的网格包含“翻转”或“纠缠”的单元时，你该怎么办？修复它们是网格生成中的一项核心技能。本实践  将指导你实现并比较两种基本的平滑方法：简单快速的拉普拉斯平滑，以及更稳健的基于优化的平滑。这种亲手实践的比较将揭示每种方法在面对网格去纠缠挑战时的优点和局限性。",
            "id": "2412991",
            "problem": "您必须编写一个完整且可运行的程序，该程序构建一个小型二维（$2$-D）三角形网格，故意引入一个翻转单元，然后比较一个简单的拉普拉斯平滑器（Laplacian smoother）与一个基于优化的平滑器（optimization-based smoother）在解开网格翻转方面的能力。您的程序必须从第一性原理出发实现这两种平滑器，将它们应用于一组给定的网格配置测试套件，并以布尔值的形式报告每种方法在每种情况下是否成功解开了网格。\n\n从以下基本概念开始：平面中三角形的有符号面积，对于顶点 $\\mathbf{p}_0=(x_0,y_0)$、$\\mathbf{p}_1=(x_1,y_1)$ 和 $\\mathbf{p}_2=(x_2,y_2)$，其定义为\n$$\nA_s(\\mathbf{p}_0,\\mathbf{p}_1,\\mathbf{p}_2) = \\tfrac{1}{2}\\,\\det\\begin{bmatrix}x_1-x_0 & x_2-x_0\\\\ y_1-y_0 & y_2-y_0\\end{bmatrix} = \\tfrac{1}{2}\\big((x_1-x_0)(y_2-y_0)-(x_2-x_0)(y_1-y_0)\\big).\n$$\n对于选定的顶点顺序，如果 $A_s \\le 0$，则三角形是翻转的。如果一个网格的所有三角形都具有严格为正的有符号面积，则该网格是未翻转的。对于第 $k$ 次迭代的内部顶点 $\\mathbf{x}_i^{(k)}$，拉普拉斯平滑器是一种显式更新方法\n$$\n\\mathbf{x}_i^{(k+1)} = \\mathbf{x}_i^{(k)} + \\alpha\\left(\\frac{1}{|\\mathcal{N}(i)|}\\sum_{j\\in \\mathcal{N}(i)} \\mathbf{x}_j^{(k)} - \\mathbf{x}_i^{(k)}\\right),\n$$\n其中 $\\mathcal{N}(i)$ 表示 1-环邻域集合， $|\\mathcal{N}(i)|$ 是其基数，$\\alpha\\in(0,1]$ 是步长。边界顶点保持固定。基于优化的平滑器是通过最小化一个能量函数来获得的，该函数在惩罚负面积的同时，鼓励形成短而平滑的边。对负有符号面积 $A_s$ 的一个平滑惩罚项可以通过将 softplus 函数 $\\operatorname{softplus}(z;\\beta) = \\tfrac{1}{\\beta}\\log(1+e^{\\beta z})$ 应用于 $z=-A_s$ 来获得，这会产生一个可微的铰链式惩罚项，当 $A_s$ 为负时其值很大，而当 $A_s$ 足够大时其值接近于零。设目标函数为\n$$\nE(\\mathbf{X}) = w_{\\ell}\\sum_{(i,j)\\in \\mathcal{E}} \\|\\mathbf{x}_i-\\mathbf{x}_j\\|_2^2 \\;+\\; w_{a}\\sum_{t\\in\\mathcal{T}} \\operatorname{softplus}\\!\\left(-A_s(t);\\beta\\right)^2,\n$$\n其中 $\\mathcal{E}$ 是无向网格边的集合，$\\mathcal{T}$ 是三角形的集合，$\\mathbf{X}$ 堆叠了所有顶点坐标，边界顶点是固定的，而内部顶点是待优化的。\n\n编程任务规范：\n- 构建一个正方形边界，其顶点为 $\\mathbf{v}_0=(0,0)$、$\\mathbf{v}_1=(1,0)$、$\\mathbf{v}_2=(1,1)$、$\\mathbf{v}_3=(0,1)$，以及一个内部顶点 $\\mathbf{c}=(x_c,y_c)$，连接构成四个具有一致逆时针方向的三角形：$(\\mathbf{v}_0,\\mathbf{v}_1,\\mathbf{c})$、$(\\mathbf{v}_1,\\mathbf{v}_2,\\mathbf{c})$、$(\\mathbf{v}_2,\\mathbf{v}_3,\\mathbf{c})$、$(\\mathbf{v}_3,\\mathbf{v}_0,\\mathbf{c})$。边界顶点的索引是固定的。\n- 实现一个拉普拉斯平滑器，该平滑器使用上述显式迭代方法，仅更新内部顶点，步长 $\\alpha = 0.25$，迭代次数恰好为 $5$ 次。使用由这些三角形导出的 1-环邻域。\n- 实现一个基于优化的平滑器，该平滑器仅针对内部顶点最小化 $E(\\mathbf{X})$，参数如下：$w_{\\ell} = 1.0$、$w_{a} = 100.0$ 和 $\\beta = 10.0$。使用带有边界约束 $-2 \\le x_c \\le 2$、$-2 \\le y_c \\le 2$ 的数值优化。根据三角形的连接关系，将 $\\mathcal{E}$ 构建为唯一的无向边集合。\n- 如果所有三角形的有符号面积都严格大于阈值 $\\varepsilon = 10^{-12}$，则定义该网格为未翻转。\n\n测试套件：\n- 情况 $1$（轻度翻转）：$\\mathbf{c}=(0.5,-0.05)$。\n- 情况 $2$（严重翻转）：$\\mathbf{c}=(0.5,-1.0)$。\n- 情况 $3$（已有效）：$\\mathbf{c}=(0.5,0.5)$。\n\n对于每种情况，从指定的初始 $\\mathbf{c}$ 开始运行两种平滑器，并根据所有三角形的 $A_s > \\varepsilon$ 标准，评估一个布尔值，以指示生成的网格是否未翻转。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果的顺序必须完全遵循\n$[$情况 $1$ 上的拉普拉斯平滑器，情况 $1$ 上的优化平滑器，情况 $2$ 上的拉普拉斯平滑器，情况 $2$ 上的优化平滑器，情况 $3$ 上的拉普拉斯平滑器，情况 $3$ 上的优化平滑器]，\n例如，$[b_1,b_2,b_3,b_4,b_5,b_6]$，其中每个 $b_i$ 为 True 或 False。",
            "solution": "该问题要求实现并比较两种网格平滑算法——拉普拉斯平滑（Laplacian smoothing）和一种基于优化的方法——以评估它们在解开一个翻转的二维三角形网格方面的有效性。对问题陈述的验证证实了其在科学上是合理的、适定的，并且包含了进行求解所需的所有必要信息。解决方法是首先确定网格的几何形状和单元有效性的度量标准，然后按规定实现每种平滑算法，最后将它们应用于提供的测试用例，以确定它们在生成有效、未翻转网格方面的成功率。\n\n首先，我们定义计算域和网格拓扑。该网格由五个顶点组成：四个固定的边界顶点，形成一个单位正方形，即 $\\mathbf{v}_0=(0,0)$、$\\mathbf{v}_1=(1,0)$、$\\mathbf{v}_2=(1,1)$ 和 $\\mathbf{v}_3=(0,1)$，以及一个可移动的内部顶点 $\\mathbf{c}=(x_c, y_c)$。这些顶点构成四个三角形，其连接关系被定义为确保一个位于边界内部的有效（非翻转）网格具有一致的逆时针方向：$T_0 = (\\mathbf{v}_0, \\mathbf{v}_1, \\mathbf{c})$、$T_1 = (\\mathbf{v}_1, \\mathbf{v}_2, \\mathbf{c})$、$T_2 = (\\mathbf{v}_2, \\mathbf{v}_3, \\mathbf{c})$ 和 $T_3 = (\\mathbf{v}_3, \\mathbf{v}_0, \\mathbf{c})$。\n\n三角形的质量由其有符号面积决定。对于一个顶点为 $\\mathbf{p}_0=(x_0,y_0)$、$\\mathbf{p}_1=(x_1,y_1)$ 和 $\\mathbf{p}_2=(x_2,y_2)$ 的三角形，其有符号面积 $A_s$ 由以下公式给出：\n$$\nA_s(\\mathbf{p}_0, \\mathbf{p}_1, \\mathbf{p}_2) = \\frac{1}{2} \\det\\begin{bmatrix}x_1-x_0 & x_2-x_0 \\\\ y_1-y_0 & y_2-y_0\\end{bmatrix}\n$$\n正的有符号面积对应于顶点的逆时针排序，这是有效单元的约定。如果 $A_s \\le 0$，则认为三角形是翻转的。如果一个网格的所有组成三角形的有符号面积都严格大于一个小的容差 $A_s > \\varepsilon$（其中 $\\varepsilon = 10^{-12}$），则该网格被定义为未翻转。\n\n第一种方法，拉普拉斯平滑（Laplacian smoothing），是一种迭代启发式方法，它将内部顶点重新定位到其相邻邻居的几何中心。在第 $k$ 次迭代中，内部顶点 $\\mathbf{x}_i$ 的位置更新公式为：\n$$\n\\mathbf{x}_i^{(k+1)} = \\mathbf{x}_i^{(k)} + \\alpha \\left( \\frac{1}{|\\mathcal{N}(i)|} \\sum_{j \\in \\mathcal{N}(i)} \\mathbf{x}_j^{(k)} - \\mathbf{x}_i^{(k)} \\right)\n$$\n在我们特定的网格中，只有一个内部顶点 $\\mathbf{c}$。它的 1-环邻域 $\\mathcal{N}(\\mathbf{c})$ 是四个边界顶点 $\\{\\mathbf{v}_0, \\mathbf{v}_1, \\mathbf{v}_2, \\mathbf{v}_3\\}$。这些固定邻居的质心是一个恒定点 $\\bar{\\mathbf{v}} = \\frac{1}{4}(\\mathbf{v}_0 + \\mathbf{v}_1 + \\mathbf{v}_2 + \\mathbf{v}_3) = (\\frac{0+1+1+0}{4}, \\frac{0+0+1+1}{4}) = (0.5, 0.5)$。对 $\\mathbf{c}$ 的迭代更新简化为：\n$$\n\\mathbf{c}^{(k+1)} = \\mathbf{c}^{(k)} + \\alpha (\\bar{\\mathbf{v}} - \\mathbf{c}^{(k)})\n$$\n此过程以步长 $\\alpha = 0.25$ 执行固定的 $5$ 次迭代。边界顶点保持不变。\n\n第二种方法是基于优化的平滑器，它试图最小化一个全局目标函数 $E(\\mathbf{X})$，其中 $\\mathbf{X}$ 代表所有顶点的坐标。该函数是两项的加权和：一项是对边长平方的惩罚，另一项是对非正三角形面积的惩罚。\n$$\nE(\\mathbf{X}) = w_{\\ell}\\sum_{(i,j)\\in \\mathcal{E}} \\|\\mathbf{x}_i-\\mathbf{x}_j\\|_2^2 \\;+\\; w_{a}\\sum_{t\\in\\mathcal{T}} \\operatorname{softplus}\\!\\left(-A_s(t);\\beta\\right)^2\n$$\n边的集合 $\\mathcal{E}$ 包括 4 条边界边和 4 条连接 $\\mathbf{c}$ 与每个边界顶点的边。三角形的集合 $\\mathcal{T}$ 包含四个三角形 $\\{T_0, T_1, T_2, T_3\\}$。项 $\\operatorname{softplus}(z;\\beta) = \\frac{1}{\\beta}\\log(1+e^{\\beta z})$ 是 ReLU 函数的一个平滑近似，当其参数为 $z = -A_s$ 时，它充当对负有符号面积的可微惩罚。优化仅针对内部顶点 $\\mathbf{c}$ 的坐标进行，并受限于箱型约束 $-2 \\le x_c, y_c \\le 2$。指定的参数为 $w_{\\ell} = 1.0$、$w_{a} = 100.0$ 和 $\\beta = 10.0$。我们将使用 `scipy` 库中的一个数值优化例程来找到最小化此目标函数的 $\\mathbf{c}$ 的坐标。\n\n对于每个测试用例，首先设置 $\\mathbf{c}$ 的初始位置。然后应用两种平滑算法中的每一种。每次运行后，使用 $\\mathbf{c}$ 的最终位置计算所有四个三角形的有符号面积。当且仅当所有四个面积都大于 $\\varepsilon = 10^{-12}$ 时，该网格被认证为未翻转。对每种方法和每个测试用例，都会记录此检查的布尔结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.5, -0.05),  # Case 1 (mild inversion)\n        (0.5, -1.0),   # Case 2 (severe inversion)\n        (0.5, 0.5),    # Case 3 (already valid)\n    ]\n\n    # Global parameters\n    EPSILON = 1e-12\n    BOUNDARY_VERTS = np.array([\n        [0.0, 0.0],  # v0 (index 0)\n        [1.0, 0.0],  # v1 (index 1)\n        [1.0, 1.0],  # v2 (index 2)\n        [0.0, 1.0],  # v3 (index 3)\n    ])\n    # Vertex indices for the four triangles, with interior vertex at index 4\n    TRIANGLES_CONN = [\n        (0, 1, 4),\n        (1, 2, 4),\n        (2, 3, 4),\n        (3, 0, 4),\n    ]\n    # Unique undirected edges for the objective function\n    EDGES_CONN = [\n        (0, 1), (1, 2), (2, 3), (3, 0), # boundary edges\n        (0, 4), (1, 4), (2, 4), (3, 4)  # interior edges\n    ]\n\n    def signed_area(p0, p1, p2):\n        \"\"\"Calculates the signed area of a triangle given its vertices.\"\"\"\n        return 0.5 * ((p1[0] - p0[0]) * (p2[1] - p0[1]) - \n                      (p2[0] - p0[0]) * (p1[1] - p0[1]))\n\n    def check_untangled(interior_vert_pos):\n        \"\"\"Checks if the mesh is untangled given the position of the interior vertex.\"\"\"\n        all_verts = np.vstack((BOUNDARY_VERTS, interior_vert_pos))\n        for i, j, k in TRIANGLES_CONN:\n            p0, p1, p2 = all_verts[i], all_verts[j], all_verts[k]\n            if signed_area(p0, p1, p2) = EPSILON:\n                return False\n        return True\n\n    def run_laplacian_smoother(initial_c):\n        \"\"\"Runs the Laplacian smoother for a specified number of iterations.\"\"\"\n        alpha = 0.25\n        num_iterations = 5\n        c_current = np.array(initial_c, dtype=float)\n        centroid = np.mean(BOUNDARY_VERTS, axis=0)\n\n        for _ in range(num_iterations):\n            # Update rule: c_new = c_old + alpha * (centroid - c_old)\n            c_current += alpha * (centroid - c_current)\n        \n        return c_current\n\n    def objective_function(c_coords, wl, wa, beta):\n        \"\"\"Objective function for optimization-based smoothing.\"\"\"\n        all_verts = np.vstack((BOUNDARY_VERTS, c_coords))\n        \n        # Edge length term\n        edge_energy = 0.0\n        for i, j in EDGES_CONN:\n            p1 = all_verts[i]\n            p2 = all_verts[j]\n            edge_energy += np.sum((p1 - p2)**2)\n            \n        # Area penalty term\n        area_penalty = 0.0\n        for i, j, k in TRIANGLES_CONN:\n            p0, p1, p2 = all_verts[i], all_verts[j], all_verts[k]\n            area = signed_area(p0, p1, p2)\n            \n            # softplus(-area; beta)\n            z = -area\n            # Use a numerically stable implementation for softplus\n            if beta * z > 700: # Avoid overflow in exp\n                 softplus_val = z\n            else:\n                 softplus_val = (1.0 / beta) * np.log1p(np.exp(beta * z))\n            area_penalty += softplus_val**2\n\n        return wl * edge_energy + wa * area_penalty\n\n    def run_optimization_smoother(initial_c):\n        \"\"\"Runs the optimization-based smoother.\"\"\"\n        wl, wa, beta = 1.0, 100.0, 10.0\n        bounds = [(-2.0, 2.0), (-2.0, 2.0)]\n        initial_c_np = np.array(initial_c, dtype=float)\n\n        result = minimize(\n            fun=objective_function,\n            x0=initial_c_np,\n            args=(wl, wa, beta),\n            method='L-BFGS-B',\n            bounds=bounds\n        )\n        return result.x\n\n    results = []\n    for case in test_cases:\n        initial_c = case\n        \n        # Run and evaluate Laplacian smoother\n        final_c_laplacian = run_laplacian_smoother(initial_c)\n        laplacian_success = check_untangled(final_c_laplacian)\n        results.append(laplacian_success)\n        \n        # Run and evaluate Optimization-based smoother\n        final_c_optimization = run_optimization_smoother(initial_c)\n        optimization_success = check_untangled(final_c_optimization)\n        results.append(optimization_success)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "许多现实世界中的物体，从涡轮叶片到汽车车身，都由曲面定义。在此类曲面上平滑网格需要特别小心，以确保顶点保留在预期的几何体上。这个高级实践  介绍了约束平滑，其中顶点的移动被限制在底层曲面的切平面上，然后再投影回去。通过为球面上的网格实现这一技术，你将获得对高保真几何建模和模拟中一项关键技术的实践性见解。",
            "id": "2412997",
            "problem": "给定一个嵌入三维欧几里得空间中的解析曲面，以及一小组顶点位于该曲面上的三角形曲面网格。对于每个网格，对顶点位置执行一次约束平滑扫描，并评估其对单元质量的影响。\n\n曲面和切平面约束。设曲面为以原点为中心、半径为 $R$ 的球面，\n$$\n\\mathcal{S} = \\left\\{ \\mathbf{x} \\in \\mathbb{R}^3 \\;\\middle|\\; \\|\\mathbf{x}\\|_2 = R \\right\\}.\n$$\n对于任意 $\\mathbf{x} \\in \\mathcal{S}$，其单位法向量为 $\\mathbf{n}(\\mathbf{x}) = \\mathbf{x}/R$，其仿射切平面为\n$$\n\\mathcal{T}_{\\mathbf{x}}\\mathcal{S} = \\left\\{ \\mathbf{y} \\in \\mathbb{R}^3 \\;\\middle|\\; (\\mathbf{y} - \\mathbf{x}) \\cdot \\mathbf{n}(\\mathbf{x}) = 0 \\right\\}.\n$$\n\n每个顶点的平滑目标。考虑一个三角形网格，其顶点集为 $V=\\{\\mathbf{p}_i\\}_{i=1}^N \\subset \\mathcal{S}$，面集为 $F \\subset \\{1,\\dots,N\\}^3$。对于每个不位于网格边界上的顶点索引 $i$，令 $\\mathcal{N}(i)$ 表示其相邻顶点索引的集合（即通过边与 $i$ 连接的顶点）。通过以下最小化问题定义约束最优中间位置 $\\mathbf{y}_i$\n$$\n\\mathbf{y}_i \\in \\underset{\\mathbf{y} \\in \\mathcal{T}_{\\mathbf{p}_i}\\mathcal{S}}{\\arg\\min}\\;\\sum_{j \\in \\mathcal{N}(i)} \\|\\mathbf{y} - \\mathbf{p}_j\\|_2^2.\n$$\n通过径向投影回球面来定义更新后的位置 $\\mathbf{z}_i$，\n$$\n\\mathbf{z}_i = \\frac{R}{\\|\\mathbf{y}_i\\|_2}\\,\\mathbf{y}_i.\n$$\n边界上的顶点不移动，即如果 $i$ 在边界上，则设置 $\\mathbf{z}_i = \\mathbf{p}_i$。如果一个顶点属于至少一条仅包含在一个面中的边，则该顶点位于边界上。一次平滑扫描会同时将所有 $\\mathbf{p}_i$ 替换为相应的 $\\mathbf{z}_i$。\n\n三角形质量。对于任意具有顶点 $\\mathbf{a},\\mathbf{b},\\mathbf{c} \\in \\mathbb{R}^3$ 的三角形，定义其面积为\n$$\nA(\\mathbf{a},\\mathbf{b},\\mathbf{c}) = \\tfrac{1}{2}\\,\\|(\\mathbf{b}-\\mathbf{a}) \\times (\\mathbf{c}-\\mathbf{a})\\|_2,\n$$\n边长为 $\\ell_1=\\|\\mathbf{b}-\\mathbf{a}\\|_2$，$\\ell_2=\\|\\mathbf{c}-\\mathbf{b}\\|_2$，$\\ell_3=\\|\\mathbf{a}-\\mathbf{c}\\|_2$。该三角形的质量为\n$$\nq(\\mathbf{a},\\mathbf{b},\\mathbf{c}) = \\frac{4\\sqrt{3}\\,A(\\mathbf{a},\\mathbf{b},\\mathbf{c})}{\\ell_1^2 + \\ell_2^2 + \\ell_3^2},\n$$\n该质量满足 $0  q \\le 1$，且对于等边三角形，$q=1$。对于一个网格，平均质量是所有面上 $q$ 值的算术平均值。\n\n任务。对于下面描述的每个测试用例，计算平滑扫描前后的平均三角形质量，并返回差值 $\\Delta = \\overline{q}_{\\text{after}} - \\overline{q}_{\\text{before}}$。\n\n测试用例中使用的定义。对于任意非零向量 $\\mathbf{v} \\in \\mathbb{R}^3$，令 $\\operatorname{normalize}(\\mathbf{v}) = \\mathbf{v}/\\|\\mathbf{v}\\|_2$。在所有情况下均使用 $R=1$。如果出现角度，均以弧度为单位，但不需要三角函数输入；所有顶点坐标都是直接给出的。\n\n测试套件。共有三个网格。\n\n测试用例 1（一个内部顶点和三个边界顶点）。顶点：\n- $\\mathbf{p}_0 = (0,0,1)$，\n- $\\mathbf{p}_1 = \\operatorname{normalize}(1,0,0.2)$，\n- $\\mathbf{p}_2 = \\left(-\\tfrac{1}{2},\\tfrac{\\sqrt{3}}{2},0\\right)$，\n- $\\mathbf{p}_3 = \\left(-\\tfrac{1}{2},-\\tfrac{\\sqrt{3}}{2},0\\right)$。\n面：$(0,1,2)$, $(0,2,3)$, $(0,3,1)$。\n\n测试用例 2（单个边界三角形）。顶点：\n- $\\mathbf{p}_1 = (1,0,0)$，\n- $\\mathbf{p}_2 = \\left(-\\tfrac{1}{2},\\tfrac{\\sqrt{3}}{2},0\\right)$，\n- $\\mathbf{p}_3 = \\left(-\\tfrac{1}{2},-\\tfrac{\\sqrt{3}}{2},0\\right)$。\n面：$(1,2,3)$。\n\n测试用例 3（一个内部顶点和一个四顶点边界环）。顶点：\n- $\\mathbf{p}_c = \\operatorname{normalize}(0.2,-0.1,0.97)$，\n- $\\mathbf{p}_a = \\operatorname{normalize}(0.9,0.0,0.435)$，\n- $\\mathbf{p}_b = \\operatorname{normalize}(0.0,0.9,0.435)$，\n- $\\mathbf{p}_d = \\operatorname{normalize}(-0.9,0.0,0.435)$，\n- $\\mathbf{p}_e = \\operatorname{normalize}(0.0,-0.9,0.435)$。\n面：$(c,a,b)$, $(c,b,d)$, $(c,d,e)$, $(c,e,a)$。\n\n最终输出要求。您的程序应生成单行输出，其中包含测试用例 1、2 和 3 的 $\\Delta$ 值，按顺序排列，形式为用方括号括起来的逗号分隔列表。每个 $\\Delta$ 值必须精确到小数点后 $6$ 位。例如：\"[$\\Delta_1,\\Delta_2,\\Delta_3$]\"，其中每个 $\\Delta_k$ 都格式化为 6 位小数。不应打印任何其他文本。单位不适用；以十进制形式报告纯实数。",
            "solution": "该问题要求对几个三角形曲面网格执行一次约束平滑扫描，并评估平均单元质量的变化。该曲面是一个以原点为中心的单位球面。\n\n对于每个给定的网格，解决方案分为四个主要阶段：\n1.  **网格分析**：识别网格的边界顶点。根据问题定义，属于仅一个三角形的任何边的顶点被视为边界顶点。所有其他顶点均为内部顶点。\n2.  **初始质量评估**：计算初始网格中每个三角形面的质量，并计算平均质量 $\\overline{q}_{\\text{before}}$。\n3.  **约束平滑**：计算所有顶点的新位置。边界顶点保持固定。对于每个内部顶点，其新位置是通过首先解决一个约束优化问题，然后将结果投影回球面上找到的。\n4.  **最终质量评估与比较**：使用新的顶点位置计算平滑后网格的平均质量 $\\overline{q}_{\\text{after}}$。最终结果是差值 $\\Delta = \\overline{q}_{\\text{after}} - \\overline{q}_{\\text{before}}$。\n\n下面我们详细阐述每个阶段的数学和算法细节。\n\n**1. 边界顶点的识别**\n\n如果一个顶点是恰好属于一个面的某条边的一部分，则该顶点位于边界上。为了实现这一点，我们可以计算网格中每条边的出现次数。一条边由两个顶点索引 $(i, j)$ 定义。由于顺序无关紧要，我们使用一种规范表示法，例如 $(\\min(i,j), \\max(i,j))$ 来表示边。我们遍历网格的所有面。对于每个面 $(v_1, v_2, v_3)$，我们识别其三条边 $(v_1, v_2)$、$(v_2, v_3)$ 和 $(v_3, v_1)$，并在一个哈希映射或字典中增加它们的计数。处理完所有面后，我们遍历该映射。计数为 $1$ 的边是边界边。构成这些边界边的所有顶点的集合就是边界顶点的集合。\n\n**2. 三角形质量度量**\n\n具有顶点 $\\mathbf{a}, \\mathbf{b}, \\mathbf{c} \\in \\mathbb{R}^3$ 的单个三角形的质量 $q$ 由以下公式给出：\n$$\nq(\\mathbf{a},\\mathbf{b},\\mathbf{c}) = \\frac{4\\sqrt{3}\\,A}{\\ell_1^2 + \\ell_2^2 + \\ell_3^2}\n$$\n其中 $A$ 是三角形的面积，$\\ell_1, \\ell_2, \\ell_3$ 是其边长。面积可以通过两个边向量的叉积计算：\n$$\nA(\\mathbf{a},\\mathbf{b},\\mathbf{c}) = \\frac{1}{2} \\|(\\mathbf{b}-\\mathbf{a}) \\times (\\mathbf{c}-\\mathbf{a})\\|_2\n$$\n边长由 $\\ell_1 = \\|\\mathbf{b}-\\mathbf{a}\\|_2$、$\\ell_2 = \\|\\mathbf{c}-\\mathbf{b}\\|_2$ 和 $\\ell_3 = \\|\\mathbf{a}-\\mathbf{c}\\|_2$ 给出。该质量度量是归一化的，对于等边三角形其值等于 $1$，对于退化三角形其值趋近于 $0$。网格的平均质量是其所有面上 $q$ 值的算术平均值。\n\n**3. 约束平滑算法**\n\n平滑过程更新每个内部顶点 $\\mathbf{p}_i$ 的位置。边界顶点不移动。对内部顶点 $\\mathbf{p}_i$ 的更新是一个两步过程。\n\n**步骤 3.1：切平面上的最优位置**\n\n首先，我们找到一个中间位置 $\\mathbf{y}_i$，它最小化到其相邻顶点的平方距离之和，约束条件是 $\\mathbf{y}_i$ 必须位于球面在 $\\mathbf{p}_i$ 处的切平面上。要最小化的目标函数是：\n$$\nf(\\mathbf{y}) = \\sum_{j \\in \\mathcal{N}(i)} \\|\\mathbf{y} - \\mathbf{p}_j\\|_2^2\n$$\n其中 $\\mathcal{N}(i)$ 是与顶点 $i$ 相邻的顶点索引集合。该函数的无约束最小值是相邻顶点的质心，$\\mathbf{c}_i = \\frac{1}{|\\mathcal{N}(i)|} \\sum_{j \\in \\mathcal{N}(i)} \\mathbf{p}_j$。\n\n约束条件是 $\\mathbf{y}_i$ 必须位于仿射切平面 $\\mathcal{T}_{\\mathbf{p}_i}\\mathcal{S}$ 中。对于以原点为中心的单位球面（$R=1$），在 $\\mathbf{p}_i$ 处的单位法向量是 $\\mathbf{n}(\\mathbf{p}_i) = \\mathbf{p}_i$。切平面的方程是 $(\\mathbf{y} - \\mathbf{p}_i) \\cdot \\mathbf{p}_i = 0$。\n\n这个约束最小化问题的解是无约束最小化点 $\\mathbf{c}_i$ 在切平面上的正交投影。该投影的公式为：\n$$\n\\mathbf{y}_i = \\mathbf{c}_i - ((\\mathbf{c}_i - \\mathbf{p}_i) \\cdot \\mathbf{n}(\\mathbf{p}_i)) \\mathbf{n}(\\mathbf{p}_i)\n$$\n代入 $\\mathbf{n}(\\mathbf{p}_i) = \\mathbf{p}_i$ 并利用 $\\|\\mathbf{p}_i\\|_2=1$（因此 $\\mathbf{p}_i \\cdot \\mathbf{p}_i = 1$）这一事实，我们简化表达式：\n$$\n\\mathbf{y}_i = \\mathbf{c}_i - (\\mathbf{c}_i \\cdot \\mathbf{p}_i - \\mathbf{p}_i \\cdot \\mathbf{p}_i) \\mathbf{p}_i = \\mathbf{c}_i - (\\mathbf{c}_i \\cdot \\mathbf{p}_i - 1) \\mathbf{p}_i\n$$\n这就得到了中间位置 $\\mathbf{y}_i$。\n\n**步骤 3.2：投影回球面**\n\n点 $\\mathbf{y}_i$ 位于切平面上，但不一定在球面上。最终更新的位置 $\\mathbf{z}_i$ 是通过将 $\\mathbf{y}_i$ 径向投影回单位球面上得到的：\n$$\n\\mathbf{z}_i = \\frac{R}{\\|\\mathbf{y}_i\\|_2}\\,\\mathbf{y}_i = \\frac{\\mathbf{y}_i}{\\|\\mathbf{y}_i\\|_2} \\quad (\\text{因为 } R=1)\n$$\n此过程对所有内部顶点同时执行，意味着每个 $\\mathbf{z}_i$ 的计算都使用原始位置 $\\{\\mathbf{p}_k\\}$。平滑后网格的新顶点集为 $\\{\\mathbf{z}_i\\}$，其中如果 $i$ 是边界顶点，则 $\\mathbf{z}_i=\\mathbf{p}_i$。\n\n**4. 计算**\n\n对于每个测试用例，我们实现以下算法：\n1.  定义初始顶点坐标和面连接关系。所有用 `normalize()` 指定的顶点都被归一化，使其欧几里得范数为 $1$。\n2.  计算初始平均质量 $\\overline{q}_{\\text{before}}$。\n3.  通过计算面之间的边共享情况来识别边界和内部顶点。同时构建一个将每个顶点映射到其邻居的邻接表。\n4.  创建一个用于存放更新后顶点位置的新数组，并用原始位置进行初始化。\n5.  遍历每个内部顶点 $i$：\n    a. 使用其邻居的原始位置计算质心 $\\mathbf{c}_i$。\n    b. 通过将 $\\mathbf{c}_i$ 投影到 $\\mathbf{p}_i$ 处的切平面上来计算中间位置 $\\mathbf{y}_i$。\n    c. 通过归一化 $\\mathbf{y}_i$ 来计算最终位置 $\\mathbf{z}_i$。\n    d. 将 $\\mathbf{z}_i$ 存储在新的位置数组中。\n6.  使用更新后的顶点位置和原始的面连接关系计算最终平均质量 $\\overline{q}_{\\text{after}}$。\n7.  计算并记录差值 $\\Delta = \\overline{q}_{\\text{after}} - \\overline{q}_{\\text{before}}$。\n\n将此过程应用于所有三个测试用例以获得所需的 $\\Delta$ 值。对于测试用例 2，所有顶点都在边界上，因此不发生平滑，从而 $\\Delta = 0$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the constrained mesh smoothing problem for all three test cases.\n    \"\"\"\n    R = 1.0\n\n    def normalize(v):\n        \"\"\"Normalizes a 3D vector to unit length.\"\"\"\n        norm = np.linalg.norm(v)\n        return v / norm if norm > 0 else v\n\n    def get_triangle_quality(a, b, c):\n        \"\"\"Calculates the quality of a single triangle.\"\"\"\n        try:\n            l1_sq = np.sum((b - a)**2)\n            l2_sq = np.sum((c - b)**2)\n            l3_sq = np.sum((a - c)**2)\n            sum_l_sq = l1_sq + l2_sq + l3_sq\n            if sum_l_sq  1e-12:\n                return 0.0\n            area = 0.5 * np.linalg.norm(np.cross(b - a, c - a))\n            return (4.0 * np.sqrt(3.0) * area) / sum_l_sq\n        except (ValueError, FloatingPointError):\n            return 0.0\n\n    def get_avg_quality(vertices, faces):\n        \"\"\"Calculates the average quality of all triangles in a mesh.\"\"\"\n        if not faces:\n            return 0.0\n        total_quality = sum(get_triangle_quality(vertices[f[0]], vertices[f[1]], vertices[f[2]]) for f in faces)\n        return total_quality / len(faces)\n\n    def find_mesh_info(num_vertices, faces):\n        \"\"\"Identifies boundary vertices and creates an adjacency list.\"\"\"\n        adj = {i: set() for i in range(num_vertices)}\n        edge_counts = {}\n        for face in faces:\n            for i in range(3):\n                v1_idx, v2_idx = face[i], face[(i + 1) % 3]\n                edge = tuple(sorted((v1_idx, v2_idx)))\n                edge_counts[edge] = edge_counts.get(edge, 0) + 1\n        \n        boundary_verts = set()\n        for edge, count in edge_counts.items():\n            if count == 1:\n                boundary_verts.add(edge[0])\n                boundary_verts.add(edge[1])\n        \n        for face in faces:\n             adj[face[0]].update([face[1], face[2]])\n             adj[face[1]].update([face[0], face[2]])\n             adj[face[2]].update([face[0], face[1]])\n        return adj, boundary_verts\n\n    def process_case(vertex_data, face_data):\n        \"\"\"Processes a single test case and returns the change in average quality.\"\"\"\n        vert_names = list(vertex_data.keys())\n        vert_map = {name: i for i, name in enumerate(vert_names)}\n        vertices = np.array([vertex_data[name] for name in vert_names])\n        faces = [tuple(vert_map[name] for name in face_tuple) for face_tuple in face_data]\n        \n        num_vertices = len(vertices)\n        \n        q_before = get_avg_quality(vertices, faces)\n        \n        adj, boundary_verts = find_mesh_info(num_vertices, faces)\n        \n        new_vertices = np.copy(vertices)\n        \n        for i in range(num_vertices):\n            if i in boundary_verts:\n                continue\n\n            p_i = vertices[i]\n            neighbors_indices = list(adj[i])\n            if not neighbors_indices:\n                continue\n            \n            c_i = np.mean(vertices[neighbors_indices, :], axis=0)\n            n_i = p_i / R  # Normal vector\n            \n            y_i = c_i - np.dot(c_i - p_i, n_i) * n_i\n            \n            z_i = normalize(y_i) * R\n            new_vertices[i] = z_i\n            \n        q_after = get_avg_quality(new_vertices, faces)\n        \n        return q_after - q_before\n\n    # --- Test Case 1 ---\n    v1_data = {\n        'p0': np.array([0, 0, 1.0]),\n        'p1': normalize(np.array([1.0, 0, 0.2])),\n        'p2': np.array([-0.5, np.sqrt(3)/2, 0]),\n        'p3': np.array([-0.5, -np.sqrt(3)/2, 0])\n    }\n    f1_data = [(0, 1, 2), (0, 2, 3), (0, 3, 1)]\n    # Convert vertex names to indices\n    v1_indexed = [v1_data['p0'], v1_data['p1'], v1_data['p2'], v1_data['p3']]\n    delta1 = process_case({str(i):v for i,v in enumerate(v1_indexed)}, f1_data)\n\n    # --- Test Case 2 ---\n    v2_data = {\n        'p1': np.array([1.0, 0, 0]),\n        'p2': np.array([-0.5, np.sqrt(3)/2, 0]),\n        'p3': np.array([-0.5, -np.sqrt(3)/2, 0])\n    }\n    f2_data = [('p1', 'p2', 'p3')]\n    delta2 = process_case(v2_data, f2_data)\n\n    # --- Test Case 3 ---\n    v3_data = {\n        'c': normalize(np.array([0.2, -0.1, 0.97])),\n        'a': normalize(np.array([0.9, 0.0, 0.435])),\n        'b': normalize(np.array([0.0, 0.9, 0.435])),\n        'd': normalize(np.array([-0.9, 0.0, 0.435])),\n        'e': normalize(np.array([0.0, -0.9, 0.435]))\n    }\n    f3_data = [('c', 'a', 'b'), ('c', 'b', 'd'), ('c', 'd', 'e'), ('c', 'e', 'a')]\n    delta3 = process_case(v3_data, f3_data)\n\n    print(f\"[{delta1:.6f},{delta2:.6f},{delta3:.6f}]\")\n\nsolve()\n```"
        }
    ]
}