{
    "hands_on_practices": [
        {
            "introduction": "插值多项式的唯一性是其核心性质之一，但这一性质有时会导致一些反直觉的结论。本练习旨在通过一个巧妙的构造，揭示一个深刻的原理：插值过程只“看见”函数在节点上的值。这个练习将帮助你巩固对插值唯一性的理解，并让你领略到Chebyshev多项式在逼近理论中的关键作用。",
            "id": "2404709",
            "problem": "设 $x_{1}, x_{2}, \\dots, x_{10}$ 是区间 $(-1,1)$ 内的 $10$ 个不同节点，它们被定义为 $10$ 次第一类切比雪夫多项式的零点，其中 $T_{10}(x)$ 定义为 $T_{10}(x) = \\cos\\!\\big(10\\,\\arccos(x)\\big)$。考虑函数 $f(x) = \\exp(x)$ 和 $g(x) = f(x) + \\alpha \\prod_{k=1}^{10} (x - x_{k})$，其中 $\\alpha$ 是一个实常数。\n\n仅使用多项式插值的基本性质和上面给出的 $T_{10}(x)$ 的定义，证明 $f(x)$ 和 $g(x)$ 在节点 $\\{x_{k}\\}_{k=1}^{10}$ 上具有相同的唯一的 $9$ 次插值多项式。然后，确定唯一的正数 $\\alpha$ 值，使得\n$$\\max_{x \\in [-1,1]} |g(x) - f(x)| = \\frac{1}{8}。$$\n\n将 $\\alpha$ 的值作为你的最终答案。无需四舍五入。",
            "solution": "首先必须验证问题陈述的科学合理性、适定性和客观性。\n\n**步骤1：提取已知条件**\n- 节点：$x_{1}, x_{2}, \\dots, x_{10}$ 是区间 $(-1,1)$ 内的 $10$ 个不同节点。\n- 节点定义：节点 $\\{x_k\\}_{k=1}^{10}$ 是 $10$ 次第一类切比雪夫多项式 $T_{10}(x)$ 的零点。\n- 切比雪夫多项式定义：$T_{10}(x) = \\cos(10 \\arccos(x))$。\n- 函数定义：$f(x) = \\exp(x)$ 和 $g(x) = f(x) + \\alpha \\prod_{k=1}^{10} (x - x_{k})$，其中 $\\alpha$ 是一个实常数。\n- 条件：必须确定唯一的正数 $\\alpha$ 值，使得 $\\max_{x \\in [-1,1]} |g(x) - f(x)| = \\frac{1}{8}$。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题属于计算工程领域，特别是插值理论。\n1.  **科学或事实不准确性**：该问题建立在多项式插值和切比雪夫多项式的标准定义和性质之上。所定义的函数是标准的初等函数。没有违反数学逻辑或科学原理。\n2.  **无法形式化或不相关**：该问题是一个形式化的数学练习，与插值和逼近理论的主题直接相关。\n3.  **设置不完整或矛盾**：该问题是自洽的。所有必要的信息都已提供。\n4.  **不切实际或不可行**：这些条件在数学上是合理的，不代表任何物理或科学上的不可能性。\n5.  **不适定或结构不良**：经过给定数量的不同点，给定次数的插值多项式的存在性和唯一性是数值分析的一个基本定理。所有术语都定义明确。\n6.  **超出科学可验证范围**：这些主张和结果可以通过直接的数学推导来验证。\n\n**步骤3：结论与行动**\n该问题被认为是有效的。将提供解答。\n\n该问题包含两部分。首先，我们必须证明 $f(x)$ 和 $g(x)$ 共享同一个唯一的 $9$ 次插值多项式。其次，我们必须确定正常数 $\\alpha$。\n\n设 $P_{9}(x)$ 表示在 $10$ 个不同节点 $\\{x_k\\}_{k=1}^{10}$ 上对一个函数进行插值的、次数至多为 $9$ 的唯一多项式。\n对于函数 $f(x)$，其插值多项式（我们称之为 $P_{f}(x)$）必须满足以下条件：\n$$P_{f}(x_k) = f(x_k) \\quad \\text{对于 } k = 1, 2, \\dots, 10。$$\n对于函数 $g(x)$，其插值多项式（我们称之为 $P_{g}(x)$）必须满足以下条件：\n$$P_{g}(x_k) = g(x_k) \\quad \\text{对于 } k = 1, 2, \\dots, 10。$$\n函数 $g(x)$ 的定义为 $g(x) = f(x) + \\alpha \\prod_{j=1}^{10} (x - x_{j})$。让我们在每个插值节点 $x_k$ 处计算 $g(x)$ 的值：\n$$g(x_k) = f(x_k) + \\alpha \\prod_{j=1}^{10} (x_k - x_{j})。$$\n当索引 $j$ 等于 $k$ 时，乘积项 $\\prod_{j=1}^{10} (x_k - x_{j})$ 包含因子 $(x_k - x_k)$。该因子等于 $0$。因此，整个乘积为零。\n于是，对于每个节点 $x_k$：\n$$g(x_k) = f(x_k) + \\alpha \\cdot 0 = f(x_k)。$$\n这表明在这 $10$ 个不同的插值节点上，函数 $f(x)$ 和 $g(x)$ 的值是相同的。因此，它们各自的插值多项式必须满足：\n$$P_{g}(x_k) = g(x_k) = f(x_k) = P_{f}(x_k) \\quad \\text{对于 } k = 1, 2, \\dots, 10。$$\n考虑差分多项式 $\\Delta(x) = P_{f}(x) - P_{g}(x)$。由于 $P_{f}(x)$ 和 $P_{g}(x)$ 都是次数至多为 $9$ 的多项式，它们的差 $\\Delta(x)$ 也是一个次数至多为 $9$ 的多项式。\n我们已经证明，对于所有 $10$ 个不同节点 $\\{x_k\\}$，都有 $\\Delta(x_k) = P_{f}(x_k) - P_{g}(x_k) = 0$。一个次数至多为 $9$ 且有 $10$ 个不同根的多项式必定是零多项式。\n因此，对于所有 $x$，$\\Delta(x) = 0$，这意味着 $P_{f}(x) = P_{g}(x)$。这就完成了问题的第一部分：$f(x)$ 和 $g(x)$ 具有相同的唯一的 $9$ 次插值多项式。\n\n接下来，我们必须根据以下条件确定 $\\alpha$ 的值：\n$$\\max_{x \\in [-1,1]} |g(x) - f(x)| = \\frac{1}{8}。$$\n让我们分析这个等式的左边。根据 $g(x)$ 的定义，我们有：\n$$g(x) - f(x) = \\left( f(x) + \\alpha \\prod_{k=1}^{10} (x - x_{k}) \\right) - f(x) = \\alpha \\prod_{k=1}^{10} (x - x_{k})。$$\n条件变为：\n$$\\max_{x \\in [-1,1]} \\left| \\alpha \\prod_{k=1}^{10} (x - x_{k}) \\right| = \\frac{1}{8}。$$\n由于 $\\alpha$ 是一个常数，我们可以将其写为：\n$$|\\alpha| \\max_{x \\in [-1,1]} \\left| \\prod_{k=1}^{10} (x - x_{k}) \\right| = \\frac{1}{8}。$$\n节点 $\\{x_k\\}_{k=1}^{10}$ 是切比雪夫多项式 $T_{10}(x)$ 的零点。多项式 $\\prod_{k=1}^{10} (x - x_{k})$ 是一个具有相同零点的 $10$ 次首一多项式。\n$n$ 次第一类切比雪夫多项式 $T_n(x)$，当 $n \\ge 1$ 时，其首项系数为 $2^{n-1}$。对于 $n=10$，首项系数为 $2^{10-1} = 2^9$。\n因此，$T_{10}(x)$ 可以写成其因式分解形式：\n$$T_{10}(x) = 2^9 \\prod_{k=1}^{10} (x - x_{k})。$$\n由此，我们可以表示出乘积项：\n$$\\prod_{k=1}^{10} (x - x_{k}) = \\frac{T_{10}(x)}{2^9}。$$\n将此代入我们的方程，得到：\n$$|\\alpha| \\max_{x \\in [-1,1]} \\left| \\frac{T_{10}(x)}{2^9} \\right| = \\frac{1}{8}。$$\n$$|\\alpha| \\frac{1}{2^9} \\max_{x \\in [-1,1]} |T_{10}(x)| = \\frac{1}{8}。$$\n第一类切比雪夫多项式 $T_n(x) = \\cos(n \\arccos(x))$ 的一个基本性质是，它在区间 $[-1, 1]$ 上的最大绝对值为 $1$。这是因为函数 $\\cos(\\theta)$ 在 $-1$ 和 $1$ 之间振荡。\n所以，$\\max_{x \\in [-1,1]} |T_{10}(x)| = 1$。\n方程简化为：\n$$|\\alpha| \\frac{1}{2^9} \\cdot 1 = \\frac{1}{8}。$$\n$$|\\alpha| \\frac{1}{512} = \\frac{1}{8}。$$\n解出 $|\\alpha|$：\n$$|\\alpha| = \\frac{512}{8} = 64。$$\n问题要求的是 $\\alpha$ 的唯一正值。因此，我们选择正解。\n$$\\alpha = 64。$$\n推导至此完成。",
            "answer": "$$\\boxed{64}$$"
        },
        {
            "introduction": "在工程与科学实践中，我们常常需要在“通用”的数学模型与“专用”的物理模型之间做出选择。本练习以放射性同位素衰变为背景，让你直接比较多项式插值与基于物理定律的指数衰减模型在预测上的差异。通过从第一性原理推导并计算插值误差的上界，你将深刻体会到理论误差分析在评估模型预测能力时的实用价值。",
            "id": "2404756",
            "problem": "一个放射性同位素样品的原子核衰变可以很好地用原子核物理学中的基本一阶速率定律来建模，这意味着其放射性活度 $A(t)$ 满足 $\\frac{dA}{dt}=-\\lambda A(t)$，其解为 $A(t)=A(0)\\exp(-\\lambda t)$，其中 $\\lambda>0$ 是衰变常数。一个理想探测器在 $t=0,1,5$ 天时记录了放射性活度，得到了以下精确测量值：$A(0)=1000$ 计数每秒，$A(1)=1000\\cdot 2^{-2/5}$ 计数每秒，以及 $A(5)=250$ 计数每秒。\n\n- 仅使用这三个测量值，构建经过数据点 $(0,A(0))$、$(1,A(1))$ 和 $(5,A(5))$ 的唯一二次插值多项式 $p_{2}(t)$，并计算 $p_{2}(3)$ 的值。\n- 独立地，使用物理指数衰变模型并结合在 $t=0$ 和 $t=5$ 时的端点测量值，来确定衰变常数 $\\lambda$ 并预测在 $t=3$ 天时的放射性活度 $A(3)$。\n- 从第一性原理出发，不使用任何快捷公式，通过将在区间 $[0,5]$ 上从指数衰变模型获得的对 $|A^{(3)}(t)|$ 的一个界与基于 $A^{(3)}(t)$ 的余项估计相结合，推导出在 $t=3$ 时插值误差的一个形式为 $|A(3)-p_{2}(3)|\\leq B$ 的上界。请给出你所得到的显式上界 $B$。\n\n最后，计算绝对差异 $|p_{2}(3)-A(3)|$ 并报告其值。将您的答案四舍五入到四位有效数字，并以“计数每秒”为单位表示。仅提供此单一数值作为您的最终答案。此问题不涉及角度。",
            "solution": "所提供的问题首先需要经过一个验证过程。\n\n**步骤1：提取已知条件**\n- 放射性活度 $A(t)$ 的控制微分方程为 $\\frac{dA}{dt}=-\\lambda A(t)$。\n- 放射性活度的物理模型为 $A(t) = A(0)\\exp(-\\lambda t)$，其中衰变常数 $\\lambda > 0$。\n- 在特定时间的精确测量值如下：\n  - $t_0=0$ 天, $y_0 = A(0) = 1000$ 计数每秒。\n  - $t_1=1$ 天, $y_1 = A(1) = 1000 \\cdot 2^{-2/5}$ 计数每秒。\n  - $t_2=5$ 天, $y_2 = A(5) = 250$ 计数每秒。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题具有科学依据，采用了原子核物理学中的标准一阶指数衰变模型。这是一个适定的问题，因为它要求计算一系列具体的、可计算的量。从所使用的精确数学语言中可以清楚地看出其客观性。为确保一致性，给定的数据点必须对同一个 $\\lambda$ 值满足物理模型。使用端点 $t_0=0$ 和 $t_2=5$：\n$A(5) = A(0) \\exp(-5\\lambda) \\implies 250 = 1000 \\exp(-5\\lambda)$。\n这得到 $\\exp(-5\\lambda) = \\frac{250}{1000} = \\frac{1}{4}$。由此，$-5\\lambda = \\ln(\\frac{1}{4}) = -\\ln(4) = -2\\ln(2)$，所以 $\\lambda = \\frac{2\\ln(2)}{5}$。该值为正，因此在物理上是有效的。\n现在，我们用这个常数来验证 $t_1=1$ 处的数据点：\n$A(1) = A(0)\\exp(-\\lambda \\cdot 1) = 1000 \\exp(-\\frac{2\\ln(2)}{5}) = 1000 \\cdot (\\exp(\\ln(2)))^{-2/5} = 1000 \\cdot 2^{-2/5}$。\n这与给定的 $A(1)$ 的值完全相同。因此，该问题是自洽的、一致的且科学上合理的。\n\n**步骤3：结论与行动**\n该问题有效。现在推导完整解。\n\n**第1部分：构建二次插值多项式 $p_2(t)$**\n对数据点 $(0, y_0)$、$(1, y_1)$、$(5, y_2)$ 进行插值的唯一二次多项式 $p_2(t)$ 可使用拉格朗日形式构建：\n$p_2(t) = y_0 L_0(t) + y_1 L_1(t) + y_2 L_2(t)$，其中拉格朗日基多项式 $L_i(t)$ 为：\n$L_0(t) = \\frac{(t-1)(t-5)}{(0-1)(0-5)} = \\frac{1}{5}(t-1)(t-5)$。\n$L_1(t) = \\frac{(t-0)(t-5)}{(1-0)(1-5)} = -\\frac{1}{4}t(t-5)$。\n$L_2(t) = \\frac{(t-0)(t-1)}{(5-0)(5-1)} = \\frac{1}{20}t(t-1)$。\n\n我们必须计算 $p_2(t)$ 在 $t=3$ 时的值。首先，我们计算基多项式在 $t=3$ 时的值：\n$L_0(3) = \\frac{(3-1)(3-5)}{5} = \\frac{(2)(-2)}{5} = -\\frac{4}{5}$。\n$L_1(3) = -\\frac{3(3-5)}{4} = -\\frac{3(-2)}{4} = \\frac{6}{4} = \\frac{3}{2}$。\n$L_2(3) = \\frac{3(3-1)}{20} = \\frac{3(2)}{20} = \\frac{6}{20} = \\frac{3}{10}$。\n\n现在我们可以计算 $p_2(3)$：\n$p_2(3) = y_0 L_0(3) + y_1 L_1(3) + y_2 L_2(3)$\n$p_2(3) = (1000)(-\\frac{4}{5}) + (1000 \\cdot 2^{-2/5})(\\frac{3}{2}) + (250)(\\frac{3}{10})$\n$p_2(3) = -800 + 1500 \\cdot 2^{-2/5} + 75 = 1500 \\cdot 2^{-2/5} - 725$。\n\n**第2部分：根据物理模型进行预测**\n衰变常数 $\\lambda$ 在验证过程中被确定为 $\\lambda = \\frac{2\\ln(2)}{5}$。我们用它来预测真实的放射性活度 $A(3)$：\n$A(3) = A(0)\\exp(-3\\lambda) = 1000\\exp(-3 \\cdot \\frac{2\\ln(2)}{5}) = 1000\\exp(-\\frac{6}{5}\\ln(2))$。\n使用恒等式 $\\exp(c \\ln a) = a^c$：\n$A(3) = 1000 \\cdot 2^{-6/5}$。\n\n**第3部分：插值误差界的推导**\n多项式插值的误差由 $A(t) - p_n(t) = \\frac{A^{(n+1)}(\\xi)}{(n+1)!} \\prod_{i=0}^{n} (t-t_i)$ 给出，其中 $\\xi$ 位于包含插值节点和 $t$ 的某个区间内。对于我们的二次情况（$n=2$），在 $t=3$ 时的误差是：\n$A(3) - p_2(3) = \\frac{A^{(3)}(\\xi)}{3!}(3-t_0)(3-t_1)(3-t_2) = \\frac{A^{(3)}(\\xi)}{6}(3-0)(3-1)(3-5)$，其中某个 $\\xi \\in (0,5)$。\n$A(3) - p_2(3) = \\frac{A^{(3)}(\\xi)}{6}(3)(2)(-2) = -2 A^{(3)}(\\xi)$。\n\n绝对误差为 $|A(3) - p_2(3)| = 2|A^{(3)}(\\xi)|$。\n为了建立一个上界 $B$，我们必须求出 $|A^{(3)}(t)|$ 在区间 $[0,5]$ 上的最大值。首先，我们计算 $A(t) = A_0 \\exp(-\\lambda t)$ 的三阶导数：\n$A'(t) = -\\lambda A_0 \\exp(-\\lambda t)$\n$A''(t) = \\lambda^2 A_0 \\exp(-\\lambda t)$\n$A'''(t) = -\\lambda^3 A_0 \\exp(-\\lambda t)$。\n所以，$|A'''(t)| = \\lambda^3 A_0 \\exp(-\\lambda t)$。由于 $\\lambda>0$，这个函数对于 $t \\ge 0$ 是单调递减的。它在 $[0,5]$ 上的最大值出现在 $t=0$ 处：\n$\\max_{t \\in [0,5]} |A'''(t)| = |A'''(0)| = \\lambda^3 A_0 \\exp(0) = \\lambda^3 A_0$。\n\n因此，误差大小的一个上界 $B$ 为：\n$|A(3) - p_2(3)| \\leq 2 \\max_{\\xi \\in [0,5]} |A^{(3)}(\\xi)| = 2 \\lambda^3 A_0$。\n代入 $A_0 = 1000$ 和 $\\lambda = \\frac{2\\ln(2)}{5}$：\n$B = 2 \\left(\\frac{2\\ln(2)}{5}\\right)^3 (1000) = 2 \\cdot \\frac{8(\\ln(2))^3}{125} \\cdot 1000 = \\frac{16(\\ln(2))^3}{125} \\cdot (1000) = 16(\\ln(2))^3 \\cdot 8 = 128(\\ln(2))^3$。\n\n**第4部分：绝对差异的计算**\n最后，我们计算 $|p_2(3) - A(3)|$ 的数值：\n$|p_2(3) - A(3)| = |(1500 \\cdot 2^{-2/5} - 725) - (1000 \\cdot 2^{-6/5})|$。\n使用数值计算：\n$2^{-2/5} = 2^{-0.4} \\approx 0.75785828$\n$2^{-6/5} = 2^{-1.2} \\approx 0.43527530$\n\n$p_2(3) \\approx 1500(0.75785828) - 725 = 1136.78742 - 725 = 411.78742$。\n$A(3) \\approx 1000(0.43527530) = 435.27530$。\n\n绝对差异为：\n$|411.78742 - 435.27530| = |-23.48788| \\approx 23.48788$。\n四舍五入到四位有效数字得到 $23.49$。",
            "answer": "$$\\boxed{23.49}$$"
        },
        {
            "introduction": "理论告诉我们Chebyshev节点是多项式插值的最优选择，但这种节点分布是如何“自然”产生的呢？本练习将引导你通过编程实现一个自适应插值算法，该算法通过在误差最大的地方动态添加新节点来优化逼近效果。你将亲手验证，这种看似简单的“贪心”策略所生成的节点分布，是否会趋近于理论上最优的Chebyshev节点分布，从而从实践中领悟插值理论的深刻内涵。",
            "id": "2378821",
            "problem": "你需要实现一个程序，在闭区间 $[-1,1]$ 上构建一个自适应多项式插值，并定量地检验最终的插值节点集是否类似于 Chebyshev–Lobatto 分布。所有角度都必须以弧度为单位处理。\n\n给定一个实值函数 $f:[-1,1]\\to\\mathbb{R}$ 和一个有限的互异节点集 $\\{x_i\\}_{i=1}^n\\subset[-1,1]$，令 $p_n$ 表示次数至多为 $n-1$ 的唯一多项式，该多项式满足插值条件 $p_n(x_i)=f(x_i)$ 对所有 $i\\in\\{1,\\dots,n\\}$ 成立。定义插值误差为 $e_n(x)=f(x)-p_n(x)$。考虑以下节点选择规则，它生成一个节点集序列 $S_k\\subset[-1,1]$，其中 $\\lvert S_k\\rvert=n_k$：\n\n- 初始化：$S_0=\\{-1,1\\}$。\n- 迭代：对于 $k=0,1,2,\\dots$，计算与 $S_k$ 关联的多项式插值 $p_{n_k}$ 和对应的误差 $e_{n_k}(x)=f(x)-p_{n_k}(x)$。在 $[-1,1]$ 区间内一个包含 $M$ 个点的均匀网格上，找到一个点 $x^\\star\\in[-1,1]$，在该点处 $\\lvert e_{n_k}(x)\\rvert$ 在网格上达到其最大值。定义 $S_{k+1}=S_k\\cup\\{x^\\star\\}$ 并继续。\n- 终止：在第一个满足 $\\max_{x\\in\\text{grid}}\\lvert e_{n_K}(x)\\rvert\\le\\varepsilon$ 或 $n_K=n_{\\max}$ 的 $K$ 处停止迭代。\n\n将最终的节点集记为 $S_K=\\{x^{(K)}_i\\}_{i=1}^{n}$，按升序排列，其中 $n=n_K$。将 $[-1,1]$ 上的 $n$ 个 Chebyshev–Lobatto 节点定义为 $c_i=\\cos\\!\\left(\\frac{\\pi(i-1)}{n-1}\\right)$，其中 $i\\in\\{1,\\dots,n\\}$，并将它们按升序排列。通过均方根偏差 (RMSD) 来量化 $S_K$ 与 Chebyshev–Lobatto 节点之间的相似性\n$$\nr=\\sqrt{\\frac{1}{n}\\sum_{i=1}^{n}\\left(x^{(K)}_i-c_i\\right)^2}.\n$$\n你的程序必须为每个测试用例执行以下操作：\n\n- 通过上述过程，使用指定的函数 $f$、容差 $\\varepsilon$、最大节点数 $n_{\\max}$ 和网格大小 $M$ 来构建 $S_K$。\n- 对于相同的 $n$，计算排序后的 $S_K$ 和排序后的 Chebyshev–Lobatto 节点之间的 RMSD $r$。\n- 对于指定的阈值 $\\tau$，输出一个布尔值，指示是否满足 $r\\le \\tau$。\n\n所有三角函数求值均使用弧度单位。所有输出均为无量纲的。\n\n测试套件：\n\n- 案例 1 (光滑有理函数):\n  - $f(x)=\\dfrac{1}{1+25x^2}$。\n  - $\\varepsilon=5\\times 10^{-5}$。\n  - $n_{\\max}=35$。\n  - $M=8193$。\n  - $\\tau=0.20$。\n- 案例 2 (在原点不可微):\n  - $f(x)=\\lvert x\\rvert$。\n  - $\\varepsilon=3\\times 10^{-2}$。\n  - $n_{\\max}=41$。\n  - $M=8193$。\n  - $\\tau=0.20$。\n- 案例 3 (振荡解析函数；角度单位为弧度):\n  - $f(x)=\\cos(10x)$。\n  - $\\varepsilon=10^{-8}$。\n  - $n_{\\max}=45$。\n  - $M=8193$。\n  - $\\tau=0.20$。\n- 案例 4 (因节点数达到上限而提前停止):\n  - $f(x)=e^{x}$。\n  - $\\varepsilon=10^{-8}$。\n  - $n_{\\max}=10$。\n  - $M=8193$。\n  - $\\tau=0.20$。\n\n最终输出格式：\n\n- 你的程序应产生单行输出，其中包含方括号括起来的、以逗号分隔的结果列表，结果按案例 1 到 4 的顺序排列，例如 $[b_1,b_2,b_3,b_4]$，其中每个 $b_i$ 是一个布尔值。",
            "solution": "该问题是有效的。它提出了一个计算物理学中明确定义的任务，特别是在数值分析领域，涉及自适应多项式插值及其与理论上最优节点分布的联系。所有常数、函数和过程都以足够的精度指定，以允许一个唯一的、可验证的解。其基本原理——多项式插值、误差分析和 Chebyshev 节点——是基础且科学合理的。\n\n解决方案是通过对每个测试用例实施指定的自适应算法，然后进行定量比较来构建的。该过程的核心步骤如下。\n\n1.  **算法初始化**：过程在区间 $[-1, 1]$ 上开始。定义一个包含两个节点的初始集合 $S_0 = \\{-1, 1\\}$。在 $[-1, 1]$ 上创建一个由 $M$ 个点组成的精细均匀网格，记为 $\\{x_j^{\\text{grid}}\\}_{j=1}^M$，用作搜索最大插值误差的空间。\n\n2.  **迭代式节点放置**：算法迭代进行。在每一步 $k$，给定一个包含 $n_k$ 个互异节点的集合 $S_k = \\{x_i\\}_{i=1}^{n_k}$，执行以下操作：\n    -   **多项式插值**：构建一个次数至多为 $n_k-1$ 的唯一多项式 $p_{n_k}(x)$，使其在 $S_k$ 中的节点处插值给定的函数 $f(x)$，即对所有 $x_i \\in S_k$ 都有 $p_{n_k}(x_i) = f(x_i)$。为了数值稳定性和效率，最好使用重心形式的拉格朗日插值多项式来实现：\n        $$\n        p_{n_k}(x) = \\frac{\\sum_{i=1}^{n_k} \\frac{w_i}{x-x_i} f(x_i)}{\\sum_{i=1}^{n_k} \\frac{w_i}{x-x_i}}\n        $$\n        其中重心权重 $w_i$ 预先计算为 $w_i = 1 / \\prod_{j \\neq i}(x_i - x_j)$。\n    -   **误差计算**：插值误差函数 $e_{n_k}(x) = f(x) - p_{n_k}(x)$ 在预定义的网格上进行求值。找到此网格上的最大绝对误差：$E_k = \\max_{j} |e_{n_k}(x_j^{\\text{grid}})|$。\n    -   **终止检查**：如果满足以下两个条件之一，则迭代终止：最大误差低于指定的容差 ($E_k \\le \\varepsilon$)，或者节点数已达到其允许的最大值 ($n_k = n_{\\max}$)。如果过程在第 $K$ 步停止，则最终的节点集为 $S_K$。\n    -   **节点增广**：如果两个终止条件都未满足，则从网格中找出出现最大绝对误差的点 $x^\\star$。将此点添加到节点集中，形成下一次迭代的集合 $S_{k+1} = S_k \\cup \\{x^\\star\\}$。这种贪心策略旨在减少后续步骤中的最大误差。\n\n3.  **与 Chebyshev-Lobatto 节点的比较**：终止时，最终的节点集 $S_K$ 包含 $n = n_K$ 个点。最优多项式插值的理论基础表明，对于光滑函数，节点应根据反正弦分布进行分布，这是切比雪夫点的一个特征。本问题研究的是与 Chebyshev-Lobatto 节点的相似性，这些节点是 $(n-1)$ 次第一类切比雪夫多项式 $T_{n-1}(x)$ 的极值点，并且已知对于插值是近乎最优的。\n    -   最终的自适应节点 $\\{x_{i}^{(K)}\\}_{i=1}^n$ 按升序排序。\n    -   使用公式 $c_i = \\cos\\left(\\frac{\\pi(j-1)}{n-1}\\right)$ 对 $j \\in \\{1, \\dots, n\\}$ 生成一个对应的包含 $n$ 个 Chebyshev-Lobatto 节点的集合 $\\{c_i\\}_{i=1}^n$，然后也将其按升序排序。注意，该公式生成的节点是降序的，因此需要进行排序。\n\n4.  **定量分析**：两个已排序节点集之间的相似性通过均方根偏差 (RMSD) 来衡量，其定义为：\n    $$\n    r = \\sqrt{\\frac{1}{n}\\sum_{i=1}^{n}\\left(x^{(K)}_i - c_i\\right)^2}\n    $$\n    该度量提供了一个平均的衡量标准，用以表示自适应生成的节点与理论上近乎最优的 Chebyshev-Lobatto 节点之間的偏差程度。\n\n5.  **最终判定**：对于每个测试用例，将计算出的 RMSD 值 $r$ 与指定的阈值 $\\tau$ 进行比较。输出是一个布尔值：如果 $r \\le \\tau$ 则为 `True`，否则为 `False`。这为“自适应节点放置策略在给定条件下是否能产生与 Chebyshev-Lobatto 分布足够相似的分布”这一问题提供了定量回答。整个过程被封装在一个程序中，该程序处理四个指定的测试用例。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import BarycentricInterpolator\n\ndef runge_func(x):\n    \"\"\"The Runge function.\"\"\"\n    return 1.0 / (1.0 + 25.0 * x**2)\n\ndef abs_val_func(x):\n    \"\"\"The absolute value function.\"\"\"\n    return np.abs(x)\n\ndef cos_func(x):\n    \"\"\"An oscillatory function.\"\"\"\n    return np.cos(10.0 * x)\n\ndef exp_func(x):\n    \"\"\"The exponential function.\"\"\"\n    return np.exp(x)\n\ndef adaptive_interpolation(f, epsilon, n_max, M):\n    \"\"\"\n    Constructs an adaptive polynomial interpolation and returns the final node set.\n    \"\"\"\n    # Initialization\n    nodes = np.array([-1.0, 1.0])\n    x_grid = np.linspace(-1.0, 1.0, M)\n    f_grid = f(x_grid)\n\n    while True:\n        num_nodes = len(nodes)\n\n        # Create the interpolating polynomial and evaluate the error.\n        y_nodes = f(nodes)\n        \n        # BarycentricInterpolator can be numerically unstable if nodes are too close.\n        # However, for the given problem parameters, it is a suitable choice.\n        poly = BarycentricInterpolator(nodes, y_nodes)\n        p_grid = poly(x_grid)\n        \n        error_grid = np.abs(f_grid - p_grid)\n        max_error = np.max(error_grid)\n\n        # Termination conditions\n        if max_error = epsilon or num_nodes >= n_max:\n            break\n\n        # Find the point of maximum error and add it to the node set.\n        idx_max_error = np.argmax(error_grid)\n        new_node = x_grid[idx_max_error]\n        \n        # Using union1d ensures nodes remain sorted and unique.\n        nodes = np.union1d(nodes, [new_node])\n\n    return nodes\n\ndef calculate_rmsd_and_check(final_nodes, tau):\n    \"\"\"\n    Calculates the RMSD between the final nodes and Chebyshev-Lobatto nodes\n    and checks if it's below the threshold tau.\n    \"\"\"\n    n = len(final_nodes)\n\n    # The number of nodes n must be >= 2 for Chebyshev-Lobatto formula.\n    # The algorithm starts with n=2 and only adds nodes, so n >= 2 always.\n    if n  2:\n        return False # Or handle as an error, but this case shouldn't be reached.\n    \n    # Sort the adaptively generated nodes.\n    sorted_nodes = np.sort(final_nodes)\n    \n    # Generate Chebyshev-Lobatto nodes. The formula gives them in descending order,\n    # so we sort them to match the ascending order of sorted_nodes.\n    # The indices for the formula are 0, 1, ..., n-1.\n    cl_nodes_raw = np.cos(np.pi * np.arange(n) / (n - 1))\n    cl_nodes = np.sort(cl_nodes_raw)\n    \n    # Calculate Root Mean Square Deviation (RMSD).\n    rmsd = np.sqrt(np.mean((sorted_nodes - cl_nodes)**2))\n    \n    # Return boolean result of the comparison.\n    return rmsd = tau\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Case 1 (smooth rational function)\n        {'f': runge_func, 'epsilon': 5e-5, 'n_max': 35, 'M': 8193, 'tau': 0.20},\n        # Case 2 (non-differentiable at the origin)\n        {'f': abs_val_func, 'epsilon': 3e-2, 'n_max': 41, 'M': 8193, 'tau': 0.20},\n        # Case 3 (oscillatory analytic function)\n        {'f': cos_func, 'epsilon': 1e-8, 'n_max': 45, 'M': 8193, 'tau': 0.20},\n        # Case 4 (early stop by node cap)\n        {'f': exp_func, 'epsilon': 1e-8, 'n_max': 10, 'M': 8193, 'tau': 0.20},\n    ]\n\n    results = []\n    for case in test_cases:\n        final_nodes = adaptive_interpolation(case['f'], case['epsilon'], case['n_max'], case['M'])\n        result = calculate_rmsd_and_check(final_nodes, case['tau'])\n        results.append(result)\n\n    # Format the final output as specified. str(bool) gives 'True'/'False'.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}