{
    "hands_on_practices": [
        {
            "introduction": "要熟练运用牛顿型多项式，首先必须理解它与我们更熟悉的多项式标准幂级数形式之间的联系。这个练习将引导你通过基础的代数展开，将一个二次牛顿多项式转换为标准形式，从而揭示牛顿系数与标准系数之间的直接关系。这有助于巩固你对多项式不同表示法是等价的这一核心概念的理解 。",
            "id": "2189970",
            "problem": "在数值分析中，一个多项式可以用多种形式表示。考虑一个二次多项式 $P_2(x)$，写成牛顿形式，该形式是使用插值节点 $x_0$ 和 $x_1$ 构建的：\n$$P_2(x) = a_0 + a_1(x-x_0) + a_2(x-x_0)(x-x_1)$$\n在这里，$a_0, a_1$ 和 $a_2$ 是牛顿基下的系数。\n\n同一个多项式也可以写成标准的幂级数形式：\n$$P_2(x) = c_2x^2 + c_1x + c_0$$\n其中 $c_2, c_1$ 和 $c_0$ 是在标准单项式基 $\\{x^2, x, 1\\}$ 下的系数。\n\n您的任务是进行代数转换，以牛顿形式的参数 $a_0, a_1, a_2, x_0$ 和 $x_1$ 来表示系数 $c_2, c_1$ 和 $c_0$ 的表达式。请将您的最终答案表示为一个单行矩阵，其中按特定顺序包含 $c_2, c_1$ 和 $c_0$ 的表达式。",
            "solution": "从给定的牛顿形式开始：\n$$P_{2}(x)=a_{0}+a_{1}(x-x_{0})+a_{2}(x-x_{0})(x-x_{1}).$$\n展开二次因式：\n$$(x-x_{0})(x-x_{1})=x^{2}-(x_{0}+x_{1})x+x_{0}x_{1}.$$\n将其代回并展开：\n$$P_{2}(x)=a_{0}+a_{1}x-a_{1}x_{0}+a_{2}\\left[x^{2}-(x_{0}+x_{1})x+x_{0}x_{1}\\right].$$\n将 $x$ 的同次幂分组，以匹配 $P_{2}(x)=c_{2}x^{2}+c_{1}x+c_{0}$：\n$$P_{2}(x)=\\underbrace{a_{2}}_{c_{2}}x^{2}+\\underbrace{\\left(a_{1}-a_{2}(x_{0}+x_{1})\\right)}_{c_{1}}x+\\underbrace{\\left(a_{0}-a_{1}x_{0}+a_{2}x_{0}x_{1}\\right)}_{c_{0}}.$$\n因此，\n$$c_{2}=a_{2},\\quad c_{1}=a_{1}-a_{2}(x_{0}+x_{1}),\\quad c_{0}=a_{0}-a_{1}x_{0}+a_{2}x_{0}x_{1}.$$",
            "answer": "$$\\boxed{\\begin{pmatrix} a_{2}  a_{1}-a_{2}(x_{0}+x_{1})  a_{0}-a_{1}x_{0}+a_{2}x_{0}x_{1} \\end{pmatrix}}$$"
        },
        {
            "introduction": "插值的一个核心特性是多项式在插值节点上与原函数值相等。这个练习颠倒了通常的流程：它提供了一个牛顿型多项式，并要求你反向推导出它所经过的原始数据点。通过解决这个问题 ，你将更深入地理解牛顿形式的结构如何直接编码节点信息，并练习应用微积分知识来定位一个关键数据点，这在分析传感器数据或寻找最优解时非常实用。",
            "id": "2189936",
            "problem": "一个研究团队正在对新开发的传感器的瞬态行为进行建模。传感器的输出电压 $V$ 作为时间 $t$ 的函数进行测量。根据初步数据，该团队使用二次多项式 $V(t)$ 来近似其响应。该多项式是通过对三个数据点 $(t_A, V_A)$、$(t_B, V_B)$ 和 $(t_C, V_C)$ 进行插值构建的。\n\n所得的多项式以一种特定的类牛顿形式写成：\n$$V(t) = k_0 + k_1(t - t_A) + k_2(t - t_A)(t - t_C)$$\n其中常数为 $k_0 = 5$，$k_1 = -2$ 和 $k_2 = 3$。其中两个数据点的时间坐标为 $t_A = 1 \\text{ s}$ 和 $t_C = 3 \\text{ s}$。第三个数据点 $(t_B, V_B)$ 是在传感器电压在区间 $[t_A, t_C]$ 上达到其全局最小值时测得的。\n\n确定这三个数据点 $(t_A, V_A)$、$(t_B, V_B)$ 和 $(t_C, V_C)$ 的坐标。将你的答案表示为一个单行矩阵，其中包含按顺序 $t_A, V_A, t_B, V_B, t_C, V_C$ 排列的六个坐标数值。时间值以秒为单位，电压值以伏特为单位。对任何非整数值使用精确分数。",
            "solution": "我们已知传感器的二次响应的类牛顿形式为：\n$$V(t) = k_{0} + k_{1}(t - t_{A}) + k_{2}(t - t_{A})(t - t_{C}),$$\n其中 $k_{0} = 5$, $k_{1} = -2$, $k_{2} = 3$, $t_{A} = 1$ 且 $t_{C} = 3$。第三个点 $(t_{B}, V_{B})$ 对应于 $V(t)$ 在区间 $[t_{A}, t_{C}]$ 上的全局最小值。\n\n首先，通过展开来显式计算 $V(t)$：\n$$(t - t_{A})(t - t_{C}) = (t - 1)(t - 3) = t^{2} - 4t + 3.$$\n因此，\n$$V(t) = 5 - 2(t - 1) + 3(t^{2} - 4t + 3) = 5 - 2t + 2 + 3t^{2} - 12t + 9,$$\n化简后得到\n$$V(t) = 3t^{2} - 14t + 16.$$\n\n在 $t_{A}$ 和 $t_{C}$ 处计算 $V$ 的值，以得到 $V_{A}$ 和 $V_{C}$：\n- 使用给定形式，在 $t = t_{A}$ 时，$(t - t_{A}) = 0$，所以\n$$V_{A} = V(t_{A}) = k_{0} = 5.$$\n- 在 $t = t_{C}$ 时，$(t - t_{C}) = 0$，所以\n$$V_{C} = V(t_{C}) = k_{0} + k_{1}(t_{C} - t_{A}) = 5 + (-2)(3 - 1) = 1.$$\n\n为了找到在 $[1,3]$ 上的全局最小值，对 $V(t)$ 求导：\n$$V'(t) = 6t - 14.$$\n令 $V'(t) = 0$ 以找到临界点：\n$$6t - 14 = 0 \\implies t = \\frac{14}{6} = \\frac{7}{3}.$$\n由于 $V''(t) = 6 > 0$，所以 $V$ 是凸函数，该临界点是一个全局最小值。它位于区间 $[1,3]$ 内，所以 $t_{B} = \\frac{7}{3}$ 并且\n$$V_{B} = V\\!\\left(\\frac{7}{3}\\right) = 3\\left(\\frac{7}{3}\\right)^{2} - 14\\left(\\frac{7}{3}\\right) + 16 = \\frac{147}{9} - \\frac{98}{3} + 16 = \\frac{49}{3} - \\frac{98}{3} + \\frac{48}{3} = -\\frac{1}{3}.$$\n\n因此，这三个数据点是 $(t_{A}, V_{A}) = (1, 5)$，$(t_{B}, V_{B}) = \\left(\\frac{7}{3}, -\\frac{1}{3}\\right)$ 和 $(t_{C}, V_{C}) = (3, 1)$。所要求的行矩阵是 $1, 5, \\frac{7}{3}, -\\frac{1}{3}, 3, 1$。",
            "answer": "$$\\boxed{\\begin{pmatrix}1  5  \\frac{7}{3}  -\\frac{1}{3}  3  1\\end{pmatrix}}$$"
        },
        {
            "introduction": "理论知识必须通过计算实践来验证，尤其是在探索多项式插值的局限性时。这个实践任务将指导你实现牛顿插值算法，并用它来近似著名的龙格函数，你会亲眼见证一个经典的数值分析问题——龙格现象。通过比较等距节点和切比雪夫节点的插值误差 ，你将深刻体会到节点选择对高阶插值稳定性和精度的决定性影响。",
            "id": "2426405",
            "problem": "您需要使用两种节点生成策略，为龙格函数实现牛顿形式的多项式插值。从基本定义出发：对于 $n+1$ 个互异节点 $\\{x_0,\\dots,x_n\\}$ 和函数值 $\\{f(x_0),\\dots,f(x_n)\\}$，存在一个次数至多为 $n$ 的唯一多项式 $p_n(x)$，对所有 $i$ 满足 $p_n(x_i)=f(x_i)$。使用均差的递归定义和牛顿基，推导出一个数值稳定的求值算法。目标函数为在 $[-1,1]$ 上的龙格函数 $f(x)=\\dfrac{1}{1+25x^2}$。所有角度都必须以弧度为单位。\n\n您的任务是：\n- 实现一个函数，用于计算节点 $\\{x_i\\}_{i=0}^n$ 和函数值 $\\{f(x_i)\\}_{i=0}^n$ 的均差，从而得到 $p_n(x)$ 的牛顿形式系数 $\\{c_0,\\dots,c_n\\}$。\n- 实现一个函数，基于牛顿基 $\\{1,(x-x_0),(x-x_0)(x-x_1),\\dots\\}$ 和先前计算出的系数 $\\{c_k\\}_{k=0}^n$，使用嵌套乘法在任意点 $x$ 处对牛顿形式的插值多项式进行求值。\n- 对于每个次数 $n$，在 $[-1,1]$ 上生成两组插值节点：\n  - 等距节点：$x_i=-1+\\dfrac{2i}{n}$，其中 $i=0,\\dots,n$。\n  - $[-1,1]$ 上的第一类切比雪夫节点（极值点）：$x_i=\\cos\\!\\left(\\dfrac{i\\pi}{n}\\right)$，其中 $i=0,\\dots,n$。使用弧度。\n- 对于每个插值多项式，在一个由 $M$ 个在 $[-1,1]$ 上均匀分布的点构成的密集网格 $\\mathcal{G}$ 上计算 $p_n(x)$ 的值，并计算最大绝对误差 $E_{\\max}=\\max_{x\\in\\mathcal{G}}|p_n(x)-f(x)|$。\n- 所有算术运算均使用双精度。\n\n测试套件规范：\n- 使用 $[-1,1]$ 上的龙格函数 $f(x)=\\dfrac{1}{1+25x^2}$。\n- 使用一个包含 $M=10001$ 个在 $[-1,1]$ 上等距分布的点的求值网格 $\\mathcal{G}$。\n- 使用以下次数（每个次数对应 $n+1$ 个节点）：$n\\in\\{0,1,5,10,20\\}$。\n- 对于上述集合中的每个 $n$，计算两个数值：等距节点的 $E_{\\max}^{\\text{eq}}(n)$ 和切比雪夫节点的 $E_{\\max}^{\\text{ch}}(n)$（角度以弧度为单位）。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。该列表必须按以下顺序包含实数：\n  - $\\big[E_{\\max}^{\\text{eq}}(0),E_{\\max}^{\\text{ch}}(0),E_{\\max}^{\\text{eq}}(1),E_{\\max}^{\\text{ch}}(1),E_{\\max}^{\\text{eq}}(5),E_{\\max}^{\\text{ch}}(5),E_{\\max}^{\\text{eq}}(10),E_{\\max}^{\\text{ch}}(10),E_{\\max}^{\\text{eq}}(20),E_{\\max}^{\\text{ch}}(20)\\big]$。\n- 输出必须为单行，且不得包含任何额外文本。",
            "solution": "该问题从插值的核心定义出发：给定 $n+1$ 个互异节点 $\\{x_0,\\dots,x_n\\}$ 和数据值 $\\{y_0,\\dots,y_n\\}$（其中 $y_i=f(x_i)$），存在一个次数至多为 $n$ 的唯一多项式 $p_n(x)$，使得对于 $i=0,\\dots,n$ 均有 $p_n(x_i)=y_i$。牛顿形式是一种构造性表示，它结合了两个基本部分：均差和牛顿基。牛顿基被递归地定义为 $N_0(x)=1$，当 $k\\ge 1$ 时，$N_k(x)=(x-x_{k-1})N_{k-1}(x)$，由此可得 $N_k(x)=\\prod_{j=0}^{k-1}(x-x_j)$。插值多项式可以表示为 $p_n(x)=\\sum_{k=0}^n c_k N_k(x)$，其中系数 $c_k$ 是均差 $c_k=f[x_0,\\dots,x_k]$。均差通过递归从数据中确定：$f[x_i]=y_i$，并且对于 $k\\ge 1$，$f[x_i,\\dots,x_{i+k}]=\\dfrac{f[x_{i+1},\\dots,x_{i+k}]-f[x_i,\\dots,x_{i+k-1}]}{x_{i+k}-x_i}$。这种构造通过对 $i$ 进行归纳，直接编码了数据约束 $p_n(x_i)=y_i$，从而保证了存在性和唯一性。\n\n算法设计如下。首先，计算均差。我们可以在一个初始化为 $d_i^{(0)}=y_i$ 的数组 $d$ 上原地实现该递归。对于每个阶 $k=1,\\dots,n$ 和索引 $i=0,\\dots,n-k$，更新 $d_i^{(k)}=\\dfrac{d_{i+1}^{(k-1)}-d_i^{(k-1)}}{x_{i+k}-x_i}$。完成所有阶的计算后，牛顿系数为 $c_k=d_0^{(k)}$，其中 $k=0,\\dots,n$。这是一个 $O(n^2)$ 的运算，并且只使用了核心递归。\n\n第二，通过嵌套乘法（一种适用于牛顿基的类霍纳方案）高效且稳定地对插值多项式进行求值。从 $v=c_n$ 开始，对 $k=n-1,\\dots,0$ 累积计算 $v \\leftarrow c_{k}+ (x-x_k)\\,v$。这可由基恒等式 $N_k(x)=(x-x_k)N_{k+1}(x)$ 推导而来，将其重新排列以将 $p_n$ 表示为嵌套形式：$p_n(x)=c_0+(x-x_0)\\left(c_1+(x-x_1)\\left(\\dots+(x-x_{n-1})c_n\\right)\\right)$。这种求值方法对每个点是 $O(n)$ 的，并且相对于朴素的基展开是数值稳定的。\n\n对于节点布置，我们比较在 $[-1,1]$ 上的两种策略。等距节点使用 $x_i=-1+\\dfrac{2i}{n}$，其中 $i=0,\\dots,n$。第一类切比雪夫节点（极值点）为 $x_i=\\cos\\!\\left(\\dfrac{i\\pi}{n}\\right)$，其中 $i=0,\\dots,n$。这些节点在端点附近聚集，并且已知可以减小解析函数的最大插值误差。按照规定，所有三角计算都使用弧度。龙格函数 $f(x)=\\dfrac{1}{1+25x^2}$ 在 $[-1,1]$ 及其周围是解析的，但它在使用等距节点进行插值时会表现出著名的龙格现象：随着 $n$ 的增加，由于在 $x=\\pm 1$ 附近的振荡，最大误差 $E_{\\max}$ 可能会恶化。切比雪夫节点通过最小化勒贝格常数的增长并将节点密度分布在最需要的地方来缓解这种情况。\n\n为了量化这种行为，我们在一个由 $M=10001$ 个在 $[-1,1]$ 上等距分布的点构成的密集网格 $\\mathcal{G}$ 上进行求值。对于每个 $n\\in\\{0,1,5,10,20\\}$ 和每种节点策略，我们在 $\\mathcal{G}$ 上计算插值多项式 $p_n(x)$，然后计算最大绝对误差 $E_{\\max}=\\max_{x\\in\\mathcal{G}}|p_n(x)-f(x)|$。程序在单行上输出序列 $[E_{\\max}^{\\text{eq}}(0),E_{\\max}^{\\text{ch}}(0),E_{\\max}^{\\text{eq}}(1),E_{\\max}^{\\text{ch}}(1),E_{\\max}^{\\text{eq}}(5),E_{\\max}^{\\text{ch}}(5),E_{\\max}^{\\text{eq}}(10),E_{\\max}^{\\text{ch}}(10),E_{\\max}^{\\text{eq}}(20),E_{\\max}^{\\text{ch}}(20)]$。我们预计，由于龙格现象，$E_{\\max}^{\\text{eq}}(n)$ 会随着 $n$ 先减小后增大，而 $E_{\\max}^{\\text{ch}}(n)$ 则应该会更稳定地减小。\n\n实现细节确保了数值的稳健性：\n- 均差使用双精度数组进行原地计算，以避免不必要的复制。\n- 求值过程在网格上使用向量化的嵌套乘法以提高效率。\n- 对于切比雪夫节点生成器，$n=0$ 的情况被显式处理，产生单个节点 $x_0=\\cos(0)=1$。对于 $n\\ge 1$，生成节点 $\\cos\\!\\left(\\dfrac{i\\pi}{n}\\right)$（其中 $i=0,\\dots,n$）并按升序排序；当系数针对排序后的顺序重新计算时，排序不会改变插值多项式，并且它能在不同策略间产生一致的排序。\n\n这种有原则的方法直接反映了插值和均差的核心定义，利用牛顿基获得了高效的算法，并在固定网格上计算所要求的误差度量，以便在不同节点集和次数之间进行客观比较。",
            "answer": "```python\nimport numpy as np\n\ndef runge_function(x: np.ndarray) - np.ndarray:\n    # f(x) = 1 / (1 + 25 x^2)\n    return 1.0 / (1.0 + 25.0 * x * x)\n\ndef divided_differences(x: np.ndarray, y: np.ndarray) - np.ndarray:\n    \"\"\"\n    Compute Newton divided differences coefficients.\n    x: nodes (n+1,)\n    y: values at nodes (n+1,)\n    Returns coefficients c such that p(x) = c0 + c1*(x-x0) + ... in Newton form.\n    \"\"\"\n    n = x.size - 1\n    dd = y.astype(float).copy()\n    # In-place computation: dd[i] overwritten by higher-order divided differences\n    for k in range(1, n + 1):\n        # Update dd[0..n-k]\n        denom = x[k:] - x[:-k]\n        # Avoid division by zero; nodes are distinct by construction\n        dd[: n - k + 1] = (dd[1: n - k + 2] - dd[: n - k + 1]) / denom\n    # Coefficients are dd[0] at each order; we need to reconstruct them\n    # We can recompute to capture dd[0] at each stage by re-running but more efficient:\n    # Build the table once and collect c's\n    # Rebuild more explicitly:\n    dd_table = y.astype(float).copy()\n    coeffs = [dd_table[0]]\n    for k in range(1, n + 1):\n        dd_table[: n - k + 1] = (dd_table[1: n - k + 2] - dd_table[: n - k + 1]) / (x[k:] - x[:-k])\n        coeffs.append(dd_table[0])\n    return np.array(coeffs, dtype=float)\n\ndef newton_evaluate(x_eval: np.ndarray, x_nodes: np.ndarray, coeffs: np.ndarray) - np.ndarray:\n    \"\"\"\n    Evaluate Newton-form polynomial with given nodes and coefficients at x_eval.\n    Uses nested multiplication (Horner-like) for Newton basis.\n    \"\"\"\n    # Start from highest-order coefficient\n    p = np.full_like(x_eval, fill_value=coeffs[-1], dtype=float)\n    # Iterate backwards over nodes\n    for k in range(len(coeffs) - 2, -1, -1):\n        p = coeffs[k] + (x_eval - x_nodes[k]) * p\n    return p\n\ndef equispaced_nodes(n: int) - np.ndarray:\n    # n+1 nodes from -1 to 1 inclusive\n    return np.linspace(-1.0, 1.0, n + 1, dtype=float)\n\ndef chebyshev_extrema_nodes(n: int) - np.ndarray:\n    # Chebyshev nodes of the first kind (extrema): x_i = cos(i*pi/n), i=0..n\n    if n == 0:\n        nodes = np.array([1.0], dtype=float)\n    else:\n        i = np.arange(0, n + 1, dtype=float)\n        nodes = np.cos(np.pi * i / float(n))\n    # Sort ascending for consistency\n    nodes.sort()\n    return nodes\n\ndef max_abs_error_on_grid(n: int, node_strategy: str, grid: np.ndarray) - float:\n    if node_strategy == \"equispaced\":\n        x_nodes = equispaced_nodes(n)\n    elif node_strategy == \"chebyshev\":\n        x_nodes = chebyshev_extrema_nodes(n)\n    else:\n        raise ValueError(\"Unknown node strategy\")\n\n    y_nodes = runge_function(x_nodes)\n    coeffs = divided_differences(x_nodes, y_nodes)\n    p_vals = newton_evaluate(grid, x_nodes, coeffs)\n    f_vals = runge_function(grid)\n    err = np.abs(p_vals - f_vals)\n    return float(np.max(err))\n\ndef solve():\n    # Define the test cases: degrees n\n    n_values = [0, 1, 5, 10, 20]\n    # Evaluation grid of M=10001 points on [-1,1]\n    M = 10001\n    grid = np.linspace(-1.0, 1.0, M, dtype=float)\n\n    results = []\n    for n in n_values:\n        e_eq = max_abs_error_on_grid(n, \"equispaced\", grid)\n        e_ch = max_abs_error_on_grid(n, \"chebyshev\", grid)\n        results.append(e_eq)\n        results.append(e_ch)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}