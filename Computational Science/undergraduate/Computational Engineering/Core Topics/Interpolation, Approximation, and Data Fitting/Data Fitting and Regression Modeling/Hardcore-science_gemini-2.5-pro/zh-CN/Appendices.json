{
    "hands_on_practices": [
        {
            "introduction": "在工程和科学领域，我们常常从物理第一性原理推导出描述系统行为的数学模型，但这些模型中通常包含一些未知的物理参数。本练习将引导你完成一个经典流程：通过悬臂梁的实验挠度数据，拟合基于欧拉-伯努利梁理论推导出的物理模型，从而估计材料的关键属性——杨氏模量 $E$ 。这个实践不仅连接了理论力学与数据分析，还展示了如何将一个物理问题转化为一个线性最小二乘拟合任务。",
            "id": "2383151",
            "problem": "您的任务是通过拟合等截面悬臂梁在静载荷作用下的挠度数据，来估算材料的杨氏模量 $E$。建模假设必须与 Euler–Bernoulli 梁理论保持一致。只能从以下基本原理和核心定义出发，且在推导过程中不得使用任何预先推导出的挠度公式。\n\n基本原理：\n- 对于具有恒定面积二次矩的等截面梁的小挠度情况，Euler–Bernoulli 梁理论指出其曲率满足 $\\,\\kappa(x) = \\dfrac{d^2 y}{dx^2} = \\dfrac{M(x)}{E I}\\,$，其中 $y(x)$ 是横向挠度，$M(x)$ 是内部弯矩，$E$ 是杨氏模量，$I$ 是绕中性轴的面积二次矩。\n- 对于一根在 $x=0$ 处固定、在 $x=L$ 处自由的悬臂梁，其固定端的边界条件为 $\\,y(0)=0\\,$ 和 $\\,y'(0)=0\\,$。\n- 对于宽度为 $b$（平面外方向）和厚度为 $h$（弯曲方向）的矩形截面，其面积二次矩为 $\\,I = \\dfrac{b h^3}{12}\\,$。\n- 我们关心的两种载荷情况下的内部弯矩函数 $M(x)$ 分别是：\n  1. 在自由端 $x=L$ 处向下施加大小为 $F$ 的尖端点载荷：$\\,M(x) = F\\,(L-x)\\,$（符号约定选择为向下挠度为正）。\n  2. 沿整个跨度 $[0,L]$ 向下施加集度为 $q$（单位长度上的力）的均布载荷：$\\,M(x) = \\dfrac{q}{2}\\,(L-x)^2\\,$。\n\n任务：\n1. 从 $\\,\\dfrac{d^2 y}{dx^2} = \\dfrac{M(x)}{E I}\\,$ 和 $x=0$ 处的悬臂梁边界条件出发，为上述两种载荷情况推导挠度 $y(x)$ 的表达式。表达式应仅用 $x$、$L$、相应的载荷参数（$F$ 或 $q$）以及未知材料参数 $E$ 来表示（其中 $I$ 可由 $b$ 和 $h$ 得知）。\n2. 证明对于每种载荷情况，挠度都可以写成参数线性形式 $\\,y(x) = a\\,\\phi(x)\\,$，其中 $\\,a = \\dfrac{1}{E I}\\,$，而 $\\,\\phi(x)\\,$ 是一个仅由 $x$、$L$ 和载荷参数（$F$ 或 $q$）决定的已知形状函数。\n3. 使用线性最小二乘法原理，对于给定的测量挠度 $\\{(x_i, y_i)\\}_{i=1}^n$，确定使 $\\sum_{i=1}^n \\big(y_i - a\\,\\phi(x_i)\\big)^2$ 最小化的估计量 $\\,\\hat{a}\\,$。然后计算 $\\,\\hat{E} = \\dfrac{1}{\\hat{a}\\,I}\\,$。\n4. 实现一个完整、可运行的程序，该程序：\n   - 对以下三个测试用例进行编码，\n   - 根据 $b$ 和 $h$ 计算 $I$，\n   - 根据您推导的表达式为每个测试用例构建相应的 $\\phi(x_i)$，\n   - 通过最小二乘法拟合 $a$ 并返回每个用例的 $\\,\\hat{E}\\,$。\n\n物理单位和答案格式：\n- 所有几何量的单位均为米，力的单位为牛顿，载荷的单位为牛顿/米。杨氏模量必须以帕斯卡（pascals）为单位报告。\n- 您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个条目都是以帕斯卡为单位的 $\\,\\hat{E}\\,$，并使用小数点后保留三位数字的科学记数法（例如 $\\,2.100\\mathrm{e}{+11}\\,$）。因此，最终要求的输出格式与 $\\,\\big[\\hat{E}_1,\\hat{E}_2,\\hat{E}_3\\big]\\,$ 完全相同，其中每个 $\\,\\hat{E}_k\\,$ 都是一个采用科学记数法且小数点后有三位数字的浮点数。\n\n测试套件（请完全按照给定的参数集实现；对于每个用例，请根据提供的测量数据拟合 $\\,\\hat{E}\\,$）：\n- 用例 A（尖端点载荷）：\n  - $L = 0.5\\,\\mathrm{m}$，$b = 0.02\\,\\mathrm{m}$，$h = 0.004\\,\\mathrm{m}$，$F = 5.0\\,\\mathrm{N}$。\n  - 位置 $x$（单位：米）：$[\\,0.1,\\,0.2,\\,0.3,\\,0.4,\\,0.5\\,]$。\n  - 测量挠度 $y$（单位：米）：$[\\,0.001634905658,\\,0.005786792453,\\,0.012306415076,\\,0.019904528282,\\,0.028301886750\\,]$。\n- 用例 B（均布载荷）：\n  - $L = 1.0\\,\\mathrm{m}$，$b = 0.03\\,\\mathrm{m}$，$h = 0.01\\,\\mathrm{m}$，$q = 200.0\\,\\mathrm{N/m}$。\n  - 位置 $x$（单位：米）：$[\\,0.2,\\,0.4,\\,0.6,\\,0.8,\\,1.0\\,]$。\n  - 测量挠度 $y$（单位：米）：$[\\,0.003307,\\,0.011611,\\,0.02263,\\,0.03495,\\,0.04766905\\,]$。\n- 用例 C（尖端点载荷，最少数据）：\n  - $L = 0.3\\,\\mathrm{m}$，$b = 0.015\\,\\mathrm{m}$，$h = 0.003\\,\\mathrm{m}$，$F = 0.2\\,\\mathrm{N}$。\n  - 位置 $x$（单位：米）：$[\\,0.15,\\,0.3\\,]$。\n  - 测量挠度 $y$（单位：米）：$[\\,0.005188,\\,0.0166767\\,]$。\n\n覆盖性设计：\n- 用例 A 是一个针对尖端载荷的良态多点拟合。\n- 用例 B 测试了具有更大抗弯刚度和均布载荷（UDL）的不同载荷情况。\n- 用例 C 是一个仅有两个测量值的边缘情况，用于测试在最小样本量下的单参数回归。\n\n您的程序必须以 $[E_1,E_2,E_3]$ 的精确格式输出单行结果，其中每个条目都是以帕斯卡为单位的 $\\,\\hat{E}\\,$，表示为小数点后有三位数字的科学记数法浮点数，且不含任何额外文本。请使用双精度算术以确保数值稳定性。",
            "solution": "所述问题是有效的。其科学依据是固体力学的基本原理，特别是 Euler–Bernoulli 梁理论，并采用了标准的参数估计技术，即线性最小二乘法。该问题是适定的，提供了唯一确定所需量（杨氏模量 $E$）所必需的所有物理参数、边界条件和测量数据。其语言客观，定义精确。因此，我们着手进行求解。\n\n任务是根据挠度数据估算杨氏模量 $E$。这需要将挠度 $y(x)$ 表示为一个在参数 $a = \\frac{1}{EI}$ 上呈线性的函数，其中 $I$ 是面积二次矩。我们将首先推导两种指定载荷情况下的挠度方程。\n\n**1. 挠度方程的推导**\n\n梁挠度 $y(x)$ 的控制微分方程如下：\n$$\n\\frac{d^2 y}{dx^2} = \\frac{M(x)}{E I}\n$$\n对于在 $x=0$ 处固定的悬臂梁，其固定端的边界条件是挠度和转角均为零：\n$$\ny(0) = 0 \\quad \\text{和} \\quad \\frac{dy}{dx}(0) = 0\n$$\n\n**情况一：尖端点载荷 $F$**\n\n内部弯矩函数为 $M(x) = F(L-x)$。将其代入控制方程：\n$$\n\\frac{d^2 y}{dx^2} = \\frac{F(L-x)}{E I}\n$$\n我们对 $x$ 进行积分以求得转角 $\\frac{dy}{dx}$：\n$$\n\\frac{dy}{dx}(x) = \\int \\frac{F(L-x)}{E I} dx = \\frac{F}{E I} \\left( Lx - \\frac{x^2}{2} \\right) + C_1\n$$\n应用边界条件 $\\frac{dy}{dx}(0) = 0$：\n$$\n\\frac{dy}{dx}(0) = \\frac{F}{E I} \\left( L(0) - \\frac{0^2}{2} \\right) + C_1 = 0 \\implies C_1 = 0\n$$\n因此，转角为 $\\frac{dy}{dx}(x) = \\frac{F}{E I} \\left( Lx - \\frac{x^2}{2} \\right)$。接下来，我们再次积分以求得挠度 $y(x)$：\n$$\ny(x) = \\int \\frac{F}{E I} \\left( Lx - \\frac{x^2}{2} \\right) dx = \\frac{F}{E I} \\left( L\\frac{x^2}{2} - \\frac{x^3}{6} \\right) + C_2\n$$\n应用边界条件 $y(0) = 0$：\n$$\ny(0) = \\frac{F}{E I} \\left( L\\frac{0^2}{2} - \\frac{0^3}{6} \\right) + C_2 = 0 \\implies C_2 = 0\n$$\n因此，尖端点载荷下的挠度方程为：\n$$\ny(x) = \\frac{F}{E I} \\left( \\frac{Lx^2}{2} - \\frac{x^3}{6} \\right)\n$$\n\n**情况二：均布载荷 $q$**\n\n内部弯矩函数为 $M(x) = \\frac{q}{2}(L-x)^2$。将其代入控制方程：\n$$\n\\frac{d^2 y}{dx^2} = \\frac{q}{2E I}(L-x)^2\n$$\n积分一次求转角：\n$$\n\\frac{dy}{dx}(x) = \\int \\frac{q}{2E I}(L-x)^2 dx = \\frac{q}{2E I} \\left( -\\frac{(L-x)^3}{3} \\right) + C_1\n$$\n应用边界条件 $\\frac{dy}{dx}(0) = 0$：\n$$\n\\frac{dy}{dx}(0) = \\frac{q}{2E I} \\left( -\\frac{L^3}{3} \\right) + C_1 = 0 \\implies C_1 = \\frac{qL^3}{6EI}\n$$\n因此，转角为 $\\frac{dy}{dx}(x) = \\frac{q}{6EI} \\left( L^3 - (L-x)^3 \\right)$。再次积分求挠度：\n$$\ny(x) = \\int \\frac{q}{6EI} \\left( L^3 - (L-x)^3 \\right) dx = \\frac{q}{6EI} \\left( L^3x + \\frac{(L-x)^4}{4} \\right) + C_2\n$$\n应用边界条件 $y(0) = 0$：\n$$\ny(0) = \\frac{q}{6EI} \\left( 0 + \\frac{L^4}{4} \\right) + C_2 = 0 \\implies C_2 = -\\frac{qL^4}{24EI}\n$$\n挠度方程为：\n$$\ny(x) = \\frac{q}{6EI} \\left( L^3x + \\frac{(L-x)^4}{4} \\right) - \\frac{qL^4}{24EI} = \\frac{q}{24EI} \\left( 4L^3x + (L-x)^4 - L^4 \\right)\n$$\n展开多项式 $(L-x)^4 = L^4 - 4L^3x + 6L^2x^2 - 4Lx^3 + x^4$ 并代入，得到简化形式：\n$$\ny(x) = \\frac{q}{24EI} \\left( 6L^2x^2 - 4Lx^3 + x^4 \\right) = \\frac{qx^2}{24EI} \\left( 6L^2 - 4Lx + x^2 \\right)\n$$\n\n**2. 参数线性模型与最小二乘估计**\n\n对于这两种情况，挠度方程都可以写成 $y(x) = a \\phi(x)$ 的形式，其中 $a = \\frac{1}{EI}$。\n- 对于尖端载荷 $F$：$\\phi_F(x) = F \\left( \\frac{Lx^2}{2} - \\frac{x^3}{6} \\right)$。\n- 对于均布载荷 $q$：$\\phi_q(x) = \\frac{qx^2}{24} \\left( 6L^2 - 4Lx + x^2 \\right)$。\n\n给定一组包含 $n$ 个带噪声的挠度测量值 $\\{(x_i, y_i)\\}_{i=1}^n$，我们寻求使误差平方和 $S(a)$ 最小化的参数估计值 $\\hat{a}$：\n$$\nS(a) = \\sum_{i=1}^n \\left( y_i - a \\phi(x_i) \\right)^2\n$$\n为求最小值，我们将 $S(a)$ 对 $a$ 的导数置为零：\n$$\n\\frac{dS}{da} = \\sum_{i=1}^n 2 \\left( y_i - a\\phi(x_i) \\right) (-\\phi(x_i)) = -2 \\sum_{i=1}^n \\left( y_i\\phi(x_i) - a\\phi(x_i)^2 \\right) = 0\n$$\n这可以简化为：\n$$\n\\sum_{i=1}^n y_i\\phi(x_i) = \\hat{a} \\sum_{i=1}^n \\phi(x_i)^2\n$$\n解出估计量 $\\hat{a}$：\n$$\n\\hat{a} = \\frac{\\sum_{i=1}^n y_i \\phi(x_i)}{\\sum_{i=1}^n \\phi(x_i)^2}\n$$\n这是通过原点的线性回归模型的斜率的标准公式。\n\n**3. 计算步骤**\n\n程序将为每个测试用例实现以下步骤：\n1.  根据给定的梁几何形状计算面积二次矩 $I = \\frac{b h^3}{12}$。\n2.  确定载荷情况，并使用相应的 $\\phi(x)$ 推导表达式，构建基函数值的向量 $\\mathbf{\\Phi} = [\\phi(x_1), \\phi(x_2), \\dots, \\phi(x_n)]^T$。\n3.  使用测量的挠度向量 $\\mathbf{y} = [y_1, y_2, \\dots, y_n]^T$，通过点积公式计算估计值 $\\hat{a}$：$\\hat{a} = \\frac{\\mathbf{y}^T \\mathbf{\\Phi}}{\\mathbf{\\Phi}^T \\mathbf{\\Phi}}$。\n4.  根据 $\\hat{a}$ 和 $I$ 计算估算的杨氏模量 $\\hat{E}$：\n    $$\n    \\hat{E} = \\frac{1}{\\hat{a} I}\n    $$\n每个测试用例的结果将按要求格式化并打印。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for Young's Modulus E for three test cases of cantilever beam deflection.\n    The solution follows the derivation of beam deflection from Euler-Bernoulli theory\n    and uses linear least squares to fit the model parameter a = 1/(EI).\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"case_id\": \"A\",\n            \"type\": \"point_load\",\n            \"L\": 0.5,  # m\n            \"b\": 0.02, # m\n            \"h\": 0.004, # m\n            \"F\": 5.0,  # N\n            \"x_data\": np.array([0.1, 0.2, 0.3, 0.4, 0.5]), # m\n            \"y_data\": np.array([0.001634905658, 0.005786792453, 0.012306415076, 0.019904528282, 0.028301886750]) # m\n        },\n        {\n            \"case_id\": \"B\",\n            \"type\": \"uniform_load\",\n            \"L\": 1.0,  # m\n            \"b\": 0.03, # m\n            \"h\": 0.01, # m\n            \"q\": 200.0, # N/m\n            \"x_data\": np.array([0.2, 0.4, 0.6, 0.8, 1.0]), # m\n            \"y_data\": np.array([0.003307, 0.011611, 0.02263, 0.03495, 0.04766905]) # m\n        },\n        {\n            \"case_id\": \"C\",\n            \"type\": \"point_load\",\n            \"L\": 0.3,  # m\n            \"b\": 0.015, # m\n            \"h\": 0.003, # m\n            \"F\": 0.2,  # N\n            \"x_data\": np.array([0.15, 0.3]), # m\n            \"y_data\": np.array([0.005188, 0.0166767]) # m\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Step 1: Calculate area second moment of inertia (I)\n        b, h = case[\"b\"], case[\"h\"]\n        I = (b * h**3) / 12\n\n        # Step 2: Construct the basis function phi(x)\n        L = case[\"L\"]\n        x = case[\"x_data\"]\n        y_measured = case[\"y_data\"]\n\n        if case[\"type\"] == \"point_load\":\n            F = case[\"F\"]\n            # phi_F(x) = F * (L*x^2/2 - x^3/6)\n            phi_values = F * (L * x**2 / 2 - x**3 / 6)\n        elif case[\"type\"] == \"uniform_load\":\n            q = case[\"q\"]\n            # phi_q(x) = (q*x^2/24) * (6*L^2 - 4*L*x + x^2)\n            phi_values = (q * x**2 / 24) * (6 * L**2 - 4 * L * x + x**2)\n        else:\n            # This case should not be reached with the given test suite\n            continue\n\n        # Step 3: Fit 'a' by linear least squares\n        # The estimator a_hat = sum(y_i * phi_i) / sum(phi_i^2)\n        # This is equivalent to (y^T * phi) / (phi^T * phi)\n        numerator = np.dot(y_measured, phi_values)\n        denominator = np.dot(phi_values, phi_values)\n        a_hat = numerator / denominator\n\n        # Step 4: Compute Young's Modulus E\n        # a = 1/(E*I) => E = 1/(a*I)\n        E_hat = 1 / (a_hat * I)\n        \n        results.append(E_hat)\n\n    # Format the final list of results into the required string format\n    # Example format required: [2.100e+11,7.000e+10,3.150e+09]\n    formatted_results = [f\"{res:.3e}\" for res in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "许多重要的科学模型本质上是非线性的，例如描述化学反应速率与温度关系的阿伦尼乌斯方程。本练习将向你展示一个强大的技术：通过数学变换（此处为对数变换）将非线性模型转化为线性形式，从而能够应用我们熟悉的普通最小二乘法进行参数估计 。你将通过拟合实验数据来确定化学反应的活化能 $E_a$，深刻理解模型变换在数据拟合中的巧妙应用。",
            "id": "2383201",
            "problem": "您的任务是构建一个完整的、可运行的程序，通过拟合在化学动力学中广泛使用的热活化速率模型，从与温度相关的反应速率数据中估计活化能。请从以下经过充分检验的温度依赖性模型开始：一个热活化过程的速率常数 $k(T)$ 遵循阿伦尼乌斯定律，该定律指出，存在一个指前因子 $A$ 和一个活化能 $E_a$，使得 $k(T)$ 通过指数温度依赖性与绝对温度 $T$ 相关。您的工作是构建并论证一个估计流程，该流程基于在适当噪声模型下的最大似然估计 (MLE) 第一性原理，通过变换将其转化为线性回归模型，然后实现该流程以从提供的数据中估计 $E_a$。\n\n基本原理与任务：您必须从热活化反应速率模型以及线性回归和最小二乘估计的基本定义出发。使用普适气体常数 $R$，其值为 $R = 8.314462618$，单位为 $\\mathrm{J \\cdot mol^{-1} \\cdot K^{-1}}$。假设数据由数对 $(T_i, k_i)$ 组成，其中 $T_i$ 的单位为 $\\mathrm{K}$，$k_i$ 的单位为 $\\mathrm{s^{-1}}$，并且适当的变换会产生一个适合普通最小二乘法 (OLS) 的线性模型。在此基础上，推导出一个理论上合理的活化能 $E_a$ 和指前因子 $A$ 的估计量，并解释该估计量为何是合适的。然后实现该估计量，以计算几个测试案例的 $E_a$。\n\n要求：\n- 从第一性原理出发，从热活化速率模型和线性回归模型的定义结合一个合理的噪声假设，推导出估计方法。\n- 将估计方法实现为一个程序，该程序接收下面提供的固定测试数据集（硬编码在您的程序中），拟合模型，并输出估计的活化能。\n\n数据与测试套件：\n使用以下四个数据集（每个数据集都是一个温度列表和相应的速率常数列表）。所有温度单位均为 $\\mathrm{K}$，所有速率常数单位均为 $\\mathrm{s^{-1}}$。您的程序必须为每个数据集独立计算一个活化能估计值。这些数据集是：\n- 情况 $1$ (一般多温度数据集):\n  - 温度 $T$: $[290.0,310.0,330.0,350.0,370.0,390.0]$\n  - 速率 $k$: $[0.0201,0.0954,0.38,1.49,5.37,17.9]$\n- 情况 $2$ (用于线性拟合的最少点数的边界情况):\n  - 温度 $T$: $[300.0,360.0]$\n  - 速率 $k$: $[0.10,3.20]$\n- 情况 $3$ (温度范围窄，可能存在条件数挑战):\n  - 温度 $T$: $[345.0,350.0,355.0,360.0]$\n  - 速率 $k$: $[2.10,2.95,4.10,5.60]$\n- 情况 $4$ (最高温度数据点存在异常值):\n  - 温度 $T$: $[310.0,330.0,350.0,370.0,390.0]$\n  - 速率 $k$: $[0.25,0.90,4.10,15.0,12.0]$\n\n输出规格：\n- 对于每个数据集，计算活化能估计值 $\\widehat{E}_a$，单位为 $\\mathrm{J \\cdot mol^{-1}}$。\n- 将每个 $\\widehat{E}_a$ 四舍五入到最近的整数（使用标准的四舍五入到最近整数的规则）。\n- 您的程序应生成单行输出，其中包含四个案例的结果，形式为逗号分隔的列表，并用方括号括起来，顺序为情况 $1$、情况 $2$、情况 $3$、情况 $4$。输出必须是 $[\\widehat{E}_{a,1},\\widehat{E}_{a,2},\\widehat{E}_{a,3},\\widehat{E}_{a,4}]$ 形式的单行，不能有其他内容。\n\n角度单位不适用。不涉及百分比。所有物理量均需使用指定单位表示。确保您的实现明确使用 $R = 8.314462618$，单位为 $\\mathrm{J \\cdot mol^{-1} \\cdot K^{-1}}$，且温度单位为 $\\mathrm{K}$。\n\n您的程序必须是自包含的，不需要用户输入，并严格遵守上述指定的输出格式。四个案例的最终答案必须是按规定要求的数值（四舍五入后的整数）。该程序应编写为可在任何现代编程环境中运行，并且对于给定的固定数据集必须是确定性的。单行输出必须将所有四个测试案例的结果汇总在一个列表中，例如 $[r_1,r_2,r_3,r_4]$。",
            "solution": "所提出的问题是计算工程和化学动力学中的一个标准且有效的练习。它要求从与温度相关的速率常数数据 $k(T)$ 中估计活化能 $E_a$。这项任务的基础是阿伦尼乌斯方程，它是物理化学的基石。该问题设定良好，有科学依据，并为获得唯一解提供了所有必要的数据和常数。我们将首先严格推导估计方法，然后进行实现。\n\n对于一个热活化过程，速率常数 $k(T)$ 的温度依赖性由阿伦尼乌斯定律描述：\n$$k(T) = A e^{-E_a / (RT)}$$\n这里，$A$ 是指前因子，$E_a$ 是活化能，$R$ 是普适气体常数，$T$ 是绝对温度。该模型对于其参数 $A$ 和 $E_a$ 是非线性的。为了应用线性回归技术，我们必须首先将方程转化为线性形式。这可以通过对等式两边取自然对数来实现：\n$$\\ln(k(T)) = \\ln\\left(A e^{-E_a / (RT)}\\right)$$\n利用对数的性质，上式可简化为：\n$$\\ln(k(T)) = \\ln(A) - \\frac{E_a}{R} \\frac{1}{T}$$\n此方程现在是线性方程 $y = c + m x$ 的形式，我们可以做出以下对应：\n- 因变量是 $y_i = \\ln(k_i)$。\n- 自变量是 $x_i = 1/T_i$。\n- 截距是 $c = \\ln(A)$。\n- 斜率是 $m = -E_a/R$。\n\n我们给定 $n$ 个数据对 $(T_i, k_i)$。在变换后的空间中，我们对每个数据点的模型是：\n$$y_i = c + m x_i + \\epsilon_i$$\n其中 $\\epsilon_i$ 表示与第 $i$ 次测量相关的噪声或误差。为了推导出一个有原则的估计量，我们必须对该误差的统计特性做出一个合理的假设。我们将使用最大似然估计 (MLE) 的原理。一个常见且在物理上合理的假设是，线性化模型中的误差 $\\epsilon_i$ 是独立同分布 (i.i.d.) 的正态随机变量，其均值为零，方差为常数 $\\sigma^2$，记作 $\\epsilon_i \\sim \\mathcal{N}(0, \\sigma^2)$。这个假设是合理的，因为速率常数 $k_i$ 测量中的实验不确定性通常与其值成正比。对数变换稳定了该方差，使得在变换域中对 $\\epsilon_i$ 作出方差齐性（恒定方差）的假设是合理的。\n\n在此高斯噪声假设下，观测到单个数据点 $y_i$ 的似然由正态概率密度函数给出：\n$$p(y_i | x_i, c, m, \\sigma^2) = \\frac{1}{\\sqrt{2\\pi\\sigma^2}} \\exp\\left(-\\frac{(y_i - (c + mx_i))^2}{2\\sigma^2}\\right)$$\n对于包含 $n$ 个独立点的整个数据集，总似然函数 $L$ 是各个概率的乘积：\n$$L(c, m, \\sigma^2 | \\mathbf{y}) = \\prod_{i=1}^n p(y_i | x_i, c, m, \\sigma^2) = \\left(2\\pi\\sigma^2\\right)^{-n/2} \\exp\\left(-\\frac{1}{2\\sigma^2} \\sum_{i=1}^n (y_i - c - mx_i)^2\\right)$$\n为了找到使该似然最大化的参数 $c$ 和 $m$，我们可以等价地最大化对数似然 $\\ln L$：\n$$\\ln L(c, m, \\sigma^2 | \\mathbf{y}) = -\\frac{n}{2}\\ln(2\\pi\\sigma^2) - \\frac{1}{2\\sigma^2} \\sum_{i=1}^n (y_i - c - mx_i)^2$$\n关于 $c$ 和 $m$ 最大化此表达式等价于最小化残差平方和 (RSS)：\n$$\\text{RSS}(c, m) = \\sum_{i=1}^n (y_i - c - mx_i)^2$$\n这个最小化问题就是普通最小二乘法 (OLS) 的定义。因此，对线性化数据应用 OLS 可为参数 $c$ 和 $m$ 提供最大似然估计。\n\nOLS 问题可以优雅地用矩阵形式表示。我们定义观测向量 $\\mathbf{y}$、设计矩阵 $\\mathbf{X}$ 和参数向量 $\\boldsymbol{\\beta}$ 如下：\n$$\\mathbf{y} = \\begin{pmatrix} \\ln(k_1) \\\\ \\ln(k_2) \\\\ \\vdots \\\\ \\ln(k_n) \\end{pmatrix}, \\quad \\mathbf{X} = \\begin{pmatrix} 1/T_1  1 \\\\ 1/T_2  1 \\\\ \\vdots  \\vdots \\\\ 1/T_n  1 \\end{pmatrix}, \\quad \\boldsymbol{\\beta} = \\begin{pmatrix} m \\\\ c \\end{pmatrix} = \\begin{pmatrix} -E_a/R \\\\ \\ln(A) \\end{pmatrix}$$\n线性模型则为 $\\mathbf{y} = \\mathbf{X}\\boldsymbol{\\beta} + \\boldsymbol{\\epsilon}$。最小化残差向量的欧几里得范数平方 $\\|\\mathbf{y} - \\mathbf{X}\\boldsymbol{\\beta}\\|_2^2$ 的 OLS 估计 $\\hat{\\boldsymbol{\\beta}}$ 是正规方程的解：\n$$(\\mathbf{X}^T \\mathbf{X}) \\hat{\\boldsymbol{\\beta}} = \\mathbf{X}^T \\mathbf{y}$$\n解由 $\\hat{\\boldsymbol{\\beta}} = (\\mathbf{X}^T \\mathbf{X})^{-1} \\mathbf{X}^T \\mathbf{y}$ 给出。这可以使用标准的线性最小二乘算法进行数值计算。从估计的参数向量 $\\hat{\\boldsymbol{\\beta}} = [\\hat{m}, \\hat{c}]^T$ 中，我们提取斜率 $\\hat{m}$。然后直接计算活化能的估计值 $\\widehat{E}_a$：\n$$\\widehat{E}_a = -\\hat{m} R$$\n我们将使用给定的普适气体常数值 $R = 8.314462618 \\mathrm{J \\cdot mol^{-1} \\cdot K^{-1}}$。\n\n实现过程将按以下步骤处理四个数据集中的每一个：\n1. 将原始数据 $(T_i, k_i)$ 变换到线性坐标 $(x_i, y_i) = (1/T_i, \\ln(k_i))$。\n2. 构建设计矩阵 $\\mathbf{X}$ 和观测向量 $\\mathbf{y}$。\n3. 求解线性最小二乘问题 $\\mathbf{y} \\approx \\mathbf{X}\\boldsymbol{\\beta}$ 以获得估计的斜率 $\\hat{m}$。\n4. 计算 $\\widehat{E}_a = -\\hat{m} R$。\n5. 将 $\\widehat{E}_a$ 的结果四舍五入到最近的整数，单位为 $\\mathrm{J \\cdot mol^{-1}}$。\n所有四个案例的结果将被汇总成指定的输出格式。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# The problem statement allows for scipy, but numpy.linalg.lstsq provides a more\n# fundamental implementation of the derived least-squares solution, which aligns\n# with the first-principles derivation.\n\ndef solve():\n    \"\"\"\n    Estimates activation energy from temperature-dependent rate data\n    using a linearized Arrhenius model and Ordinary Least Squares.\n    \"\"\"\n    # Define the universal gas constant as specified.\n    # R has units of J * mol^{-1} * K^{-1}.\n    R = 8.314462618\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple of (Temperatures in K, Rate constants in s^{-1}).\n    test_cases = [\n        # Case 1 (general multitemperature dataset)\n        (np.array([290.0, 310.0, 330.0, 350.0, 370.0, 390.0]),\n         np.array([0.0201, 0.0954, 0.38, 1.49, 5.37, 17.9])),\n\n        # Case 2 (boundary case with the minimum number of points)\n        (np.array([300.0, 360.0]),\n         np.array([0.10, 3.20])),\n\n        # Case 3 (narrow temperature span)\n        (np.array([345.0, 350.0, 355.0, 360.0]),\n         np.array([2.10, 2.95, 4.10, 5.60])),\n\n        # Case 4 (presence of an outlier)\n        (np.array([310.0, 330.0, 350.0, 370.0, 390.0]),\n         np.array([0.25, 0.90, 4.10, 15.0, 12.0]))\n    ]\n\n    estimated_energies = []\n    \n    for T_data, k_data in test_cases:\n        # Step 1: Linearize the data according to the Arrhenius equation.\n        # y = ln(k)\n        # x = 1/T\n        y = np.log(k_data)\n        x = 1.0 / T_data\n\n        # Step 2: Set up the linear least-squares problem y = X * beta.\n        # The model is y = m*x + c, so beta = [m, c]^T.\n        # The design matrix X has columns for x and a constant for the intercept.\n        X = np.vstack([x, np.ones(len(x))]).T\n\n        # Step 3: Solve for the parameters [slope, intercept] using OLS.\n        # numpy.linalg.lstsq solves the equation y = X * beta for beta.\n        # The first element of the returned solution vector is the slope, m.\n        # rcond=None is specified to use the machine-precision default.\n        slope, intercept = np.linalg.lstsq(X, y, rcond=None)[0]\n\n        # Step 4: Calculate the activation energy from the slope.\n        # The slope m = -E_a / R.\n        # Therefore, E_a = -slope * R.\n        # The result E_a will be in J * mol^{-1}.\n        activation_energy = -slope * R\n\n        # Step 5: Round the result to the nearest integer as required.\n        rounded_E_a = int(round(activation_energy))\n        estimated_energies.append(rounded_E_a)\n\n    # Final print statement in the exact required format.\n    # The output is a comma-separated list of integers enclosed in brackets.\n    print(f\"[{','.join(map(str, estimated_energies))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "虽然普通最小二乘法（OLS）是回归分析的基石，但它对数据中的异常值（outliers）极为敏感，一个错误的测量点就可能完全扭曲拟合结果。本练习旨在通过一个精心设计的案例，让你直观地看到 OLS 的脆弱性，并引入一种更稳健的替代方法——基于胡伯损失（Huber loss）的回归分析 。通过比较两种方法在含异常值数据集上的表现，你将理解稳健回归为何在处理真实世界数据时至关重要。",
            "id": "2383160",
            "problem": "本题要求您为一个包含单个预测变量和一个截距的简单线性模型实现并比较两种估计量：普通最小二乘法 (OLS) 估计量和基于 Huber 损失的稳健估计量。该模型为\n$$\ny_i = a\\,x_i + b + \\varepsilon_i,\\quad i=1,\\dots,N,\n$$\n其中 $a$ 是斜率，$b$ 是截距，$\\varepsilon_i$ 是残差。对于 OLS，参数估计 $(\\hat a_{\\mathrm{OLS}}, \\hat b_{\\mathrm{OLS}})$ 定义为残差平方和的最小化子\n$$\n(\\hat a_{\\mathrm{OLS}}, \\hat b_{\\mathrm{OLS}}) \\in \\arg\\min_{a,b} \\sum_{i=1}^{N} \\left(y_i - a\\,x_i - b\\right)^2.\n$$\n对于稳健估计量，定义参数为 $\\delta>0$ 的 Huber 损失为\n$$\n\\phi_\\delta(r) = \\begin{cases} \n\\dfrac{1}{2} r^2,  \\text{if } |r| \\le \\delta, \\\\[6pt]\n\\delta\\left(|r| - \\dfrac{1}{2}\\delta\\right),  \\text{if } |r| > \\delta,\n\\end{cases}\n$$\n并设\n$$\n(\\hat a_{\\mathrm{Huber}}, \\hat b_{\\mathrm{Huber}}) \\in \\arg\\min_{a,b} \\sum_{i=1}^{N} \\phi_\\delta\\!\\left(y_i - a\\,x_i - b\\right).\n$$\n\n请实现一个程序，构建以下三个确定性测试用例，并为每个用例计算 $(\\hat a_{\\mathrm{OLS}}, \\hat b_{\\mathrm{OLS}})$ 和 $(\\hat a_{\\mathrm{Huber}}, \\hat b_{\\mathrm{Huber}})$。所有测试均使用相同的 Huber 参数 $\\delta$，即 $\\delta = 0.1$。\n\n测试集（每个测试明确指定 $x$、$y$ 和 $N$）：\n\n- 测试 $1$（理想情况，无离群值）：\n  - $x_i = i$，其中 $i \\in \\{-5,-4,\\dots,4,5\\}$，因此 $N=11$。\n  - 对于每个 $i$，$y_i = 2\\,x_i + 1$。\n\n- 测试 $2$（单个高杠杆离群值）：\n  - 从测试 $1$ 开始，并附加一个额外的点 $(x_o, y_o) = (50, -100)$，因此 $N=12$。\n  - 因此，$x$ 是测试 $1$ 中的序列附加一个 $50$，$y$ 是相应的序列附加一个 $-100$。\n\n- 测试 $3$（小样本边界情况）：\n  - $x = [0, 1]$，因此 $N=2$。\n  - $y = [1, 3]$。\n\n您的程序必须为每个测试用例计算 $(\\hat a_{\\mathrm{OLS}}, \\hat b_{\\mathrm{OLS}})$ 和 $(\\hat a_{\\mathrm{Huber}}, \\hat b_{\\mathrm{Huber}})$，并将它们作为实数报告。不涉及物理单位或角度。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个外层列表和三个内层列表，每个内层列表对应一个测试用例，顺序固定为\n$$\n[\\,[\\hat a_{\\mathrm{OLS}}, \\hat b_{\\mathrm{OLS}}, \\hat a_{\\mathrm{Huber}}, \\hat b_{\\mathrm{Huber}}]_{\\text{Test }1},\\; [\\cdot]_{\\text{Test }2},\\; [\\cdot]_{\\text{Test }3}\\,],\n$$\n以方括号括起来的逗号分隔列表形式打印，每个数值条目都四舍五入到小数点后六位。例如，外层列表包含三个内层列表，每个内层列表按指定顺序包含四个实数。",
            "solution": "问题陈述已经过验证，被认为是有效的。它具有科学依据，是良构的、客观的，并包含了推导出唯一解所需的所有必要信息。该任务是计算统计学中的一个标准练习，旨在比较经典的普通最小二乘法 (OLS) 估计量与基于 Huber 损失函数的现代稳健替代方法。\n\n我们需要为线性模型 $y_i = a x_i + b + \\varepsilon_i$ 寻找参数估计 $(\\hat a, \\hat b)$。\n\n**普通最小二乘法 (OLS) 估计量**\n\nOLS 估计量最小化残差平方和，其损失函数定义为 $L_{\\mathrm{OLS}}(a, b) = \\sum_{i=1}^{N} (y_i - a\\,x_i - b)^2$。这是一个关于参数 $(a, b)$ 的二次、凸、光滑的函数。通过将关于 $a$ 和 $b$ 的偏导数设为零，可以找到唯一的最小值。这就得到了正规方程组：\n$$\n\\begin{pmatrix}\n\\sum_{i=1}^{N} x_i^2  \\sum_{i=1}^{N} x_i \\\\\n\\sum_{i=1}^{N} x_i  N\n\\end{pmatrix}\n\\begin{pmatrix}\n\\hat a_{\\mathrm{OLS}} \\\\ \\hat b_{\\mathrm{OLS}}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\sum_{i=1}^{N} x_i y_i \\\\\n\\sum_{i=1}^{N} y_i\n\\end{pmatrix}\n$$\n求解这个 $2 \\times 2$ 线性系统可以得到参数的闭式解析解：\n$$\n\\hat a_{\\mathrm{OLS}} = \\frac{N \\sum x_i y_i - (\\sum x_i)(\\sum y_i)}{N \\sum x_i^2 - (\\sum x_i)^2}\n$$\n$$\n\\hat b_{\\mathrm{OLS}} = \\bar{y} - \\hat a_{\\mathrm{OLS}} \\bar{x}\n$$\n其中 $\\bar{x} = \\frac{1}{N}\\sum x_i$ 且 $\\bar{y} = \\frac{1}{N}\\sum y_i$。这些公式将直接用于计算实现。\n\n**基于 Huber 损失的稳健估计量**\n\n稳健估计量最小化 Huber 损失之和，$L_{\\mathrm{Huber}}(a, b) = \\sum_{i=1}^{N} \\phi_\\delta\\!\\left(y_i - a\\,x_i - b\\right)$，其中 Huber 损失函数 $\\phi_\\delta(r)$ 定义为：\n$$\n\\phi_\\delta(r) = \\begin{cases}\n\\dfrac{1}{2} r^2,  \\text{if } |r| \\le \\delta, \\\\\n\\delta\\left(|r| - \\dfrac{1}{2}\\delta\\right),  \\text{if } |r| > \\delta.\n\\end{cases}\n$$\n对于较小的残差，此损失函数的行为是二次的（类似 OLS）；对于较大的残差，其行为是线性的。这一性质使得估计量对离群值具有稳健性，因为大的误差不会对总损失产生二次方的贡献。函数 $L_{\\mathrm{Huber}}(a, b)$ 是凸的但非连续可微（在 $|y_i - a x_i - b| = \\delta$ 处存在“扭结”）。因此，不存在像 OLS 那样的闭式解。\n\n这是一个凸优化问题，可以使用数值方法求解。我们将利用一个通用的数值优化程序，特别是 `scipy.optimize.minimize`，来找到最小化总 Huber 损失的参数 $(\\hat a_{\\mathrm{Huber}}, \\hat b_{\\mathrm{Huber}})$。OLS 估计值将作为迭代求解器的合适初始猜测。给定的参数 $\\delta$ 为 $0.1$。\n\n**跨测试用例的实现**\n\n对于每个测试用例，我们首先构建数据向量 $x$ 和 $y$。然后，我们使用解析公式计算 OLS 估计值。接着，我们将定义 Huber 损失目标函数，并使用 `scipy.optimize.minimize` 来找到 Huber 估计值。\n\n- **测试 1：** 数据点完全位于直线 $y_i = 2x_i + 1$ 上。对于精确参数 $(a,b) = (2,1)$，所有残差均为零。OLS 和 Huber 损失函数都在这一点上达到了它们的全局最小值零。因此，我们预期 $(\\hat a_{\\mathrm{OLS}}, \\hat b_{\\mathrm{OLS}}) = (\\hat a_{\\mathrm{Huber}}, \\hat b_{\\mathrm{Huber}}) = (2, 1)$。\n\n- **测试 2：** 在测试 1 的数据中加入一个离群值 $(x_o, y_o) = (50, -100)$。这个离群值具有高杠杆（其 $x$ 值远离其他 $x$ 值的均值）和较大的残差。众所周知，OLS 对此类点高度敏感；对大残差的二次惩罚会显著地将回归线“拉向”该离群值，从而使估计值从 $(2, 1)$ 发生剧烈变化。相比之下，Huber 估计量对大残差的线性惩罚会限制离群值的影响。我们预期 $(\\hat a_{\\mathrm{Huber}}, \\hat b_{\\mathrm{Huber}})$ 将保持更接近其他 11 个数据点的真实潜在参数 $(2, 1)$，从而展示稳健回归的原理。\n\n- **测试 3：** 只有两个数据点 $(0, 1)$ 和 $(1, 3)$，存在一条唯一的直线穿过这两点。该直线的方程为 $y = 2x + 1$。对于参数 $(a,b) = (2,1)$，残差为零。与测试 1 一样，OLS 和 Huber 估计量都将识别出这些精确参数，得到 $(\\hat a_{\\mathrm{OLS}}, \\hat b_{\\mathrm{OLS}}) = (\\hat a_{\\mathrm{Huber}}, \\hat b_{\\mathrm{Huber}}) = (2, 1)$。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Implements and compares OLS and Huber estimators for linear regression\n    on three specified test cases.\n    \"\"\"\n\n    # --- Estimator Implementations ---\n\n    def calculate_ols(x: np.ndarray, y: np.ndarray) -> tuple[float, float]:\n        \"\"\"\n        Calculates the Ordinary Least Squares (OLS) estimator for a and b.\n        y = a*x + b\n        \"\"\"\n        N = len(x)\n        if N  2:\n            return (np.nan, np.nan)\n\n        sum_x = np.sum(x)\n        sum_y = np.sum(y)\n        sum_xy = np.sum(x * y)\n        sum_x2 = np.sum(x**2)\n\n        denominator = N * sum_x2 - sum_x**2\n        if np.abs(denominator)  1e-12: # Check for collinearity (all x values are the same)\n            return (np.nan, np.nan)\n\n        a_ols = (N * sum_xy - sum_x * sum_y) / denominator\n        b_ols = (sum_y - a_ols * sum_x) / N\n        \n        return a_ols, b_ols\n\n    def calculate_huber(x: np.ndarray, y: np.ndarray, delta: float) -> tuple[float, float]:\n        \"\"\"\n        Calculates the Huber-loss-based robust estimator for a and b.\n        y = a*x + b\n        \"\"\"\n        \n        def huber_loss_objective(params: np.ndarray, x_data: np.ndarray, y_data: np.ndarray, d: float) -> float:\n            \"\"\"\n            Objective function: sum of Huber losses for a given set of parameters.\n            \"\"\"\n            a, b = params\n            residuals = y_data - (a * x_data + b)\n            abs_residuals = np.abs(residuals)\n            \n            # Quadratic part for small residuals\n            quadratic_loss = 0.5 * residuals[abs_residuals = d]**2\n            \n            # Linear part for large residuals\n            linear_loss = d * (abs_residuals[abs_residuals > d] - 0.5 * d)\n            \n            return np.sum(quadratic_loss) + np.sum(linear_loss)\n\n        # Use OLS estimates as a good initial guess\n        a_ols, b_ols = calculate_ols(x, y)\n        initial_guess = np.array([a_ols, b_ols])\n\n        result = minimize(\n            huber_loss_objective,\n            x0=initial_guess,\n            args=(x, y, delta),\n            method='BFGS' # A standard quasi-Newton method suitable for this problem\n        )\n\n        a_huber, b_huber = result.x\n        return a_huber, b_huber\n\n    # --- Test Cases Definition ---\n    \n    # Test 1: Happy path, no outlier\n    x1 = np.arange(-5, 6, 1, dtype=float)\n    y1 = 2 * x1 + 1\n    \n    # Test 2: Single high-leverage outlier\n    x2 = np.append(x1, 50.0)\n    y2 = np.append(y1, -100.0)\n    \n    # Test 3: Small-sample boundary case\n    x3 = np.array([0.0, 1.0])\n    y3 = np.array([1.0, 3.0])\n    \n    test_cases = [\n        (x1, y1),\n        (x2, y2),\n        (x3, y3)\n    ]\n    \n    delta = 0.1\n    all_results = []\n    \n    for x_data, y_data in test_cases:\n        a_ols, b_ols = calculate_ols(x_data, y_data)\n        a_huber, b_huber = calculate_huber(x_data, y_data, delta)\n        \n        case_results = [a_ols, b_ols, a_huber, b_huber]\n        all_results.append(case_results)\n        \n    # --- Format and Print Output ---\n    \n    outer_list_str = []\n    for inner_list in all_results:\n        inner_list_str = [f\"{val:.6f}\" for val in inner_list]\n        outer_list_str.append(f\"[{','.join(inner_list_str)}]\")\n        \n    final_output = f\"[{','.join(outer_list_str)}]\"\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}