{
    "hands_on_practices": [
        {
            "introduction": "B-splines form a robust and flexible foundation for many powerful approximation schemes used in computational engineering. To truly master them, it is essential to look beyond their application and understand how they are constructed from first principles. This exercise guides you through the celebrated Cox–de Boor recursion formula to manually build a single quadratic B-spline basis function, providing direct insight into how its local support, shape, and continuity are dictated by the placement and multiplicity of knots in its defining vector .",
            "id": "2424168",
            "problem": "In computational engineering, basis splines (B-splines) provide robust piecewise polynomial approximations with compact support and controllable continuity. Consider the open, non-uniform knot vector $t = \\{0, 0, 0, 1, 3, 3, 4, 4, 4\\}$ and quadratic degree $p = 2$. Starting from the fundamental definition of zero-degree B-spline basis functions and the Cox–de Boor recursion, manually derive the explicit piecewise polynomial expression for the quadratic B-spline basis function $N_{3,2}(x)$ associated with this knot vector. Use the standard convention that if a denominator in the recursion is zero, then the corresponding term is taken to be zero, and take characteristic intervals as half-open of the form $[a,b)$. Express your final result as a single piecewise-defined analytic expression in $x$. No numerical rounding is required, and no units are involved. The final answer must be the closed-form expression only.",
            "solution": "The posed problem is subject to rigorous validation before any attempt at a solution is made.\n\n### Step 1: Extract Givens\n-   **Field**: Computational Engineering\n-   **Topic**: Piecewise polynomial approximations, B-splines\n-   **Knot Vector**: $t = \\{0, 0, 0, 1, 3, 3, 4, 4, 4\\}$\n-   **Degree**: $p = 2$ (quadratic)\n-   **Target Basis Function**: $N_{3,2}(x)$\n-   **Method**: Cox–de Boor recursion, starting from zero-degree basis functions.\n-   **Convention 1**: If a denominator in the recursion formula is zero, the corresponding term is zero.\n-   **Convention 2**: Characteristic intervals are half-open, $[a,b)$.\n\n### Step 2: Validate Using Extracted Givens\n1.  **Scientifically Grounded**: The problem is a standard, fundamental exercise in the theory of B-splines, a core topic in numerical analysis and computer-aided geometric design. All concepts, including the knot vector, degree, and the Cox-de Boor recursion, are well-established. The problem is scientifically sound.\n2.  **Well-Posed**: The problem is specified with precision. The knot vector, polynomial degree, and the target basis function are explicitly given. The conventions for handling zero denominators and interval forms remove any potential ambiguity in the calculation. A unique, stable, and meaningful piecewise polynomial solution exists and can be derived.\n3.  **Objective**: The language is clear, precise, and entirely objective. It presents a mathematical task without subjective or speculative content.\n\n### Step 3: Verdict and Action\nThe problem is determined to be **valid**. It is self-contained, scientifically grounded, and well-posed. A solution will be derived.\n\n### Derivation\nThe derivation of the B-spline basis function $N_{i,p}(x)$ is governed by the Cox-de Boor recursion formula. We begin with the definition of the zero-degree basis functions, $N_{i,0}(x)$:\n$$\nN_{i,0}(x) =\n\\begin{cases}\n1 & \\text{if } t_i \\le x < t_{i+1} \\\\\n0 & \\text{otherwise}\n\\end{cases}\n$$\nFor a degree $p > 0$, the higher-degree basis functions are defined recursively:\n$$\nN_{i,p}(x) = \\frac{x - t_i}{t_{i+p} - t_i} N_{i, p-1}(x) + \\frac{t_{i+p+1} - x}{t_{i+p+1} - t_{i+1}} N_{i+1, p-1}(x)\n$$\nThe provided convention states that any term with a zero denominator is taken to be zero.\n\nThe problem specifies the knot vector $t = \\{t_0, t_1, \\dots, t_8\\}$ as:\n$$\nt = \\{0, 0, 0, 1, 3, 3, 4, 4, 4\\}\n$$\nThe degree is $p=2$. We are required to find the expression for the basis function $N_{3,2}(x)$.\n\nFirst, we determine the support of $N_{3,2}(x)$. The support of a B-spline basis function $N_{i,p}(x)$ is the interval $[t_i, t_{i+p+1})$. For $N_{3,2}(x)$, this corresponds to the interval $[t_3, t_{3+2+1}) = [t_3, t_6)$. From the knot vector, $t_3=1$ and $t_6=4$. Therefore, $N_{3,2}(x)$ is non-zero only for $x \\in [1, 4)$.\n\nWe apply the recursion formula to find $N_{3,2}(x)$:\n$$\nN_{3,2}(x) = \\frac{x - t_3}{t_{3+2} - t_3} N_{3,1}(x) + \\frac{t_{3+2+1} - x}{t_{3+2+1} - t_{3+1}} N_{4,1}(x) = \\frac{x - t_3}{t_5 - t_3} N_{3,1}(x) + \\frac{t_6 - x}{t_6 - t_4} N_{4,1}(x)\n$$\nSubstituting the knot values $t_3=1$, $t_4=3$, $t_5=3$, and $t_6=4$:\n$$\nN_{3,2}(x) = \\frac{x - 1}{3 - 1} N_{3,1}(x) + \\frac{4 - x}{4 - 3} N_{4,1}(x) = \\frac{x - 1}{2} N_{3,1}(x) + (4 - x) N_{4,1}(x)\n$$\nNext, we must find the expressions for the linear basis functions $N_{3,1}(x)$ and $N_{4,1}(x)$.\n\nFor $N_{3,1}(x)$, the recursion is:\n$$\nN_{3,1}(x) = \\frac{x - t_3}{t_{3+1} - t_3} N_{3,0}(x) + \\frac{t_{3+1+1} - x}{t_{3+1+1} - t_{3+1}} N_{4,0}(x) = \\frac{x - t_3}{t_4 - t_3} N_{3,0}(x) + \\frac{t_5 - x}{t_5 - t_4} N_{4,0}(x)\n$$\nSubstituting knot values $t_3=1$, $t_4=3$, $t_5=3$:\n$$\nN_{3,1}(x) = \\frac{x - 1}{3 - 1} N_{3,0}(x) + \\frac{3 - x}{3 - 3} N_{4,0}(x)\n$$\nThe denominator $t_5 - t_4$ is zero, so the second term is zero.\n$$\nN_{3,1}(x) = \\frac{x - 1}{2} N_{3,0}(x)\n$$\nThe support of $N_{3,0}(x)$ is $[t_3, t_4) = [1, 3)$, where it is equal to $1$. Thus, $N_{3,1}(x)$ is:\n$$\nN_{3,1}(x) = \\begin{cases} \\frac{x-1}{2} & 1 \\le x < 3 \\\\ 0 & \\text{otherwise} \\end{cases}\n$$\nFor $N_{4,1}(x)$, the recursion is:\n$$\nN_{4,1}(x) = \\frac{x - t_4}{t_{4+1} - t_4} N_{4,0}(x) + \\frac{t_{4+1+1} - x}{t_{4+1+1} - t_{4+1}} N_{5,0}(x) = \\frac{x - t_4}{t_5 - t_4} N_{4,0}(x) + \\frac{t_6 - x}{t_6 - t_5} N_{5,0}(x)\n$$\nSubstituting knot values $t_4=3$, $t_5=3$, $t_6=4$:\n$$\nN_{4,1}(x) = \\frac{x - 3}{3 - 3} N_{4,0}(x) + \\frac{4 - x}{4 - 3} N_{5,0}(x)\n$$\nThe denominator $t_5 - t_4$ is zero, so the first term is zero.\n$$\nN_{4,1}(x) = \\frac{4 - x}{1} N_{5,0}(x) = (4 - x) N_{5,0}(x)\n$$\nThe support of $N_{5,0}(x)$ is $[t_5, t_6) = [3, 4)$, where it is equal to $1$. Thus, $N_{4,1}(x)$ is:\n$$\nN_{4,1}(x) = \\begin{cases} 4 - x & 3 \\le x < 4 \\\\ 0 & \\text{otherwise} \\end{cases}\n$$\nNow, we substitute these piecewise expressions for $N_{3,1}(x)$ and $N_{4,1}(x)$ into the equation for $N_{3,2}(x)$. We consider the intervals over its support $[1, 4)$.\n\nCase 1: $x \\in [1, 3)$\nIn this interval, $N_{3,1}(x) = \\frac{x-1}{2}$ and $N_{4,1}(x) = 0$.\n$$\nN_{3,2}(x) = \\frac{x - 1}{2} \\left( \\frac{x-1}{2} \\right) + (4 - x)(0) = \\frac{(x-1)^2}{4}\n$$\n\nCase 2: $x \\in [3, 4)$\nIn this interval, $N_{3,1}(x) = 0$ and $N_{4,1}(x) = 4-x$.\n$$\nN_{3,2}(x) = \\frac{x-1}{2}(0) + (4 - x)(4 - x) = (4-x)^2\n$$\n\nCombining these results, we obtain the complete piecewise-defined expression for $N_{3,2}(x)$:\n$$\nN_{3,2}(x) =\n\\begin{cases}\n\\frac{(x-1)^2}{4} & \\text{if } 1 \\leq x < 3 \\\\\n(4-x)^2 & \\text{if } 3 \\leq x < 4 \\\\\n0 & \\text{otherwise}\n\\end{cases}\n$$\nThis function has support $[1,4)$. At the knot $x=3$, which has multiplicity $k=2$, the continuity is $C^{p-k} = C^{2-2} = C^0$. We verify this:\n$\\lim_{x \\to 3^-} N_{3,2}(x) = \\frac{(3-1)^2}{4} = 1$.\n$N_{3,2}(3) = (4-3)^2 = 1$.\nThe function is continuous, as required.",
            "answer": "$$\n\\boxed{\nN_{3,2}(x) = \n\\begin{cases}\n\\frac{(x-1)^{2}}{4} & 1 \\le x < 3 \\\\\n(4-x)^{2} & 3 \\le x < 4 \\\\\n0 & \\text{otherwise}\n\\end{cases}\n}\n$$"
        },
        {
            "introduction": "In many scientific and engineering scenarios, we work with discrete data from experiments or simulations, yet we need to analyze the underlying continuous behavior. Piecewise polynomial interpolants serve as a powerful tool to create a high-fidelity, continuous surrogate model from such discrete datasets. This coding exercise challenges you to implement a common computational workflow: construct a shape-preserving piecewise cubic Hermite interpolant (PCHIP) from a set of points and then use this continuous representation to find its roots—a frequent task in optimization and systems analysis .",
            "id": "2424134",
            "problem": "You are given datasets consisting of strictly increasing abscissae $x_0 < x_1 < \\dots < x_{n-1}$ and corresponding ordinates $y_0, y_1, \\dots, y_{n-1}$. The scalar function $f(x)$ is not directly available; instead, it is defined to be the unique shape-preserving piecewise cubic interpolant constructed from the dataset using piecewise cubic Hermite interpolation. Your task is to write a program that finds all real roots of $f(x)=0$ within the closed domain $\\left[x_0, x_{n-1}\\right]$ for each dataset in the test suite.\n\nFoundational base and modeling assumptions:\n- The interpolant is defined on each subinterval $\\left[x_k,x_{k+1}\\right]$ by a cubic Hermite polynomial that satisfies function value and slope matching at the subinterval endpoints. Let $h_k = x_{k+1}-x_k$ and $t=(x-x_k)/h_k\\in[0,1]$. On $\\left[x_k,x_{k+1}\\right]$, the interpolant $p_k(x)$ is defined by\n$$\np_k(x) = y_k h_{00}(t) + h_k m_k h_{10}(t) + y_{k+1} h_{01}(t) + h_k m_{k+1} h_{11}(t),\n$$\nwhere the cubic Hermite basis polynomials are\n$$\nh_{00}(t) = 2t^3 - 3t^2 + 1,\\quad\nh_{10}(t) = t^3 - 2t^2 + t,\\quad\nh_{01}(t) = -2t^3 + 3t^2,\\quad\nh_{11}(t) = t^3 - t^2.\n$$\n- The slopes $m_k$ are chosen by a monotonicity-preserving rule (Fritsch–Carlson method) applied to the secant slopes $\\delta_k = \\dfrac{y_{k+1}-y_k}{x_{k+1}-x_k}$, ensuring that if $y_k$ is monotone in $x$, then the interpolant does not introduce spurious oscillations or overshoot. In particular, if $\\delta_{k-1}$ and $\\delta_k$ have opposite signs or either is zero, then $m_k=0$; otherwise, $m_k$ is a weighted harmonic mean of $\\delta_{k-1}$ and $\\delta_k$ that preserves the local shape. Endpoint slopes $m_0$ and $m_{n-1}$ are chosen consistently to avoid overshoot.\n- A root is any $x^\\star \\in [x_0,x_{n-1}]$ such that $f(x^\\star)=0$. Roots may occur strictly inside subintervals (solutions of the cubic $p_k(x)=0$) or exactly at knots $x_k$ for which $y_k=0$.\n\nAlgorithmic requirements:\n- For each dataset, construct the piecewise cubic Hermite interpolant $f(x)$ as described. Then, for each subinterval, solve the cubic equation $p_k(x)=0$ for real roots $x \\in [x_k, x_{k+1}]$. Also include any knots $x_k$ with $y_k=0$ as roots. Discard any roots outside $\\left[x_0,x_{n-1}\\right]$ due to numerical roundoff. Remove duplicates closer than a small tolerance.\n- Sort the roots in ascending order. Round each root to $6$ decimal places.\n\nAngle unit: Whenever trigonometric functions appear in the datasets, interpret angles in radians.\n\nOutput format:\n- Your program should produce a single line of output containing the results as a single list of lists, one per dataset, where each inner list contains the rounded roots in ascending order. Use a comma-separated representation enclosed in square brackets, with no whitespace characters. For example: \"[[r11,r12],[r21],[...]]\". Use standard decimal floating-point notation for the roots with exactly $6$ digits after the decimal point. An empty list should be represented as \"[]\".\n\nTest suite:\nFor robust evaluation, run your program on the following four datasets. For each, $x$ is strictly increasing.\n\n- Test case $1$ (one interior root, not at a knot):\n  - $x = [0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5]$\n  - $y = [\\sin(0.5), \\sin(1.0), \\sin(1.5), \\sin(2.0), \\sin(2.5), \\sin(3.0), \\sin(3.5)]$ where angles are in radians.\n\n- Test case $2$ (no roots in the domain):\n  - $x = [-2.0, -1.0, 0.0, 1.0, 2.0]$\n  - $y = [(-2.0)^2 + 1.0, (-1.0)^2 + 1.0, 0.0^2 + 1.0, 1.0^2 + 1.0, 2.0^2 + 1.0]$.\n\n- Test case $3$ (multiple roots exactly at knots):\n  - $x = [0, \\tfrac{\\pi}{4}, \\tfrac{\\pi}{2}, \\tfrac{3\\pi}{4}, \\pi, \\tfrac{5\\pi}{4}, \\tfrac{3\\pi}{2}, \\tfrac{7\\pi}{4}, 2\\pi]$\n  - $y = [\\sin(0), \\sin(\\tfrac{\\pi}{4}), \\sin(\\tfrac{\\pi}{2}), \\sin(\\tfrac{3\\pi}{4}), \\sin(\\pi), \\sin(\\tfrac{5\\pi}{4}), \\sin(\\tfrac{3\\pi}{2}), \\sin(\\tfrac{7\\pi}{4}), \\sin(2\\pi)]$ with angles in radians.\n\n- Test case $4$ (root at the right boundary):\n  - $x = [0.0, 0.5, 1.0, 1.5, 2.0]$\n  - $y = [0.0-2.0, 0.5-2.0, 1.0-2.0, 1.5-2.0, 2.0-2.0]$.\n\nNumerical and validation details:\n- Use a small absolute tolerance (e.g., $10^{-12}$) to decide whether a value is zero when detecting roots at knots and for de-duplication of roots from adjacent subintervals.\n- Only real roots within the closed domain must be reported.\n- Round each root to exactly $6$ decimal places, and ensure the inner lists are in strictly ascending order after rounding.\n\nYour program must implement the above and produce a single line containing the aggregated results for the four test cases in the specified format, with no extra printing or whitespace anywhere in the output line.",
            "solution": "The problem as stated is valid. It presents a well-defined task in computational engineering, specifically in the field of numerical analysis and approximation theory. The problem is scientifically grounded in the theory of piecewise polynomial interpolation, is objective, and provides all necessary information to construct a unique, verifiable solution. There are no contradictions, ambiguities, or reliance on non-scientific premises.\n\nThe objective is to find all real roots of a function $f(x)$ defined on a closed interval $[x_0, x_{n-1}]$, where $f(x)$ is a shape-preserving piecewise cubic Hermite interpolant constructed from a given set of data points $(x_k, y_k)$ for $k=0, 1, \\dots, n-1$.\n\nA piecewise cubic Hermite interpolant is a spline constructed by joining cubic polynomials, one for each subinterval $[x_k, x_{k+1}]$. For the interpolant to be smooth, the function values and first derivatives must agree at the knots $x_k$. Let $p_k(x)$ be the cubic polynomial on the interval $[x_k, x_{k+1}]$. It is defined by four pieces of information: the function values $y_k = f(x_k)$ and $y_{k+1} = f(x_{k+1})$, and the derivative values $m_k = f'(x_k)$ and $m_{k+1} = f'(x_{k+1})$.\n\nThe interpolant $p_k(x)$ on $[x_k, x_{k+1}]$ can be expressed using the Hermite basis polynomials. Let $h_k = x_{k+1} - x_k$ and define a normalized variable $t = (x - x_k) / h_k$, so that $t \\in [0, 1]$ as $x$ ranges from $x_k$ to $x_{k+1}$. The interpolant is given by:\n$$\np_k(x(t)) = y_k h_{00}(t) + y_{k+1} h_{01}(t) + h_k m_k h_{10}(t) + h_k m_{k+1} h_{11}(t)\n$$\nwhere the Hermite basis functions are:\n$$\n\\begin{aligned}\nh_{00}(t) &= 2t^3 - 3t^2 + 1 \\\\\nh_{01}(t) &= -2t^3 + 3t^2 \\\\\nh_{10}(t) &= t^3 - 2t^2 + t \\\\\nh_{11}(t) &= t^3 - t^2\n\\end{aligned}\n$$\nThese basis functions have the properties $h_{00}(0)=1$, $h_{01}(1)=1$, $h'_{10}(0)=1$, $h'_{11}(1)=1$, with other values and derivatives at $0$ and $1$ being zero, which ensures the interpolation conditions are met.\n\nThe critical component is the selection of the derivative values, $m_k$. A standard cubic spline enforces continuity of the second derivative, but this can introduce spurious oscillations not present in the original data. The problem specifies a \"shape-preserving\" or \"monotonicity-preserving\" method, specifically the Fritsch–Carlson method. This method determines the slopes $m_k$ based on the local geometry of the data, as defined by the secant slopes $\\delta_k = (y_{k+1} - y_k) / (x_{k+1} - x_k)$.\nFor an interior knot $x_k$ ($k=1, \\dots, n-2$), the principle is as follows:\n1. If the adjacent secant slopes have different signs, i.e., $\\delta_{k-1} \\delta_k \\le 0$, the data is not monotonic around $x_k$. To prevent overshoot, the derivative at this non-monotonicity is set to zero: $m_k = 0$.\n2. If the secant slopes have the same sign, $\\delta_{k-1} \\delta_k > 0$, the data is locally monotonic. The derivative $m_k$ is chosen to maintain this monotonicity. A common choice, as implemented in standard libraries, is a weighted harmonic mean of $\\delta_{k-1}$ and $\\delta_k$ to ensure that $|m_k|$ is bounded appropriately.\nThe endpoint slopes, $m_0$ and $m_{n-1}$, are determined using a one-sided scheme consistent with these principles to avoid overshoot near the boundaries.\n\nOnce the slopes $m_k$ are determined for all $k$, the piecewise polynomial $f(x)$ is fully defined. The task reduces to finding the roots of $f(x)=0$ on $[x_0, x_{n-1}]$. This involves two distinct cases:\n1. Roots at knots: A root exists at a knot $x_k$ if its corresponding ordinate $y_k = 0$.\n2. Roots within subintervals: A root exists in an open interval $(x_k, x_{k+1})$ if the cubic polynomial $p_k(x)$ has a zero in that interval.\n\nTo find roots within an interval, we must solve $p_k(x) = 0$. By substituting the Hermite basis functions and collecting terms in powers of $t$, the equation becomes a standard cubic equation $at^3 + bt^2 + ct + d = 0$, where the coefficients are:\n$$\n\\begin{aligned}\na &= 2(y_k - y_{k+1}) + h_k(m_k + m_{k+1}) \\\\\nb &= 3(y_{k+1} - y_k) - h_k(2m_k + m_{k+1}) \\\\\nc &= h_k m_k \\\\\nd &= y_k\n\\end{aligned}\n$$\nThis cubic equation can be solved for its real roots $t^\\star$. Any root $t^\\star$ that lies in the range $[0, 1]$ corresponds to a valid root $x^\\star = x_k + t^\\star h_k$ of the interpolant.\n\nThe computational strategy proceeds as follows:\n1.  For each dataset, the `scipy.interpolate.PchipInterpolator` class is used. This provides a robust and numerically stable implementation of the Fritsch-Carlson method for constructing the shape-preserving piecewise cubic interpolant.\n2.  The root-finding process is decomposed into two parts to ensure completeness:\n    a. Roots at knots are identified by checking where the input ordinate values $y_k$ are close to zero, within a small tolerance $\\epsilon = 10^{-12}$.\n    b. Roots within the open intervals $(x_k, x_{k+1})$ are found using the `.roots()` method of the interpolator object. This method efficiently and accurately finds all real roots of the piecewise polynomial within its domain of definition, but it does not report roots at the global boundaries $x_0$ and $x_{n-1}$.\n3.  The roots from both sources are collected into a single set.\n4.  This set is sorted in ascending order. Duplicates, which may arise if a root at a knot is found by both methods, are removed by iterating through the sorted list and retaining only those roots separated by more than the tolerance $\\epsilon$.\n5.  Finally, the unique, sorted roots are rounded to $6$ decimal places and formatted as required. This methodology guarantees that all real roots in the closed domain $[x_0, x_{n-1}]$ are found and reported correctly.",
            "answer": "```python\nimport numpy as np\nfrom scipy.interpolate import PchipInterpolator\n\ndef solve():\n    \"\"\"\n    Solves for the real roots of shape-preserving piecewise cubic Hermite interpolants\n    for a suite of test cases.\n    \"\"\"\n    # Tolerance for floating-point comparisons (zero-checking and de-duplication).\n    TOL = 1e-12\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1: one interior root, not at a knot\n        {\n            \"x\": np.array([0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5]),\n            \"y\": np.sin(np.array([0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5]))\n        },\n        # Test case 2: no roots in the domain\n        {\n            \"x\": np.array([-2.0, -1.0, 0.0, 1.0, 2.0]),\n            \"y\": np.array([-2.0, -1.0, 0.0, 1.0, 2.0])**2 + 1.0\n        },\n        # Test case 3: multiple roots exactly at knots\n        {\n            \"x\": np.array([0, np.pi/4, np.pi/2, 3*np.pi/4, np.pi, 5*np.pi/4, 3*np.pi/2, 7*np.pi/4, 2*np.pi]),\n            \"y\": np.sin(np.array([0, np.pi/4, np.pi/2, 3*np.pi/4, np.pi, 5*np.pi/4, 3*np.pi/2, 7*np.pi/4, 2*np.pi]))\n        },\n        # Test case 4: root at the right boundary\n        {\n            \"x\": np.array([0.0, 0.5, 1.0, 1.5, 2.0]),\n            \"y\": np.array([0.0, 0.5, 1.0, 1.5, 2.0]) - 2.0\n        }\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        x_data, y_data = case[\"x\"], case[\"y\"]\n\n        # 1. Construct the shape-preserving piecewise cubic Hermite interpolant.\n        #    PchipInterpolator implements the Fritsch–Carlson method.\n        interpolator = PchipInterpolator(x_data, y_data)\n\n        # 2. Find roots. This requires a two-pronged approach.\n        \n        # 2a. Find roots within open subintervals using the PPoly.roots() method.\n        # This method correctly finds roots within (x_k, x_{k+1}) for all k,\n        # but does not report roots at the global boundaries x_0 and x_{n-1}.\n        interior_roots = interpolator.roots(extrapolate=False)\n\n        # 2b. Find roots that occur exactly at the knots.\n        knot_roots = x_data[np.abs(y_data) < TOL]\n        \n        # 3. Combine, sort, and de-duplicate the roots.\n        if interior_roots.size == 0 and knot_roots.size == 0:\n            unique_sorted_roots = []\n        else:\n            all_found_roots = np.concatenate((interior_roots, knot_roots))\n            # Sort all roots to prepare for de-duplication.\n            all_found_roots.sort()\n\n            # De-duplicate roots that are closer than the tolerance.\n            if len(all_found_roots) > 0:\n                unique_sorted_roots = [all_found_roots[0]]\n                for root in all_found_roots[1:]:\n                    if root - unique_sorted_roots[-1] > TOL:\n                        unique_sorted_roots.append(root)\n            else:\n                unique_sorted_roots = []\n\n        # 4. Format the output: round to 6 decimal places.\n        # The f-string format ensures exactly 6 digits are printed, even for whole numbers.\n        formatted_roots = [f\"{root:.6f}\" for root in unique_sorted_roots]\n        all_results.append(f\"[{','.join(formatted_roots)}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The utility of piecewise polynomials extends far beyond approximating scalar functions of the form $y=f(x)$ and into the realm of geometric design and computer graphics. By defining splines parametrically with vector-valued coefficients, we can construct and represent complex curves and surfaces. This practice provides a hands-on introduction to this concept by tasking you with approximating a perfect circle using a $C^1$ continuous, piecewise cubic parametric curve and then analyzing the resulting geometric (radial) error . This exercise demonstrates the power of Hermite interpolation for geometric modeling and introduces methods for quantifying approximation accuracy for shapes.",
            "id": "2424157",
            "problem": "Given a perfect circle of radius $R > 0$ centered at the origin in the plane, consider the parametric representation $\\mathbf{C}(\\theta) = \\big(R\\cos\\theta,\\; R\\sin\\theta\\big)$ for $\\theta \\in [0, 2\\pi]$ with $\\theta$ measured in radians. Let $N \\in \\mathbb{N}$ be the number of equal angular segments, and define the uniform partition $\\theta_k = k h$ for $k = 0,1,\\dots,N$, where $h = \\dfrac{2\\pi}{N}$. For each subinterval $[\\theta_k,\\theta_{k+1}]$, consider the map $t \\mapsto \\theta_k + h t$ with $t \\in [0,1]$. Define the piecewise cubic polynomial approximation $\\mathbf{S}_{N,R}$ as follows: on each segment $k$, let $\\mathbf{P}_k:[0,1]\\to\\mathbb{R}^2$ be the unique vector-valued cubic polynomial in $t$ that satisfies\n$$\n\\mathbf{P}_k(0) = \\mathbf{C}(\\theta_k),\\quad\n\\mathbf{P}_k(1) = \\mathbf{C}(\\theta_{k+1}),\\quad\n\\mathbf{P}_k'(0) = h\\,\\mathbf{C}'(\\theta_k),\\quad\n\\mathbf{P}_k'(1) = h\\,\\mathbf{C}'(\\theta_{k+1}),\n$$\nwhere $\\mathbf{C}'(\\theta) = \\dfrac{d\\mathbf{C}}{d\\theta}(\\theta) = \\big(-R\\sin\\theta,\\; R\\cos\\theta\\big)$. This defines a continuous, piecewise-cubic, $C^1$ parametric curve $\\mathbf{S}_{N,R}$ that approximates the circle.\n\nDefine the radial error on segment $k$ at parameter $t$ by\n$$\ne_k(t) = \\left\\|\\mathbf{P}_k(t)\\right\\| - R,\n$$\nand the maximum absolute radial error of the full piecewise polynomial approximation by\n$$\nE(N,R) = \\max_{0 \\le k \\le N-1}\\;\\max_{t \\in [0,1]} \\left|e_k(t)\\right|.\n$$\n\nTask: For each specified pair $(N,R)$ listed in the test suite below, compute $E(N,R)$ and report the results. All angles must be treated in radians. There are no physical units other than the implied unit length for $R$, and the requested outputs are dimensionless. Each reported value must be a floating-point number rounded to $12$ decimal places.\n\nTest suite (each item is $(N,R)$):\n- $(1,\\,1)$\n- $(2,\\,1)$\n- $(3,\\,1)$\n- $(4,\\,1)$\n- $(8,\\,1)$\n- $(16,\\,1)$\n- $(12,\\,2)$\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the same order as the test suite, for example, $\\big[\\text{result}_1,\\text{result}_2,\\dots\\big]$. Each value must be rounded to $12$ decimal places before printing.",
            "solution": "The posed problem has been subjected to rigorous validation and is found to be scientifically sound, well-posed, and objective. It constitutes a standard exercise in computational geometry and numerical approximation theory. We proceed with the solution.\n\nThe objective is to compute the maximum absolute radial error, $E(N,R)$, of a piecewise cubic Hermite approximation, $\\mathbf{S}_{N,R}$, to a circle of radius $R$. The approximation is constructed over $N$ uniform angular segments.\n\nFirst, we exploit the rotational symmetry of the problem. The circle is invariant under rotation, and the approximation is constructed using a uniform partition $\\theta_k = k h$ with step $h = 2\\pi/N$. The Hermite interpolation conditions for a segment starting at $\\theta_k$ are a rotated version of the conditions for the first segment, from $\\theta_0=0$ to $\\theta_1=h$. Consequently, the parametric curve on segment $k$, $\\mathbf{P}_k(t)$, is a simple rotation of the curve on the first segment, $\\mathbf{P}_0(t)$: $\\mathbf{P}_k(t) = \\mathcal{R}(\\theta_k)\\mathbf{P}_0(t)$, where $\\mathcal{R}(\\theta_k)$ is the rotation matrix for angle $\\theta_k$. Since the vector norm is invariant under rotation, $\\|\\mathbf{P}_k(t)\\| = \\|\\mathcal{R}(\\theta_k)\\mathbf{P}_0(t)\\| = \\|\\mathbf{P}_0(t)\\|$, the radial error $e_k(t) = \\|\\mathbf{P}_k(t)\\| - R$ is independent of the segment index $k$.\nThis simplifies the problem significantly, as we only need to analyze the error on the first segment:\n$$\nE(N,R) = \\max_{t \\in [0,1]} |e_0(t)| = \\max_{t \\in [0,1]} \\left| \\big\\|\\mathbf{P}_0(t)\\big\\| - R \\right|.\n$$\n\nThe unique cubic polynomial $\\mathbf{P}_0(t)$ on $t \\in [0,1]$ is determined by the four vector-valued Hermite conditions:\n\\begin{align*}\n\\mathbf{p}_0 &= \\mathbf{P}_0(0) = \\mathbf{C}(0) = (R, 0) \\\\\n\\mathbf{p}_1 &= \\mathbf{P}_0(1) = \\mathbf{C}(h) = (R\\cos h, R\\sin h) \\\\\n\\mathbf{v}_0 &= \\mathbf{P}_0'(0) = h\\mathbf{C}'(0) = (0, Rh) \\\\\n\\mathbf{v}_1 &= \\mathbf{P}_0'(1) = h\\mathbf{C}'(h) = (-Rh\\sin h, Rh\\cos h)\n\\end{align*}\nWriting $\\mathbf{P}_0(t) = \\mathbf{a}t^3 + \\mathbf{b}t^2 + \\mathbf{c}t + \\mathbf{d}$, the vector coefficients are found by solving the system of equations imposed by the Hermite conditions:\n$$\n\\mathbf{a} = 2\\mathbf{p}_0 - 2\\mathbf{p}_1 + \\mathbf{v}_0 + \\mathbf{v}_1 \\\\\n\\mathbf{b} = -3\\mathbf{p}_0 + 3\\mathbf{p}_1 - 2\\mathbf{v}_0 - \\mathbf{v}_1 \\\\\n\\mathbf{c} = \\mathbf{v}_0 \\\\\n\\mathbf{d} = \\mathbf{p}_0\n$$\nTo find the maximum of $|e_0(t)|$, we must find the critical points of $e_0(t)$ on the interval $[0,1]$. The error is zero at the endpoints, $e_0(0)=e_0(1)=0$, as the polynomial interpolates the circle at these points. Any extrema in the interior $(0,1)$ must be at points where the derivative is zero. The extrema of $e_0(t) = \\sqrt{\\|\\mathbf{P}_0(t)\\|^2} - R$ correspond to the extrema of the squared-norm function $f(t) = \\|\\mathbf{P}_0(t)\\|^2$.\nThe critical points are the solutions to $f'(t)=0$. Using the product rule for dot products:\n$$\nf'(t) = \\frac{d}{dt}\\left( \\mathbf{P}_0(t) \\cdot \\mathbf{P}_0(t) \\right) = 2 \\mathbf{P}_0(t) \\cdot \\mathbf{P}_0'(t).\n$$\nSince $\\mathbf{P}_0(t)$ is a cubic polynomial and its derivative $\\mathbf{P}_0'(t)$ is a quadratic, their dot product $\\mathbf{P}_0(t) \\cdot \\mathbf{P}_0'(t)$ is a quintic polynomial in $t$. The critical points of the error function are therefore the roots of this quintic polynomial.\n\nAn analytic solution for the roots of a general quintic polynomial does not exist. A numerical approach is necessary. The computational strategy is as follows:\n1. For each pair $(N,R)$, calculate $h = 2\\pi/N$.\n2. Determine the vectors $\\mathbf{p}_0, \\mathbf{p}_1, \\mathbf{v}_0, \\mathbf{v}_1$.\n3. Compute the coefficients $\\mathbf{a}, \\mathbf{b}, \\mathbf{c}, \\mathbf{d}$ of the cubic polynomial $\\mathbf{P}_0(t)$.\n4. Construct the quintic polynomial $g(t) = \\mathbf{P}_0(t) \\cdot \\mathbf{P}_0'(t)$.\n5. Numerically find all roots of $g(t)$.\n6. The candidates for the location of maximum error are the set of real roots of $g(t)$ that lie within $(0,1)$, along with the boundary points $t=0$ and $t=1$.\n7. Evaluate the absolute radial error $|e_0(t)|$ at each candidate point. The largest of these values is the required maximum error $E(N,R)$.\n\nFinally, we observe that the Hermite data points $\\mathbf{p}_0, \\mathbf{p}_1$ and tangent vectors $\\mathbf{v}_0, \\mathbf{v}_1$ all scale linearly with the radius $R$. This implies that the polynomial $\\mathbf{P}_0(t)$, its norm $\\|\\mathbf{P}_0(t)\\|$, and the error $e_0(t)$ also scale linearly with $R$. Thus, $E(N,R) = R \\cdot E(N,1)$. This property serves as a useful check on the results.",
            "answer": "```python\nimport numpy as np\nfrom numpy.polynomial import Polynomial\n\ndef solve():\n    \"\"\"\n    Solves the piecewise cubic approximation problem for a suite of test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1, 1),\n        (2, 1),\n        (3, 1),\n        (4, 1),\n        (8, 1),\n        (16, 1),\n        (12, 2)\n    ]\n\n    results = []\n    for N, R in test_cases:\n        result = compute_max_radial_error(N, R)\n        results.append(result)\n\n    # Final print statement in the exact required format, ensuring 12 decimal places.\n    print(f\"[{','.join([f'{res:.12f}' for res in results])}]\")\n\ndef compute_max_radial_error(N, R):\n    \"\"\"\n    Computes the maximum absolute radial error E(N,R) for a given N and R.\n\n    The method involves the following steps:\n    1. Define the Hermite interpolation conditions for the first segment of the circle approximation.\n    2. Construct the vector-valued cubic polynomial P_0(t) for this segment.\n    3. The radial error extremum occurs where the velocity vector P_0'(t) is orthogonal \n       to the position vector P_0(t), i.e., P_0(t) . P_0'(t) = 0.\n    4. This dot product is a quintic polynomial in t. Its roots are found numerically.\n    5. The maximum error is found by checking the error at these roots (if in [0,1])\n       and at the endpoints t=0 and t=1.\n    \"\"\"\n    # Angular width of one segment\n    h = 2.0 * np.pi / N\n\n    # Endpoint positions (p0, p1) and scaled tangent vectors (v0, v1)\n    p0 = np.array([R, 0.0], dtype=np.float64)\n    p1 = np.array([R * np.cos(h), R * np.sin(h)], dtype=np.float64)\n    v0 = np.array([0.0, R * h], dtype=np.float64)\n    v1 = np.array([-R * h * np.sin(h), R * h * np.cos(h)], dtype=np.float64)\n\n    # Coefficients a, b, c, d for the cubic P_0(t) = at^3 + bt^2 + ct + d\n    a = 2.0 * p0 - 2.0 * p1 + v0 + v1\n    b = -3.0 * p0 + 3.0 * p1 - 2.0 * v0 - v1\n    c = v0\n    d = p0\n\n    # Represent the components of P_0(t) as polynomial objects\n    Px = Polynomial([d[0], c[0], b[0], a[0]])\n    Py = Polynomial([d[1], c[1], b[1], a[1]])\n\n    # Get the derivatives P_x'(t) and P_y'(t)\n    Px_prime = Px.deriv()\n    Py_prime = Py.deriv()\n\n    # The dot product P_0(t) . P_0'(t) is a quintic polynomial.\n    quintic_poly = Px * Px_prime + Py * Py_prime\n\n    # Find the roots of the quintic polynomial\n    roots = quintic_poly.roots()\n\n    # Candidate values of t for the maximum error are the real roots in [0,1] and boundaries.\n    candidates = {0.0, 1.0}\n    for root in roots:\n        # Check if the root is real (imaginary part is close to zero)\n        if np.isclose(root.imag, 0):\n            real_root = root.real\n            # Add to candidates if it's in the open interval (0,1)\n            if 0 < real_root < 1:\n                candidates.add(real_root)\n\n    max_abs_error = 0.0\n    for t in candidates:\n        # Evaluate polynomial P_0 at t\n        pos_vec = np.array([Px(t), Py(t)])\n        \n        # Calculate the absolute radial error | ||P_0(t)|| - R |\n        radial_error = np.linalg.norm(pos_vec) - R\n        abs_error = abs(radial_error)\n        \n        # Update maximum error\n        if abs_error > max_abs_error:\n            max_abs_error = abs_error\n            \n    return max_abs_error\n\nsolve()\n```"
        }
    ]
}