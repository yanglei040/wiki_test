{
    "hands_on_practices": [
        {
            "introduction": "The foundation of the finite element method lies in understanding its fundamental building block: the element stiffness matrix. This exercise moves beyond the standard textbook case of a constant material property by asking you to derive the stiffness matrix for a bar with a linearly varying Young's modulus. Completing this derivation from first principles reinforces the integral formulation $K = \\int \\mathbf{B}^T D \\mathbf{B} \\, dV$ and provides insight into modeling functionally graded materials. ",
            "id": "2387978",
            "problem": "Consider a straight, prismatic, one-dimensional bar element of length $L$ aligned with the $x$-axis, occupying the interval $x \\in [0,L]$. The bar is subjected to small strains and small displacements in axial deformation, with a constant cross-sectional area $A$ and a position-dependent Young’s modulus given by $E(x) = E_{0} + a x$, where $E_{0}$ and $a$ are constants. Assume $E(x) > 0$ for all $x \\in [0,L]$. Adopt the standard two-node linear finite element approximation for the axial displacement field, with nodal displacements $u_{1}$ at $x=0$ and $u_{2}$ at $x=L$, and ignore any body forces or tractions so that only the element’s internal response is considered.\n\nStarting from first principles for one-dimensional linear elasticity and the standard two-node linear finite element kinematics, derive the element stiffness matrix that maps the nodal displacement vector $\\begin{pmatrix} u_{1}  u_{2} \\end{pmatrix}^{\\mathsf{T}}$ to the corresponding element internal nodal force vector. Express your final answer as a closed-form two-by-two matrix in terms of $A$, $L$, $E_{0}$, and $a$ only. No numerical evaluation is required, and no rounding is needed. Do not include units in your final answer.",
            "solution": "The problem as stated will first be subjected to rigorous validation before any attempt at a solution is made.\n\nThe givens are extracted verbatim as follows:\n- **Element type**: A straight, prismatic, one-dimensional bar element.\n- **Length**: $L$.\n- **Domain**: $x \\in [0,L]$.\n- **Kinematics**: Small strains and small displacements in axial deformation.\n- **Cross-section**: Constant area $A$.\n- **Material property**: Position-dependent Young’s modulus $E(x) = E_{0} + a x$, where $E_{0}$ and $a$ are constants.\n- **Constraint**: $E(x) > 0$ for all $x \\in [0,L]$.\n- **Approximation**: Two-node linear finite element approximation for the axial displacement field $u(x)$.\n- **Nodal DOFs**: Nodal displacements $u_{1}$ at $x=0$ and $u_{2}$ at $x=L$.\n- **Loading**: Body forces and tractions are ignored.\n- **Objective**: Derive the element stiffness matrix mapping the nodal displacement vector to the internal nodal force vector.\n- **Output specification**: A closed-form $2 \\times 2$ matrix in terms of $A$, $L$, $E_{0}$, and $a$.\n\nThe problem is subjected to validation.\n1.  **Scientific Grounding**: The problem is formulated within the well-established frameworks of one-dimensional linear elasticity and the finite element method. A spatially varying Young's modulus is a valid concept used to model functionally graded materials. The formulation is scientifically sound.\n2.  **Well-Posedness**: The problem is well-posed. It requests the derivation of a specific quantity, the element stiffness matrix, based on a complete and consistent set of physical and mathematical assumptions. A unique solution is expected to exist.\n3.  **Objectivity**: The problem is stated using precise, objective, and unambiguous technical language. It is free of subjective claims.\n\nThe problem is deemed valid. A solution will now be derived from first principles.\n\nThe stiffness matrix $\\mathbf{K}$ for a one-dimensional bar element is given by the integral over the element's volume $V$:\n$$\n\\mathbf{K} = \\int_{V} \\mathbf{B}^{\\mathsf{T}} \\mathbf{D} \\mathbf{B} \\, dV\n$$\nFor a prismatic bar of constant cross-sectional area $A$ and length $L$, the volume integral simplifies to a line integral along the $x$-axis:\n$$\n\\mathbf{K} = \\int_{0}^{L} \\mathbf{B}^{\\mathsf{T}} D \\mathbf{B} A \\, dx\n$$\nHere, $\\mathbf{B}$ is the strain-displacement matrix, and $D$ is the material stiffness, which in this one-dimensional case is the Young's modulus, $E(x)$.\n\nFirst, we define the displacement field $u(x)$ using the standard two-node linear shape functions, $N_{1}(x)$ and $N_{2}(x)$. The displacement at any point $x$ is an interpolation of the nodal displacements $u_{1}$ and $u_{2}$:\n$$\nu(x) = N_{1}(x) u_{1} + N_{2}(x) u_{2}\n$$\nThe linear shape functions for an element defined on the domain $x \\in [0,L]$ are:\n$$\nN_{1}(x) = 1 - \\frac{x}{L}\n$$\n$$\nN_{2}(x) = \\frac{x}{L}\n$$\nIn matrix form, the displacement field is $u(x) = \\mathbf{N}(x) \\mathbf{d}$, where $\\mathbf{N}(x) = \\begin{pmatrix} N_{1}(x)  N_{2}(x) \\end{pmatrix}$ and $\\mathbf{d} = \\begin{pmatrix} u_{1} \\\\ u_{2} \\end{pmatrix}$.\n\nNext, we determine the axial strain, $\\epsilon_{x}$, which is the spatial derivative of the displacement field:\n$$\n\\epsilon_{x}(x) = \\frac{du}{dx} = \\frac{d}{dx} \\left( N_{1}(x) u_{1} + N_{2}(x) u_{2} \\right) = \\left( \\frac{dN_{1}}{dx} \\right) u_{1} + \\left( \\frac{dN_{2}}{dx} \\right) u_{2}\n$$\nThe derivatives of the shape functions are:\n$$\n\\frac{dN_{1}}{dx} = -\\frac{1}{L}\n$$\n$$\n\\frac{dN_{2}}{dx} = \\frac{1}{L}\n$$\nThe strain can be written in matrix form as $\\epsilon_{x}(x) = \\mathbf{B} \\mathbf{d}$, where the strain-displacement matrix $\\mathbf{B}$ is:\n$$\n\\mathbf{B} = \\begin{pmatrix} \\frac{dN_{1}}{dx}  \\frac{dN_{2}}{dx} \\end{pmatrix} = \\begin{pmatrix} -\\frac{1}{L}  \\frac{1}{L} \\end{pmatrix}\n$$\nNote that for a linear element, the $\\mathbf{B}$ matrix is constant with respect to $x$.\n\nThe material constitutive relation is given by $\\sigma_{x}(x) = E(x) \\epsilon_{x}(x)$. The material stiffness $D$ is therefore the position-dependent Young's modulus, $D = E(x) = E_{0} + a x$.\n\nWe now assemble the integral for the stiffness matrix $\\mathbf{K}$:\n$$\n\\mathbf{K} = \\int_{0}^{L} \\mathbf{B}^{\\mathsf{T}} (E_{0} + ax) \\mathbf{B} A \\, dx\n$$\nThe term $\\mathbf{B}^{\\mathsf{T}} \\mathbf{B}$ is:\n$$\n\\mathbf{B}^{\\mathsf{T}} \\mathbf{B} = \\begin{pmatrix} -\\frac{1}{L} \\\\ \\frac{1}{L} \\end{pmatrix} \\begin{pmatrix} -\\frac{1}{L}  \\frac{1}{L} \\end{pmatrix} = \\begin{pmatrix} \\frac{1}{L^{2}}  -\\frac{1}{L^{2}} \\\\ -\\frac{1}{L^{2}}  \\frac{1}{L^{2}} \\end{pmatrix} = \\frac{1}{L^{2}} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix}\n$$\nSubstituting this into the integral for $\\mathbf{K}$:\n$$\n\\mathbf{K} = \\int_{0}^{L} \\left( \\frac{1}{L^{2}} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix} \\right) (E_{0} + ax) A \\, dx\n$$\nSince the matrix term, $A$, and $1/L^2$ are constant with respect to the integration variable $x$, they can be factored out of the integral:\n$$\n\\mathbf{K} = \\frac{A}{L^{2}} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix} \\int_{0}^{L} (E_{0} + ax) \\, dx\n$$\nNow, we evaluate the definite integral:\n$$\n\\int_{0}^{L} (E_{0} + ax) \\, dx = \\left[ E_{0}x + \\frac{ax^{2}}{2} \\right]_{0}^{L} = (E_{0}L + \\frac{aL^{2}}{2}) - (0) = L \\left( E_{0} + \\frac{aL}{2} \\right)\n$$\nThis integral represents the average value of $E(x)$ over the length $L$, multiplied by $L$. Let $\\bar{E} = E_{0} + \\frac{aL}{2}$ be the average Young's modulus.\n\nFinally, substitute the result of the integration back into the expression for $\\mathbf{K}$:\n$$\n\\mathbf{K} = \\frac{A}{L^{2}} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix} \\left( L \\left( E_{0} + \\frac{aL}{2} \\right) \\right)\n$$\nSimplifying the expression by canceling one factor of $L$:\n$$\n\\mathbf{K} = \\frac{A}{L} \\left( E_{0} + \\frac{aL}{2} \\right) \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix}\n$$\nThis is the final closed-form expression for the element stiffness matrix. The condition $E(x) > 0$ on $[0,L]$ implies $E_0>0$ and $E_0+aL >0$, which guarantees that the average modulus $\\bar{E} = E_0 + aL/2 = \\frac{1}{2}(E_0 + (E_0+aL))$ is also positive, ensuring the matrix is positive semi-definite, a necessary property reflecting physical stability.",
            "answer": "$$\n\\boxed{\\frac{A}{L} \\left( E_{0} + \\frac{aL}{2} \\right) \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "Correctly assembling element matrices into a global system is a critical, and often error-prone, step in finite element analysis. This practice frames the task as a debugging challenge, where you must diagnose faulty assembly routines by examining the properties of the resulting global matrix. By connecting common bugs to violations of properties like symmetry and positive semi-definiteness, you will develop a deep, intuitive understanding of what makes a global stiffness matrix physically and mathematically sound. ",
            "id": "2388002",
            "problem": "You are given a one-dimensional mesh with $n=4$ global nodes labeled $0,1,2,3$ and three two-node linear elements with connectivity\n- $e_1 = (0,1)$,\n- $e_2 = (1,2)$,\n- $e_3 = (2,3)$.\n\nEach element has an identical local stiffness matrix given explicitly by\n$$\nk^{(e)} \\;=\\; \\begin{bmatrix} 2  -2 \\\\ -2  2 \\end{bmatrix}.\n$$\nThe intended global stiffness matrix $K$ is produced by the standard finite element assembly, which adds each local entry $k^{(e)}_{ab}$ to the global entry $K_{ij}$ where $i$ and $j$ are the global node indices corresponding to the local nodes $a$ and $b$ of element $e$. No boundary conditions are applied.\n\nA set of four candidate global matrices is to be analyzed. They are defined as follows, using only the mesh and local matrices above:\n\n- Case $1$ (correct assembly): Assemble $K$ by summing all contributions $k^{(e)}_{ab}$ into the corresponding global entries $K_{ij}$ for all elements and all local index pairs $(a,b)$.\n- Case $2$ (lower-triangular-only assembly): For each element and each local index pair $(a,b)$, add $k^{(e)}_{ab}$ only if the corresponding global indices satisfy $i \\ge j$. No symmetric mirroring is performed.\n- Case $3$ (overwrite-instead-of-accumulate bug): For each element and each local index pair $(a,b)$, set $K_{ij} \\leftarrow k^{(e)}_{ab}$, overwriting the current value instead of adding to it. Elements are processed in the order $e_1, e_2, e_3$.\n- Case $4$ (missing-middle-element bug): Assemble as in Case $1$ but skip element $e_2$ entirely.\n\nFor each candidate matrix $\\widehat{K}$, determine the following properties, using the tolerance $\\tau = 10^{-10}$:\n\n- $p_1$: symmetry, i.e., whether $\\|\\widehat{K}-\\widehat{K}^\\top\\|_\\infty \\le \\tau$.\n- $p_2$: positive semi-definiteness in the sense of the quadratic form, i.e., whether the symmetric part $S=(\\widehat{K}+\\widehat{K}^\\top)/2$ has all eigenvalues $\\ge -\\tau$.\n- $p_3$: zero row-sum property, i.e., whether every row sum of $\\widehat{K}$ has absolute value $\\le \\tau$.\n- $p_4$: sign pattern consistency with diffusion-type stiffness, i.e., whether all diagonal entries of $\\widehat{K}$ are $\\ge -\\tau$ and all off-diagonal entries are $\\le \\tau$.\n- $p_5$: the nullity of $\\widehat{K}$, defined as the number of singular values of $\\widehat{K}$ that are $\\le \\tau$.\n\nYour program must implement the assembly from first principles using the data above and construct the four candidate matrices exactly as specified. Then, for each case in the order $1,2,3,4$, compute $[p_1,p_2,p_3,p_4,p_5]$.\n\nTest suite:\n- Mesh parameters: $n=4$ nodes, elements $e_1=(0,1)$, $e_2=(1,2)$, $e_3=(2,3)$.\n- Local stiffness matrix for all elements: $k^{(e)} = \\begin{bmatrix} 2  -2 \\\\ -2  2 \\end{bmatrix}$.\n- Tolerance: $\\tau = 10^{-10}$.\n\nRequired final output format:\n- Your program should produce a single line of output containing the results as a comma-separated list of the per-case results, in order $1,2,3,4$, enclosed in square brackets. Each per-case result must itself be a comma-separated list enclosed in square brackets, containing $5$ entries $[p_1,p_2,p_3,p_4,p_5]$, where $p_1,p_2,p_3,p_4$ are booleans and $p_5$ is an integer. For example, the overall structure must be\n$$\n[[p_{1,1},p_{1,2},p_{1,3},p_{1,4},p_{1,5}],[p_{2,1},p_{2,2},p_{2,3},p_{2,4},p_{2,5}],[p_{3,1},p_{3,2},p_{3,3},p_{3,4},p_{3,5}],[p_{4,1},p_{4,2},p_{4,3},p_{4,4},p_{4,5}]].\n$$\nNo spaces or additional characters are allowed in the output line.",
            "solution": "The problem statement is assessed to be valid. It is scientifically grounded in the principles of the Finite Element Method, providing a clear, self-contained, and objective task. All data required for the construction and analysis of the specified matrices are provided. The problem is well-posed and allows for a unique, verifiable solution. We shall proceed with the derivation.\n\nThe problem requires the construction and analysis of four different $4 \\times 4$ global stiffness matrices, denoted $\\widehat{K}$, derived from a one-dimensional mesh of $n=4$ nodes and $3$ elements. The nodes are indexed $0, 1, 2, 3$. The element connectivities are $e_1 = (0,1)$, $e_2 = (1,2)$, and $e_3 = (2,3)$. Each element possesses an identical local stiffness matrix $k^{(e)}$:\n$$\nk^{(e)} = \\begin{bmatrix} 2  -2 \\\\ -2  2 \\end{bmatrix}\n$$\nThe assembly process maps the local entries $k^{(e)}_{ab}$ (where $a, b \\in \\{0, 1\\}$) to the global entries $\\widehat{K}_{ij}$, where $i$ and $j$ are the global indices corresponding to the local nodes $a$ and $b$ for element $e$.\n\nFirst, we construct the four candidate matrices. All matrices are initialized as $4 \\times 4$ zero matrices.\n\nCase 1: Correct Assembly.\nThe standard assembly procedure sums the contributions from all elements.\n- Element $e_1=(0,1)$ contributes $k^{(1)}$ to the submatrix corresponding to nodes $(0,1)$.\n- Element $e_2=(1,2)$ contributes $k^{(2)}$ to the submatrix corresponding to nodes $(1,2)$.\n- Element $e_3=(2,3)$ contributes $k^{(3)}$ to the submatrix corresponding to nodes $(2,3)$.\n\nThe accumulation proceeds as follows:\nContribution from $e_1$: $\\begin{bmatrix} 2  -2  0  0 \\\\ -2  2  0  0 \\\\ 0  0  0  0 \\\\ 0  0  0  0 \\end{bmatrix}$\nContribution from $e_2$: $\\begin{bmatrix} 0  0  0  0 \\\\ 0  2  -2  0 \\\\ 0  -2  2  0 \\\\ 0  0  0  0 \\end{bmatrix}$\nContribution from $e_3$: $\\begin{bmatrix} 0  0  0  0 \\\\ 0  0  0  0 \\\\ 0  0  2  -2 \\\\ 0  0  -2  2 \\end{bmatrix}$\n\nSumming these contributions yields the final matrix $\\widehat{K}_1$:\n$$\n\\widehat{K}_1 = \\begin{bmatrix}\n2  -2  0  0 \\\\\n-2  4  -2  0 \\\\\n0  -2  4  -2 \\\\\n0  0  -2  2\n\\end{bmatrix}\n$$\n\nCase 2: Lower-Triangular-Only Assembly.\nFor each element, an entry $k^{(e)}_{ab}$ is added to $\\widehat{K}_{ij}$ only if the global indices satisfy $i \\ge j$.\n- For $e_1=(0,1)$, the global pairs $(i,j)$ are $(0,0), (0,1), (1,0), (1,1)$. The condition $i \\ge j$ holds for $(0,0), (1,0), (1,1)$.\n- For $e_2=(1,2)$, the global pairs are $(1,1), (1,2), (2,1), (2,2)$. The condition holds for $(1,1), (2,1), (2,2)$.\n- For $e_3=(2,3)$, the global pairs are $(2,2), (2,3), (3,2), (3,3)$. The condition holds for $(2,2), (3,2), (3,3)$.\n\nAccumulating these contributions:\n$\\widehat{K}_{00} \\leftarrow 2$\n$\\widehat{K}_{10} \\leftarrow -2$, $\\widehat{K}_{11} \\leftarrow 2$\nFrom $e_2$: $\\widehat{K}_{11} \\leftarrow 2+2=4$, $\\widehat{K}_{21} \\leftarrow -2$, $\\widehat{K}_{22} \\leftarrow 2$\nFrom $e_3$: $\\widehat{K}_{22} \\leftarrow 2+2=4$, $\\widehat{K}_{32} \\leftarrow -2$, $\\widehat{K}_{33} \\leftarrow 2$\nThe resulting matrix is:\n$$\n\\widehat{K}_2 = \\begin{bmatrix}\n2  0  0  0 \\\\\n-2  4  0  0 \\\\\n0  -2  4  0 \\\\\n0  0  -2  2\n\\end{bmatrix}\n$$\n\nCase 3: Overwrite-Instead-of-Accumulate Bug.\nThe contributions are not added but overwrite existing values. The elements are processed in order $e_1, e_2, e_3$.\n- After $e_1=(0,1)$: $\\widehat{K}_3 = \\begin{bmatrix} 2  -2  0  0 \\\\ -2  2  0  0 \\\\ 0  0  0  0 \\\\ 0  0  0  0 \\end{bmatrix}$\n- After $e_2=(1,2)$: The submatrix for nodes $(1,2)$ is overwritten. $\\widehat{K}_{11}$ becomes $2$ (not $4$).\n$\\widehat{K}_3 = \\begin{bmatrix} 2  -2  0  0 \\\\ -2  2  -2  0 \\\\ 0  -2  2  0 \\\\ 0  0  0  0 \\end{bmatrix}$\n- After $e_3=(2,3)$: The submatrix for nodes $(2,3)$ is overwritten. $\\widehat{K}_{22}$ becomes $2$.\n$$\n\\widehat{K}_3 = \\begin{bmatrix}\n2  -2  0  0 \\\\\n-2  2  -2  0 \\\\\n0  -2  2  -2 \\\\\n0  0  -2  2\n\\end{bmatrix}\n$$\n\nCase 4: Missing-Middle-Element Bug.\nThe assembly is correct, but element $e_2$ is skipped. Only $e_1$ and $e_3$ are assembled.\n$$\n\\widehat{K}_4 = \\begin{bmatrix} 2  -2  0  0 \\\\ -2  2  0  0 \\\\ 0  0  0  0 \\\\ 0  0  0  0 \\end{bmatrix} + \\begin{bmatrix} 0  0  0  0 \\\\ 0  0  0  0 \\\\ 0  0  2  -2 \\\\ 0  0  -2  2 \\end{bmatrix} = \\begin{bmatrix}\n2  -2  0  0 \\\\\n-2  2  0  0 \\\\\n0  0  2  -2 \\\\\n0  0  -2  2\n\\end{bmatrix}\n$$\n\nNext, we analyze the five properties for each matrix with tolerance $\\tau = 10^{-10}$.\n\n$p_1$: Symmetry: $\\|\\widehat{K}-\\widehat{K}^\\top\\|_\\infty \\le \\tau$. The infinity norm is the maximum absolute row sum.\n$p_2$: Positive semi-definiteness: $\\min(\\text{eig}(S)) \\ge -\\tau$, where $S = (\\widehat{K}+\\widehat{K}^\\top)/2$ is the symmetric part.\n$p_3$: Zero row-sum property: $\\max_i |\\sum_j \\widehat{K}_{ij}| \\le \\tau$.\n$p_4$: Sign pattern: $\\min_i \\widehat{K}_{ii} \\ge -\\tau$ and $\\max_{i\\ne j} \\widehat{K}_{ij} \\le \\tau$.\n$p_5$: Nullity: The number of singular values $\\sigma$ of $\\widehat{K}$ such that $\\sigma \\le \\tau$.\n\nAnalysis of $\\widehat{K}_1$:\n- $p_1$: $\\widehat{K}_1$ is symmetric by inspection. True.\n- $p_2$: $\\widehat{K}_1$ is a standard graph Laplacian for a path graph. It is known to be positive semi-definite. The vector $[1,1,1,1]^\\top$ is in its null space, giving a zero eigenvalue. All other eigenvalues are positive. True.\n- $p_3$: All row sums are $0$. For example, row 1: $-2+4-2=0$. True.\n- $p_4$: Diagonals ($2,4,4,2$) are positive. Off-diagonals ($-2,0$) are non-positive. True.\n- $p_5$: The nullity of a connected floating mechanical system is $1$ (rigid-body translation). The rank is $3$. Nullity is $4-3=1$. Value: $1$.\nResult 1: $[True, True, True, True, 1]$\n\nAnalysis of $\\widehat{K}_2$:\n- $p_1$: Not symmetric, e.g., $\\widehat{K}_{10}=-2$ but $\\widehat{K}_{01}=0$. False.\n- $p_2$: The symmetric part is $S = (\\widehat{K}_2+\\widehat{K}_2^\\top)/2 = \\begin{bsmallmatrix} 2  -1  0  0 \\\\ -1  4  -1  0 \\\\ 0  -1  4  -1 \\\\ 0  0  -1  2 \\end{bsmallmatrix}$. This is a symmetric diagonally dominant matrix with positive diagonal entries, so it is positive definite. All eigenvalues are positive. True.\n- $p_3$: The row sums are $[2, 2, 2, 0]^\\top$. Not all are zero. False.\n- $p_4$: Diagonals ($2,4,4,2$) are positive. Off-diagonals ($-2,0$) are non-positive. True.\n- $p_5$: $\\det(\\widehat{K}_2) = 2 \\cdot 4 \\cdot 4 \\cdot 2 = 64 \\ne 0$. The matrix is invertible, so its rank is $4$ and its nullity is $0$. Value: $0$.\nResult 2: $[False, True, False, True, 0]$\n\nAnalysis of $\\widehat{K}_3$:\n- $p_1$: $\\widehat{K}_3$ is symmetric by inspection. True.\n- $p_2$: Since $\\widehat{K}_3$ is symmetric, $S=\\widehat{K}_3$. The leading principal minor of size $3 \\times 3$ is $\\det(\\begin{bsmallmatrix} 2  -2  0 \\\\ -2  2  -2 \\\\ 0  -2  2 \\end{bsmallmatrix}) = 2(4-4) - (-2)(-4) = -8$. A symmetric matrix with a negative leading principal minor is not positive semi-definite. False.\n- $p_3$: Row sums are $[0, -2, -2, 0]^\\top$. Not all are zero. False.\n- $p_4$: Diagonals ($2,2,2,2$) are positive. Off-diagonals ($-2,0$) are non-positive. True.\n- $p_5$: $\\det(\\widehat{K}_3) = -16 \\ne 0$. The matrix is invertible, so its rank is $4$ and its nullity is $0$. Value: $0$.\nResult 3: $[True, False, False, True, 0]$\n\nAnalysis of $\\widehat{K}_4$:\n- $p_1$: $\\widehat{K}_4$ is symmetric by inspection. True.\n- $p_2$: $\\widehat{K}_4$ is block-diagonal with two identical blocks of $\\begin{bsmallmatrix} 2  -2 \\\\ -2  2 \\end{bsmallmatrix}$. Each block is positive semi-definite with eigenvalues $0, 4$. The eigenvalues of $\\widehat{K}_4$ are thus $\\{0, 4, 0, 4\\}$. All are non-negative. True.\n- $p_3$: The row sums of each block are zero, so all row sums of $\\widehat{K}_4$ are zero. True.\n- $p_4$: Diagonals ($2,2$) are positive. Off-diagonals ($-2,0$) are non-positive. True.\n- $p_5$: Since there are two zero eigenvalues, the null space has dimension $2$. This corresponds to the two independent rigid-body motions of the two disconnected sub-systems. The nullity is $2$. Value: $2$.\nResult 4: $[True, True, True, True, 2]$",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef assemble_case1(k_elem, conn, n_nodes):\n    \"\"\"Case 1: Correct standard assembly.\"\"\"\n    K = np.zeros((n_nodes, n_nodes))\n    for nodes in conn:\n        for i_local, i_global in enumerate(nodes):\n            for j_local, j_global in enumerate(nodes):\n                K[i_global, j_global] += k_elem[i_local, j_local]\n    return K\n\ndef assemble_case2(k_elem, conn, n_nodes):\n    \"\"\"Case 2: Lower-triangular-only assembly.\"\"\"\n    K = np.zeros((n_nodes, n_nodes))\n    for nodes in conn:\n        for i_local, i_global in enumerate(nodes):\n            for j_local, j_global in enumerate(nodes):\n                if i_global >= j_global:\n                    K[i_global, j_global] += k_elem[i_local, j_local]\n    return K\n\ndef assemble_case3(k_elem, conn, n_nodes):\n    \"\"\"Case 3: Overwrite-instead-of-accumulate bug.\"\"\"\n    K = np.zeros((n_nodes, n_nodes))\n    for nodes in conn:\n        for i_local, i_global in enumerate(nodes):\n            for j_local, j_global in enumerate(nodes):\n                K[i_global, j_global] = k_elem[i_local, j_local]\n    return K\n\ndef assemble_case4(k_elem, conn, n_nodes):\n    \"\"\"Case 4: Missing middle element e_2.\"\"\"\n    K = np.zeros((n_nodes, n_nodes))\n    conn_case4 = [conn[0], conn[2]]\n    for nodes in conn_case4:\n        for i_local, i_global in enumerate(nodes):\n            for j_local, j_global in enumerate(nodes):\n                K[i_global, j_global] += k_elem[i_local, j_local]\n    return K\n\ndef analyze_properties(K, tol):\n    \"\"\"Analyzes a given matrix for the 5 specified properties.\"\"\"\n    n_nodes = K.shape[0]\n\n    # p1: Symmetry check using infinity norm\n    p1 = np.linalg.norm(K - K.T, ord=np.inf) = tol\n\n    # p2: Positive semi-definiteness of the symmetric part\n    S = (K + K.T) / 2.0\n    try:\n        # eigvalsh is for symmetric/Hermitian matrices and is more efficient/stable.\n        eigenvalues = np.linalg.eigvalsh(S)\n        p2 = np.min(eigenvalues) = -tol\n    except np.linalg.LinAlgError:\n        p2 = False\n\n    # p3: Zero row-sum property\n    row_sums = np.sum(K, axis=1)\n    p3 = np.all(np.abs(row_sums) = tol)\n\n    # p4: Sign pattern consistency\n    diag_vals = np.diag(K)\n    # Create a boolean mask for off-diagonal elements\n    off_diag_mask = ~np.eye(n_nodes, dtype=bool)\n    off_diag_vals = K[off_diag_mask]\n    \n    diag_ok = np.all(diag_vals = -tol)\n    # Handle the case of a 1x1 matrix with no off-diagonal elements\n    off_diag_ok = np.all(off_diag_vals = tol) if off_diag_vals.size  0 else True\n    p4 = diag_ok and off_diag_ok\n\n    # p5: Nullity (dimension of null space)\n    singular_values = np.linalg.svd(K, compute_uv=False)\n    p5 = np.sum(singular_values = tol)\n\n    return [p1, p2, p3, p4, int(p5)]\n\ndef solve():\n    # Define the problem parameters from the statement.\n    n_nodes = 4\n    connectivity = [(0, 1), (1, 2), (2, 3)]\n    k_element = np.array([[2.0, -2.0], [-2.0, 2.0]])\n    tolerance = 1e-10\n\n    # Build the matrices for each case\n    candidate_matrices = [\n        assemble_case1(k_element, connectivity, n_nodes),\n        assemble_case2(k_element, connectivity, n_nodes),\n        assemble_case3(k_element, connectivity, n_nodes),\n        assemble_case4(k_element, connectivity, n_nodes),\n    ]\n\n    all_results = []\n    for K_hat in candidate_matrices:\n        properties = analyze_properties(K_hat, tolerance)\n        all_results.append(properties)\n\n    # Format the final output string exactly as required, with no spaces.\n    # 1. Convert each inner list of properties to a comma-separated string.\n    #    e.g., [True, True, 1] becomes \"True,True,1\"\n    # 2. Enclose each resulting string in brackets.\n    #    e.g., \"True,True,1\" becomes \"[True,True,1]\"\n    # 3. Join these strings with commas.\n    #    e.g., \"[True,True,1],[False,False,0]\"\n    # 4. Enclose the final result in brackets.\n    #    e.g., \"[[True,True,1],[False,False,0]]\"\n    result_strings = [f\"[{','.join(map(str, prop_list))}]\" for prop_list in all_results]\n    final_output_string = f\"[{','.join(result_strings)}]\"\n\n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "The way we structure a finite element model has profound consequences for computational efficiency. This exercise explores how a seemingly simple choice—the order in which nodes are numbered—directly impacts the bandwidth of the global stiffness matrix. By analyzing different numbering schemes, you will discover why optimizing matrix structure is essential for minimizing memory requirements and solution time in large-scale simulations, a crucial skill for any computational engineer. ",
            "id": "2388028",
            "problem": "You are given a family of rectangular grid meshes for a scalar, second-order elliptic boundary value problem discretized by conforming bilinear quadrilateral elements (commonly denoted as $Q4$). Consider a mesh with $n_x$ nodes along the horizontal direction and $n_y$ nodes along the vertical direction, forming $(n_x-1)(n_y-1)$ four-node elements by connecting adjacent nodes into axis-aligned quadrilaterals. Let $N = n_x n_y$ be the total number of nodes, and let the global stiffness matrix be $K \\in \\mathbb{R}^{N \\times N}$. The mesh is regular, and the element-level stiffness matrix for each element couples all its four corner nodes. No boundary conditions are applied or eliminated; the full set of $N$ nodal degrees of freedom is retained.\n\nDefine the following three nodal numbering schemes that assign to each node a unique index in $\\{0,1,\\dots,N-1\\}$:\n\n- Row-major (lexicographic by rows): indices increase from left to right within each row, and from the top row to the bottom row. Explicitly, for a node at row $i \\in \\{0,\\dots,n_y-1\\}$ and column $j \\in \\{0,\\dots,n_x-1\\}$, the index is $i n_x + j$.\n- Column-major (lexicographic by columns): indices increase from top to bottom within each column, and from the leftmost column to the rightmost column. Explicitly, for a node at row $i \\in \\{0,\\dots,n_y-1\\}$ and column $j \\in \\{0,\\dots,n_x-1\\}$, the index is $j n_y + i$.\n- Zigzag row-wise (serpentine): indices increase from left to right on even-numbered rows and from right to left on odd-numbered rows, with rows ordered from top to bottom. Explicitly, for a node at row $i \\in \\{0,\\dots,n_y-1\\}$ and column $j \\in \\{0,\\dots,n_x-1\\}$, the index is $i n_x + j$ if $i$ is even, and $i n_x + (n_x - 1 - j)$ if $i$ is odd.\n\nThe global stiffness matrix $K$ is symmetric. By the assembly definition for $Q4$ elements, an entry $K_{pq}$ is nonzero if and only if the global nodes with indices $p$ and $q$ are both corner nodes of at least one common element. Define the semi-bandwidth $b$ of $K$ under a given nodal numbering as\n$$\nb \\;=\\; 1 \\;+\\; \\max\\{\\,|j - i| \\;:\\; K_{ij} \\neq 0 \\,\\}.\n$$\nEquivalently, $b$ is the smallest positive integer such that $K_{ij} = 0$ whenever $|j-i| \\ge b$. All quantities in this problem are dimensionless, and no physical units are required. Angles are not involved.\n\nYour task is to write a complete, runnable program that, for each mesh in the test suite below, computes the semi-bandwidth $b$ of $K$ under each of the three numbering schemes and returns the results.\n\nTest suite (each case is a pair $(n_x,n_y)$ with $n_x \\ge 2$ and $n_y \\ge 2$):\n- Case $1$: $(n_x,n_y) = (3,3)$.\n- Case $2$: $(n_x,n_y) = (6,4)$.\n- Case $3$: $(n_x,n_y) = (10,2)$.\n- Case $4$: $(n_x,n_y) = (4,7)$.\n- Case $5$: $(n_x,n_y) = (2,2)$.\n\nFinal output format: Your program should produce a single line of output containing a comma-separated list of results, one per test case, where each result is itself a comma-separated list of the three semi-bandwidths in the order [row-major, column-major, zigzag]. The entire output must be a single list of lists with no spaces, for example\n\"[[b1_row,b1_col,b1_zig],[b2_row,b2_col,b2_zig],...]\".",
            "solution": "The problem statement is subjected to validation and is found to be valid. It is scientifically grounded in the theory of the Finite Element Method, it is well-posed with precise definitions, and its formulation is objective. No flaws were identified. We may therefore proceed with the solution.\n\nThe problem requires the computation of the semi-bandwidth $b$ of the global stiffness matrix $K$ for a regular quadrilateral mesh under three distinct nodal numbering schemes. The semi-bandwidth is defined as $b = 1 + \\max\\{|j - i| : K_{ij} \\neq 0\\}$. The condition $K_{ij} \\neq 0$ is stated to hold if and only if the global nodes with indices $i$ and $j$ are part of at least one common element. Therefore, the task reduces to finding the maximum absolute difference between the indices of any two nodes belonging to the same element, and adding $1$ to this maximum difference.\n\nLet the mesh have $n_y$ rows and $n_x$ columns of nodes. The grid coordinates of a node are $(i, j)$, where $i \\in \\{0, 1, \\dots, n_y-1\\}$ is the row index (from top to bottom) and $j \\in \\{0, 1, \\dots, n_x-1\\}$ is the column index (from left to right). A generic four-node ($Q4$) element is defined by the four nodes at its corners. We can identify each element by its top-left corner node at grid position $(r, c)$, where $r \\in \\{0, 1, \\dots, n_y-2\\}$ and $c \\in \\{0, 1, \\dots, n_x-2\\}$. The four nodes of such an element are located at grid positions $(r, c)$, $(r, c+1)$, $(r+1, c)$, and $(r+1, c+1)$.\n\nFor a given numbering scheme, let $\\text{idx}(i, j)$ be the global index assigned to the node at grid position $(i, j)$. For an element with its top-left corner at $(r, c)$, the indices of its four nodes are $\\text{idx}(r, c)$, $\\text{idx}(r, c+1)$, $\\text{idx}(r+1, c)$, and $\\text{idx}(r+1, c+1)$. The maximum index difference within this element is $\\Delta_{rc} = \\max(\\text{indices}) - \\min(\\text{indices})$. The global maximum difference is $\\max_{r,c} \\Delta_{rc}$. The semi-bandwidth is then $b = 1 + \\max_{r,c} \\Delta_{rc}$. We will now derive this value for each of the three numbering schemes.\n\n1.  **Row-major numbering**:\n    The index of a node at $(i, j)$ is given by the formula $\\text{idx}(i, j) = i n_x + j$.\n    For an element with its top-left corner at $(r, c)$, the four nodal indices are:\n    - $\\text{idx}(r, c) = r n_x + c$\n    - $\\text{idx}(r, c+1) = r n_x + c + 1$\n    - $\\text{idx}(r+1, c) = (r+1) n_x + c$\n    - $\\text{idx}(r+1, c+1) = (r+1) n_x + c + 1$\n    Since the indices increase with both $r$ and $j$, the minimum index in this set corresponds to the top-left node $(r, c)$ and the maximum index corresponds to the bottom-right node $(r+1, c+1)$.\n    The maximum difference for this element is:\n    $$ \\Delta_{rc} = \\text{idx}(r+1, c+1) - \\text{idx}(r, c) = ((r+1)n_x + c + 1) - (r n_x + c) = n_x + 1 $$\n    This difference, $n_x + 1$, is independent of the element's position $(r, c)$. Thus, the global maximum difference is $n_x + 1$.\n    The semi-bandwidth for the row-major scheme is $b_{\\text{row}} = 1 + (n_x + 1) = n_x + 2$.\n\n2.  **Column-major numbering**:\n    The index of a node at $(i, j)$ is given by $\\text{idx}(i, j) = j n_y + i$.\n    This scheme is analogous to the row-major scheme applied to a transposed grid with dimensions $n_y \\times n_x$. By swapping the roles of $n_x$ and $n_y$ in the row-major analysis, we can directly deduce the result.\n    To be explicit, for an element with its top-left corner at $(r, c)$, the four nodal indices are:\n    - $\\text{idx}(r, c) = c n_y + r$\n    - $\\text{idx}(r, c+1) = (c+1) n_y + r$\n    - $\\text{idx}(r+1, c) = c n_y + r + 1$\n    - $\\text{idx}(r+1, c+1) = (c+1) n_y + r + 1$\n    The minimum index is $\\text{idx}(r, c)$ and the maximum is $\\text{idx}(r+1, c+1)$.\n    The maximum difference for this element is:\n    $$ \\Delta_{rc} = \\text{idx}(r+1, c+1) - \\text{idx}(r, c) = ((c+1)n_y + r + 1) - (c n_y + r) = n_y + 1 $$\n    This is also independent of $(r, c)$. The global maximum difference is $n_y + 1$.\n    The semi-bandwidth for the column-major scheme is $b_{\\text{col}} = 1 + (n_y + 1) = n_y + 2$.\n\n3.  **Zigzag row-wise numbering**:\n    The indexing depends on the parity of the row index $i$.\n    If $i$ is even: $\\text{idx}(i, j) = i n_x + j$.\n    If $i$ is odd: $\\text{idx}(i, j) = i n_x + (n_x - 1 - j)$.\n    We must analyze an element connecting row $r$ and row $r+1$. Two cases arise depending on the parity of $r$.\n\n    Case A: $r$ is an even number.\n    Row $r$ is numbered left-to-right, and row $r+1$ is numbered right-to-left. The four nodal indices for an element with top-left corner $(r, c)$ are:\n    - $\\text{idx}(r, c) = r n_x + c$\n    - $\\text{idx}(r, c+1) = r n_x + c + 1$\n    - $\\text{idx}(r+1, c) = (r+1) n_x + (n_x - 1 - c)$\n    - $\\text{idx}(r+1, c+1) = (r+1) n_x + (n_x - 1 - (c+1)) = (r+1) n_x + n_x - 2 - c$\n    The minimum index in this set is $\\text{idx}(r, c) = r n_x + c$, and the maximum is $\\text{idx}(r+1, c) = (r+1) n_x + n_x - 1 - c$. This holds for all valid $c \\in \\{0, \\dots, n_x-2\\}$.\n    The maximum difference for this element is:\n    $$ \\Delta_{rc} = \\text{idx}(r+1, c) - \\text{idx}(r, c) = ((r+1)n_x + n_x - 1 - c) - (r n_x + c) = 2 n_x - 1 - 2c $$\n    This difference depends on the column $c$. To find the global maximum, we must maximize $\\Delta_{rc}$ over all possible values of $c$. As $2n_x - 1 - 2c$ is a decreasing function of $c$, its maximum occurs at the smallest value of $c$, which is $c=0$. The maximum difference is $2 n_x - 1$.\n\n    Case B: $r$ is an odd number.\n    Row $r$ is numbered right-to-left, and row $r+1$ is numbered left-to-right. The four nodal indices are:\n    - $\\text{idx}(r, c) = r n_x + (n_x - 1 - c)$\n    - $\\text{idx}(r, c+1) = r n_x + n_x - 2 - c$\n    - $\\text{idx}(r+1, c) = (r+1) n_x + c$\n    - $\\text{idx}(r+1, c+1) = (r+1) n_x + c + 1$\n    The minimum index is $\\text{idx}(r, c+1) = r n_x + n_x - 2 - c$, and the maximum is $\\text{idx}(r+1, c+1) = (r+1) n_x + c + 1$. This holds for all valid $c$.\n    The maximum difference for this element is:\n    $$ \\Delta_{rc} = \\text{idx}(r+1, c+1) - \\text{idx}(r, c+1) = ((r+1)n_x + c + 1) - (r n_x + n_x - 2 - c) = 2c + 3 $$\n    This difference, $2c+3$, is an increasing function of $c$. Its maximum occurs at the largest value of $c$, which is $c=n_x-2$. The maximum difference is $2(n_x-2) + 3 = 2n_x - 1$.\n\n    In both cases, the maximum difference encountered is $2n_x - 1$.\n    The semi-bandwidth for the zigzag scheme is $b_{\\text{zig}} = 1 + (2n_x - 1) = 2n_x$.\n\nIn summary, the semi-bandwidths for the three schemes are given by the following simple formulas:\n- Row-major: $b_{\\text{row}} = n_x + 2$\n- Column-major: $b_{\\text{col}} = n_y + 2$\n- Zigzag row-wise: $b_{\\text{zig}} = 2 n_x$\n\nThese formulas will be implemented to solve the given test cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n\ndef solve():\n    \"\"\"\n    Computes the semi-bandwidth of the global stiffness matrix for a series of\n    rectangular meshes under three different nodal numbering schemes.\n    \"\"\"\n    # Test suite: each case is a tuple (nx, ny)\n    # where nx is the number of nodes in the horizontal direction\n    # and ny is the number of nodes in the vertical direction.\n    test_cases = [\n        (3, 3),   # Case 1\n        (6, 4),   # Case 2\n        (10, 2),  # Case 3\n        (4, 7),   # Case 4\n        (2, 2)    # Case 5\n    ]\n\n    results = []\n    for case in test_cases:\n        nx, ny = case\n\n        # The semi-bandwidth 'b' is defined as 1 + max(|j - i|) for all i, j\n        # such that the matrix entry K_ij is non-zero.\n        # K_ij is non-zero iff nodes i and j belong to the same element.\n        # This problem reduces to finding the maximum index difference between any\n        # two nodes within the same element, over all elements in the mesh.\n        \n        # 1. Row-major numbering: b_row = nx + 2\n        # The max index difference within an element is (nx + 1).\n        b_row = nx + 2\n\n        # 2. Column-major numbering: b_col = ny + 2\n        # By symmetry with row-major on a transposed grid, the max index\n        # difference is (ny + 1).\n        b_col = ny + 2\n\n        # 3. Zigzag row-wise numbering: b_zig = 2*nx\n        # The max index difference is (2*nx - 1).\n        b_zig = 2 * nx\n\n        # Store the results for the current test case.\n        results.append([b_row, b_col, b_zig])\n\n    # Format the final output string as a list of lists with no spaces.\n    # e.g., \"[[r1,c1,z1],[r2,c2,z2]]\"\n    outer_parts = []\n    for res_list in results:\n        inner_str = '[' + ','.join(map(str, res_list)) + ']'\n        outer_parts.append(inner_str)\n    \n    final_output_str = '[' + ','.join(outer_parts) + ']'\n\n    # The final print statement must produce only the required single-line format.\n    print(final_output_str)\n\nsolve()\n```"
        }
    ]
}