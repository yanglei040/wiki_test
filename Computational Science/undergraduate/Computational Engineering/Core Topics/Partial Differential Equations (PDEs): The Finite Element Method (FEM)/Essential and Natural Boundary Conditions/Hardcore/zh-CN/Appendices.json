{
    "hands_on_practices": [
        {
            "introduction": "我们的第一个练习为自然边界条件提供了一个清晰的物理直觉。我们将分析一个简单的一维弹性杆，其一端施加了力——一个经典的诺伊曼(Neumann)条件。你将发现，这个单一的条件决定了杆内各处的内力，从而使一个看似复杂的形状优化问题变得异常简单。这个实践揭示了自然边界条件如何直接关系到系统内部的力平衡。",
            "id": "2389742",
            "problem": "考虑一根占据区间 $[0,L]$ 的一维线弹性杆，其空间坐标为 $x$。未知位移场为 $u(x)$。该杆具有空间变化的横截面积 $A(x)$ 和恒定的杨氏模量 $E$。控制模型基于轴向变形的小应变和线弹性理论。假设没有体力。\n\n边界条件施加如下：\n- 一个本质（Dirichlet）边界条件固定了左端：$u(0)=0$。\n- 一个自然（Neumann）边界条件在右端施加了固定的总端部力：在 $x=L$ 处的轴向牵引力等于一个给定值 $F$，因此边界条件为 $(EA(x)u'(x))\\big|_{x=L}=F$。\n\n通过将变分法应用于总势能，内部平衡方程以弱形式强制执行，并产生一个内部常微分方程，以及上述本质和自然边界条件。\n\n形状优化问题。设计变量是横截面积函数 $A(x)$。目标是最小化杆上轴向柯西应力的峰值，\n$$\n\\min_{A(\\cdot)}\\ \\ \\max_{x\\in[0,L]} \\ \\sigma(x),\n$$\n其中 $\\sigma(x)$ 是轴向应力。设计必须满足以下约束条件：\n- 总材料体积固定：$\\int_0^L A(x)\\, dx = V$。\n- 逐点几何约束：对于所有 $x\\in[0,L]$，$a_{\\min} \\le A(x) \\le a_{\\max}$。\n\n假设 $F\\ge 0$ 且三元组 $(L,V,[a_{\\min},a_{\\max}])$ 是可行的，即 $a_{\\min}L \\le V \\le a_{\\max}L$。\n\n你的任务：\n1. 从弱形式和边界条件推导出轴向力 $N(x)$ 和应力 $\\sigma(x)$ 关于 $A(x)$ 和 $F$ 的表达式。\n2. 仅使用凸分析的基本原理和不等式，确定在给定约束下最小化峰值应力的形状 $A(x)$。\n3. 实现一个程序，对于下面的每个测试用例，计算最小化的峰值应力。该程序不得执行数值偏微分方程离散化；它必须使用你推导出的解析结构。每个测试用例的输出是一个浮点数，表示最小化的峰值应力（单位：帕斯卡），四舍五入到六位小数。\n\n使用以下测试套件（每个元组列出 $(L,\\ V,\\ F,\\ a_{\\min},\\ a_{\\max})$，其中 $L$ 的单位是米， $V$ 的单位是立方米，$F$ 的单位是牛顿， $a_{\\min}, a_{\\max}$ 的单位是平方米）：\n- 测试 1（一般可行情况）：$(1.2,\\ 0.006,\\ 10000,\\ 0.003,\\ 0.006)$\n- 测试 2（体积在下界）：$(2.0,\\ 0.004,\\ 8000,\\ 0.002,\\ 0.010)$\n- 测试 3（体积在上界）：$(1.0,\\ 0.010,\\ 500,\\ 0.002,\\ 0.010)$\n- 测试 4（零载荷边界情况）：$(1.0,\\ 0.003,\\ 0,\\ 0.001,\\ 0.005)$\n\n对于每个测试用例，计算并报告最小化的峰值应力（单位：帕斯卡）。答案以 $\\mathrm{Pa}$ 表示，四舍五入到六位小数。\n\n最终输出格式：你的程序应生成单行输出，其中包含按上述测试套件顺序排列的结果，形式为逗号分隔的列表，并用方括号括起来（例如，“[result1,result2,result3,result4]”）。输出行中不允许有额外的空格或文本。",
            "solution": "我们从一维线弹性杆的总势能出发，该杆具有空间变化的横截面积 $A(x)$ 和杨氏模量 $E$，并在 $x=L$ 处承受端部力 $F$：\n$$\n\\Pi[u] = \\int_0^L \\frac{1}{2} E A(x)\\, (u'(x))^2\\, dx - F\\, u(L),\n$$\n其中 $u(0)=0$ 是一个本质（Dirichlet）边界条件，$u(L)$ 是自由的。对满足 $\\delta u(0)=0$ 的运动学容许变分 $\\delta u$ 取一阶变分，得到\n$$\n\\delta \\Pi[u;\\delta u] = \\int_0^L E A(x)\\, u'(x)\\, \\delta u'(x)\\, dx - F\\, \\delta u(L).\n$$\n分部积分，\n$$\n\\int_0^L E A(x)\\, u'(x)\\, \\delta u'(x)\\, dx = \\left. E A(x)\\, u'(x)\\, \\delta u(x)\\right|_{0}^{L} - \\int_0^L \\frac{d}{dx}\\left(E A(x)\\, u'(x)\\right)\\, \\delta u(x)\\, dx.\n$$\n由于 $\\delta u(0)=0$，在 $x=0$ 处的边界项为零。对于所有容许的 $\\delta u$，平稳性条件 $\\delta \\Pi=0$ 意味着内部平衡方程和自然边界条件：\n$$\n- \\frac{d}{dx}\\left(E A(x)\\, u'(x)\\right) = 0\\quad \\text{for } x\\in(0,L), \\qquad \\left. E A(x)\\, u'(x)\\right|_{x=L} = F.\n$$\n定义轴向力 $N(x) := E A(x)\\, u'(x)$。平衡方程给出\n$$\n\\frac{d}{dx} N(x) = 0 \\quad \\Rightarrow \\quad N(x) \\equiv F \\ \\text{ for all } x\\in[0,L],\n$$\n利用在 $x=L$ 处的自然边界条件。因此，轴向力在空间上是恒定的，且仅由给定的 Neumann 载荷决定。轴向柯西应力为\n$$\n\\sigma(x) = E\\, \\varepsilon(x) = E\\, u'(x) = \\frac{N(x)}{A(x)} = \\frac{F}{A(x)}.\n$$\n因此，对于任何容许的形状 $A(x)$，逐点应力与局部面积成反比，峰值应力为\n$$\n\\sigma_{\\max}[A] := \\max_{x\\in[0,L]} \\sigma(x) = \\max_{x\\in[0,L]} \\frac{F}{A(x)}.\n$$\n\n形状优化问题。设计约束是体积约束和逐点界限：\n$$\n\\int_0^L A(x)\\, dx = V, \\qquad a_{\\min} \\le A(x) \\le a_{\\max} \\ \\text{for all } x\\in[0,L],\n$$\n可行性条件为 $a_{\\min} L \\le V \\le a_{\\max} L$。由于 $F\\ge 0$，最小化峰值应力等价于最小化 $\\max_{x} \\frac{1}{A(x)}$。令 $\\phi(a) = \\frac{1}{a}$，它在 $(0,\\infty)$ 上是严格凸的。对于任意两个正面积 $a_1,a_2$ 和 $\\theta\\in[0,1]$，Jensen 不等式得出\n$$\n\\phi(\\theta a_1 + (1-\\theta) a_2) \\le \\theta \\phi(a_1) + (1-\\theta)\\phi(a_2),\n$$\n当 $a_1\\neq a_2$ 和 $\\theta\\in(0,1)$ 时，不等式为严格不等式。考虑任何容许的 $A(x)$ 并定义其平均值\n$$\n\\bar{A} := \\frac{1}{L} \\int_0^L A(x)\\, dx = \\frac{V}{L}.\n$$\n令 $M := \\operatorname*{ess\\,sup}_{x\\in[0,L]} \\phi(A(x)) = \\max_{x\\in[0,L]} \\frac{1}{A(x)}$。利用 $\\phi$ 是凸函数以及本质上确界是均值的上界这一事实，\n$$\n\\frac{1}{\\bar{A}} = \\phi(\\bar{A}) \\le \\frac{1}{L} \\int_0^L \\phi(A(x))\\, dx \\le \\operatorname*{ess\\,sup}_{x\\in[0,L]} \\phi(A(x)) = M.\n$$\n因此\n$$\n\\min_{A(\\cdot)} \\max_{x} \\frac{1}{A(x)} \\ge \\frac{1}{\\bar{A}}.\n$$\n如果常数设计 $A(x)\\equiv \\bar{A}$ 满足逐点界限，则可以达到这个下界。如果 $a_{\\min} \\le \\bar{A} \\le a_{\\max}$，则均匀设计是容许且最优的，得到\n$$\n\\sigma_{\\max}^{\\star} = F \\cdot \\max_{x} \\frac{1}{A(x)} = \\frac{F}{\\bar{A}} = \\frac{F}{V/L} = \\frac{F L}{V}.\n$$\n如果 $\\bar{A}$ 等于某个界限，则在该界限上的均匀设计是唯一容许的均匀解并且是最优的；如果 $\\bar{A}$ 严格位于 $[a_{\\min},a_{\\max}]$ 之外，则问题是不可行的（违反了体积可行性）。在所述的可行性条件 $a_{\\min} L \\le V \\le a_{\\max} L$ 下，最优解是\n$$\nA^{\\star}(x) \\equiv \\bar{A} = \\frac{V}{L},\n$$\n最小化的峰值应力为\n$$\n\\sigma_{\\max}^{\\star} = \\frac{F}{\\bar{A}} = \\frac{F L}{V}.\n$$\n对于零载荷边界情况 $F=0$，平衡力 $N(x)\\equiv 0$，因此对于任何容许的 $A(x)$ 都有 $\\sigma(x)\\equiv 0$，所以 $\\sigma_{\\max}^{\\star} = 0$。\n\n算法实现。给定 $(L,V,F,a_{\\min},a_{\\max})$：\n- 计算 $\\bar{A} = V/L$。\n- 验证可行性 $a_{\\min} \\le \\bar{A} \\le a_{\\max}$（所提供的测试满足此条件）。\n- 如果 $F=0$，返回 $0$。\n- 否则返回 $\\sigma_{\\max}^{\\star} = F/\\bar{A}$，单位为 $\\mathrm{Pa}$。\n\n数值细节。程序应计算四个测试用例的最小化峰值应力，并按指定顺序将结果打印为单个列表，四舍五入到六位小数。将上述公式应用于所提供的测试套件：\n- 测试 1：$\\bar{A} = \\frac{0.006}{1.2} = 0.005$，所以 $\\sigma_{\\max}^{\\star} = \\frac{10000}{0.005} = 2000000$ $\\mathrm{Pa}$。\n- 测试 2：$\\bar{A} = \\frac{0.004}{2.0} = 0.002$（等于 $a_{\\min}$），所以 $\\sigma_{\\max}^{\\star} = \\frac{8000}{0.002} = 4000000$ $\\mathrm{Pa}$。\n- 测试 3：$\\bar{A} = \\frac{0.010}{1.0} = 0.010$（等于 $a_{\\max}$），所以 $\\sigma_{\\max}^{\\star} = \\frac{500}{0.010} = 50000$ $\\mathrm{Pa}$。\n- 测试 4：$F=0$，所以 $\\sigma_{\\max}^{\\star} = 0$ $\\mathrm{Pa}$。\n\n程序将按要求计算并打印这些值，保留六位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef minimized_peak_stress(L, V, F, a_min, a_max):\n    \"\"\"\n    Compute the minimized peak axial stress for a 1D elastic bar under a fixed end force (Neumann boundary),\n    with volume and pointwise area bounds. Uses the analytical result that the optimal area is uniform\n    A* = V/L (assuming feasibility), and sigma_max* = F / (V/L) = F*L/V. Handles F=0 edge case.\n\n    Parameters:\n        L (float): Length of the bar [m]\n        V (float): Total volume [m^3]\n        F (float): Applied end force [N]\n        a_min (float): Minimum allowable cross-sectional area [m^2]\n        a_max (float): Maximum allowable cross-sectional area [m^2]\n\n    Returns:\n        float: Minimized peak stress [Pa]\n    \"\"\"\n    # Average area implied by volume constraint\n    A_avg = V / L\n\n    # Feasibility check: if infeasible, raise an error as per problem specification assumptions\n    if not (a_min - 1e-14 = A_avg = a_max + 1e-14):\n        raise ValueError(\"Infeasible test case: volume not within [a_min*L, a_max*L].\")\n\n    # If force is zero, stress is zero everywhere\n    if abs(F) == 0.0:\n        return 0.0\n\n    # Optimal peak stress for feasible cases with Neumann load:\n    # sigma_max* = F / A_avg\n    sigma_max = F / A_avg\n    return sigma_max\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each tuple is (L [m], V [m^3], F [N], a_min [m^2], a_max [m^2])\n    test_cases = [\n        (1.2, 0.006, 10000.0, 0.003, 0.006),  # Test 1: general feasible case\n        (2.0, 0.004, 8000.0, 0.002, 0.010),   # Test 2: volume at lower bound\n        (1.0, 0.010, 500.0, 0.002, 0.010),    # Test 3: volume at upper bound\n        (1.0, 0.003, 0.0, 0.001, 0.005),      # Test 4: zero load edge case\n    ]\n\n    results = []\n    for case in test_cases:\n        L, V, F, a_min, a_max = case\n        sigma_star = minimized_peak_stress(L, V, F, a_min, a_max)\n        results.append(f\"{sigma_star:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "现在我们进入二维空间，探讨一个对于数值精度至关重要的概念。本练习将研究在尖锐的几何角点处，边界条件的选择（本质的、自然的或混合的）如何显著影响解的光滑性。通过分析拉普拉斯方程在楔形域中的解，你将学会预测奇点（即梯度无穷大的点）的形成，这对于建立可靠的有限元模型至关重要。",
            "id": "2389711",
            "problem": "考虑极坐标下的平面楔形域 $\\Omega_{\\alpha} = \\{(r,\\theta)\\,:\\, 0  r  1,\\; 0  \\theta  \\alpha\\}$，其中 $\\alpha \\in (0,2\\pi)$。令 $u(r,\\theta)$ 在 $\\Omega_{\\alpha}$ 中解拉普拉斯方程 $\\Delta u = 0$，其中 $\\Delta$ 表示二维拉普拉斯算子。该楔形的两条直边是射线 $\\theta = 0$ 和 $\\theta = \\alpha$。在每条边上，施加本质（狄利克雷）边界条件 $u=0$ 或自然（诺伊曼）边界条件 $\\partial u / \\partial n = 0$，其中 $n$ 表示边界上的外单位法向量。\n\n对于每种配置，将角点奇性指数 $\\lambda_{\\min}(\\alpha,\\text{BC})$ 定义为最小的正实数 $\\lambda > 0$，使得在 $\\Omega_{\\alpha}$ 中存在一个满足指定边界条件的非平凡调和解，并且当 $r \\to 0^{+}$ 时，其主阶角点行为的阶数为 $r^{\\lambda}$。利用此指数判断梯度模长 $\\|\\nabla u\\|$ 在角点处（当 $r \\to 0^{+}$ 时）是否无界。使用以下指标对奇性进行分类：\n- 如果 $\\lambda_{\\min}(\\alpha,\\text{BC})  1$，则 $\\text{is\\_singular} = \\text{True}$，否则为 $\\text{False}$，\n并通过指数来量化梯度的发散率：\n- $b = \\max(0, 1 - \\lambda_{\\min}(\\alpha,\\text{BC}))$，其意义是当 $b > 0$ 时，存在某个常数 $C \\neq 0$，使得 $\\|\\nabla u\\|$ 在 $r \\to 0^{+}$ 时的行为类似于 $C\\, r^{-b}$。\n\n你的任务是编写一个完整的、可运行的程序，对于下面指定的每个测试案例，计算并返回三元组 $[\\lambda_{\\min}, \\text{is\\_singular}, b]$。\n\n测试套件（角度以弧度为单位）：\n- 案例 1：$\\alpha = \\dfrac{3\\pi}{2}$，在 $\\theta=0$ 和 $\\theta=\\alpha$ 上的边界条件为 $\\text{狄利克雷}/\\text{狄利克雷}$。\n- 案例 2：$\\alpha = \\dfrac{3\\pi}{2}$，在 $\\theta=0$ 和 $\\theta=\\alpha$ 上的边界条件为 $\\text{诺伊曼}/\\text{诺伊曼}$。\n- 案例 3：$\\alpha = \\dfrac{3\\pi}{2}$，在 $\\theta=0$ 和 $\\theta=\\alpha$ 上的边界条件为 $\\text{狄利克雷}/\\text{诺伊曼}$。\n- 案例 4：$\\alpha = \\pi$，在 $\\theta=0$ 和 $\\theta=\\alpha$ 上的边界条件为 $\\text{狄利克雷}/\\text{狄利克雷}$。\n- 案例 5：$\\alpha = \\dfrac{3\\pi}{4}$，在 $\\theta=0$ 和 $\\theta=\\alpha$ 上的边界条件为 $\\text{狄利克雷}/\\text{狄利克雷}$。\n- 案例 6：$\\alpha = \\dfrac{7\\pi}{4}$，在 $\\theta=0$ 和 $\\theta=\\alpha$ 上的边界条件为 $\\text{狄利克雷}/\\text{诺伊曼}$。\n- 案例 7：$\\alpha = \\dfrac{4\\pi}{3}$，在 $\\theta=0$ 和 $\\theta=\\alpha$ 上的边界条件为 $\\text{诺伊曼}/\\text{诺伊曼}$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表项的顺序与上述案例的顺序相同。\n- 每个案例的结果本身必须是一个形如 $[\\lambda_{\\min}, \\text{is\\_singular}, b]$ 的列表，其中 $\\lambda_{\\min}$ 和 $b$ 是浮点数，$\\text{is\\_singular}$ 是布尔值。\n- 具体来说，输出必须形如 $[[\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot],\\ldots]$，列表前后不应有任何额外文本。",
            "solution": "所提出的问题是有效的、有科学依据的且是适定的。它涉及椭圆偏微分方程理论中的一个经典课题——解在区域角点附近的正则性。这种分析在计算工程学中对于设计精确的数值方法（如有限元方法）至关重要，特别是在自适应网格加密的背景下。\n\n控制方程是二维拉普拉斯方程 $\\Delta u = 0$。在极坐标 $(r, \\theta)$ 中，该方程为：\n$$\n\\Delta u = \\frac{\\partial^2 u}{\\partial r^2} + \\frac{1}{r} \\frac{\\partial u}{\\partial r} + \\frac{1}{r^2} \\frac{\\partial^2 u}{\\partial \\theta^2} = 0\n$$\n我们在楔形域 $\\Omega_{\\alpha} = \\{(r,\\theta)\\,:\\, 0  r  1,\\; 0  \\theta  \\alpha\\}$ 中寻求解。为了分析解在 $r=0$ 角点附近的行为，我们采用分离变量法。我们寻找形如 $u(r,\\theta) = R(r)\\Theta(\\theta)$ 的非平凡解。将此形式代入拉普拉斯方程并整理各项可得：\n$$\n\\frac{r^2 R''(r) + r R'(r)}{R(r)} = - \\frac{\\Theta''(\\theta)}{\\Theta(\\theta)}\n$$\n由于左侧仅依赖于 $r$，右侧仅依赖于 $\\theta$，因此两边都必须等于一个分离常数，我们记为 $\\mu$。这给出了两个常微分方程：\n$$\n\\Theta''(\\theta) + \\mu \\Theta(\\theta) = 0\n$$\n$$\nr^2 R''(r) + r R'(r) - \\mu R(r) = 0\n$$\n对于角向部分，为了得到满足齐次边界条件的非平凡解，我们需要振荡行为，这要求常数是正的。我们设 $\\mu = \\lambda^2$，其中 $\\lambda > 0$。角向方程变为 $\\Theta''(\\theta) + \\lambda^2 \\Theta(\\theta) = 0$，其通解为：\n$$\n\\Theta(\\theta) = A \\cos(\\lambda\\theta) + B \\sin(\\lambda\\theta)\n$$\n径向方程是一个柯西-欧拉方程，$r^2 R'' + r R' - \\lambda^2 R = 0$，其通解为 $R(r) = c_1 r^{\\lambda} + c_2 r^{-\\lambda}$。我们研究的是当 $r \\to 0^{+}$ 时具有 $r^{\\lambda}$（其中 $\\lambda$ 为正）形式的解，因此我们关注 $r^{\\lambda}$ 项。\n\n系数 $A$、$B$ 以及 $\\lambda$ 的允许值由直边 $\\theta=0$ 和 $\\theta=\\alpha$ 上的边界条件确定。问题指定了本质（狄利克雷）或自然（诺伊曼）条件。\n- 在射线 $\\theta = \\theta_0$ 上的狄利克雷条件 $u=0$ 意味着 $\\Theta(\\theta_0) = 0$。\n- 在射线 $\\theta = \\theta_0$ 上的诺伊曼条件 $\\partial u / \\partial n = 0$ 需要仔细解释。外单位法向量 $\\vec{n}$ 与射线正交。在极坐标中，这意味着 $\\vec{n}$ 在 $\\pm \\hat{e}_{\\theta}$ 方向。梯度为 $\\nabla u = \\frac{\\partial u}{\\partial r}\\hat{e}_r + \\frac{1}{r}\\frac{\\partial u}{\\partial \\theta}\\hat{e}_{\\theta}$。因此，法向导数为 $\\frac{\\partial u}{\\partial n} = \\nabla u \\cdot \\vec{n} = \\pm \\frac{1}{r}\\frac{\\partial u}{\\partial \\theta}$。因此，条件 $\\partial u / \\partial n = 0$ 等价于在该射线上 $\\frac{\\partial u}{\\partial \\theta} = 0$，这意味着 $\\Theta'(\\theta_0) = 0$。\n\n我们分析四种边界条件配置：\n\n1.  **狄利克雷/狄利克雷 (DD)**：在 $\\theta=0$ 和 $\\theta=\\alpha$ 上 $u=0$。\n    - $\\Theta(0) = 0 \\implies A\\cos(0) + B\\sin(0) = A = 0$。\n    - 解变为 $\\Theta(\\theta) = B\\sin(\\lambda\\theta)$。\n    - $\\Theta(\\alpha) = 0 \\implies B\\sin(\\lambda\\alpha) = 0$。对于非平凡解（$B \\neq 0$），需要 $\\sin(\\lambda\\alpha) = 0$。\n    - 这给出 $\\lambda\\alpha = k\\pi$，其中 $k \\in \\{1, 2, 3, \\ldots\\}$。最小正指数对应于 $k=1$，因此 $\\lambda_{\\min} = \\dfrac{\\pi}{\\alpha}$。\n\n2.  **诺伊曼/诺伊曼 (NN)**：在 $\\theta=0$ 和 $\\theta=\\alpha$ 上 $\\partial u/\\partial n=0$。\n    - $\\Theta'(0) = 0 \\implies \\lambda(-A\\sin(0) + B\\cos(0)) = \\lambda B = 0$。由于 $\\lambda > 0$，我们有 $B=0$。\n    - 解变为 $\\Theta(\\theta) = A\\cos(\\lambda\\theta)$。\n    - $\\Theta'(\\alpha) = 0 \\implies -\\lambda A\\sin(\\lambda\\alpha) = 0$。对于非平凡解（$A \\neq 0, \\lambda \\neq 0$），需要 $\\sin(\\lambda\\alpha) = 0$。\n    - 这同样给出 $\\lambda\\alpha = k\\pi$，最小正指数为 $\\lambda_{\\min} = \\dfrac{\\pi}{\\alpha}$（对于 $k=1$；$k=0$ 给出 $\\lambda=0$，对应于常数解，这被 $\\lambda > 0$ 的要求排除）。\n\n3.  **狄利克雷/诺伊曼 (DN)**：在 $\\theta=0$ 上 $u=0$，在 $\\theta=\\alpha$ 上 $\\partial u/\\partial n=0$。\n    - $\\Theta(0) = 0 \\implies A=0$。解为 $\\Theta(\\theta) = B\\sin(\\lambda\\theta)$。\n    - $\\Theta'(\\alpha) = 0 \\implies \\lambda B\\cos(\\lambda\\alpha) = 0$。对于非平凡解，$\\cos(\\lambda\\alpha) = 0$。\n    - 这给出 $\\lambda\\alpha = (k + \\frac{1}{2})\\pi$，其中 $k \\in \\{0, 1, 2, \\ldots\\}$。最小正指数对应于 $k=0$，因此 $\\lambda_{\\min} = \\dfrac{\\pi}{2\\alpha}$。\n\n4.  **诺伊曼/狄利克雷 (ND)**：在 $\\theta=0$ 上 $\\partial u/\\partial n=0$，在 $\\theta=\\alpha$ 上 $u=0$。\n    - $\\Theta'(0) = 0 \\implies B=0$。解为 $\\Theta(\\theta) = A\\cos(\\lambda\\theta)$。\n    - $\\Theta(\\alpha) = 0 \\implies A\\cos(\\lambda\\alpha) = 0$。对于非平凡解，$\\cos(\\lambda\\alpha) = 0$。\n    - 这同样给出 $\\lambda\\alpha = (k + \\frac{1}{2})\\pi$，最小正指数为 $\\lambda_{\\min} = \\dfrac{\\pi}{2\\alpha}$。\n\n解在角点附近的主阶行为是 $u \\sim C r^{\\lambda_{\\min}} \\Theta_{\\min}(\\theta)$。梯度的模长是 $\\|\\nabla u\\| = \\sqrt{(\\partial u/\\partial r)^2 + (r^{-1}\\partial u/\\partial \\theta)^2}$。梯度中的各项行为类似于 $r^{\\lambda_{\\min}-1}$。因此，当 $r \\to 0^{+}$ 时，$\\|\\nabla u\\| \\sim C' r^{\\lambda_{\\min}-1}$。\n\n如果指数 $\\lambda_{\\min}-1$ 为负，即 $\\lambda_{\\min}  1$，则梯度变得无界。这证明了奇性指标定义的合理性：$\\text{is\\_singular} = (\\lambda_{\\min}  1)$。\n如果存在奇性，发散率由指数 $b = -(\\lambda_{\\min}-1) = 1-\\lambda_{\\min}$ 来表征。如果梯度有界（$\\lambda_{\\min} \\ge 1$），则没有发散，所以指数为 $0$。这对应于给定的定义：$b = \\max(0, 1 - \\lambda_{\\min})$。\n\n算法是根据角 $\\alpha$ 和边界条件类型计算 $\\lambda_{\\min}$，然后用它来求出 $\\text{is\\_singular}$ 和 $b$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the corner singularity exponent, singularity presence, and\n    gradient blow-up rate for the Laplace equation in a wedge domain.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple (angle_alpha_in_radians, boundary_condition_type).\n    test_cases = [\n        (3 * np.pi / 2, \"DD\"),  # Case 1: Dirichlet/Dirichlet\n        (3 * np.pi / 2, \"NN\"),  # Case 2: Neumann/Neumann\n        (3 * np.pi / 2, \"DN\"),  # Case 3: Dirichlet/Neumann\n        (np.pi,         \"DD\"),  # Case 4: Dirichlet/Dirichlet\n        (3 * np.pi / 4, \"DD\"),  # Case 5: Dirichlet/Dirichlet\n        (7 * np.pi / 4, \"DN\"),  # Case 6: Dirichlet/Neumann\n        (4 * np.pi / 3, \"NN\"),  # Case 7: Neumann/Neumann\n    ]\n\n    results = []\n    for alpha, bc_type in test_cases:\n        # Calculate the smallest positive singularity exponent lambda_min.\n        # The formulas are derived from separation of variables.\n        if bc_type == \"DD\" or bc_type == \"NN\":\n            # For Dirichlet/Dirichlet or Neumann/Neumann conditions.\n            lambda_min = np.pi / alpha\n        elif bc_type == \"DN\" or bc_type == \"ND\":\n            # For mixed Dirichlet/Neumann conditions.\n            lambda_min = np.pi / (2 * alpha)\n        else:\n            # This case should not be reached with the given test suite.\n            raise ValueError(f\"Unknown boundary condition type: {bc_type}\")\n\n        # The gradient of the solution behaves like r^(lambda_min - 1).\n        # A singularity in the gradient exists if lambda_min  1.\n        is_singular = lambda_min  1\n\n        # The blow-up rate exponent b is defined as max(0, 1 - lambda_min).\n        # It is positive only when the gradient is singular.\n        b = max(0.0, 1.0 - lambda_min)\n\n        # Append the calculated triple to the results list.\n        results.append([lambda_min, is_singular, b])\n\n    # Format the results into the specified string format.\n    # Example: [[val1,True,val2],[val3,False,val4]]\n    result_strings = []\n    for res in results:\n        # str() provides sufficient precision for floats and correct 'True'/'False' for booleans.\n        lambda_str = str(res[0])\n        singular_str = str(res[1])\n        b_str = str(res[2])\n        result_strings.append(f\"[{lambda_str},{singular_str},{b_str}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(result_strings)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "我们最后的实践将处理一个计算模拟中的常见问题：如何在弯曲的几何体上精确施加载荷。当光滑的曲线边界被一系列直线段（这是有限元网格划分的标准做法）近似时，会产生误差，我们将量化这一误差。这个练习让你具体理解几何近似误差如何影响自然(Neumann)边界条件（如压力或热通量）的实施。",
            "id": "2389726",
            "problem": "考虑在二阶椭圆型偏微分方程的弱形式下，在二维空间的光滑弯曲边界上施加诺伊曼（Neumann）边界条件。在弱形式中，诺伊曼（自然）边界条件贡献了一个形式为 $\\int_{\\Gamma} g(\\mathbf{x})\\, v\\, \\mathrm{d}s$ 的边界积分，其中 $g(\\mathbf{x})$ 是给定的法向通量，$v$ 是一个检验函数。为分离几何近似对诺伊曼边界条件的影响，令 $v \\equiv 1$，从而关注的量简化为标量边界载荷 $\\int_{\\Gamma} g(\\mathbf{x})\\, \\mathrm{d}s$。\n\n设真实的边界段是一个半径为 $R  0$ 的圆上的一段圆弧，由极角 $\\theta \\in [\\theta_a, \\theta_b]$ 参数化，其中 $\\theta_b > \\theta_a$。角度必须以弧度表示。设圆上角度为 $\\theta$ 的点为 $\\mathbf{x}(\\theta) = (R \\cos \\theta, R \\sin \\theta)$。设给定的诺伊曼通量是一个在笛卡尔坐标中为仿射的光滑函数，即\n$$\ng(\\mathbf{x}) = q_0 + q_1 x + q_2 y,\n$$\n其中常数 $q_0, q_1, q_2 \\in \\mathbb{R}$。\n\n定义精确边界载荷为\n$$\nI_{\\text{exact}} = \\int_{\\theta_a}^{\\theta_b} \\left(q_0 + q_1 R \\cos \\theta + q_2 R \\sin \\theta\\right) R\\, \\mathrm{d}\\theta.\n$$\n\n现在，用一条具有 $N \\in \\mathbb{N}$ 条直边的折线来近似该圆弧，该折线通过连接点 $\\mathbf{x}(\\theta_i)$（$i=0,1,\\dots,N$）构成，其中 $\\theta_i = \\theta_a + i h$ 且 $h = (\\theta_b - \\theta_a)/N$。设第 $i$ 条边是从 $\\mathbf{x}(\\theta_i)$ 到 $\\mathbf{x}(\\theta_{i+1})$ 的直线段。相应的近似边界载荷定义为沿每条直边对 $g$ 进行积分并求和，即\n$$\nI_{\\text{approx}} = \\sum_{i=0}^{N-1} \\int_{0}^{1} g\\!\\left((1-t)\\,\\mathbf{x}(\\theta_i) + t\\,\\mathbf{x}(\\theta_{i+1})\\right)\\, \\left\\|\\mathbf{x}(\\theta_{i+1}) - \\mathbf{x}(\\theta_i)\\right\\|\\, \\mathrm{d}t,\n$$\n其中 $\\|\\cdot\\|$ 表示欧几里得范数。\n\n对于下面测试套件中的每种情况，计算绝对误差 $E_{\\text{abs}} = |I_{\\text{approx}} - I_{\\text{exact}}|$ 和相对误差\n$$\nE_{\\text{rel}} = \\frac{E_{\\text{abs}}}{\\max\\!\\left(|I_{\\text{exact}}|, 10^{-12}\\right)}.\n$$\n每种测试情况仅报告相对误差 $E_{\\text{rel}}$。这些量是无量纲的。\n\n测试套件（角度以弧度为单位）：\n- 情况 1：$R = 1$, $\\theta_a = 0$, $\\theta_b = \\tfrac{\\pi}{2}$, $q_0 = 1$, $q_1 = 0$, $q_2 = 0$, $N = 4$。\n- 情况 2：$R = 1$, $\\theta_a = 0$, $\\theta_b = \\pi$, $q_0 = 1$, $q_1 = 0$, $q_2 = 0$, $N = 6$。\n- 情况 3：$R = 2$, $\\theta_a = 0$, $\\theta_b = \\tfrac{\\pi}{6}$, $q_0 = 1$, $q_1 = 0$, $q_2 = 0$, $N = 1$。\n- 情况 4：$R = 1.5$, $\\theta_a = \\tfrac{\\pi}{4}$, $\\theta_b = \\tfrac{3\\pi}{4}$, $q_0 = 0$, $q_1 = 0.5$, $q_2 = -0.25$, $N = 8$。\n- 情况 5：$R = 1$, $\\theta_a = 0$, $\\theta_b = 2\\pi$, $q_0 = 0.75$, $q_1 = 0.2$, $q_2 = -0.1$, $N = 32$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含情况 1 到 5 的相对误差，以逗号分隔的列表形式并用方括号括起来，例如 $[e_1,e_2,e_3,e_4,e_5]$，其中每个 $e_i$ 是情况 $i$ 的 $E_{\\text{rel}}$ 的浮点值。",
            "solution": "根据指定标准对问题进行验证。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n\n- **物理系统**：二维二阶椭圆型偏微分方程。\n- **边界条件**：光滑弯曲边界 $\\Gamma$ 上的诺伊曼（自然）边界条件。\n- **边界积分**：来自诺伊曼条件的贡献为 $\\int_{\\Gamma} g(\\mathbf{x})\\, v\\, \\mathrm{d}s$。\n- **关注的量**：通过设置检验函数 $v \\equiv 1$ 得到的标量边界载荷为 $I = \\int_{\\Gamma} g(\\mathbf{x})\\, \\mathrm{d}s$。\n- **边界几何**：真实边界 $\\Gamma$ 是一个半径为 $R > 0$ 的圆弧，由极角 $\\theta \\in [\\theta_a, \\theta_b]$ 参数化。圆弧上的点为 $\\mathbf{x}(\\theta) = (R \\cos \\theta, R \\sin \\theta)$。\n- **给定通量**：通量是一个仿射函数 $g(\\mathbf{x}) = q_0 + q_1 x + q_2 y$，其中 $q_0, q_1, q_2$ 是常数。\n- **精确边界载荷**：$I_{\\text{exact}} = \\int_{\\theta_a}^{\\theta_b} \\left(q_0 + q_1 R \\cos \\theta + q_2 R \\sin \\theta\\right) R\\, \\mathrm{d}\\theta$。\n- **近似边界**：由 $N$ 条直边组成的折线，连接点 $\\mathbf{x}(\\theta_i)$（$i=0, \\dots, N$），其中 $\\theta_i = \\theta_a + i h$ 且 $h = (\\theta_b - \\theta_a)/N$。\n- **近似边界载荷**：$I_{\\text{approx}} = \\sum_{i=0}^{N-1} \\int_{0}^{1} g\\!\\left((1-t)\\,\\mathbf{x}(\\theta_i) + t\\,\\mathbf{x}(\\theta_{i+1})\\right)\\, \\left\\|\\mathbf{x}(\\theta_{i+1}) - \\mathbf{x}(\\theta_i)\\right\\|\\, \\mathrm{d}t$。\n- **误差度量**：\n  - 绝对误差：$E_{\\text{abs}} = |I_{\\text{approx}} - I_{\\text{exact}}|$。\n  - 相对误差：$E_{\\text{rel}} = E_{\\text{abs}} / \\max(|I_{\\text{exact}}|, 10^{-12})$。\n- **测试用例**：提供了五组参数 $(R, \\theta_a, \\theta_b, q_0, q_1, q_2, N)$。\n\n**步骤 2：使用提取的已知条件进行验证**\n\n- **科学基础**：该问题在有限元法（FEM）理论中有充分的依据，特别是关于诺伊曼边界条件的处理以及由边界离散化引起的几何误差。该公式是计算工程中的标准形式。\n- **适定性**：所有公式都有明确定义，并且为每个测试用例提供了所有参数。这确保了可以为每种情况计算出唯一的数值解。\n- **客观性**：问题使用精确的数学语言陈述，没有主观或模糊的术语。\n\n该问题不违反任何指定的无效条件。它在科学上是合理的、完全指定的、客观的，并且与所述主题直接相关。\n\n**步骤 3：结论与行动**\n\n问题是**有效的**。将制定解决方案。\n\n### 解的推导\n\n任务是计算精确和近似边界载荷积分之间的相对误差。这需要为这两个量推导出可计算的表达式。\n\n**1. 精确边界载荷, $I_{\\text{exact}}$**\n\n精确边界载荷由关于角度 $\\theta$ 的定积分定义：\n$$\nI_{\\text{exact}} = \\int_{\\theta_a}^{\\theta_b} (q_0 + q_1 R \\cos \\theta + q_2 R \\sin \\theta) R\\, \\mathrm{d}\\theta\n$$\n积分是逐项对 $\\theta$ 进行的：\n$$\nI_{\\text{exact}} = R \\left[ \\int_{\\theta_a}^{\\theta_b} q_0 \\, \\mathrm{d}\\theta + q_1 R \\int_{\\theta_a}^{\\theta_b} \\cos \\theta \\, \\mathrm{d}\\theta + q_2 R \\int_{\\theta_a}^{\\theta_b} \\sin \\theta \\, \\mathrm{d}\\theta \\right]\n$$\n计算基本积分得出：\n$$\nI_{\\text{exact}} = R \\left[ q_0 \\theta + q_1 R \\sin \\theta - q_2 R \\cos \\theta \\right]_{\\theta_a}^{\\theta_b}\n$$\n应用微积分基本定理给出最终的解析表达式：\n$$\nI_{\\text{exact}} = R \\left( q_0(\\theta_b - \\theta_a) + q_1 R(\\sin \\theta_b - \\sin \\theta_a) - q_2 R(\\cos \\theta_b - \\cos \\theta_a) \\right)\n$$\n\n**2. 近似边界载荷, $I_{\\text{approx}}$**\n\n近似边界载荷通过对 $N$ 个直线段上的积分求和来计算。考虑从 $\\mathbf{x}_i \\equiv \\mathbf{x}(\\theta_i)$ 到 $\\mathbf{x}_{i+1} \\equiv \\mathbf{x}(\\theta_{i+1})$ 的第 $i$ 个线段。由于均匀的角步长 $h = \\theta_{i+1} - \\theta_i$，该线段的长度 $L_i = \\|\\mathbf{x}_{i+1} - \\mathbf{x}_i\\|$ 对所有线段都是恒定的。\n$$\nL_i^2 = (R\\cos\\theta_{i+1} - R\\cos\\theta_i)^2 + (R\\sin\\theta_{i+1} - R\\sin\\theta_i)^2\n$$\n$$\nL_i^2 = R^2 \\left( 2 - 2(\\cos\\theta_{i+1}\\cos\\theta_i + \\sin\\theta_{i+1}\\sin\\theta_i) \\right) = 2R^2(1 - \\cos(\\theta_{i+1} - \\theta_i)) = 2R^2(1 - \\cos h)\n$$\n使用半角恒等式 $1 - \\cos h = 2\\sin^2(h/2)$，长度为：\n$$\nL_h = \\sqrt{4R^2\\sin^2(h/2)} = 2R\\sin(h/2)\n$$\n（因为 $h \\ge 0$ 且通常很小，所以 $\\sin(h/2) \\ge 0$）。\n\n第 $i$ 个线段上的积分为 $I_i = L_h \\int_{0}^{1} g((1-t)\\mathbf{x}_i + t\\mathbf{x}_{i+1}) \\mathrm{d}t$。\n通量函数 $g(\\mathbf{x}) = q_0 + q_1 x + q_2 y$ 在笛卡尔坐标 $(x,y)$ 中是仿射的。线段的参数化 $\\mathbf{p}(t) = (1-t)\\mathbf{x}_i + t\\mathbf{x}_{i+1}$ 是关于 $t$ 线性的。因此，复合函数 $g(\\mathbf{p}(t))$ 是关于 $t$ 线性的。\n$$\ng(\\mathbf{p}(t)) = g(\\mathbf{x}_i) + t(g(\\mathbf{x}_{i+1}) - g(\\mathbf{x}_i))\n$$\n这个线性函数在 $t \\in [0,1]$ 上的积分就是其在端点的平均值：\n$$\n\\int_{0}^{1} g(\\mathbf{p}(t)) \\mathrm{d}t = \\left[ g(\\mathbf{x}_i)t + \\frac{t^2}{2}(g(\\mathbf{x}_{i+1}) - g(\\mathbf{x}_i)) \\right]_0^1 = g(\\mathbf{x}_i) + \\frac{1}{2}(g(\\mathbf{x}_{i+1}) - g(\\mathbf{x}_i)) = \\frac{g(\\mathbf{x}_i) + g(\\mathbf{x}_{i+1})}{2}\n$$\n这是梯形法则，对于线性被积函数是精确的。因此，第 $i$ 个线段的贡献是：\n$$\nI_i = L_h \\frac{g(\\mathbf{x}_i) + g(\\mathbf{x}_{i+1})}{2}\n$$\n总的近似载荷是所有 $N$ 个线段的总和：\n$$\nI_{\\text{approx}} = \\sum_{i=0}^{N-1} I_i = \\sum_{i=0}^{N-1} L_h \\frac{g(\\mathbf{x}(\\theta_i)) + g(\\mathbf{x}(\\theta_{i+1}))}{2}\n$$\n其中 $\\theta_i = \\theta_a + i h$ 且 $h = (\\theta_b - \\theta_a)/N$。函数值计算为 $g(\\mathbf{x}(\\theta)) = q_0 + q_1 R \\cos \\theta + q_2 R \\sin \\theta$。\n\n**3. 误差计算**\n\n在建立了 $I_{\\text{exact}}$ 和 $I_{\\text{approx}}$ 的公式后，误差直接根据其定义计算：\n- 绝对误差：$E_{\\text{abs}} = |I_{\\text{approx}} - I_{\\text{exact}}|$\n- 相对误差：$E_{\\text{rel}} = \\frac{E_{\\text{abs}}}{\\max(|I_{\\text{exact}}|, 10^{-12})}$\n\n**4. 计算算法**\n\n对于每个具有参数 $(R, \\theta_a, \\theta_b, q_0, q_1, q_2, N)$ 的测试用例：\n1.  使用其闭式解析表达式计算 $I_{\\text{exact}}$。\n2.  计算角步长 $h = (\\theta_b - \\theta_a)/N$。\n3.  计算线段长度 $L_h = 2R\\sin(h/2)$。\n4.  初始化 $I_{\\text{approx}} = 0$。\n5.  对 $i$ 从 $0$ 到 $N-1$ 进行循环：\n    a. 确定角度 $\\theta_i = \\theta_a + i h$ 和 $\\theta_{i+1} = \\theta_a + (i+1)h$。\n    b. 计算通量值 $g_i = q_0 + q_1 R \\cos(\\theta_i) + q_2 R \\sin(\\theta_i)$ 和 $g_{i+1} = q_0 + q_1 R \\cos(\\theta_{i+1}) + q_2 R \\sin(\\theta_{i+1})$。\n    c. 将线段贡献 $L_h (g_i + g_{i+1}) / 2$ 加到 $I_{\\text{approx}}$。\n6.  计算绝对误差 $E_{\\text{abs}}$ 和相对误差 $E_{\\text{rel}}$。\n7.  该情况的最终结果是 $E_{\\text{rel}}$。\n\n此算法将被实现以解决所提供的测试套件。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for all test cases and prints the results.\n    \"\"\"\n    test_cases = [\n        # (R, theta_a, theta_b, q0, q1, q2, N)\n        (1.0, 0.0, np.pi / 2.0, 1.0, 0.0, 0.0, 4),\n        (1.0, 0.0, np.pi, 1.0, 0.0, 0.0, 6),\n        (2.0, 0.0, np.pi / 6.0, 1.0, 0.0, 0.0, 1),\n        (1.5, np.pi / 4.0, 3.0 * np.pi / 4.0, 0.0, 0.5, -0.25, 8),\n        (1.0, 0.0, 2.0 * np.pi, 0.75, 0.2, -0.1, 32),\n    ]\n\n    results = [calculate_relative_error(case) for case in test_cases]\n    \n    # Format the final output as a comma-separated list in brackets.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calculate_relative_error(case):\n    \"\"\"\n    Calculates the relative error for a single test case.\n\n    Args:\n        case (tuple): A tuple containing the parameters (R, theta_a, theta_b, q0, q1, q2, N).\n\n    Returns:\n        float: The computed relative error E_rel.\n    \"\"\"\n    R, theta_a, theta_b, q0, q1, q2, N = case\n\n    # 1. Calculate the exact boundary load I_exact\n    # I_exact = R * [q0*theta + q1*R*sin(theta) - q2*R*cos(theta)] from theta_a to theta_b\n    term_q0 = q0 * (theta_b - theta_a)\n    term_q1 = q1 * R * (np.sin(theta_b) - np.sin(theta_a))\n    term_q2 = -q2 * R * (np.cos(theta_b) - np.cos(theta_a))\n    I_exact = R * (term_q0 + term_q1 + term_q2)\n\n    # 2. Calculate the approximate boundary load I_approx\n    h = (theta_b - theta_a) / N\n    # Length of a single polyline segment\n    # L_h = 2 * R * sin(h/2)\n    L_h = 2.0 * R * np.sin(h / 2.0)\n\n    # Flux function g(theta)\n    def g_func(theta):\n        return q0 + q1 * R * np.cos(theta) + q2 * R * np.sin(theta)\n\n    # Sum contributions from all segments\n    I_approx = 0.0\n    for i in range(N):\n        theta_i = theta_a + i * h\n        theta_i_plus_1 = theta_a + (i + 1) * h\n        \n        g_i = g_func(theta_i)\n        g_i_plus_1 = g_func(theta_i_plus_1)\n        \n        # Integral over the i-th segment\n        segment_integral = L_h * (g_i + g_i_plus_1) / 2.0\n        I_approx += segment_integral\n\n    # 3. Calculate absolute and relative errors\n    E_abs = np.abs(I_approx - I_exact)\n    # Use max(|I_exact|, 1e-12) to prevent division by zero\n    denominator = np.maximum(np.abs(I_exact), 1e-12)\n    E_rel = E_abs / denominator\n    \n    return E_rel\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}