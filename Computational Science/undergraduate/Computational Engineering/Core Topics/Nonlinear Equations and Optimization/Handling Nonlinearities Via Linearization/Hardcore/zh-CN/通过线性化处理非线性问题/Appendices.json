{
    "hands_on_practices": [
        {
            "introduction": "处理非线性的最基本方法是将其局部近似为线性问题。这个练习将这一原理置于一个引人入胜的密码学场景中：通过旁路攻击破解一个简化的RSA加密密钥。通过应用牛顿法，即利用线性近似来迭代求解非线性方程，你将能够解决一个关键的非线性方程，从而找出构成模数$N$的素数因子$p$。这项实践不仅巩固了牛顿法的应用，还展示了线性化思想在解决实际工程挑战中的力量。",
            "id": "2398877",
            "problem": "一个公钥密码系统使用由 $N = p\\,q$ 定义的 Rivest–Shamir–Adleman (RSA) 模数，其中 $p$ 和 $q$ 是未知素数，且 $p \\le q$。一次侧信道测量揭示了素数因子之间的一个非线性代数约束：平方和 $p^2 + q^2$ 等于一个泄露值 $L$。您的任务是通过求解一个由定义推导出的单变量非线性方程来计算 $p$，并实现一个牛顿线性化过程来找到其根。\n\n基本原理：\n- 根据模数的定义，$N = p\\,q$。\n- 泄露信息提供了 $p^2 + q^2 = L$。\n- 目标是消去 $q$，使用牛顿法（一阶泰勒线性化）求解一个标量非线性方程，以得到 $p$ 的正根。更新基于标量函数对标量迭代值的导数。\n\n算法要求：\n- 使用 $N$ 的定义消去 $q$，以获得一个与泄露信息 $p^2 + q^2 = L$ 一致的、关于未知数 $p$ 的单变量方程。\n- 定义一个连续可微的标量函数 $f(x)$，使得真实的 $p$ 是 $f(x) = 0$ 的一个单根。\n- 从第一性原理（基础微积分）推导出精确的导数 $f'(x)$，以支持牛顿法。\n- 实现牛顿法，迭代公式为 $x_{\\text{new}} = x - f(x)/f'(x)$。\n- 使用一个严格为正的初始猜测值 $x_0$，其值等于 $\\sqrt{N}$。\n- 强制迭代值为正，并根据 $x$ 的变化或 $f$ 的残差（任选其一）提供一个合理的停止规则。使用有限的最大迭代次数来保证终止。\n- 收敛后，仅在最后一步通过四舍五入将数值根映射为整数因子，并返回较小的素数因子。如果牛顿法的估计值更接近 $q$，则使用关系式 $q = N/p$ 来返回较小的素数 $p$。\n\n测试套件：\n您的程序必须解决以下四个独立的实例。对于每个实例，输入是一对 $(N, L)$，要求输出是较小的素数因子 $p$（整数形式）。\n\n- 实例 A：$N = 17473$，$L = 40130$。\n- 实例 B：$N = 272953$，$L = 548210$。\n- 实例 C：$N = 119989$，$L = 1539578$。\n- 实例 D：$N = 1005973$，$L = 2012090$。\n\n输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表，顺序为 $[p_A, p_B, p_C, p_D]$。例如，如果计算出的四个较小因子是 $a$、$b$、$c$ 和 $d$，则在单行上打印 $[a,b,c,d]$。",
            "solution": "在尝试任何解决方案之前，需要对问题陈述进行验证。\n\n### 步骤 1：提取已知条件\n\n- 公钥密码系统，RSA 模数为 $N = p\\,q$。\n- $p$ 和 $q$ 是未知素数，且 $p \\le q$。\n- 侧信道泄露提供了一个非线性代数约束：$p^2 + q^2 = L$。\n- 目标是计算素数因子 $p$。\n- 指定的方法是使用牛顿线性化过程求解一个关于 $p$ 的单变量非线性方程。\n- 标量非线性方程 $f(x)=0$（其中 $p$ 是一个根）必须通过消去 $q$ 来推导。\n- 牛顿法由迭代更新公式 $x_{\\text{new}} = x - f(x)/f'(x)$ 定义。\n- 导数 $f'(x)$ 必须从第一性原理推导。\n- 迭代的初始猜测值为 $x_0 = \\sqrt{N}$。\n- 迭代值 $x$ 必须保持为正。\n- 需要一个基于迭代值变化或残差的停止规则，并设置最大迭代次数以确保终止。\n- 最终的数值根必须映射为整数，并且必须返回较小的素数因子。如果估计值更接近 $q$，则应计算较小的因子 $p = N/q$。\n- 测试套件：\n    - 实例 A：$(N = 17473, L = 40130)$\n    - 实例 B：$(N = 272953, L = 548210)$\n    - 实例 C：$(N = 119989, L = 1539578)$\n    - 实例 D：$(N = 1005973, L = 2012090)$\n- 要求输出格式：单行输出，包含一个用方括号括起来的、针对每个实例的逗号分隔结果列表：$[p_A, p_B, p_C, p_D]$。\n\n### 步骤 2：使用提取的已知条件进行验证\n\n根据既定的有效性标准对问题进行评估。\n\n- **科学性**：该问题基于代数（求解多项式方程）和数值分析（牛顿法）的基本原理。RSA 密码学和侧信道攻击的背景是计算工程和计算机科学中一个有效且成熟的课题。其中的数学关系是合理的。\n- **适定性**：问题陈述清晰。它提供了足够的信息（$N$，$L$）和一个特定的、定义明确的数值方法（牛顿法）来找到唯一的解（较小的素数因子 $p$）。\n- **客观性**：问题使用精确、客观的数学语言表达。没有主观或模棱两可的术语。\n- **完整性与一致性**：问题是自洽的。所提供的数据（$N, L$）足以进行推导和求解。没有内部矛盾。为了使解存在，$p$ 和 $q$ 必须有实数根，这要求相关二次方程的判别式为非负。这意味着 $L^2 - 4N^2 \\ge 0$，即 $L \\ge 2N$。所有测试实例都满足此条件，证实了它们的物理一致性。\n    - A: $L=40130$, $2N=34946$. $L  2N$.\n    - B: $L=548210$, $2N=545906$. $L  2N$.\n    - C: $L=1539578$, $2N=239978$. $L  2N$.\n    - D: $L=2012090$, $2N=2011946$. $L  2N$.\n- **可形式化**：问题不是隐喻性的，可以直接形式化为一个数学过程。它正确地属于通过线性化处理非线性问题的主题。\n\n该问题没有表现出任何与科学性不健全、不可形式化、不完整、不可行或不适定相关的缺陷。\n\n### 步骤 3：结论与行动\n\n该问题是 **有效的**。将提供一个解决方案。\n\n### 解法推导\n\n该解决方案需要推导一个标量非线性函数 $f(x)=0$（其根为所求的素数因子 $p$），然后应用牛顿法。\n\n**1. 非线性方程的推导**\n\n我们有两个基本方程：\n$$\nN = p\\,q\n$$\n$$\np^2 + q^2 = L\n$$\n从第一个方程中，我们可以用 $p$ 和 $N$ 来表示 $q$，假设 $p \\neq 0$（对于素数因子这是保证的）：\n$$\nq = \\frac{N}{p}\n$$\n将这个 $q$ 的表达式代入第二个方程，可以消去 $q$：\n$$\np^2 + \\left(\\frac{N}{p}\\right)^2 = L\n$$\n$$\np^2 + \\frac{N^2}{p^2} = L\n$$\n为了得到多项式形式，我们将整个方程乘以 $p^2$：\n$$\np^4 + N^2 = L p^2\n$$\n重新排列各项，得到一个关于 $p$ 的单变量非线性方程：\n$$\np^4 - L p^2 + N^2 = 0\n$$\n我们定义一个连续可微的标量函数 $f(x)$，其根对应于素数因子：\n$$\nf(x) = x^4 - L x^2 + N^2\n$$\n问题现在简化为求 $f(x) = 0$ 的较小正根。\n\n**2. 为牛顿法推导导数**\n\n牛顿法需要 $f(x)$ 的导数，记为 $f'(x)$。应用基础微积分中的幂法则进行微分：\n$$\nf'(x) = \\frac{d}{dx} \\left( x^4 - L x^2 + N^2 \\right)\n$$\n$$\nf'(x) = 4x^3 - 2Lx\n$$\n\n**3. 牛顿法的实现**\n\n牛顿法的迭代公式为：\n$$\nx_{k+1} = x_k - \\frac{f(x_k)}{f'(x_k)} = x_k - \\frac{x_k^4 - L x_k^2 + N^2}{4x_k^3 - 2Lx_k}\n$$\n问题指定了初始猜测值 $x_0 = \\sqrt{N}$。这是一个合乎逻辑的选择。由于 $p \\le q$，因此有 $p \\le \\sqrt{N} \\le q$。所以初始猜测值位于 $f(x)=0$ 的两个正根之间。函数 $f(x)$ 是一个“W”形四次函数，在 $x=0$ 处有一个局部最大值，在 $x = \\pm\\sqrt{L/2}$ 处有局部最小值。正如在验证中确定的，$L \\ge 2N$，这意味着 $\\sqrt{L/2} \\ge \\sqrt{N}$。初始猜测值 $x_0 = \\sqrt{N}$ 位于区间 $(p, \\sqrt{L/2})$ 内。在此区间内，$f(x)$ 和 $f'(x)$ 均为负值，导致项 $f(x)/f'(x)$ 为正值。更新 $x_{k+1} = x_k - (\\text{正值})$ 确保了迭代序列 $x_k$ 单调递减并收敛到较小的根 $p$。\n\n迭代过程如下：\n1.  初始化 $x_k = \\sqrt{N}$。\n2.  迭代至最大步数（例如 100）以保证终止。\n3.  在每一步中，计算更新量 $\\Delta x = f(x_k)/f'(x_k)$。\n4.  更新估计值：$x_{k+1} = x_k - \\Delta x$。\n5.  如果更新量的大小 $|\\Delta x|$ 小于指定的容差 $\\epsilon$（例如 $10^{-9}$），则终止。\n6.  一旦迭代收敛到一个根 $x^*$，该值就是 $p$ 的一个浮点近似值。\n\n**4. 最终结果计算**\n\n收敛的根 $x^*$ 必须转换为最终的整数答案。\n1.  将数值根四舍五入到最近的整数，以获得因子的整数估计值：$p_{\\text{est}} = \\text{round}(x^*)$。\n2.  计算相应的另一个因子：$q_{\\text{est}} = \\text{round}(N / p_{\\text{est}})$。\n3.  问题要求返回较小的素数因子 $p$。确定这一点的稳健方法是取两个估计值的最小值：$\\min(p_{\\text{est}}, q_{\\text{est}})$。尽管我们选择的 $x_0$ 确保了向 $p$ 的收敛，但这种方法能正确识别出较小的因子，无论数值方法可能收敛到哪个根。\n\n该过程将应用于测试套件中的每一对 $(N, L)$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the smaller prime factor p given N=pq and L=p^2+q^2\n    using Newton's method.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (17473, 40130),    # Instance A\n        (272953, 548210),   # Instance B\n        (119989, 1539578),  # Instance C\n        (1005973, 2012090), # Instance D\n    ]\n\n    results = []\n    for N, L in test_cases:\n        # This function implements Newton's method to find a root of\n        # f(x) = x^4 - L*x^2 + N^2 = 0.\n        \n        # Initial guess as specified: x_0 = sqrt(N).\n        # This guess is between the two positive roots p and q.\n        # Newton's method from this guess will converge to the smaller root p.\n        x = np.sqrt(N)\n        \n        # Parameters for Newton's method\n        max_iterations = 100\n        tolerance = 1e-9\n        \n        for i in range(max_iterations):\n            # Evaluate the function f(x) and its derivative f'(x).\n            # f(x) = x^4 - L*x^2 + N^2\n            # f'(x) = 4*x^3 - 2*L*x\n            x_sq = x * x\n            fx = x_sq * x_sq - L * x_sq + N * N\n            \n            dfx = 4.0 * x * x_sq - 2.0 * L * x\n            \n            # Avoid division by zero, though unlikely for this problem's setup.\n            if abs(dfx)  1e-12:\n                break\n                \n            # Newton's method update step\n            step = fx / dfx\n            x = x - step\n            \n            # Check for convergence\n            if abs(step)  tolerance:\n                break\n        \n        # The iteration converges to a high-precision estimate of one of the roots.\n        x_root = x\n        \n        # Map the numerical root to the integer factor.\n        # Round the result to the nearest integer to get the first factor candidate.\n        factor1 = int(round(x_root))\n        \n        # Compute the other factor candidate using the definition N = pq.\n        # Rounding here handles any small floating-point inaccuracies.\n        factor2 = int(round(N / factor1))\n        \n        # The smaller of the two factors is the required prime p.\n        p = min(factor1, factor2)\n        results.append(p)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "从单变量方程扩展到多变量函数系统时，线性近似的核心便成了雅可比矩阵。本练习让你亲手实现并比较两种计算这一关键矩阵的方法：前向模式自动微分（AD）和中心差分（FD）。通过这个编码实践，你将直观地理解为何自动微分在精度上优于有限差分，并深入体会到在计算工程中，精确的线性化对于后续的分析和优化是多么重要。",
            "id": "2398904",
            "problem": "要求您通过两种方式计算非线性复合映射的雅可比矩阵并比较其数值精度，来研究如何使用线性化处理非线性问题。考虑由以下部分定义的复合函数。设 $\\mathbf{x} \\in \\mathbb{R}^{3}$，其分量为 $\\mathbf{x} = [x_{1}, x_{2}, x_{3}]^{\\top}$。定义一个中间映射 $\\mathbf{g}: \\mathbb{R}^{3} \\rightarrow \\mathbb{R}^{3}$ 为\n$$\n\\mathbf{g}(\\mathbf{x}) =\n\\begin{bmatrix}\n\\exp\\!\\big(x_{1} x_{2}\\big) \\\\\n\\sin\\!\\big(x_{2} + x_{3}\\big) \\\\\nx_{1}^{2} + x_{3}\n\\end{bmatrix},\n$$\n以及第二个映射 $\\mathbf{h}: \\mathbb{R}^{3} \\rightarrow \\mathbb{R}^{2}$ 为\n$$\n\\mathbf{h}(\\mathbf{u}) =\n\\begin{bmatrix}\nu_{1} \\cos(u_{2}) + u_{3}^{3} \\\\\n\\ln\\!\\big(1 + u_{1}^{2} + u_{2}^{2}\\big) + \\tanh(u_{3})\n\\end{bmatrix}.\n$$\n三角函数 $\\sin(\\cdot)$ 和 $\\cos(\\cdot)$ 的角度应以弧度为单位。复合函数为 $\\mathbf{F} = \\mathbf{h} \\circ \\mathbf{g}: \\mathbb{R}^{3} \\rightarrow \\mathbb{R}^{2}$。\n\n您的任务是使用以下两种方法，在几个输入点 $\\mathbf{x}$ 处计算雅可比矩阵 $\\mathbf{J}_{\\mathbf{F}}(\\mathbf{x}) \\in \\mathbb{R}^{2 \\times 3}$：\n- 一种是基于对偶数的前向模式自动微分方法，以及\n- 另一种是使用两种步长的中心有限差分近似方法。\n\n雅可比矩阵 $\\mathbf{J}_{\\mathbf{F}}(\\mathbf{x})$ 的元素定义为 $[\\mathbf{J}_{\\mathbf{F}}(\\mathbf{x})]_{ij} = \\partial F_{i}(\\mathbf{x}) / \\partial x_{j}$。线性化是指使用此雅可比矩阵对 $\\mathbf{F}$ 在 $\\mathbf{x}$ 附近进行的一阶近似。\n\n对于前向模式自动微分方法，您必须实现对偶数，它表示数对 $(v, \\dot{v})$，这些数对根据基本原理（乘法法则、链式法则和基本函数的标准导数）通过基本运算和函数传播值和方向导数。对于有限差分法，使用中心差分公式近似计算雅可比矩阵的第 $j$ 列\n$$\n\\frac{\\mathbf{F}(\\mathbf{x} + h \\mathbf{e}_{j}) - \\mathbf{F}(\\mathbf{x} - h \\mathbf{e}_{j})}{2 h},\n$$\n其中 $\\mathbf{e}_{j}$ 是 $\\mathbb{R}^{3}$ 中的第 $j$ 个标准基向量，$h$ 是一个正标量步长。\n\n为量化精度差异，对每个测试输入和每个步长，计算有限差分雅可比矩阵 $\\mathbf{J}_{\\mathrm{fd}}$ 和自动微分雅可比矩阵 $\\mathbf{J}_{\\mathrm{ad}}$ 之间的相对弗罗贝尼乌斯范数误差：\n$$\n\\varepsilon_{\\mathrm{rel}} = \\frac{\\left\\| \\mathbf{J}_{\\mathrm{fd}} - \\mathbf{J}_{\\mathrm{ad}} \\right\\|_{F}}{\\max\\!\\left(1, \\left\\| \\mathbf{J}_{\\mathrm{ad}} \\right\\|_{F}\\right)},\n$$\n其中 $\\|\\cdot\\|_{F}$ 表示弗罗贝尼乌斯范数。这种归一化避免了除以小于 $1$ 的值，并在雅可比范数非常小的情况下保持度量的良好缩放。\n\n测试套件：\n- 使用以下四个输入向量 $\\mathbf{x}$（无量纲）：\n  - $\\mathbf{x}^{(1)} = [0.2, -0.3, 0.5]^{\\top}$，\n  - $\\mathbf{x}^{(2)} = [10^{-8}, -10^{-8}, 10^{-8}]^{\\top}$，\n  - $\\mathbf{x}^{(3)} = [1.5, 0.7, -1.2]^{\\top}$，\n  - $\\mathbf{x}^{(4)} = [-2.0, 0.4, 0.3]^{\\top}$。\n- 对于中心差分，使用两个步长 $h$：\n  - $h_{1} = 10^{-6}$，\n  - $h_{2} = 10^{-8}$。\n\n程序要求：\n- 根据基本原理，为出现在 $\\mathbf{F}$ 中的基本运算和函数实现基于对偶数的前向模式自动微分。\n- 按规定实现中心有限差分雅可比矩阵近似。\n- 对每个测试输入 $\\mathbf{x}^{(k)}$，计算两个值：$h = h_{1}$ 时的 $\\varepsilon_{\\mathrm{rel}}$ 和 $h = h_{2}$ 时的 $\\varepsilon_{\\mathrm{rel}}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来、无空格的逗号分隔列表。该列表必须按以下顺序包含八个浮点数值：\n  - $\\mathbf{x}^{(1)}$ 在 $h_{1}$ 和 $h_{2}$ 下的 $\\varepsilon_{\\mathrm{rel}}$，\n  - $\\mathbf{x}^{(2)}$ 在 $h_{1}$ 和 $h_{2}$ 下的 $\\varepsilon_{\\mathrm{rel}}$，\n  - $\\mathbf{x}^{(3)}$ 在 $h_{1}$ 和 $h_{2}$ 下的 $\\varepsilon_{\\mathrm{rel}}$，\n  - $\\mathbf{x}^{(4)}$ 在 $h_{1}$ 和 $h_{2}$ 下的 $\\varepsilon_{\\mathrm{rel}}$。\n例如，输出必须如下所示\n$$\n[\\varepsilon_{1,1},\\varepsilon_{1,2},\\varepsilon_{2,1},\\varepsilon_{2,2},\\varepsilon_{3,1},\\varepsilon_{3,2},\\varepsilon_{4,1},\\varepsilon_{4,2}],\n$$\n其中每个 $\\varepsilon_{k,\\ell}$ 是一个浮点数。不应打印任何额外文本。",
            "solution": "问题陈述已经过验证，被认为是有效的。它在计算工程领域内提出了一个适定的、有科学依据的计算任务，具体涉及通过线性化处理非线性问题。所有函数、参数和评估指标都经过了数学上的精确定义，问题没有歧义或事实错误。\n\n核心任务是使用两种不同的方法计算复合非线性函数 $\\mathbf{F} = \\mathbf{h} \\circ \\mathbf{g}: \\mathbb{R}^{3} \\rightarrow \\mathbb{R}^{2}$ 的雅可比矩阵 $\\mathbf{J}_{\\mathbf{F}}(\\mathbf{x})$，并量化它们的数值精度。这两种方法是前向模式自动微分 (AD) 和中心有限差分 (FD)。AD 的结果精确到机器精度，将作为比较 FD 近似的参考基准。\n\n### 1. 分析框架\n\n复合函数为 $\\mathbf{F}(\\mathbf{x}) = \\mathbf{h}(\\mathbf{g}(\\mathbf{x}))$，其中 $\\mathbf{g}: \\mathbb{R}^{3} \\rightarrow \\mathbb{R}^{3}$ 且 $\\mathbf{h}: \\mathbb{R}^{3} \\rightarrow \\mathbb{R}^{2}$。\n$$\n\\mathbf{g}(\\mathbf{x}) =\n\\begin{bmatrix}\ng_{1}(\\mathbf{x}) \\\\ g_{2}(\\mathbf{x}) \\\\ g_{3}(\\mathbf{x})\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\exp\\!\\big(x_{1} x_{2}\\big) \\\\\n\\sin\\!\\big(x_{2} + x_{3}\\big) \\\\\nx_{1}^{2} + x_{3}\n\\end{bmatrix}\n$$\n$$\n\\mathbf{h}(\\mathbf{u}) =\n\\begin{bmatrix}\nh_{1}(\\mathbf{u}) \\\\ h_{2}(\\mathbf{u})\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nu_{1} \\cos(u_{2}) + u_{3}^{3} \\\\\n\\ln\\!\\big(1 + u_{1}^{2} + u_{2}^{2}\\big) + \\tanh(u_{3})\n\\end{bmatrix}\n$$\n复合函数的雅可比矩阵由多元链式法则给出：\n$$\n\\mathbf{J}_{\\mathbf{F}}(\\mathbf{x}) = \\mathbf{J}_{\\mathbf{h}}(\\mathbf{g}(\\mathbf{x})) \\cdot \\mathbf{J}_{\\mathbf{g}}(\\mathbf{x})\n$$\n其中 $\\mathbf{J}_{\\mathbf{h}} \\in \\mathbb{R}^{2 \\times 3}$ 且 $\\mathbf{J}_{\\mathbf{g}} \\in \\mathbb{R}^{3 \\times 3}$。\n\n### 2. 前向模式自动微分 (AD)\n\n前向模式 AD 通过在基本运算层面系统地应用链式法则来计算精确导数。这是通过对偶数代数实现的。一个对偶数是一个有序对 $(v, \\dot{v})$，表示一个值 $v$ 及其方向导数 $\\dot{v}$。它可以写成 $v + \\epsilon \\dot{v}$ 的形式，其中 $\\epsilon$ 是一个无穷小量，其性质为 $\\epsilon^2 = 0$。\n\n算术和基本函数的规则源自标准微分法则：\n- **加法法则**：$(u \\pm w)' = u' \\pm w'$ $\\implies$ $(u_{v}, u_{\\dot{v}}) \\pm (w_{v}, w_{\\dot{v}}) = (u_{v} \\pm w_{v}, u_{\\dot{v}} \\pm w_{\\dot{v}})$\n- **乘法法则**：$(u w)' = u'w + uw'$ $\\implies$ $(u_{v}, u_{\\dot{v}}) \\cdot (w_{v}, w_{\\dot{v}}) = (u_{v} w_{v}, u_{\\dot{v}} w_{v} + u_{v} w_{\\dot{v}})$\n- **链式法则**：$(f(u))' = f'(u) u'$ $\\implies$ $f((u_{v}, u_{\\dot{v}})) = (f(u_{v}), f'(u_{v}) u_{\\dot{v}})$\n\n为了计算雅可比矩阵 $\\mathbf{J}_{\\mathbf{F}}(\\mathbf{x})$ 的第 $j$ 列（该列包含关于 $x_j$ 的偏导数），我们计算 $\\mathbf{F}$ 在标准基向量 $\\mathbf{e}_j$ 方向上的方向导数。这通过将输入导数（“种子”）设置为 $\\dot{\\mathbf{x}} = \\mathbf{e}_j$ 来完成。\n\n该算法对每列 $j = 1, 2, 3$ 包括以下步骤：\n1.  将输入向量 $\\mathbf{x}$ 初始化为一个对偶数向量，其中 $x_{i}$ 变为 $(x_{i}, \\delta_{ij})$，$\\delta_{ij}$ 为克罗内克 δ。\n2.  使用对偶数算术评估函数 $\\mathbf{F}$。评估过程通过复合 $\\mathbf{h} \\circ \\mathbf{g}$ 传播值及其导数。\n3.  结果是一个对偶数向量 $\\mathbf{F}(\\mathbf{x}_{\\text{dual}}) = [(F_{1}, \\dot{F}_{1}), (F_{2}, \\dot{F}_{2})]^{\\top}$。导数分量 $(\\dot{F}_{1}, \\dot{F}_{2})^{\\top}$ 构成雅可比矩阵的第 $j$ 列：$[\\mathbf{J}_{\\mathbf{F}}]_{ij} = \\dot{F}_i$。\n\n对每个输入变量重复此过程，以构建完整的雅可比矩阵 $\\mathbf{J}_{\\mathrm{ad}}$。\n\n### 3. 中心有限差分 (FD) 近似\n\n有限差分法通过在扰动点上评估函数来近似导数。雅可比矩阵第 $j$ 列的中心差分公式由下式给出：\n$$\n(\\mathbf{J}_{\\mathrm{fd}})_{:,j} = \\frac{\\mathbf{F}(\\mathbf{x} + h \\mathbf{e}_{j}) - \\mathbf{F}(\\mathbf{x} - h \\mathbf{e}_{j})}{2 h}\n$$\n其中 $h$ 是一个小的步长。此公式源自 $\\mathbf{F}(\\mathbf{x} \\pm h \\mathbf{e}_{j})$ 在 $\\mathbf{x}$ 附近的泰勒级数展开。该近似的截断误差为 $O(h^2)$ 阶，意味着误差与步长的平方成正比。\n\n然而，总误差是此截断误差和浮点运算产生的舍入误差的组合。当 $h$ 减小时，分子中减法运算的舍入误差会增加，导致有效数字损失。这就产生了一个权衡：较小的 $h$ 会减少截断误差，但会增加舍入误差。我们将通过使用两个不同的步长 $h_1 = 10^{-6}$ 和 $h_2 = 10^{-8}$ 来研究这一点。\n\n### 4. 误差量化\n\n为了将有限差分法的精度与自动微分的结果进行比较，我们计算相对弗罗贝尼乌斯范数误差：\n$$\n\\varepsilon_{\\mathrm{rel}} = \\frac{\\left\\| \\mathbf{J}_{\\mathrm{fd}} - \\mathbf{J}_{\\mathrm{ad}} \\right\\|_{F}}{\\max\\!\\left(1, \\left\\| \\mathbf{J}_{\\mathrm{ad}} \\right\\|_{F}\\right)}\n$$\n弗罗贝尼乌斯范数定义为 $\\|\\mathbf{A}\\|_{F} = \\sqrt{\\sum_{i,j} |A_{ij}|^2}$。通过 $\\max(1, \\left\\| \\mathbf{J}_{\\mathrm{ad}} \\right\\|_{F})$ 进行归一化提供了一个稳定的误差度量，可以防止除以接近零的值，同时相对于“真实”雅可比矩阵的量级来缩放误差。\n\n### 5. 实现策略\n\n该解决方案用 Python 实现。定义了一个 `Dual` 类来表示对偶数并重载标准算术运算符。为基本数学运算（`exp`, `sin`, `cos`, `ln`, `tanh`）实现了多态的全局函数，可以同时处理标准浮点数和 `Dual` 对象。然后使用这些多态运算编写特定于问题的函数 $\\mathbf{g}$ 和 $\\mathbf{h}$，使它们能够无缝地用于 AD 和 FD 计算。主程序遍历指定的测试输入和步长，通过两种方法计算雅可比矩阵，并计算每种情况下的相对误差。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# A strict Russian professor insists on scientific correctness from first principles.\n\nclass Dual:\n    \"\"\"\n    Represents a dual number for forward-mode automatic differentiation.\n    A dual number has a real part (value) and an infinitesimal part (derivative).\n    d = value + derivative * epsilon, where epsilon^2 = 0.\n    \"\"\"\n    def __init__(self, value, derivative=0.0):\n        self.value = float(value)\n        self.derivative = float(derivative)\n\n    def __repr__(self):\n        return f\"Dual({self.value}, {self.derivative})\"\n\n    def __add__(self, other):\n        if isinstance(other, Dual):\n            return Dual(self.value + other.value, self.derivative + other.derivative)\n        return Dual(self.value + other, self.derivative)\n\n    def __radd__(self, other):\n        return self.__add__(other)\n\n    def __sub__(self, other):\n        if isinstance(other, Dual):\n            return Dual(self.value - other.value, self.derivative - other.derivative)\n        return Dual(self.value - other, self.derivative)\n\n    def __rsub__(self, other):\n        return Dual(other - self.value, -self.derivative)\n\n    def __mul__(self, other):\n        if isinstance(other, Dual):\n            # Product rule: (uv)' = u'v + uv'\n            return Dual(self.value * other.value, \n                        self.derivative * other.value + self.value * other.derivative)\n        return Dual(self.value * other, self.derivative * other)\n\n    def __rmul__(self, other):\n        return self.__mul__(other)\n    \n    def __pow__(self, exponent):\n        if isinstance(exponent, (int, float)):\n            # Power rule for constant exponent: (u^c)' = c*u^(c-1)*u'\n            val = self.value ** exponent\n            der = exponent * (self.value ** (exponent - 1)) * self.derivative\n            return Dual(val, der)\n        raise NotImplementedError(\"Dual to the power of Dual is not implemented.\")\n\n    def __truediv__(self, other):\n        if isinstance(other, Dual):\n            # Quotient rule: (u/v)' = (u'v - uv') / v^2\n            val = self.value / other.value\n            der = (self.derivative * other.value - self.value * other.derivative) / (other.value ** 2)\n            return Dual(val, der)\n        return Dual(self.value / other, self.derivative / other)\n\n    def __rtruediv__(self, other):\n        val = other / self.value\n        der = (-other * self.derivative) / (self.value ** 2)\n        return Dual(val, der)\n    \n    def __neg__(self):\n        return Dual(-self.value, -self.derivative)\n\n# Polymorphic elementary functions that work with both floats and Dual numbers.\ndef exp(d):\n    if not isinstance(d, Dual): return np.exp(d)\n    val = np.exp(d.value)\n    der = val * d.derivative\n    return Dual(val, der)\n\ndef sin(d):\n    if not isinstance(d, Dual): return np.sin(d)\n    val = np.sin(d.value)\n    der = np.cos(d.value) * d.derivative\n    return Dual(val, der)\n\ndef cos(d):\n    if not isinstance(d, Dual): return np.cos(d)\n    val = np.cos(d.value)\n    der = -np.sin(d.value) * d.derivative\n    return Dual(val, der)\n\ndef log(d):\n    if not isinstance(d, Dual): return np.log(d)\n    val = np.log(d.value)\n    der = (1 / d.value) * d.derivative\n    return Dual(val, der)\n\ndef tanh(d):\n    if not isinstance(d, Dual): return np.tanh(d)\n    val = np.tanh(d.value)\n    # Derivative of tanh(x) is sech^2(x) = 1 - tanh^2(x)\n    der = (1 - val**2) * d.derivative\n    return Dual(val, der)\n\n# Problem-specific nonlinear mappings\ndef g(x_vec):\n    \"\"\" Intermediate mapping g: R^3 - R^3 \"\"\"\n    x1, x2, x3 = x_vec[0], x_vec[1], x_vec[2]\n    return [\n        exp(x1 * x2),\n        sin(x2 + x3),\n        x1**2 + x3\n    ]\n\ndef h(u_vec):\n    \"\"\" Final mapping h: R^3 - R^2 \"\"\"\n    u1, u2, u3 = u_vec[0], u_vec[1], u_vec[2]\n    return [\n        u1 * cos(u2) + u3**3,\n        log(1 + u1**2 + u2**2) + tanh(u3)\n    ]\n\ndef F(x_vec):\n    \"\"\" Composed mapping F = h(g(x)) \"\"\"\n    return h(g(x_vec))\n\ndef compute_jacobian_ad(x_val):\n    \"\"\"Computes the Jacobian using forward-mode automatic differentiation.\"\"\"\n    n_in = len(x_val)\n    # Dynamically determine output dimension by a sample evaluation\n    n_out = len(F(x_val))\n    J_ad = np.zeros((n_out, n_in))\n    \n    for j in range(n_in):\n        # Create dual number inputs with a seed for the j-th partial derivative\n        x_dual = [Dual(x_val[i], 1.0 if i == j else 0.0) for i in range(n_in)]\n        \n        # Evaluate the function with dual numbers\n        F_dual = F(x_dual)\n        \n        # The derivative part of the output is the j-th column of the Jacobian\n        for i in range(n_out):\n            J_ad[i, j] = F_dual[i].derivative\n            \n    return J_ad\n\ndef compute_jacobian_fd(x_val, h_step):\n    \"\"\"Computes the Jacobian using the central finite-difference formula.\"\"\"\n    x_val = np.array(x_val, dtype=float)\n    n_in = len(x_val)\n    n_out = len(F(x_val))\n    J_fd = np.zeros((n_out, n_in))\n    \n    for j in range(n_in):\n        e_j = np.zeros(n_in)\n        e_j[j] = 1.0\n        \n        x_fwd = x_val + h_step * e_j\n        x_bwd = x_val - h_step * e_j\n        \n        F_fwd = np.array(F(x_fwd))\n        F_bwd = np.array(F(x_bwd))\n        \n        column = (F_fwd - F_bwd) / (2 * h_step)\n        J_fd[:, j] = column\n        \n    return J_fd\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [0.2, -0.3, 0.5],\n        [1e-8, -1e-8, 1e-8],\n        [1.5, 0.7, -1.2],\n        [-2.0, 0.4, 0.3]\n    ]\n    step_sizes = [1e-6, 1e-8]\n    \n    results = []\n    for x_vec in test_cases:\n        # Compute the \"exact\" Jacobian using Automatic Differentiation\n        J_ad = compute_jacobian_ad(x_vec)\n        norm_J_ad = np.linalg.norm(J_ad, 'fro')\n\n        for h in step_sizes:\n            # Compute the approximate Jacobian using Finite Differences\n            J_fd = compute_jacobian_fd(x_vec, h)\n            \n            # Calculate the relative Frobenius-norm error\n            norm_diff = np.linalg.norm(J_fd - J_ad, 'fro')\n            error = norm_diff / max(1.0, norm_J_ad)\n            results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "线性化的思想远不止应用于代数方程，它在动力系统领域同样威力巨大。本练习将目光投向著名的非线性振子——杜芬方程（Duffing equation），这是一个无法直接求得解析解的非线性微分方程。你将使用微扰理论，通过巧妙地将原始的非线性问题分解为一系列可以求解的线性问题，来计算非线性项对振动频率的一阶修正。这项实践充分展示了线性化作为一种思想工具，在分析复杂动力学行为时的深刻洞见和广泛适用性。",
            "id": "2398884",
            "problem": "考虑由 Duffing 方程控制的非线性振子\n$$\\ddot{x} + x + \\epsilon x^{3} = 0,$$\n其中 $\\epsilon$ 是一个无量纲参数，且 $|\\epsilon| \\ll 1$。设初始条件为 $x(0) = A$ 和 $\\dot{x}(0) = 0$，其中 $A0$。定义线性固有角频率为 $\\omega_{0} = 1$。请求解由三次非线性项引起的周期运动的角频率修正量 $\\Delta \\omega(A,\\epsilon)$，精确到 $\\epsilon$ 的一阶，使得角频率为 $\\omega = \\omega_{0} + \\Delta \\omega(A,\\epsilon) + \\mathcal{O}(\\epsilon^{2})$。请用 $A$ 和 $\\epsilon$ 将最终结果表示为单个闭式解析表达式。答案无需四舍五入，也没有单位。",
            "solution": "本问题要求确定由 Duffing 方程描述的非线性振子角频率的一阶修正。控制方程为：\n$$\n\\ddot{x} + x + \\epsilon x^{3} = 0\n$$\n初始条件为 $x(0) = A$ 和 $\\dot{x}(0) = 0$，其中 $A0$ 且 $|\\epsilon| \\ll 1$。线性固有角频率给定为 $\\omega_{0} = 1$。\n\n这是非线性动力学中的一个经典问题，可以使用微扰理论解决。我们将采用 Lindstedt-Poincaré 方法。该技术通过同时将解和频率按小参数 $\\epsilon$ 的幂次展开，来解决直接微扰展开中出现的久期项（随时间无限增长的项）问题。\n\n首先，我们引入一个新的无量纲时间变量 $\\tau = \\omega t$，其中 $\\omega$ 是周期运动的真实未知角频率。关于 $t$ 的导数变换如下：\n$$\n\\frac{d}{dt} = \\frac{d\\tau}{dt} \\frac{d}{d\\tau} = \\omega \\frac{d}{d\\tau}\n$$\n$$\n\\frac{d^2}{dt^2} = \\omega^2 \\frac{d^2}{d\\tau^2}\n$$\n将这些代入 Duffing 方程，并用撇号表示对 $\\tau$ 的微分，我们得到：\n$$\n\\omega^2 x''(\\tau) + x(\\tau) + \\epsilon x(\\tau)^3 = 0\n$$\n接下来，我们寻求解 $x(\\tau)$ 和频率的平方 $\\omega^2$ 关于 $\\epsilon$ 的幂级数展开。通常我们展开 $\\omega$ 本身，但展开 $\\omega^2$ 在代数上是等价的，且通常更简单。\n$$\nx(\\tau) = x_0(\\tau) + \\epsilon x_1(\\tau) + \\epsilon^2 x_2(\\tau) + \\dots\n$$\n$$\n\\omega = \\omega_0 + \\epsilon \\omega_1 + \\epsilon^2 \\omega_2 + \\dots\n$$\n给定 $\\omega_0 = 1$，$\\omega^2$ 的展开式变为：\n$$\n\\omega^2 = (1 + \\epsilon \\omega_1 + \\dots)^2 = 1 + 2\\epsilon \\omega_1 + \\mathcal{O}(\\epsilon^2)\n$$\n将这些展开式代入变换后的微分方程：\n$$\n(1 + 2\\epsilon \\omega_1 + \\mathcal{O}(\\epsilon^2))(x_0'' + \\epsilon x_1'' + \\dots) + (x_0 + \\epsilon x_1 + \\dots) + \\epsilon(x_0 + \\epsilon x_1 + \\dots)^3 = 0\n$$\n我们展开乘积，并按 $\\epsilon$ 的同次幂合并项。\n\n$\\epsilon^0$ 阶：\n$$\nx_0'' + x_0 = 0\n$$\n这是简谐振子的方程。原问题的初始条件必须转换到展开项上。在 $t=0$ 时，我们有 $\\tau=0$。\n$x(0) = x_0(0) + \\epsilon x_1(0) + \\dots = A \\implies x_0(0) = A, x_1(0)=0, \\dots$\n$\\dot{x}(t) = \\omega \\frac{dx}{d\\tau} = \\omega(x_0'(\\tau) + \\epsilon x_1'(\\tau) + \\dots)$。\n$\\dot{x}(0) = \\omega(x_0'(0) + \\epsilon x_1'(0) + \\dots) = 0 \\implies x_0'(0)=0, x_1'(0)=0, \\dots$\n零阶方程的通解是 $x_0(\\tau) = C \\cos(\\tau) + D \\sin(\\tau)$。应用初始条件：\n$x_0(0) = C = A$\n$x_0'(0) = D = 0$\n因此，零阶解为：\n$$\nx_0(\\tau) = A \\cos(\\tau)\n$$\n\n$\\epsilon^1$ 阶：\n从展开的方程中收集所有与 $\\epsilon$ 成比例的项，得到：\n$$\nx_1'' + x_0 + 2\\omega_1 x_0'' + x_0^3 = 0\n$$\n重新整理以形成关于 $x_1$ 的方程：\n$$\nx_1'' + x_1 = -2\\omega_1 x_0'' - x_0^3\n$$\n我们将零阶解 $x_0(\\tau) = A \\cos(\\tau)$ 及其二阶导数 $x_0''(\\tau) = -A \\cos(\\tau)$ 代入右侧（RHS）：\n$$\n\\text{RHS} = -2\\omega_1 (-A \\cos(\\tau)) - (A \\cos(\\tau))^3 = 2\\omega_1 A \\cos(\\tau) - A^3 \\cos^3(\\tau)\n$$\n为了分析强迫项，我们使用三角恒等式 $\\cos(3\\theta) = 4\\cos^3(\\theta) - 3\\cos(\\theta)$，由此得到 $\\cos^3(\\theta) = \\frac{1}{4}(\\cos(3\\theta) + 3\\cos(\\theta))$。\n将此恒等式应用于 $\\cos^3(\\tau)$：\n$$\n\\text{RHS} = 2\\omega_1 A \\cos(\\tau) - A^3 \\left(\\frac{3}{4}\\cos(\\tau) + \\frac{1}{4}\\cos(3\\tau)\\right)\n$$\n合并项：\n$$\n\\text{RHS} = \\left(2\\omega_1 A - \\frac{3A^3}{4}\\right)\\cos(\\tau) - \\frac{A^3}{4}\\cos(3\\tau)\n$$\n因此，$x_1$ 的方程为：\n$$\nx_1'' + x_1 = \\left(2\\omega_1 A - \\frac{3A^3}{4}\\right)\\cos(\\tau) - \\frac{A^3}{4}\\cos(3\\tau)\n$$\n此方程的齐次部分固有频率为 $1$。强迫项包含一个频率相同的分量 $\\cos(\\tau)$。这将导致共振响应，在 $x_1$ 的解中产生一个形如 $\\tau \\sin(\\tau)$ 的久期项。这样的项会无界增长，这违背了周期运动的物理假设。Lindstedt-Poincaré 方法的核心原理是精确地选择频率修正 $\\omega_1$，以消除这个产生久期项的强迫项。\n我们必须将共振项 $\\cos(\\tau)$ 的系数设为零：\n$$\n2\\omega_1 A - \\frac{3A^3}{4} = 0\n$$\n由于给定 $A  0$，我们可以除以 $2A$：\n$$\n\\omega_1 - \\frac{3A^2}{8} = 0 \\implies \\omega_1 = \\frac{3A^2}{8}\n$$\n这就得到了一阶频率修正。问题要求的是量 $\\Delta \\omega(A, \\epsilon)$，即频率直到 $\\epsilon$ 一阶的总修正。根据我们的展开式 $\\omega = \\omega_0 + \\epsilon \\omega_1 + \\mathcal{O}(\\epsilon^2)$，我们有：\n$$\n\\Delta \\omega(A, \\epsilon) = \\omega - \\omega_0 = \\epsilon \\omega_1 + \\mathcal{O}(\\epsilon^2)\n$$\n精确到 $\\epsilon$ 的一阶，修正是：\n$$\n\\Delta \\omega(A, \\epsilon) = \\epsilon \\omega_1 = \\frac{3\\epsilon A^2}{8}\n$$\n该表达式表示由于弱三次非线性引起的振子角频率的变化，是初始振幅 $A$ 和非线性参数 $\\epsilon$ 的函数。对于“硬化”弹簧（$\\epsilon0$），频率随振幅增加而增加。",
            "answer": "$$\n\\boxed{\\frac{3\\epsilon A^{2}}{8}}\n$$"
        }
    ]
}