{
    "hands_on_practices": [
        {
            "introduction": "求解开普勒方程是天体动力学中的一个经典问题，对于预测行星和卫星的位置至关重要。本练习  将挑战您将牛顿-拉弗森法应用于这个超越方程 $M = E - e \\sin(E)$，展示一个强大的数值技术如何解决一个有数百年历史的天体力学问题。",
            "id": "2434125",
            "problem": "给定标量非线性方程（用于椭圆运动的开普勒方程）$M = E - e \\sin(E)$，其参数为 $e \\in [0,1)$ 和 $M \\in [0,2\\pi)$。对于每对参数，请确定满足该方程的唯一解 $E \\in [0,2\\pi]$，并达到高数值精度。所有角度必须以弧度处理和报告。\n\n定义函数 $f(E) = E - e \\sin(E) - M$。对于每个给定的参数对 $(e,M)$，计算唯一的根 $E$ 使得 $f(E) = 0$，并满足以下正确性要求：\n- 绝对残差必须满足 $\\lvert f(E) \\rvert \\leq 10^{-13}$。\n- 报告的解必须四舍五入到小数点后 $12$ 位。\n\n测试套件（每对为 $(e,M)$，其中 $M$ 以弧度为单位）：\n- 情况 1：$(e,M) = (0.999, 0.001)$。\n- 情况 2：$(e,M) = (0.9999, \\pi)$。\n- 情况 3：$(e,M) = (0.9, 2.0)$。\n- 情况 4：$(e,M) = (0.0, 4.0)$。\n- 情况 5：$(e,M) = (0.999999, 0.000001)$。\n- 情况 6：$(e,M) = (0.9995, 2\\pi - 0.000001)$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的结果顺序与上述测试套件相同，每个 $E$ 都四舍五入到小数点后 $12$ 位，例如：$[E_1,E_2,E_3,E_4,E_5,E_6]$，其中每个 $E_k$ 是一个以弧度为单位、四舍五入到小数点后 $12$ 位的小数，不打印任何额外文本。",
            "solution": "该问题要求在给定偏心率 $e$ 和平近点角 $M$ 的情况下，对开普勒方程 $M = E - e \\sin(E)$ 进行数值求解，以求得偏近点角 $E$。这是计算天体动力学中的一项基本任务。在进行求解之前，我们必须严格验证问题陈述的有效性。\n\n给定条件如下：\n- 方程：$M = E - e \\sin(E)$\n- 参数范围：偏心率 $e \\in [0, 1)$，平近点角 $M \\in [0, 2\\pi)$\n- 解域：偏近点角 $E \\in [0, 2\\pi]$\n- 测试用例：一组六个 $(e, M)$ 对。\n- 数值要求：残差 $|E - e \\sin(E) - M| \\leq 10^{-13}$，并且结果必须四舍五入到小数点后 $12$ 位。\n\n该问题具有科学依据，植根于天体力学。它提法恰当、客观，并包含确定唯一解所需的所有必要信息。测试用例包括一些对数值方法具有挑战性的情景，例如高偏心率 ($e \\approx 1$) 加上接近 $0$ 或 $2\\pi$ 的平近点角，但这些情景在物理和数学上仍然是有效的。因此，该问题是有效的，我们可以继续进行。\n\n任务是对于给定的参数 $e$ 和 $M$，找到标量函数 $f(E) = E - e \\sin(E) - M$ 的根。\n\n首先，我们证明对于任意 $M \\in [0, 2\\pi)$ 和 $e \\in [0, 1)$，解 $E \\in [0, 2\\pi]$ 存在且唯一。$f(E)$ 对 $E$ 的一阶导数是：\n$$ f'(E) = \\frac{d}{dE} (E - e \\sin(E) - M) = 1 - e \\cos(E) $$\n由于 $e \\in [0, 1)$，我们有 $e  1$。余弦函数是有界的，即 $|\\cos(E)| \\le 1$。因此，对于任意 $E$，都有 $e \\cos(E)  1$。这意味着导数 $f'(E)$ 对所有 $E$ 都严格为正：\n$$ f'(E) = 1 - e \\cos(E)  1 - e  0 $$\n严格为正的导数意味着 $f(E)$ 是一个严格单调递增的函数。这样的函数与轴 $f(E)=0$ 最多相交一次，这保证了根的唯一性。\n\n为了证明存在性，我们计算函数在定义域 $[0, 2\\pi]$ 边界处的值：\n$$ f(0) = 0 - e \\sin(0) - M = -M $$\n$$ f(2\\pi) = 2\\pi - e \\sin(2\\pi) - M = 2\\pi - M $$\n给定 $M \\in [0, 2\\pi)$，我们有 $f(0) = -M \\le 0$ 和 $f(2\\pi) = 2\\pi - M  0$。由于 $f(E)$ 是连续的，并且在区间 $[0, 2\\pi]$ 上变号，根据介值定理，可以保证在该区间内至少存在一个根 $E$。结合唯一性，这证实了在 $[0, 2\\pi]$ 中存在一个且仅一个根。\n\n为了数值求解这个根，我们采用 Newton-Raphson 方法。这是一种高效的迭代算法，在有利条件下具有二次收敛性。从 $E_k$ 求得逐次逼近值 $E_{k+1}$ 的迭代公式为：\n$$ E_{k+1} = E_k - \\frac{f(E_k)}{f'(E_k)} = E_k - \\frac{E_k - e \\sin(E_k) - M}{1 - e \\cos(E_k)} $$\n需要一个初始猜测值 $E_0$。对于开普勒方程，一个简单且通常有效的选择是 $E_0 = M$。虽然存在更复杂的初始猜测值，特别是在 $e \\to 1$ 且 $M \\to 0$ 或 $M \\to 2\\pi$ 的挑战性情况下，但选择 $E_0=M$ 对于所有给定的测试用例都足够稳健以实现收敛。迭代过程持续进行，直到残差的绝对值 $|f(E_k)|$ 小于或等于指定公差 $10^{-13}$。\n\n对于每对 $(e, M)$，算法如下：\n1. 设置偏近点角的初始猜测值：$E \\leftarrow M$。\n2. 开始迭代循环：\n   a. 计算残差：$r = E - e \\sin(E) - M$。\n   b. 检查收敛性：如果 $|r| \\le 10^{-13}$，则终止循环。\n   c. 计算导数：$g = 1 - e \\cos(E)$。\n   d. 更新偏近点角的估计值：$E \\leftarrow E - r/g$。\n3. 循环终止后，得到的 $E$ 值即为解。然后根据要求将此解四舍五入到小数点后 $12$ 位。此过程系统地应用于所有测试用例。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves Kepler's equation for a suite of test cases using the Newton-Raphson method.\n    \"\"\"\n    \n    # Test cases: each tuple is (eccentricity, mean_anomaly_in_radians)\n    test_cases = [\n        (0.999, 0.001),\n        (0.9999, np.pi),\n        (0.9, 2.0),\n        (0.0, 4.0),\n        (0.999999, 0.000001),\n        (0.9995, 2 * np.pi - 0.000001),\n    ]\n\n    results = []\n    \n    # Numerical tolerance for the residual\n    TOLERANCE = 1e-13\n    # Maximum number of iterations to prevent infinite loops\n    MAX_ITERATIONS = 50\n\n    for e, M in test_cases:\n        # For e=0, the equation simplifies to E = M.\n        if e == 0.0:\n            results.append(round(M, 12))\n            continue\n        \n        # For M=pi and M=0 (or 2pi), E=M is the root due to sin(M)=0.\n        if M == np.pi or M == 0.0 or M == 2 * np.pi:\n            results.append(round(M, 12))\n            continue\n\n        # Initial guess for Newton-Raphson method\n        E = M\n\n        for _ in range(MAX_ITERATIONS):\n            # Function f(E) = E - e*sin(E) - M\n            residual = E - e * np.sin(E) - M\n            \n            # Check for convergence\n            if abs(residual) = TOLERANCE:\n                break\n            \n            # Derivative f'(E) = 1 - e*cos(E)\n            gradient = 1 - e * np.cos(E)\n            \n            # Newton-Raphson update step\n            E = E - residual / gradient\n        \n        # Round the final result to 12 decimal places\n        results.append(round(E, 12))\n\n    # Format the final output as a comma-separated list in brackets\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "尽管牛顿法功能强大，但其在实际应用中仍受到计算机算术精度的限制。这个思想实验  探讨了一种关键的失效模式，其中数值导数计算中的灾难性相消会导致结果严重失准。理解这类陷阱是成为一名出色的计算工程师的关键。",
            "id": "2434157",
            "problem": "一个标量非线性方程 $f(x)=0$ 将通过牛顿-拉夫逊迭代法求解，其中导数通过在浮点运算中计算的对称差商来近似：\n$$\nf'(x)\\approx \\frac{f(x+h)-f(x-h)}{2h}.\n$$\n考虑函数 $f(x)= (x-1)^{8}-10^{-8}$，它在 $x=1$ 处有一个非常平坦的极小值。初始猜测值为 $x_0=1+10^{-3}$。导数使用上述对称差分进行近似，步长为 $h=10^{-16}$。所有函数求值和算术运算都在电气和电子工程师协会 (IEEE) 754 双精度下进行，单位舍入误差为 $u=2^{-53}\\approx 1.11\\times 10^{-16}$，并且每个计算出的函数值 $\\widehat{f}(x)$ 满足 $|\\widehat{f}(x)-f(x)|\\le u\\,|f(x)|$。\n\n哪个选项最能描述第一次计算出的牛顿更新量 $\\Delta x_0=-\\,f(x_0)\\big/\\widehat{f}'(x_0)$ 及其数值原因？\n\nA. 分子 $f(x_0+h)-f(x_0-h)$ 被舍入误差主导，因此 $\\widehat{f}'(x_0)$ 的量级约为 $5\\times 10^{-9}$ 且 $\\Delta x_0\\approx +2$，导致 $x_1$ 远离根。\n\nB. 有限差分得到的结果恰好是 $\\widehat{f}'(x_0)=0$，因此牛顿更新量因除以零而未定义。\n\nC. 有限差分的相对误差精度为 $\\mathcal{O}(u)$，因此 $\\widehat{f}'(x_0)\\approx f'(x_0)=8\\times 10^{-21}$ 且 $\\Delta x_0\\approx +1.25\\times 10^{12}$。\n\nD. 选择更小的步长，例如 $h=10^{-20}$，会减少 $f(x_0+h)-f(x_0-h)$ 中的相减抵消，并恢复可靠的导数估计和收敛性。",
            "solution": "必须首先验证问题陈述的科学合理性和一致性。\n\n**步骤1：提取已知条件**\n-   非线性方程：$f(x) = 0$。\n-   函数：$f(x) = (x-1)^8 - 10^{-8}$。\n-   数值方法：牛顿-拉夫逊迭代法。\n-   导数近似：对称差商，$\\widehat{f}'(x) = \\frac{\\widehat{f}(x+h) - \\widehat{f}(x-h)}{2h}$。\n-   初始猜测值：$x_0 = 1 + 10^{-3}$。\n-   有限差分步长：$h = 10^{-16}$。\n-   算术精度：电气和电子工程师协会 (IEEE) $754$ 双精度。\n-   单位舍入误差：$u = 2^{-53} \\approx 1.11 \\times 10^{-16}$。\n-   函数求值误差模型：$|\\widehat{f}(x) - f(x)| \\le u|f(x)|$，其中 $\\widehat{f}(x)$ 是 $f(x)$ 的计算值。\n-   待分析量：第一次牛顿更新量 $\\Delta x_0 = -f(x_0)/\\widehat{f}'(x_0)$。\n\n**步骤2：使用提取的已知条件进行验证**\n-   **科学依据：**该问题坚实地建立在数值分析的既定原则之上，特别是标量求根（牛顿-拉夫逊法）、数值微分（有限差分）和浮点运算（IEEE $754$ 误差分析）。函数 $f(x)$ 是一个标准例子，用于测试数值算法在存在近乎平坦区域时的稳健性。所有参数都有定义，并与典型的计算工程场景一致。\n-   **适定性：**该问题是适定的。它要求在指定的数值条件下分析一个确定性算法的第一步。结果可以从给定信息中推导出来。\n-   **客观性：**问题陈述以精确、客观的语言表达，没有歧义或主观论断。\n\n**步骤3：结论与行动**\n问题陈述有效。可以推导出严谨的解。\n\n**求解过程**\n牛顿-拉夫逊迭代法由 $x_{k+1} = x_k - f(x_k)/f'(x_k)$ 给出。我们被要求分析第一次更新量 $\\Delta x_0 = -f(x_0)/f'(x_0)$，其中导数 $f'(x_0)$ 通过数值近似为 $\\widehat{f}'(x_0)$。\n\n首先，让我们在初始猜测值 $x_0 = 1 + 10^{-3}$ 处计算函数值：\n$$\nf(x_0) = f(1 + 10^{-3}) = ((1 + 10^{-3}) - 1)^8 - 10^{-8} = (10^{-3})^8 - 10^{-8} = 10^{-24} - 10^{-8}\n$$\n在浮点运算中，$10^{-24}$ 这一项远小于 $10^{-8}$，会因为吸收或舍入而丢失。因此，计算值将近似为 $\\widehat{f}(x_0) \\approx -10^{-8}$。\n\n接下来，我们分析在 $x_0$ 处的导数数值近似：\n$$\n\\widehat{f}'(x_0) = \\frac{\\widehat{f}(x_0+h) - \\widehat{f}(x_0-h)}{2h}\n$$\n其中 $x_0 = 1 + 10^{-3}$ 且 $h = 10^{-16}$。\n\n分析的核心在于计算分子 $\\widehat{f}(x_0+h) - \\widehat{f}(x_0-h)$。这涉及两个几乎相等的数相减，是灾难性抵消的典型场景。\n\n让我们确定被减项的量级。对于 $x_0$ 邻域内的 $y$，函数值为：\n$$\nf(y) = (y-1)^8 - 10^{-8} \\approx (x_0-1)^8 - 10^{-8} = (10^{-3})^8 - 10^{-8} \\approx -10^{-8}\n$$\n因此，$f(x_0+h)$ 和 $f(x_0-h)$ 都非常接近 $-10^{-8}$。\n\n根据问题的误差模型，计算值 $\\widehat{f}(y)$ 的绝对误差为 $|\\widehat{f}(y) - f(y)| \\le u|f(y)|$。对于 $y=x_0 \\pm h$，这个绝对误差近似为：\n$$\n\\text{Error}(\\widehat{f}(y)) \\approx u |f(y)| \\approx (1.11 \\times 10^{-16}) \\times |-10^{-8}| \\approx 1.11 \\times 10^{-24}\n$$\n分子的真实值由泰勒展开给出：\n$$\nf(x_0+h) - f(x_0-h) = 2h f'(x_0) + O(h^3)\n$$\n精确导数为 $f'(x) = 8(x-1)^7$。在 $x_0$ 处，其值为 $f'(x_0) = 8(10^{-3})^7 = 8 \\times 10^{-21}$。\n所以，分子的真实值近似为 $2h f'(x_0) = 2(10^{-16})(8 \\times 10^{-21}) = 1.6 \\times 10^{-36}$。\n\n当计算分子 $\\widehat{f}(x_0+h) - \\widehat{f}(x_0-h)$ 时，真实值 ($1.6 \\times 10^{-36}$) 完全被这两项的舍入误差所淹没。两个数的相减，每个数都有大约 $10^{-24}$ 的绝对舍入误差，导致计算出的差值实际上是噪声。这个噪声的量级与原始舍入误差的量级相当。\n$$\n|\\text{Numerator}| \\approx |\\widehat{f}(x_0+h) - \\widehat{f}(x_0-h)| \\approx u|f(x_0)| \\sim 10^{-24}\n$$\n这个结果的符号基本上是随机的。\n\n现在，我们可以估计计算出的导数：\n$$\n\\widehat{f}'(x_0) = \\frac{\\text{Numerator}}{2h} \\approx \\frac{\\pm O(10^{-24})}{2 \\times 10^{-16}} \\approx \\pm O(0.5 \\times 10^{-8}) = \\pm O(5 \\times 10^{-9})\n$$\n计算出的导数量级约为 $5 \\times 10^{-9}$。\n\n最后，我们计算牛顿更新量 $\\Delta x_0$：\n$$\n\\Delta x_0 = -\\frac{\\widehat{f}(x_0)}{\\widehat{f}'(x_0)} \\approx -\\frac{-10^{-8}}{\\pm 5 \\times 10^{-9}} = \\pm \\frac{10^{-8}}{5 \\times 10^{-9}} = \\pm 2\n$$\n牛顿更新量的量级约为 $2$。这将使得下一次迭代值 $x_1 = x_0 + \\Delta x_0 \\approx 1.001 \\pm 2$，该值远离真实根（真实根在 $x=1.1$ 和 $x=0.9$ 附近）。\n\n**逐项分析**\n\nA. 分子 $f(x_0+h)-f(x_0-h)$ 被舍入误差主导，因此 $\\widehat{f}'(x_0)$ 的量级约为 $5\\times 10^{-9}$ 且 $\\Delta x_0\\approx +2$，导致 $x_1$ 远离根。\n该选项正确地指出了分子被舍入误差（灾难性抵消）主导。计算出的导数量级 $\\approx 5 \\times 10^{-9}$ 和随后的牛顿更新量 $\\Delta x_0 \\approx +2$ 与我们的推导完全相符。迭代值将远离根的结论也是正确的。更新量的符号取决于舍入误差的随机符号，但其量级是数值失效的关键指标。\n结论：**正确**。\n\nB. 有限差分得到的结果恰好是 $\\widehat{f}'(x_0)=0$，因此牛顿更新量因除以零而未定义。\n如果参数的浮点表示完全相同，即 $fl(x_0+h) = fl(x_0-h)$，就会出现这种情况。由于 $h = 10^{-16}$，且在 $1$ 附近的浮点数间距为 $\\text{ulp}(1) = 2^{-52} \\approx 2.22 \\times 10^{-16}$，参数之间的距离 $2h=2 \\times 10^{-16}$ 与一个 ulp（最小精度单位）相当。不能保证它们会舍入为同一个数。更普遍的现象是灾难性抵消产生一个无意义的、非零的结果。因此，与A中所述相比，这种特定结果对一般问题的代表性较差。\n结论：**不正确**。\n\nC. 有限差分的相对误差精度为 $\\mathcal{O}(u)$，因此 $\\widehat{f}'(x_0)\\approx f'(x_0)=8\\times 10^{-21}$ 且 $\\Delta x_0\\approx +1.25\\times 10^{12}$。\n该选项声称导数计算是准确的。这根本上是错误的。所选步长 $h = 10^{-16}$ 太小，导致灾难性抵消，而不是准确的结果。与 $u/h$ 成正比的舍入误差主导了与 $h^2$ 成正比的截断误差。所提供的计算对应于没有舍入误差的理想情况，这与问题设置相矛盾。\n结论：**不正确**。\n\nD. 选择更小的步长，例如 $h=10^{-20}$，会减少 $f(x_0+h)-f(x_0-h)$ 中的相减抵消，并恢复可靠的导数估计和收敛性。\n这个说法是不正确的。在有限差分公式中，由相减抵消引起的误差量级为 $O(u/h)$。将 $h$ 从 $10^{-16}$ 减小到 $10^{-20}$ 会*增加*舍入误差，使导数估计更加不可靠。为了获得更好的估计，必须选择一个更大的步长，以平衡舍入误差和截断误差（其量级为 $O(h^2)$）。\n结论：**不正确**。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "精确计算管道中的流体摩擦是流体力学工程中的一项基本任务，对设计高效的输送系统至关重要。隐式的科尔布鲁克方程是该领域的行业标准，而本练习  提供了在实际工程情景中，使用牛顿-拉弗森法求解该方程的动手实践。",
            "id": "2434180",
            "problem": "考虑用于模拟圆形管道中完全湍流内部流动的达西摩擦系数的隐式 Colebrook 关系式，其形式如下\n$$\n\\frac{1}{\\sqrt{f_D}} \\;=\\; -2.0\\,\\log_{10}\\!\\left(\\frac{\\epsilon/D}{3.7} \\;+\\; \\frac{2.51}{\\text{Re}\\,\\sqrt{f_D}}\\right),\n$$\n其中，$f_D$ 是达西摩擦系数（无量纲），$\\epsilon/D$ 是相对粗糙度（无量纲），$\\text{Re}$ 是雷诺数（无量纲），$\\log_{10}$ 表示以 10 为底的对数。对于下面的每一组参数，请确定唯一的、物理上相关的解 $f_D \\in (0,1)$，该解满足方程本身，且绝对残差容差在 $10^{-12}$ 以内。\n\n使用以下参数值 $(\\text{Re},\\,\\epsilon/D)$ 的测试套件：\n- 测试 $1$：$(10^5,\\;0)$\n- 测试 $2$：$(4000,\\;10^{-4})$\n- 测试 $3$：$(10^6,\\;2.5\\times 10^{-4})$\n- 测试 $4$：$(10^7,\\;5.0\\times 10^{-3})$\n- 测试 $5$：$(3.0\\times 10^4,\\;10^{-2})$\n\n要求：\n- 将所有量视为无量纲。\n- 对于每次测试，返回满足方程且绝对残差小于 $10^{-12}$ 的单个标量 $f_D$。\n- 将每个报告的 $f_D$ 四舍五入到 8 位小数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，顺序与测试顺序相同，例如 $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5]$，其中每个 $\\text{result}_i$ 是相应测试中 $f_D$ 的四舍五入值。",
            "solution": "所提出的问题是针对隐式 Colebrook 方程的标准求根任务，该方程是流体力学中关于湍流管道流动的基本关系式。需要使用数值方法，根据给定的雷诺数 $\\text{Re}$ 和相对粗糙度 $\\epsilon/D$ 的值来确定达西摩擦系数 $f_D$。\n\n控制方程为：\n$$\n\\frac{1}{\\sqrt{f_D}} \\;=\\; -2.0\\,\\log_{10}\\!\\left(\\frac{\\epsilon/D}{3.7} \\;+\\; \\frac{2.51}{\\text{Re}\\,\\sqrt{f_D}}\\right)\n$$\n为了应用求根算法，我们必须首先将方程表示为标准形式 $g(f_D) = 0$。这通过重新排列各项来实现：\n$$\ng(f_D) = \\frac{1}{\\sqrt{f_D}} + 2.0\\,\\log_{10}\\!\\left(\\frac{\\epsilon/D}{3.7} \\;+\\; \\frac{2.51}{\\text{Re}\\,\\sqrt{f_D}}\\right) = 0\n$$\n牛顿-拉夫逊（Newton-Raphson）方法是解决此问题的有效选择，在给定良好初始估计值的情况下，它能提供二次收敛。该方法需要函数 $g(f_D)$ 及其导数 $g'(f_D)$。为了方便求导，以 10 为底的对数可以用自然对数表示：$\\log_{10}(x) = \\ln(x) / \\ln(10)$。\n我们定义常数 $C_1 = \\frac{\\epsilon/D}{3.7}$ 和 $C_2 = \\frac{2.51}{\\text{Re}}$。函数 $g(f_D)$ 于是为：\n$$\ng(f_D) = f_D^{-1/2} + \\frac{2.0}{\\ln(10)} \\ln\\left( C_1 + C_2 f_D^{-1/2} \\right)\n$$\n$g(f_D)$ 相对于 $f_D$ 的导数通过应用标准微分法则求得：\n$$\ng'(f_D) = \\frac{d}{df_D} \\left( f_D^{-1/2} \\right) + \\frac{2.0}{\\ln(10)} \\frac{d}{df_D} \\left( \\ln\\left( C_1 + C_2 f_D^{-1/2} \\right) \\right)\n$$\n使用幂法则和链式法则，我们得到：\n$$\ng'(f_D) = -\\frac{1}{2} f_D^{-3/2} + \\frac{2.0}{\\ln(10)} \\frac{1}{C_1 + C_2 f_D^{-1/2}} \\left( C_2 \\cdot \\left(-\\frac{1}{2} f_D^{-3/2}\\right) \\right)\n$$\n提取公因式 $-\\frac{1}{2} f_D^{-3/2}$ 可以简化导数的表达式：\n$$\ng'(f_D) = -\\frac{1}{2} f_D^{-3/2} \\left[ 1 + \\frac{2.0 C_2}{\\ln(10) \\left( C_1 + C_2 f_D^{-1/2} \\right)} \\right]\n$$\n牛顿-拉夫逊迭代方案由以下关系定义：\n$$\nf_{D, n+1} = f_{D, n} - \\frac{g(f_{D, n})}{g'(f_{D, n})}\n$$\n其中 $n$ 是迭代指数。该过程必须从一个初始猜测值 $f_{D, 0}$ 开始。高质量的初始猜测能确保快速稳定的收敛。为此，我们使用显式 Haaland 方程，这是一个著名且精确的摩擦系数近似公式：\n$$\n\\frac{1}{\\sqrt{f_{D, 0}}} = -1.8 \\log_{10} \\left[ \\left(\\frac{\\epsilon/D}{3.7}\\right)^{1.11} + \\frac{6.9}{\\text{Re}} \\right]\n$$\n由此可分离出 $f_{D,0}$：\n$$\nf_{D, 0} = \\left( -1.8 \\log_{10} \\left[ \\left(\\frac{\\epsilon/D}{3.7}\\right)^{1.11} + \\frac{6.9}{\\text{Re}} \\right] \\right)^{-2}\n$$\n当残差的绝对值 $|g(f_{D, n})|$ 小于所需容差 $10^{-12}$ 时，迭代过程终止。\n\n要实现的算法如下：\n$1$. 对于每对参数 $(\\text{Re}, \\epsilon/D)$，计算常数 $C_1$ 和 $C_2$。\n$2$. 使用 Haaland 方程计算初始猜测值 $f_{D,0}$。\n$3$. 开始牛顿-拉夫逊迭代循环。在每一步中，计算 $g(f_{D,n})$ 和 $g'(f_{D,n})$。\n$4$. 检查是否 $|g(f_{D,n})| \\leq 10^{-12}$。如果为真，则解已收敛。\n$5$. 如果未收敛，计算下一个近似值 $f_{D,n+1}$ 并继续循环。应包含最大迭代次数的保障措施。\n$6$. 收敛后，按要求将最终的 $f_D$ 值四舍五入到 8 位小数。\n此过程将应用于每个测试用例以生成最终结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Colebrook equation for the Darcy friction factor for a given\n    set of test cases using the Newton-Raphson method.\n    \"\"\"\n    TOLERANCE = 1e-12\n    MAX_ITERATIONS = 50\n\n    def solve_colebrook(Re, rel_rough):\n        \"\"\"\n        Calculates the Darcy friction factor f_D using Newton-Raphson.\n\n        Args:\n            Re (float): Reynolds number.\n            rel_rough (float): Relative roughness (epsilon/D).\n\n        Returns:\n            float: The calculated Darcy friction factor.\n        \"\"\"\n        # 1. Initial guess for f_D using the Haaland equation.\n        # This provides a very accurate starting point for the iteration.\n        haaland_term = (rel_rough / 3.7)**1.11 + 6.9 / Re\n        f_d = (-1.8 * np.log10(haaland_term))**-2\n\n        # 2. Define constants for the Colebrook equation.\n        c1 = rel_rough / 3.7\n        c2 = 2.51 / Re\n        ln10 = np.log(10)\n\n        # 3. Perform Newton-Raphson iteration.\n        for _ in range(MAX_ITERATIONS):\n            sqrt_fd = np.sqrt(f_d)\n            \n            # The function g(f_D) whose root we are seeking.\n            # g(f_D) = 1/sqrt(f_D) + 2.0*log10(c1 + c2/sqrt(f_D))\n            log_term_val = c1 + c2 / sqrt_fd\n            g = 1.0 / sqrt_fd + (2.0 / ln10) * np.log(log_term_val)\n\n            # Check for convergence based on the residual of the function g(f_D).\n            if abs(g) = TOLERANCE:\n                break\n            \n            # The derivative of the function, g'(f_D).\n            # g'(f_D) = -0.5*f_D**(-1.5) * [1 + (2.0*c2 / (ln(10)*(c1 + c2/sqrt(f_D))))]\n            g_prime = (-0.5 * f_d**-1.5) * (1.0 + (2.0 * c2) / (ln10 * log_term_val * sqrt_fd))\n            \n            # Update step for Newton-Raphson method.\n            f_d = f_d - g / g_prime\n        \n        return f_d\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1e5, 0.0),             # Test 1\n        (4000.0, 1e-4),         # Test 2\n        (1e6, 2.5e-4),          # Test 3\n        (1e7, 5.0e-3),          # Test 4\n        (3.0e4, 1e-2)           # Test 5\n    ]\n\n    results = []\n    for Re_val, rel_rough_val in test_cases:\n        # Calculate the friction factor for the current case.\n        f_d_solution = solve_colebrook(Re_val, rel_rough_val)\n        # Round the result to 8 decimal places as required.\n        results.append(f\"{f_d_solution:.8f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}