{
    "hands_on_practices": [
        {
            "introduction": "为了构建收敛更快的求解器，我们通常会从牛顿法等基本方法出发，添加校正项。本练习  将引导你完成严谨的数学分析，以确定这种构造方法的收敛阶。通过泰勒级数展开，你将精确地看到高阶收敛是如何实现的，以及为何这个被称为“King方法族”的特定形式能够稳定地达到三阶收敛。",
            "id": "2381957",
            "problem": "考虑一个标量非线性方程 $f(x)=0$，它在 $x=\\alpha$ 处有一个单根，即 $f(\\alpha)=0$ 且 $f'(\\alpha)\\neq 0$。假设 $f$ 在 $\\alpha$ 的一个邻域内三阶连续可微。对于一个足够接近 $\\alpha$ 的初始猜测值 $x_0$，考虑单参数迭代法\n$$\nx_{k+1} \\;=\\; x_k \\;-\\; \\frac{f(x_k)}{f'(x_k)} \\;-\\; \\frac{f(x_k)^{2}\\,f''(x_k)}{2\\,f'(x_k)^{3}\\,\\bigl(1 + \\beta\\,f(x_k)/f'(x_k)\\bigr)},\n$$\n其中 $\\beta\\in\\mathbb{R}$ 是一个固定参数，并假设分母在迭代过程中不为零。\n\n使用误差序列 $e_k=x_k-\\alpha$ 的收敛阶 $p$ 的定义，即存在一个有限常数 $C\\neq 0$ 使得 $\\lim_{k\\to\\infty}\\frac{|e_{k+1}|}{|e_k|^{p}}=|C|$，在上述假设下，确定此方法对于任意实数 $\\beta$ 的收敛阶 $p$。请以单个整数形式提供最终答案。无需四舍五入，也无需单位。",
            "solution": "问题陈述的有效性已确认。这是一个数值分析中的适定问题，没有科学或逻辑上的缺陷。\n\n为了确定给定迭代法的收敛阶，我们分析第 $k+1$ 步的误差 $e_{k+1} = x_{k+1} - \\alpha$ 与第 $k$ 步的误差 $e_k = x_k - \\alpha$ 之间的关系。收敛阶是一个整数 $p$，使得当 $k \\to \\infty$ 时，对于某个常数 $C \\neq 0$，有 $e_{k+1} = C e_k^p + O(e_k^{p+1})$。\n\n迭代公式由下式给出：\n$$\nx_{k+1} = x_k - \\frac{f(x_k)}{f'(x_k)} - \\frac{f(x_k)^{2}\\,f''(x_k)}{2\\,f'(x_k)^{3}\\,\\bigl(1 + \\beta\\,f(x_k)/f'(x_k)\\bigr)}\n$$\n从两边减去根 $\\alpha$ 得到误差递推关系：\n$$\ne_{k+1} = e_k - \\frac{f(x_k)}{f'(x_k)} - \\frac{f(x_k)^{2}\\,f''(x_k)}{2\\,f'(x_k)^{3}\\,\\bigl(1 + \\beta\\,f(x_k)/f'(x_k)\\bigr)}\n$$\n我们的分析依赖于 $f(x)$ 及其导数在单根 $\\alpha$ 附近的泰勒级数展开，其中 $f(\\alpha)=0$ 且 $f'(\\alpha)\\neq 0$。我们假设 $f$ 在 $\\alpha$ 的一个邻域内至少三阶连续可微。设 $e_k = x_k - \\alpha$。泰勒展开式为：\n$$\nf(x_k) = f(\\alpha+e_k) = f'(\\alpha)e_k + \\frac{f''(\\alpha)}{2}e_k^2 + \\frac{f'''(\\alpha)}{6}e_k^3 + O(e_k^4)\n$$\n$$\nf'(x_k) = f'(\\alpha+e_k) = f'(\\alpha) + f''(\\alpha)e_k + \\frac{f'''(\\alpha)}{2}e_k^2 + O(e_k^3)\n$$\n$$\nf''(x_k) = f''(\\alpha+e_k) = f''(\\alpha) + f'''(\\alpha)e_k + O(e_k^2)\n$$\n为了简化表达式，我们记 $A=f'(\\alpha)$，$B=f''(\\alpha)$，以及 $C=f'''(\\alpha)$，其中 $A \\neq 0$。\n\n首先，我们分析对应于牛顿法的项 $\\frac{f(x_k)}{f'(x_k)}$：\n$$\n\\frac{f(x_k)}{f'(x_k)} = \\frac{A e_k + \\frac{B}{2} e_k^2 + \\frac{C}{6} e_k^3 + O(e_k^4)}{A + B e_k + \\frac{C}{2} e_k^2 + O(e_k^3)}\n$$\n从分子中提出 $e_k$，从分母中提出 $A$：\n$$\n\\frac{f(x_k)}{f'(x_k)} = \\frac{e_k(A + \\frac{B}{2} e_k + \\frac{C}{6} e_k^2 + \\dots)}{A(1 + \\frac{B}{A} e_k + \\frac{C}{2A} e_k^2 + \\dots)} = e_k \\left(1 + \\frac{B}{2A} e_k + \\frac{C}{6A} e_k^2 + \\dots\\right) \\left(1 - \\frac{B}{A} e_k + \\left(\\frac{B^2}{A^2}-\\frac{C}{2A}\\right)e_k^2 + \\dots\\right)\n$$\n展开并合并截至 $O(e_k^3)$ 的项：\n$$\n\\frac{f(x_k)}{f'(x_k)} = e_k \\left(1 + \\left(\\frac{B}{2A} - \\frac{B}{A}\\right)e_k + \\left(\\frac{C}{6A} - \\frac{B^2}{2A^2} + \\frac{B^2}{A^2} - \\frac{C}{2A}\\right)e_k^2 + \\dots\\right)\n$$\n$$\n\\frac{f(x_k)}{f'(x_k)} = e_k - \\frac{B}{2A}e_k^2 + \\left(\\frac{B^2}{2A^2} - \\frac{C}{3A}\\right)e_k^3 + O(e_k^4)\n$$\n误差递推关系的第一部分，即牛顿法的误差，为：\n$$\ne_k - \\frac{f(x_k)}{f'(x_k)} = \\frac{B}{2A}e_k^2 - \\left(\\frac{B^2}{2A^2} - \\frac{C}{3A}\\right)e_k^3 + O(e_k^4)\n$$\n这表明牛顿法本身是二次收敛的（$p=2$）。\n\n现在，我们分析修正项：\n$$\n\\text{修正项} = \\frac{f(x_k)^{2}\\,f''(x_k)}{2\\,f'(x_k)^{3}\\,\\bigl(1 + \\beta\\,f(x_k)/f'(x_k)\\bigr)}\n$$\n我们将此项的每个组成部分展开为 $e_k$ 的幂级数。\n- 分子：\n  $f(x_k)^2 = (A e_k + \\frac{B}{2} e_k^2 + O(e_k^3))^2 = A^2 e_k^2 + A B e_k^3 + O(e_k^4)$\n  $f''(x_k) = B + C e_k + O(e_k^2)$\n  $f(x_k)^2 f''(x_k) = (A^2 e_k^2 + A B e_k^3 + O(e_k^4))(B + C e_k + O(e_k^2)) = A^2 B e_k^2 + (A^2 C + A B^2) e_k^3 + O(e_k^4)$\n- 分母：\n  $f'(x_k)^3 = (A + B e_k + O(e_k^2))^3 = A^3 + 3 A^2 B e_k + O(e_k^2)$\n  $f(x_k)/f'(x_k) = e_k - \\frac{B}{2A}e_k^2 + O(e_k^3)$\n  $1 + \\beta f(x_k)/f'(x_k) = 1 + \\beta e_k - \\frac{\\beta B}{2A} e_k^2 + O(e_k^3)$\n  分母为 $2(A^3 + 3A^2 B e_k + O(e_k^2))(1 + \\beta e_k + O(e_k^2)) = 2A^3(1 + (\\frac{3B}{A} + \\beta)e_k + O(e_k^2))$。\n\n修正项变为：\n$$\n\\frac{A^2 B e_k^2 + (A^2 C + A B^2) e_k^3 + O(e_k^4)}{2A^3(1 + (\\frac{3B}{A} + \\beta)e_k + O(e_k^2))} = \\frac{e_k^2(A^2 B + (A^2 C + A B^2) e_k + \\dots)}{2A^3} \\left(1 - (\\frac{3B}{A} + \\beta)e_k + \\dots\\right)\n$$\n$$\n= \\frac{1}{2A^3} \\left[ A^2 B e_k^2 + \\left(A^2 C + A B^2 - A^2 B(\\frac{3B}{A} + \\beta)\\right)e_k^3 + O(e_k^4) \\right]\n$$\n$$\n= \\frac{B}{2A} e_k^2 + \\frac{1}{2A^3} \\left(A^2 C + A B^2 - 3AB^2 - \\beta A^2 B\\right)e_k^3 + O(e_k^4)\n$$\n$$\n= \\frac{B}{2A} e_k^2 + \\left(\\frac{C}{2A} - \\frac{B^2}{A^2} - \\frac{\\beta B}{2A}\\right)e_k^3 + O(e_k^4)\n$$\n现在，我们将这些展开式代回到 $e_{k+1}$ 的误差递推关系中：\n$$\ne_{k+1} = \\left[ \\frac{B}{2A}e_k^2 - \\left(\\frac{B^2}{2A^2} - \\frac{C}{3A}\\right)e_k^3 \\right] - \\left[ \\frac{B}{2A} e_k^2 + \\left(\\frac{C}{2A} - \\frac{B^2}{A^2} - \\frac{\\beta B}{2A}\\right)e_k^3 \\right] + O(e_k^4)\n$$\n$e_k^2$ 阶的项相互抵消，这是一个关键的观察。这意味着收敛阶至少为 $3$。\n$$\ne_{k+1} = \\left[ -\\frac{B^2}{2A^2} + \\frac{C}{3A} - \\frac{C}{2A} + \\frac{B^2}{A^2} + \\frac{\\beta B}{2A} \\right] e_k^3 + O(e_k^4)\n$$\n合并 $e_k^3$ 项的系数：\n$$\ne_{k+1} = \\left[ \\left(1 - \\frac{1}{2}\\right)\\frac{B^2}{A^2} + \\left(\\frac{1}{3} - \\frac{1}{2}\\right)\\frac{C}{A} + \\frac{\\beta B}{2A} \\right] e_k^3 + O(e_k^4)\n$$\n$$\ne_{k+1} = \\left( \\frac{B^2}{2A^2} - \\frac{C}{6A} + \\frac{\\beta B}{2A} \\right) e_k^3 + O(e_k^4)\n$$\n渐进误差常数为 $C_3 = \\frac{3B^2 - AC + 3\\beta AB}{6A^2}$。用函数在 $\\alpha$ 处的导数重写：\n$$\nC_3 = \\frac{3(f''(\\alpha))^2 - f'(\\alpha)f'''(\\alpha) + 3\\beta f'(\\alpha)f''(\\alpha)}{6(f'(\\alpha))^2}\n$$\n收敛阶为 $3$，前提是这个常数 $C_3$ 通常不为零。对于任意给定的实数值 $\\beta$，我们可以构造一个函数 $f(x)$ 使得 $C_3 \\neq 0$。例如，对于 $f(x)=x^2-1$ 在 $\\alpha=1$ 处，我们有 $f'(\\alpha)=2, f''(\\alpha)=2, f'''(\\alpha)=0$，这导致 $C_3 = \\frac{12+12\\beta}{24} = \\frac{1+\\beta}{2}$，除非 $\\beta=-1$，否则它不为零。如果我们选择 $f(x) = \\exp(x)-1$ 在 $\\alpha=0$ 处，我们有 $f'(\\alpha)=f''(\\alpha)=f'''(\\alpha)=1$，这导致 $C_3 = \\frac{3-1+3\\beta}{6} = \\frac{2+3\\beta}{6}$，除非 $\\beta=-2/3$，否则它不为零。\n由于对于任何给定的 $\\beta$，总可以找到一个函数 $f(x)$ 使得 $C_3 \\neq 0$，因此不能保证收敛阶高于 $3$。由于已证明对于任何函数 $f$（其中 $f'(\\alpha)\\neq 0$）和任何 $\\beta$，$e_k^2$ 项都会消失，所以收敛阶至少为 $3$。\n因此，对于任意实数参数 $\\beta$，该方法的收敛阶为 $3$。",
            "answer": "$$\\boxed{3}$$"
        },
        {
            "introduction": "收敛阶理论并非只是一个抽象概念，它是在为偏微分方程（PDE）等复杂工程问题开发和验证求解器时的一个关键工具。这个实践问题  通过要求你为一个反应扩散方程实现一个“冻结”雅可比的牛顿法，从而将理论与应用联系起来。你将从你的模拟结果中数值化地估计收敛阶，从而亲身体验这些理论指标在真实计算环境中是如何被用来评估求解器性能的。",
            "id": "2381909",
            "problem": "考虑空间区间 $[0,1]$ 上的非线性偏微分方程 $u_t = u_{xx} + u^2$，其具有齐次狄利克雷边界条件 $u(0,t)=0$ 和 $u(1,t)=0$，以及光滑的初始条件 $u(x,0)=u_0(x)$。使用具有 $m$ 个内部点和间距 $h = \\frac{1}{m+1}$ 的均匀网格对空间进行离散化，并令 $u \\in \\mathbb{R}^m$ 表示给定时间的内部值向量。对空间二阶导数使用二阶中心差分近似，因此离散拉普拉斯算子由三对角矩阵 $L \\in \\mathbb{R}^{m \\times m}$ 表示，其对角线元素为 $-\\frac{2}{h^2}$，非对角线元素为 $\\frac{1}{h^2}$。使用时间步长 $\\Delta t > 0$ 的后向欧拉法对时间进行离散化，因此从 $u^n$ 到 $u^{n+1}$ 的单个时间步中，需要求解的非线性系统 $F(u^{n+1})=0$ 定义为\n$$\nF(u) \\equiv u - \\Delta t \\left(Lu + u^{\\circ 2}\\right) - u^n \\in \\mathbb{R}^m,\n$$\n其中 $u^{\\circ 2}$ 表示逐分量平方。\n\n将 $F$ 在向量 $w \\in \\mathbb{R}^m$ 处的雅可比矩阵定义为\n$$\nJ(w) \\equiv I - \\Delta t \\left(L + 2\\,\\mathrm{diag}(w)\\right) \\in \\mathbb{R}^{m \\times m},\n$$\n其中 $I$ 是单位矩阵，$\\mathrm{diag}(w)$ 是对角线上为 $w$ 中元素的对角矩阵。\n\n在每个时间步求解 $F(u)=0$ 的“冻结”雅可比牛顿法定义如下：选择一个固定向量 $w_{\\mathrm{freeze}}$，并通过求解线性系统\n$$\nJ(w_{\\mathrm{freeze}})\\, s^{(k)} = -F\\!\\left(u^{(k)}\\right),\n$$\n来计算类牛顿迭代 $u^{(k+1)} = u^{(k)} + s^{(k)}$，其中雅可比矩阵 $J(w_{\\mathrm{freeze}})$ 在所有内部迭代 $k$ 中保持固定。在本问题中，对于从时间层 $n$ 到 $n+1$ 的单个时间步，取 $w_{\\mathrm{freeze}} = u^n$ 和初始猜测 $u^{(0)} = u^n$。\n\n令序列 $\\{u^{(k)}\\}_{k \\ge 0}$ 表示一个时间步内冻结雅可比法的内部迭代，并定义步长差 $\\delta_k \\equiv \\lVert u^{(k+1)} - u^{(k)} \\rVert_2$（对于 $k \\ge 0$），其中 $\\lVert \\cdot \\rVert_2$ 是欧几里得范数。迭代求解器的渐近收敛阶 $p$ 定义为：存在一个常数 $C > 0$，使得对于足够小的误差 $e_k \\equiv \\lVert u^{(k)} - u^\\star \\rVert_2$，关系式 $e_{k+1} \\approx C\\, e_k^p$ 成立，其中 $u^\\star$ 是 $F(u)=0$ 的精确解。一个消除了未知量 $u^\\star$ 的标准 $p$ 估计器使用步长差：\n$$\n\\widehat{p}_k \\equiv \\frac{\\log\\left(\\delta_{k}/\\delta_{k-1}\\right)}{\\log\\left(\\delta_{k-1}/\\delta_{k-2}\\right)}, \\quad \\text{对于 } k \\ge 2,\n$$\n前提是该方法处于渐近状态且 $\\delta_{k-2},\\delta_{k-1},\\delta_k > 0$。\n\n任务：实现一个完整的程序，该程序\n- 为单个后向欧拉时间步构建如上所述的 $L$ 和 $F$。\n- 实现冻结雅可比牛顿法，其中 $w_{\\mathrm{freeze}} = u^n$ 且 $u^{(0)} = u^n$。\n- 迭代直至满足停止准则 $\\lVert s^{(k)} \\rVert_2 \\le \\varepsilon$ 或达到最大迭代次数 $k_{\\max}$。对 $\\lVert s^{(k)} \\rVert_2$ 使用欧几里得范数。\n- 使用最后三个可用的步长差计算的 $\\widehat{p}_k$ 来估计渐近收敛阶 $p$。如果可用的步长差少于三个，则返回一个非数值指示符（例如，特殊的浮点值 $\\mathrm{NaN}$）。\n- 在网格点 $x_i = i h$（$i = 1,2,\\dots,m$）处使用初始条件 $u^n_i = A \\sin(\\pi x_i)$，其中 $A$ 是给定的振幅，$\\pi$ 是常数 $3.14159\\dots$。\n\n对单个时间步使用以下参数集测试套件：\n- 测试 1：$m = 100$，$\\Delta t = 10^{-3}$，$A = 1.0$，$\\varepsilon = 10^{-12}$，$k_{\\max} = 100$。\n- 测试 2：$m = 100$，$\\Delta t = 5 \\times 10^{-3}$，$A = 2.0$，$\\varepsilon = 10^{-12}$，$k_{\\max} = 100$。\n- 测试 3：$m = 50$，$\\Delta t = 10^{-3}$，$A = 0.1$，$\\varepsilon = 10^{-12}$，$k_{\\max} = 100$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个条目等于相应测试的估计收敛阶 $\\widehat{p}$，并四舍五入到六位小数（例如，$[1.000000,0.998532,1.001247]$）。不涉及物理单位。如果在您自己的辅助计算中出现任何角度，必须以弧度为单位。在输出中，所有小数都应以标准十进制数字表示。",
            "solution": "首先对问题陈述进行严格验证，以确定其科学和数学上的完整性。\n\n### 问题验证\n\n#### 步骤 1：提取的已知信息\n问题提供了以下明确信息：\n-   **控制方程**：非线性偏微分方程 $u_t = u_{xx} + u^2$，定义域为 $x \\in [0,1]$。\n-   **边界条件**：齐次狄利克雷条件，$u(0,t)=0$ 和 $u(1,t)=0$。\n-   **空间离散化**：具有 $m$ 个内部点的均匀网格，网格间距为 $h = \\frac{1}{m+1}$。内部值的向量为 $u \\in \\mathbb{R}^m$。\n-   **离散拉普拉斯算子**：$u_{xx}$ 的二阶中心差分近似由一个三对角矩阵 $L \\in \\mathbb{R}^{m \\times m}$ 表示，其对角线元素为 $-\\frac{2}{h^2}$，非对角线元素为 $\\frac{1}{h^2}$。\n-   **时间离散化**：后向欧拉法，时间步长为 $\\Delta t > 0$。\n-   **非线性系统**：从 $u^n$ 到 $u^{n+1}$ 的一个时间步，需要求解的系统是 $F(u^{n+1})=0$，其中函数 $F: \\mathbb{R}^m \\to \\mathbb{R}^m$ 定义为 $F(u) \\equiv u - \\Delta t \\left(Lu + u^{\\circ 2}\\right) - u^n$。符号 $u^{\\circ 2}$ 表示逐分量平方。\n-   **雅可比矩阵**：$F$ 在向量 $w \\in \\mathbb{R}^m$ 处的雅可比矩阵是 $J(w) \\equiv I - \\Delta t \\left(L + 2\\,\\mathrm{diag}(w)\\right)$，其中 $I$ 是单位矩阵。\n-   **迭代求解器**：一种“冻结”雅可比牛顿法，其中雅可比矩阵固定在 $J(w_{\\mathrm{freeze}})$，且 $w_{\\mathrm{freeze}} = u^n$。迭代的初始猜测是 $u^{(0)} = u^n$。迭代更新为 $u^{(k+1)} = u^{(k)} + s^{(k)}$，其中 $s^{(k)}$ 是线性系统 $J(w_{\\mathrm{freeze}})\\, s^{(k)} = -F\\!\\left(u^{(k)}\\right)$ 的解。\n-   **收敛阶估计**：渐近阶 $p$ 由 $\\widehat{p}_k \\equiv \\frac{\\log\\left(\\delta_{k}/\\delta_{k-1}\\right)}{\\log\\left(\\delta_{k-1}/\\delta_{k-2}\\right)}$（对于 $k \\ge 2$）来估计。步长差为 $\\delta_k \\equiv \\lVert u^{(k+1)} - u^{(k)} \\rVert_2 = \\lVert s^{(k)} \\rVert_2$。如果可用的步长差少于三个，则结果为非数值（NaN）指示符。\n-   **初始数据**：对于所考虑的单个时间步，状态 $u^n$ 由 $u^n_i = A \\sin(\\pi x_i)$ 在网格点 $x_i = i h$（对于 $i = 1, 2, \\dots, m$）给出。\n-   **求解器参数**：停止准则是 $\\lVert s^{(k)} \\rVert_2 \\le \\varepsilon$ 或最大迭代次数 $k_{\\max}$。\n-   **测试用例**：\n    1.  $m = 100$，$\\Delta t = 10^{-3}$，$A = 1.0$，$\\varepsilon = 10^{-12}$，$k_{\\max} = 100$。\n    2.  $m = 100$，$\\Delta t = 5 \\times 10^{-3}$，$A = 2.0$，$\\varepsilon = 10^{-12}$，$k_{\\max} = 100$。\n    3.  $m = 50$，$\\Delta t = 10^{-3}$，$A = 0.1$，$\\varepsilon = 10^{-12}$，$k_{\\max} = 100$。\n\n#### 步骤 2：使用提取的已知信息进行验证\n根据科学有效性和适定性的标准对问题进行评估。\n-   **科学依据**：该问题涉及反应扩散方程的数值解法，这是计算科学中的一个基本课题。所选的数值方法——空间上的有限差分法、时间上的后向欧拉法，以及用于求解由此产生的非线性系统的冻结雅可比牛顿求解器——都是数值分析领域中的标准且经过严格建立的方法。\n-   **适定性与客观性**：该问题以数学的精确性进行了表述。所有的量、算子和算法都有明确的定义。任务是实现一个指定的计算过程并计算一个明确定义的度量。冻结雅可比牛顿法是一种不动点迭代，其收敛性已得到充分理解。预计它会表现出线性收敛（阶数 $p=1$），而问题要求对此阶数进行数值估计。该问题是明确的，并拥有唯一、有意义的求解程序。\n-   **完整性**：为每个测试用例提供了所有必要的参数（$m, \\Delta t, A, \\varepsilon, k_{\\max}$）、定义和初始条件。该问题是自包含的。\n\n#### 步骤 3：结论与行动\n该问题被认为是有效的，因为其在科学上合理，在数学上适定，且是完整的。将提供一个解。\n\n### 解法\n\n该解法需要实现一个用于单个后向欧拉时间步的数值算法。该算法是冻结雅可比牛顿法。对于每个指定的测试用例，需要估计此方法的收敛阶。\n\n首先，建立离散问题。对于给定的内部网格点数 $m$，空间步长为 $h = \\frac{1}{m+1}$。内部点的空间坐标向量为 $x$，其分量为 $x_i = i \\cdot h$（$i=1, \\dots, m$）。\n\n离散拉普拉斯算子 $L \\in \\mathbb{R}^{m \\times m}$ 是一个对称三对角矩阵，其非零元素定义如下：\n$$\nL_{i,j} = \\frac{1}{h^2} \\begin{cases}\n-2  \\text{如果 } i=j \\\\\n1  \\text{如果 } |i-j|=1 \\\\\n0  \\text{其他情况}\n\\end{cases}\n$$\n\n使用给定的振幅 $A$ 和空间坐标构建时间步的初始向量 $u^n \\in \\mathbb{R}^m$：\n$$\nu^n_i = A \\sin(\\pi x_i)\n$$\n\n求解器的核心是冻结雅可比牛顿迭代。雅可比矩阵仅评估一次，使用状态 $u^n$ 作为冻结点 $w_{\\text{freeze}}$。这会产生一个恒定的迭代矩阵：\n$$\nJ_{\\text{freeze}} = J(u^n) = I - \\Delta t \\left(L + 2\\,\\mathrm{diag}(u^n)\\right)\n$$\n其中 $I$ 是 $m \\times m$ 单位矩阵，$\\mathrm{diag}(u^n)$ 是对角线元素为向量 $u^n$ 元素的对角矩阵。\n\n寻找 $u^{n+1}$ 的迭代过程从初始猜测 $u^{(0)} = u^n$ 开始。在每次迭代 $k$ 中，执行以下步骤：\n1.  在当前迭代值 $u^{(k)}$ 处计算残差函数 $F$：\n    $$\n    F(u^{(k)}) = u^{(k)} - \\Delta t (L u^{(k)} + (u^{(k)})^{\\circ 2}) - u^n\n    $$\n2.  求解线性系统以获得牛顿更新步长 $s^{(k)}$：\n    $$\n    J_{\\text{freeze}} s^{(k)} = -F(u^{(k)})\n    $$\n3.  更新解向量：$u^{(k+1)} = u^{(k)} + s^{(k)}$。\n4.  计算更新的欧几里得范数 $\\delta_k = \\lVert s^{(k)} \\rVert_2$，并将其存储。\n当 $\\delta_k \\le \\varepsilon$ 或 $k = k_{\\max}$ 时，该过程终止。\n\n在 $N$ 次迭代后循环终止时（产生步长范数 $\\delta_0, \\dots, \\delta_{N-1}$），估计收敛阶。如果 $N  3$，则没有足够的数据点来应用三点公式，结果为 NaN。否则，使用最后三个可用的步长范数计算估计值 $\\widehat{p}$：\n$$\n\\widehat{p} = \\frac{\\log(\\delta_{N-1}/\\delta_{N-2})}{\\log(\\delta_{N-2}/\\delta_{N-3})}\n$$\n对每个测试用例都执行此计算。该方法的预期理论收敛阶为 $p=1$（线性收敛），因此数值估计 $\\widehat{p}$ 应接近于 $1$。\n\n实现将利用 `numpy` 库进行所有数组、向量和矩阵操作，包括使用 `np.linalg.solve` 求解线性系统。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_frozen_newton_solver(m, delta_t, A, epsilon, k_max):\n    \"\"\"\n    Solves the nonlinear system for one backward Euler step using a frozen Jacobian\n    Newton method and estimates the convergence order.\n    \n    Args:\n        m (int): Number of interior spatial grid points.\n        delta_t (float): Time step size.\n        A (float): Amplitude of the initial sine wave profile.\n        epsilon (float): Tolerance for the stopping criterion.\n        k_max (int): Maximum number of iterations.\n        \n    Returns:\n        float: The estimated convergence order p, or np.nan if not computable.\n    \"\"\"\n    # 1. Setup grid and initial condition for the time step\n    h = 1.0 / (m + 1.0)\n    x = np.arange(1, m + 1) * h\n    u_n = A * np.sin(np.pi * x)\n\n    # 2. Construct discrete Laplacian L\n    h_sq_inv = 1.0 / (h**2)\n    main_diag_L = -2.0 * h_sq_inv * np.ones(m)\n    off_diag_L = h_sq_inv * np.ones(m - 1)\n    L = np.diag(main_diag_L) + np.diag(off_diag_L, k=1) + np.diag(off_diag_L, k=-1)\n    \n    # 3. Construct the frozen Jacobian matrix J_freeze\n    I = np.identity(m)\n    J_freeze = I - delta_t * (L + 2.0 * np.diag(u_n))\n    \n    # 4. Perform frozen Jacobian Newton iterations\n    u_k = np.copy(u_n)  # Initial guess u^(0) = u^n\n    step_diffs = []\n\n    for _ in range(k_max):\n        # Calculate the residual F(u_k)\n        Lu_k = L @ u_k\n        u_k_sq = np.square(u_k)\n        F_u_k = u_k - delta_t * (Lu_k + u_k_sq) - u_n\n        \n        # Solve the linear system for the step s_k\n        s_k = np.linalg.solve(J_freeze, -F_u_k)\n        \n        # Calculate the norm of the step (delta_k)\n        delta_k = np.linalg.norm(s_k, 2)\n        step_diffs.append(delta_k)\n        \n        # Update the solution\n        u_k += s_k\n        \n        # Check stopping criterion\n        if delta_k = epsilon:\n            break\n            \n    # 5. Estimate the convergence order p\n    if len(step_diffs)  3:\n        return np.nan\n        \n    # Use the last three step differences for estimation\n    # delta_k / delta_{k-1}\n    # delta_{k-1} / delta_{k-2}\n    d_last = step_diffs[-1]\n    d_mid = step_diffs[-2]\n    d_first = step_diffs[-3]\n\n    # Guard against division by zero or log of non-positive numbers\n    if d_mid = 0 or d_first = 0:\n        return np.nan\n\n    ratio1 = d_last / d_mid\n    ratio2 = d_mid / d_first\n\n    if ratio1 = 0 or ratio2 = 0 or ratio2 == 1.0:\n        return np.nan\n        \n    p_hat = np.log(ratio1) / np.log(ratio2)\n    \n    return p_hat\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (m, delta_t, A, epsilon, k_max)\n        (100, 1e-3, 1.0, 1e-12, 100),\n        (100, 5e-3, 2.0, 1e-12, 100),\n        (50, 1e-3, 0.1, 1e-12, 100),\n    ]\n\n    results = []\n    for case in test_cases:\n        p_estimate = run_frozen_newton_solver(*case)\n        results.append(p_estimate)\n\n    # Format the final output string\n    formatted_results = []\n    for res in results:\n        if np.isnan(res):\n            formatted_results.append('nan')\n        else:\n            # Round to six decimal places\n            formatted_results.append(f'{res:.6f}')\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "虽然我们通常研究迭代求解器是为了它们收敛到解的能力，但它们也可能表现出更复杂的行为，例如发散或陷入周期循环。这个引人深思的练习  将通常的分析过程颠倒过来：你不再是分析一个给定的函数，而是要去设计一个函数，使得割线法能够产生一个预先确定的周期循环。这个实践揭示了迭代背后潜在的代数结构，并表明即使是简单的求解器，其动力学行为也可能惊人地丰富。",
            "id": "2381953",
            "problem": "考虑用于求解标量非线性方程 $f(x)=0$ 的割线法，其迭代公式定义为\n$$\nx_{k+1} \\;=\\; x_k \\;-\\; f(x_k)\\,\\frac{x_k - x_{k-1}}{\\,f(x_k) - f(x_{k-1})\\,},\n$$\n对于 $k \\geq 1$，给定初始点 $x_0$ 和 $x_1$。设 $x_0 = -1$ 且 $x_1 = 0$。假设存在一个标量函数 $f$，它是对以下数值进行插值的唯一三次多项式\n$$\nf(-1) = y_1,\\quad f(0) = y_2,\\quad f(1) = 1,\\quad f(c) = y_4,\n$$\n其中 $y_1, y_2, y_4$ 是非零实数，而 $c$ 是一个不等于 $1$ 的正实数。要求从 $x_0=-1$ 和 $x_1=0$ 生成的割线法迭代点满足\n$$\nx_2 = 1,\\quad x_3 = c,\\quad x_4 = -1,\\quad x_5 = 0,\n$$\n此后序列以相同的顺序按周期 $4$ 重复。确定存在这样一个函数 $f$ 的唯一正值 $c$。请用精确表达式表示你的最终答案。",
            "solution": "该问题要求找到参数 $c$ 的唯一正值，使得对于一个特定的三次多项式 $f(x)$，割线法能生成一个特定的周期性迭代序列。\n\n割线法的迭代公式为\n$$ x_{k+1} = x_k - f(x_k)\\,\\frac{x_k - x_{k-1}}{f(x_k) - f(x_{k-1})} $$\n该关系式对 $k \\geq 1$ 必须成立。通过代数变换，该方程等价于以下更方便的线性形式：\n$$ f(x_{k-1})(x_{k+1} - x_k) = f(x_k)(x_{k+1} - x_{k-1}) $$\n这种形式避免了可能为零的分母，尽管割线法本身假定 $f(x_k) \\neq f(x_{k-1})$。\n\n问题指定了一个周期为 $4$ 的迭代序列：\n$x_0 = -1$\n$x_1 = 0$\n$x_2 = 1$\n$x_3 = c$\n$x_4 = -1$\n$x_5 = 0$\n\n函数 $f(x)$ 是一个由四个不同点上的插值条件定义的三次多项式。这些点上的函数值为：\n$f(-1) = y_1$\n$f(0) = y_2$\n$f(1) = 1$\n$f(c) = y_4$\n\n我们对连续的 $k$ 值应用割线法关系式。\n\n对于 $k=1$：\n迭代点为 $x_0=-1$、$x_1=0$ 和 $x_2=1$。函数值为 $f(x_0) = f(-1) = y_1$ 和 $f(x_1) = f(0) = y_2$。\n将这些值代入关系式 $f(x_0)(x_2 - x_1) = f(x_1)(x_2 - x_0)$ 中：\n$$ y_1 (1 - 0) = y_2 (1 - (-1)) $$\n$$ y_1 = 2y_2 \\quad (1) $$\n\n对于 $k=2$：\n迭代点为 $x_1=0$、$x_2=1$ 和 $x_3=c$。函数值为 $f(x_1) = f(0) = y_2$ 和 $f(x_2) = f(1) = 1$。\n代入 $f(x_1)(x_3 - x_2) = f(x_2)(x_3 - x_1)$ 中：\n$$ y_2 (c - 1) = 1 (c - 0) $$\n由于 $c \\neq 1$，我们可以写出：\n$$ y_2 = \\frac{c}{c-1} \\quad (2) $$\n\n对于 $k=3$：\n迭代点为 $x_2=1$、$x_3=c$ 和 $x_4=-1$。函数值为 $f(x_2) = f(1) = 1$ 和 $f(x_3) = f(c) = y_4$。\n代入 $f(x_2)(x_4 - x_3) = f(x_3)(x_4 - x_2)$ 中：\n$$ 1 (-1 - c) = y_4 (-1 - 1) $$\n$$ -(c+1) = -2y_4 $$\n$$ y_4 = \\frac{c+1}{2} \\quad (3) $$\n\n对于 $k=4$：\n迭代点为 $x_3=c$、$x_4=-1$ 和 $x_5=0$。函数值为 $f(x_3) = f(c) = y_4$ 和 $f(x_4) = f(-1) = y_1$。\n代入 $f(x_3)(x_5 - x_4) = f(x_4)(x_5 - x_3)$ 中：\n$$ y_4 (0 - (-1)) = y_1 (0 - c) $$\n$$ y_4 = -c y_1 \\quad (4) $$\n\n我们得到了一个关于四个未知数 $y_1, y_2, y_4, c$ 的四元方程组。我们必须解这个方程组来求出 $c$。\n由 $(1)$ 和 $(2)$，我们将 $y_1$ 用 $c$ 表示：\n$$ y_1 = 2y_2 = 2 \\left(\\frac{c}{c-1}\\right) = \\frac{2c}{c-1} $$\n现在我们将 $y_1$ 和 $y_4$ 的表达式（来自 $(3)$）代入方程 $(4)$：\n$$ \\frac{c+1}{2} = -c \\left(\\frac{2c}{c-1}\\right) $$\n$$ \\frac{c+1}{2} = -\\frac{2c^2}{c-1} $$\n问题陈述 $c$ 是一个不等于 $1$ 的正实数，所以 $c-1 \\neq 0$。我们可以在等式两边同乘以 $2(c-1)$ 来消去分母：\n$$ (c+1)(c-1) = -2(2c^2) $$\n$$ c^2 - 1 = -4c^2 $$\n$$ 5c^2 = 1 $$\n$$ c^2 = \\frac{1}{5} $$\n这给出了 $c$ 的两个可能的解：$c = \\frac{1}{\\sqrt{5}}$ 和 $c = -\\frac{1}{\\sqrt{5}}$。\n问题要求 $c$ 的唯一正值。因此，我们必须有：\n$$ c = \\frac{1}{\\sqrt{5}} = \\frac{\\sqrt{5}}{5} $$\n这个值是正数且不等于 $1$，与问题陈述一致。\n我们还必须确保唯一三次多项式的前提成立。这要求插值节点 $x = -1, 0, 1, c$ 是互不相同的。对于 $c=\\frac{\\sqrt{5}}{5}$，这四个点是不同的。\n最后，我们验证对于这个 $c$ 值，$y_1, y_2, y_4$ 均不为零。\n$y_2 = \\frac{c}{c-1} = \\frac{1/\\sqrt{5}}{1/\\sqrt{5}-1} = \\frac{1}{1-\\sqrt{5}} = -\\frac{1+\\sqrt{5}}{4} \\neq 0$。\n$y_1 = 2y_2 = -\\frac{1+\\sqrt{5}}{2} \\neq 0$。\n$y_4 = \\frac{c+1}{2} = \\frac{1/\\sqrt{5}+1}{2} = \\frac{1+\\sqrt{5}}{2\\sqrt{5}} \\neq 0$。\n所有条件都满足。这样一个函数 $f$ 的存在性得到了保证，且 $c$ 的值是唯一确定的。",
            "answer": "$$ \\boxed{\\frac{\\sqrt{5}}{5}} $$"
        }
    ]
}