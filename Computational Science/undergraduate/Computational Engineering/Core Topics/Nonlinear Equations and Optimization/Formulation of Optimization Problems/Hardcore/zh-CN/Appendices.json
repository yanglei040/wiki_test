{
    "hands_on_practices": [
        {
            "introduction": "优化是关于在有限资源下做出最佳决策的科学。这个练习  将带你进入一个经典的营销预算分配场景，你需要将资金分配到不同的渠道以最大化客户转化。通过这个实践，你将学会如何利用凸优化和边际效益递减的原则，将一个商业问题转化为一个可解的数学模型。",
            "id": "2394742",
            "problem": "给定一个分配问题，必须根据数学优化的第一性原理进行建模和求解。存在 $n$ 个营销渠道，索引为 $i \\in \\{1,\\dots,n\\}$。设 $x_i \\ge 0$ 表示分配给渠道 $i$ 的非负支出。目标是最大化总转化数，其模型为各渠道特定转化函数 $f_i(x_i)$ 的总和，同时需满足总预算约束和可选的各渠道支出上限 $u_i \\in (0,+\\infty]$（如果某个渠道未明确指定支出上限，则取 $u_i=+\\infty$）。需要解决的优化问题是：\n最大化 $\\sum_{i=1}^{n} f_i(x_i)$，约束条件为 $\\sum_{i=1}^{n} x_i \\le B$，以及对所有 $i$ 都有 $0 \\le x_i \\le u_i$。\n\n对于此问题，函数 $f_i$ 是从 $[0,+\\infty)$ 到 $[0,+\\infty)$ 的凹、递增、二次连续可微函数，选自以下族，其参数除非另有说明，否则均为严格为正的实数：\n\n- 对数响应（L 型）：$f_i(x) = a_i \\,\\log\\!\\big(1 + b_i x\\big)$，参数 $a_i>0$, $b_i>0$。如果指定 $a_i=0$，则对所有 $x$ 都有 $f_i(x)\\equiv 0$。\n- 平方根响应（S 型）：$f_i(x) = c_i \\,\\sqrt{x}$，参数 $c_i>0$。\n- 指数饱和响应（E 型）：$f_i(x) = d_i \\,\\big(1 - \\exp(-e_i x)\\big)$，参数 $d_i>0$, $e_i>0$。\n\n所有对数均为自然对数，$\\exp(\\cdot)$ 表示指数函数。所有预算和支出均为非负实数。\n\n您的任务是，对于下面指定的每个测试用例，计算满足约束的最优分配 $(x_1,\\dots,x_n)$ 所能达到的总转化数 $\\sum_{i=1}^{n} f_i(x_i)$ 的最大值。每个测试用例的答案必须报告为一个四舍五入到恰好 $6$ 位小数的实数。\n\n测试套件：\n\n- 测试用例 1：\n  - 预算 $B = 100.0$。\n  - 渠道：\n    - 渠道 1：L 型，参数 $a_1=120.0$, $b_1=0.015$，无上限（$u_1=+\\infty$）。\n    - 渠道 2：L 型，参数 $a_2=80.0$, $b_2=0.03$，无上限（$u_2=+\\infty$）。\n    - 渠道 3：E 型，参数 $d_3=200.0$, $e_3=0.02$，无上限（$u_3=+\\infty$）。\n- 测试用例 2：\n  - 预算 $B = 0.0$。\n  - 渠道：\n    - 渠道 1：L 型，参数 $a_1=100.0$, $b_1=0.02$，无上限（$u_1=+\\infty$）。\n    - 渠道 2：S 型，参数 $c_2=50.0$，无上限（$u_2=+\\infty$）。\n- 测试用例 3：\n  - 预算 $B = 50.0$。\n  - 渠道（每个都有明确的上限）：\n    - 渠道 1：S 型，参数 $c_1=40.0$，上限 $u_1=10.0$。\n    - 渠道 2：S 型，参数 $c_2=30.0$，上限 $u_2=5.0$。\n- 测试用例 4：\n  - 预算 $B = 120.0$。\n  - 渠道：\n    - 渠道 1：L 型，参数 $a_1=150.0$, $b_1=0.01$，上限 $u_1=80.0$。\n    - 渠道 2：S 型，参数 $c_2=60.0$，无上限（$u_2=+\\infty$）。\n    - 渠道 3：E 型，参数 $d_3=180.0, e_3=0.05$，上限 $u_3=30.0$。\n    - 渠道 4：L 型，参数 $a_4=0.0$, $b_4=0.02$，无上限（$u_4=+\\infty$）。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按顺序包含测试用例 1、2、3 和 4 的最大总转化数，每个数值都四舍五入到恰好 $6$ 位小数，例如 $[v_1,v_2,v_3,v_4]$，其中每个 $v_k$ 是小数点后恰好有 $6$ 位数字的十进制数。",
            "solution": "所呈现的问题是一个资源分配问题，这是凸优化的一个经典例子。目标是最大化一个总目标函数，该函数是各个凹函数的和，并受限于线性预算约束和变量的箱形约束。\n\n该优化问题可正式表述为：\n$$\n\\begin{aligned}\n\\text{最大化} \\quad  Z = \\sum_{i=1}^{n} f_i(x_i) \\\\\n\\text{约束于} \\quad  \\sum_{i=1}^{n} x_i \\le B \\\\\n 0 \\le x_i \\le u_i, \\quad \\text{对于 } i=1, \\dots, n\n\\end{aligned}\n$$\n这里，$x_i$ 是渠道 $i$ 上的支出，$B$ 是总预算，$u_i$ 是渠道 $i$ 上的支出上限。函数 $f_i(x_i)$ 表示渠道 $i$ 在支出为 $x_i$ 时的转化数。问题陈述每个 $f_i$ 都是凹的、递增的且二次连续可微。凹函数的和也是凹函数。在一个凸可行集（由线性不等式定义）上最大化一个凹函数是一个凸优化问题。\n\n我们可以使用卡罗需-库恩-塔克（KKT）条件来解决这个问题。该问题的拉格朗日函数是：\n$$ L(x, \\lambda, \\mu, \\nu) = \\sum_{i=1}^{n} f_i(x_i) - \\lambda \\left( \\sum_{i=1}^{n} x_i - B \\right) - \\sum_{i=1}^{n} \\mu_i (x_i - u_i) + \\sum_{i=1}^{n} \\nu_i x_i $$\n其中 $\\lambda, \\mu_i, \\nu_i \\ge 0$ 分别是与预算约束、上限约束和非负性约束相关联的拉格朗日乘子。\n\nKKT 平稳性条件对于每个 $i$ 是 $\\frac{\\partial L}{\\partial x_i} = 0$：\n$$ f'_i(x_i) - \\lambda - \\mu_i + \\nu_i = 0 $$\n其中 $f'_i(x_i)$ 是 $f_i$ 关于 $x_i$ 的一阶导数，表示边际转化率。\n\n互补松弛条件为最优解提供了以下关系：\n1. 如果 $0  x_i  u_i$，则 $\\nu_i=0$ 且 $\\mu_i=0$，这意味着 $f'_i(x_i) = \\lambda$。\n2. 如果 $x_i = 0$，则 $\\nu_i \\ge 0$ 且 $\\mu_i=0$，这意味着 $f'_i(0) \\le \\lambda$。\n3. 如果 $x_i = u_i$，则 $\\nu_i = 0$ 且 $\\mu_i \\ge 0$，这意味着 $f'_i(u_i) \\ge \\lambda$。\n\n拉格朗日乘子 $\\lambda$ 可以解释为所花费的最后一美元的边际回报（每单位支出的转化数）。在最优状态下，所有获得非零支出（且未达到其上限）的渠道必须具有相同的边际回报 $\\lambda$。\n\n这一见解为寻找最优分配 $(x_1, \\dots, x_n)$ 提供了一种方法。对于给定的 $\\lambda$ 值，可以确定每个渠道的最优支出 $x_i(\\lambda)$。由于 $f_i$ 是凹函数，$f'_i$ 是一个递减函数。因此，其反函数 $(f'_i)^{-1}$ 也是一个递减函数。对于给定的 $\\lambda$，最优支出 $x_i$ 是：\n$$ x_i(\\lambda) = \\min(u_i, \\max(0, (f'_i)^{-1}(\\lambda))) $$\n\n总支出是 $\\lambda$ 的单调非增函数：$X(\\lambda) = \\sum_{i=1}^n x_i(\\lambda)$。\n我们的任务是找到一个 $\\lambda^* \\ge 0$，使得总预算被用完，即 $X(\\lambda^*) = B$，前提是总无约束支出会超过 $B$。\n\n给定函数族的导数 $f'_i$ 及其反函数 $(f'_i)^{-1}$ 如下：\n- **对数（L 型）：** $f_i(x) = a_i \\log(1 + b_i x)$\n  - $f'_i(x) = \\frac{a_i b_i}{1 + b_i x}$\n  - $(f'_i)^{-1}(\\lambda) = \\frac{a_i}{\\lambda} - \\frac{1}{b_i}$\n- **平方根（S 型）：** $f_i(x) = c_i \\sqrt{x}$\n  - $f'_i(x) = \\frac{c_i}{2\\sqrt{x}}$\n  - $(f'_i)^{-1}(\\lambda) = \\left(\\frac{c_i}{2\\lambda}\\right)^2$\n- **指数饱和（E 型）：** $f_i(x) = d_i (1 - \\exp(-e_i x))$\n  - $f'_i(x) = d_i e_i \\exp(-e_i x)$\n  - $(f'_i)^{-1}(\\lambda) = \\frac{1}{e_i} \\log\\left(\\frac{d_i e_i}{\\lambda}\\right)$\n\n总体算法如下：\n1. 处理平凡情况。如果 $B=0$，则所有 $x_i=0$，总转化数为 $0$。\n2. 计算所有有限上限的总和，$U_{\\text{total}} = \\sum_{i \\text{ s.t. } u_i  \\infty} u_i$。如果问题中存在任何渠道 $u_i = \\infty$，则总容量是无限的。如果所有 $u_i$ 都是有限的且 $B \\ge U_{\\text{total}}$，则预算约束不具约束力。最优解是在每个渠道上都支出到上限，$x_i = u_i$。总转化数为 $\\sum_i f_i(u_i)$。\n3. 如果 $0  B  U_{\\text{total}}$（或 $U_{\\text{total}}=\\infty$），则预算约束是活跃的。我们需要找到唯一的 $\\lambda > 0$ 满足 $\\sum_i x_i(\\lambda) = B$。由于 $X(\\lambda)$ 是单调的，我们可以使用像二分法这样的数值求根算法来高效地找到这个 $\\lambda$。我们在一个区间，比如 $[\\lambda_{\\text{low}}, \\lambda_{\\text{high}}]$ 内，搜索一个 $\\lambda$ 来解方程 $g(\\lambda) = X(\\lambda) - B = 0$。\n4. 二分搜索通过重复缩小搜索区间来进行。在每一步中，我们取当前区间的中点 $\\lambda_{\\text{mid}}$，计算总支出 $X(\\lambda_{\\text{mid}})$，并根据 $X(\\lambda_{\\text{mid}})$ 是大于还是小于 $B$ 来更新区间的下界或上界。\n5. 经过足够次数的迭代后，区间会变得足够小，我们可以取其中点作为最优的 $\\lambda^*$。\n6. 利用最优的 $\\lambda^*$，我们计算每个渠道的最终支出分配 $x_i^* = x_i(\\lambda^*)$。\n7. 然后通过对最优支出产生的转化数求和来计算最大总转化数：$Z^* = \\sum_i f_i(x_i^*)$。\n\n一个特殊情况是某个渠道的主要参数值为零（例如，L 型的 $a_i=0$），这将导致 $f_i(x) \\equiv 0$ 和 $f'_i(x) \\equiv 0$。对于任何 $\\lambda > 0$，条件 $f'_i(0) \\le \\lambda$ 都得到满足，从而正确地得出该渠道的最优支出为 $x_i=0$。\n\n这种方法为给定类别的优化问题提供了一个稳健且通用的解决方案。实现将包括表示渠道响应及其导数的函数，以及一个协调二分搜索的主求解函数。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve all test cases and print the results.\n    \"\"\"\n\n    class ChannelModel:\n        \"\"\"\n        A class to encapsulate the behavior of a single marketing channel.\n        \"\"\"\n        def __init__(self, ch_type, params, u_i):\n            self.ch_type = ch_type\n            self.params = params\n            self.u_i = u_i if u_i is not None else np.inf\n\n            # Pre-calculate derivatives at boundaries for efficiency\n            if self.ch_type == 'S':\n                self.deriv_at_0 = np.inf\n            else:\n                self.deriv_at_0 = self._f_prime(0)\n            \n            self.deriv_at_u = 0\n            if self.u_i  np.inf:\n                self.deriv_at_u = self._f_prime(self.u_i)\n\n        def f(self, x):\n            \"\"\"Calculates the number of conversions for a given spend x.\"\"\"\n            if x  0: x = 0\n            if self.ch_type == 'L':\n                a, b = self.params\n                if a == 0: return 0.0\n                return a * np.log(1 + b * x)\n            elif self.ch_type == 'S':\n                c, = self.params\n                return c * np.sqrt(x)\n            elif self.ch_type == 'E':\n                d, e = self.params\n                return d * (1 - np.exp(-e * x))\n            return 0.0\n\n        def _f_prime(self, x):\n            \"\"\"Calculates the marginal conversion rate (derivative) at spend x.\"\"\"\n            if self.ch_type == 'L':\n                a, b = self.params\n                if a == 0: return 0.0\n                return (a * b) / (1 + b * x)\n            elif self.ch_type == 'S':\n                c, = self.params\n                if x == 0: return np.inf\n                return c / (2 * np.sqrt(x))\n            elif self.ch_type == 'E':\n                d, e = self.params\n                return d * e * np.exp(-e * x)\n            return 0.0\n\n        def _f_prime_inv(self, lam):\n            \"\"\"Calculates spend x for a given marginal return lambda.\"\"\"\n            if lam = 0: return np.inf\n            if self.ch_type == 'L':\n                a, b = self.params\n                if a == 0: return 0.0\n                if lam >= a * b: return 0.0\n                return a / lam - 1 / b\n            elif self.ch_type == 'S':\n                c, = self.params\n                return (c / (2 * lam))**2\n            elif self.ch_type == 'E':\n                d, e = self.params\n                if lam >= d * e: return 0.0\n                return np.log(d * e / lam) / e\n            return 0.0\n\n        def get_spend(self, lam):\n            \"\"\"Determines optimal spend for a given lambda.\"\"\"\n            if lam >= self.deriv_at_0:\n                return 0.0\n            if self.u_i  np.inf and lam = self.deriv_at_u:\n                return self.u_i\n            \n            unbounded_spend = self._f_prime_inv(lam)\n            return min(self.u_i, max(0.0, unbounded_spend))\n\n    def solve_one_case(budget, channels_data):\n        \"\"\"\n        Solves a single instance of the allocation problem.\n        \"\"\"\n        if budget == 0.0:\n            return 0.0\n\n        channels = [ChannelModel(c_type, params, u_i) for c_type, params, u_i in channels_data]\n        \n        total_upper_bound = sum(ch.u_i for ch in channels if ch.u_i  np.inf)\n        if all(ch.u_i  np.inf for ch in channels) and budget >= total_upper_bound:\n            total_conversions = sum(ch.f(ch.u_i) for ch in channels)\n            return total_conversions\n\n        # Bisection search to find the optimal lambda\n        low_lam = 1e-9\n        high_lam = 1e6 # A sufficiently large upper bound for lambda\n        \n        for _ in range(100): # 100 iterations are sufficient for double precision\n            mid_lam = (low_lam + high_lam) / 2\n            current_spend = sum(ch.get_spend(mid_lam) for ch in channels)\n            \n            if current_spend > budget:\n                low_lam = mid_lam\n            else:\n                high_lam = mid_lam\n        \n        final_lambda = (low_lam + high_lam) / 2\n        \n        # Calculate final conversions with the optimal lambda\n        total_conversions = sum(ch.f(ch.get_spend(final_lambda)) for ch in channels)\n        return total_conversions\n\n    test_cases = [\n        {\n            \"B\": 100.0,\n            \"channels\": [\n                ('L', (120.0, 0.015), None),\n                ('L', (80.0, 0.03), None),\n                ('E', (200.0, 0.02), None),\n            ]\n        },\n        {\n            \"B\": 0.0,\n            \"channels\": [\n                ('L', (100.0, 0.02), None),\n                ('S', (50.0,), None),\n            ]\n        },\n        {\n            \"B\": 50.0,\n            \"channels\": [\n                ('S', (40.0,), 10.0),\n                ('S', (30.0,), 5.0),\n            ]\n        },\n        {\n            \"B\": 120.0,\n            \"channels\": [\n                ('L', (150.0, 0.01), 80.0),\n                ('S', (60.0,), None),\n                ('E', (180.0, 0.05), 30.0),\n                ('L', (0.0, 0.02), None),\n            ]\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_one_case(case[\"B\"], case[\"channels\"])\n        results.append(result)\n\n    # Format the final output string\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "许多现实世界中的决策并非连续的，而是“是”或“否”的选择。这个消防站选址练习  就是一个典型的例子，你需要用最少的消防站覆盖城市中的所有建筑。这个实践将引导你将问题构建成一个经典的整数规划问题——集合覆盖问题，从而掌握处理离散决策变量和逻辑约束的建模技巧。",
            "id": "2394756",
            "problem": "给定一个城市，其中有有限个建筑物和有限个可以安置消防站的候选位置。对于每个候选位置和建筑物，都提供了一个以分钟为单位的行驶时间。如果一个消防站到某建筑物的行驶时间小于或等于严格的 $5$ 分钟响应时间阈值，则称该建筑物被该消防站覆盖。目标是决定在哪里安置消防站，以便在覆盖所有建筑物的同时使用尽可能少的消防站数量。所有角度都与此问题无关。所有时间量都以分钟为单位，并且必须完全按照给定的数值处理。\n\n将此问题表述为一个数学优化问题。设建筑物的集合由 $i \\in \\{0,1,\\dots,n-1\\}$ 索引，候选消防站位置的集合由 $j \\in \\{0,1,\\dots,m-1\\}$ 索引。令 $t_{ij}$ 表示从候选消防站 $j$ 到建筑物 $i$ 的行驶时间（以分钟为单位）。定义一个二元覆盖参数\n$$\na_{ij} = \\begin{cases}\n1,  \\text{if } t_{ij} \\le 5 \\\\\n0,  \\text{if } t_{ij}  5\n\\end{cases}.\n$$\n为所有 $j$ 定义决策变量 $x_j \\in \\{0,1\\}$，其中 $x_j = 1$ 表示在候选位置 $j$ 安置一个消防站，否则 $x_j = 0$。该优化问题是：\n$$\n\\min \\sum_{j=0}^{m-1} x_j\n$$\n约束条件为\n$$\n\\sum_{j=0}^{m-1} a_{ij} x_j \\ge 1, \\quad \\forall i \\in \\{0,1,\\dots,n-1\\},\n$$\n$$\nx_j \\in \\{0,1\\}, \\quad \\forall j \\in \\{0,1,\\dots,m-1\\}.\n$$\n\n实现一个完整的、可运行的程序，对于下面的每个测试用例，确定：\n- 所需的最小消防站数量，以及\n- 实现这一最小数量的一个最优消防站索引集（使用从0开始的索引）；如果存在多个最优集，则返回字典序最小的排序索引集，其中字典序的比较方式是将排序后的索引列表视为元组进行比较，\n- 或者确定不存在可行解。\n\n如果不存在可行解（即，至少有一个建筑物不在任何候选消防站的 $5$ 分钟行驶时间内），你的程序必须为该测试用例输出整数 $-1$。否则，对于一个可行的测试用例，你的程序必须输出形如 $[k,[j_1,j_2,\\dots,j_k]]$ 的列表，其中 $k$ 是最小消防站数量，$[j_1,\\dots,j_k]$ 是所选消防站索引的严格递增列表。\n\n测试套件（每个 $T^{(c)}$ 是一个 $m \\times n$ 矩阵；第 $j$ 行和第 $i$ 列给出以分钟为单位的 $t_{ij}$）：\n\n- 测试用例 1：$m=n=5$，\n$$\nT^{(1)}=\\begin{bmatrix}\n4.0  5.0  6.0  6.0  6.2 \\\\\n6.1  3.5  4.0  5.0  6.5 \\\\\n3.0  6.0  6.0  6.0  4.5 \\\\\n7.0  6.8  2.5  3.5  5.5 \\\\\n8.0  7.5  6.2  6.1  1.5\n\\end{bmatrix}.\n$$\n\n- 测试用例 2：$m=n=3$（恰好为 $5$ 分钟的边界覆盖），\n$$\nT^{(2)}=\\begin{bmatrix}\n5.0  5.0  5.0 \\\\\n5.0  6.0  6.0 \\\\\n6.0  5.0  6.0\n\\end{bmatrix}.\n$$\n\n- 测试用例 3：$m=n=2$（不可行），\n$$\nT^{(3)}=\\begin{bmatrix}\n4.0  6.0 \\\\\n6.0  6.1\n\\end{bmatrix}.\n$$\n\n- 测试用例 4：$m=n=4$（多个最优解；必须选择字典序最小的），\n$$\nT^{(4)}=\\begin{bmatrix}\n4.0  6.0  5.0  6.0 \\\\\n5.0  6.0  6.0  4.0 \\\\\n6.0  3.0  4.5  6.0 \\\\\n6.0  4.0  6.0  3.0\n\\end{bmatrix}.\n$$\n\n最终输出格式：你的程序应生成单行输出，其中包含按测试用例 1 到 4 的顺序排列的结果，形式为一个用方括号括起来的、以逗号分隔的列表。对于每个测试用例，如果不可行，则输出 $-1$，或者输出如上定义的形如 $[k,[j_1,\\dots,j_k]]$ 的列表。最终打印的行不得包含任何空格。例如，一个有效的整体输出可能如下所示\n$$\n[[k_1,[j^{(1)}_1,\\dots]],[k_2,[\\dots]],-1,[k_4,[\\dots]]].\n$$",
            "solution": "所呈现的问题是集合覆盖问题的一个经典整数线性规划表述，这是计算工程和运筹学中的一个基本课题。其目标是找到所需的最小消防站数量，以确保城市中的每个建筑物都被覆盖，其中覆盖是由最大响应时间定义的。\n\n对问题陈述的验证证实了其自洽、一致且科学合理。这是一个适定问题，为所有测试用例提供了明确的目标函数、一套完整的约束条件和明确的数据。数学表述\n$$\n\\min \\sum_{j=0}^{m-1} x_j\n$$\n约束条件为\n$$\n\\sum_{j=0}^{m-1} a_{ij} x_j \\ge 1, \\quad \\forall i \\in \\{0,1,\\dots,n-1\\},\n$$\n$$\nx_j \\in \\{0,1\\}, \\quad \\forall j \\in \\{0,1,\\dots,m-1\\},\n$$\n是集合覆盖问题的一个标准且正确的表示。符号定义清晰：$x_j$ 是在候选位置 $j$ 设置消防站的二元决策变量，而 $a_{ij}$ 是一个二元参数，表示消防站 $j$ 是否能在指定的 $5$ 分钟时间阈值内覆盖建筑物 $i$。该问题没有任何科学谬误、模糊不清或矛盾之处，因此被认为是有效的。\n\n问题的核心是选择一个最小规模的候选消防站位置子集，以使每个建筑物都被覆盖。用集合覆盖问题的语言来说，建筑物集合 $\\{0, 1, \\dots, n-1\\}$ 构成了需要被覆盖的元素全集。对于每个候选消防站位置 $j \\in \\{0, 1, \\dots, m-1\\}$，我们可以定义一个集合 $S_j$，其中包含消防站 $j$ 能覆盖的所有建筑物的索引。问题就变成了找到这些集合 $\\{S_j\\}$ 的一个最小子集，其并集能够覆盖整个建筑物全集。\n\n集合覆盖问题是已知的NP难问题。对于大规模实例，通常会采用近似算法或先进的整数线性规划求解器。然而，考虑到所提供测试用例的维度很小（例如，$m, n \\le 5$），通过穷举搜索的直接精确解在计算上是可行的，并能保证最优性。算法流程如下：\n\n首先，我们对输入数据进行预处理。对于每个测试用例，给定 $m \\times n$ 的行驶时间矩阵 $T^{(c)}$，其中第 $j$ 行第 $i$ 列的条目是 $t_{ij}$，我们构建一个 $n \\times m$ 的二元覆盖矩阵 $A$。该矩阵的条目 $a_{ij}$ 在 $t_{ij} \\le 5$ 时为 $1$，否则为 $0$。该矩阵直接表示了覆盖关系：$a_{ij}=1$ 表示消防站 $j$ 覆盖建筑物 $i$。\n\n其次，我们执行不可行性检查。一个可行解的必要前提是，每个建筑物都必须能被至少一个候选消防站覆盖。这通过检查对于每个建筑物 $i$，覆盖矩阵 $A$ 中相应的行至少包含一个非零条目来验证，即 $\\sum_{j=0}^{m-1} a_{ij} \\ge 1$。如果任何建筑物违反了此条件，则没有任何消防站的组合可以覆盖所有建筑物，该问题被宣告为不可行。\n\n第三，如果问题是可行的，我们通过从 $k=1$ 到 $m$ 遍历消防站数量 $k$ 来搜索最优解。对于每个 $k$ 值，我们从 $m$ 个可用候选中生成所有 $k$ 个消防站位置的唯一组合。问题要求在所有最优解中，找到字典序最小的消防站索引集。通过按字典序生成消防站索引的组合，可以自然地处理此要求。对于最小的 $k$ 找到的第一个有效覆盖集，根据构造，就是所要求的最优解。\n\n最后，对于每个生成的 $k$ 个消防站的组合，我们验证它是否构成一个有效的覆盖。如果对于每个建筑物 $i$，所选的 $k$ 个消防站中至少有一个覆盖它，那么这个组合就是一个有效的覆盖。第一个满足此条件的组合就是解。搜索终止，我们报告当前的 $k$ 值和相应的消防站索引集。如果在 $k \\le m$ 的循环中未能找到任何解，这将意味着问题不可行，而这一点已由我们最初的检查处理。因为一个可行问题总会有一个 $k \\le m$ 的解（在最坏的情况下，使用所有为覆盖至少一个唯一的、否则未被覆盖的建筑物做出贡献的消防站），所以搜索保证能找到一个解。",
            "answer": "```python\nimport numpy as np\nfrom itertools import combinations\n\ndef solve():\n    \"\"\"\n    Main function to solve the set of test cases for the fire station location problem.\n    \"\"\"\n    T1 = np.array([\n        [4.0, 5.0, 6.0, 6.0, 6.2],\n        [6.1, 3.5, 4.0, 5.0, 6.5],\n        [3.0, 6.0, 6.0, 6.0, 4.5],\n        [7.0, 6.8, 2.5, 3.5, 5.5],\n        [8.0, 7.5, 6.2, 6.1, 1.5]\n    ])\n\n    T2 = np.array([\n        [5.0, 5.0, 5.0],\n        [5.0, 6.0, 6.0],\n        [6.0, 5.0, 6.0]\n    ])\n\n    T3 = np.array([\n        [4.0, 6.0],\n        [6.0, 6.1]\n    ])\n\n    T4 = np.array([\n        [4.0, 6.0, 5.0, 6.0],\n        [5.0, 6.0, 6.0, 4.0],\n        [6.0, 3.0, 4.5, 6.0],\n        [6.0, 4.0, 6.0, 3.0]\n    ])\n\n    test_cases = [T1, T2, T3, T4]\n    \n    results = []\n    for t_matrix in test_cases:\n        result = solve_set_cover(t_matrix)\n        results.append(result)\n\n    # Format the final output string as specified, with no spaces.\n    results_str = []\n    for res in results:\n        if res == -1:\n            results_str.append(\"-1\")\n        else:\n            k, indices = res\n            indices_str = ','.join(map(str, indices))\n            results_str.append(f\"[{k},[{indices_str}]]\")\n            \n    print(f\"[{','.join(results_str)}]\")\n\ndef solve_set_cover(t_matrix):\n    \"\"\"\n    Solves the set cover problem for a single test case.\n\n    Args:\n        t_matrix (np.ndarray): An m x n matrix of travel times, t_ij is at row j, col i.\n\n    Returns:\n        - A list [k, [j1, j2, ...]] for a feasible solution, where k is the minimum\n          number of stations and [j1, ...] are their indices.\n        - The integer -1 if no feasible solution exists.\n    \"\"\"\n    m, n = t_matrix.shape\n    response_time_threshold = 5.0\n\n    # Build the coverage sets for each station.\n    # station_covers[j] is a set of building indices covered by station j.\n    station_covers = [set() for _ in range(m)]\n    for j in range(m):  # station index\n        for i in range(n):  # building index\n            if t_matrix[j, i] = response_time_threshold:\n                station_covers[j].add(i)\n\n    # Check for infeasibility: any building that cannot be covered by any station.\n    all_coverable_buildings = set()\n    for s in station_covers:\n        all_coverable_buildings.update(s)\n    \n    if len(all_coverable_buildings)  n:\n        return -1\n\n    # Brute-force search for the minimum number of stations (k).\n    # Iterate from k=1 up to m.\n    for k in range(1, m + 1):\n        # Generate combinations of k stations. `itertools.combinations`\n        # generates them in lexicographical order.\n        for station_indices in combinations(range(m), k):\n            covered_buildings = set()\n            for station_idx in station_indices:\n                covered_buildings.update(station_covers[station_idx])\n            \n            # Check if all n buildings are covered.\n            if len(covered_buildings) == n:\n                # This is the first solution found for the smallest k, and it's\n                # the lexicographically smallest set of for that_k. So it's optimal.\n                return [k, list(station_indices)]\n    \n    # This part of the code should not be reachable if the initial\n    # feasibility check is correct. A feasible problem always has a solution.\n    return -1\n\nsolve()\n```"
        },
        {
            "introduction": "优化建模的强大之处在于它能与其它领域的深刻模型相结合，以解决复杂系统的问题。在这个急诊室人员配置的实践  中，你的目标是在预算内优化医护人员的配置，以最小化病人的平均等待时间。此练习挑战你将离散决策与排队论这一随机过程模型相结合，为评估和改善服务系统性能建立一个量化的决策框架。",
            "id": "2394812",
            "problem": "你的任务是为一个模拟医院急诊室的两阶段服务系统，构建并求解一个离散资源分配问题。患者根据泊松过程到达该系统，到达率为 $\\lambda$ (患者/小时)。每位患者必须先由护士服务，然后由医生服务，顺序如此，每个服务站均采用先到先服务 (FCFS) 规则。护士的服务时间是独立同分布的指数随机变量，每位护士的服务率为 $\\mu_n$ (患者/小时)，医生的服务时间是独立同分布的指数随机变量，每位医生的服务率为 $\\mu_d$ (患者/小时)。在任何时候，都有 $c_n$ 名护士和 $c_d$ 名医生并行工作。医院已经安排了 $c_{n,0}$ 名护士和 $c_{d,0}$ 名医生。医院可以为该班次增加 $x_n$ 名护士和 $x_d$ 名医生，每增加一名护士和医生的成本分别为 $k_n$ 和 $k_d$。增加人员的总预算为 $B$，其成本单位与 $k_n$ 和 $k_d$ 相同，因此增加的人员必须满足 $k_n x_n + k_d x_d \\le B$。决策变量 $x_n$ 和 $x_d$ 是非负整数，实际配置的服务人员数量为 $c_n = c_{n,0} + x_n$ 和 $c_d = c_{d,0} + x_d$。一个人员配置方案是可接受的，当且仅当 $\\lambda  c_n \\mu_n$ 和 $\\lambda  c_d \\mu_d$ 成立，以确保相应的 $M/M/c$ 排队系统是稳定的。\n\n将护士阶段的平均排队等待时间（不包括服务时间）定义为 $W_{q,n}(c_n)$，医生阶段的平均排队等待时间定义为 $W_{q,d}(c_d)$，两者均由相应 $M/M/c$ 队列在到达率为 $\\lambda$、单个服务台服务率为 $\\mu$、整数服务台数量为 $c$ 的条件下的稳态决定。患者总平均等待时间为 $W_q^{\\text{total}}(c_n, c_d) = W_{q,n}(c_n) + W_{q,d}(c_d)$。构建一个优化问题，选择 $(x_n, x_d)$ 以最小化 $W_q^{\\text{total}}(c_n, c_d)$，同时满足预算和稳定性约束。你的程序必须通过为可接受的整数分配方案计算明确定义的稳态量，为以下测试套件精确求解此优化问题。\n\n所有物理量的单位均为小时和患者/小时。对于每个测试用例，你的程序必须输出可实现的最小总平均等待时间 $W_q^{\\text{total}}$（以小时为单位），并精确到 $6$ 位小数。不使用角度。不使用百分比。\n\n测试套件（每项指定 $(\\lambda, \\mu_n, \\mu_d, c_{n,0}, c_{d,0}, k_n, k_d, B)$，所有速率单位为 患者/小时，成本单位为任意单位）：\n- 测试 $1$：$(\\lambda = 10.0, \\ \\mu_n = 8.0, \\ \\mu_d = 3.5, \\ c_{n,0} = 2, \\ c_{d,0} = 2, \\ k_n = 1, \\ k_d = 3, \\ B = 3)$。\n- 测试 $2$：$(\\lambda = 5.0, \\ \\mu_n = 6.0, \\ \\mu_d = 3.0, \\ c_{n,0} = 1, \\ c_{d,0} = 2, \\ k_n = 1, \\ k_d = 2, \\ B = 0)$。\n- 测试 $3$：$(\\lambda = 14.0, \\ \\mu_n = 7.0, \\ \\mu_d = 4.0, \\ c_{n,0} = 2, \\ c_{d,0} = 4, \\ k_n = 1, \\ k_d = 2, \\ B = 2)$。\n- 测试 $4$：$(\\lambda = 18.0, \\ \\mu_n = 6.0, \\ \\mu_d = 3.0, \\ c_{n,0} = 4, \\ c_{d,0} = 6, \\ k_n = 1, \\ k_d = 2, \\ B = 4)$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个条目是对应测试的最小总平均等待时间 $W_q^{\\text{total}}$（以小时为单位），精确到 $6$ 位小数。例如，包含三个结果的输出必须类似于 $[0.123456,0.234567,0.345678]$。",
            "solution": "我们首先在标准假设下将每个阶段（护士和医生）建模为 $M/M/c$ 队列：到达是速率为 $\\lambda$ 的泊松过程，服务时间是独立同分布的指数随机变量，单个服务台的服务率为 $\\mu$，并且有 $c$ 个相同的服务台采用先到先服务 (FCFS) 规则。对于一个 $M/M/c$ 队列，其话务量为 $a = \\lambda / \\mu$，利用率为 $\\rho = \\lambda / (c \\mu)$，稳定性要求 $\\rho  1$，即 $\\lambda  c \\mu$。在稳定条件下，一个到达的顾客需要等待的稳态概率，记为 $P_{\\text{wait}}$，由生灭过程归一化推导出的 Erlang C 公式给出：\n$$\nS(c, a) = \\sum_{k=0}^{c-1} \\frac{a^k}{k!}, \\quad \nP_0 = \\left( S(c, a) + \\frac{a^c}{c!} \\cdot \\frac{1}{1 - \\rho} \\right)^{-1}, \\quad \nP_{\\text{wait}} = \\frac{a^c}{c!} \\cdot \\frac{1}{1 - \\rho} \\cdot P_0.\n$$\n那么，在队列中的平均等待时间（不包括服务时间）为\n$$\nW_q(c; \\lambda, \\mu) = \\frac{P_{\\text{wait}}}{c \\mu - \\lambda}.\n$$\n对于护士阶段后跟医生阶段的两阶段串联系统，总平均等待时间是各阶段平均等待时间之和，因为这些阶段是串联的，并且对于给定的 $\\lambda$，每个站点的期望等待时间是可加的：\n$$\nW_q^{\\text{total}}(c_n, c_d) = W_q(c_n; \\lambda, \\mu_n) + W_q(c_d; \\lambda, \\mu_d).\n$$\n\n决策变量是代表增加的护士和医生的非负整数 $x_n$ 和 $x_d$。配置的服务人员数量为 $c_n = c_{n,0} + x_n$ 和 $c_d = c_{d,0} + x_d$。预算约束为\n$$\nk_n x_n + k_d x_d \\le B.\n$$\n稳定性约束为\n$$\n\\lambda  c_n \\mu_n, \\quad \\lambda  c_d \\mu_d.\n$$\n优化问题为\n$$\n\\min_{x_n, x_d \\in \\mathbb{Z}_{\\ge 0}} \\; W_q(c_{n,0} + x_n; \\lambda, \\mu_n) + W_q(c_{d,0} + x_d; \\lambda, \\mu_d)\n$$\n满足约束\n$$\nk_n x_n + k_d x_d \\le B, \\quad \\lambda  (c_{n,0} + x_n) \\mu_n, \\quad \\lambda  (c_{d,0} + x_d) \\mu_d.\n$$\n\n基于原理的推导：\n- $M/M/c$ 模型源于第一性原理，通过将系统建模为连续时间生灭马尔可夫链，其出生率为 $\\lambda$，死亡率取决于系统中的顾客数量，当系统中有 $n$ 个顾客时，死亡率等于 $\\min\\{n, c\\} \\mu$。对稳态分布进行归一化得到 $P_0$（系统中无顾客的概率），而 Erlang C 等待概率则通过对到达时所有服务台都繁忙的情况进行条件化得出。期望等待时间通过利特尔法则 (Little’s Law) 和指数分布的无记忆性得到，对于 $\\rho  1$ 的情况，得出 $W_q(c; \\lambda, \\mu) = P_{\\text{wait}} / (c \\mu - \\lambda)$。\n- 串行组合意味着期望等待时间的线性可加性，因为在稳态下，两个队列由相同的到达率为 $\\lambda$ 的到达过程顺序通过，假设没有中途放弃且从护士到医生的转移是瞬时的。\n\n与公式一致的算法实现：\n- 对于给定的 $(\\lambda, \\mu_n, \\mu_d, c_{n,0}, c_{d,0}, k_n, k_d, B)$，枚举所有满足 $x_n \\ge 0$, $x_d \\ge 0$ 和 $k_n x_n + k_d x_d \\le B$ 的整数对 $(x_n, x_d)$。对每个可行的整数对，计算 $c_n$ 和 $c_d$，检查是否满足 $\\lambda  c_n \\mu_n$ 和 $\\lambda  c_d \\mu_d$，对于那些满足稳定性的组合，通过上述 Erlang C 表达式计算 $W_q(c_n; \\lambda, \\mu_n)$ 和 $W_q(c_d; \\lambda, \\mu_d)$。在所有可行分配中，保留 $W_q^{\\text{total}}$ 的最小值。\n- 测试套件的实例规模足够小，因此对预算可行的整数对进行这种精确枚举是有限的，并且计算上是微不足道的。\n\n单位和输出：\n- 所有等待时间的单位都是小时。对于每个测试用例，程序返回可实现的最小 $W_q^{\\text{total}}$，精确到 $6$ 位小数，并将它们聚合成指定列表格式的单行输出。\n\n正确性考量：\n- Erlang C 的计算使用有限和 $S(c,a)$ 和比率项 $\\frac{a^k}{k!}$，对于中等大小的 $c$，可以通过迭代稳定地计算以避免溢出。稳定性检查确保分母 $c \\mu - \\lambda$ 严格为正。\n- 单调性：对于固定的 $(\\lambda, \\mu)$，当系统稳定时，$W_q(c; \\lambda, \\mu)$ 是关于 $c$ 严格递减的，这确保在固定预算内，在任一站点增加 $c$ 的值不会增加目标函数值。然而，由于耦合的预算约束 $k_n x_n + k_d x_d \\le B$ 以及两个站点不同的边际效应，最优分配必须通过计算得出，而不能通过简单的规则推断。\n\n将此方法应用于四个指定的测试，可得出所需的最小总平均等待时间（以小时为单位），每个结果都四舍五入到 $6$ 位小数，程序将其打印为单个带方括号的列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef erlang_c_Wq(lam, mu, c):\n    \"\"\"\n    Compute average waiting time in queue Wq for an M/M/c system\n    with arrival rate lam, per-server service rate mu, and c servers.\n    Returns Wq in hours.\n    Requires lam  c*mu and c >= 1.\n    \"\"\"\n    if c  1:\n        return np.inf\n    capacity = c * mu\n    if lam == 0.0:\n        return 0.0\n    # Stability check with small tolerance\n    if lam >= capacity * (1.0 - 1e-12):\n        return np.inf\n    a = lam / mu  # traffic offered\n    rho = lam / capacity\n    # Compute S = sum_{k=0}^{c-1} a^k / k! using iterative terms for stability.\n    term = 1.0  # a^0 / 0!\n    S = term\n    for k in range(1, c):\n        term *= a / k\n        S += term\n    # term_c = a^c / c! (continue iteration one more step)\n    term_c = term * (a / c) if c > 0 else 1.0\n    # Erlang C waiting probability\n    # P_wait = (term_c * (1/(1 - rho))) / (S + term_c * (1/(1 - rho)))\n    one_minus_rho = 1.0 - rho\n    tail = term_c * (1.0 / one_minus_rho)\n    denom = S + tail\n    if denom == 0.0:\n        return np.inf\n    P_wait = tail / denom\n    Wq = P_wait / (capacity - lam)\n    return Wq\n\ndef minimal_total_waiting_time(case):\n    \"\"\"\n    Given a test case dict with keys:\n    lam, mu_n, mu_d, cn0, cd0, kn, kd, B\n    compute the minimal total average waiting time Wq_total (in hours)\n    over integer additions xn, xd satisfying budget and stability.\n    \"\"\"\n    lam = case['lam']\n    mu_n = case['mu_n']\n    mu_d = case['mu_d']\n    cn0 = case['cn0']\n    cd0 = case['cd0']\n    kn = case['kn']\n    kd = case['kd']\n    B = case['B']\n\n    best = np.inf\n    # Upper bounds for enumeration based on budget\n    max_xn = B // kn if kn > 0 else 0\n    max_xd = B // kd if kd > 0 else 0\n\n    # Enumerate all feasible (xn, xd)\n    for xn in range(int(max_xn) + 1):\n        rem_budget = B - kn * xn\n        # If kd=0 (should not occur here), avoid infinite loop\n        if kd == 0:\n            xd_values = [0]\n        else:\n            xd_values = range(int(rem_budget // kd) + 1)\n        for xd in xd_values:\n            cn = cn0 + xn\n            cd = cd0 + xd\n            # Must have at least 1 server at each station\n            if cn  1 or cd  1:\n                continue\n            # Stability checks\n            if not (lam  cn * mu_n and lam  cd * mu_d):\n                continue\n            # Compute total waiting time\n            Wq_n = erlang_c_Wq(lam, mu_n, cn)\n            Wq_d = erlang_c_Wq(lam, mu_d, cd)\n            total_Wq = Wq_n + Wq_d\n            if total_Wq  best:\n                best = total_Wq\n    return best\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test 1\n        {'lam': 10.0, 'mu_n': 8.0, 'mu_d': 3.5, 'cn0': 2, 'cd0': 2, 'kn': 1, 'kd': 3, 'B': 3},\n        # Test 2\n        {'lam': 5.0, 'mu_n': 6.0, 'mu_d': 3.0, 'cn0': 1, 'cd0': 2, 'kn': 1, 'kd': 2, 'B': 0},\n        # Test 3\n        {'lam': 14.0, 'mu_n': 7.0, 'mu_d': 4.0, 'cn0': 2, 'cd0': 4, 'kn': 1, 'kd': 2, 'B': 2},\n        # Test 4\n        {'lam': 18.0, 'mu_n': 6.0, 'mu_d': 3.0, 'cn0': 4, 'cd0': 6, 'kn': 1, 'kd': 2, 'B': 4},\n    ]\n\n    results = []\n    for case in test_cases:\n        val = minimal_total_waiting_time(case)\n        # Round to 6 decimals; if infeasible (np.inf), we can represent as inf\n        if not np.isfinite(val):\n            results.append(\"inf\")\n        else:\n            results.append(f\"{val:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}