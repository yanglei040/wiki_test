{
    "hands_on_practices": [
        {
            "introduction": "我们对有限差分格式的精度分析，通常依赖于泰勒级数展开。这一工具的有效性有一个基本前提：函数具有足够的光滑性，即存在足够高阶的连续导数。本练习旨在通过一个特殊函数 $f(x)=|x|^{3}$ 来挑战这一前提。通过直接计算，您将发现当函数在某点不够光滑时（例如三阶导数不存在），一个看似高阶的格式的实际精度可能会“降阶”。这个“纸笔”练习将加深您对截断误差理论背后假设的理解。",
            "id": "2421857",
            "problem": "设函数 $f:\\mathbb{R}\\to\\mathbb{R}$ 定义为 $f(x)=|x|^{3}$。考虑一个间距为 $h>0$ 的均匀网格，以及函数 $f$ 在 $x=0$ 处二阶导数的三点中心有限差分近似，其表达式为\n$$\nD_{h}^{(2)}f(0)=\\frac{f(h)-2f(0)+f(-h)}{h^{2}}。\n$$\n将该近似在 $x=0$ 处的有效精度阶 $p$ 定义为满足点态误差 $E(h)=\\left|D_{h}^{(2)}f(0)-f''(0)\\right|$ 在 $h\\to 0^{+}$ 时有 $E(h)=\\mathcal{O}(h^{p})$ 的最大实数 $p$。已知 $f''(0)$ 存在但 $f'''(0)$ 未定义。\n\n确定 $p$ 的精确值。请以一个不带单位的数字给出答案，无需四舍五入。",
            "solution": "首先对题目陈述进行严格的验证。\n\n已知条件如下：\n- 函数为 $f(x) = |x|^3$，$x \\in \\mathbb{R}$。\n- 对于网格间距 $h>0$，在 $x=0$ 处二阶导数的有限差分近似为 $D_{h}^{(2)}f(0) = \\frac{f(h) - 2f(0) + f(-h)}{h^2}$。\n- 点态误差为 $E(h) = |D_{h}^{(2)}f(0) - f''(0)|$。\n- 有效精度阶 $p$ 定义为满足当 $h \\to 0^+$ 时 $E(h) = \\mathcal{O}(h^p)$ 的最大实数。\n- 题目陈述 $f''(0)$ 存在且 $f'''(0)$ 未定义。\n\n需要先验证函数 $f(x)=|x|^3$ 的所述性质。\n对于 $x \\neq 0$，导数是直接的。当 $x>0$ 时，$f(x)=x^3$，得到 $f'(x)=3x^2$ 和 $f''(x)=6x$。当 $x<0$ 时，$f(x)=-x^3$，得到 $f'(x)=-3x^2$ 和 $f''(x)=-6x$。对于 $x \\neq 0$，其紧凑形式为 $f'(x)=3x|x|$ 和 $f''(x)=6|x|$。\n\n我们必须根据极限的定义来检查在 $x=0$ 处的导数。\n一阶导数为：\n$$\nf'(0) = \\lim_{\\Delta x \\to 0} \\frac{f(0+\\Delta x) - f(0)}{\\Delta x} = \\lim_{\\Delta x \\to 0} \\frac{|\\Delta x|^3 - 0}{\\Delta x} = \\lim_{\\Delta x \\to 0} (\\Delta x)^2 \\frac{|\\Delta x|}{\\Delta x} = 0\n$$\n二阶导数为：\n$$\nf''(0) = \\lim_{\\Delta x \\to 0} \\frac{f'(\\Delta x) - f'(0)}{\\Delta x} = \\lim_{\\Delta x \\to 0} \\frac{3(\\Delta x)|\\Delta x| - 0}{\\Delta x} = \\lim_{\\Delta x \\to 0} 3|\\Delta x| = 0\n$$\n所以，$f''(0)$ 存在且等于 $0$。\n三阶导数为：\n$$\nf'''(0) = \\lim_{\\Delta x \\to 0} \\frac{f''(\\Delta x) - f''(0)}{\\Delta x} = \\lim_{\\Delta x \\to 0} \\frac{6|\\Delta x| - 0}{\\Delta x} = 6 \\lim_{\\Delta x \\to 0} \\frac{|\\Delta x|}{\\Delta x}\n$$\n当 $\\Delta x \\to 0^+$ 时的右极限为 $6$，而当 $\\Delta x \\to 0^-$ 时的左极限为 $-6$。由于左右极限不相等，$f'''(0)$ 未定义。\n因此，题目的前提被验证为正确且自洽的。该问题在数值分析领域是适定的且有科学依据。我们可以继续进行求解。\n\n任务是确定有效精度阶 $p$。我们首先直接计算有限差分近似 $D_{h}^{(2)}f(0)$。\n公式为：\n$$\nD_{h}^{(2)}f(0) = \\frac{f(h) - 2f(0) + f(-h)}{h^2}\n$$\n我们在所需点上计算函数 $f(x) = |x|^3$ 的值。由于 $h>0$：\n- $f(h) = |h|^3 = h^3$\n- $f(0) = |0|^3 = 0$\n- $f(-h) = |-h|^3 = h^3$\n\n将这些值代入公式：\n$$\nD_{h}^{(2)}f(0) = \\frac{h^3 - 2(0) + h^3}{h^2} = \\frac{2h^3}{h^2} = 2h\n$$\n接下来，我们计算点态误差 $E(h) = |D_{h}^{(2)}f(0) - f''(0)|$。我们已经确定 $f''(0)=0$。\n因此，误差为：\n$$\nE(h) = |2h - 0| = 2h\n$$\n这里我们利用了 $h>0$ 的事实。\n\n对于一个足够光滑的函数 $g \\in C^4(\\mathbb{R})$，标准的泰勒级数分析会预测该中心差分格式的截断误差是 $\\mathcal{O}(h^2)$ 阶的，因为\n$$\n\\frac{g(x+h) - 2g(x) + g(x-h)}{h^2} - g''(x) = \\frac{g^{(4)}(\\xi)}{12}h^2\n$$\n这个结果依赖于三阶导数项的抵消，而这要求 $g'''(x)$ 的存在性和连续性。在当前问题中，$f'''(0)$ 不存在。这种光滑性的缺失使得标准分析无效，并导致精度阶的降低。我们的直接计算证实了这一点。\n\n我们必须找到最大的实数 $p$，使得当 $h \\to 0^+$ 时 $E(h) = \\mathcal{O}(h^p)$。这等价于找到最大的 $p$，使得以下极限有界：\n$$\n\\limsup_{h \\to 0^+} \\frac{E(h)}{h^p}  \\infty\n$$\n代入我们得到的 $E(h)$ 表达式：\n$$\n\\limsup_{h \\to 0^+} \\frac{2h}{h^p} = \\limsup_{h \\to 0^+} 2h^{1-p}\n$$\n为使此极限为有限值，$h$ 的指数必须为非负。即 $1-p \\ge 0$，这意味着 $p \\le 1$。\n满足此条件的最大实数 $p$ 是 $p=1$。\n当 $p=1$ 时，极限为 $\\lim_{h \\to 0^+} 2h^{1-1} = \\lim_{h \\to 0^+} 2 = 2$。这是一个有限的非零常数，证实了 $E(h)$ 确实是 $\\mathcal{O}(h^1)$。\n对于任何 $p  1$，比如 $p = 1 + \\epsilon$ (其中 $\\epsilon  0$)，极限变为 $\\lim_{h \\to 0^+} 2h^{-\\epsilon} = \\infty$。这表明对于任何 $p1$，$E(h)$ 都不是 $\\mathcal{O}(h^p)$。\n\n因此，使得 $E(h) = \\mathcal{O}(h^p)$ 成立的最大实数 $p$ 精确地为 $1$。\n有效精度阶为 $p=1$。",
            "answer": "$$\n\\boxed{1}\n$$"
        },
        {
            "introduction": "理论告诉我们，一个 $p$ 阶精度的数值格式，其截断误差与步长 $h$ 的关系为 $\\mathcal{O}(h^{p})$。这意味着当步长减半时，一阶格式的误差大约减半，而二阶格式的误差则减少为原来的四分之一。本练习将理论付诸实践，要求您编写代码，将计算机变成一个“虚拟实验室”。您将通过数值实验，亲眼验证不同阶数差分格式的误差收敛特性，从而将抽象的数学概念转化为具体可感的数字。",
            "id": "2421878",
            "problem": "编写一个完整的程序，数值地演示当使用一阶和二阶有限差分格式来近似光滑函数的一阶导数时，截断误差随步长的变化关系。对于下面的每个测试用例，计算步长为 $h$ 和步长减半为 $h/2$ 时的绝对误差，然后报告比率 $R = \\lvert E(h) \\rvert / \\lvert E(h/2) \\rvert$。使用单侧一阶向前差分近似和中心二阶差分近似来计算一阶导数：\n- 一阶向前差分：$\\left(f(x+h)-f(x)\\right)/h$。\n- 二阶中心差分：$\\left(f(x+h)-f(x-h)\\right)/(2h)$。\n对于每个测试用例，计算两个比率：\n- $R_{\\text{FD}}$：一阶向前差分格式的比率。\n- $R_{\\text{CD}}$：二阶中心差分格式的比率。\n使用精确的解析导数来定义误差。角度以弧度为单位。将每个报告的比率四舍五入到小数点后两位。\n\n测试套件：\n- 情况 A（一般光滑情况）：$f(x)=\\mathrm{e}^{x}$，$f'(x)=\\mathrm{e}^{x}$，$x=0.3$，$h=10^{-3}$。\n- 情况 B（三角函数情况）：$f(x)=\\sin(x)$，$f'(x)=\\cos(x)$，$x=1.0$，$h=10^{-4}$。\n- 情况 C（一阶格式中主误差项相消的边缘情况）：$f(x)=x^{3}$，$f'(x)=3x^{2}$，$x=0.0$，$h=10^{-3}$。\n- 情况 D（非常小步长下的浮点灵敏度）：$f(x)=\\cos(x)$，$f'(x)=-\\sin(x)$，$x=2.0$，$h=10^{-8}$。\n\n您的程序必须将所有结果作为单行输出，其中包含一个按以下顺序排列的扁平列表：\n$[R_{\\text{FD}}^{A},R_{\\text{CD}}^{A},R_{\\text{FD}}^{B},R_{\\text{CD}}^{B},R_{\\text{FD}}^{C},R_{\\text{CD}}^{C},R_{\\text{FD}}^{D},R_{\\text{CD}}^{D}]$。\n程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如 $[r_{1},r_{2},\\dots]$）。",
            "solution": "问题陈述已经过严格验证，并被确定为有效。它具有科学依据，定义明确，客观且内部一致。它提出了一个数值分析中的标准、可验证的问题，这是计算工程中的一个核心课题。\n\n任务是分析两种用于一阶导数 $f'(x)$ 的有限差分格式的收敛性质。格式的精度阶数 $p$ 决定了其截断误差 $E(h)$ 如何随步长 $h$ 变化。具体来说，对于一个足够光滑的函数，误差预期表现为 $E(h) = C h^p + O(h^{p+1})$，其中 $C$ 是一个与 $h$ 无关的常数。\n\n为了数值验证精度阶数，我们计算在两个不同步长 $h$ 和 $h/2$ 下的绝对误差之比。比率 $R$ 定义为：\n$$R = \\frac{\\lvert E(h) \\rvert}{\\lvert E(h/2) \\rvert}$$\n假设主误差项占主导地位，该比率近似为：\n$$R \\approx \\frac{\\lvert C h^p \\rvert}{\\lvert C (h/2)^p \\rvert} = \\frac{h^p}{(h/2)^p} = \\frac{h^p}{h^p / 2^p} = 2^p$$\n因此，通过计算 $R$，我们可以数值地估计精度阶数 $p$。\n\n问题指定了两种格式：\n1.  **一阶向前差分 (FD)**：\n    近似值为 $f'_{\\text{FD}}(x) = \\frac{f(x+h) - f(x)}{h}$。\n    $f(x+h)$ 在 $x$ 处的泰勒级数展开为：\n    $$f(x+h) = f(x) + hf'(x) + \\frac{h^2}{2}f''(x) + O(h^3)$$\n    重新整理后，我们得到截断误差：\n    $$E_{\\text{FD}}(h) = f'_{\\text{FD}}(x) - f'(x) = \\frac{h}{2}f''(x) + O(h^2)$$\n    这是一个一阶格式 ($p=1$)，所以我们预期比率 $R_{\\text{FD}} \\approx 2^1 = 2$。\n\n2.  **二阶中心差分 (CD)**：\n    近似值为 $f'_{\\text{CD}}(x) = \\frac{f(x+h) - f(x-h)}{2h}$。\n    $f(x+h)$ 和 $f(x-h)$ 的泰勒级数展开得到：\n    $$f(x+h) = f(x) + hf'(x) + \\frac{h^2}{2}f''(x) + \\frac{h^3}{6}f'''(x) + O(h^4)$$\n    $$f(x-h) = f(x) - hf'(x) + \\frac{h^2}{2}f''(x) - \\frac{h^3}{6}f'''(x) + O(h^4)$$\n    用第一个式子减去第二个式子并求解 $f'(x)$，得到截断误差：\n    $$E_{\\text{CD}}(h) = f'_{\\text{CD}}(x) - f'(x) = \\frac{h^2}{6}f'''(x) + O(h^4)$$\n    这是一个二阶格式 ($p=2$)，所以我们预期比率 $R_{\\text{CD}} \\approx 2^2 = 4$。\n\n我们现在分析每个测试用例：\n\n- **情况 A ($f(x)=\\mathrm{e}^{x}$) 和情况 B ($f(x)=\\sin(x)$)**：这些是一般情况，函数及其导数表现良好，并且主误差项（FD 中与 $f''(x)$ 成正比，CD 中与 $f'''(x)$ 成正比）在指定点不为零。因此，标准分析成立，我们预期 $R_{\\text{FD}} \\approx 2$ 且 $R_{\\text{CD}} \\approx 4$。\n\n- **情况 C ($f(x)=x^3$ 在 $x=0$ 处)**：这是一个特殊情况。我们有 $f'(x)=3x^2$，$f''(x)=6x$，以及 $f'''(x)=6$。在 $x=0$ 点，二阶导数为 $f''(0)=0$。这导致一阶 FD 格式的主误差项 $\\frac{h}{2}f''(0)$ 消失。此时误差由泰勒展开中的下一项主导，即 $\\frac{h^2}{6}f'''(0) = \\frac{h^2}{6}(6) = h^2$。FD 格式的误差现在按 $O(h^2)$ 比例变化，使其表现得像一个二阶格式。因此，我们预期 $R_{\\text{FD}} \\approx 2^2 = 4$。对于 CD 格式，主误差项与 $f'''(0)=6$ 成正比，该值非零。该格式仍为二阶，我们预期 $R_{\\text{CD}} \\approx 4$。\n\n- **情况 D ($f(x)=\\cos(x)$ 且 $h=10^{-8}$)**：这个情况展示了有限精度算术的实际限制。总数值误差是截断误差 ($E_{\\text{trunc}}$) 和浮点舍入误差 ($E_{\\text{round}}$) 的组合。虽然 $E_{\\text{trunc}}$ 随 $h$ 减小而减小 ($E_{\\text{trunc}} \\propto h^p$)，但 $E_{\\text{round}}$ 随 $h$ 减小而增大。两个几乎相等的数相减，例如 $f(x+h)-f(x)$，会导致灾难性抵消，引入一个大致按 $\\epsilon_m / h$ 比例变化的误差，其中 $\\epsilon_m$ 是机器精度（对于双精度，大约为 $10^{-16}$）。\n    - 对于 CD 格式，$p=2$，所以截断误差 $E_{\\text{trunc}} \\propto h^2 \\approx (10^{-8})^2 = 10^{-16}$。舍入误差 $E_{\\text{round}} \\propto 1/h \\approx 10^{-8}$。显然，舍入误差占主导地位。误差按 $E(h) \\approx K/h$ 比例变化。因此比率为 $R_{\\text{CD}} \\approx \\frac{|K/h|}{|K/(h/2)|} = \\frac{|K/h|}{|2K/h|} = 0.5$。\n    - 对于 FD 格式，$p=1$，所以截断误差 $E_{\\text{trunc}} \\propto h \\approx 10^{-8}$。舍入误差也为 $E_{\\text{round}} \\propto 1/h \\approx 10^{-8}$。在这里，两种误差源的量级相当。步长 $h=10^{-8}$ 接近该格式的最佳步长，此时总误差最小化。其行为处于一个过渡区，但仍主要受截断误差项控制，因此我们预期比率接近理论值 $R_{\\text{FD}} \\approx 2$。\n\n下面的程序将执行这些计算，以数值方式验证这些理论预测。对于每种情况，它会用步长 $h$ 和 $h/2$ 计算近似导数，找出相对于精确导数的绝对误差，并计算这些误差的比率。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the error ratio for finite difference schemes to demonstrate\n    their order of accuracy.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (function, derivative, evaluation point x, step size h)\n    test_cases = [\n        (lambda x: np.exp(x), lambda x: np.exp(x), 0.3, 1e-3),\n        (lambda x: np.sin(x), lambda x: np.cos(x), 1.0, 1e-4),\n        (lambda x: x**3, lambda x: 3*x**2, 0.0, 1e-3),\n        (lambda x: np.cos(x), lambda x: -np.sin(x), 2.0, 1e-8),\n    ]\n\n    results = []\n    \n    for f, f_prime, x, h in test_cases:\n        h_half = h / 2.0\n        \n        # Exact derivative value\n        d_exact = f_prime(x)\n\n        # --- First-Order Forward Difference (FD) ---\n        \n        # Approximation at step h\n        d_fd_h = (f(x + h) - f(x)) / h\n        err_fd_h = np.abs(d_fd_h - d_exact)\n        \n        # Approximation at step h/2\n        d_fd_h_half = (f(x + h_half) - f(x)) / h_half\n        err_fd_h_half = np.abs(d_fd_h_half - d_exact)\n        \n        # Ratio for FD\n        # Handle cases where error might be zero to avoid division by zero,\n        # although unlikely for these specific problems.\n        if err_fd_h_half == 0:\n            # If the smaller error is zero, the ratio is undefined or infinite.\n            # For this problem's context, this would imply perfect accuracy at h/2.\n            # We assign a placeholder NaN. In practice, this signals an issue.\n            R_fd = np.nan \n        else:\n            R_fd = err_fd_h / err_fd_h_half\n        \n        results.append(R_fd)\n\n        # --- Second-Order Central Difference (CD) ---\n\n        # Approximation at step h\n        d_cd_h = (f(x + h) - f(x - h)) / (2 * h)\n        err_cd_h = np.abs(d_cd_h - d_exact)\n        \n        # Approximation at step h/2\n        d_cd_h_half = (f(x + h_half) - f(x - h_half)) / (2 * h_half)\n        err_cd_h_half = np.abs(d_cd_h_half - d_exact)\n        \n        # Ratio for CD\n        if err_cd_h_half == 0:\n            R_cd = np.nan\n        else:\n            R_cd = err_cd_h / err_cd_h_half\n        \n        results.append(R_cd)\n\n    # Format the final results to 2 decimal places as strings\n    formatted_results = [f\"{res:.2f}\" for res in results]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "在理论世界里，我们可以通过无限减小步长 $h$ 来获得任意精度的结果。然而，在现实的计算中，我们使用的计算机以有限精度存储数字，这引入了舍入误差。当步长 $h$ 变得极小时，截断误差虽然减小，但由数值相减造成的舍入误差却会急剧增大。本练习将引导您探索这两种误差之间的“拉锯战”，通过编程找到一个“最佳”步长 $h^{\\star}$，使得总数值误差最小。理解这种权衡对于在实际工程计算中选择合适的步长至关重要。",
            "id": "2421884",
            "problem": "设 $f:\\mathbb{R}\\to\\mathbb{R}$ 是一个光滑函数。对于给定点 $x_0\\in\\mathbb{R}$ 和步长 $h0$，定义以下两个线性有限差分算子来近似一阶导数 $f'(x_0)$：\n(1) 前向差分算子 $D_h^{\\mathrm{F}}$，定义为 $D_h^{\\mathrm{F}} f(x_0) \\equiv \\dfrac{f(x_0+h)-f(x_0)}{h}$。\n(2) 中心差分算子 $D_h^{\\mathrm{C}}$，定义为 $D_h^{\\mathrm{C}} f(x_0) \\equiv \\dfrac{f(x_0+h)-f(x_0-h)}{2h}$。\n对于 $f$、$x_0$ 以及上述算子之一的每种选定组合，考虑一个由 $h_k = 2^{-k}$（其中 $k\\in\\{1,2,\\dots,K\\}$，$K$ 为固定的正整数）给出的严格递减的几何步长序列 $\\{h_k\\}_{k=1}^{K}$。对每个 $h_k$，定义绝对误差\n$$\nE(h_k) \\equiv \\left|D_{h_k} f(x_0) - f'(x_0)\\right|.\n$$\n当步长 $h$ 沿序列 $\\{h_k\\}$ 减小时，总误差 $E(h)$ 会受到截断误差和浮点舍入误差的影响。在固定的浮点运算中，序列中通常在某个步长 $h^\\star$ 处存在一个最小误差，步长 $h$ 在此之后若进一步减小，将导致 $E(h)$ 增大。为本题之目的，将 $h^\\star$ 定义为使得 $E(h_k)$ 在 $k\\in\\{1,2,\\dots,K\\}$ 上达到最小值的 $\\{h_k\\}$ 中的元素。如果最小值出现在多个索引处，则选择这些最小值中最大的 $h_k$ 作为 $h^\\star$。\n算术模型使用以下设置：电气和电子工程师协会 (IEEE) $754$ binary$64$（通常称为双精度）和 IEEE $754$ binary$32$（通常称为单精度）。当出现角度时，必须以弧度为单位进行解释。不涉及物理单位。\n您的任务是编写一个程序，对下面定义的测试套件中的每个测试用例，根据上述定义计算 $h^\\star$。\n测试套件：\n- 测试用例 1：$f(x)=\\exp(x)$，$f'(x)=\\exp(x)$，$x_0=1$，算子 $D_h^{\\mathrm{C}}$，算术精度 binary$64$，$K=60$。\n- 测试用例 2：$f(x)=\\sin(x)$，$f'(x)=\\cos(x)$，$x_0=1$，算子 $D_h^{\\mathrm{F}}$，算术精度 binary$64$，$K=60$。\n- 测试用例 3：$f(x)=\\ln(x)$，$f'(x)=1/x$，$x_0=1$，算子 $D_h^{\\mathrm{C}}$，算术精度 binary$32$，$K=60$。\n- 测试用例 4：$f(x)=\\exp(x)$，$f'(x)=\\exp(x)$，$x_0=1$，算子 $D_h^{\\mathrm{F}}$，算术精度 binary$32$，$K=60$。\n所有对数均为自然对数。当计算 $f(x)=\\ln(x)$ 时，请确保 $x_0-h_k0$；对于指定的数据，此条件是满足的，因为 $x_0=1$ 且对于所有 $k\\geq 1$ 都有 $h_k\\leq 2^{-1}$。\n对于每个测试用例，以实数形式输出 $h^\\star$ 的值。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按测试用例 1 到 4 的顺序排列结果；例如，包含四个结果的输出必须类似于 $[r_1,r_2,r_3,r_4]$，其中每个 $r_j$ 是为测试用例 $j$ 计算出的 $h^\\star$。",
            "solution": "在尝试给出解决方案之前，需对问题陈述进行验证。\n\n**步骤 1：提取已知信息**\n- 函数：$f(x)=\\exp(x)$, $f(x)=\\sin(x)$, $f(x)=\\ln(x)$。\n- 导数：$f'(x)=\\exp(x)$, $f'(x)=\\cos(x)$, $f'(x)=1/x$。\n- 求值点：$x_0=1$。\n- 算子：前向差分 $D_h^{\\mathrm{F}} f(x_0) \\equiv \\frac{f(x_0+h)-f(x_0)}{h}$ 和中心差分 $D_h^{\\mathrm{C}} f(x_0) \\equiv \\frac{f(x_0+h)-f(x_0-h)}{2h}$。\n- 步长：一个序列 $\\{h_k\\}_{k=1}^{K}$，其中 $h_k = 2^{-k}$ 且 $K=60$。\n- 误差度量：$E(h_k) \\equiv |D_{h_k} f(x_0) - f'(x_0)|$。\n- 最优步长 $h^\\star$：使 $E(h_k)$ 最小化的 $h_k$。如果存在多个最小值，则选择最大的 $h_k$（对应最小的 $k$）。\n- 算术精度：IEEE $754$ binary$64$（双精度）和 binary$32$（单精度）。\n- 测试用例：提供了上述参数的四个特定组合。\n\n**步骤 2：验证**\n根据所需标准对问题进行评估。\n- **科学性**：问题是数值分析中的一个标准练习，重点关注有限差分法中截断误差和舍入误差之间的相互作用。这些是计算科学与工程中的核心概念。\n- **良构性**：问题以数学精度进行了规定。所有函数、参数和评估规则，包括最小值的平局打破条件，都已明确定义。这确保了每个测试用例都有一个唯一的、确定性的解。\n- **客观性**：问题以客观、正式的语言陈述，没有任何主观或模棱两可的元素。\n\n该问题未违反任何无效条件。它在科学上是合理的，规定是完整的，并且在计算上是可行的。\n\n**步骤 3：结论**\n该问题是**有效的**。将提供解决方案。\n\n**理论基础**\n数值微分中的总误差 $E(h)$ 是两个分量之和：截断误差 $E_T(h)$ 和舍入误差 $E_R(h)$。\n\n**截断误差**\n截断误差源于用离散公式近似真实导数。其形式由泰勒级数展开导出。\n对于**前向差分算子** $D_h^{\\mathrm{F}}$，$f$ 在 $x_0$ 附近的泰勒级数展开为：\n$$ f(x_0+h) = f(x_0) + hf'(x_0) + \\frac{h^2}{2}f''(x_0) + \\mathcal{O}(h^3) $$\n为求导数重新整理可得：\n$$ D_h^{\\mathrm{F}} f(x_0) = \\frac{f(x_0+h) - f(x_0)}{h} = f'(x_0) + \\frac{h}{2}f''(x_0) + \\mathcal{O}(h^2) $$\n主阶截断误差为 $E_T^{\\mathrm{F}}(h) = \\frac{h}{2}f''(x_0)$，其阶为 $\\mathcal{O}(h)$。该方法是一阶精确的。\n\n对于**中心差分算子** $D_h^{\\mathrm{C}}$，我们使用两个泰勒展开式：\n$$ f(x_0+h) = f(x_0) + hf'(x_0) + \\frac{h^2}{2}f''(x_0) + \\frac{h^3}{6}f'''(x_0) + \\mathcal{O}(h^4) $$\n$$ f(x_0-h) = f(x_0) - hf'(x_0) + \\frac{h^2}{2}f''(x_0) - \\frac{h^3}{6}f'''(x_0) + \\mathcal{O}(h^4) $$\n用第一个式子减去第二个式子并重新整理可得：\n$$ D_h^{\\mathrm{C}} f(x_0) = \\frac{f(x_0+h) - f(x_0-h)}{2h} = f'(x_0) + \\frac{h^2}{6}f'''(x_0) + \\mathcal{O}(h^4) $$\n主阶截断误差为 $E_T^{\\mathrm{C}}(h) = \\frac{h^2}{6}f'''(x_0)$，其阶为 $\\mathcal{O}(h^2)$。该方法是二阶精确的。\n\n**舍入误差**\n舍入误差源于浮点运算的有限精度。$f(x)$ 的计算产生一个值 $\\hat{f}(x)$，满足 $|\\hat{f}(x) - f(x)| \\lesssim \\epsilon_M |f(x)|$，其中 $\\epsilon_M$ 是机器 epsilon（对于 binary$64$ 约为 $2.2 \\times 10^{-16}$，对于 binary$32$ 约为 $1.2 \\times 10^{-7}$）。\n对于小的 $h$，两个差分公式都涉及相近数的减法（$f(x_0+h) \\approx f(x_0)$ 和 $f(x_0+h) \\approx f(x_0-h)$）。这种被称为“相减抵消”的运算会放大舍入误差的影响。差分公式中分子的误差大约在 $\\epsilon_M|f(x_0)|$ 的量级。当除以一个小的分母（$h$ 或 $2h$）时，导数近似中产生的舍入误差会变得显著：\n$$ |E_R(h)| \\approx C \\frac{\\epsilon_M}{h} $$\n其中常数 $C$ 取决于算子和 $|f(x_0)|$。\n\n**最优步长 $h^\\star$**\n总误差的大小主要由截断误差和舍入误差的大小之和决定：\n$$ E(h) \\approx |E_T(h)| + |E_R(h)| $$\n对于一阶格式，$E(h) \\approx A h + B \\frac{\\epsilon_M}{h}$。对于二阶格式，$E(h) \\approx A h^2 + B \\frac{\\epsilon_M}{h}$。随着 $h$ 的减小，截断误差项减小，而舍入误差项增大。这种权衡意味着存在一个最优步长 $h^\\star$，使得总误差 $E(h)$ 最小。这就是程序必须找到的值。\n\n**计算步骤**\n解决方案需要对每个测试用例进行直接模拟。\n1. 为每个用例定义参数：函数 $f$、其解析导数 $f'$、点 $x_0$、算子以及浮点精度（binary$32$ 或 binary$64$）。计算中使用的所有数值都必须转换为指定的精度。\n2. 对每个用例，将 $k$ 从 $1$ 迭代到 $K=60$。\n3. 在每次迭代中，计算步长 $h_k = 2^{-k}$。\n4. 使用相应的公式计算数值导数 $D_{h_k}f(x_0)$。\n5. 计算精确的导数值 $f'(x_0)$ 作为参考。\n6. 确定绝对误差 $E(h_k) = |D_{h_k}f(x_0) - f'(x_0)|$。\n7. 计算出误差列表 $\\{E(h_k)\\}_{k=1}^{K}$ 后，找到最小值 $E_{\\min}$。\n8. 找出产生此最小误差 $E_{\\min}$ 的所有步长 $h_k$。\n9. 根据问题的平局打破规则，从此集合中选择最大的步长作为最优值 $h^\\star$。这对应于最小的索引 $k$。\n以下程序实现了这个步骤。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the optimal finite difference step size h_star for a suite of test cases.\n\n    For each case, it iterates through a geometrically decreasing sequence of step sizes h_k,\n    calculates the absolute error of the finite difference approximation against the\n    exact derivative, and finds the step size h_star that minimizes this error. The calculation\n    is performed using the specified floating-point precision (binary32 or binary64).\n    \"\"\"\n    test_cases = [\n        {\n            \"f\": np.exp,\n            \"df\": np.exp,\n            \"x0\": 1.0,\n            \"operator\": \"C\",\n            \"dtype\": np.float64,\n            \"K\": 60,\n        },\n        {\n            \"f\": np.sin,\n            \"df\": np.cos,\n            \"x0\": 1.0,\n            \"operator\": \"F\",\n            \"dtype\": np.float64,\n            \"K\": 60,\n        },\n        {\n            \"f\": np.log,\n            \"df\": lambda x: 1/x,\n            \"x0\": 1.0,\n            \"operator\": \"C\",\n            \"dtype\": np.float32,\n            \"K\": 60,\n        },\n        {\n            \"f\": np.exp,\n            \"df\": np.exp,\n            \"x0\": 1.0,\n            \"operator\": \"F\",\n            \"dtype\": np.float32,\n            \"K\": 60,\n        }\n    ]\n\n    results = []\n\n    for case in test_cases:\n        f = case[\"f\"]\n        df = case[\"df\"]\n        dtype = case[\"dtype\"]\n        x0 = dtype(case[\"x0\"])\n        operator = case[\"operator\"]\n        K = case[\"K\"]\n\n        # Calculate the exact derivative at the specified precision\n        df_exact = df(x0)\n\n        errors_and_hs = []\n\n        # Iterate through the sequence of step sizes h_k = 2^-k\n        for k in range(1, K + 1):\n            k_p = dtype(k)\n            h = dtype(2.0)**(-k_p)\n\n            # Calculate the finite difference approximation\n            if operator == 'C':\n                f_plus = f(x0 + h)\n                f_minus = f(x0 - h)\n                df_approx = (f_plus - f_minus) / (dtype(2.0) * h)\n            elif operator == 'F':\n                f_plus = f(x0 + h)\n                f_zero = f(x0)\n                df_approx = (f_plus - f_zero) / h\n            else:\n                # This path should not be reached with valid problem inputs\n                continue\n\n            # Calculate the absolute error\n            error = np.abs(df_approx - df_exact)\n            errors_and_hs.append((error, h))\n\n        # Find the minimum error achieved\n        if not errors_and_hs:\n            # Handle case of empty list, though not expected here\n            results.append(None) # Or some other indicator of failure\n            continue\n            \n        min_error = min(e for e, h in errors_and_hs)\n        \n        # Find all h values that resulted in the minimum error\n        h_at_min_error = [h for e, h in errors_and_hs if e == min_error]\n        \n        # Per problem spec, choose the largest h if there's a tie\n        h_star = max(h_at_min_error)\n        results.append(h_star)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}