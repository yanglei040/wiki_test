{
    "hands_on_practices": [
        {
            "introduction": "This first practice is a foundational exercise in implementing the Crank-Nicolson method from the ground up. You will discretize the one-dimensional heat equation and, instead of relying on a pre-built library, implement your own linear solver using Gaussian elimination to handle the implicit time-stepping. This exercise  is designed to build a deep, practical understanding of the entire solution process, from the partial differential equation to the final numerical result.",
            "id": "2397387",
            "problem": "You are to write a complete, runnable program that advances the one-dimensional heat equation using the implicit Crank–Nicolson method and, at each time step, solves the resulting tridiagonal linear system using Gaussian elimination with partial pivoting. Start from the fundamental base of the heat equation and the definitions of finite differences and the trapezoidal rule. Consider the initial-boundary value problem for the one-dimensional heat equation\n$$\n\\frac{\\partial u}{\\partial t}(x,t) = \\alpha \\frac{\\partial^2 u}{\\partial x^2}(x,t),\n$$\non the spatial domain $x \\in (0,1)$ and time interval $t \\in [0,T]$, with homogeneous Dirichlet boundary conditions\n$$\nu(0,t) = 0,\\quad u(1,t) = 0 \\quad \\text{for all } t \\ge 0,\n$$\nand initial condition\n$$\nu(x,0) = \\sin(\\pi x),\n$$\nwhere all angles are in radians. The parameter $\\alpha$ is a positive diffusion coefficient. The spatial grid uses $N$ interior points at positions $x_i = i h$ for $i \\in \\{1,2,\\dots,N\\}$ with spacing $h = 1/(N+1)$, and the temporal grid uses $M$ steps with time step $\\Delta t$ so that $t^n = n \\Delta t$ for $n \\in \\{0,1,\\dots,M\\}$ and $T = M \\Delta t$.\n\nDerive, from the definitions of the second-order central difference for the spatial second derivative and the trapezoidal rule for time integration, the Crank–Nicolson update that relates the interior values $u_i^{n+1}$ and $u_i^n$ for $i \\in \\{1,2,\\dots,N\\}$. Show that this update defines, at each time step, a linear system for the vector of interior unknowns $u^{n+1}$ with a tridiagonal coefficient matrix. You must implement the linear solver using Gaussian Elimination with Partial Pivoting (GEPP), that is, row pivoting at each elimination step based on the largest available magnitude in the current column. You must not call any library routine that directly solves linear systems or performs decompositions; instead, implement GEPP yourself.\n\nTo verify correctness, compare the numerical solution at final time $T$ with the analytic solution obtained by separation of variables for the given initial condition, which is\n$$\nu(x,T) = e^{-\\alpha \\pi^2 T} \\sin(\\pi x).\n$$\nFor each test case specified below, compute the maximum absolute error over the interior grid points at time $T$,\n$$\nE_{\\max} = \\max_{1 \\le i \\le N} \\left| u_i^{\\text{num}}(T) - u(x_i,T) \\right|,\n$$\nand report this value as a floating-point number with no physical unit (dimensionless). All angles in the sine function must be in radians. Your program must print a single line containing the list of results for all test cases, formatted as a comma-separated list enclosed in square brackets, with each number in scientific notation with exactly eight digits after the decimal point (for example, $[1.23456789\\text{e}{-}04,2.34567890\\text{e}{-}05]$). No other output is permitted.\n\nUse the following test suite, where each tuple is $(\\alpha, N, \\Delta t, T)$, and $T/\\Delta t$ is an integer in every case:\n- Test $1$: $(\\alpha, N, \\Delta t, T) = (1.0, 10, 0.01, 0.10)$.\n- Test $2$: $(\\alpha, N, \\Delta t, T) = (1.0, 2, 0.05, 0.10)$.\n- Test $3$: $(\\alpha, N, \\Delta t, T) = (1.0, 50, 0.001, 0.10)$.\n- Test $4$: $(\\alpha, N, \\Delta t, T) = (0.1, 20, 0.10, 0.50)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3,r_4]$).",
            "solution": "The problem statement has been critically validated and is deemed valid. It is scientifically grounded, well-posed, objective, self-contained, and free of contradictions or ambiguities. The problem describes a standard initial-boundary value problem for the one-dimensional heat equation and requires the implementation of the Crank-Nicolson method with a custom-built linear solver using Gaussian Elimination with Partial Pivoting (GEPP). All necessary parameters and conditions are provided.\n\nThe core of the problem is to solve the one-dimensional heat equation:\n$$\n\\frac{\\partial u}{\\partial t} = \\alpha \\frac{\\partial^2 u}{\\partial x^2}\n$$\nThe Crank-Nicolson method is derived by applying the trapezoidal rule for the time integration and a second-order central difference for the spatial derivative. The time derivative is approximated at the midpoint of the time interval $[t^n, t^{n+1}]$:\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} \\approx \\left. \\frac{\\partial u}{\\partial t} \\right|_{x_i, t^{n+1/2}}\n$$\nwhere $u_i^n$ is the numerical approximation of $u(x_i, t^n)$. The trapezoidal rule approximates the right-hand side by averaging its value at times $t^n$ and $t^{n+1}$:\n$$\n\\left. \\alpha \\frac{\\partial^2 u}{\\partial x^2} \\right|_{x_i, t^{n+1/2}} \\approx \\frac{\\alpha}{2} \\left( \\left. \\frac{\\partial^2 u}{\\partial x^2} \\right|_{x_i, t^n} + \\left. \\frac{\\partial^2 u}{\\partial x^2} \\right|_{x_i, t^{n+1}} \\right)\n$$\nThe spatial second derivative is approximated using a second-order central difference scheme:\n$$\n\\left. \\frac{\\partial^2 u}{\\partial x^2} \\right|_{x_i} \\approx \\frac{u_{i-1} - 2u_i + u_{i+1}}{h^2}\n$$\nwhere $h$ is the spatial step size. Combining these approximations yields the Crank-Nicolson finite difference equation:\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} = \\frac{\\alpha}{2h^2} \\left( (u_{i-1}^{n+1} - 2u_i^{n+1} + u_{i+1}^{n+1}) + (u_{i-1}^n - 2u_i^n + u_{i+1}^n) \\right)\n$$\nLet the dimensionless parameter be $\\lambda = \\frac{\\alpha \\Delta t}{h^2}$. We rearrange the equation to isolate the unknown terms at time level $n+1$ on the left-hand side (LHS) and the known terms at time level $n$ on the right-hand side (RHS):\n$$\n-\\frac{\\lambda}{2} u_{i-1}^{n+1} + (1 + \\lambda) u_i^{n+1} - \\frac{\\lambda}{2} u_{i+1}^{n+1} = \\frac{\\lambda}{2} u_{i-1}^n + (1 - \\lambda) u_i^n + \\frac{\\lambda}{2} u_{i+1}^n\n$$\nThis equation is valid for all interior grid points $i \\in \\{1, 2, \\dots, N\\}$. The homogeneous Dirichlet boundary conditions imply $u_0^n = u_{N+1}^n = 0$ for all $n$.\n\nThis system of $N$ linear equations for the unknown vector of interior values $\\mathbf{u}^{n+1} = [u_1^{n+1}, \\dots, u_N^{n+1}]^T$ can be written in the matrix form $A \\mathbf{u}^{n+1} = B \\mathbf{u}^n$. The matrix $A$ representing the LHS is an $N \\times N$ symmetric tridiagonal matrix:\n$$\nA = \\begin{pmatrix}\n1+\\lambda & -\\lambda/2 & 0 & \\dots & 0 \\\\\n-\\lambda/2 & 1+\\lambda & -\\lambda/2 & \\dots & 0 \\\\\n0 & \\ddots & \\ddots & \\ddots & 0 \\\\\n\\vdots & & -\\lambda/2 & 1+\\lambda & -\\lambda/2 \\\\\n0 & \\dots & 0 & -\\lambda/2 & 1+\\lambda\n\\end{pmatrix}\n$$\nSimilarly, the matrix $B$ which operates on the known vector $\\mathbf{u}^n$ is also an $N \\times N$ symmetric tridiagonal matrix:\n$$\nB = \\begin{pmatrix}\n1-\\lambda & \\lambda/2 & 0 & \\dots & 0 \\\\\n\\lambda/2 & 1-\\lambda & \\lambda/2 & \\dots & 0 \\\\\n0 & \\ddots & \\ddots & \\ddots & 0 \\\\\n\\vdots & & \\lambda/2 & 1-\\lambda & \\lambda/2 \\\\\n0 & \\dots & 0 & \\lambda/2 & 1-\\lambda\n\\end{pmatrix}\n$$\nAt each time step, we must solve the linear system $A \\mathbf{u}^{n+1} = \\mathbf{d}^n$, where the right-hand side vector is $\\mathbf{d}^n = B \\mathbf{u}^n$. As required, this system will be solved using Gaussian Elimination with Partial Pivoting (GEPP). The GEPP algorithm consists of two phases: forward elimination and backward substitution.\nIn the forward elimination phase, for each column $k$ from $0$ to $N-2$:\n$1$. We search for the element with the largest absolute value in the current column $k$ from row $k$ downwards. This element is the pivot.\n$2$. The row containing the pivot is swapped with the current row $k$. This step, partial pivoting, enhances numerical stability.\n$3$. The elements in column $k$ below the pivot are eliminated by subtracting suitable multiples of the pivot row from subsequent rows.\nAfter forward elimination, the matrix $A$ is transformed into an upper triangular matrix $U$. The system becomes $U \\mathbf{u}^{n+1} = \\mathbf{d}'$, where $\\mathbf{d}'$ is the correspondingly transformed right-hand side vector.\nThe backward substitution phase then solves this upper triangular system, starting from the last unknown $u_N^{n+1}$ and progressively solving for the others up to $u_1^{n+1}$.\n\nThe overall algorithm proceeds as follows:\n$1$. Discretize the domain: define spatial step $h = 1/(N+1)$ and the number of time steps $M = T/\\Delta t$.\n$2$. Initialize the solution vector $\\mathbf{u}^0$ using the initial condition $u(x,0) = \\sin(\\pi x)$ at the interior grid points $x_i = ih$ for $i=1,\\dots,N$.\n$3$. Construct the constant matrix $A$.\n$4$. Loop for $n$ from $0$ to $M-1$:\n    a. Compute the RHS vector $\\mathbf{d}^n = B \\mathbf{u}^n$.\n    b. Solve the system $A \\mathbf{u}^{n+1} = \\mathbf{d}^n$ for $\\mathbf{u}^{n+1}$ using the custom GEPP implementation.\n    c. Update the solution for the next iteration: $\\mathbf{u}^n \\leftarrow \\mathbf{u}^{n+1}$.\n$5$. After the loop, the final vector $\\mathbf{u}^M$ is the numerical solution at time $T$.\n$6$. Compute the maximum absolute error $E_{\\max} = \\max_{1 \\le i \\le N} |u_i^M - u(x_i, T)|$ by comparing against the given analytic solution $u(x,T) = e^{-\\alpha \\pi^2 T} \\sin(\\pi x)$.\nThis process is repeated for each test case provided.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_gepp(A, b):\n    \"\"\"\n    Solves the linear system Ax = b using Gaussian Elimination with Partial Pivoting.\n\n    Args:\n        A (np.ndarray): The N x N coefficient matrix.\n        b (np.ndarray): The N-element right-hand side vector.\n\n    Returns:\n        np.ndarray: The solution vector x.\n    \"\"\"\n    n = len(b)\n    # Create an augmented matrix to work on\n    Ab = np.hstack([A.astype(float), b.reshape(-1, 1).astype(float)])\n\n    # Forward elimination\n    for k in range(n - 1):\n        # Partial Pivoting: find the row with the largest pivot\n        pivot_row = k\n        for i in range(k + 1, n):\n            if abs(Ab[i, k]) > abs(Ab[pivot_row, k]):\n                pivot_row = i\n        \n        # Swap rows if necessary\n        if pivot_row != k:\n            Ab[[k, pivot_row]] = Ab[[pivot_row, k]]\n\n        pivot_val = Ab[k, k]\n        # Check for singularity (not expected in this problem, but good practice)\n        if abs(pivot_val) < 1e-15:\n            # For a strictly diagonally dominant matrix, this should not occur.\n            raise ValueError(\"Matrix is singular or near-singular.\")\n\n        # Elimination\n        for i in range(k + 1, n):\n            factor = Ab[i, k] / pivot_val\n            Ab[i, k:] -= factor * Ab[k, k:]\n\n    # Backward substitution\n    x = np.zeros(n)\n    for i in range(n - 1, -1, -1):\n        sum_ax = np.dot(Ab[i, i + 1:n], x[i + 1:n])\n        x[i] = (Ab[i, n] - sum_ax) / Ab[i, i]\n        \n    return x\n\ndef run_simulation(alpha, N, dt, T):\n    \"\"\"\n    Runs the Crank-Nicolson simulation for the 1D heat equation.\n\n    Args:\n        alpha (float): The thermal diffusivity.\n        N (int): The number of interior spatial points.\n        dt (float): The time step size.\n        T (float): The final time.\n\n    Returns:\n        float: The maximum absolute error at the final time T.\n    \"\"\"\n    h = 1.0 / (N + 1)\n    num_steps = int(round(T / dt))\n    \n    # Spatial grid (interior points only)\n    x = np.linspace(h, 1.0 - h, N)\n\n    # Dimensionless parameter lambda\n    lambda_val = alpha * dt / (h * h)\n\n    # Initial condition\n    u_current = np.sin(np.pi * x)\n\n    # Construct matrix A (LHS)\n    A = np.zeros((N, N))\n    diag_A = 1.0 + lambda_val\n    off_diag_A = -lambda_val / 2.0\n    for i in range(N):\n        A[i, i] = diag_A\n        if i > 0:\n            A[i, i - 1] = off_diag_A\n        if i < N - 1:\n            A[i, i + 1] = off_diag_A\n            \n    # Time-stepping loop\n    for _ in range(num_steps):\n        # Construct RHS vector d = B * u_current\n        d = np.zeros(N)\n        diag_B = 1.0 - lambda_val\n        off_diag_B = lambda_val / 2.0\n        \n        # First element\n        if N > 1:\n            d[0] = diag_B * u_current[0] + off_diag_B * u_current[1]\n        else: # N=1 case\n            d[0] = diag_B * u_current[0]\n        \n        # Middle elements\n        for i in range(1, N - 1):\n            d[i] = off_diag_B * u_current[i - 1] + diag_B * u_current[i] + off_diag_B * u_current[i + 1]\n        \n        # Last element\n        if N > 1:\n            d[N - 1] = off_diag_B * u_current[N - 2] + diag_B * u_current[N - 1]\n\n        # Solve the linear system A * u_next = d\n        u_next = solve_gepp(A, d)\n        \n        u_current = u_next\n\n    # Final numerical solution\n    u_numerical = u_current\n\n    # Analytic solution at time T\n    u_analytic = np.exp(-alpha * np.pi**2 * T) * np.sin(np.pi * x)\n\n    # Calculate maximum absolute error\n    max_error = np.max(np.abs(u_numerical - u_analytic))\n    \n    return max_error\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the results.\n    \"\"\"\n    # (alpha, N, dt, T)\n    test_cases = [\n        (1.0, 10, 0.01, 0.10),\n        (1.0, 2, 0.05, 0.10),\n        (1.0, 50, 0.001, 0.10),\n        (0.1, 20, 0.10, 0.50),\n    ]\n\n    results = []\n    for case in test_cases:\n        alpha, N, dt, T = case\n        error = run_simulation(alpha, N, dt, T)\n        results.append(error)\n\n    # Format the output as specified\n    formatted_results = [f\"{res:.8e}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While the Crank–Nicolson scheme is celebrated for its unconditional stability, it is not without its pitfalls. This exercise explores a crucial nuance by investigating how the method can produce non-physical oscillations when simulating problems with sharp initial gradients and large time steps. By identifying the conditions under which these spurious results appear , you will learn the important distinction between mathematical stability in the $L_2$-norm and physical fidelity.",
            "id": "2443615",
            "problem": "Consider the one-dimensional heat equation\n$$\n\\frac{\\partial u}{\\partial t} = \\alpha \\frac{\\partial^2 u}{\\partial x^2}, \\quad x \\in (0,1), \\quad t > 0,\n$$\nwith homogeneous Dirichlet boundary conditions\n$$\nu(0,t) = 0, \\quad u(1,t) = 0, \\quad t \\ge 0,\n$$\nand initial condition given by a compactly supported top-hat profile\n$$\nu(x,0) = \\begin{cases}\n1,  |x - 1/2| \\le w/2,\\\\\n0,  \\text{otherwise},\n\\end{cases}\n$$\nwhere the width is $w = 0.1$. Use a uniform spatial grid with $M$ equal subintervals on $[0,1]$, so that the spatial step size is $\\Delta x = 1/M$ and the grid points are $x_i = i \\,\\Delta x$ for $i = 0,1,\\ldots,M$. The interior unknowns are at indices $i = 1,2,\\ldots,M-1$. Time integration is to be performed by the trapezoidal rule in time (also known as the Crank–Nicolson scheme) applied to the semi-discrete system that arises from second-order centered finite differences in space. Let the diffusion number be\n$$\nr = \\frac{\\alpha \\,\\Delta t}{(\\Delta x)^2},\n$$\nwith a fixed $\\alpha = 1$. Evolve the numerical solution from $t=0$ up to $t = T_{\\text{end}}$ with a constant time step $\\Delta t$ determined by the specified value of $r$. The objective is to detect physically inaccurate oscillations in time that may arise for large $r$, manifested as the appearance of negative values in the numerical solution even though the exact solution remains nonnegative for $t0$ under the given conditions.\n\nDefine an “oscillation detected” boolean for a given parameter set as follows: after each time step, if any interior grid value strictly falls below a tolerance threshold of $-10^{-10}$ at any time $t \\in (0, T_{\\text{end}}]$, then set the boolean to $\\text{True}$; otherwise set it to $\\text{False}$. The boundary values at $x=0$ and $x=1$ are fixed at $0$ and should not be used for the detection criterion.\n\nYour program must implement the above mathematical model and detection rule for the following test suite of parameter values $(M, r, T_{\\text{end}})$, with $\\alpha = 1$ and $w = 0.1$ held fixed:\n- Test A (happy path, small diffusion number): $(M, r, T_{\\text{end}}) = (100, 0.1, 0.05)$.\n- Test B (boundary regime near sign-change threshold): $(M, r, T_{\\text{end}}) = (100, 0.5, 0.05)$.\n- Test C (moderately large diffusion number): $(M, r, T_{\\text{end}}) = (100, 0.6, 0.05)$.\n- Test D (very large diffusion number): $(M, r, T_{\\text{end}}) = (100, 5.0, 0.05)$.\n\nFor each test, the single result is the boolean “oscillation detected” as defined above. Your program should produce a single line of output containing the four boolean results for Tests A–D, in order, as a comma-separated list enclosed in square brackets (e.g., “[False,True,True,False]”). No physical units are required in the output. Angles are not involved. Percentages are not involved. The output must adhere exactly to the specified format.",
            "solution": "The problem presented is valid. It is a well-defined problem in computational science, based on fundamental principles of numerical analysis for partial differential equations. All necessary parameters and conditions are provided, and there are no scientific or logical contradictions. We will proceed with the solution.\n\nThe problem requires the numerical solution of the one-dimensional heat equation:\n$$\n\\frac{\\partial u}{\\partial t} = \\alpha \\frac{\\partial^2 u}{\\partial x^2}, \\quad x \\in (0,1), \\quad t  0\n$$\nThe thermal diffusivity is given as $\\alpha = 1$. The boundary conditions are of homogeneous Dirichlet type:\n$$\nu(0,t) = 0, \\quad u(1,t) = 0, \\quad t \\ge 0\n$$\nThe initial condition is a top-hat function of width $w = 0.1$:\n$$\nu(x,0) = \\begin{cases}\n1,  \\text{if } |x - 1/2| \\le 0.1/2 \\\\\n0,  \\text{otherwise}\n\\end{cases}\n$$\nThis corresponds to $u(x,0)=1$ for $x \\in [0.45, 0.55]$.\n\nFirst, we perform a semi-discretization in space. The spatial domain $[0,1]$ is discretized into $M$ subintervals of equal length $\\Delta x = 1/M$. The grid points are $x_i = i \\Delta x$ for $i = 0, 1, \\ldots, M$. Let $u_i(t)$ be the numerical approximation of $u(x_i, t)$. The second spatial derivative is approximated using a second-order central difference formula:\n$$\n\\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{x=x_i} \\approx \\frac{u_{i+1}(t) - 2u_i(t) + u_{i-1}(t)}{(\\Delta x)^2}\n$$\nApplying this to the interior grid points $i = 1, 2, \\ldots, M-1$, we obtain a system of ordinary differential equations (ODEs):\n$$\n\\frac{d u_i}{dt} = \\frac{\\alpha}{(\\Delta x)^2} (u_{i+1} - 2u_i + u_{i-1})\n$$\nLet $\\mathbf{u}(t) = [u_1(t), u_2(t), \\ldots, u_{M-1}(t)]^T$ be the vector of solutions at the interior points. The ODE system can be written in matrix form as:\n$$\n\\frac{d\\mathbf{u}}{dt} = \\frac{\\alpha}{(\\Delta x)^2} L_{1D} \\mathbf{u}\n$$\nwhere $L_{1D}$ is the $(M-1) \\times (M-1)$ tridiagonal matrix representing the discrete Laplacian with homogeneous Dirichlet boundary conditions:\n$$\nL_{1D} = \\begin{pmatrix}\n-2  1  0  \\dots  0 \\\\\n1  -2  1  \\dots  0 \\\\\n0  1  -2  \\dots  0 \\\\\n\\vdots  \\ddots  \\ddots  \\ddots  \\vdots \\\\\n0  \\dots  0  1  -2\n\\end{pmatrix}\n$$\n\nNext, we discretize in time using the trapezoidal rule, also known as the Crank-Nicolson method. Given a time step $\\Delta t$, let $\\mathbf{u}^n$ denote the solution vector at time $t_n = n \\Delta t$. The scheme is:\n$$\n\\frac{\\mathbf{u}^{n+1} - \\mathbf{u}^n}{\\Delta t} = \\frac{1}{2} \\left( \\frac{\\alpha}{(\\Delta x)^2} L_{1D} \\mathbf{u}^{n+1} + \\frac{\\alpha}{(\\Delta x)^2} L_{1D} \\mathbf{u}^n \\right)\n$$\nIntroducing the diffusion number $r = \\frac{\\alpha \\Delta t}{(\\Delta x)^2}$, we can rearrange the equation to solve for $\\mathbf{u}^{n+1}$:\n$$\n\\left(I - \\frac{r}{2} L_{1D}\\right) \\mathbf{u}^{n+1} = \\left(I + \\frac{r}{2} L_{1D}\\right) \\mathbf{u}^n\n$$\nwhere $I$ is the $(M-1) \\times (M-1)$ identity matrix. At each time step, we must solve a linear system of the form $A \\mathbf{x} = \\mathbf{b}$, where:\n- The system matrix is $A_{CN} = I - \\frac{r}{2} L_{1D}$.\n- The unknown vector is $\\mathbf{x} = \\mathbf{u}^{n+1}$.\n- The right-hand side vector is $\\mathbf{b}_{CN} = (I + \\frac{r}{2} L_{1D}) \\mathbf{u}^n$.\n\nThe matrix $A_{CN}$ is tridiagonal with $(1+r)$ on the main diagonal and $-r/2$ on the sub- and super-diagonals. This system is non-singular and diagonally dominant for any $r  0$, and thus can be solved efficiently using an algorithm for tridiagonal systems, such as the Thomas algorithm.\n\nThe simulation proceeds as follows:\n1.  For each test case, specified by $(M, r, T_{\\text{end}})$, we set $\\alpha=1$ and $w=0.1$.\n2.  The spatial step is $\\Delta x = 1/M$. The time step is determined by the diffusion number, $\\Delta t = r (\\Delta x)^2 / \\alpha$.\n3.  The initial solution vector $\\mathbf{u}^0$ is assembled by sampling the top-hat function at the interior grid points $x_i$ for $i=1, \\ldots, M-1$.\n4.  The matrices for the Crank-Nicolson step are constructed. The left-hand side matrix $A_{CN}$ is constant throughout the simulation.\n5.  A time-stepping loop evolves the solution from $t=0$ to $t=T_{\\text{end}}$. In each step:\n    a. The right-hand side vector $\\mathbf{b}_{CN}$ is computed by applying the operator $(I + \\frac{r}{2} L_{1D})$ to the current solution $\\mathbf{u}^n$.\n    b. The linear system $A_{CN} \\mathbf{u}^{n+1} = \\mathbf{b}_{CN}$ is solved for $\\mathbf{u}^{n+1}$.\n    c. The new solution vector $\\mathbf{u}^{n+1}$ is checked for oscillations. If any of its components are less than the tolerance $-10^{-10}$, a boolean flag `oscillation_detected` is set to `True`, and the simulation for this test case terminates.\n6.  If the time loop completes without the flag being set, its value remains `False`.\n\nThe Crank-Nicolson scheme is unconditionally stable in the $L_2$-norm sense for any $r  0$. However, for non-smooth initial conditions, it may fail to preserve positivity and can introduce spurious oscillations unless the time step is sufficiently small. A Fourier stability analysis for non-negativity shows that oscillations are avoided if the amplification factor for all modes is non-negative. For the highest frequency mode, this leads to the condition $1 - 2r \\ge 0$, or $r \\le 0.5$. Therefore, we anticipate that oscillations will be detected for test cases with $r  0.5$. Specifically, for Test C ($r=0.6$) and Test D ($r=5.0$), we expect to find negative values. For Test A ($r=0.1$) and Test B ($r=0.5$), we expect the solution to remain non-negative.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n\n    def run_simulation(M, r, T_end, alpha, w):\n        \"\"\"\n        Solves the 1D heat equation using the Crank-Nicolson method for one set of parameters.\n\n        Args:\n            M (int): Number of spatial subintervals.\n            r (float): Diffusion number.\n            T_end (float): End time for the simulation.\n            alpha (float): Thermal diffusivity.\n            w (float): Width of the initial top-hat profile.\n\n        Returns:\n            bool: True if oscillations are detected, False otherwise.\n        \"\"\"\n        # --- 1. Setup simulation parameters ---\n        dx = 1.0 / M\n        dt = r * dx**2 / alpha\n        num_steps = int(np.ceil(T_end / dt))\n        tol = -1.0e-10\n        \n        # --- 2. Create spatial grid and initial condition ---\n        # Grid consists of M-1 interior points.\n        x_interior = np.linspace(dx, 1.0 - dx, M - 1)\n        \n        u = np.zeros(M - 1)\n        left_bound = 0.5 - w / 2.0\n        right_bound = 0.5 + w / 2.0\n        \n        # Set initial condition u(x,0) based on the top-hat profile.\n        # N.B. Using a small epsilon for float comparison safety is good practice,\n        # but for M=100, the boundaries 0.45 and 0.55 are exact grid points.\n        u[(x_interior = left_bound)  (x_interior = right_bound)] = 1.0\n        \n        # --- 3. Construct matrices for the Crank-Nicolson scheme ---\n        # The scheme is (I - r/2 * L) u_next = (I + r/2 * L) u_current\n        # Let A = (I - r/2 * L) and B = (I + r/2 * L). We solve A * u_next = B * u_current.\n        \n        # A matrix in banded form for Scipy's solver.\n        # It has 1 lower, 1 upper diagonal. Shape (3, M-1).\n        # Row 0: super-diagonal, Row 1: main diagonal, Row 2: sub-diagonal.\n        A_banded = np.zeros((3, M - 1))\n        A_banded[0, 1:] = -r / 2.0\n        A_banded[1, :] = 1.0 + r\n        A_banded[2, :-1] = -r / 2.0\n        \n        # --- 4. Time-stepping loop ---\n        u_current = u\n        oscillation_detected = False\n        \n        for _ in range(num_steps):\n            # Calculate the right-hand side vector: rhs = B * u_current\n            # B is tridiagonal with (1-r) on the main diagonal and r/2 on off-diagonals.\n            # We compute the matrix-vector product efficiently without forming B.\n            rhs = np.zeros(M - 1)\n            \n            # For interior points of the u_current vector (indices 1 to M-3)\n            rhs[1:-1] = (r / 2.0) * u_current[:-2] + \\\n                        (1.0 - r) * u_current[1:-1] + \\\n                        (r / 2.0) * u_current[2:]\n            \n            # Handle endpoints with homogeneous Dirichlet BCs (u_0=0, u_M=0)\n            if M - 1  0: # Ensure u_current is not empty\n                rhs[0] = (1.0 - r) * u_current[0] + (r / 2.0) * u_current[1] if M - 1  1 else (1.0 - r) * u_current[0]\n            if M - 1  1:\n                rhs[-1] = (r / 2.0) * u_current[-2] + (1.0 - r) * u_current[-1]\n            \n            # Solve the tridiagonal system A * u_next = rhs\n            u_next = solve_banded((1, 1), A_banded, rhs)\n            \n            # Check for oscillations\n            if np.any(u_next  tol):\n                oscillation_detected = True\n                break\n            \n            u_current = u_next\n            \n        return oscillation_detected\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (100, 0.1, 0.05),  # Test A\n        (100, 0.5, 0.05),  # Test B\n        (100, 0.6, 0.05),  # Test C\n        (100, 5.0, 0.05),  # Test D\n    ]\n\n    # Fixed parameters\n    alpha = 1.0\n    w = 0.1\n    \n    results = []\n    for case in test_cases:\n        M, r, T_end = case\n        result = run_simulation(M, r, T_end, alpha, w)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "How can we be certain our implemented code is correct? This final practice introduces the Method of Manufactured Solutions (MMS), a powerful and standard technique for code verification. You will invent a solution to the heat equation, derive the corresponding source term that makes it valid, and then use this \"manufactured\" problem to rigorously test your solver's accuracy . Mastering MMS is a key step in transitioning from academic exercises to developing robust, reliable computational tools.",
            "id": "2445001",
            "problem": "You will apply the Method of Manufactured Solutions (MMS) to verify a one-dimensional numerical solver for the transient heat equation. Consider the dimensionless heat equation with a source term on a finite interval,\n$$\nu_t = \\alpha\\,u_{xx} + s(x,t), \\quad x \\in [0,L], \\ t \\in [0,T],\n$$\nwith Dirichlet boundary conditions and a known initial condition. The Method of Manufactured Solutions (MMS) prescribes selecting a smooth, exact solution $u_m(x,t)$, inserting it into the differential equation, and defining the source term $s(x,t)$ so that $u_m(x,t)$ satisfies the equation identically. This enables objective code verification by comparing the numerical solution against $u_m(x,t)$.\n\nUse the manufactured solution\n$$\nu_m(x,t) = e^{-k t}\\,\\cos(a x),\n$$\nwhere $a \\ge 0$ and $k \\ge 0$ are real parameters, and the argument of $\\cos(\\cdot)$ is in radians. All quantities are dimensionless. The task is to:\n\n- Derive the source term $s(x,t)$ implied by the choice of $u_m(x,t)$, using only calculus and the differential operator definitions.\n- Discretize the partial differential equation using the Crank–Nicolson method in time and second-order central differences in space on a uniform grid. Impose Dirichlet boundary conditions from $u_m(x,t)$ and the initial condition $u(x,0)=u_m(x,0)$. The time step $\\Delta t$ must be chosen proportional to $\\Delta x$ to balance temporal and spatial errors.\n- For each test case, compute the numerical solution at the final time $t=T$ on two successively refined meshes whose numbers of spatial intervals differ by a factor of $2$, and estimate the observed order of accuracy $p$ by\n$$\np \\;=\\; \\frac{\\log\\left(E_{\\mathrm{coarse}}/E_{\\mathrm{fine}}\\right)}{\\log(2)},\n$$\nwhere $E$ is the discrete root-mean-square error over all grid nodes at $t=T$,\n$$\nE \\;=\\; \\sqrt{\\frac{1}{N+1}\\sum_{j=0}^{N}\\left(u_j^N - u_m(x_j,T)\\right)^2},\n$$\nwith $N$ the number of spatial intervals, $x_j=j\\,\\Delta x$, and $u_j^N$ the numerical solution at node $j$ and time level $N$.\n- Your time step choice must satisfy $\\Delta t = \\gamma\\,\\Delta x$ approximately, implemented by taking $N_t = \\lceil T/(\\gamma\\,\\Delta x)\\rceil$ time steps and then setting $\\Delta t = T/N_t$. Use the Crank–Nicolson scheme with source term evaluated via the trapezoidal rule in time.\n\nBase your derivations on the following foundational facts only:\n- The definition of partial derivatives and the chain rule for time and space.\n- The second derivative in space of $\\cos(a x)$ is $-a^2 \\cos(a x)$.\n- The Crank–Nicolson method is the trapezoidal rule in time applied to the semi-discrete system, and second-order central differences approximate $u_{xx}$.\n\nAngle unit specification: evaluate $\\cos(\\cdot)$ with its argument in radians.\n\nTest suite:\n- Case $1$ (general): $\\alpha=0.7$, $a=3.0$, $k=2.5$, $L=\\pi$, $T=0.2$, $N_{\\text{coarse}}=50$, $\\gamma=0.4$.\n- Case $2$ (weak diffusion): $\\alpha=0.001$, $a=4.0$, $k=0.5$, $L=\\pi$, $T=0.05$, $N_{\\text{coarse}}=60$, $\\gamma=0.4$.\n- Case $3$ (spatially constant solution): $\\alpha=0.9$, $a=0.0$, $k=1.2$, $L=1.0$, $T=0.3$, $N_{\\text{coarse}}=40$, $\\gamma=0.4$.\n\nFor each case, use two meshes: the coarse mesh with $N_{\\text{coarse}}$ spatial intervals and the fine mesh with $2N_{\\text{coarse}}$ intervals, with the time step chosen as described. Compute the observed order $p$ from the two errors at $t=T$.\n\nFinal output format:\n- Your program should produce a single line of output containing the observed orders for the three cases as a comma-separated list enclosed in square brackets, with each value rounded to three decimal places, for example, `[2.001,1.998,2.004]`.",
            "solution": "The problem statement is first subjected to rigorous validation.\n\n**Step 1: Extract Givens**\n- **Governing Equation:** $u_t = \\alpha\\,u_{xx} + s(x,t)$, for $x \\in [0,L]$ and $t \\in [0,T]$.\n- **Manufactured Solution:** $u_m(x,t) = e^{-k t}\\,\\cos(a x)$, with $a \\ge 0$, $k \\ge 0$.\n- **Observed Order of Accuracy Formula:** $p \\;=\\; \\frac{\\log\\left(E_{\\mathrm{coarse}}/E_{\\mathrm{fine}}\\right)}{\\log(2)}$.\n- **Error Metric:** The discrete root-mean-square error is $E \\;=\\; \\sqrt{\\frac{1}{N+1}\\sum_{j=0}^{N}\\left(u_j^N - u_m(x_j,T)\\right)^2}$.\n- **Numerical Method:** Crank–Nicolson in time, second-order central differences in space. Dirichlet boundary conditions and initial condition are imposed from $u_m(x,t)$.\n- **Time Step Rule:** $\\Delta t = \\gamma\\,\\Delta x$ approximately, achieved via $N_t = \\lceil T/(\\gamma\\,\\Delta x)\\rceil$ and $\\Delta t = T/N_t$. The source term is evaluated using the trapezoidal rule in time.\n- **Test Suite:**\n    - Case $1$: $\\alpha=0.7$, $a=3.0$, $k=2.5$, $L=\\pi$, $T=0.2$, $N_{\\text{coarse}}=50$, $\\gamma=0.4$.\n    - Case $2$: $\\alpha=0.001$, $a=4.0$, $k=0.5$, $L=\\pi$, $T=0.05$, $N_{\\text{coarse}}=60$, $\\gamma=0.4$.\n    - Case $3$: $\\alpha=0.9$, $a=0.0$, $k=1.2$, $L=1.0$, $T=0.3$, $N_{\\text{coarse}}=40$, $\\gamma=0.4$.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem statement is evaluated against the established criteria for validity.\n- **Scientific Grounding:** The problem is based on the one-dimensional heat equation, a fundamental partial differential equation in physics. The Method of Manufactured Solutions (MMS) is a standard, accepted technique for code verification in computational science. The numerical methods specified—Crank-Nicolson and central differencing—are canonical, well-understood algorithms. The problem is scientifically sound.\n- **Well-Posedness and Completeness:** The problem describes a well-posed initial-boundary value problem. All necessary parameters, functions, boundary conditions, and discretization rules are explicitly defined. The task of calculating the observed order of accuracy is unambiguous. The problem is self-contained and complete.\n- **Objectivity:** The problem is stated in precise, objective mathematical language, free from subjective or ambiguous interpretations.\n\n**Step 3: Verdict and Action**\nThe problem is valid. It is a standard exercise in the verification of numerical methods for partial differential equations. We proceed to the solution.\n\n**Derivation of the Source Term**\n\nThe source term $s(x,t)$ is defined to ensure that the manufactured solution $u_m(x,t)$ satisfies the partial differential equation identically. We rearrange the PDE to solve for $s(x,t)$:\n$$\ns(x,t) = u_t - \\alpha\\,u_{xx}\n$$\nThe manufactured solution is $u_m(x,t) = e^{-k t}\\,\\cos(a x)$. We compute its partial derivatives with respect to time and space.\n\nThe partial derivative with respect to time $t$ is:\n$$\nu_t = \\frac{\\partial}{\\partial t}\\left(e^{-k t}\\,\\cos(a x)\\right) = -k\\,e^{-k t}\\,\\cos(a x)\n$$\nThe first partial derivative with respect to space $x$ is:\n$$\nu_x = \\frac{\\partial}{\\partial x}\\left(e^{-k t}\\,\\cos(a x)\\right) = -a\\,e^{-k t}\\,\\sin(a x)\n$$\nThe second partial derivative with respect to space $x$ is:\n$$\nu_{xx} = \\frac{\\partial}{\\partial x}\\left(-a\\,e^{-k t}\\,\\sin(a x)\\right) = -a^2\\,e^{-k t}\\,\\cos(a x)\n$$\nSubstituting the expressions for $u_t$ and $u_{xx}$ into the equation for $s(x,t)$ yields:\n$$\ns(x,t) = \\left(-k\\,e^{-k t}\\,\\cos(a x)\\right) - \\alpha\\,\\left(-a^2\\,e^{-k t}\\,\\cos(a x)\\right)\n$$\nFactoring out the common terms, we obtain the final expression for the source term:\n$$\ns(x,t) = (\\alpha\\,a^2 - k)\\,e^{-k t}\\,\\cos(a x)\n$$\n\n**Numerical Discretization**\n\nThe PDE is discretized on a uniform grid with spatial step $\\Delta x = L/N$ and time step $\\Delta t = T/N_t$. Let $u_j^n$ approximate the solution $u(x_j, t_n)$ at grid point $x_j=j\\Delta x$ and time $t_n=n\\Delta t$.\n\nThe Crank–Nicolson method is applied to the semi-discrete equation $u_t = F(u,t)$, where $F(u,t) = \\alpha u_{xx} + s(x,t)$. This results in:\n$$\n\\frac{u^{n+1} - u^n}{\\Delta t} = \\frac{1}{2}\\left( F(u^n, t_n) + F(u^{n+1}, t_{n+1}) \\right)\n$$\nThe spatial derivative $u_{xx}$ is approximated using a second-order central difference:\n$$\n(u_{xx})_j \\approx \\frac{u_{j+1} - 2u_j + u_{j-1}}{(\\Delta x)^2}\n$$\nSubstituting this into the Crank-Nicolson scheme gives the fully discrete equation for an interior node $j \\in \\{1, 2, \\dots, N-1\\}$:\n$$\n\\frac{u_j^{n+1} - u_j^n}{\\Delta t} = \\frac{\\alpha}{2}\\left( \\frac{u_{j+1}^n - 2u_j^n + u_{j-1}^n}{(\\Delta x)^2} + \\frac{u_{j+1}^{n+1} - 2u_j^{n+1} + u_{j-1}^{n+1}}{(\\Delta x)^2} \\right) + \\frac{1}{2}(s_j^n + s_j^{n+1})\n$$\nwhere $s_j^n = s(x_j, t_n)$. We rearrange the equation to group unknown terms at time level $n+1$ on the left-hand side (LHS) and known terms at time level $n$ on the right-hand side (RHS). Define the dimensionless parameter $\\lambda = \\frac{\\alpha \\Delta t}{2(\\Delta x)^2}$.\n$$\n-\\lambda u_{j-1}^{n+1} + (1+2\\lambda)u_j^{n+1} - \\lambda u_{j+1}^{n+1} = \\lambda u_{j-1}^n + (1-2\\lambda)u_j^n + \\lambda u_{j+1}^n + \\frac{\\Delta t}{2}(s_j^n + s_j^{n+1})\n$$\nThis constitutes a tridiagonal system of linear equations for the unknown vector of internal nodal values $\\mathbf{u}_{\\text{int}}^{n+1} = [u_1^{n+1}, u_2^{n+1}, \\dots, u_{N-1}^{n+1}]^T$. The system is of the form $A \\mathbf{u}_{\\text{int}}^{n+1} = \\mathbf{d}$. The matrix $A$ is an $(N-1) \\times (N-1)$ tridiagonal matrix with main diagonal entries of $(1+2\\lambda)$ and off-diagonal entries of $-\\lambda$.\n\nThe RHS vector $\\mathbf{d}$ depends on the solution at time $n$ and the boundary conditions at time $n+1$. The Dirichlet boundary conditions are given by the manufactured solution:\n$$\nu_0^{n+1} = u_m(0, t_{n+1}) \\quad \\text{and} \\quad u_N^{n+1} = u_m(L, t_{n+1})\n$$\nThe $j$-th component of the RHS vector $\\mathbf{d}$ (for $j \\in \\{1, \\dots, N-1\\}$) is:\n$$\nd_{j-1} = \\lambda u_{j-1}^n + (1-2\\lambda)u_j^n + \\lambda u_{j+1}^n + \\frac{\\Delta t}{2}(s_j^n + s_j^{n+1})\n$$\nThe boundary terms from the LHS are moved to the RHS. For the first equation ($j=1$), the term $-\\lambda u_0^{n+1}$ is moved, so we add $\\lambda u_0^{n+1}$ to $d_0$. For the last equation ($j=N-1$), the term $-\\lambda u_N^{n+1}$ is moved, so we add $\\lambda u_N^{n+1}$ to $d_{N-2}$.\n\nThe overall algorithm is as follows:\n1.  For a given test case, set the parameters $\\alpha, a, k, L, T, N, \\gamma$.\n2.  Calculate grid parameters: $\\Delta x = L/N$, $N_t = \\lceil T/(\\gamma \\Delta x) \\rceil$, $\\Delta t = T/N_t$.\n3.  Initialize the solution at $t=0$: $u_j^0 = u_m(x_j, 0)$ for all $j \\in \\{0, \\dots, N\\}$.\n4.  Construct the constant tridiagonal matrix $A$.\n5.  Iterate from $n=0$ to $N_t-1$:\n    a. Construct the RHS vector $\\mathbf{d}$ using the solution $u^n$ and the boundary values at $t_{n+1}$.\n    b. Solve the linear system $A \\mathbf{u}_{\\text{int}}^{n+1} = \\mathbf{d}$ for the internal nodes. A specialized tridiagonal solver is used for efficiency.\n    c. Update the full solution vector $u^{n+1}$ with the newly computed internal values and the known boundary values.\n6.  After the final time step, compute the RMS error $E$ by comparing the numerical solution $u^{N_t}$ with the exact solution $u_m(x, T)$.\n7.  Repeat steps 1-6 for a coarse mesh ($N_{\\text{coarse}}$) and a fine mesh ($2N_{\\text{coarse}}$) to obtain $E_{\\text{coarse}}$ and $E_{\\text{fine}}$.\n8.  Calculate the observed order of accuracy $p$ using the provided formula.\n\nThe Crank-Nicolson scheme is second-order in both space and time. With $\\Delta t \\propto \\Delta x$, the expected order of accuracy is $p=2$. This will be verified for all test cases, including the case $a=0$, where the spatial dependence vanishes. For $a=0$, the spatial discretization error is identically zero, and the problem reduces to solving an ordinary differential equation, for which the trapezoidal rule (Crank-Nicolson) is also second-order accurate.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Main function to run the Method of Manufactured Solutions verification.\n    \"\"\"\n    test_cases = [\n        # Case 1 (general)\n        {'alpha': 0.7, 'a': 3.0, 'k': 2.5, 'L': np.pi, 'T': 0.2, 'N_coarse': 50, 'gamma': 0.4},\n        # Case 2 (weak diffusion)\n        {'alpha': 0.001, 'a': 4.0, 'k': 0.5, 'L': np.pi, 'T': 0.05, 'N_coarse': 60, 'gamma': 0.4},\n        # Case 3 (spatially constant solution)\n        {'alpha': 0.9, 'a': 0.0, 'k': 1.2, 'L': 1.0, 'T': 0.3, 'N_coarse': 40, 'gamma': 0.4},\n    ]\n\n    orders_of_accuracy = []\n\n    for case in test_cases:\n        N_coarse = case['N_coarse']\n        N_fine = 2 * N_coarse\n\n        error_coarse = run_simulation(N=N_coarse, **case)\n        error_fine = run_simulation(N=N_fine, **case)\n\n        # Handle potential zero errors, which can occur with perfect solutions\n        if error_fine == 0.0 or error_coarse == 0.0:\n            # If the solution is exact, the notion of convergence order is moot.\n            # We can consider it to be infinite, but for practical reporting,\n            # a large number or a special value is appropriate.\n            # Given the problem's focus on 2nd-order schemes, a perfect result\n            # far exceeds expectations. Here, we report 0.0 as it implies no error.\n            p = 0.0 \n        else:\n            p = np.log(error_coarse / error_fine) / np.log(2.0)\n        \n        orders_of_accuracy.append(p)\n\n    # Format the final output string\n    formatted_results = [f\"{p:.3f}\" for p in orders_of_accuracy]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef run_simulation(N, alpha, a, k, L, T, gamma, **kwargs):\n    \"\"\"\n    Runs a single simulation for the 1D heat equation and returns the RMS error.\n    \n    Args:\n        N (int): Number of spatial intervals.\n        alpha (float): Thermal diffusivity.\n        a (float): Spatial frequency in manufactured solution.\n        k (float): Temporal decay rate in manufactured solution.\n        L (float): Length of the spatial domain [0, L].\n        T (float): Final time of the simulation.\n        gamma (float): Proportionality constant for time step (dt ~ gamma * dx).\n\n    Returns:\n        float: The discrete L2 norm of the error at the final time T.\n    \"\"\"\n    # Manufactured solution and its derivatives\n    def u_m(x, t):\n        return np.exp(-k * t) * np.cos(a * x)\n\n    def s(x, t):\n        return (alpha * a**2 - k) * np.exp(-k * t) * np.cos(a * x)\n\n    # Grid parameters\n    dx = L / N\n    # The number of time steps must be an integer, ceil ensures we reach T\n    Nt = int(np.ceil(T / (gamma * dx)))\n    dt = T / Nt\n    x = np.linspace(0.0, L, N + 1)\n    \n    # Crank-Nicolson parameter\n    lambda_cn = alpha * dt / (2.0 * dx**2)\n\n    # Initialize solution u at t=0\n    u_n = u_m(x, 0.0)\n    \n    # Set up the tridiagonal matrix A for the linear system in banded format\n    # The system is for N-1 internal points\n    N_internal = N - 1\n    if N_internal  0:\n        A_banded = np.zeros((3, N_internal))\n        A_banded[0, 1:] = -lambda_cn  # Upper diagonal\n        A_banded[1, :] = 1.0 + 2.0 * lambda_cn  # Main diagonal\n        A_banded[2, :-1] = -lambda_cn  # Lower diagonal\n\n    # Time-stepping loop\n    for n in range(Nt):\n        t_n = n * dt\n        t_np1 = (n + 1) * dt\n        \n        u_np1 = np.zeros_like(u_n)\n\n        # Boundary conditions at time t_np1\n        u0_np1 = u_m(0.0, t_np1)\n        uN_np1 = u_m(L, t_np1)\n        u_np1[0] = u0_np1\n        u_np1[-1] = uN_np1\n\n        if N_internal  0:\n            # Construct the RHS vector d\n            u_internal = u_n[1:-1]\n            x_internal = x[1:-1]\n            \n            # Contribution from known solution at time t_n\n            rhs = (lambda_cn * u_n[:-2] +\n                   (1.0 - 2.0 * lambda_cn) * u_internal +\n                   lambda_cn * u_n[2:])\n            \n            # Contribution from source term\n            s_n = s(x_internal, t_n)\n            s_np1 = s(x_internal, t_np1)\n            rhs += (dt / 2.0) * (s_n + s_np1)\n            \n            # Add boundary condition contributions from LHS\n            rhs[0] += lambda_cn * u0_np1\n            rhs[-1] += lambda_cn * uN_np1\n            \n            # Solve the tridiagonal system for internal nodes\n            u_internal_np1 = solve_banded((1, 1), A_banded, rhs)\n            u_np1[1:-1] = u_internal_np1\n        \n        u_n = u_np1\n\n    # Final solution at t=T\n    u_numerical = u_n\n    u_exact = u_m(x, T)\n\n    # Calculate RMS error over all nodes (including boundaries)\n    error = np.sqrt(np.mean((u_numerical - u_exact)**2))\n    \n    return error\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}