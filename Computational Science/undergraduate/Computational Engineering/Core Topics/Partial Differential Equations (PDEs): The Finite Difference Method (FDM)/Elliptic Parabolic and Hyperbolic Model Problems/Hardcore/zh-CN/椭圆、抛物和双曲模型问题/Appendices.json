{
    "hands_on_practices": [
        {
            "introduction": "本实践聚焦于泊松方程，这是一个典型的椭圆问题，用于描述稳态现象，如热量分布或静电势。您将在一个非平凡的L型域上实现一个有限差分求解器，并使用“人造解”方法进行收敛性研究，以验证您的数值方案是否达到了其理论精度。这项练习对于培养开发稳健可靠计算模型的能力至关重要 。",
            "id": "2388329",
            "problem": "要求您实现、执行并分析一个数值实验，以验证应用于计算工程中一个椭圆模型问题的标准格式的收敛阶。考虑泊松方程，这是一个定义在L形区域上的椭圆偏微分方程。L形区域由正方形 $\\Omega_{\\mathrm{sq}} = [-1,1]\\times[-1,1]$ 移除右下象限定义：$\\Omega = \\Omega_{\\mathrm{sq}} \\setminus \\left([0,1]\\times[-1,0]\\right)$。设在 $\\Omega$ 中 $-\\Delta u = f$，在 $\\partial\\Omega$ 上有狄利克雷边界条件 $u = g$。您必须通过精确解方法，使用光滑数据来验证二阶有限差分法的收敛率，从而使得精确解 $u$ 是已知的。\n\n从基本原理出发，利用 $-\\Delta$ 是一个椭圆算子这一分类，通过对 $u$ 的泰勒展开和拉普拉斯算子的定义，在均匀笛卡尔网格上推导出一个二阶相容的离散格式。通过在边界网格节点上强制 $u=g$ 来施加狄利克雷边界条件。通过掩码掉 $\\Omega$ 外部的网格点来处理非矩形几何形状，并将离散边界定义为那些至少有一个掩码外邻居或位于 $\\Omega_{\\mathrm{sq}}$ 边界上的掩码内节点。在 $\\Omega$ 的内部（非边界）节点上组装并求解得到的稀疏线性系统。\n\n使用精确解方法：对于一个给定的光滑函数 $u(x,y)$，在 $\\Omega$ 中设置 $f(x,y)=-\\Delta u(x,y)$，并在 $\\partial\\Omega$ 上设置 $g(x,y)=u(x,y)$。对于在 $[-1,1]$ 上每个坐标方向有 $N$ 个子区间的网格（因此网格间距 $h = 2/N$，网格节点为 $\\{x_i\\}_{i=0}^N$, $\\{y_j\\}_{j=0}^N$），计算数值解，然后计算在 $\\Omega$ 上的离散 $L^2$ 误差，\n$$\nE_h = \\left( \\sum_{(x_i,y_j)\\in\\Omega_h} \\left(u_h(x_i,y_j) - u(x_i,y_j)\\right)^2\\, h^2 \\right)^{1/2},\n$$\n其中 $\\Omega_h$ 是位于 $\\Omega$ 内的网格节点集合，$u_h$ 是施加了狄利克雷数据的离散解，$u$ 是解析解。通过以下公式估算连续加密网格间的观测收敛阶：\n$$\np \\approx \\frac{\\log(E_{h}/E_{h/2})}{\\log(2)}.\n$$\n您必须实现构建带掩码的L形网格、识别 $\\Omega$ 的内部和边界节点、用二阶中心差分格式组装五点离散拉普拉斯算子、通过消元法施加狄利克雷边界条件以及求解所得线性系统的算法步骤。\n\n测试套件：\n实现三个独立的精确解测试用例，每个用例在三个连续加密的网格上进行评估，并对每个用例报告平均观测阶 $\\bar{p}$，该值由两次连续加密估算值的算术平均值计算得出。\n\n- 用例 $\\mathsf{A}$ (理想情况)：$u(x,y) = \\sin(\\pi x)\\sin(\\pi y)$, $f(x,y) = 2\\pi^2 \\sin(\\pi x)\\sin(\\pi y)$，其中 $N \\in \\{16,32,64\\}$。\n\n- 用例 $\\mathsf{B}$ (粗网格边界情况)：$u(x,y) = e^{x+y}$, $f(x,y) = -2 e^{x+y}$，其中 $N \\in \\{8,16,32\\}$。\n\n- 用例 $\\mathsf{C}$ (各向异性光滑模式)：$u(x,y) = \\cos(2x)\\cos(3y)$, $f(x,y) = 13 \\cos(2x)\\cos(3y)$，其中 $N \\in \\{24,48,96\\}$。\n\n要求的最终输出格式：\n您的程序必须生成单行输出，其中包含用例 $\\mathsf{A}$、$\\mathsf{B}$ 和 $\\mathsf{C}$ 的三个平均观测阶，按此顺序排列，格式为用方括号括起来的逗号分隔列表，例如 $[p_A,p_B,p_C]$。每个 $p$ 必须打印为浮点数。不允许有其他输出。不涉及物理单位，因此仅报告纯数字。三角函数中隐含的角度以弧度为单位。任何地方都不使用百分比；所有量都应报告为普通十进制数。",
            "solution": "我们考虑在L形区域 $\\Omega = [-1,1]^2 \\setminus \\left([0,1]\\times[-1,0]\\right)$ 中由泊松方程 $-\\Delta u = f$ 给出的椭圆模型问题，其在边界 $\\partial \\Omega$ 上满足狄利克雷边界条件 $u=g$。拉普拉斯算子 $\\Delta$ 是椭圆的，因为其主象征 $\\sigma(\\Delta)(\\xi) = -|\\xi|^2$ 对于非零 $\\xi$ 是负定的，这确保了该模型问题是椭圆的。\n\n数值格式的基于原理的推导源于以下基本事实：(i) 笛卡尔坐标中拉普拉斯算子的定义，$\\Delta u = u_{xx} + u_{yy}$，(ii) 光滑函数的泰勒展开以获得中心差分公式，以及 (iii) 精确解方法，其中预先指定一个精确解 $u$ 并由此导出 $f=-\\Delta u$ 以及边界数据 $g=u$。\n\n为了在均匀网格上获得二阶相容的离散近似，设网格点为 $(x_i,y_j)$，其中 $i,j=0,\\dots,N$，网格间距为 $h=2/N$，覆盖区域为 $[-1,1]\\times[-1,1]$。对于一个光滑函数 $u$，泰勒展开可得到标准的二阶中心差分近似：\n$$\nu_{xx}(x_i,y_j) \\approx \\frac{u(x_{i+1},y_j) - 2u(x_i,y_j) + u(x_{i-1},y_j)}{h^2},\\quad\nu_{yy}(x_i,y_j) \\approx \\frac{u(x_i,y_{j+1}) - 2u(x_i,y_j) + u(x_i,y_{j-1})}{h^2}.\n$$\n将它们相加，得到具有二阶截断误差的拉普拉斯算子五点模板：\n$$\n-\\Delta u(x_i,y_j) \\approx \\frac{4 u_{i,j} - u_{i+1,j} - u_{i-1,j} - u_{i,j+1} - u_{i,j-1}}{h^2},\n$$\n其中 $u_{i,j} = u(x_i,y_j)$。在足够光滑的条件下，局部截断误差为 $\\mathcal{O}(h^2)$。\n\n通过掩码处理几何形状：在网格点上定义一个布尔掩码，如果 $(x_i,y_j) \\in \\Omega$ 则标记为“内部”，否则标记为“外部”。对于L形区域 $\\Omega = [-1,1]^2 \\setminus ([0,1]\\times[-1,0])$，只要一个网格节点不同时满足 $x_i \\ge 0$ 和 $y_j \\le 0$，它就位于内部。边界节点是一个内部节点，它要么位于外部方框边界上（$i\\in\\{0,N\\}$ 或 $j\\in\\{0,N\\}$），要么至少有一个直接（轴向）邻居在外部。内部未知数是那些不属于边界节点的内部节点。通过在边界节点上设置 $u=g$ 来施加狄利克雷边界条件，并通过将邻近边界节点的内部节点的已知邻居贡献移到右侧来处理。\n\n代数系统：枚举内部未知数并组装一个表示五点模板的稀疏矩阵 $\\mathbf{A}$。对于一个内部节点 $(i,j)$，\n$$\n\\frac{4}{h^2} u_{i,j} - \\frac{1}{h^2}\\big(u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1}\\big) = f(x_i,y_j),\n$$\n其中相邻边界节点上的 $u$ 项被移到右侧。求解得到的线性系统 $\\mathbf{A}\\mathbf{u}=\\mathbf{b}$ 以获得内部未知数。通过用精确的狄利克雷数据 $g=u$ 填充边界节点，并用数值解填充内部节点，来获得完整的网格解。\n\n误差测量和收敛阶：区域上的离散 $L^2$ 误差计算如下\n$$\nE_h = \\left( \\sum_{(x_i,y_j)\\in\\Omega_h} \\left(u_h(x_i,y_j) - u(x_i,y_j)\\right)^2\\, h^2 \\right)^{1/2},\n$$\n这是连续 $L^2$ 范数的一个标准基于求积的近似。对于间距分别为 $h$ 和 $h/2$ 的两个连续网格，观测阶为\n$$\np = \\frac{\\log(E_h/E_{h/2})}{\\log(2)}.\n$$\n对于光滑解和五点中心差分近似，该格式是二阶相容的。在稳定性条件下（对于带有狄利克雷条件的椭圆算子的这种对称正定离散化，稳定性是成立的），Lax-Richtmyer等价性定理确保了二阶收敛，因此对于足够细的网格，预期 $p\\approx 2$。\n\n测试套件中使用的精确解：\n- 用例 $\\mathsf{A}$：$u(x,y)=\\sin(\\pi x)\\sin(\\pi y)$，则 $\\Delta u = -2\\pi^2 \\sin(\\pi x)\\sin(\\pi y)$ 所以 $f(x,y)=2\\pi^2 \\sin(\\pi x)\\sin(\\pi y)$，其中 $N\\in\\{16,32,64\\}$。\n- 用例 $\\mathsf{B}$：$u(x,y)=e^{x+y}$，则 $\\Delta u = 2 e^{x+y}$ 所以 $f(x,y)=-2 e^{x+y}$，其中 $N\\in\\{8,16,32\\}$。\n- 用例 $\\mathsf{C}$：$u(x,y)=\\cos(2x)\\cos(3y)$，则 $\\Delta u = -(2^2+3^2)\\cos(2x)\\cos(3y)=-13\\cos(2x)\\cos(3y)$ 所以 $f(x,y)=13\\cos(2x)\\cos(3y)$，其中 $N\\in\\{24,48,96\\}$。\n\n连接原理与实现的算法设计摘要：\n- 定义具有 $N$ 个子区间和间距 $h=2/N$ 的均匀网格。\n- 为 $\\Omega$ 构建内部掩码，并使用邻居检查来检测边界节点。\n- 对于每个内部节点，将五点拉普拉斯算子组装成稀疏矩阵，并通过加上 $f(x_i,y_j)$ 和减去已知边界值的贡献来构造右端项。\n- 求解内部节点的稀疏线性系统，并通过在边界节点插入狄利克雷值来组合成完整的网格解。\n- 为每个网格计算 $E_h$，然后在连续加密中计算两个 $p$ 值并求平均，以报告每个用例的 $\\bar{p}$。\n- 因为 $u$ 是光滑的且模板是二阶精确的，所以所有三个用例的观测阶都应接近 $2$。由于预渐近效应和离散边界中几何引起的非规则性，预计在粗网格上会有微小偏差，但平均值仍应接近 $2$。\n\n程序输出单行 $[p_A,p_B,p_C]$，包含三个平均观测阶，三角函数使用弧度，不带任何物理单位，满足格式规范。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import coo_matrix, csr_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef build_domain_masks(N):\n    \"\"\"\n    Build grid coordinates and masks for the L-shaped domain.\n    Domain: [-1,1]^2 minus the lower-right quadrant [0,1] x [-1,0].\n    \"\"\"\n    h = 2.0 / N\n    x = np.linspace(-1.0, 1.0, N + 1)\n    y = np.linspace(-1.0, 1.0, N + 1)\n    X, Y = np.meshgrid(x, y, indexing='ij')\n\n    # Inside if not simultaneously (x >= 0 and y = 0)\n    inside = np.logical_not((X >= 0.0)  (Y = 0.0))\n\n    # Boundary: inside but on outer box, or has a neighbor outside\n    boundary = np.zeros_like(inside, dtype=bool)\n    boundary |= (np.arange(N + 1)[:, None] == 0) | (np.arange(N + 1)[:, None] == N)\n    boundary |= (np.arange(N + 1)[None, :] == 0) | (np.arange(N + 1)[None, :] == N)\n    boundary = inside  # ensure boundary only flagged inside\n\n    # neighbor-based boundary detection\n    # shift masks for 4-neighborhood\n    # For neighbors, use 'outside' as False arrays where appropriate\n    outside = ~inside\n    # Check any of the 4 axial neighbors is outside\n    neighbor_outside = np.zeros_like(inside, dtype=bool)\n    neighbor_outside[1:, :] |= outside[:-1, :]   # left neighbor outside\n    neighbor_outside[:-1, :] |= outside[1:, :]   # right neighbor outside\n    neighbor_outside[:, 1:] |= outside[:, :-1]   # bottom neighbor outside\n    neighbor_outside[:, :-1] |= outside[:, 1:]   # top neighbor outside\n\n    boundary |= (inside  neighbor_outside)\n\n    # Interior unknowns: inside but not boundary\n    unknown = inside  (~boundary)\n\n    return X, Y, inside, boundary, unknown, h\n\ndef assemble_and_solve(N, u_exact_func, f_func):\n    \"\"\"\n    Assemble the 5-point Laplacian system on the L-shaped domain mask and solve.\n    Enforce Dirichlet boundary using u_exact_func on boundary nodes.\n    \"\"\"\n    X, Y, inside, boundary, unknown, h = build_domain_masks(N)\n\n    # Map unknown nodes to indices\n    idx = -np.ones_like(inside, dtype=int)\n    unknown_positions = np.argwhere(unknown)\n    for k, (i, j) in enumerate(unknown_positions):\n        idx[i, j] = k\n    n_unknowns = unknown_positions.shape[0]\n\n    # Precompute exact u and f on all nodes\n    U_exact = u_exact_func(X, Y)\n    F = f_func(X, Y)\n\n    # Sparse matrix triplets\n    rows = []\n    cols = []\n    data = []\n    rhs = np.zeros(n_unknowns, dtype=float)\n\n    # For each unknown, add 5-point stencil and boundary contributions\n    for k, (i, j) in enumerate(unknown_positions):\n        # Diagonal entry\n        diag = 4.0 / (h * h)\n        rows.append(k); cols.append(k); data.append(diag)\n\n        # Neighbors: (i+1,j), (i-1,j), (i,j+1), (i,j-1)\n        for (ip, jp) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n            if unknown[ip, jp]:\n                # neighbor unknown -> coefficient -1/h^2\n                rows.append(k); cols.append(idx[ip, jp]); data.append(-1.0 / (h * h))\n            elif boundary[ip, jp]:\n                # neighbor boundary -> move known Dirichlet to RHS\n                rhs[k] += (1.0 / (h * h)) * U_exact[ip, jp]\n            else:\n                # Should not happen for interior unknowns: all neighbors must be inside.\n                # But we keep a safe-guard; in L-shaped aligned domain this case is absent.\n                pass\n\n        # Right-hand side f at (i,j)\n        rhs[k] += F[i, j]\n\n    if n_unknowns > 0:\n        A = coo_matrix((data, (rows, cols)), shape=(n_unknowns, n_unknowns)).tocsr()\n        u_int = spsolve(A, rhs)\n    else:\n        u_int = np.array([])\n\n    # Compose full grid solution: boundary from U_exact, interior from u_int\n    U_num = np.array(U_exact)  # start from exact for convenience (boundary exact)\n    if n_unknowns > 0:\n        for val, (i, j) in zip(u_int, unknown_positions):\n            U_num[i, j] = val\n\n    # Compute discrete L2 error over inside nodes\n    err_sq = ((U_num - U_exact) ** 2) * inside.astype(float)\n    E_h = np.sqrt(np.sum(err_sq) * (h * h))\n    return E_h\n\ndef observed_order(errors, hs):\n    \"\"\"\n    Compute observed orders between successive refinements and return average.\n    \"\"\"\n    orders = []\n    for k in range(len(errors) - 1):\n        if errors[k+1] > 0 and errors[k] > 0:\n            p = np.log(errors[k] / errors[k+1]) / np.log(hs[k] / hs[k+1])\n            orders.append(p)\n    if len(orders) == 0:\n        return float('nan')\n    return float(np.mean(orders))\n\ndef case_A():\n    # u = sin(pi x) sin(pi y); f = 2*pi^2 * sin(pi x) sin(pi y)\n    def u_exact(X, Y):\n        return np.sin(np.pi * X) * np.sin(np.pi * Y)\n    def f_func(X, Y):\n        return 2.0 * (np.pi ** 2) * np.sin(np.pi * X) * np.sin(np.pi * Y)\n\n    Ns = [16, 32, 64]\n    errors = []\n    hs = []\n    for N in Ns:\n        E = assemble_and_solve(N, u_exact, f_func)\n        errors.append(E)\n        hs.append(2.0 / N)\n    return observed_order(errors, hs)\n\ndef case_B():\n    # u = exp(x+y); f = -2*exp(x+y)\n    def u_exact(X, Y):\n        return np.exp(X + Y)\n    def f_func(X, Y):\n        return -2.0 * np.exp(X + Y)\n\n    Ns = [8, 16, 32]\n    errors = []\n    hs = []\n    for N in Ns:\n        E = assemble_and_solve(N, u_exact, f_func)\n        errors.append(E)\n        hs.append(2.0 / N)\n    return observed_order(errors, hs)\n\ndef case_C():\n    # u = cos(2x) cos(3y); f = 13 cos(2x) cos(3y)\n    def u_exact(X, Y):\n        return np.cos(2.0 * X) * np.cos(3.0 * Y)\n    def f_func(X, Y):\n        return 13.0 * np.cos(2.0 * X) * np.cos(3.0 * Y)\n\n    Ns = [24, 48, 96]\n    errors = []\n    hs = []\n    for N in Ns:\n        E = assemble_and_solve(N, u_exact, f_func)\n        errors.append(E)\n        hs.append(2.0 / N)\n    return observed_order(errors, hs)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case returns an average observed order of convergence.\n    results = []\n    results.append(case_A())\n    results.append(case_B())\n    results.append(case_C())\n\n    # Format each result to a reasonable number of decimals\n    formatted = [\"{:.6f}\".format(r) for r in results]\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "抛物线型方程，如对流-扩散方程，用于模拟包含输运和耗散的时间依赖过程。本练习将展示计算流体动力学中的一个关键挑战：当对对流占主导的问题应用标准中心差分格式时，会出现非物理振荡。通过分析结果，您将深入了解网格佩克莱数（cell Péclet number），并理解为何通常需要专门的“迎风”格式 。",
            "id": "2388332",
            "problem": "编写一个完整、可运行的程序，该程序使用标准的空间中心差分格式和全隐式时间积分器，数值求解一个一维、瞬态的对流扩散方程（一个代表性的抛物线模型问题），并定量地展示在对流占主导地位的情况下，不使用迎风格式时出现的伪振荡。\n\n控制方程为线性对流扩散方程\n$$\n\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = \\nu \\frac{\\partial^2 u}{\\partial x^2}, \\quad x \\in (0,1), \\ t \\in (0,T],\n$$\n其狄利克雷边界条件和初始条件由下式给出\n$$\nu(0,t) = 1, \\quad u(1,t) = 0, \\quad u(x,0) = 0 \\ \\text{for all} \\ x \\in (0,1).\n$$\n这里，$a$ 是恒定的对流速度，$\\nu$ 是恒定的扩散系数。这是一个抛物线型偏微分方程，源于带扩散的输运量的守恒。\n\n您必须：\n- 使用 $n_x$ 个点（包括两个边界点）对空间域进行均匀离散，空间步长为 $h = 1/(n_x-1)$。\n- 对所有内部网格点的一阶导数 $\\partial u/\\partial x$ 和二阶导数 $\\partial^2 u/\\partial x^2$ 均使用二阶中心有限差分，不使用任何迎风格式或通量限制器。\n- 使用具有恒定时间步长 $\\Delta t$ 的全隐式（后向欧拉）时间步进法，该步长由您为保证稳定性和鲁棒性而选择。您不得使用任何人工扩散或迎风格式。\n- 在时间上推进到 $t=T$，然后通过计算有多少内部网格值违反了数据所蕴含的极值原理界限来诊断伪振荡，即有多少内部 $u$ 值在小容差 $\\varepsilon$ 范围内超出了区间 $[0,1]$。使用 $\\varepsilon = 10^{-8}$。\n\n您的程序必须实现以下参数化测试套件，其中每个测试用例是一个元组 $(a,\\nu,n_x,T)$:\n- 测试 A（扩散主导的“理想情况”）：$(a,\\nu,n_x,T) = (1.0, 0.05, 101, 2.0)$。\n- 测试 B（对流主导）：$(a,\\nu,n_x,T) = (1.0, 0.001, 101, 2.0)$。\n- 测试 C（强对流主导）：$(a,\\nu,n_x,T) = (5.0, 0.001, 101, 2.0)$。\n\n仅使用中心差分和全隐式时间积分器；不允许使用迎风格式、人工粘性、通量限制器和斜率限制器。\n\n对于每个测试用例，计算一个整数：\n- 内部网格点 $x_i$ 处 $u(x_i,T)  -\\varepsilon$ 或 $u(x_i,T)  1+\\varepsilon$ 的计数。\n\n您的程序应生成单行输出，其中包含测试 A、B 和 C 的三个整数结果，按此顺序排列，以逗号分隔并用方括号括起来，例如 $[r_1,r_2,r_3]$。\n\n您必须遵循的实现细节：\n- 通过以下方式离散化内部节点 $x_i$ 处（间距为 $h$）的空间导数\n$$\n\\left.\\frac{\\partial u}{\\partial x}\\right|_{x_i} \\approx \\frac{u_{i+1}-u_{i-1}}{2h}, \\qquad\n\\left.\\frac{\\partial^2 u}{\\partial x^2}\\right|_{x_i} \\approx \\frac{u_{i-1}-2u_i+u_{i+1}}{h^2}.\n$$\n- 使用全隐式（后向欧拉）时间离散化\n$$\n\\frac{u^{n+1} - u^n}{\\Delta t} + a \\, D_0 u^{n+1} = \\nu \\, D_2 u^{n+1},\n$$\n其中 $D_0$ 和 $D_2$ 是上面定义的中心有限差分算子，应用于时间层 $n+1$。\n- 在每个时间步为内部未知数构建生成的三对角线性系统，并在任何时候都保持狄利克雷边界值的条件下，（在数值精度内）精确求解该系统，而不使用迭代求解器。\n- 以科学合理的方式选择 $\\Delta t$，例如基于对流时间尺度和网格间距（例如，与 $h/a$ 成比例），并在代码中以注释形式记录您的选择。您不得依赖用户输入。\n\n本问题中的所有量都是无量纲和无单位的。最终输出必须是整数。程序必须是自包含的，不需要任何输入。输出必须是上面指定的确切格式的单行。",
            "solution": "所提出的问题是计算工程领域一个有效且适定的练习。它涉及一维线性对流扩散方程的数值解，这是一个典型的抛物线型偏微分方程（PDE）。所有必要的数据，包括控制方程、域、边界和初始条件、离散化格式以及具体的测试参数，均已提供。该问题具有科学依据，因为它关注的是一个有充分记录的现象：在对流主导的流动中使用中心差分格式时会产生伪振荡，这是偏微分方程数值方法研究中的一个基本课题。目标清晰，方法论明确。因此，可以构建一个解决方案。\n\n控制方程为：\n$$\n\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = \\nu \\frac{\\partial^2 u}{\\partial x^2}, \\quad x \\in (0,1), \\ t \\in (0,T]\n$$\n初始条件为 $u(x,0) = 0$（对于 $x \\in (0,1)$），狄利克雷边界条件为 $u(0,t) = 1$，$u(1,t) = 0$。\n\n我们首先将空间域 $x \\in [0,1]$ 离散为 $n_x$ 个点，得到均匀的网格间距 $h = 1 / (n_x - 1)$。解 $u(x,t)$ 在离散点 $(x_i, t_n)$ 处近似，其中 $x_i = (i-1)h$（对于 $i=1, 2, \\dots, n_x$）和 $t_n = n \\Delta t$。令 $u_i^n \\approx u(x_i, t_n)$。\n\n该问题要求使用全隐式时间积分格式（后向欧拉）。将其应用于控制偏微分方程，我们在未来的时间层 $n+1$ 评估空间导数：\n$$\n\\frac{u^{n+1}_i - u^{n}_i}{\\Delta t} + a \\left. \\frac{\\partial u}{\\partial x} \\right|_i^{n+1} = \\nu \\left. \\frac{\\partial^2 u}{\\partial x^2} \\right|_i^{n+1}\n$$\n该方程是为所有内部网格点，即 $i = 2, 3, \\dots, n_x-1$ 建立的。\n\n接下来，我们代入指定的二阶中心有限差分近似来计算空间导数：\n$$\n\\left. \\frac{\\partial u}{\\partial x} \\right|_i^{n+1} \\approx \\frac{u_{i+1}^{n+1} - u_{i-1}^{n+1}}{2h}\n$$\n$$\n\\left. \\frac{\\partial^2 u}{\\partial x^2} \\right|_i^{n+1} \\approx \\frac{u_{i-1}^{n+1} - 2u_i^{n+1} + u_{i+1}^{n+1}}{h^2}\n$$\n将这些表达式代入时间离散化的方程，得到：\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} + a \\left( \\frac{u_{i+1}^{n+1} - u_{i-1}^{n+1}}{2h} \\right) = \\nu \\left( \\frac{u_{i-1}^{n+1} - 2u_i^{n+1} + u_{i+1}^{n+1}}{h^2} \\right)\n$$\n为了求解新时间步的未知值 $u_i^{n+1}$，我们重新整理方程，将所有在时间层 $n+1$ 的项组合在左侧，所有在时间层 $n$ 的已知项放在右侧。\n$$\nu_i^{n+1} + \\frac{a \\Delta t}{2h} (u_{i+1}^{n+1} - u_{i-1}^{n+1}) - \\frac{\\nu \\Delta t}{h^2} (u_{i-1}^{n+1} - 2u_i^{n+1} + u_{i+1}^{n+1}) = u_i^n\n$$\n收集对应于网格点 $i-1$、$i$ 和 $i+1$ 的项：\n$$\n\\left( -\\frac{a \\Delta t}{2h} - \\frac{\\nu \\Delta t}{h^2} \\right) u_{i-1}^{n+1} + \\left( 1 + \\frac{2\\nu \\Delta t}{h^2} \\right) u_i^{n+1} + \\left( \\frac{a \\Delta t}{2h} - \\frac{\\nu \\Delta t}{h^2} \\right) u_{i+1}^{n+1} = u_i^n\n$$\n这就为未知的内部节点值 $\\mathbf{u}_{\\text{int}}^{n+1} = [u_2^{n+1}, u_3^{n+1}, \\dots, u_{n_x-1}^{n+1}]^T$ 形成了一个线性方程组。该系统可以写成矩阵形式 $A \\mathbf{u}_{\\text{int}}^{n+1} = \\mathbf{b}$。矩阵 $A$ 是一个大小为 $(n_x-2) \\times (n_x-2)$ 的三对角矩阵。我们定义下对角线 ($l$)、主对角线 ($d$) 和上对角线 ($r$) 的系数：\n$$\nl = -\\frac{a \\Delta t}{2h} - \\frac{\\nu \\Delta t}{h^2} \\quad \\text{(次对角线)}\n$$\n$$\nd = 1 + \\frac{2\\nu \\Delta t}{h^2} \\quad \\text{(主对角线)}\n$$\n$$\nr = \\frac{a \\Delta t}{2h} - \\frac{\\nu \\Delta t}{h^2} \\quad \\text{(超对角线)}\n$$\n右侧向量 $\\mathbf{b}$ 由前一个时间步的值 $u_i^n$ 组成，并根据边界条件进行了调整。边界条件为 $u(0,t) = u_1 = 1$ 和 $u(1,t) = u_{n_x} = 0$。这些是时间层 $n+1$ 的已知值。\n\n对于第一个内部点 ($i=2$)：\n$l u_1^{n+1} + d u_2^{n+1} + r u_3^{n+1} = u_2^n$。由于 $u_1^{n+1}=1$，这变为 $d u_2^{n+1} + r u_3^{n+1} = u_2^n - l$。\nRHS 向量的第一个条目是 $b_1 = u_2^n - l$。\n\n对于最后一个内部点 ($i=n_x-1$)：\n$l u_{n_x-2}^{n+1} + d u_{n_x-1}^{n+1} + r u_{n_x}^{n+1} = u_{n_x-1}^n$。由于 $u_{n_x}^{n+1}=0$，这变为 $l u_{n_x-2}^{n+1} + d u_{n_x-1}^{n+1} = u_{n_x-1}^n$。\nRHS 向量的最后一个条目是 $b_{n_x-2} = u_{n_x-1}^n$。\n\n对于所有其他内部点 ($2  i  n_x-1$)，RHS 向量中对应的条目就是 $b_{i-1} = u_i^n$。\n\n非物理振荡的出现由网格佩克莱数 (cell Péclet number) $Pe_h = \\frac{|a|h}{2\\nu}$ 控制。中心差分格式的理论表明，当 $Pe_h > 1$ 时，解容易出现伪非物理振荡，因为矩阵 $A$ 可能会失去其对角占优特性，而这是满足离散极值原理的一个条件。\n让我们为给定的测试用例评估 $Pe_h$，其中 $h=1/(101-1) = 0.01$：\n- 测试 A: $Pe_h = \\frac{1.0 \\times 0.01}{2 \\times 0.05} = 0.1$。由于 $Pe_h  1$，解应该是光滑且物理上正确的。\n- 测试 B: $Pe_h = \\frac{1.0 \\times 0.01}{2 \\times 0.001} = 5$。由于 $Pe_h > 1$，预计会出现振荡。\n- 测试 C: $Pe_h = \\frac{5.0 \\times 0.01}{2 \\times 0.001} = 25$。由于 $Pe_h \\gg 1$，预计会出现严重振荡。\n\n总体算法如下：\n1. 对于每个测试用例 $(a, \\nu, n_x, T)$，初始化计算参数。选择一个合理的时间步长 $\\Delta t$ 是基于 Courant-Friedrichs-Lewy (CFL) 条件，例如 $\\Delta t = C \\frac{h}{a}$，其中 $C=0.5$，以确保时间分辨率足以应对平流过程。\n2. 根据初始条件 $u(x,0)=0$ 初始化解向量 $\\mathbf{u}^0$。\n3. 使用系数 $l$、$d$ 和 $r$ 构建常数三对角矩阵 $A$。\n4. 从 $t=0$ 到 $t=T$ 进行时间迭代。在每个步骤中：\n   a. 使用上一步的解 $\\mathbf{u}^n$ 并结合边界条件，构建右侧向量 $\\mathbf{b}$。\n   b. 使用直接求解器求解线性系统 $A \\mathbf{u}_{\\text{int}}^{n+1} = \\mathbf{b}$，以找到新时间步的内部解。\n   c. 更新完整的解向量 $\\mathbf{u}^{n+1}$。\n5. 在最后一个时间步之后，分析 $t=T$ 时的解 $\\mathbf{u}$。计算解违反极值原理的内部网格点的数量，即超出范围 $[0, 1]$ 超过一个容差 $\\varepsilon = 10^{-8}$ 的点数。\n6. 为每个测试用例记录此计数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the 1D convection-diffusion problem.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (a, nu, n_x, T)\n    test_cases = [\n        (1.0, 0.05, 101, 2.0),   # Test A: Diffusion-dominated\n        (1.0, 0.001, 101, 2.0),  # Test B: Convection-dominated\n        (5.0, 0.001, 101, 2.0),  # Test C: Strongly convection-dominated\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(*case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef solve_case(a, nu, n_x, T):\n    \"\"\"\n    Solves the 1D convection-diffusion equation for a single test case.\n\n    Args:\n        a (float): Advection speed.\n        nu (float): Diffusivity.\n        n_x (int): Number of spatial grid points.\n        T (float): Final time.\n\n    Returns:\n        int: The count of interior grid points where the solution violates\n             the maximum principle at the final time T.\n    \"\"\"\n    epsilon = 1e-8\n\n    # Spatial discretization\n    h = 1.0 / (n_x - 1)\n\n    # Time discretization\n    # A reasonable time step is chosen to ensure temporal accuracy,\n    # based on a Courant number C=0.5.\n    # The implicit scheme is unconditionally stable, but this choice\n    # ensures the advection process is well-resolved in time.\n    cfl_number = 0.5\n    dt = cfl_number * h / a\n    n_t = int(T / dt)\n\n    # Initial condition: u(x, 0) = 0 for all x in (0, 1)\n    u_n = np.zeros(n_x)\n\n    # Boundary conditions: u(0, t) = 1, u(1, t) = 0\n    u_bc_left = 1.0\n    u_bc_right = 0.0\n    \n    # Set boundary values on the initial solution vector. These are constant in time.\n    u_n[0] = u_bc_left\n    u_n[-1] = u_bc_right\n\n    # Assemble the tridiagonal matrix for the linear system A*u_np1 = b\n    # The system is for the n_x - 2 interior points.\n    num_interior_points = n_x - 2\n    \n    # Coefficients for the tridiagonal matrix A\n    l = -a * dt / (2 * h) - nu * dt / h**2   # Lower diagonal\n    d = 1 + 2 * nu * dt / h**2               # Main diagonal\n    r = a * dt / (2 * h) - nu * dt / h**2    # Upper diagonal\n\n    A = np.zeros((num_interior_points, num_interior_points))\n\n    # Populate the matrix A\n    np.fill_diagonal(A, d)\n    if num_interior_points > 1:\n        np.fill_diagonal(A[1:], l)\n        np.fill_diagonal(A[:, 1:], r)\n\n    # Time-marching loop\n    for _ in range(n_t):\n        # Construct the right-hand-side vector b\n        b = u_n[1:-1].copy()\n        \n        # Incorporate boundary conditions into the RHS\n        # For the first interior point (i=2)\n        b[0] -= l * u_bc_left\n        \n        # For the last interior point (i=n_x-1), the contribution is zero\n        # because u_bc_right is 0.\n        # b[-1] -= r * u_bc_right\n\n        # Solve the linear system for interior points at time n+1\n        try:\n            u_interior_np1 = np.linalg.solve(A, b)\n        except np.linalg.LinAlgError:\n            print(\"Error: Singular matrix. The simulation cannot proceed.\")\n            # Return an error code, e.g., -1.\n            return -1\n\n        # Update the solution vector for the next time step\n        u_n[1:-1] = u_interior_np1\n\n    # After the loop, u_n holds the solution at t=T\n    # Diagnose spurious oscillations by counting violations of the maximum principle\n    interior_solution = u_n[1:-1]\n    violations = np.sum((interior_solution  -epsilon) | (interior_solution > 1.0 + epsilon))\n    \n    return int(violations)\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "双曲型方程描述了信息以有限速度传播的波动现象。本次动手实践将使用显式迎风格式，探索线性平流方程这一最简单的双曲模型的数值解。您将直接研究 Courant-Friedrichs-Lewy (CFL) 条件，这是时间依赖双曲问题数值稳定性的基石，并观察违反该条件所带来的戏剧性后果 。",
            "id": "2388289",
            "problem": "考虑线性平流方程 $u_t + c\\,u_x = 0$，定义在周期性域 $x \\in [0,1]$ 上，周期为 $1$，即对所有 $t \\ge 0$ 都有 $u(0,t)=u(1,t)$。初始条件为 $u(x,0) = \\sin(2\\pi x)$。设空间网格是均匀的，有 $N$ 个点 $x_i = i\\,\\Delta x$，其中 $i=0,1,\\dots,N-1$，$\\Delta x = 1/N$。设时间层为 $t^n = n\\,\\Delta t$，其中 $n=0,1,2,\\dots$。定义库朗数 $\\nu = c\\,\\Delta t/\\Delta x$。使用下述显式一阶迎风有限差分格式来近似求解：\n$$\nu_i^{n+1} = u_i^n \\;-\\; \\nu^{+}\\,\\big(u_i^n - u_{i-1}^n\\big)\\;-\\;\\nu^{-}\\,\\big(u_{i+1}^n - u_i^n\\big),\n$$\n其中 $\\nu^{+}=\\max(\\nu,0)$ 且 $\\nu^{-}=\\min(\\nu,0)$，并且索引对 $N$ 取模以施加周期性边界条件。对于每个指定的参数集，从 $u_i^0 = \\sin(2\\pi x_i)$ 开始，将解推进指定的时间步数，并报告增长因子\n$$\nG \\;=\\; \\frac{\\max_i |u_i^{n_f}|}{\\max_i |u_i^{0}|},\n$$\n其中 $n_f$ 是该参数集下执行的总时间步数。\n\n您的程序必须为以下五个测试用例中的每一个计算 $G$，并生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个条目都四舍五入到恰好六位小数。不允许有其他输出。\n\n测试套件：\n- 情况 1：$c=1.0$，$N=200$，$\\Delta t=0.0035$，时间步数 $n_f=400$。此处 $\\Delta x = 1/200 = 0.005$，因此 $\\nu = c\\,\\Delta t/\\Delta x = 1.0 \\times 0.0035 / 0.005 = 0.7$。\n- 情况 2：$c=1.0$，$N=100$，$\\Delta t=0.01$，时间步数 $n_f=50$。此处 $\\Delta x = 1/100 = 0.01$，因此 $\\nu = 1.0 \\times 0.01 / 0.01 = 1.0$。\n- 情况 3：$c=1.0$，$N=100$，$\\Delta t=0.012$，时间步数 $n_f=50$。此处 $\\Delta x = 1/100 = 0.01$，因此 $\\nu = 1.0 \\times 0.012 / 0.01 = 1.2$。\n- 情况 4：$c=-2.0$，$N=200$，$\\Delta t=0.00225$，时间步数 $n_f=300$。此处 $\\Delta x = 1/200 = 0.005$，因此 $\\nu = -2.0 \\times 0.00225 / 0.005 = -0.9$。\n- 情况 5：$c=0.5$，$N=40$，$\\Delta t=0.06$，时间步数 $n_f=40$。此处 $\\Delta x = 1/40 = 0.025$，因此 $\\nu = 0.5 \\times 0.06 / 0.025 = 1.2$。\n\n最终输出格式：\n- 单行列表 $[G_1,G_2,G_3,G_4,G_5]$，其中每个 $G_k$ 是情况 $k$ 的增长因子，四舍五入到恰好六位小数（例如，$[1.000000,0.998532,12.345678,1.000000,345678.901234]$）。任何角度（如果存在）都必须以弧度为单位解释；不涉及物理单位；数值答案必须是无量纲实数。",
            "solution": "所提出的问题已经过验证，并被认定为有效。这是一个计算工程领域的适定问题，其基础是偏微分方程数值分析的基本原理。所有参数和条件都已明确指定，其表述在科学和数学上都是合理的。\n\n该问题要求对一维线性平流方程进行数值求解：\n$$\n\\frac{\\partial u}{\\partial t} + c \\frac{\\partial u}{\\partial x} = 0\n$$\n该方程是一阶双曲型偏微分方程的典型模型。其精确解描述了一个波形 $u(x,0)$ 以恒定速度 $c$ 平移而不改变其形状，使得 $u(x,t) = u(x-ct, 0)$。问题指定的域为 $x \\in [0,1]$，带有周期性边界条件 $u(0,t) = u(1,t)$，初始条件为正弦波 $u(x,0) = \\sin(2\\pi x)$。\n\n该方程将使用均匀网格上的一阶显式有限差分格式进行求解。空间网格点为 $x_i = i\\Delta x$，其中 $i=0, 1, \\dots, N-1$，网格间距为 $\\Delta x = 1/N$。时间层为 $t^n = n\\Delta t$。令 $u_i^n$ 为 $u(x_i, t^n)$ 的数值近似。所提出的格式为：\n$$\nu_i^{n+1} = u_i^n - \\nu^{+}\\,\\big(u_i^n - u_{i-1}^n\\big) - \\nu^{-}\\,\\big(u_{i+1}^n - u_i^n\\big)\n$$\n这里，$\\nu = c\\Delta t/\\Delta x$ 是无量纲库朗数，分裂系数为 $\\nu^{+} = \\max(\\nu, 0)$ 和 $\\nu^{-} = \\min(\\nu, 0)$。索引对 $N$ 取模，这正确地实现了周期性边界条件。\n\n该格式是一阶迎风法的一般形式。让我们根据平流速度 $c$ 的符号，分析两种可能的情况。\n\n情况 1：$c > 0$。这意味着 $\\nu > 0$。那么 $\\nu^{+} = \\nu$ 且 $\\nu^{-} = 0$。该格式简化为：\n$$\nu_i^{n+1} = u_i^n - \\nu(u_i^n - u_{i-1}^n) = (1-\\nu)u_i^n + \\nu u_{i-1}^n\n$$\n这是针对正速度的经典迎风格式。空间导数 $\\partial u/\\partial x$ 由后向差分 $(u_i^n - u_{i-1}^n)/\\Delta x$ 近似，使用了来自波传播方向“迎风”侧的信息。\n\n情况 2：$c  0$。这意味着 $\\nu  0$。那么 $\\nu^{+} = 0$ 且 $\\nu^{-} = \\nu$。该格式简化为：\n$$\nu_i^{n+1} = u_i^n - \\nu(u_{i+1}^n - u_i^n) = (1+\\nu)u_i^n - \\nu u_{i+1}^n\n$$\n这是针对负速度的迎风格式。空间导数由前向差分 $(u_{i+1}^n - u_i^n)/\\Delta x$ 近似，同样使用了来自迎风方向的信息。\n\n任何显式有限差分格式的一个关键方面是其数值稳定性。对于一阶迎风格式，Von Neumann 稳定性分析表明，该格式是稳定的当且仅当满足 Courant-Friedrichs-Lewy (CFL) 条件。对于此特定格式，该条件为 $|\\nu| \\le 1$。\n- 如果 $|\\nu|  1$，格式是稳定的，但会引入数值耗散，这会人为地衰减解的振幅。预期增长因子 $G$ 将小于 $1$。\n- 如果 $|\\nu| = 1$，格式是稳定的且非耗散的。对于 $\\nu=1$，$u_i^{n+1} = u_{i-1}^n$，这是离散解向右精确平移一个网格单元。对于 $\\nu=-1$，$u_i^{n+1} = u_{i+1}^n$，这是向左的精确平移。在这种特殊情况下，数值解在网格点上是精确的，增长因子 $G$ 将恰好为 $1$。\n- 如果 $|\\nu| > 1$，格式是不稳定的。数值误差会随着每个时间步呈指数级放大，导致解无界增长。增长因子 $G$ 将显著大于 $1$。\n\n针对每个测试用例解决该问题的算法步骤如下：\n1. 定义该用例的参数：$c$、$N$、$\\Delta t$ 和 $n_f$。\n2. 计算派生参数：$\\Delta x = 1/N$ 和库朗数 $\\nu = c\\Delta t/\\Delta x$。确定 $\\nu^{+}$ 和 $\\nu^{-}$。\n3. 初始化大小为 $N$ 的解向量 $u$。网格点为 $x_i = i/N$，其中 $i=0, \\dots, N-1$。初始条件为 $u_i^0 = \\sin(2\\pi x_i)$。\n4. 计算初始解的最大绝对值 $\\max_i |u_i^0|$。对于给定的初始条件和 $N$ 值，网格会对正弦函数的峰值进行采样，因此该最大值为 $1$。\n5. 执行一个 $n_f$ 步的时间步进循环。在每一步中，解向量 $u^{n+1}$ 是根据 $u^n$ 使用有限差分格式的向量化实现来计算的。使用数组移位操作（例如 Python 中的 `numpy.roll`）可以有效地处理周期性边界条件。更新规则是：\n   $$\n   u^{n+1} = u^n - \\nu^{+} (u^n - \\text{roll}(u^n, 1)) - \\nu^{-} (\\text{roll}(u^n, -1) - u^n)\n   $$\n6. 在 $n_f$ 个时间步之后，计算最终解的最大绝对值 $\\max_i |u_i^{n_f}|$。\n7. 增长因子计算为 $G = (\\max_i |u_i^{n_f}|) / (\\max_i |u_i^0|)$。\n\n对所有五个测试用例重复此过程，这些测试用例旨在探究数值格式的不同稳定性区域。然后收集结果并按要求进行格式化。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the linear advection equation using a first-order upwind scheme\n    for a series of test cases and computes the growth factor for each.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (c, N, dt, n_f)\n        (1.0, 200, 0.0035, 400),\n        (1.0, 100, 0.01, 50),\n        (1.0, 100, 0.012, 50),\n        (-2.0, 200, 0.00225, 300),\n        (0.5, 40, 0.06, 40),\n    ]\n\n    results = []\n    for c, N, dt, n_f in test_cases:\n        # Step 1: Discretization and parameters\n        dx = 1.0 / N\n        nu = c * dt / dx\n        nu_plus = max(nu, 0.0)\n        nu_minus = min(nu, 0.0)\n\n        # Step 2: Initial condition\n        x = np.arange(N) * dx\n        u = np.sin(2.0 * np.pi * x)\n        \n        # The initial maximum amplitude is calculated for correctness,\n        # although it is 1.0 for the given N values.\n        max_u0 = np.max(np.abs(u))\n        \n        # Step 3: Time-stepping loop\n        for _ in range(n_f):\n            # The periodic boundary conditions are handled by np.roll.\n            # u_im1 corresponds to u_{i-1}\n            u_im1 = np.roll(u, 1)\n            # u_ip1 corresponds to u_{i+1}\n            u_ip1 = np.roll(u, -1)\n            \n            # Apply the explicit upwind scheme in vectorized form\n            u = u - nu_plus * (u - u_im1) - nu_minus * (u_ip1 - u)\n\n        # Step 4: Calculate the growth factor\n        max_uf = np.max(np.abs(u))\n        \n        # Avoid division by zero if initial condition is zero everywhere\n        if max_u0 > 1e-12:\n            growth_factor = max_uf / max_u0\n        else:\n            growth_factor = 1.0 if max_uf  1e-12 else float('inf')\n\n        results.append(growth_factor)\n\n    # Final print statement in the exact required format.\n    # The results are formatted to six decimal places.\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}