{
    "hands_on_practices": [
        {
            "introduction": "The linear advection equation serves as the quintessential model for hyperbolic partial differential equations, describing the transport of a quantity at a constant velocity. A crucial concept when solving these equations with explicit time-stepping schemes is the constraint on the time step size for a given spatial resolution. This exercise provides direct, hands-on experience with this principle, known as the Courant-Friedrichs-Lewy (CFL) condition, by having you implement a solver and witness firsthand the stable, diffusive, and explosively unstable behaviors that arise from adhering to or violating this fundamental numerical law .",
            "id": "2388289",
            "problem": "Consider the linear advection equation $u_t + c\\,u_x = 0$ on the periodic domain $x \\in [0,1]$ with period $1$, that is, $u(0,t)=u(1,t)$ for all $t \\ge 0$. The initial condition is $u(x,0) = \\sin(2\\pi x)$. Let the spatial grid be uniform with $N$ points $x_i = i\\,\\Delta x$, $i=0,1,\\dots,N-1$, where $\\Delta x = 1/N$, and let the time levels be $t^n = n\\,\\Delta t$, $n=0,1,2,\\dots$. Define the Courant number $\\nu = c\\,\\Delta t/\\Delta x$. Approximate the solution using the explicit first-order upwind finite difference scheme given by\n$$\nu_i^{n+1} = u_i^n \\;-\\; \\nu^{+}\\,\\big(u_i^n - u_{i-1}^n\\big)\\;-\\;\\nu^{-}\\,\\big(u_{i+1}^n - u_i^n\\big),\n$$\nwhere $\\nu^{+}=\\max(\\nu,0)$ and $\\nu^{-}=\\min(\\nu,0)$, and the indices are taken modulo $N$ to enforce periodic boundary conditions. For each specified parameter set, start from $u_i^0 = \\sin(2\\pi x_i)$, advance the solution for a prescribed number of time steps, and report the growth factor\n$$\nG \\;=\\; \\frac{\\max_i |u_i^{n_f}|}{\\max_i |u_i^{0}|},\n$$\nwhere $n_f$ is the total number of time steps performed in that parameter set.\n\nYour program must compute $G$ for each of the following five test cases and produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each entry rounded to exactly six decimal places. No other output is permitted.\n\nTest suite:\n- Case $1$: $c=1.0$, $N=200$, $\\Delta t=0.0035$, number of time steps $n_f=400$. Here $\\Delta x = 1/200 = 0.005$, so $\\nu = c\\,\\Delta t/\\Delta x = 1.0 \\times 0.0035 / 0.005 = 0.7$.\n- Case $2$: $c=1.0$, $N=100$, $\\Delta t=0.01$, number of time steps $n_f=50$. Here $\\Delta x = 1/100 = 0.01$, so $\\nu = 1.0 \\times 0.01 / 0.01 = 1.0$.\n- Case $3$: $c=1.0$, $N=100$, $\\Delta t=0.012$, number of time steps $n_f=50$. Here $\\Delta x = 1/100 = 0.01$, so $\\nu = 1.0 \\times 0.012 / 0.01 = 1.2$.\n- Case $4$: $c=-2.0$, $N=200$, $\\Delta t=0.00225$, number of time steps $n_f=300$. Here $\\Delta x = 1/200 = 0.005$, so $\\nu = -2.0 \\times 0.00225 / 0.005 = -0.9$.\n- Case $5$: $c=0.5$, $N=40$, $\\Delta t=0.06$, number of time steps $n_f=40$. Here $\\Delta x = 1/40 = 0.025$, so $\\nu = 0.5 \\times 0.06 / 0.025 = 1.2$.\n\nFinal output format:\n- A single line with the list $[G_1,G_2,G_3,G_4,G_5]$, where each $G_k$ is the growth factor for Case $k$, rounded to exactly six decimal places (for example, $[1.000000,0.998532,12.345678,1.000000,345678.901234]$). Angles, if any, must be interpreted in radians; no physical units are involved; numerical answers must be dimensionless real numbers.",
            "solution": "The problem presented is subjected to validation and is found to be valid. It is a well-posed problem in computational engineering, grounded in the fundamental principles of numerical analysis for partial differential equations. All parameters and conditions are specified, and the formulation is scientifically and mathematically sound.\n\nThe problem requires the numerical solution of the one-dimensional linear advection equation:\n$$\n\\frac{\\partial u}{\\partial t} + c \\frac{\\partial u}{\\partial x} = 0\n$$\nThis equation is the canonical model for first-order hyperbolic partial differential equations. Its exact solution describes a wave profile $u(x,0)$ that translates with constant velocity $c$ without changing its shape, such that $u(x,t) = u(x-ct, 0)$. The domain is specified as $x \\in [0,1]$ with periodic boundary conditions, $u(0,t) = u(1,t)$, and the initial condition is a sine wave, $u(x,0) = \\sin(2\\pi x)$.\n\nThe equation is to be solved using a first-order explicit finite difference scheme on a uniform grid. The spatial grid points are $x_i = i\\Delta x$ for $i=0, 1, \\dots, N-1$, with grid spacing $\\Delta x = 1/N$. The time levels are $t^n = n\\Delta t$. Let $u_i^n$ be the numerical approximation of $u(x_i, t^n)$. The proposed scheme is:\n$$\nu_i^{n+1} = u_i^n - \\nu^{+}\\,\\big(u_i^n - u_{i-1}^n\\big) - \\nu^{-}\\,\\big(u_{i+1}^n - u_i^n\\big)\n$$\nHere, $\\nu = c\\Delta t/\\Delta x$ is the dimensionless Courant number, and the split coefficients are $\\nu^{+} = \\max(\\nu, 0)$ and $\\nu^{-} = \\min(\\nu, 0)$. The indices are taken modulo $N$, which correctly implements the periodic boundary conditions.\n\nThis scheme is a general formulation of the first-order upwind method. Let us analyze it for the two possible cases based on the sign of the advection velocity $c$.\n\nCase 1: $c > 0$. This implies $\\nu > 0$. Then $\\nu^{+} = \\nu$ and $\\nu^{-} = 0$. The scheme simplifies to:\n$$\nu_i^{n+1} = u_i^n - \\nu(u_i^n - u_{i-1}^n) = (1-\\nu)u_i^n + \\nu u_{i-1}^n\n$$\nThis is the classic upwind scheme for positive velocity. The spatial derivative $\\partial u/\\partial x$ is approximated by a backward difference, $(u_i^n - u_{i-1}^n)/\\Delta x$, using information from the \"upwind\" direction, from where the wave propagates.\n\nCase 2: $c  0$. This implies $\\nu  0$. Then $\\nu^{+} = 0$ and $\\nu^{-} = \\nu$. The scheme simplifies to:\n$$\nu_i^{n+1} = u_i^n - \\nu(u_{i+1}^n - u_i^n) = (1+\\nu)u_i^n - \\nu u_{i+1}^n\n$$\nThis is the upwind scheme for negative velocity. The spatial derivative is approximated by a forward difference, $(u_{i+1}^n - u_i^n)/\\Delta x$, again using information from the upwind direction.\n\nA crucial aspect of any explicit finite difference scheme is its numerical stability. For the first-order upwind scheme, Von Neumann stability analysis shows that the scheme is stable if and only if the Courant-Friedrichs-Lewy (CFL) condition is satisfied. For this particular scheme, the condition is $|\\nu| \\le 1$.\n- If $|\\nu|  1$, the scheme is stable but introduces numerical diffusion, which artificially damps the amplitude of the solution. The growth factor $G$ is expected to be less than $1$.\n- If $|\\nu| = 1$, the scheme is stable and non-dissipative. For $\\nu=1$, $u_i^{n+1} = u_{i-1}^n$, which is an exact shift of the discrete solution by one grid cell to the right. For $\\nu=-1$, $u_i^{n+1} = u_{i+1}^n$, an exact shift to the left. In this special case, the numerical solution is exact at the grid points, and the growth factor $G$ will be exactly $1$.\n- If $|\\nu| > 1$, the scheme is unstable. Numerical errors are amplified exponentially with each time step, causing the solution to grow without bound. The growth factor $G$ will be significantly greater than $1$.\n\nThe algorithmic procedure to solve the problem for each test case is as follows:\n1. Define the parameters for the case: $c$, $N$, $\\Delta t$, and $n_f$.\n2. Calculate the derived parameters: $\\Delta x = 1/N$ and the Courant number $\\nu = c\\Delta t/\\Delta x$. Determine $\\nu^{+}$ and $\\nu^{-}$.\n3. Initialize the solution vector $u$ of size $N$. The grid points are $x_i = i/N$ for $i=0, \\dots, N-1$. The initial condition is $u_i^0 = \\sin(2\\pi x_i)$.\n4. Calculate the maximum absolute value of the initial solution, $\\max_i |u_i^0|$. For the given initial condition and values of $N$, the grid samples the peak of the sine function, so this maximum is $1$.\n5. Perform a time-stepping loop for $n_f$ steps. In each step, the solution vector $u^{n+1}$ is computed from $u^n$ using a vectorized implementation of the finite difference scheme. The use of array shifting operations (e.g., `numpy.roll` in Python) efficiently handles the periodic boundary conditions. The update rule is:\n   $$\n   u^{n+1} = u^n - \\nu^{+} (u^n - \\text{roll}(u^n, 1)) - \\nu^{-} (\\text{roll}(u^n, -1) - u^n)\n   $$\n6. After $n_f$ time steps, compute the maximum absolute value of the final solution, $\\max_i |u_i^{n_f}|$.\n7. The growth factor is computed as $G = (\\max_i |u_i^{n_f}|) / (\\max_i |u_i^0|)$.\n\nThis procedure is repeated for all five test cases, which are designed to probe the different stability regimes of the numerical scheme. The results are then collected and formatted as required.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the linear advection equation using a first-order upwind scheme\n    for a series of test cases and computes the growth factor for each.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (c, N, dt, n_f)\n        (1.0, 200, 0.0035, 400),\n        (1.0, 100, 0.01, 50),\n        (1.0, 100, 0.012, 50),\n        (-2.0, 200, 0.00225, 300),\n        (0.5, 40, 0.06, 40),\n    ]\n\n    results = []\n    for c, N, dt, n_f in test_cases:\n        # Step 1: Discretization and parameters\n        dx = 1.0 / N\n        nu = c * dt / dx\n        nu_plus = max(nu, 0.0)\n        nu_minus = min(nu, 0.0)\n\n        # Step 2: Initial condition\n        x = np.arange(N) * dx\n        u = np.sin(2.0 * np.pi * x)\n        \n        # The initial maximum amplitude is calculated for correctness,\n        # although it is 1.0 for the given N values.\n        max_u0 = np.max(np.abs(u))\n        \n        # Step 3: Time-stepping loop\n        for _ in range(n_f):\n            # The periodic boundary conditions are handled by np.roll.\n            # u_im1 corresponds to u_{i-1}\n            u_im1 = np.roll(u, 1)\n            # u_ip1 corresponds to u_{i+1}\n            u_ip1 = np.roll(u, -1)\n            \n            # Apply the explicit upwind scheme in vectorized form\n            u = u - nu_plus * (u - u_im1) - nu_minus * (u_ip1 - u)\n\n        # Step 4: Calculate the growth factor\n        max_uf = np.max(np.abs(u))\n        \n        # Avoid division by zero if initial condition is zero everywhere\n        if max_u0 > 1e-12:\n            growth_factor = max_uf / max_u0\n        else:\n            growth_factor = 1.0 if max_uf  1e-12 else float('inf')\n\n        results.append(growth_factor)\n\n    # Final print statement in the exact required format.\n    # The results are formatted to six decimal places.\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "We now turn to parabolic PDEs with the convection-diffusion equation, a model that governs countless phenomena involving both transport and dissipation, from heat transfer in a moving fluid to the spread of pollutants. While the diffusion term provides a smoothing effect, its interaction with the convective term can lead to significant numerical challenges. This practice guides you to explore a notorious pitfall of using standard centered-difference schemes: the emergence of unphysical, spurious oscillations when convection dominates, highlighting why more sophisticated methods are essential for generating physically reliable simulations in this regime .",
            "id": "2388332",
            "problem": "Write a complete, runnable program that numerically solves a one-dimensional, time-dependent convection–diffusion equation, a representative parabolic model problem, using a standard centered scheme in space and a fully implicit time integrator, and quantitatively demonstrates spurious oscillations in the convection-dominated regime when no upwinding is used.\n\nThe governing equation is the linear advection–diffusion equation\n$$\n\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = \\nu \\frac{\\partial^2 u}{\\partial x^2}, \\quad x \\in (0,1), \\ t \\in (0,T],\n$$\nwith Dirichlet boundary conditions and an initial condition given by\n$$\nu(0,t) = 1, \\quad u(1,t) = 0, \\quad u(x,0) = 0 \\ \\text{for all} \\ x \\in (0,1).\n$$\nHere $a$ is the constant advection speed and $\\nu$ is the constant diffusivity. This is a parabolic partial differential equation arising from conservation of a transported quantity with diffusion.\n\nYou must:\n- Discretize the spatial domain uniformly with $n_x$ points (including the two boundary points) and spatial step $h = 1/(n_x-1)$.\n- Use second-order centered finite differences for both the first derivative $\\partial u/\\partial x$ and second derivative $\\partial^2 u/\\partial x^2$ at all interior grid points, with no upwinding or flux limiters.\n- Use fully implicit (Backward Euler) time stepping with a constant time step $\\Delta t$ chosen by you for stability and robustness. You must not use any artificial diffusion or upwinding.\n- March in time until $t=T$ and then diagnose spurious oscillations by counting how many interior grid values violate the maximum principle bound implied by the data, that is, how many interior $u$ values lie outside the interval $[0,1]$ up to a small tolerance $\\varepsilon$. Use $\\varepsilon = 10^{-8}$.\n\nYour program must implement the following parameterized test suite, where each test case is a tuple $(a,\\nu,n_x,T)$:\n- Test A (diffusion-dominated “happy path”): $(a,\\nu,n_x,T) = (1.0, 0.05, 101, 2.0)$.\n- Test B (convection-dominated): $(a,\\nu,n_x,T) = (1.0, 0.001, 101, 2.0)$.\n- Test C (strongly convection-dominated): $(a,\\nu,n_x,T) = (5.0, 0.001, 101, 2.0)$.\n\nUse only centered differences and the fully implicit time integrator; no upwinding, no artificial viscosity, no flux limiters, and no slope limiters are allowed.\n\nFor each test case, compute a single integer:\n- The count of interior grid points $x_i$ where $u(x_i,T)  -\\varepsilon$ or $u(x_i,T) > 1+\\varepsilon$.\n\nYour program should produce a single line of output containing the three integer results for Tests A, B, and C, in that order, as a comma-separated list enclosed in square brackets, for example $[r_1,r_2,r_3]$.\n\nImplementation details that you must follow:\n- Discretize the spatial derivatives at interior nodes $x_i$ with spacing $h$ by\n$$\n\\left.\\frac{\\partial u}{\\partial x}\\right|_{x_i} \\approx \\frac{u_{i+1}-u_{i-1}}{2h}, \\qquad\n\\left.\\frac{\\partial^2 u}{\\partial x^2}\\right|_{x_i} \\approx \\frac{u_{i-1}-2u_i+u_{i+1}}{h^2}.\n$$\n- Use the fully implicit (Backward Euler) time discretization\n$$\n\\frac{u^{n+1} - u^n}{\\Delta t} + a \\, D_0 u^{n+1} = \\nu \\, D_2 u^{n+1},\n$$\nwhere $D_0$ and $D_2$ are the centered finite-difference operators defined above, applied at time level $n+1$.\n- Assemble the resulting tridiagonal linear system for the interior unknowns at each time step and solve it exactly (to numerical precision) without iterative solvers, maintaining the Dirichlet boundary values at all times.\n- Choose $\\Delta t$ in a way that is scientifically reasonable based on the advection time scale and the grid spacing (for example, proportional to $h/a$) and document your choice within the code as a comment. You must not rely on user input.\n\nAll quantities in this problem are nondimensional and unitless. The final outputs must be integers. The program must be self-contained and not require any input. The output must be a single line in the exact format specified above.",
            "solution": "The problem presented is a valid and well-posed exercise in computational engineering. It concerns the numerical solution of the one-dimensional linear convection-diffusion equation, a canonical parabolic partial differential equation (PDE). All necessary data, including the governing equation, domain, boundary and initial conditions, discretization schemes, and specific test parameters, are provided. The problem is scientifically grounded, as it focuses on the well-documented phenomenon of spurious oscillations arising from the use of centered difference schemes for convection-dominated flows, a fundamental topic in the study of numerical methods for PDEs. The objective is clear and the methodology is precisely specified. Therefore, a solution can be constructed.\n\nThe governing equation is given as:\n$$\n\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = \\nu \\frac{\\partial^2 u}{\\partial x^2}, \\quad x \\in (0,1), \\ t \\in (0,T]\n$$\nwith initial condition $u(x,0) = 0$ for $x \\in (0,1)$ and Dirichlet boundary conditions $u(0,t) = 1$, $u(1,t) = 0$.\n\nWe begin by discretizing the spatial domain $x \\in [0,1]$ into $n_x$ points, leading to a uniform grid spacing of $h = 1 / (n_x - 1)$. The solution $u(x,t)$ is approximated at discrete points $(x_i, t_n)$, where $x_i = (i-1)h$ for $i=1, 2, \\dots, n_x$, and $t_n = n \\Delta t$. Let $u_i^n \\approx u(x_i, t_n)$.\n\nThe problem mandates a fully implicit time integration scheme (Backward Euler). Applying this to the governing PDE, we evaluate the spatial derivatives at the future time level $n+1$:\n$$\n\\frac{u^{n+1}_i - u^{n}_i}{\\Delta t} + a \\left. \\frac{\\partial u}{\\partial x} \\right|_i^{n+1} = \\nu \\left. \\frac{\\partial^2 u}{\\partial x^2} \\right|_i^{n+1}\n$$\nThis equation is formulated for all interior grid points, i.e., for $i = 2, 3, \\dots, n_x-1$.\n\nNext, we substitute the specified second-order centered finite difference approximations for the spatial derivatives:\n$$\n\\left. \\frac{\\partial u}{\\partial x} \\right|_i^{n+1} \\approx \\frac{u_{i+1}^{n+1} - u_{i-1}^{n+1}}{2h}\n$$\n$$\n\\left. \\frac{\\partial^2 u}{\\partial x^2} \\right|_i^{n+1} \\approx \\frac{u_{i-1}^{n+1} - 2u_i^{n+1} + u_{i+1}^{n+1}}{h^2}\n$$\nSubstituting these expressions into the time-discretized equation yields:\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} + a \\left( \\frac{u_{i+1}^{n+1} - u_{i-1}^{n+1}}{2h} \\right) = \\nu \\left( \\frac{u_{i-1}^{n+1} - 2u_i^{n+1} + u_{i+1}^{n+1}}{h^2} \\right)\n$$\nTo solve for the unknown values $u_i^{n+1}$ at the new time step, we rearrange the equation to group all terms at time level $n+1$ on the left-hand side and all known terms from time level $n$ on the right-hand side.\n$$\nu_i^{n+1} + \\frac{a \\Delta t}{2h} (u_{i+1}^{n+1} - u_{i-1}^{n+1}) - \\frac{\\nu \\Delta t}{h^2} (u_{i-1}^{n+1} - 2u_i^{n+1} + u_{i+1}^{n+1}) = u_i^n\n$$\nCollecting terms corresponding to grid points $i-1$, $i$, and $i+1$:\n$$\n\\left( -\\frac{a \\Delta t}{2h} - \\frac{\\nu \\Delta t}{h^2} \\right) u_{i-1}^{n+1} + \\left( 1 + \\frac{2\\nu \\Delta t}{h^2} \\right) u_i^{n+1} + \\left( \\frac{a \\Delta t}{2h} - \\frac{\\nu \\Delta t}{h^2} \\right) u_{i+1}^{n+1} = u_i^n\n$$\nThis forms a system of linear equations for the unknown interior nodal values $\\mathbf{u}_{\\text{int}}^{n+1} = [u_2^{n+1}, u_3^{n+1}, \\dots, u_{n_x-1}^{n+1}]^T$. The system can be written in matrix form $A \\mathbf{u}_{\\text{int}}^{n+1} = \\mathbf{b}$. The matrix $A$ is a tridiagonal matrix of size $(n_x-2) \\times (n_x-2)$. Let us define the coefficients for the lower diagonal ($l$), main diagonal ($d$), and upper diagonal ($r$):\n$$\nl = -\\frac{a \\Delta t}{2h} - \\frac{\\nu \\Delta t}{h^2} \\quad \\text{(sub-diagonal)}\n$$\n$$\nd = 1 + \\frac{2\\nu \\Delta t}{h^2} \\quad \\text{(main diagonal)}\n$$\n$$\nr = \\frac{a \\Delta t}{2h} - \\frac{\\nu \\Delta t}{h^2} \\quad \\text{(super-diagonal)}\n$$\nThe right-hand side vector $\\mathbf{b}$ consists of the values from the previous time step, $u_i^n$, adjusted for the boundary conditions. The boundary conditions are $u(0,t) = u_1 = 1$ and $u(1,t) = u_{n_x} = 0$. These are known values at time level $n+1$.\n\nFor the first interior point ($i=2$):\n$l u_1^{n+1} + d u_2^{n+1} + r u_3^{n+1} = u_2^n$. Since $u_1^{n+1}=1$, this becomes $d u_2^{n+1} + r u_3^{n+1} = u_2^n - l$.\nThe first entry of the RHS vector is $b_1 = u_2^n - l$.\n\nFor the last interior point ($i=n_x-1$):\n$l u_{n_x-2}^{n+1} + d u_{n_x-1}^{n+1} + r u_{n_x}^{n+1} = u_{n_x-1}^n$. Since $u_{n_x}^{n+1}=0$, this becomes $l u_{n_x-2}^{n+1} + d u_{n_x-1}^{n+1} = u_{n_x-1}^n$.\nThe last entry of the RHS vector is $b_{n_x-2} = u_{n_x-1}^n$.\n\nFor all other interior points ($2  i  n_x-1$), the corresponding entry in the RHS vector is simply $b_{i-1} = u_i^n$.\n\nThe presence of non-physical oscillations is governed by the cell Péclet number, $Pe_h = \\frac{|a|h}{2\\nu}$. Theory for centered difference schemes indicates that for $Pe_h > 1$, the solution is prone to spurious, unphysical oscillations, as the matrix $A$ may lose its diagonal dominance property, which is a condition for satisfying a discrete maximum principle.\nLet us evaluate $Pe_h$ for the given test cases with $h=1/(101-1) = 0.01$:\n- Test A: $Pe_h = \\frac{1.0 \\times 0.01}{2 \\times 0.05} = 0.1$. Since $Pe_h  1$, the solution should be smooth and physically correct.\n- Test B: $Pe_h = \\frac{1.0 \\times 0.01}{2 \\times 0.001} = 5$. Since $Pe_h > 1$, oscillations are expected.\n- Test C: $Pe_h = \\frac{5.0 \\times 0.01}{2 \\times 0.001} = 25$. Since $Pe_h \\gg 1$, severe oscillations are expected.\n\nThe overall algorithm is as follows:\n1. For each test case $(a, \\nu, n_x, T)$, initialize the computational parameters. A reasonable time step $\\Delta t$ is chosen based on the Courant-Friedrichs-Lewy (CFL) condition, e.g., $\\Delta t = C \\frac{h}{a}$ with $C=0.5$, to ensure the temporal resolution is adequate for the advection process.\n2. Initialize the solution vector $\\mathbf{u}^0$ according to the initial condition $u(x,0)=0$.\n3. Assemble the constant tridiagonal matrix $A$ using the coefficients $l$, $d$, and $r$.\n4. Iterate in time from $t=0$ to $t=T$. In each step:\n   a. Construct the right-hand-side vector $\\mathbf{b}$ using the solution from the previous step $\\mathbf{u}^n$ and incorporating the boundary conditions.\n   b. Solve the linear system $A \\mathbf{u}_{\\text{int}}^{n+1} = \\mathbf{b}$ using a direct solver to find the interior solution at the new time step.\n   c. Update the full solution vector $\\mathbf{u}^{n+1}$.\n5. After the final time step, analyze the solution $\\mathbf{u}$ at $t=T$. Count the number of interior grid points where the solution violates the maximum principle, i.e., falls outside the range $[0, 1]$ by more than a tolerance $\\varepsilon = 10^{-8}$.\n6. Record this count for each test case.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the 1D convection-diffusion problem.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (a, nu, n_x, T)\n    test_cases = [\n        (1.0, 0.05, 101, 2.0),   # Test A: Diffusion-dominated\n        (1.0, 0.001, 101, 2.0),  # Test B: Convection-dominated\n        (5.0, 0.001, 101, 2.0),  # Test C: Strongly convection-dominated\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(*case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef solve_case(a, nu, n_x, T):\n    \"\"\"\n    Solves the 1D convection-diffusion equation for a single test case.\n\n    Args:\n        a (float): Advection speed.\n        nu (float): Diffusivity.\n        n_x (int): Number of spatial grid points.\n        T (float): Final time.\n\n    Returns:\n        int: The count of interior grid points where the solution violates\n             the maximum principle at the final time T.\n    \"\"\"\n    epsilon = 1e-8\n\n    # Spatial discretization\n    h = 1.0 / (n_x - 1)\n\n    # Time discretization\n    # A reasonable time step is chosen to ensure temporal accuracy,\n    # based on a Courant number C=0.5.\n    # The implicit scheme is unconditionally stable, but this choice\n    # ensures the advection process is well-resolved in time.\n    cfl_number = 0.5\n    dt = cfl_number * h / a\n    n_t = int(T / dt)\n\n    # Initial condition: u(x, 0) = 0 for all x in (0, 1)\n    u_n = np.zeros(n_x)\n\n    # Boundary conditions: u(0, t) = 1, u(1, t) = 0\n    u_bc_left = 1.0\n    u_bc_right = 0.0\n    \n    # Set boundary values on the initial solution vector. These are constant in time.\n    u_n[0] = u_bc_left\n    u_n[-1] = u_bc_right\n\n    # Assemble the tridiagonal matrix for the linear system A*u_np1 = b\n    # The system is for the n_x - 2 interior points.\n    num_interior_points = n_x - 2\n    \n    # Coefficients for the tridiagonal matrix A\n    l = -a * dt / (2 * h) - nu * dt / h**2   # Lower diagonal\n    d = 1 + 2 * nu * dt / h**2               # Main diagonal\n    r = a * dt / (2 * h) - nu * dt / h**2    # Upper diagonal\n\n    A = np.zeros((num_interior_points, num_interior_points))\n\n    # Populate the matrix A\n    np.fill_diagonal(A, d)\n    if num_interior_points > 1:\n        np.fill_diagonal(A[1:], l)\n        np.fill_diagonal(A[:, 1:], r)\n\n    # Time-marching loop\n    for _ in range(n_t):\n        # Construct the right-hand-side vector b\n        b = u_n[1:-1].copy()\n        \n        # Incorporate boundary conditions into the RHS\n        # For the first interior point (i=2)\n        b[0] -= l * u_bc_left\n        \n        # For the last interior point (i=n_x-1), the contribution is zero\n        # because u_bc_right is 0.\n        # b[-1] -= r * u_bc_right\n\n        # Solve the linear system for interior points at time n+1\n        try:\n            u_interior_np1 = np.linalg.solve(A, b)\n        except np.linalg.LinAlgError:\n            print(\"Error: Singular matrix. The simulation cannot proceed.\")\n            # Return an error code, e.g., -1.\n            return -1\n\n        # Update the solution vector for the next time step\n        u_n[1:-1] = u_interior_np1\n\n    # After the loop, u_n holds the solution at t=T\n    # Diagnose spurious oscillations by counting violations of the maximum principle\n    interior_solution = u_n[1:-1]\n    violations = np.sum((interior_solution  -epsilon) | (interior_solution > 1.0 + epsilon))\n    \n    return int(violations)\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "Our final practice focuses on the Poisson equation, the canonical elliptic PDE governing equilibrium or steady-state systems. In this exercise, the focus shifts from the time-dependent dynamics of hyperbolic and parabolic problems to the challenges of spatial accuracy and handling complex geometries. You will implement a finite difference solver for the Poisson equation on a non-trivial L-shaped domain and, using the method of manufactured solutions, perform a convergence study to verify that your code achieves its theoretical order of accuracy—a cornerstone of professional practice in computational engineering .",
            "id": "2388329",
            "problem": "You are asked to implement, execute, and analyze a numerical experiment that verifies the order of convergence for a standard scheme applied to an elliptic model problem in computational engineering. Consider the Poisson equation, which is an elliptic partial differential equation, posed on an L-shaped domain. The L-shaped domain is defined by the square $\\Omega_{\\mathrm{sq}} = [-1,1]\\times[-1,1]$ with the lower-right quadrant removed: $\\Omega = \\Omega_{\\mathrm{sq}} \\setminus \\left([0,1]\\times[-1,0]\\right)$. Let $-\\Delta u = f$ in $\\Omega$ with Dirichlet boundary conditions $u = g$ on $\\partial\\Omega$. You must verify convergence rates for a second-order finite difference method by the method of manufactured solutions with smooth data so that the exact solution $u$ is known.\n\nFrom a fundamental base, use the classification that $-\\Delta$ is an elliptic operator, and derive a consistent second-order discretization on a uniform Cartesian grid via Taylor expansions of $u$ and the definition of the Laplacian. Impose Dirichlet boundary conditions by enforcing $u=g$ at boundary grid nodes. Treat the non-rectangular geometry by masking out grid points outside $\\Omega$ and defining the discrete boundary as those masked-in nodes with at least one masked-out neighbor or lying on the boundary of $\\Omega_{\\mathrm{sq}}$. Assemble and solve the resulting sparse linear system over the interior (non-boundary) nodes of $\\Omega$.\n\nUse the method of manufactured solutions: for a given smooth $u(x,y)$, set $f(x,y)=-\\Delta u(x,y)$ in $\\Omega$ and $g(x,y)=u(x,y)$ on $\\partial\\Omega$. For each grid with $N$ subintervals per coordinate direction over $[-1,1]$ (so grid spacing $h = 2/N$ and grid nodes $\\{x_i\\}_{i=0}^N$, $\\{y_j\\}_{j=0}^N$), compute the numerical solution and then compute the discrete $L^2$ error over $\\Omega$,\n$$\nE_h = \\left( \\sum_{(x_i,y_j)\\in\\Omega_h} \\left(u_h(x_i,y_j) - u(x_i,y_j)\\right)^2\\, h^2 \\right)^{1/2},\n$$\nwhere $\\Omega_h$ is the set of grid nodes lying in $\\Omega$, $u_h$ is the discrete solution with Dirichlet data imposed, and $u$ is the analytical solution. Estimate the observed order of convergence between successive refinements by\n$$\np \\approx \\frac{\\log(E_{h}/E_{h/2})}{\\log(2)}.\n$$\nYou must implement the algorithmic steps required to construct the masked L-shaped grid, identify interior and boundary nodes of $\\Omega$, assemble the five-point discrete Laplacian with second-order central differences, apply Dirichlet boundary conditions by elimination, and solve the resulting linear systems.\n\nTest Suite:\nImplement three independent manufactured-solution test cases, each evaluated on three successively refined grids, and for each case report the average observed order $\\bar{p}$ computed as the arithmetic mean of the two successive refinement estimates.\n\n- Case $\\mathsf{A}$ (happy path): $u(x,y) = \\sin(\\pi x)\\sin(\\pi y)$, $f(x,y) = 2\\pi^2 \\sin(\\pi x)\\sin(\\pi y)$, with $N \\in \\{16,32,64\\}$.\n\n- Case $\\mathsf{B}$ (coarse-grid edge case): $u(x,y) = e^{x+y}$, $f(x,y) = -2 e^{x+y}$, with $N \\in \\{8,16,32\\}$.\n\n- Case $\\mathsf{C}$ (anisotropic smooth mode): $u(x,y) = \\cos(2x)\\cos(3y)$, $f(x,y) = 13 \\cos(2x)\\cos(3y)$, with $N \\in \\{24,48,96\\}$.\n\nRequired final output format:\nYour program must produce a single line of output containing the three average observed orders for Cases $\\mathsf{A}$, $\\mathsf{B}$, and $\\mathsf{C}$, in that order, as a comma-separated list enclosed in square brackets, for example, $[p_A,p_B,p_C]$. Each $p$ must be printed as a floating-point number. No other output is permitted. There are no physical units involved, so report pure numbers only. Angles implicit in trigonometric functions are in radians. Percentages are not used anywhere; all quantities are to be reported as plain decimal numbers.",
            "solution": "We consider the elliptic model problem given by the Poisson equation $-\\Delta u = f$ in the L-shaped domain $\\Omega = [-1,1]^2 \\setminus \\left([0,1]\\times[-1,0]\\right)$ with Dirichlet boundary conditions $u=g$ on $\\partial \\Omega$. The Laplacian operator $\\Delta$ is elliptic because its principal symbol $\\sigma(\\Delta)(\\xi) = -|\\xi|^2$ is negative definite for nonzero $\\xi$, which ensures that the model problem is elliptic.\n\nPrinciple-based derivation of the numerical scheme proceeds from fundamental facts: (i) the definition of the Laplacian in Cartesian coordinates, $\\Delta u = u_{xx} + u_{yy}$, (ii) Taylor expansions of a smooth function to obtain central difference formulas, and (iii) the method of manufactured solutions, in which an exact solution $u$ is prescribed and $f=-\\Delta u$ as well as boundary data $g=u$ are induced.\n\nTo obtain a second-order consistent discrete approximation on a uniform grid, let grid points be $(x_i,y_j)$ for $i,j=0,\\dots,N$ with spacing $h=2/N$ covering $[-1,1]\\times[-1,1]$. For a smooth function $u$, Taylor expansions yield the standard second-order central difference approximations\n$$\nu_{xx}(x_i,y_j) \\approx \\frac{u(x_{i+1},y_j) - 2u(x_i,y_j) + u(x_{i-1},y_j)}{h^2},\\quad\nu_{yy}(x_i,y_j) \\approx \\frac{u(x_i,y_{j+1}) - 2u(x_i,y_j) + u(x_i,y_{j-1})}{h^2}.\n$$\nSumming gives the five-point stencil for the Laplacian with second-order truncation error:\n$$\n-\\Delta u(x_i,y_j) \\approx \\frac{4 u_{i,j} - u_{i+1,j} - u_{i-1,j} - u_{i,j+1} - u_{i,j-1}}{h^2},\n$$\nwhere $u_{i,j} = u(x_i,y_j)$. The local truncation error is $\\mathcal{O}(h^2)$ under sufficient smoothness.\n\nGeometry handling by masking: Define a Boolean mask over the grid points with entries marked “inside” if $(x_i,y_j) \\in \\Omega$ and “outside” otherwise. For the L-shaped domain $\\Omega = [-1,1]^2 \\setminus ([0,1]\\times[-1,0])$, a grid node is inside whenever it does not satisfy $x_i \\ge 0$ and $y_j \\le 0$ simultaneously. A boundary node is an inside node that either lies on the outer box boundary $i\\in\\{0,N\\}$ or $j\\in\\{0,N\\}$, or has at least one immediate neighbor (in the axial directions) that is outside. Interior unknowns are inside nodes that are not boundary nodes. Dirichlet boundary conditions are imposed by setting $u=g$ at boundary nodes, and by moving known neighbor contributions to the right-hand side for interior nodes adjacent to boundary nodes.\n\nAlgebraic system: Enumerate the interior unknowns and assemble a sparse matrix $\\mathbf{A}$ representing the five-point stencil. For an interior node $(i,j)$,\n$$\n\\frac{4}{h^2} u_{i,j} - \\frac{1}{h^2}\\big(u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1}\\big) = f(x_i,y_j),\n$$\nwith terms $u$ at neighboring boundary nodes moved to the right-hand side. The resulting linear system $\\mathbf{A}\\mathbf{u}=\\mathbf{b}$ is solved for the interior unknowns. The full grid solution is obtained by filling boundary nodes with exact Dirichlet data $g=u$ and interior nodes with the numerical solution.\n\nError measurement and convergence order: The discrete $L^2$ error over the domain is computed as\n$$\nE_h = \\left( \\sum_{(x_i,y_j)\\in\\Omega_h} \\left(u_h(x_i,y_j) - u(x_i,y_j)\\right)^2\\, h^2 \\right)^{1/2},\n$$\nwhich is a standard quadrature-based approximation of the continuous $L^2$ norm. For two successive grids with spacings $h$ and $h/2$, the observed order is\n$$\np = \\frac{\\log(E_h/E_{h/2})}{\\log(2)}.\n$$\nFor a smooth solution and the five-point central difference approximation, the scheme is second-order consistent. Under stability (which holds for this symmetric positive definite discretization of an elliptic operator with Dirichlet conditions), the Lax-Richtmyer equivalence principle ensures second-order convergence, hence $p\\approx 2$ is expected for sufficiently fine grids.\n\nManufactured solutions used in the test suite:\n- Case $\\mathsf{A}$: $u(x,y)=\\sin(\\pi x)\\sin(\\pi y)$, then $\\Delta u = -2\\pi^2 \\sin(\\pi x)\\sin(\\pi y)$ so $f(x,y)=2\\pi^2 \\sin(\\pi x)\\sin(\\pi y)$, with $N\\in\\{16,32,64\\}$.\n- Case $\\mathsf{B}$: $u(x,y)=e^{x+y}$, then $\\Delta u = 2 e^{x+y}$ so $f(x,y)=-2 e^{x+y}$, with $N\\in\\{8,16,32\\}$.\n- Case $\\mathsf{C}$: $u(x,y)=\\cos(2x)\\cos(3y)$, then $\\Delta u = -(2^2+3^2)\\cos(2x)\\cos(3y)=-13\\cos(2x)\\cos(3y)$ so $f(x,y)=13\\cos(2x)\\cos(3y)$, with $N\\in\\{24,48,96\\}$.\n\nAlgorithmic design summary that bridges principles and implementation:\n- Define uniform grids with $N$ subintervals and spacing $h=2/N$.\n- Build the inside-mask for $\\Omega$ and detect boundary nodes using neighbor checks.\n- For each interior node, assemble the five-point Laplacian into a sparse matrix and construct the right-hand side by adding $f(x_i,y_j)$ and subtracting contributions from known boundary values.\n- Solve the sparse linear system for interior nodes and compose the full grid solution by inserting Dirichlet values at boundary nodes.\n- Compute $E_h$ for each grid, then compute two $p$ values across successive refinements and average them to report $\\bar{p}$ for each case.\n- Because $u$ is smooth and the stencil is second-order accurate, the observed orders should be close to $2$ for all three cases. Minor deviations on coarse grids are expected due to pre-asymptotic effects and geometry-induced irregularities in the discrete boundary, but the averages should still be near $2$.\n\nThe program outputs a single line $[p_A,p_B,p_C]$ with the three average observed orders, in radians for trigonometric functions and without any physical units, satisfying the format specification.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import coo_matrix, csr_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef build_domain_masks(N):\n    \"\"\"\n    Build grid coordinates and masks for the L-shaped domain.\n    Domain: [-1,1]^2 minus the lower-right quadrant [0,1] x [-1,0].\n    \"\"\"\n    h = 2.0 / N\n    x = np.linspace(-1.0, 1.0, N + 1)\n    y = np.linspace(-1.0, 1.0, N + 1)\n    X, Y = np.meshgrid(x, y, indexing='ij')\n\n    # Inside if not simultaneously (x >= 0.0 and y = 0.0)\n    inside = np.logical_not((X >= 0.0)  (Y = 0.0))\n\n    # Boundary: inside but on outer box, or has a neighbor outside\n    boundary = np.zeros_like(inside, dtype=bool)\n    boundary |= (np.arange(N + 1)[:, None] == 0) | (np.arange(N + 1)[:, None] == N)\n    boundary |= (np.arange(N + 1)[None, :] == 0) | (np.arange(N + 1)[None, :] == N)\n    boundary = inside  # ensure boundary only flagged inside\n\n    # neighbor-based boundary detection\n    # shift masks for 4-neighborhood\n    # For neighbors, use 'outside' as False arrays where appropriate\n    outside = ~inside\n    # Check any of the 4 axial neighbors is outside\n    neighbor_outside = np.zeros_like(inside, dtype=bool)\n    neighbor_outside[1:, :] |= outside[:-1, :]   # left neighbor outside\n    neighbor_outside[:-1, :] |= outside[1:, :]   # right neighbor outside\n    neighbor_outside[:, 1:] |= outside[:, :-1]   # bottom neighbor outside\n    neighbor_outside[:, :-1] |= outside[:, 1:]   # top neighbor outside\n\n    boundary |= (inside  neighbor_outside)\n\n    # Interior unknowns: inside but not boundary\n    unknown = inside  (~boundary)\n\n    return X, Y, inside, boundary, unknown, h\n\ndef assemble_and_solve(N, u_exact_func, f_func):\n    \"\"\"\n    Assemble the 5-point Laplacian system on the L-shaped domain mask and solve.\n    Enforce Dirichlet boundary using u_exact_func on boundary nodes.\n    \"\"\"\n    X, Y, inside, boundary, unknown, h = build_domain_masks(N)\n\n    # Map unknown nodes to indices\n    idx = -np.ones_like(inside, dtype=int)\n    unknown_positions = np.argwhere(unknown)\n    for k, (i, j) in enumerate(unknown_positions):\n        idx[i, j] = k\n    n_unknowns = unknown_positions.shape[0]\n\n    # Precompute exact u and f on all nodes\n    U_exact = u_exact_func(X, Y)\n    F = f_func(X, Y)\n\n    # Sparse matrix triplets\n    rows = []\n    cols = []\n    data = []\n    rhs = np.zeros(n_unknowns, dtype=float)\n\n    # For each unknown, add 5-point stencil and boundary contributions\n    for k, (i, j) in enumerate(unknown_positions):\n        # Diagonal entry\n        diag = 4.0 / (h * h)\n        rows.append(k); cols.append(k); data.append(diag)\n\n        # Neighbors: (i+1,j), (i-1,j), (i,j+1), (i,j-1)\n        for (ip, jp) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n            if unknown[ip, jp]:\n                # neighbor unknown -> coefficient -1/h^2\n                rows.append(k); cols.append(idx[ip, jp]); data.append(-1.0 / (h * h))\n            elif boundary[ip, jp]:\n                # neighbor boundary -> move known Dirichlet to RHS\n                rhs[k] += (1.0 / (h * h)) * U_exact[ip, jp]\n            else:\n                # Should not happen for interior unknowns: all neighbors must be inside.\n                # But we keep a safe-guard; in L-shaped aligned domain this case is absent.\n                pass\n\n        # Right-hand side f at (i,j)\n        rhs[k] += F[i, j]\n\n    if n_unknowns > 0:\n        A = coo_matrix((data, (rows, cols)), shape=(n_unknowns, n_unknowns)).tocsr()\n        u_int = spsolve(A, rhs)\n    else:\n        u_int = np.array([])\n\n    # Compose full grid solution: boundary from U_exact, interior from u_int\n    U_num = np.array(U_exact)  # start from exact for convenience (boundary exact)\n    if n_unknowns > 0:\n        for val, (i, j) in zip(u_int, unknown_positions):\n            U_num[i, j] = val\n\n    # Compute discrete L2 error over inside nodes\n    err_sq = ((U_num - U_exact) ** 2) * inside.astype(float)\n    E_h = np.sqrt(np.sum(err_sq) * (h * h))\n    return E_h\n\ndef observed_order(errors, hs):\n    \"\"\"\n    Compute observed orders between successive refinements and return average.\n    \"\"\"\n    orders = []\n    for k in range(len(errors) - 1):\n        if errors[k+1] > 0 and errors[k] > 0:\n            p = np.log(errors[k] / errors[k+1]) / np.log(hs[k] / hs[k+1])\n            orders.append(p)\n    if len(orders) == 0:\n        return float('nan')\n    return float(np.mean(orders))\n\ndef case_A():\n    # u = sin(pi x) sin(pi y); f = 2*pi^2 * sin(pi x) sin(pi y)\n    def u_exact(X, Y):\n        return np.sin(np.pi * X) * np.sin(np.pi * Y)\n    def f_func(X, Y):\n        return 2.0 * (np.pi ** 2) * np.sin(np.pi * X) * np.sin(np.pi * Y)\n\n    Ns = [16, 32, 64]\n    errors = []\n    hs = []\n    for N in Ns:\n        E = assemble_and_solve(N, u_exact, f_func)\n        errors.append(E)\n        hs.append(2.0 / N)\n    return observed_order(errors, hs)\n\ndef case_B():\n    # u = exp(x+y); f = -2*exp(x+y)\n    def u_exact(X, Y):\n        return np.exp(X + Y)\n    def f_func(X, Y):\n        return -2.0 * np.exp(X + Y)\n\n    Ns = [8, 16, 32]\n    errors = []\n    hs = []\n    for N in Ns:\n        E = assemble_and_solve(N, u_exact, f_func)\n        errors.append(E)\n        hs.append(2.0 / N)\n    return observed_order(errors, hs)\n\ndef case_C():\n    # u = cos(2x) cos(3y); f = 13 cos(2x) cos(3y)\n    def u_exact(X, Y):\n        return np.cos(2.0 * X) * np.cos(3.0 * Y)\n    def f_func(X, Y):\n        return 13.0 * np.cos(2.0 * X) * np.cos(3.0 * Y)\n\n    Ns = [24, 48, 96]\n    errors = []\n    hs = []\n    for N in Ns:\n        E = assemble_and_solve(N, u_exact, f_func)\n        errors.append(E)\n        hs.append(2.0 / N)\n    return observed_order(errors, hs)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case returns an average observed order of convergence.\n    results = []\n    results.append(case_A())\n    results.append(case_B())\n    results.append(case_C())\n\n    # Format each result to a reasonable number of decimals\n    formatted = [\"{:.6f}\".format(r) for r in results]\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}