{
    "hands_on_practices": [
        {
            "introduction": "理论知识到实际应用的转化是计算工程的核心。这个练习将引导你通过一个经典的物理问题——艾里方程，来体验这一过程。通过使用有限差分法对微分方程进行离散化，你将亲手构建一个三对角线性系统，并对其进行求解，从而直观地理解带状系统在解决现实世界问题中的起源和威力。",
            "id": "2373161",
            "problem": "考虑有限区间上的 Airy 微分方程边值问题：求函数 $y(x)$ 使得\n$$\ny''(x) - x\\,y(x) = 0 \\quad \\text{for} \\quad x \\in [x_{\\mathrm{L}},x_{\\mathrm{R}}],\n$$\n满足 Dirichlet 边界条件 $y(x_{\\mathrm{L}}) = \\alpha$ 和 $y(x_{\\mathrm{R}}) = \\beta$。其精确解具有以下形式\n$$\ny(x) = c_1\\,\\operatorname{Ai}(x) + c_2\\,\\operatorname{Bi}(x),\n$$\n其中 $\\operatorname{Ai}(x)$ 和 $\\operatorname{Bi}(x)$ 分别是第一类和第二类 Airy 函数，常数 $c_1$ 和 $c_2$ 由边界条件唯一确定。\n\n在 $[x_{\\mathrm{L}},x_{\\mathrm{R}}]$ 上定义一个包含 $n$ 个内部点的均匀网格，各点由 $x_i = x_{\\mathrm{L}} + i\\,h$ 给出，其中 $i \\in \\{0,1,\\dots,n+1\\}$，$h = (x_{\\mathrm{R}} - x_{\\mathrm{L}})/(n+1)$，且 $x_0 = x_{\\mathrm{L}}$，$x_{n+1} = x_{\\mathrm{R}}$。令 $y_i$ 表示在网格点上对 $y(x_i)$ 的近似。对于每个内部索引 $i \\in \\{1,2,\\dots,n\\}$，施加以下线性关系\n$$\n\\frac{y_{i-1} - 2 y_i + y_{i+1}}{h^2} - x_i\\,y_i = 0.\n$$\n将边界值视为已知数据：$y_0 = \\alpha$ 和 $y_{n+1} = \\beta$。这样就得到了一个关于未知向量 $\\mathbf{u} = (y_1,y_2,\\dots,y_n)^\\top$ 的三对角线性系统，形式为 $\\mathbf{A}\\,\\mathbf{u} = \\mathbf{d}$，其中 $\\mathbf{A} \\in \\mathbb{R}^{n \\times n}$ 的次对角线和超对角线元素均为常数 $1/h^2$，第 $i$ 行的对角线元素为 $-2/h^2 - x_i$，右端项 $\\mathbf{d} \\in \\mathbb{R}^{n}$ 除边界贡献 $d_1 = -\\alpha/h^2$ 和 $d_n = -\\beta/h^2$ 外，其余元素均为零。\n\n您的任务是，对于下面指定的每个测试用例，计算最大绝对网格误差\n$$\nE_{\\infty} = \\max_{0 \\le j \\le n+1} \\left| y_j - y(x_j) \\right|,\n$$\n其中 $y_j$ 表示在 $x_j$ 处的数值近似，且 $y_0 = \\alpha$ 和 $y_{n+1} = \\beta$，$y(x)$ 是精确解，其常数 $c_1$ 和 $c_2$ 由以下边界条件确定：\n$$\n\\begin{bmatrix}\n\\operatorname{Ai}(x_{\\mathrm{L}})  \\operatorname{Bi}(x_{\\mathrm{L}}) \\\\\n\\operatorname{Ai}(x_{\\mathrm{R}})  \\operatorname{Bi}(x_{\\mathrm{R}})\n\\end{bmatrix}\n\\begin{bmatrix}\nc_1 \\\\ c_2\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\alpha \\\\ \\beta\n\\end{bmatrix}.\n$$\n\n测试套件。对于以下各组参数，将边界值设置为与端点处的第一类 Airy 函数相匹配，即 $\\alpha = \\operatorname{Ai}(x_{\\mathrm{L}})$ 和 $\\beta = \\operatorname{Ai}(x_{\\mathrm{R}})$：\n- 情况 1 (一般情况)：$x_{\\mathrm{L}} = 0$, $x_{\\mathrm{R}} = 1$, $n = 100$。\n- 情况 2 (单个内部未知数)：$x_{\\mathrm{L}} = 0$, $x_{\\mathrm{R}} = 1$, $n = 1$。\n- 情况 3 (更大区间)：$x_{\\mathrm{L}} = 0$, $x_{\\mathrm{R}} = 5$, $n = 500$。\n- 情况 4 (包含负值的区间)：$x_{\\mathrm{L}} = -2$, $x_{\\mathrm{R}} = 2$, $n = 400$。\n\n最终输出格式。您的程序应生成单行输出，其中包含四个 $E_{\\infty}$ 的值，每个值对应上述顺序的一个情况，以逗号分隔的列表形式包含在方括号内，例如 $[e_1,e_2,e_3,e_4]$。每个 $e_k$ 必须是一个实数（十进制表示）。不应打印任何其他文本。",
            "solution": "所提出的问题是计算科学与工程领域中一个有效且适定的边值问题。它要求使用有限差分格式对 Airy 微分方程进行数值求解，这会产生一个三对角线性系统。任务是针对几种参数配置，计算与已知精确解相比的最大网格误差。该问题有科学依据、内容自洽且客观。没有矛盾、歧义或违反基本原理之处。我们开始求解。\n\n问题是求解 Airy 微分方程的数值近似解 $y(x)$，该方程由下式给出\n$$\ny''(x) - x\\,y(x) = 0,\n$$\n在有限域 $x \\in [x_{\\mathrm{L}}, x_{\\mathrm{R}}]$ 上，满足 Dirichlet 边界条件 $y(x_{\\mathrm{L}}) = \\alpha$ 和 $y(x_{\\mathrm{R}}) = \\beta$。\n\n首先，我们建立一个均匀的计算网格。区间 $[x_{\\mathrm{L}}, x_{\\mathrm{R}}]$ 被离散化为 $n+1$ 个等宽的子区间，宽度为 $h = (x_{\\mathrm{R}} - x_{\\mathrm{L}})/(n+1)$。这定义了一组 $n+2$ 个网格点 $x_i = x_{\\mathrm{L}} + i\\,h$，其中 $i \\in \\{0, 1, \\dots, n+1\\}$，$x_0 = x_{\\mathrm{L}}$ 且 $x_{n+1} = x_{\\mathrm{R}}$。令 $y_i$ 为每个网格点上精确解 $y(x_i)$ 的数值近似。边界上的值由给定条件固定：$y_0 = \\alpha$ 和 $y_{n+1} = \\beta$。未知数是 $n$ 个内部网格点上的值，$y_1, y_2, \\dots, y_n$。\n\n为了将连续的微分方程转换为代数方程组，我们采用有限差分近似。在内部网格点 $x_i$ 处的二阶导数 $y''(x)$ 使用二阶精度中心差分公式进行近似：\n$$\ny''(x_i) \\approx \\frac{y(x_{i-1}) - 2y(x_i) + y(x_{i+1})}{h^2}.\n$$\n将此近似代入每个内部点 $x_i$（其中 $i \\in \\{1, 2, \\dots, n\\}$）的 Airy 方程，我们得到一个包含 $n$ 个线性方程的方程组：\n$$\n\\frac{y_{i-1} - 2y_i + y_{i+1}}{h^2} - x_i y_i = 0.\n$$\n重新整理此方程，将未知项（$y_1, \\dots, y_n$）分组到左侧，得到：\n$$\n\\frac{1}{h^2} y_{i-1} + \\left(-\\frac{2}{h^2} - x_i\\right) y_i + \\frac{1}{h^2} y_{i+1} = 0.\n$$\n这组关于 $i = 1, \\dots, n$ 的方程构成了一个形式为 $\\mathbf{A} \\mathbf{u} = \\mathbf{d}$ 的线性系统，其中 $\\mathbf{u} = (y_1, y_2, \\dots, y_n)^\\top$ 是内部未知值的向量。\n\n对于第一个方程（$i=1$），项 $y_0$ 是已知的（$\\alpha$），因此将其移到右侧：\n$$\n\\left(-\\frac{2}{h^2} - x_1\\right) y_1 + \\frac{1}{h^2} y_2 = -\\frac{1}{h^2} y_0 = -\\frac{\\alpha}{h^2}.\n$$\n对于最后一个方程（$i=n$），项 $y_{n+1}$ 是已知的（$\\beta$），也将其移到右侧：\n$$\n\\frac{1}{h^2} y_{n-1} + \\left(-\\frac{2}{h^2} - x_n\\right) y_n = -\\frac{1}{h^2} y_{n+1} = -\\frac{\\beta}{h^2}.\n$$\n对于任何其他内部方程，其中 $1  i  n$，右侧为 $0$。\n\n因此，系数矩阵 $\\mathbf{A} \\in \\mathbb{R}^{n \\times n}$ 是三对角的，具有以下结构：\n- 主对角线元素：$A_{i,i} = -2/h^2 - x_i$\n- 次对角线和超对角线元素：$A_{i, i+1} = A_{i+1, i} = 1/h^2$\n\n右端向量 $\\mathbf{d} \\in \\mathbb{R}^n$ 由下式给出：\n$$\nd_i = \\begin{cases}\n    -\\alpha/h^2   \\text{if } i = 1, \\\\\n    0   \\text{if } 1  i  n, \\\\\n    -\\beta/h^2   \\text{if } i = n \\text{ and } n  1, \\\\\n    -(\\alpha+\\beta)/h^2   \\text{if } i = 1 \\text{ and } n = 1.\n\\end{cases}\n$$\n这种结构可以使用针对带状矩阵的专门算法高效求解，例如 SciPy 库中提供的算法。\n\n为了计算误差，我们需要精确解。Airy 方程的通解是 $y(x) = c_1 \\operatorname{Ai}(x) + c_2 \\operatorname{Bi}(x)$。常数 $c_1$ 和 $c_2$ 由边界条件确定。对于所有测试用例，边界值都设置为 $\\alpha = \\operatorname{Ai}(x_{\\mathrm{L}})$ 和 $\\beta = \\operatorname{Ai}(x_{\\mathrm{R}})$。因此，边界条件变为：\n$$\nc_1 \\operatorname{Ai}(x_{\\mathrm{L}}) + c_2 \\operatorname{Bi}(x_{\\mathrm{L}}) = \\operatorname{Ai}(x_{\\mathrm{L}})\n$$\n$$\nc_1 \\operatorname{Ai}(x_{\\mathrm{R}}) + c_2 \\operatorname{Bi}(x_{\\mathrm{R}}) = \\operatorname{Ai}(x_{\\mathrm{R}})\n$$\n通过观察可知，该系统的唯一解是 $c_1=1$ 和 $c_2=0$，因为 Airy 函数 $\\operatorname{Ai}(x)$ 和 $\\operatorname{Bi}(x)$ 构成了一个基础解系。因此，所有测试用例的精确解就是 $y(x) = \\operatorname{Ai}(x)$。\n\n每个测试用例的数值计算步骤如下：\n1.  定义参数 $x_{\\mathrm{L}}$、$x_{\\mathrm{R}}$ 和 $n$。\n2.  计算网格间距 $h$、内部网格点 $x_i$ 以及边界值 $\\alpha = \\operatorname{Ai}(x_{\\mathrm{L}})$ 和 $\\beta = \\operatorname{Ai}(x_{\\mathrm{R}})$。\n3.  以带状格式构建三对角矩阵 $\\mathbf{A}$ 和右端向量 $\\mathbf{d}$。\n4.  求解线性系统 $\\mathbf{A}\\mathbf{u} = \\mathbf{d}$，以找到数值近似向量 $\\mathbf{u} = (y_1, \\dots, y_n)^\\top$。\n5.  构建完整的数值解向量 $(y_0, y_1, \\dots, y_n, y_{n+1}) = (\\alpha, u_1, \\dots, u_n, \\beta)$。\n6.  在所有网格点 $x_j$（其中 $j \\in \\{0, \\dots, n+1\\}$）上计算精确解 $y(x_j) = \\operatorname{Ai}(x_j)$。\n7.  计算最大绝对误差 $E_{\\infty} = \\max_{0 \\le j \\le n+1} |y_j - y(x_j)|$。由于边界处的误差根据构造为零，这简化为计算内部点的最大误差。\n\n对四个指定的测试用例中的每一个都执行此过程，以获得所需的误差值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import airy\nfrom scipy.linalg import solve_banded\n\ndef solve_airy_bvp(x_L: float, x_R: float, n: int) - float:\n    \"\"\"\n    Solves the Airy BVP using finite differences and returns the max grid error.\n\n    Args:\n        x_L (float): Left boundary of the interval.\n        x_R (float): Right boundary of the interval.\n        n (int): Number of interior grid points.\n\n    Returns:\n        float: The maximum absolute error E_infinity.\n    \"\"\"\n    if n  0:\n        raise ValueError(\"Number of interior points n must be non-negative.\")\n\n    # 1. Setup grid\n    # The total number of points is n+2. The number of intervals is n+1.\n    h = (x_R - x_L) / (n + 1)\n    \n    # Generate the full grid from x_0 to x_{n+1}\n    x_full = np.linspace(x_L, x_R, n + 2)\n    \n    # The interior points are x_1 to x_n\n    x_interior = x_full[1:-1]\n\n    # 2. Define boundary conditions based on the problem statement\n    # The exact solution is y(x) = Ai(x).\n    # alpha = y(x_L), beta = y(x_R)\n    alpha, _, _, _ = airy(x_L)\n    beta, _, _, _ = airy(x_R)\n\n    # If there are no interior points, the error is 0 as boundaries are exact.\n    if n == 0:\n        return 0.0\n\n    # 3. Construct the tridiagonal linear system A*u = d\n    # A is represented in a banded format for scipy.linalg.solve_banded.\n    # The banded matrix `ab` has 3 rows for a tridiagonal matrix:\n    # row 0: super-diagonal (shifted)\n    # row 1: main-diagonal\n    # row 2: sub-diagonal (shifted)\n    ab = np.zeros((3, n))\n    h2_inv = 1.0 / (h * h)\n\n    # Populate the main, sub-, and super-diagonals of matrix A\n    ab[0, 1:] = h2_inv  # Super-diagonal\n    ab[1, :] = -2.0 * h2_inv - x_interior  # Main-diagonal\n    ab[2, :-1] = h2_inv  # Sub-diagonal\n\n    # Construct the right-hand side vector d\n    d = np.zeros(n)\n    d[0] = -alpha * h2_inv\n    # The beta contribution is added to the last element.\n    # This correctly handles the n=1 case where the first and last elements are the same.\n    d[-1] += -beta * h2_inv\n\n    # 4. Solve the linear system for u = (y_1, ..., y_n)\n    u = solve_banded((1, 1), ab, d)\n\n    # 5. Assemble the full numerical solution and find the exact solution\n    # The full numerical solution includes the boundary values.\n    y_numerical = np.concatenate(([alpha], u, [beta]))\n    \n    # The exact solution is Ai(x) evaluated at all grid points.\n    y_exact, _, _, _ = airy(x_full)\n\n    # 6. Compute the maximum absolute grid error E_infinity\n    error = np.max(np.abs(y_numerical - y_exact))\n    \n    return error\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple is (x_L, x_R, n).\n    test_cases = [\n        (0.0, 1.0, 100),    # Case 1\n        (0.0, 1.0, 1),      # Case 2\n        (0.0, 5.0, 500),    # Case 3\n        (-2.0, 2.0, 400),   # Case 4\n    ]\n\n    results = []\n    for case in test_cases:\n        x_L, x_R, n = case\n        e_infinity = solve_airy_bvp(x_L, x_R, n)\n        results.append(e_infinity)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "对于三对角系统，虽然存在如托马斯算法（Thomas algorithm）这样的高效解法，但它们在特定情况下可能会失效，例如当主对角线上出现零元素时。这个练习旨在挑战你实现一个更稳健的求解器。通过引入部分主元法，你将学会处理这些数值计算中的“陷阱”，并深刻体会数值稳定性在算法设计中的关键作用。",
            "id": "2447586",
            "problem": "给定形式为 $A \\mathbf{x} = \\mathbf{d}$ 的严格三对角线性系统，其中 $A \\in \\mathbb{R}^{n \\times n}$ 的非零元素仅存在于主对角线、第一副对角线和第一超对角线上。该三对角矩阵由三个数组指定：副对角线 $\\{a_i\\}_{i=1}^{n}$（其中 $a_1 = 0$）、主对角线 $\\{b_i\\}_{i=1}^{n}$ 和超对角线 $\\{c_i\\}_{i=1}^{n}$（其中 $c_n = 0$）。对于下面的每个测试用例，右侧向量 $\\mathbf{d}$ 是通过已知的解向量 $\\mathbf{x}^{\\mathrm{true}}$ 按 $\\mathbf{d} = A \\mathbf{x}^{\\mathrm{true}}$ 构建的。\n\n您的任务是编写一个完整的程序，针对每个测试用例，使用一种即使在某些 $b_i$ 等于零时也保持正确的稳健直接法来计算 $A \\mathbf{x} = \\mathbf{d}$ 的解 $\\mathbf{x}$。然后，程序必须为每个测试用例输出计算出的解向量 $\\mathbf{x}$。\n\n不涉及物理单位。不涉及角度。所有输出都必须是数值。\n\n测试套件（使用这些确切的案例）：\n\n- 案例 $1$（理想情况，严格对角占优）：$n = 5$。系数：$a_1 = 0$，对于 $i \\in \\{2,3,4,5\\}$，$a_i = -1$；对于 $i \\in \\{1,2,3,4,5\\}$，$b_i = 2$；对于 $i \\in \\{1,2,3,4\\}$，$c_i = -1$，且 $c_5 = 0$。设 $\\mathbf{x}^{\\mathrm{true}} = [1,1,1,1,1]^\\top$。计算 $\\mathbf{d} = A \\mathbf{x}^{\\mathrm{true}}$。\n- 案例 $2$（边界情况，第一个方程主对角线上为零，但系统非奇异）：$n = 4$。系数：$a_1 = 0$，$a_2 = 1$，$a_3 = 1$，$a_4 = 1$；$b_1 = 0$，$b_2 = 2$，$b_3 = 2$，$b_4 = 2$；$c_1 = 1$，$c_2 = 1$，$c_3 = 1$，$c_4 = 0$。设 $\\mathbf{x}^{\\mathrm{true}} = [1,1,1,1]^\\top$。计算 $\\mathbf{d} = A \\mathbf{x}^{\\mathrm{true}}$。\n- 案例 $3$（无交换时接近崩溃，数值上敏感的主元）：$n = 6$。系数：$a_1 = 0$，对于 $i \\in \\{2,3,4,5,6\\}$，$a_i = -1$；$b_1 = 10^{-16}$，对于 $i \\in \\{2,3,4,5,6\\}$，$b_i = 2$；对于 $i \\in \\{1,2,3,4,5\\}$，$c_i = -1$，且 $c_6 = 0$。设 $\\mathbf{x}^{\\mathrm{true}} = [1,1,1,1,1,1]^\\top$。计算 $\\mathbf{d} = A \\mathbf{x}^{\\mathrm{true}}$。\n\n最终输出格式：\n\n- 对于每个测试用例 $k$，计算 $A^{(k)} \\mathbf{x}^{(k)} = \\mathbf{d}^{(k)}$ 的数值解 $\\mathbf{x}^{(k)}$。\n- 您的程序应生成单行输出，其中包含一个由三个列表组成的逗号分隔列表，第 $k$ 个内部列表是解 $\\mathbf{x}^{(k)}$ 四舍五入到 $10$ 位小数。例如，输出格式为 `[[1.0000000000, 1.0000000000, ...], [...], [...]]`。\n- 所需的答案（每个 $\\mathbf{x}^{(k)}$ 的条目）是浮点数。这三个测试用例必须按上述方式汇总到单行中。",
            "solution": "该问题要求解在三种不同情况下表示为 $A \\mathbf{x} = \\mathbf{d}$ 的严格三对角线性方程组。矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 的非零元素仅存在于其主对角线 ($b_i$)、副对角线 ($a_i$) 和超对角线 ($c_i$) 上。一个关键要求是，所选的求解方法必须是一种稳健的直接法，能够处理对角元素 $b_i$ 为零的情况，而标准的托马斯算法在这种情况下会失效。\n\n首先，对给定问题进行验证。问题陈述在科学上基于数值线性代数，这是计算科学的核心组成部分。该问题是适定的，因为每个测试用例都对应一个非奇异线性系统，保证了唯一解的存在。定义是客观明确的，并且提供了复现测试用例所需的所有信息。因此，该问题是有效的。\n\n求解三对角系统的标准直接法是托马斯算法，它是高斯消元法的一种特例。该算法包括一个前向消元过程和一个后向代入过程。在前向过程中，系统被转换为一个上双对角系统。对于第 $i$ 个方程 $a_i x_{i-1} + b_i x_i + c_i x_{i+1} = d_i$，这是通过消去 $x_{i-1}$ 来实现的。这会导出修正系数的递推关系。例如，一种常见的公式如下修改对角线和右侧项：\n$$ b'_1 = b_1, \\quad d'_1 = d_1 $$\n对于 $i = 2, \\dots, n$:\n$$ m_i = \\frac{a_i}{b'_{i-1}} $$\n$$ b'_i = b_i - m_i c_{i-1} $$\n$$ d'_i = d_i - m_i d'_{i-1} $$\n然后通过后向代入求解该系统：\n$$ x_n = \\frac{d'_n}{b'_n} $$\n$$ x_i = \\frac{d'_i - c_i x_{i+1}}{b'_i} \\quad \\text{for } i = n-1, \\dots, 1 $$\n该算法效率很高，时间复杂度为 $\\mathcal{O}(n)$。然而，其关键缺陷是在每一步都需要除以主元 $b'_{i-1}$。如果任何 $b'_{i-1}$ 为零或数值上接近于零，算法就会失效或变得数值不稳定。这正是测试用例 2（其中 $b_1 = 0$）和测试用例 3（其中 $b_1 = 10^{-16}$）所突显的问题。\n\n为解决这一缺陷，需要一种稳健的直接法。对此类问题的经典选择是带部分主元的高斯消元法 (Gaussian Elimination with Partial Pivoting, GEPP)。GEPP 的原理是通过确保主元在数量级上尽可能大来减轻数值不稳定性。在消元的每一步 $j$，算法会检查当前列 $j$ 中从行 $j$ 向下的所有条目。然后，它将当前行 $j$ 与包含最大绝对值条目（主元）的行进行交换。\n\n对于三对角矩阵，在列 $j$ 的主元选择步骤得以简化。在列 $j$ 中，对角线上或其下方的唯一潜在非零条目是 $A_{j,j}$（即 $b_j$）和 $A_{j+1,j}$（即 $a_{j+1}$）。因此，部分主元选择仅需比较 $|A_{j,j}|$ 与 $|A_{j+1,j}|$，如果后者更大，则交换行 $j$ 和行 $j+1$。这样的交换可能会在三对角结构之外引入一个非零元素（称为“填充”），具体来说，如果行 $j$ 与行 $j+1$ 交换，则在位置 $(j, j+2)$ 处。由此产生的矩阵变成一个上带宽为 $2$ 的上三角矩阵。\n\nGEPP 算法的流程如下：\n1.  **带部分主元的前向消元**：对于从 $1$ 到 $n-1$ 的每一列 $j$：\n    a.  **主元选择**：找到行索引 $p \\ge j$ 以使 $|A_{p,j}|$ 最大化。对于初始的三对角系统，$p$ 将是 $j$ 或 $j+1$。交换行 $j$ 和行 $p$。同时交换向量 $\\mathbf{d}$ 中相应的元素。\n    b.  **消元**：对于从 $j+1$ 到 $n$ 的每一行 $i$，计算乘数 $m = A_{i,j} / A_{j,j}$。通过减去 $m$ 倍的主元行 $j$ 来更新行 $i$：$R_i \\leftarrow R_i - m R_j$。此操作将元素 $A_{i,j}$ 置零。同样的操作也应用于右侧向量：$d_i \\leftarrow d_i - m d_j$。对于初始的三对角系统，在步骤 $j$ 中，只有行 $j+1$ 会有一个非零的 $A_{j+1,j}$ 需要被消去。\n\n2.  **后向代入**：在前向消元过程之后，矩阵 $A$ 被转换为一个上三角矩阵 $U$。然后从最后一个变量 $x_n$ 开始，向后进行到 $x_1$，求解系统 $U \\mathbf{x} = \\mathbf{d'}$ 以得到 $\\mathbf{x}$：\n    $$ x_n = \\frac{d'_n}{U_{n,n}} $$\n    $$ x_i = \\frac{1}{U_{i,i}} \\left( d'_i - \\sum_{k=i+1}^{n} U_{i,k} x_k \\right) \\quad \\text{for } i = n-1, \\dots, 1 $$\n该算法对于零对角元素是稳健的（前提是矩阵非奇异）并且数值稳定。对于指定的小问题规模 ($n \\le 6$)，使用 $A$ 的稠密矩阵表示来实现此算法是直接且计算上可接受的，避免了管理带填充的带状矩阵结构的复杂性。因此，提供的解决方案代码将在稠密矩阵表示上实现带部分主元的高斯消元法。",
            "answer": "```python\nimport numpy as np\n\ndef solve_gepp(A_in, d_in):\n    \"\"\"\n    Solves the linear system Ax=d using Gaussian Elimination with Partial Pivoting.\n\n    Args:\n        A_in (np.ndarray): A square n x n matrix.\n        d_in (np.ndarray): A vector of length n.\n\n    Returns:\n        np.ndarray: The solution vector x.\n    \"\"\"\n    A = np.copy(A_in).astype(np.float64)\n    d = np.copy(d_in).astype(np.float64)\n    n = len(d)\n\n    # Forward elimination with partial pivoting\n    for j in range(n - 1):\n        # Find the row with the largest pivot in column j (from j downwards)\n        pivot_row_index = j + np.argmax(np.abs(A[j:, j]))\n\n        # Swap rows if a larger pivot is found\n        if pivot_row_index != j:\n            A[[j, pivot_row_index], :] = A[[pivot_row_index, j], :]\n            d[j], d[pivot_row_index] = d[pivot_row_index], d[j]\n\n        # The pivot element is A[j, j]. For a non-singular matrix, it must be non-zero\n        # after pivoting. The problems are guaranteed to be non-singular.\n        if A[j, j] == 0:\n            # This path should not be taken for the given problems.\n            continue\n\n        # Elimination step: zero out entries in column j below the pivot\n        for i in range(j + 1, n):\n            if A[i, j] != 0:\n                multiplier = A[i, j] / A[j, j]\n                A[i, j:] -= multiplier * A[j, j:]\n                d[i] -= multiplier * d[j]\n\n    # Backward substitution to solve the upper triangular system\n    x = np.zeros(n)\n    for i in range(n - 1, -1, -1):\n        # The problems are non-singular, so division by zero is not expected.\n        if A[i, i] == 0:\n            # This indicates a singular matrix\n            raise ValueError(\"Matrix is singular and cannot be solved.\")\n        \n        sum_ax = np.dot(A[i, i + 1:], x[i + 1:])\n        x[i] = (d[i] - sum_ax) / A[i, i]\n        \n    return x\n\ndef create_tridiagonal_matrix(n, a_coeffs, b_coeffs, c_coeffs):\n    \"\"\"Helper function to create the dense tridiagonal matrix.\"\"\"\n    A = np.zeros((n, n), dtype=np.float64)\n    for i in range(n):\n        A[i, i] = b_coeffs[i]\n        if i > 0:\n            A[i, i-1] = a_coeffs[i-1]\n        if i  n - 1:\n            A[i, i+1] = c_coeffs[i]\n    return A\n\ndef solve():\n    \"\"\"\n    Solves the tridiagonal systems for the specified test cases and prints the results.\n    \"\"\"\n    test_cases = [\n        {\n            \"n\": 5,\n            \"a\": [-1., -1., -1., -1.],  # indices i=2 to n, so n-1 elements\n            \"b\": [2., 2., 2., 2., 2.],\n            \"c\": [-1., -1., -1., -1.],  # indices i=1 to n-1, so n-1 elements\n            \"xtrue\": np.array([1., 1., 1., 1., 1.])\n        },\n        {\n            \"n\": 4,\n            \"a\": [1., 1., 1.],\n            \"b\": [0., 2., 2., 2.],\n            \"c\": [1., 1., 1.],\n            \"xtrue\": np.array([1., 1., 1., 1.])\n        },\n        {\n            \"n\": 6,\n            \"a\": [-1., -1., -1., -1., -1.],\n            \"b\": [1e-16, 2., 2., 2., 2., 2.],\n            \"c\": [-1., -1., -1., -1., -1.],\n            \"xtrue\": np.array([1., 1., 1., 1., 1., 1.])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        n = case[\"n\"]\n        a = case[\"a\"]\n        b = case[\"b\"]\n        c = case[\"c\"]\n        xtrue = case[\"xtrue\"]\n        \n        # Construct the dense matrix A\n        A = create_tridiagonal_matrix(n, a, b, c)\n\n        # Compute the right-hand side vector d\n        d = A @ xtrue\n        \n        # Solve the system Ax = d using the robust GEPP method\n        x_computed = solve_gepp(A, d)\n        results.append(x_computed)\n\n    # Format the output as specified\n    formatted_results = []\n    for res in results:\n        formatted_res = '[' + ','.join([f\"{val:.10f}\" for val in res]) + ']'\n        formatted_results.append(formatted_res)\n    \n    final_output = f\"[{','.join(formatted_results)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "三对角矩阵仅仅是更广泛的带状矩阵家族中的一个特例。为了将你的技能拓展到更广阔的领域，这个练习要求你实现一个通用的带状系统求解器。你将学习如何为具有任意上下带宽的矩阵设计并实现高效的LU分解和求解算法，这是解决许多高级工程和科学模拟问题的强大工具。",
            "id": "2373172",
            "problem": "要求您编写一个完整且可运行的程序，该程序使用无主元选择的下上三角（LU）分解法，为非中心带状线性系统实现一个求解器。一个方阵 $A \\in \\mathbb{R}^{n \\times n}$ 被称为带状矩阵，其下带宽为 $p$，上带宽为 $q$，如果当 $j  i - p$ 或 $j  i + q$ 时，$A_{i,j} = 0$。换句话说，非零元素的模式被限制在主对角线以下的 $p$ 条次对角线和以上的 $q$ 条超对角线之内。目标是通过利用带状结构将运算限制在带内来求解 $A x = b$。\n\n从高斯消去法的定义和LU分解 $A = L U$（其中 $L$ 是单位下三角矩阵，即对角线元素为1，$U$ 是上三角矩阵）的概念出发，推导出一个算法，该算法：\n- 假设不需要主元选择，仅在由 $p$ 和 $q$ 所确定的带内执行消去步骤。\n- 将对角线下的乘子存储为 $L$ 的元素，并将变换后的上部存储为 $U$ 的元素。\n- 使用前向代入法求解 $L y = b$，然后使用后向代入法求解 $U x = y$。\n\n您的实现不能依赖任何直接求解带状系统的库例程；相反，它必须显式地实现LU分解和三角求解，仅使用带宽参数 $p$ 和 $q$ 来限制运算范围。\n\n测试套件。您的程序必须将求解器应用于以下五个测试用例。在每个用例中，完全按照规定构造 $A$、$x_{\\text{true}}$ 和 $b = A x_{\\text{true}}$，然后使用您的带状LU求解器计算数值解 $\\hat{x}$，并报告误差的无穷范数 $\\lVert \\hat{x} - x_{\\text{true}} \\rVert_{\\infty} = \\max_i | \\hat{x}_i - (x_{\\text{true}})_i |$ 作为浮点数。\n\n- 用例 $1$（一般非中心带）：$n=7$, $p=2$, $q=1$。定义 $A \\in \\mathbb{R}^{7 \\times 7}$ 如下\n  - 对于 $1 \\le i \\le 7$，$A_{i,i} = 5 + i$，\n  - 对于 $1 \\le i \\le 6$，$A_{i,i+1} = -1$，\n  - 对于 $2 \\le i \\le 7$，$A_{i,i-1} = -2$，\n  - 对于 $3 \\le i \\le 7$，$A_{i,i-2} = 0.5$，\n  - 所有其他元素 $A_{i,j} = 0$。\n  令 $x_{\\text{true}} = [1,-2,3,-4,5,-6,7]^{\\top}$。\n\n- 用例 $2$（三对角）：$n=6$, $p=1$, $q=1$。定义 $A \\in \\mathbb{R}^{6 \\times 6}$ 如下\n  - 对于 $1 \\le i \\le 6$，$A_{i,i} = 4$，\n  - 对于 $1 \\le i \\le 5$，$A_{i,i+1} = -1$，\n  - 对于 $2 \\le i \\le 6$，$A_{i,i-1} = -1$，\n  - 所有其他元素 $A_{i,j} = 0$。\n  令 $x_{\\text{true}} = [1,1,1,1,1,1]^{\\top}$。\n\n- 用例 $3$（上带宽为 $q=3$ 的上带状）：$n=5$, $p=0$, $q=3$。定义 $A \\in \\mathbb{R}^{5 \\times 5}$ 如下\n  - 对于 $1 \\le i \\le 5$，$A_{i,i} = 4 + i$，\n  - 对于 $1 \\le i \\le 4$，$A_{i,i+1} = 0.5$，\n  - 对于 $1 \\le i \\le 3$，$A_{i,i+2} = -0.25$，\n  - 对于 $1 \\le i \\le 2$，$A_{i,i+3} = 0.125$，\n  - 所有其他元素 $A_{i,j} = 0$。\n  令 $x_{\\text{true}} = [2,-1,0.5,-0.5,1]^{\\top}$。\n\n- 用例 $4$（下带宽为 $p=2$ 的下带状）：$n=5$, $p=2$, $q=0$。定义 $A \\in \\mathbb{R}^{5 \\times 5}$ 如下\n  - 对于 $1 \\le i \\le 5$，$A_{i,i} = 5$，\n  - 对于 $2 \\le i \\le 5$，$A_{i,i-1} = -1$，\n  - 对于 $3 \\le i \\le 5$，$A_{i,i-2} = 0.3$，\n  - 所有其他元素 $A_{i,j} = 0$。\n  令 $x_{\\text{true}} = [1,2,3,4,5]^{\\top}$。\n\n- 用例 $5$（对角）：$n=6$, $p=0$, $q=0$。定义 $A \\in \\mathbb{R}^{6 \\times 6}$ 如下\n  - 对于 $1 \\le i \\le 6$，$A_{i,i} = 2 + 0.1 i$，\n  - 所有其他元素 $A_{i,j} = 0$。\n  令 $x_{\\text{true}} = [-1,2,-3,4,-5,6]^{\\top}$。\n\n在所有用例中，构建 $b = A x_{\\text{true}}$，用您的带状LU求解器求解 $A \\hat{x} = b$，计算无穷范数误差 $\\lVert \\hat{x} - x_{\\text{true}} \\rVert_{\\infty}$，并收集五个误差值。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，格式如 $[e_1,e_2,e_3,e_4,e_5]$，其中每个 $e_k$ 是用例 $k$ 计算出的无穷范数误差，表示为浮点数。",
            "solution": "所提出的问题是数值线性代数领域，特别是在计算工程领域中一个标准的、定义明确的练习。它要求推导并实现一个求解线性系统 $A x = b$ 的求解器，其中 $A$ 是一个带状矩阵，使用无主元选择的LU分解法。唯一解所需的所有组成部分都已提供：带状矩阵的定义、所需的方法以及一组五个不同的、数值上指定的测试用例。该问题具有科学依据，客观且完整。没有逻辑矛盾、歧义或事实不准确之处。因此，该问题被视为有效，并将提供完整的解决方案。\n\n任务是求解线性系统 $A x = b$，其中 $A \\in \\mathbb{R}^{n \\times n}$ 是一个下带宽为 $p$、上带宽为 $q$ 的方阵。这意味着如果 $j  i - p$ 或 $j  i + q$，则 $A_{i,j} = 0$。求解方法是LU分解，将 $A$ 分解为一个单位下三角矩阵 $L$ 和一个上三角矩阵 $U$ 的乘积，使得 $A = LU$。然后通过一个两步过程求解该系统：首先求解 $L y = b$（前向代入），然后求解 $U x = y$（后向代入）。\n\n一个关键的观察是，如果不执行行交换（主元选择），带状结构在高斯消去过程中会得以保留。得到的矩阵 $L$ 将具有 $p$ 的下带宽，而 $U$ 将具有 $q$ 的上带宽。这可以显著节省计算和存储成本。\n\n为了利用带状结构，我们避免存储完整的 $n \\times n$ 矩阵 $A$。取而代之的是，我们仅将非零带存储在一个大小为 $(p+q+1) \\times n$ 的紧凑矩阵中，记为 $A_{band}$。原始矩阵中的元素 $A_{i,j}$ 映射到紧凑存储中的一个元素。我们在此采用一个标准约定，将 $A_{i,j}$ 映射到元素 $A_{band}[i-j+q, j]$（使用0-based索引）。在这种方案中，$A$ 的主对角线位于 $A_{band}$ 的第 $q$ 行， $q$ 条超对角线位于第 $0, \\dots, q-1$ 行，而 $p$ 条次对角线位于第 $q+1, \\dots, q+p$ 行。\n\nLU分解过程是对 $A_{band}$ 矩阵的原地修改。该算法源自标准的高斯消去法。该过程从列 $k=0$ 到 $n-2$ 进行迭代，使用主元 $A_{k,k}$ 来消去其下方同一列中的非零项。\n\n对于每个主元列 $k \\in \\{0, 1, \\dots, n-2\\}$：\n待消去的元素是 $A_{i,k}$，其中行 $i$ 满足 $k+1 \\le i \\le \\min(n-1, k+p)$。\n对于每个这样的行 $i$，计算乘子为 $m_{i,k} = A_{i,k} / A_{k,k}$。\n这个乘子 $m_{i,k}$ 成为矩阵 $L$ 的元素 $L_{i,k}$。我们将其存储在先前由 $A_{i,k}$ 占用的位置。\n消元更新规则是 $A_{i,j} \\leftarrow A_{i,j} - m_{i,k} A_{k,j}$。此更新仅需应用于列 $j$，其中 $A_{i,j}$ 和 $A_{k,j}$ 都可能为非零。这对应于列 $j \\in \\{k+1, \\dots, \\min(n-1, k+q)\\}$。\n\n对于紧凑存储 $A_{band}$，分解算法如下，其中 $k \\in \\{0, \\dots, n-2\\}$：\n1. 对于每个行索引 $i \\in \\{k+1, \\dots, \\min(n-1, k+p)\\}$：\n   a. 主元是 $U_{k,k} = A_{band}[q, k]$。\n   b. 待消去的元素是 $A_{i,k}$，位于 $A_{band}[i-k+q, k]$。\n   c. 计算乘子 $m_{i,k} = \\frac{A_{band}[i-k+q, k]}{A_{band}[q, k]}$。\n   d. 原地存储此乘子：$A_{band}[i-k+q, k] = m_{i,k}$。该项现在代表 $L_{i,k}$。\n   e. 对于每个列索引 $j \\in \\{k+1, \\dots, \\min(n-1, k+q)\\}$，更新行 $i$ 的相应元素：\n      $$ A_{band}[i-j+q, j] \\leftarrow A_{band}[i-j+q, j] - m_{i,k} \\times A_{band}[k-j+q, j] $$\n在原地完成 $A=LU$ 分解后，我们接着求解这两个三角系统。\n\n首先，进行前向代入求解 $L y = b$：\n由于 $L$ 是一个下带宽为 $p$ 的单位下三角矩阵，每个分量 $y_i$ 的公式为：\n$$ y_i = b_i - \\sum_{j=\\max(0, i-p)}^{i-1} L_{i,j} y_j \\quad \\text{for } i = 0, \\dots, n-1 $$\n元素 $L_{i,j}$ 是存储在 $A_{band}[i-j+q, j]$ 中的乘子。向量 $y$ 可以通过将 $i$ 从 $0$ 迭代到 $n-1$ 来计算。\n\n其次，进行后向代入求解 $U x = y$：\n由于 $U$ 是一个上带宽为 $q$ 的上三角矩阵，我们通过将 $i$ 从 $n-1$ 向下迭代到 $0$ 来求解 $x$：\n$$ x_i = \\frac{1}{U_{i,i}} \\left( y_i - \\sum_{j=i+1}^{\\min(n-1, i+q)} U_{i,j} x_j \\right) \\quad \\text{for } i = n-1, \\dots, 0 $$\n元素 $U_{i,j}$ 存储在 $A_{band}[i-j+q, j]$ 中。对角线元素 $U_{i,i}$ 位于 $A_{band}[q, i]$。\n\n至此，算法的推导完成。将构建一个实现这些步骤的程序来解决给定的测试用例。对于每个用例，定义矩阵 $A$ 和向量 $x_{\\text{true}}$，计算 $b = A x_{\\text{true}}$，使用推导出的带状LU求解器找到数值解 $\\hat{x}$，并报告误差的无穷范数 $\\lVert \\hat{x} - x_{\\text{true}} \\rVert_{\\infty}$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef full_to_banded(A, p, q):\n    \"\"\"\n    Converts a full numpy matrix A to its compact banded representation.\n    \"\"\"\n    n = A.shape[0]\n    A_band = np.zeros((p + q + 1, n))\n    for i in range(n):\n        for j in range(max(0, i - p), min(n, i + q + 1)):\n            # Mapping A[i, j] to A_band[row, col]\n            # row = i - j + q, col = j\n            A_band[i - j + q, j] = A[i, j]\n    return A_band\n\ndef banded_lu_factorization(A_band, p, q):\n    \"\"\"\n    Performs LU factorization in-place on a banded matrix.\n    The upper part of A_band will store U, the lower part will store L.\n    \"\"\"\n    n = A_band.shape[1]\n    # k is the pivot column (0-indexed)\n    for k in range(n - 1):\n        # Pivot element U_kk is at A_band[q, k]\n        pivot = A_band[q, k]\n        if pivot == 0:\n            # This would require pivoting, which is not implemented as per problem spec.\n            # For the given test cases, this should not occur.\n            raise ValueError(\"Zero pivot encountered.\")\n        \n        # i is the row to be updated\n        for i in range(k + 1, min(n, k + p + 1)):\n            # Multiplier L_ik = A_ik / U_kk\n            # Element A_ik is at A_band[i-k+q, k]\n            multiplier = A_band[i - k + q, k] / pivot\n            A_band[i - k + q, k] = multiplier  # Store L_ik\n\n            # Update row i from column k+1 to k+q\n            # A_ij - A_ij - L_ik * U_kj\n            for j in range(k + 1, min(n, k + q + 1)):\n                # U_kj is at A_band[k-j+q, j]\n                # A_ij is at A_band[i-j+q, j]\n                A_band[i - j + q, j] -= multiplier * A_band[k - j + q, j]\n\ndef solve_banded_lu(A_band, p, q, b):\n    \"\"\"\n    Solves A x = b for a banded system A, given its in-place LU factorization A_band.\n    \"\"\"\n    n = A_band.shape[1]\n    y = b.copy()\n\n    # Forward substitution to solve L y = b\n    # L is unit lower triangular with lower bandwidth p\n    for i in range(n):\n        s = 0.0\n        # Sum over L_ij * y_j\n        for j in range(max(0, i - p), i):\n            # L_ij is at A_band[i-j+q, j]\n            s += A_band[i - j + q, j] * y[j]\n        y[i] -= s\n\n    # Backward substitution to solve U x = y\n    # U is upper triangular with upper bandwidth q\n    x = y.copy()\n    for i in range(n - 1, -1, -1):\n        s = 0.0\n        # Sum over U_ij * x_j\n        for j in range(i + 1, min(n, i + q + 1)):\n            # U_ij is at A_band[i-j+q, j]\n            s += A_band[i - j + q, j] * x[j]\n        \n        # U_ii is at A_band[q, i]\n        x[i] = (y[i] - s) / A_band[q, i]\n        \n    return x\n\ndef get_test_cases():\n    \"\"\"\n    Generates the five test cases as specified in the problem.\n    Returns a list of tuples, each containing (A, p, q, x_true).\n    \"\"\"\n    cases = []\n\n    # Case 1\n    n1, p1, q1 = 7, 2, 1\n    A1 = np.zeros((n1, n1))\n    for i in range(n1):\n        A1[i, i] = 5.0 + (i + 1)\n        if i + 1  n1: A1[i, i + 1] = -1.0\n        if i - 1 = 0: A1[i, i - 1] = -2.0\n        if i - 2 = 0: A1[i, i - 2] = 0.5\n    x_true1 = np.array([1.0, -2.0, 3.0, -4.0, 5.0, -6.0, 7.0])\n    cases.append((A1, p1, q1, x_true1))\n\n    # Case 2\n    n2, p2, q2 = 6, 1, 1\n    A2 = np.zeros((n2, n2))\n    for i in range(n2):\n        A2[i, i] = 4.0\n        if i + 1  n2: A2[i, i + 1] = -1.0\n        if i - 1 = 0: A2[i, i - 1] = -1.0\n    x_true2 = np.ones(n2)\n    cases.append((A2, p2, q2, x_true2))\n\n    # Case 3\n    n3, p3, q3 = 5, 0, 3\n    A3 = np.zeros((n3, n3))\n    for i in range(n3):\n        A3[i, i] = 4.0 + (i + 1)\n        if i + 1  n3: A3[i, i + 1] = 0.5\n        if i + 2  n3: A3[i, i + 2] = -0.25\n        if i + 3  n3: A3[i, i + 3] = 0.125\n    x_true3 = np.array([2.0, -1.0, 0.5, -0.5, 1.0])\n    cases.append((A3, p3, q3, x_true3))\n\n    # Case 4\n    n4, p4, q4 = 5, 2, 0\n    A4 = np.zeros((n4, n4))\n    for i in range(n4):\n        A4[i, i] = 5.0\n        if i - 1 = 0: A4[i, i - 1] = -1.0\n        if i - 2 = 0: A4[i, i - 2] = 0.3\n    x_true4 = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\n    cases.append((A4, p4, q4, x_true4))\n\n    # Case 5\n    n5, p5, q5 = 6, 0, 0\n    A5 = np.zeros((n5, n5))\n    for i in range(n5):\n        A5[i, i] = 2.0 + 0.1 * (i + 1)\n    x_true5 = np.array([-1.0, 2.0, -3.0, 4.0, -5.0, 6.0])\n    cases.append((A5, p5, q5, x_true5))\n\n    return cases\n\ndef solve():\n    test_cases = get_test_cases()\n    results = []\n\n    for A_full, p, q, x_true in test_cases:\n        # 1. Create the banded system\n        b = A_full @ x_true\n        A_band = full_to_banded(A_full, p, q)\n\n        # 2. Perform LU factorization on the banded matrix\n        banded_lu_factorization(A_band, p, q)\n\n        # 3. Solve using forward/backward substitution\n        x_hat = solve_banded_lu(A_band, p, q, b)\n\n        # 4. Compute the infinity norm of the error\n        error = np.linalg.norm(x_hat - x_true, ord=np.inf)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}