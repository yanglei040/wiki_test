{
    "hands_on_practices": [
        {
            "introduction": "这个首个练习旨在深入探讨问题的核心。我们将处理伯格斯方程 (Burgers' equation) 两种在代数上等价但在数值上截然不同的形式，并为每种形式推导其离散格式。通过分析其更新规则的求和，并最终编写代码，你将直接验证为何基于守恒形式的有限体积法能够精确地保持离散量守恒，而一个基于非守恒形式的朴素有限差分格式则不然 。",
            "id": "2379409",
            "problem": "考虑在周期性一维域 $[0,1)$ 上，以两种代数上等价但数值上不同的形式写出的标量无粘性伯格斯方程 (Burgers' equation)：\n1) 守恒形式：$u_t + (f(u))_x = 0$，其中 $f(u) = \\tfrac{u^2}{2}$。\n2) 非守恒形式：$u_t + u\\,u_x = 0$。\n\n您的任务是：\nA) 从积分守恒律和单元平均观点出发，使用数值界面通量为守恒形式推导一个全离散的有限体积更新格式。在具有 $N$ 个单元（宽度 $\\Delta x = 1/N$）和周期性边界条件的均匀网格上，使用以下离散更新格式：\n$$\nu_i^{n+1} \\;=\\; u_i^n \\;-\\; \\frac{\\Delta t}{\\Delta x}\\left(F_{i+\\tfrac{1}{2}}^n - F_{i-\\tfrac{1}{2}}^n\\right),\n$$\n其中 Rusanov (局部 Lax–Friedrichs) 数值通量为\n$$\nF_{i+\\tfrac{1}{2}}^n \\;=\\; \\tfrac{1}{2}\\left(f(u_i^n) + f(u_{i+1}^n)\\right) \\;-\\; \\tfrac{1}{2}\\, a_{i+\\tfrac{1}{2}}^n \\left(u_{i+1}^n - u_i^n\\right),\n\\quad f(u) = \\tfrac{u^2}{2},\n\\quad a_{i+\\tfrac{1}{2}}^n = \\max\\left(\\lvert u_i^n\\rvert, \\lvert u_{i+1}^n\\rvert\\right).\n$$\n从基本原理（周期性网格上的离散散度定理）出发，证明总离散质量\n$$\nM^n \\;=\\; \\sum_{i=0}^{N-1} u_i^n \\,\\Delta x\n$$\n在所有时间步 $n$ 都精确守恒，即 $M^{n+1} = M^n$。\n\nB) 考虑在单元中心离散的非守恒形式 $u_t + u\\,u_x = 0$，其中空间导数使用前向有限差分，时间上使用向前欧拉法：\n$$\nu_i^{n+1} \\;=\\; u_i^n \\;-\\; \\Delta t\\,u_i^n\\,\\frac{u_{i+1}^n - u_i^n}{\\Delta x},\n$$\n其中使用周期性索引 $u_{N}^n \\equiv u_0^n$。通过将 $M^{n+1} - M^n$ 用离散场 $u_i^n$ 表示，并证明对于一般数据它不为零，从而分析地证明总离散质量 $M^n$ 在此更新格式下通常不守恒。\n\nC) 实现任务。编写一个完整、可运行的程序，该程序：\n- 在 $[0,1)$ 上使用周期性边界条件，并使用均匀网格，其单元中心位于 $x_i = \\left(i + \\tfrac{1}{2}\\right)\\Delta x$。\n- 对两种更新格式均使用时间上的向前欧拉法。\n- 使用根据 Courant–Friedrichs–Lewy (CFL) 准则在每一步动态选择的时间步长\n$$\n\\Delta t \\;=\\; \\text{CFL}\\cdot \\frac{\\Delta x}{\\max_i \\lvert u_i^n\\rvert + 10^{-12}},\n$$\n其中加上一个极小值仅为避免除以零。\n- 演化至指定的最终时间 $T$。\n\n测试组。对于每个测试，返回一个等于质量差 $\\Delta M = M^{\\text{final}} - M^{\\text{initial}}$ 的浮点数。使用以下测试：\n- 测试 1 (守恒格式)：$N = 200$，$\\text{CFL} = 0.9$， $T = 0.1$，初始条件 $u(x,0) = 0.5 + 0.5\\sin(2\\pi x)$。预期由于周期性网格上通量差分的精确伸缩求和，$\\Delta M$ 将近似为机器精度级别的零。\n- 测试 2 (非守恒格式)：$N = 200$，$\\text{CFL} = 0.4$， $T = 0.1$，初始条件 $u(x,0) = 0.5 + 0.5\\sin(2\\pi x)$。预期 $\\Delta M$ 非零。\n- 测试 3 (非守恒格式)：$N = 200$，$\\text{CFL} = 0.4$， $T = 0.1$，初始条件 $u(x,0) = \\sin(2\\pi x)$。预期 $\\Delta M$ 非零。\n\n最终输出格式。您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[r1,r2,r3]”），其中每个 $r_k$ 是对应测试的浮点质量差，顺序与上面列出的完全一致。不应打印任何其他文本。此问题中没有物理单位；所有量均为无量纲。",
            "solution": "所述问题需要进行验证。\n\n**第一步：提取已知条件**\n- **方程：**\n    1. 守恒形式：$u_t + (\\frac{u^2}{2})_x = 0$。\n    2. 非守恒形式：$u_t + u\\,u_x = 0$。\n- **域：** 周期性，$[0,1)$。\n- **任务 A (守恒格式)：**\n    - 有限体积更新：$u_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+\\tfrac{1}{2}}^n - F_{i-\\tfrac{1}{2}}^n\\right)$。\n    - Rusanov 数值通量：$F_{i+\\tfrac{1}{2}}^n = \\tfrac{1}{2}\\left(f(u_i^n) + f(u_{i+1}^n)\\right) - \\tfrac{1}{2}\\, a_{i+\\tfrac{1}{2}}^n \\left(u_{i+1}^n - u_i^n\\right)$，其中 $f(u) = \\tfrac{u^2}{2}$ 且 $a_{i+\\tfrac{1}{2}}^n = \\max\\left(\\lvert u_i^n\\rvert, \\lvert u_{i+1}^n\\rvert\\right)$。\n    - 离散质量：$M^n = \\sum_{i=0}^{N-1} u_i^n \\,\\Delta x$。\n    - 目标：证明 $M^{n+1} = M^n$。\n- **任务 B (非守恒格式)：**\n    - 离散化：$u_i^{n+1} = u_i^n - \\Delta t\\,u_i^n\\,\\frac{u_{i+1}^n - u_i^n}{\\Delta x}$，使用周期性索引 $u_N^n \\equiv u_0^n$。\n    - 目标：证明通常情况下 $M^{n+1} \\neq M^n$。\n- **任务 C (实现)：**\n    - 网格：均匀网格，含 $N$ 个单元，中心位于 $x_i = \\left(i + \\tfrac{1}{2}\\right)\\Delta x$，其中 $\\Delta x = 1/N$。\n    - 时间步长：$\\Delta t = \\text{CFL}\\cdot \\frac{\\Delta x}{\\max_i \\lvert u_i^n\\rvert + 10^{-12}}$。\n    - 最终时间：$T$。\n- **测试组：**\n    - 测试 $1$：守恒格式，$N=200$，$\\text{CFL}=0.9$，$T=0.1$，$u(x,0) = 0.5 + 0.5\\sin(2\\pi x)$。\n    - 测试 $2$：非守恒格式，$N=200$，$\\text{CFL}=0.4$，$T=0.1$，$u(x,0) = 0.5 + 0.5\\sin(2\\pi x)$。\n    - 测试 $3$：非守恒格式，$N=200$，$\\text{CFL}=0.4$，$T=0.1$，$u(x,0) = \\sin(2\\pi x)$。\n- **输出：** 每个测试的质量差 $\\Delta M = M^{\\text{final}} - M^{\\text{initial}}$。\n\n**第二步：使用提取的已知条件进行验证**\n该问题定义明确，科学上合理且客观。它涉及守恒律数值方法的基本概念，特别是伯格斯方程的守恒与非守恒离散化之间的区别。分析推导和数值实现所需的所有参数和条件都已提供。该问题是计算数学和工程领域的一个标准练习。\n\n**第三步：结论与行动**\n该问题是有效的。将提供严谨的解答。\n\n---\n\n**A) 守恒格式的质量守恒证明**\n\n在时间步 $n+1$ 的总离散质量定义为\n$$\nM^{n+1} = \\sum_{i=0}^{N-1} u_i^{n+1} \\Delta x.\n$$\n代入 $u_i^{n+1}$ 的有限体积更新法则：\n$$\nM^{n+1} = \\sum_{i=0}^{N-1} \\left[ u_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+\\tfrac{1}{2}}^n - F_{i-\\tfrac{1}{2}}^n\\right) \\right] \\Delta x.\n$$\n分配求和项和 $\\Delta x$ 项：\n$$\nM^{n+1} = \\sum_{i=0}^{N-1} u_i^n \\Delta x - \\Delta t \\sum_{i=0}^{N-1} \\left(F_{i+\\tfrac{1}{2}}^n - F_{i-\\tfrac{1}{2}}^n\\right).\n$$\n第一项是时间步 $n$ 的总质量 $M^n$。方程变为：\n$$\nM^{n+1} = M^n - \\Delta t \\sum_{i=0}^{N-1} \\left(F_{i+\\tfrac{1}{2}}^n - F_{i-\\tfrac{1}{2}}^n\\right).\n$$\n为证明守恒，我们必须证明求和项为零。该和是一个域上散度积分的离散模拟。让我们展开这个和：\n$$\n\\sum_{i=0}^{N-1} \\left(F_{i+\\tfrac{1}{2}}^n - F_{i-\\tfrac{1}{2}}^n\\right) = \\left(F_{\\tfrac{1}{2}}^n - F_{-\\tfrac{1}{2}}^n\\right) + \\left(F_{\\tfrac{3}{2}}^n - F_{\\tfrac{1}{2}}^n\\right) + \\left(F_{\\tfrac{5}{2}}^n - F_{\\tfrac{3}{2}}^n\\right) + \\dots + \\left(F_{N-\\tfrac{1}{2}}^n - F_{N-\\tfrac{3}{2}}^n\\right).\n$$\n这是一个伸缩求和。各项成对抵消：来自单元 $i$ 的正项 $F_{i+\\tfrac{1}{2}}^n$ 与来自单元 $j=i+1$ 的负项 $F_{j-\\tfrac{1}{2}}^n$ 抵消。让我们将其形式化。设数值通量函数表示为 $\\mathcal{F}(u_L, u_R)$，使得 $F_{i+\\tfrac{1}{2}}^n = \\mathcal{F}(u_i^n, u_{i+1}^n)$。对所有单元 $i = 0, \\dots, N-1$ 的求和为：\n$$\n\\sum_{i=0}^{N-1} \\left( \\mathcal{F}(u_i^n, u_{i+1}^n) - \\mathcal{F}(u_{i-1}^n, u_i^n) \\right).\n$$\n由于周期性边界条件，网格索引在模 $N$ 意义下解释。具体来说，$u_{N}^n = u_0^n$ 且 $u_{-1}^n = u_{N-1}^n$。\n让我们通过重新索引来检验这个和。令 $G_i = \\mathcal{F}(u_{i-1}^n, u_i^n)$。这个和是 $\\sum_{i=0}^{N-1} G_{i+1} - \\sum_{i=0}^{N-1} G_i$。\n让我们改变第一个和的索引，令 $j=i+1$。当 $i=0$ 时，$j=1$；当 $i=N-1$ 时，$j=N$。所以得到 $\\sum_{j=1}^{N} G_j$。\n这个和变为 $\\sum_{j=1}^{N} G_j - \\sum_{i=0}^{N-1} G_i = (G_1 + \\dots + G_{N-1} + G_N) - (G_0 + G_1 + \\dots + G_{N-1}) = G_N - G_0$。\n根据定义，$G_N = \\mathcal{F}(u_{N-1}^n, u_N^n)$ 且 $G_0 = \\mathcal{F}(u_{-1}^n, u_0^n)$。\n使用周期性条件，$u_N^n = u_0^n$ 且 $u_{-1}^n = u_{N-1}^n$。\n因此，$G_N = \\mathcal{F}(u_{N-1}^n, u_0^n)$ 且 $G_0 = \\mathcal{F}(u_{N-1}^n, u_0^n)$。\n于是，$G_N - G_0 = 0$。\n在周期性域上，通量差分的和恒为零。这是离散环面上离散散度定理的一种体现。\n因此，\n$$\nM^{n+1} = M^n - \\Delta t \\cdot 0 = M^n.\n$$\n总离散质量在每个时间步都精确守恒，这与一致且守恒的数值通量 $\\mathcal{F}$ 的具体形式无关。证明完毕。\n\n**B) 非守恒格式的质量守恒分析**\n\n非守恒格式由以下更新法则给出：\n$$\nu_i^{n+1} = u_i^n - \\Delta t\\,u_i^n\\,\\frac{u_{i+1}^n - u_i^n}{\\Delta x}.\n$$\n从时间步 $n$ 到 $n+1$ 的总离散质量变化为\n$$\nM^{n+1} - M^n = \\sum_{i=0}^{N-1} \\left(u_i^{n+1} - u_i^n\\right) \\Delta x.\n$$\n从更新法则中代入 $u_i^{n+1} - u_i^n$ 的表达式：\n$$\nM^{n+1} - M^n = \\sum_{i=0}^{N-1} \\left( -\\Delta t\\,u_i^n\\,\\frac{u_{i+1}^n - u_i^n}{\\Delta x} \\right) \\Delta x.\n$$\n$\\Delta x$ 项相互抵消：\n$$\nM^{n+1} - M^n = -\\Delta t \\sum_{i=0}^{N-1} u_i^n \\left(u_{i+1}^n - u_i^n\\right).\n$$\n展开求和号内的乘积：\n$$\nM^{n+1} - M^n = -\\Delta t \\sum_{i=0}^{N-1} \\left( u_i^n u_{i+1}^n - (u_i^n)^2 \\right) = \\Delta t \\left( \\sum_{i=0}^{N-1} (u_i^n)^2 - \\sum_{i=0}^{N-1} u_i^n u_{i+1}^n \\right).\n$$\n由于周期性边界条件，索引 $i+1$ 在模 $N$ 意义下取值。要使质量守恒，括号中的项必须为零。\n$$\n\\sum_{i=0}^{N-1} (u_i^n)^2 - \\sum_{i=0}^{N-1} u_i^n u_{i+1}^n = 0.\n$$\n对于一般的场数据 $u_i^n$，此条件不满足。考虑一个 $N=2$ 的简单情况。该条件变为：\n$$\n(u_0^n)^2 + (u_1^n)^2 - (u_0^n u_1^n + u_1^n u_0^n) = (u_0^n-u_1^n)^2 = 0,\n$$\n这要求 $u_0^n=u_1^n$。对于一个值不全相等的非平凡场，例如 $u_0^n=1$ 和 $u_1^n=2$，表达式为 $(1-2)^2=1 \\neq 0$。质量不守恒。\n连续方程 $u_t + (u^2/2)_x = 0$ 和 $u_t + u u_x = 0$ 的代数等价性依赖于链式法则，而链式法则仅对光滑解有效。非守恒形式的离散化不会继承原始积分定律的守恒性质，并且在出现不连续性时无法捕捉正确的物理现象（例如，激波速度）。此推导展示了在离散层面上的这种失效。\n\n**C) 数值实现**\n\n该实现将包含两个主要函数：一个用于守恒的有限体积格式，另一个用于非守恒的有限差分格式。两者都将使用向前欧拉时间步进方法，并根据 CFL 条件动态确定时间步长。\n\n- **网格与状态：** 使用 $[0, 1)$ 上的均匀网格，包含 $N$ 个单元。状态向量 `u` 存储单元平均值 $u_i$。周期性边界条件通过数组移位操作（例如 `numpy.roll`）来处理。\n- **守恒格式：** 更新需要在每个单元界面处计算 Rusanov 通量 $F_{i+\\frac{1}{2}}$。通过创建状态向量 `u` 的移位版本来表示 $u_{i+1}$，从而实现向量化。所有界面的通量被同时计算。$u_i$ 的更新涉及其左右边界的通量差 $F_{i+\\frac{1}{2}} - F_{i-\\frac{1}{2}}$。这同样通过计算通量向量 `F` 及其移位版本 `numpy.roll(F, 1)` 来实现向量化。\n- **非守恒格式：** 更新更简单。空间导数项 $u_x$ 通过前向差分 $\\frac{u_{i+1}-u_i}{\\Delta x}$ 来近似。使用 `numpy.roll` 获取 $u_{i+1}$ 的值来实现向量化。\n- **时间循环：** 对于每个测试用例，系统使用给定的初始条件进行初始化，并从 $t=0$ 演化到最终时间 $T$。在每一步中，找到最大波速 $\\max_i|u_i^n|$ 以根据 CFL 准则计算一个稳定的 $\\Delta t$，同时确保时间步长不超过到达 $T$ 所需的剩余时间。\n- **质量计算：** 初始质量 $M^{\\text{initial}}$ 在时间循环开始前计算。最终质量 $M^{\\text{final}}$ 在循环结束后计算。然后报告每个测试的质量差 $\\Delta M = M^{\\text{final}} - M^{\\text{initial}}$。对于测试 1，预期该值接近机器精度，从而证实分析证明。对于测试 2 和 3，预期值为非零。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_conservative(N, CFL, T, u0_func):\n    \"\"\"\n    Solves the Burgers' equation using the conservative finite volume scheme.\n    \"\"\"\n    dx = 1.0 / N\n    x = (np.arange(N) + 0.5) * dx\n    u = u0_func(x)\n\n    M_initial = np.sum(u) * dx\n    \n    t = 0.0\n    while t  T:\n        max_abs_u = np.max(np.abs(u))\n        dt = CFL * dx / (max_abs_u + 1e-12)\n        if t + dt > T:\n            dt = T - t\n        \n        # Periodic boundary conditions via np.roll\n        u_right = np.roll(u, -1) # u_{i+1}\n\n        # Physical flux f(u) = u^2 / 2\n        f_u = 0.5 * u**2\n        f_u_right = 0.5 * u_right**2\n\n        # Rusanov flux (Local Lax-Friedrichs)\n        # a_{i+1/2} = max(|u_i|, |u_{i+1}|)\n        a = np.maximum(np.abs(u), np.abs(u_right))\n        \n        # F_{i+1/2}\n        flux = 0.5 * (f_u + f_u_right) - 0.5 * a * (u_right - u)\n        \n        # F_{i-1/2} via roll\n        flux_left = np.roll(flux, 1)\n\n        # Update u\n        u = u - (dt / dx) * (flux - flux_left)\n        \n        t += dt\n    \n    M_final = np.sum(u) * dx\n    return M_final - M_initial\n\ndef run_nonconservative(N, CFL, T, u0_func):\n    \"\"\"\n    Solves the Burgers' equation using the nonconservative finite difference scheme.\n    \"\"\"\n    dx = 1.0 / N\n    x = (np.arange(N) + 0.5) * dx\n    u = u0_func(x)\n\n    M_initial = np.sum(u) * dx\n\n    t = 0.0\n    while t  T:\n        max_abs_u = np.max(np.abs(u))\n        dt = CFL * dx / (max_abs_u + 1e-12)\n        if t + dt > T:\n            dt = T - t\n        \n        # Periodic boundary conditions for u_{i+1}\n        u_right = np.roll(u, -1)\n\n        # Forward difference for u_x\n        ux = (u_right - u) / dx\n\n        # Update u\n        u = u - dt * u * ux\n        \n        t += dt\n\n    M_final = np.sum(u) * dx\n    return M_final - M_initial\n\n\ndef solve():\n    \"\"\"\n    Executes the test suite and prints the results.\n    \"\"\"\n    test_cases = [\n        {\n            \"scheme\": \"conservative\",\n            \"N\": 200, \"CFL\": 0.9, \"T\": 0.1,\n            \"u0_func\": lambda x: 0.5 + 0.5 * np.sin(2 * np.pi * x)\n        },\n        {\n            \"scheme\": \"nonconservative\",\n            \"N\": 200, \"CFL\": 0.4, \"T\": 0.1,\n            \"u0_func\": lambda x: 0.5 + 0.5 * np.sin(2 * np.pi * x)\n        },\n        {\n            \"scheme\": \"nonconservative\",\n            \"N\": 200, \"CFL\": 0.4, \"T\": 0.1,\n            \"u0_func\": lambda x: np.sin(2 * np.pi * x)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        if case[\"scheme\"] == \"conservative\":\n            delta_M = run_conservative(case[\"N\"], case[\"CFL\"], case[\"T\"], case[\"u0_func\"])\n        else:\n            delta_M = run_nonconservative(case[\"N\"], case[\"CFL\"], case[\"T\"], case[\"u0_func\"])\n        results.append(delta_M)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "我们已经看到非守恒格式无法保持质量守恒，那么其物理后果是什么呢？本练习将通过模拟激波（非线性双曲方程的一个关键特征）来解决这个问题。你将实现一个守恒格式和一个非守恒格式，并观察到后者虽然看起来稳定，但其传播激波的速度是完全错误的，与由 Rankine–Hugoniot 条件预测的解析解相去甚远 。",
            "id": "2379415",
            "problem": "考虑一维域上的标量守恒律及其非守恒对应形式：\n1) 守恒形式：$\\partial_t u + \\partial_x f(u) = 0$，其中 $f(u) = \\tfrac{1}{2} u^2$。\n2) 非守恒（平流）形式：$\\partial_t u + u \\, \\partial_x u = 0$。\n\n在空间区间 $[0,L]$ 上（其中 $L = 6$），给定位于 $x = x_0$（其中 $x_0 = 1$）的单个间断点的分段常数初始数据。令左、右常数状态分别为 $u_L$ 和 $u_R$，因此\n$u(x,0) = \\begin{cases}\nu_L,  x  x_0,\\\\\nu_R,  x \\ge x_0.\n\\end{cases}$\n对所有 $t \\ge 0$ 施加固定的边界状态（随时间变化的狄利克雷条件）$u(0,t) = u_L$ 和 $u(L,t) = u_R$。\n\n对于 $u_L  u_R$ 且 $u_L \\ge 0, u_R \\ge 0$ 的守恒律问题，唯一的熵解是一个激波，其传播速度为 Rankine–Hugoniot 速度 $s = \\dfrac{f(u_L) - f(u_R)}{u_L - u_R} = \\dfrac{u_L + u_R}{2}$，因此精确的激波位置是 $x_{\\text{exact}}(t) = x_0 + s \\, t$。\n\n任务。在具有 $N$ 个单元（其中 $N = 1200$）、网格间距 $\\Delta x = L/N$ 的均匀网格上，实现两种显式、时间一阶的有限差分或有限体积半离散近似。时间步长 $\\Delta t$ 需动态选择，以确保每一步都满足严格小于 $1$ 的 Courant–Friedrichs–Lewy (CFL) 数。在每一步中，两种近似使用相同的 $\\Delta t$。\n- 一种近似必须是针对守恒形式 $\\partial_t u + \\partial_x f(u) = 0$ 的守恒格式，这意味着其在每个时间步的更新可以写成伸缩的通量差分形式，在没有边界通量变化的情况下，该形式能保持 $u$ 的离散总积分。\n- 另一种近似必须以非守恒的方式离散化非守恒形式 $\\partial_t u + u \\, \\partial_x u = 0$，这意味着它不能写成伸缩的通量差分形式，因此通常不保持 $u$ 的离散总积分。\n\n在同一网格上，将两种近似从 $t=0$ 演化到 $t=T$。在最终时刻 $t = T$ 时，从每个数值解中近似激波位置 $x_{\\text{num}}$，其定义为 $u(x,T)$ 等于中点值 $\\tfrac{u_L + u_R}{2}$ 的唯一位置，该位置通过跨越此中点的相邻网格节点之间的线性插值确定；如果没有发生此类跨越，则取 $|u(x,T) - \\tfrac{u_L + u_R}{2}|$ 最小的网格位置。\n\n对于下方的每个测试用例，计算非守恒近似的激波位置相对于精确激波位置的有符号误差，定义为 $E_{\\text{nc}} = x_{\\text{nc}}(T) - x_{\\text{exact}}(T)$，以与 $x$ 相同的空间单位表示（此处为无量纲）。正的 $E_{\\text{nc}}$ 表示非守恒近似的激波位于精确位置的右侧；负值表示位于左侧。使用 $L = 6$，$x_0 = 1$，$N = 1200$，以及固定的 Courant–Friedrichs–Lewy (CFL) 数 $0.45$ 进行时间步进。在所有情况下，均假设 $u_L \\ge 0$ 且 $u_R \\ge 0$。\n\n测试套件。使用以下参数集，每组为三元组 $(u_L, u_R, T)$：\n- 用例 1：$(2.0, 0.0, 0.5)$。\n- 用例 2：$(2.0, 0.0, 2.0)$。\n- 用例 3：$(2.0, 0.0, 4.0)$。\n- 用例 4：$(1.5, 0.2, 4.0)$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按上述用例的顺序排列结果：\n$[E_{\\text{nc}}^{(1)}, E_{\\text{nc}}^{(2)}, E_{\\text{nc}}^{(3)}, E_{\\text{nc}}^{(4)}]$。",
            "solution": "所述问题已通过验证。\n\n**第 1 步：提取已知条件**\n- 控制方程：\n  1. 守恒形式：$\\partial_t u + \\partial_x f(u) = 0$，通量函数为 $f(u) = \\tfrac{1}{2} u^2$。\n  2. 非守恒形式：$\\partial_t u + u \\, \\partial_x u = 0$。\n- 域和参数：空间区间 $x \\in [0,L]$，其中 $L=6$；网格单元数 $N=1200$；网格间距 $\\Delta x = L/N$。\n- 初始条件 (IC)：一个在 $x_0=1$ 处有间断点的黎曼问题。\n  $u(x,0) = \\begin{cases} u_L,  x  x_0 \\\\ u_R,  x \\ge x_0 \\end{cases}$\n- 边界条件 (BCs)：对于 $t \\ge 0$，$u(0,t) = u_L$ 和 $u(L,t) = u_R$。\n- 解的性质：该问题考虑了 $u_L  u_R$ 和 $u_L, u_R \\ge 0$ 的情况，其熵解为激波。\n- 精确激波传播：Rankine-Hugoniot 速度 $s = \\dfrac{f(u_L) - f(u_R)}{u_L - u_R} = \\dfrac{u_L + u_R}{2}$。精确位置是 $x_{\\text{exact}}(t) = x_0 + s \\, t$。\n- 数值方法要求：\n  - 两种显式、时间一阶的半离散近似。一种必须是守恒的，另一种是非守恒的。\n  - 在每一步使用 Courant–Friedrichs–Lewy (CFL) 数 $0.45$ 计算一个共享的动态时间步长 $\\Delta t$。\n- 任务：\n  - 将两种数值近似从 $t=0$ 演化到最终时间 $t=T$。\n  - 在 $t=T$ 时，从每个解中确定数值激波位置 $x_{\\text{num}}$。该位置定义为 $u(x,T) = \\tfrac{u_L + u_R}{2}$ 的位置，通过线性插值找到。如果没有网格单元跨越此值，则该位置是 $|u(x,T) - \\tfrac{u_L + u_R}{2}|$ 最小的网格点。\n  - 计算非守恒格式的有符号误差：$E_{\\text{nc}} = x_{\\text{nc}}(T) - x_{\\text{exact}}(T)$。\n- 测试套件：为四个不同用例提供了参数 $(u_L, u_R, T)$。\n\n**第 2 步：问题陈述的验证**\n根据科学和数学原理对问题进行审查。\n- **科学依据**：该问题涉及无粘性伯格斯方程，这是研究双曲偏微分方程和流体动力学的一个基础且重要的模型方程。守恒和非守恒数值格式之间的区别，以及它们对于不连续解（激波）的不同收敛特性，是计算物理学的基石。该问题在科学上是合理的。\n- **适定性**：标量双曲守恒律的初边值问题是适定的。对于指定的条件 $u_L  u_R$ 和凸通量 $f(u) = \\frac{1}{2}u^2$，解析解是一个唯一的、稳定的激波。数值任务有明确的定义和所有必要的参数，使其没有歧义。\n- **客观性**：该问题使用精确、客观的数学语言进行阐述，不含任何主观或推测性内容。\n\n**第 3 步：结论**\n该问题有效。这是一个明确定义的数值分析练习，它展示了一个关键原理：对于包含激波的问题，非守恒数值格式无法收敛到正确的弱解，具体表现为以不正确的速度传播间断点。我们继续进行求解。\n\n**基于原理的求解**\n\n目标是比较通过守恒格式和非守恒格式获得的伯格斯方程数值解中的激波传播。这证明了守恒形式对于捕捉正确的激波物理至关重要。\n\n**1. 域的离散化**\n空间域 $[0, L]$ 被离散化为 $N$ 个均匀单元。我们使用单元中心的有限体积/差分方法。单元的索引为 $i = 0, 1, \\dots, N-1$。单元 $i$ 的中心位于 $x_i = (i + 0.5)\\Delta x$，其中 $\\Delta x = L/N$。离散解变量 $U_i(t)$ 代表 $u(x,t)$ 在单元 $i$ 上的单元平均值。\n\n**2. 守恒数值格式**\n守恒形式 $\\partial_t u + \\partial_x f(u) = 0$ 是处理允许激波解问题的正确起点。在控制体积（单元 $i$）上从 $x_{i-1/2}$ 到 $x_{i+1/2}$ 进行积分，得到：\n$$ \\frac{d}{dt} \\int_{x_{i-1/2}}^{x_{i+1/2}} u(x,t) \\,dx + f(u(x_{i+1/2},t)) - f(u(x_{i-1/2},t)) = 0 $$\n定义单元平均值 $U_i(t) = \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} u(x,t) \\,dx$ 和单元界面处的数值通量 $F_{i\\pm1/2}$，我们得到半离散有限体积形式：\n$$ \\frac{d U_i}{dt} = -\\frac{1}{\\Delta x} (F_{i+1/2} - F_{i-1/2}) $$\n这种形式显然是守恒的：当对所有单元求和时，内部通量以伸缩方式抵消，确保总量 $\\sum_i U_i \\Delta x$ 仅因边界通量而改变。\n\n对于一阶格式，我们使用迎风通量。特征速度为 $f'(u) = u$。给定 $u_L, u_R \\ge 0$，解 $u(x,t)$ 保持非负，信息从左向右传播。因此，界面 $i+1/2$ 处的迎风通量由其左侧的状态 $U_i$ 决定。\n$$ F_{i+1/2} = f(U_i) = \\frac{1}{2} U_i^2 $$\n将其代入半离散形式得到：\n$$ \\frac{d U_i}{dt} = -\\frac{1}{\\Delta x} (f(U_i) - f(U_{i-1})) $$\n应用显式欧拉时间积分（$U_i^{n+1} = U_i^n + \\Delta t \\frac{d U_i}{dt}|_n$），得到全离散守恒格式：\n$$ U_{i,\\text{c}}^{n+1} = U_{i,\\text{c}}^n - \\frac{\\Delta t}{\\Delta x} \\left( \\frac{1}{2}(U_{i,\\text{c}}^n)^2 - \\frac{1}{2}(U_{i-1,\\text{c}}^n)^2 \\right) $$\n\n**3. 非守恒数值格式**\n非守恒形式 $\\partial_t u + u \\partial_x u = 0$ 在数学上对于光滑解与守恒形式等价，但这种等价性在间断点处失效。基于此形式的数值格式不能保证满足积分守恒性质，通常会计算出不正确的激波速度。\n\n我们直接离散化这个方程。对时间使用显式欧拉法，对空间导数 $\\partial_x u$ 使用一阶迎风（后向）差分以尊重信息流动的方向：\n$$ \\frac{U_i^{n+1} - U_i^n}{\\Delta t} + U_i^n \\frac{U_i^n - U_{i-1}^n}{\\Delta x} = 0 $$\n这给出了全离散非守恒格式：\n$$ U_{i,\\text{nc}}^{n+1} = U_{i,\\text{nc}}^n - \\frac{\\Delta t}{\\Delta x} U_{i,\\text{nc}}^n (U_{i,\\text{nc}}^n - U_{i-1,\\text{nc}}^n) $$\n这个更新规则不能写成守恒所需的通量差分形式。\n\n**4. 边界和初始条件**\n- **初始条件：** 分段常数初始数据通过设置 $U_i(0) = u_L$（对于单元中心 $x_i  x_0$）和 $U_i(0) = u_R$（对于 $x_i \\ge x_0$）映射到网格上。对于 $x_0 = 1$ 和 $N=1200$，间断点位于单元 $i=199$ 和 $i=200$ 之间。\n- **边界条件：** 对于 $u  0$，$x=0$ 处的边界是流入边界，而 $x=L$ 是流出边界。\n  - 在流入处 ($x=0$)，状态由外部条件 $u(0,t)=u_L$ 决定。这通过在索引 $i=-1$ 处使用一个值为 $U_{-1}^n = u_L$ 的虚拟单元来处理，对两种格式都适用。\n  - 在流出处 ($x=L$)，状态由域内的动力学决定。无需施加边界条件。我们选择的单边迎风格式自然地处理了这一点，因为它不需要来自最右侧单元之外的信息。因此，给定条件 $u(L,t)=u_R$ 是对预期流出状态的观察，而不是针对此流动方向施加的约束。\n\n**5. 时间步进和稳定性**\n显式前向欧拉法要求对时间步长加以限制以保证稳定性，这由 Courant–Friedrichs–Lewy (CFL) 条件控制。时间步长 $\\Delta t$ 必须满足：\n$$ \\Delta t \\le \\text{CFL} \\frac{\\Delta x}{\\max_i |u_i|} $$\n问题指定了使用 $\\text{CFL} = 0.45$ 的动态 $\\Delta t$。在每个时间步 $n$，我们计算全局最大速度 $u_{\\max}^n = \\max(\\max_i |U_{i,\\text{c}}^n|, \\max_i |U_{i,\\text{nc}}^n|)$，该速度跨越两种解，以确保两种格式在共享 $\\Delta t$ 的情况下都保持稳定。然后时间步长为 $\\Delta t^n = 0.45 \\cdot \\Delta x / u_{\\max}^n$。模拟时间增量推进，直到达到最终时间 $T$。\n\n**6. 激波位置定位和误差计算**\n在最终时间 $T$，找到非守恒解的数值激波位置 $x_{\\text{nc}}$。我们搜索跨越中点值 $u_{\\text{mid}} = (u_L+u_R)/2$ 的相邻网格点 $(x_i, U_{i,\\text{nc}})$ 和 $(x_{i+1}, U_{i+1,\\text{nc}})$。如果找到，位置通过线性插值确定：\n$$ x_{\\text{nc}} = x_i + \\Delta x \\frac{u_{\\text{mid}} - U_{i,\\text{nc}}}{U_{i+1,\\text{nc}} - U_{i,\\text{nc}}} $$\n如果没有这样的点对存在，$x_{\\text{nc}}$ 取为网格位置 $x_j$，在该处 $|U_{j,\\text{nc}} - u_{\\text{mid}}|$ 最小。精确激波位置计算为 $x_{\\text{exact}}(T) = x_0 + sT$。所需的误差为 $E_{\\text{nc}} = x_{\\text{nc}}(T) - x_{\\text{exact}}(T)$。\n\n此过程系统地应用于所有测试用例，以量化非守恒离散化产生的激波速度误差。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_burgers(u_L, u_R, T, L, N, cfl, x0):\n    \"\"\"\n    Solves Burgers' equation using conservative and non-conservative schemes\n    and returns the final state of the non-conservative solution.\n    \"\"\"\n    dx = L / N\n    x = np.linspace(dx / 2, L - dx / 2, N)\n\n    # Initial conditions\n    u_c = np.full_like(x, u_R)\n    u_nc = np.full_like(x, u_R)\n    \n    # Locate the discontinuity index\n    # Based on x_i  x0 ==> (i+0.5)*dx  x0 ==> i  x0/dx - 0.5\n    split_idx_float = x0 / dx - 0.5\n    split_idx = int(np.floor(split_idx_float)) + 1\n    \n    u_c[:split_idx] = u_L\n    u_nc[:split_idx] = u_L\n\n    t = 0.0\n    while t  T:\n        # Determine shared dynamic time step\n        u_max_c = np.max(np.abs(u_c))\n        u_max_nc = np.max(np.abs(u_nc))\n        u_max = max(u_max_c, u_max_nc, 1e-9) # Avoid division by zero\n        \n        dt = cfl * dx / u_max\n        if t + dt > T:\n            dt = T - t\n        \n        # --- Conservative Scheme (Upwind Finite Volume) ---\n        # Extend solution array with ghost cell for inflow BC\n        u_c_ghost = np.concatenate(([u_L], u_c))\n        \n        # Flux at cell interfaces (f(u) = 0.5*u^2). Upwind implies f(u_left).\n        # We need N fluxes for N cells updates\n        # The flux at the right of cell i is f(u_i)\n        # The flux at the left of cell i is f(u_{i-1})\n        # F_{i+1/2} corresponds to f(U_i), so the flux vector would be f(U_i) for i in 0..N-1\n        # The update is U_i^{n+1} = U_i^n - dt/dx * (F_{i+1/2} - F_{i-1/2})\n        #                         = U_i^n - dt/dx * (f(U_i) - f(U_{i-1}))\n        # Vectorized implementation:\n        flux_c = 0.5 * u_c_ghost**2\n        flux_diff_c = flux_c[1:] - flux_c[:-1]\n        u_c = u_c - (dt / dx) * flux_diff_c\n\n        # --- Non-Conservative Scheme (Upwind Finite Difference) ---\n        u_nc_ghost = np.concatenate(([u_L], u_nc))\n        \n        # Advective term: u * (u_i - u_{i-1})/dx\n        adv_term_nc = u_nc_ghost[1:] * (u_nc_ghost[1:] - u_nc_ghost[:-1])\n        u_nc = u_nc - (dt / dx) * adv_term_nc\n        \n        t += dt\n\n    return u_nc, x\n\ndef find_shock_pos(u_final, x_grid, u_L, u_R):\n    \"\"\"\n    Finds the numerical shock position by interpolation.\n    \"\"\"\n    u_mid = (u_L + u_R) / 2.0\n    \n    # Search for straddling grid cells\n    for i in range(len(u_final) - 1):\n        # (u[i] - u_mid) and (u[i+1] - u_mid) have different signs\n        if (u_final[i] - u_mid) * (u_final[i+1] - u_mid) = 0:\n            u_i = u_final[i]\n            u_i1 = u_final[i+1]\n            x_i = x_grid[i]\n            dx = x_grid[1] - x_grid[0]\n            \n            # Avoid division by zero if u_i1 == u_i\n            if abs(u_i1 - u_i)  1e-9:\n                return x_i + dx/2.0\n                \n            # Linear interpolation\n            return x_i + dx * (u_mid - u_i) / (u_i1 - u_i)\n\n    # If no straddling found, find closest point\n    min_dist_idx = np.argmin(np.abs(u_final - u_mid))\n    return x_grid[min_dist_idx]\n    \ndef solve():\n    \"\"\"\n    Main function to run test cases and produce the final output.\n    \"\"\"\n    # Problem definition\n    L = 6.0\n    x0 = 1.0\n    N = 1200\n    CFL = 0.45\n    \n    test_cases = [\n        (2.0, 0.0, 0.5),  # Case 1\n        (2.0, 0.0, 2.0),  # Case 2\n        (2.0, 0.0, 4.0),  # Case 3\n        (1.5, 0.2, 4.0),  # Case 4\n    ]\n\n    results = []\n    for u_L, u_R, T in test_cases:\n        # Calculate exact shock position\n        s_exact = (u_L + u_R) / 2.0\n        x_exact = x0 + s_exact * T\n        \n        # Run simulation to get final state\n        u_nc_final, x_grid = solve_burgers(u_L, u_R, T, L, N, CFL, x0)\n        \n        # Find numerical shock position for non-conservative scheme\n        x_nc = find_shock_pos(u_nc_final, x_grid, u_L, u_R)\n        \n        # Compute the error\n        error_nc = x_nc - x_exact\n        results.append(error_nc)\n\n    # Format and print the final output\n    print(f\"[{','.join(f'{r:.12f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一个看起来像是守恒有限体积法的格式，是否仍然可能失效？这最后一个练习将探讨这个微妙但至关重要的问题。我们将构造一个具有通量差分形式，但其数值通量与守恒律的物理通量*不一致*的格式。通过将此格式与一个真正的守恒方法进行比较，你将诊断出这种不一致性如何导致激波速度和解质量的误差，从而加深理解——真正的关键在于数值通量设计的细节之中 。",
            "id": "2379435",
            "problem": "您需要研究在有限体积离散化中违反守恒形式的影响，方法是针对一个标量守恒律，比较一个正确的守恒数值通量和一个故意设置的不正确的非守恒数值通量。考虑一维标量守恒律\n$$\nu_t + f(u)_x = 0 \\quad \\text{on} \\quad [x_L,x_R] \\times [0,T],\n$$\n其通量为\n$$\nf(u) = \\tfrac{1}{2} u^2,\n$$\n初始黎曼数据为\n$$\nu(x,0) =\n\\begin{cases}\nu_L,  x  x_0,\\\\\nu_R,  x \\ge x_0,\n\\end{cases}\n$$\n在端点处为出流边界条件。通量的雅可比矩阵为\n$$\nA(u) = f'(u) = u.\n$$\n使用一个均匀网格，包含 $N$ 个宽度为 $\\Delta x = (x_R - x_L)/N$ 的控制体，以及一个满足 Courant-Friedrichs-Lewy (CFL) 条件（CFL 数 $c \\in (0,1)$）的时间步长 $\\Delta t$。\n\n为网格单元 $[x_{i-1/2},x_{i+1/2}]$ 上的单元平均值 $u_i(t)$ 定义两种半离散有限体积更新格式，采用标准的通量差分形式：\n$$\n\\frac{d u_i}{d t} = -\\frac{1}{\\Delta x}\\left( \\hat{F}_{i+1/2} - \\hat{F}_{i-1/2} \\right).\n$$\n\n对于守恒离散化，使用局部 Lax-Friedrichs（也称为 Rusanov）数值通量\n$$\n\\hat{F}^{\\text{cons}}(u_L,u_R) = \\tfrac{1}{2}\\big(f(u_L)+f(u_R)\\big) - \\tfrac{1}{2} a(u_L,u_R) (u_R - u_L),\n$$\n其中\n$$\na(u_L,u_R) = \\max\\big(|f'(u_L)|, |f'(u_R)|\\big) = \\max\\big(|u_L|,|u_R|\\big).\n$$\n\n对于故意设置的非守恒离散化，将中心通量项替换为一个由 $A(u)$ 的平均值和 $u$ 的平均值构成的非守恒近似：\n$$\n\\hat{F}^{\\text{noncons}}(u_L,u_R) = \\left(\\tfrac{1}{2}\\big(A(u_L)+A(u_R)\\big)\\right)\\left(\\tfrac{1}{2}\\big(u_L+u_R\\big)\\right) - \\tfrac{1}{2} a(u_L,u_R) (u_R - u_L),\n$$\n其中耗散项 $a(u_L,u_R)$ 与上述相同。使用前向欧拉法在时间上推进解，时间步长 $\\Delta t$ 在每个时间步均满足 CFL 条件 $\\Delta t \\le c \\, \\Delta x / \\max_i |u_i|$。\n\n对于下面的每个测试用例，在最终时刻 $T$ 计算以下诊断量：\n\n- 对于 $u_L  u_R$ 的激波情况，使用非守恒格式计算观测到的激波速度\n$$\ns_{\\text{obs}} = \\frac{x_{\\text{shock}}(T) - x_0}{T},\n$$\n其中 $x_{\\text{shock}}(T)$ 是 $u$ 穿过中点值 $m = \\tfrac{1}{2}(u_L+u_R)$ 的位置，该位置通过相邻单元中心的线性插值确定。计算该守恒律的精确 Rankine–Hugoniot 激波速度，\n$$\ns_{\\text{exact}} = \\frac{f(u_L)-f(u_R)}{u_L - u_R} = \\tfrac{1}{2}(u_L + u_R),\n$$\n并报告其差值\n$$\nd_s = s_{\\text{obs}} - s_{\\text{exact}}.\n$$\n\n- 对于 $u_L  u_R$ 的稀疏波情况，计算每种格式在时刻 $T$ 相对于 Burgers 稀疏波的精确自相似解\n$$\nu(x,T) =\n\\begin{cases}\nu_L,  x - x_0 \\le u_L T,\\\\\n\\dfrac{x - x_0}{T},  u_L T \\le x - x_0 \\le u_R T,\\\\\nu_R,  x - x_0 \\ge u_R T,\n\\end{cases}\n$$\n的 $L^1$ 误差，并报告 $L^1$ 误差的差值\n$$\nd_{L^1} = \\|u^{\\text{noncons}}(\\cdot,T) - u^{\\text{exact}}(\\cdot,T)\\|_{L^1} - \\|u^{\\text{cons}}(\\cdot,T) - u^{\\text{exact}}(\\cdot,T)\\|_{L^1}.\n$$\n\n- 对于 $u_L = u_R$ 的常数数据情况，报告非守恒解与初始常数值的最大绝对偏差，\n$$\nd_{\\max} = \\max_i \\big| u^{\\text{noncons}}_i(T) - u_L \\big|.\n$$\n\n使用以下参数值，这些参数构成了测试套件：\n\n- 空间域：$[x_L,x_R] = [-1,1]$。\n- 单元数量：$N = 800$。\n- Courant-Friedrichs-Lewy 数：$c = 0.45$。\n- 边界条件：出流。\n- 测试用例 $(u_L,u_R,x_0,T)$:\n  1. $(1.0, 0.0, 0.0, 0.2)$ 激波情况；报告 $d_s$。\n  2. $(0.0, 1.0, 0.0, 0.2)$ 稀疏波情况；报告 $d_{L^1}$。\n  3. $(0.5, 0.5, 0.0, 0.2)$ 常数情况；报告 $d_{\\max}$。\n  4. $(0.2, 0.0, -0.1, 0.3)$ 小振幅激波；报告 $d_s$。\n\n您的程序必须生成单行输出，其中包含一个按测试用例顺序列出的四个结果的列表，格式为方括号内以逗号分隔，例如\n$$\n[\\;r_1,r_2,r_3,r_4\\;],\n$$\n其中每个 $r_i$ 是如上定义的实数。不应打印任何额外的文本或行。输出中的所有数值必须表示为不带单位的普通十进制数。",
            "solution": "该问题要求研究对标量守恒律（具体来说是无粘 Burgers 方程，$u_t + f(u)_x = 0$，其中通量 $f(u) = \\frac{1}{2}u^2$）使用非守恒数值格式的后果。采用有限体积法来比较一个守恒格式（使用局部 Lax-Friedrichs，即 Rusanov 通量）和一个故意设置的非守恒格式。分析是针对激波、稀疏波和常数数据初始条件进行的。\n\n首先，我们建立理论基础。对于守恒律 $\\frac{\\partial u}{\\partial t} + \\frac{\\partial f(u)}{\\partial x} = 0$，在一个控制体 $[x_{i-1/2}, x_{i+1/2}]$ 上积分，可以得到单元平均值 $u_i(t) = \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} u(x,t) dx$ 的精确关系式：\n$$\n\\frac{d u_i}{d t} = -\\frac{1}{\\Delta x}\\left( F(u(x_{i+1/2}, t)) - F(u(x_{i-1/2}, t)) \\right).\n$$\n这里，$F(u(x,t))$ 是在单元界面处求值的物理通量。在数值格式中，这被一个数值通量函数 $\\hat{F}(u_L, u_R)$ 所取代，该函数在给定左侧状态 $u_L$ 和右侧状态 $u_R$ 的情况下近似界面上的通量。于是，半离散格式为：\n$$\n\\frac{d u_i}{d t} = -\\frac{1}{\\Delta x}\\left( \\hat{F}_{i+1/2} - \\hat{F}_{i-1/2} \\right),\n$$\n其中 $\\hat{F}_{i+1/2} = \\hat{F}(u_i, u_{i+1})$。这种形式是内在守恒的；总量 $\\sum_i u_i \\Delta x$ 的变化仅由区域边界上的通量决定。然而，为了使一个格式能够收敛到守恒律的正确弱解，尤其是在存在间断（激波）的情况下，数值通量 $\\hat{F}(u_L, u_R)$ 必须与物理通量 $f(u)$ 相容，即满足 $\\hat{F}(u, u) = f(u)$。\n\n守恒的 Rusanov 通量定义为：\n$$\n\\hat{F}^{\\text{cons}}(u_L,u_R) = \\tfrac{1}{2}\\big(f(u_L)+f(u_R)\\big) - \\tfrac{1}{2} a(u_L,u_R) (u_R - u_L).\n$$\n对于 $u_L=u_R=u$，耗散项消失，我们得到 $\\hat{F}^{\\text{cons}}(u,u) = \\frac{1}{2}(f(u)+f(u)) = f(u)$。因此该通量是相容的。\n\n指定的“非守恒”通量为：\n$$\n\\hat{F}^{\\text{noncons}}(u_L,u_R) = \\left(\\tfrac{1}{2}\\big(A(u_L)+A(u_R)\\big)\\right)\\left(\\tfrac{1}{2}\\big(u_L+u_R\\big)\\right) - \\tfrac{1}{2} a(u_L,u_R) (u_R - u_L).\n$$\n对于 $f(u) = \\frac{1}{2}u^2$，我们有 $A(u) = f'(u) = u$。我们来检查其相容性：\n$$\n\\hat{F}^{\\text{noncons}}(u,u) = \\left(\\tfrac{1}{2}\\big(u+u\\big)\\right)\\left(\\tfrac{1}{2}\\big(u+u\\big)\\right) = u \\cdot u = u^2.\n$$\n物理通量为 $f(u) = \\frac{1}{2}u^2$。由于 $\\hat{F}^{\\text{noncons}}(u,u) = u^2 \\neq f(u)$，该数值通量与原始守恒律不相容。该格式不会收敛到正确的解。相反，它会尝试求解错误的守恒律 $u_t + g(u)_x = 0$，其中有效数值通量为 $g(u) = u^2$。\n\n这种不相容性会带来严重的后果：\n1.  对于激波（$u_L  u_R$），间断的速度必须满足 Rankine-Hugoniot 条件，$s = [f]/[u] = (f(u_L)-f(u_R))/(u_L-u_R)$。我们的守恒格式会近似这个速度。而非守恒格式会近似错误守恒律的激波速度：$s_{\\text{noncons}} = (g(u_L)-g(u_R))/(u_L-u_R) = (u_L^2-u_R^2)/(u_L-u_R) = u_L+u_R$。正确守恒律的精确速度为 $s_{\\text{exact}} = (\\frac{1}{2}u_L^2-\\frac{1}{2}u_R^2)/(u_L-u_R) = \\frac{1}{2}(u_L+u_R)$。因此，不相容格式的数值解预计会表现出一个以错误速度传播的激波，其预测的速度差为 $d_s \\approx s_{\\text{noncons}} - s_{\\text{exact}} = \\frac{1}{2}(u_L+u_R)$。\n\n2.  对于稀疏波（$u_L  u_R$），流动是光滑的，不相容性会引入污染解的误差。$L^1$ 误差的差值 $d_{L^1}$ 将量化非守恒格式与守恒基准相比表现差多少。\n\n3.  对于常数初始数据（$u_L = u_R = u_c$），一个精确的求解器会保持这个状态。然而，非守恒格式可能是不稳定的。微小的数值扰动会被放大，导致伪振荡和对常数状态的偏离。所要求的诊断量 $d_{\\max}$ 将测量这种偏差的幅度。\n\n实现过程如下：在区域 $[x_L, x_R] = [-1, 1]$ 上定义一个包含 $N=800$ 个单元的均匀网格。为每个测试用例设置初始黎曼数据。使用前向欧拉法在时间上推进解。在每个步骤中计算时间步长 $\\Delta t$ 以满足 CFL 条件 $\\Delta t = c \\cdot \\Delta x / \\max_i|u_i|$，其中 $c=0.45$，以确保稳定性。最大波速 $\\max_i|u_i|$ 在整个数值解区域上取值。通过将虚拟单元中的值设置为与相邻内部单元相等来实现出流边界条件。\n\n对于每个测试用例，运行相应的模拟直到最终时刻 $T$。\n-   对于激波情况，运行非守恒模拟。通过搜索解穿过中点值 $m = \\frac{1}{2}(u_L+u_R)$ 的单元界面并应用线性插值，找到激波的最终位置 $x_{\\text{shock}}(T)$。然后计算观测速度 $s_{\\text{obs}}$ 和差异 $d_s = s_{\\text{obs}} - s_{\\text{exact}}$。\n-   对于稀疏波情况，同时运行守恒和非守恒模拟。在时刻 $T$ 时在网格上计算精确的自相似解。每个数值解的 $L^1$ 误差计算如下：$\\|u_{\\text{num}} - u_{\\text{exact}}\\|_{L^1} = \\sum_i |u_{i, \\text{num}} - u_{i, \\text{exact}}| \\Delta x$。最终报告的值是这些误差的差值 $d_{L^1}$。\n-   对于常数数据情况，运行非守恒模拟。在所有单元上计算最终数值解与初始常数值 $u_L$ 之间的最大绝对差，以找到 $d_{\\max}$。\n\n代码对四个指定的测试用例执行此逻辑，并报告所得的诊断量。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of comparing conservative and nonconservative finite volume schemes\n    for the inviscid Burgers' equation.\n    \"\"\"\n\n    test_cases = [\n        {'uL': 1.0, 'uR': 0.0, 'x0': 0.0, 'T': 0.2, 'type': 'shock'},\n        {'uL': 0.0, 'uR': 1.0, 'x0': 0.0, 'T': 0.2, 'type': 'rarefaction'},\n        {'uL': 0.5, 'uR': 0.5, 'x0': 0.0, 'T': 0.2, 'type': 'constant'},\n        {'uL': 0.2, 'uR': 0.0, 'x0': -0.1, 'T': 0.3, 'type': 'shock'},\n    ]\n\n    results = []\n    \n    # Global parameters\n    xL, xR = -1.0, 1.0\n    N = 800\n    cfl = 0.45\n    dx = (xR - xL) / N\n    x = np.linspace(xL + dx / 2.0, xR - dx / 2.0, N)\n\n    def f(u):\n        return 0.5 * u**2\n\n    def A(u):\n        return u\n\n    def F_cons(ul, ur):\n        a = np.maximum(np.abs(ul), np.abs(ur))\n        return 0.5 * (f(ul) + f(ur)) - 0.5 * a * (ur - ul)\n\n    def F_noncons(ul, ur):\n        a = np.maximum(np.abs(ul), np.abs(ur))\n        avg_u = 0.5 * (ul + ur)\n        avg_A = 0.5 * (A(ul) + A(ur))\n        return avg_A * avg_u - 0.5 * a * (ur - ul)\n\n    def run_sim(u0, T_final, schemes):\n        solutions = {s: u0.copy() for s in schemes}\n        \n        t = 0.0\n        while t  T_final:\n            max_u_abs = 1e-9 # Avoid division by zero\n            for u in solutions.values():\n                max_u_abs = np.maximum(max_u_abs, np.max(np.abs(u)))\n\n            dt = cfl * dx / max_u_abs\n            dt = min(dt, T_final - t)\n\n            for s_name, u in solutions.items():\n                u_ext = np.concatenate(([u[0]], u, [u[-1]]))\n                \n                ul = u_ext[:-1]\n                ur = u_ext[1:]\n                \n                if s_name == 'cons':\n                    flux = F_cons(ul, ur)\n                else:\n                    flux = F_noncons(ul, ur)\n                \n                u -= (dt / dx) * (flux[1:] - flux[:-1])\n            \n            t += dt\n            \n        return solutions\n\n    for case in test_cases:\n        uL, uR, x0, T, case_type = case['uL'], case['uR'], case['x0'], case['T'], case['type']\n        \n        # Initial condition - use np.where for robust floating point comparison\n        u0 = np.where(x  x0, uL, uR).astype(float)\n\n        if case_type == 'shock':\n            final_states = run_sim(u0, T, ['noncons'])\n            u_final = final_states['noncons']\n            \n            m = 0.5 * (uL + uR)\n            # Find the first index where u drops below the midpoint m\n            indices = np.where(u_final = m)[0]\n            if len(indices) == 0 or indices[0] == 0:\n                # Shock has not entered or is at the very beginning\n                x_shock = x[np.argmin(np.abs(u_final - m))]\n            else:\n                i = indices[0]\n                u_i = u_final[i]\n                u_im1 = u_final[i-1]\n                x_i = x[i]\n                x_im1 = x[i-1]\n                \n                if abs(u_i - u_im1)  1e-9:\n                    x_shock = x_i\n                else:\n                    # Linear interpolation\n                    x_shock = x_im1 + (x_i - x_im1) * (m - u_im1) / (u_i - u_im1)\n\n            s_obs = (x_shock - x0) / T\n            s_exact = 0.5 * (uL + uR)\n            ds = s_obs - s_exact\n            results.append(ds)\n\n        elif case_type == 'rarefaction':\n            final_states = run_sim(u0, T, ['cons', 'noncons'])\n            u_cons = final_states['cons']\n            u_noncons = final_states['noncons']\n            \n            # Exact solution\n            xi_t = (x - x0) / T if T > 0 else np.zeros_like(x)\n            u_exact = np.full_like(x, 0.0)\n            u_exact = np.where(xi_t = uL, uL, u_exact)\n            u_exact = np.where(xi_t >= uR, uR, u_exact)\n            mask = (xi_t > uL)  (xi_t  uR)\n            u_exact[mask] = xi_t[mask]\n\n            l1_err_cons = np.sum(np.abs(u_cons - u_exact)) * dx\n            l1_err_noncons = np.sum(np.abs(u_noncons - u_exact)) * dx\n            d_l1 = l1_err_noncons - l1_err_cons\n            results.append(d_l1)\n            \n        elif case_type == 'constant':\n            final_states = run_sim(u0, T, ['noncons'])\n            u_final = final_states['noncons']\n            d_max = np.max(np.abs(u_final - uL))\n            results.append(d_max)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}