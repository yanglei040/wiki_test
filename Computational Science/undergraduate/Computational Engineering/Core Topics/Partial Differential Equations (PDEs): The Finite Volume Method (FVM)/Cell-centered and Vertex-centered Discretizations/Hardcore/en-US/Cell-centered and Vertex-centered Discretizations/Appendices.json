{
    "hands_on_practices": [
        {
            "introduction": "A cornerstone of physical simulation is the verification that the numerical model correctly preserves fundamental conservation laws. This first exercise provides a hands-on opportunity to explore this concept by simulating the time evolution of a quantum wave packet governed by the Schrödinger equation . You will implement a simulation and numerically quantify how well the total probability, a conserved quantity in quantum mechanics, is maintained by a standard time-stepping algorithm on both cell-centered and vertex-centered grids, offering insight into the nature of numerical error.",
            "id": "2376114",
            "problem": "You are to simulate the free one-dimensional time-dependent Schrödinger equation for a Gaussian wave packet on a periodic domain and quantify the conservation of the discrete total probability for two spatial discretization layouts: a vertex-centered grid and a cell-centered grid. The governing Partial Differential Equation (PDE) is\n$$\n\\mathrm{i}\\,\\frac{\\partial \\psi}{\\partial t}(x,t) \\;=\\; -\\frac{1}{2}\\,\\frac{\\partial^2 \\psi}{\\partial x^2}(x,t),\n\\quad x \\in [0,L], \\quad t \\ge 0,\n$$\nwith periodic boundary conditions on the interval of length $L$. The unknown complex-valued wave function is $\\psi(x,t)$. The initial condition is a Gaussian wave packet with a plane-wave carrier,\n$$\n\\psi(x,0) \\;=\\; \\mathcal{A}\\,\\exp\\!\\left(-\\frac{(x-x_0)^2}{4\\,\\sigma^2}\\right)\\,\\exp\\!\\left(\\mathrm{i}\\,k_0\\,x\\right),\n$$\nwhere $\\sigma$ is the standard deviation of the Gaussian envelope, $k_0$ is the carrier wavenumber, $x_0$ is the initial center, and $\\mathcal{A}$ is a normalization constant chosen so that the continuous total probability equals $1$, i.e.,\n$$\n\\int_{0}^{L}|\\psi(x,0)|^2\\,dx \\;=\\; 1.\n$$\nYou will use two uniform spatial layouts on $[0,L)$:\n- A vertex-centered grid with $N$ vertices located at $x_j = j\\,\\Delta x$ for $j=0,1,\\dots,N-1$, where $\\Delta x = L/N$.\n- A cell-centered grid with $N$ cell centers located at $x_{j+\\frac{1}{2}} = \\left(j+\\frac{1}{2}\\right)\\Delta x$ for $j=0,1,\\dots,N-1$.\n\nIn each layout, discretize space uniformly and evolve the semidiscrete system forward in time over a final time horizon $T_f = (\\Delta t)\\times n_{\\text{steps}}$ with periodic boundary conditions. On each layout, define the discrete total probability as\n$$\n\\mathcal{P}(t) \\;=\\; \\Delta x \\sum_{j=0}^{N-1} \\left|\\psi_j(t)\\right|^2,\n$$\nwhere $\\psi_j(t)$ denotes the discrete wave function values at the grid points of the chosen layout. Normalize the initial condition discretely so that $\\mathcal{P}(0)=1$ on each layout. After time evolution to $t=T_f$, compute the relative deviation from unit total probability\n$$\nE \\;=\\; \\left|\\mathcal{P}(T_f) - 1\\right|.\n$$\n\nFor each test case below, compute two values:\n- $E_{\\mathrm{v}}$: the value of $E$ using the vertex-centered grid,\n- $E_{\\mathrm{c}}$: the value of $E$ using the cell-centered grid.\n\nAll quantities are nondimensional; do not use physical units.\n\nUse the following test suite, where each case is specified by $(L, N, \\Delta t, n_{\\text{steps}}, \\sigma, k_0, x_0)$:\n1. Case $1$: $(20,\\;200,\\;0.005,\\;400,\\;1.0,\\;4.0,\\;5.0)$.\n2. Case $2$: $(20,\\;40,\\;0.005,\\;400,\\;1.0,\\;4.0,\\;5.0)$.\n3. Case $3$: $(20,\\;8,\\;0.0025,\\;200,\\;1.0,\\;3.0,\\;20/3)$.\n4. Case $4$: $(20,\\;128,\\;0.005,\\;400,\\;1.2,\\;0.0,\\;10.0)$.\n\nYour program must:\n- For each case, construct both spatial layouts, initialize the wave packet discretely normalized so that $\\mathcal{P}(0)=1$ for each layout, evolve to $T_f$, compute $E_{\\mathrm{v}}$ and $E_{\\mathrm{c}}$, and collect these in order.\n- Produce a single line of output containing a flat list of length $8$ with entries\n$$\n\\left[E_{\\mathrm{v}}^{(1)}, E_{\\mathrm{c}}^{(1)}, E_{\\mathrm{v}}^{(2)}, E_{\\mathrm{c}}^{(2)}, E_{\\mathrm{v}}^{(3)}, E_{\\mathrm{c}}^{(3)}, E_{\\mathrm{v}}^{(4)}, E_{\\mathrm{c}}^{(4)}\\right].\n$$\n\nFinal output format requirement: The single printed line must be a comma-separated list enclosed in square brackets, where each float is formatted in scientific notation with exactly $6$ digits after the decimal point (for example, $1.234567\\mathrm{e}{-08}$). No other text or lines must be printed.",
            "solution": "The problem presented is a well-posed and scientifically sound exercise in computational quantum mechanics. It requires the numerical solution of the one-dimensional, time-dependent Schrödinger equation for a free particle, represented by a Gaussian wave packet, on a periodic domain. The central task is to quantify the numerical conservation of total probability for two distinct uniform spatial discretization schemes: vertex-centered and cell-centered grids. The problem is self-contained, providing all necessary parameters and definitions for its resolution.\n\nThe governing partial differential equation is:\n$$\n\\mathrm{i}\\,\\frac{\\partial \\psi}{\\partial t}(x,t) \\;=\\; -\\frac{1}{2}\\,\\frac{\\partial^2 \\psi}{\\partial x^2}(x,t) \\equiv \\hat{H}\\psi(x,t)\n$$\nwhere $\\hat{H} = -\\frac{1}{2}\\frac{\\partial^2}{\\partial x^2}$ is the Hamiltonian operator. In quantum mechanics, the evolution of a closed system is unitary, which mathematically implies that the total probability, $\\mathcal{P}(t) = \\int |\\psi(x,t)|^2\\,dx$, is a conserved quantity. The goal is to investigate how this fundamental property is preserved under numerical discretization.\n\nThe solution methodology proceeds by first semi-discretizing the spatial domain and then integrating the resulting system of ordinary differential equations (ODEs) in time.\n\nFirst, the spatial derivative is discretized. A second-order central difference scheme is employed for the Laplacian operator, $\\frac{\\partial^2}{\\partial x^2}$, on a uniform grid with spacing $\\Delta x$. For a discrete wave function $\\psi_j(t) = \\psi(x_j, t)$, the approximation is:\n$$\n\\frac{\\partial^2 \\psi}{\\partial x^2}\\bigg|_{x_j} \\;\\approx\\; \\frac{\\psi_{j+1}(t) - 2\\psi_j(t) + \\psi_{j-1}(t)}{(\\Delta x)^2}\n$$\nThis transforms the partial differential equation into a system of coupled first-order ODEs for the vector of discrete wave function values, $\\vec{\\psi}(t)$:\n$$\n\\mathrm{i}\\,\\frac{d\\vec{\\psi}}{dt} \\;=\\; \\hat{H}_{\\text{FD}}\\vec{\\psi}\n$$\nHere, $\\hat{H}_{\\text{FD}}$ is the finite-difference matrix representation of the Hamiltonian. Due to the periodic boundary conditions, this matrix is a real, symmetric, circulant matrix. A real symmetric matrix is Hermitian. This property is crucial, as a system governed by a Hermitian Hamiltonian should, under exact time evolution, conserve the discrete L2-norm, $\\|\\vec{\\psi}(t)\\|^2 = \\sum_j |\\psi_j(t)|^2$. Consequently, the discrete total probability, defined as $\\mathcal{P}(t) = \\Delta x \\sum_{j=0}^{N-1} |\\psi_j(t)|^2$, should also be conserved. This holds true for both the vertex-centered grid ($x_j = j\\Delta x$) and the cell-centered grid ($x_{j+\\frac{1}{2}} = (j+\\frac{1}{2})\\Delta x$), as the periodic connectivity gives rise to a Hermitian operator in both cases.\n\nNext, a method for time integration of the semi-discrete system must be chosen. While unitary integrators such as the Crank-Nicolson scheme or a spectral propagator would conserve the discrete norm to within machine precision, they would obscure the very numerical artifacts the problem asks us to quantify. A more instructive approach is to use a standard, high-order, but non-unitary integrator. The classical fourth-order Runge-Kutta (RK4) method is an excellent choice for this purpose. For an ODE system $\\frac{d\\vec{\\psi}}{dt} = \\vec{f}(t, \\vec{\\psi})$, one step of RK4 is given by:\n$$\n\\vec{\\psi}_{n+1} = \\vec{\\psi}_n + \\frac{1}{6}(\\vec{k}_1 + 2\\vec{k}_2 + 2\\vec{k}_3 + \\vec{k}_4)\n$$\nwhere\n$$\n\\begin{aligned}\n\\vec{k}_1 &= \\Delta t \\cdot \\vec{f}(t_n, \\vec{\\psi}_n) \\\\\n\\vec{k}_2 &= \\Delta t \\cdot \\vec{f}(t_n + \\Delta t/2, \\vec{\\psi}_n + \\vec{k}_1/2) \\\\\n\\vec{k}_3 &= \\Delta t \\cdot \\vec{f}(t_n + \\Delta t/2, \\vec{\\psi}_n + \\vec{k}_2/2) \\\\\n\\vec{k}_4 &= \\Delta t \\cdot \\vec{f}(t_n + \\Delta t, \\vec{\\psi}_n + \\vec{k}_3)\n\\end{aligned}\n$$\nand for our system, $\\vec{f}(t, \\vec{\\psi}) = -\\mathrm{i}\\hat{H}_{\\text{FD}}\\vec{\\psi}$. The RK4 method's one-step amplification operator is not unitary. As a result, it does not perfectly preserve the norm, and the discrete probability $\\mathcal{P}(t)$ will drift from its initial value of $1$. The magnitude of this drift, $E = |\\mathcal{P}(T_f) - 1|$, is the quantity we must compute.\n\nThe overall algorithm is as follows:\nFor each test case and for each of the two grid layouts (vertex-centered and cell-centered):\n1.  Define the grid points $x_j$ over the domain $[0, L)$ with $N$ points and spacing $\\Delta x = L/N$.\n2.  Evaluate the initial wave function, $\\psi(x,0) = \\mathcal{A}\\,\\exp(-\\frac{(x-x_0)^2}{4\\,\\sigma^2})\\,\\exp(\\mathrm{i}\\,k_0\\,x)$, at these grid points to obtain the initial state vector $\\vec{\\psi}(0)$.\n3.  Normalize this state vector. First, compute the initial discrete probability $\\mathcal{P}_{\\text{raw}} = \\Delta x \\sum_{j=0}^{N-1} |\\psi_j(0)|^2$. Then, rescale the vector as $\\vec{\\psi}_{\\text{norm}}(0) = \\vec{\\psi}(0) / \\sqrt{\\mathcal{P}_{\\text{raw}}}$. This ensures that the initial normalized probability is exactly $1$.\n4.  Evolve the system from $t=0$ to $t=T_f = n_{\\text{steps}}\\Delta t$ using the RK4 algorithm. The action of the Hamiltonian, $\\hat{H}_{\\text{FD}}\\vec{\\psi}$, is computed efficiently at each step without explicit matrix construction, using array rolling operations to implement the periodic central difference stencil.\n5.  At the final time $T_f$, compute the final discrete probability $\\mathcal{P}(T_f) = \\Delta x \\sum_{j=0}^{N-1} |\\psi_j(T_f)|^2$.\n6.  Calculate the final error as $E = |\\mathcal{P}(T_f) - 1|$. This value is stored as $E_{\\mathrm{v}}$ for the vertex-centered grid and $E_{\\mathrm{c}}$ for the cell-centered grid.\n\nThis procedure is repeated for all specified test cases, and the resulting error values are collected and formatted into a single list. The difference between $E_{\\mathrm{v}}$ and $E_{\\mathrm{c}}$ arises from the different initial sampling of the continuous wave function, which leads to distinct initial discrete states. These distinct states then undergo slightly different error accumulation pathways through the non-unitary RK4 time-stepping process.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the time-dependent Schrödinger equation for a Gaussian wave packet\n    on a periodic domain using two different spatial discretizations and\n    quantifies the conservation of total probability.\n    \"\"\"\n    \n    # Test cases: (L, N, dt, n_steps, sigma, k0, x0)\n    test_cases = [\n        (20.0, 200, 0.005, 400, 1.0, 4.0, 5.0),\n        (20.0, 40, 0.005, 400, 1.0, 4.0, 5.0),\n        (20.0, 8, 0.0025, 200, 1.0, 3.0, 20.0/3.0),\n        (20.0, 128, 0.005, 400, 1.2, 0.0, 10.0),\n    ]\n\n    results = []\n\n    for L, N, dt, n_steps, sigma, k0, x0 in test_cases:\n        dx = L / N\n\n        for grid_type in ['vertex', 'cell']:\n            # 1. Grid Construction\n            if grid_type == 'vertex':\n                # Vertex-centered grid: x_j = j*dx\n                x = np.arange(N) * dx\n            else:  # cell-centered\n                # Cell-centered grid: x_{j+1/2} = (j+0.5)*dx\n                x = (np.arange(N) + 0.5) * dx\n            \n            # 2. Initial Condition\n            # The complex-valued Gaussian wave packet\n            psi_initial = np.exp(-(x - x0)**2 / (4 * sigma**2)) * np.exp(1j * k0 * x)\n            psi = psi_initial.astype(np.complex128)\n\n            # 3. Normalization\n            # Ensure the initial discrete probability is 1\n            prob_initial = dx * np.sum(np.abs(psi)**2)\n            psi /= np.sqrt(prob_initial)\n\n            def dpsi_dt(psi_vec, dx_val):\n                \"\"\"\n                Computes the time derivative of the wave function vector psi_vec,\n                which is -i * H * psi_vec.\n                The Hamiltonian H = -1/2 * d^2/dx^2 is approximated with\n                a central finite difference scheme on a periodic domain.\n                \"\"\"\n                # Second derivative using central differences with periodic BCs\n                # np.roll provides an efficient way to handle periodic boundaries.\n                d2psi_dx2 = (np.roll(psi_vec, -1) - 2 * psi_vec + np.roll(psi_vec, 1)) / dx_val**2\n                \n                # Action of the Hamiltonian operator H on psi\n                H_psi = -0.5 * d2psi_dx2\n                \n                # From Schrödinger eq: i*d(psi)/dt = H*psi => d(psi)/dt = -i*H*psi\n                return -1j * H_psi\n\n            # 4. Time Evolution using 4th-order Runge-Kutta (RK4)\n            for _ in range(n_steps):\n                k1 = dt * dpsi_dt(psi, dx)\n                k2 = dt * dpsi_dt(psi + 0.5 * k1, dx)\n                k3 = dt * dpsi_dt(psi + 0.5 * k2, dx)\n                k4 = dt * dpsi_dt(psi + k3, dx)\n                psi += (k1 + 2*k2 + 2*k3 + k4) / 6.0\n                \n            # 5. Final Probability and Error Calculation\n            prob_final = dx * np.sum(np.abs(psi)**2)\n            error = np.abs(prob_final - 1.0)\n            results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Real-world engineering problems often involve complex geometries and anisotropic material properties, leading to meshes that are not perfectly orthogonal. This practice delves into such a scenario, examining anisotropic diffusion on a skewed mesh to highlight a crucial difference in accuracy between discretization strategies . By comparing a simple cell-centered, two-point flux approximation with a vertex-centered approach that reconstructs the full gradient, you will quantify the \"cross-diffusion\" error and understand why more sophisticated schemes are essential for achieving accuracy on general unstructured grids.",
            "id": "2376138",
            "problem": "Consider the steady anisotropic diffusion flux in two dimensions given by Fick’s law, where the diffusive flux vector is defined by the fundamental constitutive relation $\\mathbf{q} = -\\mathbf{K}\\nabla u$ with a symmetric positive-definite tensor $\\mathbf{K}$. For a control-volume face with outward unit normal $\\mathbf{n}$ and length $L$, the exact integrated diffusive flux crossing the face is the surface integral $\\Phi = \\int_{\\text{face}} \\mathbf{q}\\cdot\\mathbf{n}\\, \\mathrm{d}S$, which for a linear field $u(\\mathbf{x})$ and a straight face simplifies to $\\Phi = -L\\mathbf{n}\\cdot \\mathbf{K}\\nabla u$. We will compare two finite-volume discretizations on a non-orthogonal mesh and quantify their treatment of cross-diffusion terms. The two schemes are: a cell-centered, two-point flux approximation and a vertex-centered, linear-reconstruction approximation.\n\nWe focus on a single internal face in a skewed parallelogram mesh obtained by the mapping $\\mathcal{M}:(\\xi,\\eta)\\mapsto (x,y)$ defined by $x=\\xi + s\\eta$ and $y=\\eta$, where $s$ is the skew parameter. Consider the face that is the image of the computational line $\\xi=0$ over $\\eta\\in[-\\tfrac{1}{2},\\tfrac{1}{2}]$. The two adjacent cell centers are the images of $(\\xi,\\eta)=(-\\tfrac{1}{2},0)$ and $(\\tfrac{1}{2},0)$. The exact face-length vector equals $\\mathbf{A}_f = L\\mathbf{n} = (1,-s)$ for this configuration, so the exact integrated flux for a linear field with constant gradient $\\nabla u=\\mathbf{g}$ is\n$$\n\\Phi_{\\text{exact}} = -\\mathbf{A}_f \\cdot (\\mathbf{K}\\mathbf{g}) = -(1,-s)\\cdot(\\mathbf{K}\\mathbf{g}).\n$$\nWe will compare the following two discretizations for the same face:\n\n- Cell-centered two-point flux approximation (CC-TPFA): approximate the gradient by its projection along the line connecting the two cell centers. Let $\\mathbf{d}$ be the vector from the left to the right cell center. For our configuration, $\\mathbf{d}=(1,0)$ and its unit direction is $\\hat{\\mathbf{d}}=(1,0)$. The two-point gradient approximation is $(\\mathbf{g}\\cdot \\hat{\\mathbf{d}})\\hat{\\mathbf{d}}$, and the corresponding integrated flux approximation is\n$$\n\\Phi_{\\text{CC}} = -\\mathbf{A}_f \\cdot \\Big(\\mathbf{K}\\big[(\\mathbf{g}\\cdot \\hat{\\mathbf{d}})\\hat{\\mathbf{d}}\\big]\\Big).\n$$\nThis approximation omits the tangential component of $\\nabla u$ relative to $\\hat{\\mathbf{d}}$ and therefore neglects cross-diffusion induced by non-orthogonality when $\\mathbf{K}$ is anisotropic or when $\\mathbf{g}$ has a significant component not aligned with $\\hat{\\mathbf{d}}$.\n\n- Vertex-centered linear reconstruction (VC-LR): reconstruct the full gradient from values at three non-collinear mesh vertices near the face by fitting a plane $u(x,y)=\\alpha + ax + by$, which yields an estimate $\\widehat{\\nabla u}=(a,b)^\\top$. For a linear field, this reconstruction is exact. The corresponding integrated flux approximation is\n$$\n\\Phi_{\\text{VC}} = -\\mathbf{A}_f \\cdot (\\mathbf{K}\\widehat{\\nabla u}).\n$$\n\nAssume a linear manufactured solution $u(x,y) = ax + by + c$ with constant gradient $\\mathbf{g}=(a,b)^\\top$. Assume a symmetric anisotropic tensor\n$$\n\\mathbf{K} = \\begin{bmatrix} k_{xx} & k_{xy} \\\\ k_{xy} & k_{yy}\\end{bmatrix},\n$$\nwith $k_{xx}>0$, $k_{yy}>0$, and $k_{xx}k_{yy} - k_{xy}^2 > 0$. For the vertex-centered reconstruction, use the three physical-space vertices obtained from the computational coordinates $(\\xi,\\eta)\\in\\{(0,-\\tfrac{1}{2}),(0,\\tfrac{1}{2}),(1,0)\\}$ via the mapping $\\mathcal{M}$, i.e., the two vertices at the ends of the face and one vertex on the right to form a non-degenerate triangle.\n\nYour task is to implement a program that, for each test case below, computes the following two absolute flux errors:\n$$\nE_{\\text{CC}} = \\big|\\Phi_{\\text{CC}} - \\Phi_{\\text{exact}}\\big|,\\qquad\nE_{\\text{VC}} = \\big|\\Phi_{\\text{VC}} - \\Phi_{\\text{exact}}\\big|.\n$$\nReport the results for all test cases in a single line as a comma-separated flat list enclosed in square brackets, ordered as $[E_{\\text{CC}}^{(1)},E_{\\text{VC}}^{(1)},E_{\\text{CC}}^{(2)},E_{\\text{VC}}^{(2)},\\dots]$.\n\nThere are no physical units in this problem; all quantities are unitless. Angles are not used.\n\nTest suite parameters are as follows, where each case specifies the skew $s$, tensor components $k_{xx}, k_{yy}, k_{xy}$, and the gradient components $a,b$:\n\n- Case $1$ (happy path, moderate skew, diagonal anisotropy, mixed gradient): $s=0.3$, $k_{xx}=2.0$, $k_{yy}=1.0$, $k_{xy}=0.0$, $a=1.0$, $b=-0.5$.\n- Case $2$ (edge, strong skew, diagonal anisotropy, equal components): $s=0.9$, $k_{xx}=2.0$, $k_{yy}=1.0$, $k_{xy}=0.0$, $a=1.0$, $b=1.0$.\n- Case $3$ (edge, strong anisotropy, diagonal, gradient dominated by tangential component): $s=0.5$, $k_{xx}=10.0$, $k_{yy}=1.0$, $k_{xy}=0.0$, $a=0.2$, $b=2.0$.\n- Case $4$ (boundary condition surrogate, orthogonal mesh): $s=0.0$, $k_{xx}=2.0$, $k_{yy}=1.0$, $k_{xy}=0.0$, $a=1.0$, $b=0.5$.\n- Case $5$ (edge, off-diagonal anisotropy present): $s=0.4$, $k_{xx}=1.0$, $k_{yy}=2.0$, $k_{xy}=0.5$, $a=1.0$, $b=1.0$.\n\nImplementation details to adhere to:\n\n- Use the exact face-length vector $\\mathbf{A}_f=(1,-s)$, the cell-center vector $\\mathbf{d}=(1,0)$ with $\\hat{\\mathbf{d}}=(1,0)$, and the vertex set given above. Use $c=0$ in $u(x,y)$.\n- Compute $\\Phi_{\\text{exact}}$ directly from $\\mathbf{A}_f$, $\\mathbf{K}$, and $\\mathbf{g}$.\n- For CC-TPFA, use $\\nabla u \\approx (\\mathbf{g}\\cdot \\hat{\\mathbf{d}})\\hat{\\mathbf{d}}$.\n- For VC-LR, reconstruct $\\widehat{\\nabla u}$ by least-squares fitting of a plane to the vertex data; for three non-collinear points and a linear field this is exact.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the order specified above, for example $\\big[ E_{\\text{CC}}^{(1)},E_{\\text{VC}}^{(1)},E_{\\text{CC}}^{(2)},E_{\\text{VC}}^{(2)},\\dots\\big]$.\n\nThe required final outputs for all test cases are floats. Ensure numerical stability and use standard double-precision arithmetic. No external input is allowed, and no user interaction is required. The program must be self-contained and deterministic.",
            "solution": "The problem statement has been evaluated and is determined to be valid. It is scientifically grounded in the principles of continuum mechanics and numerical methods for partial differential equations. It is well-posed, objective, and provides a complete and consistent set of definitions and data required for a unique solution. We may therefore proceed with the derivation and computation.\n\nThe problem requires a comparison of two finite-volume flux approximations against an exact flux for a steady anisotropic diffusion problem. The analysis is performed for a single face of a skewed mesh under the assumption of a linear scalar field.\n\nFirst, we establish the mathematical entities provided.\nThe diffusion tensor is a symmetric positive-definite matrix $\\mathbf{K}$:\n$$\n\\mathbf{K} = \\begin{bmatrix} k_{xx} & k_{xy} \\\\ k_{xy} & k_{yy}\\end{bmatrix}\n$$\nThe scalar field $u(x,y)$ is linear, given by $u(x,y) = a\\,x + b\\,y + c$, with a constant gradient vector $\\mathbf{g}$:\n$$\n\\mathbf{g} = \\nabla u = \\begin{bmatrix} a \\\\ b \\end{bmatrix}\n$$\nThe face of the control volume under consideration is characterized by its face-length vector $\\mathbf{A}_f$, which combines the face length $L$ and the outward unit normal $\\mathbf{n}$ as $\\mathbf{A}_f = L\\mathbf{n}$. For the specified geometry, this vector is given as:\n$$\n\\mathbf{A}_f = \\begin{bmatrix} 1 \\\\ -s \\end{bmatrix}\n$$\nwhere $s$ is the mesh skew parameter.\n\nThe analysis hinges on computing three integrated flux quantities: $\\Phi_{\\text{exact}}$, $\\Phi_{\\text{CC}}$, and $\\Phi_{\\text{VC}}$.\n\n1.  **Exact Integrated Flux ($\\Phi_{\\text{exact}}$)**\n\n    For a linear field, the exact integrated flux through a straight face is given by the formula $\\Phi = -L\\,\\mathbf{n}\\cdot \\mathbf{K}\\,\\nabla u$, which can be rewritten using the face-length vector $\\mathbf{A}_f$ and the constant gradient $\\mathbf{g}$:\n    $$\n    \\Phi_{\\text{exact}} = -\\mathbf{A}_f \\cdot (\\mathbf{K}\\,\\mathbf{g})\n    $$\n    Substituting the components, we have:\n    $$\n    \\mathbf{K}\\,\\mathbf{g} = \\begin{bmatrix} k_{xx} & k_{xy} \\\\ k_{xy} & k_{yy}\\end{bmatrix} \\begin{bmatrix} a \\\\ b \\end{bmatrix} = \\begin{bmatrix} k_{xx}a + k_{xy}b \\\\ k_{xy}a + k_{yy}b \\end{bmatrix}\n    $$\n    The dot product is then:\n    $$\n    \\mathbf{A}_f \\cdot (\\mathbf{K}\\,\\mathbf{g}) = \\begin{bmatrix} 1 \\\\ -s \\end{bmatrix} \\cdot \\begin{bmatrix} k_{xx}a + k_{xy}b \\\\ k_{xy}a + k_{yy}b \\end{bmatrix} = (k_{xx}a + k_{xy}b) - s(k_{xy}a + k_{yy}b)\n    $$\n    Thus, the exact flux is:\n    $$\n    \\Phi_{\\text{exact}} = - \\big( k_{xx}a + k_{xy}b - s\\,k_{xy}a - s\\,k_{yy}b \\big)\n    $$\n\n2.  **Cell-Centered Two-Point Flux Approximation ($\\Phi_{\\text{CC}}$)**\n\n    This approximation (CC-TPFA) simplifies the gradient by considering only its projection along the line connecting the two adjacent cell centers. The vector connecting these centers is $\\mathbf{d}=(1,0)$, with the unit vector $\\hat{\\mathbf{d}}=(1,0)$. The approximated gradient, $\\mathbf{g}_{\\text{CC}}$, is:\n    $$\n    \\mathbf{g}_{\\text{CC}} = (\\mathbf{g} \\cdot \\hat{\\mathbf{d}})\\,\\hat{\\mathbf{d}}\n    $$\n    Calculation of the components:\n    $$\n    \\mathbf{g} \\cdot \\hat{\\mathbf{d}} = \\begin{bmatrix} a \\\\ b \\end{bmatrix} \\cdot \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} = a\n    $$\n    So, the approximated gradient is:\n    $$\n    \\mathbf{g}_{\\text{CC}} = a \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} = \\begin{bmatrix} a \\\\ 0 \\end{bmatrix}\n    $$\n    The flux is then approximated as:\n    $$\n    \\Phi_{\\text{CC}} = -\\mathbf{A}_f \\cdot (\\mathbf{K}\\,\\mathbf{g}_{\\text{CC}})\n    $$\n    We compute the term $\\mathbf{K}\\,\\mathbf{g}_{\\text{CC}}$:\n    $$\n    \\mathbf{K}\\,\\mathbf{g}_{\\text{CC}} = \\begin{bmatrix} k_{xx} & k_{xy} \\\\ k_{xy} & k_{yy}\\end{bmatrix} \\begin{bmatrix} a \\\\ 0 \\end{bmatrix} = \\begin{bmatrix} k_{xx}a \\\\ k_{xy}a \\end{bmatrix}\n    $$\n    And the final flux expression is:\n    $$\n    \\Phi_{\\text{CC}} = -\\begin{bmatrix} 1 \\\\ -s \\end{bmatrix} \\cdot \\begin{bmatrix} k_{xx}a \\\\ k_{xy}a \\end{bmatrix} = -(k_{xx}a - s\\,k_{xy}a)\n    $$\n\n3.  **Vertex-Centered Linear Reconstruction Flux ($\\Phi_{\\text{VC}}$)**\n\n    This method reconstructs the gradient, $\\widehat{\\nabla u}$, by fitting a linear function to the scalar values at three non-collinear vertices. The problem statement asserts that for a linear field $u(x,y)$, this reconstruction is exact. This is a standard result in finite element and finite volume methods. Therefore, the reconstructed gradient $\\widehat{\\nabla u}$ is identical to the true gradient $\\mathbf{g}$:\n    $$\n    \\widehat{\\nabla u} = \\mathbf{g}\n    $$\n    Consequently, the flux approximation is:\n    $$\n    \\Phi_{\\text{VC}} = -\\mathbf{A}_f \\cdot (\\mathbf{K}\\,\\widehat{\\nabla u}) = -\\mathbf{A}_f \\cdot (\\mathbf{K}\\,\\mathbf{g}) = \\Phi_{\\text{exact}}\n    $$\n\n4.  **Absolute Flux Errors ($E_{\\text{CC}}$ and $E_{\\text{VC}}$)**\n\n    The errors are defined as the absolute difference between the approximated and exact fluxes.\n\n    For the vertex-centered scheme, the error is identically zero under the problem's conditions:\n    $$\n    E_{\\text{VC}} = |\\Phi_{\\text{VC}} - \\Phi_{\\text{exact}}| = |\\Phi_{\\text{exact}} - \\Phi_{\\text{exact}}| = 0\n    $$\n\n    For the cell-centered scheme, the error is:\n    $$\n    E_{\\text{CC}} = |\\Phi_{\\text{CC}} - \\Phi_{\\text{exact}}| = \\left| -\\left(k_{xx}a - s\\,k_{xy}a\\right) - \\left[- \\left( k_{xx}a + k_{xy}b - s\\,k_{xy}a - s\\,k_{yy}b \\right)\\right] \\right|\n    $$\n    $$\n    E_{\\text{CC}} = \\left| -k_{xx}a + s\\,k_{xy}a + k_{xx}a + k_{xy}b - s\\,k_{xy}a - s\\,k_{yy}b \\right|\n    $$\n    Simplifying the expression by cancelling terms yields:\n    $$\n    E_{\\text{CC}} = |k_{xy}b - s\\,k_{yy}b| = |b(k_{xy} - s\\,k_{yy})|\n    $$\n    This error term, known as the cross-diffusion error, arises from the method's failure to account for the flux component driven by the gradient part orthogonal to the cell-center vector, particularly when the mesh is non-orthogonal ($s \\neq 0$) or the tensor is not diagonal ($k_{xy} \\neq 0$).\n\nNow, we apply these formulas to the given test cases.\n\n**Case 1:** $s=0.3$, $k_{xx}=2.0$, $k_{yy}=1.0$, $k_{xy}=0.0$, $a=1.0$, $b=-0.5$.\n$$\nE_{\\text{CC}} = |-0.5 \\times (0.0 - 0.3 \\times 1.0)| = |-0.5 \\times -0.3| = |0.15| = 0.15\n$$\n$$\nE_{\\text{VC}} = 0.0\n$$\n\n**Case 2:** $s=0.9$, $k_{xx}=2.0$, $k_{yy}=1.0$, $k_{xy}=0.0$, $a=1.0$, $b=1.0$.\n$$\nE_{\\text{CC}} = |1.0 \\times (0.0 - 0.9 \\times 1.0)| = |1.0 \\times -0.9| = |-0.9| = 0.9\n$$\n$$\nE_{\\text{VC}} = 0.0\n$$\n\n**Case 3:** $s=0.5$, $k_{xx}=10.0$, $k_{yy}=1.0$, $k_{xy}=0.0$, $a=0.2$, $b=2.0$.\n$$\nE_{\\text{CC}} = |2.0 \\times (0.0 - 0.5 \\times 1.0)| = |2.0 \\times -0.5| = |-1.0| = 1.0\n$$\n$$\nE_{\\text{VC}} = 0.0\n$$\n\n**Case 4:** $s=0.0$, $k_{xx}=2.0$, $k_{yy}=1.0$, $k_{xy}=0.0$, $a=1.0$, $b=0.5$.\n$$\nE_{\\text{CC}} = |0.5 \\times (0.0 - 0.0 \\times 1.0)| = |0.5 \\times 0.0| = 0.0\n$$\n$$\nE_{\\text{VC}} = 0.0\n$$\nThe error for CC-TPFA is zero because the mesh is orthogonal ($s=0$) and the tensor is diagonal ($k_{xy}=0$).\n\n**Case 5:** $s=0.4$, $k_{xx}=1.0$, $k_{yy}=2.0$, $k_{xy}=0.5$, $a=1.0$, $b=1.0$.\n$$\nE_{\\text{CC}} = |1.0 \\times (0.5 - 0.4 \\times 2.0)| = |1.0 \\times (0.5 - 0.8)| = |-0.3| = 0.3\n$$\n$$\nE_{\\text{VC}} = 0.0\n$$\n\nThe final results are collected and formatted as requested.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes absolute flux errors for CC-TPFA and VC-LR discretization schemes\n    for a steady anisotropic diffusion problem on a skewed mesh.\n    \"\"\"\n    test_cases = [\n        # Case 1: (s, k_xx, k_yy, k_xy, a, b)\n        (0.3, 2.0, 1.0, 0.0, 1.0, -0.5),\n        # Case 2:\n        (0.9, 2.0, 1.0, 0.0, 1.0, 1.0),\n        # Case 3:\n        (0.5, 10.0, 1.0, 0.0, 0.2, 2.0),\n        # Case 4:\n        (0.0, 2.0, 1.0, 0.0, 1.0, 0.5),\n        # Case 5:\n        (0.4, 1.0, 2.0, 0.5, 1.0, 1.0),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        s, k_xx, k_yy, k_xy, a, b = case\n\n        # Define the mathematical entities as numpy arrays\n        # Diffusion tensor K\n        K = np.array([[k_xx, k_xy], [k_xy, k_yy]])\n        \n        # Exact gradient vector g\n        g = np.array([a, b])\n        \n        # Face-length vector A_f\n        A_f = np.array([1.0, -s])\n        \n        # Unit vector along the line connecting cell centers\n        d_hat = np.array([1.0, 0.0])\n\n        # 1. Exact Integrated Flux (Phi_exact)\n        # Phi_exact = - A_f . (K * g)\n        Kg = K @ g\n        phi_exact = -np.dot(A_f, Kg)\n\n        # 2. Cell-Centered Two-Point Flux Approximation (Phi_CC)\n        # Gradient approximation: g_cc = (g . d_hat) * d_hat\n        g_cc = np.dot(g, d_hat) * d_hat\n        # Phi_CC = - A_f . (K * g_cc)\n        Kg_cc = K @ g_cc\n        phi_cc = -np.dot(A_f, Kg_cc)\n\n        # 3. Vertex-Centered Linear Reconstruction Flux (Phi_VC)\n        # For a linear field, the reconstruction is exact, so the reconstructed\n        # gradient is identical to the true gradient g.\n        g_vc = g\n        # As a result, Phi_VC is identical to Phi_exact.\n        Kg_vc = K @ g_vc\n        phi_vc = -np.dot(A_f, Kg_vc)\n\n        # 4. Compute Absolute Flux Errors\n        E_cc = np.abs(phi_cc - phi_exact)\n        E_vc = np.abs(phi_vc - phi_exact)\n        \n        # As a sanity check, E_vc should be very close to zero.\n        # Use a small tolerance for floating point arithmetic.\n        if E_vc < 1e-15:\n            E_vc = 0.0\n\n        results.extend([E_cc, E_vc])\n\n    # Format the final output string\n    # Using 'g' format specifier for clean output of floats.\n    print(f\"[{','.join(f'{r:.15g}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Efficiently resolving localized features in a simulation often requires adaptive mesh refinement, which introduces non-conforming grid interfaces with \"hanging nodes.\" This exercise demonstrates how cell-centered and vertex-centered schemes manage such complexities, focusing on the vital principle of local flux conservation . You will discover the natural ability of cell-centered finite volume methods to enforce strict flux balancing across these interfaces, contrasting it with the special constraints required to achieve the same in a vertex-centered framework.",
            "id": "2376143",
            "problem": "Consider steady diffusion described by the second-order elliptic equation $-\\nabla \\cdot \\left( k \\nabla u \\right) = 0$ with constant isotropic conductivity $k>0$. Focus on a local nonconforming interface in two dimensions where a coarse rectangular cell on the left of width $h_c$ interfaces with two finer rectangular cells on the right, each of width $h_f$. Assume $h_c = 2 h_f$. The interface is the vertical line segment at $x=0$ with extent $y \\in [-h_f, h_f]$. The coarse cell center is at $(-h_c/2, 0)$ and the two fine cell centers are at $(h_f/2, h_f/2)$ and $(h_f/2, -h_f/2)$. Consider a manufactured linear field $u(x,y) = ax + by + c$ and constant $k$.\n\nTask A (cell-centered scheme via flux balancing, Finite Volume Method (FVM)): Using a two-point flux approximation across each subface, model the fluxes from the coarse cell to the two fine cells. For a subface of length $A = h_f$ shared between cell centers separated by a normal distance $d = (h_c/2) + (h_f/2)$, the transmissibility is $T = kA/d$. The flux from the coarse cell center to a fine cell center is $F = -T(u_{\\text{fine}} - u_{\\text{coarse}})$. Define $F_{0 \\to 1}$ for the upper fine cell and $F_{0 \\to 2}$ for the lower fine cell, and compute the summed numerical flux $F_{\\text{cc}} = F_{0 \\to 1} + F_{0 \\to 2}$. The exact integrated flux through the entire nonconforming interface segment is\n$$\nF_{\\text{exact}} = \\int_{-h_f}^{h_f} \\left(-k \\frac{\\partial u}{\\partial x} \\right) \\, dy = -2 k a h_f.\n$$\nDefine the cell-centered absolute error $E_{\\mathrm{cc}} = |F_{\\text{cc}} - F_{\\text{exact}}|$.\n\nTask B (vertex-centered scheme, naive): In a vertex-centered discretization using control volumes around vertices, the nonconforming interface introduces a hanging node at the mid-edge point $(0,0)$ that is not a vertex of the coarse cell. If one ignores this hanging node without adding any constraint, the flux attributed to the coarse cell vertices covers only the two end segments and misses the central segment of length $h_f$. Under the linear field $u(x,y) = ax + by + c$ with constant $k$, the normal flux density along the interface is uniform and equal to $-ka$, so the missing flux contribution is $-ka h_f$. Define the naive vertex-centered absolute imbalance as $E_{\\mathrm{vn}} = |-ka h_f|$.\n\nTask C (vertex-centered scheme, modified with hanging-node constraint): A standard modification in vertex-centered methods is to impose a linear constraint at the hanging node, for example $u_{\\text{hang}} = \\frac{1}{2}(u_{\\text{top}} + u_{\\text{bottom}})$, and to redistribute the central segment flux consistently to the adjacent vertices. Under the given linear field, this modification recovers the correct integrated flux attribution across the interface. Define the modified vertex-centered residual $E_{\\mathrm{vm}} = 0$ for this linear field and configuration.\n\nUse the following parameterization for the test suite. In all cases, take $b = 0.7$ and $c = -0.2$. For each test case, compute and return the triplet $(E_{\\mathrm{cc}}, E_{\\mathrm{vn}}, E_{\\mathrm{vm}})$ as described above.\n\nTest suite (each case is a tuple $(h_f, k, a)$):\n- Case $1$: $(1.0, 1.0, 1.5)$.\n- Case $2$: $(0.5, 3.0, -2.0)$.\n- Case $3$: $(2.0, 0.7, 0.0)$.\n- Case $4$: $(10^{-3}, 5.0, 4.0)$.\n\nComputational details to implement:\n- Use $h_c = 2h_f$, face length $A = h_f$, center-to-center normal distance $d = \\frac{h_c}{2} + \\frac{h_f}{2} = \\frac{3}{2} h_f$, transmissibility $T = \\frac{kA}{d}$.\n- Use the cell-center coordinates $x_0 = -h_c/2$, $y_0 = 0$, $x_1 = h_f/2$, $y_1 = h_f/2$, and $x_2 = h_f/2$, $y_2 = -h_f/2$. Evaluate $u$ at these centers and form $F_{0 \\to 1}$ and $F_{0 \\to 2}$ as above.\n- Compute $F_{\\text{exact}} = -2 k a h_f$ and then $E_{\\mathrm{cc}} = |F_{0 \\to 1} + F_{0 \\to 2} - F_{\\text{exact}}|$.\n- Compute $E_{\\mathrm{vn}} = |-ka h_f|$.\n- Set $E_{\\mathrm{vm}} = 0$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list should be flattened across test cases in the order given, i.e., $[E_{\\mathrm{cc}}^{(1)}, E_{\\mathrm{vn}}^{(1)}, E_{\\mathrm{vm}}^{(1)}, E_{\\mathrm{cc}}^{(2)}, E_{\\mathrm{vn}}^{(2)}, E_{\\mathrm{vm}}^{(2)}, \\dots]$. Each entry must be a floating-point number.",
            "solution": "The problem statement is subjected to validation prior to any attempt at a solution.\n\nStep 1: Extract Givens\n- Governing Equation: $-\\nabla \\cdot \\left( k \\nabla u \\right) = 0$ for steady diffusion.\n- Conductivity: $k$ is a positive, constant, and isotropic scalar.\n- Manufactured Solution: $u(x,y) = a x + b y + c$.\n- Geometry: A coarse rectangular cell on the left, width $h_c$. Two fine rectangular cells on the right, each width $h_f$.\n- Geometric Constraint: $h_c = 2 h_f$.\n- Interface: Vertical line at $x=0$, from $y = -h_f$ to $y = h_f$.\n- Cell Centers:\n    - Coarse cell $C_0$: $(-h_c/2, 0) = (-h_f, 0)$.\n    - Upper fine cell $C_1$: $(h_f/2, h_f/2)$.\n    - Lower fine cell $C_2$: $(h_f/2, -h_f/2)$.\n- Task A (Cell-Centered Method):\n    - Two-point flux approximation: $F = -T \\left( u_{\\text{fine}} - u_{\\text{coarse}} \\right)$.\n    - Subface length: $A = h_f$.\n    - Center-to-center normal distance: $d = (h_c/2) + (h_f/2) = (3/2)h_f$.\n    - Transmissibility: $T = k A / d$.\n    - Numerical fluxes: $F_{0 \\to 1}$ and $F_{0 \\to 2}$.\n    - Total numerical flux: $F_{\\text{cc}} = F_{0 \\to 1} + F_{0 \\to 2}$.\n    - Exact integrated flux: $F_{\\text{exact}} = \\int_{-h_f}^{h_f} \\left(-k \\frac{\\partial u}{\\partial x} \\right) \\, dy = -2 k a h_f$.\n    - Cell-centered absolute error: $E_{\\mathrm{cc}} = \\left| F_{\\text{cc}} - F_{\\text{exact}} \\right|$.\n- Task B (Naive Vertex-Centered Method):\n    - Naive vertex-centered absolute imbalance: $E_{\\mathrm{vn}} = \\left| -k a \\cdot h_f \\right|$.\n- Task C (Modified Vertex-Centered Method):\n    - Modified vertex-centered residual: $E_{\\mathrm{vm}} = 0$.\n- Parameters for all test cases: $b = 0.7$, $c = -0.2$.\n- Test Cases $(h_f, k, a)$:\n    1. $(1.0, 1.0, 1.5)$\n    2. $(0.5, 3.0, -2.0)$\n    3. $(2.0, 0.7, 0.0)$\n    4. $(10^{-3}, 5.0, 4.0)$\n\nStep 2: Validate Using Extracted Givens\nThe problem is scientifically grounded, dealing with standard discretization methods (Finite Volume Method) for a fundamental elliptic partial differential equation. It is well-posed, providing a clear set of calculations to be performed. The language is objective and precise, using established terminology from computational engineering. All necessary parameters and formulas are provided, and there are no internal contradictions. The setup represents a common scenario in numerical grid generation (nonconforming mesh refinement) and the use of a manufactured solution for code verification is a standard technique. The problem is valid.\n\nStep 3: Verdict and Action\nThe problem is valid. A complete solution will be provided.\n\nThe objective is to compute the error triplet $\\left(E_{\\mathrm{cc}}, E_{\\mathrm{vn}}, E_{\\mathrm{vm}}\\right)$ for several sets of parameters.\n\nFirst, we derive a general expression for the cell-centered error, $E_{\\mathrm{cc}}$.\nThe given manufactured solution is $u(x,y) = a x + b y + c$. We evaluate this at the three cell centers:\n- Coarse cell center $C_0$ at $(x_0, y_0) = (-h_f, 0)$:\n$$u_0 = u(-h_f, 0) = a(-h_f) + b(0) + c = -a h_f + c$$\n- Upper fine cell center $C_1$ at $(x_1, y_1) = (h_f/2, h_f/2)$:\n$$u_1 = u(h_f/2, h_f/2) = a(h_f/2) + b(h_f/2) + c = \\frac{a h_f}{2} + \\frac{b h_f}{2} + c$$\n- Lower fine cell center $C_2$ at $(x_2, y_2) = (h_f/2, -h_f/2)$:\n$$u_2 = u(h_f/2, -h_f/2) = a(h_f/2) + b(-h_f/2) + c = \\frac{a h_f}{2} - \\frac{b h_f}{2} + c$$\n\nThe transmissibility $T$ is defined as $T = \\frac{k A}{d}$. With subface area (length in 2D) $A=h_f$ and center-to-center distance $d = \\frac{h_c}{2} + \\frac{h_f}{2} = \\frac{2 h_f}{2} + \\frac{h_f}{2} = \\frac{3}{2} h_f$, we obtain:\n$$T = \\frac{k h_f}{\\frac{3}{2} h_f} = \\frac{2k}{3}$$\n\nNow, we compute the numerical fluxes from the coarse cell $C_0$ to the fine cells $C_1$ and $C_2$.\nThe flux to the upper fine cell is $F_{0 \\to 1} = -T(u_1 - u_0)$:\n$$F_{0 \\to 1} = -\\frac{2k}{3} \\left[ \\left(\\frac{a h_f}{2} + \\frac{b h_f}{2} + c\\right) - (-a h_f + c) \\right]$$\n$$F_{0 \\to 1} = -\\frac{2k}{3} \\left[ \\frac{3a h_f}{2} + \\frac{b h_f}{2} \\right] = -k \\left( a h_f + \\frac{b h_f}{3} \\right)$$\nThe flux to the lower fine cell is $F_{0 \\to 2} = -T(u_2 - u_0)$:\n$$F_{0 \\to 2} = -\\frac{2k}{3} \\left[ \\left(\\frac{a h_f}{2} - \\frac{b h_f}{2} + c\\right) - (-a h_f + c) \\right]$$\n$$F_{0 \\to 2} = -\\frac{2k}{3} \\left[ \\frac{3a h_f}{2} - \\frac{b h_f}{2} \\right] = -k \\left( a h_f - \\frac{b h_f}{3} \\right)$$\n\nThe total cell-centered numerical flux $F_{\\text{cc}}$ across the interface is the sum:\n$$F_{\\text{cc}} = F_{0 \\to 1} + F_{0 \\to 2} = -k \\left( a h_f + \\frac{b h_f}{3} \\right) - k \\left( a h_f - \\frac{b h_f}{3} \\right)$$\n$$F_{\\text{cc}} = -k a h_f - \\frac{k b h_f}{3} - k a h_f + \\frac{k b h_f}{3} = -2 k a h_f$$\n\nThe exact integrated flux is given as $F_{\\text{exact}} = -2 k a h_f$.\nThe cell-centered absolute error $E_{\\mathrm{cc}}$ is:\n$$E_{\\mathrm{cc}} = |F_{\\text{cc}} - F_{\\text{exact}}| = |(-2 k a h_f) - (-2 k a h_f)| = 0$$\nThis demonstrates a key property: for a linear field, the two-point flux approximation on this symmetric nonconforming interface is exact. The discretization errors due to the $y$-component of the field ($b$-term) on the upper and lower sub-interfaces cancel perfectly. Therefore, for all test cases, $E_{\\mathrm{cc}} = 0$.\n\nNext, we address the vertex-centered quantities.\nFor the naive vertex-centered scheme, the imbalance is given directly:\n$$E_{\\mathrm{vn}} = \\left| -k a h_f \\right| = \\left|k a h_f\\right|$$\nThis term represents the flux through the central part of the interface that is not accounted for when fluxes are only attributed to the primary coarse-grid vertices, thus ignoring the hanging node.\n\nFor the modified vertex-centered scheme, the problem states that the modification recovers the correct flux for a linear field. Thus, the residual/error is zero by definition for this test:\n$$E_{\\mathrm{vm}} = 0$$\n\nNow we apply these general formulas to each test case. Note that parameters $b=0.7$ and $c=-0.2$ do not appear in the final error expressions.\n\nCase 1: $(h_f, k, a) = (1.0, 1.0, 1.5)$\n- $E_{\\mathrm{cc}} = 0$\n- $E_{\\mathrm{vn}} = |1.0 \\times 1.5 \\times 1.0| = 1.5$\n- $E_{\\mathrm{vm}} = 0$\nTriplet: $(0.0, 1.5, 0.0)$\n\nCase 2: $(h_f, k, a) = (0.5, 3.0, -2.0)$\n- $E_{\\mathrm{cc}} = 0$\n- $E_{\\mathrm{vn}} = |3.0 \\times (-2.0) \\times 0.5| = |-3.0| = 3.0$\n- $E_{\\mathrm{vm}} = 0$\nTriplet: $(0.0, 3.0, 0.0)$\n\nCase 3: $(h_f, k, a) = (2.0, 0.7, 0.0)$\n- $E_{\\mathrm{cc}} = 0$\n- $E_{\\mathrm{vn}} = |0.7 \\times 0.0 \\times 2.0| = 0.0$\n- $E_{\\mathrm{vm}} = 0$\nTriplet: $(0.0, 0.0, 0.0)$\n\nCase 4: $(h_f, k, a) = (10^{-3}, 5.0, 4.0)$\n- $E_{\\mathrm{cc}} = 0$\n- $E_{\\mathrm{vn}} = |5.0 \\times 4.0 \\times 10^{-3}| = |20.0 \\times 10^{-3}| = 0.02$\n- $E_{\\mathrm{vm}} = 0$\nTriplet: $(0.0, 0.02, 0.0)$\n\nThese results will be compiled into a single list for the final output.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes error metrics for cell-centered and vertex-centered schemes\n    on a nonconforming grid interface for a steady diffusion problem.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple (hf, k, a).\n    # Parameters b=0.7 and c=-0.2 are constant across tests but do not\n    # affect the final error calculations as shown in the derivation.\n    test_cases = [\n        (1.0, 1.0, 1.5),      # Case 1\n        (0.5, 3.0, -2.0),     # Case 2\n        (2.0, 0.7, 0.0),      # Case 3\n        (1.0e-3, 5.0, 4.0),   # Case 4\n    ]\n\n    results = []\n    for case in test_cases:\n        hf, k, a = case\n\n        # Task A: Cell-centered scheme (FVM)\n        # As derived in the solution, for a linear field u(x,y) = ax + by + c,\n        # the two-point flux approximation on this symmetric nonconforming interface\n        # is exact. The total numerical flux F_cc equals the exact flux F_exact.\n        # F_cc = -2*k*a*hf\n        # F_exact = -2*k*a*hf\n        # Therefore, E_cc = |F_cc - F_exact| = 0\n        E_cc = 0.0\n\n        # Task B: Naive vertex-centered scheme\n        # The imbalance is due to the flux through the unhandled central segment\n        # of the interface of length hf. The flux density is -k * du/dx = -k * a.\n        # The missing flux is (-k * a) * hf.\n        # The absolute imbalance is E_vn = |-k * a * hf|.\n        E_vn = abs(-k * a * hf)\n\n        # Task C: Modified vertex-centered scheme\n        # The problem states that with a hanging node constraint for a linear field,\n        # the method correctly accounts for the flux. The resulting residual or\n        # error is defined to be zero.\n        E_vm = 0.0\n\n        results.extend([E_cc, E_vn, E_vm])\n\n    # Final print statement in the exact required format.\n    # The list is flattened across test cases.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}