{
    "hands_on_practices": [
        {
            "introduction": "克雷洛夫子空间方法的核心在于构建一个由矩阵和向量生成的特殊子空间。这个练习 () 将带你亲手操作，使用 Gram-Schmidt 正交化过程为一个小规模问题构建克雷洛夫子空间 $\\mathcal{K}_2(A, b)$ 的标准正交基。这是理解如 GMRES 等更复杂算法如何运作的基础一步。",
            "id": "2214825",
            "problem": "在数值线性代数中，克雷洛夫子空间方法是用于求解大型线性方程组的迭代技术。像广义最小残差方法 (GMRES) 这类算法的一个关键组成部分是为克雷洛夫子空间构造一个标准正交基。维度为 $m$ 的克雷洛夫子空间，记作 $\\mathcal{K}_m(A, b)$，被定义为向量 $\\{b, Ab, A^2b, \\dots, A^{m-1}b\\}$ 的线性张成空间。\n\n考虑一个线性系统 $Ax=b$，其中的矩阵 $A$ 和初始向量 $b$ 如下所示：\n$$A = \\begin{pmatrix} 1   2  0 \\\\ 0  1  3 \\\\ 1  0  1 \\end{pmatrix}, \\quad b = \\begin{pmatrix} 1 \\\\ 1 \\\\ 0 \\end{pmatrix}$$\n使用格拉姆-施密特过程为克雷洛夫子空间 $\\mathcal{K}_2(A, b)$ 构造一个标准正交基 $\\{q_1, q_2\\}$。该基是依次生成的，首先从向量 $v_1 = b$ 生成 $q_1$，然后使用向量 $v_2 = Ab$ 生成 $q_2$。为确保答案唯一，每个基向量 $q_i$ 的第一个非零分量必须为正。\n\n你的任务是提供矩阵 $Q_2 = [q_1 | q_2]$，其中 $q_1$ 和 $q_2$ 是构成标准正交基的列向量。请根据需要，使用分数和平方根将矩阵的元素表示为其精确的符号形式。",
            "solution": "我们对 $v_{1}=b$ 和 $v_{2}=Ab$ 使用欧几里得内积和经典格拉姆-施密特过程。\n\n首先，设 $v_{1}=b=\\begin{pmatrix}1\\\\1\\\\0\\end{pmatrix}$。其范数为\n$$\n\\|v_{1}\\|=\\sqrt{1^{2}+1^{2}+0^{2}}=\\sqrt{2}.\n$$\n将其单位化得到\n$$\nq_{1}=\\frac{v_{1}}{\\|v_{1}\\|}=\\begin{pmatrix}\\frac{1}{\\sqrt{2}} \\\\ \\frac{1}{\\sqrt{2}} \\\\ 0\\end{pmatrix},\n$$\n其第一个非零分量为正。\n\n接下来，计算 $v_{2}=Ab$。已知\n$$\nA=\\begin{pmatrix}1  2  0 \\\\ 0  1  3 \\\\ 1  0  1\\end{pmatrix},\\quad b=\\begin{pmatrix}1\\\\1\\\\0\\end{pmatrix},\n$$\n我们得到\n$$\nv_{2}=Ab=\\begin{pmatrix}3\\\\1\\\\1\\end{pmatrix}.\n$$\n将 $v_{2}$ 相对于 $q_{1}$ 进行正交化：\n$$\nh_{1,2}=q_{1}^{\\top}v_{2}=\\begin{pmatrix}\\frac{1}{\\sqrt{2}}  \\frac{1}{\\sqrt{2}}  0\\end{pmatrix}\\begin{pmatrix}3\\\\1\\\\1\\end{pmatrix}=\\frac{4}{\\sqrt{2}}=2\\sqrt{2}.\n$$\n形成正交分量\n$$\nu_{2}=v_{2}-h_{1,2}q_{1}=\\begin{pmatrix}3\\\\1\\\\1\\end{pmatrix}-2\\sqrt{2}\\begin{pmatrix}\\frac{1}{\\sqrt{2}} \\\\ \\frac{1}{\\sqrt{2}} \\\\ 0\\end{pmatrix}=\\begin{pmatrix}1\\\\-1\\\\1\\end{pmatrix}.\n$$\n将 $u_{2}$ 单位化：\n$$\n\\|u_{2}\\|=\\sqrt{1^{2}+(-1)^{2}+1^{2}}=\\sqrt{3},\\quad q_{2}=\\frac{u_{2}}{\\|u_{2}\\|}=\\begin{pmatrix}\\frac{1}{\\sqrt{3}} \\\\ -\\frac{1}{\\sqrt{3}} \\\\ \\frac{1}{\\sqrt{3}}\\end{pmatrix},\n$$\n其第一个非零分量也为正。\n\n因此，标准正交基矩阵为\n$$\nQ_{2}=\\begin{pmatrix}\n\\frac{1}{\\sqrt{2}}   \\frac{1}{\\sqrt{3}} \\\\\n\\frac{1}{\\sqrt{2}}   -\\frac{1}{\\sqrt{3}} \\\\\n0   \\frac{1}{\\sqrt{3}}\n\\end{pmatrix}.\n$$",
            "answer": "$$\\boxed{\\begin{pmatrix}\\frac{1}{\\sqrt{2}}  \\frac{1}{\\sqrt{3}} \\\\ \\frac{1}{\\sqrt{2}}  -\\frac{1}{\\sqrt{3}} \\\\ 0  \\frac{1}{\\sqrt{3}}\\end{pmatrix}}$$"
        },
        {
            "introduction": "共轭梯度（CG）法是求解对称正定线性系统的经典克雷洛夫子空间方法，但其应用有严格的前提条件。通过这个编程练习 ()，你将探索当这些条件不被满足时，例如当矩阵具有非正曲率（$p_k^\\top A p_k \\le 0$）时，CG 算法会如何以及为何会失效。这有助于深刻理解算法的适用范围及其内在的数学原理。",
            "id": "2407671",
            "problem": "给定形如 $A x = b$ 的线性方程组，其中 $A \\in \\mathbb{R}^{n \\times n}$ 是实对称矩阵。标准的共轭梯度（CG）法是为对称正定矩阵定义的，它产生的搜索方向 $p_k$ 和步长 $\\alpha_k$ 依赖于曲率量 $p_k^\\top A p_k$。请考虑以下计算任务。\n\n给定一个实对称矩阵 $A$、一个右端项 $b$、一个初始猜测值 $x_0 = 0$、一个容差 $\\varepsilon$ 以及最大迭代次数 $k_{\\max}$，编写一个程序，尝试使用标准的共轭梯度法求解 $A x = b$，并根据以下规则为每种情况返回一个状态码：\n\n- 如果方法在某次迭代 $k \\le k_{\\max}$ 时达到 $\\lVert r_k \\rVert_2 \\le \\varepsilon$，且从未遇到非正曲率，则返回 $1$。其中 $r_k = b - A x_k$ 是残差，$\\lVert \\cdot \\rVert_2$ 表示欧几里得范数。\n- 如果在任何迭代 $k$ 中，曲率量 $p_k^\\top A p_k \\le 0$，这表明违反了标准共轭梯度法固有的正定性要求，则返回 $0$。\n- 如果方法在完成 $k_{\\max}$ 次迭代后，既未满足 $\\lVert r_k \\rVert_2 \\le \\varepsilon$，也未遇到 $p_k^\\top A p_k \\le 0$ 的情况，则返回 $-1$。\n\n使用以下测试套件。在所有情况下，均使用初始猜测值 $x_0 = 0$、容差 $\\varepsilon = 10^{-10}$ 和最大迭代次数 $k_{\\max} = 10$。\n\n- 测试用例 $1$（对称正定，预期收敛）：\n  $$A_1 = \\begin{bmatrix} 4  1  0 \\\\ 1  3  1 \\\\ 0  1  2 \\end{bmatrix}, \\quad b_1 = \\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\end{bmatrix}.$$\n- 测试用例 $2$（对称半正定但奇异，表现出零曲率）：\n  $$A_2 = \\begin{bmatrix} 1  0 \\\\ 0  0 \\end{bmatrix}, \\quad b_2 = \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}.$$\n- 测试用例 $3$（对称不定，表现出负曲率）：\n  $$A_3 = \\begin{bmatrix} 1  2  0 \\\\ 2  1  0 \\\\ 0  0  3 \\end{bmatrix}, \\quad b_3 = \\begin{bmatrix} 1 \\\\ 0 \\\\ 0 \\end{bmatrix}.$$\n\n你的程序应生成单行输出，其中包含按测试用例顺序排列的结果，格式为方括号内以逗号分隔的列表，例如：$[s_1,s_2,s_3]$，其中每个 $s_i \\in \\{-1,0,1\\}$ 是测试用例 $i$ 的状态码。",
            "solution": "所呈现的问题陈述是有效的。它在数值线性代数这一成熟领域具有科学依据，特别是在Krylov子空间方法方面。任务是实现标准的共轭梯度（CG）算法，并监测其在应用于不一定为正定的对称矩阵时的行为。该问题是适定的、客观的且自洽的，提供了所有必需的矩阵、向量和参数（$x_0$、$\\varepsilon$、$k_{\\max}$），以便为每个测试用例生成唯一、确定的结果。指定的状态码对应于CG方法的已知失效模式或成功条件。因此，可以构建一个直接的解决方案。\n\n共轭梯度法是一种用于求解形如 $A x = b$ 的线性方程组的迭代算法，其中矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 是对称正定（SPD）的。该方法的收敛性和稳定性关键取决于正定性，正定性确保了曲率量 $p_k^\\top A p_k$ 始终为正。该项出现在步长 $\\alpha_k$ 的分母中，其正性保证了每一步都朝着二次型 $f(x) = \\frac{1}{2} x^\\top A x - b^\\top x$ 的最小值移动。\n\n标准CG算法定义如下。给定系统 $A x = b$、一个初始猜测值 $x_0$、一个容差 $\\varepsilon > 0$ 以及最大迭代次数 $k_{\\max}$。\n\n首先，我们在迭代 $k=0$ 时初始化状态变量：\n初始解给定为 $x_0 = 0$。\n初始残差为 $r_0 = b - A x_0 = b$。\n初始搜索方向设置为残差：$p_0 = r_0$。\n\n然后，算法进入一个迭代循环，从 $k = 0, 1, 2, \\ldots, k_{\\max}-1$。在每次迭代 $k$ 中，执行以下步骤：\n\n1.  计算矩阵向量积 $v_k = A p_k$。\n2.  计算曲率项，它是一个标量：$d_k = p_k^\\top v_k = p_k^\\top A p_k$。问题要求我们检查 $A$ 相对于当前搜索方向是否表现为正定矩阵。如果 $d_k \\le 0$，则正定性的假设被违反。算法无法以有意义的方式继续进行，因为步长 $\\alpha_k$ 将为负、零或无定义，从而偏离解。在这种情况下，我们必须终止并返回状态码 $0$。\n3.  如果曲率为正，则计算沿方向 $p_k$ 的最优步长：\n    $$ \\alpha_k = \\frac{r_k^\\top r_k}{p_k^\\top A p_k} $$\n4.  更新解向量：\n    $$ x_{k+1} = x_k + \\alpha_k p_k $$\n5.  更新残差。为了避免昂贵的重新计算（$r_{k+1} = b - A x_{k+1}$），我们使用一个递推公式：\n    $$ r_{k+1} = r_k - \\alpha_k A p_k = r_k - \\alpha_k v_k $$\n6.  检查收敛性。我们计算新残差的欧几里得范数 $\\lVert r_{k+1} \\rVert_2$。如果 $\\lVert r_{k+1} \\rVert_2 \\le \\varepsilon$，则认为解已足够精确。我们终止并返回状态码 $1$。\n7.  如果方法尚未收敛，我们通过计算一个新的、与前一个搜索方向 $p_k$ A-正交的搜索方向 $p_{k+1}$ 来为下一次迭代做准备。这首先通过计算系数 $\\beta_k$ 来完成：\n    $$ \\beta_k = \\frac{r_{k+1}^\\top r_{k+1}}{r_k^\\top r_k} $$\n8.  然后，新的搜索方向是新残差和旧搜索方向的线性组合：\n    $$ p_{k+1} = r_{k+1} + \\beta_k p_k $$\n\n如果在 $k_{\\max}$ 次迭代完成后，残差范数既没有降到容差 $\\varepsilon$ 以下，也从未遇到非正曲率，则该方法在给定的迭代限制内未能收敛。在这种情况下，我们返回状态码 $-1$。\n\n在实现时，我们创建一个函数，该函数接收 $A$、$b$、$x_0$、$\\varepsilon$ 和 $k_{\\max}$ 作为输入。在主循环之前，我们计算初始残差 $r_0$ 并检查其范数 $\\lVert r_0 \\rVert_2$。如果它已经小于或等于 $\\varepsilon$，我们可以立即返回状态码 $1$。否则，我们继续执行上述迭代过程。提供的三个测试用例中的每一个都旨在触发三种指定结果之一：\n-   测试用例 1：$A_1$ 是一个对称正定矩阵。其所有特征值均为正，这保证了对于任何非零向量 $p$，$p^\\top A_1 p > 0$。CG方法预计将在几次迭代内收敛到解。状态码将为 $1$。\n-   测试用例 2：$A_2$ 是一个对称半正定矩阵，因为它的特征值为 $1$ 和 $0$。它是奇异的。CG算法可能会生成一个位于 $A_2$ 零空间中的搜索方向，这会导致曲率项 $p_k^\\top A_2 p_k = 0$。这将终止算法并产生状态码 $0$。\n-   测试用例 3：$A_3$ 是一个对称不定矩阵，同时具有正特征值和负特征值。CG方法不保证能维持正曲率。可能会生成一个搜索方向 $p_k$，使得 $p_k^\\top A_3 p_k  0$。这种情况也违反了标准CG方法的前提，需要以状态码 $0$ 终止。\n\n程序将对这三个测试用例中的每一个执行此逻辑，并报告所得的状态码。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef conjugate_gradient_with_status(A, b, x0, tol, k_max):\n    \"\"\"\n    Attempts to solve Ax=b using the Conjugate Gradient method with specific status reporting.\n\n    Args:\n        A (np.ndarray): A real symmetric matrix.\n        b (np.ndarray): The right-hand side vector.\n        x0 (np.ndarray): The initial guess for the solution.\n        tol (float): The tolerance for the residual norm.\n        k_max (int): The maximum number of iterations.\n\n    Returns:\n        int: Status code (1: converged, 0: non-positive curvature, -1: max iterations reached).\n    \"\"\"\n    x = x0.copy().astype(float)\n    r = b - A @ x\n    p = r.copy()\n    \n    # Check initial residual norm for trivial convergence\n    r_norm = np.linalg.norm(r)\n    if r_norm = tol:\n        return 1\n\n    rs_old = np.dot(r, r)\n\n    for k in range(k_max):\n        Ap = A @ p\n        \n        # Calculate curvature: p^T * A * p\n        curvature = np.dot(p, Ap)\n        \n        # Check for non-positive curvature (breakdown of CG)\n        if curvature = 0:\n            return 0  # Status for non-positive definite behavior\n        \n        # Update solution and residual\n        alpha = rs_old / curvature\n        x += alpha * p\n        r -= alpha * Ap\n        \n        # Check for convergence\n        r_norm = np.linalg.norm(r)\n        if r_norm = tol:\n            return 1  # Status for successful convergence\n        \n        # Update search direction\n        rs_new = np.dot(r, r)\n        beta = rs_new / rs_old\n        p = r + beta * p\n        rs_old = rs_new\n        \n    return -1 # Status for exceeding max iterations without convergence\n\ndef solve():\n    \"\"\"\n    Defines and runs the test cases for the Conjugate Gradient problem.\n    \"\"\"\n    # Define global parameters for all test cases\n    x0_val = 0.0  # Scalar, will be broadcast to vector of zeros\n    tol = 1e-10\n    k_max = 10\n\n    # Test Case 1: Symmetric Positive Definite\n    A1 = np.array([[4, 1, 0], \n                   [1, 3, 1], \n                   [0, 1, 2]], dtype=float)\n    b1 = np.array([1, 2, 3], dtype=float)\n\n    # Test Case 2: Symmetric Positive Semidefinite (Singular)\n    A2 = np.array([[1, 0], \n                   [0, 0]], dtype=float)\n    b2 = np.array([1, 1], dtype=float)\n\n    # Test Case 3: Symmetric Indefinite\n    A3 = np.array([[1, 2, 0], \n                   [2, 1, 0], \n                   [0, 0, 3]], dtype=float)\n    b3 = np.array([1, 0, 0], dtype=float)\n    \n    test_cases = [\n        (A1, b1),\n        (A2, b2),\n        (A3, b3),\n    ]\n\n    results = []\n    for A, b in test_cases:\n        n = A.shape[0]\n        x0 = np.full(n, x0_val, dtype=float)\n        status = conjugate_gradient_with_status(A, b, x0, tol, k_max)\n        results.append(status)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "理论上等价的算法在有限精度计算中可能表现出截然不同的数值稳定性。这个高级编程练习 () 聚焦于 Arnoldi 过程的核心——正交化，通过比较经典 Gram-Schmidt（CGS）和修正 Gram-Schmidt（MGS）过程，你将直观地看到后者在维持基向量正交性方面的优越性。这揭示了在实现迭代方法时，选择数值稳定的算法是何等重要。",
            "id": "2407638",
            "problem": "给定方形实数矩阵和一个初始向量，你必须数值量化当 Arnoldi 过程中的正交化分别使用经典 Gram–Schmidt (CGS) 或修正 Gram–Schmidt (MGS) 方法时，所生成的 Arnoldi 基的正交性损失。考虑广义最小残差 (GMRES) 方法，该方法为 Krylov 子空间构建一个 Arnoldi 基。对于一个实数矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 和一个非零初始向量 $r_0 \\in \\mathbb{R}^n$，定义 $k$ 阶 Krylov 子空间为\n$$\n\\mathcal{K}_k(A,r_0) = \\operatorname{span}\\{r_0, A r_0, A^2 r_0, \\dots, A^{k-1} r_0\\}.\n$$\n设 $Q_k \\in \\mathbb{R}^{n \\times m}$ 是一个矩阵，其列是在尝试生成 $\\mathcal{K}_k(A,r_0)$ 的标准正交基时产生的前 $m$ 个 Arnoldi 向量，其中 $m \\le k$ 的情况是由于中断而提前终止。定义正交性损失度量为\n$$\n\\ell(Q_k) = \\left\\| I_m - Q_k^\\top Q_k \\right\\|_F,\n$$\n其中 $\\|\\cdot\\|_F$ 表示 Frobenius 范数，$I_m$ 是 $m \\times m$ 的单位矩阵。对于下述每个测试用例，计算两个实数：$\\ell_{\\mathrm{CGS}} = \\ell(Q_k^{\\mathrm{CGS}})$ 和 $\\ell_{\\mathrm{MGS}} = \\ell(Q_k^{\\mathrm{MGS}})$，它们分别是在 Arnoldi 过程中使用经典 Gram–Schmidt 和修正 Gram–Schmidt 进行标准正交化时获得的结果。\n\n使用双精度算术。对于所有测试用例，使用初始残差 $r_0 = b \\in \\mathbb{R}^n$，其元素为 $b_i = \\sin(i)$，$i \\in \\{1,2,\\dots,n\\}$，其中正弦函数的角度单位是弧度。\n\n测试套件：\n- 用例 1 (对称正定三对角矩阵)：设 $n=50$，$k=25$，且 $A \\in \\mathbb{R}^{n \\times n}$ 定义为：$A_{i,i}=2$（$1 \\le i \\le n$），$A_{i,i+1}=A_{i+1,i}=-1$（$1 \\le i  n$），所有其他元素为 $0$。\n- 用例 2 (病态对角矩阵)：设 $n=60$，$k=30$，且 $A=\\operatorname{diag}(\\lambda_1,\\dots,\\lambda_n)$，其中 $\\lambda_i = 10^{\\alpha_i}$ 且 $\\alpha_i = -8 + \\dfrac{(i-1)\\cdot 8}{n-1}$（$1 \\le i \\le n$）。\n- 用例 3 (非正规上双对角矩阵)：设 $n=50$，$k=25$，且 $A \\in \\mathbb{R}^{n \\times n}$ 定义为：$A_{i,i}=1$（$1 \\le i \\le n$），$A_{i,i+1}=0.9$（$1 \\le i  n$），所有其他元素为 $0$。\n- 用例 4 (近亏损上双对角矩阵)：设 $n=40$，$k=35$，且 $A \\in \\mathbb{R}^{n \\times n}$ 定义为：$A_{i,i}=\\rho$（$\\rho=0.999$，$1 \\le i \\le n$），$A_{i,i+1}=1$（$1 \\le i  n$），所有其他元素为 $0$。\n\n你的程序必须为每个用例尝试从 $r_0=b$ 开始构建一个 $k$ 阶的 Arnoldi 基，为每种变体中实际构建的矩阵 $Q_k$（使用生成的前 $m$ 列，如果发生中断则 $m \\le k$）计算 $\\ell_{\\mathrm{CGS}}$ 和 $\\ell_{\\mathrm{MGS}}$，并以指定格式报告结果。\n\n最终输出格式：\n- 生成单行输出，包含一个有四个条目的列表，每个条目对应一个测试用例，并且是形式为 $[\\ell_{\\mathrm{CGS}},\\ell_{\\mathrm{MGS}}]$ 的双元素列表。\n- 每个实数必须四舍五入到 $10$ 位有效数字。\n- 该行不得包含任何空格。\n- 例如，一个有效的形式是 $[[x_{11},x_{12}],[x_{21},x_{22}],[x_{31},x_{32}],[x_{41},x_{42}]]$，其中每个 $x_{ij}$ 是一个四舍五入后的小数字符串。\n\n该问题不涉及物理单位。$b$ 的定义中所有角度都以弧度为单位。每个测试用例的最终答案必须是实数，且最终输出必须遵循上述单行格式。",
            "solution": "该问题要求在 Arnoldi 迭代的背景下，对两种正交化方案——经典 Gram-Schmidt (CGS) 和修正 Gram-Schmidt (MGS)——的稳定性进行数值比较。稳定性是通过测量一组定义明确的测试用例所生成的基的正交性损失来量化的。整个计算将使用双精度浮点算术进行。\n\nArnoldi 迭代是数值线性代数中的一个基本算法，用于为 Krylov 子空间 $\\mathcal{K}_k(A, r_0) = \\operatorname{span}\\{r_0, A r_0, \\dots, A^{k-1} r_0\\}$ 构建一个标准正交基。对于给定的矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 和初始向量 $r_0 \\in \\mathbb{R}^n$，该过程生成一个标准正交向量序列 $q_1, q_2, \\dots, q_k$，这些向量张成的空间是 $\\mathcal{K}_k(A, r_0)$。这些向量构成了矩阵 $Q_k = [q_1, q_2, \\dots, q_k] \\in \\mathbb{R}^{n \\times k}$ 的列。该过程首先将初始向量标准化：$q_1 = r_0 / \\|r_0\\|_2$。随后，对于 $j=1, 2, \\dots, k-1$，通过计算矩阵向量乘积 $v = A q_j$ 并将其与先前计算出的基向量 $\\{q_1, q_2, \\dots, q_j\\}$ 正交化来生成向量 $q_{j+1}$。这就是 Gram-Schmidt 过程。然后将得到的向量标准化。\n\n问题的核心在于此正交化步骤的实现。\n\n经典 Gram-Schmidt (CGS) 方法通过同时减去 $v=Aq_j$ 在所有现有基向量上的投影来计算新向量。首先，计算投影系数 $h_{i,j}$：\n$$\nh_{i,j} = q_i^T v \\quad \\text{for } i = 1, 2, \\dots, j.\n$$\n然后，通过减去基向量的线性组合来形成新向量 $\\hat{v}$：\n$$\n\\hat{v} = v - \\sum_{i=1}^{j} h_{i,j} q_i.\n$$\n最后，将此向量标准化以获得下一个基向量，$q_{j+1} = \\hat{v} / \\|\\hat{v}\\|_2$，其中范数 $\\|\\hat{v}\\|_2$ 对应于 Hessenberg 矩阵的元素 $h_{j+1,j}$。\n\n修正 Gram-Schmidt (MGS) 方法顺序地执行正交化。它不是将原始向量 $v$ 投影到每个基向量上，而是投影一个已经与之前的基向量正交的中间向量。设 $w^{(0)} = v = A q_j$。该过程对 $i=1, 2, \\dots, j$ 进行迭代：\n$$\nh_{i,j} = q_i^T w^{(i-1)},\n$$\n$$\nw^{(i)} = w^{(i-1)} - h_{i,j} q_i.\n$$\n$j$ 步后得到的向量是 $\\hat{v} = w^{(j)}$。然后将此向量标准化以得到 $q_{j+1} = \\hat{v} / \\|\\hat{v}\\|_2$。\n\n在精确算术中，CGS 和 MGS 是等价的。然而，在有限精度算术中，它们的数值性质有显著差异。由于舍入误差，计算出的基向量 $\\{q_i\\}$ 并非完全正交，即当 $i \\neq j$ 时，$q_i^T q_j \\neq 0$。在 CGS 中，所有的点积 $q_i^T v$ 都是用同一个向量 $v$ 计算的。如果基向量已经失去了一些正交性，误差会累积，导致一种称为灾难性抵消的现象。得到的向量 $\\hat{v}$ 可能会保留本应被移除的沿着 $q_1, \\dots, q_j$ 方向上的显著分量。MGS 更稳定，因为被正交化的向量在每一步都会更新。计算 $q_i^T w^{(i-1)}$ 使用的是一个已经与 $\\{q_1, \\dots, q_{i-1}\\}$ 数值上正交的向量，这减少了舍入误差的传播，并在更高程度上保持了基向量的正交性。\n\n我们被要求使用度量来量化这种正交性损失\n$$\n\\ell(Q_m) = \\| I_m - Q_m^T Q_m \\|_F,\n$$\n其中 $Q_m \\in \\mathbb{R}^{n \\times m}$ 是由 $m$ 个生成的 Arnoldi 向量组成的矩阵（在发生中断时 $m \\le k$），$I_m$ 是 $m \\times m$ 的单位矩阵，$\\|\\cdot\\|_F$ 是 Frobenius 范数。对于一个完全标准正交的基，$Q_m^T Q_m = I_m$ 且 $\\ell(Q_m) = 0$。偏离零的值表示正交性的损失。\n\n求解策略如下：\n1. 对于每个测试用例，构建指定的矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 和初始向量 $r_0 = b \\in \\mathbb{R}^n$，其中 $b_i = \\sin(i)$，$i=1,\\dots,n$。\n2. 实现指定步数 $k$ 的 Arnoldi 迭代。该实现将包括 CGS 和 MGS 两种正交化变体。\n3. 该过程必须能够检测中断，当中断发生时，待标准化向量的范数 $h_{j+1,j}$ 会低于一个很小的容差。如果中断在第 $j$ 步发生，过程将终止，产生一个维数为 $m=j$ 的基。问题规定最大步数为 $k$，因此最终的基将有 $m \\le k$ 个向量。\n4. 对于每个用例和每种方法（CGS 和 MGS），生成基矩阵 $Q_m$。\n5. 为 $Q_m^{\\mathrm{CGS}}$ 和 $Q_m^{\\mathrm{MGS}}$ 计算正交性损失度量 $\\ell(Q_m)$。",
            "answer": "```python\nimport numpy as np\n\ndef format_num(n):\n    \"\"\"Formats a number to 10 significant digits for the final output.\"\"\"\n    return \"{:.10g}\".format(n)\n\ndef arnoldi_process(A, r0, k, method):\n    \"\"\"\n    Performs the Arnoldi iteration to generate an orthonormal basis Q for the\n    Krylov subspace K_k(A, r0).\n\n    Args:\n        A (np.ndarray): The matrix of size (n, n).\n        r0 (np.ndarray): The starting vector of size (n,).\n        k (int): The number of Arnoldi vectors to generate.\n        method (str): The orthogonalization method, either 'cgs' or 'mgs'.\n    \n    Returns:\n        np.ndarray: A matrix Q of size (n, m) with m = k orthonormal columns.\n    \"\"\"\n    n = A.shape[0]\n    # Use double precision explicitly as required\n    Q = np.zeros((n, k), dtype=np.float64)\n    # A small tolerance for breakdown detection.\n    tol = 1e-12\n\n    norm_r0 = np.linalg.norm(r0)\n    if norm_r0  tol:\n        # r0 is effectively the zero vector, Krylov subspace is trivial.\n        return np.zeros((n, 0), dtype=np.float64)\n\n    Q[:, 0] = r0 / norm_r0\n    m = 1  # Number of vectors generated so far\n\n    for j in range(k - 1):\n        v = A @ Q[:, j]\n        \n        # Orthogonalization against the current basis Q[:, :m], where m = j + 1\n        if method == 'cgs':\n            # Classical Gram-Schmidt\n            h = Q[:, :m].T @ v\n            w = v - Q[:, :m] @ h\n        \n        elif method == 'mgs':\n            # Modified Gram-Schmidt\n            w = v.copy()\n            for i in range(m):\n                # h_ij = q_i^T w\n                h_ij = Q[:, i].T @ w\n                # w = w - h_ij * q_i\n                w = w - h_ij * Q[:, i]\n        else:\n            raise ValueError(\"Method must be 'cgs' or 'mgs'\")\n            \n        h_next = np.linalg.norm(w)\n        \n        if h_next  tol:\n            # Breakdown: The Krylov subspace has dimension m and is invariant under A.\n            return Q[:, :m]\n        \n        Q[:, j + 1] = w / h_next\n        m += 1\n        \n    return Q[:, :m]\n\ndef solve():\n    \"\"\"\n    Solves the problem by running Arnoldi with CGS and MGS for each test case\n    and printing the results in the specified format.\n    \"\"\"\n    test_cases_params = [\n        {'n': 50, 'k': 25, 'id': 'case1'},\n        {'n': 60, 'k': 30, 'id': 'case2'},\n        {'n': 50, 'k': 25, 'id': 'case3'},\n        {'n': 40, 'k': 35, 'id': 'case4'}\n    ]\n\n    all_results = []\n\n    for params in test_cases_params:\n        n, k, case_id = params['n'], params['k'], params['id']\n        \n        # Construct matrix A for the current test case\n        if case_id == 'case1': # symmetric positive definite tridiagonal\n            A = np.diag(np.full(n, 2.0, dtype=np.float64)) + \\\n                np.diag(np.full(n - 1, -1.0, dtype=np.float64), k=1) + \\\n                np.diag(np.full(n - 1, -1.0, dtype=np.float64), k=-1)\n        elif case_id == 'case2': # ill-conditioned diagonal\n            i = np.arange(1, n + 1, dtype=np.float64)\n            alphas = -8.0 + (i - 1.0) * 8.0 / (n - 1.0)\n            lambdas = 10.0**alphas\n            A = np.diag(lambdas)\n        elif case_id == 'case3': # non-normal upper bidiagonal\n            A = np.diag(np.full(n, 1.0, dtype=np.float64)) + \\\n                np.diag(np.full(n - 1, 0.9, dtype=np.float64), k=1)\n        elif case_id == 'case4': # nearly defective upper bidiagonal\n            rho = 0.999\n            A = np.diag(np.full(n, rho, dtype=np.float64)) + \\\n                np.diag(np.full(n - 1, 1.0, dtype=np.float64), k=1)\n\n        # Construct initial vector b (r0)\n        i_vec = np.arange(1, n + 1, dtype=np.float64)\n        r0 = np.sin(i_vec)\n\n        case_results = []\n        for method in ['cgs', 'mgs']:\n            Q = arnoldi_process(A, r0, k, method)\n            m = Q.shape[1]\n            \n            if m == 0:\n                loss = 0.0\n            else:\n                I_m = np.eye(m, dtype=np.float64)\n                loss_matrix = I_m - Q.T @ Q\n                loss = np.linalg.norm(loss_matrix, 'fro')\n            case_results.append(loss)\n        \n        all_results.append(case_results)\n\n    # Format the final output string exactly as required\n    list_of_strs = []\n    for pair in all_results:\n        cgs_str = format_num(pair[0])\n        mgs_str = format_num(pair[1])\n        list_of_strs.append(f\"[{cgs_str},{mgs_str}]\")\n    \n    final_output_str = f\"[{','.join(list_of_strs)}]\"\n    print(final_output_str)\n\nsolve()\n```"
        }
    ]
}