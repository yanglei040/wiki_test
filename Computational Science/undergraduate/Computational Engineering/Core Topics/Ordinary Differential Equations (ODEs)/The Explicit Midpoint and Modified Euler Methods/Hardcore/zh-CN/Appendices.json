{
    "hands_on_practices": [
        {
            "introduction": "理解数值方法的一个好方法是在一个简单、已知的模型上进行测试。本练习将显式中点法和改进欧拉法应用于一个代表阻尼振荡器的线性系统 $y' = Ay$。您的任务是计算全局误差，并在此过程中揭示这两种方法在这种特定情况下的一个深刻联系 。",
            "id": "2444104",
            "problem": "考虑线性自治常微分方程 (ODE) 系统 $y'(t) = A y(t)$，其中 $A$ 是一个常实数 $2 \\times 2$ 矩阵，其特征值为具有负实部的复数，对应于一个欠阻尼振子。设初始条件为 $y(0) = y_0 \\in \\mathbb{R}^2$。其精确解为 $y(t) = \\exp(A t)\\, y_0$，其中 $\\exp(\\cdot)$ 表示矩阵指数。\n\n您需要为几组参数集，在使用显式中点法和修正欧拉法，在步长为 $h$ 的均匀网格上对系统进行数值积分时，计算在最终时间 $T$ 的全局误差。全局误差定义为在 $t = T$ 时，数值解与精确解之差的欧几里得二范数。本问题无需物理单位，并且所有角度（如果在您的内部推导中出现）均以弧度为单位。\n\n对于下面的每个测试用例，系统矩阵 $A$ 表示一个阻尼振子，其自然频率为 $\\omega  0$，阻尼比为 $\\zeta \\in (0,1)$，由下式给出\n$$\nA(\\omega,\\zeta) = \\begin{bmatrix}\n0   1 \\\\\n-\\omega^2   -2 \\zeta \\omega\n\\end{bmatrix},\n$$\n初始条件为 $y_0 = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}$，并指定了最终时间 $T$ 和步长 $h$。假设比率 $T/h$ 是一个正整数，以便采取 $N = T/h$ 个均匀步长。\n\n对于每个测试用例，计算两个浮点数：\n- $E_{\\text{mid}}$：当在 $N$ 步上使用步长为 $h$ 的显式中点法时，在 $t=T$ 处的全局误差。\n- $E_{\\text{mod}}$：当在 $N$ 步上使用步长为 $h$ 的修正欧拉法时，在 $t=T$ 处的全局误差。\n\n使用欧几里得二范数计算误差。精确值 $y(T)$ 必须通过矩阵指数 $y(T) = \\exp(A T) y_0$ 计算。将每个误差报告为浮点十进制数。\n\n测试套件：\n1. $(\\omega, \\zeta, T, h) = (5.0, 0.1, 2.0, 0.01)$\n2. $(\\omega, \\zeta, T, h) = (5.0, 0.1, 1.0, 0.2)$\n3. $(\\omega, \\zeta, T, h) = (10.0, 0.999, 0.5, 0.005)$\n4. $(\\omega, \\zeta, T, h) = (40.0, 0.2, 1.0, 0.002)$\n5. $(\\omega, \\zeta, T, h) = (5.0, 0.1, 2.0, 0.001)$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须为每个测试用例包含一个条目，顺序与上面列出的顺序相同。每个条目本身必须是一个形式为 $[E_{\\text{mid}}, E_{\\text{mod}}]$ 的双元素列表。例如，整体输出格式为\n$[[E_{\\text{mid}}^{(1)},E_{\\text{mod}}^{(1)}],[E_{\\text{mid}}^{(2)},E_{\\text{mod}}^{(2)}],\\dots,[E_{\\text{mid}}^{(5)},E_{\\text{mod}}^{(5)}]]$,\n其中每个 $E_{\\text{mid}}^{(i)}$ 和 $E_{\\text{mod}}^{(i)}$ 都以十进制数报告。为便于呈现，可将每个数字四舍五入到十位小数。",
            "solution": "问题陈述已经过验证，并被确定为是合理的。它具有科学依据、是适定的、客观的，并包含了获得唯一解所需的所有信息。该问题描述了一个经典的阻尼谐振子系统，并要求比较两种标准数值积分方法的性能。\n\n**解的推导**\n\n该问题要求比较两种数值格式对于线性自治常微分方程 (ODE) 系统的全局误差：\n$$\n\\frac{dy}{dt} = A y(t), \\quad y(0) = y_0\n$$\n其中 $y(t) \\in \\mathbb{R}^2$ 且 $A \\in \\mathbb{R}^{2 \\times 2}$ 是一个常数矩阵。\n这两种数值方法是显式中点法和修正欧拉法。设 $y_n$ 是在时间 $t_n = n h$ 时对 $y(t_n)$ 的数值近似。定义 ODE 的函数是 $f(t,y) = A y$。由于该系统是自治的，$f$ 不显式依赖于 $t$。\n\n**1. 显式中点法**\n对于一个 ODE $y' = f(t,y)$，显式中点法的一般形式是：\n$$\nk_1 = f(t_n, y_n)\n$$\n$$\nk_2 = f(t_n + h/2, y_n + \\frac{h}{2} k_1)\n$$\n$$\ny_{n+1} = y_n + h k_2\n$$\n对于我们的线性系统，其中 $f(y) = A y$，步骤变为：\n$$\nk_1 = A y_n\n$$\n$$\nk_2 = A \\left( y_n + \\frac{h}{2} (A y_n) \\right) = A y_n + \\frac{h}{2} A^2 y_n = \\left( A + \\frac{h}{2} A^2 \\right) y_n\n$$\n将 $k_2$ 代入 $y_{n+1}$ 的更新规则中：\n$$\ny_{n+1} = y_n + h \\left( A + \\frac{h}{2} A^2 \\right) y_n = \\left( I + h A + \\frac{h^2}{2} A^2 \\right) y_n\n$$\n因此，从一步到下一步的传播由放大矩阵 $M_{\\text{mid}} = I + h A + \\frac{h^2}{2} A^2$ 控制。\n\n**2. 修正欧拉法 (Heun 法)**\n修正欧拉法的一般形式，也称为 Heun 法或显式梯形法则，是：\n$$\nk_1 = f(t_n, y_n)\n$$\n$$\nk_2 = f(t_n + h, y_n + h k_1)\n$$\n$$\ny_{n+1} = y_n + \\frac{h}{2} (k_1 + k_2)\n$$\n对于我们的线性系统，其中 $f(y) = A y$：\n$$\nk_1 = A y_n\n$$\n$$\nk_2 = A (y_n + h (A y_n)) = A y_n + h A^2 y_n = (A + h A^2) y_n\n$$\n将 $k_1$ 和 $k_2$ 代入 $y_{n+1}$ 的更新规则中：\n$$\ny_{n+1} = y_n + \\frac{h}{2} \\left( A y_n + (A + h A^2) y_n \\right) = y_n + \\frac{h}{2} (2 A y_n + h A^2 y_n)\n$$\n$$\ny_{n+1} = y_n + h A y_n + \\frac{h^2}{2} A^2 y_n = \\left( I + h A + \\frac{h^2}{2} A^2 \\right) y_n\n$$\n此方法的放大矩阵为 $M_{\\text{mod}} = I + h A + \\frac{h^2}{2} A^2$。\n\n**关于方法等价性的结论**\n对于线性自治 ODE 系统 $y' = A y$，显式中点法和修正欧拉法在数学上是等价的。两种方法产生相同的近似序列 $y_n$，因为它们的放大矩阵是相同的：\n$$\nM_{\\text{mid}} = M_{\\text{mod}} = I + h A + \\frac{h^2}{2} A^2\n$$\n该矩阵是精确单步传播算子 $\\exp(hA)$ 的泰勒级数展开式，并截断到二阶。因此，两种方法在最终时间 $T$ 的全局误差必须相同，即 $E_{\\text{mid}} = E_{\\text{mod}}$。\n\n**误差计算算法**\n对于每个测试用例 $(\\omega, \\zeta, T, h)$：\n1. 构造矩阵 $A$：\n   $$\n   A = \\begin{bmatrix}\n   0   1 \\\\\n   -\\omega^2   -2 \\zeta \\omega\n   \\end{bmatrix}\n   $$\n2.  定义初始条件 $y_0 = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}$。\n3.  计算步数 $N = T/h$，根据问题陈述，这必须是一个整数。\n4.  计算在 $t = T$ 时的精确解。初始值问题的精确解是 $y(t) = \\exp(At) y_0$。在最终时间 $T$，这是：\n   $$\n   y_{\\text{exact}} = \\exp(A T) y_0\n   $$\n   矩阵指数 $\\exp(A T)$ 将使用高精度库函数计算。\n5.  计算在 $t = T$ 时的数值解。设放大矩阵为 $M = I + h A + \\frac{h^2}{2} A^2$。经过 $N$ 步后，数值解为：\n   $$\n   y_{\\text{num}} = M^N y_0\n   $$\n   矩阵幂 $M^N$ 将被高效计算。\n6.  计算全局误差。误差是数值解与精确解之差的欧几里得范数：\n   $$\n   E = \\| y_{\\text{num}} - y_{\\text{exact}} \\|_2\n   $$\n7.  由于两种方法相同，我们设 $E_{\\text{mid}} = E$ 且 $E_{\\text{mod}} = E$。对所有五个测试用例重复此过程。\n\n实现将使用 `numpy` 进行矩阵运算，并使用 `scipy.linalg.expm` 计算矩阵指数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Computes the global error for two numerical methods on an ODE system\n    representing a damped oscillator.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (omega, zeta, T, h)\n    test_cases = [\n        (5.0, 0.1, 2.0, 0.01),\n        (5.0, 0.1, 1.0, 0.2),\n        (10.0, 0.999, 0.5, 0.005),\n        (40.0, 0.2, 1.0, 0.002),\n        (5.0, 0.1, 2.0, 0.001)\n    ]\n\n    all_results = []\n    for case in test_cases:\n        omega, zeta, T, h = case\n\n        # Construct the system matrix A\n        A = np.array([\n            [0.0, 1.0],\n            [-omega**2, -2.0 * zeta * omega]\n        ])\n\n        # Initial condition\n        y0 = np.array([1.0, 0.0])\n\n        # Number of steps N (guaranteed to be integer)\n        N = int(T / h)\n\n        # 1. Exact solution using matrix exponential\n        # y(T) = exp(A*T) * y0\n        y_exact_T = expm(A * T) @ y0\n\n        # 2. Numerical solution\n        # For a linear autonomous system y' = Ay, both the explicit midpoint\n        # and modified Euler methods use the same amplification matrix:\n        # M = I + hA + (h^2/2)A^2\n        I = np.identity(2)\n        A_squared = A @ A\n        M = I + h * A + (h**2 / 2.0) * A_squared\n\n        # The solution at T is y_N = M^N * y0\n        # np.linalg.matrix_power is efficient for this\n        y_numerical_T = np.linalg.matrix_power(M, N) @ y0\n\n        # 3. Global error calculation\n        # Error is the Euclidean 2-norm of the difference\n        error = np.linalg.norm(y_numerical_T - y_exact_T)\n\n        # Since E_mid and E_mod are identical for this problem, they are both equal to 'error'.\n        E_mid = error\n        E_mod = error\n        \n        all_results.append([E_mid, E_mod])\n\n    # Final print statement in the exact required format.\n    # Example format: [[E_mid^(1),E_mod^(1)],[E_mid^(2),E_mod^(2)],...]\n    formatted_results = []\n    for res_pair in all_results:\n        # The problem states it is acceptable to round to 10 decimal places.\n        formatted_pair_str = f\"[{res_pair[0]:.10f}, {res_pair[1]:.10f}]\"\n        formatted_results.append(formatted_pair_str)\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "许多物理和生物系统拥有守恒量，例如能量或本练习中的一个特殊不变量。本练习探讨了经典的 Lotka-Volterra 捕食者-猎物模型，并要求您研究数值解在长时间积分后的行为 。通过检查数值轨迹是保持闭合还是螺旋发散/收敛，您将能观察到两种方法在保持系统内在属性方面的关键质性差异。",
            "id": "2444171",
            "problem": "考虑一个二维 Lotka–Volterra 捕食者-猎物系统，该系统以常微分方程（ODE）的初值问题形式给出：\n$$\n\\begin{cases}\n\\dfrac{\\mathrm{d}x}{\\mathrm{d}t} = \\alpha x - \\beta x y,\\\\[6pt]\n\\dfrac{\\mathrm{d}y}{\\mathrm{d}t} = -\\gamma y + \\delta x y,\n\\end{cases}\n\\quad\n(x(0),y(0)) = (x_0,y_0),\n$$\n其中 $\\alpha0$、$\\beta0$、$\\gamma0$、$\\delta0$，且 $(x(t),y(t))$ 分别表示猎物和捕食者的种群数量。对于该连续系统，具有正初始数据的非平凡轨迹保持在唯一的正平衡点\n$$\n(x^\\ast,y^\\ast) = \\left(\\dfrac{\\gamma}{\\delta}, \\dfrac{\\alpha}{\\beta}\\right).\n$$\n周围的闭合水平集上。\n将该系统的不变量候选项（首次积分）定义为\n$$\nH(x,y) = \\delta x - \\gamma \\ln x + \\beta y - \\alpha \\ln y,\n$$\n对于 $x0$，$y0$，该不变量沿精确解是恒定的。您将对轨迹进行数值近似，并通过检查 $H$ 的变化来诊断离散轨迹是形成闭合环路还是向内/向外螺旋。\n\n您的任务是编写一个完整的程序，对每个测试用例，使用以下两种不同的二阶龙格-库塔（RK）方法之一来推进系统：显式中点法或改进欧拉法（Heun 法）。对于给定的时间步长 $h0$ 和一个正整数的名义振荡周期数 $P$，积分总时间 $T_{\\text{int}}$ 定义为\n$$\nT_{\\text{int}} = P \\cdot \\dfrac{2\\pi}{\\sqrt{\\alpha \\gamma}},\n$$\n并使用 $N = \\left\\lfloor \\dfrac{T_{\\text{int}}}{h} + \\tfrac{1}{2}\\right\\rfloor$ 个大小为 $h$ 的时间步来覆盖此区间。令 $H_0 = H(x_0,y_0)$ 和 $H_N = H(x_N,y_N)$ 分别表示数值轨迹起点和终点处的 $H$ 值。\n\n分类规则：定义相对漂移\n$$\n\\rho = \\dfrac{H_N - H_0}{|H_0|}.\n$$\n使用容差 $\\tau = 0.01$（以十进制表示），对每个测试用例的轨迹进行如下分类：\n- 如果 $|\\rho| \\le \\tau$，则为闭合环路，编码为整数 $0$，\n- 如果 $\\rho  \\tau$，则为向外螺旋，编码为整数 $1$，\n- 如果 $\\rho  -\\tau$，则为向内螺旋，编码为整数 $-1$。\n\n您的程序必须分别实现这两种方法，并为每个测试用例应用指定的方法。\n\n测试套件：您的程序必须计算以下四个测试用例的分类。每个用例是一个形式为 $(m,\\alpha,\\beta,\\gamma,\\delta,x_0,y_0,h,P)$ 的元组，其中 $m$ 选择方法（$m=0$ 表示显式中点法，$m=1$ 表示改进欧拉法）。\n- 用例 1：$(0,\\,1,\\,1,\\,1,\\,1,\\,1.2,\\,0.8,\\,0.05,\\,30)$。\n- 用例 2：$(1,\\,1,\\,1,\\,1,\\,1,\\,1.2,\\,0.8,\\,0.05,\\,30)$。\n- 用例 3：$(0,\\,1,\\,1,\\,1,\\,1,\\,1.5,\\,0.6,\\,0.2,\\,30)$。\n- 用例 4：$(1,\\,1,\\,1,\\,1,\\,1,\\,1.5,\\,0.6,\\,0.2,\\,30)$。\n\n最终输出格式：您的程序应生成单行输出，其中包含四个用例的整数分类，以逗号分隔列表的形式并用方括号括起来，顺序与上述用例相同。例如，一个语法上有效的格式是像“[rA,rB,rC,rD]”这样的一行，其中 rA、rB、rC、rD 分别是 -1、0 或 1 之一。",
            "solution": "问题陈述是有效的。这是一个来自计算工程领域的适定初值问题，其基础是数学生物学和数值分析的既定原理。所有参数、条件和方法都得到了清晰明确的定义。\n\n该问题围绕 Lotka-Volterra 捕食者-猎物模型的数值积分展开，这是一个由两个耦合的一阶非线性常微分方程（ODE）组成的系统：\n$$\n\\frac{\\mathrm{d}x}{\\mathrm{d}t} = f_x(x,y) = \\alpha x - \\beta x y\n$$\n$$\n\\frac{\\mathrm{d}y}{\\mathrm{d}t} = f_y(x,y) = -\\gamma y + \\delta x y\n$$\n在这里，$x(t)$ 是猎物种群，$y(t)$ 是捕食者种群，参数 $\\alpha, \\beta, \\gamma, \\delta$ 是正常数。系统的初始状态由 $(x(0), y(0)) = (x_0, y_0)$ 给出。\n\n这个精确连续系统的一个显著特征是存在一个守恒量，或称首次积分，由下式给出：\n$$\nH(x,y) = \\delta x - \\gamma \\ln x + \\beta y - \\alpha \\ln y\n$$\n在任何 $x0$ 和 $y0$ 的精确解轨迹上，$H(x(t), y(t))$ 的值保持不变。这意味着解轨迹是函数 $H$ 在 $(x,y)$ 相空间中的闭合水平集曲线，代表周期性的种群循环。\n\n数值方法作为离散近似，通常无法精确保持这类不变量。累积的误差会导致数值轨迹或者向外螺旋（以 $H$ 衡量的“能量”增加），或者向内螺旋（“能量”减少）。这种现象被称为数值漂移。在积分区间内 $H$ 变化的符号和大小为数值解的长期定性行为提供了定量诊断。\n\n该任务要求实现两种不同的二阶龙格-库塔（RK）方法，以将解从初始状态 $\\mathbf{u}_n = [x_n, y_n]^T$ 推进到下一个状态 $\\mathbf{u}_{n+1}$，步长为 $h$。该常微分方程以向量形式表示为 $\\frac{\\mathrm{d}\\mathbf{u}}{\\mathrm{d}t} = \\mathbf{f}(\\mathbf{u})$。\n\n第一种方法（$m=0$）是**显式中点法**。其公式为：\n1. 计算起始点的斜率：\n$$\n\\mathbf{k}_1 = \\mathbf{f}(\\mathbf{u}_n)\n$$\n2. 使用 $\\mathbf{k}_1$ 估计时间间隔中点的状态，并计算该点的斜率：\n$$\n\\mathbf{k}_2 = \\mathbf{f}\\left(\\mathbf{u}_n + \\frac{h}{2}\\mathbf{k}_1\\right)\n$$\n3. 使用中点斜率 $\\mathbf{k}_2$ 更新状态：\n$$\n\\mathbf{u}_{n+1} = \\mathbf{u}_n + h \\mathbf{k}_2\n$$\n\n第二种方法（$m=1$）是**改进欧拉法**（也称为 Heun 法）：\n1. 计算起始点的斜率：\n$$\n\\mathbf{k}_1 = \\mathbf{f}(\\mathbf{u}_n)\n$$\n2. 使用 $\\mathbf{k}_1$ 进行一个初步的完整步（预测步），并计算此预测点的斜率：\n$$\n\\mathbf{k}_2 = \\mathbf{f}\\left(\\mathbf{u}_n + h \\mathbf{k}_1\\right)\n$$\n3. 使用初始斜率和预测斜率的平均值更新状态（校正步）：\n$$\n\\mathbf{u}_{n+1} = \\mathbf{u}_n + \\frac{h}{2}(\\mathbf{k}_1 + \\mathbf{k}_2)\n$$\n\n对于每个测试用例，模拟过程如下：\n1. 总积分时间 $T_{\\text{int}}$ 由 $P$ 个线性化系统的名义周期确定，$T_{\\text{int}} = P \\cdot \\frac{2\\pi}{\\sqrt{\\alpha\\gamma}}$。\n2. 步数 $N$ 通过对总时间与步长之比进行四舍五入计算得出：$N = \\left\\lfloor \\frac{T_{\\text{int}}}{h} + \\frac{1}{2}\\right\\rfloor$。\n3. 计算不变量的初始值 $H_0 = H(x_0, y_0)$。\n4. 应用所选的数值积分器进行 $N$ 步计算，以求得最终状态 $(x_N, y_N)$。\n5. 计算不变量的最终值 $H_N = H(x_N, y_N)$。\n6. 计算相对漂移 $\\rho = \\frac{H_N - H_0}{|H_0|}$。\n7. 根据 $\\rho$ 相对于容差 $\\tau = 0.01$ 的值对轨迹进行分类：\n    - **闭合环路（代码 $0$）：** 如果 $|\\rho| \\le \\tau$，则认为漂移可以忽略不计。\n    - **向外螺旋（代码 $1$）：** 如果 $\\rho  \\tau$，则数值能量显著增加。\n    - **向内螺旋（代码 $-1$）：** 如果 $\\rho  -tau$，则数值能量显著减少。\n\n该实现将对四个指定的测试用例应用此逻辑，方法由参数 $m$ 选择。最终输出包含每个测试用例的整数分类代码。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Lotka-Volterra problem for four test cases, classifies trajectory\n    behavior by analyzing the drift of a system invariant.\n    \"\"\"\n\n    def lotka_volterra_rhs(u, alpha, beta, gamma, delta):\n        \"\"\"\n        Computes the right-hand side of the Lotka-Volterra ODE system.\n        u: state vector [x, y]\n        alpha, beta, gamma, delta: system parameters\n        \"\"\"\n        x, y = u\n        dxdt = alpha * x - beta * x * y\n        dydt = -gamma * y + delta * x * y\n        return np.array([dxdt, dydt])\n\n    def invariant_H(u, alpha, beta, gamma, delta):\n        \"\"\"\n        Computes the invariant (first integral) H of the Lotka-Volterra system.\n        u: state vector [x, y]\n        alpha, beta, gamma, delta: system parameters\n        \"\"\"\n        x, y = u\n        # The problem statement ensures x > 0 and y > 0 for initial conditions.\n        # Trajectories of the LV system do not cross the axes.\n        return delta * x - gamma * np.log(x) + beta * y - alpha * np.log(y)\n\n    def explicit_midpoint_step(u_n, h, f_rhs, params):\n        \"\"\"\n        Performs a single step of the explicit midpoint method.\n        u_n: current state vector\n        h: time step\n        f_rhs: function for the ODE's right-hand side\n        params: tuple of system parameters (alpha, beta, gamma, delta)\n        \"\"\"\n        k1 = f_rhs(u_n, *params)\n        k2 = f_rhs(u_n + 0.5 * h * k1, *params)\n        u_n1 = u_n + h * k2\n        return u_n1\n\n    def modified_euler_step(u_n, h, f_rhs, params):\n        \"\"\"\n        Performs a single step of the modified Euler (Heun's) method.\n        u_n: current state vector\n        h: time step\n        f_rhs: function for the ODE's right-hand side\n        params: tuple of system parameters (alpha, beta, gamma, delta)\n        \"\"\"\n        k1 = f_rhs(u_n, *params)\n        k2 = f_rhs(u_n + h * k1, *params)\n        u_n1 = u_n + 0.5 * h * (k1 + k2)\n        return u_n1\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (m, alpha, beta, gamma, delta, x0, y0, h, P)\n        # m=0: explicit midpoint, m=1: modified Euler\n        (0, 1.0, 1.0, 1.0, 1.0, 1.2, 0.8, 0.05, 30),\n        (1, 1.0, 1.0, 1.0, 1.0, 1.2, 0.8, 0.05, 30),\n        (0, 1.0, 1.0, 1.0, 1.0, 1.5, 0.6, 0.2, 30),\n        (1, 1.0, 1.0, 1.0, 1.0, 1.5, 0.6, 0.2, 30),\n    ]\n\n    results = []\n    tau = 0.01  # Tolerance for classification\n\n    for case in test_cases:\n        m, alpha, beta, gamma, delta, x0, y0, h, P = case\n        \n        params = (alpha, beta, gamma, delta)\n        \n        # Set initial state vector\n        u_0 = np.array([x0, y0])\n        \n        # Calculate total integration time and number of steps\n        T_int = P * 2 * np.pi / np.sqrt(alpha * gamma)\n        # N = floor(T_int/h + 1/2) as per problem statement\n        N = int(T_int / h + 0.5)\n        \n        # Compute initial value of the invariant\n        H_0 = invariant_H(u_0, alpha, beta, gamma, delta)\n        \n        # Select the numerical method based on m\n        if m == 0:\n            stepper = explicit_midpoint_step\n        else:  # m == 1\n            stepper = modified_euler_step\n            \n        # Perform the numerical integration\n        u_current = u_0\n        for _ in range(N):\n            u_current = stepper(u_current, h, lotka_volterra_rhs, params)\n        u_N = u_current\n        \n        # Compute final value of the invariant\n        H_N = invariant_H(u_N, alpha, beta, gamma, delta)\n        \n        # Calculate the relative drift\n        rho = (H_N - H_0) / np.abs(H_0)\n        \n        # Classify the trajectory based on the drift\n        if np.abs(rho) = tau:\n            classification = 0\n        elif rho > tau:\n            classification = 1\n        else:  # rho  -tau\n            classification = -1\n            \n        results.append(classification)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "现在，让我们将所学方法应用于物理学中的一个经典非线性问题：大摆幅单摆。这个问题的周期没有简单的解析解。您的任务是数值积分单摆的运动方程，计算其振荡周期，并将两种方法的计算结果与精确的理论值进行比较，从而评估它们的定量准确性 。",
            "id": "2444127",
            "problem": "考虑一个在均匀重力 $g$ 下，长度为 $L$ 的单摆的非线性常微分方程（ODE）初值问题：\n$$\n\\theta''(t) \\;=\\; -\\frac{g}{L}\\,\\sin\\big(\\theta(t)\\big), \\quad \\theta(0) \\;=\\; \\theta_0,\\quad \\theta'(0) \\;=\\; 0,\n$$\n其中 $\\theta(t)$ 是以弧度为单位的角位移。引入状态向量 $\\mathbf{y}(t) = \\begin{bmatrix}\\theta(t) \\\\ \\omega(t)\\end{bmatrix}$，其中 $\\omega(t) = \\theta'(t)$，并将该二阶ODE重写为一阶系统\n$$\n\\mathbf{y}'(t) \\;=\\; \\mathbf{f}(t,\\mathbf{y}) \\;=\\; \\begin{bmatrix}\\omega \\\\[4pt] -\\dfrac{g}{L}\\sin(\\theta) \\end{bmatrix}.\n$$\n您的任务是实现两种二阶、显式、两阶段的龙格-库塔（RK）方法——显式中点法和改进欧拉法（也称为休恩法）——来近似大振幅摆动的完整振荡周期，并将计算出的周期与理论值进行比较。\n\n您可以假定以下基本知识为已知：ODE初值问题的定义，源自泰勒展开匹配至二阶的单步法概念，以及用第一类完全椭圆积分表示的非线性摆的已知理论周期。具体来说，振幅为 $\\theta_0$ 时的理论周期为\n$$\nT_{\\mathrm{th}}(\\theta_0;L,g) \\;=\\; 4\\sqrt{\\frac{L}{g}}\\,K\\!\\Big(m\\Big),\\quad m \\;=\\; \\sin^2\\!\\Big(\\frac{\\theta_0}{2}\\Big),\n$$\n其中第一类完全椭圆积分为\n$$\nK(m) \\;=\\; \\int_{0}^{\\pi/2} \\frac{1}{\\sqrt{1 - m\\sin^2\\phi}}\\; d\\phi.\n$$\n\n算法任务：\n- 为一阶系统 $\\mathbf{y}'=\\mathbf{f}(t,\\mathbf{y})$ 实现显式中点法和改进欧拉法。\n- 对于每种方法，给定 $(\\theta_0,L,g)$ 和一个固定的时间步长 $h$，从 $t=0$ 开始在时间上进行数值积分，直到您可以稳健地估计出从静止状态 $\\theta(0)=\\theta_0$ 开始的振荡周期 $T_{\\mathrm{num}}$。使用以下稳健规则：检测 $t0$ 后 $\\omega(t)$ 的前两个过零点（即 $\\omega$ 改变符号的时刻），在步长内进行线性时间插值以估计这些过零时间 $t_1$ 和 $t_2$，然后将完整周期估计为\n$$\nT_{\\mathrm{num}} \\;=\\; 2\\,(t_2 - t_1).\n$$\n- 对于每种方法，计算绝对相对误差\n$$\n\\varepsilon \\;=\\; \\frac{\\left|T_{\\mathrm{num}} - T_{\\mathrm{th}}\\right|}{T_{\\mathrm{th}}}\n$$\n作为一个无量纲的小数。\n\n角度必须以弧度为单位，长度以米为单位，重力以米/秒²为单位，时间以秒为单位。所有输出必须以十进制数报告。不使用百分号；如果您希望表达类似于百分比的内容，请以小数形式报告。\n\n测试套件：\n使用以下5组参数 $(\\theta_0,h,L,g)$，这些参数的选择旨在探测典型和具有挑战性的情况，包括大振幅和较粗的时间步长：\n- 情况1：$(\\theta_0,h,L,g) = (1.2,\\; 0.01,\\; 1.0,\\; 9.81)$。\n- 情况2：$(\\theta_0,h,L,g) = (2.8,\\; 0.01,\\; 1.0,\\; 9.81)$。\n- 情况3：$(\\theta_0,h,L,g) = (2.8,\\; 0.05,\\; 1.0,\\; 9.81)$。\n- 情况4：$(\\theta_0,h,L,g) = (0.1,\\; 0.02,\\; 1.0,\\; 9.81)$。\n- 情况5：$(\\theta_0,h,L,g) = (3.0,\\; 0.005,\\; 1.0,\\; 9.81)$。\n\n对于每种情况，您必须计算两个数：显式中点法的绝对相对误差和改进欧拉法的绝对相对误差，每个数都四舍五入到8位小数。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，列表包含5个方括号对，每个对方括号内的顺序为 $[\\varepsilon_{\\text{midpoint}},\\varepsilon_{\\text{modified\\_Euler}}]$，所有内容都包含在一个大方括号内。例如，一个语法正确、使用占位符数字的输出如下所示\n$$\n\\big[\\,[0.00000000,0.00000000],[0.00000000,0.00000000],[0.00000000,0.00000000],[0.00000000,0.00000000],[0.00000000,0.00000000]\\,\\big].\n$$\n您的程序必须严格遵循指定的测试套件，并且只打印这一行输出。不允许用户输入。所提供的代码必须是完整且可运行的。",
            "solution": "所述问题需要进行验证。\n\n**步骤1：提取已知条件**\n\n问题提供了以下信息：\n- 单摆的二阶常微分控制方程（ODE）：\n$$\n\\theta''(t) \\;=\\; -\\frac{g}{L}\\,\\sin\\big(\\theta(t)\\big)\n$$\n- 初始条件：\n$$\n\\theta(0) \\;=\\; \\theta_0,\\quad \\theta'(0) \\;=\\; 0\n$$\n- 状态向量定义 $\\mathbf{y}(t) = \\begin{bmatrix}\\theta(t) \\\\ \\omega(t)\\end{bmatrix}$，其中 $\\omega(t) = \\theta'(t)$。\n- 等效的一阶ODE系统：\n$$\n\\mathbf{y}'(t) \\;=\\; \\mathbf{f}(t,\\mathbf{y}) \\;=\\; \\begin{bmatrix}\\omega \\\\ -\\dfrac{g}{L}\\sin(\\theta) \\end{bmatrix}\n$$\n- 振幅为 $\\theta_0$ 时的理论周期 $T_{\\mathrm{th}}$：\n$$\nT_{\\mathrm{th}}(\\theta_0;L,g) \\;=\\; 4\\sqrt{\\frac{L}{g}}\\,K\\!\\Big(m\\Big),\\quad m \\;=\\; \\sin^2\\!\\Big(\\frac{\\theta_0}{2}\\Big)\n$$\n- 第一类完全椭圆积分的定义：\n$$\nK(m) \\;=\\; \\int_{0}^{\\pi/2} \\frac{1}{\\sqrt{1 - m\\sin^2\\phi}}\\; d\\phi\n$$\n- 数值任务涉及两种特定的二阶龙格-库塔方法：显式中点法和改进欧拉法（休恩法）。\n- 数值估计周期 $T_{\\mathrm{num}}$ 的规则：通过线性插值找到 $t  0$ 时 $\\omega(t)$ 的前两个过零点，记为 $t_1$ 和 $t_2$，然后计算 $T_{\\mathrm{num}} = 2(t_2 - t_1)$。\n- 绝对相对误差的定义：\n$$\n\\varepsilon \\;=\\; \\frac{\\left|T_{\\mathrm{num}} - T_{\\mathrm{th}}\\right|}{T_{\\mathrm{th}}}\n$$\n- 提供了五个测试用例，形式为 $(\\theta_0, h, L, g)$ 的元组：\n1. $(1.2, 0.01, 1.0, 9.81)$\n2. $(2.8, 0.01, 1.0, 9.81)$\n3. $(2.8, 0.05, 1.0, 9.81)$\n4. $(0.1, 0.02, 1.0, 9.81)$\n5. $(3.0, 0.005, 1.0, 9.81)$\n- 要求的输出格式是特定字符串表示的误差对列表。\n\n**步骤2：使用提取的已知条件进行验证**\n\n根据验证标准对问题进行评估。\n- **科学依据**：该问题基于经典力学（单摆）和数值分析（龙格-库塔方法）的原理。控制方程、其一阶表示形式以及周期的解析公式都是物理学和数学中标准且正确的结果。\n- **适定性**：这是一个适定的初值问题。函数 $\\mathbf{f}(t, \\mathbf{y})$ 是连续可微的，这保证了解的存在性和唯一性。计算数值周期及其误差的任务定义清晰，对于给定的方法和步长，会得到唯一的结果。\n- **客观性**：问题以精确、正式和客观的数学语言陈述。\n- **缺陷分析**：\n    1.  **科学或事实上的不健全性**：无。物理和数学基础是健全的。\n    2.  **非形式化或不相关**：无。该问题是数值方法在计算工程中的直接和具体应用。\n    3.  **不完整或矛盾的设置**：无。所有必要的组成部分都已提供：模型、方法、分析过程和测试数据。\n    4.  **不切实际或不可行**：无。物理参数和初始条件是现实的。初始振幅虽然很大，但在物理上是可以达到的（小于在 $\\theta = \\pi$ 处的不稳定平衡点）。\n    5.  **不适定或结构不良**：无。指令清晰明确。确定数值周期的方法是稳健的。\n    6.  **超出科学可验证范围**：无。结果是可通过计算验证的。\n\n**步骤3：结论与行动**\n\n问题是**有效的**。有必要提供完整解答。\n\n问题的核心是使用两种不同的数值方案求解一阶系统 $\\mathbf{y}' = \\mathbf{f}(t, \\mathbf{y})$ 的初值问题。状态向量为 $\\mathbf{y} = [\\theta, \\omega]^T$。一个通用的单步法将解从时间 $t_n$推进到 $t_{n+1} = t_n + h$，其形式为 $\\mathbf{y}_{n+1} = \\mathbf{y}_n + h \\Phi(t_n, \\mathbf{y}_n, h; \\mathbf{f})$，其中 $\\Phi$ 是增量函数。\n\n首先，我们定义两种所需的二阶、两阶段龙格-库塔方法。\n\n1.  **显式中点法**：通过在时间间隔的中点评估导数来计算增量，使用前向欧拉步来估计该中点处的状态。\n    更新规则是：\n    $$\n    \\mathbf{k}_1 = \\mathbf{f}(t_n, \\mathbf{y}_n)\n    $$\n    $$\n    \\mathbf{k}_2 = \\mathbf{f}\\left(t_n + \\frac{h}{2}, \\mathbf{y}_n + \\frac{h}{2}\\mathbf{k}_1\\right)\n    $$\n    $$\n    \\mathbf{y}_{n+1} = \\mathbf{y}_n + h\\mathbf{k}_2\n    $$\n\n2.  **改进欧拉法（休恩法）**：这是一种预测-校正方法。使用前向欧拉法（预测步）对 $\\mathbf{y}_{n+1}$ 进行初始预测，并使用此预测来估计区间末端的斜率。最终的更新（校正步）是区间开始和结束处斜率的平均值。\n    更新规则是：\n    $$\n    \\mathbf{k}_1 = \\mathbf{f}(t_n, \\mathbf{y}_n)\n    $$\n    $$\n    \\mathbf{k}_2 = \\mathbf{f}(t_n + h, \\mathbf{y}_n + h\\mathbf{k}_1)\n    $$\n    $$\n    \\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{h}{2}(\\mathbf{k}_1 + \\mathbf{k}_2)\n    $$\n\n为了评估这些方法的准确性，我们必须将数值计算的振荡周期 $T_{\\mathrm{num}}$ 与理论周期 $T_{\\mathrm{th}}$进行比较。\n\n理论周期 $T_{\\mathrm{th}}$ 由包含第一类完全椭圆积分 $K(m)$ 的公式给出：\n$$\nT_{\\mathrm{th}} = 4\\sqrt{\\frac{L}{g}}\\,K(m), \\quad \\text{其中} \\quad m = \\sin^2\\left(\\frac{\\theta_0}{2}\\right)\n$$\n该积分必须进行数值计算，可以使用标准库函数来完成。\n\n数值周期 $T_{\\mathrm{num}}$ 是通过跟踪角速度 $\\omega(t)$ 来确定的。摆锤从其最大位移处静止开始，因此 $\\omega(0) = 0$。当 $t  0$ 时，$\\omega(t)$ 第一次返回零的位置是在相对的转折点，对应半个周期 ($t_1 \\approx T/2$)。第二次返回零则是在完成一个完整周期时 ($t_2 \\approx T$)。问题指定了稳健的估计公式 $T_{\\mathrm{num}} = 2(t_2 - t_1)$，如果 $t_1=T/2$ 且 $t_2=T$，该公式可以正确地计算出 $T$。\n为了找到过零时间 $t_1$ 和 $t_2$，我们迭代数值方法并监视角速度分量 $\\omega_n$ 的符号。如果在时间步 $t_n$ 和 $t_{n+1}$ 之间 $\\omega_n \\cdot \\omega_{n+1}  0$，则发生了一次过零。然后使用在点 $(t_n, \\omega_n)$ 和 $(t_{n+1}, \\omega_{n+1})$ 之间的线性插值来估计精确的过零时间 $t_{\\text{cross}}$：\n$$\nt_{\\text{cross}} = t_n - \\omega_n \\frac{t_{n+1} - t_n}{\\omega_{n+1} - \\omega_n} = t_n - \\omega_n \\frac{h}{\\omega_{n+1}-\\omega_n}\n$$\n对于 $t  0$ 找到的前两个这样的过零时间将是 $t_1$ 和 $t_2$。\n\n最后，对于每种方法和每个测试用例，绝对相对误差 $\\varepsilon$ 计算如下：\n$$\n\\varepsilon = \\frac{|T_{\\mathrm{num}} - T_{\\mathrm{th}}|}{T_{\\mathrm{th}}}\n$$\n\n对于每个测试用例 $(\\theta_0, h, L, g)$ 的总体算法如下：\n1.  使用提供的公式和高精度的椭圆积分值计算 $T_{\\mathrm{th}}$。\n2.  对于每种数值方法（显式中点法和改进欧拉法）：\n    a. 初始化状态 $\\mathbf{y}_0 = [\\theta_0, 0]^T$，时间 $t_0 = 0$，以及一个用于存储过零时间的空列表。\n    b. 重复应用方法的更新规则在时间上向前步进，$\\mathbf{y}_{n+1} = \\text{step}(\\mathbf{y}_n)$。\n    c. 在每一步，检查 $\\omega(t)$ 是否过零。如果在 $t_n$ 和 $t_{n+1}$ 之间检测到过零，则使用线性插值计算 $t_{\\text{cross}}$ 并记录下来。\n    d. 继续直到记录下两个过零时间 $t_1$ 和 $t_2$。\n    e. 计算 $T_{\\mathrm{num}} = 2(t_2 - t_1)$。\n    f. 计算误差 $\\varepsilon$。\n3.  为该测试用例存储误差对 $[\\varepsilon_{\\text{midpoint}}, \\varepsilon_{\\text{modified\\_Euler}}]$。\n4.  在处理完所有测试用例后，将结果格式化为指定的字符串。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import ellipk\n\ndef solve():\n    \"\"\"\n    Solves the pendulum problem for the given test suite, calculating the\n    relative error in the period for two numerical methods.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (theta0, h, L, g)\n        (1.2, 0.01, 1.0, 9.81),\n        (2.8, 0.01, 1.0, 9.81),\n        (2.8, 0.05, 1.0, 9.81),\n        (0.1, 0.02, 1.0, 9.81),\n        (3.0, 0.005, 1.0, 9.81),\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        theta0, h, L, g = case\n        \n        # --- Define the ODE system ---\n        def f_ode(t, y, g_val, L_val):\n            \"\"\"\n            Represents the first-order system y' = f(t, y).\n            y = [theta, omega]\n            y' = [omega, -g/L * sin(theta)]\n            \"\"\"\n            theta, omega = y\n            return np.array([omega, -(g_val / L_val) * np.sin(theta)])\n\n        # --- Define the numerical methods ---\n        def explicit_midpoint_step(f, t, y, h_step, g_val, L_val):\n            k1 = f(t, y, g_val, L_val)\n            k2 = f(t + h_step / 2.0, y + (h_step / 2.0) * k1, g_val, L_val)\n            y_next = y + h_step * k2\n            return y_next\n\n        def modified_euler_step(f, t, y, h_step, g_val, L_val):\n            k1 = f(t, y, g_val, L_val)\n            k2 = f(t + h_step, y + h_step * k1, g_val, L_val)\n            y_next = y + (h_step / 2.0) * (k1 + k2)\n            return y_next\n            \n        # --- Function to compute numerical period ---\n        def compute_numerical_period(step_func, y0_val, h_step, g_val, L_val):\n            t = 0.0\n            y = np.copy(y0_val)\n            \n            crossing_times = []\n            max_steps = int(2.0 * (4 * np.sqrt(L_val/g_val) * 10) / h_step) # Generous max steps\n\n            # We need to find the first two zero crossings of omega for t > 0\n            for i in range(max_steps):\n                y_prev = np.copy(y)\n                t_prev = t\n                \n                y = step_func(f_ode, t, y, h_step, g_val, L_val)\n                t = t + h_step\n\n                omega_prev = y_prev[1]\n                omega_curr = y[1]\n\n                # Check for sign change in omega; omega(0)=0 so let's start checking after first step\n                if omega_prev * omega_curr  0.0:\n                    # Linear interpolation to find the zero-crossing time\n                    t_cross = t_prev - omega_prev * h_step / (omega_curr - omega_prev)\n                    crossing_times.append(t_cross)\n                    \n                    if len(crossing_times) == 2:\n                        break\n            \n            if len(crossing_times)  2:\n                # Should not happen with well-chosen max_steps\n                return -1.0 \n            \n            t1, t2 = crossing_times\n            T_num = 2.0 * (t2 - t1)\n            return T_num\n\n        # --- Function to compute theoretical period ---\n        def compute_theoretical_period(theta0_val, L_val, g_val):\n            m = np.sin(theta0_val / 2.0)**2\n            K_m = ellipk(m)\n            T_th = 4.0 * np.sqrt(L_val / g_val) * K_m\n            return T_th\n\n        # --- Main calculation for the case ---\n        case_results = []\n        y0 = np.array([theta0, 0.0])\n        T_th = compute_theoretical_period(theta0, L, g)\n        \n        methods = [explicit_midpoint_step, modified_euler_step]\n        \n        for method in methods:\n            T_num = compute_numerical_period(method, y0, h, g, L)\n            rel_error = np.abs(T_num - T_th) / T_th\n            case_results.append(f\"{rel_error:.8f}\")\n\n        all_results.append(f\"[{','.join(case_results)}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```"
        }
    ]
}