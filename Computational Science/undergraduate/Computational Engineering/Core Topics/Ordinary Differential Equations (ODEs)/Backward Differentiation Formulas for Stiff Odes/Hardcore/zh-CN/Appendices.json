{
    "hands_on_practices": [
        {
            "introduction": "要真正理解为何像后向分化公式（BDF）这样的隐式方法对于求解刚性问题是不可或缺的，我们首先必须量化其计算成本的权衡。这个练习将引导你进行一次“信封背面”式的估算，比较显式Runge-Kutta方法和BDF方法的计算效率。通过这个估算，你将揭示出对于显式方法，稳定性的限制而非精度要求，是如何主导其计算成本的，从而凸显出BDF方法在处理刚性问题时所带来的巨大效率优势。",
            "id": "2372592",
            "problem": "您的任务是积分van der Pol振子，这是一个非线性常微分方程（ODE），由以下公式给出：\n$$\n\\begin{cases}\nx'(t) = y(t),\\\\\ny'(t) = \\mu \\left(1 - x(t)^2\\right) y(t) - x(t),\n\\end{cases}\n$$\n在区间 $[0, T]$（其中 $T = 20$）上，针对刚性状态 $\\mu = 10^3$。您必须达到一个统一的目标精度，对应的全局误差容差为 $\\varepsilon = 10^{-3}$。\n\n考虑两种时间步进策略：\n- 一种显式 $s$ 阶 Runge–Kutta (RK) 方法，其中 $s = 4$，阶数为 $p_{\\mathrm{RK}} = 4$。\n- 一种 $k$ 步后向分化公式 (BDF) 方法，其中 $k = 2$，阶数为 $p_{\\mathrm{BDF}} = 2$，每一步通过Newton法求解，每次迭代使用 $m = 3$ 次残差（右端项）求值，并且在Newton迭代中重复使用单个Jacobian分解。\n\n假设以下经过充分检验的事实：\n- 对于刚性问题，在吸引段附近的线性化会产生一个量级为 $|\\lambda| \\sim \\mathcal{O}(\\mu)$ 的主导负特征值。\n- 将方法应用于标量测试方程 $z'(t)=\\lambda z(t)$ 时，显式稳定性要求 $|\\Phi(\\lambda \\Delta t)| < 1$，对于经典的 $4$ 阶RK方法，这意味着在负实轴上有一个实际界限 $|\\lambda| \\Delta t \\lesssim c_{\\mathrm{RK}}$。使用一个保守值 $c_{\\mathrm{RK}} = 2$。\n- 2阶BDF在负实轴上是 $A$-稳定的（也是刚性稳定的），因此其步长不受刚性限制，而是受精度限制。\n- 对于一个 $p$ 阶方法，为满足规定的精度，步长必须选择得足够小，以使与 $\\Delta t^p$ 成比例的主截断误差不超过容差。使用此原则来设定由精度驱动的步长。\n\n令 $N_{\\mathrm{RK}}$ 和 $N_{\\mathrm{BDF}}$ 分别表示RK和BDF方法的时间步数。令 $F_{\\mathrm{RK}}$ 和 $F_{\\mathrm{BDF}}$ 表示右端项函数求值的总次数。对于显式 $4$ 阶RK方法，每步成本为 $s = 4$ 次右端项求值，因此 $F_{\\mathrm{RK}} \\approx 4 N_{\\mathrm{RK}}$。对于BDF方法，其中Newton法每步进行 $m = 3$ 次残差求值，取 $F_{\\mathrm{BDF}} \\approx 3 N_{\\mathrm{BDF}}$。\n\n仅使用显式方法的刚性引起的稳定性限制和两种方法的精度引起的限制，估算上述参数下的 $F_{\\mathrm{RK}}$ 和 $F_{\\mathrm{BDF}}$，并从下面选择最佳估算。\n\nA. $F_{\\mathrm{RK}} \\approx 4 \\times 10^4$ 且 $F_{\\mathrm{BDF}} \\approx 1.9 \\times 10^3$；BDF方法所需的函数求值次数大约少 $20$ 倍。\n\nB. $F_{\\mathrm{RK}} \\approx 1.6 \\times 10^5$ 且 $F_{\\mathrm{BDF}} \\approx 1.9 \\times 10^3$；BDF方法所需的函数求值次数大约少 $80$ 倍。\n\nC. $F_{\\mathrm{RK}} \\approx 1.0 \\times 10^4$ 且 $F_{\\mathrm{BDF}} \\approx 5.7 \\times 10^4$；显式方法更有效。\n\nD. $F_{\\mathrm{RK}} \\approx F_{\\mathrm{BDF}} \\approx 2.0 \\times 10^3$；稳定性限制相当，因此两种方法的成本相似。",
            "solution": "首先必须对问题陈述进行严格的验证。\n\n### 步骤1：提取已知条件\n所提供的信息如下：\n- **控制方程**：van der Pol振子，由一阶常微分方程组（ODEs）定义：\n$$\n\\begin{cases}\nx'(t) = y(t),\\\\\ny'(t) = \\mu \\left(1 - x(t)^2\\right) y(t) - x(t),\n\\end{cases}\n$$\n- **参数**：\n  - 刚性参数：$\\mu = 10^3$。\n  - 积分区间：$[0, T]$，其中 $T = 20$。\n  - 全局误差容差：$\\varepsilon = 10^{-3}$。\n- **方法1（显式Runge-Kutta）**：\n  - 阶数：$s = 4$。\n  - 精度阶数：$p_{\\mathrm{RK}} = 4$。\n  - 每步函数求值次数：$s = 4$。\n  - 总求值次数：$F_{\\mathrm{RK}} \\approx 4 N_{\\mathrm{RK}}$。\n- **方法2（后向分化公式）**：\n  - 步数：$k = 2$。\n  - 精度阶数：$p_{\\mathrm{BDF}} = 2$。\n  - 非线性求解器：Newton法。\n  - 每步函数求值次数：$m = 3$。\n  - 总求值次数：$F_{\\mathrm{BDF}} \\approx 3 N_{\\mathrm{BDF}}$。\n- **假设与启发式方法**：\n  - 问题是刚性的，主导负特征值的量级为 $|\\lambda| \\sim \\mathcal{O}(\\mu)$。\n  - 显式 $4$ 阶RK方法的稳定性约束为 $|\\lambda| \\Delta t \\lesssim c_{\\mathrm{RK}}$，其中给定的有效常数为 $c_{\\mathrm{RK}} = 2$。\n  - 2阶BDF方法是A-稳定的，意味着其步长受精度限制，而非稳定性。\n  - 对于一个 $p$ 阶方法，由精度驱动的步长 $\\Delta t$ 是由全局误差（其与 $\\Delta t^p$ 成比例）满足容差 $\\varepsilon$ 的要求决定的。\n  - 成本分析应使用显式方法的刚性引起的稳定性限制和两种方法的精度引起的限制。\n\n### 步骤2：使用提取的已知条件进行验证\n根据有效性标准对问题陈述进行评估。\n- **科学依据**：该问题在常微分方程数值分析领域有充分的依据。van der Pol方程是刚性系统的一个经典例子。刚性、Jacobian矩阵的谱特性、显式和隐式方法（如Runge-Kutta和BDF）的稳定性区域，以及基于函数求值的计算成本分析等概念，都是该学科的标准和基础内容。\n- **适定性**：该问题是适定的。它提供了足够的数据和一组清晰的假设来进行所需的计算成本估算。问题要求进行估算，这对于所提供的启发式常数和标度律的性质是合适的。可以推导出一个唯一的、有意义的估算值。\n- **客观性**：问题以精确、客观的数学语言陈述。没有主观或含糊不清的术语。\n\n### 步骤3：结论与行动\n问题陈述在科学上是合理的、适定的和客观的。没有可识别的缺陷。因此，该问题是**有效的**。我将继续推导解答。\n\n### 解题推导\n任务是估算在区间 $[0, 20]$ 上以 $\\varepsilon = 10^{-3}$ 的全局精度积分给定的刚性ODE所需的右端项函数求值总次数 $F_{\\mathrm{RK}}$ 和 $F_{\\mathrm{BDF}}$。\n\n**1. 显式Runge-Kutta方法 (RK-4) 的分析**\n对于刚性问题，显式方法的步长 $\\Delta t_{\\mathrm{RK}}$ 受到稳定性要求的严格限制。问题明确指出了这一点，并提供了稳定性条件：\n$$|\\lambda| \\Delta t_{\\mathrm{RK}} \\lesssim c_{\\mathrm{RK}}$$\n我们已知主导特征值的量级与 $\\mu$ 成比例，因此我们取 $|\\lambda| \\approx \\mu = 10^3$。给定的稳定性常数为 $c_{\\mathrm{RK}} = 2$。\n将这些值代入稳定性条件，得到：\n$$10^3 \\cdot \\Delta t_{\\mathrm{RK}} \\lesssim 2$$\n这意味着最大稳定步长为：\n$$\\Delta t_{\\mathrm{RK}} \\approx \\frac{2}{10^3} = 2 \\times 10^{-3}$$\n问题要求使用这个由稳定性引起的限制。此方法的全局误差为 $\\mathcal{O}(\\Delta t_{\\mathrm{RK}}^4)$，对于如此小的步长，该误差将远低于要求的容差 $\\varepsilon = 10^{-3}$。确实，步长是由稳定性而非精度决定的。\n\n覆盖长度为 $T = 20$ 的区间所需的总步数 $N_{\\mathrm{RK}}$ 为：\n$$N_{\\mathrm{RK}} = \\frac{T}{\\Delta t_{\\mathrm{RK}}} = \\frac{20}{2 \\times 10^{-3}} = 10 \\times 10^3 = 10^4$$\n显式RK-4方法每步需要 $s = 4$ 次函数求值。因此，总求值次数为：\n$$F_{\\mathrm{RK}} \\approx s \\cdot N_{\\mathrm{RK}} = 4 \\times 10^4$$\n\n**2. 后向分化公式方法 (BDF-2) 的分析**\nBDF-2方法是A-稳定的，这意味着其步长不受问题刚性的约束。相反，$\\Delta t_{\\mathrm{BDF}}$ 由精度要求确定。该方法的阶数为 $p_{\\mathrm{BDF}} = 2$。\n\n一个 $p$ 阶方法的全局误差与 $\\mathcal{O}(\\Delta t^p)$ 成比例。为达到 $\\varepsilon$ 的全局误差容差，步长 $\\Delta t$ 必须满足 $C (\\Delta t)^p \\approx \\varepsilon$ 形式的关系，其中 $C$ 是一个依赖于问题解及其导数的常数。在没有更多信息的情况下，一个标准的估算启发式方法是假设 $C \\approx 1$。\n将此应用于BDF-2方法（$p=2$）：\n$$(\\Delta t_{\\mathrm{BDF}})^2 \\approx \\varepsilon = 10^{-3}$$\n求解受精度限制的步长 $\\Delta t_{\\mathrm{BDF}}$：\n$$\\Delta t_{\\mathrm{BDF}} \\approx \\sqrt{10^{-3}} = 10^{-1.5} = 10^{-1} \\sqrt{10} \\approx 0.03162$$\n总步数 $N_{\\mathrm{BDF}}$ 为：\n$$N_{\\mathrm{BDF}} = \\frac{T}{\\Delta t_{\\mathrm{BDF}}} = \\frac{20}{\\sqrt{10^{-3}}} = \\frac{20}{10^{-1.5}} = 20 \\times 10^{1.5} = 200\\sqrt{10} \\approx 200 \\times 3.162 = 632.4$$\n我们可以将其四舍五入为 $N_{\\mathrm{BDF}} \\approx 633$ 步。\n\nBDF方法的每一步都需要求解一个非线性系统。题目说明这是通过Newton法完成的，每步耗费 $m=3$ 次函数（残差）求值。函数求值的总次数为：\n$$F_{\\mathrm{BDF}} \\approx m \\cdot N_{\\mathrm{BDF}} = 3 \\times 633 = 1899$$\n这个值与 $1.9 \\times 10^3$ 非常接近。\n\n**3. 成本比较**\n我们的估算结果是：\n- $F_{\\mathrm{RK}} \\approx 4 \\times 10^4$\n- $F_{\\mathrm{BDF}} \\approx 1.9 \\times 10^3$\n\n成本之比为：\n$$\\frac{F_{\\mathrm{RK}}}{F_{\\mathrm{BDF}}} \\approx \\frac{4 \\times 10^4}{1.9 \\times 10^3} = \\frac{40}{1.9} \\approx 21.05$$\n这证实了对于这个刚性问题，隐式BDF方法效率显著更高，所需的函数求值次数大约比显式RK方法少 $21$ 倍。\n\n### 评估所给选项\n\n**A. $F_{\\mathrm{RK}} \\approx 4 \\times 10^4$ 且 $F_{\\mathrm{BDF}} \\approx 1.9 \\times 10^3$；BDF方法所需的函数求值次数大约少 $20$ 倍。**\n- 值 $F_{\\mathrm{RK}} \\approx 4 \\times 10^4$ 与我们推导的估算值完全匹配。\n- 值 $F_{\\mathrm{BDF}} \\approx 1.9 \\times 10^3$ 与我们推导的估算值（$1899$）匹配。\n- BDF方法效率高“大约 $20$ 倍”的比较与我们计算出的约 $21$ 的比率相符。\n- **结论：正确。**\n\n**B. $F_{\\mathrm{RK}} \\approx 1.6 \\times 10^5$ 且 $F_{\\mathrm{BDF}} \\approx 1.9 \\times 10^3$；BDF方法所需的函数求值次数大约少 $80$ 倍。**\n- $F_{\\mathrm{BDF}}$ 的值是正确的。\n- 值 $F_{\\mathrm{RK}} \\approx 1.6 \\times 10^5$ 是不正确的。它比我们推导的估算值大四倍。这将意味着 $N_{\\mathrm{RK}} = 4 \\times 10^4$，而不是 $10^4$。\n- **结论：不正确。**\n\n**C. $F_{\\mathrm{RK}} \\approx 1.0 \\times 10^4$ 且 $F_{\\mathrm{BDF}} \\approx 5.7 \\times 10^4$；显式方法更有效。**\n- 值 $F_{\\mathrm{RK}} \\approx 1.0 \\times 10^4$ 是不正确的。这将意味着 $N_{\\mathrm{RK}} = 2500$，这违反了稳定性条件。\n- 值 $F_{\\mathrm{BDF}} \\approx 5.7 \\times 10^4$ 是不正确的。这将意味着步长远小于指定精度所要求的步长。\n- 对于这种性质的刚性问题，显式方法更有效的结论是根本错误的。\n- **结论：不正确。**\n\n**D. $F_{\\mathrm{RK}} \\approx F_{\\mathrm{BDF}} \\approx 2.0 \\times 10^3$；稳定性限制相当，因此两种方法的成本相似。**\n- “稳定性限制相当”这个前提是错误的。这正是刚性问题的定义特征：显式方法的稳定性限制远比精度限制苛刻。像BDF-2这样的A-稳定方法没有这种稳定性限制。因此，成本并不相似。$F_{\\mathrm{RK}} \\approx 4 \\times 10^4$ 与 $2.0 \\times 10^3$ 相差甚远。\n- **结论：不正确。**",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "刚性问题的核心在于系统内部存在着巨大差异的时间尺度，这在数学上对应着“快”动态和“慢”动态。本动手编程练习将通过一个包含“慢流形”的简单系统，让你直观地观察到这一现象。你将分别实现一个显式方法和一个BDF方法，亲眼见证像BDF2这样的A-稳定方法是如何准确捕捉解向慢流形的快速坍缩，而显式方法在步长不够小的情况下则可能遭遇灾难性的失败。",
            "id": "2374906",
            "problem": "考虑以下无量纲线性刚性常微分方程 (ODEs) 系统\n$$\n\\frac{d x}{d t} = -x, \\qquad \\varepsilon \\frac{d y}{d t} = -y,\n$$\n其初始条件为\n$$\nx(0)=x_0,\\quad y(0)=y_0,\n$$\n其中 $\\varepsilon>0$ 是一个刚性参数。慢流形是集合\n$$\n\\mathcal{M}=\\{(x,y)\\in\\mathbb{R}^2:\\ y=0\\},\n$$\n快子空间是集合\n$$\n\\mathcal{F}=\\{(x,y)\\in\\mathbb{R}^2:\\ x=0\\}。\n$$\n对于在固定步长 $h>0$ 的等距时间网格 $t_n = n h$ 上计算的离散数值轨迹 $\\{(x_n,y_n)\\}_{n=0}^N$，定义其到慢流形的塌缩时间为\n$$\n\\tau = \\min\\{t_n:\\ |y_n|\\le \\delta\\},\n$$\n并约定，如果没有索引 $n\\in\\{0,1,\\dots,N\\}$ 满足 $|y_n|\\le \\delta$，则 $\\tau=+\\infty$。所有量均为无量纲。\n\n对于下方的每个测试用例，在同一网格 $t_n = n h$（其中 $n=0,1,\\dots,\\lfloor T/h\\rfloor$）上计算两条离散轨迹：\n- 一条由步长为 $h$ 的二阶后向分化公式 (BDF2) 生成的轨迹，\n- 一条由相同步长 $h$ 的一阶显式方法（前向欧拉法）生成的轨迹。\n\n对于每条轨迹，使用测试用例中指定的容差 $\\delta$ 报告其到慢流形 $\\mathcal{M}$ 的塌缩时间 $\\tau$。如果在时间 $T$ 或之前没有发生塌缩，则报告该轨迹的塌缩时间为 $+\\infty$。\n\n测试套件（每个用例是一个元组 $(\\varepsilon,h,T,x_0,y_0,\\delta)$）：\n- 用例 A（理想情况，强刚性且显式方法不稳定）：$(\\varepsilon,h,T,x_0,y_0,\\delta) = (10^{-3},\\,0.05,\\,2.0,\\,0,\\,1,\\,10^{-6})$。\n- 用例 B（接近稳定边界的稳定显式演化）：$(\\varepsilon,h,T,x_0,y_0,\\delta) = (10^{-2},\\,0.015,\\,2.0,\\,0,\\,1,\\,10^{-6})$。\n- 用例 C（从慢流形上开始的边界情况）：$(\\varepsilon,h,T,x_0,y_0,\\delta) = (0.5,\\,0.25,\\,3.0,\\,2,\\,0,\\,10^{-12})$。\n\n你的程序必须产生单行输出，其中包含六个塌缩时间，顺序和格式如下：\n$$\n[\\tau_{\\mathrm{BDF2}}^{\\mathrm{A}},\\ \\tau_{\\mathrm{FE}}^{\\mathrm{A}},\\ \\tau_{\\mathrm{BDF2}}^{\\mathrm{B}},\\ \\tau_{\\mathrm{FE}}^{\\mathrm{B}},\\ \\tau_{\\mathrm{BDF2}}^{\\mathrm{C}},\\ \\tau_{\\mathrm{FE}}^{\\mathrm{C}}],\n$$\n其中 $\\tau_{\\mathrm{BDF2}}^{\\mathrm{A}}$ 是用例 A 的 BDF2 塌缩时间，$\\tau_{\\mathrm{FE}}^{\\mathrm{A}}$ 是用例 A 的前向欧拉法塌缩时间，用例 B 和 C 与此类似。如果轨迹在时间 $T$ 前没有塌缩，则使用实数 $+\\infty$。输出必须是严格的一行，采用指定的方括号括起、逗号分隔的格式。不应打印任何其他文本。",
            "solution": "所给问题是适定的且科学上合理的，为研究刚性常微分方程 (ODEs) 的数值方法提供了一个典型例子。我们将直接进行求解。\n\n该 ODEs 系统由以下方程给出：\n$$\n\\frac{d x}{d t} = -x\n$$\n$$\n\\varepsilon \\frac{d y}{d t} = -y\n$$\n这是一个线性解耦系统。在初始条件 $x(0)=x_0$ 和 $y(0)=y_0$ 下，其解析解为：\n$$\nx(t) = x_0 e^{-t}\n$$\n$$\ny(t) = y_0 e^{-t/\\varepsilon}\n$$\n参数 $\\varepsilon > 0$ 控制系统的刚性。当 $0 < \\varepsilon \\ll 1$ 时，系统表现出两种截然不同的时间尺度：$x(t)$ 的慢尺度，其衰减率为 $1$；以及 $y(t)$ 的快尺度，其衰减率为 $1/\\varepsilon$。$y(t)$ 的快动力学将解驱动至慢流形 $\\mathcal{M} = \\{(x,y) : y=0\\}$。一个数值方法必须能够处理这种尺度差异，而无需使用过小的时间步长 $h$。\n\n我们将分析指定的两种数值方法。设在时间 $t_n = n h$ 的状态向量为 $\\mathbf{u}_n = (x_n, y_n)^T$。\n\n一阶显式前向欧拉 (FE) 法的形式为 $\\mathbf{u}_{n+1} = \\mathbf{u}_n + h f(\\mathbf{u}_n)$。对于给定的 ODE，这会产生以下递推关系：\n$$\nx_{n+1} = (1 - h) x_n\n$$\n$$\ny_{n+1} = (1 - \\frac{h}{\\varepsilon}) y_n\n$$\n对于方程 $\\dot{z} = \\lambda z$，FE 方法的稳定性需要满足 Courant-Friedrichs-Lewy (CFL) 条件 $|1 + h\\lambda| \\le 1$。对于 $y$ 分量，$\\lambda = -1/\\varepsilon$。这对时间步长施加了严格的限制：$|1 - h/\\varepsilon| \\le 1$，即 $h \\le 2\\varepsilon$。如果违反此条件，$y_n$ 的数值解将表现出振幅不断增长的不稳定振荡。\n\n二阶后向分化公式 (BDF2) 是一种隐式两步法。对于 ODE $\\dot{\\mathbf{u}} = f(\\mathbf{u})$，其公式为：\n$$\n\\frac{3}{2} \\mathbf{u}_{n+1} - 2\\mathbf{u}_n + \\frac{1}{2}\\mathbf{u}_{n-1} = h f(\\mathbf{u}_{n+1})\n$$\n对于我们的线性系统，这变为 $(\\frac{3}{2}I - hA)\\mathbf{u}_{n+1} = 2\\mathbf{u}_n - \\frac{1}{2}\\mathbf{u}_{n-1}$，其中 $A = \\mathrm{diag}(-1, -1/\\varepsilon)$。这会产生以下分量形式的递推关系：\n$$\nx_{n+1} = \\frac{2x_n - 0.5x_{n-1}}{1.5 + h}\n$$\n$$\ny_{n+1} = \\frac{2y_n - 0.5y_{n-1}}{1.5 + h/\\varepsilon}\n$$\n作为一种两步法，BDF2 需要一个启动程序来从 $\\mathbf{u}_0$ 计算 $\\mathbf{u}_1$。我们将采用适用于刚性问题的一阶隐式后向欧拉 (BE) 法（也称为 BDF1）的单步计算。BE 更新为 $\\mathbf{u}_1 = (I - hA)^{-1}\\mathbf{u}_0$，得到：\n$$\nx_1 = \\frac{x_0}{1+h}, \\quad y_1 = \\frac{y_0}{1+h/\\varepsilon}\n$$\nBDF2 方法是 A-稳定的，意味着其绝对稳定域包含整个复平面左半部分。因此，当应用于刚性系统时，它不会像 FE 方法那样受到严格的时间步长限制，并且对于任何 $h>0$ 都预期是稳定的。\n\n现在我们分析每个测试用例：\n\n用例 A: $(\\varepsilon,h,T,x_0,y_0,\\delta) = (10^{-3},\\,0.05,\\,2.0,\\,0,\\,1,\\,10^{-6})$\n刚性很强，$\\varepsilon = 10^{-3}$。FE 的稳定性条件是 $h \\le 2\\varepsilon \\implies 0.05 \\le 0.002$，此条件被违反。$y_n$ 的放大因子为 $(1 - h/\\varepsilon) = (1 - 0.05/10^{-3}) = -49$。$y_n$ 的模将以 $|y_n| = 49^n |y_0|$ 的形式增长，因此永远不会塌缩到流形上。故 $\\tau_{\\mathrm{FE}}^A = +\\infty$。\n对于 BDF2，该方法是稳定的。经过短暂的初始瞬态后，$y$ 的数值解将会衰减。直接计算表明 $|y_5| \\approx 7.78 \\times 10^{-6} > \\delta$ 且 $|y_6| \\approx 3.38 \\times 10^{-7} \\le \\delta$。塌缩发生在第 $n=6$ 步，因此塌缩时间为 $\\tau_{\\mathrm{BDF2}}^A = 6 \\times h = 6 \\times 0.05 = 0.3$。\n\n用例 B: $(\\varepsilon,h,T,x_0,y_0,\\delta) = (10^{-2},\\,0.015,\\,2.0,\\,0,\\,1,\\,10^{-6})$\n刚性适中，$\\varepsilon = 10^{-2}$。FE 的稳定性条件是 $h \\le 2\\varepsilon \\implies 0.015 \\le 0.02$，此条件得到满足。FE 方法是稳定的。放大因子为 $(1 - h/\\varepsilon) = (1 - 0.015/10^{-2}) = -0.5$。我们需要找到最小的整数 $n$ 使得 $|y_n| = |(-0.5)^n y_0| \\le 10^{-6}$。这需要 $n \\ln(0.5) \\le \\ln(10^{-6})$，解得 $n \\ge 19.93$。因此，塌缩发生在 $n=20$。塌缩时间为 $\\tau_{\\mathrm{FE}}^B = 20 \\times h = 20 \\times 0.015 = 0.3$。\n对于 BDF2，该方法也是稳定的。$y_n$ 的递推关系是 $y_{n+1} = (2y_n - 0.5y_{n-1}) / (1.5 + 1.5)$。当 $y_0 = 1$ 且 $y_1 = y_0 / (1 + 1.5) = 0.4$ 时，我们发现 $y_2 = 0.1$ 且 $y_3=0$。轨迹在第 $n=3$ 步精确地塌缩到流形上。塌缩时间为 $\\tau_{\\mathrm{BDF2}}^B = 3 \\times h = 3 \\times 0.015 = 0.045$。\n\n用例 C: $(\\varepsilon,h,T,x_0,y_0,\\delta) = (0.5,\\,0.25,\\,3.0,\\,2,\\,0,\\,10^{-12})$\n初始条件 $(x_0, y_0)=(2,0)$ 位于慢流形 $\\mathcal{M}$ 上。$y(t)$ 的解析解对于所有 $t \\ge 0$ 恒等于零。FE 和 BDF2 都保持此不变量。对于 FE，如果 $y_n=0$，那么 $y_{n+1} = (1 - h/\\varepsilon) \\times 0 = 0$。对于 BDF2，如果 $y_{n-1}=0$ 且 $y_n=0$，那么 $y_{n+1}=0$。\n由于 $y_0=0$，对于两种方法，数值轨迹在所有 $n \\ge 0$ 时都满足 $y_n=0$。塌缩条件 $|y_n| \\le \\delta$ 在第一步 $n=0$ 时即被满足。因此，两种方法的塌缩时间均为 $\\tau = t_0 = 0$。故 $\\tau_{\\mathrm{FE}}^C = 0.0$ 且 $\\tau_{\\mathrm{BDF2}}^C = 0.0$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the collapse time to the slow manifold for a stiff ODE system\n    using Forward Euler and BDF2 methods for three test cases.\n    \"\"\"\n    test_cases = [\n        # Case A: (eps, h, T, x0, y0, delta)\n        (1e-3, 0.05, 2.0, 0, 1, 1e-6),\n        # Case B\n        (1e-2, 0.015, 2.0, 0, 1, 1e-6),\n        # Case C\n        (0.5, 0.25, 3.0, 2, 0, 1e-12),\n    ]\n\n    results = []\n    for case in test_cases:\n        eps, h, T, x0, y0, delta = case\n        N = int(T / h)\n\n        # --- Forward Euler Trajectory and Collapse Time ---\n        # Since the collapse time only depends on y, we only evolve y.\n        tau_fe = float('inf')\n        y_fe_n = float(y0)\n\n        if abs(y_fe_n) = delta:\n            tau_fe = 0.0\n        else:\n            for n in range(N):\n                y_fe_n = y_fe_n * (1.0 - h / eps)\n                # Check for numerical overflow in unstable cases\n                if not np.isfinite(y_fe_n):\n                    # The trajectory has diverged, it will never collapse.\n                    break\n                if abs(y_fe_n) = delta:\n                    tau_fe = (n + 1) * h\n                    break\n        \n        # --- BDF2 Trajectory and Collapse Time ---\n        tau_bdf2 = float('inf')\n        \n        # History for y component\n        y_bdf_hist = np.zeros(N + 1, dtype=float)\n        y_bdf_hist[0] = float(y0)\n\n        if abs(y_bdf_hist[0]) = delta:\n            tau_bdf2 = 0.0\n        else:\n            # First step using Backward Euler (BDF1)\n            y_bdf_hist[1] = y_bdf_hist[0] / (1.0 + h / eps)\n            \n            if abs(y_bdf_hist[1]) = delta:\n                tau_bdf2 = h\n            else:\n                # Subsequent steps (n=2 to N) using BDF2\n                for n in range(1, N):  # n from 1 to N-1\n                    # BDF2 formula to compute y_{n+1}\n                    y_bdf_hist[n+1] = (2.0 * y_bdf_hist[n] - 0.5 * y_bdf_hist[n-1]) / (1.5 + h / eps)\n                    if abs(y_bdf_hist[n+1]) = delta:\n                        tau_bdf2 = (n + 1) * h\n                        break\n        \n        results.append(tau_bdf2)\n        results.append(tau_fe)\n\n    # Use map(str, ...) to handle float('inf') becoming 'inf'\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "像BDF这样的隐式方法，其强大功能的代价是在每个时间步都必须求解一个非线性代数方程组。这个练习将深入探讨这一关键的实现细节，聚焦于单个BDF步中使用的Newton-Raphson迭代法。通过研究一个刚性可调的系统，你将揭示出常微分方程的刚性与Newton迭代求解器收敛性所依赖的雅可比矩阵的病态条件之间的直接联系。",
            "id": "2374964",
            "problem": "考虑一个自治刚性常微分方程（ODE）系统，其状态向量 $y(t) = [y_1(t), y_2(t)]^\\top$ 定义如下\n$$\n\\frac{d}{dt}\n\\begin{bmatrix}\ny_1 \\\\\ny_2\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n- k\\, y_1 + c\\,(y_2 - y_1) + a\\, y_1^2 \\\\\n\\frac{1}{\\varepsilon}\\,(y_1 - y_2) - b\\, y_2^2\n\\end{bmatrix},\n$$\n其中参数为 $k = 1$，$c = 10$，$a = 1$，$b = 1$，以及一个小的正参数 $\\varepsilon  0$，该参数控制一个近似简并的快耦合。所有量均为无量纲，没有物理单位。任务是研究在使用一阶后向分化公式（BDF）（也称为隐式欧拉法）的单步计算中，雅可比矩阵的条件数如何影响在新时间层级上产生的非线性代数系统的牛顿-拉夫逊迭代的收敛性。\n\n对于给定在时间 $t_n$ 的前一状态 $y_n \\in \\mathbb{R}^2$ 和步长 $h  0$，BDF-1 隐式更新 $y_{n+1}$ 在时间 $t_{n+1} = t_n + h$ 被定义为非线性残差方程的解\n$$\nG(y_{n+1}) = y_{n+1} - y_n - h\\, f(y_{n+1}) = 0,\n$$\n其中 $f(y)$ 表示 ODE 系统的右端项。残差的雅可比矩阵为\n$$\nJ(y) = \\frac{\\partial G}{\\partial y}(y) = I - h\\, \\frac{\\partial f}{\\partial y}(y),\n$$\n其中\n$$\n\\frac{\\partial f}{\\partial y}(y) =\n\\begin{bmatrix}\n- k - c + 2 a y_1  c \\\\\n\\frac{1}{\\varepsilon}  -\\frac{1}{\\varepsilon} - 2 b y_2\n\\end{bmatrix}.\n$$\n使用初始状态 $y_n = \\begin{bmatrix} 0.9 \\\\ 0.1 \\end{bmatrix}$，残差使用欧几里得范数，收敛容差为 $\\lVert G(y) \\rVert_2$ 上的 $\\tau = 10^{-10}$，以及牛顿-拉夫逊迭代的最大允许次数 $M = 50$。牛顿-拉夫逊迭代的初值必须为 $y^{(0)} = y_n$。矩阵 $A$ 在欧几里得范数下的谱条件数记为 $\\kappa_2(A)$。\n\n对于下面的每个测试用例，在 $t_n = 0$ 处应用单步 BDF-1，并报告两个量：\n$($i$)$ 为满足 $\\lVert G(y^{(k)}) \\rVert_2 \\le \\tau$ 所需的牛顿-拉夫逊迭代的整数次数（如果在 $M$ 次迭代内未达到收敛或线性求解失败，则使用 $-1$），以及\n$($ii$)$ 在该步骤中所有牛顿-拉夫逊迭代中遇到的最大谱条件数 $\\kappa_2(J(y^{(k)}))$ 的以 10 为底的对数 $\\log_{10}$（使用直到终止时观察到的最大值，即使迭代未能收敛）。\n\n测试组（每个用例是一对 $(\\varepsilon, h)$）：\n- 用例 1：$\\varepsilon = 1$, $h = 0.05$。\n- 用例 2：$\\varepsilon = 10^{-3}$, $h = 0.05$。\n- 用例 3：$\\varepsilon = 10^{-6}$, $h = 0.05$。\n- 用例 4：$\\varepsilon = 10^{-3}$, $h = 0.5$。\n- 用例 5：$\\varepsilon = 10^{-6}$, $h = 0.5$。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按顺序包含每个测试用例的整数迭代次数，然后是最大条件数的 $\\log_{10}$ 浮点值；因此最终列表的长度为 $10$。例如，格式为 $[n_1,\\ell_1,n_2,\\ell_2,n_3,\\ell_3,n_4,\\ell_4,n_5,\\ell_5]$，其中 $n_i$是整数，$\\ell_i$是实数。",
            "solution": "问题陈述已经过验证，被认为是科学上可靠、适定且完整的。它代表了计算物理学中的一个标准练习，特别是在刚性常微分方程（ODE）的数值分析领域。所有参数、初始条件和程序都得到了明确的定义。因此，我们开始进行求解。\n\n任务是分析在使用一阶后向分化公式（BDF-1）（也称为隐式欧拉法）的单步计算中，求解所产生的代数系统时牛顿-拉夫逊方法的行为。所考虑的 ODE 系统是\n$$\n\\frac{d\\boldsymbol{y}}{dt} = \\boldsymbol{f}(\\boldsymbol{y}) =\n\\begin{bmatrix}\n- k y_1 + c(y_2 - y_1) + a y_1^2 \\\\\n\\frac{1}{\\varepsilon}(y_1 - y_2) - b y_2^2\n\\end{bmatrix}\n$$\n其中 $\\boldsymbol{y}(t) = [y_1(t), y_2(t)]^\\top$ 是状态向量。给定的参数为 $k=1$，$c=10$，$a=1$ 和 $b=1$。参数 $\\varepsilon  0$ 控制系统的刚性；对于 $\\varepsilon \\ll 1$，系统表现出在广泛分离的时间尺度上的动力学行为，这是刚性系统的定义。\n\nBDF-1 方法使用 $t_n$ 时刻的值来逼近 $t_{n+1} = t_n + h$ 时刻的解。在 $t_{n+1}$ 时刻的时间导数 $\\frac{d\\boldsymbol{y}}{dt}$ 由 $\\frac{\\boldsymbol{y}_{n+1} - \\boldsymbol{y}_n}{h}$ 近似。将此代入 ODE，得到关于未知状态 $\\boldsymbol{y}_{n+1}$ 的非线性代数系统：\n$$\n\\frac{\\boldsymbol{y}_{n+1} - \\boldsymbol{y}_n}{h} = \\boldsymbol{f}(\\boldsymbol{y}_{n+1})\n$$\n这被重排为关于残差函数 $\\boldsymbol{G}(\\boldsymbol{y}_{n+1})$ 的求根问题：\n$$\n\\boldsymbol{G}(\\boldsymbol{y}_{n+1}) = \\boldsymbol{y}_{n+1} - \\boldsymbol{y}_n - h \\boldsymbol{f}(\\boldsymbol{y}_{n+1}) = \\boldsymbol{0}\n$$\n该非线性系统使用牛顿-拉夫逊方法求解。从初始猜测 $\\boldsymbol{y}^{(0)} = \\boldsymbol{y}_n$ 开始，通过以下迭代公式生成逐次逼近值 $\\boldsymbol{y}^{(k)}$：\n$$\n\\boldsymbol{y}^{(k+1)} = \\boldsymbol{y}^{(k)} - [\\boldsymbol{J}(\\boldsymbol{y}^{(k)})]^{-1} \\boldsymbol{G}(\\boldsymbol{y}^{(k)})\n$$\n其中 $\\boldsymbol{J}(\\boldsymbol{y})$ 是残差函数 $\\boldsymbol{G}(\\boldsymbol{y})$ 相对于 $\\boldsymbol{y}$ 的雅可比矩阵。它由下式给出：\n$$\n\\boldsymbol{J}(\\boldsymbol{y}) = \\frac{\\partial \\boldsymbol{G}}{\\partial \\boldsymbol{y}}(\\boldsymbol{y}) = \\boldsymbol{I} - h \\frac{\\partial \\boldsymbol{f}}{\\partial \\boldsymbol{y}}(\\boldsymbol{y})\n$$\n这里，$\\boldsymbol{I}$ 是 $2 \\times 2$ 的单位矩阵，而 $\\frac{\\partial \\boldsymbol{f}}{\\partial \\boldsymbol{y}}$ 是 ODE 右端项的雅可比矩阵，如下所示：\n$$\n\\frac{\\partial \\boldsymbol{f}}{\\partial \\boldsymbol{y}}(\\boldsymbol{y}) =\n\\begin{bmatrix}\n-k - c + 2 a y_1  c \\\\\n\\frac{1}{\\varepsilon}  -\\frac{1}{\\varepsilon} - 2 b y_2\n\\end{bmatrix}\n$$\n牛顿-拉夫逊方法的收敛性关键取决于雅可比矩阵 $\\boldsymbol{J}$ 的性质。具体来说，$\\boldsymbol{J}$ 的条件数至关重要。谱条件数 $\\kappa_2(\\boldsymbol{J}) = \\lVert \\boldsymbol{J} \\rVert_2 \\lVert \\boldsymbol{J}^{-1} \\rVert_2$ 衡量了线性系统 $\\boldsymbol{J} \\Delta\\boldsymbol{y} = -\\boldsymbol{G}$ 的解对扰动的敏感度。大的条件数表明 $\\boldsymbol{J}$ 近似奇异，这可能导致计算出的步长 $\\Delta\\boldsymbol{y}$ 出现大的数值误差，从而减慢收敛速度或阻止收敛。\n\n对于小的 $\\varepsilon$，项 $1/\\varepsilon$ 在 $\\frac{\\partial \\boldsymbol{f}}{\\partial \\boldsymbol{y}}$ 中占主导地位。残差的雅可比矩阵变为：\n$$\n\\boldsymbol{J}(\\boldsymbol{y}) =\n\\begin{bmatrix}\n1 - h(-k - c + 2 a y_1)  -hc \\\\\n-\\frac{h}{\\varepsilon}  1 - h(-\\frac{1}{\\varepsilon} - 2 b y_2)\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n1 + h(k + c - 2 a y_1)  -hc \\\\\n-\\frac{h}{\\varepsilon}  1 + \\frac{h}{\\varepsilon} + 2 h b y_2\n\\end{bmatrix}\n$$\n当比率 $h/\\varepsilon$ 很大时，包含该项的矩阵元素将占主导地位。这导致 $\\boldsymbol{J}$ 的奇异值变得非常分散，从而使条件数 $\\kappa_2(\\boldsymbol{J})$ 增大，近似与 $h/\\varepsilon$ 成正比。这种病态是将在一个刚性系统上应用数值方法时，所用步长 $h$ 相对于最快时间尺度（量级为 $\\varepsilon$）过大的直接后果。\n\n将要实现的算法会对每个测试用例 $(\\varepsilon, h)$ 执行以下操作：\n1. 用 $\\boldsymbol{y}^{(0)} = \\boldsymbol{y}_n = [0.9, 0.1]^\\top$ 初始化牛顿-拉夫逊迭代。\n2. 对于从 $0$ 到最大值 $M=50$ 的每次迭代 $k$：\n    a. 计算残差 $\\boldsymbol{G}(\\boldsymbol{y}^{(k)})$ 及其欧几里得范数 $\\lVert \\boldsymbol{G}(\\boldsymbol{y}^{(k)}) \\rVert_2$。\n    b. 计算雅可比矩阵 $\\boldsymbol{J}(\\boldsymbol{y}^{(k)})$ 及其谱条件数 $\\kappa_2(\\boldsymbol{J}(\\boldsymbol{y}^{(k)}))$。存储此值。\n    c. 如果 $\\lVert \\boldsymbol{G}(\\boldsymbol{y}^{(k)}) \\rVert_2 \\le \\tau = 10^{-10}$，则迭代收敛。记录迭代次数 $k$ 和迄今为止观察到的最大条件数。\n    d. 否则，求解线性系统 $\\boldsymbol{J}(\\boldsymbol{y}^{(k)}) \\Delta\\boldsymbol{y} = -\\boldsymbol{G}(\\boldsymbol{y}^{(k)})$ 以获得更新量 $\\Delta\\boldsymbol{y}$。\n    e. 更新状态：$\\boldsymbol{y}^{(k+1)} = \\boldsymbol{y}^{(k)} + \\Delta\\boldsymbol{y}$。\n3. 如果在 $M$ 次迭代内未达到收敛，或如果线性求解因奇异性而失败，则迭代次数记录为 $-1$。在所有情况下，报告的条件数是在所有计算出的迭代中观察到的最大值。\n\n此过程在提供的 Python 脚本中实现，该脚本系统地评估每个测试用例并计算所需的量。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the specified stiff ODE problem using BDF-1 and Newton-Raphson,\n    and reports on convergence and Jacobian conditioning.\n    \"\"\"\n    # Define constants and initial conditions as specified in the problem.\n    K_PARAM = 1.0\n    C_PARAM = 10.0\n    A_PARAM = 1.0\n    B_PARAM = 1.0\n    Y_N = np.array([0.9, 0.1], dtype=np.float64)\n    TOLERANCE = 1e-10\n    MAX_ITERATIONS = 50\n\n    test_cases = [\n        # (epsilon, h)\n        (1.0, 0.05),\n        (1e-3, 0.05),\n        (1e-6, 0.05),\n        (1e-3, 0.5),\n        (1e-6, 0.5)\n    ]\n\n    def ode_rhs(y, eps):\n        \"\"\"Computes the right-hand side f(y) of the ODE.\"\"\"\n        y1, y2 = y\n        dy1_dt = -K_PARAM * y1 + C_PARAM * (y2 - y1) + A_PARAM * y1**2\n        dy2_dt = (1.0 / eps) * (y1 - y2) - B_PARAM * y2**2\n        return np.array([dy1_dt, dy2_dt], dtype=np.float64)\n\n    def ode_jacobian(y, eps):\n        \"\"\"Computes the Jacobian of the ODE's right-hand side, df/dy.\"\"\"\n        y1, y2 = y\n        return np.array([\n            [-K_PARAM - C_PARAM + 2.0 * A_PARAM * y1, C_PARAM],\n            [1.0 / eps, -1.0 / eps - 2.0 * B_PARAM * y2]\n        ], dtype=np.float64)\n\n    def run_single_bdf_step(eps, h):\n        \"\"\"\n        Performs a single BDF-1 step, solving the nonlinear system\n        with Newton-Raphson iteration.\n        \"\"\"\n        y_k = np.copy(Y_N)\n        cond_numbers = []\n\n        for k in range(MAX_ITERATIONS):  # Corresponds to iterations k=0, 1, ..., M-1\n            # At the start of iteration k, we evaluate the state y_k = y^{(k)}\n            f_val = ode_rhs(y_k, eps)\n            g_val = y_k - Y_N - h * f_val\n            \n            df_dy_val = ode_jacobian(y_k, eps)\n            j_val = np.identity(2) - h * df_dy_val\n\n            # Calculate and store condition number for the current iterate\n            try:\n                cond_numbers.append(np.linalg.cond(j_val, 2))\n            except np.linalg.LinAlgError:\n                # Jacobian is singular, Newton iteration cannot proceed.\n                max_c = max(cond_numbers) if cond_numbers else np.inf\n                return -1, np.log10(max_c if max_c > 0 else 1.0)\n\n            # Check for convergence\n            if np.linalg.norm(g_val) = TOLERANCE:\n                return k, np.log10(max(cond_numbers))\n\n            # Solve the linear system for the Newton update\n            try:\n                delta_y = np.linalg.solve(j_val, -g_val)\n            except np.linalg.LinAlgError:\n                return -1, np.log10(max(cond_numbers))\n\n            # Update the iterate for the next step -> y^{(k+1)}\n            y_k += delta_y\n        \n        # After MAX_ITERATIONS, we have y^{(M)}. Perform a final check.\n        f_val = ode_rhs(y_k, eps)\n        g_val = y_k - Y_N - h * f_val\n        \n        df_dy_val = ode_jacobian(y_k, eps)\n        j_val = np.identity(2) - h * df_dy_val\n        try:\n            cond_numbers.append(np.linalg.cond(j_val, 2))\n        except np.linalg.LinAlgError:\n            pass # The iteration already failed to converge, just record max condition number\n\n        max_c = max(cond_numbers) if cond_numbers else 1.0\n        if np.linalg.norm(g_val) = TOLERANCE:\n            return MAX_ITERATIONS, np.log10(max_c)\n        else:\n            return -1, np.log10(max_c)\n\n    # --- Main execution loop ---\n    results_list = []\n    for epsilon, h_step in test_cases:\n        num_iterations, log_max_cond_num = run_single_bdf_step(epsilon, h_step)\n        results_list.append(num_iterations)\n        results_list.append(log_max_cond_num)\n\n    # Print the final result in the exact specified format.\n    print(f\"[{','.join(map(str, results_list))}]\")\n\nsolve()\n```"
        }
    ]
}