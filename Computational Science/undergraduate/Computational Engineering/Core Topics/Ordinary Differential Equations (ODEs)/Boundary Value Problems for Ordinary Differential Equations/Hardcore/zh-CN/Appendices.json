{
    "hands_on_practices": [
        {
            "introduction": "有限差分法是将微分方程转化为计算机可以求解的代数方程组的一种强大技术。本练习将指导您完成一个边值问题的离散化过程，其中包括如何处理导数（诺伊曼）边界条件，这是许多工程仿真中的常见任务。通过这个实践，您将掌握将连续问题转化为离散问题的基本技能。",
            "id": "2173556",
            "problem": "考虑由常微分方程\n$$y'' - y = -x$$\n定义的两点边值问题，其区间为 $0 \\le x \\le 1$。边界条件由 $y'(0) = 1$ 和 $y(1) = 2$ 给出。\n\n我们希望使用有限差分法求此问题的近似数值解。将区间 $[0, 1]$ 划分为 $n=3$ 个等宽的子区间，宽度为 $h$。令 $y_i$ 表示在网格点 $x_i = i h$（$i=0, 1, 2, 3$）处解 $y(x_i)$ 的数值近似。\n\n为离散化该微分方程，使用二阶中心差分近似来处理二阶导数，即 $y''(x_i) \\approx \\frac{y_{i+1} - 2y_i + y_{i-1}}{h^2}$。对于 $x=0$ 处的导数边界条件，使用一阶向前差分近似，即 $y'(x_0) \\approx \\frac{y_1 - y_0}{h}$。此过程将生成一个关于未知值 $y_0, y_1, y_2$ 的线性方程组。\n\n计算 $y(0)$ 的数值近似值。将答案表示为最简分数形式。",
            "solution": "我们将区间划分为 $n=3$ 个相等的子区间，因此 $h=(1-0)/3=1/3$。网格点为 $x_{i}=ih$，$i=0,1,2,3$，右边界值给出 $y_{3}=2$。\n\n对 $x=0$ 处的导数边界条件使用一阶向前差分，\n$$\n\\frac{y_{1}-y_{0}}{h}=1 \\quad \\Rightarrow \\quad y_{1}=y_{0}+h.\n$$\n对内部节点 $i=1$ 和 $i=2$ 使用二阶中心差分，我们有\n$$\n\\frac{y_{i+1}-2y_{i}+y_{i-1}}{h^{2}}-y_{i}=-x_{i}.\n$$\n对于 $i=1$，由于 $x_{1}=h$，\n$$\n\\frac{y_{2}-2y_{1}+y_{0}}{h^{2}}-y_{1}=-h,\n$$\n两边乘以 $h^{2}$ 后变为\n$$\ny_{2}-2y_{1}+y_{0}-h^{2}y_{1}=-h^{3}.\n$$\n代入 $y_{1}=y_{0}+h$ 得\n$$\ny_{2}+(-1-h^{2})y_{0}-(2+h^{2})h=-h^{3},\n$$\n所以\n$$\ny_{2}=(1+h^{2})y_{0}+(2+h^{2})h-h^{3}.\n$$\n对于 $i=2$，有 $x_{2}=2h$ 和 $y_{3}=2$，\n$$\n\\frac{y_{3}-2y_{2}+y_{1}}{h^{2}}-y_{2}=-2h,\n$$\n或者，两边乘以 $h^{2}$，\n$$\ny_{3}-2y_{2}+y_{1}-h^{2}y_{2}=-2h^{3}.\n$$\n代入 $y_{3}=2$，$y_{1}=y_{0}+h$ 以及 $y_2$ 的表达式，得到\n$$\n2+y_{0}+h-(2+h^{2})\\left[(1+h^{2})y_{0}+(2+h^{2})h-h^{3}\\right]=-2h^{3}.\n$$\n令 $A=2+h^{2}$，方程变为\n$$\n2+y_{0}+h-A(1+h^{2})y_{0}-A^{2}h+Ah^{3}=-2h^{3}.\n$$\n整理得，\n$$\n\\left[1-A(1+h^{2})\\right]y_{0}=-2h^{3}-2-h-Ah^{3}+A^{2}h.\n$$\n由于 $A(1+h^{2})=2+3h^{2}+h^{4}$，系数简化为 $-(1+3h^{2}+h^{4})$，等式右边简化为 $-2+3h$。因此，\n$$\n-(1+3h^{2}+h^{4})\\,y_{0}=-2+3h \\quad \\Rightarrow \\quad y_{0}=\\frac{2-3h}{1+3h^{2}+h^{4}}.\n$$\n当 $h=\\frac{1}{3}$ 时，我们计算\n$$\n2-3h=2-1=1,\\qquad 1+3h^{2}+h^{4}=1+\\frac{1}{3}+\\frac{1}{81}=\\frac{109}{81}.\n$$\n于是\n$$\ny_{0}=\\frac{1}{109/81}=\\frac{81}{109}.\n$$\n因此，$y(0)$ 的有限差分近似值为 $\\frac{81}{109}$。",
            "answer": "$$\\boxed{\\frac{81}{109}}$$"
        },
        {
            "introduction": "打靶法巧妙地将边值问题（BVP）转化为初值问题（IVP），并利用求根算法来满足边界条件。虽然这种方法对于线性问题很直观，但非线性边值问题可能表现出复杂的行为。本编程练习将通过研究具有多个解、无解甚至连续解族的问题来探索这些细微差别，突显在处理非线性系统时进行仔细分析的重要性。",
            "id": "2375115",
            "problem": "考虑常微分方程两点边值问题在无量纲设置下的打靶法公式。令 $x \\in [a,b]$ 表示自变量，令 $y(x)$ 表示因变量。对于一个二阶常微分方程，引入打靶参数 $s$ 作为 $x=a$ 处缺失的初始条件，并定义一个标量求根函数 $F(s)$，其零点（或多个零点）编码了在 $x=b$ 处边界条件的满足情况。具体来说，当左边界为狄利克雷（Dirichlet）边界条件时，取 $y(a) = \\alpha$ 和 $y^{\\prime}(a) = s$，并设 $F(s) = y(b;s) - \\beta$。当右边界为诺伊曼（Neumann）边界条件时，取 $y^{\\prime}(b) = \\gamma$ 并设 $F(s) = y^{\\prime}(b;s) - \\gamma$。映射 $s \\mapsto F(s)$ 可能有多个根、没有根或有连续统的根，这取决于非线性程度。\n\n你的任务是实现一个程序，对三个精心选择的非线性边值问题，使用初值问题的数值积分和标量求根区间法来刻画相应打靶函数 $F(s)$ 的根结构。任何三角表达式中使用的角度必须以弧度为单位进行解释。\n\n从以下基本依据出发：对于光滑右端项的初值问题，存在唯一的局部解；在保守情况下，乘以 $y^{\\prime}$ 可得到运动的第一积分。仅使用打靶法的定义以及初值问题的基本存在性和唯一性作为你的出发点。除非能从此基础上推导出来，否则不要假设任何显式解。\n\n定义三个测试案例如下。\n\n- 案例 A（具有狄利克雷-狄利克雷边界条件的非线性保守振子；预期有多个根）：考虑\n  $$ y^{\\prime\\prime}(x) + y(x)^3 = 0, \\quad x \\in [0,1] $$\n  边界条件为\n  $$ y(0) = 0, \\quad y(1) = 0. $$\n  定义打靶参数为 $s = y^{\\prime}(0)$，求根函数为 $F(s) = y(1;s) - 0$。对多个 $s$ 值进行初值问题的数值积分，以检测 $F(s)$ 的符号变化，然后将每个含根区间优化为一个根。对于一个网格间距为 $\\Delta s$ 的对称搜索区间 $[-S_{\\max}, S_{\\max}]$，报告在此区间内检测到的不同根的总数，计数对称的非零根以及（如果存在）在 $s = 0$ 处的根。使用测试参数 $S_{\\max} = 12$ 和 $\\Delta s = 0.05$。\n\n- 案例 B（具有诺伊曼-诺伊曼边界条件的非线性方程；预期没有根）：考虑\n  $$ y^{\\prime\\prime}(x) = 1 + \\big(y^{\\prime}(x)\\big)^2, \\quad x \\in [0,1] $$\n  边界条件为\n  $$ y^{\\prime}(0) = 0, \\quad y^{\\prime}(1) = 0. $$\n  使用 $s = y(0)$ 作为打靶参数，并定义 $F(s) = y^{\\prime}(1;s) - 0$。通过在两个不同的打靶值 $s_1 = -1$ 和 $s_2 = 1$ 处评估 $F(s)$，数值验证根不存在，证明 $F(s)$ 在这两点上均严格非零且符号相同。当且仅当此测试未检测到根时，返回一个布尔值 true。\n\n- 案例 C（具有诺伊曼-诺伊曼边界条件的非线性方程；预期有连续统的根）：考虑\n  $$ y^{\\prime\\prime}(x) = y(x)\\,y^{\\prime}(x), \\quad x \\in [0,1] $$\n  边界条件为\n  $$ y^{\\prime}(0) = 0, \\quad y^{\\prime}(1) = 0. $$\n  使用 $s = y(0)$ 作为打靶参数，并定义 $F(s) = y^{\\prime}(1;s) - 0$。通过在两个不同的打靶值 $s_1 = -0.3$ 和 $s_2 = 0.8$ 处评估 $F(s)$，并检查两个评估值是否在严格的数值公差内均为零，来数值验证存在连续统的根。当且仅当两个值在数值上都为零时，返回一个布尔值 true，这证明了存在多个不同的 $s$ 满足边界条件。\n\n实现要求和数值规格：\n\n- 对每个案例，将常微分方程表述为一阶系统：\n  $$ y^{\\prime} = v, \\quad v^{\\prime} = f(x, y, v). $$\n- 使用在 $[0,1]$ 上的初值问题的数值积分来评估 $F(s)$。如果在分析中使用三角函数，请将角度解释为弧度。\n- 在积分器中使用相对公差 $10^{-10}$ 和绝对公差 $10^{-12}$。\n- 对于案例 A，在 $[0, S_{\\max}]$ 上以间距 $\\Delta s$ 对 $F(s)$ 进行粗略扫描，以找到 $F(s)$ 的符号变化，并使用一个鲁棒的含根区间求根器优化每个区间。将计数镜像到 $[-S_{\\max}, 0)$，并包括在 $s=0$ 处可能检测到的根。\n- 对于案例 B 和 C，在指定的 $s$ 值处进行评估，并使用 $10^{-8}$ 的公差来判断是否为零。\n- 你的程序应产生单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。输出必须采用以下形式\n  $$ [M, \\text{NR}, \\text{CR}], $$\n  其中 $M$ 是在案例 A 中于 $[-S_{\\max}, S_{\\max}]$ 内检测到的整数根数，$\\text{NR}$ 是一个布尔值，表示通过指定测试在案例 B 中不存在根，$\\text{CR}$ 是一个布尔值，表示通过指定测试在案例 C 中检测到连续统。\n\n最终程序必须是完整的，并且无需用户输入即可运行，仅使用 Python 标准库和指定的科学库。本问题中的所有数值和参数都是无量纲的；任何计算或报告中均不涉及物理单位。",
            "solution": "所提出的问题要求使用打靶法对三个不同的非线性两点边值问题的解结构进行数值刻画。对问题陈述的严格验证证实了其有效性：它在科学上基于常微分方程理论，是适定的、客观的，并为数值实现提供了一套完整且一致的参数。我们将继续进行求解。\n\n打靶法将一个边值问题（BVP）转化为一个初值问题（IVP）。我们引入一个参数 $s$，表示在一个边界（比如 $x=a$）上缺失的初始条件。然后我们将得到的初值问题（IVP）数值积分到另一个边界 $x=b$。定义一个函数 $F(s)$，它当且仅当 $x=b$ 处的边界条件得到满足时等于零。$F(s)$ 的根对应于原始边值问题（BVP）的解。\n\n对于一个形如 $y^{\\prime\\prime} = g(x, y, y^{\\prime})$ 的一般二阶常微分方程（ODE），我们通过令 $y_0 = y$ 和 $y_1 = y^{\\prime}$ 将其重构为一个一阶系统。该系统是：\n$$\n\\begin{cases}\ny_0^{\\prime} = y_1 \\\\\ny_1^{\\prime} = g(x, y_0, y_1)\n\\end{cases}\n$$\n然后使用数值积分器求解该系统。对于此问题，我们使用指定的相对公差 $10^{-10}$ 和绝对公差 $10^{-12}$ 的高精度公差。\n\n### 案例 A：非线性保守振子\n边值问题是：\n$$ y^{\\prime\\prime}(x) + y(x)^3 = 0, \\quad x \\in [0,1], \\quad y(0) = 0, \\quad y(1) = 0 $$\n一阶系统是：\n$$ \\mathbf{y}^{\\prime} = \\begin{pmatrix} y_0^{\\prime} \\\\ y_1^{\\prime} \\end{pmatrix} = \\begin{pmatrix} y_1 \\\\ -y_0^3 \\end{pmatrix} $$\n$x=0$ 处的边界条件是狄利克雷类型，$y(0)=0$。我们引入打靶参数 $s = y^{\\prime}(0)$。因此，初值问题（IVP）的初始条件是 $\\mathbf{y}(0) = [y_0(0), y_1(0)]^T = [0, s]^T$。打靶函数 $F(s)$ 由右边界的条件 $y(1)=0$ 定义：\n$$ F(s) = y_0(1; s) - 0 = y_0(1; s) $$\n问题要求在区间 $s \\in [-12, 12]$ 内 $F(s)$ 的根的总数。\n\n该常微分方程是保守的，这表明解是振荡的，从而预期存在多个根。此外，该方程在变换 $y \\to -y$ 下是不变的。如果 $y(x;s)$ 是打靶参数 $s$ 的解，那么 $-y(x;s)$ 也是一个解。$-y(x;s)$ 的初始斜率是 $-y^{\\prime}(0;s) = -s$。因此，$F(-s) = y_0(1;-s) = -y_0(1;s) = -F(s)$。这种奇对称性意味着如果 $s_0 \\neq 0$ 是一个根，那么 $-s_0$ 也是一个根。此外，$F(0)=0$，对应于平凡解 $y(x)=0$，所以 $s=0$ 总是一个根。\n\n我们的步骤如下：\n1.  确定 $s=0$ 是一个根。\n2.  在区间 $(0, S_{\\max}]$ 中搜索根，其中 $S_{\\max} = 12$。我们用步长 $\\Delta s = 0.05$ 对此区间进行离散化。\n3.  对于离散化中发生符号变化的每个分段 $[s_i, s_{i+1}]$（即 $F(s_i)F(s_{i+1})  0$），我们使用一个鲁棒的数值求根器来确认在该区间内存在唯一的根。\n4.  计数为 $s>0$ 找到的根的数量。\n5.  由于对称性，根的总数是 $M = 1 + 2 \\times (\\text{正根的数量})$。\n\n### 案例 B：无解\n边值问题是：\n$$ y^{\\prime\\prime}(x) = 1 + \\big(y^{\\prime}(x)\\big)^2, \\quad x \\in [0,1], \\quad y^{\\prime}(0) = 0, \\quad y^{\\prime}(1) = 0 $$\n一阶系统是：\n$$ \\mathbf{y}^{\\prime} = \\begin{pmatrix} y_0^{\\prime} \\\\ y_1^{\\prime} \\end{pmatrix} = \\begin{pmatrix} y_1 \\\\ 1 + y_1^2 \\end{pmatrix} $$\n$x=0$ 处的边界条件是诺伊曼类型。因此，打靶参数被选为函数本身的值，即 $s = y(0)$。初始条件是 $\\mathbf{y}(0) = [s, 0]^T$。打靶函数由右边界条件 $y^{\\prime}(1)=0$ 导出：\n$$ F(s) = y_1(1; s) - 0 = y_1(1; s) $$\n关于 $y_1 = y^{\\prime}$ 的方程与 $y_0$ 解耦：$y_1^{\\prime} = 1 + y_1^2$。这是一个可分离方程：$dy_1 / (1 + y_1^2) = dx$。在初始条件 $y_1(0) = 0$ 下，从 $x=0$ 积分到一个一般的 $x$ 得到 $\\arctan(y_1(x)) = x$，或 $y_1(x) = \\tan(x)$。关键是，$y_1(x)$ 的这个解与 $y_0(0) = s$ 无关。因此，打靶函数是一个常数：\n$$ F(s) = y_1(1) = \\tan(1) \\approx 1.5574 $$\n由于 $F(s)$ 是一个非零常数，它没有根。我们通过在两个不同的点 $s_1 = -1$ 和 $s_2 = 1$ 处评估 $F(s)$，并确认两个值都是正且非零的，来数值验证这一点。如果此测试未检测到根，则布尔结果 `NR` 为 true。\n\n### 案例 C：连续统的解\n边值问题是：\n$$ y^{\\prime\\prime}(x) = y(x)\\,y^{\\prime}(x), \\quad x \\in [0,1], \\quad y^{\\prime}(0) = 0, \\quad y^{\\prime}(1) = 0 $$\n一阶系统是：\n$$ \\mathbf{y}^{\\prime} = \\begin{pmatrix} y_0^{\\prime} \\\\ y_1^{\\prime} \\end{pmatrix} = \\begin{pmatrix} y_1 \\\\ y_0 y_1 \\end{pmatrix} $$\n与案例 B 一样，我们使用打靶参数 $s = y(0)$，得到初始条件 $\\mathbf{y}(0) = [s, 0]^T$。打靶函数是 $F(s) = y_1(1; s)$。\n对系统的解析检查揭示了一个特殊性质。初始条件 $y_1(0)=0$ 将系统置于 $y_1$ 分量的平衡状态，因为 $y_1^{\\prime}(0) = y_0(0) y_1(0) = s \\cdot 0 = 0$。根据初值问题解的唯一性，如果初始状态是一个平衡点，它将保持在那里。因此，对于所有 $x \\in [0,1]$，$y_1(x) = 0$。这意味着 $y_0(x)$ 是常数，所以 $y_0(x) = y_0(0) = s$。\n对于任何常数 $s$，函数 $y(x) = s$ 和 $y^{\\prime}(x) = 0$ 是常微分方程 $y^{\\prime\\prime} = y y^{\\prime}$ 的一个有效解，因为它简化为 $0 = s \\cdot 0$。\n这个解同时满足两个边界条件 $y^{\\prime}(0)=0$ 和 $y^{\\prime}(1)=0$。因此，对于所有 $s$ 值，$F(s) = y_1(1; s) = 0$。存在一个连续统的解。我们通过在两个不同的点 $s_1 = -0.3$ 和 $s_2 = 0.8$ 处评估 $F(s)$，并检查两个值是否都在 $10^{-8}$ 的公差内为零，来数值验证这一点。如果此测试通过，则布尔结果 `CR` 为 true。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Solves three boundary value problems using the shooting method to characterize\n    the root structure of the corresponding shooting function F(s).\n    \"\"\"\n\n    # --- Case A: Nonlinear conservative oscillator ---\n    def solve_case_a():\n        s_max = 12.0\n        delta_s = 0.05\n        rtol = 1e-10\n        atol = 1e-12\n\n        def ode_a(t, y):\n            # y'' + y^3 = 0  =>  y0' = y1, y1' = -y0^3\n            y0, y1 = y\n            return [y1, -y0**3]\n\n        memo = {}\n        def F_a(s):\n            s_val = float(s)\n            if s_val in memo:\n                return memo[s_val]\n            \n            # Trivial case s=0\n            if abs(s_val)  1e-15:\n                return 0.0\n\n            # Initial condition: y(0)=0, y'(0)=s\n            y0 = [0.0, s_val]\n            sol = solve_ivp(ode_a, [0, 1], y0, rtol=rtol, atol=atol)\n            # F(s) = y(1;s)\n            result = sol.y[0, -1]\n            memo[s_val] = result\n            return result\n\n        # The trivial solution y(x)=0 corresponding to s=0 is a root.\n        root_count = 1  \n        \n        # Scan for roots for s > 0\n        positive_roots = 0\n        s_grid = np.arange(delta_s, s_max + delta_s, delta_s)\n        \n        f_prev = F_a(0)\n        s_prev = 0\n        \n        for s_curr in s_grid:\n            f_curr = F_a(s_curr)\n            if np.sign(f_curr) != np.sign(f_prev) and f_prev != 0:\n                # Bracket found, refine with brentq to confirm root\n                try:\n                    brentq(F_a, s_prev, s_curr)\n                    positive_roots += 1\n                except ValueError:\n                    # Should not happen if sign change is correct\n                    pass\n            s_prev = s_curr\n            f_prev = f_curr\n\n        # Total roots = 1 (for s=0) + 2 * (positive roots) due to symmetry\n        M = 1 + 2 * positive_roots\n        return M\n\n    # --- Case B: Nonlinear equation with no roots ---\n    def solve_case_b():\n        s1 = -1.0\n        s2 = 1.0\n        zero_tol = 1e-8\n        rtol = 1e-10\n        atol = 1e-12\n\n        def ode_b(t, y):\n            # y'' = 1 + (y')^2  =>  y0' = y1, y1' = 1 + y1^2\n            y0, y1 = y\n            return [y1, 1 + y1**2]\n\n        def F_b(s):\n            # Initial condition: y(0)=s, y'(0)=0\n            y0 = [s, 0.0]\n            sol = solve_ivp(ode_b, [0, 1], y0, rtol=rtol, atol=atol)\n            # F(s) = y'(1;s)\n            return sol.y[1, -1]\n\n        f_s1 = F_b(s1)\n        f_s2 = F_b(s2)\n        \n        # Analytically, F(s) = tan(1) for all s.\n        # Check if both are non-zero and have the same sign.\n        no_root_detected = (\n            abs(f_s1) > zero_tol and\n            abs(f_s2) > zero_tol and\n            np.sign(f_s1) == np.sign(f_s2)\n        )\n        return no_root_detected\n\n    # --- Case C: Nonlinear equation with a continuum of roots ---\n    def solve_case_c():\n        s1 = -0.3\n        s2 = 0.8\n        zero_tol = 1e-8\n        rtol = 1e-10\n        atol = 1e-12\n\n        def ode_c(t, y):\n            # y'' = y * y'  =>  y0' = y1, y1' = y0 * y1\n            y0, y1 = y\n            return [y1, y0 * y1]\n\n        def F_c(s):\n            # Initial condition: y(0)=s, y'(0)=0\n            y0 = [s, 0.0]\n            sol = solve_ivp(ode_c, [0, 1], y0, rtol=rtol, atol=atol)\n            # F(s) = y'(1;s)\n            return sol.y[1, -1]\n\n        f_s1 = F_c(s1)\n        f_s2 = F_c(s2)\n\n        # Analytically, F(s) = 0 for all s.\n        # Check if both evaluations are numerically zero.\n        continuum_detected = (\n            abs(f_s1)  zero_tol and\n            abs(f_s2)  zero_tol\n        )\n        return continuum_detected\n\n    # Calculate results for all cases\n    result_a = solve_case_a()\n    result_b = solve_case_b()\n    result_c = solve_case_c()\n\n    # Print in the specified format [M, NR, CR]\n    print(f\"[{result_a},{result_b},{result_c}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "现实世界中的工程问题很少只涉及单个孤立的方程，而常常是多个相互作用的物理过程。本练习将处理一个耦合的反应-扩散系统，这是一个与化学工程、材料科学和生物学相关的模型。您将使用专业级的BVP求解器来计算两种相互作用物质的浓度分布，展示如何应用这些数值工具来解决复杂的多物理场问题。",
            "id": "2375141",
            "problem": "考虑一个在一维闭区间 $[0,1]$ 上的稳态反应扩散系统，其中包含两种物质，其无量纲浓度分别为 $A(x)$ 和 $B(x)$。该系统由以下耦合边值问题描述\n$$D_A\\,A''(x) - k\\,A(x)\\,B(x) = 0,\\qquad D_B\\,B''(x) - k\\,A(x)\\,B(x) = 0,$$\n对于所有 $x \\in (0,1)$，其中 $D_A>0$ 和 $D_B>0$ 是无量纲扩散系数，$k \\ge 0$ 是无量纲反应速率。边界条件为\n$$A(0) = A_L,\\quad A(1) = A_R,\\quad B(0) = B_L,\\quad B(1) = B_R.$$\n\n你的任务是编写一个完整、可运行的程序，对下方指定的每个测试用例，计算标量\n$$I = \\int_{0}^{1} A(x)\\,B(x)\\,dx,$$\n其中 $A(x)$ 和 $B(x)$ 是在给定参数和边界数据下该系统的解。所有变量和参数均为无量纲。将每个 $I$ 的值以小数形式报告，四舍五入到小数点后六位。\n\n测试套件：\n- 测试用例1（一般情况）：$D_A=1.0$, $D_B=0.5$, $k=2.0$, $A_L=1.0$, $A_R=0.2$, $B_L=0.3$, $B_R=1.2$。\n- 测试用例2（无反应边界情况）：$D_A=1.0$, $D_B=1.0$, $k=0.0$, $A_L=0.0$, $A_R=1.0$, $B_L=1.0$, $B_R=0.0$。\n- 测试用例3（扩散系数差异悬殊）：$D_A=10.0$, $D_B=0.1$, $k=1.5$, $A_L=0.8$, $A_R=0.6$, $B_L=0.2$, $B_R=0.9$。\n\n最终输出格式：\n你的程序应生成单行输出，其中按顺序包含三个结果，形式为方括号括起来的逗号分隔列表，每个条目四舍五入到小数点后六位，例如 $[0.123456,0.234567,0.345678]$。",
            "solution": "对问题陈述进行验证。\n\n**1. 提取已知条件：**\n- 控制方程：$D_A\\,A''(x) - k\\,A(x)\\,B(x) = 0$ 和 $D_B\\,B''(x) - k\\,A(x)\\,B(x) = 0$ 对于 $x \\in (0,1)$。\n- 参数：无量纲扩散系数 $D_A > 0$、$D_B > 0$ 和无量纲反应速率 $k \\ge 0$。\n- 边界条件：$A(0) = A_L$，$A(1) = A_R$，$B(0) = B_L$，$B(1) = B_R$。\n- 目标：计算积分 $I = \\int_{0}^{1} A(x)\\,B(x)\\,dx$。\n- 测试套件：提供了三组不同的参数和边界条件。\n\n**2. 验证：**\n- **科学依据：** 该问题描述了一个典型的反应扩散系统，这是化学工程和数学生物学中一个基础且成熟的模型。其控制方程具有科学合理性。\n- **适定性：** 该问题是一个在闭区间上的、由两个耦合的二阶非线性常微分方程 (ODE) 组成的系统，并提供了四个边界条件（每个二阶方程对应两个）。这构成了一个适定的两点边值问题 (BVP)。所提供的参数具有物理真实性。\n- **客观性与完整性：** 该问题使用精确、无歧义的数学语言进行陈述。所有必要信息（方程、参数、边界条件、目标量）均已提供。问题是自洽且一致的。\n\n**3. 结论：**\n该问题是有效的。它是计算科学中一个标准的、适定的边值问题，可以使用成熟的数值方法求解。\n\n**求解方法：**\n\n任务是求解一个构成边值问题的耦合非线性ODE系统，然后计算一个涉及其解的定积分。\n\n首先，通过检查控制方程的结构，可以获得一些解析上的洞察：\n$$D_A\\,A''(x) = k\\,A(x)\\,B(x)$$\n$$D_B\\,B''(x) = k\\,A(x)\\,B(x)$$\n显而易见，$D_A\\,A''(x) = D_B\\,B''(x)$。对此关系式进行两次积分，可以揭示系统的一个线性不变量。令 $U(x) = D_A A(x) - D_B B(x)$。那么 $U''(x) = 0$，这意味着 $U(x)$ 是 $x$ 的一个线性函数。这个线性函数的系数由边界条件决定。这个性质可以用来将系统简化为单个更复杂的非线性ODE。然而，对于通用的数值求解器来说，直接处理原始的耦合系统更为直接和稳健。\n\nBVP的数值求解需要将二阶ODE系统转换为一阶ODE系统。定义状态向量 $\\mathbf{y}(x)$ 如下：\n$$\\mathbf{y}(x) = \\begin{bmatrix} y_1(x) \\\\ y_2(x) \\\\ y_3(x) \\\\ y_4(x) \\end{bmatrix} = \\begin{bmatrix} A(x) \\\\ A'(x) \\\\ B(x) \\\\ B'(x) \\end{bmatrix}$$\n原始系统随后被重写为一个包含四个一阶ODE的系统，$\\mathbf{y}'(x) = \\mathbf{f}(x, \\mathbf{y}(x))$：\n$$\n\\begin{cases}\ny_1'(x) = y_2(x) \\\\\ny_2'(x) = \\frac{k}{D_A} y_1(x) y_3(x) \\\\\ny_3'(x) = y_4(x) \\\\\ny_4'(x) = \\frac{k}{D_B} y_1(x) y_3(x)\n\\end{cases}\n$$\n相关的边界条件应用于定义域 $x \\in [0, 1]$ 的端点：\n$$y_1(0) = A_L, \\quad y_1(1) = A_R, \\quad y_3(0) = B_L, \\quad y_3(1) = B_R$$\n\n该系统是一个经典的两点边值问题。它将使用配置法进行求解，这是一种处理此类问题的稳健技术。SciPy库中的 `scipy.integrate.solve_bvp` 函数提供了此方法的实现。该求解器需要三个主要组成部分：\n1.  一个实现一阶ODE系统 $\\mathbf{f}(x, \\mathbf{y})$ 的函数。\n2.  一个定义边界条件残差的函数。对于此问题，残差为 $y_1(0) - A_L$、$y_1(1) - A_R$、$y_3(0) - B_L$ 和 $y_3(1) - B_R$。求解器将找到一个使这些残差为零的解。\n3.  在定义域 $[0, 1]$ 的点网格上对解的剖面进行初始猜测。边界值之间的线性插值提供了一个合适且简单的初始猜测。例如，$A(x)$ 的初始猜测是 $A_{guess}(x) = A_L + (A_R - A_L)x$。\n\n需要特别关注测试用例2，其中反应速率 $k=0$。在这种情况下，控制方程简化为 $A''(x) = 0$ 和 $B''(x) = 0$。其解是 $x$ 的线性函数，完全由其边界条件决定：$A(x) = (A_R-A_L)x + A_L$ 和 $B(x) = (B_R-B_L)x + B_L$。对于这种情况，积分 $I$ 可以解析计算，得到 $I = \\frac{1}{6}$。这个解析结果是验证通用数值实现正确性的一个宝贵验证点。数值求解器必须能正确处理 $k=0$ 的情况并复现此结果。\n\nBVP求解器找到解函数 $A(x)$ 和 $B(x)$（表示为连续样条函数）后，计算最终的量 $I = \\int_{0}^{1} A(x) B(x) dx$。这是通过在区间 $[0, 1]$ 上足够密集的点网格上计算乘积 $A(x)B(x)$，然后应用 `scipy.integrate.simpson` 提供的高阶数值积分法则（如辛普森法则）来实现的。\n\n对指定的三个测试用例分别执行此过程。每个用例得到的 $I$ 值都按照要求四舍五入到小数点后六位。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_bvp, simpson\n\ndef solve():\n    \"\"\"\n    Solves the coupled reaction-diffusion BVP for three test cases\n    and computes the specified integral.\n    \"\"\"\n    # Test cases are defined as tuples of parameters:\n    # (D_A, D_B, k, A_L, A_R, B_L, B_R)\n    test_cases = [\n        # Test Case 1 (general case)\n        (1.0, 0.5, 2.0, 1.0, 0.2, 0.3, 1.2),\n        # Test Case 2 (no reaction edge case)\n        (1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0),\n        # Test Case 3 (strongly unequal diffusivities)\n        (10.0, 0.1, 1.5, 0.8, 0.6, 0.2, 0.9),\n    ]\n\n    results = []\n    for case in test_cases:\n        DA, DB, k, AL, AR, BL, BR = case\n\n        # Define the ODE system dy/dx = f(x, y).\n        # The state vector y is [A, A', B, B'].\n        def ode_system(x, y):\n            # Unpack state variables for clarity\n            A, A_prime, B, B_prime = y[0], y[1], y[2], y[3]\n            \n            # The system of first-order ODEs\n            # A'' = (k/DA) * A * B\n            # B'' = (k/DB) * A * B\n            A_double_prime = (k / DA) * A * B if DA > 0 else 0\n            B_double_prime = (k / DB) * A * B if DB > 0 else 0\n            \n            # Return derivatives as a column vector\n            return np.vstack((A_prime, A_double_prime, B_prime, B_double_prime))\n\n        # Define the boundary conditions residual function.\n        # The solver aims to make the return values of this function zero.\n        def bc(ya, yb):\n            # ya: solution at x=0, yb: solution at x=1\n            # y_i[0] is A, y_i[2] is B\n            return np.array([ya[0] - AL,   # A(0) = AL\n                             yb[0] - AR,   # A(1) = AR\n                             ya[2] - BL,   # B(0) = BL\n                             yb[2] - BR])  # B(1) = BR\n\n        # Set up an initial mesh and a guess for the solution.\n        # A linear interpolation between boundary values is a robust guess.\n        x_mesh = np.linspace(0, 1, 50)\n        y_guess = np.zeros((4, x_mesh.size))\n        \n        # Guess for A(x) and A'(x)\n        y_guess[0, :] = AL + (AR - AL) * x_mesh\n        y_guess[1, :] = AR - AL\n        \n        # Guess for B(x) and B'(x)\n        y_guess[2, :] = BL + (BR - BL) * x_mesh\n        y_guess[3, :] = BR - BL\n        \n        # Solve the boundary value problem.\n        # tol sets the desired accuracy of the solution.\n        sol = solve_bvp(ode_system, bc, x_mesh, y_guess, tol=1e-7)\n\n        # Evaluate the solution on a fine grid for accurate integration.\n        x_eval = np.linspace(0, 1, 501)\n        y_eval = sol.sol(x_eval)\n        \n        # Extract the solution components A(x) and B(x).\n        A_x = y_eval[0]\n        B_x = y_eval[2]\n        \n        # Compute the integral I = integral(A(x)*B(x)) dx from 0 to 1\n        # using Simpson's rule for high accuracy.\n        integrand = A_x * B_x\n        integral_val = simpson(integrand, x_eval)\n        \n        results.append(integral_val)\n\n    # Format the final results as specified in the problem statement.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}