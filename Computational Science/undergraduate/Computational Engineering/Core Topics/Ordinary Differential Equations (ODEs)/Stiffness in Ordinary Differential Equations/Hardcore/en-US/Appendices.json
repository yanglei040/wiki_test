{
    "hands_on_practices": [
        {
            "introduction": "The first step in mastering stiff systems is to understand why they are a problem for standard numerical methods. This hands-on practice is designed to give you a firsthand look at this challenge by using a common explicit adaptive integrator on systems with varying degrees of stiffness. You will write a program to observe how stiffness forces an integrator to take impractically small time steps, not for accuracy, but purely to maintain numerical stability .",
            "id": "2439135",
            "problem": "Construct a program that analyzes step-size behavior of an explicit adaptive integrator on initial value problems exhibiting stiffness. For each given initial value problem, integrate the system and record the minimal accepted time step during the integration. Use an explicit Runge–Kutta–Fehlberg method of order five with an embedded order four estimator (Runge–Kutta–Fehlberg (RKF45)) with standard absolute and relative error control. For all problems, require absolute tolerance $\\mathrm{atol} = 10^{-9}$ and relative tolerance $\\mathrm{rtol} = 10^{-6}$. Define an accepted step as one for which the embedded local error estimate satisfies a standard weighted root-mean-square criterion less than or equal to $1$. Define “extreme step-size reduction” as the occurrence of a minimal accepted time step strictly less than $10^{-4}$ over the specified integration interval.\n\nYou must evaluate the following test suite of initial value problems:\n\n- Test A (nonstiff scalar): $$y'(t) = -y(t), \\quad y(0) = 1, \\quad t \\in [0, 10].$$\n- Test B (stiff scalar, forced linear): $$y'(t) = -10000\\,y(t) + 30000 - 20000\\,e^{-t}, \\quad y(0) = 0, \\quad t \\in [0, 0.1].$$\n- Test C (stiff linear two-component system): $$\\begin{aligned} y_1'(t) = -15\\,y_1(t), \\\\ y_2'(t) = -10000\\left(y_2(t) - y_1(t)\\right), \\end{aligned} \\quad \\begin{bmatrix} y_1(0) \\\\ y_2(0) \\end{bmatrix} = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}, \\quad t \\in [0, 0.2].$$\n\nFor each test, compute the minimal accepted step size $h_{\\min}$ encountered over the integration and determine a boolean value according to whether $h_{\\min}  10^{-4}$ holds. The required final output is a single line containing a comma-separated list of these three boolean results in order `[A,B,C]`, enclosed in square brackets. For example, an output of the form `[False,True,True]` indicates that extreme step-size reduction occurred for Test B and Test C but not for Test A.\n\nThere are no physical units in this problem. Angles do not appear. Percentages are not used. Your program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets, exactly in the order `[A,B,C]` as described above.",
            "solution": "The problem statement has been validated and is deemed valid. It is scientifically grounded, well-posed, objective, and contains all necessary information to construct a unique, verifiable solution. The problem lies within the domain of computational engineering and numerical analysis, specifically addressing the concept of stiffness in ordinary differential equations (ODEs).\n\nStiffness in an initial value problem arises when the solution contains components that vary on vastly different time scales. This poses a significant challenge for explicit numerical integration methods. While the rapidly decaying components (transients) may become negligible very quickly, their presence in the system's Jacobian matrix continues to impose a severe restriction on the integrator's step size to maintain numerical stability. The step size is constrained by the fastest time scale, even when accuracy considerations for the smooth, slow-varying part of the solution would permit a much larger step. This leads to computationally inefficient integrations, as the solver is forced to take an excessive number of very small steps.\n\nThe task is to demonstrate this phenomenon by analyzing the step-size behavior of an explicit adaptive integrator on three distinct ODE problems. The chosen integrator is a Runge-Kutta-Fehlberg method of order five with an embedded order-four error estimator, commonly known as RKF45. A modern, high-quality implementation of this class of method is the Dormand-Prince 5(4) pair, which is available in the `scipy` library as `scipy.integrate.solve_ivp` with `method='RK45'`. This will be the tool used for the numerical integration.\n\nThe integration process uses adaptive step-size control based on a local error estimate. At each step, an error is estimated by comparing the fifth-order solution with the embedded fourth-order one. This error, $E$, is measured using a weighted root-mean-square norm, and the step is accepted only if $E \\le 1$. The weights are functions of the specified absolute tolerance, $\\mathrm{atol} = 10^{-9}$, and relative tolerance, $\\mathrm{rtol} = 10^{-6}$. Specifically, for a solution vector $y$, the error is scaled by $\\mathrm{atol} + \\mathrm{rtol} \\times |y|$. After an accepted step of size $h$, the next step size is chosen to keep the estimated error near the target of $1$. If the error is too large, the step is rejected and retried with a smaller $h$.\n\nWe will analyze three initial value problems and record the minimum accepted step size, $h_{\\min}$, for each. The condition for \"extreme step-size reduction\" is defined as $h_{\\min}  10^{-4}$.\n\nTest A: Nonstiff scalar problem\nThe ODE is $y'(t) = -y(t)$ with $y(0)=1$ on $t \\in [0, 10]$.\nThe system's Jacobian is simply the scalar $J = [-1]$. The only eigenvalue is $\\lambda = -1$, corresponding to a time constant of $\\tau = 1/|\\lambda| = 1$. The solution is $y(t) = e^{-t}$. There is only one time scale, and it is not particularly fast. The step size selected by the adaptive integrator will be governed primarily by the accuracy requirements defined by $\\mathrm{atol}$ and $\\mathrm{rtol}$. We do not expect stability to force the step size to be pathologically small. Therefore, it is predicted that $h_{\\min}$ will not fall below the threshold of $10^{-4}$.\n\nTest B: Stiff scalar problem\nThe ODE is $y'(t) = -10000\\,y(t) + 30000 - 20000\\,e^{-t}$ with $y(0)=0$ on $t \\in [0, 0.1]$.\nThe Jacobian is $J = [-10000]$. The eigenvalue is $\\lambda = -10000$, corresponding to an extremely fast time constant of $\\tau = 1/|\\lambda| = 10^{-4}$. The stability region of an explicit Runge-Kutta method requires that the product of the step size $h$ and the eigenvalue $\\lambda$ lies within a bounded region in the complex plane. For real negative eigenvalues, this imposes a constraint of the form $h \\lesssim C/|\\lambda|$ for some constant $C$ of order $1$, which for this problem is $h \\lesssim C \\times 10^{-4}$. Even after the initial transient associated with this eigenvalue has decayed (which happens very quickly, within a few multiples of $10^{-4}$), this stability constraint remains in effect for the explicit integrator. Consequently, the step size will be severely limited throughout the entire integration interval. It is strongly predicted that $h_{\\min}$ will be less than $10^{-4}$.\n\nTest C: Stiff linear system\nThe system is given by:\n$$\n\\begin{aligned}\ny_1'(t) = -15\\,y_1(t) \\\\\ny_2'(t) = -10000\\left(y_2(t) - y_1(t)\\right)\n\\end{aligned}\n\\quad \\text{with} \\quad\n\\begin{bmatrix} y_1(0) \\\\ y_2(0) \\end{bmatrix} = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}\n\\quad \\text{on} \\quad t \\in [0, 0.2].\n$$\nThe Jacobian matrix of this system is:\n$$\nJ = \\frac{\\partial \\mathbf{f}}{\\partial \\mathbf{y}} = \\begin{bmatrix} -15  0 \\\\ 10000  -10000 \\end{bmatrix}\n$$\nSince this matrix is lower triangular, its eigenvalues are its diagonal entries: $\\lambda_1 = -15$ and $\\lambda_2 = -10000$. These correspond to two very different time scales: a slow one $\\tau_1 = 1/15 \\approx 0.067$ and a very fast one $\\tau_2 = 1/10000 = 10^{-4}$. The ratio of the magnitudes of the eigenvalues, the stiffness ratio, is $|\\lambda_2|/|\\lambda_1| = 10000/15 \\approx 667$, which is large and confirms the system is stiff. As with Test B, the stability of the explicit integrator is governed by the eigenvalue with the largest magnitude, $\\lambda_2 = -10000$. The step size $h$ will be constrained by the stability limit associated with this eigenvalue, forcing $h$ to remain on the order of $10^{-4}$ or smaller. Thus, it is predicted that $h_{\\min}  10^{-4}$.\n\nThe program will implement this analysis by calling `scipy.integrate.solve_ivp` for each case. The returned solution object contains an array `sol.t` of the time points at which the solution was computed. The sequence of accepted step sizes is then calculated as the successive differences in this array, `np.diff(sol.t)`. The minimum of these values is $h_{\\min}$, which is then compared against the $10^{-4}$ threshold to produce the required boolean output.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Analyzes step-size behavior of an explicit adaptive integrator on\n    initial value problems exhibiting stiffness, as per the problem description.\n    \"\"\"\n\n    # Define common parameters for the analysis.\n    atol = 1e-9\n    rtol = 1e-6\n    step_size_threshold = 1e-4\n\n    # Define the test cases.\n    test_cases = [\n        {\n            \"name\": \"A\",\n            \"fun\": lambda t, y: -y,\n            \"t_span\": [0, 10],\n            \"y0\": [1],\n        },\n        {\n            \"name\": \"B\",\n            \"fun\": lambda t, y: -10000 * y[0] + 30000 - 20000 * np.exp(-t),\n            \"t_span\": [0, 0.1],\n            \"y0\": [0],\n        },\n        {\n            \"name\": \"C\",\n            \"fun\": lambda t, y: np.array([-15 * y[0], -10000 * (y[1] - y[0])]),\n            \"t_span\": [0, 0.2],\n            \"y0\": [1, 0],\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        # Integrate the ODE system using the specified method and tolerances.\n        # The 'RK45' method in SciPy is the Dormand-Prince 5(4) pair, a standard\n        # high-quality implementation of the class of methods described in the problem.\n        sol = solve_ivp(\n            fun=case[\"fun\"],\n            t_span=case[\"t_span\"],\n            y0=case[\"y0\"],\n            method='RK45',\n            atol=atol,\n            rtol=rtol,\n        )\n\n        # The 'sol.t' attribute contains the time points of the accepted steps.\n        # The differences between consecutive time points are the accepted step sizes.\n        if len(sol.t)  2:\n            # This case should not occur for the given problems but is a safe check.\n            # If only one point (initial) exists, there are no steps.\n            # We can treat this as no extreme reduction, or handle as an error.\n            # For this problem's context, it indicates no steps were taken or needed,\n            # so no small steps were taken.\n            h_min = np.inf\n        else:\n            step_sizes = np.diff(sol.t)\n            h_min = np.min(step_sizes)\n\n        # Determine if extreme step-size reduction occurred.\n        # The problem defines this as h_min strictly less than the threshold.\n        extreme_reduction = h_min  step_size_threshold\n        results.append(extreme_reduction)\n\n    # Format the final output string as a comma-separated list of booleans.\n    # Python's `str(bool)` converts True to 'True' and False to 'False',\n    # which is not what the example output shows. The problem asks for a list\n    # of boolean values, which is commonly represented textually as true/false\n    # or True/False. We will stick to the standard Python representation.\n    # The example [False,True,True] uses capitalized boolean literals.\n    # Let's format it exactly as specified.\n    results_str = [str(r) for r in results]\n    \n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "After witnessing the limitations of explicit solvers, we now turn to their powerful counterparts: implicit methods. This exercise focuses on the simplest implicit stiff solver, the first-order Backward Differentiation Formula (BDF1), to build your intuition about its exceptional stability. By applying the method to the canonical test equation, you will computationally verify the properties of A-stability and L-stability, which are the theoretical cornerstones that allow these methods to take large time steps on stiff problems .",
            "id": "2439069",
            "problem": "Implement a one-step Backward Differentiation Formula method of order one for the scalar linear initial value problem defined by the canonical stiff test equation. Consider the ordinary differential equation given by $y^{\\prime}(t)=\\lambda y(t)$ with initial condition $y(0)=y_0$. Let the time grid be uniform with step size $h0$, so that $t_n = n h$ for integer $n \\ge 0$, and let $N$ denote the number of steps taken so that the final time is $t_N = N h$. For each test case listed below, use the same initial value $y_0=1$ and apply the implementation to approximate the numerical solution at $t_N$. Then, evaluate the specified property for each case using the stated quantitative criterion.\n\nRequired properties to evaluate:\n- A-stability check: For a case labeled as A-stability, return a boolean that is true if the numerical solution magnitude at $t_N$ does not exceed the initial magnitude, that is, if $\\lvert y_N \\rvert \\le \\lvert y_0 \\rvert$, and false otherwise.\n- L-stability check: For a case labeled as L-stability, return a boolean that is true if a single step produces stiff decay relative to the initial value, specifically if $\\lvert y_1 \\rvert / \\lvert y_0 \\rvert \\le \\tau_L$ with tolerance $\\tau_L=10^{-6}$, and false otherwise.\n- Zero-eigenvalue boundary check: For a case labeled as zero-boundary, return a boolean that is true if the numerical solution after $N$ steps equals the initial condition within a strict tolerance $\\tau_0=10^{-12}$, that is, if $\\lvert y_N - y_0 \\rvert \\le \\tau_0$, and false otherwise.\n\nTest suite:\n- Case 1 (A-stability): $\\lambda=-2.5$, $h=4.0$, $N=5$.\n- Case 2 (A-stability, extremely stiff but large step): $\\lambda=-10^3$, $h=10^2$, $N=2$.\n- Case 3 (L-stability): $\\lambda=-10^9$, $h=10^{-2}$, $N=1$, tolerance $\\tau_L=10^{-6}$.\n- Case 4 (Zero-eigenvalue boundary): $\\lambda=0$, $h=10$, $N=3$, tolerance $\\tau_0=10^{-12}$.\n- Case 5 (Non-A-stable configuration with positive $\\lambda$): $\\lambda=0.5$, $h=3.0$, $N=5$.\n- Case 6 (A-stability near a representative boundary on the negative real axis): $\\lambda=-10^{-12}$, $h=10^{12}$, $N=4$.\n\nAll computations are to be carried out in pure numbers without physical units. Angles are not involved. Percentages must not be used.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[result_1,result_2,\\dots,result_6]$), where each entry is a boolean in the order of the test suite listed above.",
            "solution": "The problem statement is critically examined and found to be valid. It is a well-posed, scientifically grounded problem in the field of computational engineering, specifically concerning the numerical stability of methods for solving stiff ordinary differential equations. All parameters and criteria are defined with sufficient precision.\n\nThe task is to implement the one-step Backward Differentiation Formula (BDF1), also known as the Backward Euler method, for the canonical stiff test equation $y'(t) = \\lambda y(t)$ with initial condition $y(0)=y_0$. We must then evaluate certain stability properties for a given set of test cases.\n\nFirst, we derive the numerical scheme. The BDF1 method approximates the derivative $y'(t)$ at time $t_{n+1}$ using a first-order backward difference:\n$$\ny'(t_{n+1}) \\approx \\frac{y_{n+1} - y_n}{h}\n$$\nwhere $y_n$ is the numerical approximation to $y(t_n)$, and $h = t_{n+1} - t_n$ is the constant time step. For the given ordinary differential equation (ODE), $y'(t_{n+1}) = \\lambda y(t_{n+1})$. The BDF1 discretization is therefore implicit:\n$$\n\\frac{y_{n+1} - y_n}{h} = \\lambda y_{n+1}\n$$\nTo obtain a recurrence relation, we must solve for $y_{n+1}$ in terms of $y_n$:\n$$\ny_{n+1} - y_n = h \\lambda y_{n+1}\n$$\n$$\ny_{n+1} (1 - h \\lambda) = y_n\n$$\n$$\ny_{n+1} = \\frac{1}{1 - h \\lambda} y_n\n$$\nThis recurrence relation defines the numerical solution at each time step. The term $R(z) = \\frac{1}{1 - z}$ where $z = h\\lambda$ is the stability function of the method. By repeated application of this formula, the numerical solution at step $N$ can be expressed in a closed form:\n$$\ny_N = \\left( \\frac{1}{1 - h \\lambda} \\right)^N y_0\n$$\nThis single formula is sufficient to evaluate all test cases. The initial condition is given as $y_0=1$.\n\nThe problem requires checking A-stability and L-stability. A numerical method is A-stable if its region of absolute stability contains the entire left half of the complex plane, i.e., $\\{z \\in \\mathbb{C} \\mid \\text{Re}(z) \\le 0 \\}$. This means that for any stable ODE (where $\\text{Re}(\\lambda) \\le 0$), the numerical solution does not grow, regardless of the step size $h$. For the BDF1 method, the stability function is $R(z) = (1 - z)^{-1}$. If we let $z = x + iy$ with $x \\le 0$, the squared magnitude is:\n$$\n|R(z)|^2 = \\left| \\frac{1}{1 - (x+iy)} \\right|^2 = \\frac{1}{(1-x)^2 + y^2}\n$$\nSince $x \\le 0$, it follows that $1-x \\ge 1$, and thus $(1-x)^2 \\ge 1$. Consequently, $|R(z)|^2 \\le 1$, which confirms that $|R(z)| \\le 1$ for all $\\text{Re}(z) \\le 0$. The BDF1 method is A-stable. The A-stability check, $|y_N| \\le |y_0|$, should therefore be true for all cases where $\\lambda \\le 0$.\n\nL-stability is a stronger condition requiring that, in addition to being A-stable, the stability function vanishes at infinity in the left-half plane: $\\lim_{\\text{Re}(z) \\to -\\infty} |R(z)| = 0$. For BDF1, as $\\text{Re}(z) \\to -\\infty$, $|1-z| \\to \\infty$, so $|R(z)| \\to 0$. The method is indeed L-stable. This property is crucial for stiff problems, where it ensures that components corresponding to very large negative eigenvalues are damped out rapidly.\n\nWe now evaluate each test case using the derived formula $y_N = (1 - h \\lambda)^{-N} y_0$ and the given criteria with $y_0 = 1$.\n\nCase 1 (A-stability): $\\lambda=-2.5$, $h=4.0$, $N=5$.\nThe product $z = h\\lambda = (4.0)(-2.5) = -10.0$.\n$y_5 = (\\frac{1}{1 - (-10.0)})^5 (1) = (\\frac{1}{11})^5$.\nThe criterion is $|y_5| \\le |y_0|$, which is $|\\frac{1}{11^5}| \\le 1$. This is true.\n\nCase 2 (A-stability): $\\lambda=-10^3$, $h=10^2$, $N=2$.\nThe product $z = h\\lambda = (10^2)(-10^3) = -10^5$.\n$y_2 = (\\frac{1}{1 - (-10^5)})^2 (1) = (\\frac{1}{100001})^2$.\nThe criterion is $|y_2| \\le |y_0|$, which is $|\\frac{1}{100001^2}| \\le 1$. This is true.\n\nCase 3 (L-stability): $\\lambda=-10^9$, $h=10^{-2}$, $N=1$, $\\tau_L=10^{-6}$.\nThe product $z = h\\lambda = (10^{-2})(-10^9) = -10^7$.\n$y_1 = (\\frac{1}{1 - (-10^7)})^1 (1) = \\frac{1}{10000001}$.\nThe criterion is $|y_1| / |y_0| \\le \\tau_L$, which is $|\\frac{1}{10000001}| \\le 10^{-6}$. This is equivalent to $\\frac{1}{10000001} \\le \\frac{1}{1000000}$, which is true.\n\nCase 4 (Zero-eigenvalue boundary): $\\lambda=0$, $h=10$, $N=3$, $\\tau_0=10^{-12}$.\nThe product $z = h\\lambda = (10)(0) = 0$.\n$y_3 = (\\frac{1}{1 - 0})^3 (1) = 1$.\nThe criterion is $|y_3 - y_0| \\le \\tau_0$, which is $|1 - 1| \\le 10^{-12}$, or $0 \\le 10^{-12}$. This is true.\n\nCase 5 (Non-A-stable configuration): $\\lambda=0.5$, $h=3.0$, $N=5$.\nThe ODE itself is unstable as $\\lambda  0$. The A-stability-style check $|y_N| \\le |y_0|$ is expected to fail.\nThe product $z = h\\lambda = (3.0)(0.5) = 1.5$.\n$y_5 = (\\frac{1}{1 - 1.5})^5 (1) = (\\frac{1}{-0.5})^5 = (-2)^5 = -32$.\nThe criterion is $|y_5| \\le |y_0|$, which is $|-32| \\le 1$, or $32 \\le 1$. This is false.\n\nCase 6 (A-stability): $\\lambda=-10^{-12}$, $h=10^{12}$, $N=4$.\nThe product $z = h\\lambda = (10^{12})(-10^{-12}) = -1$.\n$y_4 = (\\frac{1}{1 - (-1)})^4 (1) = (\\frac{1}{2})^4 = \\frac{1}{16}$.\nThe criterion is $|y_4| \\le |y_0|$, which is $|\\frac{1}{16}| \\le 1$. This is true.\n\nThe sequence of results is: True, True, True, True, False, True.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and tests the BDF1 method for the canonical stiff test equation\n    y'(t) = lambda * y(t) across a suite of predefined test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'id': 1, 'lambda_val': -2.5, 'h': 4.0, 'N': 5, 'check': 'A-stability', 'tol': None},\n        {'id': 2, 'lambda_val': -1.0e3, 'h': 1.0e2, 'N': 2, 'check': 'A-stability', 'tol': None},\n        {'id': 3, 'lambda_val': -1.0e9, 'h': 1.0e-2, 'N': 1, 'check': 'L-stability', 'tol': 1.0e-6},\n        {'id': 4, 'lambda_val': 0.0, 'h': 10.0, 'N': 3, 'check': 'zero-boundary', 'tol': 1.0e-12},\n        {'id': 5, 'lambda_val': 0.5, 'h': 3.0, 'N': 5, 'check': 'A-stability', 'tol': None},\n        {'id': 6, 'lambda_val': -1.0e-12, 'h': 1.0e12, 'N': 4, 'check': 'A-stability', 'tol': None},\n    ]\n\n    results = []\n    y0 = 1.0\n\n    for case in test_cases:\n        lambda_val = case['lambda_val']\n        h = case['h']\n        N = case['N']\n        check_type = case['check']\n        tol = case['tol']\n\n        # The closed-form solution for y_N is y_0 * (1 / (1 - h*lambda))^N\n        # Let z = h*lambda, the stability function is R(z) = 1 / (1 - z)\n        # y_N = y_0 * R(z)^N\n        # Using standard Python floats (double precision) is sufficient for these values.\n        z = h * lambda_val\n        R = 1.0 / (1.0 - z)\n\n        result_bool = False\n        if check_type == 'A-stability':\n            # Check if |y_N| = |y_0|\n            y_N = (R**N) * y0\n            result_bool = np.abs(y_N) = np.abs(y0)\n        elif check_type == 'L-stability':\n            # Check if |y_1| / |y_0| = tau_L\n            # For this case N is always 1\n            y_1 = R * y0\n            # Since y0=1.0, this simplifies to checking |y_1| = tol\n            result_bool = np.abs(y_1) / np.abs(y0) = tol\n        elif check_type == 'zero-boundary':\n            # Check if |y_N - y_0| = tau_0\n            y_N = (R**N) * y0\n            result_bool = np.abs(y_N - y0) = tol\n        \n        results.append(result_bool)\n\n    # Final print statement in the exact required format.\n    # The default string representation of a boolean in Python is 'True' or 'False'.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "In many scientific applications, stiffness does not affect the entire system uniformly. This final practice introduces a sophisticated and efficient strategy for such scenarios: the Implicit-Explicit (IMEX) method. You will implement an IMEX scheme for a reaction-diffusion model, a classic problem in computational science, treating the stiff part implicitly and the non-stiff part explicitly. This exercise demonstrates how to blend methods to create a solver that is both stable and computationally efficient for complex, multi-scale problems .",
            "id": "2439136",
            "problem": "Consider the initial value problem for a semidiscrete reaction-diffusion system obtained by a uniform second-order central-difference discretization of the one-dimensional spatial domain. Let the spatial domain be the closed interval $\\left[0,1\\right]$ with homogeneous Dirichlet boundary conditions. For an integer $N \\ge 1$, define a uniform grid of $N$ interior points at locations $x_j = \\dfrac{j}{N+1}$ for $j = 1,2,\\ldots,N$ with spacing $\\Delta x = \\dfrac{1}{N+1}$. Define the state vector $y(t) \\in \\mathbb{R}^N$ with components $y_j(t)$ approximating the solution at $x_j$. The semidiscrete ordinary differential equation (ODE) system is\n$$\n\\frac{d y}{d t} = A y + g(y),\n$$\nwhere the diffusion matrix $A \\in \\mathbb{R}^{N \\times N}$ is the standard discrete Laplacian with homogeneous Dirichlet boundary conditions,\n$$\nA = \\frac{D}{\\left(\\Delta x\\right)^2} \\operatorname{tridiag}\\left(1, -2, 1\\right),\n$$\nwith $D \\ge 0$ the diffusion coefficient, and the nonlinear reaction term $g: \\mathbb{R}^N \\to \\mathbb{R}^N$ acts componentwise as\n$$\n\\left[g(y)\\right]_j = \\lambda \\left(y_j - y_j^3\\right),\n$$\nwith $\\lambda \\in \\mathbb{R}$ the reaction coefficient. The initial condition is\n$$\ny_j(0) = \\sin\\!\\left(\\pi x_j\\right), \\quad j = 1,2,\\ldots,N.\n$$\n\nFor a given final time $T  0$ and a time step size $h  0$ such that $M = \\dfrac{T}{h}$ is an integer, define the time grid $t_n = n h$ for $n = 0,1,\\ldots,M$. Consider the unique sequence $\\{y^n\\}_{n=0}^M \\subset \\mathbb{R}^N$ satisfying\n$$\n\\left(I - h A\\right) y^{n+1} = y^n + h\\, g\\!\\left(y^n\\right), \\quad n = 0,1,\\ldots,M-1,\n$$\nwith $y^0$ given by the initial condition. For each specified parameter set, compute the discrete Euclidean norm (also known as the $L^2$ norm) of the terminal state $y^M$ defined by\n$$\n\\left\\|y^M\\right\\|_{2,\\Delta x} = \\sqrt{ \\Delta x \\sum_{j=1}^N \\left(y_j^M\\right)^2 }.\n$$\n\nAll quantities in this problem are dimensionless, and no physical units are required.\n\nTest Suite. For each of the following parameter sets $(N, D, \\lambda, T, h)$, compute the value of $\\left\\|y^M\\right\\|_{2,\\Delta x}$:\n- Case $1$: $(N, D, \\lambda, T, h) = (\\,50,\\, 1.0,\\, 5.0,\\, 0.1,\\, 0.001\\,)$.\n- Case $2$: $(N, D, \\lambda, T, h) = (\\,50,\\, 1.0,\\, 5.0,\\, 0.1,\\, 0.00005\\,)$.\n- Case $3$: $(N, D, \\lambda, T, h) = (\\,1,\\, 1.0,\\, 10.0,\\, 0.1,\\, 0.01\\,)$.\n- Case $4$: $(N, D, \\lambda, T, h) = (\\,50,\\, 0.0,\\, 5.0,\\, 0.1,\\, 0.01\\,)$.\n\nFinal Output Format. Your program should produce a single line of output containing the four results, one for each case in the order listed above, rounded to $8$ decimal places, as a comma-separated list enclosed in square brackets. For example, the output format must be exactly like\n$$\n\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4\\right].\n$$",
            "solution": "The problem statement has been evaluated and is determined to be valid. It is scientifically grounded, well-posed, and objective. It presents a clear computational task in the field of numerical analysis for partial differential equations, specifically concerning the solution of a semidiscrete reaction-diffusion system. The problem consists of simulating the system's evolution using a specified numerical scheme and computing a norm of the final state for several parameter sets.\n\nThe governing equation is a system of ordinary differential equations (ODEs) of the form $\\frac{d y}{d t} = A y + g(y)$, which arises from the spatial discretization (method of lines) of a one-dimensional reaction-diffusion partial differential equation. The term $A y$ represents the diffusion process, where $A$ is the discrete Laplacian matrix, and $g(y)$ is a nonlinear reaction term of Allen-Cahn type, $[g(y)]_j = \\lambda (y_j - y_j^3)$. Such systems are classic examples of stiff differential equations, as the timescales associated with diffusion (related to the eigenvalues of $A$) can be much faster than those of the reaction.\n\nThe numerical method prescribed for time integration is $(I - h A) y^{n+1} = y^n + h\\, g(y^n)$. This is a semi-implicit or implicit-explicit (IMEX) scheme. The stiff linear diffusion term $A y$ is treated implicitly (using the backward Euler method), while the nonlinear and potentially non-stiff reaction term $g(y)$ is treated explicitly (using the forward Euler method). This approach is highly suitable for stiff systems as the implicit treatment of the stiff part allows for larger time steps $h$ than a fully explicit method would permit, without encountering numerical instability. The stability of the method is governed by the explicit part, which requires $h$ to be sufficiently small with respect to the dynamics of the reaction term $g(y)$.\n\nThe solution algorithm proceeds as follows for each given parameter set $(N, D, \\lambda, T, h)$. First, we establish the computational grid and parameters: the number of spatial points $N$, the spatial step size $\\Delta x = \\frac{1}{N+1}$, and the number of time steps $M = T/h$. The initial state vector $y^0 \\in \\mathbb{R}^N$ is constructed according to the initial condition $y_j(0) = \\sin(\\pi x_j)$ at the grid points $x_j = j \\Delta x$ for $j=1, \\ldots, N$. The core of the algorithm is a time-stepping loop from $n=0$ to $M-1$. In each step, we must solve a linear system for the next state $y^{n+1}$. The equation can be rearranged as $L y^{n+1} = b$, where $L = (I - hA)$ is the system matrix and $b = y^n + hg(y^n)$ is the right-hand side vector computed from the current state $y^n$. The matrix $A = \\frac{D}{(\\Delta x)^2} \\operatorname{tridiag}(1, -2, 1)$ is tridiagonal, which means the matrix $L$ is also tridiagonal with main diagonal elements $1 + \\frac{2hD}{(\\Delta x)^2}$ and off-diagonal elements $-\\frac{hD}{(\\Delta x)^2}$. Such tridiagonal systems are efficiently solved using specialized algorithms; in our implementation, we will use the `scipy.linalg.solve_banded` function. This loop is executed $M$ times to advance the solution from the initial time $t=0$ to the final time $t=T$. Finally, after the last time step, we obtain the terminal state vector $y^M$. The required quantity, the discrete Euclidean norm $\\|y^M\\|_{2,\\Delta x}$, is computed using its definition, $\\|y^M\\|_{2,\\Delta x} = \\sqrt{ \\Delta x \\sum_{j=1}^N (y_j^M)^2 }$. This procedure is repeated for all four test cases provided.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef compute_one_case(N, D, lambda_val, T, h):\n    \"\"\"\n    Solves the semidiscrete reaction-diffusion system for one set of parameters.\n\n    Args:\n        N (int): Number of interior spatial grid points.\n        D (float): Diffusion coefficient.\n        lambda_val (float): Reaction coefficient.\n        T (float): Final time.\n        h (float): Time step size.\n\n    Returns:\n        float: The discrete Euclidean norm of the terminal state.\n    \"\"\"\n    # 1. Setup grid and parameters\n    dx = 1.0 / (N + 1)\n    # The problem statement guarantees M = T/h is an integer.\n    # Using round() guards against potential floating-point inaccuracies.\n    M = int(round(T / h))\n    x_grid = np.linspace(dx, 1.0 - dx, N)\n\n    # 2. Set initial condition y^0\n    y = np.sin(np.pi * x_grid)\n\n    # 3. Construct the time-stepping matrix L = (I - hA)\n    # The matrix A is D/dx^2 * tridiag(1, -2, 1).\n    # The matrix L is tridiagonal with diagonals:\n    # Main: 1 + 2*h*D/dx^2\n    # Off-diagonals: -h*D/dx^2\n    # This matrix is represented in the 'ab' banded format for scipy.linalg.solve_banded.\n    # The format requires a (3, N) array for a tridiagonal matrix.\n    \n    # Constant for off-diagonals\n    c = -h * D / (dx**2)\n    \n    # 'ab' matrix for solve_banded (l=1, u=1)\n    # Row 0: Super-diagonal (padded with one 0 at the start)\n    # Row 1: Main diagonal\n    # Row 2: Sub-diagonal (padded with one 0 at the end)\n    ab = np.zeros((3, N))\n    ab[0, 1:] = c\n    ab[1, :] = 1.0 - 2.0 * c \n    ab[2, :-1] = c\n    \n    # 4. Time-stepping loop\n    for _ in range(M):\n        # Calculate the right-hand side: y^n + h*g(y^n)\n        g_y = lambda_val * (y - y**3)\n        rhs = y + h * g_y\n        \n        # Solve the linear system (I - hA)y^{n+1} = rhs for y^{n+1}\n        y = solve_banded((1, 1), ab, rhs, check_finite=False)\n\n    # 5. Compute the final discrete L^2 norm\n    # norm = sqrt(dx * sum(y_j^M)^2)\n    final_norm = np.sqrt(dx * np.sum(y**2))\n    \n    return final_norm\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (50, 1.0, 5.0, 0.1, 0.001),     # Case 1\n        (50, 1.0, 5.0, 0.1, 0.00005),   # Case 2\n        (1, 1.0, 10.0, 0.1, 0.01),      # Case 3\n        (50, 0.0, 5.0, 0.1, 0.01),      # Case 4\n    ]\n\n    results = []\n    for case in test_cases:\n        N, D, lambda_val, T, h = case\n        result = compute_one_case(N, D, lambda_val, T, h)\n        # Format the result to 8 decimal places as required.\n        results.append(f\"{result:.8f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```"
        }
    ]
}