{
    "hands_on_practices": [
        {
            "introduction": "在计算科学中，许多现实世界的问题，例如化学反应动力学或电路模拟，本质上都是“刚性”的。这意味着系统包含以截然不同速率演化的过程，给数值求解带来了巨大挑战。本练习将通过一个典型的化学反应模型，让你亲身体验为何像前向欧拉法这样的显式方法因其严苛的稳定性限制而变得不切实际，以及为何像后向欧拉法这样的隐式方法是解决此类问题的稳健选择 。通过这个实践，你将不仅实现数值积分，还将从第一性原理出发进行稳定性分析，从而深化对数值稳定性和刚性问题本质的理解。",
            "id": "2446924",
            "problem": "编写一个完整的程序，用于分析一个由双物种不可逆反应产生的刚性初值问题并进行时间步进。其控制方程为如下线性系统的初值问题\n$$\n\\frac{d}{dt}\n\\begin{bmatrix}\ny_1(t)\\\\\ny_2(t)\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n-k_1  0\\\\\nk_1  -k_2\n\\end{bmatrix}\n\\begin{bmatrix}\ny_1(t)\\\\\ny_2(t)\n\\end{bmatrix},\\quad\n\\begin{bmatrix}\ny_1(0)\\\\\ny_2(0)\n\\end{bmatrix}\n=\n\\begin{bmatrix}\ny_{1,0}\\\\\ny_{2,0}\n\\end{bmatrix},\n$$\n其中 $y_1(t)$ 和 $y_2(t)$ 表示物种浓度，$k_1$ 和 $k_2$ 是反应速率，单位为 $\\mathrm{s}^{-1}$。当 $k_1 \\gg k_2$ 时，系统出现刚性。重点是初值问题时间步进的基础知识：显式时间步进的稳定性限制以及使用隐式方法的稳健积分。\n\n对于每个指定的测试用例，您的程序必须从第一性原理出发，完成以下所有任务：\n\n- 使用标量线性测试方程作为稳定性分析的基础，确定使前向欧拉方法 (Forward Euler method) 对该系统线性稳定的最大恒定时间步长 $h_{\\mathrm{FE}}$。通过其特征模态，论证从该系统到标量测试方程的映射是合理的，并要求对衰减最快的模态保持稳定。不要使用任何黑箱稳定性表。\n- 计算达到最终时间 $T$ 所需的最小整数步数 $N_{\\mathrm{FE}} = \\lceil T / h_{\\mathrm{FE}} \\rceil$（前向欧拉步数）。\n- 使用测试用例中提供的恒定时间步长 $h_{\\mathrm{BE}}$，通过后向欧拉方法（Backward Euler method，也称为隐式欧拉法）对系统进行数值积分。如果 $T$ 不是 $h_{\\mathrm{BE}}$ 的整数倍，则在最后走一个较短的步长，以确保最终时间恰好等于 $T$。\n- 在 $t=T$ 时评估解析解，并报告后向欧拉解在最终时间的相对误差，\n$$\n\\varepsilon = \\frac{\\left\\| \\mathbf{y}_{\\mathrm{BE}}(T) - \\mathbf{y}_{\\mathrm{exact}}(T) \\right\\|_2}{\\left\\| \\mathbf{y}_{\\mathrm{exact}}(T) \\right\\|_2},\n$$\n其中 $\\|\\cdot\\|_2$ 是欧几里得范数。\n\n您必须将推导建立在以下核心定义和事实上：\n- 初值问题的定义 $\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(t,\\mathbf{y})$，给定 $\\mathbf{y}(0)$。\n- 前向欧拉方法的更新公式 $\\mathbf{y}^{n+1} = \\mathbf{y}^n + h \\mathbf{f}(t^n,\\mathbf{y}^n)$ 及其标量线性测试方程 $\\dot{z} = \\lambda z$ 的放大因子 $1 + h \\lambda$。\n- 后向欧拉方法的更新公式 $\\mathbf{y}^{n+1} = \\mathbf{y}^n + h \\mathbf{f}(t^{n+1},\\mathbf{y}^{n+1})$，对于线性 $\\mathbf{f}$，这需要在每一步求解一个线性系统。\n\n为了验证，请使用通过求解该线性系统得到的闭式解析解：\n- $y_1(t) = y_{1,0} e^{-k_1 t}$。\n- 对于 $k_1 \\neq k_2$，$y_2(t) = y_{2,0} e^{-k_2 t} + \\dfrac{k_1 y_{1,0}}{k_2 - k_1}\\left( e^{-k_1 t} - e^{-k_2 t} \\right)$。\n- 对于 $k_1 = k_2$，$y_2(t) = \\left( y_{2,0} + k_1 y_{1,0} t \\right) e^{-k_2 t}$。\n\n测试套件和覆盖要求。您的程序必须运行以下独立的测试用例，这些用例共同涵盖了极端刚性、中度刚性、速率相近和速率完全相等边界的情况：\n- 用例 A（极端刚性，长时程）：$(k_1, k_2, T, h_{\\mathrm{BE}}, y_{1,0}, y_{2,0}) = (10^9, 1, 10, 10^{-2}, 1, 0)$。\n- 用例 B（中度刚性）：$(k_1, k_2, T, h_{\\mathrm{BE}}, y_{1,0}, y_{2,0}) = (10^3, 1, 10, 2\\times 10^{-2}, 1, 0)$。\n- 用例 C（速率相近，但不相等）：$(k_1, k_2, T, h_{\\mathrm{BE}}, y_{1,0}, y_{2,0}) = (5, 5.000001, 3, 5\\times 10^{-2}, 0.7, 0.3)$。\n- 用例 D（速率完全相等，边界情况）：$(k_1, k_2, T, h_{\\mathrm{BE}}, y_{1,0}, y_{2,0}) = (5, 5, 3, 5\\times 10^{-2}, 1, 0)$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，每个测试用例按顺序贡献一对 $[N_{\\mathrm{FE}}, \\varepsilon]$。要求的格式是\n$$\n\\big[ [N_{\\mathrm{FE}}^{(A)}, \\varepsilon^{(A)}], [N_{\\mathrm{FE}}^{(B)}, \\varepsilon^{(B)}], [N_{\\mathrm{FE}}^{(C)}, \\varepsilon^{(C)}], [N_{\\mathrm{FE}}^{(D)}, \\varepsilon^{(D)}] \\big].\n$$\n每对中的第一个条目是整数，第二个是浮点数。输出中不需要物理单位；报告纯数字即可。您的程序必须严格按照此格式打印一行，例如\n$$\n\\big[ [5000000000, 5.2\\times 10^{-2}], [\\dots], [\\dots], [\\dots] \\big],\n$$\n其中省略号将被其他用例的计算值替换。",
            "solution": "所提出的问题是有效的。它构成了一个适定的初值问题，是计算科学与工程中刚性线性系统的一个典型例子。该问题在科学上基于化学动力学和数值分析的原理，并提供了所有必要的数据和定义。我们将从第一性原理出发，进行严谨的推导和求解。\n\n该问题需要分析以下常微分方程组 (ODEs)\n$$\n\\frac{d\\mathbf{y}}{dt} = \\mathbf{A}\\mathbf{y}, \\quad \\text{with} \\quad \\mathbf{y}(t) = \\begin{bmatrix} y_1(t) \\\\ y_2(t) \\end{bmatrix}, \\quad \\mathbf{A} = \\begin{bmatrix} -k_1  0 \\\\ k_1  -k_2 \\end{bmatrix},\n$$\n以及初始条件 $\\mathbf{y}(0) = [y_{1,0}, y_{2,0}]^T$。参数 $k_1 > 0$ 和 $k_2 > 0$ 是反应速率。\n\n我们的分析将分三部分进行：首先，显式前向欧拉方法 (explicit Forward Euler method) 的稳定性分析；其次，隐式后向欧拉方法 (implicit Backward Euler method) 的实现；第三，根据所提供的解析解计算数值误差。\n\n**第 1 部分：前向欧拉方法的稳定性**\n\n对于线性系统 $\\dot{\\mathbf{y}} = \\mathbf{A}\\mathbf{y}$，数值方法的稳定性取决于该方法如何处理矩阵 $\\mathbf{A}$ 的特征模态。通过基变换，该系统可以解耦为一组形式为 $\\dot{z} = \\lambda z$ 的标量常微分方程，其中 $\\lambda$ 是矩阵 $\\mathbf{A}$ 的特征值。\n\n矩阵 $\\mathbf{A}$ 是下三角矩阵，因此其特征值即为其对角线元素：\n$$\n\\lambda_1 = -k_1 \\quad \\text{and} \\quad \\lambda_2 = -k_2.\n$$\n由于 $k_1, k_2 > 0$，两个特征值都是负实数。这些特征值决定了系统响应的时间尺度。$|\\lambda|$ 的大值对应于快速衰减的分量（“刚性”分量），而小值则对应于慢速分量。\n\n前向欧拉方法由更新规则 $\\mathbf{y}^{n+1} = \\mathbf{y}^n + h \\mathbf{f}(t^n, \\mathbf{y}^n)$ 定义。对于我们的线性系统，这变为 $\\mathbf{y}^{n+1} = \\mathbf{y}^n + h \\mathbf{A} \\mathbf{y}^n = (\\mathbf{I} + h\\mathbf{A})\\mathbf{y}^n$。此迭代的稳定性取决于放大矩阵 $\\mathbf{G} = \\mathbf{I} + h\\mathbf{A}$ 的谱半径小于或等于 $1$。这等价于要求对于 $\\mathbf{A}$ 的每个特征值 $\\lambda$，$\\mathbf{G}$ 对应的特征值 $1+h\\lambda$ 的模不大于 $1$。\n\n对于每个特征值 $\\lambda_i$，我们必须满足标量测试方程 $\\dot{z} = \\lambda_i z$ 的稳定性条件：\n$$\n|1 + h\\lambda_i| \\le 1.\n$$\n由于我们的特征值 $\\lambda_1 = -k_1$ 和 $\\lambda_2 = -k_2$ 是负实数，该不等式变为：\n$$\n-1 \\le 1 + h\\lambda_i \\le 1.\n$$\n右侧不等式 $1 + h\\lambda_i \\le 1$ 可简化为 $h\\lambda_i \\le 0$，对于 $h > 0$ 和 $\\lambda_i  0$ 恒成立。左侧不等式 $-1 \\le 1 + h\\lambda_i$ 得到 $h\\lambda_i \\ge -2$，即 $h \\le -2/\\lambda_i$。代入 $\\lambda_i = -k_i$，即为 $h \\le 2/k_i$。\n\n为了使数值格式对整个系统都稳定，时间步长 $h$ 必须同时对所有特征模态都稳定。这施加了最严格的约束，该约束来自于模最大的特征值（最快的时间尺度）：\n$$\nh \\le \\frac{2}{\\max(k_1, k_2)}.\n$$\n因此，前向欧拉方法允许的最大恒定时间步长为\n$$\nh_{\\mathrm{FE}} = \\frac{2}{\\max(k_1, k_2)}.\n$$\n任何更大的步长都会导致至少一个模态被放大，从而引发灾难性的数值不稳定性。达到时间 $T$ 所需的步数是满足 $N_{\\mathrm{FE}} \\cdot h_{\\mathrm{FE}} \\ge T$ 的最小整数 $N_{\\mathrm{FE}}$，由 $N_{\\mathrm{FE}} = \\lceil T / h_{\\mathrm{FE}} \\rceil$ 给出。\n\n**第 2 部分：使用后向欧拉方法进行积分**\n\n后向欧拉方法是一种隐式方法，其更新规则定义为：\n$$\n\\mathbf{y}^{n+1} = \\mathbf{y}^n + h \\mathbf{f}(t^{n+1}, \\mathbf{y}^{n+1}).\n$$\n对于线性系统 $\\dot{\\mathbf{y}} = \\mathbf{A}\\mathbf{y}$，这变为：\n$$\n\\mathbf{y}^{n+1} = \\mathbf{y}^n + h \\mathbf{A} \\mathbf{y}^{n+1}.\n$$\n为了求解未知状态 $\\mathbf{y}^{n+1}$，我们必须在每个时间步求解一个线性系统：\n$$\n(\\mathbf{I} - h\\mathbf{A})\\mathbf{y}^{n+1} = \\mathbf{y}^n.\n$$\n代入矩阵 $\\mathbf{A}$，我们得到：\n$$\n\\begin{bmatrix}\n1 + h k_1  0 \\\\\n-h k_1  1 + h k_2\n\\end{bmatrix}\n\\begin{bmatrix}\ny_1^{n+1} \\\\\ny_2^{n+1}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\ny_1^n \\\\\ny_2^n\n\\end{bmatrix}.\n$$\n这个下三角系统可以通过向前代入法高效求解。首先，我们求解 $y_1^{n+1}$：\n$$\n(1 + h k_1)y_1^{n+1} = y_1^n \\implies y_1^{n+1} = \\frac{y_1^n}{1 + h k_1}.\n$$\n然后，我们将此结果代入第二个方程以求解 $y_2^{n+1}$：\n$$\n-h k_1 y_1^{n+1} + (1 + h k_2)y_2^{n+1} = y_2^n \\implies y_2^{n+1} = \\frac{y_2^n + h k_1 y_1^{n+1}}{1 + h k_2}.\n$$\n后向欧拉方法是 A-稳定的，这意味着其绝对稳定区域包含整个复平面的左半部分。因此，对于任何刚性系统，无论时间步长 $h  0$ 多大，它都是稳定的。因此，步长 $h_{\\mathrm{BE}}$ 的选择是基于精度考虑，而非稳定性。这就是对刚性问题使用隐式方法的根本原因。\n\n积分从 $t=0$ 到 $T$ 使用给定的步长 $h_{\\mathrm{BE}}$ 进行。如果 $T$ 不是 $h_{\\mathrm{BE}}$ 的整数倍，算法将执行 $N = \\lfloor T/h_{\\mathrm{BE}} \\rfloor$ 个大小为 $h_{\\mathrm{BE}}$ 的完整步长，以及一个大小为 $h_{final} = T - N h_{\\mathrm{BE}}$ 的最后、较短的步长。\n\n**第 3 部分：误差计算**\n\n将系统积分至 $t=T$ 得到数值解 $\\mathbf{y}_{\\mathrm{BE}}(T)$ 后，我们将其与精确解析解 $\\mathbf{y}_{\\mathrm{exact}}(T)$ 进行比较。解析解由以下公式给出：\n-   $y_1(t) = y_{1,0} e^{-k_1 t}$。\n-   对于 $k_1 \\neq k_2$，$y_2(t) = y_{2,0} e^{-k_2 t} + \\frac{k_1 y_{1,0}}{k_2 - k_1} (e^{-k_1 t} - e^{-k_2 t})$。\n-   对于 $k_1 = k_2$，$y_2(t) = (y_{2,0} + k_1 y_{1,0} t) e^{-k_2 t}$。\n\n数值解在最终时间 $T$ 的相对误差使用欧几里得范数 ($\\|\\cdot\\|_2$) 计算：\n$$\n\\varepsilon = \\frac{\\left\\| \\mathbf{y}_{\\mathrm{BE}}(T) - \\mathbf{y}_{\\mathrm{exact}}(T) \\right\\|_2}{\\left\\| \\mathbf{y}_{\\mathrm{exact}}(T) \\right\\|_2}.\n$$\n这个量度量了对于所选步长 $h_{\\mathrm{BE}}$，后向欧拉积分的精度。分母对误差进行归一化，使其成为一个相对度量。所提供的测试用例将展示后向欧拉方法在不同刚性程度下的稳健性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Format: (k1, k2, T, h_BE, y1_0, y2_0)\n    test_cases = [\n        (1e9, 1.0, 10.0, 1e-2, 1.0, 0.0),\n        (1e3, 1.0, 10.0, 2e-2, 1.0, 0.0),\n        (5.0, 5.000001, 3.0, 5e-2, 0.7, 0.3),\n        (5.0, 5.0, 3.0, 5e-2, 1.0, 0.0),\n    ]\n\n    results = []\n    for k1, k2, T, h_BE, y1_0, y2_0 in test_cases:\n        # Part 1: Forward Euler stability analysis\n        # The largest stable time step is h_FE = 2 / max(|lambda_i|).\n        # Eigenvalues are -k1 and -k2.\n        h_FE = 2.0 / max(k1, k2)\n        \n        # Number of steps to reach T. Use np.ceil for ceiling operation.\n        N_FE = int(np.ceil(T / h_FE))\n\n        # Part 2: Backward Euler integration\n        y = np.array([y1_0, y2_0], dtype=np.float64)\n        current_time = 0.0\n        \n        # Determine number of steps and handle the final step if T is not a multiple of h_BE\n        num_steps = int(np.floor(T / h_BE))\n        last_h = T - num_steps * h_BE\n\n        # Integration loop for full steps\n        for _ in range(num_steps):\n            # Solve (I - hA)y_new = y_old\n            # y1_new = y1_old / (1 + h*k1)\n            y[0] = y[0] / (1.0 + h_BE * k1)\n            # y2_new = (y2_old + h*k1*y1_new) / (1 + h*k2)\n            y[1] = (y[1] + h_BE * k1 * y[0]) / (1.0 + h_BE * k2)\n        \n        # Final shorter step, if necessary\n        if last_h > 1e-15: # Use a tolerance for floating point comparison\n            y[0] = y[0] / (1.0 + last_h * k1)\n            y[1] = (y[1] + last_h * k1 * y[0]) / (1.0 + last_h * k2)\n\n        y_BE_T = y\n\n        # Part 3: Analytical solution and error calculation\n        y_exact_T = np.zeros(2, dtype=np.float64)\n        \n        # Analytical solution for y1(T)\n        y_exact_T[0] = y1_0 * np.exp(-k1 * T)\n\n        # Analytical solution for y2(T) depends on whether k1 and k2 are equal\n        if k1 == k2:\n            y_exact_T[1] = (y2_0 + k1 * y1_0 * T) * np.exp(-k2 * T)\n        else:\n            term1 = y2_0 * np.exp(-k2 * T)\n            # Check for k1 != k2 for the fraction\n            if abs(k2 - k1) > 1e-15:\n                factor = (k1 * y1_0) / (k2 - k1)\n                term2 = factor * (np.exp(-k1 * T) - np.exp(-k2 * T))\n                y_exact_T[1] = term1 + term2\n            else: # This case is for near-equal rates, but formula is robust enough\n                factor = (k1 * y1_0) / (k2 - k1)\n                term2 = factor * (np.exp(-k1 * T) - np.exp(-k2 * T))\n                y_exact_T[1] = term1 + term2\n\n        # Calculate the relative error using Euclidean norm\n        norm_diff = np.linalg.norm(y_BE_T - y_exact_T)\n        norm_exact = np.linalg.norm(y_exact_T)\n        \n        epsilon = norm_diff / norm_exact if norm_exact > 1e-15 else 0.0\n\n        results.append(f\"[{N_FE}, {epsilon:.12e}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\n# Execute the solver function\nsolve()\n```"
        },
        {
            "introduction": "我们通常认为，像四阶龙格库塔（RK4）这样的高阶数值方法总是比一阶的前向欧拉法更精确。然而，这种优势是建立在一个关键假设之上的：时间步长必须足够小，以精确捕捉解的所有重要特征。本练习将挑战这一直觉，通过构建一个特例，你将发现前向欧拉法在特定的大时间步长下，其精度竟能超越RK4方法 。这个看似反常的结果揭示了数值计算中的一个核心概念——混淆效应（aliasing），它警示我们在选择数值方法和步长时，必须批判性地思考问题本身的特性，而不能盲目迷信高阶方法的理论优势。",
            "id": "2446910",
            "problem": "考虑以下常微分方程 (ODE) 初值问题\n$$\n\\frac{dy}{dt} = f(t), \\quad y(0)=0,\n$$\n其右侧项为时间周期函数，定义如下。设 $p0$ 为周期，$A0$ 为振幅，$\\sigma \\in (0,0.5)$ 为无量纲宽度参数。定义归约相位\n$$\nr(t) = t - p \\left\\lfloor \\frac{t}{p} \\right\\rfloor \\in [0,p),\n$$\n中心化相位\n$$\ns(t) = r(t) - \\frac{p}{2},\n$$\n并设\n$$\nf(t) = A \\exp\\!\\left(-\\frac{s(t)^2}{2\\,(\\sigma p)^2}\\right).\n$$\n固定参数 $p=1.0$，$A=10.0$，$\\sigma=0.05$，以及最终时间 $T=64.0$。您将对区间 $[0,T]$ 上的近似解进行分析，采用以下规定的时间步长（单位均为秒）：$\\Delta t_1 = 1.0$，$\\Delta t_2 = 2.0$，$\\Delta t_3 = 0.5$ 和 $\\Delta t_4 = 0.125$。请注意，每个 $\\Delta t_i$ 都能整除 $T$。\n\n对于此数据，根据微积分基本定理应用于该 ODE，在时间 $T$ 的精确解可得，此处简化为\n$$\ny(T) \\;=\\; \\int_{0}^{T} f(t)\\,dt.\n$$\n因为 $f(t)$ 是周期为 $p$ 的周期函数，且 $T$ 是 $p$ 的整数倍，所以该积分可以用闭式形式计算为\n$$\ny(T) \\;=\\; \\frac{T}{p}\\, \\int_{0}^{p} A \\exp\\!\\left(-\\frac{(t-\\frac{p}{2})^2}{2\\,(\\sigma p)^2}\\right) dt \n\\;=\\; T \\, A \\, \\sigma \\, \\sqrt{2\\pi}\\, \\operatorname{erf}\\!\\left(\\frac{1}{2\\sqrt{2}\\,\\sigma}\\right),\n$$\n其中 $\\operatorname{erf}(\\cdot)$ 表示高斯误差函数。\n\n您的任务是，对于每个 $\\Delta t_i$，使用以下每种单步时间步进近似法，在均匀网格 $t_n = n\\,\\Delta t_i$ 上计算在时间 $T$ 的绝对误差：\n\n1) 前向欧拉法：\n$$\ny^{n+1}_{\\mathrm{FE}} \\;=\\; y^n_{\\mathrm{FE}} \\;+\\; \\Delta t_i \\, f(t_n), \n\\quad y^0_{\\mathrm{FE}} = 0.\n$$\n\n2) 经典四阶龙格-库塔法 (RK4)：\n\\begin{align*}\nk_1 = f(t_n),\\\\\nk_2 = f\\!\\left(t_n+\\tfrac{1}{2}\\Delta t_i\\right),\\\\\nk_3 = f\\!\\left(t_n+\\tfrac{1}{2}\\Delta t_i\\right),\\\\\nk_4 = f\\!\\left(t_n+\\Delta t_i\\right),\\\\\ny^{n+1}_{\\mathrm{RK4}} = y^n_{\\mathrm{RK4}} \\;+\\; \\Delta t_i \\,\\frac{k_1 + 2k_2 + 2k_3 + k_4}{6}, \n\\quad y^0_{\\mathrm{RK4}} = 0.\n\\end{align*}\n\n对于每个 $\\Delta t_i$，计算绝对误差\n$$\nE_{\\mathrm{FE}}(\\Delta t_i) \\;=\\; \\left|y_{\\mathrm{FE}}(T;\\Delta t_i) - y(T)\\right|, \n\\qquad\nE_{\\mathrm{RK4}}(\\Delta t_i) \\;=\\; \\left|y_{\\mathrm{RK4}}(T;\\Delta t_i) - y(T)\\right|.\n$$\n\n测试套件：\n- 情况 1：$\\Delta t_1 = 1.0$ (一个等于激励周期 $p$ 的大步长)。\n- 情况 2：$\\Delta t_2 = 2.0$ (一个等于 $2p$ 的非常大的步长)。\n- 情况 3：$\\Delta t_3 = 0.5$ (一个等于 $p/2$ 的中等步长)。\n- 情况 4：$\\Delta t_4 = 0.125$ (一个等于 $p/8$ 的小步长)。\n\n对于每种情况，报告布尔值\n$$\nB_i = \\big( E_{\\mathrm{FE}}(\\Delta t_i)  E_{\\mathrm{RK4}}(\\Delta t_i) \\big),\n$$\n即，对于该特定的 $\\Delta t_i$，前向欧拉法是否比四阶龙格-库塔法更精确。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含四种情况的布尔值，格式为用方括号括起来的逗号分隔列表，例如，“[True,False,True,False]”。",
            "solution": "问题陈述经过验证。\n\n第一步：提取已知条件\n- **ODE**：$\\frac{dy}{dt} = f(t)$，初始条件为 $y(0)=0$。\n- **激励函数定义**：\n  - 周期：$p  0$。\n  - 振幅：$A  0$。\n  - 无量纲宽度：$\\sigma \\in (0, 0.5)$。\n  - 归约相位：$r(t) = t - p \\left\\lfloor \\frac{t}{p} \\right\\rfloor \\in [0,p)$。\n  - 中心化相位：$s(t) = r(t) - \\frac{p}{2}$。\n  - 激励函数：$f(t) = A \\exp\\!\\left(-\\frac{s(t)^2}{2\\,(\\sigma p)^2}\\right)$。\n- **固定参数**：$p=1.0$，$A=10.0$，$\\sigma=0.05$，最终时间 $T=64.0$。\n- **时间步长**：$\\Delta t_1 = 1.0$，$\\Delta t_2 = 2.0$，$\\Delta t_3 = 0.5$，$\\Delta t_4 = 0.125$。\n- **在 $T$ 处的精确解**：$y(T) = T \\, A \\, \\sigma \\, \\sqrt{2\\pi}\\, \\operatorname{erf}\\!\\left(\\frac{1}{2\\sqrt{2}\\,\\sigma}\\right)$。\n- **数值方法**：\n  - 前向欧拉法 (FE)：$y^{n+1}_{\\mathrm{FE}} = y^n_{\\mathrm{FE}} + \\Delta t_i \\, f(t_n)$，其中 $y^0_{\\mathrm{FE}} = 0$。\n  - 经典四阶龙格-库塔法 (RK4)：\n    $k_1 = f(t_n)$，$k_2 = f(t_n+\\tfrac{1}{2}\\Delta t_i)$，$k_3 = f(t_n+\\tfrac{1}{2}\\Delta t_i)$，$k_4 = f(t_n+\\Delta t_i)$，\n    $y^{n+1}_{\\mathrm{RK4}} = y^n_{\\mathrm{RK4}} + \\Delta t_i \\,\\frac{k_1 + 2k_2 + 2k_3 + k_4}{6}$，其中 $y^0_{\\mathrm{RK4}} = 0$。\n- **任务**：对于每个 $\\Delta t_i$，计算布尔值 $B_i = ( E_{\\mathrm{FE}}(\\Delta t_i)  E_{\\mathrm{RK4}}(\\Delta t_i) )$，其中 $E(\\Delta t_i) = |y_{\\text{approx}}(T;\\Delta t_i) - y(T)|$。\n\n第二步：使用提取的已知条件进行验证\n该问题是数值分析中一个明确定义的练习，特别是关于常微分方程的单步方法研究。\n- **科学依据**：该问题基于微积分和求解 ODE 的数值方法的基本概念。方程 $y' = f(t)$ 是非自治 ODE 的最简单形式。所提供的前向欧拉法和 RK4 是标准数值格式。精确解的推导在数学上是合理的。该问题没有科学缺陷。\n- **适定的**：该初值问题是适定的。函数 $f(t)$ 是连续且有界的，保证了解的唯一性。计算任务的规定是明确的。\n- **客观的**：该问题使用精确的数学语言陈述，不含任何主观或基于意见的内容。\n- **完整且一致**：所有必要的参数、方程、初始条件和方法都已提供。数据内部是一致的（例如，$T$ 是 $p$ 的整数倍，所有 $\\Delta t_i$ 都能整除 $T$）。\n- **不适定的/不切实际的**：该问题是一个标准的数值实验，并非不适定或不切实际。它所研究的现象——高阶方法在特定、选择不当的步长下可能比低阶方法精度更低——是数值分析中与采样和混叠相关的一个已知且重要的概念。\n\n第三步：结论与行动\n该问题是**有效的**。这是一个正确且有意义的计算工程练习。将提供一个解。\n\n目标是使用两种不同的数值方法——前向欧拉法 (FE) 和四阶龙格-库塔法 (RK4)——针对一组四个不同的时间步长 $\\Delta t_i$，求解初值问题 $dy/dt = f(t)$，$y(0)=0$ 在时间区间 $[0, T]$ 上的解。对于每种情况，我们必须确定一阶 FE 方法在最终时间 $T$ 产生的绝对误差是否小于四阶 RK4 方法。\n\n控制参数设置为 $p=1.0$，$A=10.0$，$\\sigma=0.05$ 和 $T=64.0$。激励函数 $f(t)$ 是一串周期为 $p$ 的类高斯脉冲。因为 ODE 的形式是 $dy/dt=f(t)$，解就是直接积分 $y(t) = \\int_0^t f(\\tau)d\\tau$。因此，数值格式是对这个积分的近似。具体来说，FE 方法得到的总累积值 $y(T)$ 对应于使用复合左矩形法则的积分近似，而对于这种特定的 ODE 形式，RK4 方法等价于复合辛普森法则。\n\n首先，我们使用提供的公式计算精确解 $y(T)$：\n$$\ny(T) = T \\, A \\, \\sigma \\, \\sqrt{2\\pi}\\, \\operatorname{erf}\\!\\left(\\frac{1}{2\\sqrt{2}\\,\\sigma}\\right)\n$$\n代入给定参数：\n$$\ny(T) = 64.0 \\cdot 10.0 \\cdot 0.05 \\cdot \\sqrt{2\\pi} \\cdot \\operatorname{erf}\\!\\left(\\frac{1}{2\\sqrt{2} \\cdot 0.05}\\right) = 32.0 \\cdot \\sqrt{2\\pi} \\cdot \\operatorname{erf}\\!\\left(\\frac{1}{0.1\\sqrt{2}}\\right) \\approx 80.2121\n$$\n误差函数的参数约为 $7.071$，此时 $\\operatorname{erf}$ 的值实际上是 $1.0$。\n\n接下来，我们为每个 $\\Delta t_i \\in \\{1.0, 2.0, 0.5, 0.125\\}$ 实现数值格式。对于每个 $\\Delta t$，步数为 $N = T / \\Delta t$。时间网格为 $t_n = n \\Delta t$，其中 $n=0, 1, \\dots, N$。\n\n流程如下：\n 对每个 $\\Delta t_i$：\n 1. 初始化 $y_{\\mathrm{FE}}^0=0$ 和 $y_{\\mathrm{RK4}}^0=0$。\n 2. 从 $n=0$ 迭代到 $N-1$：\n    - 计算 $f(t_n)$ 并更新 FE 解：$y_{\\mathrm{FE}}^{n+1} = y_{\\mathrm{FE}}^{n} + \\Delta t_i f(t_n)$。\n    - 计算 RK4 的阶段值 $k_1 = f(t_n)$，$k_2=k_3 = f(t_n+\\tfrac{1}{2}\\Delta t_i)$，$k_4 = f(t_n+\\Delta t_i)$，并更新 RK4 解：$y_{\\mathrm{RK4}}^{n+1} = y_{\\mathrm{RK4}}^{n} + \\Delta t_i (k_1 + 4k_2 + k_4)/6$。\n 3. 循环结束后，最终近似解为 $y_{\\mathrm{FE}}(T) = y_{\\mathrm{FE}}^N$ 和 $y_{\\mathrm{RK4}}(T) = y_{\\mathrm{RK4}}^N$。\n 4. 计算绝对误差：$E_{\\mathrm{FE}}(\\Delta t_i) = |y_{\\mathrm{FE}}(T) - y(T)|$ 和 $E_{\\mathrm{RK4}}(\\Delta t_i) = |y_{\\mathrm{RK4}}(T) - y(T)|$。\n 5. 评估布尔值 $B_i = (E_{\\mathrm{FE}}(\\Delta t_i)  E_{\\mathrm{RK4}}(\\Delta t_i))$。\n\n各情况分析：\n- **情况 1: $\\Delta t_1 = 1.0 = p$**：\n  - FE 在 $t_n = n \\cdot p$ 处对 $f(t)$ 进行采样。在这些点上，$r(t_n)=0$ 且 $s(t_n)=-p/2$。因此，$f(t_n) = A \\exp(-1/(8\\sigma^2)) \\approx 10 e^{-50}$，这几乎为零。FE 近似解 $y_{\\mathrm{FE}}(T)$ 将非常接近 $0$。误差 $E_{\\mathrm{FE}}$ 约为 $|0 - 80.2121| = 80.2121$。\n  - RK4 在 $t_n$、$t_n+p/2$ 和 $t_n+p$ 处采样。在 $t_n+p/2$ 处的采样点正好击中高斯脉冲的峰值，此时 $s(t)=0$ 且 $f(t)=A=10.0$。由于辛普森法则中赋予此中点采样很大的权重，该方法严重高估了每个周期上的积分。$y_{\\mathrm{RK4}}(T) \\approx (T/p) \\cdot (p/3)(f(0)+2A) \\approx 64 \\cdot (1/3)(0+20) = 426.67$。误差 $E_{\\mathrm{RK4}}$ 为 $|426.67 - 80.2121| \\approx 346.45$。\n  - 此处，$E_{\\mathrm{FE}}  E_{\\mathrm{RK4}}$。因此，$B_1$ 为 True。这个反直觉的结果展示了混叠现象：时间步长太大，无法解析 $f(t)$ 的特征，导致高阶方法灾难性地失败。\n\n- **情况 2: $\\Delta t_2 = 2.0 = 2p$**：\n  - FE 在 $t_n = n \\cdot 2p$ 处采样，得到 $f(t_n)=f(0) \\approx 0$。结果 $y_{\\mathrm{FE}}(T) \\approx 0$，误差 $E_{\\mathrm{FE}} \\approx 80.2121$。\n  - RK4 在 $t_n=n \\cdot 2p$、$t_n+p$ 和 $t_n+2p$ 处采样。$f(n \\cdot 2p)=f(0)$，$f(n \\cdot 2p+p)=f(p)=f(0)$，以及 $f(n \\cdot 2p+2p)=f(2p)=f(0)$。所有采样点都得到相同的近零值。\n  - 两种方法产生相同的结果：$y_{\\mathrm{FE}}(T) = y_{\\mathrm{RK4}}(T) \\approx 0$，导致 $E_{\\mathrm{FE}} = E_{\\mathrm{RK4}}$。\n  - 条件 $E_{\\mathrm{FE}}  E_{\\mathrm{RK4}}$ 为 False。因此，$B_2$ 为 False。\n\n- **情况 3: $\\Delta t_3 = 0.5 = p/2$**：\n  - FE 在 $t=0, 0.5, 1.0, 1.5, \\dots$ 处采样。它交替采样近零的尾部 $f(0)$ 和峰值 $f(0.5)=A=10$。这导致了很大的高估，$y_{\\mathrm{FE}}(T) \\approx (T/\\Delta t) \\cdot \\Delta t \\cdot (f(0)+f(0.5))/2 = T \\cdot A/2 = 320$。误差 $E_{\\mathrm{FE}} \\approx |320 - 80.2121| \\approx 239.79$。\n  - RK4 使用更精细的采样网格，包括像 $t=0.25$ 和 $t=0.75$ 这样的点，这能更好地解析高斯脉冲的形状。其结果明显更准确。$y_{\\mathrm{RK4}}(T) \\approx 106.67$，得到 $E_{\\mathrm{RK4}} \\approx |106.67 - 80.2121| \\approx 26.45$。\n  - $E_{\\mathrm{FE}}  E_{\\mathrm{RK4}}$。因此，$B_3$ 为 False。\n\n- **情况 4: $\\Delta t_4 = 0.125 = p/8$**：\n  - 随着时间步长变小，这些方法开始进入其预期的渐近收敛区域。RK4 的误差以 $O((\\Delta t)^4)$ 的速度缩放，将远小于 FE 的误差（以 $O(\\Delta t)$ 的速度缩放）。\n  - 我们预期 RK4 会明显更准确。\n  - $E_{\\mathrm{FE}}  E_{\\mathrm{RK4}}$。因此，$B_4$ 为 False。\n\n最终的布尔值结果是通过数值化实现此逻辑来计算的。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erf\n\ndef solve():\n    \"\"\"\n    Solves the given ODE problem for four different time steps and compares\n    the accuracy of Forward Euler and RK4 methods.\n    \"\"\"\n    # Define problem parameters\n    p = 1.0\n    A = 10.0\n    sigma = 0.05\n    T = 64.0\n\n    # Define test cases for time steps\n    test_cases = [1.0, 2.0, 0.5, 0.125]\n\n    # Define the forcing function f(t)\n    def f(t, p_val, a_val, sigma_val):\n        \"\"\"\n        Computes the value of the periodic forcing function f(t).\n        \"\"\"\n        r_t = t - p_val * np.floor(t / p_val)\n        s_t = r_t - p_val / 2.0\n        exponent = -s_t**2 / (2.0 * (sigma_val * p_val)**2)\n        return a_val * np.exp(exponent)\n\n    # Calculate the exact solution y(T)\n    arg_erf = 1.0 / (2.0 * np.sqrt(2.0) * sigma)\n    y_exact_T = T * A * sigma * np.sqrt(2.0 * np.pi) * erf(arg_erf)\n\n    results = []\n\n    for dt in test_cases:\n        # Ensure the number of steps is an integer\n        if T % dt != 0:\n            raise ValueError(f\"Time step dt={dt} does not evenly divide T={T}\")\n        N = int(T / dt)\n\n        # --- Forward Euler (FE) simulation ---\n        y_fe = 0.0\n        # The sum can be vectorized for efficiency\n        time_points_fe = np.arange(N) * dt\n        f_values_fe = f(time_points_fe, p, A, sigma)\n        y_fe = np.sum(f_values_fe) * dt\n        \n        error_fe = np.abs(y_fe - y_exact_T)\n\n        # --- RK4 simulation ---\n        y_rk4 = 0.0\n        # The ODE y'=f(t) simplifies the RK4 scheme, which is equivalent to\n        # composite Simpson's rule for integration.\n        time_points_rk4 = np.arange(N) * dt\n        \n        k1 = f(time_points_rk4, p, A, sigma)\n        k2 = f(time_points_rk4 + 0.5 * dt, p, A, sigma)\n        # For y'=f(t), k3 is identical to k2\n        k4 = f(time_points_rk4 + dt, p, A, sigma)\n        \n        y_rk4 = np.sum((dt / 6.0) * (k1 + 4.0 * k2 + k4))\n\n        error_rk4 = np.abs(y_rk4 - y_exact_T)\n\n        # Compare errors and store boolean result\n        results.append(error_fe  error_rk4)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在了解了不同数值方法的特性和局限性之后，一个自然的问题是：我们能否系统性地改进一个方法的精度？理查森外推法（Richardson extrapolation）为此提供了一个强有力的通用框架。本练习将指导你将理查森外推法应用于二阶梯形法则，以构建一个更高阶的积分格式 。你将通过计算收敛阶来验证精度确实得到了提升，同时也会探索这一操作对方法稳定性（特别是A-稳定性）的微妙影响，从而理解到在追求更高精度的同时，必须仔细审视其对稳定性的潜在影响。",
            "id": "2446856",
            "problem": "考虑由常微分方程 $y^{\\prime}(t)=\\lambda\\,y(t)$ 及初值条件 $y(0)=y_0$ 定义的自治线性初值问题，其中 $\\lambda \\in \\mathbb{C}$ 且 $y_0 \\in \\mathbb{C}$。令 $h0$ 表示一个恒定的时间步长，且 $t_n = n h$。梯形单步法由隐式更新 $y_{n+1}=y_n+\\tfrac{h}{2}\\left(f(t_n,y_n)+f(t_{n+1},y_{n+1})\\right)$ 定义，其中 $f(t,y)=\\lambda y$，其稳定性函数为 $R(z)=\\dfrac{1+\\tfrac{z}{2}}{1-\\tfrac{z}{2}}$，其中 $z=h\\lambda$。通过结合使用步长 $h$ 和 $\\tfrac{h}{2}$ 计算的两个梯形近似，根据 $y^{\\mathrm{RE}}(T;h)=\\dfrac{2^p\\,y^{\\mathrm{trap}}(T;\\tfrac{h}{2})-y^{\\mathrm{trap}}(T;h)}{2^p-1}$ 来定义在同一最终时间的 Richardson 外推近似，其中 $p=2$ 是梯形法的阶，而 $T0$ 是一个固定的最终时间。对于线性测试方程，Richardson 外推法相应的一步稳定性函数是 $R_{\\mathrm{RE}}(z)=\\dfrac{4\\,R\\!\\left(\\tfrac{z}{2}\\right)^2-R(z)}{3}$。\n\n您的任务是实现一个程序，针对下面指定的测试套件，计算误差比以评估观测收敛阶，并数值上评估绝对稳定性（A-stability）。绝对稳定性（A-stability）的理解如下：对于步长 $h0$ 和问题参数 $\\lambda$，如果当 $\\mathrm{Re}(\\lambda)\\leq 0$ 时，总有 $|R(h\\lambda)|\\leq 1$，则称具有稳定性函数 $R(z)$ 的单步法是绝对稳定的。\n\n在需要时，使用精确解 $y(t)=y_0\\,e^{\\lambda t}$ 来计算在最终时间 $T$ 的绝对误差。所有计算都必须使用给定的参数值进行，无需任何用户输入。此问题不涉及角度。不涉及物理单位。\n\n测试套件：\n- 情况 1（梯形法的观测阶）：使用 $\\lambda=-1$，$y_0=1$，$T=1$，步长为 $h=0.2$ 和 $h/2=0.1$。计算比率 $\\dfrac{E_h}{E_{h/2}}$，其中 $E_h=\\left|y(T)-y^{\\mathrm{trap}}(T;h)\\right|$ 且 $E_{h/2}=\\left|y(T)-y^{\\mathrm{trap}}(T;\\tfrac{h}{2})\\right|$。将此比率报告为浮点数。\n- 情况 2（Richardson 外推法的观测阶）：使用与情况 1 相同的 $\\lambda$、$y_0$ 和 $T$。使用 $h=0.2$ 计算 $y^{\\mathrm{RE}}(T;h)$，使用 $h/2=0.1$ 计算 $y^{\\mathrm{RE}}(T;\\tfrac{h}{2})$，其中 $y^{\\mathrm{RE}}$ 结合了如上定义的步长为 $h$ 和 $\\tfrac{h}{2}$ 的梯形近似。计算比率 $\\dfrac{E_h^{\\mathrm{RE}}}{E_{h/2}^{\\mathrm{RE}}}$，其中 $E_h^{\\mathrm{RE}}=\\left|y(T)-y^{\\mathrm{RE}}(T;h)\\right|$ 且 $E_{h/2}^{\\mathrm{RE}}=\\left|y(T)-y^{\\mathrm{RE}}(T;\\tfrac{h}{2})\\right|$。将此比率报告为浮点数。\n- 情况 3（Richardson 外推单步稳定性函数在中等刚度下的绝对稳定性检查）：对 $z=-1$ 求值 $|R_{\\mathrm{RE}}(z)|\\leq 1$。将结果报告为布尔值。\n- 情况 4（Richardson 外推单步稳定性函数在严重刚度下的绝对稳定性检查）：对 $z=-100$ 求值 $|R_{\\mathrm{RE}}(z)|\\leq 1$。将结果报告为布尔值。\n- 情况 5（一致性边界情况）：使用 $\\lambda=0$，$y_0=1$，$T=1$ 和 $h=0.25$。计算绝对误差 $\\left|y(T)-y^{\\mathrm{RE}}(T;h)\\right|$ 并将其报告为浮点数。\n\n最终输出格式：\n您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表，按情况 1 到 5 的顺序排列结果，例如 `[r_1,r_2,r_3,r_4,r_5]`，其中 $r_1$ 和 $r_2$ 是浮点数，$r_3$ 和 $r_4$ 是布尔值，$r_5$ 是浮点数。",
            "solution": "所提出的问题是计算科学领域一个定义明确的练习，特别是在常微分方程的数值分析方面。它具有科学依据、内容自洽且没有歧义。该任务涉及为标准线性测试问题分析梯形法则及其 Richardson 外推。该问题是有效的。我将继续提供一个完整的解决方案。\n\n研究的基本对象是线性初值问题（IVP）：\n$$\ny^{\\prime}(t) = \\lambda y(t), \\quad y(0) = y_0\n$$\n其中 $\\lambda \\in \\mathbb{C}$ 且 $y_0 \\in \\mathbb{C}$。该 IVP 的精确解由 $y(t) = y_0 e^{\\lambda t}$ 给出。数值方法在离散时间点 $t_n = n h$ 处近似此解，其中 $h  0$ 是时间步长。\n\n让我们用 $y_n$ 表示在时间 $t_n$ 的数值近似。该 IVP 的梯形法则是一个由递推关系定义的隐式单步法：\n$$\ny_{n+1} = y_n + \\frac{h}{2} (\\lambda y_n + \\lambda y_{n+1})\n$$\n必须求解该方程以得到 $y_{n+1}$：\n$$\ny_{n+1} \\left(1 - \\frac{h\\lambda}{2}\\right) = y_n \\left(1 + \\frac{h\\lambda}{2}\\right)\n$$\n$$\ny_{n+1} = \\frac{1 + \\frac{h\\lambda}{2}}{1 - \\frac{h\\lambda}{2}} y_n\n$$\n乘以 $y_n$ 的项是该方法的稳定性函数，记为 $R(z)$，其中 $z = h\\lambda$。因此，$y_{n+1} = R(z) y_n$。通过重复应用，在时间 $T=Nh$ 的解由 $y_N = R(z)^N y_0$ 给出。让我们将这个最终近似记为 $y^{\\mathrm{trap}}(T;h) = R(h\\lambda)^{T/h} y_0$。这个闭式表达式将用于计算。\n\nRichardson 外推是一种提高数值近似精度的技术。对于一个 p 阶方法，误差可以表示为步长 $h$ 的渐近级数。对于对称的梯形法，其误差展开式仅包含 $h$ 的偶次幂：\n$$\ny^{\\mathrm{trap}}(T;h) = y(T) + C_p h^p + C_{p+2} h^{p+2} + \\dots\n$$\n其中 $p=2$。使用两个近似，一个步长为 $h$，另一个步长为 $h/2$，我们可以消除主误差项。Richardson 外推解 $y^{\\mathrm{RE}}(T;h)$ 的公式如下：\n$$\ny^{\\mathrm{RE}}(T;h) = \\frac{2^p y^{\\mathrm{trap}}(T;\\tfrac{h}{2}) - y^{\\mathrm{trap}}(T;h)}{2^p - 1}\n$$\n当 $p=2$ 时，这变为：\n$$\ny^{\\mathrm{RE}}(T;h) = \\frac{4 y^{\\mathrm{trap}}(T;\\tfrac{h}{2}) - y^{\\mathrm{trap}}(T;h)}{3}\n$$\n这个新的近似 $y^{\\mathrm{RE}}(T;h)$ 的误差阶为 $O(h^{p+2}) = O(h^4)$，前提是展开式中的下一项存在。\n\n我们现在处理测试套件中提出的每种情况。\n\n情况 1：梯形法的观测收敛阶。\n参数为 $\\lambda=-1$，$y_0=1$，$T=1$。我们使用 $h=0.2$。精确解是 $y(T) = e^{-1}$。\n使用步长 $h=0.2$ 的数值近似需要 $N_h=T/h=5$ 步。稳定性函数的自变量是 $z_h=h\\lambda=-0.2$。\n$$\ny^{\\mathrm{trap}}(T;h) = \\left( R(-0.2) \\right)^{5} y_0 = \\left( \\frac{1-0.1}{1+0.1} \\right)^5 = \\left(\\frac{9}{11}\\right)^5\n$$\n使用步长 $h/2=0.1$ 的近似需要 $N_{h/2}=T/(h/2)=10$ 步。自变量是 $z_{h/2}=(h/2)\\lambda=-0.1$。\n$$\ny^{\\mathrm{trap}}(T;\\tfrac{h}{2}) = \\left( R(-0.1) \\right)^{10} y_0 = \\left( \\frac{1-0.05}{1+0.05} \\right)^{10} = \\left(\\frac{19}{21}\\right)^{10}\n$$\n绝对误差为 $E_h = |y(T) - y^{\\mathrm{trap}}(T;h)|$ 和 $E_{h/2} = |y(T) - y^{\\mathrm{trap}}(T;\\tfrac{h}{2})|$。对于一个 $p=2$ 阶的方法，误差比应约等于 $E_h/E_{h/2} \\approx 2^p = 4$。\n\n情况 2：Richardson 外推法的观测收敛阶。\n我们使用与情况 1 相同的参数。我们需要计算两个外推近似。\n首先，使用 $h=0.2$ 的 $y^{\\mathrm{RE}}(T;h)$：\n$$\ny^{\\mathrm{RE}}(T;0.2) = \\frac{4 y^{\\mathrm{trap}}(T;0.1) - y^{\\mathrm{trap}}(T;0.2)}{3}\n$$\n其次，使用 $h/2=0.1$ 的 $y^{\\mathrm{RE}}(T;h/2)$。这需要步长为 $0.1$ 和 $0.1/2=0.05$ 的近似。步长 $h=0.05$ 的近似使用 $N=T/0.05=20$ 步且 $z=-0.05$。\n$$\ny^{\\mathrm{trap}}(T;0.05) = \\left(R(-0.05)\\right)^{20} y_0 = \\left(\\frac{1-0.025}{1+0.025}\\right)^{20} = \\left(\\frac{39}{41}\\right)^{20}\n$$\n$$\ny^{\\mathrm{RE}}(T;0.1) = \\frac{4 y^{\\mathrm{trap}}(T;0.05) - y^{\\mathrm{trap}}(T;0.1)}{3}\n$$\n误差为 $E_h^{\\mathrm{RE}} = |y(T) - y^{\\mathrm{RE}}(T;0.2)|$ 和 $E_{h/2}^{\\mathrm{RE}} = |y(T) - y^{\\mathrm{RE}}(T;0.1)|$。由于外推法的阶为 $p_{\\mathrm{RE}}=4$，预期的误差比为 $E_h^{\\mathrm{RE}}/E_{h/2}^{\\mathrm{RE}} \\approx 2^4 = 16$。\n\n情况 3：Richardson 外推单步法在 $z=-1$ 时的绝对稳定性。\n组合单步法的稳定性函数由 $R_{\\mathrm{RE}}(z)=\\dfrac{4\\,R\\!\\left(\\tfrac{z}{2}\\right)^2-R(z)}{3}$ 给出。我们必须对 $z=-1$ 求 $|R_{\\mathrm{RE}}(z)| \\le 1$ 的值。\n当 $z=-1$ 时，我们有 $z/2=-0.5$。\n$$\nR(-1) = \\frac{1+(-1)/2}{1-(-1)/2} = \\frac{1/2}{3/2} = \\frac{1}{3}\n$$\n$$\nR(-0.5) = \\frac{1+(-0.5)/2}{1-(-0.5)/2} = \\frac{3/4}{5/4} = \\frac{3}{5}\n$$\n$$\nR_{\\mathrm{RE}}(-1) = \\frac{4(3/5)^2 - (1/3)}{3} = \\frac{4(9/25) - 1/3}{3} = \\frac{36/25 - 1/3}{3} = \\frac{(108-25)/75}{3} = \\frac{83}{225}\n$$\n其大小为 $|\\frac{83}{225}| = \\frac{83}{225} \\approx 0.3689$，小于或等于 $1$。条件成立。\n\n情况 4：$z=-100$ 时的绝对稳定性。\n我们对 $z=-100$ 求 $|R_{\\mathrm{RE}}(z)| \\le 1$ 的值。\n当 $z=-100$ 时，我们有 $z/2=-50$。\n$$\nR(-100) = \\frac{1+(-100)/2}{1-(-100)/2} = \\frac{1-50}{1+50} = -\\frac{49}{51}\n$$\n$$\nR(-50) = \\frac{1+(-50)/2}{1-(-50)/2} = \\frac{1-25}{1+25} = -\\frac{24}{26} = -\\frac{12}{13}\n$$\n$$\nR_{\\mathrm{RE}}(-100) = \\frac{4(-12/13)^2 - (-49/51)}{3} = \\frac{4(144/169) + 49/51}{3} = \\frac{576/169 + 49/51}{3}\n$$\n数值上，这约等于 $\\frac{3.40828 + 0.96078}{3} \\approx 1.45635$。该值大于 $1$。条件不成立。这表明对 A-稳定方法进行 Richardson 外推不一定能保持 A-稳定性。\n\n情况 5：$\\lambda=0$ 时的一致性检查。\n参数为 $\\lambda=0$，$y_0=1$，$T=1$ 和 $h=0.25$。\n该 IVP 是 $y'(t)=0$，初值为 $y(0)=1$，因此对于所有 $t$，精确解是 $y(t)=1$。在最终时间的精确值是 $y(T)=1$。\n对于 $\\lambda=0$，稳定性函数的自变量是 $z=h\\lambda=0$。\n$R(0) = \\frac{1+0}{1-0} = 1$。\n对于任何步长 $h$，梯形近似为 $y^{\\mathrm{trap}}(T;h) = R(0)^{T/h} y_0 = 1^{T/h} \\cdot 1 = 1$。\n因此，$y^{\\mathrm{trap}}(T;0.25) = 1$ 且 $y^{\\mathrm{trap}}(T;0.125)=1$。\nRichardson 外推解为：\n$$\ny^{\\mathrm{RE}}(T;0.25) = \\frac{4 y^{\\mathrm{trap}}(T;0.125) - y^{\\mathrm{trap}}(T;0.25)}{3} = \\frac{4(1) - 1}{3} = 1\n$$\n绝对误差为 $|y(T) - y^{\\mathrm{RE}}(T;0.25)| = |1 - 1| = 0$。这证实了该方法是一致的，因为它能精确求解该平凡情况。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Executes the computations for all five test cases as required by the problem statement.\n    \"\"\"\n\n    # Helper function to compute the stability function R(z)\n    def R_trap(z: complex) -> complex:\n        \"\"\"Stability function of the trapezoidal method.\"\"\"\n        # Handle the case z=2 where the denominator is zero\n        if np.isclose(z, 2.0):\n            return np.inf\n        return (1 + z / 2) / (1 - z / 2)\n\n    # Helper function for trapezoidal method solution\n    def trapezoidal_solver(h: float, T: float, y0: complex, lam: complex) -> complex:\n        \"\"\"\n        Computes the numerical solution y(T) using the trapezoidal method.\n        \"\"\"\n        # Ensure T is a multiple of h for integer number of steps\n        num_steps = round(T / h)\n        if not np.isclose(T, num_steps * h):\n            raise ValueError(\"T must be an integer multiple of h.\")\n        \n        z = h * lam\n        y_T = (R_trap(z)**num_steps) * y0\n        return y_T\n\n    # Helper function for Richardson extrapolation\n    def richardson_extrapolation(h: float, T: float, y0: complex, lam: complex, p: int) -> complex:\n        \"\"\"\n        Computes the Richardson-extrapolated solution y_RE(T; h).\n        \"\"\"\n        y_h = trapezoidal_solver(h, T, y0, lam)\n        y_h_half = trapezoidal_solver(h / 2, T, y0, lam)\n        \n        y_RE = (2**p * y_h_half - y_h) / (2**p - 1)\n        return y_RE\n\n    # Helper function for the RE stability function\n    def R_re(z: complex) -> complex:\n        \"\"\"One-step stability function of the Richardson-extrapolated method.\"\"\"\n        return (4 * R_trap(z / 2)**2 - R_trap(z)) / 3\n\n    results = []\n\n    # Case 1: Observed order for the trapezoidal method\n    lam1_2 = -1.0 + 0j\n    y0_1_2 = 1.0 + 0j\n    T1_2 = 1.0\n    h1_2 = 0.2\n    p_trap = 2\n\n    y_exact_1_2 = y0_1_2 * np.exp(lam1_2 * T1_2)\n    y_trap_h = trapezoidal_solver(h1_2, T1_2, y0_1_2, lam1_2)\n    y_trap_h_half = trapezoidal_solver(h1_2 / 2, T1_2, y0_1_2, lam1_2)\n    \n    E_h = abs(y_exact_1_2 - y_trap_h)\n    E_h_half = abs(y_exact_1_2 - y_trap_h_half)\n    \n    # Avoid division by zero, though not expected here\n    ratio1 = E_h / E_h_half if E_h_half != 0 else float('inf')\n    results.append(float(ratio1))\n\n    # Case 2: Observed order for the Richardson-extrapolated method\n    p_re_theory = 4\n\n    y_re_h = richardson_extrapolation(h1_2, T1_2, y0_1_2, lam1_2, p_trap)\n    y_re_h_half = richardson_extrapolation(h1_2 / 2, T1_2, y0_1_2, lam1_2, p_trap)\n\n    E_h_re = abs(y_exact_1_2 - y_re_h)\n    E_h_half_re = abs(y_exact_1_2 - y_re_h_half)\n\n    ratio2 = E_h_re / E_h_half_re if E_h_half_re != 0 else float('inf')\n    results.append(float(ratio2))\n    \n    # Case 3: Absolute stability check for RE at z = -1\n    z3 = -1.0 + 0j\n    is_stable3 = abs(R_re(z3)) = 1.0\n    results.append(is_stable3)\n\n    # Case 4: Absolute stability check for RE at z = -100\n    z4 = -100.0 + 0j\n    is_stable4 = abs(R_re(z4)) = 1.0\n    results.append(is_stable4)\n\n    # Case 5: Consistency edge case\n    lam5 = 0.0 + 0j\n    y0_5 = 1.0 + 0j\n    T5 = 1.0\n    h5 = 0.25\n\n    y_exact_5 = y0_5 * np.exp(lam5 * T5)\n    y_re_5 = richardson_extrapolation(h5, T5, y0_5, lam5, p_trap)\n    error5 = abs(y_exact_5 - y_re_5)\n    results.append(float(error5))\n\n    # Final print statement\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}