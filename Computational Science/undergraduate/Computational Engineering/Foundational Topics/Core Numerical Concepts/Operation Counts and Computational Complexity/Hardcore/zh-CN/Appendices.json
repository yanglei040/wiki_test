{
    "hands_on_practices": [
        {
            "introduction": "分析算法效率最直接的方法是精确计算其执行的基本操作次数。这个练习将带你完成一个从微观到宏观的分析过程，从处理单个像素所需的操作，扩展到处理整个视频流的总计算量。通过这个具体的例子，你将学会如何将一个大型计算任务分解为可重复的单元，并精确量化其总成本。",
            "id": "2421532",
            "problem": "一个结构检测流程中的裂纹检测程序处理一张宽度为 $W$ 像素、高度为 $H$ 像素的单通道灰度图像。对于每个像素，该程序精确执行 $c$ 次原语操作，其中 $c$ 是一个与 $W$ 和 $H$ 无关的正常数。因此，每张图像的操作计数与像素数量成线性关系，并与 $O(W \\cdot H)$ 的缩放级别一致。该流程必须处理一个以每秒 $30$ 帧（frames per second (fps)）录制、时长为 $1$ 分钟的视频流，其中每一帧都是尺寸为 $W \\times H$ 的图像。假设不存在帧间复用，并且每帧的操作计数与时间无关。从操作计数的定义和组合重复独立工作负载的概念出发，推导处理整个视频所需的总原语操作次数，并将其表示为 $W$、$H$ 和 $c$ 的函数。请以 $W$、$H$ 和 $c$ 的单闭式表达式形式给出您的答案。最终表达式无需四舍五入，也无需单位。",
            "solution": "在尝试给出任何解答之前，将首先对问题陈述进行严格验证。\n\n### 步骤 1：提取已知条件\n问题陈述中逐字提供了以下数据：\n- 图像宽度：$W$ 像素\n- 图像高度：$H$ 像素\n- 每像素操作数：$c$（一个与 $W$ 和 $H$ 无关的正常数）\n- 每图像操作计数缩放级别：$O(W \\cdot H)$\n- 视频流帧率：$30$ 帧/秒 (fps)\n- 视频流时长：$1$ 分钟\n- 处理假设：无帧间复用\n- 处理假设：每帧操作计数与时间无关\n- 目标：推导整个视频的总原语操作数，并将其表示为 $W$、$H$ 和 $c$ 的函数。\n\n### 步骤 2：使用提取的已知条件进行验证\n根据既定标准对问题进行评估：\n- **科学依据**：该问题基于计算复杂性分析的基本原理，特别是图像和视频处理中算法的操作计数。该模型是计算工程学中使用的标准且有效的简化模型。它不违反任何科学或数学定律。\n- **适定性**：该问题是适定的。它提供了计算唯一解所需的所有必要参数（$W$、$H$、$c$、帧率、时长）。目标陈述明确。\n- **客观性**：问题以精确、客观的语言陈述。它没有歧义、主观性或非科学性主张。\n\n该问题不存在任何缺陷。它在科学上是合理的，规定完整，并以适合定量求解的正式、客观方式提出。\n\n### 步骤 3：结论与行动\n该问题被判定为**有效**。现在将推导解答。\n\n任务是确定处理一个视频流所需的总原语操作次数。这是一个组合独立工作负载的问题。总工作负载是每个组成部分工作负载的总和。在本例中，组成部分是视频的单个帧。\n\n首先，我们确定处理单帧图像所需的操作次数。单帧图像是一张尺寸为 $W \\times H$ 像素的图像。\n一帧中的总像素数 $N_{\\text{pixels}}$ 是其宽度和高度的乘积：\n$$N_{\\text{pixels}} = W \\cdot H$$\n问题陈述指出，对于每个像素，该程序精确执行 $c$ 次原语操作。因此，处理单帧的总操作数 $O_{\\text{frame}}$ 是像素数与每像素操作数的乘积：\n$$O_{\\text{frame}} = N_{\\text{pixels}} \\cdot c = (W \\cdot H) \\cdot c$$\n缩放级别为 $O(W \\cdot H)$ 的信息与这种线性关系是一致的，因为 $c$ 是一个常数。\n\n接下来，我们确定视频流中的总帧数。视频时长 $T$ 给定为 $1$ 分钟。我们必须将其转换为与帧率一致的时间单位。\n$$T = 1 \\text{ minute} = 60 \\text{ seconds}$$\n帧率 $f$ 给定为每秒 $30$ 帧。\n$$f = 30 \\text{ fps}$$\n总帧数 $N_{\\text{frames}}$ 是以秒为单位的时长与帧率的乘积：\n$$N_{\\text{frames}} = T \\cdot f = 60 \\text{ s} \\cdot 30 \\text{ s}^{-1} = 1800$$\n因此，该流程必须处理 $1800$ 帧。\n\n最后，我们计算整个视频的总操作数 $O_{\\text{total}}$。问题陈述中提到没有帧间复用，这意味着每一帧都是一个独立的计算任务。因此，总操作数是每帧操作数与总帧数的乘积：\n$$O_{\\text{total}} = O_{\\text{frame}} \\cdot N_{\\text{frames}}$$\n代入上面推导出的表达式：\n$$O_{\\text{total}} = (W \\cdot H \\cdot c) \\cdot 1800$$\n按照惯例，数字系数写在前面。因此，总原语操作次数为：\n$$O_{\\text{total}} = 1800 W H c$$\n这就是以给定参数 $W$、$H$ 和 $c$ 表示的总操作计数的最终闭式表达式。",
            "answer": "$$\\boxed{1800WHc}$$"
        },
        {
            "introduction": "在现实世界的计算工程问题中，算法通常由多个顺序执行的阶段组成。这项练习模拟了一个简化的金融风险模型，旨在教会你如何组合不同部分的计算复杂度。你将学习到，当多个任务顺序执行时，它们的成本会累加，而总复杂度最终由增长最快的“主导项”决定。",
            "id": "2380831",
            "problem": "一家银行经营 $D$ 个业务部门，每个部门持有一个包含 $N$ 个头寸的投资组合。为了进行监管报告，银行需要为每个部门计算部门风险指标，然后将这些部门指标汇总成一个全公司范围的数值。假设以下成本模型基于基本算法操作：\n\n- 对于一个给定的部门，本地风险计算会扫描所有无序的头寸对以评估相互作用，然后执行常数次的额外线性时间遍数进行缩放和归一化。因此，一个部门的最坏情况操作数可以被某个正常数 $a$、$b$ 和 $c$ 限定上界为 $a N^{2} + b N + c$，因此其复杂度为 $\\mathcal{O}(N^{2})$。\n\n- 在计算完所有 $D$ 个部门的指标后，企业聚合器通过读取每个部门的数值一次，应用一个常数时间变换，并求和，从而以固定的权重对它们进行线性组合。聚合成本的上限为 $k D$，其中 $k$ 是一个正常数，因此其复杂度为 $\\mathcal{O}(D)$。\n\n假设所有部门在单个计算线程上顺序处理，部门之间没有记忆化或计算复用，并且 $N \\ge 1$，$D \\ge 1$。仅使用渐进上界（大O）的基本定义和顺序组合增加成本的原则，推导出生成全公司风险数值的总时间复杂度，并以一个关于 $N$ 和 $D$ 的单一简化 $\\mathcal{O}(\\cdot)$ 表达式表示。你的最终答案必须是一个单一的封闭形式 $\\mathcal{O}(\\cdot)$ 表达式。不需要四舍五入，也不需要报告单位。",
            "solution": "首先将对问题陈述进行严格的验证过程。\n\n**第一步：提取已知条件**\n- 业务部门数量：$D$\n- 每个部门的头寸数量：$N$\n- 一个部门风险计算的最坏情况操作数上限为 $a N^{2} + b N + c$。\n- 常数 $a$、$b$ 和 $c$ 为正。\n- 一个部门的复杂度为 $\\mathcal{O}(N^{2})$。\n- 企业聚合的成本上限为 $k D$。\n- 常数 $k$ 为正。\n- 聚合的复杂度为 $\\mathcal{O}(D)$。\n- 处理模型：在单个线程上顺序执行。\n- 部门之间无记忆化或计算复用。\n- 约束条件：$N \\ge 1$ 且 $D \\ge 1$。\n- 目标：以一个关于 $N$ 和 $D$ 的单一简化 $\\mathcal{O}(\\cdot)$ 表达式推导总时间复杂度。\n\n**第二步：使用提取的已知条件进行验证**\n根据所需标准对问题进行评估。\n\n- **科学依据**：该问题是计算复杂性理论（大O表示法）在一个简化的、但合理的金融风险计算模型中的应用。成本模型 $a N^{2} + b N + c$ 用于成对交互和线性遍数，是算法分析中的标准模型。它完全符合计算机科学的原理。\n- **良态问题**：该问题是良态的。它提供了所有必要的组成部分：子问题的成本函数、它们的组合方法（顺序相加）以及变量的约束。可以推导出一个唯一的、有意义的解。\n- **客观性**：问题以精确、客观和量化的术语陈述。诸如“无序对”、“线性时间遍数”和“在单个计算线程上顺序处理”等术语是明确无误的。\n\n**第三步：结论与行动**\n问题是**有效的**。这是一个直接、定义明确的算法分析练习。我现在将着手解决。\n\n令 $T_{dept}(N)$ 表示计算一个拥有 $N$ 个头寸的部门的风险指标所需的时间。根据问题陈述，这个时间由一个关于 $N$ 的多项式作为上界，即：\n$$T_{dept}(N) \\le a N^{2} + b N + c$$\n其中 $a > 0$，$b > 0$ 和 $c > 0$ 是常数。这对应于单个部门的时间复杂度 $\\mathcal{O}(N^{2})$。\n\n银行有 $D$ 个这样的部门，它们被顺序处理。顺序组合原则指出，一系列操作的总时间是每个单独操作时间的总和。由于部门之间没有计算复用，处理所有 $D$ 个部门所需的总时间，我们称之为 $T_{all\\_depts}(N, D)$，是 $D$ 个相同计算成本的总和。\n$$T_{all\\_depts}(N, D) = \\sum_{i=1}^{D} T_{dept}(N) = D \\cdot T_{dept}(N)$$\n因此，此计算阶段的上界是：\n$$D \\cdot (a N^{2} + b N + c)$$\n\n在部门计算之后，执行一个企业聚合步骤。令此聚合的时间为 $T_{agg}(D)$。问题指出，这个时间由一个关于 $D$ 的线性函数作为上界：\n$$T_{agg}(D) \\le k D$$\n其中 $k > 0$ 是一个常数。这对应于时间复杂度 $\\mathcal{O}(D)$。\n\n整个过程包括所有部门的计算，然后是最终的聚合。再次应用顺序组合原则，全公司风险计算的总时间 $T_{total}(N, D)$ 是这两个阶段时间的总和。总时间的上界是：\n$$T_{total}(N, D) \\le T_{all\\_depts}(N, D) + T_{agg}(D)$$\n$$T_{total}(N, D) \\le D(a N^{2} + b N + c) + k D$$\n展开此表达式可得：\n$$T_{total}(N, D) \\le a D N^{2} + b D N + c D + k D$$\n$$T_{total}(N, D) \\le a D N^{2} + b D N + (c+k)D$$\n\n为了确定总的渐进时间复杂度，我们必须在这个多项式表达式中识别出对于大的 $N$ 和 $D$ 值的主导项。这些项是 $a D N^{2}$，$b D N$ 和 $(c+k)D$。根据大O表示法的定义，我们需要找到常数 $C > 0$，$N_{0} \\ge 1$ 和 $D_{0} \\ge 1$，使得对于所有 $N \\ge N_{0}$ 和 $D \\ge D_{0}$，以下不等式成立：\n$$a D N^{2} + b D N + (c+k)D \\le C \\cdot g(N, D)$$\n其中 $g(N,D)$ 是表征增长率的最简函数。\n\n我们选择 $g(N, D) = D N^{2}$。我们必须证明 $a D N^{2} + b D N + (c+k)D \\in \\mathcal{O}(D N^{2})$。\n根据问题约束，$N \\ge 1$ 且 $D \\ge 1$。\n对于 $N \\ge 1$，我们有 $N \\le N^{2}$，因此 $b D N \\le b D N^{2}$。\n同样，对于 $N \\ge 1$，我们有 $1 \\le N^{2}$，这意味着 $D \\le D N^{2}$，所以 $(c+k)D \\le (c+k)D N^{2}$。\n\n将这些不等式代回总时间的表达式中：\n$$a D N^{2} + b D N + (c+k)D \\le a D N^{2} + b D N^{2} + (c+k)D N^{2}$$\n$$a D N^{2} + b D N + (c+k)D \\le (a + b + c + k) D N^{2}$$\n令 $C = a + b + c + k$。由于 $a, b, c, k$ 都是正常数，所以 $C$ 也是一个正常数。该不等式对于所有 $N \\ge 1$ 和 $D \\ge 1$ 都成立。\n因此，根据大O表示法的正式定义，总时间复杂度的上界为 $C \\cdot D N^{2}$。\n\n总时间复杂度为 $\\mathcal{O}(D N^{2})$。",
            "answer": "$$\\boxed{\\mathcal{O}(D N^{2})}$$"
        },
        {
            "introduction": "渐近复杂度更优的算法（例如，增长更慢的算法）在实际应用中不一定总是最佳选择，因为它们可能伴随着更高的初始开销。这个练习探讨了经典矩阵乘法与更高级的Strassen算法之间的权衡。通过计算两种算法性能相当的“临界点”，你将掌握一种关键的决策技能：确定在何种问题规模下，采用理论上更优但实现更复杂的算法才真正值得。",
            "id": "2421609",
            "problem": "在计算工程学中，算法效率通常通过计算算术运算次数随问题规模变化的函数来评估。考虑使用两种不同的算法来计算两个大小为 $n \\times n$ 的稠密方阵的乘积：\n- 经典的三重循环算法的运算次数由 $T_{\\mathrm{std}}(n) = \\alpha n^{3}$ 建模，其中 $\\alpha > 0$ 是一个表示每次运算成本的常数。\n- Strassen 算法的运算次数由 $T_{\\mathrm{str}}(n) = \\beta n^{\\log_{2}(7)}$ 建模，其中 $\\beta > 0$ 是一个常数。\n\n假设由于与 $n$ 无关的实现开销，Strassen 算法在小规模问题上的运算次数是经典算法的 $10$ 倍，因此 $\\beta = 10 \\alpha$。将 $n$ 视为一个正实数变量，确定阈值规模 $n^{\\ast}$，在该规模下 Strassen 算法的运算次数首次小于或等于经典算法。\n\n请以 $n^{\\ast}$ 的单个封闭形式解析表达式给出你的最终答案。不需要也不允许使用数值近似。",
            "solution": "首先必须验证问题陈述的科学正确性、逻辑一致性和客观性。\n\n步骤1：提取已知条件。\n已知条件如下：\n- 经典算法的运算次数：$T_{\\mathrm{std}}(n) = \\alpha n^{3}$。\n- Strassen 算法的运算次数：$T_{\\mathrm{str}}(n) = \\beta n^{\\log_{2}(7)}$。\n- 矩阵是大小为 $n \\times n$ 的稠密方阵。\n- $\\alpha$ 是一个大于 $0$ 的常数，即 $\\alpha > 0$。\n- $\\beta$ 是一个大于 $0$ 的常数，即 $\\beta > 0$。\n- 给出了常数之间的特定关系：$\\beta = 10 \\alpha$。\n- 变量 $n$ 被视为一个正实数变量。\n- 目标是找到阈值规模 $n^{\\ast}$，在该规模下 $T_{\\mathrm{str}}(n) \\le T_{\\mathrm{std}}(n)$。\n\n步骤2：使用提取的已知条件进行验证。\n根据所需标准对问题进行评估。\n- **科学依据**：运算次数的模型 $T_{\\mathrm{std}}(n) \\propto n^{3}$ 和 $T_{\\mathrm{str}}(n) \\propto n^{\\log_{2}(7)}$ 分别是经典矩阵乘法算法和 Strassen 算法渐近复杂度的标准且正确的表示。像 Strassen 这样的更高级算法具有更高的常数因子开销（由 $\\beta > \\alpha$ 表示）这一前提，在计算实践中是真实存在的情况。该问题牢固地建立在计算复杂性分析的既定原则之上。\n- **适定性**：问题定义清晰。它提供了关于单个变量 $n$ 的两个函数，并要求找出使它们关系发生变化的 $n$ 值。所有常数都已定义，并且给出了特定关系 $\\beta = 10 \\alpha$，这使得问题可以求解一个唯一的交叉点。将 $n$ 视为实数是此类渐近分析中标准且可接受的简化方法。\n- **客观性**：问题以精确、无偏见的数学语言陈述。没有主观或基于意见的主张。\n\n步骤3：结论与行动。\n问题陈述是有效的。它在科学上是合理的，问题是适定的，并且是客观的。我现在将继续提供完整的解决方案。\n\n目标是确定阈值规模 $n^{\\ast}$，在该规模下，Strassen 算法的效率等于或高于经典算法。这个条件由不等式表示：\n$$T_{\\mathrm{str}}(n) \\le T_{\\mathrm{std}}(n)$$\n阈值 $n^{\\ast}$ 是使两个运算次数相等的特定 $n$ 值。因此，我们求解方程：\n$$T_{\\mathrm{str}}(n^{\\ast}) = T_{\\mathrm{std}}(n^{\\ast})$$\n代入给定的运算次数表达式：\n$$\\beta (n^{\\ast})^{\\log_{2}(7)} = \\alpha (n^{\\ast})^{3}$$\n我们已知关系 $\\beta = 10 \\alpha$。将其代入方程得到：\n$$10 \\alpha (n^{\\ast})^{\\log_{2}(7)} = \\alpha (n^{\\ast})^{3}$$\n由于题目说明 $\\alpha > 0$，我们可以在不失一般性的情况下将方程两边同除以 $\\alpha$：\n$$10 (n^{\\ast})^{\\log_{2}(7)} = (n^{\\ast})^{3}$$\n为了求解 $n^{\\ast}$，我们重新整理各项以分离变量。假设 $n^{\\ast} > 0$，我们可以除以 $(n^{\\ast})^{\\log_{2}(7)}$：\n$$10 = \\frac{(n^{\\ast})^{3}}{(n^{\\ast})^{\\log_{2}(7)}}$$\n使用指数性质 $x^{a} / x^{b} = x^{a-b}$：\n$$10 = (n^{\\ast})^{3 - \\log_{2}(7)}$$\n为了求出 $n^{\\ast}$，我们必须将其分离出来。这可以通过对等式两边取对数来实现。我们将使用自然对数，记作 $\\ln$。\n$$\\ln(10) = \\ln\\left((n^{\\ast})^{3 - \\log_{2}(7)}\\right)$$\n使用对数幂法则 $\\ln(x^{a}) = a \\ln(x)$：\n$$\\ln(10) = (3 - \\log_{2}(7)) \\ln(n^{\\ast})$$\n现在，我们可以求解 $\\ln(n^{\\ast})$。项 $3 - \\log_{2}(7)$ 非零。我们注意到 $3 = \\log_{2}(2^{3}) = \\log_{2}(8)$。因为 $8 > 7$，所以 $\\log_{2}(8) > \\log_{2}(7)$，因此 $3 - \\log_{2}(7) > 0$。我们可以除以该项：\n$$\\ln(n^{\\ast}) = \\frac{\\ln(10)}{3 - \\log_{2}(7)}$$\n最后，为了求出 $n^{\\ast}$，我们对等式两边取指数：\n$$n^{\\ast} = \\exp\\left(\\frac{\\ln(10)}{3 - \\log_{2}(7)}\\right)$$\n该表达式为阈值 $n^{\\ast}$ 提供了精确的、封闭形式的解析值。对于任何 $n > n^{\\ast}$，不等式 $10  n^{3 - \\log_{2}(7)}$ 都成立，这等价于 $T_{\\mathrm{str}}(n)  T_{\\mathrm{std}}(n)$，从而证实了 $n^{\\ast}$ 确实是交叉点，超过该点 Strassen 算法更优。",
            "answer": "$$\\boxed{\\exp\\left(\\frac{\\ln(10)}{3 - \\log_{2}(7)}\\right)}$$"
        }
    ]
}