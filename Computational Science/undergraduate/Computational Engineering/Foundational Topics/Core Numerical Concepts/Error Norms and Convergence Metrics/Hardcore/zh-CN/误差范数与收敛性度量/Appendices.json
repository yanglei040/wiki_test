{
    "hands_on_practices": [
        {
            "introduction": "开发数值方法的一个关键部分是验证其是否按预期工作。本练习将引导您使用一种标准技术——对数-对数图法——来凭经验估算收敛阶数，这是调试和验证任何数值代码的基本技能。通过这个实践，您将学会如何从数值实验数据中自动提取出方法的关键性能指标 $p$ 。",
            "id": "2389343",
            "problem": "给定一个在闭区间 $[0,1]$ 上的一维设定，其上有一个包含 $N+1$ 个节点的均匀网格 $x_i = i h$，其中 $h = 1/N$ 且 $i \\in \\{0,1,\\dots,N\\}$。精确光滑函数为 $u(x) = \\sin(2\\pi x)$。对于一个网格尺寸为 $h$ 的数值方法，将其点态误差记为 $e_h(x) = u_h(x) - u(x)$。您将使用误差范数，在下列假设下，自动检测该方法的收敛阶 $p$。\n\n基本原理：\n- 均匀网格上的离散 $L^1$、$L^2$ 和 $L^\\infty$ 范数使用黎曼和来近似其对应的连续形式。对于误差向量 $e_i \\approx e_h(x_i)$，\n  - 离散 $L^1$ 范数为 $\\|e_h\\|_{1,h} = h \\sum_{i=0}^N |e_i|$，\n  - 离散 $L^2$ 范数为 $\\|e_h\\|_{2,h} = \\sqrt{h \\sum_{i=0}^N e_i^2}$，\n  - 离散 $L^\\infty$ 范数为 $\\|e_h\\|_{\\infty,h} = \\max_{0 \\le i \\le N} |e_i|$。\n- 在 $h$ 足够小的渐近区域内，许多相容的数值方法都表现出 $\\|e_h\\| \\approx C h^p$ 形式的误差范数缩放规律，其中常数 $C > 0$ 和 $p > 0$ 不依赖于 $h$。\n\n任务：\n- 从上述定义和渐近缩放假设出发，推导一个用于计算收敛阶 $p$ 的有理论依据的估计器，该估计器仅使用在多个网格尺寸 $h$ 下计算出的误差范数。您的估计器不能假设已知 $C$，并且必须对误差中的微小高阶污染项具有鲁棒性。\n- 实现一个完整的程序，该程序：\n  1. 为一组网格尺寸 $h$ 构建一系列近似解 $u_h(x)$，并计算相应的误差范数。\n  2. 在每种情况下，应用您的估计器从最精细的几层网格中获得 $\\widehat{p}$。\n  3. 汇总给定测试套件的结果，并以要求的最终输出格式打印。\n\n综合“未知”方法模型：\n- 对于每个网格尺寸 $h$，近似解定义为\n  $$u_h(x) = u(x) + C\\,h^p\\,w(x) + \\delta(x;h),$$\n  其中 $w(x)$ 是一个光滑的“误差形态”，$\\delta(x;h)$ 是一个可选的高阶污染项，用于模拟预渐近效应。$w(x)$ 和 $\\delta(x;h)$ 都在下面的测试套件中完全指定，但除了计算 $e_h(x)$ 的范数外，您的估计器不得使用任何关于 $C$、$p$、$w(x)$ 或 $\\delta(x;h)$ 的先验知识。\n\n需要计算的范数：\n- 对于每个测试用例和每个 $h$，使用包含 $N+1$ 个点且 $h = 1/N$ 的均匀网格，根据上面给出的定义，计算与指定选择的 $q \\in \\{1,2,\\infty\\}$ 对应的离散范数 $\\|e_h\\|_{q,h}$。\n\n估计器应用规则：\n- 对于每个测试用例，通过将您的估计器应用于三个最精细的网格尺寸（即，该用例中三个最小的 $h$ 值）来估计 $p$。\n\n测试套件：\n- 在每种情况下使用以下网格尺寸：$N \\in \\{10,20,40,80,160\\}$，因此 $h \\in \\{1/10,1/20,1/40,1/80,1/160\\}$。\n- 用例 1（理想路径）：$p = 2$, $C = 0.7$, $w(x) = \\cos(\\pi x)$, $\\delta(x;h) \\equiv 0$, 范数 $L^2$。\n- 用例 2（不同范数）：$p = 1$, $C = 1.5$, $w(x) = e^{x}$, $\\delta(x;h) \\equiv 0$, 范数 $L^1$。\n- 用例 3（分数阶和 $L^\\infty$）：$p = 1.5$, $C = 0.3$, $w(x) = \\sin(3\\pi x)$, $\\delta(x;h) \\equiv 0$, 范数 $L^\\infty$。\n- 用例 4（预渐近污染）：$p = 3$, $C = 0.2$, $w(x) = \\cos(5\\pi x)$, $\\delta(x;h) = D\\,h^{p+1}\\,\\sin(7\\pi x)$ 其中 $D = 5.0$, 范数 $L^2$。\n\n算法要求：\n- 对于每种情况，仅使用范数值和网格尺寸来估计 $p$。\n- 为减轻预渐近效应，在每种情况下，仅将您的估计器应用于最精细的三个网格尺寸，即 $N \\in \\{40,80,160\\}$。\n\n最终输出规范：\n- 您的程序必须生成单行输出，其中包含一个列表，内含按用例1到4顺序排列的四个估计收敛阶，每个收敛阶都四舍五入到3位小数。格式必须严格为方括号括起来的逗号分隔列表，例如 `[a,b,c,d]`，其中 a、b、c 和 d 是十进制数。\n\n不涉及物理单位。所有角度均以弧度为单位。最终答案的生成不得要求任何用户输入或外部文件。",
            "solution": "所述问题需进行验证。\n\n第1步：提取已知条件\n- 定义域：闭区间 $[0,1]$。\n- 网格：包含 $N+1$ 个节点的均匀网格 $x_i = i h$，其中 $h = 1/N$ 且 $i \\in \\{0, 1, \\dots, N\\}$。\n- 精确函数：$u(x) = \\sin(2\\pi x)$。\n- 点态误差：$e_h(x) = u_h(x) - u(x)$。\n- 离散 $L^1$ 范数：$\\|e_h\\|_{1,h} = h \\sum_{i=0}^N |e_i|$。\n- 离散 $L^2$ 范数：$\\|e_h\\|_{2,h} = \\sqrt{h \\sum_{i=0}^N e_i^2}$。\n- 离散 $L^\\infty$ 范数：$\\|e_h\\|_{\\infty,h} = \\max_{0 \\le i \\le N} |e_i|$。\n- 渐近误差缩放：$\\|e_h\\| \\approx C h^p$，其中常数 $C > 0$ 且 $p > 0$。\n- 综合近似模型：$u_h(x) = u(x) + C\\,h^p\\,w(x) + \\delta(x;h)$。\n- 用于分析的网格尺寸：$N \\in \\{10, 20, 40, 80, 160\\}$，因此 $h \\in \\{1/10, 1/20, 1/40, 1/80, 1/160\\}$。\n- 估计器应用规则：使用三个最精细的网格尺寸，对应于 $N \\in \\{40, 80, 160\\}$。\n- 测试用例 1：$p = 2$, $C = 0.7$, $w(x) = \\cos(\\pi x)$, $\\delta(x;h) \\equiv 0$, 范数为 $L^2$。\n- 测试用例 2：$p = 1$, $C = 1.5$, $w(x) = e^{x}$, $\\delta(x;h) \\equiv 0$, 范数为 $L^1$。\n- 测试用例 3：$p = 1.5$, $C = 0.3$, $w(x) = \\sin(3\\pi x)$, $\\delta(x;h) \\equiv 0$, 范数为 $L^\\infty$。\n- 测试用例 4：$p = 3$, $C = 0.2$, $w(x) = \\cos(5\\pi x)$, $\\delta(x;h) = D\\,h^{p+1}\\,\\sin(7\\pi x)$ 其中 $D = 5.0$, 范数为 $L^2$。所有角度均以弧度为单位。\n\n第2步：使用提取的已知条件进行验证\n根据验证标准对问题进行评估。\n- **科学依据**：该问题基于数值分析的基本概念，特别是数值方法收敛率的研究，这是计算工程和应用数学中的一个标准课题。定义和模型都是标准的。该问题在科学上是合理的。\n- **适定性**：该问题是适定的。它提供了所有必要的信息——精确函数、数值误差模型、范数定义、要使用的网格尺寸以及一个明确的目标。任务是推导并应用一个估计器，对此存在唯一且有意义的解。\n- **客观性**：语言精确且定量。没有主观或基于观点的陈述。所有参数都已明确定义。\n- 该问题是自洽的、一致的且可形式化的。没有矛盾、缺失数据或不切实际的要求。\n\n第3步：结论与行动\n该问题有效。将提供完整的解决方案。\n\n**收敛阶估计器的推导**\n\n问题在于根据误差范数 $\\|e_h\\|$ 作为网格尺寸 $h$ 的函数的渐近关系，来确定收敛阶 $p$。控制模型给出如下：\n$$\n\\|e_h\\| \\approx C h^p\n$$\n其中对于足够小的 $h$，$C$ 和 $p$ 是不依赖于 $h$ 的常数。常数 $C$ 是未知的。为了消去 $C$ 并求解 $p$，我们可以通过对两边取自然对数将关系式转换为线性形式：\n$$\n\\ln(\\|e_h\\|) \\approx \\ln(C h^p) = \\ln(C) + \\ln(h^p) = \\ln(C) + p \\ln(h)\n$$\n该方程形如 $Y = A + p X$，其中 $Y = \\ln(\\|e_h\\|)$，$X = \\ln(h)$，截距 $A = \\ln(C)$ 是一个常数。这揭示了误差范数的对数与网格尺寸的对数之间存在线性关系。收敛阶 $p$ 即为这条线的斜率。\n\n问题要求使用来自三个网格细化层的数据，我们将其表示为 $h_1$、$h_2$ 和 $h_3$，对应的计算误差范数为 $E_1$、$E_2$ 和 $E_3$。这为我们提供了三个数据点 $(X_i, Y_i) = (\\ln(h_i), \\ln(E_i))$，其中 $i \\in \\{1, 2, 3\\}$。可以使用线性最小二乘回归获得斜率 $p$ 的一个鲁棒估计器。此方法寻找使数据点到直线的垂直距离平方和最小化的直线。对于一组 $n$ 个点 $(X_i, Y_i)$，最佳拟合线的斜率 $\\hat{p}$ 的公式为：\n$$\n\\hat{p} = \\frac{n \\sum_{i=1}^n X_i Y_i - \\left(\\sum_{i=1}^n X_i\\right) \\left(\\sum_{i=1}^n Y_i\\right)}{n \\sum_{i=1}^n X_i^2 - \\left(\\sum_{i=1}^n X_i\\right)^2}\n$$\n这种方法是有理论依据的，因为它使用了三个指定网格层级的所有可用信息。它对理想线性模型的微小扰动也具有鲁棒性，例如由误差中的高阶项（如用例4中的 $\\delta(x;h)$ 项）引入的扰动，因为回归过程具有平均效应。\n\n**实现策略**\n\n实现将对每个测试用例遵循一个系统化的流程。\n1. 为测试用例定义参数：真实阶数 $p_{true}$、常数 $C$、误差形态函数 $w(x)$、污染项 $\\delta(x;h)$ 以及范数类型 $q \\in \\{1, 2, \\infty\\}$。\n2. 对于三个最精细的网格分辨率 $N \\in \\{40, 80, 160\\}$，执行以下步骤：\n    a. 计算网格尺寸 $h=1/N$。\n    b. 生成包含 $N+1$ 个点的均匀网格，$x_i = i h$，其中 $i=0, \\dots, N$。\n    c. 在网格上评估精确解 $u(x_i) = \\sin(2\\pi x_i)$。\n    d. 在网格上构建近似解 $u_h(x_i) = u(x_i) + C\\,h^{p_{true}}\\,w(x_i) + \\delta(x_i;h, p_{true})$。请注意，如此处指定的，真实阶数 $p_{true}$ 仅用于生成综合数据。\n    e. 计算点态误差向量 $e_i = u_h(x_i) - u(x_i)$。\n    f. 根据提供的公式计算指定的离散误差范数 $\\|e_h\\|_{q,h}$。\n3. 在计算出三个网格尺寸（$h_1, h_2, h_3$）对应的三个误差范数（$E_1, E_2, E_3$）后，创建两个向量：$X = [\\ln(h_1), \\ln(h_2), \\ln(h_3)]$ 和 $Y = [\\ln(E_1), \\ln(E_2), \\ln(E_3)]$。\n4. 对数据 $(X, Y)$ 应用线性回归算法以求得斜率。一个标准的数值库函数，例如 `numpy.polyfit` 并设置阶数为1，提供了最小二乘公式的高效实现，它返回的第一个系数即为斜率。该斜率就是收敛阶的估计值 $\\hat{p}$。\n5. 对所有四个测试用例重复此过程。收集得到的估计值，并按要求格式化为四舍五入到3位小数的数字列表作为最终输出。\n\n此方法严格遵守问题约束：它仅使用范数值和网格尺寸进行估计，并应用了一种有理论依据的、鲁棒的技术，适用于分析收敛数据。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by estimating the order of convergence for four test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"case\": 1,\n            \"p_true\": 2.0,\n            \"C\": 0.7,\n            \"w_func\": lambda x: np.cos(np.pi * x),\n            \"delta_func\": lambda x, h, p: 0.0,\n            \"q\": 2\n        },\n        {\n            \"case\": 2,\n            \"p_true\": 1.0,\n            \"C\": 1.5,\n            \"w_func\": lambda x: np.exp(x),\n            \"delta_func\": lambda x, h, p: 0.0,\n            \"q\": 1\n        },\n        {\n            \"case\": 3,\n            \"p_true\": 1.5,\n            \"C\": 0.3,\n            \"w_func\": lambda x: np.sin(3 * np.pi * x),\n            \"delta_func\": lambda x, h, p: 0.0,\n            \"q\": np.inf\n        },\n        {\n            \"case\": 4,\n            \"p_true\": 3.0,\n            \"C\": 0.2,\n            \"w_func\": lambda x: np.cos(5 * np.pi * x),\n            \"delta_func\": lambda x, h, p: 5.0 * h**(p + 1) * np.sin(7 * np.pi * x),\n            \"q\": 2\n        }\n    ]\n\n    results = []\n    # Mesh resolutions to use for the estimator, as per the problem statement.\n    mesh_resolutions_N = [40, 80, 160]\n\n    for case in test_cases:\n        p_true = case[\"p_true\"]\n        C = case[\"C\"]\n        w_func = case[\"w_func\"]\n        delta_func = case[\"delta_func\"]\n        q = case[\"q\"]\n\n        mesh_sizes_h = []\n        error_norms = []\n\n        for N in mesh_resolutions_N:\n            h = 1.0 / N\n            mesh_sizes_h.append(h)\n            \n            # Create the uniform grid from x=0 to x=1 with N+1 points.\n            x = np.linspace(0.0, 1.0, N + 1)\n            \n            # Compute the exact solution u(x) = sin(2*pi*x).\n            u_exact = np.sin(2 * np.pi * x)\n            \n            # Compute the approximate solution using the synthetic model.\n            error_shape = C * h**p_true * w_func(x)\n            contamination = delta_func(x, h, p_true)\n            u_approx = u_exact + error_shape + contamination\n            \n            # Compute the pointwise error.\n            error_vector = u_approx - u_exact\n            \n            # Compute the specified discrete norm of the error.\n            norm = 0.0\n            if q == 1:\n                # Discrete L1 norm: h * sum(|e_i|)\n                norm = h * np.sum(np.abs(error_vector))\n            elif q == 2:\n                # Discrete L2 norm: sqrt(h * sum(e_i^2))\n                norm = np.sqrt(h * np.sum(error_vector**2))\n            elif q == np.inf:\n                # Discrete L-infinity norm: max(|e_i|)\n                norm = np.max(np.abs(error_vector))\n            \n            error_norms.append(norm)\n\n        # Estimate the order of convergence p using linear regression on the log-log data.\n        # The model is log(E) = log(C) + p * log(h).\n        # We find the slope 'p' of the best-fit line for (log(h), log(E)).\n        log_h = np.log(np.array(mesh_sizes_h))\n        log_E = np.log(np.array(error_norms))\n        \n        # np.polyfit with degree 1 fits a line and returns [slope, intercept].\n        # The slope is our estimate for the order of convergence p.\n        p_estimated, _ = np.polyfit(log_h, log_E, 1)        \n        results.append(p_estimated)\n\n    # Final print statement in the exact required format.\n    # The output is a comma-separated list of results rounded to 3 decimal places, inside brackets.\n    print(f\"[{','.join(f'{r:.3f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "虽然误差范数为评估精度提供了一个简洁的总结，但它们有时会掩盖重要的定性行为。本练习将探讨一个使用刚性常微分方程的经典案例，其中解在积分意义上看似收敛，但却表现出非物理的振荡。这个例子教导我们，必须超越单一的误差度量，批判性地审视数值解的质量 。",
            "id": "2389318",
            "problem": "构造一个完全指定的计算实验，以展示刚性常微分方程的积分范数收敛与逐点行为之间的对比。考虑在区间 $[0,1]$ 上的初值问题：\n- 刚性线性常微分方程：$y'(t) = -\\lambda y(t)$，其中刚性参数 $\\lambda = 100$。\n- 初始条件：$y(0) = 1$。\n- 精确解：$y(t) = e^{-\\lambda t}$。\n\n对于每个均匀时间步数 $N \\in \\mathbb{N}$，定义步长 $h = 1/N$，并通过前向（显式）欧拉时间步进格式定义离散逼近 $\\{Y_n\\}_{n=0}^{N}$\n$$\nY_{n+1} = Y_n + h(-\\lambda Y_n) = (1 - h\\lambda) Y_n,\\quad Y_0 = 1,\n$$\n并通过对节点值 $\\{(t_n,Y_n)\\}_{n=0}^{N}$（其中 $t_n = nh$）进行线性插值，定义连续分段线性插值函数 $y_h:[0,1]\\to\\mathbb{R}$。\n\n定义给定步长 $h$ 的时间连续 $L^2$ 误差范数为\n$$\nE_2(h) = \\left(\\int_0^1 \\lvert y_h(t) - y(t) \\rvert^2\\,dt\\right)^{1/2}.\n$$\n通过计算序列 $\\{Y_n\\}_{n=0}^{N}$ 中的符号变化次数，为离散轨迹定义一个逐点振荡指标。因为精确解 $y(t)$ 在 $[0,1]$ 上严格为正，所以离散解的任何符号变化都被视为不正确的逐点行为。\n\n你的程序必须对下面列出的每个测试用例，根据该用例中给定的三个步数 $N$ 评估以下两个布尔度量：\n- 在细化过程中积分范数误差是否严格递减：对于测试用例中按所列顺序给出的三个步长 $h_i = 1/N_i$，如果 $E_2(h_1) > E_2(h_2) > E_2(h_3)$ 成立，则返回 $\\mathrm{True}$，否则返回 $\\mathrm{False}$。\n- 是否存在逐点振荡：如果在测试用例中对应于三个步数的三个离散解 $\\{Y_n\\}$ 中，至少有一个表现出至少一次符号变化，则返回 $\\mathrm{True}$，否则返回 $\\mathrm{False}$。\n\n测试套件（每行是一个测试用例，指定了三个步数 $N$）：\n- 用例 A（稳定但振荡的区域）：$N \\in \\{52,55,59\\}$。\n- 用例 B（良好解析的区域）：$N \\in \\{200,400,800\\}$。\n- 用例 C（稳定边界及其以外）：$N \\in \\{50,49,48\\}$。\n- 用例 D（混合区域）：$N \\in \\{83,100,125\\}$。\n\n你的程序必须对分段线性的 $y_h$ 精确计算 $E_2(h)$，或者通过足够精度的数值积分来计算，以确保对于每个 $E_2(h)$ 值，布尔比较在 $10^{-8}$ 的绝对容差内是正确的，并且必须严格地对离散节点值 $\\{Y_n\\}$ 实现符号变化检验。\n\n最终输出格式：\n- 你的程序应产生一行输出，其中包含八个布尔结果，这些结果按以下顺序聚合为一个用方括号括起来的逗号分隔列表：\n$$\n[\\text{A\\_dec},\\text{A\\_osc},\\ \\text{B\\_dec},\\text{B\\_osc},\\ \\text{C\\_dec},\\text{C\\_osc},\\ \\text{D\\_dec},\\text{D\\_osc}],\n$$\n例如，$\\text{A\\_dec}$ 是指示在用例 A 的三个 $N$ 值上 $E_2$ 是否严格递减的布尔值，而 $\\text{A\\_osc}$ 指示在用例 A 的离散轨迹中是否发生任何符号变化。布尔值必须打印为 $\\mathrm{True}$ 或 $\\mathrm{False}$，该行上不得有其他任何内容。",
            "solution": "我们完全根据定义来形式化该计算实验。常微分方程为 $y'(t) = -\\lambda y(t)$，其中 $\\lambda = 100$，$t \\in [0,1]$，$y(0)=1$。精确解为 $y(t) = e^{-\\lambda t}$，它在 $[0,1]$ 上是严格为正且严格递减的。刚性的产生是因为衰减的时间尺度为 $1/\\lambda$，因此对于 $\\lambda=100$，解在相对于定义域长度 $1$ 的小尺度 $t=\\mathcal{O}(10^{-2})$ 上表现出快速衰减。\n\n对于一个有 $N$ 个步长的均匀网格，$h = 1/N$，$t_n = nh$，前向（显式）欧拉格式从第一性原理出发，通过将导数的定义应用于半离散更新来定义：\n$$\n\\frac{Y_{n+1} - Y_n}{h} \\approx y'(t_n) = -\\lambda y(t_n),\n$$\n并用 $Y_n$ 替换 $y(t_n)$，我们得到\n$$\nY_{n+1} = Y_n + h(-\\lambda Y_n) = (1 - h\\lambda) Y_n,\\quad Y_0 = 1.\n$$\n这个闭式递推关系得出\n$$\nY_n = (1 - h\\lambda)^n.\n$$\n然后，在每个子区间 $[t_n,t_{n+1}]$ 上，连续分段线性插值函数 $y_h(t)$ 被定义为匹配节点值的唯一线性函数：\n$$\ny_h(t) = \\frac{t_{n+1}-t}{h} Y_n + \\frac{t - t_n}{h} Y_{n+1},\\qquad t \\in [t_n,t_{n+1}].\n$$\n\n我们在时间连续 $L^2$ 范数下度量误差，\n$$\nE_2(h) = \\left(\\int_0^1 \\lvert y_h(t) - e^{-\\lambda t} \\rvert^2\\,dt\\right)^{1/2}.\n$$\n这是差函数上的一个范数，根据定义，它对逐点误差的平方随时间进行积分。因为 $y_h$ 是分段线性的而 $y$ 是光滑的，所以 $E_2(h)$ 既可以通过在每个子区间上进行精确积分（一个二次函数减去一个指数函数的展开，其反导数是已知的）来评估，也可以通过足够精确的数值积分法来评估，以确保不同 $h$ 值之间的比较在一个小的绝对容差内是正确的。\n\n我们还通过检测离散序列 $\\{Y_n\\}_{n=0}^{N}$ 中的符号变化来量化不正确的逐点行为。由于精确解在 $[0,1]$ 上满足 $y(t)>0$，数值序列中的任何符号变化都是非物理振荡。对于线性测试方程上的前向欧拉格式，其放大因子为\n$$\nG(h\\lambda) = 1 - h\\lambda.\n$$\n如果 $0 < h\\lambda < 1$，则 $G(h\\lambda) \\in (0,1)$，因此 $Y_{n+1} = G Y_n$ 保持为正且单调递减，不出现符号变化。如果 $1 < h\\lambda < 2$，则 $G(h\\lambda) \\in (-1,0)$，因此 $Y_{n+1}$ 的符号交替变化且幅值衰减，产生逐点振荡。如果 $h\\lambda \\ge 2$，则 $\\lvert G(h\\lambda) \\rvert \\ge 1$，方法处于稳定边界或不稳定状态，通常会产生持续或增长的振荡。\n\n测试套件的理由：\n- 用例 A 使用 $N \\in \\{52,55,59\\}$，即 $h\\lambda \\in \\{100/52,100/55,100/59\\} \\subset (1,2)$，因此离散解是振荡但稳定的。随着 $N$ 增加，$h$ 减小，$L^2$ 误差 $E_2(h)$ 预期将严格递减；由于符号交替，振荡指标应为正。\n- 用例 B 使用 $N \\in \\{200,400,800\\}$，即 $h\\lambda \\in \\{0.5,0.25,0.125\\} \\subset (0,1)$，因此方法是稳定且不振荡的。$E_2(h)$ 应严格递减，振荡指标应为负（无符号变化）。\n- 用例 C 使用 $N \\in \\{50,49,48\\}$，即 $h\\lambda \\in \\{2.0,\\approx 2.0408,\\approx 2.0833\\}$，横跨稳定边界和一个不稳定区域。按此顺序，$L^2$ 误差在序列上不是严格递减的（处于稳定边界的第一个值通常远小于随后的不稳定值），而由于符号交替和不稳定性，振荡指标为正。\n- 用例 D 使用 $N \\in \\{83,100,125\\}$，即 $h\\lambda \\in \\{\\approx 1.2048,1.0,0.8\\}$，从振荡稳定过渡到非振荡稳定。$L^2$ 误差应严格递减，振荡指标应为正，因为至少最粗糙的选择会产生符号变化。\n\n基于这些原理的算法实现：\n- 对每个 $N$，通过递推关系计算节点值 $\\{Y_n\\}$，并通过在 $[0,1]$ 上的线性插值构造 $y_h$。\n- 通过在 $[0,1]$ 的密集均匀划分上对 $\\lvert y_h(t) - e^{-\\lambda t}\\rvert^2$ 进行数值积分来评估 $E_2(h)$，例如，通过使用足够大的偶数个子区间的复合梯形法则，以达到优于 $10^{-8}$ 的绝对精度。\n- 通过检查是否存在索引 $n$ 使得 $Y_n Y_{n+1} < 0$（一次符号变化），来确定振荡指标。\n- 对于每个由按指定顺序排列的三个 $N$ 值组成的测试用例，计算在这三个值上 $E_2$ 是否严格递减以及是否存在振荡的布尔值。\n\n最终输出是列表\n$$\n[\\text{A\\_dec},\\text{A\\_osc},\\ \\text{B\\_dec},\\text{B\\_osc},\\ \\text{C\\_dec},\\text{C\\_osc},\\ \\text{D\\_dec},\\text{D\\_osc}],\n$$\n以布尔值形式单行打印。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef forward_euler_linear_decay(lmbda: float, N: int):\n    \"\"\"\n    Solve y' = -lambda*y, y(0)=1 on [0,1] with Forward Euler using N steps.\n    Returns time nodes t (size N+1) and solution values Y (size N+1).\n    \"\"\"\n    h = 1.0 / N\n    t = np.linspace(0.0, 1.0, N + 1)\n    Y = np.empty(N + 1, dtype=float)\n    Y[0] = 1.0\n    factor = 1.0 - h * lmbda\n    # Use recurrence: Y_n = factor^n\n    # Iterative to avoid potential under/overflow in pow for large N and debug clarity\n    for n in range(N):\n        Y[n + 1] = Y[n] * factor\n    return t, Y\n\ndef piecewise_linear_interpolant_values(t_nodes: np.ndarray, y_nodes: np.ndarray, t_query: np.ndarray):\n    \"\"\"\n    Evaluate the piecewise linear interpolant through (t_nodes, y_nodes) at t_query.\n    Uses numpy's linear interpolation.\n    Assumes t_nodes is sorted ascending spanning [0,1].\n    \"\"\"\n    return np.interp(t_query, t_nodes, y_nodes)\n\ndef l2_error(lmbda: float, t_nodes: np.ndarray, y_nodes: np.ndarray, num_subintervals: int = 200000):\n    \"\"\"\n    Compute L2(0,1) error norm between piecewise-linear y_h and exact y(t)=exp(-lambda t).\n    Uses composite trapezoidal rule on a uniform grid with num_subintervals subintervals.\n    \"\"\"\n    # Ensure even number of subintervals for symmetric sampling (not required for trapz but good practice)\n    if num_subintervals % 2 == 1:\n        num_subintervals += 1\n    tq = np.linspace(0.0, 1.0, num_subintervals + 1)\n    yh = piecewise_linear_interpolant_values(t_nodes, y_nodes, tq)\n    y_exact = np.exp(-lmbda * tq)\n    err_sq = (yh - y_exact) ** 2\n    integral = np.trapz(err_sq, tq)\n    return np.sqrt(integral)\n\ndef has_sign_change(y_nodes: np.ndarray):\n    \"\"\"\n    Return True if the discrete sequence y_nodes exhibits any sign change between consecutive nodes.\n    \"\"\"\n    # Consider exact zero as non-negative for sign-change detection\n    prod = y_nodes[:-1] * y_nodes[1:]\n    return np.any(prod  0.0)\n\ndef evaluate_case(lmbda: float, N_list):\n    \"\"\"\n    For a list of three N values, compute:\n    - strictly decreasing L2 error across the list order\n    - presence of oscillations (any sign change) among the three solutions\n    Returns tuple (dec_bool, osc_bool).\n    \"\"\"\n    E2_vals = []\n    osc_flags = []\n    for N in N_list:\n        t_nodes, y_nodes = forward_euler_linear_decay(lmbda, N)\n        E2 = l2_error(lmbda, t_nodes, y_nodes, num_subintervals=200000)\n        E2_vals.append(E2)\n        osc_flags.append(has_sign_change(y_nodes))\n    dec = (E2_vals[0] > E2_vals[1]) and (E2_vals[1] > E2_vals[2])\n    osc = any(osc_flags)\n    return dec, osc\n\ndef solve():\n    # Define parameters\n    lmbda = 100.0  # stiffness parameter\n    # Test cases: lists of N (number of steps); h = 1/N\n    case_A = [52, 55, 59]     # stable but oscillatory (1  h*lambda  2)\n    case_B = [200, 400, 800]  # well-resolved (h*lambda  1)\n    case_C = [50, 49, 48]     # boundary and unstable (h*lambda >= 2), ordered to break monotonic decrease\n    case_D = [83, 100, 125]   # mixed: oscillatory -> boundary -> non-oscillatory\n\n    test_cases = [case_A, case_B, case_C, case_D]\n\n    results = []\n    for case in test_cases:\n        dec, osc = evaluate_case(lmbda, case)\n        results.append(dec)\n        results.append(osc)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "在有限维向量空间中，所有范数都是“等价”的，但对于我们用来模拟物理现实的函数空间而言，情况并非如此。这个实践通过一个具体的计算例子，展示了在无限维设置中范数等价性的失效。通过将一个函数序列在一个范数下进行归一化，您将观察到其他范数如何以不同的速率衰减，从而揭示了在数值分析中选择正确范数的重要性 。",
            "id": "2389350",
            "problem": "考虑区间 $\\left[0,1\\right]$ 以及具有零边界值的连续分片线性函数的标准协调有限元空间，这是在区间 $\\left[0,1\\right]$ 上的泊松问题中，有限元方法（FEM, Finite Element Method）所使用的典型试验空间。对于一个网格尺寸为 $h \\in \\left(0,\\tfrac{1}{2}\\right]$ 且 $\\tfrac{1}{2h}$ 为整数的均匀网格，令 $\\varphi_h$ 表示中心在 $x=\\tfrac{1}{2}$ 处的节点帽状基函数，即：\n$$\n\\varphi_h(x) \\;=\\; \\begin{cases} 1 - \\dfrac{\\left|x - \\tfrac{1}{2}\\right|}{h},  \\text{若 } \\left|x - \\tfrac{1}{2}\\right| \\le h, \\\\ 0,  \\text{其他情况。} \\end{cases}\n$$\n定义 $u_h(x) = \\alpha_h\\,\\varphi_h(x)$，其中选择缩放 $\\alpha_h  0$ 以使得 $u_h$ 的 $H^1$ 半范数等于 $1$，即 $\\lVert u_h' \\rVert_{L^2(0,1)} = 1$。当 $h \\to 0$ 时，这个构造产生了一个有限元函数序列 $\\left\\{u_h\\right\\}$。\n\n你的任务是使用此序列，通过量化在 $H^1$ 半范数固定的情况下 $L^2$ 范数的行为，来展示在无穷维情形下范数等价性的失效。对于每个指定的网格尺寸 $h$，计算 $u_h$ 的以下量值：\n- $L^2$ 范数 $\\lVert u_h \\rVert_{L^2(0,1)}$，\n- $L^\\infty$ 范数 $\\lVert u_h \\rVert_{L^\\infty(0,1)}$。\n\n本问题不涉及物理单位。\n\n测试套件：\n使用网格尺寸 $h \\in \\left\\{\\tfrac{1}{2},\\,\\tfrac{1}{4},\\,\\tfrac{1}{8},\\,\\tfrac{1}{16},\\,\\tfrac{1}{32},\\,\\tfrac{1}{64}\\right\\}$。\n\n答案格式：\n你的程序应产生单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。对于按上述顺序列出的每个 $h$，按以下顺序输出两个浮点数：\n$\\left[\\lVert u_h \\rVert_{L^2(0,1)},\\, \\lVert u_h \\rVert_{L^\\infty(0,1)}\\right]$。\n所有数字必须四舍五入到小数点后恰好六位。因此，最终输出必须包含 $12$ 个数字，并且形式为\n$[\\text{L2}_1,\\text{Linfty}_1,\\text{L2}_2,\\text{Linfty}_2,\\ldots,\\text{L2}_6,\\text{Linfty}_6]$,\n其中 $\\text{L2}_k$ 和 $\\text{Linfty}_k$ 对应于测试套件中的第 $k$ 个网格尺寸。",
            "solution": "该问题是有效的，因为它在科学上基于泛函分析和有限元方法的原理，是适定的且提供了所有必要信息，并用客观、无歧义的数学语言表达。没有矛盾之处，并且可以推导出唯一的、可验证的解。\n\n目标是对于一个递减的网格尺寸序列 $h$，分析有限元函数序列 $u_h(x) = \\alpha_h \\varphi_h(x)$。缩放因子 $\\alpha_h$ 由 $H^1$ 半范数为 1 的归一化条件决定，即 $\\lVert u_h' \\rVert_{L^2(0,1)} = 1$。然后，我们必须计算序列中每个函数 $u_h$ 的 $L^2(0,1)$ 和 $L^\\infty(0,1)$ 范数。\n\n分析分三步进行：首先，确定缩放因子 $\\alpha_h$；其次，计算 $L^2$ 范数；第三，计算 $L^\\infty$ 范数。\n\n步骤 1：确定缩放因子 $\\alpha_h$。\n\n缩放因子 $\\alpha_h$ 是通过施加条件 $\\lVert u_h' \\rVert_{L^2(0,1)}^2 = 1$ 来找到的。\n函数 $u_h(x)$ 定义为 $u_h(x) = \\alpha_h \\varphi_h(x)$。它的导数是 $u_h'(x) = \\alpha_h \\varphi_h'(x)$。\n基函数 $\\varphi_h(x)$ 由下式给出\n$$\n\\varphi_h(x) =\n\\begin{cases}\n1 + \\frac{x - 1/2}{h},  x \\in [1/2 - h, 1/2] \\\\\n1 - \\frac{x - 1/2}{h},  x \\in [1/2, 1/2 + h] \\\\\n0,  \\text{其他情况}\n\\end{cases}\n$$\n(弱)导数 $\\varphi_h'(x)$ 是一个分片常数函数：\n$$\n\\varphi_h'(x) =\n\\begin{cases}\n\\frac{1}{h},  x \\in (1/2 - h, 1/2) \\\\\n-\\frac{1}{h},  x \\in (1/2, 1/2 + h) \\\\\n0,  \\text{其他情况}\n\\end{cases}\n$$\n$u_h$ 的 $H^1$ 半范数的平方是：\n$$\n\\lVert u_h' \\rVert_{L^2(0,1)}^2 = \\int_0^1 (u_h'(x))^2 \\, dx = \\alpha_h^2 \\int_0^1 (\\varphi_h'(x))^2 \\, dx\n$$\n我们计算积分项：\n$$\n\\int_0^1 (\\varphi_h'(x))^2 \\, dx = \\int_{1/2 - h}^{1/2} \\left(\\frac{1}{h}\\right)^2 \\, dx + \\int_{1/2}^{1/2+h} \\left(-\\frac{1}{h}\\right)^2 \\, dx\n$$\n$$\n= \\frac{1}{h^2} \\int_{1/2 - h}^{1/2} 1 \\, dx + \\frac{1}{h^2} \\int_{1/2}^{1/2+h} 1 \\, dx = \\frac{1}{h^2} \\cdot h + \\frac{1}{h^2} \\cdot h = \\frac{1}{h} + \\frac{1}{h} = \\frac{2}{h}\n$$\n因此，归一化条件 $\\lVert u_h' \\rVert_{L^2(0,1)}^2 = 1$ 变为：\n$$\n\\alpha_h^2 \\left(\\frac{2}{h}\\right) = 1\n$$\n由于指定了 $\\alpha_h  0$，我们求解 $\\alpha_h$：\n$$\n\\alpha_h = \\sqrt{\\frac{h}{2}}\n$$\n\n步骤 2：计算 $L^2$ 范数 $\\lVert u_h \\rVert_{L^2(0,1)}$。\n\n$u_h$ 的 $L^2$ 范数的平方由下式给出：\n$$\n\\lVert u_h \\rVert_{L^2(0,1)}^2 = \\int_0^1 (u_h(x))^2 \\, dx = \\alpha_h^2 \\int_0^1 (\\varphi_h(x))^2 \\, dx\n$$\n该积分仅在 $\\varphi_h$ 的支集，即 $[1/2 - h, 1/2 + h]$ 上非零。由于 $\\varphi_h(x)$ 关于 $x=1/2$ 的对称性，我们可以写出：\n$$\n\\int_0^1 (\\varphi_h(x))^2 \\, dx = 2 \\int_{1/2}^{1/2+h} \\left(1 - \\frac{x - 1/2}{h}\\right)^2 \\, dx\n$$\n我们进行换元 $y = x - 1/2$，因此 $dy = dx$。积分限从 $x \\in [1/2, 1/2+h]$ 变为 $y \\in [0, h]$。\n$$\n= 2 \\int_0^h \\left(1 - \\frac{y}{h}\\right)^2 \\, dy = 2 \\int_0^h \\left(1 - \\frac{2y}{h} + \\frac{y^2}{h^2}\\right) \\, dy\n$$\n$$\n= 2 \\left[ y - \\frac{y^2}{h} + \\frac{y^3}{3h^2} \\right]_0^h = 2 \\left( h - \\frac{h^2}{h} + \\frac{h^3}{3h^2} \\right) = 2 \\left( h - h + \\frac{h}{3} \\right) = \\frac{2h}{3}\n$$\n现在，我们将 $\\alpha_h^2$ 的表达式和积分结果代回到范数平方的方程中：\n$$\n\\lVert u_h \\rVert_{L^2(0,1)}^2 = \\alpha_h^2 \\cdot \\frac{2h}{3} = \\left(\\frac{h}{2}\\right) \\cdot \\frac{2h}{3} = \\frac{h^2}{3}\n$$\n取平方根得到 $L^2$ 范数：\n$$\n\\lVert u_h \\rVert_{L^2(0,1)} = \\sqrt{\\frac{h^2}{3}} = \\frac{h}{\\sqrt{3}}\n$$\n\n步骤 3：计算 $L^\\infty$ 范数 $\\lVert u_h \\rVert_{L^\\infty(0,1)}$。\n\n$L^\\infty$ 范数是函数绝对值的本性上确界。对于像 $u_h(x)$ 这样的连续函数，这等于其绝对值的最大值。\n$$\n\\lVert u_h \\rVert_{L^\\infty(0,1)} = \\sup_{x \\in (0,1)} |u_h(x)|\n$$\n由于 $\\alpha_h  0$ 且 $\\varphi_h(x) \\ge 0$，这简化为：\n$$\n\\lVert u_h \\rVert_{L^\\infty(0,1)} = \\alpha_h \\cdot \\sup_{x \\in (0,1)} \\varphi_h(x)\n$$\n帽状函数 $\\varphi_h(x)$ 在其中心 $x=1/2$ 处达到其最大值 $1$。\n$$\n\\sup_{x \\in (0,1)} \\varphi_h(x) = \\varphi_h(1/2) = 1\n$$\n因此，$L^\\infty$ 范数等于缩放因子 $\\alpha_h$：\n$$\n\\lVert u_h \\rVert_{L^\\infty(0,1)} = \\alpha_h \\cdot 1 = \\alpha_h = \\sqrt{\\frac{h}{2}}\n$$\n当 $h \\to 0$ 时，根据构造我们有 $\\lVert u_h' \\rVert_{L^2(0,1)} = 1$，而 $\\lVert u_h \\rVert_{L^2(0,1)} \\sim O(h) \\to 0$ 且 $\\lVert u_h \\rVert_{L^\\infty(0,1)} \\sim O(\\sqrt{h}) \\to 0$。这表明，在作为这些有限元空间之并集的完备化的无穷维空间上，$H^1$ 半范数与 $L^2$ 或 $L^\\infty$ 范数并不等价。\n\n需要实现的最终公式是：\n- $L^2$ 范数：$\\lVert u_h \\rVert_{L^2(0,1)} = \\frac{h}{\\sqrt{3}}$\n- $L^\\infty$ 范数：$\\lVert u_h \\rVert_{L^\\infty(0,1)} = \\sqrt{\\frac{h}{2}}$",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the L2 and L-infinity norms for a sequence of FEM functions.\n\n    For each mesh size h in the test suite, this function calculates the norms\n    of a function u_h(x) = alpha_h * phi_h(x), where phi_h is a nodal hat\n    basis function and alpha_h is a scaling factor chosen such that the H1\n    seminorm of u_h is 1.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Mesh sizes h.\n    test_cases = [1/2, 1/4, 1/8, 1/16, 1/32, 1/64]\n\n    results = []\n    for h in test_cases:\n        # The analytical formulas for the norms are derived as:\n        # L2 norm: ||u_h||_L2 = h / sqrt(3)\n        # L-infinity norm: ||u_h||_L_inf = sqrt(h / 2)\n\n        # Calculate the L2 norm for the current h.\n        l2_norm = h / np.sqrt(3)\n\n        # Calculate the L-infinity norm for the current h.\n        linf_norm = np.sqrt(h / 2)\n\n        # Append the rounded results to the list.\n        results.append(round(l2_norm, 6))\n        results.append(round(linf_norm, 6))\n\n    # Format the final output string as required.\n    # The map converts each float to its string representation.\n    # The ':.6f' format specifier ensures exactly six digits after the decimal point.\n    formatted_results = [f\"{num:.6f}\" for num in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}