{
    "hands_on_practices": [
        {
            "introduction": "动量系数 $\\beta$ 通常被定性地描述为控制优化器的“记忆”能力。本练习将挑战你超越直觉，将这一概念形式化。通过将动量更新视为一个线性滤波器，你将推导并比较其“有效平均窗口”的不同量化指标，为调整和理解 $\\beta$ 提供坚实的数学基础。",
            "id": "3154008",
            "problem": "要求您形式化并验证在深度学习中基于动量的优化所使用的指数移动平均（EMA）的有效平均窗口长度这一概念。考虑在动量法和自适应矩估计等方法中用于梯度计算的标准 EMA 估计量，其递归定义如下：在离散时间步索引 $t$ 处，估计值 $m_t$ 使用衰减参数 $\\beta \\in [0,1)$ 和一个标量梯度信号 $g_t$ 进行更新，该更新遵循一个线性递推关系，结合了前一个估计值 $m_{t-1}$ 与当前的 $g_t$。假设 $m_0 = 0$。\n\n您的任务是：\n\n- 从给定的递推关系和线性时不变系统的叠加原理出发，定义脉冲响应权重 $w_k$，该权重用以量化过去 $k$ 步的梯度对当前 EMA 估计值的贡献。论证这些权重构成一个总和为 $1$ 的非负序列，并将其解释为非负整数上的一个概率质量函数。\n\n- 仅使用关于几何级数的基本性质，定义有效平均窗口长度的两个量化概念：\n  1. 累积质量窗口长度 $L_p$，对于一个固定的阈值 $p \\in (0,1)$，定义为满足 $\\sum_{k=0}^{L-1} w_k \\ge p$ 的最小整数 $L$。对于本问题，使用 $p = 0.95$，并将其视为一个无单位的小数阈值。\n  2. 有效样本量 $N_{\\mathrm{eff}}$，定义为 $N_{\\mathrm{eff}} = 1/\\sum_{k=0}^{\\infty} w_k^2$，它对应于在独立同分布噪声下，能够产生与几何加权平均相同的方差缩减效果的等权重样本数量。\n\n- 推导一个“有效平均窗口长度”的简单闭式基准。该基准通过将归一化权重视为概率质量函数并使用一阶矩来定义特征窗口长度而得到。此基准直接源于几何级数的求和。除几何级数性质外，不要假定任何外部结论。\n\n- 设计一个计算验证任务：对于一组衰减参数 $\\beta$，计算两种有效窗口长度度量与基于几何级数的简单基准的比率。具体来说，对每个 $\\beta$ 计算\n  - $r_L = L_{0.95} \\,/\\, \\text{baseline}$，\n  - $r_N = N_{\\mathrm{eff}} \\,/\\, \\text{baseline}$。\n\n您的程序必须实现上述量，并为以下衰减参数测试套件生成结果，该测试套件探究了正常路径和类边界情形：\n- $\\beta \\in \\{\\, 0.0,\\, 0.5,\\, 0.9,\\, 0.99,\\, 0.999 \\,\\}$。\n\n需要考虑的边界情况：\n- 当 $\\beta = 0$ 时，EMA 仅简化为当前梯度。\n- 当 $\\beta \\to 1^{-}$ 时，EMA 保留非常长的记忆，有效窗口长度变得非常大。\n\n实现细节和输出格式要求：\n- 您的程序必须是自包含的，除了下面描述的最后一行外，不产生任何其他输出。\n- 在所有计算中使用表示为小数的 $p = 0.95$。\n- 对于给定测试套件中的每个 $\\beta$，计算如上定义的 $r_L$ 和 $r_N$。\n- 将最终结果报告为单行，其中包含一个列表的列表，每个 $\\beta$ 对应一个内部列表，顺序与上文列出的一致。每个内部列表包含两个比率 $[r_L, r_N]$，形式为四舍五入到三位小数的浮点数。\n- 要求的最终输出格式为：\n  - 单行：一个 Python 列表的列表的字符串表示，例如 $[[a_{11},a_{12}],[a_{21},a_{22}],\\dots]$，其中每个 $a_{ij}$ 都是一个四舍五入到三位小数的十进制数，并且没有任何附加文本。\n\n本问题不涉及物理单位，也不使用角度。百分比必须表示为小数，而不是使用百分号。整个问题是纯粹的数学和算法问题，基于 EMA 的定义和几何级数的性质。通过对接近 $1$ 的 $\\beta$ 值使用精确的或可证明收敛的级数操作（而不是在适当时使用朴素截断）来确保科学真实性和数值稳定性。",
            "solution": "该问题要求对深度学习中使用的指数移动平均（EMA）的有效平均窗口长度概念进行形式化和验证。我们将首先推导 EMA 滤波器的脉冲响应，然后基于基本原理定义三个不同的有效窗口长度度量，最后为一组给定的参数计算这些度量的比率。\n\nEMA 更新规则是一个线性递推，它根据前一个估计值 $m_{t-1}$ 和当前输入信号 $g_t$（例如梯度）计算时间步 $t$ 的新估计值 $m_t$。参数 $\\beta \\in [0,1)$ 控制衰减率。问题指出，过去梯度的权重之和必须为 $1$，这唯一地确定了递推的标准形式：\n$$m_t = \\beta m_{t-1} + (1-\\beta) g_t$$\n给定初始条件 $m_0 = 0$，我们可以展开这个递推关系，将 $m_t$ 表示为所有过去梯度的加权和：\n$$m_t = (1-\\beta)g_t + \\beta m_{t-1} = (1-\\beta)g_t + \\beta((1-\\beta)g_{t-1} + \\beta m_{t-2})$$\n$$m_t = (1-\\beta)g_t + (1-\\beta)\\beta g_{t-1} + (1-\\beta)\\beta^2 g_{t-2} + \\dots$$\n在稳态极限下（或对于已运行很多步的进程，$t \\to \\infty$），当前估计值 $m_t$ 是所有过去梯度的叠加，延伸至 $k \\to \\infty$：\n$$m_t = \\sum_{k=0}^{\\infty} (1-\\beta)\\beta^k g_{t-k}$$\n因此，脉冲响应权重 $w_k$（量化了过去 $k$ 步的梯度 $g_{t-k}$ 的贡献）由下式给出：\n$$w_k = (1-\\beta)\\beta^k, \\quad \\text{for } k \\in \\{0, 1, 2, \\dots\\}$$\n这些权重在非负整数上构成了一个有效的概率质量函数。首先，由于 $\\beta \\in [0, 1)$，$(1-\\beta)$ 和 $\\beta^k$ 都是非负的，因此对于所有 $k$，都有 $w_k \\ge 0$。其次，这些权重的总和是一个几何级数：\n$$\\sum_{k=0}^{\\infty} w_k = \\sum_{k=0}^{\\infty} (1-\\beta)\\beta^k = (1-\\beta) \\sum_{k=0}^{\\infty} \\beta^k = (1-\\beta) \\left( \\frac{1}{1-\\beta} \\right) = 1$$\n这个序列 $w_k$ 代表了以时间步为单位测量的梯度“年龄”的几何分布。\n\n问题要求从该分布的一阶矩推导基准窗口长度。此概率分布的一阶矩，即均值 $\\mu$，是信息的期望年龄：\n$$\\mu = \\mathbb{E}[k] = \\sum_{k=0}^{\\infty} k \\, w_k = \\sum_{k=0}^{\\infty} k (1-\\beta) \\beta^k = (1-\\beta) \\sum_{k=0}^{\\infty} k \\beta^k$$\n该和式可以使用几何级数公式的导数进行计算：$\\sum_{k=0}^{\\infty} k x^k = x/(1-x)^2$。\n$$\\mu = (1-\\beta) \\frac{\\beta}{(1-\\beta)^2} = \\frac{\\beta}{1-\\beta}$$\n这个平均年龄 $\\mu$ 可用于定义一个特征窗口长度。简单地使用 $\\mu$ 会有问题，因为当 $\\beta=0$ 时，$\\mu=0$，这不是一个有意义的长度，并且会在所需的比率计算中导致除零错误。一个更鲁棒且与常见启发式方法一致的定义是，将基准长度定义为 $L_{\\text{baseline}} = \\mu + 1$。这代表了从索引 $0$ 到平均索引 $\\mu$ 的样本数量。\n$$L_{\\text{baseline}} = \\mu + 1 = \\frac{\\beta}{1-\\beta} + 1 = \\frac{\\beta + 1 - \\beta}{1-\\beta} = \\frac{1}{1-\\beta}$$\n该定义在 $\\beta=0$ 时得出的长度为 $1$，并在 $\\beta \\to 1^-$ 时增长至无穷大，这对于窗口长度来说是一种合理的行为。\n\n接下来，我们形式化两个指定的有效窗口长度度量。\n\n1.  累积质量窗口长度 $L_p$ 是使得前 $L$ 个权重之和达到阈值 $p$ 的最小整数 $L$。我们给定 $p=0.95$。\n    $$\\sum_{k=0}^{L-1} w_k = \\sum_{k=0}^{L-1} (1-\\beta)\\beta^k = (1-\\beta) \\frac{1-\\beta^L}{1-\\beta} = 1-\\beta^L$$\n    我们寻找满足 $1-\\beta^L \\ge p$ 的最小整数 $L$。\n    $$1 - p \\ge \\beta^L$$\n    对于 $\\beta \\in (0,1)$，我们取对数，由于 $\\log(\\beta)$ 是负数，这会反转不等号：\n    $$\\log(1-p) \\le L \\log(\\beta) \\implies L \\ge \\frac{\\log(1-p)}{\\log(\\beta)}$$\n    因为 $L$ 必须是整数，我们对这个表达式取上整。对于 $\\beta=0$ 的特殊情况，$w_0=1$ 且所有其他权重为 $0$，因此对于任何 $L \\ge 1$，和都为 $1$；因此，最小的 $L$ 是 $1$。\n    $$L_p = \\begin{cases} 1  \\text{if } \\beta=0 \\\\ \\left\\lceil \\frac{\\log(1-p)}{\\log(\\beta)} \\right\\rceil  \\text{if } \\beta \\in (0,1) \\end{cases}$$\n    当 $p=0.95$ 时，对于 $\\beta  0$，此式变为 $L_{0.95} = \\lceil \\log(0.05)/\\log(\\beta) \\rceil$。\n\n2.  有效样本量 $N_{\\text{eff}}$ 定义为 $N_{\\text{eff}} = 1/\\sum_{k=0}^{\\infty} w_k^2$。该度量衡量的是能够提供相同方差缩减效果的等效独立样本数量。\n    $$\\sum_{k=0}^{\\infty} w_k^2 = \\sum_{k=0}^{\\infty} ((1-\\beta)\\beta^k)^2 = (1-\\beta)^2 \\sum_{k=0}^{\\infty} (\\beta^2)^k$$\n    这是另一个公比为 $\\beta^2$ 的几何级数，其收敛于 $1/(1-\\beta^2)$。\n    $$\\sum_{k=0}^{\\infty} w_k^2 = (1-\\beta)^2 \\frac{1}{1-\\beta^2} = (1-\\beta)^2 \\frac{1}{(1-\\beta)(1+\\beta)} = \\frac{1-\\beta}{1+\\beta}$$\n    因此，有效样本量为：\n    $$N_{\\text{eff}} = \\frac{1}{(1-\\beta)/(1+\\beta)} = \\frac{1+\\beta}{1-\\beta}$$\n    此公式对所有 $\\beta \\in [0,1)$ 均有效。\n\n最后，我们为计算任务计算所需的比率。\n第一个比率是 $r_L = L_{0.95} / L_{\\text{baseline}}$：\n$$r_L = \\frac{L_{0.95}}{L_{\\text{baseline}}} = (1-\\beta) L_{0.95} = (1-\\beta) \\left\\lceil \\frac{\\log(0.05)}{\\log(\\beta)} \\right\\rceil \\quad (\\text{for } \\beta  0)$$\n在极限 $\\beta \\to 1^-$ 下，令 $\\beta = 1-\\epsilon$，其中 $\\epsilon \\to 0^+$。那么 $\\log(\\beta) \\approx -\\epsilon$。上整函数内的项变为 $\\log(0.05)/(-\\epsilon) \\approx 2.9957/\\epsilon$。该比率趋近于 $r_L \\approx \\epsilon (\\lceil 2.9957/\\epsilon \\rceil) \\to 2.9957 = \\log(20)$。\n\n第二个比率是 $r_N = N_{\\text{eff}} / L_{\\text{baseline}}$：\n$$r_N = \\frac{N_{\\text{eff}}}{L_{\\text{baseline}}} = \\frac{(1+\\beta)/(1-\\beta)}{1/(1-\\beta)} = 1+\\beta$$\n这个非常简洁的结果对所有 $\\beta \\in [0,1)$ 都有效。当 $\\beta \\to 1^-$ 时，该比率趋近于 $2$。\n\nPython 代码将实现这些推导出的公式，以计算指定 $\\beta$ 值测试套件的比率。对于 $\\beta=0$，将使用推导出的特殊处理方法：$L_{0.95}(0)=1$，$N_{\\text{eff}}(0)=1$ 和 $L_{\\text{baseline}}(0)=1$，得出 $r_L=1$ 和 $r_N=1$。",
            "answer": "```python\nimport numpy as np\nimport math\n\n# The problem is valid. Proceeding with the solution.\n\ndef solve():\n    \"\"\"\n    Computes effective window length ratios for an Exponential Moving Average (EMA).\n    \n    This function calculates two ratios, r_L and r_N, for a given set of EMA\n    decay parameters (beta).\n    \n    r_L = L_0.95 / L_baseline\n    r_N = N_eff / L_baseline\n    \n    where:\n    - L_0.95 is the cumulative-mass window length for p=0.95.\n    - N_eff is the effective sample size.\n    - L_baseline is a baseline window length derived from the first moment.\n    \"\"\"\n    \n    # Test suite of decay parameters\n    betas = [0.0, 0.5, 0.9, 0.99, 0.999]\n    \n    # Threshold for cumulative-mass window length\n    p = 0.95\n    log_1_minus_p = np.log(1.0 - p)\n\n    results = []\n    for beta in betas:\n        # Handle the edge case beta = 0 separately to avoid log(0)\n        if beta == 0.0:\n            # For beta=0, EMA is just the current gradient. All window lengths are 1.\n            # L_baseline = 1/(1-0) = 1\n            # L_0.95 = 1 (since w_0 = 1 = 0.95)\n            # N_eff = (1+0)/(1-0) = 1\n            r_L = 1.0\n            r_N = 1.0\n            results.append([round(r_L, 3), round(r_N, 3)])\n            continue\n\n        # Derived formulas from the solution section\n        \n        # 1. Baseline window length: L_baseline = 1 / (1 - beta)\n        L_baseline = 1.0 / (1.0 - beta)\n        \n        # 2. Cumulative-mass window length: L_0.95 = ceil(log(1-p) / log(beta))\n        L_095 = np.ceil(log_1_minus_p / np.log(beta))\n        \n        # 3. Effective sample size: N_eff = (1 + beta) / (1 - beta)\n        N_eff = (1.0 + beta) / (1.0 - beta)\n        \n        # Compute the ratios\n        r_L = L_095 / L_baseline\n        # r_N can be computed directly as 1 + beta, but we compute it from\n        # the definitions as a cross-check, which is more robust.\n        r_N = N_eff / L_baseline\n\n        # Round results to three decimal places before storing\n        results.append([round(r_L, 3), round(r_N, 3)])\n        \n    # Format the output into the required single-line string representation\n    # of a list of lists, with no spaces inside the inner lists.\n    # e.g., [[1.0,1.0],[2.5,1.5],...]\n    inner_strings = [str(item).replace(' ', '') for item in results]\n    final_output_string = f\"[{','.join(inner_strings)}]\"\n    \n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "为什么动量法有时会引起振荡并越过最小值点？本实践揭示了动量优化与阻尼谐振子物理学之间的深刻联系。通过分析优化器在简单二次势能面上的运动，你将揭示决定下降过程是平滑还是振荡的数学条件，从而为理解动量的行为建立一个强大的心智模型。",
            "id": "3154030",
            "problem": "考虑一维四次目标函数 $f(\\theta)=\\frac{1}{4}\\theta^4$ 以及由学习率 $\\eta0$ 和动量系数 $\\beta\\ge 0$ 定义的经典动量更新。经典动量迭代由两个耦合方程给出：一个速度更新和一个参数更新。用符号表示，对于 $t\\in\\{0,1,2,\\dots\\}$，\n$$\nv_{t+1}=\\beta\\,v_t+\\nabla f(\\theta_t)\\quad\\text{和}\\quad \\theta_{t+1}=\\theta_t-\\eta\\,v_{t+1}.\n$$\n从这些核心定义出发，在没有额外假设的情况下，推导出仅含 $\\theta_t$ 的等价二阶差分方程。然后，通过在参考振幅 $a0$ 周围对非线性项进行局部线性化，将此离散时间动态与阻尼振子的行为联系起来。具体来说，在推导出的二阶差分方程中使用近似 $\\theta_t^3\\approx a^2\\,\\theta_t$ 来获得一个线性常系数递推关系，并分析其特征方程。从第一性原理出发，刻画参数对 $(\\eta,\\beta)$ 如何控制参考振幅 $a$ 附近的定性行为：无超调的单调下降、有超调的阻尼振荡、稳定边界上的持续振荡以及发散。你的刻画必须用关于 $(\\eta,\\beta)$ 和参考振幅 $a$ 的不等式来表示，并且必须与特征多项式的根结构以及阻尼状态（过阻尼、临界阻尼、欠阻尼）的离散时间模拟相关联。\n\n你的程序必须实现此刻画规则，以对几个测试用例进行分类。对于每个测试用例，将参考振幅 $a$ 视为线性化点，并通过分析线性化二阶递推关系的特征多项式来计算分类。分类整数必须遵循以下编码：\n- $0$：单调下降（无超调），对应于非振荡衰减，其根为严格位于单位圆盘内部的非负实根。\n- $1$：阻尼振荡（有超调），对应于振荡衰减；当谱半径严格小于1且根的结构产生符号交替或共轭复根时发生。\n- $2$：持续振荡（稳定边界），对应于模为1的主导根，即谱半径等于1。\n- $3$：发散，对应于谱半径严格大于1。\n\n你的程序应评估以下测试套件，其中每个测试用例是一个三元组 $(\\eta,\\beta,a)$，且 $a0$：\n- $(\\eta,\\beta,a)=\\left(0.05,\\,0.5,\\,1.0\\right)$\n- $(\\eta,\\beta,a)=\\left(0.3,\\,0.9,\\,1.0\\right)$\n- $(\\eta,\\beta,a)=\\left(3.0,\\,0.5,\\,1.0\\right)$\n- $(\\eta,\\beta,a)=\\left(4.0,\\,0.2,\\,1.0\\right)$\n- $(\\eta,\\beta,a)=\\left(0.5,\\,0.0,\\,1.0\\right)$\n- $(\\eta,\\beta,a)=\\left(1.2,\\,0.0,\\,1.0\\right)$\n\n不涉及物理单位。不使用角度。结果必须是纯数值的。你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，顺序与测试套件中的顺序相同。例如，如果你的分类依次是 $r_1,\\dots,r_6$，则打印行 $\\left[\\text{r}_1,\\text{r}_2,\\text{r}_3,\\text{r}_4,\\text{r}_5,\\text{r}_6\\right]$，不含任何额外文本。",
            "solution": "该问题要求对经典动量优化算法在一维四次目标函数 $f(\\theta) = \\frac{1}{4}\\theta^4$ 上的动态特性进行刻画。这涉及到推导一个二阶差分方程，对其进行线性化，并根据其参数分析其稳定性和行为。\n\n### 步骤1：推导二阶差分方程\n\n我们从给定的经典动量耦合方程开始：\n$$v_{t+1} = \\beta v_t + \\nabla f(\\theta_t)$$\n$$\\theta_{t+1} = \\theta_t - \\eta v_{t+1}$$\n目标函数为 $f(\\theta) = \\frac{1}{4}\\theta^4$，因此其梯度为 $\\nabla f(\\theta) = \\frac{d}{d\\theta}\\left(\\frac{1}{4}\\theta^4\\right) = \\theta^3$。更新方程变为：\n$$v_{t+1} = \\beta v_t + \\theta_t^3 \\quad (1)$$\n$$\\theta_{t+1} = \\theta_t - \\eta v_{t+1} \\quad (2)$$\n\n为了得到关于 $\\theta_t$ 的单一差分方程，我们必须消去速度项 $v_t$ 和 $v_{t+1}$。从方程(2)中，我们可以用参数 $\\theta_t$ 和 $\\theta_{t+1}$ 来表示 $v_{t+1}$：\n$$v_{t+1} = \\frac{1}{\\eta}(\\theta_t - \\theta_{t+1})$$\n通过将时间索引从 $t+1$ 平移到 $t$，我们也可以表示 $v_t$：\n$$v_t = \\frac{1}{\\eta}(\\theta_{t-1} - \\theta_t)$$\n将 $v_t$ 和 $v_{t+1}$ 的这些表达式代入速度更新方程(1)：\n$$\\frac{1}{\\eta}(\\theta_t - \\theta_{t+1}) = \\beta \\left( \\frac{1}{\\eta}(\\theta_{t-1} - \\theta_t) \\right) + \\theta_t^3$$\n整个方程乘以 $\\eta$ 以消去分母：\n$$\\theta_t - \\theta_{t+1} = \\beta(\\theta_{t-1} - \\theta_t) + \\eta \\theta_t^3$$\n最后，我们重新整理方程以分离出 $\\theta_{t+1}$，它代表了作为先前状态函数的下一个状态：\n$$\\theta_{t+1} = \\theta_t - \\beta(\\theta_{t-1} - \\theta_t) - \\eta \\theta_t^3$$\n$$\\theta_{t+1} = (1+\\beta)\\theta_t - \\beta\\theta_{t-1} - \\eta \\theta_t^3$$\n这就是我们所求的控制序列 $\\{\\theta_t\\}$ 的二阶非线性差分方程。\n\n### 步骤2：线性化与特征方程\n\n非线性系统的行为可以通过在参考点周围进行线性化来局部近似。问题指定在参考振幅 $a  0$ 周围对非线性项 $\\theta_t^3$ 进行局部线性化，使用近似 $\\theta_t^3 \\approx a^2 \\theta_t$。将此代入差分方程：\n$$\\theta_{t+1} \\approx (1+\\beta)\\theta_t - \\beta\\theta_{t-1} - \\eta (a^2 \\theta_t)$$\n合并包含 $\\theta_t$ 的项：\n$$\\theta_{t+1} = (1+\\beta - \\eta a^2)\\theta_t - \\beta\\theta_{t-1}$$\n为了分析这个线性、齐次、常系数差分方程，我们寻找形式为 $\\theta_t = \\lambda^t$ 的解。代入这个假设解（ansatz）可得到特征方程：\n$$\\lambda^{t+1} = (1+\\beta - \\eta a^2)\\lambda^t - \\beta\\lambda^{t-1}$$\n两边除以 $\\lambda^{t-1}$ (对于 $\\lambda \\neq 0$)：\n$$\\lambda^2 - (1+\\beta - \\eta a^2)\\lambda + \\beta = 0$$\n这个二次特征多项式的根 $\\lambda_{1,2}$ 决定了线性化系统的定性行为。\n\n### 步骤3：稳定性分析与分类\n\n由特征多项式 $P(\\lambda) = \\lambda^2 + A\\lambda + B = 0$ 描述的离散时间系统的稳定性由Jury稳定性判据确定，该判据要求所有根的模长都小于1。对于二阶系统，这些判据是：\n1. $P(1)  0$\n2. $P(-1)  0$\n3. $|B|  1$\n\n在我们的例子中，多项式是 $P(\\lambda) = \\lambda^2 - (1+\\beta - \\eta a^2)\\lambda + \\beta$，因此 $A = -(1+\\beta - \\eta a^2)$ 且 $B = \\beta$。\n1. $P(1) = 1 - (1+\\beta - \\eta a^2) + \\beta = \\eta a^2$。由于 $\\eta  0$ 且 $a  0$，所以 $P(1)  0$ 总是成立。这意味着根不可能在 $\\lambda=1$ 处，因此系统不会收敛到一个非零常数。\n2. $P(-1) = 1 + (1+\\beta - \\eta a^2) + \\beta = 2(1+\\beta) - \\eta a^2$。稳定性条件是 $2(1+\\beta) - \\eta a^2  0$，即 $\\eta a^2  2(1+\\beta)$。\n3. $|B| = |\\beta|  1$。因为问题陈述 $\\beta \\ge 0$，这可简化为 $0 \\le \\beta  1$。\n\n稳定衰减到原点（$\\rho = \\max(|\\lambda_1|, |\\lambda_2|)  1$）要求 $0 \\le \\beta  1$ 且 $0  \\eta a^2  2(1+\\beta)$。\n\n现在我们可以定义行为的类别：\n\n- **类别3 (发散):** 谱半径 $\\rho  1$。如果任何稳定性条件被违反，就会发生这种情况。\n    - 如果 $\\beta  1$，根的乘积 $\\lambda_1\\lambda_2 = \\beta  1$，因此至少有一个根必须位于单位圆之外。\n    - 如果 $\\eta a^2  2(1+\\beta)$，则 $P(-1)  0$。由于 $P(1)  0$，必须存在一个实根 $\\lambda  -1$，导致发散。\n    - 一个特殊情况是 $\\beta=1$ 和 $\\eta a^2 \\ge 4$，这会导致实根，其中至少有一个根满足 $|\\lambda| \\ge 1$（当 $\\eta a^2=4$ 时，在 $\\lambda=-1$ 处有一个重根，导致振幅线性增长）。\n\n- **类别2 (持续振荡):** 谱半径 $\\rho = 1$，且没有根在单位圆外。这种情况发生在稳定边界上。\n    - 如果 $\\beta = 1$ 且 $0  \\eta a^2  4$。根是模为 $\\sqrt{\\beta}=1$ 的共轭复根，位于单位圆上。\n    - 如果 $\\eta a^2 = 2(1+\\beta)$ 且 $0 \\le \\beta  1$。这意味着 $P(-1)=0$，所以一个根是 $\\lambda_1 = -1$。另一个根是 $\\lambda_2 = \\beta/\\lambda_1 = -\\beta$。由于 $|\\beta|1$，主导根的模为1。\n \n- **类别0和1 (稳定衰减):** 系统是稳定的（$0 \\le \\beta  1$ 且 $0  \\eta a^2  2(1+\\beta)$）。行为由根的性质区分，这取决于特征方程的判别式：$\\Delta = (1+\\beta - \\eta a^2)^2 - 4\\beta$。\n    - 如果 $\\Delta  0$，根是共轭复根。解是一个衰减的正弦波，即振荡。这属于 **类别1（阻尼振荡）**。\n    - 如果 $\\Delta \\ge 0$，根是实数。行为取决于它们的符号。根的乘积为 $\\beta \\ge 0$，所以它们同号。它们的符号由它们的和 $C_1 = 1+\\beta - \\eta a^2$ 决定。\n        - 如果 $C_1 = 1+\\beta - \\eta a^2  0$，两个根都是负数。解包含 $(-\\lambda)^t$ 这样的项，产生符号交替（超调）。这是 **类别1（阻尼振荡）**。\n        - 如果 $C_1 = 1+\\beta - \\eta a^2 \\ge 0$，两个根都是非负的。解是具有非负底数的衰减指数之和，导致 **类别0（单调下降）**。\n\n### 分类逻辑总结\n\n对于给定的 $(\\eta, \\beta, a)$:\n1. 定义 $C_0 = \\eta a^2$。\n2. **类别3 (发散):**\n   如果 $\\beta  1$ 或 $C_0  2(1+\\beta)$ 或 ($\\beta = 1$ 且 $C_0 \\ge 4$)。\n3. **类别2 (持续振荡):**\n   如果 ($\\beta = 1$ 且 $C_0  4$) 或 ($C_0 = 2(1+\\beta)$ 且 $\\beta  1$)。\n4. **稳定情况:** 否则，系统是稳定的。\n   - 令 $C_1 = 1+\\beta-C_0$ 且 $\\Delta = C_1^2 - 4\\beta$。\n   - **类别1 (阻尼振荡):** 如果 $\\Delta  0$ 或 $C_1  0$。\n   - **类别0 (单调下降):** 如果 $\\Delta \\ge 0$ 且 $C_1 \\ge 0$。\n注意：浮点数的相等性比较应使用一个小的容差来处理。",
            "answer": "```python\nimport numpy as np\n\ndef classify_dynamics(eta, beta, a):\n    \"\"\"\n    Classifies the behavior of the linearized momentum dynamics.\n\n    Args:\n        eta (float): Learning rate.\n        beta (float): Momentum coefficient.\n        a (float): Reference amplitude for linearization.\n\n    Returns:\n        int: Classification code (0, 1, 2, or 3).\n    \"\"\"\n    if eta = 0 or a = 0 or beta  0:\n        # Invalid parameters based on problem constraints.\n        # This case is not expected for the given test suite.\n        raise ValueError(\"Parameters eta and a must be > 0, and beta must be >= 0.\")\n    \n    c0 = eta * a**2\n    \n    # Use a tolerance for floating-point equality checks.\n    tol = 1e-9\n\n    # Category 3: Divergence (spectral radius > 1)\n    # Corresponds to violation of Jury stability conditions.\n    if beta > 1 + tol:\n        return 3\n    if c0 > 2 * (1 + beta) + tol:\n        return 3\n    if np.isclose(beta, 1.0, atol=tol) and c0 >= 4.0 - tol:\n        return 3\n\n    # Category 2: Sustained Oscillations (spectral radius = 1)\n    # Corresponds to being on the boundary of the stability region.\n    if np.isclose(beta, 1.0, atol=tol) and c0  4.0 - tol:\n        # Ensure c0 > 0, which is guaranteed by eta > 0, a > 0\n        return 2\n    if np.isclose(c0, 2 * (1 + beta), atol=tol) and beta  1.0 - tol:\n        return 2\n\n    # If not divergent or sustained, the system is stable (spectral radius  1).\n    # We now distinguish between monotone and oscillatory decay.\n    c1 = 1 + beta - c0\n    discriminant = c1**2 - 4 * beta\n\n    # Category 1: Damped Oscillations\n    # Complex roots or real negative roots (causing sign alternation).\n    if discriminant  0 or c1  0:\n        return 1\n    \n    # Category 0: Monotone Descent\n    # Real, non-negative roots.\n    # This is the remaining case: discriminant >= 0 and c1 >= 0.\n    return 0\n\ndef solve():\n    \"\"\"\n    Solves the problem by classifying the dynamics for each test case.\n    \"\"\"\n    test_cases = [\n        (0.05, 0.5, 1.0),\n        (0.3, 0.9, 1.0),\n        (3.0, 0.5, 1.0),\n        (4.0, 0.2, 1.0),\n        (0.5, 0.0, 1.0),\n        (1.2, 0.0, 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        eta, beta, a = case\n        classification = classify_dynamics(eta, beta, a)\n        results.append(classification)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "在实践中，优化算法由多个相互作用的组件构成。本练习探讨了一个关键且常见的问题：动量与梯度裁剪之间的相互作用。你将设计一个场景，在该场景中，朴素的动量累积会导致过度振荡，然后你将开发一种基于原则的修正方法，从而学会如何在复杂的优化系统中诊断和修复病态行为。",
            "id": "3154076",
            "problem": "考虑一个一维优化问题，其可微目标函数定义为分段二次函数：对于正常数半径 $r$ 和正常数曲率 $a_{\\mathrm{hi}}$ 与 $a_{\\mathrm{lo}}$，\n$$\nL(x) = \n\\begin{cases}\n\\dfrac{1}{2} a_{\\mathrm{hi}} x^2  \\text{若 } |x| \\le r, \\\\\n\\dfrac{1}{2} a_{\\mathrm{lo}} x^2  \\text{若 } |x|  r.\n\\end{cases}\n$$\n因此，梯度为\n$$\n\\nabla L(x) = \n\\begin{cases}\na_{\\mathrm{hi}} x  \\text{若 } |x| \\le r, \\\\\na_{\\mathrm{lo}} x  \\text{若 } |x|  r.\n\\end{cases}\n$$\n考虑使用带动量（也称为重球法）的随机梯度下降（SGD）进行优化，并在一个维度上受制于阈值为 $c  0$ 的基于范数的梯度裁剪。裁剪规则为\n$$\ng_t = \\nabla L(x_t), \\quad g_t^{\\mathrm{clip}} = \\operatorname{sign}(g_t) \\cdot \\min\\!\\big(|g_t|, c\\big),\n$$\n动量更新为\n$$\nv_t = \\mu v_{t-1} + g_t^{\\mathrm{clip}}, \\quad x_{t+1} = x_t - \\eta v_t,\n$$\n其中步长 $\\eta  0$，动量系数 $\\mu \\in [0,1)$。\n\n任务1（推导）：从基本的离散时间线性系统分析出发，将未裁剪区域 $|g_t| \\le c$ 视为围绕固定曲率 $a$ 的线性递归（即，对于某个固定的 $a  0$，$g_t = a x_t$）。证明当没有裁剪时，该递归可以写成一个关于 $x_t$ 的二阶差分方程，其特征多项式为\n$$\np(r) = r^2 - \\big(1 + \\mu - \\eta a\\big) r + \\mu,\n$$\n并回顾欠阻尼行为对应于共轭复数特征根，这种情况在判别式\n$$\n\\Delta = \\big(1 + \\mu - \\eta a\\big)^2 - 4 \\mu\n$$\n为负时发生。以此为基础，论述进入和离开裁剪区域（$|g_t|  c$）如何系统地改变有效刚度和 $v_t$ 随时间的累积，从而影响振荡（$x_t$ 的符号变化）的趋势。\n\n任务2（设计与提议）：使用上述 $L(x)$，设计一个场景，其参数为 $a_{\\mathrm{hi}}$、$a_{\\mathrm{lo}}$、$r$、$x_0$、$\\eta$、$\\mu$ 和 $c$，使得裁剪在早期（对于大的 $|x|$）发生，并且在恢复力被 $c$ 限制的同时，动量显著累积。解释为什么一旦迭代点接近 $|x| \\le r$ 附近的高曲率区域（裁剪在此处停止），这会产生 $x_t$ 的重复符号变化（轨迹意义上的系统性欠阻尼）。提出一种校正缩放方案，在裁剪激活时调节动量结转，仅使用时间 $t$ 可用的瞬时量，而无需二阶导数等额外信息。您的提议必须是应用于更新中动量系数的乘法调整，表示为瞬时裁剪因子\n$$\n\\gamma_t = \\frac{|g_t^{\\mathrm{clip}}|}{|g_t| + \\varepsilon},\n$$\n的函数，其中 $\\varepsilon$ 是一个小的正常数，仅用于避免除以零。\n\n任务3（实现与测试套件）：为一维 $L(x)$ 实现两个优化器：\n- 基线优化器：如上定义的带梯度裁剪的经典动量更新。\n- 校正优化器：与基线优化器相同，但根据您提出的校正缩放，将 $\\mu$ 替换为依赖于 $\\gamma_t$ 的时变 $\\mu_t$。\n\n从相同的初始值 $x_0$ 和 $v_0=0$ 开始，对两个优化器运行固定的步数 $T$。通过计算在最后 $W$ 步的窗口内轨迹 $x_t$ 的符号变化次数来量化欠阻尼；即，满足 $x_t x_{t+1}  0$ 的索引 $t \\in \\{T-W, \\dots, T-1\\}$ 的数量。对于每个测试用例，返回一个布尔值，指示校正优化器是否比基线优化器减少了欠阻尼度量，即校正后的计数是否严格小于基线计数。\n\n使用以下参数集测试套件，该套件旨在覆盖标准情况、边界条件和边缘情况：\n1. $a_{\\mathrm{hi}} = 20.0$, $a_{\\mathrm{lo}} = 5.0$, $r = 0.5$, $x_0 = 12.0$, $\\eta = 0.08$, $\\mu = 0.95$, $c = 1.0$, $T = 600$, $W = 200$.\n2. $a_{\\mathrm{hi}} = 20.0$, $a_{\\mathrm{lo}} = 5.0$, $r = 0.5$, $x_0 = 12.0$, $\\eta = 0.08$, $\\mu = 0.95$, $c = 10^9$, $T = 600$, $W = 200$.\n3. $a_{\\mathrm{hi}} = 20.0$, $a_{\\mathrm{lo}} = 5.0$, $r = 0.5$, $x_0 = 12.0$, $\\eta = 0.08$, $\\mu = 0.0$, $c = 1.0$, $T = 600$, $W = 200$.\n4. $a_{\\mathrm{hi}} = 30.0$, $a_{\\mathrm{lo}} = 6.0$, $r = 0.4$, $x_0 = 20.0$, $\\eta = 0.05$, $\\mu = 0.98$, $c = 0.1$, $T = 800$, $W = 300$.\n5. $a_{\\mathrm{hi}} = 25.0$, $a_{\\mathrm{lo}} = 4.0$, $r = 0.6$, $x_0 = 10.0$, $\\eta = 0.01$, $\\mu = 0.9$, $c = 0.5$, $T = 800$, $W = 400$.\n\n最终输出格式：您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的布尔值列表（例如，“[True,False,True,False,True]”）。不应打印任何其他文本。",
            "solution": "该问题被评估为有效。它在科学上基于数值优化理论，问题定义良好、客观，并包含了求解所需的所有必要信息。\n\n### 任务1：推导与分析\n\n优化过程由关于位置 $x_t$ 和速度 $v_t$ 的两个耦合一阶差分方程组描述。更新规则如下：\n$$\nv_t = \\mu v_{t-1} + g_t^{\\mathrm{clip}} \\quad (1)\n$$\n$$\nx_{t+1} = x_t - \\eta v_t \\quad (2)\n$$\n其中 $g_t^{\\mathrm{clip}}$ 是损失函数 $L(x)$ 在 $x_t$ 处的裁剪梯度，$\\eta  0$ 是步长，$\\mu \\in [0,1)$ 是动量系数。\n\n在未裁剪区域，即 $|g_t| \\le c$ 时，我们有 $g_t^{\\mathrm{clip}} = g_t$。问题要求通过设置 $g_t = a x_t$（对于某个固定的正常数曲率 $a$）将此区域作为线性递归进行分析。将此代入方程 $(1)$ 得到：\n$$\nv_t = \\mu v_{t-1} + a x_t\n$$\n为了推导关于 $x_t$ 的单个二阶差分方程，我们用序列 $x_t$ 来表示 $v_t$ 和 $v_{t-1}$。从方程 $(2)$，我们有：\n$$\nv_t = \\frac{1}{\\eta} (x_t - x_{t+1})\n$$\n并将索引后移一位：\n$$\nv_{t-1} = \\frac{1}{\\eta} (x_{t-1} - x_t)\n$$\n将 $v_t$ 和 $v_{t-1}$ 的这些表达式代入速度更新方程，得到：\n$$\n\\frac{1}{\\eta} (x_t - x_{t+1}) = \\mu \\left( \\frac{1}{\\eta} (x_{t-1} - x_t) \\right) + a x_t\n$$\n乘以 $\\eta$ 并重新排列各项以求解 $x_{t+1}$：\n$$\nx_t - x_{t+1} = \\mu (x_{t-1} - x_t) + \\eta a x_t\n$$\n$$\nx_{t+1} = x_t - \\mu x_{t-1} + \\mu x_t - \\eta a x_t\n$$\n$$\nx_{t+1} = (1 + \\mu - \\eta a) x_t - \\mu x_{t-1}\n$$\n这可以写成齐次线性差分方程的标准形式：\n$$\nx_{t+1} - (1 + \\mu - \\eta a) x_t + \\mu x_{t-1} = 0\n$$\n解 $x_t$ 的行为由特征多项式的根决定。假设解的形式为 $x_t \\propto R^t$，我们将其代入方程，得到关于 $R$ 的特征多项式（在问题陈述中用 $r$ 表示，但我们用 $R$ 以避免与半径参数混淆）：\n$$\np(R) = R^2 - (1 + \\mu - \\eta a) R + \\mu = 0\n$$\n这与问题中指定的多项式相匹配。这个二次方程的根决定了系统的动力学。当根是一对共轭复数时，系统表现出以振荡为特征的欠阻尼行为。这种情况发生当且仅当判别式 $\\Delta$ 为负：\n$$\n\\Delta = (1 + \\mu - \\eta a)^2 - 4\\mu  0\n$$\n这是线性、未裁剪区域中发生振荡的条件。\n\n现在，我们分析梯度裁剪的影响。当梯度的模 $|g_t| = |a x_t|$ 超过裁剪阈值 $c$ 时，更新变为非线性。裁剪后的梯度为 $g_t^{\\mathrm{clip}} = c \\cdot \\operatorname{sign}(g_t)$。速度更新为：\n$$\nv_t = \\mu v_{t-1} + c \\cdot \\operatorname{sign}(g_t)\n$$\n在此区域，添加到速度中的校正项的模是恒定的，无论 $|x_t|$（以及 $|g_t|$）变得多大。从状态 $x_t$到速度变化的反馈实际上是饱和的。系统表现得像一个积分器，从一个模恒定的力中累积速度。如果优化器在此裁剪区域停留多个步骤，$v_t$ 的模可能会增长得很大。\n\n当轨迹最终进入原点附近的高曲率区域（$|x| \\le r$）时，曲率从 $a_{\\mathrm{lo}}$跃升至 $a_{\\mathrm{hi}}$。同时，随着 $|x_t|$ 变小，未裁剪的梯度 $|g_t| = |a_{\\mathrm{hi}} x_t|$ 可能会降到阈值 $c$ 以下，导致裁剪停止。此时，两种现象结合在一起引发问题：\n1. 在裁剪阶段累积的大速度 $v_t$ 被“注入”到中心区域。\n2. 中心区域本身通常被配置为欠阻尼（即，对于 $a=a_{\\mathrm{hi}}$，$\\Delta  0$），意味着它本质上是振荡的。\n\n大初速度和欠阻尼系统的组合导致在最小值 $x=0$ 处出现显著的超调。这个大的超调将 $x_t$ 推到损失函数景观的远端另一侧，很可能重新进入裁剪区域。这个循环可以重复，导致大幅持续的振荡，这是一种轨迹上的系统性欠阻尼。\n\n### 任务2：场景设计与校正提议\n\n一个容易出现这种病态行为的场景是：\n- 初始位置 $x_0$ 很大，确保动力学从低曲率区域（$|x_0|  r$）开始，其中 $|g_0| = |a_{\\mathrm{lo}}x_0|$ 很大。\n- 裁剪阈值 $c$ 相对于初始梯度 $|g_0|$ 较小，确保从一开始就激活裁剪。\n- 动量系数 $\\mu$ 很高（接近 1），促进了速度随时间的显著累积。\n- 高曲率区域（$|x| \\le r$）是强欠阻尼的，即 $(1+\\mu-\\eta a_{\\mathrm{hi}})^2 - 4\\mu  0$。这会放大任何进入该区域的大速度的影响。\n\n核心问题在于完整梯度模（它为我们关于动量的直觉提供信息）与更新中使用的裁剪梯度模之间的不匹配。在裁剪期间，动量的累积就像是对一个强大、持续的力作出响应，而位置更新则基于一个较小的、有上限的力。这导致了上述的“积分饱和”效应。\n\n为了解决这个问题，我们提出一种校正缩放方案，根据裁剪的严重程度来调节动量系数 $\\mu$。所提议的调整使动量结转 $\\mu_t$ 依赖于瞬时裁剪因子 $\\gamma_t$：\n$$\n\\gamma_t = \\frac{|g_t^{\\mathrm{clip}}|}{|g_t| + \\varepsilon}\n$$\n其中 $\\varepsilon  0$ 是一个用于数值稳定的小常数。当没有裁剪时（$|g_t| \\approx |g_t^{\\mathrm{clip}}|$），因子 $\\gamma_t$ 接近 1；当梯度被严重裁剪时（$|g_t| \\gg |g_t^{\\mathrm{clip}}| = c$），它趋近于 0。\n\n我们的提议是定义一个时变动量系数 $\\mu_t$ 为：\n$$\n\\mu_t = \\mu \\cdot \\gamma_t\n$$\n校正后的速度更新变为：\n$$\nv_t = (\\mu \\cdot \\gamma_t) v_{t-1} + g_t^{\\mathrm{clip}}\n$$\n这种校正具有期望的特性：\n- **无裁剪（$\\gamma_t \\approx 1$）：** 更新变为 $v_t \\approx \\mu v_{t-1} + g_t$，恢复到标准的动量动力学。\n- **严重裁剪（$\\gamma_t \\ll 1$）：** 动量结转项 $(\\mu \\cdot \\gamma_t) v_{t-1}$ 被强烈衰减。更新近似于 $v_t \\approx g_t^{\\mathrm{clip}}$，这类似于简单的（裁剪）梯度下降。这恰好在因裁剪而失去来自 $x_t$ 的反馈时，防止了速度的过度累积（积分饱和）。\n\n这种基于局部可用信息的动量项动态调整，应能在优化器在裁剪和非裁剪区域之间转换时，减轻超调并减少由此产生的振荡。\n\n### 任务3：实现\n\n实现和测试涉及两个优化器。基线优化器使用固定的 $\\mu$ 和标准的裁剪动量更新。校正优化器将 $\\mu$ 替换为提议的时变 $\\mu_t = \\mu \\gamma_t$。两者都在一套测试用例上运行，其性能通过计算轨迹 $x_t$ 在最后 $W$ 步中的符号变化次数来衡量。一个布尔结果指示校正优化器是否严格减少了此计数。最终答案中的 Python 代码实现了此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef grad_L(x: float, a_hi: float, a_lo: float, r: float) -> float:\n    \"\"\"Computes the gradient of the piecewise quadratic function L(x).\"\"\"\n    if np.abs(x) = r:\n        return a_hi * x\n    else:\n        return a_lo * x\n\ndef run_optimizer(params: tuple, corrected: bool) -> int:\n    \"\"\"\n    Runs an optimizer on the given problem and returns the number of sign changes.\n\n    Args:\n        params: A tuple containing (a_hi, a_lo, r, x0, eta, mu, c, T, W).\n        corrected: A boolean indicating whether to use the corrected momentum update.\n\n    Returns:\n        The number of sign changes in the trajectory's final W steps.\n    \"\"\"\n    a_hi, a_lo, r, x0, eta, mu, c, T, W = params\n    \n    x_traj = np.zeros(T + 1)\n    x_traj[0] = x0\n    \n    # v_prev corresponds to v_{t-1} in the update rule for v_t.\n    # Initialize v_{-1} = 0, consistent with v_0 = g_0^clip.\n    v_prev = 0.0\n    x_curr = x0\n    \n    # Epsilon for numerical stability in gamma_t calculation.\n    epsilon = 1e-8\n\n    # Main optimization loop\n    for t in range(T):\n        # Calculate gradient and clip it\n        g_t = grad_L(x_curr, a_hi, a_lo, r)\n        g_t_abs = np.abs(g_t)\n        g_t_clip = np.sign(g_t) * np.minimum(g_t_abs, c)\n        \n        current_mu = mu\n        if corrected:\n            gamma_t = np.abs(g_t_clip) / (g_t_abs + epsilon)\n            current_mu = mu * gamma_t\n            \n        # Update velocity and position based on the problem statement's equations:\n        # v_t = mu * v_{t-1} + g_t^clip\n        # x_{t+1} = x_t - eta * v_t\n        v_curr = current_mu * v_prev + g_t_clip\n        x_next = x_curr - eta * v_curr\n        \n        # Store trajectory and update states for the next iteration\n        x_traj[t + 1] = x_next\n        x_curr = x_next\n        v_prev = v_curr\n        \n    # Count sign changes in the final window of W steps.\n    # The window covers pairs (x_t, x_{t+1}) for t in [T-W, T-1].\n    sign_changes = 0\n    for i in range(T - W, T):\n        if x_traj[i] * x_traj[i + 1]  0:\n            sign_changes += 1\n            \n    return sign_changes\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test suite and prints the results.\n    \"\"\"\n    test_cases = [\n        # a_hi, a_lo, r, x0, eta, mu, c, T, W\n        (20.0, 5.0, 0.5, 12.0, 0.08, 0.95, 1.0, 600, 200),\n        (20.0, 5.0, 0.5, 12.0, 0.08, 0.95, 1e9, 600, 200),\n        (20.0, 5.0, 0.5, 12.0, 0.08, 0.0, 1.0, 600, 200),\n        (30.0, 6.0, 0.4, 20.0, 0.05, 0.98, 0.1, 800, 300),\n        (25.0, 4.0, 0.6, 10.0, 0.01, 0.9, 0.5, 800, 400),\n    ]\n\n    results = []\n    for case in test_cases:\n        baseline_count = run_optimizer(case, corrected=False)\n        corrected_count = run_optimizer(case, corrected=True)\n        # Append True if the corrected optimizer strictly reduces underdamping\n        results.append(corrected_count  baseline_count)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}