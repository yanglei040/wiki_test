{
    "hands_on_practices": [
        {
            "introduction": "We begin our exploration of Multilayer Perceptron (MLP) architecture by examining its most fundamental building block: the Rectified Linear Unit (ReLU). This exercise challenges you to think constructively about how complex, non-linear functions can be assembled from these simple piecewise-linear components. By building the absolute value function, $f(x)=|x|$, from scratch, you will gain a concrete intuition for the expressive power of even a very small ReLU network .",
            "id": "3151215",
            "problem": "Consider a one-dimensional, two-layer feedforward network with Rectified Linear Unit (ReLU) activation, where Rectified Linear Unit (ReLU) is defined by $\\sigma(u)=\\max\\{0,u\\}$. The network has $m$ hidden neurons and computes\n$$f(x)=w_{2}^{\\top}\\sigma(W_{1}x+b_{1})+b_{2},$$\nfor input $x\\in\\mathbb{R}$, weight matrix $W_{1}\\in\\mathbb{R}^{m\\times 1}$, bias vector $b_{1}\\in\\mathbb{R}^{m}$, output weights $w_{2}\\in\\mathbb{R}^{m}$, and scalar output bias $b_{2}\\in\\mathbb{R}$. Let the target function be $f^{\\star}(x)=|x|$.\n\nUsing only the core definitions of a feedforward architecture and the Rectified Linear Unit (ReLU), do the following:\n- Construct explicit weights and biases $(W_{1},b_{1},w_{2},b_{2})$ that produce a uniform approximation of $f^{\\star}(x)$ over all $x\\in\\mathbb{R}$ with worst-case error at most $\\epsilon$, for an arbitrary tolerance $\\epsilon>0$.\n- Determine the minimal number of hidden neurons $m$ required to achieve this uniform error guarantee as a function of $\\epsilon$.\n\nYour final answer must be a single closed-form expression for $m$ as a function of $\\epsilon$. No rounding is required and no units are needed.",
            "solution": "The problem is first validated to ensure it is well-posed, scientifically grounded, and unambiguous.\n\n### Step 1: Extract Givens\n- Network architecture: A two-layer feedforward network computing $f(x)=w_{2}^{\\top}\\sigma(W_{1}x+b_{1})+b_{2}$.\n- Input domain: $x \\in \\mathbb{R}$.\n- Activation function: Rectified Linear Unit (ReLU), $\\sigma(u)=\\max\\{0,u\\}$.\n- Network parameters: $W_{1}\\in\\mathbb{R}^{m\\times 1}$ (first-layer weights), $b_{1}\\in\\mathbb{R}^{m}$ (first-layer biases), $w_{2}\\in\\mathbb{R}^{m}$ (second-layer weights), and $b_{2}\\in\\mathbb{R}$ (second-layer bias). $m$ is the number of hidden neurons.\n- Target function: $f^{\\star}(x)=|x|$.\n- Approximation requirement: A uniform approximation over $\\mathbb{R}$ such that the worst-case error is bounded by $\\epsilon$. That is, $\\sup_{x\\in\\mathbb{R}} |f(x) - f^{\\star}(x)| \\le \\epsilon$ for an arbitrary tolerance $\\epsilon>0$.\n- Objective 1: Construct the parameters $(W_{1},b_{1},w_{2},b_{2})$ that satisfy the approximation requirement.\n- Objective 2: Determine the minimal number of hidden neurons, $m$, required to meet this guarantee, expressed as a function of $\\epsilon$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is well-defined and scientifically sound. It resides within the standard framework of approximation theory using neural networks. The target function $f^{\\star}(x)=|x|$ is continuous, and the universal approximation theorem guarantees that a two-layer network can approximate it. This problem asks for a specific construction and an analysis of the minimal network size. The problem is self-contained and objective. Although the phrasing \"as a function of $\\epsilon$\" might suggest a non-constant relationship, a constant function is a valid answer. The problem is not flawed; its structure tests the understanding of the exact representational capacity of ReLU networks for certain functions. The problem is deemed **valid**.\n\n### Step 3: Derivation of the Solution\nThe solution proceeds in two parts: first, we determine the minimal number of neurons required, and second, we provide an explicit construction.\n\nLet us analyze the number of neurons $m$ required. We start by investigating if $m=1$ is sufficient.\nFor $m=1$, the network parameters are scalars. Let $W_1 = a \\in \\mathbb{R}$, $b_1 = d \\in \\mathbb{R}$, $w_2 = c \\in \\mathbb{R}$, and $b_2 = e \\in \\mathbb{R}$. The network function is:\n$$f(x) = c \\cdot \\sigma(ax+d) + e = c \\cdot \\max\\{0, ax+d\\} + e$$\nWe must satisfy $|f(x) - |x|| \\le \\epsilon$ for all $x \\in \\mathbb{R}$.\n\nConsider the asymptotic behavior of $f(x)$ and $|x|$.\n- If $a=0$, $f(x) = c \\cdot \\max\\{0,d\\} + e$, which is a constant. The error $|f(x) - |x||$ becomes unbounded as $|x| \\to \\infty$. So, we must have $a \\ne 0$.\n- If $a > 0$:\n  - For large positive $x$, $ax+d > 0$, so $f(x) = c(ax+d)+e = (ac)x + (cd+e)$. To ensure the error $|f(x) - x|$ is bounded as $x \\to \\infty$, the linear terms must cancel. This requires $ac=1$.\n  - For large negative $x$ (i.e., $x \\to -\\infty$), $ax+d < 0$, so $f(x) = e$. The error is $|f(x) - |x|| = |e - (-x)| = |e+x|$. This error is unbounded as $x \\to -\\infty$.\n- If $a < 0$:\n  - For large negative $x$, $ax+d > 0$, so $f(x) = c(ax+d)+e = (ac)x + (cd+e)$. To ensure the error $|f(x) - (-x)|$ is bounded as $x \\to -\\infty$, we must have $ac=-1$.\n  - For large positive $x$ (i.e., $x \\to \\infty$), $ax+d < 0$, so $f(x) = e$. The error is $|f(x) - |x|| = |e - x|$. This error is unbounded as $x \\to \\infty$.\n\nIn all cases for $m=1$, it is impossible to maintain a bounded error over the entire domain $\\mathbb{R}$. Therefore, a single hidden neuron is insufficient, so we must have $m > 1$.\n\nNow, let us investigate the case $m=2$. We will attempt to construct $f(x)$ to exactly represent $f^{\\star}(x)=|x|$. Consider the identity:\n$$|x| = \\max\\{0, x\\} + \\max\\{0, -x\\}$$\nThis expresses $|x|$ as a sum of two functions, each of which has the form of a ReLU activation. We can implement this with a two-neuron network.\nThe network output is $f(x) = w_{2,1}\\sigma(W_{1,1}x+b_{1,1}) + w_{2,2}\\sigma(W_{1,2}x+b_{1,2}) + b_2$.\n\nTo realize the identity $|x| = \\sigma(x) + \\sigma(-x)$, we can choose the parameters as follows:\n- For the first neuron, we want to compute $\\sigma(x)$. We set its corresponding weights and bias to be $W_{1,1}=1$ and $b_{1,1}=0$.\n- For the second neuron, we want to compute $\\sigma(-x)$. We set its weights and bias to be $W_{1,2}=-1$ and $b_{1,2}=0$.\n- The output layer must sum these two results. We set the output weights to be $w_{2,1}=1$ and $w_{2,2}=1$.\n- There is no overall offset, so we set the output bias $b_2=0$.\n\nIn matrix/vector form, these parameters are:\n- $W_{1} = \\begin{pmatrix} 1 \\\\ -1 \\end{pmatrix} \\in \\mathbb{R}^{2\\times 1}$\n- $b_{1} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix} \\in \\mathbb{R}^{2}$\n- $w_{2} = \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix} \\in \\mathbb{R}^{2}$\n- $b_{2} = 0 \\in \\mathbb{R}$\n\nWith these parameters, the network function is:\n$$f(x) = \\begin{pmatrix} 1 & 1 \\end{pmatrix} \\sigma\\left(\\begin{pmatrix} 1 \\\\ -1 \\end{pmatrix}x + \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}\\right) + 0$$\n$$f(x) = \\begin{pmatrix} 1 & 1 \\end{pmatrix} \\begin{pmatrix} \\sigma(x) \\\\ \\sigma(-x) \\end{pmatrix} = \\sigma(x) + \\sigma(-x)$$\n$$f(x) = \\max\\{0, x\\} + \\max\\{0, -x\\}$$\nWe verify that this equals $|x|$:\n- If $x \\ge 0$, $f(x) = x + 0 = x = |x|$.\n- If $x < 0$, $f(x) = 0 + (-x) = -x = |x|$.\nThis construction provides an exact representation of $f^{\\star}(x) = |x|$.\n\nThe approximation error is $|f(x) - f^{\\star}(x)| = ||x| - |x|| = 0$.\nThe problem requires the error to be at most $\\epsilon$ for any $\\epsilon > 0$. Since our construction achieves an error of $0$, and $0 \\le \\epsilon$ for any $\\epsilon > 0$, this construction is a valid solution for any tolerance.\n\nWe have shown that $m=1$ is insufficient and $m=2$ is sufficient (achieving zero error). Therefore, the minimal number of hidden neurons required is $m=2$. This result holds for any choice of $\\epsilon > 0$. The minimal number of neurons $m$ is thus a constant function of $\\epsilon$:\n$$m(\\epsilon) = 2$$",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "While ReLU is a powerful activation function, the architectural design space is vast, and other choices can offer different advantages. This practice introduces the Maxout activation unit and formalizes the concept of a network's expressive power by analyzing its \"linear regions.\" By directly comparing the capabilities of a single ReLU unit versus a Maxout unit, you will develop a more quantitative understanding of how specific architectural decisions influence a model's capacity to represent complex functions .",
            "id": "3155524",
            "problem": "You are given two single-hidden-unit feedforward models over a one-dimensional input, each producing a scalar output. The hidden operation is either the Rectified Linear Unit (ReLU) or the Maxout. Both models are piecewise-linear functions of the input. A linear region is defined as a maximal connected interval of the input domain on which the model’s output equals a single affine function.\n\nFundamental definitions to use:\n- A ReLU activation is defined by $h(x) = \\max\\{0, z(x)\\}$ with preactivation $z(x) = w x + b$. For a single hidden ReLU unit and a scalar output layer, the model takes the form $y(x) = a \\cdot \\max\\{0, w x + b\\} + c$.\n- A Maxout unit with $k$ affine components is defined by $h(x) = \\max_{j \\in \\{1,\\dots,k\\}} \\{\\ell_j(x)\\}$ where $\\ell_j(x) = w_j x + b_j$. For a single hidden Maxout unit and a scalar output layer with unit scaling, the model takes the form $y(x) = \\max_{j \\in \\{1,\\dots,k\\}} \\{w_j x + b_j\\} + c$. In this problem, use $c = 0$ unless otherwise specified.\n- For a one-dimensional piecewise-linear function, the linear regions on a closed interval $[L, R]$ are determined by the set of breakpoints where the active affine form can change:\n  - For ReLU, the only potential breakpoint is the root $x^\\star$ of $w x + b = 0$ when it lies in $(L, R)$ and when $w \\neq 0$.\n  - For Maxout, the potential breakpoints are the pairwise equality points $x_{p,q}$ where $\\ell_p(x) = \\ell_q(x)$ for $p \\neq q$ with $w_p \\neq w_q$, i.e., $x_{p,q} = \\dfrac{b_q - b_p}{w_p - w_q}$, when $x_{p,q} \\in (L, R)$. Parallel lines with $w_p = w_q$ do not induce breakpoints unless they are identical everywhere, in which case they do not change the maximum.\n\nTasks:\n1) For each test case below, compute the exact number of linear regions of $y(x)$ on the specified domain for the ReLU model and for the Maxout model, by enumerating all candidate breakpoints from the definitions above, sorting those that lie in the open interval, and counting the number of maximal intervals on which the same affine form is active. If two consecutive subintervals share the same active affine form, they must be merged into a single linear region.\n\n2) Construct an input arrangement that benefits from Maxout aggregation. Use the following dataset $D$ of inputs:\n   $[-2.0, -1.5, -1.0, -0.25, 0.0, 0.25, 0.75, 1.0, 1.5]$.\n   Define the target function $t(x)$ as the output of a single Maxout unit with $k = 3$ affine components:\n   $\\ell_1(x) = -1 \\cdot x + (-0.5)$,\n   $\\ell_2(x) = 0.2 \\cdot x + 0.1$,\n   $\\ell_3(x) = 1.5 \\cdot x + (-0.2)$,\n   and output $t(x) = \\max\\{\\ell_1(x), \\ell_2(x), \\ell_3(x)\\}$.\n   Evaluate the mean squared error (MSE) on $D$ for:\n   - The ReLU model $y_{\\text{ReLU}}(x) = \\max\\{0, 1 \\cdot x + 0\\}$.\n   - The Maxout model $y_{\\text{Maxout}}(x) = \\max\\{\\ell_1(x), \\ell_2(x), \\ell_3(x)\\}$.\n   Report both MSE values, rounded to $6$ decimal places.\n\nTest suite:\n- Case A (happy path):\n  - Domain: $[L, R] = [-2, 2]$.\n  - ReLU parameters: $a = 1$, $w = 1$, $b = 0$, $c = 0$.\n  - Maxout parameters: $k = 3$ with $(w_1, b_1) = (-1, -0.5)$, $(w_2, b_2) = (0.2, 0.1)$, $(w_3, b_3) = (1.5, -0.2)$, and $c = 0$.\n- Case B (redundant Maxout pieces):\n  - Domain: $[L, R] = [-1, 1]$.\n  - ReLU parameters: $a = 2$, $w = 1$, $b = 0$, $c = 0$.\n  - Maxout parameters: $k = 3$ with $(w_1, b_1) = (1, 0)$, $(w_2, b_2) = (1, -0.001)$, $(w_3, b_3) = (1, -0.002)$, and $c = 0$.\n- Case C (ReLU breakpoint outside domain):\n  - Domain: $[L, R] = [-1, 1]$.\n  - ReLU parameters: $a = 1$, $w = 1$, $b = -10$, $c = 0$.\n  - Maxout parameters: $k = 2$ with $(w_1, b_1) = (-0.5, 0)$, $(w_2, b_2) = (0.5, 0)$, and $c = 0$.\n\nYour program should output a single line in the exact format:\n\"[rA_relu,rA_maxout,rB_relu,rB_maxout,rC_relu,rC_maxout,mse_relu_on_D,mse_maxout_on_D]\"\nwhere $r\\cdot$ are integers and the two MSE values are decimal numbers rounded to $6$ decimal places. No extra text should be printed.\n\nAll angles are purely algebraic; there are no physical units involved. Percentages are not used; any fractional quantity that appears must be given as a decimal number. The final answers must be purely numerical in the required format.",
            "solution": "The problem has been analyzed and validated as being scientifically sound, well-posed, and internally consistent. It presents a clear and formalizable task within the domain of deep learning, specifically concerning the architectural properties of single-unit MLP models. All necessary parameters and definitions are provided.\n\nThe solution is divided into two parts as per the problem statement: first, the computation of the number of linear regions for ReLU and Maxout models under different parameterizations, and second, the calculation of Mean Squared Error (MSE) for these models against a specified target function.\n\n### Part 1: Computation of the Number of Linear regions\n\nA linear region of a piecewise-linear function $y(x)$ is a maximal connected interval of the input domain on which $y(x)$ is defined by a single affine function. The number of such regions on a closed interval $[L, R]$ is determined by the number of \"true\" breakpoints within the open interval $(L, R)$. A candidate breakpoint is a point where the active affine form *can* change. A true breakpoint is a point where it *does* change. The number of linear regions is one more than the number of true breakpoints in $(L, R)$.\n\nThe procedure is as follows:\n1.  Identify all candidate breakpoints for the given model.\n2.  Filter these to retain only those lying in the open interval $(L, R)$.\n3.  For Maxout units, a candidate breakpoint may be \"undercut\" if another affine component is larger at that point. These must be filtered out to find the true breakpoints.\n4.  The number of regions is $1 + (\\text{number of unique, true breakpoints in } (L, R))$.\n\n**Case A: Domain $[L, R] = [-2, 2]$**\n\n**ReLU Model:**\nThe model is $y(x) = a \\cdot \\max\\{0, w x + b\\} + c$. With parameters $a=1, w=1, b=0, c=0$, we have:\n$$y_{\\text{ReLU}}(x) = \\max\\{0, x\\}$$\nThe preactivation is $z(x) = w x + b = x$. The only candidate breakpoint is at $z(x) = 0$, which gives $x^\\star = 0$.\nSince $x^\\star = 0 \\in (-2, 2)$, this is a true breakpoint. It divides the domain into two intervals: $[-2, 0]$ and $[0, 2]$.\n- For $x \\in [-2, 0]$, $y_{\\text{ReLU}}(x) = 0$.\n- For $x \\in [0, 2]$, $y_{\\text{ReLU}}(x) = x$.\nThese are distinct affine functions. Thus, there are **$2$** linear regions.\n\n**Maxout Model:**\nThe model is $y(x) = \\max_{j=1,2,3}\\{\\ell_j(x)\\}$, with $\\ell_1(x) = -x - 0.5$, $\\ell_2(x) = 0.2x + 0.1$, and $\\ell_3(x) = 1.5x - 0.2$.\nWe find candidate breakpoints by solving for pairwise intersections $\\ell_p(x) = \\ell_q(x)$:\n1.  $\\ell_1(x) = \\ell_2(x) \\implies -x - 0.5 = 0.2x + 0.1 \\implies 1.2x = -0.6 \\implies x_{1,2} = -0.5$.\n2.  $\\ell_1(x) = \\ell_3(x) \\implies -x - 0.5 = 1.5x - 0.2 \\implies 2.5x = -0.3 \\implies x_{1,3} = -0.12$.\n3.  $\\ell_2(x) = \\ell_3(x) \\implies 0.2x + 0.1 = 1.5x - 0.2 \\implies 1.3x = 0.3 \\implies x_{2,3} = \\frac{3}{13} \\approx 0.23077$.\n\nAll three candidate breakpoints are within the domain $(-2, 2)$. Now we must check if any are undercut.\n- At $x_{1,2} = -0.5$, $\\ell_1(-0.5) = \\ell_2(-0.5) = 0$. The value of the third component is $\\ell_3(-0.5) = 1.5(-0.5) - 0.2 = -0.95$. Since $-0.95 < 0$, this breakpoint is on the upper envelope. It is a true breakpoint.\n- At $x_{1,3} = -0.12$, $\\ell_1(-0.12) = \\ell_3(-0.12) = -0.38$. The value of the second component is $\\ell_2(-0.12) = 0.2(-0.12) + 0.1 = 0.076$. Since $0.076 > -0.38$, the intersection of $\\ell_1$ and $\\ell_3$ occurs below $\\ell_2$. This is not a true breakpoint.\n- At $x_{2,3} = 3/13$, $\\ell_2(3/13) = \\ell_3(3/13) \\approx 0.146$. The value of the first component is $\\ell_1(3/13) = -3/13 - 0.5 \\approx -0.73$. Since $-0.73 < 0.146$, this is a true breakpoint.\n\nThe true breakpoints in $(-2, 2)$ are $\\{-0.5, 3/13\\}$. These two points partition the domain into three intervals, each corresponding to a different active affine function ($\\ell_1$, then $\\ell_2$, then $\\ell_3$). Thus, there are **$3$** linear regions.\n\n**Case B: Domain $[L, R] = [-1, 1]$**\n\n**ReLU Model:**\nThe model is $y(x) = 2 \\cdot \\max\\{0, x\\}$. The breakpoint is at $x^\\star = 0$, which is in $(-1, 1)$.\nThis leads to **$2$** linear regions ($y(x) = 0$ for $x \\le 0$ and $y(x) = 2x$ for $x > 0$).\n\n**Maxout Model:**\nThe model is $y(x) = \\max\\{x, x-0.001, x-0.002\\}$.\nThe three affine components $\\ell_1(x) = x$, $\\ell_2(x) = x - 0.001$, and $\\ell_3(x) = x - 0.002$ are parallel lines (all have slope $w=1$). For any value of $x$, it is always true that $x > x - 0.001 > x-0.002$.\nTherefore, $\\ell_1(x)$ is always the maximum.\nThe function simplifies to $y(x) = x$ across the entire domain. This is a single affine function, so there is only **$1$** linear region.\n\n**Case C: Domain $[L, R] = [-1, 1]$**\n\n**ReLU Model:**\nThe model is $y(x) = \\max\\{0, x-10\\}$.\nThe preactivation is $z(x) = x-10$. The candidate breakpoint is at $x-10=0$, which gives $x^\\star=10$.\nSince $x^\\star = 10 \\notin (-1, 1)$, there are no breakpoints within the domain.\nThe function is determined by a single affine form on $[-1, 1]$. To find which one, we test a point, e.g., $x=0$. $z(0)=-10 < 0$, so $y(x)=0$ for the entire domain. Thus, there is **$1$** linear region.\n\n**Maxout Model:**\nThe model is $y(x) = \\max\\{-0.5x, 0.5x\\}$.\nThe breakpoint is at $-0.5x = 0.5x \\implies x=0$.\nSince $x=0 \\in (-1, 1)$, this is a true breakpoint.\n- For $x \\in [-1, 0]$, $-0.5x \\ge 0.5x$, so $y(x)=-0.5x$.\n- For $x \\in [0, 1]$, $0.5x \\ge -0.5x$, so $y(x)=0.5x$.\nThese are distinct forms, so there are **$2$** linear regions.\n\n### Part 2: Mean Squared Error (MSE) Comparison\n\nThe MSE is given by $\\text{MSE} = \\frac{1}{N} \\sum_{i=1}^N (y_i - t_i)^2$.\n- Dataset $D = [-2.0, -1.5, -1.0, -0.25, 0.0, 0.25, 0.75, 1.0, 1.5]$, so $N=9$.\n- Target function $t(x) = \\max\\{-x - 0.5, 0.2x + 0.1, 1.5x - 0.2\\}$.\n- ReLU model $y_{\\text{ReLU}}(x) = \\max\\{0, x\\}$.\n- Maxout model $y_{\\text{Maxout}}(x) = \\max\\{-x - 0.5, 0.2x + 0.1, 1.5x - 0.2\\}$.\n\n**MSE for Maxout model:**\nThe model $y_{\\text{Maxout}}(x)$ is identical to the target function $t(x)$. Therefore, the error $(y_{\\text{Maxout}}(x_i) - t(x_i))$ is $0$ for all $x_i \\in D$. Consequently, the MSE is **$0.0$**.\n\n**MSE for ReLU model:**\nWe compute the target values $t(x_i)$ and model predictions $y_{\\text{ReLU}}(x_i)$ for each $x_i \\in D$.\n- $x = [-2.0, -1.5, -1.0, -0.25, 0.0, 0.25, 0.75, 1.0, 1.5]$\n- $t(x) = [1.5, 1.0, 0.5, 0.05, 0.1, 0.175, 0.925, 1.3, 2.05]$\n- $y_{\\text{ReLU}}(x) = [0, 0, 0, 0, 0, 0.25, 0.75, 1.0, 1.5]$\n\nThe squared errors $(y_{\\text{ReLU}}(x_i) - t(x_i))^2$ are:\n- $(0 - 1.5)^2 = 2.25$\n- $(0 - 1.0)^2 = 1.0$\n- $(0 - 0.5)^2 = 0.25$\n- $(0 - 0.05)^2 = 0.0025$\n- $(0 - 0.1)^2 = 0.01$\n- $(0.25 - 0.175)^2 = (0.075)^2 = 0.005625$\n- $(0.75 - 0.925)^2 = (-0.175)^2 = 0.030625$\n- $(1.0 - 1.3)^2 = (-0.3)^2 = 0.09$\n- $(1.5 - 2.05)^2 = (-0.55)^2 = 0.3025$\n\nSum of squared errors:\n$\\sum (y_i - t_i)^2 = 2.25 + 1.0 + 0.25 + 0.0025 + 0.01 + 0.005625 + 0.030625 + 0.09 + 0.3025 = 3.69125$\n\nMean squared error:\n$\\text{MSE}_{\\text{ReLU}} = \\frac{3.69125}{9} \\approx 0.41013888...$\nRounded to $6$ decimal places, the MSE is **$0.410139$**.\n\n### Summary of Results\n- `rA_relu`: $2$\n- `rA_maxout`: $3$\n- `rB_relu`: $2$\n- `rB_maxout`: $1$\n- `rC_relu`: $1$\n- `rC_maxout`: $2$\n- `mse_relu_on_D`: $0.410139$\n- `mse_maxout_on_D`: $0.000000$",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the two-part problem:\n    1. Counts linear regions for ReLU and Maxout models for three test cases.\n    2. Computes the MSE for a specific ReLU and Maxout model on a given dataset.\n    \"\"\"\n\n    def count_regions_relu(w, b, L, R):\n        \"\"\"\n        Counts the number of linear regions for y = a*max(0, w*x + b) + c on [L, R].\n        Note: a and c do not affect the number of regions, only their specific form.\n        \"\"\"\n        if w == 0:\n            # The function is constant, so there is only one linear region.\n            return 1\n        \n        breakpoint = -b / w\n        \n        if L < breakpoint < R:\n            # The breakpoint is inside the domain, creating two regions.\n            return 2\n        else:\n            # The breakpoint is outside the domain, so one region spans [L, R].\n            return 1\n\n    def count_regions_maxout(params, L, R):\n        \"\"\"\n        Counts the number of linear regions for y = max(w_j*x + b_j) on [L, R].\n        \"\"\"\n        k = len(params)\n        if k <= 1:\n            return 1\n            \n        candidate_breakpoints = []\n        for i in range(k):\n            for j in range(i + 1, k):\n                w_i, b_i = params[i]\n                w_j, b_j = params[j]\n                \n                if w_i != w_j:\n                    # Solve w_i*x + b_i = w_j*x + b_j for x\n                    x_intersect = (b_j - b_i) / (w_i - w_j)\n                    if L < x_intersect < R:\n                        candidate_breakpoints.append((x_intersect, i, j))\n        \n        true_breakpoints = set()\n        for bp, p_idx, q_idx in candidate_breakpoints:\n            val_at_bp = params[p_idx][0] * bp + params[p_idx][1]\n            is_undercut = False\n            for r_idx in range(k):\n                if r_idx != p_idx and r_idx != q_idx:\n                    val_r = params[r_idx][0] * bp + params[r_idx][1]\n                    # Use a small tolerance for floating point comparisons\n                    if val_r > val_at_bp + 1e-9:\n                        is_undercut = True\n                        break\n            if not is_undercut:\n                # Round to avoid float precision issues creating duplicate breakpoints\n                true_breakpoints.add(round(bp, 9))\n                \n        return 1 + len(true_breakpoints)\n\n    # --- Task 1: Count Linear Regions for Test Cases ---\n\n    # Case A\n    rA_relu = count_regions_relu(w=1, b=0, L=-2, R=2)\n    maxout_params_A = [(-1, -0.5), (0.2, 0.1), (1.5, -0.2)]\n    rA_maxout = count_regions_maxout(maxout_params_A, L=-2, R=2)\n    \n    # Case B\n    rB_relu = count_regions_relu(w=1, b=0, L=-1, R=1)\n    maxout_params_B = [(1, 0), (1, -0.001), (1, -0.002)]\n    rB_maxout = count_regions_maxout(maxout_params_B, L=-1, R=1)\n\n    # Case C\n    rC_relu = count_regions_relu(w=1, b=-10, L=-1, R=1)\n    maxout_params_C = [(-0.5, 0), (0.5, 0)]\n    rC_maxout = count_regions_maxout(maxout_params_C, L=-1, R=1)\n\n    # --- Task 2: Calculate MSE ---\n\n    D = np.array([-2.0, -1.5, -1.0, -0.25, 0.0, 0.25, 0.75, 1.0, 1.5])\n    \n    # Target function t(x) = max(l1(x), l2(x), l3(x))\n    l1 = lambda x: -1.0 * x - 0.5\n    l2 = lambda x: 0.2 * x + 0.1\n    l3 = lambda x: 1.5 * x - 0.2\n    \n    t_vals = np.maximum.reduce([l1(D), l2(D), l3(D)])\n    \n    # ReLU model y_relu(x) = max(0, 1*x + 0)\n    y_relu_vals = np.maximum(0, D)\n    \n    # Maxout model y_maxout(x) = t(x)\n    y_maxout_vals = t_vals\n    \n    # Calculate MSE\n    mse_relu_on_D = np.mean((y_relu_vals - t_vals)**2)\n    mse_maxout_on_D = np.mean((y_maxout_vals - t_vals)**2)\n\n    results = [\n        rA_relu, rA_maxout,\n        rB_relu, rB_maxout,\n        rC_relu, rC_maxout,\n        round(mse_relu_on_D, 6),\n        round(mse_maxout_on_D, 6)\n    ]\n    \n    # Format the final output string\n    result_str = \",\".join(map(str, results))\n    print(f\"[{result_str}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Having explored the building blocks in a single layer, we now turn to the power of composition, which lies at the heart of \"deep\" learning. This advanced exercise guides you through constructing an MLP to approximate the multiplication function, $f(x,y) = x \\cdot y$, a task not immediately obvious for standard MLPs. In doing so, you will uncover the profound and practical trade-off between a network's depth and its width, providing a concrete example of why deep architectures can be exponentially more efficient than shallow ones for representing certain functions .",
            "id": "3155543",
            "problem": "You are given the task of constructing a Multilayer Perceptron (MLP) that approximates the multiplication function $f(x,y) = x \\cdot y$ over the square domain $[0,1]^2$, using only piecewise linear functions built from the Rectified Linear Unit (ReLU) activation. The desired approximation error is a nonnegative tolerance $\\epsilon$. Your goal is to derive the architecture from first principles and to implement a program that verifies the error and reports the required architectural complexity. The construction must be scientifically sound and derived from fundamental bases: the definition of an MLP, the algebraic identity that reduces $x \\cdot y$ to combinations of univariate functions, and standard error bounds for linear interpolation of twice differentiable functions.\n\nDefinitions to use as the base:\n- A Multilayer Perceptron (MLP) is a function composed of alternating affine transformations and nonlinearities. With Rectified Linear Unit (ReLU) activation, a layer computes $\\sigma(z)$ where $\\sigma(t) = \\max\\{0,t\\}$ and $z$ is an affine transformation of its inputs.\n- A piecewise linear univariate function with breakpoints $\\{c_i\\}$ can be exactly represented by a one-hidden-layer ReLU network as $g(t) = \\alpha_0 + \\alpha_1 t + \\sum_i \\beta_i \\max\\{0, t - c_i\\}$, where the coefficients are determined by the slopes across the segments.\n- The target function is $f(x,y) = x \\cdot y$ on $[0,1]^2$.\n\nTasks:\n1. Derive from first principles how to reduce $f(x,y) = x \\cdot y$ to a composition of univariate functions so that an MLP that exactly computes a piecewise linear approximation to a univariate function can be used to approximate $f(x,y)$. Start from a valid identity for $x \\cdot y$ expressed via univariate functions and then derive the final MLP structure using ReLU units.\n2. Using well-tested facts from numerical analysis, derive a bound on the uniform approximation error when linearly interpolating a twice differentiable function $s(t)$ over an interval $[-R,R]$ with $M$ equal-length segments. Apply this to $s(t) = t^2$ and then propagate the error through your reduction for $x \\cdot y$ to show how to choose $M$ (and thus the width of the MLP’s hidden layer) so that the final approximation error to $x \\cdot y$ is $\\le \\epsilon$ uniformly on $[0,1]^2$.\n3. Analyze the trade-off of depth versus width. Provide two asymptotic constructions:\n   - A shallow-wide network that uses a single hidden layer to exactly compute a piecewise linear approximation to $t^2$ on $[-R,R]$ with $M$ segments (constant depth, width grows with $M$).\n   - A deep-narrow network that obtains the same number of effective linear segments by composition, where the number of linear segments grows exponentially with depth; show that the depth can be $O(\\log M)$ with width bounded by a small constant independent of $M$, assuming a constructive composition scheme using ReLU operations.\n   Use fundamental definitions and logic to justify both constructions without appealing to undocumented shortcuts.\n4. Implementation requirements:\n   - Implement the shallow-wide construction concretely. Build the univariate piecewise linear approximation $S(t)$ to $t^2$ over $[-2,2]$ using $M$ equal segments, represent $S$ exactly as a one-hidden-layer ReLU network with breakpoints at the segment boundaries, and then compute the approximation to $x \\cdot y$ via your reduction using only affine combinations of $S(x)$, $S(y)$, and $S(x+y)$. Your program must compute the uniform approximation error over a grid on $[0,1]^2$ and verify that it is $\\le \\epsilon$.\n   - Compute and report the theoretical width of this shallow-wide network as a function of $\\epsilon$ (use the number of hidden units in the widest hidden layer as the width), and report the theoretical depth of a deep-narrow network sufficient to achieve the same error tolerance using the composition argument (you may assume a fixed width of a small constant for the deep-narrow construction).\n5. Test suite specification:\n   - Use the error tolerances $\\epsilon \\in \\{\\, 10^{-1}, \\, 10^{-2}, \\, 2.5 \\times 10^{-3} \\,\\}$.\n   - For each $\\epsilon$, choose $M$ according to your derived rule and evaluate the shallow-wide network’s maximum absolute error $\\sup_{(x,y) \\in [0,1]^2} | \\hat{f}(x,y) - x y |$ on a uniform Cartesian grid with $x$ and $y$ each sampled at $N$ equally spaced points in $[0,1]$ including endpoints, where $N$ is a positive integer chosen to be sufficiently large to capture the supremum in practice. Include $x=0$, $x=1$, $y=0$, and $y=1$ explicitly.\n   - For each $\\epsilon$, report three quantities: the measured uniform error (a float), the theoretical width of the shallow-wide network (an integer), and the theoretical depth of the deep-narrow network for the same error tolerance (an integer).\n6. Final output format:\n   - Your program should produce a single line of output containing the results for the three test cases as a comma-separated list of lists with each inner list of the form $[\\text{error}, \\text{width}, \\text{depth}]$. That is, print a single string like $[[e_1,w_1,d_1],[e_2,w_2,d_2],[e_3,w_3,d_3]]$ with no extra spaces or text.\n\nAll mathematical entities must appear in LaTeX notation in this problem statement. There are no physical units, no angles, and no percentages involved; report numerical quantities as decimals or integers.",
            "solution": "The problem is subjected to a validation process before a solution is attempted.\n\n### Step 1: Extract Givens\n- **Target Function**: $f(x,y) = x \\cdot y$ on the domain $[0,1]^2$.\n- **Approximation Tolerance**: A nonnegative error tolerance $\\epsilon$.\n- **Activation Function**: Rectified Linear Unit (ReLU), $\\sigma(t) = \\max\\{0,t\\}$.\n- **MLP Definition**: A function composed of alternating affine transformations and nonlinearities.\n- **Piecewise Linear Function Representation**: A univariate piecewise linear function $g(t)$ with breakpoints $\\{c_i\\}$ can be represented as $g(t) = \\alpha_0 + \\alpha_1 t + \\sum_i \\beta_i \\max\\{0, t - c_i\\}$.\n- **Tasks**:\n    1.  Derive a reduction of $f(x,y)$ to univariate functions suitable for MLP approximation.\n    2.  Derive an error bound for the approximation and a rule for choosing the number of linear segments, $M$, as a function of $\\epsilon$.\n    3.  Analyze shallow-wide vs. deep-narrow architectural trade-offs.\n    4.  Implement the shallow-wide construction. Approximate $s(t) = t^2$ over $[-2,2]$ with $M$ segments. Verify the error is $\\le \\epsilon$.\n    5.  Compute results for $\\epsilon \\in \\{10^{-1}, 10^{-2}, 2.5 \\times 10^{-3}\\}$. Report measured error, shallow network width, and deep network depth for each $\\epsilon$.\n    6.  The final output must be a single string of the format `[[e1,w1,d1],[e2,w2,d2],[e3,w3,d3]]`.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is assessed based on the predefined criteria:\n\n-   **Scientifically Grounded**: The problem is based on the well-established mathematical field of approximation theory and its application to neural networks, specifically the universal approximation theorems and constructive proofs for ReLU networks. The use of the polarization identity and standard numerical analysis error bounds is scientifically sound.\n-   **Well-Posed**: The problem is well-posed. It asks for a constructive procedure and an analysis based on a given error tolerance $\\epsilon$, which leads to a determinate set of architectural parameters and a verifiable error measure.\n-   **Objective**: The language is formal and unambiguous. All terms are standard within mathematics and computer science.\n-   **Completeness and Consistency**: The problem provides all necessary definitions and constraints to proceed with a unique line of reasoning. There are no contradictions.\n-   **Realism and Feasibility**: The tasks are mathematically feasible and constitute a standard theoretical exercise in deep learning.\n-   **Structure and Other Criteria**: The problem is well-structured, non-trivial, and verifiable.\n\n### Step 3: Verdict and Action\nThe problem is valid. A complete solution will be provided.\n\n### Principle-Based Solution\n\n#### 1. Reduction of Multiplication to a Univariate Function\nThe core of the task is to approximate the bivariate function $f(x,y) = x \\cdot y$. This can be reduced to the approximation of a univariate function by using the polarization identity. The square of a sum is given by $(x+y)^2 = x^2 + 2xy + y^2$. Rearranging this identity to solve for $x \\cdot y$ yields:\n$$\nx \\cdot y = \\frac{1}{2} \\left( (x+y)^2 - x^2 - y^2 \\right)\n$$\nThis identity demonstrates that multiplication can be expressed using only the univariate squaring function $s(t) = t^2$ and linear combinations. Therefore, if we can construct an MLP that approximates $s(t) = t^2$, we can construct an MLP that approximates $x \\cdot y$.\nLet $S(t)$ be a piecewise linear approximation of $s(t) = t^2$ computed by a ReLU network. The corresponding approximation of $f(x,y)$, which we denote $\\hat{f}(x,y)$, is:\n$$\n\\hat{f}(x,y) = \\frac{1}{2} \\left( S(x+y) - S(x) - S(y) \\right)\n$$\nThe problem domain for $(x,y)$ is $[0,1]^2$. The arguments to the function $S(t)$ will be $x \\in [0,1]$, $y \\in [0,1]$, and $x+y \\in [0,2]$. The implementation requirement specifies approximating $t^2$ over the interval $[-2,2]$, which comfortably contains the required domain $[0,2]$. We will set the approximation range for $s(t)$ to be $[-R, R]$ with $R=2$.\n\n#### 2. Error Analysis and Architectural Sizing\nWe must determine the number of linear segments, $M$, required for the piecewise approximation $S(t)$ to achieve a final error $|\\hat{f}(x,y) - xy| \\le \\epsilon$. The strategy involves bounding the error of $S(t)$ first, and then propagating that error through the reduction identity.\n\nAccording to standard results in numerical analysis, the uniform error for piecewise linear interpolation of a twice-differentiable function $g(t)$ on an interval $[a,b]$ is bounded by $|g(t) - L(t)| \\le \\frac{1}{8}(b-a)^2 \\sup_{t \\in [a,b]} |g''(t)|$.\nWe are creating a piecewise linear function $S(t)$ that interpolates $s(t)=t^2$ over $M$ equal-length segments on the interval $[-R,R] = [-2,2]$. The length of each segment is $h = \\frac{2R}{M} = \\frac{4}{M}$. The error bound for $S(t)$ on any single segment, and thus uniformly over $[-2,2]$, is given by:\n$$\n\\epsilon_S = \\sup_{t \\in [-2,2]} |S(t) - s(t)| \\le \\frac{1}{8}h^2 \\sup_{t \\in [-2,2]} |s''(t)|\n$$\nFor $s(t) = t^2$, the second derivative is $s''(t) = 2$, a constant. The bound becomes:\n$$\n\\epsilon_S \\le \\frac{1}{8} \\left(\\frac{4}{M}\\right)^2 \\cdot 2 = \\frac{1}{8} \\frac{16}{M^2} \\cdot 2 = \\frac{4}{M^2}\n$$\nNow, we propagate this error to the approximation of $x \\cdot y$. The total error is:\n$$\n|\\hat{f}(x,y) - f(x,y)| = \\left| \\frac{1}{2}(S(x+y) - S(x) - S(y)) - \\frac{1}{2}((x+y)^2 - x^2 - y^2) \\right|\n$$\n$$\n= \\frac{1}{2} |(S(x+y) - (x+y)^2) - (S(x) - x^2) - (S(y) - y^2)|\n$$\nBy the triangle inequality:\n$$\n\\le \\frac{1}{2} \\left( |S(x+y) - (x+y)^2| + |S(x) - x^2| + |S(y) - y^2| \\right)\n$$\nSince $x,y,x+y$ are all within the domain $[-2,2]$ where $S(t)$ is defined, each term is bounded by $\\epsilon_S$:\n$$\n|\\hat{f}(x,y) - f(x,y)| \\le \\frac{1}{2}(\\epsilon_S + \\epsilon_S + \\epsilon_S) = \\frac{3}{2}\\epsilon_S\n$$\nSubstituting the bound for $\\epsilon_S$, we get the total error bound:\n$$\n\\epsilon_{xy} \\le \\frac{3}{2} \\left(\\frac{4}{M^2}\\right) = \\frac{6}{M^2}\n$$\nTo ensure the error is within the tolerance $\\epsilon$, we require $\\frac{6}{M^2} \\le \\epsilon$, which implies $M^2 \\ge \\frac{6}{\\epsilon}$. Since $M$ must be an integer, we must choose:\n$$\nM = \\left\\lceil \\sqrt{\\frac{6}{\\epsilon}} \\right\\rceil\n$$\n\n#### 3. Architectural Trade-offs: Shallow-Wide vs. Deep-Narrow Networks\n\n**Shallow-Wide Construction:**\nA piecewise linear function with $M$ segments (and thus $M-1$ breakpoints) can be exactly represented by a single-hidden-layer ReLU network. The function $S(t)$ with breakpoints $\\{c_i\\}_{i=1}^{M-1}$ is given by:\n$$\nS(t) = \\alpha_0 + \\alpha_1 t + \\sum_{i=1}^{M-1} \\beta_i \\max\\{0, t - c_i\\}\n$$\nThis requires $M-1$ ReLU neurons in a hidden layer. To implement $\\hat{f}(x,y)$, we need to compute $S(x)$, $S(y)$, and $S(x+y)$. This can be done in parallel within a single, wider hidden layer. The required hidden units are $\\max\\{0, x-c_i\\}$, $\\max\\{0, y-c_i\\}$, and $\\max\\{0, x+y-c_i\\}$ for all $i=1, \\dots, M-1$. This leads to a total of $3(M-1)$ hidden neurons. The architecture is Input (2 neurons) $\\to$ Hidden Layer ($3(M-1)$ neurons) $\\to$ Output (1 neuron). The width of this shallow network, defined as the size of the widest hidden layer, is:\n$$\nW = 3(M-1) = 3\\left(\\left\\lceil \\sqrt{\\frac{6}{\\epsilon}} \\right\\rceil - 1\\right)\n$$\nThis is a constant-depth (depth 2, i.e., one hidden layer) network whose width grows as $O(1/\\sqrt{\\epsilon})$.\n\n**Deep-Narrow Construction:**\nAlternatively, a deep, narrow network can achieve the same approximation. The key idea is that composing layers of ReLU units can create an exponential increase in the number of linear segments with respect to depth. A simple, constant-width network module can be constructed to effectively double the number of linear segments of its input function. For a function defined on $[0,1]$, a module can map it to a new function with twice the \"frequency\".\nLet a single hidden layer of constant width be able to transform a function with $k$ linear segments into one with $2k$ segments. By composing $d$ such layers, we can generate a function with $2^d k_0$ segments, where $k_0$ is the number of segments at the start. To achieve the required $M$ segments, we need $2^d \\approx M$, which implies $d \\approx \\log_2 M$. The minimum integer number of layers, or depth, required is:\n$$\nD = \\lceil \\log_2 M \\rceil = \\left\\lceil \\log_2 \\left\\lceil \\sqrt{\\frac{6}{\\epsilon}} \\right\\rceil \\right\\rceil\n$$\nThis represents a network of depth $O(\\log(1/\\sqrt{\\epsilon}))$ with a small, constant width.\n\n#### 4. Implementation Details and Test Case Calculations\nFor the implementation of the shallow-wide network, we need the specific coefficients for $S(t)$.\nThe breakpoints are $c_k = -2 + k \\cdot h$ for $k=1, \\dots, M-1$, with $h=4/M$.\nThe slope of $S(t)$ changes at each breakpoint $c_k$. The change in slope is $\\beta_k$. The slope of the segment $[c_{k}, c_{k+1}]$ is $m_k = c_k+c_{k+1}$. The change is $\\beta_k = m_{k+1}-m_k = (c_{k+1}+c_{k+2})-(c_k+c_{k+1}) = c_{k+2}-c_k = 2h = 8/M$. So, $\\beta_k = 8/M$ for all $k$.\nThe slope of the first segment is $\\alpha_1 = m_0 = c_0+c_1 = -2 + (-2+h) = h-4 = 4/M-4$.\nThe value at the start is $S(-2) = s(-2) = (-2)^2 = 4$. Using the formula, $S(-2) = \\alpha_0 + \\alpha_1(-2) = 4$.\nThis gives $\\alpha_0 = 4 + 2\\alpha_1 = 4 + 2(4/M - 4) = 4 + 8/M - 8 = 8/M - 4$.\nThe coefficients for $S(t)$ are:\n- $\\alpha_0 = \\frac{8}{M} - 4$\n- $\\alpha_1 = \\frac{4}{M} - 4$\n- $\\beta_k = \\frac{8}{M}$ for $k=1, \\dots, M-1$.\n\nFor the given test cases, the architectural parameters are:\n1.  **$\\epsilon = 10^{-1}$**:\n    $M = \\lceil \\sqrt{6/0.1} \\rceil = \\lceil \\sqrt{60} \\rceil = 8$.\n    Width $W = 3(8-1) = 21$.\n    Depth $D = \\lceil \\log_2 8 \\rceil = 3$.\n2.  **$\\epsilon = 10^{-2}$**:\n    $M = \\lceil \\sqrt{6/0.01} \\rceil = \\lceil \\sqrt{600} \\rceil = 25$.\n    Width $W = 3(25-1) = 72$.\n    Depth $D = \\lceil \\log_2 25 \\rceil = 5$.\n3.  **$\\epsilon = 2.5 \\times 10^{-3}$**:\n    $M = \\lceil \\sqrt{6/0.0025} \\rceil = \\lceil \\sqrt{2400} \\rceil = 49$.\n    Width $W = 3(49-1) = 144$.\n    Depth $D = \\lceil \\log_2 49 \\rceil = 6$.\n\nThe program in the final answer will implement this logic and verify the error bound.",
            "answer": "```python\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Derives and verifies an MLP architecture for approximating f(x,y)=xy.\n\n    This function implements the shallow-wide network construction derived from\n    first principles. It calculates the required number of linear segments (M) for a\n    given error tolerance epsilon, constructs the piecewise linear approximation\n    S(t) to t^2, and evaluates the uniform approximation error for xy on a\n    fine grid over [0,1]^2. It also reports the theoretical width of this\n    network and the theoretical depth of an equivalent deep-narrow network.\n    \"\"\"\n\n    test_cases = [1e-1, 1e-2, 2.5e-3]\n    results = []\n    \n    # Use a sufficiently large grid for error verification.\n    N_GRID = 201\n\n    def S_approx(t, M):\n        \"\"\"\n        Computes the piecewise linear approximation of s(t) = t^2 on [-2, 2]\n        using M equal-length segments.\n        S(t) = alpha_0 + alpha_1*t + sum(beta_i * max(0, t - c_i))\n        \n        Args:\n            t (np.ndarray): Input values.\n            M (int): Number of linear segments.\n            \n        Returns:\n            np.ndarray: The approximated values s(t).\n        \"\"\"\n        if M == 0:\n            # Should not happen with the formula for M\n            return t**2\n        \n        is_scalar = not isinstance(t, np.ndarray)\n        if is_scalar:\n            t = np.array([t])\n            \n        # Interval [-R, R] with R=2\n        R = 2.0\n        h = 2.0 * R / float(M)\n\n        # Coefficients for the ReLU network representation\n        alpha_0 = (2.0 * h) - (2.0 * R) # Simplified from 8/M - 4\n        alpha_1 = h - (2.0 * R)       # Simplified from 4/M - 4\n        beta = 2.0 * h                # Simplified from 8/M\n\n        # Breakpoints\n        c = -R + np.arange(1, M) * h\n\n        # Reshape for broadcasting\n        t_reshaped = t.reshape(-1, 1)\n        c_reshaped = c.reshape(1, -1)\n        \n        # ReLU activations\n        relu_terms = np.sum(np.maximum(0, t_reshaped - c_reshaped), axis=1)\n        \n        # Final piecewise linear function\n        s_val = alpha_0 + alpha_1 * t + beta * relu_terms.reshape(t.shape)\n\n        if is_scalar:\n            return s_val.item()\n        return s_val\n\n    def f_hat(x, y, M):\n        \"\"\"\n        Approximates f(x,y) = xy using the identity and S_approx.\n        f_hat(x,y) = 0.5 * (S(x+y) - S(x) - S(y))\n        \"\"\"\n        return 0.5 * (S_approx(x + y, M) - S_approx(x, M) - S_approx(y, M))\n\n    for epsilon in test_cases:\n        # 1. Determine M based on the derived formula\n        M = math.ceil(math.sqrt(6.0 / epsilon))\n\n        # 2. Evaluate the uniform error on a grid\n        grid_points = np.linspace(0, 1, N_GRID)\n        X, Y = np.meshgrid(grid_points, grid_points)\n        \n        Z_true = X * Y\n        Z_hat = f_hat(X, Y, M)\n        \n        measured_error = np.max(np.abs(Z_hat - Z_true))\n\n        # 3. Calculate theoretical width of the shallow-wide network\n        # Width = 3 * (M - 1)\n        theoretical_width = 3 * (M - 1)\n\n        # 4. Calculate theoretical depth of the deep-narrow network\n        # Depth = ceil(log2(M))\n        theoretical_depth = math.ceil(math.log2(M)) if M > 0 else 0\n        \n        results.append([measured_error, theoretical_width, theoretical_depth])\n    \n    # Format the final output string exactly as required.\n    # str(list) produces \"[item1, item2, ...]\" so this will create the nested structure\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}