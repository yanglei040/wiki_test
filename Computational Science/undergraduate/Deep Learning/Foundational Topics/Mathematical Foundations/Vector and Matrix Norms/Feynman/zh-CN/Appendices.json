{
    "hands_on_practices": [
        {
            "introduction": "扎实的理解始于动手计算。这项练习旨在帮助你巩固几种最常用矩阵范数的定义：$1$-范数、$\\infty$-范数、$2$-范数以及弗罗贝尼乌斯范数。通过为一个简单的“全一矩阵”计算这些范数，你将直观地看到不同的范数如何为同一个矩阵赋予不同的“大小”度量，并理解每种范数捕捉了矩阵变换特性的不同方面。",
            "id": "2449594",
            "problem": "设 $m,n \\in \\mathbb{N}$ 且 $m \\geq 1, n \\geq 1$。对于一个矩阵 $A \\in \\mathbb{R}^{m \\times n}$ 以及 $p \\in \\{1,2,\\infty\\}$，由向量 $p$-范数诱导的算子范数定义为\n$$\n\\|A\\|_{p} = \\sup_{x \\neq 0} \\frac{\\|A x\\|_{p}}{\\|x\\|_{p}},\n$$\n其中，对于 $x \\in \\mathbb{R}^{k}$，向量范数分别为 $\\|x\\|_{1} = \\sum_{i=1}^{k} |x_{i}|$，$\\|x\\|_{2} = \\sqrt{\\sum_{i=1}^{k} |x_{i}|^{2}}$，以及 $\\|x\\|_{\\infty} = \\max_{1 \\leq i \\leq k} |x_{i}|$。矩阵 $A$ 的弗罗贝尼乌斯范数（Frobenius norm）定义为\n$$\n\\|A\\|_{F} = \\sqrt{\\sum_{i=1}^{m} \\sum_{j=1}^{n} |a_{ij}|^{2}}.\n$$\n考虑全 1 矩阵 $J \\in \\mathbb{R}^{m \\times n}$，其元素为 $J_{ij} = 1$ 对所有 $i,j$ 成立。确定 $\\|J\\|_{1}$、$\\|J\\|_{2}$、$\\|J\\|_{\\infty}$ 和 $\\|J\\|_{F}$ 作为 $m$ 和 $n$ 的显式函数。请将您的最终答案以单行向量的形式按顺序 $\\big(\\|J\\|_{1}, \\|J\\|_{2}, \\|J\\|_{\\infty}, \\|J\\|_{F}\\big)$ 给出。答案必须是精确值，请勿近似。",
            "solution": "对问题陈述进行验证。\n\n**第 1 步：提取已知条件**\n- $m, n \\in \\mathbb{N}$ 且 $m \\geq 1, n \\geq 1$。\n- 矩阵 $A \\in \\mathbb{R}^{m \\times n}$。\n- 算子范数：$\\|A\\|_{p} = \\sup_{x \\neq 0} \\frac{\\|A x\\|_{p}}{\\|x\\|_{p}}$，其中 $p \\in \\{1, 2, \\infty\\}$。\n- 对于 $x \\in \\mathbb{R}^{k}$ 的向量范数：\n  - $\\|x\\|_{1} = \\sum_{i=1}^{k} |x_{i}|$\n  - $\\|x\\|_{2} = \\sqrt{\\sum_{i=1}^{k} |x_{i}|^{2}}$\n  - $\\|x\\|_{\\infty} = \\max_{1 \\leq i \\leq k} |x_{i}|$\n- 弗罗贝尼乌斯范数：$\\|A\\|_{F} = \\sqrt{\\sum_{i=1}^{m} \\sum_{j=1}^{n} |a_{ij}|^{2}}$。\n- 所考虑的矩阵是全 1 矩阵 $J \\in \\mathbb{R}^{m \\times n}$，其元素为 $J_{ij} = 1$ 对所有 $i,j$ 成立。\n- 目标是确定 $\\|J\\|_{1}$、$\\|J\\|_{2}$、$\\|J\\|_{\\infty}$ 和 $\\|J\\|_{F}$ 作为 $m$ 和 $n$ 的显式函数。\n- 最终答案要求以行向量的形式给出：$\\big(\\|J\\|_{1}, \\|J\\|_{2}, \\|J\\|_{\\infty}, \\|J\\|_{F}\\big)$。\n\n**第 2 步：使用提取的已知条件进行验证**\n根据所需标准对问题进行评估。\n- **科学依据：** 该问题使用了线性代数和数值分析领域中关于向量和矩阵范数的标准、普遍接受的定义。它在科学上和数学上是合理的。\n- **适定性：** 问题陈述清晰。矩阵 $J$ 被明确定义，待计算的范数也同样明确。对于所要求的四个量，都存在唯一的、有意义的解。\n- **客观性：** 问题以精确的数学语言表述，没有任何主观性或模糊性。\n\n发现该问题没有任何缺陷，如科学上不合理、不完整或矛盾。\n\n**第 3 步：结论和行动**\n该问题是**有效的**。将提供一个完整的、有理有据的解答。\n\n我们继续为全 1 矩阵 $J \\in \\mathbb{R}^{m \\times n}$ 计算四个指定的范数。\n\n**1. 计算 $1$-范数, $\\|J\\|_{1}$**\n矩阵 $A \\in \\mathbb{R}^{m \\times n}$ 的算子 $1$-范数定义为最大绝对列和：\n$$\n\\|A\\|_{1} = \\max_{1 \\leq j \\leq n} \\sum_{i=1}^{m} |a_{ij}|\n$$\n对于矩阵 $J$，所有元素均为 $J_{ij} = 1$。我们计算任意列 $j$ 的绝对值之和：\n$$\n\\sum_{i=1}^{m} |J_{ij}| = \\sum_{i=1}^{m} |1| = \\sum_{i=1}^{m} 1 = m\n$$\n对于每一列 $j$（其中 $1 \\leq j \\leq n$），这个和都是常数。因此，这些相同和的最大值是 $m$。\n$$\n\\|J\\|_{1} = m\n$$\n\n**2. 计算 $\\infty$-范数, $\\|J\\|_{\\infty}$**\n矩阵 $A \\in \\mathbb{R}^{m \\times n}$ 的算子 $\\infty$-范数定义为最大绝对行和：\n$$\n\\|A\\|_{\\infty} = \\max_{1 \\leq i \\leq m} \\sum_{j=1}^{n} |a_{ij}|\n$$\n对于矩阵 $J$，我们计算任意行 $i$ 的绝对值之和：\n$$\n\\sum_{j=1}^{n} |J_{ij}| = \\sum_{j=1}^{n} |1| = \\sum_{j=1}^{n} 1 = n\n$$\n对于每一行 $i$（其中 $1 \\leq i \\leq m$），这个和都是常数。这些相同和的最大值是 $n$。\n$$\n\\|J\\|_{\\infty} = n\n$$\n\n**3. 计算弗罗贝尼乌斯范数, $\\|J\\|_{F}$**\n矩阵 $A \\in \\mathbb{R}^{m \\times n}$ 的弗罗贝尼乌斯范数定义为：\n$$\n\\|A\\|_{F} = \\sqrt{\\sum_{i=1}^{m} \\sum_{j=1}^{n} |a_{ij}|^{2}}\n$$\n对于矩阵 $J$，这变成：\n$$\n\\|J\\|_{F} = \\sqrt{\\sum_{i=1}^{m} \\sum_{j=1}^{n} |1|^{2}} = \\sqrt{\\sum_{i=1}^{m} \\sum_{j=1}^{n} 1}\n$$\n双重求和表示矩阵中元素的总数，即 $mn$。\n$$\n\\|J\\|_{F} = \\sqrt{mn}\n$$\n\n**4. 计算 $2$-范数 (谱范数), $\\|J\\|_{2}$**\n矩阵 $A$ 的算子 $2$-范数是其最大的奇异值 $\\sigma_{\\max}(A)$。这等价于矩阵 $A^T A$ 的最大特征值的平方根。\n$$\n\\|A\\|_{2} = \\sqrt{\\lambda_{\\max}(A^T A)}\n$$\n对于我们的矩阵 $J$，我们首先构造矩阵 $J^T J$。矩阵 $J$ 是一个 $m \\times n$ 的全 1 矩阵，所以其转置 $J^T$ 是一个 $n \\times m$ 的全 1 矩阵。乘积 $J^T J$ 是一个 $n \\times n$ 矩阵。该乘积的第 $(k,l)$ 个元素是：\n$$\n(J^T J)_{kl} = \\sum_{i=1}^{m} (J^T)_{ki} J_{il} = \\sum_{i=1}^{m} J_{ik} J_{il} = \\sum_{i=1}^{m} 1 \\cdot 1 = m\n$$\n因此，$J^T J$ 是一个每个元素都等于 $m$ 的 $n \\times n$ 矩阵。我们可以将其写为 $J^T J = m U_n$，其中 $U_n$ 是 $n \\times n$ 的全 1 矩阵。$J^T J$ 的特征值是 $U_n$ 特征值的 $m$ 倍。\n\n矩阵 $U_n$ 的秩为 1，因为其所有列都相同。一个秩为 $k$ 的矩阵至少有 $n-k$ 个零特征值。因此，$U_n$ 有一个特征值为 0，其重数为至少 $n-1$。一个矩阵的特征值之和等于其迹。$U_n$ 的迹是 $\\text{Tr}(U_n) = \\sum_{i=1}^{n} 1 = n$。由于 $n-1$ 个特征值为 0，剩下的那个特征值必须是 $n$。所以，$U_n$ 的特征值是 $n$ (重数为 1) 和 0 (重数为 $n-1$)。\n\n$J^T J = m U_n$ 的特征值因此是 $mn$ (重数为 1) 和 0 (重数为 $n-1$)。最大特征值是 $\\lambda_{\\max}(J^T J) = mn$。\n$2$-范数是该值的平方根：\n$$\n\\|J\\|_{2} = \\sqrt{\\lambda_{\\max}(J^T J)} = \\sqrt{mn}\n$$\n\n总而言之，计算出的四个范数是：\n- $\\|J\\|_{1} = m$\n- $\\|J\\|_{2} = \\sqrt{mn}$\n- $\\|J\\|_{\\infty} = n$\n- $\\|J\\|_{F} = \\sqrt{mn}$\n\n最终答案以指定顺序的行向量形式呈现。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} m & \\sqrt{mn} & n & \\sqrt{mn} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "在掌握了基本计算之后，让我们深入探索范数更深层次的概念。这项实践将引导你探索范数的一个基本性质——三角不等式。通过构造一个特例并研究该不等式取等号的条件，你将揭示出向量范数与线性代数核心概念（即特征向量和非负特征值）之间的深刻联系，从而更深入地理解矩阵作用于特定向量时的几何意义。",
            "id": "2447194",
            "problem": "在计算经济学和金融学中常用的线性状态转移模型中，考虑一个实数 $2 \\times 2$ 矩阵 $A$ 和单位矩阵 $I$。全文使用欧几里得向量范数 $\\|\\cdot\\|_2$。构造一个非对角的实数 $2 \\times 2$ 矩阵 $A$，并找出一个非零向量 $x \\in \\mathbb{R}^2$，使得三角不等式\n$$\n\\|(A+I)x\\|_2 \\leq \\|Ax\\|_2 + \\|x\\|_2\n$$\n等号成立。定义比率\n$$\nR \\equiv \\frac{\\|(A+I)x\\|_2}{\\|Ax\\|_2 + \\|x\\|_2}。\n$$\n计算你构造的矩阵-向量对 $(A,x)$ 所对应的 $R$ 的精确值，并简要解释三角不等式等号成立时 $(A,x)$ 需满足的条件。你最终报告的答案必须是 $R$ 的精确值（无需四舍五入）。",
            "solution": "问题陈述经过验证。\n\n**步骤1：提取已知条件**\n- `A`：一个实数 `2 \\times 2` 非对角矩阵。\n- `I`：单位矩阵。\n- `x`：`\\mathbb{R}^2` 中的一个非零向量。\n- 范数：欧几里得向量范数 `\\|\\cdot\\|_2`。\n- 不等式：`\\|(A+I)x\\|_2 \\leq \\|Ax\\|_2 + \\|x\\|_2`。\n- 任务：构造 `A` 和 `x`，使得不等式等号成立。\n- 定义：比率 `R \\equiv \\frac{\\|(A+I)x\\|_2}{\\|Ax\\|_2 + \\|x\\|_2}`。\n- 任务：计算所构造的对 `(A,x)` 的 `R` 的精确值。\n- 任务：解释等号成立的条件。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题在科学上基于线性代数和向量范数理论的既定原理。这是一个适定问题，因为可以进行有效的构造，并得出指定比率的唯一值。该问题使用客观、精确的数学语言陈述，内容自洽且无矛盾。该场景是线性算子研究中的一个标准练习。\n\n**步骤3：结论与行动**\n问题被认定为有效。将提供完整解法。\n\n该问题要求构造一个矩阵 `A` 和一个向量 `x`，使得向量的三角不等式等号成立。一般来说，对于内积空间中的任意两个向量 `\\mathbf{u}` 和 `\\mathbf{v}`，三角不等式为 `\\|\\mathbf{u}+\\mathbf{v}\\| \\leq \\|\\mathbf{u}\\| + \\|\\mathbf{v}\\|`。等号成立的充要条件是，其中一个向量是另一个向量的非负标量倍数。\n\n在这个问题中，这两个向量是 `\\mathbf{u} = Ax` 和 `\\mathbf{v} = Ix = x`。给定的表达式是 `\\|Ax+x\\|_2 \\leq \\|Ax\\|_2 + \\|x\\|_2`。为了使等号成立，我们必须满足条件 `Ax = kx`，其中 `k` 是某个非负实标量。`x = k(Ax)` 的情况也是可能的，但由于 `x` 是非零的，`A` 需要是可逆的，这可以简化为 `A^{-1}x = kx`，这等价于第一个条件，其特征值为 `\\frac{1}{k}`。我们采用更简单的形式继续。\n\n条件 `Ax = kx` 意味着 `x` 必须是矩阵 `A` 的一个特征向量，且对应的特征值 `k` 必须是非负的。问题陈述 `x` 必须是一个非零向量，这与特征向量的定义是一致的。\n\n因此，我们的任务是：\n$1$. 构造一个实的、非对角的 `2 \\times 2` 矩阵 `A`。\n$2$. 确保 `A` 至少有一个非负特征值 `\\lambda \\geq 0`。\n$3$. 找出一个对应的特征向量 `x`。\n$4$. 计算这对 `(A,x)` 的比率 `R`。\n\n让我们构造这样一个矩阵 `A`。我们可以设计 `A`，使其具有简单的非负整数特征值。设特征值为 `\\lambda_1 = 1` 和 `\\lambda_2 = 4`。两者均为非负。\n对于一个 `2 \\times 2` 矩阵，特征值之和是其迹，特征值之积是其行列式。\n`\\mathrm{Tr}(A) = \\lambda_1 + \\lambda_2 = 1+4 = 5`.\n`\\det(A) = \\lambda_1 \\lambda_2 = 1 \\times 4 = 4`.\n\n设 `A = \\begin{pmatrix} a  b \\\\ c  d \\end{pmatrix}`。我们需要 `a+d=5` 和 `ad-bc=4`。为确保 `A` 是非对角的，我们要求 `b` 和 `c` 不全为零。\n让我们选择 `a=3`。则 `d=5-3=2`。\n行列式条件变为 `(3)(2) - bc = 4`，简化为 `6 - bc = 4`，即 `bc=2`。\n我们可以选择 `b=2` 和 `c=1`。这给出矩阵：\n$$\nA = \\begin{pmatrix} 3  2 \\\\ 1  2 \\end{pmatrix}\n$$\n这个矩阵是实的、`2 \\times 2` 的、非对角的。根据构造，其特征值为 `\\lambda_1 = 1` 和 `\\lambda_2 = 4`，两者都是非负的。\n\n现在，我们为其中一个特征值找出一个特征向量 `x`。我们选择 `\\lambda = 4`。我们需要求解方程组 `(A - \\lambda I)x = 0`，即 `(A - 4I)x = 0`。\n$$\n(A - 4I) = \\begin{pmatrix} 3-4  2 \\\\ 1  2-4 \\end{pmatrix} = \\begin{pmatrix} -1  2 \\\\ 1  -2 \\end{pmatrix}\n$$\n需要求解的方程是：\n$$\n\\begin{pmatrix} -1  2 \\\\ 1  -2 \\end{pmatrix} \\begin{pmatrix} x_1 \\\\ x_2 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}\n$$\n这得出一个独立的方程 `-x_1 + 2x_2 = 0`，即 `x_1 = 2x_2`。\n我们必须选择一个非零向量 `x`。一个简单的选择是 `x_2=1`，这给出 `x_1=2`。\n因此，我们构造的向量是 `x = \\begin{pmatrix} 2 \\\\ 1 \\end{pmatrix}`。\n\n我们现在构造了对 `(A,x)`：\n`A = \\begin{pmatrix} 3  2 \\\\ 1  2 \\end{pmatrix}` 和 `x = \\begin{pmatrix} 2 \\\\ 1 \\end{pmatrix}`。\n`A` 是非对角的，`x` 是非零的。对应的特征值是 `\\lambda=4 \\geq 0`，所以等式条件 `Ax = 4x` 得以满足。\n\n现在我们计算比率 `R`。\n$$\nR = \\frac{\\|(A+I)x\\|_2}{\\|Ax\\|_2 + \\|x\\|_2}\n$$\n根据我们的理论推导，由于三角不等式等号成立的条件已满足，分子和分母必须相等，因此 `R` 必须是 `1`。我们通过直接计算来验证这一点。\n\n首先，计算分母中的各项：\n`Ax = 4x = 4 \\begin{pmatrix} 2 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 8 \\\\ 4 \\end{pmatrix}`.\n`\\|Ax\\|_2 = \\left\\| \\begin{pmatrix} 8 \\\\ 4 \\end{pmatrix} \\right\\|_2 = \\sqrt{8^2 + 4^2} = \\sqrt{64+16} = \\sqrt{80} = 4\\sqrt{5}`.\n`\\|x\\|_2 = \\left\\| \\begin{pmatrix} 2 \\\\ 1 \\end{pmatrix} \\right\\|_2 = \\sqrt{2^2 + 1^2} = \\sqrt{4+1} = \\sqrt{5}`.\n分母是 `\\|Ax\\|_2 + \\|x\\|_2 = 4\\sqrt{5} + \\sqrt{5} = 5\\sqrt{5}`。\n\n接下来，计算分子中的项：\n`(A+I)x = Ax + x`.\n因为 `Ax=4x`，我们有 `Ax+x = 4x+x=5x`。\n`(A+I)x = 5x = 5 \\begin{pmatrix} 2 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 10 \\\\ 5 \\end{pmatrix}`.\n`\\|(A+I)x\\|_2 = \\left\\| \\begin{pmatrix} 10 \\\\ 5 \\end{pmatrix} \\right\\|_2 = \\sqrt{10^2 + 5^2} = \\sqrt{100+25} = \\sqrt{125} = 5\\sqrt{5}`.\n\n最后，计算比率 `R`。\n$$\nR = \\frac{5\\sqrt{5}}{5\\sqrt{5}} = 1\n$$\n计算结果证实了理论预期。\n\n等号成立条件的解释如下：等式 `\\|(A+I)x\\|_2 = \\|Ax\\|_2 + \\|x\\|_2` 成立的充要条件是向量 `Ax` 是向量 `x` 的一个非负标量倍数。鉴于 `x` 必须是非零的，这恰好是 `x` 作为矩阵 `A` 对应于一个非负特征值的特征向量的定义。",
            "answer": "$$\n\\boxed{1}\n$$"
        },
        {
            "introduction": "最后，我们将理论与实际计算联系起来。矩阵的$2$-范数（或称谱范数）在理论上极为重要，但直接从定义计算却十分困难。这项练习将指导你推导并实现幂迭代法，这是一个经典的数值线性代数算法，用于估算矩阵的$2$-范数。通过这个编程任务，你将学会如何将理论性质（例如 $\\|A\\|_2^2 = \\lambda_{\\max}(A^T A)$）转化为一个高效的计算策略，体验从理论到实践的完整过程。",
            "id": "2449590",
            "problem": "要求你设计并实现一个确定性程序，用于估计实矩阵 $A \\in \\mathbb{R}^{m \\times n}$ 的诱导矩阵 $2$-范数 $\\lVert A \\rVert_2$。该程序需使用基于幂迭代的算法，且仅从向量和矩阵范数的基本定义以及对称矩阵特征值的基本性质出发。你的目标是推导、论证并编写一个算法，该算法不依赖于显式构造任何超出标准矩阵-向量乘法的矩阵乘积，并且适用于方阵和矩形矩阵。\n\n待完成的任务：\n1. 从诱导矩阵 $2$-范数的核心定义 $\\lVert A \\rVert_2 = \\sup_{\\mathbf{x} \\neq \\mathbf{0}} \\frac{\\lVert A \\mathbf{x} \\rVert_2}{\\lVert \\mathbf{x} \\rVert_2}$ 以及对于任意实矩阵 $A$，矩阵 $A^\\top A$ 都是对称半正定矩阵这一事实出发，推导出一个估计 $\\lVert A \\rVert_2$ 的迭代方案。该方案通过重复应用 $A \\mathbf{x}$ 和 $A^\\top \\mathbf{y}$ 形式的矩阵-向量乘法，而不显式构造 $A^\\top A$。你的推导必须基于这些定义和性质，并且应包含一个基于估计值变化的明确停止准则。\n2. 将推导出的算法实现为一个完整的、可运行的程序。该算法必须：\n   - 使用 $\\mathbb{R}^n$ 中的一个确定性非零向量进行初始化，在 $\\ell_2$ 意义上对其进行归一化，并且在每次迭代中仅使用 $A \\mathbf{x}$ 和 $A^\\top \\mathbf{y}$ 运算。\n   - 当连续两次迭代中估计范数的相对变化小于容差 $\\varepsilon = 10^{-10}$ 时，或者当达到最大迭代次数 $10^4$ 次时终止，以先满足者为准。\n   - 稳健地处理 $A = 0$ 的边界情况，得出估计值 $\\lVert A \\rVert_2 = 0$。\n   - 返回 $\\lVert A \\rVert_2$ 的一个非负估计值。\n3. 你的程序必须评估以下矩阵测试套件，并以指定格式报告估计出的范数：\n   - 情况 1 (方阵, 对称正定):\n     $$A_1 = \\begin{bmatrix} 3  1 \\\\ 1  3 \\end{bmatrix}.$$\n   - 情况 2 (方阵, 高度非正规):\n     $$A_2 = \\begin{bmatrix} 1  10  0 \\\\ 0  1  0 \\\\ 0  0  0.1 \\end{bmatrix}.$$\n   - 情况 3 (高矩形):\n     $$A_3 = \\begin{bmatrix} 1  2 \\\\ 0  1 \\\\ 2  0 \\\\ 0  0 \\end{bmatrix}.$$\n   - 情况 4 (宽矩形):\n     $$A_4 = \\begin{bmatrix} 1  0  2  0 \\\\ 0  1  0  1 \\end{bmatrix}.$$\n   - 情况 5 (零矩阵):\n     $$A_5 = \\begin{bmatrix} 0  0  0 \\\\ 0  0  0 \\\\ 0  0  0 \\end{bmatrix}.$$\n   - 情况 6 (方阵, 具有接近的多个主导奇异值):\n     $$A_6 = \\begin{bmatrix} 1  0 \\\\ 0  0.999 \\end{bmatrix}.$$\n4. 最终输出格式：你的程序应生成单行输出，其中包含六个估计范数的结果，以逗号分隔列表形式，按 $A_1$ 到 $A_6$ 的顺序排列，并用方括号括起来。每个值必须四舍五入到 8 位小数。例如，一个有效的输出格式是\n   $$[\\text{v}_1,\\text{v}_2,\\text{v}_3,\\text{v}_4,\\text{v}_5,\\text{v}_6],$$\n   其中每个 $\\text{v}_i$ 是一个四舍五入到 8 位小数的十进制数。不应打印额外的文本或行。\n\n实现约束：\n- 程序必须是完全自包含的，不需要用户输入，并且只使用 Python 标准库和允许的库。\n- 本问题不使用角度。\n- 不涉及物理单位。",
            "solution": "问题要求推导并实现一个迭代算法，以估计实矩阵 $A \\in \\mathbb{R}^{m \\times n}$ 的诱导矩阵 $2$-范数 $\\lVert A \\rVert_2$。推导必须基于第一性原理，并避免显式构造如 $A^\\top A$ 这样的矩阵乘积。\n\n首先对问题陈述进行验证。\n\n**步骤 1：提取已知条件**\n- **定义**：诱导矩阵 $2$-范数定义为 $\\lVert A \\rVert_2 = \\sup_{\\mathbf{x} \\neq \\mathbf{0}} \\frac{\\lVert A \\mathbf{x} \\rVert_2}{\\lVert \\mathbf{x} \\rVert_2}$。\n- **性质**：对于任意实矩阵 $A$，矩阵 $A^\\top A$ 是对称半正定的。\n- **算法目标**：推导一个仅使用 $A \\mathbf{x}$ 和 $A^\\top \\mathbf{y}$ 形式的矩阵-向量乘法来估计 $\\lVert A \\rVert_2$ 的迭代方案。\n- **实现约束**：\n  - **初始化**：使用 $\\mathbb{R}^n$ 中的一个确定性、归一化的非零向量。\n  - **停止准则**：当范数估计值的相对变化小于容差 $\\varepsilon = 10^{-10}$ 时，或在达到最大迭代次数 $10^4$ 次后终止。\n  - **边界情况**：正确处理零矩阵 $A = 0$ 的情况，得出估计值 0。\n  - **返回值**：函数必须返回 $\\lVert A \\rVert_2$ 的一个非负估计值。\n- **测试套件**：提供了六个矩阵（$A_1$ 到 $A_6$）用于评估。\n- **输出格式**：包含六个估计范数的单行逗号分隔列表，四舍五入到 8 位小数，并用方括号括起来。\n\n**步骤 2：使用提取的已知条件进行验证**\n1.  **科学依据**：该问题基于诱导 $2$-范数的标准定义及其与 $A^\\top A$ 最大特征值的基本关系。所提出的方法——幂迭代法，是数值线性代数中用于寻找主导特征值的经典且科学合理的算法。该问题牢固地植根于已确立的数学原理。\n2.  **适定性**：该问题是适定的。它要求估计一个唯一定义的数学量（$\\lVert A \\rVert_2$）。算法的终止由最大迭代限制和收敛准则保证。\n3.  **客观性**：该问题以精确、客观的数学语言陈述，没有歧义或主观性陈述。\n4.  **缺陷分析**：\n    - **科学或事实不健全**：无。前提条件是正确的。\n    - **无法形式化或不相关**：无。该问题是计算工程和数值分析中的一个标准任务，直接涉及向量和矩阵范数。\n    - **不完整或矛盾的设置**：无。所有必要的组成部分都已指定：目标、方法约束、终止准则和测试用例。\n    - **不切实际或不可行**：无。该算法是实用的，测试矩阵是标准示例。\n    - **不适定或结构不良**：无。结构清晰，从理论推导到实现都有指导。\n    - **超出科学可验证性**：无。算法的正确性及其结果的准确性可以通过已知的解析解或标准库函数（例如，奇异值分解）进行验证。\n\n**步骤 3：结论与行动**\n该问题被判定为**有效**。将提供一个完整的、论证充分的解决方案。\n\n**推导与算法设计**\n\n对于矩阵 $A \\in \\mathbb{R}^{m \\times n}$，起点是诱导矩阵 $2$-范数的定义：\n$$\n\\lVert A \\rVert_2 = \\sup_{\\mathbf{x} \\in \\mathbb{R}^n, \\mathbf{x} \\neq \\mathbf{0}} \\frac{\\lVert A \\mathbf{x} \\rVert_2}{\\lVert \\mathbf{x} \\rVert_2}\n$$\n由于范数始终为非负，我们可以考虑其平方：\n$$\n\\lVert A \\rVert_2^2 = \\left( \\sup_{\\mathbf{x} \\neq \\mathbf{0}} \\frac{\\lVert A \\mathbf{x} \\rVert_2}{\\lVert \\mathbf{x} \\rVert_2} \\right)^2 = \\sup_{\\mathbf{x} \\neq \\mathbf{0}} \\frac{\\lVert A \\mathbf{x} \\rVert_2^2}{\\lVert \\mathbf{x} \\rVert_2^2}\n$$\n使用欧几里得范数的定义 $\\lVert \\mathbf{v} \\rVert_2^2 = \\mathbf{v}^\\top \\mathbf{v}$，我们可以将表达式重写为：\n$$\n\\lVert A \\rVert_2^2 = \\sup_{\\mathbf{x} \\neq \\mathbf{0}} \\frac{(A \\mathbf{x})^\\top (A \\mathbf{x})}{\\mathbf{x}^\\top \\mathbf{x}} = \\sup_{\\mathbf{x} \\neq \\mathbf{0}} \\frac{\\mathbf{x}^\\top A^\\top A \\mathbf{x}}{\\mathbf{x}^\\top \\mathbf{x}}\n$$\n这个表达式是矩阵 $B = A^\\top A$ 的瑞利商 (Rayleigh quotient)。线性代数中的一个基本定理指出，对称矩阵的瑞利商的上确界是其最大特征值 $\\lambda_{\\text{max}}$。矩阵 $B = A^\\top A$ 确实是对称的（因为 $(A^\\top A)^\\top = A^\\top (A^\\top)^\\top = A^\\top A$）并且是半正定的。因此，我们得到了关键关系：\n$$\n\\lVert A \\rVert_2^2 = \\lambda_{\\text{max}}(A^\\top A)\n$$\n这意味着诱导矩阵 $2$-范数是 $A^\\top A$ 最大特征值的平方根：\n$$\n\\lVert A \\rVert_2 = \\sqrt{\\lambda_{\\text{max}}(A^\\top A)}\n$$\n根据定义，值 $\\sqrt{\\lambda_{\\text{max}}(A^\\top A)}$ 也是 $A$ 的最大奇异值，记为 $\\sigma_1(A)$。\n\n问题现在简化为在不显式计算矩阵 $A^\\top A$ 的情况下找到 $\\lambda_{\\text{max}}(A^\\top A)$。这可以使用**幂迭代**法实现。幂迭代法是一种迭代算法，用于找到模最大的特征值（主导特征值）及其对应的特征向量。对于像 $A^\\top A$ 这样的对称半正定矩阵，所有特征值都是实数且非负，因此模最大的特征值就是 $\\lambda_{\\text{max}}$。\n\n矩阵 $B$ 的标准幂迭代法如下：\n1.  从一个非零向量 $\\mathbf{v}_0$ 开始。\n2.  迭代 $k = 1, 2, \\dots$：$\\mathbf{v}_k = \\frac{B \\mathbf{v}_{k-1}}{\\lVert B \\mathbf{v}_{k-1} \\rVert_2}$。\n向量序列 $\\{\\mathbf{v}_k\\}$ 收敛于对应于 $\\lambda_{\\text{max}}(B)$ 的特征向量，前提是初始向量 $\\mathbf{v}_0$ 在该特征向量方向上具有非零分量。\n\n在我们的例子中，$B = A^\\top A$。迭代步骤是 $\\mathbf{v}_k \\propto (A^\\top A) \\mathbf{v}_{k-1}$。按照要求，我们通过执行两个连续的矩阵-向量乘积来避免构造 $A^\\top A$：\n1.  首先，计算 $\\mathbf{y}_{k-1} = A \\mathbf{v}_{k-1}$。\n2.  然后，计算 $\\mathbf{x}_k = A^\\top \\mathbf{y}_{k-1}$。\n因此，核心更新是 $\\mathbf{x}_k = A^\\top (A \\mathbf{v}_{k-1})$。下一个归一化向量是 $\\mathbf{v}_k = \\mathbf{x}_k / \\lVert \\mathbf{x}_k \\rVert_2$。\n\n我们还需要在每次迭代中估计 $\\lambda_{\\text{max}}(A^\\top A)$。这可以通过使用当前特征向量估计值 $\\mathbf{v}_{k-1}$ 的瑞利商来获得：\n$$\n\\lambda_k \\approx \\frac{\\mathbf{v}_{k-1}^\\top (A^\\top A) \\mathbf{v}_{k-1}}{\\mathbf{v}_{k-1}^\\top \\mathbf{v}_{k-1}}\n$$\n由于 $\\mathbf{v}_{k-1}$ 是一个单位向量（$\\lVert \\mathbf{v}_{k-1} \\rVert_2 = 1$），其分母为 1。分子变为：\n$$\n\\mathbf{v}_{k-1}^\\top A^\\top A \\mathbf{v}_{k-1} = (A \\mathbf{v}_{k-1})^\\top (A \\mathbf{v}_{k-1}) = \\mathbf{y}_{k-1}^\\top \\mathbf{y}_{k-1} = \\lVert \\mathbf{y}_{k-1} \\rVert_2^2\n$$\n所以，在第 $k$ 次迭代时最大特征值的估计值为 $\\lambda_k = \\lVert A \\mathbf{v}_{k-1} \\rVert_2^2$。\n因此，矩阵 $2$-范数的估计值 $\\sigma_k = \\sqrt{\\lambda_k}$ 仅为：\n$$\n\\sigma_k = \\lVert A \\mathbf{v}_{k-1} \\rVert_2 = \\lVert \\mathbf{y}_{k-1} \\rVert_2\n$$\n这提供了一种在每次迭代中更新范数估计值的简单而高效的方法。\n\n**最终算法：**\n设 $A$ 是一个 $m \\times n$ 矩阵。设 $\\varepsilon = 10^{-10}$ 为容差，$K_{\\text{max}} = 10^4$ 为最大迭代次数。\n\n1.  **处理平凡情况**：如果 $n=0$，则定义域为空，所以 $\\lVert A \\rVert_2 = 0$。\n2.  **初始化**：\n    - 选择一个确定性的非零起始向量 $\\mathbf{v}_0 \\in \\mathbb{R}^n$。一个标准的选择是全为 1 的向量。\n    - 将其归一化：$\\mathbf{v} \\leftarrow \\frac{\\mathbf{v}_0}{\\lVert \\mathbf{v}_0 \\rVert_2}$。\n    - 初始化范数估计值，例如，$\\sigma_{\\text{new}} \\leftarrow 0$。\n3.  **迭代**：对于 $k=1, \\dots, K_{\\text{max}}$：\n    a.  存储前一个估计值：$\\sigma_{\\text{old}} \\leftarrow \\sigma_{\\text{new}}$。\n    b.  应用第一个矩阵-向量乘积：$\\mathbf{y} \\leftarrow A \\mathbf{v}$。\n    c.  更新范数估计值：$\\sigma_{\\text{new}} \\leftarrow \\lVert \\mathbf{y} \\rVert_2$。\n    d.  **检查收敛性**：如果 $k>1$ 且 $|\\sigma_{\\text{new}} - \\sigma_{\\text{old}}|  \\varepsilon \\cdot \\sigma_{\\text{new}}$，则跳出循环。\n    e.  **处理零矩阵情况**：如果 $\\sigma_{\\text{new}} = 0$，这意味着 $\\mathbf{y}=\\mathbf{0}$。即 $A\\mathbf{v}=\\mathbf{0}$。矩阵 $A$ 是奇异的，或者可能是零矩阵。该算法正确地得出 $\\sigma_{\\text{new}} = 0$ 并应终止。我们可以中断循环。\n    f.  应用第二个矩阵-向量乘积：$\\mathbf{x} \\leftarrow A^\\top \\mathbf{y}$。\n    g.  将结果向量归一化以用于下一次迭代：$\\mathbf{v} \\leftarrow \\frac{\\mathbf{x}}{\\lVert \\mathbf{x} \\rVert_2}$。如果 $\\lVert \\mathbf{x} \\rVert_2 = 0$，则中断循环。这种情况发生在 $\\mathbf{y}$ 位于 $A^\\top$ 的零空间中，对于 $\\mathbf{y}=A\\mathbf{v}$，这意味着 $A\\mathbf{v}=\\mathbf{0}$，从而正确地得出范数为 0。\n4.  **返回**：最终的估计值 $\\sigma_{\\text{new}}$。\n\n此算法仅使用矩阵-向量乘积，遵守所有约束，并能正确估计 $\\lVert A \\rVert_2$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef estimate_induced_2_norm(A, tol=1e-10, max_iter=10000):\n    \"\"\"\n    Estimates the induced matrix 2-norm (largest singular value) of a real matrix A\n    using the power iteration method.\n\n    The algorithm iteratively computes v_k = A^T * A * v_{k-1} without explicitly\n    forming the matrix A^T*A. The norm is estimated as ||A*v_k||_2.\n\n    Args:\n        A (np.ndarray): The input matrix, m x n.\n        tol (float): The relative tolerance for convergence.\n        max_iter (int): The maximum number of iterations.\n\n    Returns:\n        float: The estimated induced 2-norm of A.\n    \"\"\"\n    # Get matrix dimensions\n    m, n = A.shape\n\n    # Handle the edge case of a matrix with zero columns.\n    if n == 0:\n        return 0.0\n\n    # Initialize with a deterministic non-zero vector in R^n.\n    # A vector of ones is a standard deterministic choice.\n    # The power method might fail if this initial vector is orthogonal\n    # to the dominant eigenvector of A^T*A. In practice, for general\n    # matrices and with finite-precision arithmetic, this is rare.\n    v = np.ones(n)\n    v /= np.linalg.norm(v)\n\n    norm_est = 0.0\n\n    for _ in range(max_iter):\n        norm_est_prev = norm_est\n\n        # First matrix-vector product: y = A*v\n        y = A @ v\n\n        # Update the norm estimate: ||A||_2 approx ||y||_2\n        norm_est = np.linalg.norm(y)\n\n        # Check for convergence using relative change.\n        # This check is safe because for a non-zero matrix, norm_est converges\n        # to a positive value.\n        if norm_est > 0 and abs(norm_est - norm_est_prev) < tol * norm_est:\n            break\n        \n        # Handle the case where A is the zero matrix or v is in the null space of A.\n        if norm_est == 0:\n            return 0.0\n\n        # Second matrix-vector product: x = A^T*y\n        x = A.T @ y\n        \n        # Normalize the vector for the next iteration.\n        norm_x = np.linalg.norm(x)\n\n        # If norm_x is zero, the iteration has converged to the null space.\n        if norm_x == 0:\n            break\n            \n        v = x / norm_x\n\n    return norm_est\n\n\ndef solve():\n    \"\"\"\n    Defines the test cases, runs the norm estimation, and prints the results.\n    \"\"\"\n    \n    A1 = np.array([[3.0, 1.0], \n                   [1.0, 3.0]])\n\n    A2 = np.array([[1.0, 10.0, 0.0],\n                   [0.0, 1.0, 0.0],\n                   [0.0, 0.0, 0.1]])\n\n    A3 = np.array([[1.0, 2.0],\n                   [0.0, 1.0],\n                   [2.0, 0.0],\n                   [0.0, 0.0]])\n\n    A4 = np.array([[1.0, 0.0, 2.0, 0.0],\n                   [0.0, 1.0, 0.0, 1.0]])\n\n    A5 = np.array([[0.0, 0.0, 0.0],\n                   [0.0, 0.0, 0.0],\n                   [0.0, 0.0, 0.0]])\n\n    A6 = np.array([[1.0, 0.0],\n                   [0.0, 0.999]])\n                   \n    test_cases = [A1, A2, A3, A4, A5, A6]\n\n    results = []\n    for A in test_cases:\n        norm_estimate = estimate_induced_2_norm(A, tol=1e-10, max_iter=10000)\n        results.append(f\"{norm_estimate:.8f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}