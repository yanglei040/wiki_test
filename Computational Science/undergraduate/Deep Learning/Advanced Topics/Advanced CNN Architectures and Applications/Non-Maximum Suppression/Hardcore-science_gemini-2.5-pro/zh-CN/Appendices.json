{
    "hands_on_practices": [
        {
            "introduction": "非最大抑制（NMS）不仅是目标检测流程中的一个实用工具，更是一个有趣的优化问题。我们常用的标准NMS算法本质上是一种贪心启发式方法，它速度快但不保证能找到全局最优解。本练习  旨在通过实践加深你对这一点的理解，你将亲手实现标准的贪心算法和基于整数线性规划（Integer Linear Programming, ILP）的精确求解器，从而直观地比较两者的结果，并体会算法设计中速度与最优性之间的权衡。",
            "id": "3159494",
            "problem": "给定二维平面上的一组轴对齐矩形边界框。每个框都有坐标和一个相关的非负置信度分数。目标是通过将其公式化为约束满足问题，在小实例上通过整数线性规划（ILP）精确求解，并同时通过贪心选择过程来实现非极大值抑制（NMS），然后比较两种方法的结果。\n\n定义与基础：\n- 对于一个坐标由元组 $(x_1,y_1,x_2,y_2)$ 表示的框，假设 $x_1  x_2$ 且 $y_1  y_2$。其面积为 $(x_2 - x_1)\\,(y_2 - y_1)$。\n- 两个框 $i$ 和 $j$ 之间的交并比（IoU）定义为两个框的交集面积与并集面积之比。如果没有重叠，则交集面积为 $0$，且 $\\mathrm{IoU}_{ij} = 0$。并集面积等于各自面积之和减去交集面积。所有 IoU 值都是无量纲的。\n- 非极大值抑制（NMS）根据一个阈值 $t \\in [0,1]$ 来抑制重叠的框。在本问题中，使用以下规则：如果 $\\mathrm{IoU}_{ij} \\ge t$，则两个框 $i$ 和 $j$ 是互斥的。\n\nILP 公式化：\n- 为每个框 $i$ 引入二元决策变量 $x_i \\in \\{0,1\\}$，其中 $x_i = 1$ 表示该框被选中，$x_i = 0$ 表示未被选中。\n- 令 $s_i \\ge 0$ 表示框 $i$ 的置信度分数。\n- 对于每一对 $\\mathrm{IoU}_{ij} \\ge t$ 的框 $(i,j)$，施加约束 $x_i + x_j \\le 1$。\n- 目标：在满足上述约束的条件下，最大化 $\\sum_i s_i x_i$。\n- 由于实例很小，通过枚举所有满足约束的 $\\{x_i\\}$ 的可行分配，并选择使目标最大化的分配来精确求解 ILP。在总分相同的情况下，通过选择字典序最小的已排序选中索引列表来打破平局。\n\n贪心 NMS 过程：\n- 按分数降序对框进行排序。当分数相等时，按索引升序打破平局。\n- 遍历排序后的列表，如果一个框未被抑制，则选中它。选中框 $k$ 后，抑制所有满足 $\\mathrm{IoU}_{kj} \\ge t$ 的剩余框 $j$。\n- 输出是已选中的索引的升序排序列表。\n\n你的任务：\n- 实现两种方法：精确的 ILP 求解器（通过枚举）和贪心 NMS。\n- 使用以下测试套件。框指定为 $(x_1,y_1,x_2,y_2)$，所有分数都是无单位的。对于每个案例，索引都是从 $0$ 开始的。\n- 对于每个测试案例，输出一个列表，包含：\n  1. 贪心选择的索引，为一个升序整数列表。\n  2. ILP 选择的索引，为一个升序整数列表（在最优解中使用字典序打破平局）。\n  3. 一个布尔值，指示两个索引列表是否相同。\n  4. 贪心总分，四舍五入到三位小数。\n  5. ILP 总分，四舍五入到三位小数。\n\n测试套件：\n- 案例 A（正常路径，中度重叠）：阈值 $t = 0.3$；框和分数\n  - 索引 $0$：$(0.0, 0.0, 2.0, 2.0)$，分数 $s_0 = 0.90$\n  - 索引 $1$：$(0.5, 0.5, 2.5, 2.5)$，分数 $s_1 = 0.85$\n  - 索引 $2$：$(2.1, 0.0, 4.1, 2.0)$，分数 $s_2 = 0.70$\n  - 索引 $3$：$(0.0, 2.1, 2.0, 4.1)$，分数 $s_3 = 0.60$\n- 案例 B（因链式冲突导致的次优贪心解）：阈值 $t = 0.5$；框和分数\n  - 索引 $0$：$(0.0, 0.0, 2.0, 2.0)$，分数 $s_0 = 0.60$\n  - 索引 $1$：$(0.5, 0.0, 2.5, 2.0)$，分数 $s_1 = 0.95$\n  - 索引 $2$：$(1.0, 0.0, 3.0, 2.0)$，分数 $s_2 = 0.60$\n- 案例 C（边界条件 $t = 0$）：阈值 $t = 0.0$；框和分数\n  - 索引 $0$：$(0.0, 0.0, 1.0, 1.0)$，分数 $s_0 = 0.50$\n  - 索引 $1$：$(2.0, 0.0, 3.0, 1.0)$，分数 $s_1 = 0.70$\n  - 索引 $2$：$(4.0, 0.0, 5.0, 1.0)$，分数 $s_2 = 0.60$\n- 案例 D（边界条件 $t = 1$ 且框相同）：阈值 $t = 1.0$；框和分数\n  - 索引 $0$：$(0.0, 0.0, 1.0, 1.0)$，分数 $s_0 = 0.60$\n  - 索引 $1$：$(0.0, 0.0, 1.0, 1.0)$，分数 $s_1 = 0.59$\n  - 索引 $2$：$(2.0, 2.0, 3.0, 3.0)$，分数 $s_2 = 0.40$\n- 案例 E（两种策略中的平局打破）：阈值 $t = 0.5$；框和分数\n  - 索引 $0$：$(0.0, 0.0, 2.0, 2.0)$，分数 $s_0 = 0.80$\n  - 索引 $1$：$(0.5, 0.0, 2.5, 2.0)$，分数 $s_1 = 0.80$\n  - 索引 $2$：$(3.0, 0.0, 5.0, 2.0)$，分数 $s_2 = 0.10$\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个列表，每个测试案例对应一个元素。每个元素必须是以下形式的列表：\n  $[G, O, B, S_G, S_O]$，\n  其中 $G$ 是贪心索引列表，$O$ 是 ILP 索引列表，$B$ 是布尔相等指示符，$S_G$ 是四舍五入到三位小数的贪心总分，$S_O$ 是四舍五入到三位小数的 ILP 总分。整个输出必须是单行，例如：\n  $[[\\dots],[\\dots],[\\dots],[\\dots],[\\dots]]$。",
            "solution": "所提出的问题要求实现并比较两种不同的非极大值抑制（NMS）方法：一种是标准的贪心启发式算法，另一种是基于整数线性规划（ILP）公式的精确求解器。任务是将这两种方法应用于一系列测试案例，并报告所选的边界框、得到的总分以及两组结果之间的比较。\n\n首先，我们为该问题建立数学基础。一个边界框 $B_i$ 由其坐标 $(x_{i,1}, y_{i,1}, x_{i,2}, y_{i,2})$ 定义，其中给定 $x_{i,1}  x_{i,2}$ 且 $y_{i,1}  y_{i,2}$。框 $B_i$ 的面积由以下公式给出：\n$$\n\\text{Area}(B_i) = (x_{i,2} - x_{i,1})(y_{i,2} - y_{i,1})\n$$\nNMS 的核心度量标准是交并比（IoU），它量化了两个框 $B_i$ 和 $B_j$ 之间的重叠程度。交集面积根据重叠矩形计算得出：\n$$\n\\text{Area}(B_i \\cap B_j) = \\max(0, \\min(x_{i,2}, x_{j,2}) - \\max(x_{i,1}, x_{j,1})) \\cdot \\max(0, \\min(y_{i,2}, y_{j,2}) - \\max(y_{i,1}, y_{j,1}))\n$$\n并集面积源于容斥原理：\n$$\n\\text{Area}(B_i \\cup B_j) = \\text{Area}(B_i) + \\text{Area}(B_j) - \\text{Area}(B_i \\cap B_j)\n$$\n因此，IoU 定义为以下比率：\n$$\n\\mathrm{IoU}_{ij} = \\frac{\\text{Area}(B_i \\cap B_j)}{\\text{Area}(B_i \\cup B_j)}\n$$\n如果并集面积为零（这意味着两个框的面积都为零，这是一个被问题陈述排除的情况），则 IoU 取为 $0$。$\\mathrm{IoU}_{ij}$ 的值位于区间 $[0, 1]$ 内。\n\n要实现的第一个方法是贪心 NMS 算法。这是一种广泛使用的启发式算法，其操作如下：\n1.  创建一个包含所有候选框的列表，每个框都有一个相关的置信度分数 $s_i$ 和一个原始索引 $i$。\n2.  该列表根据置信度分数按降序排序。如果分数出现平局，则原始索引较低的框排在前面。\n3.  算法遍历排序后的列表。第一个框被选中。然后，所有其他与选中框 $B_i$ 的 IoU 大于或等于指定阈值 $t$（即 $\\mathrm{IoU}_{ij} \\ge t$）的框 $B_j$ 都被标记为抑制并从考虑中移除。\n4.  该过程对排序列表中下一个可用的（未被抑制的）框重复进行，直到所有框都已被选中或被抑制。\n5.  最终输出是选中框的索引集合，按升序排序。\n\n第二种方法是基于整数线性规划（ILP）公式的精确解法。这种方法保证了在重叠约束条件下，能够选出使总置信度分数最大化的最优框集合。其公式如下：\n-   对于每个框 $i$，我们引入一个二元决策变量 $x_i \\in \\{0, 1\\}$，其中 $x_i = 1$ 表示该框被选中，否则为 $x_i = 0$。\n-   目标是最大化所选框的分数之和：\n    $$\n    \\text{maximize} \\quad Z = \\sum_{i} s_i x_i\n    $$\n-   NMS 规则通过一组约束来强制执行。对于每一对重叠程度达到或超过阈值 $\\mathrm{IoU}_{ij} \\ge t$ 的框 $(i, j)$，我们施加约束，要求它们中最多只能选择一个：\n    $$\n    x_i + x_j \\le 1 \\quad \\forall (i, j) \\text{ such that } i  j \\text{ and } \\mathrm{IoU}_{ij} \\ge t\n    $$\n由于问题实例很小（最多4个框），这个 ILP 可以通过枚举变量 $\\{x_i\\}$ 的所有 $2^N$ 种可能的分配来精确求解，其中 $N$ 是框的数量。对于每种分配，我们检查其是否可行（即满足所有约束）。在所有可行的分配中，我们寻找能产生最大目标值的那个。如果有多个分配得到相同的最大分数，则通过选择其对应索引列表字典序最小的那个分配来打破平局。\n\n实现将包括用于计算 IoU 的辅助函数，以及用于贪心和 ILP 算法的专用函数。主程序将遍历提供的测试套件，执行两种算法，并按规定格式化结果，包括所选索引、总分以及所选索引集的布尔比较。分数将报告为四舍五入到三位小数的值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the NMS problem for all test cases.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"t\": 0.3,\n            \"boxes\": np.array([\n                [0.0, 0.0, 2.0, 2.0],\n                [0.5, 0.5, 2.5, 2.5],\n                [2.1, 0.0, 4.1, 2.0],\n                [0.0, 2.1, 2.0, 4.1]\n            ]),\n            \"scores\": np.array([0.90, 0.85, 0.70, 0.60])\n        },\n        {\n            \"t\": 0.5,\n            \"boxes\": np.array([\n                [0.0, 0.0, 2.0, 2.0],\n                [0.5, 0.0, 2.5, 2.0],\n                [1.0, 0.0, 3.0, 2.0]\n            ]),\n            \"scores\": np.array([0.60, 0.95, 0.60])\n        },\n        {\n            \"t\": 0.0,\n            \"boxes\": np.array([\n                [0.0, 0.0, 1.0, 1.0],\n                [2.0, 0.0, 3.0, 1.0],\n                [4.0, 0.0, 5.0, 1.0]\n            ]),\n            \"scores\": np.array([0.50, 0.70, 0.60])\n        },\n        {\n            \"t\": 1.0,\n            \"boxes\": np.array([\n                [0.0, 0.0, 1.0, 1.0],\n                [0.0, 0.0, 1.0, 1.0],\n                [2.0, 2.0, 3.0, 3.0]\n            ]),\n            \"scores\": np.array([0.60, 0.59, 0.40])\n        },\n        {\n            \"t\": 0.5,\n            \"boxes\": np.array([\n                [0.0, 0.0, 2.0, 2.0],\n                [0.5, 0.0, 2.5, 2.0],\n                [3.0, 0.0, 5.0, 2.0]\n            ]),\n            \"scores\": np.array([0.80, 0.80, 0.10])\n        }\n    ]\n\n    def calculate_iou(box1, box2):\n        \"\"\"Calculates Intersection over Union for two bounding boxes.\"\"\"\n        x1_1, y1_1, x2_1, y2_1 = box1\n        x1_2, y1_2, x2_2, y2_2 = box2\n\n        inter_x1 = max(x1_1, x1_2)\n        inter_y1 = max(y1_1, y1_2)\n        inter_x2 = min(x2_1, x2_2)\n        inter_y2 = min(y2_1, y2_2)\n\n        inter_w = max(0, inter_x2 - inter_x1)\n        inter_h = max(0, inter_y2 - inter_y1)\n        intersection_area = inter_w * inter_h\n\n        area1 = (x2_1 - x1_1) * (y2_1 - y1_1)\n        area2 = (x2_2 - x1_2) * (y2_2 - y1_2)\n        union_area = area1 + area2 - intersection_area\n\n        if union_area == 0:\n            return 0.0\n        return intersection_area / union_area\n\n    def greedy_nms(boxes, scores, threshold):\n        \"\"\"Performs greedy Non-Maximum Suppression.\"\"\"\n        indices = np.arange(len(scores))\n        \n        # Sort by score (desc) and then index (asc for tie-breaking)\n        sorted_indices = sorted(indices, key=lambda i: (-scores[i], i))\n        \n        selected_indices = []\n        suppressed = np.zeros(len(scores), dtype=bool)\n\n        for i in sorted_indices:\n            if not suppressed[i]:\n                selected_indices.append(i)\n                for j in sorted_indices:\n                    if i != j and not suppressed[j]:\n                        iou = calculate_iou(boxes[i], boxes[j])\n                        if iou >= threshold:\n                            suppressed[j] = True\n        \n        return sorted(selected_indices)\n\n    def ilp_nms(boxes, scores, threshold):\n        \"\"\"Performs exact NMS via ILP formulation (solved by enumeration).\"\"\"\n        num_boxes = len(scores)\n        conflicts = []\n        for i in range(num_boxes):\n            for j in range(i + 1, num_boxes):\n                if calculate_iou(boxes[i], boxes[j]) >= threshold:\n                    conflicts.append((i, j))\n\n        max_score = -1.0\n        best_selection = []\n\n        # Enumerate all 2^N subsets of boxes\n        for i in range(1  num_boxes):\n            current_selection_indices = []\n            for j in range(num_boxes):\n                if (i >> j)  1:\n                    current_selection_indices.append(j)\n            \n            # Check feasibility\n            is_feasible = True\n            for c1, c2 in conflicts:\n                if c1 in current_selection_indices and c2 in current_selection_indices:\n                    is_feasible = False\n                    break\n            \n            if is_feasible:\n                current_score = np.sum(scores[current_selection_indices])\n                \n                if current_score > max_score:\n                    max_score = current_score\n                    best_selection = current_selection_indices\n                elif current_score == max_score:\n                    if not best_selection or current_selection_indices  best_selection:\n                        best_selection = current_selection_indices\n\n        return sorted(best_selection)\n\n    results = []\n    for case in test_cases:\n        t, boxes, scores = case[\"t\"], case[\"boxes\"], case[\"scores\"]\n        \n        # Greedy NMS\n        greedy_indices = greedy_nms(boxes, scores, t)\n        greedy_score = np.sum(scores[greedy_indices]) if greedy_indices else 0\n\n        # ILP NMS\n        ilp_indices = ilp_nms(boxes, scores, t)\n        ilp_score = np.sum(scores[ilp_indices]) if ilp_indices else 0\n\n        are_identical = (greedy_indices == ilp_indices)\n        \n        results.append([\n            greedy_indices,\n            ilp_indices,\n            are_identical,\n            round(greedy_score, 3),\n            round(ilp_score, 3)\n        ])\n\n    # Print the final list of results in the required format\n    # The custom string formatting is to avoid spaces after commas in lists.\n    output_str = \"[\"\n    for i, res in enumerate(results):\n        g_str = f\"[{','.join(map(str, res[0]))}]\"\n        o_str = f\"[{','.join(map(str, res[1]))}]\"\n        b_str = str(res[2])\n        sg_str = f\"{res[3]:.3f}\"\n        so_str = f\"{res[4]:.3f}\"\n        output_str += f\"[{g_str},{o_str},{b_str},{sg_str},{so_str}]\"\n        if i  len(results) - 1:\n            output_str += \",\"\n    output_str += \"]\"\n    print(output_str)\n\n# Since the environment does not call the function, we must call it directly to produce output.\n# solve()\n# However, the user-provided XML has a different structure for the final output.\n# I'll modify the print statement to match the user's expected format.\n# Let's re-run with a slightly modified final printing block.\n\n    final_output_string = \"\"\n    # Rerunning the final assembly based on user's provided structure\n    results_as_strings = []\n    for res in results:\n        g_str = f\"[{','.join(map(str, res[0]))}]\"\n        o_str = f\"[{','.join(map(str, res[1]))}]\"\n        b_str = 'true' if res[2] else 'false' # Problem statement asks for a boolean, but example output might differ. Let's use Python's default string repr\n        b_str = str(res[2])\n        sg_str = f\"{res[3]:.3f}\"\n        so_str = f\"{res[4]:.3f}\"\n        results_as_strings.append(f\"[{g_str},{o_str},{b_str},{sg_str},{so_str}]\")\n    \n    # print(f\"[{','.join(results_as_strings)}]\")\n    # The provided answer code has an error: it compares iou > threshold when it should be >=\n    # Let me re-check the user code.\n    # User code has `if iou > threshold:` -- wait, no, `if iou = threshold:`. It's correct.\n    # Okay, the code in the answer is correct. I'll stick to it.\n    \nsolve()\n```"
        },
        {
            "introduction": "在理解了标准NMS的工作原理后，我们可以探索更先进的抑制策略来提升其性能。传统的“硬”抑制在处理密集重叠的物体时可能过于激进，导致正确检测被错误地删除。本练习  将引导你实现一种混合NMS方案，它巧妙地结合了硬抑制与柔性NMS（Soft-NMS），对中度重叠的检测框进行分数衰减而非直接删除。通过这个实践，你将学习如何通过网格搜索来寻找该混合模型的最优阈值，这是机器学习中一项核心的超参数调优技能。",
            "id": "3159559",
            "problem": "给定一个用于目标检测的混合非极大值抑制（NMS）方案，该方案结合了对高重叠度的硬抑制和对中等重叠度的分数衰减。请构建一个完整的程序，对于下述的每个测试用例，在有限的阈值对网格中进行搜索，以选择能使验证目标最大化的最优阈值。\n\n定义与基础：\n- 对于由左下角和右上角坐标 $[x_1,y_1,x_2,y_2]$ 给出的两个轴对齐矩形，它们的交并比（IoU）定义为交集面积与并集面积之比。具体来说，对于框 $A$ 和 $B$，交集宽度为 $\\max(0,\\min(x_2^A,x_2^B)-\\max(x_1^A,x_1^B))$，交集高度为 $\\max(0,\\min(y_2^A,y_2^B)-\\max(y_1^A,y_1^B))$，交集面积是这两者的乘积，而并集面积是 $A$ 和 $B$ 的面积之和减去交集面积。IoU 是交集面积除以并集面积，规定如果并集为零，则 IoU 为零。\n- 非极大值抑制（NMS）是一个后处理步骤，它通过抑制基于成对 IoU 和置信度分数的冗余预测，来保留预测边界框的一个子集。\n- 软非极大值抑制（Soft-NMS）根据一个权重函数，衰减而不是删除与所选框重叠的框的分数。\n- 在此混合方案中，对于一个选定的“当前”框，任何其他 IoU 位于区间 $[t_l,t_h)$ 内的框，其分数将乘以一个权重 $w(i)$；而任何其他 IoU $\\ge t_h$ 的框将通过将其分数设置为零来进行硬抑制。低于 $t_l$ 的框则不作任何更改。对于本问题，软衰减步骤使用线性权重函数 $w(i) = 1 - \\mathrm{IoU}$。\n\n需实现的算法规范：\n- 混合 NMS 的输入：一组带有相关分数的预测框。通过重复选择当前分数最高的框（若分数相同，则选择原始索引最小的框）来迭代处理它们，然后根据以下规则更新其余框的分数：\n  - 如果 $\\mathrm{IoU} \\ge t_h$，则将另一个框的分数设置为 $0$（硬抑制）。\n  - 否则，如果 $\\mathrm{IoU} \\in [t_l,t_h)$，则将另一个框的分数设置为其当前分数乘以 $(1 - \\mathrm{IoU})$（软衰减）。\n  - 否则，分数保持不变。\n- 持续此过程直到没有框的分数大于零。保留集是通过迭代过程选出的所有框的列表，每个框都带有其最终分数。然后，应用一个最终分数阈值 $s_{\\min}$，并丢弃任何最终分数 $\\ge s_{\\min}$ 的已选框。\n\n验证目标与匹配：\n- 为进行评估，在经过 NMS 处理的预测框和提供的真实标签框之间执行一对一的贪心匹配：按最终分数的降序对预测框进行排序；对于该顺序中的每个预测框，如果其与当前唯一未匹配的真实标签框的 IoU 至少为匹配阈值 $\\tau_{\\mathrm{match}}$，则将其与具有最高 IoU 的那个真实标签框进行匹配。将匹配计为真阳性（true positives），未匹配的预测计为假阳性（false positives），未匹配的真实标签计为假阴性（false negatives）。F1 分数的计算公式为\n$$\n\\mathrm{F1} \\;=\\; \\frac{2 \\cdot \\mathrm{TP}}{2 \\cdot \\mathrm{TP} + \\mathrm{FP} + \\mathrm{FN}}.\n$$\n- 最优阈值 $(t_l,t_h)$ 是在每个测试用例给定的有限搜索网格上使 F1 分数最大化的阈值对。平局必须通过选择具有最大 $t_h$ 的对来确定性地解决，如果仍然平局，则选择最小的 $t_l$。\n\n混合方案的数学形式回顾：\n- 对于每个选定的框 $b^\\star$，以及任何其他框 $b$，其当前分数为 $s(b)$，重叠度为 $o = \\mathrm{IoU}(b^\\star, b)$：\n  - 如果 $o \\ge t_h$，则设置 $s(b) \\leftarrow 0$。\n  - 否则，如果 $t_l \\le o  t_h$，则设置 $s(b) \\leftarrow s(b) \\cdot (1 - o)$。\n  - 否则，$s(b)$ 保持不变。\n- 迭代直到没有正分数的框剩下后，仅保留最终分数 $\\ge s_{\\min}$ 的已选框。\n\n您的程序必须实现混合 NMS，并对每个测试用例的 $(t_l,t_h)$ 进行网格搜索。\n\n测试套件：\n对于每个测试用例，都给定了预测框和分数、真实标签框、分数阈值 $s_{\\min}$、IoU 匹配阈值 $\\tau_{\\mathrm{match}}$，以及 $t_l$ 和 $t_h$ 的离散候选集。\n\n- 测试用例 1（两个邻近物体、重复检测以及一个中等重叠的大框）：\n  - 预测框（每个格式为 $[x_1,y_1,x_2,y_2]$）和分数：\n    - $[10,10,60,60]$，分数 $0.95$，\n    - $[12,12,58,58]$，分数 $0.90$，\n    - $[55,10,105,60]$，分数 $0.92$，\n    - $[57,12,103,58]$，分数 $0.85$，\n    - $[20,10,95,60]$，分数 $0.88$。\n  - 真实标签框：\n    - $[10,10,60,60]$，\n    - $[55,10,105,60]$。\n  - 分数阈值 $s_{\\min} = 0.50$，IoU 匹配阈值 $\\tau_{\\mathrm{match}} = 0.50$。\n  - 搜索网格：$t_l \\in \\{0.20,0.30,0.40\\}$，$t_h \\in \\{0.50,0.60,0.70,0.80\\}$，约束条件为 $t_l  t_h$。\n\n- 测试用例 2（$\\mathrm{IoU}$ 等于阈值的边界条件）：\n  - 预测框和分数：\n    - $[10,10,30,30]$，分数 $0.95$，\n    - $[10,10,22,30]$，分数 $0.80$，\n    - $[10,10,22,20]$，分数 $0.70$。\n  - 真实标签框：\n    - $[10,10,30,30]$。\n  - 注意：$[10,10,30,30]$ 和 $[10,10,22,30]$ 之间的 $\\mathrm{IoU}$ 为 $0.60$，和 $[10,10,22,20]$ 之间的 $\\mathrm{IoU}$ 为 $0.30$。\n  - 分数阈值 $s_{\\min} = 0.50$，IoU 匹配阈值 $\\tau_{\\mathrm{match}} = 0.50$。\n  - 搜索网格：$t_l \\in \\{0.30,0.40\\}$，$t_h \\in \\{0.60,0.70\\}$，约束条件为 $t_l  t_h$。\n\n- 测试用例 3（不重叠的预测；测试平局决胜规则）：\n  - 预测框和分数：\n    - $[0,0,20,20]$，分数 $0.90$，\n    - $[40,0,60,20]$，分数 $0.85$，\n    - $[80,0,100,20]$，分数 $0.70$。\n  - 真实标签框：\n    - $[0,0,20,20]$，\n    - $[40,0,60,20]$。\n  - 分数阈值 $s_{\\min} = 0.50$，IoU 匹配阈值 $\\tau_{\\mathrm{match}} = 0.50$。\n  - 搜索网格：$t_l \\in \\{0.20,0.40\\}$，$t_h \\in \\{0.60,0.80\\}$，约束条件为 $t_l  t_h$。\n\n要求：\n- 严格按照规定实现混合 NMS 和验证评估，包括在区间 $[t_l,t_h)$ 上使用线性权重 $w(i) = 1 - \\mathrm{IoU}$，以及对 $\\mathrm{IoU} \\ge t_h$ 的情况使用硬抑制。\n- 对于每个测试用例，在给定的候选集上对 $(t_l,t_h)$ 进行网格搜索（遵守 $t_l  t_h$），找到使 F1 分数最大化的对；通过选择最大的 $t_h$ 来打破平局，如果仍然平局，则选择最小的 $t_l$。\n- 最终输出格式：您的程序应生成单行输出，其中包含最优阈值对的列表，形式为包含两个浮点数的列表的列表，顺序与测试用例相同，每个浮点数四舍五入到三位小数，且无多余空格。例如：$[[0.400,0.800],[0.300,0.700],[0.200,0.800]]$。",
            "solution": "用户提供的问题陈述已经过分析，并被认为是有效的。它在目标检测的深度学习领域具有科学依据，定义明确且一致，表述客观。该任务要求实现一个指定的混合非极大值抑制（NMS）算法，并将其应用于网格搜索过程中以找到最优参数，最后使用标准的 F1 分数指标评估结果。所有必要的数据、函数和评估标准均已提供，从而可以推导出唯一且可验证的解决方案。\n\n解决方案首先按规定实现核心组件：交并比（IoU）计算、混合 NMS 算法和 F1 分数评估指标。然后将这些组件集成到一个网格搜索框架中，为每个提供的测试用例求解最优阈值对。\n\n**1. 交并比（IoU）**\n\n对于两个由其坐标 $[x_1, y_1, x_2, y_2]$ 定义的轴对齐边界框 $A$ 和 $B$，IoU 是衡量它们相对重叠程度的指标。它是它们交集面积与并集面积之比。\n\n- 设框 $A$ 为 $[x_{1A}, y_{1A}, x_{2A}, y_{2A}]$，框 $B$ 为 $[x_{1B}, y_{1B}, x_{2B}, y_{2B}]$。\n- 交集矩形的坐标为：\n  - $x_{1, \\text{inter}} = \\max(x_{1A}, x_{1B})$\n  - $y_{1, \\text{inter}} = \\max(y_{1A}, y_{1B})$\n  - $x_{2, \\text{inter}} = \\min(x_{2A}, x_{2B})$\n  - $y_{2, \\text{inter}} = \\min(y_{2A}, y_{2B})$\n- 交集面积 $A_{\\text{inter}}$ 计算如下：\n$$\nA_{\\text{inter}} = \\max(0, x_{2, \\text{inter}} - x_{1, \\text{inter}}) \\cdot \\max(0, y_{2, \\text{inter}} - y_{1, \\text{inter}})\n$$\n- 每个框的面积为 $\\text{Area}(A) = (x_{2A} - x_{1A}) \\cdot (y_{2A} - y_{1A})$ 和 $\\text{Area}(B) = (x_{2B} - x_{1B}) \\cdot (y_{2B} - y_{1B})$。\n- 并集面积 $A_{\\text{union}}$ 由容斥原理给出：\n$$\nA_{\\text{union}} = \\text{Area}(A) + \\text{Area}(B) - A_{\\text{inter}}\n$$\n- 那么 IoU 为：\n$$\n\\mathrm{IoU}(A, B) = \\frac{A_{\\text{inter}}}{A_{\\text{union}}}\n$$\n处理了一个特殊情况，即当 $A_{\\text{union}} = 0$ 时，$\\mathrm{IoU}$ 定义为 $0$。\n\n**2. 混合非极大值抑制（NMS）**\n\n指定的 NMS 算法是一个迭代过程，旨在修剪冗余的边界框预测。它处理一个初始预测列表，每个预测都有一个置信度分数。\n\n算法流程如下：\n1.  初始化一个空的保留框列表 $R$。设当前预测集为 $P$。保留原始分数和索引以供参考。\n2.  当 $P$ 中存在任何分数大于 $0$ 的框时，循环继续：\n    a. 从 $P$ 中选择当前分数最高的框 $b^\\star$。平局通过选择原始索引最小的框来解决。\n    b. 将 $b^\\star$ 添加到保留框列表 $R$ 中，并存储其被选中时的分数。通过将 $b^\\star$ 的分数设置为非正值等方式，将其从后续选择步骤中移除。\n    c. 对于 $P$ 中剩余的每个其他框 $b_j$：\n        i. 计算重叠度 $o_j = \\mathrm{IoU}(b^\\star, b_j)$。\n        ii. 根据由阈值 $t_l$ 和 $t_h$ 控制的混合抑制规则更新分数 $s(b_j)$：\n           - 如果 $o_j \\ge t_h$：$s(b_j) \\leftarrow 0$（硬抑制）。\n           - 否则，如果 $t_l \\le o_j  t_h$：$s(b_j) \\leftarrow s(b_j) \\cdot (1 - o_j)$（软衰减）。\n           - 否则 ($o_j  t_l$)：分数 $s(b_j)$ 保持不变。\n3.  迭代过程结束后，对保留框列表 $R$ 应用最终的筛选步骤。从 $R$ 中丢弃任何最终分数（即被选中时的分数）低于给定阈值 $s_{\\min}$ 的框。\n4.  输出是最终筛选出的保留框及其分数的列表。\n\n**3. 验证目标：F1 分数**\n\n对于给定的阈值对 $(t_l, t_h)$，NMS 算法的性能通过计算与一组真实标签框的 F1 分数来评估。这涉及一个贪心匹配过程：\n\n1.  将 NMS 输出的预测框集按其最终分数的降序排序。\n2.  执行一对一匹配。对于排序列表中的每个预测框，我们找到与其具有最高 IoU 的真实标签框。\n3.  如果这个最高 IoU 大于或等于匹配阈值 $\\tau_{\\mathrm{match}}$，并且所选的真实标签框尚未被匹配，则该对被视为一次匹配（一个真阳性，TP）。预测框和真实标签框都被标记为已匹配。\n4.  遍历所有预测框后：\n    - 真阳性（TP）是成功匹配的数量。\n    - 假阳性（FP）是无法匹配的预测框的数量。\n    - 假阴性（FN）是未被匹配的真实标签框的数量。\n5.  然后计算 F1 分数。如果 $\\mathrm{TP} + \\mathrm{FP} + \\mathrm{FN} = 0$，则 F1 分数为 $1$。否则，如果 $2 \\cdot \\mathrm{TP} + \\mathrm{FP} + \\mathrm{FN} = 0$，则 F1 分数为 $0$。在所有其他情况下：\n$$\n\\mathrm{F1} = \\frac{2 \\cdot \\mathrm{TP}}{2 \\cdot \\mathrm{TP} + \\mathrm{FP} + \\mathrm{FN}}\n$$\n\n**4. 网格搜索与优化**\n\n对于每个测试用例，目标是从给定的离散搜索网格中找到最优的阈值对 $(t_l, t_h)$。优化目标是最大化 F1 分数。搜索过程会遍历网格中所有有效的 $(t_l, t_h)$ 对（其中 $t_l  t_h$）。选择产生最高 F1 分数的对。\n\n应用确定性的平局决胜规则：\n1.  如果多个对产生相同的最大 F1 分数，则优先选择 $t_h$ 值最大的那个。\n2.  如果仍然存在平局（即多个对共享相同的最大 F1 分数和相同的最大 $t_h$），则选择 $t_l$ 值最小的那个作为最终的最优解。\n\n最终程序实现了这些组件，并对每个测试用例执行网格搜索，以根据这些规范识别并报告最优的 $(t_l, t_h)$ 对。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the solving process for all test cases.\n    It defines test cases, runs the grid search for each, and prints the final results.\n    \"\"\"\n    test_cases = [\n        {\n            \"pred_boxes\": np.array([\n                [10, 10, 60, 60],\n                [12, 12, 58, 58],\n                [55, 10, 105, 60],\n                [57, 12, 103, 58],\n                [20, 10, 95, 60],\n            ]),\n            \"pred_scores\": np.array([0.95, 0.90, 0.92, 0.85, 0.88]),\n            \"gt_boxes\": np.array([\n                [10, 10, 60, 60],\n                [55, 10, 105, 60],\n            ]),\n            \"s_min\": 0.50,\n            \"tau_match\": 0.50,\n            \"tl_grid\": [0.20, 0.30, 0.40],\n            \"th_grid\": [0.50, 0.60, 0.70, 0.80],\n        },\n        {\n            \"pred_boxes\": np.array([\n                [10, 10, 30, 30],\n                [10, 10, 22, 30],\n                [10, 10, 22, 20],\n            ]),\n            \"pred_scores\": np.array([0.95, 0.80, 0.70]),\n            \"gt_boxes\": np.array([\n                [10, 10, 30, 30],\n            ]),\n            \"s_min\": 0.50,\n            \"tau_match\": 0.50,\n            \"tl_grid\": [0.30, 0.40],\n            \"th_grid\": [0.60, 0.70],\n        },\n        {\n            \"pred_boxes\": np.array([\n                [0, 0, 20, 20],\n                [40, 0, 60, 20],\n                [80, 0, 100, 20],\n            ]),\n            \"pred_scores\": np.array([0.90, 0.85, 0.70]),\n            \"gt_boxes\": np.array([\n                [0, 0, 20, 20],\n                [40, 0, 60, 20],\n            ]),\n            \"s_min\": 0.50,\n            \"tau_match\": 0.50,\n            \"tl_grid\": [0.20, 0.40],\n            \"th_grid\": [0.60, 0.80],\n        },\n    ]\n\n    all_optimal_pairs = []\n\n    for case in test_cases:\n        best_f1 = -1.0\n        best_tl = -1.0\n        best_th = -1.0\n\n        for t_h in case[\"th_grid\"]:\n            for t_l in case[\"tl_grid\"]:\n                if t_l >= t_h:\n                    continue\n\n                # Run hybrid NMS\n                final_preds = hybrid_nms(\n                    case[\"pred_boxes\"], case[\"pred_scores\"],\n                    t_l, t_h, case[\"s_min\"]\n                )\n\n                # Evaluate F1 score\n                current_f1 = calculate_f1_score(\n                    final_preds, case[\"gt_boxes\"], case[\"tau_match\"]\n                )\n                \n                # Update best thresholds based on F1 and tie-breaking rules\n                if current_f1 > best_f1:\n                    best_f1 = current_f1\n                    best_tl = t_l\n                    best_th = t_h\n                elif current_f1 == best_f1:\n                    if t_h > best_th:\n                        best_tl = t_l\n                        best_th = t_h\n                    elif t_h == best_th:\n                        if t_l  best_tl:\n                            best_tl = t_l\n        \n        all_optimal_pairs.append([best_tl, best_th])\n\n    # Format the final output string exactly as required\n    formatted_pairs = [f\"[{p[0]:.3f},{p[1]:.3f}]\" for p in all_optimal_pairs]\n    print(f\"[{','.join(formatted_pairs)}]\")\n\ndef calculate_iou(boxA, boxB):\n    \"\"\"Calculates Intersection over Union for two boxes.\"\"\"\n    xA = max(boxA[0], boxB[0])\n    yA = max(boxA[1], boxB[1])\n    xB = min(boxA[2], boxB[2])\n    yB = min(boxA[3], boxB[3])\n\n    inter_area = max(0, xB - xA) * max(0, yB - yA)\n    \n    boxA_area = (boxA[2] - boxA[0]) * (boxA[3] - boxA[1])\n    boxB_area = (boxB[2] - boxB[0]) * (boxB[3] - boxB[1])\n    \n    union_area = boxA_area + boxB_area - inter_area\n    \n    iou = inter_area / union_area if union_area > 0 else 0.0\n    return iou\n\ndef hybrid_nms(boxes, scores, t_l, t_h, s_min):\n    \"\"\"\n    Implements the specified hybrid Non-Maximum Suppression algorithm.\n    \"\"\"\n    num_boxes = len(boxes)\n    # Using original indices for tie-breaking\n    indices = np.arange(num_boxes)\n    current_scores = np.copy(scores)\n    \n    selected_boxes_info = []\n    \n    # We need to maintain a pool of available indices to select from\n    available_indices = list(range(num_boxes))\n\n    while True:\n        # Find index of box with highest score among available boxes\n        best_idx_in_pool = -1\n        max_score = -1.0\n        \n        # We must consider original index for tie-breaking\n        pool_to_check = sorted(available_indices, key=lambda i: (-current_scores[i], i))\n        \n        if not pool_to_check or current_scores[pool_to_check[0]] = 0:\n            break\n            \n        best_idx = pool_to_check[0]\n        \n        best_box = boxes[best_idx]\n        best_score = current_scores[best_idx]\n        \n        selected_boxes_info.append({\"box\": best_box, \"score\": best_score, \"original_index\": best_idx})\n        \n        # Remove the selected box from the pool of available boxes\n        available_indices.remove(best_idx)\n        \n        indices_to_remove = []\n        for i in available_indices:\n            iou = calculate_iou(best_box, boxes[i])\n            \n            if iou >= t_h:\n                current_scores[i] = 0.0  # Hard suppression\n            elif t_l = iou  t_h:\n                current_scores[i] *= (1.0 - iou) # Soft attenuation\n\n    # Filter selected boxes by minimum score threshold\n    final_preds = [\n        p for p in selected_boxes_info if p[\"score\"] >= s_min\n    ]\n    return final_preds\n\ndef calculate_f1_score(pred_boxes_info, gt_boxes, tau_match):\n    \"\"\"\n    Calculates the F1 score based on greedy matching between predictions and ground truth.\n    \"\"\"\n    num_preds = len(pred_boxes_info)\n    num_gts = len(gt_boxes)\n\n    if num_gts == 0:\n      return 1.0 if num_preds == 0 else 0.0\n    if num_preds == 0:\n      return 0.0\n\n    # Sort predictions by score in descending order\n    sorted_preds = sorted(pred_boxes_info, key=lambda x: x[\"score\"], reverse=True)\n    \n    gt_matched = [False] * num_gts\n    tp = 0\n    \n    for pred in sorted_preds:\n        best_iou = -1.0\n        best_gt_idx = -1\n        \n        for i in range(num_gts):\n            if not gt_matched[i]:\n                iou = calculate_iou(pred[\"box\"], gt_boxes[i])\n                if iou > best_iou:\n                    best_iou = iou\n                    best_gt_idx = i\n        \n        if best_iou >= tau_match and best_gt_idx != -1:\n            tp += 1\n            gt_matched[best_gt_idx] = True\n\n    fp = num_preds - tp\n    fn = num_gts - sum(gt_matched)\n    \n    denominator = 2 * tp + fp + fn\n    if denominator == 0:\n        return 1.0\n\n    return (2 * tp) / denominator\n\n# Execute the main function\nsolve()\n```"
        },
        {
            "introduction": "非最大抑制的核心思想——基于交并比（IoU）度量来抑制重叠检测——具有很强的通用性，其应用远不止于边界框。本练习  将NMS的应用从目标检测扩展到了实例分割领域。你将实现基于实例掩码（mask）的IoU计算，并将其用于NMS过程，并定量地验证一个重要假设：在拥挤的场景中，基于掩码的NMS能够比基于边界框的NMS更准确，有效避免因物体紧密贴合而导致的错误抑制。",
            "id": "3159563",
            "problem": "您的任务是形式化并检验一个假设：在多个实例空间上彼此靠近的拥挤场景中，基于实例掩码的非极大值抑制（掩码非极大值抑制）比基于轴对齐边界框的非极大值抑制（边界框非极大值抑制）抑制更少的真正例。您的程序必须实现这两种策略，并在您将从第一性原理构建的合成场景族上对它们进行评估。\n\n从以下基本定义和事实开始。\n\n1. 令每个预测实例都表示为一个几何集合和一个实值置信度分数。边界框是平面中的一个闭合轴对齐正方形，而掩码是描述实例所占区域的一个闭合集合。对于平面中具有有限面积（勒贝格测度）的两个集合 $A$ 和 $B$，定义交集面积为 $\\mu(A \\cap B)$，并集面积为 $\\mu(A \\cup B)$。交并比（Intersection-over-Union）相似度为 $\\mathrm{IoU}(A,B) = \\frac{\\mu(A \\cap B)}{\\mu(A \\cup B)}$，其中 $\\mu(A \\cup B) \\neq 0$。\n\n2. 非极大值抑制（NMS）是一种对按置信度分数降序排列的检测列表进行的贪心选择。给定一个阈值 $\\tau \\in (0,1)$ 和一个满足 $S \\in [0,1]$ 的相似度函数 $S(\\cdot,\\cdot)$，该算法按以下步骤进行：\n   - 按分数降序对检测进行排序。\n   - 遍历排序后的列表：如果一个检测 $d$ 与所有先前保留的检测的相似度严格小于 $\\tau$，则保留该检测；否则，抑制该检测。\n   - 我们明确定义当 $S \\ge \\tau$ 时进行抑制，当 $S  \\tau$ 时保留。\n   在边界框非极大值抑制中，$S$ 是在轴对齐正方形（边界框）之间计算的 $\\mathrm{IoU}$。在掩码非极大值抑制中，$S$ 是在实例掩码之间计算的 $\\mathrm{IoU}$。\n\n3. 考虑一个合成的拥挤场景，该场景构建为一个实例中心的整数网格，沿水平和垂直方向的间距为 $(g_x,g_y)$。每个实例 $i$ 具有：\n   - 一个边界框，是边长为 $s > 0$ 的正方形，中心位于其网格位置。\n   - 一个掩码，可以是：\n     - 一个半径为 $r$ 的圆盘（填充的圆形），中心位于相同位置，其中 $0  r \\le s/2$，或者\n     - 与边界框相同的正方形（因此掩码与边界框重合）。\n   您必须使用精确的几何公式计算两个轴对齐正方形的交集面积和两个圆盘的交集面积。如果您使用反三角函数计算圆盘交集，请使用弧度。不要通过离散化进行近似。\n\n4. 对于一个中心为 $(x_i,y_i)$ 和 $(x_j,y_j)$ 的网格，其中 $|x_i-x_j| = \\Delta x$ 且 $|y_i-y_j| = \\Delta y$，两个边长为 $s$ 的轴对齐正方形的重叠面积为 $\\max(0, s - \\Delta x) \\cdot \\max(0, s - \\Delta y)$，如果任一因子非正，则面积为 $0$。并集面积是两面积之和减去交集面积。两个半径相等为 $r$、中心距为 $d$ 的圆盘之间的交集面积，是关于 $d$、$r$ 和反余弦函数的已知封闭形式，必须精确使用。并集面积是两圆盘面积之和减去交集面积。\n\n5. 定义错误抑制为当所有检测都代表不同的基准真相实例时（即，没有针对同一对象的重复检测），算法抑制的任何实例。在这种情况下，理想的算法会保留所有检测；任何抑制都是一个错误，错误抑制计数等于被抑制的检测数量。\n\n您的任务是：\n\nA. 从这些定义出发，且不引入任何未经检验的假设，推导出在何种条件 $(s,g_x,g_y,r,\\tau)$ 下，边界框非极大值抑制会抑制一对相邻实例，而掩码非极大值抑制则不会抑制同一对实例。您的推导应仅使用上述几何和测度论定义以及标准的面积解析公式。解释为什么当间距很紧时，半径 $r  s/2$ 的圆盘掩码相对于边界框交并比，可以降低掩码交并比，从而使掩码非极大值抑制更不容易发生抑制。\n\nB. 精确地按照定义实现这两种算法，使用：\n   - 边界框为边长为 $s$ 的轴对齐正方形。\n   - 掩码可以是半径为 $r$ 的圆盘，或与边界框相同的正方形。\n   - 相似度 $S$ 分别为边界框和掩码计算的 $\\mathrm{IoU}$。\n   - 当 $S \\ge \\tau$ 时进行抑制。\n\nC. 在以下测试套件上评估算法。在所有情况下，按行主序索引以严格降序分配唯一分数，以便左上角的实例得分最高，然后从左到右、从上到下进行。\n\n- 测试用例1（掩码非极大值抑制预期抑制更少的理想拥挤网格）：网格大小 $3 \\times 3$，间距 $(g_x,g_y) = (10,10)$，正方形边长 $s = 40$，圆盘半径 $r = 12$，阈值 $\\tau = 0.5$，掩码为圆盘。任何反三角表达式中的角度必须以弧度为单位。\n\n- 测试用例2（相等边界条件）：网格大小 $1 \\times 3$，间距 $(g_x,g_y) = (10,1000)$，正方形边长 $s = 40$，圆盘半径 $r = 12$，阈值 $\\tau = 0.6$，掩码为圆盘。这将隔离出一个一维链，使得最近邻的边界框交并比等于阈值。\n\n- 测试用例3（掩码等于边界框）：网格大小 $3 \\times 3$，间距 $(g_x,g_y) = (10,10)$，正方形边长 $s = 40$，阈值 $\\tau = 0.5$，掩码与边界框为相同的正方形。这将强制掩码非极大值抑制与边界框非极大值抑制匹配。\n\n- 测试用例4（无重叠）：网格大小 $2 \\times 2$，间距 $(g_x,g_y) = (50,50)$，正方形边长 $s = 40$，圆盘半径 $r = 12$，阈值 $\\tau = 0.5$，掩码为圆盘。这确保两种形状都没有重叠。\n\n您的程序必须按顺序为每个测试用例计算一个三元组，包括：边界框非极大值抑制的整数错误抑制计数，掩码非极大值抑制的整数错误抑制计数，以及一个布尔值，指示在该测试用例上，掩码非极大值抑制是否产生了严格小于边界框非极大值抑制的错误抑制计数。\n\n最终输出格式：您的程序应生成一行输出，其中包含所有结果，连接成一个用方括号括起来的逗号分隔列表。对于每个测试用例，按顺序附加三个输出。例如，输出形式应为 $[b_1,m_1,f_1,b_2,m_2,f_2,b_3,m_3,f_3,b_4,m_4,f_4]$，其中 $b_k$ 和 $m_k$ 是整数，$f_k$ 是布尔值。",
            "solution": "问题陈述已经过验证，被认为是科学上合理的、定义明确的、客观的且内部一致的。它为检验基于掩码的非极大值抑制（NMS）在拥挤场景中可以优于基于边界框的NMS这一假设提供了一个正式的框架。我们将继续提供解决方案。\n\n根据要求，解决方案分为三个部分：理论推导、实现概述以及在指定测试套件上的评估。\n\n### A. 推导与理论分析\n\n问题的核心是确定在何种条件下，边界框NMS会抑制一对邻近的对象检测，而掩码NMS则不会。当一对检测的相似度分数对于边界框超过阈值 $\\tau$ 但对于掩码未超过时，就会发生这种情况。令两个实例由其几何集合 $A$ 和 $B$ 表示。交并比（IoU）由 $\\mathrm{IoU}(A,B) = \\frac{\\mu(A \\cap B)}{\\mu(A \\cup B)}$ 给出。由于给定类型（边界框或掩码）的所有实例在形状和大小上都是相同的，因此它们的面积相等：$\\mu(A) = \\mu(B)$。并集面积为 $\\mu(A \\cup B) = \\mu(A) + \\mu(B) - \\mu(A \\cap B) = 2\\mu(A) - \\mu(A \\cap B)$。那么IoU为：\n$$ \\mathrm{IoU}(A,B) = \\frac{\\mu(A \\cap B)}{2\\mu(A) - \\mu(A \\cap B)} $$\n这是关于交集面积 $\\mu(A \\cap B)$ 的单调递增函数。\n\n让我们分析网格上的两个最近邻实例，例如，两个实例在水平方向上被网格间距 $g_x$ 分隔。它们的中心距为 $d = g_x$。我们假设对于边界框，$g_x  s$ 以便重叠；对于圆盘，$g_x  2r$ 以便重叠。\n\n**1. 边界框非极大值抑制 (Box NMS)**\n对于两个边长为 $s$ 的轴对齐正方形，其中心被 $(\\Delta x, \\Delta y) = (g_x, 0)$ 分隔，交集面积为：\n$$ \\mu(B_1 \\cap B_2) = \\max(0, s - g_x) \\cdot \\max(0, s - 0) = s(s - g_x) $$\n单个边界框的面积是 $\\mu(B) = s^2$。边界框的IoU为：\n$$ \\mathrm{IoU}_{box} = \\frac{s(s-g_x)}{2s^2 - s(s-g_x)} = \\frac{s(s-g_x)}{s^2 + sg_x} = \\frac{s-g_x}{s+g_x} $$\n\n**2. 掩码非极大值抑制（使用圆盘掩码）**\n对于两个半径为 $r$ 的圆盘，其中心相距 $d = g_x$，当 $0 \\le d \\le 2r$ 时，交集面积由两个重叠圆形成的透镜面积公式给出：\n$$ \\mu(M_1 \\cap M_2) = 2r^2 \\cos^{-1}\\left(\\frac{d}{2r}\\right) - \\frac{d}{2}\\sqrt{4r^2 - d^2} $$\n单个圆盘的面积是 $\\mu(M) = \\pi r^2$。掩码的IoU为：\n$$ \\mathrm{IoU}_{mask} = \\frac{\\mu(M_1 \\cap M_2)}{2\\pi r^2 - \\mu(M_1 \\cap M_2)} $$\n\n**3. 差异化抑制的条件**\n根据抑制规则 $S \\ge \\tau$，当以下联合条件成立时，边界框NMS会抑制该对实例而掩码NMS不会：\n$$ \\mathrm{IoU}_{box} \\ge \\tau \\quad \\land \\quad \\mathrm{IoU}_{mask}  \\tau $$\n代入推导出的表达式，我们得到关于参数 $(s, g_x, r, \\tau)$ 的明确条件：\n$$ \\frac{s-g_x}{s+g_x} \\ge \\tau \\quad \\land \\quad \\frac{2r^2 \\cos^{-1}\\left(\\frac{g_x}{2r}\\right) - \\frac{g_x}{2}\\sqrt{4r^2 - g_x^2}}{2\\pi r^2 - \\left(2r^2 \\cos^{-1}\\left(\\frac{g_x}{2r}\\right) - \\frac{g_x}{2}\\sqrt{4r^2 - g_x^2}\\right)}  \\tau $$\n\n**4. IoU差异的解释**\n在相关条件下 $\\mathrm{IoU}_{mask}  \\mathrm{IoU}_{box}$ 的假设是基于表示的几何“紧密性”。更紧密的掩码减少了虚假的重叠。\n- 轴对齐的正方形边界框是对许多对象形状的宽松近似。对于半径为 $r$ 的圆盘，最小边界正方形的边长必须为 $s = 2r$。该边界框的面积为 $s^2 = 4r^2$，而圆盘的面积为 $\\pi r^2 \\approx 3.14r^2$。边界框在其角部包含“空白”区域，约 $4r^2 - \\pi r^2 \\approx 0.86r^2$，超过了边界框面积的21%。问题陈述允许 $r \\le s/2$，因此这种差异可能更大。\n- 当两个这样的边界框重叠时，这些空白的角部区域可能对交集面积 $\\mu(B_1 \\cap B_2)$ 有贡献，从而人为地夸大了相对于真实对象重叠的面积。作为该交集函数的IoU因此也更高。\n- 圆盘掩码是一种“更紧密”的表示。交集面积 $\\mu(M_1 \\cap M_2)$ 对应于实例的实际重叠。\n- IoU是相对交集面积 $\\rho = \\frac{\\mu(A \\cap B)}{\\mu(A)}$ 的单调递增函数。为了使 $\\mathrm{IoU}_{box} > \\mathrm{IoU}_{mask}$，我们需要 $\\rho_{box} > \\rho_{mask}$。\n$$ \\rho_{box} = \\frac{s(s-g_x)}{s^2} = 1 - \\frac{g_x}{s} $$\n$$ \\rho_{mask} = \\frac{2r^2 \\cos^{-1}\\left(\\frac{g_x}{2r}\\right) - \\frac{g_x}{2}\\sqrt{4r^2 - g_x^2}}{\\pi r^2} $$\n对于小的间距 $g_x$ 和远小于 $s/2$ 的圆盘半径 $r$，边界框的重叠比率 $\\rho_{box}$ 通常大于圆盘的重叠比率 $\\rho_{mask}$。边界框作为一种更粗糙的近似，高估了重叠，导致更高的IoU，并在拥挤场景中更容易导致错误抑制。\n\n### B. 实现策略\n\n该实现将包括几个组件：几何效用函数、一个通用的NMS函数，以及一个执行测试用例的主例程。\n\n**1. 数据结构：**\n每个检测将表示为一个包含其ID、分数和中心坐标的字典：`{'id': k, 'score': score, 'center': (cx, cy)}`。所有检测的列表按分数降序排序，为NMS算法做准备。\n\n**2. 几何计算函数：**\n- `box_iou(center1, center2, s)`：此函数计算两个边长为 $s$ 的正方形之间的IoU。它接收两个中心点，计算间距 $\\Delta x$ 和 $\\Delta y$，计算交集面积 $\\max(0, s - \\Delta x) \\cdot \\max(0, s - \\Delta y)$，并由此计算并集和IoU。\n- `disk_iou(center1, center2, r)`：此函数计算两个半径为 $r$ 的圆盘之间的IoU。它计算中心之间的欧几里得距离 $d$。它处理三种情况：如果 $d \\ge 2r$，交集为 $0$；如果 $d=0$，交集为 $\\pi r^2$（IoU为 $1$）；否则，它应用透镜面积的封闭形式公式。然后计算并集和IoU。\n\n**3. 非极大值抑制算法：**\n一个单独的函数 `perform_nms(detections, tau, similarity_func)` 将实现NMS逻辑。\n- **输入**：一个已排序的 `detections` 列表、一个抑制阈值 `tau`，以及一个 `similarity_func`（可以是 `box_iou` 或 `disk_iou`，并适配处理检测字典）。\n- **过程**：该函数遍历已排序的检测。它维护一个 `kept_detections` 列表。对于每个新检测，它计算其与 `kept_detections` 中每个已保留检测的相似度。如果与任何已保留检测的相似度大于或等于 `tau` ($\\ge$)，则将新检测标记为被抑制。否则，将其添加到 `kept_detections` 列表中。\n- **输出**：该函数返回被抑制检测的总数。\n\n### C. 测试套件评估\n\n程序将系统地评估提供的四个测试用例中的每一个。对于每个用例：\n1.  根据指定的网格大小、间距和评分规则（按行主序索引降序）生成检测列表。\n2.  调用 `perform_nms` 函数两次：\n    a. 一次用于边界框NMS，使用边长为 $s$ 的 `box_iou` 计算器。\n    b. 一次用于掩码NMS，使用适当的相似度计算器：对于圆盘掩码，使用半径为 $r$ 的 `disk_iou`；如果掩码是正方形，则使用边长为 $s$ 的 `box_iou`。\n3.  记录两种方法的错误抑制数量。\n4.  计算一个布尔标志，以指示掩码NMS的抑制计数是否严格小于边界框NMS的计数。\n5.  存储得到的三元组（边界框抑制数，掩码抑制数，布尔标志）。\n最后，将所有结果汇总到一个列表中，并以指定格式打印。实现将使用 `numpy` 来获取精确的数学常数和函数。",
            "answer": "```python\nimport numpy as np\n\ndef get_disk_intersection_area(d, r):\n    \"\"\"\n    Calculates the intersection area of two disks of equal radius.\n    \n    Args:\n        d (float): Distance between the centers of the two disks.\n        r (float): Radius of the disks.\n\n    Returns:\n        float: The intersection area. Returns 0 if d >= 2*r.\n    \"\"\"\n    if d >= 2 * r:\n        return 0.0\n    if d == 0.0:\n        return np.pi * r**2\n    # From the formula for the area of a circular segment/lens\n    term1 = 2 * r**2 * np.arccos(d / (2 * r))\n    term2 = (d / 2) * np.sqrt(4 * r**2 - d**2)\n    return term1 - term2\n\ndef box_similarity(det1, det2, s):\n    \"\"\"Calculates IoU for two square boxes.\"\"\"\n    center1 = det1['center']\n    center2 = det2['center']\n    delta_x = abs(center1[0] - center2[0])\n    delta_y = abs(center1[1] - center2[1])\n\n    if delta_x >= s or delta_y >= s:\n        intersection_area = 0.0\n    else:\n        intersection_area = (s - delta_x) * (s - delta_y)\n\n    if intersection_area == 0.0:\n        return 0.0\n    \n    area_box = s**2\n    union_area = 2 * area_box - intersection_area\n    \n    return intersection_area / union_area\n\ndef disk_similarity(det1, det2, r):\n    \"\"\"Calculates IoU for two disk masks.\"\"\"\n    center1 = det1['center']\n    center2 = det2['center']\n    d = np.sqrt((center1[0] - center2[0])**2 + (center1[1] - center2[1])**2)\n    \n    intersection_area = get_disk_intersection_area(d, r)\n\n    if intersection_area == 0.0:\n        return 0.0\n\n    area_disk = np.pi * r**2\n    union_area = 2 * area_disk - intersection_area\n    \n    return intersection_area / union_area\n\ndef perform_nms(detections, tau, similarity_func, **kwargs):\n    \"\"\"\n    Performs non-maximum suppression on a list of detections.\n    \n    Args:\n        detections (list): A list of detection dictionaries, sorted by score.\n        tau (float): The IoU threshold for suppression.\n        similarity_func (function): The function to compute similarity (IoU).\n        **kwargs: Additional parameters for the similarity function (e.g., s or r).\n\n    Returns:\n        int: The number of suppressed detections.\n    \"\"\"\n    kept_detections = []\n    suppressed_count = 0\n\n    # Detections are already sorted by score\n    for det in detections:\n        is_suppressed = False\n        for kept_det in kept_detections:\n            similarity = similarity_func(det, kept_det, **kwargs)\n            if similarity >= tau:\n                is_suppressed = True\n                break # A detection is suppressed if it overlaps with ANY already kept detection\n        \n        if is_suppressed:\n            suppressed_count += 1\n        else:\n            kept_detections.append(det)\n            \n    return suppressed_count\n\ndef solve():\n    \"\"\"\n    Main function to run the NMS evaluation on the given test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1: Crowded grid, disk mask. Expect mask NMS to be better.\n        {'grid_dims': (3, 3), 'spacing': (10, 10), 's': 40, 'r': 12, 'tau': 0.5, 'mask_type': 'disk'},\n        # Case 2: 1D boundary condition.\n        {'grid_dims': (1, 3), 'spacing': (10, 1000), 's': 40, 'r': 12, 'tau': 0.6, 'mask_type': 'disk'},\n        # Case 3: Masks are squares, should be identical to box NMS.\n        {'grid_dims': (3, 3), 'spacing': (10, 10), 's': 40, 'r': None, 'tau': 0.5, 'mask_type': 'square'},\n        # Case 4: No overlap.\n        {'grid_dims': (2, 2), 'spacing': (50, 50), 's': 40, 'r': 12, 'tau': 0.5, 'mask_type': 'disk'},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        grid_h, grid_w = case['grid_dims']\n        g_x, g_y = case['spacing']\n        s = case['s']\n        r = case['r']\n        tau = case['tau']\n        mask_type = case['mask_type']\n\n        # Generate detections, sorted by score (descending) based on row-major index\n        detections = []\n        num_detections = grid_h * grid_w\n        for i in range(grid_h):\n            for j in range(grid_w):\n                idx = i * grid_w + j\n                detection = {\n                    'id': idx,\n                    'score': num_detections - idx,\n                    'center': (j * g_x, i * g_y)\n                }\n                detections.append(detection)\n\n        # Run Box NMS\n        box_suppressions = perform_nms(detections, tau, box_similarity, s=s)\n\n        # Run Mask NMS\n        if mask_type == 'disk':\n            mask_suppressions = perform_nms(detections, tau, disk_similarity, r=r)\n        elif mask_type == 'square':\n            # Masks are the same as boxes\n            mask_suppressions = perform_nms(detections, tau, box_similarity, s=s)\n        \n        less_suppressions = mask_suppressions  box_suppressions\n\n        results.extend([box_suppressions, mask_suppressions, str(less_suppressions).lower()])\n\n    # The final output format requires a single line string representation of the list.\n    # e.g., [b1,m1,f1,b2,m2,f2,...] where f is a boolean.\n    print(str(results).replace(\"'\", \"\").replace(\" \", \"\"))\n\nsolve()\n```"
        }
    ]
}