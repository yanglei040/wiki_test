{
    "hands_on_practices": [
        {
            "introduction": "理论是根基，但亲手实现是理解的最佳途径。本练习将指导你从零开始构建一个简单的$C_4$群卷积层。通过这个过程，你将直观地看到权重共享（即使用单一基础核的旋转副本来生成所有方向的滤波器）是如何从数学上保证网络层对旋转操作具备等变性的。这个练习不仅会验证等变性，还会通过一个对比实验，展示在没有这种特定权重共享结构时，等变性将不复存在。",
            "id": "3180084",
            "problem": "您需要实现并测试一个群卷积，该卷积作用于由 $90^\\circ$ 旋转生成的四阶循环群（平面旋转群）。此任务基于离散二维卷积的核心定义（实现为无卷积核翻转的离散二维互相关，并采用有效窗口）以及旋转对数组的作用。您必须仅从这些基本定义出发，通过权重共享构建一个旋转等变映射，并精确验证其行为。\n\n使用的定义和设置：\n- 设 $X \\in \\mathbb{R}^{H \\times W}$ 为方形网格上的实值图像，设 $K \\in \\mathbb{R}^{k_h \\times k_w}$ 为实值卷积核。\n- 定义旋转算子 $R_m$（其中 $m \\in \\{0,1,2,3\\}$），其作用于任意数组，将其在平面内连续旋转 $m$ 次 $90^\\circ$（以度为单位）。也就是说，$R_0$ 是恒等变换，$R_1$ 旋转 $90^\\circ$，$R_2$ 旋转 $180^\\circ$，$R_3$ 旋转 $270^\\circ$。角度单位应理解为度。\n- 将带有效窗口的离散二维互相关定义为：对于卷积核完全覆盖图像的每个空间位置，进行逐元素相乘并求和。该操作将输出形状缩减为 $(H - k_h + 1) \\times (W - k_w + 1)$。\n- 定义四阶循环群（记为 $C_4$）上的群卷积，通过 $Y_g = X \\star R_g K$ 生成由 $g \\in \\{0,1,2,3\\}$ 索引的四个方向通道。此处使用上述互相关运算，其中 $R_g K$ 是将卷积核旋转 $g$ 个90度的结果。由于所有 $Y_g$ 都是使用单个基础卷积核 $K$ 的旋转副本计算得出的，这强制实现了跨方向的权重共享。\n- 需要验证的旋转等变性是指：对于 $m \\in \\{0,1,2,3\\}$，如果输入被旋转为 $X' = R_m X$，那么由 $X'$ 和相同的共享基础卷积核计算出的群卷积输出 $Y'_g$ 满足 $Y'_g = R_m \\, Y_{g - m}$，其中索引运算为模4算术。这里 $Y_{g - m}$ 表示由 $(g - m) \\bmod 4$ 索引的方向通道。\n\n您的程序必须：\n1. 使用 $m$ 次连续的 $90^\\circ$ 旋转在数组上实现 $R_m$。\n2. 实现上述带有效窗口的离散二维互相关。\n3. 通过 $R_g K$ 实现带权重共享的 $C_4$ 群卷积 $X \\mapsto (Y_0,Y_1,Y_2,Y_3)$。\n4. 对于每个测试用例，计算一个布尔值，断言等变性陈述 $Y'_g = R_m \\, Y_{g - m}$ 对所有 $g \\in \\{0,1,2,3\\}$ 在 $10^{-9}$ 的绝对容差内成立。其中 $Y'_g$ 是将相同的 $C_4$ 群卷积应用于 $X' = R_m X$ 和相同的基础卷积核 $K$ 计算得出的。\n5. 包括一个对比测试，其中四个方向通道使用四个不相关、不共享的卷积核 $(K_0,K_1,K_2,K_3)$（这些卷积核之间没有旋转关系）计算。在该测试中，断言相同的等变性条件，并报告布尔结果（该结果通常为假），从而证明跨旋转副本的权重共享是实现旋转等变性的强制机制。\n\n测试套件规范：\n- 测试用例 $1$ (一般情况)：$X$ 的尺寸为 $6 \\times 6$，从伪随机种子为 $1$ 的标准正态分布中抽取；$K$ 的尺寸为 $3 \\times 3$，从伪随机种子为 $0$ 的标准正态分布中抽取；旋转索引 $m = 1$，对应 $90^\\circ$。\n- 测试用例 $2$ (偶数尺寸卷积核的边界行为)：$X$ 的尺寸为 $5 \\times 5$，种子为 $3$；$K$ 的尺寸为 $2 \\times 2$，种子为 $2$；旋转索引 $m = 1$，对应 $90^\\circ$。\n- 测试用例 $3$ (多步旋转)：$X$ 的尺寸为 $7 \\times 7$，种子为 $5$；$K$ 的尺寸为 $3 \\times 3$，种子为 $4$；旋转索引 $m = 2$，对应 $180^\\circ$。\n- 测试用例 $4$ (恒等变换)：$X$ 的尺寸为 $6 \\times 6$，种子为 $7$；$K$ 的尺寸为 $3 \\times 3$，种子为 $6$；旋转索引 $m = 0$，对应 $0^\\circ$。\n- 测试用例 $5$ (结构化输入)：$X$ 的尺寸为 $8 \\times 8$，所有元素设为1；$K$ 的尺寸为 $3 \\times 3$，种子为 $8$；旋转索引 $m = 3$，对应 $270^\\circ$。\n- 测试用例 $6$ (无权重共享的对比测试)：$X$ 的尺寸为 $6 \\times 6$，种子为 $9$；四个不相关的卷积核 $(K_0,K_1,K_2,K_3)$，尺寸均为 $3 \\times 3$，分别使用种子 $10, 11, 12, 13$ 生成；旋转索引 $m = 1$，对应 $90^\\circ$。在这种情况下，使用 $Y_g = X \\star K_g$ 和 $Y'_g = (R_m X) \\star K_g$ 计算四个方向通道，并检查 $Y'_g = R_m \\, Y_{g - m}$ 是否对所有 $g$ 成立，报告布尔结果。\n\n数值容差规范：\n- 在比较数组是否相等时，使用 $10^{-9}$ 的绝对容差和 $0$ 的相对容差。\n\n最终输出格式：\n- 您的程序应生成一行输出，包含测试用例 $1$ 到 $6$ 的六个布尔结果，按顺序排列，形式为一个逗号分隔的列表，用方括号括起来，例如 `[true,false,true,false,true,false]`。使用 Python 的布尔字面量，因此实际输出应类似于 `[True,False,True,False,True,False]`。",
            "solution": "该问题要求针对一种特定类型的卷积层——群卷积，实现并验证其旋转等变性。该群卷积定义在4个平面旋转（$C_4 = \\{0^\\circ, 90^\\circ, 180^\\circ, 270^\\circ\\}$）构成的循环群上。任务的核心是从基本原理出发，证明通过特定权重共享方案构建的卷积映射对其输入的旋转具有等变性。\n\n等变性是物理学和机器学习中的一个基本概念。如果一个函数或系统 $\\Phi$ 对一组变换 $G$ 是等变的，那么将 $G$ 中的一个变换应用于系统输入，会产生一个可预测的变换后输出。更正式地说，对于群 $G$ 中的任意变换 $T_g$，在输出空间上存在一个对应的变换 $T'_g$，使得 $\\Phi(T_g(X)) = T'_g(\\Phi(X))$。这个性质是理想的，因为它确保系统对一个物体的分析与其方向或位置无关。\n\n我们的目标是为一个 $C_4$ 群卷积验证以下等变性恒等式：当输入图像 $X$ 被旋转 $m$ 个90度，得到 $X' = R_m X$ 时，所产生的输出特征图集合 $(Y'_0, Y'_1, Y'_2, Y'_3)$ 是原始输出图 $(Y_0, Y_1, Y_2, Y_3)$ 经过旋转和置换后的版本。具体来说，需要验证的恒等式是 $Y'_g = R_m Y_{(g - m) \\pmod 4}$，对每个方向通道 $g \\in \\{0, 1, 2, 3\\}$ 成立。\n\n解决方案根据所提供的定义分步构建。\n\n**1. 旋转算子 $R_m$**\n\n变换群是循环群 $C_4$，其元素对应于角度为 $\\{0^\\circ, 90^\\circ, 180^\\circ, 270^\\circ\\}$ 的旋转。我们定义一个算子 $R_m$，它作用于一个二维数组，将其逆时针连续旋转 $m$ 次 $90^\\circ$，其中 $m \\in \\{0, 1, 2, 3\\}$。此操作可以直接使用已有的数值库函数来实现，这些函数能在矩阵上执行旋转。$R_m$ 作用于一个形状为 $H \\times W$ 的数组，如果 $m$ 是奇数，结果数组的形状为 $W \\times H$；如果 $m$ 是偶数，则形状为 $H \\times W$。\n\n**2. 离散二维互相关**\n\n基本的构建模块是离散二维互相关运算，记为 $\\star$。给定输入图像 $X \\in \\mathbb{R}^{H \\times W}$ 和卷积核 $K \\in \\mathbb{R}^{k_h \\times k_w}$，计算输出特征图 $Y = X \\star K$。该操作指定使用“有效”窗口，意味着只对卷积核完全与输入重叠的位置计算输出。每个输出位置 $(i, j)$ 的值是卷积核与输入相应子区域的逐元素乘积之和。\n$$Y[i,j] = \\sum_{u=0}^{k_h-1} \\sum_{v=0}^{k_w-1} X[i+u, j+v] K[u,v]$$\n此操作产生的输出图尺寸为 $(H - k_h + 1) \\times (W - k_w + 1)$。这与完整的卷积不同，后者会涉及翻转卷积核。\n\n**3. 通过权重共享实现的 $C_4$ 群卷积**\n\n标准的卷积层本身不具备旋转等变性。为了构建一个 $C_4$ 等变层，我们强制采用一种称为权重共享的特定结构。我们不为不同方向学习独立的卷积核，而是使用一个单一的基础卷积核 $K$，并通过对其应用群的变换来生成所有其他必要的卷积核。\n\n$C_4$ 群卷积的输出由四个方向通道 $(Y_0, Y_1, Y_2, Y_3)$ 组成，由群的元素 $g \\in \\{0, 1, 2, 3\\}$ 索引。每个通道 $Y_g$ 是通过将输入图像 $X$ 与基础卷积核 $K$ 的旋转版本进行卷积计算得出的：\n$$Y_g = X \\star (R_g K)$$\n这里，$R_g K$ 是将卷积核 $K$ 旋转 $g$ 个90度的结果。这种构造确保了该层在四个通道中检测到的特征是相同的，只是方向不同。\n\n**4. 等变性属性的验证**\n\n核心任务是数值上验证等变性关系。该性质是旋转和互相关之间关系的直接结果。对于任何定义了该操作的二维数组 $A$ 和 $B$，以下恒等式成立：\n$$(R_m A) \\star B = R_m (A \\star R_{-m} B)$$\n其中 $R_{-m}$ 是 $R_m$ 的逆旋转。在群 $C_4$ 中，$R_m$ 的逆是 $R_{(-m) \\pmod 4}$。\n\n让我们将此恒等式应用于我们的问题。新的输出通道 $Y'_g$ 是由旋转后的输入 $X' = R_m X$ 和同一组共享的、旋转过的卷积核计算得出的：\n$$Y'_g = X' \\star (R_g K) = (R_m X) \\star (R_g K)$$\n应用该恒等式，令 $A=X$ 且 $B=R_g K$，我们得到：\n$$Y'_g = R_m (X \\star R_{(-m) \\pmod 4} (R_g K))$$\n由于旋转算子构成一个群，它们的复合是另一个旋转：$R_{(-m) \\pmod 4} (R_g K) = R_{(-m+g) \\pmod 4} K = R_{(g-m) \\pmod 4} K$。将其代回得到：\n$$Y'_g = R_m (X \\star R_{(g-m) \\pmod 4} K)$$\n括号中的项 $X \\star R_{(g-m) \\pmod 4} K$ 根据定义就是原始的输出通道 $Y_{(g-m) \\pmod 4}$。因此，我们得到了等变性属性：\n$$Y'_g = R_m Y_{(g-m) \\pmod 4}$$\n此推导表明，该性质在数学上是由其构造所保证的。我们的实现将对几个测试用例进行数值验证。对于每个用例，我们计算该方程对所有 $g \\in \\{0, 1, 2, 3\\}$ 的左侧和右侧，并在指定的数值容差内检查它们是否相等。\n\n**5. 对比测试：权重共享的必要性**\n\n最后一个测试用例作为一个关键的对比。在这种情况下，我们定义一个具有四个输出通道的“卷积”层，但打破了权重共享的约束。这四个通道是使用四个独立的、不相关的卷积核 $(K_0, K_1, K_2, K_3)$ 计算的。\n$$Y_g = X \\star K_g$$\n当输入被旋转为 $X' = R_m X$ 时，新的输出是 $Y'_g = (R_m X) \\star K_g$。对等变性的检查保持不变：我们测试是否 $Y'_g = R_m Y_{(g - m) \\pmod 4}$。由于卷积核 $K_g$ 之间没有通过群作用关联（即，通常情况下 $K_g \\neq R_g K_0$），步骤4中的推导不成立。等变性属性没有被结构性地强制实现，预计会失败，这表明特定的权重共享方案是实现等变性的机制。\n\n最终的程序将系统地实现这些步骤，并执行所述的测试，为每个用例生成一个布尔结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.signal import correlate2d\n\ndef solve():\n    \"\"\"\n    Implements and verifies C4 rotation equivariance for a 2D group convolution.\n    \"\"\"\n\n    # Test suite specification\n    # (id, X_shape, X_seed, K_shape, K_seed(s), m)\n    test_cases = [\n        (1, (6, 6), 1, (3, 3), [0], 1),\n        (2, (5, 5), 3, (2, 2), [2], 1),\n        (3, (7, 7), 5, (3, 3), [4], 2),\n        (4, (6, 6), 7, (3, 3), [6], 0),\n        (5, (8, 8), 8, (3, 3), [8], 3),  # Structured input\n        (6, (6, 6), 9, (3, 3), [10, 11, 12, 13], 1)  # Contrast test\n    ]\n\n    results = []\n    \n    # Numerical tolerance for array comparisons\n    atol = 1e-9\n    rtol = 0.0\n\n    for case in test_cases:\n        case_id, x_shape, x_seed, k_shape, k_seeds, m = case\n\n        # --- Data Generation ---\n        rng_x = np.random.RandomState(x_seed)\n        if case_id == 5: # Structured input of all ones\n            X = np.ones(x_shape)\n        else:\n            X = rng_x.randn(*x_shape)\n        \n        kernels = []\n        for seed in k_seeds:\n            rng_k = np.random.RandomState(seed)\n            kernels.append(rng_k.randn(*k_shape))\n\n        is_equivariant = False # Placeholder\n        \n        # --- Helper Functions ---\n        def rotate_array(arr, k):\n            \"\"\"Rotates a 2D array by k*90 degrees counter-clockwise.\"\"\"\n            return np.rot90(arr, k=k)\n\n        def cross_correlate(image, kernel):\n            \"\"\"Computes 2D cross-correlation with 'valid' padding.\"\"\"\n            return correlate2d(image, kernel, mode='valid')\n\n        # --- Main Logic ---\n        if case_id != 6:\n            # Standard C4 Group Convolution with weight sharing\n            K_base = kernels[0]\n            \n            # 1. Compute original output channels Y_g = X * (R_g K)\n            Y_channels = []\n            for g in range(4):\n                rotated_K = rotate_array(K_base, g)\n                Y_g = cross_correlate(X, rotated_K)\n                Y_channels.append(Y_g)\n            \n            # 2. Rotate input: X' = R_m X\n            X_prime = rotate_array(X, m)\n            \n            # 3. Compute new output channels Y'_g = X' * (R_g K)\n            Y_prime_channels = []\n            for g in range(4):\n                rotated_K = rotate_array(K_base, g)\n                Y_prime_g = cross_correlate(X_prime, rotated_K)\n                Y_prime_channels.append(Y_prime_g)\n\n        else: # Contrast test without weight sharing\n            # 1. Compute original output channels Y_g = X * K_g\n            Y_channels = []\n            for g in range(4):\n                Y_g = cross_correlate(X, kernels[g])\n                Y_channels.append(Y_g)\n                \n            # 2. Rotate input: X' = R_m X\n            X_prime = rotate_array(X, m)\n\n            # 3. Compute new output channels Y'_g = X' * K_g\n            Y_prime_channels = []\n            for g in range(4):\n                Y_prime_g = cross_correlate(X_prime, kernels[g])\n                Y_prime_channels.append(Y_prime_g)\n\n        # 4. Verify equivariance: Y'_g == R_m(Y_{g-m mod 4}) for all g\n        all_g_hold = True\n        for g in range(4):\n            # LHS: Y'_g\n            lhs = Y_prime_channels[g]\n            \n            # RHS: R_m(Y_{g-m mod 4})\n            original_channel_index = (g - m) % 4\n            y_original_permuted = Y_channels[original_channel_index]\n            rhs = rotate_array(y_original_permuted, m)\n            \n            # Check for equality within tolerance\n            if not np.allclose(lhs, rhs, rtol=rtol, atol=atol):\n                all_g_hold = False\n                break\n        \n        is_equivariant = all_g_hold\n        results.append(is_equivariant)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "构建一个等变层只是第一步，真正的挑战在于如何将其应用于解决实际问题。本练习探讨了一个更精妙的设计问题：如何确保网络的最终输出能够遵循特定任务的对称性。我们将分析一个手性分类任务，其中旋转操作不改变手性，而反射操作会反转手性。通过这个例子，你将学会如何精心设计输出层的表示，使其与标签在对称变换下的行为精确匹配。",
            "id": "3133472",
            "problem": "一位从业者设计了一个群卷积神经网络 (G-CNN)，用于处理具有手性（左手性与右手性）的平面图案图像。其对称群为二面体群 $D_n$，由一个 $n$ 阶旋转 $r$ 和一个反射 $s$ 生成，满足关系 $r^n = e$，$s^2 = e$ 和 $s r s = r^{-1}$。该网络由对 $D_n$ 等变的群卷积层构成。所谓等变，是指对于实现特征场 $x$ 上的映射 $f$ 的任何层，以及任意 $g \\in D_n$，都有 $f(T_g x) = \\rho(g) f(x)$，其中 $T_g$ 是 $g$ 对输入的作用，$\\rho(g)$ 是一个线性表示，决定了该层输出的变换方式。\n\n任务是对手性进行二元分类。根据经验和对称性，旋转 $r^k$（$k \\in \\{0,1,\\dots,n-1\\}$）不改变手性，而反射 $s r^k$ 会反转手性。在测试时，输入可能相对于训练集被旋转或反射，分类器必须作出一致的响应：对于旋转，它应该保持预测类别不变；而对于反射，它应该交换左/右手的预测。\n\n从群等变的定义 $f(T_g x) = \\rho(g) f(x)$ 出发，并考虑到标签应根据与任务物理对称性一致的表示 $\\pi(g)$（旋转保持手性；反射反转手性）进行变换的理念，请选择能在分类头正确强制执行所需行为的设计。假设适用时，对类别概率使用标准的交叉熵进行训练，或对带符号目标使用均方误差进行训练，并假设 G-CNN 的早期层是 $D_n$ 等变的。\n\n以下哪种输出头设计能正确编码奇偶性行为，并在测试时产生所需的旋转不变性和反射引起的类别反转？\n\nA. 使用一个 $D_n$ 等变头，其在两个 logit 上的输出表示是平凡的，即对于所有 $g \\in D_n$，$\\rho(g) = I_2$。然后对这两个 logit 应用 softmax 以获得类别概率。\n\nB. 使用一个 $D_n$ 等变头，其输出为二维，其中旋转的作用是平凡的，而反射会交换两个分量：$\\rho(r^k) = I_2$ 和 $\\rho(s r^k) = \\begin{pmatrix} 0  1 \\\\ 1  0 \\end{pmatrix}$。对这两个分量应用 softmax 以获得左手与右手的类别概率。\n\nC. 放弃反射，仅使用一个循环群 $C_n$ 等变头（仅旋转）。训练时使用数据增强，其中包括将反射后的样本重新标记为相反的类别，并依赖网络在没有显式表示级约束的情况下学习这种翻转。\n\nD. 使用一个 $D_n$ 等变头，其输出为单个标量 $y \\in \\mathbb{R}$，通过回归一个带符号的目标 $t \\in \\{-1,+1\\}$ 进行训练，其中 $\\rho(r^k) = 1$ 和 $\\rho(s r^k) = -1$。在测试时，通过决策规则 $\\hat{c} = \\mathbf{1}[y > 0]$ 预测类别。\n\n选择所有适用的选项。",
            "solution": "在进行解答之前，首先对问题陈述进行验证。\n\n### 步骤 1：提取已知条件\n- **对称群**：由旋转 $r$ 和反射 $s$ 生成的二面体群 $D_n$。\n- **群关系**：$r^n = e$，$s^2 = e$ 和 $s r s = r^{-1}$。\n- **网络架构**：一个带有 $D_n$ 等变层的群卷积神经网络 (G-CNN)。\n- **等变性定义**：对于特征场 $x$ 上的一个层映射 $f$，以及任意群元素 $g \\in D_n$，等变关系为 $f(T_g x) = \\rho(g) f(x)$。这里，$T_g$ 是 $g$ 对输入场的作用，$\\rho(g)$ 是一个定义输出场如何变换的线性表示。\n- **任务**：手性的二元分类（左手性 vs. 右手性）。\n- **手性的对称性**：\n    - 旋转（$g=r^k$，其中 $k \\in \\{0, 1, \\dots, n-1\\}$）保持手性。\n    - 反射（$g=s r^k$）反转手性。\n- **分类器所需行为**：\n    - 在旋转下，预测的类别必须保持不变（不变性）。\n    - 在反射下，预测的类别必须被反转（例如，左手 $\\to$ 右手）。\n- **假设**：G-CNN 的早期层是 $D_n$ 等变的。训练使用标准方法，如交叉熵或均方误差。\n- **目标**：选择能够正确强制执行所需对称性行为的输出头设计。\n\n### 步骤 2：使用提取的已知条件进行验证\n评估问题陈述的有效性。\n- **科学依据**：该问题基于群论及其通过群等变 CNN 在深度学习中应用的成熟数学框架。二面体群 $D_n$ 的性质和手性的几何概念被正确陈述和使用。这是几何深度学习领域的一个标准问题。该问题在科学上是合理的。\n- **良构性**：问题定义清晰。它指定了群、任务、输出所需的对称性以及等变性的定义。问题要求选择一个满足这些约束的特定设计方案。可以使用群表示论的原理推导出解决方案。该问题是良构的。\n- **客观性**：该问题使用精确的技术语言（例如“$D_n$ 等变”、“线性表示”），没有主观或模糊的术语。该问题是客观的。\n\n根据检查清单，未发现任何缺陷（例如，没有科学不合理性、不完整性或模糊性）。\n\n### 步骤 3：结论与行动\n问题陈述有效。将推导完整的解决方案。\n\n### 基于原理的推导\n为特定任务设计等变网络的核心原则是，确保网络输出的表示 $\\rho(g)$ 与任务标签的表示（我们称之为 $\\pi(g)$）相匹配。网络头是一个映射 $f_{\\text{head}}$。如果其输入 $x_{\\text{penultimate}}$ 被 $T_g$ 变换，其输出 $y = f_{\\text{head}}(x_{\\text{penultimate}})$ 将变换为 $y \\mapsto \\rho(g) y$。那么最终的分类决策 $C(y)$ 必须表现出所需的对称性。\n\n让我们将标签所需的对称性 $\\pi(g)$ 形式化：\n$1$. **旋转**：旋转 $g = r^k$ 保持手性。这意味着分类决策必须是不变的。\n$2$. **反射**：反射 $g = sr^k$ 反转手性。这意味着分类决策必须被翻转。\n\n我们现在必须检查每个提议的设计，看其输出表示 $\\rho(g)$ 和后续的决策规则是否能产生这种行为。\n\n### 逐项分析\n\n**A. 使用一个 $D_n$ 等变头，其在两个 logit 上的输出表示是平凡的，即对于所有 $g \\in D_n$，$\\rho(g) = I_2$。然后对这两个 logit 应用 softmax 以获得类别概率。**\n\n- **分析**：该头的输出是一个二维的 logit 向量，$y \\in \\mathbb{R}^2$。等变性意味着对于一个输入图像 $x_{in}$，如果它被任意 $g \\in D_n$ 变换，输出将变为 $y(T_g x_{in}) = \\rho(g) y(x_{in})$。根据此选项，对所有 $g$，$\\rho(g) = I_2$（$2 \\times 2$ 单位矩阵）。因此，$y(T_g x_{in}) = I_2 y(x_{in}) = y(x_{in})$。\n- 输出的 logit 在所有群作用下（包括旋转和反射）都是不变的。对一个不变的向量应用 softmax 函数将产生不变的概率。因此，最终的分类对于旋转和反射都将是不变的。虽然旋转不变性是期望的，但对反射的不变性与反射必须反转手性的要求相矛盾。该模型在架构上被约束为忽略反射，这对于此任务是不正确的。\n- **结论**：不正确。\n\n**B. 使用一个 $D_n$ 等变头，其输出为二维，其中旋转的作用是平凡的，而反射会交换两个分量：$\\rho(r^k) = I_2$ 和 $\\rho(s r^k) = \\begin{pmatrix} 0  1 \\\\ 1  0 \\end{pmatrix}$。对这两个分量应用 softmax 以获得左手与右手的类别概率。**\n\n- **分析**：输出是一个二维的 logit 向量，$y = [y_1, y_2]^T$。让我们检查在两种变换下的行为。\n- **旋转 ($g=r^k$)**：输出变换为 $y(T_{r^k} x_{in}) = \\rho(r^k) y(x_{in}) = I_2 y(x_{in}) = y(x_{in})$。logit 是不变的。随后的 softmax 概率和最终分类也是不变的。这符合对旋转的要求。\n- **反射 ($g=sr^k$)**：输出变换为 $y(T_{sr^k} x_{in}) = \\rho(sr^k) y(x_{in}) = \\begin{pmatrix} 0  1 \\\\ 1  0 \\end{pmatrix} \\begin{pmatrix} y_1 \\\\ y_2 \\end{pmatrix} = \\begin{pmatrix} y_2 \\\\ y_1 \\end{pmatrix}$。两个 logit 被交换。设类别概率为 $p_1 = e^{y_1} / (e^{y_1} + e^{y_2})$ 和 $p_2 = e^{y_2} / (e^{y_1} + e^{y_2})$。对于变换后的输入，新的 logit 是 $[y_2, y_1]^T$，导致新的概率 $p'_1 = e^{y_2} / (e^{y_2} + e^{y_1}) = p_2$ 和 $p'_2 = e^{y_1} / (e^{y_2} + e^{y_1}) = p_1$。两个类别的概率被交换，这正确地实现了手性的反转。\n- **表示的有效性**：所提议的映射 $\\rho$ 是 $D_n$ 的一个有效表示。它正确地将 $r$ 映射到单位矩阵，将 $s$ 映射到置换矩阵，满足群关系。\n- **结论**：正确。\n\n**C. 放弃反射，仅使用一个循环群 $C_n$ 等变头（仅旋转）。训练时使用数据增强，其中包括将反射后的样本重新标记为相反的类别，并依赖网络在没有显式表示级约束的情况下学习这种翻转。**\n\n- **分析**：此选项建议在架构上强制执行旋转等变性，但将反射行为留给数据增强来学习。虽然数据增强是深度学习中一种强大且常用的技术，但它并不能*强制*或*保证*精确的对称性。网络从有限的数据中学习反射规则的近似值，没有架构上的约束来确保 $f(T_s x)$ 以所需的方式与 $f(x)$ 完美关联。问题要求的是能够*正确强制执行所需行为*的设计。此选项用经验学习取代了架构上的强制执行，这是一种不同的设计哲学，不能提供与针对整个 $D_n$ 群的等变设计相同的保证。\n- **结论**：不正确。\n\n**D. 使用一个 $D_n$ 等变头，其输出为单个标量 $y \\in \\mathbb{R}$，通过回归一个带符号的目标 $t \\in \\{-1,+1\\}$ 进行训练，其中 $\\rho(r^k) = 1$ 和 $\\rho(s r^k) = -1$。在测试时，通过决策规则 $\\hat{c} = \\mathbf{1}[y > 0]$ 预测类别。**\n\n- **分析**：输出是单个标量 $y \\in \\mathbb{R}$。这对应于 $D_n$ 的一个一维表示。我们来检查其行为。\n- **旋转 ($g=r^k$)**：输出变换为 $y(T_{r^k} x_{in}) = \\rho(r^k) y(x_{in}) = (1) \\cdot y(x_{in}) = y(x_{in})$。标量输出是不变的。基于其符号的决策 $\\mathbf{1}[y > 0]$ 也是不变的。这符合对旋转的要求。\n- **反射 ($g=sr^k$)**：输出变换为 $y(T_{sr^k} x_{in}) = \\rho(sr^k) y(x_{in}) = (-1) \\cdot y(x_{in}) = -y(x_{in})$。标量输出被取反。如果原始预测是一个类别（例如，$y > 0$），则新的输出 $-y$ 将为负（$-y  0$），从而导致预测为另一个类别。如果原始预测是 $y  0$，新的输出 $-y$ 将为正（$-y  0$），同样翻转了类别。这正确地实现了手性的反转。\n- **表示的有效性**：映射 $\\rho(r^k)=1$ 和 $\\rho(sr^k)=-1$ 是著名的 $D_n$ 的符号（或交错）表示。它是一个有效的、一维的、不可约的表示，正确地反映了群元素的奇偶性（旋转为偶，反射为奇）。\n- **结论**：正确。",
            "answer": "$$\\boxed{BD}$$"
        },
        {
            "introduction": "群等变模型的一个强大之处在于它们对数据对称性做出了明确的假设。但如果我们假设是错误的呢？例如，我们构建了一个对8种旋转（$C_8$）等变的模型，但数据本身只具有4种旋转（$C_4$）对称性。本练习将带你进入一个实际的诊断场景，学习如何通过检查特征图中的特定冗余模式，来判断模型假设的对称性与数据内在的对称性是否匹配。",
            "id": "3133417",
            "problem": "给定一个卷积神经网络（CNN），其第一层是作用于循环旋转群 $C_{8}$ 上的群卷积，生成由对应于群元素的方向通道索引的特征张量。具体来说，对于一批输入，该层输出一个张量 $F \\in \\mathbb{R}^{B \\times C \\times |G| \\times H \\times W}$，其中 $|G|=8$，第三个轴以 $45^\\circ$ 为步长索引 $C_{8}$ 中的八个方向。该实现被设计为对 $C_{8}$ 旋转等变。您怀疑训练数据分布不是 $C_{8}$ 对称的，而仅仅对由 $90^\\circ$ 旋转生成的子群 $C_{4} \\subset C_{8}$ 保持不变。\n\n使用以下第一性原理基础：\n- 对群 $G$ 的群卷积产生的特征，在 $G$ 的左正则作用 $L_{h}$ 下以等变的方式变换：如果输入被 $h \\in G$ 变换，那么特征张量会沿着方向轴被 $h$ 排列。\n- 如果数据分布在子群 $H \\subseteq G$ 下是不变的，那么在数据分布上平均的统计量将在 $H$ 对方向索引的相应作用下保持不变，这可能在位于相同 $H$-轨道（陪集结构）的方向通道之间引入冗余（线性相关）。\n- 一组通道间的线性冗余可以通过二阶统计量（例如，协方差秩）或通过离散傅里叶变换（DFT）揭示的方向轴上的周期性来检测。\n\n您想要一个实用的、数据驱动的监控程序，该程序可以在训练期间应用于当前轮次的一个留出批次，仅使用来自第一个群卷积层（在任何非线性或池化之前）的特征张量 $F$，以检测假定的 $C_{8}$ 对称性是否与数据不匹配（例如，数据仅具有 $C_{4}$ 对称性），特别是通过监控方向通道间的冗余来实现。\n\n以下哪种方法最适合此目的？\n\nA. 将 $F$ 在批次、基础通道和空间位置上聚合为一个矩阵 $X \\in \\mathbb{R}^{|G| \\times N}$（其中 $N = B \\cdot C \\cdot H \\cdot W$），方法是将 $|G|$ 个方向切片堆叠为行。计算这 $|G|$ 行之间的经验方向协方差 $\\Sigma \\in \\mathbb{R}^{|G| \\times |G|}$。估计 $\\Sigma$ 的有效秩（例如，通过参与率 $r = \\frac{\\left(\\sum_{i=1}^{|G|} \\lambda_i\\right)^2}{\\sum_{i=1}^{|G|} \\lambda_i^2}$，其中 $\\{\\lambda_i\\}$ 是 $\\Sigma$ 的特征值）。如果 $r \\ll |G|$ 并且相关性模式表现出与疑似子群一致的周期性（对于 $C_{8}$ 内的 $C_{4}$，通道 $k$ 和 $k+4$ 之间存在近似重复的相关性），则标记为对称性不匹配。\n\nB. 监控训练损失随轮次变化的函数。如果在使用 $C_{8}$ 等变层时，损失在高于期望阈值处停滞，则推断假定的对称性不匹配，因为模型无法进一步减少损失。\n\nC. 在按方向通道计算的平均激活值上添加 $\\ell_{1}$ 惩罚，以鼓励 $|G|$ 个方向上的稀疏性，并且如果在训练后大部分方向通道变得接近于零，则声明不匹配。\n\nD. 对于每个 $b \\in \\{1,\\dots,B\\}$ 和每个基础通道 $c \\in \\{1,\\dots,C\\}$，沿长度为 $|G|=8$ 的方向轴计算离散傅里叶变换（DFT），将平方幅值在 $(b,c,h,w)$ 上平均以获得方向谱能量 $\\mathcal{E}(k)$（其中 $k \\in \\{0,\\dots,7\\}$），然后计算集中在与 $C_{4}$-周期性一致的谐波（即索引 $k$ 是 $|G|/|C_{4}| = 2$ 的倍数）上的能量与总能量的比率。如果该比率接近 $1$，则标记为不匹配，这表明存在 $4$-周期性，从而说明相隔 $4$ 个步长的方向通道之间存在冗余。\n\nE. 比较在不同方向上绑定的学习到的滤波器的弗罗贝尼乌斯范数。如果分配给不同方向的滤波器的范数不相等，则断定假定的 $C_{8}$ 对称性与数据不匹配。\n\n选择所有适用选项。",
            "solution": "### 步骤 1：提取已知条件\n- 一个卷积神经网络（CNN）的第一层是作用于循环旋转群 $C_{8}$ 上的群卷积。\n- 该层的输出是一个特征张量 $F \\in \\mathbb{R}^{B \\times C \\times |G| \\times H \\times W}$。\n- 群是 $G=C_{8}$，因此其大小为 $|G|=8$。\n- $F$ 的第三个轴以 $45^\\circ$ 为步长索引八个方向。\n- 该层被设计为对 $C_{8}$ 旋转等变。\n- 存在一个怀疑，即训练数据分布仅对由 $90^\\circ$ 旋转生成的子群 $C_{4} \\subset C_{8}$ 保持不变。\n- 第一性原理基础：\n    1. 对群 $G$ 的群卷积产生的特征在 $h \\in G$ 的左正则作用 $L_{h}$ 下是等变的：由 $h$ 变换输入会排列特征张量的方向轴。\n    2. 数据分布在子群 $H \\subseteq G$ 下的不变性，使得在数据分布上平均的统计量在 $H$ 对方向索引的作用下保持不变，可能在同一 $H$-轨道（陪集）的通道之间引入冗余（线性相关）。\n    3. 线性冗余可以通过二阶统计量（例如，协方差秩）或通过离散傅里叶变换（DFT）在方向轴上的周期性来检测。\n- 目标是找到一个实用的、数据驱动的监控程序，仅使用第一层（非线性之前）的特征张量 $F$ 来检测 $C_{8}$ 与 $C_{4}$ 的对称性不匹配，方法是监控方向通道间的冗余。\n\n### 步骤 2：使用提取的已知条件进行验证\n根据验证标准评估问题陈述。\n\n- **科学依据：** 该问题牢固地植根于几何深度学习的既定理论，特别是关于群等变卷积网络。群论（$C_8$, $C_4$）、等变性、数据对称性和统计检测方法（协方差分析，DFT）等概念都是标准的且在数学上是合理的。\n- **适定性：** 问题定义清晰。它提出了一个特定的情景（模型对称性与数据对称性之间可能存在的不匹配），并要求基于一组给定的原则和约束找到一个合适的检测方法。对选项进行唯一且有意義的分析是可能的。\n- **客观性：** 所使用的语言精确、技术性强且没有主观性。诸如“群卷积”、“$C_8$-等变”和“协方差秩”等术语在机器学习和数学的背景下具有明确的含义。\n\n该问题没有表现出任何列出的缺陷：\n1.  它在科学上是合理的。\n2.  它是可形式化的，并且与主题直接相关。\n3.  设置是完整和一致的。\n4.  在应用等变模型的背景下，该情景是现实的。\n5.  它结构良好，不包含循环推理。\n6.  这是一个需要概念理解的非平凡问题。\n7.  所提出的方法是可以通过经验验证的。\n\n### 步骤 3：结论与行动\n问题陈述是**有效的**。将继续进行解答过程。\n\n### 从第一性原理推导\n令群为 $G = C_{8}$，我们可以用模 $8$ 加法下的整数 $\\{0, 1, \\dots, 7\\}$ 来表示它。每个整数 $g \\in G$ 对应于一个 $g \\cdot 45^\\circ$ 的旋转。该层是 $G$-等变的。令 $\\Phi$ 为该层计算的函数，令 $\\rho(g)$ 为将输入旋转 $g \\cdot 45^\\circ$ 的算子。等变性意味着对于任何输入 $I$ 和任何 $g \\in G$，$\\Phi(\\rho(g)I) = L_g(\\Phi(I))$，其中 $L_g$ 是排列输出张量 $F = \\Phi(I)$ 的方向通道的左正则作用。具体来说，对于通道索引 $k \\in G$，有 $(L_g F)_k = F_{k-g \\pmod 8}$。\n\n假设数据分布 $p(I)$ 在子群 $H=C_{4} \\subset G$ 下是不变的。子群 $C_{4}$ 由 $90^\\circ$ 旋转生成，这在我们的表示中对应于元素 $g=2$。因此，$H = \\{0, 2, 4, 6\\}$。数据不变性意味着对于所有 $h \\in H$，都有 $p(I) = p(\\rho(h)I)$。\n\n这种数据对称性对输出特征 $F$ 上计算的统计量有影响。令 $S(F)$ 为特征的任意统计泛函。它在数据分布上的期望是 $E[S(F)] = \\int S(\\Phi(I)) p(I) dI$。利用 $p(I)$ 的 $H$-不变性，对于任何 $h \\in H$：$E[S(F)] = \\int S(\\Phi(I)) p(\\rho(-h)I) dI$。通过变量替换 $I' = \\rho(-h)I$，因此 $I=\\rho(h)I'$，我们得到：$E[S(F)] = \\int S(\\Phi(\\rho(h)I')) p(I') dI' = \\int S(L_h(\\Phi(I'))) p(I') dI' = E[S(L_h F)]$。这证明了特征 $F$ 的任何统计量，在数据分布上平均时，必须在所有 $h \\in H$ 的作用 $L_h$ 下保持不变。在一个大的、有代表性的数据批次上，经验统计量应近似于这种不变性。\n\n在 $H=C_4$ 中一个特别重要的元素是 $h=4$（一个 $180^\\circ$ 旋转）。作用于方向通道上的 $L_4$ 是一个大小为 $4$ 的移位：$(L_4 F)_k = F_{k-4 \\pmod 8}$。统计不变性意味着通道 $k$ 的属性与通道 $k-4 \\pmod 8$（或等价地，通道 $k+4 \\pmod 8$）的属性相同。这就产生了一种强形式的冗余：通道 $k$ 中的特征集合，记为 $F_{:,:,k,:,:}$，应该与通道 $k+4$ 中的特征在统计上无法区分。这意味着沿着方向轴存在一个周期为 $P=4$ 的周期性结构。\n\n这种冗余，或称 $4$-周期性，可以如基本原理所建議的那樣，通過兩種主要方式來檢測：\n1.  **协方差分析：** 如果特征通道 $k$ 和通道 $k+4$ 在统计上是相同的，那么它们激活值（在所有其他维度上展平）的向量应该是高度相关的。对于一个 $8 \\times 8$ 的方向通道间协方差矩阵 $\\Sigma$，这意味着行/列对 $(k, k+4)$ 将几乎相同。这导致矩阵接近奇异，其有效秩从 $|G|=8$ 下降到 $|G|/2=4$。\n2.  **傅里叶分析：** 一个长度为 $N$、周期为 $P$ 的离散信号，其离散傅里叶变换（DFT）的能量集中在频率索引为 $N/P$ 整数倍的位置。在我们的案例中，信号是沿方向轴的特征序列，长度为 $N=|G|=8$。期望的周期性是 $P=4$。因此，沿该轴的 DFT 能量应该集中在频率 $k'$ 是 $8/4=2$ 的倍数处。相应的 DFT 索引是 $k' \\in \\{0, 2, 4, 6\\}$。\n\n### 逐项分析\n\n**A. 该方法直接应用了从第一性原理推导出的协方差分析。通过创建矩阵 $X$，它准备了数据以计算 8 个方向通道之间的经验协方差 $\\Sigma$。在一个 $C_8$ 模型中存在 $C_4$ 对称性的假设预测了通道 $k$ 和 $k+4$ 会变得冗余。这种线性相关性将导致 $\\Sigma$ 的 4 个特征值接近于零，从而将有效秩从最大值 $|G|=8$ 显著降低到大约 $4$。参与率是量化此有效秩的标准方法。该方法还正确预测了特定的相关性模式：相隔 4 个索引的通道之间具有高相关性。这是一个直接、定量且合适的程序，用于检测指定的不匹配。**\n**结论：正确**\n\n**B. 这是一个间接且不可靠的方法。高的训练损失平台期是训练神经网络时许多可能问题的通用症状，包括但不限于：次优的学习率、糟糕的初始化、模型容量不足、陷入糟糕的局部最小值，或者问题本身固有的困难。将高损失完全归因于对称性不匹配是一个不合理的逻辑跳跃。问题要求的是一个监控*冗余*的程序，而这个方法并没有直接做到这一点。**\n**结论：错误**\n\n**C. 这个方法是误导性的。所描述的对称性不匹配的预期后果是*冗余*，而不是*稀疏性*。也就是说，通道变得与其他通道在统计上相似（例如，通道 $k$ 镜像通道 $k+4$），而不一定是零。虽然 $\\ell_1$ 惩罚强制稀疏性，但它不是检测预测的线性相关模式的正确工具。很可能没有通道会变为零，但成对的通道会变得高度相关，而这种现象是该方法无法检测的。**\n**结论：错误**\n\n**D. 该方法直接应用了从第一性原理推导出的傅里葉分析。如前所述，$C_4$ 数据对称性在长度为 $N=8$ 的方向轴上施加了一个周期为 $P=4$ 的统计周期性。DFT 是检测周期性的经典工具。根据傅里叶理论，一个在长度为 $N$ 的域上周期为 $P$ 的信号，其功率谱集中在频率索引为 $N/P$ 的倍数处。在这里，这个值是 $8/4=2$。该程序正确地将这些谐波索引识别为 $\\{0, 2, 4, 6\\}$（因为 DFT 也是周期性的，索引 $6$ 等价于 $-2$）。通过计算这些谐波中的能量与总能量的比率，该方法提供了一个直接、定量的度量，用于衡量 $4$-周期性的强度。一个接近 $1$ 的比率是对称性不匹配的有力证据。这个程序是合理且适当的。**\n**结论：正确**\n\n**E. 该方法基于对群卷积的一个根本性误解。在一个 G-等变层中，不同群元素（方向）的滤波器不是独立学习的参数。它们是通过对单个“母”滤波器或核应用群作用生成的。对于一个旋转群，这意味着方向 $g$ 的滤波器是基础滤波器的一个旋转版本。由于弗罗贝尼乌斯范数在这种旋转下是不变的，因此在一个正确实现的群卷积层中，所有在群上绑定的滤波器的范数将*通过构造*而相同。因此，这些范数不包含关于训练数据对称属性的任何信息。它们只反映模型自身的结构。**\n**结论：错误**",
            "answer": "$$\\boxed{AD}$$"
        }
    ]
}