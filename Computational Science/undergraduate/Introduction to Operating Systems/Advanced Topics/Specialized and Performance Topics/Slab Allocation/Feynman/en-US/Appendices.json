{
    "hands_on_practices": [
        {
            "introduction": "Understanding how a slab allocator works begins with the fundamental question of how many objects can fit into a single page. This exercise guides you through the essential calculation of slab capacity, forcing you to account for practical constraints like header overhead, object alignment, and padding. By working through this problem , you will develop a core skill: quantifying the efficiency of a slab by calculating its object count and the resulting internal fragmentation.",
            "id": "3683553",
            "problem": "In a slab allocation scenario within an operating system course on memory management, consider a cache of fixed-size objects with the following parameters: object size $s=40$ bytes, page size $P=4096$ bytes, per-page slab header $h=64$ bytes, and alignment requirement $a=8$ bytes. Each slab is backed by exactly one page, and the slab header occupies the first $h$ bytes of the page. Objects must begin at addresses that are multiples of $a$ bytes, and each object slot must be sized so that its start and end respect the $a$-byte alignment constraint. Any alignment padding, including any padding required after the header to align the first object and any per-object padding that arises from rounding $s$ up to the alignment boundary, is not usable for payload and counts as internal fragmentation. Any residual space in the page payload that remains after placing the maximum number of object slots and that is insufficient to hold another slot must also be considered internal fragmentation. The slab header $h$ is not counted as internal fragmentation.\n\nUnder these rules, determine:\n1. The number of objects that can fit in one slab page.\n2. The internal fragmentation as a decimal fraction of the usable payload space $P-h$.\n\nReport the final answer as a row matrix with two entries, where the first entry is the object count and the second entry is the internal fragmentation fraction. Express the internal fragmentation as a unitless decimal fraction rounded to four significant figures. Do not include any units in your final boxed answer.",
            "solution": "The slab allocator arranges fixed-size object slots inside a page, accounting for alignment and metadata. We begin with the following foundational definitions and facts:\n- A page provides $P$ bytes of total capacity.\n- A slab header consumes $h$ bytes from the start of the page and is not counted toward internal fragmentation.\n- Alignment to $a$ bytes requires that the start address of each object slot be a multiple of $a$, and that the slot size be padded up to the smallest multiple of $a$ that is not less than the logical object size $s$.\n- Internal fragmentation inside the slab payload consists of: padding to align the first object after the header, per-object padding due to alignment, and any remaining unusable payload space after packing the maximum number of object slots. It is measured relative to the usable payload $P-h$.\n\nFirst, compute the usable payload after the header:\n$$\nU = P - h = 4096 - 64 = 4032.\n$$\nNext, compute the aligned object slot size. For an alignment $a$, the padded slot size $s'$ is the smallest multiple of $a$ not less than $s$:\n$$\ns' = a \\times \\left\\lceil \\frac{s}{a} \\right\\rceil.\n$$\nWith $s=40$ and $a=8$, we have\n$$\n\\frac{s}{a} = \\frac{40}{8} = 5,\n$$\nso\n$$\ns' = 8 \\times \\left\\lceil 5 \\right\\rceil = 8 \\times 5 = 40.\n$$\nThus, each object slot is $s' = 40$ bytes, and per-object padding $s' - s = 40 - 40 = 0$ bytes.\n\nWe must also ensure the first object is aligned after the header. The header ends at offset $h$; if $h$ is not a multiple of $a$, we need top padding $p_{0}$ to reach the next multiple of $a$. The required top padding is\n$$\np_{0} = (a - (h \\bmod a)) \\bmod a.\n$$\nCompute $h \\bmod a$:\n$$\nh \\bmod a = 64 \\bmod 8 = 0,\n$$\nso\n$$\np_{0} = (8 - 0) \\bmod 8 = 0.\n$$\nTherefore, no extra padding is required to align the first object.\n\nThe number of object slots $n$ is the largest integer such that $n s' \\leq U - p_{0}$. Thus,\n$$\nn = \\left\\lfloor \\frac{U - p_{0}}{s'} \\right\\rfloor = \\left\\lfloor \\frac{4032 - 0}{40} \\right\\rfloor = \\left\\lfloor 100.8 \\right\\rfloor = 100.\n$$\nThe residual unused payload after packing $n$ slots is\n$$\nr = (U - p_{0}) - n s' = 4032 - 100 \\times 40 = 4032 - 4000 = 32.\n$$\nTotal internal fragmentation inside the payload comprises three components:\n- Top alignment padding $p_{0}$,\n- Per-object padding $n (s' - s)$,\n- Residual unfillable tail $r$.\n\nHence the total wasted bytes $W$ are\n$$\nW = p_{0} + n (s' - s) + r = 0 + 100 \\times (40 - 40) + 32 = 32.\n$$\nWe quantify internal fragmentation as a fraction of the usable payload $U = P - h$:\n$$\nf = \\frac{W}{U} = \\frac{32}{4032}.\n$$\nWe can simplify this fraction. Note that $4032 = 32 \\times 126$, so\n$$\nf = \\frac{32}{32 \\times 126} = \\frac{1}{126}.\n$$\nExpressed as a decimal, this is\n$$\nf = \\frac{1}{126} \\approx 0.0079365079365079\\ldots\n$$\nRounded to four significant figures, we obtain\n$$\nf \\approx 0.007937.\n$$\nTherefore, the object count is $n = 100$, and the internal fragmentation fraction is $f \\approx 0.007937$ when rounded to four significant figures as required.",
            "answer": "$$\\boxed{\\begin{pmatrix}100 & 0.007937\\end{pmatrix}}$$"
        },
        {
            "introduction": "Building on the basics of slab layout, this practice introduces a more nuanced scenario where the alignment requirement is the dominant factor in determining object placement. You will learn to calculate the \"stride,\" or the total distance between the start of consecutive objects, when significant padding is needed to meet alignment rules. This problem  illuminates a common trade-off in memory management and introduces the practical concept of repurposing the resulting \"slack\" space for metadata storage.",
            "id": "3683644",
            "problem": "A slab allocator in an operating system manages memory by carving fixed-size objects out of page-sized slabs. Consider a cache of objects with size $s = 88$ bytes, subject to an alignment requirement $a = 64$ bytes for the starting address of every object. The system page size is $P = 4096$ bytes. Assume that page base addresses are aligned to $P$ and thus to $a$.\n\nUse the following fundamental base:\n- A slab divides a page into equal-sized slots, each of which has a stride $t$ that is large enough to contain the object and to ensure that the starting address of each slot satisfies the alignment requirement.\n- An alignment requirement of $a$ bytes means every object’s starting address must be a multiple of $a$.\n- The number of whole objects that fit in one page is the largest integer $n$ such that $n \\cdot t \\leq P$.\n- The per-page internal fragmentation slack $S$ is defined as the difference between the page size and the total useful payload: $S = P - n \\cdot s$.\n- Slack bytes can be repurposed for slab metadata if they are not otherwise required to satisfy alignment or object storage.\n\nTasks:\n1. Determine the adjusted stride $t$ that satisfies the alignment requirement for all objects in the slab.\n2. Determine the number of objects $n$ that fit into a single page of size $P$ using stride $t$.\n3. Determine the per-page internal fragmentation slack $S$ defined as $S = P - n \\cdot s$.\n4. Propose using all slack $S$ for per-slab metadata.\n\nReport, as your final answer, the maximum number of bytes available for slab metadata per page when all slack is repurposed for metadata. Express your final answer as an exact integer number in bytes. Do not include units in your final boxed answer.",
            "solution": "The solution requires calculating the total slack space $S$ on a single page, which is designated for metadata. The formula given is $S = P - n \\cdot s$. To compute $S$, we must first determine the number of objects per page, $n$, which in turn requires finding the per-object stride, $t$.\n\n**1. Determine the adjusted stride $t$.**\n\nThe stride, $t$, is the distance between the starting addresses of consecutive objects. It must satisfy two constraints:\na) It must be large enough to hold one object: $t \\ge s$.\nb) It must be a multiple of the alignment $a$, since the page base address is aligned and all subsequent objects at offsets $t, 2t, 3t, \\dots$ must also be aligned.\n\nGiven $s = 88$ bytes and $a = 64$ bytes, we must find the smallest multiple of $64$ that is greater than or equal to $88$.\n$$t = a \\times \\left\\lceil \\frac{s}{a} \\right\\rceil = 64 \\times \\left\\lceil \\frac{88}{64} \\right\\rceil = 64 \\times \\lceil 1.375 \\rceil = 64 \\times 2 = 128 \\text{ bytes}.$$\n\n**2. Determine the number of objects $n$.**\n\nThe number of objects, $n$, that can fit into a single page is the page size divided by the stride, rounding down to the nearest integer.\n$$n = \\left\\lfloor \\frac{P}{t} \\right\\rfloor$$\nUsing the page size $P = 4096$ bytes and the calculated stride $t = 128$ bytes:\n$$n = \\left\\lfloor \\frac{4096}{128} \\right\\rfloor = 32.$$\nThus, a single page can hold $n=32$ objects.\n\n**3. Determine the per-page internal fragmentation slack $S$.**\n\nThe slack $S$ is the total page size minus the space consumed by the actual object data (the payload).\n$$S = P - n \\cdot s$$\nSubstituting the known values: $P = 4096$, $n = 32$, and $s = 88$.\nFirst, calculate the total useful payload size:\n$$n \\cdot s = 32 \\cdot 88 = 2816 \\text{ bytes}.$$\nNow, calculate the slack $S$:\n$$S = 4096 - 2816 = 1280 \\text{ bytes}.$$\nThis slack represents the memory on the page not used for storing object data, primarily due to alignment padding. The problem states this entire amount can be repurposed for metadata.\n\n**4. Determine available metadata space.**\n\nThe maximum number of bytes available for per-slab metadata is equal to the total slack $S$.\n\nMaximum metadata space = $S = 1280$ bytes.",
            "answer": "$$\n\\boxed{1280}\n$$"
        },
        {
            "introduction": "After mastering the static layout of a slab, it's crucial to understand the allocator's dynamic behavior over time. The policy for managing free objects has profound implications for system performance, particularly cache locality and memory reclamation. This thought experiment  challenges you to compare the Last-In, First-Out (LIFO) and First-In, First-Out (FIFO) freelist disciplines, revealing a classic trade-off between optimizing for allocation speed and enabling efficient memory return to the system.",
            "id": "3683573",
            "problem": "A kernel uses a slab allocator for a single object type. Each slab contains $m$ fixed-size objects and transitions among three states: full (no free objects), partial (some free objects), and empty (all $m$ free). When a slab becomes empty, the allocator returns its physical pages to the page allocator. The allocator maintains a per-processor freelist of object pointers and always services an allocation by removing the next pointer from this freelist. The freelist discipline is either Last-In, First-Out (LIFO) or First-In, First-Out (FIFO). Consider a long-running workload in which $S$ independent flows repeatedly allocate an object, perform a brief operation, and free it. At the object level, the identity of the freed object is approximately uniformly distributed across currently allocated objects, so frees are effectively spread across slabs without bias. Assume no cross-processor contention and that allocation always comes from the local freelist.\n\nUsing only the following foundations:\n- The definition of spatial locality: successive allocations drawn from addresses that are close in memory (e.g., from the same slab) have higher spatial locality than allocations spread across different slabs.\n- The definition of the freelist disciplines: LIFO returns the most recently freed object first; FIFO returns the least recently freed object first.\n- The condition for a slab to be returned to the system: it must reach $0$ allocated objects (i.e., all $m$ objects are free simultaneously).\n\nCompare LIFO versus FIFO with respect to both (i) the spatial locality of successive allocations and (ii) the steady-state likelihood that a particular slab reaches the empty state and is returned to the page allocator. Which statement is most accurate?\n\nA. LIFO increases spatial locality by preferentially reusing recently freed objects within the same slab, and it decreases the likelihood that any slab becomes empty; FIFO reduces spatial locality and increases the likelihood that slabs become empty and can be returned.\n\nB. LIFO reduces spatial locality by scattering allocations across slabs, and it increases the likelihood that slabs become empty; FIFO improves locality and reduces emptying.\n\nC. The order of the freelist (LIFO versus FIFO) is irrelevant in steady state under uniformly random frees, so both spatial locality and slab-emptying likelihood are the same.\n\nD. LIFO increases spatial locality but also increases the likelihood of empty slabs because it concentrates frees into the same slab more often than FIFO.\n\nE. FIFO increases spatial locality by reusing the most recent frees and therefore reduces the likelihood of empty slabs relative to LIFO.",
            "solution": "This problem requires analyzing the effects of two different freelist management policies, LIFO and FIFO, on the performance and behavior of a slab allocator. We will evaluate each policy against the two specified criteria: spatial locality and the likelihood of a slab becoming empty.\n\n**1. LIFO (Last-In, First-Out) Discipline**\n\n*   **Mechanism:** In a LIFO freelist, the most recently freed object is placed at the head of the list and is the first to be reallocated.\n*   **Impact on Spatial Locality:** This creates a tight loop of reuse. An object that is freed is very likely to be the next one allocated, especially in workloads with rapid allocate-free cycles. This recycling happens within a small set of \"hot\" objects, which likely reside in the same slab. Since successive allocations come from the same memory region, LIFO behavior leads to high spatial locality, improving CPU cache performance. Therefore, LIFO **increases spatial locality**.\n*   **Impact on Slab Emptying:** Because LIFO continuously reuses a few hot objects, it prevents the slabs containing those objects from ever becoming fully free. A slab transitions from `partial` to `empty` only when all its objects are simultaneously on the freelist. LIFO works against this by keeping `partial` slabs in active use, thereby **decreasing the likelihood** that a slab will become empty and be returned to the system.\n\n**2. FIFO (First-In, First-Out) Discipline**\n\n*   **Mechanism:** In a FIFO freelist, a freed object is added to the tail of the list. The next allocation takes the object from the head of the list—the one that has been free for the longest time.\n*   **Impact on Spatial Locality:** This policy forces a rotation through the entire pool of free objects. An object freed from slab A goes to the back of the queue. The next allocation will be an object from the front, which was freed much earlier and may belong to a completely different slab B. This spreads successive allocations across different slabs, **reducing spatial locality**.\n*   **Impact on Slab Emptying:** FIFO's \"oldest-free-first\" approach systematically drains the pool of free objects. An object in a slab, once freed, will not be reused until all objects freed before it have been allocated. This gives other objects in the same slab time to be freed. Consequently, this policy makes it statistically more likely that all objects in a slab become free at once, allowing the slab to transition to the `empty` state. Therefore, FIFO **increases the likelihood** that slabs become empty, which is beneficial for memory reclamation.\n\n**Conclusion:**\n\n*   **LIFO:** Maximizes spatial locality (good for performance) but is poor for memory reclamation (slabs are slow to empty).\n*   **FIFO:** Minimizes spatial locality (bad for performance) but is good for memory reclamation (slabs empty more quickly).\n\nBased on this analysis, option A correctly summarizes these trade-offs. LIFO increases locality and decreases emptying, while FIFO reduces locality and increases emptying.",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}