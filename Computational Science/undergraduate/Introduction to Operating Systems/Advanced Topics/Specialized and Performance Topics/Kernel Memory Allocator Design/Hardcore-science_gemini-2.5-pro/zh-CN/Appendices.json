{
    "hands_on_practices": [
        {
            "introduction": "在设计内存分配器时，一个基础但关键的决策是如何管理元数据。本练习探讨了两种常见策略的空间效率权衡：一种是将元数据作为头部附加到每个分配的对象上，另一种是将其外部化，集中管理。通过一个具体的计算场景，我们将量化这两种设计在不同分配数量下的元数据开销，并确定外部化方案开始显现优势的临界点。",
            "id": "3652204",
            "problem": "一个内核内存分配器必须满足一个包含 $n$ 个大小相同的对象的请求流。每个对象的载荷大小为 $s$ 字节。在一个朴素的“按对象”方案中，每个已分配的对象都带有一个大小为 $h$ 字节的头部，用于存储分配器的元数据。在一个“外部化”方案中，元数据被移出单个对象，并以一个固定大小的区域（一个“slab”）为粒度进行分组：每个 slab 保留 $H$ 字节的元数据，并提供 $S$ 字节用于对象载荷，没有按对象的头部。对象被紧密地打包在 slab 中，没有额外的填充。假设没有其他开销来源，并且 slab 根据需要用于顺序放置对象。\n\n仅使用以下基本定义：\n- 分配器元数据开销是分配器使用的、不属于应用程序载荷的总字节数。\n- 一个 slab 中能容纳的对象数量是不超过 slab 中可用载荷字节数与对象载荷大小之比的最大整数。\n- 所需 slab 的数量是其总对象容量至少为 $n$ 的 slab 的最小整数数量。\n\n假设 $s = 96$ 字节，$h = 24$ 字节，$S = 4096$ 字节，以及 $H = 128$ 字节。从第一性原理出发，为两种设计推导总分配器元数据开销作为 $n$ 的函数。然后确定最小整数 $n^{\\star}$，使得外部化方案使用的元数据字节数严格少于按对象方案。\n\n最终答案只提供 $n^{\\star}$ 的值。无需四舍五入，$n^{\\star}$ 也不需要单位（它是一个对象计数）。",
            "solution": "本题要求比较两种元数据管理方案的开销，并找出外部化方案开始优于按对象方案的临界点 $n^{\\star}$。\n\n**1. 定义两种方案的元数据开销函数**\n\n*   **按对象 (Per-Object) 方案, $O_p(n)$**:\n    每个对象都有一个大小为 $h$ 的头部。对于 $n$ 个对象，总元数据开销是：\n    $O_p(n) = n \\times h$\n\n*   **外部化 (Externalized) 方案, $O_e(n)$**:\n    元数据按 slab 管理。首先，计算一个 slab 能容纳多少个对象。\n    -   Slab 可用载荷空间: $S$\n    -   单个对象载荷大小: $s$\n    -   每个 slab 能容纳的对象数, $k = \\lfloor \\frac{S}{s} \\rfloor$\n    然后，计算需要多少个 slab 来容纳 $n$ 个对象。\n    -   所需 slab 数, $N_{\\text{slabs}} = \\lceil \\frac{n}{k} \\rceil$\n    每个 slab 有 $H$ 字节的元数据开销。总元数据开销是：\n    $O_e(n) = N_{\\text{slabs}} \\times H = \\lceil \\frac{n}{\\lfloor S/s \\rfloor} \\rceil \\times H$\n\n**2. 代入给定参数**\n\n给定的参数为：\n- $s = 96$ 字节\n- $h = 24$ 字节\n- $S = 4096$ 字节\n- $H = 128$ 字节\n\n首先计算每个 slab 能容纳的对象数 $k$：\n$k = \\lfloor \\frac{4096}{96} \\rfloor = \\lfloor 42.66... \\rfloor = 42$ 个对象\n\n现在，我们可以写出两种方案具体的开销函数：\n- $O_p(n) = 24n$\n- $O_e(n) = \\lceil \\frac{n}{42} \\rceil \\times 128$\n\n**3. 求解不等式**\n\n我们需要找到最小的整数 $n^{\\star}$，使得 $O_e(n)  O_p(n)$，即：\n$$\\lceil \\frac{n}{42} \\rceil \\times 128  24n$$\n\n我们可以通过测试 $n$ 的值来求解。注意到对于 $1 \\le n \\le 42$，$\\lceil n/42 \\rceil$ 的值恒为 $1$。因此，在这个区间内，不等式简化为：\n$$1 \\times 128  24n$$\n$$n > \\frac{128}{24}$$\n$$n > \\frac{16}{3} \\approx 5.333$$\n\n由于 $n$ 必须是整数，满足此条件的最小整数是 $n=6$。\n\n我们可以验证当 $n=5$ 时，不等式不成立：\n$O_e(5) = \\lceil 5/42 \\rceil \\times 128 = 1 \\times 128 = 128$\n$O_p(5) = 5 \\times 24 = 120$\n$128 \\not 120$\n\n当 $n=6$ 时，不等式成立：\n$O_e(6) = \\lceil 6/42 \\rceil \\times 128 = 1 \\times 128 = 128$\n$O_p(6) = 6 \\times 24 = 144$\n$128  144$\n\n因此，外部化方案开始显现优势的最小对象数是 $n^{\\star} = 6$。",
            "answer": "$$\\boxed{6}$$"
        },
        {
            "introduction": "在解决了元数据开销后，我们转向另一个关键的效率指标：内部碎片。当分配器使用固定大小的内存块来满足可变大小的请求时，必然会产生空间浪费。本练习展示了如何通过分析一个假设的请求大小分布，来系统地选择最优的大小类组合，从而将这种内部碎片降至最低。",
            "id": "3652158",
            "problem": "一个内核为小对象使用分离式空闲列表分配器。每个大小为 $s$ 字节的分配请求都会被向上取整到满足 $c \\geq s$ 的最小可用大小类 $c$，并返回一个大小为 $c$ 的对象。对于一个大小为 $s$ 的请求，由大小类 $c$ 来满足时，其内部碎片定义为 $c - s$。期望内部碎片是在观测到的请求大小分布下，$c - s$ 的期望值。该分配器被限制为只能使用三个大小类，这些大小类从允许的集合 $C = \\{16, 32, 48, 64, 80, 96\\}$ 字节中选择，且最大的大小类固定为 $96$ 字节。\n\n您对系统进行检测，获得了一个随时间稳定的请求大小的离散概率质量函数（PMF）。观测到的请求仅有以下大小（单位为字节）及其相关概率：\n- $11$，概率 $0.1$\n- $15$，概率 $0.1$\n- $17$，概率 $0.05$\n- $20$，概率 $0.1$\n- $29$，概率 $0.1$\n- $31$，概率 $0.05$\n- $33$，概率 $0.1$\n- $45$，概率 $0.05$\n- $49$，概率 $0.1$\n- $63$，概率 $0.05$\n- $79$，概率 $0.1$\n- $95$，概率 $0.1$\n\n当前，分配器使用 $16$、$64$ 和 $96$ 字节这几个大小类，并表现出很高的内部碎片。您的任务是在所述约束下重新设计大小类的边界，以最小化期望内部碎片。\n\n从上述定义和观测到的PMF出发，通过从 $C$ 中选择最优的三个大小类（最大类固定为 $96$ 字节），计算可实现的最小期望内部碎片（单位为字节/请求）。将您的答案四舍五入到四位有效数字。以字节/请求为单位表示最终结果。",
            "solution": "本题的目标是通过选择最优的大小类组合，来最小化分离式空闲列表分配器的期望内部碎片。\n\n**1. 定义期望内部碎片**\n\n期望内部碎片 $E[F]$ 是所有可能请求大小的内部碎片与其发生概率的加权平均值。对于一个大小为 $s_i$、概率为 $p_i$ 的请求，如果它由大小为 $c(s_i)$ 的内存块满足，则其内部碎片为 $c(s_i) - s_i$。因此，期望内部碎片为：\n$$E[F] = \\sum_{i} p_i (c(s_i) - s_i)$$\n其中，$c(s_i)$ 是满足 $c \\ge s_i$ 的最小可用大小类。\n\n**2. 确定优化空间**\n\n约束条件是：\n- 必须选择三个大小类 $\\{c_1, c_2, c_3\\}$。\n- $c_3$ 固定为 $96$ 字节。\n- $c_1$ 和 $c_2$ 必须从集合 $\\{16, 32, 48, 64, 80\\}$ 中选择，且 $c_1  c_2$。\n\n可能的 $(c_1, c_2)$ 组合共有 $\\binom{5}{2} = 10$ 种。我们需要对每一种组合计算 $E[F]$，并找出最小值。\n\n**3. 整理请求分布数据**\n\n我们将请求大小 ($s_i$) 和概率 ($p_i$) 整理如下：\n\n| $s_i$ (字节) | $p_i$  | | $s_i$ (字节) | $p_i$  |\n|--------------|--------|---|--------------|--------|\n| 11           | 0.1    | | 33           | 0.1    |\n| 15           | 0.1    | | 45           | 0.05   |\n| 17           | 0.05   | | 49           | 0.1    |\n| 20           | 0.1    | | 63           | 0.05   |\n| 29           | 0.1    | | 79           | 0.1    |\n| 31           | 0.05   | | 95           | 0.1    |\n\n**4. 计算并比较所有可能组合的 $E[F]$**\n\n我们系统地为每种可能的 $\\{c_1, c_2, 96\\}$ 组合计算期望内部碎片。对于一个给定的组合 $\\{c_1, c_2, 96\\}$，请求大小 $s \\le c_1$ 由 $c_1$ 服务；$c_1  s \\le c_2$ 由 $c_2$ 服务；$c_2  s \\le 96$ 由 $96$ 服务。\n\n| 组合 $\\{c_1, c_2, 96\\}$ | $E[F]$ (字节/请求) |\n|-------------------------|----------------------|\n| $\\{16, 32, 96\\}$        | 19.90                |\n| $\\{16, 48, 96\\}$        | 17.50                |\n| $\\{16, 64, 96\\}$        | 19.90                |\n| $\\{16, 80, 96\\}$        | 27.90                |\n| $\\{32, 48, 96\\}$        | 15.90                |\n| **$\\{32, 64, 96\\}$**    | **13.50**            |\n| $\\{32, 80, 96\\}$        | 16.70                |\n| $\\{48, 64, 96\\}$        | 19.10                |\n| $\\{48, 80, 96\\}$        | 19.90                |\n| $\\{64, 80, 96\\}$        | 27.90                |\n\n**5. 确定最优解**\n\n通过比较上表中的所有结果，可以发现期望内部碎片的最小值为 $13.50$ 字节/请求，这个值是在大小类组合为 $\\{32, 64, 96\\}$ 字节时实现的。\n\n因此，可实现的最小期望内部碎片是 $13.50$ 字节/请求。",
            "answer": "$$\\boxed{13.50}$$"
        },
        {
            "introduction": "内存分配器的设计不仅要考虑空间效率，还必须满足特定的执行上下文约束，尤其是在内核的中断处理程序等时间敏感环境中。在这些环境中，分配操作绝不能阻塞或休眠。本练习引导我们思考如何设计一个预留的、无锁的对象池来满足这些严苛要求，并运用基本的性能分析原理来计算确保系统在峰值负载下稳定运行所需的最小池容量。",
            "id": "3652214",
            "problem": "一个在单中央处理器（CPU）上运行的内核必须在中断处理程序执行期间进行固定大小的内存分配。在中断上下文中，抢占被禁用，并且禁止休眠。通用分配器可能会阻塞（例如，等待互斥锁），也可能触发页错误，这两者在中断上下文中都是不允许的。为保证处理能够继续进行，内核设计者考虑使用一个预先保留的、每个CPU专属的、专用于中断时分配的无锁对象池。每次中断从该池中即时分配恰好 $n$ 个对象，持有它们一段有界的时间 $t_{h}$，然后将它们释放回池中。在持续的峰值负载下，中断以速率 $\\lambda$ 到达该CPU。假设到达过程能够将峰值速率 $\\lambda$ 维持足够长的时间，使得在 $t_{h}$ 上的稳态平均有意义，并假设在中断上下文中不会发生从通用分配器进行的补充。\n\n从中断上下文施加的约束以及到达和释放之间的流守恒原理出发，推导出在中断上下文中的任何分配路径都必须是非阻塞的，并且必须完全由预留池满足的要求。然后，仅使用关于对象到达速率和在系统中停留时间之间关系的第一性原理推理，得出一个为维持峰值中断速率而不发生分配失败所需的最小池容量 $P$（以对象数量计）的表达式。\n\n最后，根据以下参数评估您的表达式：\n- 峰值中断速率 $\\lambda = 1.2 \\times 10^{5}$ 次中断/秒。\n- 每次中断的对象数 $n = 2$。\n- 每次中断的持有时间 $t_{h} = 2.0 \\times 10^{-4}$ 秒。\n\n将您最终的 $P$ 表示为纯粹的对象计数（无单位）。无需进行四舍五入；报告在所述峰值条件下避免分配失败所需的确切整数。",
            "solution": "首先，我们分析在中断上下文中进行内存分配的约束。中断处理程序在执行时通常会禁用抢占，并且绝不能阻塞或休眠。如果它因等待锁或处理页错误而暂停，整个CPU乃至系统都可能被冻结。因此，通用分配器（可能阻塞或触发页错误）在此处不可用。一个预留的、每个CPU专属的、无锁的对象池是理想的解决方案，因为它能保证分配操作快速、无阻塞，且内存是预先分配好的（物理驻留的）。\n\n接下来，我们推导维持峰值负载所需的最小池容量 $P$。这可以应用排队论中的**利特尔法则 (Little's Law)** 来解决，该法则建立了系统中对象的平均数量、到达速率和停留时间之间的关系。\n\n1.  **计算对象的总到达速率 ($R_{alloc}$)**\n    系统以速率 $\\lambda$ 接收中断，每次中断需要 $n$ 个对象。因此，对象被请求的总速率为：\n    $$R_{alloc} = n \\times \\lambda$$\n\n2.  **计算稳态下正在使用的对象数量 ($N_{in\\_use}$)**\n    在稳态下，任何时刻系统中正在使用的对象数量，等于对象的到达速率乘以每个对象在系统中的平均停留时间（即持有时间 $t_h$）。\n    $$N_{in\\_use} = R_{alloc} \\times t_h = (n \\lambda) t_h$$\n\n3.  **确定最小池容量 ($P$)**\n    为了确保在持续的峰值负载下，任何分配请求都能被满足，池的容量必须至少等于稳态下正在使用的对象总数。因此，最小池容量 $P$ 为：\n    $$P = n \\lambda t_h$$\n\n最后，我们将给定的参数代入此公式进行计算：\n- $\\lambda = 1.2 \\times 10^{5}$ 次中断/秒\n- $n = 2$ 个对象/次中断\n- $t_{h} = 2.0 \\times 10^{-4}$ 秒\n\n$$P = (2) \\times (1.2 \\times 10^{5} \\, \\text{s}^{-1}) \\times (2.0 \\times 10^{-4} \\, \\text{s})$$\n$$P = 4.8 \\times 10^{(5-4)}$$\n$$P = 4.8 \\times 10^{1}$$\n$$P = 48$$\n\n因此，为避免在峰值负载下发生分配失败，所需的最小池容量为 $48$ 个对象。",
            "answer": "$$\\boxed{48}$$"
        }
    ]
}