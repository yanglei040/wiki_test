{
    "hands_on_practices": [
        {
            "introduction": "The buddy system is a classic and elegant algorithm for managing physical memory in power-of-two-sized chunks. Its performance hinges on the efficiency of its two core operations: splitting large blocks to satisfy smaller requests and coalescing 'buddy' blocks upon being freed. This exercise  challenges you to analyze the worst-case latency of these operations, providing a crucial understanding of the allocator's performance guarantees and how to bound them in a real-time environment.",
            "id": "3652110",
            "problem": "A computer system uses a buddy memory allocator inside the operating system kernel to manage physical memory in units of pages. The allocator organizes memory into power-of-two sized blocks: a block at order $o$ consists of $2^{o}$ pages. The allocator maintains free lists for orders $0$ through $m$, where the maximum managed block has order $m$. A request for a block of $2^{k}$ pages (order $k$), with $0 \\leq k \\leq m$, is satisfied by repeatedly splitting a larger free block: each split of an order $o$ block produces two buddies of order $o-1$, one of which is chosen for further splitting until an order $k$ block is obtained. On freeing an order $k$ block, the allocator coalesces it with its buddy if the buddy is free to form an order $k+1$ block, and repeats this process upward as long as buddies are free.\n\nAssume the following worst-case conditions hold on the critical path of allocation and free:\n- For the allocation, immediately before the request, the free lists at orders $k, k+1, \\ldots, m-1$ are empty, and there is exactly one free block available at order $m$.\n- For the free, immediately before the block is freed, exactly the necessary buddies exist in the free lists to allow maximal coalescing upward from order $k$.\n\nAssume the per-operation latency on the critical path is proportional to the number of block-transformation steps, where each split or merge counts as unit cost $1$. You may assume that reading or updating metadata has negligible cost compared to splits and merges, and that no contention or cache effects alter this proportionality.\n\n(1) From first principles of the buddy allocatorâ€™s structure, derive the maximum number of splits required to satisfy the allocation request and the maximum number of merges that can occur on free of the same block in the worst case described above. Express each quantity in terms of $m$ and $k$.\n\n(2) To cap worst-case per-operation latency, the kernel designer introduces a strict critical-path split/merge stop-order policy parameter $r \\in \\mathbb{Z}$ with $k \\leq r \\leq m$. Under this policy:\n- On allocation, the kernel will only split on the critical path from order $r$ down to order $k$, deferring any splitting above order $r$ to a background maintenance thread.\n- On free, the kernel will coalesce only up to order $r$ on the critical path, deferring any coalescing above order $r$ to the background thread.\n\nGiven an integer latency cap $L \\in \\mathbb{Z}_{\\geq 0}$ that bounds the number of split or merge steps allowed on the critical path for any single allocation or free, choose $r$ to maximize on-path reclamation (that is, make $r$ as large as possible) while ensuring that the worst-case number of on-path splits or merges for the order-$k$ block does not exceed $L$. What is the resulting $r$ as a closed-form expression in terms of $m$, $k$, and $L$? Report only this expression as your final answer. No units are required and no rounding is needed.",
            "solution": "The problem statement is evaluated as valid. It is a well-posed, scientifically grounded problem in the domain of operating system kernel design, specifically concerning the analysis of the buddy memory allocation algorithm. The premises are clear, consistent, and formalizable into a mathematical model. The requested derivations and optimization are standard exercises in algorithm analysis.\n\nPart (1): Derivation of Worst-Case Latency\n\nFirst, we analyze the number of splits required for an allocation in the specified worst-case scenario. The request is for a block of order $k$, where a block of order $o$ contains $2^o$ pages. The allocator's state is such that the only available memory is a single block of the maximum order, $m$. The free lists for all intermediate orders, from $k$ to $m-1$, are empty.\n\nTo obtain a block of order $k$, the allocator must start with the order $m$ block and recursively split it.\n1.  A block of order $o$ is split to produce two \"buddy\" blocks of order $o-1$. This is defined as a single split operation with a cost of $1$.\n2.  To get from order $m$ to order $m-1$, one split is performed on the order $m$ block.\n3.  To get from order $m-1$ to order $m-2$, one split is performed on one of the newly created order $m-1$ blocks.\n4.  This process continues until a block of the desired order $k$ is produced. The final split required is on a block of order $k+1$ to produce two blocks of order $k$.\n\nThe sequence of block orders that must be split is $m, m-1, m-2, \\ldots, k+1$. The number of splits, $N_{\\text{splits}}$, is the count of elements in this sequence. This is an arithmetic progression. The number of terms is given by:\n$$N_{\\text{splits}} = m - (k+1) + 1 = m - k$$\nThus, the maximum number of splits required for the allocation is $m-k$.\n\nNext, we analyze the number of merges (coalesces) performed when freeing the same block in the specified worst-case scenario. We are freeing a block of order $k$. The condition for a \"worst-case\" free operation, in terms of maximizing upward coalescing, is that for each step of merging, the corresponding buddy block is also free.\n1.  When the order $k$ block is freed, it is checked against its buddy. If the buddy is free, they are merged to form a single block of order $k+1$. This is one merge operation with a cost of $1$.\n2.  This newly formed block of order $k+1$ is then checked against its own buddy. If that buddy is free, they merge to form a block of order $k+2$. This is a second merge operation.\n3.  The problem states that this process continues as high as possible, which means it will proceed until a block of order $m$ is formed. The final merge combines two blocks of order $m-1$ to form the single block of order $m$.\n\nThe sequence of new blocks formed by merging is of orders $k+1, k+2, \\ldots, m$. The number of merge operations, $N_{\\text{merges}}$, is the count of operations required to form these blocks. Each formation corresponds to one merge. The number of merges is therefore:\n$$N_{\\text{merges}} = m - (k+1) + 1 = m - k$$\nThus, the maximum number of merges that can occur is also $m-k$.\n\nPart (2): Derivation of the Optimal Policy Parameter $r$\n\nA new policy is introduced with a parameter $r$, where $k \\leq r \\leq m$, and a latency cap $L \\in \\mathbb{Z}_{\\geq 0}$. The number of on-path (critical path) operations is limited.\n\nFor an allocation of an order $k$ block, the critical path work is defined as splitting from order $r$ down to order $k$. Applying the logic from Part (1), the number of on-path splits, $N_{\\text{splits, on-path}}$, is the number of splits to get from order $r$ to order $k$. This corresponds to splitting blocks of orders $r, r-1, \\ldots, k+1$.\n$$N_{\\text{splits, on-path}} = r - (k+1) + 1 = r - k$$\n\nFor a free operation, the critical path work is defined as coalescing from order $k$ up to order $r$. This means forming blocks of orders $k+1, k+2, \\ldots, r$. The number of on-path merges, $N_{\\text{merges, on-path}}$, is the number of merge operations in this sequence.\n$$N_{\\text{merges, on-path}} = r - (k+1) + 1 = r - k$$\n\nThe latency cap $L$ requires that the number of on-path operations for any single allocation or free must not exceed $L$. Since both quantities are equal, this imposes a single constraint:\n$$r - k \\leq L$$\nwhich can be rewritten as:\n$$r \\leq k + L$$\n\nThe objective is to choose $r$ to be as large as possible (\"maximize on-path reclamation\") while adhering to all constraints. The constraints on $r$ are:\n1.  From the problem definition: $r \\leq m$.\n2.  From the latency cap derivation: $r \\leq k + L$.\n3.  From the problem definition: $r \\geq k$. Since $L \\geq 0$, the inequality $r \\leq k + L$ automatically ensures $r \\geq k$ is possible. We are choosing the largest $r$, so this lower bound will be met.\n\nTo maximize $r$ while satisfying both upper bounds, $r$ must be less than or equal to both $m$ and $k+L$. Therefore, the largest possible value for $r$ is the minimum of these two quantities.\n$$r = \\min(m, k+L)$$\nThis expression for $r$ provides the largest possible order for on-path reclamation without violating the latency cap $L$ or the physical constraints of the memory system, which has a maximum order of $m$.",
            "answer": "$$\\boxed{\\min(m, k+L)}$$"
        },
        {
            "introduction": "While the buddy system is excellent for large, page-aligned allocations, kernels also need to efficiently manage numerous small objects. Segregated-list allocators address this by offering a menu of fixed-size 'classes', but this design introduces a trade-off: how do you pick the class sizes to minimize wasted space, a phenomenon known as internal fragmentation? This problem  puts you in the role of a systems tuner, using a workload distribution to find the optimal class configuration that minimizes waste.",
            "id": "3652158",
            "problem": "A kernel uses a segregated free-list allocator for small objects. Every allocation request of size $s$ bytes is rounded up to the smallest available size class $c$ such that $c \\geq s$, and an object of size $c$ is returned. Internal fragmentation for a request of size $s$ served by class $c$ is defined as $c - s$. The expected internal fragmentation is the expectation of $c - s$ under the observed request-size distribution. The allocator is constrained to exactly three size classes, chosen from the allowed set $C = \\{16, 32, 48, 64, 80, 96\\}$ bytes, with the largest class fixed at $96$ bytes.\n\nYou instrument the system and obtain a discrete probability mass function (PMF) of request sizes that is stable over time. The observed requests are exclusively the following sizes (in bytes) with associated probabilities:\n- $11$ with probability $0.1$\n- $15$ with probability $0.1$\n- $17$ with probability $0.05$\n- $20$ with probability $0.1$\n- $29$ with probability $0.1$\n- $31$ with probability $0.05$\n- $33$ with probability $0.1$\n- $45$ with probability $0.05$\n- $49$ with probability $0.1$\n- $63$ with probability $0.05$\n- $79$ with probability $0.1$\n- $95$ with probability $0.1$\n\nCurrently, the allocator uses classes $16$, $64$, and $96$ bytes and exhibits high internal fragmentation. You are asked to redesign the class boundaries under the stated constraints to minimize the expected internal fragmentation.\n\nStarting from the definitions above and the observed PMF, compute the minimal achievable expected internal fragmentation (in bytes per request) by selecting the optimal three classes from $C$ with the largest fixed at $96$ bytes. Round your answer to four significant figures. Express the final result in bytes per request.",
            "solution": "The problem statement is first subjected to a validation process.\n\n### Step 1: Extract Givens\n- **Allocator Type**: Segregated free-list for small objects.\n- **Allocation Rule**: A request of size $s$ is rounded up to the smallest available size class $c$ such that $c \\geq s$.\n- **Definition of Internal Fragmentation**: For a request of size $s$ served by class $c$, the internal fragmentation is $c - s$.\n- **Objective**: Minimize the expected internal fragmentation, which is the expectation of $c - s$ over the given request-size distribution.\n- **Constraints on Size Classes**:\n    - Exactly three size classes must be used.\n    - The size classes must be chosen from the set $C = \\{16, 32, 48, 64, 80, 96\\}$ bytes.\n    - The largest of the three classes is fixed at $96$ bytes.\n- **Probability Mass Function (PMF)** of request sizes ($s_i$ in bytes) and their probabilities ($p_i$):\n    - $s_1=11$, $p_1=0.1$\n    - $s_2=15$, $p_2=0.1$\n    - $s_3=17$, $p_3=0.05$\n    - $s_4=20$, $p_4=0.1$\n    - $s_5=29$, $p_5=0.1$\n    - $s_6=31$, $p_6=0.05$\n    - $s_7=33$, $p_7=0.1$\n    - $s_8=45$, $p_8=0.05$\n    - $s_9=49$, $p_9=0.1$\n    - $s_{10}=63$, $p_{10}=0.05$\n    - $s_{11}=79$, $p_{11}=0.1$\n    - $s_{12}=95$, $p_{12}=0.1$\n- **Current (suboptimal) classes**: $\\{16, 64, 96\\}$ bytes.\n- **Required Output**: The minimal achievable expected internal fragmentation, rounded to four significant figures.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is subjected to validation against the specified criteria.\n- **Scientifically Grounded**: The problem is well-grounded in the field of computer science, specifically operating systems design. The concepts of segregated-list allocators, size classes, and internal fragmentation are fundamental topics in memory management. The model presented is a standard, albeit simplified, representation of a real-world engineering design problem.\n- **Well-Posed**: The problem is well-posed. It defines a clear objective function (expected internal fragmentation) to be minimized, a discrete and finite set of choices for the optimization variables (the two smaller size classes), and provides all necessary data (the PMF of request sizes). The search space is finite, guaranteeing that a minimum value exists and is computable. The sum of the given probabilities is $8 \\times 0.1 + 4 \\times 0.05 = 0.8 + 0.2 = 1.0$. The PMF is valid.\n- **Objective**: The problem is stated in precise, objective language. All definitions, constraints, and data are quantitative and unambiguous.\n\nThe problem does not exhibit any of the flaws listed in the validation criteria. It is scientifically sound, fully specified, and computationally tractable.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A solution will be provided.\n\n### Solution\nThe objective is to find a set of three size classes $\\{c_1, c_2, c_3\\}$ that minimizes the expected internal fragmentation, $E[F]$. The fragmentation is defined for a request of size $s$ allocated from a block of size $c(s)$ as $F = c(s) - s$. The expected fragmentation is the sum of fragmentation for each request size, weighted by its probability:\n$$E[F] = \\sum_{i} p_i (c(s_i) - s_i)$$\nwhere $s_i$ are the request sizes, $p_i$ are their probabilities, and $c(s_i)$ is the smallest class size greater than or equal to $s_i$.\n\nThe constraints are:\n1. The classes are chosen from the set $C = \\{16, 32, 48, 64, 80, 96\\}$.\n2. There are exactly three classes, so the class set is $\\{c_1, c_2, c_3\\}$ with $c_1  c_2  c_3$.\n3. The largest class is fixed: $c_3 = 96$.\n\nThis implies that we must choose two classes, $c_1$ and $c_2$, from the set $\\{16, 32, 48, 64, 80\\}$ such that $c_1  c_2$. The number of possible pairs $(c_1, c_2)$ is given by the binomial coefficient $\\binom{5}{2} = \\frac{5 \\times 4}{2} = 10$. We must evaluate the expected fragmentation for each of these $10$ configurations and identify the minimum.\n\nThe PMF is given as:\n$P(s=11)=0.1$, $P(s=15)=0.1$, $P(s=17)=0.05$, $P(s=20)=0.1$, $P(s=29)=0.1$, $P(s=31)=0.05$, $P(s=33)=0.1$, $P(s=45)=0.05$, $P(s=49)=0.1$, $P(s=63)=0.05$, $P(s=79)=0.1$, $P(s=95)=0.1$.\n\nFor any choice of classes $\\{c_1, c_2, 96\\}$, a request of size $s$ is allocated as follows:\n- If $s \\le c_1$, it is served by class $c_1$.\n- If $c_1  s \\le c_2$, it is served by class $c_2$.\n- If $c_2  s \\le 96$, it is served by class $96$.\nAll request sizes given are $\\le 95$, so they are all serviceable.\n\nWe now systematically calculate the expected fragmentation $E[F]$ for each of the $10$ possible class sets.\n\n1.  **Classes $\\{16, 32, 96\\}$**:\n    $E[F] = 0.1(16-11) + 0.1(16-15) + 0.05(32-17) + 0.1(32-20) + 0.1(32-29) + 0.05(32-31) + 0.1(96-33) + 0.05(96-45) + 0.1(96-49) + 0.05(96-63) + 0.1(96-79) + 0.1(96-95) = 19.9$ bytes/request.\n\n2.  **Classes $\\{16, 48, 96\\}$**:\n    $E[F] = 0.1(16-11) + 0.1(16-15) + 0.05(48-17) + 0.1(48-20) + 0.1(48-29) + 0.05(48-31) + 0.1(48-33) + 0.05(48-45) + 0.1(96-49) + 0.05(96-63) + 0.1(96-79) + 0.1(96-95) = 17.5$ bytes/request.\n\n3.  **Classes $\\{16, 64, 96\\}$** (the current configuration):\n    $E[F] = 0.1(16-11) + 0.1(16-15) + 0.05(64-17) + 0.1(64-20) + 0.1(64-29) + 0.05(64-31) + 0.1(64-33) + 0.05(64-45) + 0.1(64-49) + 0.05(64-63) + 0.1(96-79) + 0.1(96-95) = 19.9$ bytes/request.\n\n4.  **Classes $\\{16, 80, 96\\}$**:\n    $E[F] = 0.1(16-11) + 0.1(16-15) + 0.05(80-17) + \\dots + 0.1(80-79) + 0.1(96-95) = 27.9$ bytes/request.\n\n5.  **Classes $\\{32, 48, 96\\}$**:\n    $E[F] = 0.1(32-11) + 0.1(32-15) + 0.05(32-17) + 0.1(32-20) + 0.1(32-29) + 0.05(32-31) + 0.1(48-33) + 0.05(48-45) + 0.1(96-49) + \\dots + 0.1(96-95) = 15.9$ bytes/request.\n\n6.  **Classes $\\{32, 64, 96\\}$**:\n    $E[F] = [0.1(32-11) + 0.1(32-15) + 0.05(32-17) + 0.1(32-20) + 0.1(32-29) + 0.05(32-31)] + [0.1(64-33) + 0.05(64-45) + 0.1(64-49) + 0.05(64-63)] + [0.1(96-79) + 0.1(96-95)]$\n    $E[F] = [2.1 + 1.7 + 0.75 + 1.2 + 0.3 + 0.05] + [3.1 + 0.95 + 1.5 + 0.05] + [1.7 + 0.1]$\n    $E[F] = 6.1 + 5.6 + 1.8 = 13.5$ bytes/request.\n\n7.  **Classes $\\{32, 80, 96\\}$**:\n    $E[F] = 6.1 + [0.1(80-33) + \\dots + 0.1(80-79)] + [0.1(96-95)] = 16.7$ bytes/request.\n\n8.  **Classes $\\{48, 64, 96\\}$**:\n    $E[F] = [0.1(48-11) + \\dots + 0.05(48-45)] + [0.1(64-49) + 0.05(64-63)] + [0.1(96-79) + 0.1(96-95)] = 19.1$ bytes/request.\n\n9.  **Classes $\\{48, 80, 96\\}$**:\n    $E[F] = [0.1(48-11) + \\dots + 0.05(48-45)] + [0.1(80-49) + \\dots + 0.1(80-79)] + [0.1(96-95)] = 19.9$ bytes/request.\n\n10. **Classes $\\{64, 80, 96\\}$**:\n    $E[F] = [0.1(64-11) + \\dots + 0.05(64-63)] + [0.1(80-79)] + [0.1(96-95)] = 27.9$ bytes/request.\n\nA summary of the expected fragmentation for each configuration:\n- $\\{16, 32, 96\\}: 19.9$\n- $\\{16, 48, 96\\}: 17.5$\n- $\\{16, 64, 96\\}: 19.9$\n- $\\{16, 80, 96\\}: 27.9$\n- $\\{32, 48, 96\\}: 15.9$\n- $\\{32, 64, 96\\}: 13.5$\n- $\\{32, 80, 96\\}: 16.7$\n- $\\{48, 64, 96\\}: 19.1$\n- $\\{48, 80, 96\\}: 19.9$\n- $\\{64, 80, 96\\}: 27.9$\n\nThe minimum value is $13.5$, achieved with the size classes $\\{32, 64, 96\\}$.\nThe problem requires the answer to be rounded to four significant figures. The value $13.5$ is written as $13.50$ to meet this requirement.\nThe minimal achievable expected internal fragmentation is $13.50$ bytes per request.",
            "answer": "$$\\boxed{13.50}$$"
        },
        {
            "introduction": "Not all parts of a kernel are created equal; code running in an interrupt handler operates under extreme constraints where it cannot block or sleep, making calls to a general-purpose allocator unsafe. This practice  explores the design of a specialized allocator for this critical context, using a pre-reserved object pool. You will apply a fundamental principle from performance analysis to determine the minimum pool size needed to guarantee allocation success, even under a sustained peak load.",
            "id": "3652214",
            "problem": "A kernel running on a single Central Processing Unit (CPU) must perform fixed-size memory allocations during an interrupt handler. In an interrupt context, preemption is disabled and sleeping is forbidden. The general-purpose allocator may block (for example, on a mutex), and can also trigger page faults, both of which are impermissible in interrupt context. To guarantee progress, the kernel designer considers using a pre-reserved, per-CPU, lock-free object pool dedicated to interrupt-time allocations. Each interrupt instantaneously allocates exactly $n$ objects from this pool, holds them for a bounded time $t_{h}$, and then frees them back to the pool. At sustained peak load, interrupts arrive at rate $\\lambda$ on that CPU. Assume the arrival process is such that the peak rate $\\lambda$ can be maintained for long enough that steady-state averaging over $t_{h}$ is meaningful, and assume no refilling from the general allocator occurs while in interrupt context.\n\nStarting from the constraints imposed by interrupt context and the conservation-of-flow principle between arrivals and releases, derive the requirement that any allocation path in interrupt context must be non-blocking and must be satisfied entirely from the pre-reserved pool. Then, using only first-principles reasoning about the relationship between arrival rate and time-in-system for the objects, obtain an expression for the minimal pool capacity $P$ (in objects) needed to sustain the peak interrupt rate without allocation failure.\n\nFinally, evaluate your expression for the following parameters:\n- Peak interrupt rate $\\lambda = 1.2 \\times 10^{5}$ interrupts per second.\n- Objects per interrupt $n = 2$.\n- Hold time per interrupt $t_{h} = 2.0 \\times 10^{-4}$ seconds.\n\nExpress your final $P$ as a pure count of objects (no units). No rounding instruction is necessary; report the exact integer required to avoid allocation failure under the stated peak conditions.",
            "solution": "The problem is valid. It is scientifically grounded in the principles of operating system design, specifically memory management in constrained execution contexts like interrupt handlers. It is well-posed, providing all necessary information to derive a unique and meaningful solution. The language is objective and the scenario is a classic, formalizable problem in computer systems performance analysis.\n\nThe first part of the problem requires deriving the necessity of a non-blocking allocation path from a pre-reserved pool for interrupt context. The fundamental constraints of an interrupt handler on a single Central Processing Unit (CPU) are that preemption is disabled and the handler cannot sleep or block. Disabling preemption ensures that the handler runs to completion without being interrupted by other tasks on the same CPU. If an interrupt handler were to block (e.g., waiting for a lock) or sleep (e.g., waiting for I/O after a page fault), it would halt all processing on that CPU, leading to system freezes and potential deadlocks. The general-purpose memory allocator is unsuitable for this context because it may need to acquire locks to manage a global heap, or it might try to allocate memory that is not physically resident, triggering a page fault. A page fault is a blocking event. Therefore, to guarantee system progress and stability, any allocation within an interrupt handler must come from an allocator that is guaranteed to be non-blocking and to not cause page faults. A pre-reserved, per-CPU, lock-free object pool satisfies these stringent requirements. The memory is allocated upfront, ensuring it is resident, and the lock-free design ensures that an allocation request can be fulfilled without blocking.\n\nThe second part of the problem requires deriving the minimal pool capacity, $P$, needed to sustain the peak workload. This can be determined using a first-principles argument based on conservation of flow, which is formalized by Little's Law from queuing theory. Let $\\lambda$ be the rate of interrupts per unit time, $n$ be the number of objects allocated per interrupt, and $t_h$ be the fixed time each object is held.\n\nThe rate at which objects are allocated from the pool is the product of the interrupt rate and the number of objects per interrupt. Let this allocation rate be $R_{alloc}$.\n$$R_{alloc} = n \\lambda$$\nThe problem states that the system is at a sustained peak load, which implies a steady-state condition where the rate of object allocation equals the rate of object release. An object allocated at time $t$ is released at time $t + t_h$. At any given moment, the set of objects currently in use (allocated but not yet freed) consists of all objects that were allocated over the preceding time interval of duration $t_h$.\n\nThe total number of objects in use at any time, which we denote as $N_{in\\_use}$, is the product of the object allocation rate and the hold time.\n$$N_{in\\_use} = R_{alloc} \\times t_h$$\nSubstituting the expression for $R_{alloc}$, we get:\n$$N_{in\\_use} = (n \\lambda) t_h$$\nTo prevent allocation failures, the pool must be large enough to hold all objects that are simultaneously in use. An allocation request fails if it occurs when the pool is empty. Under the specified sustained peak load, the number of objects in use is constant. Therefore, the minimal capacity of the pool, $P$, must be equal to this number.\n$$P = n \\lambda t_h$$\nThis expression gives the minimum number of objects required in the pool to ensure that an allocation request never fails under the sustained peak interrupt rate $\\lambda$.\n\nFinally, we evaluate this expression for the given parameters:\n- Peak interrupt rate $\\lambda = 1.2 \\times 10^{5}$ interrupts per second.\n- Objects per interrupt $n = 2$.\n- Hold time per interrupt $t_{h} = 2.0 \\times 10^{-4}$ seconds.\n\nSubstituting these values into the derived formula for $P$:\n$$P = (2) \\times (1.2 \\times 10^{5} \\, \\text{s}^{-1}) \\times (2.0 \\times 10^{-4} \\, \\text{s})$$\n$$P = 2 \\times 1.2 \\times 2.0 \\times 10^{5} \\times 10^{-4}$$\n$$P = 4.8 \\times 10^{5-4}$$\n$$P = 4.8 \\times 10^{1}$$\n$$P = 48$$\nThe minimal pool capacity required is $48$ objects. Since the calculation results in an exact integer, this is the precise minimal number of objects needed to avoid allocation failure under the specified peak conditions.",
            "answer": "$$\\boxed{48}$$"
        }
    ]
}