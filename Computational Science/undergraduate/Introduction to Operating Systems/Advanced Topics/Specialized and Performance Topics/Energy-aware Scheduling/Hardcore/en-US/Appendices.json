{
    "hands_on_practices": [
        {
            "introduction": "A fundamental technique in energy-aware scheduling is enforcing a power cap to prevent a system from overheating or exceeding its power budget. This practice explores one of the most direct methods: idle injection. By calculating the necessary idle time to meet a specific power target, you will gain a concrete understanding of the direct trade-off between power savings and computational performance, a core concept in OS power management .",
            "id": "3639085",
            "problem": "A uniprocessor operating at a fixed clock frequency has Dynamic Voltage and Frequency Scaling (DVFS) disabled. The operating system enforces a power cap by idle injection: over each enforcement window of duration $T$, it forces the processor into a deep idle state for a fraction $\\alpha$ of the time and allows it to execute the workload for the remaining fraction $1-\\alpha$. Assume that whenever the processor is executing, its instantaneous power draw is a constant $P_{\\text{busy}}$, and when forcibly idled it draws a constant $P_{\\text{idle}}$.\n\nThe workload is compute-bound, so its instruction throughput is proportional to the fraction of time the processor is executing at the fixed frequency. Ignore any overheads for entering and exiting idle.\n\nGiven $P_{\\text{busy}} = 44\\,\\text{W}$, $P_{\\text{idle}} = 8\\,\\text{W}$, and a power cap $P_{\\text{cap}} = 29\\,\\text{W}$, determine the smallest idle fraction $\\alpha$ that ensures the average power over each window satisfies $P_{\\text{avg}} \\le P_{\\text{cap}}$. Then, evaluate the performance loss as a fraction $L$ of the uncapped baseline throughput, defined as $L = 1 - \\frac{\\text{throughput under cap}}{\\text{throughput without cap}}$.\n\nReport your answer as a pair $\\left(\\alpha, L\\right)$, rounded to four significant figures. Express both values as pure numbers with no unit.",
            "solution": "The problem statement is first validated for correctness and completeness.\n\n**Step 1: Extract Givens**\n- Enforcement window duration: $T$\n- Idle time fraction: $\\alpha$\n- Execution time fraction: $1-\\alpha$\n- Instantaneous power during execution: $P_{\\text{busy}} = 44\\,\\text{W}$\n- Instantaneous power during forced idle: $P_{\\text{idle}} = 8\\,\\text{W}$\n- Power cap constraint: $P_{\\text{avg}} \\le P_{\\text{cap}}$, where $P_{\\text{cap}} = 29\\,\\text{W}$\n- Throughput model: Throughput is proportional to the fraction of time the processor is executing.\n- Performance loss definition: $L = 1 - \\frac{\\text{throughput under cap}}{\\text{throughput without cap}}$\n- Objective: Determine the smallest idle fraction $\\alpha$ and the corresponding performance loss $L$.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem presents a simplified but standard model of power management via idle injection in operating systems. The given values for power are physically reasonable for a processor. The relationship between execution time and throughput for a compute-bound workload at a fixed frequency is a standard assumption. All necessary parameters are provided, and the objective is clearly defined. The problem is self-contained, scientifically grounded in its domain, and well-posed.\n\n**Step 3: Verdict and Action**\nThe problem is deemed valid. A solution will be derived.\n\n**Derivation of Idle Fraction $\\alpha$**\nThe average power, $P_{\\text{avg}}$, over an enforcement window of duration $T$ is the weighted sum of the power consumed in the busy and idle states. The processor is busy for a duration of $(1-\\alpha)T$ and idle for a duration of $\\alpha T$.\n\nThe total energy $E$ consumed over the window is:\n$$E = P_{\\text{busy}} \\cdot (1-\\alpha)T + P_{\\text{idle}} \\cdot \\alpha T$$\n\nThe average power is this energy divided by the window duration $T$:\n$$P_{\\text{avg}} = \\frac{E}{T} = P_{\\text{busy}}(1-\\alpha) + P_{\\text{idle}}\\alpha$$\n\nThe problem imposes the constraint that the average power must not exceed the power cap, $P_{\\text{cap}}$:\n$$P_{\\text{avg}} \\le P_{\\text{cap}}$$\nSubstituting the expression for $P_{\\text{avg}}$:\n$$P_{\\text{busy}}(1-\\alpha) + P_{\\text{idle}}\\alpha \\le P_{\\text{cap}}$$\n\nWe are asked for the smallest idle fraction $\\alpha$ that satisfies this condition. Since $P_{\\text{busy}} > P_{\\text{idle}}$, the left-hand side of the inequality is a monotonically decreasing function of $\\alpha$. Therefore, the smallest value of $\\alpha$ that satisfies the inequality is the one that makes the two sides equal. We set up the equality:\n$$P_{\\text{busy}}(1-\\alpha) + P_{\\text{idle}}\\alpha = P_{\\text{cap}}$$\n\nWe now solve for $\\alpha$:\n$$P_{\\text{busy}} - \\alpha P_{\\text{busy}} + \\alpha P_{\\text{idle}} = P_{\\text{cap}}$$\n$$P_{\\text{busy}} - P_{\\text{cap}} = \\alpha (P_{\\text{busy}} - P_{\\text{idle}})$$\n$$\\alpha = \\frac{P_{\\text{busy}} - P_{\\text{cap}}}{P_{\\text{busy}} - P_{\\text{idle}}}$$\n\nSubstituting the given numerical values:\n$$P_{\\text{busy}} = 44\\,\\text{W}$$\n$$P_{\\text{idle}} = 8\\,\\text{W}$$\n$$P_{\\text{cap}} = 29\\,\\text{W}$$\n\n$$\\alpha = \\frac{44 - 29}{44 - 8} = \\frac{15}{36} = \\frac{5}{12}$$\n\nAs a decimal, $\\alpha = 0.41666...$. Rounded to four significant figures, this is $\\alpha = 0.4167$.\n\n**Derivation of Performance Loss $L$**\nThe problem states that instruction throughput is proportional to the fraction of time the processor is executing. Let the throughput be denoted by $\\Theta$ and the proportionality constant by $k$.\n$$\\Theta = k \\times (\\text{execution fraction})$$\n\nThe baseline (uncapped) scenario corresponds to the processor executing all the time, as the workload is compute-bound. Thus, the execution fraction is $1$.\n$$\\Theta_{\\text{without cap}} = k \\times 1 = k$$\n\nUnder the power cap, the processor executes for a fraction $1-\\alpha$ of the time.\n$$\\Theta_{\\text{under cap}} = k \\times (1-\\alpha)$$\n\nThe performance loss $L$ is defined as:\n$$L = 1 - \\frac{\\Theta_{\\text{under cap}}}{\\Theta_{\\text{without cap}}}$$\nSubstituting the expressions for throughput:\n$$L = 1 - \\frac{k(1-\\alpha)}{k} = 1 - (1-\\alpha) = \\alpha$$\n\nThus, the performance loss fraction $L$ is numerically equal to the required idle fraction $\\alpha$.\n$$L = \\alpha = \\frac{5}{12} \\approx 0.41666...$$\n\nRounded to four significant figures, the performance loss is $L = 0.4167$.\n\nThe final answer is the pair $(\\alpha, L)$.\n$$\\alpha \\approx 0.4167$$\n$$L \\approx 0.4167$$",
            "answer": "$$\\boxed{\\begin{pmatrix} 0.4167 & 0.4167 \\end{pmatrix}}$$"
        },
        {
            "introduction": "In multicore processors, schedulers face a critical decision: is it more energy-efficient to spread a workload across many cores running at a low frequency, or to consolidate it onto a few cores running at a high frequency? This exercise delves into the underlying physics of processor power, distinguishing between dynamic power (related to activity) and leakage power (a constant drain). By deriving a model for the \"critical leakage power\" , you will uncover the quantitative reasoning an OS scheduler might use to make this crucial decision.",
            "id": "3639071",
            "problem": "An operating system scheduler must decide between consolidating a workload onto few processor cores (parking the rest) or spreading it across many cores at a lower frequency, taking into account leakage power. Consider a symmetric multicore processor with $M$ identical cores. A job requires $X$ clock cycles and must complete before a deadline $D$. Assume ideal parallel scaling with no overhead: if $N$ cores are active, each runs the jobâ€™s share at the same clock frequency $f$, and the aggregate throughput is $N f$, so the completion time is $T = X/(N f)$. To minimize energy under the deadline, the scheduler chooses the minimal frequency that satisfies $T \\leq D$.\n\nUse the following widely accepted physical model for complementary metal-oxide-semiconductor (CMOS) dynamic power and Dynamic Voltage and Frequency Scaling (DVFS):\n- Dynamic power per active core is $P_{\\text{dyn}} = C V^{2} f$, where $C$ is the effective switching capacitance and $V$ is the supply voltage.\n- In the operating range of interest, voltage scales approximately proportionally with frequency: $V = \\beta f$, where $\\beta$ is a technology-dependent constant.\n\nLeakage power per active core is a constant $P_{\\text{leak}}$ that does not depend on $f$ in this model. Parked cores have negligible leakage. The energy consumed is the time integral of power; under constant $f$ during execution, this is the product of power and execution time.\n\nDerive, from these bases, a closed-form analytic expression for the critical leakage power $P_{\\text{leak}}^{\\star}$ such that the total energy of running the job on all $M$ cores at the minimal frequency equals the total energy of running the job on a single core at the corresponding minimal frequency. Express your final answer in Watts. Do not compute a numerical value; provide the exact symbolic expression only.",
            "solution": "The problem statement is evaluated as valid. It is scientifically grounded in standard simplified models for CMOS power consumption, well-posed with a clear objective and sufficient information, and uses objective, formal language. We may proceed with the solution.\n\nThe objective is to find the critical leakage power per core, denoted as $P_{\\text{leak}}^{\\star}$, at which the total energy consumed to complete a job on a single core equals the total energy consumed to complete the same job on all $M$ cores of a processor.\n\nFirst, we establish a general model for the total energy consumed, $E$, when using $N$ active cores. The total power, $P_{\\text{total}}(N, f)$, is the sum of the dynamic power and leakage power across all active cores. Parked cores consume negligible power.\nThe power for a single active core running at frequency $f$ is the sum of dynamic power, $P_{\\text{dyn}}$, and leakage power, $P_{\\text{leak}}$.\n$$P_{\\text{core}} = P_{\\text{dyn}} + P_{\\text{leak}}$$\nThe dynamic power is given as $P_{\\text{dyn}} = C V^2 f$, where $V$ is the supply voltage. The voltage is related to the frequency by $V = \\beta f$. Substituting this into the dynamic power equation gives:\n$$P_{\\text{dyn}} = C (\\beta f)^2 f = C \\beta^2 f^3$$\nThus, the power for one core is $P_{\\text{core}}(f) = C \\beta^2 f^3 + P_{\\text{leak}}$. For $N$ active cores, the total power is:\n$$P_{\\text{total}}(N, f) = N \\cdot P_{\\text{core}}(f) = N (C \\beta^2 f^3 + P_{\\text{leak}})$$\nThe job requires $X$ clock cycles to complete. With $N$ cores running at frequency $f$, the aggregate throughput is $Nf$ cycles per second. The execution time $T$ is:\n$$T(N, f) = \\frac{X}{Nf}$$\nThe scheduler must meet a deadline $D$, so $T \\leq D$. To minimize energy, the scheduler selects the lowest possible frequency that satisfies this constraint. This occurs when the execution time is exactly equal to the deadline:\n$$T = \\frac{X}{Nf} = D$$\nFrom this, we can solve for the operating frequency $f$ as a function of the number of active cores $N$:\n$$f(N) = \\frac{X}{ND}$$\nNow, we can express the total energy consumed, $E(N)$, which is the product of total power and execution time, $E(N) = P_{\\text{total}}(N, f(N)) \\times T$. Since the time is fixed at $T=D$:\n$$E(N) = P_{\\text{total}}(N, f(N)) \\cdot D$$\nSubstituting the expressions for $P_{\\text{total}}$ and $f(N)$:\n$$E(N) = N \\left( C \\beta^2 \\left( \\frac{X}{ND} \\right)^3 + P_{\\text{leak}} \\right) D$$\n$$E(N) = N \\left( C \\beta^2 \\frac{X^3}{N^3 D^3} + P_{\\text{leak}} \\right) D$$\n$$E(N) = \\frac{C \\beta^2 X^3}{N^2 D^2} + N P_{\\text{leak}} D$$\nThis is the general expression for the total energy consumed as a function of the number of active cores $N$.\n\nWe now apply this general expression to the two specific cases defined in the problem.\n\nCase 1: The job runs on a single core ($N=1$).\nThe energy consumed, $E_1$, is found by setting $N=1$ in the general energy expression:\n$$E_1 = E(1) = \\frac{C \\beta^2 X^3}{1^2 D^2} + (1) P_{\\text{leak}} D = \\frac{C \\beta^2 X^3}{D^2} + P_{\\text{leak}} D$$\n\nCase 2: The job runs on all $M$ cores ($N=M$).\nThe energy consumed, $E_M$, is found by setting $N=M$:\n$$E_M = E(M) = \\frac{C \\beta^2 X^3}{M^2 D^2} + M P_{\\text{leak}} D$$\n\nThe critical leakage power, $P_{\\text{leak}}^{\\star}$, is defined as the value of $P_{\\text{leak}}$ for which $E_1 = E_M$. We set up this equality, replacing $P_{\\text{leak}}$ with $P_{\\text{leak}}^{\\star}$:\n$$\\frac{C \\beta^2 X^3}{D^2} + P_{\\text{leak}}^{\\star} D = \\frac{C \\beta^2 X^3}{M^2 D^2} + M P_{\\text{leak}}^{\\star} D$$\nNow, we solve for $P_{\\text{leak}}^{\\star}$. First, group terms containing $P_{\\text{leak}}^{\\star}$ on one side and the remaining terms on the other:\n$$M P_{\\text{leak}}^{\\star} D - P_{\\text{leak}}^{\\star} D = \\frac{C \\beta^2 X^3}{D^2} - \\frac{C \\beta^2 X^3}{M^2 D^2}$$\nFactor out common terms on both sides:\n$$P_{\\text{leak}}^{\\star} D (M-1) = \\frac{C \\beta^2 X^3}{D^2} \\left( 1 - \\frac{1}{M^2} \\right)$$\nSimplify the term in the parenthesis:\n$$P_{\\text{leak}}^{\\star} D (M-1) = \\frac{C \\beta^2 X^3}{D^2} \\left( \\frac{M^2-1}{M^2} \\right)$$\nUsing the identity $M^2 - 1 = (M-1)(M+1)$:\n$$P_{\\text{leak}}^{\\star} D (M-1) = \\frac{C \\beta^2 X^3}{D^2} \\frac{(M-1)(M+1)}{M^2}$$\nFor a multicore processor, we assume $M \\ge 2$, which implies $M-1 \\neq 0$. We can therefore divide both sides by $D(M-1)$:\n$$P_{\\text{leak}}^{\\star} = \\frac{1}{D(M-1)} \\left( \\frac{C \\beta^2 X^3}{D^2} \\frac{(M-1)(M+1)}{M^2} \\right)$$\n$$P_{\\text{leak}}^{\\star} = \\frac{C \\beta^2 X^3}{D^3} \\frac{M+1}{M^2}$$\nThis is the final closed-form analytic expression for the critical leakage power.",
            "answer": "$$\n\\boxed{C \\beta^2 \\frac{X^3}{D^3} \\frac{M+1}{M^2}}\n$$"
        },
        {
            "introduction": "Many workloads are I/O-bound, meaning the CPU frequently waits for data from networks or disks, creating opportunities for significant energy savings. This practice models a sophisticated scheduling strategy where the OS delays waking the CPU, choosing to accumulate and batch incoming requests to maximize time spent in a deep sleep state. By optimizing the batch size , you will analyze the inherent trade-off between the energy saved during deep sleep and the request latency introduced by this batching strategy, a key challenge in designing responsive yet efficient systems.",
            "id": "3639102",
            "problem": "An operating system network stack employs an energy-aware scheduler that defers wake-ups to enter a deep sleep state between I/O bursts. Incoming network requests arrive according to a Poisson process with rate $\\lambda$ requests per second, and when asleep the system waits until exactly $B$ requests have accumulated before initiating a wake-up and processing them as a batch. Assume the following well-tested facts and definitions as the fundamental base of the derivation: energy equals power times time, the Poisson process is memoryless, and the expected time to accumulate $B$ arrivals under rate $\\lambda$ is $B / \\lambda$. The wake transition has fixed duration $t_{w}$ during which power is $P_{w}$, the deep sleep state draws power $P_{d}$, and the active processing state draws power $P_{a}$. When active, the system processes requests at a constant rate $\\mu$ requests per second in first-in-first-out order. Assume $\\lambda < \\mu$ and that arrivals during wake-up and processing are negligible compared to the batch size so each cycle (sleep, wake, process) can be treated as isolated.\n\nDefine the average energy per request as the total energy consumed in one cycle divided by $B$, and define the average latency per request as the expected time from arrival to completion for a request, averaged across requests in the batch. To quantify the energy-latency tradeoff, consider the weighted objective $J(B)$ that adds the average energy per request and a latency penalty $k$ (in Joules per second) times the average latency per request.\n\nStarting only from the base assumptions above and without invoking any shortcut formulas, derive a closed-form expression for the batch size $B^{\\ast}$ (treated as a continuous variable) that minimizes $J(B)$. Express your final answer as a single analytic expression in terms of $\\lambda$, $\\mu$, $P_{d}$, $P_{a}$, $P_{w}$, $t_{w}$, and $k$. No numerical evaluation is required. If you introduce any intermediate symbols, they must be eliminated so that the final expression is entirely in the given parameters. The final answer must be a single expression; do not provide an inequality or an equation. No rounding is required, and no units should be included in the final expression.",
            "solution": "The goal is to find the batch size $B^*$ that minimizes the weighted objective function $J(B)$, where $B$ is treated as a continuous variable. The function $J(B)$ is defined as the sum of the average energy per request, $E_{avg}(B)$, and the average latency per request, $L_{avg}(B)$, scaled by a penalty factor $k$.\n$$J(B) = E_{avg}(B) + k \\cdot L_{avg}(B)$$\nOur derivation proceeds in several steps: first, we model a single operational cycle; second, we derive the total energy per cycle and the average energy per request; third, we derive the average latency per request; and finally, we construct and minimize the objective function $J(B)$.\n\nA single cycle consists of three distinct phases: deep sleep, wake-up, and active processing.\n\n**1. Derivation of Average Energy per Request, $E_{avg}(B)$**\n\nFirst, we determine the duration and energy consumption for each phase of a cycle which processes a batch of $B$ requests.\n\n*   **Sleep Phase:** The system remains in a deep sleep state, consuming power $P_{d}$, until exactly $B$ requests have arrived. The requests follow a Poisson process with rate $\\lambda$. The problem states that the expected time to accumulate $B$ arrivals, which is the expected duration of the sleep phase, is $t_{sleep} = \\frac{B}{\\lambda}$. The energy consumed during this phase is $E_{sleep} = P_{d} \\cdot t_{sleep} = P_{d} \\frac{B}{\\lambda}$.\n\n*   **Wake-up Phase:** The wake-up transition has a fixed duration $t_{w}$ and a constant power consumption $P_{w}$. The energy consumed is $E_{wake} = P_w t_w$.\n\n*   **Active Processing Phase:** The system processes the batch of $B$ requests at a rate of $\\mu$ requests per second, with a power draw of $P_a$. The time required to process the entire batch is $t_{proc} = \\frac{B}{\\mu}$. The energy consumed is $E_{proc} = P_a \\cdot t_{proc} = P_a \\frac{B}{\\mu}$.\n\nThe total energy consumed in one cycle, $E_{cycle}$, is the sum of the energy from all three phases:\n$$E_{cycle}(B) = E_{sleep} + E_{wake} + E_{proc} = P_{d} \\frac{B}{\\lambda} + P_w t_w + P_a \\frac{B}{\\mu}$$\nThe average energy per request, $E_{avg}(B)$, is the total cycle energy divided by the number of requests, $B$:\n$$E_{avg}(B) = \\frac{E_{cycle}(B)}{B} = \\frac{1}{B} \\left( P_{d} \\frac{B}{\\lambda} + P_w t_w + P_a \\frac{B}{\\mu} \\right) = \\frac{P_{d}}{\\lambda} + \\frac{P_w t_w}{B} + \\frac{P_a}{\\mu}$$\n\n**2. Derivation of Average Latency per Request, $L_{avg}(B)$**\n\nLatency is the time interval between a request's arrival and its completion. We need to compute the expectation of this value, averaged over all $B$ requests in a batch.\n\nLet the start of the sleep period be $t=0$. The $i$-th request (where $i \\in \\{1, 2, \\dots, B\\}$) arrives at time $T_i$. For a Poisson process, the expected arrival time of the $i$-th event is $E[T_i] = \\frac{i}{\\lambda}$.\n\nThe cycle's processing phase begins after the sleep and wake-up phases are complete. The expected end time of the wake-up phase is $t_{sleep} + t_w = \\frac{B}{\\lambda} + t_w$. Requests are processed in a first-in-first-out (FIFO) manner. The time to process the first $i$ requests is $\\frac{i}{\\mu}$. Thus, the expected completion time for the $i$-th request is:\n$$E[t_{completion, i}] = t_{sleep} + t_w + \\frac{i}{\\mu} = \\frac{B}{\\lambda} + t_w + \\frac{i}{\\mu}$$\nThe expected latency for the $i$-th request is the difference between its expected completion time and its expected arrival time:\n$$E[L_i] = E[t_{completion, i}] - E[T_i] = \\left(\\frac{B}{\\lambda} + t_w + \\frac{i}{\\mu}\\right) - \\frac{i}{\\lambda}$$\nThe average latency per request, $L_{avg}(B)$, is the average of these expected latencies over all $B$ requests:\n$$L_{avg}(B) = \\frac{1}{B} \\sum_{i=1}^{B} E[L_i] = \\frac{1}{B} \\sum_{i=1}^{B} \\left(\\frac{B}{\\lambda} + t_w + \\frac{i}{\\mu} - \\frac{i}{\\lambda}\\right)$$\nWe can split the sum:\n$$L_{avg}(B) = \\frac{1}{B} \\left[ \\sum_{i=1}^{B}\\left(\\frac{B}{\\lambda} + t_w\\right) + \\left(\\frac{1}{\\mu} - \\frac{1}{\\lambda}\\right) \\sum_{i=1}^{B} i \\right]$$\nUsing the formula for the sum of the first $B$ integers, $\\sum_{i=1}^{B} i = \\frac{B(B+1)}{2}$:\n$$L_{avg}(B) = \\frac{1}{B} \\left[ B\\left(\\frac{B}{\\lambda} + t_w\\right) + \\left(\\frac{1}{\\mu} - \\frac{1}{\\lambda}\\right) \\frac{B(B+1)}{2} \\right]$$\n$$L_{avg}(B) = \\left(\\frac{B}{\\lambda} + t_w\\right) + \\frac{B+1}{2}\\left(\\frac{1}{\\mu} - \\frac{1}{\\lambda}\\right)$$\nTo facilitate differentiation, we express $L_{avg}(B)$ as a linear function of $B$:\n$$L_{avg}(B) = \\frac{B}{\\lambda} + t_w + \\frac{B}{2\\mu} - \\frac{B}{2\\lambda} + \\frac{1}{2\\mu} - \\frac{1}{2\\lambda} = B \\left(\\frac{1}{2\\lambda} + \\frac{1}{2\\mu}\\right) + \\left(t_w + \\frac{1}{2\\mu} - \\frac{1}{2\\lambda}\\right)$$\n\n**3. Minimization of the Objective Function $J(B)$**\n\nNow we assemble the objective function $J(B) = E_{avg}(B) + k \\cdot L_{avg}(B)$:\n$$J(B) = \\left(\\frac{P_{d}}{\\lambda} + \\frac{P_a}{\\mu} + \\frac{P_w t_w}{B}\\right) + k \\left[ B \\left(\\frac{1}{2\\lambda} + \\frac{1}{2\\mu}\\right) + \\left(t_w + \\frac{1}{2\\mu} - \\frac{1}{2\\lambda}\\right) \\right]$$\nTo find the minimum, we compute the derivative of $J(B)$ with respect to $B$ and set it to zero. Terms not involving $B$ vanish.\n$$\\frac{dJ}{dB} = \\frac{d}{dB} \\left( \\frac{P_w t_w}{B} + k B \\left(\\frac{1}{2\\lambda} + \\frac{1}{2\\mu}\\right) \\right)$$\n$$\\frac{dJ}{dB} = -\\frac{P_w t_w}{B^2} + k \\left(\\frac{1}{2\\lambda} + \\frac{1}{2\\mu}\\right)$$\nSetting the derivative to zero for $B = B^*$:\n$$-\\frac{P_w t_w}{(B^*)^2} + k \\left(\\frac{1}{2\\lambda} + \\frac{1}{2\\mu}\\right) = 0$$\n$$\\frac{P_w t_w}{(B^*)^2} = k \\left(\\frac{1}{2\\lambda} + \\frac{1}{2\\mu}\\right) = k \\left(\\frac{\\mu + \\lambda}{2\\lambda\\mu}\\right)$$\nSolving for $(B^*)^2$:\n$$(B^*)^2 = \\frac{P_w t_w}{k \\left(\\frac{\\lambda + \\mu}{2\\lambda\\mu}\\right)} = \\frac{2 \\lambda \\mu P_w t_w}{k(\\lambda + \\mu)}$$\nSince the batch size $B$ must be positive, we take the positive square root:\n$$B^* = \\sqrt{\\frac{2 \\lambda \\mu P_w t_w}{k(\\lambda + \\mu)}}$$\nThe second derivative, $\\frac{d^2J}{dB^2} = \\frac{2P_w t_w}{B^3}$, is positive for positive $B$, $P_w$, and $t_w$, confirming that $B^*$ corresponds to a minimum. The resulting expression for $B^*$ depends only on the parameters provided in the problem statement.",
            "answer": "$$\\boxed{\\sqrt{\\frac{2 \\lambda \\mu P_w t_w}{k(\\lambda + \\mu)}}}$$"
        }
    ]
}