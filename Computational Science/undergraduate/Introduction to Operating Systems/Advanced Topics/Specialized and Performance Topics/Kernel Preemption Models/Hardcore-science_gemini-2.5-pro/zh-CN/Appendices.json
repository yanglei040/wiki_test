{
    "hands_on_practices": [
        {
            "introduction": "理论知识需要通过实践来巩固。这个练习旨在建立一个基础模型，用以量化内核的非抢占部分如何直接影响用户感知的系统响应能力。通过分析从键盘敲击到屏幕回显的整个延迟链路，我们可以分离并理解造成延迟的核心因素，特别是那些由不可中断的内核代码执行所引起的阻塞时间 。这个练习将帮助你把抽象的抢占概念与一个具体的、可量化的性能指标——响应时间联系起来。",
            "id": "3652427",
            "problem": "一台工作站运行着一个操作系统（OS），其内核是可抢占的，但在中断被屏蔽的不可抢占临界区内除外。假设任何此类不可抢占区间的最大持续时间为 $C$ 秒。一次按键会触发一个硬件中断，该中断由一个中断服务程序（ISR）处理。该ISR将字符入队，并唤醒一个执行可见回显的用户空间终端进程。调度程序会引入一个从唤醒到分派的延迟，在稳定的交互式负载下，该延迟被建模为一个均值为 $D$ 秒的低方差随机变量；在此软实时环境中，为了资源规划的目的，你被要求使用 $D$ 作为调度程序引起的延迟的规划值。假设ISR的执行时间以及终端进程的回显计算时间与 $C$ 和 $D$ 相比可以忽略不计，并且设备和显示管道增加的延迟也相对于 $C$ 和 $D$ 可以忽略不计。仅使用抢占、阻塞和响应时间构成的核心定义，推导从物理按键到回显字符可见的这段时间的紧凑软上限。将你的最终上界以秒为单位，表示为一个关于 $C$ 和 $D$ 的封闭形式符号表达式。",
            "solution": "问题要求推导从物理按键到回显字符出现在显示器上的总时间的紧凑软上限。这个总时间也称为端到端响应时间。为了推导这个上界，我们必须分析所提供的操作系统模型描述的事件序列及其相关延迟。\n\n设 $T_{response}$ 为总响应时间。我们可以将 $T_{response}$ 分解为一系列连续时间间隔的和，这些时间间隔对应于处理按键事件的各个阶段。\n\n事件序列及其相关的时间组成部分如下：\n\n1.  **中断延迟 ($T_{block}$)**：一次按键会产生一个硬件中断。问题陈述，内核是可抢占的，*除了*在中断被屏蔽的不可抢占临界区内。如果中断发生时系统正在执行这样一个不可抢占的部分，中断服务将被延迟，直到该部分结束。任何此类部分的最大持续时间为 $C$ 秒。这代表了中断处理程序的阻塞时间。因此，在中断服务程序（ISR）可以开始之前的最坏情况延迟是 $C$。我们将此确定为初始延迟的上限。\n    $$ T_{block} \\le C $$\n\n2.  **ISR执行时间 ($T_{ISR}$)**：一旦中断不再被屏蔽，相应的ISR就会被执行。问题明确指出，ISR的执行时间与 $C$ 和 $D$ 相比可以忽略不计。因此，我们可以正式地将其对总时间的贡献视为 $0$。\n    $$ T_{ISR} = 0 $$\n\n3.  **调度延迟 ($T_{sched}$)**：ISR的功能是将字符入队并唤醒用户空间的终端进程。这个操作将终端进程从睡眠/等待状态转移到就绪状态。该进程现在有资格运行，但它必须等待OS调度程序选择它并将其分派到CPU。这就是“从唤醒到分派”的延迟。问题要求我们使用规划值 $D$ 作为此延迟，该值是此延迟随机变量模型的均值。\n    $$ T_{sched} = D $$\n\n4.  **进程执行与显示管道时间 ($T_{proc} + T_{display}$)**：一旦被分派，终端进程就运行其代码以执行回显。随后，字符被发送通过显示管道以变得可见。问题陈述，终端进程的回显计算时间以及设备/显示管道的延迟都可以忽略不计。因此，我们将其贡献视为 $0$。\n    $$ T_{proc} = 0 $$\n    $$ T_{display} = 0 $$\n\n总响应时间 $T_{response}$ 是所有这些连续延迟分量的总和。为了找到紧凑的软上限，我们将每个分量的最大值或指定的规划值相加。\n\n$$ T_{response} = T_{block} + T_{ISR} + T_{sched} + T_{proc} + T_{display} $$\n\n代入从问题陈述中推导出的值，响应时间的上界，我们称之为 $T_{bound}$，是：\n\n$$ T_{bound} = C + 0 + D + 0 + 0 $$\n\n这可以简化为响应时间的紧凑软上限的最终表达式：\n\n$$ T_{bound} = C + D $$\n\n这个表达式正确地捕捉了指定模型中两个主要的延迟来源：由于内核不可抢占性而产生的潜在阻塞时间 $C$ 和调度程序引起的延迟 $D$。该表达式的单位是秒，因为 $C$ 和 $D$ 都是以秒为单位定义的。",
            "answer": "$$\n\\boxed{C+D}\n$$"
        },
        {
            "introduction": "在掌握了延迟的基本模型后，让我们来看一个更具体的工程场景。这个练习模拟了实时系统工程师面临的典型挑战：你必须确保关键的外部设备中断在严格的时间预算内得到服务。为了达成这个目标，你需要计算出由自旋锁（spinlock）等机制所创建的非抢占代码段的最大允许执行时间 。这项练习将让你从理论分析转向实际的“延迟预算”计算，这是设计高可靠性嵌入式系统和实时操作系统的核心技能。",
            "id": "3652472",
            "problem": "一个单处理器实时系统使用一个完全可抢占的内核，但在自旋锁保护的临界区内除外，在临界区内本地中断被禁用。一个外部设备断言一个中断，该中断必须在最大最坏情况中断延迟界限 $I = 19.73\\,\\mu\\text{s}$ 内得到服务。根据定义，最坏情况中断延迟是指从设备断言中断的瞬间到中断服务程序（上半部分）的第一条指令在处理器上执行所经过的时间。\n\n考虑一个自旋锁保护的区域，其中断被禁用的持续时间为 $S$。在最坏情况下，外部中断在该区域开始时禁用中断后立即到达。在该区域结束后，中断被重新启用，在中断服务程序的第一条指令运行之前，会发生以下延迟：\n- 当中断启用生效时，有 $0.113\\,\\mu\\text{s}$ 的流水线串行化延迟。\n- 中断控制器中的传递和仲裁延迟为 $0.271\\,\\mu\\text{s}$。\n- 硬件识别和向量化到内核中断入口点的时间为 $0.583\\,\\mu\\text{s}$。\n- 内核入口序言和上下文保存开销为 $2.347\\,\\mu\\text{s}$。\n\n假设除了单个临界区之外没有额外的中断屏蔽嵌套，没有不可屏蔽中断的干扰，并且在自旋锁区域之外，内核的抢占模型不会在列举的步骤之外给中断处理增加额外的延迟。\n\n仅使用关于中断延迟和不可抢占区间的基本定义，从第一性原理推导出最大允许长度 $S_{\\max}$ 的表达式，使得最坏情况中断延迟不超过 $I$，然后计算其数值。将最终答案以微秒表示，并四舍五入到四位有效数字。",
            "solution": "核心原理是延迟分量的可加性。总的最坏情况中断延迟，我们表示为 $L_{\\text{total}}$，是从外部设备断言中断的时刻到相应中断服务程序（ISR）的第一条指令开始在处理器上执行的所有顺序延迟的总和。问题要求这个总延迟不超过一个指定的界限 $I$。\n$$L_{\\text{total}} \\le I$$\n问题定义了一个具体的最坏情况场景。一个中断在本地中断被禁用以执行持续时间为 $S$ 的自旋锁保护临界区后立即被断言。处理器必须首先完成这个不可抢占的部分，然后才能开始处理挂起的中断。因此，持续时间 $S$ 是此场景中中断延迟的第一个也是主要的分量。\n\n在持续时间为 $S$ 的临界区完成后，中断被重新启用。在一系列随后的固定延迟发生后，ISR 才能运行。这些延迟是：\n1.  流水线串行化延迟，$L_{\\text{pipe}} = 0.113\\,\\mu\\text{s}$。\n2.  中断控制器传递和仲裁延迟，$L_{\\text{ctrl}} = 0.271\\,\\mu\\text{s}$。\n3.  硬件识别和向量化时间，$L_{\\text{hw}} = 0.583\\,\\mu\\text{s}$。\n4.  内核入口序言和上下文保存开销，$L_{\\text{kern}} = 2.347\\,\\mu\\text{s}$。\n\n问题中的假设（无嵌套中断屏蔽，无 NMI 干扰）确保了除了初始中断禁用期 $S$ 之外，这些是延迟的唯一贡献者。\n\n从第一性原理出发，我们可以通过将这些分量相加来构建总的最坏情况中断延迟的表达式：\n$$L_{\\text{total}} = S + L_{\\text{pipe}} + L_{\\text{ctrl}} + L_{\\text{hw}} + L_{\\text{kern}}$$\n为了找到临界区的最大允许持续时间 $S_{\\max}$，我们必须满足总延迟不超过界限 $I = 19.73\\,\\mu\\text{s}$ 的约束。最大值 $S_{\\max}$ 对应于总延迟恰好等于界限 $I$ 的情况：\n$$S_{\\max} + L_{\\text{pipe}} + L_{\\text{ctrl}} + L_{\\text{hw}} + L_{\\text{kern}} = I$$\n从这个基本关系中，我们可以通过在方程的一边分离出 $S_{\\max}$ 来推导其表达式：\n$$S_{\\max} = I - (L_{\\text{pipe}} + L_{\\text{ctrl}} + L_{\\text{hw}} + L_{\\text{kern}})$$\n这就是基于给定约束和定义推导出的自旋锁保护临界区最大允许长度的表达式。\n\n现在，我们计算数值。首先，我们可以将固定的延迟分量相加：\n$$L_{\\text{fixed}} = L_{\\text{pipe}} + L_{\\text{ctrl}} + L_{\\text{hw}} + L_{\\text{kern}}$$\n代入给定值：\n$$L_{\\text{fixed}} = 0.113\\,\\mu\\text{s} + 0.271\\,\\mu\\text{s} + 0.583\\,\\mu\\text{s} + 2.347\\,\\mu\\text{s}$$\n$$L_{\\text{fixed}} = 3.314\\,\\mu\\text{s}$$\n接下来，我们将 $I$ 和 $L_{\\text{fixed}}$ 的值代入 $S_{\\max}$ 的表达式中：\n$$S_{\\max} = 19.73\\,\\mu\\text{s} - 3.314\\,\\mu\\text{s}$$\n$$S_{\\max} = 16.416\\,\\mu\\text{s}$$\n问题要求最终答案四舍五入到四位有效数字。数字 $16.416$ 有五位有效数字。前四位是 $1$、$6$、$4$ 和 $1$。第五位有效数字是 $6$。由于这个数字大于或等于 $5$，我们将第四位有效数字向上取整。数字 $1$ 变成 $2$。\n因此，四舍五入到四位有效数字的最大允许长度 $S_{\\max}$ 是 $16.42\\,\\mu\\text{s}$。",
            "answer": "$$\\boxed{16.42}$$"
        },
        {
            "introduction": "虽然非抢占内核会增加延迟，但引入内核抢占也并非没有代价。这个高级练习将你置于一位内核开发者的角色，去诊断一个只在可抢占内核下才会偶然出现的致命死锁。这个问题展示了抢占如何通过改变代码的交错执行顺序，从而暴露出并发控制逻辑中潜藏的缺陷，例如不一致的锁获取顺序 。通过解决这个“bug hunt”挑战，你将深刻体会到在现代多任务操作系统中，正确的锁策略与对抢占模型的深入理解是何等重要。",
            "id": "3652483",
            "problem": "一个用于 Linux 内核的设备驱动程序正在一个具有 $N=1$ 个中央处理器 (CPU) 的单处理器系统上进行测试。该驱动程序暴露了两个进程上下文入口点，用于操作一个由两个不同的锁保护的共享数据结构：一个互斥锁 $m$ 和一个自旋锁 $s$。相关行为总结如下。\n\n- 路径 $W$：获取 $m$；之后获取 $s$；然后释放 $s$，最后释放 $m$。\n- 路径 $I$：获取 $s$；之后尝试获取 $m$；然后释放 $m$，最后释放 $s$。\n\n在相同硬件上的经验观察显示如下。\n\n- 在内核配置为 $CONFIG\\_PREEMPT\\_NONE$（不可抢占内核）的情况下，经过多次迭代后未观察到死锁。\n- 在内核配置为 $CONFIG\\_PREEMPT$（可抢占内核）的情况下，系统偶尔会硬死锁。一次死锁实例的捕获追踪显示，一个在路径 $W$ 中的线程持有 $m$ 并在 $s$ 上自旋，而另一个在路径 $I$ 中的线程持有 $s$ 并因等待 $m$ 而被阻塞。\n\n假设遵循标准的 Linux 语义：自旋锁 $s$ 在持有期间会禁用内核抢占，并且不能在任何可能引起睡眠的操作中持有；互斥锁 $m$ 在发生竞争时可能导致睡眠，但其本身不会禁用抢占。死锁需要满足四个 Coffman 条件：互斥、持有并等待、资源不可剥夺和循环等待。\n\n哪个选项最能解释为什么死锁只在 $CONFIG\\_PREEMPT$ 配置下出现，以及最合适的最小化修复方案是什么？\n\nA. 可抢占内核允许在 $W$ 获取 $m$ 之后、获取 $s$ 之前发生重新调度，从而让 $I$ 得以运行，获取 $s$，然后在仍持有 $s$ 的情况下因请求 $m$ 而阻塞。这在 $m$ 和 $s$ 之间造成了循环等待，并违反了持有自旋锁时不能睡眠的规则。在一个 $N=1$ 的不可抢占内核上，除非 $W$ 阻塞，否则这种交错执行不可能发生。最小化修复方案是强制执行一个单一的全局锁顺序（例如，总是 $m \\rightarrow s$），并重构 $I$ 以确保在持有 $s$ 时永不获取 $m$（例如，在尝试获取 $m$ 之前释放 $s$，或者先获取 $m$ 再获取 $s$），从而消除循环等待和在持有自旋锁时睡眠的风险。\n\nB. 死锁是由于可抢占内核触发的优先级反转所致。正确的修复方案是将自旋锁 $s$ 替换为支持优先级继承的互斥锁，这样低优先级的持有者就不会饿死高优先级的等待者。\n\nC. 可抢占内核允许更深层次的中断嵌套，并且一个不可屏蔽中断 (NMI) 处理程序偶尔会在 $I$ 持有 $m$ 时获取 $s$。修复方案是将所有 $s$ 的操作转换为 $spin\\_lock\\_irqsave$/$spin\\_unlock\\_irqrestore$ 来在 $s$ 的临界区周围屏蔽中断。\n\nD. 死锁是一个由 $CONFIG\\_PREEMPT$ 中更长的抢占窗口引起的读-复制-更新 (RCU) 宽限期停滞。正确的修复方案是用 $rcu\\_read\\_lock$/$rcu\\_read\\_unlock$ 包裹临界区，以避免阻塞宽限期。",
            "solution": "问题的核心在于理解，在给定的执行路径和锁语义下，为什么死锁在可抢占内核 ($CONFIG\\_PREEMPT$) 中发生，但在单处理器系统上的不可抢占内核 ($CONFIG\\_PREEMPT\\_NONE$) 中却不发生。\n\n**死锁条件分析**\n问题提供了一个死锁追踪：\n1. 一个执行路径 $W$ 的线程（称之为 $T_W$）持有互斥锁 $m$ 并等待获取自旋锁 $s$。\n2. 一个执行路径 $I$ 的线程（称之为 $T_I$）持有自旋锁 $s$ 并等待获取互斥锁 $m$。\n\n这是一个经典的循环等待，满足了死锁的四个 Coffman 条件之一。锁 $m$ 和 $s$ 提供了互斥。持有并等待条件得到满足，因为两个线程都持有一个资源同时请求另一个。资源不可剥夺条件也得到满足，因为锁不能被从线程中强制剥夺。因此，死锁的所有条件都存在。问题集中于允许达到此状态的时序。\n\n**在 $CONFIG\\_PREEMPT\\_NONE$ (不可抢占内核) 下的行为**\n在一个 $N=1$ 的不可抢占内核的单处理器系统上，一个在内核模式下运行的线程将持续持有 CPU，直到它：\na) 主动阻塞（例如，等待 I/O 或一个有竞争的互斥锁）。\nb) 退出内核模式。\nc) 发生中断，但除非内核代码明确允许（例如，通过 `schedule()`），否则调度器不会被调用以切换到另一个进程上下文。\n\n让我们追踪执行过程：\n假设 $T_W$ 开始执行。它获取互斥锁 $m$。由于此时 $m$ 大概率没有竞争，$T_W$ 不会阻塞并继续执行。因为内核是不可抢占的，没有其他进程上下文的线程（如 $T_I$）可以被调度运行。$T_W$ 将立即继续获取自旋锁 $s$。如果 $s$ 是空闲的，$T_W$ 获取它，完成其工作，并释放两个锁。没有死锁。只有在 $T_W$ 获取 $m$ 之后、获取 $s$ 之前，$T_I$ 以某种方式得以运行时，死锁才可能发生。在一个不可抢占的单处理器上，这是不可能的，除非路径 $W$ 在获取 $m$ 和获取 $s$ 之间存在一个主动阻塞点。问题没有说明这一点，并且经验上没有观察到死锁的现象也支持了这段代码窗口是非阻塞的结论。因此，$T_W$ 保持对 CPU 的控制，阻止 $T_I$ 运行并产生循环依赖。\n\n**在 $CONFIG\\_PREEMPT$ (可抢占内核) 下的行为**\n可抢占内核允许一个在内核模式下运行的任务被另一个任务抢占，前提是它没有持有自旋锁或处于其他不可抢占的区域。互斥锁本身不会禁用抢占。\n\n让我们在此模型下追踪死锁场景：\n1. $T_W$ 开始执行路径 $W$ 并成功获取互斥锁 $m$。\n2. 在获取 $m$ 之后、尝试获取 $s$ 之前，发生了一次抢占事件。这可能是由于定时器中断指示线程的时间片已用完，或一个更高优先级的任务变为可运行状态。由于 $T_W$ 只持有一个互斥锁，它是完全可被抢占的。\n3. 调度器运行并将上下文切换到 $T_I$。\n4. $T_I$ 开始执行路径 $I$。它成功获取了空闲的自旋锁 $s$。根据指定的语义，获取 $s$ 的行为会禁用内核抢占。\n5. $T_I$ 继续执行并尝试获取互斥锁 $m$。\n6. 互斥锁 $m$ 由 $T_W$ 持有。根据其语义，尝试获取一个有竞争的互斥锁会导致请求线程睡眠（阻塞）。因此，$T_I$ 阻塞，等待 $m$ 被释放。\n7. 当一个线程阻塞时，它会放弃 CPU。调度器再次运行。它看到 $T_W$ 是下一个可运行的线程并调度它。\n8. $T_W$ 从它被抢占的地方（获取 $m$ 之后）恢复执行。它现在尝试获取自旋锁 $s$。\n9. 然而，$s$ 被 $T_I$ 持有。$T_W$ 开始自旋，等待 $s$ 被释放。\n10. 此时，系统陷入死锁（“硬死锁”）：\n    - $T_W$ 正在 CPU 上自旋，持有 $m$，等待 $s$。\n    - $T_I$ 正在睡眠，持有 $s$，等待 $m$。\n    - 因为我们是在一个单处理器系统 ($N=1$) 上，唯一运行的线程是正在自旋的 $T_W$。$T_I$ 是 $T_W$ 所需资源 $s$ 的持有者，但它正在睡眠，永远无法被调度运行以释放 $s$。\n\n这一系列事件完美地解释了为什么死锁只在 $CONFIG\\_PREEMPT$ 下出现。抢占使得创建循环等待所需的交错执行成为可能。它也暴露了路径 $I$ 中的一个严重错误：在持有自旋锁 ($s$) 的同时尝试获取一个可能导致睡眠的锁 ($m$)。这是一个非法操作，因为自旋锁的持有者可能会无限期睡眠，使系统饿死，并且在单处理器上，如果互斥锁存在竞争，这将保证导致死锁。\n\n**最小化修复方案**\n死锁的根本原因有：\n1. **循环等待：** 锁的获取顺序不一致（在 $W$ 中是 $m \\rightarrow s$，但在 $I$ 中是 $s \\rightarrow m$）。\n2. **非法锁使用：** 路径 $I$ 试图在持有自旋锁的同时获取一个互斥锁（一个可能睡眠的锁），这是被禁止的。\n\n最合适和最小化的修复方案必须解决这些根本原因。防止循环等待死锁的典型解决方案是对所有锁的获取强制执行一个严格的全局顺序。例如，我们可以规定 $m$ 必须总是在 $s$ 之前被获取。\n这将要求重构路径 $I$。它必须被修改以遵循全局顺序，而不是 `acquire s; acquire m`。两种有效的修改方式是：\n- 先获取 $m$，再获取 $s$：`acquire m; ...; acquire s; ...; release s; ...; release m`。\n- 破坏持有并等待条件：`acquire s; ...; release s; acquire m; ...; release m`。\n\n在两个路径中都强制使用 $m \\rightarrow s$ 的顺序可以同时解决这两个问题。它消除了循环等待，并确保了试图在持有自旋锁时获取互斥锁的非法操作不再发生。\n\n### 逐项分析\n\n**A. 可抢占内核允许在 $W$ 获取 $m$ 之后、获取 $s$ 之前发生重新调度，从而让 $I$ 得以运行，获取 $s$，然后在仍持有 $s$ 的情况下因请求 $m$ 而阻塞。这在 $m$ 和 $s$ 之间造成了循环等待，并违反了持有自旋锁时不能睡眠的规则。在一个 $N=1$ 的不可抢占内核上，除非 $W$ 阻塞，否则这种交错执行不可能发生。最小化修复方案是强制执行一个单一的全局锁顺序（例如，总是 $m \\rightarrow s$），并重构 $I$ 以确保在持有 $s$ 时永不获取 $m$（例如，在尝试获取 $m$ 之前释放 $s$，或者先获取 $m$ 再获取 $s$），从而消除循环等待和在持有自旋锁时睡眠的风险。**\n- 该选项对死锁机制的解释与上面推导的完全一致。它正确地指出了抢占在促成致命交错执行中的作用。它正确地注意到这既暴露了循环等待，也暴露了在持有自旋锁 ($s$) 时睡眠（在 $m$ 上阻塞）的非法行为。它正确地解释了为什么不可抢占内核不受影响。所提出的修复方案——强制执行严格的锁顺序——是解决这类问题的标准、正确且最小化的方案。给出的例子是该修复方案的有效实现。\n- **结论：正确**\n\n**B. 死锁是由于可抢占内核触发的优先级反转所致。正确的修复方案是将自旋锁 $s$ 替换为支持优先级继承的互斥锁，这样低优先级的持有者就不会饿死高优先级的等待者。**\n- 该选项误诊了问题。问题是循环等待导致的死锁，而不是优先级反转。优先级反转是一种调度风险，指高优先级任务被低优先级任务阻塞，而该低优先级任务又被中等优先级任务抢占。虽然与优先级和抢占有关，但它是一种不同的现象。其修复方案，用支持优先级继承的互斥锁替换自旋锁，并不能解决根本的循环等待问题。两个 PI-互斥锁之间，如果获取模式为 $m \\rightarrow s_p$ 和 $s_p \\rightarrow m$，仍然可能发生死锁。\n- **结论：不正确**\n\n**C. 可抢占内核允许更深层次的中断嵌套，并且一个不可屏蔽中断 (NMI) 处理程序偶尔会在 $I$ 持有 $m$ 时获取 $s$。修复方案是将所有 $s$ 的操作转换为 $spin\\_lock\\_irqsave$/$spin\\_unlock\\_irqrestore$ 来在 $s$ 的临界区周围屏蔽中断。**\n- 该选项虚构了问题中不存在的事实。问题明确指出代码路径处于“进程上下文”，而不是中断或 NMI 处理程序。观察到的死锁发生在两个进程上下文线程之间，而不是进程和中断之间。其解释也与路径 $I$ 的定义相矛盾（它说 NMI 在 $I$ 持有 $m$ 时获取 $s$，但路径 $I$ 是在获取 $m$ 之前获取 $s$）。虽然当一个锁在进程上下文和中断上下文之间共享时，使用 `spin_lock_irqsave` 是必要的，但对于这里描述的两个进程之间的特定死锁，它不是正确的解决方案。\n- **结论：不正确**\n\n**D. 死锁是一个由 $CONFIG\\_PREEMPT$ 中更长的抢占窗口引起的读-复制-更新 (RCU) 宽限期停滞。正确的修复方案是用 $rcu\\_read\\_lock$/$rcu\\_read\\_unlock$ 包裹临界区，以避免阻塞宽限期。**\n- 该选项错误地将问题识别为与读-复制-更新 (RCU) 相关。问题明确涉及一个互斥锁和一个自旋锁，完全没有提到 RCU。RCU 停滞是一种不同类型的系统挂起。所提出的修复方案也是无稽之谈；`rcu_read_lock` 不为写入者提供互斥，不能用作替代互斥锁或自旋锁来保护正在被修改的数据结构。\n- **结论：不正确**",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}