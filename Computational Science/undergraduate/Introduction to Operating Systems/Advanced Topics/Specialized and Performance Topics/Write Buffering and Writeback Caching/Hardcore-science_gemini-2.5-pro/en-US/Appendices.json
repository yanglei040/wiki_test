{
    "hands_on_practices": [
        {
            "introduction": "Understanding the performance of a write buffer begins with a simple but powerful model from queueing theory. By treating the buffer as a reservoir with an inflow of write requests and an outflow to storage, we can analyze its long-term behavior from first principles. This exercise  challenges you to use a fundamental conservation law to determine the critical condition for system stability, relating the arrival rate $\\lambda$ to the service rate $\\mu$, and to predict how quickly an overloaded buffer will fail. This provides a quantitative foundation for reasoning about throughput and latency in any buffered system.",
            "id": "3690122",
            "problem": "An operating system uses a write-back caching policy with a memory-resident write buffer. Multiple producer threads generate application write requests that are appended to the buffer, and a single asynchronous flusher thread drains the buffer to storage. Model the system as a continuous-rate (fluid) queue with the following definitions:\n\n- Let $Q(t)$ denote the buffered data volume at time $t$.\n- Let $\\lambda$ denote the long-term average production rate of write requests (buffer arrivals).\n- Let $\\mu$ denote the long-term average sustained drain rate of the flusher (buffer service).\n- Assume $Q(0)=Q_{0} \\ge 0$.\n- When $Q(t) > 0$, the flusher can run at rate $\\mu$; when $Q(t)=0$, the buffer cannot go negative.\n- The buffer has finite capacity $C$; an overflow occurs when $Q(t)$ first reaches $C$.\n\nStarting only from the basic conservation-of-flow principle that the instantaneous rate of change of buffered data equals the input rate minus the output rate whenever the buffer is nonempty, and that $Q(t)$ is lower bounded by $0$, answer the following:\n\n1) Using the above principles and without invoking any pre-packaged queueing results, reason about the stability of the buffer occupancy in the long run. State the condition on $\\lambda$ and $\\mu$ under which the buffer occupancy can remain bounded over time, and the condition under which it will diverge.\n\n2) Specialize to the case $\\lambda > \\mu$ and $Q(0)=Q_{0} \\in (0,C)$. Derive a closed-form expression for $Q(t)$ for $0 \\le t < t_{\\text{overflow}}$, where $t_{\\text{overflow}}$ is the first time $Q(t)$ reaches $C$.\n\n3) For a concrete system with parameters $\\lambda = 2.4$ GB/s, $\\mu = 1.8$ GB/s, $C = 12$ GB, and $Q_{0} = 1.5$ GB, compute the overflow time $t_{\\text{overflow}}$ in seconds. Express the final answer in seconds and round your answer to four significant figures.",
            "solution": "The problem asks for an analysis of a write buffer modeled as a continuous-rate fluid queue. The analysis must be derived from the first principle of conservation of flow.\n\nThe fundamental principle provided is that the instantaneous rate of change of the buffered data volume, $\\frac{dQ(t)}{dt}$, is equal to the input rate minus the output rate. The input rate is given as a constant average rate $\\lambda$. The output rate is a constant average rate $\\mu$, but this drain only occurs when the buffer is non-empty, i.e., $Q(t) > 0$. Furthermore, the buffer volume cannot be negative, $Q(t) \\ge 0$.\n\nThis can be formalized into a differential equation. For any time $t$ where $Q(t) > 0$, the dynamics are governed by:\n$$\n\\frac{dQ(t)}{dt} = \\lambda - \\mu\n$$\nIf $Q(t) = 0$, the volume cannot decrease further. Thus, the rate of change must be non-negative. This means $\\frac{dQ(t)}{dt} = \\max(0, \\lambda - \\mu)$ when $Q(t) = 0$.\n\n1) Stability of the buffer occupancy\nThe long-term behavior (stability) of the buffer occupancy $Q(t)$ depends entirely on the sign of the net rate, which is the constant value $\\lambda - \\mu$. We analyze the two cases presented in the question.\n\nCase I: Bounded Occupancy (Stable System)\nFor the buffer occupancy to remain bounded over time, it must not have a tendency to grow indefinitely. This occurs if the net rate of change is non-positive whenever the buffer is non-empty.\nIf $\\lambda < \\mu$, then $\\lambda - \\mu < 0$. In this case, whenever $Q(t) > 0$, we have $\\frac{dQ}{dt} < 0$, meaning the buffer will drain. If the buffer is empty, $Q(t)=0$, it can only start to fill if there are arrivals, at which point the drain rate exceeds the arrival rate, pushing $Q(t)$ back towards $0$. The system is self-regulating, and the occupancy will remain bounded.\nIf $\\lambda = \\mu$, then $\\lambda - \\mu = 0$. In this case, whenever $Q(t) > 0$, we have $\\frac{dQ}{dt} = 0$. The buffer level remains constant at its current value. If $Q(t) = 0$, it remains at $0$. The occupancy does not grow to infinity; it remains at its initial level $Q_0$ if $Q_0>0$. Thus, it is also bounded.\nTherefore, the condition for the buffer occupancy to remain bounded over time is $\\lambda \\le \\mu$.\n\nCase II: Divergent Occupancy (Unstable System)\nThe buffer occupancy will diverge if it has a persistent tendency to grow. This occurs if the net rate of change is positive.\nIf $\\lambda > \\mu$, then $\\lambda - \\mu > 0$. In this case, whenever $Q(t) > 0$, we have $\\frac{dQ}{dt} > 0$. The buffer volume will continuously increase. Even if the buffer starts empty, $Q(0)=0, \\frac{dQ}{dt} = \\lambda - \\mu > 0$, so it will immediately begin to fill and continue to grow. In a system with a finite capacity $C$, this growth will continue until the buffer overflows. In an uncapacitated system, $Q(t)$ would grow without bound.\nTherefore, the condition for the buffer occupancy to diverge is $\\lambda > \\mu$.\n\n2) Derivation of $Q(t)$ for $\\lambda > \\mu$\nWe are given the specific case where $\\lambda > \\mu$ and the initial condition is $Q(0) = Q_{0}$, with $Q_{0} \\in (0, C)$.\nSince $Q_{0} > 0$ and the net rate $\\lambda - \\mu$ is a positive constant, the buffer volume $Q(t)$ will increase linearly from its initial state. It will never become $0$ for $t > 0$. Thus, for the entire time interval $0 \\le t < t_{\\text{overflow}}$, the system is governed by the simpler differential equation:\n$$\n\\frac{dQ}{dt} = \\lambda - \\mu\n$$\nThis is a first-order ordinary differential equation with constant coefficients. We can solve it by integrating with respect to time from $t=0$ to a general time $t$, with the corresponding queue volumes being $Q(0)=Q_{0}$ and $Q(t)$:\n$$\n\\int_{Q_{0}}^{Q(t)} dQ' = \\int_{0}^{t} (\\lambda - \\mu) dt'\n$$\nEvaluating the integrals gives:\n$$\nQ(t) - Q_{0} = (\\lambda - \\mu)t\n$$\nSolving for $Q(t)$, we obtain the closed-form expression for the buffer volume as a function of time:\n$$\nQ(t) = Q_{0} + (\\lambda - \\mu)t\n$$\nThis expression is valid for $0 \\le t < t_{\\text{overflow}}$.\n\n3) Calculation of the overflow time $t_{\\text{overflow}}$\nWe are given the system parameters:\n- Arrival rate $\\lambda = 2.4$ GB/s\n- Service rate $\\mu = 1.8$ GB/s\n- Buffer capacity $C = 12$ GB\n- Initial buffer volume $Q_{0} = 1.5$ GB\n\nThe overflow time, $t_{\\text{overflow}}$, is the time $t$ at which the buffer volume $Q(t)$ first reaches the capacity $C$. We use the expression for $Q(t)$ from part (2) and set $Q(t_{\\text{overflow}}) = C$:\n$$\nC = Q_{0} + (\\lambda - \\mu)t_{\\text{overflow}}\n$$\nWe can now solve for $t_{\\text{overflow}}$:\n$$\nC - Q_{0} = (\\lambda - \\mu)t_{\\text{overflow}}\n$$\n$$\nt_{\\text{overflow}} = \\frac{C - Q_{0}}{\\lambda - \\mu}\n$$\nNow, we substitute the numerical values into this equation. The units are consistent: $\\frac{\\text{GB}}{\\text{GB/s}} = \\text{s}$.\n$$\nt_{\\text{overflow}} = \\frac{12 - 1.5}{2.4 - 1.8}\n$$\n$$\nt_{\\text{overflow}} = \\frac{10.5}{0.6}\n$$\n$$\nt_{\\text{overflow}} = 17.5\n$$\nThe problem asks for the answer to be rounded to four significant figures. The exact value of $17.5$ can be expressed as $17.50$ to satisfy this requirement. The unit of the result is seconds.",
            "answer": "$$\n\\boxed{17.50}\n$$"
        },
        {
            "introduction": "Real-world operating systems employ more sophisticated strategies than a simple, constant-rate flusher. To balance performance and responsiveness, systems like Linux use multiple thresholds to trigger different levels of writeback activity, from gentle background flushing to aggressive, process-stalling flushes. This hands-on coding exercise  asks you to implement a piecewise-linear model of such a page cache. By simulating the system's dynamics, you can predict how it responds to a write-heavy workload and when different flushing mechanisms are activated, bridging the gap between simple theory and practical kernel design.",
            "id": "3690239",
            "problem": "Design and implement a complete, runnable program that models the dynamics of a file system page cache under a write-heavy workload in an Operating System (OS). The model uses writeback caching with dirty page thresholds and flusher threads. The goal is to predict when flusher threads kick in and whether the page cache saturates.\n\nStart from the following fundamental definitions and well-tested facts. A page cache holds recently accessed file data and accumulates dirty pages when processes write data, deferring writeback to secondary storage. Let the cache capacity be $C$ pages and the number of dirty pages at time $t$ be $D(t)$, measured in pages. Under a write-heavy workload, $N$ processes write at constant rates $\\{w_i\\}_{i=1}^N$ in pages per second, so the aggregate write rate is $W = \\sum_{i=1}^N w_i$ in pages per second. Writeback flusher threads are governed by two thresholds expressed as ratios of the cache capacity: the background dirty threshold $\\text{dirty\\_bg\\_ratio} = r_{\\text{bg}}$ and the maximum dirty threshold $\\text{dirty\\_ratio} = r_{\\text{max}}$, where $0 < r_{\\text{bg}} < r_{\\text{max}} < 1$. When $D(t)$ crosses $r_{\\text{bg}} \\cdot C$, background flushing begins at a constant rate $f_{\\text{bg}}$ in pages per second. When $D(t)$ crosses $r_{\\text{max}} \\cdot C$, aggressive flushing begins at a higher constant rate $f_{\\text{max}}$ in pages per second. The number of dirty pages $D(t)$ is constrained by $0 \\le D(t) \\le C$.\n\nThe program must compute the following quantities for each provided test case:\n- $t_{\\text{bg}}$: the first time in seconds at which $D(t)$ reaches or exceeds $r_{\\text{bg}} \\cdot C$, meaning background flusher threads kick in.\n- $t_{\\text{max}}$: the first time in seconds at which $D(t)$ reaches or exceeds $r_{\\text{max}} \\cdot C$, meaning aggressive flusher threads kick in.\n- $t_{\\text{sat}}$: the first time in seconds at which $D(t)$ reaches $C$, meaning the page cache saturates.\n\nUse the following piecewise-linear dynamics. Let the initial dirty pages be $D(0) = D_0$. The aggregate write rate is $W = \\sum_{i=1}^N w_i$. Define the instantaneous writeback rate $f(D)$ by\n$$\nf(D) = \n\\begin{cases}\n0, & \\text{if } D < r_{\\text{bg}} \\cdot C, \\\\\nf_{\\text{bg}}, & \\text{if } r_{\\text{bg}} \\cdot C \\le D < r_{\\text{max}} \\cdot C, \\\\\nf_{\\text{max}}, & \\text{if } D \\ge r_{\\text{max}} \\cdot C,\n\\end{cases}\n$$\nand the rate of change of dirty pages by the well-tested conservation law\n$$\n\\frac{dD}{dt} = W - f(D),\n$$\nwith clamping to the interval $[0, C]$.\n\nAll times must be expressed in seconds as decimal floats. If a quantity never occurs under constant rates (for example, no writes so $W = 0$ and $D(t)$ never increases), output $-1.0$ for that quantity.\n\nTest Suite. Implement the program for the following parameter sets. For each test case, the program must output $[t_{\\text{bg}}, t_{\\text{max}}, t_{\\text{sat}}]$.\n\n- Test case $1$ (general \"happy path\"): $C = 10000$, $r_{\\text{bg}} = 0.1$, $r_{\\text{max}} = 0.4$, $N = 3$, $\\{w_i\\} = \\{120, 80, 50\\}$, $f_{\\text{bg}} = 200$, $f_{\\text{max}} = 300$, $D_0 = 0$.\n- Test case $2$ (boundary where background flushing exactly balances writes): $C = 5000$, $r_{\\text{bg}} = 0.2$, $r_{\\text{max}} = 0.5$, $N = 2$, $\\{w_i\\} = \\{100, 100\\}$, $f_{\\text{bg}} = 200$, $f_{\\text{max}} = 400$, $D_0 = 0$.\n- Test case $3$ (edge case with no writes): $C = 8000$, $r_{\\text{bg}} = 0.1$, $r_{\\text{max}} = 0.3$, $N = 2$, $\\{w_i\\} = \\{0, 0\\}$, $f_{\\text{bg}} = 100$, $f_{\\text{max}} = 200$, $D_0 = 0$.\n- Test case $4$ (saturation case where even aggressive flushing cannot keep up): $C = 4000$, $r_{\\text{bg}} = 0.15$, $r_{\\text{max}} = 0.35$, $N = 4$, $\\{w_i\\} = \\{300, 250, 200, 150\\}$, $f_{\\text{bg}} = 500$, $f_{\\text{max}} = 800$, $D_0 = 0$.\n- Test case $5$ (background flusher triggers but immediately reduces dirty pages): $C = 12000$, $r_{\\text{bg}} = 0.25$, $r_{\\text{max}} = 0.6$, $N = 1$, $\\{w_i\\} = \\{100\\}$, $f_{\\text{bg}} = 150$, $f_{\\text{max}} = 400$, $D_0 = 0$.\n\nFinal Output Format. Your program should produce a single line of output containing the results as a comma-separated list of sublists, each sublist in the form $[t_{\\text{bg}}, t_{\\text{max}}, t_{\\text{sat}}]$, all times in seconds as decimal floats rounded to six decimal places, enclosed in a single outer pair of square brackets. For example: $[[1.000000,2.500000,-1.000000],[\\dots]]$.",
            "solution": "The evolution of the number of dirty pages, $D(t)$, is governed by the piecewise-linear differential equation $\\frac{dD}{dt} = W - f(D)$. We can analyze the system's dynamics in three distinct phases defined by the dirty page thresholds. The key is to recognize that within each phase, the rate of change of $D(t)$ is constant. This allows us to calculate the time $\\Delta t$ required to change the number of dirty pages by $\\Delta D$ using the simple kinematic relation $\\Delta t = \\frac{\\Delta D}{\\text{rate}}$.\n\nFirst, we define the absolute page counts for the thresholds:\n- Background threshold: $D_{\\text{bg}} = r_{\\text{bg}} \\cdot C$\n- Maximum threshold: $D_{\\text{max}} = r_{\\text{max}} \\cdot C$\n- Saturation: $D_{\\text{sat}} = C$\n\nThe net rates of change of dirty pages in each phase are:\n- Phase 1 (pre-flush): For $D(t) < D_{\\text{bg}}$, $f(D) = 0$, so the rate is $R_1 = \\frac{dD}{dt} = W$.\n- Phase 2 (background flush): For $D_{\\text{bg}} \\le D(t) < D_{\\text{max}}$, $f(D) = f_{\\text{bg}}$, so the rate is $R_2 = \\frac{dD}{dt} = W - f_{\\text{bg}}$.\n- Phase 3 (aggressive flush): For $D(t) \\ge D_{\\text{max}}$, $f(D) = f_{\\text{max}}$, so the rate is $R_3 = \\frac{dD}{dt} = W - f_{\\text{max}}$.\n\nThe problem specifies an initial condition of $D(0) = D_0 = 0$ for all test cases. This simplifies the calculation, as the system always starts in Phase $1$ and progresses sequentially. We initialize all target times to the sentinel value, $t_{\\text{bg}} = -1.0$, $t_{\\text{max}} = -1.0$, and $t_{\\text{sat}} = -1.0$.\n\n**Step 1: Calculation of $t_{\\text{bg}}$**\nThe system starts with $D(0)=0$ dirty pages. It will reach the background threshold $D_{\\text{bg}}$ only if the net rate of change is positive, i.e., $R_1 = W > 0$. If $W \\le 0$, the number of dirty pages will not increase, and no thresholds will ever be reached.\nIf $W > 0$, the time required to accumulate $D_{\\text{bg}}$ pages is:\n$$t_{\\text{bg}} = \\frac{\\Delta D}{\\text{rate}} = \\frac{D_{\\text{bg}} - D_0}{R_1} = \\frac{D_{\\text{bg}}}{W}$$\nIf this step is not possible ($W \\le 0$), we stop, and all times remain $-1.0$.\n\n**Step 2: Calculation of $t_{\\text{max}}$**\nAfter time $t_{\\text{bg}}$, the system has $D_{\\text{bg}}$ dirty pages and enters Phase $2$. The number of dirty pages will continue to increase towards $D_{\\text{max}}$ only if the net rate in this phase is positive, i.e., $R_2 = W - f_{\\text{bg}} > 0$.\nIf $R_2 > 0$, the additional time, $\\Delta t_2$, to go from $D_{\\text{bg}}$ to $D_{\\text{max}}$ is:\n$$\\Delta t_2 = \\frac{D_{\\text{max}} - D_{\\text{bg}}}{R_2} = \\frac{D_{\\text{max}} - D_{\\text{bg}}}{W - f_{\\text{bg}}}$$\nThe total time from $t=0$ to reach the maximum threshold is the sum of the times from each phase:\n$$t_{\\text{max}} = t_{\\text{bg}} + \\Delta t_2$$\nIf $R_2 \\le 0$, the system will either stabilize at $D_{\\text{bg}}$ or the number of dirty pages will decrease, so $D_{\\text{max}}$ is never reached. In this case, $t_{\\text{max}}$ and $t_{\\text{sat}}$ remain $-1.0$.\n\n**Step 3: Calculation of $t_{\\text{sat}}$**\nAfter time $t_{\\text{max}}$, the system has $D_{\\text{max}}$ dirty pages and enters Phase $3$. The cache will saturate (reach $D(t) = C$) only if the net rate in this phase is positive, i.e., $R_3 = W - f_{\\text{max}} > 0$.\nIf $R_3 > 0$, the additional time, $\\Delta t_3$, to go from $D_{\\text{max}}$ to $C$ is:\n$$\\Delta t_3 = \\frac{C - D_{\\text{max}}}{R_3} = \\frac{C - D_{\\text{max}}}{W - f_{\\text{max}}}$$\nThe total time from $t=0$ to saturation is:\n$$t_{\\text{sat}} = t_{\\text{max}} + \\Delta t_3$$\nIf $R_3 \\le 0$, the aggressive flusher is sufficient to handle the write load, and the cache will not saturate. In this case, $t_{\\text{sat}}$ remains $-1.0$.\n\nThis sequential, phase-by-phase calculation provides the required times for each test case.",
            "answer": "[[4.000000,64.000000,-1.000000],[5.000000,-1.000000,-1.000000],[-1.000000,-1.000000,-1.000000],[0.666667,2.666667,28.666667],[30.000000,-1.000000,-1.000000]]"
        },
        {
            "introduction": "The performance gains of write buffering come at a cost: a gap between when an application believes a write is complete and when the data is truly durable on storage. This gap creates complex failure modes, especially during system crashes, as the operating system may reorder writes to optimize performance. This practice  presents a critical, real-world logic puzzle: how to perform an atomic file update safely using the standard \"temporary file and rename\" pattern. You must reason about the ordering guarantees of file system operations to find the correct sequence of `fsync` calls that prevents data corruption, highlighting the programmer's responsibility in a world of buffered I/O.",
            "id": "3690204",
            "problem": "An application on a Portable Operating System Interface (POSIX) compliant Operating System (OS) updates a configuration file using a two-step protocol to avoid partial writes. The application writes the next version of the configuration into a temporary file path $\\mathrm{config.tmp}$, then renames $\\mathrm{config.tmp}$ over the existing $\\mathrm{config}$ path. The storage stack uses an OS page cache and a device write-back cache; both caches are volatile and may lose buffered data on a crash unless explicitly flushed. Closing a file does not imply durability. The function $\\mathrm{fsync}$ on a regular file forces that file’s data and inode metadata to reach stable storage; the function $\\mathrm{fsync}$ on a directory forces directory entries (including adds, deletes, and renames) and directory metadata to reach stable storage. The rename is atomic with respect to directory entries once persisted (i.e., readers see either the old name mapping or the new name mapping, but never a mixture), yet the file’s data blocks and directory metadata may be persisted in different orders unless forced.\n\nThe application’s baseline sequence (omitting optional $\\mathrm{fsync}$ calls) is:\n- Open $\\mathrm{config.tmp}$ for write.\n- Write $N$ bytes of the new configuration into $\\mathrm{config.tmp}$.\n- Close $\\mathrm{config.tmp}$.\n- Rename $\\mathrm{config.tmp}$ to $\\mathrm{config}$ (replacing the old $\\mathrm{config}$ atomically at persistence time).\n\nYou must decide where to place $\\mathrm{fsync}$ calls to guarantee atomicity under the following strong crash-consistency requirement:\n\nDefinition (atomicity requirement): For any crash that occurs at any time during the update (possibly between two adjacent system calls in the sequence), the recovered system state must satisfy both invariants:\n- Invariant $\\mathrm{I1}$ (no torn content upon visibility): If $\\mathrm{config}$ after recovery refers to the new version, then its contents are exactly the $N$ bytes written by the application (no truncation, zeros, or stale mixture).\n- Invariant $\\mathrm{I2}$ (post-success durability of the name switch): After the application’s last call in the chosen sequence returns success, any subsequent crash must not revert the name mapping; that is, $\\mathrm{config}$ continues to refer to the new version after recovery.\n\nAssume the source and destination paths are in the same parent directory. Which of the following $\\mathrm{fsync}$ placements guarantee atomicity as defined above?\n\nA. Perform no $\\mathrm{fsync}$ calls at all.\n\nB. After the rename, call $\\mathrm{fsync}$ on the parent directory only; do not call $\\mathrm{fsync}$ on the file.\n\nC. Before the rename, call $\\mathrm{fsync}$ on $\\mathrm{config.tmp}$; after the rename, do not call $\\mathrm{fsync}$ on the parent directory.\n\nD. Before the rename, call $\\mathrm{fsync}$ on $\\mathrm{config.tmp}$; perform the rename; then call $\\mathrm{fsync}$ on the parent directory.\n\nE. Perform the rename first; then call $\\mathrm{fsync}$ on `config` (the renamed file); finally call `fsync` on the parent directory.",
            "solution": "This problem requires finding a sequence of operations that satisfies two crash-consistency invariants. Let `dir` be the parent directory.\n\n**Analysis of Invariant I1 (no torn content upon visibility):**\nInvariant I1 states that if the name `config` on the filesystem points to the new version of the file after a crash, then the contents of that file must be complete. The `rename(\"config.tmp\", \"config\")` call makes the new content visible under the name `config`. Due to write reordering in the OS and storage device, the directory change from `rename` could be persisted to stable storage *before* the data blocks of `config.tmp` are persisted. If a crash occurs in this window, the file system would recover to a state where `config` points to an inode whose data on disk is incomplete or garbage. This is a \"torn content\" failure.\n\nTo prevent this, the application must enforce an ordering: the data of `config.tmp` must be durable *before* the `rename` operation is performed. The POSIX call to force a file's data to stable storage is `fsync()`. Therefore, to satisfy I1, `fsync(config.tmp)` must be called and return successfully *before* calling `rename(\"config.tmp\", \"config\")`.\n\n**Analysis of Invariant I2 (post-success durability of the name switch):**\nInvariant I2 states that once the application's entire update sequence completes successfully, the name change must be durable and survive any subsequent crash. The `rename` operation modifies the parent directory `dir`. A successful return from the `rename()` system call only means the operation is queued in the OS's volatile buffers; it does not guarantee it has reached stable storage. A crash after `rename()` returns but before the directory change is flushed would cause the name change to be lost.\n\nTo guarantee the durability of the directory modification, the application must explicitly force it to stable storage. The call for this is `fsync(dir)`. To satisfy I2, `fsync(dir)` must be called *after* the `rename` operation, and the entire sequence is only considered durably complete after `fsync(dir)` returns success.\n\n**Synthesis of the Correct Sequence:**\nCombining the requirements from both invariants yields the only correct and robust sequence:\n1.  Write the new data to `config.tmp`.\n2.  Call `fsync(config.tmp)`. (Satisfies prerequisite for I1)\n3.  Call `rename(\"config.tmp\", \"config\")`.\n4.  Call `fsync(dir)`. (Satisfies I2 and completes the atomic operation)\n\n**Evaluation of Options:**\n\n*   **A. No `fsync` calls:** Violates both I1 (reordering can cause torn content) and I2 (rename is not durable).\n*   **B. `fsync` on directory only:** Fails to `fsync` the file data before rename, violating I1.\n*   **C. `fsync` on file only:** Satisfies I1, but fails to `fsync` the directory after rename, violating I2.\n*   **D. `fsync` on file, then rename, then `fsync` on directory:** This sequence matches the derived correct protocol. It satisfies both I1 and I2.\n*   **E. Rename first:** Performing `rename` before `fsync(file)` immediately creates a window where I1 can be violated.",
            "answer": "$$\\boxed{D}$$"
        }
    ]
}