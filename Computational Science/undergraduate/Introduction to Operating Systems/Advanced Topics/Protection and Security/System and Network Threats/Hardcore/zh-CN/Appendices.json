{
    "hands_on_practices": [
        {
            "introduction": "现代操作系统采用地址空间布局随机化（ASLR）等技术，以增加利用内存错误的难度。然而，“更难”不是一个精确的术语。本练习将指导你计算 ASLR 在熵方面的实际强度，并了解该强度如何转化为暴力攻击的现实成功概率。",
            "id": "3685862",
            "problem": "现代操作系统使用地址空间布局随机化 (ASLR) 技术，在每次程序启动时随机化位置无关可执行文件 (PIE) 的基地址。考虑两种架构：一个 $32$ 位系统和一个 $64$ 位系统。在这两种系统中，加载器都会从一个受限于页面对齐的连续虚拟地址窗口内，均匀随机地选择 PIE 基地址。具体来说，在 $32$ 位系统上，窗口宽度为 $256$ MiB；在 $64$ 位系统上，窗口宽度为 $128$ GiB。页面大小为 $4$ KiB。假设窗口端点的选择使得在两种情况下页面对齐的基地址位置数量都是整数，并且窗口内每个页面对齐的位置都是等可能的。\n\n将 PIE 基地址的运行时 ASLR “熵” $E$ 定义为运行时实际可达到的等可能基地址位置数量的以 2 为底的对数。仅从以下基本事实出发：在 $N$ 个结果上的均匀离散选择中，每个结果的概率为 $1/N$；宽度为 $W$、对齐量为 $a$ 的窗口中页面对齊位置的数量等于该窗口能容纳的对齐量子的数量；$\\log_{2}$ 用于度量 $N$ 个等可能状态的熵（单位为比特）。请完成以下任务：\n\n- 用符号确定 $E$ 如何依赖于窗口宽度 $W$ 和对齐量 $a$。\n- 根据上述参数，计算 $32$ 位和 $64$ 位系统所实现的运行时熵值 $E_{32}$ 和 $E_{64}$。\n- 现在考虑一种远程内存损坏攻击，该攻击成功的唯一条件是攻击者在每次连接中对 PIE 基地址的单次猜测与实际基地址完全匹配。每次失败的猜测都会导致进程崩溃并立即重启，一次新的连接会从同一分布中产生一次独立的 ASLR 抽样。仅使用独立伯努利试验的公理和补集法则，推导 $m$ 次独立尝试后的成功概率，将其表示为 $m$ 和基地址位置数 $N$ 的函数。然后，使用上述 $64$ 位系统的参数，对 $m = 10^{6}$ 次尝试的情况，数值计算此概率。将此成功概率表示为保留四位有效数字的小数。\n\n將你的最終答案表示为一个行矩阵 $\\begin{pmatrix} E_{32}  E_{64}  p_{64}(m) \\end{pmatrix}$，其中 $p_{64}(m)$ 表示所要求的 $m = 10^{6}$ 时 $64$ 位系统的成功概率。",
            "solution": "该问题被验证为科学上合理、良定、完整且相关。解答按要求分三部分进行。\n\n首先，我们确定 ASLR 熵 $E$、随机化窗口宽度 $W$ 和对齐大小 $a$ 之间的符号关系。\n基地址的可能选择数量 $N$，由总随机化窗口内可容纳的非重叠对齐块的数量给出。问题中将其表述为“该窗口能容纳的对齐量子的数量”。这可以通过将窗口宽度 $W$ 除以对齐大小 $a$ 来计算。\n$$N = \\frac{W}{a}$$\n问题将 ASLR “熵” $E$ 定义为等可能基地址位置数量的以 2 为底的对数，这对于一个在 $N$ 个状态上的均匀分布而言，是以比特为单位的 Shannon 熵的标准定义。\n$$E = \\log_{2}(N)$$\n将 $N$ 的表达式代入 $E$ 的定义，我们得到熵对 $W$ 和 $a$ 的符号依赖关系。\n$$E = \\log_{2}\\left(\\frac{W}{a}\\right)$$\n\n其次，我们计算给定系统参数下实现的运行时熵值 $E_{32}$ 和 $E_{64}$。为此，我们必须首先将窗口宽度和页面大小表示为一致的单位，例如字节。我们使用标准的二进制前缀：$1 \\text{ KiB} = 2^{10}$ 字节，$1 \\text{ MiB} = 2^{20}$ 字节，以及 $1 \\text{ GiB} = 2^{30}$ 字节。\n\n页面大小决定了对齐量 $a$，给定为 $4$ KiB。\n$$a = 4 \\text{ KiB} = 4 \\times 2^{10} \\text{ bytes} = 2^2 \\times 2^{10} \\text{ bytes} = 2^{12} \\text{ bytes}$$\n\n对于 $32$ 位系统，窗口宽度 $W_{32}$ 为 $256$ MiB。\n$$W_{32} = 256 \\text{ MiB} = 256 \\times 2^{20} \\text{ bytes} = 2^8 \\times 2^{20} \\text{ bytes} = 2^{28} \\text{ bytes}$$\n可能的基地址位置数量 $N_{32}$ 为：\n$$N_{32} = \\frac{W_{32}}{a} = \\frac{2^{28} \\text{ bytes}}{2^{12} \\text{ bytes}} = 2^{28-12} = 2^{16}$$\n因此，$32$ 位系统的熵 $E_{32}$ 为：\n$$E_{32} = \\log_{2}(N_{32}) = \\log_{2}(2^{16}) = 16$$\n\n对于 $64$ 位系统，窗口宽度 $W_{64}$ 为 $128$ GiB。\n$$W_{64} = 128 \\text{ GiB} = 128 \\times 2^{30} \\text{ bytes} = 2^7 \\times 2^{30} \\text{ bytes} = 2^{37} \\text{ bytes}$$\n可能的基地址位置数量 $N_{64}$ 为：\n$$N_{64} = \\frac{W_{64}}{a} = \\frac{2^{37} \\text{ bytes}}{2^{12} \\text{ bytes}} = 2^{37-12} = 2^{25}$$\n$64$ 位系统的熵 $E_{64}$ 为：\n$$E_{64} = \\log_{2}(N_{64}) = \\log_{2}(2^{25}) = 25$$\n\n第三，我们推导 $m$ 次独立尝试后远程内存损坏攻击的成功概率。攻击模型假设攻击者每次尝试只进行一次猜测，失败的尝试会导致进程重启，并生成一个新的、独立的随机基地址。这种设置对应于一系列独立的伯努利试验。\n设 $N$ 为可能的基地址总数。由于选择是均匀的，任何单次尝试的成功概率为：\n$$p_{success} = \\frac{1}{N}$$\n单次尝试的失败概率是其补集：\n$$p_{fail} = 1 - p_{success} = 1 - \\frac{1}{N}$$\n由于 $m$ 次尝试都是独立的，所有 $m$ 次尝试都失败的概率是它们各自概率的乘积：\n$$P(\\text{fail on all } m \\text{ attempts}) = (p_{fail})^m = \\left(1 - \\frac{1}{N}\\right)^m$$\n“$m$ 次尝试后成功”的事件意味着至少成功一次。这是“所有 $m$ 次尝试都失败”事件的补集。使用补集法则，在 $m$ 次尝试中至少有一次成功的概率，记为 $p(m)$，为：\n$$p(m) = 1 - P(\\text{fail on all } m \\text{ attempts}) = 1 - \\left(1 - \\frac{1}{N}\\right)^m$$\n现在，我们针对 $m = 10^6$ 次尝试的 $64$ 位系统来计算这个概率。对于该系统，我们已经得出 $N = N_{64} = 2^{25}$。\n$$p_{64}(m) = 1 - \\left(1 - \\frac{1}{2^{25}}\\right)^{10^6}$$\n我们计算其数值：\n$$N_{64} = 2^{25} = 33,554,432$$\n$$p_{64}(10^6) = 1 - \\left(1 - \\frac{1}{33,554,432}\\right)^{1,000,000}$$\n计算此表达式得出：\n$$p_{64}(10^6) \\approx 1 - (0.9999999701976776)^{1000000} \\approx 1 - 0.970636936 \\approx 0.029363064$$\n将此结果四舍五入到四位有效数字，得到：\n$$p_{64}(10^6) \\approx 0.02936$$\n\n最终结果为 $E_{32}=16$，$E_{64}=25$ 和 $p_{64}(10^6) \\approx 0.02936$。",
            "answer": "$$\\boxed{\\begin{pmatrix} 16  25  0.02936 \\end{pmatrix}}$$"
        },
        {
            "introduction": "保护数据安全不仅在于加密，还在于确保其在更新过程中的一致性。这个思想实验探讨了底层文件系统的日志和缓存行为如何产生竞争条件，攻击者可以利用简单的断电来触发这种竞争条件，从而导致严重的信息泄露。",
            "id": "3685788",
            "problem": "一个存储服务器使用日志文件系统，该系统支持三种日志模式：仅元数据（metadata-only）的写回（writeback）模式、仅元数据的有序数据写入（ordered data writes）模式，以及完全数据日志（full data journaling）模式。文件系统底层的设备有一个易失性（volatile）的写回缓存。当启用时，写屏障（write barriers）（如缓存刷新或强制单元访问/Force Unit Access）会强制数据持久化并保证跨设备缓存的写入顺序。日志是一种预写式日志（write-ahead log）：元数据更新被分组到一个事务 $T_k$ 中，其提交记录（commit record）最后写入；发生崩溃后，只有完全提交的事务才会被重放。在仅元数据模式下，应用程序的数据块不属于日志的一部分，并且可以由后台输入/输出（I/O）在任何时候写入主区域，具体取决于每种模式的排序规则。文件同步系统调用（`fsync`）请求文件系统在返回之前，根据文件系统的保证，将调用文件的脏数据（dirty data）和元数据强制写入稳定存储。访问控制列表（ACL）的变更是与 inode 关联的元数据。\n\n考虑一个初始时对用户组 $G$ 全局可读的单个文件 $f$。一个用户打算将文件 $f$ 变为机密，并用一个秘密字符串覆盖其内容。该用户在没有发生崩溃的情况下执行以下高级步骤：首先，将新内容写入 $f$ 的现有已分配块中；然后，设置一个限制性的 ACL，使得只有所有者可以读取 $f$。攻击者可以在向存储设备实际写出过程中的任意选定时间 $t$ 切断电源。除非另有说明，假设不使用应用程序级别的重命名（rename）或临时文件交换操作，并且除非另有说明，假设不显式调用 `fsync`。攻击者的目标是导致系统重启后出现一种状态：新内容可见，而旧的、宽松的 ACL 仍然有效。\n\n根据日志记录和存储排序的基本原理，选择下面所有能保证在任何对抗性选择的崩溃时间 $t$ 下，系统都不会重启进入这样一种状态：$f$ 的新内容可见，而限制性 ACL 尚未持久化。\n\nA. 完全数据日志模式，启用写屏障；应用程序执行数据写入和 ACL 更改，然后对 $f$ 调用一次 `fsync`。\n\nB. 仅元数据日志的有序（ordered）模式，启用写屏障；应用程序不调用 `fsync`。\n\nC. 仅元数据日志的写回（writeback）模式，禁用写屏障。\n\nD. 完全数据日志模式，在具有易失性写回缓存的设备上禁用写屏障；应用程序在两次更新后对 $f$ 调用一次 `fsync`。\n\nE. 仅元数据日志的有序模式，启用写屏障；应用程序在数据写入后立即对 $f$ 调用 `fsync`，然后在没有后续 `fsync` 的情况下执行 ACL 更改。\n\nF. 仅元数据日志的有序模式，启用写屏障；应用程序首先更改 ACL，对 $f$ 调用 `fsync`，然后写入新内容，并再次对 $f$ 调用 `fsync`。",
            "solution": "在进行解答之前，首先分析问题陈述的有效性。\n\n### 步骤1：提取已知条件\n- **系统**：一个带有日志文件系统的存储服务器。\n- **日志模式**：\n    1. 仅元数据的写回（writeback）模式。\n    2. 仅元数据的有序数据写入（ordered data writes）模式。\n    3. 完全数据日志（Full data journaling）模式。\n- **设备**：包含一个易失性（volatile）的写回缓存。\n- **写屏障（Write Barriers）**：启用时，强制持久化和排序（例如，缓存刷新、强制单元访问/Force Unit Access）。\n- **日志**：一种预写式日志（WAL）。元数据更新被分组到一个事务 $T_k$ 中。提交记录最后写入。崩溃后只重放完全提交的事务。\n- **仅元数据模式**：数据块不在日志中，由后台 I/O 根据每种模式的排序规则写入主区域。\n- **ACLs**：访问控制列表是元数据。\n- **`fsync`**：一个将文件的脏数据和元数据强制写入稳定存储的系统调用。\n- **初始状态**：文件 $f$ 对用户组 $G$ 全局可读。\n- **用户操作序列**：\n    1. 将新的机密内容写入 $f$ 的现有块中。\n    2. 在 $f$ 上设置一个限制性 ACL。\n- **攻击者目标**：导致重启后出现一种状态，即 $f$ 的新内容可见，而旧的、宽松的 ACL 仍然有效。\n- **假设**：除非明确说明，否则没有应用层面的原子替换操作（例如 `rename`），也没有 `fsync` 调用。\n\n### 步骤2：使用提取的已知条件进行验证\n问题是科学严谨的、定义明确的、并且客观的。\n- **科学严谨性**：该问题建立在操作系统和计算机体系结构的核心、标准概念之上，包括日志文件系统（预写式日志、不同的日志模式）、存储设备缓存（易失性写回缓存）和数据一致性原语（写屏障、`fsync`）。这些概念在计算机科学领域是事实性的且广为接受的。\n- **定义明确性**：初始状态、用户操作和攻击者的期望结果（“易受攻击的状态”）都得到了精确的定义。问题要求找出能够*保证*在*任何*对抗性选择的崩溃时间 $t$ 下防止这种状态发生的配置。这为评估每个选项设定了一个清晰、明确的标准。通过基于所提供原理的逻辑推导，可以得出一个唯一的答案集。\n- **客观性**：语言是技术性的，没有主观性或歧义。诸如“易失性写回缓存”、“仅元数据的有序数据写入”和“强制单元访问”等术语具有精确的技术含义。\n\n该问题没有违反任何无效性标准。它是一个基于系统设计基本原理的、有效的、可解决的问题。\n\n### 步骤3：结论与行动\n问题有效。将推导出解决方案。\n\n### 基于原理的推导\n令 $D_{new}$ 表示新的、机密的数据内容，令 $M_{new}$ 表示新的、限制性的 ACL 元数据。用户首先执行与 $D_{new}$ 对应的操作，然后执行与 $M_{new}$ 对应的操作。\n令 $W(X)$ 表示项目 $X$ 已被持久地写入稳定存储的事件，这意味着它能在电源故障后幸存。\n攻击者的目标是达到易受攻击的状态：$W(D_{new}) \\land \\neg W(M_{new})$。\n如果一个配置能保证在任何崩溃时间 $t$ 下这种状态都不可能发生，那么该配置就是“安全的”。这需要确保对于任何执行，条件 $W(D_{new}) \\implies W(M_{new})$ 都成立。这个蕴含关系可以通过两种通用机制之一来满足：\n1.  **原子性**：$D_{new}$ 和 $M_{new}$ 作为单个原子事务的一部分被写入。恢复的结果要么是 $W(D_{new}) \\land W(M_{new})$，要么是 $\\neg W(D_{new}) \\land \\neg W(M_{new})$。混合状态是不可能的。\n2.  **排序性**：系统强制执行一个排序，使得 $W(M_{new})$ 必须在 $W(D_{new})$ 之前发生。如果这个顺序得到保证，那么 $W(D_{new})$ 为真的状态必然意味着 $W(M_{new})$ 也为真。\n\n我们现在根据这些原则来分析每个选项。\n\n### 逐项分析\n\n**A. 完全数据日志模式，启用写屏障；应用程序执行数据写入和 ACL 更改，然后对 $f$ 调用一次 `fsync`。**\n\n在完全数据日志模式下，文件数据（$D_{new}$）和元数据（$M_{new}$）都作为同一个事务 $T_k$ 的一部分写入日志。文件系统确保 $D_{new}$ 和 $M_{new}$ 的日志条目被写入，然后是 $T_k$ 的提交记录。启用写屏障是至关重要的：它保证了这些写操作以正确的顺序发生在稳定存储介质上，防止提交记录在事务内容之前被持久化。因为 $D_{new}$ 和 $M_{new}$ 是同一个原子事务的一部分，崩溃恢复将要么重放整个事务（应用两个更改），要么丢弃它（两个更改都不应用）。恢复后不可能出现数据更改已应用而元数据更改未应用的状态。这提供了上面讨论的原子性保证。`fsync` 调用强制提交此事务，但安全保证源于完全数据日志模式本身的基本原子性。\n\n**结论：** 正确。\n\n**B. 仅元数据日志的有序（ordered）模式，启用写屏障；应用程序不调用 `fsync`。**\n\n在有序模式下，文件系统强制执行一个特定的依赖关系：数据块（$D_{new}$）必须在其引用的元数据事务（$T_k$，包含 $M_{new}$）提交到日志*之前*，被写入其在稳定存储上的最终位置。操作顺序是：（1）后台I/O将 $D_{new}$ 写入磁盘，使 $W(D_{new})$ 为真；（2）文件系统提交 $T_k$，使 $W(M_{new})$ 为真。在步骤（1）之后但在步骤（2）之前存在一个时间窗口。如果攻击者在此窗口期间切断电源，系统将重启进入一个状态，其中 $W(D_{new})$ 为真，但由于 $T_k$ 未提交，$\\neg W(M_{new})$ 为真。这恰好是易受攻击的状态。缺少 `fsync` 调用使得这些操作的时间安排交由操作系统决定，攻击者可以利用这一点。\n\n**结论：** 不正确。\n\n**C. 仅元数据日志的写回（writeback）模式，禁用写屏障。**\n\n这是最弱的一致性配置。在写回模式下，数据写入和元数据日志提交之间没有强制的顺序。系统可以自由地在提交 $M_{new}$ 的事务之前很久就将 $D_{new}$ 写入稳定存储。这创造了与有序模式中相同的易受攻击窗口，并且这个窗口通常要大得多。此外，在具有易失性缓存的设备上禁用写屏障，设备本身可以重排写操作，可能破坏日志结构并导致未定义的文件系统状态，这不能被认为是安全的。此配置不能防止易受攻击的状态。\n\n**结论：** 不正确。\n\n**D. 完全数据日志模式，在具有易失性写回缓存的设备上禁用写屏障；应用程序在两次更新后对 $f$ 调用一次 `fsync`。**\n\n虽然完全数据日志提供了逻辑上的原子性，但这一保证依赖于预写式日志在稳定存储上的完整性。问题陈述该设备具有易失性写回缓存。禁用写屏障意味着文件系统无法命令设备刷新其缓存或强制写入顺序。因此，设备可以自由地重排写操作。它可能在写入事务的数据（$D_{new}$）或元数据（$M_{new}$）块之前，就将事务的提交块写入稳定存储，而前者可能仍在易失性缓存中。此时发生电源崩溃将导致日志中存在一个已提交但内容缺失的事务。重启时，恢复过程将从日志中读取垃圾数据并重放，导致文件系统损坏。此配置不能保证安全；它会主动带来灾难性数据损坏的风险，并且无法保证防止任何特定状态的发生。\n\n**结论：** 不正确。\n\n**E. 仅元数据日志的有序模式，启用写屏障；应用程序在数据写入后立即对 $f$ 调用 `fsync`，然后在没有后续 `fsync` 的情况下执行 ACL 更改。**\n\n应用程序逻辑是 `write(f, D_new);` `fsync(f);` `set_acl(f, M_new)`。`fsync(f)` 调用强制将 $f$ 的所有脏数据（即 $D_{new}$）写入稳定存储。在 `fsync` 调用成功返回后，条件 $W(D_{new})$ 为真。然后应用程序继续更改 ACL，但攻击者可以在 `fsync` 返回后、但在 $M_{new}$ 的新元数据事务提交到日志之前触发电源故障。重启后，系统状态将是 $W(D_{new}) \\land \\neg W(M_{new})$，这正是易受攻击的状态。此应用程序逻辑明确地制造了该漏洞。\n\n**结论：** 不正确。\n\n**F. 仅元数据日志的有序模式，启用写屏障；应用程序首先更改 ACL，对 $f$ 调用 `fsync`，然后写入新内容，并再次对 $f$ 调用 `fsync`。**\n\n此选项将应用程序逻辑反转为 `set_acl(f, M_new);` `fsync(f);` `write(f, D_new);` `fsync(f)`。第一个 `fsync(f)` 通过确保其事务提交到日志，强制将 ACL 元数据更改（$M_{new}$）写入稳定存储。在此调用返回后，$W(M_{new})$ 被保证为真。在此之前发生的任何崩溃都不会导致数据泄露，因为 $D_{new}$ 甚至还没有被写入。在此之后发生的任何崩溃都发生在 $W(M_{new})$ 已经为真的情况下。易受攻击的状态是 $W(D_{new}) \\land \\neg W(M_{new})$。这种状态是不可能达到的，因为任何可能使 $W(D_{new})$ 为真的情况都必须发生在第一个 `fsync` 完成之后，而在那时 $\\neg W(M_{new})$ 为假。此应用程序逻辑正确地实现了保证安全的排序原则。\n\n**结论：** 正确。",
            "answer": "$$\\boxed{AF}$$"
        },
        {
            "introduction": "许多网络攻击始于侦察阶段，攻击者在此阶段扫描开放的端口和服务。本练习让你站在攻击者的角度，对端口扫描的时间成本进行建模，从而定量地展示防火墙规则和正确的服务配置如何能够减缓并威慑对手。",
            "id": "3685793",
            "problem": "一个单主机系统运行着远程过程调用 (RPC) 服务，其端口映射器由 `rpcbind` 程序实现。该主机的防火墙配置了默认拒绝的入站规则，会静默丢弃未经请求的数据包，除非这些数据包的目标是服务端口的一个小型白名单。此外，`rpcbind` 被配置为仅绑定到环回接口，因此 TCP 端口 $111$（标准的 RPC 端口映射器）从外部网络是无法访问的。一个外部攻击者对一组 $m$ 个不同的端口按顺序执行传输控制协议 (TCP) 端口扫描。设 $k$ 是外部可达、在白名单中的开放服务端口的数量，设 $r$ 是被过滤的端口数量（原因可能是防火墙的丢弃策略，也可能是因为 `rpcbind` 仅在环回接口上监听）。剩下的 $m - k - r$ 个端口是关闭但未被过滤的（会以一个重置包响应，而不是被静默丢弃）。\n\n假设单个探测的时序模型如下：\n- 对于一个开放端口（包括任何非 RPC 的白名单服务），完成初始握手的时间是一个随机变量，服从速率参数为 $\\lambda_{o}$ 的指数分布。\n- 对于一个关闭但未过滤的端口，接收到重置包的时间是一个随机变量，服从速率参数为 $\\lambda_{c}$ 的指数分布。\n- 对于一个被过滤的端口，由于静默丢弃行为，扫描器会观察到一个固定的超时时间 $\\tau_{f}$ 秒。\n\n所有探测都是按顺序执行的，并且不同探测的网络条件是相互独立的。从关于时间顺序组合和独立随机变量期望的第一性原理出发，推导出一个关于总扫描时间期望值 $t$（扫描 $m$ 个端口）的封闭形式解析表达式，该表达式应是 $m$、$k$、$r$、$\\lambda_{o}$、$\\lambda_{c}$ 和 $\\tau_{f}$ 的函数。将您的最终答案以秒为单位表示。不需要进行数值计算；请提供精确的表达式。",
            "solution": "根据期望的线性性质，扫描所有 $m$ 个端口的总期望时间 $t$ 是扫描每个端口的期望时间之和。由于探测是相互独立的，我们可以分别计算每类端口的期望时间贡献，然后将它们相加。\n\n这 $m$ 个端口可以分为三类：\n1.  **$k$ 个开放端口**：探测一个开放端口所需的时间服从速率参数为 $\\lambda_{o}$ 的指数分布。指数分布的期望值为其速率参数的倒数。因此，探测单个开放端口的期望时间是 $1/\\lambda_{o}$。对于所有 $k$ 个开放端口，总的期望时间贡献是 $k \\cdot \\frac{1}{\\lambda_{o}} = \\frac{k}{\\lambda_{o}}$。\n\n2.  **$r$ 个被过滤的端口**：探测一个被过滤的端口所需的时间是一个固定的超时时间 $\\tau_{f}$。一个常数随机变量的期望值就是该常数本身。因此，探测单个被过滤端口的期望时间是 $\\tau_{f}$。对于所有 $r$ 个被过滤端口，总的期望时间贡献是 $r \\cdot \\tau_{f}$。\n\n3.  **$m - k - r$ 个关闭但未过滤的端口**：探测一个关闭但未过滤的端口所需的时间服从速率参数为 $\\lambda_{c}$ 的指数分布。与开放端口的情况类似，探测单个此类端口的期望时间是 $1/\\lambda_{c}$。对于所有 $m - k - r$ 个此类端口，总的期望时间贡献是 $(m - k - r) \\cdot \\frac{1}{\\lambda_{c}} = \\frac{m - k - r}{\\lambda_{c}}$。\n\n将这三类端口的期望时间贡献相加，我们得到总扫描时间 $t$ 的期望值的封闭形式表达式：\n$$t = \\frac{k}{\\lambda_{o}} + r \\tau_{f} + \\frac{m - k - r}{\\lambda_{c}}$$\n为了与答案格式一致，可以重新排列各项：\n$$t = \\frac{k}{\\lambda_{o}} + \\frac{m - k - r}{\\lambda_{c}} + r \\tau_{f}$$",
            "answer": "$$\n\\boxed{\\frac{k}{\\lambda_{o}} + \\frac{m - k - r}{\\lambda_{c}} + r \\tau_{f}}\n$$"
        }
    ]
}