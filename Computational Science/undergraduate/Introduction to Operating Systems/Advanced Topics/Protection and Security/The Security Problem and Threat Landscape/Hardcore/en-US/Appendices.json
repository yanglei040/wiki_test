{
    "hands_on_practices": [
        {
            "introduction": "A secure operating system begins with robust fundamentals, and few are more fundamental than how the system counts and accounts for resources. This exercise explores a classic vulnerability class: integer overflow. By working through a hypothetical scenario involving CPU time accounting, you will see firsthand how the finite limitations of a 32-bit counter can create a security loophole, and then analyze a more robust 64-bit saturating counter as a mitigation strategy. ",
            "id": "3687968",
            "problem": "In an operating system’s resource accounting, suppose the system tracks cumulative Central Processing Unit (CPU) time in microseconds using an unsigned $32$-bit counter for legacy code paths. On each process creation event (for example, a fork), the process performs work that consumes a fixed amount of CPU time equal to $u$ microseconds, and the counter is incremented by this amount. Because the counter is unsigned and $32$ bits wide, it obeys arithmetic modulo $2^{32}$, so that it wraps to zero upon exceeding $2^{32}-1$. An adversary can attempt to exploit wrap-around to evade threshold-based enforcement if the counter is near its maximum.\n\nAs a mitigation, consider a design that uses a $64$-bit monotonic saturating counter that clamps at a configurable alert threshold $\\theta$ and triggers exactly once when the cumulative CPU usage first reaches $\\theta$. Specifically, the $64$-bit counter $S$ starts at $S_0=0$ and updates on each fork by $S_{k+1}=\\min(\\theta, S_k+u)$; the alert fires on the first step $n$ such that $S_n=\\theta$.\n\nAssume the following concrete parameter values:\n- Per-fork CPU usage is $u=123{,}457$ microseconds.\n- The current stored value of the $32$-bit counter is $C_0=c_0=3{,}500{,}000{,}000$ microseconds.\n- The alert threshold for the $64$-bit saturating counter is $\\theta=600{,}000{,}000$ microseconds.\n\nDefine $n_{\\text{wrap}}$ as the smallest nonnegative integer $n$ such that the $32$-bit counter wraps at least once when updated by $n$ forks from $C_0$ under modulo-$2^{32}$ addition. Define $n_{\\text{alert}}$ as the smallest nonnegative integer $n$ such that the $64$-bit saturating counter reaches the alert threshold $\\theta$ when starting from $0$ and applying $n$ updates of size $u$. Compute the single quantity\n$\nD = n_{\\text{wrap}} - n_{\\text{alert}}.\n$\nProvide your answer as an integer number of forks. No rounding is required.",
            "solution": "The problem requires the computation of a quantity $D = n_{\\text{wrap}} - n_{\\text{alert}}$, which is the difference between the number of fork events required to trigger a counter wrap-around in a legacy $32$-bit system and the number of events required to trigger an alert in a mitigated $64$-bit system.\n\nFirst, we analyze the $32$-bit unsigned counter. An unsigned $32$-bit integer counter performs arithmetic modulo $2^{32}$. The maximum value is $2^{32}-1$. The total range corresponds to a numerical value of $2^{32}$, which is $4,294,967,296$.\n\nThe problem defines $n_{\\text{wrap}}$ as the smallest non-negative integer $n$ such that the counter wraps at least once. The initial value is $c_0 = 3,500,000,000$. Each fork event adds $u = 123,457$ microseconds. A wrap-around occurs when the conceptual value meets or exceeds the modulus, $2^{32}$. We must find the smallest integer $n$ that satisfies:\n$$c_0 + n \\cdot u \\ge 2^{32}$$\nRearranging the inequality to solve for $n$:\n$$n \\cdot u \\ge 2^{32} - c_0$$\n$$n \\ge \\frac{2^{32} - c_0}{u}$$\nSince $n$ must be an integer, $n_{\\text{wrap}}$ is the ceiling of the right-hand side.\n$$n_{\\text{wrap}} = \\left\\lceil \\frac{2^{32} - c_0}{u} \\right\\rceil$$\nSubstituting the given values:\n$$n_{\\text{wrap}} = \\left\\lceil \\frac{4,294,967,296 - 3,500,000,000}{123,457} \\right\\rceil$$\n$$n_{\\text{wrap}} = \\left\\lceil \\frac{794,967,296}{123,457} \\right\\rceil$$\n$$\\frac{794,967,296}{123,457} \\approx 6440.003386$$\nThe ceiling of this value is:\n$$n_{\\text{wrap}} = 6441$$\n\nNext, we analyze the $64$-bit saturating counter. It starts at $S_0 = 0$ and increments by $u$ until it reaches the alert threshold $\\theta = 600,000,000$.\nThe quantity $n_{\\text{alert}}$ is the smallest integer $n$ such that the cumulative sum of increments is greater than or equal to $\\theta$.\n$$n \\cdot u \\ge \\theta$$\nSolving for $n$:\n$$n \\ge \\frac{\\theta}{u}$$\nAs before, $n_{\\text{alert}}$ is the ceiling of this value:\n$$n_{\\text{alert}} = \\left\\lceil \\frac{\\theta}{u} \\right\\rceil$$\nSubstituting the given values:\n$$n_{\\text{alert}} = \\left\\lceil \\frac{600,000,000}{123,457} \\right\\rceil$$\n$$\\frac{600,000,000}{123,457} \\approx 4860.103536$$\nThe ceiling of this value is:\n$$n_{\\text{alert}} = 4861$$\n\nFinally, we compute the required quantity $D = n_{\\text{wrap}} - n_{\\text{alert}}$.\n$$D = 6441 - 4861$$\n$$D = 1580$$\nThe result is the difference in the number of forks required to trigger the respective events.",
            "answer": "$$\\boxed{1580}$$"
        },
        {
            "introduction": "Beyond simple arithmetic bugs, many security flaws arise from the interaction between concurrent operations over time. This practice problem delves into the \"Time-Of-Check To Time-Of-Use\" (TOCTTOU) vulnerability, a classic race condition where an attacker can alter a resource after it has been checked by the system but before it is used. You will analyze a proposed token-based mitigation, learning to reason about atomicity and how modern security designs prevent such temporal gaps in authorization. ",
            "id": "3687966",
            "problem": "Consider a multi-user operating system in which a device driver for device $D$ authorizes operations using an Access Control List (ACL). A process $P$ performs the open system call on $D$ at time $t_0$, and later issues Input/Output (I/O) operations at times $t_1, t_2, \\ldots$. An administrator may modify the ACL at any time, including between $t_0$ and a later I/O operation. Time-Of-Check To Time-Of-Use (TOCTTOU) vulnerabilities arise whenever authorization is checked and subsequently used non-atomically in the presence of concurrent changes to shared authorization state.\n\nYou are asked to reason from first principles about a proposed mitigation: when $P$ opens $D$ at time $t_0$, the kernel issues an atomic permission token $T$ bound to the open operation. The token $T$ is associated with the identity of $P$, the target device $D$, and a set of rights $R$ determined by the ACL at $t_0$. For each subsequent I/O operation on $D$, $P$ presents $T$ to the kernel, and the kernel validates $T$ and authorizes the operation accordingly within the same system call that performs the device operation.\n\nSelect all statements that are correct about the security properties and trade-offs of this design in the threat landscape described.\n\nA. If $T$ is unforgeable and validated by the kernel immediately before performing the device operation without relinquishing control to untrusted code, the TOCTTOU window between authorization and use is eliminated for those operations that require $T$.\n\nB. The token approach cannot support revocation without reintroducing TOCTTOU and is therefore strictly inferior to holding the ACL under a lock for the entire duration of each device operation.\n\nC. Incorporating a per-device revocation version counter $v$ that the kernel compares against the version embedded in $T$ at each operation supports immediate revocation while keeping the check and use within a single atomic kernel path, at the cost of an additional check per operation.\n\nD. Because $T$ is bound at open time, any subsequent ACL changes that grant additional rights to $P$ are automatically reflected when $P$ uses $T$, which preserves the Principle of Least Privilege.\n\nE. If $T$ is stored in user space and supplied with each call, then without a kernel-enforced integrity mechanism that makes $T$ unforgeable, a malicious process could modify $T$ to escalate privileges; therefore, unforgeability and integrity of $T$ are necessary for the design to be secure.\n\nSelect all that apply.",
            "solution": "The problem describes a shift from a direct ACL-check model to a token-based (capability-based) authorization model. At `open` time ($t_0$), the process's rights $R$ are evaluated and \"frozen\" into a token $T$. For subsequent operations, the check (validating $T$) and the use (performing the I/O) are done atomically within a single kernel-mode transition. We analyze each statement based on these principles.\n\n**A. If $T$ is unforgeable and validated by the kernel immediately before performing the device operation without relinquishing control to untrusted code, the TOCTTOU window between authorization and use is eliminated for those operations that require $T$.**\nThis statement describes the core benefit of the design. A TOCTTOU vulnerability exists in the time between a check and a use. By performing the validation and the operation \"within the same system call,\" the kernel executes them atomically from a user-space perspective, eliminating the race condition. This is a correct description of an atomic check-then-use sequence. **This statement is correct.**\n\n**B. The token approach cannot support revocation without reintroducing TOCTTOU and is therefore strictly inferior to holding the ACL under a lock for the entire duration of each device operation.**\nThis statement is incorrect. Revocation can be supported atomically, for instance by checking a version number (as in option C) or a revocation list within the same kernel operation. Furthermore, the token model is generally more performant than holding a lock for a long I/O operation, so it is not \"strictly inferior.\" **This statement is incorrect.**\n\n**C. Incorporating a per-device revocation version counter $v$ that the kernel compares against the version embedded in $T$ at each operation supports immediate revocation while keeping the check and use within a single atomic kernel path, at the cost of an additional check per operation.**\nThis statement accurately describes a valid mechanism for revocation. If the kernel increments a version counter on ACL change, it can reject tokens with stale versions. This check can be part of the same atomic system call that validates the token and performs the I/O, thus preventing TOCTTOU. **This statement is correct.**\n\n**D. Because $T$ is bound at open time, any subsequent ACL changes that grant additional rights to $P$ are automatically reflected when $P$ uses $T$, which preserves the Principle of Least Privilege.**\nThis statement is factually incorrect. Rights are determined at time $t_0$ and are fixed in the token. Subsequent changes to the ACL are *not* automatically reflected. This behavior—not automatically escalating privileges—is what helps enforce the Principle of Least Privilege for the token's lifetime. **This statement is incorrect.**\n\n**E. If $T$ is stored in user space and supplied with each call, then without a kernel-enforced integrity mechanism that makes $T$ unforgeable, a malicious process could modify $T$ to escalate privileges; therefore, unforgeability and integrity of $T$ are necessary for the design to be secure.**\nIf the token is held in user space, a malicious process could alter it to grant itself more permissions. To prevent this, the token must be tamper-proof, typically via a cryptographic signature or MAC using a kernel-only key. Unforgeability is a necessary precondition for the security of this design. **This statement is correct.**",
            "answer": "$$\\boxed{ACE}$$"
        },
        {
            "introduction": "An operating system's security is not just about the kernel; it extends to the administrative policies and tools that govern user privileges. This final exercise shifts focus to the user-space layer, examining how misconfigured `sudo` rules can inadvertently grant full root access, violating the principle of least privilege. By applying a formal model to analyze common but dangerous command patterns, you will develop the critical skill of identifying and preventing privilege escalation pathways in real-world system administration. ",
            "id": "3687915",
            "problem": "An advanced user in an Operating System (OS) is granted selective elevated privileges via the `sudo` policy in a system that enforces command-level access control using an argument-matching pattern language. Consider the following threat assessment task, grounded in the principle of least privilege and the definition of trust boundaries: a user’s effective privilege set $P$ is determined by which commands they can invoke as the superuser and how those commands can be composed. Root-level capability, denoted $R$, represents the superset of actions a superuser can perform. By first principles, if a permitted command enables arbitrary code execution or arbitrary write to trusted system state, then such permission crosses the trust boundary and yields $P \\approx R$ (root-equivalent), because the user can construct arbitrary workflows that realize any root capability.\n\nA static analyzer is proposed for `sudo` rules with wildcards to detect patterns equivalent to full root and to compute a privilege dilution score $D$. The analyzer uses the following foundational model:\n- Privilege is modeled by capability categories $C = \\{c_1, c_2, c_3, c_4, c_5\\}$, where $c_1$ is arbitrary code execution, $c_2$ is arbitrary write to system files, $c_3$ is arbitrary read of system files, $c_4$ is service control (e.g., starting/stopping services), and $c_5$ is system configuration changes (e.g., package or network configuration). Full root has all categories, so the superuser capability set corresponds to $R$ that covers all of $C$. The analyzer defines the privilege dilution score as $D = \\frac{|C_{\\text{reachable}}|}{|C|}$, where $C_{\\text{reachable}} \\subseteq C$ is the set of categories the user can reach via permitted commands. Under the closure principle, if $c_1 \\in C_{\\text{reachable}}$, then composing arbitrary code execution yields all categories in $C$, and thus $D = 1$.\n- The analyzer flags as root-equivalent any rule that allows the user to trigger arbitrary code execution, including but not limited to shells, interpreters, editors with shell escape, or utilities whose options embed command execution.\n\nSuppose the `sudo` policy encodes rules as pairs `(p, A)`, where `p` is an absolute command path and `A` is a pattern over the argument vector, with the wildcard symbol `*` matching any single argument token (including options, flags, and values):\n\n- Rule $r_1$: `p = /usr/bin/find`, `A = ['/var', '*', '-exec', '/bin/sh', '-c', '*']`. This permits running `find` over `/var` with arbitrary predicates and then executing `/bin/sh -c …` with arbitrary command content.\n- Rule $r_2$: `p = /usr/bin/vim`, `A = ['/etc/*']`. This permits running `vim` as root to edit any file under `/etc` with interactive features intact.\n- Rule $r_3$: `p = /bin/tar`, `A = ['*']`. This permits running `tar` with any arguments.\n- Rule $r_4$: `p = /usr/bin/systemctl`, `A = ['restart', 'myservice']`. This permits restarting a single named service.\n\nAssume a conventional environment in which `/usr/bin/vim` allows shell escape (e.g., using `:!`), `/bin/tar` supports an option to execute a command at checkpoint (e.g., `--checkpoint-action=exec=…`), and `/usr/bin/find` with `-exec /bin/sh -c …` executes arbitrary code. Using the analyzer’s model above and reasoning strictly from the principle of least privilege and trust boundary semantics, select the correct assessment of which rules are equivalent to full root and the resulting $D$ for the user.\n\nA. The analyzer flags $r_1$, $r_2$, and $r_3$ as root-equivalent; $D = 1$.\n\nB. The analyzer flags only $r_2$ as root-equivalent; $D = \\frac{3}{5}$.\n\nC. The analyzer flags no rules as root-equivalent; $D = \\frac{1}{5}$.\n\nD. The analyzer flags $r_1$ and $r_2$ as root-equivalent but not $r_3$; $D = \\frac{4}{5}$.",
            "solution": "The task is to analyze four `sudo` rules using the provided model to determine which are root-equivalent and to compute the privilege dilution score $D$. A rule is root-equivalent if it grants capability $c_1$ (arbitrary code execution). If $c_1$ is reachable, the closure principle states that all other capabilities become reachable, and $D=1$.\n\n1.  **Rule $r_1$ (`find ... -exec /bin/sh -c *`):** The `-exec` action with `/bin/sh -c` and a final `*` wildcard allows the user to execute any arbitrary shell command as root. This directly grants capability $c_1$. Therefore, rule $r_1$ is **root-equivalent**.\n\n2.  **Rule $r_2$ (`vim /etc/*`):** The problem states that `vim` allows shell escapes (e.g., `:!command`). By running `vim` as root, a user can execute an arbitrary command, such as `:!/bin/sh`, to get a root shell. This grants capability $c_1$. Therefore, rule $r_2$ is **root-equivalent**.\n\n3.  **Rule $r_3$ (`tar *`):** The user can supply any argument to `tar`. The problem states `tar` has an option like `--checkpoint-action=exec=...` which executes a command. A user can leverage this to run an arbitrary command as root. This grants capability $c_1$. Therefore, rule $r_3$ is **root-equivalent**.\n\n4.  **Rule $r_4$ (`systemctl restart myservice`):** This rule is highly restricted. It allows one specific action (`restart`) on one specific service (`myservice`). It does not provide a mechanism for arbitrary code execution. It grants capability $c_4$ (service control) but is **not root-equivalent**.\n\n**Conclusion:**\nThe analyzer flags rules $r_1$, $r_2$, and $r_3$ as root-equivalent because they all provide capability $c_1$.\nSince capability $c_1$ is reachable, the closure principle applies: \"if $c_1 \\in C_{\\text{reachable}}$, then composing arbitrary code execution yields all categories in $C$, and thus $D=1$.\"\nThe user can achieve arbitrary code execution, which makes all capabilities $\\{c_1, c_2, c_3, c_4, c_5\\}$ reachable.\nTherefore, $|C_{\\text{reachable}}| = 5$, and the score is $D = \\frac{5}{5} = 1$.\n\nThis matches option A.",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}