{
    "hands_on_practices": [
        {
            "introduction": "The concept of a measured boot chain can seem abstract. This first practice makes it concrete by modeling a Platform Configuration Register (PCR) as a simple state machine. By using a simplified \"toy\" hash function, we can manually trace the step-by-step process of extending measurements and see how the final state depends on every input in the sequence . This hands-on calculation will help you build a foundational intuition for the deterministic, one-way nature of the cryptographic log created during a measured boot.",
            "id": "3679559",
            "problem": "You are analyzing a measured boot sequence in a computer system that uses a Trusted Platform Module (TPM) and Platform Configuration Registers (PCRs) to record the integrity of the Trusted Computing Base (TCB). In measured boot, each component measurement is extended into a PCR using the recurrence $S' = H(S \\Vert d)$, where $S$ is the current PCR state, $d$ is the next measurement value, and $H$ is a hash function. For the purpose of this exercise, replace the real cryptographic hash with the following toy function to enable exact calculation:\n$$H(u \\Vert v) = (11u + 7v + 13) \\bmod 101.$$\nAssume a single PCR is modeled as a state machine with initial state $S_0 = 0$. A boot policy measures and extends exactly $3$ TCB components in the fixed order: bootloader, kernel, then initial ramdisk. The manifest lists the bootloader measurement as $m_b = 23$, the kernel measurement as $m_k = 57$, and the initial ramdisk measurement as an unknown value $x$. After boot, the TPM reports the final PCR state as $S_f = 88$.\n\nUsing only the measured boot recurrence $S' = H(S \\Vert d)$ and the toy hash $H$ above, determine the unique value of $x \\in \\{0,1,\\ldots,100\\}$ such that a sequence of exactly $3$ extends in the given order produces $S_f$ from $S_0$.\n\nProvide your answer as an integer modulo $101$. No rounding is required, and no units should be included in the final answer.",
            "solution": "The user wants me to find the value of an unknown measurement, $x$, in a simulated measured boot sequence.\n\n### Step 1: Extract Givens\n- The measured boot recurrence relation is $S' = H(S \\Vert d)$, where $S$ is the current state and $d$ is the measurement.\n- The toy hash function is defined as $H(u \\Vert v) = (11u + 7v + 13) \\bmod 101$.\n- The initial state of the Platform Configuration Register (PCR) is $S_0 = 0$.\n- There are exactly $3$ measurements in a fixed order.\n- The first measurement is the bootloader, $m_b = 23$.\n- The second measurement is the kernel, $m_k = 57$.\n- The third measurement is the initial ramdisk, with an unknown value $x$.\n- The domain for $x$ is $\\{0, 1, \\ldots, 100\\}$.\n- The final PCR state after the $3$ measurements is $S_f = 88$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded as it uses a simplified but mathematically well-defined model to illustrate the real-world concept of measured boot, a core topic in operating systems security. The use of a \"toy\" function is an established pedagogical tool. The problem is well-posed, providing all necessary information ($S_0$, the recurrence, the function $H$, two of the three inputs, and the final output $S_f$) to uniquely determine the third input, $x$. The calculations involve modular arithmetic, which is a standard mathematical tool. The problem is objective, with no ambiguous or subjective terms. It does not violate any of the invalidity criteria. All provided values are integers, and the operations are closed over the integers modulo $101$. Therefore, the problem is valid.\n\n### Step 3: Proceed to Solution\nThe problem requires us to determine the value of the third measurement, $x$, by sequentially applying the measurement extension process. The process consists of three steps, starting from the initial state $S_0$.\n\nLet $S_0$, $S_1$, $S_2$, and $S_3$ be the states of the PCR. We are given $S_0 = 0$. The final state is $S_3 = S_f = 88$.\n\n**First Extension (Bootloader):**\nThe first measurement is the bootloader measurement, $d_1 = m_b = 23$. The state transitions from $S_0$ to $S_1$.\n$$S_1 = H(S_0 \\Vert m_b)$$\nUsing the given values, $S_0 = 0$ and $m_b = 23$:\n$$S_1 = H(0 \\Vert 23) = (11 \\cdot 0 + 7 \\cdot 23 + 13) \\bmod 101$$\n$$S_1 = (0 + 161 + 13) \\bmod 101$$\n$$S_1 = 174 \\bmod 101$$\nTo find the remainder, we perform the division: $174 = 1 \\cdot 101 + 73$.\n$$S_1 = 73$$\n\n**Second Extension (Kernel):**\nThe second measurement is the kernel measurement, $d_2 = m_k = 57$. The state transitions from $S_1$ to $S_2$.\n$$S_2 = H(S_1 \\Vert m_k)$$\nUsing the calculated value $S_1 = 73$ and the given $m_k = 57$:\n$$S_2 = H(73 \\Vert 57) = (11 \\cdot 73 + 7 \\cdot 57 + 13) \\bmod 101$$\nFirst, calculate the products:\n$$11 \\cdot 73 = 803$$\n$$7 \\cdot 57 = 399$$\nNow substitute these back into the expression:\n$$S_2 = (803 + 399 + 13) \\bmod 101$$\n$$S_2 = 1215 \\bmod 101$$\nTo find the remainder, we perform the division: $1215 = 12 \\cdot 101 + 3$.\n$$S_2 = 3$$\n\n**Third Extension (Initial Ramdisk):**\nThe third and final measurement is the initial ramdisk value, $d_3 = x$. The state transitions from $S_2$ to $S_3$. We are given that the final state is $S_3 = S_f = 88$.\n$$S_3 = H(S_2 \\Vert x)$$\nUsing the calculated value $S_2 = 3$ and the final state $S_3 = 88$:\n$$88 = H(3 \\Vert x) = (11 \\cdot 3 + 7 \\cdot x + 13) \\bmod 101$$\nThis gives us a linear congruence in $x$:\n$$88 \\equiv (33 + 7x + 13) \\pmod{101}$$\n$$88 \\equiv (46 + 7x) \\pmod{101}$$\nTo solve for $x$, we first isolate the term containing $x$:\n$$88 - 46 \\equiv 7x \\pmod{101}$$\n$$42 \\equiv 7x \\pmod{101}$$\nThe modulus, $101$, is a prime number. Since $\\gcd(7, 101) = 1$, a unique multiplicative inverse for $7$ modulo $101$ exists, and we can \"divide\" both sides of the congruence by $7$. In this case, the division is exact in the integers.\n$$x \\equiv \\frac{42}{7} \\pmod{101}$$\n$$x \\equiv 6 \\pmod{101}$$\nThe problem states that $x \\in \\{0, 1, \\ldots, 100\\}$. The only integer in this range that is congruent to $6$ modulo $101$ is $6$.\nThus, the unique value of the initial ramdisk measurement is $x=6$.",
            "answer": "$$\n\\boxed{6}\n$$"
        },
        {
            "introduction": "Building on the state machine model, this exercise explores a critical security property of measured boot: its sensitivity to order. While real-world implementations use secure cryptographic hashes like SHA-256, the principle that the final PCR value acts as a fingerprint not only of the components loaded but also of the precise sequence in which they were loaded remains the same . By comparing an expected PCR value with a remotely attested one, you will see how a verifier can detect not just unauthorized code but also unexpected changes in the boot process itself.",
            "id": "3679592",
            "problem": "A system implements measured boot using a Trusted Platform Module (TPM). The Platform Configuration Register (PCR) extend operation is defined by the fundamental rule: starting from the all-zero value $PCR^{(0)} = 0^{256}$, each new measurement digest $d$ is incorporated by the update $PCR \\leftarrow \\mathcal{H}(PCR \\,\\|\\, d)$, where $\\mathcal{H}$ is a collision-resistant cryptographic hash function (e.g., Secure Hash Algorithm 256-bit (SHA-256)), and $\\|$ denotes concatenation. The Trusted Computing Base (TCB) components measured at boot are three software components $A$, $B$, and $C$ with the manifest listing them in the order $(A,B,C)$ and the corresponding digests:\n- $d_{A} = \\texttt{a3c1d2e4f50617293b4c5d6e7f8091a2b3c4d5e6f718293a4b5c6d7e8f9012ab}$,\n- $d_{B} = \\texttt{0f1e2d3c4b5a69788796a5b4c3d2e1f0ffeeddccbbaa99887766554433221100}$,\n- $d_{C} = \\texttt{ffffffff00000000aaaaaaaa55555555cccccccc33333333dddddddd22222222}$.\n\nFor analysis, you are provided with precomputed hash-chain outputs for the first and second extends in the two relevant partial orders and the third extend result in two candidate full orders:\n- $\\mathcal{H}(0^{256} \\,\\|\\, d_{A}) = \\texttt{1111111122222222333333334444444455555555666666667777777788888888}$,\n- $\\mathcal{H}(0^{256} \\,\\|\\, d_{B}) = \\texttt{0123456789abcdeffedcba98765432100123456789abcdeffedcba9876543210}$,\n- $\\mathcal{H}(0^{256} \\,\\|\\, d_{C}) = \\texttt{abcdef0123456780abcdef0123456780abcdef0123456780abcdef0123456780}$,\n- $\\mathcal{H}(\\mathcal{H}(0^{256} \\,\\|\\, d_{A}) \\,\\|\\, d_{B}) = \\texttt{2222222233333333444444445555555566666666777777778888888899999999}$,\n- $\\mathcal{H}(\\mathcal{H}(0^{256} \\,\\|\\, d_{B}) \\,\\|\\, d_{A}) = \\texttt{33333333444444445555555566666666777777778888888899999999aaaaaaaa}$.\n\nContinuing those chains for the third measurement produces:\n- $\\mathcal{H}(\\mathcal{H}(\\mathcal{H}(0^{256} \\,\\|\\, d_{A}) \\,\\|\\, d_{B}) \\,\\|\\, d_{C}) = \\texttt{3adf1c0b9e2f47a1c4d58376029b1e55f0a4c2d1b6e7f8930abcdeffedcba012}$,\n- $\\mathcal{H}(\\mathcal{H}(\\mathcal{H}(0^{256} \\,\\|\\, d_{B}) \\,\\|\\, d_{A}) \\,\\|\\, d_{C}) = \\texttt{3bcf1d0b9e2f47a1c4d58376029b1e55f0a4c2d1b6e7f8930abcdeffedcba092}$.\n\nA TPM quote reports the attested value of $PCR_{0}$ as\n$Q = \\texttt{3bcf1d0b9e2f47a1c4d58376029b1e55f0a4c2d1b6e7f8930abcdeffedcba092}$.\n\nTasks:\n1. Using only the extend rule $PCR \\leftarrow \\mathcal{H}(PCR \\,\\|\\, d)$ and the provided precomputations, reconstruct the expected sequence $\\{PCR_{0}^{(1)}, PCR_{0}^{(2)}, PCR_{0}^{(3)}\\}$ if the manifest order $(A,B,C)$ were followed, and write the final expected $PCR_{0}^{(3)}$ as a $256$-bit hexadecimal string.\n2. From first principles of the extend operation and the given data, determine whether a discrepancy between the expected final value and the quoted $Q$ can be explained purely by a different component ordering. Identify one ordering consistent with $Q$ using the provided precomputations, and explain why ordering matters in measured boot.\n3. Quantify the discrepancy by computing the Hamming distance $d_{H}$ between the expected final $PCR_{0}^{(3)}$ (for manifest order $(A,B,C)$) and the quoted $Q$. The Hamming distance $d_{H}$ is the number of bit positions at which the two $256$-bit values differ. Provide only the value of $d_{H}$ as your final numeric answer. No rounding is required.",
            "solution": "The problem requires a three-part analysis of a measured boot process involving a Trusted Platform Module (TPM) and its Platform Configuration Registers (PCRs). The core of the process is the PCR extend operation, defined as $PCR \\leftarrow \\mathcal{H}(PCR \\,\\|\\, d)$, where $\\mathcal{H}$ is a cryptographic hash function, $PCR$ is the current register value, $d$ is the new measurement digest, and $\\|$ denotes concatenation. We are given the initial state $PCR^{(0)} = 0^{256}$, three component digests $d_A$, $d_B$, $d_C$, and several precomputed hash values for different measurement sequences.\n\n**Task 1: Reconstruction of the Expected PCR Sequence**\n\nThe first task is to reconstruct the sequence of PCR values, $\\{PCR_{0}^{(1)}, PCR_{0}^{(2)}, PCR_{0}^{(3)}\\}$, that would result from measuring the components in the manifest order $(A, B, C)$. We start with $PCR_{0}^{(0)} = 0^{256}$ and apply the extend rule sequentially using the provided precomputed hash values.\n\n1.  **First measurement (Component A):** The first PCR update measures component $A$.\n    $$PCR_{0}^{(1)} = \\mathcal{H}(PCR_{0}^{(0)} \\,\\|\\, d_{A}) = \\mathcal{H}(0^{256} \\,\\|\\, d_{A})$$\n    The value is provided in the problem statement:\n    $$PCR_{0}^{(1)} = \\texttt{1111111122222222333333334444444455555555666666667777777788888888}$$\n\n2.  **Second measurement (Component B):** The second update extends the new $PCR_{0}^{(1)}$ with the digest of component $B$.\n    $$PCR_{0}^{(2)} = \\mathcal{H}(PCR_{0}^{(1)} \\,\\|\\, d_{B}) = \\mathcal{H}(\\mathcal{H}(0^{256} \\,\\|\\, d_{A}) \\,\\|\\, d_{B})$$\n    This value is also provided:\n    $$PCR_{0}^{(2)} = \\texttt{2222222233333333444444445555555566666666777777778888888899999999}$$\n\n3.  **Third measurement (Component C):** The final update extends $PCR_{0}^{(2)}$ with the digest of component $C$. This gives the final expected PCR value.\n    $$PCR_{0}^{(3)} = \\mathcal{H}(PCR_{0}^{(2)} \\,\\|\\, d_{C}) = \\mathcal{H}(\\mathcal{H}(\\mathcal{H}(0^{256} \\,\\|\\, d_{A}) \\,\\|\\, d_{B}) \\,\\|\\, d_{C})$$\n    The problem provides this final value for the sequence $(A, B, C)$:\n    $$PCR_{0}^{(3)} = \\texttt{3adf1c0b9e2f47a1c4d58376029b1e55f0a4c2d1b6e7f8930abcdeffedcba012}$$\nThis is the expected final PCR value if the boot process strictly followed the manifest order $(A, B, C)$.\n\n**Task 2: Analysis of Discrepancy and Ordering**\n\nThe second task is to analyze the discrepancy between the expected final PCR value calculated above and the quoted value $Q$, where $Q$ is given as:\n$$Q = \\texttt{3bcf1d0b9e2f47a1c4d58376029b1e55f0a4c2d1b6e7f8930abcdeffedcba092}$$\nComparing this with the expected value $PCR_{0}^{(3)}$ for the order $(A, B, C)$, we see they are not identical.\n$PCR_{0}^{(3)} = \\texttt{3adf...012}$\n$Q = \\texttt{3bcf...092}$\nA discrepancy exists. The problem asks if this can be explained by a different component ordering. The provided data includes the final PCR value for the measurement order $(B, A, C)$:\n$$\\mathcal{H}(\\mathcal{H}(\\mathcal{H}(0^{256} \\,\\|\\, d_{B}) \\,\\|\\, d_{A}) \\,\\|\\, d_{C}) = \\texttt{3bcf1d0b9e2f47a1c4d58376029b1e55f0a4c2d1b6e7f8930abcdeffedcba092}$$\nThis value exactly matches the quoted value $Q$. Therefore, the discrepancy can be explained by the system having measured the components in the order $(B, A, C)$ instead of the specified manifest order $(A, B, C)$.\n\nThe reason ordering matters is fundamental to the security guarantee of measured boot. The PCR extend operation, $PCR_{new} = \\mathcal{H}(PCR_{old} \\,\\|\\, d)$, is a cryptographic chain. At each step, the entire state of the previous PCR value is used as part of the input to the hash function for the next state. Cryptographic hash functions are deterministic but non-commutative with respect to their inputs when concatenated. That is, for two distinct inputs $x$ and $y$, it is overwhelmingly likely that $\\mathcal{H}(x \\,\\|\\, y) \\neq \\mathcal{H}(y \\,\\|\\, x)$. Consequently, the final PCR value is a unique cryptographic summary not only of the components that were measured but also of the precise sequence in which they were measured. A verifier, comparing the final PCR quote against a value they compute based on the manifest, can detect any deviation in the boot process, including both the substitution of a component and a change in the boot order. This property is what allows the PCR to serve as an immutable, order-sensitive log of the boot process.\n\n**Task 3: Quantification of Discrepancy**\n\nThe final task is to quantify the discrepancy by computing the Hamming distance, $d_H$, between the expected final PCR value (for order $(A,B,C)$) and the quoted value $Q$. The Hamming distance is the number of bit positions at which the two binary strings differ.\n\nThe two $256$-bit values to be compared are:\n- Expected, $E = \\texttt{3adf1c0b9e2f47a1c4d58376029b1e55f0a4c2d1b6e7f8930abcdeffedcba012}$\n- Quoted, $Q = \\texttt{3bcf1d0b9e2f47a1c4d58376029b1e55f0a4c2d1b6e7f8930abcdeffedcba092}$\n\nWe compare these strings character by character (each character representing a $4$-bit nibble) and sum the Hamming distances for the nibbles that differ.\n\n- Position $2$ (nibble $2$): $E$ has `a`, $Q$ has `b`.\n  - `a` (hex) = $1010_2$\n  - `b` (hex) = $1011_2$\n  - Bitwise XOR: $1010_2 \\oplus 1011_2 = 0001_2$. The number of set bits (population count) is $1$. Distance = $1$.\n\n- Position $3$ (nibble $3$): $E$ has `d`, $Q$ has `c`.\n  - `d` (hex) = $1101_2$\n  - `c` (hex) = $1100_2$\n  - Bitwise XOR: $1101_2 \\oplus 1100_2 = 0001_2$. Population count is $1$. Distance = $1$.\n\n- Position $6$ (nibble $6$): $E$ has `c`, $Q$ has `d`.\n  - `c` (hex) = $1100_2$\n  - `d` (hex) = $1101_2$\n  - Bitwise XOR: $1100_2 \\oplus 1101_2 = 0001_2$. Population count is $1$. Distance = $1$.\n\n- Position $63$ (nibble $63$): $E$ has `1`, $Q$ has `9`.\n  - `1` (hex) = $0001_2$\n  - `9` (hex) = $1001_2$\n  - Bitwise XOR: $0001_2 \\oplus 1001_2 = 1000_2$. Population count is $1$. Distance = $1$.\n\nAll other hexadecimal characters at positions $1$, $4$, $5$, $7-62$, and $64$ are identical. The total Hamming distance is the sum of the distances at the differing positions.\n\n$$d_H(E, Q) = 1 + 1 + 1 + 1 = 4$$\n\nThe total Hamming distance between the expected and quoted PCR values is $4$.",
            "answer": "$$\n\\boxed{4}\n$$"
        },
        {
            "introduction": "Security mechanisms often come with a performance cost, and measured boot is no exception. This final practice moves from cryptographic principles to the practical systems engineering challenge of performance overhead. You will develop a simple analytical model to estimate the time added to the boot process by hashing components and recording them to the Trusted Platform Module (TPM) . This exercise will give you insight into identifying system bottlenecks—whether the process is limited by storage I/O or CPU speed—and evaluating the effectiveness of parallelization.",
            "id": "3679607",
            "problem": "An operating system implementing measured boot records the cryptographic hash of each component in the Trusted Computing Base (TCB) into a Trusted Platform Module (TPM) Platform Configuration Register during boot. In contrast to secure boot, which enforces signature verification at load time, measured boot focuses on recording what was loaded. Assume the following minimal, first-principles model for boot-time cost consistent with standard definitions:\n\n- Hashing uses a cryptographic hash function whose computation time scales linearly with the input size.\n- Storage input/output (I/O) delivers bytes at a fixed sustained rate when reading the components from non-volatile storage.\n- Hash computation may be performed on a single core or across multiple cores, and components are independent so hashing can be parallelized across components subject to available cores.\n- TPM extends (writing a hash to a register) introduces a fixed, per-component latency and is serialized.\n- When hashing and reading are both active, the two-stage pipeline behaves as a throughput-limited system where the end-to-end rate is limited by the slowest stage.\n\nConsider measuring $n$ components, each independently hashed and then extended to the TPM. Let $n = 30$. Assume the expected size of each component is $\\mu = 16$ MiB, so the expected total size is the large-$n$ limit $S_{\\text{tot}} = n \\mu$. The single-core hash throughput is $h = 600$ MiB/s per core, the storage I/O throughput is $B = 2000$ MiB/s, and the per-component TPM extend latency is $o = 0.002$ s. In the parallel case, hashing uses $c = 4$ cores. Use seconds for time.\n\nTasks:\n1. Using only the fundamental assumptions above, derive an analytical expression for the total boot-time overhead due solely to measured boot hashing and TPM extends for $n$ components, both in the sequential case (single core hashing) and the parallel case (hashing across $c$ cores). Your expressions must be in terms of $n$, $S_{\\text{tot}}$, $B$, $h$, $c$, and $o$ and must reflect the throughput-limited nature of the read–hash pipeline and the serialized per-component TPM extends.\n2. Instantiate your expressions for the given parameters and compute the sequential and parallel total overheads in seconds.\n3. Propose a measurable experiment to validate your model on real hardware, and define a single scalar metric that would be reported to compare sequential versus parallel hashing. Then, compute that metric for the given parameters.\n\nRound your final reported metric to four significant figures. Express the metric as a dimensionless decimal (no unit).",
            "solution": "The problem statement has been validated and is determined to be sound. It is scientifically grounded in the principles of computer system performance modeling, well-posed with sufficient and consistent data, and objective in its language. We may therefore proceed with a solution.\n\nThe total overhead of the measured boot process, denoted as $T$, can be modeled as the sum of the time required for the read-and-hash pipeline and the time required for the serialized Trusted Platform Module (TPM) operations.\n\nLet $T_{\\text{pipeline}}$ be the time for the read-hash pipeline and $T_{\\text{tpm}}$ be the time for the TPM extensions. The total time is:\n$$T = T_{\\text{pipeline}} + T_{\\text{tpm}}$$\n\nThe TPM extend operations are serialized. For $n$ components, with each operation taking a fixed latency $o$, the total TPM time is:\n$$T_{\\text{tpm}} = n \\cdot o$$\n\nThe read-and-hash process is described as a two-stage pipeline where work can be done concurrently. The total time for processing a batch of data of size $S_{\\text{tot}}$ through such a pipeline is determined by the bottleneck, which is the stage with the lowest throughput. This time is equivalent to the maximum of the times each stage would take to process the entire workload independently. Let $T_{\\text{read}}$ be the time to read all components from storage and $T_{\\text{hash}}$ be the time to hash all components.\n\nThe time to read the total data size $S_{\\text{tot}}$ from storage with I/O throughput $B$ is:\n$$T_{\\text{read}} = \\frac{S_{\\text{tot}}}{B}$$\n\nThe time to hash the total data size $S_{\\text{tot}}$ depends on the available computational throughput. The total time for the pipeline is thus:\n$$T_{\\text{pipeline}} = \\max(T_{\\text{read}}, T_{\\text{hash}})$$\n\nWe now analyze the sequential and parallel cases as required.\n\n**Task 1: Analytical Expressions for Total Overhead**\n\n**Sequential Case (Single Core):**\nIn the sequential case, hashing is performed on a single core. The hash throughput is $h$. The time taken to hash the total data size $S_{\\text{tot}}$ is:\n$$T_{\\text{hash,seq}} = \\frac{S_{\\text{tot}}}{h}$$\nThe pipeline time is the maximum of the read time and the hash time:\n$$T_{\\text{pipeline,seq}} = \\max\\left(\\frac{S_{\\text{tot}}}{B}, \\frac{S_{\\text{tot}}}{h}\\right)$$\nThe total overhead for the sequential measured boot process, $T_{\\text{seq}}$, is the sum of the pipeline time and the serialized TPM time:\n$$T_{\\text{seq}} = \\max\\left(\\frac{S_{\\text{tot}}}{B}, \\frac{S_{\\text{tot}}}{h}\\right) + n \\cdot o$$\n\n**Parallel Case ($c$ Cores):**\nIn the parallel case, hashing is performed across $c$ cores. Assuming the hashing of components is perfectly parallelizable, the total hash throughput is $c \\cdot h$. The time taken to hash the total data size $S_{\\text{tot}}$ is:\n$$T_{\\text{hash,par}} = \\frac{S_{\\text{tot}}}{c \\cdot h}$$\nThe pipeline time is again the maximum of the read time and this new parallel hash time:\n$$T_{\\text{pipeline,par}} = \\max\\left(\\frac{S_{\\text{tot}}}{B}, \\frac{S_{\\text{tot}}}{c \\cdot h}\\right)$$\nThe total overhead for the parallel measured boot process, $T_{\\text{par}}$, is:\n$$T_{\\text{par}} = \\max\\left(\\frac{S_{\\text{tot}}}{B}, \\frac{S_{\\text{tot}}}{c \\cdot h}\\right) + n \\cdot o$$\n\nThese are the required analytical expressions.\n\n**Task 2: Numerical Computation of Overheads**\n\nFirst, we calculate the total data size $S_{\\text{tot}}$ using the given parameters:\n$n = 30$ components\n$\\mu = 16$ MiB/component\n$$S_{\\text{tot}} = n \\cdot \\mu = 30 \\cdot 16 \\; \\text{MiB} = 480 \\; \\text{MiB}$$\n\nThe other parameters are:\n$B = 2000$ MiB/s\n$h = 600$ MiB/s\n$o = 0.002$ s\n$c = 4$\n\nNow, we compute the time components:\nTime to read all data:\n$$T_{\\text{read}} = \\frac{S_{\\text{tot}}}{B} = \\frac{480 \\; \\text{MiB}}{2000 \\; \\text{MiB/s}} = 0.24 \\; \\text{s}$$\nTime for all TPM extends:\n$$T_{\\text{tpm}} = n \\cdot o = 30 \\cdot 0.002 \\; \\text{s} = 0.06 \\; \\text{s}$$\n\nFor the **sequential case**:\nTime to hash all data on a single core:\n$$T_{\\text{hash,seq}} = \\frac{S_{\\text{tot}}}{h} = \\frac{480 \\; \\text{MiB}}{600 \\; \\text{MiB/s}} = 0.80 \\; \\text{s}$$\nTotal sequential overhead:\n$$T_{\\text{seq}} = \\max(T_{\\text{read}}, T_{\\text{hash,seq}}) + T_{\\text{tpm}} = \\max(0.24 \\; \\text{s}, 0.80 \\; \\text{s}) + 0.06 \\; \\text{s} = 0.80 \\; \\text{s} + 0.06 \\; \\text{s} = 0.86 \\; \\text{s}$$\nIn this case, the process is compute-bound, as hashing is slower than reading from storage.\n\nFor the **parallel case**:\nTime to hash all data on $c=4$ cores:\n$$T_{\\text{hash,par}} = \\frac{S_{\\text{tot}}}{c \\cdot h} = \\frac{480 \\; \\text{MiB}}{4 \\cdot 600 \\; \\text{MiB/s}} = \\frac{480 \\; \\text{MiB}}{2400 \\; \\text{MiB/s}} = 0.20 \\; \\text{s}$$\nTotal parallel overhead:\n$$T_{\\text{par}} = \\max(T_{\\text{read}}, T_{\\text{hash,par}}) + T_{\\text{tpm}} = \\max(0.24 \\; \\text{s}, 0.20 \\; \\text{s}) + 0.06 \\; \\text{s} = 0.24 \\; \\text{s} + 0.06 \\; \\text{s} = 0.30 \\; \\text{s}$$\nIn this case, with parallel hashing, the process becomes I/O-bound, as reading from storage is now the slower stage in the pipeline.\n\n**Task 3: Experimental Validation and Metric**\n\n**Experimental Proposal:**\nTo validate the model, one would conduct a controlled experiment on a physical machine equipped with a TPM, a multi-core processor, and a storage device whose performance characteristics are known or can be benchmarked. The experiment would proceed as follows:\n1.  **Preparation**: Create a workload of $n=30$ files on the storage device, each with a size of $\\mu=16$ MiB. The I/O throughput $B$ of the storage device and the single-core hashing throughput $h$ for a specific algorithm (e.g., SHA-256) should be measured independently as baseline values.\n2.  **Instrumentation**: Develop a small boot-time or user-space application that instruments the measured boot sequence. This application must use high-precision timers (e.g., the Time-Stamp Counter on x86 architectures, accessible via the `RDTSC` instruction) to measure the total elapsed time from the start of reading the first component to the completion of the TPM extend for the last component.\n3.  **Sequential Test**: Execute the instrumented application on a single core. The application will iterate through the $n$ files, for each one: read it from storage, compute its hash, and perform a TPM extend operation. The total time $T_{\\text{seq,measured}}$ is recorded.\n4.  **Parallel Test**: Execute the application again, this time configured to use a thread pool of size $c=4$ for the hashing tasks. The application can use a producer-consumer pattern where a main thread reads files and enqueues them, and worker threads consume from the queue to compute hashes. The TPM extend operations remain serialized. The total time $T_{\\text{par,measured}}$ is recorded.\n5.  **Validation**: Compare the measured times, $T_{\\text{seq,measured}}$ and $T_{\\text{par,measured}}$, against the model's predictions, $T_{\\text{seq}} = 0.86$ s and $T_{\\text{par}} = 0.30$ s. Discrepancies would highlight unmodeled effects, such as thread management overhead, cache effects, or contention for the memory bus.\n\n**Scalar Metric Definition and Computation:**\nA suitable scalar metric for comparing the performance of the sequential and parallel implementations is **Speedup**, $S$. It is a dimensionless quantity defined as the ratio of the sequential execution time to the parallel execution time.\n$$S = \\frac{T_{\\text{seq}}}{T_{\\text{par}}}$$\nThis metric quantifies the performance improvement gained by parallelization. A value of $S=1$ indicates no improvement, while a value of $S=c$ (the number of cores) would represent ideal, linear speedup *for the parallelized portion of the task*. However, due to Amdahl's Law, the overall speedup is limited by the serial portions of the task (in this case, I/O and TPM operations).\n\nUsing the values computed in Task 2:\n$$S = \\frac{0.86 \\; \\text{s}}{0.30 \\; \\text{s}} = \\frac{86}{30} = \\frac{43}{15} \\approx 2.8666...$$\nRounding to four significant figures as requested, the metric is $2.867$.\nThis value is less than the number of cores ($c=4$) because the system becomes I/O-bound in the parallel case, and the TPM latency forms a serial component that does not benefit from parallelization. The speedup reflects the improvement in the overall system time, not just the hashing component.",
            "answer": "$$\\boxed{2.867}$$"
        }
    ]
}