{
    "hands_on_practices": [
        {
            "introduction": "Understanding how permission revocation works is fundamental to system security. This first exercise provides a practical demonstration of Discretionary Access Control (DAC) in a standard Unix-like environment, showing how revoking a user's group membership immediately and effectively restricts their access to shared resources. By analyzing this controlled experiment , you will solidify your understanding of how permissions are dynamically evaluated at the time of access.",
            "id": "3619218",
            "problem": "An operating system implements Discretionary Access Control (DAC), Mandatory Access Control (MAC), and Role-Based Access Control (RBAC). Discretionary Access Control (DAC) on a typical Unix-like system uses owner, group, and others permission bits, and the Set Group ID (SGID) bit on directories causes new files created within the directory to inherit the directory’s group. Under DAC, effective access for a process to a filesystem object is determined by comparing the process’s credentials (user identifier and set of group identifiers) to the object’s ownership fields and then applying the appropriate permission class: owner bits if the process’s user identifier equals the owner, group bits if any of the process’s group identifiers equals the file’s group, and otherwise others bits. Additionally, the system uses a process creation mask (umask) to clear permission bits at file creation. Mandatory Access Control (MAC) can further constrain access based on labels and policy, while Role-Based Access Control (RBAC) assigns permissions by roles rather than identities or groups; however, for this experiment, assume MAC is not enforcing any additional constraints and that RBAC is not configured to override DAC.\n\nDesign and evaluate the following controlled experiment intended to demonstrate how revocation of group membership affects effective rights when SGID directories cause new files to inherit groups.\n\nSetup:\n- There are two users, $u_{alice}$ and $u_{bob}$, and one group $G_{dev}$.\n- The directory $D = \\text{/proj/dev}$ is owned by $u_{alice}$, has group $G_{dev}$, and its mode is $2775$ (the leading $2$ sets the SGID bit on the directory, so the mode is $rwxrwxr-x$). No Access Control List (ACL) entries are present beyond mode bits. The umask for processes of both users is $002$.\n- At time $t_1$, $u_{bob}$ is a member of $G_{dev}$ and authenticates to obtain fresh credentials reflecting current group membership.\n- At time $t_1$, $u_{alice}$ creates file $f_1$ inside $D$ by calling $\\text{open}(\\text{\"}f_1\\text{\"}, O\\_CREAT)$ with the requested mode $0666$. Due to the umask $002$, the actual mode becomes $0664$; because $D$ has SGID set, the group of $f_1$ becomes $G_{dev}$, and the owner of $f_1$ is $u_{alice}$.\n- Immediately after $t_1$, $u_{bob}$ has no open file descriptors to $f_1$ and has not cached any capabilities beyond standard credentials.\n- At time $t_2$, the administrator revokes $u_{bob}$’s membership in $G_{dev}$ and forces $u_{bob}$ to reauthenticate, ensuring his process credentials reflect the revocation.\n- At time $t_3 > t_2$, $u_{alice}$ creates file $f_2$ inside $D$ with requested mode $0666$; due to umask $002$, the actual mode is $0664$ and, due to SGID on $D$, the group of $f_2$ is $G_{dev}$, with owner $u_{alice}$.\n- At time $t_4 > t_3$, $u_{bob}$ attempts the following operations: write to $f_1$, write to $f_2$, and create a new file $f_3$ in $D$ with requested mode $0666$.\n\nAssumptions:\n- No Mandatory Access Control (MAC) labels or policies are active that would deny or permit access beyond DAC.\n- No Role-Based Access Control (RBAC) roles are in force for $u_{bob}$ that would override DAC outcomes.\n- No POSIX ACLs are set on $D$, $f_1$, or $f_2$ beyond the standard mode bits.\n- All access checks occur at the time of each operation; in particular, $u_{bob}$ did not open $f_1$ for writing before $t_2$.\n\nWhich of the following outcome sets, observed at time $t_4$, correctly demonstrates the effect of revoking $u_{bob}$’s membership in $G_{dev}$ under these conditions?\n\nA. Before revocation at $t_1$, $u_{bob}$ can write $f_1$ via group $G_{dev}$; after revocation at $t_2$ and reauthentication, $u_{bob}$ cannot write to $f_1$, cannot write to $f_2$, and cannot create $f_3$ in $D$.\n\nB. $u_{bob}$ can still write to $f_1$ after revocation because the SGID bit “pins” group write permission to files in $D$; $u_{bob}$ cannot write to $f_2$, but can create $f_3$ because SGID grants create regardless of group membership.\n\nC. Revocation only affects future files: $u_{bob}$ retains write access to $f_1$ but loses write access to $f_2$; creation of $f_3$ remains permitted because $u_{bob}$ previously had membership in $G_{dev}$ at $t_1$.\n\nD. Even with no Role-Based Access Control (RBAC) configured to override DAC, revoking $u_{bob}$’s membership in $G_{dev}$ at $t_2$ does not affect DAC outcomes on $f_1$ or $f_2$ due to SGID; $u_{bob}$ can write both $f_1$ and $f_2$ and can create $f_3$ in $D$.",
            "solution": "The problem statement describes a controlled experiment on a Unix-like operating system to test the effects of group membership revocation on file access permissions under a Discretionary Access Control (DAC) policy. The analysis requires a precise application of the rules for DAC, the Set Group ID (SGID) bit on directories, and the process creation mask (umask).\n\n### Problem Validation\nThe provided problem statement is subjected to validation.\n\n**Step 1: Extract Givens**\n- **Users**: $u_{alice}$, $u_{bob}$\n- **Group**: $G_{dev}$\n- **Directory**: $D = \\text{/proj/dev}$\n    - Owner: $u_{alice}$\n    - Group: $G_{dev}$\n    - Mode: $2775$ (octal), which is $rwxrwxr-x$ with the SGID bit set.\n- **Umask**: $002$ (octal) for both users.\n- **Timeline and Events**:\n    - **$t_1$**: $u_{bob}$ is a member of $G_{dev}$ and has credentials reflecting this. $u_{alice}$ creates file $f_1$ in $D$ with requested mode $0666$. The resulting file has owner $u_{alice}$, group $G_{dev}$ (due to SGID on $D$), and mode $0664$ (due to umask $002$). $u_{bob}$ holds no open file descriptors to $f_1$.\n    - **$t_2$**: $u_{bob}$'s membership in $G_{dev}$ is revoked. $u_{bob}$ reauthenticates to update his credentials.\n    - **$t_3$**: $u_{alice}$ creates file $f_2$ in $D$ with requested mode $0666$. The resulting file has owner $u_{alice}$, group $G_{dev}$, and mode $0664$.\n    - **$t_4$**: $u_{bob}$ attempts three operations: write to $f_1$, write to $f_2$, create $f_3$ in $D$.\n- **Assumptions**: No overriding MAC or RBAC policies, no POSIX ACLs, access checks are performed at the time of the operation.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is scientifically grounded, well-posed, and objective. It describes a standard, verifiable scenario in operating systems security based on POSIX-compliant file system semantics.\n- The description of DAC, SGID on directories, and umask functionality is accurate and aligns with established principles of operating systems like Linux.\n- The setup is self-contained and provides all necessary information (users, groups, permissions, actions) to deduce a unique outcome.\n- The problem is free of contradictions. For example, the calculation of the final file mode from the requested mode and the umask is correct: the effective permissions are `(requested_mode) & (~umask)`. For a requested mode of $0666_8$ and a umask of $0002_8$, the calculation is $0666_8 \\text{ AND } (\\text{NOT } 0002_8) = 0666_8 \\text{ AND } 0775_8 = 0664_8$.\n- The language is precise and technical.\n\n**Step 3: Verdict and Action**\nThe problem statement is **valid**. A solution can be derived.\n\n### Derivation of Solution\nThe solution is derived by analyzing the permissions of each filesystem object and the credentials of user $u_{bob}$ at the time of the access attempts.\n\n**1. Object Permissions Analysis**\n- **Directory $D = \\text{/proj/dev}$**:\n    - Permissions: mode $2775_8$. This gives $rwx$ to the owner ($u_{alice}$), $rwx$ to the group ($G_{dev}$), and $r-x$ to others. The leading $2$ sets the SGID bit. To create a file within a directory, a process needs both write ($w$) and execute ($x$) permissions on the directory.\n- **File $f_1$ (created at $t_1$)**:\n    - Owner: $u_{alice}$\n    - Group: $G_{dev}$ (inherited from $D$ due to SGID)\n    - Mode: $0664_8$ ($rw-rw-r--$). This gives read/write ($rw-$) to the owner, read/write ($rw-$) to the group, and read-only ($r--$) to others.\n- **File $f_2$ (created at $t_3$)**:\n    - Owner: $u_{alice}$\n    - Group: $G_{dev}$\n    - Mode: $0664_8$ ($rw-rw-r--$). Permissions are identical to $f_1$.\n\n**2. Access Analysis at Time $t_1$ (Before Revocation)**\nAt time $t_1$, $u_{bob}$'s process credentials include membership in $G_{dev}$. When accessing $f_1$:\n- The process UID ($u_{bob}$) does not match the file's owner UID ($u_{alice}$).\n- A process GID ($G_{dev}$) matches the file's group GID ($G_{dev}$).\n- Therefore, the group permissions are used. For $f_1$, these are $rw-$.\n- Conclusion: At $t_1$, $u_{bob}$ can read and write to $f_1$.\n\n**3. Access Analysis at Time $t_4$ (After Revocation)**\nAt time $t_2$, $u_{bob}$'s membership in $G_{dev}$ is revoked, and he reauthenticates. At time $t_4$, any new process run by $u_{bob}$ will have credentials that do not include $G_{dev}$. Access checks occur at the time of the operation ($t_4$) using these new credentials.\n\n- **Attempt 1: Write to file $f_1$**\n    - Target: $f_1$ (owner: $u_{alice}$, group: $G_{dev}$, mode: $rw-rw-r--$)\n    - $u_{bob}$'s credentials: UID is $u_{bob}$, GIDs do **not** include $G_{dev}$.\n    - Access Check:\n        1. UID match? No ($u_{bob} \\neq u_{alice}$).\n        2. GID match? No ($G_{dev}$ is not in $u_{bob}$'s GID set).\n        3. Default to \"others\" permissions.\n    - The \"others\" permissions on $f_1$ are $r--$. This does not grant write permission.\n    - **Outcome**: The write operation is denied.\n\n- **Attempt 2: Write to file $f_2$**\n    - Target: $f_2$ (owner: $u_{alice}$, group: $G_{dev}$, mode: $rw-rw-r--$)\n    - The access check is identical to that for $f_1$. $u_{bob}$ is not the owner and is not in the file's group, so \"others\" permissions apply.\n    - The \"others\" permissions are $r--$.\n    - **Outcome**: The write operation is denied.\n\n- **Attempt 3: Create file $f_3$ in directory $D$**\n    - Target: $D$ (owner: $u_{alice}$, group: $G_{dev}$, mode: $rwxrwxr-x$)\n    - Operation: Creating a file requires write ($w$) and execute ($x$) permissions on the containing directory.\n    - $u_{bob}$'s credentials: Not owner, not in group.\n    - Access Check: \"others\" permissions apply.\n    - The \"others\" permissions on $D$ are $r-x$. This grants read and execute/search permissions, but **not** write permission.\n    - **Outcome**: The file creation is denied.\n\n**Summary of Outcomes:** At $t_4$, $u_{bob}$ cannot write to $f_1$, cannot write to $f_2$, and cannot create $f_3$ in $D$. The revocation of group membership, combined with reauthentication, effectively and immediately removes all access rights that were dependent on that group membership.\n\n### Option-by-Option Analysis\n\n- **A. Before revocation at $t_1$, $u_{bob}$ can write $f_1$ via group $G_{dev}$; after revocation at $t_2$ and reauthentication, $u_{bob}$ cannot write to $f_1$, cannot write to $f_2$, and cannot create $f_3$ in $D$.**\n    - The first clause is correct, as analyzed for time $t_1$.\n    - The second clause, listing the outcomes at $t_4$, matches our derivation perfectly: all three attempted operations fail.\n    - **Verdict: Correct.**\n\n- **B. $u_{bob}$ can still write to $f_1$ after revocation because the SGID bit “pins” group write permission to files in $D$; $u_{bob}$ cannot write to $f_2$, but can create $f_3$ because SGID grants create regardless of group membership.**\n    - This option is based on a misunderstanding of SGID. SGID on a directory affects group ownership of new files, it does not \"pin\" permissions or override the standard DAC evaluation based on current credentials. As derived, $u_{bob}$ cannot write to $f_1$ or create $f_3$.\n    - **Verdict: Incorrect.**\n\n- **C. Revocation only affects future files: $u_{bob}$ retains write access to $f_1$ but loses write access to $f_2$; creation of $f_3$ remains permitted because $u_{bob}$ previously had membership in $G_{dev}$ at $t_1$.**\n    - This is incorrect. Access control in DAC is dynamic; it does not depend on when the file was created or on historical group memberships. Rights are checked at the time of access. $u_{bob}$ loses access to all files for which his permission depended on $G_{dev}$, including $f_1$. He also cannot create $f_3$.\n    - **Verdict: Incorrect.**\n\n- **D. Even with no Role-Based Access Control (RBAC) configured to override DAC, revoking $u_{bob}$’s membership in $G_{dev}$ at $t_2$ does not affect DAC outcomes on $f_1$ or $f_2$ due to SGID; $u_{bob}$ can write both $f_1$ and $f_2$ and can create $f_3$ in $D$.**\n    - This option claims revocation is ineffective, which is the opposite of the truth. The problem explicitly states $u_{bob}$ reauthenticates, meaning his credentials are updated. DAC uses these updated credentials. The SGID bit is irrelevant to this access check. All three predicted outcomes in this option are wrong.\n    - **Verdict: Incorrect.**",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "While the previous example showed revocation working as intended, real-world systems often have more complex features like POSIX Access Control Lists (ACLs). This practice  presents a counterexample where a seemingly successful revocation fails for newly created files, demonstrating how default ACLs can unintentionally grant access. Solving this requires a deeper understanding of permission inheritance and highlights the need for careful, holistic policy design.",
            "id": "3619191",
            "problem": "In a Unix-like system conforming to the Portable Operating System Interface (POSIX) draft Access Control List semantics, consider a project directory where Discretionary Access Control (DAC) governs who may access objects. The directory is intended to allow collaboration among members of a project group while excluding a specific former collaborator. You are told the following facts.\n\n- The directory is named /share, has set group identifier (setgid) semantics for group inheritance, and its mode is $2770$ (that is, $rwxrws---$). Its owning group is team. The user Bob is not a member of the team group.\n- The /share directory has a default Access Control List (ACL) with the following entries (written conceptually, not as exact command syntax):\n  - default:user::rwx\n  - default:group::r-x\n  - default:other::---\n  - default:mask:r-x\n  - default:user:bob:r--\n- Alice, a team member, has a user file-creation mode mask (umask) of $022$ and creates regular files in /share with a requested mode of $0666$ and directories with a requested mode of $0777$, following the usual application defaults.\n- Alice wishes to revoke Bob’s access. She explicitly removes Bob from the ACL of an existing file old.txt by executing a command that deletes the per-file entry for user:bob. She then creates a new file new.txt in /share during the same session.\n\nFundamental base: Under Discretionary Access Control (DAC) in a POSIX-like ACL model, a directory’s default ACL is inherited by newly created files and directories as their access ACL. The effective permissions of named users and groups on a file are limited by the file’s ACL mask entry. If the parent directory has a default mask, the new file’s mask is inherited from that default mask; otherwise, the mask is derived from the group class of the file mode that results from applying the umask to the requested mode. The umask directly constrains the base permission bits computed from the requested mode but does not remove inherited named-user or named-group ACL entries; those are subject to the mask.\n\nQuestion: Which option both correctly explains why Bob can read the new file new.txt even after the per-file revocation on old.txt and prescribes a minimally sufficient fix using only the user file-creation mode mask (umask) and a redesign of the directory’s default ACL so that future revocation is effective for newly created files without breaking intended team access?\n\nA. Explanation: The directory default ACL contains default:user:bob:r--, so each newly created file inherits a user:bob entry, and the inherited default:mask:r-x permits that read access regardless of per-file revocation elsewhere. Fix: Remove the default ACL entry for Bob from /share and ensure the default ACL mask permits only the intended group access (for example, keep default:group::r-x and default:mask:r-x but no default:user:bob), and tighten Alice’s umask to $027$ so that, in directories without a default ACL, new files are created with modes no more permissive than owner $rw$, group $r$, other none (for files approximately $0640$; for directories approximately $0750$), preserving team access while preventing Bob and other non-team users from regaining read permissions.\n\nB. Explanation: The umask of $022$ directly granted Bob read access on new files. Fix: Change umask to $077$ and leave the directory default ACL unchanged.\n\nC. Explanation: The revocation failed because the directory lacks the sticky bit, which allows other users to bypass per-file ACLs for reads. Fix: Set the sticky bit on /share and remove the setgid bit.\n\nD. Explanation: Because DAC is discretionary, revocation cannot be enforced for future objects. Fix: Replace DAC with Role-Based Access Control (RBAC) or Mandatory Access Control (MAC) so the system blocks Bob regardless of directory defaults.\n\nE. Explanation: Bob regains access through team group inheritance. Fix: Remove Bob from the team group; the directory ACLs can remain unchanged.\n\nSelect the single best option.",
            "solution": "We proceed from first principles of Discretionary Access Control (DAC) with POSIX-like Access Control Lists (ACLs), default ACL inheritance, and user file-creation mode mask (umask) behavior.\n\n1) Definitions and governing semantics.\n\n- Under Discretionary Access Control (DAC), the owner of an object can grant or revoke access at their discretion, typically via permission bits and Access Control Lists (ACLs).\n- A directory may have a default ACL. When a new file is created in that directory, the file’s access ACL is derived from the directory’s default ACL. All default entries (default:user, default:group, default:mask, default:other, and any default:named-user or default:named-group) are inherited by the new object as its access ACL entries, with the default:mask copied as the file’s mask.\n- The ACL mask limits the effective permissions granted to any named-user entries (other than the owner) and to the owning group and named groups. Thus, an entry such as user:bob:r-- is further limited by the mask; if mask is r-x, Bob’s effective rights are the intersection of r-- and r-x, which remains r--.\n- The user file-creation mode mask (umask) of value $u$ transforms a requested mode $m$ into a base permission mode $(m \\wedge \\neg u)$ for the new file or directory. If no default ACL exists, this also determines the file’s group class and hence the mask. If a default ACL exists and specifies a default:mask, the new file inherits that mask; the umask does not remove named ACL entries and does not override an explicit default ACL mask.\n\n2) Apply the semantics to the scenario.\n\n- The /share directory has setgid and mode $2770$ ($rwxrws---$), group team, and a default ACL that includes default:user:bob:r-- and default:mask:r-x. Bob is not in the team group.\n- Alice creates a regular file new.txt with a requested mode $0666$ and umask $022$, yielding a base mode of $(0666 \\wedge \\neg 022) = 0644$. However, because the parent directory has a default ACL, the new file inherits the default ACL as its access ACL entries. In particular:\n  - It inherits user:bob:r--.\n  - It inherits mask:r-x.\n  - The effective permissions of Bob are computed as the intersection of his named-user entry and the mask, which is $r-- \\wedge r-x = r--$. Therefore, Bob can read new.txt.\n- Alice previously removed Bob from old.txt by deleting the per-file ACL entry user:bob. That revocation applies only to old.txt. New files created in /share will continue to inherit the default ACL entry for Bob, so the revocation does not persist for new objects. This is a characteristic pitfall in DAC with default ACLs: revoking a per-file ACL does not alter the parent directory’s default ACL, so new files can regrant access.\n\n3) Corrective design using umask and directory ACL redesign.\n\n- To prevent Bob from regaining access on newly created files in /share, the parent directory’s default ACL must be changed so that it no longer grants user:bob any rights. Removing default:user:bob from /share ensures that new files will not inherit that entry. Keeping default:group::r-x and default:mask:r-x maintains intended team access while continuing to limit the effective rights of any named entries to at most r-x; since there is no named entry for Bob and he is not in the team group, he will have no access via group or named-user entries, and other::--- denies access via others.\n- To strengthen least privilege outside or in the absence of default ACLs, Alice should also reduce her umask from $022$ to $027$. With requested mode $0666$ for files, $0666 \\wedge \\neg 027 = 0640$, giving owner $rw$, group $r$, other none; with requested mode $0777$ for directories, $0777 \\wedge \\neg 027 = 0750$, giving owner $rwx$, group $rx$, other none. This aligns with the team’s intent: team members (group) can read directories and read files as needed, while non-team users, including Bob, cannot read. Note that the umask does not override an explicit default ACL mask, but it does ensure that in directories without default ACLs, or for new directories Alice creates, the base permissions do not leak to others.\n\n4) Option-by-option analysis.\n\n- Option A: This correctly identifies the root cause: the directory’s default ACL contains default:user:bob:r--, so new files inherit a user:bob entry; the default:mask:r-x permits Bob’s read. It also prescribes the minimal sufficient DAC fix: remove the default entry for Bob and keep a default ACL mask and group entry that preserve team access; additionally, adjust umask to $027$ so that, where default ACLs are absent, files and directories are created with restrictive base permissions. This uses only umask and directory ACL redesign, and it achieves the stated goals. Verdict: Correct.\n\n- Option B: This attributes the problem to umask $022$ and proposes changing only the umask to $077$ while leaving the default ACL unchanged. This is insufficient. With a default ACL present that includes default:user:bob and an explicit default:mask, the new file inherits both, regardless of the umask. The umask does not remove inherited named-user entries nor override an explicit default mask; Bob would still receive read via the inherited ACL. Verdict: Incorrect.\n\n- Option C: This blames the absence of the sticky bit and suggests setting the sticky bit and removing setgid. The sticky bit governs unlink/rename in a directory, not read access. Removing setgid would alter group inheritance but would not remove the inherited named-user ACL entry for Bob. This does not explain the observed read, nor does it fix it. Verdict: Incorrect.\n\n- Option D: This claims that DAC cannot enforce revocation for future objects, recommending Role-Based Access Control (RBAC) or Mandatory Access Control (MAC). While MAC can supersede DAC and could be used to enforce policy, the premise that DAC cannot enforce revocation here is false; the issue arises from a misconfigured default ACL, not an intrinsic limitation of DAC. The problem can be solved within DAC by redesigning the default ACL and adjusting umask as in Option A. Verdict: Incorrect.\n\n- Option E: This asserts Bob regains access through the team group and proposes removing Bob from that group. The scenario states Bob is not a member of the team group. His access comes from the default:named-user entry. This neither explains the behavior nor provides the relevant fix. Verdict: Incorrect.\n\nTherefore, the correct choice is the one that removes the default:named-user entry for Bob, retains a suitable default mask and group entry to preserve team access, and tightens umask to avoid unintended permissions elsewhere, namely Option A.",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "Shifting from discretionary to Mandatory Access Control (MAC) requires a new way of thinking, focusing on system-wide information flow rather than user-by-user permissions. This exercise  challenges you to model a MAC policy as a directed graph and to use graph reachability to verify the property of noninterference after revoking a write privilege. This practice formalizes the concept of security, allowing you to prove that no information can leak from a high-security level to a low-security level.",
            "id": "3619220",
            "problem": "You are to model Mandatory Access Control (MAC) information flows and revocation of write privileges using a directed graph and demonstrate noninterference with respect to a two-level confidentiality partition. Use the following fundamental base:\n\n- Let a system have a finite set of security labels organized in a lattice with partial order $\\preceq$. Every subject or object $v$ has a label $\\ell(v)$. In classical confidentiality MAC, write operations must respect the property \"no write down,\" i.e., writing from $u$ to $w$ is permitted only if $\\ell(u) \\preceq \\ell(w)$.\n- Noninterference, in the two-level confidentiality sense, requires that actions at a high-security level do not alter what is observable at a low-security level, which can be operationally reasoned about as the absence of any information flow from high to low through allowed operations.\n\nYour program must:\n\n- Represent a small information-flow graph as a directed graph $G = (V, E)$, where vertices $V$ represent subjects or objects, and directed edges $(u, v) \\in E$ represent currently allowed write flows from $u$ to $v$.\n- Apply revocation to write edges: a revocation is the removal of designated edges from $E$, producing a new edge set $E' \\subseteq E$.\n- After revocation, determine whether noninterference holds by checking that there is no path in $G' = (V, E')$ that starts at any vertex $s$ with $\\ell(s) = H$ and reaches any vertex $t$ with $\\ell(t) = L$. For this problem, use a two-level partition with low set $L$ at numeric label $0$ and high set $H$ at numeric label $2$. Vertices with any other label (e.g., $1$) are intermediates that should be considered only as potential waypoints; they are not directly part of the low or high sets for the noninterference check.\n- Return, for each test case, a boolean expressed as an integer: output $1$ if noninterference holds (no high-to-low reachability) after revocation, and output $0$ otherwise.\n\nImplement the solution purely in terms of graph reachability using the remaining write edges after revocation. You must define the revocation semantics as the elimination of specified write edges from the graph. You may assume that all edges in these test cases are write edges.\n\nTest Suite:\nUse exactly the following five test cases. In all cases, the label function $\\ell$ maps vertices to integers, with $0$ meaning low $L$, $1$ meaning intermediate, and $2$ meaning high $H$. All edges listed are write edges prior to revocation. Vertices are indexed starting from $0$.\n\n- Test case $1$ (happy path: revocation blocks a high-to-low flow):\n  - $|V| = 3$, labels $\\ell = [2, 1, 0]$ for vertices $[0, 1, 2]$ respectively.\n  - Initial edges $E = \\{(0,1), (1,2), (0,2)\\}$.\n  - Revoked edges: indices $0$ and $2$, i.e., remove $(0,1)$ and $(0,2)$, keep $(1,2)$.\n\n- Test case $2$ (boundary: no edges):\n  - $|V| = 3$, labels $\\ell = [2, 1, 0]$ for vertices $[0, 1, 2]$ respectively.\n  - Initial edges $E = \\emptyset$.\n  - Revoked edges: none.\n\n- Test case $3$ (edge case: cycle among high nodes, no path to low):\n  - $|V| = 3$, labels $\\ell = [2, 2, 0]$ for vertices $[0, 1, 2]$ respectively.\n  - Initial edges $E = \\{(0,1), (1,0)\\}$.\n  - Revoked edges: none.\n\n- Test case $4$ (negative case: indirect path from high to low remains):\n  - $|V| = 3$, labels $\\ell = [2, 1, 0]$ for vertices $[0, 1, 2]$ respectively.\n  - Initial edges $E = \\{(0,1), (1,2)\\}$.\n  - Revoked edges: none.\n\n- Test case $5$ (revocation removes a direct high-to-low edge):\n  - $|V| = 2$, labels $\\ell = [2, 0]$ for vertices $[0, 1]$ respectively.\n  - Initial edges $E = \\{(0,1)\\}$.\n  - Revoked edges: index $0$, i.e., remove $(0,1)$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results for the five test cases, as a comma-separated list enclosed in square brackets, in the order the test cases are given. For example, the output must be of the form $[r_1,r_2,r_3,r_4,r_5]$, where each $r_i$ is an integer $0$ or $1$ as defined above. There are no physical quantities, so no units are required. Angles and percentages do not apply.",
            "solution": "The problem is assessed to be **valid**. It presents a well-defined task grounded in the formal principles of computer security, specifically information flow control and noninterference. The problem is self-contained, with all necessary data and definitions provided. The use of a directed graph to model information flow and reachability analysis to check for policy violations is a standard and sound methodology in this domain.\n\nThe central principle is **noninterference**, a security policy that aims to prevent actions performed by subjects at a high-security level from having any effect on the observations of subjects at a low-security level. In the context of this problem, noninterference is formalized as the absence of information flow from high-security entities to low-security entities.\n\nWe model the system as a directed graph $G' = (V, E')$, where:\n- $V$ is the set of all subjects and objects in the system, represented as vertices.\n- Each vertex $v \\in V$ is assigned a security label $\\ell(v)$. The problem specifies a lattice of labels, but here we use a discrete set $\\{0, 1, 2\\}$, where $\\ell(v)=0$ corresponds to a low-security level ($L$), and $\\ell(v)=2$ corresponds to a high-security level ($H$). Vertices with $\\ell(v)=1$ are considered intermediate and are neither sources nor sinks for the noninterference check, but can be part of a flow path.\n- $E'$ is the set of directed edges representing permitted information flows (write operations) *after* a revocation operation has occurred. An edge $(u, v) \\in E'$ signifies that information can flow from $u$ to $v$.\n\nA violation of noninterference occurs if there is a path from any high-security vertex to any low-security vertex. Let $V_H = \\{s \\in V \\mid \\ell(s) = 2\\}$ be the set of high-security vertices and $V_L = \\{t \\in V \\mid \\ell(t) = 0\\}$ be the set of low-security vertices. Noninterference is violated if there exists at least one pair $(s, t)$ with $s \\in V_H$ and $t \\in V_L$ such that $t$ is reachable from $s$ in the graph $G'$. Mathematically, a violation exists if:\n$$ \\exists s \\in V_H, \\exists t \\in V_L \\text{ such that a path } s \\to \\dots \\to t \\text{ exists in } G' $$\nIf no such path exists for any pair $(s, t)$, noninterference is said to hold.\n\nThe algorithmic solution proceeds as follows for each test case:\n\n1.  **Graph Construction:** The graph $G'=(V, E')$ is constructed. We can use an adjacency matrix $A$ of size $|V| \\times |V|$, initialized with all entries as $0$. The initial set of edges $E$ is given. We iterate through these edges. For each edge $(u,v) \\in E$ that is *not* in the set of revoked edges, we set the corresponding matrix entry $A_{uv} = 1$. This matrix represents the final set of allowed flows $E'$.\n\n2.  **Identify High and Low Vertices:** From the given label mapping $\\ell$, we identify the sets $V_H$ and $V_L$.\n\n3.  **Reachability Analysis:** To check for a violation, we must determine if any vertex in $V_L$ is reachable from any vertex in $V_H$. A systematic way to do this is to perform a graph traversal, such as a Depth-First Search (DFS), starting from each high-security vertex.\n    - For each vertex $s \\in V_H$:\n        - Initiate a DFS starting from $s$.\n        - A `visited` array, reset for each new starting vertex $s$, is used to track visited vertices during the traversal to avoid infinite loops in case of cycles.\n        - The DFS explores vertices reachable from $s$. If at any point the traversal reaches a vertex $t$ such that $t \\in V_L$ (i.e., $\\ell(t)=0$), an information flow from high to low has been discovered.\n        - Upon finding such a path, the noninterference property is violated. We can immediately conclude the result for the test case is $0$ and terminate the search.\n\n4.  **Final Verdict:** If the traversal from every vertex $s \\in V_H$ completes without ever reaching any vertex in $V_L$, it proves that no such high-to-low path exists in the graph. In this case, the noninterference property holds, and the result for the test case is $1$.\n\nThis algorithm correctly and completely solves the problem by translating the abstract security property of noninterference into a concrete graph reachability problem.",
            "answer": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n// #include <complex.h> // Not needed\n// #include <threads.h> // Not needed\n// #include <stdatomic.h> // Not needed\n\n// Define problem-specific constants for clarity and safety.\n#define MAX_VERTICES 4 // Max vertices across all test cases is 3, using 4 for safety.\n#define MAX_EDGES 3    // Max edges across all test cases is 3.\n\n// Security level definitions from the problem.\n#define HIGH_LEVEL 2\n#define LOW_LEVEL 0\n\n// A struct to represent a directed edge in the graph.\ntypedef struct {\n    int u; // source vertex\n    int v; // destination vertex\n} Edge;\n\n// A struct to hold the parameters for a single test case.\ntypedef struct {\n    int num_vertices;\n    int labels[MAX_VERTICES];\n    int num_edges;\n    Edge edges[MAX_EDGES];\n    int num_revoked;\n    int revoked_indices[MAX_EDGES];\n} TestCase;\n\n/**\n * @brief Performs a Depth-First Search (DFS) to find a path to a low-security vertex.\n *\n * @param u The current vertex in the traversal.\n * @param num_vertices The total number of vertices in the graph.\n * @param adj The adjacency matrix representing the graph.\n * @param labels The array of security labels for each vertex.\n * @param visited An array to keep track of visited vertices in the current DFS traversal.\n * @return Returns 1 if a path to a low-security vertex is found, 0 otherwise.\n */\nint has_path_to_low_recursive(int u, int num_vertices, const int adj[][MAX_VERTICES], const int labels[], int visited[]) {\n    visited[u] = 1;\n\n    for (int v = 0; v < num_vertices; ++v) {\n        if (adj[u][v]) { // If there is an edge from u to v\n            if (labels[v] == LOW_LEVEL) {\n                return 1; // Path to a low-level vertex found\n            }\n            if (!visited[v]) {\n                if (has_path_to_low_recursive(v, num_vertices, adj, labels, visited)) {\n                    return 1; // Propagate the \"found\" signal up the recursion stack\n                }\n            }\n        }\n    }\n    return 0; // No path found from this branch\n}\n\nint main(void) {\n    // Define the test cases from the problem statement.\n    TestCase test_cases[] = {\n        // Test case 1 (happy path: revocation blocks flow)\n        {   .num_vertices = 3, \n            .labels = {2, 1, 0}, \n            .num_edges = 3, \n            .edges = {{0, 1}, {1, 2}, {0, 2}}, \n            .num_revoked = 2, \n            .revoked_indices = {0, 2}\n        },\n        // Test case 2 (boundary: no edges)\n        {   .num_vertices = 3, \n            .labels = {2, 1, 0}, \n            .num_edges = 0, \n            .edges = {}, \n            .num_revoked = 0, \n            .revoked_indices = {}\n        },\n        // Test case 3 (edge case: cycle among high nodes)\n        {   .num_vertices = 3, \n            .labels = {2, 2, 0}, \n            .num_edges = 2, \n            .edges = {{0, 1}, {1, 0}}, \n            .num_revoked = 0, \n            .revoked_indices = {}\n        },\n        // Test case 4 (negative case: indirect path remains)\n        {   .num_vertices = 3, \n            .labels = {2, 1, 0}, \n            .num_edges = 2, \n            .edges = {{0, 1}, {1, 2}}, \n            .num_revoked = 0, \n            .revoked_indices = {}\n        },\n        // Test case 5 (revocation removes direct high-to-low edge)\n        {   .num_vertices = 2, \n            .labels = {2, 0}, \n            .num_edges = 1, \n            .edges = {{0, 1}},\n            .num_revoked = 1, \n            .revoked_indices = {0}\n        }\n    };\n\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    int results[num_cases];\n\n    // Calculate the result for each test case.\n    for (int i = 0; i < num_cases; ++i) {\n        TestCase tc = test_cases[i];\n        int adj[MAX_VERTICES][MAX_VERTICES];\n        memset(adj, 0, sizeof(adj));\n\n        // Build the post-revocation adjacency matrix.\n        int is_revoked_flags[MAX_EDGES] = {0};\n        for (int j = 0; j < tc.num_revoked; ++j) {\n            is_revoked_flags[tc.revoked_indices[j]] = 1;\n        }\n\n        for (int j = 0; j < tc.num_edges; ++j) {\n            if (!is_revoked_flags[j]) {\n                Edge e = tc.edges[j];\n                adj[e.u][e.v] = 1;\n            }\n        }\n\n        // Check for noninterference.\n        int interference_found = 0;\n        for (int start_node = 0; start_node < tc.num_vertices; ++start_node) {\n            if (tc.labels[start_node] == HIGH_LEVEL) {\n                int visited[MAX_VERTICES] = {0};\n                if (has_path_to_low_recursive(start_node, tc.num_vertices, (const int (*)[MAX_VERTICES])adj, tc.labels, visited)) {\n                    interference_found = 1;\n                    break; // A high-to-low path was found, no need to check other high nodes.\n                }\n            }\n        }\n        \n        // Result is 1 if noninterference holds (no path found), 0 otherwise.\n        results[i] = !interference_found;\n    }\n\n    // Print the results in the EXACT REQUIRED format before the final return statement.\n    printf(\"[\");\n    for (int i = 0; i < num_cases; ++i) {\n        printf(\"%d\", results[i]);\n        if (i < num_cases - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\\n\");\n\n    return EXIT_SUCCESS;\n}\n```"
        }
    ]
}