{
    "hands_on_practices": [
        {
            "introduction": "This first exercise grounds the abstract principles of Byzantine Fault Tolerance in a common, practical scenario: securing service discovery within an operating system. The problem explores how to build a resilient DNS client that can withstand malicious resolvers. By leveraging the power of digital signatures (via DNSSEC), the challenge of ensuring safety is simplified, allowing you to focus on deriving the minimum requirements for liveness—guaranteeing that the system can always make progress despite a subset of nodes being faulty .",
            "id": "3625118",
            "problem": "An operating system service discovery component needs to resolve hostnames to endpoints using the Domain Name System (DNS). To tolerate adversarial resolvers that may return poisoned entries, the client implements a Byzantine fault tolerant read protocol with certified data. The client concurrently queries $n$ independent recursive resolvers drawn from disjoint administrative domains. At most $f$ resolvers are Byzantine faulty, in the sense of the classical definition of Byzantine faults: they may behave arbitrarily, including sending incorrect data, replaying stale data, equivocating, or not responding at all.\n\nThe authoritative zone for the service is protected by Domain Name System Security Extensions (DNSSEC), and the client verifies every received resource record set using the zone’s public key. Assume the authoritative signing key is uncompromised, the signature scheme provides unforgeability and data-origin authentication, and the record set for the target name at the time of resolution is unique and deterministic for all correct resolvers. Any response that fails signature verification, has an invalid signature validity interval, or does not exactly match the currently valid signed resource record set is discarded by the client.\n\nThe client’s acceptance policy is as follows: it accepts the mapping only after it has collected $q$ identical, validly signed resource record sets from $q$ distinct resolvers. The network is asynchronous, so responses can be delayed arbitrarily, but every nonfaulty resolver eventually returns the correct, validly signed record set.\n\nStarting from these definitions and properties, derive a closed-form expression for the minimal number $n$ of resolvers the client must query to guarantee both safety (it never accepts an incorrect mapping) and liveness (it eventually accepts the correct mapping), for any adversary controlling up to $f$ resolvers. Express your final answer as a function of $f$ and $q$. No numerical rounding is required.",
            "solution": "The problem statement has been analyzed and is deemed valid. It is scientifically grounded in the principles of distributed systems and cryptography, specifically Byzantine fault tolerance (BFT) with authenticated messages. The problem is well-posed, objective, and contains sufficient information to derive a unique and meaningful solution.\n\nLet $n$ be the total number of resolvers the client queries.\nLet $f$ be the maximum number of these resolvers that can be Byzantine faulty.\nLet $q$ be the number of identical, validly signed resource record sets required for the client to accept a mapping.\n\nThe client must guarantee two properties: safety and liveness.\n\n1.  **Safety Analysis**\n\n    Safety requires that the client never accepts an incorrect mapping. The client's acceptance policy is to wait for $q$ identical, validly signed resource record sets from $q$ distinct resolvers.\n\n    The problem states that the system uses Domain Name System Security Extensions (DNSSEC), the authoritative signing key is uncompromised, and the signature scheme provides unforgeability. This implies that an adversary controlling the $f$ faulty resolvers cannot forge a valid digital signature for any resource record set that was not signed by the authoritative owner of the zone.\n\n    Furthermore, the problem specifies that \"the record set for the target name at the time of resolution is unique and deterministic for all correct resolvers.\" Let us denote this unique, currently valid, and correctly signed record set as $RR_{correct}$.\n\n    Any response that does not exactly match $RR_{correct}$ will be discarded by the client, as it would either fail signature verification or be identified as not the \"currently valid signed resource record set\". Therefore, a Byzantine resolver cannot create a different, validly signed record set, $RR_{incorrect}$, that would pass the client's verification. The only validly signed record set they could possibly send is $RR_{correct}$ itself.\n\n    Consequently, it is impossible for the client to collect $q$ identical, validly signed copies of an incorrect record set. The only record set that can satisfy the acceptance criteria is $RR_{correct}$. Thus, the safety property is unconditionally guaranteed by the cryptographic authentication mechanism for any $q \\ge 1$, irrespective of the values of $n$ and $f$.\n\n2.  **Liveness Analysis**\n\n    Liveness requires that the client eventually accepts the correct mapping. This means the client must be guaranteed to eventually collect $q$ copies of $RR_{correct}$.\n\n    We must consider the worst-case scenario that an adversary can create to prevent liveness. The adversary controls $f$ resolvers. To maximally obstruct the client, the adversary will instruct all $f$ faulty resolvers to behave in a way that prevents the client from making progress. Given the client's validation rules, the most damaging action a faulty resolver can take is to not send the correct record set, $RR_{correct}$. This can be achieved by not responding at all (a crash fault), or by sending data that is guaranteed to be discarded (e.g., garbage data, a replayed stale record, or a record for a different name).\n\n    There are a total of $n$ resolvers. In the worst case, $f$ of them are faulty and are not contributing to the collection of $RR_{correct}$. The number of remaining resolvers is $n - f$. These resolvers are, by definition, non-faulty.\n\n    The problem states that \"every nonfaulty resolver eventually returns the correct, validly signed record set.\" This guarantees that the client will, eventually, receive $n - f$ copies of $RR_{correct}$.\n\n    For the liveness property to hold, the number of guaranteed correct responses must be sufficient to meet the client's acceptance quorum, $q$. Therefore, the number of non-faulty resolvers must be at least $q$. This gives us the following inequality:\n    $$n - f \\ge q$$\n\n3.  **Derivation of Minimal $n$**\n\n    The safety property imposes no additional constraints on $n$ beyond what liveness requires. The liveness property requires that $n - f \\ge q$. To find the minimal number of resolvers, $n$, we can solve this inequality for $n$:\n    $$n \\ge f + q$$\n\n    The smallest integer value of $n$ that satisfies this condition for any configuration of up to $f$ faults is when equality holds. Thus, the minimal number of resolvers required is:\n    $$n = f + q$$\n\n    With $n = f + q$ resolvers, in the worst case where $f$ resolvers are faulty and uncooperative, there are still $(f + q) - f = q$ non-faulty resolvers remaining. Since all non-faulty resolvers are guaranteed to eventually respond with the correct, validly signed record set, the client is guaranteed to eventually receive $q$ such responses, thereby satisfying the liveness condition. As established, safety is already guaranteed by the cryptographic properties of the system.",
            "answer": "$$\\boxed{f + q}$$"
        },
        {
            "introduction": "Moving beyond simple consensus, this practice demonstrates the broad applicability of BFT concepts to the domain of control systems and signal processing. Here, you will analyze a method for achieving a reliable temperature reading from multiple sensors, some of which may be malicious and report arbitrary, physically impossible values. This exercise in robust estimation will guide you through proving the worst-case error bound of a common BFT-inspired technique, the $f$-trimmed mean, developing your skills in reasoning about system resilience in the presence of adversarial data sources .",
            "id": "3625176",
            "problem": "An Operating System (OS) fan controller uses multiple on-board thermal sensors to estimate the Central Processing Unit (CPU) temperature and set the fan speed. The system must tolerate Byzantine Fault Tolerance (BFT), where up to $f$ sensors may act arbitrarily (maliciously), and the remaining $n-f$ sensors are honest. Let the true CPU temperature be $T \\in \\mathbb{R}$. Honest sensor $i$ reports $x_{i} = T + \\varepsilon_{i}$ with $|\\varepsilon_{i}| \\leq \\delta$ for a known bound $\\delta > 0$. Malicious sensors may report any real numbers without constraint.\n\nTo aggregate the $n$ readings, the OS uses the $f$-trimmed mean estimator: sort the $n$ reported values to obtain the order statistics $x_{(1)} \\leq x_{(2)} \\leq \\cdots \\leq x_{(n)}$, discard the lowest $f$ and highest $f$ values, and compute\n$$\n\\hat{T} = \\frac{1}{n - 2f} \\sum_{i = f + 1}^{n - f} x_{(i)} \\, ,\n$$\nassuming $n \\ge 2f + 1$ so that the estimator is well-defined.\n\nAdversaries seek to maximize the estimation error subject to the above constraints. Derive the tight worst-case upper bound on the absolute error\n$$\nE = \\sup \\, \\big| \\hat{T} - T \\big| \\, ,\n$$\nover all possible assignments of malicious values and all honest noise realizations satisfying $|\\varepsilon_{i}| \\leq \\delta$. Express your final bound as a closed-form function of $n$, $f$, and $\\delta$. You must express the bound in degrees Celsius. No numerical rounding is required.",
            "solution": "The problem asks for the tight worst-case upper bound on the absolute estimation error, $E = \\sup \\, |\\hat{T} - T|$, where $\\hat{T}$ is the $f$-trimmed mean estimator for the true temperature $T$. The estimator is given by\n$$\n\\hat{T} = \\frac{1}{n - 2f} \\sum_{i = f + 1}^{n - f} x_{(i)}\n$$\nThe system consists of $n$ sensors, of which up to $f$ can be malicious (Byzantine) and report arbitrary values. The remaining $n-f$ sensors are honest, reporting values $x_i = T + \\varepsilon_i$ where the noise $\\varepsilon_i$ is bounded by $|\\varepsilon_i| \\leq \\delta$. The analysis is subject to the condition $n \\geq 2f + 1$.\n\nThe absolute error is $|\\hat{T} - T|$. To find its supremum, we can analyze the maximum and minimum possible values of the deviation $\\hat{T} - T$. Due to the symmetric nature of the problem (malicious sensors can report arbitrarily high or low values, and the honest error bound $|\\varepsilon_i| \\le \\delta$ is symmetric around $0$), the maximum positive error $\\sup(\\hat{T}-T)$ will have the same magnitude as the maximum negative error $\\sup(T-\\hat{T})$. We will focus on finding the maximum possible value of $\\hat{T}$.\n\nLet us analyze the range of values that can appear in the sum of the estimator. The sum is over the order statistics $x_{(i)}$ for $i$ from $f+1$ to $n-f$. We will demonstrate that any such value $x_{(i)}$ must lie within the range $[T-\\delta, T+\\delta]$, regardless of the values reported by the malicious sensors.\n\nFirst, let's establish an upper bound for any value $x_{(i)}$ in the averaging window. The largest value included in the average is $x_{(n-f)}$. Consider the set of the largest $f+1$ reported values: $\\{x_{(n-f)}, x_{(n-f+1)}, \\dots, x_{(n)}\\}$. All values in this set are, by definition of order statistics, greater than or equal to $x_{(n-f)}$. This set contains $f+1$ sensor readings. Since there are only $f$ malicious sensors, at least one of these $f+1$ readings must come from an honest sensor. Let this honest reading be $x_{h}$. For this honest reading, we know $x_{h} = T + \\varepsilon_{h}$ and $\\varepsilon_{h} \\leq \\delta$, so $x_{h} \\leq T + \\delta$.\nSince $x_{h}$ is in the set $\\{x_{(n-f)}, \\dots, x_{(n)}\\}$, we have $x_{h} \\geq x_{(n-f)}$.\nCombining these inequalities yields $x_{(n-f)} \\leq x_{h} \\leq T + \\delta$.\nSince $x_{(n-f)}$ is the largest value in the averaging window, it follows that for any $i \\in \\{f+1, \\dots, n-f\\}$, we have $x_{(i)} \\leq x_{(n-f)} \\leq T + \\delta$.\n\nSecond, let's establish a lower bound using a symmetric argument. The smallest value included in the average is $x_{(f+1)}$. Consider the set of the smallest $f+1$ reported values: $\\{x_{(1)}, x_{(2)}, \\dots, x_{(f+1)}\\}$. All values in this set are less than or equal to $x_{(f+1)}$. This set also contains $f+1$ sensor readings. By the pigeonhole principle, at least one of these readings must originate from an honest sensor. Let this honest reading be $x_{h'}$. For this reading, $x_{h'} = T + \\varepsilon_{h'}$ and $\\varepsilon_{h'} \\geq -\\delta$, so $x_{h'} \\geq T - \\delta$.\nSince $x_{h'}$ is in the set $\\{x_{(1)}, \\dots, x_{(f+1)}\\}$, we have $x_{h'} \\leq x_{(f+1)}$.\nCombining these gives $x_{(f+1)} \\geq x_{h'} \\geq T - \\delta$.\nSince $x_{(f+1)}$ is the smallest value in the averaging window, it follows that for any $i \\in \\{f+1, \\dots, n-f\\}$, we have $x_{(i)} \\geq x_{(f+1)} \\geq T - \\delta$.\n\nWe have proven that for any index $i$ in the summation range, $f+1 \\leq i \\leq n-f$, the corresponding order statistic $x_{(i)}$ is bounded by\n$$\nT - \\delta \\leq x_{(i)} \\leq T + \\delta\n$$\nThis holds for any possible set of malicious values and any valid realization of honest sensor noise.\n\nNow, we can bound the estimator $\\hat{T}$. Using the upper bound for each term in the sum:\n$$\n\\hat{T} = \\frac{1}{n - 2f} \\sum_{i = f + 1}^{n - f} x_{(i)} \\leq \\frac{1}{n - 2f} \\sum_{i = f + 1}^{n - f} (T + \\delta)\n$$\nThe number of terms in the sum is $(n-f) - (f+1) + 1 = n-2f$.\n$$\n\\hat{T} \\leq \\frac{1}{n - 2f} (n - 2f)(T + \\delta) = T + \\delta\n$$\nSimilarly, using the lower bound for each term:\n$$\n\\hat{T} = \\frac{1}{n - 2f} \\sum_{i = f + 1}^{n - f} x_{(i)} \\geq \\frac{1}{n - 2f} \\sum_{i = f + 1}^{n - f} (T - \\delta) = T - \\delta\n$$\nCombining these results, we find that the estimate $\\hat{T}$ is always contained in the interval $[T - \\delta, T + \\delta]$. This implies that the absolute error is bounded by:\n$$\n|\\hat{T} - T| \\leq \\delta\n$$\nThis shows that $\\sup \\, |\\hat{T}-T| \\le \\delta$.\n\nTo prove that this bound is tight, we must construct a worst-case scenario where the error is exactly $\\delta$. The adversary's goal is to maximize the error, which involves choosing the $f$ malicious values and is maximized over all possible honest noise realizations $|\\varepsilon_i| \\le \\delta$. To maximize $\\hat{T}-T$, the adversary can employ the following strategy:\n1.  Set the noise for all $n-f$ honest sensors to their maximum possible value, $\\varepsilon_i = +\\delta$. This makes all honest sensors report the value $T+\\delta$.\n2.  Set the values for all $f$ malicious sensors to be some value smaller than any honest reading, for instance, by reporting a very large negative number (or any value less than $T+\\delta$). A simple choice is to have them report $T-\\delta$.\n\nThe collection of $n$ sensor readings is then $\\{T-\\delta, \\dots, T-\\delta\\}$ ($f$ times) and $\\{T+\\delta, \\dots, T+\\delta\\}$ ($n-f$ times). The sorted list of readings, $x_{(1)} \\leq x_{(2)} \\leq \\cdots \\leq x_{(n)}$, will be:\n$$\nx_{(1)} = \\cdots = x_{(f)} = T - \\delta\n$$\n$$\nx_{(f+1)} = \\cdots = x_{(n)} = T + \\delta\n$$\nThe estimator $\\hat{T}$ averages the values from $x_{(f+1)}$ to $x_{(n-f)}$. In this scenario, all of these values are equal to $T+\\delta$.\n$$\n\\hat{T} = \\frac{1}{n - 2f} \\sum_{i = f + 1}^{n - f} (T + \\delta) = \\frac{1}{n - 2f} (n-2f)(T+\\delta) = T + \\delta\n$$\nFor this case, the estimation error is $\\hat{T} - T = (T+\\delta) - T = \\delta$.\nBy a symmetric argument (setting honest noise to $-\\delta$ and malicious values to a very large positive number), an error of $-\\delta$ can be achieved.\n\nSince the absolute error $|\\hat{T} - T|$ is always less than or equal to $\\delta$, and we have demonstrated a scenario where it is exactly equal to $\\delta$, the tight worst-case upper bound (supremum) on the absolute error is $\\delta$. The problem states the bound should be expressed in degrees Celsius, which is the unit of $\\delta$.",
            "answer": "$$\\boxed{\\delta}$$"
        },
        {
            "introduction": "This final practice provides a hands-on opportunity to translate the core mathematical theory of BFT into a working simulation. You will implement the decision logic for a distributed checkpointing service, a critical function for system hibernation and recovery. The task requires you to derive the fundamental quorum size from first principles and apply the classic viability condition of $n \\ge 3f + 1$, cementing your understanding of how quorum intersection guarantees safety against arbitrary faults and prevents dangerous split-brain scenarios .",
            "id": "3625121",
            "problem": "You are given a scenario motivated by operating system hibernation: before entering a low-power state, a distributed checkpoint service must agree on a single memory image digest to persist. The system is replicated across multiple nodes and must tolerate Byzantine faults. The agreement is performed on signed memory image digests, denoted by $h$, one per proposed image. Your task is to write a program that simulates whether safe agreement is achievable and, if so, which digest is selected, based on a set-theoretic derivation of a quorum rule under Byzantine faults.\n\nUse the following fundamental base, stated in purely logical and mathematical terms:\n\n- Byzantine Fault Tolerance (BFT) means up to $f$ nodes can behave arbitrarily. The system has $n$ total nodes. Correct nodes follow protocol rules, including signing at most one digest for a given decision round.\n- The acceptance rule requires a quorum of signatures on a single digest. A signature is considered valid if it is syntactically correct and attached to the target digest $h$; otherwise it is invalid. For the purpose of this simulation, validity is a boolean predicate provided in the test cases for each signature.\n- A quorum size, denoted by $t$, must be chosen to guarantee safety and liveness under the following constraints:\n  1. Safety: No two distinct digests $h_a \\neq h_b$ can both be simultaneously accepted by correct nodes. Equivalently, any two quorums for different digests must intersect in at least one correct node, since correct nodes sign at most one digest per round.\n  2. Liveness: If at most $f$ nodes are Byzantine, correct nodes can form a quorum that accepts a digest whenever sufficiently many correct signatures exist.\n- Set-theoretic foundation: For a universe of $n$ nodes, any two subsets of size $t$ have an intersection of size at least $2t - n$. Since at most $f$ nodes can be Byzantine, guaranteeing that the intersection includes at least one correct node requires the intersection’s size to exceed $f$.\n\nYour program must:\n1. Derive the minimal integer quorum size $t$ from $n$ and $f$ using the above constraints and set-theoretic facts, without relying on any pre-given shortcut formulas.\n2. Validate signatures, count only valid and distinct signers per digest, and enforce that each correct node signs at most one digest in the round.\n3. Determine if a unique digest is safely acceptable. A digest $h$ is acceptable if it gathers at least $t$ valid signatures, and no other digest simultaneously does so; if more than one digest meets or exceeds $t$, or if a correct node signs more than one digest, or if the configuration is not viable for Byzantine Fault Tolerance, then no safe agreement can be made.\n4. Produce the final answer as a single line containing a comma-separated list of integers in square brackets, one per test case, where each integer is the accepted digest identifier $h$ if agreement is safely achievable, or $-1$ if no safe agreement can be made.\n\nViability check: A classical sufficient viability condition for Byzantine Fault Tolerance is $n \\geq 3f + 1$. If this condition does not hold for a test case, the program must return $-1$ for that case.\n\nTest suite specification (all identifiers and counts are integers, and all sets are finite; for every mathematical entity, numbers are wrapped in LaTeX):\n- Test Case $1$ (happy path):\n  - $n=7$, $f=2$, correct nodes $\\{0,1,2,3,4\\}$.\n  - Digests:\n    - $h=101$ with valid signers $\\{0,1,2,3,4,5\\}$, all valid.\n    - $h=202$ with signers $\\{5,6\\}$ where node $5$ is valid and node $6$ is invalid.\n  - Expected behavior: only $h=101$ reaches the quorum; accept $101$.\n- Test Case $2$ (boundary viability):\n  - $n=4$, $f=1$, correct nodes $\\{0,1,2\\}$.\n  - Digests:\n    - $h=303$ with valid signers $\\{0,1,2\\}$, all valid.\n  - Expected behavior: accept $303$.\n- Test Case $3$ (correct-node double-signing invalidates safety):\n  - $n=7$, $f=2$, correct nodes $\\{0,1,2,3,4\\}$.\n  - Digests:\n    - $h=404$ with valid signers $\\{0,1,2,3,5\\}$, all valid.\n    - $h=505$ with valid signers $\\{0,1,2,4,6\\}$, all valid.\n  - Expected behavior: correct nodes $0,1,2$ sign two digests; reject agreement and return $-1$.\n- Test Case $4$ (non-viable configuration):\n  - $n=6$, $f=2$, correct nodes $\\{0,1,2,3\\}$.\n  - Digests:\n    - $h=606$ with valid signers $\\{0,1,2,3,4\\}$, all valid.\n  - Expected behavior: since $n  3f + 1$ (i.e., $6  7$), return $-1$.\n- Test Case $5$ (insufficient signatures):\n  - $n=7$, $f=2$, correct nodes $\\{0,1,2,3,4\\}$.\n  - Digests:\n    - $h=707$ with signers $\\{0,1,2,3\\}$, where nodes $0,1,2$ are valid and node $3$ is invalid, leaving only $3$ valid signatures.\n  - Expected behavior: no digest reaches the quorum; return $-1$.\n- Test Case $6$ (Byzantine equivocation but unique quorum):\n  - $n=10$, $f=3$, correct nodes $\\{0,1,2,3,4,5,6\\}$.\n  - Digests:\n    - $h=808$ with valid signers $\\{0,1,2,3,4,5,7\\}$, all valid.\n    - $h=909$ with valid signers $\\{7,8,9,6\\}$, all valid.\n    - $h=1000$ with valid signers $\\{8,9\\}$, all valid.\n  - Expected behavior: only $h=808$ meets the quorum; accept $808$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result_1,result_2,\\dots]$). For the above test suite, the program must output the accepted digest identifiers or $-1$ per case, in order.",
            "solution": "The problem requires the design of a simulation to determine if a safe agreement on a memory digest can be reached in a distributed system subject to Byzantine faults. The solution is derived from first principles of Byzantine Fault Tolerance (BFT), specifically focusing on the set-theoretic properties of quorums.\n\nThe process of determining the outcome for each test case is predicated on a sequence of validation steps and calculations, grounded in established BFT theory.\n\n**Step 1: System Viability Condition**\n\nThe system is described by a total of $n$ nodes, of which up to $f$ may be Byzantine. A widely established sufficient condition for a system to be able to solve consensus in the presence of $f$ Byzantine faults is that the total number of nodes $n$ must be at least $3f + 1$. This is expressed by the inequality:\n$$n \\ge 3f + 1$$\nThis condition ensures that after $f$ nodes are revealed to be faulty, the remaining $n-f$ correct nodes are numerous enough ($n-f \\ge 2f+1$) to outvote the faulty nodes, which could lie and create two opposing factions of size $f$. The problem states that if this viability condition is not met for a given test case, no safe agreement can be made, and the outcome must be $-1$.\n\n**Step 2: Derivation of the Minimal Quorum Size ($t$)**\n\nThe core of BFT safety revolves around ensuring that two conflicting proposals (e.g., for different digests $h_a$ and $h_b$) can never be simultaneously accepted by the system. Acceptance of a digest $h$ is defined as gathering a quorum of at least $t$ valid signatures from distinct nodes.\n\nLet $Q_a$ be the set of nodes that signed for digest $h_a$, and $Q_b$ be the set of nodes that signed for digest $h_b$. For both digests to be accepted, the size of these sets must meet the quorum threshold: $|Q_a| \\ge t$ and $|Q_b| \\ge t$. For our derivation, we consider the minimal case where $|Q_a| = t$ and $|Q_b| = t$.\n\nThe safety property mandates that it's impossible for two quorums on conflicting digests to be formed. A correct node, by definition, signs at most one digest per decision round. Therefore, if the intersection of any two potential quorums, $Q_a \\cap Q_b$, is guaranteed to contain at least one correct node, safety is upheld. If a correct node is in the intersection, it would be asked to sign for both $h_a$ and $h_b$. It would sign one but refuse the other, preventing one of the quorums from forming.\n\nThe worst-case scenario for safety is that the intersection $Q_a \\cap Q_b$ consists entirely of Byzantine nodes. There are at most $f$ Byzantine nodes in the system. To guarantee that the intersection contains at least one correct node, its size must be strictly greater than $f$.\n$$|Q_a \\cap Q_b| > f$$\nFrom set theory, the size of the intersection of two sets is bounded by the inclusion-exclusion principle. For a universe of $n$ nodes:\n$$|Q_a \\cap Q_b| \\ge |Q_a| + |Q_b| - n$$\nSubstituting $|Q_a| = t$ and $|Q_b| = t$, we get:\n$$|Q_a \\cap Q_b| \\ge 2t - n$$\nCombining the two inequalities to enforce the safety requirement yields:\n$$2t - n > f$$\nSolving for $t$, the quorum size:\n$$2t > n + f$$\n$$t > \\frac{n+f}{2}$$\nSince $t$ must be an integer (representing a count of nodes), the minimal integer value for $t$ that satisfies this strict inequality is obtained by taking the floor of the right-hand side and adding $1$.\n$$t = \\left\\lfloor \\frac{n+f}{2} \\right\\rfloor + 1$$\nThis formula provides the minimum number of signatures required to safely accept a digest.\n\n**Step 3: Algorithmic Procedure for Agreement**\n\nBased on the principles above, a deterministic algorithm can be formulated to evaluate each test case.\n\n1.  **Viability Check**: For the given parameters $n$ and $f$, first verify if $n \\ge 3f + 1$. If this condition is false, the system is not viable. The procedure terminates for this case, and the result is $-1$.\n\n2.  **Quorum Calculation**: If the system is viable, calculate the minimal integer quorum size $t$ using the derived formula: $t = \\lfloor \\frac{n+f}{2} \\rfloor + 1$.\n\n3.  **Signature Validation and Correctness Check**:\n    a. Initialize data structures to track the number of valid signatures for each proposed digest and to monitor the signing activity of correct nodes.\n    b. For each digest, iterate through its list of signers. A signature is counted only if it is marked as valid.\n    c. Simultaneously, check for protocol violations by correct nodes. A correct node must sign at most one digest. If a node identified as correct is found to have provided valid signatures for two or more distinct digests, this constitutes a critical safety failure. The procedure terminates for this case, and the result is $-1$. Byzantine nodes are, by definition, allowed to equivocate (sign multiple digests).\n\n4.  **Determine Final Outcome**:\n    a. After processing all signatures and confirming no correct node has double-signed, determine which digests, if any, have met the quorum threshold $t$.\n    b. Let $S$ be the set of digests that have accumulated at least $t$ valid signatures.\n    c. If $|S| = 1$, then a unique, safe agreement has been reached. The result is the identifier $h$ of the single digest in $S$.\n    d. If $|S| = 0$, no digest gathered sufficient support.\n    e. If $|S| > 1$, two or more digests have met the quorum threshold, resulting in an ambiguity that violates safety.\n    f. In both cases where $|S| \\neq 1$, no safe agreement is possible, and the result is $-1$.\n\nThis structured procedure ensures that all conditions for Byzantine fault-tolerant agreement, as specified in the problem, are rigorously checked, leading to a definitive conclusion for each scenario.",
            "answer": "```c\n#include stdio.h\n#include stdlib.h\n#include string.h\n#include math.h\n\n// #include complex.h\n// #include threads.h\n// #include stdatomic.h\n\n// The maximum number of nodes across all test cases, used for array sizing.\n#define MAX_NODES 16\n\n// A struct to hold information about a single digest proposal.\ntypedef struct {\n    int id;\n    const int* signers;\n    const int* valid_flags;\n    int num_signers;\n} Digest;\n\n// A struct to hold all parameters for a single test case.\ntypedef struct {\n    int n;\n    int f;\n    const int* correct_nodes;\n    int num_correct;\n    const Digest* digests;\n    int num_digests;\n} TestCase;\n\n// Function to solve a single test case.\nint solve_case(const TestCase* tc) {\n    // Step 1: Viability Check\n    if (tc-n  3 * tc-f + 1) {\n        return -1;\n    }\n\n    // Step 2: Calculate Quorum Size\n    int t = (tc-n + tc-f) / 2 + 1;\n\n    // Data structures for validation\n    int is_correct[MAX_NODES] = {0};\n    for (int i = 0; i  tc-num_correct; ++i) {\n        is_correct[tc-correct_nodes[i]] = 1;\n    }\n\n    int digest_counts[tc-num_digests];\n    for(int i = 0; i  tc-num_digests; ++i) {\n        digest_counts[i] = 0;\n    }\n\n    int node_signed_digest[MAX_NODES] = {0}; // Stores which digest_id a node signed (0 if none)\n    int double_sign_error = 0;\n\n    // Step 3: Signature Validation and Correctness Check\n    for (int i = 0; i  tc-num_digests; ++i) {\n        const Digest* d = tc-digests[i];\n        for (int j = 0; j  d-num_signers; ++j) {\n            if (d-valid_flags[j]) {\n                digest_counts[i]++;\n                int signer_id = d-signers[j];\n                if (signer_id  MAX_NODES  is_correct[signer_id]) {\n                    if (node_signed_digest[signer_id] != 0  node_signed_digest[signer_id] != d-id) {\n                        double_sign_error = 1;\n                    }\n                    node_signed_digest[signer_id] = d-id;\n                }\n            }\n        }\n    }\n\n    if (double_sign_error) {\n        return -1;\n    }\n\n    // Step 4: Determine Final Outcome\n    int accepted_digest_id = -1;\n    int num_accepted = 0;\n    for (int i = 0; i  tc-num_digests; ++i) {\n        if (digest_counts[i] = t) {\n            num_accepted++;\n            accepted_digest_id = tc-digests[i].id;\n        }\n    }\n\n    if (num_accepted == 1) {\n        return accepted_digest_id;\n    }\n\n    return -1;\n}\n\nint main(void) {\n    // --- Test Case 1 Data ---\n    int tc1_correct_nodes[] = {0, 1, 2, 3, 4};\n    int tc1_d1_signers[] = {0, 1, 2, 3, 4, 5};\n    int tc1_d1_valid[] = {1, 1, 1, 1, 1, 1};\n    int tc1_d2_signers[] = {5, 6};\n    int tc1_d2_valid[] = {1, 0};\n    Digest tc1_digests[] = {\n        {101, tc1_d1_signers, tc1_d1_valid, 6},\n        {202, tc1_d2_signers, tc1_d2_valid, 2}\n    };\n\n    // --- Test Case 2 Data ---\n    int tc2_correct_nodes[] = {0, 1, 2};\n    int tc2_d1_signers[] = {0, 1, 2};\n    int tc2_d1_valid[] = {1, 1, 1};\n    Digest tc2_digests[] = {\n        {303, tc2_d1_signers, tc2_d1_valid, 3}\n    };\n\n    // --- Test Case 3 Data ---\n    int tc3_correct_nodes[] = {0, 1, 2, 3, 4};\n    int tc3_d1_signers[] = {0, 1, 2, 3, 5};\n    int tc3_d1_valid[] = {1, 1, 1, 1, 1};\n    int tc3_d2_signers[] = {0, 1, 2, 4, 6};\n    int tc3_d2_valid[] = {1, 1, 1, 1, 1};\n    Digest tc3_digests[] = {\n        {404, tc3_d1_signers, tc3_d1_valid, 5},\n        {505, tc3_d2_signers, tc3_d2_valid, 5}\n    };\n\n    // --- Test Case 4 Data ---\n    int tc4_correct_nodes[] = {0, 1, 2, 3};\n    int tc4_d1_signers[] = {0, 1, 2, 3, 4};\n    int tc4_d1_valid[] = {1, 1, 1, 1, 1};\n    Digest tc4_digests[] = {\n        {606, tc4_d1_signers, tc4_d1_valid, 5}\n    };\n\n    // --- Test Case 5 Data ---\n    int tc5_correct_nodes[] = {0, 1, 2, 3, 4};\n    int tc5_d1_signers[] = {0, 1, 2, 3};\n    int tc5_d1_valid[] = {1, 1, 1, 0};\n    Digest tc5_digests[] = {\n        {707, tc5_d1_signers, tc5_d1_valid, 4}\n    };\n\n    // --- Test Case 6 Data ---\n    int tc6_correct_nodes[] = {0, 1, 2, 3, 4, 5, 6};\n    int tc6_d1_signers[] = {0, 1, 2, 3, 4, 5, 7};\n    int tc6_d1_valid[] = {1, 1, 1, 1, 1, 1, 1};\n    int tc6_d2_signers[] = {7, 8, 9, 6};\n    int tc6_d2_valid[] = {1, 1, 1, 1};\n    int tc6_d3_signers[] = {8, 9};\n    int tc6_d3_valid[] = {1, 1};\n    Digest tc6_digests[] = {\n        {808, tc6_d1_signers, tc6_d1_valid, 7},\n        {909, tc6_d2_signers, tc6_d2_valid, 4},\n        {1000, tc6_d3_signers, tc6_d3_valid, 2},\n    };\n\n    // Define the test cases from the problem statement.\n    TestCase test_cases[] = {\n        {7, 2, tc1_correct_nodes, 5, tc1_digests, 2},\n        {4, 1, tc2_correct_nodes, 3, tc2_digests, 1},\n        {7, 2, tc3_correct_nodes, 5, tc3_digests, 2},\n        {6, 2, tc4_correct_nodes, 4, tc4_digests, 1},\n        {7, 2, tc5_correct_nodes, 5, tc5_digests, 1},\n        {10, 3, tc6_correct_nodes, 7, tc6_digests, 3},\n    };\n\n    // Calculate the number of test cases.\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    int results[num_cases];\n\n    // Calculate the result for each test case.\n    for (int i = 0; i  num_cases; ++i) {\n        results[i] = solve_case(test_cases[i]);\n    }\n\n    // Print the results in the EXACT REQUIRED format.\n    printf(\"[\");\n    for (int i = 0; i  num_cases; ++i) {\n        printf(\"%d\", results[i]);\n        if (i  num_cases - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\");\n\n    return EXIT_SUCCESS;\n}\n```"
        }
    ]
}