{
    "hands_on_practices": [
        {
            "introduction": "在深入探讨如何设计和优化调度策略之前，我们首先需要具备一项关键技能：如何从系统行为中识别出正在运行的策略。本练习将让你扮演一名系统性能侦探的角色。通过分析真实世界中常见的 CPU 核心队列长度时间序列数据，你将学习如何运用跨相关性分析等技术，揭示不同迁移策略（推式迁移与拉式迁移）在数据中留下的独特“因果指纹”。",
            "id": "3674334",
            "problem": "一个对称双核调度器维护每个核心的可运行队列长度 $q_1(t)$ 和 $q_2(t)$，在离散时间 $t \\in \\{0,1,2,3,4,5,6,7,8\\}$ 以采样间隔 $\\Delta t = 1$ 进行采样。假设外部到达在核心间平均是平衡的，并且每个核心的服务量在样本间近似恒定。考虑两种典型的迁移策略：推送迁移（一个过载的核心主动将任务转移到其他核心）和拉取迁移（一个欠载的核心主动从其他核心获取任务）。\n\n给定一个队列长度的跟踪记录：\n- $t=0,1,\\dots,8$ 时的 $q_1(t)$: $[\\,3,4,5,5,4,3,2,2,2\\,]$，\n- $t=0,1,\\dots,8$ 时的 $q_2(t)$: $[\\,1,1,1,2,3,3,3,2,2\\,]$。\n\n设离散时间导数由后向差分定义为 $\\dot q_j(t) \\approx q_j(t)-q_j(t-1)$ (当 $t \\ge 1$ 时)。考虑在滞后 $\\tau$ 处的样本互相关，对于两个在其公共支撑集上的零均值序列 $x(t)$ 和 $y(t)$，其定义为\n$$\n\\rho_{xy}(\\tau) \\;=\\; \\frac{\\sum_t \\big(x(t-\\tau)-\\bar x\\big)\\big(y(t)-\\bar y\\big)}{\\sqrt{\\sum_t \\big(x(t-\\tau)-\\bar x\\big)^2}\\,\\sqrt{\\sum_t \\big(y(t)-\\bar y\\big)^2}},\n$$\n其中 $\\bar x$ 和 $\\bar y$ 是样本均值。将 $\\tau>0$ 解释为 $x$ 领先于 $y$。\n\n使用提供的跟踪记录，构建 $t=1,\\dots,8$ 时的 $\\dot q_2(t)$，并根据推送迁移和拉取迁移的定义，结合互相关的定义，通过分析 $\\mathrm{corr}\\big(q_1,\\dot q_2\\big)$ 的显著峰值的符号和滞后，来判断哪种迁移策略与数据更一致。选择唯一的最佳选项：\n\nA. 系统使用推送迁移：$q_1$ 领先于 $\\dot q_2$；$\\mathrm{corr}\\big(q_1,\\dot q_2\\big)$ 在一个小的正滞后 $\\tau>0$ 处有一个强的正峰值。\n\nB. 系统使用拉取迁移：当 $q_2$ 欠载时启动迁移；$\\mathrm{corr}\\big(q_1,\\dot q_2\\big)$ 在一个负滞后 $\\tau0$ 处达到峰值，或者对于 $\\tau0$ 时相关性很弱。\n\nC. 系统使用拉取迁移，但 $q_1$ 仍然以一个强的正峰值在 $\\tau0$ 处领先于 $\\dot q_2$。\n\nD. 无法推断出任何一种策略：对于小的 $|\\tau|$，$\\mathrm{corr}\\big(q_1,\\dot q_2\\big)$ 近似为零。",
            "solution": "### 每种策略的理论预期：\n\n1.  **推送迁移：**\n    *   该策略的触发条件是一个核心变得过载。在我们的双核系统中，如果核心1过载，其队列长度 $q_1(t)$ 将会很高。\n    *   作为一项主动措施，核心1将“推送”一个任务到核心2以平衡负载。\n    *   这个被推送的任务到达核心2将导致其队列长度 $q_2$ 增加。这对应于队列长度变化的一个正值，即 $\\dot q_2  0$。\n    *   这里存在一个因果关系：时刻 $t$ 的高 $q_1$ 会导致稍后时刻 $t+\\tau$ 的正 $\\dot q_2$，其中 $\\tau  0$ 是包含决策和迁移时间的滞后。\n    *   这意味着时间序列 $q_1(t)$ 和 $\\dot q_2(t)$ 之间存在正相关。由于原因（$q_1$）先于结果（$\\dot q_2$），我们预期互相关函数 $\\rho_{q_1 \\dot q_2}(\\tau)$ 会在一个小的正滞后 $\\tau  0$ 处表现出显著的正峰值。\n\n2.  **拉取迁移：**\n    *   该策略的触发条件是一个核心变得欠载。如果核心2欠载，其队列长度 $q_2(t)$ 将会很低。\n    *   核心2将从另一个核心（在此情况下必须是核心1）“拉取”一个任务。这只有在核心1有任务可给时才会发生，因此 $q_1(t)$ 必须足够大。\n    *   成功拉取的结果是 $q_2$ 增加，意味着 $\\dot q_2  0$。\n    *   直接的触发因素是核心2的状态（低 $q_2$），而不是核心1。$q_1$ 的状态是一个必要的前提条件，而不是迁移事件的直接原因。\n    *   因此，仅 $q_1$ 与变化 $\\dot q_2$ 之间的因果联系没有推送迁移中那么直接。我们可能预期对于 $\\tau  0$，相关性 $\\rho_{q_1 \\dot q_2}(\\tau)$ 会较弱，或者关系更复杂，可能还涉及到 $q_2$ 的状态。在 $\\tau  0$ 处出现强正峰值的特征不是拉取迁移的主要预期。\n\n### 数据分析：\n\n让我们根据给定的跟踪记录计算相关量。\n\n*   $q_1(t) = [\\,3, 4, 5, 5, 4, 3, 2, 2, 2\\,]$ (当 $t=0, \\dots, 8$)\n*   $q_2(t) = [\\,1, 1, 1, 2, 3, 3, 3, 2, 2\\,]$ (当 $t=0, \\dots, 8$)\n\n首先，我们计算 $t=1, \\dots, 8$ 时 $\\dot q_2(t) = q_2(t) - q_2(t-1)$ 的序列：\n*   $\\dot q_2(1) = 1-1=0$\n*   $\\dot q_2(2) = 1-1=0$\n*   $\\dot q_2(3) = 2-1=1$\n*   $\\dot q_2(4) = 3-2=1$\n*   $\\dot q_2(5) = 3-3=0$\n*   $\\dot q_2(6) = 3-3=0$\n*   $\\dot q_2(7) = 2-3=-1$\n*   $\\dot q_2(8) = 2-2=0$\n\n因此，要进行相关的序列是 $x(t) = q_1(t)$ 和 $y(t) = \\dot q_2(t) = [\\,0, 0, 1, 1, 0, 0, -1, 0\\,]$ (当 $t=1, \\dots, 8$)。我们需要找到 $\\rho_{xy}(\\tau) = \\mathrm{corr}\\big(q_1, \\dot q_2\\big)(\\tau)$ 的显著峰值的滞后 $\\tau$。\n\n我们将为小的整数滞后 $|\\tau|$ 计算互相关的分子，即样本协方差。协方差的峰值对应于相关的峰值。协方差的公式是 $C_{xy}(\\tau) = \\sum_t (x(t-\\tau) - \\bar{x})(y(t) - \\bar{y})$，其中求和是在公共时间支撑集上进行的，均值是在该支撑集上的序列上计算的。\n\n**情况 $\\tau = 1$ ($q_1$ 领先于 $\\dot q_2$)：**\n求和范围为 $t \\in [1, 8]$。\n*   序列 $x(t-1)$ 是 $q_1(0...7) = [\\,3, 4, 5, 5, 4, 3, 2, 2\\,]$。其均值为 $\\bar x = (3+4+5+5+4+3+2+2)/8 = 28/8 = 3.5$。\n*   序列 $y(t)$ 是 $\\dot q_2(1...8) = [\\,0, 0, 1, 1, 0, 0, -1, 0\\,]$。其均值为 $\\bar y = (0+0+1+1+0+0-1+0)/8 = 1/8 = 0.125$。\n*   未中心化的互积和为 $\\sum_{t=1}^8 q_1(t-1) \\dot q_2(t) = 5\\cdot1 + 5\\cdot1 + 2\\cdot(-1) = 8$。\n*   协方差为 $C_{xy}(1) = \\sum x y - N \\bar x \\bar y = 8 - 8 \\cdot (3.5) \\cdot (0.125) = 8 - 3.5 = 4.5$。\n\n**情况 $\\tau = 0$ (零滞后)：**\n求和范围为 $t \\in [1, 8]$。\n*   序列 $x(t)$ 是 $q_1(1...8) = [\\,4, 5, 5, 4, 3, 2, 2, 2\\,]$。其均值为 $\\bar x = (4+5+5+4+3+2+2+2)/8 = 27/8 = 3.375$。\n*   序列 $y(t)$ 是 $\\dot q_2(1...8)$，与之前相同，$\\bar y = 0.125$。\n*   未中心化的互积和为 $\\sum_{t=1}^8 q_1(t) \\dot q_2(t) = 5\\cdot1 + 4\\cdot1 + 2\\cdot(-1) = 7$。\n*   协方差为 $C_{xy}(0) = \\sum x y - N \\bar x \\bar y = 7 - 8 \\cdot (3.375) \\cdot (0.125) = 7 - 3.375 = 3.625$。\n\n**情况 $\\tau = 2$ ($q_1$ 领先于 $\\dot q_2$)：**\n求和范围为 $t \\in [2, 8]$。\n*   序列 $x(t-2)$ 是 $q_1(0...6) = [\\,3, 4, 5, 5, 4, 3, 2\\,]$。其均值为 $\\bar x = (3+4+5+5+4+3+2)/7 = 26/7 \\approx 3.714$。\n*   序列 $y(t)$ 是 $\\dot q_2(2...8) = [\\,0, 1, 1, 0, 0, -1, 0\\,]$。其均值为 $\\bar y = (0+1+1+0+0-1+0)/7 = 1/7 \\approx 0.143$。\n*   未中心化的互积和为 $\\sum_{t=2}^8 q_1(t-2) \\dot q_2(t) = 4\\cdot1 + 5\\cdot1 + 3\\cdot(-1) = 6$。\n*   协方差为 $C_{xy}(2) = \\sum x y - N \\bar x \\bar y = 6 - 7 \\cdot (26/7) \\cdot (1/7) = 6 - 26/7 = (42-26)/7 = 16/7 \\approx 2.286$。\n\n协方差值为 $C(1)=4.5$，$C(0)=3.625$，$C(2)\\approx 2.286$。协方差明显为正，并在滞后 $\\tau=1$ 处有一个显著的峰值。为了确认相关的强度，我们可以计算 $\\rho(1)$。\n*   $\\rho(1)$ 的分母：$\\sqrt{\\sum (x-\\bar x)^2} \\sqrt{\\sum (y-\\bar y)^2}$。\n*   对于 $x(t-1)$，中心化序列为 $[ -0.5, 0.5, 1.5, 1.5, 0.5, -0.5, -1.5, -1.5 ]$。平方和为 $10$。\n*   对于 $y(t)$，中心化序列为 $[ -0.125, -0.125, 0.875, 0.875, -0.125, -0.125, -1.125, -0.125 ]$。平方和为 $184/64 = 2.875$。\n*   $\\rho(1) = \\frac{4.5}{\\sqrt{10} \\sqrt{2.875}} \\approx \\frac{4.5}{3.162 \\times 1.696} \\approx \\frac{4.5}{5.362} \\approx 0.839$。\n\n这是一个非常强的正相关。数据表明，核心1上的高队列长度是核心2队列长度在下一个时间步增加的强预测因子。这个观察结果是推送迁移的一个典型特征。\n\n### 第三步：逐项分析选项\n\n**A. 系统使用推送迁移：$q_1$ 领先于 $\\dot q_2$；$\\mathrm{corr}\\big(q_1,\\dot q_2\\big)$ 在一个小的正滞后 $\\tau0$ 处有一个强的正峰值。**\n该陈述与我们对推送迁移的理论推理和对所提供数据的分析完全一致。我们在 $\\tau = 1$ 的正滞后处发现了一个强的正相关系数（$\\rho \\approx 0.839$）。在 $\\tau=1$ 处的峰值意味着 $q_1$ 领先于 $\\dot q_2$。\n**结论：正确。**\n\n**B. 系统使用拉取迁移：当 $q_2$ 欠载时启动迁移；$\\mathrm{corr}\\big(q_1,\\dot q_2\\big)$ 在一个负滞后 $\\tau0$ 处达到峰值，或者对于 $\\tau0$ 时相关性很弱。**\n该陈述声称对于拉取迁移，相关性要么在 $\\tau  0$ 时很弱，要么在 $\\tau  0$ 处达到峰值。我们的数据分析发现，在 $\\tau=1  0$ 处存在*强*相关性，这与这两种可能性都相矛盾。因此，数据与为拉取迁移描述的特征不一致。\n**结论：不正确。**\n\n**C. 系统使用拉取迁移，但 $q_1$ 仍然以一个强的正峰值在 $\\tau0$ 处领先于 $\\dot q_2$。**\n这个选项表明系统正在使用拉取迁移，但巧合地表现出推送迁移的特征。虽然复杂的系统动力学有时会产生误导性的相关性，但奥卡姆剃刀定律建议我们应选择最简单的解释。观察到的特征是推送迁移的典型预期。在有此证据的情况下断言策略是拉取迁移需要一个独立的、有说服力的理由，而这里并未提供。从数据得出的最直接结论是该策略是推送迁移。\n**结论：不正确。**\n\n**D. 无法推断出任何一种策略：对于小的 $|\\tau|$，$\\mathrm{corr}\\big(q_1,\\dot q_2\\big)$ 近似为零。**\n该陈述声称相关性可以忽略不计。我们的计算表明，在 $\\tau=1$ 时相关性是强且正的，$\\rho(1) \\approx 0.839$，这远非零。因此，这个陈述在事实上是不正确的。\n**结论：不正确。**\n\n数据分析为推送迁移策略提供了强有力的证据，因为其特征信号在 $q_1$ 和 $\\dot q_2$ 之间的相关性中清晰可见。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "理解了如何识别迁移策略后，下一个自然的问题是：迁移总是值得的吗？任务迁移并非没有代价，其开销有时甚至会抵消负载均衡带来的好处。本练习将引导你从观察转向建模，关注一个关键但常被忽视的成本——因迁移引起的内存系统开销，特别是转换旁路缓冲区（TLB）刷新的成本。你将亲手构建一个简洁而强大的成本模型，量化这一开销，并学会如何基于工作负载的特性（如工作集大小）来做出明智的迁移决策。",
            "id": "3674362",
            "problem": "一个多核操作系统采用两种负载均衡策略：推送迁移（push migration），即一个繁忙的核心主动将一个可运行的线程移动到另一个核心；以及拉取迁移（pull migration），即一个空闲的核心在检测到不平衡时拉取一个线程。考虑线程在核心之间迁移所导致的内存翻译开销。底层架构提供了一个转译后备缓冲器（TLB），用于缓存页翻译。迁移线程的地址空间由地址空间标识符（ASID）标识，但假设在该平台上，操作系统通过向源核心发送处理器间中断（IPI）来执行逐页的 TLB 击落（TLB shootdown），以使迁移地址空间的潜在陈旧翻译失效，并且目标核心在首次接触线程工作集的每个不同页面时都必须承担 TLB 重新填充的开销。\n\n使用以下符合上下文的基本条件和假设：\n- 转译后备缓冲器（TLB）有 $E$ 个条目的容量，每个条目缓存一个页面的翻译。\n- 线程的工作集跨越 $n$ 个不同的页面。\n- 在源核心上，每次逐页 TLB 失效（例如类似于 invalidate page 的指令）的成本为每个失效条目 $t_{\\text{invlpg}}$ 秒，而分派和处理处理器间中断（IPI）的固定开销为每次击落事件 $t_{\\text{ipi}}$ 秒。\n- 在目标核心上，每次首次访问工作集中尚未在 TLB 中的不同页面都会导致一次 TLB 未命中，在 TLB 为该地址空间预热之前，每次访问不同页面的成本为 $t_{\\text{miss}}$ 秒。\n- 在单次迁移中，超出 TLB 容量的页面不会导致超过 $E$ 次的额外失效或未命中，因为 TLB 中一次最多只能驻留 $E$ 个不同的翻译。\n\n任务：\n1. 从以上定义出发，推导一个闭式表达式 $S(n)$，表示在两个核心上由于 TLB 击落和 TLB 重新填充所产生的总迁移开销时间，该表达式用 $n$、$E$、$t_{\\text{ipi}}$、$t_{\\text{invlpg}}$ 和 $t_{\\text{miss}}$ 表示。您的表达式必须对大小地址空间都有效，并应根据 TLB 容量解释任何饱和行为的使用。\n2. 给定 $E = 512$，$t_{\\text{ipi}} = 3.0 \\times 10^{-6}$ 秒，$t_{\\text{invlpg}} = 8.0 \\times 10^{-8}$ 秒，以及 $t_{\\text{miss}} = 4.0 \\times 10^{-8}$ 秒，计算 $S(n)$ 对于一个页面数为 $n_{s} = 32$ 的“小”地址空间和一个页面数为 $n_{\\ell} = 4096$ 的“大”地址空间的值。将两个结果都以微秒表示，并四舍五入到四位有效数字。\n3. 假设推送迁移的主动效益（例如，减少运行队列等待时间）为每次迁移 $G$ 秒。用一个单一的闭式解析表达式，推导阈值页面数 $n^{\\star}$（作为 $E$、$t_{\\text{ipi}}$、$t_{\\text{invlpg}}$、$t_{\\text{miss}}$ 和 $G$ 的函数），当页面数超过此阈值时，推送迁移会适得其反，即 $S(n)  G$。\n\n将您的最终结果表示为一个行向量 $\\big[ S(n_{s})\\text{ in }\\mu\\text{s},\\ S(n_{\\ell})\\text{ in }\\mu\\text{s},\\ n^{\\star} \\big]$，并注意数值条目必须四舍五入到四位有效数字。不要在加框的最终答案中包含单位，但在您的中间计算过程中明确说明微秒。",
            "solution": "### 求解推导\n\n总迁移开销 $S(n)$ 是源核心上的开销（TLB 击落）和目标核心上的开销（TLB 重新填充）之和。\n\n$S(n) = T_{\\text{shootdown}} + T_{\\text{refill}}$\n\n**1. 开销表达式 $S(n)$ 的推导**\n\n源核心上的 TLB 击落过程包括一次用于启动失效的处理器间中断（IPI），以及使每个相关 TLB 条目失效的成本。一个工作集为 $n$ 页的线程在 TLB 中最多可以有 $n$ 个条目。然而，TLB 的容量限制为 $E$ 个条目。因此，该线程在源核心的 TLB 中可能存在的条目数是 $n$ 和 $E$ 的最小值。问题陈述确认了这种饱和行为。因此，击落开销为：\n$$T_{\\text{shootdown}} = t_{\\text{ipi}} + \\min(n, E) \\cdot t_{\\text{invlpg}}$$\n这里，$t_{\\text{ipi}}$ 是击落事件的一次性成本，而 $\\min(n, E) \\cdot t_{\\text{invlpg}}$ 是取决于要失效的页面数量的可变成本。\n\nTLB 重新填充过程发生在目标核心上。当线程开始执行时，其工作集中的 $n$ 个页面不在新核心的 TLB 中。每次首次访问这 $n$ 个不同页面中的一个都会导致一次 TLB 未命中，产生 $t_{\\text{miss}}$ 的成本。与击落成本类似，问题明确指出未命中的次数上限为 TLB 容量 $E$。因此，需要计算的未命中次数为 $\\min(n, E)$。重新填充的开销是：\n$$T_{\\text{refill}} = \\min(n, E) \\cdot t_{\\text{miss}}$$\n\n将这两个部分组合起来，得到总迁移开销 $S(n)$：\n$$S(n) = \\left( t_{\\text{ipi}} + \\min(n, E) \\cdot t_{\\text{invlpg}} \\right) + \\left( \\min(n, E) \\cdot t_{\\text{miss}} \\right)$$\n提取公因式 $\\min(n, E)$，我们得到总开销的最终闭式表达式：\n$$S(n) = t_{\\text{ipi}} + \\min(n, E) \\cdot (t_{\\text{invlpg}} + t_{\\text{miss}})$$\n该表达式正确地模拟了当工作集小于 TLB 容量时（$n \\le E$，其中 $\\min(n, E) = n$）开销的线性增长，以及当工作集大于 TLB 容量时（$n  E$，其中 $\\min(n, E) = E$）开销的饱和。\n\n**2. 计算 $S(n_{s})$ 和 $S(n_{\\ell})$**\n\n给定以下数值：\n- $E = 512$\n- $t_{\\text{ipi}} = 3.0 \\times 10^{-6}$ s\n- $t_{\\text{invlpg}} = 8.0 \\times 10^{-8}$ s\n- $t_{\\text{miss}} = 4.0 \\times 10^{-8}$ s\n\n首先，我们预先计算合并的每页成本：\n$$t_{\\text{invlpg}} + t_{\\text{miss}} = 8.0 \\times 10^{-8} \\, \\text{s} + 4.0 \\times 10^{-8} \\, \\text{s} = 12.0 \\times 10^{-8} \\, \\text{s} = 1.2 \\times 10^{-7} \\, \\text{s}$$\n\n对于“小”地址空间，$n_{s} = 32$。由于 $n_{s}  E$（$32  512$），我们有 $\\min(n_{s}, E) = 32$。\n$$S(32) = t_{\\text{ipi}} + 32 \\cdot (t_{\\text{invlpg}} + t_{\\text{miss}})$$\n$$S(32) = 3.0 \\times 10^{-6} + 32 \\cdot (1.2 \\times 10^{-7})$$\n$$S(32) = 3.0 \\times 10^{-6} + 3.84 \\times 10^{-6} = 6.84 \\times 10^{-6} \\, \\text{s}$$\n换算成微秒，即为 $6.84 \\, \\mu\\text{s}$。保留四位有效数字，为 $6.840 \\, \\mu\\text{s}$。\n\n对于“大”地址空间，$n_{\\ell} = 4096$。由于 $n_{\\ell} > E$（$4096 > 512$），我们有 $\\min(n_{\\ell}, E) = E = 512$。\n$$S(4096) = t_{\\text{ipi}} + E \\cdot (t_{\\text{invlpg}} + t_{\\text{miss}})$$\n$$S(4096) = 3.0 \\times 10^{-6} + 512 \\cdot (1.2 \\times 10^{-7})$$\n$$S(4096) = 3.0 \\times 10^{-6} + 61.44 \\times 10^{-6} = 64.44 \\times 10^{-6} \\, \\text{s}$$\n换算成微秒，即为 $64.44 \\, \\mu\\text{s}$。该值已有四位有效数字。\n\n**3. 阈值页面数 $n^{\\star}$ 的推导**\n\n当迁移开销 $S(n)$ 超过效益 $G$ 时，推送迁移会适得其反。阈值 $n^{\\star}$ 是开销等于效益时的页面数，即 $S(n^{\\star}) = G$。\n$$t_{\\text{ipi}} + \\min(n^{\\star}, E) \\cdot (t_{\\text{invlpg}} + t_{\\text{miss}}) = G$$\n只有在开销未饱和的情况下，才能解出 $n^{\\star}$。从有益到适得其反的交叉点必须发生在成本函数的线性区域，即 $n^{\\star} \\le E$。如果效益 $G$ 大于可能的最大开销 $S(E) = t_{\\text{ipi}} + E (t_{\\text{invlpg}} + t_{\\text{miss}})$，那么迁移永远不会适得其反，也就不存在有限的阈值 $n^{\\star}$。假设这样的阈值确实存在（即 $G$ 不会过大），我们可以在线性区域（其中 $\\min(n^{\\star}, E) = n^{\\star}$）求解 $n^{\\star}$：\n$$t_{\\text{ipi}} + n^{\\star} \\cdot (t_{\\text{invlpg}} + t_{\\text{miss}}) = G$$\n求解 $n^{\\star}$：\n$$n^{\\star} \\cdot (t_{\\text{invlpg}} + t_{\\text{miss}}) = G - t_{\\text{ipi}}$$\n$$n^{\\star} = \\frac{G - t_{\\text{ipi}}}{t_{\\text{invlpg}} + t_{\\text{miss}}}$$\n如果 $G  t_{\\text{ipi}}$，该表达式对于页面数阈值具有物理意义，得出 $n^{\\star}  0$。如果 $G \\le t_{\\text{ipi}}$，那么对于任何大小的工作集（$n  0$），任何迁移都是适得其反的，使得有效阈值为 $0$。推导出的表达式是在阈值存在于线性成本域（$0 \\le n^{\\star} \\le E$）的条件下，阈值 $n^{\\star}$ 的通用解析解。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n6.840  64.44  \\frac{G - t_{\\text{ipi}}}{t_{\\text{invlpg}} + t_{\\text{miss}}}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "经过观察识别和成本建模，现在是时候将所有知识付诸实践了。本练习是本章的综合性顶石实践，要求你从零开始，在一个精确定义的离散时间模拟环境中实现推式和拉式迁移这两种核心调度策略。通过编写代码并在一系列不同负载场景（从均衡到高度倾斜）下进行测试，你将能够直接比较它们的性能表现，从而对这些策略的内在机制、适用场景和对系统整体性能（如吞吐量和任务周转时间）的影响，形成最深刻、最直观的理解。",
            "id": "3674377",
            "problem": "考虑一个对称多处理器调度器，其拥有 $C$ 个相同的核心，这些核心不共享硬件中断。时钟中断根据离散时间下的伯努利过程独立地到达每个核心。在时间 $t$ 核心 $i$ 上的一个时钟中断会创建一个新的、由计时器驱动的任务，并将其加入核心 $i$ 的本地运行队列。每个新创建的任务需要 $S$ 个单位量子（quantum）的中央处理器（CPU）服务才能完成。时间以整数时间滴答（tick） $t \\in \\{0,1,2,\\dots,H-1\\}$ 的形式推进。在每个滴答内，一个核心最多能对单个任务执行一个单位量子的计算。在每个核心的运行队列内部，任务按先到先服务（FCFS）的原则进行调度。当一个任务成为运行队列的头部时，它会保持为该核心上当前运行的任务，跨越多个滴答，直到其所有 $S$ 个量子被消耗完毕。迁移（如果允许）只转移当前未在运行的任务（不假设迁移成本）。所有队列初始为空。\n\n用作基础的基本定义：\n- 在每个滴答中，核心 $i$ 以概率 $q_i \\in [0,1]$ 接收到一个时钟中断，此事件在核心间和时间上均独立。这是每个核心参数为 $q_i$ 的独立同分布伯努利过程。\n- 在时间 $t$，核心 $i$ 的运行队列长度定义为 $L_i(t) = W_i(t) + R_i(t)$，其中 $W_i(t)$ 是等待中（非当前运行）的任务数量，而 $R_i(t) \\in \\{0,1\\}$ 指示核心 $i$ 上是否有当前正在运行的任务。\n- 每个滴答的总服务容量是 $C$ 个单位量子，而以任务数计算的服务容量上限为 $C/S$，因为每个任务需要 $S$ 个单位量子。\n\n需要建模两种迁移策略：\n- 推送迁移（Push migration）：在固定的 $P$ 个滴答的平衡间隔，即在满足 $t \\bmod P = 0$ 的滴答 $t$，一个全局平衡器会重复选择具有最大 $L_j(t)$ 的核心 $j$ 和具有最小 $L_k(t)$ 的核心 $k$。如果 $L_j(t) - L_k(t) \\ge 2$ 且核心 $j$ 至少有一个等待中的任务（$W_j(t) \\ge 1$），平衡器会将一个等待中的任务从核心 $j$ 队列的尾部移动到核心 $k$ 队列的尾部。此过程重复进行，直到 $L_j(t) - L_k(t) \\le 1$ 或没有可移动的任务为止。正在运行的任务不可移动。\n- 拉取迁移（Pull migration）：在每个滴答中，执行之前，每个 $L_i(t) = 0$ 的核心 $i$ 会尝试从当前负载最高的核心 $j$（根据 $L_j(t)$ 判断）窃取一个等待中的任务，前提是 $L_j(t) - L_i(t) \\ge 2$ 且 $W_j(t) \\ge 1$。被窃取的任务从核心 $j$ 队列的尾部移除，并附加到核心 $i$ 队列的尾部。若存在多个负载最高的核心，则通过最小的核心索引来解决平局。\n\n离散时间模型的仿真规则：\n- 每个滴答 $t$ 内的顺序：\n  1. 对于每个核心 $i$，以概率 $q_i$ 在时间 $t$ 有一个新任务到达，并被加入核心 $i$ 队列的尾部，其到达时间戳记为 $t$。在同一个滴答内，同一个核心上不可能有多个任务到达。\n  2. 应用推送或拉取迁移策略。\n  3. 对于每个核心 $i$：\n     - 如果没有当前运行的任务且等待队列非空，则等待队列头部的任务成为当前运行的任务。\n     - 如果存在当前运行的任务，它会执行一个单位量子。如果这完成了其剩余服务，任务离开系统，其流转时间（flow time）贡献为 $(t+1) - \\text{arrival\\_time}$。\n- 所有随机选择必须由一个具有固定种子的确定性伪随机数生成器生成，以确保可复现性。使用一个线性同余生成器（LCG），其模为 $2^{64}$，乘数为 $a = 6364136223846793005$，增量为 $c = 1$，初始种子为 $s_0 = 0xDEADBEEFCAFEBABE$。在每一步，状态演变为 $s_{n+1} = (a \\cdot s_n + c) \\bmod 2^{64}$。要获得 $[0,1)$ 内的均匀实数变量，构造 $u_n = \\lfloor s_n / 2^{11} \\rfloor / 2^{53}$。\n\n在时间范围 $H$ 内，为每种策略测量的指标：\n- 到时间 $H$ 为止完成的任务数 $T$（整数）。\n- 所有已完成任务的平均流转时间 $F$，定义为 $(\\text{completion\\_time} - \\text{arrival\\_time})$ 的算术平均值（实数）。\n\n您的任务是编写一个完整的、可运行的程序，实现指定的仿真，并为以下测试套件生成指标。每个测试用例指定了 $(C,H,S,P,\\mathbf{q})$：\n- 测试 A（均衡中断）：$C=4$, $H=5000$, $S=3$, $P=20$, $\\mathbf{q} = [0.02, 0.02, 0.02, 0.02]$。\n- 测试 B（偏向一个核心）：$C=4$, $H=5000$, $S=3$, $P=20$, $\\mathbf{q} = [0.07, 0.005, 0.005, 0.005]$。\n- 测试 C（极端偏斜，多核心空闲）：$C=8$, $H=5000$, $S=3$, $P=10$, $\\mathbf{q} = [0.10, 0, 0, 0, 0, 0, 0, 0]$。\n\n需遵循的科学真实性和基本约束：\n- 稳定性考虑：每个滴答的预期总到达率（以单位量子计）为 $\\sum_{i=1}^{C} q_i \\cdot S$，为保证排队机制稳定，其期望值受服务容量 $C$ 的限制。您的参数满足 $\\sum_{i=1}^{C} q_i \\cdot S \\le C$。\n- 所有迁移只移动等待中的任务，并保留每个任务的剩余服务需求和原始到达时间。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个列表，每个测试用例对应一个条目。每个条目必须是列表 $[T_{\\text{push}}, T_{\\text{pull}}, F_{\\text{push}}, F_{\\text{pull}}]$，并严格遵守此顺序，其中 $T_{\\text{push}}$ 和 $T_{\\text{pull}}$ 是整数，$F_{\\text{push}}$ 和 $F_{\\text{pull}}$ 是浮点数。整个输出为单行，格式完全如下：\n  - 例如，$\\texttt{[[Tp1,Tl1,Fp1,Fl1],[Tp2,Tl2,Fp2,Fl2],[Tp3,Tl3,Fp3,Fl3]]}$，数字之间用逗号分隔，无额外空格。\n\n您的程序必须是自包含的，不接受任何输入。它必须严格按照定义实现策略，使用指定的生成器和种子，并应用上述的滴答内操作顺序。",
            "solution": "### 基于原则的设计与解决方案\n\n解决方案需要仔细实现一个离散时间仿真。程序的核心将是一个主函数 `run_simulation`，它为给定的策略和参数集执行整个过程。这确保了每次仿真运行的状态被正确隔离和重置，从而允许在相同的、确定性生成的到达模式下对推送和拉取策略进行公平比较。\n\n**数据结构**：\n-   **Task**：为了表示一个工作单元，定义了一个 `Task` 结构体。它存储其 `arrival_time` 和 `remaining_service`。为了便于高效的队列管理（队尾入队、队首出队以及为了迁移而从队尾移除），双向链表是理想的数据结构。因此，`Task` 也将包含 `next` 和 `prev` 指针。\n-   **Core**：一个 `Core` 结构体代表一个 CPU。它包含其到达概率 `q`、一个指向 `running_task` 的指针，以及指向 `wait_queue_head` 和 `wait_queue_tail` 的指针来管理其本地运行队列。我们还显式跟踪 `wait_queue_length`（$W_i$），以便高效计算总负载 $L_i$。\n-   **PRNG**：指定的 LCG 将使用 `unsigned long long` 来表示 $64$ 位状态。\n\n**仿真循环**：\n仿真以离散时间步从 $t=0$ 推进到 $t=H-1$。每个滴答内的操作严格遵循规定的顺序：\n1.  **到达**：对每个核心，生成一个随机数。如果它小于核心的到达概率 $q_i$，则创建一个新任务并将其加入其等待队列的尾部。\n2.  **迁移**：调用相应的迁移逻辑（推送或拉取）。\n    -   **推送**：在周期性间隔（$t \\bmod P = 0$），进入一个平衡循环。它重复地识别负载最高和最低的核心。如果负载差异显著（$\\ge 2$）且负载最高的核心有等待任务，则将一个任务从队尾移到另一个队尾。此过程持续到系统平衡或没有更多可移动的任务。对于在具有最大/最小负载的核心中选择给予者/接受者，将假定采用最小索引平局决胜规则以确保确定性。\n    -   **拉取**：在每个滴答中，每个空闲核心（$L_i=0$）都试图窃取工作。它识别出负载最高的核心（使用指定的最小索引平局决胜规则），如果条件允许（$L_j \\ge 2, W_j \\ge 1$），则窃取最新的等待任务。每次窃取后系统状态都会更新，这会影响同一滴答内后续的窃取尝试。\n3.  **执行**：更新每个核心的状态。如果一个核心空闲但有任务在等待，其队列头部的任务将成为新的 `running_task`。如果一个核心有 `running_task`，其服务需求将减少。如果服务完成，任务将退役，其流转时间计算为 $(t+1) - \\text{arrival\\_time}$ 并进行累加。\n\n**指标计算**：\n达到仿真时域 $H$ 后，使用完成的总任务数 $T$ 和它们的流转时间总和来计算平均流转时间 $F$。如果 $T=0$，则平均流转时间未定义，但将报告为 $0.0$。\n\n`main` 函数协调整个过程。它遍历预定义的测试用例。对于每个用例，它分别为推送策略和拉取策略各调用一次 `run_simulation`，确保每次调用时 PRNG 和所有系统状态都重置为其初始值。结果被收集起来，并最终以精确指定的格式打印。对所有任务（包括已完成的和仍在队列中的）的内存都进行了仔细管理，以防止泄漏。",
            "answer": "```c\n#include"
        }
    ]
}