{
    "hands_on_practices": [
        {
            "introduction": "我们从一个最基础的分布式互斥算法——令牌环（token ring）开始。通过分析一个网络延迟异构的系统中请求者的等待时间，你将练习计算确定性分布式算法的关键性能指标。这个练习旨在深化你对分布式环境下最坏情况与平均情况分析的理解。",
            "id": "3638426",
            "problem": "考虑一个用于分布式互斥的单向令牌环，其中有 $N$ 个进程，标记为 $P_{1}, P_{2}, \\ldots, P_{N}$。从 $P_{i}$ 到 $P_{i+1}$ 的有向链接（索引对 $N$ 取模，因此 $P_{N+1} \\equiv P_{1}$）具有一个确定的跳跃延迟 $d_{i} \\gt 0$，该延迟包括传输和转发延迟。令牌不断循环；当一个进程有待处理的临界区请求时，它在令牌到达时捕获令牌，进入临界区，并立即转发令牌，其额外的持有时间可忽略不计。\n\n假设发出单个请求的过程如下：首先，从 $\\{P_{1}, \\ldots, P_{N}\\}$ 中均匀随机地选择一个请求者；其次，其请求时间与令牌的运动无关，并且在令牌周期的稳态阶段上均匀分布。将此请求的等待时间定义为从请求时刻到令牌下一次到达请求者所经过的时间。\n\n仅使用令牌环操作的基本定义和基本的时间平均论证，推导出：\n- 最坏情况下的等待时间 $W_{\\max}$（在所有请求者身份和请求阶段上的上确界），\n- 平均等待时间 $W_{\\text{mean}}$（在上述均匀选择下的期望值），\n- 以及比率 $\\rho = \\frac{W_{\\max}}{W_{\\text{mean}}}$。\n\n将您的最终答案表示为一个行矩阵，其条目按 $W_{\\max}$、$W_{\\text{mean}}$ 和 $\\rho$ 的顺序排列。不要四舍五入；将表达式保留为精确形式。使用与 $d_{i}$ 相同的时间单位表示所有时间量。",
            "solution": "首先对问题陈述进行严格的验证过程。\n\n步骤 1：提取已知条件\n- 系统：一个用于分布式互斥的单向令牌环。\n- 进程：$N$ 个进程，标记为 $P_{1}, P_{2}, \\ldots, P_{N}$。\n- 拓扑：从 $P_{i}$到 $P_{i+1}$ 存在有向链接，索引对 $N$ 取模。\n- 延迟：从 $P_{i}$ 到 $P_{i+1}$ 的链接具有一个确定的跳跃延迟 $d_{i} > 0$。\n- 令牌行为：令牌不断循环。有待处理请求的进程在令牌到达时捕获令牌，使用临界区，并以可忽略不计的额外持有时间转发令牌。\n- 请求模型：考虑单个请求。\n  - 请求者从 $\\{P_{1}, \\ldots, P_{N}\\}$ 中均匀随机选择。\n  - 请求时间与令牌运动无关，并在令牌周期的稳态阶段上均匀分布。\n- 等待时间的定义：从请求时刻到令牌下一次到达请求者所经过的时间。\n- 目标：推导最坏情况下的等待时间 $W_{\\max}$、平均等待时间 $W_{\\text{mean}}$ 以及比率 $\\rho = \\frac{W_{\\max}}{W_{\\text{mean}}}$。\n\n步骤 2：使用提取的已知条件进行验证\n根据验证标准对问题进行评估。\n- **科学依据**：带有确定性延迟的令牌环模型是在分布式算法和操作系统研究中一个标准且易于理解的抽象。它在科学上和数学上都是合理的。\n- **适定性**：问题定义清晰。系统、其参数（$N$, $d_i$）、请求的随机过程以及待推导的量都得到了明确的规定。持有时间可忽略不计的假设确保了令牌循环周期是恒定的，这简化了分析并保证了明确定义的周期。\n- **客观性**：问题以精确、客观的语言陈述，没有歧义或主观因素。\n- **缺陷清单**：该问题没有表现出任何列出的缺陷。它不是科学上不合理、不可形式化、不完整、自相矛盾、不切实际、不适定或微不足道的。它是其领域内一个标准的分析问题。\n\n步骤 3：结论与行动\n该问题被认为是有效的。现在将提供一个完整的、有理有据的解决方案。\n\n支配系统时间行为的基本量是令牌在环上完成一次完整循环所需的总时间。由于每个进程的持有时间可以忽略不计，这个总周期时间，记为 $T_C$，是所有单个跳跃延迟的总和。\n$$T_C = \\sum_{i=1}^{N} d_{i}$$\n这个周期时间 $T_C$ 定义了发出请求的“稳态阶段”的持续时间。\n\n**1. 最坏情况下的等待时间 ($W_{\\max}$)**\n\n一个请求的等待时间是从请求发出时刻到令牌下一次到达请求进程的持续时间。为了找到最坏情况下的等待时间，我们必须找到这个持续时间在所有可能的请求进程和所有可能的请求时间上的上确界。\n\n考虑一个由任意进程 $P_k$ 发出的请求。如果在最不合时宜的时刻发出请求，等待时间将达到最大值。这个时刻发生在令牌刚刚离开进程 $P_k$ 后的无穷小时间内。在这种情况下，该进程刚刚错过了捕获令牌的机会，必须等待令牌完成整个环路循环后才能返回。\n\n由于令牌转发是立即的，完成这个环路所需的时间恰好是总周期时间 $T_C$。这个逻辑适用于环中的任何进程 $P_k$。因此，最坏情况下的等待时间对所有进程都是相同的。在所有条件下，等待时间的上确界是 $T_C$。\n$$W_{\\max} = T_C = \\sum_{i=1}^{N} d_{i}$$\n\n**2. 平均等待时间 ($W_{\\text{mean}}$)**\n\n平均等待时间 $W_{\\text{mean}}$ 是等待时间的期望值，该期望值是在请求进程的随机选择和请求时间的随机性上共同计算的。\n\n我们首先确定一个固定的、任意的请求进程 $P_k$ 的平均等待时间。问题陈述指出，请求时间在持续时间为 $T_C$ 的令牌周期内均匀分布。让我们为进程 $P_k$ 设置一个本地时间参考，使其令牌到达时间为 $0, T_C, 2T_C, \\ldots$。来自 $P_k$ 的请求在时间 $t_{req}$ 发出，该时间在区间 $[0, T_C)$ 内均匀分布。\n\n等待时间 $W_k(t_{req})$ 是从 $t_{req}$ 到下一次到达时间 $t=T_C$ 的时间。因此，$W_k(t_{req}) = T_C - t_{req}$。\n\n进程 $P_k$ 的平均等待时间，记为 $E[W_k]$，是 $W_k(t_{req})$ 在 $t_{req}$ 的均匀分布下的期望值。\n$$E[W_k] = \\int_{0}^{T_C} W_k(t) \\cdot f(t) \\,dt$$\n其中 $f(t)$ 是在 $[0, T_C)$ 上的均匀分布的概率密度函数，即当 $t \\in [0, T_C)$ 时，$f(t) = \\frac{1}{T_C}$，否则为 $0$。\n$$E[W_k] = \\int_{0}^{T_C} (T_C - t) \\frac{1}{T_C} \\,dt = \\frac{1}{T_C} \\left[ T_C t - \\frac{t^2}{2} \\right]_{0}^{T_C}$$\n$$E[W_k] = \\frac{1}{T_C} \\left( (T_C \\cdot T_C - \\frac{T_C^2}{2}) - (0) \\right) = \\frac{1}{T_C} \\left( T_C^2 - \\frac{T_C^2}{2} \\right) = \\frac{1}{T_C} \\left( \\frac{T_C^2}{2} \\right) = \\frac{T_C}{2}$$\n这个结果表明，任何特定进程 $P_k$ 的平均等待时间恰好是总周期时间的一半。这个结果与进程索引 $k$ 和各个延迟值 $d_i$ 无关，仅取决于它们的总和 $T_C$。\n\n接下来，我们对请求者的选择进行平均。问题陈述指出，请求者是从 $N$ 个进程中均匀随机选择的。总的平均等待时间 $W_{\\text{mean}}$ 是 $E[W_k]$ 在 $k \\in \\{1, 2, \\ldots, N\\}$ 的离散均匀分布下的期望值。\n$$W_{\\text{mean}} = E_{k}[E[W_k]] = \\sum_{k=1}^{N} P(\\text{请求者是 } P_k) \\cdot E[W_k]$$\n由于 $P(\\text{请求者是 } P_k) = \\frac{1}{N}$ 且对所有 $k$ 都有 $E[W_k] = \\frac{T_C}{2}$：\n$$W_{\\text{mean}} = \\sum_{k=1}^{N} \\frac{1}{N} \\cdot \\frac{T_C}{2} = \\frac{1}{N} \\left( N \\cdot \\frac{T_C}{2} \\right) = \\frac{T_C}{2}$$\n因此，平均等待时间是总周期时间的一半。\n$$W_{\\text{mean}} = \\frac{1}{2} T_C = \\frac{1}{2} \\sum_{i=1}^{N} d_{i}$$\n\n**3. 比率 $\\rho$**\n\n比率 $\\rho$ 定义为 $\\frac{W_{\\max}}{W_{\\text{mean}}}$。使用上面推导出的表达式：\n$$\\rho = \\frac{W_{\\max}}{W_{\\text{mean}}} = \\frac{T_C}{T_C/2}$$\n$$\\rho = 2$$\n最坏情况下的等待时间与平均等待时间之比恰好为 $2$。这个结果是一个常数，与进程数 $N$ 和具体的延迟值 $d_i$ 无关，只要它们是正的。这是一个随机变量的典型特征，该随机变量表示在固定持续时间的区间结束前的等待时间，其中到达时间在该区间上均匀分布。\n\n最终结果是：\n- $W_{\\max} = \\sum_{i=1}^{N} d_{i}$\n- $W_{\\text{mean}} = \\frac{1}{2}\\sum_{i=1}^{N} d_{i}$\n- $\\rho = 2$\n这些将以行矩阵的形式呈现。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\sum_{i=1}^{N} d_{i}  \\frac{1}{2}\\sum_{i=1}^{N} d_{i}  2\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "许多现代分布式系统因其简洁性和可扩展性而采用随机化算法，尤其是在节点总数未知的情况下。本练习探讨了一种经典的随机化领导者选举算法，其中每个进程选择一个大的随机标识符。通过计算成功选出唯一领导者的概率，你将学会如何运用基本的概率工具来为这类算法的可靠性提供形式化保证 。",
            "id": "3638486",
            "problem": "考虑一个同步消息传递系统，该系统建模为一个包含 $N$ 个进程（节点）的连通无向图，其图直径为 $D$。每个进程都不知道 $N$ 或 $D$ 的值。时间以锁步轮次的方式推进。在每一轮中，一个进程可以向其每个邻居发送消息，并接收在该轮次发送给它的消息。假设每条消息可以携带一个 $L$ 比特的值而无需分片。\n\n设计一个选举算法，该算法无需知道 $N$ 的值，并使用随机化的进程标识符来确保以高概率在有界的轮次内所有进程都选出同一个领导者。该算法必须为每个进程从集合 $\\{0,1,\\dots,2^{L}-1\\}$ 中分配一个独立且均匀随机的标识符，并且每轮只使用本地邻居通信。\n\n从同步轮次、图直径和随机变量独立性的基本定义出发，推导出一个概率下界，该概率指的是到第 $D$ 轮结束时所有进程都选出了同一个领导者。将收敛时间视为所有进程就单个标识符达成一致所需的时间，并假设选出的领导者是持有在系统中观察到的最大标识符的进程。使用离散概率中经过充分检验的概率工具来证明你的界，并确保它不依赖于算法内部任何关于 $N$ 的知识。\n\n将你的最终答案表示为一个单一的闭式解析表达式，用 $N$ 和 $L$ 表示，该表达式是到第 $D$ 轮结束时所有进程都选出同一个领导者的概率下界。无需取整。",
            "solution": "该问题要求我们在一个同步消息传递系统中设计并分析一个随机化分布式选举算法。我们必须推导在指定时间范围内成功选出唯一领导者的概率下界。\n\n首先，我们验证问题陈述的有效性。\n**步骤1：提取已知条件**\n- 系统模型：同步消息传递，连通无向图。\n- 进程数量：$N$。\n- 图直径：$D$。\n- 进程知识：进程不知道 $N$ 或 $D$。\n- 时间模型：锁步轮次。\n- 通信：在每一轮中，进程可以向其邻居发送消息，并接收该轮次的消息。\n- 消息容量：$L$ 比特值。\n- 标识符分配：每个进程被分配一个来自集合 $\\{0, 1, \\dots, 2^L - 1\\}$ 的独立且均匀随机的标识符。\n- 选举规则：领导者是持有在系统中观察到的最大标识符的进程。\n- 目标：推导到第 $D$ 轮结束时，所有进程都选出同一个唯一领导者的概率下界。该界应用 $N$ 和 $L$ 表示。\n\n**步骤2：使用提取的已知条件进行验证**\n- 该问题在科学上植根于分布式算法的标准理论，特别是同步系统中的随机化选举。所有概念（$N$、$D$、同步轮次、随机标识符）在该领域内都有明确的定义。\n- 这是一个适定问题（well-posed problem），要求计算概率的下界，在给定的概率设定下，这是一个可解的分析任务。\n- 语言客观且正式。\n- 设定是完整的，并且对于所需的分析是自洽的。\n- 该模型虽然是理想化的（完全同步），但它是一个标准的理论模型，并且用于算法分析在科学上并非不合理。\n- 这个问题并非无足轻重，它要求将概率方法（特别是并集界）正确地应用于分布式系统的属性。\n\n**步骤3：结论与行动**\n问题被认为是有效的。我们继续进行解答。\n\n满足问题约束的算法操作如下。每个进程 $p_i$（其中 $i \\in \\{1, \\dots, N\\}$）被分配一个随机标识符 $ID_i$，该标识符从集合 $S = \\{0, 1, \\dots, 2^L - 1\\}$ 中独立且均匀地抽取。标识符空间的大小为 $|S| = 2^L$。该选举算法是一个基于泛洪的最大值查找算法。\n令 $M_i(r)$ 为进程 $p_i$ 在第 $r$ 轮结束时已知的最大标识符。\n1. 初始化（第 $0$ 轮）：每个进程 $p_i$ 将其初始已知的最大ID设置为其自身的ID：$M_i(0) = ID_i$。\n2. 通信轮次（$r = 1, 2, \\dots, D$）：在每一轮 $r$ 中，每个进程 $p_i$ 将其当前已知的最大ID $M_i(r-1)$ 发送给其所有邻居。然后它从其邻居 $p_j$ 处接收消息 $\\{M_j(r-1)\\}$。\n3. 更新：每个进程 $p_i$ 通过取其自身当前值和所有接收到的值的最大值来更新其已知的最大ID：$$M_i(r) = \\max(\\{M_i(r-1)\\} \\cup \\{M_j(r-1) \\mid p_j \\text{ 是 } p_i \\text{ 的邻居}\\})。$$\n\n在第 $D$ 轮前成功选出唯一领导者需要满足两个条件：\n1. 收敛性：到第 $D$ 轮结束时，所有进程必须就同一个领导者ID值达成一致。\n2. 唯一性：系统中必须只有一个进程拥有此领导者ID。\n\n让我们首先分析收敛条件。该系统被建模为一个直径为 $D$ 的连通图。直径是图中任意两个节点之间的最大最短路径距离。在一个消息每轮遍历一条边的同步系统中，来自任何进程 $p_i$ 的信息保证能在等于最短路径距离 $d(p_i, p_j)$ 的轮次数内到达任何其他进程 $p_j$。由于对于所有节点对 $(i, j)$ 都有 $d(p_i, p_j) \\le D$，因此来自任何进程的信息最多在 $D$ 轮内到达所有其他进程。\n\n令 $ID_{max} = \\max_{i \\in \\{1, \\dots, N\\}} \\{ID_i\\}$ 为系统中的全局最大标识符，并令 $p_{max}$ 为持有此ID的进程。根据算法的传播机制，$ID_{max}$ 的值将从 $p_{max}$ 开始泛洪整个网络。到第 $D$ 轮结束时，系统中的每个进程都将收到 $ID_{max}$（或一条源自携带 $ID_{max}$ 的消息链的消息）。由于每个进程总是将其本地最大值更新为更大的值，因此到第 $D$ 轮结束时，可以保证对于每个进程 $p_i$，其本地最大值将为 $M_i(D) = ID_{max}$。因此，收敛条件在第 $D$ 轮时是确定性地满足的。\n\n现在我们分析唯一性条件。选举成功当且仅当存在唯一的领导者。这意味着全局最大标识符 $ID_{max}$ 必须由且仅由一个进程持有。因此，选举成功的概率是 $N$ 个随机选择的标识符集合 $\\{ID_1, ID_2, \\dots, ID_N\\}$ 包含一个唯一最大元素的概率。\n\n令 $S_{succ}$ 为存在唯一最大ID的事件。我们希望找到 $P(S_{succ})$ 的一个下界。存在唯一最大值的一个充分但非必要条件是所有 $N$ 个标识符都互不相同。如果所有标识符都是唯一的，那么其中一个必然是最大值。令 $A$ 为所有 $N$ 个标识符都互不相同的事件。由于事件 $A$ 蕴含事件 $S_{succ}$（即 $A \\subseteq S_{succ}$），我们有不等式 $P(A) \\le P(S_{succ})$。因此，$P(A)$ 的一个下界也同样是 $P(S_{succ})$ 的一个下界。\n\n我们将通过考虑其补集 $A^c$ 来计算 $P(A)$ 的下界，$A^c$ 是至少有两个标识符相同的事件。\n$$P(A) = 1 - P(A^c)$$\n事件 $A^c$ 可以表示为特定进程对具有相同ID的事件的并集。令 $E_{ij}$ 为进程 $p_i$ 和进程 $p_j$ 具有相同标识符的事件，即 $ID_i = ID_j$，其中 $1 \\le i  j \\le N$。\n那么，$A^c = \\bigcup_{1 \\le i  j \\le N} E_{ij}$。\n\n使用并集界（布尔不等式），我们可以建立 $P(A^c)$ 的一个上界：\n$$P(A^c) = P\\left(\\bigcup_{1 \\le i  j \\le N} E_{ij}\\right) \\le \\sum_{1 \\le i  j \\le N} P(E_{ij})$$\n标识符 $ID_i$ 和 $ID_j$ 在大小为 $2^L$ 的集合上是独立且均匀分布的。它们相等的概率是：\n$$P(E_{ij}) = P(ID_i = ID_j) = \\sum_{k=0}^{2^L - 1} P(ID_i = k \\land ID_j = k)$$\n由于独立性，这等于：\n$$P(E_{ij}) = \\sum_{k=0}^{2^L - 1} P(ID_i = k) \\cdot P(ID_j = k)$$\n由于均匀分布，对于任何 $k \\in \\{0, 1, \\dots, 2^L - 1\\}$，都有 $P(ID_i = k) = P(ID_j = k) = \\frac{1}{2^L}$。\n$$P(E_{ij}) = \\sum_{k=0}^{2^L - 1} \\left(\\frac{1}{2^L}\\right) \\cdot \\left(\\frac{1}{2^L}\\right) = \\sum_{k=0}^{2^L - 1} \\frac{1}{(2^L)^2} = 2^L \\cdot \\frac{1}{2^{2L}} = \\frac{1}{2^L}$$\n满足 $1 \\le i  j \\le N$ 的不同进程对 $(i, j)$ 的数量由二项式系数 $\\binom{N}{2} = \\frac{N(N-1)}{2}$ 给出。\n将此代入并集界不等式：\n$$P(A^c) \\le \\sum_{1 \\le i  j \\le N} \\frac{1}{2^L} = \\binom{N}{2} \\frac{1}{2^L} = \\frac{N(N-1)}{2 \\cdot 2^L}$$\n现在我们可以找到 $P(A)$ 的一个下界：\n$$P(A) = 1 - P(A^c) \\ge 1 - \\frac{N(N-1)}{2 \\cdot 2^L}$$\n由于 $P(S_{succ}) \\ge P(A)$，这个表达式也是成功选举概率的一个下界。\n因此，到第 $D$ 轮时，选出唯一领导者并且所有进程都知晓这一事实的概率至少为 $1 - \\frac{N(N-1)}{2 \\cdot 2^L}$。\n\n该推导从同步模型和概率独立性的基本定义出发，使用了标准的并集界技术，并按要求提供了用给定参数 $N$ 和 $L$ 表示的下界。",
            "answer": "$$\\boxed{1 - \\frac{N(N-1)}{2 \\cdot 2^{L}}}$$"
        },
        {
            "introduction": "尽管性能和概率很重要，但保证系统在面对故障时的正确性是分布式系统设计中最关键的挑战。本练习提出了一个看似合理但存在缺陷的事件排序方案，它使用本地正常运行时间来排序，这将促使你诊断与时钟回绕和节点重启相关的微妙错误。通过这个分析，你将理解为何因果一致性对安全性至关重要，并学会如何设计鲁棒的容錯排序机制 。",
            "id": "3638458",
            "problem": "一个包含 $N$ 个节点的分布式系统必须通过选举一个协调者，然后将锁请求路由到该协调者的方式来提供集中式分布式互斥。工程团队提出了以下两种设计方案，以标准化领导者选举和请求仲裁中的排序决策：\n\n- 每个节点都有一个唯一的、永久性的整数标识符 $\\text{id}$。\n- 每个节点维护一个本地的 $\\text{uptime}$ 计数器，其值等于自最近一次启动以来的秒数。该计数器存储在一个 $w$ 位的无符号寄存器中，因此以 $2^w$ 为模演变；当溢出时，它会回绕到 $0$，当重启时，它会重置为 $0$。\n\n他们在数对 $(\\text{id}, \\text{uptime})$ 上定义了一个字典序，规则是“较大者胜出”：给定 $(a_1,a_2)$ 和 $(b_1,b_2)$，如果 $a_1  b_1$ 或者 $a_1 = b_1$ 且 $a_2  b_2$，则认为 $(a_1,a_2)$ 更大。计划如下：\n\n- 对于领导者选举，拥有最高 $(\\text{id}, \\text{uptime})$ 的节点将成为协调者。\n- 对于请求仲裁（为了在协调者看到的、同时挂起的锁请求之间打破平局），协调者偏好其附加的 $(\\text{id}, \\text{uptime})$ 更高的请求。\n\n假设网络是异步的，消息延迟有限但无界，存在崩溃-恢复故障（节点可能崩溃并稍后重启），并且没有拜占庭故障。所有节点都按照上述规定，在相同的整数宽度上实现相同的字典序比较。\n\n仅使用领导者选举和分布式互斥的安全性（safety）与活性（liveness）的基本定义，以及关于回绕算术和逻辑时钟的标准事实（例如，Lamport 逻辑时钟 $L$ 是一个函数，它为每个事件分配一个整数，使得如果事件 $e$ happens-before 事件 $f$，则 $L(e)  L(f)$，并且可以通过 $(L,\\text{id})$ 导出一个全序），评估以下陈述并选择所有正确的选项。\n\nA. 对于在提议的排序规则下的领导者选举，$\\text{uptime}$ 的回绕本身不会导致两个并发领导者的存在：因为 $\\text{id}$ 是字典序中的主字段，有效的选举优先级对于 $\\text{id}$ 是静态的，所以脑裂需要网络分区或错误的实现，而不仅仅是 $\\text{uptime}$ 的回绕。\n\nB. 对于分布式互斥中的请求仲裁，即使 $\\text{uptime}$ 发生回绕，用数对 $(\\text{id}, \\text{uptime})$ 替换 Lamport 逻辑时钟 $L$ 也是安全的，因为对固定宽度整数的任何字典序都会导出一个全序，而互斥安全性只需要一个全序。\n\nC. 如果团队反过来将顺序颠倒为 $(\\text{uptime}, \\text{id})$ 并使用无符号比较，那么只要每个节点都使用相同的 $w$，回绕在任何情况下都不会影响安全性或活性；模 $2^w$ 算术足以为了所有目的保持正确的排序。\n\nD. 在异步崩溃-恢复模型中，将 $\\text{uptime}$ 的宽度从 $w=32$ 增加到 $w=64$ 可以保证领导者选举和请求仲裁的安全性，因为回绕周期变得天文数字般巨大，从而实际上不可能达到。\n\nE. 一个有原则的修复方案是，在对安全性至关重要的排序中消除对 $\\text{uptime}$ 的依赖，而是使用形式为 $(e, L, \\text{id})$ 的时间戳。其中，$e$ 是一个存储在稳定存储中的持久化纪元号，在每次启动和开始任何选举之前递增；$L$ 是一个 Lamport 逻辑时钟，当 $e$ 递增时重置为 $0$，并在每次本地事件和接收事件时推进；如果两个事件的 $e$ 和 $L$ 相等，则它们的 $\\text{id}$ 用来打破平局。通过最高的 $(e,\\text{id})$ 选举领导者，并通过最高的 $(e, L, \\text{id})$ 仲裁请求。这可以防止回绕异常，并恢复在重启和消息延迟情况下保证安全性所需的排序属性。\n\n选择所有正确的选项。",
            "solution": "问题陈述描述了一个在包含 $N$ 个节点且存在崩溃-恢复故障的系统中，实现集中式分布式互斥的设计。该设计的核心是基于数对 $(\\text{id}, \\text{uptime})$ 的字典序，其中 $\\text{id}$ 是唯一的永久性节点标识符，$\\text{uptime}$ 是一个本地的 $w$ 位计数器，它在重启时重置为 $0$，在溢出时回绕。此排序用于领导者选举和仲裁锁请求。\n\n首先，我们必须分析所提议的时间戳 $(\\text{id}, \\text{uptime})$ 的属性。在分布式系统中，尤其是在有故障的系统中，一个时间戳机制理想情况下必须提供一个与因果关系（“happens-before”关系）一致的事件全序。如果事件 $a$ happens-before 事件 $b$（表示为 $a \\rightarrow b$），一个正确的逻辑时钟 $C$ 应满足 $C(a)  C(b)$。\n\n所提议的元组 $(\\text{id}, \\text{uptime})$ 出于两个根本原因未能满足此要求：\n1.  **重启时重置**：当一个节点崩溃并重启时，其 $\\text{uptime}$ 计数器会重置为 $0$。考虑同一节点 $P_i$ 上的两个事件 $e_1$ 和 $e_2$。假设 $e_1$ 发生，然后 $P_i$ 崩溃并重启，接着 $e_2$ 发生。根据定义，$e_1 \\rightarrow e_2$。然而，$e_1$ 的时间戳可能是 $(\\text{id}_i, u_1)$，其中 $u_1$ 很大；而 $e_2$ 的时间戳将是 $(\\text{id}_i, u_2)$，其中 $u_2$ 很小。在这种情况下，字典序比较会得出 $(\\text{id}_i, u_1) > (\\text{id}_i, u_2)$ 的结果，这违反了因果性原则。\n2.  **回绕**：$\\text{uptime}$ 计数器是一个有限的 $w$ 位寄存器，因此它以 $2^w$ 为模演变。一个在 $\\text{uptime} = 2^w-1$ 时发生的事件，其后继事件的 $\\text{uptime}$ 将是 $0$。这种非单调性也违反了逻辑时钟所需的属性。\n\n无法创建一个因果一致的排序是一个关键缺陷，可能导致分布式算法中对安全性和活性的违反。基于这一理解，我们来评估每个陈述。\n\n**A. 对于在提议的排序规则下的领导者选举，$\\text{uptime}$ 的回绕本身不会导致两个并发领导者的存在：因为 $\\text{id}$ 是字典序中的主字段，有效的选举优先级对于 $\\text{id}$ 是静态的，所以脑裂需要网络分区或错误的实现，而不仅仅是 $\\text{uptime}$ 的回绕。**\n\n领导者被选为具有最高 $(\\text{id}, \\text{uptime})$ 数对的节点。比较是字典序的：如果 $a_1 > b_1$ 或 ($a_1=b_1$ 且 $a_2 > b_2$)，则 $(a_1, a_2) > (b_1, b_2)$。当比较来自两个不同节点 $P_i$ 和 $P_j$ 的数对时，它们的 ID 是不同的，因此 $\\text{id}_i \\neq \\text{id}_j$。因此，比较仅取决于主字段 $\\text{id}$。假设 $\\text{id}_i > \\text{id}_j$。那么对于 $\\text{uptime}_i$ 和 $\\text{uptime}_j$ 的任何可能值，$(\\text{id}_i, \\text{uptime}_i) > (\\text{id}_j, \\text{uptime}_j)$ 总是成立的。系统中具有最高 $\\text{id}$ 的节点将始终拥有所有节点中排名最高的数对。\n\n任何节点上 $\\text{uptime}$ 计数器的回绕都不会改变这一事实。如果具有最高 $\\text{id}$ 的节点的 $\\text{uptime}$ 计数器发生回绕，其相对于任何其他节点的排名不受影响，因为其 $\\text{id}$ 仍然是最高的。如果任何其他节点的 $\\text{uptime}$ 回绕，它仍然无法获得比具有最高 $\\text{id}$ 的节点更高的排名。因此，$\\text{uptime}$ 的回绕本身不能造成一个较低 $\\text{id}$ 的节点拥有比一个较高 $\\text{id}$ 的节点排名更高的时间戳的情况。“脑裂”（两个并发的领导者）将需要不同的故障，例如网络分区，使得最高 $\\text{id}$ 的节点对某个节点子集不可达，从而导致它们在自己中间选举一个新的领导者。因此，该陈述的推理是正确的。\n\n**结论：正确**\n\n**B. 对于分布式互斥中的请求仲裁，即使 $\\text{uptime}$ 发生回绕，用数对 $(\\text{id}, \\text{uptime})$ 替换 Lamport 逻辑时钟 $L$ 也是安全的，因为对固定宽度整数的任何字典序都会导出一个全序，而互斥安全性只需要一个全序。**\n\n这个陈述包含一个危险的错误前提：“互斥安全性只需要一个全序”。虽然全序是必要的，但它并非充分条件。许多分布式算法的安全性（包括去中心化互斥或中心化方案的恢复协议）要求所有正确的进程就*同一个*全序达成一致，并且这个顺序必须与因果关系一致。\n\n如前所述，由于重启时重置的行为，$(\\text{id}, \\text{uptime})$ 数对不尊重因果关系。一个节点 $P_i$ 可以发出一个时间戳为 $(\\text{id}_i, u_1)$ 的请求 $R_1$，然后崩溃、重启，并发出另一个时间戳为 $(\\text{id}_i, u_2)$ 的请求 $R_2$，其中 $u_1 > u_2$。一个观察到这两个请求的观察者会将它们排序为 $R_1 > R_2$，认为按时间顺序更早的请求是后发生的。如果系统中的不同节点由于网络延迟观察到这些事件的不同子集，它们可能会形成对全局请求顺序的不一致视图。这种不一致性可能导致安全性的违反（例如，两个节点同时进入临界区）在去中心化算法中。即使在中心化方案中，如果协调者发生故障，新的协调者必须根据其他节点提供的信息重建请求队列，这些不一致性也可能导致状态不正确，从而可能违反安全性。因此，所提议的排序是不安全的。\n\n**结论：错误**\n\n**C. 如果团队反过来将顺序颠倒为 $(\\text{uptime}, \\text{id})$ 并使用无符号比较，那么只要每个节点都使用相同的 $w$，回绕在任何情况下都不会影响安全性或活性；模 $2^w$ 算术足以为了所有目的保持正确的排序。**\n\n这个提议比原来的方案要差得多。以 $(\\text{uptime}, \\text{id})$ 作为排序键，领导权和请求优先级主要由 $\\text{uptime}$ 决定。\n对于领导者选举，$\\text{uptime}$ 最高的节点成为领导者。这使得领导权非常不稳定；任何节点的计数器只要超过当前领导者的计数器，就可能触发一次选举。最严重的缺陷是回绕的影响。假设一个领导者 $P_i$ 的 $\\text{uptime} = 2^w-1$。在下一个时间步，它的 $\\text{uptime}$ 变为 $0$。它的时间戳 $(\\text{uptime}_i, \\text{id}_i)$ 突然变成了系统中最低的时间戳之一。任何其他具有非零 $\\text{uptime}$ 的节点 $P_j$ 现在都拥有更高的时间戳，并将有资格成为领导者。这可能导致快速、重复的领导者变更，严重影响系统活性。此外，它直接导致了安全性的违反。一个具有高 $\\text{uptime}$ 的领导者可以发送“我是领导者”的消息，然后其计数器回绕到 $0$。另一个节点随后可以迅速赢得选举并也宣布自己为领导者，从而造成由回绕直接导致的脑裂情景。断言该方案不受回绕影响的说法显然是错误的。\n\n**结论：错误**\n\n**D. 在异步崩溃-恢复模型中，将 $\\text{uptime}$ 的宽度从 $w=32$ 增加到 $w=64$ 可以保证领导者选举和请求仲裁的安全性，因为回绕周期变得天文数字般巨大，从而实际上不可能达到。**\n\n这是一个从实用性而非形式正确性出发的论点。在算法的形式化分析中，一个潜在的故障模式不能仅仅因为其不太可能发生而被忽略。从严谨的、理论的角度来看，“保证安全性”是一个站不住脚的主张。\n\n更重要的是，这个提议完全忽略了第二个、更频繁且同样具有破坏性的缺陷：$\\text{uptime}$ 在重启时重置为 $0$。正如在选项 B 的分析中所解释的，这种行为破坏了因果排序。节点可能在任何时候崩溃并重启，这在崩溃-恢复模型中是常见事件。将寄存器加宽到 $64$ 位完全无法修复由重启引入的因果异常。因此，即使使用 $64$ 位计数器，该系统对于请求仲裁仍然是不安全的。\n\n**结论：错误**\n\n**E. 一个有原则的修复方案是，在对安全性至关重要的排序中消除对 $\\text{uptime}$ 的依赖，而是使用形式为 $(e, L, \\text{id})$ 的时间戳。其中，$e$ 是一个存储在稳定存储中的持久化纪元号，在每次启动和开始任何选举之前递增；$L$ 是一个 Lamport 逻辑时钟，当 $e$ 递增时重置为 $0$，并在每次本地事件和接收事件时推进；如果两个事件的 $e$ 和 $L$ 相等，则它们的 $\\text{id}$ 用来打破平局。通过最高的 $(e,\\text{id})$ 选举领导者，并通过最高的 $(e, L, \\text{id})$ 仲裁请求。这可以防止回绕异常，并恢复在重启和消息延迟情况下保证安全性所需的排序属性。**\n\n该陈述提出了一个在崩溃-恢复模型中生成逻辑时间戳的健壮且公认的解决方案模式。我们来分析其组成部分：\n1.  **纪元号 $e$**：在稳定存储上存储一个计数器，并在每次启动时递增，这样就创建了一个持久的、单调递增的值，该值在崩溃后依然存在。这直接解决了重启时重置的问题。任何在重启后发生的事件，其纪元号 $e$ 都将严格高于重启前的任何事件，从而正确地捕捉了跨崩溃的因果关系。\n2.  **Lamport 时钟 $L$**：在单个纪元内（即两次重启之间），Lamport 时钟 $L$ 确保了本地的“happens-before”关系得以维持。\n3.  **节点标识符 $\\text{id}$**：这作为最终的平局打破者，以创建一个全序。\n\n由此产生的时间戳 $(e, L, \\text{id})$ 为所有事件提供了一个与因果上的 happens-before 关系一致的全序。如果事件 $a \\rightarrow b$，那么 $a$ 的时间戳在字典序上将小于 $b$ 的时间戳。\n\n提议的用法也是合理的：\n-   **通过 $(e, \\text{id})$ 进行领导者选举**：使用纪元号作为领导者选举的主字段是一种标准技术（例如，Raft 共识算法中的“任期（term）”）。它确保一个新重启并开始选举的节点可以成为领导者，并为纪元内的领导权提供了稳定的基础。$\\text{id}$ 打破平局确保了领导者的唯一性。\n-   **通过 $(e, L, \\text{id})$ 进行请求仲裁**：由于此时间戳正确反映了因果关系，使用它来对请求进行排序可确保所有节点都能就单一、一致的历史达成共识，这是分布式互斥中安全性和活性的基础。\n\n这个提议正确地指出了原始设计中的缺陷，并用已知可行的、有原则的机制取而代之。它有效地防止了由 `uptime` 回绕和重启引起的异常，恢复了正确分布式算法所需的属性。\n\n**结论：正确**",
            "answer": "$$\\boxed{AE}$$"
        }
    ]
}