{
    "hands_on_practices": [
        {
            "introduction": "在远程过程调用能够执行任何有意义的操作之前，其消息必须被安全地接收和解析。这项实践深入探讨了此过程中一个至关重要的安全方面：如何通过根据来自网络的不可信输入谨慎管理内存分配，来防止资源耗尽攻击。通过模拟一个健壮的解串行器，你将学习到防御性编程在构建可靠网络服务中的核心作用。",
            "id": "3677042",
            "problem": "您需要设计并实现一个独立的程序，该程序模拟一个远程过程调用 (RPC) 消息的反序列化器，并评估一个防御性编码的部分反序列化策略在对抗性输入和边界输入下是否能防止资源耗尽。上下文是一个长度前缀的 RPC 消息，其中第一个字段声明了消息长度。您的任务是根据基本原则对流式输入下的资源分配进行推理，并实现一个测试框架来验证其安全属性，而无需执行任何网络输入或实际的内存分配。\n\n基本和核心定义：\n- 远程过程调用 (RPC) 是一种机制，客户端通过它调用远程服务器上的过程，就像调用本地过程一样。一种常见的消息分帧方法是在每条消息前加上一个声明的长度。反序列化是从字节序列中重建结构化消息的过程。\n- 如果一个实现允许基于不受信任的输入进行无限制或过大的内存分配，就会发生资源耗尽。为避免这种情况，内存分配应受到配置限制的约束，并以增量方式执行。\n- 我们考虑单个连接一次最多处理一条消息，且解析器维持恒定的开销。\n\n需要模拟的安全策略（不要假设任何快捷公式；相反，请忠实地应用以下规则）：\n- 令 $L$ 为声明的消息长度（字节），$C$ 为配置的单条消息长度上限（字节），$M$ 为此连接的可用内存预算（字节），$O$ 为每个连接的恒定解析器开销（字节），$P$ 为实际到达的负载字节总数（如果流被截断，该值可能小于 $L$），$s$ 为每次增量到达的负载块的大小（字节）。\n- 安全的反序列化器必须强制执行以下不变量：\n  - 如果在读取头部时，声明的长度 $L$ 超过上限 $C$，则立即中止该消息，不分配任何消息缓冲区。解析器开销 $O$ 仍然驻留内存。\n  - 如果 $L \\leq C$，不要预先分配 $L$ 字节。而应随着负载的到达以增量方式增长消息缓冲区，每次增长的量最多为到达的块大小 $s$，并且缓冲区总大小绝不超过已接收负载总量和上限 $C$ 中的较小者。\n  - 如果接收到的总负载达到声明的长度 $L$，则消息处理完成，消息缓冲区被释放。如果流提前截断 ($P < L$)，则在输入结束时释放部分填充的消息缓冲区。\n  - 在任何时候，当前分配的内存等于解析器开销 $O$ 加上当前消息缓冲区的大小；峰值分配是在处理消息期间观察到的该总量的最大值。\n- 当且仅当峰值分配不超过预算 $M$ 时，系统才能避免资源耗尽。\n\n您的程序必须：\n- 针对提供的测试套件中的每个测试用例，模拟上述过程：以大小为 $s$ 字节的块（最后一个块可能更小）逐步模拟负载的到达，遵守 $L > C$ 时的中止条件、$L \\leq C$ 时的增量增长规则，以及在完成或截断时释放缓冲区的规则。\n- 对于每个测试用例，如果安全策略避免了资源耗尽（峰值分配 $\\leq M$），则输出整数 $1$，否则输出 $0$。\n\n测试套件：\n- 测试用例 1：$L = 1024$ 字节, $P = 1024$ 字节, $s = 128$ 字节, $C = 2048$ 字节, $M = 4096$ 字节, $O = 64$ 字节。\n- 测试用例 2：$L = 1000000000$ 字节, $P = 1$ 字节, $s = 1$ 字节, $C = 65536$ 字节, $M = 10000000$ 字节, $O = 64$ 字节。\n- 测试用例 3：边界条件 $L = C$：$L = 4096$ 字节, $P = 4096$ 字节, $s = 257$ 字节, $C = 4096$ 字节, $M = 5000$ 字节, $O = 64$ 字节。\n- 测试用例 4：负载被截断且受上限约束：$L = 50000$ 字节, $P = 10000$ 字节, $s = 3000$ 字节, $C = 8192$ 字节, $M = 8300$ 字节, $O = 64$ 字节。\n- 测试用例 5：零长度消息：$L = 0$ 字节, $P = 0$ 字节, $s = 1$ 字节, $C = 16$ 字节, $M = 64$ 字节, $O = 64$ 字节。\n- 测试用例 6：预算紧张导致失败：$L = 1024$ 字节, $P = 1024$ 字节, $s = 512$ 字节, $C = 1024$ 字节, $M = 1000$ 字节, $O = 64$ 字节。\n\n最终输出格式：\n- 您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如, `[x,y,z]`），每个元素按顺序对应一个测试用例，如果该用例的安全策略避免了资源耗尽，则为整数 $1$，否则为 $0$。输出是无单位的整数，表示布尔值（$1$ 表示真，$0$ 表示假）。不应打印任何其他文本。",
            "solution": "该问题要求在特定的安全策略下模拟远程过程调用 (RPC) 的反序列化过程，以确定是否避免了资源耗尽。我们将首先验证问题陈述，然后根据所提供的规则，通过模拟内存分配状态，系统地推导出每个测试用例的结果。\n\n### 问题验证\n\n#### 步骤1：提取已知条件\n\n问题定义了以下符号参数：\n- $L$：声明的消息长度（字节）。\n- $C$：配置的单条消息长度上限（字节）。\n- $M$：此连接的可用内存预算（字节）。\n- $O$：每个连接的恒定解析器开销（字节）。\n- $P$：实际到达的负载字节总数。\n- $s$：每次增量到达的负载块的大小（字节）。\n\n安全策略由一组不变量定义：\n1.  如果 $L > C$，在读取头部时消息被中止。不分配消息缓冲区。解析器开销 $O$ 仍然存在。\n2.  如果 $L \\leq C$，不预分配消息缓冲区。它随着负载的到达而增量增长。任何时候，缓冲区大小都不能超过到目前为止接收到的总负载和上限 $C$ 中的较小者。\n3.  如果接收到的总负载达到 $L$，则消息处理完成。缓冲区在完成后被释放。如果流被截断 ($P < L$)，部分缓冲区在输入结束时被释放。\n4.  当前内存分配是解析器开销 $O$ 和当前消息缓冲区大小的总和。\n5.  峰值分配是在处理一条消息期间观察到的最大内存分配。\n6.  当且仅当峰值分配不超过预算 $M$ 时，资源耗尽才被避免。\n\n测试套件为六个不同的用例提供了参数 $L, P, s, C, M, O$ 的具体值。\n\n#### 步骤2：使用提取的已知条件进行验证\n\n该问题根据以下标准进行评估：\n- **科学依据**：该问题在计算机科学基本原理方面有充分的依据，特别是在网络协议、操作系统和防御性编程领域。长度前缀消息、资源耗尽攻击以及带上限的增量分配等概念都是软件工程中的标准和现实主题。\n- **良构性**：该问题是良构的。模拟规则是确定性的，并以算法方式陈述。对于测试套件中的每组输入参数，都可以计算出唯一的结果（峰值分配），从而得到明确的二进制结果（$1$ 或 $0$）。\n- **客观性**：问题以精确、量化和客观的语言陈述。它没有主观性或模糊性。\n- **完整性与一致性**：问题是自包含的。为每个测试用例提供了所有必要的数据和规则。规则被构造为一组非矛盾的条件不变量。`if L > C` 的情况与 `if L = C` 的情况互斥，形成一个完整的决策过程。\n- **现实性**：该场景和参数对于建模和测试网络服务的逻辑是现实的。这些值的选择是为了探测边界条件，这是算法测试中的标准做法。\n\n#### 步骤3：结论与行动\n\n问题陈述是**有效的**。它在科学上是合理的、提法明确，并且提供了所有必要的信息。我们将继续进行分步求解。\n\n### 算法解决方案\n对于每个测试用例，我们模拟内存分配过程以找到峰值分配，并将其与内存预算 $M$ 进行比较。设 `peak_alloc` 为观察到的峰值内存分配，`current_alloc` 为给定步骤中分配的内存。\n\n单个测试用例的模拟算法如下：\n1.  将 `peak_alloc` 初始化为恒定的解析器开销 $O$。这是基线分配。\n2.  评估第一个不变量：将声明的长度 $L$ 与上限 $C$ 进行比较。\n    - 如果 $L  C$，策略规定立即中止。从不分配消息缓冲区。内存使用量绝不会超过初始的解析器开销。因此，`peak_alloc` 保持为 $O$。\n    - 如果 $L \\leq C$，则进入增量分配阶段。\n3.  对于 $L \\leq C$ 的情况，模拟负载分块到达。初始化 `bytes_received = 0` 和 `buffer_size = 0`。\n4.  只要还有负载可以到达 (`bytes_received  P`) 且消息尚未完成 (`bytes_received  L`)，就循环执行：\n    - a. 确定下一个传入数据块的大小：`chunk_size = min(s, P - bytes_received)`。\n    - b. 更新接收到的数据总量：`bytes_received = bytes_received + chunk_size`。\n    - c. 根据规则更新已分配的缓冲区大小：`buffer_size = min(bytes_received, C)`。缓冲区增长以容纳接收到的数据，但受上限 $C$ 的限制。\n    - d. 计算当前总内存分配：`current_alloc = O + buffer_size`。\n    - e. 更新峰值分配：`peak_alloc = max(peak_alloc, current_alloc)`。\n5.  循环终止后（由于接收完所有负载 $P$ 或在长度 $L$ 处完成消息），缓冲区被释放。`peak_alloc` 值保存了消息生命周期中的最大内存足迹。\n6.  如果 `peak_alloc` $\\leq M$，则该测试用例的最终结果为 $1$，否则为 $0$。\n\n我们现在将此算法应用于每个测试用例。\n\n**测试用例 1**：$L=1024, P=1024, s=128, C=2048, M=4096, O=64$。\n- $L \\leq C$ ($1024 \\leq 2048$)。继续分配。\n- `peak_alloc` 初始化为 $O=64$。\n- 模拟接收负载，直到 `bytes_received` 达到 $1024$。缓冲区随接收到的负载一起增长。\n- 最大缓冲区大小将为 $\\min(1024, C=2048) = 1024$ 字节。\n- 峰值分配发生在缓冲区满时：`peak_alloc` $= O + 1024 = 64 + 1024 = 1088$ 字节。\n- 条件检查：$1088 \\leq M=4096$。为真。\n- 结果：$1$。\n\n**测试用例 2**：$L=10^9, P=1, s=1, C=65536, M=10^7, O=64$。\n- $L  C$ ($10^9  65536$)。策略要求立即中止。\n- 不分配缓冲区。峰值分配就是解析器的开销。\n- `peak_alloc` $= O = 64$ 字节。\n- 条件检查：$64 \\leq M=10^7$。为真。\n- 结果：$1$。\n\n**测试用例 3**：$L=4096, P=4096, s=257, C=4096, M=5000, O=64$。\n- $L \\leq C$ ($4096 \\leq 4096$)。继续分配。\n- `peak_alloc` 初始化为 $O=64$。\n- 模拟接收负载，直到 `bytes_received` 达到 $4096$。\n- 最大缓冲区大小将为 $\\min(4096, C=4096) = 4096$ 字节。\n- 峰值分配为 `peak_alloc` $= O + 4096 = 64 + 4096 = 4160$ 字节。\n- 条件检查：$4160 \\leq M=5000$。为真。\n- 结果：$1$。\n\n**测试用例 4**：$L=50000, P=10000, s=3000, C=8192, M=8300, O=64$。\n- $L  C$ ($50000  8192$)。策略要求立即中止。\n- 不分配缓冲区。该测试用例的名称“负载被截断且受上限约束”是一个干扰项；$L  C$ 时中止的首要规则优先适用。\n- `peak_alloc` $= O = 64$ 字节。\n- 条件检查：$64 \\leq M=8300$。为真。\n- 结果：$1$。\n\n**测试用例 5**：$L=0, P=0, s=1, C=16, M=64, O=64$。\n- $L \\leq C$ ($0 \\leq 16$)。继续。\n- `peak_alloc` 初始化为 $O=64$。\n- $P=0$，所以没有负载到达。接收循环不执行。由于 `bytes_received` ($0$) 不小于 $L$ ($0$)，消息被立即视为完成。\n- 不分配缓冲区（`buffer_size` 保持为 $0$）。\n- 峰值分配不超过初始开销：`peak_alloc` $= 64$ 字节。\n- 条件检查：$64 \\leq M=64$。为真。\n- 结果：$1$。\n\n**测试用例 6**：$L=1024, P=1024, s=512, C=1024, M=1000, O=64$。\n- $L \\leq C$ ($1024 \\leq 1024$)。继续分配。\n- `peak_alloc` 初始化为 $O=64$。\n- 模拟接收负载，直到 `bytes_received` 达到 $1024$。\n- 最大缓冲区大小将为 $\\min(1024, C=1024) = 1024$ 字节。\n- 峰值分配为 `peak_alloc` $= O + 1024 = 64 + 1024 = 1088$ 字节。\n- 条件检查：$1088 \\leq M=1000$。为假。\n- 结果：$0$。\n\n### 结果总结\n测试用例的结果是：\n1.  用例 1: $1$\n2.  用例 2: $1$\n3.  用例 3: $1$\n4.  用例 4: $1$\n5.  用例 5: $1$\n6.  用例 6: $0$\n程序应将这些结果输出为方括号内的逗号分隔列表。",
            "answer": "[1,1,1,1,1,0]"
        },
        {
            "introduction": "网络是不可靠的，由于超时和重试，远程过程调用可能会被执行一次以上。本练习探讨了幂等性（idempotency）的概念，这是构建健壮系统的关键属性。你将通过分析哪些操作天然具有重试安全性，以及如何使其他操作变得安全，来掌握确保分布式系统中语义一致性的重要策略。",
            "id": "3677029",
            "problem": "客户端使用远程过程调用（RPC）与远程文件服务通信，RPC被正式定义为一个确定性过程，它将一个请求和当前的服务器状态映射到一个新的状态和一个回复。设服务器维护一个表示为 $S$ 的状态空间，并将一次RPC执行定义为一个函数 $F$，其中 $F(S, x) = (S', r)$，$x$ 是操作请求，$S'$ 是新状态，$r$ 是回复。由于重试，网络实现了至少一次（at-least-once）的交付语义：如果客户端在超时时间内没有收到回复，它会重新发送相同的请求，服务器可能会多次执行相同的请求。如果对于任何状态 $S$，一个操作 $x$ 在状态和可观察的回复方面都是幂等的，则有：\n$$F(S, x) = (S', r) \\quad \\text{and} \\quad F(S', x) = (S', r),$$\n这意味着重新执行不会改变相对于单次执行的结果状态或回复。\n\n考虑一个类 Portable Operating System Interface (POSIX) 的文件服务，它在路径 $P$ 或文件 $F$ 上提供以下操作：\n$\\mathsf{read}(F, o, n)$ 从偏移量 $o$ 返回 $n$ 字节，$\\mathsf{writeAt}(F, o, B)$ 在偏移量 $o$ 写入字节序列 $B$，$\\mathsf{append}(F, B)$ 将 $B$ 追加到 $F$ 的末尾，$\\mathsf{create}(P)$ 在 $P$ 处创建一个新的空文件，如果 $P$ 不存在则返回成功，$\\mathsf{delete}(P)$ 删除 $P$ 处的文件，$\\mathsf{chmod}(P, m)$ 将模式位设置为 $m$（绝对赋值），以及 $\\mathsf{rename}(A, B)$ 将路径 $A$ 原子地移动到 $B$。\n\n假设：\n- 服务器原子地执行每个操作，并在回复前立即持久化其效果。\n- 只有一个客户端发出这些操作，重复执行的唯一来源是网络层面对同一请求的重试；在重试之间没有其他客户端的并发写入。\n- 当一个操作被重试时，客户端会重新发送一个完全相同的请求消息。\n\n根据上面幂等性的基本定义和标准的类 POSIX 语义，请分类哪些操作在至少一次语义下是天然幂等的，哪些是非幂等的（因为重试会改变用户可见的语义，即状态和回复）。对于非幂等的操作，提出包装策略，使其在重试下是安全的，而无需全局事务，例如引入客户端生成的幂等性密钥和服务器可以验证的条件前置条件，以便对同一逻辑请求的重新执行产生相同的效果和回复。\n\n哪个选项正确地对幂等与非幂等操作进行了分类，并提出了在尊重典型文件系统不变量的同时，在重试下实现幂等行为的包装策略？\n\nA. 将 $\\mathsf{read}(F, o, n)$、$\\mathsf{writeAt}(F, o, B)$ 和 $\\mathsf{chmod}(P, m)$ 分类为幂等；将 $\\mathsf{append}(F, B)$、$\\mathsf{create}(P)$、$\\mathsf{delete}(P)$ 和 $\\mathsf{rename}(A, B)$ 分类为非幂等，因为即使状态不改变，重试也会改变回复。使用请求范围的幂等性密钥 $k$ 使非幂等操作安全：对于 $\\mathsf{append}$，使用 $\\mathsf{appendToken}(F, k, B)$，它精确地写入一次 $B$，记录所选的偏移量，并在对相同 $k$ 的重试中返回相同的偏移量；对于 $\\mathsf{create}$，使用 $\\mathsf{createToken}(P, k)$，它要么创建并记录 $\\langle P, k \\rangle$，要么如果 $P$ 因相同的 $k$ 而已经存在，则返回成功，如果 $P$ 因其他原因存在，则返回“已存在”；对于 $\\mathsf{delete}$，使用 $\\mathsf{deleteToken}(P, k)$，它删除并记录 $\\langle P, k \\rangle$，在对 $k$ 的重试中返回相同的成功，如果 $P$ 不存在且不是由 $k$ 删除的，则返回“未找到”；对于 $\\mathsf{rename}$，使用 $\\mathsf{renameToken}(A, B, k, i, v)$，它只有当 $A$ 当前指向版本为 $v$ 的 inode $i$ 时才会有条件地重命名，记录 $\\langle A \\to B, k \\rangle$，并在重试 $k$ 时返回相同的成功或错误。\n\nB. 将 $\\mathsf{append}(F, B)$ 分类为幂等，因为追加两次相同的 $B$ 会产生两个 $B$ 的副本，这是“可接受的”，将 $\\mathsf{writeAt}(F, o, B)$ 分类为非幂等，因为写入两次会“覆盖不同的字节”，并在没有服务器支持的情况下，通过客户端重试计数器 $c$ 使所有操作安全，假设如果 $c$ 增加，服务器会丢弃重复项。\n\nC. 将 $\\mathsf{rename}(A, B)$ 分类为幂等，因为移动一个路径两次不会“再次移动它”，将 $\\mathsf{delete}(P)$ 分类为幂等，因为删除一个已经不存在的文件没有状态效果，并在没有任何幂等性密钥的情况下，通过将临时文件重命名为 $P$ 来使 $\\mathsf{create}(P)$ 安全，假设重命名操作的重试总是返回成功。\n\nD. 将 $\\mathsf{read}(F, o, n)$ 分类为非幂等，因为文件可能在重试之间发生变化，将 $\\mathsf{writeAt}(F, o, B)$ 和 $\\mathsf{append}(F, B)$ 分类为幂等，并通过在重试前引入客户端休眠来使非幂等操作安全，以便服务器“稳定”，而没有任何服务器端的去重或条件检查。\n\n选择唯一的最佳选项。",
            "solution": "从第一性原理开始。一个RPC操作 $x$ 是幂等的，如果 $F(F(S, x)_1, x) = F(S, x)$，其中 $F(S, x) = (S', r)$ 且 $F(S', x) = (S', r)$；这里的下标 $1$ 选择状态分量。换句话说，应用两次 $x$ 产生与应用一次 $x$ 相同的状态和回复。在至少一次语义下，同一个逻辑请求 $x$ 可能会执行多次，因此幂等性取决于重复执行相同的请求是否会相对于单次执行改变最终状态或回复。\n\n假设限制了可变性：单个客户端、原子操作和相同的重试意味着重复执行之间的任何变化都是由操作本身引起的，而不是并发干扰。\n\n分析每个操作：\n\n- $\\mathsf{read}(F, o, n)$: 在给定的假设下，文件内容在重试之间不会改变，因为没有其他客户端写入，并且同一个客户端只是因为回复丢失而重试。因此，状态保持不变，回复（返回的字节序列）在重新执行时也是相同的。所以 $\\mathsf{read}$ 是幂等的。\n\n- $\\mathsf{writeAt}(F, o, B)$: 在相同的偏移量 $o$ 处写入相同的字节 $B$ 两次，其最终状态与写入一次相同：第一次写入后，该范围内的文件字节等于 $B$，第二次写入在相同位置再次写入 $B$，文件保持不变。在类 POSIX 语义中，成功写入的回复指示写入的字节数；在原子性和持久性的保证下，重复执行返回相同的成功信息。因此，在所述条件下 $\\mathsf{writeAt}$ 是幂等的。\n\n- $\\mathsf{chmod}(P, m)$ 使用绝对赋值：将模式位设置为 $m$ 两次会得到相同的模式 $m$；因为赋值是绝对的（不是切换或算术更新），所以重试时表示成功的回复是相同的。因此 $\\mathsf{chmod}$ 是幂等的。\n\n- $\\mathsf{append}(F, B)$: 将 $B$ 追加到文件末尾会使文件长度增加 $\\lvert B \\rvert$。重新执行相同的追加操作将再次使长度增加 $\\lvert B \\rvert$，并且内容将包含两个 $B$ 的副本。回复通常包括追加的字节数或新的结束偏移量；这个回复在第一次和第二次执行之间会有所不同。因此 $\\mathsf{append}$ 不是幂等的。\n\n- $\\mathsf{create}(P)$: 在 $P$ 处创建文件一次，状态从“不存在”变为“存在”。在同一路径 $P$ 上第二次执行会产生不同的回复：标准语义会返回“已存在”错误；即使状态保持为“存在”，回复也改变了。因此，相对于包含回复语义的定义，$\\mathsf{create}$ 不是幂等的。\n\n- $\\mathsf{delete}(P)$: 删除文件一次，状态从“存在”变为“不存在”。对一个不存在的文件进行第二次执行会产生不同的回复，“未找到”，尽管状态保持为“不存在”。鉴于定义包括回复，$\\mathsf{delete}$ 不是幂等的。\n\n- $\\mathsf{rename}(A, B)$: 将路径从 $A$ 移动到 $B$ 一次，会导致 $A$ 不存在，$B$ 变为存在（指向被移动的 inode）。第二次使用相同参数执行通常会失败，因为 $A$ 不再存在，从而产生不同的回复；因此 $\\mathsf{rename}$ 不是幂等的。\n\n对于非幂等操作，包装器可以通过将逻辑请求绑定到幂等性密钥 $k$ 来提供幂等语义，并使服务器在重新执行同一逻辑请求时返回相同的效果和回复。此类包装器的原则包括：\n\n- 通过每个客户端的密钥进行去重：服务器存储一个从 $(\\text{client}, k)$ 到已完成操作结果 $(S', r)$ 的映射，确保带有相同 $(\\text{client}, k)$ 的重复请求返回存储的回复 $r$，并且不重新应用状态更改。\n\n- 条件前置条件：服务器检查状态是否满足客户端发出请求时看到的前置条件（例如，重命名操作的源 inode 和版本）。如果前置条件不满足，则返回相同的错误；如果前置条件满足且操作已在 $k$ 下完成，则返回相同的成功信息。\n\n将这些原则应用于每个非幂等操作：\n\n- $\\mathsf{append}(F, B)$: 使用 $\\mathsf{appendToken}(F, k, B)$，在追加 $B$ 时，在每个文件的账本中记录 $k$，以及选择的偏移量 $o$ 和 $B$ 的哈希值以检测不匹配。当使用相同的 $k$ 重试时，服务器返回先前记录的 $o$ 并且不再追加，从而确保对于 $x = \\mathsf{appendToken}(F, k, B)$，有 $F(F(S, x)_1, x) = F(S, x)$。\n\n- $\\mathsf{create}(P)$: 使用 $\\mathsf{createToken}(P, k)$，在成功时创建文件并记录 $\\langle P, k \\rangle$。如果带有相同 $k$ 的重试到达，服务器会检测到现有记录并再次返回成功。如果路径 $P$ 存在但不是在 $k$ 下创建的，服务器返回“已存在”错误，从而保留不变量。\n\n- $\\mathsf{delete}(P)$: 使用 $\\mathsf{deleteToken}(P, k)$，它删除并记录 $\\langle P, k \\rangle$。在使用相同 $k$ 的重试下，即使 $P$ 已经不存在，服务器也会返回成功，因为相同的逻辑删除操作早先已在 $k$ 下完成。如果 $P$ 不存在且没有关于 $k$ 的记录，服务器返回“未找到”，从而保留相对于不同逻辑请求的正确性。\n\n- $\\mathsf{rename}(A, B)$: 使用 $\\mathsf{renameToken}(A, B, k, i, v)$，其中客户端包含在发出重命名请求之前观察到的源 inode $i$ 和版本 $v$。服务器仅在 $A$ 指向版本为 $v$ 的 inode $i$ 时执行重命名，然后记录 $\\langle A \\to B, k \\rangle$。使用相同 $k$ 的重试会返回相同的成功信息；如果 $A$ 不再匹配 $i, v$ 且没有关于 $k$ 的记录，服务器将返回与第一次尝试相同的错误，从而避免了意外的额外移动。\n\n评估每个选项：\n\nA. 该选项将 $\\mathsf{read}$、$\\mathsf{writeAt}$ 和 $\\mathsf{chmod}$ 分类为幂等，其余的在重试下为非幂等，因为即使状态可能不改变，回复也会改变。这与上面的分析相符。所提出的包装器使用幂等性密钥 $k$ 和条件检查，以确保重复执行产生相同的回复，而无需重新应用状态更改。每个包装器都尊重常见的文件系统不变量：$\\mathsf{appendToken}$ 在重试时不会重复内容，$\\mathsf{createToken}$ 区分由相同逻辑请求创建的文件与预先存在的文件，$\\mathsf{deleteToken}$ 在使相同逻辑删除幂等的同时，为不同的逻辑请求保留“未找到”的回复，$\\mathsf{renameToken}$ 使用前置条件（$i, v$）以避免意外的额外移动，并在重试下返回相同的结果。结论 — 正确。\n\nB. 该选项错误地宣称 $\\mathsf{append}$ 是幂等的，理由是重复内容是“可接受的”。根据正式定义，追加两次产生的状态和回复与追加一次不同，因此它不是幂等的。它还错误地声称，在所述假设下 $\\mathsf{writeAt}$ 是非幂等的；在相同的 $o$ 处写入相同的 $B$ 两次会产生相同的状态和回复。此外，仅依赖客户端重试计数器 $c$ 而没有服务器端去重，不能保证服务器会抑制重复项，尤其是在重新连接或无状态服务器的情况下。结论 — 错误。\n\nC. 该选项错误地将 $\\mathsf{rename}$ 分类为幂等，理由是移动“不会再次移动它”，但重试会产生不同的回复，因为源路径已不存在，这违反了幂等性条件。它还将 $\\mathsf{delete}$ 视为幂等，但这在第二次执行返回“未找到”时失败。所提出的 $\\mathsf{create}$ 包装器仅依赖于将临时文件重命名为 $P$ 而不使用幂等性密钥，这并不能确保重试的重命名操作返回相同的回复；如果第一次重命名成功而第二次执行，源临时路径可能已不存在，回复也会不同。结论 — 错误。\n\nD. 该选项在给定假设下错误地将 $\\mathsf{read}$ 分类为非幂等；在没有中间写入的情况下，重试的读取操作返回相同的数据和回复。它错误地将 $\\mathsf{append}$ 分类为幂等。建议的“重试前休眠”没有提供任何服务器端机制来确保重复抑制或回复一致性，因此无法在重试下实现幂等行为。结论 — 错误。\n\n因此，正确的选项是 A。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "一个成功的服务不可避免地会随着时间演进，这要求对其RPC接口进行变更。这项实践将挑战你像系统架构师一样思考，评估不同的API版本控制策略，以在不中断现有用户的情况下支持新功能和破坏性变更。理解如何优雅地管理演化是确保分布式服务长期生命力和可维护性的基石。",
            "id": "3677065",
            "problem": "远程过程调用 (RPC) 是一种机制，通过该机制，一个地址空间中的客户端可以调用另一个地址空间中的服务器提供的过程，这通常跨越进程或机器边界。在操作系统层面，RPC 依赖于客户端和服务器之间的一个稳定契约，该契约描述了过程标识符、参数和结果的编码方式以及错误语义。假设存在以下基本事实：\n- 使用自描述编码（例如，类型-长度-值 (TLV)）的线路协议可以安全地携带实现未知的字段，因为可以使用长度和类型元数据跳过未知字段类型。因此，添加可选字段是向前兼容的：只要先前定义的字段和语义保持不变，旧版客户端就可以通过忽略未知字段来解析消息。\n- 向后兼容性意味着服务器升级不会强制现有客户端更改以继续运行：先前有效的过程调用和响应仍然有效并被正确解释。向前兼容性意味着新版客户端可以通过进行仅限于旧版服务器契约的调用来与旧版服务器互操作。\n\n考虑一个必须随时间演变的分布式服务。该服务有一套基线过程和几个可选功能（例如，压缩、追踪和流式传输）。环境包括无法立即升级的已部署客户端。设计目标是：\n- 向后兼容性：新服务器不应破坏现有客户端。\n- 功能协商：客户端和服务器只应在双方都支持可选功能时才启用它们。\n- 受控的破坏性变更：在绝对必要时，会破坏兼容性的变更必须被隔离，以便旧客户端仍然可以工作，而不会被立即强制更改。\n\n假设一个客户端支持主版本 $M_c = 1$，次要版本范围为 $[m_{c,\\min}, m_{c,\\max}] = [1, 3]$，以及一个功能集 $F_c = \\{\\text{gzip}, \\text{streaming}\\}$。一个服务器支持主版本 $M \\in \\{1, 2\\}$，其中 $M=1$ 的次要版本范围为 $[1, 5]$，$M=2$ 的次要版本范围为 $[0, 2]$，以及一个功能集 $F_s = \\{\\text{gzip}, \\text{streaming}, \\text{tracing}\\}$。线路编码是类似 TLV 的，因此未知字段可以被忽略。基线过程不需要任何强制性功能。服务必须选择一个兼容的接口和功能集，以使得：\n- 所选版本保留了客户端解析和响应操作以及服务器解析请求的能力。\n- 可选功能仅在双方都支持时才被启用；不支持的功能保持禁用状态，不会在基线调用中导致错误。\n- 在次要演变中添加新的可选字段或过程不应强制旧客户端更改，并且引入的破坏性变更不得静默地损坏调用，而应通过版本控制进行隔离，以便旧客户端可以继续工作。\n\n以下哪种 RPC 接口版本控制方案通常能实现这些目标？\n\nA. 对服务契约 $(M, m)$ 使用两级语义版本控制，其中 $M$ 是表示向后不兼容变更的主版本， $m$ 是表示向后兼容新增内容的次要版本。在连接建立时，客户端将其支持的主版本作为一个有限集 $V_c \\subset \\mathbb{N}$ 发送，并为每个 $M \\in V_c$ 发送一个次要版本区间 $[m_{c,\\min}(M), m_{c,\\max}(M)]$，以及一个功能集 $F_c \\subseteq \\mathcal{F}$ 的能力位图。服务器回复一个选定的版本 $(M^*, m^*)$，使得 $M^* \\in V_c \\cap V_s$ 且 $m^*$ 位于客户端和服务器对于 $M^*$ 的次要版本区间的交集中，并选择其中最高的 $m^*$；以及一个协商后的功能集 $F^* = F_c \\cap F_s$。线路协议保证未知的可选字段被忽略，并且在固定的 $M$ 内，过程标识符和现有字段的语义不会改变。服务器可以同时支持多个 $M$ 以避免破坏旧客户端；破坏性变更需要增加 $M$。\n\nB. 使用一个单一的单调递增的全局版本号 $v \\in \\mathbb{N}$，没有明确的次要级别或功能协商。服务器总是使用最新的 $v$，客户端必须升级以匹配。可选功能由 $v$ 隐含，不能独立切换。线路协议允许在较新的 $v$ 中更改字段含义以简化演变。\n\nC. 取消显式版本号，完全依赖于通过能力位图 $F \\subseteq \\mathcal{F}$ 进行的功能协商。功能的有无定义了契约。服务器启用客户端声明的任何功能，并在新功能存在时静默地更改字段语义。没有基线版本；不兼容的字段变更通过添加新功能和移除旧功能来处理。\n\nD. 为每个过程 $p$ 分配独立于服务范围版本的每个过程版本号 $v_p \\in \\mathbb{N}$。在连接时，服务器公布一个 $\\{p \\mapsto v_{s,p,\\max}\\}$ 的映射，客户端选择其偏好的任何 $\\{p \\mapsto v_{c,p}\\}$，最高不超过服务器的最大值。功能被嵌入在过程版本内部，不单独协商。线路编码不保证能安全跳过未知字段；旧客户端必须为每个 $p$ 解析精确的模式，并且字段可以在给定的 $v_p$ 内被重新利用以减少重复。\n\n选择满足向后兼容性、功能协商和受控破坏性变更，并且在添加新可选功能时不会破坏旧客户端的唯一最佳选项。",
            "solution": "问题陈述是分布式系统设计中的一个有效练习，特别是关于协议版本控制和演变。其前提在科学上基于既定的计算机科学原理，而目标——向后兼容性、功能协商和受控的破坏性变更——是明确定义和客观的。该问题是自包含且定义良好的，要求根据这些明确的标准评估不同的策略。\n\n问题中定义的健壮 RPC 演进策略的核心要求是：\n1.  **向后兼容性**：新部署的服务器不得破坏现有的、较旧的客户端。在客户端升级不是即时的环境中，这一点至关重要。问题暗示，这可以通过确保新增内容是可选的，并且使用自描述的线路协议（如类型-长度-值，TLV）让旧客户端忽略它们不理解的新字段来实现。\n2.  **功能协商**：可选能力（例如，压缩）必须进行显式协商，以便仅在客户端和服务器都支持时才启用。这可以防止因尝试使用不支持的功能而导致的错误。\n3.  **受控的破坏性变更**：不兼容的 API 变更（例如，更改字段含义、移除过程）必须是可能的，但必须以一种隔离其影响的方式进行管理。旧客户端必须能够继续使用旧的 API 契约运行，这意味着服务器可能需要同时支持多个不兼容的 API 版本。\n\n基于这些原则，我们将评估每个提议的版本控制方案。示例场景提供了一个具体案例：一个支持版本 $M_c = 1$、次要版本范围 $[1, 3]$ 和功能集 $F_c = \\{\\text{gzip}, \\text{streaming}\\}$ 的客户端，应该能够成功连接到一个支持主版本 $\\{1, 2\\}$、相应次要版本范围为 $[1, 5]$ 和 $[0, 2]$、以及功能集 $F_s = \\{\\text{gzip}, \\text{streaming}, \\text{tracing}\\}$ 的服务器。一次成功的协商会选择主版本 $M^* = 1$，一个兼容的次要版本（例如，最大公共版本 $m^*=3$），以及功能的交集 $F^* = \\{\\text{gzip}, \\text{streaming}\\}$。\n\n### 逐项分析\n\n**A. 对服务契约 $(M, m)$ 使用两级语义版本控制...**\n\n该方案提出了一种两级版本系统 $(M, m)$，其中 $M$ 表示向后不兼容的变更，而 $m$ 表示向后兼容的新增内容。协商协议明确定义如下：\n- 客户端发送其支持的主版本 $V_c$ 和相应的次要版本范围。\n- 客户端发送其支持的功能集 $F_c$。\n- 服务器响应一个相互支持的选定版本 $(M^*, m^*)$（通常是可用的最高版本），以及一个协商后的功能集 $F^* = F_c \\cap F_s$。\n- 它依赖于一种线路协议，其中未知的可选字段被忽略，并且过程/字段的语义在主版本 $M$ 内是稳定的。\n- 破坏性变更通过递增 $M$ 来管理，并且服务器可以同时支持多个主版本。\n\n让我们根据目标来评估这一点：\n- **向后兼容性**：这一点完美实现。支持 $M=1$ 的旧客户端可以与在 $M=1$ 内演进到更高次要版本的新服务器通信（例如，客户端在 $1.3$ 版本与服务器在 $1.5$ 版本通信）。服务器知道客户端的最大次要版本是 $3$，会将其响应限制在 $1.3$ 契约内。由于次要变更只是增量式的，并且线路协议会忽略未知的增量内容，因此客户端不会中断。\n- **功能协商**：通过交换功能集 ($F_c$, $F_s$) 并计算它们的交集 ($F^*$)，这一点得到了明确而稳健的处理。这是一个清晰、正交的机制。\n- **受控的破坏性变更**：这正是主版本 $M$ 的明确目的。一个破坏性变更需要将 $M$ 递增到，比如说，$M=2$。服务器可以同时提供 $M=1$ 和 $M=2$ 接口。旧客户端将协商使用 $M=1$ 并继续运行，而新客户端可以使用 $M=2$ 接口。这完美地隔离了破坏性变更。\n\n这个方案是健壮协议演进策略的教科书式例子。\n\n**结论：正确**\n\n**B. 使用一个单一的单调递增的全局版本号 $v \\in \\mathbb{N}$...**\n\n这个方案提出了一个单一的全局版本号 $v$。服务器总是使用最新版本，客户端被强制升级。功能不进行协商，而是与版本 $v$ 绑定。线路协议允许更改字段含义。\n\n让我们根据目标来评估这一点：\n- **向后兼容性**：该方案明确违反了向后兼容性。这是一个“锁步”模型，要求所有客户端都升级，这与问题陈述的目标相悖，即“现有客户端”不应因“服务器升级”而中断，并且他们“无法立即升级”。\n- **功能协商**：这一点被明确禁止。功能被僵硬地绑定到全局版本 $v$。\n- **受控的破坏性变更**：变更不受控制；它们被强制施加于所有客户端。能够“更改字段含义”是极其危险的，也是一个众所周知的反模式，可能导致静默数据损坏，而一个健壮的系统必须防止这种情况。\n\n这个方案很脆弱，不适合所述环境。\n\n**结论：不正确**\n\n**C. 取消显式版本号，完全依赖于功能协商...**\n\n该方案放弃了版本号，转而使用一组功能 $F$。契约由功能的集合定义。它允许服务器“在新功能存在时静默地更改字段语义”。\n\n让我们根据目标来评估这一点：\n- **向后兼容性**：这一点受到了严重损害。仅仅依赖功能集会产生组合复杂性。规则“在新功能存在时静默地更改字段语义”是一个关键缺陷。一个声明了功能 $\\{f_1, f_2\\}$ 的客户端可能会连接到一个支持 $\\{f_1, f_2, f_3\\}$ 的服务器。如果 $f_3$ 的存在改变了与 $f_1$ 相关的消息的语义，客户端将错误地解释数据，导致静默损坏。这是一种灾难性的故障模式。一个由版本控制保证的稳定基线契约是防止此类歧义所必需的。\n- **功能协商**：虽然它以功能协商为中心，但缺少一个带版本的基线使其不安全。没有版本，就无法推断功能 *组合* 的兼容性。\n- **受控的破坏性变更**：这个模型提供的控制很差。一个“破坏性变更”被建模为添加一个新功能并移除一个旧功能。一个不知道此协议演进的旧客户端可能会尝试一个不再有效的调用，导致意外错误或更糟的未定义行为。这未能“隔离”变更。\n\n这个方案定义不明确，并鼓励导致不确定性和静默错误的实践。\n\n**结论：不正确**\n\n**D. 为每个过程 $p$ 分配每个过程版本号 $v_p \\in \\mathbb{N}$...**\n\n这个方案提出了在单个过程级别上的细粒度版本控制。功能被嵌入到这些过程版本中。关键的是，它指出线路编码“不保证能安全跳过未知字段”并允许字段被“重新利用”。\n\n让我们根据目标来评估这一点：\n- **向后兼容性**：这一点被协议假设所破坏。如果旧客户端不能安全地跳过未知字段，那么服务器对过程响应的任何增量式更改都可能破坏客户端。这违反了轻松实现向后兼容演进的前提。允许字段被“重新利用”是一个严重的反模式，与选项B中的缺陷相同，可能导致静默数据损坏。\n- **功能协商**：这一点没有被正交地处理。将功能（如压缩）嵌入过程版本内部是糟糕的设计。像压缩这样的横切关注点应该在连接时协商一次，而不是在每个过程的基础上，这会导致冗余和复杂性。\n- **受控的破坏性变更**：虽然每个过程的版本控制似乎提供了隔离，但它创造了一个维护噩梦。对共享数据结构的更改将需要在所有使用它的过程中进行协调的版本升级。整个服务“契约”变成了一个复杂的过程版本矩阵，这比单一的服务级别版本要难管理得多。\n\n这个方案过于复杂、脆弱，其指定的线路协议对于演进式设计来说根本不安全。\n\n**结论：不正确**\n\n总之，选项 A 是唯一一个提出全面、安全且可扩展的策略，满足问题陈述中列出的所有设计目标的方案。它与演进分布式系统的最佳实践相一致。",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}