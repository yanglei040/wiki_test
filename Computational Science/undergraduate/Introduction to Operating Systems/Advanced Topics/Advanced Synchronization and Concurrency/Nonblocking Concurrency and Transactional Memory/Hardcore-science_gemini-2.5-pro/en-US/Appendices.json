{
    "hands_on_practices": [
        {
            "introduction": "The ABA problem is a subtle yet critical hazard in nonblocking algorithms that rely on the Compare-and-Swap (CAS) primitive. This exercise challenges you to move beyond the theoretical definition of the problem and into the realm of practical system design. By calculating the necessary bit-width for a version tag, you will learn how to quantitatively safeguard a lock-free data structure against this race condition, ensuring its correctness over long operational periods .",
            "id": "3663893",
            "problem": "A lock-free stack implemented with Atomic Compare-and-Swap (CAS) uses a tagged pointer in a single $64$-bit word to mitigate the ABA problem. The head field consists of a pointer and a version tag that increments by $1$ on every successful CAS that changes the head (both push and pop). The version tag is stored modulo $2^{b}$, where $b$ is the number of tag bits. The system’s worst-case rate of successful head updates is $N$ updates per second. To ensure that an ABA cannot be hidden by a tag wraparound during a target no-wrap interval of length $T$, the tag must not wrap within any interval of length $T$.\n\nAssume the following:\n- The worst-case sustained rate of successful head updates is $N = 1.2 \\times 10^{8}$ per second.\n- The required no-wrap interval is $T = 3$ hours.\n\nUsing only the standard semantics of Atomic Compare-and-Swap (CAS), the definition of the ABA problem, and the arithmetic relationship between rate and count over time, determine the minimal integer tag width $b$ (in bits) that guarantees no tag wraparound within any interval of length $T$. Express your answer as an exact integer number of bits. Do not include any units in your final answer.",
            "solution": "The problem requires determining the minimum integer number of bits, $b$, for a version tag to prevent a wraparound within a specified time interval, $T$, given a worst-case rate of updates, $N$. This is a classic problem in designing lock-free data structures to mitigate the ABA problem.\n\nFirst, we formalize the given parameters.\nThe worst-case sustained rate of successful head updates is $N = 1.2 \\times 10^{8}$ updates per second.\nThe required no-wrap interval is $T = 3$ hours.\nThe version tag is an integer counter stored in $b$ bits, which increments with each successful update. This tag can represent $2^b$ distinct values, from $0$ to $2^b - 1$. A wraparound occurs when the counter increments $2^b$ times, causing its value to reset to the starting value (modulo $2^b$).\n\nThe core principle is that to guarantee no wraparound within the interval $T$, the total number of updates that can occur during this interval must be strictly less than the number of unique states the tag can represent.\n\nLet $U_{max}$ be the maximum number of updates that can occur in the time interval $T$. This is calculated by multiplying the rate of updates $N$ by the duration of the interval $T$.\nFirst, we must express $T$ in a consistent unit with $N$, which is seconds.\nGiven $T = 3$ hours, we convert it to seconds:\n$$T_{\\text{seconds}} = 3 \\text{ hours} \\times \\frac{60 \\text{ minutes}}{1 \\text{ hour}} \\times \\frac{60 \\text{ seconds}}{1 \\text{ minute}} = 3 \\times 3600 \\text{ seconds} = 10800 \\text{ s}$$\n\nNext, we calculate the total maximum number of updates, $U_{max}$, over this interval:\n$$U_{max} = N \\times T_{\\text{seconds}}$$\n$$U_{max} = (1.2 \\times 10^{8} \\text{ s}^{-1}) \\times (10800 \\text{ s})$$\n$$U_{max} = 1.2 \\times 10^{8} \\times 1.08 \\times 10^{4}$$\n$$U_{max} = 1.296 \\times 10^{12}$$\n\nThe number of distinct states a $b$-bit tag can represent is $2^b$. To prevent a wraparound, the total number of updates, $U_{max}$, must be less than $2^b$.\n$$U_{max} < 2^b$$\n$$1.296 \\times 10^{12} < 2^b$$\n\nTo find the minimum integer value of $b$ that satisfies this inequality, we take the base-$2$ logarithm of both sides:\n$$\\log_{2}(1.296 \\times 10^{12}) < \\log_{2}(2^b)$$\n$$\\log_{2}(1.296 \\times 10^{12}) < b$$\n\nWe can evaluate the logarithm:\n$$\\log_{2}(1.296 \\times 10^{12}) = \\frac{\\ln(1.296 \\times 10^{12})}{\\ln(2)}$$\nUsing computational tools for precision:\n$$\\ln(1.296 \\times 10^{12}) \\approx 27.890270$$\n$$\\ln(2) \\approx 0.693147$$\n$$b > \\frac{27.890270}{0.693147} \\approx 40.236606$$\n\nSince $b$ must be an integer, the smallest integer value for $b$ that satisfies the condition $b > 40.236606$ is $41$.\nTherefore, a minimum of $b=41$ bits are required for the version tag to ensure it does not wrap around within any $3$-hour interval under the given worst-case update rate.\nIf $b=40$, the number of states is $2^{40} \\approx 1.0995 \\times 10^{12}$. This is less than the required $1.296 \\times 10^{12}$ updates, so a wraparound could occur.\nIf $b=41$, the number of states is $2^{41} \\approx 2.1990 \\times 10^{12}$. This is greater than $1.296 \\times 10^{12}$, thus satisfying the no-wrap condition.",
            "answer": "$$\\boxed{41}$$"
        },
        {
            "introduction": "At the heart of nonblocking algorithms are atomic hardware primitives like Compare-and-Swap (CAS) and Load-Linked/Store-Conditional (LL/SC). While they serve a similar purpose, their performance characteristics and failure modes can differ significantly. This practice asks you to build a simple probabilistic model to formally analyze and compare the expected performance of these two primitives, giving you a deeper appreciation for the architectural trade-offs involved in designing high-performance concurrent code .",
            "id": "3663895",
            "problem": "A systems engineer is evaluating two lock-free implementations of a stack push operation: one based on Compare-and-Swap (CAS) and one based on Load-Linked/Store-Conditional (LL/SC). The stack top is a single pointer. Each push attempt consists of reading the current top, building a new node that points to the observed top, and trying to swing the top pointer to the new node.\n\nAssume the following foundations:\n- A lock-free operation terminates when a successful atomic update occurs; otherwise, it retries.\n- In the CAS implementation, each attempt succeeds if and only if no interfering update by another thread occurs before the CAS.\n- In the LL/SC implementation, each attempt succeeds if and only if no interfering update occurs between the Load-Linked and the Store-Conditional, and the Store-Conditional is not rejected spuriously by the hardware.\n\nModel interference and spurious failure as follows:\n- On any attempt, let the probability that some other thread performs an interfering update be $p_{c}$, with $0 \\leq p_{c} < 1$. If interference occurs, the attempt definitively fails in both implementations.\n- Conditional on no interference in an LL/SC attempt, let the Store-Conditional fail spuriously with probability $p_{s}$, with $0 \\leq p_{s} < 1$. In the CAS implementation, there are no spurious failures.\n- Across attempts, all coin flips are independent and identically distributed. Within an attempt, interference and spurious failure events are independent.\n\nLet the expected number of retries be defined as the expected number of attempts until the first success, minus $1$.\n\nStarting from first principles in probability (in particular, the expectation of the number of independent Bernoulli trials needed for the first success), derive a closed-form expression for the difference in expected retries between the LL/SC and CAS implementations, denoted $\\Delta$, where\n$$\n\\Delta \\equiv \\mathbb{E}[\\text{retries}_{\\text{LL/SC}}] - \\mathbb{E}[\\text{retries}_{\\text{CAS}}]\n$$.\nYour final answer must be a single analytic expression in terms of $p_{c}$ and $p_{s}$. Do not approximate or round.",
            "solution": "The problem statement has been validated and is deemed sound, well-posed, and based on established principles of computer science and probability theory. All necessary parameters and definitions are provided, allowing for a rigorous derivation.\n\nThe core of the problem is to determine the expected number of attempts required to achieve a single successful operation for two different implementations, Compare-And-Swap (CAS) and Load-Linked/Store-Conditional (LL/SC), and then find the difference in their expected number of retries.\n\nAn attempt to perform the push operation is a Bernoulli trial, where success is the desired outcome. Let $N$ be the random variable representing the number of attempts until the first success. If the probability of success in a single trial is $p$, then $N$ follows a geometric distribution with probability mass function $P(N=k) = (1-p)^{k-1}p$ for $k = 1, 2, 3, \\dots$. The expected value of such a random variable is $\\mathbb{E}[N] = \\frac{1}{p}$.\n\nThe problem defines the expected number of retries as the expected number of attempts minus $1$. Thus, $\\mathbb{E}[\\text{retries}] = \\mathbb{E}[N] - 1$.\n\nFirst, we analyze the CAS implementation.\nAn attempt with the CAS implementation succeeds if and only if there is no interfering update from another thread. The probability of such an interference is given as $p_c$. Therefore, the probability of success for a single CAS attempt, which we denote as $P_{\\text{CAS}}$, is the probability of no interference:\n$$P_{\\text{CAS}} = 1 - p_c$$\nThe number of attempts until a successful CAS operation, $N_{\\text{CAS}}$, follows a geometric distribution with success probability $P_{\\text{CAS}}$. Its expected value is:\n$$\\mathbb{E}[N_{\\text{CAS}}] = \\frac{1}{P_{\\text{CAS}}} = \\frac{1}{1 - p_c}$$\nThe expected number of retries for the CAS implementation is then:\n$$\\mathbb{E}[\\text{retries}_{\\text{CAS}}] = \\mathbb{E}[N_{\\text{CAS}}] - 1 = \\frac{1}{1 - p_c} - 1$$\n\nNext, we analyze the LL/SC implementation.\nAn attempt with the LL/SC implementation succeeds if and only if two conditions are met:\n$1$. There is no interfering update from another thread.\n$2$. The Store-Conditional does not fail spuriously.\n\nLet $I$ be the event of an interfering update, so $P(I) = p_c$. The event of no interference is $I^c$, with probability $P(I^c) = 1 - p_c$.\nLet $S$ be the event of a spurious failure. The problem states that the probability of a spurious failure is conditional on no interference. Let this be $P(S|I^c) = p_s$.\n\nA successful LL/SC attempt corresponds to the joint event of no interference ($I^c$) and no spurious failure ($S^c$). The probability of success for a single LL/SC attempt, $P_{\\text{LL/SC}}$, is $P(I^c \\cap S^c)$.\nUsing the definition of conditional probability, $P(A \\cap B) = P(B|A)P(A)$, we have:\n$$P_{\\text{LL/SC}} = P(S^c | I^c) P(I^c)$$\nThe probability of no spurious failure, given no interference, is $P(S^c | I^c) = 1 - P(S | I^c) = 1 - p_s$.\nSubstituting the known probabilities, we get:\n$$P_{\\text{LL/SC}} = (1 - p_s)(1 - p_c)$$\nThe number of attempts until a successful LL/SC operation, $N_{\\text{LL/SC}}$, follows a geometric distribution with success probability $P_{\\text{LL/SC}}$. Its expected value is:\n$$\\mathbb{E}[N_{\\text{LL/SC}}] = \\frac{1}{P_{\\text{LL/SC}}} = \\frac{1}{(1 - p_s)(1 - p_c)}$$\nThe expected number of retries for the LL/SC implementation is:\n$$\\mathbb{E}[\\text{retries}_{\\text{LL/SC}}] = \\mathbb{E}[N_{\\text{LL/SC}}] - 1 = \\frac{1}{(1 - p_s)(1 - p_c)} - 1$$\n\nFinally, we compute the difference $\\Delta$ as defined in the problem statement:\n$$\\Delta \\equiv \\mathbb{E}[\\text{retries}_{\\text{LL/SC}}] - \\mathbb{E}[\\text{retries}_{\\text{CAS}}]$$\nSubstituting the expressions derived above:\n$$\\Delta = \\left( \\frac{1}{(1 - p_s)(1 - p_c)} - 1 \\right) - \\left( \\frac{1}{1 - p_c} - 1 \\right)$$\nThe constant term $-1$ cancels out:\n$$\\Delta = \\frac{1}{(1 - p_s)(1 - p_c)} - \\frac{1}{1 - p_c}$$\nTo simplify, we find a common denominator, which is $(1 - p_s)(1 - p_c)$, but it is more direct to factor out the common term $\\frac{1}{1 - p_c}$:\n$$\\Delta = \\frac{1}{1 - p_c} \\left( \\frac{1}{1 - p_s} - 1 \\right)$$\nNow, we simplify the expression in the parenthesis:\n$$\\frac{1}{1 - p_s} - 1 = \\frac{1}{1 - p_s} - \\frac{1 - p_s}{1 - p_s} = \\frac{1 - (1 - p_s)}{1 - p_s} = \\frac{1 - 1 + p_s}{1 - p_s} = \\frac{p_s}{1 - p_s}$$\nSubstituting this back into the expression for $\\Delta$:\n$$\\Delta = \\frac{1}{1 - p_c} \\cdot \\frac{p_s}{1 - p_s}$$\nThis gives the final closed-form expression for the difference in expected retries:\n$$\\Delta = \\frac{p_s}{(1 - p_c)(1 - p_s)}$$\nThe result is positive for $p_s > 0$, indicating, as expected, that the LL/SC implementation has a higher number of expected retries due to the possibility of spurious failures.",
            "answer": "$$\n\\boxed{\\frac{p_s}{(1 - p_c)(1 - p_s)}}\n$$"
        },
        {
            "introduction": "While powerful, low-level primitives like CAS can be difficult to compose into large, correct concurrent programs. Transactional Memory (TM) offers a higher-level abstraction, allowing developers to group sequences of operations into atomic 'transactions.' This hands-on coding challenge immerses you in the inner workings of a TM system by having you implement a transactional memory allocator, forcing you to grapple with fundamental concepts like atomicity, speculative execution, and the notoriously difficult problem of integrating 'irrevocable' operations into a transactional model .",
            "id": "3663912",
            "problem": "You are to design and implement a nonblocking, transactional, per-thread memory allocator simulator that enforces consistent global accounting across threads and correctly handles irrevocable deallocation operations. The program you produce must be a complete, runnable program that outputs a single line in the exact format described below.\n\nFundamental base and core definitions:\n- Atomic read-modify-write using compare-and-swap (CAS) is a widely accepted primitive that provides linearizable updates without locks. Model this by an atomic integer that can be incremented and compared-exchanged.\n- In a transactional memory model, a thread executes a transaction that accumulates a write-set delta, here the net memory change, and commits atomically. Let the global total allocated bytes be $G$, the per-thread local allocated bytes be $L_i$, and the per-transaction net change be $\\Delta_i$. A correct commit must preserve $G_{\\text{final}} = G_{\\text{initial}} + \\sum \\Delta_i^{\\text{committed}}$ and $G_{\\text{final}} = \\sum L_i^{\\text{final}}$.\n- Nonblocking progress means that no thread holds locks; progress is achieved via atomic operations and abort/retry. An irrevocable operation is one that cannot be safely rolled back. An irrevocable $free()$ call must be serialized globally to preserve correctness; only one thread may perform it at a time.\n\nBehavioral specification:\n- Each thread $i$ begins with a known local allocation $L_i$ (in bytes). The global total $G$ begins consistent with $G = \\sum L_i$.\n- Each thread executes a transaction with an ordered sequence of operations of three kinds:\n  1. Allocate: increases the local delta by a nonnegative integer amount $a$, i.e., $\\Delta \\leftarrow \\Delta + a$.\n  2. Free: decreases the local delta by a nonnegative integer amount $f$, i.e., $\\Delta \\leftarrow \\Delta - f$.\n  3. Irrevocable free: an operation identical to free in effect, but it must be globally serialized. A thread can perform at most one irrevocable free in its transaction. Only one thread may hold the irrevocable right at a time, modeled by a global owner variable, acquired by CAS. If the irrevocable right is not available to the requesting thread, the transaction must abort immediately, performing no global or local changes.\n- A transaction must also abort if it would cause the local allocation to become negative upon commit. Formally, a commit is permitted only if $L_i + \\Delta \\ge 0$.\n- On successful commit, apply $\\Delta$ atomically to $G$ and update $L_i \\leftarrow L_i + \\Delta$, releasing any irrevocable ownership if held. On abort, leave $G$ and $L_i$ unchanged and release any irrevocable ownership if acquired.\n\nDeterministic tie-breaking for irrevocable free:\n- To avoid nondeterminism and livelock in this exercise, a single global tie-breaker identifies the thread identifier allowed to acquire the irrevocable right next. Only the thread whose identifier equals this tie-breaker may acquire the irrevocable right when it attempts an irrevocable free; other threads attempting an irrevocable free must abort immediately. If the tie-breaker is set to $-1$, all threads are allowed to attempt acquisition, but in this problem’s test suite the tie-breaker is set to a specific thread identifier wherever multiple threads perform irrevocable free operations concurrently.\n\nYour program must:\n- Simulate the above transactional per-thread allocator semantics using atomic operations only (no locks), utilizing threads for concurrency. You must use integer bytes, with all accounting in bytes.\n- Produce a single line of output containing the aggregated results for the provided test suite in the exact specified format.\n\nTest suite to implement:\n- Test case $1$ (happy path, no irrevocable operations):\n  - Threads: $2$; tie-breaker $=-1$.\n  - Initial locals: $L_0 = 0$, $L_1 = 0$; set $G = 0$.\n  - Operations:\n    - Thread $0$: allocate $100$, allocate $50$, free $70$.\n    - Thread $1$: allocate $30$, free $10$, allocate $5$.\n  - Expected properties: both transactions commit; final accounting must be consistent.\n- Test case $2$ (irrevocable free serialization):\n  - Threads: $3$; tie-breaker $=0$.\n  - Initial locals: $L_0 = 200$, $L_1 = 150$, $L_2 = 0$; set $G = 350$.\n  - Operations:\n    - Thread $0$: irrevocable free $200$.\n    - Thread $1$: irrevocable free $150$.\n    - Thread $2$: allocate $60$.\n  - Expected properties: thread $0$ commits its irrevocable free; thread $1$ aborts on attempting irrevocable free due to the tie-breaker; thread $2$ commits; final accounting must be consistent.\n- Test case $3$ (zero net delta, commit succeeds):\n  - Threads: $1$; tie-breaker $=-1$.\n  - Initial locals: $L_0 = 100$; set $G = 100$.\n  - Operations:\n    - Thread $0$: allocate $100$, free $100$.\n  - Expected properties: commit succeeds with $\\Delta = 0$; final accounting must be consistent.\n- Test case $4$ (safety abort on negative local):\n  - Threads: $1$; tie-breaker $=-1$.\n  - Initial locals: $L_0 = 50$; set $G = 50$.\n  - Operations:\n    - Thread $0$: free $60$.\n  - Expected properties: transaction aborts because $L_0 + \\Delta = 50 - 60 = -10$ would be negative; final accounting must be consistent.\n\nRequired output format:\n- For each test case $i$, compute the final global total bytes $G_i$ (an integer), the number of committed transactions $C_i$ (an integer), the number of aborted transactions $A_i$ (an integer), and a consistency indicator $B_i$ (a boolean expressed as $1$ for true and $0$ for false) for whether $G_i = \\sum L_j^{\\text{final}}$ holds.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the exact order: $[G_1,C_1,A_1,B_1,G_2,C_2,A_2,B_2,G_3,C_3,A_3,B_3,G_4,C_4,A_4,B_4]$.\n\nAll answers are integers. No user input is allowed; all data is hardcoded as specified above.",
            "solution": "The problem requires the design and implementation of a deterministic simulation for a nonblocking, transactional memory allocator. The solution adheres to the specified behavioral rules, employing atomic operations for concurrency control as mandated. The core of the solution is a C program that simulates four distinct test cases, each involving multiple threads executing transactions, and then aggregates the results into a single formatted output line.\n\nThe logical design is founded on the following principles:\n\n1.  **State Representation**: The system's state is partitioned into shared global state and per-thread local state.\n    -   The global total of allocated bytes, $G$, is represented by an `_Atomic long` variable. This ensures that updates from concurrent committing transactions are correctly serialized and applied without data races.\n    -   The ownership for irrevocable free operations is managed by a single global `_Atomic int` variable, `irrevocable_owner`. A value of $-1$ signifies that the right is unowned. A thread with ID $i$ acquires the right by successfully executing a compare-and-swap (CAS) operation to change the value from $-1$ to $i$.\n    -   Per-thread local allocations, $L_i$, are stored in a standard `long` array. Since each thread $i$ exclusively modifies its own element $L_i$ (and only upon a successful commit), direct atomic operations on this array are not necessary. Access by the main thread for verification occurs only after all worker threads have terminated, thus preventing race conditions.\n    -   Aggregate statistics for each test case—the number of committed transactions $C_i$ and aborted transactions $A_i$—are also modeled as `_Atomic int` counters to allow for safe concurrent increments.\n\n2.  **Transactional Execution Model**: Each thread's execution is modeled as a single, all-or-nothing transaction. A dedicated thread function implements this logic.\n    -   **Accumulation Phase**: The thread first processes its assigned sequence of operations (`allocate`, `free`, `irrevocable free`). It calculates the net change in allocation, $\\Delta$, in a private local variable.\n    -   **Abort Conditions**: The transaction is designed to abort immediately under specific conditions, ensuring forward progress and correctness without locks.\n        -   **Irrevocable Free Failure**: An attempt to perform an `irrevocable free` triggers an abort if (a) a `tie_breaker` is active and the thread's ID does not match, or (b) the thread fails to acquire the global irrevocable ownership via CAS because it is already held.\n        -   **Safety Violation**: Before committing, the transaction verifies that the commit would not result in a negative local allocation. If $L_i + \\Delta < 0$, the transaction must abort.\n    -   **Commit/Abort Logic**:\n        -   **On Commit**: If no abort conditions are met, the transaction commits. The calculated $\\Delta$ is atomically added to the global total $G$ using `atomic_fetch_add`. The thread's local allocation is updated: $L_i \\leftarrow L_i + \\Delta$. If the thread had acquired the irrevocable right, it releases it by atomically setting `irrevocable_owner` back to $-1$. Finally, the global commit counter $C_i$ is atomically incremented.\n        -   **On Abort**: The global state $G$ and the local state $L_i$ remain unchanged. If the thread had acquired the irrevocable right during the transaction attempt, it must release it to prevent deadlock. The global abort counter $A_i$ is atomically incremented.\n\n3.  **Concurrency and Determinism**: The simulation utilizes the C `threads.h` library to create and manage threads, thereby modeling the specified concurrent environment. However, the problem's strict rules, including a fixed sequence of operations for each thread and a deterministic tie-breaker for irrevocable operations, eliminate runtime nondeterminism. This ensures that the simulation yields a single, predictable, and verifiable outcome for each test case.\n\n4.  **Verification**: After all threads for a given test case have completed their execution and are joined, the main thread performs a final consistency check. It calculates the sum of all final per-thread local allocations, $\\sum L_j^{\\text{final}}$, and compares it to the final global allocation total, $G_i$. The result of this check is stored as a boolean indicator, $B_i$, which must be true ($1$) if the simulation is correct. This validates the fundamental invariant $G = \\sum L_j$.\n\nThe implementation systematically applies these principles to each of the four test cases. A `TestCase` data structure is defined to hold the initial parameters ($L_i$ values, tie-breaker) and the list of operations for each thread. The main program iterates through these test cases, sets up the initial state, runs the concurrent simulation, and collects the final results ($G_i, C_i, A_i, B_i$). Finally, it prints all collected results in the precisely specified comma-separated format.",
            "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <threads.h>\n#include <stdatomic.h>\n\n// Enum and structs for defining operations and test cases.\ntypedef enum { ALLOC, FREE, IRREVOCABLE_FREE } OpType;\n\ntypedef struct {\n    OpType type;\n    long amount;\n} Operation;\n\ntypedef struct {\n    int num_threads;\n    int tie_breaker;\n    const long* initial_local_bytes;\n    const int* ops_per_thread;\n    Operation const* const* ops_list;\n} TestCase;\n\n// Struct for passing arguments to each thread.\ntypedef struct {\n    int thread_id;\n    int num_ops;\n    const Operation* ops;\n\n    // Shared state pointers\n    _Atomic long* global_total;\n    long* local_bytes_array;\n    _Atomic int* irrevocable_owner;\n    int tie_breaker;\n    _Atomic int* committed_count;\n    _Atomic int* aborted_count;\n} ThreadArgs;\n\n// The function executed by each thread to run one transaction.\nint run_transaction(void* arg) {\n    ThreadArgs* args = (ThreadArgs*)arg;\n    \n    long delta = 0;\n    int must_abort = 0;\n    int acquired_irrevocable_right = 0;\n    const int UNOWNED = -1;\n\n    // 1. Process operation sequence to compute delta and check for abort conditions.\n    for (int i = 0; i < args->num_ops; ++i) {\n        Operation op = args->ops[i];\n        switch (op.type) {\n            case ALLOC:\n                delta += op.amount;\n                break;\n            case FREE:\n                delta -= op.amount;\n                break;\n            case IRREVOCABLE_FREE:\n                // Tie-breaker check\n                if (args->tie_breaker != -1 && args->thread_id != args->tie_breaker) {\n                    must_abort = 1;\n                    goto end_op_loop;\n                }\n                \n                // CAS to acquire ownership\n                int expected_owner = UNOWNED;\n                if (!atomic_compare_exchange_strong(args->irrevocable_owner, &expected_owner, args->thread_id)) {\n                    must_abort = 1;\n                    goto end_op_loop;\n                }\n                \n                acquired_irrevocable_right = 1;\n                delta -= op.amount;\n                break;\n        }\n    }\nend_op_loop:;\n\n    // 2. Further pre-commit check for negative local allocation.\n    if (!must_abort) {\n        if (args->local_bytes_array[args->thread_id] + delta < 0) {\n            must_abort = 1;\n        }\n    }\n    \n    // 3. Commit or Abort.\n    if (must_abort) {\n        // ABORT\n        atomic_fetch_add(args->aborted_count, 1);\n        if (acquired_irrevocable_right) {\n            atomic_store(args->irrevocable_owner, UNOWNED);\n        }\n    } else {\n        // COMMIT\n        atomic_fetch_add(args->global_total, delta);\n        args->local_bytes_array[args->thread_id] += delta;\n        \n        if (acquired_irrevocable_right) {\n            atomic_store(args->irrevocable_owner, UNOWNED);\n        }\n        \n        atomic_fetch_add(args->committed_count, 1);\n    }\n    \n    return thrd_success;\n}\n\nint main(void) {\n    // Define the test case data statically.\n    // Test Case 1 Data\n    const Operation tc1_t0_ops[] = {{ALLOC, 100}, {ALLOC, 50}, {FREE, 70}};\n    const Operation tc1_t1_ops[] = {{ALLOC, 30}, {FREE, 10}, {ALLOC, 5}};\n    Operation const* const tc1_ops_list[] = {tc1_t0_ops, tc1_t1_ops};\n    const long tc1_initial_locals[] = {0, 0};\n    const int tc1_ops_per_thread[] = {3, 3};\n\n    // Test Case 2 Data\n    const Operation tc2_t0_ops[] = {{IRREVOCABLE_FREE, 200}};\n    const Operation tc2_t1_ops[] = {{IRREVOCABLE_FREE, 150}};\n    const Operation tc2_t2_ops[] = {{ALLOC, 60}};\n    Operation const* const tc2_ops_list[] = {tc2_t0_ops, tc2_t1_ops, tc2_t2_ops};\n    const long tc2_initial_locals[] = {200, 150, 0};\n    const int tc2_ops_per_thread[] = {1, 1, 1};\n\n    // Test Case 3 Data\n    const Operation tc3_t0_ops[] = {{ALLOC, 100}, {FREE, 100}};\n    Operation const* const tc3_ops_list[] = {tc3_t0_ops};\n    const long tc3_initial_locals[] = {100};\n    const int tc3_ops_per_thread[] = {2};\n\n    // Test Case 4 Data\n    const Operation tc4_t0_ops[] = {{FREE, 60}};\n    Operation const* const tc4_ops_list[] = {tc4_t0_ops};\n    const long tc4_initial_locals[] = {50};\n    const int tc4_ops_per_thread[] = {1};\n\n    TestCase test_cases[] = {\n        {2, -1, tc1_initial_locals, tc1_ops_per_thread, tc1_ops_list},\n        {3, 0, tc2_initial_locals, tc2_ops_per_thread, tc2_ops_list},\n        {1, -1, tc3_initial_locals, tc3_ops_per_thread, tc3_ops_list},\n        {1, -1, tc4_initial_locals, tc4_ops_per_thread, tc4_ops_list}\n    };\n\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    long results[num_cases * 4];\n\n    for (int i = 0; i < num_cases; ++i) {\n        TestCase* tc = &test_cases[i];\n        \n        // Initialize shared state\n        _Atomic long global_total;\n        long initial_global = 0;\n        long* local_bytes_array = (long*)malloc(tc->num_threads * sizeof(long));\n        for(int j = 0; j < tc->num_threads; ++j) {\n            local_bytes_array[j] = tc->initial_local_bytes[j];\n            initial_global += tc->initial_local_bytes[j];\n        }\n        atomic_init(&global_total, initial_global);\n\n        _Atomic int irrevocable_owner;\n        atomic_init(&irrevocable_owner, -1);\n        _Atomic int committed_count;\n        atomic_init(&committed_count, 0);\n        _Atomic int aborted_count;\n        atomic_init(&aborted_count, 0);\n        \n        thrd_t* threads = (thrd_t*)malloc(tc->num_threads * sizeof(thrd_t));\n        ThreadArgs* args = (ThreadArgs*)malloc(tc->num_threads * sizeof(ThreadArgs));\n\n        // Create and launch threads\n        for (int j = 0; j < tc->num_threads; ++j) {\n            args[j] = (ThreadArgs){\n                .thread_id = j,\n                .num_ops = tc->ops_per_thread[j],\n                .ops = tc->ops_list[j],\n                .global_total = &global_total,\n                .local_bytes_array = local_bytes_array,\n                .irrevocable_owner = &irrevocable_owner,\n                .tie_breaker = tc->tie_breaker,\n                .committed_count = &committed_count,\n                .aborted_count = &aborted_count\n            };\n            thrd_create(&threads[j], run_transaction, &args[j]);\n        }\n        \n        // Wait for all threads to complete\n        for (int j = 0; j < tc->num_threads; ++j) {\n            thrd_join(threads[j], NULL);\n        }\n\n        // Collect results\n        results[i * 4 + 0] = atomic_load(&global_total);\n        results[i * 4 + 1] = atomic_load(&committed_count);\n        results[i * 4 + 2] = atomic_load(&aborted_count);\n        \n        // Consistency check\n        long final_local_sum = 0;\n        for (int j = 0; j < tc->num_threads; ++j) {\n            final_local_sum += local_bytes_array[j];\n        }\n        results[i * 4 + 3] = (atomic_load(&global_total) == final_local_sum);\n\n        free(threads);\n        free(args);\n        free(local_bytes_array);\n    }\n\n    // Print the results in the EXACT required format.\n    printf(\"[\");\n    for (int i = 0; i < num_cases * 4 - 1; ++i) {\n        printf(\"%ld,\", results[i]);\n    }\n    printf(\"%ld]\\n\", results[num_cases * 4 - 1]);\n\n    return EXIT_SUCCESS;\n}\n```"
        }
    ]
}