{
    "hands_on_practices": [
        {
            "introduction": "ABA 问题是设计无锁数据结构时的一个常见且微妙的陷阱。本练习将通过一个具体的工程场景，让你亲手实践解决 ABA 问题的核心技术——标签指针。通过计算在高并发系统中为防止标签回绕（tag wraparound）所需的最小时钟周期标签位宽，你将深刻理解其背后的设计权衡和数学原理，从而在理论和实践之间建立起坚实的桥梁。 ",
            "id": "3663893",
            "problem": "一个使用原子比较并交换（CAS）实现的无锁栈，在一个 $64$ 位字中使用带标签的指针来缓解 ABA 问题。head 字段由一个指针和一个版本标签组成，每次成功改变 head（包括 push 和 pop 操作）的 CAS 操作都会使该标签加 $1$。版本标签以模 $2^{b}$ 的形式存储，其中 $b$ 是标签的位数。系统成功更新 head 的最坏情况速率是每秒 $N$ 次更新。为确保在长度为 $T$ 的目标无回绕间隔内，ABA 问题不会因标签回绕而被隐藏，标签在任何长度为 $T$ 的间隔内都不能发生回绕。\n\n假设如下：\n- 成功更新 head 的最坏情况持续速率是 $N = 1.2 \\times 10^{8}$ 次/秒。\n- 要求的无回绕间隔是 $T = 3$ 小时。\n\n仅使用原子比较并交换（CAS）的标准语义、ABA 问题的定义以及速率和计数随时间变化的算术关系，确定保证在任何长度为 $T$ 的间隔内标签不发生回绕的最小整数标签宽度 $b$（以位为单位）。将您的答案表示为精确的整数位数。最终答案中不要包含任何单位。",
            "solution": "该问题要求，在给定最坏情况下的更新速率 $N$ 和指定的时间间隔 $T$ 的条件下，确定版本标签所需的最小整数位数 $b$，以防止在该时间间隔内发生回绕。这是设计无锁数据结构以缓解 ABA 问题时的一个经典问题。\n\n首先，我们将给定的参数形式化。\n成功更新 head 的最坏情况持续速率是 $N = 1.2 \\times 10^{8}$ 次/秒。\n要求的无回绕间隔是 $T = 3$ 小时。\n版本标签是一个用 $b$ 位存储的整数计数器，每次成功更新时都会递增。该标签可以表示 $2^b$ 个不同的值，从 $0$ 到 $2^b - 1$。当计数器递增 $2^b$ 次时，会发生回绕，导致其值重置为初始值（以 $2^b$ 为模）。\n\n核心原则是，为保证在间隔 $T$ 内不发生回绕，此间隔内可能发生的最大更新总数必须严格小于标签可以表示的唯一状态数。\n\n设 $U_{max}$ 为时间间隔 $T$ 内可能发生的最大更新次数。这可以通过将更新速率 $N$ 乘以间隔时长 $T$ 来计算。\n首先，我们必须将 $T$ 表示为与 $N$ 一致的单位，即秒。\n给定 $T = 3$ 小时，我们将其转换为秒：\n$$T_{\\text{seconds}} = 3 \\text{ hours} \\times \\frac{60 \\text{ minutes}}{1 \\text{ hour}} \\times \\frac{60 \\text{ seconds}}{1 \\text{ minute}} = 3 \\times 3600 \\text{ seconds} = 10800 \\text{ s}$$\n\n接下来，我们计算在此间隔内的最大更新总数 $U_{max}$：\n$$U_{max} = N \\times T_{\\text{seconds}}$$\n$$U_{max} = (1.2 \\times 10^{8} \\text{ s}^{-1}) \\times (10800 \\text{ s})$$\n$$U_{max} = 1.2 \\times 10^{8} \\times 1.08 \\times 10^{4}$$\n$$U_{max} = 1.296 \\times 10^{12}$$\n\n一个 $b$ 位标签可以表示的独立状态数是 $2^b$。为了防止回绕，总更新次数 $U_{max}$ 必须小于 $2^b$。\n$$U_{max}  2^b$$\n$$1.296 \\times 10^{12}  2^b$$\n\n为了找到满足此不等式的最小整数 $b$ 值，我们对两边取以 $2$ 为底的对数：\n$$\\log_{2}(1.296 \\times 10^{12})  b$$\n\n我们可以计算该对数值：\n$$\\log_{2}(1.296 \\times 10^{12}) = \\frac{\\ln(1.296 \\times 10^{12})}{\\ln(2)}$$\n使用计算工具以获得精确值：\n$$\\ln(1.296 \\times 10^{12}) \\approx 27.890270$$\n$$\\ln(2) \\approx 0.693147$$\n$$b > \\frac{27.890270}{0.693147} \\approx 40.236606$$\n\n由于 $b$ 必须是整数，满足条件 $b > 40.236606$ 的最小整数值是 $41$。\n因此，在给定的最坏情况更新速率下，版本标签至少需要 $b=41$ 位，以确保它在任何 $3$ 小时的间隔内都不会回绕。\n如果 $b=40$，状态数为 $2^{40} \\approx 1.0995 \\times 10^{12}$。这个值小于所需的 $1.296 \\times 10^{12}$ 次更新，因此可能会发生回绕。\n如果 $b=41$，状态数为 $2^{41} \\approx 2.1990 \\times 10^{12}$。这个值大于 $1.296 \\times 10^{12}$，因此满足无回绕条件。",
            "answer": "$$\\boxed{41}$$"
        },
        {
            "introduction": "构建稳健的非阻塞系统不仅需要了解原子指令，还需要深入理解它们与操作系统事件（如中断）的复杂互动。本练习模拟了一个真实场景，要求你分析在中断和多核竞争环境下，基于“加载链接/条件存储”(LL/SC) 的算法其进度保证会受到何种影响。这有助于你将并发理论（如无锁与无等待）与复杂的系统行为联系起来，提升对系统整体正确性的推理能力。 ",
            "id": "3663960",
            "problem": "考虑一个拥有多个处理器核心的系统，其运行的操作系统采用基于 Load-Linked (LL) 和 Store-Conditional (SC) 的非阻塞同步。在 Load-Linked (LL) 和 Store-Conditional (SC) 对中，Load-Linked (LL) 读取一个共享内存位置并在其上设置一个预留，而 Store-Conditional (SC) 尝试向同一位置写入一个新值，但仅当预留仍然有效且在此期间没有发生冲突写入时才会成功。在这种架构上，在 Load-Linked (LL) 和 Store-Conditional (SC) 之间，执行核心上发生的任何中断都会清除该预留，导致 Store-Conditional (SC) 失败。其他核心上的中断不会直接清除执行核心的预留，但其他核心对目标位置的写入会使预留失效或以其他方式导致 Store-Conditional (SC) 失败。操作系统可以将中断传递给任何核心；相应的中断处理程序可能会对共享状态进行写入。\n\n核心 $C_0$ 上的单个线程尝试使用一个循环来更新共享变量 $X$，该循环对 $X$ 执行 Load-Linked (LL)，计算一个新值，然后在持续时间为 $w$ 个时间单位的固定窗口后执行 Store-Conditional (SC)。假设在持续时间为 $w$ 的窗口期间，干扰的随机模型如下：\n- 核心 $C_0$ 上的中断作为泊松过程到达，速率为每个单位时间 $\\lambda$，且与其他事件无关。\n- 有 $M$ 个其他核心，每个核心根据速率为每个单位时间 $\\mu$ 的泊松过程独立地生成对 $X$ 的冲突写入，且与核心 $C_0$ 上的中断无关，并且在核心之间也相互独立。\n\n从 Load-Linked (LL)/Store-Conditional (SC) 语义的核心定义以及标准的非阻塞进度属性——即无锁（lock-free，系统级进度：在有限步数内，某个线程完成）和无等待（wait-free，每线程进度：在有限步数内，每个线程不论其他线程如何都将完成）——出发，推断中断和并发写入者如何影响 Store-Conditional (SC) 的成功概率以及算法的进度保证。评估在核心 $C_0$ 上本地禁用中断以及重试退避策略的作用。\n\n根据所述模型和定义，选择所有正确的陈述。\n\nA. 在上述独立性假设下，单次 Store-Conditional (SC) 尝试成功的概率是 $e^{-(\\lambda + M\\mu) w}$。如果在持续时间为 $w$ 的窗口期间仅在核心 $C_0$ 上禁用本地中断，则成功概率变为 $e^{-M\\mu w}$。以这种有界的方式禁用本地中断并不会使算法变为无等待的。\n\nB. 因为 Load-Linked (LL)/Store-Conditional (SC) 是一种旨在确保前向进度的硬件原语，中断不会导致饥饿，并且无论中断率 $\\lambda$如何，该算法都保持无等待。\n\nC. 为避免因中断导致的 Store-Conditional (SC) 失败，必须在所有核心上全局禁用中断；仅在执行核心 $C_0$ 上禁用中断是不够的，因为其他核心上的中断仍会清除 $C_0$ 上的预留。\n\nD. 在重试之间引入指数退避，通过限制重试次数，将使用 Load-Linked (LL)/Store-Conditional (SC) 的无锁算法转换为无等待算法。\n\nE. 即使在核心 $C_0$ 的 Load-Linked (LL) 和 Store-Conditional (SC) 之间禁用了本地中断，如果另一个核心在持续时间为 $w$ 的窗口内写入 $X$（例如，由于在另一个核心上运行的中断处理程序更新了 $X$），Store-Conditional (SC) 仍然可能失败，因为缓存一致性协议会使预留失效或以其他方式导致 Store-Conditional (SC) 失败。",
            "solution": "### 步骤 1：提取已知条件\n- 一个系统拥有多个处理器核心，其操作系统使用非阻塞同步。\n- 同步原语是 Load-Linked (LL) 和 Store-Conditional (SC)。\n- `LL`：读取一个共享内存位置并在其上设置一个预留。\n- `SC`：尝试向同一位置写入；仅当预留仍然有效时才成功。\n- 在 LL 和 SC 之间，执行核心上的中断会清除预留，导致 SC 失败。\n- 其他核心上的中断不会直接清除执行核心的预留。\n- 其他核心对目标位置的写入会使预留失效或导致 SC 失败。\n- 中断处理程序可能会对共享状态进行写入。\n- 核心 $C_0$ 上的一个线程在一个循环中尝试更新共享变量 $X$。\n- 该循环包括对 $X$ 执行 LL、计算以及对 $X$ 执行 SC。\n- LL 和 SC 之间的时间窗口具有固定持续时间 $w$。\n- 核心 $C_0$ 上的中断作为泊松过程到达，速率为每个单位时间 $\\lambda$。\n- 有 $M$ 个其他核心。\n- 这 $M$ 个其他核心中的每一个都根据速率为每个单位时间 $\\mu$ 的泊松过程独立地生成对 $X$ 的冲突写入。\n- 所有随机过程都是独立的。\n- 无锁（lock-free）的定义：在有限步数内，某个线程完成其操作（系统级进度）。\n- 无等待（wait-free）的定义：在有限步数内，每个线程完成其操作（每线程进度）。\n\n### 步骤 2：使用提取的已知条件进行验证\n问题陈述在计算机体系结构和操作系统领域具有科学依据。Load-Linked/Store-Conditional (LL/SC)、缓存一致性、非阻塞同步以及进度条件（无锁、无等待）等概念都是标准主题。使用泊松过程的随机模型是在性能分析中对中断和竞争等异步事件进行建模的一种常见且有效的方法。问题提取得当，提供了一个清晰的模型，并要求基于该模型评估陈述。语言客观而精确。问题是自包含的，不包含内部矛盾。例如，它正确地区分了另一个核心上的中断事件（不使预留失效）和由该核心执行的写入操作（会使预留失效）。\n\n### 步骤 3：结论与行动\n问题是有效的。现在开始解题过程。\n\n### 推导与选项分析\n\n问题的核心是确定单次 Store-Conditional (SC) 操作的成功概率，并对更新循环的进度保证（无锁 vs. 无等待）进行推理。\n\n核心 $C_0$ 上的 SC 操作当且仅当在持续时间为 $w$ 的窗口内没有发生任何使前一个 LL 设置的预留失效的事件时才会成功。问题指明了两种类型的失效事件：\n1.  执行核心 $C_0$ 上的中断。这些事件遵循速率为 $\\lambda$ 的泊松过程。\n2.  来自其他 $M$ 个核心之一的对共享变量 $X$ 的冲突写入。这 $M$ 个核心中的每一个都作为速率为 $\\mu$ 的独立泊松过程生成此类写入。\n\n对于速率为 $r$ 的泊松过程，在时间间隔 $t$ 内发生零个事件的概率由 $P(k=0) = e^{-rt}$ 给出。\n\n来自其他 $M$ 个核心的冲突写入过程是 $M$ 个独立的泊松过程的叠加，每个过程的速率为 $\\mu$。叠加后得到的是一个单一的泊松过程，其速率等于各个速率之和，即 $M\\mu$。\n\n设 $E_{int}$ 为在窗口 $w$ 期间 $C_0$ 上至少发生一次中断的事件。设 $E_{write}$ 为在窗口 $w$ 期间任何其他 $M$ 个核心中至少发生一次冲突写入的事件。如果这两个事件都没有发生，SC 就会成功。由于底层的泊松过程是独立的，这些事件也是独立的。\n\n成功概率 $P(\\text{success})$ 为：\n$$ P(\\text{success}) = P(\\text{在 } w \\text{ 期间 } C_0 \\text{ 上没有中断}) \\times P(\\text{在 } w \\text{ 期间其他核心没有冲突写入}) $$\n$$ P(\\text{在 } w \\text{ 期间 } C_0 \\text{ 上没有中断}) = e^{-\\lambda w} $$\n$$ P(\\text{在 } w \\text{ 期间其他核心没有冲突写入}) = e^{-(M\\mu) w} $$\n因此，单次 SC 尝试成功的概率是：\n$$ P(\\text{success}) = e^{-\\lambda w} \\cdot e^{-M\\mu w} = e^{-(\\lambda + M\\mu)w} $$\n\n现在，我们逐一评估每个选项。\n\n**A. 在上述独立性假设下，单次 Store-Conditional (SC) 尝试成功的概率是 $e^{-(\\lambda + M\\mu) w}$。如果在持续时间为 $w$ 的窗口期间仅在核心 $C_0$ 上禁用本地中断，则成功概率变为 $e^{-M\\mu w}$。以这种有界的方式禁用本地中断并不会使算法变为无等待的。**\n\n- **第 1 部分：成功概率。** 如上所述，两个独立的失败来源（本地中断和远程写入）的组合有效速率为 $\\lambda + M\\mu$。在窗口 $w$ 内此类事件发生零次的概率确实是 $e^{-(\\lambda + M\\mu)w}$。这部分是正确的。\n- **第 2 部分：禁用本地中断。** 如果在窗口 $w$ 期间禁用核心 $C_0$ 上的本地中断，则 $C_0$ 上由中断引起的失败率为 $\\lambda = 0$。唯一剩下的失败来源是来自其他 $M$ 个核心的冲突写入，其总速率为 $M\\mu$。成功概率变为 $e^{-(0 + M\\mu)w} = e^{-M\\mu w}$。这部分是正确的。\n- **第 3 部分：无等待保证。** 如果每个线程都保证在有限的自身步骤内完成其操作，则算法是无等待的。即使禁用了本地中断，SC 仍然可能由于其他核心的冲突写入而失败（只要 $M\\mu  0$）。核心 $C_0$ 上的线程可能因竞争而经历的连续失败次数没有上限。理论上，来自其他核心的连续写入流可能会无限期地使核心 $C_0$ 上的线程饥饿。因此，该算法是无锁的（只要 $P(\\text{success})  0$，整个系统就可以取得进展），但不是无等待的。禁用本地中断消除了一个导致无限重试的来源，但没有消除另一个。这部分是正确的。\n\n由于陈述的三个部分都正确，所以整个陈述是正确的。\n**结论：正确**\n\n**B. 因为 Load-Linked (LL)/Store-Conditional (SC) 是一种旨在确保前向进度的硬件原语，中断不会导致饥饿，并且无论中断率 $\\lambda$如何，该算法都保持无等待。**\n\n- 前提“LL/SC 是一种旨在确保前向进度的硬件原语”是一种模糊的过度简化。LL/SC 使得构建非阻塞算法成为可能，这些算法提供进度保证。使用简单的 LL/SC 循环最常实现的保证是无锁，而不是无等待。\n- “中断不会导致饥饿”：这是错误的。问题明确指出，执行核心上的中断会导致 SC 失败。如果中断以足够高的频率到达（例如，如果 $\\lambda$ 非常大，以至于 $\\lambda w \\gg 1$），成功概率 $e^{-(\\lambda+M\\mu)w}$ 会趋近于 0。该线程可能会无限期地失败其 SC 尝试，这是一种饥饿或活锁。\n- “该算法保持无等待”：这是错误的。如选项 A 的解释，一个 LL/SC 循环会受到其他线程的竞争影响。这可能导致单个线程进行无限次数的重试，意味着算法不是无等待的。中断的存在（$\\lambda  0$）增加了另一个失败的原因，使其更不可能是无等待的。\n**结论：不正确**\n\n**C. 为避免因中断导致的 Store-Conditional (SC) 失败，必须在所有核心上全局禁用中断；仅在执行核心 $C_0$ 上禁用中断是不够的，因为其他核心上的中断仍会清除 $C_0$ 上的预留。**\n\n- 此选项中提供的理由是“因为其他核心上的中断仍会清除 $C_0$ 上的预留”。\n- 问题陈述明确反驳了这一点：“其他核心上的中断不会直接清除执行核心的预留”。\n- 可能发生的情况是，另一个核心（比如 $C_i$）上的中断可以触发 $C_i$ 上的中断处理程序，该处理程序对共享变量 $X$ 执行写入。然后，这个*写入*操作通过缓存一致性协议使 $C_0$ 上的预留失效。失效的原因是写入，而不是远程中断事件本身。\n- 该陈述的推理是有缺陷的，因为它错误地识别了预留丢失的直接原因。因此，该陈述基于一个相对于问题定义而言不正确的前提。\n**结论：不正确**\n\n**D. 在重试之间引入指数退避，通过限制重试次数，将使用 Load-Linked (LL)/Store-Conditional (SC) 的无锁算法转换为无等待算法。**\n\n- 指数退避是一种竞争管理策略。当 SC 失败时，线程在重试前会等待一个随机的时间间隔。该间隔的平均值随着每次连续失败而增加（通常是指数级增加）。\n- 该策略通过分散访问尝试来降低重复冲突的概率，从而提高整体吞吐量和公平性。\n- 然而，它并没有为重试次数提供一个硬性上限。一个线程仍然可能运气不好，即使有退避机制，也可能经历一长串的失败。这是一种概率上的改进，而不是一个确定性的保证。\n- 将无锁算法转换为无等待算法需要确保每个线程在有限步数内完成其操作，而不管其他线程的行为如何。这通常涉及更复杂的技术，如“帮助”（helping），即较快的线程代表较慢或延迟的线程完成操作。仅靠指数退避无法实现这一点。\n**结论：不正确**\n\n**E. 即使在核心 $C_0$ 的 Load-Linked (LL) 和 Store-Conditional (SC) 之间禁用了本地中断，如果另一个核心在持续时间为 $w$ 的窗口内写入 $X$（例如，由于在另一个核心上运行的中断处理程序更新了 $X$），Store-Conditional (SC) 仍然可能失败，因为缓存一致性协议会使预留失效或以其他方式导致 Store-Conditional (SC) 失败。**\n\n- 该陈述描述了核心 $C_0$ 上的本地中断失败源被移除的场景。\n- 它正确地指出，另一个失败源——来自另一个核心的冲突写入——仍然存在。\n- 给出的例子，“由于在另一个核心上运行的中断处理程序更新了 $X$”，与问题陈述完全一致：“相应的中断处理程序可能会对共享状态进行写入。”\n- 陈述的最后一部分，“因为缓存一致性协议会使预留失效或以其他方式导致 Store-Conditional (SC) 失败”，提供了关于远程写入如何使 LL/SC 序列失效的正确、标准的硬件机制。当一个核心向一个缓存行写入时，系统的缓存一致性协议确保任何其他在该行上有预留（或只读副本）的核心其状态被更新或失效。这个事件被用来打破 LL/SC 预留。\n- 该陈述是对问题中定义的系统行为的完整而准确的描述。\n**结论：正确**",
            "answer": "$$\\boxed{AE}$$"
        },
        {
            "introduction": "理论最终要通过实践来检验。这项综合性编程练习将引导你从分析转向综合，亲手实现一个基于事务的内存分配器模拟程序。你将直面真实世界中的挑战：如何仅使用原子原语来保证操作的原子性、处理不可撤销操作，以及在多线程环境下维护全局数据的一致性，从而将非阻塞并发和事务内存的抽象概念转化为具体、可运行的代码。 ",
            "id": "3663912",
            "problem": "你需要设计并实现一个非阻塞、事务性的、每线程的内存分配器模拟器，该模拟器在所有线程间强制执行一致的全局记账，并正确处理不可撤销的释放操作。你生成的程序必须是一个完整的、可运行的程序，并按下方描述的精确格式输出单行结果。\n\n基本和核心定义：\n- 使用比较并交换（CAS）的原子读-修改-写是一种被广泛接受的原语，它能提供无需锁的可线性化更新。通过一个可以进行递增和比较交换的原子整数来对此进行建模。\n- 在事务内存模型中，一个线程执行一个事务，该事务会累积一个写集增量（在此为净内存变化），并原子地提交。设全局总分配字节数为 $G$，每线程的本地分配字节数为 $L_i$，每事务的净变化为 $\\Delta_i$。一次正确的提交必须保持 $G_{\\text{final}} = G_{\\text{initial}} + \\sum \\Delta_i^{\\text{committed}}$ 和 $G_{\\text{final}} = \\sum L_i^{\\text{final}}$。\n- 非阻塞进展意味着没有线程持有锁；进展是通过原子操作和中止/重试来实现的。一个不可撤销操作是指无法被安全回滚的操作。一个不可撤销的 $free()$ 调用必须全局串行化以保持正确性；在同一时刻只允许一个线程执行它。\n\n行为规范：\n- 每个线程 $i$ 开始时拥有一个已知的本地分配量 $L_i$（以字节为单位）。全局总量 $G$ 开始时与 $G = \\sum L_i$ 保持一致。\n- 每个线程执行一个包含三种有序操作序列的事务：\n  1. 分配（Allocate）：将本地增量增加一个非负整数值 $a$，即 $\\Delta \\leftarrow \\Delta + a$。\n  2. 释放（Free）：将本地增量减少一个非负整数值 $f$，即 $\\Delta \\leftarrow \\Delta - f$。\n  3. 不可撤销的释放（Irrevocable free）：一个在效果上与释放相同的操作，但必须全局串行化。一个线程在其事务中最多只能执行一次不可撤销的释放。在同一时刻，只有一个线程可以持有不可撤销权，该权利通过一个全局所有者变量建模，并使用 CAS 获取。如果请求线程无法获得不可撤销权，其事务必须立即中止，不执行任何全局或本地更改。\n- 如果事务在提交时会导致本地分配量变为负数，则该事务也必须中止。形式上，只有当 $L_i + \\Delta \\ge 0$ 时，才允许提交。\n- 成功提交时，将 $\\Delta$ 原子地应用于 $G$ 并更新 $L_i \\leftarrow L_i + \\Delta$，如果持有不可撤销所有权，则释放它。中止时，保持 $G$ 和 $L_i$ 不变，并释放任何已获得的不可撤销所有权。\n\n不可撤销释放的确定性决胜机制：\n- 为避免本次练习中的不确定性和活锁，使用一个单一的全局决胜标识符来确定下一个允许获取不可撤销权的线程ID。只有其ID与该决胜标识符相等的线程在尝试进行不可撤销释放时才能获取该权利；其他尝试进行不可撤销释放的线程必须立即中止。如果决胜标识符设置为 $-1$，则所有线程都可以尝试获取，但在本问题的测试套件中，只要有多个线程并发执行不可撤销释放操作，决胜标识符就会被设置为一个特定的线程ID。\n\n你的程序必须：\n- 仅使用原子操作（无锁），通过线程实现并发，来模拟上述事务性每线程分配器的语义。你必须使用整数字节，所有记账均以字节为单位。\n- 生成一行输出，其中包含所提供测试套件的聚合结果，并严格遵循指定的格式。\n\n需要实现的测试套件：\n- 测试用例 1（顺利路径，无不可撤销操作）：\n  - 线程数：$2$；决胜标识符 $=-1$。\n  - 初始本地量：$L_0 = 0$，$L_1 = 0$；设置 $G = 0$。\n  - 操作：\n    - 线程 0：分配 100，分配 50，释放 70。\n    - 线程 1：分配 30，释放 10，分配 5。\n  - 预期属性：两个事务都提交；最终记账必须一致。\n- 测试用例 2（不可撤销释放的串行化）：\n  - 线程数：$3$；决胜标识符 $=0$。\n  - 初始本地量：$L_0 = 200$，$L_1 = 150$，$L_2 = 0$；设置 $G = 350$。\n  - 操作：\n    - 线程 0：不可撤销的释放 200。\n    - 线程 1：不可撤销的释放 150。\n    - 线程 2：分配 60。\n  - 预期属性：线程 0 提交其不可撤销释放；线程 1 因决胜标识符而中止其不可撤销释放的尝试；线程 2 提交；最终记账必须一致。\n- 测试用例 3（净增量为零，提交成功）：\n  - 线程数：$1$；决胜标识符 $=-1$。\n  - 初始本地量：$L_0 = 100$；设置 $G = 100$。\n  - 操作：\n    - 线程 0：分配 100，释放 100。\n  - 预期属性：以 $\\Delta = 0$ 成功提交；最终记账必须一致。\n- 测试用例 4（因本地量为负而安全中止）：\n  - 线程数：$1$；决胜标识符 $=-1$。\n  - 初始本地量：$L_0 = 50$；设置 $G = 50$。\n  - 操作：\n    - 线程 0：释放 60。\n  - 预期属性：事务中止，因为 $L_0 + \\Delta = 50 - 60 = -10$ 将为负数；最终记账必须一致。\n\n要求的输出格式：\n- 对于每个测试用例 $i$，计算最终的全局总字节数 $G_i$（一个整数），已提交事务的数量 $C_i$（一个整数），已中止事务的数量 $A_i$（一个整数），以及一个一致性指示符 $B_i$（一个布尔值，真为 $1$，假为 $0$），表示 $G_i = \\sum L_j^{\\text{final}}$ 是否成立。\n- 你的程序应生成一行输出，其中包含一个方括号括起来的逗号分隔列表，结果严格按照此顺序排列：$[G_1,C_1,A_1,B_1,G_2,C_2,A_2,B_2,G_3,C_3,A_3,B_3,G_4,C_4,A_4,B_4]$。\n\n所有答案均为整数。不允许用户输入；所有数据均按上述规定硬编码。",
            "solution": "该问题要求设计并实现一个用于非阻塞、事务性内存分配器的确定性模拟。解决方案遵循指定的行为规则，按要求使用原子操作进行并发控制。其核心是一个C程序，该程序模拟四个不同的测试用例，每个用例都涉及多个线程执行事务，然后将结果聚合成一个单行格式化输出。\n\n逻辑设计基于以下原则：\n\n1.  **状态表示**：系统状态被划分为共享的全局状态和每线程的本地状态。\n    -   全局总分配字节数 $G$ 由一个 `_Atomic long` 变量表示。这确保了来自并发提交事务的更新能够被正确串行化并应用，而不会产生数据竞争。\n    -   不可撤销释放操作的所有权由一个单一的全局 `_Atomic int` 变量 `irrevocable_owner` 管理。值为 $-1$ 表示该权利未被拥有。ID为 $i$ 的线程通过成功执行比较并交换（CAS）操作，将该值从 $-1$ 更改为 $i$ 来获取此权利。\n    -   每线程的本地分配量 $L_i$ 存储在一个标准的 `long` 数组中。由于每个线程 $i$ 只修改自己的元素 $L_i$（且仅在成功提交时），因此无需对该数组进行直接的原子操作。主线程仅在所有工作线程终止后才访问此数组进行验证，从而避免了竞争条件。\n    -   每个测试用例的聚合统计数据——已提交事务数 $C_i$ 和已中止事务数 $A_i$——也建模为 `_Atomic int` 计数器，以便进行安全的并发递增。\n\n2.  **事务执行模型**：每个线程的执行被建模为一个单一的、要么全做要么全不做的事务。一个专用的线程函数实现了这一逻辑。\n    -   **累积阶段**：线程首先处理其分配的操作序列（`allocate`、`free`、`irrevocable free`）。它在一个私有的局部变量中计算分配的净变化量 $\\Delta$。\n    -   **中止条件**：事务被设计为在特定条件下立即中止，从而在无锁的情况下确保前向进展和正确性。\n        -   **不可撤销释放失败**：尝试执行 `irrevocable free` 时，如果(a) `tie_breaker` 处于活动状态且线程ID不匹配，或(b) 线程因该权利已被持有而未能通过CAS获取全局不可撤销所有权，则会触发中止。\n        -   **安全性违规**：在提交之前，事务会验证提交是否会导致本地分配量变为负数。如果 $L_i + \\Delta  0$，事务必须中止。\n    -   **提交/中止逻辑**：\n        -   **提交时**：如果没有满足任何中止条件，事务将提交。计算出的 $\\Delta$ 通过 `atomic_fetch_add` 原子地加到全局总量 $G$ 上。线程的本地分配量被更新：$L_i \\leftarrow L_i + \\Delta$。如果线程已获得不可撤销权，它通过原子地将 `irrevocable_owner` 设置回 $-1$ 来释放它。最后，全局提交计数器 $C_i$ 被原子地递增。\n        -   **中止时**：全局状态 $G$ 和本地状态 $L_i$ 保持不变。如果线程在事务尝试期间获得了不可撤销权，它必须释放该权利以防止死锁。全局中止计数器 $A_i$ 被原子地递增。\n\n3.  **并发性与确定性**：该模拟利用C语言的 `threads.h` 库来创建和管理线程，从而模拟指定的并发环境。然而，问题的严格规则，包括每个线程固定的操作序列和用于不可撤销操作的确定性决胜机制，消除了运行时的不确定性。这确保了模拟对每个测试用例都产生单一、可预测且可验证的结果。\n\n4.  **验证**：在给定测试用例的所有线程完成执行并被联接（joined）后，主线程执行最终的一致性检查。它计算所有最终的每线程本地分配量之和 $\\sum L_j^{\\text{final}}$，并将其与最终的全局分配总量 $G_i$ 进行比较。此检查的结果被存储为一个布尔指示符 $B_i$，如果模拟正确，该值必须为真（$1$）。这验证了基本不变量 $G = \\sum L_j$。\n\n该实现系统地将这些原则应用于所有四个测试用例。定义了一个 `TestCase` 数据结构来保存每个线程的初始参数（$L_i$ 值、决胜标识符）和操作列表。主程序遍历这些测试用例，设置初始状态，运行并发模拟，并收集最终结果（$G_i, C_i, A_i, B_i$）。最后，它以精确指定的逗号分隔格式打印所有收集到的结果。",
            "answer": "[105,2,0,1,210,2,1,1,100,1,0,1,50,0,1,1]"
        }
    ]
}