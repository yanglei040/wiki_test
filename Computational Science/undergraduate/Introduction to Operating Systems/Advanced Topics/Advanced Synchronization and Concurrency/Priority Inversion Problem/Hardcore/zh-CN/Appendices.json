{
    "hands_on_practices": [
        {
            "introduction": "这个练习将引导你分析最经典的优先级反转场景。通过从基本定义出发，你将推导出一个高优先级任务因中等优先级任务的抢占而必须等待的总延迟。这个计算练习旨在巩固你对固定优先级抢占式调度和上下文切换开销如何共同导致非预期的、潜在无界的延迟的理解 。",
            "id": "3671212",
            "problem": "一个单处理器调度器使用固定优先级抢占式调度，并对处于相同优先级的任务采用轮询时间分片。中央处理器（CPU）每次分派一个就绪任务运行时，会产生一个持续时间为 $\\delta$ 的恒定上下文切换开销。一个高优先级任务 $H$ 试图获取一个当前由低优先级任务 $L$ 持有的互斥锁。系统中没有优先级继承机制：任务 $L$ 保持其低优先级。在 $H$ 因互斥锁而阻塞的瞬间，恰好有 $m$ 个中等优先级的任务 $\\{M_{1}, M_{2}, \\ldots, M_{m}\\}$ 处于就绪状态。每个中等优先级的任务被调度时，会运行恰好一个持续时间为 $q$ 的时间量，然后因输入/输出而阻塞，阻塞时间足够长，以至于在此事件期间不会再次变为就绪状态。在此事件期间没有其他任务到达。将此次实验运行中的反转延迟 $D_{\\text{inv}}$ 定义为从 $H$ 因互斥锁而阻塞开始，到最后一个中等优先级任务完成其一个时间量并阻塞时（即，在调度器下一次要运行 $L$ 之前）所经过的时间。对于这个实验设计，你将在不同的运行中改变 $q$、$\\delta$ 和 $m$ 的值。\n\n仅使用固定优先级抢占式调度、时间量和上下文切换开销的核心定义，推导在所述情境下一次运行中 $D_{\\text{inv}}$ 作为 $q$、$\\delta$ 和 $m$ 的函数的解析表达式。然后，使用具体参数值 $q = 3.7$ 毫秒，$\\delta = 0.23$ 毫秒以及 $m = 19$ 来计算你的表达式。将你的数值答案四舍五入到四位有效数字。以毫秒为单位表示最终延迟。仅提供一个数字作为你的最终结果。",
            "solution": "该问题提出了一个涉及单处理器系统上任务调度的场景，并要求推导和计算一个称为“反转延迟”的特定指标。\n\n### 步骤1：问题验证\n\n首先，对问题陈述进行严格的验证。\n\n**提取已知条件：**\n- **调度策略：** 固定优先级抢占式调度。对于相同优先级的任务，使用轮询时间分片。\n- **系统：** 单处理器。\n- **上下文切换开销：** 每次分派一个就绪任务时，会产生一个持续时间为 $\\delta$ 的恒定开销。\n- **任务集和状态：**\n    - 一个高优先级任务, $H$。\n    - 一个低优先级任务, $L$，它持有一个互斥锁。\n    - $m$ 个中等优先级的任务, $\\{M_{1}, M_{2}, \\ldots, M_{m}\\}$。\n    - 初始状态始于任务 $H$ 试图获取 $L$ 持有的互斥锁并阻塞的瞬间。在同一瞬间，所有 $m$ 个中等优先级的任务都处于就绪状态。\n- **任务行为：**\n    - 每个中等优先级任务 $M_i$ 被调度时，会运行恰好一个持续时间为 $q$ 的时间量。\n    - 在运行完其时间量后，每个 $M_i$ 会因输入/输出操作而阻塞，并且在关注的时间段内不会再次变为就绪状态。\n- **优先级继承：** 明确说明未实现。任务 $L$ 保持其低优先级。\n- **反转延迟 $D_{\\text{inv}}$ 的定义：** 从 $H$ 因互斥锁而阻塞的时刻起，直到最后一个中等优先级任务完成其时间量并阻塞的时刻所经过的时间。\n- **用于计算的参数：** $q = 3.7$ 毫秒, $\\delta = 0.23$ 毫秒, 以及 $m = 19$。\n\n**依据标准进行验证：**\n- **科学依据：** 该问题牢固地植根于操作系统的基本原理，特别是任务调度、并发控制（互斥锁）以及有充分文献记载的优先级反转现象。所有使用的术语（$q$、$\\delta$、抢占、优先级）都是该领域的标准术语。该场景是用于说明调度行为的经典示例。\n- **适定性：** 该问题是适定的。初始条件被精确指定，所有相关任务的行为是确定性的，待计算量 $D_{\\text{inv}}$ 的起止点定义清晰。这种结构确保可以推导出唯一且有意义的解。\n- **客观性：** 语言正式、精确，没有任何主观或模棱两可的术语。\n\n**结论：** 问题陈述有效，它科学合理、适定、客观且内部一致。我将继续推导解决方案。\n\n### 步骤2：解析表达式的推导\n\n问题要求计算高优先级任务 $H$ 经历的反转延迟 $D_{\\text{inv}}$。这个延迟是由 $m$ 个中等优先级任务的执行引起的，这些任务抢占了持有 $H$ 所需互斥锁的低优先级任务 $L$。\n\n让我们将时间测量的起点 $t=0$ 定义为任务 $H$ 因互斥锁而阻塞的瞬间。\n在 $t=0$ 时，就绪任务集包括低优先级任务 $L$ 和 $m$ 个中等优先级任务 $\\{M_1, M_2, \\ldots, M_m\\}$。任务 $H$ 此时处于阻塞状态。\n\n根据固定优先级抢占式调度策略，调度器必须始终从最高优先级的非空队列中运行一个就绪任务。由于中等优先级任务的优先级高于任务 $L$，调度器将忽略 $L$，转而执行中等优先级任务。\n\n$m$ 个中等优先级任务都处于相同的优先级水平，并使用轮询策略进行调度。这意味着它们将按顺序执行。由于它们的行为完全相同，具体的执行顺序（$M_1, M_2, \\ldots$ 或任何其他排列）不影响总耗时。我们假设它们按其索引顺序进行调度。\n\n1.  **任务 $M_1$ 的执行**：调度器选择 $M_1$ 运行。在 $M_1$ 可以执行之前，系统必须执行一次上下文切换来分派它。这会产生一个 $\\delta$ 的开销。上下文切换后，$M_1$ 运行其规定的时间量 $q$。系统处理 $M_1$ 所消耗的总时间是上下文切换时间和执行时间之和：$t_1 = \\delta + q$。完成其时间量后，$M_1$ 阻塞并从就绪队列中移除。\n\n2.  **任务 $M_2$ 的执行**：在 $M_1$ 阻塞后，调度器再次被调用。此时最高优先级的就绪任务是 $\\{M_2, \\ldots, M_m\\}$。调度器选择 $M_2$。同样，需要一次持续时间为 $\\delta$ 的上下文切换，然后执行一个时间量 $q$。此步骤所耗费的时间为 $t_2 = \\delta + q$。\n\n这个过程对所有 $m$ 个中等优先级任务重复。集合中的每个任务 $M_i$ 在阻塞前都需要一次 $\\delta$ 的上下文切换，并运行一个时间量 $q$。因此，每个任务 $M_i$ 的时间贡献是 $(\\delta + q)$。\n\n总反转延迟 $D_{\\text{inv}}$ 定义为直到最后一个中等优先级任务 $M_m$ 完成其时间量并阻塞为止的时间。这是所有 $m$ 个中等优先级任务的时间贡献之和。\n\n$$D_{\\text{inv}} = \\sum_{i=1}^{m} (\\text{context switch for } M_i + \\text{run time of } M_i)$$\n$$D_{\\text{inv}} = \\sum_{i=1}^{m} (\\delta + q)$$\n\n由于 $\\delta$ 和 $q$ 对于所有 $m$ 个任务都是常数，求和可以简化为：\n$$D_{\\text{inv}} = m(q + \\delta)$$\n这就是反转延迟作为 $m$、$q$ 和 $\\delta$ 的函数的解析表达式。\n\n### 步骤3：数值计算\n\n问题为参数提供了以下具体值：\n- $q = 3.7$ 毫秒\n- $\\delta = 0.23$ 毫秒\n- $m = 19$\n\n将这些值代入推导出的表达式：\n$$D_{\\text{inv}} = 19 \\times (3.7 + 0.23)$$\n首先，计算括号内的和：\n$$q + \\delta = 3.7 + 0.23 = 3.93 \\text{ ms}$$\n现在，乘以中等优先级任务的数量 $m$：\n$$D_{\\text{inv}} = 19 \\times 3.93$$\n$$D_{\\text{inv}} = 74.67 \\text{ ms}$$\n\n问题要求将数值答案四舍五入到四位有效数字。计算出的值 $74.67$ 已经恰好包含四位有效数字（$7$、$4$、$6$ 和 $7$）。因此，不需要进一步的四舍五入。反转延迟的最终数值结果是 $74.67$ 毫秒。",
            "answer": "$$\\boxed{74.67}$$"
        },
        {
            "introduction": "优先级反转的影响超出了纯粹的调度层面，它还可能由硬件资源的争用引起。这个练习探讨了一种更微妙但同样关键的延迟来源：缓存颠簸 (cache thrashing)。你将量化当中等优先级任务污染共享缓存，从而增加低优先级任务执行时间时，对高优先级任务造成的额外阻塞时间 。这项实践揭示了在现代计算机体系结构中，理解软件与硬件交互对于准确分析系统性能至关重要。",
            "id": "3671221",
            "problem": "考虑一个单核系统，该系统采用固定优先级抢占式调度，并有三个线程：一个高优先级线程 $T_{H}$，一个中优先级线程 $T_{M}$，以及一个低优先级线程 $T_{L}$。低优先级线程 $T_{L}$ 持有一个互斥锁（mutex），而高优先级线程 $T_{H}$ 需要该锁才能进入其临界区。系统中没有优先级继承机制。在 $T_{L}$ 持有锁期间，只要 $T_{M}$ 是可运行的，调度器就允许 $T_{M}$ 抢占 $T_{L}$，每次抢占的固定时间片长度为 $\\Delta$。中央处理器（CPU）的频率为 $f$ 周期/秒。\n\n假设采用以下工作集和缓存交互模型。每次 $T_{M}$ 运行时，它会访问 $e$ 个缓存行，这些缓存行与 $T_{L}$ 临界区当前相关的缓存行映射到相同的缓存组，从而将后者从共享缓存中逐出。当 $T_{L}$ 在每次被抢占后恢复执行时，它需要重新加载这 $e$ 个缓存行，每行导致一次额外的缓存未命中，每次未命中的惩罚为 $p$ 个周期。这个模式会重复 $k$ 次抢占，直到 $T_{L}$ 最终释放该锁。\n\n参数：\n- CPU 频率 $f = 2.5 \\times 10^{9}$ 周期/秒。\n- 未命中惩罚 $p = 200$ 周期/次未命中。\n- 每次抢占逐出的缓存行数 $e = 128$。\n- 抢占次数 $k = 75$。\n- 每次抢占的中优先级时间片 $\\Delta = 1$ 毫秒。\n\n从以下定义出发：由周期成本产生的时间等于周期数除以每秒周期数；优先级反转是高优先级线程因低优先级线程持有锁以及中优先级活动的干扰而产生的额外等待时间。请从第一性原理推导：\n\n1. $T_{L}$ 仅因 $T_{M}$ 的逐出操作导致的额外缓存未命中而经历的附加延迟 $M$（以毫秒为单位表示 $M$）。\n2. 导致的优先级反转 $D$。它是在没有 $T_{M}$ 的基线情况之外，施加给 $T_{H}$ 的额外等待时间，其值等于 $T_{L}$ 持有锁期间 $T_{M}$ 的调度运行时间与缓存未命中引起的延迟 $M$ 之和（以毫秒为单位表示 $D$）。\n\n提供精确值，无需四舍五入。请以毫秒为单位表示您的最终答案。",
            "solution": "我们从两个核心事实出发：\n- 以周期为单位的时间成本可以通过除以CPU频率转换为秒。因此，如果一个计算产生了 $C$ 个周期，那么所需的时间（秒）就是 $C/f$。\n- 在这种没有优先级继承的情况下，优先级反转是指高优先级线程 $T_{H}$ 因低优先级线程 $T_{L}$ 持有锁，同时中优先级线程 $T_{M}$ 抢占 $T_{L}$ 并通过缓存颠簸（cache thrashing）降低 $T_{L}$ 的执行进度而承受的额外等待时间。\n\n定义仅由缓存颠簸引起的附加延迟 $M$。每次 $T_{M}$ 的抢占会逐出 $e$ 个与 $T_{L}$ 相关的缓存行。根据所述模型，当 $T_{L}$ 在一次抢占后恢复执行时，它将重新加载这 $e$ 个缓存行，每行产生一次额外的未命中。设每次未命中的惩罚为 $p$ 个周期。在 $k$ 次抢占中，额外未命中的总次数为 $k \\cdot e$，产生的额外总周期数为\n$$\nC_{\\text{miss}} = k \\cdot e \\cdot p.\n$$\n使用CPU频率 $f$ 将周期转换为秒，得到\n$$\nt_{\\text{miss}} = \\frac{C_{\\text{miss}}}{f} = \\frac{k \\cdot e \\cdot p}{f}.\n$$\n为了以毫秒表示，需乘以 $10^{3}$：\n$$\nM = 10^{3} \\cdot \\frac{k \\cdot e \\cdot p}{f} \\quad \\text{milliseconds}.\n$$\n代入给定值 $k = 75$，$e = 128$，$p = 200$ 和 $f = 2.5 \\times 10^{9}$：\n首先计算周期数：\n$$\nC_{\\text{miss}} = 75 \\cdot 128 \\cdot 200 = 75 \\cdot 25{,}600 = 1{,}920{,}000 \\ \\text{cycles}.\n$$\n转换为秒：\n$$\nt_{\\text{miss}} = \\frac{1{,}920{,}000}{2.5 \\times 10^{9}} = 0.000768 \\ \\text{seconds}.\n$$\n转换为毫秒：\n$$\nM = 10^{3} \\cdot 0.000768 = 0.768 \\ \\text{milliseconds}.\n$$\n\n接下来，定义导致的优先级反转 $D$。在没有 $T_{M}$ 的情况下，$T_{H}$ 在 $T_{L}$ 持有锁期间的基线等待时间将不包括 $T_{M}$ 的CPU时间或缓存颠簸开销。当 $T_{M}$ 存在时，可归因于 $T_{M}$ 的额外等待时间是以下两项之和：\n- 在 $k$ 次抢占中 $T_{M}$ 的调度运行时间，总计为 $k \\cdot \\Delta$。\n- $T_{L}$ 因缓存未命中而经历的附加延迟 $M$，这直接延长了锁的持有时间，从而也延长了 $T_{H}$ 的等待时间。\n\n因此，\n$$\nD = k \\cdot \\Delta + M.\n$$\n使用 $k = 75$ 和 $\\Delta = 1 \\ \\text{毫秒}$ 可得\n$$\nk \\cdot \\Delta = 75 \\cdot 1 = 75 \\ \\text{milliseconds}.\n$$\n因此，\n$$\nD = 75 + 0.768 = 75.768 \\ \\text{milliseconds}.\n$$\n\n我们已经从第一性原理推导出了 $M$ 和 $D$：每次抢占的额外未命中会产生一个附加周期成本，通过频率 $f$ 转换为时间；总的优先级反转时间结合了调度器引起的延迟和缓存引起的延迟。两个值均按要求以毫秒表示。",
            "answer": "$$\\boxed{\\begin{pmatrix}0.768 & 75.768\\end{pmatrix}}$$"
        },
        {
            "introduction": "在实时系统中，优先级反转不仅仅是一个性能问题，更是一个正确性问题。这个练习将低层级的阻塞时间与高层级的系统目标——可调度性（schedulability）联系起来。你将运用一个基于利用率的充分条件，来确定一个任务集在考虑了优先级反转引起的阻塞效应后，是否仍然能够保证满足所有截止时间 。通过这个练习，你将学会如何将阻塞时间整合到正式的调度分析中，从而评估其对系统整体可靠性的影响。",
            "id": "3671272",
            "problem": "考虑在单处理器上调度的三个独立的、可抢占的、周期的实时任务，其优先级由速率单调（Rate Monotonic, RM）和截止时间单调（Deadline Monotonic, DM）两种策略分配。所有任务都是周期性的，并共享一个由互斥锁保护的资源，这可能导致优先级反转。这些任务是：\n- 任务 $\\tau_1$：周期 $T_1 = 10\\,\\mathrm{ms}$，最坏情况执行时间 $C_1 = 1\\,\\mathrm{ms}$，相对截止时间 $D_1 = T_1$。\n- 任务 $\\tau_2$：周期 $T_2 = 25\\,\\mathrm{ms}$，最坏情况执行时间 $C_2 = 2.5\\,\\mathrm{ms}$，相对截止时间 $D_2 = T_2$。\n- 任务 $\\tau_3$：周期 $T_3 = 50\\,\\mathrm{ms}$，最坏情况执行时间 $C_3 = 6\\,\\mathrm{ms}$，相对截止时间 $D_3 = T_3$。\n\n假设一个共享的临界区可能被一个低优先级任务持有，由于优先级反转，从而对一个高优先级任务产生最坏情况阻塞时间 $B$。仅使用以下基本事实：\n- 在固定优先级调度下，当所有截止时间等于周期时，$n$ 个任务可调度的充分利用率界限为 $U_{\\text{bound}}(n) = n\\big(2^{1/n} - 1\\big)$。\n- 总利用率为 $U = \\sum_{i=1}^{n} \\frac{C_i}{T_i}$。\n- 由于单个共享资源引起的优先级反转所造成的阻塞，可以通过在最小关注时间窗口上对最坏情况阻塞进行归一化，从而保守地纳入基于利用率的充分可调度性检查中。\n\n基于这些基础，推导最大阻塞时间 $B_{\\max}$，使得任务集在速率单调（RM）和截止时间单调（DM）调度下都能保证可调度，并以毫秒表示 $B_{\\max}$。将最终数值答案四舍五入到四位有效数字，并以 $\\mathrm{ms}$ 为单位表示最终结果。",
            "solution": "在进行求解之前，首先评估问题的有效性。\n\n### 步骤1：提取已知条件\n-   **任务**：在单处理器上的$3$个独立的、可抢占的、周期的实时任务（$\\tau_1$, $\\tau_2$, $\\tau_3$）。\n-   **调度**：固定优先级，优先级由速率单调（RM）和截止时间单调（DM）分配。\n-   **资源共享**：共享一个由互斥锁保护的资源，可能导致优先级反转。\n-   **任务参数**：\n    -   任务 $\\tau_1$：周期 $T_1 = 10\\,\\mathrm{ms}$，最坏情况执行时间 $C_1 = 1\\,\\mathrm{ms}$，相对截止时间 $D_1 = T_1$。\n    -   任务 $\\tau_2$：周期 $T_2 = 25\\,\\mathrm{ms}$，最坏情况执行时间 $C_2 = 2.5\\,\\mathrm{ms}$，相对截止时间 $D_2 = T_2$。\n    -   任务 $\\tau_3$：周期 $T_3 = 50\\,\\mathrm{ms}$，最坏情况执行时间 $C_3 = 6\\,\\mathrm{ms}$，相对截止时间 $D_3 = T_3$。\n-   **阻塞**：高优先级任务的最坏情况阻塞时间 $B$。\n-   **分析的基本事实**：\n    1.  $D_i = T_i$ 时，$n$ 个任务可调度的充分利用率界限：$U_{\\text{bound}}(n) = n\\big(2^{1/n} - 1\\big)$。\n    2.  总利用率：$U = \\sum_{i=1}^{n} \\frac{C_i}{T_i}$。\n    3.  阻塞合并规则：“阻塞……可以通过在最小关注时间窗口上对最坏情况阻塞进行归一化，从而保守地纳入基于利用率的充分可调度性检查中。”\n-   **目标**：找出最大阻塞时间 $B_{\\max}$（以毫秒为单位，四舍五入到四位有效数字），使得任务集在RM和DM下都能保证可调度。\n\n### 步骤2：使用提取的已知条件进行验证\n该问题在科学上基于实时系统调度理论的既定原则，特别是速率单调分析（Rate Monotonic Analysis, RMA）。\n-   **科学依据**：该问题使用了任务（$T_i, C_i, D_i$）、优先级反转以及经典的 Liu and Layland 可调度性利用率界限的标准定义。这些是操作系统和实时系统中的核心概念。所规定的合并阻塞的方法是基于利用率测试的一种已知的保守方法。该问题在科学上是合理的。\n-   **适定性**：该问题提供了所有必需的参数。它指明了截止时间等于周期（$D_i = T_i$）。在此条件下，速率单调（RM）调度（基于速率/周期的优先级）和截止时间单调（DM）调度（基于截止时间的优先级）是等价的。由于 $T_1  T_2  T_3$，两种方案的优先级分配是相同的：优先级($\\tau_1$)  优先级($\\tau_2$)  优先级($\\tau_3$)。因此，“在RM和DM下均可调度”的条件并不矛盾，可以简化为单一的可调度性分析。\n-   **客观性**：语言精确且无偏见。所有术语均为标准技术定义。\n\n该问题没有表现出任何诸如科学上不合理、不完整、矛盾或模糊之类的缺陷。指令是具体的，并导向一个唯一的解。\n\n### 步骤3：结论与行动\n该问题是**有效的**。将推导解答。\n\n### 解答推导\n目标是根据所提供的基于利用率的充分性测试，找到使任务集保持可调度的最大阻塞时间 $B_{\\max}$。\n\n首先，我们确定优先级分配。对于给定的任务集，所有截止时间 $D_i$ 都等于它们各自的周期 $T_i$。\n周期分别为 $T_1 = 10\\,\\mathrm{ms}$，$T_2 = 25\\,\\mathrm{ms}$ 和 $T_3 = 50\\,\\mathrm{ms}$。我们有 $T_1  T_2  T_3$。\n-   速率单调（RM）调度将较高优先级分配给周期较短的任务。因此，优先级顺序为 $\\tau_1 > \\tau_2 > \\tau_3$。\n-   截止时间单调（DM）调度将较高优先级分配给相对截止时间较短的任务。由于 $D_i = T_i$，我们有 $D_1  D_2  D_3$，因此优先级顺序也是 $\\tau_1 > \\tau_2 > \\tau_3$。\n由于两种方案得出相同的优先级分配，我们只需要执行一次可调度性分析。\n\n接下来，我们计算任务集的总处理器利用率 $U$，不包括任何阻塞效应。\n$$U = \\sum_{i=1}^{3} \\frac{C_i}{T_i} = \\frac{C_1}{T_1} + \\frac{C_2}{T_2} + \\frac{C_3}{T_3}$$\n代入给定值（单位为毫秒）：\n$$U = \\frac{1}{10} + \\frac{2.5}{25} + \\frac{6}{50} = 0.1 + 0.1 + 0.12 = 0.32$$\n\n该问题提供了使用 Liu and Layland 界限 $U_{\\text{bound}}(n)$ 的 $n$ 个任务可调度的充分条件。对于 $n=3$ 个任务，此界限为：\n$$U_{\\text{bound}}(3) = 3(2^{1/3} - 1)$$\n\n该问题强制要求一种特定方法，将阻塞时间的影响纳入此基于利用率的测试中。我们必须“在最小关注时间窗口上对最坏情况阻塞进行归一化”。在此任务集的背景下，“最小关注时间窗口”对应于最短的周期，即 $T_1$。将阻塞时间 $B$ 在此周期上进行归一化，会产生一个“阻塞因子”，这是一个表示被阻塞消耗的利用率的附加项：\n$$U_{\\text{blocking}} = \\frac{B}{T_1}$$\n这是一种保守的方法，因为它假设阻塞影响具有最紧定时约束的任务，从而在利用率框架中对整个系统的可调度性产生最大影响。\n\n包含阻塞的可调度性充分条件是，总有效利用率不得超过可调度性界限：\n$$\\left( \\sum_{i=1}^{3} \\frac{C_i}{T_i} \\right) + \\frac{B}{T_1} \\le U_{\\text{bound}}(3)$$\n代入已知值：\n$$0.32 + \\frac{B}{10} \\le 3(2^{1/3} - 1)$$\n为了找到最大允许阻塞时间 $B_{\\max}$，我们在该不等式的边界求解方程：\n$$0.32 + \\frac{B_{\\max}}{10} = 3(2^{1/3} - 1)$$\n求解 $B_{\\max}$：\n$$\\frac{B_{\\max}}{10} = 3(2^{1/3} - 1) - 0.32$$\n$$B_{\\max} = 10 \\left( 3(2^{1/3} - 1) - 0.32 \\right)$$\n现在，我们计算数值。\n$$U_{\\text{bound}}(3) = 3(2^{1/3} - 1) \\approx 3(1.25992105 - 1) = 3(0.25992105) \\approx 0.77976315$$\n将此值代入 $B_{\\max}$ 的表达式中：\n$$B_{\\max} = 10 (0.77976315 - 0.32) = 10 (0.45976315) = 4.5976315\\,\\mathrm{ms}$$\n问题要求将答案四舍五入到四位有效数字。\n$$B_{\\max} \\approx 4.598\\,\\mathrm{ms}$$\n因此，在给定条件下，保证任务集可调度的最大阻塞时间是 $4.598\\,\\mathrm{ms}$。",
            "answer": "$$\\boxed{4.598}$$"
        }
    ]
}