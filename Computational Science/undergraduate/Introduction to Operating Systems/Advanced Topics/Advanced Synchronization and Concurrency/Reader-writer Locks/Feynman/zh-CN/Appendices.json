{
    "hands_on_practices": [
        {
            "introduction": "在实现层面之上，并发系统的稳定性还依赖于对锁的正确使用。本练习模拟了一个常见的编程错误：一个读者线程在解锁时忘记递减计数器，从而“泄露”了锁 ()。你将通过分析这一场景，深入理解锁状态机的演变，并辨别在不同锁策略下导致的死锁与饥饿现象，这对于调试复杂的并发问题至关重要。",
            "id": "3675714",
            "problem": "读写锁（RW lock）为读者强制共享访问，为写者强制独占访问。考虑一种常见实现，它维护三个由互斥锁保护并由条件变量协调的状态变量：$C$（活跃读者的数量）、$W$（等待写者的数量）和 $X$（一个指示是否有写者处于活跃状态的布尔标志）。当 $X$ 为 $\\text{false}$ 且 $W=0$ 时，该锁允许读者进入；当 $X$ 为 $\\text{false}$ 且 $C=0$ 时，允许写者进入。读者获取锁时将 $C$ 增加 1，解锁时将 $C$ 减少 1。写者获取锁时将 $X$ 设置为 $\\text{true}$，解锁时将 $X$ 设置为 $\\text{false}$。在写者优先的变体中，即使 $X$ 为 $\\text{false}$，当 $W>0$ 时读者也必须等待。\n\n从基本定义开始：互斥要求任意两个写者不能并发执行；读者共享访问要求只有在没有活跃写者时，读者才可以并发执行；死锁是一种状态，其中一组线程各自等待的事件只能由该集合中的其他线程引发，这是基于上面定义的锁语义和状态转换。\n\n假设系统开始于 $C=0$、$W=0$ 和 $X=\\text{false}$ 的静止状态。然后，$n$ 个读者顺序地获取并释放该锁。恰好有一个读者在解锁时未能将 $C$ 减 1，导致 $C=1$，尽管实际上没有活跃的读者。随后，一个写者到达并尝试获取锁，在 $C>0$ 或 $X$ 为 $\\text{true}$ 的条件下执行其等待循环，并将 $W$ 增加到 1。此后，又有其他读者陆续到达。\n\n在这些假设下，考虑以下陈述：\n\nA. 在写者优先的读写锁中，在单个读者忘记将 $C$ 减 1 且一个写者到达后，系统将进入死锁状态：$C$ 保持为 1，写者因为 $C>0$ 而无法继续，所有新来的读者因为 $W>0$ 而被阻塞，因此没有线程能够取得进展将 $C$ 变为 0。\n\nB. 在读者优先的读写锁中（读者在 $W>0$ 时不等待），同样的错误不可避免地导致死锁而非饿死，因为当 $C>0$ 时写者永远无法获取锁。\n\nC. 一个基于等待图的死锁检测器，它记录从等待线程到它们等待的锁的边，以及从锁到其当前持有线程的边，将会报告这个死锁，因为泄漏的读者计数对应于一个所有者，并在图中构成一个环路。\n\nD. 一种检测策略，它维护每个线程的读者持有计数器 $c_i$ 并周期性地检查不变量 $\\sum_i c_i = C$，可以通过发现 $C$ 与真实的读者持有者集合之间的不匹配，在任何写者开始等待之前就识别出这个错误。\n\nE. 为写者的等待条件添加超时可以保证不发生死锁并保持正确性，因为写者最终将绕过 $C>0$ 的条件并继续执行。\n\n选择所有正确的陈述。",
            "solution": "问题陈述描述了一种读写锁实现和一个涉及软件错误的场景，在该场景中，一个读者在释放锁时未能减少活跃读者计数 $C$。我们必须分析在不同锁策略和不同检测机制下此错误的后果。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n-   **系统**：一个读写锁（RW lock）。\n-   **状态变量**：\n    -   $C$：整数，活跃读者的数量。\n    -   $W$：整数，等待写者的数量。\n    -   $X$：布尔值，如果一个写者是活跃的则为 `true`。\n-   **加锁逻辑（读者）**：\n    -   获取条件（通用）：$X = \\text{false}$ 且 $W = 0$。\n    -   获取操作：$C \\leftarrow C + 1$。\n    -   解锁操作：$C \\leftarrow C - 1$。\n-   **加锁逻辑（写者）**：\n    -   获取条件：$X = \\text{false}$ 且 $C = 0$。\n    -   获取操作：$X \\leftarrow \\text{true}$。\n    -   解锁操作：$X \\leftarrow \\text{false}$。\n-   **写者优先变体**：如果 $W > 0$，读者也必须等待。\n-   **场景**：\n    1.  初始状态：$C = 0$，$W = 0$，$X = \\text{false}$。\n    2.  $n$ 个读者顺序地获取并释放锁。\n    3.  一个错误：恰好有一个读者在解锁时未能执行 $C \\leftarrow C - 1$。\n    4.  结果状态：$C = 1$，但实际上没有读者线程在其临界区内。\n    5.  一个写者到达。它执行其等待条件循环（`while (C > 0 || X == true)`）并将 $W$ 增加到 1。\n    6.  在写者之后，其他读者陆续到达。\n-   **定义**：\n    -   **互斥**：任意两个写者不能并发。\n    -   **共享访问**：只有在没有活跃写者时，读者才能并发。\n    -   **死锁**：一组线程各自等待一个只能由该集合中其他线程引发的事件。\n\n**步骤 2：使用提取的已知条件进行验证**\n-   **科学依据**：该问题基于成熟的计算机科学主题——并发控制，特别是读写锁。所描述的实现（使用计数器、标志、互斥锁和条件变量）是一个标准的教科书模型。所提出的错误是一个现实的编程错误。\n-   **适定性**：初始条件、状态转换规则和事件序列都得到了明确的规定。选项中提出的问题可以根据这些规则进行评估。\n-   **客观性**：语言是技术性的，没有主观论断。\n-   **完整性和一致性**：该问题提供了足够的信息来分析系统的行为。标准锁和写者优先锁的规则都已清晰阐明。设置中不存在矛盾。\n\n**步骤 3：结论与行动**\n问题陈述是有效的。它描述了并发编程中一个现实且可分析的场景。我将继续进行解答。\n\n### 解答推导\n\n我们的分析初始状态，在错误发生和第一个写者 ($W_1$) 到达之后，如下所示：\n-   有错误的读者已经终止，留下 $C=1$。\n-   实际上没有线程持有读锁。\n-   一个写者 $W_1$ 到达。它检查其等待条件 `while (C > 0 || X == true)`。由于 $C=1$，该条件满足。\n-   $W_1$ 增加等待写者的计数，因此 $W=1$。\n-   $W_1$ 在一个条件变量上阻塞。\n-   系统状态现在是：$C=1$，$W=1$，$X=\\text{false}$。\n-   随后，新的读者到达。\n\n我们现在将根据这个系统状态和提供的规则来评估每个陈述。\n\n### 逐项分析\n\n**A. 在写者优先的读写锁中，在单个读者忘记将 $C$ 减 1 且一个写者到达后，系统将进入死锁状态：$C$ 保持为 1，写者因为 $C>0$ 而无法继续，所有新来的读者因为 $W>0$ 而被阻塞，因此没有线程能够取得进展将 $C$ 变为 0。**\n\n-   **分析**：\n    1.  写者 $W_1$ 被阻塞，等待条件 $C=0$。\n    2.  新的读者到达。对于写者优先锁，读者只有在 $X$ 为 $\\text{false}$ 且 $W=0$ 时才能获取锁。\n    3.  在当前状态下，$W=1$。因此，任何新到达的读者都将被阻塞；它无法获取锁。\n    4.  我们有一组被阻塞的线程：写者 $W_1$ 和所有后续的读者。\n    5.  $W_1$ 正在等待 $C$ 变为 0。唯一能使 $C$ 减少的操作是读者的解锁。然而，当前没有读者持有锁。本应减少 $C$ 的线程已经终止。新来的读者在它们能够获取锁并增加 $C$ 之前就被阻塞了，所以它们永远不会达到可以执行解锁来减少 $C$ 的状态。因此，$W_1$ 等待的事件永远不会发生。\n    6.  新的读者正在等待 $W$ 变为 0。这只有在 $W_1$ 获取并释放锁之后才会发生。但 $W_1$ 被阻塞了。\n    7.  这造成了永久性的停滞。线程集合 {$W_1$，所有新读者} 都在等待无法被触发的事件。写者在等待一个“幽灵”读者释放锁，而新读者在等待写者。这符合死锁的定义。\n-   **结论**：正确。\n\n**B. 在读者优先的读写锁中（读者在 $W>0$ 时不等待），同样的错误不可避免地导致死锁而非饿死，因为当 $C>0$ 时写者永远无法获取锁。**\n\n-   **分析**：\n    1.  我们考虑一个读者优先锁。初始状态相同：$C=1$，$W=1$，$X=\\text{false}$，写者 $W_1$ 因等待 $C=0$ 而被阻塞。\n    2.  新的读者到达。在读者优先的实现中，读者获取锁的条件通常只是 $X=\\text{false}$。等待的写者（$W>0$）的存在不会阻塞读者。\n    3.  由于 $X=\\text{false}$，这些新读者可以成功获取锁，将 $C$ 增加到 2、3，...。它们可以执行工作，然后正确地释放锁，减少 $C$。\n    4.  当这些新读者在取得进展时，写者 $W_1$ 因为 $C>0$ 而仍然被阻塞。只要有持续的读者流到来，在写者被调度运行时，$C=0$ 这个条件可能永远不会满足。\n    5.  这种一个线程（$W_1$）被无限期推迟而其他线程（新读者）能取得进展的场景，就是**饿死**（starvation）的定义。\n    6.  这不是死锁，因为系统并未处于全局停滞状态；读者线程能够继续执行。该陈述错误地将结果认定为死锁。\n-   **结论**：不正确。\n\n**C. 一个基于等待图的死锁检测器，它记录从等待线程到它们等待的锁的边，以及从锁到其当前持有线程的边，将会报告这个死锁，因为泄漏的读者计数对应于一个所有者，并在图中构成一个环路。**\n\n-   **分析**：\n    1.  用于资源分配的等待图通常包含线程和资源（这里是读写锁）的节点。从线程 $T_i$ 到资源 $R$ 的边表示 $T_i$ 正在等待 $R$。从 $R$ 到线程 $T_j$ 的边表示 $R$ 被 $T_j$ 持有。环路表示死锁。\n    2.  在我们的死锁场景中（来自选项 A），写者 $W_1$ 正在等待读写锁。这会创建一条边：$W_1 \\rightarrow \\text{RWLock}$。\n    3.  锁的状态是 $C=1$，所以它处于“被持有”的读模式。要形成一个环路，检测器必须从锁画一条到其所有者的边：$\\text{RWLock} \\rightarrow T_{owner}$。\n    4.  问题在于，所描述的锁实现只维护读者的*数量*（$C$），而不记录它们的身份。更重要的是，导致 $C$ 为 1 的线程已经终止了。它是一个“幽灵”所有者。\n    5.  死锁检测器是对系统中的*活跃*线程集合进行操作的。它不能创建一条指向不存在线程的边。锁的状态显示它被持有，但检测器找不到一个活跃的所有者来分配这条持有边。\n    6.  如果没有从锁到活跃线程的边，就无法形成环路。该图将仅仅显示一个或多个线程在等待一个看起来被持有但没有可识别所有者来完成等待链的锁。因此，这种类型的检测器不会报告死锁。\n-   **结论**：不正确。\n\n**D. 一种检测策略，它维护每个线程的读者持有计数器 $c_i$ 并周期性地检查不变量 $\\sum_i c_i = C$，可以通过发现 $C$ 与真实的读者持有者集合之间的不匹配，在任何写者开始等待之前就识别出这个错误。**\n\n-   **分析**：\n    1.  这个陈述提出了一种调试或监控机制。假设如果线程 $i$ 持有读锁，则 $c_i$ 为 1，否则为 0。不变量是，所有活跃线程的这些每线程标志的总和必须等于锁的内部读者计数 $C$。\n    2.  当有错误的读者（我们称之为 $R_{bug}$）获取锁时，它会设置其内部标志 $c_{bug}=1$，并且锁会增加其计数器 $C \\leftarrow 1$。此时，$\\sum_i c_i = 1$ 且 $C=1$，因此不变量成立。\n    3.  然后，读者 $R_{bug}$ 在没有减少 $C$ 的情况下终止。线程终止时，其所有相关资源和状态，包括假设的 $c_{bug}$ 标志，都会被回收。该线程对总和 $\\sum_i c_i$ 的贡献变为 0。\n    4.  在 $R_{bug}$ 终止后，状态立即变为：$C=1$（因为它没有被减少）且 $\\sum_i c_i = 0$（对所有剩余的*活跃*线程求和）。\n    5.  对不变量 $\\sum_i c_i = C$ 的周期性检查会发现一个不匹配：$0 \\neq 1$。\n    6.  这个不匹配在有错误的线程终止时就会被检测到，这发生在写者到达之前。因此，所提出的策略能有效地识别这个特定的错误。\n-   **结论**：正确。\n\n**E. 为写者的等待条件添加超时可以保证不发生死锁并保持正确性，因为写者最终将绕过 $C>0$ 的条件并继续执行。**\n\n-   **分析**：\n    1.  考虑选项 A 中的死锁。写者 $W_1$ 被无限期阻塞。如果它在条件变量上的等待有超时，它最终会停止等待并重新获得控制权。\n    2.  这确实打破了死锁，因为写者不再被永久卡住。所以，该论断的第一部分（“保证不发生死锁”）是合理的。\n    3.  然而，该陈述还声称它“保持正确性”。当写者的定时等待到期时，条件 $C>0$ 仍然为真。为了保持正确性，写者必须在其 `while` 循环中重新检查该条件，发现它仍然为真后，重新进入等待状态。这并不能解决问题。\n    4.  如果像该陈述所暗示的那样，写者“绕过 $C>0$ 的条件并继续执行”，它将在 $C=1$ 的情况下获取锁（例如，设置 $X=\\text{true}$）。\n    5.  这一行为从根本上违反了读写锁的核心不变量：当有读者活跃时，写者不能活跃。锁的状态（$C=1$）表明有一个读者是活跃的。允许写者继续执行打破了这一保证。正确性没有被保持。锁的状态现在是不一致的（$C=1$ 且 $X=\\text{true}$）并被永久损坏，因为那个值为 1 的幽灵计数永远不会被清除。\n-   **结论**：不正确。",
            "answer": "$$\\boxed{AD}$$"
        },
        {
            "introduction": "并发原语的行为不仅由其自身逻辑决定，还受到操作系统调度器的深刻影响。本练习将引导你分析一个经典的系统级风险——优先级反转，即一个高优先级任务被一个低优先级任务阻塞 ()。通过分析读写锁在这种场景下的表现，你将掌握在真实世界的抢占式、优先级驱动的系统中，同步机制可能引发的复杂问题及其缓解策略。",
            "id": "3675645",
            "problem": "一个单处理器操作系统使用抢占式、固定优先级的调度器：在任何时刻，具有最高数值优先级的可运行线程会运行，一个更高优先级的到达会立即抢占一个更低优先级的线程。一个读写锁允许任意数量的并发读者，但要求写者独占访问。一个持有锁的线程仅因锁的语义而被阻塞；否则，如果它是可运行的，并且在可运行线程中具有最高优先级，那么它就会运行。假设上下文切换开销可忽略不计，且我们所关心的临界区是CPU密集型的。\n\n考虑以下场景。存在三类线程：一个低优先级读者 $R_L$，其优先级为 $p_L$；一个高优先级写者 $W_H$，其优先级为 $p_H$；以及一系列中等优先级的线程 $\\{M_i\\}$，每个线程的优先级为 $p_M$，使得 $p_H \\gt p_M \\gt p_L$。在时间 $t=0$，$R_L$ 获取了读锁并开始一个剩余CPU时间为 $C_r \\gt 0$ 的临界区。在时间 $t=\\varepsilon$（对于某个任意小的 $\\varepsilon \\gt 0$），$W_H$ 变为可运行状态并尝试获取写锁，因为 $R_L$ 持有读锁而被阻塞。从时间 $t=\\varepsilon$ 开始，任意数量的中等优先级线程 $\\{M_i\\}$ 可能会随着时间的推移变为可运行状态。该锁的实现默认允许多个并发读者，并且没有任何内置的优先级处理机制，除非某个变体特别指定。\n\n仅使用上述核心定义（读写互斥、抢占式固定优先级调度、以及被阻塞的线程无法运行这一概念），推理优先级反转及其缓解措施。下列哪些陈述是正确的？选择所有适用的选项。\n\nA. 在所描述的基线实现（没有优先级感知功能）中，$W_H$ 可能会遭遇无界延迟，即使在 $t=\\varepsilon$ 时只有 $R_L$ 持有读锁，因为任意多的中等优先级线程的到达可以持续抢占 $R_L$，阻止其完成临界区。\n\nB. 一个变体，它在任何被阻塞的写者到达时，立即将每个当前持有读锁的线程的优先级提升到 $p_H$，并阻止新读者进入，直到写者获取并释放锁，这样可以消除无界优先级反转。在单核上，若在 $t=\\varepsilon$ 时恰好有1个当前读者，其剩余临界区时间为 $C_r$，那么从 $t=\\varepsilon$ 开始，$W_H$ 经历的额外等待时间最多为 $C_r$。\n\nC. 一个变体，它在被阻塞的写者到达时，将任意选择的一个当前持有读锁的线程的优先级提升到 $p_H$，但允许新读者继续获取锁，这在一般情况下足以防止无界优先级反转。\n\nD. 一个变体，它在被阻塞的写者到达时，为锁对象本身分配一个临时优先级 $p_H$（而不修改持有锁的线程的优先级），这足以防止无界优先级反转，因为调度器会偏好锁的优先级。\n\nE. 一个变体，它为读写锁实现了一种优先级天花板式的策略——定义一个天花板 $p_C = \\max\\{p \\mid \\text{某个线程可能以优先级 } p \\text{ 进行写操作}\\}$；当任何读者获取锁时，它会临时以优先级 $p_C$ 执行；如果有任何写者在等待，则不允许新读者进入——这在给定的调度器下可以消除无界优先级反转，且不会饿死写者。",
            "solution": "用户提供了一个关于在使用读写锁的抢占式、固定优先级单处理器操作系统环境下的优先级反转问题。任务是验证问题陈述的有效性，如果有效，则评估关于系统行为和潜在缓解策略的几个陈述。\n\n### 问题验证\n\n首先，我将验证问题陈述。\n\n#### 步骤1：提取已知条件\n\n*   **系统模型**：单处理器，采用抢占式、固定优先级的调度器。\n*   **调度策略**：具有最高数值优先级的可运行线程会运行。更高优先级的到达会立即抢占更低优先级的线程。\n*   **同步原语**：读写锁。\n    *   允许多个并发读者。\n    *   要求写者独占访问。\n    *   基线实现没有内置的优先级感知功能。\n*   **线程状态**：持有锁的线程仅因锁语义而被视为阻塞。如果它没有因为试图获取锁而被阻塞，那么它就是可运行的。\n*   **假设**：上下文切换开销可忽略不计；临界区是CPU密集型的。\n*   **场景参与者**：\n    *   一个低优先级读者 $R_L$，优先级为 $p_L$。\n    *   一个高优先级写者 $W_H$，优先级为 $p_H$。\n    *   一系列中等优先级的线程 $\\{M_i\\}$，每个优先级为 $p_M$。\n*   **优先级顺序**：$p_H > p_M > p_L$。\n*   **时间线**：\n    *   在时间 $t=0$，$R_L$ 获取读锁并进入一个剩余CPU时间为 $C_r > 0$ 的临界区。\n    *   在时间 $t=\\varepsilon$（对于某个任意小的 $\\varepsilon > 0$），$W_H$ 变为可运行状态并尝试获取写锁，随后因 $R_L$ 持有读锁而被阻塞。\n    *   对于 $t \\geq \\varepsilon$，任意数量的中等优先级线程 $\\{M_i\\}$ 可能变为可运行状态。\n\n#### 步骤2：使用提取的已知条件进行验证\n\n*   **科学依据**：该问题基于操作系统理论中基础且成熟的概念，包括抢占式优先级调度、读写锁和优先级反转。所描述的场景是用于说明这些概念的典型示例。它在科学上是合理的。\n*   **定义明确**：问题定义清晰。系统规则（调度器、锁）、初始条件和后续事件都已指定，从而可以对系统行为进行逻辑分析。问题要求基于此模型评估给定陈述的正确性。\n*   **客观性**：语言技术性强且精确。“单处理器”、“抢占式”、“CPU密集型”等术语以及优先级定义都是客观且无歧义的。\n*   **完整性与一致性**：问题陈述是自包含的，提供了推理结果所需的所有必要信息。“任意数量的中等优先级线程”这一条件是检验*无界*延迟的必要设置部分。没有矛盾之处。\n*   **现实性**：这个场景是实时系统中的一个经典问题，从计算机科学的角度来看是完全现实的。\n\n#### 步骤3：结论与行动\n\n问题陈述是**有效的**。这是一个操作系统理论中定义良好的问题。我将继续推导解决方案并评估每个选项。\n\n### 解题推导与选项分析\n\n需要分析的核心问题是优先级反转。当一个高优先级线程被迫等待一个低优先级线程，并且关键的是，这个等待的持续时间因不相关的中等优先级线程的执行而被延长时，就会发生优先级反转。\n\n**基线场景分析**\n\n在时间 $t=0$，$R_L$（优先级 $p_L$）持有读锁并正在运行。\n在时间 $t=\\varepsilon$，$W_H$（优先级 $p_H$）到达并尝试获取写锁。由于 $R_L$ 持有读锁，$W_H$ 在锁上被阻塞。根据调度器规则，被阻塞的线程不运行。\n现在，考虑在任意时间 $t' > \\varepsilon$，一个中等优先级的线程 $M_i$（优先级 $p_M$）变为可运行状态。此时，可运行线程集合至少包含 $\\{R_L, M_i\\}$。由于调度器是抢占式的且 $p_M > p_L$，调度器将抢占 $R_L$ 并运行 $M_i$。\n问题陈述指出，任意数量的此类线程 $\\{M_i\\}$ 都可能变为可运行状态。这意味着CPU可能被一系列中等优先级的任务持续占用。只要至少有一个可运行的线程 $M_i$ 存在，低优先级读者 $R_L$ 就永远不会被调度运行。\n因为 $R_L$ 无法运行，它就无法完成其临界区并释放读锁。因为 $R_L$ 永远不释放锁，高优先级写者 $W_H$ 将无限期地被阻塞。这是一个经典的无界优先级反转案例，其中 $W_H$ 的阻塞时间不是由 $R_L$ 的临界区决定的，而是由任意数量的 $M_i$ 线程的执行决定的。\n\n**逐项分析**\n\n**A. 在所描述的基线实现（没有优先级感知功能）中，$W_H$ 可能会遭遇无界延迟，即使在 $t=\\varepsilon$ 时只有 $R_L$ 持有读锁，因为任意多的中等优先级线程的到达可以持续抢占 $R_L$，阻止其完成临界区。**\n\n*   **分析**：该陈述准确地描述了上面分析的基线场景。高优先级线程 $W_H$ 被低优先级线程 $R_L$ 阻塞。然而，$R_L$ 由于来自中等优先级线程 $\\{M_i\\}$ 的持续抢占而无法运行。这导致了 $W_H$ 的无界等待时间。\n*   **结论**：**正确**。\n\n**B. 一个变体，它在任何被阻塞的写者到达时，立即将每个当前持有读锁的线程的优先级提升到 $p_H$，并阻止新读者进入，直到写者获取并释放锁，这样可以消除无界优先级反转。在单核上，若在 $t=\\varepsilon$ 时恰好有1个当前读者，其剩余临界区时间为 $C_r$，那么从 $t=\\varepsilon$ 开始，$W_H$ 经历的额外等待时间最多为 $C_r$。**\n\n*   **分析**：这描述了一种类似优先级继承的机制。在 $t=\\varepsilon$ 时，$W_H$ 阻塞。该变体的规则被触发：\n    1.  唯一的读者 $R_L$ 的优先级从 $p_L$ 提升到 $p_H$。\n    2.  新读者被阻止获取锁。\n    现在 $R_L$ 的优先级为 $p_H$，它不能被任何到达的中等优先级线程 $M_i$ 抢占（因为 $p_H > p_M$）。$R_L$ 将会运行至完成。这所需的时间取决于它在 $t=\\varepsilon$ 之前完成了多少临界区。假设它已经执行了时间 $\\delta \\le \\varepsilon$。其剩余CPU时间为 $C_r' = C_r - \\delta$。从 $t=\\varepsilon$ 开始，$R_L$ 将运行 $C_r'$ 的时间，然后释放锁。因此，$W_H$ 从其在 $t=\\varepsilon$ 到达时开始的等待时间为 $C_r'$。由于 $\\delta \\ge 0$，我们有 $C_r' \\le C_r$。该陈述声称等待时间最多为 $C_r$，这是一个正确的上界。该机制成功地限制了优先级反转。\n*   **结论**：**正确**。\n\n**C. 一个变体，它在被阻塞的写者到达时，将任意选择的一个当前持有读锁的线程的优先级提升到 $p_H$，但允许新读者继续获取锁，这在一般情况下足以防止无界优先级反转。**\n\n*   **分析**：这个变体有两个重大缺陷。\n    1.  **只提升一个读者的优先级**：假设在 $W_H$ 阻塞时，有多个低优先级的读者，比如 $R_{L1}$ 和 $R_{L2}$。该变体将 $R_{L1}$ 的优先级提升到 $p_H$。$R_{L1}$ 运行并完成，释放了它对锁的持有。然而，$R_{L2}$ 仍然持有读锁，并保持其低优先级 $p_L$。$R_{L2}$ 将被任何中等优先级的线程 $\\{M_i\\}$ 抢占，优先级反转问题依然存在。$W_H$ 仍然被 $R_{L2}$ 阻塞。\n    2.  **允许新读者**：即使最初只有一个读者 $R_L$，其优先级被提升并完成任务。然而，该策略允许新读者在 $W_H$ 等待时获取锁。一个新的中等优先级读者 $R_M$ 可以在 $R_L$ 释放锁之前获取锁。现在，$W_H$ 被 $R_M$ 阻塞。这种情况可以重复发生，导致写者饿死，这是一种无界延迟的形式。\n    因此，这个提议的解决方案在一般情况下是不充分的。\n*   **结论**：**错误**。\n\n**D. 一个变体，它在被阻塞的写者到达时，为锁对象本身分配一个临时优先级 $p_H$（而不修改持有锁的线程的优先级），这足以防止无界优先级反转，因为调度器会偏好锁的优先级。**\n\n*   **分析**：这个陈述定义不明确。问题的核心调度规则是：“在任何时刻，具有最高数值优先级的可运行线程会运行。”调度器操作的是线程，而不是像锁这样的同步对象。该陈述没有提供任何机制来说明“锁的优先级”将如何影响线程的调度。声称“因为调度器会偏好锁的优先级”是一个未经证实的断言。为了使这个变体起作用，它需要被重新规定为一个修改线程优先级的规则，例如，“任何持有锁的线程都会继承锁的优先级”。没有这个关键细节，该陈述描述的机制无法与已定义的调度策略集成。它模糊到致命的程度。\n*   **结论**：**错误**。\n\n**E. 一个变体，它为读写锁实现了一种优先级天花板式的策略——定义一个天花板 $p_C = \\max\\{p \\mid \\text{某个线程可能以优先级 } p \\text{ 进行写操作}\\}$；当任何读者获取锁时，它会临时以优先级 $p_C$ 执行；如果有任何写者在等待，则不允许新读者进入——这在给定的调度器下可以消除无界优先级反转，且不会饿死写者。**\n\n*   **分析**：这描述了为读写锁调整的优先级天花板协议。让我们追踪一下：\n    1.  优先级天花板 $p_C$ 被设置为任何潜在写者的最高优先级，即 $p_H$。\n    2.  在 $t=0$ 时，当 $R_L$ 获取读锁时，其优先级立即被提升到 $p_C = p_H$。它开始以这个高优先级执行。\n    3.  因为 $R_L$ 以 $p_H$ 的优先级运行，它不能被任何到达的中等优先级线程 $\\{M_i\\}$ 抢占（因为 $p_H > p_M$）。因此，优先级反转从一开始就得到了防止。\n    4.  在 $t=\\varepsilon$ 时，$W_H$ 到达并阻塞，成为一个“等待中的写者”。\n    5.  “不允许新读者”的规则现在被激活，阻止任何其他读者获取锁并延长 $W_H$ 的等待时间。这可以防止写者饿死。\n    $R_L$ 继续以优先级 $p_H$ 运行，完成其临界区，然后释放锁。一旦锁被释放，$W_H$ 就可以获取它。$W_H$ 的阻塞时间受限于持有锁的读者（它们以天花板优先级运行）的剩余临界区时间。该协议正确地消除了无界优先级反转并防止了写者饿死。\n*   **结论**：**正确**。",
            "answer": "$$\\boxed{ABE}$$"
        }
    ]
}