{
    "hands_on_practices": [
        {
            "introduction": "One of the primary benefits of indexed allocation is its ability to support files that are much larger than what a few direct pointers could manage. This exercise guides you through the fundamental calculation of a file's maximum size in a system with multiple levels of indirection. By summing the capacities of direct, single-indirect, double-indirect, and deeper-level pointers, you will see firsthand how this scheme achieves massive scalability from a small, fixed-size inode. ",
            "id": "3649508",
            "problem": "A file system component within an Operating System (OS) uses indexed allocation. Each file is composed of fixed-size data blocks of size $B$ bytes. The fileâ€™s inode (index node) contains $a$ direct block pointers that reference data blocks directly. It may also contain pointers to indirect index blocks providing up to depth $d$ levels of indirection. Each indirect index block is a fixed-size block that stores only block pointers, each of size $p$ bytes, so an indirect index block can hold $k$ pointers, where $k$ equals the integer capacity of a block of size $B$ when filled with $p$-byte pointers. Assume $k$ is known and that every indirect pointer at level $i$ ($i \\in \\{1,\\dots,d\\}$) ultimately references only data blocks at the leaves; intermediate levels reference further indirect blocks. The inode has exactly one pointer to each level of indirection $i \\in \\{1,\\dots,d\\}$, in addition to its $a$ direct pointers. Index blocks themselves do not contribute to the logical file size; only data blocks are counted.\n\nStarting from these definitions and fundamental counting principles, derive an analytic expression for the maximum number of addressable data blocks in a file as a function of $a$, $k$, and $d$, and then derive the maximum file size in bytes as a function of $B$, $a$, $k$, and $d$.\n\nFinally, evaluate the maximum file size for the case $B=4\\,\\mathrm{KB}$, $p=4\\,\\mathrm{B}$, $a=12$, and $d=3$. Express the final maximum file size in bytes. Do not round; give the exact integer value.",
            "solution": "The user wants me to solve a problem related to indexed file allocation in an operating system.\n\n### Step 1: Extract Givens\n- File system block size: $B$ bytes.\n- Number of direct block pointers in an inode: $a$.\n- Maximum depth of indirection: $d$.\n- Size of a block pointer: $p$ bytes.\n- Number of pointers per indirect index block: $k = \\lfloor B/p \\rfloor$.\n- Inode structure: $a$ direct pointers and one pointer for each level of indirection $i \\in \\{1, \\dots, d\\}$.\n- Task 1: Derive an analytic expression for the maximum number of addressable data blocks, $N_{blocks}$, as a function of $a$, $k$, and $d$.\n- Task 2: Derive an analytic expression for the maximum file size, $S_{max}$, as a function of $B$, $a$, $k$, and $d$.\n- Task 3: Evaluate $S_{max}$ for the specific case: $B=4\\,\\mathrm{KB}$, $p=4\\,\\mathrm{B}$, $a=12$, and $d=3$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem describes a standard model of indexed file allocation, a fundamental concept in operating systems.\n- **Scientifically Grounded:** The model is a well-established and simplified representation of file systems like the Unix File System (UFS). All concepts are standard in computer science.\n- **Well-Posed:** The problem is clearly defined with all necessary variables ($B, p, a, d$) and relationships ($k = \\lfloor B/p \\rfloor$) provided. The structure of the inode is explicitly stated. The tasks are specific and lead to a unique solution.\n- **Objective:** The language is formal and unambiguous.\n\nThe problem does not exhibit any flaws. It is not scientifically unsound, non-formalizable, incomplete, unrealistic, ill-posed, or trivial. It is a standard, solvable problem in the field of operating systems.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A solution will be provided.\n\n### Derivation of Maximum Number of Addressable Data Blocks\n\nLet $N_{blocks}$ be the maximum number of data blocks a file can have. This is determined by the total number of data block pointers that can be accessed starting from the file's inode. We sum the contributions from the direct and indirect pointers.\n\n1.  **Contribution from Direct Pointers:** The inode contains $a$ direct pointers. Each direct pointer references exactly one data block.\n    Contribution from direct pointers = $a$.\n\n2.  **Contribution from Indirect Pointers:** The problem states that the inode has \"exactly one pointer to each level of indirection $i \\in \\{1,\\dots,d\\}$\". This means there is one single-indirect pointer, one double-indirect pointer, ..., and one $d$-level-indirect pointer.\n\n    -   **Level 1 (Single-Indirect Pointer):** The single-indirect pointer in the inode points to an *index block*. This index block contains $k$ pointers. Each of these $k$ pointers references a data block.\n        Contribution from the level-1 pointer = $k^1 = k$.\n\n    -   **Level 2 (Double-Indirect Pointer):** The double-indirect pointer in the inode points to a first-level index block. This block contains $k$ pointers, each of which points to a second-level index block. There are thus $k$ second-level index blocks. Each of these second-level index blocks contains $k$ pointers to data blocks.\n        Contribution from the level-2 pointer = $k \\times k = k^2$.\n\n    -   **Level $i$ ($i$-level-Indirect Pointer):** Generalizing the pattern, the $i$-level-indirect pointer in the inode initiates a tree of index blocks with a depth of $i$. This structure allows addressing $k^i$ data blocks.\n        Contribution from the level-$i$ pointer = $k^i$.\n\n    The total contribution from all indirect pointers is the sum of the contributions from each level of indirection from $1$ to $d$.\n    Total contribution from indirect pointers = $\\sum_{i=1}^{d} k^i$.\n\n3.  **Total Number of Data Blocks:** The total number of addressable data blocks, $N_{blocks}$, is the sum of the blocks addressed by direct pointers and all levels of indirect pointers.\n    $$N_{blocks}(a, k, d) = a + \\sum_{i=1}^{d} k^i$$\n    This is the first required expression. The sum is a geometric series. For $k \\neq 1$, this can also be written as $N_{blocks}(a, k, d) = a + k \\frac{k^d - 1}{k - 1}$.\n\n### Derivation of Maximum File Size\n\nThe logical size of the file is determined by the content of the data blocks only. Each data block has a size of $B$ bytes. The maximum file size, $S_{max}$, is the total number of addressable data blocks multiplied by the size of each block.\n\nUsing the expression for $N_{blocks}$ derived above:\n$$S_{max}(B, a, k, d) = B \\times N_{blocks}(a, k, d)$$\nSubstituting the expression for $N_{blocks}$:\n$$S_{max}(B, a, k, d) = B \\left( a + \\sum_{i=1}^{d} k^i \\right)$$\nThis is the second required analytical expression.\n\n### Evaluation for the Specific Case\n\nWe are asked to evaluate the maximum file size for the case where $B=4\\,\\mathrm{KB}$, $p=4\\,\\mathrm{B}$, $a=12$, and $d=3$.\n\n1.  **Calculate $k$:**\n    First, we must convert $B$ to bytes.\n    $B = 4\\,\\mathrm{KB} = 4 \\times 1024\\,\\mathrm{Bytes} = 4096\\,\\mathrm{Bytes}$.\n    The size of a pointer is $p = 4\\,\\mathrm{Bytes}$.\n    The number of pointers in an index block, $k$, is:\n    $$k = \\left\\lfloor \\frac{B}{p} \\right\\rfloor = \\left\\lfloor \\frac{4096}{4} \\right\\rfloor = 1024$$\n\n2.  **Calculate the total number of blocks, $N_{blocks}$:**\n    We use the formula for $N_{blocks}$ with $a=12$, $d=3$, and $k=1024$.\n    $$N_{blocks} = a + \\sum_{i=1}^{d} k^i = 12 + \\sum_{i=1}^{3} (1024)^i$$\n    $$N_{blocks} = 12 + 1024^1 + 1024^2 + 1024^3$$\n    Let's calculate the powers of $1024$:\n    $1024^1 = 1024$\n    $1024^2 = (2^{10})^2 = 2^{20} = 1,048,576$\n    $1024^3 = (2^{10})^3 = 2^{30} = 1,073,741,824$\n    Now, we sum these values:\n    $$N_{blocks} = 12 + 1024 + 1,048,576 + 1,073,741,824$$\n    $$N_{blocks} = 1036 + 1,048,576 + 1,073,741,824$$\n    $$N_{blocks} = 1,049,612 + 1,073,741,824$$\n    $$N_{blocks} = 1,074,791,436$$\n\n3.  **Calculate the maximum file size, $S_{max}$:**\n    The maximum file size is $N_{blocks}$ multiplied by the block size $B$.\n    $$S_{max} = N_{blocks} \\times B$$\n    $$S_{max} = 1,074,791,436 \\times 4096$$\n    Performing the multiplication:\n    $$S_{max} = 4,402,345,721,856$$\nThe maximum file size is exactly $4,402,345,721,856$ bytes. This is approximately $4$ terabytes ($4\\,\\mathrm{TiB}$).",
            "answer": "$$\\boxed{4402345721856}$$"
        },
        {
            "introduction": "While indexed allocation provides great scalability, its practical efficiency depends on key design choices, like the block size $B$. A larger block size reduces the number of index blocks needed, minimizing metadata overhead, but it can lead to significant wasted space from internal fragmentation in the last data block. This practice puts you in the role of a system designer, tasked with finding the optimal block size that minimizes total storage consumption for a given file by balancing these competing factors. ",
            "id": "3649516",
            "problem": "A storage subsystem in an Operating System (OS) uses indexed allocation with chained single-level index blocks. A data block has size $B$, chosen from the set $\\{1\\,\\mathrm{KB},2\\,\\mathrm{KB},4\\,\\mathrm{KB},8\\,\\mathrm{KB}\\}$, where $1\\,\\mathrm{KB}=1024$ bytes. Each index block consists solely of fixed-size block pointers of size $p$ bytes, with $p=8$ bytes. For a given block size $B$, the pointer capacity of an index block is $k=\\lfloor B/p\\rfloor$, and the maximum single-indirect coverage (the largest file size addressable by a single index block) is $k\\cdot B$ bytes.\n\nAssume the following storage model for a single file of size $S$ bytes:\n- The file uses $n_{d}(B)=\\lceil S/B\\rceil$ data blocks.\n- If more data blocks are needed than a single index block can address, additional index blocks are chained. The number of index blocks used is $n_{i}(B)=\\left\\lceil n_{d}(B)/k\\right\\rceil$. Each index block occupies a full block of size $B$ and stores only data block pointers. You may assume that chaining metadata is managed outside of the index blocks and does not affect $k$.\n- Internal fragmentation arises only from the last partially filled data block and is captured by the ceiling operation on $n_{d}(B)$.\n\nLet the file size be $S=15000000$ bytes, and let $p=8$ bytes.\n\nTask:\n1. For each candidate $B\\in\\{1\\,\\mathrm{KB},2\\,\\mathrm{KB},4\\,\\mathrm{KB},8\\,\\mathrm{KB}\\}$, determine $k=\\lfloor B/p\\rfloor$ and the maximum single-indirect coverage $k\\cdot B$.\n2. Using the model above, determine, for each $B$, the total allocated space $A(B)=\\big(n_{d}(B)+n_{i}(B)\\big)\\cdot B$ in bytes for the file of size $S$.\n3. Choose the block size $B^{\\star}$ that minimizes $A(B)$ (breaking ties by choosing the larger $B$), and compute the corresponding maximum single-indirect coverage $k(B^{\\star})\\cdot B^{\\star}$.\n\nExpress your final answer as a single integer number of bytes. No rounding is required. Use bytes as the unit for any intermediate computations and explanations.",
            "solution": "The problem requires an analysis of storage overhead in an indexed file allocation system. The goal is to determine the optimal block size $B$ from a given set that minimizes total allocated space for a file of a specific size, and then to calculate a related property for that optimal block size. The analysis will proceed by systematically evaluating each candidate block size according to the provided model.\n\nThe given parameters are:\n- File size: $S = 15000000$ bytes.\n- Block pointer size: $p = 8$ bytes.\n- Candidate block sizes: $B \\in \\{1\\,\\mathrm{KB}, 2\\,\\mathrm{KB}, 4\\,\\mathrm{KB}, 8\\,\\mathrm{KB}\\}$. We convert these to bytes using $1\\,\\mathrm{KB} = 1024$ bytes, so $B \\in \\{1024, 2048, 4096, 8192\\}$ bytes.\n\nThe model defines the following quantities for a given block size $B$:\n- The number of pointers per index block: $k(B) = \\lfloor B/p \\rfloor$.\n- The number of data blocks required for the file: $n_{d}(B) = \\lceil S/B \\rceil$.\n- The number of index blocks required to point to all data blocks: $n_{i}(B) = \\lceil n_{d}(B)/k(B) \\rceil$.\n- The total allocated space: $A(B) = (n_{d}(B) + n_{i}(B)) \\cdot B$.\n\nWe will now compute these values for each candidate block size.\n\n**Case 1: Block Size $B = 1024$ bytes**\n\nFirst, we calculate the number of pointers that can be stored in a single index block.\n$$k(1024) = \\left\\lfloor \\frac{1024}{8} \\right\\rfloor = \\lfloor 128 \\rfloor = 128$$\nThe maximum single-indirect coverage is the amount of data addressable by one index block.\n$$k(1024) \\cdot B = 128 \\cdot 1024 = 131072 \\text{ bytes}$$\nNext, we determine the number of data blocks needed for the file.\n$$n_{d}(1024) = \\left\\lceil \\frac{15000000}{1024} \\right\\rceil = \\lceil 14648.4375 \\rceil = 14649$$\nThen, we find the number of index blocks needed to address these data blocks.\n$$n_{i}(1024) = \\left\\lceil \\frac{n_{d}(1024)}{k(1024)} \\right\\rceil = \\left\\lceil \\frac{14649}{128} \\right\\rceil = \\lceil 114.4453125 \\rceil = 115$$\nFinally, we compute the total allocated space.\n$$A(1024) = (n_{d}(1024) + n_{i}(1024)) \\cdot 1024 = (14649 + 115) \\cdot 1024 = 14764 \\cdot 1024 = 15118336 \\text{ bytes}$$\n\n**Case 2: Block Size $B = 2048$ bytes**\n\nFollowing the same procedure:\n$$k(2048) = \\left\\lfloor \\frac{2048}{8} \\right\\rfloor = \\lfloor 256 \\rfloor = 256$$\nThe maximum single-indirect coverage is:\n$$k(2048) \\cdot B = 256 \\cdot 2048 = 524288 \\text{ bytes}$$\nThe number of data blocks is:\n$$n_{d}(2048) = \\left\\lceil \\frac{15000000}{2048} \\right\\rceil = \\lceil 7324.21875 \\rceil = 7325$$\nThe number of index blocks is:\n$$n_{i}(2048) = \\left\\lceil \\frac{n_{d}(2048)}{k(2048)} \\right\\rceil = \\left\\lceil \\frac{7325}{256} \\right\\rceil = \\lceil 28.61328125 \\rceil = 29$$\nThe total allocated space is:\n$$A(2048) = (n_{d}(2048) + n_{i}(2048)) \\cdot 2048 = (7325 + 29) \\cdot 2048 = 7354 \\cdot 2048 = 15060992 \\text{ bytes}$$\n\n**Case 3: Block Size $B = 4096$ bytes**\n\nAgain, we apply the formulas:\n$$k(4096) = \\left\\lfloor \\frac{4096}{8} \\right\\rfloor = \\lfloor 512 \\rfloor = 512$$\nThe maximum single-indirect coverage is:\n$$k(4096) \\cdot B = 512 \\cdot 4096 = 2097152 \\text{ bytes}$$\nThe number of data blocks is:\n$$n_{d}(4096) = \\left\\lceil \\frac{15000000}{4096} \\right\\rceil = \\lceil 3662.109375 \\rceil = 3663$$\nThe number of index blocks is:\n$$n_{i}(4096) = \\left\\lceil \\frac{n_{d}(4096)}{k(4096)} \\right\\rceil = \\left\\lceil \\frac{3663}{512} \\right\\rceil = \\lceil 7.154296875 \\rceil = 8$$\nThe total allocated space is:\n$$A(4096) = (n_{d}(4096) + n_{i}(4096)) \\cdot 4096 = (3663 + 8) \\cdot 4096 = 3671 \\cdot 4096 = 15036416 \\text{ bytes}$$\n\n**Case 4: Block Size $B = 8192$ bytes**\n\nLastly, for the largest block size:\n$$k(8192) = \\left\\lfloor \\frac{8192}{8} \\right\\rfloor = \\lfloor 1024 \\rfloor = 1024$$\nThe maximum single-indirect coverage is:\n$$k(8192) \\cdot B = 1024 \\cdot 8192 = 8388608 \\text{ bytes}$$\nThe number of data blocks is:\n$$n_{d}(8192) = \\left\\lceil \\frac{15000000}{8192} \\right\\rceil = \\lceil 1831.0546875 \\rceil = 1832$$\nThe number of index blocks is:\n$$n_{i}(8192) = \\left\\lceil \\frac{n_{d}(8192)}{k(8192)} \\right\\rceil = \\left\\lceil \\frac{1832}{1024} \\right\\rceil = \\lceil 1.7890625 \\rceil = 2$$\nThe total allocated space is:\n$$A(8192) = (n_{d}(8192) + n_{i}(8192)) \\cdot 8192 = (1832 + 2) \\cdot 8192 = 1834 \\cdot 8192 = 15024128 \\text{ bytes}$$\n\n**Comparison and Selection of Optimal Block Size $B^{\\star}$**\n\nWe now compare the total allocated space $A(B)$ for each block size:\n- $A(1024) = 15118336$ bytes\n- $A(2048) = 15060992$ bytes\n- $A(4096) = 15036416$ bytes\n- $A(8192) = 15024128$ bytes\n\nBy comparing these values, we find that the minimum total allocated space is $15024128$ bytes. This minimum is achieved with the block size $B = 8192$ bytes. Therefore, the optimal block size is $B^{\\star} = 8192$ bytes.\n\n**Final Calculation**\n\nThe problem asks for the maximum single-indirect coverage, $k(B^{\\star}) \\cdot B^{\\star}$, corresponding to the optimal block size $B^{\\star}$. We have already computed this value for $B=8192$.\n$$k(B^{\\star}) \\cdot B^{\\star} = k(8192) \\cdot 8192 = 1024 \\cdot 8192 = 8388608$$\nThis value represents the maximum file size that can be supported by a single index block when the block size is $B^{\\star}$.",
            "answer": "$$\\boxed{8388608}$$"
        },
        {
            "introduction": "No file system design exists in a vacuum; its performance must be weighed against alternatives. This exercise compares the metadata space overhead of indexed allocation with that of a popular alternative, extent-based allocation. By analyzing the systems in an asymptotic regime for very large files, you will derive the 'break-even' point where one method becomes more space-efficient than the other, providing deep insight into their respective architectural trade-offs. ",
            "id": "3649420",
            "problem": "A file system stores file block addresses in an index node (inode). Each inode may store up to $a$ direct data block addresses, followed by up to one single-indirect pointer and up to one double-indirect pointer. The storage unit is a fixed-size data block of size $B$ bytes, and each on-disk pointer occupies $p$ bytes, with $p$ dividing $B$. An indirect block is a block that contains only pointers; thus, a single indirect block can store exactly $k = B/p$ pointers to data blocks, and a double-indirect pointer references a second-level block of $k$ pointers to first-level indirect blocks, each of which in turn contains $k$ pointers to data blocks, for a total capacity of $k^{2}$ data blocks when fully utilized.\n\nDefine the metadata space overhead for a file of size $S$ (in bytes) as the total on-disk bytes not carrying file data but required to locate it, counting:\n- the bytes consumed by the pointer fields used inside the inode,\n- the full $B$ bytes of each allocated indirect block at any level.\n\nIgnore any fixed per-file headers other than the pointer fields actually used in the inode, ignore any internal headers inside indirect blocks, and treat any partially filled indirect blocks as occupying a full $B$ bytes.\n\nNow compare this indexed-pointers scheme to an extent-based scheme in which the file is represented as a list of contiguous runs (extents). Assume the average extent length is $\\ell$ data blocks, and that each extent descriptor consists of exactly two pointer-sized fields (one for the starting block address and one for the run length), totaling $2p$ bytes per extent. Treat the extent descriptors as packed without padding and ignore any additional per-file headers beyond the extent descriptors themselves.\n\nIn the asymptotic regime of very large files where the contribution of the first $a$ direct pointers and the single-indirect tier is negligible on a per-data-block basis, derive the break-even average extent length $\\ell^{\\star}$ at which the asymptotic metadata overhead per data block of the indexed-pointers scheme equals that of the extent-based scheme. Express your final answer as a single closed-form symbolic expression in terms of $B$ and $p$ only (you may use $k = B/p$). No numerical evaluation is required. The final answer must be a single analytic expression.",
            "solution": "The problem is well-posed, scientifically grounded, and provides sufficient information to derive the requested quantity. It is a standard theoretical problem in the study of file systems. I will proceed with the solution.\n\nThe objective is to find the break-even average extent length, denoted as $\\ell^{\\star}$, at which the asymptotic metadata overhead per data block of an indexed-pointer allocation scheme equals that of an extent-based scheme.\n\nLet us first analyze the asymptotic metadata overhead for the indexed-pointers scheme. The problem specifies that for very large files, the contribution of the first $a$ direct pointers and the single-indirect tier becomes negligible on a per-data-block basis. This implies we only need to consider the overhead associated with the double-indirect pointer, as it addresses the vast majority of blocks in a very large file.\n\nIn this scheme, a double-indirect pointer in the inode points to a second-level (L2) indirect block. This L2 block contains $k = B/p$ pointers, each pointing to a first-level (L1) indirect block. Each L1 block, in turn, contains $k$ pointers to data blocks. Therefore, one fully utilized double-indirect structure supports $k \\times k = k^2$ data blocks.\n\nAccording to the problem's definition of metadata overhead, we must count the full size ($B$ bytes) of each allocated indirect block. To address $k^2$ data blocks via the double-indirect pointer, we require:\n$1$. One L2 indirect block, occupying $B$ bytes.\n$2$. $k$ L1 indirect blocks, occupying a total of $k \\times B$ bytes.\n\nThe total metadata overhead, $M_{idx}$, for these $k^2$ data blocks is the sum of the space occupied by these indirect blocks:\n$$M_{idx} = B + k B = B(1+k)$$\nThe number of data blocks, $N_{data}$, addressed by this metadata is $k^2$. The asymptotic metadata overhead per data block, $O_{idx}$, is therefore the ratio of this metadata cost to the number of data blocks it supports.\n$$O_{idx} = \\frac{M_{idx}}{N_{data}} = \\frac{B(1+k)}{k^2}$$\nThe problem states that the pointers inside the inode also contribute to overhead. For a file large enough to use the double-indirect pointer, the inode will have used $a$ direct pointers, $1$ single-indirect pointer, and $1$ double-indirect pointer. This is a fixed cost. When calculating the overhead *per data block* in the asymptotic limit of an infinitely large file, this fixed cost is divided by an infinite number of blocks, and its contribution tends to zero. Thus, it is correctly neglected in the asymptotic analysis, consistent with the problem statement.\n\nNext, let us analyze the metadata overhead for the extent-based scheme. A file is represented as a list of extents, where the average extent length is $\\ell$ data blocks. Each extent is described by a descriptor of size $2p$ bytes.\nFor a large file consisting of $N$ data blocks, the number of extents, $N_{extents}$, can be approximated as:\n$$N_{extents} \\approx \\frac{N}{\\ell}$$\nThe total metadata overhead, $M_{ext}$, is the total size of all extent descriptors:\n$$M_{ext} \\approx N_{extents} \\times 2p = \\frac{N}{\\ell} \\times 2p$$\nThe asymptotic metadata overhead per data block, $O_{ext}$, is the total metadata cost divided by the number of data blocks:\n$$O_{ext} = \\frac{M_{ext}}{N} = \\frac{(N/\\ell) \\times 2p}{N} = \\frac{2p}{\\ell}$$\nThe break-even average extent length, $\\ell^{\\star}$, is found by setting the two overheads equal to each other: $O_{idx} = O_{ext}$ when $\\ell = \\ell^{\\star}$.\n$$\\frac{B(1+k)}{k^2} = \\frac{2p}{\\ell^{\\star}}$$\nWe now solve for $\\ell^{\\star}$:\n$$\\ell^{\\star} = \\frac{2p \\cdot k^2}{B(1+k)}$$\nThe problem requires the final answer to be expressed in terms of $B$ and $p$ only. We substitute the definition $k = B/p$ into the expression for $\\ell^{\\star}$:\n$$\\ell^{\\star} = \\frac{2p \\left(\\frac{B}{p}\\right)^2}{B\\left(1+\\frac{B}{p}\\right)}$$\nSimplifying the numerator and denominator:\n$$\\ell^{\\star} = \\frac{2p \\left(\\frac{B^2}{p^2}\\right)}{B\\left(\\frac{p+B}{p}\\right)} = \\frac{\\frac{2B^2}{p}}{\\frac{B(p+B)}{p}}$$\nThe factor of $p$ in the denominator of both the numerator and the denominator cancels out:\n$$\\ell^{\\star} = \\frac{2B^2}{B(p+B)}$$\nFinally, we cancel a factor of $B$ from the numerator and denominator to obtain the final closed-form expression:\n$$\\ell^{\\star} = \\frac{2B}{p+B} = \\frac{2B}{B+p}$$\nThis is the break-even average extent length, measured in units of data blocks.",
            "answer": "$$\\boxed{\\frac{2B}{B+p}}$$"
        }
    ]
}