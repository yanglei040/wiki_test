{
    "hands_on_practices": [
        {
            "introduction": "文件系统的完整性始于最基本的层面：跟踪哪些块是空闲的，哪些块正在被使用。本练习模拟了一项核心的 `fsck` 任务，你将在此任务中校对一个详细的、逐块的空闲空间位图与一个粒度较粗的摘要计数器。通过实现这一检查，你将获得处理文件系统如何检测和修复其分配元数据不一致问题的实践经验，这也是系统崩溃后常见的问题。 ",
            "id": "3643422",
            "problem": "给定一个简化的基于块的文件系统模型，该模型被划分为多个块组。每个块组 $g$ 拥有总共 $B_g$ 个块，其中前 $R_g$ 个块为元数据保留，绝不能计为空闲块。文件系统为每个块组维护一个空闲空间位图，其中位值为 $1$ 表示空闲块，位值为 $0$ 表示已分配块。该位图覆盖了组中所有的 $B_g$ 个块。文件系统还为每个组存储一个摘要计数器 $S_g$，该计数器应当等于该组中空闲数据块的数量。文件系统范围的摘要是所有组计数器的总和。\n\n此处与文件系统一致性检查相关的基本不变量如下：\n- 空闲空间位图是关于哪些块当前是空闲的权威性逐块记录。根据定义，组 $g$ 的真实空闲计数等于非保留位置（即索引 $i$ 满足 $R_g \\le i \\lt B_g$ 的位置）中值为 $1$ 的位数。\n- 保留块不可用于文件数据，因此无论其位图值如何，都必须将其视为已分配。在正确的位图中，保留位的位值为 $0$，但一个健壮的协调过程绝不能将任何保留位置计为空闲。\n- 组摘要 $S_g$ 应等于从位图推导出的空闲数据块计数。文件系统范围的空闲块摘要应为总和 $\\sum_{g=0}^{G-1} S_g$，其中 $G$ 是组的数量。\n\n设计一个类似于文件系统检查器的协调过程，该过程执行以下操作：\n1. 对于每个组 $g$，通过计算位图中索引 $i$ 满足 $R_g \\le i \\lt B_g$ 的位置上 $1$ 的位数，重新计算校正后的空闲块计数 $C_g$，并忽略前 $R_g$ 个位（视为保留位）。\n2. 将 $C_g$ 与存储的 $S_g$ 进行比较，如果 $C_g \\ne S_g$，则将该组标记为不一致。\n3. 计算校正后的文件系统范围的总空闲块数 $T = \\sum_{g=0}^{G-1} C_g$。\n4. 针对每个测试用例，报告列表 $\\left[C_0, C_1, \\dots, C_{G-1}, T, K\\right]$，其中 $K$ 是满足 $C_g \\ne S_g$ 的组的数量。\n\n实现一个完整的、可运行的程序，该程序硬编码以下测试套件并计算协调结果：\n\n测试用例 1：\n- $G = 3$\n- 组 0：$B_0 = 16$， $R_0 = 2$，位图字符串为长度16的序列 \"0010110010011001\"，存储的摘要 $S_0 = 5$。\n- 组 1：$B_1 = 8$， $R_1 = 1$，位图字符串为长度8的序列 \"01001001\"，存储的摘要 $S_1 = 6$。\n- 组 2：$B_2 = 10$， $R_2 = 0$，位图字符串为长度10的序列 \"1100000000\"，存储的摘要 $S_2 = 4$。\n\n测试用例 2：\n- $G = 2$\n- 组 0：$B_0 = 5$， $R_0 = 5$，位图字符串为长度5的序列 \"00000\"，存储的摘要 $S_0 = 2$。\n- 组 1：$B_1 = 5$， $R_1 = 0$，位图字符串为长度5的序列 \"10101\"，存储的摘要 $S_1 = 3$。\n\n测试用例 3：\n- $G = 3$\n- 组 0：$B_0 = 4$，$R_0 = 0$，位图字符串为长度4的序列 \"1111\"，存储的摘要 $S_0 = 0$。\n- 组 1：$B_1 = 4$，$R_1 = 2$，位图字符串为长度4的序列 \"0001\"，存储的摘要 $S_1 = 2$。\n- 组 2：$B_2 = 1$，$R_2 = 0$，位图字符串为长度1的序列 \"0\"，存储的摘要 $S_2 = 0$。\n\n您的程序必须：\n- 完全按照规定使用这些硬编码输入。\n- 无论位图中的位值如何，都将任何满足 $0 \\le i \\lt R_g$ 的保留位置 $i$ 视为非空闲。\n- 对于每个测试用例，计算每个组的 $C_g$、总数 $T$ 以及不一致组的数量 $K$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的列表组成的逗号分隔列表，每个列表对应一个测试用例，并按上述顺序排列。具体来说，输出必须采用以下格式：\n  - $\\left[\\left[C_0^{(1)}, C_1^{(1)}, \\dots, C_{G^{(1)}-1}^{(1)}, T^{(1)}, K^{(1)}\\right], \\left[C_0^{(2)}, \\dots, T^{(2)}, K^{(2)}\\right], \\left[C_0^{(3)}, \\dots, T^{(3)}, K^{(3)}\\right]\\right]$\n  其中上标 $(j)$ 表示测试用例 $j$。\n- 元素 $C_g$、$T$ 和 $K$ 均为整数。\n- 除该单行方括号列表外，不得有任何额外的文本或空白字符。",
            "solution": "问题陈述提供了一个简化的基于块的文件系统模型，并要求实现一个类似于文件系统检查器的协调过程，以验证和校正其空闲块的记账。该问题在科学上基于操作系统和文件系统设计的原理，提法恰当，包含了所有必要的数据和明确的目标，并以客观、正式的语言表述。因此，它被认为是一个有效的问题。\n\n任务的核心是根据每个组的位图重新计算其空闲块的数量，将此校正后的计数与存储的摘要进行比较，并汇总结果。该过程由一套精确的规则指定。设 $G$ 为文件系统中的块组数量。对于每个组 $g$（其中 $g$ 的范围从 $0$ 到 $G-1$），我们给定以下信息：\n- $B_g$：组中的总块数。\n- $R_g$：为元数据保留的初始块数。\n- 一个长度为 $B_g$ 的位图字符串，其中‘1’位表示空闲块，‘0’位表示已分配块。\n- $S_g$：一个声称是该组中空闲数据块数量的存储摘要值。\n\n协调过程涉及为每个测试用例计算三个量：一个校正后的每组空闲块计数的向量 $[C_0, C_1, \\dots]$，一个校正后的文件系统范围的总空闲块计数 $T$，以及一个不一致组的计数 $K$。\n\n步骤 1：计算校正后的空闲块计数 $C_g$\n基本不变量是位图是块分配状态的最终事实来源。然而，一个关键约束是，无论位图中对应的位值如何，保留块都绝不能计为空闲。保留块占据索引 $i$ 满足 $0 \\le i  R_g$ 的位置。因此，组 $g$ 中可用于数据存储的块池由索引 $i$ 满足 $R_g \\le i  B_g$ 的块组成。\n\n组 $g$ 的校正后空闲块计数（表示为 $C_g$）是通过遍历该组位图的非保留部分并对值为 $1$ 的位相加来确定的。形式上，这表示为：\n$$ C_g = \\sum_{i=R_g}^{B_g - 1} \\mathbf{1}(\\text{bitmap}_g[i] = \\text{'1'}) $$\n其中 $\\mathbf{1}(\\cdot)$ 是指示函数，如果其参数为真，则值为 $1$，否则为 $0$。用于此计算的循环从第一个非保留块索引 $R_g$ 开始，直到总块数 $B_g$（但不包括 $B_g$）。\n\n步骤 2：识别不一致的组并计算 $K$\n如果一个组 $g$ 的存储摘要计数器 $S_g$ 与新计算的权威计数 $C_g$ 不匹配，则该组被标记为不一致。不一致组的总数 $K$ 是满足此条件的所有组的数量。\n$$ K = \\sum_{g=0}^{G-1} \\mathbf{1}(C_g \\neq S_g) $$\n此步骤通过将计算出的 $C_g$ 与为每个组提供的 $S_g$ 进行比较，并为每个检测到的差异递增一个计数器来执行。\n\n步骤 3：计算校正后的文件系统范围总数 $T$\n校正后的文件系统范围的总空闲块数 $T$ 就是所有组的校正后空闲块计数的总和。\n$$ T = \\sum_{g=0}^{G-1} C_g $$\n该值表示协调后整个文件系统中空闲数据块的真实数量。\n\n计算示例（测试用例 1，组 0）：\n- 已知：$B_0 = 16$，$R_0 = 2$，位图 = \"0010110010011001\"，$S_0 = 5$。\n- 我们通过对位图中从索引 $i=2$ 到 $i=15$ 的‘1’进行求和来计算 $C_0$。\n- 需要检查的子字符串是 `10110010011001`。\n- 计算‘1’的个数：位于索引 $2, 4, 5, 8, 11, 12, 15$。共有 $7$ 个‘1’。\n- 因此，校正后的计数为 $C_0 = 7$。\n- 我们将 $C_0$ 与 $S_0$进行比较。由于 $C_0 = 7$ 且 $S_0 = 5$，我们得到 $C_0 \\neq S_0$。此组不一致。\n\n此过程被系统地应用于所有测试用例中的所有组，以生成所需的输出向量。每个测试用例的最终报告是一个有序列表，包含每组的校正后计数、校正后的总计数以及不一致组的数量：$[C_0, C_1, \\dots, C_{G-1}, T, K]$。",
            "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n#include\n```"
        },
        {
            "introduction": "在验证了块分配的正确性后，我们将注意力转向单个文件。本练习将挑战你验证文件元数据的内部一致性，特别是通过比较其记录的大小与由其范围 (extents) 定义的实际数据覆盖范围。你将开发一个程序来识别差异，例如在记录的文件末尾之外存在已初始化的数据，并提出非破坏性的修复方案，从而加深在一致性检查中数据保全的原则。 ",
            "id": "3643409",
            "problem": "您将获得一个文件系统的简化模型，该系统将文件存储为一组逻辑区段。每个文件都有一个记录大小和一系列区段，其中每个区段将一个连续的逻辑块范围映射到已初始化（已写入）的数据或未写入的预分配空间。您的任务是构建一个一致性检查器，该检查器将记录的文件大小与已初始化区段所隐含的大小进行交叉验证，检测区段之间的逻辑重叠，并提出避免截断任何已初始化数据的非破坏性修复操作。\n\n基本依据与定义：\n\n- 文件由以下部分描述：\n  - 块大小 $B$（以字节为单位）。\n  - 记录大小 $S$（以字节为单位）。\n  - 一个区段列表 $\\{(l_i, n_i, w_i)\\}_{i=1}^N$，其中：\n    - $l_i$ 是逻辑起始块索引（一个满足 $l_i \\ge 0$ 的整数）。\n    - $n_i$ 是区段中的块数量（一个满足 $n_i \\ge 0$ 的整数）。\n    - $w_i \\in \\{0,1\\}$ 指示区段是已初始化 ($1$) 还是未写入的预分配空间 ($0$)。\n\n- 每个区段 $i$ 覆盖逻辑块区间 $I_i = [l_i, l_i + n_i)$（以块为单位）。如果 $\\max(l_i, l_j)  \\min(l_i + n_i, l_j + n_j)$，则两个区段 $i$ 和 $j$ 在逻辑空间中重叠。\n\n- 最大已分配逻辑字节末端是\n  $$M_{\\text{alloc}} = \\max_{1 \\le i \\le N} (l_i + n_i) \\cdot B,$$\n  其中空集的最大值定义为 $0$。\n\n- 最大已初始化逻辑字节末端是\n  $$M_{\\text{init}} = \\max_{1 \\le i \\le N, \\, w_i = 1} (l_i + n_i) \\cdot B,$$\n  其中空集的最大值定义为 $0$。\n\n- 表示记录大小所需块数的向上取整是\n  $$Q = \\left\\lceil \\frac{S}{B} \\right\\rceil.$$\n\n一致性解释和避免截断已初始化数据的非破坏性修复建议：\n\n- 如果 $S  M_{\\text{init}}$，则表示某些已初始化的数据位于记录的文件末尾之后。一种非破坏性的修正是将记录大小增加到\n  $$S_{\\text{rec}} = M_{\\text{init}}.$$\n\n- 否则，保持记录大小不变：\n  $$S_{\\text{rec}} = S.$$\n\n- 超出文件末尾的未写入预分配空间可以在不冒数据丢失风险的情况下安全移除。定义要从文件末尾之后丢弃的未写入块的总数为\n  $$C = \\sum_{i: w_i = 0} \\max\\left(0,\\,(l_i + n_i) - Q\\right).$$\n  这只计算起始索引至少为 $Q$ 的完整块；与 $l_i  Q$ 的部分重叠的未写入块保持不变。\n\n- 计算重叠区段对的数量\n  $$O = \\#\\left\\{(i,j) \\mid 1 \\le i  j \\le N,\\; \\max(l_i, l_j)  \\min(l_i + n_i, l_j + n_j)\\right\\}.$$\n\n- 定义一个风险指示器\n  $$R = \\begin{cases}\n  1  \\text{如果存在重叠对且 } w_i = 1 \\text{ 和 } w_j = 1,\\\\\n  0  \\text{否则。}\n  \\end{cases}$$\n  这表示已初始化区段之间存在重叠，可能由于潜在的数据冲突而需要手动解决。\n\n程序要求：\n\n- 对于每个测试用例，计算元组 $\\left(O, S_{\\text{rec}}, C, R\\right)$，所有四个值均为整数。\n\n- 您的程序必须处理以下包含七个用例的测试套件。对于每个用例，都提供了块大小 $B$、记录大小 $S$ 和区段列表。每个区段都按上述顺序以三元组 $(l_i, n_i, w_i)$ 的形式给出。\n\n  - 测试用例 1：\n    - $B = 4096$, $S = 12288$。\n    - 区段：$(0, 3, 1)$。\n  - 测试用例 2：\n    - $B = 4096$, $S = 20480$。\n    - 区段：$(0, 2, 1)$。\n  - 测试用例 3：\n    - $B = 4096$, $S = 8192$。\n    - 区段：$(0, 3, 1)$。\n  - 测试用例 4：\n    - $B = 4096$, $S = 4096$。\n    - 区段：$(0, 1, 1)$, $(1, 4, 0)$。\n  - 测试用例 5：\n    - $B = 4096$, $S = 12288$。\n    - 区段：$(0, 3, 1)$, $(2, 2, 1)$。\n  - 测试用例 6：\n    - $B = 4096$, $S = 0$。\n    - 区段：无（空列表）。\n  - 测试用例 7：\n    - $B = 4096$, $S = 4500$。\n    - 区段：$(0, 1, 1)$, $(1, 1, 0)$。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例的结果本身也是一个按 $\\left[O,S_{\\text{rec}},C,R\\right]$ 顺序排列的方括号列表。不要使用空格。例如，两个用例的输出可能看起来像 “$[[1,100,0,0],[0,80,2,1]]$”。对于给定的七个测试用例，请准确输出一行，按顺序汇总所有七个结果列表。",
            "solution": "该问题提供了一个文件系统中文件表示的简化模型，并要求实现一个一致性检查器，以计算四个指标：重叠区段的数量 ($O$)、建议的非破坏性文件大小 ($S_{\\text{rec}}$)、可回收的未写入块的数量 ($C$)，以及已初始化数据重叠的风险指示器 ($R$)。该问题定义明确，以操作系统原理为科学基础，并提供了所有必要的公式和数据。因此，它被认为是一个有效的问题。\n\n我们将对提供的七个测试用例逐一应用给定的定义和公式。\n\n对于任何给定的文件，我们有：\n- 块大小 $B$\n- 记录大小 $S$\n- N个区段的列表 $\\{(l_i, n_i, w_i)\\}_{i=1}^N$\n\n派生量如下：\n- 记录大小所需块数的向上取整：$Q = \\left\\lceil \\frac{S}{B} \\right\\rceil$。对于非负 $S$ 和正 $B$ 的整数算术，这可计算为 $(S + B - 1) / B$。\n- 最大已初始化逻辑字节末端：$M_{\\text{init}} = \\max_{i: w_i = 1} (l_i + n_i) \\cdot B$。\n- 建议大小：$S_{\\text{rec}} = \\max(S, M_{\\text{init}})$。\n- 重叠计数：$O = \\#\\left\\{(i,j) \\mid 1 \\le i  j \\le N,\\; \\max(l_i, l_j)  \\min(l_i + n_i, l_j + n_j)\\right\\}$。\n- 可丢弃的未写入块计数：$C = \\sum_{i: w_i = 0} \\max\\left(0,\\,(l_i + n_i) - Q\\right)$。\n- 风险指示器：如果存在重叠对 $(i,j)$ 且 $w_i=1$ 和 $w_j=1$，则 $R=1$；否则 $R=0$。\n\n我们现在分析每个用例。\n\n**测试用例 1：**\n- 给定：$B = 4096$, $S = 12288$, 区段: $\\{(0, 3, 1)\\}$.\n- $N=1$。单个区段为 $l_1=0$, $n_1=3$, $w_1=1$。\n- $Q = \\lceil 12288 / 4096 \\rceil = \\lceil 3 \\rceil = 3$。\n- $M_{\\text{init}} = (l_1 + n_1) \\cdot B = (0 + 3) \\cdot 4096 = 12288$。\n- $S = 12288$, $M_{\\text{init}} = 12288$。由于 $S \\ge M_{\\text{init}}$，因此 $S_{\\text{rec}} = S = 12288$。\n- $C$: 没有未写入的区段 ($w_i=0$)。总和是基于空集的，所以 $C = 0$。\n- $O, R$: 只有一个区段，没有可检查的对。$O=0, R=0$。\n- 结果：$(0, 12288, 0, 0)$。\n\n**测试用例 2：**\n- 给定：$B = 4096$, $S = 20480$, 区段: $\\{(0, 2, 1)\\}$.\n- $N=1$。单个区段为 $l_1=0$, $n_1=2$, $w_1=1$。\n- $Q = \\lceil 20480 / 4096 \\rceil = \\lceil 5 \\rceil = 5$。\n- $M_{\\text{init}} = (l_1 + n_1) \\cdot B = (0 + 2) \\cdot 4096 = 8192$。\n- $S = 20480$, $M_{\\text{init}} = 8192$。由于 $S \\ge M_{\\text{init}}$，因此 $S_{\\text{rec}} = S = 20480$。\n- $C$: 没有未写入的区段。$C = 0$。\n- $O, R$: 没有区段对。$O=0, R=0$。\n- 结果：$(0, 20480, 0, 0)$。\n\n**测试用例 3：**\n- 给定：$B = 4096$, $S = 8192$, 区段: $\\{(0, 3, 1)\\}$.\n- $N=1$。单个区段为 $l_1=0$, $n_1=3$, $w_1=1$。\n- $Q = \\lceil 8192 / 4096 \\rceil = \\lceil 2 \\rceil = 2$。\n- $M_{\\text{init}} = (l_1 + n_1) \\cdot B = (0 + 3) \\cdot 4096 = 12288$。\n- $S = 8192$, $M_{\\text{init}} = 12288$。由于 $S  M_{\\text{init}}$，因此 $S_{\\text{rec}} = M_{\\text{init}} = 12288$。\n- $C$: 没有未写入的区段。$C = 0$。\n- $O, R$: 没有区段对。$O=0, R=0$。\n- 结果：$(0, 12288, 0, 0)$。\n\n**测试用例 4：**\n- 给定：$B = 4096$, $S = 4096$, 区段: $e_1=(0, 1, 1)$, $e_2=(1, 4, 0)$。\n- $N=2$。$l_1=0, n_1=1, w_1=1$; $l_2=1, n_2=4, w_2=0$。\n- $Q = \\lceil 4096 / 4096 \\rceil = \\lceil 1 \\rceil = 1$。\n- $M_{\\text{init}}$: 只有 $e_1$ 是已初始化的。$M_{\\text{init}} = (l_1 + n_1) \\cdot B = (0 + 1) \\cdot 4096 = 4096$。\n- $S = 4096$, $M_{\\text{init}} = 4096$。由于 $S \\ge M_{\\text{init}}$，因此 $S_{\\text{rec}} = S = 4096$。\n- $C$: 只有 $e_2$ 是未写入的。$C = \\max(0, (l_2+n_2) - Q) = \\max(0, (1+4) - 1) = 4$。\n- $O, R$: 检查对 $(e_1, e_2)$。区间为 $I_1 = [0, 1)$ 和 $I_2 = [1, 5)$。重叠需要 $\\max(l_1, l_2)  \\min(l_1+n_1, l_2+n_2)$。这里，$\\max(0, 1) = 1$ 且 $\\min(1, 5) = 1$。条件 $1  1$ 为假。无重叠。$O=0, R=0$。\n- 结果：$(0, 4096, 4, 0)$。\n\n**测试用例 5：**\n- 给定：$B = 4096$, $S = 12288$, 区段: $e_1=(0, 3, 1)$, $e_2=(2, 2, 1)$。\n- $N=2$。$l_1=0, n_1=3, w_1=1$; $l_2=2, n_2=2, w_2=1$。\n- $Q = \\lceil 12288 / 4096 \\rceil = \\lceil 3 \\rceil = 3$。\n- $M_{\\text{init}}$: 两个区段都已初始化。末端字节分别为 $(0+3) \\cdot 4096 = 12288$ 和 $(2+2) \\cdot 4096 = 16384$。$M_{\\text{init}} = \\max(12288, 16384) = 16384$。\n- $S = 12288$, $M_{\\text{init}} = 16384$。由于 $S  M_{\\text{init}}$，因此 $S_{\\text{rec}} = M_{\\text{init}} = 16384$。\n- $C$: 没有未写入的区段。$C = 0$。\n- $O, R$: 检查对 $(e_1, e_2)$。区间为 $I_1 = [0, 3)$ 和 $I_2 = [2, 4)$。重叠需要 $\\max(l_1, l_2)  \\min(l_1+n_1, l_2+n_2)$。这里，$\\max(0, 2) = 2$ 且 $\\min(3, 4) = 3$。条件 $2  3$ 为真。存在重叠。$O=1$。\n- 由于重叠对的 $w_1=1$ 和 $w_2=1$，风险指示器 $R=1$。\n- 结果：$(1, 16384, 0, 1)$。\n\n**测试用例 6：**\n- 给定：$B = 4096$, $S = 0$, 区段: 无。\n- $N=0$。\n- $Q = \\lceil 0 / 4096 \\rceil = \\lceil 0 \\rceil = 0$。\n- $M_{\\text{init}}$: 已初始化区段的集合为空。根据定义，$M_{\\text{init}} = 0$。\n- $S=0$, $M_{\\text{init}}=0$。由于 $S \\ge M_{\\text{init}}$，因此 $S_{\\text{rec}} = S = 0$。\n- $C$: 未写入区段的集合为空。$C=0$。\n- $O, R$: 没有区段，因此没有对。$O=0, R=0$。\n- 结果：$(0, 0, 0, 0)$。\n\n**测试用例 7：**\n- 给定：$B = 4096$, $S = 4500$, 区段: $e_1=(0, 1, 1)$, $e_2=(1, 1, 0)$。\n- $N=2$。$l_1=0, n_1=1, w_1=1$; $l_2=1, n_2=1, w_2=0$。\n- $Q = \\lceil 4500 / 4096 \\rceil = \\lceil 1.0986... \\rceil = 2$。\n- $M_{\\text{init}}$: 只有 $e_1$ 是已初始化的。$M_{\\text{init}} = (l_1 + n_1) \\cdot B = (0 + 1) \\cdot 4096 = 4096$。\n- $S = 4500$, $M_{\\text{init}} = 4096$。由于 $S \\ge M_{\\text{init}}$，因此 $S_{\\text{rec}} = S = 4500$。\n- $C$: 只有 $e_2$ 是未写入的。$C = \\max(0, (l_2+n_2) - Q) = \\max(0, (1+1) - 2) = 0$。\n- $O, R$: 检查对 $(e_1, e_2)$。区间为 $I_1=[0, 1)$ 和 $I_2=[1, 2)$。重叠需要 $\\max(l_1, l_2)  \\min(l_1+n_1, l_2+n_2)$。这里，$\\max(0, 1) = 1$ 且 $\\min(1, 2) = 1$。条件 $1  1$ 为假。无重叠。$O=0, R=0$。\n- 结果：$(0, 4500, 0, 0)$。",
            "answer": "```c\n#include\n```"
        },
        {
            "introduction": "文件系统一致性的最后一个也是最复杂的层面是目录层次结构，它将所有文件和目录组织成一个连贯的结构。在这个高级练习中，你将实现一个算法，从头开始重建和验证这个结构，而不依赖于可能已损坏的 `.` 和 `..` 条目。这个任务要求你将文件系统视为一个图，解决如多父节点之类的结构异常，并验证链接计数，从而让你深入理解 `fsck` 是如何恢复文件系统全局完整性的。 ",
            "id": "3643427",
            "problem": "您将获得一个分层文件系统的抽象模型，旨在捕获文件系统一致性检查 (FSCK) 所使用的基本约束。每个实体由一个唯一的 inode 标识符表示。inode 有两种类型：目录和普通文件。目录内容被指定为名称到 inode 的映射（目录条目）。在此模型中，名为“.”和“..”的条目可能已损坏，因此不能用于确定父子关系。目标是设计并实现一种算法，仅使用非“.”和非“..”的条目、唯一的 inode 标识符和链接计数证据来重建父子链接。\n\n基本定义和事实：\n- 一个 inode 由一个唯一的整数标识符 $i \\in \\mathbb{Z}$ 标识。\n- 每个 inode 的类型为 $\\{\\text{dir}, \\text{file}\\}$ 中的一种，并拥有一个元数据链接计数 $lc(i) \\in \\mathbb{Z}_{\\ge 0}$。\n- 对于每个目录 inode $d$，其条目列表是一个有限序列 $E(d) = [(n_1, i_1), (n_2, i_2), \\dots, (n_k, i_k)]$，其中每个 $n_j$ 是一个字符串名称，每个 $i_j$ 是一个目标 inode 标识符。\n- 经过充分检验的事实：\n  1. 对于一个普通文件 inode $f$，其链接计数等于引用它的目录条目数量：$lc(f) = \\left|\\{(n, f) \\mid (n, f) \\in \\bigcup_{d} E(d)\\}\\right|$。\n  2. 对于一个目录 inode $p$，其链接计数等于 $2$ 加上它直接包含的子目录数量：$lc(p) = 2 + \\left|\\{(n, c) \\mid (n, c) \\in E(p),\\ c\\ \\text{is a directory},\\ n \\notin \\{\\text{\".\"}, \\text{\"..\"}\\}\\right|$。其中的“$2$”代表每个子目录贡献的自链接“.”和反向链接“..”，这是传统类 Unix 文件系统的一个公认属性。\n\n任务：\n- 在重建父子关系和计算引用时，您必须忽略名为“.”和“..”的目录条目。\n- 通过将在目录 $d$ 中找到的每个非“.”和非“..”的目录条目 $(n, i)$ 解释为一条边 $d \\to i$ 来重建候选的父子关系。对于一个目录 inode $c$，其候选父节点集合为 $\\{d \\mid (n, c) \\in E(d),\\ n \\notin \\{\\text{\".\"}, \\text{\"..\"}\\}\\}$。\n- 通过选择唯一的、没有候选父节点的目录 inode 来确定根目录。如果有多个目录没有候选父节点，则选择标识符最小的那个作为根目录，并将每个额外的无父目录计为一处不一致。如果没有无父目录，则因“未找到根”而计为一处不一致。\n- 对于任何有多个候选父节点的目录，使用以下基于链接计数证据的平局打破规则来选择唯一一个父节点：对于子节点 $c$ 的每个候选父节点 $p$，计算 $m(p) = \\left|lc(p) - \\left(2 + \\text{outdeg}_{\\text{dir}}(p)\\right)\\right|$，其中 $\\text{outdeg}_{\\text{dir}}(p)$ 是从 $p$ 指向目录 inode 且使用非“.”和非“..”条目的出边数量。选择使 $m(p)$ 最小化的父节点 $p^*$，若存在平局则选择 inode 标识符最小的那个。将 $p^*$ 之外的每个额外父节点计为一处不一致。\n- 验证链接计数：\n  - 对于每个文件 inode $f$，计算来自所有目录的传入引用数（忽略“.”和“..”条目），记为 $r(f)$，如果 $r(f) \\ne lc(f)$，则计为一处不一致。\n  - 对于每个目录 inode $p$，计算 $2 + \\text{outdeg}_{\\text{dir}}(p)$，如果 $2 + \\text{outdeg}_{\\text{dir}}(p) \\ne lc(p)$，则计为一处不一致。\n\n您的程序必须计算下面指定的每个测试用例检测到的不一致性总数，结果为一个非负整数。最终输出必须是单行，包含一个用方括号括起来的、所有测试用例结果的逗号分隔列表。\n\n测试套件：\n- 测试用例 1 (通用，正常路径)：\n  - Inodes: 目录 $1$，$lc(1) = 3$；目录 $3$，$lc(3) = 2$；文件 $2$，$lc(2) = 2$。\n  - 目录条目：\n    - $E(1) = [(\\text{\".\"}, 1), (\\text{\"..\"}, 1), (\\text{\"etc\"}, 3), (\\text{\"readme\"}, 2)]$。\n    - $E(3) = [(\\text{\".\"}, 3), (\\text{\"..\"}, 1), (\\text{\"note\"}, 2)]$。\n- 测试用例 2 (“.”和“..”损坏但结构完整)：\n  - Inodes: 目录 $10$，$lc(10) = 3$；目录 $11$，$lc(11) = 2$。\n  - 目录条目：\n    - $E(10) = [(\\text{\".\"}, 999), (\\text{\"..\"}, 999), (\\text{\"child\"}, 11)]$。\n    - $E(11) = [(\\text{\".\"}, 111), (\\text{\"..\"}, 999)]$。\n- 测试用例 3 (孤儿目录，多余的根)：\n  - Inodes: 目录 $20$，$lc(20) = 3$；目录 $21$，$lc(21) = 2$；目录 $22$，$lc(22) = 2$。\n  - 目录条目：\n    - $E(20) = [(\\text{\"child\"}, 22)]$。\n    - $E(21) = [\\ ]$。\n    - $E(22) = [\\ ]$。\n- 测试用例 4 (目录被多个父节点引用)：\n  - Inodes: 目录 $30$，$lc(30) = 3$；目录 $31$，$lc(31) = 3$；目录 $32$，$lc(32) = 2$。\n  - 目录条目：\n    - $E(30) = [(\\text{\"A\"}, 32)]$。\n    - $E(31) = [(\\text{\"B\"}, 32)]$。\n    - $E(32) = [\\ ]$。\n- 测试用例 5 (文件和目录的链接计数不匹配)：\n  - Inodes: 目录 $40$，$lc(40) = 4$；文件 $41$，$lc(41) = 1$；目录 $42$，$lc(42) = 2$。\n  - 目录条目：\n    - $E(40) = [(\\text{\"file\"}, 41), (\\text{\"sub\"}, 42)]$。\n    - $E(42) = [(\\text{\"file\"}, 41)]$。\n- 测试用例 6 (单个空根目录)：\n  - Inodes: 目录 $50$，$lc(50) = 2$。\n  - 目录条目：\n    - $E(50) = [\\ ]$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，格式为逗号分隔的列表，并用方括号括起来，例如 $[\\text{result}_1,\\text{result}_2,\\dots]$。不得有任何额外的文本或换行。",
            "solution": "该问题要求设计并实现一种算法，用于验证一个简化的分层文件系统模型的一致性，这类似于文件系统一致性检查（FSCK）工具。该解决方案的架构是对文件系统结构进行系统性的、多遍的分析，该结构被视为一个有向图。在这个图中，inode 是顶点，目录条目构成边。对于给定的文件系统配置，其总不一致性分数是违反特定规则集的所有违规项的总和。\n\n该算法对每个测试用例按三个不同阶段进行：\n\n**阶段 1：图重建与属性聚合**\n初始阶段致力于构建文件系统有向图的内存表示，并计算其顶点（inode）的基本属性。我们遍历每个目录 inode $d$ 及其条目列表 $E(d)$。根据问题的约束，名称为 `“.”` 和 `“..”` 的条目被明确忽略，因为它们不定义主要的父子层次结构，并且可能不可靠。\n\n对于每个有效条目 $(n, i)$（其中 $n \\notin \\{\\text{\".\"}, \\text{\"..\"}\\}$），我们将其解释为从目录 inode $d$ 到目标 inode $i$ 的一条有向边。在遍历过程中，我们计算并存储三个关键属性：\n\n1.  **候选父节点：** 对于每个 inode $j$，我们编制一个列表，包含所有含有指向 $j$ 的条目的目录 inode $d$。这个集合 $\\{d \\mid (n, j) \\in E(d), n \\notin \\{\\text{\".\"}, \\text{\"..\"}\\}\\}$ 代表了 inode $j$ 的候选父节点集。\n2.  **引用计数 $r(i)$：** 对于每个 inode $i$，我们统计来自有效目录条目的入边总数。这个计算出的值 $r(i) = |\\{(n, i) \\mid (n, i) \\in \\bigcup_{d} E(d), n \\notin \\{\\text{\".\"}, \\text{\"..\"}\\}\\}|$ 是后验引用计数，将与 inode 存储的元数据链接计数 $lc(i)$ 进行核对。\n3.  **目录出度 $\\text{outdeg}_{\\text{dir}}(p)$：** 对于每个目录 inode $p$，我们计算其指向其他目录 inode 的出边数量。这个值 $\\text{outdeg}_{\\text{dir}}(p) = |\\{(n, c) \\mid (n, c) \\in E(p), c \\text{ is a directory}, n \\notin \\{\\text{\".\"}, \\text{\"..\"}\\}\\}|$ 对于验证目录链接计数规则至关重要。\n\n**阶段 2：结构验证**\n图结构建立后，第二阶段将根据层次结构的期望来验证其整体完整性。这涉及两个主要检查：\n\n1.  **根目录识别：** 一个结构良好的文件系统应该拥有一个单一的根，定义为入度为 $0$ 的目录（即没有候选父节点）。我们识别所有这样的目录。\n    - 如果没有目录没有候选父节点（例如，在存在目录循环的情况下），则因“未找到根”而计为一处不一致。\n    - 如果恰好有一个目录没有候选父节点，它将被正确识别为根，并且不记录不一致。\n    - 如果有多个目录（比如 $k > 1$）没有候选父节点，这表明存在碎片化或并行的层次结构。问题提供了一个平局打破规则：将 inode 标识符最小的目录指定为真正的根。其余的 $k-1$ 个目录被认为是“多余的根”，每个都会贡献一处不一致，总共 $k-1$ 处不一致。\n\n2.  **多父节点解决：** 严格的层次结构规定，每个非根目录必须有且仅有一个父节点。我们检查每个目录 inode $c$ 及其候选父节点集的大小。如果一个目录有 $N_{p} > 1$ 个候选父节点，则违反了此原则。问题陈述提供了一个确定性规则来选择一个规范父节点 $p^*$，确保总能做出选择。其余的 $N_{p}-1$ 个候选者被视为“多余的父节点”，每个都会贡献一处不一致。因此，一个有 $N_{p}$ 个父节点的目录会使总不一致计数增加 $N_{p}-1$。\n\n**阶段 3：链接计数验证**\n最后阶段验证在阶段 1 中推导出的文件系统结构与每个 inode 存储的元数据链接计数 $lc(i)$ 之间的一致性。\n\n1.  **文件链接计数：** 对于每个文件 inode $f$，其元数据链接计数 $lc(f)$ 必须等于计算出的引用计数 $r(f)$。若存在差异 $lc(f) \\neq r(f)$，则表明存在一处不一致，总计数加一。\n2.  **目录链接计数：** 对于每个目录 inode $p$，其链接计数由公式 $lc(p) = 2 + \\text{outdeg}_{\\text{dir}}(p)$ 决定。项 `2` 代表了一致文件系统中期盼的 `.` (自身) 和 `..` (父) 链接。我们将 inode 存储的 $lc(p)$ 与根据其结构属性 $\\text{outdeg}_{\\text{dir}}(p)$ 计算出的值进行比较。若不匹配，即 $lc(p) \\neq 2 + \\text{outdeg}_{\\text{dir}}(p)$，则表示存在一处不一致，计数器加一。\n\n在这三个阶段中检测到的所有不一致的总和构成了给定测试用例的最终整数结果，为文件系统偏离有效状态的程度提供了一个量化度量。",
            "answer": "```c\n#include\n```"
        }
    ]
}