{
    "hands_on_practices": [
        {
            "introduction": "文件系统的核心挑战之一是在元数据开销和数据存储容量之间取得平衡。本练习将探讨两种经典的磁盘元数据设计：固定索引节点（inode）表和动态索引节点分配。通过从第一性原理出发推导可创建文件的最大数量，你将深入理解这两种策略如何影响文件系统的根本限制，并学会量化它们之间的优劣 。",
            "id": "3642840",
            "problem": "一个存储栈在总大小为 $P$ 字节的单个分区内，于文件组织层实现了两种对比鲜明的磁盘元数据设计。这可以通过经典的分层结构来理解，其中逻辑文件层使用索引节点（inodes）来命名和定位文件数据，而目录层存储将名称绑定到索引节点标识符的目录条目。请思考以下两种设计。\n\n固定索引节点设计。文件系统（FS）预先分配一个大小为 $I$ 字节的磁盘索引节点表。每个索引节点（inode）占用 $i_s$ 字节。其中有 $r$ 个索引节点因被系统对象和根目录保留而永久对用户不可用；剩余的索引节点（若有）可用于用户创建的普通文件。非索引节点的固定开销（例如，超级块、日志结构和分配位图），不包括索引节点表本身，占用 $F_f$ 字节，且不随用户文件数量的增加而增加。每个用户创建的普通文件都必须出现在一个目录中；目录层为每个文件存储恰好 $d$ 字节作为该文件的目录条目负载，这些目录字节与普通文件内容存储在同一个通用数据区域中。您可以假设，为了最大化不同文件的数量，所创建的文件大小均为 $0$ 字节，以便除了目录条目之外不消耗任何数据块，并且根目录和其他系统对象已计入 $r$ 个保留索引节点和 $F_f$ 字节的开销中。\n\n动态索引节点设计。文件系统不预先分配固定大小的索引节点表。相反，索引节点是根据需要从通用空闲空间区域中划分出来的。每个用户创建的索引节点仍然存储 $i_s$ 字节的索引节点状态，此外还会产生一个与用户索引节点数量线性相关的 $a$ 字节的摊销分配记账成本。此设计的非索引节点固定开销（包括任何预先创建的系统对象，如根目录及其元数据）占用 $F_d$ 字节，且不随用户文件数量的增加而增加。每个文件的目录条目成本仍为 $d$ 字节，存储在同一个通用空闲空间区域中。同上，假设所有用户文件的大小均为 $0$ 字节。\n\n从文件层和目录层的基本原理出发，并且不使用任何现成的公式，推导出在每种设计下可以创建的不同用户普通文件数量的最紧可能上限。然后，定义乘法改进因子 $\\gamma$ 为动态索引节点上限与固定索引节点上限的比率，仅使用代数运算符以及根据需要捕获离散性和共享空间耦合的标准向下取整和最小运算符。将您的最终答案表示为关于 $\\gamma$ 的单个封闭形式解析表达式，用 $P$、$I$、$i_s$、$r$、$F_f$、$F_d$、$a$ 和 $d$ 表示。在您的最终表达式中不要注明单位。假设参数使得所有使用的分母非零且界限为正。",
            "solution": "该问题要求推导两种不同磁盘元数据设计下用户可创建文件数量的最紧可能上限，然后计算这些上限的比率。让我们从基本原理出发，分析每一种设计。设 $N$ 表示不同用户普通文件的数量。分析假设创建的文件大小为 $0$ 字节，以通过最小化数据块消耗来最大化文件数量，从而将分析重点放在元数据开销上。\n\n首先，我们分析 **固定索引节点设计**。\n在这种设计中，两个主要资源限制了文件数量：预分配的有限索引节点数量和用于目录条目的有限空间量。最大文件数，我们称之为 $N_{fixed}$，将是这两个约束所施加的界限中的最小值。\n\n1.  **索引节点约束**：预分配的索引节点表总大小为 $I$ 字节，每个索引节点占用 $i_s$ 字节。该表中可存储的索引节点总数是这些大小之比的整数部分，即 $\\lfloor \\frac{I}{i_s} \\rfloor$。问题陈述 $r$ 个索引节点被保留用于系统。因此，可用于用户文件的最大索引节点数是总索引节点数减去保留数。这对 $N_{fixed}$ 施加了一个上限：\n    $$ N_{fixed} \\le \\left\\lfloor \\frac{I}{i_s} \\right\\rfloor - r $$\n\n2.  **空间约束**：分区总大小为 $P$ 字节。固定开销所消耗的空间包括索引节点表本身（$I$ 字节）和其他非索引节点结构（$F_f$ 字节）。剩余空间构成通用数据区域，可用于存储文件内容和目录条目。该区域的大小为 $P - I - F_f$。根据模型，$N_{fixed}$ 个用户文件中的每一个都需要 $d$ 字节用于其目录条目，这些条目存储在此数据区域中。由于我们假设用户文件大小为 $0$，这些目录条目消耗的总空间为 $N_{fixed} \\cdot d$。这种消耗不能超过数据区域中的可用空间。\n    $$ N_{fixed} \\cdot d \\le P - I - F_f $$\n    通过除以 $d$ 并向下取整，因为不能创建非整数个文件，这得出了对 $N_{fixed}$ 的第二个上限：\n    $$ N_{fixed} \\le \\left\\lfloor \\frac{P - I - F_f}{d} \\right\\rfloor $$\n\n用户文件数 $N_{fixed}$ 必须同时满足这两个约束。因此，最紧可能上限是这两个限制中最严格的一个。这可以用最小运算符表示：\n$$ N_{fixed} = \\min\\left( \\left\\lfloor \\frac{I}{i_s} \\right\\rfloor - r, \\left\\lfloor \\frac{P - I - F_f}{d} \\right\\rfloor \\right) $$\n\n接下来，我们分析 **动态索引节点设计**。\n在这种设计中，没有预分配的索引节点表。相反，索引节点和目录条目都从同一个通用空闲空间区域中分配。这意味着只有一个主要资源约束：总可用空间。设 $N_{dynamic}$ 为此设计中的最大用户文件数。\n\n1.  **空间约束**：分区总大小为 $P$ 字节。非索引节点的固定开销占用 $F_d$ 字节。剩余空间 $P - F_d$ 是通用空闲空间区域，所有每个文件的元数据都从该区域分配。对于创建的每个用户文件，都会从此池中消耗一定量的空间。每个文件的成本包括：\n    - 索引节点本身：$i_s$ 字节。\n    - 索引节点的摊销分配记账成本：$a$ 字节。\n    - 目录条目：$d$ 字节。\n    - 文件数据大小为 $0$ 字节。\n    每个用户文件消耗的总空间为 $i_s + a + d$ 字节。对于 $N_{dynamic}$ 个文件，消耗的总空间为 $N_{dynamic} \\cdot (i_s + a + d)$。这个总量不能超过可用的空闲空间。\n    $$ N_{dynamic} \\cdot (i_s + a + d) \\le P - F_d $$\n    求解 $N_{dynamic}$ 并向下取整以确保文件数量为整数，得到最紧上限：\n    $$ N_{dynamic} = \\left\\lfloor \\frac{P - F_d}{i_s + a + d} \\right\\rfloor $$\n\n最后，我们将乘法改进因子 $\\gamma$ 定义为动态索引节点上限与固定索引节点上限的比率。\n$$ \\gamma = \\frac{N_{dynamic}}{N_{fixed}} $$\n代入推导出的 $N_{dynamic}$ 和 $N_{fixed}$ 表达式，得到 $\\gamma$ 的最终封闭形式表达式。\n$$ \\gamma = \\frac{\\left\\lfloor \\frac{P - F_d}{i_s + a + d} \\right\\rfloor}{\\min\\left( \\left\\lfloor \\frac{I}{i_s} \\right\\rfloor - r, \\left\\lfloor \\frac{P - I - F_f}{d} \\right\\rfloor \\right)} $$\n此表达式仅使用给定参数和允许的代数、向下取整和最小运算符构建，满足问题陈述的所有条件。分母非零和界限为正的假设确保了此表达式是良定义的。",
            "answer": "$$\n\\boxed{\\frac{\\left\\lfloor \\frac{P - F_d}{i_s + a + d} \\right\\rfloor}{\\min\\left( \\left\\lfloor \\frac{I}{i_s} \\right\\rfloor - r, \\left\\lfloor \\frac{P - I - F_f}{d} \\right\\rfloor \\right)}}\n$$"
        },
        {
            "introduction": "一旦文件系统知道了文件的存在（通过索引节点），它如何定位文件的实际数据块？本练习对比了两种不同的文件映射方法：经典的文件分配表（FAT）链式结构和更现代的基于区段（extent）的映射。通过建立一个包含缓存命中率的性能模型，你将能够量化随机访问一个文件块的预期时间，并揭示不同底层数据结构对性能的深远影响 。",
            "id": "3642743",
            "problem": "一个操作系统的文件子系统使用分层结构，其中文件映射层在存储层发出输入/输出操作之前，将文件的逻辑块索引转换为磁盘上的位置。考虑一个文件的两种可选映射组织方式：文件分配表 (FAT) 和基于区段 (extent-based) 的映射。在文件分配表 (FAT) 组织中，一个文件是簇 (cluster) 的单向链表，目录项存储起始簇号。假设每个簇包含 $C$ 个逻辑块。对文件内逻辑块索引 $b \\in \\mathbb{Z}_{\\ge 0}$ 的随机访问需要从起始簇开始遍历 FAT 链，直到包含块 $b$ 的簇。假设映射层和存储层的成本模型如下：\n\n- 访问一个已在内存缓存中的 FAT 条目成本为 $t_{H}$ 时间单位。\n- 访问一个不在缓存中的 FAT 条目成本为 $t_{F}$ 时间单位（从存储器中读取到内存）。\n- 在遍历过程中，对于每个所需的 FAT 条目，其在缓存中的概率为 $p \\in [0,1]$，且各条目是否在缓存中是相互独立的。\n- 映射完成后，从存储设备读取目标数据块的成本为 $t_{B}$ 时间单位。\n- 目录项的起始簇号假定已知且已在内存中，成本为 $0$。\n- 在基于区段的组织中，映射层以 $t_{E}$ 时间单位的成本执行一次 $O(1)$ 的区段查找，然后存储层以相同的成本 $t_{B}$ 时间单位读取目标数据块。\n\n从文件分配表 (FAT) 链遍历如何计算包含给定逻辑块的簇的基本定义以及独立缓存命中事件的期望线性性质出发，推导出一个封闭形式的表达式，该表达式表示在 FAT 组织中对逻辑块 $b$ 进行随机访问的期望总时间与在基于区段的组织中进行相同访问的总时间之比 $R(b)$。用 $b$、$C$、$p$、$t_{H}$、$t_{F}$、$t_{B}$ 和 $t_{E}$ 将你的最终答案表示为单个简化的解析表达式。不需要进行数值计算。最终答案必须是单个表达式；除了所要求的表达式外，不要提供不等式或方程式。如果你选择展示任何中间量，它们不能出现在最终答案中。最终答案中不要包含单位。",
            "solution": "该问题要求推导一个封闭形式的表达式，用于表示在文件分配表 (FAT) 组织中对逻辑块 $b$ 进行随机访问的期望总时间与在基于区段的组织中进行相同访问的总时间之比 $R(b)$。我们将通过首先确定基于区段情况下的总时间表达式，然后推导基于 FAT 情况下的期望总时间，最后计算它们的比率来解决这个问题。\n\n首先，我们分析在基于区段的组织中进行一次访问的总时间。问题陈述，映射层执行一次区段查找，成本为 $t_{E}$ 时间单位，这被描述为一个 $O(1)$ 操作。之后，存储层读取目标数据块，这会产生 $t_{B}$ 时间单位的成本。这两个操作是顺序执行的。因此，在基于区段的组织中进行一次访问的总时间，我们表示为 $T_{\\text{extent}}$，是这些成本的总和：\n$$T_{\\text{extent}} = t_{E} + t_{B}$$\n这个时间是确定性的。\n\n接下来，我们分析在 FAT 组织中进行一次访问的期望总时间。对索引为 $b \\in \\mathbb{Z}_{\\ge 0}$ 的逻辑块的访问涉及两个主要步骤：首先，映射层必须通过遍历 FAT 链将逻辑块索引转换为物理磁盘位置；其次，存储层读取实际的数据块。\n\n文件的逻辑块被分组成簇，每个簇包含 $C$ 个逻辑块。块从 $0$ 开始索引。因此，文件的簇 $0$ 包含逻辑块 $0, 1, \\dots, C-1$。簇 $1$ 包含逻辑块 $C, C+1, \\dots, 2C-1$。通常，相对于文件的簇 $k$ 包含索引从 $kC$ 到 $(k+1)C-1$ 的逻辑块。为了找到包含逻辑块 $b$ 的相对于文件的簇索引 $k$，我们必须找到整数 $k$ 使得 $kC \\le b  (k+1)C$。两边除以 $C$ 得到 $k \\le \\frac{b}{C}  k+1$。这意味着 $k$ 是 $\\frac{b}{C}$ 的整数部分，由向下取整函数给出：\n$$k = \\left\\lfloor \\frac{b}{C} \\right\\rfloor$$\n在 FAT 组织中，一个文件是簇的单向链表。目录项包含第一个簇（文件序列中的簇 $0$）的地址，假定该地址已知且在内存中，成本为零。为了找到索引为 $k$ 的目标簇的位置，文件系统必须从第一个簇开始遍历链表。这需要在 FAT 中进行 $k$ 次顺序查找。例如，要找到第二个簇（索引为 $1$），必须读取对应于第一个簇（索引为 $0$）的 FAT 条目。要找到第三个簇（索引为 $2$），必须读取第二个簇的 FAT 条目，依此类推。因此，要到达索引为 $k = \\lfloor \\frac{b}{C} \\rfloor$ 的簇，总共需要进行 $N = \\lfloor \\frac{b}{C} \\rfloor$ 次 FAT 条目访问。\n\n设 $X_i$ 为表示遍历链中第 $i$ 次 FAT 访问成本的随机变量，其中 $i \\in \\{1, 2, \\dots, N\\}$。每次访问的成本取决于相应的 FAT 条目是否在内存缓存中。\n- 如果条目在缓存中（“命中”），则成本为 $t_H$。这种情况发生的概率为 $p$。\n- 如果条目不在缓存中（“未命中”），则成本为 $t_F$。这种情况发生的概率为 $1-p$。\n\n单次 FAT 访问的期望成本 $E[X_i]$ 是这两种结果的加权平均值：\n$$E[X_i] = p \\cdot t_{H} + (1-p) \\cdot t_{F}$$\n问题陈述，对于每个所需的 FAT 条目，缓存命中/未命中事件是独立的。因此，对于所有的 $i=1, \\dots, N$，期望成本 $E[X_i]$ 都是相同的。我们将这个共同的期望成本表示为 $E[X_{\\text{access}}]$。\n\n映射层遍历的总时间是 $N$ 次单独访问成本的总和，即 $T_{\\text{mapping-FAT}} = \\sum_{i=1}^{N} X_i$。根据期望的线性性质，期望总映射时间是每次访问的期望成本之和：\n$$E[T_{\\text{mapping-FAT}}] = E\\left[\\sum_{i=1}^{N} X_i\\right] = \\sum_{i=1}^{N} E[X_i]$$\n由于对于所有 $i$，$E[X_i]$ 都是常数，且 $N = \\lfloor \\frac{b}{C} \\rfloor$，这可以简化为：\n$$E[T_{\\text{mapping-FAT}}] = N \\cdot E[X_{\\text{access}}] = \\left\\lfloor \\frac{b}{C} \\right\\rfloor (p t_{H} + (1-p) t_{F})$$\n在映射层确定数据块的物理位置后，存储层执行读操作，其成本为常数 $t_B$。基于 FAT 访问的总期望时间 $E[T_{\\text{FAT}}(b)]$ 是期望映射时间与块读取时间之和：\n$$E[T_{\\text{FAT}}(b)] = E[T_{\\text{mapping-FAT}}] + t_{B} = \\left\\lfloor \\frac{b}{C} \\right\\rfloor (p t_{H} + (1-p) t_{F}) + t_{B}$$\n\n最后，我们可以计算 FAT 组织的总期望时间与基于区段组织的总时间之比 $R(b)$：\n$$R(b) = \\frac{E[T_{\\text{FAT}}(b)]}{T_{\\text{extent}}}$$\n将推导出的分子和分母表达式代入，我们得到最终的封闭形式表达式：\n$$R(b) = \\frac{\\left\\lfloor \\frac{b}{C} \\right\\rfloor (p t_{H} + (1-p) t_{F}) + t_{B}}{t_{E} + t_{B}}$$\n此表达式已简化，并且只包含问题陈述中指定的变量。",
            "answer": "$$\\boxed{\\frac{\\left\\lfloor \\frac{b}{C} \\right\\rfloor \\left(p t_{H} + (1-p) t_{F}\\right) + t_{B}}{t_{E} + t_{B}}}$$"
        },
        {
            "introduction": "文件系统不仅仅是关于在磁盘上存储数据，它还定义了我们如何命名和访问这些数据，这直接关系到系统的安全性。本练习模拟了一个常见的安全场景：创建一个“沙箱”环境。通过分析 `chroot`、当前工作目录（cwd）以及 `..` 路径组件的复杂交互，你将学会识别路径解析中的安全漏洞，并理解为什么像 `openat` 这样的现代系统调用对于编写安全、可靠的程序至关重要 。",
            "id": "3642749",
            "problem": "考虑一个遵循 POSIX (可移植操作系统接口) 的类 Unix 系统上的进程。设该进程的初始当前工作目录 `cwd` 等于 `\"/etc\"`，其根目录 `root` 等于 `\"/\"`。该进程后来在绝对路径 `\"/srv/sandbox\"` 处创建了一个用作沙箱的目录，其中包含条目 `\"a\"` (一个目录) 和 `\"b\"` (一个普通文件)。为了符合实际情况，假设在初始 `cwd` `\"/etc\"` 下也存在名为 `\"a\"` (一个目录) 和 `\"b\"` (一个普通文件) 的条目。该进程可以调用更改根目录操作 `chroot` 来设置其新的 `root`，也可以调用更改目录操作 `chdir` 或 `fchdir` 来设置其 `cwd`。`openat` 系统调用会相对于一个提供的目录文件描述符来解析路径名，或者如果传递了特殊常量 `AT_FDCWD`，则相对于进程的 `cwd` 来解析。假设没有挂载命名空间或绑定挂載来改变可见性，并忽略权限错误。\n\n仅使用以下关于路径解析的广泛接受的基本事实：在 POSIX 下，相对路径从 `cwd` 开始解析，绝对路径从 `root` 开始解析；组件 `\".\"` 和 `\"..\"` 在路径解析时被解释，因此 `x/..\"` 指的是在任何符号链接解析后 `x` 实际表示的目录的父目录；`chroot` 设置 `root` 但不改变 `cwd`；当设置了 `root` 时，路径遍历在解析过程中不能通过 `\"..\"` 上溯到 `root` 之上，但解析不会将 `root` 之外的 `cwd` 回溯性地重新定位到 `root` 之内。\n\n该进程希望使用 `openat` 打开路径名 `\"a/../b\"`。以下哪个选项正确地陈述了能保证所打开的路径被限制在沙箱 `\"/srv/sandbox\"` 的子树内的条件 (即，最终解析的路径不能命名 `\"/srv/sandbox\"` 之外的任何东西)？选择所有适用项。\n\nA. 调用 `chroot(\"/srv/sandbox\")`，然后不改變 `cwd` 直接调用 `openat(AT_FDCWD, \"a/../b\", O_RDONLY)`。限制能够得到保证，因为 `\"..\"` 无法逃逸出新的 `root`。\n\nB. 调用 `chroot(\"/srv/sandbox\")` 紧接着调用 `chdir(\"/\")`，然后调用 `openat(AT_FDCWD, \"a/../b\", O_RDONLY)`。限制能够得到保证。\n\nC. 不使用 `AT_FDCWD`，而是打开一个指向 `\"/srv/sandbox\"` 的目录文件描述符 `d_root` (例如，通过 `d_root = open(\"/srv/sandbox\", O_PATH | O_DIRECTORY)`)，然后调用 `openat(d_root, \"a/../b\", O_RDONLY)`。无论 `cwd` 如何，限制都能得到保证。\n\nD. 调用 `chroot(\"/srv/sandbox\")` 紧接着调用 `chdir(\"/\")`，但假设在沙箱内部 `\"a\"` 是一个指向 `\"/\"` 的符号链接。那么 `openat(AT_FDCWD, \"a/../b\", O_RDONLY)` 可能会解析到沙箱外部，因此限制无法得到保证。\n\nE. 调用 `chroot(\"/srv/sandbox\")`，同时保持一个预先存在的指向 `\"/etc\"` 的目录文件描述符为打开状态，然后在调用 `openat(AT_FDCWD, \"a/../b\", O_RDONLY)` 之前使用 `fchdir` 将 `cwd` 设置为该目录。限制仍然能够得到保证，因为 `root` 屏障会阻止通过 `\"..\"` 逃逸。",
            "solution": "问题陈述是计算系统理论中一个明确定义的练习，具体涉及 POSIX 兼容操作系统中文件系统路径解析的语义。它提供了一个清晰的初始状态、一组定义好的操作以及一系列约束系统行为的明确规则。这些规则与类 Unix 系统的既定行为一致。该问题具有科学依据、提法恰当、客观，并且没有任何逻辑矛盾或事实错误。因此，它适合进行分析。\n\n核心任务是确定在哪种情况下，解析相对路径 `\"a/../b\"` 能保证得到一个被限制在 `\"/srv/sandbox\"` 目录子树内的文件路径。从一个起始目录（我们称之为 $D_{start}$）解析路径 `\"a/../b\"` 的过程可以简化。组件 `\"a\"` 指向子目录 $D_{start}\\text{/a}$。然后，组件 `\"../\"` 指向 $D_{start}\\text{/a}$ 的父目录，也就是 $D_{start}$ 本身（假设 `\"a\"` 是一个简单目录而不是会使解析复杂化的符号链接，我们将在后面单独处理这种情况）。最后，组件 `\"b\"` 在 $D_{start}$ 内解析，得到路径 $D_{start}\\text{/b}$。因此，路径 `\"a/../b\"` 实际上等同于从起始目录解析 `\"b\"`。\n\n因此，当且仅当路径解析的起始目录 $D_{start}$ 是 `\"/srv/sandbox\"` 本身或其子目录之一时，才能保证路径被限制在 `\"/srv/sandbox\"` 子树内。所讨论的系统调用是 `openat`，其起始目录由它的第一个参数决定。\n\n让我们根据这些原则和提供的基本事实来评估每个选项。初始状态为 `root = \"/\"` 和 `cwd = \"/etc\"`。\n\n**选项 A 评估**\n1.  进程调用 `chroot(\"/srv/sandbox\")`。根据提供的规则，这会将进程的 `root` 目录设置为 `\"/srv/sandbox\"`。至关重要的是，此操作“不改变 `cwd`”。\n2.  `cwd` 仍然是对目录 `\"/etc\"` 的引用。规则“解析不会将 `root` 之外的 `cwd` 回溯性地重新定位到 `root` 之内”证实了进程的 `cwd` 仍然是位于全局文件系统中 `\"/etc\"` 位置的目录，它在新 `root` jail 之外。\n3.  然后进程调用 `openat(AT_FDCWD, \"a/../b\", O_RDONLY)`。特殊常量 `AT_FDCWD` 指示系统调用相对于当前工作目录 `cwd` 解析路径。\n4.  由于 `cwd` 是 `\"/etc\"`，路径解析从那里开始。它将 `\"a/../b\"` 解析为 `\"/etc/b\"`。\n5.  最终路径 `\"/etc/b\"` 不在 `\"/srv/sandbox\"` 子树内。未能实现限制。\n6.  选项中提供的理由，“因为 `..` 无法逃逸出新的 `root`”，是错误的。路径解析完全在新 `root` 之外开始并保持，因此对 `\"..\"` 的遍历限制从未被触发。\n\n所述条件不能保证限制。\n结论：**不正确**。\n\n**选项 B 评估**\n1.  进程调用 `chroot(\"/srv/sandbox\")`，将其 `root` 设置为 `\"/srv/sandbox\"`。和之前一样，`cwd` 仍然是 `\"/etc\"`。\n2.  进程接着调用 `chdir(\"/\")`。根据规则“绝对路径从 `root` 开始解析”，路径 `\"/\"` 相对于进程的新 `root` 目录 `\"/srv/sandbox\"` 进行解析。因此，`chdir(\"/\")` 成功地将 `cwd` 更改为 `\"/srv/sandbox\"`。\n3.  现在进程的状态是 `root = \"/srv/sandbox\"` 和 `cwd = \"/srv/sandbox\"`。\n4.  调用 `openat(AT_FDCWD, \"a/../b\", O_RDONLY)` 从 `cwd`（即 `\"/srv/sandbox\"`）开始解析路径。\n5.  从 `\"/srv/sandbox\"` 解析 `\"a/../b\"` 的过程如下：找到 `\"/srv/sandbox/a\"` 目录，`\"../\"` 解析为其父目录 `\"/srv/sandbox\"`，而 `\"b\"` 解析为文件 `\"/srv/sandbox/b\"`。\n6.  最终路径是 `\"/srv/sandbox/b\"`，它被限制在沙箱子树内。\n\n所述条件确实保证了限制。\n结论：**正确**。\n\n**选项 C 评估**\n1.  此选项绕过了使用 `chroot` 和 `AT_FDCWD` 来进行打开操作。取而代之的是，通过类似 `d_root = open(\"/srv/sandbox\", O_PATH | O_DIRECTORY)` 的调用，为目录 `\"/srv/sandbox\"` 获取一个文件描述符 `d_root`。\n2.  然后进程调用 `openat(d_root, \"a/../b\", O_RDONLY)`。这种形式的 `openat` 会相对于与文件描述符 `d_root` 关联的目录来解析给定的路径名。\n3.  解析的起始目录明确是 `\"/srv/sandbox\"`，不受进程的 `cwd` 或 `root` 影响。\n4.  如对选项 B 的分析所示，从起始目录 `\"/srv/sandbox\"` 解析 `\"a/../b\"` 得到最终路径 `\"/srv/sandbox/b\"`。\n5.  此路径被限制在沙箱内。声明“无论 `cwd` 如何，限制都能得到保证”是准确的。这是一种标准且可靠的技术，用于在特定目录内执行基于路径的操作，而无需更改像 `cwd` 或 `root` 这样的进程范围状态。\n\n所述条件确实保证了限制。\n结论：**正确**。\n\n**选项 D 评估**\n1.  此选项提出了一个场景并对其结果做出了断言。我们必须评估该断言的真实性。\n2.  设置与选项 B 相同：`chroot(\"/srv/sandbox\")` 接着 `chdir(\"/\")`。如已确立的，这将设置 `root = \"/srv/sandbox\"` 和 `cwd = \"/srv/sandbox\"`。\n3.  新的条件是沙箱内的 `\"a\"` (`\"/srv/sandbox/a\"`) 是一个指向 `\"/\"` 的符号链接。\n4.  调用是 `openat(AT_FDCWD, \"a/../b\", O_RDONLY)`，从 `cwd = \"/srv/sandbox\"` 开始。\n5.  路径解析以 `\"a\"` 开始。在 `\"/srv/sandbox\"`，发现 `\"a\"` 是一个指向 `\"/\"` 的符号链接。\n6.  链接的目标 `\"/\"` 是一个绝对路径。因此，它的解析必须从进程当前的 `root` 开始，即 `\"/srv/sandbox\"`。因此，该符号链接解析为目录 `\"/srv/sandbox\"`。\n7.  路径组件 `\"a\"` 实际上已解析为 `\"/srv/sandbox\"`。现在，处理下一个组件 `\"..\"`。这指的是刚刚解析出的目录的父目录。\n8.  我们必须找到 `\"/srv/sandbox\"` 的父目录。然而，规则“路径遍历不能通过 `..` 上溯到 `root` 之上”适用。由于 `\"/srv/sandbox\"` 是进程的 `root`，尝试通过 `\"../\"` 上溯的结果是 `\"/srv/sandbox\"` 本身。\n9.  所以，路径 `\"a/..\"` 解析为 `\"/srv/sandbox\"`。\n10. 最后，组件 `\"b\"` 相对于此结果进行解析，得到 `\"/srv/sandbox/b\"`。\n11. 最终路径被限制在沙箱内。因此，该选项声称路径“可能会解析到沙箱外部”以及“限制无法得到保证”是错误的。\n\n此选项中的陈述事实不正确。\n结论：**不正确**。\n\n**选项 E 评估**\n1.  进程调用 `chroot(\"/srv/sandbox\")`，设置 `root = \"/srv/sandbox\"`。\n2.  然后它使用 `fchdir`，利用一个在 `chroot` 之前打开的指向 `\"/etc\"` 的文件描述符来设置其 `cwd`。此操作明确地将 `cwd` 设置为与 `\"/etc\"` 对应的目录 inode。\n3.  结果状态为 `root = \"/srv/sandbox\"`，而 `cwd` 指向目录 `\"/etc\"`，该目录位于 `root` jail 之外。这与选项 A 中的状态相同。\n4.  调用 `openat(AT_FDCWD, \"a/../b\", O_RDONLY)` 相对于 `cwd` `\"/etc\"` 解析路径。\n5.  路径解析为 `\"/etc/b\"`，它不被限制在 `\"/srv/sandbox\"` 子树内。\n6.  声明“限制仍然能够得到保证”是错误的。其理由“因为 `root` 屏障会阻止逃逸”再次是错误的，因为解析从一开始就从未进入 jail。\n\n所述条件不能保证限制。\n结论：**不正确**。\n\n总而言之，只有选项 B 和 C 描述了能够正确且可靠地保证文件操作被限制在 `\"/srv/sandbox\"` 子树内的场景。",
            "answer": "$$\\boxed{BC}$$"
        }
    ]
}