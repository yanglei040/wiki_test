{
    "hands_on_practices": [
        {
            "introduction": "日志结构文件系统（LFS）的核心思想是将所有写入操作顺序追加到日志中。这个练习将带你深入探究 LFS 写入路径的 CPU 开销，通过将一次写入操作分解为多个基本步骤（如 CRC 校验、元数据处理），并从底层构建性能模型。通过这个实践，你将学会如何量化系统性能，并识别出影响 LFS 写入效率的关键因素，这是系统性能分析的一项基本技能。",
            "id": "3654765",
            "problem": "日志结构文件系统 (Log-Structured File System, LFS) 为每个段（segment）维护一个摘要（summary），以加速崩溃恢复和清理（cleaning）过程。假设一个实现将用户写入追加到一个大小为 $S = 2\\,\\mathrm{MiB}$ 的内存段缓冲区中，文件系统块大小为 $B = 4096\\,\\mathrm{bytes}$。当段写满时，系统会写出该段及其摘要。每个追加的块都对应一个摘要条目。每个条目的工作包括计算循环冗余校验 (Cyclic Redundancy Check, CRC)、格式化元数据，以及将条目插入到一个内存哈希表中，该哈希表用于在清理期间进行快速查找。该实现在一台给定机器上进行了性能分析，测量出以下单次操作的成本：\n\n- 对一个字节流计算 $32$ 位 CRC 的成本为 $c_{\\mathrm{crc}} = 3.2$ 周期/字节。\n- 格式化和存储大小为 $m = 32\\,\\mathrm{bytes}$ 的固定大小摘要元数据的成本为 $c_{\\mathrm{meta}} = 0.8$ 周期/字节。\n- 每个条目的固定格式化开销（分支、边界检查和指针追逐）成本为 $c_{\\mathrm{fmt}} = 150$ 周期/条目。\n- 在观察到的负载因子下，将条目插入内存哈希表的期望成本为 $c_{\\mathrm{hash}} = 75$ 周期/条目。\n\n此外，还有一个固定的每段段头组装成本 $c_{\\mathrm{seg}} = 10000$ 周期，该成本必须摊销到段中的所有条目上。另外，每次用户写入都有一个固定的每次写入同步开销 $c_{\\mathrm{w}} = 300$ 周期。\n\n假设平均用户写入大小为 $w = 12\\,\\mathrm{KiB}$，并且写入与块边界对齐，因此每次写入的块数恰好为 $n = w / B$。假设段被密集填充，因此 $c_{\\mathrm{seg}}$ 的每条目摊销份额在段中所有条目间是均匀的，并且所有成本线性相加，因为这些步骤在中央处理器 (CPU) 上是串行执行的。\n\n请从第一性原理和给定测量值出发，推导每次写入的期望 CPU 周期数 $C_{\\mathrm{cpu}}$ 的闭式表达式，然后使用所提供的参数进行数值计算。最终结果以周期为单位表示，并将答案四舍五入到四位有效数字。",
            "solution": "该问题要求推导每次用户写入的期望 CPU 周期数（表示为 $C_{\\mathrm{cpu}}$）的闭式表达式，并随后进行数值计算。推导将基于第一性原理，将总成本分解为问题陈述中描述的各个组成部分。线性原理允许我们将这些单独的成本相加。\n\n首先，让我们用符号和数值定义给定的参数：\n- 段缓冲区大小：$S = 2\\,\\mathrm{MiB} = 2 \\times (1024)^2\\,\\mathrm{bytes} = 2 \\times 2^{20}\\,\\mathrm{bytes} = 2097152\\,\\mathrm{bytes}$。\n- 文件系统块大小：$B = 4096\\,\\mathrm{bytes} = 4 \\times 1024\\,\\mathrm{bytes} = 2^{12}\\,\\mathrm{bytes}$。\n- 平均用户写入大小：$w = 12\\,\\mathrm{KiB} = 12 \\times 1024\\,\\mathrm{bytes} = 12288\\,\\mathrm{bytes}$。\n- 每个条目的摘要元数据大小：$m = 32\\,\\mathrm{bytes}$。\n- 每字节的 CRC 成本：$c_{\\mathrm{crc}} = 3.2$ 周期/字节。\n- 每字节的元数据存储成本：$c_{\\mathrm{meta}} = 0.8$ 周期/字节。\n- 每个条目的固定格式化开销：$c_{\\mathrm{fmt}} = 150$ 周期/条目。\n- 每个条目的哈希表插入成本：$c_{\\mathrm{hash}} = 75$ 周期/条目。\n- 每个段的固定段头组装成本：$c_{\\mathrm{seg}} = 10000$ 周期/段。\n- 每次写入的固定同步开销：$c_{\\mathrm{w}} = 300$ 周期/写入。\n\n每次写入的总成本 $C_{\\mathrm{cpu}}$ 是每次写入的固定开销与处理构成该写入的块相关成本的总和。单次用户写入的大小为 $w$，由 $n$ 个大小为 $B$ 的块组成。根据块对齐的假设，每次写入的块数为：\n$$n = \\frac{w}{B}$$\n总成本可以表示为：\n$$C_{\\mathrm{cpu}} = c_{\\mathrm{w}} + n \\cdot C_{\\mathrm{block}}$$\n其中 $C_{\\mathrm{block}}$ 是与处理单个块相关的总 CPU 成本。\n\n每个块的成本 $C_{\\mathrm{block}}$ 是几个组成部分的总和。问题指出，每个追加的块贡献一个摘要条目。因此，每个块的成本等同于每个条目的成本。这些成本可分类如下：\n\n1.  **CRC 计算成本**：此成本与块大小 $B$ 成正比。\n    $$C_{\\mathrm{crc\\_block}} = c_{\\mathrm{crc}} \\cdot B$$\n2.  **摘要条目生成成本**：这包括格式化和存储大小为 $m$ 的元数据、每个条目的固定格式化开销以及哈希表插入成本。\n    $$C_{\\mathrm{summary\\_entry}} = (c_{\\mathrm{meta}} \\cdot m) + c_{\\mathrm{fmt}} + c_{\\mathrm{hash}}$$\n3.  **摊销的每段成本**：每个段的固定成本 $c_{\\mathrm{seg}}$ 必须分摊到该段内的所有块上。首先，我们计算一个大小为 $S$ 的段可以容纳的块数 $N_{B/S}$。\n    $$N_{B/S} = \\frac{S}{B}$$\n    那么，每个块（或每个条目）的摊销成本为：\n    $$C_{\\mathrm{amortized\\_seg}} = \\frac{c_{\\mathrm{seg}}}{N_{B/S}} = \\frac{c_{\\mathrm{seg}}}{S/B} = \\frac{c_{\\mathrm{seg}} \\cdot B}{S}$$\n\n每个块的总成本 $C_{\\mathrm{block}}$ 是这些组成部分的总和：\n$$C_{\\mathrm{block}} = C_{\\mathrm{crc\\_block}} + C_{\\mathrm{summary\\_entry}} + C_{\\mathrm{amortized\\_seg}}$$\n$$C_{\\mathrm{block}} = (c_{\\mathrm{crc}} \\cdot B) + (c_{\\mathrm{meta}} \\cdot m + c_{\\mathrm{fmt}} + c_{\\mathrm{hash}}) + \\frac{c_{\\mathrm{seg}} \\cdot B}{S}$$\n\n现在，我们将 $C_{\\mathrm{block}}$ 的表达式代入 $C_{\\mathrm{cpu}}$ 的方程中：\n$$C_{\\mathrm{cpu}} = c_{\\mathrm{w}} + n \\cdot \\left( c_{\\mathrm{crc}} \\cdot B + c_{\\mathrm{meta}} \\cdot m + c_{\\mathrm{fmt}} + c_{\\mathrm{hash}} + \\frac{c_{\\mathrm{seg}} \\cdot B}{S} \\right)$$\n代入 $n = w/B$，我们得到每次写入的期望 CPU 周期的最终闭式表达式：\n$$C_{\\mathrm{cpu}} = c_{\\mathrm{w}} + \\frac{w}{B} \\left( c_{\\mathrm{crc}} \\cdot B + c_{\\mathrm{meta}} \\cdot m + c_{\\mathrm{fmt}} + c_{\\mathrm{hash}} + \\frac{c_{\\mathrm{seg}} \\cdot B}{S} \\right)$$\n\n接下来，我们使用提供的参数对此表达式进行数值计算。\n\n首先，计算每次写入的块数 $n$：\n$$n = \\frac{w}{B} = \\frac{12288\\,\\mathrm{bytes}}{4096\\,\\mathrm{bytes}} = 3$$\n\n现在，我们计算每个块成本 $C_{\\mathrm{block}}$ 的组成部分：\n- 每个块的 CRC 成本：\n$C_{\\mathrm{crc\\_block}} = c_{\\mathrm{crc}} \\cdot B = 3.2 \\cdot 4096 = 13107.2$ 周期。\n- 摘要条目成本（不包括摊销成本）：\n$C_{\\mathrm{summary\\_entry}} = (c_{\\mathrm{meta}} \\cdot m) + c_{\\mathrm{fmt}} + c_{\\mathrm{hash}} = (0.8 \\cdot 32) + 150 + 75 = 25.6 + 150 + 75 = 250.6$ 周期。\n- 每个块的摊销段成本：\n首先，计算每个段的块数 $N_{B/S}$：\n$$N_{B/S} = \\frac{S}{B} = \\frac{2097152\\,\\mathrm{bytes}}{4096\\,\\mathrm{bytes}} = 512$$\n然后，摊销成本为：\n$$C_{\\mathrm{amortized\\_seg}} = \\frac{c_{\\mathrm{seg}}}{N_{B/S}} = \\frac{10000}{512} = 19.53125 \\text{ 周期。}$$\n\n每个块的总成本是这些组成部分的总和：\n$$C_{\\mathrm{block}} = 13107.2 + 250.6 + 19.53125 = 13377.33125 \\text{ 周期。}$$\n\n最后，我们计算每次写入的总 CPU 周期数 $C_{\\mathrm{cpu}}$：\n$$C_{\\mathrm{cpu}} = c_{\\mathrm{w}} + n \\cdot C_{\\mathrm{block}} = 300 + 3 \\cdot 13377.33125$$\n$$C_{\\mathrm{cpu}} = 300 + 40131.99375 = 40431.99375 \\text{ 周期。}$$\n\n问题要求将最终答案四舍五入到四位有效数字。计算值为 $40431.99375$。前四位有效数字是 $4, 0, 4, 3$。第五位数字是 $1$，所以我们向下舍入。\n$$C_{\\mathrm{cpu}} \\approx 40430$$\n为了用四位有效数字明确地表示这一点，我们可以使用科学记数法：$4.043 \\times 10^4$。",
            "answer": "$$\\boxed{4.043 \\times 10^4}$$"
        },
        {
            "introduction": "日志结构文件系统虽然简化了写入操作，但其长期性能在很大程度上取决于“清理器”的效率，它负责回收碎片化的空间。这个练习建立了一个简化的概率模型，让你运用微积分来寻找最优的清理触发阈值 $u_t$，从而在清理开销和回收效率之间达到最佳平衡。这项实践将帮助你理解写放大（write amplification）这一核心概念，并掌握如何通过数学建模来优化系统策略，解决复杂的设计权衡问题。",
            "id": "3654742",
            "problem": "日志结构文件系统（LFS）的清理器通过选择利用率低于某一阈值的段来回收空间。考虑以下基于段清理和概率选择定义的原则性模型。\n\n一个大段池中的各个段具有独立的利用率，由一个在 $[0,1]$ 上均匀分布的随机变量 $U$ 建模。当清理器运行时，它会在满足 $U \\le u_t$ 的段中进行均匀选择，其中 $u_t \\in (0,1)$ 是一个固定的触发阈值。清理一个利用率为 $u$ 的段会读取 $1$ 个段，并将比例为 $u$ 的活动数据写入新的段中，从而释放比例为 $1-u$ 的空间。写入新用户数据的行为本身，每写入一个单位的数据（归一化为 $1$），总是会产生恰好相当于 $1$ 个段的设备流量。此外，在清理之前，系统可能需要扫描候选段以找到那些满足 $U \\le u_t$ 的段。在扫描过程中检查的每个候选段都会产生一个归一化的、依赖于工作负载的设备流量开销 $c_m$，其中 $m \\in \\{\\text{hot}, \\text{cold}\\}$ 表示工作负载模式。假设为找到一个符合条件的段而检查的预期候选段数量等于该条件概率的倒数。\n\n工作负载随时间在两种模式下随机变化：\n- 系统有 $p$ 的概率处于热模式，每个候选段产生扫描成本 $c_{\\mathrm{hot}}$。\n- 系统有 $1-p$ 的概率处于冷模式，每个候选段产生扫描成本 $c_{\\mathrm{cold}}$。\n\n假设 $p = \\frac{1}{3}$，$c_{\\mathrm{hot}} = 2$ 以及 $c_{\\mathrm{cold}} = \\frac{1}{2}$。段大小和所有设备流量均已归一化，因此上述单位是无量纲的。\n\n从上述定义和基础概率（特别是条件期望和伯努利过程中首次成功前的试验次数期望）出发，推导出每单位新用户数据的预期总设备流量 $E[W(u_t)]$，作为 $u_t$ 的函数，其中期望是针对工作负载模式的随机性计算的。然后，确定使 $E[W(u_t)]$ 最小化的 $u_t \\in (0,1)$ 的值。将最优阈值 $u_t^{\\star}$ 的最终答案表示为单个闭式表达式。",
            "solution": "该问题是有效的，因为它具有科学依据、问题适定且客观。它提出了一个操作系统设计领域内的标准优化问题，该问题基于一个简化但一致的日志结构文件系统清理器模型。\n\n目标是找到最优利用率阈值 $u_t^{\\star}$，以最小化每单位新用户数据的预期总设备流量，记为 $E[W(u_t)]$。这个量通常被称为写放大因子。\n\n首先，我们来确定设备流量各组成部分之间的关系。总设备流量是写入新用户数据产生的流量和清理过程产生的流量之和。问题将写入新用户数据的流量归一化为每单位数据 $1$ 个单位的流量。要写入 $1$ 个单位的新数据，需要 $1$ 个单位的可用空间。这个空间必须由清理器回收。每单位新数据的总流量 $W$ 可以表示为：\n$$\nW = 1 + (\\text{为释放 } 1 \\text{ 单位空间而产生的清理流量})\n$$\n清理流量本身由两部分组成：扫描符合条件的段和清理一个段的读/写操作。\n\n设 $U$ 是表示段利用率的随机变量，且 $U \\sim \\text{Uniform}[0, 1]$。\n如果一个段的利用率低于或等于阈值 $u_t$（其中 $u_t \\in (0, 1)$），则该段符合清理条件。一个随机选择的段符合条件的概率是：\n$$\nP(U \\le u_t) = \\int_0^{u_t} 1 \\, du = u_t\n$$\n被选中进行清理的段的利用率，我们称之为 $U_s$，服从 $U$ 在 $U \\le u_t$ 条件下的分布。这个条件分布是在 $[0, u_t]$ 上的均匀分布，其概率密度函数为 $f_{U_s}(u) = \\frac{1}{u_t}$，其中 $u \\in [0, u_t]$。\n\n一个被清理段的期望利用率是：\n$$\nE[U_s] = E[U | U \\le u_t] = \\int_0^{u_t} u \\cdot f_{U_s}(u) \\, du = \\int_0^{u_t} u \\frac{1}{u_t} \\, du = \\frac{1}{u_t} \\left[ \\frac{u^2}{2} \\right]_0^{u_t} = \\frac{u_t}{2}\n$$\n清理一个利用率为 $u$ 的段会释放 $1-u$ 个单位的空间。每个被清理的段所释放的期望空间是：\n$$\nE[\\text{Space Freed}] = E[1 - U_s] = 1 - E[U_s] = 1 - \\frac{u_t}{2}\n$$\n清理一个利用率为 $u$ 的段的流量成本是 $1$（用于读取该段）加上 $u$（用于写入活动数据）。清理一个段的期望读/写流量是：\n$$\nE[\\text{Read/Write Traffic}] = E[1 + U_s] = 1 + E[U_s] = 1 + \\frac{u_t}{2}\n$$\n接下来，我们考虑扫描成本。寻找一个符合条件的段的过程是一系列成功概率为 $p_{succ} = u_t$ 的伯努利试验。找到第一个成功所需的试验次数（即需要扫描的段数）的期望值是几何分布的均值，即 $1/p_{succ} = 1/u_t$。\n每个候选段的扫描成本是 $c_m$，其中 $m \\in \\{\\text{hot}, \\text{cold}\\}$。在给定工作负载模式 $m$ 的条件下，找到一个符合条件的段的期望扫描流量是：\n$$\nE[\\text{Scanning Traffic} | m] = \\frac{1}{u_t} \\cdot c_m = \\frac{c_m}{u_t}\n$$\n在给定模式 $m$ 的条件下，清理一个段的期望总流量是期望扫描流量和期望读/写流量之和：\n$$\nC_{seg}(u_t, m) = E[\\text{Scanning Traffic} | m] + E[\\text{Read/Write Traffic}] = \\frac{c_m}{u_t} + 1 + \\frac{u_t}{2}\n$$\n要释放 $1$ 个单位的空间，必须清理的段的期望数量是：\n$$\nN_{seg} = \\frac{1}{E[\\text{Space Freed}]} = \\frac{1}{1 - \\frac{u_t}{2}}\n$$\n在给定模式 $m$ 的条件下，为释放 $1$ 个单位空间而产生的清理流量是段的数量与每段成本的乘积：\n$$\nT_{clean}(u_t, m) = N_{seg} \\cdot C_{seg}(u_t, m) = \\frac{1}{1 - \\frac{u_t}{2}} \\left( \\frac{c_m}{u_t} + 1 + \\frac{u_t}{2} \\right)\n$$\n在给定模式 $m$ 的条件下，每单位新数据的总流量（写放大）是 $W(u_t, m) = 1 + T_{clean}(u_t, m)$：\n$$\nW(u_t, m) = 1 + \\frac{\\frac{c_m}{u_t} + 1 + \\frac{u_t}{2}}{1 - \\frac{u_t}{2}} = \\frac{(1 - \\frac{u_t}{2}) + (\\frac{c_m}{u_t} + 1 + \\frac{u_t}{2})}{1 - \\frac{u_t}{2}} = \\frac{2 + \\frac{c_m}{u_t}}{1 - \\frac{u_t}{2}}\n$$\n问题要求计算这个量在所有工作负载模式下的期望值。设成本的随机变量为 $C_M$。$C_M = c_{\\mathrm{hot}}$ 的概率为 $p$，$C_M = c_{\\mathrm{cold}}$ 的概率为 $1-p$。期望成本为 $E[C_M] = p \\cdot c_{\\mathrm{hot}} + (1-p) \\cdot c_{\\mathrm{cold}}$。我们用 $\\bar{c}$ 表示这个平均成本。\n使用全期望定律：\n$$\nE[W(u_t)] = p \\cdot W(u_t, \\text{hot}) + (1-p) \\cdot W(u_t, \\text{cold})\n$$\n$$\nE[W(u_t)] = p \\left(\\frac{2 + \\frac{c_{\\mathrm{hot}}}{u_t}}{1 - \\frac{u_t}{2}}\\right) + (1-p) \\left(\\frac{2 + \\frac{c_{\\mathrm{cold}}}{u_t}}{1 - \\frac{u_t}{2}}\\right) = \\frac{2p + \\frac{p c_{\\mathrm{hot}}}{u_t} + 2(1-p) + \\frac{(1-p)c_{\\mathrm{cold}}}{u_t}}{1 - \\frac{u_t}{2}}\n$$\n$$\nE[W(u_t)] = \\frac{2 + \\frac{p c_{\\mathrm{hot}} + (1-p)c_{\\mathrm{cold}}}{u_t}}{1 - \\frac{u_t}{2}} = \\frac{2 + \\frac{\\bar{c}}{u_t}}{1 - \\frac{u_t}{2}}\n$$\n现在，代入给定的数值：$p = 1/3$，$c_{\\mathrm{hot}} = 2$ 和 $c_{\\mathrm{cold}} = 1/2$。\n$$\n\\bar{c} = \\frac{1}{3}(2) + \\left(1-\\frac{1}{3}\\right)\\left(\\frac{1}{2}\\right) = \\frac{2}{3} + \\frac{2}{3} \\cdot \\frac{1}{2} = \\frac{2}{3} + \\frac{1}{3} = 1\n$$\n因此，需要最小化的函数是：\n$$\nf(u_t) = E[W(u_t)] = \\frac{2 + \\frac{1}{u_t}}{1 - \\frac{u_t}{2}} = \\frac{\\frac{2u_t+1}{u_t}}{\\frac{2-u_t}{2}} = \\frac{2(2u_t+1)}{u_t(2-u_t)} = \\frac{4u_t+2}{2u_t - u_t^2}\n$$\n为了找到最小值，我们将 $f(u_t)$ 对 $u_t$ 求导，并令导数为 $0$。使用商法则，其中 $g(u_t) = 4u_t+2$ 且 $h(u_t) = 2u_t - u_t^2$：\n$$\n\\frac{df}{du_t} = \\frac{(4)(2u_t - u_t^2) - (4u_t+2)(2 - 2u_t)}{(2u_t - u_t^2)^2}\n$$\n令分子为零以找到临界点：\n$$\n4(2u_t - u_t^2) - (4u_t+2)(2 - 2u_t) = 0\n$$\n$$\n(8u_t - 4u_t^2) - (8u_t - 8u_t^2 + 4 - 4u_t) = 0\n$$\n$$\n8u_t - 4u_t^2 - (4u_t - 8u_t^2 + 4) = 0\n$$\n$$\n8u_t - 4u_t^2 - 4u_t + 8u_t^2 - 4 = 0\n$$\n$$\n4u_t^2 + 4u_t - 4 = 0\n$$\n$$\nu_t^2 + u_t - 1 = 0\n$$\n我们求解这个关于 $u_t$ 的二次方程：\n$$\nu_t = \\frac{-1 \\pm \\sqrt{1^2 - 4(1)(-1)}}{2(1)} = \\frac{-1 \\pm \\sqrt{5}}{2}\n$$\n由于阈值 $u_t$ 必须在区间 $(0, 1)$ 内，我们取正根：\n$$\nu_t^{\\star} = \\frac{-1 + \\sqrt{5}}{2}\n$$\n$\\sqrt{5}$ 的值约等于 $2.236$，所以 $u_t^{\\star} \\approx \\frac{-1+2.236}{2} \\approx 0.618$，该值位于定义域 $(0,1)$ 内。二阶导数检验或对一阶导数符号的分析表明这是一个最小值。一阶导数的分子 $4(u_t^2 + u_t - 1)$ 是一个开口向上的抛物线，在两根之间为负，在其他地方为正。因此，函数 $f(u_t)$ 在 $u_t^{\\star}$ 之前递减，之后递增，从而证实了这是一个最小值。",
            "answer": "$$\\boxed{\\frac{-1 + \\sqrt{5}}{2}}$$"
        },
        {
            "introduction": "任何存储系统的设计都必须考虑其在发生崩溃（例如断电）后的恢复能力。本练习探讨了日志结构文件系统在遭遇“撕裂的检查点”（torn checkpoint）时的恢复过程，这是一个经典的故障场景。你将使用泊松过程和伯努利试验等概率论工具，来推导系统成功“前滚”（roll-forward）恢复的概率 $p_{rf}$。通过这个练习，你不仅能理解 LFS 的崩溃一致性机制，还能学会如何用数学模型来量化和分析系统的可靠性。",
            "id": "3654820",
            "problem": "一个存储系统使用日志结构文件系统（LFS）。该系统定期写入一个检查点区域，以捕获内存中的映射元数据。每个检查点都有副本并通过校验和进行保护，但电源故障可能会产生一个撕裂的检查点（torn checkpoint），使最新的检查点无效。考虑以下故障场景。\n\n在写入最新检查点期间发生电源故障，因此该检查点的两个副本都未能通过校验和验证（即一个撕裂的检查点）。因此，恢复必须从上一个有效检查点开始。设上一个有效检查点与崩溃之间经过的时间为 $\\Delta$。在此时间间隔 $(0,\\Delta]$ 内，LFS已将段（segment）附加到日志中。\n\n恢复过程如下：\n- 通过验证校验和来定位最后一个有效检查点，由于最新的检查点是撕裂的，因此回退到上一个有效检查点。\n- 从该检查点开始执行前滚扫描：对于每个完全写入的段，系统会验证带有校验和的段摘要块（segment-summary block）并重放其中包含的更新；在崩溃点处的部分写入的尾部，摘要的验证预计会失败，这标志着停止点。如果尾部的摘要虚假地显示为有效，恢复将会错误地解释尾部，并被视为失败。\n\n假设以下基于标准排队论和可靠性假设的概率模型：\n- 在 $(0,\\Delta]$ 内完成的完全写入的段的数量是一个泊松随机变量，其单位时间速率为 $\\lambda$，因此平均数量为 $\\lambda \\Delta$。\n- 每个完全写入的段的摘要块独立地以概率 $q$ 成功验证。\n- 最终的部分写入的尾部的摘要以概率 $\\beta$ 虚假地显示为有效；恢复要求此事件不发生。\n\n定义 $p_{rf}$ 为在前述撕裂检查点场景下，前滚成功的概率。从这些假设以及泊松过程和独立伯努利试验的第一性原理出发，推导出一个关于 $\\lambda$、$\\Delta$、$q$ 和 $\\beta$ 的 $p_{rf}$ 的封闭形式解析表达式。将您的最终答案表示为单个简化表达式。不需要进行数值计算，也不需要单位。",
            "solution": "该问题被认为是有效的，因为它具有科学依据、问题定义清晰、客观，并包含得出唯一解所需的所有必要信息。它展示了计算机系统可靠性分析中的一个标准概率建模场景。\n\n设 $p_{rf}$ 为前滚恢复过程成功的概率。根据问题描述，成功恢复需要两个独立事件同时发生：\n1. 事件 $A$：在时间间隔 $(0, \\Delta]$ 内完成的所有完全写入的段，其段摘要块都成功通过验证。\n2. 事件 $B$：最终的部分写入的尾部段的摘要*没有*虚假地显示为有效。\n\n问题陈述这些事件是独立的。因此，成功的总概率是这两个事件概率的乘积：\n$$p_{rf} = P(A) \\times P(B)$$\n\n我们首先确定事件 $B$ 的概率。问题陈述尾部的摘要以概率 $\\beta$ 虚假地显示为有效。为了使恢复成功，此事件不得发生。其互补事件（摘要按预期未能通过验证）的概率是：\n$$P(B) = 1 - \\beta$$\n\n现在，我们来确定事件 $A$ 的概率。在时间间隔 $(0, \\Delta]$ 内完全写入的段的数量不是一个固定的数，而是一个随机变量。我们用 $N$ 表示这个随机变量。问题陈述 $N$ 服从均值为 $\\lambda \\Delta$ 的泊松分布。$N$ 的概率质量函数（PMF）由下式给出：\n$$P(N=k) = \\frac{(\\lambda\\Delta)^{k} \\exp(-\\lambda\\Delta)}{k!} \\quad \\text{for } k = 0, 1, 2, \\dots$$\n其中 $k$ 是完全写入的段的数量。\n\n为了求出事件 $A$ 的概率，我们必须考虑 $N$ 的所有可能值。我们可以使用全概率公式，对所有可能的段数 $k$ 进行求和：\n$$P(A) = \\sum_{k=0}^{\\infty} P(A | N=k) P(N=k)$$\n$P(A | N=k)$ 项是在有 $k$ 个完全写入的段的情况下，所有段摘要都成功验证的条件概率。问题陈述每个摘要块独立地以概率 $q$ 验证成功。对于 $k$ 个独立的段，它们全部验证成功的概率是它们各自概率的乘积：\n$$P(A | N=k) = q^k$$\n\n现在，我们可以将这个结果和 $N$ 的概率质量函数代回到 $P(A)$ 的求和式中：\n$$P(A) = \\sum_{k=0}^{\\infty} (q^k) \\left( \\frac{(\\lambda\\Delta)^{k} \\exp(-\\lambda\\Delta)}{k!} \\right)$$\n我们可以将不依赖于求和索引 $k$ 的项提取出来：\n$$P(A) = \\exp(-\\lambda\\Delta) \\sum_{k=0}^{\\infty} q^k \\frac{(\\lambda\\Delta)^{k}}{k!}$$\n我们将求和式内部的 $k$ 次方项合并：\n$$P(A) = \\exp(-\\lambda\\Delta) \\sum_{k=0}^{\\infty} \\frac{(q\\lambda\\Delta)^{k}}{k!}$$\n求和项是指数函数的麦克劳林级数展开式，$\\sum_{j=0}^{\\infty} \\frac{x^j}{j!} = \\exp(x)$。在我们的例子中，参数 $x$ 是 $q\\lambda\\Delta$。因此，该和的计算结果为：\n$$\\sum_{k=0}^{\\infty} \\frac{(q\\lambda\\Delta)^{k}}{k!} = \\exp(q\\lambda\\Delta)$$\n将此结果代回到 $P(A)$ 的表达式中：\n$$P(A) = \\exp(-\\lambda\\Delta) \\exp(q\\lambda\\Delta)$$\n使用指数属性 $\\exp(x)\\exp(y) = \\exp(x+y)$，我们得到：\n$$P(A) = \\exp(-\\lambda\\Delta + q\\lambda\\Delta) = \\exp(\\lambda\\Delta(q-1))$$\n\n最后，我们将事件 $A$ 和事件 $B$ 的概率结合起来，求出成功前滚的总概率 $p_{rf}$：\n$$p_{rf} = P(A) \\times P(B) = \\exp(\\lambda\\Delta(q-1)) \\times (1 - \\beta)$$\n这就得出了关于给定参数的 $p_{rf}$ 的封闭形式解析表达式。",
            "answer": "$$\\boxed{(1 - \\beta) \\exp(\\lambda \\Delta (q - 1))}$$"
        }
    ]
}