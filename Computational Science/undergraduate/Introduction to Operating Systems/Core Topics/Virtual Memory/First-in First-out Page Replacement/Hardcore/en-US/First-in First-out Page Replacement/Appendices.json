{
    "hands_on_practices": [
        {
            "introduction": "The first step toward mastering any algorithm is to trace its execution manually. This practice develops an intuitive feel for the First-In, First-Out (FIFO) mechanism by having you track the state of the page frames for a given sequence of memory references. By carefully simulating the process, you will see exactly how the queue's strict chronological ordering dictates which pages are loaded and, more importantly, which are evicted .",
            "id": "3644489",
            "problem": "A process executes under a demand-paged virtual memory in an Operating System (OS). The First-In, First-Out (FIFO) page replacement policy maintains a queue ordered by time of insertion into the set of page frames: the oldest page (at the queue front) is the first to be evicted on a miss when memory is full, and the queue ordering does not change on a hit. Initially, all page frames are empty. The reference string is $S = [2,3,2,1,5,2,4,5,3,2,5,2]$, and the number of available page frames is $k = 3$. \n\nStarting from the core definitions of demand paging, page fault, and FIFO queue behavior, reconstruct the FIFO queue state at each reference in $S$, explicitly identifying at each step whether the access is a hit or a miss, and if a miss, which page is evicted. Explain how any counterintuitive behaviors you observe arise from the queue ordering and the fact that FIFO does not adjust ordering on hits.\n\nCompute the total number of page faults incurred over the entire reference string under FIFO with $k=3$. Provide your final answer as a single integer. No rounding is required.",
            "solution": "The problem requires an analysis of the First-In, First-Out (FIFO) page replacement algorithm within a demand-paged virtual memory system. We must reconstruct the state of memory for a given reference string and calculate the total number of page faults.\n\nThe fundamental principle of demand paging is that a page is loaded into main memory from secondary storage only when it is referenced and is not already present. An attempt to access a page not in memory is called a page fault or a miss. An access to a page that is already in memory is a hit. The system has a fixed number of physical memory slots called page frames, denoted by $k$. In this problem, $k=3$.\n\nThe FIFO page replacement policy manages the set of pages in memory as a queue. When a page is loaded into memory, it is added to the rear of this queue. When a page fault occurs and all page frames are occupied, the page at the front of the queue (the one that has been in memory the longest) is selected for eviction. The problem statement specifies a critical feature of the FIFO policy: the queue ordering is determined solely by the time of insertion and does not change upon a hit. The oldest page remains the oldest, regardless of how recently or frequently it has been accessed.\n\nWe are given the reference string $S = [2,3,2,1,5,2,4,5,3,2,5,2]$ and $k=3$ available page frames. Initially, all frames are empty. We will trace the state of the FIFO queue (representing pages in memory) and the number of page faults for each reference. The queue front is on the left, and the rear is on the right.\n\n1.  Reference to page $2$: The frames are empty. This is a miss. Page $2$ is loaded.\n    -   Page Faults: $1$.\n    -   FIFO Queue: $[2]$.\n\n2.  Reference to page $3$: The frames are not full. This is a miss. Page $3$ is loaded.\n    -   Page Faults: $1+1 = 2$.\n    -   FIFO Queue: $[2, 3]$.\n\n3.  Reference to page $2$: Page $2$ is already in memory. This is a hit.\n    -   Page Faults: $2$.\n    -   FIFO Queue: $[2, 3]$ (unchanged). Page $2$ remains the oldest page.\n\n4.  Reference to page $1$: The frames are not full. This is a miss. Page $1$ is loaded.\n    -   Page Faults: $2+1 = 3$.\n    -   FIFO Queue: $[2, 3, 1]$. The frames are now full.\n\n5.  Reference to page $5$: Page $5$ is not in memory, and the frames are full. This is a miss. The page at the front of the queue, page $2$, is evicted. Page $5$ is inserted at the rear.\n    -   Page Faults: $3+1 = 4$.\n    -   FIFO Queue: $[3, 1, 5]$.\n\n6.  Reference to page $2$: Page $2$ is not in memory. This is a miss. The page at the front of the queue, page $3$, is evicted. Page $2$ is inserted at the rear.\n    -   Page Faults: $4+1 = 5$.\n    -   FIFO Queue: $[1, 5, 2]$.\n\n7.  Reference to page $4$: Page $4$ is not in memory. This is a miss. The page at the front of the queue, page $1$, is evicted. Page $4$ is inserted at the rear.\n    -   Page Faults: $5+1 = 6$.\n    -   FIFO Queue: $[5, 2, 4]$.\n\n8.  Reference to page $5$: Page $5$ is in memory. This is a hit.\n    -   Page Faults: $6$.\n    -   FIFO Queue: $[5, 2, 4]$ (unchanged).\n\n9.  Reference to page $3$: Page $3$ is not in memory. This is a miss. The page at the front of the queue, page $5$, is evicted. Page $3$ is inserted at the rear.\n    -   Page Faults: $6+1 = 7$.\n    -   FIFO Queue: $[2, 4, 3]$.\n\n10. Reference to page $2$: Page $2$ is in memory. This is a hit.\n    -   Page Faults: $7$.\n    -   FIFO Queue: $[2, 4, 3]$ (unchanged). Page $2$ remains the oldest page.\n\n11. Reference to page $5$: Page $5$ is not in memory. This is a miss. The page at the front of the queue, page $2$, is evicted. Page $5$ is inserted at the rear.\n    -   Page Faults: $7+1 = 8$.\n    -   FIFO Queue: $[4, 3, 5]$.\n\n12. Reference to page $2$: Page $2$ is not in memory. This is a miss. The page at the front of the queue, page $4$, is evicted. Page $2$ is inserted at the rear.\n    -   Page Faults: $8+1 = 9$.\n    -   FIFO Queue: $[3, 5, 2]$.\n\nThe simulation is complete. The total number of page faults is $9$.\n\nThe counterintuitive behavior of FIFO is clearly observed in this trace. For instance, at step $3$, page $2$ is referenced (a hit), indicating it is being actively used. However, because FIFO's queue ordering does not change on a hit, page $2$ remains the \"oldest\" page. Consequently, at step $5$, when a page must be evicted to make room for page $5$, the recently used page $2$ is chosen as the victim simply because it was the first one loaded among the current residents. An algorithm like Least Recently Used (LRU) would have considered page $2$ as the most recently used after the hit at step $3$ and would have protected it from eviction at step $5$. The FIFO policy's ignorance of access patterns leads to the eviction of potentially useful pages, which can increase the page fault rate. This is evident in the repeated faults on page $2$ (steps $6, 12$) shortly after its eviction. This phenomenon, where an algorithm that seems simple and fair performs poorly, is a key lesson in the study of page replacement algorithms.",
            "answer": "$$\\boxed{9}$$"
        },
        {
            "introduction": "While FIFO is simple to understand, its simplicity hides a surprising and famous flaw. Intuition suggests that allocating more resources—in this case, more memory frames—should always improve performance. This exercise demonstrates that for FIFO, this is not always true, guiding you to discover a paradox known as Belady's anomaly, where more memory can actually lead to more page faults .",
            "id": "3623347",
            "problem": "A demand-paged virtual memory system maintains a fixed-size set of physical frames and replaces pages on a fault using the First-In First-Out (FIFO) policy, where the page that has resided in memory the longest (i.e., the first that arrived) is evicted. A page fault occurs whenever a referenced page is not currently resident in any frame. Assume that all frames are initially empty and that a reference loads the page into a free frame if one exists; otherwise, the FIFO policy evicts the oldest resident page before loading the new one. Let $f_{\\text{FIFO}}(k)$ denote the total number of page faults when using $k$ frames under FIFO for a given reference string.\n\nGiven the classical reference sequence $S = (1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5)$, compute $f_{\\text{FIFO}}(3)$ and $f_{\\text{FIFO}}(4)$, and, starting from the above definitions, explain why the resulting values exemplify Belady's anomaly, wherein increasing the number of frames can increase the number of page faults under the FIFO policy.\n\nExpress your final answer as a two-entry row matrix $\\begin{pmatrix} f_{\\text{FIFO}}(3) & f_{\\text{FIFO}}(4) \\end{pmatrix}$ with exact integer values. No rounding is required.",
            "solution": "The problem statement is entirely self-contained, scientifically grounded in the principles of operating system memory management, and well-posed. All terms are standard and clearly defined, providing a basis for a unique and verifiable solution. Thus, the problem is deemed valid.\n\nThe task is to compute the number of page faults for a given reference string $S = (1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5)$ using a First-In First-Out (FIFO) page replacement policy with $k=3$ and $k=4$ frames, denoted by $f_{\\text{FIFO}}(3)$ and $f_{\\text{FIFO}}(4)$ respectively. Subsequently, we must explain why the result demonstrates Belady's anomaly.\n\nThe FIFO policy operates like a queue. When a page must be evicted, the one that has been in memory for the longest time is chosen. We will trace the state of the memory frames for each case. A page fault is indicated by 'F' and a hit by 'H'. The frames' contents represent the set of pages currently in memory. The \"Arrival Order\" queue shows the pages from oldest to newest.\n\n**Case 1: $k=3$ frames**\n\nWe simulate the process step-by-step for $f_{\\text{FIFO}}(3)$.\n\n| Reference | Page | Frames (Set)  | Fault/Hit | Arrival Order (Oldest $\\rightarrow$ Newest) | Action                               |\n|-----------|------|---------------|-----------|---------------------------------------------|--------------------------------------|\n| 1         | $1$  | $\\{1\\}$       | F         | $[1]$                                       | Load $1$ into an empty frame.          |\n| 2         | $2$  | $\\{1, 2\\}$    | F         | $[1, 2]$                                    | Load $2$ into an empty frame.          |\n| 3         | $3$  | $\\{1, 2, 3\\}$ | F         | $[1, 2, 3]$                                 | Load $3$ into an empty frame.          |\n| 4         | $4$  | $\\{2, 3, 4\\}$ | F         | $[2, 3, 4]$                                 | Evict $1$ (oldest), load $4$.          |\n| 5         | $1$  | $\\{3, 4, 1\\}$ | F         | $[3, 4, 1]$                                 | Evict $2$ (oldest), load $1$.          |\n| 6         | $2$  | $\\{4, 1, 2\\}$ | F         | $[4, 1, 2]$                                 | Evict $3$ (oldest), load $2$.          |\n| 7         | $5$  | $\\{1, 2, 5\\}$ | F         | $[1, 2, 5]$                                 | Evict $4$ (oldest), load $5$.          |\n| 8         | $1$  | $\\{1, 2, 5\\}$ | H         | $[1, 2, 5]$                                 | Page $1$ is in memory.               |\n| 9         | $2$  | $\\{1, 2, 5\\}$ | H         | $[1, 2, 5]$                                 | Page $2$ is in memory.               |\n| 10        | $3$  | $\\{2, 5, 3\\}$ | F         | $[2, 5, 3]$                                 | Evict $1$ (oldest), load $3$.          |\n| 11        | $4$  | $\\{5, 3, 4\\}$ | F         | $[5, 3, 4]$                                 | Evict $2$ (oldest), load $4$.          |\n| 12        | $5$  | $\\{5, 3, 4\\}$ | H         | $[5, 3, 4]$                                 | Page $5$ is in memory.               |\n\nCounting the number of faults (F), we find there are $9$ page faults.\nTherefore, $f_{\\text{FIFO}}(3) = 9$.\n\n**Case 2: $k=4$ frames**\n\nNext, we simulate the process for $f_{\\text{FIFO}}(4)$.\n\n| Reference | Page | Frames (Set)    | Fault/Hit | Arrival Order (Oldest $\\rightarrow$ Newest) | Action                               |\n|-----------|------|-----------------|-----------|---------------------------------------------|--------------------------------------|\n| 1         | $1$  | $\\{1\\}$         | F         | $[1]$                                       | Load $1$ into an empty frame.          |\n| 2         | $2$  | $\\{1, 2\\}$      | F         | $[1, 2]$                                    | Load $2$ into an empty frame.          |\n| 3         | $3$  | $\\{1, 2, 3\\}$   | F         | $[1, 2, 3]$                                 | Load $3$ into an empty frame.          |\n| 4         | $4$  | $\\{1, 2, 3, 4\\}$| F         | $[1, 2, 3, 4]$                              | Load $4$ into an empty frame.          |\n| 5         | $1$  | $\\{1, 2, 3, 4\\}$| H         | $[1, 2, 3, 4]$                              | Page $1$ is in memory.               |\n| 6         | $2$  | $\\{1, 2, 3, 4\\}$| H         | $[1, 2, 3, 4]$                              | Page $2$ is in memory.               |\n| 7         | $5$  | $\\{2, 3, 4, 5\\}$| F         | $[2, 3, 4, 5]$                              | Evict $1$ (oldest), load $5$.          |\n| 8         | $1$  | $\\{3, 4, 5, 1\\}$| F         | $[3, 4, 5, 1]$                              | Evict $2$ (oldest), load $1$.          |\n| 9         | $2$  | $\\{4, 5, 1, 2\\}$| F         | $[4, 5, 1, 2]$                              | Evict $3$ (oldest), load $2$.          |\n| 10        | $3$  | $\\{5, 1, 2, 3\\}$| F         | $[5, 1, 2, 3]$                              | Evict $4$ (oldest), load $3$.          |\n| 11        | $4$  | $\\{1, 2, 3, 4\\}$| F         | $[1, 2, 3, 4]$                              | Evict $5$ (oldest), load $4$.          |\n| 12        | $5$  | $\\{2, 3, 4, 5\\}$| F         | $[2, 3, 4, 5]$                              | Evict $1$ (oldest), load $5$.          |\n\nCounting the number of faults (F), we find there are $10$ page faults.\nTherefore, $f_{\\text{FIFO}}(4) = 10$.\n\n**Explanation of Belady's Anomaly**\n\nThe computed values are $f_{\\text{FIFO}}(3) = 9$ and $f_{\\text{FIFO}}(4) = 10$. We observe that $f_{\\text{FIFO}}(4) > f_{\\text{FIFO}}(3)$. This phenomenon, where increasing the number of allocated memory frames leads to an increase in the number of page faults, is known as Belady's anomaly. It is a counterintuitive result because one would generally expect more resources (i.e., more frames) to improve performance (i.e., cause fewer faults).\n\nThe anomaly occurs because the FIFO replacement algorithm does not consider the usage history or future likelihood of a page being referenced; it only considers the arrival time. The specific reason for the anomaly in this example can be pinpointed by comparing the frame states.\n\nAt reference $7$, the string requests page $5$.\n- In the $k=3$ case, the frames contain $\\{2, 3, 4\\}$, with page $1$ having been evicted at reference $4$. The oldest page is $2$, but the frames are $\\{4, 1, 2\\}$ just before reference 7 according to the trace. Let's be precise. Just before reference 7, the frames are $\\{4, 1, 2\\}$ with arrival order $[4, 1, 2]$. Page $4$ is the oldest and is evicted to load page $5$. The new state is $\\{1, 2, 5\\}$. Crucially, pages $1$ and $2$ remain in memory. The subsequent references to $1$ and $2$ are hits.\n- In the $k=4$ case, the frames contain $\\{1, 2, 3, 4\\}$. The oldest page is $1$. To load page $5$, page $1$ is evicted. The new state is $\\{2, 3, 4, 5\\}$. This eviction is detrimental because page $1$ is requested on the very next step (reference $8$), causing an immediate page fault.\n\nThe larger frame set ($k = 4$) allowed the \"wrong\" page (page $1$, which was needed again soon) to become the oldest resident and thus the victim for replacement. In contrast, the smaller frame set ($k = 3$) had already evicted pages that were not immediately needed, leading to a frame composition that fortuitously performed better on the subsequent references.\n\nBelady's anomaly is characteristic of page replacement algorithms that are not \"stack algorithms.\" A stack algorithm has the property that the set of pages in memory with $k$ frames is always a subset of the pages in memory with $k+1$ frames at any point in the reference string. FIFO does not satisfy this property, as demonstrated here: after reference $7$, the frame set for $k=3$ is $\\{1, 2, 5\\}$, while for $k=4$ it is $\\{2, 3, 4, 5\\}$. The former is not a subset of the latter.\n\nThe final computed values are presented as a two-entry row matrix.",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 9 & 10 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "Theoretical knowledge becomes practical skill when you can translate an algorithm into working code. This practice challenges you to move from tracing on paper to building a functional simulation of the FIFO policy from first principles. You will implement the core logic using a queue built from a singly linked list, a classic and efficient approach that solidifies your understanding of both the algorithm and the underlying data structures .",
            "id": "3246836",
            "problem": "Design and implement a complete, runnable program that simulates the First-In First-Out (FIFO) page replacement policy of an Operating System (OS) virtual memory manager using a queue of page frames implemented as a singly linked list. The simulation must be grounded in first principles of data structures: a queue is defined by the operations of enqueuing and dequeuing with the invariant that elements are removed in the order they were inserted, and a singly linked list is defined as a sequence of nodes where each node contains a value and a pointer to the next node, with the head and tail pointers enabling insertion at the tail and removal from the head in time proportional to $O(1)$. Page replacement is defined as the process of deciding which existing page frame to evict when a new page must be loaded while the set of frames is full. Under First-In First-Out (FIFO), the page that has resided the longest without regard to future use is evicted, which is precisely the head of the queue.\n\nStart from the following core definitions and facts:\n- A queue $Q$ maintains a sequence of elements with the operations enqueue and dequeue satisfying the invariant that dequeue removes the element that has been in the queue the longest.\n- A singly linked list supports $O(1)$ insertion at the tail and $O(1)$ removal at the head when both head and tail pointers are maintained, and $O(n)$ membership check in the general case, where $n$ denotes the number of nodes.\n- A page reference string $R$ is a sequence of page numbers, and a frame capacity $C$ is a nonnegative integer indicating the maximum number of pages that can reside simultaneously in memory.\n- A page hit occurs when the referenced page is already resident; a page fault occurs when it is not. On a fault:\n  - If the queue size is less than $C$, enqueue the page to the tail without eviction.\n  - If the queue size equals $C$, dequeue the head (the oldest page) and then enqueue the new page to the tail.\n\nImplement the queue as a singly linked list with explicit node objects; do not use built-in array-resident queue abstractions. Use the queue for all residency and eviction logic. The only allowable use of built-in arrays (lists) is for representing the input reference strings and aggregating the final results for output.\n\nFor each test case, compute:\n- The integer count of page faults $F$.\n- The integer count of page hits $H$.\n- The page fault rate $f = F / |R|$ as a decimal number rounded to four decimal places (and defined to be $0$ when $|R| = 0$).\n\nYour program must apply the simulation to the following test suite, where $C$ denotes the frame capacity and $R$ the page reference string:\n- Case $1$: $C = 3$, $R = [7,0,1,2,0,3,0,4,2,3,0,3,2]$.\n- Case $2$: $C = 1$, $R = [1,2,3,4,1]$.\n- Case $3$: $C = 4$, $R = [1,1,1,1,1,1]$.\n- Case $4$: $C = 4$, $R = []$.\n- Case $5$: $C = 4$, $R = [1,2,3,4]$.\n\nThe final output format must aggregate the results for all test cases in order as a single line containing a comma-separated list enclosed in square brackets, with each test case contributing a list of three values $[F,H,f]$. For example, the output must be of the form $[[F_1,H_1,f_1],[F_2,H_2,f_2],\\dots]$. No other text may be printed.",
            "solution": "The problem statement has been analyzed and is determined to be **valid**. It is scientifically grounded in the established principles of operating systems and data structures, specifically the First-In First-Out (FIFO) page replacement algorithm and its implementation using a singly linked list-based queue. The problem is well-posed, providing all necessary definitions, constraints, and test cases to derive a unique, verifiable solution. The objectives are stated with clear, unambiguous language.\n\nThe task is to simulate the FIFO page replacement policy. This policy dictates that when a page needs to be loaded into a full set of memory frames, the page that has been in memory for the longest time is the one to be evicted. This behavior is perfectly modeled by a queue data structure, which operates on a First-In, First-Out principle. The problem requires this queue to be implemented from first principles using a singly linked list.\n\nFirst, we define the necessary data structures. A singly linked list is composed of nodes. Each `Node` will store a `value`, representing the page number, and a `next` pointer, which references the subsequent node in the list.\n\n$$\n\\text{Node} = (\\text{value}, \\text{next})\n$$\n\nNext, we construct the `Queue` class. This class will manage the collection of nodes and must maintain pointers to both the `head` (the first element) and the `tail` (the last element) of the list. It will also track its current `size`. These attributes allow for the fundamental queue operations—enqueue and dequeue—to be performed in constant time, $O(1)$.\n\n-   `head`: A pointer to the first `Node` in the queue. This is the page that has been resident the longest.\n-   `tail`: A pointer to the last `Node` in the queue. This is the most recently added page.\n-   `size`: An integer count of the number of nodes currently in the queue.\n\nThe `Queue` class will implement the following methods:\n1.  `enqueue(value)`: This operation adds a new page to the memory. A new `Node` containing the `value` is created. If the queue is empty (`size = 0`), both `head` and `tail` pointers are set to this new node. Otherwise, the `next` pointer of the current `tail` node is updated to point to the new node, and the `tail` pointer is then updated to this new node. The `size` is incremented. This is an $O(1)$ operation.\n2.  `dequeue()`: This operation evicts the oldest page from memory. It removes the node at the `head` of the queue. The `value` of the `head` node is retrieved, and the `head` pointer is advanced to the next node (`head.next`). If the queue becomes empty after this removal, the `tail` pointer must also be set to `None`. The `size` is decremented. This is an $O(1)$ operation.\n3.  `contains(value)`: This operation checks if a page is already resident in memory. It requires traversing the linked list from the `head` to the `tail`, comparing the `value` of each node with the target value. The operation returns `True` if the value is found and `False` otherwise. As stipulated in the problem, this is an $O(n)$ operation, where $n$ is the current number of pages in the frames.\n\nThe simulation proceeds by processing a given page reference string, $R$, with a fixed frame capacity, $C$. We initialize a page fault counter, $F$, and a page hit counter, $H$, to $0$. We then iterate through each page reference, $p$, in $R$.\n\nFor each page $p$:\n-   We first check for its presence in our queue using the `contains(p)` method.\n-   **Case 1: Page Hit.** If `contains(p)` returns `True`, the page is already in memory. We increment the hit counter, $H$. The state of the queue remains unchanged, as FIFO does not alter the order of pages upon a hit.\n-   **Case 2: Page Fault.** If `contains(p)` returns `False`, the page is not in memory, and a page fault occurs. We increment the fault counter, $F$, and proceed with the following logic:\n    -   If the number of pages in memory is less than the capacity $C$ (i.e., `queue.size < C`), there is an empty frame. The new page $p$ is added to memory by calling `enqueue(p)`.\n    -   If memory is full (i.e., `queue.size == C`), a page must be replaced. According to the FIFO policy, we evict the oldest page by calling `dequeue()`. Then, we load the new page $p$ into the newly freed frame by calling `enqueue(p)`.\n\nAfter iterating through the entire reference string $R$, the simulation for one test case is complete. We then compute the required metrics:\n-   Total page faults: $F$\n-   Total page hits: $H$\n-   Page fault rate: $f$. This is calculated as the ratio of total faults to the total number of references, $f = F / |R|$. As specified, if the length of the reference string $|R|$ is $0$, the fault rate $f$ is defined to be $0$. The result is rounded to four decimal places.\n\nThis process is repeated for each test case provided in the problem statement, and the results $[F, H, f]$ for each case are aggregated into a final list for output.",
            "answer": "```python\ndef solve():\n    \"\"\"\n    Solves the FIFO page replacement simulation problem for the given test suite.\n    \"\"\"\n\n    class Node:\n        \"\"\"\n        A node in a singly linked list.\n        \"\"\"\n        def __init__(self, value):\n            self.value = value\n            self.next = None\n\n    class Queue:\n        \"\"\"\n        A queue implemented with a singly linked list, designed for FIFO simulation.\n        It supports O(1) enqueue and dequeue, and O(n) membership checking.\n        \"\"\"\n        def __init__(self):\n            self.head = None\n            self.tail = None\n            self.size = 0\n\n        def enqueue(self, value):\n            \"\"\"Adds an element to the tail of the queue in O(1).\"\"\"\n            new_node = Node(value)\n            if self.tail is None:\n                self.head = self.tail = new_node\n            else:\n                self.tail.next = new_node\n                self.tail = new_node\n            self.size += 1\n\n        def dequeue(self):\n            \"\"\"Removes an element from the head of the queue in O(1).\"\"\"\n            if self.head is None:\n                return None\n            \n            value = self.head.value\n            self.head = self.head.next\n            if self.head is None:\n                self.tail = None\n            \n            self.size -= 1\n            return value\n\n        def contains(self, value):\n            \"\"\"Checks if a value is in the queue by traversing the list in O(n).\"\"\"\n            current = self.head\n            while current:\n                if current.value == value:\n                    return True\n                current = current.next\n            return False\n\n    def fifo_simulation(capacity, ref_string):\n        \"\"\"\n        Simulates the FIFO page replacement algorithm.\n\n        Args:\n            capacity (int): The number of page frames.\n            ref_string (list[int]): The sequence of page references.\n\n        Returns:\n            tuple[int, int, float]: A tuple containing page faults (F),\n                                    page hits (H), and fault rate (f).\n        \"\"\"\n        page_frames = Queue()\n        page_faults = 0\n        page_hits = 0\n        \n        for page in ref_string:\n            if page_frames.contains(page):\n                page_hits += 1\n            else:\n                page_faults += 1\n                if page_frames.size == capacity:\n                    page_frames.dequeue()\n                page_frames.enqueue(page)\n        \n        num_references = len(ref_string)\n        if num_references == 0:\n            fault_rate = 0.0\n        else:\n            fault_rate = page_faults / num_references\n            \n        return page_faults, page_hits, fault_rate\n\n    # The test suite provided in the problem description.\n    test_cases = [\n        # Case 1\n        (3, [7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2]),\n        # Case 2\n        (1, [1, 2, 3, 4, 1]),\n        # Case 3\n        (4, [1, 1, 1, 1, 1, 1]),\n        # Case 4\n        (4, []),\n        # Case 5\n        (4, [1, 2, 3, 4]),\n    ]\n\n    all_results = []\n    for C, R in test_cases:\n        F, H, f = fifo_simulation(C, R)\n        all_results.append([F, H, f])\n\n    # Format the final output string exactly as required.\n    result_strings = []\n    for F, H, f in all_results:\n        # Format float to four decimal places.\n        f_str = f\"{f:.4f}\"\n        result_strings.append(f\"[{F},{H},{f_str}]\")\n        \n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```"
        }
    ]
}