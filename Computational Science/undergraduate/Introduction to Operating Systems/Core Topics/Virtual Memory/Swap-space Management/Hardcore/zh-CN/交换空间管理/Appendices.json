{
    "hands_on_practices": [
        {
            "introduction": "要真正掌握操作系统算法，没有什么比从头开始构建一个模拟器更好的方法了。这个实践练习将指导您实现一个模拟器，用于比较两种核心策略：简单的先进先出（FIFO）策略和理想化的、具有前瞻性的优先级策略。通过这个练习 ()，您将巩固对页面替换和交换槽管理核心机制的理解。",
            "id": "3685067",
            "problem": "你需要实现一个完整的、可运行的程序，模拟一个玩具操作系统的交换空间管理和页面替换行为。该模拟器必须量化管理页框和交换槽的队列策略如何影响在给定的页面引用轨迹下磁盘页面调入错误的总数。设置、参数、规则和所需的输出格式在下文中已精确指定。\n\n其基础由操作系统中的以下标准定义和事实构成：内存访问指向一个虚拟页面；一个物理页框可以容纳一个页面；当引用的页面不存在于物理页框中时，会发生页面错误，并且必须从辅助存储中调入该页面；当驻留页面的数量等于页框的数量时，必须选择一个页面进行替换以释放一个页框。该模拟器必须实现两种可选的队列策略：先进先出（FIFO）和一种理想化的优先级方案，该方案使用未来使用距离来优先保留将更快被重用的页面。一个页面在轨迹中位置 $i$ 的未来使用距离，是指该页面再次出现在位置 $i + d$ 处的最小正整数 $d$；如果它不再出现，则距离为 $+\\infty$。该优先级方案总是优先置换具有最大未来使用距离的驻留页面（若距离相同，则由最早的加载时间确定性地打破平局），这是一个为比较研究而明确定义的理想化模型。\n\n你必须为每个测试用例模拟两种配置：\n- 配置 A (FIFO/FIFO)：页框通过 FIFO 队列进行替换管理，交换槽在满时通过 FIFO 队列进行回收管理。\n- 配置 B (PRIO/PRIO)：页框通过优先级规则进行管理，该规则置换具有最大未来使用距离的驻留页面；交换槽在满时通过移除具有最大未来使用距离的换出页面来进行回收。\n\n交换空间管理建模如下。共有 $U$ 个交换槽。当一个页面从内存中被置换出来时，如果存在可用的交换槽，它将占用一个；如果所有 $U$ 个槽都已被使用，则必须根据当前配置的交换队列策略丢弃一个已换出的页面，以释放一个槽位。如果一个非驻留页面被引用，无论它是否存在于交换空间中，都会导致一次磁盘页面调入错误。模拟器只需计算磁盘页面调入错误的总数，即每次引用当前非驻留页面时计为一次；命中不增加此计数。没有预取，也没有显式的释放事件；唯一的事件是轨迹中的页面引用。\n\n基于这些基本原理，为模拟器实现以下精确规则：\n- 有 $F$ 个物理页框。初始时，所有页框均为空，交换空间也为空。\n- 对于轨迹索引 $i$ 处对页面 $p_i$ 的每次引用：\n  - 如果 $p_i$ 驻留在 $F$ 个页框之一中，则为命中，不计入错误。\n  - 否则，页面调入错误计数加一（$+1$）。如果驻留页面数小于 $F$，则将 $p_i$ 加载到一个空闲页框中。否则，选择一个驻留页面进行置换：\n    - 在配置 A 中，置换在内存中停留时间最长的驻留页面（基于加载时间的 FIFO）。\n    - 在配置 B 中，置换从索引 $i$ 算起未来使用距离最大的驻留页面；如果多个页面距离相同，则置换其中最早加载的页面。\n  - 置换页面时，如果存在空闲的交换槽，则将其放入其中；否则，通过移除以下页面来回收一个交换槽：\n    - 在配置 A 中，移除在交换空间中停留时间最长的换出页面（FIFO）。\n    - 在配置 B 中，移除从索引 $i$ 算起未来使用距离最大的换出页面；如果多个页面距离相同，则确定性地移除其中任何一个。\n  - 如果 $p_i$ 恰好存在于某个交换槽中，在将其加载到内存时，需将其从交换空间中移除；这不改变错误计数。\n\n你的程序必须精确实现上述逻辑，并为每个测试用例在每种配置下产出页面调入错误的总数。\n\n测试套件。使用以下测试用例；对于每个用例，$F$ 是页框数量，$U$ 是交换槽数量，sequence 是作为有序整数列表的页面引用轨迹。以下所有数字必须解释为页面或容量，而非物理单位。\n\n- 测试 $1$：$F = 3$，$U = 2$，序列 $[1,2,3,4,1,2,3,4]$。\n- 测试 $2$：$F = 2$，$U = 1$，序列 $[1,2,1,3,1,2,1,3]$。\n- 测试 $3$：$F = 2$，$U = 2$，序列 $[1,2,1,2,1,2]$。\n- 测试 $4$：$F = 5$，$U = 3$，序列 $[1,2,3,4,1,2,3,4,2,3,1]$。\n- 测试 $5$：$F = 2$，$U = 0$，序列 $[1,2,3,2,1,2,3,2]$。\n\n你的程序必须为每个测试用例计算在配置 A 和配置 B 下的错误总数，并按此顺序排列。最终输出格式要求为单行，包含一个整数列表的列表，其中每个内部列表对应于上述顺序的一个测试用例，并包含两个整数：$[\\text{faults}_\\text{FIFO}, \\text{faults}_\\text{PRIO}]$。例如，输出格式必须严格为\n`\"[ [a,b],[c,d],[e,f],[g,h],[i,j] ]\"` 的形式，除了示例中逗号和括号所用的空格外，不包含其他空格。你的程序必须精确地产生这样一行格式的输出，并且不得读取任何输入。",
            "solution": "该问题要求为一个玩具操作系统实现一个页面替换和交换空间管理的模拟器。模拟必须针对五个测试用例进行，每个用例在两种不同配置下运行，并报告每次运行的页面调入错误总数。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n-   **核心实体**：虚拟页面、物理页框、交换槽。\n-   **每个测试用例的参数**：\n    -   $F$：物理页框数量。\n    -   $U$：交换槽数量。\n    -   `sequence`：页面引用轨迹（一个有序整数列表）。\n-   **关键定义**：当引用的页面未驻留在物理页框中时，发生页面错误，并计数为 $+1$。\n-   **初始状态**：所有 $F$ 个页框和 $U$ 个交换槽均为空。\n-   **事件**：在轨迹索引 $i$ 处引用页面 $p_i$。\n-   **命中逻辑**：如果 $p_i$ 在页框中，则为命中；不计入错误。\n-   **错误逻辑**：\n    1.  错误计数加一（$+1$）。\n    2.  如果页框未满（驻留页面数 $< F$），则将 $p_i$ 加载到一个空闲页框中。\n    3.  如果页框已满，根据配置的替换策略选择一个牺牲页面进行置换。\n-   **置换逻辑**：\n    1.  当一个页面从页框中被置换出来时，它被放入一个交换槽中。\n    2.  如果交换空间已满（已换出的页面数 $= U$），则必须根据配置的回收策略从交换空间中丢弃一个页面。\n-   **与交换空间的交互**：如果一个被引用的页面 $p_i$（导致了错误）在交换槽中被找到，那么在它被加载到内存时，会从交换空间中移除。这不会改变错误计数。\n-   **未来使用距离**：对于轨迹中位置 $i$ 的一个页面，其未来使用距离是该页面再次出现在位置 $i+d$ 处的最小正整数 $d$。如果它再也不出现，则距离为 $+\\infty$。\n-   **配置 A (FIFO/FIFO)**：\n    -   页框替换：置换具有最早加载时间（先进先出）的驻留页面。\n    -   交换空间回收：丢弃具有最早换入交换空间时间（FIFO）的已换出页面。\n-   **配置 B (PRIO/PRIO)**：\n    -   页框替换：置换从当前轨迹索引 $i$ 算起具有最大未来使用距离的驻留页面。平局通过置换加载时间最早的页面来打破。\n    -   交换空间回收：丢弃从当前轨迹索引 $i$ 算起具有最大未来使用距离的已换出页面。平局被确定性地打破。\n-   **测试套件**：\n    -   测试 $1$：$F = 3$, $U = 2$, 序列 $[1,2,3,4,1,2,3,4]$。\n    -   测试 $2$：$F = 2$, $U = 1$, 序列 $[1,2,1,3,1,2,1,3]$。\n    -   测试 $3$：$F = 2$, $U = 2$, 序列 $[1,2,1,2,1,2]$。\n    -   测试 $4$：$F = 5$, $U = 3$, 序列 $[1,2,3,4,1,2,3,4,2,3,1]$。\n    -   测试 $5$：$F = 2$, $U = 0$, 序列 $[1,2,3,2,1,2,3,2]$。\n\n**步骤 2：使用提取的已知条件进行验证**\n-   **科学性**：该问题基于操作系统中基本且成熟的概念，包括虚拟内存、分页、页面错误、FIFO 替换、最优替换（此处通过 PRIO 方案理想化）以及交换空间管理。它在科学上是合理的。\n-   **适定性**：该问题是适定的。初始状态、转换规则和终止条件（轨迹结束）都已精确定义。为每个测试用例提供了参数。平局打破规则确保了每次模拟都有一个唯一的、确定性的结果。\n-   **客观性**：问题以精确、正式和客观的语言陈述，没有歧义或主观性断言。\n-   **完整性与一致性**：所有必要信息（$F, U$、轨迹、规则）均已提供。规则内部一致，不包含矛盾。例如，页面错误的定义是明确的，处理命中、错误和置换的程序也已足够详细，可以算法化实现。\n-   **其他标准**：该问题并非微不足道，因为它需要仔细实现状态管理和两种不同的复杂算法。它是可形式化的，并与其指定领域直接相关。在模拟的背景下，它并非不切实际或不可行。\n\n**步骤 3：结论与行动**\n该问题是**有效的**。将提供一个完整的、合理的解决方案。\n\n### 解决方案设计\n\n解决方案的核心是一个模拟引擎，它处理页面引用轨迹并维护系统内存和交换空间的状态。对于每个测试用例，该引擎将运行两次：一次用于配置 A (FIFO/FIFO)，一次用于配置 B (PRIO/PRIO)。\n\n**数据结构**\n为了管理状态，我们需要能够表示页框和交换槽内容的结构。`PageEntry` 结构适合此目的，它存储以下信息：\n-   `page_id`：页面标识符。值 $-1$ 可表示空槽位。\n-   `load_time`：页面加载到页框中的轨迹索引。\n-   `swap_time`：页面移入交换槽的轨迹索引。\n\n主模拟函数将管理用于页框和交换槽的 `PageEntry` 数组，以及它们当前占用情况的计数器。\n\n**模拟算法**\n模拟通过从索引 $i = 0$ 开始迭代页面引用轨迹直到结束来进行。对于每次对页面 $p_i$ 的引用：\n\n1.  **检查命中**：在物理页框中搜索 $p_i$。如果找到，则为命中。状态不发生变化，模拟继续处理下一个引用。\n\n2.  **处理页面错误**：如果在页框中未找到 $p_i$，则发生页面错误。错误计数增加。采取以下步骤：\n    a. **检查交换空间**：在交换空间中搜索 $p_i$。如果找到，相应的交换槽将被标记为空闲，因为该页面现在正被调回主内存。\n    b. **寻找页框**：\n        i. 如果驻留页面数小于总页框数 $F$，则使用一个空闲页框。\n        ii. 如果所有页框已满，则必须置换一个页面。牺牲页面根据当前活动的替换策略（FIFO 或 PRIO）选择。\n    c. **置换牺牲页面**：被置换的页面被移至交换空间。\n        i. 如果交换空间中的页面数小于总槽数 $U$，则使用一个空槽。\n        ii. 如果交换空间已满，必须从交换空间中丢弃一个页面以腾出空间。要丢弃的页面根据当前活动的交换空间回收策略（FIFO 或 PRIO）选择。\n    d. **加载页面**：将新页面 $p_i$ 放入现在可用的页框中。其 `load_time` 被记录为当前轨迹索引 $i$。\n\n**特定策略的逻辑**\n\n**配置 A (FIFO/FIFO)**\n-   **页框替换**：为了找到 FIFO 的牺牲页面，我们遍历所有驻留页面，并选择 `load_time` 最小的那个。\n-   **交换空间回收**：类似地，为了回收一个交换槽，我们遍历所有已换出的页面，并选择 `swap_time` 最小的那个。\n\n**配置 B (PRIO/PRIO)**\n此策略需要为候选牺牲页面计算未来使用距离。\n-   **页框替换**：为了在轨迹索引 $i$ 处找到 PRIO 的牺牲页面：\n    1.  对于每个驻留页面 $p_{res}$，在轨迹中找到它在索引 $j > i$ 处的下一次出现。\n    2.  未来使用距离定义为 $j - i$。如果页面永不重现，其距离被视为无限大。\n    3.  选择具有最大未来使用距离的页面作为牺牲页面。\n    4.  如果多个页面具有相同的最大距离（例如，全部为无限大），则通过选择 `load_time` 最小的页面来打破平局。\n-   **交换空间回收**：逻辑类似。对于交换空间中的每个页面，计算其从当前索引 $i$ 开始的未来使用距离。丢弃距离最大的页面。指定的平局打破规则是“确定性地任选其一”，这可以通过选择找到的第一个具有最大距离的页面来实现。\n\n这个详细的、分步的过程，在为每个配置和测试用例实施后，将产生所需的错误计数。",
            "answer": "[[8,5],[6,5],[2,2],[4,4],[6,5]]"
        },
        {
            "introduction": "在构建了模拟器之后，下一步是使用数学工具来预测系统性能。排队论是分析交换设备等系统的强大方法。本练习 () 将引导您将交换设备建模为 $M/M/1$ 队列，推导出平均等待时间等关键性能指标，并理解系统稳定性的重要概念。",
            "id": "3685064",
            "problem": "一个操作系统使用单个交换空间设备来满足由缺页引发的页面换入输入/输出 (I/O) 请求。考虑一个由三个独立进程组成的多道程序工作负载；每个进程都会产生缺页，从而创建交换I/O请求。假设每个进程的缺页形成一个独立的 Poisson 过程，其速率分别为 $r_{1} = 50~\\mathrm{s}^{-1}$、$r_{2} = 60~\\mathrm{s}^{-1}$ 和 $r_{3} = 80~\\mathrm{s}^{-1}$。该交换设备以先到先服务的顺序一次处理一个请求，服务时间是独立的且服从均值为 $4~\\mathrm{ms}$ 的指数分布，因此服务速率为 $\\mu_{\\text{swap}} = 250~\\mathrm{s}^{-1}$。在设备繁忙时到达的请求将在队列中等待。\n\n将该交换设备建模为一个 $M/M/1$ 队列。从 Poisson 过程、指数服务时间以及 $M/M/1$ 模型底层的生灭 Markov 链的基本定义出发，推导出一个请求在系统中（从到达至完成）所花费的稳态平均时间（记为 $W$）的解析表达式。然后根据给定的参数计算 $W$。此外，从模型的首要原则出发，陈述其通用稳定性条件，并确定给定参数是否满足该条件。\n\n将 $W$ 的最终数值以毫秒表示，并四舍五入到四位有效数字。在最终的方框答案中不要包含单位；如此处指定的，使用毫秒。",
            "solution": "该问题陈述被认为是有效的，因为它在科学上基于排队论，问题设定良好，具有完整且一致的参数集，并且陈述客观。我们将从首要原则出发，推导一个完整的解。\n\n问题要求我们将交换设备建模为一个 $M/M/1$ 队列。第一个“M”表示到达遵循一个 Markovian 过程，具体来说是一个 Poisson 过程。第二个“M”表示服务时间是 Markovian 的，即服从指数分布。数字“1”表示单个服务器。\n\n首先，我们必须确定队列的总到达率 $\\lambda$。问题陈述了三个独立进程产生缺页，每个进程都遵循一个 Poisson 过程，速率分别为 $r_{1} = 50~\\mathrm{s}^{-1}$、$r_{2} = 60~\\mathrm{s}^{-1}$ 和 $r_{3} = 80~\\mathrm{s}^{-1}$。Poisson 过程的一个基本性质是，多个独立的 Poisson 过程的叠加也是一个 Poisson 过程，其速率是各个独立过程速率之和。因此，到达交换设备的请求总速率为：\n$$ \\lambda = r_{1} + r_{2} + r_{3} = 50~\\mathrm{s}^{-1} + 60~\\mathrm{s}^{-1} + 80~\\mathrm{s}^{-1} = 190~\\mathrm{s}^{-1} $$\n给定的服务速率为 $\\mu = \\mu_{\\text{swap}} = 250~\\mathrm{s}^{-1}$。\n\n我们现在从其底层的生灭 Markov 链推导这个 $M/M/1$ 队列的稳态性质。设 $N(t)$ 为在时间 $t$ 系统中的请求数（在队列中或正在被服务）。状态空间是非负整数集合 $\\{0, 1, 2, \\ldots\\}$。\n生率 $\\lambda_n$ 表示从状态 $n$ 转移到 $n+1$ 的速率。由于到达遵循速率为 $\\lambda$ 的 Poisson 过程，因此生率是恒定的：\n$$ \\lambda_n = \\lambda \\quad \\text{for } n = 0, 1, 2, \\ldots $$\n灭率 $\\mu_n$ 表示从状态 $n$ 转移到 $n-1$ 的速率。由于服务时间服从速率为 $\\mu$ 的指数分布，且只有一个服务器，因此只有当系统不为空时才会发生离去。因此，灭率为：\n$$ \\mu_n = \\begin{cases} \\mu & \\text{if } n \\ge 1 \\\\ 0 & \\text{if } n = 0 \\end{cases} $$\n\n在稳态下，处于状态 $n$ 的概率记为 $P_n$。细致平衡原则要求进入一个状态的速率等于离开该状态的速率。这给了我们一组平衡方程：\n对于状态 $n=0$：（迁出率）=（迁入率） $\\implies \\lambda P_0 = \\mu P_1$。\n对于状态 $n \\ge 1$：（迁出率）=（迁入率） $\\implies (\\lambda + \\mu) P_n = \\lambda P_{n-1} + \\mu P_{n+1}$。\n\n我们可以求解这个方程组。从第一个方程，我们得到：\n$$ P_1 = \\frac{\\lambda}{\\mu} P_0 $$\n让我们定义流量强度 $\\rho = \\frac{\\lambda}{\\mu}$。那么 $P_1 = \\rho P_0$。\n使用 $n=1$ 时的一般平衡方程：\n$$ (\\lambda + \\mu)P_1 = \\lambda P_0 + \\mu P_2 $$\n代入 $P_1 = \\frac{\\lambda}{\\mu}P_0$：\n$$ (\\lambda + \\mu)\\frac{\\lambda}{\\mu}P_0 = \\lambda P_0 + \\mu P_2 \\implies \\frac{\\lambda^2}{\\mu}P_0 + \\lambda P_0 = \\lambda P_0 + \\mu P_2 $$\n$$ \\implies \\frac{\\lambda^2}{\\mu}P_0 = \\mu P_2 \\implies P_2 = \\frac{\\lambda^2}{\\mu^2}P_0 = \\rho^2 P_0 $$\n通过归纳法，我们可以建立一般关系：\n$$ P_n = \\rho^n P_0 \\quad \\text{for } n \\ge 0 $$\n\n为了使这些稳态概率有效，它们在所有可能状态上的总和必须等于 $1$：\n$$ \\sum_{n=0}^{\\infty} P_n = 1 \\implies \\sum_{n=0}^{\\infty} \\rho^n P_0 = P_0 \\sum_{n=0}^{\\infty} \\rho^n = 1 $$\n该求和是一个几何级数，其收敛的充要条件是其公比小于 $1$。由此，我们推导出 $M/M/1$ 队列的基本稳定性条件：\n$$ \\rho < 1 \\quad \\text{or equivalently} \\quad \\lambda < \\mu $$\n只有当到达率严格小于服务速率时，系统才是稳定的。\n\n假设稳定性条件成立，该级数的和为 $\\frac{1}{1-\\rho}$。因此：\n$$ P_0 \\left( \\frac{1}{1-\\rho} \\right) = 1 \\implies P_0 = 1 - \\rho $$\n将此代回，得到完整的稳态概率分布：\n$$ P_n = (1-\\rho)\\rho^n \\quad \\text{for } n \\ge 0 $$\n\n接下来，我们推导系统中的平均请求数，记为 $L$。这是顾客数 $n$ 的期望值：\n$$ L = E[N] = \\sum_{n=0}^{\\infty} n P_n = \\sum_{n=1}^{\\infty} n (1-\\rho)\\rho^n = (1-\\rho) \\sum_{n=1}^{\\infty} n \\rho^n $$\n该求和可以使用几何级数的一个已知结果来计算：$\\sum_{n=1}^{\\infty} n x^n = \\frac{x}{(1-x)^2}$。\n$$ L = (1-\\rho) \\frac{\\rho}{(1-\\rho)^2} = \\frac{\\rho}{1-\\rho} $$\n\n最后，我们推导一个请求在系统中花费的平均时间 $W$。我们使用排队论中的一个基本结果——Little 法则，该法则指出对于一个稳定系统，$L = \\lambda W$。由此，我们推导出 $W$ 的解析表达式：\n$$ W = \\frac{L}{\\lambda} = \\frac{\\rho/(1-\\rho)}{\\lambda} $$\n代入 $\\rho = \\lambda/\\mu$：\n$$ W = \\frac{(\\lambda/\\mu)/(1-\\lambda/\\mu)}{\\lambda} = \\frac{\\lambda/\\mu}{(\\mu-\\lambda)/\\mu} \\frac{1}{\\lambda} = \\frac{\\lambda}{\\mu} \\frac{\\mu}{\\mu - \\lambda} \\frac{1}{\\lambda} = \\frac{1}{\\mu - \\lambda} $$\n这就是所要求的系统中平均时间 $W$ 的解析表达式。\n\n现在，我们计算给定参数的数值。\n总到达率为 $\\lambda = 190~\\mathrm{s}^{-1}$。\n服务速率为 $\\mu = 250~\\mathrm{s}^{-1}$。\n\n首先，我们检查稳定性条件：$\\lambda < \\mu$。\n$$ 190~\\mathrm{s}^{-1} < 250~\\mathrm{s}^{-1} $$\n该条件得到满足，因此系统是稳定的，且存在稳态。\n\n现在我们使用推导出的公式计算 $W$：\n$$ W = \\frac{1}{\\mu - \\lambda} = \\frac{1}{250~\\mathrm{s}^{-1} - 190~\\mathrm{s}^{-1}} = \\frac{1}{60}~\\mathrm{s} $$\n问题要求答案以毫秒为单位，并四舍五入到四位有效数字。\n$$ W = \\frac{1}{60}~\\mathrm{s} \\times 1000~\\frac{\\mathrm{ms}}{\\mathrm{s}} = \\frac{1000}{60}~\\mathrm{ms} = \\frac{50}{3}~\\mathrm{ms} \\approx 16.666...~\\mathrm{ms} $$\n四舍五入到四位有效数字，我们得到 $W = 16.67~\\mathrm{ms}$。",
            "answer": "$$\\boxed{16.67}$$"
        },
        {
            "introduction": "最后，让我们将分析技能应用于一个现代的、真实世界的设计问题。本练习 () 介绍了内存压缩交换（如 zram/zswap）作为传统磁盘交换的替代方案。它挑战您推导出一个性能阈值，以确定何时压缩所带来的 CPU 开销能够被 I/O 延迟的节省所弥补，从而揭示现代操作系统设计中的复杂权衡。",
            "id": "3685159",
            "problem": "一个现代操作系统可以通过将页面交换到存储设备，或者使用zram或zswap等机制将交换出的页面压缩后保存在主内存中，来实现交换空间管理。考虑一个大小为 $P$ 字节的单个页面。当使用存储设备时，将每次输入/输出（I/O）的延迟建模为固定的单次I/O开销 $t_{d0}$ 秒与传输时间（等于数据大小除以设备吞吐量）之和。当使用压缩主内存时，将延迟建模为压缩和之后解压该页面的中央处理器（CPU）时间，加上以内存带宽在内存中传输压缩数据的时间之和。假设如下：\n- 压缩比为 $r$，这意味着压缩后的大小为 $P/r$ 字节。\n- 压缩和之后解压该页面的总中央处理器（CPU）时间为 $C_{cpu} \\, P$ 秒，其中 $C_{cpu}$ 的单位是秒/字节，并同时计入了压缩和解压的时间。\n- 有效持续磁盘吞吐量为 $B_{d}$ 字节/秒，固定的单次I/O磁盘开销为 $t_{d0}$ 秒；一次换出（写入）和其后的一次换入（读取）都会产生 $t_{d0}$ 的开销并传输 $P$ 字节。\n- 有效持续主内存带宽为 $B_{m}$ 字节/秒；写入和之后读取压缩页面均传输 $P/r$ 字节。\n- CPU时间与传输时间之间没有重叠，不同传输之间也没有重叠，并且分页遵循一个稳态的往返模式，即一次换出后最终会跟一次换入。\n\n仅从“传输延迟等于数据大小除以吞吐量再加上任何固定开销”和“CPU处理时间与处理的字节数成线性关系”这两个基本定义出发，推导出一个闭式阈值 $r^{*}$，使得当且仅当 $r > r^{*}$ 时，压缩主内存交换产生的总往返延迟严格低于基于磁盘的交换。将你的最终答案表示为关于 $P$、$B_{m}$、$B_{d}$、$t_{d0}$ 和 $C_{cpu}$ 的单一解析表达式。不要代入数值，也不要四舍五入。答案是无量纲的。",
            "solution": "该问题要求推导一个阈值压缩比 $r^{*}$，该阈值决定了压缩主内存交换是否比传统的基于磁盘的交换性能更好（即具有更低的总往返延迟）。条件是当且仅当实际压缩比 $r > r^{*}$ 时，压缩交换才严格更优。\n\n令 $L_{disk}$ 表示基于磁盘交换的总往返延迟，令 $L_{mem}$ 表示压缩主内存交换的总往返延迟。我们必须首先根据所提供的模型，为这两种延迟建立表达式。\n\n首先，我们分析基于磁盘的交换。一个往返操作包括一次换出（将一个页面写入磁盘）和一次随后的换入（从磁盘读回同一页面）。每次操作中传输的数据大小是完整的页面大小，即 $P$ 字节。\n\n单次磁盘 I/O 操作的延迟由固定开销 $t_{d0}$ 和可变传输时间之和给出。传输时间是数据大小除以磁盘吞吐量 $B_d$。\n对于一个大小为 $P$ 的页面的单次操作（换出或换入）：\n$$ \\text{Latency}_{\\text{one-way disk}} = t_{d0} + \\frac{P}{B_d} $$\n总往返延迟 $L_{disk}$ 是换出和换入延迟之和。\n$$ L_{disk} = \\left( t_{d0} + \\frac{P}{B_d} \\right) + \\left( t_{d0} + \\frac{P}{B_d} \\right) $$\n$$ L_{disk} = 2 t_{d0} + \\frac{2P}{B_d} $$\n\n接下来，我们分析压缩主内存交换。一个往返操作涉及压缩页面，将压缩数据写入主内存的某个区域，之后再读回压缩数据，并将其解压以恢复原始页面。\n\n压缩和解压的总 CPU 时间为 $C_{cpu} P$。\n压缩比为 $r$，因此压缩后的页面大小为 $P/r$ 字节。\n内存传输的延迟是数据大小除以内存带宽 $B_m$。根据题目描述，内存传输没有固定开销。\n将压缩页面写入内存的延迟是 $\\frac{P/r}{B_m} = \\frac{P}{r B_m}$。\n从内存读取压缩页面的延迟也是 $\\frac{P}{r B_m}$。\n一个往返中内存传输的总时间是写入和读取延迟之和。\n$$ \\text{Time}_{\\text{memory transfer}} = \\frac{P}{r B_m} + \\frac{P}{r B_m} = \\frac{2P}{r B_m} $$\n基于无重叠的假设，压缩内存交换的总往返延迟 $L_{mem}$ 是总 CPU 时间和总内存传输时间之和。\n$$ L_{mem} = C_{cpu} P + \\frac{2P}{r B_m} $$\n\n我们要寻找的条件是，压缩内存交换的延迟严格低于基于磁盘的交换。这可以用不等式 $L_{mem} < L_{disk}$ 表示。\n$$ C_{cpu} P + \\frac{2P}{r B_m} < 2 t_{d0} + \\frac{2P}{B_d} $$\n我们的目标是解这个关于 $r$ 的不等式。我们可以重新排列各项以分离出包含 $r$ 的项。\n$$ \\frac{2P}{r B_m} < 2 t_{d0} + \\frac{2P}{B_d} - C_{cpu} P $$\n为了存在一个有意义的阈值 $r^*$，使得性能优势取决于超过它（$r > r^*$），不等式的右侧必须为正。这对应于一个物理条件，即基于磁盘的方法本身速度不是已经那么快（或者压缩的 CPU 成本不是那么高），以至于压缩方法永远不可能更好。\n假设右侧为正，我们可以继续求解 $r$。让我们操作这个不等式，将 $r$ 移到分子上。\n首先，我们可以对两边取倒数，这会反转不等号的方向。\n$$ \\frac{r B_m}{2P} > \\frac{1}{2 t_{d0} + \\frac{2P}{B_d} - C_{cpu} P} $$\n接下来，我们通过将两边乘以 $\\frac{2P}{B_m}$ 来分离出 $r$。由于 $P$ 和 $B_m$ 是正的物理量，这不会改变不等号的方向。\n$$ r > \\frac{2P}{B_m \\left( 2 t_{d0} + \\frac{2P}{B_d} - C_{cpu} P \\right)} $$\n这个不等式给出了压缩内存交换速度更快的条件。右侧的表达式就是阈值 $r^*$。\n$$ r^{*} = \\frac{2P}{B_m \\left( 2 t_{d0} + \\frac{2P}{B_d} - C_{cpu} P \\right)} $$\n为了以没有嵌套分数的简化形式呈现，我们可以为分母括号内的各项找到一个公分母。这几项是 $2 t_{d0}$、$\\frac{2P}{B_d}$ 和 $-C_{cpu} P$。公分母是 $B_d$。\n$$ r^{*} = \\frac{2P}{B_m \\left( \\frac{2 t_{d0} B_d}{B_d} + \\frac{2P}{B_d} - \\frac{C_{cpu} P B_d}{B_d} \\right)} $$\n$$ r^{*} = \\frac{2P}{B_m \\left( \\frac{2 t_{d0} B_d + 2P - C_{cpu} P B_d}{B_d} \\right)} $$\n通过将分子和分母同乘以 $B_d$，我们得到了 $r^*$ 的最终闭式表达式：\n$$ r^{*} = \\frac{2P B_d}{B_m (2P + 2 t_{d0} B_d - C_{cpu} P B_d)} $$\n这个表达式代表了临界压缩比。如果实现的压缩比 $r$ 大于这个值 $r^*$，那么使用压缩主内存交换的总延迟将严格小于使用基于磁盘交换的延迟。",
            "answer": "$$\\boxed{\\frac{2P B_d}{B_m (2P + 2 t_{d0} B_d - C_{cpu} P B_d)}}$$"
        }
    ]
}