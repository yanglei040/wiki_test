{
    "hands_on_practices": [
        {
            "introduction": "Understanding swap-space management begins with recognizing its close relationship with page replacement algorithms. This hands-on simulation task allows you to build a core component of an operating system's memory manager from scratch. By implementing and comparing a simple FIFO policy against a more intelligent priority-based policy, you will gain a concrete understanding of how algorithmic choices directly influence system performance, measured by the total number of page faults .",
            "id": "3685067",
            "problem": "You are to implement a complete, runnable program that simulates a toy operating system’s swap-space management and page replacement behavior. The simulator must quantify how the discipline of queues managing page frames and swap slots affects the total number of disk page-in faults over a given page-reference trace. The setting, parameters, rules, and required output format are precisely specified below.\n\nThe foundational base consists of the following standard definitions and facts from operating systems: a memory access is directed at a virtual page; a physical frame can hold one page; when a referenced page is not present in a physical frame, a page fault occurs and the page must be brought in from auxiliary storage; when the number of resident pages equals the number of frames, a replacement must be chosen to free a frame. The simulator must implement two alternative queue disciplines: First-In First-Out (FIFO) and an idealized priority scheme that uses the next-use distance to prefer keeping pages that will be reused sooner. The next-use distance for a page at position $i$ in a trace is the minimal positive integer $d$ such that the same page appears again at position $i + d$, or $+\\infty$ if it does not reappear. The priority scheme always prefers to evict the resident page with the largest next-use distance (ties are broken deterministically by the earliest load time), which is a well-defined idealization for comparative study.\n\nYou must simulate two configurations for each test case:\n- Configuration A (FIFO/FIFO): page frames are managed as a FIFO queue for replacement, and swap slots are managed as a FIFO queue for reclamation when full.\n- Configuration B (PRIO/PRIO): page frames are managed by a priority rule that evicts the resident page with the largest next-use distance, and swap slots are reclaimed by removing the swapped-out page with the largest next-use distance when full.\n\nSwap-space management is modeled as follows. There are $U$ swap slots. When a page is evicted from memory, it occupies one swap slot if available; if all $U$ slots are used, one swapped-out page must be discarded according to the swap queue discipline in the current configuration to free a slot. If a page that is not resident is referenced, it causes a disk page-in fault regardless of whether or not it resides in swap. The simulator must only count the number of disk page-in faults, which is one per reference to a page that is not currently resident; hits do not increase this count. There is no prefetching, and there are no explicit deallocation events; the only events are the page references in the trace.\n\nFrom these fundamentals, implement the following precise rules for the simulator:\n- There are $F$ physical frames. Initially, all frames are empty, and the swap is empty.\n- For each reference at trace index $i$ to page $p_i$:\n  - If $p_i$ is resident in one of the $F$ frames, it is a hit and no fault is counted.\n  - Otherwise, a page-in fault is counted as $+1$. If the number of resident pages is less than $F$, load $p_i$ into a free frame. Otherwise, select a resident page to evict:\n    - In Configuration A, evict the resident page that has been in memory the longest (FIFO on load time).\n    - In Configuration B, evict the resident page whose next-use distance from index $i$ is largest; if multiple pages tie, evict the earliest-loaded among them.\n  - When evicting a page, place it into a swap slot if a free slot exists; otherwise, reclaim a swap slot by removing:\n    - In Configuration A, the swapped-out page that has been in swap the longest (FIFO).\n    - In Configuration B, the swapped-out page whose next-use distance from index $i$ is largest; if multiple pages tie, remove any one deterministically.\n  - If $p_i$ happens to be present in a swap slot, remove it from swap upon loading it into memory; this does not change the fault count.\n\nYour program must implement the above logic exactly and produce the total number of page-in faults under each configuration for each test case.\n\nTest Suite. Use the following test cases; for each case, $F$ is the number of frames, $U$ is the number of swap slots, and the sequence is the page-reference trace as an ordered list of integers. All numbers below must be interpreted as pages or capacities, not physical units.\n\n- Test $1$: $F = 3$, $U = 2$, sequence $[1,2,3,4,1,2,3,4]$.\n- Test $2$: $F = 2$, $U = 1$, sequence $[1,2,1,3,1,2,1,3]$.\n- Test $3$: $F = 2$, $U = 2$, sequence $[1,2,1,2,1,2]$.\n- Test $4$: $F = 5$, $U = 3$, sequence $[1,2,3,4,1,2,3,4,2,3,1]$.\n- Test $5$: $F = 2$, $U = 0$, sequence $[1,2,3,2,1,2,3,2]$.\n\nYour program must compute, for each test case, the total number of faults under Configuration A and under Configuration B, in that order. The required final output format is a single line containing a list of lists of integers, where each inner list corresponds to a test case in the same order as above and contains two integers: $[\\text{faults}_\\text{FIFO}, \\text{faults}_\\text{PRIO}]$. For example, the output format must be exactly `[[a,b],[c,d],[e,f],[g,h],[i,j]]`. Your program must produce exactly one line in this format and must not read any input.",
            "solution": "The problem requires the implementation of a simulator for page replacement and swap-space management in a toy operating system. The simulation must be performed for five test cases, each under two distinct configurations, and the total number of page-in faults must be reported for each run.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n-   **Core Entities**: Virtual pages, physical frames, swap slots.\n-   **Parameters per Test Case**:\n    -   $F$: number of physical frames.\n    -   $U$: number of swap slots.\n    -   `sequence`: a page-reference trace (an ordered list of integers).\n-   **Key Definition**: A page fault occurs, and is counted as $+1$, when a referenced page is not resident in a physical frame.\n-   **Initial State**: All $F$ frames and $U$ swap slots are empty.\n-   **Event**: A reference to page $p_i$ at trace index $i$.\n-   **Hit Logic**: If $p_i$ is in a frame, it is a hit; no fault is counted.\n-   **Fault Logic**:\n    1.  Count fault as $+1$.\n    2.  If frames are not full (resident pages $< F$), load $p_i$ into a free frame.\n    3.  If frames are full, select a victim page for eviction based on the configuration's replacement policy.\n-   **Eviction Logic**:\n    1.  When a page is evicted from a frame, it is placed into a swap slot.\n    2.  If swap is full (swapped pages $= U$), a page in swap must be discarded based on the configuration's reclamation policy.\n-   **Interaction with Swap**: If a referenced page $p_i$ (that caused a fault) is found in a swap slot, it is removed from swap upon being loaded into memory. This does not alter the fault count.\n-   **Next-Use Distance**: For a page at position $i$ in a trace, its next-use distance is the minimal positive integer $d$ such that the same page appears at position $i+d$. If it never reappears, the distance is $+\\infty$.\n-   **Configuration A (FIFO/FIFO)**:\n    -   Frame Replacement: Evict the resident page with the earliest load time (First-In, First-Out).\n    -   Swap Reclamation: Discard the swapped-out page with the earliest swap-in time (FIFO).\n-   **Configuration B (PRIO/PRIO)**:\n    -   Frame Replacement: Evict the resident page with the largest next-use distance from the current trace index $i$. Ties are broken by evicting the one with the earliest load time.\n    -   Swap Reclamation: Discard the swapped-out page with the largest next-use distance from the current trace index $i$. Ties are broken deterministically.\n-   **Test Suite**:\n    -   Test $1$: $F = 3$, $U = 2$, sequence $[1,2,3,4,1,2,3,4]$.\n    -   Test $2$: $F = 2$, $U = 1$, sequence $[1,2,1,3,1,2,1,3]$.\n    -   Test $3$: $F = 2$, $U = 2$, sequence $[1,2,1,2,1,2]$.\n    -   Test $4$: $F = 5$, $U = 3$, sequence $[1,2,3,4,1,2,3,4,2,3,1]$.\n    -   Test $5$: $F = 2$, $U = 0$, sequence $[1,2,3,2,1,2,3,2]$.\n\n**Step 2: Validate Using Extracted Givens**\n-   **Scientifically Grounded**: The problem is based on fundamental and well-established concepts in operating systems, including virtual memory, paging, page faults, FIFO replacement, optimal replacement (idealized here by the PRIO scheme), and swap space management. It is scientifically sound.\n-   **Well-Posed**: The problem is well-posed. The initial state, rules of transition, and termination conditions (end of trace) are all precisely defined. The parameters for each test case are provided. The tie-breaking rules ensure a unique, deterministic outcome for each simulation.\n-   **Objective**: The problem is stated in precise, formal, and objective language, free of ambiguity or subjective claims.\n-   **Completeness and Consistency**: All necessary information ($F, U$, trace, rules) is provided. The rules are internally consistent and do not contain contradictions. For instance, the definition of a page fault is unambiguous, and the procedures for handling hits, faults, and evictions are specified in sufficient detail to be implemented algorithmically.\n-   **Other Criteria**: The problem is not trivial, as it requires careful implementation of state management and two different complex algorithms. It is formalizable and directly relevant to its specified domain. It is not unrealistic or infeasible within the context of a simulation.\n\n**Step 3: Verdict and Action**\nThe problem is **valid**. A complete, reasoned solution will be provided.\n\n### Solution Design\n\nThe core of the solution is a simulation engine that processes a page reference trace and maintains the state of the system's memory and swap space. For each test case, this engine will be run twice: once for Configuration A (FIFO/FIFO) and once for Configuration B (PRIO/PRIO).\n\n**Data Structures**\nTo manage the state, we require structures to represent the contents of frames and swap slots. A `PageEntry` structure is appropriate for this purpose, storing:\n-   `page_id`: The identifier of the page. A value of $-1$ can denote an empty slot.\n-   `load_time`: The trace index at which the page was loaded into a frame.\n-   `swap_time`: The trace index at which the page was moved into a swap slot.\n\nThe main simulation function will manage arrays of `PageEntry` for both frames and swap slots, along with counters for their current occupancy.\n\n**Simulation Algorithm**\nThe simulation proceeds by iterating through the page reference trace from index $i = 0$ to the end. For each reference to page $p_i$:\n\n1.  **Check for Hit**: Search the physical frames for $p_i$. If found, this is a hit. No state change occurs, and the simulation proceeds to the next reference.\n\n2.  **Handle Page Fault**: If $p_i$ is not found in the frames, a page fault occurs. The fault count is incremented. The following steps are taken:\n    a. **Check Swap**: Search the swap space for $p_i$. If found, the corresponding swap slot is marked as free, as the page is now being brought back into main memory.\n    b. **Find Frame**:\n        i. If the number of resident pages is less than the total number of frames, $F$, an empty frame is used.\n        ii. If all frames are full, a page must be evicted. The victim is chosen according to the active replacement policy (FIFO or PRIO).\n    c. **Evict Victim**: The evicted page is moved to the swap space.\n        i. If the number of pages in swap is less than the total number of slots, $U$, an empty slot is used.\n        ii. If swap is full, a page must be discarded from swap to make room. The page to discard is chosen based on the active swap reclamation policy (FIFO or PRIO).\n    d. **Load Page**: The new page, $p_i$, is placed into the now-available frame. Its `load_time` is recorded as the current trace index, $i$.\n\n**Policy-Specific Logic**\n\n**Configuration A (FIFO/FIFO)**\n-   **Frame Replacement**: To find the FIFO victim, we iterate through all resident pages and select the one with the minimum `load_time`.\n-   **Swap Reclamation**: Similarly, to reclaim a swap slot, we iterate through all swapped-out pages and select the one with the minimum `swap_time`.\n\n**Configuration B (PRIO/PRIO)**\nThis policy requires calculating the next-use distance for candidate victims.\n-   **Frame Replacement**: To find the PRIO victim at trace index $i$:\n    1.  For each resident page $p_{res}$, find its next occurrence in the trace at an index $j > i$.\n    2.  The next-use distance is defined as $j - i$. If the page never reappears, its distance is considered infinite.\n    3.  The page with the maximum next-use distance is chosen as the victim.\n    4.  If multiple pages have the same maximum distance (e.g., all are infinite), the tie is broken by choosing the one with the minimum `load_time`.\n-   **Swap Reclamation**: The logic is analogous. For each page in swap, its next-use distance from the current index $i$ is calculated. The page with the maximum distance is discarded. The specified tie-breaking rule is \"any one deterministically,\" which can be implemented by selecting the first one found with the maximum distance.\n\nThis detailed, step-by-step process, when implemented for each configuration and test case, will yield the required fault counts.",
            "answer": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n// Define a large integer to represent infinity for next-use distance.\n#define INF 999999\n\n// Represents a page in a frame or swap slot.\ntypedef struct {\n    int page_id;     // ID of the page. -1 if the slot is empty.\n    int load_time;   // Trace index when loaded into a frame.\n    int swap_time;   // Trace index when moved to swap.\n} PageEntry;\n\n// Holds the parameters for a single test case.\ntypedef struct {\n    int F;                            // Number of frames\n    int U;                            // Number of swap slots\n    const int* trace;                 // Page reference trace\n    int trace_len;                    // Length of the trace\n} TestCase;\n\n// Calculates page faults for a given configuration.\nint simulate(int F, int U, const int* trace, int trace_len, int is_prio) {\n    int faults = 0;\n    PageEntry frames[F];\n    PageEntry swap[U];\n    int frame_count = 0;\n    int swap_count = 0;\n\n    // Initialize frames and swap slots\n    for (int i = 0; i < F; ++i) frames[i].page_id = -1;\n    for (int i = 0; i < U; ++i) swap[i].page_id = -1;\n\n    for (int i = 0; i < trace_len; ++i) {\n        int current_page = trace[i];\n        int in_memory = 0;\n\n        // 1. Check for hit\n        for (int j = 0; j < frame_count; ++j) {\n            if (frames[j].page_id == current_page) {\n                in_memory = 1;\n                break;\n            }\n        }\n\n        if (in_memory) {\n            continue; // Hit, do nothing.\n        }\n\n        // 2. Handle page fault\n        faults++;\n\n        // 2a. Check if page is in swap and remove it if so.\n        if (U > 0) {\n            for (int j = 0; j < swap_count; ++j) {\n                if (swap[j].page_id == current_page) {\n                    // Remove from swap by shifting subsequent elements\n                    for (int k = j; k < swap_count - 1; ++k) {\n                        swap[k] = swap[k + 1];\n                    }\n                    swap[swap_count - 1].page_id = -1;\n                    swap_count--;\n                    break;\n                }\n            }\n        }\n        \n        int frame_to_load_idx = -1;\n\n        // 2b. Find a frame for the new page\n        if (frame_count < F) {\n            // There is a free frame\n            frame_to_load_idx = frame_count++;\n        } else {\n            // Frames are full, need replacement\n            int victim_frame_idx = -1;\n\n            if (!is_prio) { // FIFO Replacement\n                int min_load_time = INF;\n                for (int j = 0; j < frame_count; ++j) {\n                    if (frames[j].load_time < min_load_time) {\n                        min_load_time = frames[j].load_time;\n                        victim_frame_idx = j;\n                    }\n                }\n            } else { // PRIO Replacement\n                int max_dist = -1;\n                int earliest_load_time = INF;\n                for (int j = 0; j < frame_count; ++j) {\n                    int dist = 0;\n                    int next_use_found = 0;\n                    for (int k = i + 1; k < trace_len; ++k) {\n                        if (trace[k] == frames[j].page_id) {\n                            dist = k - i;\n                            next_use_found = 1;\n                            break;\n                        }\n                    }\n                    if (!next_use_found) {\n                        dist = INF;\n                    }\n                    if (dist > max_dist) {\n                        max_dist = dist;\n                        victim_frame_idx = j;\n                        earliest_load_time = frames[j].load_time;\n                    } else if (dist == max_dist) {\n                        if (frames[j].load_time < earliest_load_time) {\n                            victim_frame_idx = j;\n                            earliest_load_time = frames[j].load_time;\n                        }\n                    }\n                }\n            }\n            \n            frame_to_load_idx = victim_frame_idx;\n            PageEntry victim_page = frames[victim_frame_idx];\n\n            // 2c. Evict victim page to swap\n            if (U > 0) {\n                int swap_slot_idx = -1;\n                if (swap_count < U) {\n                    swap_slot_idx = swap_count++;\n                } else { // Swap is full, need reclamation\n                    int swap_victim_idx = -1;\n                    if (!is_prio) { // FIFO Swap Reclamation\n                        int min_swap_time = INF;\n                        for (int j = 0; j < swap_count; ++j) {\n                            if (swap[j].swap_time < min_swap_time) {\n                                min_swap_time = swap[j].swap_time;\n                                swap_victim_idx = j;\n                            }\n                        }\n                    } else { // PRIO Swap Reclamation\n                        int max_dist = -1;\n                        for (int j = 0; j < swap_count; ++j) {\n                            int dist = 0;\n                            int next_use_found = 0;\n                            for (int k = i + 1; k < trace_len; ++k) {\n                                if (trace[k] == swap[j].page_id) {\n                                    dist = k - i;\n                                    next_use_found = 1;\n                                    break;\n                                }\n                            }\n                            if (!next_use_found) {\n                                dist = INF;\n                            }\n                            if (dist > max_dist) {\n                                max_dist = dist;\n                                swap_victim_idx = j;\n                            }\n                        }\n                    }\n                    swap_slot_idx = swap_victim_idx;\n                }\n                swap[swap_slot_idx] = victim_page;\n                swap[swap_slot_idx].swap_time = i;\n            }\n        }\n        \n        // 2d. Load the new page\n        frames[frame_to_load_idx].page_id = current_page;\n        frames[frame_to_load_idx].load_time = i;\n    }\n\n    return faults;\n}\n\nint main(void) {\n    const int trace1[] = {1, 2, 3, 4, 1, 2, 3, 4};\n    const int trace2[] = {1, 2, 1, 3, 1, 2, 1, 3};\n    const int trace3[] = {1, 2, 1, 2, 1, 2};\n    const int trace4[] = {1, 2, 3, 4, 1, 2, 3, 4, 2, 3, 1};\n    const int trace5[] = {1, 2, 3, 2, 1, 2, 3, 2};\n\n    TestCase test_cases[] = {\n        {3, 2, trace1, sizeof(trace1) / sizeof(trace1[0])},\n        {2, 1, trace2, sizeof(trace2) / sizeof(trace2[0])},\n        {2, 2, trace3, sizeof(trace3) / sizeof(trace3[0])},\n        {5, 3, trace4, sizeof(trace4) / sizeof(trace4[0])},\n        {2, 0, trace5, sizeof(trace5) / sizeof(trace5[0])},\n    };\n\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    int results[num_cases][2];\n\n    for (int i = 0; i < num_cases; ++i) {\n        TestCase tc = test_cases[i];\n        results[i][0] = simulate(tc.F, tc.U, tc.trace, tc.trace_len, 0); // FIFO/FIFO\n        results[i][1] = simulate(tc.F, tc.U, tc.trace, tc.trace_len, 1); // PRIO/PRIO\n    }\n    \n    printf(\"[\");\n    for (int i = 0; i < num_cases; ++i) {\n        printf(\"[%d,%d]\", results[i][0], results[i][1]);\n        if (i < num_cases - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\");\n\n    return EXIT_SUCCESS;\n}\n```"
        },
        {
            "introduction": "Modern operating systems face a critical trade-off between the large capacity of disk-based swap and the high speed of main memory. This practice explores a contemporary solution: in-memory compressed swap, as seen in mechanisms like zram. By deriving a mathematical threshold, you will learn to perform a quantitative cost-benefit analysis, balancing the CPU overhead of compression against the latency savings from avoiding slow disk I/O, a vital skill for designing and tuning high-performance systems .",
            "id": "3685159",
            "problem": "A modern operating system can implement swap-space management either by paging to a storage device or by keeping swapped pages compressed in main memory using mechanisms such as zram or zswap. Consider a single page of size $P$ bytes. When using a storage device, model the latency of each Input/Output (I/O) as the sum of a fixed per-I/O overhead $t_{d0}$ seconds and a transfer time equal to the data size divided by the device throughput. When using compressed main memory, model the latency as the sum of Central Processing Unit (CPU) time to compress and later decompress the page plus the time to transfer the compressed data in memory at the memory bandwidth. Assume the following:\n- The compression ratio is $r$, meaning the compressed size is $P/r$ bytes.\n- The total Central Processing Unit (CPU) time to compress and later decompress the page is $C_{cpu} \\, P$ seconds, where $C_{cpu}$ is in seconds per byte and accounts for both compression and decompression together.\n- The effective sustained disk throughput is $B_{d}$ bytes per second, and the fixed per-I/O disk overhead is $t_{d0}$ seconds; a swap-out (write) and its later swap-in (read) each incur $t_{d0}$ and transfer $P$ bytes.\n- The effective sustained main memory bandwidth is $B_{m}$ bytes per second; writing and later reading the compressed page each transfer $P/r$ bytes.\n- There is no overlap between CPU time and transfer time, nor between different transfers, and paging follows a steady-state round-trip pattern of one swap-out followed eventually by one swap-in.\n\nStarting only from the fundamental definitions that latency for a transfer equals data size divided by throughput plus any fixed overhead, and that CPU processing time is linear in the number of bytes processed, derive a closed-form threshold $r^{*}$ such that compressed main-memory swap yields a strictly lower total round-trip latency than disk-backed swap if and only if $r > r^{*}$. Express your final answer as a single analytic expression for $r^{*}$ in terms of $P$, $B_{m}$, $B_{d}$, $t_{d0}$, and $C_{cpu}$. Do not substitute numerical values and do not round. The answer is dimensionless.",
            "solution": "The problem requires the derivation of a threshold compression ratio, $r^{*}$, which determines whether compressed main-memory swap is more performant (i.e., has a lower total round-trip latency) than traditional disk-backed swap. The condition is that compressed swap is strictly better if and only if the actual compression ratio $r > r^{*}$.\n\nLet $L_{disk}$ denote the total round-trip latency for disk-backed swap and $L_{mem}$ denote the total round-trip latency for compressed main-memory swap. We must first formulate expressions for these two latencies based on the provided models.\n\nFirst, we analyze the disk-backed swap. A round-trip operation consists of one swap-out (writing a page to disk) and one subsequent swap-in (reading the same page from disk). The size of the data transferred in each operation is the full page size, $P$ bytes.\n\nThe latency for a single disk I/O operation is given as the sum of a fixed overhead, $t_{d0}$, and a variable transfer time. The transfer time is the data size divided by the disk throughput, $B_d$.\nFor a single operation (either swap-out or swap-in) of a page of size $P$:\n$$ \\text{Latency}_{\\text{one-way disk}} = t_{d0} + \\frac{P}{B_d} $$\nThe total round-trip latency, $L_{disk}$, is the sum of the swap-out and swap-in latencies.\n$$ L_{disk} = \\left( t_{d0} + \\frac{P}{B_d} \\right) + \\left( t_{d0} + \\frac{P}{B_d} \\right) $$\n$$ L_{disk} = 2 t_{d0} + \\frac{2P}{B_d} $$\n\nNext, we analyze the compressed main-memory swap. A round-trip operation involves compressing the page, writing the compressed data to a region of main memory, later reading the compressed data back, and decompressing it to restore the original page.\n\nThe total CPU time for both compression and decompression is given as $C_{cpu} P$.\nThe compression ratio is $r$, so the size of the compressed page is $P/r$ bytes.\nThe latency for a memory transfer is the data size divided by the memory bandwidth, $B_m$. There is no fixed overhead for memory transfers according to the problem statement.\nThe latency to write the compressed page to memory is $\\frac{P/r}{B_m} = \\frac{P}{r B_m}$.\nThe latency to read the compressed page from memory is also $\\frac{P}{r B_m}$.\nThe total time for memory transfers in a round trip is the sum of the write and read latencies.\n$$ \\text{Time}_{\\text{memory transfer}} = \\frac{P}{r B_m} + \\frac{P}{r B_m} = \\frac{2P}{r B_m} $$\nThe total round-trip latency for compressed memory swap, $L_{mem}$, is the sum of the total CPU time and the total memory transfer time, based on the non-overlapping assumption.\n$$ L_{mem} = C_{cpu} P + \\frac{2P}{r B_m} $$\n\nWe are seeking the condition under which compressed memory swap has a strictly lower latency than disk-backed swap. This is expressed by the inequality $L_{mem} < L_{disk}$.\n$$ C_{cpu} P + \\frac{2P}{r B_m} < 2 t_{d0} + \\frac{2P}{B_d} $$\nOur goal is to solve this inequality for $r$. We can rearrange the terms to isolate the term containing $r$.\n$$ \\frac{2P}{r B_m} < 2 t_{d0} + \\frac{2P}{B_d} - C_{cpu} P $$\nFor a meaningful threshold $r^*$ to exist where the performance benefit depends on exceeding it ($r > r^*$), the right-hand side of the inequality must be positive. This corresponds to the physical condition that the disk-based method is not already so fast (or the CPU cost of compression so high) that the compressed method could never be better.\nAssuming the right-hand side is positive, we can proceed to solve for $r$. Let's manipulate the inequality to get $r$ in the numerator.\nFirst, we can take the reciprocal of both sides, which reverses the direction of the inequality sign.\n$$ \\frac{r B_m}{2P} > \\frac{1}{2 t_{d0} + \\frac{2P}{B_d} - C_{cpu} P} $$\nNext, we isolate $r$ by multiplying both sides by $\\frac{2P}{B_m}$. Since $P$ and $B_m$ are positive physical quantities, this does not change the inequality direction.\n$$ r > \\frac{2P}{B_m \\left( 2 t_{d0} + \\frac{2P}{B_d} - C_{cpu} P \\right)} $$\nThis inequality gives the condition for which compressed memory swap is faster. The expression on the right-hand side is the threshold value, $r^*$.\n$$ r^{*} = \\frac{2P}{B_m \\left( 2 t_{d0} + \\frac{2P}{B_d} - C_{cpu} P \\right)} $$\nTo present this in a simplified form without nested fractions, we can find a common denominator for the terms inside the parentheses in the denominator. The terms are $2 t_{d0}$, $\\frac{2P}{B_d}$, and $-C_{cpu} P$. The common denominator is $B_d$.\n$$ r^{*} = \\frac{2P}{B_m \\left( \\frac{2 t_{d0} B_d}{B_d} + \\frac{2P}{B_d} - \\frac{C_{cpu} P B_d}{B_d} \\right)} $$\n$$ r^{*} = \\frac{2P}{B_m \\left( \\frac{2 t_{d0} B_d + 2P - C_{cpu} P B_d}{B_d} \\right)} $$\nBy multiplying the numerator and the denominator by $B_d$, we obtain the final closed-form expression for $r^*$:\n$$ r^{*} = \\frac{2P B_d}{B_m (2P + 2 t_{d0} B_d - C_{cpu} P B_d)} $$\nThis expression represents the critical compression ratio. If the achieved compression ratio $r$ is greater than this value $r^*$, the total latency of using compressed main-memory swap will be strictly less than that of using disk-backed swap.",
            "answer": "$$\\boxed{\\frac{2P B_d}{B_m (2P + 2 t_{d0} B_d - C_{cpu} P B_d)}}$$"
        },
        {
            "introduction": "When an operating system is under memory pressure, the swap device can become a significant performance bottleneck as numerous page fault requests queue up. This exercise introduces a powerful analytical tool, queueing theory, to model and predict the performance of the swap system. By treating the swap device as an $M/M/1$ queue, you will derive and apply fundamental formulas to calculate the average time a process must wait for its page, providing critical insights into system stability and responsiveness under load .",
            "id": "3685064",
            "problem": "An operating system employs a single swap-space device to satisfy page-in Input/Output (I/O) requests triggered by page faults. Consider a multi-programmed workload of three independent processes; each process generates page faults that create swap I/O requests. Assume each process’s page faults form an independent Poisson process with rates $r_{1} = 50~\\mathrm{s}^{-1}$, $r_{2} = 60~\\mathrm{s}^{-1}$, and $r_{3} = 80~\\mathrm{s}^{-1}$. The swap device serves one request at a time in first-come, first-served order, and service times are independent and exponentially distributed with mean $4~\\mathrm{ms}$, so the service rate is $\\mu_{\\text{swap}} = 250~\\mathrm{s}^{-1}$. Requests that arrive while the device is busy wait in a queue.\n\nModel the swap device as an $M/M/1$ queue. Starting from the fundamental definitions of the Poisson process, exponential service times, and the birth-death Markov chain underlying the $M/M/1$ model, derive an analytic expression for the steady-state mean time a request spends in the system (from arrival to completion), denoted by $W$. Then compute $W$ for the given parameters. Also, from first principles of the model, state the general stability condition and determine whether the given parameters satisfy it.\n\nExpress the final numerical value of $W$ in milliseconds and round your answer to four significant figures. Do not include units in your final boxed answer; use milliseconds as specified here.",
            "solution": "The problem statement is deemed valid as it is scientifically grounded in queueing theory, well-posed with a complete and consistent set of parameters, and objectively stated. We will proceed with a full solution derived from first principles.\n\nThe problem asks us to model a swap device as an $M/M/1$ queue. The first 'M' signifies that arrivals follow a Markovian process, specifically a Poisson process. The second 'M' signifies that service times are Markovian, i.e., exponentially distributed. The '$1$' indicates a single server.\n\nFirst, we must determine the total arrival rate, $\\lambda$, to the queue. The problem states that three independent processes generate page faults, each according to a Poisson process with rates $r_{1} = 50~\\mathrm{s}^{-1}$, $r_{2} = 60~\\mathrm{s}^{-1}$, and $r_{3} = 80~\\mathrm{s}^{-1}$. A fundamental property of Poisson processes is that the superposition of independent Poisson processes is also a Poisson process whose rate is the sum of the individual rates. Therefore, the total arrival rate of requests to the swap device is:\n$$ \\lambda = r_{1} + r_{2} + r_{3} = 50~\\mathrm{s}^{-1} + 60~\\mathrm{s}^{-1} + 80~\\mathrm{s}^{-1} = 190~\\mathrm{s}^{-1} $$\nThe service rate is given as $\\mu = \\mu_{\\text{swap}} = 250~\\mathrm{s}^{-1}$.\n\nWe now derive the steady-state properties of this $M/M/1$ queue from its underlying birth-death Markov chain. Let $N(t)$ be the number of requests in the system (in the queue or being served) at time $t$. The state space is the set of non-negative integers $\\{0, 1, 2, \\ldots\\}$.\nThe birth rates, $\\lambda_n$, represent the rate of transition from state $n$ to $n+1$. Since arrivals follow a Poisson process with rate $\\lambda$, the birth rates are constant:\n$$ \\lambda_n = \\lambda \\quad \\text{for } n = 0, 1, 2, \\ldots $$\nThe death rates, $\\mu_n$, represent the rate of transition from state $n$ to $n-1$. Since service times are exponential with rate $\\mu$ and there is a single server, a departure can only occur if the system is not empty. Thus, the death rates are:\n$$ \\mu_n = \\begin{cases} \\mu & \\text{if } n \\ge 1 \\\\ 0 & \\text{if } n = 0 \\end{cases} $$\n\nIn steady state, the probability of being in state $n$ is denoted by $P_n$. The principle of detailed balance requires that the rate of entering a state equals the rate of leaving it. This gives us a set of balance equations:\nFor state $n=0$: (rate out) = (rate in) $\\implies \\lambda P_0 = \\mu P_1$.\nFor state $n \\ge 1$: (rate out) = (rate in) $\\implies (\\lambda + \\mu) P_n = \\lambda P_{n-1} + \\mu P_{n+1}$.\n\nWe can solve this system of equations. From the first equation, we get:\n$$ P_1 = \\frac{\\lambda}{\\mu} P_0 $$\nLet us define the traffic intensity, $\\rho = \\frac{\\lambda}{\\mu}$. Then $P_1 = \\rho P_0$.\nUsing the general balance equation for $n=1$:\n$$ (\\lambda + \\mu)P_1 = \\lambda P_0 + \\mu P_2 $$\nSubstituting $P_1 = \\frac{\\lambda}{\\mu}P_0$:\n$$ (\\lambda + \\mu)\\frac{\\lambda}{\\mu}P_0 = \\lambda P_0 + \\mu P_2 \\implies \\frac{\\lambda^2}{\\mu}P_0 + \\lambda P_0 = \\lambda P_0 + \\mu P_2 $$\n$$ \\implies \\frac{\\lambda^2}{\\mu}P_0 = \\mu P_2 \\implies P_2 = \\frac{\\lambda^2}{\\mu^2}P_0 = \\rho^2 P_0 $$\nBy induction, we can establish the general relationship:\n$$ P_n = \\rho^n P_0 \\quad \\text{for } n \\ge 0 $$\n\nFor these steady-state probabilities to be valid, their sum over all possible states must be equal to $1$:\n$$ \\sum_{n=0}^{\\infty} P_n = 1 \\implies \\sum_{n=0}^{\\infty} \\rho^n P_0 = P_0 \\sum_{n=0}^{\\infty} \\rho^n = 1 $$\nThe summation is a geometric series, which converges if and only if its ratio is less than $1$. From this, we derive the fundamental stability condition for the $M/M/1$ queue:\n$$ \\rho < 1 \\quad \\text{or equivalently} \\quad \\lambda < \\mu $$\nThe system is stable only if the arrival rate is strictly less than the service rate.\n\nAssuming the stability condition holds, the sum of the series is $\\frac{1}{1-\\rho}$. Therefore:\n$$ P_0 \\left( \\frac{1}{1-\\rho} \\right) = 1 \\implies P_0 = 1 - \\rho $$\nSubstituting this back gives the full steady-state probability distribution:\n$$ P_n = (1-\\rho)\\rho^n \\quad \\text{for } n \\ge 0 $$\n\nNext, we derive the mean number of requests in the system, denoted by $L$. This is the expected value of the number of customers, $n$:\n$$ L = E[N] = \\sum_{n=0}^{\\infty} n P_n = \\sum_{n=1}^{\\infty} n (1-\\rho)\\rho^n = (1-\\rho) \\sum_{n=1}^{\\infty} n \\rho^n $$\nThe summation can be evaluated using a known result for geometric series: $\\sum_{n=1}^{\\infty} n x^n = \\frac{x}{(1-x)^2}$.\n$$ L = (1-\\rho) \\frac{\\rho}{(1-\\rho)^2} = \\frac{\\rho}{1-\\rho} $$\n\nFinally, we derive the mean time a request spends in the system, $W$. We use Little's Law, a fundamental result in queueing theory, which states that for a stable system, $L = \\lambda W$. From this, we derive the analytic expression for $W$:\n$$ W = \\frac{L}{\\lambda} = \\frac{\\rho/(1-\\rho)}{\\lambda} $$\nSubstituting $\\rho = \\lambda/\\mu$:\n$$ W = \\frac{(\\lambda/\\mu)/(1-\\lambda/\\mu)}{\\lambda} = \\frac{\\lambda/\\mu}{(\\mu-\\lambda)/\\mu} \\frac{1}{\\lambda} = \\frac{\\lambda}{\\mu} \\frac{\\mu}{\\mu - \\lambda} \\frac{1}{\\lambda} = \\frac{1}{\\mu - \\lambda} $$\nThis is the required analytic expression for the mean time in the system, $W$.\n\nNow, we compute the numerical values for the given parameters.\nThe total arrival rate is $\\lambda = 190~\\mathrm{s}^{-1}$.\nThe service rate is $\\mu = 250~\\mathrm{s}^{-1}$.\n\nFirst, we check the stability condition: $\\lambda < \\mu$.\n$$ 190~\\mathrm{s}^{-1} < 250~\\mathrm{s}^{-1} $$\nThe condition is satisfied, so the system is stable and a steady state exists.\n\nNow we compute $W$ using the derived formula:\n$$ W = \\frac{1}{\\mu - \\lambda} = \\frac{1}{250~\\mathrm{s}^{-1} - 190~\\mathrm{s}^{-1}} = \\frac{1}{60}~\\mathrm{s} $$\nThe problem asks for the answer in milliseconds, rounded to four significant figures.\n$$ W = \\frac{1}{60}~\\mathrm{s} \\times 1000~\\frac{\\mathrm{ms}}{\\mathrm{s}} = \\frac{1000}{60}~\\mathrm{ms} = \\frac{50}{3}~\\mathrm{ms} \\approx 16.666...~\\mathrm{ms} $$\nRounding to four significant figures, we get $W = 16.67~\\mathrm{ms}$.",
            "answer": "$$\\boxed{16.67}$$"
        }
    ]
}