{
    "hands_on_practices": [
        {
            "introduction": "要真正理解一个算法，最好的方法之一就是亲手执行它。本练习将引导您详细地模拟增强型二次机会算法（Enhanced Second-Chance algorithm）的运行过程。通过手动追踪几轮页面置换，您将深入理解引用位和脏位如何共同作用，构建出一个精细的淘汰候选页面层次结构，这对于掌握高级时钟算法至关重要。",
            "id": "3655937",
            "problem": "一个实现最近最少使用（LRU）近似算法的操作系统使用了增强的二次机会算法（也称为带引用位和修改位的时钟算法）。该算法维护一个帧的循环列表和一个一次前进一帧的指针。每个帧都有一个引用位 $R \\in \\{0,1\\}$ 和一个修改位 $D \\in \\{0,1\\}$。当需要页面置换时，算法按以下方式进行：\n\n- 帧在概念上被划分为四类，淘汰的优先级递增：第 $0$ 类：$(R=0,D=0)$，第 $1$ 类：$(R=0,D=1)$，第 $2$ 类：$(R=1,D=0)$，第 $3$ 类：$(R=1,D=1)$。\n- 指针从其当前位置开始，并按类别递增的顺序执行扫描（完整的循环扫描）：第一次扫描针对第 $0$ 类，第二次扫描针对第 $1$ 类，然后是第 $2$ 类，再然后是第 $3$ 类。在任何一次扫描中，当指针检查一个帧时，如果该帧的 $R=1$，算法会设置 $R \\leftarrow 0$ 并继续。一个帧只有在其状态与当前扫描的目标类别匹配时（此匹配检查在同一次扫描中执行任何 $R$ 位清除操作之前进行），才有资格在当前扫描中被淘汰。在该次扫描中遇到的第一个符合条件的帧被选中淘汰。\n- 淘汰后，新页面立即被加载到同一个帧中，其初始位为 $(R=1,D=0)$，并且指针前进到下一个帧，以便为下一次置换继续搜索。在两次置换之间，假设没有内存引用发生；对 $R$ 的唯一改变来自于算法在扫描时自身的清除操作。\n- 为了本题的目的，我们将时钟指针的旋转次数定义为帧间前进的总次数除以总帧数 $N$。您必须计算指针在所有扫描中寻找牺牲帧时所进行的所有帧间前进次数。在放置第 $k$ 个新页面后，不要计算任何前进；在该加载操作后立即停止计数。\n\n考虑有 $N=10$ 个帧排列成一个圆环，按顺序标记为帧 $1$ 到 $10$。在零时刻，从帧 $1$ 开始顺时针方向，各帧的初始位 $(R,D)$ 如下：\n- 帧 $1$: $(1,1)$\n- 帧 $2$: $(1,0)$\n- 帧 $3$: $(0,0)$\n- 帧 $4$: $(1,1)$\n- 帧 $5$: $(0,1)$\n- 帧 $6$: $(1,0)$\n- 帧 $7$: $(0,0)$\n- 帧 $8$: $(1,1)$\n- 帧 $9$: $(1,0)$\n- 帧 $10$: $(0,1)$\n\n指针最初指向帧 $1$。系统必须使用上面指定的增强型二次机会算法，按顺序逐个淘汰并替换 $k=5$ 个页面。\n\n计算完成这 $5$ 次淘汰所需的时钟指针旋转的总次数。将您的答案表示为一个最简分数。不要包含单位。无需四舍五入。",
            "solution": "题目描述了一种增强型二次机会（或时钟）页面置换算法的特定变体，并要求计算执行 $k=5$ 次页面淘汰所需的时钟指针总旋转次数。这个问题在操作系统领域内是格式规范且有科学依据的，尽管对算法的描述需要仔细、字面地解读。\n\n首先，让我们根据题目中的规定，将寻找单个待淘汰页面的算法形式化。该算法涉及最多四次扫描，每次扫描针对一类特定的帧 $(R,D)$，其中 $R$ 是引用位，$D$ 是修改位。这些类别按淘汰优先级排序：第 $0$ 类：$(0,0)$，第 $1$ 类：$(0,1)$，第 $2$ 类：$(1,0)$，以及第 $3$ 类：$(1,1)$。\n\n对于单次页面置换，寻找牺牲帧的搜索过程如下：\n1.  开始对第 $0$ 类帧（即状态为 $(R,D) = (0,0)$ 的帧）进行扫描。\n2.  指针从其当前帧开始。对于检查的每个帧：\n    a. 设该帧的状态为 $(R_{current}, D_{current})$。\n    b. 检查 $(R_{current}, D_{current})$ 是否与当前扫描的目标类别匹配。此检查使用该帧在此步骤中进行任何修改 *之前* 的状态。如果匹配，则此帧为牺牲帧。搜索终止。\n    c. 如果该帧不是牺牲帧，检查其引用位 $R_{current}$ 是否为 $1$。如果是，则将其设置为 $0$。\n    d. 如果该帧不是牺牲帧，指针前进到下一个帧。此移动构成一次“帧间前进”。\n3.  如果一次完整的循环扫描（$N$ 次帧检查）完成而未在当前扫描中找到牺牲帧，则从指针的当前位置开始，为序列中的下一个类别（第 $1$ 类，然后是第 $2$ 类，依此类推）开始一次新的扫描。\n\n找到牺牲帧后，新页面被加载到其帧中，并将该帧的位设置为 $(R,D) = (1,0)$。然后指针前进到循环列表中的下一个帧，从那里开始为下一次页面置换进行搜索。\n\n给定 $N=10$ 个帧，标记为 $F_1$ 到 $F_{10}$。初始指针位置在 $F_1$。初始状态 $(R,D)$ 如下：\n- $F_1: (1,1)$\n- $F_2: (1,0)$\n- $F_3: (0,0)$\n- $F_4: (1,1)$\n- $F_5: (0,1)$\n- $F_6: (1,0)$\n- $F_7: (0,0)$\n- $F_8: (1,1)$\n- $F_9: (1,0)$\n- $F_{10}: (0,1)$\n\n我们将追踪所需的 $k=5$ 次淘汰，记录所有帧的状态、指针位置以及累计的前进次数。设总前进次数为 $A$。初始时，$A=0$。\n\n**第 1 次淘汰**\n- 初始指针位置：$F_1$。\n- 初始状态：$[(1,1), (1,0), (0,0), (1,1), (0,1), (1,0), (0,0), (1,1), (1,0), (0,1)]$\n- 算法开始扫描第 $0$ 类帧，$(0,0)$。\n- **扫描：**\n    - 指针在 $F_1$：状态为 $(1,1)$。不是牺牲帧。设置 $R \\leftarrow 0$。$F_1$ 变为 $(0,1)$。指针前进到 $F_2$。（$A=1$）\n    - 指针在 $F_2$：状态为 $(1,0)$。不是牺牲帧。设置 $R \\leftarrow 0$。$F_2$ 变为 $(0,0)$。指针前进到 $F_3$。（$A=2$）\n    - 指针在 $F_3$：状态为 $(0,0)$。这是一个第 $0$ 类帧。**找到牺牲帧。**\n- **第 1 次淘汰总结：**\n    - 本次搜索的前进次数：$2$。\n    - 总前进次数 $A = 2$。\n    - 牺牲帧是 $F_3$。它被一个新页面替换，因此其状态变为 $(1,0)$。\n    - 指针前进到下一个帧 $F_4$。\n- **第 1 次淘汰后状态：**\n    - 帧：$[(0,1), (0,0), (1,0), (1,1), (0,1), (1,0), (0,0), (1,1), (1,0), (0,1)]$\n    - 指针在 $F_4$。\n\n**第 2 次淘汰**\n- 指针位置：$F_4$。\n- 算法开始扫描第 $0$ 类帧，$(0,0)$。\n- **扫描：**\n    - 指针在 $F_4$：状态为 $(1,1)$。不是牺牲帧。设置 $R \\leftarrow 0$。$F_4$ 变为 $(0,1)$。指针前进到 $F_5$。（$A=2+1=3$）\n    - 指针在 $F_5$：状态为 $(0,1)$。不是牺牲帧。指针前进到 $F_6$。（$A=3+1=4$）\n    - 指针在 $F_6$：状态为 $(1,0)$。不是牺牲帧。设置 $R \\leftarrow 0$。$F_6$ 变为 $(0,0)$。指针前进到 $F_7$。（$A=4+1=5$）\n    - 指针在 $F_7$：状态为 $(0,0)$。**找到牺牲帧。**\n- **第 2 次淘汰总结：**\n    - 本次搜索的前进次数：$3$。\n    - 总前进次数 $A = 5$。\n    - 牺牲帧是 $F_7$。它被替换，因此其状态变为 $(1,0)$。\n    - 指针前进到下一个帧 $F_8$。\n- **第 2 次淘汰后状态：**\n    - 帧：$[(0,1), (0,0), (1,0), (0,1), (0,1), (0,0), (1,0), (1,1), (1,0), (0,1)]$\n    - 指针在 $F_8$。\n\n**第 3 次淘汰**\n- 指针位置：$F_8$。\n- 算法开始扫描第 $0$ 类帧，$(0,0)$。\n- **扫描：**\n    - 指针在 $F_8$：状态为 $(1,1)$。不是牺牲帧。设置 $R \\leftarrow 0$。$F_8$ 变为 $(0,1)$。前进到 $F_9$。（$A=5+1=6$）\n    - 指针在 $F_9$：状态为 $(1,0)$。不是牺牲帧。设置 $R \\leftarrow 0$。$F_9$ 变为 $(0,0)$。前进到 $F_{10}$。（$A=6+1=7$）\n    - 指针在 $F_{10}$：状态为 $(0,1)$。不是牺牲帧。前进到 $F_1$。（$A=7+1=8$）\n    - 指针在 $F_1$：状态为 $(0,1)$。不是牺牲帧。前进到 $F_2$。（$A=8+1=9$）\n    - 指针在 $F_2$：状态为 $(0,0)$。**找到牺牲帧。**\n- **第 3 次淘汰总结：**\n    - 本次搜索的前进次数：$4$。\n    - 总前进次数 $A = 9$。\n    - 牺牲帧是 $F_2$。它被替换，因此其状态变为 $(1,0)$。\n    - 指针前进到下一个帧 $F_3$。\n- **第 3 次淘汰后状态：**\n    - 帧：$[(0,1), (1,0), (1,0), (0,1), (0,1), (0,0), (1,0), (0,1), (0,0), (0,1)]$\n    - 指针在 $F_3$。\n\n**第 4 次淘汰**\n- 指针位置：$F_3$。\n- 算法开始扫描第 $0$ 类帧，$(0,0)$。\n- **扫描：**\n    - 指针在 $F_3$：状态为 $(1,0)$。不是牺牲帧。设置 $R \\leftarrow 0$。$F_3$ 变为 $(0,0)$。前进到 $F_4$。（$A=9+1=10$）\n    - 指针在 $F_4$：状态为 $(0,1)$。不是牺牲帧。前进到 $F_5$。（$A=10+1=11$）\n    - 指针在 $F_5$：状态为 $(0,1)$。不是牺牲帧。前进到 $F_6$。（$A=11+1=12$）\n    - 指针在 $F_6$：状态为 $(0,0)$。**找到牺牲帧。**\n- **第 4 次淘汰总结：**\n    - 本次搜索的前进次数：$3$。\n    - 总前进次数 $A = 12$。\n    - 牺牲帧是 $F_6$。它被替换，因此其状态变为 $(1,0)$。\n    - 指针前进到下一个帧 $F_7$。\n- **第 4 次淘汰后状态：**\n    - 帧：$[(0,1), (1,0), (0,0), (0,1), (0,1), (1,0), (1,0), (0,1), (0,0), (0,1)]$\n    - 指针在 $F_7$。\n\n**第 5 次淘汰**\n- 指针位置：$F_7$。\n- 算法开始扫描第 $0$ 类帧，$(0,0)$。\n- **扫描：**\n    - 指针在 $F_7$：状态为 $(1,0)$。不是牺牲帧。设置 $R \\leftarrow 0$。$F_7$ 变为 $(0,0)$。前进到 $F_8$。（$A=12+1=13$）\n    - 指针在 $F_8$：状态为 $(0,1)$。不是牺牲帧。前进到 $F_9$。（$A=13+1=14$）\n    - 指针在 $F_9$：状态为 $(0,0)$。**找到牺牲帧。**\n- **第 5 次淘汰总结：**\n    - 本次搜索的前进次数：$2$。\n    - 总前进次数 $A = 14$。\n    - 牺牲帧是 $F_9$。它被替换，因此其状态变为 $(1,0)$。\n    - 指针前进到下一个帧 $F_{10}$。\n    - 题目要求我们在此刻停止计数前进次数。\n\n所有 $5$ 次淘汰的帧间前进总次数为 $A = 14$。\n\n题目将时钟指针旋转次数定义为总前进次数除以总帧数 $N$。\n$$ \\text{Rotations} = \\frac{A}{N} = \\frac{14}{10} $$\n作为最简分数，结果是：\n$$ \\text{Rotations} = \\frac{7}{5} $$",
            "answer": "$$\\boxed{\\frac{7}{5}}$$"
        },
        {
            "introduction": "在理解了算法的具体步骤之后，我们自然会问：它在平均情况下的表现如何？本练习将教您使用概率论来分析CLOCK算法的平均性能。通过将引用位的状态建模为一个随机过程，您将推导出算法在找到一个可替换页面前需要扫描的期望页面数，这是衡量其效率的关键指标。",
            "id": "3655894",
            "problem": "一个操作系统 (OS) 使用 CLOCK 最近最少使用 (LRU) 近似算法来管理一个页帧的循环列表。每次发生缺页中断时，CLOCK 指针会逐帧前进，按顺序检查每个帧由硬件维护的引用位 $R$。当指针检查到一个 $R=1$ 的帧时，它将 $R$ 设置为 $0$ ($R \\leftarrow 0$) 并前进到下一个帧。当它检查到一个 $R=0$ 的帧时，它会选择该帧作为牺牲帧，并停止为该次缺页中断进行的扫描。\n\n考虑一个瞬时的内存压力高峰，在此期间缺页中断会突发性地出现。假设，在突发中的任何一次缺页中断开始时，那些尚未被指针在该次中断中触及的帧的引用位 $R$ 在各帧之间是相互独立的，并且服从相同的分布，即 $\\Pr(R=1)=u$ 和 $\\Pr(R=0)=1-u$，其中 $u \\in [0,1)$。假设帧的数量足够大，以至于在单次缺页中断的扫描过程中，指针完整扫描一圈的概率可以忽略不计，因此可以将指针的行为建模为探查一个有效的无限独立帧序列，直到遇到第一个 $R=0$ 的帧。\n\n定义随机变量 $X$ 为单次缺页中断期间扫描的帧数，包括牺牲帧在内。从上述定义和基本概率工具出发，推导 $X$ 的概率质量函数，然后计算期望值 $E[X]$ 作为 $u$ 的函数。将你的最终答案表示为关于 $u$ 的封闭形式解析表达式。无需四舍五入。",
            "solution": "问题陈述已经过验证，被认为是合理的、定义明确的，并且没有矛盾或歧义。它描述了算法分析中的一个经典场景，可以使用初等概率论进行建模。我们可以开始求解。\n\n问题要求计算单次缺页中断期间扫描的帧数的期望值 $X$。扫描帧的过程描述如下：CLOCK 指针顺序检查帧。如果一个帧的引用位 $R$ 为 $1$，它被重置为 $0$，指针前进。如果 $R$ 为 $0$，该帧被选为牺牲帧，扫描终止。\n\n问题为单次缺页中断扫描开始时引用位的状态提供了一个概率模型。帧的引用位 $R$ 是独立同分布的随机变量，满足：\n$$ \\Pr(R=1) = u $$\n$$ \\Pr(R=0) = 1-u $$\n其中 $u \\in [0,1)$。扫描被建模为探查一个有效的无限序列的此类帧。\n\n随机变量 $X$ 表示扫描的总帧数。扫描在遇到第一个 $R=0$ 的帧时停止。这是一个经典的独立伯努利试验序列。我们定义“成功”为找到一个 $R=0$ 的帧的事件，“失败”为找到一个 $R=1$ 的帧。在任何单次试验中（检查一个帧）的成功概率是 $p = \\Pr(R=0) = 1-u$。失败的概率是 $q = \\Pr(R=1) = u$。\n\n随机变量 $X$ 是获得第一次成功所需的试验次数。根据定义，这是一个服从几何分布的随机变量。我们可以推导出它的概率质量函数 (PMF)，记为 $P(k) = \\Pr(X=k)$，对于任何整数 $k \\geq 1$。\n\n为了使扫描在第 $k$ 个帧处终止（即，$X=k$ 发生），必须满足两个条件：\n1. 扫描的前 $k-1$ 个帧的引用位必须为 $R=1$。\n2. 扫描的第 $k$ 个帧的引用位必须为 $R=0$。\n\n由于各帧的引用位是独立的，这一系列事件的概率是它们各自概率的乘积：\n$$ \\Pr(X=k) = \\underbrace{\\Pr(R=1) \\times \\Pr(R=1) \\times \\dots \\times \\Pr(R=1)}_{k-1 \\text{ 次}} \\times \\Pr(R=0) $$\n代入给定的概率，我们得到：\n$$ P(k) = \\Pr(X=k) = u^{k-1} (1-u) \\quad \\text{对于 } k = 1, 2, 3, \\dots $$\n这就是随机变量 $X$ 的 PMF。\n\n下一步是计算 $X$ 的期望值，记为 $E[X]$。根据离散随机变量期望的定义，我们有：\n$$ E[X] = \\sum_{k=1}^{\\infty} k \\cdot \\Pr(X=k) $$\n代入我们推导出的 PMF：\n$$ E[X] = \\sum_{k=1}^{\\infty} k \\cdot u^{k-1} (1-u) $$\n我们可以将常数项 $(1-u)$ 从求和中提取出来：\n$$ E[X] = (1-u) \\sum_{k=1}^{\\infty} k u^{k-1} $$\n这个求和具有等差-等比级数的形式。我们可以通过回顾几何级数的公式来計算它。对于任何满足 $|x|<1$ 的变量 $x$，我们有：\n$$ \\sum_{k=0}^{\\infty} x^k = \\frac{1}{1-x} $$\n对两边关于 $x$ 求导，得到：\n$$ \\frac{d}{dx} \\left( \\sum_{k=0}^{\\infty} x^k \\right) = \\frac{d}{dx} \\left( \\frac{1}{1-x} \\right) $$\n$$ \\sum_{k=1}^{\\infty} k x^{k-1} = -1 \\cdot (1-x)^{-2} \\cdot (-1) = \\frac{1}{(1-x)^2} $$\n我们 $E[X]$ 表达式中的求和正是这种形式，其中 $x=u$。由于问题陈述 $u \\in [0,1)$，条件 $|u|<1$ 得到满足，级数收敛。\n所以，我们可以代入求和的结果：\n$$ \\sum_{k=1}^{\\infty} k u^{k-1} = \\frac{1}{(1-u)^2} $$\n现在，我们将其代回 $E[X]$ 的方程中：\n$$ E[X] = (1-u) \\left( \\frac{1}{(1-u)^2} \\right) $$\n$$ E[X] = \\frac{1-u}{(1-u)^2} $$\n化简表达式得到最终结果：\n$$ E[X] = \\frac{1}{1-u} $$\n这个结果与成功概率为 $p=1-u$ 的几何分布的均值（即 $1/p$）的已知公式是一致的。\n物理上的解释也证实了这一结果。如果 $u$ 接近 $0$，大多数位都是 $0$，所以我们期望很快找到一个牺牲帧，$E[X]$ 接近 $1$。如果 $u$ 接近 $1$，大多数位都是 $1$，我们期望在找到牺牲帧之前扫描许多帧，所以 $E[X]$ 趋近于无穷大，这与推导出的表达式的行为相符。",
            "answer": "$$\\boxed{\\frac{1}{1-u}}$$"
        },
        {
            "introduction": "理论知识的最终目的是应用于实践。本练习将让您扮演系统性能工程师的角色，并向您介绍另一种LRU近似算法——老化算法（Aging algorithm）。您将学习如何利用工作负载的特征（具体来说是重用距离直方图）来智能地调整算法参数以达到预设的性能目标，从而连接起算法理论与系统实践的桥梁。",
            "id": "3655920",
            "problem": "一个单处理器虚拟内存系统使用老化（Aging）页面替换算法（一种最近最少使用（LRU）算法的近似实现）。每个页面都有一个$B$位计数器。每经过$\\Delta$次内存引用，硬件会执行一个周期性操作：它将每个页面的计数器右移一位，并将该页面当前的引用位插入到最高有效位，然后清除引用位。随着时间的推移，这会为每个页面生成一个指数衰减的近期性得分。\n\n给定一个从长时间运行的工作负载中测得的重用距离（栈距离）直方图。一次引用的重用距离是指在两次连续引用同一页面之间访问的不同页面的数量。在精确的最近最少使用（LRU）算法下，当且仅当一次引用的重用距离小于或等于物理帧数$F$时，该引用命中。测得的重用距离直方图（以页面为单位）如下：\n- 在范围$[1,8]$内：概率$0.25$，\n- 在范围$[9,16]$内：概率$0.25$，\n- 在范围$[17,32]$内：概率$0.20$，\n- 在范围$[33,64]$内：概率$0.20$，\n- 在范围$[65,128]$内：概率$0.05$，\n- 大于$128$或首次（冷）引用：概率$0.05$。\n\n假设系统有$F=64$个物理帧，并使用宽度为$B=8$位的计数器。你希望设置周期$\\Delta$（每次老化移位对应的内存引用次数），以便启发式地使那些重用距离处于或低于目标分位数$X=0.9$的页面保持驻留，从而模拟精确LRU在该分位数下的命中行为。请仅从上述核心定义（重用距离、精确LRU的命中条件，以及老化算法作为每次周期性右移一位的指数衰减行为的定性描述）出发，推导出一个有原则的启发式方法，从直方图中选择$\\Delta$，并计算此工作负载下得到的$\\Delta$值。\n\n将你最终的$\\Delta$报告为单个实数值。最终答案中不要包含任何单位。",
            "solution": "用户希望我解决以下问题。首先，我将验证问题陈述。\n\n**问题验证**\n\n**第一步：提取已知条件**\n- **算法**：老化页面替换算法。\n- **计数器宽度**：$B$位。\n- **老化周期**：$\\Delta$次内存引用。\n- **老化操作**：每$\\Delta$次引用：将每个计数器右移一位，将页面的引用位插入最高有效位（MSB），并清除引用位。\n- **重用距离**：两次连续引用同一页面之间访问的不同页面数量。\n- **精确LRU命中条件**：当且仅当一次引用的重用距离小于或等于物理帧数$F$时，该引用命中。\n- **重用距离直方图**：\n  - 范围$[1, 8]$：概率$0.25$。\n  - 范围$[9, 16]$：概率$0.25$。\n  - 范围$[17, 32]$：概率$0.20$。\n  - 范围$[33, 64]$：概率$0.20$。\n  - 范围$[65, 128]$：概率$0.05$。\n  - 范围$> 128$或首次引用：概率$0.05$。\n- **系统参数**：\n  - 物理帧数，$F=64$。\n  - 计数器宽度，$B=8$位。\n- **目标**：设置$\\Delta$，使重用距离处于或低于目标分位数$X=0.9$的页面保持驻留。\n- **任务**：推导一个有原则的启发式方法来选择$\\Delta$并计算其值。\n\n**第二步：使用提取的已知条件进行验证**\n该问题具有科学依据，描述了著名的老化算法，这是操作系统理论中的一个核心内容。重用距离、LRU和页面替换等概念都是标准且定义明确的。问题是适定的，提供了所有必要的数据（$F$、$B$、工作负载直方图和目标分位数$X$）来推导启发式方法并计算$\\Delta$的值。语言客观而精确。该问题没有科学缺陷、矛盾和歧义，只有一个小例外，即“内存引用”和“访问的不同页面”之间的关系，这是此类问题中常见的简化。该问题是将理论概念应用于实践性问题的有效练习。\n\n**第三步：结论与行动**\n问题被判定为**有效**。将提供解决方案。\n\n**求解推导**\n\n问题的核心是在工作负载的统计特性与老化算法的可配置参数$\\Delta$之间建立一个有原则的联系。目标是使老化算法的行为模拟理想LRU策略在工作负载特定部分的行为。\n\n首先，我们必须确定与指定分位数$X=0.9$相对应的目标重用距离。直方图提供了重用距离的概率分布。我们可以计算累积分布函数（CDF）来找到标记第90个百分位数的重用距离。\n设$d$为重用距离。累积概率为：\n- $P(d \\le 8) = 0.25$\n- $P(d \\le 16) = P(d \\le 8) + P(9 \\le d \\le 16) = 0.25 + 0.25 = 0.50$\n- $P(d \\le 32) = P(d \\le 16) + P(17 \\le d \\le 32) = 0.50 + 0.20 = 0.70$\n- $P(d \\le 64) = P(d \\le 32) + P(33 \\le d \\le 64) = 0.70 + 0.20 = 0.90$\n\n因此，在$X=0.9$分位数处的重用距离是$d_{0.9} = 64$。目标是调整$\\Delta$，以确保重用距离高达64的页面很可能继续驻留在内存中。\n\n接下来，我们分析老化算法的机制。每个页面都有一个$B$位计数器。一个页面被引用，其引用位被置位。在下一次周期性更新时（经过$\\Delta$次内存引用后），这个1被移入计数器的最高有效位（MSB）。如果该页面没有再次被引用，随后的更新将在每$\\Delta$次内存引用后将这个1向右移动一位，同时将0移入最高有效位。当一个页面的计数值降至0时，它就成为被置换的主要候选者。\n\n一个引用位一旦被捕获到$B$位计数器的最高有效位，经过$B$个未被引用的周期后，将完全移出计数器。这个过程发生的时间，以内存引用次数计算，是$B \\times \\Delta$。这个持续时间代表了算法的“记忆”或“保护窗口”；它是一个页面在单次引用后被保护免于置换的大致时间。\n\n启发式方法是将这个保护窗口与目标重用距离的时间尺度等同起来。目标重用距离是$d_{0.9} = 64$个不同的页面。关键一步是将这个度量与以内存引用次数衡量的时间流逝联系起来。问题陈述区分了“不同的页面”（用于重用距离）和“内存引用”（用于$\\Delta$）。在没有具体模型将两者映射的情况下，为了进行这种高层次的分析，最直接和标准的简化假设是在一对一的基础上将它们等同起来。也就是说，我们假设重用距离$d$对应于一个跨越大约$d$次内存引用的时间间隔。\n\n在此假设下，与目标重用距离$d_{0.9}$对应的时间窗口是64次内存引用。我们希望算法的保护窗口至少有这么长。因此，我们让这两个量相等：\n$$B \\times \\Delta = d_{0.9}$$\n这个方程构成了我们有原则的启发式方法。它确保了近期性最弱的证据（一个单一的引用位）衰减到零所需的时间，与我们希望保护的最大重用距离相匹配。\n\n我们已知$B=8$，并已计算出$d_{0.9}=64$。将这些值代入我们的启发式方程：\n$$8 \\times \\Delta = 64$$\n解出$\\Delta$：\n$$\\Delta = \\frac{64}{8} = 8$$\n因此，老化周期应设置为$\\Delta=8$次内存引用/每次移位。这确保了一个页面在被引用后，在大约$B \\times \\Delta = 8 \\times 8 = 64$次内存引用的时间内受到保护，免于被置换，这与该工作负载在第90个百分位数上的目标重用距离相匹配。值得注意的是，这个64的目标重用距离恰好与物理帧数$F=64$相匹配，这意味着我们的调优旨在使老化算法在该工作负载达到第90个百分位数的命中率时，其行为类似于具有64个帧的精确LRU策略。",
            "answer": "$$\\boxed{8}$$"
        }
    ]
}