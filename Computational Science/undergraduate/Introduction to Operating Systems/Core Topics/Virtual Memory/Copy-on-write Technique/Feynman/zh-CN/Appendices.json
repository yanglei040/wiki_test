{
    "hands_on_practices": [
        {
            "introduction": "“写时复制” (COW) 的核心优势在于它避免了在 `fork` 时立即复制整个进程的内存。然而，这种优化的效果究竟有多大？本练习旨在通过构建一个概率模型来量化 COW 的性能。通过运用基本的概率论，我们将推导出由子进程的写操作引发的 COW 页面错误的期望次数，从而让你亲身体会到 COW 在写操作不频繁的工作负载下是如何节省系统资源的。",
            "id": "3629158",
            "problem": "一个操作系统通过通常称为 fork 的系统调用，在进程创建时实现了写时复制（Copy-On-Write, COW）。fork 调用后，子进程和父进程共享相同的物理页；所有共享的映射都被标记为只读。当首次写入任何共享页时，会发生一个 COW 页错误：内核分配一个新的物理页，复制原始页的内容，将发生错误的进程的页表更新为指向新的私有页，然后重试写操作。同一进程后续对该页的写入不会再引发 COW 错误，因为该页现在是私有且可写的。读操作不会导致 COW 错误。\n\n考虑一个进程，其地址空间由 $n$ 个虚拟内存页组成，每个页的大小为 $S$ 字节。fork之后，只有子进程可以写入。对于这 $n$ 个页中的每一个，子进程独立地以概率 $p \\in [0,1]$ 对该页尝试进行一次写操作，并以概率 $1-p$ 不对该页进行写操作。假设除了子进程自己的第一次写入外，没有其他写入者，也没有其他会破坏共享的干预事件。每次 COW 页错误会精确复制一个大小为 $S$ 字节的页。\n\n从概率论的基本原理（伯努利试验、指示器随机变量和期望的线性性）以及上面给出的 COW 的操作系统定义出发，推导一个用 $n$、$p$ 和 $S$ 表示的表达式，用于计算：\n- 子进程引发的 COW 页错误的期望数量，以及\n- 由于 COW 复制的总字节数的期望值。\n\n将总字节数以字节为单位表示。请使用 LaTeX 的 `pmatrix` 环境将你的最终答案表示为一个双元素行矩阵，其中第一个元素等于 COW 错误的期望数量，第二个元素等于由于 COW 复制的总字节数的期望值。最终答案中不要包含任何文本注释。",
            "solution": "问题要求计算通过 `fork` 创建的子进程所产生的写时复制（COW）页错误的期望数量以及因 COW 而复制的总字节数的期望值。这个问题定义明确，科学上基于操作系统和概率论的原理，并且包含了得出唯一解所需的所有信息。\n\n设 $n$ 为进程地址空间中的虚拟内存页数。\n设 $S$ 为每个页的大小（以字节为单位）。\n设 $p$ 为子进程对任意给定页尝试进行一次写操作的概率。对 $n$ 个页中每一个的写尝试都是独立事件。\n\n当且仅当子进程尝试对特定页进行第一次写操作时，该页上才会发生 COW 页错误。问题陈述，对于每个页，子进程以概率 $p$ 进行一次写尝试。因此，给定页发生 COW 错误的概率为 $p$。\n\n为了求出 COW 页错误的期望数量，我们可以使用指示器随机变量来对情况建模。我们为每个页 $i$ 定义一个指示器随机变量 $X_i$，其中 $i \\in \\{1, 2, \\dots, n\\}$。\n\n指示器随机变量 $X_i$ 定义如下：\n$$\nX_i = \\begin{cases}\n1  \\text{如果页 } i \\text{ 上发生 COW 错误} \\\\\n0  \\text{如果页 } i \\text{ 上没有发生 COW 错误}\n\\end{cases}\n$$\n\n如果子进程写入页 $i$，则页 $i$ 上发生 COW 错误。此事件的概率为 $p$。\n因此，$X_i$ 的概率分布为：\n$P(X_i = 1) = p$\n$P(X_i = 0) = 1-p$\n\n这是对每个页 $i$ 的一次伯努利试验。伯努利随机变量的期望值是成功的概率。因此，$X_i$ 的期望值为：\n$$E[X_i] = 1 \\cdot P(X_i=1) + 0 \\cdot P(X_i=0) = 1 \\cdot p + 0 \\cdot (1-p) = p$$\n\nCOW 页错误的总数，我们称这个随机变量为 $N_{faults}$，是所有 $n$ 个页的指示器变量之和，因为每个 $X_i$ 如果发生，就计为一个错误。\n$$N_{faults} = \\sum_{i=1}^{n} X_i$$\n\n为了求出 COW 页错误总数的期望值，我们计算 $N_{faults}$ 的期望。我们使用期望的线性性，该性质指出，随机变量之和的期望等于它们各自期望之和。无论随机变量是否独立，此性质都成立。在这个问题中，事件被说明是独立的，但期望的线性性并不需要这个假设。\n$$E[N_{faults}] = E\\left[\\sum_{i=1}^{n} X_i\\right] = \\sum_{i=1}^{n} E[X_i]$$\n\n由于对所有页 $i = 1, \\dots, n$ 都有 $E[X_i] = p$，所以总和变为：\n$$E[N_{faults}] = \\sum_{i=1}^{n} p = n \\cdot p$$\n这就是子进程引发的 COW 页错误的期望数量。\n\n接下来，我们需要求出因 COW 而复制的总字节数的期望值。\n问题陈述，每次 COW 页错误导致精确复制一个大小为 $S$ 字节的页。\n设 $B_{copied}$ 为表示复制的总字节数的随机变量。\n复制的总字节数是 COW 错误次数乘以每次错误复制的字节数。\n$$B_{copied} = N_{faults} \\cdot S$$\n\n我们想求出 $B_{copied}$ 的期望值，即 $E[B_{copied}]$。\n$$E[B_{copied}] = E[N_{faults} \\cdot S]$$\n由于 $S$ 是一个常数，我们可以将其从期望中提出来：\n$$E[B_{copied}] = S \\cdot E[N_{faults}]$$\n\n我们已经推导出 $E[N_{faults}] = np$。将此结果代入方程中得到：\n$$E[B_{copied}] = S \\cdot (np) = npS$$\n这就是因 COW 而复制的总字节数的期望值。\n\n最终答案要求一个包含 COW 错误期望数量和复制的总字节数期望值的双元素行矩阵。\n第一个元素是 $E[N_{faults}] = np$。\n第二个元素是 $E[B_{copied}] = npS$。",
            "answer": "$$\\boxed{\\begin{pmatrix} np & npS \\end{pmatrix}}$$"
        },
        {
            "introduction": "在评估系统性能时，除了分析平均情况，理解最坏情况下的行为也至关重要，因为它决定了系统的稳定性和响应能力的下限。本练习将引导你分析一个旨在最大化“写时复制”开销的“最坏情况”写模式。通过对这个假设场景的建模，你将学会如何识别性能瓶颈，并将操作系统行为（COW）与底层硬件能力（内存带宽）联系起来，计算出满足特定性能目标所需的系统资源。",
            "id": "3629086",
            "problem": "一个多进程操作系统在通过系统调用 `fork` 创建进程时使用写时复制 (Copy-on-Write, COW) 技术。在 COW 机制下，子进程最初共享父进程的内存页面；对任一共享页面的首次写入会触发一个缺页中断，之后操作系统会分配一个新的物理帧并复制整个原始页面，然后才允许写入操作继续。考虑一个父进程，其私有地址空间大小为 $S$ 字节，按页面边界对齐，页面大小为 $P$ 字节。子进程执行一种最坏情况下的写入模式，通过在每个不同的页面中精确写入一个字节，以等于页面大小的步长顺序进行，并且从不重复访问一个页面，从而最大化 COW 页面复制次数。假设以下系统参数：\n- $S = 8\\,\\mathrm{GiB}$，其中 $1\\,\\mathrm{GiB} = 2^{30}\\,\\mathrm{字节}$，\n- $P = 4\\,\\mathrm{KiB}$，其中 $1\\,\\mathrm{KiB} = 2^{10}\\,\\mathrm{字节}$，\n- 每次缺页中断在操作系统中花费的恒定处理开销为 $\\tau_{\\mathrm{pf}} = 2 \\times 10^{-6}\\,\\mathrm{s}$ （例如，陷阱处理、页帧分配、页表更新、转换后备缓冲区 (Translation Lookaside Buffer, TLB) shootdown），\n- 可用于数据移动的持续内存带宽预算为 $B_{\\mathrm{actual}} = 25\\,\\mathrm{GiB/s}$。\n\n使用以下基本事实：\n- 页面数量为 $N = S / P$。\n- 对一个先前共享的页面的 COW 写入需要复制整个页面，在最坏情况下，这会引发两次大小均为 $P$ 的主存传输（一次读取旧页面和一次写入新页面），外加应用程序实际写入的 1 字节；在最坏情况下，缓存无法消除这些传输。\n- 对于持续的流式传输，内存带宽将数据移动量 $D$（以字节为单位）与时间 $t$（以秒为单位）通过关系式 $t = D / B$ 相关联。\n\n从这些基本原理出发，推导一个封闭形式的表达式，用于计算在 $T_{\\mathrm{goal}} = 5.0\\,\\mathrm{s}$ 的截止时间内完成子进程在整个地址空间上每页写入一字节的操作所需的最小持续内存带宽 $B_{\\mathrm{req}}$（单位为 $\\mathrm{GiB/s}$），并在给定可用带宽 $B_{\\mathrm{actual}}$ 的情况下，计算实际完成时间 $T_{\\mathrm{actual}}$（单位为 $\\mathrm{s}$）。将 $B_{\\mathrm{req}}$ 以 $\\mathrm{GiB/s}$ 表示，将 $T_{\\mathrm{actual}}$ 以 $\\mathrm{s}$ 表示。将两个数值结果四舍五入到四位有效数字。",
            "solution": "该问题陈述已经过验证，并被认为是科学上合理的、定义明确且客观的。它基于操作系统的既定原则，特别是写时复制 (COW) 内存管理技术，提出了一个可解决的性能分析场景。所有必要的参数都已提供，目标也已明确定义。\n\n核心任务是确定一系列 COW 操作所需的总时间，然后利用这种关系求解所需的带宽和实际完成时间。\n\n首先，我们根据给定参数确定基本量。\n父进程地址空间的大小为 $S = 8\\,\\mathrm{GiB} = 8 \\times 2^{30}\\,\\mathrm{bytes} = 2^{3} \\times 2^{30}\\,\\mathrm{bytes} = 2^{33}\\,\\mathrm{bytes}$。\n页面大小为 $P = 4\\,\\mathrm{KiB} = 4 \\times 2^{10}\\,\\mathrm{bytes} = 2^{2} \\times 2^{10}\\,\\mathrm{bytes} = 2^{12}\\,\\mathrm{bytes}$。\n地址空间中的页面数量 $N$ 是总大小除以页面大小：\n$$N = \\frac{S}{P} = \\frac{2^{33}\\,\\mathrm{bytes}}{2^{12}\\,\\mathrm{bytes}} = 2^{21}$$\n数值上，$N = 2,097,152$ 页。\n\n问题描述了最坏情况的场景，即子进程对 $N$ 个不同的页面各精确写入一次。每次对共享页面的这种写入都会触发一次缺页中断和一次 COW 操作。完成整个序列的总时间是 $N$ 次 COW 事件各自时间的总和。\n\n我们来分析单个 COW 事件所需的时间 $T_{\\mathrm{fault}}$。该时间由两部分组成：\n1. 操作系统处理缺页中断的恒定开销 $\\tau_{\\mathrm{pf}}$。\n2. 执行内存复制所需的时间 $t_{\\mathrm{copy}}$。\n\n问题指出，一次 COW 操作涉及读取原始页面并将其写入新分配的帧中。这对应于每次中断总共 $D_{\\mathrm{fault}} = P + P = 2P$ 字节的数据传输。此数据传输所花费的时间取决于可用内存带宽 $B$，遵循关系式 $t = D/B$。因此，\n$$t_{\\mathrm{copy}} = \\frac{2P}{B}$$\n单次中断的总时间是开销和复制时间之和：\n$$T_{\\mathrm{fault}} = \\tau_{\\mathrm{pf}} + t_{\\mathrm{copy}} = \\tau_{\\mathrm{pf}} + \\frac{2P}{B}$$\n由于有 $N$ 个这样的独立且顺序的事件，完成该过程的总时间 $T_{\\mathrm{total}}$ 是单个事件时间的 $N$ 倍：\n$$T_{\\mathrm{total}}(B) = N \\times T_{\\mathrm{fault}} = N \\left( \\tau_{\\mathrm{pf}} + \\frac{2P}{B} \\right)$$\n可以展开为：\n$$T_{\\mathrm{total}}(B) = N\\tau_{\\mathrm{pf}} + \\frac{2PN}{B}$$\n我们可以通过认识到 $PN = (S/P)P = S$ 来简化第二项。因此，传输的总数据量为 $2S$。总时间的表达式变为：\n$$T_{\\mathrm{total}}(B) = N\\tau_{\\mathrm{pf}} + \\frac{2S}{B}$$\n这个方程是本问题的核心模型。总时间是总固定操作系统开销 ($N\\tau_{\\mathrm{pf}}$) 和总数据传输时间 ($2S/B$) 的总和。\n\n现在我们可以解决问题的两个部分了。\n\n第 1 部分：推导所需的内存带宽 $B_{\\mathrm{req}}$。\n给定截止时间 $T_{\\mathrm{goal}} = 5.0\\,\\mathrm{s}$。我们需要找到能让进程恰好在此时间内完成的带宽 $B_{\\mathrm{req}}$。我们设 $T_{\\mathrm{total}}(B_{\\mathrm{req}}) = T_{\\mathrm{goal}}$：\n$$T_{\\mathrm{goal}} = N\\tau_{\\mathrm{pf}} + \\frac{2S}{B_{\\mathrm{req}}}$$\n求解 $B_{\\mathrm{req}}$：\n$$T_{\\mathrm{goal}} - N\\tau_{\\mathrm{pf}} = \\frac{2S}{B_{\\mathrm{req}}}$$\n$$B_{\\mathrm{req}} = \\frac{2S}{T_{\\mathrm{goal}} - N\\tau_{\\mathrm{pf}}}$$\n这就是所需带宽的封闭形式表达式。现在，我们代入数值。\n首先，计算总固定开销时间 $N\\tau_{\\mathrm{pf}}$：\n$$N\\tau_{\\mathrm{pf}} = 2^{21} \\times (2 \\times 10^{-6}\\,\\mathrm{s}) = 2,097,152 \\times 2 \\times 10^{-6}\\,\\mathrm{s} = 4.194304\\,\\mathrm{s}$$\n要复制的总数据量是 $2S = 2 \\times 8\\,\\mathrm{GiB} = 16\\,\\mathrm{GiB}$。\n可用于此数据传输的时间必须是 $T_{\\mathrm{goal}} - N\\tau_{\\mathrm{pf}}$：\n$$T_{\\mathrm{goal}} - N\\tau_{\\mathrm{pf}} = 5.0\\,\\mathrm{s} - 4.194304\\,\\mathrm{s} = 0.805696\\,\\mathrm{s}$$\n现在我们可以计算 $B_{\\mathrm{req}}$：\n$$B_{\\mathrm{req}} = \\frac{16\\,\\mathrm{GiB}}{0.805696\\,\\mathrm{s}} \\approx 19.85981\\,\\mathrm{GiB/s}$$\n四舍五入到四位有效数字，我们得到 $B_{\\mathrm{req}} = 19.86\\,\\mathrm{GiB/s}$。\n\n第 2 部分：计算实际完成时间 $T_{\\mathrm{actual}}$。\n我们使用相同的总时间公式，但使用给定的实际带宽 $B_{\\mathrm{actual}} = 25\\,\\mathrm{GiB/s}$。\n$$T_{\\mathrm{actual}} = T_{\\mathrm{total}}(B_{\\mathrm{actual}}) = N\\tau_{\\mathrm{pf}} + \\frac{2S}{B_{\\mathrm{actual}}}$$\n我们已经计算出总开销 $N\\tau_{\\mathrm{pf}} = 4.194304\\,\\mathrm{s}$。使用实际带宽进行数据传输的时间是：\n$$\\frac{2S}{B_{\\mathrm{actual}}} = \\frac{16\\,\\mathrm{GiB}}{25\\,\\mathrm{GiB/s}} = 0.64\\,\\mathrm{s}$$\n实际总时间是这两个部分的总和：\n$$T_{\\mathrm{actual}} = 4.194304\\,\\mathrm{s} + 0.64\\,\\mathrm{s} = 4.834304\\,\\mathrm{s}$$\n四舍五入到四位有效数字，我们得到 $T_{\\mathrm{actual}} = 4.834\\,\\mathrm{s}$。\n\n所需带宽的封闭形式表达式为 $B_{\\mathrm{req}} = \\frac{2S}{T_{\\mathrm{goal}} - (S/P)\\tau_{\\mathrm{pf}}}$。$B_{\\mathrm{req}}$ (单位为 $\\mathrm{GiB/s}$) 和 $T_{\\mathrm{actual}}$ (单位为 $\\mathrm{s}$) 的数值结果分别为 $19.86$ 和 $4.834$。",
            "answer": "$$\\boxed{\\begin{pmatrix} 19.86 & 4.834 \\end{pmatrix}}$$"
        },
        {
            "introduction": "“写时复制” (COW) 不仅仅是 `fork` 系统调用的一个优化技巧，它还是现代操作系统中一个应用广泛的基础机制，尤其是在内存映射文件中。本练习探讨了 COW 在私有文件映射 (`MAP_PRIVATE`) 中与文件系统页面缓存的微妙交互。通过分析这个场景，你将揭示为什么对私有映射的修改会与底层文件隔离开来，从而加深对内存管理和文件系统两大核心子系统如何协同工作的理解。",
            "id": "3629104",
            "problem": "一个类Unix操作系统（OS）上的高级用户空间程序，在一个实现了请求分页、统一页缓存以及私有和共享映射标准语义的内核上使用内存映射文件。考虑一个传统基于块的文件系统（FS）上大小为 $N$ 字节的普通文件。一个进程以读写方式打开该文件，并使用带有写权限的私有映射将其映射到某个虚拟地址 $X$。映射建立后，该进程向映射区域内的一个位置存入一个值，从而在相应的虚拟页上引发一个写错误。\n\n从第一性原理出发，使用以下基本事实来推断会发生什么以及如何通过实验来验证它：\n- 虚拟内存通过每进程页表将虚拟页映射到物理帧；每个映射由一个页表项（PTE）表示。PTE 编码了访问权限以及是否允许写入。\n- 页缓存存储按文件和偏移量索引的文件支持的页；文件系统回写机制将脏的文件支持的缓存页写入磁盘。\n- 文件的私有映射提供写时复制（COW）语义：最初，进程看到的是文件的页缓存内容；在对一个已映射页面进行第一次写入时，内核必须确保进程之间以及与底层文件的隔离。\n- 回写以及通过 msync 和 fsync 进行数据同步的语义是为共享的文件支持的缓存页以及通过显式写系统调用写入的数据定义的。可移植操作系统接口（POSIX）不要求在私有映射上使用 msync 来使修改在文件中可见。\n\n下列哪个陈述是正确的？选择所有适用的选项。\n\nA. 在文件支持的私有映射中，对一个干净的、文件支持的页面的第一次写入会触发写时复制（COW）错误：内核分配一个新的匿名页，复制数据，并更新进程的PTE以指向这个具有写权限的匿名页。原始的文件支持的页缓存页面保持干净。因为进程的脏页现在是匿名的（不在文件的页缓存中），文件系统回写机制不会将这些私有修改写入文件，并且在私有映射上调用 msync 或在文件描述符上调用 fsync 等操作也不会将私有更改传播到文件中。\n\nB. 在文件支持的私有映射中，写错误会就地将文件的页缓存页面标记为脏；因此，后台回写以及调用 msync 或 fsync 会将私有更改传播到磁盘上的文件中。\n\nC. 可以设计一个决定性的用户空间测试，如下所示：通过对一个新打开的文件描述符进行读取来计算文件内容的强校验和 $H_{0}$；使用私有、可写的映射来映射文件并在映射中修改一些字节；然后使用 MS_SYNC 标志调用 msync 并在文件描述符上调用 fsync；解除映射；重新打开文件，并通过一种避免重用任何可能陈旧的内存状态的路径（例如，使用 O_DIRECT 配合对齐的缓冲读取，或者如果策略允许，先清除缓存）读取文件来计算 $H_{1}$；最后，比较 $H_{0}$ 和 $H_{1}$。预期结果为 $H_{0}=H_{1}$，表明文件未被改变，而在解除映射前从私有映射中读取会返回修改后的字节。\n\nD. 要使私有映射的修改写入文件，只需在修改后对文件描述符调用 fsync 即可；fsync 将会定位并回写进程的私有脏页。\n\nE. 一个合适的测试是在另一个进程中用共享映射来映射同一个文件，然后在第一个进程修改其私有映射并调用 msync 后，通过共享映射来读取；如果回写机制起作用，共享映射应该能反映私有映射的写入，因此看到修改后的字节将证实内核已将私有脏页回写到文件中。",
            "solution": "问题陈述描述了在类Unix操作系统中的一个标准场景，涉及文件的私有、可写内存映射。首先评估问题陈述的有效性。\n\n**问题有效性验证**\n\n问题陈述是有效的。它在科学上基于操作系统设计的公认原则，包括虚拟内存、请求分页、页缓存以及私有（`MAP_PRIVATE`）与共享（`MAP_SHARED`）内存映射之间的区别。所提供的基本事实准确地描述了像Linux这样的现代内核如何处理这些概念。这个问题提得很好，客观且自成体系，提出了一个可以根据给定原则进行推理的关于系统行为的清晰问题。这是一个不简单的问题，它探究了内存管理和文件系统子系统之间微妙的相互作用。\n\n**从第一性原理推导**\n\n控制文件私有、可写映射行为的核心概念是**写时复制（Copy-On-Write, COW）**。正如问题基本事实中所规定的，该机制对于提供隔离至关重要。让我们追踪一下事件的顺序。\n\n1.  **映射建立**：进程请求对文件进行私有、可写的映射。内核为指定的地址范围配置进程的虚拟内存区域（VMA），并注明这是一个对给定文件的可写、私有映射。然后，内核填充该进程在此范围内的页表项（PTE）。至关重要的是，为了强制执行COW，内核在硬件页表中将这些PTE标记为**只读**，尽管VMA本身被标记为可写。这些PTE最初将指向位于内核统一页缓存中文件的相应页面。\n\n2.  **写错误**：进程试图向映射的虚拟地址范围内的某个字节写入数据。CPU的内存管理单元（MMU）检测到对一个被其PTE标记为只读的页面的写操作。这个违规行为会触发一个页错误，这是一个陷入内核的陷阱。\n\n3.  **内核错误处理（COW）**：内核的页错误处理程序检查该错误。它确定错误发生在一个进程合法可写的VMA内的地址上，但错误是由对一个只读PTE的写入触发的。这种特定的组合表明这是一个私有映射上的COW错误。内核执行以下操作：\n    a. 内核分配一个新的、空的物理页帧。这个页面是**匿名内存**；它不与任何文件关联，专属于该进程。\n    b. 内核将原始文件支持的页面（来自页缓存）的全部内容复制到这个新的匿名页面中。\n    c. 内核更新进程中引发错误的虚拟页的PTE。新的PTE现在指向新的匿名页，其访问权限被更改为**读-写**。\n    d. 内核从错误处理程序返回，CPU重新执行导致错误的指令。由于页面现在被映射为可写，写入操作成功。\n\n4.  **COW的后果**：\n    *   **隔离**：进程现在拥有了页面的一个私有副本。它所做的任何修改都局限于这个匿名页，对于可能映射了同一文件的其他进程是不可见的。文件页缓存中的原始页面保持不变，因此是“干净”的（非脏）。\n    *   **失去文件支持**：进程的虚拟页不再由文件支持；它由匿名内存支持。就像堆或栈内存一样，如果这个页面因内存压力需要被换出，它将被写入系统的交换区，而不是原始文件。\n    *   **同步语义**：像 `msync` 和 `fsync` 这样的系统调用旨在将文件的页缓存与磁盘存储同步。由于进程修改后的页面是匿名的，不再是文件页缓存的一部分，这些系统调用无法感知它，也没有机制将其内容写入文件。POSIX标准明确指出了这种行为，声明 `msync` 对 `MAP_PRIVATE` 映射的效果是未指定的，在像Linux这样的系统上，实践中它对传播私有更改没有影响。\n\n**逐项分析**\n\n**A. 在文件支持的私有映射中，对一个干净的、文件支持的页面的第一次写入会触发写时复制（COW）错误：内核分配一个新的匿名页，复制数据，并更新进程的PTE以指向这个具有写权限的匿名页。原始的文件支持的页缓存页面保持干净。因为进程的脏页现在是匿名的（不在文件的页缓存中），文件系统回写机制不会将这些私有修改写入文件，并且在私有映射上调用 msync 或在文件描述符上调用 fsync 等操作也不会将私有更改传播到文件中。**\n此陈述是对COW机制及其对私有文件映射后果的精确和完整描述。它正确地指出了匿名页的创建、原始页缓存页面的隔离，以及由此导致的 `msync` 或 `fsync` 无法持久化私有修改。\n**结论**：**正确**。\n\n**B. 在文件支持的私有映射中，写错误会就地将文件的页缓存页面标记为脏；因此，后台回写以及调用 msync 或 fsync 会将私有更改传播到磁盘上的文件中。**\n此陈述不正确。它描述的是**共享**（`MAP_SHARED`）映射的行为，其中修改直接在页缓存页面上进行，从而对其他进程可见并会被回写。这种行为与 `MAP_PRIVATE` 映射的“私有”和“写时复制”语义背道而驰。\n**结论**：**不正确**。\n\n**C. 可以设计一个决定性的用户空间测试，如下所示：通过对一个新打开的文件描述符进行读取来计算文件内容的强校验和 $H_{0}$；使用私有、可写的映射来映射文件并在映射中修改一些字节；然后使用 MS_SYNC 标志调用 msync 并在文件描述符上调用 fsync；解除映射；重新打开文件，并通过一种避免重用任何可能陈旧的内存状态的路径（例如，使用 O_DIRECT 配合对齐的缓冲读取，或者如果策略允许，先清除缓存）读取文件来计算 $H_{1}$；最后，比较 $H_{0}$ 和 $H_{1}$。预期结果为 $H_{0}=H_{1}$，表明文件未被改变，而在解除映射前从私有映射中读取会返回修改后的字节。**\n此陈述概述了一个科学上合理的实验步骤，以验证理论行为。它正确地确定了以下步骤：建立基线（$H_{0}$）、执行私有修改、尝试同步，然后在仔细避免缓存伪影的情况下重新测量磁盘上的状态（$H_{1}$）。预测的结果（$H_{0}=H_{1}$）与我们的推导一致，即私有修改不会被写入文件。额外的检查，即映射本身持有修改后的数据，证实了写操作发生在进程的私有内存中。\n**结论**：**正确**。\n\n**D. 要使私有映射的修改写入文件，只需在修改后对文件描述符调用 fsync 即可；fsync 将会定位并回写进程的私有脏页。**\n此陈述不正确。如前所述，修改后的页面是匿名的，并与内核文件系统层管理的文件数据结构断开连接。`fsync` 系统调用作用于文件描述符及其在页缓存中的相关脏页。它没有机制去查找并回写进程的私有匿名页。\n**结论**：**不正确**。\n\n**E. 一个合适的测试是在另一个进程中用共享映射来映射同一个文件，然后在第一个进程修改其私有映射并调用 msync 后，通过共享映射来读取；如果回写机制起作用，共享映射应该能反映私有映射的写入，因此看到修改后的字节将证实内核已将私有脏页回写到文件中。**\n此陈述描述了一个有效的实验设置，但对预期结果得出了错误的结论。COW机制确保了隔离。第一个进程的写入创建了一个私有副本。带有共享映射的第二个进程将继续看到来自页缓存的原始、未修改的数据。因此，从共享映射中读取**不会**显示修改。该测试实际上可以很好地证明隔离属性，但陈述错误地暗示可能会看到修改后的字节，这是错误的。其前提（“如果回写机制对私有页面起作用”）本身就是不正确的。\n**结论**：**不正确**。",
            "answer": "$$\\boxed{AC}$$"
        }
    ]
}