{
    "hands_on_practices": [
        {
            "introduction": "本练习探讨页面替换算法的选择如何对性能产生巨大影响。通过分析一个简单的循环内存访问模式，您将亲眼看到像最近最少使用（LRU）这样的策略如何导致“颠簸”（thrashing）状态，此时缺页率（PFF）接近于$1$，而其他策略（如随机替换）则可以避免这种灾难性后果。这项实践对于建立工作负载特征与系统策略之间相互作用的直观理解至关重要。",
            "id": "3667744",
            "problem": "一个进程以固定的循环顺序重复访问一个由 $K$ 个不同虚拟页面组成的循环，每个周期内对每个页面进行一次引用，对这 $K$ 个页面的重访频率均等。该进程被分配了 $f$ 个物理页框，其中 $f  K$。不进行预取，内存初始内容为空；考虑在任何瞬态预热过去后的长期稳态。操作系统可以使用三种页面替换策略之一：最近最少使用 (LRU)、时钟页面替换算法 (CLOCK) 或随机替换 (RR)。将页面错误频率 (Page-Fault Frequency, PFF) 定义为每次内存引用的长期平均页面错误数：$PFF = \\lim_{N \\to \\infty} \\frac{F(N)}{N}$，其中 $F(N)$ 记录前 $N$ 次引用中的页面错误次数。\n\n根据这些替换策略的基本定义和所述的工作负载，推断在 $f  K$ 的情况下，每种策略下的稳态 $PFF$。然后，在 $K = 10$ 和 $f = 4$ 的特定情况下，选择能最佳预测各策略间稳态 $PFF$ 顺序并为 RR 提供正确数值预测的选项。\n\nA. 在 LRU 和 CLOCK 策略下，稳态时 $PFF$ 接近每次引用 $1$ 次；在 RR 策略下，$PFF$ 严格小于 $1$，且当 $K = 10$ 和 $f = 4$ 时约为 $0.90$。\n\nB. 在 LRU 和 CLOCK 策略下，稳态时 $PFF$ 接近每次引用 $1$ 次；在 RR 策略下，当 $K = 10$ 和 $f = 4$ 时，$PFF$ 约为 $1 - \\frac{f}{K} = 0.60$。\n\nC. 在 LRU、CLOCK 和 RR 策略下，只要 $f  K$，$PFF$ 就接近每次引用 $1$ 次。\n\nD. 在 LRU 策略下的 $PFF$ 严格小于 CLOCK 策略下的 $PFF$，且两者都严格小于 RR 策略下的 $PFF$，因为 LRU 利用近期性来避免在 $f  K$ 时发生颠簸。",
            "solution": "用户希望我扮演一位严谨的 STEM 教授，解决一个关于页面替换算法的问题。\n\n我的计划如下：\n1.  **验证问题陈述：** 我将首先提取所有给定信息，然后严格检查问题是否科学合理、表述清晰且信息完整。\n2.  **推导解决方案：** 如果问题有效，我将针对给定的工作负载条件，推导三种指定页面替换策略（LRU、CLOCK、RR）各自的页面错误频率 (PFF)。\n3.  **评估选项：** 我将根据我的推导结果分析每个提供的选项，并为每个选项提供明确的结论和理由。\n\n### 第一步：提取已知条件\n\n*   **工作负载：** 一个进程以固定的循环顺序访问一个由 $K$ 个不同虚拟页面组成的循环。\n*   **引用模式：** 每个周期内对每个页面进行一次引用。对这 $K$ 个页面的重访频率均等。\n*   **内存分配：** 该进程被分配了 $f$ 个物理页框。\n*   **约束条件：** $f  K$。\n*   **初始状态：** 不进行预取；内存初始为空。\n*   **分析周期：** 长期稳态。\n*   **策略：** 最近最少使用 (LRU)、时钟页面替换算法 (CLOCK)、随机替换 (RR)。\n*   **定义：** 页面错误频率 (PFF) 定义为 $PFF = \\lim_{N \\to \\infty} \\frac{F(N)}{N}$，其中 $F(N)$ 记录前 $N$ 次引用中的页面错误次数。\n*   **特定情况：** $K = 10$，$f = 4$。\n\n### 第二步：使用提取的已知条件进行验证\n\n对问题陈述进行验证。\n\n*   **科学依据：** 该问题牢固地基于操作系统和算法分析的原理。虚拟内存、页框、页面替换策略（LRU、CLOCK、RR）和颠簸等概念在计算机科学中是标准且成熟的。循环访问模式是用于演示某些算法最坏情况行为的经典工作负载。\n*   **适定性：** 该问题是适定的。访问模式是确定性的，算法定义明确，要计算的量（稳态 PFF）是一个定义明确的极限，对于此设置将会收敛。每种策略都存在唯一的解。\n*   **客观性：** 问题以精确、客观的语言陈述。“固定循环顺序”和“长期稳态”等术语具有明确的技术含义。\n*   **完整性：** 提供了所有必要信息：页面数 ($K$)、页框数 ($f$)、关系 $f  K$、特定的访问模式以及用于分析的策略。\n*   **可行性：** 该场景是一个标准的理论模型。特定的值 $K=10$ 和 $f=4$ 对于分析是合理的。\n\n### 第三步：结论与行动\n\n该问题是**有效的**。这是一个关于页面替换算法分析的标准、适定的问题。我现在将进行推导和求解。\n\n###\n### 页面错误频率 (PFF) 分析\n\n设页面引用序列为 $P_1, P_2, \\dots, P_K, P_1, P_2, \\dots$。已知有 $f  K$ 个页框。\n\n**最近最少使用 (LRU) 策略：**\nLRU 策略替换掉最长时间未被使用的页面。\n1.  最初，前 $f$ 次引用 ($P_1, \\dots, P_f$) 将各自导致一次页面错误，填满 $f$ 个页框。内存将包含 $\\{P_1, P_2, \\dots, P_f\\}$。\n2.  下一次引用是页面 $P_{f+1}$。由于 $f  K$，该页面不在内存中，导致一次错误。最近最少使用的页面是 $P_1$（在 $f$ 步前引用）。LRU 逐出 $P_1$ 并加载 $P_{f+1}$。内存现在包含 $\\{P_2, P_3, \\dots, P_{f+1}\\}$。\n3.  下一次引用是 $P_{f+2}$。这也是一次错误。现在最近最少使用的页面是 $P_2$。LRU 逐出 $P_2$ 并加载 $P_{f+2}$。内存变为 $\\{P_3, P_4, \\dots, P_{f+2}\\}$。\n这种模式会一直持续。对于任何对页面 $P_i$ 的引用，当前驻留在内存中的 $f$ 个页面恰好是 $\\{P_{i-f}, \\dots, P_{i-1}\\}$（索引循环解释）。由于 $f \\ge 1$，页面 $P_i$ 永远不会在这个集合中。\n因此，在稳态下，每一次内存引用都会导致一次页面错误。这是 LRU 的一个经典颠簸（thrashing）场景。\n对于 $N$ 次引用的错误次数 $F(N)$ 将为 $N$（在初始预热后）。\n$$PFF_{LRU} = \\lim_{N \\to \\infty} \\frac{N}{N} = 1$$\n\n**时钟 (CLOCK) 策略：**\nCLOCK 算法是 LRU 的一种近似实现。它维护一个内存中页面的循环列表和一个指针（“时钟指针”）。每个页面都有一个引用位，初始设置为 $1$。发生错误时，算法从时钟指针处开始扫描，寻找引用位为 $0$ 的页面。如果遇到引用位为 $1$ 的页面，它会将其清除为 $0$ 并前移指针。\n在这种特定的循环工作负载下，CLOCK 的行为模拟了 LRU 的最坏情况性能。\n1.  假设 $f$ 个页框已满，装有页面 $\\{P_1, \\dots, P_f\\}$，所有页面的引用位都设置为 $1$。\n2.  对 $P_{f+1}$ 的引用导致一次错误。时钟指针开始扫描。它找到 $P_1$（或指针起始位置的任何页面），看到其引用位为 $1$，将其清除为 $0$，然后前进。它将对内存中的所有 $f$ 个页面 $\\{P_1, \\dots, P_f\\}$ 执行此操作，因为它们最近都被引用过。\n3.  经过一整圈后，指针返回到其起始页面（例如 $P_1$），该页面的引用位现在为 $0$。该页面被选中进行替换。$P_1$ 被逐出，$P_{f+1}$ 被加载，其引用位设置为 $1$。\n内存的状态仍然是最近使用的 $f$ 个页面的集合。循环序列中的下一个页面永远不会存在。因此，就像 LRU 一样，每次引用都会导致一次页面错误。\n$$PFF_{CLOCK} = 1$$\n\n**随机替换 (RR) 策略：**\n当发生错误时，会从驻留页面中均匀随机地选择一个进行逐出。与 LRU 和 CLOCK 不同，这种随机选择避免了与循环访问模式的持续性、病态同步。\n如果请求的页面不在内存中，就会发生页面错误。PFF 是此事件的稳态概率。\n对于循环工作负载，最准确的 PFF 模型涉及生存分析。设 $p_{hit}$ 为命中的稳态概率，则 $PFF = 1 - p_{hit}$。\n对一个页面（比如 $P_i$）的引用将是命中，仅当 $P_i$ 自上次引用以来一直保留在内存中。对 $P_i$ 的上次引用发生在 $K$ 步之前。因此，要使当前对 $P_i$ 的引用发生命中，它必须在 intervening $K-1$ 次内存引用中幸存下来。\n让我们计算一个特定页面在内存中幸存一次内存引用步骤的概率。一个页面被逐出，当且仅当发生一次错误且该特定页面被选中进行替换。\n在任何一步发生错误的概率是 $PFF$。如果发生错误，内存中的 $f$ 个页面之一将被选中进行逐出。任何单个页面被选中的概率是 $1/f$。所以，在任何一步一个给定页面被逐出的概率是 $P(\\text{逐出}) = PFF \\times \\frac{1}{f}$。\n该页面*幸存*一步的概率是 $1 - P(\\text{逐出}) = 1 - \\frac{PFF}{f}$。\n为了命中页面 $P_i$，它必须幸存 $K-1$ 步。其概率为：\n$$p_{hit} = \\left(1 - \\frac{PFF}{f}\\right)^{K-1}$$\n代入 $p_{hit} = 1 - PFF$，我们得到一个关于 $PFF$ 的递归方程：\n$$1 - PFF = \\left(1 - \\frac{PFF}{f}\\right)^{K-1}$$\n对于特定情况 $K = 10$ 和 $f = 4$：\n$$1 - PFF = \\left(1 - \\frac{PFF}{4}\\right)^{9}$$\n我们可以数值求解这个方程，或者测试选项中提供的值。\n让我们测试选项 A 建议的 $PFF \\approx 0.90$。\n*   左边 (LHS): $1 - 0.90 = 0.10$。\n*   右边 (RHS): $\\left(1 - \\frac{0.90}{4}\\right)^{9} = (1 - 0.225)^{9} = (0.775)^{9}$。\n计算 $(0.775)^9$：\n$(0.775)^2 \\approx 0.6006$\n$(0.775)^4 \\approx (0.6006)^2 \\approx 0.3607$\n$(0.775)^8 \\approx (0.3607)^2 \\approx 0.1301$\n$(0.775)^9 = (0.775)^8 \\times 0.775 \\approx 0.1301 \\times 0.775 \\approx 0.1008$\nLHS ($0.10$) 约等于 RHS ($0.1008$)。因此，从这个更准确的模型来看，$PFF_{RR} \\approx 0.90$ 是正确的预测。\n由于 $0.90  1$，RR 的 PFF 严格小于 LRU 和 CLOCK。\n\n一个替代的、更简单的模型假设下一次引用的页面是从 $K$ 个页面中均匀随机选择的。该页面在内存中的概率是 $f/K$。这得出 $PFF = 1 - f/K = 1 - 4/10 = 0.6$。然而，这个模型忽略了“固定循环顺序”，对于这个特定的工作负载，其准确性不如生存分析模型。\n\n###\n### 选项评估\n\n**A. 在 LRU 和 CLOCK 策略下，稳态时 $PFF$ 接近每次引用 $1$ 次；在 RR 策略下，$PFF$ 严格小于 $1$，且当 $K = 10$ 和 $f = 4$ 时约为 $0.90$。**\n*   关于 LRU 和 CLOCK 的 PFF 接近 $1$ 的陈述与我们的分析一致。\n*   关于 RR 的 PFF 严格小于 $1$ 的陈述也是正确的。\n*   对于 $K=10, f=4$ 时 $PFF_{RR} \\approx 0.90$ 的预测与更准确的生存分析模型的结果相匹配，这是对给定循环工作负载的最佳预测。\n*   结论：**正确**。\n\n**B. 在 LRU 和 CLOCK 策略下，稳态时 $PFF$ 接近每次引用 $1$ 次；在 RR 策略下，当 $K = 10$ 和 $f = 4$ 时，$PFF$ 约为 $1 - \\frac{f}{K} = 0.60$。**\n*   陈述的第一部分是正确的。\n*   RR 的数值预测 $0.60$ 是从一个假设均匀随机访问（而非固定循环顺序）的简化模型得出的。产生 $\\approx 0.90$ 结果的生存模型为指定的工作负载提供了更好的预测。因此，此选项不是最佳预测。\n*   结论：**错误**。\n\n**C. 在 LRU、CLOCK 和 RR 策略下，只要 $f  K$，$PFF$ 就接近每次引用 $1$ 次。**\n*   这是错误的。我们的分析表明，对于随机替换 (RR)，PFF 严格小于 $1$。总有非零的命中概率，因为随机逐出选择不会与循环引用模式发生病态同步。\n*   结论：**错误**。\n\n**D. 在 LRU 策略下的 $PFF$ 严格小于 CLOCK 策略下的 $PFF$，且两者都严格小于 RR 策略下的 $PFF$，因为 LRU 利用近期性来避免在 $f  K$ 时发生颠簸。**\n*   声称的 PFF 顺序是 $PFF_{LRU}  PFF_{CLOCK}  PFF_{RR}$。我们的分析得出 $PFF_{LRU} = PFF_{CLOCK} = 1$ 和 $PFF_{RR} \\approx 0.90$。正确的顺序是 $PFF_{RR}  PFF_{LRU} = PFF_{CLOCK}$。所声称的顺序是错误的。\n*   提供的理由也是错误的。对于这种 $f  K$ 的循环工作负载，LRU 对近期性的利用直接导致了最坏情况的颠簸场景（$PFF=1$），而不是避免它。\n*   结论：**错误**。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "在理解了不同策略的影响之后，本练习将缺页率（PFF）分析应用于一个具体且广泛使用的算法：快速排序。您将对该算法的内存需求进行建模，包括其递归堆栈使用情况和分区阶段的数据访问模式，并根据页面大小和内存引用密度等基本参数推导出 PFF。这项练习旨在连接抽象的算法设计与真实的系统性能，让您学会如何从系统层面分析程序的内存行为。",
            "id": "3667713",
            "problem": "一个单线程、原地的快速排序（Quicksort）算法对一个大小为 $N$ 个元素、存储在连续虚拟内存中的数组进行分区。系统使用请求分页机制，页面大小固定为 $p$ 字节，并采用最近最少使用 (LRU) 页面置换算法。每个数组元素的大小为 $b$ 字节。每次快速排序的递归调用会分配一个大小为 $s$ 字节的栈帧，在其最大递归深度时，算法达到深度 $d$。在对一个大子数组进行分区时，假设访问模式是对该子数组的顺序前向扫描。进一步假设，在分区过程中，每个元素平均会引发 $\\gamma$ 次内存引用，这些引用指向其自身页面上的数据（读和写的总和），并且主元选择和索引变量包含在常驻的栈页面中。在对一个大子数组进行分区开始时，该子数组的数据页面均非常驻。该进程被分配了 $F$ 个页框，并且其常驻的栈页面在整个分区过程中都占用着页框。你可以假设 $F \\ge \\left\\lceil \\frac{d s}{p} \\right\\rceil + 1$，因此在扫描期间至少有 $1$ 个页框可用于数据页面。\n\n仅使用工作集的核心定义和缺页频率的定义，完成以下任务：\n\n- 估算在递归深度为 $d$ 的分区过程中，峰值工作集大小，作为 $d$、$s$ 和 $p$ 的函数。\n- 然后，在所述条件下，推导在扫描大子数组分区期间，预期的缺页频率（每次内存引用的缺页次数）的封闭形式解析表达式，用 $b$、$\\gamma$ 和 $p$ 表示。\n\n仅提供预期的缺页频率的最终表达式。无需单位。不要四舍五入。",
            "solution": "该问题陈述已经过验证，被认为是科学严谨、定义明确且客观的。它提供了一个自洽、简化的程序行为和内存管理模型，适合在操作系统导论的背景下进行分析。所有推导所需量所必需的参数和条件均已指定。\n\n该问题需要两个不同的推导。首先，估算峰值工作集大小；其次，推导缺页频率的表达式。最终答案仅要求后者。\n\n第一部分：峰值工作集大小估算\n\n在此背景下，一个进程的工作集指的是它为实现高效执行而无需发生颠簸（thrashing）所需常驻内存的页面集合。峰值工作集大小对应于在指定的执行阶段中同时所需的最大页面数。在递归深度为 `$d$` 时，进程使用内存来存储其执行栈和正在分区的数组数据。\n\n1.  栈页面：快速排序算法处于递归深度 `$d$`。每次递归调用分配一个大小为 `$s$` 字节的栈帧。因此，栈消耗的总内存为 `$d \\times s$` 字节。给定页面大小为 `$p$` 字节，在此深度下存储整个调用栈所需的页面数由总栈大小除以页面大小的向上取整值给出。设 `$WSS_{stack}$` 为栈的工作集大小。\n    $$WSS_{stack} = \\left\\lceil \\frac{d s}{p} \\right\\rceil$$\n    问题陈述指出这些页面是常驻的，因此它们是工作集的一部分。\n\n2.  数据页面：分区步骤涉及对子数组的顺序扫描。对于简单的顺序扫描，局部性原理意味着在任何给定时间，内存引用都集中在少数页面上。随着扫描从一个元素进展到下一个元素，它线性地在内存中移动。在任何时刻，算法都在主动读写驻留在单个页面上的元素。当扫描跨越页面边界时，一个新的页面变为活动状态。考虑到最近最少使用（LRU）页面置换策略和扫描的顺序、非重复性，为保证程序进展，内存中所需的数据页面的最小数量仅为 `$1$` 个，即当前访问的页面。假设 `$F \\ge \\left\\lceil \\frac{d s}{p} \\right\\rceil + 1$` 明确保证了至少有一个页框可用于数据页面，从而防止栈页面换出活动的数据页面。因此，数据部分的工作集大小 `$WSS_{data}` 可以估计为 `$1$` 个页面。\n\n3.  总峰值工作集大小：总峰值工作集 `$W$` 是栈和数据所需页面的总和。\n    $$W(d, s, p) = WSS_{stack} + WSS_{data} = \\left\\lceil \\frac{d s}{p} \\right\\rceil + 1$$\n    该表达式表示在递归深度为 `$d$` 的分区过程中，以页面为单位的估算峰值工作集大小。\n\n第二部分：缺页频率推导\n\n缺页频率 (PFF) 定义为每次内存引用的缺页次数。\n$$PFF = \\frac{\\text{总缺页次数}}{\\text{总内存引用次数}}$$\n我们可以通过分析一个代表性区间内的事件来计算这个频率。在对大子数组进行分区顺序扫描期间，最方便的区间是处理单个数据页面内包含的所有元素的过程。\n\n1.  每页元素数：一个页面的大小为 `$p$` 字节。每个数组元素的大小为 `$b$` 字节。假设元素是连续打包的，则每页的元素数 `$E_{page}$` 为：\n    $$E_{page} = \\frac{p}{b}$$\n\n2.  每页总内存引用数：问题陈述指出，每个元素平均会引发 `$\\gamma$` 次对其自身页面上数据的内存引用。对主元和索引变量的引用由栈页面处理，这些页面已经是常驻的，因此不会导致数据缺页。因此，在处理单个页面上的元素时生成的总内存引用数 `$R_{page}$` 为：\n    $$R_{page} = E_{page} \\times \\gamma = \\frac{p}{b} \\gamma$$\n\n3.  每页缺页次数：问题明确指出，在分区扫描开始时，子数组的数据页面均非常驻内存。扫描按顺序访问页面。由于请求分页机制，首次尝试访问一个新的、非常驻页面上的任何数据都会触发一次缺页。一旦该页面被加载到页框中，对同一页面的后续访问（总共有 `$R_{page}$` 次）将不会导致缺页，因为该页面现在是常驻的。由于扫描是顺序的，置换策略是 LRU，并且我们有足够的页框，因此在一个页面被扫描完成之前，它不会被换出。因此，在扫描过程中每遇到一个新的数据页面，就会发生恰好一次缺页。设 `$F_{page}$` 为处理一个页面相关联的缺页次数。\n    $$F_{page} = 1$$\n\n4.  PFF 的计算：我们现在可以将 PFF 计算为每页的缺页次数与每页的引用次数之比。该比率代表了稳态顺序扫描期间的平均缺页率。\n    $$PFF = \\frac{F_{page}}{R_{page}} = \\frac{1}{\\frac{p \\gamma}{b}}$$\n    简化此表达式可得出预期的缺页频率的封闭形式解析表达式。\n    $$PFF = \\frac{b}{p \\gamma}$$\n    正如所要求的，该表达式仅取决于元素大小 `$b$`、页面大小 `$p$` 和引用密度 `$\\gamma$`。",
            "answer": "$$\\boxed{\\frac{b}{p\\gamma}}$$"
        },
        {
            "introduction": "最后的这项实践将我们的重点从分析转向优化，这是系统工程中的一项核心任务。您将面对一个场景：必须在一个进程的两个不同内存区域——堆栈和堆——之间分配固定数量的内存。您的任务是确定能够最小化总缺页率的最优分配方案，并在此过程中发现一个基于平衡每个额外内存帧带来的边际收益的强大原则。",
            "id": "3667671",
            "problem": "一个进程的内存访问分为调用栈区域和堆区域。设访问栈的引用比例为 $r_{s}$，访问堆的引用比例为 $r_{h}=1-r_{s}$。缺页率 (Page-Fault Frequency, PFF) 定义为每次内存引用的缺页次数，其在一个足够长的观察窗口内测量，以使各态历经平均值与期望值一致。假设在最近最少使用 (Least Recently Used, LRU) 策略下，每个区域的单次引用未命中概率可以根据分配给该区域的页帧数量，经验地建模为一个严格递减的凸函数。具体来说，对于栈和堆，其未命中概率为\n$$m_{s}(f_{s})=\\exp(-a_{s} f_{s}), \\quad m_{h}(f_{h})=\\exp(-a_{h} f_{h}),$$\n其中，$f_{s}$ 和 $f_{h}$ 分别是分配给栈和堆的帧数，$a_{s}0$ 和 $a_{h}0$ 是捕获局部性强度的区域特定参数。该进程受固定的总帧预算 $F$ 的限制，因此 $f_{s}+f_{h}=F$，其中 $f_{s}\\ge 0$ 且 $f_{h}\\ge 0$。\n\n给定 $r_{s}=0.4$，因此 $r_{h}=0.6$，以及 $a_{s}=0.35$，$a_{h}=0.15$，和总帧预算 $F=30$。\n\n任务：\n- 仅使用缺页率 (PFF) 作为每次引用的期望缺页次数的定义和给定的未命中概率模型，推导 $PFF_{stack}(f_{s})$、$PFF_{heap}(f_{h})$ 的符号表达式，以及在约束条件 $f_{h}=F-f_{s}$ 下，仅作为 $f_{s}$ 函数的总 PFF 的符号表达式。\n- 从第一性原理出发，解释“优先考虑 PFF 较高区域”的策略如何转化为一个基于“当一个额外帧分配给任一区域时总 PFF 的边际减少量”的每帧分配决策规则。\n- 使用给定的数值参数，计算在约束 $f_{s}+f_{h}=F$ 下最小化总 PFF 的栈分配值 $f_{s}^{\\star}$。将你的答案四舍五入到三位有效数字，并以帧为单位表示。",
            "solution": "所述问题在科学上是合理的、提法得当的、客观的且内部一致的。它在操作系统资源管理的背景下，提出了一个基于程序局部性的简化但有效的经验模型的标准优化问题。所有必要的参数和定义都已提供，从而可以得到一个唯一且有意义的解。因此，该问题被认为是有效的。\n\n解决方案通过解决问题陈述中概述的三个任务来进行。\n\n首先，我们推导缺页率 (PFF) 各组成部分的符号表达式。PFF 定义为每次内存引用的期望缺页数。总 PFF 是来自栈和堆区域的贡献之和。\n\n栈对总 PFF 的贡献，记为 $PFF_{stack}$，是随机选择的内存引用指向栈“并且”导致缺页的概率。这是访问栈的引用比例 $r_{s}$ 与栈的未命中概率 $m_{s}(f_{s})$ 的乘积。\n$$PFF_{stack}(f_{s}) = r_{s} m_{s}(f_{s}) = r_{s} \\exp(-a_{s} f_{s})$$\n类似地，堆对总 PFF 的贡献，记为 $PFF_{heap}$，是访问堆的引用比例 $r_{h}$ 与堆的未命中概率 $m_{h}(f_{h})$ 的乘积。\n$$PFF_{heap}(f_{h}) = r_{h} m_{h}(f_{h}) = r_{h} \\exp(-a_{h} f_{h})$$\n该进程的总 PFF 是这两个贡献之和：\n$$PFF(f_{s}, f_{h}) = PFF_{stack}(f_{s}) + PFF_{heap}(f_{h}) = r_{s} \\exp(-a_{s} f_{s}) + r_{h} \\exp(-a_{h} f_{h})$$\n使用总帧数固定为 $F$ 的约束条件，我们有 $f_{s} + f_{h} = F$，这意味着 $f_{h} = F - f_{s}$。将此代入总 PFF 的表达式中，可得到仅作为 $f_{s}$ 函数的总 PFF：\n$$PFF(f_{s}) = r_{s} \\exp(-a_{s} f_{s}) + r_{h} \\exp(-a_{h} (F - f_{s}))$$\n\n其次，我们解释分配决策规则。一个朴素的“优先考虑 PFF 较高区域”的策略将意味着，如果 $PFF_{stack}(f_s)  PFF_{heap}(f_h)$，则将一帧分配给栈，否则分配给堆。然而，这个策略并非最优。最优的资源分配策略旨在实现整体目标函数（即总 PFF）的最大可能改进（即减少）。\n\n正确的决策规则基于将一个额外帧分配给某个区域所获得的总 PFF 的边际减少量。对于帧分配的连续近似，这可以通过总 PFF 相对于分配给每个区域的帧数的偏导数来捕获。向栈增加一帧带来的总 PFF 的边际减少量是 $-\\frac{\\partial PFF}{\\partial f_{s}}$，对于堆则是 $-\\frac{\\partial PFF}{\\partial f_{h}}$。\n\n让我们从它们各自对总 PFF 的贡献中计算这些边际减少量：\n栈的边际减少量是：\n$$R_{s}(f_{s}) = -\\frac{d}{d f_{s}} (PFF_{stack}(f_{s})) = -\\frac{d}{d f_{s}} [r_{s} \\exp(-a_{s} f_{s})] = a_{s} r_{s} \\exp(-a_{s} f_{s})$$\n堆的边际减少量是：\n$$R_{h}(f_{h}) = -\\frac{d}{d f_{h}} (PFF_{heap}(f_{h})) = -\\frac{d}{d f_{h}} [r_{h} \\exp(-a_{h} f_{h})] = a_{h} r_{h} \\exp(-a_{h} f_{h})$$\n决策规则是将下一个帧分配给边际减少量较高的区域。当边际减少量相等时，达到最优静态分配：$R_{s}(f_{s}^{\\star}) = R_{h}(f_{h}^{\\star})$。这个条件确保了没有任何帧可以通过从一个区域重新分配到另一个区域来实现总 PFF 更大的减少。\n\n第三，我们计算最小化总 PFF 的最优栈分配 $f_{s}^{\\star}$。为了找到 $PFF(f_s)$ 的最小值，我们将其关于 $f_s$ 的一阶导数设为零。\n$$PFF(f_{s}) = r_{s} \\exp(-a_{s} f_{s}) + r_{h} \\exp(-a_{h} (F - f_{s}))$$\n$$\\frac{d PFF(f_{s})}{d f_{s}} = -a_{s} r_{s} \\exp(-a_{s} f_{s}) + a_{h} r_{h} \\exp(-a_{h} (F - f_{s}))$$\n将导数设为零：\n$$-a_{s} r_{s} \\exp(-a_{s} f_{s}^{\\star}) + a_{h} r_{h} \\exp(-a_{h} (F - f_{s}^{\\star})) = 0$$\n$$a_{s} r_{s} \\exp(-a_{s} f_{s}^{\\star}) = a_{h} r_{h} \\exp(-a_{h} (F - f_{s}^{\\star}))$$\n这个方程与边际减少量相等的平衡条件是相同的。为了解出 $f_{s}^{\\star}$，我们对等式两边取自然对数：\n$$\\ln(a_{s} r_{s}) - a_{s} f_{s}^{\\star} = \\ln(a_{h} r_{h}) - a_{h} (F - f_{s}^{\\star})$$\n$$\\ln(a_{s} r_{s}) - a_{s} f_{s}^{\\star} = \\ln(a_{h} r_{h}) - a_{h} F + a_{h} f_{s}^{\\star}$$\n重新整理各项以分离出 $f_{s}^{\\star}$：\n$$a_{h} F + \\ln(a_{s} r_{s}) - \\ln(a_{h} r_{h}) = (a_{s} + a_{h}) f_{s}^{\\star}$$\n$$f_{s}^{\\star} = \\frac{a_{h} F + \\ln\\left(\\frac{a_{s} r_{s}}{a_{h} r_{h}}\\right)}{a_{s} + a_{h}}$$\n现在，我们代入给定的数值：$r_{s}=0.4$, $r_{h}=0.6$, $a_{s}=0.35$, $a_{h}=0.15$, 和 $F=30$。\n分母是 $a_{s} + a_{h} = 0.35 + 0.15 = 0.5$。\n分子项是：\n$a_{h} F = 0.15 \\times 30 = 4.5$。\n对数的参数是 $\\frac{a_{s} r_{s}}{a_{h} r_{h}} = \\frac{0.35 \\times 0.4}{0.15 \\times 0.6} = \\frac{0.14}{0.09} = \\frac{14}{9}$。\n所以，$\\ln\\left(\\frac{14}{9}\\right) \\approx 0.44183$。\n将这些值代入 $f_s^{\\star}$ 的表达式中：\n$$f_{s}^{\\star} = \\frac{4.5 + \\ln\\left(\\frac{14}{9}\\right)}{0.5} \\approx \\frac{4.5 + 0.44183}{0.5} = \\frac{4.94183}{0.5} \\approx 9.88366$$\n$PFF(f_s)$ 的二阶导数是 $a_{s}^2 r_{s} \\exp(-a_{s} f_{s}) + a_{h}^2 r_{h} \\exp(-a_{h} (F - f_{s}))$，它对所有 $f_s$ 都严格为正，这证实了该临界点是一个全局最小值。\n将结果四舍五入到三位有效数字，我们得到 $9.88$。该值在有效范围 $[0, 30]$ 内。",
            "answer": "$$\\boxed{9.88}$$"
        }
    ]
}