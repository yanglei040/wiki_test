{
    "hands_on_practices": [
        {
            "introduction": "深入理解消息队列的第一步是掌握其基本动态。通过构建一个离散事件模拟器，你将亲眼观察队列的占用率如何响应生产者和消费者的速率（分别为 $\\lambda$ 和 $\\mu$）。更重要的是，你将实现反压（backpressure）机制——一种防止系统过载的关键流控制技术，并分析其在不同负载下的行为。这项动手实践将让你对队列系统的核心动态有更深刻的理解。",
            "id": "3658645",
            "problem": "您需要设计并实现一个单消息队列系统的离散事件模拟器，该系统包含一个生产者和一个消费者，适用于分析背压行为。该系统模拟一个具有有限容量和阻塞发送背压策略的先进先出（FIFO）消息队列。生产者以每秒 $\\,\\lambda\\,$ 条消息的恒定速率生成消息，消费者以每秒 $\\,\\mu\\,$ 条消息的恒定速率处理消息。消费者在固定的延迟后启动。所有的消息到达间隔时间和服务时间都是确定性的，分别等于 $\\,1/\\lambda\\,$ 和 $\\,1/\\mu\\,$。队列的整数容量为 $\\,C\\,$，背压阈值为 $\\,B\\,$。在背压期间，生产者被阻塞，即如果队列占用率 $\\,q(t)\\,$ 大于或等于 $\\,B\\,$，生产者将停止生成消息，直到 $\\,q(t)\\,$ 严格下降到 $\\,B\\,$ 以下。当队列已满（队列占用率等于 $\\,C\\,$）且生产者未被背压阻塞时，到达的消息将被丢弃并计数，但不会进入队列。消费者的行为类似于一个工作保持（work-conserving）服务器：如果消费者已启动且队列非空，它会持续处理消息，每 $\\,1/\\mu\\,$ 秒完成一次，并在队列仍然非空的情况下立即开始下一次服务。\n\n必须使用的基本原理和定义：\n- 消息队列是一种支持入队（enqueue）和出队（dequeue）操作的抽象数据类型。占用率 $\\,q(t)\\,$ 在一次未被丢弃的到达时由 $\\,q(t)\\to q(t)+1\\,$ 演变，在一次服务完成时由 $\\,q(t)\\to q(t)-1\\,$ 演变，其中 $\\,q(t)\\in\\{0,1,\\dots,C\\}\\,$。\n- 确定性的到达间隔时间和服务时间分别为 $\\,\\Delta t_{\\text{arr}}=1/\\lambda\\,$ 和 $\\,\\Delta t_{\\text{svc}}=1/\\mu\\,$。\n- 背压策略是：当 $\\,q(t)\\ge B\\,$ 时生产者阻塞，当 $\\,q(t)  B\\,$ 时生产者解除阻塞。\n- 丢弃策略是：当 $\\,q(t)=C\\,$ 且生产者未被阻塞时，丢弃到达的消息。",
            "solution": "用户要求对一个具有有限容量和背压机制的单生产者、单消费者消息队列系统进行确定性的离散事件模拟。该问题定义明确，在排队论中有科学依据，并为存在唯一解提供了所有必要的参数和规则，包括平局决胜规则。验证结论是该问题是**有效的**。\n\n该解决方案将以一个C语言程序实现，该程序为多个测试用例模拟该系统。程序的核心是一个离散事件模拟器。系统的状态由一组变量定义：当前模拟时间 `t`、队列占用率 `q(t)`，以及表示生产者（阻塞/未阻塞）和消费者（活动/非活动、繁忙/空闲）状态的布尔标志。\n\n模拟通过将时间推进到下一个已安排的事件来进行。有三种类型的事件：\n1. **到达（Arrival）**：生产者生成一条消息。\n2. **服务完成（Service Completion）**：消费者处理完一条消息。\n3. **消费者启动（Consumer Start）**：消费者在指定的延迟后变为可操作状态。\n\n模拟循环按以下方式进行：\n1. 在时间 `t=0` 初始化系统状态，队列为空 (`q(0) = 0`)。第一个 `ARRIVAL` 事件被安排在 `t = 1/\\lambda`，`CONSUMER_START` 事件被安排在 `t = t_{\\text{delay}}`。`SERVICE_COMPLETION` 事件初始不被安排 (`t = \\infty`)。\n2. 确定下一个已安排事件的最小时间 (`t_{next}`)。\n3. 如果 `t_{next}` 超出模拟时域 `T_{\\text{end}}`，主循环终止。在终止前，会进行最后一次检查，以计入直到 `T_{\\text{end}}` 的任何持续中的背压时长。\n4. 将模拟时间 `t` 推进到 `t_{next}`。\n5. 根据指定的平局决胜优先级处理所有安排在 `t_{next}` 的事件：`SERVICE_COMPLETION`  `CONSUMER_START`  `ARRIVAL`。\n\n处理每个事件的逻辑如下：\n\n**服务完成（SERVICE_COMPLETION）事件**：队列占用率 `q(t)` 减一。如果 `q(t)` 降至背压阈值 `B` 以下，生产者被解除阻塞，记录刚刚结束的背压区间的持续时间，并安排一个新的 `ARRIVAL` 事件。此时空闲的消费者如果队列不为空，则立即开始处理下一条消息（工作保持策略），并安排一个新的 `SERVICE_COMPLETION` 事件在 `1/\\mu` 秒后发生。\n\n**消费者启动（CONSUMER_START）事件**：消费者变为活动状态。如果队列不为空，消费者立即开始处理第一条消息，并安排一个 `SERVICE_COMPLETION` 事件。\n\n**到达（ARRIVAL）事件**：如果生产者未被阻塞，则发生一次到达。如果队列已满，容量为 `C`，则消息被丢弃。否则，`q(t)` 增一。如果 `q(t)` 达到或超过背压阈值 `B`，生产者变为阻塞状态，并更新背压指标（触发时间、计数、区间开始时间）。仅当生产者未被阻塞时，下一个 `ARRIVAL` 事件才被安排在 `1/\\lambda` 秒后。\n\n在整个模拟过程中，跟踪以下指标：\n- **峰值队列占用率**：观察到的 `q(t)` 的最大值。\n- **背压指标**：首次触发的时间、总触发次数（从 `q  B` 到 `q >= B` 的转换次数），以及 `q >= B` 的总持续时间。\n- **丢弃的到达**：用于记录当队列已满 (`q=C`) 且生产者未处于背压状态时发生的到达次数的计数器。\n- **最终状态**：`q(T_{\\text{end}})` 的值和预先计算的稳定性指标 `\\mathbf{1}_{\\{\\lambda > \\mu\\}}`。\n\n实现将使用 `double` 精度表示时间，使用 `int` 表示计数器和占用率。逻辑经过精心构建，以按规定处理事件调度和平局决胜，确保为所提供的测试用例提供确定性和正确的结果。",
            "answer": "```c\n// The complete and compilable C program for the message queue simulation.\n#include"
        },
        {
            "introduction": "简单的队列按先入先出的顺序处理消息，但真实世界的网络和系统中，消息乱序是常见问题。本练习将挑战你实现一个能够处理这种复杂性的重组队列。你将利用序列号来缓存和重排乱序到达的消息，以确保它们以正确、无间隙的顺序交付给消费者，并分析其对缓冲区大小的影响。这是构建如TCP等可靠通信协议时不可或缺的核心构件。",
            "id": "3658594",
            "problem": "给定操作系统中消息重组队列的基础语义。每个入队的消息都带有一个序列号 $seq \\in \\mathbb{N}$，并且必须从一个初始期望序列号 $s_0 \\in \\mathbb{N}$ 开始，严格按照递增顺序交付给消费者。以下约定规定了在离散到达步骤（由 $t \\in \\mathbb{N}$ 索引）中的处理过程，其中当前下一个期望序列号表示为 $n_t$，包含乱序消息的缓冲区内容集合为 $S_t \\subset \\mathbb{N}$：\n- 如果到达的消息的 $seq_t  n_t$，则该消息已过时，将被丢弃。\n- 如果到达的消息的 $seq_t = n_t$，则立即交付该消息，$n_t$ 增加 1，并继续贪婪地交付：当 $n_t \\in S_t$ 时，交付 $n_t$，将其从 $S_t$ 中移除，并将 $n_t$ 增加 1。这将产生一次连续的有序重组刷新。\n- 如果到达的消息的 $seq_t  n_t$，若其尚不存在于缓冲区中，则将其存入 $S_t$（重复项将被忽略）。\n将缓冲区占用率 $B_t$ 定义为步骤 $t$ 的所有操作完成后 $S_t$ 的基数，并将有限到达序列上的峰值缓冲区占用率定义为 $$B_{\\max} = \\max_{t} B_t.$$\n\n您的任务是实现一个基于 $seq$ 的带重组功能的乱序出队，并为每个测试用例计算 $B_{\\max}$。实现必须遵守上述语义，维护一个包含唯一 $seq$ 值的有序缓冲区以高效检测连续刷新，并为每个测试用例生成有序的已交付 $seq$ 值列表。\n\n推理和算法设计的基本原则：\n- 消息队列必须强制执行一个不变性：已交付的序列号构成一个从 $s_0$ 开始的严格递增序列。\n- 为了在重排序情况下保持正确性，重复和过时的消息将被忽略。\n- 缓冲区占用率只计算存储的、严格大于当前期望值 $n_t$ 的乱序消息。\n\n测试套件：\n- 案例 1 (理想路径): $s_0 = 0$, 到达序列 $[\\,0,1,2,3,4,5,6,7,8,9\\,]$。\n- 案例 2 (最大局部重排序窗口): $s_0 = 0$, 到达序列 $[\\,9,8,7,6,5,4,3,2,1,0\\,]$。\n- 案例 3 (重复与稀疏重排序): $s_0 = 0$, 到达序列 $[\\,0,2,2,1,4,3,5\\,]$。\n- 案例 4 (间隙后刷新): $s_0 = 0$, 到达序列 $[\\,3,4,5,6,7,0,1,2\\,]$。\n- 案例 5 (处理进度推进后的过时消息和重复消息): $s_0 = 0$, 到达序列 $[\\,0,1,2,1,1,3,5,4,4,6\\,]$。\n\n为每个测试用例计算：\n- 已交付的序列列表 $L$，该列表为从 $s_0$ 开始、在到达序列允许的范围内严格递增的整数列表。\n- 该案例处理过程中的峰值缓冲区占用率 $B_{\\max}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个每个测试用例结果的列表，每个结果本身是一个双元素列表 $[\\,L, B_{\\max}\\,]$。每个 $L$ 必须打印为用方括号括起来、逗号分隔的整数列表，$B_{\\max}$ 必须为整数。总输出必须是这些逐个测试用例结果的单个方括号括起来、逗号分隔的列表，例如：$[[[0,1,2],1],[[0,1],0]]$。\n\n不适用物理单位。不适用角度和百分比。程序必须是自包含、非交互式的，并且必须忠实地实现上述语义。单行输出必须严格按照指定格式聚合结果，不得包含任何额外文本。",
            "solution": "问题陈述是有效的。它在科学上基于有关数据流处理和缓冲区管理的计算机科学原理，问题定义明确，具有清晰、确定性的规则，并以客观、形式化的语言表达。该问题是实现重组队列的经典练习，重组队列是在不可靠或会重排序的信道（例如网络中的 TCP）上处理有序数据的系统中的一个基本组件。\n\n问题的核心是处理一系列传入消息，每个消息由一个序列号 $seq$ 标识，并从给定的初始序列号 $s_0$ 开始，以严格递增的顺序将它们交付给消费者。系统必须维护其状态，该状态由下一个期望序列号 $n_t$ 和一个乱序消息缓冲区 $S_t$ 组成。\n\n让我们将状态和转换形式化。系统在任何步骤 $t$ 的状态由元组 $(n_t, S_t)$ 描述，其中 $n_t \\in \\mathbb{N}$ 是消费者期望的下一个序列号，而 $S_t \\subset \\{ k \\in \\mathbb{N} \\mid k  n_t \\}$ 是已乱序到达并保存在缓冲区中的序列号集合。缓冲区占用率为 $B_t = |S_t|$。初始状态为 $(n_0, S_{-1}) = (s_0, \\emptyset)$。\n\n对于在步骤 $t$ 到达的每个序列号为 $seq_t$ 的消息，我们根据以下规则将状态 $(n_t, S_{t-1})$ 更新为 $(n_{t+1}, S_t)$：\n\n1.  **过时消息**：如果 $seq_t  n_t$，则该消息被认为是旧的，并且很可能已经交付（或者其前驱丢失，窗口已经前移）。它被丢弃。状态不改变：$(n_{t+1}, S_t) = (n_t, S_{t-1})$。\n\n2.  **期望消息**：如果 $seq_t = n_t$，该消息就是消费者正在等待的消息。它被立即交付。这将期望序列号推进到 $n_t + 1$。此推进可能会解锁缓冲区中已存在的连续消息序列。执行一次贪婪刷新：\n    -   系统交付 $seq_t$。\n    -   设置一个临时期望号，$n'_{t} = n_t + 1$。\n    -   系统检查 $n'_{t}$ 是否存在于缓冲区 $S_{t-1}$ 中。只要在缓冲区中能找到下一个期望号，就交付它，将其从缓冲区中移除，并递增期望号。\n    -   这个过程通过一个循环来形式化：令 $S'_{t} = S_{t-1}$。当 $n'_{t} \\in S'_{t}$ 时，交付 $n'_{t}$，更新 $S'_{t} \\leftarrow S'_{t} \\setminus \\{n'_{t}\\}$，并更新 $n'_{t} \\leftarrow n'_{t} + 1$。\n    -   状态转换最终确定为：$(n_{t+1}, S_t) = (n'_{t}, S'_{t})$。\n\n3.  **乱序消息**：如果 $seq_t  n_t$，则该消息在其前驱之前到达。必须将其存储起来以备将来交付。如果它尚未存在于缓冲区中，则将其添加进去（重复的乱序消息被丢弃）。下一个期望序列号保持不变。\n    -   状态转换为：$(n_{t+1}, S_t) = (n_t, S_{t-1} \\cup \\{seq_t\\})$。\n\n缓冲区占用率 $B_t$ 是步骤 $t$ 的操作完成后 $S_t$ 的基数。峰值缓冲区占用率 $B_{\\max}$ 是在整个到达序列中观察到的 $B_t$ 的最大值。\n\n为了实现这一点，一个关键选择是缓冲区 $S_t$ 的数据结构。问题指定缓冲区应保持排序，以便高效地检测连续刷新。排序动态数组是一个合适的选择。使用排序缓冲区，检查 $n_t$ 是否存在（即 `while $n_t \\in S_t$` 条件）就变成了对数组第一个元素的简单检查。\n\n每个测试用例的算法如下：\n1.  初始化 $n_t = s_0$，$S_t = \\emptyset$，已交付列表 $L = \\emptyset$，以及 $B_{\\max} = 0$。\n2.  对于输入列表中的每个到达序列号 $seq_t$：\n    a. 应用上述三个规则来更新 $n_t$，$S_t$ 和 $L$。\n    b. 处理完到达事件和任何因此产生的贪婪刷新后，计算当前缓冲区大小 $|S_t|$。\n    c. 更新 $B_{\\max} = \\max(B_{\\max}, |S_t|)$。\n3.  处理完所有到达事件后，最终的 $L$ 和 $B_{\\max}$ 就是该测试用例的结果。\n\n使用排序数组作为缓冲区意味着以下操作：\n-   **插入**：要添加一个值 $seq_t  n_t$，需要执行搜索以找到正确的排序位置。为防止重复，如果该值已存在，则跳过插入。否则，移动元素以腾出空间，并插入新值。\n-   **刷新**：在贪婪刷新期间，通过将 $n_t$ 与排序缓冲区的第一个元素进行比较，可以高效地检查条件“$n_t \\in S_t$？”。如果它们匹配，则交付该元素，并通过将所有后续元素向左移动一个位置将其从缓冲区中移除。",
            "answer": "```c\n#include"
        },
        {
            "introduction": "当多个生产者共享一个资源时，我们如何确保公平访问，特别是当它们发送大小不同的消息时？本练习将视角从单个队列的内部机制提升到多队列系统的公平调度问题。你将实现赤字轮询（Deficit Round Robin, DRR）算法，这是一种优雅而强大的算法，能为竞争的数据流提供按比例的公平性。通过模拟DRR并对照理想模型来衡量其公平性，你将获得现代路由器和操作系统中所用高级调度技术的实践经验。",
            "id": "3658595",
            "problem": "考虑一个具有多个生产者的系统，每个生产者维护一个先进先出（FIFO）的消息队列，其元素是长度可变的字节级消息。该系统使用赤字轮询（Deficit Round Robin, DRR）调度传输，其正式定义如下。每个生产者 $i$ 被分配一个固定的赤字额度 $d_i$（单位为字节/轮）。在每一轮中，调度器以固定的循环顺序访问生产者。当访问生产者 $i$ 时，如果其队列不为空，调度器将其赤字计数器 $D_i$ 增加 $d_i$，然后从其队首尽可能多地传输消息，传输总量受 $D_i$ 的限制，并从 $D_i$ 中减去每条已传输消息的大小。如果队列为空，调度器将 $D_i \\leftarrow 0$ 并继续处理下一个。调度器重复此过程，直到所有队列都为空。\n\n公平性的基本原则是比例共享原则：对于一组权重为 $w_i$ 的积压生产者 $S$（即队列非空的生产者），一个理想的保功调度器（work-conserving scheduler）会分配服务，使得在集合 $S$ 保持不变的任何时间段内，每个生产者 $i \\in S$ 获得的服务比例为 $w_i / \\sum_{k \\in S} w_k$。在 DRR 中，权重为 $w_i = d_i$。\n\n将整个执行期间为生产者 $i$ 传输的实际字节数定义为 $B_i$。通过以下构造定义一个期望字节函数 $E_i$。按时间顺序将每个单独的消息传输事件索引为 $e = 1, 2, \\dots, E$。设事件 $e$ 的大小为 $x_e$ 字节，由某个生产者 $j_e$ 传输，并设 $S_e$ 为事件 $e$ 发生前瞬间的积压生产者集合。理想的比例分配意味着事件 $e$ 对生产者 $i$ 的期望贡献为\n$$\n\\Delta E_{i,e} = \\begin{cases}\nx_e \\cdot \\dfrac{d_i}{\\sum_{k \\in S_e} d_k},  \\text{若 } i \\in S_e, \\\\\n0,  \\text{其他情况}.\n\\end{cases}\n$$\n定义 $E_i = \\sum_{e=1}^{E} \\Delta E_{i,e}$ 以及总传输字节数 $X = \\sum_{e=1}^{E} x_e$。每个生产者的归一化公平性误差为\n$$\n\\varepsilon_i = \\begin{cases}\n\\dfrac{\\lvert B_i - E_i \\rvert}{X},  \\text{若 } X  0, \\\\\n0,  \\text{若 } X = 0,\n\\end{cases}\n$$\n单个案例的汇总度量指标为\n$$\n\\varepsilon_{\\max} = \\max_{i} \\varepsilon_i.\n$$\n\n实现带有生产者赤字额度 $d_i$ 的赤字轮询算法，通过对实际传输事件的期望进行积分来计算如上定义的 $B_i$ 和 $E_i$，并报告每个测试用例的 $\\varepsilon_{\\max}$。所有消息大小和赤字额度均以字节为单位。不涉及除字节以外的任何角度或物理单位，所有报告的值必须是无量纲的小数。您的程序必须是自包含的，不需要任何输入，并按指定格式精确输出一行结果。\n\n测试套件：\n- 案例 $1$ (正常路径，异构大小，持续积压):\n  - 生产者数量: $3$。\n  - 赤字额度: $\\{700, 500, 300\\}$。\n  - 消息:\n    - 生产者 $0$: $\\{400, 800, 700, 300\\}$。\n    - 生产者 $1$: $\\{500, 500, 1000\\}$。\n    - 生产者 $2$: $\\{300, 900, 600\\}$。\n- 案例 $2$ (边界条件，大量小消息对一个大消息，权重相等):\n  - 生产者数量: $2$。\n  - 赤字额度: $\\{500, 500\\}$。\n  - 消息:\n    - 生产者 $0$: $\\{100, 100, 100, 100, 100, 100, 100, 100, 100, 100\\}$。\n    - 生产者 $1$: $\\{1000, 100, 100, 100\\}$。\n- 案例 $3$ (边缘案例，一个空队列和一个有大消息的生产者):\n  - 生产者数量: $3$。\n  - 赤字额度: $\\{500, 300, 700\\}$。\n  - 消息:\n    - 生产者 $0$: $\\{\\}$ (空)。\n    - 生产者 $1$: $\\{2000, 2000\\}$。\n    - 生产者 $2$: $\\{100, 100, 100, 100, 100, 100, 100, 100, 100, 100\\}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个条目对应于上述顺序中一个测试用例的 $\\varepsilon_{\\max}$，表示为小数点后保留六位的小数。例如，输出应类似于 $\\left[\\varepsilon_{\\max}^{(1)}, \\varepsilon_{\\max}^{(2)}, \\varepsilon_{\\max}^{(3)}\\right]$，渲染为单行 ASCII 文本，如 $[0.012345,0.000678,0.091000]$。",
            "solution": "设计始于保功调度下的比例公平原则。其基本陈述是，当一组生产者 $S$ 出现积压时，一个理想的调度器会分配服务，使得在 $S$ 固定的任何时间段内，生产者 $i \\in S$ 能获得服务总量的 $w_i / \\sum_{k \\in S} w_k$ 比例。在赤字轮询（DRR）中，设计者旨在使用离散的轮次和每个生产者的赤字额度 $d_i$ 来近似这一原则。\n\nDRR 的算法规范：\n- 维护每个生产者的赤字计数器 $D_i$，初始值为 $0$。\n- 以循环顺序访问生产者。当访问生产者 $i$ 时，如果其队列不为空：\n  - 将 $d_i$ 加到 $D_i$ 上。\n  - 当队首消息的大小 $h_i \\le D_i$ 时，传输该消息，从 $D_i$ 中减去 $h_i$，并前移队首指针。如果下一个队首消息的大小超过 $D_i$，则停止并转向下一个生产者。\n- 如果在访问生产者 $i$ 时其队列为空，则设置 $D_i \\leftarrow 0$ 并继续。\n因为只要生产者仍在循环中，每个 $D_i$ 每轮都会增加 $d_i$，所以一旦 $D_i$ 累积到足够大，大消息最终也会得到服务，这保证了有限工作负载下的最终终止。\n\n公平性度量：\n- 设为生产者 $i$ 服务的实际字节数为 $B_i$，即从 $i$ 传输的所有消息大小的总和。\n- 为了与比例公平原则进行比较，且不假设连续时间速率，我们在离散的传输事件上对理想分配进行积分。用消息大小 $x_e$ 索引每个传输事件 $e$，并将 $S_e$ 定义为事件 $e$ 发生前瞬间队列非空的生产者集合。理想的比例分配授予生产者 $i \\in S_e$ 一份份额 $x_e \\cdot d_i / \\sum_{k \\in S_e} d_k$，如果 $i \\notin S_e$ 则授予 $0$。对所有事件求和得到 $E_i = \\sum_e \\Delta E_{i,e}$ 和总字节数 $X = \\sum_e x_e$。\n- 归一化公平性误差 $\\varepsilon_i = \\lvert B_i - E_i \\rvert / X$ 将实际服务与积分后的理想期望进行比较。报告每个测试用例的最坏情况误差 $\\varepsilon_{\\max} = \\max_i \\varepsilon_i$ 可以简明地总结偏差。\n\n基于原则的论证：\n- 比例共享原则假设权重 $w_i$ 反映了期望的相对服务量。在 DRR 下，$w_i = d_i$。当某些队列变空导致 $S_e$ 随时间变化时，理想份额会适应瞬时集合 $S_e$，而不是惩罚空闲的生产者。在包含 $S_e$ 的事件上进行积分，得到的 $E_i$ 与每个服务瞬间的基本原则相一致。\n- DRR 是保功的：在每一步中，如果任何生产者有一个队首消息的大小不超过其当前赤字，调度器就传输它。否则，赤字会逐轮累积，直到传输成为可能。因为工作负载是有限的，且每个有工作的生产者的 $d_i  0$，所以赤字机制确保了最终的传输和终止。\n\n在代码中实现的算法步骤：\n- 用数组表示每个测试用例：赤字额度 $d_i$ 和每个生产者的消息列表（大小以字节为单位）。\n- 初始化用于存储每个生产者索引、赤字 $D_i$、实际字节数 $B_i$ 和期望字节数 $E_i$ 的数组；计算总字节数 $X$。\n- 主循环持续进行，直到所有消息都已传输。在每一轮中，依次访问生产者：\n  - 如果生产者 $i$ 为空，设置 $D_i \\leftarrow 0$。\n  - 否则，将 $d_i$ 加到 $D_i$ 上，并且当队首消息大小 $h_i \\le D_i$ 时循环：\n    - 计算积压集合 $S_e$（即队列非空的生产者集合）；计算 $\\sum_{k \\in S_e} d_k$。\n    - 对于所有 $k \\in S_e$，更新 $E_k \\leftarrow E_k + x_e \\cdot d_k / \\sum_{k \\in S_e} d_k$。\n    - 更新 $B_i \\leftarrow B_i + x_e$，$D_i \\leftarrow D_i - x_e$，并前移生产者 $i$ 的队首索引。\n- 完成后，对每个生产者计算 $\\varepsilon_i = \\lvert B_i - E_i \\rvert / X$（如果 $X  0$），否则 $\\varepsilon_i = 0$，并报告 $\\varepsilon_{\\max} = \\max_i \\varepsilon_i$。\n\n测试套件覆盖范围：\n- 案例 $1$ 测试了异构的消息大小和异构的权重，在运行的大部分时间内产生了跨生产者的持续积压，这测试了在不同队首约束下的比例性。\n- 案例 $2$ 应用了相等的权重，但将许多小消息与一个大消息外加一些小消息进行对比，测试了 DRR 在粒度化和突发性工作负载之间实现公平性收敛的能力。\n- 案例 $3$ 包含一个空生产者和一个拥有大消息且权重相对较高的生产者，测试了在队列为空时赤字的正确重置以及在积压集合变化时的公平性计算。\n\n输出：\n- 程序打印列表 $\\left[\\varepsilon_{\\max}^{(1)}, \\varepsilon_{\\max}^{(2)}, \\varepsilon_{\\max}^{(3)}\\right]$ 作为单行 ASCII 文本，每个值四舍五入到小数点后六位，满足可量化答案规范和格式要求。",
            "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n#include"
        }
    ]
}