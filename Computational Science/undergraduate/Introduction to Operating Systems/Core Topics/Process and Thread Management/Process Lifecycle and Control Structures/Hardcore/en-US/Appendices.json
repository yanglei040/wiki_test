{
    "hands_on_practices": [
        {
            "introduction": "The concept of a context switch can feel abstract, but it carries a tangible performance cost. This first practice exercise grounds this idea in the demanding world of real-time systems, where meeting strict deadlines is paramount. You will derive a schedulability condition that directly links the overhead of process preemption, represented by the cost $c$ of saving and restoring the Process Control Block (PCB), to a process's ability to complete its work before a deadline $D$. This exercise demonstrates how understanding low-level OS mechanics is critical for building high-performance and reliable applications.",
            "id": "3672223",
            "problem": "A single hard real-time process $P$ is released at time $t = 0$ with a relative deadline $D$ measured from its release. The process $P$ requires $C$ units of Central Processing Unit (CPU) execution time to complete its job once it is dispatched. The operating system uses a fully preemptive scheduler, and each preemption of $P$ causes a transition from the Running state to the Ready state and later back to the Running state. Every such preemption of $P$ incurs a deterministic, constant overhead $c$ that includes saving and restoring the Process Control Block (PCB), scheduler bookkeeping, and the bounded execution of any interrupt service routine associated with the preemption. Assume $c > 0$, $D \\ge C$, there is no input/output blocking by $P$, and all state transitions and control structures behave deterministically as specified.\n\nDuring the execution window of $P$, suppose it suffers exactly $k$ preemptions due to higher-priority activities or external events, each contributing the overhead $c$ as described. Starting from the fundamental definition that a job is schedulable if and only if its worst-case response time is less than or equal to its relative deadline, and reasoning from the semantics of process states and context switching, derive the schedulability requirement in terms of $C$, $c$, $k$, and $D$. Then, treating $k$ as an integer decision variable controlled by system design (for example, through priority assignment or interrupt masking policies), determine the maximum allowable integer number of preemptions $k_{\\max}$ that still guarantees $P$ meets its deadline.\n\nExpress your final answer as a closed-form analytic expression for $k_{\\max}$ in terms of $D$, $C$, and $c$.",
            "solution": "The problem requires us to determine the schedulability condition for a single hard real-time process, $P$, and from that, to derive the maximum number of preemptions it can tolerate while still meeting its deadline. The analysis will be based on the fundamental principles of real-time scheduling and process management.\n\nFirst, let us formalize the components of the process's execution timeline. The process $P$ is released at time $t = 0$ and must complete its execution by its relative deadline $D$. The process requires a total of $C$ units of CPU time for its own computation. The system is preemptive, and during its execution, process $P$ is preempted exactly $k$ times.\n\nEach preemption incurs a deterministic overhead of $c$. This overhead accounts for the time the CPU is busy with system tasks instead of application code, such as saving the context of $P$ to its Process Control Block (PCB), executing the scheduler to select another process, and eventually restoring the context of $P$ when it is dispatched to run again. The problem statement also includes \"the bounded execution of any interrupt service routine associated with the preemption\" within this overhead $c$.\n\nThe total workload that the CPU must service to ensure the completion of process $P$ is the sum of its own computational requirement and the total overhead incurred due to preemptions.\nThe intrinsic computational workload of the process is $C$.\nWith $k$ preemptions, and each incurring an overhead of $c$, the total overhead workload is the product $k \\cdot c$.\n\nTherefore, the total effective CPU time required to complete the job of process $P$, denoted as $C_{eff}$, is:\n$$C_{eff} = C + k \\cdot c$$\n\nThe worst-case response time, $R_{wc}$, of a process is the longest possible time interval from its release to its completion. In this model, we are given that there are exactly $k$ preemption events. The provided definition of overhead $c$ subsumes all time costs associated with these preemptions. The problem does not provide a model for the execution time of other, higher-priority processes; the analysis is constrained to the terms $C$, $c$, $k$, and $D$. This implies that the interference from higher-priority activities is entirely represented by the $k$ discrete preemption events with their total cost $k \\cdot c$. Under this interpretation, the worst-case scenario is one where the CPU must execute the total workload $C_{eff}$ without any idle time. Thus, the worst-case response time is equal to this total effective workload.\n\n$$R_{wc} = C_{eff} = C + k \\cdot c$$\n\nThe problem states that a job is schedulable if and only if its worst-case response time is less than or equal to its relative deadline. For process $P$, this fundamental schedulability condition is:\n$$R_{wc} \\le D$$\n\nSubstituting our derived expression for $R_{wc}$ gives the specific schedulability requirement for process $P$:\n$$C + k \\cdot c \\le D$$\n\nThis inequality is the schedulability requirement expressed in terms of the given parameters $C$, $c$, $k$, and $D$.\n\nThe second part of the problem asks for the maximum allowable integer number of preemptions, denoted as $k_{\\max}$, that guarantees schedulability. To find this, we must solve the schedulability inequality for $k$.\n\nStarting with the inequality:\n$$C + k \\cdot c \\le D$$\n\nWe can isolate the term containing $k$ by subtracting $C$ from both sides:\n$$k \\cdot c \\le D - C$$\n\nThe problem specifies that the overhead $c$ is positive, i.e., $c > 0$. Therefore, we can divide both sides of the inequality by $c$ without changing the direction of the inequality sign:\n$$k \\le \\frac{D - C}{c}$$\n\nThis inequality defines the upper bound for the number of preemptions. Since $k$ must be an integer (as it represents a count of discrete events), the maximum allowable value for $k$, or $k_{\\max}$, is the largest integer that satisfies this condition. By definition, this is the floor of the expression on the right-hand side.\n\n$$k_{\\max} = \\left\\lfloor \\frac{D - C}{c} \\right\\rfloor$$\n\nThe givens $D \\ge C$ and $c > 0$ ensure that the argument of the floor function, $\\frac{D - C}{c}$, is non-negative, which is consistent with $k$ being a non-negative count of preemptions. This closed-form expression represents the maximum number of preemptions process $P$ can sustain while being guaranteed to meet its deadline $D$.",
            "answer": "$$\n\\boxed{\\left\\lfloor \\frac{D - C}{c} \\right\\rfloor}\n$$"
        },
        {
            "introduction": "A simple diagram of process states—like Ready, Running, and Blocked—is a good start, but the reality is more complex. This practice challenges you to act as the OS scheduler and trace a process through its entire lifecycle, including more unusual states like `STOPPED`, `ZOMBIE`, and `ORPHAN`. By applying a set of formal rules based on the POSIX model, you will explore how signals, parent-child relationships, and reaping mechanics determine a process's ultimate fate, providing insight into how to write robust programs that correctly manage system resources .",
            "id": "3672144",
            "problem": "You are to design and implement a self-contained simulation of a parent-child process interaction that is consistent with the common semantics of the Portable Operating System Interface (POSIX) signal model and process lifecycle rules. The simulation must start from first principles: the definitions of process states, the behavior of signals (including the signal named $SIGSTOP$), and the parent-child resource accounting relationship, as represented by the Process Control Block (PCB). The Process Control Block (PCB) is a logical record that holds a process's state, identifiers, and accounting information. A process has a Process Identifier (PID) and a User Identifier (UID). The parent process is the creator of the child via a fork-like operation, and is responsible for reaping the child upon termination through a wait-like action, otherwise the child can briefly enter a post-termination state that is commonly described as a zombie. When a process sends $SIGSTOP$ to itself, it transitions to the stopped state, which prevents it from being scheduled until it receives a resume signal such as $SIGCONT$ from an authorized process. In this model, authorization to send a resume signal is given to either the parent process while it is alive or any process with the same $UID$ as the target; a process with a different $UID$ cannot resume the target. If the parent exits while the child is still alive, the child becomes an orphan and is re-parented to a special system process that always reaps terminated orphans, thereby eliminating sustained zombie risk.\n\nFundamental base:\n- A process exists in one of the following states: $RUNNING$, $STOPPED$, $ZOMBIE$, or $REAPED$. For the purpose of observability in this simulation, orphaned running or stopped states are denoted $ORPHAN\\_RUNNING$ and $ORPHAN\\_STOPPED$.\n- The process lifecycle semantics are:\n  1. Child creation via a fork-like event yields a parent-child relationship and both processes are in $RUNNING$.\n  2. A child that sends $SIGSTOP$ to itself transitions from $RUNNING$ to $STOPPED$.\n  3. A $STOPPED$ child can transition back to $RUNNING$ only upon receiving a $SIGCONT$ from an authorized process. Authorization is granted to the living parent or any same-$UID$ process.\n  4. If the parent exits while the child is still alive, the child becomes orphaned and is reparented to a system process that reaps terminated children.\n  5. If a child terminates while its parent is alive and the parent does not perform a wait-like action to reap it, the child becomes $ZOMBIE$. If the parent performs a wait-like action, the child becomes $REAPED$ immediately. If the parent has already exited, the orphan is reaped by the system process, so sustained zombie risk is eliminated.\n\nYour program must implement the following logical model:\n- Start with a parent process $P$ and a child process $C$. Both begin in $RUNNING$.\n- Immediately after creation, the child $C$ sends $SIGSTOP$ to itself, transitioning $C$ from $RUNNING$ to $STOPPED$.\n- The following events are parameterized per test case, each a boolean value in $\\{0,1\\}$:\n  - $c\\_p$: whether the parent $P$ attempts to send $SIGCONT$ to $C$ while $P$ is alive.\n  - $e\\_p$: whether the parent $P$ exits before any successful resume of $C$ by $P$.\n  - $c\\_s$: whether a same-$UID$ third-party process attempts to send $SIGCONT$ to $C$.\n  - $c\\_d$: whether a different-$UID$ third-party process attempts to send $SIGCONT$ to $C$.\n  - $w\\_p$: whether the parent $P$ performs a wait-like action after $C$ terminates, provided $P$ is alive at that time.\n- A resume attempt succeeds only if issued by an authorized and alive process at the time of the attempt. If $e\\_p = 1$, then the parent $P$ cannot perform $SIGCONT$ or a wait-like action afterwards.\n\nTermination and zombie-orphan semantics:\n- If $C$ is $RUNNING$, it can eventually terminate. Upon $C$ termination:\n  - If $P$ is alive and $w\\_p = 1$, $C$ transitions to $REAPED$.\n  - If $P$ is alive and $w\\_p = 0$, $C$ transitions to $ZOMBIE$.\n  - If $P$ has exited ($e\\_p = 1$), $C$ is an orphan and will be reaped by the system process, transitioning to $REAPED$ without sustained zombie risk.\n- If $C$ remains $STOPPED$ because no authorized resume succeeded, and $P$ exits, $C$ transitions to $ORPHAN\\_STOPPED$ and cannot terminate within this model without external actions not represented by the parameters.\n\nDefine the output encoding:\n- State codes: $0 \\rightarrow RUNNING$, $1 \\rightarrow STOPPED$, $2 \\rightarrow ORPHAN\\_STOPPED$, $3 \\rightarrow ORPHAN\\_RUNNING$, $4 \\rightarrow ZOMBIE$, $5 \\rightarrow REAPED$.\n- For each test case, your program must output three values in order: the final child state code, the resume success indicator, and the zombie risk indicator. The resume success indicator is $1$ if any authorized resume succeeded, else $0$. The zombie risk indicator is $1$ if $C$ enters $ZOMBIE$ due to $P$ not performing a wait-like action while alive; otherwise $0$.\n\nTest suite:\n- Test case $1$: $(c\\_p, e\\_p, c\\_s, c\\_d, w\\_p) = (1, 0, 0, 0, 1)$.\n- Test case $2$: $(c\\_p, e\\_p, c\\_s, c\\_d, w\\_p) = (0, 1, 1, 0, 0)$.\n- Test case $3$: $(c\\_p, e\\_p, c\\_s, c\\_d, w\\_p) = (0, 1, 0, 1, 0)$.\n- Test case $4$: $(c\\_p, e\\_p, c\\_s, c\\_d, w\\_p) = (1, 0, 0, 0, 0)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must be the concatenation of the triples for the above test cases in order, namely $[state\\_1,resumed\\_1,zombie\\_1,state\\_2,resumed\\_2,zombie\\_2,state\\_3,resumed\\_3,zombie\\_3,state\\_4,resumed\\_4,zombie\\_4]$, where each $state\\_i$ is the final child state code and each $resumed\\_i$ and $zombie\\_i$ is a boolean in $\\{0,1\\}$.",
            "solution": "The problem statement has been validated and is deemed sound. It is scientifically grounded in the principles of operating system process management, is well-posed with a clear and complete set of rules, and is expressed in objective, formalizable language. There are no contradictions, ambiguities, or factual errors. A unique solution can be determined by logical application of the provided rules.\n\nThe problem requires the simulation of a child process's lifecycle based on a set of parameters governing its interaction with a parent process and other processes. The final state of the child process $C$, along with indicators for resume success and zombie risk, must be determined for four distinct test cases. The states are encoded as follows: $RUNNING \\rightarrow 0$, $STOPPED \\rightarrow 1$, $ORPHAN\\_STOPPED \\rightarrow 2$, $ORPHAN\\_RUNNING \\rightarrow 3$, $ZOMBIE \\rightarrow 4$, $REAPED \\rightarrow 5$.\n\nThe initial state of the child process $C$ is $STOPPED$ (code $1$), as it sends a $SIGSTOP$ signal to itself immediately after creation. The evolution from this state depends on whether a successful resume signal ($SIGCONT$) is received.\n\nThe core of the logic lies in a two-stage analysis: first, determining if the child process is resumed, and second, determining its final state based on the outcome of the resume attempt and the subsequent actions of the parent process $P$.\n\n**Stage 1: Resume Success Analysis**\n\nA resume attempt is successful if it originates from an authorized process. According to the problem specification, authorization is granted to:\n1. The parent process $P$, provided it is alive at the time of the signal. The parameter $e_p=1$ indicates the parent exits early, precluding it from sending signals. Thus, a parent's resume attempt ($c_p=1$) is successful only if $e_p=0$.\n2. Any third-party process with the same User Identifier ($UID$) as the child process. This is represented by the parameter $c_s=1$.\n3. An attempt from a different-$UID$ process ($c_d=1$) is never authorized.\n\nLet $R_s$ be a boolean indicator for resume success ($1$ for success, $0$ for failure). The condition for success is derived from the logical OR of the authorized attempts:\n$$R_s = (c_p \\land \\neg e_p) \\lor c_s$$\nwhere the parameters are interpreted as boolean values ($1$ is true, $0$ is false).\n\n**Stage 2: Final State Determination**\n\nThe final state of child $C$ depends on $R_s$ and the parameters governing parent liveness ($e_p$) and reaping behavior ($w_p$).\n\n*   **If Resume Fails ($R_s = 0$):**\n    The child process $C$ is never resumed and remains in a stopped state. Its final state is contingent on the parent's liveness:\n    *   If the parent remains alive ($e_p=0$), the child's state is $STOPPED$ (code $1$).\n    *   If the parent exits ($e_p=1$), the child becomes an orphan while stopped, and its state is $ORPHAN\\_STOPPED$ (code $2$). In this model, this is a terminal state.\n\n*   **If Resume Succeeds ($R_s = 1$):**\n    The child process $C$ transitions to $RUNNING$ and will eventually terminate. Its final state after termination depends on whether it is reaped and by whom.\n    *   If the parent remains alive ($e_p=0$): The child terminates while the parent is available to reap it.\n        *   If the parent performs a wait-like action ($w_p=1$), the child is properly reaped and its final state is $REAPED$ (code $5$). The zombie risk is $0$.\n        *   If the parent does not wait ($w_p=0$), the child enters a $ZOMBIE$ state (code $4$). This is the sole condition under which zombie risk exists, so the zombie risk indicator is $1$.\n    *   If the parent exits ($e_p=1$): The running child becomes an orphan. Its state is momentarily $ORPHAN\\_RUNNING$ (code $3$). Upon termination, it is automatically reaped by the designated system process. Its final state is $REAPED$ (code $5$), and there is no sustained zombie risk.\n\nWe now apply this formal logic to each test case.\n\n**Test Case 1: $(c_p, e_p, c_s, c_d, w_p) = (1, 0, 0, 0, 1)$**\n1.  **Resume Success ($R_s$):** $R_s = (1 \\land \\neg 0) \\lor 0 = 1 \\lor 0 = 1$. Resume succeeds.\n2.  **Final State:** Since $R_s=1$ and the parent is alive ($e_p=0$), the child enters $RUNNING$ and terminates. The parent performs a wait action ($w_p=1$). The child is reaped.\n    *   Final State Code: $5$ ($REAPED$)\n    *   Resume Success Indicator: $1$\n    *   Zombie Risk Indicator: $0$\n    *   Result: $(5, 1, 0)$\n\n**Test Case 2: $(c_p, e_p, c_s, c_d, w_p) = (0, 1, 1, 0, 0)$**\n1.  **Resume Success ($R_s$):** $R_s = (0 \\land \\neg 1) \\lor 1 = 0 \\lor 1 = 1$. Resume succeeds (from same-$UID$ process).\n2.  **Final State:** Since $R_s=1$ and the parent exits ($e_p=1$), the child becomes an orphan while running ($ORPHAN\\_RUNNING$). Upon termination, it is reaped by the system.\n    *   Final State Code: $5$ ($REAPED$)\n    *   Resume Success Indicator: $1$\n    *   Zombie Risk Indicator: $0$\n    *   Result: $(5, 1, 0)$\n\n**Test Case 3: $(c_p, e_p, c_s, c_d, w_p) = (0, 1, 0, 1, 0)$**\n1.  **Resume Success ($R_s$):** $R_s = (0 \\land \\neg 1) \\lor 0 = 0 \\lor 0 = 0$. Resume fails. Note that the attempt from a different-$UID$ process ($c_d=1$) is unauthorized and has no effect.\n2.  **Final State:** Since $R_s=0$ and the parent exits ($e_p=1$), the stopped child becomes an orphan.\n    *   Final State Code: $2$ ($ORPHAN\\_STOPPED$)\n    *   Resume Success Indicator: $0$\n    *   Zombie Risk Indicator: $0$\n    *   Result: $(2, 0, 0)$\n\n**Test Case 4: $(c_p, e_p, c_s, c_d, w_p) = (1, 0, 0, 0, 0)$**\n1.  **Resume Success ($R_s$):** $R_s = (1 \\land \\neg 0) \\lor 0 = 1 \\lor 0 = 1$. Resume succeeds.\n2.  **Final State:** Since $R_s=1$ and the parent is alive ($e_p=0$), the child enters $RUNNING$ and terminates. The parent does not perform a wait action ($w_p=0$). The child becomes a zombie.\n    *   Final State Code: $4$ ($ZOMBIE$)\n    *   Resume Success Indicator: $1$\n    *   Zombie Risk Indicator: $1$\n    *   Result: $(4, 1, 1)$\n\nThe concatenated list of results for the four test cases is $[5,1,0,5,1,0,2,0,0,4,1,1]$. The following C program implements this logic to generate the required output.",
            "answer": "```c\n#include stdio.h\n#include stdlib.h\n\n// State codes as defined in the problem\n#define STATE_RUNNING 0\n#define STATE_STOPPED 1\n#define STATE_ORPHAN_STOPPED 2\n#define STATE_ORPHAN_RUNNING 3\n#define STATE_ZOMBIE 4\n#define STATE_REAPED 5\n\n// A struct to hold the boolean parameters for a single test case.\n// We use int (0 or 1) as C23 standard's stdbool.h is not in the allowed list.\ntypedef struct {\n    int c_p; // Parent attempts to send SIGCONT\n    int e_p; // Parent exits early\n    int c_s; // Same-UID process attempts to send SIGCONT\n    int c_d; // Different-UID process attempts to send SIGCONT\n    int w_p; // Parent performs a wait-like action\n} TestCase;\n\nint main(void) {\n    // Define the test cases from the problem statement.\n    TestCase test_cases[] = {\n        {1, 0, 0, 0, 1}, // Test case 1\n        {0, 1, 1, 0, 0}, // Test case 2\n        {0, 1, 0, 1, 0}, // Test case 3\n        {1, 0, 0, 0, 0}  // Test case 4\n    };\n\n    // Calculate the number of test cases.\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    // Each case produces 3 integer results: state, resumed, zombie_risk\n    int results[num_cases * 3];\n\n    // Calculate the result for each test case.\n    for (int i = 0; i  num_cases; ++i) {\n        TestCase current_case = test_cases[i];\n        int final_child_state;\n        int resume_success = 0;\n        int zombie_risk = 0;\n\n        // Stage 1: Determine resume success.\n        // A resume is successful if attempted by the parent (c_p=1) while it's alive (e_p=0),\n        // or if attempted by a same-UID process (c_s=1).\n        if ((current_case.c_p  !current_case.e_p) || current_case.c_s) {\n            resume_success = 1;\n        }\n\n        // Stage 2: Determine final state based on resume success and parent actions.\n        if (resume_success) {\n            // Child is resumed and will eventually terminate.\n            if (!current_case.e_p) { // Parent is alive.\n                // Parent is responsible for reaping.\n                if (current_case.w_p) {\n                    // Parent waits, child is reaped.\n                    final_child_state = STATE_REAPED;\n                } else {\n                    // Parent does not wait, child becomes a zombie.\n                    final_child_state = STATE_ZOMBIE;\n                    zombie_risk = 1;\n                }\n            } else { // Parent has exited, child is an orphan.\n                // Running orphan is reaped by the system upon termination.\n                final_child_state = STATE_REAPED;\n            }\n        } else {\n            // Resume failed, child remains stopped.\n            if (!current_case.e_p) { // Parent is alive.\n                final_child_state = STATE_STOPPED;\n            } else { // Parent has exited.\n                // Stopped child becomes an orphan.\n                final_child_state = STATE_ORPHAN_STOPPED;\n            }\n        }\n\n        results[i * 3 + 0] = final_child_state;\n        results[i * 3 + 1] = resume_success;\n        results[i * 3 + 2] = zombie_risk;\n    }\n\n    // Print the results in the EXACT REQUIRED format before the final return statement.\n    printf(\"[\");\n    for (int i = 0; i  num_cases * 3; ++i) {\n        printf(\"%d\", results[i]);\n        if (i  num_cases * 3 - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\");\n\n    return EXIT_SUCCESS;\n}\n```"
        },
        {
            "introduction": "Armed with an understanding of process lifecycle rules and overhead costs, you are now ready to tackle a core challenge in systems programming: robustly spawning a new process. This final exercise asks you to analyze and select a correct design for a parent-child \"handshake\" that uses pipes to guarantee no zombie processes are created, even when faced with edge cases like `exec` failure. By evaluating different strategies involving `fork`, `exec`, and `wait` calls, you will learn to appreciate the subtle but critical details—such as the `FD_CLOEXEC` flag—that distinguish a fragile script from a reliable system utility .",
            "id": "3672175",
            "problem": "You are designing a robust parent–child handshake on a Portable Operating System Interface (POSIX) system to spawn a child process that will replace its image with a target program via `execve()`, and you want to guarantee that no zombie processes are ever created. A zombie process is a process that has terminated but still has an entry in the Process Control Block (PCB) because its parent has not yet collected its termination status via `wait()` or `waitpid()`. You will use only pipes and ordering of `close()`, `exec()`, and `wait()` calls, and you must consider edge cases such as `exec()` failure, early child exit, and the parent performing `exec()` soon after spawning. Assume the following well-tested facts and definitions as your fundamental base:\n\n- After a successful `fork()`, the child inherits the parent's open File Descriptors (FDs), including both ends of any pipe the parent created, and the kernel maintains reference counts for each end.\n- A pipe read returns 0 (end-of-file) only when all write ends referring to the pipe are closed across all processes. A read blocks when at least one write end remains open and no data is available.\n- `execve()` replaces the calling process's image and FDs are preserved unless they have the Close-On-Exec (FD\\_CLOEXEC) flag set, in which case they are closed atomically during `execve()`.\n- A child becomes a zombie if it terminates and its parent does not call `wait()` or `waitpid()` to reap it; if the parent itself terminates, the child is adopted by the system reaper (for example, process 1 on some systems), preventing zombies for that lineage.\n- `waitpid()` can be called after any blocking read completes; correct ordering matters to avoid races that could leave the child unreaped.\n\nYou will choose one design below that uses pipes to ensure the parent never leaves a child as a zombie, even if the parent intends to call `exec()` soon after spawning the child. Consider the following candidate handshakes, which differ in their ordering of `close()`, `exec()`, and `wait()`. In each, $P_{c2p}$ denotes a child-to-parent status pipe and $P_{p2c}$ a parent-to-child readiness pipe. For clarity, $r$ and $w$ denote the read and write ends, respectively.\n\nA. Parent creates two pipes $P_{c2p}$ and $P_{p2c}$. The parent sets FD\\_CLOEXEC on $P_{c2p}(w)$ and leaves $P_{c2p}(r)$ without FD\\_CLOEXEC. After `fork()`:\n- Child closes $P_{c2p}(r)$ and $P_{p2c}(w)$, then performs a blocking read of 1 byte from $P_{p2c}(r)$ to ensure the parent is ready to reap. Upon receiving the byte, the child attempts `execve()`. If `execve()` succeeds, FD\\_CLOEXEC closes $P_{c2p}(w)$ atomically and the child proceeds in the new image. If `execve()` fails, the child writes a small error code to $P_{c2p}(w)$ and calls `_exit()`.\n- Parent closes $P_{c2p}(w)$ and $P_{p2c}(r)$ immediately, writes 1 byte to $P_{p2c}(w)$ to release the child, then reads from $P_{c2p}(r)$. If the read returns 0, the parent infers `execve()` success and calls `waitpid()` to reap later when the child eventually terminates. If the read returns an error code, the parent calls `waitpid()` to reap immediately and handles the failure. Only after performing `waitpid()` does the parent proceed to its own `exec()` or other actions. This ordering ensures that all write ends of $P_{c2p}$ are closed in the success path (producing 0), and that the parent reaps in both success and failure paths, preventing zombies. Edge cases: if the child exits early before reading $P_{p2c}(r)$, the parent’s read of $P_{c2p}(r)$ will deliver the error code or 0, and `waitpid()` will still reap. If FD\\_CLOEXEC were not set on $P_{c2p}(w)$, the parent’s read could block forever due to the new image keeping the write end open; setting FD\\_CLOEXEC avoids this.\n\nB. Parent creates a single pipe $P_{c2p}$ but does not set FD\\_CLOEXEC on either end. After `fork()`:\n- Child closes $P_{c2p}(r)$ and attempts `execve()`. On failure, it writes an error code and exits; on success, the new image inherits $P_{c2p}(w)$ and keeps it open indefinitely.\n- Parent closes nothing and reads from $P_{c2p}(r)$. It interprets any 0 as success and nonzero bytes as failure, then immediately calls `exec()` without calling `waitpid()`.\nThis design can deadlock or mis-signal: the parent’s read may never return 0 because $P_{c2p}(w)$ remains open in the child’s new image, and the parent never calls `waitpid()`, risking a zombie if the child exits after the parent’s `exec()`.\n\nC. Parent sets the Signal (SIGCHLD) disposition to ignore and uses no pipes. After `fork()`:\n- Child attempts `execve()` and exits when done.\n- Parent immediately calls `exec()` without calling `waitpid()`, assuming SIGCHLD ignore guarantees auto-reap on all POSIX systems.\nThis relies on non-portable behavior; ignoring SIGCHLD does not universally guarantee automatic reaping across all POSIX implementations and fails to use the specified pipe-based handshake. It therefore risks zombies on systems where auto-reap is not performed.\n\nD. Parent implements a double `fork()` in the child to orphan the grandchild, uses no pipes, and never calls `waitpid()`. The intermediate child exits, causing the grandchild to be reparented to the system reaper (for example, process 1), which will reap it eventually.\nWhile double `fork()` can avoid zombies, it ignores the requirement to use pipes for a handshake and does not cover `exec()` failure signaling to the parent; additionally, it complicates resource management and lineage tracking.\n\nWhich option correctly uses pipes and ordering of `close()`, `exec()`, and `wait()` calls to ensure no zombie creation and handles the stated edge cases under the given assumptions?\n\nA. The two-pipe handshake with FD\\_CLOEXEC on $P_{c2p}(w)$, parent closing its write ends, releasing the child via $P_{p2c}$, reading status, and calling `waitpid()` before any parent `exec()`.\n\nB. The single-pipe approach without FD\\_CLOEXEC, parent not closing its write end and calling `exec()` without `waitpid()`.\n\nC. Ignoring SIGCHLD and not using pipes, relying on auto-reap.\n\nD. Double `fork()` without pipes and never calling `waitpid()`.",
            "solution": "The user-provided problem is analyzed as follows.\n\n### Step 1: Extract Givens\n- **Objective**: Design a robust parent–child handshake on a POSIX system to spawn a child, have it call `execve()`, and guarantee no zombie processes are created.\n- **Zombie Definition**: A process that has terminated but its Process Control Block (PCB) entry persists because its parent has not collected its status via `wait()` or `waitpid()`.\n- **Constraints**: Use only pipes and the ordering of `close()`, `exec()`, and `wait()` calls.\n- **Edge Cases**: Must handle `exec()` failure, early child exit, and the parent performing `exec()` soon after spawning.\n- **Fundamental Facts**:\n    1.  After `fork()`, the child inherits parent's open File Descriptors (FDs), and the kernel reference-counts each pipe end.\n    2.  A pipe read returns `0` (end-of-file) only when all write ends are closed. A read blocks if a write end is open and no data is available.\n    3.  `execve()` preserves FDs unless the `FD_CLOEXEC` (Close-On-Exec) flag is set, which closes them atomically.\n    4.  A child becomes a zombie if its live parent does not `wait()`. If the parent terminates, an adopted child is reaped by the system reaper (e.g., process `1`).\n    5.  `waitpid()` can be called after a blocking read; ordering is critical to avoid race conditions.\n- **Notation**: $P_{c2p}$ (child-to-parent pipe), $P_{p2c}$ (parent-to-child pipe), $r$ (read end), $w$ (write end).\n\n### Step 2: Validate Using Extracted Givens\nThe problem statement is critically evaluated for validity.\n\n- **Scientifically Grounded**: The problem is firmly rooted in the established principles of process management in POSIX-compliant operating systems. The descriptions of `fork()`, `execve()`, `waitpid()`, pipes, file descriptors, `FD_CLOEXEC`, and zombie processes are accurate and reflect standard systems programming concepts.\n- **Well-Posed**: The problem is well-posed. It presents a clear objective (preventing zombies during an `exec()` handshake), defines the constraints and available tools, and asks for the evaluation of specific proposed solutions. A unique correct design exists among the choices based on the provided axioms.\n- **Objective**: The language is technical, precise, and free of subjective or ambiguous terminology. The criteria for a successful solution are clearly defined and verifiable.\n- **Completeness and Consistency**: The problem provides all necessary definitions and assumptions to reason about the correct solution. There are no internal contradictions. The provided \"fundamental facts\" form a self-contained logical basis for the analysis.\n- **Relevance**: The problem is directly and fundamentally relevant to the topic of process lifecycle and control structures in an introduction to operating systems.\n\n### Step 3: Verdict and Action\nThe problem statement is **valid**. It is a standard, albeit intricate, problem in systems programming that tests the understanding of process control and inter-process communication primitives. The solution process may now proceed.\n\n### Principle-Based Derivation\n\nThe central challenge is to design a mechanism that simultaneously accomplishes two tasks under the specified constraints:\n1.  **Status Reporting**: The parent must be able to reliably determine whether the child's call to `execve()` succeeded or failed.\n2.  **Zombie Prevention**: The child process, upon termination, must be successfully reaped by its parent via `wait()` or `waitpid()` to prevent it from becoming a zombie. This must hold even if the parent process itself calls `execve()` after the handshake.\n\n**Status Reporting Mechanism**:\nA pipe from child to parent ($P_{c2p}$) is the designated tool. Failure can be signaled by the child writing an error code to the pipe before exiting. Success is more subtle, as the new process image loaded by `execve()` has no knowledge of the handshake and will not write a \"success\" code. The correct way to signal success is through an implicit action: the closing of the pipe's write end.\n\nLet the parent hold the read end $P_{c2p}(r)$ and the child hold the write end $P_{c2p}(w)$. After the `fork()`, both processes initially have both FDs. For the communication to work, the parent must close its copy of $P_{c2p}(w)$, and the child must close its copy of $P_{c2p}(r)$. Now, the parent can perform a blocking `read()` on $P_{c2p}(r)$.\n- If `execve()` fails, the child `write()`s an error code to $P_{c2p}(w)$. The parent's `read()` receives this data.\n- If `execve()` succeeds, the program must ensure $P_{c2p}(w)$ is closed. If it remains open in the newly loaded process, the parent's `read()` will block indefinitely. The `FD_CLOEXEC` flag is essential here. By setting `FD_CLOEXEC` on $P_{c2p}(w)$ before the `fork()`, a successful `execve()` in the child will atomically close this file descriptor. Since the parent already closed its copy of $P_{c2p}(w)$, this action closes the last remaining write handle, causing the parent's `read()` to unblock and return `0` (EOF), reliably signaling success.\n\n**Zombie Prevention Mechanism**:\nA child becomes a zombie if its parent is alive but fails to call `waitpid()`. The problem states the parent might call `execve()` itself. A common misconception is that this terminates the parent. It does not; it replaces the parent's process image. The parent process, with its original Process ID, continues to exist and remains the parent of the child. However, the new program loaded by `execve()` will be unaware of the child and will not have the logic to call `waitpid()`. Consequently, when the child eventually terminates, its parent (running the new program) will not reap it, and it will become a zombie.\n\nTo absolutely *guarantee* that no zombie is created, the original parent code must reap the child *before* it relinquishes control by calling `execve()`. This means that after the parent has determined the child's `execve()` status, it must call `waitpid(child\\_pid, ...)` and wait for it to complete. If the child's `execve()` was successful, this implies the parent process will block until the child's entire lifecycle is complete. This creates a synchronous spawn, which may not be desirable in all cases, but it is the only way to satisfy the strict \"guarantee no zombie\" requirement under the specified constraints.\n\n### Option-by-Option Analysis\n\n**A. The two-pipe handshake with FD\\_CLOEXEC on $P_{c2p}(w)$, parent closing its write ends, releasing the child via $P_{p2c}$, reading status, and calling `waitpid()` before any parent `exec()`.**\n\nThis option describes a meticulous and correct implementation based on the principles derived above.\n- **Pipes**: It uses two pipes. The child-to-parent pipe ($P_{c2p}$) is used for status reporting as described. The parent-to-child pipe ($P_{p2c}$) serves as a synchronization barrier, ensuring the child does not call `execve()` until the parent is fully prepared to listen for the status signal, thus preventing a race condition.\n- **`FD_CLOEXEC`**: It correctly specifies that $P_{c2p}(w)$ must have the `FD_CLOEXEC` flag set. This is the cornerstone of signaling `execve()` success via EOF on the pipe.\n- **`close()` ordering**: It correctly outlines that each process closes the pipe end it does not use.\n- **Reaping**: Crucially, it states that *after* resolving the handshake (reading `0` or an error code from $P_{c2p}(r)$), the parent calls `waitpid()`. In the case of `execve()` failure, the child has already exited, so `waitpid()` returns immediately. In the case of `execve()` success, the parent blocks until the child terminates. Only after the child is reaped does the parent proceed to its own tasks, such as calling `exec()`. This sequence correctly and completely prevents the creation of a zombie, satisfying all problem constraints.\n\nVerdict: **Correct**.\n\n**B. The single-pipe approach without FD\\_CLOEXEC, parent not closing its write end and calling `exec()` without `waitpid()`.**\n\nThis option is fundamentally flawed.\n- **No `FD_CLOEXEC`**: Without `FD_CLOEXEC`, a successful `execve()` in the child will cause the new process image to inherit the write end of the pipe ($P_{c2p}(w)$). The parent's `read()` on $P_{c2p}(r)$ will block forever, as a write handle to the pipe remains open, but no data is being written. This leads to a deadlock.\n- **No Parent `close()`**: The parent fails to close its own copy of $P_{c2p}(w)$. This is an additional, independent reason for the parent's `read()` to deadlock.\n- **No `waitpid()`**: The parent calls `exec()` without calling `waitpid()`. As explained in the derivation, this guarantees a zombie process if the child terminates while the parent is still running its new image.\n\nVerdict: **Incorrect**.\n\n**C. Ignoring SIGCHLD and not using pipes, relying on auto-reap.**\n\nThis option violates the problem's explicit constraints and is not a universally robust solution.\n- **Violates Constraints**: The problem mandates the use of \"only pipes and ordering of `close()`, `exec()`, and `wait()` calls\". This solution uses signals (`SIGCHLD`) and explicitly avoids pipes.\n- **Non-Portable**: The behavior that setting the disposition of `SIGCHLD` to `SIG_IGN` causes automatic reaping of child processes is a common extension (e.g., on Linux and BSD), but it is not specified by the POSIX standard. A robust design for a POSIX system cannot rely on this behavior.\n- **No Status Reporting**: This mechanism provides no way for the parent to know if the child's `execve()` call failed.\n\nVerdict: **Incorrect**.\n\n**D. Double `fork()` without pipes and never calling `waitpid()`.**\n\nThis option describes a valid general pattern for daemonization but fails to meet the specific requirements of this problem.\n- **Violates Constraints**: The problem requires a pipe-based handshake. This solution uses no pipes for communication between the original parent and the process that will eventually call `execve()`.\n- **No Status Reporting**: The original parent process reaps the intermediate child, which exits almost immediately. The parent has no communication channel to the grandchild (the actual worker process) and therefore cannot be notified if the grandchild's `execve()` call fails.\n\nVerdict: **Incorrect**.",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}