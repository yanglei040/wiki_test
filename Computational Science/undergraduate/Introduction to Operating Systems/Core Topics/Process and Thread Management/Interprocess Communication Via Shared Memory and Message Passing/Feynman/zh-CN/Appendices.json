{
    "hands_on_practices": [
        {
            "introduction": "高效的共享内存编程需要深入理解硬件如何处理数据。本练习将带你探究缓存行（cache line）这一内存一致性的基本单元。你将探索一种被称为“伪共享”（false sharing）的微妙性能陷阱，并推导出一个数据布局规则来避免它，从而确保你的并发程序能够高效运行。",
            "id": "3650171",
            "problem": "一个系统团队正在评估两种用于两个协作进程之间进行进程间通信的设计：通过操作系统原语进行消息传递，以及使用共享内存进行原地更新。为了减少消息传递中常见的系统调用开销，他们考虑对两个频繁更新的计数器使用共享内存。硬件是一个共享内存多处理器，采用写-失效缓存一致性协议，缓存行大小固定为 $L$ 字节。一个共享内存段被创建并映射到由操作系统选择的虚拟基地址；该映射的基地址模 $L$ 的值不能被用户空间控制，可以是 $\\{0,1,\\dots,L-1\\}$ 中的任意余数。每个计数器存储在一个大小为 $s$ 字节（其中 $1 \\leq s \\leq L$）的标量对象中，并且这两个计数器被放置在距离共享内存段起始位置的字节偏移量 $o_1$ 和 $o_2$ 处，其中 $o_2 \\geq o_1$ 并且两个计数器的地址不重叠。\n\n使用以下基本定义作为您推理的基础：\n\n- 缓存行是一致性的单位；如果两个内存位置位于同一缓存行中，不同处理器对这些位置的写入会导致伪共享 (false sharing)，即使这些位置是不同的，也会表现为一致性流量。\n- 地址 $x$ 位于缓存行索引 $\\left\\lfloor x / L \\right\\rfloor$ 中。一个连续的内存区域 $[x, x + s - 1]$ 占据其索引在集合 $\\left\\{\\left\\lfloor \\frac{y}{L} \\right\\rfloor : y \\in [x, x + s - 1]\\right\\}$ 中的所有缓存行。\n\n设 $B$ 表示映射的（未知）虚拟基地址，定义两个计数器的地址范围为 $[B + o_1, B + o_1 + s - 1]$ 和 $[B + o_2, B + o_2 + s - 1]$。目标是选择间隔 $d = o_2 - o_1$ 以最小化缓存行争用（消除伪共享），而不管 $B \\bmod L$ 的值如何。\n\n根据上述定义，并且不假设 $B$ 有任何特殊对齐方式，推导出一个关于 $L$ 和 $s$ 的最小字节间隔 $d$ 的闭式表达式，使得对于 $B \\bmod L$ 的每一个可能余数，两个计数器都不会占用任何公共缓存行。以字节为单位提供 $d$ 的最终表达式。不需要进行数值计算或四舍五入；用 $L$ 和 $s$ 的符号形式表示您的最终结果。",
            "solution": "问题要求推导共享内存中两个数据对象（计数器）之间的最小字节间隔 $d$，以保证无论内存映射的基地址对齐方式如何，它们都不会占用任何公共缓存行。此条件必须防止伪共享。\n\n设缓存行大小为 $L$ 字节。两个计数器的大小均为 $s$ 字节，其中 $1 \\le s \\le L$。共享内存段映射在虚拟基地址 $B$ 处。计数器放置在该基地址的偏移量 $o_1$ 和 $o_2$ 处。间隔为 $d = o_2 - o_1$。不失一般性，我们假设 $o_2 \\ge o_1$。\n\n第一个计数器占据连续的内存地址范围 $[B+o_1, B+o_1+s-1]$。我们将其起始地址表示为 $A_1 = B+o_1$。地址范围是 $[A_1, A_1+s-1]$。\n第二个计数器占据地址范围 $[B+o_2, B+o_2+s-1]$。其起始地址是 $A_2 = B+o_2 = B+o_1+d = A_1+d$。地址范围是 $[A_2, A_2+s-1]$。\n\n根据问题陈述，地址 $x$ 位于索引为 $\\lfloor x/L \\rfloor$ 的缓存行中。如果两个内存位置映射到相同的缓存行索引，它们就会引起争用。为了完全消除两个计数器之间的争用，第一个计数器占用的缓存行索引集合必须与第二个计数器的缓存行索引集合不相交。\n\n第一个计数器的缓存行索引集合 $C_1$ 由其范围内所有地址 $y_1$ 的索引给出：$C_1 = \\{\\lfloor y_1/L \\rfloor : y_1 \\in [A_1, A_1+s-1]\\}$。由于函数 $\\lfloor \\cdot \\rfloor$ 是非递减的，这个索引集合是一个连续的范围。最小索引是 $\\lfloor A_1/L \\rfloor$，最大索引是 $\\lfloor (A_1+s-1)/L \\rfloor$。\n\n同样，第二个计数器的缓存行索引集合 $C_2$ 是 $C_2 = \\{\\lfloor y_2/L \\rfloor : y_2 \\in [A_2, A_2+s-1]\\}$。最小索引是 $\\lfloor A_2/L \\rfloor$，最大索引是 $\\lfloor (A_2+s-1)/L \\rfloor$。\n\n由于 $o_2 \\ge o_1$，我们有 $A_2 \\ge A_1$。为了确保缓存行索引集合 $C_1$ 和 $C_2$ 不相交，$C_1$ 中的最大索引必须严格小于 $C_2$ 中的最小索引。这给出了充要条件：\n$$\n\\max(C_1)  \\min(C_2)\n$$\n$$\n\\lfloor \\frac{A_1+s-1}{L} \\rfloor  \\lfloor \\frac{A_2}{L} \\rfloor\n$$\n代入 $A_2 = A_1+d$，条件变为：\n$$\n\\lfloor \\frac{A_1+s-1}{L} \\rfloor  \\lfloor \\frac{A_1+d}{L} \\rfloor\n$$\n这个不等式必须对任何可能的基地址 $B$ 都成立。问题陈述指出，基地址模 $L$（我们表示为 $B \\pmod L$）可以是 $\\{0, 1, \\dots, L-1\\}$ 中的任意余数。第一个计数器的起始地址是 $A_1 = B+o_1$。偏移量 $o_1$ 是一个固定的选定值，而 $B$ 是可变的。$A_1$ 相对于缓存行边界的对齐方式由 $A_1 \\pmod L = (B+o_1) \\pmod L$ 给出。由于 $B \\pmod L$可以取从 $0$ 到 $L-1$ 的任何值，通过适当选择 $B$，$(B+o_1) \\pmod L$ 也可以取这些值。因此，我们必须确保该不等式对 $A_1$ 的任何可能对齐方式都成立。\n\n设 $A_1 = kL+r$，其中 $k$ 是一个表示基缓存行索引的整数，$r \\in \\{0, 1, \\dots, L-1\\}$ 是该行内的字节偏移量。将此代入不等式中：\n$$\n\\lfloor \\frac{kL+r+s-1}{L} \\rfloor  \\lfloor \\frac{kL+r+d}{L} \\rfloor\n$$\n使用对于整数 $n$ 的属性 $\\lfloor z+n \\rfloor = \\lfloor z \\rfloor + n$：\n$$\nk + \\lfloor \\frac{r+s-1}{L} \\rfloor  k + \\lfloor \\frac{r+d}{L} \\rfloor\n$$\n$$\n\\lfloor \\frac{r+s-1}{L} \\rfloor  \\lfloor \\frac{r+d}{L} \\rfloor\n$$\n这等价于要求：\n$$\n\\lfloor \\frac{r+s-1}{L} \\rfloor + 1 \\le \\lfloor \\frac{r+d}{L} \\rfloor\n$$\n这个条件必须对所有可能的余数 $r \\in \\{0, 1, \\dots, L-1\\}$ 都成立。为了找到对所有 $r$ 都满足此条件的最小 $d$，我们必须分析 $r$ 的最坏情况。我们来求解 $d$：\n$$\n\\frac{r+d}{L} \\ge \\lfloor \\frac{r+d}{L} \\rfloor \\ge \\lfloor \\frac{r+s-1}{L} \\rfloor + 1\n$$\n这意味着 $r+d \\ge L \\left( \\lfloor \\frac{r+s-1}{L} \\rfloor + 1 \\right)$，所以：\n$$\nd \\ge L \\left( \\lfloor \\frac{r+s-1}{L} \\rfloor + 1 \\right) - r\n$$\n为了找到适用于所有 $r$ 的最小 $d$，我们必须找到右侧表达式在所有可能的 $r$ 上的最大值：\n$$\nd_{min} = \\max_{r \\in \\{0, \\dots, L-1\\}} \\left( L \\left( \\lfloor \\frac{r+s-1}{L} \\rfloor + 1 \\right) - r \\right)\n$$\n我们根据 $\\lfloor (r+s-1)/L \\rfloor$ 的值，分两部分分析该表达式。\n给定 $1 \\le s \\le L$ 和 $0 \\le r \\le L-1$，项 $r+s-1$ 的范围可以从 $s-1$到 $2L-2$。所以，$\\lfloor (r+s-1)/L \\rfloor$ 可以是 $0$ 或 $1$。\n\n情况1：$r+s-1  L$，这意味着 $r  L-s+1$。\n在这种情况下，$\\lfloor (r+s-1)/L \\rfloor = 0$。表达式变为 $L(0+1) - r = L-r$。为了在范围 $[0, L-s]$ 内最大化此值，我们选择最小的 $r$，即 $r=0$。最大值为 $L-0=L$。\n\n情况2：$r+s-1 \\ge L$，这意味着 $r \\ge L-s+1$。\n在这种情况下，$\\lfloor (r+s-1)/L \\rfloor = 1$。表达式变为 $L(1+1) - r = 2L-r$。为了在范围 $[L-s+1, L-1]$ 内最大化此值，我们选择最小的 $r$，即 $r=L-s+1$。最大值为 $2L - (L-s+1) = L+s-1$。\n\n所需的总体最小间隔 $d$ 是这两种情况要求的最大值：\n$$\nd_{min} = \\max(L, L+s-1)\n$$\n由于 $s \\ge 1$，我们有 $s-1 \\ge 0$，这意味着 $L+s-1 \\ge L$。因此，这两个值的最大值是 $L+s-1$。\n\n所需的最小字节间隔为 $d = L+s-1$。这保证了对于共享内存段的任何可能对齐方式，两个计数器都将位于完全独立的缓存行中，从而消除了伪共享。计数器不重叠的条件 $d \\ge s$ 也得到满足，因为 $L \\ge 1$ 意味着 $L+s-1 \\ge s$。",
            "answer": "$$ \\boxed{L+s-1} $$"
        },
        {
            "introduction": "除了性能，正确性是至关重要的。当进程间进行无锁通信时，内存更新的顺序在不同的处理器核心看来可能有所不同，这会导致难以捉摸的错误。本问题展示了一个经典的无锁队列中的数据竞争场景，并要求你诊断其根本原因——内存重排序（memory reordering），然后应用标准的解决方案，即使用“释放-获取”（release-acquire）语义来保证程序的正确性。",
            "id": "3650245",
            "problem": "一个单生产者/单消费者（SPSC）队列被实现为共享内存中的一个环形缓冲区，该共享内存被映射到两个独立的进程中，运行在具有弱内存模型的对称多处理器上。生产者进程将一个元素写入索引为 $i$ 的槽位，然后推进共享索引 $tail$；消费者进程读取 $tail$ 来判断是否有可用数据，然后从相应的槽位读取元素。所有共享变量都位于普通的共享内存中，没有任何显式的排序原语。该平台保证缓存一致性（即，每个内存位置的程序顺序得以保留），但允许编译器和中央处理器（CPU）对不同地址的内存操作进行重排序。\n\n生产者伪代码步骤（按程序顺序）：\n- 步骤 $1$：将有效载荷值 $v$ 存储到 $buf[i]$。\n- 步骤 $2$：将新索引存储到 $tail$（例如，设置 $tail := i + 1 \\bmod N$，其中 $N$ 是环形缓冲区的容量）。\n\n消费者伪代码步骤（按程序顺序）：\n- 步骤 $1$：加载 $t := tail$。\n- 步骤 $2$：根据消费者本地的 $head$ 确定的适当 $j$ 值，加载 $r := buf[j]$。\n\n在测试中，消费者有时会观察到 $t$ 表明有新元素可用（即 $t$ 已经推进），但读取到的有效载荷 $r$ 却是生产者写入 $v$ 之前的旧值。假设 $i$ 和 $j$ 是单次元素传输中对应的匹配索引。\n\n仅使用以下基本原则：\n- 缓存一致性和每个内存位置的程序顺序的定义（即，对同一地址的写入操作，所有处理器观察到的顺序与程序顺序一致）。\n- happens-before 关系以及释放/获取同步（release/acquire synchronization）效应的定义：对共享变量的释放操作（release operation）使其线程中所有先前的写入操作 happens-before 一个匹配的、从该释放操作中读取的获取操作（acquire operation），从而防止重排序并确保这些写入对执行获取操作的线程可见。\n- 在没有显式排序约束的情况下，弱序架构可能会对不同地址的存储操作和不同地址的加载操作进行重排序。\n\n选择唯一一个同时满足以下条件的选项：\n- 提供一个具体的、架构上合理的事件序列（命名重排序类别），解释消费者如何能看到 $tail$ 已更新但看不到相应的有效载荷。\n- 提出一个最小化的修改，该修改足以在所有弱序架构上消除此错误，同时保留非阻塞的 SPSC 设计。\n\nA. 诊断：生产者的对 $tail$ 的存储操作可能在其对 $buf[i]$ 的先前存储操作之前变得可见（一种对不同地址的存储后随存储重排序），并且消费者的对 $buf[j]$ 的加载操作可能在其对 $tail$ 的加载操作之后发出并被处理，但仍然返回旧值，因为生产者对 $buf[i]$ 的存储操作尚未全局可见。一个具体的交错是：生产者按程序顺序执行步骤 $1$ 然后执行步骤 $2$，但其他核心观察到步骤 $2$ 先于步骤 $1$；消费者执行步骤 $1$（看到已推进的 $tail$）然后执行步骤 $2$（看到过时的 $buf[j]$）。最小化修复：将生产者对 $tail$ 的存储操作设为释放操作，将消费者对 $tail$ 的加载操作设为获取操作（例如，对生产者的 $tail$ 存储使用带有 `memory_order_release` 的 C11 原子操作，对消费者的 $tail$ 加载使用带有 `memory_order_acquire` 的 C11 原子操作，或者等效地，在生产者步骤 $1$ 和步骤 $2$ 之间放置一个存储-释放屏障，在消费者步骤 $1$ 和步骤 $2$ 之间放置一个加载-获取屏障）。这在有效载荷存储操作和消费者的有效载荷加载操作之间建立了一个 happens-before 边。\n\nB. 诊断：该异常仅由编译器重排序引起，而非硬件。最小化修复：在生产者步骤 $1$ 和步骤 $2$ 之间插入一个仅编译器屏障（例如，优化栅栏）；消费者端无需更改。\n\nC. 诊断：该异常仅由消费者重排序其加载操作引起（加载后随加载重排序）。最小化修复：仅在消费者读取 $tail$ 之后添加一个获取栅栏或获取语义；生产者端无需更改。\n\nD. 诊断：该异常由 $tail$ 和有效载荷槽位的伪共享引起。最小化修复：填充数据结构，使 $tail$ 和 $buf[i]$ 位于不同的缓存行上；无需内存排序更改。\n\nE. 诊断：生产者的存储操作可能被乱序观察到，但消费者端的重排序无关紧要。最小化修复：在生产者步骤 $1$ 和步骤 $2$ 之间插入一个单独的完整栅栏；消费者端无需排序更改。\n\n选择正确的选项。",
            "solution": "用户要求对问题陈述进行严格验证，然后详细推导解决方案，并对所有提供的选项进行评估。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n- **系统**：一个单生产者/单消费者（SPSC）队列，实现为共享内存中的环形缓冲区。\n- **环境**：两个独立进程，对称多处理器（SMP），弱内存模型。\n- **共享变量**：$buf$，环形缓冲区；$tail$，一个共享索引。这些变量位于“没有任何显式排序原语的普通共享内存”中。\n- **内存保证**：\n    - 保证缓存一致性。\n    - 保留每个内存位置的程序顺序（对同一地址的写入按程序顺序被观察到）。\n    - 允许编译器和中央处理器（CPU）对不同地址的内存操作进行重排序。\n- **生产者逻辑（程序顺序）**：\n    1. 将有效载荷 $v$ 存储到 $buf[i]$。\n    2. 将新索引存储到 $tail$（例如，$tail := i + 1 \\bmod N$）。\n- **消费者逻辑（程序顺序）**：\n    1. 加载 $t := tail$。\n    2. 加载 $r := buf[j]$（其中 $j$ 由消费者的本地 $head$ 索引派生）。\n- **观察到的异常**：消费者读取到已推进的 $t$ 值，但从 $buf[j]$ 读取到旧的、过时的有效载荷 $r$ 值，其中索引 $i$ 和 $j$ 对应于同一次元素传输。\n- **基本原则**：解决方案必须基于缓存一致性、带释放/获取语义的 happens-before 关系以及弱序架构属性的定义。\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学依据**：该问题是并发编程和系统设计中的一个经典且基础的场景。所描述的概念——弱内存模型、编译器和CPU的内存重排序、缓存一致性以及对显式内存排序原语（栅栏/屏障）的需求——是现代计算机体系结构的核心原则。观察到的异常是在朴素的无锁实现中会发生的、有据可查的数据竞争。\n- **定义明确**：问题定义清晰。它指定了算法、硬件/编译器环境、观察到的失败模式以及用于分析的理论原则。问题要求给出具体的诊断和最小化的、充分的修复方案，这是该领域问题的标准格式。\n- **客观性**：问题陈述使用了精确的技术语言。没有主观或模棱两可的术语。“伪代码步骤”为内存操作的程序顺序提供了清晰、形式化的描述。\n\n**步骤 3：结论与行动**\n问题陈述是有效的。它在科学上是合理的、定义明确的且客观的。它代表了操作系统和并发编程领域中一个真实而重要的挑战。可以继续进行解决方案的推导。\n\n### 解决方案推导\n\n核心问题源于“弱内存模型”，该模型允许对不同地址的内存操作进行重排序。生产者向两个不同的内存位置写入：缓冲区中的一个槽位 $buf[i]$ 和共享索引 $tail$。消费者从这两个相同的位置读取（使用匹配的索引 $j$）。\n\n生产者的程序顺序是：\n$1$. `store v, buf[i]`\n$2$. `store (i+1 mod N), tail`\n\n消费者的程序顺序是：\n$1$. `load t, tail`\n$2$. `load r, buf[j]`\n\n当消费者读取到 $tail$ 的新值但读取到 $buf[j]$ 的旧值时，异常发生。这意味着，从消费者的角度看，生产者第二次存储的效果已经可见，但第一次存储的效果尚未可见。在弱序架构上，内存系统被允许在对 $buf[i]$ 的写入变得可见之前，使对 $tail$ 的写入全局可见，即使生产者的CPU是按程序顺序执行它们的。这种现象通常被称为存储-存储重排序（Store-Store reordering）。生产者核心可能将其本地存储缓冲区中的两个值都写入，但内存子系统可能会在提交对 $buf[i]$ 的写入之前，先将对 $tail$ 的写入提交到共享缓存/内存。\n\n为了防止这种情况，必须强制执行特定的顺序。必须保证对数据（$buf[i]$）的写入在对指示数据已就绪的“标志”变量（$tail$）的写入*之前*对所有其他处理器可见。这创建了一个同步点。\n\n通过释放/获取语义实现的 happens-before 关系这一基本原则直接解决了这个问题。\n- **释放操作（release operation）** 确保在该线程的程序顺序中，所有先于释放操作的内存写入在释放操作本身之前完成并对其他线程可见。\n- **获取操作（acquire operation）** 确保如果它读取了来自释放操作的值，那么所有 happens-before 该释放操作的内存写入现在对当前线程可见。它还防止当前线程中后续的内存读取被重排序到获取操作之前。\n\n正确且最小化的修复方法是将这些语义应用于同步变量 $tail$。\n\n1.  **生产者**：对 $tail$ 的存储必须是**释放存储（release store）**。这使得对 $buf[i]$ 的先前存储 happens-before 对 $tail$ 的存储。实际上，它“发布”了数据写入。\n    - `store v, buf[i]`\n    - `store_release (i+1 mod N), tail`\n\n2.  **消费者**：从 $tail$ 的加载必须是**获取加载（acquire load）**。这确保如果消费者看到更新后的 $tail$（从而与生产者的释放操作同步），那么它也保证能看到更新后的 $buf[i]$。它还防止了从 $buf[j]$ 的加载被重排序到从 $tail$ 的加载之前发生。\n    - `load_acquire t, tail`\n    - `load r, buf[j]`\n\n这种释放-获取配对在生产者的对 $buf[i]$ 的写入和消费者的对 $buf[j]$ 的读取之间建立了一个 happens-before 边，从而正确地解决了数据竞争。这是最小化的修复，因为双方都必须参与以建立同步；在所有通用的弱内存模型上，单方面的修复是不够的。\n\n### 逐项分析\n\n**A. 诊断：生产者的对 $tail$ 的存储操作可能在其对 $buf[i]$ 的先前存储操作之前变得可见（一种对不同地址的存储后随存储重排序）... 最小化修复：将生产者对 $tail$ 的存储操作设为释放操作，将消费者对 $tail$ 的加载操作设为获取操作...**\n- **分析**：此选项提供了精确而完整的诊断。它正确地指出了从内存系统的角度看，生产者存储操作的重排序（存储-存储重排序）是根本原因。所提出的修复方案，即在生产者上使用释放存储，在消费者上使用获取加载，是解决此问题的规范、正确且最小化的解决方案。它如上述推导中所述，建立了必要的 happens-before 关系。提及 C11 原子操作是实现此方案的正确且具体的例子。\n- **结论**：**正确**。\n\n**B. 诊断：该异常仅由编译器重排序引起，而非硬件。最小化修复：在生产者步骤 $1$ 和步骤 $2$ 之间插入一个仅编译器屏障...**\n- **分析**：此诊断不正确。问题明确指出，弱内存模型上的CPU也可以重排序操作。仅编译器的屏障（优化栅栏）不会生成约束硬件重排序的CPU指令。因此，即使采用此修复，错误仍将持续存在。该诊断错误地限制了重排序的来源。\n- **结论**：**不正确**。\n\n**C. 诊断：该异常仅由消费者重排序其加载操作引起... 最小化修复：仅在消费者读取 $tail$ 之后添加一个获取栅栏或获取语义...**\n- **分析**：该诊断不完整，因此作为唯一解释是不正确的。虽然消费者端的加载-加载重排序在某些架构上可能是一个促成因素，但主要问题是生产者的写入缺乏保证的可见性顺序。所提出的修复是不充分的。消费者端的获取操作必须与生产者端的释放操作配对，才能有保证的同步效果。没有生产者的释放，获取操作就没有任何东西可以同步，也无法保证生产者的数据写入是可见的。\n- **结论**：**不正确**。\n\n**D. 诊断：该异常由伪共享引起... 最小化修复：填充数据结构...**\n- **分析**：此诊断不正确。伪共享是由多个CPU在写入不同变量时竞争同一缓存行而导致的性能问题。它不会导致问题中描述的重排序可见性的正确性问题。该异常是关于内存更新可见的*顺序*，而不是缓存行争用。修复方案——填充——解决了伪共享问题，但没有执行任何内存排序。\n- **结论**：**不正确**。\n\n**E. 诊断：生产者的存储操作可能被乱序观察到，但消费者端的重排序无关紧要。最小化修复：在生产者步骤 $1$ 和步骤 $2$ 之间插入一个单独的完整栅栏...**\n- **分析**：该诊断不完整，因为在某些弱架构（例如 ARM）上，消费者端的重排序可能是相关的。所提出的修复方案既不是最小化的，也不充分。它不是最小化的，因为完整栅栏是比所需的释放语义更强（也更昂贵）的屏障。它是不充分的，因为生产者端的栅栏不能阻止消费者的CPU重排序其自身的独立加载。一个可移植的解决方案在消费者端也需要一个屏障或获取加载。\n- **结论**：**不正确**。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "设计可扩展的并发系统通常需要在相互竞争的因素之间寻求平衡。单个全局锁会成为性能瓶颈，而无锁编程又相当复杂，分区锁（partitioned locking）则提供了一个实用的折中方案。本练习将引导你对一个常见的性能权衡进行建模：使用更多锁来减少争用，但这会增加管理这些锁的开销。通过找到最佳平衡点，你将学到高性能系统设计的一个核心原则。",
            "id": "3650193",
            "problem": "一个多核程序使用共享内存区域来协调 $n$ 个线程的工作。为避免单个全局锁引起的高度竞争，该区域可以被分割成 $s$ 个大小相等的分区，每个分区都由其自己的锁保护。每个操作都以均匀随机的方式映射到恰好一个分区（例如，通过将一个键哈希到一个分区索引），获取该分区的锁，执行一个常数时间的临界更新，然后释放锁。假设在稳定的工作负载下，以下经过经验测量和理论推导的事实成立：\n\n- 使用单个锁（即 $s=1$）时，每个操作纯粹由于等待锁（除了常数时间的临界工作和其他无关成本外）而产生的预期额外时间是 $\\gamma$（时间单位）。这个 $\\gamma$ 捕捉了当前工作负载下到达率、服务时间和调度器行为的综合效应。\n- 当共享区域被分割成 $s$ 个独立的、等概率的分区，并且对分区的映射在各个操作之间是均匀且独立时，每个操作由竞争引起的等待时间与 $s$ 成反比，因为竞争被平均分配到 $s$ 个独立的锁上。\n- 更多锁的存在会因更大的锁数组和缓存效应而产生每个操作的锁管理开销。这个开销随分区数量线性增长，测得的边际成本为每个分区每个操作 $h$（时间单位）。因此，将 $s$ 增加 1 会使每个操作的预期锁管理开销增加 $h$。\n\n仅从上述事实和独立预期成本的标准可加性出发，将每个操作在同步上花费的预期时间（等待时间加锁管理开销）建模为 $s$、$\\gamma$ 和 $h$ 的函数。将 $s$ 视为一个正实数变量，并忽略任何不依赖于 $s$ 的常数项。推导出使该预期同步时间最小化的 $s$ 值。\n\n给出你的最终答案，形式为一个以 $\\gamma$ 和 $h$ 表示的单个闭式解析表达式。不需要四舍五入。$s$ 是无量纲的；在最终表达式中不要包含单位。",
            "solution": "该问题要求我们将每个操作的预期同步时间建模为分区数 $s$ 的函数，然后找到使该时间最小化的 $s$ 值。设 $T(s)$ 表示每个操作的总预期同步时间。问题指出，该时间由两部分组成：一个由竞争引起的等待时间，我们将其表示为 $W(s)$，以及一个锁管理开銷，表示为 $O(s)$。\n\n总同步时间是这两部分之和：\n$$T(s) = W(s) + O(s)$$\n\n首先，我们必须确定 $W(s)$ 的函数形式。问题指出，“每个操作由竞争引起的等待时间与 $s$ 成反比”。这种关系可以用数学方式表示为 $W(s) = \\frac{k}{s}$，其中 $k$ 是一个比例常数。我们还得到了条件：“使用单个锁（即 $s=1$）时，每个操作纯粹由于等待锁……而产生的预期额外时间是 $\\gamma$”。这使我们能够确定常数 $k$。在我们的 $W(s)$ 模型中设置 $s=1$，我们得到 $W(1) = \\frac{k}{1} = k$。因为我们已知 $W(1) = \\gamma$，所以可得 $k = \\gamma$。因此，由竞争引起的等待时间由下式给出：\n$$W(s) = \\frac{\\gamma}{s}$$\n\n接下来，我们确定 $O(s)$ 的函数形式。问题指出，“每个操作的锁管理开销……随分区数量线性增长，测得的边际成本为每个分区每个操作 $h$……”。边际成本为 $h$ 的线性增长意味着开销中依赖于 $s$ 的部分由函数 $O(s) = h \\cdot s$ 给出。“忽略任何不依赖于 $s$ 的常数项”的指令验证了这个模型，因为我们只关心随 $s$ 变化的项来找到 $s$ 的最优值。因此，我们有：\n$$O(s) = h \\cdot s$$\n\n结合这两个组成部分，我们得到总预期同步时间作为 $s$ 的函数：\n$$T(s) = \\frac{\\gamma}{s} + h \\cdot s$$\n\n为了找到使 $T(s)$ 最小化的 $s$ 值，我们可以使用微积分，按照规定将 $s$ 视为一个正实数变量。我们计算 $T(s)$ 关于 $s$ 的一阶导数，并将其设为零以找到临界点。\n\n$T(s)$ 的导数是：\n$$\\frac{dT}{ds} = \\frac{d}{ds} \\left( \\frac{\\gamma}{s} + h \\cdot s \\right) = \\frac{d}{ds}(\\gamma s^{-1}) + \\frac{d}{ds}(hs)$$\n$$\\frac{dT}{ds} = -\\gamma s^{-2} + h = -\\frac{\\gamma}{s^2} + h$$\n\n将导数设为零，得到最小值的条件：\n$$-\\frac{\\gamma}{s^2} + h = 0$$\n$$h = \\frac{\\gamma}{s^2}$$\n\n我们现在可以解出 $s$。因为 $s$ 必须为正（它代表分区数），我们可以如下重新排列方程：\n$$s^2 = \\frac{\\gamma}{h}$$\n取正平方根得到 $s$ 的最优值：\n$$s = \\sqrt{\\frac{\\gamma}{h}}$$\n参数 $\\gamma$ 和 $h$ 是时间成本，所以它们是正实数。它们的比率是一个正的无量綱量，所以它的平方根是一个定义良好的正实数。\n\n为了验证这个临界点对应一个最小值，我们检查 $T(s)$ 的二阶导数：\n$$\\frac{d^2T}{ds^2} = \\frac{d}{ds} \\left( -\\frac{\\gamma}{s^2} + h \\right) = \\frac{d}{ds}(-\\gamma s^{-2})$$\n$$\\frac{d^2T}{ds^2} = -(-2)\\gamma s^{-3} = \\frac{2\\gamma}{s^3}$$\n\n考虑到 $\\gamma > 0$（一个等待时间）并且我们考虑的是 $s > 0$（分区数），二阶导数 $\\frac{d^2T}{ds^2}$ 对于所有在关注域内的 $s$ 都是严格为正的。正的二阶导数表明函数 $T(s)$ 在 $s > 0$ 上是严格凸的，这证实了我们找到的 $s$ 值对应于一个唯一的全局最小值。",
            "answer": "$$\\boxed{\\sqrt{\\frac{\\gamma}{h}}}$$"
        }
    ]
}