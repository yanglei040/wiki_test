{
    "hands_on_practices": [
        {
            "introduction": "Effective file protection begins before we even consider file permissions themselves; it starts with securing the boundaries between processes. This exercise explores a classic and critical security vulnerability in Unix-like systems: the leaky file descriptor. By analyzing a scenario where a privileged process spawns an unprivileged one, you will learn why managing file descriptors across an `execve` call is crucial and how a seemingly minor oversight can lead to a complete security bypass . This practice will solidify your understanding of process lifecycle semantics and the importance of the `close-on-exec` flag as a fundamental protection mechanism.",
            "id": "3642426",
            "problem": "A privileged file-sharing daemon on a Unix-like operating system is implemented as follows. At startup, it opens a sensitive resource (for example, a password database file or a management socket) and retains the associated File Descriptor (FD). The daemon later forks and invokes the executable loading system call `execve` to start a helper process that runs user-supplied plug-ins. The daemon intends to limit the helper’s access by switching to an unprivileged user identifier (UID) $1000$ before executing the helper. However, the daemon did not set the `close-on-exec` flag on its sensitive FDs at open time and did not subsequently set the flag using the file control system call `fcntl`. Assume the operating system semantics conform to the Portable Operating System Interface (POSIX), including the following definitions:\n- A FD refers to an open file description maintained by the kernel. Permission checks occur when opening a pathname; once a FD is obtained, operations on that FD do not recheck the original pathname permissions.\n- On `execve`, FDs without the `close-on-exec` flag remain open in the new program image.\n- Processes can enumerate their FDs via the process file system (for example, paths under /proc/self/fd) and can perform I/O on inherited FDs if their integer numbers are known.\n\nConsider that the daemon opens a sensitive file at FD $3$ and a privileged Unix domain socket at FD $4$, then forks and execs the helper that runs untrusted plug-in code.\n\nWhich option(s) both describe a feasible exploit chain that leverages the omission of the `close-on-exec` flag to gain unauthorized access and articulate effective mitigation step(s) grounded in operating system FD semantics?\n\nA. An unprivileged helper process inherits FD $3$ to a sensitive file because the `close-on-exec` flag was not set. The plug-in enumerates /proc/self/fd, discovers that FD $3$ points to a privileged file (for example, a password database), and reads its contents, bypassing pathname-based permission checks. Effective mitigations include setting the `close-on-exec` flag at open time (for example, using `O_CLOEXEC` or `fcntl` with `FD_CLOEXEC`), adopting “close-on-exec by default” APIs (for example, `pipe2` and `dup3` variants that support close-on-exec), and performing a pre-exec close pass (for example, `closefrom`) or using spawn routines that explicitly close or whitelist FDs.\n\nB. The helper process cannot inherit any FDs across `execve` because `execve` always clears all FDs regardless of flags. Therefore, there is no exploit chain, and no mitigation is required beyond standard privilege dropping (for example, `setuid` to UID $1000$).\n\nC. Dropping privileges to UID $1000$ ensures that the helper cannot read from an inherited FD because the kernel rechecks pathname permissions on each read operation. Thus, even if FD $3$ is inherited, subsequent reads are denied. The correct mitigation is simply to call `setuid` before `execve`.\n\nD. The helper process inherits FD $4$ to a privileged Unix domain socket because the `close-on-exec` flag was not set. The plug-in issues administrative commands over the socket, leveraging the already-authorized connection to control the daemon or elevate privileges indirectly. Effective mitigations include marking all sensitive sockets and files with the `close-on-exec` flag on creation, ensuring only intended FDs are inherited via explicit whitelist mechanisms (for example, `posix_spawn` file actions), and conducting an audit to close unexpected FDs before `execve`.\n\nE. Rely on Secure Computing Berkeley Packet Filter (`seccomp-BPF`) sandboxing alone to block `read` and `write` system calls globally in the helper; this fully prevents exploitation and obviates the need to manage FD inheritance or `close-on-exec` flags even for required helper functionality.\n\nSelect all that apply.",
            "solution": "The problem statement describes a scenario involving a privileged daemon on a Unix-like operating system that spawns a less-privileged helper process. The core of the problem lies in the management of file descriptors (FDs) across a `fork` and `execve` sequence.\n\nFirst, I will validate the problem statement.\n\n**Step 1: Extract Givens**\n- A privileged daemon runs on a POSIX-compliant, Unix-like OS.\n- At startup, the daemon opens a sensitive file, obtaining file descriptor (FD) `3`.\n- The daemon also opens a privileged Unix domain socket, obtaining FD `4`.\n- The `close-on-exec` flag is not set on these FDs.\n- The daemon `fork`s a child process.\n- The child process switches its user identifier (UID) to the unprivileged UID $1000$.\n- The child process then calls `execve` to run a helper program containing untrusted plug-in code.\n- POSIX Semantics Defined:\n    1. An FD refers to a kernel-maintained open file description. Permissions are checked at `open` time against the file's pathname, not on subsequent I/O operations on the FD.\n    2. `execve` preserves FDs that do not have the `close-on-exec` flag set.\n    3. A process can enumerate its FDs via `/proc/self/fd` and use them if it knows their integer values.\n\n**Step 2: Validate Using Extracted Givens**\n- **Scientifically Grounded**: The problem is based on well-established and accurately described principles of POSIX/Unix operating systems, including process creation (`fork`, `execve`), file descriptors, privilege separation (`setuid`), and the `close-on-exec` flag. The scenario is a canonical example of a real-world security vulnerability class (FD leaking).\n- **Well-Posed**: The problem is clearly stated, with all necessary information to deduce the behavior of the system and evaluate the consequences. It asks for a feasible exploit chain and effective mitigations, both of which can be determined from the provided premises.\n- **Objective**: The language is technical, precise, and free of ambiguity or subjective claims.\n\nThe problem statement is internally consistent, scientifically sound, and well-posed. No flaws are identified.\n\n**Step 3: Verdict and Action**\nThe problem is valid. I will proceed with the derivation and analysis.\n\n**Derivation of System Behavior and Vulnerability**\n\nThe sequence of events is `open` - `fork` - `setuid` - `execve`.\n1.  The privileged daemon opens the sensitive file and socket, successfully passing the permission checks and obtaining FDs `3` and `4`. These FDs refer to open file descriptions in the kernel which grant read/write access.\n2.  The daemon calls `fork()`. The child process inherits a copy of the parent's file descriptor table. The child's FDs `3` and `4` point to the exact same open file descriptions as the parent's.\n3.  The child process calls `setuid(1000)`. This changes the process's effective UID, reducing its privileges. However, this does not affect the capabilities of already-open file descriptors.\n4.  The child process calls `execve()` to load the helper program. As per the problem description, FDs without the `close-on-exec` flag remain open. Since this flag was not set on FDs `3` and `4`, the helper program starts execution with these FDs still open and valid.\n5.  The helper program, now running with UID $1000$ and executing untrusted code, has access to FDs `3` and `4`. It can perform I/O operations on them (e.g., `read()`, `write()`, `send()`). The kernel, upon receiving these system calls, acts on the open file description. It does not re-verify the process's UID ($1000$) against the original file's path permissions, as that check was passed at `open` time.\n\nThis constitutes a serious vulnerability. The untrusted helper process can read the sensitive file and interact with the privileged socket, effectively bypassing the system's security controls.\n\n**Option-by-Option Analysis**\n\n**A. An unprivileged helper process inherits FD $3$ to a sensitive file because the close-on-exec flag was not set. The plug-in enumerates /proc/self/fd, discovers that FD $3$ points to a privileged file (for example, a password database), and reads its contents, bypassing pathname-based permission checks. Effective mitigations include setting the close-on-exec flag at open time (for example, using O_CLOEXEC or fcntl with FD_CLOEXEC), adopting “close-on-exec by default” APIs (for example, pipe2 and dup3 variants that support close-on-exec), and performing a pre-exec close pass (for example, closefrom) or using spawn routines that explicitly close or whitelist FDs.**\n\n- **Analysis**: The described exploit chain is exactly correct, following the logic derived above for the sensitive file on FD `3`. The untrusted code can discover and use the leaked FD. The list of mitigations is comprehensive and accurate. Setting the `close-on-exec` flag is the most direct solution, either atomically at creation (e.g., `open()` with `O_CLOEXEC`) or afterward (e.g., `fcntl()`). Other methods, such as closing a range of FDs or using modern, safer process-spawning APIs like `posix_spawn()` with file actions, are also valid and recommended practices.\n- **Verdict**: Correct.\n\n**B. The helper process cannot inherit any FDs across execve because execve always clears all FDs regardless of flags. Therefore, there is no exploit chain, and no mitigation is required beyond standard privilege dropping (for example, setuid to UID $1000$).**\n\n- **Analysis**: This statement is factually incorrect. It fundamentally misrepresents the behavior of `execve` as defined by POSIX and described in the problem statement. `execve` only closes FDs that are explicitly marked with the `close-on-exec` flag.\n- **Verdict**: Incorrect.\n\n**C. Dropping privileges to UID $1000$ ensures that the helper cannot read from an inherited FD because the kernel rechecks pathname permissions on each read operation. Thus, even if FD $3$ is inherited, subsequent reads are denied. The correct mitigation is simply to call setuid before execve.**\n\n- **Analysis**: This statement is factually incorrect. It contradicts a core principle of Unix file access, which is correctly stated in the problem: permission checks are performed at `open()` time, not on every `read()` or `write()` on the resulting FD. An open FD is a capability, and its permissions are not affected by a subsequent `setuid()` call by the process holding the FD. Privilege dropping via `setuid()` is necessary but not sufficient to prevent this exploit.\n- **Verdict**: Incorrect.\n\n**D. The helper process inherits FD $4$ to a privileged Unix domain socket because the close-on-exec flag was not set. The plug-in issues administrative commands over the socket, leveraging the already-authorized connection to control the daemon or elevate privileges indirectly. Effective mitigations include marking all sensitive sockets and files with the close-on-exec flag on creation, ensuring only intended FDs are inherited via explicit whitelist mechanisms (for example, posix_spawn file actions), and conducting an audit to close unexpected FDs before execve.**\n\n- **Analysis**: This option correctly describes the same vulnerability pattern but applies it to the Unix domain socket on FD `4`. An inherited socket FD is a powerful capability, as the connection is typically considered trusted by the peer. The untrusted code can abuse this trust. The proposed mitigations are identical in principle to those in option A and are equally correct and effective for sockets (e.g., using `SOCK_CLOEXEC` with the `socket()` or `accept4()` system calls).\n- **Verdict**: Correct.\n\n**E. Rely on Secure Computing Berkeley Packet Filter (seccomp-BPF) sandboxing alone to block read and write system calls globally in the helper; this fully prevents exploitation and obviates the need to manage FD inheritance or close-on-exec flags even for required helper functionality.**\n\n- **Analysis**: This proposed solution is flawed. First, blocking `read` and `write` system calls globally is an impractical, overly-broad measure that would likely render the helper process non-functional. Most processes need some form of I/O to be useful. Second, while `seccomp-BPF` is a powerful defense-in-depth tool, framing it as a replacement that \"obviates the need\" to fix the underlying FD leak is incorrect security engineering. The primary control should be to not leak capabilities in the first place. Relying solely on `seccomp-BPF` creates a fragile defense and does not address the root cause.\n- **Verdict**: Incorrect.",
            "answer": "$$\\boxed{AD}$$"
        },
        {
            "introduction": "While securing process boundaries is vital, the core of file protection lies in defining who can do what to which files. Modern systems require sophisticated rules that go beyond simple owner-group-other permissions, especially in collaborative environments with nested teams and projects. This practice challenges you to implement the logic for a hierarchical Access Control List (ACL) system, forcing you to grapple with concepts like permission inheritance, group memberships, and the explicit precedence of `DENY` rules . By building this algorithm, you will gain hands-on experience with the engine that powers access control in many enterprise-grade file systems.",
            "id": "3642362",
            "problem": "You are to formalize and implement an algorithm for effective permission computation in a hierarchical project tree with nested group membership and inheritance exceptions. The model is specified using the following foundational definitions and facts from access control in operating systems.\n\nDefinitions:\n- Let $U$ be the set of users, $G$ be the set of groups, and $S = U \\cup G$ be the set of principals.\n- Let $P$ be the set of projects (nodes) organized as a rooted tree with parent relation $\\pi: P \\setminus \\{\\text{root}\\} \\to P$. For $p \\in P$, the unique path from the root to $p$ is denoted $\\text{path}(p) = \\langle a_0, a_1, \\dots, a_k \\rangle$ with $a_0 = \\text{root}$ and $a_k = p$.\n- Each node $a \\in P$ has a protection flag $b(a) \\in \\{\\text{false}, \\text{true}\\}$. If $b(a)=\\text{true}$, we say $a$ is protected and breaks inheritance from its ancestors.\n- A group membership relation $M \\subseteq (U \\cup G) \\times G$ is given. Its transitive closure determines derived memberships. For a user $u \\in U$, the set $C(u) \\subseteq G$ of all groups to which $u$ belongs is the least fixed point satisfying:\n  - If $(u, g) \\in M$ then $g \\in C(u)$.\n  - If $g \\in C(u)$ and $(g, h) \\in M$ then $h \\in C(u)$.\n- Each node $a \\in P$ contains zero or more Access Control Entries (ACEs). An ACE is a tuple $(t, s, Q, \\iota)$ where $t \\in \\{\\text{ALLOW}, \\text{DENY}\\}$ is the type, $s \\in S$ is the subject, $Q \\subseteq \\{r,w,x\\}$ is the finite set of permissions it mentions, and $\\iota \\in \\{\\text{false}, \\text{true}\\}$ is the inheritable flag indicating whether the ACE propagates to descendants.\n- Default-deny semantics apply: in the absence of any applicable ACE mentioning a permission, access for that permission is denied.\n\nApplicability and inheritance:\n- An ACE $(t, s, Q, \\iota)$ at node $a_i$ applies to a user $u \\in U$ if either $s = u$ or $s \\in G$ and $s \\in C(u)$.\n- For a target node $p$ with path $\\langle a_0,\\dots,a_k\\rangle$, determine the deepest index $j^\\star \\in \\{0,\\dots,k\\}$ such that $b(a_{j^\\star}) = \\text{true}$, if any exist; otherwise let $j^\\star = 0$. Only ACEs in nodes $a_j$ with $j \\in \\{j^\\star,\\dots,k\\}$ can be considered. Among these nodes, for $j  k$ (proper ancestors of $p$), only ACEs with $\\iota = \\text{true}$ are considered; at $j = k$ (the target node), ACEs are considered regardless of $\\iota$.\n\nDecision rule:\n- For each permission $q \\in \\{r,w,x\\}$, among all applicable ACEs mentioning $q$ in nodes $a_j$ with $j \\in \\{j^\\star,\\dots,k\\}$, the ones at the maximum depth $j_{\\max}$ take precedence. If at depth $j_{\\max}$ at least one applicable ACE has type DENY, then $q$ is denied; else if at that same depth at least one applicable ACE has type ALLOW, then $q$ is allowed; else, if no ACE mentions $q$, it is denied by default.\n\nOutput encoding:\n- Map permissions to bits as follows: $r \\mapsto 1$, $w \\mapsto 2$, $x \\mapsto 4$. The effective permission bitmask for a user-target pair is the sum of the bits for the permissions that are allowed.\n\nData for this problem:\n- Users $U = \\{\\text{Alice}, \\text{Bob}, \\text{Carol}\\}$.\n- Groups $G = \\{\\text{G1}, \\text{G2}, \\text{G3}\\}$.\n- Membership relation $M$ contains the following pairs:\n  - User-to-group: $(\\text{Alice}, \\text{G1})$, $(\\text{Bob}, \\text{G2})$, $(\\text{Carol}, \\text{G3})$.\n  - Group-to-group (nested): $(\\text{G1}, \\text{G2})$.\n- Project tree $P$ with parent relation $\\pi$:\n  - Nodes: Root, SubA, SubA1, SubA2, SubB, SubB1.\n  - Parent mapping: $\\pi(\\text{SubA})=\\text{Root}$, $\\pi(\\text{SubA1})=\\text{SubA}$, $\\pi(\\text{SubA2})=\\text{SubA}$, $\\pi(\\text{SubB})=\\text{Root}$, $\\pi(\\text{SubB1})=\\text{SubB}$.\n  - Protection flags: $b(\\text{SubA2})=\\text{true}$; all other nodes have $b=\\text{false}$.\n- ACEs at each node:\n  - Root:\n    - $(\\text{ALLOW}, \\text{G2}, \\{r\\}, \\text{true})$,\n    - $(\\text{DENY}, \\text{G3}, \\{x\\}, \\text{true})$,\n    - $(\\text{ALLOW}, \\text{Bob}, \\{w\\}, \\text{false})$.\n  - SubA:\n    - $(\\text{ALLOW}, \\text{G1}, \\{w\\}, \\text{true})$.\n  - SubA1:\n    - $(\\text{DENY}, \\text{G2}, \\{w\\}, \\text{false})$.\n  - SubA2:\n    - $(\\text{ALLOW}, \\text{Alice}, \\{x\\}, \\text{true})$,\n    - $(\\text{DENY}, \\text{G1}, \\{w\\}, \\text{true})$,\n    - $(\\text{ALLOW}, \\text{G2}, \\{w\\}, \\text{true})$.\n  - SubB:\n    - $(\\text{ALLOW}, \\text{Carol}, \\{x\\}, \\text{true})$.\n  - SubB1:\n    - no ACEs.\n\nTask:\n- Implement a complete, runnable program that constructs the above data and computes the effective permission bitmask for each of the following $6$ test queries $(u, p)$, in this exact order:\n  $1.$ $(\\text{Alice}, \\text{SubA1})$,\n  $2.$ $(\\text{Alice}, \\text{SubA2})$,\n  $3.$ $(\\text{Alice}, \\text{SubB1})$,\n  $4.$ $(\\text{Bob}, \\text{SubA1})$,\n  $5.$ $(\\text{Carol}, \\text{SubA1})$,\n  $6.$ $(\\text{Bob}, \\text{Root})$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list of base-$10$ integers enclosed in square brackets (for example, $[\\dots]$). No additional whitespace or characters are permitted before or after this line.\n\nConstraints and notes:\n- Your implementation must be deterministic and must not read any input.\n- Apply the decision rule exactly as stated: deeper nodes take precedence; at the same depth, if both an ALLOW and a DENY applicable ACE mention the same permission, the decision at that depth is DENY.\n- The program must encode permissions using $r \\mapsto 1$, $w \\mapsto 2$, $x \\mapsto 4$, and sum the bits corresponding to allowed permissions to form the final integer per test case.",
            "solution": "The problem statement has been validated and is deemed a well-posed, self-contained, and scientifically grounded problem in the domain of computer science, specifically access control systems. All necessary data, definitions, and rules are provided to deterministically compute a unique solution for each query.\n\nThe solution proceeds in two stages: first, the static analysis of the hierarchy and memberships, and second, the dynamic evaluation of permissions for each query according to the specified rules.\n\n**1. System Model and Static Analysis**\n\nLet the set of users be $U = \\{\\text{Alice}, \\text{Bob}, \\text{Carol}\\}$ and the set of groups be $G = \\{\\text{G1}, \\text{G2}, \\text{G3}\\}$. The set of principals is $S = U \\cup G$. The project tree $P$ and parent relation $\\pi$ are given.\n\nThe core of the static analysis is to compute the transitive closure of the group membership relation $M$. The given direct memberships are $M = \\{(\\text{Alice}, \\text{G1}), (\\text{Bob}, \\text{G2}), (\\text{Carol}, \\text{G3}), (\\text{G1}, \\text{G2})\\}$. For a user $u \\in U$, we compute the set $C(u)$ of all groups they belong to.\n\n- **For Alice**: Alice is directly in G1, i.e., $(\\text{Alice}, \\text{G1}) \\in M$. The relation also contains a nested membership $(\\text{G1}, \\text{G2}) \\in M$. By transitivity, since Alice is in G1 and G1 is in G2, Alice is also in G2. Therefore, $C(\\text{Alice}) = \\{\\text{G1}, \\text{G2}\\}$.\n- **For Bob**: Bob is directly in G2, i.e., $(\\text{Bob}, \\text{G2}) \\in M$. There are no further memberships derived from this. Thus, $C(\\text{Bob}) = \\{\\text{G2}\\}$.\n- **For Carol**: Carol is directly in G3, i.e., $(\\text{Carol}, \\text{G3}) \\in M$. There are no further memberships derived from this. Thus, $C(\\text{Carol}) = \\{\\text{G3}\\}$.\n\nThe project tree structure is a hierarchy rooted at a node named 'Root'.\n- $\\text{path}(\\text{Root}) = \\langle\\text{Root}\\rangle$\n- $\\text{path}(\\text{SubA1}) = \\langle\\text{Root}, \\text{SubA}, \\text{SubA1}\\rangle$\n- $\\text{path}(\\text{SubA2}) = \\langle\\text{Root}, \\text{SubA}, \\text{SubA2}\\rangle$\n- $\\text{path}(\\text{SubB1}) = \\langle\\text{Root}, \\text{SubB}, \\text{SubB1}\\rangle$\nThe node SubA2 has its protection flag set, $b(\\text{SubA2}) = \\text{true}$. For all other nodes $p$, $b(p) = \\text{false}$.\n\n**2. Algorithm for Permission Evaluation**\n\nFor a given query $(u, p)$ with user $u$ and target project $p$, and for each permission $q \\in \\{r, w, x\\}$, we apply the following steps:\n\n1.  **Determine Path and Inheritance Scope**: Construct the path from the root to $p$, $\\text{path}(p) = \\langle a_0, \\dots, a_k \\rangle$. Find the greatest index $j^\\star \\in \\{0, \\dots, k\\}$ such that $b(a_{j^\\star}) = \\text{true}$. If no such node exists, set $j^\\star = 0$. The set of nodes to consider for ACEs is $\\{a_j \\mid j \\in \\{j^\\star, \\dots, k\\}\\}$.\n2.  **Collect Applicable ACEs**: An ACE $(t, s, Q, \\iota)$ at node $a_j$ is considered applicable to user $u$ for permission $q$ if:\n    - $q \\in Q$.\n    - The subject $s$ matches the user: $s = u$ or $s \\in C(u)$.\n    - The ACE is considered based on its location: if $j  k$ (i.e., $a_j$ is a proper ancestor of $p$), the inheritable flag must be true, $\\iota = \\text{true}$. If $j = k$ (i.e., $a_j$ is the target node $p$), the ACE is considered regardless of $\\iota$.\n3.  **Apply Decision Rule**:\n    - Let $\\mathcal{A}$ be the set of all applicable ACEs for permission $q$ collected in the previous step, paired with their node depth.\n    - If $\\mathcal{A}$ is empty, permission $q$ is denied (default-deny).\n    - Otherwise, find the maximum depth $j_{\\max} = \\max \\{j \\mid ((t,s,Q,\\iota), j) \\in \\mathcal{A}\\}$.\n    - Examine all applicable ACEs at depth $j_{\\max}$. If any of them has type $t=\\text{DENY}$, permission $q$ is denied.\n    - Otherwise (all applicable ACEs at depth $j_{\\max}$ are of type $t=\\text{ALLOW}$), permission $q$ is allowed.\n4.  **Compute Bitmask**: The final permission bitmask is the sum of values for all allowed permissions, where $r \\mapsto 1$, $w \\mapsto 2$, and $x \\mapsto 4$.\n\n**3. Detailed Computations for Test Queries**\n\nLet's illustrate with two queries.\n\n**Query 1: $(\\text{Alice}, \\text{SubA1})$**\n- **Path and Scope**: $\\text{path}(\\text{SubA1}) = \\langle \\text{Root}_0, \\text{SubA}_1, \\text{SubA1}_2 \\rangle$. No nodes on this path are protected, so $j^\\star = 0$. We consider nodes from index $0$ to $2$.\n- **Permission $r$**:\n    - The ACE $(\\text{ALLOW}, \\text{G2}, \\{r\\}, \\text{true})$ at Root (depth $0$) is applicable because Alice $\\in C(\\text{Alice})$, $C(\\text{Alice})$ contains G2, and $\\iota=\\text{true}$ for an ancestor.\n    - No other applicable ACEs for $r$.\n    - $j_{\\max} = 0$. The only ACE at this depth is `ALLOW`. Result: **$r$ is allowed**.\n- **Permission $w$**:\n    - The ACE $(\\text{ALLOW}, \\text{G1}, \\{w\\}, \\text{true})$ at SubA (depth $1$) is applicable (Alice $\\in$ G1, $\\iota=\\text{true}$).\n    - The ACE $(\\text{DENY}, \\text{G2}, \\{w\\}, \\text{false})$ at SubA1 (depth $2$) is applicable (Alice $\\in$ G2, on target node).\n    - $j_{\\max} = 2$. The ACE at this depth is `DENY`. Result: **$w$ is denied**.\n- **Permission $x$**: No applicable ACEs. Result: **$x$ is denied** (default-deny).\n- **Final Bitmask**: $1 (r) + 0 (w) + 0 (x) = 1$.\n\n**Query 2: $(\\text{Alice}, \\text{SubA2})$**\n- **Path and Scope**: $\\text{path}(\\text{SubA2}) = \\langle \\text{Root}_0, \\text{SubA}_1, \\text{SubA2}_2 \\rangle$. Node SubA2 is protected ($b(\\text{SubA2})=\\text{true}$), so $j^\\star = 2$. We only consider node SubA2.\n- **Permission $r$**: No ACEs for $r$ at SubA2. Result: **$r$ is denied**.\n- **Permission $w$**:\n    - At SubA2 (depth $2$): $(\\text{DENY}, \\text{G1}, \\{w\\}, \\text{true})$ is applicable (Alice $\\in$ G1). Also, $(\\text{ALLOW}, \\text{G2}, \\{w\\}, \\text{true})$ is applicable (Alice $\\in$ G2).\n    - $j_{\\max} = 2$. At this depth, there is an applicable `DENY`. Result: **$w$ is denied**.\n- **Permission $x$**:\n    - At SubA2 (depth $2$): $(\\text{ALLOW}, \\text{Alice}, \\{x\\}, \\text{true})$ is applicable.\n    - $j_{\\max} = 2$. The only applicable ACE is `ALLOW`. Result: **$x$ is allowed**.\n- **Final Bitmask**: $0 (r) + 0 (w) + 4 (x) = 4$.\n\n**4. Summary of All Results**\n\nFollowing the same procedure for all queries yields the following results:\n1.  $(\\text{Alice}, \\text{SubA1}) \\rightarrow 1$\n2.  $(\\text{Alice}, \\text{SubA2}) \\rightarrow 4$\n3.  $(\\text{Alice}, \\text{SubB1}) \\rightarrow 1$\n4.  $(\\text{Bob}, \\text{SubA1}) \\rightarrow 1$\n5.  $(\\text{Carol}, \\text{SubA1}) \\rightarrow 0$\n6.  $(\\text{Bob}, \\text{Root}) \\rightarrow 3$\nThe final output is the comma-separated list of these integer bitmasks.",
            "answer": "```c\n#include stdio.h\n#include stdlib.h\n#include string.h\n#include math.h\n\n// Use C23 native bool type\n#if __STDC_VERSION__  202311L\n#include stdbool.h\n#endif\n\n// --- Data Model Definitions ---\n\n// Principals (Users and Groups)\ntypedef enum {\n    USER_ALICE, USER_BOB, USER_CAROL, NUM_USERS\n} UserId;\n\ntypedef enum {\n    GROUP_G1, GROUP_G2, GROUP_G3, NUM_GROUPS\n} GroupId;\n\ntypedef enum {\n    PRINCIPAL_ALICE = USER_ALICE,\n    PRINCIPAL_BOB = USER_BOB,\n    PRINCIPAL_CAROL = USER_CAROL,\n    PRINCIPAL_G1 = NUM_USERS + GROUP_G1,\n    PRINCIPAL_G2 = NUM_USERS + GROUP_G2,\n    PRINCIPAL_G3 = NUM_USERS + GROUP_G3,\n    NUM_PRINCIPALS\n} PrincipalId;\n\n// Permissions\ntypedef enum {\n    PERM_R = 1,\n    PERM_W = 2,\n    PERM_X = 4\n} Permission;\n\n// Project Nodes\ntypedef enum {\n    NODE_ROOT, NODE_SUBA, NODE_SUBA1, NODE_SUBA2, NODE_SUBB, NODE_SUBB1, NUM_NODES\n} NodeId;\n\n// Access Control Entry (ACE)\ntypedef enum { ACE_ALLOW, ACE_DENY } AceType;\n\ntypedef struct {\n    AceType type;\n    PrincipalId subject;\n    int permissions; // Bitmask of Permission\n    bool inheritable;\n} ACE;\n\n// Project Node Structure\ntypedef struct {\n    NodeId parent_id;\n    bool is_protected;\n    ACE* aces;\n    int num_aces;\n} ProjectNode;\n\n// Query Structure\ntypedef struct {\n    UserId user_id;\n    NodeId node_id;\n} Query;\n\n\n// --- System State ---\n\n// Project nodes data\nstatic ProjectNode system_nodes[NUM_NODES];\n\n// ACEs data storage\nstatic ACE aces_root[] = {\n    {ACE_ALLOW, PRINCIPAL_G2, PERM_R, true},\n    {ACE_DENY,  PRINCIPAL_G3, PERM_X, true},\n    {ACE_ALLOW, PRINCIPAL_BOB, PERM_W, false}\n};\nstatic ACE aces_suba[] = {\n    {ACE_ALLOW, PRINCIPAL_G1, PERM_W, true}\n};\nstatic ACE aces_suba1[] = {\n    {ACE_DENY, PRINCIPAL_G2, PERM_W, false}\n};\nstatic ACE aces_suba2[] = {\n    {ACE_ALLOW, PRINCIPAL_ALICE, PERM_X, true},\n    {ACE_DENY,  PRINCIPAL_G1, PERM_W, true},\n    {ACE_ALLOW, PRINCIPAL_G2, PERM_W, true}\n};\nstatic ACE aces_subb[] = {\n    {ACE_ALLOW, PRINCIPAL_CAROL, PERM_X, true}\n};\n\n// --- Helper Functions ---\n\nvoid initialize_system_state(bool user_in_group[NUM_USERS][NUM_GROUPS]) {\n    // Initialize project tree structure\n    system_nodes[NODE_ROOT]  = (ProjectNode){-1, false, aces_root, sizeof(aces_root)/sizeof(ACE)};\n    system_nodes[NODE_SUBA]  = (ProjectNode){NODE_ROOT, false, aces_suba, sizeof(aces_suba)/sizeof(ACE)};\n    system_nodes[NODE_SUBA1] = (ProjectNode){NODE_SUBA, false, aces_suba1, sizeof(aces_suba1)/sizeof(ACE)};\n    system_nodes[NODE_SUBA2] = (ProjectNode){NODE_SUBA, true, aces_suba2, sizeof(aces_suba2)/sizeof(ACE)};\n    system_nodes[NODE_SUBB]  = (ProjectNode){NODE_ROOT, false, aces_subb, sizeof(aces_subb)/sizeof(ACE)};\n    system_nodes[NODE_SUBB1] = (ProjectNode){NODE_SUBB, false, NULL, 0};\n\n    // Initialize group memberships\n    // Direct user-to-group\n    user_in_group[USER_ALICE][GROUP_G1] = true;\n    user_in_group[USER_BOB][GROUP_G2] = true;\n    user_in_group[USER_CAROL][GROUP_G3] = true;\n    \n    // Direct group-to-group\n    bool group_in_group[NUM_GROUPS][NUM_GROUPS] = {false};\n    group_in_group[GROUP_G1][GROUP_G2] = true;\n\n    // Compute transitive closure for user memberships\n    bool changed = true;\n    while (changed) {\n        changed = false;\n        for (int u = 0; u  NUM_USERS; ++u) {\n            for (int g = 0; g  NUM_GROUPS; ++g) {\n                if (user_in_group[u][g]) {\n                    for (int h = 0; h  NUM_GROUPS; ++h) {\n                        if (group_in_group[g][h]  !user_in_group[u][h]) {\n                            user_in_group[u][h] = true;\n                            changed = true;\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\nbool is_ace_applicable(const ACE* ace, UserId user_id, const bool user_in_group[NUM_USERS][NUM_GROUPS]) {\n    if (ace-subject  NUM_USERS) { // Subject is a user\n        return ace-subject == user_id;\n    } else { // Subject is a group\n        GroupId group_id = ace-subject - NUM_USERS;\n        return user_in_group[user_id][group_id];\n    }\n}\n\nint compute_permissions(const Query* query, const bool user_in_group[NUM_USERS][NUM_GROUPS]) {\n    NodeId path[NUM_NODES];\n    int path_len = 0;\n    NodeId current_node_id = query-node_id;\n\n    // 1. Determine Path from root to target\n    while (current_node_id != -1) {\n        path[path_len++] = current_node_id;\n        current_node_id = system_nodes[current_node_id].parent_id;\n    }\n    // Reverse path to be from root to target\n    for (int i = 0; i  path_len / 2; ++i) {\n        NodeId temp = path[i];\n        path[i] = path[path_len - 1 - i];\n        path[path_len - 1 - i] = temp;\n    }\n\n    // 2. Determine Inheritance Scope (j_star)\n    int j_star = 0;\n    for (int i = 0; i  path_len; ++i) {\n        if (system_nodes[path[i]].is_protected) {\n            j_star = i;\n        }\n    }\n\n    int effective_permissions = 0;\n    Permission permissions_to_check[] = {PERM_R, PERM_W, PERM_X};\n\n    // 3. Evaluate each permission\n    for (int p_idx = 0; p_idx  3; ++p_idx) {\n        Permission q = permissions_to_check[p_idx];\n        \n        int max_depth = -1;\n        AceType decision_at_max_depth = ACE_ALLOW; // Default to allow if any match at max depth\n\n        // Find max depth of any applicable ACE\n        for (int j = j_star; j  path_len; ++j) {\n            ProjectNode* node = system_nodes[path[j]];\n            for (int i = 0; i  node-num_aces; ++i) {\n                ACE* ace = node-aces[i];\n                bool is_on_target = (j == path_len - 1);\n                \n                if ((ace-permissions  q)  (is_on_target || ace-inheritable)  is_ace_applicable(ace, query-user_id, user_in_group)) {\n                    if (j  max_depth) {\n                        max_depth = j;\n                    }\n                }\n            }\n        }\n        \n        // If an applicable ACE exists, make a decision based on the deepest one(s)\n        if (max_depth != -1) {\n            bool deny_found = false;\n            ProjectNode* node_at_max_depth = system_nodes[path[max_depth]];\n            for (int i = 0; i  node_at_max_depth-num_aces; ++i) {\n                ACE* ace = node_at_max_depth-aces[i];\n                bool is_on_target = (max_depth == path_len - 1);\n\n                if ((ace-permissions  q)  (is_on_target || ace-inheritable)  is_ace_applicable(ace, query-user_id, user_in_group)) {\n                    if (ace-type == ACE_DENY) {\n                        deny_found = true;\n                        break; \n                    }\n                }\n            }\n            if (!deny_found) {\n                effective_permissions |= q;\n            }\n        }\n        // Otherwise, permission is denied by default (do nothing)\n    }\n\n    return effective_permissions;\n}\n\nint main(void) {\n    bool user_in_group[NUM_USERS][NUM_GROUPS] = {false};\n    initialize_system_state(user_in_group);\n\n    Query test_queries[] = {\n        {USER_ALICE, NODE_SUBA1},\n        {USER_ALICE, NODE_SUBA2},\n        {USER_ALICE, NODE_SUBB1},\n        {USER_BOB,   NODE_SUBA1},\n        {USER_CAROL, NODE_SUBA1},\n        {USER_BOB,   NODE_ROOT}\n    };\n    int num_queries = sizeof(test_queries) / sizeof(test_queries[0]);\n    int results[num_queries];\n\n    for (int i = 0; i  num_queries; ++i) {\n        results[i] = compute_permissions(test_queries[i], user_in_group);\n    }\n\n    printf(\"[%d,%d,%d,%d,%d,%d]\", results[0], results[1], results[2], results[3], results[4], results[5]);\n\n    return EXIT_SUCCESS;\n}\n```"
        },
        {
            "introduction": "Beyond controlling access, a robust protection mechanism must also guarantee the integrity and authenticity of the data itself. This advanced practice moves beyond permissions to the realm of cryptographic verification, where the goal is to create a tamper-evident log. You will implement an append-only log using a hash chain for integrity and a keyed-hash message authentication code (MAC) for authorship, concepts that are foundational to secure audit trails, version control systems, and even blockchains . This exercise demonstrates how to build trust not just in who can access data, but in the data's history and content.",
            "id": "3642395",
            "problem": "You are asked to design and implement an append-only shared log mechanism for submissions that permits corrections via new entries while verifying authorship and integrity without in-place edits. The system must be modeled using a tamper-evident hash chain and a keyed message authentication code, and the logic must be implemented as a complete, runnable program that outputs verification results over a specified test suite.\n\nFundamental base and core definitions to be used:\n- Append-only semantics: a log is append-only if past entries are not modified and new entries strictly extend the log in time and index order. An operational invariant is that indices are strictly increasing by $1$ and timestamps are non-decreasing. This invariant ensures that any deviation implies a violation of append-only behavior.\n- Integrity via hash chaining: define a digest $h_i$ for each entry $i$ by hashing a deterministic encoding of the entry and the previous digest $h_{i-1}$. Any change to a prior entry changes $h_{i-1}$ and propagates to $h_i$, making tampering detectable.\n- Authorship via a keyed message authentication code (MAC): Given a per-author secret key $K_{\\text{author}}$, define a deterministic function $M(K_{\\text{author}}, h_i)$ that binds the author to the digest. Verification recomputes $M$ and compares it with the recorded MAC to confirm authorship and integrity.\n- Corrections via new entries: A correction entry references a prior entry index and does not modify any previous content. The correction’s author must match the original author of the referenced entry.\n\nCanonical encoding of each log entry $i$:\n- Each entry is a tuple $(i, t_i, a_i, \\tau_i, \\rho_i, m_i)$, where $i$ is the index, $t_i$ is the timestamp, $a_i$ is the author identifier string, $\\tau_i \\in \\{\\text{'N'}, \\text{'C'}\\}$ indicates a new submission or a correction, $\\rho_i$ is the referenced target index (use $0$ if not applicable), and $m_i$ is the message text.\n- Let $h_0 = 0$. Define the canonical ASCII encoding $S_i$ as the concatenation of fields separated by the vertical bar character with the previous digest appended in fixed-width hexadecimal as\n$$\nS_i = \\text{ASCII}\\big(\\text{format}\\big(i\\;|\\;t_i\\;|\\;a_i\\;|\\;\\tau_i\\;|\\;\\rho_i\\;|\\;m_i\\;|\\;\\text{prev} = \\text{hex}_{16}(h_{i-1})\\big)\\big).\n$$\n- The digest function $H$ is the $64$-bit Fowler–Noll–Vo ($\\text{FNV-1a}$) hash with offset basis $1469598103934665603$ and prime $1099511628211$. For a byte sequence $(b_j)$, the hash iterates $h \\leftarrow (h \\oplus b_j) \\times 1099511628211 \\bmod 2^{64}$ starting from $h = 1469598103934665603$.\n- The keyed MAC is defined as\n$$\nM(K, h) = \\operatorname{rotl}_{64}(h \\oplus K, 13) \\oplus C,\n$$\nwhere $C = 0x9e3779b97f4a7c15$ and $\\operatorname{rotl}_{64}$ denotes a $64$-bit left rotation by $13$ bits.\n\nVerification rules the program must implement:\n- Append-only ordering: for all entries, indices must satisfy $i_l = l$ for $l \\in \\{1, 2, \\dots, n\\}$, and timestamps must satisfy $t_l \\ge t_{l-1}$ for $l \\ge 2$.\n- Correction constraints: if $\\tau_i = \\text{'C'}$, then the target index must satisfy $1 \\le \\rho_i \\le i-1$, and the author must equal the author of the referenced target entry.\n- Authorship and integrity verification: for each entry $i$, compute $h_i = H(S_i)$ and verify that the recorded $\\text{mac}_i$ equals $M(K_{a_i}, h_i)$ given the per-author key $K_{a_i}$.\n\nAuthor keys:\n- $K_{\\text{alice}} = 0x0123456789ABCDEF$\n- $K_{\\text{bob}} = 0xFEDCBA9876543210$\n- $K_{\\text{carol}} = 0x0F0F0F0F0F0F0F0F$\n\nTest suite specification:\n- Case $1$ (valid happy path):\n  - Entries:\n    - $(i=1, t_1=1000, a_1=\\text{\"alice\"}, \\tau_1=\\text{'N'}, \\rho_1=0, m_1=\\text{\"Task A\"})$\n    - $(i=2, t_2=1005, a_2=\\text{\"alice\"}, \\tau_2=\\text{'C'}, \\rho_2=1, m_2=\\text{\"Fix typo\"})$\n    - $(i=3, t_3=1010, a_3=\\text{\"bob\"}, \\tau_3=\\text{'N'}, \\rho_3=0, m_3=\\text{\"Task B\"})$\n    - $(i=4, t_4=1015, a_4=\\text{\"bob\"}, \\tau_4=\\text{'C'}, \\rho_4=3, m_4=\\text{\"Add detail\"})$\n  - For this case, $\\text{mac}_i$ for each $i$ is computed by the program as $M(K_{a_i}, H(S_i))$ using $h_0 = 0$ and the chain rule.\n- Case $2$ (tampered content in place, recorded MAC unchanged):\n  - Start from Case $1$. Replace the message of entry $i=3$ with $m_3=\\text{\"Task X\"}$ but keep the recorded $\\text{mac}_3$ identical to the Case $1$ value. All other entries remain identical to Case $1$ including their recorded MACs. This simulates an in-place content change without recomputing the MAC, which must be detected as invalid.\n- Case $3$ (broken append-only index ordering):\n  - Entries:\n    - $(i=1, t_1=3000, a_1=\\text{\"alice\"}, \\tau_1=\\text{'N'}, \\rho_1=0, m_1=\\text{\"T1\"})$\n    - $(i=3, t_2=3005, a_2=\\text{\"bob\"}, \\tau_2=\\text{'N'}, \\rho_2=0, m_2=\\text{\"T3\"})$\n    - $(i=4, t_3=3010, a_3=\\text{\"bob\"}, \\tau_3=\\text{'C'}, \\rho_3=3, m_3=\\text{\"C3\"})$\n  - The indices are not contiguous by $1$ (missing $i=2$), which must be detected as invalid. Recorded $\\text{mac}_i$ values are computed normally for the given fields and chain rule.\n- Case $4$ (invalid correction reference to a non-existent future entry):\n  - Entries:\n    - $(i=1, t_1=2000, a_1=\\text{\"carol\"}, \\tau_1=\\text{'N'}, \\rho_1=0, m_1=\\text{\"Report\"})$\n    - $(i=2, t_2=2001, a_2=\\text{\"carol\"}, \\tau_2=\\text{'C'}, \\rho_2=3, m_2=\\text{\"Refine\"})$\n  - The correction references $\\rho_2=3$ which does not exist and violates $1 \\le \\rho_2 \\le i-1$; this must be detected as invalid. Recorded $\\text{mac}_i$ values are computed normally for the given fields and chain rule.\n\nRequired output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the four test cases: for example, $\\text{[result1,result2,result3,result4]}$ where each result is an integer $0$ (invalid) or $1$ (valid). No extra spaces or text should be printed.\n\nYour task:\n- Implement the described verification mechanism and apply it to the four test cases exactly as specified, including the construction procedure for Case $2$. The program must compute the digests and MACs as defined, enforce all constraints, and print the single-line result in the required format.",
            "solution": "The problem requires the design and implementation of a verification system for an append-only shared log. The system must ensure the integrity, authorship, and structural consistency of log entries using a hash chain and a keyed-hash message authentication code (MAC). The solution is presented as a C program that validates four distinct test cases against a set of rigorously defined rules.\n\nThe logical design is partitioned into several components: data structures for log entries, implementations of the specified cryptographic primitives, and a comprehensive verification function that enforces all system rules.\n\nFirst, we define a data structure, `LogEntry`, to represent a single entry in the log. This structure encapsulates all fields specified in the canonical encoding: the index $i$, timestamp $t_i$, author identifier $a_i$, type $\\tau_i \\in \\{\\text{'N'}, \\text{'C'}\\}$, referenced index $\\rho_i$, the message text $m_i$, and the recorded MAC, $\\text{mac}_i$. Author keys, such as $K_{\\text{alice}}$, are defined as $64$-bit unsigned integer constants. A helper function maps author name strings to their corresponding keys.\n\nThe core of the integrity mechanism is the hash chain, which relies on the $64$-bit Fowler–Noll–Vo hash function (FNV-1a), denoted as $H$. This function is implemented to process a sequence of bytes, corresponding to the canonical string representation $S_i$ of a log entry. The FNV-1a algorithm is initialized with the standard offset basis $h = 1469598103934665603$. For each byte $b_j$ in the input string, the hash is updated via the operation $h \\leftarrow (h \\oplus b_j) \\times 1099511628211$, with all arithmetic performed modulo $2^{64}$. The canonical string $S_i$ for an entry $i$ is constructed by concatenating its fields, separated by the `|` character, and appending the hexadecimal representation of the previous entry's digest, $h_{i-1}$. The chain starts with a genesis digest $h_0 = 0$.\n\nAuthorship and integrity are bound together using a custom keyed message authentication code, $M(K, h)$. This function takes a per-author secret key $K$ and a digest $h$, and computes the MAC as $M(K, h) = \\operatorname{rotl}_{64}(h \\oplus K, 13) \\oplus C$. The operation $\\operatorname{rotl}_{64}(x, n)$ represents a $64$-bit left bitwise rotation of $x$ by $n$ bits, implemented as $(x \\ll n) | (x \\gg (64 - n))$. The constant $C$ is defined as $0x9e3779b97f4a7c15$. This MAC binds the author's key to the entry's content (via its digest), ensuring that only the possessor of the key could have generated the valid MAC for that entry.\n\nThe main verification logic is encapsulated in a function, `verify_log`, which iterates through a given log and applies all specified rules sequentially. For each entry at position $l$ in the log (where $l$ begins at $1$):\n$1$. **Append-Only Ordering Verification**: The function first validates the structural invariants. It checks that the entry's index field $i_l$ is equal to its position $l$ in the log, i.e., $i_l = l$. It also ensures that the timestamp is non-decreasing by checking that $t_l \\ge t_{l-1}$ for all $l \\ge 2$. A violation of either of these conditions indicates a breach of the append-only property and results in immediate invalidation of the log.\n$2$. **Correction Constraint Verification**: If an entry is a correction ($\\tau_l = \\text{'C'}$), the function enforces two additional rules. The referenced index $\\rho_l$ must point to a valid, existing prior entry, satisfying $1 \\le \\rho_l \\le i_l-1$. Furthermore, the author of the correction, $a_l$, must be identical to the author of the referenced entry, $a_{\\rho_l}$. This ensures that only original authors can correct their own submissions.\n$3$. **Authorship and Integrity Verification**: This is the final and most critical check. The function re-computes the entire hash chain from the beginning. For each entry $l$, it constructs the canonical string $S_l$ using the current entry's data and the digest of the previous entry, $h_{l-1}$. It then computes the digest $h_l = H(S_l)$. Using the author's key $K_{a_l}$, it computes the expected MAC, $M(K_{a_l}, h_l)$. This recomputed MAC is compared against the recorded $\\text{mac}_l$ stored with the entry. A mismatch implies that either the entry's content has been tampered with or the recorded MAC is invalid, causing the entire log to be rejected. If the MACs match, the computed $h_l$ is stored as the new `prev_hash` for the next iteration.\n\nIf all entries in the log pass all these checks, the function returns a status of valid ($1$); otherwise, it returns invalid ($0$).\n\nThe `main` function systematically constructs and evaluates the four test cases.\n- **Case 1 (Valid)**: The entries are defined as specified, and a helper function, `compute_mac_chain`, is first used to populate the `mac` fields by correctly calculating the entire hash and MAC chain. The `verify_log` function is then called on this \"golden\" log, which is expected to pass all checks.\n- **Case 2 (Tampered)**: This case is constructed by taking the valid log from Case $1$, modifying the message of entry $3$ to `\"Task X\"`, but retaining the original, now incorrect, MACs from Case $1$. The verification is expected to fail at entry $3$ due to a MAC mismatch.\n- **Case 3 (Broken Index)**: The log is defined with non-sequential indices ($1, 3, 4$). The verification is expected to fail at the second entry, as its index field $i_2=3$ violates the rule $i_l=l$.\n- **Case 4 (Invalid Correction)**: The log is defined with a correction entry at index $2$ that references a future, non-existent entry with index $\\rho_2=3$. This violates the rule $1 \\le \\rho_l \\le i_l-1$, and the verification is expected to fail.\n\nThe program calculates the validity of each case and prints the results in the specified format `[1,0,0,0]`.",
            "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n#include stdio.h\n#include stdlib.h\n#include string.h\n#include math.h\n// Note: Other headers per problem are not needed for this solution.\n\n// Use unsigned long long for 64-bit integers as it's standard and guaranteed = 64 bits.\ntypedef unsigned long long uint64_t;\n\n// FNV-1a hash function constants\nconst uint64_t FNV_OFFSET_BASIS = 1469598103934665603ULL;\nconst uint64_t FNV_PRIME = 1099511628211ULL;\n\n// MAC function constant\nconst uint64_t MAC_CONSTANT_C = 0x9e3779b97f4a7c15ULL;\n\n// Author secret keys\nconst uint64_t KEY_ALICE = 0x0123456789ABCDEFULL;\nconst uint64_t KEY_BOB = 0xFEDCBA9876543210ULL;\nconst uint64_t KEY_CAROL = 0x0F0F0F0F0F0F0F0FULL;\n\n// Structure to represent a single log entry\ntypedef struct {\n    int index;\n    int timestamp;\n    const char *author;\n    char type;\n    int ref_index;\n    const char *message;\n    uint64_t mac; // The recorded MAC for verification\n} LogEntry;\n\n// Retrieves the 64-bit key for a given author name.\nuint64_t get_author_key(const char* author) {\n    if (strcmp(author, \"alice\") == 0) return KEY_ALICE;\n    if (strcmp(author, \"bob\") == 0) return KEY_BOB;\n    if (strcmp(author, \"carol\") == 0) return KEY_CAROL;\n    return 0; // Should not be reached with valid problem data\n}\n\n// Implements the 64-bit FNV-1a hash algorithm.\nuint64_t fnv1a_hash(const char *str) {\n    uint64_t hash = FNV_OFFSET_BASIS;\n    while (*str) {\n        hash ^= (uint64_t)(unsigned char)(*str++);\n        hash *= FNV_PRIME;\n    }\n    return hash;\n}\n\n// Implements the 64-bit left bitwise rotation.\nuint64_t rotl64(uint64_t x, int bits) {\n    return (x  bits) | (x  (64 - bits));\n}\n\n// Implements the specified keyed MAC function.\nuint64_t calculate_mac(uint64_t key, uint64_t hash) {\n    return rotl64(hash ^ key, 13) ^ MAC_CONSTANT_C;\n}\n\n// Constructs the canonical string representation of a log entry for hashing.\nvoid build_canonical_string(char* buffer, size_t buffer_size, const LogEntry* entry, uint64_t prev_hash) {\n    snprintf(buffer, buffer_size, \"%d|%d|%s|%c|%d|%s|prev=%016llx\",\n             entry-index, entry-timestamp, entry-author, entry-type,\n             entry-ref_index, entry-message, prev_hash);\n}\n\n// Computes the correct MAC for each entry in a log chain. Used for test case setup.\nvoid compute_mac_chain(LogEntry* log, int num_entries) {\n    uint64_t prev_hash = 0;\n    char buffer[1024];\n\n    for (int i = 0; i  num_entries; ++i) {\n        build_canonical_string(buffer, sizeof(buffer), log[i], prev_hash);\n        uint64_t current_hash = fnv1a_hash(buffer);\n        uint64_t key = get_author_key(log[i].author);\n        log[i].mac = calculate_mac(key, current_hash);\n        prev_hash = current_hash;\n    }\n}\n\n// Primary function to verify the integrity and validity of an entire log.\nint verify_log(const LogEntry* log, int num_entries) {\n    uint64_t prev_hash = 0;\n    char buffer[1024];\n\n    for (int l = 1; l = num_entries; ++l) {\n        const LogEntry* current_entry = log[l - 1];\n\n        // Rule 1: Append-only ordering (indices and timestamps)\n        if (current_entry-index != l) {\n            return 0; // Index must be sequential (1, 2, 3, ...)\n        }\n        if (l  1) {\n            if (current_entry-timestamp  log[l - 2].timestamp) {\n                return 0; // Timestamp must be non-decreasing\n            }\n        }\n\n        // Rule 2: Correction constraints\n        if (current_entry-type == 'C') {\n            if (!(current_entry-ref_index = 1  current_entry-ref_index  current_entry-index)) {\n                return 0; // Reference must be to a valid prior entry\n            }\n            const LogEntry* ref_entry = log[current_entry-ref_index - 1];\n            if (strcmp(current_entry-author, ref_entry-author) != 0) {\n                return 0; // Author of correction must match original author\n            }\n        }\n\n        // Rule 3: Authorship and integrity (hash chain and MAC)\n        build_canonical_string(buffer, sizeof(buffer), current_entry, prev_hash);\n        uint64_t computed_hash = fnv1a_hash(buffer);\n        \n        uint64_t key = get_author_key(current_entry-author);\n        uint64_t expected_mac = calculate_mac(key, computed_hash);\n\n        if (expected_mac != current_entry-mac) {\n            return 0; // MAC mismatch detected, indicates tampering or invalid MAC\n        }\n        \n        prev_hash = computed_hash;\n    }\n\n    return 1; // All checks passed, the log is valid\n}\n\nint main(void) {\n    int results[4];\n\n    // --- Case 1: Valid happy path ---\n    LogEntry case1_log[] = {\n        {1, 1000, \"alice\", 'N', 0, \"Task A\", 0},\n        {2, 1005, \"alice\", 'C', 1, \"Fix typo\", 0},\n        {3, 1010, \"bob\",   'N', 0, \"Task B\", 0},\n        {4, 1015, \"bob\",   'C', 3, \"Add detail\", 0}\n    };\n    int num_entries1 = sizeof(case1_log) / sizeof(case1_log[0]);\n    compute_mac_chain(case1_log, num_entries1);\n    results[0] = verify_log(case1_log, num_entries1);\n\n    // --- Case 2: Tampered content with unchanged MAC ---\n    LogEntry case2_log[] = {\n        {1, 1000, \"alice\", 'N', 0, \"Task A\", 0},\n        {2, 1005, \"alice\", 'C', 1, \"Fix typo\", 0},\n        {3, 1010, \"bob\",   'N', 0, \"Task X\", 0}, // Tampered message\n        {4, 1015, \"bob\",   'C', 3, \"Add detail\", 0}\n    };\n    int num_entries2 = sizeof(case2_log) / sizeof(case2_log[0]);\n    for (int i = 0; i  num_entries2; ++i) {\n        case2_log[i].mac = case1_log[i].mac; // Use MACs from the valid case\n    }\n    results[1] = verify_log(case2_log, num_entries2);\n\n    // --- Case 3: Broken append-only index ordering ---\n    LogEntry case3_log[] = {\n        {1, 3000, \"alice\", 'N', 0, \"T1\", 0},\n        {3, 3005, \"bob\",   'N', 0, \"T3\", 0}, // Broken index (skips 2)\n        {4, 3010, \"bob\",   'C', 3, \"C3\", 0}\n    };\n    int num_entries3 = sizeof(case3_log) / sizeof(case3_log[0]);\n    compute_mac_chain(case3_log, num_entries3);\n    results[2] = verify_log(case3_log, num_entries3);\n\n    // --- Case 4: Invalid correction reference to a non-existent entry ---\n    LogEntry case4_log[] = {\n        {1, 2000, \"carol\", 'N', 0, \"Report\", 0},\n        {2, 2001, \"carol\", 'C', 3, \"Refine\", 0} // Invalid ref_index  index-1\n    };\n    int num_entries4 = sizeof(case4_log) / sizeof(case4_log[0]);\n    compute_mac_chain(case4_log, num_entries4);\n    results[3] = verify_log(case4_log, num_entries4);\n\n    // Print the results in the EXACT required format before the final return statement\n    printf(\"[%d,%d,%d,%d]\", results[0], results[1], results[2], results[3]);\n    \n    return EXIT_SUCCESS;\n}\n```"
        }
    ]
}