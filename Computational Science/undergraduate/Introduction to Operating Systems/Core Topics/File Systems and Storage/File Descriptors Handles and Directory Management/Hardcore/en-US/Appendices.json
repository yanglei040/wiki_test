{
    "hands_on_practices": [
        {
            "introduction": "This practice grounds our understanding in the fundamental security model of POSIX file systems. When a program creates a file or directory, the operating system applies a process-specific permission mask, the umask, to the requested permissions. This exercise  walks you through the crucial bitwise calculation to determine the final, effective permissions of a newly created directory, a core skill for any systems programmer.",
            "id": "3642039",
            "problem": "A student is designing a toy shell for a Portable Operating System Interface (POSIX) system that demonstrates how process-level permission masks affect directory creation and access. The shell sequence is as follows: the shell process first sets a process umask to the octal value $237$. It then invokes the directory creation system call with an explicit mode argument of octal $775$ to create a directory named $D$. Assume that no special bits (such as set-user-ID, set-group-ID, or sticky) are involved, that only the nine permission bits (owner, group, others) matter, and that directory permissions are interpreted as follows: the read bit grants the ability to list directory entries, the write bit grants the ability to create or remove entries within the directory, and the execute bit grants the ability to traverse the directory in a pathname lookup.\n\nThe shell uses a File Descriptor (FD) abstraction for directories: it attempts to open $D$ for reading and enumeration via a library that internally issues the appropriate system call to obtain an FD on $D$ and then reads entries. For a subject class (owner, group, or others) to have practical visibility of $D$, require that both the read bit and the execute bit for that class are set on $D$.\n\nStarting from the core definitions that (i) a process umask specifies permission bits that must be cleared in the mode of newly created filesystem objects, and (ii) the effective mode of the created directory is obtained by clearing any bits present in the umask from the requested mode, derive the effective directory mode of $D$ in octal. Then, using the derived mode, verify which subject classes have both read and execute permissions and thus practical visibility according to the stated criterion. Provide as your final answer the effective directory mode of $D$ as a three-digit octal number. Do not include any units. If you perform intermediate arithmetic, keep all integers exact; no rounding is required.",
            "solution": "The problem requires the derivation of the effective permissions of a newly created directory, $D$. The calculation is based on a requested permission mode and a process-level `umask`. The fundamental principle, as stated in the problem, is that the effective mode is obtained by clearing any bits set in the `umask` from the requested mode. In bitwise logic, this corresponds to the operation $P = M \\land (\\neg U)$, where $P$ is the final effective permission mode, $M$ is the requested mode, $U$ is the `umask`, $\\land$ denotes the bitwise AND operator, and $\\neg$ denotes the bitwise NOT (complement) operator.\n\nThe given values are:\n- Process `umask`, $U = 237_8$.\n- Requested directory creation mode, $M = 775_8$.\n\nTo perform the bitwise calculation, we first convert these octal values to their $9$-bit binary representations, corresponding to the permission bits for owner, group, and others. Each octal digit maps to a $3$-bit binary sequence ($rwx$, for read, write, execute).\n\nThe `umask` is $U = 237_8$.\n- The first digit, $2_8$, corresponds to the owner's umask bits: $010_2$.\n- The second digit, $3_8$, corresponds to the group's umask bits: $011_2$.\n- The third digit, $7_8$, corresponds to others' umask bits: $111_2$.\nThus, the full `umask` in binary is $U = (010\\ 011\\ 111)_2$.\n\nThe requested mode is $M = 775_8$.\n- The first digit, $7_8$, corresponds to the owner's requested permissions ($rwx$): $111_2$.\n- The second digit, $7_8$, corresponds to the group's requested permissions ($rwx$): $111_2$.\n- The third digit, $5_8$, corresponds to others' requested permissions ($r-x$): $101_2$.\nThus, the full requested mode in binary is $M = (111\\ 111\\ 101)_2$.\n\nThe formula for the effective mode $P$ is $P = M \\land (\\neg U)$. First, we compute the bitwise complement of the `umask`, $\\neg U$. We consider the $9$ relevant permission bits.\n$$ \\neg U = \\neg (010\\ 011\\ 111)_2 = (101\\ 100\\ 000)_2 $$\n\nNext, we perform the bitwise AND operation between the requested mode $M$ and the complemented `umask` $\\neg U$:\n$$ P = M \\land (\\neg U) $$\n$$\n\\begin{array}{r@{\\,}c@{\\,}c@{\\,}c}\n   111  111  101_2  \\quad (M = 775_8) \\\\\n\\land  101  100  000_2  \\quad (\\neg U) \\\\\n\\hline\n   101  100  000_2  \\quad (P) \\\\\n\\end{array}\n$$\nThe resulting effective permission mode in binary is $P = (101\\ 100\\ 000)_2$.\n\nTo express this result in the standard octal format, we convert each $3$-bit group back to an octal digit:\n- The owner's bits are $101_2$, which is $1 \\times 2^2 + 0 \\times 2^1 + 1 \\times 2^0 = 4 + 1 = 5_8$.\n- The group's bits are $100_2$, which is $1 \\times 2^2 + 0 \\times 2^1 + 0 \\times 2^0 = 4_8$.\n- The others' bits are $000_2$, which is $0_8$.\n\nTherefore, the effective directory mode of $D$ is $540_8$.\n\nThe problem also requires verification of which subject classes have \"practical visibility,\" defined as having both the read ($r$) and execute ($x$) bits set. We analyze the effective mode $P = 540_8$:\n- **Owner Permissions**: $5_8 = 101_2$, which corresponds to $r-x$. The read bit is set and the execute bit is set. Thus, the owner has practical visibility of the directory $D$.\n- **Group Permissions**: $4_8 = 100_2$, which corresponds to $r--$. The read bit is set, but the execute bit is not. Thus, the group does not have practical visibility.\n- **Others Permissions**: $0_8 = 000_2$, which corresponds to $---$. Neither the read bit nor the execute bit is set. Thus, others do not have practical visibility.\n\nThe derivation is complete. The effective directory mode for $D$ is $540_8$, and only the owner has practical visibility according to the specified criterion. The final answer is the effective directory mode itself.",
            "answer": "$$\\boxed{540}$$"
        },
        {
            "introduction": "Here we explore the powerful and often misunderstood distinction between a file's name in a directory and the file data itself, referenced by an inode. This thought experiment  presents a classic scenario where a file remains fully accessible via its file descriptor even after being unlinked from the directory tree. Understanding this decoupling is key to grasping how operating systems manage file lifecycles and how robust applications create temporary files.",
            "id": "3642088",
            "problem": "Consider a Portable Operating System Interface (POSIX) compliant Unix-like system. A directory stores mappings from pathnames to underlying file metadata via directory entries. A file descriptor (FD) is a per-process integer handle that indexes an open file description stored by the kernel; an open file description maintains state such as the current offset and a reference to the file’s inode and is shared across duplicated descriptors. The system call `open()` resolves a pathname to an inode and creates or references an open file description, returning an FD to the process. The system call `unlink()` removes a single name-to-inode mapping from its parent directory and decrements the inode’s link count. The kernel reclaims the inode and its data blocks only when the inode’s link count is $0$ and there are no remaining references from open file descriptions.\n\nAt time $t_0$, there is a regular file at path `/tmp/x` with exactly $1$ hard link (i.e., link count = 1). Process $P_1$ successfully calls `open(\"/tmp/x\", O_RDWR)` and receives FD f, which references an open file description tied to the inode of `/tmp/x`. At time $t_1  t_0$, process $P_2$ calls `unlink(\"/tmp/x\")`, and there are no other directory entries pointing to the same inode. At time $t_2  t_1$, $P_1$ issues `write(f, ...)` of $n$ bytes, followed by `read(f, ...)` to verify the content. At time $t_3  t_2$, $P_2$ creates a brand-new file at the same pathname `/tmp/x` using `open(\"/tmp/x\", O_CREAT | O_EXCL)` and receives FD g to that new file.\n\nWhich option best explains the state after `unlink()` and why the data remains accessible via FD f despite removal of the directory entry, as well as the effect of recreating the pathname?\n\nA. In a POSIX system with reference-counted inodes and open file descriptions, once $P_1$ has obtained FD f from `open()`, the file’s data and metadata remain accessible through f even if $P_2$ removes the only directory entry via `unlink()`. $P_1$ can read and write through f until it calls `close(f)`, at which point, with link count $0$ and no remaining references, the storage is reclaimed. If $P_2$ later recreates `/tmp/x`, that pathname binds to a different inode and does not affect $P_1$’s FD f.\n\nB. The call to `unlink()` atomically invalidates all existing FDs that reference the target file, causing subsequent `read` or `write` on those FDs to fail with error number `ENOENT`.\n\nC. The kernel defers the effect of `unlink()` until all processes have closed the file; `unlink()` blocks until there are $0$ open FDs to the inode, ensuring there is no race condition between `open()` and `unlink()`.\n\nD. After `unlink()` completes, any `write()` via $P_1$’s FD f is transparently redirected to a newly created file with the same pathname if one appears, so the original removed file’s data does not remain accessible via f.\n\nE. If the file’s link count was $1$, then `unlink()` immediately frees the inode and its blocks irrespective of open FDs, making further `read` or `write` on FD f impossible.\n\nSelect the single best option.",
            "solution": "The core principle is the separation of a file's name (a directory entry) from its data and metadata (an inode). A file's storage is reclaimed by the operating system only when two conditions are simultaneously met: (1) its link count is zero (no directory entries point to it), and (2) its open file reference count is zero (no process holds an open file descriptor to it).\n\nLet's trace the state of the original file's inode.\n\n1.  **At time $t_0$**: Process $P_1$ calls `open(\"/tmp/x\", O_RDWR)`. The kernel finds the inode for `/tmp/x`, creates an open file description that points to this inode, and returns file descriptor f to $P_1$. At this point, the inode's link count is 1 (from the directory entry `/tmp/x`), and its open file reference count is now 1 (because of $P_1$'s open file descriptor).\n\n2.  **At time $t_1$**: Process $P_2$ calls `unlink(\"/tmp/x\")`. This removes the directory entry `/tmp/x` and decrements the inode's link count. The link count becomes $1 - 1 = 0$.\n\n3.  **State after $t_1$**: The inode's link count is 0, but its open file reference count is still 1. Since the reclamation condition (both counts being zero) is not met, the inode and its data blocks are **not** deleted. The file now exists without a name in the filesystem but remains fully accessible to $P_1$ through the file descriptor f.\n\n4.  **At time $t_2$**: $P_1$'s calls to `write(f, ...)` and `read(f, ...)` succeed because f is a valid descriptor pointing to a persistent open file description and inode.\n\n5.  **At time $t_3$**: $P_2$ creates a new file at the same path, `/tmp/x`. This operation creates a **new and distinct** inode. The name `/tmp/x` is now linked to this new inode. This has no effect on the original inode or on $P_1$'s file descriptor f, which remains bound to the original, now-anonymous inode.\n\nThe original file's data will only be reclaimed by the kernel when $P_1$ calls `close(f)` (or terminates), which will drop the open file reference count to 0. At that moment, both conditions for reclamation will be met. Option A perfectly summarizes this sequence of events.",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "This exercise delves into the specific and guaranteed behaviors governed by file open flags, which can sometimes interact in non-intuitive ways. By analyzing a file opened in append mode, with the `O_APPEND` flag, you will explore its atomic, end-of-file write guarantee and see how it overrides explicit positioning attempts with `lseek()`. Mastering this concept  is essential for building reliable applications that perform logging or handle concurrent data streams.",
            "id": "3642026",
            "problem": "You are analyzing a program on a system that conforms to the Portable Operating System Interface (POSIX). The program operates on a regular file and uses a single file descriptor. Consider the following setup and actions.\n\nFundamental base and definitions to use for reasoning:\n- Under POSIX, a file descriptor refers to an open file description that maintains a single file offset. The system call `lseek()` updates this file offset.\n- When a file is opened with the append flag `O_APPEND`, each `write()` to a regular file is required to occur at the end-of-file (EOF) as it exists at the time of the write, and this placement is performed atomically. This behavior is defined independently of any previously set file offset.\n- The `write()` system call updates the open file description’s file offset to the byte position immediately following the data written.\n\nScenario:\n- A regular file $F$ initially has size $S = 1000$ bytes.\n- The program opens $F$ with `O_WRONLY | O_APPEND` and obtains a single file descriptor $f$ referring to one open file description.\n- It performs the following steps in a single process, without any concurrent writers:\n  1. `lseek(f, 0, SEEK_SET)`.\n  2. `write(f, \"ABC\", 3)`, where the string `\"ABC\"` has length $k = 3$ bytes.\n  3. `lseek(f, 500, SEEK_SET)`.\n  4. `write(f, \"DEF\", 3)`, again writing $k = 3$ bytes.\n  5. `lseek(f, S + 200, SEEK_SET)` (that is, `lseek(f, 1200, SEEK_SET)`).\n  6. `write(f, \"GHI\", 3)`, again writing $k = 3$ bytes.\n\nWhich of the following statements correctly describes where the data are placed by the three `write` operations, how the file size evolves, and what the final file offset is after step $6$?\n\nA. With `O_APPEND`, the kernel computes the current end-of-file for each `write()` and appends atomically; `lseek()` changes the stored offset but does not affect where `write()` places data. After the three writes, the file size is $S + 3k = 1009$ and the file offset is $S + 3k = 1009$. No holes are created.\n\nB. Because `lseek()` precedes each `write()`, the data are placed at those offsets; the first write at $0$, the second at $500$, and the third at $1200$. The file size becomes $\\max(S, 1200 + k) = 1203$, holes appear between $S$ and $1200$, and the final file offset equals $1200 + k = 1203$.\n\nC. With `O_APPEND`, each `write()` appends, but the file offset after each `write()` remains at the value set by the most recent `lseek()`; therefore, after the final `write()`, it remains at $S + 200 = 1200$.\n\nD. Seeking beyond end-of-file disables `O_APPEND` for that file descriptor, so only the first write appends; the second and third writes occur at $500$ and $1200$, respectively.\n\nE. Under `O_APPEND`, writes append; however, seeking beyond end-of-file before a write creates a hole that is later filled by the append, increasing the file size to $1200 + k + 2k = 1209$, and the final offset equals $1200 + 3k = 1209$.",
            "solution": "The key to this problem lies in the POSIX-guaranteed behavior of the `O_APPEND` flag. When a file is opened with `O_APPEND`, the kernel ensures that every `write()` operation is atomic and places data at the current end-of-file. This behavior overrides any file offset set by a preceding `lseek()` call. Let's trace the file size and offset through the sequence of operations.\n\n- **Initial State:** File size is 1000 bytes. The file is opened with `O_APPEND`.\n\n- **Step 1: `lseek(f, 0, SEEK_SET)`**\n  - The file offset is set to 0. File size remains 1000.\n\n- **Step 2: `write(f, \"ABC\", 3)`**\n  - Due to `O_APPEND`, the write occurs at the current end-of-file (offset 1000), not the offset set by `lseek()` (0).\n  - Data \"ABC\" is written at offsets 1000-1002.\n  - File size becomes $1000 + 3 = 1003$.\n  - The `write()` call updates the file offset to the new end-of-file: 1003.\n\n- **Step 3: `lseek(f, 500, SEEK_SET)`**\n  - The file offset is set to 500. File size remains 1003.\n\n- **Step 4: `write(f, \"DEF\", 3)`**\n  - Again, `O_APPEND` forces the write to the current end-of-file (offset 1003).\n  - Data \"DEF\" is written at offsets 1003-1005.\n  - File size becomes $1003 + 3 = 1006$.\n  - The file offset is updated to the new end-of-file: 1006.\n\n- **Step 5: `lseek(f, 1200, SEEK_SET)`**\n  - The file offset is set to 1200. This is a valid operation, but it does not by itself change the file size. File size remains 1006.\n\n- **Step 6: `write(f, \"GHI\", 3)`**\n  - `O_APPEND` once again directs the write to the end-of-file (offset 1006).\n  - Data \"GHI\" is written at offsets 1006-1008.\n  - Final file size becomes $1006 + 3 = 1009$.\n  - Final file offset is updated to the new end-of-file: 1009.\n\n**Conclusion:**\nAll `write()` operations appended to the file, and intervening `lseek()` calls had no effect on the data placement. No file holes were created. The final file size is 1009 bytes, and the final file offset is also 1009. This corresponds exactly to the description in option A.",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}