{
    "hands_on_practices": [
        {
            "introduction": "Understanding an acyclic-graph directory system begins with its fundamental bookkeeping. The link count, a piece of metadata often stored in a field like `$st\\_nlink$`, is critical for managing the lifecycle of files and directories. This exercise challenges you to manually trace the `$st\\_nlink$` values for several objects through a sequence of common filesystem operations, reinforcing the specific rules that govern a DAG structure and building your intuition for how the system maintains its integrity .",
            "id": "3619462",
            "problem": "An operating system supports a directory namespace that is a Directed Acyclic Graph (DAG), allowing multiple hard links to a directory as long as no cycles are formed. The file status field $st\\_nlink$ reports the number of hard links to an inode. The following model is used:\n- For a non-directory file $F$, $st\\_nlink(F)$ is the number of directory entries that refer to $F$.\n- For a directory $D$, $st\\_nlink(D)$ counts every directory entry that refers to $D$, including $D$'s own dot entry `.`, any parent directories’ entries that name $D$, and each immediate subdirectory’s dot-dot entry `..` that resolves to $D$.\n- When a new subdirectory $C$ is created inside a parent $P$, the new directory has $st\\_nlink(C) = 2$ (for its `.` and the parent directory entry naming it), and $st\\_nlink(P)$ increases by $1$ because $C$’s `..` entry resolves to $P$.\n- When an additional hard link to an existing directory $D$ is created in some other directory $Q$ (which does not make $D$’s `..` resolve to $Q$), $st\\_nlink(D)$ increases by $1$, and $st\\_nlink(Q)$ does not change.\n- Unlinking a name of a non-directory decrements the target’s $st\\_nlink$ by $1$. Removing an empty subdirectory via $rmdir$ decrements the parent’s $st\\_nlink$ by $1$ and eliminates the child directory.\n\nAssume an initially empty filesystem except for the root directory. The following sequence of operations is performed, and all operations are valid with respect to acyclicity:\n- Step $1$: Create directories $/$P and $/$Q under the root.\n- Step $2$: In directory $/$P, create a regular file named $f$.\n- Step $3$: Create a hard link to $/$P$/f$ at path $/$Q$/g$.\n- Step $4$: In directory $/$P, create a subdirectory named $C$.\n- Step $5$: In directory $/$Q, create a subdirectory named $D$.\n- Step $6$: In directory $/$Q, create an additional hard link named $C\\_alias$ that refers to the existing directory $/$P$/$C$ (this does not change which parent the `..` entry in `/P/C` resolves to).\n- Step $7$: In directory $/$P$/$C, create a subdirectory named $E$.\n- Step $8$: Unlink $/$P$/$f$.\n- Step $9$: Unlink $/$Q$/$C\\_alias$ (remove the extra link to $/$P$/$C$).\n- Step $10$: Remove the empty subdirectory $/$P$/$C$/$E$ via $rmdir$.\n\nWhich of the following tuples gives the final values of $\\big(st\\_nlink(/P),\\, st\\_nlink(/Q),\\, st\\_nlink(/P/C),\\, st\\_nlink(/Q/D),\\, st\\_nlink(\\text{inode of }f)\\big)$ after Step $10$?\n\nA. $\\;(3,\\;3,\\;2,\\;2,\\;1)$\nB. $\\;(3,\\;4,\\;3,\\;2,\\;1)$\nC. $\\;(2,\\;3,\\;2,\\;2,\\;1)$\nD. $\\;(3,\\;3,\\;3,\\;2,\\;2)$",
            "solution": "The problem statement is first validated for correctness and solvability.\n\n### Step 1: Extract Givens\n- The directory system is a Directed Acyclic Graph (DAG).\n- The `st_nlink` field represents the link count of an inode.\n- For a non-directory file $F$, $st\\_nlink(F)$ is the number of directory entries pointing to it.\n- For a directory $D$, $st\\_nlink(D)$ is the sum of:\n  1. Its own `.` entry.\n  2. Any parent directory entries naming $D$.\n  3. The `..` entry from each immediate subdirectory.\n- Creation of a subdirectory $C$ in parent $P$: $st\\_nlink(C)$ becomes $2$, and $st\\_nlink(P)$ increases by $1$.\n- Creation of an additional hard link to a directory $D$ in directory $Q$: $st\\_nlink(D)$ increases by $1$; $st\\_nlink(Q)$ is unchanged.\n- Unlinking a non-directory name: decrements the target inode's $st\\_nlink$ by $1$.\n- Removing an empty subdirectory (`rmdir`): decrements the parent's $st\\_nlink$ by $1$.\n- Initial condition: Filesystem contains only the root directory `/`.\n- Sequence of operations:\n  1. Create directories `/P` and `/Q`.\n  2. Create regular file `/P/f`.\n  3. Create hard link `/Q/g` to `/P/f`.\n  4. Create subdirectory `/P/C`.\n  5. Create subdirectory `/Q/D`.\n  6. Create additional hard link `/Q/C_alias` to `/P/C`.\n  7. Create subdirectory `/P/C/E`.\n  8. Unlink `/P/f`.\n  9. Unlink `/Q/C_alias`.\n  10. `rmdir /P/C/E`.\n- The question asks for the final values of $\\big(st\\_nlink(/P),\\, st\\_nlink(/Q),\\, st\\_nlink(/P/C),\\, st\\_nlink(/Q/D),\\, st\\_nlink(\\text{inode of }f)\\big)$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded within the domain of computer science, specifically operating system file system design. The model provided for `st_nlink` accounting in a DAG-based directory system, while not universally implemented, is a logically consistent and well-defined concept. The problem is well-posed, with a clear initial state, a deterministic sequence of operations, and a specific question. The language is objective and unambiguous. All terms are sufficiently defined by the provided rules. The problem is therefore valid.\n\n### Step 3: Verdict and Action\nThe problem is valid. A step-by-step derivation of the solution will be performed.\n\n### Solution Derivation\nWe will track the `st_nlink` values for the five specified inodes through the sequence of ten operations. Let the tuple of interest be $\\big(n_P, n_Q, n_C, n_D, n_f\\big)$, representing $\\big(st\\_nlink(/P),\\, st\\_nlink(/Q),\\, st\\_nlink(/P/C),\\, st\\_nlink(/Q/D),\\, st\\_nlink(\\text{inode of }f)\\big)$.\n\n**Initial State:** The filesystem is empty except for the root. The inodes for `/P`, `/Q`, `/P/C`, `/Q/D`, and `f` do not exist. Their link counts are effectively $0$.\n\n**Step 1:** Create directories `/P` and `/Q`.\n- A new directory `/P` is created. Per the rule, its link count is $2$. $n_P = 2$.\n- A new directory `/Q` is created. Per the rule, its link count is $2$. $n_Q = 2$.\n- Tuple: $\\big(2, 2, \\text{N/A}, \\text{N/A}, \\text{N/A}\\big)$.\n\n**Step 2:** Create a regular file `/P/f`.\n- An inode for file `f` is created with one directory entry, `/P/f`. Its link count is $1$. $n_f = 1$.\n- Tuple: $\\big(2, 2, \\text{N/A}, \\text{N/A}, 1\\big)$.\n\n**Step 3:** Create a hard link to `/P/f` at path `/Q/g`.\n- A second directory entry, `/Q/g`, now points to the inode of `f`. Its link count increases by $1$.\n- $n_f$ becomes $1+1 = 2$.\n- Tuple: $\\big(2, 2, \\text{N/A}, \\text{N/A}, 2\\big)$.\n\n**Step 4:** Create a subdirectory `/P/C`.\n- A new directory `/P/C` is created. Its link count is $2$. $n_C = 2$.\n- The parent `/P` gains a `..` link from `/P/C`. Its link count increases by $1$.\n- $n_P$ becomes $2+1 = 3$.\n- Tuple: $\\big(3, 2, 2, \\text{N/A}, 2\\big)$.\n\n**Step 5:** Create a subdirectory `/Q/D`.\n- A new directory `/Q/D` is created. Its link count is $2$. $n_D = 2$.\n- The parent `/Q` gains a `..` link from `/Q/D`. Its link count increases by $1$.\n- $n_Q$ becomes $2+1 = 3$.\n- Tuple: $\\big(3, 3, 2, 2, 2\\big)$.\n\n**Step 6:** Create an additional hard link `/Q/C_alias` to `/P/C`.\n- The target directory `/P/C` gains a new name. Its link count increases by $1$.\n- $n_C$ becomes $2+1 = 3$.\n- The link count of `/Q` is unchanged as per the rule.\n- Tuple: $\\big(3, 3, 3, 2, 2\\big)$.\n\n**Step 7:** Create a subdirectory `/P/C/E`.\n- The parent directory `/P/C` gains a `..` link from `/P/C/E`. Its link count increases by $1$.\n- $n_C$ becomes $3+1 = 4$.\n- Tuple: $\\big(3, 3, 4, 2, 2\\big)$.\n\n**Step 8:** Unlink `/P/f`.\n- The directory entry `/P/f` is removed. The link count of the target inode `f` decreases by $1$.\n- $n_f$ becomes $2-1 = 1$.\n- Tuple: $\\big(3, 3, 4, 2, 1\\big)$.\n\n**Step 9:** Unlink `/Q/C_alias`.\n- The additional hard link to the directory `/P/C` is removed. Symmetrically to its creation, this decrements the target directory's link count by $1$.\n- $n_C$ becomes $4-1 = 3$.\n- Tuple: $\\big(3, 3, 3, 2, 1\\big)$.\n\n**Step 10:** Remove the empty subdirectory `/P/C/E` via `rmdir`.\n- The parent of `/P/C/E` is `/P/C`. Removing `/P/C/E` removes the `..` link from `/P/C/E` that pointed to `/P/C`. The parent's link count decreases by $1$.\n- $n_C$ becomes $3-1 = 2$.\n- Final Tuple: $\\big(3, 3, 2, 2, 1\\big)$.\n\nThe final derived values are $st\\_nlink(/P) = 3$, $st\\_nlink(/Q) = 3$, $st\\_nlink(/P/C) = 2$, $st\\_nlink(/Q/D) = 2$, and $st\\_nlink(\\text{inode of }f) = 1$.\n\n### Option-by-Option Analysis\n\n**A. $\\;(3,\\;3,\\;2,\\;2,\\;1)$**\nThis tuple matches the final values derived from the step-by-step analysis.\n- $st\\_nlink(/P) = 3$: Correct. Links are its entry `P` in `/`, its own `.` entry, and the `..` entry from its child `/P/C`.\n- $st\\_nlink(/Q) = 3$: Correct. Links are its entry `Q` in `/`, its own `.` entry, and the `..` entry from its child `/Q/D`.\n- $st\\_nlink(/P/C) = 2$: Correct. Links are its entry `C` in `/P` and its own `.` entry. The link from `C_alias` (Step 6) was removed (Step 9), and the `..` link from `/P/C/E` (Step 7) was removed (Step 10).\n- $st\\_nlink(/Q/D) = 2$: Correct. Links are its entry `D` in `/Q` and its own `.` entry.\n- $st\\_nlink(\\text{inode of }f) = 1$: Correct. The entry `/P/f` was removed (Step 8), leaving only the entry `/Q/g`.\n**Verdict: Correct.**\n\n**B. $\\;(3,\\;4,\\;3,\\;2,\\;1)$**\n- The value for $st\\_nlink(/Q)$ is $4$, which is incorrect. The derived value is $3$.\n- The value for $st\\_nlink(/P/C)$ is $3$, which is incorrect. The derived value is $2$. This would be the state after Step 9 but before Step 10.\n**Verdict: Incorrect.**\n\n**C. $\\;(2,\\;3,\\;2,\\;2,\\;1)$**\n- The value for $st\\_nlink(/P)$ is $2$, which is incorrect. The derived value is $3$. Its link count was incremented to $3$ in Step 4 and was not subsequently decremented.\n**Verdict: Incorrect.**\n\n**D. $\\;(3,\\;3,\\;3,\\;2,\\;2)$**\n- The value for $st\\_nlink(/P/C)$ is $3$, which is incorrect, as explained for option B.\n- The value for $st\\_nlink(\\text{inode of }f)$ is $2$, which is incorrect. The derived value is $1$. This would be the state before the unlink operation in Step 8.\n**Verdict: Incorrect.**",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "While tracking metadata is essential, understanding the high-level semantics of operations is equally important, especially for complex actions like `rename`. System calls must be atomic, ensuring that the filesystem is never left in an inconsistent state. This thought experiment probes a subtle edge case to test your ability to deduce the correct behavior based on the core principles of atomicity and logical consistency, rather than implementation-specific shortcuts .",
            "id": "3619396",
            "problem": "In a directory system that is formally modeled as a Directed Acyclic Graph (DAG), consider the following scenario: a regular file with inode $i_f$ currently has two hard-link directory entries, namely $D_1/A$ and $D_2/B$, where $D_1$ and $D_2$ are distinct parent directories. The system enforces the following well-tested facts and core definitions:\n\n- A directory entry maps a name to exactly one inode; an inode uniquely identifies a file’s metadata and data.\n- A hard link is a directory entry to a regular file’s inode; hard links to directories are prohibited to preserve acyclicity.\n- The link count $\\ell(i)$ is the number of directory entries that reference inode $i$.\n- The rename operation is defined to be atomic and linearizable: either the requested name change happens entirely, or no change occurs; on failure, the file system’s observable state cannot reflect a partial change.\n- The directory structure must remain acyclic under all operations.\n\nA user issues a rename request to move $D_1/A$ to $D_2/B$, but $D_2/B$ already exists and is a hard link to the same inode $i_f$. The operation crosses parents (from $D_1$ to $D_2$) and must preserve acyclicity. Assume Portable Operating System Interface (POSIX) style expectations about atomic rename and link counts, but do not assume any special-case shortcut behavior beyond what must follow from the facts above.\n\nWhich outcome best reflects the principle of least surprise for the user, while remaining consistent with the above invariants and definitions?\n\nA. Return an error indicating that the destination exists, leave the directory graph unchanged, and preserve $\\ell(i_f)$.\n\nB. Return success and perform no action because both paths resolve to $i_f$, thereby leaving $D_1/A$ and $D_2/B$ intact and preserving $\\ell(i_f)$.\n\nC. Return success and atomically remove only the source name $D_1/A$, leaving $D_2/B$ unchanged; update affected metadata as required, and decrement $\\ell(i_f)$ by $1$.\n\nD. Return success and atomically remove $D_2/B$ then re-create $D_2/B$ by moving $D_1/A$; the final state has $D_2/B$ present and $D_1/A$ absent, but $\\ell(i_f)$ remains unchanged because the destination was replaced rather than the source removed.",
            "solution": "The problem statement is first validated for correctness and solvability.\n\n### Step 1: Extract Givens\n- The file system's directory structure is a Directed Acyclic Graph (DAG).\n- A regular file exists, identified by inode $i_f$.\n- Two distinct directory entries, $D_1/A$ and $D_2/B$, are hard links to inode $i_f$. $D_1$ and $D_2$ are distinct directories.\n- A directory entry maps a name to exactly one inode.\n- An inode uniquely represents file metadata and data.\n- Hard links are directory entries to regular file inodes. Hard links to directories are prohibited.\n- The link count, $\\ell(i)$, is the number of directory entries referencing inode $i$.\n- The `rename` operation is atomic and linearizable.\n- The directory structure must remain acyclic.\n- A user requests the operation to rename $D_1/A$ to $D_2/B$.\n- The destination $D_2/B$ already exists and points to the same inode $i_f$.\n- The operation involves different parent directories ($D_1$ and $D_2$).\n- The analysis should assume Portable Operating System Interface (POSIX) style expectations for atomicity and link counts.\n- The analysis should not assume special-case shortcut behaviors beyond what logically follows from the given facts.\n- The question is to identify the outcome that is consistent with these rules and best reflects the \"principle of least surprise\".\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded in the domain of operating systems and file system design. The concepts of inodes, hard links, link counts, and atomic `rename` are fundamental and well-defined by the POSIX standard. The scenario describes a specific, realistic edge case for the `rename` system call. The problem is well-posed, providing a clear set of rules and asking for the logical outcome. The \"principle of least surprise\" is a standard heuristic in API design, guiding towards predictable and consistent behavior. The problem is therefore valid.\n\n### Step 3: Verdict and Action\nThe problem is valid. A step-by-step derivation of the solution will be performed.\n\n### Solution Derivation\nThe problem requires determining the outcome of the request `rename(D1/A, D2/B)`, where both paths resolve to the same inode, $i_f$. The core principles to apply are the atomicity of `rename` and its fundamental purpose.\n\nThe `rename(source, destination)` operation is intended to atomically change the name of the `source` file to `destination`. If `destination` already exists, the POSIX-style expectation is that `destination` is removed and replaced by `source`. This entire process must appear as a single, instantaneous event.\n\nLet's model the general atomic procedure for `rename(src, dst)` when `dst` exists:\n1. The system identifies the inode for `src`, let's call it $i_{src}$.\n2. The system identifies the inode for `dst`, let's call it $i_{dst}$.\n3. The system must atomically execute a transaction that achieves the following state change:\n    a. The directory entry for `dst` is removed. This would cause a decrement of $\\ell(i_{dst})$.\n    b. A new directory entry for `dst` is created, pointing to $i_{src}$. This would cause an increment of $\\ell(i_{src})$.\n    c. The directory entry for `src` is removed. This would cause a decrement of $\\ell(i_{src})$.\n\nIn our specific case, `src` is $D_1/A$ and `dst` is $D_2/B$. We are given that they both point to the same inode $i_f$. Therefore, $i_{src} = i_{dst} = i_f$.\n\nLet's trace the effect of this general procedure on the link count $\\ell(i_f)$, starting from an initial count of $k$. Since $D_1/A$ and $D_2/B$ are two distinct hard links, we know $k \\ge 2$.\n\n-   **Step 3a (conceptual)**: The entry $D_2/B$ pointing to $i_f$ is removed. The link count $\\ell(i_f)$ would change from $k$ to $k-1$.\n-   **Step 3b (conceptual)**: A new entry $D_2/B$ is created to point to $i_f$. The link count $\\ell(i_f)$ would change from $k-1$ back to $k$.\n-   **Step 3c (conceptual)**: The entry $D_1/A$ pointing to $i_f$ is removed. The link count $\\ell(i_f)$ would change from $k$ to $k-1$.\n\nThe entire sequence must be atomic, meaning the system transitions from the initial state directly to the final state. The net result of this logical sequence is:\n- The final link count is $\\ell(i_f) = k-1$.\n- The directory entry $D_1/A$ is removed.\n- The directory entry $D_2/B$ is effectively unchanged (it is removed and immediately replaced with a link to the exact same inode).\n\nThe derived outcome corresponds to removing the source link $D_1/A$ while the destination link $D_2/B$ remains. The operation should succeed, as no constraints are violated.\n\n### Option-by-Option Analysis\n\n-   **A. Return an error indicating that the destination exists, leave the directory graph unchanged, and preserve $\\ell(i_f)$.**\n    This is **Incorrect**. The standard behavior of `rename` when the destination is an existing non-directory file is to replace it, not to return an error like `EEXIST`. This outcome would violate the principle of least surprise for users accustomed to `rename`'s replacement semantics.\n\n-   **B. Return success and perform no action because both paths resolve to $i_f$, thereby leaving $D_1/A$ and $D_2/B$ intact and preserving $\\ell(i_f)$.**\n    This is **Incorrect**. While this behavior corresponds to a special-case optimization documented in the POSIX standard, the problem instructs us not to assume such shortcuts and instead derive the outcome from the fundamental definitions. From a user's perspective of the `mv` command (which uses `rename`), a \"move\" operation that does not remove the source file is highly surprising.\n\n-   **C. Return success and atomically remove only the source name $D_1/A$, leaving $D_2/B$ unchanged; update affected metadata as required, and decrement $\\ell(i_f)$ by $1$.**\n    This is **Correct**. This outcome is the logical consequence of applying the general principle of atomic `rename`-by-replacement. The net effect of the atomic sequence of unlinking the destination, relinking to the source inode, and unlinking the source is simply the removal of the source link, as the destination link is effectively restored. This decrements the link count $\\ell(i_f)$ by $1$. This behavior is also consistent with the semantics of \"moving\" a file, where the source name disappears.\n\n-   **D. Return success and atomically remove $D_2/B$ then re-create $D_2/B$ by moving $D_1/A$; the final state has $D_2/B$ present and $D_1/A$ absent, but $\\ell(i_f)$ remains unchanged because the destination was replaced rather than the source removed.**\n    This is **Incorrect**. The description of the final state (`D_1/A` absent) correctly implies that a link to inode $i_f$ has been removed. The claim that $\\ell(i_f)$ remains unchanged is a direct contradiction of the definition of link count. If one of the $k$ links is removed and no new link to $i_f$ is created elsewhere, the link count must become $k-1$. Therefore, this option is internally inconsistent.",
            "answer": "$$\\boxed{C}$$"
        },
        {
            "introduction": "The ultimate test of understanding a complex system is to build a simplified version of it. This capstone coding practice guides you through implementing a complete in-memory simulator for an acyclic-graph directory system. You will translate the theoretical concepts of nodes, edges, cycle detection, and reference-counted garbage collection into a tangible, working program, providing a robust and practical foundation in the topic .",
            "id": "3619453",
            "problem": "You are to design and implement a self-contained teaching simulator for a directory system modeled as a Directed Acyclic Graph (DAG). The simulator must operate entirely in memory and must rigorously enforce acyclicity. The model should adhere to the following first-principles definitions and rules that originate from standard operating system directory abstractions and well-established graph theory.\n\nCore definitions that the simulator must embody:\n- A directory system is represented as a directed graph $G = (V, E)$, where $V$ is a finite set of nodes and $E \\subseteq V \\times V$ is a set of directed edges.\n- Each node $v \\in V$ represents a filesystem object with a type: either a directory or a file. Files have no outgoing edges. Directories may have outgoing edges to any type of node. Each outgoing edge from a directory is labeled by a string name. Names within a single directory must be unique.\n- The graph must be acyclic. A cycle is a sequence of nodes $(v_0, v_1, \\dots, v_k)$ with $k \\geq 1$ such that $(v_i, v_{i+1}) \\in E$ for all $i \\in \\{0, 1, \\dots, k-1\\}$ and $(v_k, v_0) \\in E$. Therefore, adding any edge that would make a parent node reachable from its prospective child must be refused.\n- Each node $v$ maintains an incoming degree (also called reference count), denoted $\\mathrm{in}(v) \\in \\mathbb{Z}_{\\ge 0}$, equal to the number of directory entries that refer to $v$. The root directory is a distinguished node with identifier $0$ and is never garbage-collected.\n- Garbage collection rule: when an edge is removed and a node’s incoming degree becomes $0$ (and the node is not the root), that node is deleted. If that node is a directory, every outgoing edge from it is removed and the reference counts of its children are decremented accordingly; this may cascade recursively.\n\nYour simulator must implement the following commands with explicit error states:\n- link$(p, c, s)$: Add a directed edge from parent node with identifier $p$ (which must be a directory) to child node with identifier $c$ and assign it the name string $s$ within $p$.\n  - Return $0$ on success.\n  - Return $-1$ if either $p$ or $c$ does not refer to a valid existing node or if $p$ is not a directory.\n  - Return $-2$ if $s$ is already bound in $p$ to a different child node.\n  - Return $-3$ if an edge already exists from $p$ to $c$ with the same name $s$.\n  - Return $-4$ if adding the edge would introduce a cycle (equivalently, if $p$ is reachable from $c$ before the addition).\n- unlink$(p, s)$: Remove the named edge with string $s$ from the directory node $p$ to its child. After removal, perform garbage collection by the rule above.\n  - Return $0$ on success.\n  - Return $-5$ if there is no such named edge from $p$.\n- rename$(p, s_{\\text{old}}, s_{\\text{new}})$: Change the name of the existing edge in directory node $p$ from $s_{\\text{old}}$ to $s_{\\text{new}}$.\n  - Return $0$ on success.\n  - Return $-6$ if $s_{\\text{old}}$ does not exist in $p$.\n  - Return $-7$ if $s_{\\text{new}}$ is already in use in $p$ for any edge.\n\nThe simulator must also implement a read-only show operation that computes invariant metrics of the current graph state:\n- Let $N$ be the total number of live nodes.\n- Let $E$ be the total number of live directed edges.\n- Let $B$ be a boolean indicator of acyclicity, where $B = 1$ if and only if the current graph has no directed cycles, and $B = 0$ otherwise.\n- Let $S$ be an integer checksum defined as $S = \\sum_{(p \\to c, s) \\in E} \\left( |s| + p + c \\right)$, where $|s|$ denotes the length of the string $s$, and the sum ranges over all directory edges $(p \\to c)$ labeled by the name $s$.\n\nAlgorithmic facts that must guide your design:\n- Reachability is defined by the existence of a directed path: node $u$ reaches node $v$ if there exists a sequence $u = v_0, v_1, \\dots, v_k = v$ with $k \\ge 0$ and $(v_i, v_{i+1}) \\in E$ for all $i$. Refusing cycles in link$(p,c,s)$ is achieved by checking whether $p$ is reachable from $c$ in the current $G$ before adding $(p \\to c)$.\n- A standard depth-first search (DFS) with color marking or visited sets is suitable to determine reachability and detect cycles, and thus to evaluate $B$.\n\nYour program must:\n- Construct fresh DAG instances for each test case below.\n- Provide internal helper operations to create nodes of type directory and file as needed for the test sequences. The root directory with identifier $0$ must exist in every DAG and is a directory.\n- Execute the following test suite, each test executed on a new DAG instance:\n  1. Test case $1$ (happy path): Create directories $A$ and $B$, and a file $F$. Execute link$(0, A, \\text{\"home\"})$, link$(0, B, \\text{\"etc\"})$, link$(A, F, \\text{\"notes\"})$. Then compute show metrics and return the list $[N, E, B, S]$.\n  2. Test case $2$ (cycle refusal): Create directory $A$. Execute link$(0, A, \\text{\"home\"})$. Attempt link$(A, 0, \\text{\"back\"})$. Return the integer error code produced by the attempt (expected to be a negative integer indicating refusal due to cycle risk).\n  3. Test case $3$ (rename collision): Create files $F$ and $G$. Execute link$(0, F, \\text{\"x\"})$, link$(0, G, \\text{\"y\"})$. Attempt rename$(0, \\text{\"x\"}, \\text{\"y\"})$. Return the integer error code produced by the attempt (expected to be a negative integer signaling target name collision).\n  4. Test case $4$ (unlink garbage collection): Create directory $A$ and file $F$. Execute link$(0, A, \\text{\"home\"})$, link$(A, F, \\text{\"notes\"})$. Execute unlink$(0, \\text{\"home\"})$. Return the integer node count $N$ after garbage collection completes.\n  5. Test case $5$ (multi-parent linking and unlinking): Create directories $A$ and $B$. Execute link$(0, A, \\text{\"home\"})$, link$(0, B, \\text{\"etc\"})$, link$(B, A, \\text{\"alias\"})$. Execute unlink$(B, \\text{\"alias\"})$. Return the integer incoming degree $\\mathrm{in}(A)$ after the unlink.\n\nFinal output format specification:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test result occupies a single position in the list. Use a four-element list for test case $1$, and single integers for test cases $2$, $3$, $4$, and $5$.\n- Concretely, the output must have the exact shape $[[N,E,B,S],r_2,r_3,r_4,r_5]$ where $r_2$, $r_3$, $r_4$, and $r_5$ are integers as defined above. No other output is permitted.\n- There are no physical units, angles, or percentages involved in this task; all answers are pure integers or a list of integers, and all numbers must be reported in plain integer form.",
            "solution": "The problem requires the design and implementation of a simulator for an acyclic-graph directory system. The solution must be grounded in formal definitions from graph theory and operating systems principles. The core of the solution lies in modeling the filesystem as a Directed Acyclic Graph (DAG) $G = (V, E)$ and correctly implementing state-modifying operations (`link`, `unlink`, `rename`) that preserve the integrity of this structure, particularly its acyclicity and reference-counted garbage collection.\n\n### Data Structure Design\n\nThe graph $G$ is represented by a collection of nodes and edges. To facilitate efficient access and management, a central `DAG` structure encapsulates the entire state.\n\n1.  **Node Representation**: Each node $v \\in V$ is represented by a `Node` structure. This structure contains:\n    *   An integer identifier `id`, which is a unique key for the node.\n    *   A `type` enumerator, which can be `NODE_DIRECTORY` or `NODE_FILE`.\n    *   An integer `in_degree`, representing the reference count $\\mathrm{in}(v)$. This count is the number of incoming edges, corresponding to the number of parent directories linking to this node.\n    *   A boolean flag `is_active` to logically mark a node as 'live' or 'deleted' by the garbage collector.\n    *   For `NODE_DIRECTORY` types, a pointer to a linked list of outgoing edges. A file node, by definition, has no outgoing edges.\n\n2.  **Edge Representation**: Each directed edge $(p, c) \\in E$ with a name label $s$ is represented by an `Edge` structure. This structure contains:\n    *   A character array `name` to store the string label $s$.\n    *   An integer `child_id` which stores the identifier of the child node $c$.\n    *   A `next` pointer, forming a singly linked list of edges originating from a common parent directory $p$.\n\n3.  **Graph Container**: A `DAG` structure aggregates the components of the graph:\n    *   An array `nodes` of `Node` structures, indexed by node `id`, providing $O(1)$ access to any node given its identifier.\n    *   An integer `next_node_id` to ensure unique identifier assignment for newly created nodes.\n\nThe simulation begins with a single, active, root directory at `id = 0`, whose `in_degree` is conceptually non-zero and which is exempt from garbage collection.\n\n### Algorithmic Implementation\n\n**1. Acyclicity Enforcement via Reachability Check**\n\nThe `link(p, c, s)` operation must guarantee that adding an edge from parent $p$ to child $c$ does not introduce a cycle. A cycle would be created if and only if there is already a path from $c$ to $p$ in the graph. Therefore, before adding the edge $(p, c)$, we must perform a reachability check.\n\nThe reachability query \"Is node $p$ reachable from node $c$?\" is resolved using an iterative Depth-First Search (DFS). The algorithm is as follows:\n*   Initialize a boolean array `visited` of size $|V|$, with all entries set to false.\n*   Initialize a stack and push the starting node identifier, $c$.\n*   Mark $c$ as visited.\n*   While the stack is not empty:\n    1.  Pop a node identifier, $u$.\n    2.  If $u$ is the target node $p$, then a path exists. Return `true`.\n    3.  For each child $v$ of node $u$:\n        *   If $v$ has not been visited, mark it as visited and push it onto the stack.\n*   If the loop completes without finding $p$, no path exists. Return `false`.\n\nIf this check returns `true`, the `link` operation is aborted with error code $-4$.\n\n**2. Garbage Collection**\n\nGarbage collection is based on reference counting. A node is eligible for collection if its `in_degree` drops to $0$ (and it is not the root node). This process is initiated by the `unlink` operation.\n\nThe `collect_garbage(v_id)` procedure is recursive:\n1.  Retrieve the node $v$ corresponding to `v_id`.\n2.  The base cases for terminating recursion are: if $v$ is already inactive, if $v$ is the root node (ID $0$), or if $\\mathrm{in}(v) > 0$.\n3.  If no base case is met, mark node $v$ as inactive (`is_active = false`).\n4.  If $v$ is a directory, iterate through all its outgoing edges $(v, w)$. For each such edge:\n    *   Decrement the `in_degree` of the child node $w$.\n    *   Recursively call `collect_garbage(w_id)`.\n    *   The memory allocated for the `Edge` structure itself is freed.\n5.  After iterating, the directory's edge list is cleared.\n\nThis cascading deletion correctly reclaims all unreachable subgraphs.\n\n**3. Command Implementation**\n\nThe user-facing commands are implemented as functions that manipulate the `DAG` data structure, using the above algorithms to maintain consistency.\n\n*   `link(p, c, s)`: First, it validates the existence and types of nodes $p$ and $c$. It then iterates through the edge list of $p$ to check for name collisions (error $-2$) or duplicate edges (error $-3$). Subsequently, it performs the crucial acyclicity check. If all checks pass, it allocates a new `Edge`, prepends it to the parent's edge list, and increments the child's `in_degree`.\n\n*   `unlink(p, s)`: It validates the parent node $p$ and searches its edge list for an edge named $s$. If not found, it returns error $-5$. If found, the edge is removed from the linked list and its memory is freed. The `in_degree` of the corresponding child is decremented, and `collect_garbage` is called on the child, potentially triggering a cascade.\n\n*   `rename(p, s_old, s_new)`: It first checks if the new name $s_{\\text{new}}$ is already in use within directory $p$, returning error $-7$ if so. Then, it searches for the edge named $s_{\\text{old}}$. If found, the name is updated; otherwise, error $-6$ is returned.\n\n**4. `show` Metrics Calculation**\n\nThe `show` operation computes four metrics describing the current state of the graph.\n\n*   $N$ (Total Nodes): Calculated by iterating through the `nodes` array and counting all nodes where `is_active` is true.\n*   $E$ (Total Edges): Calculated by iterating through all active nodes. If a node is a directory, the size of its edge list is added to a running total.\n*   $B$ (Acyclicity): A boolean value determined by a global cycle detection algorithm. A three-color DFS traversal is employed:\n    *   All nodes are initially `WHITE` (unvisited).\n    *   The traversal starts from each `WHITE` node in the graph.\n    *   When visiting a node, it is colored `GRAY` (visiting).\n    *   If the traversal encounters a `GRAY` node, a back edge has been found, indicating a cycle. The function returns $B=0$.\n    *   After all descendants of a node have been visited, the node is colored `BLACK` (finished).\n    *   If the traversal completes for all nodes without finding a cycle, the graph is acyclic, and the function returns $B=1$.\n*   $S$ (Checksum): Calculated by iterating over all edges $(p \\to c, s)$ in the graph and summing the value $|s| + p + c$ for each, where $|s|$ is the length of the string name.\n\nThis comprehensive design ensures that all rules and behaviors specified in the problem statement are rigorously enforced, resulting in a correct and robust simulation.",
            "answer": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_NODES 32\n#define MAX_NAME_LEN 32\n\ntypedef enum { NODE_FILE, NODE_DIRECTORY } NodeType;\n\nstruct Edge;\n\ntypedef struct {\n    int id;\n    NodeType type;\n    int in_degree;\n    bool is_active;\n    struct Edge* edges;\n} Node;\n\ntypedef struct Edge {\n    char name[MAX_NAME_LEN];\n    int child_id;\n    struct Edge* next;\n} Edge;\n\ntypedef struct {\n    Node nodes[MAX_NODES];\n    int node_count;\n} DAG;\n\n// Forward declarations\nvoid collect_garbage(DAG* dag, int node_id);\nbool is_reachable(DAG* dag, int start_id, int end_id);\n\nvoid init_dag(DAG* dag) {\n    dag->node_count = 0;\n    for (int i = 0; i < MAX_NODES; ++i) {\n        dag->nodes[i].is_active = false;\n        dag->nodes[i].edges = NULL;\n    }\n    // Create root directory\n    dag->nodes[0].id = 0;\n    dag->nodes[0].type = NODE_DIRECTORY;\n    dag->nodes[0].in_degree = 1; // Conceptually, never collected\n    dag->nodes[0].is_active = true;\n    dag->node_count = 1;\n}\n\nvoid free_dag_memory(DAG* dag) {\n    for (int i = 0; i < dag->node_count; ++i) {\n        if (dag->nodes[i].type == NODE_DIRECTORY) {\n            Edge* edge = dag->nodes[i].edges;\n            while (edge != NULL) {\n                Edge* temp = edge;\n                edge = edge->next;\n                free(temp);\n            }\n            dag->nodes[i].edges = NULL;\n        }\n    }\n}\n\nint create_node(DAG* dag, NodeType type) {\n    if (dag->node_count >= MAX_NODES) return -1;\n    int id = dag->node_count;\n    dag->nodes[id].id = id;\n    dag->nodes[id].type = type;\n    dag->nodes[id].in_degree = 0;\n    dag->nodes[id].is_active = true;\n    dag->nodes[id].edges = NULL;\n    dag->node_count++;\n    return id;\n}\n\nint link_node(DAG* dag, int p_id, int c_id, const char* s) {\n    if (p_id < 0 || p_id >= dag->node_count || c_id < 0 || c_id >= dag->node_count) return -1;\n    Node* p = &dag->nodes[p_id];\n    Node* c = &dag->nodes[c_id];\n    if (!p->is_active || !c->is_active || p->type != NODE_DIRECTORY) return -1;\n\n    Edge* current_edge = p->edges;\n    while (current_edge != NULL) {\n        if (strcmp(current_edge->name, s) == 0) {\n            return (current_edge->child_id == c_id) ? -3 : -2;\n        }\n        current_edge = current_edge->next;\n    }\n\n    if (p_id == c_id || is_reachable(dag, c_id, p_id)) return -4;\n\n    Edge* new_edge = (Edge*)malloc(sizeof(Edge));\n    if (!new_edge) return -1; // Memory allocation failure\n    strncpy(new_edge->name, s, MAX_NAME_LEN - 1);\n    new_edge->name[MAX_NAME_LEN - 1] = '\\0';\n    new_edge->child_id = c_id;\n    new_edge->next = p->edges;\n    p->edges = new_edge;\n    c->in_degree++;\n    return 0;\n}\n\nint unlink_node(DAG* dag, int p_id, const char* s) {\n    if (p_id < 0 || p_id >= dag->node_count) return -5;\n    Node* p = &dag->nodes[p_id];\n    if (!p->is_active || p->type != NODE_DIRECTORY) return -5;\n\n    Edge* curr = p->edges;\n    Edge* prev = NULL;\n    while (curr != NULL && strcmp(curr->name, s) != 0) {\n        prev = curr;\n        curr = curr->next;\n    }\n\n    if (curr == NULL) return -5;\n\n    if (prev == NULL) p->edges = curr->next;\n    else prev->next = curr->next;\n\n    int child_id = curr->child_id;\n    free(curr);\n\n    Node* child = &dag->nodes[child_id];\n    child->in_degree--;\n    if (child->in_degree == 0 && child->id != 0) {\n        collect_garbage(dag, child_id);\n    }\n    return 0;\n}\n\nint rename_edge(DAG* dag, int p_id, const char* s_old, const char* s_new) {\n    if (p_id < 0 || p_id >= dag->node_count) return -6;\n    Node* p = &dag->nodes[p_id];\n    if (!p->is_active || p->type != NODE_DIRECTORY) return -6;\n\n    Edge* edge_to_rename = NULL;\n    Edge* current_edge = p->edges;\n    while (current_edge != NULL) {\n        if (strcmp(current_edge->name, s_new) == 0) return -7;\n        if (strcmp(current_edge->name, s_old) == 0) edge_to_rename = current_edge;\n        current_edge = current_edge->next;\n    }\n\n    if (edge_to_rename == NULL) return -6;\n\n    strncpy(edge_to_rename->name, s_new, MAX_NAME_LEN - 1);\n    edge_to_rename->name[MAX_NAME_LEN - 1] = '\\0';\n    return 0;\n}\n\nbool is_reachable(DAG* dag, int start_id, int end_id) {\n    bool visited[MAX_NODES] = {false};\n    int stack[MAX_NODES];\n    int top = -1;\n\n    stack[++top] = start_id;\n    visited[start_id] = true;\n\n    while (top >= 0) {\n        int u_id = stack[top--];\n        if (u_id == end_id) return true;\n\n        Node* u_node = &dag->nodes[u_id];\n        if (u_node->is_active && u_node->type == NODE_DIRECTORY) {\n            Edge* edge = u_node->edges;\n            while (edge != NULL) {\n                int v_id = edge->child_id;\n                if (!visited[v_id]) {\n                    visited[v_id] = true;\n                    stack[++top] = v_id;\n                }\n                edge = edge->next;\n            }\n        }\n    }\n    return false;\n}\n\nvoid collect_garbage(DAG* dag, int node_id) {\n    Node* node = &dag->nodes[node_id];\n    if (!node->is_active || node->id == 0 || node->in_degree > 0) return;\n\n    node->is_active = false;\n\n    if (node->type == NODE_DIRECTORY) {\n        Edge* edge = node->edges;\n        while (edge != NULL) {\n            Edge* to_free = edge;\n            int child_id = edge->child_id;\n            dag->nodes[child_id].in_degree--;\n            if (dag->nodes[child_id].in_degree == 0 && child_id != 0) {\n                collect_garbage(dag, child_id);\n            }\n            edge = edge->next;\n            free(to_free);\n        }\n        node->edges = NULL;\n    }\n}\n\ntypedef struct { int n, e, b, s; } ShowMetrics;\nbool is_acyclic_dfs_visit(DAG* dag, int u_id, int* colors);\n\nbool is_acyclic(DAG* dag) {\n    int colors[MAX_NODES] = {0}; // 0: white, 1: gray, 2: black\n    for (int i = 0; i < dag->node_count; ++i) {\n        if (dag->nodes[i].is_active && colors[i] == 0) {\n            if (!is_acyclic_dfs_visit(dag, i, colors)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nbool is_acyclic_dfs_visit(DAG* dag, int u_id, int* colors) {\n    colors[u_id] = 1; // Gray\n    Node* u_node = &dag->nodes[u_id];\n    if (u_node->is_active && u_node->type == NODE_DIRECTORY) {\n        Edge* edge = u_node->edges;\n        while(edge != NULL) {\n            int v_id = edge->child_id;\n            if (dag->nodes[v_id].is_active) {\n                if (colors[v_id] == 1) return false; // Cycle\n                if (colors[v_id] == 0) {\n                    if (!is_acyclic_dfs_visit(dag, v_id, colors)) return false;\n                }\n            }\n            edge = edge->next;\n        }\n    }\n    colors[u_id] = 2; // Black\n    return true;\n}\n\nShowMetrics show(DAG* dag) {\n    ShowMetrics m = {0, 0, 0, 0};\n    for (int i = 0; i < dag->node_count; ++i) {\n        if (dag->nodes[i].is_active) {\n            m.n++;\n            if (dag->nodes[i].type == NODE_DIRECTORY) {\n                Edge* edge = dag->nodes[i].edges;\n                while (edge != NULL) {\n                    m.e++;\n                    m.s += strlen(edge->name) + dag->nodes[i].id + edge->child_id;\n                    edge = edge->next;\n                }\n            }\n        }\n    }\n    m.b = is_acyclic(dag) ? 1 : 0;\n    return m;\n}\n\nint main(void) {\n    int res1[4];\n    int res2, res3, res4, res5;\n\n    // Test case 1\n    {\n        DAG dag;\n        init_dag(&dag);\n        int a_id = create_node(&dag, NODE_DIRECTORY);\n        int b_id = create_node(&dag, NODE_DIRECTORY);\n        int f_id = create_node(&dag, NODE_FILE);\n        link_node(&dag, 0, a_id, \"home\");\n        link_node(&dag, 0, b_id, \"etc\");\n        link_node(&dag, a_id, f_id, \"notes\");\n        ShowMetrics m = show(&dag);\n        res1[0] = m.n; res1[1] = m.e; res1[2] = m.b; res1[3] = m.s;\n        free_dag_memory(&dag);\n    }\n\n    // Test case 2\n    {\n        DAG dag;\n        init_dag(&dag);\n        int a_id = create_node(&dag, NODE_DIRECTORY);\n        link_node(&dag, 0, a_id, \"home\");\n        res2 = link_node(&dag, a_id, 0, \"back\");\n        free_dag_memory(&dag);\n    }\n\n    // Test case 3\n    {\n        DAG dag;\n        init_dag(&dag);\n        int f_id = create_node(&dag, NODE_FILE);\n        int g_id = create_node(&dag, NODE_FILE);\n        link_node(&dag, 0, f_id, \"x\");\n        link_node(&dag, 0, g_id, \"y\");\n        res3 = rename_edge(&dag, 0, \"x\", \"y\");\n        free_dag_memory(&dag);\n    }\n\n    // Test case 4\n    {\n        DAG dag;\n        init_dag(&dag);\n        int a_id = create_node(&dag, NODE_DIRECTORY);\n        int f_id = create_node(&dag, NODE_FILE);\n        link_node(&dag, 0, a_id, \"home\");\n        link_node(&dag, a_id, f_id, \"notes\");\n        unlink_node(&dag, 0, \"home\");\n        ShowMetrics m = show(&dag);\n        res4 = m.n;\n        free_dag_memory(&dag);\n    }\n\n    // Test case 5\n    {\n        DAG dag;\n        init_dag(&dag);\n        int a_id = create_node(&dag, NODE_DIRECTORY);\n        int b_id = create_node(&dag, NODE_DIRECTORY);\n        link_node(&dag, 0, a_id, \"home\");\n        link_node(&dag, 0, b_id, \"etc\");\n        link_node(&dag, b_id, a_id, \"alias\");\n        unlink_node(&dag, b_id, \"alias\");\n        res5 = dag.nodes[a_id].in_degree;\n        free_dag_memory(&dag);\n    }\n\n    printf(\"[[%d,%d,%d,%d],%d,%d,%d,%d]\\n\", res1[0], res1[1], res1[2], res1[3], res2, res3, res4, res5);\n\n    return EXIT_SUCCESS;\n}\n```"
        }
    ]
}