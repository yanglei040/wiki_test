{
    "hands_on_practices": [
        {
            "introduction": "Before building a complex system, we must first master its fundamental rules. This exercise provides a guided walkthrough of link count management in a directory system structured as a Directed Acyclic Graph (DAG). By manually tracing the $st\\_nlink$ values for files and directories through a sequence of common operations, you will develop a concrete understanding of how references are tracked, particularly the subtle rules for directory link counts that distinguish DAGs from simple tree structures .",
            "id": "3619462",
            "problem": "An operating system supports a directory namespace that is a Directed Acyclic Graph (DAG), allowing multiple hard links to a directory as long as no cycles are formed. The file status field $st\\_nlink$ reports the number of hard links to an inode. The following model is used:\n- For a non-directory file $F$, $st\\_nlink(F)$ is the number of directory entries that refer to $F$.\n- For a directory $D$, $st\\_nlink(D)$ counts every directory entry that refers to $D$, including $D$'s own dot entry \"$.$\", any parent directories’ entries that name $D$, and each immediate subdirectory’s dot-dot entry \"$..$\" that resolves to $D$.\n- When a new subdirectory $C$ is created inside a parent $P$, the new directory has $st\\_nlink(C) = 2$ (for its \"$.$\" and the parent directory entry naming it), and $st\\_nlink(P)$ increases by $1$ because $C$’s \"$..$\" entry resolves to $P$.\n- When an additional hard link to an existing directory $D$ is created in some other directory $Q$ (which does not make $D$’s \"$..$\" resolve to $Q$), $st\\_nlink(D)$ increases by $1$, and $st\\_nlink(Q)$ does not change.\n- Unlinking a name of a non-directory decrements the target’s $st\\_nlink$ by $1$. Removing an empty subdirectory via $rmdir$ decrements the parent’s $st\\_nlink$ by $1$ and eliminates the child directory.\n\nAssume an initially empty filesystem except for the root directory. The following sequence of operations is performed, and all operations are valid with respect to acyclicity:\n- Step $1$: Create directories $/$P and $/$Q under the root.\n- Step $2$: In directory $/$P, create a regular file named $f$.\n- Step $3$: Create a hard link to $/$P$/f$ at path $/$Q$/g$.\n- Step $4$: In directory $/$P, create a subdirectory named $C$.\n- Step $5$: In directory $/$Q, create a subdirectory named $D$.\n- Step $6$: In directory $/$Q, create an additional hard link named $C\\_alias$ that refers to the existing directory $/$P$/$C$ (this does not change which parent $/$C$..\"$ resolves to).\n- Step $7$: In directory $/$P$/$C$, create a subdirectory named $E$.\n- Step $8$: Unlink $/$P$/$f$.\n- Step $9$: Unlink $/$Q$/$C\\_alias$ (remove the extra link to $/$P$/$C$).\n- Step $10$: Remove the empty subdirectory $/$P$/$C$/$E$ via $rmdir$.\n\nWhich of the following tuples gives the final values of $\\big(st\\_nlink(/P),\\, st\\_nlink(/Q),\\, st\\_nlink(/P/C),\\, st\\_nlink(/Q/D),\\, st\\_nlink(\\text{inode of }f)\\big)$ after Step $10$?\n\nA. $\\;(3,\\;3,\\;2,\\;2,\\;1)$\n\nB. $\\;(3,\\;4,\\;3,\\;2,\\;1)$\n\nC. $\\;(2,\\;3,\\;2,\\;2,\\;1)$\n\nD. $\\;(3,\\;3,\\;3,\\;2,\\;2)$",
            "solution": "The problem statement is first validated for correctness and solvability.\n\n### Step 1: Extract Givens\n- The directory system is a Directed Acyclic Graph (DAG).\n- The `$st\\_nlink$` field represents the link count of an inode.\n- For a non-directory file $F$, $st\\_nlink(F)$ is the number of directory entries pointing to it.\n- For a directory $D$, $st\\_nlink(D)$ is the sum of:\n  1. Its own `.` entry.\n  2. Any parent directory entries naming $D$.\n  3. The `..` entry from each immediate subdirectory.\n- Creation of a subdirectory $C$ in parent $P$: $st\\_nlink(C)$ becomes $2$, and $st\\_nlink(P)$ increases by $1$.\n- Creation of an additional hard link to a directory $D$ in directory $Q$: $st\\_nlink(D)$ increases by $1$; $st\\_nlink(Q)$ is unchanged.\n- Unlinking a non-directory name: decrements the target inode's $st\\_nlink$ by $1$.\n- Removing an empty subdirectory (`rmdir`): decrements the parent's $st\\_nlink$ by $1$.\n- Initial condition: Filesystem contains only the root directory `/`.\n- Sequence of operations:\n  1. Create directories `/P` and `/Q`.\n  2. Create regular file `/P/f`.\n  3. Create hard link `/Q/g` to `/P/f`.\n  4. Create subdirectory `/P/C`.\n  5. Create subdirectory `/Q/D`.\n  6. Create additional hard link `/Q/C_alias` to `/P/C`.\n  7. Create subdirectory `/P/C/E`.\n  8. Unlink `/P/f`.\n  9. Unlink `/Q/C_alias`.\n  10. `rmdir /P/C/E`.\n- The question asks for the final values of $\\big(st\\_nlink(/P),\\, st\\_nlink(/Q),\\, st\\_nlink(/P/C),\\, st\\_nlink(/Q/D),\\, st\\_nlink(\\text{inode of }f)\\big)$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded within the domain of computer science, specifically operating system file system design. The model provided for `$st\\_nlink$` accounting in a DAG-based directory system, while not universally implemented, is a logically consistent and well-defined concept. The problem is well-posed, with a clear initial state, a deterministic sequence of operations, and a specific question. The language is objective and unambiguous. All terms are sufficiently defined by the provided rules. The problem is therefore valid.\n\n### Step 3: Verdict and Action\nThe problem is valid. A step-by-step derivation of the solution will be performed.\n\n### Solution Derivation\nWe will track the `$st\\_nlink$` values for the five specified inodes through the sequence of ten operations. Let the tuple of interest be $\\big(n_P, n_Q, n_C, n_D, n_f\\big)$, representing $\\big(st\\_nlink(/P),\\, st\\_nlink(/Q),\\, st\\_nlink(/P/C),\\, st\\_nlink(/Q/D),\\, st\\_nlink(\\text{inode of }f)\\big)$.\n\n**Initial State:** The filesystem is empty except for the root. The inodes for `/P`, `/Q`, `/P/C`, `/Q/D`, and `f` do not exist. Their link counts are effectively $0$.\n\n**Step 1:** Create directories `/P` and `/Q`.\n- A new directory `/P` is created. Per the rule, its link count is $2$. $n_P = 2$.\n- A new directory `/Q` is created. Per the rule, its link count is $2$. $n_Q = 2$.\n- Tuple: $\\big(2, 2, \\text{N/A}, \\text{N/A}, \\text{N/A}\\big)$.\n\n**Step 2:** Create a regular file `/P/f`.\n- An inode for file `f` is created with one directory entry, `/P/f`. Its link count is $1$. $n_f = 1$.\n- Tuple: $\\big(2, 2, \\text{N/A}, \\text{N/A}, 1\\big)$.\n\n**Step 3:** Create a hard link to `/P/f` at path `/Q/g`.\n- A second directory entry, `/Q/g`, now points to the inode of `f`. Its link count increases by $1$.\n- $n_f$ becomes $1+1 = 2$.\n- Tuple: $\\big(2, 2, \\text{N/A}, \\text{N/A}, 2\\big)$.\n\n**Step 4:** Create a subdirectory `/P/C`.\n- A new directory `/P/C` is created. Its link count is $2$. $n_C = 2$.\n- The parent `/P` gains a `..` link from `/P/C`. Its link count increases by $1$.\n- $n_P$ becomes $2+1 = 3$.\n- Tuple: $\\big(3, 2, 2, \\text{N/A}, 2\\big)$.\n\n**Step 5:** Create a subdirectory `/Q/D`.\n- A new directory `/Q/D` is created. Its link count is $2$. $n_D = 2$.\n- The parent `/Q` gains a `..` link from `/Q/D`. Its link count increases by $1$.\n- $n_Q$ becomes $2+1 = 3$.\n- Tuple: $\\big(3, 3, 2, 2, 2\\big)$.\n\n**Step 6:** Create an additional hard link `/Q/C_alias` to `/P/C`.\n- The target directory `/P/C` gains a new name. Its link count increases by $1$.\n- $n_C$ becomes $2+1 = 3$.\n- The link count of `/Q` is unchanged as per the rule.\n- Tuple: $\\big(3, 3, 3, 2, 2\\big)$.\n\n**Step 7:** Create a subdirectory `/P/C/E`.\n- The parent directory `/P/C` gains a `..` link from `/P/C/E`. Its link count increases by $1$.\n- $n_C$ becomes $3+1 = 4$.\n- Tuple: $\\big(3, 3, 4, 2, 2\\big)$.\n\n**Step 8:** Unlink `/P/f`.\n- The directory entry `/P/f` is removed. The link count of the target inode `f` decreases by $1$.\n- $n_f$ becomes $2-1 = 1$.\n- Tuple: $\\big(3, 3, 4, 2, 1\\big)$.\n\n**Step 9:** Unlink `/Q/C_alias`.\n- The additional hard link to the directory `/P/C` is removed. Symmetrically to its creation, this decrements the target directory's link count by $1$.\n- $n_C$ becomes $4-1 = 3$.\n- Tuple: $\\big(3, 3, 3, 2, 1\\big)$.\n\n**Step 10:** Remove the empty subdirectory `/P/C/E` via `rmdir`.\n- The parent of `/P/C/E` is `/P/C`. Removing `/P/C/E` removes the `..` link from `/P/C/E` that pointed to `/P/C`. The parent's link count decreases by $1$.\n- $n_C$ becomes $3-1 = 2$.\n- Final Tuple: $\\big(3, 3, 2, 2, 1\\big)$.\n\nThe final derived values are $st\\_nlink(/P) = 3$, $st\\_nlink(/Q) = 3$, $st\\_nlink(/P/C) = 2$, $st\\_nlink(/Q/D) = 2$, and $st\\_nlink(\\text{inode of }f) = 1$.\n\n### Option-by-Option Analysis\n\n**A. $\\;(3,\\;3,\\;2,\\;2,\\;1)$**\nThis tuple matches the final values derived from the step-by-step analysis.\n- $st\\_nlink(/P) = 3$: Correct. Links are its entry `P` in `/`, its own `.` entry, and the `..` entry from its child `/P/C`.\n- $st\\_nlink(/Q) = 3$: Correct. Links are its entry `Q` in `/`, its own `.` entry, and the `..` entry from its child `/Q/D`.\n- $st\\_nlink(/P/C) = 2$: Correct. Links are its entry `C` in `/P` and its own `.` entry. The link from `C_alias` (Step 6) was removed (Step 9), and the `..` link from `/P/C/E` (Step 7) was removed (Step 10).\n- $st\\_nlink(/Q/D) = 2$: Correct. Links are its entry `D` in `/Q` and its own `.` entry.\n- $st\\_nlink(\\text{inode of }f) = 1$: Correct. The entry `/P/f` was removed (Step 8), leaving only the entry `/Q/g`.\n**Verdict: Correct.**\n\n**B. $\\;(3,\\;4,\\;3,\\;2,\\;1)$**\n- The value for $st\\_nlink(/Q)$ is $4$, which is incorrect. The derived value is $3$.\n- The value for $st\\_nlink(/P/C)$ is $3$, which is incorrect. The derived value is $2$. This would be the state after Step 9 but before Step 10.\n**Verdict: Incorrect.**\n\n**C. $\\;(2,\\;3,\\;2,\\;2,\\;1)$**\n- The value for $st\\_nlink(/P)$ is $2$, which is incorrect. The derived value is $3$. Its link count was incremented to $3$ in Step 4 and was not subsequently decremented.\n**Verdict: Incorrect.**\n\n**D. $\\;(3,\\;3,\\;3,\\;2,\\;2)$**\n- The value for $st\\_nlink(/P/C)$ is $3$, which is incorrect, as explained for option B.\n- The value for $st\\_nlink(\\text{inode of }f)$ is $2$, which is incorrect. The derived value is $1$. This would be the state before the unlink operation in Step 8.\n**Verdict: Incorrect.**",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "Now that you understand the rules, it's time to build the system itself. This practice challenges you to move from theory to implementation by creating an in-memory simulator for a DAG-based directory system. You will implement core filesystem primitives and, most importantly, devise a mechanism to enforce the acyclicity constraint, which is the defining feature of this architecture . This exercise provides direct experience with the data structures and graph traversal algorithms that underpin modern filesystems.",
            "id": "3619453",
            "problem": "You are to design and implement a self-contained teaching simulator for a directory system modeled as a Directed Acyclic Graph (DAG). The simulator must operate entirely in memory and must rigorously enforce acyclicity. The model should adhere to the following first-principles definitions and rules that originate from standard operating system directory abstractions and well-established graph theory.\n\nCore definitions that the simulator must embody:\n- A directory system is represented as a directed graph $G = (V, E)$, where $V$ is a finite set of nodes and $E \\subseteq V \\times V$ is a set of directed edges.\n- Each node $v \\in V$ represents a filesystem object with a type: either a directory or a file. Files have no outgoing edges. Directories may have outgoing edges to any type of node. Each outgoing edge from a directory is labeled by a string name. Names within a single directory must be unique.\n- The graph must be acyclic. A cycle is a sequence of nodes $(v_0, v_1, \\dots, v_k)$ with $k \\geq 1$ such that $(v_i, v_{i+1}) \\in E$ for all $i \\in \\{0, 1, \\dots, k-1\\}$ and $(v_k, v_0) \\in E$. Therefore, adding any edge that would make a parent node reachable from its prospective child must be refused.\n- Each node $v$ maintains an incoming degree (also called reference count), denoted $\\mathrm{in}(v) \\in \\mathbb{Z}_{\\ge 0}$, equal to the number of directory entries that refer to $v$. The root directory is a distinguished node with identifier $0$ and is never garbage-collected.\n- Garbage collection rule: when an edge is removed and a node’s incoming degree becomes $0$ (and the node is not the root), that node is deleted. If that node is a directory, every outgoing edge from it is removed and the reference counts of its children are decremented accordingly; this may cascade recursively.\n\nYour simulator must implement the following commands with explicit error states:\n- `link(p, c, s)`: Add a directed edge from parent node with identifier $p$ (which must be a directory) to child node with identifier $c$ and assign it the name string $s$ within $p$.\n  - Return $0$ on success.\n  - Return $-1$ if either $p$ or $c$ does not refer to a valid existing node or if $p$ is not a directory.\n  - Return $-2$ if $s$ is already bound in $p$ to a different child node.\n  - Return $-3$ if an edge already exists from $p$ to $c$ with the same name $s$.\n  - Return $-4$ if adding the edge would introduce a cycle (equivalently, if $p$ is reachable from $c$ before the addition).\n- `unlink(p, s)`: Remove the named edge with string $s$ from the directory node $p$ to its child. After removal, perform garbage collection by the rule above.\n  - Return $0$ on success.\n  - Return $-5$ if there is no such named edge from $p$.\n- `rename(p, s_{\\text{old}}, s_{\\text{new}})`: Change the name of the existing edge in directory node $p$ from $s_{\\text{old}}$ to $s_{\\text{new}}$.\n  - Return $0$ on success.\n  - Return $-6$ if $s_{\\text{old}}$ does not exist in $p$.\n  - Return $-7$ if $s_{\\text{new}}$ is already in use in $p$ for any edge.\n\nThe simulator must also implement a read-only show operation that computes invariant metrics of the current graph state:\n- Let $N$ be the total number of live nodes.\n- Let $E$ be the total number of live directed edges.\n- Let $B$ be a boolean indicator of acyclicity, where $B = 1$ if and only if the current graph has no directed cycles, and $B = 0$ otherwise.\n- Let $S$ be an integer checksum defined as $S = \\sum_{(p \\to c, s) \\in E} \\left( |s| + p + c \\right)$, where $|s|$ denotes the length of the string $s$, and the sum ranges over all directory edges $(p \\to c)$ labeled by the name $s$.\n\nAlgorithmic facts that must guide your design:\n- Reachability is defined by the existence of a directed path: node $u$ reaches node $v$ if there exists a sequence $u = v_0, v_1, \\dots, v_k = v$ with $k \\ge 0$ and $(v_i, v_{i+1}) \\in E$ for all $i$. Refusing cycles in `link(p,c,s)` is achieved by checking whether $p$ is reachable from $c$ in the current $G$ before adding $(p \\to c)$.\n- A standard depth-first search (DFS) with color marking or visited sets is suitable to determine reachability and detect cycles, and thus to evaluate $B$.\n\nYour program must:\n- Construct fresh DAG instances for each test case below.\n- Provide internal helper operations to create nodes of type directory and file as needed for the test sequences. The root directory with identifier $0$ must exist in every DAG and is a directory.\n- Execute the following test suite, each test executed on a new DAG instance:\n  1. Test case $1$ (happy path): Create directories $A$ and $B$, and a file $F$. Execute `link(0, A, \"home\")`, `link(0, B, \"etc\")`, `link(A, F, \"notes\")`. Then compute show metrics and return the list $[N, E, B, S]$.\n  2. Test case $2$ (cycle refusal): Create directory $A$. Execute `link(0, A, \"home\")`. Attempt `link(A, 0, \"back\")`. Return the integer error code produced by the attempt (expected to be a negative integer indicating refusal due to cycle risk).\n  3. Test case $3$ (rename collision): Create files $F$ and $G$. Execute `link(0, F, \"x\")`, `link(0, G, \"y\")`. Attempt `rename(0, \"x\", \"y\")`. Return the integer error code produced by the attempt (expected to be a negative integer signaling target name collision).\n  4. Test case $4$ (unlink garbage collection): Create directory $A$ and file $F$. Execute `link(0, A, \"home\")`, `link(A, F, \"notes\")`. Execute `unlink(0, \"home\")`. Return the integer node count $N$ after garbage collection completes.\n  5. Test case $5$ (multi-parent linking and unlinking): Create directories $A$ and $B$. Execute `link(0, A, \"home\")`, `link(0, B, \"etc\")`, `link(B, A, \"alias\")`. Execute `unlink(B, \"alias\")`. Return the integer incoming degree $\\mathrm{in}(A)$ after the unlink.\n\nFinal output format specification:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test result occupies a single position in the list. Use a four-element list for test case $1$, and single integers for test cases $2$, $3$, $4$, and $5$.\n- Concretely, the output must have the exact shape $[[N,E,B,S],r_2,r_3,r_4,r_5]$ where $r_2$, $r_3$, $r_4$, and $r_5$ are integers as defined above. No other output is permitted.\n- There are no physical units, angles, or percentages involved in this task; all answers are pure integers or a list of integers, and all numbers must be reported in plain integer form.",
            "solution": "The problem requires the design and implementation of a simulator for an acyclic-graph directory system. The solution must be grounded in formal definitions from graph theory and operating systems principles. The core of the solution lies in modeling the filesystem as a Directed Acyclic Graph (DAG) $G = (V, E)$ and correctly implementing state-modifying operations (`link`, `unlink`, `rename`) that preserve the integrity of this structure, particularly its acyclicity and reference-counted garbage collection.\n\n### Data Structure Design\n\nThe graph $G$ is represented by a collection of nodes and edges. To facilitate efficient access and management, a central `DAG` structure encapsulates the entire state.\n\n1.  **Node Representation**: Each node $v \\in V$ is represented by a `Node` structure. This structure contains:\n    *   An integer identifier `id`, which is a unique key for the node.\n    *   A `type` enumerator, which can be `NODE_DIRECTORY` or `NODE_FILE`.\n    *   An integer `in_degree`, representing the reference count $\\mathrm{in}(v)$. This count is the number of incoming edges, corresponding to the number of parent directories linking to this node.\n    *   A boolean flag `is_active` to logically mark a node as 'live' or 'deleted' by the garbage collector.\n    *   For `NODE_DIRECTORY` types, a pointer to a linked list of outgoing edges. A file node, by definition, has no outgoing edges.\n\n2.  **Edge Representation**: Each directed edge $(p, c) \\in E$ with a name label $s$ is represented by an `Edge` structure. This structure contains:\n    *   A character array `name` to store the string label $s$.\n    *   An integer `child_id` which stores the identifier of the child node $c$.\n    *   A `next` pointer, forming a singly linked list of edges originating from a common parent directory $p$.\n\n3.  **Graph Container**: A `DAG` structure aggregates the components of the graph:\n    *   An array `nodes` of `Node` structures, indexed by node `id`, providing $O(1)$ access to any node given its identifier.\n    *   An integer `next_node_id` to ensure unique identifier assignment for newly created nodes.\n\nThe simulation begins with a single, active, root directory at `id = 0`, whose `in_degree` is conceptually non-zero and which is exempt from garbage collection.\n\n### Algorithmic Implementation\n\n**1. Acyclicity Enforcement via Reachability Check**\n\nThe `link(p, c, s)` operation must guarantee that adding an edge from parent $p$ to child $c$ does not introduce a cycle. A cycle would be created if and only if there is already a path from $c$ to $p$ in the graph. Therefore, before adding the edge $(p, c)$, we must perform a reachability check.\n\nThe reachability query \"Is node $p$ reachable from node $c$?\" is resolved using an iterative Depth-First Search (DFS). The algorithm is as follows:\n*   Initialize a boolean array `visited` of size $|V|$, with all entries set to false.\n*   Initialize a stack and push the starting node identifier, $c$.\n*   Mark $c$ as visited.\n*   While the stack is not empty:\n    1.  Pop a node identifier, $u$.\n    2.  If $u$ is the target node $p$, then a path exists. Return `true`.\n    3.  For each child $v$ of node $u$:\n        *   If $v$ has not been visited, mark it as visited and push it onto the stack.\n*   If the loop completes without finding $p$, no path exists. Return `false`.\n\nIf this check returns `true`, the `link` operation is aborted with error code $-4$.\n\n**2. Garbage Collection**\n\nGarbage collection is based on reference counting. A node is eligible for collection if its `in_degree` drops to $0$ (and it is not the root node). This process is initiated by the `unlink` operation.\n\nThe `collect_garbage(v_id)` procedure is recursive:\n1.  Retrieve the node $v$ corresponding to `v_id`.\n2.  The base cases for terminating recursion are: if $v$ is already inactive, if $v$ is the root node (ID $0$), or if $\\mathrm{in}(v) > 0$.\n3.  If no base case is met, mark node $v$ as inactive (`is_active = false`).\n4.  If $v$ is a directory, iterate through all its outgoing edges $(v, w)$. For each such edge:\n    *   Decrement the `in_degree` of the child node $w$.\n    *   Recursively call `collect_garbage(w_id)`.\n    *   The memory allocated for the `Edge` structure itself is freed.\n5.  After iterating, the directory's edge list is cleared.\n\nThis cascading deletion correctly reclaims all unreachable subgraphs.\n\n**3. Command Implementation**\n\nThe user-facing commands are implemented as functions that manipulate the `DAG` data structure, using the above algorithms to maintain consistency.\n\n*   `link(p, c, s)`: First, it validates the existence and types of nodes $p$ and $c$. It then iterates through the edge list of $p$ to check for name collisions (error $-2$) or duplicate edges (error $-3$). Subsequently, it performs the crucial acyclicity check. If all checks pass, it allocates a new `Edge`, prepends it to the parent's edge list, and increments the child's `in_degree`.\n\n*   `unlink(p, s)`: It validates the parent node $p$ and searches its edge list for an edge named $s$. If not found, it returns error $-5$. If found, the edge is removed from the linked list and its memory is freed. The `in_degree` of the corresponding child is decremented, and `collect_garbage` is called on the child, potentially triggering a cascade.\n\n*   `rename(p, s_old, s_new)`: It first checks if the new name $s_{\\text{new}}$ is already in use within directory $p$, returning error $-7$ if so. Then, it searches for the edge named $s_{\\text{old}}$. If found, the name is updated; otherwise, error $-6$ is returned.\n\n**4. `show` Metrics Calculation**\n\nThe `show` operation computes four metrics describing the current state of the graph.\n\n*   $N$ (Total Nodes): Calculated by iterating through the `nodes` array and counting all nodes where `is_active` is true.\n*   $E$ (Total Edges): Calculated by iterating through all active nodes. If a node is a directory, the size of its edge list is added to a running total.\n*   $B$ (Acyclicity): A boolean value determined by a global cycle detection algorithm. A three-color DFS traversal is employed:\n    *   All nodes are initially `WHITE` (unvisited).\n    *   The traversal starts from each `WHITE` node in the graph.\n    *   When visiting a node, it is colored `GRAY` (visiting).\n    *   If the traversal encounters a `GRAY` node, a back edge has been found, indicating a cycle. The function returns $B=0$.\n    *   After all descendants of a node have been visited, the node is colored `BLACK` (finished).\n    *   If the traversal completes for all nodes without finding a cycle, the graph is acyclic, and the function returns $B=1$.\n*   $S$ (Checksum): Calculated by iterating over all edges $(p \\to c, s)$ in the graph and summing the value $|s| + p + c$ for each, where $|s|$ is the length of the string name.\n\nThis comprehensive design ensures that all rules and behaviors specified in the problem statement are rigorously enforced, resulting in a correct and robust simulation.",
            "answer": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_NODES 32\n#define MAX_NAME_LEN 32\n\ntypedef enum { NODE_FILE, NODE_DIRECTORY } NodeType;\n\nstruct Edge;\n\ntypedef struct {\n    int id;\n    NodeType type;\n    int in_degree;\n    bool is_active;\n    struct Edge* edges;\n} Node;\n\ntypedef struct Edge {\n    char name[MAX_NAME_LEN];\n    int child_id;\n    struct Edge* next;\n} Edge;\n\ntypedef struct {\n    Node nodes[MAX_NODES];\n    int node_count;\n} DAG;\n\n// Forward declarations\nvoid collect_garbage(DAG* dag, int node_id);\nbool is_reachable(DAG* dag, int start_id, int end_id);\n\nvoid init_dag(DAG* dag) {\n    dag->node_count = 0;\n    for (int i = 0; i < MAX_NODES; ++i) {\n        dag->nodes[i].is_active = false;\n        dag->nodes[i].edges = NULL;\n    }\n    // Create root directory\n    dag->nodes[0].id = 0;\n    dag->nodes[0].type = NODE_DIRECTORY;\n    dag->nodes[0].in_degree = 1; // Conceptually, never collected\n    dag->nodes[0].is_active = true;\n    dag->node_count = 1;\n}\n\nvoid free_dag_memory(DAG* dag) {\n    for (int i = 0; i < dag->node_count; ++i) {\n        if (dag->nodes[i].type == NODE_DIRECTORY) {\n            Edge* edge = dag->nodes[i].edges;\n            while (edge != NULL) {\n                Edge* temp = edge;\n                edge = edge->next;\n                free(temp);\n            }\n            dag->nodes[i].edges = NULL;\n        }\n    }\n}\n\nint create_node(DAG* dag, NodeType type) {\n    if (dag->node_count >= MAX_NODES) return -1;\n    int id = dag->node_count;\n    dag->nodes[id].id = id;\n    dag->nodes[id].type = type;\n    dag->nodes[id].in_degree = 0;\n    dag->nodes[id].is_active = true;\n    dag->nodes[id].edges = NULL;\n    dag->node_count++;\n    return id;\n}\n\nint link_node(DAG* dag, int p_id, int c_id, const char* s) {\n    if (p_id < 0 || p_id >= dag->node_count || c_id < 0 || c_id >= dag->node_count) return -1;\n    Node* p = &dag->nodes[p_id];\n    Node* c = &dag->nodes[c_id];\n    if (!p->is_active || !c->is_active || p->type != NODE_DIRECTORY) return -1;\n\n    Edge* current_edge = p->edges;\n    while (current_edge != NULL) {\n        if (strcmp(current_edge->name, s) == 0) {\n            return (current_edge->child_id == c_id) ? -3 : -2;\n        }\n        current_edge = current_edge->next;\n    }\n\n    if (p_id == c_id || is_reachable(dag, c_id, p_id)) return -4;\n\n    Edge* new_edge = (Edge*)malloc(sizeof(Edge));\n    if (!new_edge) return -1; // Memory allocation failure\n    strncpy(new_edge->name, s, MAX_NAME_LEN - 1);\n    new_edge->name[MAX_NAME_LEN - 1] = '\\0';\n    new_edge->child_id = c_id;\n    new_edge->next = p->edges;\n    p->edges = new_edge;\n    c->in_degree++;\n    return 0;\n}\n\nint unlink_node(DAG* dag, int p_id, const char* s) {\n    if (p_id < 0 || p_id >= dag->node_count) return -5;\n    Node* p = &dag->nodes[p_id];\n    if (!p->is_active || p->type != NODE_DIRECTORY) return -5;\n\n    Edge* curr = p->edges;\n    Edge* prev = NULL;\n    while (curr != NULL && strcmp(curr->name, s) != 0) {\n        prev = curr;\n        curr = curr->next;\n    }\n\n    if (curr == NULL) return -5;\n\n    if (prev == NULL) p->edges = curr->next;\n    else prev->next = curr->next;\n\n    int child_id = curr->child_id;\n    free(curr);\n\n    Node* child = &dag->nodes[child_id];\n    child->in_degree--;\n    if (child->in_degree == 0 && child->id != 0) {\n        collect_garbage(dag, child_id);\n    }\n    return 0;\n}\n\nint rename_edge(DAG* dag, int p_id, const char* s_old, const char* s_new) {\n    if (p_id < 0 || p_id >= dag->node_count) return -6;\n    Node* p = &dag->nodes[p_id];\n    if (!p->is_active || p->type != NODE_DIRECTORY) return -6;\n\n    Edge* edge_to_rename = NULL;\n    Edge* current_edge = p->edges;\n    while (current_edge != NULL) {\n        if (strcmp(current_edge->name, s_new) == 0) return -7;\n        if (strcmp(current_edge->name, s_old) == 0) edge_to_rename = current_edge;\n        current_edge = current_edge->next;\n    }\n\n    if (edge_to_rename == NULL) return -6;\n\n    strncpy(edge_to_rename->name, s_new, MAX_NAME_LEN - 1);\n    edge_to_rename->name[MAX_NAME_LEN - 1] = '\\0';\n    return 0;\n}\n\nbool is_reachable(DAG* dag, int start_id, int end_id) {\n    bool visited[MAX_NODES] = {false};\n    int stack[MAX_NODES];\n    int top = -1;\n\n    stack[++top] = start_id;\n    visited[start_id] = true;\n\n    while (top >= 0) {\n        int u_id = stack[top--];\n        if (u_id == end_id) return true;\n\n        Node* u_node = &dag->nodes[u_id];\n        if (u_node->is_active && u_node->type == NODE_DIRECTORY) {\n            Edge* edge = u_node->edges;\n            while (edge != NULL) {\n                int v_id = edge->child_id;\n                if (!visited[v_id]) {\n                    visited[v_id] = true;\n                    stack[++top] = v_id;\n                }\n                edge = edge->next;\n            }\n        }\n    }\n    return false;\n}\n\nvoid collect_garbage(DAG* dag, int node_id) {\n    Node* node = &dag->nodes[node_id];\n    if (!node->is_active || node->id == 0 || node->in_degree > 0) return;\n\n    node->is_active = false;\n\n    if (node->type == NODE_DIRECTORY) {\n        Edge* edge = node->edges;\n        while (edge != NULL) {\n            Edge* to_free = edge;\n            int child_id = edge->child_id;\n            dag->nodes[child_id].in_degree--;\n            if (dag->nodes[child_id].in_degree == 0 && child_id != 0) {\n                collect_garbage(dag, child_id);\n            }\n            edge = edge->next;\n            free(to_free);\n        }\n        node->edges = NULL;\n    }\n}\n\ntypedef struct { int n, e, b, s; } ShowMetrics;\nbool is_acyclic_dfs_visit(DAG* dag, int u_id, int* colors);\n\nbool is_acyclic(DAG* dag) {\n    int colors[MAX_NODES] = {0}; // 0: white, 1: gray, 2: black\n    for (int i = 0; i < dag->node_count; ++i) {\n        if (dag->nodes[i].is_active && colors[i] == 0) {\n            if (!is_acyclic_dfs_visit(dag, i, colors)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nbool is_acyclic_dfs_visit(DAG* dag, int u_id, int* colors) {\n    colors[u_id] = 1; // Gray\n    Node* u_node = &dag->nodes[u_id];\n    if (u_node->is_active && u_node->type == NODE_DIRECTORY) {\n        Edge* edge = u_node->edges;\n        while(edge != NULL) {\n            int v_id = edge->child_id;\n            if (dag->nodes[v_id].is_active) {\n                if (colors[v_id] == 1) return false; // Cycle\n                if (colors[v_id] == 0) {\n                    if (!is_acyclic_dfs_visit(dag, v_id, colors)) return false;\n                }\n            }\n            edge = edge->next;\n        }\n    }\n    colors[u_id] = 2; // Black\n    return true;\n}\n\nShowMetrics show(DAG* dag) {\n    ShowMetrics m = {0, 0, 0, 0};\n    for (int i = 0; i < dag->node_count; ++i) {\n        if (dag->nodes[i].is_active) {\n            m.n++;\n            if (dag->nodes[i].type == NODE_DIRECTORY) {\n                Edge* edge = dag->nodes[i].edges;\n                while (edge != NULL) {\n                    m.e++;\n                    m.s += strlen(edge->name) + dag->nodes[i].id + edge->child_id;\n                    edge = edge->next;\n                }\n            }\n        }\n    }\n    m.b = is_acyclic(dag) ? 1 : 0;\n    return m;\n}\n\nint main(void) {\n    int res1[4];\n    int res2, res3, res4, res5;\n\n    // Test case 1\n    {\n        DAG dag;\n        init_dag(&dag);\n        int a_id = create_node(&dag, NODE_DIRECTORY);\n        int b_id = create_node(&dag, NODE_DIRECTORY);\n        int f_id = create_node(&dag, NODE_FILE);\n        link_node(&dag, 0, a_id, \"home\");\n        link_node(&dag, 0, b_id, \"etc\");\n        link_node(&dag, a_id, f_id, \"notes\");\n        ShowMetrics m = show(&dag);\n        res1[0] = m.n; res1[1] = m.e; res1[2] = m.b; res1[3] = m.s;\n        free_dag_memory(&dag);\n    }\n\n    // Test case 2\n    {\n        DAG dag;\n        init_dag(&dag);\n        int a_id = create_node(&dag, NODE_DIRECTORY);\n        link_node(&dag, 0, a_id, \"home\");\n        res2 = link_node(&dag, a_id, 0, \"back\");\n        free_dag_memory(&dag);\n    }\n\n    // Test case 3\n    {\n        DAG dag;\n        init_dag(&dag);\n        int f_id = create_node(&dag, NODE_FILE);\n        int g_id = create_node(&dag, NODE_FILE);\n        link_node(&dag, 0, f_id, \"x\");\n        link_node(&dag, 0, g_id, \"y\");\n        res3 = rename_edge(&dag, 0, \"x\", \"y\");\n        free_dag_memory(&dag);\n    }\n\n    // Test case 4\n    {\n        DAG dag;\n        init_dag(&dag);\n        int a_id = create_node(&dag, NODE_DIRECTORY);\n        int f_id = create_node(&dag, NODE_FILE);\n        link_node(&dag, 0, a_id, \"home\");\n        link_node(&dag, a_id, f_id, \"notes\");\n        unlink_node(&dag, 0, \"home\");\n        ShowMetrics m = show(&dag);\n        res4 = m.n;\n        free_dag_memory(&dag);\n    }\n\n    // Test case 5\n    {\n        DAG dag;\n        init_dag(&dag);\n        int a_id = create_node(&dag, NODE_DIRECTORY);\n        int b_id = create_node(&dag, NODE_DIRECTORY);\n        link_node(&dag, 0, a_id, \"home\");\n        link_node(&dag, 0, b_id, \"etc\");\n        link_node(&dag, b_id, a_id, \"alias\");\n        unlink_node(&dag, b_id, \"alias\");\n        res5 = dag.nodes[a_id].in_degree;\n        free_dag_memory(&dag);\n    }\n\n    printf(\"[[%d,%d,%d,%d],%d,%d,%d,%d]\\n\", res1[0], res1[1], res1[2], res1[3], res2, res3, res4, res5);\n\n    return EXIT_SUCCESS;\n}\n```"
        },
        {
            "introduction": "With a working model of a DAG directory system, we can now build tools that operate upon it. This exercise simulates the development of a disk usage utility (`du`) that must remain accurate even when the file system is changing. Your task is to implement a traversal algorithm that correctly calculates total size by visiting each file only once, despite the presence of multiple hard links, and to prove its robustness using an inode bitmap under a model of concurrent link additions .",
            "id": "3619477",
            "problem": "You are given an abstract model of an Acyclic-Graph Directory System (AGDS) suitable for a disk usage calculator similar to the standard utility \"du\". The model assumes the following fundamental base:\n\n- Each file system object has a unique inode identifier in the range $\\{0,\\dots,N-1\\}$ for some finite integer $N$. A directory contains an ordered list of references (links) to other inodes. Files do not contain links; they are leaves.\n- The directory graph is a directed acyclic graph (DAG): directories may link to directories and files, and files do not link to any node. Hard links to files are allowed, but links to directories are constrained so that no directed cycles occur.\n- The size of a file inode $i$ is a nonnegative integer $s(i) \\in \\mathbb{N}$. The size of a directory is considered $0$ for disk usage accounting in this problem.\n\nA correct disk usage traversal for a set of starting directory inodes must visit each reachable file inode at most once, summing its size exactly once, even if there are multiple hard links to the same file. A common technique is an inode bitmap: maintain a bit array $B$ indexed by inode identifier, where $B[i] = 1$ if inode $i$ has already been counted.\n\nConcurrency model for this problem:\n\n- The traversal proceeds in discrete steps, using a depth-first strategy with an explicit stack. At each traversal step, the algorithm reads the next entry in the current directory frame, possibly descending into a subdirectory or encountering a file.\n- Concurrent link additions are modeled as discrete events interleaved with traversal steps. An addition event inserts a new directory entry at the end of a directory’s entry list, linking that directory to an existing file inode or to a freshly created file inode. No deletions occur, and no directory links are added that would introduce cycles.\n- A race window exists because a directory’s entry list length is read on each step; therefore, entries added after a directory frame is fully processed will not be seen by the traversal. Entries added before the frame finishes will be observed when the traversal reaches those indices. This models the reality that the traversal’s visible set of entries for a directory is not a global snapshot, and yet the disk usage algorithm must still never double-count any file.\n\nYour task is to write a complete, runnable program that:\n\n- Constructs several AGDS test cases, each defined by an initial set of inodes, initial links, and a sequence of interleaved events: either a traversal step or a concurrent link addition. The traversal always starts at a single root directory inode $r$ for each test case.\n- Implements a \"du\" traversal using an inode bitmap $B$ to decide whether to add $s(i)$ to the running sum the first time a file inode $i$ is encountered. Directories contribute $0$ to the sum. The traversal continues until the explicit stack is empty.\n- Records, for each file inode $i$, the number of times its size is added to the sum (this is the \"count-additions\" for $i$). The key correctness property to check is that for all file inodes $i$, the count-additions value is at most $1$.\n\nYou must derive and implement the traversal logic from first principles based on the following core definitions and well-tested facts:\n\n- A directory graph is a directed acyclic graph $G = (V, E)$, with vertex set $V$ and edge set $E \\subseteq V \\times V$ capturing \"contains a link to.\"\n- The reachability set from root $r$ is $R(r) = \\{ v \\in V \\mid \\exists \\text{ a directed path from } r \\text{ to } v \\}$.\n- The \"du\" objective, in the absence of concurrency, is to compute $S = \\sum_{i \\in R(r) \\cap F} s(i)$, where $F \\subseteq V$ is the subset of file inodes. Under concurrency, the requirement is not to compute a snapshot sum but to ensure the safety property \"never double-count,\" namely, for every file inode $i$, $B[i]$ transitions from $0$ to $1$ at most once and $s(i)$ is added to the total at most once.\n\nImportant: Your program should purely simulate logic. There are no physical units involved.\n\nTest Suite and Coverage:\n\nImplement the following $4$ test cases. For each case, construct the initial AGDS and the interleaved event sequence, then execute the simulation to completion. For every test case, your program must return a boolean result indicating whether any file’s size was added more than once (where 1 means \"no double-counts occurred\" and 0 means \"a double-count occurred\").\n\n- Test case $1$ (happy path with a late hard link):\n  - Initial inodes: root directory $r$, directory $d$, files $f_1$ and $f_2$ with sizes $s(f_1)=10$ and $s(f_2)=20$.\n  - Initial links: $r \\to f_1$, $r \\to d$, $d \\to f_2$.\n  - Event sequence: perform $3$ traversal steps to visit $f_1$ and descend into $d$ to visit $f_2$, then add a new link $r \\to f_2$, then continue traversal until completion.\n  - Expected: no double-count; $f_2$’s late link is observed but skipped because $B[f_2]=1$.\n\n- Test case $2$ (boundary: many hard links to the same file across multiple subdirectories):\n  - Initial inodes: root $r$, subdirectories $a$, $b$, $c$, file $f$ with $s(f)=7$.\n  - Initial links: $r \\to a$, $r \\to b$, $r \\to c$.\n  - Event sequence: interleave traversal steps so that each of $a$, $b$, and $c$ is eventually visited; before each subdirectory is fully processed, add a link from that subdirectory to $f$. Add at least $2$ links to $f$ across different subdirectories before $f$ is ever encountered by the traversal, then complete traversal.\n  - Expected: no double-count; $f$ is counted exactly once despite multiple links.\n\n- Test case $3$ (race window causing undercount but never double-count):\n  - Initial inodes: root $r$, subdirectories $x$, $y$.\n  - Initial links: $r \\to x$, $r \\to y$.\n  - Event sequence: fully traverse $x$ while it is empty, then create a new file $g$ with $s(g)=5$ and add $x \\to g$ after $x$ has been fully processed so it will not be seen there; before $y$ is processed, add $y \\to g$; then complete traversal.\n  - Expected: no double-count; $g$ is seen once via $y$ and counted once.\n\n- Test case $4$ (edge: empty file system under root):\n  - Initial inodes: root $r$ only.\n  - Initial links: none.\n  - Event sequence: complete traversal immediately.\n  - Expected: no double-count; the sum is $0$.\n\nFinal Output Format:\n\n- Your program should produce a single line of output containing the boolean results for the $4$ test cases in order, as a comma-separated list enclosed in square brackets, where each boolean is expressed as an integer $0$ or $1$. For example, an output line like $[1,1,1,1]$ indicates that all test cases exhibited no double-counting.\n\nConstraints and notes:\n\n- You must implement the traversal using an inode bitmap $B$ and an explicit stack, stepping the traversal one directory-entry at a time to allow interleaving with link-addition events.\n- You must not assume a global snapshot. New directory entries appended after a directory frame is exhausted will not be seen by the traversal of that directory.\n- You must not use any external input; everything must be constructed in program memory and executed deterministically.",
            "solution": "The problem statement has been critically validated and is deemed **valid**. It presents a well-posed, scientifically sound, and internally consistent problem in the domain of operating systems algorithms. The model of an Acyclic-Graph Directory System (AGDS) is a standard abstraction, and the simulation of a concurrent `du`-like utility with a specific race-window model is a formalizable and non-trivial task. All definitions, constraints, and test case requirements are clear and sufficient for constructing a deterministic simulation to verify the specified correctness property.\n\n### Principle-Based Design of the Simulation\n\nThe goal is to simulate a disk usage calculation on a file system model and verify that a specific implementation strategy, using an inode bitmap, correctly prevents double-counting of files under a simplified concurrency model. The design is based on the following principles.\n\n#### 1. Modeling the Acyclic-Graph Directory System (AGDS)\n\nThe file system is modeled as a directed acyclic graph (DAG), denoted `$G = (V, E)$`. The set of vertices `$V$` corresponds to the set of inodes, uniquely identified by integers in `$\\{0, \\dots, N-1\\}$` for a system with `$N$` inodes. An edge `$(u, v) \\in E$` exists if a directory inode `$u$` contains a link to an inode `$v$`. In our implementation, an `Inode` structure represents a vertex. It stores its type (directory or file), its size `$s(i)$` (which is `$0$` for directories), and for directories, a dynamic list of links to other inodes. This directly maps the abstract graph structure to a concrete data structure.\n\n```c\ntypedef enum { INODE_DIR, INODE_FILE } InodeType;\ntypedef struct {\n    int id;\n    InodeType type;\n    int size;\n    int entries[MAX_ENTRIES];\n    int num_entries;\n} Inode;\n```\n\n#### 2. Depth-First Traversal with an Explicit Stack\n\nA non-recursive, depth-first search (DFS) is required to traverse the directory graph starting from a root inode `$r$`. This is implemented using an explicit stack. Each element on the stack, or `StackFrame`, represents a directory traversal in progress. A frame contains the inode identifier of the directory being processed (`inode_id`) and the index of the next entry to visit within that directory's link list (`entry_index`).\n\n```c\ntypedef struct {\n    int inode_id;\n    int entry_index;\n} StackFrame;\n```\n\nThe traversal logic proceeds as follows:\n- Peek at the stack's top frame `$\\{d, k\\}$`.\n- If the `$k$`-th entry of directory `$d$` exists, process it.\n- If the entry points to a subdirectory, push a new frame for that subdirectory onto the stack.\n- If the entry points to a file, proceed to the counting logic.\n- Increment the entry index `$k$` in the current frame.\n- If all entries in directory `$d$` have been processed, pop its frame from the stack.\n- The traversal terminates when the stack becomes empty.\n\n#### 3. Correctness via Inode Bitmap\n\nThe core correctness property is to sum the size of each reachable file `$s(i)$` at most once, even when multiple paths (hard links) lead to the same file inode `$i$`. This is enforced using an auxiliary data structure, the inode bitmap `$B$`. `$B$` is a bit array of size `$N$`, where each bit `$B[i]$` corresponds to an inode `$i$`. Initially, all bits are `$0$`. When the traversal first encounters a file inode `$i$`, it performs an atomic-like check-and-set operation:\n\n1.  Check if `$B[i]$` is `$0$`.\n2.  If it is, add `$s(i)$` to the total sum, set `$B[i]` to `$1$`, and record that an addition occurred for this file.\n3.  If `$B[i]$` is already `$1$`, the file has been counted before. The traversal skips it and proceeds.\n\nThis mechanism guarantees that the addition `total_sum += s(i)` happens at most once for each file `$i$`, satisfying the problem's primary safety requirement. For verification, we maintain a `count_additions` array to explicitly track how many times this addition is performed for each file. A correct run must result in `count_additions[i]` being at most `$1$` for all file inodes `$i$`.\n\n#### 4. Simulating Concurrency and the Race Window\n\nConcurrency is modeled through a deterministic, interleaved sequence of events. An event can be a single traversal step or a link-addition operation. The simulation proceeds by processing this predefined sequence.\n\nThe race window is modeled by ensuring that the number of entries in a directory is read fresh on each traversal step that processes that directory. Our `perform_traversal_step` function implements this by checking `frame->entry_index < dir->num_entries`, where `dir->num_entries` reflects the current, possibly modified, state of the directory. If a link is added to a directory after the traversal has processed all entries that were present when it started, but before the frame is popped, the new entry will be seen. Conversely, if a link is added after the traversal's index has passed the end of the original list of entries, the new link will be missed, correctly simulating the race condition.\n\nThis discrete event simulation allows for a rigorous and reproducible analysis of the algorithm's behavior under specific concurrent scenarios, as defined in the test suite. The implementation translates each test case from the problem description into an initial graph configuration and a corresponding event sequence to drive the simulation.",
            "answer": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n// Note: Unused but permitted headers are commented out as per convention.\n// #include <complex.h>\n// #include <threads.h>\n// #include <stdatomic.h>\n\n#define MAX_INODES 16\n#define MAX_ENTRIES 16\n#define MAX_EVENTS 32\n#define MAX_STACK_DEPTH 16\n\n// Represents the type of an inode in the file system.\ntypedef enum {\n    INODE_DIR,\n    INODE_FILE\n} InodeType;\n\n// Represents a file system object (file or directory).\ntypedef struct {\n    int id;\n    InodeType type;\n    int size;\n    int entries[MAX_ENTRIES];\n    int num_entries;\n} Inode;\n\n// Represents a frame on the explicit DFS stack.\ntypedef struct {\n    int inode_id;\n    int entry_index;\n} StackFrame;\n\n// Represents the type of an event in the simulation sequence.\ntypedef enum {\n    EV_TRAVERSE,\n    EV_ADD_LINK,\n    EV_CREATE_FILE\n} EventType;\n\n// Represents a single event in the simulation.\ntypedef struct {\n    EventType type;\n    int arg1; // For ADD_LINK: dir_id; For CREATE_FILE: new_inode_id\n    int arg2; // For ADD_LINK: target_id; For CREATE_FILE: size\n} Event;\n\n// Defines a complete test case for the simulation.\ntypedef struct {\n    const char* name;\n    int num_total_inodes;\n    Inode initial_inodes[MAX_INODES];\n    int root_inode_id;\n    int num_events;\n    Event events[MAX_EVENTS];\n} SimulationTestCase;\n\n// Foward declaration of the traversal step function.\nvoid perform_traversal_step(\n    int* stack_ptr,\n    StackFrame stack[],\n    Inode inodes[],\n    int num_inodes,\n    int inode_bitmap[],\n    int count_additions[]);\n\n// Runs a single simulation test case and returns 1 if no double-counts occurred, 0 otherwise.\nint run_simulation(const SimulationTestCase* tc) {\n    // Simulation state\n    Inode inodes[MAX_INODES];\n    int num_inodes = tc->num_total_inodes;\n    int inode_bitmap[MAX_INODES] = {0};\n    int count_additions[MAX_INODES] = {0};\n    StackFrame stack[MAX_STACK_DEPTH];\n    int stack_ptr = 0;\n\n    // --- Initialization ---\n    memcpy(inodes, tc->initial_inodes, sizeof(tc->initial_inodes));\n\n    // Initialize the traversal stack with the root directory, if it exists.\n    if (tc->root_inode_id >= 0 && tc->root_inode_id < num_inodes) {\n        stack[stack_ptr].inode_id = tc->root_inode_id;\n        stack[stack_ptr].entry_index = 0;\n        stack_ptr++;\n    }\n\n    // --- Main Simulation Loop ---\n    // Process the predefined event sequence.\n    for (int i = 0; i < tc->num_events; ++i) {\n        Event ev = tc->events[i];\n        switch (ev.type) {\n            case EV_TRAVERSE:\n                perform_traversal_step(&stack_ptr, stack, inodes, num_inodes, inode_bitmap, count_additions);\n                break;\n            case EV_ADD_LINK: {\n                int dir_id = ev.arg1;\n                int target_id = ev.arg2;\n                if (dir_id < num_inodes && inodes[dir_id].type == INODE_DIR && inodes[dir_id].num_entries < MAX_ENTRIES) {\n                    inodes[dir_id].entries[inodes[dir_id].num_entries++] = target_id;\n                }\n                break;\n            }\n            case EV_CREATE_FILE: {\n                int new_inode_id = ev.arg1;\n                int size = ev.arg2;\n                if (new_inode_id < MAX_INODES) {\n                    if (new_inode_id >= num_inodes) num_inodes = new_inode_id + 1;\n                    inodes[new_inode_id] = (Inode){ .id = new_inode_id, .type = INODE_FILE, .size = size, .num_entries = 0 };\n                }\n                break;\n            }\n        }\n    }\n\n    // Continue traversal until the stack is empty.\n    while (stack_ptr > 0) {\n        perform_traversal_step(&stack_ptr, stack, inodes, num_inodes, inode_bitmap, count_additions);\n    }\n    \n    // --- Verification ---\n    // Check if any file's size was added more than once.\n    for (int i = 0; i < num_inodes; ++i) {\n        if (inodes[i].type == INODE_FILE && count_additions[i] > 1) {\n            return 0; // A double-count occurred.\n        }\n    }\n\n    return 1; // No double-counts were detected.\n}\n\n// Executes a single step of the DFS traversal.\nvoid perform_traversal_step(\n    int* stack_ptr,\n    StackFrame stack[],\n    Inode inodes[],\n    int num_inodes,\n    int inode_bitmap[],\n    int count_additions[])\n{\n    if (*stack_ptr <= 0) {\n        return; // Stack is empty, traversal is finished.\n    }\n\n    // Peek at the top frame.\n    StackFrame* frame = &stack[*stack_ptr - 1];\n    \n    if (frame->inode_id < 0 || frame->inode_id >= num_inodes) {\n        (*stack_ptr)--; // Invalid inode ID on stack, pop and return.\n        return;\n    }\n    \n    Inode* dir = &inodes[frame->inode_id];\n    \n    // Check if there are more entries to process in this directory.\n    // The value of dir->num_entries is read here, modeling the race window.\n    if (frame->entry_index < dir->num_entries) {\n        int child_inode_id = dir->entries[frame->entry_index];\n        frame->entry_index++; // Advance index for the next step.\n\n        if (child_inode_id < 0 || child_inode_id >= num_inodes) {\n            return; // Invalid child link, ignore.\n        }\n        Inode* child = &inodes[child_inode_id];\n\n        if (child->type == INODE_DIR) {\n            // Push a new frame for the subdirectory.\n            if (*stack_ptr < MAX_STACK_DEPTH) {\n                stack[*stack_ptr].inode_id = child_inode_id;\n                stack[*stack_ptr].entry_index = 0;\n                (*stack_ptr)++;\n            }\n        } else { // INODE_FILE\n            // Check the bitmap to prevent double-counting.\n            if (inode_bitmap[child_inode_id] == 0) {\n                inode_bitmap[child_inode_id] = 1;\n                count_additions[child_inode_id]++;\n            }\n        }\n    } else {\n        // Finished with this directory, pop it from the stack.\n        (*stack_ptr)--;\n    }\n}\n\n\nint main(void) {\n    // Define the 4 test cases from the problem statement.\n    SimulationTestCase test_cases[] = {\n        [0] = {\n            .name = \"Test Case 1: Late Hard Link\",\n            .num_total_inodes = 4,\n            .initial_inodes = {\n                [0] = { .id=0, .type=INODE_DIR, .num_entries=2, .entries={2, 1} }, // root r\n                [1] = { .id=1, .type=INODE_DIR, .num_entries=1, .entries={3} },    // dir d\n                [2] = { .id=2, .type=INODE_FILE, .size=10 },                       // file f1\n                [3] = { .id=3, .type=INODE_FILE, .size=20 },                       // file f2\n            },\n            .root_inode_id = 0,\n            .num_events = 4,\n            .events = {\n                { .type=EV_TRAVERSE }, // Visit r -> f1\n                { .type=EV_TRAVERSE }, // Visit r -> d, descend\n                { .type=EV_TRAVERSE }, // Visit d -> f2\n                { .type=EV_ADD_LINK, .arg1=0, .arg2=3 }, // Add link r -> f2\n            },\n        },\n        [1] = {\n            .name = \"Test Case 2: Many Hard Links\",\n            .num_total_inodes = 5,\n            .initial_inodes = {\n                [0] = { .id=0, .type=INODE_DIR, .num_entries=3, .entries={1, 2, 3} }, // root r\n                [1] = { .id=1, .type=INODE_DIR }, // dir a\n                [2] = { .id=2, .type=INODE_DIR }, // dir b\n                [3] = { .id=3, .type=INODE_DIR }, // dir c\n                [4] = { .id=4, .type=INODE_FILE, .size=7 }, // file f\n            },\n            .root_inode_id = 0,\n            .num_events = 7,\n            .events = {\n                { .type=EV_TRAVERSE }, // Visit r -> a\n                { .type=EV_ADD_LINK, .arg1=1, .arg2=4 }, // a -> f\n                { .type=EV_TRAVERSE }, // Visit r -> b\n                { .type=EV_ADD_LINK, .arg1=2, .arg2=4 }, // b -> f\n                { .type=EV_TRAVERSE }, // Visit r -> c\n                { .type=EV_ADD_LINK, .arg1=3, .arg2=4 }, // c -> f\n                { .type=EV_TRAVERSE }, // Start processing a, b, or c\n            },\n        },\n        [2] = {\n            .name = \"Test Case 3: Race Window Undercount\",\n            .num_total_inodes = 3,\n            .initial_inodes = {\n                [0] = { .id=0, .type=INODE_DIR, .num_entries=2, .entries={1, 2} }, // root r\n                [1] = { .id=1, .type=INODE_DIR }, // dir x\n                [2] = { .id=2, .type=INODE_DIR }, // dir y\n            },\n            .root_inode_id = 0,\n            .num_events = 6,\n            .events = {\n                { .type=EV_TRAVERSE },     // Visit r -> x\n                { .type=EV_TRAVERSE },     // Process empty x\n                { .type=EV_CREATE_FILE, .arg1=3, .arg2=5 }, // Create g (id=3)\n                { .type=EV_ADD_LINK, .arg1=1, .arg2=3 }, // Add x -> g (too late)\n                { .type=EV_ADD_LINK, .arg1=2, .arg2=3 }, // Add y -> g\n                { .type=EV_TRAVERSE },     // Visit r -> y\n            },\n        },\n        [3] = {\n            .name = \"Test Case 4: Empty File System\",\n            .num_total_inodes = 1,\n            .initial_inodes = {\n                [0] = { .id=0, .type=INODE_DIR }, // root r\n            },\n            .root_inode_id = 0,\n            .num_events = 0, // No events, traversal runs until empty.\n            .events = {},\n        },\n    };\n\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    int results[num_cases];\n\n    for (int i = 0; i < num_cases; ++i) {\n        results[i] = run_simulation(&test_cases[i]);\n    }\n\n    printf(\"[%d,%d,%d,%d]\\n\", results[0], results[1], results[2], results[3]);\n\n    return EXIT_SUCCESS;\n}\n```"
        }
    ]
}