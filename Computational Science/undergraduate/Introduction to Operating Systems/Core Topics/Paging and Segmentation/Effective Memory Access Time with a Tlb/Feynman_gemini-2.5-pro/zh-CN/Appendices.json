{
    "hands_on_practices": [
        {
            "introduction": "程序的内存访问模式是决定TLB性能的关键因素。这个练习通过对比两种截然不同的数据访问方式——具有优秀空间局部性的顺序扫描和破坏局部性的大步长访问——来让你亲身体验这一点。通过计算这两种模式下的有效内存访问时间（$EMAT$），你将直观地看到一个简单的代码改动如何对内存性能产生巨大的影响。",
            "id": "3638194",
            "problem": "一个系统实现了请求分页虚拟内存，带有一个全相联的数据转译后备缓冲器 (DTLB)，并使用最近最少使用 (LRU) 替换策略。DTLB 有 $N = 64$ 个条目。页面大小为 $S = 4$ KiB。考虑一个长度为 $L = 128$ MiB 的连续数组，其中包含 64 位整数（每个元素大小为 $B = 8$ 字节）。该数组的所有页面都存在于物理内存中，没有缺页中断。每次内存访问都需要先进行 DTLB 查找，然后才能进行物理访问。一次 DTLB 命中会在 $t_{\\mathrm{mem}} = 60$ ns 的内存访问时间之前，引入 $t_{\\mathrm{TLB}} = 0.5$ ns 的额外查找开销。一次 DTLB 未命中除了 $t_{\\mathrm{TLB}}$ 外，还会在执行内存访问之前，因页表遍历和 TLB 重新填充而引入 $t_{\\mathrm{miss}} = 80$ ns 的额外转译延迟。假设缓存层次结构不改变这些时间，并且成本如所述以加法方式组合。\n\n请比较在同一个数组上，以下两种数据访问模式下每次访问的有效内存访问时间 ($EMAT$)：\n- 模式 $(a)$：步长为 $1$，即程序按索引递增的顺序依次读取每个元素，顺序访问元素 $0, 1, 2, \\dots$。\n- 模式 $(b)$：步长等于页面大小 $S$，即程序按页面递增的顺序，只读取每个页面的第一个元素一次，访问元素索引 $0, \\frac{S}{B}, 2\\frac{S}{B}, \\dots$ 直到数组末尾。\n\n您需要分别计算模式 $(a)$ 和模式 $(b)$ 的 $EMAT$ 值。将您的答案四舍五入到四位有效数字。每个 $EMAT$ 以纳秒为单位表示。",
            "solution": "该问题是有效的，因为它具有科学依据、问题明确且客观。我们可以进行正式的求解。\n\n有效内存访问时间 ($EMAT$) 是转译后备缓冲器 (TLB) 命中时间和 TLB 未命中时间的加权平均值。设 $h$ 为 TLB 命中率。TLB 命中后的内存访问时间是 TLB 查找时间 $t_{\\mathrm{TLB}}$ 和内存访问时间 $t_{\\mathrm{mem}}$ 的总和。\n$$T_{\\mathrm{hit}} = t_{\\mathrm{TLB}} + t_{\\mathrm{mem}}$$\nTLB 未命中后的内存访问时间是 TLB 查找时间 $t_{\\mathrm{TLB}}$、额外的页表遍历惩罚 $t_{\\mathrm{miss}}$ 和内存访问时间 $t_{\\mathrm{mem}}$ 的总和。\n$$T_{\\mathrm{miss}} = t_{\\mathrm{TLB}} + t_{\\mathrm{miss}} + t_{\\mathrm{mem}}$$\n$EMAT$ 的通用公式为：\n$$EMAT = h \\cdot T_{\\mathrm{hit}} + (1-h) \\cdot T_{\\mathrm{miss}}$$\n代入 $T_{\\mathrm{hit}}$ 和 $T_{\\mathrm{miss}}$ 的表达式：\n$$EMAT = h \\cdot (t_{\\mathrm{TLB}} + t_{\\mathrm{mem}}) + (1-h) \\cdot (t_{\\mathrm{TLB}} + t_{\\mathrm{miss}} + t_{\\mathrm{mem}})$$\n通过提取公因式，可以简化此表达式：\n$$EMAT = (h + (1-h)) \\cdot (t_{\\mathrm{TLB}} + t_{\\mathrm{mem}}) + (1-h) \\cdot t_{\\mathrm{miss}}$$\n$$EMAT = t_{\\mathrm{TLB}} + t_{\\mathrm{mem}} + (1-h) \\cdot t_{\\mathrm{miss}}$$\n我们已知以下值：\n$t_{\\mathrm{TLB}} = 0.5$ ns\n$t_{\\mathrm{mem}} = 60$ ns\n$t_{\\mathrm{miss}} = 80$ ns\n\n首先，我们确定系统参数。\n页面大小为 $S = 4 \\text{ KiB} = 4 \\times 2^{10} \\text{ 字节} = 4096 \\text{ 字节}$。\n元素大小为 $B = 8 \\text{ 字节}$。\n单个页面可以容纳的元素数量为：\n$$N_{\\mathrm{elements\\_per\\_page}} = \\frac{S}{B} = \\frac{4096}{8} = 512$$\n数组的总长度为 $L = 128 \\text{ MiB} = 128 \\times 2^{20} \\text{ 字节}$。\n数组所跨越的总页面数为：\n$$N_{\\mathrm{pages}} = \\frac{L}{S} = \\frac{128 \\times 2^{20}}{4 \\times 2^{10}} = 32 \\times 2^{10} = 32768$$\n数组中的总元素数量为：\n$$N_{\\mathrm{elements}} = \\frac{L}{B} = \\frac{128 \\times 2^{20}}{8} = 16 \\times 2^{20} = 16777216$$\nDTLB 的条目数为 $N = 64$。由于 $N_{\\mathrm{pages}} \\gg N$，DTLB 在任何给定时间只能保存数组总页面转译的一小部分。\n\n现在，我们分析每种访问模式以确定其 TLB 命中率。\n\n模式 (a)：步长为 $1$（顺序访问）\n在这种模式下，程序按 $0, 1, 2, \\dots$ 的顺序读取数组元素。这些访问表现出很强的空间局部性。\n对任何给定页面的第一次访问（例如，对页面 $0$ 上的元素 $0$ 的访问）将导致强制性 TLB 未命中，因为该页面的转译尚不在 DTLB 中。这次未命中导致页面转译被加载到 DTLB 中。\n对同一页面的后续 $N_{\\mathrm{elements\\_per\\_page}} - 1 = 512 - 1 = 511$ 次访问都将是 TLB 命中，因为转译现在驻留在 DTLB 中。\n当程序移动到下一页时，对这个新页面的第一次访问将再次导致 TLB 未命中，如此循环往复。\n由于数组是顺序遍历的，对于每个对应一个页面的 $512$ 次访问块，恰好有 $1$ 次未命中和 $511$ 次命中。LRU 替换策略不会对此模式产生负面影响，因为当一个页面的转译被驱逐时，它已不再被需要。\n模式 (a) 的命中率 $h_a$ 是在任何给定页面遍历中命中次数与总访问次数的比率：\n$$h_a = \\frac{\\text{每页的命中次数}}{\\text{每页的访问次数}} = \\frac{511}{512}$$\n未命中率为 $1 - h_a = \\frac{1}{512}$。\n我们现在可以计算模式 (a) 的 $EMAT$：\n$$EMAT_a = t_{\\mathrm{TLB}} + t_{\\mathrm{mem}} + (1-h_a) \\cdot t_{\\mathrm{miss}}$$\n$$EMAT_a = 0.5 ns + 60 ns + \\left(\\frac{1}{512}\\right) \\cdot 80 ns$$\n$$EMAT_a = 60.5 + 0.15625 = 60.65625 \\text{ ns}$$\n四舍五入到四位有效数字，我们得到 $EMAT_a = 60.66$ ns。\n\n模式 (b)：步长等于页面大小 $S$\n在这种模式下，程序按页面递增的顺序读取每个页面的第一个元素。被访问元素的索引是 $0, \\frac{S}{B}, 2\\frac{S}{B}, \\dots$。\n由于 $\\frac{S}{B} = 512$，被访问的元素索引是 $0, 512, 1024, \\dots$。\n元素 $0$ 在页面 $0$ 上。元素 $512$ 在页面 $1$ 上。元素 $1024$ 在页面 $2$ 上，依此类推。\n每一次访问都是针对一个新的、不同的页面。\n页面访问的序列是 $0, 1, 2, \\dots, 32767$。\n让我们追踪 DTLB 的行为：\n- 访问页面 $0$：未命中。DTLB 被填入页面 $0$ 的转译。\n- 访问页面 $1$：未命中。DTLB 被填入页面 $1$ 的转译。\n- ...\n- 访问页面 $63$：未命中。DTLB 现已填满页面 $0$ 到 $63$ 的转译。\n- 访问页面 $64$：未命中。由于 DTLB 已满并使用 LRU 替换策略，页面 $0$（最近最少使用的）的条目被驱逐，为页面 $64$ 的转译腾出空间。\n这种情况对所有后续访问都持续存在。每次访问都是针对一个其转译不在 DTLB 中的页面，因为页面是以远超 DTLB 容量的序列被访问，且没有重用。因此，每次访问都会导致 DTLB 未命中。\n模式 (b) 的命中率 $h_b$ 为 $0$。\n未命中率为 $1 - h_b = 1$。\n我们现在可以计算模式 (b) 的 $EMAT$：\n$$EMAT_b = t_{\\mathrm{TLB}} + t_{\\mathrm{mem}} + (1-h_b) \\cdot t_{\\mathrm{miss}}$$\n$$EMAT_b = 0.5 ns + 60 ns + (1) \\cdot 80 ns$$\n$$EMAT_b = 60.5 + 80 = 140.5 \\text{ ns}$$\n这个值已经是四位有效数字。\n\n最终值为 $EMAT_a = 60.66$ ns 和 $EMAT_b = 140.5$ ns。",
            "answer": "$$\\boxed{\\begin{pmatrix} 60.66  140.5 \\end{pmatrix}}$$"
        },
        {
            "introduction": "真实的计算机系统很少只运行单一类型的任务。通常是用户程序和操作系统内核代码混合运行，而它们的内存访问行为和TLB命中率可能大不相同。这个练习模拟了这样一个混合工作负载的场景，教你如何通过加权平均来计算系统的总体$EMAT$，从而将$EMAT$的概念从单个进程推广到系统级的性能指标。",
            "id": "3638184",
            "problem": "一个计算机系统使用虚拟内存，并配备一个硬件管理的转换检测缓冲区（TLB）。对于中央处理器（CPU）发起的每一次内存访问，会发生以下情况。首先执行一次延迟为 $t_{\\mathrm{TLB}}$ 的TLB查找。如果TLB查找命中，则获得物理地址，并通过一次延迟为 $t_{\\mathrm{mem}}$ 的主存访问来检索所引用的字。如果TLB查找未命中，硬件页表遍历器将执行一次二级页表遍历，这会产生两次用于访问页表条目的主存访问，以及一个额外的固定遍历器控制开销 $t_{\\mathrm{walk}}$。之后，通过另一次主存访问来获取所引用的字。忽略页错误，并假定页表驻留在主存中。此外，忽略除TLB之外的所有缓存效应，因此所有提到的内存访问都是针对主存的。\n\n工作负载由用户模式和内核模式的内存访问组成。设用户模式访问的比例为 $f_{u}$，内核模式访问的比例为 $f_{k}$，且 $f_{u} + f_{k} = 1$。由于映射策略不同，用户模式访问的TLB命中概率为 $h_{u}$，内核模式访问的TLB命中概率为 $h_{k}$。\n\n使用以下参数，所有时间量单位均为纳秒：$t_{\\mathrm{TLB}} = 2\\,\\text{ns}$， $t_{\\mathrm{mem}} = 60\\,\\text{ns}$， $t_{\\mathrm{walk}} = 6\\,\\text{ns}$， $f_{u} = 0.8$， $f_{k} = 0.2$， $h_{u} = 0.93$， $h_{k} = 0.995$。\n\n计算此混合工作负载的有效内存访问时间（$EMAT$），定义为在所述行为下每次内存访问的期望时间。最终答案以纳秒表示，并四舍五入到四位有效数字。",
            "solution": "该问题要求计算在具有转换检测缓冲区（TLB）的系统中，混合工作负载下的有效内存访问时间（$EMAT$）。该问题表述清晰，具有科学依据，并提供了所有必要的数据。因此，可以推导出解决方案。\n\n有效内存访问时间是单次内存访问的期望时间。工作负载由两种类型的访问组成：用户模式和内核模式。总 $EMAT$ 是每种模式 $EMAT$ 的加权平均值，权重是每种模式下访问的比例。\n$$\nEMAT = f_{u} \\cdot EMAT_{u} + f_{k} \\cdot EMAT_{k}\n$$\n这里，$f_{u}$ 和 $f_{k}$ 分别是用户模式和内核模式访问的比例，而 $EMAT_{u}$ 和 $EMAT_{k}$ 是它们各自的有效内存访问时间。\n\n首先，我们来确定在TLB命中和TLB未命中情况下，一次内存访问所需的时间。\n\n在TLB命中的情况下：\n$1$. 执行一次TLB查找，耗时 $t_{\\mathrm{TLB}}$。\n$2$. 查找命中，因此立即获得物理地址。\n$3$. 执行一次主存访问以检索字，耗时 $t_{\\mathrm{mem}}$。\n因此，TLB命中的总时间 $T_{\\mathrm{hit}}$ 为：\n$$\nT_{\\mathrm{hit}} = t_{\\mathrm{TLB}} + t_{\\mathrm{mem}}\n$$\n\n在TLB未命中的情况下：\n$1$. 执行一次TLB查找，耗时 $t_{\\mathrm{TLB}}$。\n$2$. 查找未命中。硬件页表遍历器被调用。\n$3$. 遍历器执行一次二级页表遍历，需要两次主存访问。这耗时 $2 \\cdot t_{\\mathrm{mem}}$。\n$4$. 遍历器还会产生一个固定的控制开销 $t_{\\mathrm{walk}}$。\n$5$. 页表遍历后，物理地址已知。然后从主存中获取所引用的字，这需要额外耗时 $t_{\\mathrm{mem}}$。\nTLB未命中的总时间 $T_{\\mathrm{miss}}$ 是这些步骤的总和：\n$$\nT_{\\mathrm{miss}} = t_{\\mathrm{TLB}} + (2 \\cdot t_{\\mathrm{mem}} + t_{\\mathrm{walk}}) + t_{\\mathrm{mem}} = t_{\\mathrm{TLB}} + 3 \\cdot t_{\\mathrm{mem}} + t_{\\mathrm{walk}}\n$$\n\n现在，我们可以为特定操作模式（用户或内核）写出 $EMAT$ 的表达式。设 $h$ 为该模式的TLB命中概率。未命中的概率是 $(1-h)$。该模式的 $EMAT$ 是命中时间和未命中时间的加权平均值。\n$$\nEMAT_{\\mathrm{mode}} = h \\cdot T_{\\mathrm{hit}} + (1-h) \\cdot T_{\\mathrm{miss}}\n$$\n代入 $T_{\\mathrm{hit}}$ 和 $T_{\\mathrm{miss}}$ 的表达式：\n$$\nEMAT_{\\mathrm{mode}} = h \\cdot (t_{\\mathrm{TLB}} + t_{\\mathrm{mem}}) + (1-h) \\cdot (t_{\\mathrm{TLB}} + 3 \\cdot t_{\\mathrm{mem}} + t_{\\mathrm{walk}})\n$$\n这个表达式可以重新整理，将命中时间与未命中时产生的额外惩罚分开。TLB未命中惩罚 $T_{\\mathrm{penalty}}$ 是指与命中相比，未命中时所花费的额外时间：\n$$\nT_{\\mathrm{penalty}} = T_{\\mathrm{miss}} - T_{\\mathrm{hit}} = (t_{\\mathrm{TLB}} + 3 \\cdot t_{\\mathrm{mem}} + t_{\\mathrm{walk}}) - (t_{\\mathrm{TLB}} + t_{\\mathrm{mem}}) = 2 \\cdot t_{\\mathrm{mem}} + t_{\\mathrm{walk}}\n$$\n所以，$EMAT$可以表示为命中时间加上未命中的期望惩罚：\n$$\nEMAT_{\\mathrm{mode}} = T_{\\mathrm{hit}} + (1-h) \\cdot T_{\\mathrm{penalty}} = (t_{\\mathrm{TLB}} + t_{\\mathrm{mem}}) + (1-h) \\cdot (2 \\cdot t_{\\mathrm{mem}} + t_{\\mathrm{walk}})\n$$\n\n使用这个公式，我们可以用各自的命中概率 $h_{u}$ 和 $h_{k}$ 来写出 $EMAT_{u}$ 和 $EMAT_{k}$ 的表达式：\n$$\nEMAT_{u} = (t_{\\mathrm{TLB}} + t_{\\mathrm{mem}}) + (1-h_{u}) \\cdot (2 \\cdot t_{\\mathrm{mem}} + t_{\\mathrm{walk}})\n$$\n$$\nEMAT_{k} = (t_{\\mathrm{TLB}} + t_{\\mathrm{mem}}) + (1-h_{k}) \\cdot (2 \\cdot t_{\\mathrm{mem}} + t_{\\mathrm{walk}})\n$$\n\n现在，我们将它们代入总的 $EMAT$ 公式：\n$$\nEMAT = f_{u} \\left[ (t_{\\mathrm{TLB}} + t_{\\mathrm{mem}}) + (1-h_{u})(2 \\cdot t_{\\mathrm{mem}} + t_{\\mathrm{walk}}) \\right] + f_{k} \\left[ (t_{\\mathrm{TLB}} + t_{\\mathrm{mem}}) + (1-h_{k})(2 \\cdot t_{\\mathrm{mem}} + t_{\\mathrm{walk}}) \\right]\n$$\n对各项进行分组：\n$$\nEMAT = (f_{u} + f_{k})(t_{\\mathrm{TLB}} + t_{\\mathrm{mem}}) + [f_{u}(1-h_{u}) + f_{k}(1-h_{k})](2 \\cdot t_{\\mathrm{mem}} + t_{\\mathrm{walk}})\n$$\n由于已知 $f_{u} + f_{k} = 1$，表达式简化为：\n$$\nEMAT = (t_{\\mathrm{TLB}} + t_{\\mathrm{mem}}) + [f_{u}(1-h_{u}) + f_{k}(1-h_{k})](2 \\cdot t_{\\mathrm{mem}} + t_{\\mathrm{walk}})\n$$\n这个最终表达式是基础访问时间（命中时间）加上混合工作负载的总未命中概率乘以未命中惩罚。\n\n我们现在可以代入给定的数值：\n$t_{\\mathrm{TLB}} = 2\\,\\text{ns}$\n$t_{\\mathrm{mem}} = 60\\,\\text{ns}$\n$t_{\\mathrm{walk}} = 6\\,\\text{ns}$\n$f_{u} = 0.8$\n$f_{k} = 0.2$\n$h_{u} = 0.93$\n$h_{k} = 0.995$\n\n首先，计算各个组成部分：\n基础访问时间（命中时间）是：\n$$\nt_{\\mathrm{TLB}} + t_{\\mathrm{mem}} = 2\\,\\text{ns} + 60\\,\\text{ns} = 62\\,\\text{ns}\n$$\n未命中惩罚是：\n$$\n2 \\cdot t_{\\mathrm{mem}} + t_{\\mathrm{walk}} = 2 \\cdot (60\\,\\text{ns}) + 6\\,\\text{ns} = 120\\,\\text{ns} + 6\\,\\text{ns} = 126\\,\\text{ns}\n$$\n混合工作负载的总未命中概率是：\n$$\nf_{u}(1-h_{u}) + f_{k}(1-h_{k}) = 0.8 \\cdot (1 - 0.93) + 0.2 \\cdot (1 - 0.995)\n$$\n$$\n= 0.8 \\cdot (0.07) + 0.2 \\cdot (0.005) = 0.056 + 0.001 = 0.057\n$$\n现在，将这些值代入简化的 $EMAT$ 公式：\n$$\nEMAT = 62\\,\\text{ns} + (0.057) \\cdot (126\\,\\text{ns})\n$$\n$$\nEMAT = 62\\,\\text{ns} + 7.182\\,\\text{ns}\n$$\n$$\nEMAT = 69.182\\,\\text{ns}\n$$\n问题要求答案四舍五入到四位有效数字。数值 $69.182$ 有五位有效数字。四舍五入到四位有效数字得到 $69.18$。",
            "answer": "$$\n\\boxed{69.18}\n$$"
        },
        {
            "introduction": "理解最佳情况很重要，但分析最坏情况同样能带来深刻的洞见。这个练习构建了一个被称为“TLB颠簸”（TLB thrashing）的经典“病态”场景，其中一个精心设计的访问模式会持续地在TLB的同一个组中引发冲突未命中。解决这个问题将加深你对TLB内部机制（如组相联度和替换策略）的理解，并揭示它们如何被特定的访问模式所颠覆。",
            "id": "3638178",
            "problem": "一个处理器使用带有硬件翻译的虚拟内存。它有一个转换后备缓冲区 (TLB)，该 TLB 是组相联的，相联度为 $A$，并采用最近最少使用 (LRU) 替换策略。考虑一对不相交的虚拟内存区域，由页面 $\\{P_{0},P_{1},\\dots,P_{A}\\}$ 组成，这些页面被选择以使得所有 $A+1$ 个页面都映射到同一个 TLB 组。处理器无限期地重复发出一个循环引用流，该引用流按 $P_{0},P_{1},\\dots,P_{A},P_{0},P_{1},\\dots$ 的顺序访问每个页面中的一个字。假设以下时序模型和系统属性。\n\n- TLB 探测耗时 $t_{\\mathrm{TLB}}=0.5$ ns。如果 TLB 探测命中，处理器则在一级 (L1) 数据缓存中执行数据访问，耗时 $t_{\\mathrm{L1}}=1.0$ ns。\n- 如果 TLB 探测未命中，硬件将遍历一个二级页表 ($L=2$)，每一级都需要一次主存访问，耗时 $t_{\\mathrm{MEM}}=50$ ns。页表遍历是串行化的（各级之间没有重叠），其条目不被缓存，遍历后 TLB 会被更新。翻译完成后，处理器执行 L1 数据访问，耗时 $t_{\\mathrm{L1}}=1.0$ ns。\n- 不存在缺页（所有页面都已驻留），并且一旦翻译可用，每次数据访问都会在 L1 缓存中命中。TLB 查找必须在 L1 访问开始之前完成，因此所选路径上的延迟是累加的。\n- 忽略强制性预热效应，并假设循环流处于稳态行为。\n\n仅使用命中、未命中以及互斥情况下的平均时间的定义，分析给定访问模式相对于 TLB 组的稳态行为，并计算在此模式下每次内存引用的稳态有效内存访问时间 (EMAT)。请用纳秒表示最终答案，并四舍五入到四位有效数字。",
            "solution": "问题要求计算给定内存引用模式下的稳态有效内存访问时间 (EMAT)。EMAT 是转换后备缓冲区 (TLB) 命中和 TLB 未命中的访问时间的加权平均值。EMAT 的通用公式是：\n$$\n\\text{EMAT} = (h \\times T_{\\mathrm{hit}}) + (m \\times T_{\\mathrm{miss}})\n$$\n其中 $h$ 是 TLB 命中率，$m$ 是 TLB 未命中率，$T_{\\mathrm{hit}}$ 是 TLB 命中时的内存访问时间，$T_{\\mathrm{miss}}$ 是 TLB 未命中时的内存访问时间。根据定义，每次访问要么是命中，要么是未命中，所以 $h + m = 1$。\n\n首先，我们根据提供的延迟来确定命中和未命中的访问时间。\n\nTLB 命中的时间 $T_{\\mathrm{hit}}$ 包括 TLB 探测时间和随之而来的一级 (L1) 数据缓存访问时间。问题说明这些时间是累加的。\n$$\nT_{\\mathrm{hit}} = t_{\\mathrm{TLB}} + t_{\\mathrm{L1}}\n$$\n给定值 $t_{\\mathrm{TLB}} = 0.5$ ns 和 $t_{\\mathrm{L1}} = 1.0$ ns：\n$$\nT_{\\mathrm{hit}} = 0.5~\\text{ns} + 1.0~\\text{ns} = 1.5~\\text{ns}\n$$\n\nTLB 未命中的时间 $T_{\\mathrm{miss}}$ 包括初始的 TLB 探测时间、硬件页表遍历的时间以及最终的 L1 数据缓存访问时间。页表遍历涉及 $L=2$ 级，每一级都需要一次耗时为 $t_{\\mathrm{MEM}}$ 的主存访问。这些访问是串行化的。\n$$\nT_{\\mathrm{miss}} = t_{\\mathrm{TLB}} + (L \\times t_{\\mathrm{MEM}}) + t_{\\mathrm{L1}}\n$$\n给定值 $t_{\\mathrm{TLB}} = 0.5$ ns，$L = 2$，$t_{\\mathrm{MEM}} = 50$ ns，以及 $t_{\\mathrm{L1}} = 1.0$ ns：\n$$\nT_{\\mathrm{miss}} = 0.5~\\text{ns} + (2 \\times 50~\\text{ns}) + 1.0~\\text{ns} = 0.5~\\text{ns} + 100~\\text{ns} + 1.0~\\text{ns} = 101.5~\\text{ns}\n$$\n\n接下来，我们必须确定稳态命中率 $h$ 和未命中率 $m$。这取决于具体的访问模式和 TLB 的组织结构。系统有一个组相联 TLB，相联度为 $A$，采用最近最少使用 (LRU) 替换策略。访问模式是针对 $A+1$ 个页面 $\\{P_{0}, P_{1}, \\dots, P_{A}\\}$ 的循环流，所有这些页面都映射到*同一个* TLB 组。\n\n让我们分析这个单一 TLB 组的状态。该组有 $A$ 个槽位（或路）用于存储页面翻译。访问流由一个包含 $A+1$ 个不同页面引用的重复周期组成。因为我们正在访问 $A+1$ 个映射到只能容纳 $A$ 个条目的组的页面，所以一旦该组已满，每次访问都保证会发生冲突。\n\n考虑系统处于稳态。让我们追踪序列中对任意页面 $P_i$ 的访问。要使对 $P_i$ 的访问命中，其翻译必须驻留在 TLB 组中。根据 LRU 策略，组中的 $A$ 个条目将是最近使用的 $A$ 个页面的翻译。\n\n访问模式是 $P_{0}, P_{1}, \\dots, P_{A}, P_{0}, \\dots$。紧接在引用页面 $P_i$ 之前的访问序列由 $A$ 个不同的页面 $\\{P_{i-1}, P_{i-2}, \\dots, P_{i-A}\\}$ 组成（索引对 $A+1$ 取模）。例如，在访问 $P_A$ 之前，最后 $A$ 次访问是针对 $P_{A-1}, P_{A-2}, \\dots, P_0$。在下一个周期中访问 $P_0$ 之前，最后 $A$ 次访问是针对 $P_A, P_{A-1}, \\dots, P_1$。\n\n总的来说，在访问页面 $P_i$ 时，TLB 组中的 $A$ 个槽位被最近引用的 $A$ 个页面的翻译所占据，这些页面是 $\\{P_{i-1}, P_{i-2}, \\dots, P_{i-A}\\}$。页面 $P_i$ 本身的翻译不在此组中。因此，对 $P_i$ 的访问将导致 TLB 未命中。\n\n发生此未命中后，将获取 $P_i$ 的翻译。由于 LRU 策略，从组中逐出的条目将是对应于最近最少使用的页面，即 $P_{i-A}$。然后加载 $P_i$ 的新条目。这个未命中和替换的循环在序列中的每次访问中都会重复。每次页面访问都会逐出 $A$ 步之后将需要的翻译，从而保证轮到它时它将不会存在。这种现象被称为抖动。\n\n因此，在稳态下，此模式中的每一次内存引用都会导致 TLB 未命中。\n这导致 TLB 命中率 $h=0$ 和 TLB 未命中率 $m=1$。\n\n现在我们可以使用这些比率计算 EMAT：\n$$\n\\text{EMAT} = (0 \\times T_{\\mathrm{hit}}) + (1 \\times T_{\\mathrm{miss}})\n$$\n$$\n\\text{EMAT} = T_{\\mathrm{miss}}\n$$\n代入计算出的 $T_{\\mathrm{miss}}$ 值：\n$$\n\\text{EMAT} = 101.5~\\text{ns}\n$$\n问题要求答案四舍五入到四位有效数字。值 $101.5$ 已经有四位有效数字。",
            "answer": "$$\n\\boxed{101.5}\n$$"
        }
    ]
}