{
    "hands_on_practices": [
        {
            "introduction": "Understanding memory protection begins with the most fundamental event: the page fault. This exercise challenges you to think like the Memory Management Unit (MMU), the hardware component responsible for enforcing memory boundaries. By calculating the exact virtual address where a fault occurs when a write operation crosses from a valid page into unmapped memory, you will solidify your understanding of address arithmetic and the deterministic nature of hardware-level memory access checks. ",
            "id": "3657608",
            "problem": "Consider a process running on a system that implements paged virtual memory with fixed-size pages. Each page has size $P$ bytes, and virtual addresses are integers in units of bytes. The Central Processing Unit (CPU) consults the Memory Management Unit (MMU) to translate each virtual address to a physical address; the MMU uses the page table hierarchy and raises a page fault if the translation indicates that the referenced page is not present or if the requested access violates the protection bits of the page.\n\nAssume a contiguous layout in the virtual address space as follows:\n- One mapped page with write permission spans addresses $[B, B+P)$.\n- Immediately following it, there is an unmapped gap of $g$ consecutive pages spanning addresses $[B+P, B+P+gP)$, where $g$ is a positive integer.\n- Immediately following the gap, there is another mapped page (possibly with different protection) spanning $[B+P+gP, B+P+(g+1)P)$.\n\nA thread performs a forward, byte-granular write of a contiguous buffer of length $L$ bytes starting at virtual address $S$, where $B \\leq S < B+P$, and $L > B+P - S$ so the write crosses into the next page. The write touches addresses in the increasing sequence $S, S+1, S+2, \\dots, S+L-1$.\n\nUsing only the definitions of paging, page boundaries, and protection checks, derive the first virtual address at which the MMU will raise a fault during this write, knowing that the first page after $[B, B+P)$ is the first page of the unmapped gap. Express your final answer as a single closed-form analytic expression in terms of $S$ and $P$ only, in bytes. No rounding is required.\n\nAdditionally, provide a brief qualitative discussion explaining whether the protection bits of the mapped page immediately after the gap influence the hardware’s classification of the fault caused by the first access into the gap (for example, whether it is considered a “not-present” fault versus a “protection” fault). Your discussion should rely solely on first principles of MMU address translation and page protection semantics.",
            "solution": "The problem asks for the first virtual address that will cause a fault during a sequential write operation, and for a qualitative discussion about the nature of that fault. We will address these two parts in order.\n\nFirst, we must determine the virtual address of the first fault.\nThe system uses paged virtual memory with a fixed page size of $P$ bytes. A virtual address $V$ is located on a specific page. The starting address of the page containing $V$ can be calculated as $P \\times \\lfloor V/P \\rfloor$, where $\\lfloor \\cdot \\rfloor$ denotes the floor function. The page containing $V$ spans the address range $[P \\times \\lfloor V/P \\rfloor, P \\times \\lfloor V/P \\rfloor + P)$.\n\nThe problem states that a write operation starts at a virtual address $S$ which is located within a mapped page that spans the range $[B, B+P)$. This implies that $B$ is the starting address of a page. From the general formula, the starting address of the page containing $S$ is $P \\times \\lfloor S/P \\rfloor$. Therefore, we can establish the identity:\n$$B = P \\times \\left\\lfloor \\frac{S}{P} \\right\\rfloor$$\nThis page has write permission, so any write accesses to addresses within this page will succeed without generating a fault. The write operation accesses bytes at addresses $S, S+1, S+2, \\dots$ in sequence. All write accesses to addresses $V$ such that $S \\le V < B+P$ are therefore valid.\n\nThe problem specifies that the length of the write buffer, $L$, is greater than the remaining space in the initial page, i.e., $L > (B+P) - S$. This condition guarantees that the write operation will attempt to access addresses beyond the end of the first page. The last valid address in the first page is $B+P-1$. The sequential write will access this address and then attempt to access the next byte at address $(B+P-1)+1 = B+P$.\n\nThe problem states that the address range $[B+P, B+P+gP)$ is an \"unmapped gap\". This means there is no valid virtual-to-physical address mapping for any address $V$ in this range. When the Memory Management Unit (MMU) attempts to translate the virtual address $B+P$, it will find that the corresponding page table entry (PTE) is invalid (e.g., the 'present' bit is $0$). This failed translation attempt immediately causes the hardware to raise a page fault.\n\nSince the write accesses addresses in increasing order starting from a valid region, the very first address that falls into the unmapped gap will be the first address to cause a fault. This address is precisely $B+P$.\n\nTo express the final answer in terms of only $S$ and $P$, as required, we substitute the expression for $B$ we derived earlier:\n$$V_{\\text{fault}} = B+P = \\left( P \\times \\left\\lfloor \\frac{S}{P} \\right\\rfloor \\right) + P$$\nThis expression can be simplified by factoring out $P$:\n$$V_{\\text{fault}} = P \\times \\left( \\left\\lfloor \\frac{S}{P} \\right\\rfloor + 1 \\right)$$\nThis is the closed-form analytic expression for the first virtual address at which the MMU will raise a fault.\n\nSecond, we provide the qualitative discussion regarding the fault type.\nThe question is whether the protection bits of the mapped page immediately after the unmapped gap influence the hardware's classification of the fault that occurs at address $V_{\\text{fault}} = B+P$.\n\nThe address translation mechanism performed by the MMU is deterministic and localized. To translate a virtual address $V$, the MMU determines its virtual page number (VPN), $VPN(V) = \\lfloor V/P \\rfloor$, and uses this to index into the page table structure to find the corresponding PTE. The fault occurs at address $B+P$, which is the first address in the unmapped gap. The MMU's action is determined entirely by the contents of the PTE for the page containing this address.\n\nThe problem states this page is \"unmapped\". In the context of MMU hardware, this means the PTE for this page will be marked as invalid (e.g., a 'present' or 'valid' bit is set to $0$). The MMU's logic prioritizes this check. If the page is not marked as present, the MMU cannot proceed to check protection bits (read/write/execute) because there is no valid physical frame to protect. The MMU immediately signals a fault to the CPU, and the hardware typically reports the cause as a \"not-present\" or \"invalid page\" fault.\n\nThe properties of the page after the gap, which starts at address $B+P+gP$, are described by a completely different PTE. The MMU hardware does not look ahead at other PTEs when translating a specific address. The translation process for address $B+P$ is independent of the mapping or protection status of the page starting at $B+P+gP$. Therefore, the protection bits of the mapped page following the gap have absolutely no influence on the classification of the fault caused by the first access into the gap. The fault is unequivocally classified based on the invalid mapping of the accessed page itself.",
            "answer": "$$\\boxed{P \\times \\left( \\left\\lfloor \\frac{S}{P} \\right\\rfloor + 1 \\right)}$$"
        },
        {
            "introduction": "Memory protection is not just a restrictive mechanism, but a powerful tool for building reliable software. This practice explores a classic use case: stack guard pages, which prevent stack overflows from silently corrupting adjacent memory regions. By connecting the high-level concept of recursive function calls to the low-level reality of page permissions, you will see how a simple hardware feature can transform a dangerous bug into a predictable and manageable fault. ",
            "id": "3657704",
            "problem": "An operating system uses demand paging with per-page access permissions enforced by the memory management unit (MMU). Each virtual memory page has a size of $P$ bytes. The stack for a particular thread is placed in a region where virtual pages alternate between data pages with read and write permissions ($\\text{rw}$, non-executable) and guard pages with execute-only permission ($\\text{--x}$), in the repeating pattern $\\text{rw}, \\text{--x}, \\text{rw}, \\text{--x}, \\dots$. The stack grows toward lower addresses. The thread begins execution with the stack pointer aligned to the top of an $\\text{rw}$ page and with $0$ bytes currently used in that page. Each recursive function call consumes a fixed-size activation record of $F$ bytes that is laid out contiguously on the stack. The hardware raises a protection fault immediately upon any read or write that targets a page whose corresponding permission bit (read or write) is not set.\n\nStarting from the definitions of page size, page permissions, and the MMU’s access checks, derive a closed-form expression for the maximum number of completed recursive calls $d$ that can be performed before the first protection fault occurs in this configuration. Your derivation should proceed from first principles, explicitly identifying the resource that limits stack growth and how the MMU enforces that limit, without invoking any pre-derived shortcut formulas. Express your final answer in terms of $P$ and $F$ using standard mathematical operators and, if needed, an appropriate integer-rounding operator. No rounding by significant figures is required. Also, in a few sentences within your reasoning, explain how the presence of the execute-only guard pages prevents silent memory corruption compared to a design where all pages are $\\text{rw}$.",
            "solution": "The problem asks for the maximum number of completed recursive calls, $d$, before a protection fault occurs. The solution requires analyzing the memory layout, the stack growth mechanism, and the conditions under which the Memory Management Unit (MMU) generates a fault.\n\nThe operating system has configured the virtual address space for the thread's stack such that usable memory pages are separated by protected guard pages. The pattern is $\\text{rw}, \\text{--x}, \\text{rw}, \\text{--x}, \\dots$. Each page, whether an $\\text{rw}$ data page or a $\\text{--x}$ guard page, has a size of $P$ bytes.\n\nThe stack grows toward lower memory addresses. The problem states that the stack pointer begins at the top of an $\\text{rw}$ page. This initial $\\text{rw}$ page provides a contiguous block of $P$ bytes of memory where read and write operations are permitted. The page immediately below this one in the address space is a guard page with $\\text{--x}$ permissions. Any attempt to read from or write to this guard page will trigger a protection fault, as the necessary $\\text{r}$ or $\\text{w}$ permission bits are not set for that page.\n\nEach recursive function call consumes a fixed-size activation record of $F$ bytes. For $d$ completed recursive calls, the total memory consumed on the stack is $d \\times F$ bytes. The thread can execute without faults as long as all memory writes required for pushing these activation records occur within the initial $\\text{rw}$ page. This page provides exactly $P$ bytes of usable stack space. Therefore, the total memory consumed must be less than or equal to $P$. This gives us the inequality:\n$$d \\times F \\le P$$\n\nWe are looking for the maximum number of *completed* calls, which corresponds to the maximum integer value of $d$ that satisfies this condition. Assuming $F > 0$, we can divide by $F$:\n$$d \\le \\frac{P}{F}$$\n\nSince $d$ must be an integer representing the number of calls, the maximum value it can take is the largest integer that is less than or equal to $\\frac{P}{F}$. This is, by definition, the floor of the expression $\\frac{P}{F}$.\n$$d_{max} = \\left\\lfloor \\frac{P}{F} \\right\\rfloor$$\nAfter $d_{max}$ calls, the total stack usage is $\\lfloor \\frac{P}{F} \\rfloor \\times F$, which is less than or equal to $P$. Thus, all memory access for the first $d_{max}$ calls falls within the initial $\\text{rw}$ page.\n\nThe $(d_{max} + 1)$-th call would attempt to push another activation record of size $F$. The total memory required would be $(\\lfloor \\frac{P}{F} \\rfloor + 1) \\times F$, which is greater than $P$. This means the write operation will cross the page boundary and target an address within the adjacent $\\text{--x}$ guard page, causing an immediate protection fault. Therefore, the $(d_{max} + 1)$-th call cannot complete.\n\nThe presence of the execute-only ($\\text{--x}$) guard pages is a critical security and reliability feature. In a system where all pages were $\\text{rw}$, a stack overflow would cause the stack to grow into an adjacent memory region, such as the heap or another thread's stack. This would silently corrupt data in that region, leading to unpredictable program behavior and difficult-to-diagnose crashes. By placing a non-writable guard page next to the stack's allocated region, any attempt to grow the stack beyond its limit results in an immediate, deterministic hardware protection fault. This fault is caught by the operating system, which typically terminates the offending process, turning a silent data corruption bug into an easily identifiable crash at the exact point of the error.",
            "answer": "$$\\boxed{\\left\\lfloor \\frac{P}{F} \\right\\rfloor}$$"
        },
        {
            "introduction": "Real-world programs rarely operate on a single byte at a time; they use functions that access large blocks of memory. This exercise delves into the critical problem of partial success, where an operation crossing a protection boundary fails mid-way, leaving data in an inconsistent state. You will analyze this failure mode and evaluate software-level strategies to build robust, \"all-or-nothing\" operations, a key skill for any systems programmer. ",
            "id": "3657635",
            "problem": "A user-space program on a $64$-bit Operating System (OS) runs on hardware that enforces virtual memory protection via a Memory Management Unit (MMU). Pages are contiguous regions of virtual memory of size $4096$ bytes, and each page has an associated access-rights vector (e.g., read-only, read-write). The MMU causes a protection fault when an instruction attempts to access a page in a manner not permitted by that page’s rights; the OS delivers a Signal Segmentation Violation (SIGSEGV) to the process upon such a fault. Consider the following situation:\n\n- A destination array begins at virtual address $V$ such that $V \\bmod 4096 = 4080$.\n- The first page containing the start of the destination has read-write permission, and the immediately following page is read-only.\n- A source buffer is fully readable and at least $64$ bytes long.\n- The program calls a standard C library function that copies bytes from the source to the destination in increasing-address order (assume it issues ordinary store instructions that write to the destination and does not use prefetches or non-fault-suppressing speculative stores that would write beyond the page boundary before reaching it).\n\nStarting from the core definitions above (page size and offset arithmetic, MMU enforcement of per-page rights, and process signal delivery on protection violation), reason about the failure mode when attempting to copy $64$ bytes from the source into the destination. Then, evaluate how one might design an all-or-nothing copy (either the full $64$ bytes are written or none are) using page protection changes. Choose all statements that are correct under these assumptions.\n\nA. With page size $4096$ and destination page offset $4080$, copying $64$ bytes writes exactly $16$ bytes into the first page before the first attempted write to the second page triggers a protection fault, causing Signal Segmentation Violation (SIGSEGV). After the fault, the destination contains the first $16$ bytes from the source; no bytes in the second page were modified.\n\nB. The copy completes without fault because the implementation can upgrade page permissions on demand; the MMU allows writing into a read-only page when the write follows a prior successful write to a neighboring page.\n\nC. Marking only the first page temporarily read-only via a protection change before the copy guarantees an all-or-nothing outcome without any signal handling or rollback, because the MMU will prevent any partial writes and the program can simply reattempt the copy afterward to complete it.\n\nD. To ensure all-or-nothing semantics before performing the copy, compute the set of pages covering the destination range and attempt to change their protection to include write access via a protection-change system call (e.g., making both pages read-write). If the protection change for any page fails, abort the copy so no bytes are written; if all succeed, perform the $64$-byte copy and then restore the original protection configuration. This approach yields atomicity at page granularity.\n\nE. Using language-level exceptions (e.g., a try-catch block) around the copy ensures an all-or-nothing outcome because exceptions are raised before any writes occur, preventing partial copies across page boundaries.\n\nSelect all correct options.",
            "solution": "First, let's analyze the initial failure mode as described in the problem.\n\nThe page size is $4096$ bytes. Addresses within a page are identified by offsets from $0$ to $4095$. The destination array starts at a virtual address $V$ such that its offset within the page is $4080$. Let's call the page containing address $V$ as \"Page 1\" and the subsequent page as \"Page 2\". Page 1 has read-write permissions and Page 2 has read-only permissions.\n\nThe number of bytes available for writing in Page 1, starting from address $V$, is:\n$$ \\text{Bytes remaining in Page 1} = \\text{Page Size} - \\text{Start Offset} = 4096 - 4080 = 16 \\text{ bytes} $$\nThese $16$ bytes correspond to the address range $[V, V+15]$.\n\nThe program attempts to copy $64$ bytes. The copy operation proceeds in increasing-address order.\n1.  The first $16$ bytes are copied to the address range $[V, V+15]$. All these addresses fall within Page 1, which is writable. These $16$ store operations will succeed.\n2.  The $17$-th byte is to be written to address $V+16$. This address is the first byte of the next page, Page 2.\n3.  When the CPU attempts a store instruction to address $V+16$ in the read-only Page 2, the MMU will detect a write attempt to a read-only page and trigger a protection fault.\n4.  The OS fault handler delivers a SIGSEGV signal to the process. The first $16$ writes have already completed and modified memory in Page 1, but the fault prevents the $17$-th write and all subsequent writes.\n\nThis initial analysis confirms that the copy operation fails, resulting in a partial write of $16$ bytes. Now, we evaluate each option:\n\n---\n\n**A. With page size $4096$ and destination page offset $4080$, copying $64$ bytes writes exactly $16$ bytes into the first page before the first attempted write to the second page triggers a protection fault, causing Signal Segmentation Violation (SIGSEGV). After the fault, the destination contains the first $16$ bytes from the source; no bytes in the second page were modified.**\n\nThis statement perfectly matches our derived analysis. The calculation of $16$ bytes being successfully written is correct. The fault occurs on the first write to the second, read-only page. The consequence is a SIGSEGV and a partially modified destination.\n\nVerdict: **Correct**\n\n---\n\n**B. The copy completes without fault because the implementation can upgrade page permissions on demand; the MMU allows writing into a read-only page when the write follows a prior successful write to a neighboring page.**\n\nThis statement is incorrect. Standard hardware MMUs do not dynamically change permissions based on access patterns. A write to a page marked as read-only will always fault. Permissions are changed explicitly by the OS.\n\nVerdict: **Incorrect**\n\n---\n\n**C. Marking only the first page temporarily read-only via a protection change before the copy guarantees an all-or-nothing outcome without any signal handling or rollback, because the MMU will prevent any partial writes and the program can simply reattempt the copy afterward to complete it.**\n\nThis statement is incorrect. If the first page is marked read-only, the very first write attempt will cause an immediate protection fault and a SIGSEGV. This prevents any partial write. However, without a custom signal handler for SIGSEGV, the process's default action is termination. The program cannot \"simply reattempt the copy afterward\" without handling the signal, which contradicts the claim.\n\nVerdict: **Incorrect**\n\n---\n\n**D. To ensure all-or-nothing semantics before performing the copy, compute the set of pages covering the destination range and attempt to change their protection to include write access via a protection-change system call (e.g., making both pages read-write). If the protection change for any page fails, abort the copy so no bytes are written; if all succeed, perform the $64$-byte copy and then restore the original protection configuration. This approach yields atomicity at page granularity.**\n\nThis describes a correct and robust \"pre-flight check\" software pattern.\n1.  **Check:** Use a system call (like `mprotect`) to request write permissions for all destination pages.\n2.  **Failure:** If the call fails, abort the operation. No bytes have been copied.\n3.  **Success:** If the call succeeds, both pages are now writable. The copy will complete without fault. Afterwards, original permissions can be restored.\nThis correctly implements \"all-or-nothing\" semantics by verifying writability before acting.\n\nVerdict: **Correct**\n\n---\n\n**E. Using language-level exceptions (e.g., a try-catch block) around the copy ensures an all-or-nothing outcome because exceptions are raised before any writes occur, preventing partial copies across page boundaries.**\n\nThis statement is incorrect. It confuses language-level exceptions with hardware faults/signals. A SIGSEGV is not a standard C++ exception and cannot be caught by a `try-catch` block. More fundamentally, the fault is triggered by the $17$-th attempted write, *after* the first $16$ writes have already succeeded. A partial copy has already occurred before the fault is generated, so this mechanism cannot prevent it.\n\nVerdict: **Incorrect**",
            "answer": "$$\\boxed{AD}$$"
        }
    ]
}