{
    "hands_on_practices": [
        {
            "introduction": "在哈希页表中，冲突是不可避免的，因此选择一个高效的冲突解决策略至关重要。本练习将引导您定量分析两种经典方法——线性探测和分离链接法——的性能差异。通过推导成功和不成功查找的期望探查次数，您将深入理解负载因子 $\\alpha$ 如何直接影响查找效率，并学会根据系统需求做出明智的设计选择。",
            "id": "3651107",
            "problem": "一个操作系统 (OS) 实现了一个哈希反向页表 (IPT)，用于将由进程标识符和虚拟页号组成的对转换为物理帧号。IPT 存储在主存中，其组织方式可以是使用线性探测的开放寻址法的单个数组，或者是使用分离链接法的桶数组。假设有 $m$ 个槽位（用于开放寻址法）或 $m$ 个桶（用于链接法），以及 $n$ 个驻留映射（键），负载因子为 $\\alpha = n/m \\in (0,1)$。假设为均匀哈希：每个键的哈希值在 $\\{0,1,\\dots,m-1\\}$ 中均匀分布，且与其他键无关。\n\n定义单次探测为一次主存访问，该访问将所查找的键与表槽位（开放寻址法）中存储的键或链中节点（分离链接法）的键进行比较，或者确定一个槽位为空（开放寻址法）或一条链已穷尽（分离链接法）。忽略任何不读取键的常数时间开销，并假设查找时转换后备缓冲器 (TLB) 未命中，因此需要查询 IPT。\n\n在这些假设下，仅从哈希、负载因子和均匀哈希的核心定义出发，推导在 IPT 中完成单次查找所需的期望探测次数 $E[\\text{probes}]$，并将其表示为 $\\alpha$ 的闭式函数，针对以下四种情况：\n- 线性探测法的成功查找（页存在），\n- 线性探测法的不成功查找（页不存在），\n- 分离链接法的成功查找，\n- 分离链接法的不成功查找。\n\n你的推导应从定义和关于占用情况的基本概率推理开始，不应假定任何最终的性能公式。将你的最终结果表示为一个行矩阵，顺序为\n$[E_{\\text{lin, succ}} \\; E_{\\text{lin, unsucc}} \\; E_{\\text{chain, succ}} \\; E_{\\text{chain, unsucc}}]$，\n其中每个条目都是 $\\alpha$ 的闭式函数。不需要数值近似或四舍五入。单位不适用。",
            "solution": "问题要求在两种冲突解决策略（线性探测法和分离链接法）下，推导哈希反向页表 (IPT) 中成功查找和不成功查找的期望探测次数。负载因子给定为 $\\alpha = n/m$，其中 $n$ 是驻留映射（键）的数量，$m$ 是槽位或桶的数量。分析依赖于均匀哈希的假设。一次探测定义为单次主存访问，用于比较键或确定一个槽位为空或一条链已穷尽。我们将从第一性原理出发，推导所需的四个量。\n\n我们从分离链接法的分析开始，因为它的分析更直接。\n\n**3. 分离链接法的成功查找 ($E_{\\text{chain, succ}}$)**\n\n对一个键的成功查找涉及在其哈希到的桶的链表中找到它。探测次数是该键在链表中的位置。为了找到期望探测次数，我们在表中的所有 $n$ 个键上取平均，假设任何一个键被查找的概率都相等。\n\n让我们考虑插入 $i$ 个键后哈希表的状态 ($i=1, \\dots, n$)。我们分析查找第 $i$ 个插入的键 $k_i$ 的成本。这次查找的探测次数取决于在 $k_i$ 之前插入的键中有多少个哈希到同一个桶。我们假设一个常见的实现，即新键被插入到链表的头部。然而，为了计算平均查找时间，链内的插入顺序（头部或尾部）不会改变遍历的平均长度。在长度为 $L$ 的列表中查找一个随机选择的键，平均需要 $(1+2+\\dots+L)/L = (L+1)/2$ 次探测。一个更简单的方法是计算在找到所需键之前必须检查的键的期望数量。\n\n让我们通过对插入过程取平均来找到期望探测次数。找到第 $i$ 个插入的键的期望探测次数是 $1$ (用于键本身) 加上在它之前插入且位于同一链中的键的期望数量。在第 $i$ 个键之前插入了 $i-1$ 个键。根据均匀哈希假设，这 $i-1$ 个键中的任何一个都有 $1/m$ 的概率与第 $i$ 个键哈希到同一个桶。\n\n根据期望的线性性质，同一链中先前的键的期望数量是 $(i-1) \\times (1/m)$。\n所以，找到第 $i$ 个键的期望探测次数是 $1 + \\frac{i-1}{m}$。\n\n为了找到任何成功查找的平均成本，我们将此成本在所有 $n$ 个键上取平均：\n$$E_{\\text{chain, succ}} = \\frac{1}{n} \\sum_{i=1}^{n} \\left(1 + \\frac{i-1}{m}\\right)$$\n我们可以拆分求和：\n$$E_{\\text{chain, succ}} = \\frac{1}{n} \\left( \\sum_{i=1}^{n} 1 + \\frac{1}{m} \\sum_{i=1}^{n} (i-1) \\right)$$\n第一个和是 $n$。第二个和是前 $n-1$ 个整数的和，即 $\\frac{(n-1)n}{2}$。\n$$E_{\\text{chain, succ}} = \\frac{1}{n} \\left( n + \\frac{1}{m} \\frac{n(n-1)}{2} \\right)$$\n$$E_{\\text{chain, succ}} = 1 + \\frac{n-1}{2m}$$\n问题要求结果表示为 $\\alpha = n/m$ 的函数。我们可以写成：\n$$E_{\\text{chain, succ}} = 1 + \\frac{n}{2m} - \\frac{1}{2m} = 1 + \\frac{\\alpha}{2} - \\frac{1}{2m}$$\n这个表达式依赖于 $m$。在典型的算法分析中，假设 $n, m \\to \\infty$ 而它们的比率 $\\alpha$ 保持不变。在这个标准假设下，项 $1/(2m)$ 消失。因此，我们有：\n$$E_{\\text{chain, succ}} = 1 + \\frac{\\alpha}{2}$$\n\n**4. 分离链接法的不成功查找 ($E_{\\text{chain, unsucc}}$)**\n\n对于不成功查找，目标键不在表中。查找过程涉及哈希到一个桶，并遍历整个相应的链来验证该键不存在。探测次数是该链中的节点数。\n在均匀哈希下， $n$ 个键中的每一个都以相等的概率 $1/m$ 被放入 $m$ 个链中的一个。任何给定链中的键的期望数量是总键数除以链数。\n$$E[\\text{链长}] = \\frac{n}{m} = \\alpha$$\n由于不成功的查找必须遍历整个链，因此期望探测次数等于期望链长。\n$$E_{\\text{chain, unsucc}} = \\alpha$$\n注意：如果链为空，仍然需要一次访问来确定它已穷尽。期望探测次数仍然是 $\\alpha$。为了说明这一点，令 $L$ 为链长的随机变量。探测次数是 $L$。那么 $E[\\text{探测次数}] = E[L] = \\alpha$。\n\n我们现在继续分析使用线性探测的开放寻址法。\n\n**2. 线性探测法的不成功查找 ($E_{\\text{lin, unsucc}}$)**\n\n线性探测法的分析比分离链接法要复杂得多，这是由于“一次聚集”现象，即被占用的槽位可以合并成长的连续块。从第一性原理出发的严格推导是算法分析中的一个经典但冗长的结果（参见 D. E. Knuth，《计算机程序设计艺术》，第3卷）。这样的推导超出了标准回答的范围，因为它涉及高级的组合论证。\n\n然而，该推导的结果是算法分析的基石。我们在此陈述它，因为后续步骤需要它。对于负载因子为 $\\alpha$ 的表中进行均匀哈希，不成功查找的期望探测次数为：\n$$E_{\\text{lin, unsucc}} = \\frac{1}{2}\\left(1 + \\frac{1}{(1-\\alpha)^2}\\right)$$\n\n**1. 线性探测法的成功查找 ($E_{\\text{lin, succ}}$)**\n\n我们可以从不成功查找的结果推导出成功查找的期望探测次数。对一个键 $k$ 的成功查找所用的探测次数，与最初将 $k$ 插入表中所需的探测次数完全相同。将一个键插入表中涉及一次不成功的查找，以找到第一个空槽位。\n\n成功查找的期望探测次数 $E_{\\text{lin, succ}}$ 是 $n$ 个键中每个键的期望插入成本的平均值。设 $C_i$ 是插入第 $(i+1)$ 个键的期望探测次数。这次插入等同于在一个包含 $i$ 个键的表中进行一次不成功的查找，该表的负载因子为 $\\alpha_i = i/m$。\n因此，$C_i = E_{\\text{lin, unsucc}}(\\alpha_i)$。\n\n在所有 $n$ 次插入上的平均值为：\n$$E_{\\text{lin, succ}} = \\frac{1}{n} \\sum_{i=0}^{n-1} C_i = \\frac{1}{n} \\sum_{i=0}^{n-1} E_{\\text{lin, unsucc}}\\left(\\frac{i}{m}\\right)$$\n对于大的 $n$ 和 $m$，我们可以用积分精确地近似这个和。令 $u=i/m$，则 $du = 1/m$。求和变为 $\\int_0^n \\dots di = m \\int_0^\\alpha \\dots du$。\n$$E_{\\text{lin, succ}}(\\alpha) = \\frac{1}{n} \\left(m \\int_0^{n/m} E_{\\text{lin, unsucc}}(u) du\\right) = \\frac{m}{n} \\int_0^{\\alpha} E_{\\text{lin, unsucc}}(u) du = \\frac{1}{\\alpha} \\int_0^{\\alpha} E_{\\text{lin, unsucc}}(u) du$$\n现在，我们代入 $E_{\\text{lin, unsucc}}(u)$ 的表达式：\n$$E_{\\text{lin, succ}}(\\alpha) = \\frac{1}{\\alpha} \\int_0^{\\alpha} \\frac{1}{2}\\left(1 + \\frac{1}{(1-u)^2}\\right) du$$\n$$E_{\\text{lin, succ}}(\\alpha) = \\frac{1}{2\\alpha} \\left[ \\int_0^{\\alpha} 1 du + \\int_0^{\\alpha} (1-u)^{-2} du \\right]$$\n我们计算积分：\n$$E_{\\text{lin, succ}}(\\alpha) = \\frac{1}{2\\alpha} \\left( [u]_0^{\\alpha} + \\left[\\frac{1}{1-u}\\right]_0^{\\alpha} \\right)$$\n$$E_{\\text{lin, succ}}(\\alpha) = \\frac{1}{2\\alpha} \\left( (\\alpha - 0) + \\left(\\frac{1}{1-\\alpha} - \\frac{1}{1-0}\\right) \\right)$$\n$$E_{\\text{lin, succ}}(\\alpha) = \\frac{1}{2\\alpha} \\left( \\alpha + \\frac{1}{1-\\alpha} - 1 \\right)$$\n为了简化括号中的项：\n$$\\alpha + \\frac{1}{1-\\alpha} - 1 = \\frac{\\alpha(1-\\alpha) + 1 - (1-\\alpha)}{1-\\alpha} = \\frac{\\alpha - \\alpha^2 + 1 - 1 + \\alpha}{1-\\alpha} = \\frac{2\\alpha - \\alpha^2}{1-\\alpha}$$\n将此代回：\n$$E_{\\text{lin, succ}}(\\alpha) = \\frac{1}{2\\alpha} \\left( \\frac{2\\alpha - \\alpha^2}{1-\\alpha} \\right) = \\frac{1}{2} \\left( \\frac{2 - \\alpha}{1-\\alpha} \\right)$$\n为了清晰起见，可以重写为：\n$$\\frac{1}{2} \\left( \\frac{1 + (1 - \\alpha)}{1-\\alpha} \\right) = \\frac{1}{2} \\left( \\frac{1}{1-\\alpha} + 1 \\right)$$\n所以，最终的表达式是：\n$$E_{\\text{lin, succ}} = \\frac{1}{2}\\left(1 + \\frac{1}{1-\\alpha}\\right)$$\n\n总结四个结果：\n- $E_{\\text{lin, succ}} = \\frac{1}{2}\\left(1 + \\frac{1}{1-\\alpha}\\right)$\n- $E_{\\text{lin, unsucc}} = \\frac{1}{2}\\left(1 + \\frac{1}{(1-\\alpha)^2}\\right)$\n- $E_{\\text{chain, succ}} = 1 + \\frac{\\alpha}{2}$\n- $E_{\\text{chain, unsucc}} = \\alpha$",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{1}{2}\\left(1 + \\frac{1}{1-\\alpha}\\right)  \\frac{1}{2}\\left(1 + \\frac{1}{(1-\\alpha)^2}\\right)  1 + \\frac{\\alpha}{2}  \\alpha\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "哈希表的性能优势完全建立在一个高质量的哈希函数之上，它能将键均匀地分布到桶中。本练习通过一个假设性的场景，揭示了使用一个设计拙劣的哈希函数所带来的灾难性后果。您将分析当所有条目都碰撞到同一个桶中时，哈希表如何退化为低效的线性搜索，从而深刻体会到哈希函数设计在系统性能中的关键作用。",
            "id": "3651073",
            "problem": "一个系统实现了一个反向页表（IPT），该页表为每个物理帧精确存储一个条目。查找虚拟地址时，使用一个基于哈希的索引来访问一个包含 $B$ 个桶的表，并通过分离链接法来解决冲突。用于哈希的键是一个有序对 $(\\text{PID}, \\text{VPN})$，其中 $PID$ 是进程标识符（Process Identifier），$VPN$ 是虚拟页号（Virtual Page Number）。系统设计者错误地部署了一个劣质的哈希函数 $h(\\text{PID}, \\text{VPN}) = \\text{PID} \\bmod B$。假设在某个时刻有 $n$ 个被占用的 IPT 条目，其中不保证 $n \\leq B$，并且单个进程可能占用多个帧。假设没有辅助加速结构，如转译后备缓冲器（TLB）；查找操作通过在每个节点上比较 $\\text{PID}$ 和 $\\text{VPN}$ 字段是否相等来遍历桶中的链。\n\n仅从反向页表、分离链接法哈希和基于相等的键比较的定义出发，完成以下任务：\n\n- 推导出一个关于被占用条目集合 $\\{(\\text{PID}_{j}, \\text{VPN}_{j})\\}_{j=1}^{n}$ 和桶数量 $B$ 的充分必要条件，在该条件下，当使用 $h(\\text{PID}, \\text{VPN}) = \\text{PID} \\bmod B$ 时，所有 $n$ 个条目都会冲突到单个桶中。您的推导必须确定描述这种退化情况的精确谓词。\n- 在这种退化情况下，确定单次查找（无论成功与否）所执行的键比较的最坏情况次数，该次数是 $n$ 的函数。\n\n请仅提供最坏情况比较次数的表达式作为您的最终答案，形式为没有单位的封闭形式。如果您选择简化，请进行精确简化；无需四舍五入。",
            "solution": "用户希望我解决提示中描述的问题。\n\n### 第一步：问题验证\n\n首先，我将根据指定的标准验证问题陈述。\n\n#### 第一步.1：提取已知条件\n\n*   **系统架构**：一个反向页表（IPT），每个物理帧有一个条目。\n*   **查找机制**：基于哈希的索引，访问一个包含 $B$ 个桶的表。\n*   **冲突解决**：分离链接法。\n*   **哈希键**：一个有序对 $(\\text{PID}, \\text{VPN})$，其中 $PID$ 是进程标识符，而 $VPN$ 是虚拟页号。\n*   **哈希函数**：$h(\\text{PID}, \\text{VPN}) = \\text{PID} \\bmod B$。\n*   **系统状态**：有 $n$ 个被占用的 IPT 条目。\n*   **条目集合**：被占用的条目集合表示为 $\\{(\\text{PID}_j, \\text{VPN}_j)\\}_{j=1}^{n}$。\n*   **约束条件**：不保证 $n \\leq B$。单个进程可能占用多个帧。\n*   **假设**：没有诸如转译后备缓冲器（TLB）之类的辅助加速结构。查找通过比较 $\\text{PID}$ 和 $\\text{VPN}$ 字段是否相等来遍历链。\n*   **目标**：\n    1.  推导所有 $n$ 个条目冲突到单个桶中的充分必要条件。\n    2.  在此条件下，确定单次查找中键比较的最坏情况次数，作为 $n$ 的函数。\n\n#### 第一步.2：使用提取的已知条件进行验证\n\n*   **科学依据**：该问题基于操作系统和数据结构的基本概念，特别是虚拟内存管理（反向页表）和哈希（使用分离链接法的哈希表）。设计拙劣的哈希函数的场景是一个标准的教学示例，用来说明哈希函数质量的重要性。这些概念在科学上和计算上都是合理的。\n*   **适定性**：该问题是适定的。它清楚地定义了系统、哈希函数和数据。它要求两个不同的、可推导的结果：一个逻辑条件和一个最坏情况下的复杂度分析。提供了所需的信息，可以确定一个唯一的、有意义的答案。\n*   **客观性**：问题以精确、客观的语言陈述，没有歧义或主观断言。像“反向页表”、“分离链接法”和“键比较”等术语在计算机科学中具有标准的、无歧义的含义。\n\n问题陈述不违反任何无效标准。这是一个来自计算机科学领域的科学合理、适定且客观的问题。\n\n#### 第一步.3：结论与行动\n\n问题是**有效的**。我将继续进行解答。\n\n### 第二步：解题推导\n\n问题有两个部分。首先，我们必须推导出最大冲突的条件，其次，我们必须分析在该条件下的最坏情况性能。\n\n#### 第一部分：退化的充分必要条件\n\n哈希表有 $B$ 个桶，索引从 $0$ 到 $B-1$。键为 $(\\text{PID}, \\text{VPN})$ 的条目所在的桶由哈希函数 $h(\\text{PID}, \\text{VPN})$ 的值确定。给定的哈希函数是 $h(\\text{PID}, \\text{VPN}) = \\text{PID} \\bmod B$。值得注意的是，哈希值仅取决于 $\\text{PID}$，而与 $\\text{VPN}$ 无关。\n\n所有 $n$ 个被占用的条目，由集合 $\\{(\\text{PID}_j, \\text{VPN}_j)\\}_{j=1}^{n}$ 表示，当且仅当它们都哈希到同一个桶索引时，才会冲突到单个桶中。设这个公共桶索引为整数 $k$，其中 $0 \\leq k  B$。\n\n这个条件可以用数学方式表示为：\n$$h(\\text{PID}_j, \\text{VPN}_j) = k \\quad \\text{for all } j \\in \\{1, 2, \\dots, n\\}$$\n\n代入哈希函数的定义，我们得到：\n$$\\text{PID}_j \\bmod B = k \\quad \\text{for all } j \\in \\{1, 2, \\dots, n\\}$$\n\n这个陈述意味着，来自被占用条目集合的每个进程标识符 $\\text{PID}_j$ 在除以 $B$ 时都必须有相同的余数 $k$。这是模 $B$ 同余的定义。因此，对于集合中的任意两个 PID，比如说 $\\text{PID}_i$ 和 $\\text{PID}_j$，必须有 $\\text{PID}_i \\bmod B = \\text{PID}_j \\bmod B$。这等价于说所有的 PID 都属于模 $B$ 的同一个同余类。\n\n因此，充分必要条件是：\n存在一个整数 $k \\in \\{0, 1, \\dots, B-1\\}$，使得对于所有被占用的条目 $(\\text{PID}_j, \\text{VPN}_j)$（其中 $j \\in \\{1, \\dots, n\\}$），其进程标识符 $\\text{PID}_j$ 满足同余关系 $\\text{PID}_j \\equiv k \\pmod{B}$。\n\n#### 第二部分：键比较的最坏情况次数\n\n在上面推导出的退化条件下，所有 $n$ 个被占用的条目都存储在与某个桶（比如桶 $k$）关联的单个链表（一个链）中。这个链的长度是 $n$。\n\n查找目标键 $(\\text{PID}_{target}, \\text{VPN}_{target})$ 的过程如下：\n1.  计算桶索引：$i = h(\\text{PID}_{target}, \\text{VPN}_{target}) = \\text{PID}_{target} \\bmod B$。\n2.  遍历桶 $i$ 处的链表。在链表的每个节点上，将存储的键 $(\\text{PID}_{stored}, \\text{VPN}_{stored})$ 与目标键 $(\\text{PID}_{target}, \\text{VPN}_{target})$ 进行比较。单次“键比较”涉及检查两个字段是否都相等：$(\\text{PID}_{stored} = \\text{PID}_{target}) \\land (\\text{VPN}_{stored} = \\text{VPN}_{target})$。\n\n我们需要找到这种比较的最坏情况次数。最坏情况可能发生在成功查找或不成功查找中。我们必须同时考虑这两种情况。\n\n**情况 A：成功查找**\n当目标键 $(\\text{PID}_{target}, \\text{VPN}_{target})$ 是链中 $n$ 个条目之一时，会发生成功查找。在链表中搜索的最坏情况发生在目标元素是列表中的最后一个元素时。为了找到它，算法必须遍历所有前面的 $n-1$ 个节点，在每个节点上执行一次失败的比较，然后在第 $n$ 个节点上执行一次最终的、成功的比较。因此，键比较的总次数是 $n$。\n\n**情况 B：不成功查找**\n当目标键 $(\\text{PID}_{target}, \\text{VPN}_{target})$ 不在 IPT 中时，会发生不成功查找。不成功查找的最坏情况发生在搜索被导向到最拥挤的桶时。为了让查找被导向到长度为 $n$ 的链，目标 PID 必须满足 $\\text{PID}_{target} \\bmod B = k$。然后，算法将遍历整个长度为 $n$ 的链表，在 $n$ 个节点中的每一个上都执行一次键比较。由于键不存在，所有 $n$ 次比较都会失败。在检查完所有 $n$ 个条目并到达列表末尾后，搜索终止。执行的键比较总次数是 $n$。\n\n**结论**\n成功查找的最坏情况比较次数是 $n$。不成功查找的最坏情况比较次数也是 $n$。因此，在给定的退化条件下，任何单次查找（成功或不成功）的键比较的总体最坏情况次数是这两个值的最大值，即 $n$。",
            "answer": "$$\\boxed{n}$$"
        },
        {
            "introduction": "真实的操作系统不仅要追求高性能，还必须保证关键数据结构的健壮性和可恢复性。本练习将带您进入一个系统崩溃恢复的实际场景，其中内存中的哈希页表结构已丢失，但底层的物理帧元数据得以幸存。您的任务是设计一个高效的算法来重建哈希页表，这不仅考验您对算法效率的把握，更深化了您对逻辑数据结构与其物理存储之间关系的理解。",
            "id": "3647292",
            "problem": "一个操作系统（OS）使用哈希页表来将由地址空间标识符（ASID）和虚拟页号（VPN）组成的对转换为物理帧号（PFN）。该哈希页表由 $M$ 个桶组成，每个桶存储一个冲突链，链中条目的形式为 $(\\text{ASID}, \\text{VPN}) \\mapsto \\text{PFN}$，并附带保护和状态标志。哈希函数 $H(\\cdot)$ 是确定性的，仅依赖于 $(\\text{ASID}, \\text{VPN})$ 和表的大小 $M$，操作系统可以在启动时选择 $M$。\n\n操作系统还为每个物理帧在内存（RAM）中维护一个帧描述符，该描述符与帧共同存放，并能在内核崩溃后幸存。内核崩溃会使 RAM 内容保持完整，但会破坏内核内的哈希表结构。每个帧描述符包含：\n- 一个状态标志，指示帧是空闲还是已映射。\n- 如果已映射，则有一个“所有者集合”，它以有限多重集 $\\{(\\text{ASID}_i, \\text{VPN}_i)\\}_{i=1}^{k}$ 的形式记录了当前引用此 PFN 的每一个虚拟映射，以及每个映射的标志（有效位、脏位、访问位、保护位）。\n- 一个小的、固定大小的头部，包含 PFN 和一个用于防范撕裂写的校验和。\n\n假设在崩溃前以下不变性条件和事实成立：\n- 一个虚拟到物理的转换是有效的，当且仅当存在一个 $(\\text{ASID}, \\text{VPN})$ 的哈希页表条目，该条目映射到一个标记为“已映射”的 PFN，并且该 PFN 的描述符的所有者集合中包含 $(\\text{ASID}, \\text{VPN})$ 且其有效位被设置。\n- 每个驻留的映射都恰好出现在其对应 PFN 的一个所有者集合中，并且每个所有者集合中的条目都恰好对应一个哈希页表条目。\n- 崩溃后，RAM 的内容（包括所有帧描述符和所有者集合）仍然可读，但哈希页表丢失了，必须重建。操作系统可以分配一个全新的、大小为 $M$ 的空哈希页表，并将冲突链重新初始化为空。\n\n令 $F$ 表示物理帧的总数，令 $N$ 表示所有帧描述符中所有者集合条目的总数（即，RAM 中驻留的 $(\\text{ASID}, \\text{VPN})$ 映射的总数）。\n\n你必须选择一种设计和恢复算法，在这些假设下，该算法既能重建一个正确的哈希页表，又能在 $\\mathcal{O}(N)$ 时间内运行，且不执行磁盘输入/输出。\n\n哪个选项是正确的？\n\nA. 初始化一个有 $M$ 个桶的新空哈希页表。对所有 $F$ 个帧描述符执行一次线性扫描。对于每个状态为“已映射”的帧描述符，遍历其所有者集合 $\\{(\\text{ASID}_i, \\text{VPN}_i)\\}_{i=1}^{k}$；对于每一对，计算桶索引 $b = H(\\text{ASID}_i,\\text{VPN}_i) \\bmod M$，并在桶 $b$ 的链的头部插入一个新条目 $(\\text{ASID}_i,\\text{VPN}_i)\\mapsto \\text{PFN}$ 及记录的标志。跳过标记为“空闲”的描述符。因为每个所有者集合的条目最多产生一次常数时间的插入，所以工作量为 $\\mathcal{O}(F + N) = \\mathcal{O}(N)$（假设 $N \\ge 1$），并且不需要磁盘输入/输出。\n\nB. 首先，根据从其所有者集合中提取的 $(\\text{ASID}, \\text{VPN})$ 键，按字典序对所有 $F$ 个帧描述符进行排序，然后通过扫描排序后的列表并按该顺序插入条目来重建哈希页表。这保证了链中的稳定排序，从而保证了正确性，但时间成本为 $\\mathcal{O}(N \\log N)$。\n\nC. 对每个进程，扫描整个虚拟地址空间以发现有效页面，方法是按升序探测每个潜在的 $(\\text{ASID}, \\text{VPN})$，并使用中央处理器（CPU）触发页错误来确定其是否存在。对于每个发现的驻留映射，将其插入哈希页表。因为虚拟地址空间的大小可能远大于帧的数量，所以该方法的时间复杂度是 $N$ 的超线性，但它无需帧描述符即可重建所有条目。\n\nD. 仅对 PFN 进行哈希：对于每个已映射的帧，计算 $b = H(\\text{PFN}) \\bmod M$，并使用为该帧发现的任意一个 $(\\text{ASID}^{*}, \\text{VPN}^{*})$ 对，为每个帧插入一个条目 $(\\text{ASID}^{*}, \\text{VPN}^{*}) \\mapsto \\text{PFN}$；对于具有多个别名（aliases）的帧，只保留遇到的第一个对，以避免重复插入。这会产生 $\\mathcal{O}(F)$ 的时间复杂度并避免长链，但可能会丢弃一些别名。",
            "solution": "### 第 1 步：提取已知信息\n\n-   **系统组件：** 一个操作系统（OS）使用哈希页表。\n-   **映射：** 该表将一个对 $(\\text{ASID}, \\text{VPN})$（地址空间标识符，虚拟页号）转换为一个 PFN（物理帧号）。\n-   **哈希表结构：** 该表有 $M$ 个桶。每个桶是一个冲突链，链中条目的形式为 $(\\text{ASID}, \\text{VPN}) \\mapsto \\text{PFN}$，外加保护和状态标志。\n-   **哈希函数：** 一个确定性函数 $H(\\cdot)$，仅依赖于 $(\\text{ASID}, \\text{VPN})$ 和表的大小 $M$。$M$ 在启动时选择。\n-   **崩溃恢复数据：** 操作系统为每个物理帧在 RAM 中维护一个帧描述符。这些描述符与它们的帧共同存放，并能在内核崩溃后幸存，内核崩溃会破坏内核内的哈希页表但保持 RAM 内容完整。\n-   **帧描述符内容：**\n    1.  一个状态标志：“空闲”或“已映射”。\n    2.  如果“已映射”，则有一个“所有者集合”：一个有限多重集 $\\{(\\text{ASID}_i, \\text{VPN}_i)\\}_{i=1}^{k}$，包含所有指向此 PFN 的虚拟映射，并带有每个映射的标志。\n    3.  一个带有 PFN 和校验和的头部。\n-   **不变性（崩溃前）：**\n    1.  一个虚拟到物理的转换是有效的，当且仅当存在一个 $(\\text{ASID}, \\text{VPN})$ 的哈希页表条目映射到一个 PFN，且该 PFN 的描述符被标记为“已映射”，并且其所有者集合包含 $(\\text{ASID}, \\text{VPN})$ 且其有效位被设置。\n    2.  每个驻留的映射 $(\\text{ASID}, \\text{VPN})$ 恰好出现在其对应 PFN 的一个所有者集合中。\n    3.  每个所有者集合的条目恰好对应一个哈希页表条目。\n-   **崩溃后状态：**\n    1.  RAM 内容，包括帧描述符和所有者集合，均可读。\n    2.  哈希页表已丢失。\n    3.  操作系统可以分配一个大小为 $M$ 的新的空哈希页表。\n-   **变量：**\n    -   $F$：物理帧的总数。\n    -   $N$：所有帧描述符中所有者集合条目的总数（即，驻留映射的总数）。\n-   **任务要求：** 选择一个恢复算法，该算法能够重建一个正确的哈希页表，运行时间为 $\\mathcal{O}(N)$，并且不执行磁盘输入/输出。\n\n### 第 2 步：使用提取的已知信息进行验证\n\n问题陈述描述了操作系统内存管理子系统的崩溃恢复场景。\n\n-   **科学依据：** 所提出的概念是操作系统设计中的标准概念。哈希页表和反向页表是众所周知的内存管理结构。将元数据（帧描述符）与数据（帧）共同存放以方便恢复的想法，是在容错系统和数据库中用于确保一致性和实现快速重启的一种有效且实用的技术。不变性条件在内存状态（所有者集合）和易失的内核数据结构（哈希页表）之间建立了一个清晰且逻辑的关系。该问题牢固地植根于计算机科学原理。\n-   **良构性：** 这个问题是良构的。初始状态（崩溃后的内存内容）、最终状态（一个正确重建的哈希页表）以及约束条件（时间复杂度为 $\\mathcal{O}(N)$，无磁盘 I/O）都已明确说明。不变性条件，特别是“每个所有者集合的条目恰好对应一个哈希页表条目”，保证了完整和正确重建所需的所有信息都在幸存的帧描述符中可用。\n-   **客观性：** 语言技术性强、精确，没有主观或模糊的术语。\n\n问题陈述没有违反任何无效标准。这是一个在操作系统领域内自成体系、逻辑清晰且科学合理的问题。\n\n### 第 3 步：结论与行动\n\n问题陈述是 **有效的**。将推导解决方案并评估各个选项。\n\n### 基于原则的推导与解决方案\n\n恢复的基本原则源于所提供的不变性条件。在崩溃之前，（现已丢失的）哈希页表中的条目与（幸存的）帧描述符内的所有者集合中的条目之间存在一一对应关系。因此，要正确重建哈希页表，必须为在所有“已映射”物理帧的所有者集合中找到的每一个条目，在新表中创建一个新条目。\n\n恢复算法必须是：\n1.  **初始化：** 分配一个新的、空的哈希页表，并设置合适的桶数 $M$。为获得最佳性能，$M$ 应与 $N$ 同阶，即 $M = \\Theta(N)$。此初始化需要 $\\mathcal{O}(M)$ 时间，也就是 $\\mathcal{O}(N)$。\n2.  **数据遍历：** 所需映射信息的唯一来源是 RAM 中的 $F$ 个帧描述符集合。由于没有辅助索引来仅定位“已映射”的帧，算法必须对所有 $F$ 个物理帧进行线性扫描以读取它们各自的描述符。此步骤需要 $\\mathcal{O}(F)$ 时间。\n3.  **重建：** 在扫描过程中，对于找到的每个帧描述符：\n    a. 检查其状态标志。如果为“空闲”，则忽略并继续。\n    b. 如果为“已映射”，从描述符的头部检索该帧的 PFN。然后，遍历其所有者集合中的每个条目 $(\\text{ASID}_i, \\text{VPN}_i)$。\n    c. 对于每个这样的条目，一个完整的映射 $(\\text{ASID}_i, \\text{VPN}_i) \\mapsto \\text{PFN}$ 是已知的。\n    d. 要将其插入哈希页表，需计算桶索引 $b = H(\\text{ASID}_i, \\text{VPN}_i) \\bmod M$。\n    e. 创建一个包含该映射和相关标志的新哈希表条目，并将其插入到桶 $b$ 的冲突链中。在链的头部插入是一个 $\\mathcal{O}(1)$ 的操作。\n\n所有帧中所有者集合条目的总数给定为 $N$。因此，在步骤 3c-3e 中完成的总工作量为 $\\mathcal{O}(N)$。\n\n这个正确算法的总时间复杂度是其各部分复杂度之和：$\\mathcal{O}(M) + \\mathcal{O}(F) + \\mathcal{O}(N)$。当 $M = \\Theta(N)$ 时，这变为 $\\mathcal{O}(N + F)$。\n\n问题要求时间复杂度为 $\\mathcal{O}(N)$。这意味着 $\\mathcal{O}(N + F) = \\mathcal{O}(N)$，这当且仅当 $F = \\mathcal{O}(N)$ 时成立。在一个典型的负载下的操作系统中，活动内存映射的数量（$N$）通常与物理帧的总数（$F$）相当或更大，尤其是在有内存共享的情况下。因此，假设 $F = \\mathcal{O}(N)$ 是一个合理的简化，用于分析一个活跃到足以崩溃的系统的性能。所以，一个复杂度为 $\\mathcal{O}(N+F)$ 的算法在这种实际情境下可以被认为满足 $\\mathcal{O}(N)$ 的约束。\n\n该算法也满足“无磁盘输入/输出”的约束，因为所有数据都驻留在 RAM 中。\n\n### 逐项分析\n\n**A. 初始化一个有 $M$ 个桶的新空哈希页表。对所有 $F$ 个帧描述符执行一次线性扫描。对于每个状态为“已映射”的帧描述符，遍历其所有者集合 $\\{(\\text{ASID}_i, \\text{VPN}_i)\\}_{i=1}^{k}$；对于每一对，计算桶索引 $b = H(\\text{ASID}_i,\\text{VPN}_i) \\bmod M$，并在桶 $b$ 的链的头部插入一个新条目 $(\\text{ASID}_i,\\text{VPN}_i)\\mapsto \\text{PFN}$ 及记录的标志。跳过标记为“空闲”的描述符。因为每个所有者集合的条目最多产生一次常数时间的插入，所以工作量为 $\\mathcal{O}(F + N) = \\mathcal{O}(N)$（假设 $N \\ge 1$），并且不需要磁盘输入/输出。**\n\n-   **分析：** 这个选项精确地描述了从第一性原理推导出的正确且最高效的算法。它正确地确定了信息的来源（所有者集合）、遍历方法（对帧进行线性扫描）以及重建过程（对每个所有者集合条目进行哈希并插入）。其时间复杂度分析正确地将工作量确定为 $\\mathcal{O}(F+N)$，并在 $F$ 不渐进主导 $N$ 的合理假设下将其简化为 $\\mathcal{O}(N)$。该算法仅使用 RAM 数据。\n-   **结论：** **正确**。\n\n**B. 首先，根据从其所有者集合中提取的 $(\\text{ASID}, \\text{VPN})$ 键，按字典序对所有 $F$ 个帧描述符进行排序，然后通过扫描排序后的列表并按该顺序插入条目来重建哈希页表。这保证了链中的稳定排序，从而保证了正确性，但时间成本为 $\\mathcal{O}(N \\log N)$。**\n\n-   **分析：** 这个选项引入了一个不必要且代价高昂的排序步骤。哈希表冲突链中条目的顺序不影响查找的正确性。查找操作会遍历链，直到找到匹配的键或到达链尾。因此，排序没有任何好处。排序步骤将涉及提取 $N$ 个映射并对其进行排序，其复杂度为 $\\mathcal{O}(N \\log N)$。这违反了要求的时间复杂度 $\\mathcal{O}(N)$。\n-   **结论：** **不正确**。\n\n**C. 对每个进程，扫描整个虚拟地址空间以发现有效页面，方法是按升序探测每个潜在的 $(\\text{ASID}, \\text{VPN})$，并使用中央处理器（CPU）触发页错误来确定其是否存在。对于每个发现的驻留映射，将其插入哈希页表。因为虚拟地址空间的大小可能远大于帧的数量，所以该方法的时间复杂度是 $N$ 的超线性，但它无需帧描述符即可重建所有条目。**\n\n-   **分析：** 这种方法根本无法工作。CPU 的内存管理单元（MMU）依赖于一个有效的页表来执行地址转换和触发页错误。在崩溃后的状态下，哈希页表已被销毁。任何访问虚拟地址的尝试都会灾难性地失败，因为硬件没有有效的页表结构可供查询。这个提议类似于试图在一本被烧毁的字典里查单词。此外，它忽略了为恢复而明确提供的可靠数据源：帧描述符。其复杂度也将是天文数字，与虚拟地址空间的大小成正比，而不是 $\\mathcal{O}(N)$。\n-   **结论：** **不正确**。\n\n**D. 仅对 PFN 进行哈希：对于每个已映射的帧，计算 $b = H(\\text{PFN}) \\bmod M$，并使用为该帧发现的任意一个 $(\\text{ASID}^{*}, \\text{VPN}^{*})$ 对，为每个帧插入一个条目 $(\\text{ASID}^{*}, \\text{VPN}^{*}) \\mapsto \\text{PFN}$；对于具有多个别名（aliases）的帧，只保留遇到的第一个对，以避免重复插入。这会产生 $\\mathcal{O}(F)$ 的时间复杂度并避免长链，但可能会丢弃一些别名。**\n\n-   **分析：** 这个选项有两个致命缺陷。首先，它提出了一个基于 PFN 的哈希函数，即 $H(\\text{PFN})$。问题明确指出，系统使用的哈希函数是 $H(\\text{ASID}, \\text{VPN})$。地址转换始于虚拟地址，因此哈希键必须由虚拟地址派生。其次，该提议明确指出，对于共享帧（“多个别名”），它将“只保留遇到的第一个对”并“丢弃一些别名”。这意味着重建是不完整的，因此是不正确的。任何试图使用被丢弃的映射的进程都会失败，即使该映射在崩溃前是有效的。\n-   **结论：** **不正确**。",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}