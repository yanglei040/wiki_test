{
    "hands_on_practices": [
        {
            "introduction": "要评估哈希页表的效率，核心问题是：一次查找操作需要多长时间？这个练习将引导你分析两种经典的冲突解决方法——分离链接法和线性探测法——在查找成功和失败时的预期内存访问次数。理解这些权衡是设计或选择高效哈希表实现的基础 。",
            "id": "3651107",
            "problem": "一个操作系统 (OS) 实现了一个哈希反向页表 (IPT)，用于将由进程标识符和虚拟页号组成的对转换为物理帧号。IPT 存储在主存中，其组织方式可以是使用线性探测法的开放寻址的单个数组，也可以是使用分离链接法的桶数组。假设有 $m$ 个槽（对于开放寻址）或 $m$ 个桶（对于链接法），以及 $n$ 个驻留映射（键），负载因子为 $\\alpha = n/m \\in (0,1)$。假设为均匀哈希：每个键的哈希值在 $\\{0,1,\\dots,m-1\\}$ 中均匀分布，且与其他键无关。\n\n将单次探测定义为一次主存访问，该访问将待查找的键与表槽（开放寻址）中存储的键或链（分离链接法）中的节点进行比较，或者确定一个槽为空（开放寻址）或一条链已遍历完（分离链接法）。忽略任何不读取键的常数时间开销，并假设查找时转译后备缓冲器 (TLB) 未命中，因此需要查询 IPT。\n\n在这些假设下，仅从哈希、负载因子和均匀哈希的核心定义出发，推导在 IPT 中完成单次查找所需的期望探测次数 $E[\\text{probes}]$，并表示为关于 $\\alpha$ 的闭式函数，针对以下四种情况：\n- 使用线性探测法的成功查找（页面存在），\n- 使用线性探测法的不成功查找（页面不存在），\n- 使用分离链接法的成功查找，\n- 使用分离链接法的不成功查找。\n\n你的推导应从定义和关于占用情况的基本概率推理开始，不应预设任何最终的性能公式。将你的最终结果按以下顺序表示为一个行矩阵：\n$[E_{\\text{lin, succ}} \\; E_{\\text{lin, unsucc}} \\; E_{\\text{chain, succ}} \\; E_{\\text{chain, unsucc}}]$，\n其中每个条目都是 $\\alpha$ 的闭式函数。不需要数值近似或四舍五入。单位不适用。",
            "solution": "本问题要求在两种冲突解决方法（线性探测法和分离链接法）下，推导哈希反向页表 (IPT) 中成功查找和不成功查找的期望探测次数。负载因子给定为 $\\alpha = n/m$，其中 $n$ 是驻留映射（键）的数量， $m$ 是槽或桶的数量。该分析依赖于均匀哈希的假设。一次探测被定义为一次主存访问，用于比较一个键或确定一个槽为空或一条链已遍历完。我们将从第一性原理出发，推导这四个所求的量。\n\n我们从分离链接法的分析开始，因为它的分析更为直接。\n\n**3. 使用分离链接法的成功查找 ($E_{\\text{chain, succ}}$)**\n\n对一个键的成功查找涉及到在其哈希到的桶的链表中找到它。探测次数是该键在链表中的位置。为了找到期望探测次数，我们对表中的所有 $n$ 个键进行平均，假设任何键被搜索的概率都相等。\n\n让我们通过对插入过程求平均来找到期望探测次数。找到第 $i$ 个插入的键的期望探测次数是 $1$（为其自身）加上在其之前插入且位于同一链中的键的期望数量。在第 $i$ 个键之前插入了 $i-1$ 个键。由于均匀哈希的假设，这 $i-1$ 个键中的任何一个都有 $1/m$ 的概率与第 $i$ 个键哈希到同一个桶。\n\n根据期望的线性性，同一链中先前插入的键的期望数量为 $(i-1) \\times (1/m)$。\n因此，找到第 $i$ 个键的期望探测次数是 $1 + \\frac{i-1}{m}$。\n\n为了找到任何成功搜索的平均值，我们对所有 $n$ 个键的这个代价求平均：\n$$E_{\\text{chain, succ}} = \\frac{1}{n} \\sum_{i=1}^{n} \\left(1 + \\frac{i-1}{m}\\right)$$\n我们可以拆分求和：\n$$E_{\\text{chain, succ}} = \\frac{1}{n} \\left( \\sum_{i=1}^{n} 1 + \\frac{1}{m} \\sum_{i=1}^{n} (i-1) \\right)$$\n第一个和是 $n$。第二个和是前 $n-1$ 个整数的和，即 $\\frac{(n-1)n}{2}$。\n$$E_{\\text{chain, succ}} = \\frac{1}{n} \\left( n + \\frac{1}{m} \\frac{n(n-1)}{2} \\right)$$\n$$E_{\\text{chain, succ}} = 1 + \\frac{n-1}{2m}$$\n在典型的算法分析中，通常假设 $n, m \\to \\infty$ 且它们的比率 $\\alpha = n/m$ 保持不变。在此标准假设下，项 $1/(2m)$ 将消失（趋于零）。因此，我们有：\n$$E_{\\text{chain, succ}} = 1 + \\frac{\\alpha}{2}$$\n\n**4. 使用分离链接法的不成功查找 ($E_{\\text{chain, unsucc}}$)**\n\n对于不成功的查找，目标键不在表中。查找过程包括哈希到一个桶，并遍历整个相应的链来验证该键不存在。探测次数是该链中的节点数。在均匀哈希下，任意给定链中的期望键数是总键数除以链数。\n$$E[\\text{链的长度}] = \\frac{n}{m} = \\alpha$$\n由于不成功的搜索必须遍历整个链，期望探测次数等于期望链长。\n$$E_{\\text{chain, unsucc}} = \\alpha$$\n\n我们现在继续分析使用线性探测法的开放寻址。这是算法分析中的一个经典结果。\n\n**2. 使用线性探测法的不成功查找 ($E_{\\text{lin, unsucc}}$)**\n\n对于负载因子为 $\\alpha$ 的表进行均匀哈希，不成功搜索的期望探测次数是：\n$$E_{\\text{lin, unsucc}} = \\frac{1}{2}\\left(1 + \\frac{1}{(1-\\alpha)^2}\\right)$$\n\n**1. 使用线性探测法的成功查找 ($E_{\\text{lin, succ}}$)**\n\n我们可以从不成功搜索的结果推导出成功搜索的期望探测次数。对键 $k$ 的一次成功查找所用的探测次数，与最初将 $k$ 插入表中所需的探测次数完全相同。成功搜索的期望探测次数 $E_{\\text{lin, succ}}$ 是对 $n$ 个键中每一个的期望插入代价的平均值。插入第 $(i+1)$ 个键的期望探测次数，等同于在一个包含 $i$ 个键的表中进行一次不成功的搜索，其负载因子为 $\\alpha_i = i/m$。\n对所有 $n$ 次插入的平均值，在大 $n, m$ 的情况下可以用积分近似：\n$$E_{\\text{lin, succ}}(\\alpha) = \\frac{1}{\\alpha} \\int_0^{\\alpha} E_{\\text{lin, unsucc}}(u) du$$\n代入 $E_{\\text{lin, unsucc}}(u)$ 的表达式并求解积分：\n$$E_{\\text{lin, succ}}(\\alpha) = \\frac{1}{\\alpha} \\int_0^{\\alpha} \\frac{1}{2}\\left(1 + \\frac{1}{(1-u)^2}\\right) du$$\n$$E_{\\text{lin, succ}}(\\alpha) = \\frac{1}{2\\alpha} \\left[ u + \\frac{1}{1-u} \\right]_0^{\\alpha}$$\n$$E_{\\text{lin, succ}}(\\alpha) = \\frac{1}{2\\alpha} \\left( \\alpha + \\frac{1}{1-\\alpha} - 1 \\right) = \\frac{1}{2\\alpha} \\left( \\frac{\\alpha(1-\\alpha) + 1 - (1-\\alpha)}{1-\\alpha} \\right)$$\n$$E_{\\text{lin, succ}}(\\alpha) = \\frac{1}{2\\alpha} \\left( \\frac{2\\alpha - \\alpha^2}{1-\\alpha} \\right) = \\frac{1}{2} \\left( \\frac{2 - \\alpha}{1-\\alpha} \\right) = \\frac{1}{2}\\left(1 + \\frac{1}{1-\\alpha}\\right)$$\n\n总结这四个结果：\n- $E_{\\text{lin, succ}} = \\frac{1}{2}\\left(1 + \\frac{1}{1-\\alpha}\\right)$\n- $E_{\\text{lin, unsucc}} = \\frac{1}{2}\\left(1 + \\frac{1}{(1-\\alpha)^2}\\right)$\n- $E_{\\text{chain, succ}} = 1 + \\frac{\\alpha}{2}$\n- $E_{\\text{chain, unsucc}} = \\alpha$",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{1}{2}\\left(1 + \\frac{1}{1-\\alpha}\\right) & \\frac{1}{2}\\left(1 + \\frac{1}{(1-\\alpha)^2}\\right) & 1 + \\frac{\\alpha}{2} & \\alpha\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "从抽象的性能分析转向系统的可靠性，本练习将探讨一个真实的场景：系统崩溃后的恢复。你需要设计一个算法，从内存中持久化的元数据重建丢失的哈希页表。这个练习阐明了哈希页表作为一种易失性加速结构的角色，并强调了为内存映射维护一个一致的“事实来源”的重要性 。",
            "id": "3651073",
            "problem": "一个系统实现了一个反向页表（IPT），每个物理帧恰好存储一个条目。查找虚拟地址时，使用基于哈希的索引来访问一个包含 $B$ 个桶的表，并通过分离链接法解决冲突。哈希键是一个有序对 $\\left(PID, VPN\\right)$，其中 $PID$ 是进程标识符（PID），$VPN$ 是虚拟页号（VPN）。系统设计者错误地部署了一个性能不佳的哈希函数 $h\\left(PID, VPN\\right) = PID \\bmod B$。假设在某个时刻有 $n$ 个被占用的 IPT 条目，其中不保证 $n \\leq B$，并且单个进程可能占用多个帧。假设没有辅助加速结构，例如转译后备缓冲器（TLB）；查找操作通过在每个节点上比较 $PID$ 和 $VPN$ 字段是否相等来遍历桶中的链。\n\n仅从反向页表、分离链接法哈希和基于等值的键比较的定义出发，完成以下任务：\n\n- 推导一个关于被占用条目集 $\\left\\{\\left(PID_{j}, VPN_{j}\\right)\\right\\}_{j=1}^{n}$ 和桶数 $B$ 的充分必要条件，在该条件下，当使用 $h\\left(PID, VPN\\right) = PID \\bmod B$ 时，所有 $n$ 个条目都会冲突到单个桶中。您的推导必须确定表征这种退化情况的精确谓词。\n- 在这种退化情况下，确定单次查找（无论是成功还是不成功）所执行的最坏情况下的键比较次数，作为 $n$ 的函数。\n\n仅提供最坏情况下比较次数的表达式作为您的最终答案，形式为封闭形式，无单位。如果您选择简化，请进行精确简化；无需四舍五入。",
            "solution": "该问题分为两部分：推导所有条目冲突到单个桶的条件，以及在该条件下确定最坏情况的查找成本。\n\n**第一部分：最大冲突的充分必要条件**\n\n哈希表有 $B$ 个桶，索引为 $0, \\dots, B-1$。一个条目根据其哈希键 $(PID, VPN)$ 被放入哪个桶，由哈希函数 $h(PID, VPN)$ 决定。给定的哈希函数为 $h(PID, VPN) = PID \\bmod B$，这意味着哈希值仅取决于进程标识符（PID）。\n\n所有 $n$ 个条目 $\\{(PID_j, VPN_j)\\}_{j=1}^{n}$ 都冲突到单个桶中，当且仅当它们都哈希到同一个桶索引。设这个公共索引为某个整数 $k$，其中 $0 \\le k  B$。\n这意味着对于集合中的所有条目 $j=1, \\dots, n$，必须满足：\n$$h(PID_j, VPN_j) = k$$\n代入哈希函数定义，我们得到：\n$$PID_j \\bmod B = k$$\n这个关系表明，所有被占用条目的进程标识符 $PID_j$ 在除以 $B$ 时都必须具有相同的余数 $k$。换言之，所有 $PID_j$ 都属于模 $B$ 的同一个同余类。\n\n因此，充分必要条件是：**存在一个整数 $k \\in \\{0, 1, \\dots, B-1\\}$，使得对于所有被占用的条目 $(PID_j, VPN_j)$，其进程标识符 $PID_j$ 均满足同余关系 $PID_j \\equiv k \\pmod{B}$。**\n\n**第二部分：最坏情况下的键比较次数**\n\n在上述退化条件下，所有 $n$ 个条目都位于同一个桶的冲突链表中，形成一个长度为 $n$ 的链。查找操作（无论是成功还是不成功）的最坏情况都涉及到遍历整个链表。\n\n-   **成功查找的最坏情况**：当要查找的键位于链表的末尾时。算法必须将目标键与链中的前 $n-1$ 个条目进行比较，最后在第 $n$ 个位置找到匹配项。这需要 $n$ 次键比较。\n\n-   **不成功查找的最坏情况**：当要查找的键的 PID 哈希到这个拥挤的桶，但该键实际上不在链表中时。算法必须遍历链中的所有 $n$ 个条目，每次都进行一次键比较，最终发现所有比较都失败。这也需要 $n$ 次键比较。\n\n因此，在这两种情况下，最坏情况执行的键比较次数都是 $n$。",
            "answer": "$$\\boxed{n}$$"
        },
        {
            "introduction": "从抽象的性能分析转向系统的可靠性，本练习将探讨一个真实的场景：系统崩溃后的恢复。你需要设计一个算法，从内存中持久化的元数据重建丢失的哈希页表。这个练习阐明了哈希页表作为一种易失性加速结构的角色，并强调了为内存映射维护一个一致的“事实来源”的重要性 。",
            "id": "3647292",
            "problem": "一个操作系统 (OS) 使用哈希页表将由地址空间标识符 (ASID) 和虚拟页号 (VPN) 组成的对转换为物理帧号 (PFN)。该哈希页表由 $M$ 个桶组成，每个桶存储一个冲突链，链中条目的形式为 $(\\text{ASID}, \\text{VPN}) \\mapsto \\text{PFN}$，并附带保护和状态标志。哈希函数 $H(\\cdot)$ 是确定性的，仅取决于 $(\\text{ASID}, \\text{VPN})$ 和表大小 $M$，OS 可以在启动时选择 $M$。\n\nOS 还为每个物理帧在 RAM 中维护一个帧描述符，该描述符与帧共同存放，并在内核崩溃后幸存。此次崩溃会使 RAM 内容保持完整，但会破坏内核内的哈希表结构。每个帧描述符包含：\n- 一个状态标志，指示该帧是空闲还是已映射。\n- 如果已映射，则有一个“所有者集合”，记录当前引用此 PFN 的每一个虚拟映射，形式为一个有限多重集 $\\{(\\text{ASID}_i, \\text{VPN}_i)\\}_{i=1}^{k}$，以及每个映射的标志（有效位、脏位、访问位、保护位）。\n- 一个小的定长头部，包含 PFN 和一个校验和，以防止撕裂写。\n\n假设在崩溃前以下不变量和事实成立：\n- 一个虚拟到物理的转换是有效的，当且仅当存在一个用于 $(\\text{ASID}, \\text{VPN})$ 的哈希页表条目，该条目映射到一个标记为“已映射”的 PFN，并且该 PFN 描述符的所有者集合包含设置了有效位的 $(\\text{ASID}, \\text{VPN})$。\n- 每个常驻映射都恰好出现在其 PFN 的一个所有者集合中，并且每个所有者集合条目都恰好对应一个哈希页表条目。\n- RAM 的内容，包括所有帧描述符和所有者集合，在崩溃后仍然可读，但哈希页表已丢失，必须重建。OS 可以分配一个全新的、大小为 $M$ 的空哈希页表，并将冲突链重新初始化为空。\n\n令 $F$ 表示物理帧的总数，令 $N$ 表示所有帧描述符中所有者集合条目的总数（即 RAM 中常驻 $(\\text{ASID}, \\text{VPN})$ 映射的总数）。\n\n您必须选择一种设计和恢复算法，该算法在这些假设下，既能重建一个正确的哈希页表，又能以 $\\mathcal{O}(N)$ 的时间复杂度运行，且不执行磁盘输入/输出。\n\n哪个选项是正确的？\n\nA. 初始化一个新的包含 $M$ 个桶的空哈希页表。对所有 $F$ 个帧描述符执行一次线性遍历。对于每个状态为“已映射”的帧描述符，迭代其所有者集合 $\\{(\\text{ASID}_i, \\text{VPN}_i)\\}_{i=1}^{k}$；对于每一对，计算桶索引 $b = H(\\text{ASID}_i,\\text{VPN}_i) \\bmod M$，并在桶 $b$ 链表的头部插入一个新条目 $(\\text{ASID}_i,\\text{VPN}_i)\\mapsto \\text{PFN}$，并附上记录的标志。跳过标记为“空闲”的描述符。因为每个所有者集合条目最多产生一次常数时间的插入，所以工作量为 $\\mathcal{O}(F + N) = \\mathcal{O}(N)$（假设 $N \\ge 1$），并且不需要磁盘输入/输出。\n\nB. 首先，根据从所有者集合中提取的 $(\\text{ASID}, \\text{VPN})$ 键，对所有 $F$ 个帧描述符进行字典序排序，然后通过扫描排序后的列表并按该顺序插入条目来重建哈希页表。这保证了链中的稳定排序，从而保证了正确性，但时间成本为 $\\mathcal{O}(N \\log N)$。\n\nC. 对于每个进程，扫描整个虚拟地址空间以发现有效页面，方法是按升序探测每个潜在的 $(\\text{ASID}, \\text{VPN})$，并使用中央处理器 (CPU) 触发缺页故障来确定其是否存在。对于每个发现的常驻映射，将其插入哈希页表中。因为虚拟地址空间的大小可能远大于帧的数量，所以该方法在 $N$ 上是超线性的，但它可以在不需要帧描述符的情况下重建所有条目。\n\nD. 仅基于 PFN 进行哈希：对于每个已映射的帧，计算 $b = H(\\text{PFN}) \\bmod M$，并为每个帧使用发现的任意一个 $(\\text{ASID}^{*}, \\text{VPN}^{*})$ 对插入单个条目 $(\\text{ASID}^{*}, \\text{VPN}^{*}) \\mapsto \\text{PFN}$；对于具有多个别名的帧，只保留遇到的第一对以避免重复插入。这会产生 $\\mathcal{O}(F)$ 的时间，并避免了长链，但可能会丢弃一些别名。",
            "solution": "### 解决方案分析\n\n问题的核心是设计一个算法，利用崩溃后幸存的内存中元数据（帧描述符）来重建丢失的哈希页表。该算法必须正确、高效（$\\mathcal{O}(N)$ 时间复杂度），且不依赖磁盘I/O。\n\n根据问题描述，帧描述符中的“所有者集合”是描述真实内存映射的“事实来源”。不变量指出，在崩溃前，哈希页表中的每个有效条目都与所有者集合中的一个条目一一对应。因此，正确的恢复策略必须遍历所有幸存的所有者集合条目，并为每个条目重新创建相应的哈希页表项。\n\n**正确算法的步骤：**\n1.  **初始化**：分配一个新的、大小为 $M$ 的空哈希页表。此操作为 $\\mathcal{O}(M)$，通常选择 $M = \\Theta(N)$，因此为 $\\mathcal{O}(N)$。\n2.  **遍历**：由于无法直接定位哪些物理帧被映射，必须对所有 $F$ 个物理帧进行一次线性扫描，检查每个帧的描述符。此步骤需要 $\\mathcal{O}(F)$ 时间。\n3.  **重建**：在扫描过程中，对于每个标记为“已映射”的帧描述符：\n    a. 读取其 PFN。\n    b. 遍历其所有者集合中的每一个条目 $(\\text{ASID}_i, \\text{VPN}_i)$。\n    c. 对于每个条目，计算其哈希值 $b = H(\\text{ASID}_i, \\text{VPN}_i) \\bmod M$。\n    d. 创建一个新的哈希页表项，并将其插入到桶 $b$ 的冲突链的头部。这是一个 $\\mathcal{O}(1)$ 操作。\n4.  **复杂度分析**：总共有 $N$ 个所有者集合条目，因此重建步骤的总时间是 $\\mathcal{O}(N)$。算法的总时间复杂度为 $\\mathcal{O}(M + F + N)$。假设在一个正常运行的系统中 $F$ 和 $M$ 都与 $N$ 同阶或更小，复杂度简化为 $\\mathcal{O}(N)$。该算法完全在 RAM 中进行，满足无磁盘 I/O 的要求。\n\n### 评估各个选项\n\n*   **A**：此选项精确地描述了上述正确且高效的算法。它识别了正确的数据源（所有者集合），采用了正确的遍历方式（线性扫描帧描述符），并使用了正确的重建逻辑（为每个所有者条目进行哈希和插入）。其时间和资源分析也是正确的。\n\n*   **B**：此选项引入了不必要的 $\\mathcal{O}(N \\log N)$ 排序步骤。哈希冲突链中条目的顺序不影响查找的正确性，因此排序是多余的，且违反了 $\\mathcal{O}(N)$ 的时间复杂度约束。\n\n*   **C**：此选项根本上是错误的。它提议通过触发缺页中断来发现页面，但这在哈希页表被销毁后是不可能的，因为CPU的内存管理单元（MMU）需要一个有效的页表才能工作。这是一种逻辑上的循环依赖。\n\n*   **D**：此选项存在两个致命缺陷。首先，它使用了错误的哈希键（PFN 而不是 $(\\text{ASID}, \\text{VPN})$），这与系统的设计不符。其次，它会丢弃共享页面的额外映射（别名），导致重建的页表不完整和不正确。\n\n因此，选项 A 是唯一正确、高效且可行的解决方案。",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}