{
    "hands_on_practices": [
        {
            "introduction": "本练习将展示哈希函数设计在反向页表中的关键重要性。一个设计粗糙或选择不当的哈希函数可能导致灾难性的性能退化，将高效的查找结构变为缓慢的线性搜索。通过分析一个具体的退化案例，你将亲身体会到为什么哈希函数必须有效地分散键值以维持高性能。",
            "id": "3651073",
            "problem": "一个系统实现了一个反向页表（IPT），该页表为每个物理帧精确存储一个条目。对虚拟地址的查找使用基于哈希的索引来访问一个包含 $B$ 个桶的表，并通过分离链接法解决冲突。用于哈希的键是一个有序对 $\\left(PID, VPN\\right)$，其中 $PID$ 是进程标识符（Process Identifier, PID），$VPN$ 是虚拟页号（Virtual Page Number, VPN）。系统设计者错误地部署了一个糟糕的哈希函数 $h\\left(PID, VPN\\right) = PID \\bmod B$。假设在某个时刻有 $n$ 个被占用的 IPT 条目，其中不保证 $n \\leq B$，并且单个进程可能占用多个帧。假设没有辅助加速结构，如转译后备缓冲器（Translation Lookaside Buffer, TLB）；查找通过在桶中遍历链表，在每个节点上比较 $PID$ 和 $VPN$ 字段是否相等来进行。\n\n仅从反向页表、分离链接法哈希和基于等值的键比较的定义出发，完成以下任务：\n\n- 推导在使用 $h\\left(PID, VPN\\right) = PID \\bmod B$ 哈希函数时，所有 $n$ 个条目都冲突到单个桶中的一个关于已占用条目集合 $\\left\\{\\left(PID_{j}, VPN_{j}\\right)\\right\\}_{j=1}^{n}$ 和桶数量 $B$ 的充分必要条件。你的推导必须确定描述这种退化情况的精确谓词。\n- 在该退化情况下，确定单次查找（无论成功与否）所执行的最坏情况下的键比较次数，并将其表示为 $n$ 的函数。\n\n仅提供最坏情况下比较次数的表达式作为最终答案，形式为封闭形式，无单位。如果选择简化，请进行精确简化，无需四舍五入。",
            "solution": "用户希望我解决提示中描述的问题。\n\n### 步骤 1：问题验证\n\n首先，我将根据指定标准验证问题陈述。\n\n#### 步骤 1.1：提取已知条件\n\n*   **系统架构**：一个反向页表（IPT），每个物理帧有一个条目。\n*   **查找机制**：基于哈希的索引，访问一个包含 $B$ 个桶的表。\n*   **冲突解决**：分离链接法。\n*   **哈希键**：一个有序对 $(PID, VPN)$，其中 $PID$ 是进程标识符，$VPN$ 是虚拟页号。\n*   **哈希函数**：$h(PID, VPN) = PID \\bmod B$。\n*   **系统状态**：有 $n$ 个被占用的 IPT 条目。\n*   **条目集合**：被占用的条目集合表示为 $\\{(PID_j, VPN_j)\\}_{j=1}^{n}$。\n*   **约束条件**：不保证 $n \\leq B$。单个进程可能占用多个帧。\n*   **假设**：没有像转译后备缓冲器（TLB）这样的辅助加速结构。查找通过比较 $PID$ 和 $VPN$ 字段是否相等来遍历链表。\n*   **目标**：\n    1.  推导所有 $n$ 个条目冲突到单个桶中的充分必要条件。\n    2.  在此条件下，确定单次查找的最坏情况下键比较次数，作为 $n$ 的函数。\n\n#### 步骤 1.2：使用提取的已知条件进行验证\n\n*   **科学基础**：该问题基于操作系统和数据结构的基本概念，特别是虚拟内存管理（反向页表）和哈希（使用分离链接法的哈希表）。设计不佳的哈希函数的场景是一个标准的教学示例，用于说明哈希函数质量的重要性。这些概念在科学和计算上都是合理的。\n*   **适定性**：该问题是适定的。它清晰地定义了系统、哈希函数和数据。它要求两个不同的、可推导的结果：一个逻辑条件和一个最坏情况下的复杂度分析。所需信息已提供，并且可以确定一个唯一的、有意义的答案。\n*   **客观性**：该问题以精确、客观的语言陈述，没有歧义或主观论断。诸如“反向页表”、“分离链接法”和“键比较”等术语在计算机科学中具有标准的、明确的含义。\n\n问题陈述没有违反任何无效性标准。这是一个来自计算机科学领域的、科学上合理、适定且客观的问题。\n\n#### 步骤 1.3：结论与行动\n\n该问题是**有效的**。我将继续进行解答。\n\n### 步骤 2：解题推导\n\n该问题分为两部分。首先，我们必须推导出最大冲突的条件，其次，我们必须在该条件下分析最坏情况下的性能。\n\n#### 第 1 部分：退化的充分必要条件\n\n哈希表有 $B$ 个桶，索引从 $0$ 到 $B-1$。键为 $(PID, VPN)$ 的条目所在的桶由哈希函数 $h(PID, VPN)$ 的值确定。给定的哈希函数是 $h(PID, VPN) = PID \\bmod B$。值得注意的是，哈希值仅取决于 $PID$，与 $VPN$ 无关。\n\n所有 $n$ 个被占用的条目，由集合 $\\{(PID_j, VPN_j)\\}_{j=1}^{n}$ 表示，当且仅当它们都哈希到同一个桶索引时，才会冲突到单个桶中。设这个公共桶索引为一个整数 $k$，其中 $0 \\leq k  B$。\n\n这个条件可以用数学方式表示为：\n$$h(PID_j, VPN_j) = k \\quad \\text{for all } j \\in \\{1, 2, \\dots, n\\}$$\n\n代入哈希函数的定义，我们得到：\n$$PID_j \\bmod B = k \\quad \\text{for all } j \\in \\{1, 2, \\dots, n\\}$$\n\n这个陈述意味着，所有来自被占用条目集合的进程标识符 $PID_j$ 在除以 $B$ 时都必须具有相同的余数 $k$。这是模 $B$ 同余的定义。因此，对于集合中的任意两个 PID，例如 $PID_i$ 和 $PID_j$，必须有 $PID_i \\bmod B = PID_j \\bmod B$。这等价于说所有 PID 都属于模 $B$ 的同一个同余类。\n\n因此，充分必要条件是：\n存在一个整数 $k \\in \\{0, 1, \\dots, B-1\\}$，使得对于所有 $j \\in \\{1, \\dots, n\\}$ 的已占用条目 $(PID_j, VPN_j)$，其进程标识符 $PID_j$ 都满足同余关系 $PID_j \\equiv k \\pmod{B}$。\n\n#### 第 2 部分：最坏情况下的键比较次数\n\n在上面推导出的退化条件下，所有 $n$ 个被占用的条目都存储在与某个桶（比如桶 $k$）关联的单个链表（一个链）中。这个链的长度是 $n$。\n\n对目标键 $(PID_{target}, VPN_{target})$ 的查找过程如下：\n1.  计算桶索引：$i = h(PID_{target}, VPN_{target}) = PID_{target} \\bmod B$。\n2.  遍历桶 $i$ 处的链表。在链表的每个节点上，将存储的键 $(PID_{stored}, VPN_{stored})$ 与目标键 $(PID_{target}, VPN_{target})$ 进行比较。一次“键比较”涉及检查两个字段是否都相等：$(PID_{stored} = PID_{target}) \\land (VPN_{stored} = VPN_{target})$。\n\n我们需要找到这种比较的最坏情况次数。最坏情况可能发生在成功查找或不成功查找中。我们必须同时考虑这两种情况。\n\n**情况 A：成功查找**\n当目标键 $(PID_{target}, VPN_{target})$ 是链中 $n$ 个条目之一时，发生成功查找。在链表中搜索的最坏情况发生在目标元素是列表中的最后一个元素时。为了找到它，算法必须遍历所有前面的 $n-1$ 个节点，在每个节点上进行一次失败的比较，然后在第 $n$ 个节点上进行最后一次成功的比较。因此，键比较的总次数是 $n$。\n\n**情况 B：不成功查找**\n当目标键 $(PID_{target}, VPN_{target})$ 不在 IPT 中时，发生不成功查找。不成功查找的最坏情况发生在搜索被定向到最拥挤的桶时。为了让查找被定向到长度为 $n$ 的链，目标 PID 必须满足 $PID_{target} \\bmod B = k$。然后，算法将遍历整个长度为 $n$ 的链表，在 $n$ 个节点中的每一个上都执行一次键比较。由于键不存在，所有 $n$ 次比较都将失败。在检查了所有 $n$ 个条目并到达列表末尾后，搜索终止。执行的键比较总次数是 $n$。\n\n**结论**\n成功查找的最坏情况比较次数是 $n$。不成功查找的最坏情况比较次数也是 $n$。因此，在给定的退化条件下，任何单次查找（无论成功与否）的总体最坏情况键比较次数是这两个值的最大值，即 $n$。",
            "answer": "$$\\boxed{n}$$"
        },
        {
            "introduction": "在理解了劣质哈希函数的危害之后，我们现在转向分析一个设计良好、均匀分布的哈希函数的行为。本练习将深入探讨哈希表的概率特性，引导你推导出一个关键的性能指标——空桶的期望比例。这一分析为调整哈希表大小和预测系统负载提供了数学基础。",
            "id": "3651017",
            "problem": "一个操作系统 (OS) 使用一个反向页表 (IPT)，该页表被组织成一个带链地址法的哈希表。该表有 $m$ 个桶，并且有 $n$ 个活跃的页表条目。每个条目被均匀且独立地哈希到 $m$ 个桶中的一个。在一个桶中定位一个条目的时间与该桶中的条目数成正比，因此桶的占用情况直接影响查找性能。\n\n从概率、指示随机变量和期望的线性性的定义出发，推导出空桶的精确期望分数，该分数是关于 $m$ 和 $n$ 的函数。然后，使用一个大系统近似（其中 $m$ 和 $n$ 很大，而负载因子 $\\alpha = n/m$ 保持不变），推导出空桶期望分数的渐近形式。最后，假设系统旨在调整 $m$，使得空桶的期望分数等于一个目标值 $\\theta$（其中 $0  \\theta  1$）。使用渐近形式，推导出用 $n$ 和 $\\theta$ 表示 $m$ 的闭式表达式。\n\n将你的最终答案表示为一个包含两个条目的行矩阵：第一个条目是作为 $m$ 和 $n$ 函数的空桶精确期望分数，第二个条目是用 $n$ 和 $\\theta$ 表示 $m$ 的渐近表达式。不需要进行数值近似或四舍五入。",
            "solution": "题目要求进行三个相关的推导，这些推导关乎反向页表中条目的分布，该页表被建模为一个链式哈希表。我们将按照要求，从第一性原理出发，依次处理每个部分。\n\n这是一个概率论中经典的“球与箱”问题，其中 $n$ 个球（页表条目）被独立、均匀、随机地投入 $m$ 个箱（桶）中。\n\n首先，我们推导空桶的精确期望分数。设 $X$ 为表示空桶总数的随机变量。我们想求期望分数，即 $\\frac{E[X]}{m}$。为了计算 $E[X]$，我们使用指示随机变量法。\n\n对于 $i \\in \\{1, 2, \\dots, m\\}$，设 $X_i$ 为桶 $i$ 为空这一事件的指示随机变量。根据定义：\n$$\nX_i =\n\\begin{cases}\n1  \\text{如果桶 } i \\text{ 为空} \\\\\n0  \\text{如果桶 } i \\text{ 不为空}\n\\end{cases}\n$$\n空桶的总数是这些指示变量的和：\n$$X = \\sum_{i=1}^{m} X_i$$\n根据期望的线性性，空桶的期望数量是指示变量期望值的和：\n$$E[X] = E\\left[\\sum_{i=1}^{m} X_i\\right] = \\sum_{i=1}^{m} E[X_i]$$\n指示随机变量的期望等于它所指示事件的概率。因此，$E[X_i] = P(\\text{桶 } i \\text{ 为空})$。\n\n让我们计算这个概率。考虑单个页表条目。由于哈希是均匀的，该条目被哈希到任何特定桶 $i$ 的概率是 $\\frac{1}{m}$。因此，该条目*不*被哈希到桶 $i$ 的概率是 $1 - \\frac{1}{m} = \\frac{m-1}{m}$。\n\n总共有 $n$ 个条目，它们的哈希位置是独立的。“桶 $i$ 为空”这一事件发生，当且仅当这 $n$ 个条目中没有一个被哈希到桶 $i$。这个复合事件的概率是每个条目对应概率的乘积：\n$$P(\\text{桶 } i \\text{ 为空}) = \\left(\\frac{m-1}{m}\\right) \\times \\left(\\frac{m-1}{m}\\right) \\times \\dots \\times \\left(\\frac{m-1}{m}\\right) \\quad (n \\text{ 次})$$\n$$P(\\text{桶 } i \\text{ 为空}) = \\left(\\frac{m-1}{m}\\right)^n = \\left(1 - \\frac{1}{m}\\right)^n$$\n所以，对于任何桶 $i$，我们有 $E[X_i] = \\left(1 - \\frac{1}{m}\\right)^n$。\n\n现在，我们可以求出空桶的期望总数：\n$$E[X] = \\sum_{i=1}^{m} \\left(1 - \\frac{1}{m}\\right)^n = m \\left(1 - \\frac{1}{m}\\right)^n$$\n空桶的期望分数是 $\\frac{E[X]}{m}$：\n$$\\text{期望分数} = \\frac{m \\left(1 - \\frac{1}{m}\\right)^n}{m} = \\left(1 - \\frac{1}{m}\\right)^n$$\n这是第一个要求的结果。\n\n其次，我们推导该分数在大系统极限下的渐近形式，其中 $m \\to \\infty$ 和 $n \\to \\infty$，同时负载因子 $\\alpha = \\frac{n}{m}$ 保持不变。我们将 $n = \\alpha m$ 代入分数表达式中：\n$$\\left(1 - \\frac{1}{m}\\right)^n = \\left(1 - \\frac{1}{m}\\right)^{\\alpha m}$$\n我们计算当 $m \\to \\infty$ 时的极限：\n$$\\lim_{m \\to \\infty} \\left(1 - \\frac{1}{m}\\right)^{\\alpha m} = \\lim_{m \\to \\infty} \\left[ \\left(1 + \\frac{-1}{m}\\right)^m \\right]^{\\alpha}$$\n我们使用指数函数的基本极限定义，$\\lim_{x \\to \\infty} \\left(1 + \\frac{k}{x}\\right)^x = \\exp(k)$。这里，$x=m$ 且 $k=-1$。\n$$\\lim_{m \\to \\infty} \\left(1 + \\frac{-1}{m}\\right)^m = \\exp(-1)$$\n因此，该分数的渐近极限是：\n$$\\left[\\exp(-1)\\right]^{\\alpha} = \\exp(-\\alpha) = \\exp\\left(-\\frac{n}{m}\\right)$$\n空桶期望分数的渐近形式是 $\\exp\\left(-\\frac{n}{m}\\right)$。\n\n第三，我们使用这个渐近形式来推导 $m$ 的表达式，用 $n$ 和一个目标期望空桶分数 $\\theta$ 来表示，其中 $0  \\theta  1$。我们将渐近分数设为等于 $\\theta$：\n$$\\exp\\left(-\\frac{n}{m}\\right) = \\theta$$\n为了解出 $m$，我们对两边取自然对数：\n$$\\ln\\left(\\exp\\left(-\\frac{n}{m}\\right)\\right) = \\ln(\\theta)$$\n$$-\\frac{n}{m} = \\ln(\\theta)$$\n由于 $0  \\theta  1$，其对数 $\\ln(\\theta)$ 是一个非零负数。我们现在可以解出 $m$：\n$$m = -\\frac{n}{\\ln(\\theta)}$$\n这也可以写成 $m = \\frac{n}{\\ln(1/\\theta)}$。该表达式是良定义的且为正值，符合对桶数量的要求。这是第二个要求的结果。\n\n最终答案将是一个行矩阵，包含精确期望分数和推导出的 $m$ 的表达式。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\left(1 - \\frac{1}{m}\\right)^n  -\\frac{n}{\\ln(\\theta)}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "即使使用良好的哈希函数，冲突也是哈希表操作中不可避免的一部分。因此，反向页表的效率取决于其冲突解决策略。本练习要求你比较三种常见的开放寻址技术的性能，推导每种技术在不同负载因子下的期望查找成本。",
            "id": "3651068",
            "problem": "一个操作系统使用反向页表来解析地址，它将由进程标识符和虚拟页号组成的对通过哈希函数 $h(PID, VPN)$ 映射到一个大小为 $N$ 的表中的索引。该反向页表采用开放寻址法来解决冲突，并考虑了三种不同的探测序列：\n\n- 线性探测：$i_{k+1} = (i_k + 1) \\bmod N$。\n- 二次探测：$i_k = (i_0 + c_1 k + c_2 k^2) \\bmod N$，其中 $c_1$ 和 $c_2$ 是整数，其选择应使探测序列在可能的情况下能够遍历整个表。\n- 双重哈希：$i_k = (i_0 + k \\cdot d) \\bmod N$，其中 $d = h_2(PID, VPN)$ 是一个取值于 $\\{1, 2, \\dots, N-1\\}$ 的第二次哈希的步长。\n\n假设以下科学上真实且标准的条件成立：\n\n1. 反向页表包含 $N$ 个槽位，负载因子 $\\alpha$ 满足 $0  \\alpha  1$，意味着有 $\\alpha N$ 个槽位被占用。\n2. $h(PID, VPN)$ 的结果在 $\\{0, 1, \\dots, N-1\\}$ 上均匀分布，并且在与探测相关的粒度上，槽位的占用是随机且独立的。\n3. 对于双重哈希，假设采用均匀哈希模型（在给定起始索引的情况下，每个探测位置在未探测过的位置中是等可能的）；对于二次探测，为进行期望成本分析，假设采用相同的均匀哈希近似（当 $c_1$ 和 $c_2$ 选择得当时，这与实践一致）；对于线性探测，要考虑探测序列固有的一次聚集效应。\n\n仅从负载因子和开放寻址法的核心定义，以及经过充分检验的均匀哈希模型出发，为上述三种探测序列，推导在反向页表中成功查找到一个驻留页面所需的期望探测次数的闭式解析表达式，该表达式应为 $\\alpha$ 的函数。将你的最终结果分别表示为三个函数 $E_{\\mathrm{lin}}(\\alpha)$、$E_{\\mathrm{quad}}(\\alpha)$ 和 $E_{\\mathrm{dh}}(\\alpha)$，并置于一个单行矩阵中。无需进行数值计算；请提供精确表达式。最终答案必须是单一的解析表达式，无单位，也无需舍入说明。",
            "solution": "用户提供的问题陈述已被验证，并被确定为计算机科学（算法分析）领域中一个良定的、有科学依据的问题。该问题要求推导在开放寻址哈希表中，使用三种不同探测方案进行成功查找的期望探测次数。\n\n设 $N$ 为反向页表中的槽位数，$M$ 为已占用槽位数。负载因子定义为 $\\alpha = M/N$。给定条件为 $0  \\alpha  1$。设 $E_{\\text{succ}}(\\alpha)$ 为成功查找的期望探测次数， $E_{\\text{unsucc}}(\\alpha)$ 为不成功查找的期望探测次数，两者均为负载因子 $\\alpha$ 的函数。\n\n$E_{\\text{succ}}(\\alpha)$ 和 $E_{\\text{unsucc}}(\\alpha)$ 之间存在一个基本关系。一次成功查找是在表中查找已存在的 $M$ 个键之一。假设查找其中任何一个键的概率均等（为 $1/M$），则成功查找的平均成本是插入这 $M$ 个键各自成本的平均值。将第 $(k+1)$ 个键插入到当时已包含 $k$ 个键的表中，其成本等价于在该表中进行一次不成功查找的成本。此时的负载因子为 $k/N$。\n因此，在一个包含 $M$ 个项的表中成功查找的期望探测次数为：\n$$ E_{\\text{succ}, M} = \\frac{1}{M} \\sum_{k=0}^{M-1} E_{\\text{unsucc}}(k/N) $$\n对于较大的 $N$ 和 $M$，我们可以用积分来近似这个和。令 $x = k/N$，则 $dk = N dx$。该和变为一个从 $x=0$ 到 $x=(M-1)/N \\approx M/N = \\alpha$ 的积分。\n$$ E_{\\text{succ}}(\\alpha) \\approx \\frac{1}{M} \\int_{0}^{M} E_{\\text{unsucc}}(k/N) dk = \\frac{1}{\\alpha N} \\int_{0}^{\\alpha} E_{\\text{unsucc}}(x) (N dx) = \\frac{1}{\\alpha} \\int_0^\\alpha E_{\\text{unsucc}}(x) dx $$\n这个积分关系是我们推导的核心。我们将首先确定每种情况下 $E_{\\text{unsucc}}(\\alpha)$ 的值，然后使用此公式来找到相应的 $E_{\\text{succ}}(\\alpha)$。\n\n**情况1：二次探测和双重哈希 ($E_{\\mathrm{quad}}(\\alpha)$ 和 $E_{\\mathrm{dh}}(\\alpha)$)**\n\n对于这两种方法，问题陈述要求假设采用均匀哈希模型。该模型假定一个序列中的每次探测都会在可用的未探测槽位中独立且均匀随机地选择一个槽位进行检查。对于一个大表，这可以很好地近似为每次探测都是从所有 $N$ 个槽位中进行的独立随机选择。\n\n一次不成功的查找会持续进行，直到找到一个空槽位。任何给定探测位置被占用的概率是 $\\alpha$。它为空的概率是 $1-\\alpha$。如果前 $k-1$ 次探测都命中了被占用的槽位，而第 $k$ 次探测命中了一个空槽位，那么一次不成功的查找恰好需要 $k$ 次探测。此事件的概率为 $P(k \\text{ 次探测}) \\approx \\alpha^{k-1}(1-\\alpha)$。\n\n不成功查找的期望探测次数是所有可能探测次数 $k$ 的总和：\n$$ E_{\\text{unsucc}}(\\alpha) = \\sum_{k=1}^\\infty k \\cdot P(k \\text{ 次探测}) \\approx \\sum_{k=1}^\\infty k \\alpha^{k-1}(1-\\alpha) $$\n这是一个几何分布的期望值。我们可以计算这个和：\n$$ E_{\\text{unsucc}}(\\alpha) = (1-\\alpha) \\sum_{k=1}^\\infty k \\alpha^{k-1} = (1-\\alpha) \\frac{d}{d\\alpha} \\left( \\sum_{k=0}^\\infty \\alpha^k \\right) = (1-\\alpha) \\frac{d}{d\\alpha} \\left( \\frac{1}{1-\\alpha} \\right) $$\n$$ E_{\\text{unsucc}}(\\alpha) = (1-\\alpha) \\left( \\frac{1}{(1-\\alpha)^2} \\right) = \\frac{1}{1-\\alpha} $$\n现在，我们使用积分关系来求成功查找的期望探测次数：\n$$ E_{\\mathrm{quad}}(\\alpha) = E_{\\mathrm{dh}}(\\alpha) = \\frac{1}{\\alpha} \\int_0^\\alpha \\frac{1}{1-x} dx $$\n积分计算结果为：\n$$ \\int_0^\\alpha \\frac{1}{1-x} dx = [-\\ln(1-x)]_0^\\alpha = -\\ln(1-\\alpha) - (-\\ln(1-0)) = -\\ln(1-\\alpha) $$\n将此结果代回，我们得到：\n$$ E_{\\mathrm{quad}}(\\alpha) = E_{\\mathrm{dh}}(\\alpha) = \\frac{-\\ln(1-\\alpha)}{\\alpha} = \\frac{1}{\\alpha} \\ln\\left(\\frac{1}{1-\\alpha}\\right) $$\n\n**情况2：线性探测 ($E_{\\mathrm{lin}}(\\alpha)$)**\n\n线性探测会受到一次聚集的影响，即冲突会导致被占用槽位的连续块形成并增长。这违反了均匀哈希假设。因此，其分析更为复杂。我们依赖于由 Donald Knuth 著名地推导出的、关于线性探测下不成功查找的期望探测次数的既有结论。\n$$ E_{\\text{unsucc}}(\\alpha) \\approx \\frac{1}{2} \\left(1 + \\frac{1}{(1-\\alpha)^2}\\right) $$\n使用这个结果，我们通过相同的积分关系来求成功查找的期望探测次数：\n$$ E_{\\mathrm{lin}}(\\alpha) = \\frac{1}{\\alpha} \\int_0^\\alpha \\frac{1}{2} \\left(1 + \\frac{1}{(1-x)^2}\\right) dx $$\n我们计算该积分：\n$$ \\int_0^\\alpha \\frac{1}{2} \\left(1 + \\frac{1}{(1-x)^2}\\right) dx = \\frac{1}{2} \\left[ x + \\frac{1}{1-x} \\right]_0^\\alpha $$\n$$ = \\frac{1}{2} \\left( \\left(\\alpha + \\frac{1}{1-\\alpha}\\right) - \\left(0 + \\frac{1}{1-0}\\right) \\right) = \\frac{1}{2} \\left( \\alpha + \\frac{1}{1-\\alpha} - 1 \\right) $$\n化简括号中的表达式：\n$$ \\alpha + \\frac{1}{1-\\alpha} - 1 = \\frac{\\alpha(1-\\alpha) + 1 - (1-\\alpha)}{1-\\alpha} = \\frac{\\alpha - \\alpha^2 + 1 - 1 + \\alpha}{1-\\alpha} = \\frac{2\\alpha - \\alpha^2}{1-\\alpha} = \\frac{\\alpha(2-\\alpha)}{1-\\alpha} $$\n将此结果代回 $E_{\\mathrm{lin}}(\\alpha)$ 的表达式中：\n$$ E_{\\mathrm{lin}}(\\alpha) = \\frac{1}{\\alpha} \\cdot \\frac{1}{2} \\left( \\frac{\\alpha(2-\\alpha)}{1-\\alpha} \\right) = \\frac{1}{2} \\frac{2-\\alpha}{1-\\alpha} $$\n这个表达式可以改写成一个更常见的形式：\n$$ E_{\\mathrm{lin}}(\\alpha) = \\frac{1}{2} \\frac{(1-\\alpha) + 1}{1-\\alpha} = \\frac{1}{2} \\left(1 + \\frac{1}{1-\\alpha}\\right) $$\n\n总而言之，成功查找的期望探测次数的推导表达式如下：\n对于线性探测：$E_{\\mathrm{lin}}(\\alpha) = \\frac{1}{2}\\left(1 + \\frac{1}{1-\\alpha}\\right)$\n对于二次探测：$E_{\\mathrm{quad}}(\\alpha) = \\frac{1}{\\alpha}\\ln\\left(\\frac{1}{1-\\alpha}\\right)$\n对于双重哈希：$E_{\\mathrm{dh}}(\\alpha) = \\frac{1}{\\alpha}\\ln\\left(\\frac{1}{1-\\alpha}\\right)$",
            "answer": "$$ \\boxed{ \\begin{pmatrix} \\frac{1}{2}\\left(1 + \\frac{1}{1-\\alpha}\\right)  \\frac{1}{\\alpha}\\ln\\left(\\frac{1}{1-\\alpha}\\right)  \\frac{1}{\\alpha}\\ln\\left(\\frac{1}{1-\\alpha}\\right) \\end{pmatrix} } $$"
        }
    ]
}