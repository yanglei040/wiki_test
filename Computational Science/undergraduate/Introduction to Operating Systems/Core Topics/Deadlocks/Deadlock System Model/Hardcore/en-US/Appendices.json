{
    "hands_on_practices": [
        {
            "introduction": "To build a solid understanding of deadlock, we begin with the fundamentals. This first practice explores the most basic condition for deadlock: the relationship between the number of processes competing for resources and the quantity of available resources. By analyzing a simplified, worst-case scenario from first principles , you will derive a clear and powerful rule that determines when a system is inherently susceptible to deadlock, providing a foundational intuition for more complex models.",
            "id": "3633188",
            "problem": "Consider a single resource class consisting of $m$ identical printers and $n$ processes. Each process may require at most $2$ printers during its lifetime. The system obeys the four Coffman deadlock conditions: mutual exclusion, hold-and-wait, no preemption, and circular wait. Processes request printers one at a time and do not release any printer they hold until they have acquired all the printers they need to complete. Assume $m \\geq 2$ so that the maximum per-process requirement is physically realizable. Use the deadlock system model for a single resource type and the notion of a Resource Allocation Graph (RAG) to reason from first principles.\n\nTask:\n- Using only the core definitions above (without invoking any pre-proved shortcut criteria), derive a parameterized condition relating $m$ and $n$ under which a deadlock state is possible in the worst case where each process can require up to $2$ printers.\n- Then, specialize your condition to compute the minimal values of $m$ that make deadlock impossible for $n=3$, $n=4$, and $n=5$. Provide your three minimal values for $m$ in the order $n=3$, $n=4$, $n=5$.\n\nNo rounding is needed. Express the final answer as three integers.",
            "solution": "The problem requires the derivation of a condition for the possibility of deadlock in a system with $n$ processes and a single resource class containing $m$ identical instances. Each process has a maximum requirement of $2$ resource instances. The derivation must be from first principles, using the concept of a Resource Allocation Graph (RAG).\n\nFirst, let us establish the fundamental principles. A deadlock is a state in which a set of processes are blocked because each process is holding a resource and waiting for another resource that is held by another process in the set. For a system with a single resource type, the existence of a cycle in the Resource Allocation Graph is a necessary and sufficient condition for a deadlock. A cycle exists if there is a set of waiting processes $\\{P_1, P_2, \\dots, P_k\\}$ such that $P_1$ is waiting for a resource held by $P_2$, $P_2$ is waiting for a resource held by $P_3$, ..., and $P_k$ is waiting for a resource held by $P_1$.\n\nThe four Coffman conditions are given to hold:\n1.  Mutual Exclusion: Each printer can be used by only one process at a time. This is inherent to the problem.\n2.  Hold and Wait: Processes hold the printers they have been allocated while waiting for additional printers. The problem statement specifies this behavior.\n3.  No Preemption: Printers cannot be forcibly taken from a process. This is assumed.\n4.  Circular Wait: This is the condition we must analyze. A deadlock is possible if and only if a circular wait is possible.\n\nTo determine the condition under which a deadlock is possible, we must identify a worst-case scenario of resource allocation that could lead to such a circular wait. A process can be in one of three states regarding its resource allocation: holding $0$ printers, holding $1$ printer, or holding $2$ printers. A process holding $2$ printers has its maximum need met and will eventually complete and release its resources. A process holding $0$ printers is not contributing to the \"hold and wait\" aspect of a deadlock. Therefore, the critical state for a process is holding $1$ printer and waiting for a second.\n\nThe worst-case scenario for the system, maximizing the potential for deadlock, occurs when the maximum possible number of processes are in this critical state. Let us assume all $n$ processes in the system each attempt to acquire their resources one by one. A sequence of events that leads to the highest resource contention is as follows: each of the $n$ processes requests and is granted exactly one printer.\n\nFor this state to be reachable, the system must have enough printers to allocate one to each of the $n$ processes. This is possible if the total number of printers, $m$, is at least equal to the number of processes, $n$. If $m  n$, then only $m$ processes can hold a printer simultaneously.\n\nLet's analyze two cases for the relationship between $m$ and $n$.\n\nCase 1: $m \\le n$.\nIn this case, a deadlock is possible. To demonstrate this, we construct a sequence of events leading to a deadlock.\nLet $k = m$ be the number of processes that will participate in the deadlock. Note that $k \\le n$.\n1.  The first $m$ processes, $P_1, P_2, \\dots, P_m$, each request one printer.\n2.  The operating system grants each of these requests. Let process $P_i$ be allocated printer $R_i$.\nAt this point, all $m$ printers are allocated. The number of available printers is $m - m = 0$.\n3.  Now, each of these $m$ processes requests its second printer. To form a cycle, we can imagine the following requests:\n    - $P_1$ requests the printer $R_2$, which is held by $P_2$.\n    - $P_2$ requests the printer $R_3$, which is held by $P_3$.\n    - ...\n    - $P_{m-1}$ requests the printer $R_m$, which is held by $P_m$.\n    - $P_m$ requests the printer $R_1$, which is held by $P_1$.\nA circular wait condition now exists: $P_1 \\to R_2 \\to P_2 \\to \\dots \\to P_m \\to R_1 \\to P_1$. Since there are no available printers, none of these requests can ever be satisfied. The processes $P_1, \\dots, P_m$ are in a deadlock. Since such a sequence of events is possible, a deadlock is possible if $m \\le n$.\n\nCase 2: $m  n$.\nIn this case, a deadlock is impossible. To prove this, we will show that regardless of the allocation state, there is always at least one process that can complete, meaning the system is always in a safe state.\nConsider any arbitrary state of resource allocation. Let $n_1$ be the number of processes holding $1$ printer and $n_0$ be the number of processes holding $0$ printers. Any process holding $2$ printers can complete, so we do not consider them as part of a potential deadlock. We have $n_0 + n_1 = n$.\nThe total number of allocated printers is $n_1$.\nThe number of available printers is $A = m - n_1$.\nA process holding $1$ printer needs exactly $1$ more to complete. A process holding $0$ printers needs $1$ or $2$ more.\nA deadlock state is one where no process can have its request fulfilled. This would require the remaining need of every process to be greater than the number of available printers.\nFor a process holding $1$ printer, its remaining need is $1$. For it to be blocked, it must be that $1  A$, which means $A=0$.\nThis implies $m - n_1 = 0$, or $m = n_1$.\nHowever, we have the condition $m  n$. We also know that $n_1 \\le n$.\nThis leads to a contradiction: $n_1 = m  n \\ge n_1$, which simplifies to $n_1  n_1$. This is impossible.\nTherefore, it cannot be true that $A=0$ when there are processes holding $1$ resource.\nLet's formalize this: from $m  n$ and $n \\ge n_1$, it follows that $m  n_1$. Since $m$ and $n_1$ are integers, this is equivalent to $m \\ge n_1 + 1$.\nThe number of available printers is $A = m - n_1 \\ge (n_1 + 1) - n_1 = 1$.\nSo, there is always at least one printer available. This printer can be allocated to any of the $n_1$ processes waiting for their second printer. Once that process receives its second printer, it has its maximum need of $2$ and can run to completion. Upon completion, it releases both of its printers. The number of available printers increases to $A - 1 + 2 = A + 1$, and the number of waiting processes decreases. This procedure can be repeated until all processes have completed.\nThus, if $m  n$, no deadlock can ever occur.\n\nSummary of the derived condition:\n- A deadlock is possible if and only if $m \\le n$.\n- A deadlock is impossible if and only if $m  n$.\n\nNow, we specialize this result to compute the minimal values of $m$ that make deadlock impossible for the given values of $n$.\nThe condition for deadlock impossibility is $m  n$. For a given integer $n$, the minimal integer $m$ that satisfies this inequality is $m = n+1$.\n\nFor $n=3$:\nThe minimal value of $m$ to make deadlock impossible is $m = 3+1 = 4$.\n\nFor $n=4$:\nThe minimal value of $m$ to make deadlock impossible is $m = 4+1 = 5$.\n\nFor $n=5$:\nThe minimal value of $m$ to make deadlock impossible is $m = 5+1 = 6$.\n\nThe three minimal values for $m$ are $4$, $5$, and $6$, corresponding to $n=3$, $n=4$, and $n=5$ respectively.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n4  5  6\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "Once we understand when deadlocks are possible, the next logical step is to learn how to actively avoid them. This exercise introduces the Banker's algorithm, a classic and powerful strategy for deadlock avoidance that ensures a system always remains in a \"safe state.\" To sharpen your problem-solving skills, this problem  challenges you to distinguish a genuinely safe state from one that a simplistic, \"naive\" detector would incorrectly flag as unsafe, forcing you to appreciate the subtleties of the algorithm's predictive power.",
            "id": "3633110",
            "problem": "Consider the deadlock system model with $n$ processes and $m$ resource types. Each system state is characterized by three matrices or vectors: the per-process $Allocation$ matrix (current holdings), the per-process $Max$ matrix (declared maximum demands), and the system $Available$ vector (currently free units). A naive detector misclassifies safety by checking only whether there exists a process whose declared maximum demand vector is component-wise less than or equal to the current $Available$ vector; that is, it declares the state unsafe if for all processes $i$, $Max_i \\nleq Available$ in the initial state, disregarding current holdings.\n\nWhich option below provides a concrete instance with $n = 3$ and $m = 2$ in which the state is safe under the correct safety notion used by Banker's algorithm, yet appears unsafe to the naive detector described above? For each option, the per-process data are listed as $P_1$, $P_2$, $P_3$, with $Allocation$ and $Max$ as ordered pairs and $Available$ as an ordered pair.\n\n- A. $Allocation$: $P_1:(1,2)$, $P_2:(3,0)$, $P_3:(1,1)$; $Max$: $P_1:(3,2)$, $P_2:(3,2)$, $P_3:(4,3)$; $Available:(2,2)$.\n\n- B. $Allocation$: $P_1:(1,0)$, $P_2:(2,0)$, $P_3:(0,2)$; $Max$: $P_1:(1,1)$, $P_2:(3,3)$, $P_3:(3,3)$; $Available:(1,1)$.\n\n- C. $Allocation$: $P_1:(2,0)$, $P_2:(0,1)$, $P_3:(0,0)$; $Max$: $P_1:(3,1)$, $P_2:(3,2)$, $P_3:(2,2)$; $Available:(3,1)$.\n\n- D. $Allocation$: $P_1:(2,1)$, $P_2:(1,1)$, $P_3:(0,0)$; $Max$: $P_1:(3,2)$, $P_2:(2,2)$, $P_3:(1,1)$; $Available:(1,0)$.\n\nSelect the single correct option.",
            "solution": "The correct safety notion derives from the Banker's algorithm. Fundamental definitions for the deadlock system model are as follows:\n\n- For each process $P_i$, the remaining requirement (often called the \"need\") is defined by\n$$\nNeed_i = Max_i - Allocation_i,\n$$\ncomputed component-wise for each resource type.\n- A state is safe if there exists an ordering (a safe sequence) of the processes $(Q_1, Q_2, \\dots, Q_n)$ such that, starting with $Work = Available$, for each $Q_k$ in order,\n$$\nNeed_{Q_k} \\le Work,\n$$\nand then the process completes and releases its holdings so that\n$$\nWork \\leftarrow Work + Allocation_{Q_k},\n$$\nbefore proceeding to the next process in the sequence. All relations are interpreted component-wise across the $m$ resource types.\n\nThe naive detector in the problem statement is incorrect because it ignores current holdings and checks only whether there exists a process with $Max_i \\le Available$ initially. This erroneously treats declared maxima as immediate requirements and fails to recognize that processes may already be holding resources sufficient to complete, or that completion releases resources enabling others to finish.\n\nWe now analyze each option using the principle-based definitions.\n\nOption A:\n- Data: $Allocation$: $P_1:(1,2)$, $P_2:(3,0)$, $P_3:(1,1)$; $Max$: $P_1:(3,2)$, $P_2:(3,2)$, $P_3:(4,3)$; $Available:(2,2)$.\n- Compute $Need$:\n$$\nNeed_1 = (3,2) - (1,2) = (2,0),\\quad\nNeed_2 = (3,2) - (3,0) = (0,2),\\quad\nNeed_3 = (4,3) - (1,1) = (3,2).\n$$\n- Begin with $Work = (2,2)$.\n- Check $P_1$: $Need_1 = (2,0) \\le (2,2)$, so $P_1$ can finish. Update\n$$\nWork \\leftarrow (2,2) + Allocation_1 = (2,2) + (1,2) = (3,4).\n$$\n- Check $P_2$: $Need_2 = (0,2) \\le (3,4)$, so $P_2$ can finish. Update\n$$\nWork \\leftarrow (3,4) + Allocation_2 = (3,4) + (3,0) = (6,4).\n$$\n- Check $P_3$: $Need_3 = (3,2) \\le (6,4)$, so $P_3$ can finish. Update\n$$\nWork \\leftarrow (6,4) + Allocation_3 = (6,4) + (1,1) = (7,5).\n$$\n- All processes can complete in the sequence $(P_1, P_2, P_3)$; the state is safe.\n- Naive detector: It tests $Max_i \\le Available$ initially. We have\n$$\n(3,2) \\nleq (2,2),\\quad (3,2) \\nleq (2,2),\\quad (4,3) \\nleq (2,2).\n$$\nNo process satisfies $Max_i \\le Available$ at the start, so the naive detector declares the state unsafe. Therefore, Option A is safe under Banker's algorithm but appears unsafe to the naive detector. Verdict: Correct.\n\nOption B:\n- Data: $Allocation$: $P_1:(1,0)$, $P_2:(2,0)$, $P_3:(0,2)$; $Max$: $P_1:(1,1)$, $P_2:(3,3)$, $P_3:(3,3)$; $Available:(1,1)$.\n- Compute $Need$:\n$$\nNeed_1 = (1,1) - (1,0) = (0,1),\\quad\nNeed_2 = (3,3) - (2,0) = (1,3),\\quad\nNeed_3 = (3,3) - (0,2) = (3,1).\n$$\n- Begin with $Work = (1,1)$.\n- Initially, only $P_1$ satisfies $Need_1 \\le Work$ because $(0,1) \\le (1,1)$, whereas $(1,3) \\nleq (1,1)$ and $(3,1) \\nleq (1,1)$.\n- Finish $P_1$ and update\n$$\nWork \\leftarrow (1,1) + Allocation_1 = (1,1) + (1,0) = (2,1).\n$$\n- With $Work = (2,1)$, check remaining processes:\n$$\nNeed_2 = (1,3) \\nleq (2,1),\\quad Need_3 = (3,1) \\nleq (2,1).\n$$\n- No further process can finish; the algorithm cannot find a safe sequence. The state is unsafe.\n- Naive detector: It checks whether some $Max_i \\le Available$ initially. Here,\n$$\n(1,1) \\le (1,1) \\text{ for } P_1,\n$$\nso the naive detector would declare the state safe. This is a misclassification in the opposite direction. Option B does not match the requested property. Verdict: Incorrect.\n\nOption C:\n- Data: $Allocation$: $P_1:(2,0)$, $P_2:(0,1)$, $P_3:(0,0)$; $Max$: $P_1:(3,1)$, $P_2:(3,2)$, $P_3:(2,2)$; $Available:(3,1)$.\n- Compute $Need$:\n$$\nNeed_1 = (3,1) - (2,0) = (1,1),\\quad\nNeed_2 = (3,2) - (0,1) = (3,1),\\quad\nNeed_3 = (2,2) - (0,0) = (2,2).\n$$\n- Begin with $Work = (3,1)$.\n- $P_1$ can finish since $(1,1) \\le (3,1)$. Update\n$$\nWork \\leftarrow (3,1) + (2,0) = (5,1).\n$$\n- With $Work = (5,1)$, $P_2$ can finish since $(3,1) \\le (5,1)$. Update\n$$\nWork \\leftarrow (5,1) + (0,1) = (5,2).\n$$\n- With $Work = (5,2)$, $P_3$ can finish since $(2,2) \\le (5,2)$. Update\n$$\nWork \\leftarrow (5,2) + (0,0) = (5,2).\n$$\n- All processes can complete; the state is safe.\n- Naive detector: Initially,\n$$\nMax_1 = (3,1) \\le (3,1),\n$$\nso the naive detector declares the state safe as well. This option does not appear unsafe to the naive detector. Verdict: Incorrect.\n\nOption D:\n- Data: $Allocation$: $P_1:(2,1)$, $P_2:(1,1)$, $P_3:(0,0)$; $Max$: $P_1:(3,2)$, $P_2:(2,2)$, $P_3:(1,1)$; $Available:(1,0)$.\n- Compute $Need$:\n$$\nNeed_1 = (3,2) - (2,1) = (1,1),\\quad\nNeed_2 = (2,2) - (1,1) = (1,1),\\quad\nNeed_3 = (1,1) - (0,0) = (1,1).\n$$\n- Begin with $Work = (1,0)$.\n- For all three processes,\n$$\n(1,1) \\nleq (1,0),\n$$\nso no process can finish. There is no safe sequence; the state is unsafe.\n- Naive detector: Initially, for each process $i$,\n$$\nMax_i \\nleq (1,0),\n$$\nso it declares the state unsafe as well. This option does not satisfy the requested property. Verdict: Incorrect.\n\nConclusion: Only Option A presents a state that is safe under Banker's algorithm yet appears unsafe to the naive detector that mistakenly compares $Max$ to $Available$ in the initial state.",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "While avoidance is ideal, some systems allow deadlocks to occur and then focus on detection and recovery. This final practice moves into this crucial operational phase, where an OS must not only identify a deadlock but also resolve it efficiently. You will model a recovery policy that aborts the minimum number of processes necessary to break all deadlock cycles , translating a complex system state into a formal optimization problem and finding the solution that minimizes work lost.",
            "id": "3633125",
            "problem": "An Operating System (OS) uses deadlock detection on a system where every resource type has exactly one instance. In this setting, a deadlock exists if and only if there is a directed cycle in the Wait-For Graph (WFG). When a deadlock is detected, the recovery policy is to abort one or more processes, where aborting process $P_i$ causes a loss of $w_i$ units of work. The goal is to design a principled recovery policy that minimizes the total work lost while guaranteeing deadlock resolution. Using only the definition of a deadlock in a WFG and the notion of cycles, construct a mathematical model that selects which processes to abort so that all deadlocks are eliminated with minimal total work lost, and then evaluate it on the concrete system below.\n\nThe WFG has $6$ processes $P_1, P_2, P_3, P_4, P_5, P_6$ with edges\n$$\nE \\;=\\; \\{(P_1 \\to P_2),\\; (P_2 \\to P_3),\\; (P_3 \\to P_1),\\; (P_3 \\to P_4),\\; (P_4 \\to P_5),\\; (P_5 \\to P_3),\\; (P_2 \\to P_4),\\; (P_4 \\to P_2),\\; (P_5 \\to P_6),\\; (P_6 \\to P_5)\\}.\n$$\nThe per-process work-loss weights are\n$$\nw_1 = 7,\\quad w_2 = 3,\\quad w_3 = 6,\\quad w_4 = 2,\\quad w_5 = 5,\\quad w_6 = 4.\n$$\n\nTasks:\n- Using the WFG-cycle characterization of deadlock for single-instance resources as the only foundational fact, define binary decision variables and formulate an optimization model that captures the policy “abort a set of processes that intersects every directed cycle” while minimizing the total work lost.\n- Identify all simple directed cycles in the given WFG.\n- Solve the optimization model for the given $w_i$ to obtain the minimal total work lost. Express the final answer as a single number equal to the minimal total work lost in units of work. No rounding is required.",
            "solution": "We begin from the foundational characterization for single-instance resources: in a Wait-For Graph (WFG), a deadlock exists if and only if there is a directed cycle. Therefore, to eliminate all deadlocks, it is necessary and sufficient to abort at least one process on every directed cycle. The policy we seek must choose a subset of processes that intersects every directed cycle while minimizing the total work lost.\n\nModeling framework. For each process $P_i$, define a binary decision variable $x_i \\in \\{0,1\\}$, where $x_i = 1$ means that $P_i$ is aborted and $x_i = 0$ means that $P_i$ is not aborted. The total work lost is\n$$\nL(x) \\;=\\; \\sum_{i=1}^{6} w_i x_i.\n$$\nTo guarantee that every directed cycle $C$ in the WFG is broken, we must require that\n$$\n\\sum_{P_i \\in C} x_i \\;\\ge\\; 1\n$$\nfor each directed cycle $C$, since at least one process on that cycle must be aborted to break it. Hence, the optimization model is the following binary integer program:\n$$\n\\min_{x_1,\\dots,x_6 \\in \\{0,1\\}} \\;\\; \\sum_{i=1}^{6} w_i x_i\n\\quad \\text{subject to} \\quad \\sum_{P_i \\in C_k} x_i \\ge 1 \\;\\; \\text{for all simple directed cycles } C_k \\text{ in the WFG}.\n$$\n\nEnumerating cycles. From the edge set\n$$\nE \\;=\\; \\{(P_1 \\to P_2),\\; (P_2 \\to P_3),\\; (P_3 \\to P_1),\\; (P_3 \\to P_4),\\; (P_4 \\to P_5),\\; (P_5 \\to P_3),\\; (P_2 \\to P_4),\\; (P_4 \\to P_2),\\; (P_5 \\to P_6),\\; (P_6 \\to P_5)\\},\n$$\nthe simple directed cycles are:\n- $C_1 = \\{P_1, P_2, P_3\\}$ via $P_1 \\to P_2 \\to P_3 \\to P_1$,\n- $C_2 = \\{P_2, P_4\\}$ via $P_2 \\to P_4 \\to P_2$,\n- $C_3 = \\{P_2, P_3, P_4\\}$ via $P_2 \\to P_3 \\to P_4 \\to P_2$,\n- $C_4 = \\{P_3, P_4, P_5\\}$ via $P_3 \\to P_4 \\to P_5 \\to P_3$,\n- $C_5 = \\{P_5, P_6\\}$ via $P_5 \\to P_6 \\to P_5$,\n- $C_6 = \\{P_1, P_2, P_3, P_4, P_5\\}$ via $P_1 \\to P_2 \\to P_3 \\to P_4 \\to P_5 \\to \\dots$ (this path does not cycle back to $P_1$ through $P_3$ in a simple way, let's trace again: $P_1 \\to P_2 \\to P_4 \\to P_5 \\to P_3 \\to P_1$).\n\nAny non-simple cycle is composed of simple cycles. Therefore, to break all cycles, it is sufficient to break all simple cycles. A full enumeration reveals six simple cycles:\n- $C_1 = \\{P_1, P_2, P_3\\}$\n- $C_2 = \\{P_3, P_4, P_5\\}$\n- $C_3 = \\{P_2, P_4\\}$\n- $C_4 = \\{P_5, P_6\\}$\n- $C_5 = \\{P_2, P_3, P_4\\}$\n- $C_6 = \\{P_1, P_2, P_4, P_5, P_3\\}$\n\nThus, the constraints become:\n$$\n\\begin{aligned}\nx_1 + x_2 + x_3 \\ge 1 \\text{(cycle } C_1\\text{)},\\\\\nx_3 + x_4 + x_5 \\ge 1 \\text{(cycle } C_2\\text{)},\\\\\nx_2 + x_4 \\ge 1 \\text{(cycle } C_3\\text{)},\\\\\nx_5 + x_6 \\ge 1 \\text{(cycle } C_4\\text{)},\\\\\nx_2 + x_3 + x_4 \\ge 1 \\text{(cycle } C_5\\text{)},\\\\\nx_1 + x_2 + x_3 + x_4 + x_5 \\ge 1 \\text{(cycle } C_6\\text{)}.\n\\end{aligned}\n$$\nThe objective, with $w_1 = 7$, $w_2 = 3$, $w_3 = 6$, $w_4 = 2$, $w_5 = 5$, $w_6 = 4$, is\n$$\n\\min \\; 7x_1 + 3x_2 + 6x_3 + 2x_4 + 5x_5 + 4x_6.\n$$\n\nSolving by structured reasoning. We seek a minimal-weight hitting set of the cycles. We can analyze the problem by considering which process to abort to satisfy the constraint for the cheapest cycle to hit, or a cycle that must be hit.\n\nAny feasible solution must satisfy $x_5+x_6 \\ge 1$, which costs at least $\\min(w_5, w_6) = \\min(5,4)=4$. Let's consider these two cases.\n\n- Case 1: Abort $P_6$ ($x_6=1$, cost=4). We must still satisfy constraints for cycles $C_1, C_2, C_3, C_5, C_6$. The cheapest way to satisfy $x_2+x_4 \\ge 1$ (for $C_3$) is to abort $P_4$ ($x_4=1$, cost=2). This also satisfies constraints for $C_2$, $C_5$, and $C_6$. Now we only need to satisfy $x_1+x_2+x_3 \\ge 1$ (for $C_1$). The cheapest option is aborting $P_2$ ($x_2=1$, cost=3). The total cost for this set of choices $\\{P_6, P_4, P_2\\}$ is $4+2+3=9$.\n\n- Case 2: Abort $P_5$ ($x_5=1$, cost=5). This satisfies constraints for cycles $C_2, C_4$, and $C_6$. We must still satisfy constraints for $C_1, C_3, C_5$. Notice that all three of these cycles involve $P_2$. If we abort $P_2$ ($x_2=1$, cost=3), we satisfy all remaining constraints: $x_1+x_2+x_3 \\ge 1$, $x_2+x_4 \\ge 1$, and $x_2+x_3+x_4 \\ge 1$. The total cost for this set of choices $\\{P_5, P_2\\}$ is $5+3=8$.\n\nComparing the cases, the minimal cost solution found is 8. No single process abortion can break all cycles, so the cost must be greater than $\\max(w_i)=7$. The solution with cost 8 is a strong candidate for the optimum. A more exhaustive search confirms that this is indeed the minimal cost. For instance, any solution must contain $\\{P_2 \\text{ or } P_4\\}$ and $\\{P_5 \\text{ or } P_6\\}$. The four combinations have costs:\n- $\\{P_4, P_6\\}$: cost 2+4=6. Fails to cover $C_1$. Add $P_2$ (cost 3) -> total 9.\n- $\\{P_4, P_5\\}$: cost 2+5=7. Fails to cover $C_1$. Add $P_2$ (cost 3) -> total 10.\n- $\\{P_2, P_6\\}$: cost 3+4=7. Fails to cover $C_2$. Add $P_4$ (cost 2) -> total 9.\n- $\\{P_2, P_5\\}$: cost 3+5=8. Covers all cycles.\n\nThus, the minimal total lost work under the optimal recovery policy is $8$ units of work.",
            "answer": "$$\\boxed{8}$$"
        }
    ]
}