{
    "hands_on_practices": [
        {
            "introduction": "理解死锁的第一步是掌握其发生的基本条件。这个练习引导我们从第一性原理出发，在一个只包含一种类型资源的简化系统中，通过分析进程数 $n$ 和资源实例数 $m$ 之间的关系，推导出死锁是否可能发生的一个临界条件 。这种基础分析对于培养我们对资源竞争和系统安全状态的直觉至关重要。",
            "id": "3633188",
            "problem": "考虑一个由 $m$ 台相同打印机和 $n$ 个进程组成的单一资源类。每个进程在其生命周期内最多可能需要 $2$ 台打印机。系统遵循四个Coffman死锁条件：互斥、持有并等待、非抢占和循环等待。进程一次请求一台打印机，并且在获得完成所需的所有打印机之前，不会释放其持有的任何打印机。假设 $m \\geq 2$，以便每个进程的最大需求在物理上是可实现的。使用单一资源类型的死锁系统模型和资源分配图（RAG）的概念，从基本原理出发进行推导。\n\n任务：\n- 仅使用上述核心定义（不借助任何已证明的快捷准则），推导出一个关于 $m$ 和 $n$ 的参数化条件，在该条件下，当每个进程最多可需要 $2$ 台打印机时，在最坏情况下可能出现死锁状态。\n- 然后，将您的条件具体化，计算当 $n=3$、$n=4$ 和 $n=5$ 时，使得死锁不可能发生的 $m$ 的最小值。按 $n=3$、$n=4$、$n=5$ 的顺序提供您的三个 $m$ 的最小值。\n\n无需四舍五入。最终答案以三个整数表示。",
            "solution": "该问题要求在一个包含 $n$ 个进程和 $m$ 个相同实例的单一资源类的系统中，推导出现死锁可能性的条件。每个进程最多需要 $2$ 个资源实例。推导必须从基本原理出发，使用资源分配图（RAG）的概念。\n\n首先，我们建立基本原理。死锁是一组进程被阻塞的状态，其中每个进程都持有一个资源并等待该集合中另一个进程持有的另一个资源。对于单一资源类型的系统，资源分配图中存在环路是发生死锁的充分必要条件。如果存在一组等待进程 $\\{P_1, P_2, \\dots, P_k\\}$，使得 $P_1$ 等待 $P_2$ 持有的资源，$P_2$ 等待 $P_3$ 持有的资源，...，而 $P_k$ 等待 $P_1$ 持有的资源，则存在环路。\n\n给定的四个Coffman条件成立：\n1.  互斥：每台打印机一次只能由一个进程使用。这是问题固有的。\n2.  持有并等待：进程在等待额外打印机时，会继续持有已分配给它们的打印机。问题陈述明确了此行为。\n3.  非抢占：不能从进程中强制收回打印机。这是假设的。\n4.  循环等待：这是我们必须分析的条件。当且仅当循环等待可能发生时，死锁才可能发生。\n\n为了确定可能发生死锁的条件，我们必须识别一个可能导致这种循环等待的资源分配的最坏情况。一个进程在其资源分配方面可以处于三种状态之一：持有 $0$ 台打印机、持有 $1$ 台打印机或持有 $2$ 台打印机。持有 $2$ 台打印机的进程其最大需求已得到满足，最终将完成并释放其资源。持有 $0$ 台打印机的进程对死锁的“持有并等待”方面没有贡献。因此，一个进程的关键状态是持有 $1$ 台打印机并等待第二台。\n\n对于系统而言，使死锁可能性最大化的最坏情况发生在最大可能数量的进程处于这种关键状态时。让我们假设系统中的所有 $n$ 个进程都尝试逐一获取其资源。导致最高资源争用的一系列事件如下：$n$ 个进程中的每一个都请求并被授予一台打印机。\n\n要使此状态可达，系统必须有足够的打印机分配给 $n$ 个进程中的每一个。如果打印机总数 $m$ 至少等于进程数 $n$，这是可能的。如果 $m  n$，则只有 $m$ 个进程可以同时持有一台打印机。\n\n让我们分析 $m$ 和 $n$ 之间关系的两种情况。\n\n情况1：$m \\le n$。\n在这种情况下，死锁是可能的。为了证明这一点，我们构造一个导致死锁的事件序列。\n令参与死锁的进程数量为 $k = m$。注意 $k \\le n$。\n1.  前 $m$ 个进程 $P_1, P_2, \\dots, P_m$ 各请求一台打印机。\n2.  操作系统批准了这些请求。假设进程 $P_i$ 被分配了打印机 $R_i$。\n此时，所有 $m$ 台打印机都已被分配。可用打印机数量为 $m - m = 0$。\n3.  现在，这 $m$ 个进程中的每一个都请求其第二台打印机。为了形成一个环路，我们可以想象以下请求：\n    - $P_1$ 请求 $P_2$ 持有的打印机 $R_2$。\n    - $P_2$ 请求 $P_3$ 持有的打印机 $R_3$。\n    - ...\n    - $P_{m-1}$ 请求 $P_m$ 持有的打印机 $R_m$。\n    - $P_m$ 请求 $P_1$ 持有的打印机 $R_1$。\n现在存在一个循环等待条件：$P_1 \\to R_2 \\to P_2 \\to \\dots \\to P_m \\to R_1 \\to P_1$。由于没有可用的打印机，这些请求都无法被满足。进程 $P_1, \\dots, P_m$ 处于死锁状态。由于这样的事件序列是可能的，如果 $m \\le n$，则死锁是可能的。\n\n情况2：$m > n$。\n在这种情况下，死锁是不可能的。为了证明这一点，我们将表明，无论资源分配状态如何，总有至少一个进程可以完成，这意味着系统总是处于安全状态。\n考虑任何任意的资源分配状态。令 $n_1$ 为持有 $1$ 台打印机的进程数，$n_0$ 为持有 $0$ 台打印机的进程数。任何持有 $2$ 台打印机的进程都可以完成，所以我们不将它们视为潜在死锁的一部分。我们有 $n_0 + n_1 = n$。\n已分配的打印机总数为 $n_1$。\n可用打印机的数量为 $A = m - n_1$。\n一个持有 $1$ 台打印机的进程正好还需要 $1$ 台才能完成。一个持有 $0$ 台打印机的进程还需要 $1$ 或 $2$ 台。\n死锁状态是指没有进程的请求可以被满足。这将要求每个进程的剩余需求都大于可用打印机的数量。\n对于一个持有 $1$ 台打印机的进程，其剩余需求为 $1$。要使其被阻塞，必须满足 $1 > A$，这意味着 $A=0$。\n这意味着 $m - n_1 = 0$，或 $m = n_1$。\n然而，我们有条件 $m > n$。我们还知道 $n_1 \\le n$。\n这导致了一个矛盾：$n_1 = m > n \\ge n_1$，可以简化为 $n_1 > n_1$。这是不可能的。\n因此，当有进程持有 $1$ 个资源时，$A=0$ 是不成立的。\n让我们将其形式化：从 $m > n$ 和 $n \\ge n_1$ 可推导出 $m > n_1$。由于 $m$ 和 $n_1$ 是整数，这等价于 $m \\ge n_1 + 1$。\n可用打印机的数量为 $A = m - n_1 \\ge (n_1 + 1) - n_1 = 1$。\n所以，总有至少一台打印机可用。这台打印机可以分配给任何一个等待其第二台打印机的 $n_1$ 个进程。一旦该进程收到了它的第二台打印机，它就满足了其最大需求 $2$，可以运行至完成。完成后，它会释放其两台打印机。可用打印机的数量增加到 $A - 1 + 2 = A + 1$，等待进程的数量减少。这个过程可以重复进行，直到所有进程都完成。\n因此，如果 $m > n$，则永远不会发生死锁。\n\n推导出的条件总结：\n- 当且仅当 $m \\le n$ 时，死锁是可能的。\n- 当且仅当 $m > n$ 时，死锁是不可能的。\n\n现在，我们将此结果具体化，以计算给定 $n$ 值下使死锁不可能发生的 $m$ 的最小值。\n死锁不可能发生的条件是 $m > n$。对于一个给定的整数 $n$，满足此不等式的最小整数 $m$ 是 $m = n+1$。\n\n对于 $n=3$：\n使死锁不可能发生的 $m$ 的最小值为 $m = 3+1 = 4$。\n\n对于 $n=4$：\n使死锁不可能发生的 $m$ 的最小值为 $m = 4+1 = 5$。\n\n对于 $n=5$：\n使死锁不可能发生的 $m$ 的最小值为 $m = 5+1 = 6$。\n\n对应于 $n=3$、$n=4$ 和 $n=5$， $m$ 的三个最小值分别为 $4$、$5$ 和 $6$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n4  5  6\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在更复杂的、包含多种资源类型的系统中，我们可以采用死锁避免策略来确保系统始终处于安全状态。银行家算法是实现这一目标的核心方法，它通过精确计算进程的未来需求来做出决策。这个练习旨在深化你对银行家算法安全检查逻辑的理解，通过一个巧妙的例子，你需要识别出一个实际上安全但会被“朴素”检测器误判为不安全的状态 。",
            "id": "3633110",
            "problem": "考虑一个包含 $n$ 个进程和 $m$ 种资源类型的死锁系统模型。每个系统状态由三个矩阵或向量来表征：每个进程的 $Allocation$ 矩阵（当前持有量）、每个进程的 $Max$ 矩阵（已声明的最大需求量），以及系统的 $Available$ 向量（当前可用单元数）。一个朴素的检测器会错误地判断安全性，它仅检查是否存在一个进程，其声明的最大需求向量按分量小于或等于当前的 $Available$ 向量；也就是说，如果在初始状态下，对于所有进程 $i$ 都有 $Max_i \\nleq Available$，它就宣布该状态为不安全，而忽略了当前的持有量。\n\n以下哪个选项提供了一个具体的实例（$n = 3$ 且 $m = 2$），在该实例中，根据银行家算法使用的正确安全概念，状态是安全的，但对于上述的朴素检测器来说却是不安全的？对于每个选项，各进程的数据以 $P_1$、$P_2$、$P_3$ 的形式列出，其中 $Allocation$ 和 $Max$ 是有序对，$Available$ 也是一个有序对。\n\n- A. $Allocation$：$P_1:(1,2)$，$P_2:(3,0)$，$P_3:(1,1)$；$Max$：$P_1:(3,2)$，$P_2:(3,2)$，$P_3:(4,3)$；$Available:(2,2)$。\n\n- B. $Allocation$：$P_1:(1,0)$，$P_2:(2,0)$，$P_3:(0,2)$；$Max$：$P_1:(1,1)$，$P_2:(3,3)$，$P_3:(3,3)$；$Available:(1,1)$。\n\n- C. $Allocation$：$P_1:(2,0)$，$P_2:(0,1)$，$P_3:(0,0)$；$Max$：$P_1:(3,1)$，$P_2:(3,2)$，$P_3:(2,2)$；$Available:(3,1)$。\n\n- D. $Allocation$：$P_1:(2,1)$，$P_2:(1,1)$，$P_3:(0,0)$；$Max$：$P_1:(3,2)$，$P_2:(2,2)$，$P_3:(1,1)$；$Available:(1,0)$。\n\n选择唯一正确的选项。",
            "solution": "正确的安全概念源于银行家算法。死锁系统模型的基本定义如下：\n\n- 对于每个进程 $P_i$，其剩余需求（通常称为“need”）由以下公式定义\n$$\nNeed_i = Max_i - Allocation_i,\n$$\n按资源类型逐分量计算。\n- 如果存在一个进程的排序（一个安全序列）$(Q_1, Q_2, \\dots, Q_n)$，使得从 $Work = Available$ 开始，对于序列中的每个 $Q_k$，\n$$\nNeed_{Q_k} \\le Work,\n$$\n该进程可以完成并释放其持有的资源，从而\n$$\nWork \\leftarrow Work + Allocation_{Q_k},\n$$\n然后继续处理序列中的下一个进程，则状态是安全的。所有关系都针对 $m$ 种资源类型进行逐分量解释。\n\n问题描述中的朴素检测器是不正确的，因为它忽略了当前的持有量，仅检查初始时是否存在一个进程满足 $Max_i \\le Available$。这种做法错误地将声明的最大值视为立即需求，并且没有认识到进程可能已经持有足够的资源来完成，或者某个进程的完成会释放资源从而使其他进程能够结束。\n\n我们现在使用基于原则的定义来分析每个选项。\n\n选项 A:\n- 数据：$Allocation$：$P_1:(1,2)$，$P_2:(3,0)$，$P_3:(1,1)$；$Max$：$P_1:(3,2)$，$P_2:(3,2)$，$P_3:(4,3)$；$Available:(2,2)$。\n- 计算 $Need$：\n$$\nNeed_1 = (3,2) - (1,2) = (2,0),\\quad\nNeed_2 = (3,2) - (3,0) = (0,2),\\quad\nNeed_3 = (4,3) - (1,1) = (3,2).\n$$\n- 从 $Work = (2,2)$ 开始。\n- 检查 $P_1$：$Need_1 = (2,0) \\le (2,2)$，因此 $P_1$ 可以完成。更新\n$$\nWork \\leftarrow (2,2) + Allocation_1 = (2,2) + (1,2) = (3,4).\n$$\n- 检查 $P_2$：$Need_2 = (0,2) \\le (3,4)$，因此 $P_2$ 可以完成。更新\n$$\nWork \\leftarrow (3,4) + Allocation_2 = (3,4) + (3,0) = (6,4).\n$$\n- 检查 $P_3$：$Need_3 = (3,2) \\le (6,4)$，因此 $P_3$ 可以完成。更新\n$$\nWork \\leftarrow (6,4) + Allocation_3 = (6,4) + (1,1) = (7,5).\n$$\n- 所有进程都可以在序列 $(P_1, P_2, P_3)$ 中完成；该状态是安全的。\n- 朴素检测器：它在初始时测试 $Max_i \\le Available$。我们有\n$$\n(3,2) \\nleq (2,2),\\quad (3,2) \\nleq (2,2),\\quad (4,3) \\nleq (2,2).\n$$\n开始时没有进程满足 $Max_i \\le Available$，所以朴素检测器宣布状态为不安全。因此，选项A在银行家算法下是安全的，但对朴素检测器来说却是不安全的。结论：正确。\n\n选项 B:\n- 数据：$Allocation$：$P_1:(1,0)$，$P_2:(2,0)$，$P_3:(0,2)$；$Max$：$P_1:(1,1)$，$P_2:(3,3)$，$P_3:(3,3)$；$Available:(1,1)$。\n- 计算 $Need$：\n$$\nNeed_1 = (1,1) - (1,0) = (0,1),\\quad\nNeed_2 = (3,3) - (2,0) = (1,3),\\quad\nNeed_3 = (3,3) - (0,2) = (3,1).\n$$\n- 从 $Work = (1,1)$ 开始。\n- 最初，只有 $P_1$ 满足 $Need_1 \\le Work$，因为 $(0,1) \\le (1,1)$，而 $(1,3) \\nleq (1,1)$ 且 $(3,1) \\nleq (1,1)$。\n- 完成 $P_1$ 并更新\n$$\nWork \\leftarrow (1,1) + Allocation_1 = (1,1) + (1,0) = (2,1).\n$$\n- 当 $Work = (2,1)$ 时，检查剩余进程：\n$$\nNeed_2 = (1,3) \\nleq (2,1),\\quad Need_3 = (3,1) \\nleq (2,1).\n$$\n- 没有其他进程可以完成；算法无法找到安全序列。该状态是不安全的。\n- 朴素检测器：它检查初始时是否有某个 $Max_i \\le Available$。这里，\n$$\n(1,1) \\le (1,1) \\text{ 对于 } P_1,\n$$\n所以朴素检测器会宣布状态为安全。这是一个方向相反的错误分类。选项B不符合所要求的属性。结论：错误。\n\n选项 C:\n- 数据：$Allocation$：$P_1:(2,0)$，$P_2:(0,1)$，$P_3:(0,0)$；$Max$：$P_1:(3,1)$，$P_2:(3,2)$，$P_3:(2,2)$；$Available:(3,1)$。\n- 计算 $Need$：\n$$\nNeed_1 = (3,1) - (2,0) = (1,1),\\quad\nNeed_2 = (3,2) - (0,1) = (3,1),\\quad\nNeed_3 = (2,2) - (0,0) = (2,2).\n$$\n- 从 $Work = (3,1)$ 开始。\n- $P_1$ 可以完成，因为 $(1,1) \\le (3,1)$。更新\n$$\nWork \\leftarrow (3,1) + (2,0) = (5,1).\n$$\n- 当 $Work = (5,1)$ 时，$P_2$ 可以完成，因为 $(3,1) \\le (5,1)$。更新\n$$\nWork \\leftarrow (5,1) + (0,1) = (5,2).\n$$\n- 当 $Work = (5,2)$ 时，$P_3$ 可以完成，因为 $(2,2) \\le (5,2)$。更新\n$$\nWork \\leftarrow (5,2) + (0,0) = (5,2).\n$$\n- 所有进程都可以完成；该状态是安全的。\n- 朴素检测器：初始时，\n$$\nMax_1 = (3,1) \\le (3,1),\n$$\n所以朴素检测器也会宣布状态是安全的。此选项对朴素检测器来说并非不安全。结论：错误。\n\n选项 D:\n- 数据：$Allocation$：$P_1:(2,1)$，$P_2:(1,1)$，$P_3:(0,0)$；$Max$：$P_1:(3,2)$，$P_2:(2,2)$，$P_3:(1,1)$；$Available:(1,0)$。\n- 计算 $Need$：\n$$\nNeed_1 = (3,2) - (2,1) = (1,1),\\quad\nNeed_2 = (2,2) - (1,1) = (1,1),\\quad\nNeed_3 = (1,1) - (0,0) = (1,1).\n$$\n- 从 $Work = (1,0)$ 开始。\n- 对于所有三个进程，\n$$\n(1,1) \\nleq (1,0),\n$$\n所以没有进程可以完成。不存在安全序列；该状态是不安全的。\n- 朴素检测器：初始时，对于每个进程 $i$，\n$$\nMax_i \\nleq (1,0),\n$$\n所以它也会宣布状态为不安全。此选项不满足所要求的属性。结论：错误。\n\n结论：只有选项A呈现了一个在银行家算法下是安全的，但对于错误地在初始状态下比较 $Max$ 和 $Available$ 的朴素检测器来说却是不安全的状态。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "当系统不采用死锁避免，或者避免策略失效时，我们就需要依赖死锁的检测和恢复。此练习模拟了这样一个场景：在一个所有资源都只有一个实例的系统中，通过分析等待图（Wait-For Graph）中的环路来检测死锁。你的任务是构建一个优化模型，以最小的工作损失为代价，选择中止哪些进程来打破所有死锁环路，从而将理论化的恢复策略付诸实践 。",
            "id": "3633125",
            "problem": "一个操作系统（OS）在一个系统中进行死锁检测，该系统中每种资源类型都只有一个实例。在这种情况下，当且仅当等待图（WFG）中存在有向环时，才会发生死锁。当检测到死锁时，恢复策略是中止一个或多个进程，其中中止进程 $P_i$ 会导致 $w_i$ 个单位的工作损失。目标是设计一个有原则的恢复策略，在保证解决死锁的同时，最小化总工作损失。仅使用WFG中死锁的定义和环的概念，构建一个数学模型来选择要中止的进程，以最小的总工作损失消除所有死锁，然后对下面的具体系统进行评估。\n\n该WFG有 $6$ 个进程 $P_1, P_2, P_3, P_4, P_5, P_6$，其边集为\n$$\nE \\;=\\; \\{(P_1 \\to P_2),\\; (P_2 \\to P_3),\\; (P_3 \\to P_1),\\; (P_3 \\to P_4),\\; (P_4 \\to P_5),\\; (P_5 \\to P_3),\\; (P_2 \\to P_4),\\; (P_4 \\to P_2),\\; (P_5 \\to P_6),\\; (P_6 \\to P_5)\\}.\n$$\n每个进程的工作损失权重为\n$$\nw_1 = 7,\\quad w_2 = 3,\\quad w_3 = 6,\\quad w_4 = 2,\\quad w_5 = 5,\\quad w_6 = 4.\n$$\n\n任务：\n- 仅以单实例资源死锁的WFG环特征为唯一基本事实，定义二进制决策变量，并构建一个优化模型，该模型体现了“中止一个与每个有向环都相交的进程集合”的策略，同时最小化总工作损失。\n- 识别给定WFG中的所有简单有向环。\n- 针对给定的 $w_i$ 求解优化模型，以获得最小总工作损失。将最终答案表示为一个等于最小总工作损失的单一数值（以工作单位计）。无需四舍五入。",
            "solution": "我们从单实例资源的基本特征出发：在等待图（WFG）中，当且仅当存在有向环时，才会发生死锁。因此，要消除所有死锁，充分且必要的条件是在每个有向环上至少中止一个进程。我们寻求的策略必须选择一个与每个有向环都相交的进程子集，同时最小化总工作损失。\n\n建模框架。对于每个进程 $P_i$，定义一个二进制决策变量 $x_i \\in \\{0,1\\}$，其中 $x_i = 1$ 表示进程 $P_i$ 被中止，而 $x_i = 0$ 表示进程 $P_i$ 未被中止。总工作损失为\n$$\nL(x) \\;=\\; \\sum_{i=1}^{6} w_i x_i.\n$$\n为保证WFG中的每个有向环 $C$ 都被打破，我们必须要求\n$$\n\\sum_{P_i \\in C} x_i \\;\\ge\\; 1\n$$\n对于每个有向环 $C$，因为必须中止该环上的至少一个进程才能打破它。因此，该优化模型是以下二进制整数规划：\n$$\n\\min_{x_1,\\dots,x_6 \\in \\{0,1\\}} \\;\\; \\sum_{i=1}^{6} w_i x_i\n\\quad \\text{subject to} \\quad \\sum_{P_i \\in C_k} x_i \\ge 1 \\;\\; \\text{对于WFG中所有的有向环 } C_k \\text{。}\n$$\n\n枚举环。根据边集\n$$\nE \\;=\\; \\{(P_1 \\to P_2),\\; (P_2 \\to P_3),\\; (P_3 \\to P_1),\\; (P_3 \\to P_4),\\; (P_4 \\to P_5),\\; (P_5 \\to P_3),\\; (P_2 \\to P_4),\\; (P_4 \\to P_2),\\; (P_5 \\to P_6),\\; (P_6 \\to P_5)\\},\n$$\n简单有向环是：\n- $C_1 = \\{P_1, P_2, P_3\\}$ 通过 $P_1 \\to P_2 \\to P_3 \\to P_1$，\n- $C_2 = \\{P_3, P_4, P_5\\}$ 通过 $P_3 \\to P_4 \\to P_5 \\to P_3$，\n- $C_3 = \\{P_2, P_4\\}$ 通过 $P_2 \\to P_4 \\to P_2$，\n- $C_4 = \\{P_5, P_6\\}$ 通过 $P_5 \\to P_6 \\to P_5$。\n\n任何更大的有向环必然是这些简单环的组合，并且通过要求每个简单环至少中止一个进程的条件，已经覆盖了这些更大的环。\n\n因此，约束条件变为：\n$$\n\\begin{aligned}\nx_1 + x_2 + x_3 \\ge 1 \\text{(环 } C_1\\text{)},\\\\\nx_3 + x_4 + x_5 \\ge 1 \\text{(环 } C_2\\text{)},\\\\\nx_2 + x_4 \\ge 1 \\text{(环 } C_3\\text{)},\\\\\nx_5 + x_6 \\ge 1 \\text{(环 } C_4\\text{)}.\n\\end{aligned}\n$$\n目标函数为，其中 $w_1 = 7$, $w_2 = 3$, $w_3 = 6$, $w_4 = 2$, $w_5 = 5$, $w_6 = 4$：\n$$\n\\min \\; 7x_1 + 3x_2 + 6x_3 + 2x_4 + 5x_5 + 4x_6.\n$$\n\n通过结构化推理求解。我们寻求这些环的一个最小权重命中集。观察到 $x_4$ 的成本较低，为 $w_4 = 2$，并且它同时有助于满足 $C_2$ 和 $C_3$ 的约束。然而，无论 $x_4$ 取何值，环 $C_1$ 和环 $C_4$ 仍需被命中。\n\n我们考虑以下组合：\n\n- 选择 $x_5 = 1$ 以满足 $C_4$，成本为 $5$；然后为了满足 $C_1$ 和 $C_3$，最便宜的方式是选择 $x_2 = 1$（成本 $3$），这也满足了 $C_1$ 和 $C_3$。在 $x_2 = 1$ 的情况下，$C_2$ 尚未被 $x_2$ 或 $x_5$ 满足，但由于 $x_5 = 1$ 已经满足了 $C_2$，因此所有约束都得到了满足。总成本为 $5 + 3 = 8$。\n\n- 或者，选择 $x_6 = 1$（成本 $4$）来满足 $C_4$。这样一来，$C_2$ 仍需被命中，$C_1$ 和 $C_3$ 也需要覆盖。一种低成本的方法是设置 $x_4 = 1$（成本 $2$）来命中 $C_2$ 和 $C_3$，并设置 $x_2 = 1$（成本 $3$）来命中 $C_1$；总成本为 $4 + 2 + 3 = 9$。\n\n- 考虑使用 $x_3 = 1$（成本 $6$）来同时命中 $C_1$ 和 $C_2$。但这没有命中 $C_3$ 或 $C_4$，所以我们还必须为 $C_3$ 选择 $x_2 = 1$ 或 $x_4 = 1$，为 $C_4$ 选择 $x_5 = 1$ 或 $x_6 = 1$。完成此任务的最便宜组合是 $x_4 = 1$ 和 $x_6 = 1$，总成本为 $6 + 2 + 4 = 12$，比 $8$ 要差。\n\n- 考虑使用 $x_4 = 1$（成本 $2$）来命中 $C_2$ 和 $C_3$，然后以最小成本覆盖 $C_1$ 和 $C_4$。对于 $C_1$，最便宜的是 $x_2 = 1$（成本 $3$），对于 $C_4$，最便宜的是 $x_6 = 1$（成本 $4$）。总成本为 $2 + 3 + 4 = 9$，同样比 $8$ 差。\n\n我们现在论证成本为 $8$ 的解 $\\{x_2 = 1, x_5 = 1\\}$ 的最优性。任何可行解都必须命中 $C_4$，这要求 $x_5$ 或 $x_6$ 中至少有一个为 $1$，成本至少为 $\\min\\{5,4\\} = 4$。如果选择 $x_6 = 1$（成本 $4$），那么 $C_2$ 必须由 $\\{x_3, x_4, x_5\\}$ 中的一个命中，$C_1$ 必须由 $\\{x_1, x_2, x_3\\}$ 中的一个命中，$C_3$ 必须由 $\\{x_2, x_4\\}$ 中的一个命中。同时覆盖 $C_2$ 和 $C_3$ 的最便宜组合是 $x_4 = 1$（成本 $2$），然后 $C_1$ 至少需要 $x_2 = 1$（成本 $3$）或 $x_3 = 1$（成本 $6$）或 $x_1 = 1$（成本 $7$），导致总成本至少为 $4 + 2 + 3 = 9$。如果转而选择 $x_5 = 1$（成本 $5$），那么 $C_2$ 已经被命中，我们仍然必须命中 $C_1$ 和 $C_3$。同时命中这两者的最便宜方法是 $x_2 = 1$（成本 $3$），总成本为 $5 + 3 = 8$。没有单个进程可以命中所有环，因为没有一个顶点同时位于 $C_1$、$C_2$、$C_3$ 和 $C_4$ 中。因此，成本严格低于 $8$ 是不可能的，最小总工作损失为 $8$。\n\n因此，在最优恢复策略下，最小总工作损失为 $8$ 个工作单位。",
            "answer": "$$\\boxed{8}$$"
        }
    ]
}