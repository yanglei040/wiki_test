{
    "hands_on_practices": [
        {
            "introduction": "Before implementing complex deadlock prevention or avoidance schemes, a fundamental question is whether deadlock is even possible in a given system. This exercise challenges you to reason from first principles about the conditions that can lead to deadlock in a simplified, single-resource system. By analyzing the worst-case scenario where processes hold some resources while requesting others, you will derive a critical threshold relating the number of processes ($n$) and available resources ($m$), providing a foundational understanding of system safety. ",
            "id": "3633188",
            "problem": "Consider a single resource class consisting of $m$ identical printers and $n$ processes. Each process may require at most $2$ printers during its lifetime. The system obeys the four Coffman deadlock conditions: mutual exclusion, hold-and-wait, no preemption, and circular wait. Processes request printers one at a time and do not release any printer they hold until they have acquired all the printers they need to complete. Assume $m \\geq 2$ so that the maximum per-process requirement is physically realizable. Use the deadlock system model for a single resource type and the notion of a Resource Allocation Graph (RAG) to reason from first principles.\n\nTask:\n- Using only the core definitions above (without invoking any pre-proved shortcut criteria), derive a parameterized condition relating $m$ and $n$ under which a deadlock state is possible in the worst case where each process can require up to $2$ printers.\n- Then, specialize your condition to compute the minimal values of $m$ that make deadlock impossible for $n=3$, $n=4$, and $n=5$. Provide your three minimal values for $m$ in the order $n=3$, $n=4$, $n=5$.\n\nNo rounding is needed. Express the final answer as three integers.",
            "solution": "The problem requires the derivation of a condition for the possibility of deadlock in a system with $n$ processes and a single resource class containing $m$ identical instances. Each process has a maximum requirement of $2$ resource instances. The derivation must be from first principles, using the concept of a Resource Allocation Graph (RAG).\n\nFirst, let us establish the fundamental principles. A deadlock is a state in which a set of processes are blocked because each process is holding a resource and waiting for another resource that is held by another process in the set. For a system with a single resource type, the existence of a cycle in the Resource Allocation Graph is a necessary and sufficient condition for a deadlock. A cycle exists if there is a set of waiting processes $\\{P_1, P_2, \\dots, P_k\\}$ such that $P_1$ is waiting for a resource held by $P_2$, $P_2$ is waiting for a resource held by $P_3$, ..., and $P_k$ is waiting for a resource held by $P_1$.\n\nThe four Coffman conditions are given to hold:\n1.  Mutual Exclusion: Each printer can be used by only one process at a time. This is inherent to the problem.\n2.  Hold and Wait: Processes hold the printers they have been allocated while waiting for additional printers. The problem statement specifies this behavior.\n3.  No Preemption: Printers cannot be forcibly taken from a process. This is assumed.\n4.  Circular Wait: This is the condition we must analyze. A deadlock is possible if and only if a circular wait is possible.\n\nTo determine the condition under which a deadlock is possible, we must identify a worst-case scenario of resource allocation that could lead to such a circular wait. A process can be in one of three states regarding its resource allocation: holding $0$ printers, holding $1$ printer, or holding $2$ printers. A process holding $2$ printers has its maximum need met and will eventually complete and release its resources. A process holding $0$ printers is not contributing to the \"hold and wait\" aspect of a deadlock. Therefore, the critical state for a process is holding $1$ printer and waiting for a second.\n\nThe worst-case scenario for the system, maximizing the potential for deadlock, occurs when the maximum possible number of processes are in this critical state. Let us assume all $n$ processes in the system each attempt to acquire their resources one by one. A sequence of events that leads to the highest resource contention is as follows: each of the $n$ processes requests and is granted exactly one printer.\n\nFor this state to be reachable, the system must have enough printers to allocate one to each of the $n$ processes. This is possible if the total number of printers, $m$, is at least equal to the number of processes, $n$. If $m  n$, then only $m$ processes can hold a printer simultaneously.\n\nLet's analyze two cases for the relationship between $m$ and $n$.\n\nCase 1: $m \\le n$.\nIn this case, a deadlock is possible. To demonstrate this, we construct a sequence of events leading to a deadlock.\nLet $k = m$ be the number of processes that will participate in the deadlock. Note that $k \\le n$.\n1.  The first $m$ processes, $P_1, P_2, \\dots, P_m$, each request one printer.\n2.  The operating system grants each of these requests. Let process $P_i$ be allocated printer $R_i$.\nAt this point, all $m$ printers are allocated. The number of available printers is $m - m = 0$.\n3.  Now, each of these $m$ processes requests its second printer. To form a cycle, we can imagine the following requests:\n    - $P_1$ requests the printer $R_2$, which is held by $P_2$.\n    - $P_2$ requests the printer $R_3$, which is held by $P_3$.\n    - ...\n    - $P_{m-1}$ requests the printer $R_m$, which is held by $P_m$.\n    - $P_m$ requests the printer $R_1$, which is held by $P_1$.\nA circular wait condition now exists: $P_1 \\to R_2 \\to P_2 \\to \\dots \\to P_m \\to R_1 \\to P_1$. Since there are no available printers, none of these requests can ever be satisfied. The processes $P_1, \\dots, P_m$ are in a deadlock. Since such a sequence of events is possible, a deadlock is possible if $m \\le n$.\n\nCase 2: $m  n$.\nIn this case, a deadlock is impossible. To prove this, we will show that regardless of the allocation state, there is always at least one process that can complete, meaning the system is always in a safe state.\nConsider any arbitrary state of resource allocation. Let $n_1$ be the number of processes holding $1$ printer and $n_0$ be the number of processes holding $0$ printers. Any process holding $2$ printers can complete, so we do not consider them as part of a potential deadlock. We have $n_0 + n_1 = n$.\nThe total number of allocated printers is $n_1$.\nThe number of available printers is $A = m - n_1$.\nA process holding $1$ printer needs exactly $1$ more to complete. A process holding $0$ printers needs $1$ or $2$ more.\nA deadlock state is one where no process can have its request fulfilled. This would require the remaining need of every process to be greater than the number of available printers.\nFor a process holding $1$ printer, its remaining need is $1$. For it to be blocked, it must be that $1  A$, which means $A=0$.\nThis implies $m - n_1 = 0$, or $m = n_1$.\nHowever, we have the condition $m  n$. We also know that $n_1 \\le n$.\nThis leads to a contradiction: $n_1 = m  n \\ge n_1$, which simplifies to $n_1  n_1$. This is impossible.\nTherefore, it cannot be true that $A=0$ when there are processes holding $1$ resource.\nLet's formalize this: from $m  n$ and $n \\ge n_1$, it follows that $m  n_1$. Since $m$ and $n_1$ are integers, this is equivalent to $m \\ge n_1 + 1$.\nThe number of available printers is $A = m - n_1 \\ge (n_1 + 1) - n_1 = 1$.\nSo, there is always at least one printer available. This printer can be allocated to any of the $n_1$ processes waiting for their second printer. Once that process receives its second printer, it has its maximum need of $2$ and can run to completion. Upon completion, it releases both of its printers. The number of available printers increases to $A - 1 + 2 = A + 1$, and the number of waiting processes decreases. This procedure can be repeated until all processes have completed.\nThus, if $m  n$, no deadlock can ever occur.\n\nSummary of the derived condition:\n- A deadlock is possible if and only if $m \\le n$.\n- A deadlock is impossible if and only if $m  n$.\n\nNow, we specialize this result to compute the minimal values of $m$ that make deadlock impossible for the given values of $n$.\nThe condition for deadlock impossibility is $m  n$. For a given integer $n$, the minimal integer $m$ that satisfies this inequality is $m = n+1$.\n\nFor $n=3$:\nThe minimal value of $m$ to make deadlock impossible is $m = 3+1 = 4$.\n\nFor $n=4$:\nThe minimal value of $m$ to make deadlock impossible is $m = 4+1 = 5$.\n\nFor $n=5$:\nThe minimal value of $m$ to make deadlock impossible is $m = 5+1 = 6$.\n\nThe three minimal values for $m$ are $4$, $5$, and $6$, corresponding to $n=3$, $n=4$, and $n=5$ respectively.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n4  5  6\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "Once we know deadlock is possible, the next step is to actively avoid it. The Banker's algorithm is a classic deadlock avoidance strategy that guarantees safety by carefully managing resource grants. This practice requires you to step into the role of the OS and apply the safety algorithm to distinguish a truly safe state from one that only appears unsafe to a simplistic check, reinforcing the crucial difference between maximum claims ($Max$) and remaining needs ($Need$). ",
            "id": "3633110",
            "problem": "Consider the deadlock system model with $n$ processes and $m$ resource types. Each system state is characterized by three matrices or vectors: the per-process $Allocation$ matrix (current holdings), the per-process $Max$ matrix (declared maximum demands), and the system $Available$ vector (currently free units). A naive detector misclassifies safety by checking only whether there exists a process whose declared maximum demand vector is component-wise less than or equal to the current $Available$ vector; that is, it declares the state unsafe if for all processes $i$, $Max_i \\nleq Available$ in the initial state, disregarding current holdings.\n\nWhich option below provides a concrete instance with $n = 3$ and $m = 2$ in which the state is safe under the correct safety notion used by Banker's algorithm, yet appears unsafe to the naive detector described above? For each option, the per-process data are listed as $P_1$, $P_2$, $P_3$, with $Allocation$ and $Max$ as ordered pairs and $Available$ as an ordered pair.\n\n- A. $Allocation$: $P_1:(1,2)$, $P_2:(3,0)$, $P_3:(1,1)$; $Max$: $P_1:(3,2)$, $P_2:(3,2)$, $P_3:(4,3)$; $Available:(2,2)$.\n\n- B. $Allocation$: $P_1:(1,0)$, $P_2:(2,0)$, $P_3:(0,2)$; $Max$: $P_1:(1,1)$, $P_2:(3,3)$, $P_3:(3,3)$; $Available:(1,1)$.\n\n- C. $Allocation$: $P_1:(2,0)$, $P_2:(0,1)$, $P_3:(0,0)$; $Max$: $P_1:(3,1)$, $P_2:(3,2)$, $P_3:(2,2)$; $Available:(3,1)$.\n\n- D. $Allocation$: $P_1:(2,1)$, $P_2:(1,1)$, $P_3:(0,0)$; $Max$: $P_1:(3,2)$, $P_2:(2,2)$, $P_3:(1,1)$; $Available:(1,0)$.\n\nSelect the single correct option.",
            "solution": "The correct safety notion derives from the Banker's algorithm. Fundamental definitions for the deadlock system model are as follows:\n\n- For each process $P_i$, the remaining requirement (often called the \"need\") is defined by\n$$\nNeed_i = Max_i - Allocation_i,\n$$\ncomputed component-wise for each resource type.\n- A state is safe if there exists an ordering (a safe sequence) of the processes $(Q_1, Q_2, \\dots, Q_n)$ such that, starting with $Work = Available$, for each $Q_k$ in order,\n$$\nNeed_{Q_k} \\le Work,\n$$\nand then the process completes and releases its holdings so that\n$$\nWork \\leftarrow Work + Allocation_{Q_k},\n$$\nbefore proceeding to the next process in the sequence. All relations are interpreted component-wise across the $m$ resource types.\n\nThe naive detector in the problem statement is incorrect because it ignores current holdings and checks only whether there exists a process with $Max_i \\le Available$ initially. This erroneously treats declared maxima as immediate requirements and fails to recognize that processes may already be holding resources sufficient to complete, or that completion releases resources enabling others to finish.\n\nWe now analyze each option using the principle-based definitions.\n\nOption A:\n- Data: $Allocation$: $P_1:(1,2)$, $P_2:(3,0)$, $P_3:(1,1)$; $Max$: $P_1:(3,2)$, $P_2:(3,2)$, $P_3:(4,3)$; $Available:(2,2)$.\n- Compute $Need$:\n$$\nNeed_1 = (3,2) - (1,2) = (2,0),\\quad\nNeed_2 = (3,2) - (3,0) = (0,2),\\quad\nNeed_3 = (4,3) - (1,1) = (3,2).\n$$\n- Begin with $Work = (2,2)$.\n- Check $P_1$: $Need_1 = (2,0) \\le (2,2)$, so $P_1$ can finish. Update\n$$\nWork \\leftarrow (2,2) + Allocation_1 = (2,2) + (1,2) = (3,4).\n$$\n- Check $P_2$: $Need_2 = (0,2) \\le (3,4)$, so $P_2$ can finish. Update\n$$\nWork \\leftarrow (3,4) + Allocation_2 = (3,4) + (3,0) = (6,4).\n$$\n- Check $P_3$: $Need_3 = (3,2) \\le (6,4)$, so $P_3$ can finish. Update\n$$\nWork \\leftarrow (6,4) + Allocation_3 = (6,4) + (1,1) = (7,5).\n$$\n- All processes can complete in the sequence $(P_1, P_2, P_3)$; the state is safe.\n- Naive detector: It tests $Max_i \\le Available$ initially. We have\n$$\n(3,2) \\nleq (2,2),\\quad (3,2) \\nleq (2,2),\\quad (4,3) \\nleq (2,2).\n$$\nNo process satisfies $Max_i \\le Available$ at the start, so the naive detector declares the state unsafe. Therefore, Option A is safe under Banker's algorithm but appears unsafe to the naive detector. Verdict: Correct.\n\nOption B:\n- Data: $Allocation$: $P_1:(1,0)$, $P_2:(2,0)$, $P_3:(0,2)$; $Max$: $P_1:(1,1)$, $P_2:(3,3)$, $P_3:(3,3)$; $Available:(1,1)$.\n- Compute $Need$:\n$$\nNeed_1 = (1,1) - (1,0) = (0,1),\\quad\nNeed_2 = (3,3) - (2,0) = (1,3),\\quad\nNeed_3 = (3,3) - (0,2) = (3,1).\n$$\n- Begin with $Work = (1,1)$.\n- Initially, only $P_1$ satisfies $Need_1 \\le Work$ because $(0,1) \\le (1,1)$, whereas $(1,3) \\nleq (1,1)$ and $(3,1) \\nleq (1,1)$.\n- Finish $P_1$ and update\n$$\nWork \\leftarrow (1,1) + Allocation_1 = (1,1) + (1,0) = (2,1).\n$$\n- With $Work = (2,1)$, check remaining processes:\n$$\nNeed_2 = (1,3) \\nleq (2,1),\\quad Need_3 = (3,1) \\nleq (2,1).\n$$\n- No further process can finish; the algorithm cannot find a safe sequence. The state is unsafe.\n- Naive detector: It checks whether some $Max_i \\le Available$ initially. Here,\n$$\n(1,1) \\le (1,1) \\text{ for } P_1,\n$$\nso the naive detector would declare the state safe. This is a misclassification in the opposite direction. Option B does not match the requested property. Verdict: Incorrect.\n\nOption C:\n- Data: $Allocation$: $P_1:(2,0)$, $P_2:(0,1)$, $P_3:(0,0)$; $Max$: $P_1:(3,1)$, $P_2:(3,2)$, $P_3:(2,2)$; $Available:(3,1)$.\n- Compute $Need$:\n$$\nNeed_1 = (3,1) - (2,0) = (1,1),\\quad\nNeed_2 = (3,2) - (0,1) = (3,1),\\quad\nNeed_3 = (2,2) - (0,0) = (2,2).\n$$\n- Begin with $Work = (3,1)$.\n- $P_1$ can finish since $(1,1) \\le (3,1)$. Update\n$$\nWork \\leftarrow (3,1) + (2,0) = (5,1).\n$$\n- With $Work = (5,1)$, $P_2$ can finish since $(3,1) \\le (5,1)$. Update\n$$\nWork \\leftarrow (5,1) + (0,1) = (5,2).\n$$\n- With $Work = (5,2)$, $P_3$ can finish since $(2,2) \\le (5,2)$. Update\n$$\nWork \\leftarrow (5,2) + (0,0) = (5,2).\n$$\n- All processes can complete; the state is safe.\n- Naive detector: Initially,\n$$\nMax_1 = (3,1) \\le (3,1),\n$$\nso the naive detector declares the state safe as well. This option does not appear unsafe to the naive detector. Verdict: Incorrect.\n\nOption D:\n- Data: $Allocation$: $P_1:(2,1)$, $P_2:(1,1)$, $P_3:(0,0)$; $Max$: $P_1:(3,2)$, $P_2:(2,2)$, $P_3:(1,1)$; $Available:(1,0)$.\n- Compute $Need$:\n$$\nNeed_1 = (3,2) - (2,1) = (1,1),\\quad\nNeed_2 = (2,2) - (1,1) = (1,1),\\quad\nNeed_3 = (1,1) - (0,0) = (1,1).\n$$\n- Begin with $Work = (1,0)$.\n- For all three processes,\n$$\n(1,1) \\nleq (1,0),\n$$\nso no process can finish. There is no safe sequence; the state is unsafe.\n- Naive detector: Initially, for each process $i$,\n$$\nMax_i \\nleq (1,0),\n$$\nso it declares the state unsafe as well. This option does not satisfy the requested property. Verdict: Incorrect.\n\nConclusion: Only Option A presents a state that is safe under Banker's algorithm yet appears unsafe to the naive detector that mistakenly compares $Max$ to $Available$ in the initial state.",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "When avoidance strategies are not used or fail, an operating system must be able to detect and recover from deadlock. This exercise shifts our focus to this reactive approach, where deadlocks are identified as cycles in a Wait-For Graph (WFG). Your task is to design a principled recovery policy by framing it as an optimization problem: how to break all cycles with the minimum possible \"work loss,\" demonstrating how graph theory provides a powerful tool for making optimal recovery decisions. ",
            "id": "3633125",
            "problem": "An Operating System (OS) uses deadlock detection on a system where every resource type has exactly one instance. In this setting, a deadlock exists if and only if there is a directed cycle in the Wait-For Graph (WFG). When a deadlock is detected, the recovery policy is to abort one or more processes, where aborting process $P_i$ causes a loss of $w_i$ units of work. The goal is to design a principled recovery policy that minimizes the total work lost while guaranteeing deadlock resolution. Using only the definition of a deadlock in a WFG and the notion of cycles, construct a mathematical model that selects which processes to abort so that all deadlocks are eliminated with minimal total work lost, and then evaluate it on the concrete system below.\n\nThe WFG has $6$ processes $P_1, P_2, P_3, P_4, P_5, P_6$ with edges\n$$\nE \\;=\\; \\{(P_1 \\to P_2),\\; (P_2 \\to P_3),\\; (P_3 \\to P_1),\\; (P_3 \\to P_4),\\; (P_4 \\to P_5),\\; (P_5 \\to P_3),\\; (P_2 \\to P_4),\\; (P_4 \\to P_2),\\; (P_5 \\to P_6),\\; (P_6 \\to P_5)\\}.\n$$\nThe per-process work-loss weights are\n$$\nw_1 = 7,\\quad w_2 = 3,\\quad w_3 = 6,\\quad w_4 = 2,\\quad w_5 = 5,\\quad w_6 = 4.\n$$\n\nTasks:\n- Using the WFG-cycle characterization of deadlock for single-instance resources as the only foundational fact, define binary decision variables and formulate an optimization model that captures the policy “abort a set of processes that intersects every directed cycle” while minimizing the total work lost.\n- Identify all simple directed cycles in the given WFG.\n- Solve the optimization model for the given $w_i$ to obtain the minimal total work lost. Express the final answer as a single number equal to the minimal total work lost in units of work. No rounding is required.",
            "solution": "We begin from the foundational characterization for single-instance resources: in a Wait-For Graph (WFG), a deadlock exists if and only if there is a directed cycle. Therefore, to eliminate all deadlocks, it is necessary and sufficient to abort at least one process on every directed cycle. The policy we seek must choose a subset of processes that intersects every directed cycle while minimizing the total work lost.\n\nModeling framework. For each process $P_i$, define a binary decision variable $x_i \\in \\{0,1\\}$, where $x_i = 1$ means that $P_i$ is aborted and $x_i = 0$ means that $P_i$ is not aborted. The total work lost is\n$$\nL(x) \\;=\\; \\sum_{i=1}^{6} w_i x_i.\n$$\nTo guarantee that every directed cycle $C$ in the WFG is broken, we must require that\n$$\n\\sum_{P_i \\in C} x_i \\;\\ge\\; 1\n$$\nfor each directed cycle $C$, since at least one process on that cycle must be aborted to break it. Hence, the optimization model is the following binary integer program:\n$$\n\\min_{x_1,\\dots,x_6 \\in \\{0,1\\}} \\;\\; \\sum_{i=1}^{6} w_i x_i\n\\quad \\text{subject to} \\quad \\sum_{P_i \\in C_k} x_i \\ge 1 \\;\\; \\text{for all directed cycles } C_k \\text{ in the WFG}.\n$$\n\nEnumerating cycles. A comprehensive search of the graph for all simple directed cycles is required. From the edge set\n$$\nE \\;=\\; \\{(P_1 \\to P_2),\\; (P_2 \\to P_3),\\; (P_3 \\to P_1),\\; (P_3 \\to P_4),\\; (P_4 \\to P_5),\\; (P_5 \\to P_3),\\; (P_2 \\to P_4),\\; (P_4 \\to P_2),\\; (P_5 \\to P_6),\\; (P_6 \\to P_5)\\},\n$$\nthe simple directed cycles are:\n- $C_1 = \\{P_1, P_2, P_3\\}$ via $P_1 \\to P_2 \\to P_3 \\to P_1$.\n- $C_2 = \\{P_2, P_4\\}$ via $P_2 \\to P_4 \\to P_2$.\n- $C_3 = \\{P_3, P_4, P_5\\}$ via $P_3 \\to P_4 \\to P_5 \\to P_3$.\n- $C_4 = \\{P_2, P_3, P_4\\}$ via $P_2 \\to P_3 \\to P_4 \\to P_2$.\n- $C_5 = \\{P_5, P_6\\}$ via $P_5 \\to P_6 \\to P_5$.\n\nThus, the constraints become:\n$$\n\\begin{aligned}\nx_1 + x_2 + x_3 \\ge 1 \\text{(cycle } C_1\\text{)},\\\\\nx_2 + x_4 \\ge 1 \\text{(cycle } C_2\\text{)},\\\\\nx_3 + x_4 + x_5 \\ge 1 \\text{(cycle } C_3\\text{)},\\\\\nx_2 + x_3 + x_4 \\ge 1 \\text{(cycle } C_4\\text{)},\\\\\nx_5 + x_6 \\ge 1 \\text{(cycle } C_5\\text{)}.\n\\end{aligned}\n$$\nThe objective, with $w_1 = 7$, $w_2 = 3$, $w_3 = 6$, $w_4 = 2$, $w_5 = 5$, $w_6 = 4$, is\n$$\n\\min \\; 7x_1 + 3x_2 + 6x_3 + 2x_4 + 5x_5 + 4x_6.\n$$\n\nSolving by structured reasoning. We seek a minimal-weight hitting set of the cycles. Observe that $x_4$ is inexpensive with $w_4 = 2$, and it simultaneously helps satisfy constraints for $C_2$, $C_3$, and $C_4$. However, cycle $C_1$ and cycle $C_5$ remain to be hit regardless of $x_4$.\n\nWe consider combinations:\n\n- Choose $x_5 = 1$ to satisfy $C_5$ with cost $5$. With $x_5=1$, cycle $C_3$ is also hit. To satisfy the remaining cycles ($C_1, C_2, C_4$), the cheapest way is to choose $x_2 = 1$ (cost $3$). This hits $C_1, C_2, C_4$. All constraints are met. The total cost is $w_5 + w_2 = 5 + 3 = 8$.\n\n- Alternatively, choose $x_6 = 1$ (cost $4$) to satisfy $C_5$. Then $C_1, C_2, C_3, C_4$ remain to be hit. A low-cost approach is to set $x_4 = 1$ (cost $2$) to hit $C_2$, $C_3$, and $C_4$. Then $C_1$ must still be hit, and the cheapest way is to set $x_2 = 1$ (cost $3$). The total cost is $w_6 + w_4 + w_2 = 4 + 2 + 3 = 9$.\n\n- Consider using $x_3 = 1$ (cost $6$) to hit $C_1$, $C_3$, and $C_4$. This does not hit $C_2$ or $C_5$, so we must also choose either $x_2 = 1$ or $x_4 = 1$ for $C_2$ and either $x_5 = 1$ or $x_6 = 1$ for $C_5$. The cheapest such completion is $x_4 = 1$ and $x_6 = 1$, with total cost $6 + 2 + 4 = 12$, which is worse than $8$.\n\n- Consider using $x_4 = 1$ (cost $2$) to hit $C_2$, $C_3$, and $C_4$. We must still cover $C_1$ and $C_5$ with minimal cost. For $C_1$, the cheapest is $x_2 = 1$ (cost $3$), and for $C_5$, the cheapest is $x_6 = 1$ (cost $4$). Total cost is $2 + 3 + 4 = 9$, again worse than $8$.\n\nWe now argue optimality of the $8$-cost solution $\\{x_2 = 1, x_5 = 1\\}$. Any feasible solution must hit $C_5$, which requires at least one of $x_5$ or $x_6$ to be $1$, costing at least $\\min\\{5,4\\} = 4$. If it chooses $x_6 = 1$ (cost $4$), then cycles $C_1, C_2, C_3, C_4$ must be hit. The cheapest way to hit $C_2, C_3, C_4$ is by picking $x_4=1$ (cost 2) or $x_2=1$ (cost 3). If we pick $x_4=1$, we must still hit $C_1$, costing at least $\\min(w_1, w_2, w_3) = 3$ by picking $x_2=1$. This gives a total of $4+2+3=9$. If we pick $x_2=1$, we still must hit $C_3$, costing at least $\\min(w_3,w_4,w_5)=2$ by picking $x_4=1$. This gives a total of $4+3+2=9$. So any solution starting with $x_6=1$ costs at least 9.\nIf instead the solution chooses $x_5 = 1$ (cost $5$), then $C_3$ and $C_5$ are already hit. We still must hit $C_1$, $C_2$, and $C_4$. The cheapest way to hit all three is to pick $x_2 = 1$ (cost $3$), which lies on all three of these remaining cycles. This yields a total cost of $5 + 3 = 8$.\nNo single process can hit all cycles since no vertex lies in all of $C_1$, $C_2$, $C_3$, $C_4$, and $C_5$. Therefore, a cost strictly below $8$ is impossible, and the minimal total work lost is $8$.\n\nThus, the minimal total lost work under the optimal recovery policy is $8$ units of work.",
            "answer": "$$\\boxed{8}$$"
        }
    ]
}