{
    "hands_on_practices": [
        {
            "introduction": "这个练习将我们置于一个管理共享实验室设备的真实场景中。它挑战我们超越简单的算法，去选择一种基本的策略——资源排序——来打破“循环等待”这个死锁发生的关键条件。这个实践突显了结构化规则  如何成为一种强大而高效的死锁避免方法，而无需进行复杂的状态跟踪。",
            "id": "3631764",
            "problem": "一位实验室协调员希望将课堂设备借出系统建模为操作系统 (OS) 框架内的一个资源分配问题，以避免在实验轮换期间发生死锁。现有 $2$ 种资源类型：显微镜 (类型 $r_1$) 和示波器 (类型 $r_2$)。两者都是物理设备，因此资源是不可抢占的。实验小组随时间动态到达，他们执行的任务可能需要一种设备，或者在某些跨学科步骤中，需要同时使用两种设备。协调员无法预先可靠地知道每个小组未来的最大需求。目标是采用一种可证明地避免死锁的预留策略，同时在安全的情况下，仍然允许小组使用单个设备取得进展（例如，在使用显微镜准备样本时，等待示波器）。\n\n使用死锁理论的基本原理：Coffman 条件指出，如果以下所有条件同时成立，就可能发生死锁——互斥、持有并等待、不可抢占和循环等待。可以通过设计策略来确保系统永远不会进入可能发生死锁的状态，从而实现死锁避免。\n\n哪种单一的预留策略最能满足协调员的约束和目标？\n\nA. 先来先服务 (FCFS)：当所请求的设备可用时，批准每个请求；如果一个小组持有一个设备，允许其等待直到第二个设备可用，对请求顺序没有限制。\n\nB. 对资源类型强加一个严格的全序关系，并要求所有小组按递增顺序请求（例如，总是先请求 $r_1$ 再请求 $r_2$），并拒绝任何不按顺序的请求；小组可以持有 $r_1$ 并稍后根据该顺序请求 $r_2$。\n\nC. 尽管每个小组未来的最大需求未知，仍在每个请求时应用银行家算法；仅根据当前可用性推断安全性，并接受任何不会立即耗尽设备的请求。\n\nD. 强制执行全有或全无的组合预留：仅当 $r_1$ 和 $r_2$ 同时可用时才批准小组的请求；否则拒绝并要求稍后重新提交，从而在等待期间阻止任何使用单个设备的进展。",
            "solution": "此问题要求我们从四种策略中选择一种最佳策略，用于在无法预知进程最大资源需求的情况下避免死锁，同时满足允许进程在持有一个资源时等待另一个资源的灵活性要求。我们将逐一分析每个选项。\n\n*   **A. 先来先服务 (FCFS)**：此策略不对资源请求的顺序施加任何限制。考虑两个小组，$G_1$ 和 $G_2$。$G_1$ 请求并获得了显微镜 ($r_1$)，然后等待示波器 ($r_2$)。同时，$G_2$ 请求并获得了示波器 ($r_2$)，然后等待显微镜 ($r_1$)。此时，$G_1$ 持有 $r_1$ 等待 $r_2$，$G_2$ 持有 $r_2$ 等待 $r_1$。这形成了**循环等待**，满足了死锁的四个必要条件（互斥、持有并等待、不可抢占、循环等待），因此可能导致死锁。故此选项不安全。\n\n*   **B. 资源排序**：此策略通过对资源类型施加一个全局的、严格的请求顺序（例如，必须先请求 $r_1$ 再请求 $r_2$）来破坏**循环等待**条件。在任何情况下，一个持有高序位资源（$r_2$）的小组永远不会去请求一个低序位资源（$r_1$）。这就从结构上杜绝了循环依赖的可能性，从而**预防**了死锁。同时，该策略允许一个小组持有 $r_1$ 并等待 $r_2$，满足了问题中“使用单个设备取得进展”的要求。因此，这是一个有效且满足所有约束的策略。\n\n*   **C. 银行家算法**：银行家算法是经典的**死锁避免**算法，但其核心前提是必须预先知道每个进程对每种资源的**最大需求量**。问题明确指出“协调员无法预先可靠地知道每个小组未来的最大需求”。因此，应用银行家算法的基础条件不满足，此选项不可行。\n\n*   **D. 全有或全无**：此策略通过破坏**持有并等待**条件来预防死锁。小组要么一次性获得所有所需资源，要么一个也得不到。这确实能有效避免死锁。然而，问题要求策略应“仍然允许小组使用单个设备取得进展（例如，在使用显微镜准备样本时，等待示波器）”。“全有或全无”策略禁止了这种行为，因为它不允许在持有部分资源的情况下等待其他资源。因此，该策略不满足问题的灵活性目标。\n\n**结论**：综合分析，只有选项 B（资源排序）能够在不预知最大需求的情况下，通过破坏循环等待条件来有效避免死锁，并且满足了允许进程在等待期间继续使用已持有资源的要求。",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "在考虑了高层策略之后，让我们深入银行家算法的具体操作。这个问题要求我们通过明确找出所有可能的安全完成序列，来判断一个由机器人竞争充电桩组成的系统是否处于安全状态。这是理解操作系统  如何做出可证明安全的资源分配决策的核心技能。",
            "id": "3631832",
            "problem": "一个移动机器人实验室部署了一个由 $3$ 个机器人组成的集群，这些机器人共享由一个中央实验室调度器以类似操作系统 (OS) 的方式提供的两种充电资源：快速充电桩 ($F$) 和标准充电桩 ($S$)。每个机器人需要这些资源的组合来完成其充电过程。实验室调度器使用死锁避免中的概念来为资源使用建模，特别是安全状态的概念和作为银行家调度策略基础的最大需求框架。\n\n实验室中可用资源的总数为 $\\mathbf{T} = (F, S) = (5, 6)$。在某一时刻，每个机器ンの当前资源分配和声明的最大需求如下，其中行对应机器人 $R_1$、$R_2$ 和 $R_3$，列对应 $F$ 和 $S$：\n\n当前分配矩阵 $\\mathbf{A}$：\n$$\n\\mathbf{A} = \n\\begin{pmatrix}\n1  2 \\\\\n2  0 \\\\\n1  3\n\\end{pmatrix}.\n$$\n\n最大需求矩阵 $\\mathbf{M}$：\n$$\n\\mathbf{M} =\n\\begin{pmatrix}\n3  3 \\\\\n3  2 \\\\\n2  4\n\\end{pmatrix}.\n$$\n\n从死锁避免中安全状态的核心定义出发——即，如果存在某个机器人完成顺序，使得每个机器人都能从可用资源加上先前完成的机器人所释放的资源中获得其剩余所需资源，那么该状态就是安全的——请将此充电场景映射到最大需求框架，并确定在当前时刻存在多少个不同的安全充电完成序列。请用一个整数表示你的最终答案。无需四舍五入。",
            "solution": "问题要求基于用于死锁避免的银行家算法，计算一个由 $3$ 个机器人竞争 $2$ 种资源的系统中，不同安全完成序列的数量。如果存在至少一个机器人完成序列，使得每个机器人都能获取其所需的最大资源，则状态是安全的。我们需要找到所有这样的唯一序列。\n\n首先，我们使用银行家算法的标准术语来形式化该问题。\n进程（机器人）的数量为 $n=3$，资源类型（充电桩）的数量为 $m=2$。\n\n给定条件如下：\n- 每种类型的可用资源总数，由向量 $\\mathbf{T} = (5, 6)$ 表示，其中第一个分量代表快速充电桩 ($F$)，第二个分量代表标准充电桩 ($S$)。\n- 当前分配矩阵 $\\mathbf{A}$，它指定了当前分配给每个机器人的每种资源的数量。\n$$\n\\mathbf{A} = \n\\begin{pmatrix}\n1  2 \\\\\n2  0 \\\\\n1  3\n\\end{pmatrix}\n$$\n各行对应机器人 $R_1$、$R_2$ 和 $R_3$。\n- 最大需求矩阵 $\\mathbf{M}$，它指定了每个机器人在其整个充电过程中可能请求的每种资源的最大数量。\n$$\n\\mathbf{M} =\n\\begin{pmatrix}\n3  3 \\\\\n3  2 \\\\\n2  4\n\\end{pmatrix}\n$$\n\n根据这些给定条件，我们可以推导出安全算法所需的基本要素。\n\n1.  **计算可用资源向量 $\\mathbf{V}$**：\n每种类型已分配的资源总数是分配矩阵 $\\mathbf{A}$ 各列的总和。\n已分配的 $F$ 资源总数：$1 + 2 + 1 = 4$。\n已分配的 $S$ 资源总数：$2 + 0 + 3 = 5$。\n已分配资源总量向量为 $(4, 5)$。\n\n可用资源向量 $\\mathbf{V}$ 是总资源向量 $\\mathbf{T}$ 减去已分配资源总量向量。\n$$\n\\mathbf{V} = \\mathbf{T} - (4, 5) = (5, 6) - (4, 5) = (1, 1)\n$$\n所以，最初有 $1$ 个快速充电桩和 $1$ 个标准充电桩可用。\n\n2.  **计算需求矩阵 $\\mathbf{N}$**：\n需求矩阵 $\\mathbf{N}$ 表示每个机器人仍然可能请求的剩余资源。它通过最大需求矩阵 $\\mathbf{M}$ 与当前分配矩阵 $\\mathbf{A}$ 之差计算得出。\n$$\n\\mathbf{N} = \\mathbf{M} - \\mathbf{A} = \n\\begin{pmatrix}\n3 - 1  3 - 2 \\\\\n3 - 2  2 - 0 \\\\\n2 - 1  4 - 3\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n2  1 \\\\\n1  2 \\\\\n1  1\n\\end{pmatrix}\n$$\n$\\mathbf{N}$ 的行是每个机器人的需求向量：\n- $R_1$ 的需求：$\\mathbf{N}_1 = (2, 1)$\n- $R_2$ 的需求：$\\mathbf{N}_2 = (1, 2)$\n- $R_3$ 的需求：$\\mathbf{N}_3 = (1, 1)$\n\n3.  **使用安全算法找出所有安全序列**：\n安全算法检查是否存在一个机器人序列 $\\langle R_{i_1}, R_{i_2}, \\dots, R_{i_n} \\rangle$，使得对于每个机器人 $R_{i_k}$，其需求向量 $\\mathbf{N}_{i_k}$ 小于或等于当前可用资源向量。如果这个条件成立，机器人就可以完成其任务并释放其已分配的资源，这些资源随后被加到可用资源池中。我们必须找到所有这样的有效序列。\n\n设未完成的机器人集合为 $\\{R_1, R_2, R_3\\}$。初始可用向量为 $\\mathbf{V}^{(0)} = (1, 1)$。\n\n**步骤 1：寻找序列中的第一个机器人。**\n我们检查哪个机器人 $R_i$ 满足条件 $\\mathbf{N}_i \\le \\mathbf{V}^{(0)}$。如果对于所有分量 $j$ 都有 $a_j \\le b_j$，则向量 $\\mathbf{a} \\le \\mathbf{b}$。\n- 对于 $R_1$：$\\mathbf{N}_1 = (2, 1) \\le (1, 1)$ 是否成立？否，因为 $2 > 1$。\n- 对于 $R_2$：$\\mathbf{N}_2 = (1, 2) \\le (1, 1)$ 是否成立？否，因为 $2 > 1$。\n- 对于 $R_3$：$\\mathbf{N}_3 = (1, 1) \\le (1, 1)$ 是否成立？是，因为 $1 \\le 1$ 且 $1 \\le 1$。\n\n只有 $R_3$ 可以作为安全序列中的第一个机器人。因此，任何安全序列都必须以 $\\langle R_3, \\dots \\rangle$ 开始。\n\n**步骤 2：寻找序列中的第二个机器人。**\n假设 $R_3$ 运行至完成，它会释放其已分配的资源 $\\mathbf{A}_3 = (1, 3)$。新的可用资源向量变为：\n$$\n\\mathbf{V}^{(1)} = \\mathbf{V}^{(0)} + \\mathbf{A}_3 = (1, 1) + (1, 3) = (2, 4)\n$$\n现在未完成的机器人集合为 $\\{R_1, R_2\\}$。我们检查在可用资源为 $\\mathbf{V}^{(1)} = (2, 4)$ 的情况下，哪个机器人可以接下来运行。\n- 对于 $R_1$：$\\mathbf{N}_1 = (2, 1) \\le (2, 4)$ 是否成立？是，因为 $2 \\le 2$ 且 $1 \\le 4$。\n- 对于 $R_2$：$\\mathbf{N}_2 = (1, 2) \\le (2, 4)$ 是否成立？是，因为 $1 \\le 2$ 且 $2 \\le 4$。\n\n$R_1$ 和 $R_2$ 都可以作为序列中的第二个机器人。这产生了两个不同的分支。\n\n**分支 A：序列为 $\\langle R_3, R_1, \\dots \\rangle$。**\n$R_1$ 运行并释放其已分配的资源 $\\mathbf{A}_1 = (1, 2)$。新的可用向量为：\n$$\n\\mathbf{V}^{(2A)} = \\mathbf{V}^{(1)} + \\mathbf{A}_1 = (2, 4) + (1, 2) = (3, 6)\n$$\n唯一剩下的未完成机器人是 $R_2$。我们检查它是否可以运行。\n- 对于 $R_2$：$\\mathbf{N}_2 = (1, 2) \\le (3, 6)$ 是否成立？是，因为 $1 \\le 3$ 且 $2 \\le 6$。\n$R_2$ 可以完成。这得出了第一个安全序列：$\\langle R_3, R_1, R_2 \\rangle$。\n\n**分支 B：序列为 $\\langle R_3, R_2, \\dots \\rangle$。**\n$R_2$ 运行并释放其已分配的资源 $\\mathbf{A}_2 = (2, 0)$。新的可用向量为：\n$$\n\\mathbf{V}^{(2B)} = \\mathbf{V}^{(1)} + \\mathbf{A}_2 = (2, 4) + (2, 0) = (4, 4)\n$$\n唯一剩下的未完成机器人是 $R_1$。我们检查它是否可以运行。\n- 对于 $R_1$：$\\mathbf{N}_1 = (2, 1) \\le (4, 4)$ 是否成立？是，因为 $2 \\le 4$ 且 $1 \\le 4$。\n$R_1$ 可以完成。这得出了第二个安全序列：$\\langle R_3, R_2, R_1 \\rangle$。\n\n我们已经探索了所有可能的路径。搜索结果表明，恰好有两个不同的安全完成序列。\n\n安全序列集合为：\n1. $\\langle R_3, R_1, R_2 \\rangle$\n2. $\\langle R_3, R_2, R_1 \\rangle$\n\n不同的安全充电完成序列总数为 $2$。",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "现实世界的系统是动态变化的。这个练习模拟了一个进程在开始运行后需要增加其最大资源声明 $M$ 的情景。我们将运用银行家算法 ，不仅是检查一个静态状态，而是要确定这种动态变化的最大允许限度，同时保证系统始终维持在安全状态。这展示了死锁避免算法在适应变化条件时的灵活性和强大功能。",
            "id": "3631866",
            "problem": "考虑一个使用Dijkstra银行家算法（一种资源分配和死锁避免算法）来管理两种资源类型（表示为 $R_1$ 和 $R_2$）的系统。设总资源向量为 $$T = \\begin{pmatrix} 10 \\\\ 9 \\end{pmatrix},$$ 其中第一个分量对应 $R_1$，第二个分量对应 $R_2$。系统中有 $4$ 个进程，$P_1, P_2, P_3, P_4$。当前的分配矩阵是 $$A = \\begin{pmatrix} 2  1 \\\\ 3  2 \\\\ 2  3 \\\\ 1  1 \\end{pmatrix},$$ 其中第 $i$ 行给出了当前分配给进程 $P_i$ 的 $(R_1, R_2)$ 资源单位数。初始声明的最大需求矩阵是 $$M = \\begin{pmatrix} 4  3 \\\\ 5  4 \\\\ 3  5 \\\\ 3  2 \\end{pmatrix},$$ 其中第 $i$ 行给出了进程 $P_i$ 在其整个生命周期中可能需要的 $(R_1, R_2)$ 资源的最大单位数。\n\n在时间 $t$，当上述分配生效后且在任何进一步的资源请求被批准之前，进程 $P_1$ 发出一个动态更新，将其对 $R_1$ 的最大需求增加 $x$ 个单位（其对 $R_2$ 的最大需求保持不变）。这将其最大需求行从 $\\begin{pmatrix} 4  3 \\end{pmatrix}$ 变为 $\\begin{pmatrix} 4 + x  3 \\end{pmatrix}$。系统仅当根据安全状态的定义，由此产生的状态仍然是安全的情况下，才会接受此动态更新。安全状态的定义是：存在一个进程终止的序列，使得序列中的每个进程，其剩余需求可以由当前可用资源加上先前已完成进程释放的资源来满足。\n\n假设不允许抢占当前持有的资源，除非动态更新后无法保持安全状态。仅使用安全状态、可用资源、分配、最大需求和需求量的基本定义，确定最大的整数 $x$，使得该动态更新可以被接受而无需强制抢占。请将您的答案表示为一个精确的整数，不要四舍五入。",
            "solution": "问题要求解出最大的整数 $x$，使得对进程 $P_1$ 最大需求的动态更新是允许的，这意味着由此产生的系统状态仍然是安全的。一个状态是安全的，如果存在一个进程的排序，使得每个进程都能获取其所需的最大资源并运行至完成。\n\n首先，让我们将给定的信息形式化。系统有 $4$ 个进程，$P_1, P_2, P_3, P_4$，和 $2$ 种资源类型，$R_1$ 和 $R_2$。\n\n总资源向量由下式给出：\n$$T = \\begin{pmatrix} 10 \\\\ 9 \\end{pmatrix}$$\n\n当前的分配矩阵 $A$ 是：\n$$A = \\begin{pmatrix} 2  1 \\\\ 3  2 \\\\ 2  3 \\\\ 1  1 \\end{pmatrix}$$\n其中第 $i$ 行对应分配给进程 $P_i$ 的资源。\n\n初始的最大需求矩阵 $M$ 是：\n$$M = \\begin{pmatrix} 4  3 \\\\ 5  4 \\\\ 3  5 \\\\ 3  2 \\end{pmatrix}$$\n\n每种资源类型的已分配资源总量是分配矩阵 $A$ 各列的和。设这个向量为 $A_{total}$。\n$$A_{total} = \\begin{pmatrix} 2+3+2+1 \\\\ 1+2+3+1 \\end{pmatrix} = \\begin{pmatrix} 8 \\\\ 7 \\end{pmatrix}$$\n\n可用资源向量 $V$ 是总资源减去总已分配资源：\n$$V = T - A_{total} = \\begin{pmatrix} 10 \\\\ 9 \\end{pmatrix} - \\begin{pmatrix} 8 \\\\ 7 \\end{pmatrix} = \\begin{pmatrix} 2 \\\\ 2 \\end{pmatrix}$$\n\n进程 $P_1$将其对 $R_1$ 的最大需求更新一个整数值 $x$。新的最大需求矩阵 $M'$ 变为：\n$$M' = \\begin{pmatrix} 4+x  3 \\\\ 5  4 \\\\ 3  5 \\\\ 3  2 \\end{pmatrix}$$\n\n需求矩阵 $N$ 代表每个进程为完成其任务可能仍然需要请求的剩余资源。它被定义为 $N = M - A$。更新后，新的需求矩阵 $N'$ 是：\n$$N' = M' - A = \\begin{pmatrix} 4+x  3 \\\\ 5  4 \\\\ 3  5 \\\\ 3  2 \\end{pmatrix} - \\begin{pmatrix} 2  1 \\\\ 3  2 \\\\ 2  3 \\\\ 1  1 \\end{pmatrix} = \\begin{pmatrix} 2+x  2 \\\\ 2  2 \\\\ 1  2 \\\\ 2  1 \\end{pmatrix}$$\n\n为了使此更新有效，必须满足两个条件：\n1. 任何进程的新最大需求都不能超过系统中的总资源。对于 $P_1$ 来说，这意味着其在 $M'$ 中的行必须按分量小于或等于 $T$。\n$$ \\begin{pmatrix} 4+x  3 \\end{pmatrix} \\le \\begin{pmatrix} 10  9 \\end{pmatrix} $$\n这给出了两个不等式：$4+x \\le 10$ 和 $3 \\le 9$。第二个不等式成立。第一个不等式意味着 $x \\le 6$。由于 $x$ 必须是整数，所以 $x$ 的最大可能值为 $6$。\n\n2. 由矩阵 $A$、$M'$ 以及派生出的向量 $V$ 和 $N'$ 定义的最终状态必须是安全状态。\n\n为了找到最大的整数 $x$，我们从测试最大可能值 $x=6$ 开始，并使用银行家安全算法检查由此产生的状态是否安全。\n\n让我们测试 $x=6$ 时的状态。当 $x=6$ 时，需求矩阵 $N'$ 为：\n$$N' = \\begin{pmatrix} 2+6  2 \\\\ 2  2 \\\\ 1  2 \\\\ 2  1 \\end{pmatrix} = \\begin{pmatrix} 8  2 \\\\ 2  2 \\\\ 1  2 \\\\ 2  1 \\end{pmatrix}$$\n\n安全算法的步骤如下：\n- 我们从可用资源向量 `Work` $= V = \\begin{pmatrix} 2 \\\\ 2 \\end{pmatrix}$ 开始。\n- 我们还维护一个布尔向量 `Finish`，对所有 $4$ 个进程初始化为 false。\n- 我们搜索一个进程 $P_i$，使得 `Finish`$[i]$ 为 false，并且其需求向量 `Need`$_i$ 按分量小于或等于 `Work` 向量。\n\n让我们应用该算法：\n初始状态：`Work` = $\\begin{pmatrix} 2 \\\\ 2 \\end{pmatrix}$，`Finish` = $[F, F, F, F]$。\n\n步骤 1：找到一个进程 $P_i$ 满足 `Need`$_i \\le$ `Work`。\n- $P_1$：`Need`$_1 = \\begin{pmatrix} 8 \\\\ 2 \\end{pmatrix}$。这不满足 $\\le \\begin{pmatrix} 2 \\\\ 2 \\end{pmatrix}$，因为 $8 > 2$。\n- $P_2$：`Need`$_2 = \\begin{pmatrix} 2 \\\\ 2 \\end{pmatrix}$。这满足 $\\le \\begin{pmatrix} 2 \\\\ 2 \\end{pmatrix}$。\n- $P_3$：`Need`$_3 = \\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix}$。这满足 $\\le \\begin{pmatrix} 2 \\\\ 2 \\end{pmatrix}$。\n- $P_4$：`Need`$_4 = \\begin{pmatrix} 2 \\\\ 1 \\end{pmatrix}$。这满足 $\\le \\begin{pmatrix} 2 \\\\ 2 \\end{pmatrix}$。\n\n我们可以在 $P_2$、$P_3$ 和 $P_4$ 中选择。只要存在任何一个安全序列就足够了。我们选择 $P_3$。\n\n步骤 2：假设 $P_3$ 运行至完成。它释放其已分配的资源。\n- 新的 `Work` = `Work` + `Allocation`$_3 = \\begin{pmatrix} 2 \\\\ 2 \\end{pmatrix} + \\begin{pmatrix} 2 \\\\ 3 \\end{pmatrix} = \\begin{pmatrix} 4 \\\\ 5 \\end{pmatrix}$。\n- `Finish` = $[F, F, T, F]$。\n\n步骤 3：寻找下一个进程。当前 `Work` = $\\begin{pmatrix} 4 \\\\ 5 \\end{pmatrix}$。\n- $P_1$：`Need`$_1 = \\begin{pmatrix} 8 \\\\ 2 \\end{pmatrix}$。不满足 $\\le \\begin{pmatrix} 4 \\\\ 5 \\end{pmatrix}$（因为 $8 > 4$）。\n- $P_2$：`Need`$_2 = \\begin{pmatrix} 2 \\\\ 2 \\end{pmatrix}$。是的，满足 $\\le \\begin{pmatrix} 4 \\\\ 5 \\end{pmatrix}$。\n- $P_4$：`Need`$_4 = \\begin{pmatrix} 2 \\\\ 1 \\end{pmatrix}$。是的，满足 $\\le \\begin{pmatrix} 4 \\\\ 5 \\end{pmatrix}$。\n\n我们选择 $P_2$。\n\n步骤 4：假设 $P_2$ 运行至完成。\n- 新的 `Work` = `Work` + `Allocation`$_2 = \\begin{pmatrix} 4 \\\\ 5 \\end{pmatrix} + \\begin{pmatrix} 3 \\\\ 2 \\end{pmatrix} = \\begin{pmatrix} 7 \\\\ 7 \\end{pmatrix}$。\n- `Finish` = $[F, T, T, F]$。\n\n步骤 5：寻找下一个进程。当前 `Work` = $\\begin{pmatrix} 7 \\\\ 7 \\end{pmatrix}$。\n- $P_1$：`Need`$_1 = \\begin{pmatrix} 8 \\\\ 2 \\end{pmatrix}$。不满足 $\\le \\begin{pmatrix} 7 \\\\ 7 \\end{pmatrix}$（因为 $8 > 7$）。\n- $P_4$：`Need`$_4 = \\begin{pmatrix} 2 \\\\ 1 \\end{pmatrix}$。是的，满足 $\\le \\begin{pmatrix} 7 \\\\ 7 \\end{pmatrix}$。\n\n我们必须选择 $P_4$。\n\n步骤 6：假设 $P_4$ 运行至完成。\n- 新的 `Work` = `Work` + `Allocation`$_4 = \\begin{pmatrix} 7 \\\\ 7 \\end{pmatrix} + \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 8 \\\\ 8 \\end{pmatrix}$。\n- `Finish` = $[F, T, T, T]$。\n\n步骤 7：寻找最后一个进程。只剩下 $P_1$。当前 `Work` = $\\begin{pmatrix} 8 \\\\ 8 \\end{pmatrix}$。\n- $P_1$：`Need`$_1 = \\begin{pmatrix} 8 \\\\ 2 \\end{pmatrix}$。是的，满足 $\\le \\begin{pmatrix} 8 \\\\ 8 \\end{pmatrix}$。\n\n步骤 8：$P_1$ 运行至完成。\n- 新的 `Work` = `Work` + `Allocation`$_1 = \\begin{pmatrix} 8 \\\\ 8 \\end{pmatrix} + \\begin{pmatrix} 2 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 10 \\\\ 9 \\end{pmatrix}$。\n- 这个最终的 `Work` 向量等于总资源向量 $T$，符合预期。\n- `Finish` = $[T, T, T, T]$。\n\n由于所有进程都可以完成，我们找到了一个安全序列，例如 $\\langle P_3, P_2, P_4, P_1 \\rangle$。因此，对于 $x=6$ 而言，系统状态是安全的。\n\n由于我们从物理上可能的最大值 $x=6$ 开始测试并证明了其安全性，所以最大的整数 $x$ 是 $6$。",
            "answer": "$$\\boxed{6}$$"
        }
    ]
}