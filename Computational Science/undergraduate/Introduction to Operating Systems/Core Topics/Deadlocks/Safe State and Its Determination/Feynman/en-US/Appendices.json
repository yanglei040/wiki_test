{
    "hands_on_practices": [
        {
            "introduction": "This first exercise simplifies the system state to its essentials, with only one process having an outstanding resource need. By focusing on this specific scenario, you can clearly see the core principle of the safety algorithm in action: can the system satisfy the final process by first allowing all other processes to run and release their resources? This practice helps build a foundational intuition for how resource availability accumulates as processes complete their execution .",
            "id": "3678795",
            "problem": "Consider a system managed by the Banker's algorithm with $n$ processes $\\{P_0,\\dots,P_4\\}$ and $m$ resource types $\\{R_0,R_1,R_2\\}$. You are given the current state in terms of the $Allocation$ and $Max$ vectors for each process and the system-wide $Available$ vector. For all processes except one, the declared maximum equals the current allocation, so their remaining need is zero. The data are:\n- $Available = (1,0,0)$.\n- $Allocation(P_0) = (1,0,2)$ and $Max(P_0) = (1,0,2)$.\n- $Allocation(P_1) = (0,2,1)$ and $Max(P_1) = (0,2,1)$.\n- $Allocation(P_2) = (2,1,0)$ and $Max(P_2) = (2,1,0)$.\n- $Allocation(P_3) = (1,1,1)$ and $Max(P_3) = (1,1,1)$.\n- $Allocation(P_4) = (0,1,0)$ and $Max(P_4) = (4,3,3)$.\n\nUse only the core definitions that underlie the Banker's safety test: a state is safe if there exists some order in which processes can finish, where at each step the currently $Available$ resources are at least the remaining claim of some unfinished process, and upon a process finishing its allocated resources are returned to $Available$. Determine whether the single remaining process with nonzero need (namely $P_4$) can be safely satisfied given $Available$ and the fact that all other processes have zero remaining need. Define the indicator $s$ to be $1$ if the state is safe (i.e., such an order exists) and $0$ otherwise. Provide the value of $s$ as a single integer. No rounding is required, and no units are involved.",
            "solution": "The problem asks to determine if a given system state is safe according to the Banker's algorithm. The state is defined by the number of processes $n=5$, denoted $\\{P_0, P_1, P_2, P_3, P_4\\}$, and the number of resource types $m=3$, denoted $\\{R_0, R_1, R_2\\}$. We are provided with the current allocation of resources to each process, the maximum resources each process may request, and the currently available resources in the system.\n\nFirst, we formalize the given data.\nThe vector of available resources is $Available = (1, 0, 0)$.\nThe allocation matrix, $Allocation$, where row $i$ corresponds to process $P_i$, is:\n$$\nAllocation = \\begin{pmatrix}\n1 & 0 & 2 \\\\\n0 & 2 & 1 \\\\\n2 & 1 & 0 \\\\\n1 & 1 & 1 \\\\\n0 & 1 & 0\n\\end{pmatrix}\n$$\nThe maximum need matrix, $Max$, is:\n$$\nMax = \\begin{pmatrix}\n1 & 0 & 2 \\\\\n0 & 2 & 1 \\\\\n2 & 1 & 0 \\\\\n1 & 1 & 1 \\\\\n4 & 3 & 3\n\\end{pmatrix}\n$$\n\nThe core of the Banker's algorithm is the safety check, which determines if there is at least one sequence of process executions that allows every process to complete without causing a deadlock. A state is safe if such a sequence exists. The algorithm relies on the concept of the remaining need of each process, which is calculated as the difference between its maximum required resources and its current allocation.\n\nLet the $Need$ matrix be defined by the relation $Need_i = Max_i - Allocation_i$, where $i$ is the process index. We can compute the $Need$ vector for each process:\n$Need(P_0) = Max(P_0) - Allocation(P_0) = (1,0,2) - (1,0,2) = (0,0,0)$.\n$Need(P_1) = Max(P_1) - Allocation(P_1) = (0,2,1) - (0,2,1) = (0,0,0)$.\n$Need(P_2) = Max(P_2) - Allocation(P_2) = (2,1,0) - (2,1,0) = (0,0,0)$.\n$Need(P_3) = Max(P_3) - Allocation(P_3) = (1,1,1) - (1,1,1) = (0,0,0)$.\n$Need(P_4) = Max(P_4) - Allocation(P_4) = (4,3,3) - (0,1,0) = (4,2,3)$.\n\nAs stated in the problem, processes $P_0, P_1, P_2, P_3$ have a remaining need of zero, meaning they have acquired all the resources they declared they would ever need and can finish their execution at any time, releasing their currently allocated resources. Process $P_4$ is the only one with a non-zero remaining need.\n\nThe safety algorithm works as follows:\n1.  Initialize a vector $Work = Available$ and a boolean vector $Finish$ of length $n$ to $false$.\n2.  Find a process $P_i$ such that $Finish[i]$ is $false$ and $Need_i \\le Work$. If no such process exists, go to step 4.\n3.  If such a process is found, assume it completes execution. Update $Work = Work + Allocation_i$ and set $Finish[i]$ to $true$. Go back to step 2.\n4.  If all elements of $Finish$ are $true$, the system state is safe. Otherwise, it is unsafe.\n\nLet's apply this algorithm to the given state.\nInitial state:\n$Work = Available = (1,0,0)$.\n$Finish = (false, false, false, false, false)$.\n\nWe search for a process $P_i$ such that $Finish[i] = false$ and $Need_i \\le Work$.\n- For $P_0$: $Need_0 = (0,0,0) \\le Work = (1,0,0)$. This is true. So, $P_0$ can finish.\nLet's select $P_0$ to run to completion.\n$Work = Work + Allocation_0 = (1,0,0) + (1,0,2) = (2,0,2)$.\n$Finish = (true, false, false, false, false)$.\nThe partial safe sequence is $<P_0>$.\n\nNow we repeat the search with the updated $Work$ vector.\n- For $P_1$: $Finish[1] = false$ and $Need_1 = (0,0,0) \\le Work = (2,0,2)$. This is true.\nLet's select $P_1$ to run to completion.\n$Work = Work + Allocation_1 = (2,0,2) + (0,2,1) = (2,2,3)$.\n$Finish = (true, true, false, false, false)$.\nThe partial safe sequence is $<P_0, P_1>$.\n\nRepeat the search:\n- For $P_2$: $Finish[2] = false$ and $Need_2 = (0,0,0) \\le Work = (2,2,3)$. This is true.\nLet's select $P_2$ to run to completion.\n$Work = Work + Allocation_2 = (2,2,3) + (2,1,0) = (4,3,3)$.\n$Finish = (true, true, true, false, false)$.\nThe partial safe sequence is $<P_0, P_1, P_2>$.\n\nRepeat the search:\n- For $P_3$: $Finish[3] = false$ and $Need_3 = (0,0,0) \\le Work = (4,3,3)$. This is true.\nLet's select $P_3$ to run to completion.\n$Work = Work + Allocation_3 = (4,3,3) + (1,1,1) = (5,4,4)$.\n$Finish = (true, true, true, true, false)$.\nThe partial safe sequence is $<P_0, P_1, P_2, P_3>$.\n\nFinally, we repeat the search for the last unfinished process, $P_4$.\n- For $P_4$: $Finish[4] = false$. We must check if $Need_4 \\le Work$.\n$Need_4 = (4,2,3)$.\n$Work = (5,4,4)$.\nThe condition $(4,2,3) \\le (5,4,4)$ is true because $4 \\le 5$, $2 \\le 4$, and $3 \\le 4$.\nSo, $P_4$ can also run to completion.\n$Work = Work + Allocation_4 = (5,4,4) + (0,1,0) = (5,5,4)$.\n$Finish = (true, true, true, true, true)$.\nThe full safe sequence is $<P_0, P_1, P_2, P_3, P_4>$.\n\nSince the algorithm terminated with $Finish[i]$ being true for all processes $i = 0, \\dots, 4$, a safe sequence exists. Therefore, the system is in a safe state.\n\nThe problem asks for the value of the indicator $s$, which is $1$ if the state is safe and $0$ otherwise. Since the state is safe, $s=1$. Any permutation of $\\{P_0, P_1, P_2, P_3\\}$ followed by $P_4$ would constitute a valid safe sequence.",
            "answer": "$$\\boxed{1}$$"
        },
        {
            "introduction": "Building on the foundational check, this problem moves to a more comprehensive analysis of a system's state in a simple, single-resource environment. You will practice not only determining if a state is safe but also enumerating all possible safe execution sequences, which deepens your understanding of system flexibility. Furthermore, by evaluating hypothetical resource requests, you will engage with the proactive, decision-making aspect of the Banker's Algorithm, which is crucial for deadlock avoidance .",
            "id": "3678785",
            "problem": "Consider a system with $n=3$ processes, labeled $P_0$, $P_1$, and $P_2$, and $m=1$ reusable resource type. The current snapshot has $Available=1$ instance free, the current $Allocation$ vector $[1,0,0]$ corresponding respectively to $P_0$, $P_1$, $P_2$, and the $Max$ vector $[2,1,1]$ indicating each process’s declared maximum demand. Assume the standard setting that when a process completes, it immediately releases all instances it holds, and that a state is safe if and only if there exists an ordering of all processes such that each process can obtain its remaining needed instances from what is currently available plus what will be released by previously finished processes.\nDefine $S$ to be the number of distinct safe sequences (full orderings of all $3$ processes) that are feasible from the given snapshot under the standard safety check. Next, for each $i \\in \\{0,1,2\\}$, consider a hypothetical immediate single-instance request of size $1$ from process $P_i$ (each such request is within the process’s remaining need in this snapshot). Let $U$ be the number of indices $i$ for which granting that request immediately (and updating the snapshot accordingly) would place the system in an unsafe state.\nCompute the single integer $S - U$. Express your final answer as an integer with no units. No rounding is required.",
            "solution": "This problem requires a two-part analysis of a system state based on the Banker's algorithm. First, we determine the number of possible safe execution sequences ($S$). Second, we evaluate three hypothetical resource requests to count how many of them would lead to an unsafe state ($U$).\n\n**Initial System State**\n- Processes: $P_0, P_1, P_2$\n- Resource Type: 1\n- Available instances: $Available = 1$\n- Allocation vector: $Allocation = [1, 0, 0]$\n- Maximum need vector: $Max = [2, 1, 1]$\n\nFirst, we calculate the remaining `Need` for each process using the formula $Need_i = Max_i - Allocation_i$:\n- $Need_0 = 2 - 1 = 1$\n- $Need_1 = 1 - 0 = 1$\n- $Need_2 = 1 - 0 = 1$\nSo, the `Need` vector is $[1, 1, 1]$.\n\n**Part 1: Calculating $S$, the Number of Safe Sequences**\nA state is safe if a sequence exists where each process can acquire its needed resources. We apply the safety algorithm with $Work = Available = 1$.\nA process $P_i$ can be selected if $Need_i \\le Work$. Since all processes need 1 instance and $Work=1$, any of the three processes ($P_0, P_1, P_2$) can be the first in a safe sequence.\n\n1.  **Sequence starts with $P_0$:** $P_0$ runs. It releases its allocation. New $Work = Work + Allocation_0 = 1 + 1 = 2$. The remaining processes are $P_1$ and $P_2$, both needing 1 instance. Since $1 \\le 2$, both can run in any order. This gives two sequences: $<P_0, P_1, P_2>$ and $<P_0, P_2, P_1>$.\n\n2.  **Sequence starts with $P_1$:** $P_1$ runs. It releases its allocation. New $Work = Work + Allocation_1 = 1 + 0 = 1$. The remaining processes are $P_0$ and $P_2$, both needing 1 instance. Since $1 \\le 1$, both can run in any order. This gives two sequences: $<P_1, P_0, P_2>$ and $<P_1, P_2, P_0>$.\n\n3.  **Sequence starts with $P_2$:** $P_2$ runs. It releases its allocation. New $Work = Work + Allocation_2 = 1 + 0 = 1$. This case is symmetric to starting with $P_1$. The remaining processes $P_0$ and $P_1$ can run in any order. This gives two sequences: $<P_2, P_0, P_1>$ and $<P_2, P_1, P_0>$.\n\nTotal number of distinct safe sequences $S = 2 + 2 + 2 = 6$.\n\n**Part 2: Calculating $U$, the Number of Unsafe Scenarios**\nWe analyze the outcome of immediately granting a request of 1 instance to each process.\n\n*   **Scenario A: Grant 1 instance to $P_0$**\n    - New state: $Available' = 1 - 1 = 0$; $Allocation' = [2, 0, 0]$; $Need' = [0, 1, 1]$.\n    - Safety check: $Work' = 0$. Only $P_0$ can run (since $Need'_0 = 0$). After $P_0$ finishes, it releases its 2 instances. New $Work' = 0 + 2 = 2$. Both $P_1$ and $P_2$ can finish since their need (1) is $\\le 2$. The state is **SAFE**.\n\n*   **Scenario B: Grant 1 instance to $P_1$**\n    - New state: $Available' = 1 - 1 = 0$; $Allocation' = [1, 1, 0]$; $Need' = [1, 0, 1]$.\n    - Safety check: $Work' = 0$. Only $P_1$ can run. After $P_1$ finishes, it releases its 1 instance. New $Work' = 0 + 1 = 1$. Both $P_0$ and $P_2$ can finish since their need (1) is $\\le 1$. The state is **SAFE**.\n\n*   **Scenario C: Grant 1 instance to $P_2$**\n    - New state: $Available' = 1 - 1 = 0$; $Allocation' = [1, 0, 1]$; $Need' = [1, 1, 0]$.\n    - This is symmetric to Scenario B. The state is **SAFE**.\n\nSince granting the request leads to a safe state in all three cases, the number of scenarios resulting in an unsafe state is $U = 0$.\n\n**Final Calculation**\nWe need to compute $S - U$.\n$S - U = 6 - 0 = 6$.",
            "answer": "$$\\boxed{6}$$"
        },
        {
            "introduction": "This final practice challenges you to think like a system designer, moving beyond analysis to active problem-solving. Instead of just analyzing a fixed state, you must determine the minimum change required to transform an unsafe state into a safe one. This exercise powerfully illustrates the concept of resource thresholds and bottlenecks, showing how adding a small number of a key resource can fundamentally ensure system stability and prevent deadlock .",
            "id": "3678749",
            "problem": "A uniprogrammed operating system is managing $m=2$ distinct resource types, denoted $R_1$ and $R_2$. There are $n=3$ independent processes $P_0$, $P_1$, and $P_2$. The system-wide resource totals are $R_1^{\\text{tot}}=100$ and $R_2^{\\text{tot}}=3$. The current state of the system is specified by each process’s current Allocation vector and its declared Maximum vector, given as ordered pairs $(R_1,R_2)$:\n- $P_0$: Allocation $(10,1)$, Maximum $(20,3)$.\n- $P_1$: Allocation $(15,1)$, Maximum $(25,3)$.\n- $P_2$: Allocation $(5,1)$, Maximum $(15,3)$.\n\nNo other processes exist. Assume that the only change you are allowed to make is to increase the total amount of $R_2$ by an integer $\\Delta \\ge 0$ (so that $R_2^{\\text{tot}}$ becomes $3+\\Delta$), with no changes to Allocations or Maximums. The goal is to leverage the standard notion of a safe state in resource-allocation systems: a state is safe if there exists some order of completion of the processes such that each process can acquire its remaining needed resources from what is available at its turn and, upon completion, releases its Allocation to possibly enable the next process, until all processes complete.\n\nDetermine the minimal integer $\\Delta$ such that, after increasing only $R_2^{\\text{tot}}$ by $\\Delta$, the resulting state is safe. Report the value of $\\Delta$ as a single integer. No rounding is required.",
            "solution": "The problem asks for the minimum integer value of $\\Delta \\ge 0$ that makes the given system state safe. The initial total resources are $R_1^{\\text{tot}}=100$ and $R_2^{\\text{tot}}=3$. The amount of $R_2$ is increased to a new total of $R_{2, \\text{new}}^{\\text{tot}} = 3 + \\Delta$. This problem can be solved by applying the Banker's Algorithm for deadlock avoidance.\n\nFirst, let's formalize the state of the system. The number of processes is $n=3$ and the number of resource types is $m=2$.\n\nThe resource vectors are defined as follows:\nThe `Total` vector (E) of available resources in the system is $E = (R_1^{\\text{tot}}, R_{2, \\text{new}}^{\\text{tot}}) = (100, 3+\\Delta)$.\n\nThe `Allocation` matrix (A) specifies the resources currently allocated to each process.\nFor $P_0$: $A_0 = (10, 1)$\nFor $P_1$: $A_1 = (15, 1)$\nFor $P_2$: $A_2 = (5, 1)$\n$$ A = \\begin{pmatrix} 10 & 1 \\\\ 15 & 1 \\\\ 5 & 1 \\end{pmatrix} $$\n\nThe `Maximum` matrix (M) specifies the maximum resources each process may request.\nFor $P_0$: $M_0 = (20, 3)$\nFor $P_1$: $M_1 = (25, 3)$\nFor $P_2$: $M_2 = (15, 3)$\n$$ M = \\begin{pmatrix} 20 & 3 \\\\ 25 & 3 \\\\ 15 & 3 \\end{pmatrix} $$\n\nNext, we calculate the `Need` matrix (N), which represents the remaining resources each process needs to complete its task. The `Need` for a process $i$ is calculated as $N_i = M_i - A_i$.\nFor $P_0$: $N_0 = (20, 3) - (10, 1) = (10, 2)$\nFor $P_1$: $N_1 = (25, 3) - (15, 1) = (10, 2)$\nFor $P_2$: $N_2 = (15, 3) - (5, 1) = (10, 2)$\n$$ N = \\begin{pmatrix} 10 & 2 \\\\ 10 & 2 \\\\ 10 & 2 \\end{pmatrix} $$\n\nNow, we calculate the `Available` vector (V), which represents the resources not currently allocated. This is found by subtracting the sum of all allocated resources from the total resources.\nFirst, find the total allocated resources by summing the columns of the `Allocation` matrix:\nTotal allocated $R_1 = 10 + 15 + 5 = 30$.\nTotal allocated $R_2 = 1 + 1 + 1 = 3$.\nSo, the total allocation vector is $(30, 3)$.\n\nThe `Available` vector $V$ is:\n$V = E - (30, 3) = (100, 3+\\Delta) - (30, 3) = (70, \\Delta)$.\n\nThe safety algorithm is used to determine if the current state is safe. A state is safe if there exists a sequence of processes $<P_{i_1}, P_{i_2}, \\dots, P_{i_n}>$ such that for each process $P_k$ in the sequence, its `Need` can be satisfied by the currently available resources. If this condition is met, the process is assumed to execute, complete, and release its allocated resources, which are then added back to the pool of available resources.\n\nThe algorithm works as follows:\nLet `Work` be a vector of length $m$, initialized to `Available`. So, $Work = V = (70, \\Delta)$.\nLet `Finish` be a boolean vector of length $n$, initialized to `false` for all processes.\n\n1. Find a process $P_i$ such that `Finish[i]` is `false` and $N_i \\le Work$. The vector inequality $A \\le B$ holds if $A_j \\le B_j$ for all components $j$.\n2. If no such process exists, go to step 4.\n3. If such a process $P_i$ is found, update `Work` = `Work` + $A_i$, set `Finish[i]` = `true`, and go back to step 1.\n4. If `Finish[i]` is `true` for all $i$, the system is in a safe state. Otherwise, it is unsafe.\n\nFor the system to be safe, there must be at least one process $P_i$ that can be executed first. This requires its `Need` vector $N_i$ to be less than or equal to the initial `Available` vector, $V$.\nLet's check this condition for each process:\nFor $P_0$: $N_0 \\le V \\implies (10, 2) \\le (70, \\Delta)$. This requires $10 \\le 70$ (which is true) and $2 \\le \\Delta$.\nFor $P_1$: $N_1 \\le V \\implies (10, 2) \\le (70, \\Delta)$. This requires $10 \\le 70$ (true) and $2 \\le \\Delta$.\nFor $P_2$: $N_2 \\le V \\implies (10, 2) \\le (70, \\Delta)$. This requires $10 \\le 70$ (true) and $2 \\le \\Delta$.\n\nIn all cases, for the safety algorithm to even begin, we must satisfy the condition $2 \\le \\Delta$. Since $\\Delta$ is an integer, the smallest possible value it could take to satisfy this condition is $\\Delta = 2$.\n\nLet's verify if the state is indeed safe for $\\Delta = 2$.\nIf $\\Delta=2$, the initial `Available` (Work) vector is $Work = (70, 2)$.\nThe `Finish` vector is $($false, false, false$)$.\n\n1. We can choose any of the three processes to start. Let's pick $P_0$.\n   Is $N_0 = (10, 2) \\le Work = (70, 2)$? Yes.\n   $P_0$ can run. It finishes and releases its resources.\n   New $Work = Work + A_0 = (70, 2) + (10, 1) = (80, 3)$.\n   `Finish` becomes $($true, false, false$)$.\n\n2. Now we look for the next process. Current $Work = (80, 3)$.\n   Let's pick $P_1$. Is $N_1 = (10, 2) \\le Work = (80, 3)$? Yes.\n   $P_1$ can run. It finishes and releases its resources.\n   New $Work = Work + A_1 = (80, 3) + (15, 1) = (95, 4)$.\n   `Finish` becomes $($true, true, false$)$.\n\n3. Finally, we check the last process, $P_2$. Current $Work = (95, 4)$.\n   Is $N_2 = (10, 2) \\le Work = (95, 4)$? Yes.\n   $P_2$ can run. It finishes and releases its resources.\n   New $Work = Work + A_2 = (95, 4) + (5, 1) = (100, 5)$.\n   `Finish` becomes $($true, true, true$)$.\n\nSince `Finish` is true for all processes, a safe sequence $<P_0, P_1, P_2>$ exists (other permutations like $<P_1, P_0, P_2>$ etc. are also possible). Therefore, the state is safe for $\\Delta=2$.\n\nIf we choose any integer $\\Delta < 2$ (i.e., $\\Delta_0 = 0$ or $\\Delta_1=1$), the initial condition $N_i \\le V$ would not be met for any process $P_i$, as it would require $2 \\le 0$ or $2 \\le 1$, both of which are false. In those cases, no process could be selected to run, and the algorithm would terminate with `Finish` not all true, indicating an unsafe state.\n\nThus, the minimal integer value of $\\Delta$ that makes the system state safe is $2$.",
            "answer": "$$\n\\boxed{2}\n$$"
        }
    ]
}