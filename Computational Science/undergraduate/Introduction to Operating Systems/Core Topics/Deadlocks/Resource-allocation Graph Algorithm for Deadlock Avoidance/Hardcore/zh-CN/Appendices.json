{
    "hands_on_practices": [
        {
            "introduction": "理论知识只有通过实践才能真正掌握。这项练习将带你逐步模拟一个简化的操作系统环境，通过跟踪资源分配图随时间的变化，你将亲眼见证一个死锁是如何形成的。这项练习  旨在帮助你理解在单实例资源系统中，请求和分配边形成的环路是造成死锁的直接原因。",
            "id": "3677751",
            "problem": "一个操作系统 (OS) 维护一个以进程和资源为节点的资源分配图 (RAG)。进程 $P_i$ 被绘制为圆形，资源 $R_j$ 被绘制为方形。一条有向边 $P_i \\rightarrow R_j$ 是一条请求边，表示进程 $P_i$ 正在等待资源 $R_j$。一条有向边 $R_j \\rightarrow P_i$ 是一条分配边，表示资源 $R_j$ 当前已分配给进程 $P_i$。一条声明边 $P_i \\rightarrow R_j$ 表示进程 $P_i$ 将来可能会请求 $R_j$；声明边在发出请求之前就存在，当进程实际请求该资源时，声明边会转换为请求边。如果请求被批准且资源空闲，请求边会转换为分配边；如果资源不空闲，请求边将保持不变。当一个进程释放资源时，分配边 $R_j \\rightarrow P_i$ 被移除，并且相应的声明边 $P_i \\rightarrow R_j$ 被恢复。在一个每种资源类型都只有一个实例的系统中，请求边和分配边之间存在有向环是发生死锁的充分必要条件。\n\n考虑三个进程 $P_1, P_2, P_3$ 和两个资源 $R_a, R_b$，每种资源都只有一个实例。在时间 $t=0$ 时的初始声明边如下：\n- $P_1 \\rightarrow R_a$, $P_1 \\rightarrow R_b$,\n- $P_2 \\rightarrow R_a$, $P_2 \\rightarrow R_b$,\n- $P_3 \\rightarrow R_b$.\n\n然后，系统根据以下事件在离散时间片 $t=1,2,3,\\dots$ 中演进。在每个时间点 $t$，如果资源空闲，操作系统会立即批准请求；否则，请求边被添加并保持，直到资源变为空闲。不应用任何死锁避免决策。\n\n- 在 $t=1$ 时，$P_1$ 发出对 $R_a$ 的请求。\n- 在 $t=2$ 时，$P_2$ 发出对 $R_b$ 的请求。\n- 在 $t=3$ 时，$P_1$ 发出对 $R_b$ 的请求。\n- 在 $t=4$ 时，$P_2$ 发出对 $R_a$ 的请求。\n- 在 $t=5$ 时，$P_3$ 发出对 $R_b$ 的请求。\n\n假设在 $t \\in \\{1,2,3,4,5\\}$ 期间没有资源释放发生。根据本题的约定，在判断是否存在环时，只考虑请求边和分配边，忽略声明边。\n\n仅使用上述基本定义和给定的事件序列，确定请求边和分配边构成的图中首次出现有向环的最小正整数 $t^\\*$。将 $t^\\*$ 报告为一个精确的整数，不带单位。无需四舍五入。",
            "solution": "本题要求我们确定一个最小正整数时间 $t^\\*$，在该时间点，给定进程和资源系统的资源分配图 (RAG) 中首次出现有向环。RAG 由进程节点 $\\{P_1, P_2, P_3\\}$、资源节点 $\\{R_a, R_b\\}$ 以及与环检测相关的两种有向边组成：请求边 ($P_i \\rightarrow R_j$) 和分配边 ($R_j \\rightarrow P_i$)。根据题目描述，对于每种只有一个实例的资源，这种环的存在是死锁的充分必要条件。我们将根据指定的事件序列，逐步追踪 RAG 的演变。\n\n设时间 $t$ 时图中请求边和分配边的集合为 $E_t$。\n\n**$t=0$ 时的初始状态：**\n系统开始时有三个进程 $P_1, P_2, P_3$ 和两个单实例资源 $R_a$ 和 $R_b$。两个资源最初都是空闲且可用的。没有活动的请求或分配。\n- 边集：$E_0 = \\emptyset$。\n- 图中没有边，因此没有环。\n\n**时间步 $t=1$：**\n- **事件：** 进程 $P_1$ 发出对资源 $R_a$ 的请求。\n- **分析：** 此时，资源 $R_a$ 是空闲的。根据规则，操作系统立即批准该请求。此操作将瞬时的请求边转换为永久的分配边。\n- **状态更新：** 一条分配边 $R_a \\rightarrow P_1$ 被添加到图中。资源 $R_a$ 现在分配给了 $P_1$。\n- **边集：** $E_1 = \\{R_a \\rightarrow P_1\\}$。\n- **环检测：** 图中只有一条边。无法形成有向环。\n\n**时间步 $t=2$：**\n- **事件：** 进程 $P_2$ 发出对资源 $R_b$ 的请求。\n- **分析：** 资源 $R_b$ 是空闲的。请求被立即批准。\n- **状态更新：** 一条分配边 $R_b \\rightarrow P_2$ 被添加到图中。资源 $R_b$ 现在分配给了 $P_2$。\n- **边集：** $E_2 = \\{R_a \\rightarrow P_1, R_b \\rightarrow P_2\\}$。\n- **环检测：** 图由两条长度为1的不相交路径组成。不存在有向环。\n\n**时间步 $t=3$：**\n- **事件：** 进程 $P_1$ 发出对资源 $R_b$ 的请求。\n- **分析：** 资源 $R_b$ 不空闲；它当前分配给了进程 $P_2$（由边 $R_b \\rightarrow P_2$ 表示）。该请求无法被批准。\n- **状态更新：** 一条请求边 $P_1 \\rightarrow R_b$ 被添加到图中，表示 $P_1$ 现在正在等待 $R_b$。\n- **边集：** $E_3 = \\{R_a \\rightarrow P_1, R_b \\rightarrow P_2, P_1 \\rightarrow R_b\\}$。\n- **环检测：** 我们可以从现有的分配边 $R_a \\rightarrow P_1$ 追踪到新的请求边 $P_1 \\rightarrow R_b$，然后再到另一条分配边 $R_b \\rightarrow P_2$。这形成了一条有向路径 $R_a \\rightarrow P_1 \\rightarrow R_b \\rightarrow P_2$。没有从 $P_2$ 指向该路径中任何已有节点的边。因此，不存在有向环。\n\n**时间步 $t=4$：**\n- **事件：** 进程 $P_2$ 发出对资源 $R_a$ 的请求。\n- **分析：** 资源 $R_a$ 不空闲；它当前分配给了进程 $P_1$（由边 $R_a \\rightarrow P_1$ 表示）。该请求无法被批准。\n- **状态更新：** 一条请求边 $P_2 \\rightarrow R_a$ 被添加到图中，表示 $P_2$ 现在正在等待 $R_a$。\n- **边集：** $E_4 = \\{R_a \\rightarrow P_1, R_b \\rightarrow P_2, P_1 \\rightarrow R_b, P_2 \\rightarrow R_a\\}$。\n- **环检测：** 让我们检查图中的路径。\n  1. 进程 $P_1$ 正在等待资源 $R_b$：即边 $P_1 \\rightarrow R_b$。\n  2. 资源 $R_b$ 被进程 $P_2$ 持有：即边 $R_b \\rightarrow P_2$。\n  3. 进程 $P_2$ 正在等待资源 $R_a$：即新边 $P_2 \\rightarrow R_a$。\n  4. 资源 $R_a$ 被进程 $P_1$ 持有：即边 $R_a \\rightarrow P_1$。\n将这些边组合起来，我们可以构建以下节点和边的序列：$P_1 \\rightarrow R_b \\rightarrow P_2 \\rightarrow R_a \\rightarrow P_1$。这个序列形成一个闭环，即 RAG 中的一个有向环。这个环涉及进程 $P_1$ 和 $P_2$ 以及资源 $R_a$ 和 $R_b$。具体来说，$P_1$ 持有 $R_a$ 并请求 $R_b$，而 $P_2$ 持有 $R_b$ 并请求 $R_a$，这是一个典型的死锁条件。\n\n由于有向环在 $t=4$ 时首次出现，这就是我们寻找的值。因为问题要求的是最小的此类正整数，所以分析可以在此终止。\n\n请求边和分配边构成的图中首次出现有向环的最小正整数 $t^\\*$ 是 $4$。",
            "answer": "$$\\boxed{4}$$"
        },
        {
            "introduction": "在理解了环路如何形成之后，下一步是学习如何主动地避免它们。这项练习将死锁避免的抽象规则与具体的计算机科学算法联系起来，要求你使用深度优先搜索（DFS）来检测一个潜在的资源分配是否会形成环路。通过这个练习 ，你将掌握在授予资源请求之前进行“安全检查”的核心技术。",
            "id": "3677764",
            "problem": "给定一个有向二部图 $G$，它表示一个资源分配图 (RAG)。进程节点为 $\\{P_1, P_2, P_3\\}$，资源节点为 $\\{R_a, R_b, R_c\\}$。所有资源都是单实例的。一条边 $R_x \\to P_y$ 表示将资源 $R_x$ 分配给进程 $P_y$，一条边 $P_y \\to R_x$ 表示进程 $P_y$ 请求资源 $R_x$。图 $G$ 当前的邻接表（邻居的探索顺序与列表顺序完全一致）如下：\n- $P_1: [R_b]$\n- $P_2: [\\,]$\n- $P_3: [R_a]$\n- $R_a: [P_1]$\n- $R_b: [P_2]$\n- $R_c: [P_3]$\n\n现提出一条请求边 $P_2 \\to R_c$。使用深度优先搜索 (DFS) 进行即时循环检测，在添加边 $P_2 \\to R_c$ 后立即从 $P_2$ 开始。DFS 探索邻居的顺序与所提供的顺序完全一致，并使用颜色状态法来检测循环（白色 = 未访问，灰色 = 已发现且在当前递归栈中，黑色 = 已完成）。如果遇到指向灰色节点的回边，则在单实例假设下系统是不安全的，该请求必须被拒绝。\n\n定义 $L$ 为在添加 $P_2 \\to R_c$ 后从 $P_2$ 开始的 DFS 通过回边检测到的第一个简单有向环的长度（不同有向边的数量）。计算 $L$。请用一个不带单位的整数表示最终答案。",
            "solution": "第一步是构建添加新请求边后的资源分配图 (RAG) 的状态。\n顶点集为 $V = \\{P_1, P_2, P_3, R_a, R_b, R_c\\}$。\n根据问题的邻接表，初始边如下：\n- 请求边 (进程 $\\to$ 资源): $(P_1, R_b)$, $(P_3, R_a)$。\n- 分配边 (资源 $\\to$ 进程): $(R_a, P_1)$, $(R_b, P_2)$, $(R_c, P_3)$。\n添加一条新的请求边 $(P_2, R_c)$。\n图 $G$ 中有向边的完整集合为 $E = \\{(P_1, R_b), (P_3, R_a), (R_a, P_1), (R_b, P_2), (R_c, P_3), (P_2, R_c)\\}$。\n$P_2$ 更新后的邻接表现在是 $P_2: [R_c]$。\n\n接下来，我们从节点 $P_2$ 开始执行深度优先搜索 (DFS) 来检测循环。我们将跟踪每个节点的颜色（初始为白色）和 DFS 树中每个节点的父节点。\n\n1.  **初始化**：对于所有 $v \\in V$，`color[v] = WHITE`。对于所有 $v \\in V$，`parent[v] = NULL`。\n2.  **开始 DFS**：调用 `DFS-Visit(P_2)`。\n\n**`DFS-Visit` 追踪：**\n\n- **调用 `DFS-Visit(P_2)`**：\n    - 设置 `color[P_2] = GRAY`。\n    - `parent[P_2] = NULL`。\n    - 探索 $P_2$ 的邻居。邻接表为 $[R_c]$。\n    - 邻居是 $R_c$。`color[R_c]` 是白色。这是一条树边。\n    - 设置 `parent[R_c] = P_2`。\n    - 递归调用 `DFS-Visit(R_c)`。\n\n- **调用 `DFS-Visit(R_c)`**：\n    - 设置 `color[R_c] = GRAY`。\n    - 探索 $R_c$ 的邻居。邻接表为 $[P_3]$。\n    - 邻居是 $P_3$。`color[P_3]` 是白色。这是一条树边。\n    - 设置 `parent[P_3] = R_c`。\n    - 递归调用 `DFS-Visit(P_3)`。\n\n- **调用 `DFS-Visit(P_3)`**：\n    - 设置 `color[P_3] = GRAY`。\n    - 探索 $P_3$ 的邻居。邻接表为 $[R_a]$。\n    - 邻居是 $R_a$。`color[R_a]` 是白色。这是一条树边。\n    - 设置 `parent[R_a] = P_3`。\n    - 递归调用 `DFS-Visit(R_a)`。\n\n- **调用 `DFS-Visit(R_a)`**：\n    - 设置 `color[R_a] = GRAY`。\n    - 探索 $R_a$ 的邻居。邻接表为 $[P_1]$。\n    - 邻居是 $P_1$。`color[P_1]` 是白色。这是一条树边。\n    - 设置 `parent[P_1] = R_a`。\n    - 递归调用 `DFS-Visit(P_1)`。\n\n- **调用 `DFS-Visit(P_1)`**：\n    - 设置 `color[P_1] = GRAY`。\n    - 探索 $P_1$ 的邻居。邻接表为 $[R_b]$。\n    - 邻居是 $R_b$。`color[R_b]` 是白色。这是一条树边。\n    - 设置 `parent[R_b] = P_1`。\n    - 递归调用 `DFS-Visit(R_b)`。\n\n- **调用 `DFS-Visit(R_b)`**：\n    - 设置 `color[R_b] = GRAY`。\n    - 探索 $R_b$ 的邻居。邻接表为 $[P_2]$。\n    - 邻居是 $P_2$。`color[P_2]` 是灰色。\n    - 由于 $P_2$ 是一个灰色节点，边 $(R_b, P_2)$ 是一条回边。检测到一个循环。DFS 算法终止搜索并报告该循环。\n\n在找到回边 $(R_b, P_2)$ 时，检测到第一个循环。该循环由这条边以及 DFS 树中从目标节点 $P_2$ 到源节点 $R_b$ 的路径组成。我们可以通过从 $R_b$ 回溯到 $P_2$ 的 `parent` 指针来重建这条路径。\n\n- `parent[R_b] = P_1`\n- `parent[P_1] = R_a`\n- `parent[R_a] = P_3`\n- `parent[P_3] = R_c`\n- `parent[R_c] = P_2`\n\n从 $P_2$到 $R_b$的路径是 $P_2 \\to R_c \\to P_3 \\to R_a \\to P_1 \\to R_b$。\n追加回边 $(R_b, P_2)$ 形成闭环：\n$P_2 \\to R_c \\to P_3 \\to R_a \\to P_1 \\to R_b \\to P_2$。\n\n问题要求的是这个循环的长度 $L$，也就是它包含的不同有向边的数量。这些边是：\n1. $(P_2, R_c)$\n2. $(R_c, P_3)$\n3. $(P_3, R_a)$\n4. $(R_a, P_1)$\n5. $(P_1, R_b)$\n6. $(R_b, P_2)$\n\n这个简单有向环中有 $6$ 条边。因此，长度 $L$ 为 $6$。",
            "answer": "$$\\boxed{6}$$"
        },
        {
            "introduction": "现在，你已经掌握了识别和检测环路的方法，让我们在一个更复杂的场景中应用这些技能。在这项练习中，你将扮演操作系统调度程序的角色，面对一系列待处理的资源请求。你的任务是逐一评估每个请求 ，并根据资源分配图算法的规则，决定是批准还是拒绝，以确保系统始终处于安全状态。",
            "id": "3677767",
            "problem": "您正在测试用于死锁避免的资源分配图（RAG）算法，情况是每种资源类型只有一个实例。考虑一个系统，包含进程 $P_1, P_2, P_3, P_4, P_5$ 和资源 $R_1, R_2, R_3, R_4, R_5$，每种资源只有一个实例。当前图有以下分配边（从资源到进程）和请求边（从进程到资源）：\n- 分配边：$R_1 \\to P_2$，$R_2 \\to P_3$，$R_3 \\to P_4$，$R_4 \\to P_5$，$R_5 \\to P_1$。\n- 请求边：$P_1 \\to R_1$，$P_2 \\to R_2$，$P_3 \\to R_3$，$P_4 \\to R_4$。\n\n对于接下来可能发出的以下潜在请求，存在需求边（即，这些是唯一可以添加的额外请求边）：$P_5 \\to R_5$，$P_3 \\to R_5$，$P_5 \\to R_2$，$P_2 \\to R_4$，$P_4 \\to R_1$。除了已作为所列请求边实现的那些之外，不存在其他需求边。\n\n观察到当前图中包含一条长度为 $L = 8$ 条边的简单路径：\n$$\nP_1 \\to R_1 \\to P_2 \\to R_2 \\to P_3 \\to R_3 \\to P_4 \\to R_4 \\to P_5,\n$$\n这还不是一个环，但如果用一条合适的额外边来增强，它将成为一个环。\n\n根据资源分配图算法的死锁避免规则（即，拒绝任何其添加会导致图中产生环的请求），确定所列的待处理请求中有多少必须被拒绝，因为它们的添加会将现有路径扩展成一个环。将您的最终答案表示为整数 $D$。无需四舍五入。",
            "solution": "本问题要求我们分析一组潜在的资源请求，并为每个请求确定批准它是否会在资源分配图中创建一个环。在一个每种资源类型只有一个实例的系统中，用于死锁避免的RAG算法规定，进程 $P_i$ 对资源 $R_j$ 的请求（表示为请求边 $P_i \\to R_j$）只有在将此边添加到图中不会创建环的情况下才能被批准。如果已经存在从资源 $R_j$ 到进程 $P_i$ 的路径，那么添加该请求边就会形成一个环，因此该请求必须被拒绝。\n\n首先，让我们表示系统的当前状态图，该图由进程 $P_k$、资源 $R_k$ 和现有边组成。\n\n进程集合为 $\\mathcal{P} = \\{P_1, P_2, P_3, P_4, P_5\\}$。\n资源集合为 $\\mathcal{R} = \\{R_1, R_2, R_3, R_4, R_5\\}$。\n\n图中的当前边是：\n1.  **分配边**（资源被进程持有）：\n    - $R_1 \\to P_2$ ($P_2$ 持有 $R_1$)\n    - $R_2 \\to P_3$ ($P_3$ 持有 $R_2$)\n    - $R_3 \\to P_4$ ($P_4$ 持有 $R_3$)\n    - $R_4 \\to P_5$ ($P_5$ 持有 $R_4$)\n    - $R_5 \\to P_1$ ($P_1$ 持有 $R_5$)\n2.  **请求边**（进程等待资源）：\n    - $P_1 \\to R_1$ ($P_1$ 等待 $R_1$)\n    - $P_2 \\to R_2$ ($P_2$ 等待 $R_2$)\n    - $P_3 \\to R_3$ ($P_3$ 等待 $R_3$)\n    - $P_4 \\to R_4$ ($P_4$ 等待 $R_4$)\n\n我们现在必须评估五个潜在请求中的每一个，看添加它是否会闭合一个环。\n\n**1. 请求：$P_5 \\to R_5$**\n要检查此请求是否会创建一个环，我们必须确定是否存在从资源 $R_5$ 到进程 $P_5$ 的现有路径。\n- 路径追溯：$R_5 \\to P_1 \\to R_1 \\to P_2 \\to R_2 \\to P_3 \\to R_3 \\to P_4 \\to R_4 \\to P_5$。\n- 确实存在从 $R_5$到 $P_5$ 的路径。添加边 $P_5 \\to R_5$ 会创建一个环。\n**结论：拒绝。**\n\n**2. 请求：$P_3 \\to R_5$**\n我们检查是否存在从 $R_5$ 到 $P_3$ 的现有路径。\n- 路径追溯：$R_5 \\to P_1 \\to R_1 \\to P_2 \\to R_2 \\to P_3$。\n- 存在从 $R_5$ 到 $P_3$ 的路径。添加边 $P_3 \\to R_5$ 会创建一个环。\n**结论：拒绝。**\n\n**3. 请求：$P_5 \\to R_2$**\n我们检查是否存在从 $R_2$ 到 $P_5$ 的现有路径。\n- 路径追溯：$R_2 \\to P_3 \\to R_3 \\to P_4 \\to R_4 \\to P_5$。\n- 存在从 $R_2$ 到 $P_5$ 的路径。添加边 $P_5 \\to R_2$ 会创建一个环。\n**结论：拒绝。**\n\n**4. 请求：$P_2 \\to R_4$**\n我们检查是否存在从 $R_4$ 到 $P_2$ 的现有路径。\n- 从 $R_4$ 出发的唯一出边是分配边 $R_4 \\to P_5$。\n- 从 $P_5$ 出发，在当前图中没有出边（因为 $P_5$ 当前没有请求任何资源）。\n- 因此，不存在从 $R_4$ 到 $P_2$ 的路径。添加边 $P_2 \\to R_4$ 不会创建环。\n**结论：批准。**\n\n**5. 请求：$P_4 \\to R_1$**\n我们检查是否存在从 $R_1$ 到 $P_4$ 的现有路径。\n- 路径追溯：$R_1 \\to P_2 \\to R_2 \\to P_3 \\to R_3 \\to P_4$。\n- 存在从 $R_1$ 到 $P_4$ 的路径。添加边 $P_4 \\to R_1$ 会创建一个环。\n**结论：拒绝。**\n\n总结如下：\n- 请求 $P_5 \\to R_5$：拒绝\n- 请求 $P_3 \\to R_5$：拒绝\n- 请求 $P_5 \\to R_2$：拒绝\n- 请求 $P_2 \\to R_4$：批准\n- 请求 $P_4 \\to R_1$：拒绝\n\n必须被拒绝的请求数 $D$ 是“拒绝”结论的计数。我们有 $4$ 个这样的请求。\n因此，$D=4$。",
            "answer": "$$\n\\boxed{4}\n$$"
        }
    ]
}