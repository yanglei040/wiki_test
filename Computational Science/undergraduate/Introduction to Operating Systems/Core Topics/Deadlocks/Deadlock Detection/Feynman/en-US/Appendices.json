{
    "hands_on_practices": [
        {
            "introduction": "To begin our hands-on exploration, we'll tackle the core deadlock detection algorithm for systems with multiple instances of each resource type. This practice requires you to step into the role of the operating system's scheduler, using a systematic, matrix-based method similar to the Banker's algorithm to determine if the current state of resource allocation has led to a deadlock . Mastering this numerical approach is fundamental to understanding how modern operating systems can manage complex resource dependencies and ensure system stability.",
            "id": "3632410",
            "problem": "Consider an Operating System (OS) with $n=6$ processes $\\{P_0,P_1,P_2,P_3,P_4,P_5\\}$ competing for $m=4$ resource types $\\{R_1,R_2,R_3,R_4\\}$, each with multiple instances. The system state is characterized by the resource allocation matrix $\\mathbf{Allocation} \\in \\mathbb{Z}^{6 \\times 4}$, the outstanding request matrix $\\mathbf{Request} \\in \\mathbb{Z}^{6 \\times 4}$, and the currently available instances vector $\\mathbf{Available} \\in \\mathbb{Z}^{4}$, all given below. Each row corresponds to a process $P_i$, and each column corresponds to a resource type $R_j$.\n\n$$\n\\mathbf{Allocation} =\n\\begin{pmatrix}\n1 & 0 & 0 & 1 \\\\\n0 & 0 & 1 & 0 \\\\\n0 & 2 & 0 & 0 \\\\\n1 & 0 & 0 & 0 \\\\\n0 & 0 & 1 & 1 \\\\\n0 & 1 & 0 & 0\n\\end{pmatrix},\n\\quad\n\\mathbf{Request} =\n\\begin{pmatrix}\n0 & 0 & 1 & 0 \\\\\n1 & 0 & 0 & 0 \\\\\n0 & 1 & 0 & 0 \\\\\n0 & 0 & 0 & 0 \\\\\n0 & 0 & 0 & 1 \\\\\n0 & 1 & 0 & 0\n\\end{pmatrix},\n\\quad\n\\mathbf{Available} =\n\\begin{pmatrix}\n1 & 0 & 1 & 0\n\\end{pmatrix}.\n$$\n\nUse the classical deadlock detection algorithm for multiple-instance resources that iteratively searches for an unfinished process $P_i$ whose request vector $Request_i$ satisfies $Request_i \\leq Work$ (with $Work$ initialized to $\\mathbf{Available}$), and when found, treats $P_i$ as able to complete and release its allocation, updating $Work \\leftarrow Work + Allocation_i$. Continue until no such $P_i$ exists; the processes that remain unfinished at that point are deemed unfinishable.\n\nDefine the quantity $S$ to be the sum of the indices of all unfinishable processes, i.e., if the unfinishable set is $\\{P_{i_1}, P_{i_2}, \\dots\\}$ then $S = i_1 + i_2 + \\dots$. Compute $S$. Provide your final answer as an exact integer. No rounding is required.",
            "solution": "The problem is validated as being scientifically grounded, well-posed, and objective. It describes a standard scenario in operating systems and asks for the application of the classical deadlock detection algorithm. All necessary data is provided, and the problem is free of contradictions or ambiguities.\n\nThe task is to determine the set of unfinishable processes in a system with $n=6$ processes and $m=4$ resource types. The state of the system is given by the $\\mathbf{Allocation}$ matrix, the $\\mathbf{Request}$ matrix, and the $\\mathbf{Available}$ vector.\n\nThe givens are:\n- Number of processes: $n=6$, $\\{P_0,P_1,P_2,P_3,P_4,P_5\\}$.\n- Number of resource types: $m=4$, $\\{R_1,R_2,R_3,R_4\\}$.\n- Allocation matrix $\\mathbf{Allocation} \\in \\mathbb{Z}^{6 \\times 4}$:\n$$\n\\mathbf{Allocation} =\n\\begin{pmatrix}\n1 & 0 & 0 & 1 \\\\\n0 & 0 & 1 & 0 \\\\\n0 & 2 & 0 & 0 \\\\\n1 & 0 & 0 & 0 \\\\\n0 & 0 & 1 & 1 \\\\\n0 & 1 & 0 & 0\n\\end{pmatrix}\n$$\n- Request matrix $\\mathbf{Request} \\in \\mathbb{Z}^{6 \\times 4}$:\n$$\n\\mathbf{Request} =\n\\begin{pmatrix}\n0 & 0 & 1 & 0 \\\\\n1 & 0 & 0 & 0 \\\\\n0 & 1 & 0 & 0 \\\\\n0 & 0 & 0 & 0 \\\\\n0 & 0 & 0 & 1 \\\\\n0 & 1 & 0 & 0\n\\end{pmatrix}\n$$\n- Available vector $\\mathbf{Available} \\in \\mathbb{Z}^{4}$:\n$$\n\\mathbf{Available} = \\begin{pmatrix} 1 & 0 & 1 & 0 \\end{pmatrix}\n$$\n\nWe apply the deadlock detection algorithm. Let $\\mathbf{Work}$ be a vector of length $m$ and $\\mathbf{Finish}$ be a boolean vector of length $n$. The vector inequality $\\mathbf{A} \\leq \\mathbf{B}$ holds if and only if $A_k \\leq B_k$ for all components $k$.\n\n**Step 1: Initialization**\nInitialize $\\mathbf{Work}$ to $\\mathbf{Available}$ and $\\mathbf{Finish}_i$ to false for all processes $i = 0, \\dots, 5$.\n$$ \\mathbf{Work} = \\mathbf{Available} = \\begin{pmatrix} 1 & 0 & 1 & 0 \\end{pmatrix} $$\n$$ \\mathbf{Finish} = \\begin{pmatrix} \\text{false} & \\text{false} & \\text{false} & \\text{false} & \\text{false} & \\text{false} \\end{pmatrix} $$\n\n**Step 2: Iterative Search and Update**\nThe algorithm proceeds by finding an index $i$ such that $\\mathbf{Finish}_i$ is false and its request vector $\\mathbf{Request}_i \\leq \\mathbf{Work}$. If found, the process can theoretically finish, so we release its resources by updating $\\mathbf{Work} \\leftarrow \\mathbf{Work} + \\mathbf{Allocation}_i$ and setting $\\mathbf{Finish}_i \\leftarrow \\text{true}$. This process is repeated until no such process can be found.\n\n**Iteration 1:**\nWe search for a process $P_i$ with $\\mathbf{Finish}_i = \\text{false}$ and $\\mathbf{Request}_i \\leq \\mathbf{Work} = \\begin{pmatrix} 1 & 0 & 1 & 0 \\end{pmatrix}$.\n- $P_0$: $\\mathbf{Request}_0 = \\begin{pmatrix} 0 & 0 & 1 & 0 \\end{pmatrix} \\leq \\begin{pmatrix} 1 & 0 & 1 & 0 \\end{pmatrix}$. This condition is met.\nLet's select $P_0$.\nUpdate $\\mathbf{Work}$: $\\mathbf{Work} \\leftarrow \\mathbf{Work} + \\mathbf{Allocation}_0 = \\begin{pmatrix} 1 & 0 & 1 & 0 \\end{pmatrix} + \\begin{pmatrix} 1 & 0 & 0 & 1 \\end{pmatrix} = \\begin{pmatrix} 2 & 0 & 1 & 1 \\end{pmatrix}$.\nUpdate $\\mathbf{Finish}$: $\\mathbf{Finish}_0 \\leftarrow \\text{true}$.\nThe current state is $\\mathbf{Work} = \\begin{pmatrix} 2 & 0 & 1 & 1 \\end{pmatrix}$ and $\\mathbf{Finish} = \\begin{pmatrix} \\text{true} & \\text{false} & \\text{false} & \\text{false} & \\text{false} & \\text{false} \\end{pmatrix}$.\n\n**Iteration 2:**\nWe search for an unfinished process $P_i$ with $\\mathbf{Request}_i \\leq \\mathbf{Work} = \\begin{pmatrix} 2 & 0 & 1 & 1 \\end{pmatrix}$.\n- $P_1$: $\\mathbf{Request}_1 = \\begin{pmatrix} 1 & 0 & 0 & 0 \\end{pmatrix} \\leq \\begin{pmatrix} 2 & 0 & 1 & 1 \\end{pmatrix}$. This condition is met.\nLet's select $P_1$.\nUpdate $\\mathbf{Work}$: $\\mathbf{Work} \\leftarrow \\mathbf{Work} + \\mathbf{Allocation}_1 = \\begin{pmatrix} 2 & 0 & 1 & 1 \\end{pmatrix} + \\begin{pmatrix} 0 & 0 & 1 & 0 \\end{pmatrix} = \\begin{pmatrix} 2 & 0 & 2 & 1 \\end{pmatrix}$.\nUpdate $\\mathbf{Finish}$: $\\mathbf{Finish}_1 \\leftarrow \\text{true}$.\nThe current state is $\\mathbf{Work} = \\begin{pmatrix} 2 & 0 & 2 & 1 \\end{pmatrix}$ and $\\mathbf{Finish} = \\begin{pmatrix} \\text{true} & \\text{true} & \\text{false} & \\text{false} & \\text{false} & \\text{false} \\end{pmatrix}$.\n\n**Iteration 3:**\nWe search for an unfinished process $P_i$ with $\\mathbf{Request}_i \\leq \\mathbf{Work} = \\begin{pmatrix} 2 & 0 & 2 & 1 \\end{pmatrix}$.\n- $P_2$: $\\mathbf{Request}_2 = \\begin{pmatrix} 0 & 1 & 0 & 0 \\end{pmatrix}$. This is not $\\leq \\mathbf{Work}$ because for the second resource, $1 > 0$.\n- $P_3$: $\\mathbf{Request}_3 = \\begin{pmatrix} 0 & 0 & 0 & 0 \\end{pmatrix} \\leq \\begin{pmatrix} 2 & 0 & 2 & 1 \\end{pmatrix}$. This condition is met.\nLet's select $P_3$.\nUpdate $\\mathbf{Work}$: $\\mathbf{Work} \\leftarrow \\mathbf{Work} + \\mathbf{Allocation}_3 = \\begin{pmatrix} 2 & 0 & 2 & 1 \\end{pmatrix} + \\begin{pmatrix} 1 & 0 & 0 & 0 \\end{pmatrix} = \\begin{pmatrix} 3 & 0 & 2 & 1 \\end{pmatrix}$.\nUpdate $\\mathbf{Finish}$: $\\mathbf{Finish}_3 \\leftarrow \\text{true}$.\nThe current state is $\\mathbf{Work} = \\begin{pmatrix} 3 & 0 & 2 & 1 \\end{pmatrix}$ and $\\mathbf{Finish} = \\begin{pmatrix} \\text{true} & \\text{true} & \\text{false} & \\text{true} & \\text{false} & \\text{false} \\end{pmatrix}$.\n\n**Iteration 4:**\nWe search for an unfinished process $P_i$ with $\\mathbf{Request}_i \\leq \\mathbf{Work} = \\begin{pmatrix} 3 & 0 & 2 & 1 \\end{pmatrix}$.\n- $P_2$: $\\mathbf{Request}_2$ is still not satisfiable.\n- $P_4$: $\\mathbf{Request}_4 = \\begin{pmatrix} 0 & 0 & 0 & 1 \\end{pmatrix} \\leq \\begin{pmatrix} 3 & 0 & 2 & 1 \\end{pmatrix}$. This condition is met.\nLet's select $P_4$.\nUpdate $\\mathbf{Work}$: $\\mathbf{Work} \\leftarrow \\mathbf{Work} + \\mathbf{Allocation}_4 = \\begin{pmatrix} 3 & 0 & 2 & 1 \\end{pmatrix} + \\begin{pmatrix} 0 & 0 & 1 & 1 \\end{pmatrix} = \\begin{pmatrix} 3 & 0 & 3 & 2 \\end{pmatrix}$.\nUpdate $\\mathbf{Finish}$: $\\mathbf{Finish}_4 \\leftarrow \\text{true}$.\nThe current state is $\\mathbf{Work} = \\begin{pmatrix} 3 & 0 & 3 & 2 \\end{pmatrix}$ and $\\mathbf{Finish} = \\begin{pmatrix} \\text{true} & \\text{true} & \\text{false} & \\text{true} & \\text{true} & \\text{false} \\end{pmatrix}$.\n\n**Iteration 5:**\nWe search for an unfinished process $P_i$ with $\\mathbf{Request}_i \\leq \\mathbf{Work} = \\begin{pmatrix} 3 & 0 & 3 & 2 \\end{pmatrix}$. The remaining unfinished processes are $P_2$ and $P_5$.\n- $P_2$: $\\mathbf{Request}_2 = \\begin{pmatrix} 0 & 1 & 0 & 0 \\end{pmatrix}$. This is not $\\leq \\mathbf{Work}$ because for $R_2$, $1 > 0$.\n- $P_5$: $\\mathbf{Request}_5 = \\begin{pmatrix} 0 & 1 & 0 & 0 \\end{pmatrix}$. This is not $\\leq \\mathbf{Work}$ because for $R_2$, $1 > 0$.\n\n**Step 3: Termination**\nNo remaining unfinished process can have its request satisfied with the current $\\mathbf{Work}$ vector. The algorithm terminates.\n\n**Step 4: Identify Unfinishable Processes and Calculate S**\nThe processes for which $\\mathbf{Finish}_i$ remains false are considered unfinishable. From the final $\\mathbf{Finish}$ vector $\\begin{pmatrix} \\text{true} & \\text{true} & \\text{false} & \\text{true} & \\text{true} & \\text{false} \\end{pmatrix}$, the unfinishable processes are $\\{P_2, P_5\\}$.\n\nThe problem defines $S$ as the sum of the indices of all unfinishable processes.\n$$ S = 2 + 5 = 7 $$\nThe physical reason for the deadlock is that both $P_2$ and $P_5$ are requesting an instance of resource $R_2$. There are $0$ instances of $R_2$ available, and no other process that can finish holds any instances of $R_2$ to release. Thus, $P_2$ and $P_5$ will wait indefinitely.",
            "answer": "$$\\boxed{7}$$"
        },
        {
            "introduction": "Moving from numerical analysis to a more visual representation, this next practice focuses on the Wait-For Graph (WFG), a powerful tool for modeling deadlocks in systems with single-instance resources. After constructing the WFG from a given scenario, your task is to identify the cycles that represent deadlocks and then determine the minimum number of processes to preempt to break them . This exercise not only sharpens your detection skills but also introduces the practical challenge of deadlock recovery.",
            "id": "3632133",
            "problem": "An operating system monitors a snapshot of resource allocation in a system using the Resource Allocation Graph (RAG) and its derived Wait-For Graph (WFG). Under the single-instance resource model with the logical \"AND\" request semantics, an edge from process $P_{i}$ to process $P_{j}$ appears in the WFG if and only if $P_{i}$ is currently blocked and is requesting at least one resource that is held by $P_{j}$. A deadlock exists if and only if the WFG contains at least one directed cycle. The system can perform resource preemption for recovery: preempting a process $P_{v}$ immediately releases all resources held by $P_{v}$ and removes $P_{v}$ and all incident edges from the WFG.\n\nConsider the following scientifically plausible snapshot with $7$ processes $\\{P_{1},P_{2},P_{3},P_{4},P_{5},P_{6},P_{7}\\}$ and $8$ single-instance resources $\\{R_{1},R_{2},R_{3},R_{4},R_{5},R_{6},R_{8}\\}$ (note that resource identifiers need not be consecutive):\n\n- Current holdings (each resource is held by exactly one process):\n  - $R_{3}$ held by $P_{1}$.\n  - $R_{1}$ held by $P_{2}$.\n  - $R_{2}$ held by $P_{3}$.\n  - $R_{4}$ held by $P_{4}$.\n  - $R_{5}$ held by $P_{5}$.\n  - $R_{6}$ held by $P_{6}$.\n  - $R_{8}$ held by $P_{7}$.\n\n- Current pending requests (each bullet indicates a process that is blocked, requesting all listed resources simultaneously, each of which is currently held by the stated holder above):\n  - $P_{1}$ requests $\\{R_{1}\\}$.\n  - $P_{2}$ requests $\\{R_{2},R_{5}\\}$.\n  - $P_{3}$ requests $\\{R_{3},R_{4}\\}$.\n  - $P_{4}$ requests $\\{R_{5},R_{8}\\}$.\n  - $P_{5}$ requests $\\{R_{2},R_{6}\\}$.\n  - $P_{6}$ requests $\\{R_{1}\\}$.\n  - $P_{7}$ requests $\\{R_{4}\\}$.\n\nUsing only the fundamental definitions above:\n- Construct the Wait-For Graph by introducing a directed edge $P_{i} \\to P_{j}$ for each requested resource by $P_{i}$ that is currently held by $P_{j}$.\n- Reason about deadlock by identifying directed cycles in the WFG.\n- Under the stated preemption model, interpret deadlock recovery as selecting a set of processes (victims) whose preemption breaks all directed cycles in the WFG.\n\nDetermine the minimal possible number of processes that must be preempted so that the resulting WFG is acyclic. Report your answer as a single integer. No rounding is required and no units are needed.",
            "solution": "The problem provides a snapshot of a system with multiple processes and single-instance resources and asks for the minimum number of processes to preempt to resolve all deadlocks. The problem is scientifically grounded, well-posed, and objective, based on standard principles of operating systems and graph theory. Therefore, it is a valid problem.\n\nThe solution proceeds in three steps:\n1.  Construct the Wait-For Graph (WFG) from the given process holdings and requests.\n2.  Identify all directed cycles in the WFG, as cycles indicate the presence of deadlocks.\n3.  Determine the minimum set of vertices (processes) whose removal breaks all cycles. This is equivalent to finding the minimum feedback vertex set of the WFG.\n\n**Step 1: Construct the Wait-For Graph (WFG)**\n\nThe vertices of the WFG are the set of processes $V = \\{P_{1}, P_{2}, P_{3}, P_{4}, P_{5}, P_{6}, P_{7}\\}$.\nA directed edge $P_{i} \\to P_{j}$ exists if process $P_{i}$ is requesting a resource held by process $P_{j}$. We analyze the given requests to determine the edge set $E$ of the graph.\n\n-   Process $P_{1}$ requests $\\{R_{1}\\}$. Resource $R_{1}$ is held by $P_{2}$. This creates an edge $P_{1} \\to P_{2}$.\n-   Process $P_{2}$ requests $\\{R_{2}, R_{5}\\}$. Resource $R_{2}$ is held by $P_{3}$, and $R_{5}$ is held by $P_{5}$. This creates edges $P_{2} \\to P_{3}$ and $P_{2} \\to P_{5}$.\n-   Process $P_{3}$ requests $\\{R_{3}, R_{4}\\}$. Resource $R_{3}$ is held by $P_{1}$, and $R_{4}$ is held by $P_{4}$. This creates edges $P_{3} \\to P_{1}$ and $P_{3} \\to P_{4}$.\n-   Process $P_{4}$ requests $\\{R_{5}, R_{8}\\}$. Resource $R_{5}$ is held by $P_{5}$, and $R_{8}$ is held by $P_{7}$. This creates edges $P_{4} \\to P_{5}$ and $P_{4} \\to P_{7}$.\n-   Process $P_{5}$ requests $\\{R_{2}, R_{6}\\}$. Resource $R_{2}$ is held by $P_{3}$, and $R_{6}$ is held by $P_{6}$. This creates edges $P_{5} \\to P_{3}$ and $P_{5} \\to P_{6}$.\n-   Process $P_{6}$ requests $\\{R_{1}\\}$. Resource $R_{1}$ is held by $P_{2}$. This creates an edge $P_{6} \\to P_{2}$.\n-   Process $P_{7}$ requests $\\{R_{4}\\}$. Resource $R_{4}$ is held by $P_{4}$. This creates an edge $P_{7} \\to P_{4}$.\n\nThe complete set of edges in the WFG is:\n$E = \\{ (P_{1}, P_{2}), (P_{2}, P_{3}), (P_{2}, P_{5}), (P_{3}, P_{1}), (P_{3}, P_{4}), (P_{4}, P_{5}), (P_{4}, P_{7}), (P_{5}, P_{3}), (P_{5}, P_{6}), (P_{6}, P_{2}), (P_{7}, P_{4}) \\}$.\n\n**Step 2: Identify Directed Cycles**\n\nA deadlock exists if and only if there is at least one directed cycle in the WFG. By inspection of the graph defined by $V$ and $E$, we can identify the following fundamental cycles:\n\n1.  $C_{1}: P_{1} \\to P_{2} \\to P_{3} \\to P_{1}$. This cycle involves processes $\\{P_{1}, P_{2}, P_{3}\\}$.\n2.  $C_{2}: P_{2} \\to P_{5} \\to P_{3} \\to P_{1} \\to P_{2}$. This cycle involves processes $\\{P_{1}, P_{2}, P_{3}, P_{5}\\}$.\n3.  $C_{3}: P_{2} \\to P_{5} \\to P_{6} \\to P_{2}$. This cycle involves processes $\\{P_{2}, P_{5}, P_{6}\\}$.\n4.  $C_{4}: P_{4} \\to P_{7} \\to P_{4}$. This cycle involves processes $\\{P_{4}, P_{7}\\}$.\n5.  $C_{5}: P_{3} \\to P_{4} \\to P_{5} \\to P_{3}$. This cycle involves processes $\\{P_{3}, P_{4}, P_{5}\\}$.\n\nSince there are multiple cycles, the system is in a state of deadlock. All $7$ processes are part of at least one cycle.\n\n**Step 3: Determine the Minimum Number of Preemptions**\n\nTo recover from deadlock, we must preempt a set of processes (victims) such that their removal from the WFG eliminates all directed cycles. This is the Minimum Feedback Vertex Set problem. For a graph of this size, we can determine the minimum number by direct analysis.\n\nFirst, we check if preempting a single process is sufficient.\n-   Preempting $P_{1}$: Breaks cycles $C_{1}$ and $C_{2}$. Cycles $C_{3}$, $C_{4}$, and $C_{5}$ remain.\n-   Preempting $P_{2}$: Breaks cycles $C_{1}$, $C_{2}$, and $C_{3}$. Cycles $C_{4}$ and $C_{5}$ remain.\n-   Preempting $P_{3}$: Breaks cycles $C_{1}$, $C_{2}$, and $C_{5}$. Cycles $C_{3}$ and $C_{4}$ remain.\n-   Preempting $P_{4}$: Breaks cycles $C_{4}$ and $C_{5}$. Cycles $C_{1}$, $C_{2}$, and $C_{3}$ remain.\n-   Preempting $P_{5}$: Breaks cycles $C_{2}$, $C_{3}$, and $C_{5}$. Cycles $C_{1}$ and $C_{4}$ remain.\n-   Preempting $P_{6}$: Breaks only cycle $C_{3}$.\n-   Preempting $P_{7}$: Breaks only cycle $C_{4}$.\n\nSince no single preemption can break all cycles, the minimum number of victims must be greater than $1$.\n\nNext, we check if preempting two processes is sufficient. We need to find a pair of processes $\\{P_{i}, P_{j}\\}$ that together are part of every cycle.\nLet's analyze the cycles each process participates in:\n-   $P_{1}$: in $\\{C_{1}, C_{2}\\}$\n-   $P_{2}$: in $\\{C_{1}, C_{2}, C_{3}\\}$\n-   $P_{3}$: in $\\{C_{1}, C_{2}, C_{5}\\}$\n-   $P_{4}$: in $\\{C_{4}, C_{5}\\}$\n-   $P_{5}$: in $\\{C_{2}, C_{3}, C_{5}\\}$\n-   $P_{6}$: in $\\{C_{3}\\}$\n-   $P_{7}$: in $\\{C_{4}\\}$\n\nConsider the set of victims $\\{P_{2}, P_{4}\\}$.\n-   Preempting $P_{2}$ breaks cycles $C_{1}$, $C_{2}$, and $C_{3}$.\n-   The remaining cycles to be broken are $C_{4}$ and $C_{5}$.\n-   Preempting $P_{4}$ breaks both cycles $C_{4}$ and $C_{5}$.\n\nThus, preempting the set of processes $\\{P_{2}, P_{4}\\}$ is sufficient to break all cycles in the WFG.\nSince $1$ preemption is insufficient and $2$ are sufficient, the minimal possible number of processes that must be preempted is $2$.",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "To solidify your understanding, this final practice transitions from theoretical analysis to implementation, challenging you to write code that analyzes Wait-For Graphs. You will implement algorithms to find Strongly Connected Components (SCCs) and identify the shortest deadlock cycles, gaining a deeper appreciation for the graph-theoretic foundations of deadlock detection . This coding exercise bridges the gap between abstract concepts and their concrete application in system software.",
            "id": "3632165",
            "problem": "Consider the following computational lab in the context of deadlock detection in an operating system. You are given a family of finite directed graphs that represent the wait-for graph (WFG) induced by a set of processes. A WFG is a directed graph whose vertices are processes and where there is a directed edge from process $P_i$ to process $P_j$ if and only if $P_i$ is currently waiting for a resource held by $P_j$. The fundamental base we will rely on consists of the following standard definitions and facts from graph theory and operating systems.\n\n1. A directed graph has a deadlock if and only if there exists at least one directed cycle. In a WFG, a directed cycle corresponds to a set of processes each of which is waiting for the next process in the cycle, so none can proceed without external intervention.\n2. A strongly connected component (SCC) is a maximal set of vertices where each vertex is reachable from every other vertex in the set. Every directed cycle is fully contained inside a single SCC. Conversely, every SCC of size at least $2$ contains at least one directed cycle; an SCC of size $1$ contains a cycle only if it has a self-loop.\n3. The task is to detect SCCs and compare them with minimal deadlock cycles to understand why some SCCs do not correspond to deadlocks under the precise definition in item $1$.\n\nYour program must:\n- Construct each test graph internally and perform two analyses:\n  - Compute the number of SCCs and the number of SCCs that actually represent deadlocks under the definition above (that is, an SCC of size at least $2$, or an SCC of size $1$ with a self-loop).\n  - Compute the length of the shortest directed cycle (a minimal deadlock cycle) in the entire graph, where the length is the number of distinct vertices on the cycle. If no directed cycle exists, the length should be reported as $0$.\n- Report, in addition, the total number of processes that are involved in deadlocks, defined as the sum of the sizes of all SCCs that correspond to deadlocks as just defined.\n\nYou must treat process identifiers as integers from $1$ to $n$ for each graph. All graphs are finite and directed.\n\nTest suite:\nProvide results for exactly $4$ test graphs. Each graph is specified by a pair $\\left(n, E\\right)$, where $n$ is the number of processes (vertices) and $E$ is the set of directed edges:\n- Test case $1$: $n = 5$, edges $E = \\{(1,2),(2,3),(3,1),(4,5)\\}$.\n- Test case $2$: $n = 4$, edges $E = \\{(1,2),(2,3),(3,4)\\}$.\n- Test case $3$: $n = 4$, edges $E = \\{(1,1),(2,3),(3,2)\\}$.\n- Test case $4$: $n = 6$, edges $E = \\{(1,2),(2,3),(3,1),(3,4),(4,2),(5,6)\\}$.\n\nFor each test case, your program must compute the following $4$ integers:\n- $s$: the total number of strongly connected components,\n- $d$: the number of SCCs that are deadlocks under the definition above,\n- $\\ell$: the length of the shortest directed cycle in the entire graph (use $\\ell = 0$ if there is no cycle),\n- $t$: the total number of processes that are in deadlock (sum of the sizes of all deadlock SCCs).\n\nFinal output format:\nYour program should produce a single line of output containing the results for all four test cases as a comma-separated list of lists, each inner list in the order $\\left[s,d,\\ell,t\\right]$, enclosed in a single pair of square brackets. For example, the format must be exactly like\n$[\\,[s_1,d_1,\\ell_1,t_1],[s_2,d_2,\\ell_2,t_2],[s_3,d_3,\\ell_3,t_3],[s_4,d_4,\\ell_4,t_4]\\,]$.\n\nThere are no physical units or angles in this problem. All outputs are integers written in base-$10$ numerals.",
            "solution": "The problem is valid. It is scientifically grounded in established principles of graph theory and their application to deadlock detection in operating systems. The problem is well-posed, objective, and contains all necessary information to derive a unique, verifiable solution.\n\n### 1. Problem Formalization\n\nThe problem requires the analysis of several wait-for graphs (WFGs), which are finite directed graphs $G = (V, E)$, where $V$ is a set of processes and an edge $(P_i, P_j) \\in E$ signifies that process $P_i$ is waiting for a resource held by process $P_j$. The process identifiers are integers from $1$ to $n$, where $n = |V|$. We will map these identifiers to zero-indexed vertices $0, 1, \\dots, n-1$ for computational implementation.\n\nFor each given graph, we are tasked with computing four quantities:\n1.  $s$: The total number of strongly connected components (SCCs) in the graph. An SCC is a maximal subgraph where for any two vertices $u, v$ in the subgraph, there is a path from $u$ to $v$ and a path from $v$ to $u$.\n2.  $d$: The number of SCCs that constitute a deadlock. According to the problem definition, a deadlock corresponds to an SCC of size at least $2$, or an SCC of size $1$ that has a self-loop. This is because any such SCC is guaranteed to contain at least one directed cycle, which is the necessary and sufficient condition for a deadlock.\n3.  $\\ell$: The length of the shortest directed cycle in the graph, defined as the number of distinct vertices in the cycle. If no cycles exist, $\\ell = 0$.\n4.  $t$: The total number of processes involved in deadlocks. This is the sum of the sizes (number of vertices) of all SCCs identified as deadlocks.\n\n### 2. Algorithmic Strategy\n\nA multi-step algorithmic approach is required to compute the four specified quantities.\n\n#### 2.1. SCC Decomposition and Deadlock Analysis ($s, d, t$)\n\nTo find the SCCs of each directed graph, we will employ Tarjan's algorithm. This algorithm is highly efficient, with a time complexity of $O(|V| + |E|)$, making it suitable for this task. The algorithm performs a single Depth-First Search (DFS) from an arbitrary start vertex. During the traversal, it maintains two values for each vertex $u$:\n-   `disc[u]`: The discovery time, i.e., the time-stamp when $u$ is first visited.\n-   `low[u]`: The lowest discovery time reachable from $u$ (including through back-edges in the DFS tree).\n\nA vertex $u$ is the root of an SCC if and only if `disc[u] == low[u]`. When such a vertex is found, all vertices on the algorithm's internal stack above and including $u$ form a complete SCC.\n\nAs each SCC is identified by Tarjan's algorithm, we can immediately analyze it to determine if it represents a deadlock. Let an SCC have size $k$.\n-   If $k \\ge 2$, it is classified as a deadlock. We increment the deadlock count $d$ and add $k$ to the total deadlocked process count $t$.\n-   If $k = 1$, the SCC consists of a single vertex $v$. We check if a self-loop $(v, v)$ exists in the graph. If it does, this SCC is also a deadlock. We increment $d$ and add $1$ to $t$.\nThe total number of SCCs found gives the value of $s$. This integrated approach allows us to compute $s, d,$ and $t$ in a single pass over the graph structure.\n\n#### 2.2. Shortest Cycle Detection ($\\ell$)\n\nTo find the length of the shortest directed cycle, $\\ell$, we can perform a Breadth-First Search (BFS) starting from each vertex in the graph. A BFS naturally finds the shortest path from a source vertex to all other reachable vertices in terms of the number of edges.\n\nThe algorithm is as follows:\n1.  Initialize a minimum cycle length, $\\ell_{min}$, to a value larger than any possible cycle length (e.g., $n+1$).\n2.  For each vertex $u \\in V$:\n    a.  Execute a BFS starting from $u$. We use a `dist` array to store the shortest distance from $u$.\n    b.  During the BFS traversal, when exploring from a vertex $v$ to its neighbors $w$:\n        i.  If $w$ is the starting vertex $u$, a cycle has been found. Its length is `dist[v] + 1`. We update $\\ell_{min} = \\min(\\ell_{min}, \\text{dist}[v] + 1)$.\n        ii. If $w$ has not been visited, we update its distance, `dist[w] = dist[v] + 1`, and add it to the queue.\n3.  After iterating through all possible starting vertices, if $\\ell_{min}$ remains at its initial large value, no cycles were found, and we set $\\ell=0$. Otherwise, $\\ell = \\ell_{min}$.\n\nThe time complexity of this approach is $O(|V| \\cdot (|V|+|E|))$, which is computationally feasible for the small graphs specified in the problem statement.\n\n### 3. Implementation and Test Case Walkthrough\n\nThe described algorithms will be implemented in C. The graphs are represented using an adjacency matrix for simplicity, given the small number of vertices ($n \\le 6$). Process identifiers $1, \\dots, n$ are mapped to $0$-indexed array indices $0, \\dots, n-1$.\n\nLet's walk through **Test Case 4**: $n = 6$, edges $E = \\{(1,2),(2,3),(3,1),(3,4),(4,2),(5,6)\\}$.\n\n-   **Graph Construction**: The vertices are $\\{0, 1, 2, 3, 4, 5\\}$. Edges are $\\{(0,1), (1,2), (2,0), (2,3), (3,1), (4,5)\\}$.\n\n-   **SCC and Deadlock Analysis ($s, d, t$)**:\n    1.  Running Tarjan's algorithm reveals three SCCs:\n        -   $C_1 = \\{0, 1, 2, 3\\}$: All these vertices are mutually reachable. For example, $0 \\to 1 \\to 2 \\to 0$ and $1 \\to 2 \\to 3 \\to 1$.\n        -   $C_2 = \\{4\\}$: Vertex $4$ has an outgoing edge to $5$ but no path back.\n        -   $C_3 = \\{5\\}$: Vertex $5$ has no outgoing edges.\n    2.  The total number of SCCs is $s = 3$.\n    3.  Analyzing for deadlocks:\n        -   $C_1$: Size is $4 \\ge 2$. It is a deadlock. Current state: $d=1, t=4$.\n        -   $C_2$: Size is $1$. There is no self-loop $(4,4)$. Not a deadlock.\n        -   $C_3$: Size is $1$. There is no self-loop $(5,5)$. Not a deadlock.\n    4.  Final values: $s=3$, $d=1$, $t=4$.\n\n-   **Shortest Cycle ($\\ell$)**:\n    1.  We search for cycles. A BFS starting from vertex $1$ explores its neighbor $2$ (distance $1$), which explores its neighbor $0$ (distance $2$), which explores its neighbor $1$. A cycle $1 \\to 2 \\to 0 \\to 1$ is detected with length $3$. So, $\\ell_{min}$ is set to $3$.\n    2.  Another cycle is $1 \\to 2 \\to 3 \\to 1$, also of length $3$.\n    3.  A check for cycles of length $2$ (of the form $u \\to v \\to u$) reveals none exist.\n    4.  The shortest cycle length found is $3$. Thus, $\\ell=3$.\n\n-   **Result for Test Case 4**: $[s, d, \\ell, t] = [3, 1, 3, 4]$.\n\nThis detailed analysis, applied to all test cases, yields the final results to be computed by the program.",
            "answer": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// No other headers are permitted.\n// #include <math.h>\n// #include <complex.h>\n// #include <threads.h>\n// #include <stdatomic.h>\n\n#define MAX_VERTICES 10\n#define MAX_EDGES 20\n#define UNVISITED -1\n#define MIN(a,b) (((a)<(b))?(a):(b))\n\n// Graph representation using an adjacency matrix\ntypedef struct {\n    int n; // number of vertices\n    int adj[MAX_VERTICES][MAX_VERTICES];\n} Graph;\n\n// State for Tarjan's algorithm\ntypedef struct {\n    int disc[MAX_VERTICES];\n    int low[MAX_VERTICES];\n    int on_stack[MAX_VERTICES];\n    int stack[MAX_VERTICES];\n    int stack_ptr;\n    int time;\n    int scc_count;\n    int deadlock_scc_count;\n    int deadlocked_processes_count;\n} TarjanState;\n\n// A simple queue for BFS\ntypedef struct {\n    int items[MAX_VERTICES];\n    int front;\n    int rear;\n} Queue;\n\nvoid init_queue(Queue* q) { q->front = -1; q->rear = -1; }\nint is_queue_empty(Queue* q) { return q->rear == -1 || q->front > q->rear; }\nvoid enqueue(Queue* q, int value) {\n    if (q->rear == MAX_VERTICES - 1) return;\n    if (q->front == -1) q->front = 0;\n    q->rear++;\n    q->items[q->rear] = value;\n}\nint dequeue(Queue* q) {\n    if (is_queue_empty(q)) return -1;\n    int item = q->items[q->front];\n    q->front++;\n    if (q->front > q->rear) {\n        init_queue(q);\n    }\n    return item;\n}\n\n// Prototypes\nvoid tarjan_dfs(int u, TarjanState* state, const Graph* g);\nvoid find_sccs_and_deadlocks(const Graph* g, int* s, int* d, int* t);\nint find_shortest_cycle(const Graph* g);\n\n// Tarjan's algorithm DFS helper function\nvoid tarjan_dfs(int u, TarjanState* state, const Graph* g) {\n    state->disc[u] = state->low[u] = state->time++;\n    state->stack[state->stack_ptr++] = u;\n    state->on_stack[u] = 1;\n\n    for (int v = 0; v < g->n; ++v) {\n        if (g->adj[u][v]) {\n            if (state->disc[v] == UNVISITED) {\n                tarjan_dfs(v, state, g);\n                state->low[u] = MIN(state->low[u], state->low[v]);\n            } else if (state->on_stack[v]) {\n                state->low[u] = MIN(state->low[u], state->disc[v]);\n            }\n        }\n    }\n\n    if (state->low[u] == state->disc[u]) {\n        state->scc_count++;\n        int scc_size = 0;\n        int current_scc_nodes[MAX_VERTICES];\n        int w;\n        \n        do {\n            w = state->stack[--state->stack_ptr];\n            state->on_stack[w] = 0;\n            current_scc_nodes[scc_size++] = w;\n        } while (u != w);\n        \n        int is_deadlock = 0;\n        if (scc_size > 1) {\n            is_deadlock = 1;\n        } else { // scc_size == 1\n            int node = current_scc_nodes[0];\n            if (g->adj[node][node]) { // Check for self-loop\n                is_deadlock = 1;\n            }\n        }\n\n        if (is_deadlock) {\n            state->deadlock_scc_count++;\n            state->deadlocked_processes_count += scc_size;\n        }\n    }\n}\n\n// Main function to find SCCs and analyze deadlocks\nvoid find_sccs_and_deadlocks(const Graph* g, int* s, int* d, int* t) {\n    TarjanState state;\n    memset(&state, 0, sizeof(TarjanState));\n    for (int i = 0; i < g->n; ++i) {\n        state.disc[i] = UNVISITED;\n    }\n\n    for (int i = 0; i < g->n; ++i) {\n        if (state.disc[i] == UNVISITED) {\n            tarjan_dfs(i, &state, g);\n        }\n    }\n\n    *s = state.scc_count;\n    *d = state.deadlock_scc_count;\n    *t = state.deadlocked_processes_count;\n}\n\n// Function to find the length of the shortest cycle\nint find_shortest_cycle(const Graph* g) {\n    int min_len = g->n + 1; // Initialize with a value larger than any possible cycle\n\n    for (int i = 0; i < g->n; ++i) { // Start BFS from each vertex\n        Queue q;\n        init_queue(&q);\n        int dist[MAX_VERTICES];\n        for(int k=0; k<g->n; ++k) dist[k] = -1;\n\n        dist[i] = 0;\n        enqueue(&q, i);\n\n        while (!is_queue_empty(&q)) {\n            int u = dequeue(&q);\n\n            for (int v = 0; v < g->n; ++v) {\n                if (g->adj[u][v]) {\n                    if (v == i) { // Cycle detected\n                        min_len = MIN(min_len, dist[u] + 1);\n                    } else if (dist[v] == -1) {\n                        dist[v] = dist[u] + 1;\n                        enqueue(&q, v);\n                    }\n                }\n            }\n        }\n    }\n\n    return (min_len > g->n) ? 0 : min_len;\n}\n\n// Struct to hold the parameters for a single test case.\ntypedef struct {\n    int n;\n    int num_edges;\n    int edges[MAX_EDGES][2];\n} TestCase;\n\nint main(void) {\n    // Define the test cases from the problem statement.\n    TestCase test_cases[] = {\n        {5, 4, {{1, 2}, {2, 3}, {3, 1}, {4, 5}}},\n        {4, 3, {{1, 2}, {2, 3}, {3, 4}}},\n        {4, 3, {{1, 1}, {2, 3}, {3, 2}}},\n        {6, 6, {{1, 2}, {2, 3}, {3, 1}, {3, 4}, {4, 2}, {5, 6}}}\n    };\n\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    int results[num_cases][4];\n\n    for (int i = 0; i < num_cases; ++i) {\n        Graph g;\n        g.n = test_cases[i].n;\n        memset(g.adj, 0, sizeof(g.adj));\n\n        for (int j = 0; j < test_cases[i].num_edges; ++j) {\n            // Map 1-based process IDs to 0-based vertex indices\n            int u = test_cases[i].edges[j][0] - 1;\n            int v = test_cases[i].edges[j][1] - 1;\n            if (u >= 0 && u < g.n && v >= 0 && v < g.n) {\n                g.adj[u][v] = 1;\n            }\n        }\n\n        // s: results[i][0], d: results[i][1], t: results[i][3]\n        find_sccs_and_deadlocks(&g, &results[i][0], &results[i][1], &results[i][3]);\n        // l: results[i][2]\n        results[i][2] = find_shortest_cycle(&g);\n    }\n\n    // Print the results in the EXACT REQUIRED format before the final return statement\n    printf(\"[\");\n    for (int i = 0; i < num_cases; ++i) {\n        printf(\"[%d,%d,%d,%d]\", results[i][0], results[i][1], results[i][2], results[i][3]);\n        if (i < num_cases - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\");\n\n    return EXIT_SUCCESS;\n}\n```"
        }
    ]
}