{
    "hands_on_practices": [
        {
            "introduction": "在解决死锁之前，我们必须首先能够检测到它们。第一个练习聚焦于一种核心算法，适用于每种资源类型都有多个实例的系统。通过基于当前请求和可用资源来模拟分配过程，你将确定哪些进程陷入了死锁状态，从而对基于状态的检测机制获得基础性的理解。",
            "id": "3632410",
            "problem": "考虑一个操作系统（OS），其中有 $n=6$ 个进程 $\\{P_0,P_1,P_2,P_3,P_4,P_5\\}$ 竞争 $m=4$ 种资源类型 $\\{R_1,R_2,R_3,R_4\\}$，每种资源有多个实例。系统状态由资源分配矩阵 $\\mathbf{Allocation} \\in \\mathbb{Z}^{6 \\times 4}$、未完成的请求矩阵 $\\mathbf{Request} \\in \\mathbb{Z}^{6 \\times 4}$ 以及当前可用实例向量 $\\mathbf{Available} \\in \\mathbb{Z}^{4}$ 来表征，具体如下所示。每行对应一个进程 $P_i$，每列对应一种资源类型 $R_j$。\n\n$$\n\\mathbf{Allocation} =\n\\begin{pmatrix}\n1  0  0  1 \\\\\n0  0  1  0 \\\\\n0  2  0  0 \\\\\n1  0  0  0 \\\\\n0  0  1  1 \\\\\n0  1  0  0\n\\end{pmatrix},\n\\quad\n\\mathbf{Request} =\n\\begin{pmatrix}\n0  0  1  0 \\\\\n1  0  0  0 \\\\\n0  1  0  0 \\\\\n0  0  0  0 \\\\\n0  0  0  1 \\\\\n0  1  0  0\n\\end{pmatrix},\n\\quad\n\\mathbf{Available} =\n\\begin{pmatrix}\n1  0  1  0\n\\end{pmatrix}.\n$$\n\n使用经典的多实例资源死锁检测算法，该算法迭代地搜索一个未完成的进程 $P_i$，其请求向量 $Request_i$ 满足 $Request_i \\leq Work$（其中 $Work$ 初始化为 $\\mathbf{Available}$）。当找到这样的进程时，认为 $P_i$ 能够完成并释放其分配的资源，更新 $Work \\leftarrow Work + Allocation_i$。持续此过程，直到不存在这样的 $P_i$ 为止；此时仍未完成的进程被视为不可完成的进程。\n\n定义量 $S$ 为所有不可完成进程的索引之和，即，如果不可完成的进程集合为 $\\{P_{i_1}, P_{i_2}, \\dots\\}$，则 $S = i_1 + i_2 + \\dots$。计算 $S$。请提供一个精确的整数作为最终答案。无需四舍五入。",
            "solution": "该问题经验证具有科学依据、问题明确且客观。它描述了操作系统中的一个标准场景，并要求应用经典的死锁检测算法。所有必要的数据均已提供，问题没有矛盾或含糊之处。\n\n任务是确定在一个有 $n=6$ 个进程和 $m=4$ 种资源类型的系统中不可完成的进程集合。系统状态由 $\\mathbf{Allocation}$ 矩阵、$\\mathbf{Request}$ 矩阵和 $\\mathbf{Available}$ 向量给出。\n\n已知条件如下：\n- 进程数量：$n=6$，$\\{P_0,P_1,P_2,P_3,P_4,P_5\\}$。\n- 资源类型数量：$m=4$，$\\{R_1,R_2,R_3,R_4\\}$。\n- 分配矩阵 $\\mathbf{Allocation} \\in \\mathbb{Z}^{6 \\times 4}$：\n$$\n\\mathbf{Allocation} =\n\\begin{pmatrix}\n1  0  0  1 \\\\\n0  0  1  0 \\\\\n0  2  0  0 \\\\\n1  0  0  0 \\\\\n0  0  1  1 \\\\\n0  1  0  0\n\\end{pmatrix}\n$$\n- 请求矩阵 $\\mathbf{Request} \\in \\mathbb{Z}^{6 \\times 4}$：\n$$\n\\mathbf{Request} =\n\\begin{pmatrix}\n0  0  1  0 \\\\\n1  0  0  0 \\\\\n0  1  0  0 \\\\\n0  0  0  0 \\\\\n0  0  0  1 \\\\\n0  1  0  0\n\\end{pmatrix}\n$$\n- 可用向量 $\\mathbf{Available} \\in \\mathbb{Z}^{4}$：\n$$\n\\mathbf{Available} = \\begin{pmatrix} 1  0  1  0 \\end{pmatrix}\n$$\n\n我们应用死锁检测算法。设 $\\mathbf{Work}$ 为一个长度为 $m$ 的向量，$\\mathbf{Finish}$ 为一个长度为 $n$ 的布尔向量。向量不等式 $\\mathbf{A} \\leq \\mathbf{B}$ 成立当且仅当对于所有分量 $k$ 都有 $A_k \\leq B_k$。\n\n**步骤 1：初始化**\n将 $\\mathbf{Work}$ 初始化为 $\\mathbf{Available}$，并将所有进程 $i = 0, \\dots, 5$ 的 $\\mathbf{Finish}_i$ 初始化为 false。\n$$ \\mathbf{Work} = \\mathbf{Available} = \\begin{pmatrix} 1  0  1  0 \\end{pmatrix} $$\n$$ \\mathbf{Finish} = \\begin{pmatrix} \\text{false}  \\text{false}  \\text{false}  \\text{false}  \\text{false}  \\text{false} \\end{pmatrix} $$\n\n**步骤 2：迭代搜索与更新**\n该算法通过寻找一个索引 $i$ 来进行，该索引满足 $\\mathbf{Finish}_i$ 为 false 且其请求向量 $\\mathbf{Request}_i \\leq \\mathbf{Work}$。如果找到，该进程理论上可以完成，因此我们通过更新 $\\mathbf{Work} \\leftarrow \\mathbf{Work} + \\mathbf{Allocation}_i$ 并设置 $\\mathbf{Finish}_i \\leftarrow \\text{true}$ 来释放其资源。重复此过程，直到找不到这样的进程为止。\n\n**迭代 1：**\n我们搜索一个满足 $\\mathbf{Finish}_i = \\text{false}$ 且 $\\mathbf{Request}_i \\leq \\mathbf{Work} = \\begin{pmatrix} 1  0  1  0 \\end{pmatrix}$ 的进程 $P_i$。\n- $P_0$: $\\mathbf{Request}_0 = \\begin{pmatrix} 0  0  1  0 \\end{pmatrix} \\leq \\begin{pmatrix} 1  0  1  0 \\end{pmatrix}$。此条件满足。\n我们选择 $P_0$。\n更新 $\\mathbf{Work}$：$\\mathbf{Work} \\leftarrow \\mathbf{Work} + \\mathbf{Allocation}_0 = \\begin{pmatrix} 1  0  1  0 \\end{pmatrix} + \\begin{pmatrix} 1  0  0  1 \\end{pmatrix} = \\begin{pmatrix} 2  0  1  1 \\end{pmatrix}$。\n更新 $\\mathbf{Finish}$：$\\mathbf{Finish}_0 \\leftarrow \\text{true}$。\n当前状态为 $\\mathbf{Work} = \\begin{pmatrix} 2  0  1  1 \\end{pmatrix}$ 和 $\\mathbf{Finish} = \\begin{pmatrix} \\text{true}  \\text{false}  \\text{false}  \\text{false}  \\text{false}  \\text{false} \\end{pmatrix}$。\n\n**迭代 2：**\n我们搜索一个满足 $\\mathbf{Request}_i \\leq \\mathbf{Work} = \\begin{pmatrix} 2  0  1  1 \\end{pmatrix}$ 的未完成进程 $P_i$。\n- $P_1$: $\\mathbf{Request}_1 = \\begin{pmatrix} 1  0  0  0 \\end{pmatrix} \\leq \\begin{pmatrix} 2  0  1  1 \\end{pmatrix}$。此条件满足。\n我们选择 $P_1$。\n更新 $\\mathbf{Work}$：$\\mathbf{Work} \\leftarrow \\mathbf{Work} + \\mathbf{Allocation}_1 = \\begin{pmatrix} 2  0  1  1 \\end{pmatrix} + \\begin{pmatrix} 0  0  1  0 \\end{pmatrix} = \\begin{pmatrix} 2  0  2  1 \\end{pmatrix}$。\n更新 $\\mathbf{Finish}$：$\\mathbf{Finish}_1 \\leftarrow \\text{true}$。\n当前状态为 $\\mathbf{Work} = \\begin{pmatrix} 2  0  2  1 \\end{pmatrix}$ 和 $\\mathbf{Finish} = \\begin{pmatrix} \\text{true}  \\text{true}  \\text{false}  \\text{false}  \\text{false}  \\text{false} \\end{pmatrix}$。\n\n**迭代 3：**\n我们搜索一个满足 $\\mathbf{Request}_i \\leq \\mathbf{Work} = \\begin{pmatrix} 2  0  2  1 \\end{pmatrix}$ 的未完成进程 $P_i$。\n- $P_2$: $\\mathbf{Request}_2 = \\begin{pmatrix} 0  1  0  0 \\end{pmatrix}$。这不满足 $\\leq \\mathbf{Work}$，因为对于第二种资源，$1 > 0$。\n- $P_3$: $\\mathbf{Request}_3 = \\begin{pmatrix} 0  0  0  0 \\end{pmatrix} \\leq \\begin{pmatrix} 2  0  2  1 \\end{pmatrix}$。此条件满足。\n我们选择 $P_3$。\n更新 $\\mathbf{Work}$：$\\mathbf{Work} \\leftarrow \\mathbf{Work} + \\mathbf{Allocation}_3 = \\begin{pmatrix} 2  0  2  1 \\end{pmatrix} + \\begin{pmatrix} 1  0  0  0 \\end{pmatrix} = \\begin{pmatrix} 3  0  2  1 \\end{pmatrix}$。\n更新 $\\mathbf{Finish}$：$\\mathbf{Finish}_3 \\leftarrow \\text{true}$。\n当前状态为 $\\mathbf{Work} = \\begin{pmatrix} 3  0  2  1 \\end{pmatrix}$ 和 $\\mathbf{Finish} = \\begin{pmatrix} \\text{true}  \\text{true}  \\text{false}  \\text{true}  \\text{false}  \\text{false} \\end{pmatrix}$。\n\n**迭代 4：**\n我们搜索一个满足 $\\mathbf{Request}_i \\leq \\mathbf{Work} = \\begin{pmatrix} 3  0  2  1 \\end{pmatrix}$ 的未完成进程 $P_i$。\n- $P_2$: $\\mathbf{Request}_2$ 仍然无法满足。\n- $P_4$: $\\mathbf{Request}_4 = \\begin{pmatrix} 0  0  0  1 \\end{pmatrix} \\leq \\begin{pmatrix} 3  0  2  1 \\end{pmatrix}$。此条件满足。\n我们选择 $P_4$。\n更新 $\\mathbf{Work}$：$\\mathbf{Work} \\leftarrow \\mathbf{Work} + \\mathbf{Allocation}_4 = \\begin{pmatrix} 3  0  2  1 \\end{pmatrix} + \\begin{pmatrix} 0  0  1  1 \\end{pmatrix} = \\begin{pmatrix} 3  0  3  2 \\end{pmatrix}$。\n更新 $\\mathbf{Finish}$：$\\mathbf{Finish}_4 \\leftarrow \\text{true}$。\n当前状态为 $\\mathbf{Work} = \\begin{pmatrix} 3  0  3  2 \\end{pmatrix}$ 和 $\\mathbf{Finish} = \\begin{pmatrix} \\text{true}  \\text{true}  \\text{false}  \\text{true}  \\text{true}  \\text{false} \\end{pmatrix}$。\n\n**迭代 5：**\n我们搜索一个满足 $\\mathbf{Request}_i \\leq \\mathbf{Work} = \\begin{pmatrix} 3  0  3  2 \\end{pmatrix}$ 的未完成进程 $P_i$。剩余的未完成进程是 $P_2$ 和 $P_5$。\n- $P_2$: $\\mathbf{Request}_2 = \\begin{pmatrix} 0  1  0  0 \\end{pmatrix}$。这不满足 $\\leq \\mathbf{Work}$，因为对于 $R_2$，$1 > 0$。\n- $P_5$: $\\mathbf{Request}_5 = \\begin{pmatrix} 0  1  0  0 \\end{pmatrix}$。这不满足 $\\leq \\mathbf{Work}$，因为对于 $R_2$，$1 > 0$。\n\n**步骤 3：终止**\n没有剩余的未完成进程的请求可以被当前的 $\\mathbf{Work}$ 向量满足。算法终止。\n\n**步骤 4：识别不可完成的进程并计算 S**\n那些 $\\mathbf{Finish}_i$ 仍然为 false 的进程被认为是不可完成的。从最终的 $\\mathbf{Finish}$ 向量 $\\begin{pmatrix} \\text{true}  \\text{true}  \\text{false}  \\text{true}  \\text{true}  \\text{false} \\end{pmatrix}$ 来看，不可完成的进程是 $\\{P_2, P_5\\}$。\n\n问题将 $S$ 定义为所有不可完成进程的索引之和。\n$$ S = 2 + 5 = 7 $$\n发生死锁的物理原因是 $P_2$ 和 $P_5$ 都在请求资源 $R_2$ 的一个实例。当前没有可用的 $R_2$ 实例（0个），也没有其他能够完成的进程持有任何 $R_2$ 实例可以释放。因此，$P_2$ 和 $P_5$ 将无限期地等待。",
            "answer": "$$\\boxed{7}$$"
        },
        {
            "introduction": "死锁检测不仅仅是一个抽象的操作系统问题，它在许多现实世界的系统中也是一个关键挑战，尤其是在数据库中。这个练习从数值状态分析转向基于图的方法，要求你为数据库事务构建并分析一个等待图（WFG）。你将探索锁类型和升级请求如何创建复杂的依赖关系，并学习一种解决特定类型死锁的实用策略。",
            "id": "3632180",
            "problem": "在一个使用两阶段锁定 (2PL) 的数据库系统中，考虑一个包含事务 $T_1, T_2, T_3, T_4, T_5, T_6$ 和资源 $R_a, R_b, R_c$ 的锁表快照。锁可以是共享 ($S$) 锁或排他 ($X$) 锁，一个事务可以请求将其已持有的某个资源的 $S$ 锁升级为 $X$ 锁。根据 $S$ 和 $X$ 的标准锁兼容性规则：$S$ 与 $S$ 兼容，而 $X$ 与 $S$ 和 $X$ 均不兼容，一个请求当且仅当它与当前持有的锁冲突时才会等待。快照如下。\n\n- 在资源 $R_a$ 上：当前持有者是持有 $S$ 锁的 $T_1$ 和持有 $S$ 锁的 $T_2$。等待队列按顺序为：$T_1$ 请求从 $S$ 升级到 $X$，$T_3$ 请求一个新的 $X$ 锁。\n- 在资源 $R_b$ 上：当前持有者是持有 $S$ 锁的 $T_3$。等待队列按顺序为：$T_2$ 请求 $X$ 锁，然后是 $T_4$ 请求 $X$ 锁。\n- 在资源 $R_c$ 上：当前持有者是持有 $S$ 锁的 $T_4$ 和持有 $S$ 锁的 $T_5$。等待队列按顺序为：$T_4$ 请求从 $S$ 升级到 $X$，然后是 $T_5$ 请求从 $S$ 升级到 $X$，最后是 $T_6$ 请求一个新的 $X$ 锁。\n\n假设没有事务处于其缩减阶段，即，根据两阶段锁定 (2PL) 的规定，在提交或中止之前，不会释放任何已持有的锁。假设事务的开始时间为 $s(T_1)=10$, $s(T_2)=20$, $s(T_3)=15$, $s(T_4)=40$, $s(T_5)=35$, $s(T_6)=50$，其中较小的 $s(\\cdot)$ 值表示事务更早（更老）。\n\n任务：\n1. 使用等待图 (WFG) 的定义，其中当且仅当事务 $T_i$ 当前被事务 $T_j$ 持有的锁阻塞时，才存在一条有向边 $T_i \\to T_j$。请根据上述快照构建 WFG。在此构建过程中，仅考虑与当前已持有锁的冲突（不考虑队列中但未被授予的请求），并将升级请求视为与在同一资源上当前持有不兼容锁的任何其他事务的冲突。\n2. 运行一个简单的死锁检测器，通过寻找强连通分量来发现有向环，从而识别死锁（在 2PL 下的 WFG 中，一个大小至少为 2 的强连通分量表示一个环，因此存在死锁）。\n3. 现在，从基本原理出发，解释当多个事务在同一资源上同时持有 $S$ 锁并都请求升级到 $X$ 锁时，锁升级请求为什么会在 WFG 中引发虚假环。提出一种避免此类虚假环的改进方法，该方法需与 2PL 兼容。具体来说，基于事务开始时间 $s(T_i)$，在单个资源上采用“最老优先”的升级排序：对于同一资源上的并发 $S \\to X$ 升级请求，将任何等待关系从较年轻的升级者指向较年老的升级者，并且当唯一的相互冲突仅源于它们在该资源上的共享锁时，消除这些升级者之间的反向边。\n4. 将第 3 部分的改进方法应用于上述快照，并重新计算 WFG 中大小至少为 2 的强连通分量的数量。\n\n将你的最终答案表示为第 4 部分得到的整数计数。无需四舍五入。最终答案必须是单个实数值。",
            "solution": "该问题要求对数据库系统快照进行死锁分析，首先使用标准的等待图 (WFG) 构建方法，然后使用一种为处理锁升级请求而设计的修改后构建规则。\n\n首先，对给定条件进行验证。问题提供了一组事务 $\\{T_1, T_2, T_3, T_4, T_5, T_6\\}$，一组资源 $\\{R_a, R_b, R_c\\}$，每个资源的持有锁和等待请求的状态，以及每个事务的开始时间 $s(T_i)$。锁兼容性规则（$S$ 与 $S$；$X$ 与无）、WFG 边的创建规则，以及一个处理升级死锁的特定改进方法都得到了明确的定义。该问题在科学上植根于数据库并发控制理论，提法适定、客观且内部一致。因此，它被认为是一个有效的问题。\n\n解决方案按照任务描述分为四个部分进行。\n\n事务的开始时间给出如下：$s(T_1)=10$, $s(T_2)=20$, $s(T_3)=15$, $s(T_4)=40$, $s(T_5)=35$, $s(T_6)=50$。因此，事务的年龄排序（从最老到最年轻）为：$T_1, T_3, T_2, T_5, T_4, T_6$。\n\n### 第 1 部分：构建初始等待图 (WFG)\n\n如果事务 $T_i$ 请求的锁与事务 $T_j$ 当前持有的锁冲突，则向 WFG 添加一条有向边 $T_i \\to T_j$。我们根据提供的快照分析每个资源的冲突情况。\n\n**资源 $R_a$**：\n- 当前状态：$T_1$ 持有 $S$ 锁，$T_2$ 持有 $S$ 锁。\n- 等待请求：\n    1. $T_1$ 请求从 $S$ 升级到 $X$。此请求与 $T_2$ 持有的 $S$ 锁冲突。一个 $X$ 锁与一个 $S$ 锁不兼容。因此，$T_1$ 必须等待 $T_2$。这创建了边 $T_1 \\to T_2$。\n    2. $T_3$ 请求一个 $X$ 锁。此请求与 $T_1$ 和 $T_2$ 持有的 $S$ 锁冲突。因此，$T_3$ 必须同时等待 $T_1$ 和 $T_2$。这创建了边 $T_3 \\to T_1$ 和 $T_3 \\to T_2$。\n\n**资源 $R_b$**：\n- 当前状态：$T_3$ 持有 $S$ 锁。\n- 等待请求：\n    1. $T_2$ 请求一个 $X$ 锁。这与 $T_3$ 持有的 $S$ 锁冲突。因此，$T_2$ 等待 $T_3$。这创建了边 $T_2 \\to T_3$。\n    2. $T_4$ 请求一个 $X$ 锁。这也与 $T_3$ 持有的 $S$ 锁冲突。因此，$T_4$ 等待 $T_3$。这创建了边 $T_4 \\to T_3$。\n\n**资源 $R_c$**：\n- 当前状态：$T_4$ 持有 $S$ 锁，$T_5$ 持有 $S$ 锁。\n- 等待请求：\n    1. $T_4$ 请求从 $S$ 升级到 $X$。这与 $T_5$ 持有的 $S$ 锁冲突。因此，$T_4$ 等待 $T_5$，创建了边 $T_4 \\to T_5$。\n    2. $T_5$ 请求从 $S$ 升级到 $X$。这与 $T_4$ 持有的 $S$ 锁冲突。因此，$T_5$ 等待 $T_4$，创建了边 $T_5 \\to T_4$。\n    3. $T_6$ 请求一个 $X$ 锁。这与 $T_4$ 和 $T_5$ 持有的 $S$ 锁冲突。因此，$T_6$ 同时等待 $T_4$ 和 $T_5$。这创建了边 $T_6 \\to T_4$ 和 $T_6 \\to T_5$。\n\n初始 WFG 中的完整边集合是：\n$E = \\{ (T_1, T_2), (T_3, T_1), (T_3, T_2), (T_2, T_3), (T_4, T_3), (T_4, T_5), (T_5, T_4), (T_6, T_4), (T_6, T_5) \\}$。\n\n### 第 2 部分：在初始 WFG 中检测死锁\n\n死锁由 WFG 中的一个环表示，该环对应于一个大小至少为 2 的强连通分量 (SCC)。我们检查图中是否存在这样的环。\n\n- **环 1**: $T_1 \\to T_2 \\to T_3 \\to T_1$。边 $T_1 \\to T_2$ 来自资源 $R_a$ 上的冲突。边 $T_2 \\to T_3$ 来自资源 $R_b$。边 $T_3 \\to T_1$ 来自资源 $R_a$。这形成了一个涉及三个事务的环。集合 $\\{T_1, T_2, T_3\\}$ 是一个大小为 3 的强连通分量。\n- **环 2**: $T_4 \\to T_5 \\to T_4$。两条边都源于资源 $R_c$ 上的并发升级请求。这是一个经典的转换死锁。集合 $\\{T_4, T_5\\}$ 是一个大小为 2 的强连通分量。\n\n因此，在初始 WFG 中，存在两个死锁。\n\n### 第 3 部分：虚假环的原理及建议的改进方法\n\n问题中提到由锁升级引起的“虚假环”。该术语描述了资源 $R_c$ 上的情况，其中两个事务 $T_4$ 和 $T_5$ 都持有 $S$ 锁，随后都请求升级为 $X$ 锁。$T_4$ 的升级请求被 $T_5$ 持有的 $S$ 锁阻塞（创建了边 $T_4 \\to T_5$），对称地，$T_5$ 的升级请求被 $T_4$ 持有的 $S$ 锁阻塞（创建了边 $T_5 \\to T_4$）。这导致了一个环 $T_4 \\leftrightarrow T_5$。这是一个真实的死锁状态，但它有时被称为“虚假”或“可解决”的死锁，因为它具有一种特殊的结构，可以通过锁管理器中的确定性策略来打破，这与跨越多个资源的更复杂的死锁不同。\n\n建议的改进就是这样一种策略：`最老优先`的升级排序。对于单个资源上的并发升级请求，等待关系是不对称的。相反，优先权被赋予最老的事务。规则规定，等待边应从较年轻的升级者指向较年老的升级者，并且反向边被消除。这打破了对称性，并防止了在 WFG 中形成环。\n\n### 第 4 部分：应用改进方法并最终计数\n\n我们将`最老优先`规则应用于该快照。该规则唯一适用的地方是在资源 $R_c$ 上，其中 $T_4$ 和 $T_5$ 都请求升级。\n- 开始时间为 $s(T_4) = 40$ 和 $s(T_5) = 35$。\n- $T_5$ 比 $T_4$ 更老。\n- 根据规则，较年轻的事务 ($T_4$) 必须等待较年老的事务 ($T_5$) 。这建立了边 $T_4 \\to T_5$。\n- 反向边 $T_5 \\to T_4$（它将表示较老的事务等待较年轻的事务）被消除。\n\n所有其他的等待关系都与第 1 部分中保持一致。新的、改进后的 WFG 具有以下边集：\n$E' = \\{ (T_1, T_2), (T_3, T_1), (T_3, T_2), (T_2, T_3), (T_4, T_3), (T_4, T_5), (T_6, T_4), (T_6, T_5) \\}$。\n这是从原始集合 $E$ 中移除了边 $(T_5, T_4)$ 之后的结果。\n\n现在我们在这个修改后的图中找到大小 $\\ge 2$ 的强连通分量：\n- 环 $T_1 \\to T_2 \\to T_3 \\to T_1$ 完全不受此更改的影响，因为它涉及不同的事务和资源。因此，$\\{T_1, T_2, T_3\\}$ 仍然是一个大小为 3 的强连通分量。这对应一个死锁。\n- 环 $T_4 \\to T_5 \\to T_4$ 因移除了边 $T_5 \\to T_4$ 而被打破。现在只有一条从 $T_4$ 到 $T_5$ 的路径，但没有从 $T_5$ 返回到 $T_4$ 的路径。节点 $\\{T_4, T_5, T_6\\}$ 不构成任何其他环，也不属于任何其他环。由这些节点导出的子图是一个有向无环图 (DAG)。\n- 因此，在修改后的 WFG 中，唯一大小 $\\ge 2$ 的强连通分量是 $\\{T_1, T_2, T_3\\}$。\n\n在改进后的 WFG 中，大小至少为 2 的强连通分量的数量是 1。",
            "answer": "$$\\boxed{1}$$"
        },
        {
            "introduction": "检测到死锁只是成功了一半；系统还必须从中恢复。最后一个练习探讨了一种最常见的恢复技术：进程抢占。你的任务是分析一个复杂的等待图，识别所有死锁循环，并确定为打破所有循环所需终止的“牺牲”进程的最小数量。这个练习突出了死锁恢复中所涉及的策略权衡。",
            "id": "3632133",
            "problem": "一个操作系统使用资源分配图 (RAG) 及其派生的等待图 (WFG) 来监控系统中资源分配的快照。在单实例资源模型和逻辑“与”请求语义下，当且仅当进程 $P_{i}$ 当前被阻塞，并且正在请求至少一个由进程 $P_{j}$ 持有的资源时，等待图 (WFG) 中才会出现一条从 $P_{i}$ 到 $P_{j}$ 的边。当且仅当 WFG 包含至少一个有向环时，系统中存在死锁。系统可以通过资源抢占来进行恢复：抢占一个进程 $P_{v}$ 会立即释放 $P_{v}$ 持有的所有资源，并将 $P_{v}$ 及其所有关联边从 WFG 中移除。\n\n考虑以下包含 $7$ 个进程 $\\{P_{1},P_{2},P_{3},P_{4},P_{5},P_{6},P_{7}\\}$ 和 $8$ 个单实例资源 $\\{R_{1},R_{2},R_{3},R_{4},R_{5},R_{6},R_{8}\\}$ 的科学上合理的快照（注意资源标识符不必是连续的）：\n\n- 当前持有情况（每个资源恰好由一个进程持有）：\n  - $R_{3}$ 由 $P_{1}$ 持有。\n  - $R_{1}$ 由 $P_{2}$ 持有。\n  - $R_{2}$ 由 $P_{3}$ 持有。\n  - $R_{4}$ 由 $P_{4}$ 持有。\n  - $R_{5}$ 由 $P_{5}$ 持有。\n  - $R_{6}$ 由 $P_{6}$ 持有。\n  - $R_{8}$ 由 $P_{7}$ 持有。\n\n- 当前待处理请求（每个条目表示一个被阻塞的进程，该进程同时请求所有列出的资源，而这些资源当前分别由上述持有者持有）：\n  - $P_{1}$ 请求 $\\{R_{1}\\}$。\n  - $P_{2}$ 请求 $\\{R_{2},R_{5}\\}$。\n  - $P_{3}$ 请求 $\\{R_{3},R_{4}\\}$。\n  - $P_{4}$ 请求 $\\{R_{5},R_{8}\\}$。\n  - $P_{5}$ 请求 $\\{R_{2},R_{6}\\}$。\n  - $P_{6}$ 请求 $\\{R_{1}\\}$。\n  - $P_{7}$ 请求 $\\{R_{4}\\}$。\n\n仅使用上述基本定义：\n- 对于 $P_{i}$ 请求的每个当前由 $P_{j}$ 持有的资源，构造一条有向边 $P_{i} \\to P_{j}$，从而构建等待图。\n- 通过识别 WFG 中的有向环来推断死锁。\n- 在所述的抢占模型下，将死锁恢复解释为选择一个进程集合（牺牲者），抢占这些进程可以破坏 WFG 中的所有有向环。\n\n确定为使最终的 WFG 成为无环图所必须抢占的进程的最小可能数量。以单个整数形式报告您的答案。无需四舍五入，也无需单位。最终答案必须是单个实数值。",
            "solution": "该问题提供了一个包含多个进程和单实例资源的系统快照，并要求为解决所有死锁而需要抢占的最小进程数。该问题基于操作系统和图论的标准原理，科学上成立、定义明确且客观。因此，这是一个有效的问题。\n\n解决方案分三步进行：\n1.  根据给定的进程持有和请求情况构建等待图 (WFG)。\n2.  识别 WFG 中的所有有向环，因为环表示存在死锁。\n3.  确定移除后能破坏所有环的最小顶点（进程）集合。这等同于寻找 WFG 的最小反馈顶点集。\n\n**步骤 1：构建等待图 (WFG)**\n\nWFG 的顶点是进程集合 $V = \\{P_{1}, P_{2}, P_{3}, P_{4}, P_{5}, P_{6}, P_{7}\\}$。\n如果进程 $P_{i}$ 请求一个由进程 $P_{j}$ 持有的资源，则存在一条有向边 $P_{i} \\to P_{j}$。我们分析给定的请求来确定图的边集 $E$。\n\n-   进程 $P_{1}$ 请求 $\\{R_{1}\\}$。资源 $R_{1}$ 由 $P_{2}$ 持有。这产生一条边 $P_{1} \\to P_{2}$。\n-   进程 $P_{2}$ 请求 $\\{R_{2}, R_{5}\\}$。资源 $R_{2}$ 由 $P_{3}$ 持有，而 $R_{5}$ 由 $P_{5}$ 持有。这产生边 $P_{2} \\to P_{3}$ 和 $P_{2} \\to P_{5}$。\n-   进程 $P_{3}$ 请求 $\\{R_{3}, R_{4}\\}$。资源 $R_{3}$ 由 $P_{1}$ 持有，而 $R_{4}$ 由 $P_{4}$ 持有。这产生边 $P_{3} \\to P_{1}$ 和 $P_{3} \\to P_{4}$。\n-   进程 $P_{4}$ 请求 $\\{R_{5}, R_{8}\\}$。资源 $R_{5}$ 由 $P_{5}$ 持有，而 $R_{8}$ 由 $P_{7}$ 持有。这产生边 $P_{4} \\to P_{5}$ 和 $P_{4} \\to P_{7}$。\n-   进程 $P_{5}$ 请求 $\\{R_{2}, R_{6}\\}$。资源 $R_{2}$ 由 $P_{3}$ 持有，而 $R_{6}$ 由 $P_{6}$ 持有。这产生边 $P_{5} \\to P_{3}$ 和 $P_{5} \\to P_{6}$。\n-   进程 $P_{6}$ 请求 $\\{R_{1}\\}$。资源 $R_{1}$ 由 $P_{2}$ 持有。这产生一条边 $P_{6} \\to P_{2}$。\n-   进程 $P_{7}$ 请求 $\\{R_{4}\\}$。资源 $R_{4}$ 由 $P_{4}$ 持有。这产生一条边 $P_{7} \\to P_{4}$。\n\nWFG 中完整的边集为：\n$E = \\{ (P_{1}, P_{2}), (P_{2}, P_{3}), (P_{2}, P_{5}), (P_{3}, P_{1}), (P_{3}, P_{4}), (P_{4}, P_{5}), (P_{4}, P_{7}), (P_{5}, P_{3}), (P_{5}, P_{6}), (P_{6}, P_{2}), (P_{7}, P_{4}) \\}$。\n\n**步骤 2：识别有向环**\n\n当且仅当 WFG 中存在至少一个有向环时，死锁存在。通过检查由 $V$ 和 $E$ 定义的图，我们可以识别出以下基本环：\n\n1.  $C_{1}: P_{1} \\to P_{2} \\to P_{3} \\to P_{1}$。此环涉及进程 $\\{P_{1}, P_{2}, P_{3}\\}$。\n2.  $C_{2}: P_{2} \\to P_{5} \\to P_{3} \\to P_{1} \\to P_{2}$。此环涉及进程 $\\{P_{1}, P_{2}, P_{3}, P_{5}\\}$。\n3.  $C_{3}: P_{2} \\to P_{5} \\to P_{6} \\to P_{2}$。此环涉及进程 $\\{P_{2}, P_{5}, P_{6}\\}$。\n4.  $C_{4}: P_{4} \\to P_{7} \\to P_{4}$。此环涉及进程 $\\{P_{4}, P_{7}\\}$。\n5.  $C_{5}: P_{3} \\to P_{4} \\to P_{5} \\to P_{3}$。此环涉及进程 $\\{P_{3}, P_{4}, P_{5}\\}$。\n\n由于存在多个环，系统处于死锁状态。所有 $7$ 个进程都至少是一个环的一部分。\n\n**步骤 3：确定最小抢占数**\n\n为了从死锁中恢复，我们必须抢占一组进程（牺牲者），使得将它们从 WFG 中移除可以消除所有有向环。这就是最小反馈顶点集问题。对于这种规模的图，我们可以通过直接分析来确定最小数量。\n\n首先，我们检查抢占单个进程是否足够。\n-   抢占 $P_{1}$：破坏环 $C_{1}$ 和 $C_{2}$。环 $C_{3}$、$C_{4}$ 和 $C_{5}$ 仍然存在。\n-   抢占 $P_{2}$：破坏环 $C_{1}$、$C_{2}$ 和 $C_{3}$。环 $C_{4}$ 和 $C_{5}$ 仍然存在。\n-   抢占 $P_{3}$：破坏环 $C_{1}$、$C_{2}$ 和 $C_{5}$。环 $C_{3}$ 和 $C_{4}$ 仍然存在。\n-   抢占 $P_{4}$：破坏环 $C_{4}$ 和 $C_{5}$。环 $C_{1}$、$C_{2}$ 和 $C_{3}$ 仍然存在。\n-   抢占 $P_{5}$：破坏环 $C_{2}$、$C_{3}$ 和 $C_{5}$。环 $C_{1}$ 和 $C_{4}$ 仍然存在。\n-   抢占 $P_{6}$：仅破坏环 $C_{3}$。\n-   抢占 $P_{7}$：仅破坏环 $C_{4}$。\n\n由于没有任何单个抢占可以破坏所有环，因此最小牺牲者数量必须大于 $1$。\n\n接下来，我们检查抢占两个进程是否足够。我们需要找到一对进程 $\\{P_{i}, P_{j}\\}$，它们共同是每个环的一部分。\n让我们分析每个进程参与的环：\n-   $P_{1}$：在 $\\{C_{1}, C_{2}\\}$ 中\n-   $P_{2}$：在 $\\{C_{1}, C_{2}, C_{3}\\}$ 中\n-   $P_{3}$：在 $\\{C_{1}, C_{2}, C_{5}\\}$ 中\n-   $P_{4}$：在 $\\{C_{4}, C_{5}\\}$ 中\n-   $P_{5}$：在 $\\{C_{2}, C_{3}, C_{5}\\}$ 中\n-   $P_{6}$：在 $\\{C_{3}\\}$ 中\n-   $P_{7}$：在 $\\{C_{4}\\}$ 中\n\n考虑牺牲者集合 $\\{P_{2}, P_{4}\\}$。\n-   抢占 $P_{2}$ 破坏环 $C_{1}$、$C_{2}$ 和 $C_{3}$。\n-   剩下需要破坏的环是 $C_{4}$ 和 $C_{5}$。\n-   抢占 $P_{4}$ 破坏了环 $C_{4}$ 和 $C_{5}$。\n\n因此，抢占进程集合 $\\{P_{2}, P_{4}\\}$ 足以破坏 WFG 中的所有环。\n由于抢占 $1$ 个进程不足以解决问题，而抢占 $2$ 个进程足够，因此必须抢占的进程的最小可能数量是 $2$。",
            "answer": "$$\\boxed{2}$$"
        }
    ]
}