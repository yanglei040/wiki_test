{
    "hands_on_practices": [
        {
            "introduction": "死锁预防是一种主动策略，旨在通过破坏其四个必要条件之一来从结构上消除死锁的可能性。其中，最实用的方法之一是打破“循环等待”条件。 这个练习将此理论转化为一个实际的优化问题，要求您在遵循单一资源全序以防止死锁的同时，找到一个能最小化对进程原有请求顺序干扰的方案。这不仅能加深您对死锁预防机制的理解，还能锻炼您在满足系统约束的同时进行工程优化的能力。",
            "id": "3658940",
            "problem": "一个操作系统调度三个并发进程 $\\{P_1, P_2, P_3\\}$，每个进程都会获取不可抢占资源集 $\\{A, B, C, D\\}$ 的一个子集。当且仅当等待图中存在环时，可能发生死锁。预防死锁的一种经过充分检验的方法是，对资源施加一个严格全序，并要求每个进程都以相对于该全序单调不减的顺序请求资源。这通过确保不存在有向环来消除循环等待。\n\n每个进程都有一个原始的偏好获取序列（即它将要获取的资源的线性顺序，无重复）：\n- $P_1$: $A \\rightarrow B \\rightarrow C$\n- $P_2$: $B \\rightarrow D \\rightarrow A$\n- $P_3$: $C \\rightarrow A \\rightarrow D$\n\n您必须将此问题建模为一个约束满足问题，其中的决策变量是操作系统将强制执行的每个进程的资源获取顺序。约束必须确保强制执行的顺序相对于 $\\{A, B, C, D\\}$ 上的某个单一严格全序是单调不减的，从而使等待图是无环的。强制执行的顺序与进程原始序列的偏差，由将原始序列转换为强制执行序列所需的相邻交换次数来衡量（这就是局限于该进程序列中资源的肯德尔tau距离）。总偏差是 $P_1, P_2, P_3$ 各自偏差距离的总和。\n\n在所有遵守单一严格资源全序（从而预防死锁）的满足条件的获取顺序分配中，确定最小的可能总偏差。以单个整数形式报告您的答案。无需四舍五入。",
            "solution": "问题要求计算三个进程的原始偏好资源获取序列与强制执行序列之间的最小可能总偏差，其约束条件是所有强制执行的序列必须符合资源集 $\\{A, B, C, D\\}$ 上的单一严格全序。这个约束是预防死锁的标准方法。\n\n设资源集为 $R = \\{A, B, C, D\\}$。$R$ 上的一个严格全序是这四个资源的一个排列 $\\pi$。共有 $4! = 24$ 种可能的顺序。对于任何给定的全序 $\\pi$，每个进程 $P_i$ 必须以 $\\pi$ 的一个子序列的顺序获取其所需资源。这就为每个进程确定了一个唯一的强制获取序列。\n\n设 $S_1, S_2, S_3$ 是原始偏好获取序列：\n- $S_1: A \\rightarrow B \\rightarrow C$\n- $S_2: B \\rightarrow D \\rightarrow A$\n- $S_3: C \\rightarrow A \\rightarrow D$\n\n设 $\\pi$ 是 $R$ 上的一个选定的严格全序。对于每个进程 $P_i$，设 $R_i \\subseteq R$ 是它所使用的资源集。$P_i$ 的强制序列，记为 $S_i'(\\pi)$，是通过根据 $\\pi$ 对 $R_i$ 中的资源进行排序而得到的排列。\n\n单个进程 $P_i$ 的偏差定义为将原始序列 $S_i$ 转换为强制序列 $S_i'(\\pi)$ 所需的相邻交换次数。这等价于资源集 $R_i$ 的这两个排列之间的逆序对数量，或者说肯德尔tau距离。该距离是在 $S_i$ 和 $S_i'(\\pi)$ 中相对顺序不同的资源对的数量。\n\n对于给定的全序 $\\pi$，总偏差是每个进程偏差的总和：\n$$ D(\\pi) = \\sum_{i=1}^{3} d_K(S_i, S_i'(\\pi)) $$\n其中 $d_K$ 表示肯德尔tau距离。\n\n目标是找到 $\\min_{\\pi} D(\\pi)$。\n\n总偏差可以通过考虑每一对资源 $\\{X, Y\\} \\subseteq R$ 来分解。总偏差是所有三个进程中所有资源对上的不一致性之和。\n$$ D(\\pi) = \\sum_{\\{X, Y\\} \\subseteq R, X \\neq Y} \\text{cost}(\\{X, Y\\}|\\pi) $$\n对于给定的全序 $\\pi$，单对资源 $\\{X, Y\\}$ 的成本是其原始请求顺序被 $\\pi$ 颠倒的进程数量。\n设 $N(X \\prec Y)$ 是在原始序列 $S_i$ 中 $X$ 在 $Y$ 之前被请求的进程 $P_i$ 的数量。如果全序指定了 $X \\prec_{\\pi} Y$，那么这对资源贡献的成本是 $N(Y \\prec X)$。反之，如果 $Y \\prec_{\\pi} X$，成本则是 $N(X \\prec Y)$。\n因此，资源对 $\\{X, Y\\}$ 的最小可能成本是 $\\min(N(X \\prec Y), N(Y \\prec X))$。\n\n最小总偏差是这些最小配对成本的总和，前提是实现这些最小值的两两排序集合是一致的（即具有传递性且不包含环）。如果这些偏好是一致的，那么就存在一个遵守所有这些偏好的全序 $\\pi$。\n\n让我们根据原始序列计算所有 $\\binom{4}{2} = 6$ 对资源的数量 $N(X \\prec Y)$：\n- $S_1 = (A, B, C)$: 给出偏好 $A \\prec B$, $A \\prec C$, $B \\prec C$。\n- $S_2 = (B, D, A)$: 给出偏好 $B \\prec D$, $B \\prec A$, $D \\prec A$。\n- $S_3 = (C, A, D)$: 给出偏好 $C \\prec A$, $C \\prec D$, $A \\prec D$。\n\n现在，我们列表计算数量并确定每对资源的最小成本：\n\n1.  **对 {A, B}**:\n    - $P_1$ 偏好 $A \\prec B$。\n    - $P_2$ 偏好 $B \\prec A$。\n    - $P_3$ 不使用 $B$。\n    - 因此，$N(A \\prec B) = 1$ 且 $N(B \\prec A) = 1$。\n    - {A, B} 的最小成本为 $\\min(1, 1) = 1$。无论我们选择 $A \\prec_{\\pi} B$ 还是 $B \\prec_{\\pi} A$，这个成本都无法避免。\n\n2.  **对 {A, C}**:\n    - $P_1$ 偏好 $A \\prec C$。\n    - $P_3$ 偏好 $C \\prec A$。\n    - $P_2$ 不使用 $C$。\n    - 因此，$N(A \\prec C) = 1$ 且 $N(C \\prec A) = 1$。\n    - {A, C} 的最小成本为 $\\min(1, 1) = 1$。这个成本是不可避免的。\n\n3.  **对 {A, D}**:\n    - $P_3$ 偏好 $A \\prec D$。\n    - $P_2$ 偏好 $D \\prec A$。\n    - $P_1$ 不使用 $D$。\n    - 因此，$N(A \\prec D) = 1$ 且 $N(D \\prec A) = 1$。\n    - {A, D} 的最小成本为 $\\min(1, 1) = 1$。这个成本是不可避免的。\n\n4.  **对 {B, C}**:\n    - $P_1$ 偏好 $B \\prec C$。\n    - $P_2$ 不使用 $C$。$P_3$ 不使用 $B$。\n    - 因此，$N(B \\prec C) = 1$ 且 $N(C \\prec B) = 0$。\n    - {B, C} 的最小成本为 $\\min(1, 0) = 0$。这个最小值通过选择顺序 $B \\prec_{\\pi} C$ 来实现。\n\n5.  **对 {B, D}**:\n    - $P_2$ 偏好 $B \\prec D$。\n    - $P_1$ 不使用 $D$。$P_3$ 不使用 $B$。\n    - 因此，$N(B \\prec D) = 1$ 且 $N(D \\prec B) = 0$。\n    - {B, D} 的最小成本为 $\\min(1, 0) = 0$。这个最小值通过选择顺序 $B \\prec_{\\pi} D$ 来实现。\n\n6.  **对 {C, D}**:\n    - $P_3$ 偏好 $C \\prec D$。\n    - $P_1$ 不使用 $D$。$P_2$ 不使用 $C$。\n    - 因此，$N(C \\prec D) = 1$ 且 $N(D \\prec C) = 0$。\n    - {C, D} 的最小成本为 $\\min(1, 0) = 0$。这个最小值通过选择顺序 $C \\prec_{\\pi} D$ 来实现。\n\n为实现整体最小总偏差，我们必须选择能产生最小成本的两两排序。这要求我们的全序 $\\pi$ 满足：\n- $B \\prec_{\\pi} C$\n- $B \\prec_{\\pi} D$\n- $C \\prec_{\\pi} D$\n\n让我们检查这些约束是否一致。约束 $B \\prec_{\\pi} C$ 和 $C \\prec_{\\pi} D$ 通过传递性可推导出 $B \\prec_{\\pi} D$。这与第三个约束是一致的。因此，这些偏好顺序中没有环。我们可以构建一个满足所有三个约束的全序 $\\pi$，例如，任何 $B, C, D$ 的相对顺序为 $B \\rightarrow C \\rightarrow D$ 的排序。一个例子是 $\\pi = (A, B, C, D)$。\n\n最小总偏差是每对资源最小成本的总和：\n$$ D_{min} = \\underbrace{1}_{\\{A,B\\}} + \\underbrace{1}_{\\{A,C\\}} + \\underbrace{1}_{\\{A,D\\}} + \\underbrace{0}_{\\{B,C\\}} + \\underbrace{0}_{\\{B,D\\}} + \\underbrace{0}_{\\{C,D\\}} = 3 $$\n\n让我们用一个满足条件的特定全序来验证这一点，例如 $\\pi = (B, A, C, D)$。这个顺序满足 $B \\prec C$、 $B \\prec D$ 以及 $C \\prec D$。\n- $P_1$ (使用 $\\{A,B,C\\}$)，原始序列 $A \\rightarrow B \\rightarrow C$。强制序列 $S_1'(\\pi): B \\rightarrow A \\rightarrow C$。\n  - 资源对 $(A,B)$, $(A,C)$, $(B,C)$：原始序列中有 $A \\prec B$。强制序列中有 $B \\prec A$。$1$ 个逆序对。偏差 = $1$。\n- $P_2$ (使用 $\\{A,B,D\\}$)，原始序列 $B \\rightarrow D \\rightarrow A$。强制序列 $S_2'(\\pi): B \\rightarrow A \\rightarrow D$。\n  - 资源对 $(B,D)$, $(B,A)$, $(D,A)$：原始序列中有 $D \\prec A$。强制序列中有 $A \\prec D$。$1$ 个逆序对。偏差 = $1$。\n- $P_3$ (使用 $\\{A,C,D\\}$)，原始序列 $C \\rightarrow A \\rightarrow D$。强制序列 $S_3'(\\pi): A \\rightarrow C \\rightarrow D$。\n  - 资源对 $(C,A)$, $(C,D)$, $(A,D)$：原始序列中有 $C \\prec A$。强制序列中有 $A \\prec C$。$1$ 个逆序对。偏差 = $1$。\n总偏差为 $1 + 1 + 1 = 3$。\n\n分析证实，最小可能总偏差为 $3$。任何资源 $B,C,D$ 以 $B \\rightarrow C \\rightarrow D$ 序列出现的全序 $\\pi$ 都会产生这个最小偏差。",
            "answer": "$$\\boxed{3}$$"
        },
        {
            "introduction": "与严格的预防策略相比，死锁避免是一种更为动态和灵活的方法。它不完全禁止可能导致问题的资源请求模式，而是通过预先分析每个请求的安全性来“绕开”死锁。 这个练习将带您亲手实践著名的银行家算法，这是一个经典的死锁避免算法。通过模拟安全性检查的核心过程，您需要确定一个系统状态保持“安全”的临界条件，从而深刻理解安全状态与不安全状态的本质区别，以及操作系统如何做出决策以确保系统永远不会进入死锁。",
            "id": "3658926",
            "problem": "在一个保守资源分配的哲学家就餐问题变体中，所有的叉子被视为一个单一的相同资源池。现有 $n=4$ 位哲学家 $\\{P_1,P_2,P_3,P_4\\}$ 和一个包含 $F=9$ 把相同叉子的资源池。每位哲学家 $P_i$ 声明其最大需求量为 $M_i$ 把叉子，但要完成一餐，一位哲学家一次最多需要 2 把叉子。然而，操作系统通过银行家算法来确保安全性，该算法必须保守地假设每个 $P_i$ 在释放任何叉子之前，可能会请求其声明的最大数量 $M_i$。因此，安全性检查是根据声明的最大需求量进行的。\n\n当前的分配向量（当前持有的叉子数）为 $A=(2,2,2,1)$，声明的最大需求向量为 $M=(5,6,5,x)$，其中 $x$ 是一个正整数，并且必须满足 $1 \\le x \\le F$ 才是一个有效的声明。系统状态由 $(F,M,A)$ 表示，如果存在一个哲学家的序列，从当前可用的叉子开始，每个哲学家都可以被分配其剩余的声明需求，然后完成任务（释放其所有已分配的叉子），并且在任何步骤中都不会超过可用叉子的数量，那么该状态就被认为是安全的。\n\n仅从死锁的核心定义和银行家算法的安全性测试出发（不假设任何专门的捷径），确定使当前状态 $(F,M,A)$ 在银行家算法下为安全状态的最大整数值 $x$。请以单个整数的形式提供你的最终答案。",
            "solution": "该问题要求根据银行家算法，确定一个变量 $x$ 的最大整数值，使得资源分配系统保持在安全状态。一个状态被定义为安全的，如果存在一个进程（在这里是哲学家）序列，使得所有进程都能完成它们的执行。\n\n首先，我们根据所提供的数据来形式化系统状态。\n进程（哲学家）的数量为 $n=4$。\n相同资源（叉子）的总数为 $F=9$。\n\n系统状态由三个向量定义：\n1.  每个哲学家声明的最大资源需求量，$M$。\n2.  当前分配给每个哲学家的资源量，$A$。\n3.  系统中可用资源的数量，$V$。\n\n已知条件是：\n最大需求向量为 $M = (M_1, M_2, M_3, M_4) = (5, 6, 5, x)$。\n当前分配向量为 $A = (A_1, A_2, A_3, A_4) = (2, 2, 2, 1)$。\n\n由此，我们可以计算出已分配资源的总数：\n$$ \\sum_{i=1}^{n} A_i = 2 + 2 + 2 + 1 = 7 $$\n当前可用资源的数量 $V$，是总资源数减去已分配资源的总数：\n$$ V = F - \\sum_{i=1}^{n} A_i = 9 - 7 = 2 $$\n\n接下来，我们计算 `Need` 向量 $N$。每个哲学家 $P_i$ 的 `Need` 是它为完成任务可能请求的额外资源的最大数量。它被计算为其最大需求量与当前分配量之差：$N_i = M_i - A_i$。\n$$ N = M - A = (5-2, 6-2, 5-2, x-1) = (3, 4, 3, x-1) $$\n\n安全性算法用于确定当前状态是否安全。该算法的工作流程如下：\n1.  初始化一个 `Work` 向量（在本例中，由于只有一种资源类型，它是一个标量）为 `Available` 资源的数量。设 $W = V = 2$。\n2.  初始化一个长度为 $n$ 的布尔向量 `Finish`，所有元素都设置为 `false`。$Finish = (\\text{false}, \\text{false}, \\text{false}, \\text{false})$。\n3.  寻找一个哲学家 $P_i$，使其同时满足以下两个条件：\n    a. $Finish_i$ 为 `false`。\n    b. $N_i \\le W$。\n4.  如果存在这样的哲学家 $P_i$，我们假设它可以完成任务。我们通过虚拟地释放其资源来更新状态：\n    a. $W \\leftarrow W + A_i$。\n    b. $Finish_i \\leftarrow \\text{true}$。\n    c. 返回步骤 3。\n5.  如果在步骤 3 中找不到这样的哲学家，算法终止。\n6.  当且仅当算法终止时 `Finish` 向量的所有元素都为 `true`，初始状态才被认为是安全的。\n\n现在我们将此算法应用于给定的系统状态，以找出对 $x$ 的约束。\n安全性检查的初始状态：\n$W = 2$\n$N = (3, 4, 3, x-1)$\n$A = (2, 2, 2, 1)$\n$Finish = (\\text{false}, \\text{false}, \\text{false}, \\text{false})$\n\n在步骤 3 的第一轮中，我们寻找一个哲学家 $P_i$，满足 $N_i \\le W = 2$ 且 $Finish_i$ 为 `false`。\n- 对于 $P_1$：$N_1 = 3$。$3 \\le 2$ 吗？否。\n- 对于 $P_2$：$N_2 = 4$。$4 \\le 2$ 吗？否。\n- 对于 $P_3$：$N_3 = 3$。$3 \\le 2$ 吗？否。\n- 对于 $P_4$：$N_4 = x-1$。我们需要检查是否 $x-1 \\le 2$。\n\n为了使安全性算法能够进行到第一步之后，必须至少有一个哲学家能够被当前可用的资源满足。根据以上分析，哲学家 $P_1$、$P_2$ 和 $P_3$ 都不能被选择。因此，只有当哲学家 $P_4$ 可以被选择时，算法才能开始。这对 $x$ 施加了一个必要条件：\n$$ N_4 \\le W \\implies x-1 \\le 2 \\implies x \\le 3 $$\n问题说明 $x$ 是一个正整数，所以 $x \\ge 1$。这意味着任何 $x > 3$ 的值都会导致不安全状态，因为安全性算法将在第一步就停止，没有任何进程能够继续执行。\n\n为了找到使状态安全的最大整数值 $x$，我们必须测试可能的最大值 $x=3$。如果 $x=3$ 能够得到一个安全状态，那它就是我们的答案。\n\n让我们测试 $x=3$ 的情况：\n`Need` 向量变为 $N = (3, 4, 3, 3-1) = (3, 4, 3, 2)$。\n初始状态：$W=2$，$Finish=(\\text{false}, \\text{false}, \\text{false}, \\text{false})$。\n\n- **第一轮：** 我们寻找 $N_i \\le W=2$ 的 $P_i$。如前所述，只有 $N_4=2$ 的 $P_4$ 满足此条件。我们选择 $P_4$。\n  - 更新 $W \\leftarrow W + A_4 = 2 + 1 = 3$。\n  - 更新 $Finish \\leftarrow (\\text{false}, \\text{false}, \\text{false}, \\text{true})$。\n  - 一个可能安全序列以 $\\langle P_4 \\rangle$ 开始。\n\n- **第二轮：** 我们寻找 $Finish_i=\\text{false}$ 且 $N_i \\le W=3$ 的 $P_i$。\n  - 对于 $P_1$：$N_1 = 3$。$3 \\le 3$ 吗？是。\n  - 对于 $P_2$：$N_2 = 4$。$4 \\le 3$ 吗？否。\n  - 对于 $P_3$：$N_3 = 3$。$3 \\le 3$ 吗？是。\n  - 我们可以选择 $P_1$ 或 $P_3$。让我们选择 $P_1$。\n  - 更新 $W \\leftarrow W + A_1 = 3 + 2 = 5$。\n  - 更新 $Finish \\leftarrow (\\text{true}, \\text{false}, \\text{false}, \\text{true})$。\n  - 序列现在是 $\\langle P_4, P_1 \\rangle$。\n\n- **第三轮：** 我们寻找 $Finish_i=\\text{false}$ 且 $N_i \\le W=5$ 的 $P_i$。\n  - 对于 $P_2$：$N_2 = 4$。$4 \\le 5$ 吗？是。\n  - 对于 $P_3$：$N_3 = 3$。$3 \\le 5$ 吗？是。\n  - 我们可以选择 $P_2$ 或 $P_3$。让我们选择 $P_3$。\n  - 更新 $W \\leftarrow W + A_3 = 5 + 2 = 7$。\n  - 更新 $Finish \\leftarrow (\\text{true}, \\text{false}, \\text{true}, \\text{true})$。\n  - 序列现在是 $\\langle P_4, P_1, P_3 \\rangle$。\n\n- **第四轮：** 我们寻找 $Finish_i=\\text{false}$ 且 $N_i \\le W=7$ 的 $P_i$。\n  - 只剩下 $P_2$。$N_2=4$。$4 \\le 7$ 吗？是。\n  - 我们选择 $P_2$。\n  - 更新 $W \\leftarrow W + A_2 = 7 + 2 = 9$。\n  - 更新 $Finish \\leftarrow (\\text{true}, \\text{true}, \\text{true}, \\text{true})$。\n  - 序列现在是 $\\langle P_4, P_1, P_3, P_2 \\rangle$。\n\n- **第五轮：** `Finish` 向量的所有元素现在都为 `true`。算法成功终止。\n\n由于对于 $x=3$ 存在一个安全序列 $\\langle P_4, P_1, P_3, P_2 \\rangle$，因此该状态在此值下是安全的。我们已经确定，对于任何整数 $x>3$，状态都是不安全的。因此，使状态安全的最大整数值 $x$ 是 $3$。",
            "answer": "$$\\boxed{3}$$"
        },
        {
            "introduction": "在许多系统中，预防和避免策略的开销可能过高或过于严格。因此，另一种常见的方法是允许死锁发生，然后通过检测和恢复机制来处理它们。 本练习探讨了死锁发生时的实际后果，例如自旋锁（spinlock）导致的 CPU 资源浪费，并引入了检测死锁的标准方法：构建等待图（Wait-For Graph, WFG）并检测其中的循环。通过分析不同锁类型在死锁情境下的表现，您将学会如何运用等待图这一形式化工具来准确诊断死锁，并理解为何它优于基于超时的启发式方法。",
            "id": "3658954",
            "problem": "考虑一个运行在拥有 $m=2$ 个核心的对称多处理系统上的操作系统 (OS)。该操作系统提供两种锁：自旋锁和睡眠锁。自旋锁使线程在一个循环中忙等待，使用原子操作重复测试一个共享变量，直到锁变为可用；睡眠锁使线程阻塞并让出中央处理器 (CPU)，让调度器运行其他线程。两个线程 $T_1$ 和 $T_2$ 按如下方式竞争两个自旋锁 $L_1$ 和 $L_2$：线程 $T_1$ 获取 $L_1$ 然后尝试获取 $L_2$，而线程 $T_2$ 获取 $L_2$ 然后尝试获取 $L_1$。在等待第二个锁时，两个线程都不会释放它们持有的第一个锁。系统支持追踪锁的所有权和等待者。目标是从死锁和资源等待的基本定义出发，分析死锁情况下因自旋造成的CPU浪费，并提出一种可以在自旋循环内部调用的、有原则的死锁检测方法。\n\n基本定义：当一个非空线程集合中的每个线程都在等待一个只有该集合中其他线程才能引发的事件时，就存在死锁，这在锁的上下文中对应于等待图 (WFG) 中的循环。发生死锁的Coffman条件是：互斥、持有并等待、不可抢占和循环等待。吞吐量是单位时间内完成的临界区速率；当一个线程自旋时，即使它在其临界区上没有取得进展，它仍然消耗CPU周期。\n\n在这种情况下，以下哪些陈述是正确的？\n\nA. 在有 $m=2$ 个核心的情况下，如果 $T_1$ 和 $T_2$ 在自旋等待 $L_1$ 和 $L_2$ 时发生死锁，系统的总CPU利用率可达到约 $100\\%$，而吞吐量保持为 $0$，因为两个核心都在执行不完成任何工作的忙等待循环。\n\nB. 如果 $L_1$ 和 $L_2$ 被实现为睡眠锁而不是自旋锁， $T_1$ 和 $T_2$ 之间仍然可能发生死锁，但调度器会取消对阻塞线程的调度，从而减少CPU浪费，但吞吐量不会增加。\n\nC. 自旋循环内部一个正确的死锁检测策略可以仅基于一个固定的超时时间 $t$；如果一个线程自旋时间超过 $t$，操作系统就可以安全地断定发生了死锁，并强行抢占锁的持有者以打破循环。\n\nD. 一种针对自旋线程的有原则的死锁检测方法是，根据内核维护的所有权和等待者元数据，定期构建线程和锁的等待图 (WFG) 并检查循环；一旦检测到循环，操作系统可以调用一个解决策略，例如中止一次获取尝试或回滚一个线程，从而打破循环等待。\n\nE. 在单处理器系统上，自旋锁总是优于睡眠锁，因为它们消除了上下文切换的开销，因此不会发生死锁。",
            "solution": "问题陈述经分析后被认为是有效的。它在科学上基于操作系统原理，特别是并发和死锁。该场景提法得当、无歧义且没有矛盾。它呈现了一个适合进行严谨分析的经典死锁案例。\n\n问题的核心描述了一个在拥有 $m=2$ 个核心的对称多处理系统上，涉及两个线程 $T_1$ 和 $T_2$ 以及两个自旋锁 $L_1$ 和 $L_2$ 的死锁情况。锁的获取顺序造成了一个循环依赖：\n1. 线程 $T_1$ 获取锁 $L_1$。\n2. 线程 $T_2$ 获取锁 $L_2$。\n3. 线程 $T_1$ 尝试获取 $L_2$，该锁由 $T_2$ 持有。$T_1$ 开始自旋等待。\n4. 线程 $T_2$ 尝试获取 $L_1$，该锁由 $T_1$ 持有。$T_2$ 开始自旋等待。\n\n这种情况满足了死锁的四个必要Coffman条件：\n1.  **互斥**：锁 $L_1$ 和 $L_2$ 是互斥资源。\n2.  **持有并等待**：$T_1$ 在等待 $L_2$ 时持有 $L_1$，$T_2$ 在等待 $L_1$ 时持有 $L_2$。\n3.  **不可抢占**：问题陈述指出，在等待时两个线程都不会释放它们的第一个锁，这意味着锁不能被抢占。\n4.  **循环等待**：存在一个循环等待链：$T_1 \\to L_2 \\to T_2 \\to L_1 \\to T_1$。\n\n鉴于这种死锁情况，$T_1$ 和 $T_2$ 被调度到两个可用的核心上。$T_1$ 在一个核心上执行忙等待循环，$T_2$ 在另一个核心上执行忙等待循环。两个线程都无法取得进展。\n\n**选项A分析：**\n该陈述表明，在有 $m=2$ 个核心的情况下，死锁的线程 $T_1$ 和 $T_2$ 将导致约 $100\\%$ 的CPU利用率和 $0$ 的吞吐量。\n在所描述的死锁中，$T_1$ 在一个核心上执行自旋等待循环，$T_2$ 在第二个核心上执行自旋等待循环。处于自旋等待循环中的线程正在积极执行指令，从而使其运行的CPU核心保持完全占用。由于这个 $m=2$ 系统的两个核心都被自旋的线程占用，总CPU利用率将是 $((100\\% + 100\\%) / 2) = 100\\%$。吞吐量定义为完成的临界区速率。由于两个线程都陷入死锁，它们都无法完成其操作序列。因此，有用工作的吞吐量为 $0$。该陈述中提供的推理也是合理的：核心很忙，但做的是非生产性工作。\n结论：**正确**。\n\n**选项B分析：**\n该陈述考虑了一个假设场景，其中自旋锁 $L_1$ 和 $L_2$ 被替换为睡眠锁。\n死锁的底层逻辑保持不变；四个Coffman条件仍然满足。因此，死锁仍然会发生。区别在于等待机制。睡眠锁使一个线程阻塞，并由调度器从`RUNNING`状态转移到`WAITING`或`BLOCKED`状态。一个阻塞的线程不消耗CPU周期。因此，当 $T_1$ 和 $T_2$ 尝试获取第二个锁时，它们都将被取消调度。这会释放CPU核心以执行其他就绪线程，或者在没有其他就绪线程时进入空闲状态。与自旋锁场景相比，这直接减少了CPU浪费。然而，死锁状况持续存在，因此两个线程都没有进展，吞吐量保持为 $0$。\n结论：**正确**。\n\n**选项C分析：**\n该陈述提出了一种基于固定超时时间 $t$ 和强行抢占锁持有者的恢复操作的死锁检测策略。\n使用超时来推断死锁是一种启发式方法，而不是一种确定性方法。一个线程可能会长时间自旋，不是因为死锁，而是因为高竞争，或者因为锁的持有者正在执行一个合法的、长时间运行的临界区。因此，不能仅凭超时就“安全地断定发生了死锁”；这可能导致误报。此外，“强行抢占锁的持有者”是一个极其不安全的操作。锁的持有者可能正处于修改共享数据结构的中间阶段。抢占它的锁很可能会使该结构处于不一致和损坏的状态，这可能导致系统崩溃或引发微妙的数据错误。安全的抢占需要复杂的、类似事务的回滚/恢复机制，而这种简单化的策略并未暗示这些机制。\n结论：**不正确**。\n\n**选项D分析：**\n该陈述描述了一种有原则的死锁检测和解决方法。它涉及构建一个等待图 (WFG)，其中节点代表线程，从 $T_i$ 到 $T_j$ 的有向边表示 $T_i$ 正在等待 $T_j$ 持有的资源。问题陈述指出，操作系统维护着必要的所有权和等待者信息。WFG中的循环是死锁的充分必要条件。这是一种正式且正确的检测方法。一旦检测到循环（从而确认死锁），操作系统必须应用一个解决策略。建议的策略——中止一次获取尝试或回滚一个线程——是打破死锁的标准策略，通常是通过打破循环等待条件来实现。这种方法是合理、鲁棒的，并且代表了操作系统课程中讲授的标准算法。\n结论：**正确**。\n\n**选项E分析：**\n该陈述声称，在单处理器系统上，自旋锁“总是优于”睡眠锁，因为它们“不会发生死锁”。\n这个陈述存在根本性缺陷。在单处理器系统上，如果一个持有锁的线程 $T_A$ 被抢占，而另一个线程 $T_B$ 被调度，并且 $T_B$ 尝试使用自旋锁获取同一个锁，那么 $T_B$ 将会无限期地自旋。由于只有一个处理器，持有锁的线程 $T_A$ 无法运行以释放锁，因为 $T_B$ 正在消耗所有可用的CPU时间。这会导致完全的系统冻结，是死锁的一种形式。相反，如果 $T_B$ 使用睡眠锁，它会阻塞，调度器可以重新调度 $T_A$，$T_A$ 随后可以释放锁，让系统取得进展。因此，在单处理器系统上，自旋锁通常是一个非常糟糕的选择，而且它们几乎肯定会引起死锁。这个前提是错误的，结论也是错误的。\n结论：**不正确**。",
            "answer": "$$\\boxed{ABD}$$"
        }
    ]
}