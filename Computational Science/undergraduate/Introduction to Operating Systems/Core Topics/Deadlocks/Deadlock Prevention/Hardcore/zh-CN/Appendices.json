{
    "hands_on_practices": [
        {
            "introduction": "死锁的形成需要满足四个必要条件，其中环路等待（circular wait）是关键一环。一种强大而通用的死锁预防策略是打破这个环路，通过为所有锁建立一个全局的、固定的获取顺序。本练习将引导你应用这种称为“锁层次”（lock hierarchy）的原则，通过重构代码来消除潜在的死锁风险，从而掌握预防环路等待的核心思想。",
            "id": "3632807",
            "problem": "一个操作系统（OS）的软件模块使用三个互斥锁（mutex）来保护共享数据结构：$L_{\\text{acct}}$ 用于账户状态，$L_{\\text{buf}}$ 用于输入/输出缓冲区，以及 $L_{\\text{user}}$ 用于用户会话元数据。存在三个不同的代码路径，每个路径都需要为一个简短的临界区同时持有两个互斥锁。在当前的实现中，嵌套的获取方式如下：\n- 路径 $P_1$：先获取 $L_{\\text{user}}$，再获取 $L_{\\text{acct}}$。\n- 路径 $P_2$：先获取 $L_{\\text{buf}}$，再获取 $L_{\\text{user}}$。\n- 路径 $P_3$：先获取 $L_{\\text{acct}}$，再获取 $L_{\\text{buf}}$。\n假设临界区可以被重构，使得在每个路径中获取这两个锁的顺序可以被改变，而不会在互斥之外违反正确性或不变量。同时假设一个线程会持有锁直到相应临界区的结束，锁一旦获取就不可被抢占，并且所有三个锁都是标准的非可重入互斥锁。\n\n基本原理：死锁是一种状态，其中一组进程中的每一个都在等待一个只有该集合中另一个进程才能引起的事件。死锁的一组必要条件（Coffman 条件）包括互斥、持有并等待、无抢占和循环等待。防止死锁需要确保这些条件中至少有一个不成立。\n\n工程师们提出了一项策略，通过强制实施一个基于锁名称字符串字典序的锁获取顺序来降低循环等待的风险，该顺序使用一个固定的比较器。对于给定的锁，这个顺序是 $L_{\\text{acct}} \\prec L_{\\text{buf}} \\prec L_{\\text{user}}$。\n\n以下哪个选项是正确的？选择所有适用的选项。\n\nA. 一个有效的重构方案，它强制执行了所述的字母顺序，并消除了这三个路径之间循环等待的可能性，该方案是：\n- 路径 $P_1$：先获取 $L_{\\text{acct}}$，再获取 $L_{\\text{user}}$。\n- 路径 $P_2$：先获取 $L_{\\text{buf}}$，再获取 $L_{\\text{user}}$。\n- 路径 $P_3$：先获取 $L_{\\text{acct}}$，再获取 $L_{\\text{buf}}$。\n\nB. 以下重构也强制执行了字母顺序并消除了循环等待的可能性：\n- 路径 $P_1$：先获取 $L_{\\text{user}}$，再获取 $L_{\\text{acct}}$。\n- 路径 $P_2$：先获取 $L_{\\text{buf}}$，再获取 $L_{\\text{user}}$。\n- 路径 $P_3$：先获取 $L_{\\text{acct}}$，再获取 $L_{\\text{buf}}$。\n\nC. 使用锁名称的字典序作为全序的代理是可靠的，但这需要满足一些系统范围内的约束条件。具体来说，在程序的生命周期内，名称必须是不可变的和全局唯一的，所有代码都必须使用相同的规范比较器（例如，固定的区分大小写和不依赖于区域设置的排序规则），并且所有参与者都必须遵守相同的命名方案。陷阱包括重命名锁的重构、其顺序在不同执行中会改变的动态生成名称，以及跨组件的名称规范化不匹配。\n\nD. 因为可重入锁允许一个线程多次获取同一个锁，所以任何通过强制按名称对锁获取施加全序来防止死锁的尝试都会失败，即使所有代码都遵守该顺序；因此，当存在可重入性时，按名称排序无法防止循环等待。\n\nE. 在初始化时为每个互斥锁分配一个唯一的数字等级，并要求所有代码严格按照等级升序获取锁，这提供了一个全序。如果这个全序被普遍执行且从未被违反（即在持有一个较高等级的锁时，不获取一个较低等级的锁），它就能独立于锁的名称防止循环等待。\n\nF. 当互斥锁与容器的元素相关联时，使用容器的当前大小作为获取键（总是先获取当前大小较小的容器的锁）是一个安全且充分的全序，可以防止所有遵守它的线程之间发生循环等待。",
            "solution": "在进行解答之前，将对问题陈述进行验证。\n\n### 第1步：提取已知条件\n\n-   **互斥锁**：$L_{\\text{acct}}$、$L_{\\text{buf}}$、$L_{\\text{user}}$。\n-   **代码路径（初始实现）**：\n    -   $P_1$：先获取 $L_{\\text{user}}$，再获取 $L_{\\text{acct}}$。\n    -   $P_2$：先获取 $L_{\\text{buf}}$，再获取 $L_{\\text{user}}$。\n    -   $P_3$：先获取 $L_{\\text{acct}}$，再获取 $L_{\\text{buf}}$。\n-   **假设**：\n    1.  获取锁的顺序可以改变。\n    2.  锁会被持有直到临界区结束（存在“持有并等待”条件）。\n    3.  锁一旦获取就不可抢占（存在“无抢占”条件）。\n    4.  锁是标准的非可重入互斥锁，并提供互斥（存在“互斥”条件）。\n-   **基本原理**：死锁的四个必要条件（Coffman 条件）是互斥、持有并等待、无抢占和循环等待。打破其中任何一个条件即可防止死锁。\n-   **提议的策略**：强制执行一个基于锁名称的字典序（字母顺序）的锁获取顺序：$L_{\\text{acct}} \\prec L_{\\text{buf}} \\prec L_{\\text{user}}$。\n\n### 第2步：使用提取的已知条件进行验证\n\n-   **科学依据**：该问题基于计算机科学中的基本和标准概念，特别是操作系统理论。互斥锁、死锁、Coffman 条件和锁序层次结构都是经典主题。该问题是合理的。\n-   **定义明确**：该问题提供了一个清晰的初始状态、一组约束和一个提议的策略。它要求评估几个后果和相关原则。信息足以确定死锁的存在并评估提议解决方案的有效性。该问题是定义明确的。\n-   **客观性**：术语是精确和技术性的。排序规则 $L_{\\text{acct}} \\prec L_{\\text{buf}} \\prec L_{\\text{user}}$ 是客观定义的。没有主观语言。\n\n### 第3步：结论和行动\n\n问题陈述是有效的。这是一个关于操作系统中死锁预防的标准、格式良好的问题。我将继续推导解决方案。\n\n### 基于原则的推导\n\n死锁的可能性源于循环等待条件，因为其他三个 Coffman 条件被声明为存在。循环等待可以通过“等待图”（waits-for graph）来可视化，其中节点代表资源（互斥锁），从 $L_i$ 到 $L_j$ 的有向边表示一个进程/线程可以在持有 $L_i$ 的同时请求 $L_j$。此图中的环路意味着可能存在死锁。\n\n在初始实现中：\n-   路径 $P_1$（先获取 $L_{\\text{user}}$ 再获取 $L_{\\text{acct}}$）创建了一个依赖关系 $L_{\\text{user}} \\rightarrow L_{\\text{acct}}$。\n-   路径 $P_2$（先获取 $L_{\\text{buf}}$ 再获取 $L_{\\text{user}}$）创建了一个依赖关系 $L_{\\text{buf}} \\rightarrow L_{\\text{user}}$。\n-   路径 $P_3$（先获取 $L_{\\text{acct}}$ 再获取 $L_{\\text{buf}}$）创建了一个依赖关系 $L_{\\text{acct}} \\rightarrow L_{\\text{buf}}$。\n\n结合这些依赖关系揭示了一个环路：$L_{\\text{acct}} \\rightarrow L_{\\text{buf}} \\rightarrow L_{\\text{user}} \\rightarrow L_{\\text{acct}}$。这证实了初始实现容易发生死锁。\n\n提议的策略是在锁获取上强制执行一个全序（total order）：$L_{\\text{acct}} \\prec L_{\\text{buf}} \\prec L_{\\text{user}}$。这意味着持有锁 $L_i$ 的线程只有在 $L_i \\prec L_j$ 的情况下才能请求锁 $L_j$。此规则确保“等待图”中的所有边都从较低序的资源指向较高序的资源。一个其边遵守其顶点全序的有向图是一个有向无环图（DAG）。由于 DAG 根据定义没有环路，该策略可以防止循环等待条件，从而消除死锁的可能性。\n\n### 逐项分析\n\n**A. 一个有效的重构方案，它强制执行了所述的字母顺序，并消除了这三个路径之间循环等待的可能性，该方案是：**\n**- 路径 $P_1$：先获取 $L_{\\text{acct}}$，再获取 $L_{\\text{user}}$。**\n**- 路径 $P_2$：先获取 $L_{\\text{buf}}$，再获取 $L_{\\text{user}}$。**\n**- 路径 $P_3$：先获取 $L_{\\text{acct}}$，再获取 $L_{\\text{buf}}$。**\n\n让我们根据全序 $L_{\\text{acct}} \\prec L_{\\text{buf}} \\prec L_{\\text{user}}$ 检查每个路径。\n-   $P_1$：先获取 $L_{\\text{acct}}$，再获取 $L_{\\text{user}}$。这是有效的，因为 $L_{\\text{acct}} \\prec L_{\\text{user}}$。\n-   $P_2$：先获取 $L_{\\text{buf}}$，再获取 $L_{\\text{user}}$。这是有效的，因为 $L_{\\text{buf}} \\prec L_{\\text{user}}$。\n-   $P_3$：先获取 $L_{\\text{acct}}$，再获取 $L_{\\text{buf}}$。这是有效的，因为 $L_{\\text{acct}} \\prec L_{\\text{buf}}$。\n所有三个重构后的路径都符合全序规则。如前所述，强制执行这样的全序可以防止循环等待。因此，该选项提供了一个正确的重构方案。\n**结论：正确。**\n\n**B. 以下重构也强制执行了字母顺序并消除了循环等待的可能性：**\n**- 路径 $P_1$：先获取 $L_{\\text{user}}$，再获取 $L_{\\text{acct}}$。**\n**- 路径 $P_2$：先获取 $L_{\\text{buf}}$，再获取 $L_{\\text{user}}$。**\n**- 路径 $P_3$：先获取 $L_{\\text{acct}}$，再获取 $L_{\\text{buf}}$。**\n\n这是问题陈述中的初始实现。让我们根据顺序 $L_{\\text{acct}} \\prec L_{\\text{buf}} \\prec L_{\\text{user}}$ 来检查它。\n-   $P_1$：先获取 $L_{\\text{user}}$，再获取 $L_{\\text{acct}}$。这违反了顺序，因为一个线程会在持有“更高”等级的锁（$L_{\\text{user}}$）时请求一个“更低”等级的锁（$L_{\\text{acct}}$）。\n该陈述声称此重构“强制执行了字母顺序”，这是错误的。它还声称它“消除了循环等待的可能性”，正如初始分析所示，这也是错误的。\n**结论：不正确。**\n\n**C. 使用锁名称的字典序作为全序的代理是可靠的，但这需要满足一些系统范围内的约束条件。具体来说，在程序的生命周期内，名称必须是不可变的和全局唯一的，所有代码都必须使用相同的规范比较器（例如，固定的区分大小写和不依赖于区域设置的排序规则），并且所有参与者都必须遵守相同的命名方案。陷阱包括重命名锁的重构、其顺序在不同执行中会改变的动态生成名称，以及跨组件的名称规范化不匹配。**\n\n该陈述描述了成功实施基于字符串名称的锁序策略所面临的工程挑战和必要的前提条件。\n-   **不可变性和唯一性**：如果锁名称可以更改或不是唯一的，那么两个锁之间的相对顺序将不是明确定义或稳定的，这将破坏固定全序的整个前提。\n-   **规范比较器**：不同的字符串比较函数（例如，区分大小写与不区分大小写，特定区域设置的排序规则）可以对同一组字符串产生不同的排序。如果系统的不同部分使用不同的比较器，它们可能对全序没有共识，从而可能重新引入环路。\n-   **陷阱**：所给出的示例（重命名锁、动态名称、规范化不匹配）是未能满足上述前提条件的直接且有效的后果。\n该陈述是对这种死锁预防技术的实践要求的正确而深刻的总结。\n**结论：正确。**\n\n**D. 因为可重入锁允许一个线程多次获取同一个锁，所以任何通过强制按名称对锁获取施加全序来防止死\n锁的尝试都会失败，即使所有代码都遵守该顺序；因此，当存在可重入性时，按名称排序无法防止循环等待。**\n\n可重入（或递归）锁允许已经持有该锁的线程“重新获取”它而不会阻塞。这可以防止一个线程与自身发生死锁。然而，由循环等待引起的死锁至少涉及两个不同的线程和两个不同的资源。全序策略防止的是*不同锁之间*的依赖环路。\n例如，在全序 $L_1 \\prec L_2$ 下，线程 $T_A$ 不能在持有 $L_2$ 的同时请求 $L_1$，而线程 $T_B$ 在持有 $L_1$ 的同时请求 $L_2$。这种预防机制完全独立于 $L_1$ 和 $L_2$ 是否可重入。可重入属性涉及单个线程与单个锁的交互，而不是导致循环等待的线程间依赖关系。声称排序策略“会失败”是错误的。\n**结论：不正确。**\n\n**E. 在初始化时为每个互斥锁分配一个唯一的数字等级，并要求所有代码严格按照等级升序获取锁，这提供了一个全序。如果这个全序被普遍执行且从未被违反（即在持有一个较高等级的锁时，不获取一个较低等级的锁），它就能独立于锁的名称防止循环等待。**\n\n这描述了一种称为锁级别（lock leveling）或锁层次结构（lock hierarchy）的技术。为每个锁分配一个唯一的、不可变的整数等级，可以建立一个清晰明确的全序。强制按严格升序获取与我们讨论的策略是等效的。如前所述，这打破了循环等待条件。这种方法在实践中通常更受青睐，因为它避免了选项 C 中描述的基于字符串名称排序的陷阱（例如，比较的模糊性、名称更改）。该陈述是对一种鲁棒的死锁预防策略的正确描述。\n**结论：正确。**\n\n**F. 当互斥锁与容器的元素相关联时，使用容器的当前大小作为获取键（总是先获取当前大小较小的容器的锁）是一个安全且充分的全序，可以防止所有遵守它的线程之间发生循环等待。**\n\n集合 $S$ 上的全序要求对于任意两个不同的元素 $a,b \\in S$，要么 $a \\prec b$，要么 $b \\prec a$。提议的排序键是容器的大小。考虑两个不同的容器 $C_1$ 和 $C_2$，它们碰巧具有相同的大小。规则“总是先获取当前大小较小的容器的锁”在这种情况下是未定义的。\n如果线程 $T_A$ 决定按（$C_1$, $C_2$）的顺序加锁，而线程 $T_B$ 决定按（$C_2$, $C_1$）的顺序加锁，则可能发生死锁：$T_A$ 获取了 lock($C_1$) 并等待 lock($C_2$)，而 $T_B$ 获取了 lock($C_2$) 并等待 lock($C_1$)。\n因为键（大小）不能保证是唯一的，它只建立了一个偏序（partial order），而不是一个全序。为了安全起见，需要一个决胜规则（tie-breaking rule）（例如，如果大小相等，则使用容器对象的内存地址）。没有这样的规则，该策略是不安全的。该陈述声称这是一个“安全且充分的全序”是错误的。\n**结论：不正确。**",
            "answer": "$$\\boxed{ACE}$$"
        },
        {
            "introduction": "除了环路等待，“持有并等待”（hold-and-wait）是另一个导致死锁的关键条件。当一个线程持有一个锁，同时又等待另一个只能由其他线程触发的事件时，系统就可能陷入僵局。本练习通过一个思想实验，探讨了为什么监视器（monitor）中的条件变量（condition variable）在线程等待时必须原子性地释放锁，从而揭示其设计是如何从根本上打破“持有并等待”条件以预防死锁的。",
            "id": "3632747",
            "problem": "考虑一个监视器风格的设计，其中有一个共享互斥锁 $L$ 保护共享状态 $S$ 和一个名为 $cv$ 的条件变量 (CV)。监视器不变量是一个谓词 $p(S)$，它指示消费者何时可以继续执行。生产者线程负责使 $p(S)$ 为真，然后通过 CV 通知等待者。两个线程，$T_1$ (消费者) 和 $T_2$ (生产者)，遵循以下模式：\n- $T_1$ 执行：获取 $L$，当 $\\neg p(S)$ 时执行 $wait(cv)$，然后执行需要 $p(S)$ 的操作，最后释放 $L$。\n- $T_2$ 执行：获取 $L$，修改 $S$ 直到 $p(S)$ 为真，调用 $signal(cv)$，然后释放 $L$。\n\n已知操作系统中死锁的基本特征：当一个集合中的每个线程都在等待一个只有该集合中其他线程才能引发的事件时，就存在死锁。经典的 Coffman 条件是互斥资源访问、持有并等待、无抢占和循环等待。条件变量提供了一种阻塞直到谓词变为真的方法，正确的监视器设计要求在持有 $L$ 的同时调用 $wait(cv)$。在标准的监视器语义中，$wait(cv)$ 会原子地释放 $L$ 并将线程加入 $cv$ 的队列；当因 $signal(cv)$ 而恢复执行时，线程在返回前会重新获取 $L$。\n\n现在，假设有人提出了一种 $wait(cv)$ 的替代语义，该语义仍然要求在持有 $L$ 时调用它，但内部不释放 $L$；也就是说，等待的线程在仍然持有 $L$ 的同时保持阻塞状态。\n\n根据上述基本原理和死锁特征，哪个选项最好地解释了为什么替代语义有死锁风险，以及标准语义是如何防止死锁的？\n\nA. 如果 $wait(cv)$ 不释放 $L$，那么当 $T_1$ 阻塞时，它持有 $L$ 并等待 $T_2$ 使 $p(S)$ 为真并调用 $signal(cv)$。然而，$T_2$ 无法获取 $L$ 来更新 $S$，因为 $T_1$ 持有 $L$。这在等待关系中造成了一个循环（$T_1$ 等待 $T_2$ 的操作；$T_2$ 等待由 $T_1$ 持有的 $L$），满足了 Coffman 条件。在 $wait(cv)$ 内部释放 $L$ 打破了“持有并等待”条件，允许 $T_2$ 获取 $L$、更新 $S$ 并发出信号，从而防止了循环。\n\nB. 在 $wait(cv)$ 内部持有 $L$ 是安全的，因为 $signal(cv)$ 不需要 $L$；无论如何信号都会唤醒 $T_1$，因此等待的实现不会产生死锁。\n\nC. 死锁不会发生，因为条件变量会抢占锁：一个 $signal(cv)$ 会强制将 $L$ 从信号发送者转移到等待者，即使等待者在阻塞时持有 $L$，也能确保进展。\n\nD. 在 $wait(cv)$ 内部释放 $L$ 主要是通过增加并发性来提高性能，但与死锁无关；死锁的避免完全是通过使用 $signal(cv)$ 而不是 $broadcast(cv)$ 来实现的。",
            "solution": "问题陈述在并发系统和操作系统设计的研究中提出了一个有效且根本性的问题。它在科学上基于既定的进程同步原则，定义明确，清晰地界定了条件变量操作的标准语义和替代语义，并且完全客观。它提供了一个经典的教学场景，用以阐明为什么在等待操作期间必须释放监视器的锁。我们可以开始进行分析。\n\n监视器的基本原理是将共享数据与操作这些数据的过程捆绑在一起，通过单个锁确保互斥。条件变量 (CVs) 在监视器内部用于管理同步点，在这些同步点上，线程必须等待特定条件变为真才能继续执行。\n\n让我们使用所提供的定义来分析提议的 $wait(cv)$ 的替代语义，并将其与标准语义进行比较。\n\n**替代语义分析**\n\n在提议的替代语义下，调用 $wait(cv)$ 的线程会阻塞，但继续持有监视器的互斥锁 $L$。让我们假设谓词 $p(S)$ 初始为假，追踪线程 $T_1$ (消费者) 和 $T_2$ (生产者) 的执行过程。\n\n1.  线程 $T_1$ 获取锁 $L$。\n2.  $T_1$ 评估条件 $p(S)$。该条件为假，因此 $T_1$ 必须等待。\n3.  $T_1$ 调用 $wait(cv)$。根据替代语义，$T_1$ 进入阻塞状态，但*保留锁 $L$ 的所有权*。\n4.  线程 $T_2$ 现在尝试执行其生产者逻辑。第一步是获取锁 $L$。\n5.  然而，$L$ 是一个互斥锁，当前由阻塞的线程 $T_1$ 持有。因此，$T_2$ 无法获取 $L$，被迫阻塞，等待 $L$ 变为可用。\n\n此时，系统处于死锁状态。让我们对照死锁的四个必要 Coffman 条件来验证这一点：\n-   **互斥**：锁 $L$ 是一种一次只能由一个线程持有的资源。根据互斥锁的定义，此条件已满足。\n-   **持有并等待**：线程 $T_1$ 在等待另一事件（来自 $T_2$ 的关于 $cv$ 的信号）发生时，持有资源 $L$。此条件已满足。\n-   **无抢占**：锁 $L$ 不能从 $T_1$ 被强制抢占。它必须被自愿释放。对于此类锁，这是一个标准假设，此条件已满足。\n-   **循环等待**：存在一个循环依赖链。$T_1$ 正在等待一个只能由 $T_2$ 引起的事件（调用 $signal(cv)$）。$T_2$ 正在等待一个由 $T_1$ 持有的资源 ($L$)。这形成了一个等待环：$T_1 \\rightarrow T_2 \\rightarrow T_1$。此条件已满足。\n\n由于所有四个条件都满足，替代语义直接导致死锁。$T_1$ 正在等待来自 $T_2$ 的信号，但 $T_2$ 永远无法执行发送该信号的代码，因为它因等待 $T_1$ 持有的锁而被阻塞。\n\n**标准语义分析**\n\n在标准的、正确的语义下，$wait(cv)$ 在阻塞调用线程之前会原子地释放 $L$。\n\n1.  线程 $T_1$ 获取锁 $L$。\n2.  $T_1$ 评估 $p(S)$，发现其为假，并调用 $wait(cv)$。\n3.  根据标准语义，$T_1$ 原子地释放 $L$，然后进入 $cv$ 等待队列的阻塞状态。锁 $L$ 现在是空闲的。\n4.  线程 $T_2$ 尝试执行并调用 `acquire L`。由于 $L$ 已被 $T_1$ 释放，$T_2$ 成功获取锁。\n5.  $T_2$ 继续修改共享状态 $S$，直到 $p(S)$ 为真。\n6.  $T_2$ 调用 $signal(cv)$，这将 $T_1$ 从 $cv$ 等待队列移动到锁 $L$ 的就绪队列。\n7.  $T_2$ 完成其工作并调用 `release L`。\n8.  稍后，调度器运行 $T_1$，$T_1$ 现在重新获取锁 $L$（作为从 $wait(cv)$ 调用返回的一部分），并且可以继续执行，因为 $p(S)$ 现在为真。\n\n死锁被避免了。标准语义明确地打破了导致循环依赖的**持有并等待**条件。通过释放锁，等待的线程 ($T_1$) 允许其他线程 ($T_2$) 获取锁并改变系统状态，从而解决第一个线程正在等待的那个条件。\n\n现在我们评估所提供的选项。\n\n**选项 A：** 如果 $wait(cv)$ 不释放 $L$，那么当 $T_1$ 阻塞时，它持有 $L$ 并等待 $T_2$ 使 $p(S)$ 为真并调用 $signal(cv)$。然而，$T_2$ 无法获取 $L$ 来更新 $S$，因为 $T_1$ 持有 $L$。这在等待关系中造成了一个循环（$T_1$ 等待 $T_2$ 的操作；$T_2$ 等待由 $T_1$ 持有的 $L$），满足了 Coffman 条件。在 $wait(cv)$ 内部释放 $L$ 打破了“持有并等待”条件，允许 $T_2$ 获取 $L$、更新 $S$ 并发出信号，从而防止了循环。\n-   **结论：** **正确**。该选项通过识别循环等待依赖关系，精确而准确地描述了替代语义下的死锁场景。它正确地指出 $T_1$ 持有 $L$ 阻止了 $T_2$ 取得进展。它还正确地指出，标准语义通过打破“持有并等待”条件来防止这种死锁，从而打破了循环等待。这个解释根植于所提供的基本原理。\n\n**选项 B：** 在 $wait(cv)$ 内部持有 $L$ 是安全的，因为 $signal(cv)$ 不需要 $L$；无论如何信号都会唤醒 $T_1$，因此等待的实现不会产生死锁。\n-   **结论：** **不正确**。这个陈述基于一个错误的前提。生产者线程 $T_2$ 必须首先获取锁 $L$ 才能安全地修改共享状态 $S$ 并使谓词 $p(S)$ 为真。问题明确说明了这个顺序：`acquire L`，修改 $S$，然后 `signal(cv)`。如果 $T_2$ 无法获取 $L$，它就永远无法到达调用 $signal(cv)$ 的那一点。因此，信号*不会*发生，死锁就会出现。\n\n**选项 C：** 死锁不会发生，因为条件变量会抢占锁：一个 $signal(cv)$ 会强制将 $L$ 从信号发送者转移到等待者，即使等待者在阻塞时持有 $L$，也能确保进展。\n-   **结论：** **不正确**。这错误地描述了标准的监视器语义。一个 `signal` 操作并不会强制转移锁。在典型的 Hoare 风格或 Mesa 风格的监视器中，发送信号的线程会一直持有锁，直到它明确释放。被信号唤醒的线程只是被置为就绪状态，并且必须重新竞争锁。更重要的是，即使在替代语义下，这种机制也无法解决死锁，因为发送信号的线程 ($T_2$) 根本无法运行到调用 `signal` 的地方，因为它会因试图获取等待线程 ($T_1$) 持有的锁而被阻塞。\n\n**选项 D：** 在 $wait(cv)$ 内部释放 $L$ 主要是通过增加并发性来提高性能，但与死锁无关；死锁的避免完全是通过使用 $signal(cv)$ 而不是 $broadcast(cv)$ 来实现的。\n-   **结论：** **不正确**。释放锁是防止死锁的一个基本正确性要求，而不仅仅是性能优化。正如我们的分析所示，不释放锁必然导致死锁。在 $signal(cv)$ 和广播操作之间进行选择与这个特定的死锁问题是正交的（不相关的）；如果锁在等待期间被持有，两者都无法解决死锁。这个陈述从根本上误解了在监视器的等待操作中释放锁的作用。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "将理论原则应用于更复杂的真实场景是掌握知识的关键。本练习基于前一个练习中关于打破“持有并等待”条件的见解，向你提出了一个更具挑战性的问题：如何处理读写锁（read-write lock）升级时引发的死锁。你需要设计一个策略来解决这个常见的并发陷阱，同时还必须考虑因释放和重新获取锁而引入的正确性问题，例如竞争条件（race condition）。",
            "id": "3632814",
            "problem": "在一个操作系统（OS）库中，一个单一的读写（RW）锁 $L$ 保护一个共享数据结构 $S$。锁 $L$ 支持读模式（$R$），可由多个线程并发持有；以及写模式（$W$），必须由至多 $1$ 个线程独占持有。该实现还额外支持“升级”：一个已经持有 $R$ 锁的线程可以请求 $W$ 锁而无需释放 $R$ 锁，并且如果可能，该实现最终会将锁转换为 $W$ 锁。\n\n考虑以下常见的访问模式。线程 $T_i$ 获取 $L$ 上的 $R$ 锁，读取 $S$，有时决定必须修改 $S$。在当前设计中，它随后在仍持有 $R$ 锁的情况下请求升级到 $W$ 锁，并阻塞直到 $W$ 锁被授予。假设实现中不存在锁所有权的抢占。\n\n出现这样一种场景：$2$ 个线程 $T_1$ 和 $T_2$ 都获取了 $L$ 上的 $R$ 锁，都决定修改 $S$，并且都在仍持有 $R$ 锁的情况下请求升级到 $W$ 锁。在一个不强制任何线程释放 $R$ 锁的调度器下，系统可能会发生死锁，因为当另一个线程仍持有 $R$ 锁时，任何一个线程的升级请求都无法被批准。\n\n使用 Coffman 条件（互斥、持有并等待、无抢占和循环等待）对死锁的基本特征描述，选择一个最佳选项，该选项提出一个客户端可见的策略和每个线程应遵循的序列，以防止这种由升级引起的死锁，且不引入新的锁或抢占。正确的选项必须解释该策略如何打破至少一个 Coffman 条件，以及这些步骤如何在存在并发线程的情况下保持更新的正确性。\n\nA. 禁止在持有 $R$ 锁时升级。当一个线程决定需要 $W$ 锁时，它必须遵循以下序列：释放 $R$ 锁；获取 $W$ 锁；重新读取或重新验证 $S$ 上促使更新的谓词；如果谓词仍然成立，则执行更新并释放 $W$ 锁；否则，释放 $W$ 锁，重新获取 $R$ 锁，并继续以读模式运行。该策略被明确规定为拒绝任何在仍持有 $R$ 锁时请求 $W$ 锁的尝试。\n\nB. 保持升级功能启用，但在请求升级的线程之间强制执行先进先出（FIFO）排队。持有 $R$ 锁并请求 $W$ 锁的线程在等待时继续持有 $R$ 锁，但升级请求严格按照到达顺序被批准。其他读取者可以继续自由地获取 $R$ 锁。\n\nC. 使用一种在持有 $R$ 锁时自旋的非阻塞尝试升级方法：一个线程重复尝试将 $R$ 锁原子地转换为 $W$ 锁，失败后立即在保持 $R$ 锁的情况下重试。为避免饿死，线程在尝试之间使用退避延迟，但在成功获得 $W$ 锁之前绝不释放 $R$ 锁。\n\nD. 允许“条件性升级”：一个线程只有在它是唯一的读取者时才能从 $R$ 锁升级到 $W$ 锁；否则，它保持 $R$ 锁并等待，直到它成为唯一的读取者，此时升级才会进行。在它等待期间，允许其他读取者到达。",
            "solution": "用户提供了一个关于操作系统中读写锁死锁场景的问题陈述。任务是验证该问题，如果有效，则推导出正确的解决方案并评估给定的选项。\n\n### 问题验证\n\n首先，我将根据指定标准验证问题陈述。\n\n**步骤 1：提取已知条件**\n-   一个单一的读写（RW）锁 $L$ 保护一个共享数据结构 $S$。\n-   锁 $L$ 有两种模式：读（$R$）和写（$W$）。\n-   $R$ 模式可由多个线程并发持有。\n-   $W$ 模式必须由至多 $1$ 个线程独占持有。\n-   锁支持“升级”功能：持有 $R$ 锁的线程可以请求 $W$ 锁而无需释放 $R$ 锁。\n-   一个常见的访问模式是：线程 $T_i$ 获取 $R$ 锁，读取 $S$，有时决定修改 $S$，然后在持有 $R$ 锁的情况下请求升级到 $W$ 锁。\n-   假设：锁所有权无抢占。\n-   描述了一个死锁场景：$2$ 个线程，$T_1$ 和 $T_2$，都获取了 $R$ 锁，然后都请求升级到 $W$ 锁。由于另一个线程持有 $R$ 锁，两个升级请求都无法被批准。\n-   目标是找到一个客户端可见的策略和序列，通过打破一个 Coffman 条件来防止这种死锁，同时不引入新的锁或抢占，并保持正确性。\n\n**步骤 2：使用提取的已知条件进行验证**\n-   **科学依据：** 该问题牢固地植根于并发编程和操作系统的理论中。读写锁、锁升级及其导致的死锁是经典的、有据可查的概念。Coffman 条件是分析死锁的标准理论框架。该场景在科学上是合理的。\n-   **定义明确：** 该问题定义明确。它清晰地定义了系统、特定的死锁场景以及有效解决方案的一系列约束。预期会有一个唯一的概念性解决方案。\n-   **客观性：** 语言正式、精确，没有主观性。像“读写锁”、“死锁”和“Coffman 条件”这样的术语具有明确的技术含义。\n\n**步骤 3：结论和行动**\n问题陈述是有效的。这是一个标准的计算机科学问题，它自成体系、科学合理且定义明确。我将继续推导解决方案。\n\n### 推导与选项分析\n\n问题要求提出一个策略来防止特定的死锁。为此，我们必须打破死锁所需的四个 Coffman 条件中的至少一个，这些条件在所描述的场景中都存在：\n\n1.  **互斥：** 这个条件成立，因为写锁 $W$ 必须是独占的。升级到 $W$ 锁需要独占访问权，而这会被任何其他持有 $R$ 锁的线程所阻塞。这个条件对于写操作的正确性至关重要，不能被打破。\n2.  **持有并等待：** 这个条件成立。如陈述所述，“一个已经持有 $R$ 锁的线程可以请求 $W$ 锁而无需释放 $R$ 锁”。在死锁场景中，$T_1$ 和 $T_2$ 都持有一个资源（$R$ 锁），同时等待获取另一个资源（$W$ 锁所需的独占访问权）。\n3.  **无抢占：** 这个条件成立，根据问题陈述中的明确假设（“锁所有权无抢占”）。此外，问题限制解决方案不能引入抢占。\n4.  **循环等待：** 这个条件成立。线程 $T_1$ 需要 $T_2$ 持有的资源（即 $T_2$ 释放其 $R$ 锁）来完成其升级。对称地，线程 $T_2$ 需要 $T_1$ 持有的资源（即 $T_1$ 释放其 $R$ 锁）来完成其升级。这造成了一个循环依赖：$T_1 \\rightarrow T_2 \\rightarrow T_1$。\n\n为了防止死锁，我们必须打破“持有并等待”或“循环等待”条件。\n\n一个健壮且常见的死锁预防策略是打破 **持有并等待** 条件。这可以通过建立一个策略来实现，即线程在请求一个可能需要等待的新锁之前，必须释放它持有的所有锁。在这种情况下，一个持有 $R$ 锁并决定需要写入的线程必须首先释放 $R$ 锁，然后从不持有任何锁的状态下尝试获取 $W$ 锁。\n\n然而，这个策略引入了一个新的正确性挑战。在线程释放 $R$ 锁和它重新以 $W$ 锁方式获取锁之间的瞬间，另一个线程可能已经获取了 $W$ 锁并修改了数据结构 $S$。促使第一个线程执行更新的谓词或条件可能不再为真。这是一个经典的“检查时到使用时”（Time-of-Check to Time-of-Use, TOCTOU）的竞争条件。一个正确的解决方案必须考虑到这一点。线程在成功获取 $W$ 锁后，必须重新读取或重新验证 $S$ 的状态，以确保其更新的依据在继续修改之前仍然有效。\n\n现在，我将基于这一原则性分析来评估每个选项。\n\n**A. 禁止在持有 R 锁时升级。当一个线程决定需要 W 锁时，它必须遵循以下序列：释放 R 锁；获取 W 锁；重新读取或重新验证 S 上促使更新的谓词；如果谓词仍然成立，则执行更新并释放 W 锁；否则，释放 W 锁，重新获取 R 锁，并继续以读模式运行。该策略被明确规定为拒绝任何在仍持有 R 锁时请求 W 锁的尝试。**\n\n-   **Coffman 条件：** 该策略直接打破了 **持有并等待** 条件。线程在等待 $W$ 锁时从不持有 $R$ 锁。它在请求 $W$ 锁*之前*释放 $R$ 锁。由于在等待时不持有任何资源，它不会导致死锁循环。\n-   **正确性：** 该策略正确地识别了因释放和重新获取锁而引入的 TOCTOU 竞争条件。它强制要求一个关键步骤：“重新读取或重新验证 $S$ 上的谓词”。这确保了只有在 $S$ 的状态仍然合适时才执行更新，从而维护了数据的完整性。\n-   **约束：** 该策略不引入新的锁或抢占。它是一个客户端可见的策略，规定了每个线程特定的操作序列。\n-   **结论：** 此选项提供了一个完整且正确的解决方案，遵循了所有约束。它确定了要打破的正确 Coffman 条件，并指定了维持正确性所需的步骤。这是在实际系统中处理这种情况的标准和推荐模式。**正确**。\n\n**B. 保持升级功能启用，但在请求升级的线程之间强制执行先进先出（FIFO）排队。持有 R 锁并请求 W 锁的线程在等待时继续持有 R 锁，但升级请求严格按照到达顺序被批准。其他读取者可以继续自由地获取 R 锁。**\n\n-   **Coffman 条件：** 该策略没有打破任何 Coffman 条件。关键在于，线程“在等待时继续持有 $R$ 锁”，因此 **持有并等待** 条件仍然存在。在有线程 $T_1$ 和 $T_2$ 的场景中，一个线程（$T_1$）将位于 FIFO 队列的头部，等待 $T_2$ 释放其 $R$ 锁。$T_2$ 将在队列中位于 $T_1$ 之后，同样在等待。因为 $T_1$ 无法继续，所以 $T_2$ 永远无法到达队列头部。死锁仍未解决。FIFO 顺序只是形式化了谁先被卡住。而“其他读取者可以继续自由地获取 $R$ 锁”的策略甚至可能通过允许新读取者到达并延长升级失败的时间来加剧问题。\n-   **结论：** 此策略无法防止死锁。**不正确**。\n\n**C. 使用一种在持有 R 锁时自旋的非阻塞尝试升级方法：一个线程重复尝试将 R 锁原子地转换为 W 锁，失败后立即在保持 R 锁的情况下重试。为避免饿死，线程在尝试之间使用退避延迟，但在成功获得 W 锁之前绝不释放 R 锁。**\n\n-   **Coffman 条件：** 该策略没有打破“持有并等待”条件。线程“在成功之前绝不释放 $R$ 锁”。自旋只是一种忙等待的形式。在死锁场景中，$T_1$ 和 $T_2$ 都会自旋，由于另一个线程持有 $R$ 锁，它们会反复失败其 `try_upgrade` 尝试。两者都永远无法成功。这会导致活锁（线程处于活动状态但没有进展）或死锁，但它没有解决资源冲突。\n-   **结论：** 此策略用自旋代替了阻塞，但并未防止死锁。**不正确**。\n\n**D. 允许“条件性升级”：一个线程只有在它是唯一的读取者时才能从 R 锁升级到 W 锁；否则，它保持 R 锁并等待，直到它成为唯一的读取者，此时升级才会进行。其他读取者是允许在其等待时到达。**\n\n-   **Coffman 条件：** 这个策略精确地描述了*导致*死锁的行为，而不是一个防止死锁的解决方案。一个线程“保持 $R$ 锁并等待”。当 $T_1$ 和 $T_2$ 都执行此策略时，它们都发现自己不是唯一的读取者，因此它们都决定在持有 $R$ 锁的情况下等待。它们将无限期地互相等待。**持有并等待** 和 **循环等待** 条件完全成立。\n-   **结论：** 这不是一个解决方案；这是对问题的重述。**不正确**。\n\n总之，只有选项 A 正确地确定了一个有效的死锁预防策略（打破“持有并等待”条件），并提供了确保正确性所必需的逻辑（重新验证）。",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}