{
    "hands_on_practices": [
        {
            "introduction": "要真正理解死锁，最好的方法就是亲手构造一个。这个练习将引导你探究造成死锁的最小条件，通过构建一个包含两个资源和多个进程的资源分配图（RAG），你会发现，仅仅一个进程违反既定的资源获取顺序，就足以引发致命的循环等待，从而导致系统陷入僵局。这个实践凸显了严格遵守死锁预防策略的重要性。",
            "id": "3677426",
            "problem": "考虑一个系统，它有两种资源类型，表示为 $R_a$ 和 $R_b$，每种资源都只有一个实例。系统中有 $n$ 个进程，表示为 $P_1, P_2, \\dots, P_n$，这些进程可能需要以嵌套的方式获取这两种资源。系统规定了一个全局锁顺序：任何需要两种资源的进程都必须先获取 $R_a$ 再获取 $R_b$，我们将此锁顺序表示为 $R_a \\rightarrow R_b$。资源分配图 (RAG) 的定义如下：对于每个进程 $P_i$ 和资源 $R_x$，一条有向边 $P_i \\rightarrow R_x$ 表示 $P_i$ 正在请求 $R_x$，一条有向边 $R_x \\rightarrow P_i$ 表示 $R_x$ 已分配给 $P_i$。假设死锁的四个常规必要条件均已满足：互斥、占有并等待、不可抢占和循环等待。\n\n在时刻 $t$，系统处于以下快照状态：\n- 进程 $P_1$ 持有 $R_a$（存在一条分配边 $R_a \\rightarrow P_1$），并且遵循全局锁顺序，在未释放 $R_a$ 的情况下请求 $R_b$（存在一条请求边 $P_1 \\rightarrow R_b$）。\n- 恰好有一个进程 $P_k$ 违反了全局锁顺序。具体来说，$P_k$ 持有 $R_b$（存在一条分配边 $R_b \\rightarrow P_k$），并在未释放 $R_b$ 的情况下请求 $R_a$（存在一条请求边 $P_k \\rightarrow R_a$）。\n- 所有其他进程，如果需要这两种资源，都遵守锁顺序 $R_a \\rightarrow R_b$。\n\n从资源分配图的核心定义以及一个众所周知的特性（在单实例资源情况下，RAG中存在环是死锁的充分必要条件）出发，构建时刻 $t$ 快照的逻辑RAG，并确定要使RAG包含一个有向环（这意味着在这个双资源系统中存在死锁），在 $n$ 个进程中所需的最少锁顺序违规次数，记为 $v_{\\min}$。将你的答案表示为 $v_{\\min}$ 的单个整数值。无需四舍五入，无需单位。",
            "solution": "问题要求在一个拥有两个单实例资源 $R_a$ 和 $R_b$ 的系统中，造成死锁所需的最少锁顺序违规次数 $v_{\\min}$。\n\n首先，我们建立理论基础。系统由一组进程 $\\mathcal{P} = \\{P_1, P_2, \\dots, P_n\\}$ 和一组资源类型 $\\mathcal{R} = \\{R_a, R_b\\}$ 组成。每种资源类型只有一个实例。系统的状态可以通过资源分配图（RAG）来建模，它是一个有向图 $G = (V, E)$。顶点集为 $V = \\mathcal{P} \\cup \\mathcal{R}$。边集 $E$ 由两种类型的边组成：\n1.  如果进程 $P_i$ 正在等待资源类型 $R_x$ 的一个实例，则存在一条请求边 $P_i \\rightarrow R_x$。\n2.  如果资源类型 $R_x$ 的一个实例已分配给进程 $P_i$，则存在一条分配边 $R_x \\rightarrow P_i$。\n\n问题陈述了死锁的四个必要条件（互斥、占有并等待、不可抢占和循环等待）均已满足。对于具有单实例资源的系统，RAG中的环是死锁存在的充分必要条件。我们的任务是找到为创建这样一个环路而必须违反既定锁顺序 $R_a \\rightarrow R_b$ 的最小进程数。\n\n我们来分析形成环的条件。RAG中的环必须同时涉及进程和资源。由于只有两种资源类型，环必须在进程和资源之间交替出现。最简单的可能环路将涉及两个进程（比如 $P_i$ 和 $P_j$）和两种资源（$R_a$ 和 $R_b$）。这样的环将具有 $P_i \\rightarrow R_x \\rightarrow P_j \\rightarrow R_y \\rightarrow P_i$ 的结构，其中 $R_x, R_y \\in \\{R_a, R_b\\}$ 且 $R_x \\neq R_y$。\n\n不失一般性地，我们假设 $R_x = R_a$ 且 $R_y = R_b$。那么环就是 $P_i \\rightarrow R_a \\rightarrow P_j \\rightarrow R_b \\rightarrow P_i$。\n我们来解释这个环中的边：\n-   $P_i \\rightarrow R_a$：进程 $P_i$ 正在请求资源 $R_a$。\n-   $R_a \\rightarrow P_j$：资源 $R_a$ 被进程 $P_j$ 持有。\n-   $P_j \\rightarrow R_b$：进程 $P_j$ 正在请求资源 $R_b$。\n-   $R_b \\rightarrow P_i$：资源 $R_b$ 被进程 $P_i$ 持有。\n\n总结环中涉及的两个进程的状态：\n-   进程 $P_i$ 持有 $R_b$ 并请求 $R_a$。\n-   进程 $P_j$ 持有 $R_a$ 并请求 $R_b$。\n\n现在，我们根据全局锁顺序规则来评估这种状态，该规则强制要求任何需要两种资源的进程都必须先获取 $R_a$ 再获取 $R_b$。\n-   进程 $P_j$ 的行为与此规则一致。它获取了 $R_a$，现在正在请求 $R_b$。这是一个有效的操作序列。\n-   然而，进程 $P_i$ 持有 $R_b$ 并请求 $R_a$。要处于这种状态，它必须先获取 $R_b$。随后请求 $R_a$ 的行为违反了 $R_a \\rightarrow R_b$ 的锁顺序。\n\n此分析表明，形成一个涉及两个进程和两种资源的环路*需要*其中一个进程违反全局锁顺序。如果两个进程都遵循锁顺序，一个持有 $R_b$ 的进程将永远不会请求 $R_a$，从而打破了循环等待条件出现的可能性。因此，违规数量必须至少为1。我们已经确定 $v_{\\min} \\geq 1$。\n\n接下来，我们必须确定在只有一次违规的情况下是否可能发生死锁。问题陈述提供了一个时刻 $t$ 的具体快照，使我们能够对此进行测试。\n-   进程 $P_1$ 持有 $R_a$ 并请求 $R_b$。这对应于边 $R_a \\rightarrow P_1$ 和 $P_1 \\rightarrow R_b$。如前所述，$P_1$ 遵守锁顺序协议。\n-   进程 $P_k$ 持有 $R_b$ 并请求 $R_a$。这对应于边 $R_b \\rightarrow P_k$ 和 $P_k \\rightarrow R_a$。这被明确说明是唯一的锁顺序违规行为。\n\n让我们为这个特定配置构建RAG。该图包含以下有向边序列：\n$P_1 \\rightarrow R_b \\rightarrow P_k \\rightarrow R_a \\rightarrow P_1$。\n\n这个序列在RAG中构成一个闭合的有向路径，即一个环。顶点和边如下：\n-   $P_1$ 请求 $R_b$（边 $P_1 \\rightarrow R_b$）。\n-   $R_b$ 被 $P_k$ 持有（边 $R_b \\rightarrow P_k$）。\n-   $P_k$ 请求 $R_a$（边 $P_k \\rightarrow R_a$）。\n-   $R_a$ 被 $P_1$ 持有（边 $R_a \\rightarrow P_1$）。\n\n由于RAG中存在一个环，并且资源是单实例的，涉及进程 $P_1$ 和 $P_k$ 的死锁便存在了。这个死锁状态是在只有一个进程 $P_k$ 违反全局锁顺序的情况下达成的。\n\n因此，我们证明了：\n1.  形成死锁环路至少需要一次锁顺序违规（$v_{\\min} \\geq 1$）。\n2.  恰好一次锁顺序违规足以形成死锁环路（$v_{\\min} \\leq 1$）。\n\n综合这两点，RAG中要包含一个有向环所需的最少锁顺序违规次数恰好是 $1$。",
            "answer": "$$\\boxed{1}$$"
        },
        {
            "introduction": "在理解了死锁如何形成之后，下一步自然是学习如何预防它。本练习将资源分配图应用于经典的“哲学家就餐”问题，这是一个著名的并发编程难题。通过对比两种不同的资源分配策略——严格的总排序与循环排序——你将直观地看到为什么前者能够有效打破循环等待条件，而后者则必然导致死锁。",
            "id": "3677360",
            "problem": "考虑一个哲学家就餐问题的变体，其模型如下。有 $n$ 个哲学家 $P_1, P_2, \\dots, P_n$ 围绕一张圆桌就坐，还有 $n$ 把叉子 $R_1, R_2, \\dots, R_n$，其中叉子 $R_j$ 放在哲学家 $P_j$ 和 $P_{j+1}$ 之间（索引对 $n$ 取模，所以 $R_n$ 在 $P_n$ 和 $P_1$ 之间）。每个哲学家 $P_i$ 需要两把叉子 $R_i$ 和 $R_{i+1}$ 才能吃饭。假设每种资源类型（每把叉子）只有一个实例。根据资源分配图（RAG）的标准定义，构建一个包含进程顶点 $P_i$ 和资源顶点 $R_j$ 的图，其中请求边为 $P_i \\rightarrow R_j$，分配边为 $R_j \\rightarrow P_i$。\n\n一个系统策略对资源类型施加了严格的全序关系：$R_1 \\prec R_2 \\prec \\cdots \\prec R_n$。每个哲学家必须按照关于 $\\prec$ 的严格递增顺序请求叉子：对于哲学家 $P_i$ 来说，这意味着先请求 $\\min_{\\prec}\\{R_i, R_{i+1}\\}$，然后再请求 $\\max_{\\prec}\\{R_i, R_{i+1}\\}$。将此策略与单实例资源类型在RAG中形成循环的直观原理进行比较，并评估以下陈述。此外，考虑一个假设的变体策略，其中资源类型的优先级是循环的 $R_1 \\rightarrow R_2 \\rightarrow \\cdots \\rightarrow R_n \\rightarrow R_1$，并且哲学家们沿着这个循环的方向请求资源。\n\n下列哪个陈述是正确的？\n\nA. 在严格全序 $R_1 \\prec R_2 \\prec \\cdots \\prec R_n$ 以及哲学家按递增顺序请求的约束下，资源分配图不能包含有向环；因此对于单实例叉子，死锁是不可能发生的。\n\nB. 即使有严格全序和递增顺序请求，在导出的等待图中仍然可能出现进程间的有向环，因此对于单实例叉子，死锁仍然是可能发生的。\n\nC. 严格全序消除了占有并等待条件，因为哲学家被禁止在等待一个更高序的叉子时占有一个更低序的叉子。\n\nD. 如果资源类型的优先级是循环的 $R_1 \\rightarrow R_2 \\rightarrow \\cdots \\rightarrow R_n \\rightarrow R_1$，那么沿着这个循环请求将无法防止资源分配图中出现有向环。\n\nE. 严格全序保证了无论调度策略如何都不会发生饿死，因此每个哲学家最终都能获得两把叉子并吃饭。",
            "solution": "问题描述了哲学家就餐问题的一个变体，并要求在两种不同的资源分配策略下，评估几个关于死锁和饿死的陈述。该问题定义明确，并基于操作系统理论的原理。\n\n首先，让我们根据所给的陈述来形式化系统组件和策略。\n- **进程**：有 $n$ 个哲学家，表示为进程集合 $\\mathcal{P} = \\{P_1, P_2, \\dots, P_n\\}$。\n- **资源**：有 $n$ 把叉子，表示为资源类型集合 $\\mathcal{R} = \\{R_1, R_2, \\dots, R_n\\}$。每种资源类型只有一个实例。\n- **资源需求**：哲学家 $P_i$ 需要两把叉子，$R_i$ 和 $R_{i+1}$，其中索引对 $n$ 取模（因此 $P_n$ 需要 $R_n$ 和 $R_1$）。\n- **死锁条件**：对于单实例资源类型，当且仅当资源分配图（RAG）中存在有向环时，才会发生死锁。RAG中的环是一个交替出现的进程和资源的序列，例如 $P_a \\rightarrow R_x \\rightarrow P_b \\rightarrow R_y \\rightarrow \\dots \\rightarrow P_a$，表示一个等待进程的循环链。\n\n我们将分析两种策略。\n\n**策略1：严格全序**\n\n第一种策略对资源类型施加了严格的全序关系：$R_1 \\prec R_2 \\prec \\cdots \\prec R_n$。哲学家必须根据此优先级关系，按严格递增的顺序请求他们所需的叉子。\n\n让我们分析每个哲学家 $P_i$ 的请求顺序：\n- 对于任何哲学家 $P_i$，$i \\in \\{1, 2, \\dots, n-1\\}$，所需的叉子是 $R_i$ 和 $R_{i+1}$。根据全序关系，$R_i \\prec R_{i+1}$。因此，$P_i$ 必须先请求 $R_i$，只有在获得 $R_i$ 之后才能请求 $R_{i+1}$。\n- 对于哲学家 $P_n$，所需的叉子是 $R_n$ 和 $R_1$。根据全序关系，$R_1 \\prec R_n$。因此，$P_n$ 必须先请求 $R_1$，只有在获得 $R_1$ 之后才能请求 $R_n$。\n\n该策略是一种标准的死锁预防技术，称为分层资源分配。它通过打破循环等待条件出现的可能性来预防死锁。为了证明这一点，我们用反证法，假设RAG中存在一个环。一个环的形式必然是 $P_{i_1} \\rightarrow R_{j_1} \\rightarrow P_{i_2} \\rightarrow R_{j_2} \\rightarrow \\dots \\rightarrow P_{i_k} \\rightarrow R_{j_k} \\rightarrow P_{i_1}$。\n\n- 一条边 $P_{i_m} \\rightarrow R_{j_m}$ 意味着进程 $P_{i_m}$ 正在请求资源 $R_{j_m}$。\n- 一条边 $R_{j_{m-1}} \\rightarrow P_{i_m}$ 意味着进程 $P_{i_m}$ 持有资源 $R_{j_{m-1}}$（其中索引 $m-1$ 对 $k$ 取模）。\n\n因此，对于环中的任何进程 $P_{i_m}$，它持有一个资源 $R_{j_{m-1}}$ 并正在请求另一个资源 $R_{j_m}$。该策略规定，一个进程只能请求比其当前持有的任何资源次序更高的资源。因此，在环的每一步中，所持有的资源的次序必须低于所请求的资源。\n- $P_{i_1}$ 持有 $R_{j_k}$ 并请求 $R_{j_1} \\implies R_{j_k} \\prec R_{j_1}$。\n- $P_{i_2}$ 持有 $R_{j_1}$ 并请求 $R_{j_2} \\implies R_{j_1} \\prec R_{j_2}$。\n- ...\n- $P_{i_k}$ 持有 $R_{j_{k-1}}$ 并请求 $R_{j_k} \\implies R_{j_{k-1}} \\prec R_{j_k}$。\n\n将这些不等式串联起来得到 $R_{j_k} \\prec R_{j_1} \\prec R_{j_2} \\prec \\cdots \\prec R_{j_{k-1}} \\prec R_{j_k}$。这导致了陈述 $R_{j_k} \\prec R_{j_k}$，它与严格序的非自反性相矛盾。因此，RAG中不可能存在环。\n\n**策略2：循环优先级**\n\n第二种假设的策略施加了一个循环优先级：$R_1 \\rightarrow R_2 \\rightarrow \\cdots \\rightarrow R_n \\rightarrow R_1$。哲学家们沿着这个循环的方向请求叉子。\n\n让我们分析每个哲学家 $P_i$ 的请求顺序：\n- 对于任何哲学家 $P_i$，$i \\in \\{1, 2, \\dots, n-1\\}$，所需的叉子是 $R_i$ 和 $R_{i+1}$。循环优先级是 $R_i \\rightarrow R_{i+1}$，所以 $P_i$ 先请求 $R_i$，然后请求 $R_{i+1}$。\n- 对于哲学家 $P_n$，所需的叉子是 $R_n$ 和 $R_1$。循环优先级是 $R_n \\rightarrow R_1$，所以 $P_n$ 先请求 $R_n$，然后请求 $R_1$。\n\n这种设置导致了经典的哲学家就餐死锁场景。考虑所有哲学家同时执行其协议的第一步的情况：\n1.  $P_1$ 请求并获得 $R_1$。\n2.  $P_2$ 请求并获得 $R_2$。\n3.  ...\n4.  $P_n$ 请求并获得 $R_n$。\n\n此时，每个哲学家都持有一把叉子，并准备请求他们的第二把叉子。\n- $P_1$ 持有 $R_1$ 并请求 $R_2$，而 $R_2$ 被 $P_2$ 持有。所以 $P_1$ 等待。\n- $P_2$ 持有 $R_2$ 并请求 $R_3$，而 $R_3$ 被 $P_3$ 持有。所以 $P_2$ 等待。\n- ...\n- $P_{n-1}$ 持有 $R_{n-1}$ 并请求 $R_n$，而 $R_n$ 被 $P_n$ 持有。所以 $P_{n-1}$ 等待。\n- $P_n$ 持有 $R_n$ 并请求 $R_1$，而 $R_1$ 被 $P_1$ 持有。所以 $P_n$ 等待。\n\n这造成了一个循环等待条件。RAG将包含环路：\n$P_1 \\rightarrow R_2 \\rightarrow P_2 \\rightarrow R_3 \\rightarrow \\cdots \\rightarrow P_n \\rightarrow R_1 \\rightarrow P_1$。\n因此，这个策略未能阻止死锁。\n\n现在，我们来评估每个陈述。\n\n**A. 在严格全序 $R_1 \\prec R_2 \\prec \\cdots \\prec R_n$ 以及哲学家按递增顺序请求的约束下，资源分配图不能包含有向环；因此对于单实例叉子，死锁是不可能发生的。**\n我们对策略1的分析证明了资源的严格全序可以防止在RAG中形成环。对于单实例资源，RAG中没有环是无死锁的充分条件。\n结论：**正确**。\n\n**B. 即使有严格全序和递增顺序请求，在导出的等待图中仍然可能出现进程间的有向环，因此对于单实例叉子，死锁仍然是可能发生的。**\n等待图（WFG）中存在从 $P_i$到 $P_j$ 的边，表示进程 $P_i$ 正在等待进程 $P_j$ 持有的资源。对于单实例资源类型，WFG中的环等价于RAG中的环。正如对陈述A的分析所确立的，严格全序策略可以防止RAG中出现环。因此，它也防止了WFG中出现环。该陈述声称环可能出现是错误的。\n结论：**不正确**。\n\n**C. 严格全序消除了占有并等待条件，因为哲学家被禁止在等待一个更高序的叉子时占有一个更低序的叉子。**\n占有并等待条件是死锁的四个必要条件之一，它指出一个进程必须在等待获取额外资源时至少持有一个资源。严格全序策略并没有消除这个条件。例如，哲学家 $P_1$ 请求 $R_1$，如果被批准，它会*占有* $R_1$ 同时*等待* $R_2$。该策略构建了占有并等待的结构，但并未消除它。所提供的推理也是有缺陷的；该策略要求哲学家在等待一个更高序的叉子时占有一个更低序的叉子，而不是禁止它。\n结论：**不正确**。\n\n**D. 如果资源类型的优先级是循环的 $R_1 \\rightarrow R_2 \\rightarrow \\cdots \\rightarrow R_n \\rightarrow R_1$，那么沿着这个循环请求将无法防止资源分配图中出现有向环。**\n我们对策略2的分析表明，循环优先级允许出现这样一种场景：每个哲学家都获得一把叉子，并等待循环中的下一把，从而导致所有 $n$ 个哲学家之间的循环等待。这种循环依赖在RAG中表现为一个环，导致死锁。因此，该策略未能防止有向环。\n结论：**正确**。\n\n**E. 严格全序保证了无论调度策略如何都不会发生饿死，因此每个哲学家最终都能获得两把叉子并吃饭。**\n无死锁并不意味着无饿死。饿死，或称无限期推迟，是指一个进程即使在资源可用时也反复被拒绝访问。虽然全序策略可以防止死锁，但哲学家仍有可能饿死。例如，考虑 $P_{n-1}$（需要 $R_{n-1}$，然后是 $R_n$）及其邻居 $P_{n-2}$（需要 $R_{n-2}$，然后是 $R_{n-1}$）和 $P_n$（需要 $R_1$，然后是 $R_n$）。一个不幸的调度序列可能允许 $P_{n-2}$ 和 $P_n$ 以交替方式重复获取它们各自需要的叉子（$P_{n-2}$ 需要 $R_{n-1}$，$P_n$ 需要 $R_n$），使得 $P_{n-1}$ 永远无法同时获得 $R_{n-1}$ 和 $R_n$。该策略本身没有提供确保公平性的机制。\n结论：**不正确**。",
            "answer": "$$\\boxed{AD}$$"
        },
        {
            "introduction": "预防虽好，但我们还需要为已经发生的死锁准备解决方案。这个练习探讨了死锁的恢复机制，特别是通过“资源抢占”来打破僵局。你将分析一个已经形成循环的资源分配图，其中包含一个可抢占资源（如 CPU）和一个不可抢占资源（如打印机），并推演操作系统如何通过强制收回可抢占资源来打破死锁循环，使系统恢复正常运行。",
            "id": "3677400",
            "problem": "考虑一个操作系统导论课程中的以下场景。资源分配图（RAG）是一个有向二分图，其节点为进程和资源，并包含两种类型的边：从进程到资源的请求边（表示为 $P_i \\to R_j$），代表进程 $P_i$ 正在等待资源 $R_j$；以及从资源到进程的分配边（表示为 $R_j \\to P_i$），代表资源 $R_j$ 当前由进程 $P_i$ 持有。当一组进程被阻塞，每个进程都在等待该集合中另一个进程所持有的资源时，系统就处于死锁状态；对于单实例资源类型，RAG中存在有向环是死锁的充分必要条件。\n\n假设有 $2$ 个进程 $P_1$ 和 $P_2$，以及 $2$ 种资源类型：一个中央处理器（CPU），建模为单实例资源 $R_{cpu}$；以及一个打印机，建模为单实例资源 $R_{printer}$。CPU $R_{cpu}$ 是可抢占的，这意味着操作系统可以强制将其从一个进程中解除分配并重新分配给其他进程，而打印机 $R_{printer}$ 是不可抢占的，这意味着一旦分配就不能被强制收回。\n\n最初，RAG 具有以下边：\n- $R_{printer} \\to P_1$ （打印机被分配给 $P_1$），\n- $P_1 \\to R_{cpu}$ （进程 $P_1$ 请求 CPU），\n- $R_{cpu} \\to P_2$ （CPU 被分配给 $P_2$），\n- $P_2 \\to R_{printer}$ （进程 $P_2$ 请求打印机）。\n\n这形成了一个环路\n$$\nP_1 \\to R_{cpu} \\to P_2 \\to R_{printer} \\to P_1.\n$$\n\n基于RAG和死锁的基本定义，评估允许抢占 $R_{cpu}$ 对上述环路的影响。哪个陈述最能描述抢占 $R_{cpu}$ 是否能打破本会导致死锁的环路，并解释原因？\n\nA. 允许抢占 $R_{cpu}$ 可以通过从 $P_2$ 抢占 $R_{cpu}$ 并将其分配给 $P_1$ 来打破环路，使 $P_1$ 能够运行并最终释放 $R_{printer}$，从而防止死锁。\n\nB. 无论抢占策略如何，RAG中的环路总是意味着死锁，因此允许抢占 $R_{cpu}$ 不能打破环路或防止死锁。\n\nC. 只有当 $R_{printer}$ 也可抢占时，抢占 $R_{cpu}$ 才能打破环路；否则，环路必然持续存在，死锁依然存在。\n\nD. 当两种资源都是单实例时，抢占 $R_{cpu}$ 不能打破“持有并等待”条件；因此，环路依然存在，死锁不可避免。",
            "solution": "我们从核心定义开始。资源分配图（RAG）用有向边表示进程和资源：请求边 $P_i \\to R_j$ 表示进程 $P_i$ 正在等待资源 $R_j$，而分配边 $R_j \\to P_i$ 表示资源 $R_j$ 由进程 $P_i$ 持有。对于单实例资源类型，RAG中的有向环是死锁的充分必要条件：如果存在环路，则存在一组进程，其中每个进程都在等待该集合中另一个进程所持有的资源，从而无法取得进展。\n\n在给定的场景中，有 $2$ 个进程（$P_1$，$P_2$）和 $2$ 种单实例资源类型（$R_{cpu}$ 和 $R_{printer}$）。边如下：\n- $R_{printer} \\to P_1$，\n- $P_1 \\to R_{cpu}$，\n- $R_{cpu} \\to P_2$，\n- $P_2 \\to R_{printer}$。\n\n这创建了环路\n$$\nP_1 \\to R_{cpu} \\to P_2 \\to R_{printer} \\to P_1,\n$$\n在假设两种资源都不可抢占的情况下，这将意味着死锁，因为每个进程持有一个资源并等待另一个资源，两者都无法继续执行。\n\n然而，CPU $R_{cpu}$ 被明确规定是可抢占的。抢占意味着操作系统可以强制从 $P_2$ 解除分配 $R_{cpu}$，并将其重新分配给另一个进程，例如 $P_1$。在RAG中，从 $P_2$ 抢占 $R_{cpu}$ 会移除分配边 $R_{cpu} \\to P_2$。如果操作系统接着将 $R_{cpu}$ 分配给 $P_1$，图中将增加分配边 $R_{cpu} \\to P_1$，同时请求边 $P_1 \\to R_{cpu}$ 得到满足而被移除。之后，剩余的边是：\n- $R_{printer} \\to P_1$,\n- $R_{cpu} \\to P_1$,\n- $P_2 \\to R_{printer}$。\n\n这些边中没有环路：$P_2$ 请求 $R_{printer}$，它由 $P_1$ 持有，但 $P_1$ 同时持有 $R_{cpu}$ 和 $R_{printer}$，可以继续运行（使用 $R_{cpu}$）并完成使用 $R_{printer}$ 的临界区，最终释放 $R_{printer}$。一旦 $R_{printer}$ 被释放，$P_2$ 就可以获得 $R_{printer}$，系统得以继续运行而没有死锁。\n\n从死锁的四个必要条件——互斥、持有并等待、不可抢占和循环等待——来进行一般性描述，注意到允许对 $R_{cpu}$ 进行抢占使得该资源类型的“不可抢占”条件无效。通过移除分配边 $R_{cpu} \\to P_2$，循环等待条件被打破：先前存在的环路 $P_1 \\to R_{cpu} \\to P_2 \\to R_{printer} \\to P_1$ 不再存在，因为在关键的转换过程中 $R_{cpu}$ 不再由 $P_2$ 持有。因此，可以避免死锁。\n\n我们现在评估每个选项：\n\nA. 允许抢占 $R_{cpu}$ 可以通过从 $P_2$ 抢占 $R_{cpu}$ 并将其分配给 $P_1$ 来打破环路，使 $P_1$ 能够运行并最终释放 $R_{printer}$，从而防止死锁。这与上述推理一致。抢占 $R_{cpu}$ 移除了分配边 $R_{cpu} \\to P_2$，从而消除了环路，并将 $R_{cpu}$ 授予 $P_1$ 使其能够取得进展并释放 $R_{printer}$。结论 — 正确。\n\nB. 无论抢占策略如何，RAG中的环路总是意味着死锁，因此允许抢占 $R_{cpu}$ 不能打破环路或防止死锁。这是不正确的。“环路总是意味着死锁”这一说法仅在没有抢占的静态分配模型下对单实例资源成立。当资源可抢占时，操作系统可以改变分配状态，从而消除环路并防止死锁。结论 — 不正确。\n\nC. 只有当 $R_{printer}$ 也可抢占时，抢占 $R_{cpu}$ 才能打破环路；否则，环路必然持续存在，死锁依然存在。这是不正确的。如上所示，仅通过抢占 $R_{cpu}$ 就可以打破环路：移除 $R_{cpu} \\to P_2$ 就破坏了环路，即使 $R_{printer}$ 仍然是不可抢占的。打印机的不可抢占性并不妨碍通过CPU来打破环路。结论 — 不正确。\n\nD. 当两种资源都是单实例时，抢占 $R_{cpu}$ 不能打破“持有并等待”条件；因此，环路依然存在，死锁不可避免。这是不正确的。抢占 $R_{cpu}$ 通过迫使 $P_2$ 释放 $R_{cpu}$，明确地打破了 $P_2$ 的“持有并等待”条件。环路被消除，死锁得以避免。单实例状态并不能否定抢占在打破循环等待方面的作用。结论 — 不正确。\n\n因此，最佳描述由选项A给出。",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}