{
    "hands_on_practices": [
        {
            "introduction": "A common rule of thumb states that a cycle in a dependency graph implies a deadlock. This foundational exercise challenges that oversimplification by examining the crucial role of resource multiplicity. By analyzing a Resource-Allocation Graph (RAG)—a close cousin of the Wait-For Graph—you will explore the necessary versus sufficient conditions for deadlock, solidifying your understanding of why a cycle is only a guaranteed deadlock when all involved resources are single-instance .",
            "id": "3677342",
            "problem": "Consider a Resource-Allocation Graph (RAG) with process nodes $P_1$, $P_2$, $P_3$ and resource-type nodes $R_a$, $R_b$, $R_c$. Resource types $R_a$ and $R_b$ each have exactly $1$ instance. Resource type $R_c$ has $m$ identical instances, with $m > 1$. The current edges are:\n- An assignment edge $R_a \\rightarrow P_1$ (process $P_1$ holds $R_a$).\n- A request edge $P_1 \\rightarrow R_b$ (process $P_1$ requests $R_b$).\n- An assignment edge $R_b \\rightarrow P_2$ (process $P_2$ holds $R_b$).\n- A request edge $P_2 \\rightarrow R_c$ (process $P_2$ requests $1$ instance of $R_c$).\n- An assignment edge $R_c \\rightarrow P_3$ representing that $P_3$ holds exactly $1$ instance of $R_c$ (at least one instance of $R_c$ is allocated to $P_3$).\n- A request edge $P_3 \\rightarrow R_a$ (process $P_3$ requests $R_a$).\n\nThis forms a directed cycle involving $P_1$, $P_2$, $P_3$, $R_a$, $R_b$, $R_c$. Assume the standard deadlock conditions apply: mutual exclusion for each resource instance, hold-and-wait, no preemption, and circular wait is possible if the graph structure warrants it. No further information is given about how many of the remaining $m-1$ instances of $R_c$ are currently free or who holds them.\n\nSelect all statements that are correct under this model.\n\nA. For any $m > 1$, the existence of the cycle implies the system is deadlocked.\n\nB. When $m > 1$, the cycle alone does not guarantee deadlock; if at least one instance of $R_c$ is currently free, $P_2$ can be allocated $R_c$, potentially allowing a completion order that breaks the cycle.\n\nC. If instead $m = 1$ (so that $R_c$ also has a single instance), then the existence of the cycle is sufficient to conclude that the involved processes are deadlocked.\n\nD. Even with $m > 1$, if all $m$ instances of $R_c$ are held by processes on the same cycle and each process on the cycle holds at least one resource and is waiting for the next, then the system is in deadlock.",
            "solution": "The problem describes a state in a system with three processes $P_1, P_2, P_3$ and three resource types $R_a, R_b, R_c$. The number of instances are $1$ for $R_a$, $1$ for $R_b$, and $m > 1$ for $R_c$.\nThe Resource-Allocation Graph (RAG) contains the following dependencies:\n- $P_1$ holds $R_a$ and requests $R_b$: $R_a \\rightarrow P_1 \\rightarrow R_b$.\n- $P_2$ holds $R_b$ and requests $R_c$: $R_b \\rightarrow P_2 \\rightarrow R_c$.\n- $P_3$ holds an instance of $R_c$ and requests $R_a$: $R_c \\rightarrow P_3 \\rightarrow R_a$.\n\nThese dependencies form a directed cycle: $P_1 \\rightarrow R_b \\rightarrow P_2 \\rightarrow R_c \\rightarrow P_3 \\rightarrow R_a \\rightarrow P_1$. The problem is to determine which statements about deadlock are correct given this configuration.\n\nThe fundamental principles for deadlock detection using RAGs are:\n1.  If a RAG contains no cycles, then the system is not in a deadlocked state. A cycle is a necessary condition for deadlock.\n2.  If a RAG contains a cycle, one of two conditions holds:\n    a. If every resource type in the cycle has exactly one instance, then a deadlock exists. The cycle is a sufficient condition.\n    b. If there are resource types in the cycle with multiple instances, then a deadlock *may* exist, but is not guaranteed. The cycle is not a sufficient condition. A deadlock occurs if and only if for each process $P_i$ in the cycle waiting for a resource $R_j$, all instances of $R_j$ are held by other processes which are themselves blocked.\n\nThe cycle in question involves resource types $R_a$, $R_b$, and $R_c$. Resource types $R_a$ and $R_b$ have $1$ instance each, but $R_c$ has $m > 1$ instances. Therefore, we are in case 2.b: the cycle is a necessary but not sufficient condition for deadlock. The state of the other $m-1$ instances of $R_c$ is critical.\n\nLet's evaluate each option based on these principles.\n\nA. For any $m > 1$, the existence of the cycle implies the system is deadlocked.\nThis statement claims that the cycle is a sufficient condition for deadlock, irrespective of the number of instances $m > 1$. As established by principle 2.b, this is false. A cycle involving a multi-instance resource type is not sufficient to prove deadlock. For a counterexample, consider the case where one of the $m-1$ currently un-accounted-for instances of $R_c$ is free. The system could grant this free instance to $P_2$, breaking the wait condition.\nVerdict: **Incorrect**.\n\nB. When $m > 1$, the cycle alone does not guarantee deadlock; if at least one instance of $R_c$ is currently free, $P_2$ can be allocated $R_c$, potentially allowing a completion order that breaks the cycle.\nThis statement correctly identifies that the cycle is not a sufficient condition for deadlock when $m > 1$. It also provides the correct reasoning. If a free instance of $R_c$ exists, it can be allocated to $P_2$. Assuming $P_2$ eventually completes its task, it will release its resources, including $R_b$. The release of $R_b$ allows $P_1$ to proceed. Upon completion, $P_1$ releases $R_a$, which in turn allows $P_3$ to proceed. This sequence of events, known as breaking the cycle, demonstrates that no deadlock is present in this scenario.\nVerdict: **Correct**.\n\nC. If instead $m = 1$ (so that $R_c$ also has a single instance), then the existence of the cycle is sufficient to conclude that the involved processes are deadlocked.\nThis statement proposes a hypothetical alteration where $m=1$. In this case, all resource types in the cycle ($R_a$, $R_b$, and $R_c$) have exactly one instance. According to principle 2.a, a cycle in a RAG where all involved resources are single-instance is a sufficient condition for deadlock. The wait chain becomes unbreakable:\n- $P_1$ waits for $R_b$, which is held by $P_2$.\n- $P_2$ waits for $R_c$, which is held by $P_3$.\n- $P_3$ waits for $R_a$, which is held by $P_1$.\nNo process in this cycle can ever acquire the resource it is waiting for, as the resource is held by another waiting process in the same cycle. Thus, a deadlock is guaranteed.\nVerdict: **Correct**.\n\nD. Even with $m > 1$, if all $m$ instances of $R_c$ are held by processes on the same cycle and each process on the cycle holds at least one resource and is waiting for the next, then the system is in deadlock.\nThis statement provides an additional condition to the original problem where $m > 1$. The condition is that all $m$ instances of $R_c$ are held by processes within the cycle $\\{P_1, P_2, P_3\\}$. We know $P_3$ holds one instance of $R_c$. We also know $P_2$ is requesting an instance of $R_c$, so it cannot be holding one. Therefore, this condition implies that the remaining $m-1$ instances of $R_c$ must be held by $P_1$ and/or $P_3$. Let's analyze the state of the processes:\n- $P_1$ is waiting for $R_b$. It is blocked.\n- $P_3$ is waiting for $R_a$. It is blocked.\n- $P_2$ is waiting for an instance of $R_c$.\nUnder the given condition, all $m$ instances of $R_c$ are allocated. The holders are a subset of $\\{P_1, P_3\\}$. Since both $P_1$ and $P_3$ are themselves blocked and part of the cycle, they will not release their instances of $R_c$. Consequently, there are no free instances of $R_c$ for $P_2$ to acquire, and no prospect of any becoming free. Thus, $P_2$ is also blocked. Since every process in the cycle $\\{P_1, P_2, P_3\\}$ is blocked waiting for a resource held by another blocked process in the cycle, the system is in a deadlocked state. The statement accurately describes a sufficient condition for deadlock in a multi-instance resource scenario.\nVerdict: **Correct**.",
            "answer": "$$\\boxed{BCD}$$"
        },
        {
            "introduction": "In any large concurrent system, the Wait-For Graph (WFG) can become a complex web of dependencies, making a simple visual inspection for cycles impractical. This practice introduces a formal, algorithmic approach to deadlock analysis using the concept of Strongly Connected Components (SCCs) . You will learn to decompose a WFG into its SCCs and classify each component as deadlocked, at risk of deadlock, or safe, providing a comprehensive assessment of the system's state.",
            "id": "3689961",
            "problem": "Consider a directed Wait-For Graph (WFG) on processes $\\{P_1, P_2, \\dots, P_{12}\\}$, where a directed edge $P_i \\rightarrow P_j$ denotes that process $P_i$ is waiting for process $P_j$. The Strongly Connected Component (SCC) decomposition partitions the vertex set into maximal subsets in which every vertex is reachable from every other vertex in the subset via directed paths. Tarjan’s algorithm is a linear-time method for computing SCCs. In operating systems with single-instance resources, a deadlock can occur when there is a subset of processes that are mutually waiting in a directed cycle and have no waiting edges to processes outside that subset.\n\nYou are given the WFG $G$ with the following directed edges:\n- $P_1 \\rightarrow P_2$\n- $P_2 \\rightarrow P_3$\n- $P_3 \\rightarrow P_1$\n- $P_4 \\rightarrow P_5$\n- $P_5 \\rightarrow P_4$\n- $P_5 \\rightarrow P_6$\n- $P_6 \\rightarrow P_1$\n- $P_7 \\rightarrow P_7$\n- $P_7 \\rightarrow P_8$\n- $P_8 \\rightarrow P_9$\n- $P_9 \\rightarrow P_{10}$\n- $P_{10} \\rightarrow P_9$\n- $P_{10} \\rightarrow P_{12}$\n- $P_{11} \\rightarrow P_2$\n- $P_{11} \\rightarrow P_8$\n- $P_{12} \\rightarrow P_{12}$\n\nApply Tarjan’s algorithm to extract all SCCs of $G$. Then classify each SCC based on the following criteria, which rely on in-degree/out-degree patterns in the condensation graph and the presence of cycles or self-loops:\n- Safe: an SCC that contains no directed cycle (equivalently, an SCC of size $1$ with no self-loop).\n- Risky: an SCC that contains a directed cycle (either size at least $2$, or size $1$ with a self-loop) and has at least one outgoing edge to a different SCC in the condensation graph.\n- Deadlocked: an SCC that contains a directed cycle (either size at least $2$, or size $1$ with a self-loop) and has zero outgoing edges in the condensation graph.\n\nLet $S_{\\text{dead}}$ be the sum of the sizes (number of processes) of all deadlocked SCCs, and let $S_{\\text{risk}}$ be the sum of the sizes of all risky SCCs. Compute the value\n$$X \\;=\\; 3\\,S_{\\text{dead}} \\;+\\; 2\\,S_{\\text{risk}}.$$\nExpress your final answer as an integer. No rounding is required.",
            "solution": "The solution consists of three main parts:\n1.  Identifying the Strongly Connected Components (SCCs) of the graph $G$.\n2.  Classifying each SCC as Safe, Risky, or Deadlocked based on the given criteria.\n3.  Calculating the values of $S_{\\text{dead}}$, $S_{\\text{risk}}$, and finally $X$.\n\n### 1. Identifying the SCCs\nAn SCC is a maximal subgraph where for any two vertices $u, v$ in the subgraph, there is a path from $u$ to $v$ and a path from $v$ to $u$. By inspecting the edge list, we can identify the following SCCs:\n\n-   A cycle $P_1 \\to P_2 \\to P_3 \\to P_1$ means $\\{P_1, P_2, P_3\\}$ is an SCC. Let's call it $C_1$.\n-   A cycle $P_4 \\to P_5 \\to P_4$ means $\\{P_4, P_5\\}$ is an SCC. Let's call it $C_2$.\n-   A cycle $P_9 \\to P_{10} \\to P_{9}$ means $\\{P_9, P_{10}\\}$ is an SCC. Let's call it $C_6$.\n-   A self-loop $P_7 \\to P_7$ means $\\{P_7\\}$ is an SCC. Let's call it $C_4$.\n-   A self-loop $P_{12} \\to P_{12}$ means $\\{P_{12}\\}$ is an SCC. Let's call it $C_8$.\n-   The remaining processes $\\{P_6\\}, \\{P_8\\}, \\{P_{11}\\}$ do not belong to any non-trivial cycles and form their own SCCs of size 1. Let's call them $C_3, C_5, C_7$ respectively.\n\nThe set of SCCs is:\n-   $C_1 = \\{P_1, P_2, P_3\\}$\n-   $C_2 = \\{P_4, P_5\\}$\n-   $C_3 = \\{P_6\\}$\n-   $C_4 = \\{P_7\\}$\n-   $C_5 = \\{P_8\\}$\n-   $C_6 = \\{P_9, P_{10}\\}$\n-   $C_7 = \\{P_{11}\\}$\n-   $C_8 = \\{P_{12}\\}$\n\n### 2. Classifying the SCCs\nWe classify each SCC based on whether it contains a cycle and its connectivity to other SCCs.\n\n-   **$C_1 = \\{P_1, P_2, P_3\\}$**:\n    -   Cycle: Yes (size is $3 > 1$).\n    -   Outgoing edges: None. All edges are internal to $C_1$.\n    -   Classification: **Deadlocked**. Size is $3$.\n\n-   **$C_2 = \\{P_4, P_5\\}$**:\n    -   Cycle: Yes (size is $2 > 1$).\n    -   Outgoing edges: $P_5 \\to P_6$. Since $P_6 \\in C_3$, this is an outgoing edge from $C_2$ to $C_3$.\n    -   Classification: **Risky**. Size is $2$.\n\n-   **$C_3 = \\{P_6\\}$**:\n    -   Cycle: No (size is $1$ and no self-loop).\n    -   Classification: **Safe**. Size is $1$.\n\n-   **$C_4 = \\{P_7\\}$**:\n    -   Cycle: Yes (self-loop $P_7 \\to P_7$).\n    -   Outgoing edges: $P_7 \\to P_8$. Since $P_8 \\in C_5$, this is an outgoing edge from $C_4$ to $C_5$.\n    -   Classification: **Risky**. Size is $1$.\n\n-   **$C_5 = \\{P_8\\}$**:\n    -   Cycle: No (size is $1$ and no self-loop).\n    -   Classification: **Safe**. Size is $1$.\n\n-   **$C_6 = \\{P_9, P_{10}\\}$**:\n    -   Cycle: Yes (size is $2 > 1$).\n    -   Outgoing edges: $P_{10} \\to P_{12}$. Since $P_{12} \\in C_8$, this is an outgoing edge from $C_6$ to $C_8$.\n    -   Classification: **Risky**. Size is $2$.\n\n-   **$C_7 = \\{P_{11}\\}$**:\n    -   Cycle: No (size is $1$ and no self-loop).\n    -   Classification: **Safe**. Size is $1$.\n\n-   **$C_8 = \\{P_{12}\\}$**:\n    -   Cycle: Yes (self-loop $P_{12} \\to P_{12}$).\n    -   Outgoing edges: None.\n    -   Classification: **Deadlocked**. Size is $1$.\n\n### 3. Final Calculation\nNow, we compute $S_{\\text{dead}}$ and $S_{\\text{risk}}$.\n\n-   The deadlocked SCCs are $C_1$ (size $3$) and $C_8$ (size $1$).\n    $$S_{\\text{dead}} = |C_1| + |C_8| = 3 + 1 = 4$$\n\n-   The risky SCCs are $C_2$ (size $2$), $C_4$ (size $1$), and $C_6$ (size $2$).\n    $$S_{\\text{risk}} = |C_2| + |C_4| + |C_6| = 2 + 1 + 2 = 5$$\n\nFinally, we compute the value of $X$:\n$$X = 3S_{\\text{dead}} + 2S_{\\text{risk}} = 3(4) + 2(5) = 12 + 10 = 22$$",
            "answer": "$$\\boxed{22}$$"
        },
        {
            "introduction": "Now, let's apply these concepts to a classic, practical scenario from database systems: concurrency control using Two-Phase Locking (2PL). This exercise requires you to construct a Wait-For Graph directly from a snapshot of a lock manager's state, including the subtle but important case of lock upgrades (e.g., from a Shared ($S$) lock to an Exclusive ($X$) lock). By analyzing the resulting graph, you will not only detect a deadlock but also explore how a simple, priority-based policy can resolve it, demonstrating how WFG analysis informs the design of real-world concurrency protocols .",
            "id": "3632180",
            "problem": "In a database system using Two-Phase Locking (2PL), consider a snapshot of the lock table with transactions $T_1, T_2, T_3, T_4, T_5, T_6$ and resources $R_a, R_b, R_c$. Locks can be Shared ($S$) or Exclusive ($X$), and a transaction can request an upgrade from $S$ to $X$ on a resource it already holds in $S$. A request waits if and only if it conflicts with currently held locks according to the standard lock compatibility for $S$ and $X$: $S$ is compatible with $S$, and $X$ is incompatible with both $S$ and $X$. The snapshot is the following.\n\n- On resource $R_a$: current holders are $T_1$ with $S$ and $T_2$ with $S$. The pending queue is, in order, $T_1$ requesting an upgrade from $S$ to $X$, then $T_3$ requesting a fresh $X$ lock.\n- On resource $R_b$: current holders are $T_3$ with $S$. The pending queue is, in order, $T_2$ requesting $X$, then $T_4$ requesting $X$.\n- On resource $R_c$: current holders are $T_4$ with $S$ and $T_5$ with $S$. The pending queue is, in order, $T_4$ requesting an upgrade from $S$ to $X$, then $T_5$ requesting an upgrade from $S$ to $X$, then $T_6$ requesting a fresh $X$ lock.\n\nAssume that no transaction is in its shrinking phase, i.e., no held lock will be released until commit or abort as per Two-Phase Locking (2PL). Let the transaction start times be $s(T_1)=10$, $s(T_2)=20$, $s(T_3)=15$, $s(T_4)=40$, $s(T_5)=35$, $s(T_6)=50$, where smaller $s(\\cdot)$ means older.\n\nTask:\n1. Using the definition of a Wait-For Graph (WFG), where a directed edge $T_i \\to T_j$ exists if and only if transaction $T_i$ is currently blocked by a lock held by transaction $T_j$, construct the WFG for the snapshot above. In this construction, consider only conflicts with currently held locks (not queued but ungranted requests), and include upgrade requests as conflicts with any other transaction currently holding incompatible locks on the same resource.\n2. Run a simple deadlock detector that identifies deadlocks by finding directed cycles via strongly connected components (a strongly connected component of size at least $2$ indicates a cycle and hence a deadlock in the WFG under 2PL).\n3. Now, reason from first principles why lock upgrade requests can induce phantom cycles in the WFG when multiple transactions simultaneously hold $S$ on a resource and both request $X$ upgrades. Propose an improvement to avoid such phantom cycles that remains compatible with 2PL. Specifically, adopt an oldest-first upgrade ordering on a single resource based on the start times $s(T_i)$: for simultaneous $S \\to X$ upgrade requests on one resource, direct any wait-for relation from the younger upgrader toward the older upgrader and eliminate the reverse edge between those upgraders when the only mutual conflict arises from their shared locks on that same resource.\n4. Apply the improvement in part $3$ to the snapshot above and recompute the count of strongly connected components of the WFG that have size at least $2$.\n\nExpress your final answer as the integer count from part $4$. No rounding is needed. The final answer must be a single real-valued number.",
            "solution": "The problem requires the analysis of a database system snapshot for deadlocks, first using a standard Wait-For Graph (WFG) construction and then using a modified construction rule designed to handle lock upgrade requests.\n\nThe transaction start times are given as: $s(T_1)=10$, $s(T_2)=20$, $s(T_3)=15$, $s(T_4)=40$, $s(T_5)=35$, $s(T_6)=50$. The age ordering of transactions, from oldest to youngest, is therefore: $T_1  T_3  T_2  T_5  T_4  T_6$.\n\n### Part 1: Construction of the Initial Wait-For Graph (WFG)\n\nA directed edge $T_i \\to T_j$ is added to the WFG if transaction $T_i$ requests a lock that conflicts with a lock currently held by transaction $T_j$. We analyze the conflicts for each resource based on the provided snapshot.\n\n**Resource $R_a$**:\n- Current state: $T_1$ holds $S$, $T_2$ holds $S$.\n- Pending requests:\n    1. $T_1$ requests an upgrade from $S$ to $X$. This conflicts with the $S$ lock held by $T_2$. Thus, $T_1$ must wait for $T_2$, creating the edge $T_1 \\to T_2$.\n    2. $T_3$ requests an $X$ lock. This conflicts with the $S$ locks held by both $T_1$ and $T_2$. Thus, $T_3$ must wait for both $T_1$ and $T_2$, creating the edges $T_3 \\to T_1$ and $T_3 \\to T_2$.\n\n**Resource $R_b$**:\n- Current state: $T_3$ holds $S$.\n- Pending requests:\n    1. $T_2$ requests an $X$ lock. This conflicts with the $S$ lock held by $T_3$. Thus, $T_2$ waits for $T_3$, creating the edge $T_2 \\to T_3$.\n    2. $T_4$ requests an $X$ lock. This also conflicts with the $S$ lock held by $T_3$. Thus, $T_4$ waits for $T_3$, creating the edge $T_4 \\to T_3$.\n\n**Resource $R_c$**:\n- Current state: $T_4$ holds $S$, $T_5$ holds $S$.\n- Pending requests:\n    1. $T_4$ requests an upgrade from $S$ to $X$. This conflicts with the $S$ lock held by $T_5$. Thus, $T_4$ waits for $T_5$, creating the edge $T_4 \\to T_5$.\n    2. $T_5$ requests an upgrade from $S$ to $X$. This conflicts with the $S$ lock held by $T_4$. Thus, $T_5$ waits for $T_4$, creating the edge $T_5 \\to T_4$.\n    3. $T_6$ requests an $X$ lock. This conflicts with the $S$ locks held by both $T_4$ and $T_5$. Thus, $T_6$ waits for both $T_4$ and $T_5$, creating the edges $T_6 \\to T_4$ and $T_6 \\to T_5$.\n\nThe complete set of edges in the initial WFG is:\n$E = \\{ (T_1, T_2), (T_3, T_1), (T_3, T_2), (T_2, T_3), (T_4, T_3), (T_4, T_5), (T_5, T_4), (T_6, T_4), (T_6, T_5) \\}$.\n\n### Part 2: Deadlock Detection in the Initial WFG\n\nA deadlock is indicated by a cycle in the WFG, which corresponds to a strongly connected component (SCC) of size at least $2$. We inspect the graph for such cycles.\n- **Cycle 1**: $T_1 \\to T_2 \\to T_3 \\to T_1$. This forms a cycle involving three transactions. The set $\\{T_1, T_2, T_3\\}$ is an SCC of size $3$.\n- **Cycle 2**: $T_4 \\to T_5 \\to T_4$. Both edges arise from the simultaneous upgrade requests on resource $R_c$. The set $\\{T_4, T_5\\}$ is an SCC of size $2$.\nIn the initial WFG, there are two deadlocks (two SCCs of size $\\ge 2$).\n\n### Part 3: Rationale for Phantom Cycles and the Proposed Improvement\n\nThe problem describes the situation on resource $R_c$, where two transactions, $T_4$ and $T_5$, both hold an $S$ lock and subsequently both request an $X$ lock upgrade. $T_4$'s upgrade request is blocked by $T_5$'s held $S$ lock ($T_4 \\to T_5$), and symmetrically, $T_5$'s upgrade request is blocked by $T_4$'s held $S$ lock ($T_5 \\to T_4$). This results in a cycle $T_4 \\leftrightarrow T_5$. This is a genuine deadlock state, often called a conversion deadlock. The proposed improvement is an `oldest-first` upgrade ordering policy. For simultaneous upgrade requests on a single resource, priority is given to the oldest transaction. The wait-for edge is directed from the younger upgrader to the older one, and the reverse edge is eliminated, thus breaking the cycle deterministically.\n\n### Part 4: Application of the Improvement and Final Count\n\nWe apply the `oldest-first` rule to the upgrade requests on resource $R_c$.\n- The start times are $s(T_4) = 40$ and $s(T_5) = 35$.\n- $T_5$ is older than $T_4$.\n- According to the rule, the younger transaction ($T_4$) must wait for the older one ($T_5$). This establishes the edge $T_4 \\to T_5$.\n- The reverse edge, $T_5 \\to T_4$, is eliminated.\n\nThe new, improved WFG has the following set of edges:\n$E' = \\{ (T_1, T_2), (T_3, T_1), (T_3, T_2), (T_2, T_3), (T_4, T_3), (T_4, T_5), (T_6, T_4), (T_6, T_5) \\}$.\nThis is the original set $E$ with the edge $(T_5, T_4)$ removed.\n\nNow we find the SCCs of size $\\ge 2$ in this modified graph:\n- The cycle $T_1 \\to T_2 \\to T_3 \\to T_1$ is unaffected. Therefore, $\\{T_1, T_2, T_3\\}$ remains an SCC of size $3$.\n- The cycle $T_4 \\leftrightarrow T_5$ has been broken by the removal of the edge $(T_5, T_4)$. There is now only a path from $T_4$ to $T_5$, but no path from $T_5$ back to $T_4$. No other cycles involving $\\{T_4, T_5, T_6\\}$ exist.\n- Therefore, the only SCC with size $\\ge 2$ in the modified WFG is $\\{T_1, T_2, T_3\\}$.\n\nThe count of strongly connected components of size at least $2$ in the improved WFG is $1$.",
            "answer": "$$\\boxed{1}$$"
        }
    ]
}