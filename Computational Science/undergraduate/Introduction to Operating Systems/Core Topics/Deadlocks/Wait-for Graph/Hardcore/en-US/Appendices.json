{
    "hands_on_practices": [
        {
            "introduction": "The first step in using a wait-for graph for deadlock detection is translating a system's current state of resource allocation and requests into a formal graph structure. This practice exercise challenges you to do just that, using a realistic snapshot from a database system that employs shared and exclusive locks. By constructing the graph from scratch and identifying wait dependencies, including those from complex lock upgrade requests, you will develop the foundational skill of modeling system states to diagnose deadlocks .",
            "id": "3632180",
            "problem": "In a database system using Two-Phase Locking (2PL), consider a snapshot of the lock table with transactions $T_1, T_2, T_3, T_4, T_5, T_6$ and resources $R_a, R_b, R_c$. Locks can be Shared ($S$) or Exclusive ($X$), and a transaction can request an upgrade from $S$ to $X$ on a resource it already holds in $S$. A request waits if and only if it conflicts with currently held locks according to the standard lock compatibility for $S$ and $X$: $S$ is compatible with $S$, and $X$ is incompatible with both $S$ and $X$. The snapshot is the following.\n\n- On resource $R_a$: current holders are $T_1$ with $S$ and $T_2$ with $S$. The pending queue is, in order, $T_1$ requesting an upgrade from $S$ to $X$, then $T_3$ requesting a fresh $X$ lock.\n- On resource $R_b$: current holders are $T_3$ with $S$. The pending queue is, in order, $T_2$ requesting $X$, then $T_4$ requesting $X$.\n- On resource $R_c$: current holders are $T_4$ with $S$ and $T_5$ with $S$. The pending queue is, in order, $T_4$ requesting an upgrade from $S$ to $X$, then $T_5$ requesting an upgrade from $S$ to $X$, then $T_6$ requesting a fresh $X$ lock.\n\nAssume that no transaction is in its shrinking phase, i.e., no held lock will be released until commit or abort as per Two-Phase Locking (2PL). Let the transaction start times be $s(T_1)=10$, $s(T_2)=20$, $s(T_3)=15$, $s(T_4)=40$, $s(T_5)=35$, $s(T_6)=50$, where smaller $s(\\cdot)$ means older.\n\nTask:\n1. Using the definition of a Wait-For Graph (WFG), where a directed edge $T_i \\to T_j$ exists if and only if transaction $T_i$ is currently blocked by a lock held by transaction $T_j$, construct the WFG for the snapshot above. In this construction, consider only conflicts with currently held locks (not queued but ungranted requests), and include upgrade requests as conflicts with any other transaction currently holding incompatible locks on the same resource.\n2. Run a simple deadlock detector that identifies deadlocks by finding directed cycles via strongly connected components (a strongly connected component of size at least $2$ indicates a cycle and hence a deadlock in the WFG under 2PL).\n3. Now, reason from first principles why lock upgrade requests can induce phantom cycles in the WFG when multiple transactions simultaneously hold $S$ on a resource and both request $X$ upgrades. Propose an improvement to avoid such phantom cycles that remains compatible with 2PL. Specifically, adopt an oldest-first upgrade ordering on a single resource based on the start times $s(T_i)$: for simultaneous $S \\to X$ upgrade requests on one resource, direct any wait-for relation from the younger upgrader toward the older upgrader and eliminate the reverse edge between those upgraders when the only mutual conflict arises from their shared locks on that same resource.\n4. Apply the improvement in part $3$ to the snapshot above and recompute the count of strongly connected components of the WFG that have size at least $2$.\n\nExpress your final answer as the integer count from part $4$. No rounding is needed. The final answer must be a single integer.",
            "solution": "The problem requires the analysis of a database system snapshot for deadlocks, first using a standard Wait-For Graph (WFG) construction and then using a modified construction rule designed to handle lock upgrade requests.\n\nFirst, the givens are validated. The problem provides a set of transactions $\\{T_1, T_2, T_3, T_4, T_5, T_6\\}$, a set of resources $\\{R_a, R_b, R_c\\}$, the state of held locks and pending requests for each resource, and the start times $s(T_i)$ for each transaction. The rules for lock compatibility ($S$ with $S$; $X$ with none), WFG edge creation, and a specific improvement for handling upgrade deadlocks are all explicitly defined. The problem is scientifically grounded in database concurrency control theory, well-posed, objective, and internally consistent. It is therefore deemed a valid problem.\n\nThe solution proceeds in four parts as delineated by the task description.\n\nThe transaction start times are given as: $s(T_1)=10$, $s(T_2)=20$, $s(T_3)=15$, $s(T_4)=40$, $s(T_5)=35$, $s(T_6)=50$. The age ordering of transactions, from oldest to youngest, is therefore: $T_1  T_3  T_2  T_5  T_4  T_6$.\n\n### Part 1: Construction of the Initial Wait-For Graph (WFG)\n\nA directed edge $T_i \\to T_j$ is added to the WFG if transaction $T_i$ requests a lock that conflicts with a lock currently held by transaction $T_j$. We analyze the conflicts for each resource based on the provided snapshot.\n\n**Resource $R_a$**:\n- Current state: $T_1$ holds $S$, $T_2$ holds $S$.\n- Pending requests:\n    1. $T_1$ requests an upgrade from $S$ to $X$. This request conflicts with the $S$ lock held by $T_2$. An $X$ lock is incompatible with an $S$ lock. Thus, $T_1$ must wait for $T_2$. This creates the edge $T_1 \\to T_2$.\n    2. $T_3$ requests an $X$ lock. This request conflicts with the $S$ locks held by both $T_1$ and $T_2$. Thus, $T_3$ must wait for both $T_1$ and $T_2$. This creates the edges $T_3 \\to T_1$ and $T_3 \\to T_2$.\n\n**Resource $R_b$**:\n- Current state: $T_3$ holds $S$.\n- Pending requests:\n    1. $T_2$ requests an $X$ lock. This conflicts with the $S$ lock held by $T_3$. Thus, $T_2$ waits for $T_3$. This creates the edge $T_2 \\to T_3$.\n    2. $T_4$ requests an $X$ lock. This also conflicts with the $S$ lock held by $T_3$. Thus, $T_4$ waits for $T_3$. This creates the edge $T_4 \\to T_3$.\n\n**Resource $R_c$**:\n- Current state: $T_4$ holds $S$, $T_5$ holds $S$.\n- Pending requests:\n    1. $T_4$ requests an upgrade from $S$ to $X$. This conflicts with the $S$ lock held by $T_5$. Thus, $T_4$ waits for $T_5$, creating the edge $T_4 \\to T_5$.\n    2. $T_5$ requests an upgrade from $S$ to $X$. This conflicts with the $S$ lock held by $T_4$. Thus, $T_5$ waits for $T_4$, creating the edge $T_5 \\to T_4$.\n    3. $T_6$ requests an $X$ lock. This conflicts with the $S$ locks held by both $T_4$ and $T_5$. Thus, $T_6$ waits for both $T_4$ and $T_5$. This creates the edges $T_6 \\to T_4$ and $T_6 \\to T_5$.\n\nThe complete set of edges in the initial WFG is:\n$E = \\{ (T_1, T_2), (T_3, T_1), (T_3, T_2), (T_2, T_3), (T_4, T_3), (T_4, T_5), (T_5, T_4), (T_6, T_4), (T_6, T_5) \\}$.\n\n### Part 2: Deadlock Detection in the Initial WFG\n\nA deadlock is indicated by a cycle in the WFG, which corresponds to a strongly connected component (SCC) of size at least $2$. We inspect the graph for such cycles.\n\n- **Cycle 1**: $T_1 \\to T_2 \\to T_3 \\to T_1$. The edge $T_1 \\to T_2$ is from the conflict on $R_a$. The edge $T_2 \\to T_3$ is from $R_b$. The edge $T_3 \\to T_1$ is from $R_a$. This forms a cycle involving three transactions. The set $\\{T_1, T_2, T_3\\}$ is an SCC of size $3$.\n- **Cycle 2**: $T_4 \\to T_5 \\to T_4$. Both edges arise from the simultaneous upgrade requests on resource $R_c$. This is a classic conversion deadlock. The set $\\{T_4, T_5\\}$ is an SCC of size $2$.\n\nThus, in the initial WFG, there are two deadlocks.\n\n### Part 3: Rationale for Phantom Cycles and the Proposed Improvement\n\nThe problem refers to \"phantom cycles\" induced by lock upgrades. This term describes the situation on resource $R_c$, where two transactions, $T_4$ and $T_5$, both hold an $S$ lock and subsequently both request an $X$ lock upgrade. $T_4$'s upgrade request is blocked by $T_5$'s held $S$ lock (creating edge $T_4 \\to T_5$), and symmetrically, $T_5$'s upgrade request is blocked by $T_4$'s held $S$ lock (creating edge $T_5 \\to T_4$). This results in a cycle $T_4 \\leftrightarrow T_5$. This is a genuine deadlock state, but it is sometimes called a \"phantom\" or \"resolvable\" deadlock because it has a special structure that can be broken by a deterministic policy in the lock manager, unlike more complex deadlocks spanning multiple resources.\n\nThe proposed improvement is one such policy: an `oldest-first` upgrade ordering. For simultaneous upgrade requests on a single resource, the wait relationship is not symmetric. Instead, priority is given to the oldest transaction. The rule states that the wait-for edge should be directed from the younger upgrader to the older one, and the reverse edge is eliminated. This breaks the symmetry and prevents the cycle from forming in the WFG.\n\n### Part 4: Application of the Improvement and Final Count\n\nWe apply the `oldest-first` rule to the snapshot. The only place this rule is applicable is on resource $R_c$, where both $T_4$ and $T_5$ request upgrades.\n- The start times are $s(T_4) = 40$ and $s(T_5) = 35$.\n- $T_5$ is older than $T_4$.\n- According to the rule, the younger transaction ($T_4$) must wait for the older one ($T_5$). This establishes the edge $T_4 \\to T_5$.\n- The reverse edge, $T_5 \\to T_4$, which would represent the older transaction waiting for the younger one, is eliminated.\n\nAll other wait-for relationships remain as they were in Part 1. The new, improved WFG has the following set of edges:\n$E' = \\{ (T_1, T_2), (T_3, T_1), (T_3, T_2), (T_2, T_3), (T_4, T_3), (T_4, T_5), (T_6, T_4), (T_6, T_5) \\}$.\nThis is the original set $E$ with the edge $(T_5, T_4)$ removed.\n\nNow we find the SCCs of size $\\ge 2$ in this modified graph:\n- The cycle $T_1 \\to T_2 \\to T_3 \\to T_1$ is entirely unaffected by the change, as it involves different transactions and resources. Therefore, $\\{T_1, T_2, T_3\\}$ remains an SCC of size $3$. This corresponds to one deadlock.\n- The cycle $T_4 \\to T_5 \\to T_4$ has been broken by the removal of the edge $T_5 \\to T_4$. There is now only a path from $T_4$ to $T_5$, but no path from $T_5$ back to $T_4$. The nodes $\\{T_4, T_5, T_6\\}$ do not form or belong to any other cycles. The subgraph induced by these nodes is a directed acyclic graph (DAG).\n- Therefore, the only SCC with size $\\ge 2$ in the modified WFG is $\\{T_1, T_2, T_3\\}$.\n\nThe number of strongly connected components of size at least $2$ in the improved WFG is $1$.",
            "answer": "$$\\boxed{1}$$"
        },
        {
            "introduction": "Once a wait-for graph is constructed, we need a systematic method to analyze it for deadlocks, especially in large, complex systems. This exercise moves beyond simple visual inspection to a formal, algorithmic approach based on a graph's Strongly Connected Components (SCCs). You will classify these components to distinguish between process sets that are definitively deadlocked and those that are merely at risk, providing insight into how automated deadlock detectors operate in real-world operating systems .",
            "id": "3689961",
            "problem": "Consider a directed Wait-For Graph (WFG) on processes $\\{P_1, P_2, \\dots, P_{12}\\}$, where a directed edge $P_i \\rightarrow P_j$ denotes that process $P_i$ is waiting for process $P_j$. The Strongly Connected Component (SCC) decomposition partitions the vertex set into maximal subsets in which every vertex is reachable from every other vertex in the subset via directed paths. Tarjan’s algorithm is a linear-time method for computing SCCs. In operating systems with single-instance resources, a deadlock can occur when there is a subset of processes that are mutually waiting in a directed cycle and have no waiting edges to processes outside that subset.\n\nYou are given the WFG $G$ with the following directed edges:\n- $P_1 \\rightarrow P_2$\n- $P_2 \\rightarrow P_3$\n- $P_3 \\rightarrow P_1$\n- $P_4 \\rightarrow P_5$\n- $P_5 \\rightarrow P_4$\n- $P_5 \\rightarrow P_6$\n- $P_6 \\rightarrow P_1$\n- $P_7 \\rightarrow P_7$\n- $P_7 \\rightarrow P_8$\n- $P_8 \\rightarrow P_9$\n- $P_9 \\rightarrow P_{10}$\n- $P_{10} \\rightarrow P_9$\n- $P_{10} \\rightarrow P_{12}$\n- $P_{11} \\rightarrow P_2$\n- $P_{11} \\rightarrow P_8$\n- $P_{12} \\rightarrow P_{12}$\n\nApply Tarjan’s algorithm to extract all SCCs of $G$. Then classify each SCC based on the following criteria, which rely on in-degree/out-degree patterns in the condensation graph and the presence of cycles or self-loops:\n- Safe: an SCC that contains no directed cycle (equivalently, an SCC of size $1$ with no self-loop).\n- Risky: an SCC that contains a directed cycle (either size at least $2$, or size $1$ with a self-loop) and has at least one outgoing edge to a different SCC in the condensation graph.\n- Deadlocked: an SCC that contains a directed cycle (either size at least $2$, or size $1$ with a self-loop) and has zero outgoing edges in the condensation graph.\n\nLet $S_{\\text{dead}}$ be the sum of the sizes (number of processes) of all deadlocked SCCs, and let $S_{\\text{risk}}$ be the sum of the sizes of all risky SCCs. Compute the value\n$$X \\;=\\; 3\\,S_{\\text{dead}} \\;+\\; 2\\,S_{\\text{risk}}.$$\nExpress your final answer as an integer. No rounding is required.",
            "solution": "The problem requires us to analyze a given Wait-For Graph (WFG) by first identifying its Strongly Connected Components (SCCs), then classifying them as \"Safe\", \"Risky\", or \"Deadlocked\" based on provided criteria, and finally calculating a weighted sum based on this classification.\n\n**Step 1: Identify Strongly Connected Components (SCCs)**\n\nBy inspecting the graph's edges, we can identify the maximal sets of vertices where every vertex is reachable from every other vertex within the set.\n- A cycle $P_1 \\to P_2 \\to P_3 \\to P_1$ forms the SCC: $C_1 = \\{P_1, P_2, P_3\\}$.\n- A cycle $P_4 \\to P_5 \\to P_4$ forms the SCC: $C_2 = \\{P_4, P_5\\}$.\n- A cycle $P_9 \\to P_{10} \\to P_{9}$ forms the SCC: $C_6 = \\{P_9, P_{10}\\}$.\n- A self-loop $P_7 \\to P_7$ makes $\\{P_7\\}$ an SCC: $C_4 = \\{P_7\\}$.\n- A self-loop $P_{12} \\to P_{12}$ makes $\\{P_{12}\\}$ an SCC: $C_8 = \\{P_{12}\\}$.\n- The remaining processes do not belong to any cycles and form singleton SCCs: $C_3 = \\{P_6\\}$, $C_5 = \\{P_8\\}$, and $C_7 = \\{P_{11}\\}$.\n\nIn summary, the SCCs are: $\\{P_1, P_2, P_3\\}$, $\\{P_4, P_5\\}$, $\\{P_6\\}$, $\\{P_7\\}$, $\\{P_8\\}$, $\\{P_9, P_{10}\\}$, $\\{P_{11}\\}$, $\\{P_{12}\\}$.\n\n**Step 2: Classify SCCs**\n\nWe now classify each SCC based on whether it contains a cycle and whether it has an outgoing edge to another SCC.\n- **$\\{P_1, P_2, P_3\\}$**: Contains a cycle (size 3). No outgoing edges. **Classification: Deadlocked**. Size = 3.\n- **$\\{P_4, P_5\\}$**: Contains a cycle (size 2). Has an outgoing edge $P_5 \\to P_6$. **Classification: Risky**. Size = 2.\n- **$\\{P_6\\}$**: No cycle (size 1, no self-loop). **Classification: Safe**.\n- **$\\{P_7\\}$**: Contains a cycle (self-loop). Has an outgoing edge $P_7 \\to P_8$. **Classification: Risky**. Size = 1.\n- **$\\{P_8\\}$**: No cycle (size 1, no self-loop). **Classification: Safe**.\n- **$\\{P_9, P_{10}\\}$**: Contains a cycle (size 2). Has an outgoing edge $P_{10} \\to P_{12}$. **Classification: Risky**. Size = 2.\n- **$\\{P_{11}\\}$**: No cycle (size 1, no self-loop). **Classification: Safe**.\n- **$\\{P_{12}\\}$**: Contains a cycle (self-loop). No outgoing edges. **Classification: Deadlocked**. Size = 1.\n\n**Step 3: Calculate the Final Value**\n\nWe sum the sizes of the deadlocked and risky SCCs.\n- $S_{\\text{dead}}$ (sum of sizes of Deadlocked SCCs) = Size$(\\{P_1, P_2, P_3\\})$ + Size$(\\{P_{12}\\}) = 3 + 1 = 4$.\n- $S_{\\text{risk}}$ (sum of sizes of Risky SCCs) = Size$(\\{P_4, P_5\\})$ + Size$(\\{P_7\\})$ + Size$(\\{P_9, P_{10}\\}) = 2 + 1 + 2 = 5$.\n\nFinally, we compute $X$:\n$$ X = 3\\,S_{\\text{dead}} + 2\\,S_{\\text{risk}} = 3(4) + 2(5) = 12 + 10 = 22 $$",
            "answer": "$$\\boxed{22}$$"
        },
        {
            "introduction": "While a cycle is a necessary condition for deadlock, understanding the nuances of wait conditions is key to correctly identifying one. This practice extends the basic wait-for graph model to include more complex synchronization patterns, where a process might wait for events from multiple other processes simultaneously. You will need to reason from the fundamental definition of deadlock—a set of processes where every member is waiting on another member of the same set—to analyze the system state and see how a deadlock can propagate beyond a simple cycle .",
            "id": "3689963",
            "problem": "Consider a system of concurrent processes modeled by a Wait-For Graph (WFG), where the directed graph $G = (V, E)$ has one vertex for each process and a directed edge $P_i \\to P_j$ if process $P_i$ is currently blocked waiting for an event that only process $P_j$ can cause. Under the standard single-instance resource model, a directed cycle among processes that are waiting on single resources is widely used as an indicator of deadlock. In addition, many synchronization primitives, such as a barrier, can be modeled as a simultaneous wait on multiple processes: if process $P_i$ must see events from processes $P_j$ and $P_k$ before proceeding, we represent this as $P_i$ having multiple outgoing edges $P_i \\to P_j$ and $P_i \\to P_k$ that together denote a conjunctive requirement that both events must occur before $P_i$ can be unblocked. This is referred to here as an \"AND-wait,\" in contrast to the usual single-edge \"OR-wait\" on a single process.\n\nThe fundamental base for this problem is the following:\n- A deadlock is a set of processes $S \\subseteq V$ such that every $P_i \\in S$ is blocked waiting for events that can only be caused by some $P_j \\in S$, so no event from outside $S$ can unblock any process in $S$.\n- In a WFG for single-instance resources, a directed cycle composed entirely of single-edge waits (each wait is for a single process) is a sufficient condition for deadlock among the processes on that cycle.\n\nNow consider $V = \\{ P_1, P_2, P_3, P_4, P_5 \\}$ and a snapshot of $G$ with the following edges:\n- Conjunctive (AND-wait) edges: $P_1 \\to P_2$ and $P_1 \\to P_3$, meaning $P_1$ requires events from both $P_2$ and $P_3$ simultaneously before it can proceed.\n- Single-edge waits (each an \"OR-wait\" on one process): $P_2 \\to P_3$, $P_3 \\to P_4$, $P_4 \\to P_5$, and $P_5 \\to P_4$. Assume all these waits reflect single-instance resource dependencies in the usual sense that only the target process can produce the required event.\n\nBased on the definitions above, and interpreting the multiple outgoing edges from $P_1$ as an AND-wait (e.g., modeling a barrier-like requirement that $P_1$ needs both $P_2$ and $P_3$), which of the following statements best characterizes the implications of cycles in $G$ and identifies the correct deadlocked set of processes?\n\nA. Any directed cycle anywhere in $G$ implies a deadlock for the processes in the cycle, including any cycles that involve conjunctive AND-waits; therefore both the subgraph on $\\{ P_1, P_2, P_3 \\}$ and the subgraph on $\\{ P_4, P_5 \\}$ are deadlocked independently.\n\nB. The directed $2$-cycle $\\{ P_4, P_5 \\}$ is a deadlock under the single-instance resource model; because $P_3$ waits on $P_4$, $P_2$ waits on $P_3$, and $P_1$ waits conjunctively on both $P_2$ and $P_3$, the set $\\{ P_1, P_2, P_3, P_4, P_5 \\}$ forms a closed wait set and is deadlocked.\n\nC. Directed cycles cease to be sufficient indicators of deadlock when any AND-wait is present anywhere in $G$; consequently there is no deadlock in the given graph.\n\nD. Only the processes on a directed cycle are deadlocked; therefore $\\{ P_4, P_5 \\}$ are deadlocked, but $\\{ P_1, P_2, P_3 \\}$ are not and will eventually proceed even if $\\{ P_4, P_5 \\}$ remain blocked.",
            "solution": "The problem statement is critically validated before proceeding to a solution.\n\n### Step 1: Extract Givens\n-   The system is modeled by a Wait-For Graph (WFG) $G = (V, E)$.\n-   A directed edge $P_i \\to P_j$ indicates process $P_i$ is blocked, waiting for an event from process $P_j$.\n-   The set of processes is $V = \\{ P_1, P_2, P_3, P_4, P_5 \\}$.\n-   There are two types of waits:\n    1.  **AND-wait (conjunctive):** A process $P_i$ with multiple outgoing edges $P_i \\to P_j$ and $P_i \\to P_k$ requires events from both $P_j$ and $P_k$ to unblock.\n    2.  **OR-wait (single-edge):** The standard wait where an edge $P_i \\to P_j$ means $P_i$ is waiting for a single event from $P_j$.\n-   The specific graph edges are:\n    -   $P_1$ has an AND-wait on $P_2$ and $P_3$, represented by edges $P_1 \\to P_2$ and $P_1 \\to P_3$.\n    -   Single-edge (OR) waits: $P_2 \\to P_3$, $P_3 \\to P_4$, $P_4 \\to P_5$, and $P_5 \\to P_4$.\n-   **Definition of Deadlock:** \"A deadlock is a set of processes $S \\subseteq V$ such that every $P_i \\in S$ is blocked waiting for events that can only be caused by some $P_j \\in S$, so no event from outside $S$ can unblock any process in $S$.\"\n-   **Principle for single-instance resources:** A directed cycle of single-edge waits is a sufficient condition for deadlock.\n\n### Step 2: Validate Using Extracted Givens\nThe problem statement is analyzed for validity.\n-   **Scientifically Grounded:** The problem uses a standard Wait-For Graph model from operating systems theory and extends it with a well-known synchronization pattern (AND-wait, analogous to joining threads or barrier synchronization). The definition of deadlock provided is standard and formal. The concepts are grounded in computer science principles.\n-   **Well-Posed:** The graph structure, process set, and wait conditions are explicitly and unambiguously defined. The question asks for an analysis based on these definitions, which permits a unique, logical deduction.\n-   **Objective:** The language is formal and technical, devoid of subjectivity or ambiguity.\n-   **Completeness and Consistency:** The problem provides all necessary information to determine the state of the system. The definitions and given graph structure are self-consistent.\n-   **Other Flaws:** The problem does not violate any other validation criteria. It is not trivial, as it requires careful application of the deadlock definition in a mixed-wait-type graph, distinguishing it from the simpler \"cycle = deadlock\" rule.\n\n### Step 3: Verdict and Action\n-   **Verdict:** The problem statement is valid, well-posed, and scientifically sound.\n-   **Action:** Proceed with a formal derivation of the solution.\n\n### Derivation of Solution\nThe primary task is to identify the set of deadlocked processes, $S$, based on the provided definition: every process in $S$ must wait for another process that is also in $S$.\n\nFirst, let us analyze the subgraph involving processes $P_4$ and $P_5$.\n-   The edges are $P_4 \\to P_5$ and $P_5 \\to P_4$.\n-   These are single-edge (OR) waits.\n-   Process $P_4$ is blocked, waiting for an event from $P_5$.\n-   Process $P_5$ is blocked, waiting for an event from $P_4$.\n-   Let's consider the set $S_1 = \\{ P_4, P_5 \\}$.\n    -   For $P_4 \\in S_1$, it is waiting on $P_5$, and $P_5 \\in S_1$.\n    -   For $P_5 \\in S_1$, it is waiting on $P_4$, and $P_4 \\in S_1$.\n-   Every process in $S_1$ is waiting for an event that can only be caused by another process within $S_1$. According to the problem's definition, the set $\\{ P_4, P_5 \\}$ is a deadlocked set. This is a classic deadlock caused by a cycle in a resource allocation graph with single-instance resources.\n\nNext, we analyze the remaining processes, considering the state of $\\{ P_4, P_5 \\}$.\n-   Process $P_3$ is waiting for $P_4$ ($P_3 \\to P_4$). Since $P_4$ is part of the deadlocked set $\\{ P_4, P_5 \\}$, $P_4$ will never produce the event required by $P_3$. Consequently, $P_3$ will be blocked indefinitely.\n-   Process $P_2$ is waiting for $P_3$ ($P_2 \\to P_3$). Since $P_3$ will be blocked indefinitely, $P_3$ will never produce the event required by $P_2$. Consequently, $P_2$ will also be blocked indefinitely.\n-   Process $P_1$ has an AND-wait on $P_2$ and $P_3$. This means $P_1$ requires events from *both* $P_2$ and $P_3$ to proceed. Since we have established that both $P_2$ and $P_3$ will be blocked indefinitely, neither will ever produce the required events. Consequently, $P_1$ will also be blocked indefinitely.\n\nThis propagation of blockage suggests that the entire set of processes may be deadlocked. Let's test the full set $S_{all} = \\{ P_1, P_2, P_3, P_4, P_5 \\}$ against the formal definition of a deadlocked set.\n-   For $P_1 \\in S_{all}$, it waits for $P_2$ and $P_3$. Both $\\{P_2, P_3\\} \\subset S_{all}$.\n-   For $P_2 \\in S_{all}$, it waits for $P_3$. We have $P_3 \\in S_{all}$.\n-   For $P_3 \\in S_{all}$, it waits for $P_4$. We have $P_4 \\in S_{all}$.\n-   For $P_4 \\in S_{all}$, it waits for $P_5$. We have $P_5 \\in S_{all}$.\n-   For $P_5 \\in S_{all}$, it waits for $P_4$. We have $P_4 \\in S_{all}$.\n\nEvery process in the set $S_{all}$ is waiting for an event from one or more other processes that are also within $S_{all}$. No process in $S_{all}$ is waiting for an event from a process outside this set. Therefore, no process in $S_{all}$ can ever be unblocked. The set $S_{all} = \\{ P_1, P_2, P_3, P_4, P_5 \\}$ is a \"closed wait set\" and satisfies the definition of a deadlocked set.\n\n### Option-by-Option Analysis\n\n**A. Any directed cycle anywhere in $G$ implies a deadlock for the processes in the cycle, including any cycles that involve conjunctive AND-waits; therefore both the subgraph on $\\{ P_1, P_2, P_3 \\}$ and the subgraph on $\\{ P_4, P_5 \\}$ are deadlocked independently.**\nThis statement is incorrect. The presence of an AND-wait complicates the simple \"cycle implies deadlock\" rule. A cycle involving an AND-wait node is not necessarily a deadlock. For example, if $P_1$ had an AND-wait on $P_2$ and a free process $P_6$, and $P_2$ waited on $P_1$, the cycle $P_1 \\to P_2 \\to P_1$ would not be a deadlock until $P_6$ supplied its event. More directly, the set $\\{ P_1, P_2, P_3 \\}$ is not a deadlocked set \"independently,\" because $P_3$ is waiting on $P_4$, which is outside this set. The condition for deadlock is not met for this subset.\n**Verdict: Incorrect.**\n\n**B. The directed $2$-cycle $\\{ P_4, P_5 \\}$ is a deadlock under the single-instance resource model; because $P_3$ waits on $P_4$, $P_2$ waits on $P_3$, and $P_1$ waits conjunctively on both $P_2$ and $P_3$, the set $\\{ P_1, P_2, P_3, P_4, P_5 \\}$ forms a closed wait set and is deadlocked.**\nThis statement is fully consistent with our derivation. It correctly identifies the initial deadlock in the $\\{ P_4, P_5 \\}$ cycle. It then correctly traces the propagation of permanent blocking through $P_3$, $P_2$, and $P_1$. Finally, it correctly concludes that the entire set of five processes forms a deadlocked set (a closed wait set) according to the formal definition.\n**Verdict: Correct.**\n\n**C. Directed cycles cease to be sufficient indicators of deadlock when any AND-wait is present anywhere in $G$; consequently there is no deadlock in the given graph.**\nThis statement is incorrect. While the general rule becomes more nuanced, a simple cycle composed entirely of OR-waits, such as $\\{ P_4, P_5 \\}$, remains a sufficient condition for deadlock for those processes, regardless of other waits elsewhere in the graph. The conclusion, \"consequently there is no deadlock,\" is false, as we have definitively identified a deadlock.\n**Verdict: Incorrect.**\n\n**D. Only the processes on a directed cycle are deadlocked; therefore $\\{ P_4, P_5 \\}$ are deadlocked, but $\\{ P_1, P_2, P_3 \\}$ are not and will eventually proceed even if $\\{ P_4, P_5 \\}$ remain blocked.**\nThis statement is incorrect. While it correctly identifies $\\{ P_4, P_5 \\}$ as deadlocked, its second claim is false. If $\\{ P_4, P_5 \\}$ remain blocked, then $P_4$ never signals. This permanently blocks $P_3$, which in turn permanently blocks $P_2$. Since $P_1$ requires signals from both $P_2$ and $P_3$, it will also be permanently blocked. The processes $\\{ P_1, P_2, P_3 \\}$ will *not* eventually proceed; they are also part of the overall deadlocked state of the system.\n**Verdict: Incorrect.**",
            "answer": "$$\\boxed{B}$$"
        }
    ]
}