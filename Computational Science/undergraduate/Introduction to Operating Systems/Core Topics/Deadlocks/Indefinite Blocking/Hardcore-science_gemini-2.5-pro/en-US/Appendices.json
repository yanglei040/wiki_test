{
    "hands_on_practices": [
        {
            "introduction": "This first exercise explores the most direct and absolute form of starvation. In a system with strict, fixed-priority scheduling, what happens when a high-priority task is always ready to run? This problem  challenges you to use first principles to prove the stark outcome for a lower-priority task, demonstrating why such a simple scheduling policy can be dangerous in practice.",
            "id": "3649124",
            "problem": "Consider a single Central Processing Unit (CPU) system running a preemptive, fixed-priority, Round Robin scheduler with time-slice (quantum) size $q > 0$. There are $2$ processes: a high-priority process $H$ that is strictly CPU-bound (it never performs Input/Output (I/O) and therefore never blocks) and a lower-priority process $L$ that is I/O-bound. The I/O-bound process $L$ alternates between I/O and CPU requests: while performing I/O it is not runnable; upon I/O completion it immediately becomes ready and requests CPU service for a short burst. I/O completions for $L$ occur as a Poisson process with rate $\\mu > 0$. There is no priority aging, no dynamic priority boost on I/O completion, and no admission control; the scheduler always selects the highest-priority runnable process and only considers lower-priority runnable processes when the higher-priority queue is empty.\n\nDefine $N(t)$ to be the number of CPU quanta actually granted to $L$ in the time interval $[0,t]$ under this scheduler. Using first principles and the core definitions above, derive the asymptotic probability that $L$ receives any CPU service at all by computing\n$$\\lim_{t \\to \\infty} \\mathbb{P}\\big(N(t) \\ge 1\\big)$$\nas a function of $q$ and $\\mu$. No rounding is required. Express the final answer as a dimensionless quantity.",
            "solution": "The problem asks for the asymptotic probability that a low-priority process, $L$, receives any CPU service in a system with a preemptive, fixed-priority scheduler.\n\nFirst, a rigorous validation of the problem statement is conducted.\n\n**Step 1: Extract Givens**\n- System type: Single Central Processing Unit (CPU).\n- Scheduler type: Preemptive, fixed-priority, Round Robin.\n- Time-slice (quantum) size: $q > 0$.\n- Process $H$: High-priority, strictly CPU-bound (never blocks, always runnable).\n- Process $L$: Lower-priority, I/O-bound (alternates between I/O and CPU requests).\n- Behavior of $L$: Upon I/O completion, it becomes ready for the CPU. I/O completions for $L$ occur as a Poisson process with rate $\\mu > 0$.\n- Scheduler rules:\n    - No priority aging.\n    - No dynamic priority boost.\n    - The scheduler always selects the highest-priority runnable process.\n    - Lower-priority runnable processes are considered only when the higher-priority queue is empty.\n- Quantity to derive: $\\lim_{t \\to \\infty} \\mathbb{P}\\big(N(t) \\ge 1\\big)$, where $N(t)$ is the number of CPU quanta granted to $L$ in the time interval $[0,t]$.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is scientifically grounded in the principles of operating system scheduling theory. The concepts of fixed-priority scheduling, CPU-bound and I/O-bound processes, and starvation are standard textbook material. The problem is self-contained, and its terms are objective and well-defined. The use of a Poisson process to model I/O completion is a common technique in performance analysis. The problem is well-posed and leads to a unique, stable solution based on a logical deduction from the given rules. The problem does not violate any of the invalidity criteria.\n\n**Verdict and Action**\nThe problem is deemed **valid**. A solution will now be derived.\n\n**Derivation**\nThe core of this problem lies in the strict rules of the specified scheduler. The scheduler is described as a preemptive, fixed-priority scheduler that \"always selects the highest-priority runnable process\" and \"only considers lower-priority runnable processes when the higher-priority queue is empty.\"\n\nLet us analyze the state of the two processes, $H$ and $L$.\n\n1.  **Process $H$**: This is a high-priority process. The problem states it is \"strictly CPU-bound\" and \"never blocks\". This means that process $H$ is, by definition, always in a runnable state. Consequently, the ready queue for the high-priority level is never empty; it always contains at least process $H$.\n\n2.  **Process $L$**: This is a lower-priority process. It alternates between being blocked for I/O and being ready for the CPU. When its I/O operation completes, it transitions to the ready state and is placed in the ready queue for its lower priority level. The occurrences of these transitions are modeled by a Poisson process with rate $\\mu$, but this detail relates to *when* $L$ becomes ready, not *if* it can be selected for execution.\n\nThe scheduler's decision logic is absolute. At any point in time when the CPU becomes available (e.g., after a time quantum $q$ expires), the scheduler must choose the next process to run. Its algorithm is:\n-   Check the highest-priority ready queue.\n-   Is this queue non-empty?\n    -   Yes: Select a process from this queue to run (using Round Robin if there are multiple, but here there is only $H$).\n    -   No: Check the next-lower-priority queue.\n\nIn this specific system, the high-priority queue is never empty because it always contains the runnable process $H$. Therefore, the scheduler will *always* find process $H$ in the high-priority queue and will *always* select it for execution. The condition required to even consider process $L$—that the \"higher-priority queue is empty\"—is never met.\n\nThis scenario describes a classic case of **starvation** (or indefinite blocking). The lower-priority process $L$, despite becoming ready for the CPU periodically, is never granted CPU time because the higher-priority process $H$ perpetually occupies the resource.\n\nThe quantity $N(t)$ represents the number of CPU quanta granted to process $L$ in the time interval $[0,t]$. Based on the analysis above, process $L$ is never selected to run by the scheduler. Therefore, the number of CPU quanta it receives is always zero, regardless of the length of the time interval.\n$$N(t) = 0 \\quad \\text{for all } t \\ge 0$$\nThe parameters $q$ and $\\mu$, which describe the quantum size and the rate at which $L$ becomes ready, are irrelevant to the outcome because the scheduling priority rule prevents $L$ from ever being chosen.\n\nWe are asked to compute the probability $\\mathbb{P}\\big(N(t) \\ge 1\\big)$. This is the probability of the event that process $L$ receives at least one quantum of CPU time within the interval $[0,t]$. Since we have established that $N(t)$ is deterministically $0$ for all $t$, the event $N(t) \\ge 1$ is an impossible event.\n\nThe probability of an impossible event is $0$.\n$$\\mathbb{P}\\big(N(t) \\ge 1\\big) = 0 \\quad \\text{for all } t \\ge 0$$\nFinally, we must compute the limit of this probability as $t \\to \\infty$.\n$$\\lim_{t \\to \\infty} \\mathbb{P}\\big(N(t) \\ge 1\\big) = \\lim_{t \\to \\infty} 0$$\nThe limit of a constant is the constant itself.\n$$\\lim_{t \\to \\infty} 0 = 0$$\nThus, the asymptotic probability that process $L$ receives any CPU service at all is $0$.",
            "answer": "$$\\boxed{0}$$"
        },
        {
            "introduction": "Starvation is not always caused by a single, greedy process. More commonly, the collective demand of multiple high-priority tasks can saturate a resource, leaving none for lower-priority work. This practice problem  shifts the focus from qualitative understanding to quantitative analysis, asking you to calculate the precise tipping point—in terms of task frequency—at which a system's CPU becomes fully utilized, causing a background task to starve.",
            "id": "3649175",
            "problem": "Consider a single-processor operating system that uses fixed-priority, fully preemptive scheduling. Three independent real-time tasks, denoted $\\tau_1$, $\\tau_2$, and $\\tau_3$, have strictly higher priority than a background maintenance thread $M$, which has the lowest priority. Each $\\tau_i$ is periodic with inter-arrival time (period) $T_i$ and worst-case execution time $C_i$. Assume all tasks are released synchronously at time $t=0$, deadlines equal periods, there is no input or output blocking, and no self-suspension; whenever a higher-priority task is ready, it preempts any lower-priority task.\n\nIndefinite blocking (starvation) of the background thread $M$ means that $M$ receives no processor time over an unbounded interval. Using only the fundamental definitions of processor capacity and work-conserving preemptive scheduling, reason about the aggregate processor demand imposed by the higher-priority tasks. Then, determine the critical value $T_3^{\\star}$ such that if $T_3 \\leq T_3^{\\star}$, the background thread $M$ can starve indefinitely, whereas if $T_3 > T_3^{\\star}$, the background thread $M$ necessarily receives some processor time infinitely often.\n\nThe task parameters are:\n- $\\tau_1$: $C_1 = 2 \\,\\mathrm{ms}$, $T_1 = 5 \\,\\mathrm{ms}$,\n- $\\tau_2$: $C_2 = 1.5 \\,\\mathrm{ms}$, $T_2 = 4 \\,\\mathrm{ms}$,\n- $\\tau_3$: $C_3 = 1 \\,\\mathrm{ms}$, $T_3$ unknown.\n\nCompute $T_3^{\\star}$ based on the requirement that the aggregate higher-priority processor demand just matches the processor capacity. Round your final numerical answer for $T_3^{\\star}$ to four significant figures and express it in milliseconds.",
            "solution": "The problem requires determining the critical period $T_3^{\\star}$ for a real-time task $\\tau_3$ that marks the boundary for the indefinite starvation of a low-priority background thread $M$. The system operates on a single processor with fixed-priority, preemptive scheduling.\n\nThe fundamental principle governing this problem is processor utilization. For a single processor, the total available processing capacity is normalized to $1$. A set of periodic tasks can be scheduled without overloading the processor only if their total utilization is less than or equal to $1$.\n\nThe utilization $U_i$ of a periodic task $\\tau_i$ with worst-case execution time $C_i$ and period $T_i$ is defined as the fraction of processor time it consumes in the long run:\n$$ U_i = \\frac{C_i}{T_i} $$\nThe background thread $M$ has the lowest priority. According to the rules of work-conserving, preemptive scheduling, $M$ will only be allocated processor time when no higher-priority tasks ($\\tau_1, \\tau_2, \\tau_3$) are ready to run. Indefinite starvation of $M$ will occur if the processor is fully consumed by the higher-priority tasks over any unbounded interval. This condition is met if the aggregate processor demand, which is the sum of the utilizations of tasks $\\tau_1, \\tau_2,$ and $\\tau_3$, is equal to or greater than the total processor capacity.\n\nLet $U_{total}$ be the aggregate utilization of the higher-priority tasks:\n$$ U_{total} = U_1 + U_2 + U_3 = \\frac{C_1}{T_1} + \\frac{C_2}{T_2} + \\frac{C_3}{T_3} $$\nThe condition for indefinite starvation of $M$ is $U_{total} \\geq 1$. Conversely, if $U_{total} < 1$, there will be spare processor capacity, which will be allocated to $M$, preventing starvation.\n\nThe problem asks for the critical value $T_3^{\\star}$ such that if $T_3 \\leq T_3^{\\star}$, starvation can occur. This critical boundary corresponds to the case where the aggregate processor demand exactly matches the processor capacity. We therefore set the total utilization to $1$:\n$$ \\frac{C_1}{T_1} + \\frac{C_2}{T_2} + \\frac{C_3}{T_3^{\\star}} = 1 $$\nWe can solve this equation for $T_3^{\\star}$. First, we isolate the term containing $T_3^{\\star}$:\n$$ \\frac{C_3}{T_3^{\\star}} = 1 - \\left( \\frac{C_1}{T_1} + \\frac{C_2}{T_2} \\right) $$\nThen, we solve for $T_3^{\\star}$:\n$$ T_3^{\\star} = \\frac{C_3}{1 - \\frac{C_1}{T_1} - \\frac{C_2}{T_2}} $$\nThis expression is valid provided that the denominator is positive, i.e., $1 - \\frac{C_1}{T_1} - \\frac{C_2}{T_2} > 0$.\n\nNow, we substitute the given task parameters:\n- $\\tau_1$: $C_1 = 2 \\,\\mathrm{ms}$, $T_1 = 5 \\,\\mathrm{ms}$\n- $\\tau_2$: $C_2 = 1.5 \\,\\mathrm{ms}$, $T_2 = 4 \\,\\mathrm{ms}$\n- $\\tau_3$: $C_3 = 1 \\,\\mathrm{ms}$\n\nFirst, we compute the utilizations of $\\tau_1$ and $\\tau_2$:\n$$ U_1 = \\frac{C_1}{T_1} = \\frac{2}{5} = 0.4 $$\n$$ U_2 = \\frac{C_2}{T_2} = \\frac{1.5}{4} = \\frac{3/2}{4} = \\frac{3}{8} = 0.375 $$\nThe sum of these utilizations is:\n$$ U_1 + U_2 = 0.4 + 0.375 = 0.775 $$\nThe remaining processor capacity available for task $\\tau_3$ before saturation is $1 - 0.775 = 0.225$. The critical condition is met when the utilization of $\\tau_3$ is exactly this value:\n$$ U_3^{\\star} = \\frac{C_3}{T_3^{\\star}} = 0.225 $$\nSubstituting $C_3 = 1 \\,\\mathrm{ms}$:\n$$ \\frac{1}{T_3^{\\star}} = 0.225 $$\nSolving for $T_3^{\\star}$:\n$$ T_3^{\\star} = \\frac{1}{0.225} = \\frac{1}{225/1000} = \\frac{1000}{225} $$\nSimplifying the fraction by dividing the numerator and denominator by their greatest common divisor, which is $25$:\n$$ T_3^{\\star} = \\frac{1000 \\div 25}{225 \\div 25} = \\frac{40}{9} \\,\\mathrm{ms} $$\nAs a decimal, this is $T_3^{\\star} = 4.4444... \\,\\mathrm{ms}$. The problem requires rounding the final answer to four significant figures.\n$$ T_3^{\\star} \\approx 4.444 \\,\\mathrm{ms} $$\nIf $T_3$ is less than or equal to this value, the total utilization of the high-priority tasks will be greater than or equal to $1$, leaving no processor time for the background thread $M$. If $T_3$ is greater than this value, the total utilization will be less than $1$, guaranteeing that $M$ receives some processor time.",
            "answer": "$$ \\boxed{4.444} $$"
        },
        {
            "introduction": "After identifying and quantifying starvation, the next logical step is to engineer a solution. This final problem puts you in the role of an OS designer tasked with preventing indefinite blocking by implementing a priority aging mechanism. By modeling the system dynamics, you will derive the exact mathematical condition, specifically the minimal aging rate $\\mu_{\\min}$, required to guarantee that a low-priority thread will eventually get its turn, showcasing how theoretical analysis informs the design of fair and robust schedulers .",
            "id": "3649191",
            "problem": "An operating system uses a preemptive, priority-based scheduler on a single Central Processing Unit (CPU) with fixed-length time quanta of duration $\\Delta$. Each thread $i$ has a base priority $b_{i} \\in (0,1)$, and an effective priority $p_{i}(t)$ that is updated at the end of every quantum to prevent indefinite blocking (starvation). You are to formalize a priority decay mechanism that avoids oscillatory priority dynamics while guaranteeing that a lower base-priority thread cannot starve in the presence of a higher base-priority thread.\n\nStarting from the core definitions that starvation is indefinite postponement of service and that aging is a monotone increase of effective priority while waiting, proceed as follows:\n\n- Propose a continuous-time decay function $d(t)$ with a single rate parameter $\\lambda>0$ that maps elapsed time $t$ to a multiplicative decay factor on the distance of $p_{i}(t)$ from $b_{i}$, such that the induced discrete-time update at the end of each quantum is monotone and non-oscillatory.\n\n- Given your $d(t)$, suppose the per-quantum update rule is\n$$\np_{i}^{+} \\;=\\; d(\\Delta)\\,p_{i} \\;+\\; \\bigl(1-d(\\Delta)\\bigr)\\,b_{i} \\;+\\; \\mu\\,\\Delta\\,\\mathbf{1}\\{\\text{thread $i$ waited during the quantum}\\},\n$$\nwhere $\\mu>0$ is a constant aging rate and $\\mathbf{1}\\{\\cdot\\}$ is the indicator function. The scheduler always runs the thread with the maximum effective priority at the beginning of a quantum, breaking ties arbitrarily.\n\n- Consider exactly two threads, $H$ and $L$, with base priorities $b_{H}$ and $b_{L}$ satisfying $b_{H}>b_{L}$. Initially $p_{H}(0)=b_{H}$ and $p_{L}(0)=b_{L}$. Analyze the worst-case schedule for $L$ in which $H$ continues to run so long as $p_{H}\\ge p_{L}$. Using only the definitions above and first-principles linear-time-invariant reasoning, derive a closed-form expression for the minimal aging rate $\\mu_{\\min}$, as a function of $b_{H},b_{L},\\lambda$, and $\\Delta$, that guarantees $L$ cannot starve.\n\nYour final answer must be a single closed-form analytic expression for $\\mu_{\\min}$. Do not round. No units are required.",
            "solution": "The problem is found to be valid as it is scientifically grounded in operating systems theory, well-posed, objective, and contains sufficient information for a unique solution. We proceed with the derivation.\n\nThe problem asks us to formalize a priority update mechanism to prevent starvation. This involves three main steps: proposing a suitable decay function, setting up the system dynamics for a two-thread scenario, and deriving the minimum aging rate $\\mu_{\\min}$ to guarantee the lower-priority thread is not starved.\n\nFirst, we must propose a continuous-time decay function $d(t)$ with a single rate parameter $\\lambda > 0$. The update rule for priority $p_{i}$ in the absence of aging is $p_{i}^{+} = d(\\Delta)p_{i} + (1-d(\\Delta))b_{i}$, where $p_i$ is the current priority and $p_i^+$ is the priority after one quantum of duration $\\Delta$. This can be rewritten as $p_{i}^{+} - b_{i} = d(\\Delta)(p_{i} - b_{i})$, indicating that the deviation of the effective priority from the base priority decays by a factor of $d(\\Delta)$ in each time step. The continuous-time analogue of this discrete first-order process is the first-order linear ordinary differential equation:\n$$ \\frac{d}{dt} \\left( p_{i}(t) - b_{i} \\right) = -\\lambda \\left( p_{i}(t) - b_{i} \\right) $$\nwhere $\\lambda>0$ is the decay rate. The solution to this equation is:\n$$ p_{i}(t) - b_{i} = (p_{i}(0) - b_{i}) \\exp(-\\lambda t) $$\nThis describes the evolution of the priority deviation over a time interval $t$. The multiplicative decay factor applied to the deviation over time $t$ is evidently $\\exp(-\\lambda t)$. Therefore, the most natural and appropriate choice for the decay function is:\n$$ d(t) = \\exp(-\\lambda t) $$\nThis function has a single rate parameter $\\lambda > 0$. For the discrete update over a quantum $\\Delta$, the factor is $d(\\Delta) = \\exp(-\\lambda\\Delta)$. Since $\\lambda > 0$ and $\\Delta > 0$, we have $0 < \\exp(-\\lambda\\Delta) < 1$. In a linear recurrence relation, a characteristic root in this range ensures monotonic, non-oscillatory convergence, satisfying the problem's requirement. For notational convenience, we define the constant $\\gamma = d(\\Delta) = \\exp(-\\lambda\\Delta)$.\n\nNext, we analyze the worst-case scenario for the low-priority thread, $L$. We have two threads, $H$ (high base priority) and $L$ (low base priority), with $b_{H} > b_{L}$. The initial conditions are $p_{H}(0) = b_{H}$ and $p_{L}(0) = b_{L}$. Let $p_{H,k}$ and $p_{L,k}$ denote the effective priorities of threads $H$ and $L$, respectively, at the end of the $k$-th quantum (i.e., at time $t=k\\Delta$). The initial state is $p_{H,0} = b_{H}$ and $p_{L,0} = b_{L}$.\n\nAt the start of the first quantum ($k=0$), we have $p_{H,0} > p_{L,0}$, so the scheduler runs thread $H$. The worst-case for $L$ is that $H$ continues to run as long as its priority is greater than or equal to $L$'s, i.e., $p_{H,k} \\ge p_{L,k}$ for all subsequent steps $k$. Under this assumption, for each quantum $k+1$ (from $t=k\\Delta$ to $t=(k+1)\\Delta$), thread $H$ runs and thread $L$ waits.\n\nThe priority update rules at the end of each quantum are:\nFor thread $H$ (which ran):\n$p_{H,k+1} = \\gamma p_{H,k} + (1-\\gamma)b_{H} + \\mu \\Delta \\cdot 0 = \\gamma p_{H,k} + (1-\\gamma)b_{H}$\nFor thread $L$ (which waited):\n$p_{L,k+1} = \\gamma p_{L,k} + (1-\\gamma)b_{L} + \\mu \\Delta \\cdot 1 = \\gamma p_{L,k} + (1-\\gamma)b_{L} + \\mu\\Delta$\n\nWe now solve these two linear recurrence relations.\nFor thread $H$, the initial condition is $p_{H,0}=b_{H}$. For $k=0$:\n$p_{H,1} = \\gamma p_{H,0} + (1-\\gamma)b_{H} = \\gamma b_{H} + (1-\\gamma)b_{H} = b_{H}$.\nBy induction, if $p_{H,k}=b_{H}$, then $p_{H,k+1} = \\gamma b_{H} + (1-\\gamma)b_{H} = b_{H}$. Thus, as long as $H$ keeps running, its priority remains constant:\n$$ p_{H,k} = b_{H} \\quad \\text{for all } k \\ge 0 $$\n\nFor thread $L$, we have the recurrence $p_{L,k+1} = \\gamma p_{L,k} + C$, where $C = (1-\\gamma)b_{L} + \\mu\\Delta$. This is a standard first-order non-homogeneous recurrence relation. The solution consists of a homogeneous part and a particular solution. The fixed point (particular solution) $p_{L}^*$ satisfies $p_{L}^* = \\gamma p_{L}^* + C$, which gives $p_{L}^* = \\frac{C}{1-\\gamma}$.\n$$ p_{L}^* = \\frac{(1-\\gamma)b_{L} + \\mu\\Delta}{1-\\gamma} = b_{L} + \\frac{\\mu\\Delta}{1-\\gamma} $$\nThe general solution is of the form $p_{L,k} = A\\gamma^k + p_{L}^*$, where $A$ is a constant determined by the initial condition $p_{L,0}=b_{L}$.\n$p_{L,0} = A\\gamma^0 + p_{L}^* = A + b_{L} + \\frac{\\mu\\Delta}{1-\\gamma}$.\n$b_{L} = A + b_{L} + \\frac{\\mu\\Delta}{1-\\gamma} \\implies A = - \\frac{\\mu\\Delta}{1-\\gamma}$.\nThus, the closed-form solution for $p_{L,k}$ is:\n$$ p_{L,k} = \\left(b_{L} + \\frac{\\mu\\Delta}{1-\\gamma}\\right) - \\left(\\frac{\\mu\\Delta}{1-\\gamma}\\right)\\gamma^k = b_{L} + \\frac{\\mu\\Delta}{1-\\gamma}(1-\\gamma^k) $$\n\nStarvation of thread $L$ occurs if it is indefinitely postponed. In our model, this means $p_{L,k} \\le p_{H,k}$ for all $k \\ge 0$. To guarantee that $L$ cannot starve, its priority must eventually exceed that of $H$. Since $p_{L,k}$ is a monotonically increasing function of $k$ (as $0 < \\gamma < 1$), if it ever exceeds $p_{H,k}=b_H$, it will do so and stay above it if the aging term continues. The condition to guarantee no starvation is that the asymptotic limit of $p_{L,k}$ must be strictly greater than $b_H$.\n$$ \\lim_{k\\to\\infty} p_{L,k} > b_{H} $$\nAs $k \\to \\infty$, $\\gamma^k \\to 0$ because $0 < \\gamma < 1$. So, the limit is:\n$$ \\lim_{k\\to\\infty} p_{L,k} = b_{L} + \\frac{\\mu\\Delta}{1-\\gamma} $$\nThe condition to prevent starvation becomes:\n$$ b_{L} + \\frac{\\mu\\Delta}{1-\\gamma} > b_{H} $$\nWe solve this inequality for $\\mu$:\n$$ \\frac{\\mu\\Delta}{1-\\gamma} > b_{H} - b_{L} $$\n$$ \\mu > \\frac{(1-\\gamma)(b_{H} - b_{L})}{\\Delta} $$\nThe minimal aging rate, $\\mu_{\\min}$, is the infimum of the set of $\\mu$ values that satisfy this condition, which corresponds to the boundary of the inequality.\n$$ \\mu_{\\min} = \\frac{(1-\\gamma)(b_{H} - b_{L})}{\\Delta} $$\nFinally, we substitute back $\\gamma = \\exp(-\\lambda\\Delta)$:\n$$ \\mu_{\\min} = \\frac{(1 - \\exp(-\\lambda\\Delta))(b_{H} - b_{L})}{\\Delta} $$\nIf $\\mu$ is set to this value, $p_{L,k}$ will approach $b_H$ asymptotically from below, never quite reaching it in finite time. Therefore, any $\\mu > \\mu_{\\min}$ will guarantee that $p_{L,k}$ exceeds $b_H$ after a finite number of steps, thus preventing starvation. The problem asks for the minimal rate $\\mu_{\\min}$ that establishes this guarantee.",
            "answer": "$$\\boxed{\\frac{\\left(1 - \\exp(-\\lambda\\Delta)\\right)\\left(b_{H} - b_{L}\\right)}{\\Delta}}$$"
        }
    ]
}