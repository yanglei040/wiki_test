{
    "hands_on_practices": [
        {
            "introduction": "Understanding indefinite blocking often begins with a simple, yet powerful, principle: a resource can only supply so much. In preemptive, priority-based scheduling, this principle manifests through processor utilization. This exercise provides a hands-on opportunity to calculate the critical threshold where the computational demand of high-priority tasks completely consumes the CPU, leaving no time for lower-priority work and guaranteeing starvation .",
            "id": "3649175",
            "problem": "Consider a single-processor operating system that uses fixed-priority, fully preemptive scheduling. Three independent real-time tasks, denoted $\\tau_1$, $\\tau_2$, and $\\tau_3$, have strictly higher priority than a background maintenance thread $M$, which has the lowest priority. Each $\\tau_i$ is periodic with inter-arrival time (period) $T_i$ and worst-case execution time $C_i$. Assume all tasks are released synchronously at time $t=0$, deadlines equal periods, there is no input or output blocking, and no self-suspension; whenever a higher-priority task is ready, it preempts any lower-priority task.\n\nIndefinite blocking (starvation) of the background thread $M$ means that $M$ receives no processor time over an unbounded interval. Using only the fundamental definitions of processor capacity and work-conserving preemptive scheduling, reason about the aggregate processor demand imposed by the higher-priority tasks. Then, determine the critical value $T_3^{\\star}$ such that if $T_3 \\leq T_3^{\\star}$, the background thread $M$ can starve indefinitely, whereas if $T_3 > T_3^{\\star}$, the background thread $M$ necessarily receives some processor time infinitely often.\n\nThe task parameters are:\n- $\\tau_1$: $C_1 = 2 \\,\\mathrm{ms}$, $T_1 = 5 \\,\\mathrm{ms}$,\n- $\\tau_2$: $C_2 = 1.5 \\,\\mathrm{ms}$, $T_2 = 4 \\,\\mathrm{ms}$,\n- $\\tau_3$: $C_3 = 1 \\,\\mathrm{ms}$, $T_3$ unknown.\n\nCompute $T_3^{\\star}$ based on the requirement that the aggregate higher-priority processor demand just matches the processor capacity. Round your final numerical answer for $T_3^{\\star}$ to four significant figures and express it in milliseconds.",
            "solution": "The problem requires determining the critical period $T_3^{\\star}$ for a real-time task $\\tau_3$ that marks the boundary for the indefinite starvation of a low-priority background thread $M$. The system operates on a single processor with fixed-priority, preemptive scheduling.\n\nThe fundamental principle governing this problem is processor utilization. For a single processor, the total available processing capacity is normalized to $1$. A set of periodic tasks can be scheduled without overloading the processor only if their total utilization is less than or equal to $1$.\n\nThe utilization $U_i$ of a periodic task $\\tau_i$ with worst-case execution time $C_i$ and period $T_i$ is defined as the fraction of processor time it consumes in the long run:\n$$ U_i = \\frac{C_i}{T_i} $$\nThe background thread $M$ has the lowest priority. According to the rules of work-conserving, preemptive scheduling, $M$ will only be allocated processor time when no higher-priority tasks ($\\tau_1, \\tau_2, \\tau_3$) are ready to run. Indefinite starvation of $M$ will occur if the processor is fully consumed by the higher-priority tasks over any unbounded interval. This condition is met if the aggregate processor demand, which is the sum of the utilizations of tasks $\\tau_1, \\tau_2,$ and $\\tau_3$, is equal to or greater than the total processor capacity.\n\nLet $U_{total}$ be the aggregate utilization of the higher-priority tasks:\n$$ U_{total} = U_1 + U_2 + U_3 = \\frac{C_1}{T_1} + \\frac{C_2}{T_2} + \\frac{C_3}{T_3} $$\nThe condition for indefinite starvation of $M$ is $U_{total} \\geq 1$. Conversely, if $U_{total} < 1$, there will be spare processor capacity, which will be allocated to $M$, preventing starvation.\n\nThe problem asks for the critical value $T_3^{\\star}$ such that if $T_3 \\leq T_3^{\\star}$, starvation can occur. This critical boundary corresponds to the case where the aggregate processor demand exactly matches the processor capacity. We therefore set the total utilization to $1$:\n$$ \\frac{C_1}{T_1} + \\frac{C_2}{T_2} + \\frac{C_3}{T_3^{\\star}} = 1 $$\nWe can solve this equation for $T_3^{\\star}$. First, we isolate the term containing $T_3^{\\star}$:\n$$ \\frac{C_3}{T_3^{\\star}} = 1 - \\left( \\frac{C_1}{T_1} + \\frac{C_2}{T_2} \\right) $$\nThen, we solve for $T_3^{\\star}$:\n$$ T_3^{\\star} = \\frac{C_3}{1 - \\frac{C_1}{T_1} - \\frac{C_2}{T_2}} $$\nThis expression is valid provided that the denominator is positive, i.e., $1 - \\frac{C_1}{T_1} - \\frac{C_2}{T_2} > 0$.\n\nNow, we substitute the given task parameters:\n- $\\tau_1$: $C_1 = 2 \\,\\mathrm{ms}$, $T_1 = 5 \\,\\mathrm{ms}$\n- $\\tau_2$: $C_2 = 1.5 \\,\\mathrm{ms}$, $T_2 = 4 \\,\\mathrm{ms}$\n- $\\tau_3$: $C_3 = 1 \\,\\mathrm{ms}$\n\nFirst, we compute the utilizations of $\\tau_1$ and $\\tau_2$:\n$$ U_1 = \\frac{C_1}{T_1} = \\frac{2}{5} = 0.4 $$\n$$ U_2 = \\frac{C_2}{T_2} = \\frac{1.5}{4} = \\frac{3/2}{4} = \\frac{3}{8} = 0.375 $$\nThe sum of these utilizations is:\n$$ U_1 + U_2 = 0.4 + 0.375 = 0.775 $$\nThe remaining processor capacity available for task $\\tau_3$ before saturation is $1 - 0.775 = 0.225$. The critical condition is met when the utilization of $\\tau_3$ is exactly this value:\n$$ U_3^{\\star} = \\frac{C_3}{T_3^{\\star}} = 0.225 $$\nSubstituting $C_3 = 1 \\,\\mathrm{ms}$:\n$$ \\frac{1}{T_3^{\\star}} = 0.225 $$\nSolving for $T_3^{\\star}$:\n$$ T_3^{\\star} = \\frac{1}{0.225} = \\frac{1}{225/1000} = \\frac{1000}{225} $$\nSimplifying the fraction by dividing the numerator and denominator by their greatest common divisor, which is $25$:\n$$ T_3^{\\star} = \\frac{1000 \\div 25}{225 \\div 25} = \\frac{40}{9} \\,\\mathrm{ms} $$\nAs a decimal, this is $T_3^{\\star} = 4.4444... \\,\\mathrm{ms}$. The problem requires rounding the final answer to four significant figures.\n$$ T_3^{\\star} \\approx 4.444 \\,\\mathrm{ms} $$\nIf $T_3$ is less than or equal to this value, the total utilization of the high-priority tasks will be greater than or equal to $1$, leaving no processor time for the background thread $M$. If $T_3$ is greater than this value, the total utilization will be less than $1$, guaranteeing that $M$ receives some processor time.",
            "answer": "$$ \\boxed{4.444} $$"
        },
        {
            "introduction": "While strict priority schemes are a clear source of starvation, what about systems that try to be fair, such as those using random selection? This practice explores the probabilistic nature of starvation in such scenarios. You will discover that \"fair\" does not always mean \"guaranteed,\" and by applying basic probability theory, you can derive the exact likelihood that a thread will be unlucky enough to be ignored for an extended period, even when the system is trying to give everyone a chance .",
            "id": "3649142",
            "problem": "A shared mutual exclusion lock (mutex) protects a single critical section in a system with $N$ concurrent threads that may wait to acquire the lock. When the mutex is released, the scheduler selects the next acquirer uniformly at random among the current set of waiting threads, and these selections are independent across successive releases. Consider one designated waiting thread, denoted $W$, that remains in the waiting set until selected and then departs permanently. The system maintains the waiting set size at $N$ by admitting a newly arriving thread immediately after each selection so that the set size stays constant at $N$ throughout.\n\nIn the operating systems sense, indefinite blocking (also called starvation) occurs when a thread is not scheduled to acquire the shared resource within an operative time budget. For this problem, define starvation for $W$ to mean that $W$ is not selected within $T$ successive mutex handoffs, where $T$ is a fixed positive integer representing the time budget measured in release events.\n\nStarting only from the core definitions above (independence of selections, uniform random choice, and the starvation definition as exceeding the time budget), derive the exact closed-form expression for the probability that $W$ experiences starvation under this budget. Express your final answer as a single simplified analytic expression in terms of $N$ and $T$. No numerical evaluation is required, and no units are involved.",
            "solution": "The mutex handoffs define a sequence of independent selection events. At each handoff, the probability that the designated thread $W$ is chosen is $p = \\frac{1}{N}$ because the scheduler selects uniformly at random among the $N$ waiters and $W$ remains a member of the set until chosen. Consequently, the probability that $W$ is not chosen in a given handoff is $1 - p = 1 - \\frac{1}{N}$.\n\nLet $X$ be the number of handoffs until $W$ is first selected. Under the assumptions of independence and constant success probability $p$, the trials form a sequence of independent Bernoulli events with success probability $p$, and the waiting time $X$ follows a geometric distribution with parameter $p$. The event that $W$ starves under the budget corresponds to $X > T$, that is, $W$ is not selected in any of the first $T$ handoffs.\n\nBecause the selection events are independent, the probability that $W$ is not selected in the first handoff is $1 - \\frac{1}{N}$, and similarly for each subsequent handoff. Therefore, the probability that $W$ is not selected in all of the first $T$ handoffs is the product of the $T$ identical probabilities:\n$$\n\\Pr(X > T) = \\left(1 - \\frac{1}{N}\\right)^{T}.\n$$\nBy the stated starvation definition (not being selected within $T$ handoffs), $\\Pr(X > T)$ is exactly the starvation probability for $W$ under the given budget. Thus, the required expression is\n$$\n\\left(1 - \\frac{1}{N}\\right)^{T}.\n$$\nThis closed form depends only on $N$ and $T$, as requested. For completeness, note that as $T \\to \\infty$, the limit of this probability is $0$, reflecting that indefinite blocking has zero probability under independent uniform random selection in the infinite horizon, even though finite-horizon starvation remains possible due to unlucky draws.",
            "answer": "$$\\boxed{\\left(1 - \\frac{1}{N}\\right)^{T}}$$"
        },
        {
            "introduction": "Identifying and analyzing starvation is a critical skill, but the ultimate goal of an operating system designer is to prevent it. This advanced practice challenges you to move from analyst to architect by designing an anti-starvation mechanism. By formalizing a priority aging scheme, you will derive the precise mathematical conditions required to guarantee fairness, ensuring that even the lowest-priority thread eventually gets its turn on the CPU .",
            "id": "3649191",
            "problem": "An operating system uses a preemptive, priority-based scheduler on a single Central Processing Unit (CPU) with fixed-length time quanta of duration $\\Delta$. Each thread $i$ has a base priority $b_{i} \\in (0,1)$, and an effective priority $p_{i}(t)$ that is updated at the end of every quantum to prevent indefinite blocking (starvation). You are to formalize a priority decay mechanism that avoids oscillatory priority dynamics while guaranteeing that a lower base-priority thread cannot starve in the presence of a higher base-priority thread.\n\nStarting from the core definitions that starvation is indefinite postponement of service and that aging is a monotone increase of effective priority while waiting, proceed as follows:\n\n- Propose a continuous-time decay function $d(t)$ with a single rate parameter $\\lambda>0$ that maps elapsed time $t$ to a multiplicative decay factor on the distance of $p_{i}(t)$ from $b_{i}$, such that the induced discrete-time update at the end of each quantum is monotone and non-oscillatory.\n\n- Given your $d(t)$, suppose the per-quantum update rule is\n$$\np_{i}^{+} \\;=\\; d(\\Delta)\\,p_{i} \\;+\\; \\bigl(1-d(\\Delta)\\bigr)\\,b_{i} \\;+\\; \\mu\\,\\Delta\\,\\mathbf{1}\\{\\text{thread $i$ waited during the quantum}\\},\n$$\nwhere $\\mu>0$ is a constant aging rate and $\\mathbf{1}\\{\\cdot\\}$ is the indicator function. The scheduler always runs the thread with the maximum effective priority at the beginning of a quantum, breaking ties arbitrarily.\n\n- Consider exactly two threads, $H$ and $L$, with base priorities $b_{H}$ and $b_{L}$ satisfying $b_{H}>b_{L}$. Initially $p_{H}(0)=b_{H}$ and $p_{L}(0)=b_{L}$. Analyze the worst-case schedule for $L$ in which $H$ continues to run so long as $p_{H}\\ge p_{L}$. Using only the definitions above and first-principles linear-time-invariant reasoning, derive a closed-form expression for the minimal aging rate $\\mu_{\\min}$, as a function of $b_{H},b_{L},\\lambda$, and $\\Delta$, that guarantees $L$ cannot starve.\n\nYour final answer must be a single closed-form analytic expression for $\\mu_{\\min}$. Do not round. No units are required.",
            "solution": "The problem asks us to formalize a priority update mechanism to prevent starvation. This involves three main steps: proposing a suitable decay function, setting up the system dynamics for a two-thread scenario, and deriving the minimum aging rate $\\mu_{\\min}$ to guarantee the lower-priority thread is not starved.\n\nFirst, we must propose a continuous-time decay function $d(t)$ with a single rate parameter $\\lambda > 0$. The update rule for priority $p_{i}$ in the absence of aging is $p_{i}^{+} = d(\\Delta)p_{i} + (1-d(\\Delta))b_{i}$, where $p_i$ is the current priority and $p_i^+$ is the priority after one quantum of duration $\\Delta$. This can be rewritten as $p_{i}^{+} - b_{i} = d(\\Delta)(p_{i} - b_{i})$, indicating that the deviation of the effective priority from the base priority decays by a factor of $d(\\Delta)$ in each time step. The continuous-time analogue of this discrete first-order process is the first-order linear ordinary differential equation:\n$$ \\frac{d}{dt} \\left( p_{i}(t) - b_{i} \\right) = -\\lambda \\left( p_{i}(t) - b_{i} \\right) $$\nwhere $\\lambda>0$ is the decay rate. The solution to this equation is:\n$$ p_{i}(t) - b_{i} = (p_{i}(0) - b_{i}) \\exp(-\\lambda t) $$\nThis describes the evolution of the priority deviation over a time interval $t$. The multiplicative decay factor applied to the deviation over time $t$ is evidently $\\exp(-\\lambda t)$. Therefore, the most natural and appropriate choice for the decay function is:\n$$ d(t) = \\exp(-\\lambda t) $$\nThis function has a single rate parameter $\\lambda > 0$. For the discrete update over a quantum $\\Delta$, the factor is $d(\\Delta) = \\exp(-\\lambda\\Delta)$. Since $\\lambda > 0$ and $\\Delta > 0$, we have $0 < \\exp(-\\lambda\\Delta) < 1$. In a linear recurrence relation, a characteristic root in this range ensures monotonic, non-oscillatory convergence, satisfying the problem's requirement. For notational convenience, we define the constant $\\gamma = d(\\Delta) = \\exp(-\\lambda\\Delta)$.\n\nNext, we analyze the worst-case scenario for the low-priority thread, $L$. We have two threads, $H$ (high base priority) and $L$ (low base priority), with $b_{H} > b_{L}$. The initial conditions are $p_{H}(0) = b_{H}$ and $p_{L}(0) = b_{L}$. Let $p_{H,k}$ and $p_{L,k}$ denote the effective priorities of threads $H$ and $L$, respectively, at the end of the $k$-th quantum (i.e., at time $t=k\\Delta$). The initial state is $p_{H,0} = b_{H}$ and $p_{L,0} = b_{L}$.\n\nAt the start of the first quantum ($k=0$), we have $p_{H,0} > p_{L,0}$, so the scheduler runs thread $H$. The worst-case for $L$ is that $H$ continues to run as long as its priority is greater than or equal to $L$'s, i.e., $p_{H,k} \\ge p_{L,k}$ for all subsequent steps $k$. Under this assumption, for each quantum $k+1$ (from $t=k\\Delta$ to $t=(k+1)\\Delta$), thread $H$ runs and thread $L$ waits.\n\nThe priority update rules at the end of each quantum are:\nFor thread $H$ (which ran):\n$p_{H,k+1} = \\gamma p_{H,k} + (1-\\gamma)b_{H} + \\mu \\Delta \\cdot 0 = \\gamma p_{H,k} + (1-\\gamma)b_{H}$\nFor thread $L$ (which waited):\n$p_{L,k+1} = \\gamma p_{L,k} + (1-\\gamma)b_{L} + \\mu \\Delta \\cdot 1 = \\gamma p_{L,k} + (1-\\gamma)b_{L} + \\mu\\Delta$\n\nWe now solve these two linear recurrence relations.\nFor thread $H$, the initial condition is $p_{H,0}=b_{H}$. For $k=0$:\n$p_{H,1} = \\gamma p_{H,0} + (1-\\gamma)b_{H} = \\gamma b_{H} + (1-\\gamma)b_{H} = b_{H}$.\nBy induction, if $p_{H,k}=b_{H}$, then $p_{H,k+1} = \\gamma b_{H} + (1-\\gamma)b_{H} = b_{H}$. Thus, as long as $H$ keeps running, its priority remains constant:\n$$ p_{H,k} = b_{H} \\quad \\text{for all } k \\ge 0 $$\n\nFor thread $L$, we have the recurrence $p_{L,k+1} = \\gamma p_{L,k} + C$, where $C = (1-\\gamma)b_{L} + \\mu\\Delta$. This is a standard first-order non-homogeneous recurrence relation. The solution consists of a homogeneous part and a particular solution. The fixed point (particular solution) $p_{L}^*$ satisfies $p_{L}^* = \\gamma p_{L}^* + C$, which gives $p_{L}^* = \\frac{C}{1-\\gamma}$.\n$$ p_{L}^* = \\frac{(1-\\gamma)b_{L} + \\mu\\Delta}{1-\\gamma} = b_{L} + \\frac{\\mu\\Delta}{1-\\gamma} $$\nThe general solution is of the form $p_{L,k} = A\\gamma^k + p_{L}^*$, where $A$ is a constant determined by the initial condition $p_{L,0}=b_{L}$.\n$p_{L,0} = A\\gamma^0 + p_{L}^* = A + b_{L} + \\frac{\\mu\\Delta}{1-\\gamma}$.\n$b_{L} = A + b_{L} + \\frac{\\mu\\Delta}{1-\\gamma} \\implies A = - \\frac{\\mu\\Delta}{1-\\gamma}$.\nThus, the closed-form solution for $p_{L,k}$ is:\n$$ p_{L,k} = \\left(b_{L} + \\frac{\\mu\\Delta}{1-\\gamma}\\right) - \\left(\\frac{\\mu\\Delta}{1-\\gamma}\\right)\\gamma^k = b_{L} + \\frac{\\mu\\Delta}{1-\\gamma}(1-\\gamma^k) $$\n\nStarvation of thread $L$ occurs if it is indefinitely postponed. In our model, this means $p_{L,k} \\le p_{H,k}$ for all $k \\ge 0$. To guarantee that $L$ cannot starve, its priority must eventually exceed that of $H$. Since $p_{L,k}$ is a monotonically increasing function of $k$ (as $0 < \\gamma < 1$), if it ever exceeds $p_{H,k}=b_H$, it will do so. The condition to guarantee no starvation is that the asymptotic limit of $p_{L,k}$ must be strictly greater than $b_H$.\n$$ \\lim_{k\\to\\infty} p_{L,k} > b_{H} $$\nAs $k \\to \\infty$, $\\gamma^k \\to 0$ because $0 < \\gamma < 1$. So, the limit is:\n$$ \\lim_{k\\to\\infty} p_{L,k} = b_{L} + \\frac{\\mu\\Delta}{1-\\gamma} $$\nThe condition to prevent starvation becomes:\n$$ b_{L} + \\frac{\\mu\\Delta}{1-\\gamma} > b_{H} $$\nWe solve this inequality for $\\mu$:\n$$ \\frac{\\mu\\Delta}{1-\\gamma} > b_{H} - b_{L} $$\n$$ \\mu > \\frac{(1-\\gamma)(b_{H} - b_{L})}{\\Delta} $$\nThe minimal aging rate, $\\mu_{\\min}$, is the infimum of the set of $\\mu$ values that satisfy this condition, which corresponds to the boundary of the inequality.\n$$ \\mu_{\\min} = \\frac{(1-\\gamma)(b_{H} - b_{L})}{\\Delta} $$\nFinally, we substitute back $\\gamma = \\exp(-\\lambda\\Delta)$:\n$$ \\mu_{\\min} = \\frac{(1 - \\exp(-\\lambda\\Delta))(b_{H} - b_{L})}{\\Delta} $$\nIf $\\mu$ is set to this value, $p_{L,k}$ will approach $b_H$ asymptotically from below, never quite reaching it in finite time. Therefore, any $\\mu > \\mu_{\\min}$ will guarantee that $p_{L,k}$ exceeds $b_H$ after a finite number of steps, thus preventing starvation. The problem asks for the minimal rate $\\mu_{\\min}$ that establishes this guarantee.",
            "answer": "$$\\boxed{\\frac{\\left(1 - \\exp(-\\lambda\\Delta)\\right)\\left(b_{H} - b_{L}\\right)}{\\Delta}}$$"
        }
    ]
}