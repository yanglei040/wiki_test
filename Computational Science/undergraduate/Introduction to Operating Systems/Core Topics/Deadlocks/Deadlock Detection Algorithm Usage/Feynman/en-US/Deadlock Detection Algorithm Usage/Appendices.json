{
    "hands_on_practices": [
        {
            "introduction": "The most intuitive way to visualize a deadlock is through a Wait-For Graph (WFG), where a cycle of waiting threads tells a clear story of gridlock. This first exercise  allows you to build this intuition from the ground up by manually simulating a sequence of lock requests. By tracing events and drawing the resulting graph, you will gain hands-on experience in identifying the circular-wait condition and determining the minimal actions needed to break the deadlock and restore progress.",
            "id": "3632429",
            "problem": "An operating system (OS) manages $n=6$ concurrent threads $\\{T_1,T_2,T_3,T_4,T_5,T_6\\}$ contending for six distinct non-reentrant mutual-exclusion locks $\\{\\ell_A,\\ell_B,\\ell_C,\\ell_D,\\ell_E,\\ell_F\\}$, all initially free. The OS uses a deadlock detection algorithm based on the Wait-For Graph (WFG), which has a directed edge $T_i \\to T_j$ if and only if thread $T_i$ is waiting for some lock currently held by thread $T_j$. A deadlock is present if and only if the WFG contains at least one directed cycle. When a thread is blocked, it continues to hold all locks it previously acquired. Upon termination of a thread, the OS immediately releases all locks held by that thread.\n\nProcess the following event sequence in order. If a lock requested is free, the requesting thread acquires it; otherwise, the thread blocks and waits for its availability.\n\n- Event $1$: $T_1$ requests $\\ell_A$ and acquires $\\ell_A$.\n- Event $2$: $T_2$ requests $\\ell_B$ and acquires $\\ell_B$.\n- Event $3$: $T_3$ requests $\\ell_C$ and acquires $\\ell_C$.\n- Event $4$: $T_1$ requests $\\ell_B$; since $\\ell_B$ is held by $T_2$, $T_1$ blocks waiting for $\\ell_B$.\n- Event $5$: $T_2$ requests $\\ell_C$; since $\\ell_C$ is held by $T_3$, $T_2$ blocks waiting for $\\ell_C$.\n- Event $6$: $T_3$ requests $\\ell_A$; since $\\ell_A$ is held by $T_1$, $T_3$ blocks waiting for $\\ell_A$.\n- Event $7$: $T_4$ requests $\\ell_D$ and acquires $\\ell_D$.\n- Event $8$: $T_5$ requests $\\ell_E$ and acquires $\\ell_E$.\n- Event $9$: $T_6$ requests $\\ell_F$ and acquires $\\ell_F$.\n- Event $10$: $T_4$ requests $\\ell_E$; since $\\ell_E$ is held by $T_5$, $T_4$ blocks waiting for $\\ell_E$.\n- Event $11$: $T_5$ requests $\\ell_F$; since $\\ell_F$ is held by $T_6$, $T_5$ blocks waiting for $\\ell_F$.\n- Event $12$: $T_6$ requests $\\ell_D$; since $\\ell_D$ is held by $T_4$, $T_6$ blocks waiting for $\\ell_D$.\n\nAfter processing through Event $12$, construct the Wait-For Graph (WFG) implied by the resulting state. Confirm whether the specific cycle $C: T_1 \\to T_2 \\to T_3 \\to T_1$ exists in the WFG at this time. Then, assuming that terminating any thread immediately releases all locks it holds and that no further events occur, compute the minimal number $k$ of threads that must be terminated to ensure that the system is free of deadlock and can make progress. Provide only the value of $k$ as your final answer. Give your answer exactly as an integer with no rounding.",
            "solution": "The problem requires us to analyze a sequence of events in a multithreaded environment to determine the state of deadlock and the minimum number of threads to terminate to resolve it. The analysis will proceed by first tracking the state of locks and threads, then constructing the Wait-For Graph (WFG), identifying cycles within it, and finally determining the minimum number of vertices to remove to make the graph acyclic.\n\nFirst, we trace the state of the system through the given sequence of $12$ events. The state of the system is defined by which threads hold which locks and which threads are waiting for other threads.\n\n- **Initial State**: All six locks $\\{\\ell_A, \\ell_B, \\ell_C, \\ell_D, \\ell_E, \\ell_F\\}$ are free. All six threads $\\{T_1, T_2, T_3, T_4, T_5, T_6\\}$ are ready.\n\n- **Events $1-3$**: Threads $T_1$, $T_2$, and $T_3$ acquire locks $\\ell_A$, $\\ell_B$, and $\\ell_C$ respectively.\n  - After Event $1$: $T_1$ holds $\\ell_A$.\n  - After Event $2$: $T_2$ holds $\\ell_B$.\n  - After Event $3$: $T_3$ holds $\\ell_C$.\n\n- **Events $4-6$**: A set of circular dependencies is established among $T_1, T_2, T_3$.\n  - Event $4$: $T_1$ requests $\\ell_B$, which is held by $T_2$. $T_1$ blocks. This establishes a wait-for dependency: $T_1 \\to T_2$.\n  - Event $5$: $T_2$ requests $\\ell_C$, which is held by $T_3$. $T_2$ blocks. This establishes a wait-for dependency: $T_2 \\to T_3$.\n  - Event $6$: $T_3$ requests $\\ell_A$, which is held by $T_1$. $T_3$ blocks. This establishes a wait-for dependency: $T_3 \\to T_1$.\n\n- **Events $7-9$**: Threads $T_4$, $T_5$, and $T_6$ acquire locks $\\ell_D$, $\\ell_E$, and $\\ell_F$ respectively.\n  - After Event $7$: $T_4$ holds $\\ell_D$.\n  - After Event $8$: $T_5$ holds $\\ell_E$.\n  - After Event $9$: $T_6$ holds $\\ell_F$.\n\n- **Events $10-12$**: A second set of circular dependencies is established among $T_4, T_5, T_6$.\n  - Event $10$: $T_4$ requests $\\ell_E$, which is held by $T_5$. $T_4$ blocks. This establishes a wait-for dependency: $T_4 \\to T_5$.\n  - Event $11$: $T_5$ requests $\\ell_F$, which is held by $T_6$. $T_5$ blocks. This establishes a wait-for dependency: $T_5 \\to T_6$.\n  - Event $12$: $T_6$ requests $\\ell_D$, which is held by $T_4$. $T_6$ blocks. This establishes a wait-for dependency: $T_6 \\to T_4$.\n\nAfter processing all $12$ events, the state of the system is as follows:\n- **Lock Holders**:\n  - $T_1$ holds $\\ell_A$.\n  - $T_2$ holds $\\ell_B$.\n  - $T_3$ holds $\\ell_C$.\n  - $T_4$ holds $\\ell_D$.\n  - $T_5$ holds $\\ell_E$.\n  - $T_6$ holds $\\ell_F$.\n- **Waiting Threads**:\n  - $T_1$ is waiting for $\\ell_B$ (held by $T_2$).\n  - $T_2$ is waiting for $\\ell_C$ (held by $T_3$).\n  - $T_3$ is waiting for $\\ell_A$ (held by $T_1$).\n  - $T_4$ is waiting for $\\ell_E$ (held by $T_5$).\n  - $T_5$ is waiting for $\\ell_F$ (held by $T_6$).\n  - $T_6$ is waiting for $\\ell_D$ (held by $T_4$).\n\nNext, we construct the Wait-For Graph, $G=(V, E)$, where the set of vertices $V$ is the set of threads, and a directed edge $(T_i, T_j) \\in E$ exists if thread $T_i$ is waiting for a lock held by thread $T_j$.\n- Vertex set: $V = \\{T_1, T_2, T_3, T_4, T_5, T_6\\}$.\n- Edge set: $E = \\{(T_1, T_2), (T_2, T_3), (T_3, T_1), (T_4, T_5), (T_5, T_6), (T_6, T_4)\\}$.\n\nA deadlock exists if and only if the WFG contains at least one directed cycle. We examine the graph for cycles.\nThe edge set clearly defines two distinct cycles:\n1.  Cycle $C_1$: $T_1 \\to T_2 \\to T_3 \\to T_1$. This cycle is formed by the edges $(T_1, T_2)$, $(T_2, T_3)$, and $(T_3, T_1)$.\n2.  Cycle $C_2$: $T_4 \\to T_5 \\to T_6 \\to T_4$. This cycle is formed by the edges $(T_4, T_5)$, $(T_5, T_6)$, and $(T_6, T_4)$.\n\nThe problem explicitly asks to confirm the existence of the cycle $C: T_1 \\to T_2 \\to T_3 \\to T_1$. Based on our construction of the WFG, this cycle is present and is one of the two deadlocks in the system.\n\nThe final task is to compute the minimal number $k$ of threads that must be terminated to eliminate all deadlocks. Terminating a thread corresponds to removing its corresponding vertex from the WFG. To break all cycles in a directed graph, we must find a minimum feedback vertex set, which is a smallest set of vertices whose removal leaves the graph acyclic.\n\nThe WFG in this problem consists of two vertex-disjoint components, each being a simple cycle.\n- The first component involves vertices $\\{T_1, T_2, T_3\\}$ and forms cycle $C_1$.\n- The second component involves vertices $\\{T_4, T_5, T_6\\}$ and forms cycle $C_2$.\n\nSince the two cycles are vertex-disjoint, removing a vertex from one cycle does not affect the other. Therefore, to break all cycles, we must break each cycle independently.\n- To break cycle $C_1$, we must terminate at least one thread from the set $\\{T_1, T_2, T_3\\}$. The minimum number required is $1$.\n- To break cycle $C_2$, we must terminate at least one thread from the set $\\{T_4, T_5, T_6\\}$. The minimum number required is $1$.\n\nThe total minimum number of threads to terminate, $k$, is the sum of the minimums required for each disjoint cycle.\n$$k = (\\text{min threads for } C_1) + (\\text{min threads for } C_2) = 1 + 1 = 2$$\nFor example, terminating threads $T_1$ and $T_4$ would be one possible minimal set of terminations. Terminating $T_1$ releases $\\ell_A$, breaking cycle $C_1$. Terminating $T_4$ releases $\\ell_D$, breaking cycle $C_2$. The resulting system would be free of deadlocks.\n\nThus, the minimal number of threads that must be terminated is $2$.",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "Real-world systems often manage resource types with multiple identical instances, such as CPU cores or memory blocks, a scenario where a simple Wait-For Graph is insufficient. This practice  introduces the more general, matrix-based detection algorithm, which is a cornerstone of modern operating systems. By analyzing the system's state through its $\\mathbf{Allocation}$, $\\mathbf{Request}$, and $\\mathbf{Available}$ matrices, you will learn to systematically determine if progress is possible for all processes or if a subset is irrecoverably deadlocked.",
            "id": "3632410",
            "problem": "Consider an Operating System (OS) with $n=6$ processes $\\{P_0,P_1,P_2,P_3,P_4,P_5\\}$ competing for $m=4$ resource types $\\{R_1,R_2,R_3,R_4\\}$, each with multiple instances. The system state is characterized by the resource allocation matrix $\\mathbf{Allocation} \\in \\mathbb{Z}^{6 \\times 4}$, the outstanding request matrix $\\mathbf{Request} \\in \\mathbb{Z}^{6 \\times 4}$, and the currently available instances vector $\\mathbf{Available} \\in \\mathbb{Z}^{4}$, all given below. Each row corresponds to a process $P_i$, and each column corresponds to a resource type $R_j$.\n\n$$\n\\mathbf{Allocation} =\n\\begin{pmatrix}\n1  0  0  1 \\\\\n0  0  1  0 \\\\\n0  2  0  0 \\\\\n1  0  0  0 \\\\\n0  0  1  1 \\\\\n0  1  0  0\n\\end{pmatrix},\n\\quad\n\\mathbf{Request} =\n\\begin{pmatrix}\n0  0  1  0 \\\\\n1  0  0  0 \\\\\n0  1  0  0 \\\\\n0  0  0  0 \\\\\n0  0  0  1 \\\\\n0  1  0  0\n\\end{pmatrix},\n\\quad\n\\mathbf{Available} =\n\\begin{pmatrix}\n1  0  1  0\n\\end{pmatrix}.\n$$\n\nUse the classical deadlock detection algorithm for multiple-instance resources that iteratively searches for an unfinished process $P_i$ whose request vector $Request_i$ satisfies $Request_i \\leq Work$ (with $Work$ initialized to $\\mathbf{Available}$), and when found, treats $P_i$ as able to complete and release its allocation, updating $Work \\leftarrow Work + Allocation_i$. Continue until no such $P_i$ exists; the processes that remain unfinished at that point are deemed unfinishable.\n\nDefine the quantity $S$ to be the sum of the indices of all unfinishable processes, i.e., if the unfinishable set is $\\{P_{i_1}, P_{i_2}, \\dots\\}$ then $S = i_1 + i_2 + \\dots$. Compute $S$. Provide your final answer as an exact integer. No rounding is required.",
            "solution": "The givens are:\n- Number of processes: $n=6$, $\\{P_0,P_1,P_2,P_3,P_4,P_5\\}$.\n- Number of resource types: $m=4$, $\\{R_1,R_2,R_3,R_4\\}$.\n- Allocation matrix $\\mathbf{Allocation} \\in \\mathbb{Z}^{6 \\times 4}$:\n$$\n\\mathbf{Allocation} =\n\\begin{pmatrix}\n1  0  0  1 \\\\\n0  0  1  0 \\\\\n0  2  0  0 \\\\\n1  0  0  0 \\\\\n0  0  1  1 \\\\\n0  1  0  0\n\\end{pmatrix}\n$$\n- Request matrix $\\mathbf{Request} \\in \\mathbb{Z}^{6 \\times 4}$:\n$$\n\\mathbf{Request} =\n\\begin{pmatrix}\n0  0  1  0 \\\\\n1  0  0  0 \\\\\n0  1  0  0 \\\\\n0  0  0  0 \\\\\n0  0  0  1 \\\\\n0  1  0  0\n\\end{pmatrix}\n$$\n- Available vector $\\mathbf{Available} \\in \\mathbb{Z}^{4}$:\n$$\n\\mathbf{Available} = \\begin{pmatrix} 1  0  1  0 \\end{pmatrix}\n$$\n\nWe apply the deadlock detection algorithm. Let $\\mathbf{Work}$ be a vector of length $m$ and $\\mathbf{Finish}$ be a boolean vector of length $n$. The vector inequality $\\mathbf{A} \\leq \\mathbf{B}$ holds if and only if $A_k \\leq B_k$ for all components $k$.\n\n**Step 1: Initialization**\nInitialize $\\mathbf{Work}$ to $\\mathbf{Available}$ and $\\mathbf{Finish}_i$ to false for all processes $i = 0, \\dots, 5$.\n$$ \\mathbf{Work} = \\mathbf{Available} = \\begin{pmatrix} 1  0  1  0 \\end{pmatrix} $$\n$$ \\mathbf{Finish} = \\begin{pmatrix} \\text{false}  \\text{false}  \\text{false}  \\text{false}  \\text{false}  \\text{false} \\end{pmatrix} $$\n\n**Step 2: Iterative Search and Update**\nThe algorithm proceeds by finding an index $i$ such that $\\mathbf{Finish}_i$ is false and its request vector $\\mathbf{Request}_i \\leq \\mathbf{Work}$. If found, the process can theoretically finish, so we release its resources by updating $\\mathbf{Work} \\leftarrow \\mathbf{Work} + \\mathbf{Allocation}_i$ and setting $\\mathbf{Finish}_i \\leftarrow \\text{true}$. This process is repeated until no such process can be found.\n\n**Iteration 1:**\nWe search for a process $P_i$ with $\\mathbf{Finish}_i = \\text{false}$ and $\\mathbf{Request}_i \\leq \\mathbf{Work} = \\begin{pmatrix} 1  0  1  0 \\end{pmatrix}$.\n- $P_0$: $\\mathbf{Request}_0 = \\begin{pmatrix} 0  0  1  0 \\end{pmatrix} \\leq \\begin{pmatrix} 1  0  1  0 \\end{pmatrix}$. This condition is met.\nLet's select $P_0$.\nUpdate $\\mathbf{Work}$: $\\mathbf{Work} \\leftarrow \\mathbf{Work} + \\mathbf{Allocation}_0 = \\begin{pmatrix} 1  0  1  0 \\end{pmatrix} + \\begin{pmatrix} 1  0  0  1 \\end{pmatrix} = \\begin{pmatrix} 2  0  1  1 \\end{pmatrix}$.\nUpdate $\\mathbf{Finish}$: $\\mathbf{Finish}_0 \\leftarrow \\text{true}$.\nThe current state is $\\mathbf{Work} = \\begin{pmatrix} 2  0  1  1 \\end{pmatrix}$ and $\\mathbf{Finish} = \\begin{pmatrix} \\text{true}  \\text{false}  \\text{false}  \\text{false}  \\text{false}  \\text{false} \\end{pmatrix}$.\n\n**Iteration 2:**\nWe search for an unfinished process $P_i$ with $\\mathbf{Request}_i \\leq \\mathbf{Work} = \\begin{pmatrix} 2  0  1  1 \\end{pmatrix}$.\n- $P_1$: $\\mathbf{Request}_1 = \\begin{pmatrix} 1  0  0  0 \\end{pmatrix} \\leq \\begin{pmatrix} 2  0  1  1 \\end{pmatrix}$. This condition is met.\nLet's select $P_1$.\nUpdate $\\mathbf{Work}$: $\\mathbf{Work} \\leftarrow \\mathbf{Work} + \\mathbf{Allocation}_1 = \\begin{pmatrix} 2  0  1  1 \\end{pmatrix} + \\begin{pmatrix} 0  0  1  0 \\end{pmatrix} = \\begin{pmatrix} 2  0  2  1 \\end{pmatrix}$.\nUpdate $\\mathbf{Finish}$: $\\mathbf{Finish}_1 \\leftarrow \\text{true}$.\nThe current state is $\\mathbf{Work} = \\begin{pmatrix} 2  0  2  1 \\end{pmatrix}$ and $\\mathbf{Finish} = \\begin{pmatrix} \\text{true}  \\text{true}  \\text{false}  \\text{false}  \\text{false}  \\text{false} \\end{pmatrix}$.\n\n**Iteration 3:**\nWe search for an unfinished process $P_i$ with $\\mathbf{Request}_i \\leq \\mathbf{Work} = \\begin{pmatrix} 2  0  2  1 \\end{pmatrix}$.\n- $P_2$: $\\mathbf{Request}_2 = \\begin{pmatrix} 0  1  0  0 \\end{pmatrix}$. This is not $\\leq \\mathbf{Work}$ because for the second resource, $1 > 0$.\n- $P_3$: $\\mathbf{Request}_3 = \\begin{pmatrix} 0  0  0  0 \\end{pmatrix} \\leq \\begin{pmatrix} 2  0  2  1 \\end{pmatrix}$. This condition is met.\nLet's select $P_3$.\nUpdate $\\mathbf{Work}$: $\\mathbf{Work} \\leftarrow \\mathbf{Work} + \\mathbf{Allocation}_3 = \\begin{pmatrix} 2  0  2  1 \\end{pmatrix} + \\begin{pmatrix} 1  0  0  0 \\end{pmatrix} = \\begin{pmatrix} 3  0  2  1 \\end{pmatrix}$.\nUpdate $\\mathbf{Finish}$: $\\mathbf{Finish}_3 \\leftarrow \\text{true}$.\nThe current state is $\\mathbf{Work} = \\begin{pmatrix} 3  0  2  1 \\end{pmatrix}$ and $\\mathbf{Finish} = \\begin{pmatrix} \\text{true}  \\text{true}  \\text{false}  \\text{true}  \\text{false}  \\text{false} \\end{pmatrix}$.\n\n**Iteration 4:**\nWe search for an unfinished process $P_i$ with $\\mathbf{Request}_i \\leq \\mathbf{Work} = \\begin{pmatrix} 3  0  2  1 \\end{pmatrix}$.\n- $P_2$: $\\mathbf{Request}_2$ is still not satisfiable.\n- $P_4$: $\\mathbf{Request}_4 = \\begin{pmatrix} 0  0  0  1 \\end{pmatrix} \\leq \\begin{pmatrix} 3  0  2  1 \\end{pmatrix}$. This condition is met.\nLet's select $P_4$.\nUpdate $\\mathbf{Work}$: $\\mathbf{Work} \\leftarrow \\mathbf{Work} + \\mathbf{Allocation}_4 = \\begin{pmatrix} 3  0  2  1 \\end{pmatrix} + \\begin{pmatrix} 0  0  1  1 \\end{pmatrix} = \\begin{pmatrix} 3  0  3  2 \\end{pmatrix}$.\nUpdate $\\mathbf{Finish}$: $\\mathbf{Finish}_4 \\leftarrow \\text{true}$.\nThe current state is $\\mathbf{Work} = \\begin{pmatrix} 3  0  3  2 \\end{pmatrix}$ and $\\mathbf{Finish} = \\begin{pmatrix} \\text{true}  \\text{true}  \\text{false}  \\text{true}  \\text{true}  \\text{false} \\end{pmatrix}$.\n\n**Iteration 5:**\nWe search for an unfinished process $P_i$ with $\\mathbf{Request}_i \\leq \\mathbf{Work} = \\begin{pmatrix} 3  0  3  2 \\end{pmatrix}$. The remaining unfinished processes are $P_2$ and $P_5$.\n- $P_2$: $\\mathbf{Request}_2 = \\begin{pmatrix} 0  1  0  0 \\end{pmatrix}$. This is not $\\leq \\mathbf{Work}$ because for $R_2$, $1 > 0$.\n- $P_5$: $\\mathbf{Request}_5 = \\begin{pmatrix} 0  1  0  0 \\end{pmatrix}$. This is not $\\leq \\mathbf{Work}$ because for $R_2$, $1 > 0$.\n\n**Step 3: Termination**\nNo remaining unfinished process can have its request satisfied with the current $\\mathbf{Work}$ vector. The algorithm terminates.\n\n**Step 4: Identify Unfinishable Processes and Calculate S**\nThe processes for which $\\mathbf{Finish}_i$ remains false are considered unfinishable. From the final $\\mathbf{Finish}$ vector $\\begin{pmatrix} \\text{true}  \\text{true}  \\text{false}  \\text{true}  \\text{true}  \\text{false} \\end{pmatrix}$, the unfinishable processes are $\\{P_2, P_5\\}$.\n\nThe problem defines $S$ as the sum of the indices of all unfinishable processes.\n$$ S = 2 + 5 = 7 $$\nThe physical reason for the deadlock is that both $P_2$ and $P_5$ are requesting an instance of resource $R_2$. There are $0$ instances of $R_2$ available, and no other process that can finish holds any instances of $R_2$ to release. Thus, $P_2$ and $P_5$ will wait indefinitely.",
            "answer": "$$\\boxed{7}$$"
        },
        {
            "introduction": "A detection algorithm is only as accurate as its model of resource interactions. What happens when we apply a simple deadlock model to more sophisticated synchronization tools, like reader-writer locks? This advanced exercise  explores this critical question by contrasting a correct model with a naive one that fails to account for lock-sharing semantics. You will discover how this modeling error can lead the system to misinterpret a benign condition like writer starvation as a catastrophic deadlock, highlighting why understanding the nuances of synchronization is paramount.",
            "id": "3632504",
            "problem": "Consider a single reader–writer lock with reader preference, which allows any number of readers to hold the lock concurrently but requires a writer to hold the lock exclusively. The system follows reader preference: once a writer arrives, subsequent readers are still admitted immediately; thus a writer can starve if readers keep arriving, but there is no true deadlock under correct modeling because readers do not wait for other readers. The operating system’s deadlock detector constructs a Wait-For Graph (WFG), where nodes are threads and an edge $P \\to Q$ exists if and only if thread $P$ is waiting for a resource currently held or guaranteed to be acquired before $P$ by thread $Q$. A system is in deadlock if and only if there is a directed cycle in the WFG.\n\nAt time $t_0$, suppose there are $x$ reader threads $R_1,\\dots,R_x$ holding the lock and $y$ writer threads $W_1,\\dots,W_y$ that have arrived and are waiting to acquire the lock. After $t_0$, $n$ additional reader threads $R_{x+1},\\dots,R_{x+n}$ arrive. Under reader preference, these $n$ readers immediately join the set of current holders without waiting. However, a naive deadlock detector that incorrectly treats the reader–writer lock as a strict first-in-first-out mutual exclusion lock, ignoring lock modes and reader preference, builds its WFG by adding, for each thread waiting to acquire the lock, edges to every thread that either currently holds the lock or is anywhere in the queue (irrespective of queue position and lock mode). Under this naive model:\n- For each waiting writer $W_k$, the detector adds edges $W_k \\to R_i$ for all $i \\in \\{1,\\dots,x+n\\}$.\n- For each newly arrived reader $R_j$ with $j \\in \\{x+1,\\dots,x+n\\}$, the detector (wrongly) assumes it is queued behind the writers and adds edges $R_j \\to W_k$ for all $k \\in \\{1,\\dots,y\\}$.\n\nAnswer the following in one derivation grounded on the definitions above:\n1. Explain from first principles of WFG construction and reader–writer semantics why correct detection must treat readers differently from writers, and why the reader-preference behavior described does not create a deadlock under correct modeling.\n2. Under the naive detector, quantify the number of distinct two-node cycles (mutual-wait pairs) that appear in the WFG as a function of $n$ and $y$.\n3. The deployment of the naive detector triggers a deadlock alarm only when the number of distinct two-node cycles is at least a fixed threshold $T$ (to avoid spurious single-cycle noise). Determine, in closed form, the smallest integer $n^{\\star}$ such that the naive detector will misclassify the situation as deadlock (i.e., the number of two-node cycles is at least $T$), expressed as a function of $y$ and $T$.\n\nExpress your final answer as a single closed-form analytic expression for $n^{\\star}$. No rounding is required.",
            "solution": "**1. Correct Deadlock Detection Analysis**\n\nA deadlock is defined by the existence of a cycle in the Wait-For Graph (WFG). An edge $P \\to Q$ in the WFG signifies that thread $P$ is in a waiting state, pending the release of a resource held by thread $Q$. We construct the correct WFG for the described state.\n\nThe threads in the system are the readers $R_1, \\dots, R_{x+n}$ and the writers $W_1, \\dots, W_y$. We must determine which threads are waiting.\n- The readers $R_1, \\dots, R_x$ held the lock at time $t_0$. They are not waiting.\n- The writers $W_1, \\dots, W_y$ arrived and are waiting to acquire the lock. The lock is held by the readers. Therefore, for each writer $W_k$ (where $k \\in \\{1, \\dots, y\\}$), it is waiting on all current holders of the lock. The holders are the readers $R_1, \\dots, R_{x+n}$. Thus, edges $W_k \\to R_i$ exist for all $k \\in \\{1, \\dots, y\\}$ and $i \\in \\{1, \\dots, x+n\\}$.\n- The new readers $R_{x+1}, \\dots, R_{x+n}$ arrive after the writers. However, the system enforces reader preference, meaning these new readers are \"admitted immediately\" and \"join the set of current holders without waiting.\" Since they do not wait, there are no outgoing edges from any reader node $R_j$ in the WFG.\n\nA cycle in a directed graph is a path of one or more edges that starts and ends at the same node, for example, $P_1 \\to P_2 \\to \\dots \\to P_m \\to P_1$. In our correctly constructed WFG, the only extant edges are of the form $W_k \\to R_i$. There are no edges originating from any reader node $R_i$. Consequently, it is impossible to form a path of length $2$ or greater, as any path must terminate at a reader node. For a cycle to exist, there would need to be a path from a reader $R_i$ back to a writer $W_k$ (or any other node from which a path to $W_k$ exists), but no such paths can be formed. The WFG is a bipartite graph where all edges are directed from the set of writer nodes to the set of reader nodes. Such a graph is acyclic by definition. Therefore, under a correct WFG model, there is no deadlock.\n\n**2. Quantification of Two-Node Cycles under the Naive Detector**\n\nThe naive detector operates under a flawed model. We analyze the WFG it constructs to count the number of two-node cycles. A two-node cycle between threads $P$ and $Q$ consists of two edges: $P \\to Q$ and $Q \\to P$. We seek to find pairs of threads for which the naive detector's rules create such a mutual-wait condition.\n\nThe rules for edge creation are:\n- (A) For each waiting writer $W_k$ ($k \\in \\{1, \\dots, y\\}$), edges $W_k \\to R_i$ are added for all $i \\in \\{1, \\dots, x+n\\}$.\n- (B) For each newly arrived reader $R_j$ ($j \\in \\{x+1, \\dots, x+n\\}$), edges $R_j \\to W_k$ are added for all $k \\in \\{1, \\dots, y\\}$.\n\nLet us consider a pair of threads consisting of one writer $W_k$ and one new reader $R_j$, where $k \\in \\{1, \\dots, y\\}$ and $j \\in \\{x+1, \\dots, x+n\\}$.\n- Does the edge $W_k \\to R_j$ exist? Yes, according to rule (A), an edge is created from each writer $W_k$ to every reader, including the new readers.\n- Does the edge $R_j \\to W_k$ exist? Yes, according to rule (B), an edge is created from each new reader $R_j$ to every writer $W_k$.\n\nThus, for every writer $W_k$ and every new reader $R_j$, the naive detector constructs a two-node cycle $\\{W_k, R_j\\}$.\n\nWe must now count the number of distinct such cycles. A distinct two-node cycle is defined by a unique pair of nodes. The pairs are of the form $\\{W_k, R_j\\}$.\n- The number of choices for the writer thread $W_k$ is $y$.\n- The number of choices for the new reader thread $R_j$ is $n$.\n\nThe total number of unique pairs, and thus the number of distinct two-node cycles, is the product of the number of choices for each type of thread. Let $C$ be the number of cycles.\n$$C = n \\times y = ny$$\nNote that the original readers $R_1, \\dots, R_x$ do not participate in these two-node cycles. While rule (A) creates edges $W_k \\to R_i$ for $i \\in \\{1, \\dots, x\\}$, rule (B) does not apply to these readers, so no edges of the form $R_i \\to W_k$ are created for this group. Therefore, the parameter $x$ is not relevant to the count of two-node cycles.\n\n**3. Determination of the Minimum Integer $n^{\\star}$**\n\nThe naive detector triggers an alarm if the number of distinct two-node cycles, $C$, is at least a fixed threshold $T$.\n$$C \\ge T$$\nSubstituting the expression for $C$ from part $2$:\n$$ny \\ge T$$\nWe are asked to find the smallest integer $n$, denoted $n^{\\star}$, that satisfies this condition. We can solve the inequality for $n$. Assuming $y > 0$ (as if $y=0$, there are no waiting writers and thus $C=0$, making the alarm impossible for $T>0$), we can divide by $y$:\n$$n \\ge \\frac{T}{y}$$\nSince $n$ must be an integer representing a count of threads, the smallest integer value of $n$ that satisfies this inequality is the ceiling of the expression $\\frac{T}{y}$. The ceiling function, denoted $\\lceil z \\rceil$, gives the smallest integer greater than or equal to $z$.\nTherefore, the smallest integer $n^{\\star}$ is:\n$$n^{\\star} = \\left\\lceil \\frac{T}{y} \\right\\rceil$$\n\nThis is the final closed-form expression for $n^{\\star}$ as a function of $y$ and $T$.",
            "answer": "$$\\boxed{\\left\\lceil \\frac{T}{y} \\right\\rceil}$$"
        }
    ]
}