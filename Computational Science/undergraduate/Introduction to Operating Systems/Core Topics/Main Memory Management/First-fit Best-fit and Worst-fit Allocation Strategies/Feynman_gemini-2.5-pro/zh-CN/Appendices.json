{
    "hands_on_practices": [
        {
            "introduction": "我们首先通过一个简单且可重复的内存请求场景来建立直观认识。这项练习旨在通过手动追踪首次适应（First-Fit）、最佳适应（Best-Fit）和最差适应（Worst-Fit）策略，来理解它们的基本工作原理。我们将根据两个关键指标来比较这些策略 ：搜索效率和内存块的匹配质量，为理解它们的核心权衡奠定基础。",
            "id": "3644104",
            "problem": "考虑一个操作系统（OS）中的单区域动态内存分配器，该分配器使用线性空闲列表和连续块。该分配器可以采用三种策略之一进行操作：首次适应（first-fit）、最佳适应（best-fit）或最差适应（worst-fit）。空闲列表以固定顺序维护，并恰好包含三个空闲块，其大小按顺序分别为 $8$、$6$ 和 $9$ 个单位。一个周期为 $k=3$ 的循环工作负载在每个步骤中发出一个分配请求，大小分别为 $6$、$8$ 和 $7$ 个单位，然后无限重复。在下一次分配请求到来之前，每次分配之后都会立即释放相同请求大小的内存。假设分配较大块时，分裂操作会在分裂点留下一个剩余的空闲碎片，并且立即释放会触发合并操作，从而在下一次请求之前确定性地将空闲列表恢复到其原始状态和顺序。在整个周期中，分配器不会改变空闲列表的顺序。\n\n基本定义：\n- 首次适应（first-fit）分配器选择空闲列表中第一个大小至少等于请求大小的块。\n- 最佳适应（best-fit）分配器选择空闲列表中大小至少等于请求大小的最小块；假设采用一个朴素的实现，它会扫描整个空闲列表以确定最小的足够大的块。\n- 最差适应（worst-fit）分配器选择空闲列表中大小至少等于请求大小的最大块；假设采用一个朴素的实现，它会扫描整个空闲列表以确定最大的足够大的块。\n\n设 $\\Pr[\\text{exact-fit}]$ 表示在一个包含 $k$ 个请求的周期内，分配器返回的块大小与请求大小完全相等的概率。设 $T$ 表示在所述的朴素实现下，每个分配请求检查的空闲列表块头的期望数量，该期望值是在一个周期的 $k$ 个请求上平均计算得出的。\n\n对于这个循环工作负载，确定哪种策略能最大化 $\\Pr[\\text{exact-fit}]$，哪种策略能最小化 $T$。将三种策略编码为数字：首次适应（first-fit）$=1$，最佳适应（best-fit）$=2$，最差适应（worst-fit）$=3$。将您的最终答案表示为行矩阵 $\\begin{pmatrix} s_{\\max}  s_{\\min} \\end{pmatrix}$，其中 $s_{\\max}$ 是最大化 $\\Pr[\\text{exact-fit}]$ 的策略的代码，$s_{\\min}$ 是最小化 $T$ 的策略的代码。无需四舍五入，也无需报告单位。使用指定的编码将最终答案表示为行矩阵。",
            "solution": "该问题要求在特定的循环工作负载下，分析三种动态内存分配策略——首次适应（first-fit）、最佳适应（best-fit）和最差适应（worst-fit）。我们的任务是确定哪种策略能最大化精确匹配分配的概率（记为 $\\Pr[\\text{exact-fit}]$），以及哪种策略能最小化每个请求检查的空闲列表块头的期望数量（记为 $T$）。三种策略被编码为：首次适应 $=1$，最佳适应 $=2$，最差适应 $=3$。\n\n空闲列表的初始状态是一个有序的块大小序列：$L = (8, 6, 9)$。此列表包含 $3$ 个块。\n工作负载是一个重复周期 $k=3$ 的分配请求，大小为 $R = (r_1, r_2, r_3) = (6, 8, 7)$。\n一个关键条件是，在每次分配并立即释放所分配的块之后，空闲列表都会确定性地恢复到其原始状态和顺序 $L$。这一简化意味着周期中的 $k=3$ 个请求中的每一个都是针对相同的初始空闲列表 $L=(8, 6, 9)$ 进行评估的。\n\n我们将对每个策略在一个包含 $k=3$ 个请求的周期内进行分析。\n\n1. 首次适应策略 ($s=1$)\n该策略选择空闲列表中第一个足以满足请求的可用块。列表按其固定顺序 $(8, 6, 9)$ 进行扫描。\n\n- 请求 $r_1 = 6$：分配器从头开始扫描列表。第一个块的大小为 $8$。由于 $8 \\ge 6$，该块被选中进行分配。搜索停止。这不是精确匹配（$8 > 6$）。检查的块数量为 $1$。\n- 请求 $r_2 = 8$：列表恢复为 $(8, 6, 9)$。分配器扫描列表。第一个块的大小为 $8$。由于 $8 \\ge 8$，该块被选中。这是一个精确匹配。检查的块数量为 $1$。\n- 请求 $r_3 = 7$：列表恢复为 $(8, 6, 9)$。分配器扫描列表。第一个块的大小为 $8$。由于 $8 \\ge 7$，该块被选中。这不是精确匹配（$8 > 7$）。检查的块数量为 $1$。\n\n对于首次适应策略：\n- 一个周期内精确匹配分配的总数为 $1$。\n- 精确匹配的概率为 $\\Pr[\\text{exact-fit}]_{ff} = \\frac{1}{3}$。\n- 周期内检查的块头总数为 $1 + 1 + 1 = 3$。\n- 每个请求的期望检查次数为 $T_{ff} = \\frac{3}{3} = 1$。\n\n2. 最佳适应策略 ($s=2$)\n该策略从整个空闲列表中选择足以满足请求的最小块。问题指明了一个朴素的实现，即每次请求都扫描整个包含 $3$ 个块的列表以找到最小的足够大的块。\n\n- 请求 $r_1 = 6$：分配器扫描整个列表 $(8, 6, 9)$。足够大的块集合为 $\\{8, 6, 9\\}$。其中最小的是大小为 $6$ 的块。该块被选中。这是一个精确匹配。检查的块数量为 $3$。\n- 请求 $r_2 = 8$：列表恢复。分配器扫描整个列表 $(8, 6, 9)$。足够大的块集合为 $\\{8, 9\\}$。其中最小的是大小为 $8$ 的块。该块被选中。这是一个精确匹配。检查的块数量为 $3$。\n- 请求 $r_3 = 7$：列表恢复。分配器扫描整个列表 $(8, 6, 9)$。足够大的块集合为 $\\{8, 9\\}$。其中最小的是大小为 $8$ 的块。该块被选中。这不是精确匹配（$8 > 7$）。检查的块数量为 $3$。\n\n对于最佳适应策略：\n- 一个周期内精确匹配分配的总数为 $2$。\n- 精确匹配的概率为 $\\Pr[\\text{exact-fit}]_{bf} = \\frac{2}{3}$。\n- 检查的块头总数为 $3 + 3 + 3 = 9$。\n- 每个请求的期望检查次数为 $T_{bf} = \\frac{9}{3} = 3$。\n\n3. 最差适应策略 ($s=3$)\n该策略从整个空闲列表中选择足够大的最大块。这也使用了一个朴素的实现，即每次请求都扫描整个包含 $3$ 个块的列表。\n\n- 请求 $r_1 = 6$：分配器扫描整个列表 $(8, 6, 9)$。足够大的块集合为 $\\{8, 6, 9\\}$。其中最大的是大小为 $9$ 的块。该块被选中。这不是精确匹配（$9 > 6$）。检查的块数量为 $3$。\n- 请求 $r_2 = 8$：列表恢复。分配器扫描整个列表 $(8, 6, 9)$。足够大的块集合为 $\\{8, 9\\}$。其中最大的是大小为 $9$ 的块。该块被选中。这不是精确匹配（$9 > 8$）。检查的块数量为 $3$。\n- 请求 $r_3 = 7$：列表恢复。分配器扫描整个列表 $(8, 6, 9)$。足够大的块集合为 $\\{8, 9\\}$。其中最大的是大小为 $9$ 的块。该块被选中。这不是精确匹配（$9 > 7$）。检查的块数量为 $3$。\n\n对于最差适应策略：\n- 一个周期内精确匹配分配的总数为 $0$。\n- 精确匹配的概率为 $\\Pr[\\text{exact-fit}]_{wf} = \\frac{0}{3} = 0$。\n- 检查的块头总数为 $3 + 3 + 3 = 9$。\n- 每个请求的期望检查次数为 $T_{wf} = \\frac{9}{3} = 3$。\n\n指标摘要：\n- 首次适应（$s=1$）：$\\Pr[\\text{exact-fit}]_{ff} = \\frac{1}{3}$，$T_{ff} = 1$。\n- 最佳适应（$s=2$）：$\\Pr[\\text{exact-fit}]_{bf} = \\frac{2}{3}$，$T_{bf} = 3$。\n- 最差适应（$s=3$）：$\\Pr[\\text{exact-fit}]_{wf} = 0$，$T_{wf} = 3$。\n\n最优策略的确定：\n为了找到最大化 $\\Pr[\\text{exact-fit}]$ 的策略，我们比较计算出的概率：$\\{\\frac{1}{3}, \\frac{2}{3}, 0\\}$。最大值是 $\\frac{2}{3}$，对应于最佳适应策略。因此，最大化此概率的策略代码是 $s_{\\max} = 2$。\n\n为了找到最小化期望检查次数 $T$ 的策略，我们比较平均检查次数：$\\{1, 3, 3\\}$。最小值是 $1$，对应于首次适应策略。因此，最小化此成本的策略代码是 $s_{\\min} = 1$。\n\n问题要求将最终答案报告为行矩阵 $(s_{\\max} \\ \\ s_{\\min})$。代入确定的值，我们得到矩阵 $(2 \\ \\ 1)$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n2  1\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在理解了基本工作方式后，我们转向更具策略性的分析。一个内存分配器的长期健康状况取决于其满足未来请求的能力，而这通常与其拥有的最大空闲块的大小有关。这项练习挑战你像一个“对手”一样思考，设计一个请求序列，以突显首次适应和最差适应策略选择下，内存状态的巨大差异 ，从而深刻洞察碎片化是如何产生的。",
            "id": "3644191",
            "problem": "考虑一个可变大小分区内存分配器，它管理一个按内存地址递增顺序排列的空闲链表。该分配器在分配过程中使用块分割，但没有紧凑或合并操作：当从一个大小为 $f \\ge s$ 的空闲块中满足一个大小为 $s$ 的请求时，分配器会创建一个大小为 $s$ 的已分配块和一个大小为 $f - s$ 的剩余空闲块（如果 $f = s$，则所选的空闲块会消失）。定义首次适应 (FF) 策略为选择地址顺序上第一个大小至少为请求大小的空闲块，以及最差适应 (WF) 策略为选择大小至少为请求大小的最大空闲块。\n\n初始时，空闲链表由 $m$ 个大小为 $b$ 的小块和一个大小为 $B$ 的大块组成，其中 $B  b  0$ 且 $m \\ge n$。你将执行 $n$ 次分配操作，请求大小为 $\\{ s_i \\}_{i=1}^{n}$，且对所有 $i$ 满足 $0  s_i \\le b$。\n\n令 $C_{\\max}^{\\mathrm{FF}}(t)$ 和 $C_{\\max}^{\\mathrm{WF}}(t)$ 分别表示在首次适应和最差适应策略下，经过 $t$ 次操作后最大连续空闲块的大小。定义 $n$ 次操作后的差值为\n$$\n\\Delta C_{\\max} \\equiv C_{\\max}^{\\mathrm{FF}}(n) - C_{\\max}^{\\mathrm{WF}}(n).\n$$\n你的任务是：\n- 仅使用首次适应和最差适应策略的核心定义以及所述的分配器语义，确定能使 $\\Delta C_{\\max}$ 最大化的请求序列 $\\{s_i \\}$ 的模式。\n- 从第一性原理出发，推导出 $\\Delta C_{\\max}$ 的最大可达值的封闭形式表达式，用 $n$、$b$ 和 $B$ 表示。\n\n请以精确的解析表达式形式提供最终答案。无需四舍五入。",
            "solution": "目标是最大化数量 $\\Delta C_{\\max} = C_{\\max}^{\\mathrm{FF}}(n) - C_{\\max}^{\\mathrm{WF}}(n)$。这要求我们找到一个请求序列 $\\{s_i\\}_{i=1}^n$，该序列能同时使 $C_{\\max}^{\\mathrm{FF}}(n)$ 尽可能大，并使 $C_{\\max}^{\\mathrm{WF}}(n)$ 尽可能小。\n\n**请求序列模式分析**\n\n让我们分析每种分配策略的行为，以确定最优的请求序列。\n\n**最大化 $C_{\\max}^{\\mathrm{FF}}(n)$：**\n初始空闲链表中的最大块大小为 $B$。由于不执行合并操作，因此永远不可能创建比 $B$ 更大的块。因此，$C_{\\max}^{\\mathrm{FF}}(n)$ 的最大可能值为 $B$。为实现这一目标，这 $n$ 次分配的序列必须完全不使用大小为 $B$ 的大块。\n\n首次适应 (FF) 策略按内存地址递增的顺序扫描空闲链表。初始链表由 $m$ 个大小为 $b$ 的块和一个大小为 $B$ 的块组成。对于任何请求 $s_i$ 其中 $0  s_i \\le b$，FF 将扫描最初的 $m$ 个块。由于 $m \\ge n$，小块的数量至少与请求数量一样多。每个请求 $s_i$ 都可以由一个大小为 $b$ 的块来满足。\n\n为保证永远不会触及大小为 $B$ 的大块，我们必须确保 $n$ 个请求中的每一个都由前 $m$ 个块之一来满足。让我们考虑这样一个序列，其中每个请求的大小都是允许的最大值，即对所有 $i \\in \\{1, \\ldots, n\\}$，都有 $s_i = b$。\n- 对于第一个请求 $s_1 = b$，FF 找到第一个大小为 $b$ 的块，该块正好满足请求。此块从空闲链表中移除。\n- 对于第二个请求 $s_2 = b$，FF 找到下一个大小为 $b$ 的块（此时它成为链表中的第一个块）并将其移除。\n- 这个过程持续 $n$ 次请求。由于 $m \\ge n$，对于 $n$ 个请求中的每一个，都有一个新的大小为 $b$ 的块可用。\n- 经过 $n$ 次这样的操作后，前 $n$ 个大小为 $b$ 的块已被消耗。空闲链表现在由 $m-n$ 个大小为 $b$ 的块和那个未被触动的大小为 $B$ 的块组成。\n- 空闲链表中剩余块的大小为 $\\{b, \\ldots, b, B\\}$（$m-n$ 次）。\n- 由于 $B > b$，最大空闲块的大小为 $C_{\\max}^{\\mathrm{FF}}(n) = B$。\n\n这个序列，即对所有 $i$ 都有 $s_i = b$，实现了 $C_{\\max}^{\\mathrm{FF}}(n)$ 的最大可能值。\n\n**最小化 $C_{\\max}^{\\mathrm{WF}}(n)$：**\n最差适应 (WF) 策略总是从可用的最大空闲块中进行分配。为了使最终的最大块大小 $C_{\\max}^{\\mathrm{WF}}(n)$ 尽可能小，我们应该选择请求序列 $\\{s_i\\}$ 以便尽可能多地减小最大块的大小。这可以通过最大化分配的总内存量 $\\sum_{i=1}^n s_i$ 来实现。给定约束 $0  s_i \\le b$，当对所有 $i=1, \\ldots, n$ 都有 $s_i = b$ 时，总和最大。此时总分配大小为 $n b$。\n\n让我们用这个序列（即对 $i=1, \\ldots, n$ 都有 $s_i = b$）来分析 WF 的行为。\n- 初始时，空闲块的大小为 $\\{b, \\ldots, b, B\\}$。由于 $B>b$，最大的块是大小为 $B$ 的那个。\n- 对于每个请求 $s_i=b$，WF 会识别当前空闲链表中的最大块。\n- 只要原始大小为 $B$ 的块的剩余部分大于 $b$，WF 就会选择它进行分配。我们用 $B_k$ 表示经过 $k$ 次分配后这个剩余部分的大小。\n- 第一次请求后，剩余部分大小为 $B_1 = B-b$。第二次后，为 $B_2 = B-2b$，依此类推。只要 $B-(k-1)b > b$，这个过程就会继续。\n- 经过 $n$ 次操作后，总共分配了 $nb$ 的内存。这部分内存被优先从可用的最大块中分割出来。\n\n让我们确定最终状态。出现两种情况：\n\n情况1：$B-nb > b$，等价于 $B > (n+1)b$。\n在这种情况下，在每一步 $k \\in \\{1, \\ldots, n\\}$，大块的剩余部分（大小为 $B-(k-1)b$）都严格大于 $b$。因此，对于所有 $n$ 个请求，WF 都从这个剩余部分进行分配。经过 $n$ 次操作后，空闲链表由 $m$ 个大小为 $b$ 的块和一个大小为 $B-nb$ 的块组成。最大块的大小是 $C_{\\max}^{\\mathrm{WF}}(n) = B-nb$。\n\n情况2：$B-nb \\le b$，等价于 $b  B \\le (n+1)b$。\n在这种情况下，WF 最初会从大小为 $B$ 的块进行分配，直到其剩余部分不再是最大的块。设 $k_0$ 是第一个使得 $B - k_0 b \\le b$ 的整数。对于前 $k_0$ 个大小为 $b$ 的请求，WF 使用大块。经过 $k_0$ 次请求后，空闲链表包含 $m$ 个大小为 $b$ 的块和一个大小为 $B-k_0 b$ 的剩余部分。此时，最大的块大小为 $b$。对于剩下的 $n-k_0$ 个请求，WF 将消耗掉 $n-k_0$ 个原始的大小为 $b$ 的块。\n在所有 $n$ 次请求之后，空闲链表将包含 $m-(n-k_0)$ 个大小为 $b$ 的块和大小为 $B-k_0 b (\\le b)$ 的剩余部分。因此，最大的块的大小将为 $b$。所以，$C_{\\max}^{\\mathrm{WF}}(n) = b$。\n\n我们可以统一这两种情况。对于序列 $s_i=b$，WF 策略下最大块的大小是两个可能的剩余块中较大的一个：原始的小块大小 $b$ 和大块的剩余部分 $B-nb$。\n$$C_{\\max}^{\\mathrm{WF}}(n) = \\max(b, B-nb)$$\n\n对于所有 $i$，$s_i=b$ 的序列成功地最大化了 $C_{\\max}^{\\mathrm{FF}}(n)$ 并最小化了 $C_{\\max}^{\\mathrm{WF}}(n)$，所以它确实是最大化 $\\Delta C_{\\max}$ 的模式。\n\n**最大 $\\Delta C_{\\max}$ 的推导**\n\n现在我们可以使用为最优序列 $s_i=b$ 推导出的结果来计算 $\\Delta C_{\\max}$ 的最大值：\n$$\n\\Delta C_{\\max} = C_{\\max}^{\\mathrm{FF}}(n) - C_{\\max}^{\\mathrm{WF}}(n) = B - \\max(b, B-nb)\n$$\n这个表达式可以通过考虑 $\\max$ 函数的两种情况来简化。\n\n情况 A：$b \\ge B-nb$，等价于 $(n+1)b \\ge B$。\n在这种情况下，$\\max(b, B-nb) = b$。\n差值为 $\\Delta C_{\\max} = B - b$。\n\n情况 B：$b  B-nb$，等价于 $(n+1)b  B$。\n在这种情况下，$\\max(b, B-nb) = B-nb$。\n差值为 $\\Delta C_{\\max} = B - (B-nb) = nb$。\n\n结合这两种情况，我们看到 $\\Delta C_{\\max}$ 的最大值是 $nb$ 和 $B-b$ 这两个值中较小的一个。这可以使用最小值函数紧凑地表示为：\n$$\n\\max(\\Delta C_{\\max}) = \\min(nb, B-b)\n$$\n这个表达式代表了最终答案。导致此结果的模式是对于所有 $n$ 次分配都使用大小为 $s_i=b$ 的请求。",
            "answer": "$$\n\\boxed{\\min(nb, B-b)}\n$$"
        },
        {
            "introduction": "最后，我们通过一个模拟真实世界分配器设计的实践来总结。我们将引入内部碎片（internal fragmentation）和外部碎片（external fragmentation）的概念，以及一种常见的优化技术——拆分阈值 $\\epsilon$。这项练习要求你实现这些分配器，并定量地衡量调整该阈值如何导致一个直接的权衡 ：以增加内部碎片为代价，来减少微小的、难以利用的外部碎片，这是内存管理中的一个核心挑战。",
            "id": "3644173",
            "problem": "本题要求您实现并分析三种选择策略（首次适应、最佳适应和最差适应）下的连续内存分配，并应用一个关于分割的阈值规则。考虑一个固定大小的单块连续内存，以及一系列由唯一进程标识符标识的确定性分配和释放请求。重点是在序列结束时，量化外部碎片和内部碎片，并比较这些指标如何随分割阈值的变化而改变。\n\n使用的基本定义：\n- 连续分配维护一个空闲块列表，并分配在地址空间中连续的整个内存区域。分配基于一个选择足够大小空闲块的策略。\n- 首次适应选择第一个足够大的空闲块。\n- 最佳适应选择不小于请求大小的最小空闲块；使用最低起始地址来打破平局。\n- 最差适应选择最大的空闲块；使用最低起始地址来打破平局。\n- 当为了满足大小为 $r$ 的请求而分割一个大小为 $s$ 的空闲块时，如果余量 $t = s - r$ 满足 $t  \\epsilon$ (严格小于)，分配器不会进行分割。而是将整个大小为 $s$ 的块分配给该请求，并为该分配记录 $s - r$ 字节的内部浪费。如果 $t \\ge \\epsilon$，则进行正常分割，产生一个大小为 $r$ 的已分配块和一个大小为 $t$ 的空闲块。\n- 在释放时，会立即与任何相邻的空闲邻居进行合并，以保持最大限度的空闲连续性。\n- 在整个序列结束时，外部碎片 $E$ 定义为\n$$\nE \\equiv \\begin{cases}\n0,  \\text{若总空闲内存 } F = 0,\\\\\n1 - \\dfrac{L}{F},  \\text{若 } F > 0,\n\\end{cases}\n$$\n其中 $F$ 是所有空闲块大小的总和，$L$ 是最大空闲块的大小。\n- 在整个序列结束时，内部碎片 $I$ 定义为当前所有已分配块的 $\\text{allocated\\_size} - \\text{requested\\_size}$ (以字节为单位) 的总和。每个已分配块在分配时记录其请求大小和分配大小；只有在结束时仍处于分配状态的块才对 $I$ 有贡献。\n\n内存模型和参数：\n- 总内存大小为 $M = 100$ 字节，建模为从 $0$ 到 $M-1$ 的地址；初始状态是一个大小为 $100$ 的单一空闲块。\n- 请求是一个包含 $10$ 个操作的序列，这些操作要么分配要么释放一个由标识符引用的块。分配大小以字节为单位。序列如下：\n  - 分配 id $1$ 大小 $20$。\n  - 分配 id $2$ 大小 $10$。\n  - 分配 id $3$ 大小 $15$。\n  - 释放 id $2$。\n  - 分配 id $4$ 大小 $9$。\n  - 分配 id $5$ 大小 $8$。\n  - 释放 id $3$。\n  - 分配 id $6$ 大小 $12$。\n  - 释放 id $1$。\n  - 分配 id $7$ 大小 $18$。\n- 使用严格的地址顺序来表示空闲列表和已分配块；块选择中的平局通过选择最低起始地址来解决。\n- 假设此序列中的所有分配在上述规则下都能成功。\n\n分割阈值测试套件：\n- 对 $\\epsilon \\in \\{0, 2, 4, 12\\}$ 评估系统，其中 $\\epsilon$ 以字节为单位。\n\n程序要求：\n- 在每种策略下（首次适应 FF、最佳适应 BF、最差适应 WF），为每个 $\\epsilon$ 独立地模拟该序列。分配器完全按照上述定义运行，包括释放时的立即合并和分配时的分割阈值规则。\n- 对于每对 $(\\epsilon, \\text{policy})$，计算最终的外部碎片 $E$（无量纲）和最终的内部碎片 $I$（以字节为单位）。除字节外，不涉及其他物理单位，也不使用角度。\n- 输出格式：您的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表形式的结果。对于按升序排列的每个 $\\epsilon \\in \\{0, 2, 4, 12\\}$，按此顺序附加六个浮点数：$E_{\\mathrm{FF}}$、$I_{\\mathrm{FF}}$、$E_{\\mathrm{BF}}$、$I_{\\mathrm{BF}}$、$E_{\\mathrm{WF}}$、$I_{\\mathrm{WF}}$。将每个数字打印为浮点值，小数点后保留六位数字。因此，最后一行应包含 $4 \\times 6 = 24$ 个浮点数，位于一个方括号列表中，形如 $[\\dots]$。\n\n设计目标与覆盖范围：\n- 测试套件包括作为基线的 $\\epsilon = 0$，一个只影响非常小余量的阈值 $\\epsilon = 2$，一个抑制更多余量的中等阈值 $\\epsilon = 4$，以及一个用于强调权衡的较大阈值 $\\epsilon = 12$。\n- 这覆盖了理想路径场景、阈值规则的类边界情况以及策略差异化，确保结果是可量化的浮点数，并按规定汇总到最终的单行列表中。",
            "solution": "我们从连续内存分配策略和碎片的核心定义开始。分配器维护一个按起始地址排序的内存段列表，每个段由 $(\\text{start}, \\text{size}, \\text{is\\_free})$ 描述，对于已分配的块还记录 $(\\text{id}, \\text{requested\\_size}, \\text{allocated\\_size})$。初始状态是一个大小为 $M = 100$ 字节的单一空闲段。\n\n分配选择由一个搜索空闲列表的策略决定：\n- 首次适应返回第一个大小至少为 $r$ 的空闲段。\n- 最佳适应返回大小至少为 $r$ 的段中大小最小的那个；通过最小起始地址打破平局。\n- 最差适应返回大小至少为 $r$ 的段中大小最大的那个；通过最小起始地址打破平局。\n\n一旦选择了一个大小为 $s$ 的候选空闲块来满足一个 $r$ 字节的请求，我们计算余量 $t = s - r$ 并应用分割阈值规则：\n- 如果 $t  \\epsilon$，则分配会消耗整个大小为 $s$ 的块，该块被分配给请求。为此块记录的内部浪费为 $s - r$。此块不会产生新的空闲段。\n- 如果 $t \\ge \\epsilon$，分配器会将空闲块分割成一个大小为 $r$ 的已分配块和一个在下一地址的大小为 $t$ 的空闲块。此分配的内部浪费为 $0$，因为分配大小等于请求大小。\n\n在对标识符为 $\\text{id}$ 的块执行释放操作时，该段被标记为空闲，并立即与两边相邻的空闲邻居进行合并，将它们融合成一个单一的空闲块。这个不变性确保了在给定的分配决策下，空闲列表保持最大程度的合并状态。\n\n在整个序列结束时，我们计算：\n- 总空闲内存 $F$，即所有空闲段大小的总和。\n- 最大空闲块 $L$，即空闲段中的最大大小；如果没有空闲段，则 $F = 0$。\n- 外部碎片 $E$ 为\n$$\nE = \\begin{cases}\n0,  \\text{若 } F = 0,\\\\\n1 - \\dfrac{L}{F},  \\text{若 } F  0.\n\\end{cases}\n$$\n- 内部碎片 $I$，即当前所有已分配段的 $\\text{allocated\\_size} - \\text{requested\\_size}$ 的总和。请注意，这不是一个随时间累积的指标；它是最终状态下锁定在已分配块中的内部浪费。\n\n模拟器的算法大纲：\n1. 将内存表示为一个按起始地址排序的段动态数组。每个事件都会改变这个数组。\n2. 对于在策略 $P$ 下分配大小为 $r$ 的内存：\n   - 扫描空闲段以根据策略 $P$ 选择索引。\n   - 如果不存在大小至少为 $r$ 的段，序列将失败；但是，所提供的序列是一致的，因此在给定约束下所有分配都会成功。\n   - 设所选段的大小为 $s$，起始地址为 $a$。计算 $t = s - r$。如果 $t  \\epsilon$，则分配整个段：将其标记为已分配，并设置 $\\text{requested\\_size} = r$ 和 $\\text{allocated\\_size} = s$。如果 $t \\ge \\epsilon$，则进行分割：将被选段更改为大小为 $r$ 的已分配段，并在其后紧接着插入一个大小为 $t$、起始地址为 $a + r$ 的新空闲段。\n3. 对于释放标识符为 $\\text{id}$ 的块：\n   - 找到具有该 $\\text{id}$ 的已分配段并将其标记为空闲。\n   - 如果前一个邻居是空闲的，则通过合并大小和调整起始地址与其合并。然后，如果后一个邻居是空闲的，则与其合并。由于列表保持排序，每次与邻居的合并操作耗时为常数时间。\n4. 处理完所有操作后，按规定计算 $F$、$L$、$E$ 和 $I$。\n\n一个用于演示原理的示例推导：\n考虑在首次适应策略下 $\\epsilon = 4$ 的情况。在 $M=100$ 的内存上，确定性序列如下：\n- 分配 id $1$ 大小 $20$：由于 $80 \\ge 4$，将 $100$ 分割为 $20 + 80$。\n- 分配 id $2$ 大小 $10$：由于 $70 \\ge 4$，将 $80$ 分割为 $10 + 70$。\n- 分配 id $3$ 大小 $15$：由于 $55 \\ge 4$，将 $70$ 分割为 $15 + 55$。\n- 释放 id $2$：大小为 $10$ 字节的块变为空闲。\n- 分配 id $4$ 大小 $9$：选择第一个大小为 $10$ 的空闲块。余量为 $t = 1$，由于 $1  4$，消耗整个 $10$ 字节的块。为 id $4$ 记录内部浪费 $10 - 9 = 1$。\n- 分配 id $5$ 大小 $8$：选择下一个大小为 $55$ 的空闲块；由于 $47 \\ge 4$，将其分割为 $8 + 47$。\n- 释放 id $3$：大小为 $15$ 字节的块变为空闲；其邻居都已分配，因此除自身外不发生合并。\n- 分配 id $6$ 大小 $12$：选择第一个大小为 $15$ 的空闲块。余量为 $t = 3$，由于 $3  4$，消耗整个 $15$ 字节的块。为 id $6$ 记录内部浪费 $15 - 12 = 3$。\n- 释放 id $1$：大小为 $20$ 字节的块变为空闲。\n- 分配 id $7$ 大小 $18$：选择第一个大小为 $20$ 的空闲块。余量为 $t = 2$，由于 $2  4$，消耗整个 $20$ 字节的块。为 id $7$ 记录内部浪费 $20 - 18 = 2$。\n\n结束时，唯一的空闲内存是大小为 $47$ 字节的块；因此 $F = 47$, $L = 47$，所以 $E = 1 - 47/47 = 0$。内部碎片为 $I = 1 + 3 + 2 = 6$ 字节。这演示了增加 $\\epsilon$ 如何以增加内部浪费为代价来抑制小的外部碎片。\n\n作为对比，在最差适应策略下，使用相同的 $\\epsilon = 4$，选择过程会反复挑选最大的块，产生总是至少为 $\\epsilon$ 的大余量；因此 $I = 0$，最终的空闲集合是三个块，其大小总和为 $F = 65$，最大块大小 $L = 27$，得出 $E = 1 - 27/65 \\approx 0.584615$。\n\n通过对每个 $\\epsilon \\in \\{0, 2, 4, 12\\}$ 和每种策略执行定义的序列，模拟器计算出最终的 $E$ 和 $I$ 值。程序必须输出一个包含 24 个浮点数的方括号列表，按每个 $\\epsilon$ 的 $E_{\\mathrm{FF}}, I_{\\mathrm{FF}}, E_{\\mathrm{BF}}, I_{\\mathrm{BF}}, E_{\\mathrm{WF}}, I_{\\mathrm{WF}}$ 顺序排列，每个数字小数点后精确到六位，用逗号分隔，无附加文本。",
            "answer": "[0.113208,0.000000,0.113208,0.000000,0.584615,0.000000,0.113208,1.000000,0.000000,2.000000,0.584615,0.000000,0.000000,6.000000,0.000000,6.000000,0.584615,0.000000,0.000000,19.000000,0.000000,19.000000,0.444444,7.000000]"
        }
    ]
}