{
    "hands_on_practices": [
        {
            "introduction": "我们的第一个练习将通过一个具体的计算来深入探讨内部碎片。我们将研究伙伴系统（buddy system）分配器，这是一种常见的内存管理策略，它会将内存请求的大小向上取整到最接近的 $2$ 的幂，从而产生浪费。通过为一个特定的内存请求序列量化这种浪费，本练习将帮助你巩固对内部碎片核心概念的理解 。",
            "id": "3628282",
            "problem": "一个计算机系统在随机存取存储器 (RAM) 的一个单一区域内使用连续内存分配。该分配器是一个伙伴系统，它强制使用2的幂次大小的块，并将一个较大的连续区域分割成较小的2的幂次大小的块。最小可分配块的大小为一千位二进制字节 (KiB)。在伙伴系统下，对于一个大小为 $s$ 的块请求，系统会通过将 $s$ 向上取整到大于或等于 $s$ 的最小2的幂次来满足，然后连续地分配一个这样大小的块。\n\n考虑一个初始大小为 $512$ 千位二进制字节 (KiB) 的空闲连续区域。一个进程按顺序发出四个分配请求，每个请求都需要一个连续的块，大小分别为：$62$ KiB、$90$ KiB、$35$ KiB 和 $10$ KiB。在具有理想可变大小分割的连续内存分配下，每个请求都将通过划分出与请求大小完全相同的空间来满足，从而产生零内部碎片。在伙伴系统下，每个请求的大小在分配前都会被向上取整到最小的2的幂次块大小。\n\n仅使用连续内存分配、内部碎片和伙伴系统的2的幂次向上取整规则的核心定义，确定由伙伴分配器相对于理想连续分割基线所引起的内部碎片浪费。将浪费分数定义为超额分配的字节数除以请求的字节数，并计算此分配模式下的精确值。将最终答案表示为一个不带单位的分数。",
            "solution": "该问题要求计算在伙伴系统下，一系列内存分配请求相对于理想分配方案所产生的内部碎片浪费分数。解决方案需要逐步分析伙伴系统如何处理每个请求，并计算由此产生的碎片。\n\n首先，让我们将给定的信息和定义形式化。\n内存请求序列的大小分别为 $s_1 = 62$ KiB, $s_2 = 90$ KiB, $s_3 = 35$ KiB, 和 $s_4 = 10$ KiB。\n总请求大小，记为 $S_{req}$，是各个请求大小的总和：\n$$S_{req} = s_1 + s_2 + s_3 + s_4$$\n\n在伙伴系统下，一个大小为 $s$ 的请求通过分配一个大小为 $a$ 的块来满足，其中 $a$ 是满足 $a \\ge s$ 的最小的2的幂。在数学上，这可以表示为 $a = 2^{\\lceil \\log_2(s) \\rceil}$。最小可分配块大小为 $1$ KiB，即 $2^0$ KiB，这与2的幂次规则一致。\n\n问题定义了“理想可变大小分割”基线，其中分配的大小恰好等于请求的大小。对于此基线，总分配内存将等于 $S_{req}$，因此内部碎片为零。\n\n单次分配的内部碎片是分配大小与请求大小之差，即 $a - s$。总内部碎片，或总“超额分配字节数”($I$)，是每个请求的碎片之和。\n$$I = \\sum_{i=1}^{4} (a_i - s_i) = \\left(\\sum_{i=1}^{4} a_i\\right) - \\left(\\sum_{i=1}^{4} s_i\\right) = S_{alloc} - S_{req}$$\n其中 $S_{alloc}$ 是伙伴系统分配的总大小。\n\n“浪费分数” $F_w$ 定义为超额分配的字节数除以请求的字节数：\n$$F_w = \\frac{I}{S_{req}} = \\frac{S_{alloc} - S_{req}}{S_{req}}$$\n\n现在，我们进行计算。\n\n步骤1：计算总请求内存大小 $S_{req}$。\n$$S_{req} = 62 + 90 + 35 + 10 = 197 \\text{ KiB}$$\n\n步骤2：根据伙伴系统的2的幂次向上取整规则，计算每个请求 $s_i$ 的分配大小 $a_i$。\n- 对于第一个请求 $s_1 = 62$ KiB：\n2的幂次有 $..., 32, 64, 128, ...$。大于或等于 $62$ 的最小的2的幂是 $64$。因此，$a_1 = 64$ KiB。这对应于 $2^6$。\n\n- 对于第二个请求 $s_2 = 90$ KiB：\n大于或等于 $90$ 的最小的2的幂是 $128$。因此，$a_2 = 128$ KiB。这对应于 $2^7$。\n\n- 对于第三个请求 $s_3 = 35$ KiB：\n大于或等于 $35$ 的最小的2的幂是 $64$。因此，$a_3 = 64$ KiB。这对应于 $2^6$。\n\n- 对于第四个请求 $s_4 = 10$ KiB：\n大于或等于 $10$ 的最小的2的幂是 $16$。因此，$a_4 = 16$ KiB。这对应于 $2^4$。\n\n步骤3：计算总分配内存大小 $S_{alloc}$。\n$$S_{alloc} = a_1 + a_2 + a_3 + a_4 = 64 + 128 + 64 + 16 = 272 \\text{ KiB}$$\n注意，总分配大小 ($272$ KiB) 小于初始空闲区域大小 ($512$ KiB)，因此所有分配都成功。\n\n步骤4：计算总超额分配字节数（内部碎片）$I$。\n$$I = S_{alloc} - S_{req} = 272 - 197 = 75 \\text{ KiB}$$\n\n步骤5：计算浪费分数 $F_w$。\n$$F_w = \\frac{I}{S_{req}} = \\frac{75}{197}$$\n\n为确保分数为最简形式，我们找出分子和分母的质因数。\n分子是 $75 = 3 \\times 25 = 3 \\times 5^2$。\n对于分母 $197$，我们检查它是否能被小的质数整除。\n- $197$ 不能被 $2$ 整除（它是奇数）。\n- 数字之和为 $1+9+7 = 17$，不能被 $3$ 整除。\n- 它不以 $0$ 或 $5$ 结尾，因此不能被 $5$ 整除。\n- 我们继续检查直到 $\\sqrt{197} \\approx 14$ 的质数：$7, 11, 13$。\n  - $197 \\div 7 = 28$ 余 $1$。\n  - $197 \\div 11 = 17$ 余 $10$。\n  - $197 \\div 13 = 15$ 余 $2$。\n由于 $197$ 不能被任何小于或等于其平方根的质数整除，所以 $197$ 是一个质数。\n因此，分数 $\\frac{75}{197}$ 是不可约分的。",
            "answer": "$$\\boxed{\\frac{75}{197}}$$"
        },
        {
            "introduction": "在现实世界中，内存分配器的性能取决于其在各种请求下的平均表现，而不仅仅是某个特定序列。本练习将我们从单个实例的分析提升到概率分析的层面，要求你计算一种更先进的分配器——分离式空闲列表（Segregated Free Lists），在一种更真实的请求大小模型下的*预期*内部碎片率。这个练习展示了一种评估分配器效率的强大分析技术 。",
            "id": "3657360",
            "problem": "一个操作系统内存分配器使用分离空闲链表（SFL），其中空闲块被组织到大小为2的幂的“桶”中。具体来说，可用的块大小为 $2^{0}, 2^{1}, 2^{2}, \\dots, 2^{m}$ 字节，其中 $m$ 是一个固定的正整数。对于一个大小为 $s$ 字节的请求（$1 \\leq s \\leq 2^{m}$），分配器会选择满足 $b(s) \\geq s$ 的最小块大小 $b(s)$。假设每个块的元数据和对齐开销都可以忽略不计。\n\n从“内部碎片率是分配给一个请求的块中未被使用的部分所占的比例”这一核心定义出发，将内部碎片率表示为 $s$ 和 $b(s)$ 的函数，然后在以下工作负载模型下计算其期望值：请求大小在 $[1, 2^{m}]$ 上连续分布，其概率密度函数为\n$$\nf(s) = \\frac{1}{s \\, m \\, \\ln 2} \\quad \\text{for } 1 \\leq s \\leq 2^{m},\n$$\n这是在 $[1, 2^{m}]$ 上归一化的对数均匀分布。\n\n推导期望内部碎片率，将其表示为包含自然对数的单一闭式解析表达式。将最终答案表示为精确表达式，不要进行四舍五入。",
            "solution": "第一步是表达内部碎片率。内部碎片是已分配块中未使用的空间。对于大小为 $s$ 的内存请求，分配的块大小为 $b(s)$。因此，未使用的空间量为 $b(s) - s$。问题将内部碎片率定义为已分配块中未使用部分所占的比例。我们将此比率记为 $I(s)$。\n\n$$\nI(s) = \\frac{\\text{未使用空间}}{\\text{已分配块大小}} = \\frac{b(s) - s}{b(s)} = 1 - \\frac{s}{b(s)}\n$$\n\n接下来，我们必须确定函数 $b(s)$。内存分配器使用的块大小是2的幂：$2^0, 2^1, \\dots, 2^m$。对于大小为 $s$ 的请求，分配器会选择满足 $b(s) \\geq s$ 的最小块大小 $b(s)$。这个策略意味着，如果请求大小 $s$ 落在区间 $(2^{k-1}, 2^k]$ 内，分配的块大小将是 $b(s) = 2^k$。这对 $k = 1, 2, \\dots, m$ 都成立。对于 $s=1=2^0$ 的特殊情况，分配的块是 $b(1)=2^0=1$。\n\n问题要求计算内部碎片率的期望值 $E[I(s)]$，其中请求大小 $s$ 是一个具有给定概率密度函数（PDF）$f(s)$ 的随机变量。期望值由以下积分定义：\n$$\nE[I(s)] = \\int_{1}^{2^m} I(s) f(s) \\, ds\n$$\n代入 $I(s)$ 和 $f(s)$ 的表达式：\n$$\nE[I(s)] = \\int_{1}^{2^m} \\left(1 - \\frac{s}{b(s)}\\right) \\frac{1}{s \\, m \\, \\ln 2} \\, ds\n$$\n我们可以重写被积函数：\n$$\nE[I(s)] = \\frac{1}{m \\ln 2} \\int_{1}^{2^m} \\left(\\frac{1}{s} - \\frac{1}{b(s)}\\right) \\, ds\n$$\n由于 $b(s)$ 是一个阶跃函数，在 $(2^{k-1}, 2^k]$ 形式的区间上是常数，我们必须相应地划分积分域 $[1, 2^m]$。该域可以写成区间 $\\{1\\} \\cup \\bigcup_{k=1}^{m} (2^{k-1}, 2^k]$ 的并集。由于单点 $s=1$ 对积分的贡献为零，我们可以将积分表示为在这些区间上的求和：\n$$\nE[I(s)] = \\frac{1}{m \\ln 2} \\sum_{k=1}^{m} \\int_{2^{k-1}}^{2^k} \\left(\\frac{1}{s} - \\frac{1}{b(s)}\\right) \\, ds\n$$\n在每个积分区间 $(2^{k-1}, 2^k]$ 内，分配的块大小是恒定的：$b(s) = 2^k$。\n$$\nE[I(s)] = \\frac{1}{m \\ln 2} \\sum_{k=1}^{m} \\int_{2^{k-1}}^{2^k} \\left(\\frac{1}{s} - \\frac{1}{2^k}\\right) \\, ds\n$$\n让我们计算和式中单项的积分，该项对应于一个特定的整数 $k$（$1 \\le k \\le m$）：\n$$\nJ_k = \\int_{2^{k-1}}^{2^k} \\left(\\frac{1}{s} - \\frac{1}{2^k}\\right) \\, ds\n$$\n该积分计算如下：\n$$\nJ_k = \\left[ \\ln(s) - \\frac{s}{2^k} \\right]_{s=2^{k-1}}^{s=2^k}\n$$\n在上限 $s=2^k$ 处求值：\n$$\n\\ln(2^k) - \\frac{2^k}{2^k} = k \\ln 2 - 1\n$$\n在下限 $s=2^{k-1}$ 处求值：\n$$\n\\ln(2^{k-1}) - \\frac{2^{k-1}}{2^k} = (k-1) \\ln 2 - \\frac{1}{2}\n$$\n从上限的求值结果中减去下限的求值结果：\n$$\nJ_k = (k \\ln 2 - 1) - \\left((k-1) \\ln 2 - \\frac{1}{2}\\right) = k \\ln 2 - 1 - (k-1) \\ln 2 + \\frac{1}{2}\n$$\n$$\nJ_k = (k - (k-1))\\ln 2 - 1 + \\frac{1}{2} = \\ln 2 - \\frac{1}{2}\n$$\n值得注意的是，积分 $J_k$ 的值是一个常数，与 $k$ 无关。\n\n现在我们可以将这个结果代回到期望值的表达式中：\n$$\nE[I(s)] = \\frac{1}{m \\ln 2} \\sum_{k=1}^{m} J_k = \\frac{1}{m \\ln 2} \\sum_{k=1}^{m} \\left(\\ln 2 - \\frac{1}{2}\\right)\n$$\n该和式包含 $m$ 个相同的项：\n$$\n\\sum_{k=1}^{m} \\left(\\ln 2 - \\frac{1}{2}\\right) = m \\left(\\ln 2 - \\frac{1}{2}\\right)\n$$\n最后，我们得到期望内部碎片率：\n$$\nE[I(s)] = \\frac{1}{m \\ln 2} \\left[ m \\left(\\ln 2 - \\frac{1}{2}\\right) \\right] = \\frac{\\ln 2 - \\frac{1}{2}}{\\ln 2}\n$$\n该表达式可以简化为：\n$$\nE[I(s)] = 1 - \\frac{1/2}{\\ln 2} = 1 - \\frac{1}{2 \\ln 2}\n$$\n这就是期望内部碎片率的最终闭式表达式，它与参数 $m$ 无关。",
            "answer": "$$\n\\boxed{1 - \\frac{1}{2 \\ln(2)}}\n$$"
        },
        {
            "introduction": "内存浪费并不仅仅发生在已分配的区块*内部*。本练习将我们的注意力转移到外部碎片上，即空闲内存被分割成许多小的、不连续的“孔洞”，这些孔洞因太小而无法满足新的、较大的内存请求。通过模拟一个特定的分配和释放序列，本练习将清晰地展示外部碎片是如何产生的，以及如何对其进行量化 。",
            "id": "3657357",
            "problem": "一个系统对大小为 $M$ 的堆使用连续区域内存分配，模型假设没有每块开销和对齐约束，因此大小为 $x$ 的分配恰好占用 $x$ 个连续字节。使用兆字节 (MiB) 作为内存大小的单位。外部碎片定义为在给定时间，总空闲内存中不包含在单个最大连续空闲块中的部分所占的比例 $f$。\n\n考虑在一个大小为 $M = 1024 \\, \\text{MiB}$ 的堆上执行以下操作序列：\n- 步骤 $1$：在最低可用地址处分配一个大小为 $H = 512 \\, \\text{MiB}$ 的大块。\n- 步骤 $2$：在大块上方的剩余空闲区域中，使用首次适应策略分配 $n = 192$ 个小块，每个小块的大小为 $s = 2 \\, \\text{MiB}$。该策略精确分割空闲区域，并在空间允许的情况下将这些小块一个接一个地连续放置。\n- 步骤 $3$：释放每个偶数索引的小块（即，按分配顺序编号为 $2, 4, 6, \\dots$ 的块），保留奇数索引的小块仍处于分配状态。这将在大块上方的区域产生交错的空闲和已分配的小块区域，并使第一个小块（与大块相邻）保持分配状态。\n- 步骤 $4$：释放大小为 $H$ 的大块。\n\n假设分配器不合并非相邻的空闲区域，并且由于这些特定的释放操作，步骤 $3$ 和 $4$ 中产生的任何空闲区域都不会变得相邻；特别地，因为在步骤 $3$ 中第一个小块仍保持分配状态，所以在步骤 $4$ 中通过释放 $H$ 创建的空闲区域不会与任何其他空闲区域相邻。在这些假设下，计算步骤 $4$ 之后立即产生的外部碎片比例 $f$（根据上述定义）。将你的最终答案表示为一个最简分数（无单位）。不要使用百分号。",
            "solution": "我们将追踪总大小为 $M = 1024 \\, \\text{MiB}$ 的堆在指定操作序列中的状态。\n\n最初，整个堆是一个大小为 $1024 \\, \\text{MiB}$ 的单个空闲块。\n\n**步骤 1：** 在最低地址处分配一个大小为 $H = 512 \\, \\text{MiB}$ 的块。\n- 已分配内存：$[0, 512)$。此块大小为 $512 \\, \\text{MiB}$。\n- 空闲内存：一个位于 $[512, 1024)$ 的单个块。此空闲块的大小为 $1024 - 512 = 512 \\, \\text{MiB}$。\n\n**步骤 2：**\n在大小为 $512 \\, \\text{MiB}$ 的剩余空闲区域中，连续分配了 $n = 192$ 个小块，每个小块的大小为 $s = 2 \\, \\text{MiB}$。\n- 分配的小块总大小：$S_{alloc} = n \\times s = 192 \\times 2 = 384 \\, \\text{MiB}$。\n- 这些块从地址 $512$ 开始放置。它们占据区域 $[512, 512 + 384) = [512, 896)$。\n- 此步骤后，内存布局为：\n    - 已分配的块 $H$：$[0, 512)$，大小 $512 \\, \\text{MiB}$。\n    - $192$ 个已分配的小块：$[512, 896)$，总大小 $384 \\, \\text{MiB}$。\n    - 一个剩余的单个空闲块：$[896, 1024)$，大小 $1024 - 896 = 128 \\, \\text{MiB}$。\n\n**步骤 3：**\n每个偶数索引的小块被释放。小块的索引为 $1, 2, 3, \\dots, 192$。我们释放块 $2, 4, \\dots, 192$。\n- 释放的块数为 $\\frac{192}{2} = 96$。\n- 仍处于分配状态的块数也是 $\\frac{192}{2} = 96$。这些是奇数索引的块 $1, 3, \\dots, 191$。\n- 这创建了 $96$ 个新的空闲块，每个大小为 $s = 2 \\, \\text{MiB}$。\n- 已分配的奇数索引块和新释放的偶数索引块在区域 $[512, 896)$ 中交错排列。例如，块 $1$（已分配）位于 $[512, 514)$，块 $2$ 被释放，在 $[514, 516)$ 处创建一个空闲区域，块 $3$（已分配）位于 $[516, 518)$，依此类推。\n- 分配器不合并非相邻空闲区域的假设在这里至关重要。这 $96$ 个大小为 $2 \\, \\text{MiB}$ 的空闲块彼此之间以及与大小为 $128 \\, \\text{MiB}$ 的最终空闲块保持独立。\n\n**步骤 4：**\n堆起始处大小为 $H = 512 \\, \\text{MiB}$ 的大块被释放。\n- 这在 $[0, 512)$ 处创建了一个大小为 $512 \\, \\text{MiB}$ 的新空闲块。\n- 问题明确指出，这个新的空闲区域不会与任何其他空闲区域相邻，因为第一个小块（块 $1$，位于 $[512, 514)$）仍处于分配状态。\n\n现在，我们根据最终的内存状态计算外部碎片比例 $f$。\n首先，我们确定所有空闲块及其大小：\n1.  一个来自释放 $H$ 的空闲块：大小 $512 \\, \\text{MiB}$。\n2.  $96$ 个来自释放偶数索引小块的空闲块：每个大小为 $2 \\, \\text{MiB}$。\n3.  一个小块分配后的剩余空闲块：大小 $128 \\, \\text{MiB}$。\n\n空闲内存总量 $F_{total}$ 是所有空闲块大小的总和：\n$$F_{total} = 512 + (96 \\times 2) + 128$$\n$$F_{total} = 512 + 192 + 128 = 832 \\, \\text{MiB}$$\n\n另外，已分配内存总量由 $96$ 个奇数索引的小块组成：\n$A_{total} = 96 \\times 2 = 192 \\, \\text{MiB}$。\n总空闲内存必须是 $M - A_{total} = 1024 - 192 = 832 \\, \\text{MiB}$。计算结果一致。\n\n接下来，我们确定单个最大连续空闲块的大小 $L$。通过比较空闲块的大小（$512$、$128$ 和 $2$），我们发现：\n$$L = 512 \\, \\text{MiB}$$\n\n外部碎片比例 $f$ 定义为总空闲内存中不在最大空闲块中的部分所占的比例。\n$$f = \\frac{F_{total} - L}{F_{total}}$$\n代入计算出的值：\n$$f = \\frac{832 - 512}{832} = \\frac{320}{832}$$\n\n为了简化这个分数，我们找到分子和分母的最大公约数。\n$320 = 32 \\times 10 = (2^5) \\times (2 \\times 5) = 2^6 \\times 5 = 64 \\times 5$。\n$832 = 13 \\times 64$。\n因此：\n$$f = \\frac{64 \\times 5}{64 \\times 13} = \\frac{5}{13}$$\n外部碎片比例为 $\\frac{5}{13}$。",
            "answer": "$$\\boxed{\\frac{5}{13}}$$"
        }
    ]
}