{
    "hands_on_practices": [
        {
            "introduction": "A primary challenge in contiguous memory allocation is fragmentation, which leads to wasted memory. This exercise provides a practical scenario to help you distinguish between internal fragmentation (space wasted inside allocated blocks) and external fragmentation (space wasted between allocated blocks). By simulating a specific workload, you will quantify both types of waste and see firsthand how an allocator's policies, such as rounding up for memory alignment, can significantly influence efficiency .",
            "id": "3628308",
            "problem": "Consider a uniprogrammed system that uses a contiguous memory allocator over a single region of size $M$ bytes. The allocator enforces an alignment constraint of $a$ bytes and rounds each request up to the least multiple of $a$ that is greater than or equal to the requested size. The allocator uses a first-fit policy, splits free blocks on allocation, and coalesces only adjacent free blocks on deallocation. Assume all bookkeeping metadata overhead is negligible.\n\nStarting from an initially empty memory region of size $M = 4096$ bytes with base address $0$, the following workload is executed:\n- Perform $n = 45$ allocation requests, each for $s = 33$ bytes.\n- Then deallocate exactly one of the allocated blocks that is not at either end of the allocated sequence (specifically, free the $23$rd allocation).\n\nDefine internal fragmentation as the sum, over all currently allocated blocks, of the difference between the allocator’s rounded-up size and the requested size. Define external fragmentation at the end of the workload as the total free memory minus the size of the largest single free block.\n\nLet $\\rho$ be the fraction of total fragmentation attributable to internal fragmentation at the end of the workload, that is, $\\rho$ equals internal fragmentation divided by the sum of internal and external fragmentation.\n\nUsing only fundamental definitions and the specified allocator behavior, compute $\\rho$ for $a = 64$, $M = 4096$, $n = 45$, and $s = 33$. Provide your final answer as an exact simplified rational number with no units.",
            "solution": "The problem statement is validated as being self-contained, consistent, and scientifically grounded in the principles of operating systems memory management. All parameters, definitions, and allocator behaviors are specified unambiguously, allowing for a deterministic and unique solution.\n\nThe problem can be solved by simulating the memory allocation and deallocation process, calculating the resulting internal and external fragmentation, and then computing their ratio.\n\nFirst, we determine the actual size of each allocated block. The request size is $s = 33$ bytes, and the alignment requirement is $a = 64$ bytes. The allocator rounds each request up to the least multiple of $a$ that is greater than or equal to the requested size. Let this allocated size be $S_{alloc}$.\n$$S_{alloc} = \\left\\lceil \\frac{s}{a} \\right\\rceil \\times a = \\left\\lceil \\frac{33}{64} \\right\\rceil \\times 64 = 1 \\times 64 = 64 \\text{ bytes}$$\nThus, every allocation will reserve a block of $64$ bytes.\n\nThe system starts with an empty memory region of size $M = 4096$ bytes, which is a single free block from address $0$ to $4095$.\nThe workload consists of $n = 45$ allocation requests. Since the allocator uses a first-fit policy and the memory is initially a single contiguous free block, the $45$ allocations will be placed one after another starting from address $0$.\nThe total memory occupied by these $45$ blocks is:\n$$n \\times S_{alloc} = 45 \\times 64 = 2880 \\text{ bytes}$$\nAfter this allocation phase, the memory map consists of:\n1.  An allocated region of $2880$ bytes, from address $0$ to $2879$.\n2.  A single remaining free block of size $M - 2880 = 4096 - 2880 = 1216$ bytes, from address $2880$ to $4095$.\n\nNext, the $23$-rd allocated block is deallocated. The $k$-th allocated block occupies the memory address range $[(k-1)S_{alloc}, k \\cdot S_{alloc} - 1]$. For the $23$-rd block ($k=23$):\n-   Start address: $(23-1) \\times 64 = 22 \\times 64 = 1408$.\n-   End address: $23 \\times 64 - 1 = 1472 - 1 = 1471$.\nThe allocator's policy is to coalesce only with adjacent free blocks upon deallocation. The block immediately preceding the freed block (the $22$-nd block) is still allocated. The block immediately succeeding it (the $24$-th block) is also still allocated. Therefore, no coalescing can occur. This deallocation creates a new, isolated free block of size $64$ bytes at address $1408$.\n\nThe final state of the memory is as follows:\n-   Allocated blocks $1$ through $22$: Occupying addresses $0$ to $1407$. Total count: $22$.\n-   A free block of size $64$ bytes: Occupying addresses $1408$ to $1471$.\n-   Allocated blocks $24$ through $45$: Occupying addresses $1472$ to $2879$. Total count: $45 - 24 + 1 = 22$.\n-   A free block of size $1216$ bytes: Occupying addresses $2880$ to $4095$.\n\nThe total number of currently allocated blocks is $45 - 1 = 44$.\n\nNow, we calculate the internal and external fragmentation based on this final memory state.\n\nInternal fragmentation ($I$) is the sum of wasted space within all allocated blocks. For each of the $44$ allocated blocks, the requested size was $s=33$ bytes, but the allocated size was $S_{alloc}=64$ bytes.\n$$I = (\\text{Number of allocated blocks}) \\times (S_{alloc} - s)$$\n$$I = 44 \\times (64 - 33) = 44 \\times 31 = 1364 \\text{ bytes}$$\n\nExternal fragmentation ($E$) is defined as the total free memory minus the size of the largest single free block.\n-   The sizes of the free blocks are $64$ bytes and $1216$ bytes.\n-   Total free memory, $F_{total} = 64 + 1216 = 1280$ bytes.\n-   The size of the largest single free block is $F_{max} = \\max(64, 1216) = 1216$ bytes.\n$$E = F_{total} - F_{max} = 1280 - 1216 = 64 \\text{ bytes}$$\n\nFinally, we compute the ratio $\\rho$, which is the fraction of total fragmentation attributable to internal fragmentation.\n$$\\rho = \\frac{I}{I + E}$$\n$$\\rho = \\frac{1364}{1364 + 64} = \\frac{1364}{1428}$$\nTo simplify this fraction, we can divide the numerator and denominator by their greatest common divisor. Both are divisible by $4$.\n$$\\rho = \\frac{1364 \\div 4}{1428 \\div 4} = \\frac{341}{357}$$\nWe check for further common factors by prime factorization:\n-   Numerator: $341 = 11 \\times 31$.\n-   Denominator: $357 = 3 \\times 119 = 3 \\times 7 \\times 17$.\nThere are no common prime factors, so the fraction is in its simplest form.",
            "answer": "$$\\boxed{\\frac{341}{357}}$$"
        },
        {
            "introduction": "Operating systems employ various strategies to manage memory and mitigate fragmentation. The buddy system is a classic algorithm that simplifies allocation and deallocation by restricting block sizes to powers of two. This practice problem lets you explore the direct consequences of this design choice, calculating the internal fragmentation that arises from rounding up memory requests to the nearest power of two, and measuring it as a \"waste fraction\" .",
            "id": "3628282",
            "problem": "A computer system uses contiguous memory allocation within a single region of Random Access Memory (RAM). The allocator is a buddy system that enforces power-of-two block sizes and splits a larger contiguous region into smaller power-of-two blocks. The smallest allocable block is one kibibyte (KiB). Under the buddy system, a request for a block of size $s$ is satisfied by rounding $s$ up to the smallest power of two that is greater than or equal to $s$, then allocating one such block contiguously.\n\nConsider an initially free contiguous region of size $512$ kibibytes (KiB). A process issues a sequence of four allocation requests in order, each requiring a contiguous block: $62$ KiB, $90$ KiB, $35$ KiB, and $10$ KiB. Under contiguous memory allocation with ideal variable-size splitting, each request would be satisfied by carving out exactly the requested size, incurring zero internal fragmentation. Under the buddy system, each request is rounded up to the smallest power-of-two block size before allocation.\n\nUsing only the core definitions of contiguous memory allocation, internal fragmentation, and the buddy system’s power-of-two rounding rule, determine the internal fragmentation waste induced by the buddy allocator relative to the ideal contiguous splitting baseline. Define the waste fraction as the excess allocated bytes divided by the requested bytes, and compute its exact value for this allocation pattern. Express your final answer as a fraction without units.",
            "solution": "The problem asks for the internal fragmentation waste fraction for a sequence of memory allocation requests under a buddy system, relative to an ideal allocation scheme. The solution requires a step-by-step analysis of how the buddy system services each request and a calculation of the resulting fragmentation.\n\nFirst, let us formalize the given information and definitions.\nThe sequence of memory requests has sizes $s_1 = 62$ KiB, $s_2 = 90$ KiB, $s_3 = 35$ KiB, and $s_4 = 10$ KiB.\nThe total requested size, denoted as $S_{req}$, is the sum of the individual request sizes:\n$$S_{req} = s_1 + s_2 + s_3 + s_4$$\n\nUnder the buddy system, a request of size $s$ is satisfied by allocating a block of size $a$, where $a$ is the smallest power of two such that $a \\ge s$. Mathematically, this can be expressed as $a = 2^{\\lceil \\log_2(s) \\rceil}$. The smallest allocable block size is $1$ KiB, which is $2^0$ KiB, consistent with the power-of-two rule.\n\nThe problem defines the \"ideal variable-size splitting\" baseline, where the allocated size is exactly the requested size. For this baseline, the total allocated memory would be equal to $S_{req}$, and thus the internal fragmentation would be zero.\n\nInternal fragmentation for a single allocation is the difference between the allocated size and the requested size, i.e., $a - s$. The total internal fragmentation, or the total \"excess allocated bytes\" ($I$), is the sum of the fragmentation for each request.\n$$I = \\sum_{i=1}^{4} (a_i - s_i) = \\left(\\sum_{i=1}^{4} a_i\\right) - \\left(\\sum_{i=1}^{4} s_i\\right) = S_{alloc} - S_{req}$$\nwhere $S_{alloc}$ is the total size allocated by the buddy system.\n\nThe \"waste fraction\", $F_w$, is defined as the excess allocated bytes divided by the requested bytes:\n$$F_w = \\frac{I}{S_{req}} = \\frac{S_{alloc} - S_{req}}{S_{req}}$$\n\nNow, we proceed with the calculation.\n\nStep 1: Calculate the total requested memory size, $S_{req}$.\n$$S_{req} = 62 + 90 + 35 + 10 = 197 \\text{ KiB}$$\n\nStep 2: Calculate the allocated size, $a_i$, for each request $s_i$ under the buddy system's power-of-two rounding rule.\n- For the first request, $s_1 = 62$ KiB:\nThe powers of two are $..., 32, 64, 128, ...$. The smallest power of two greater than or equal to $62$ is $64$. So, $a_1 = 64$ KiB. This corresponds to $2^6$.\n\n- For the second request, $s_2 = 90$ KiB:\nThe smallest power of two greater than or equal to $90$ is $128$. So, $a_2 = 128$ KiB. This corresponds to $2^7$.\n\n- For the third request, $s_3 = 35$ KiB:\nThe smallest power of two greater than or equal to $35$ is $64$. So, $a_3 = 64$ KiB. This corresponds to $2^6$.\n\n- For the fourth request, $s_4 = 10$ KiB:\nThe smallest power of two greater than or equal to $10$ is $16$. So, $a_4 = 16$ KiB. This corresponds to $2^4$.\n\nStep 3: Calculate the total allocated memory size, $S_{alloc}$.\n$$S_{alloc} = a_1 + a_2 + a_3 + a_4 = 64 + 128 + 64 + 16 = 272 \\text{ KiB}$$\nNote that the total allocated size ($272$ KiB) is less than the initial free region ($512$ KiB), so all allocations succeed.\n\nStep 4: Calculate the total excess allocated bytes (internal fragmentation), $I$.\n$$I = S_{alloc} - S_{req} = 272 - 197 = 75 \\text{ KiB}$$\n\nStep 5: Calculate the waste fraction, $F_w$.\n$$F_w = \\frac{I}{S_{req}} = \\frac{75}{197}$$\n\nTo ensure the fraction is in its simplest form, we find the prime factors of the numerator and denominator.\nThe numerator is $75 = 3 \\times 25 = 3 \\times 5^2$.\nFor the denominator, $197$, we check for divisibility by small prime numbers.\n- $197$ is not divisible by $2$ (it is odd).\n- The sum of digits is $1+9+7 = 17$, which is not divisible by $3$.\n- It does not end in $0$ or $5$, so it is not divisible by $5$.\n- We continue checking primes up to $\\sqrt{197} \\approx 14$: $7, 11, 13$.\n  - $197 \\div 7 = 28$ remainder $1$.\n  - $197 \\div 11 = 17$ remainder $10$.\n  - $197 \\div 13 = 15$ remainder $2$.\nSince $197$ is not divisible by any prime number less than or equal to its square root, $197$ is a prime number.\nTherefore, the fraction $\\frac{75}{197}$ is irreducible.",
            "answer": "$$\\boxed{\\frac{75}{197}}$$"
        },
        {
            "introduction": "Over time, as processes are allocated and freed, even the most sophisticated allocator can leave memory in a highly fragmented state, often described as \"Swiss cheese.\" To solve this, an operating system can perform compaction, a process that reorganizes memory to consolidate all free space into one large, usable block. This exercise simulates a step-by-step compaction process, giving you a tangible understanding of how allocated segments are moved to eliminate holes and reclaim contiguous memory .",
            "id": "3628275",
            "problem": "An Operating System (OS) manages a single contiguous main memory region in Random Access Memory (RAM). In contiguous memory allocation, each process resides in one contiguous segment of physical addresses. When processes terminate, their segments are freed, creating holes of free memory between still-allocated segments. Over time, random frees produce a highly fragmented or \"Swiss cheese\" layout. The OS can perform compaction, which is the act of moving allocated segments in memory to eliminate holes and coalesce free space into one larger contiguous block, while preserving each segment's integrity.\n\nConsider the following current memory layout along increasing physical addresses (from low to high). Memory alternates between free holes and allocated segments. Let the free hole sizes be denoted by $h_{i}$ in kilobytes (kB), and the allocated segment sizes be denoted by $a_{i}$ in kilobytes (kB). The layout from the lowest address to the highest address is:\n$h_{0} = 12$, $a_{1} = 180$, $h_{1} = 36$, $a_{2} = 72$, $h_{2} = 20$, $a_{3} = 150$, $h_{3} = 55$, $a_{4} = 90$, $h_{4} = 40$, $a_{5} = 60$, $h_{5} = 30$, $a_{6} = 200$, $h_{6} = 17$, $a_{7} = 85$, $h_{7} = 28$.\n\nAssume the OS performs compaction under the following policy:\n- The relative order of allocated segments is preserved.\n- Only leftward moves are allowed, and each move consists of sliding a single allocated segment leftward to completely eliminate the immediately preceding hole.\n- After each move, the total free memory remains constant, but the eliminated hole’s capacity is effectively consolidated toward the high-address end as contiguous free space.\n\nYou are asked to propose a concrete compaction path that follows the above policy and then determine how many moves are required to create, at the highest addresses, a single contiguous free block of size at least $R = 150$ kB. Provide your final answer as the smallest number of moves needed to ensure the terminal free block is at least $R$. No rounding is required. Do not include units in your final numerical answer.",
            "solution": "The problem statement has been validated and is deemed to be self-contained, scientifically grounded in the context of operating systems principles, and well-posed. All data and conditions are provided to determine a unique solution.\n\nThe problem describes a contiguous memory allocation scheme. The memory layout consists of alternating free holes, with sizes denoted by $h_i$, and allocated segments, with sizes denoted by $a_i$, for $i \\in \\{0, 1, 2, \\dots\\}$. The layout is specified along increasing physical addresses, starting from the lowest address:\n$h_{0} = 12$ kB, $a_{1} = 180$ kB, $h_{1} = 36$ kB, $a_{2} = 72$ kB, $h_{2} = 20$ kB, $a_{3} = 150$ kB, $h_{3} = 55$ kB, $a_{4} = 90$ kB, $h_{4} = 40$ kB, $a_{5} = 60$ kB, $h_{5} = 30$ kB, $a_{6} = 200$ kB, $h_{6} = 17$ kB, $a_{7} = 85$ kB, $h_{7} = 28$ kB.\n\nThe goal of compaction is to move allocated segments to form a single, large, contiguous block of allocated memory, which in turn coalesces all free space into another single, large, contiguous block. The policy specifies that compaction moves segments leftward (towards lower addresses) and preserves the relative order of the allocated segments. This implies that the final configuration will place all allocated segments at the beginning of the memory region, followed by one large free block. The final layout would be:\n$[a_1][a_2][a_3][a_4][a_5][a_6][a_7][\\text{Free Space}]$\n\nTo achieve this final state while preserving the relative order of segments, the compaction process must proceed sequentially. First, segment $a_1$ must be moved to the beginning of memory, eliminating the hole $h_0$. Then, segment $a_2$ must be moved to be adjacent to $a_1$, eliminating hole $h_1$. This continues sequentially. A \"move\" is defined as sliding a single segment $a_i$ leftward to eliminate the immediately preceding hole $h_{i-1}$. Therefore, the compaction path is fixed:\n1. Move $a_1$ to eliminate $h_0$.\n2. Move $a_2$ to eliminate $h_1$.\n3. Move $a_3$ to eliminate $h_2$.\nAnd so on.\n\nThe problem states that when a hole is eliminated, its capacity is consolidated into the free block at the highest-address end. Let $H_{end}$ be the size of this contiguous terminal free block. Initially, this block is just the last hole in the layout, $h_7$.\nInitial size of the terminal free block: $H_{end}(0) = h_7 = 28$ kB.\n\nWe need to find the smallest number of moves, $N$, required to make the size of this terminal free block at least $R = 150$ kB. Each move corresponds to the elimination of one hole in sequential order, starting with $h_0$. After $N$ moves, the holes $h_0, h_1, \\dots, h_{N-1}$ will have been eliminated, and their sizes added to the terminal free block.\n\nThe size of the terminal free block after $N$ moves, $H_{end}(N)$, is given by the initial size plus the sum of the sizes of the eliminated holes:\n$$H_{end}(N) = h_7 + \\sum_{i=0}^{N-1} h_i$$\n\nWe seek the smallest integer $N$ such that $H_{end}(N) \\ge 150$. Let's calculate the cumulative size of the terminal block after each move.\n\nInitial state ($N=0$ moves):\n$H_{end}(0) = 28$ kB. This is less than $150$ kB.\n\nAfter $N=1$ move (eliminating $h_0$):\nThe hole $h_0$ has size $12$ kB.\n$H_{end}(1) = H_{end}(0) + h_0 = 28 + 12 = 40$ kB. This is less than $150$ kB.\n\nAfter $N=2$ moves (eliminating $h_0$ and $h_1$):\nThe hole $h_1$ has size $36$ kB.\n$H_{end}(2) = H_{end}(1) + h_1 = 40 + 36 = 76$ kB. This is less than $150$ kB.\n\nAfter $N=3$ moves (eliminating $h_0, h_1, h_2$):\nThe hole $h_2$ has size $20$ kB.\n$H_{end}(3) = H_{end}(2) + h_2 = 76 + 20 = 96$ kB. This is less than $150$ kB.\n\nAfter $N=4$ moves (eliminating $h_0, h_1, h_2, h_3$):\nThe hole $h_3$ has size $55$ kB.\n$H_{end}(4) = H_{end}(3) + h_3 = 96 + 55 = 151$ kB.\n\nAt this point, $H_{end}(4) = 151$ kB, which is greater than or equal to the required size $R = 150$ kB.\nTherefore, the smallest number of moves required is $4$. The compaction path consists of moving segment $a_1$ to eliminate $h_0$, then $a_2$ to eliminate $h_1$, then $a_3$ to eliminate $h_2$, and finally $a_4$ to eliminate $h_3$.",
            "answer": "$$\\boxed{4}$$"
        }
    ]
}