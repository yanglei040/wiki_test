{
    "hands_on_practices": [
        {
            "introduction": "While compaction effectively solves external fragmentation, it comes at a performance cost—the CPU cycles spent copying memory segments. A fundamental choice in designing a compaction algorithm is whether to preserve the original relative order of segments. This practice, known as stable compaction, is often simpler to implement but may not be the most efficient. This exercise challenges you to quantify the cost difference between stable compaction and an optimal but unstable strategy that rearranges segments to minimize the amount of data moved . Understanding this trade-off is crucial for evaluating different compaction policies.",
            "id": "3626069",
            "problem": "A uniprogrammed segmented memory system exhibits external fragmentation: free gaps exist between allocated segments. Compaction aims to coalesce free memory into a single contiguous free region by relocating segments. Consider a memory region from address $0$ to address $180$ bytes with the following current layout (addresses increase from left to right):\n\nSegment $S_1$ of size $30$ bytes starting at base address $0$, followed by a free gap of size $10$ bytes; segment $S_2$ of size $20$ bytes starting at base address $40$, followed by a free gap of size $20$ bytes; segment $S_3$ of size $40$ bytes starting at base address $80$, followed by a free gap of size $10$ bytes; and segment $S_4$ of size $50$ bytes starting at base address $130$.\n\nAssume the operating system performs compaction to eliminate all gaps, producing one contiguous block of all segments starting at address $0$ followed by a single contiguous free region at the end of memory. Define the relocation cost $R$ as the total number of bytes copied during compaction, equal to the sum of the sizes (in bytes) of all segments that are relocated to a different base address.\n\nTwo compaction policies are considered:\n1. Stable compaction: the final arrangement preserves the current relative order of segments ($S_1$, then $S_2$, then $S_3$, then $S_4$).\n2. Unstable compaction: the final arrangement may reorder segments arbitrarily to minimize $R$.\n\nCompute the increase in relocation cost $\\Delta R = R_{\\text{stable}} - R_{\\text{unstable}}$ produced by stable compaction relative to optimally chosen unstable compaction. Express your final answer in bytes. No rounding is required.",
            "solution": "Let $s_i$ be the size and $b_i$ be the initial base address of segment $S_i$. The given values are:\n- $S_1$: $s_1 = 30$, $b_1 = 0$.\n- $S_2$: $s_2 = 20$, $b_2 = 40$.\n- $S_3$: $s_3 = 40$, $b_3 = 80$.\n- $S_4$: $s_4 = 50$, $b_4 = 130$.\n\nThe total size of allocated memory is $\\sum_{i=1}^{4} s_i = 30 + 20 + 40 + 50 = 140$ bytes. After compaction, these segments will occupy the memory region from address $0$ to $140$. A segment $S_i$ is relocated if its final base address, $b'_i$, is not equal to its initial base address, $b_i$. The relocation cost, $R$, is the sum of sizes of all relocated segments.\n\n**1. Calculation of Stable Compaction Cost ($R_{\\text{stable}}$)**\n\nIn stable compaction, the relative order of segments is preserved. The final layout will be $S_1, S_2, S_3, S_4$, starting at address $0$. We calculate the new base addresses ($b'_i$):\n- $S_1$ is at the beginning: $b'_1 = 0$.\n- $S_2$ follows $S_1$: $b'_2 = b'_1 + s_1 = 0 + 30 = 30$.\n- $S_3$ follows $S_2$: $b'_3 = b'_2 + s_2 = 30 + 20 = 50$.\n- $S_4$ follows $S_3$: $b'_4 = b'_3 + s_3 = 50 + 40 = 90$.\n\nNow, we identify which segments are relocated by comparing initial and final base addresses:\n- $S_1$: $b_1 = 0$, $b'_1 = 0$. Since $b_1 = b'_1$, $S_1$ is not relocated.\n- $S_2$: $b_2 = 40$, $b'_2 = 30$. Since $b_2 \\neq b'_2$, $S_2$ is relocated.\n- $S_3$: $b_3 = 80$, $b'_3 = 50$. Since $b_3 \\neq b'_3$, $S_3$ is relocated.\n- $S_4$: $b_4 = 130$, $b'_4 = 90$. Since $b_4 \\neq b'_4$, $S_4$ is relocated.\n\nThe stable relocation cost is the sum of the sizes of the relocated segments:\n$$R_{\\text{stable}} = s_2 + s_3 + s_4 = 20 + 40 + 50 = 110$$\n\n**2. Calculation of Optimal Unstable Compaction Cost ($R_{\\text{unstable}}$)**\n\nIn unstable compaction, we can reorder the segments to minimize the relocation cost $R$. Minimizing $R$ is equivalent to maximizing the total size of segments that are *not* relocated. A segment $S_i$ is not relocated if its final position has the same base address as its initial position, $b'_i = b_i$.\n\nFor any segment to remain fixed in an arrangement starting at address $0$, segment $S_1$ (with initial base address $0$) must be the first segment in the final arrangement and thus is not relocated. To maximize the non-relocated memory, we search for other segments that can also remain in their original positions.\n\nLet's test if we can keep both $S_1$ and another segment $S_j$ fixed. This is possible if the space between them, $b_j - (b_1 + s_1)$, can be exactly filled by a subset of the remaining segments.\n- **Test for $\\{S_1, S_2\\}$**: Gap size to fill = $b_2 - (b_1 + s_1) = 40 - (0 + 30) = 10$. The remaining segments are $S_3$ (size 40) and $S_4$ (size 50). No subset sums to 10. Not possible.\n- **Test for $\\{S_1, S_3\\}$**: Gap size to fill = $b_3 - (b_1 + s_1) = 80 - (0 + 30) = 50$. The remaining segments are $S_2$ (size 20) and $S_4$ (size 50). We can fill the gap with $S_4$. This is a valid arrangement. The non-relocated segments are $S_1$ and $S_3$, with a total size of $s_1 + s_3 = 30 + 40 = 70$.\n- **Test for $\\{S_1, S_4\\}$**: Gap size to fill = $b_4 - (b_1 + s_1) = 130 - (0 + 30) = 100$. The remaining segments are $S_2$ (size 20) and $S_3$ (size 40), with a total size of 60. Not possible.\n\nThe maximum total size of segments that can be kept in their original positions is $70$ bytes (by keeping $S_1$ and $S_3$ fixed). The minimal relocation cost is the total size of all segments minus this maximum non-relocated size.\n$$R_{\\text{unstable}} = \\left(\\sum_{i=1}^{4} s_i\\right) - (s_1 + s_3) = 140 - (30 + 40) = 140 - 70 = 70$$\n\n**3. Calculation of the Increase in Relocation Cost ($\\Delta R$)**\n\nThe increase in relocation cost is the difference between the stable and optimal unstable costs.\n$$\\Delta R = R_{\\text{stable}} - R_{\\text{unstable}} = 110 - 70 = 40$$\n\nThe increase in cost is $40$ bytes.",
            "answer": "$$\n\\boxed{40}\n$$"
        },
        {
            "introduction": "After establishing the cost of moving segments, a practical question arises: where should the consolidated free block be located? The two most common strategies are to move all allocated segments to the lowest available addresses (packing left) or to the highest available addresses (packing right). In this problem, you will analyze a large memory space and calculate the total relocation cost for both scenarios under a stable compaction policy . This practice will solidify your ability to analyze memory layouts and determine the most efficient direction for a full compaction operation.",
            "id": "3626058",
            "problem": "An Operating System (OS) manages main memory by placing allocated regions (process segments) and leaving free regions (holes) where allocations have been deallocated or cannot be used due to size mismatch. External fragmentation arises when free memory is split into many discontiguous holes, making large allocations impossible despite sufficient total free capacity. Compaction is the process of physically moving allocated regions to eliminate holes and consolidate free memory into a single contiguous region. Under stable order compaction, the relative order of allocated regions must be preserved, no region may be split, and each moved region is copied exactly once; the cost of moving a region is measured as the number of bytes copied for that region.\n\nConsider a linear memory of size $M=1\\ \\mathrm{GiB}$, modeled as a sequence of $n=200$ allocated segments and $(n+1)$ holes in the following order from the lowest address to the highest: an initial hole $h_0$, followed by segment $1$, then hole $h_1$, segment $2$, and so on, ending with hole $h_{200}$. All allocated segments have identical size $s_i=2\\ \\mathrm{MiB}$ for $i=1,2,\\dots,200$. The holes are defined by\n- $h_0=0$,\n- $h_j=0$ for $j=1,2,\\dots,79$,\n- $h_j=4\\ \\mathrm{MiB}$ for $j=80,81,\\dots,199$,\n- $h_{200}=144\\ \\mathrm{MiB}$,\nand there are no other holes. The total memory satisfies the identity\n$$M=\\left(\\sum_{i=1}^{200} s_i\\right)+\\left(\\sum_{j=0}^{200} h_j\\right).$$\n\nUnder stable order compaction that must consolidate all free memory into one single contiguous region located at either the lowest addresses (left end) or the highest addresses (right end), define the compaction cost as $\\sum_{i=1}^{200} m_i$, where $m_i$ equals $s_i$ if segment $i$ is moved and $m_i=0$ if segment $i$ remains unmoved. Compute the minimal possible value\n$$\\min \\sum_{i=1}^{200} m_i,$$\nover all valid stable-order compactions that produce a single contiguous free region at one end of memory. Express your final answer as an exact integer number of bytes.",
            "solution": "### Step 1: Analyze the Initial Memory Configuration\nFirst, let's verify the memory allocation given in the problem statement.\n- Total allocated segment size: $200 \\text{ segments} \\times 2 \\text{ MiB/segment} = 400 \\text{ MiB}$.\n- Total hole size:\n    - $h_0 = 0 \\text{ MiB}$\n    - $h_1$ to $h_{79}$ (79 holes): $79 \\times 0 \\text{ MiB} = 0 \\text{ MiB}$\n    - $h_{80}$ to $h_{199}$ (120 holes): $120 \\times 4 \\text{ MiB} = 480 \\text{ MiB}$\n    - $h_{200} = 144 \\text{ MiB}$\n- Sum of hole sizes = $0 + 0 + 480 + 144 = 624 \\text{ MiB}$.\n- Total memory = Segment size + Hole size = $400 \\text{ MiB} + 624 \\text{ MiB} = 1024 \\text{ MiB} = 1 \\text{ GiB}$.\nThe configuration is consistent.\n\nThe cost of compaction is the sum of the sizes of all relocated segments. We need to calculate this cost for two scenarios: compacting to the left end and compacting to the right end, then find the minimum.\n\n### Step 2: Calculate Cost for Compaction to the Left End ($C_{\\text{left}}$)\nWhen compacting to the left (lowest addresses), segments are moved to fill any preceding holes. A segment does not move if and only if there are no holes before it.\n- The layout is $h_0, s_1, h_1, s_2, \\dots$.\n- A segment $s_k$ remains in place if the sum of all preceding holes, $\\sum_{j=0}^{k-1} h_j$, is equal to $0$.\n- We are given $h_0=0$ and $h_j=0$ for $j=1, \\dots, 79$.\n- For any segment $s_k$ where $k \\le 80$, the sum of preceding holes $\\sum_{j=0}^{k-1} h_j = 0$. Therefore, segments $s_1, s_2, \\dots, s_{80}$ are already contiguous at the start of memory and do not move.\n- For segment $s_{81}$, the preceding holes include $h_{80} = 4 \\text{ MiB}$. The sum is non-zero, so $s_{81}$ must be relocated.\n- For all subsequent segments ($s_k$ with $k > 80$), the sum of preceding holes will be non-zero. Thus, all segments from $s_{81}$ to $s_{200}$ must be relocated.\n- Number of relocated segments = $200 - 81 + 1 = 120$.\n- Each segment is $2 \\text{ MiB}$.\n- $C_{\\text{left}} = 120 \\text{ segments} \\times 2 \\text{ MiB/segment} = 240 \\text{ MiB}$.\n\n### Step 3: Calculate Cost for Compaction to the Right End ($C_{\\text{right}}$)\nWhen compacting to the right (highest addresses), the contiguous block of segments will occupy the highest addresses in memory. Due to stable ordering, segment $s_{200}$ will be at the very end, preceded by $s_{199}$, and so on.\n- A segment $s_k$ remains in its original position only if all holes after it (including any within its block) are of size 0.\n- The condition for segment $s_k$ to not move is $\\sum_{j=k}^{200} h_j = 0$.\n- Since $h_{200} = 144 \\text{ MiB} > 0$, this condition is never met for any $k \\le 200$.\n- Therefore, when compacting to the right, *all* 200 segments must be relocated.\n- $C_{\\text{right}} = 200 \\text{ segments} \\times 2 \\text{ MiB/segment} = 400 \\text{ MiB}$.\n\n### Step 4: Determine Minimal Cost and Convert to Bytes\nThe minimal compaction cost is the smaller of the two calculated costs.\n- Minimal cost in MiB = $\\min(C_{\\text{left}}, C_{\\text{right}}) = \\min(240 \\text{ MiB}, 400 \\text{ MiB}) = 240 \\text{ MiB}$.\n- The final answer must be in bytes. $1 \\text{ MiB} = 2^{20} \\text{ bytes} = 1,048,576 \\text{ bytes}$.\n- Minimal cost in bytes = $240 \\times 1,048,576 = 251,658,240 \\text{ bytes}$.",
            "answer": "$$\\boxed{251658240}$$"
        },
        {
            "introduction": "Full compaction, which eliminates all holes, can be an expensive, all-or-nothing operation. In many real-world scenarios, an operating system only needs to create a single free hole large enough to satisfy an incoming memory request. This leads to the strategy of partial compaction: performing the minimal work necessary to achieve a specific goal. This exercise puts you in the role of an OS designer, asking you to find the most cost-effective way to create a target-sized hole and compare its cost to that of a full compaction . This helps illustrate the practical optimizations that make memory management efficient.",
            "id": "3626125",
            "problem": "An operating system uses contiguous allocation for processes in Random Access Memory (RAM). External fragmentation manifests as multiple non-contiguous free regions (holes) interspersed with allocated segments (processes). Compaction relocates allocated segments to coalesce holes, increasing the maximal allocatable contiguous block. Assume the following model and constraints are in effect:\n\n- Memory is a linear address space from low to high addresses.\n- The current layout from low to high addresses is: a hole of size $60\\,\\text{KiB}$, then an allocated segment $P_1$ of size $80\\,\\text{KiB}$, then a hole of size $50\\,\\text{KiB}$, then an allocated segment $P_2$ of size $100\\,\\text{KiB}$, then a hole of size $120\\,\\text{KiB}$, then an allocated segment $P_3$ of size $90\\,\\text{KiB}$, then a hole of size $40\\,\\text{KiB}$, then an allocated segment $P_4$ of size $60\\,\\text{KiB}$, then a hole of size $50\\,\\text{KiB}$.\n- Relocating a segment incurs a cost equal to its size (in bytes relocated). Segments must be relocated as whole, contiguous units into a single existing hole whose size is at least the segment’s size; splitting a segment across multiple holes is forbidden. Relocated segments must not overlap any other segment, and the total free space remains unchanged.\n- Under full compaction, the operating system performs a stable leftward packing: all allocated segments are moved toward the lowest address while preserving their order to eliminate all internal holes, leaving a single hole at the highest addresses.\n\nStarting from the above layout, perform a partial compaction that achieves a target maximum hole size $h_{\\max} = 160\\,\\text{KiB}$, with the policy “compact only to reach the target”: relocate the minimal total amount of data $R$ (in $\\text{KiB}$) necessary to ensure there exists at least one contiguous free region of size at least $h_{\\max}$, subject to the relocation constraints stated above. Let $R_{\\text{full}}$ be the total amount of data relocated by full compaction under the stable leftward packing described.\n\nCompute the ratio $R/R_{\\text{full}}$ and express your final answer as a dimensionless decimal rounded to four significant figures.",
            "solution": "### Step 1: Define the Initial Memory Layout and Goals\nThe initial memory layout is a sequence of holes (H) and processes (P) with sizes in KiB:\n`H1(60) | P1(80) | H2(50) | P2(100) | H3(120) | P3(90) | H4(40) | P4(60) | H5(50)`\n\nThe relocation cost is the size of the moved segment.\n- **Partial Compaction Goal**: Create a hole of at least $h_{\\max} = 160\\,\\text{KiB}$ with minimal relocation cost, $R$.\n- **Full Compaction Goal**: Perform stable leftward packing, and find its cost, $R_{\\text{full}}$.\n\n### Step 2: Calculate the Cost of Full Compaction ($R_{\\text{full}}$)\nFull stable leftward packing moves all allocated segments to the start of memory while preserving their order. The initial layout starts with a hole (`H1`), so every segment must be moved to the left to form a contiguous block `P1|P2|P3|P4` at the lowest addresses. The cost is the sum of the sizes of all relocated segments.\n$$ R_{\\text{full}} = \\text{size}(P_1) + \\text{size}(P_2) + \\text{size}(P_3) + \\text{size}(P_4) $$\n$$ R_{\\text{full}} = 80 + 100 + 90 + 60 = 330\\,\\text{KiB} $$\n\n### Step 3: Calculate the Minimal Cost of Partial Compaction ($R$)\nWe need to find the cheapest sequence of moves to create a hole of at least $160\\,\\text{KiB}$. A larger hole can be created by moving a process that separates two or more holes, allowing them to merge.\n\nLet's analyze the possibilities by moving a single process:\n1.  **Move P1 (size 80 KiB)**: This would merge the space of `P1` with its adjacent holes `H1(60)` and `H2(50)`.\n    - Resulting hole size = `size(H1) + size(P1) + size(H2) = 60 + 80 + 50 = 190\\,\\text{KiB}`.\n    - Since $190 \\ge 160$, this achieves the goal.\n    - Feasibility: To move `P1`, we need an existing hole of at least its size (80 KiB). Hole `H3(120)` is available.\n    - This move is possible. The cost is `size(P1) = 80\\,\\text{KiB}`.\n\n2.  **Move P2 (size 100 KiB)**: This would merge `H2(50)`, `P2(100)`, and `H3(120)`, creating a hole of `270\\,\\text{KiB}`.\n    - Feasibility: To move `P2`, we need an existing hole of at least 100 KiB *outside* of the `H2-P2-H3` region. The available holes are `H1(60)`, `H4(40)`, `H5(50)`. None are large enough.\n    - This move is not possible in a single step.\n\n3.  **Move P3 (size 90 KiB)**: This would merge `H3(120)`, `P3(90)`, and `H4(40)`, creating a hole of `250\\,\\text{KiB}`.\n    - Feasibility: To move `P3`, we need an outside hole of at least 90 KiB. The available holes are `H1(60)`, `H2(50)`, `H5(50)`. None are large enough.\n    - This move is not possible in a single step.\n    \n4.  **Move P4 (size 60 KiB)**: This would merge `H4(40)`, `P4(60)`, and `H5(50)`, creating a hole of `150\\,\\text{KiB}`.\n    - This does not meet the target of $160\\,\\text{KiB}$.\n\nThe only single-move solution that achieves the goal costs `80\\,\\text{KiB}`. Could a multi-move solution be cheaper?\n- A multi-move solution would have to cost less than `80\\,\\text{KiB}`.\n- The cheapest process to move is `P4` (cost `60\\,\\text{KiB}`). As shown, this move by itself is insufficient.\n- Any second move would add to the cost. The next smallest process to move would be `P1` (size 80). Any two-process move sequence would thus cost more than $80\\,\\text{KiB}$.\n- Therefore, any multi-move solution is more expensive than the single-move solution of relocating `P1`.\n\nThe minimal cost for partial compaction is $R = 80\\,\\text{KiB}$.\n\n### Step 4: Compute the Ratio\nThe problem asks for the ratio $R/R_{\\text{full}}$.\n$$ \\frac{R}{R_{\\text{full}}} = \\frac{80\\,\\text{KiB}}{330\\,\\text{KiB}} = \\frac{8}{33} $$\n$$ \\frac{8}{33} \\approx 0.242424... $$\nRounding to four significant figures gives $0.2424$.",
            "answer": "$$\n\\boxed{0.2424}\n$$"
        }
    ]
}