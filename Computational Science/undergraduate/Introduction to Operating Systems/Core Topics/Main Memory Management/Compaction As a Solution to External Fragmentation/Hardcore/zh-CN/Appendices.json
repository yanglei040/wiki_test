{
    "hands_on_practices": [
        {
            "introduction": "为了开始我们对内存紧缩的动手实践，我们从一个基本问题入手：“游戏规则”如何影响最终结果？第一个练习  比较了两种关键策略：保留数据相对顺序的稳定紧缩，以及允许为最小化成本而重排顺序的不稳定紧缩。通过计算每种策略的成本，你将具体理解在可预测性和效率之间的权衡。",
            "id": "3626069",
            "problem": "一个单道程序的分段式内存系统存在外部碎片：在已分配的段之间存在空闲间隙。紧凑技术旨在通过重定位内存段，将空闲内存合并成一个单一的连续空闲区域。考虑一个从地址 $0$ 到地址 $180$ 字节的内存区域，其当前布局如下（地址从左到右递增）：\n\n大小为 $30$ 字节的段 $S_1$，起始基地址为 $0$，后跟一个大小为 $10$ 字节的空闲间隙；大小为 $20$ 字节的段 $S_2$，起始基地址为 $40$，后跟一个大小为 $20$ 字节的空闲间隙；大小为 $40$ 字节的段 $S_3$，起始基地址为 $80$，后跟一个大小为 $10$ 字节的空闲间隙；以及大小为 $50$ 字节的段 $S_4$，起始基地址为 $130$。\n\n假设操作系统执行紧凑操作以消除所有间隙，从而生成一个从地址 $0$ 开始的所有段组成的连续块，其后是内存末尾的一个单一连续空闲区域。将重定位成本 $R$ 定义为紧凑过程中复制的总字节数，等于所有被重定位到不同基地址的段的大小（以字节为单位）之和。\n\n考虑以下两种紧凑策略：\n1. 稳定紧凑：最终布局保留段的当前相对顺序（$S_1$、然后是 $S_2$、然后是 $S_3$、然后是 $S_4$）。\n2. 不稳定紧凑：最终布局可以任意重排段以最小化 $R$。\n\n计算相对于最优选择的不稳定紧凑，稳定紧凑所产生的重定位成本增加量 $\\Delta R = R_{\\text{stable}} - R_{\\text{unstable}}$。最终答案以字节为单位表示。无需四舍五入。",
            "solution": "在进行求解之前，对问题进行验证。\n\n### 步骤 1：提取已知条件\n- 总内存区域：地址 $0$到地址 $180$ 字节。\n- 段 $S_1$：大小 $30$ 字节，基地址 $0$。\n- 空闲间隙 1：大小 $10$ 字节。\n- 段 $S_2$：大小 $20$ 字节，基地址 $40$。\n- 空闲间隙 2：大小 $20$ 字节。\n- 段 $S_3$：大小 $40$ 字节，基地址 $80$。\n- 空闲间隙 3：大小 $10$ 字节。\n- 段 $S_4$：大小 $50$ 字节，基地址 $130$。\n- 紧凑目标：所有段在内存起始处形成一个单一连续块，后跟一个单一连续空闲区域。\n- 重定位成本 $R$：所有被重定位到不同基地址的段的大小之和。\n- 稳定紧凑：段的最终相对顺序是 $S_1, S_2, S_3, S_4$。\n- 不稳定紧凑：可以重排段以最小化重定位成本 $R$。\n- 要计算的值：$\\Delta R = R_{\\text{stable}} - R_{\\text{unstable}}$。\n\n### 步骤 2：使用提取的已知条件进行验证\n问题陈述描述了操作系统内存管理中关于外部碎片和紧凑的一个标准场景。这些概念是有科学依据的。参数（段大小、基地址、内存大小）定义清晰且数值上一致。\n- $S_1$ 占用地址 $[0, 30)$。\n- 间隙 1 占用 $[30, 40)$。\n- $S_2$ 占用 $[40, 60)$。\n- 间隙 2 占用 $[60, 80)$。\n- $S_3$ 占用 $[80, 120)$。\n- 间隙 3 占用 $[120, 130)$。\n- $S_4$ 占用 $[130, 180)$。\n占用的总空间为 $180$ 字节，与内存区域大小相符。该问题是自洽的、提法明确且客观的。它不包含科学错误、歧义或矛盾。\n\n### 步骤 3：结论与行动\n问题有效。将提供完整解决方案。\n\n### 解答\n\n设 $s_i$ 为段 $S_i$ 的大小，$b_i$ 为其初始基地址。给定的值为：\n- $S_1$: $s_1 = 30$, $b_1 = 0$。\n- $S_2$: $s_2 = 20$, $b_2 = 40$。\n- $S_3$: $s_3 = 40$, $b_3 = 80$。\n- $S_4$: $s_4 = 50$, $b_4 = 130$。\n\n已分配内存的总大小为 $\\sum_{i=1}^{4} s_i = 30 + 20 + 40 + 50 = 140$ 字节。紧凑后，这些段将占用从地址 $0$ 到 $140$ 的内存区域。如果段 $S_i$ 的最终基地址 $b'_i$ 不等于其初始基地址 $b_i$，则该段被重定位。重定位成本 $R$ 是所有被重定位段的大小之和。\n\n**1. 计算稳定紧凑成本 ($R_{\\text{stable}}$)**\n\n在稳定紧凑中，段的相对顺序被保留。最终布局将是 $S_1, S_2, S_3, S_4$，从地址 $0$ 开始。我们计算新的基地址（$b'_i$）：\n- $S_1$ 在开头：$b'_1 = 0$。\n- $S_2$ 跟随 $S_1$：$b'_2 = b'_1 + s_1 = 0 + 30 = 30$。\n- $S_3$ 跟随 $S_2$：$b'_3 = b'_2 + s_2 = 30 + 20 = 50$。\n- $S_4$ 跟随 $S_3$：$b'_4 = b'_3 + s_3 = 50 + 40 = 90$。\n\n现在，我们通过比较初始和最终基地址来确定哪些段被重定位：\n- $S_1$：$b_1 = 0$, $b'_1 = 0$。由于 $b_1 = b'_1$， $S_1$ 未被重定位。\n- $S_2$：$b_2 = 40$, $b'_2 = 30$。由于 $b_2 \\neq b'_2$， $S_2$ 被重定位。\n- $S_3$：$b_3 = 80$, $b'_3 = 50$。由于 $b_3 \\neq b'_3$， $S_3$ 被重定位。\n- $S_4$：$b_4 = 130$, $b'_4 = 90$。由于 $b_4 \\neq b'_4$， $S_4$ 被重定位。\n\n稳定重定位成本是被重定位段的大小之和：\n$$R_{\\text{stable}} = s_2 + s_3 + s_4 = 20 + 40 + 50 = 110$$\n\n**2. 计算最优不稳定紧凑成本 ($R_{\\text{unstable}}$)**\n\n在不稳定紧凑中，我们可以重排段以最小化重定位成本 $R$。最小化 $R$ 等同于最大化*未*被重定位的段的总大小。如果段 $S_i$ 的最终位置与其初始位置具有相同的基地址 $b'_i = b_i$，则该段未被重定位。\n\n设未重定位段的集合为 $K$。为使 $K$ 非空，必须至少有一个段 $S_k \\in K$，其最终基地址 $b'_k$ 等于其初始基地址 $b_k$。在最终的紧凑布局中，段从地址 $0$ 开始形成一个连续块。假设未重定位的段按其基地址排序为 $S_{k_1}, S_{k_2}, \\ldots, S_{k_m}$，且 $b_{k_1}  b_{k_2}  \\ldots  b_{k_m}$。\n最终序列中的第一个段的基地址必须为 $0$。如果这个段（比如 $S_i$）要不被重定位，它的初始基地址必须是 $0$。只有 $S_1$ 的初始基地址为 $0$。因此，如果要让任何段保持固定，$S_1$ 必须是最终布局中的第一个段，因此它不被重定位。\n\n所以，任何未重定位段的集合都必须包含 $S_1$。让我们测试一下除了 $S_1$ 之外，还有哪些段可以保持原位。\n假设 $S_1$ 和 $S_j$（其中 $b_j > b_1$）都未被重定位。在最终布局中，从 $S_1$ 的末尾（地址 $b_1+s_1$）到 $S_j$ 的开头（地址 $b_j$）的内存块必须由剩余（被重定位）段的一个子集精确填充。填充此间隙所需的大小为 $b_j - (b_1 + s_1)$。\n\n- **测试将 $\\{S_1, S_2\\}$ 作为未重定位段：**\n  - $b_1=0$, $s_1=30$。$b_2=40$。\n  - 需填充的间隙大小：$b_2 - (b_1 + s_1) = 40 - (0 + 30) = 10$。\n  - 其他段是 $S_3$（大小 $40$）和 $S_4$（大小 $50$）。$\\{S_3, S_4\\}$ 的任何子集的总大小都不为 $10$。因此，不可能同时保持 $S_1$ 和 $S_2$ 固定。\n\n- **测试将 $\\{S_1, S_3\\}$ 作为未重定位段：**\n  - $b_1=0$, $s_1=30$。$b_3=80$。\n  - 需填充的间隙大小：$b_3 - (b_1 + s_1) = 80 - (0 + 30) = 50$。\n  - 其他段是 $S_2$（大小 $20$）和 $S_4$（大小 $50$）。段 $S_4$ 的大小为 $50$。我们可以将 $S_4$ 放入该间隙。\n  - 这导致了一个有效的布局：最终顺序是 $(S_1, S_4, S_3, S_2)$。\n    - $S_1$ 从 $0$ 开始（未重定位）。\n    - $S_4$ 从 $0+s_1=30$ 开始（从 $130$ 重定位）。\n    - $S_3$ 从 $30+s_4=30+50=80$ 开始（未重定位）。\n    - $S_2$ 从 $80+s_3=80+40=120$ 开始（从 $40$ 重定位）。\n  - 未重定位段的总大小为 $s_1 + s_3 = 30 + 40 = 70$。\n\n- **测试将 $\\{S_1, S_4\\}$ 作为未重定位段：**\n  - $b_1=0$, $s_1=30$。$b_4=130$。\n  - 需填充的间隙大小：$b_4 - (b_1 + s_1) = 130 - (0 + 30) = 100$。\n  - 其他段是 $S_2$（大小 $20$）和 $S_3$（大小 $40$）。它们的总大小为 $20+40=60$，而不是 $100$。因此，不可能同时保持 $S_1$ 和 $S_4$ 固定。\n\n根据分析，可以保持在其原始位置的段的最大 total size为 $70$ 字节（通过保持 $S_1$ 和 $S_3$ 固定）。\n最小重定位成本是所有段的总大小减去这个最大的未重定位大小。\n$$R_{\\text{unstable}} = \\left(\\sum_{i=1}^{4} s_i\\right) - (s_1 + s_3) = 140 - (30 + 40) = 140 - 70 = 70$$\n\n**3. 计算重定位成本的增加量 ($\\Delta R$)**\n\n重定位成本的增加量是稳定成本与最优不稳定成本之差。\n$$\\Delta R = R_{\\text{stable}} - R_{\\text{unstable}} = 110 - 70 = 40$$\n\n成本增加量为 $40$ 字节。",
            "answer": "$$\n\\boxed{40}\n$$"
        },
        {
            "introduction": "虽然完全紧缩很有效，但它可能是一项成本高昂的“全有或全无”的操作。在实践中，系统通常只需要创建一个特定大小的可用空间，而无需整合所有碎片化的内存。这个练习  引入了部分紧缩的概念，挑战你寻找最经济高效的方式来达成特定目标。这突显了一个关键的工程原则：为达成所需结果而优化，而不是执行不必要的工作。",
            "id": "3626125",
            "problem": "一个操作系统在随机存取存储器（RAM）中对进程使用连续分配。外部碎片表现为多个不连续的空闲区域（空洞）散布在已分配段（进程）之间。紧凑通过重定位已分配段来合并空闲区，从而增加最大可分配的连续块。假设以下模型和约束生效：\n\n- 内存是一个从低地址到高地址的线性地址空间。\n- 当前从低地址到高地址的布局是：一个大小为 $60\\,\\text{KiB}$ 的空洞，接着是一个大小为 $80\\,\\text{KiB}$ 的已分配段 $P_1$，接着是一个大小为 $50\\,\\text{KiB}$ 的空洞，接着是一个大小为 $100\\,\\text{KiB}$ 的已分配段 $P_2$，接着是一个大小为 $120\\,\\text{KiB}$ 的空洞，接着是一个大小为 $90\\,\\text{KiB}$ 的已分配段 $P_3$，接着是一个大小为 $40\\,\\text{KiB}$ 的空洞，接着是一个大小为 $60\\,\\text{KiB}$ 的已分配段 $P_4$，接着是一个大小为 $50\\,\\text{KiB}$ 的空洞。\n- 重定位一个段产生的成本等于其大小（即重定位的数据量）。段必须作为完整的、连续的单元被重定位到一个大小至少等于该段大小的单个现有空洞中；禁止将一个段分割到多个空洞中。重定位后的段不得与任何其他段重叠，并且总空闲空间保持不变。\n- 在完全紧凑下，操作系统执行稳定的向左紧缩：所有已分配段都向最低地址移动，同时保持它们的顺序，以消除所有内部空洞，在最高地址处留下一个单一的空洞。\n\n从上述布局开始，执行一次部分紧凑以达到目标最大空洞大小 $h_{\\max} = 160\\,\\text{KiB}$，遵循“仅为达到目标而紧凑”的策略：重定位所需的最小总数据量 $R$（单位为 $\\text{KiB}$）以确保存在至少一个大小至少为 $h_{\\max}$ 的连续空闲区域，并遵守上述重定位约束。设 $R_{\\text{full}}$ 为在所述稳定的向左紧缩策略下通过完全紧凑重定位的总数据量。\n\n计算比率 $R/R_{\\text{full}}$，并将您的最终答案表示为一个无量纲的小数，四舍五入到四位有效数字。",
            "solution": "我们首先验证问题陈述。问题为关于操作系统内存紧缩提供了一个清晰且定义明确的场景。所有参数，如段大小、空洞大小和重定位规则都是明确的。问题没有科学错误、歧义或矛盾。因此，我们将继续提供一个完整的解决方案。\n\n### 步骤 1：分析初始内存布局\n初始内存布局从低地址到高地址依次为：\n- 空洞 $H_1$: $60\\,\\text{KiB}$\n- 进程 $P_1$: $80\\,\\text{KiB}$\n- 空洞 $H_2$: $50\\,\\text{KiB}$\n- 进程 $P_2$: $100\\,\\text{KiB}$\n- 空洞 $H_3$: $120\\,\\text{KiB}$\n- 进程 $P_3$: $90\\,\\text{KiB}$\n- 空洞 $H_4$: $40\\,\\text{KiB}$\n- 进程 $P_4$: $60\\,\\text{KiB}$\n- 空洞 $H_5$: $50\\,\\text{KiB}$\n\n### 步骤 2：计算完全紧缩成本 ($R_{\\text{full}}$)\n完全紧缩的策略是稳定的向左紧缩，将所有已分配段移至内存的最低地址端。\n初始布局中，最低地址处是一个空洞 ($H_1$)，因此没有进程位于其最终的紧凑位置。为了将所有进程 `P1, P2, P3, P4` 移动到内存的开头，形成一个连续的块，所有这四个进程都必须被重定位。\n重定位成本等于被移动段的大小之和。因此，$R_{\\text{full}}$ 是所有进程大小的总和。\n$$R_{\\text{full}} = \\text{size}(P_1) + \\text{size}(P_2) + \\text{size}(P_3) + \\text{size}(P_4)$$\n$$R_{\\text{full}} = 80 + 100 + 90 + 60 = 330\\,\\text{KiB}$$\n\n### 步骤 3：计算最小部分紧缩成本 ($R$)\n目标是创建一个大小至少为 $h_{\\max} = 160\\,\\text{KiB}$ 的连续空洞，同时最小化重定位成本 $R$。\n创建更大空洞的方法是通过移动它们之间的进程来合并现有的空洞。当我们移动一个进程 `P` 时，它会留下一个大小为 `size(P)` 的新空洞，这个新空洞可以与其相邻的空洞合并。\n我们来分析通过移动单个进程来合并相邻空洞的选项：\n\n1.  **移动 $P_1$ (大小 80 KiB) 以合并 $H_1$, $P_1$ 的空间, 和 $H_2$**:\n    - 这将创建一个大小为 $60 + 80 + 50 = 190\\,\\text{KiB}$ 的空洞。\n    - 这个大小满足目标 $190 \\ge 160$。\n    - 这个操作是否可行？我们需要一个地方来存放 $P_1$。根据规则，它必须被移动到一个大小至少为 $80\\,\\text{KiB}$ 的**现有**空洞中。$H_3$ 的大小为 $120\\,\\text{KiB}$，可以容纳 $P_1$。\n    - 因此，这是一个有效的操作。成本是移动 $P_1$ 的大小，即 $R = 80\\,\\text{KiB}$。\n\n2.  **移动 $P_2$ (大小 100 KiB) 以合并 $H_2$, $P_2$ 的空间, 和 $H_3$**:\n    - 这将创建一个大小为 $50 + 100 + 120 = 270\\,\\text{KiB}$ 的空洞。\n    - 这个操作是否可行？我们需要一个大小至少为 $100\\,\\text{KiB}$ 的现有空洞来存放 $P_2$。除了我们正在尝试合并的 $H_2$ 和 $H_3$ 之外，可用的空洞是 $H_1 (60)$, $H_4 (40)$, $H_5 (50)$。没有一个空洞足够大。\n    - 因此，这个操作无法通过一次移动完成。\n\n3.  **移动 $P_3$ (大小 90 KiB) 以合并 $H_3$, $P_3$ 的空间, 和 $H_4$**:\n    - 这将创建一个大小为 $120 + 90 + 40 = 250\\,\\text{KiB}$ 的空洞。\n    - 这个操作是否可行？我们需要一个大小至少为 $90\\,\\text{KiB}$ 的现有空洞。除了 $H_3$ 和 $H_4$ 之外，可用的空洞是 $H_1 (60)$, $H_2 (50)$, $H_5 (50)$。没有一个足够大。\n    - 因此，这个操作也无法通过一次移动完成。\n\n4.  **移动 $P_4$ (大小 60 KiB) 以合并 $H_4$, $P_4$ 的空间, 和 $H_5$**:\n    - 这将创建一个大小为 $40 + 60 + 50 = 150\\,\\text{KiB}$ 的空洞。\n    - 这个大小不满足目标 $150  160$。\n\n到目前为止，通过移动单个进程达到目标的唯一可行方法是移动 $P_1$，成本为 $80\\,\\text{KiB}$。\n\n现在我们考虑移动多个进程。任何寻找更低成本的策略都必须有总成本小于 $80\\,\\text{KiB}$。\n- 最小的移动成本来自移动最小的进程 $P_4$ (大小 $60\\,\\text{KiB}$)。如果只移动 $P_4$，我们无法达到目标。\n- 如果我们移动 $P_4$ 和另一个进程 $P_x$，总成本将是 $60 + \\text{size}(P_x)$。为了使这个成本低于 $80$，我们需要 $\\text{size}(P_x)  20\\,\\text{KiB}$。没有这样的进程。\n- 因此，任何涉及移动两个或更多进程的有效序列的成本都将高于 $80\\,\\text{KiB}$。例如，移动 $P_4$ (成本 60) 和 $P_1$ (成本 80) 的总成本是 $140\\,\\text{KiB}$。\n\n结论是，达到目标所需的最小重定位成本是通过移动 $P_1$ 实现的。\n$$R = 80\\,\\text{KiB}$$\n\n### 步骤 4：计算比率\n现在我们计算比率 $R/R_{\\text{full}}$。\n$$\\frac{R}{R_{\\text{full}}} = \\frac{80\\,\\text{KiB}}{330\\,\\text{KiB}} = \\frac{8}{33}$$\n将分数转换为小数：\n$$\\frac{8}{33} \\approx 0.242424...$$\n四舍五入到四位有效数字，我们得到 $0.2424$。",
            "answer": "$$\n\\boxed{0.2424}\n$$"
        },
        {
            "introduction": "内存紧缩可能会导致明显的系统暂停，因为大量数据需要一次性移动。为了解决这个问题，现实世界的系统通常采用增量紧缩，将工作分散到多个时间片中。这最后一个练习  从简单的计算转向算法设计，要求你设计一个在每“滴答”（tick）预算内运行的增量紧缩策略。你将分析其最坏情况下的性能，从而培养在高级系统设计中至关重要的算法思维和复杂度分析能力。",
            "id": "3626092",
            "problem": "考虑一个由可变大小分配器管理的、大小为 $M$ 字节的连续主存。在时间 $t=0$ 时，存在外部碎片：总空闲内存为 $S$ 字节，但它分散在 $k$ 个不相交的空闲洞中，大小分别为 $\\{s_1,\\dots,s_k\\}$，且满足 $\\sum_{i=1}^{k} s_i = S$。剩余的 $A = M - S$ 字节被不同大小的已分配块占用。系统实现增量式紧凑：在每个调度时钟周期内，紧凑子系统最多可以移动 $c$ 字节的已分配数据。“移动”指将这些字节复制到新地址并更新任何相应的元数据，以使系统在时钟周期之间保持一致和运行安全。\n\n从以下两个基本定义出发：(i) 外部碎片是空闲内存以多个不连续的洞形式存在的状态，以及 (ii) 紧凑是移动已分配块以消除这些洞，从而形成一个连续空闲区域的过程。请设计一个增量式紧凑算法，该算法遵守每时钟周期最多移动 $c$ 字节的预算，并保证在内存的一端产生一个大小为 $S$ 的单一连续空闲块。清晰地陈述您的算法为保证安全性和进展所维护的不变量。然后，推导当初始空闲内存 $S$ 分散在 $k$ 个洞中时，您的算法为实现一个大小为 $S$ 的单一空闲块所需的最坏情况下的时钟周期数，记为 $T_{\\text{inc}}(M,c)$。将 $T_{\\text{inc}}(M,c)$ 表示为关于 $M$、$S$ 和 $c$ 的闭式解析表达式。您可以假设指针修复和元数据更新的执行时间为每移动字节 $O(1)$，且其成本远小于复制成本；当源和目标范围可能重叠时，复制操作能安全执行（例如，通过选择正确的复制方向或使用缓冲区）；并且分配器将接受在选定端产生的单一空闲块。无需对额外的硬件约束进行建模。提供您关于 $T_{\\text{inc}}(M,c)$ 的最终表达式；不需要四舍五入，最终表达式框中也不应包含单位。",
            "solution": "### 问题验证\n该问题要求设计一个增量式紧凑算法并分析其最坏情况性能。问题陈述清晰，提供了所有必要的定义（内存模型、碎片、增量式紧凑约束）。它是一个标准的、有科学依据的算法设计和分析问题。问题是客观的，不包含矛盾。我们将继续进行求解。\n\n### 算法设计与不变量\n我们的目标是将所有已分配的内存块移动到内存的一端（不失一般性，我们选择低地址端），从而在另一端（高地址端）创建一个大小为 $S$ 的单一连续空闲块。最终，所有 $A = M - S$ 字节的已分配数据将占据地址区间 $[0, A)$。\n\n**算法（双指针法）：**\n我们使用两个指针：\n1.  **目标指针 (`dest`)**: 指向下一个已分配块应该被移动到的位置。它从地址 $0$ 开始。\n2.  **源指针 (`src`)**: 扫描整个内存，寻找已分配的块。它也从地址 $0$ 开始。\n\n算法步骤如下：\n1.  初始化 `dest = 0` 和 `src = 0`。\n2.  当 `src  M` 时，循环执行：\n    a. 如果 `src` 指向一个空闲块，则将 `src` 指针跳过该空闲块。\n    b. 如果 `src` 指向一个已分配块，并且 `src` 不等于 `dest`，则将该已分配块从 `src` 处移动到 `dest` 处。\n        - 这个移动操作是增量的。在一个时钟周期内，我们从源块复制最多 $c$ 字节到目标位置。如果块的大小大于 $c$，这个移动将跨越多个时钟周期。\n    c. 移动完一个完整的已分配块后，将 `dest` 和 `src` 都增加该块的大小。如果 `src` 等于 `dest`（即一个已分配块已经在其最终位置），则只需将两个指针都增加该块的大小，无需移动。\n3.  算法在 `src` 到达内存末尾时终止。\n\n**不变量：**\n为了保证算法的安全性和正确性，我们维护以下不变量：\n- 在任何时候，地址区间 `[0, dest)` 只包含已经处于其最终紧凑位置的已分配数据。\n- 地址区间 `[dest, src)` 是一个空闲区域，是已被处理并合并的空闲空间。\n- 地址区间 `[src, M)` 是尚未处理的内存区域，保持其原始布局。\n- 每次只移动一个块的一部分（最多 $c$ 字节）时，系统必须确保在此期间对该块的访问被正确处理（例如，通过临时阻塞进程或使用重定向），以保持一致性。\n\n### 最坏情况分析\n**总移动数据量：**\n紧凑过程的目标是将所有 $A = M - S$ 字节的已分配数据放入连续的内存区域 $[0, A)$。在最坏的情况下，没有任何一个已分配的块已经位于其最终的目标位置。这种情况发生在每个已分配块之前都存在空闲空间，例如，内存布局以一个空闲洞开始。在这种情况下，每个已分配的字节都必须被移动。因此，需要移动的总数据量等于所有已分配内存的总大小。\n总移动字节数 (最坏情况) = $A = M - S$。\n\n**所需时钟周期数：**\n系统在每个时钟周期内最多可以移动 $c$ 字节的数据。为了移动总共 $A$ 字节的数据，所需的时钟周期数是总数据量除以每周期的数据移动速率。因为我们不能在一个周期内完成超过一个周期的工作，所以我们需要取结果的向上取整（ceiling）。\n$$T_{\\text{inc}}(M,c) = \\left\\lceil \\frac{\\text{总移动字节数}}{\\text{每周期移动字节数}} \\right\\rceil$$\n将最坏情况下的总移动数据量代入，我们得到：\n$$T_{\\text{inc}}(M,c) = \\left\\lceil \\frac{M - S}{c} \\right\\rceil$$\n这个表达式给出了完成紧凑所需的最坏情况下的时钟周期数。它只依赖于已分配内存的总量 ($M-S$) 和系统的移动能力 ($c$)，而与空闲洞的数量 $k$ 或其具体分布无关，因为最坏情况已经假设了所有已分配数据都需要移动。",
            "answer": "$$\\boxed{\\left\\lceil\\frac{M-S}{c}\\right\\rceil}$$"
        }
    ]
}