{
    "hands_on_practices": [
        {
            "introduction": "Preemptive scheduling is a cornerstone of modern operating systems, but its benefits come at a price. Every context switch consumes precious CPU cycles that could have been used for productive work. This exercise  provides a clear, analytical model to quantify this overhead, helping you understand the fundamental trade-off between responsiveness and efficiency in Round Robin scheduling. By deriving the throughput degradation, you will gain insight into how real-world system performance is directly impacted by the choice of scheduling parameters like the time quantum.",
            "id": "3630101",
            "problem": "Consider a single-core Central Processing Unit (CPU) executing a large stream of identical, purely CPU-bound jobs under Round Robin (RR) scheduling. Each job requires a total of $C$ units of CPU service to complete, with $C \\gg q$, where $q$ is the RR time slice (quantum). The dispatcher incurs an average context switch overhead of $d$ units of CPU time at each preemption and dispatch, during which no useful job computation occurs. Assume there are always at least $2$ ready jobs so that a context switch occurs at every quantum expiration, the CPU is never idle, and boundary effects at job start and completion are negligible in the long-run average.\n\nLet $X(q,d)$ denote the long-run throughput, defined as the limit of completed jobs per unit time, and let $X_{\\text{ideal}}$ denote the ideal throughput on the same CPU if there were no context-switching overhead and no preemption overhead. Define the multiplicative throughput degradation factor as $D(q,d) = \\frac{X(q,d)}{X_{\\text{ideal}}}$.\n\nStarting only from the definitions of throughput and time accounting for useful work versus overhead under RR scheduling and dispatching, derive $D(q,d)$ and then evaluate it when $q=d$. Provide your final answer as a single exact value for $D(q,d)$ when $q=d$. No rounding is required, and no units should be included in the final answer. Express the final value as a simplified exact fraction.",
            "solution": "The problem statement is first validated for scientific soundness, self-consistency, and clarity.\n\n**Step 1: Extract Givens**\n- Scheduling algorithm: Round Robin (RR).\n- CPU: Single-core.\n- Job characteristics: Identical, purely CPU-bound.\n- Total CPU service time required per job: $C$.\n- Time slice (quantum): $q$.\n- Condition on service time and quantum: $C \\gg q$.\n- Context switch overhead per preemption: $d$.\n- System state: Always at least $2$ ready jobs, ensuring the CPU is never idle and a context switch occurs at the end of every time slice.\n- Simplifying assumption: Boundary effects at job start and completion are negligible in the long-run average.\n- Definition of long-run throughput: $X(q,d)$ is the limit of completed jobs per unit time.\n- Definition of ideal throughput: $X_{\\text{ideal}}$ is the throughput on the same CPU if $d=0$ (no context-switching overhead).\n- Definition of throughput degradation factor: $D(q,d) = \\frac{X(q,d)}{X_{\\text{ideal}}}$.\n- Task: Derive $D(q,d)$ and evaluate it for the case $q=d$.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is scientifically grounded, rooted in the fundamental principles of operating system CPU scheduling. It presents a standard, simplified model used to analyze the performance of the Round Robin algorithm. The terms used ($C$, $q$, $d$, throughput) are well-defined within computer science. The assumptions provided (e.g., $C \\gg q$, always ready jobs) are necessary to create a tractable analytical model for steady-state behavior, removing complexities of transient states and idle time. The problem is well-posed, objective, and self-contained, with no internal contradictions or missing information. It is a valid problem for analysis.\n\n**Step 3: Verdict and Action**\nThe problem is valid. A complete solution will be provided.\n\n**Derivation of the Solution**\n\nThe objective is to find the throughput degradation factor $D(q,d) = \\frac{X(q,d)}{X_{\\text{ideal}}}$. We begin by deriving expressions for the ideal throughput $X_{\\text{ideal}}$ and the actual throughput $X(q,d)$. Throughput is defined as the number of jobs completed per unit of time.\n\n**1. Ideal Throughput ($X_{\\text{ideal}}$)**\n\nIn the ideal case, there is no overhead from context switching, so $d=0$. The CPU spends $100\\%$ of its time performing useful computations for the jobs. Each job requires a total of $C$ units of CPU service time. Therefore, the time taken to complete one job is simply $C$.\n\nThe ideal throughput, $X_{\\text{ideal}}$, is the reciprocal of the time required to complete one job:\n$$X_{\\text{ideal}} = \\frac{1 \\text{ job}}{C \\text{ time units}} = \\frac{1}{C}$$\n\n**2. Actual Throughput ($X(q,d)$)**\n\nUnder Round Robin scheduling with context-switch overhead, the CPU's time is divided between useful work and overhead. The problem states that a context switch occurs after every time slice.\n\nA single cycle of operation consists of:\n- One time slice of useful computation, of duration $q$.\n- One context switch, of duration $d$.\n\nThe total duration of one such cycle is $T_{\\text{cycle}} = q + d$.\n\nDuring this cycle of total time $q+d$, only a duration of $q$ is spent performing useful work. The fraction of total time that the CPU spends on useful computation is its efficiency, $\\eta$:\n$$\\eta = \\frac{\\text{Useful time}}{\\text{Total time}} = \\frac{q}{q+d}$$\n\nTo complete a single job, a total of $C$ units of useful CPU service must be provided. Since the CPU is only effectively available for useful work for a fraction $\\eta$ of the time, the total (wall-clock) time required to provide $C$ units of service is:\n$$T_{\\text{job}} = \\frac{C}{\\eta} = \\frac{C}{\\frac{q}{q+d}} = C \\frac{q+d}{q}$$\n\nThe actual long-run throughput, $X(q,d)$, is the reciprocal of this total time per job:\n$$X(q,d) = \\frac{1}{T_{\\text{job}}} = \\frac{1}{C \\frac{q+d}{q}} = \\frac{q}{C(q+d)}$$\n\n**3. Throughput Degradation Factor ($D(q,d)$)**\n\nNow we can compute the degradation factor using its definition:\n$$D(q,d) = \\frac{X(q,d)}{X_{\\text{ideal}}}$$\nSubstituting the expressions for $X(q,d)$ and $X_{\\text{ideal}}$:\n$$D(q,d) = \\frac{\\frac{q}{C(q+d)}}{\\frac{1}{C}}$$\n$$D(q,d) = \\frac{q}{C(q+d)} \\cdot \\frac{C}{1} = \\frac{q}{q+d}$$\nThis result is intuitive: the throughput is degraded by a factor equal to the fraction of time the CPU is doing useful work.\n\n**4. Evaluation for $q=d$**\n\nThe problem asks for the value of $D(q,d)$ when the quantum $q$ is equal to the context-switch overhead $d$. We substitute $d=q$ into our expression for $D(q,d)$:\n$$D(q,q) = \\frac{q}{q+q} = \\frac{q}{2q}$$\nSince $q$ is a time quantum, it must be a positive duration ($q > 0$). We can therefore cancel $q$ from the numerator and denominator:\n$$D(q,q) = \\frac{1}{2}$$\n\nThus, when the context switch overhead is equal to the time slice duration, the CPU spends half its time on useful work and half on overhead, resulting in a throughput that is exactly half of the ideal throughput.",
            "answer": "$$\\boxed{\\frac{1}{2}}$$"
        },
        {
            "introduction": "The choice of a CPU scheduling algorithm is a critical design decision that directly influences system performance and user experience. Different algorithms prioritize different goals, and their effectiveness can vary depending on the workload. This practice problem  offers a concrete, hands-on opportunity to simulate and contrast two foundational scheduling policies: the simple First-Come First-Served (FCFS) and the optimal-but-clairvoyant Shortest-Job-First (SJF). By meticulously tracing job execution and calculating performance metrics like slowdown, you will see firsthand why SJF is a crucial theoretical benchmark and how scheduling choices can dramatically alter system efficiency.",
            "id": "3630106",
            "problem": "A uniprocessor Central Processing Unit (CPU) executes a mixed workload of six independent jobs with arbitrary arrivals. Dispatch and context-switch overheads are negligible (assume zero). The ready queue is managed either by First-Come First-Served (FCFS) or by non-preemptive Shortest Job First (SJF). For FCFS, ties among jobs that arrive at the same time are broken by increasing job index. For SJF, when the CPU becomes idle, the scheduler selects the available job with the smallest service time; ties are broken first by earliest arrival time and then by increasing job index. If the ready queue is empty, the CPU remains idle until the next arrival. All times are measured in milliseconds. For each job $J_i$, let arrival time be $a_i$, service time (CPU burst) be $s_i$, start time be $b_i$, finish time be $f_i$, completion time (turnaround time) be $c_i = f_i - a_i$, and slowdown be $S_i = \\frac{c_i}{s_i}$.\n\nThe workload is:\n- Job $J_1$: $a_1 = 0$, $s_1 = 8$.\n- Job $J_2$: $a_2 = 0$, $s_2 = 3$.\n- Job $J_3$: $a_3 = 0$, $s_3 = 1$.\n- Job $J_4$: $a_4 = 2$, $s_4 = 9$.\n- Job $J_5$: $a_5 = 3$, $s_5 = 2$.\n- Job $J_6$: $a_6 = 6$, $s_6 = 5$.\n\nUsing only the definitions above and the scheduling rules, determine the arithmetic mean slowdown under FCFS, denoted $\\overline{S}_{\\mathrm{FCFS}}$, and the arithmetic mean slowdown under SJF, denoted $\\overline{S}_{\\mathrm{SJF}}$. Then compute the ratio\n$$R \\equiv \\frac{\\overline{S}_{\\mathrm{FCFS}}}{\\overline{S}_{\\mathrm{SJF}}}.$$\nReport only $R$ as a pure number, rounded to four significant figures.",
            "solution": "The problem statement is scrutinized and found to be valid. It is a well-posed problem from the field of operating systems, specifically CPU scheduling. It provides a complete set of data for six jobs, defines two scheduling algorithms (First-Come First-Served and non-preemptive Shortest Job First) with explicit tie-breaking rules, and specifies all necessary performance metrics. There are no scientific inconsistencies, contradictions, or ambiguities. We may therefore proceed with the solution.\n\nThe problem requires the calculation of the arithmetic mean slowdown for two different scheduling policies and their ratio. The definitions given are:\n- Arrival time: $a_i$\n- Service time: $s_i$\n- Finish time: $f_i$\n- Completion (turnaround) time: $c_i = f_i - a_i$\n- Slowdown: $S_i = \\frac{c_i}{s_i}$\n- Mean slowdown: $\\overline{S} = \\frac{1}{N} \\sum_{i=1}^{N} S_i$, where $N=6$.\n\nThe workload consists of $6$ jobs, $J_1$ through $J_6$:\n- $J_1: a_1=0, s_1=8$\n- $J_2: a_2=0, s_2=3$\n- $J_3: a_3=0, s_3=1$\n- $J_4: a_4=2, s_4=9$\n- $J_5: a_5=3, s_5=2$\n- $J_6: a_6=6, s_6=5$\n\n**Part 1: Analysis under First-Come First-Served (FCFS) Scheduling**\n\nUnder FCFS, jobs are processed in the order of their arrival. For jobs arriving simultaneously, the tie is broken by increasing job index.\n- At time $t=0$, jobs $J_1$, $J_2$, and $J_3$ arrive. The ready queue, ordered by job index, is ($J_1, J_2, J_3$).\n- The CPU starts processing $J_1$ at $t=0$. It runs for $s_1 = 8$ units.\n- Finish time for $J_1$ is $f_1 = 0 + 8 = 8$.\n- At $t=8$, the CPU becomes free. The ready queue contains all other jobs, as they have all arrived by this time. The FCFS order (based on original arrival times and job indices) is ($J_2, J_3, J_4, J_5, J_6$).\n- The CPU starts processing $J_2$ at $t=8$. It runs for $s_2 = 3$ units.\n- Finish time for $J_2$ is $f_2 = 8 + 3 = 11$.\n- The CPU starts processing $J_3$ at $t=11$. It runs for $s_3 = 1$ unit.\n- Finish time for $J_3$ is $f_3 = 11 + 1 = 12$.\n- The CPU starts processing $J_4$ at $t=12$. It runs for $s_4 = 9$ units.\n- Finish time for $J_4$ is $f_4 = 12 + 9 = 21$.\n- The CPU starts processing $J_5$ at $t=21$. It runs for $s_5 = 2$ units.\n- Finish time for $J_5$ is $f_5 = 21 + 2 = 23$.\n- The CPU starts processing $J_6$ at $t=23$. It runs for $s_6 = 5$ units.\n- Finish time for $J_6$ is $f_6 = 23 + 5 = 28$.\n\nNow, we calculate the completion time $c_i$ and slowdown $S_i$ for each job.\n- $J_1$: $c_1 = f_1 - a_1 = 8 - 0 = 8$. $S_1 = c_1/s_1 = 8/8 = 1$.\n- $J_2$: $c_2 = f_2 - a_2 = 11 - 0 = 11$. $S_2 = c_2/s_2 = 11/3$.\n- $J_3$: $c_3 = f_3 - a_3 = 12 - 0 = 12$. $S_3 = c_3/s_3 = 12/1 = 12$.\n- $J_4$: $c_4 = f_4 - a_4 = 21 - 2 = 19$. $S_4 = c_4/s_4 = 19/9$.\n- $J_5$: $c_5 = f_5 - a_5 = 23 - 3 = 20$. $S_5 = c_5/s_5 = 20/2 = 10$.\n- $J_6$: $c_6 = f_6 - a_6 = 28 - 6 = 22$. $S_6 = c_6/s_6 = 22/5$.\n\nThe arithmetic mean slowdown for FCFS is:\n$$ \\overline{S}_{\\mathrm{FCFS}} = \\frac{1}{6} \\sum_{i=1}^{6} S_i = \\frac{1}{6} \\left(1 + \\frac{11}{3} + 12 + \\frac{19}{9} + 10 + \\frac{22}{5}\\right) $$\n$$ \\overline{S}_{\\mathrm{FCFS}} = \\frac{1}{6} \\left(23 + \\frac{11}{3} + \\frac{19}{9} + \\frac{22}{5}\\right) $$\nTo sum the fractions, we find a common denominator of $45$:\n$$ \\overline{S}_{\\mathrm{FCFS}} = \\frac{1}{6} \\left(\\frac{23 \\cdot 45}{45} + \\frac{11 \\cdot 15}{45} + \\frac{19 \\cdot 5}{45} + \\frac{22 \\cdot 9}{45}\\right) $$\n$$ \\overline{S}_{\\mathrm{FCFS}} = \\frac{1}{6} \\left(\\frac{1035 + 165 + 95 + 198}{45}\\right) = \\frac{1}{6} \\left(\\frac{1493}{45}\\right) = \\frac{1493}{270} $$\n\n**Part 2: Analysis under Non-preemptive Shortest Job First (SJF) Scheduling**\n\nUnder non-preemptive SJF, when the CPU becomes idle, it selects the available job with the smallest service time. Ties are broken first by earliest arrival time, and then by increasing job index.\n\n- At $t=0$, the CPU is idle. The ready queue contains $J_1(s_1=8, a_1=0)$, $J_2(s_2=3, a_2=0)$, and $J_3(s_3=1, a_3=0)$. Based on the shortest service time, $J_3$ is selected.\n- $J_3$ starts at $t=0$ and runs for $s_3=1$. Finish time $f_3 = 1$.\n- At $t=1$, the CPU is idle. The ready queue contains $J_1(s_1=8, a_1=0)$ and $J_2(s_2=3, a_2=0)$. Shortest is $J_2$.\n- $J_2$ starts at $t=1$ and runs for $s_2=3$. Finish time $f_2 = 1+3=4$. During its execution, $J_4(a_4=2, s_4=9)$ and $J_5(a_5=3, s_5=2)$ arrive.\n- At $t=4$, the CPU is idle. The ready queue contains $J_1(s_1=8, a_1=0)$, $J_4(s_4=9, a_4=2)$, and $J_5(s_5=2, a_5=3)$. Shortest is $J_5$.\n- $J_5$ starts at $t=4$ and runs for $s_5=2$. Finish time $f_5 = 4+2=6$. During its execution, $J_6(a_6=6, s_6=5)$ arrives at the moment of completion.\n- At $t=6$, the CPU is idle. The ready queue contains $J_1(s_1=8, a_1=0)$, $J_4(s_4=9, a_4=2)$, and $J_6(s_6=5, a_6=6)$. Shortest is $J_6$.\n- $J_6$ starts at $t=6$ and runs for $s_6=5$. Finish time $f_6 = 6+5=11$.\n- At $t=11$, the CPU is idle. The ready queue contains $J_1(s_1=8, a_1=0)$ and $J_4(s_4=9, a_4=2)$. Shortest is $J_1$.\n- $J_1$ starts at $t=11$ and runs for $s_1=8$. Finish time $f_1 = 11+8=19$.\n- At $t=19$, the CPU is idle. The only job left is $J_4$.\n- $J_4$ starts at $t=19$ and runs for $s_4=9$. Finish time $f_4 = 19+9=28$.\n\nNow, we calculate the completion time $c_i$ and slowdown $S_i$ for each job under SJF.\n- $J_1$: $c_1 = f_1 - a_1 = 19 - 0 = 19$. $S_1 = c_1/s_1 = 19/8$.\n- $J_2$: $c_2 = f_2 - a_2 = 4 - 0 = 4$. $S_2 = c_2/s_2 = 4/3$.\n- $J_3$: $c_3 = f_3 - a_3 = 1 - 0 = 1$. $S_3 = c_3/s_3 = 1/1 = 1$.\n- $J_4$: $c_4 = f_4 - a_4 = 28 - 2 = 26$. $S_4 = c_4/s_4 = 26/9$.\n- $J_5$: $c_5 = f_5 - a_5 = 6 - 3 = 3$. $S_5 = c_5/s_5 = 3/2$.\n- $J_6$: $c_6 = f_6 - a_6 = 11 - 6 = 5$. $S_6 = c_6/s_6 = 5/5 = 1$.\n\nThe arithmetic mean slowdown for SJF is:\n$$ \\overline{S}_{\\mathrm{SJF}} = \\frac{1}{6} \\sum_{i=1}^{6} S_i = \\frac{1}{6} \\left(\\frac{19}{8} + \\frac{4}{3} + 1 + \\frac{26}{9} + \\frac{3}{2} + 1\\right) $$\n$$ \\overline{S}_{\\mathrm{SJF}} = \\frac{1}{6} \\left(2 + \\frac{19}{8} + \\frac{4}{3} + \\frac{26}{9} + \\frac{3}{2}\\right) $$\nTo sum the fractions, we find a common denominator of $72$:\n$$ \\overline{S}_{\\mathrm{SJF}} = \\frac{1}{6} \\left(\\frac{2 \\cdot 72}{72} + \\frac{19 \\cdot 9}{72} + \\frac{4 \\cdot 24}{72} + \\frac{26 \\cdot 8}{72} + \\frac{3 \\cdot 36}{72}\\right) $$\n$$ \\overline{S}_{\\mathrm{SJF}} = \\frac{1}{6} \\left(\\frac{144 + 171 + 96 + 208 + 108}{72}\\right) = \\frac{1}{6} \\left(\\frac{727}{72}\\right) = \\frac{727}{432} $$\n\n**Part 3: Calculation of the Ratio R**\n\nThe final step is to compute the ratio $R \\equiv \\frac{\\overline{S}_{\\mathrm{FCFS}}}{\\overline{S}_{\\mathrm{SJF}}}$.\n$$ R = \\frac{1493/270}{727/432} = \\frac{1493}{270} \\times \\frac{432}{727} $$\nWe can simplify the fraction $\\frac{432}{270}$:\n$$ \\frac{432}{270} = \\frac{432 \\div 54}{270 \\div 54} = \\frac{8}{5} $$\nSo the ratio becomes:\n$$ R = \\frac{1493}{727} \\times \\frac{8}{5} = \\frac{11944}{3635} $$\nNow, we compute the numerical value and round to four significant figures:\n$$ R \\approx 3.285832187... $$\nRounding to four significant figures yields $3.286$.",
            "answer": "$$\\boxed{3.286}$$"
        },
        {
            "introduction": "Static priority scheduling can lead to starvation, where low-priority tasks are indefinitely neglected. A common solution is \"aging,\" which dynamically boosts the priority of waiting tasks. However, this fix introduces a new design challenge: if priorities increase too quickly, the scheduler loses its ability to differentiate between tasks, but if they increase too slowly, starvation persists. This problem  places you in the role of an OS designer, tasking you with finding the precise \"sweet spot\" for the aging rate, $\\alpha$. By balancing the conflicting goals of preventing starvation and preserving meaningful priority levels, you will practice the kind of constrained optimization that is central to systems engineering.",
            "id": "3630147",
            "problem": "A single-processor operating system uses priority-based, preemptive scheduling for the Central Processing Unit (CPU). Each ready (not running) task has a dynamic priority that starts at its base priority and increases via aging by a fixed increment per scheduler tick. Specifically, at each scheduler tick, every task in the ready queue increases its dynamic priority by $\\alpha$ (units: priority points per tick), capped at a maximum priority $P_{\\max}$. The scheduler always dispatches the ready task with the highest dynamic priority; ties are broken by First-In First-Out (FIFO). Assume preemption and dispatch decisions may occur only at tick boundaries. Aging applies only to waiting tasks; running tasks do not age while executing.\n\nTo prevent starvation under worst-case load, the system designers impose that any task with base priority $p_{L}$ must receive CPU time within at most $W_{\\max}$ ticks, even if a continuous stream of tasks with base priority $p_{H}$ keeps arriving. Under this requirement, it is sufficient to ensure that the low-priority taskâ€™s dynamic priority can reach at least $p_{H}$ within $W_{\\max}$ ticks of waiting.\n\nTo preserve scheduler stability, the designers also impose that priorities must not collapse too quickly. Concretely, they require that a task beginning at a low base priority $p_{\\min}$ must not reach the maximum priority $P_{\\max}$ in fewer than $T_{\\text{flat}}$ ticks of waiting. This constraint avoids homogenizing priorities so rapidly that the scheduler loses meaningful differentiation among tasks.\n\nGiven the following parameters:\n- Maximum priority $P_{\\max} = 100$,\n- High base priority $p_{H} = 80$,\n- Low base priority for the starvation constraint $p_{L} = 25$,\n- Starvation bound $W_{\\max} = 550$ ticks,\n- Low base priority for the collapse constraint $p_{\\min} = 10$,\n- Minimum flattening time $T_{\\text{flat}} = 450$ ticks,\n\nderive, from first principles of priority aging and scheduling, the permissible range for the aging rate $\\alpha$ that simultaneously prevents starvation and avoids collapsing priorities too quickly. Express your final answer as two numbers representing the lower and upper bounds of $\\alpha$ (in units of priority points per tick). No rounding is required; provide exact values. The final answer must be a calculation.",
            "solution": "The problem requires the derivation of a permissible range for the priority aging rate, $\\alpha$, based on two distinct constraints: one to prevent task starvation and another to prevent the rapid collapse of the priority hierarchy. We will analyze each constraint separately to establish a lower and an upper bound for $\\alpha$.\n\nThe fundamental principle is that the dynamic priority, $p_{dyn}(t)$, of a ready task with a base priority $p_{base}$ increases linearly with the time $t$ it has spent waiting in the ready queue. The aging rate $\\alpha$ is the constant of proportionality. This relationship can be expressed as:\n$$p_{dyn}(t) = p_{base} + \\alpha t$$\nThis increase is capped at a maximum priority, $P_{\\max}$. For our analysis, we will first consider the un-capped linear growth to find the time at which certain priority thresholds are met, and then ensure the logic is consistent with the cap.\n\nThe first constraint is designed to prevent starvation. It states that any task with a low base priority, $p_L$, must receive CPU time within a maximum waiting time of $W_{\\max}$ ticks. The problem specifies that a sufficient condition to meet this requirement is to ensure the task's dynamic priority reaches at least the high base priority level, $p_H$, within the $W_{\\max}$ window. This ensures that the low-priority task will eventually have a higher priority than any newly arriving high-priority tasks and will be scheduled.\n\nLet us formalize this condition. The dynamic priority of the low-priority task after waiting for a time $t$ is $p_L + \\alpha t$. To guarantee that it can be scheduled within $W_{\\max}$ ticks, its priority at time $t = W_{\\max}$ must be at least $p_H$. This gives us the inequality:\n$$p_L + \\alpha W_{\\max} \\ge p_H$$\nThis must hold for the minimum acceptable value of $\\alpha$ that prevents starvation. We can solve this inequality for $\\alpha$:\n$$\\alpha W_{\\max} \\ge p_H - p_L$$\n$$\\alpha \\ge \\frac{p_H - p_L}{W_{\\max}}$$\nThis inequality establishes the lower bound for the aging rate, $\\alpha_{min}$. Substituting the given parameter values:\n- High base priority for comparison, $p_H = 80$.\n- Low base priority for the starvation constraint, $p_L = 25$.\n- Maximum allowed waiting time, $W_{\\max} = 550$ ticks.\n\nWe calculate the minimum value for $\\alpha$:\n$$\\alpha_{min} = \\frac{80 - 25}{550} = \\frac{55}{550} = \\frac{1}{10}$$\nTherefore, to prevent starvation, the aging rate $\\alpha$ must be at least $\\frac{1}{10}$ priority points per tick.\n\nThe second constraint is designed to preserve meaningful differentiation in the priority system by preventing priorities from collapsing too quickly. It requires that a task starting at a very low base priority, $p_{min}$, must not reach the maximum system priority, $P_{max}$, in fewer than $T_{flat}$ ticks.\n\nLet $T_{climb}$ be the time it takes for a task with base priority $p_{min}$ to reach $P_{max}$. We can find this time by setting its dynamic priority equal to $P_{max}$:\n$$p_{min} + \\alpha T_{climb} = P_{max}$$\nSolving for $T_{climb}$:\n$$T_{climb} = \\frac{P_{max} - p_{min}}{\\alpha}$$\nThe constraint states that this time must be greater than or equal to $T_{flat}$:\n$$T_{climb} \\ge T_{flat}$$\nSubstituting our expression for $T_{climb}$:\n$$\\frac{P_{max} - p_{min}}{\\alpha} \\ge T_{flat}$$\nThis inequality will establish the upper bound for $\\alpha$. Since $\\alpha$ is a rate of increase, it is inherently positive ($\\alpha > 0$). We can safely rearrange the inequality to solve for $\\alpha$:\n$$P_{max} - p_{min} \\ge \\alpha T_{flat}$$\n$$\\alpha \\le \\frac{P_{max} - p_{min}}{T_{flat}}$$\nThis inequality establishes the upper bound for the aging rate, $\\alpha_{max}$. Substituting the given parameter values:\n- Maximum priority, $P_{max} = 100$.\n- Low base priority for the collapse constraint, $p_{min} = 10$.\n- Minimum time to flatten priorities, $T_{flat} = 450$ ticks.\n\nWe calculate the maximum value for $\\alpha$:\n$$\\alpha_{max} = \\frac{100 - 10}{450} = \\frac{90}{450} = \\frac{9}{45} = \\frac{1}{5}$$\nTherefore, to avoid rapid priority collapse, the aging rate $\\alpha$ must be no more than $\\frac{1}{5}$ priority points per tick.\n\nCombining both constraints, we find the permissible range for $\\alpha$:\n$$\\alpha_{min} \\le \\alpha \\le \\alpha_{max}$$\n$$\\frac{1}{10} \\le \\alpha \\le \\frac{1}{5}$$\nThe lower bound for $\\alpha$ is $\\frac{1}{10}$, and the upper bound is $\\frac{1}{5}$.",
            "answer": "$$\\boxed{\\begin{pmatrix} \\frac{1}{10} & \\frac{1}{5} \\end{pmatrix}}$$"
        }
    ]
}