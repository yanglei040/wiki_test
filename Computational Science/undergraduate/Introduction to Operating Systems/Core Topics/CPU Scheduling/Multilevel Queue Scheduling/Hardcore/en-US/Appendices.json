{
    "hands_on_practices": [
        {
            "introduction": "This first exercise establishes the most fundamental principle of multilevel scheduling: how the CPU resource is partitioned among different priority levels. By working through a hypothetical scenario with fixed budgets under heavy load, you will see how the work-conserving nature of the scheduler and its priority rules deterministically allocate service time . This forms the bedrock for analyzing more complex scheduler behaviors.",
            "id": "3660877",
            "problem": "An operating system deploys Multilevel Queue Scheduling (MLQS), with $3$ ready queues denoted $Q_0$ (highest priority), $Q_1$, and $Q_2$ (lowest priority). The dispatcher enforces long-term budget constraints on the top two queues: queue $Q_0$ has a budget $B_0$ and queue $Q_1$ has a budget $B_1$, where $0 < B_0 < 1$, $0 < B_1 < 1$, and $B_0 + B_1 < 1$. Assume the following foundational properties hold in steady state under heavy load (each queue always has a runnable thread):\n\n- The scheduler is work-conserving: the Central Processing Unit (CPU) is never intentionally idled when there is runnable work.\n- Budget constraints are strict caps: a saturated queue cannot exceed its budgeted long-run fraction of CPU time.\n- Starvation freedom is ensured by hierarchical donation: any capacity not used by a higher-priority queue is immediately available to lower-priority queues.\n\nLet $S_i$ denote the steady-state service fraction (long-run fraction of CPU time) received by queue $Q_i$. Using only the above properties and definitions, derive expressions for $S_0$, $S_1$, and $S_2$ in terms of $B_0$ and $B_1$. Express your final answer as a single row matrix containing $S_0$, $S_1$, and $S_2$, in simplest closed form. No rounding is required, and the service fractions are dimensionless.",
            "solution": "The problem is valid as it is scientifically grounded in the principles of operating system scheduling, is well-posed with a self-contained and consistent set of definitions and constraints, and is expressed in objective, formalizable language.\n\nLet $S_i$ denote the steady-state service fraction for queue $Q_i$, where $i \\in \\{0, 1, 2\\}$. The total available CPU time can be represented as a fraction of $1$. The \"work-conserving\" property states that the CPU is never idle if there is work to be done. The \"heavy load\" assumption guarantees that each queue always has a runnable thread. Combined, these two properties imply that the sum of the service fractions for all queues must equal the total available CPU time.\n$$S_0 + S_1 + S_2 = 1$$\nThis equation represents the complete allocation of CPU resources.\n\nWe proceed to determine the service fraction for each queue, starting with the one of highest priority, $Q_0$. Queue $Q_0$ has the highest priority and is saturated (always has work). The scheduler will thus always select a thread from $Q_0$ to run, subject to its budget. The problem states that the budget, $B_0$, is a \"strict cap\" on the long-run fraction of CPU time. Because $Q_0$ is saturated, it will fully utilize its allocated budget. Therefore, the steady-state service fraction for $Q_0$ is exactly its budget.\n$$S_0 = B_0$$\n\nNext, we analyze queue $Q_1$. It has lower priority than $Q_0$ but higher priority than $Q_2$. The CPU time available to queues other than $Q_0$ is the total time minus the time consumed by $Q_0$, which is $1 - S_0 = 1 - B_0$. The property of \"hierarchical donation\" ensures this remaining capacity is available to the lower-priority queues. As $Q_1$ has priority over $Q_2$, it has first claim to this capacity. Queue $Q_1$ is also saturated and will attempt to consume as much of this available time as possible. However, its consumption is capped by its own budget, $B_1$. Therefore, the service fraction $S_1$ is the minimum of the available capacity and its budget:\n$$S_1 = \\min(1 - B_0, B_1)$$\nThe problem provides the constraint $B_0 + B_1 < 1$. This inequality can be rearranged to $B_1 < 1 - B_0$. This shows that the budget of $Q_1$ is strictly less than the CPU capacity remaining after $Q_0$ has been serviced. Consequently, the limiting factor for $Q_1$ is its own budget, not the available capacity.\n$$S_1 = B_1$$\n\nFinally, we determine the service fraction for the lowest priority queue, $Q_2$. Since the scheduler is work-conserving and $Q_2$ is always runnable, it will receive all CPU time not consumed by the higher-priority queues $Q_0$ and $Q_1$. We use the initial resource allocation equation:\n$$S_0 + S_1 + S_2 = 1$$\nSubstituting the derived expressions for $S_0$ and $S_1$:\n$$B_0 + B_1 + S_2 = 1$$\nSolving for $S_2$ gives the remaining fraction of CPU time:\n$$S_2 = 1 - B_0 - B_1$$\nThe given condition $B_0 + B_1 < 1$ ensures that $S_2 > 0$, meaning the lowest-priority queue is not starved of CPU time, which is consistent with the problem's stated properties.\n\nThus, the steady-state service fractions are $S_0 = B_0$, $S_1 = B_1$, and $S_2 = 1 - B_0 - B_1$. These are to be expressed as a single row matrix.",
            "answer": "$$\\boxed{\\begin{pmatrix} B_0 & B_1 & 1 - B_0 - B_1 \\end{pmatrix}}$$"
        },
        {
            "introduction": "Building on the idea of resource allocation, this practice explores the performance impact of strict priority scheduling on low-priority tasks. You will derive a tight upper bound on the response time for a background task when a high-priority, periodic workload is present . This exercise is crucial for understanding why multilevel queues can degrade responsiveness for certain tasks and highlights the concept of preemption-induced delays.",
            "id": "3660837",
            "problem": "A uniprocessor operating system uses a strict preemptive multilevel queue scheduler with three queues: $Q_0$ (highest priority), $Q_1$ (middle priority), and $Q_2$ (lowest priority). The Central Processing Unit (CPU) always runs a ready task from the nonempty highest-priority queue, preempting any task from a lower-priority queue. Context-switch and dispatch latencies are negligible.\n\nQueue $Q_0$ hosts a periodic workload with period $P$ and duty cycle $d$, where $0<d<1$. By definition of duty cycle, in every interval of length $P$, the $Q_0$ workload executes for exactly $dP$ units of time and is idle for exactly $(1-d)P$ units of time. Assume that within each period this $dP$ execution occurs as a single contiguous busy interval (fixed phase across periods), and that these periods repeat indefinitely. Queue $Q_1$ is empty at all times.\n\nA single task $\\tau$ arrives to $Q_2$ at an arbitrary time instant $t_0$ with no other tasks present in $Q_2$ at arrival. Queue $Q_2$ is scheduled First-Come, First-Served (FCFS). Define the time to first response of $\\tau$ as the elapsed time from its arrival at $t_0$ until the instant when the CPU first begins executing $\\tau$.\n\nUsing only the core definitions of strict preemptive priority scheduling and the given periodic on-off characterization of $Q_0$, derive a tight worst-case upper bound on the time to first response of $\\tau$ over all possible arrival phases of $t_0$ relative to the $Q_0$ workload. Express your final answer as a single closed-form expression in terms of $P$ and $d$. Do not substitute numerical values and do not round. State the bound as a time quantity (seconds) in your reasoning, but provide the final boxed answer without units.",
            "solution": "We begin from the fundamental definitions:\n\n- Under strict preemptive priority scheduling with queues $Q_0 \\succ Q_1 \\succ Q_2$, the CPU is available to $Q_2$ if and only if both $Q_0$ and $Q_1$ are idle. Since $Q_1$ is empty by assumption, availability to $Q_2$ is equivalent to $Q_0$ being idle.\n\n- A periodic workload with period $P$ and duty cycle $d$ that executes a contiguous busy interval of length $dP$ each period (with fixed phase across periods) induces a repeating pattern on the time axis: for each integer $n$, there exists a busy interval\n  $$ I_n = [nP + \\phi,\\; nP + \\phi + dP) $$\n  for some fixed phase $\\phi \\in [0,P)$, during which $Q_0$ executes and preempts $Q_2$. Between successive busy intervals $I_n$ and $I_{n+1}$, $Q_0$ is idle for exactly $(1-d)P$ time units.\n\nLet $t_0$ denote the arrival time of the $Q_2$ task $\\tau$. Define the earliest time $\\Delta(t_0) \\ge 0$ until $\\tau$ can first execute as the minimal nonnegative offset such that $t_0 + \\Delta(t_0)$ does not lie in any $Q_0$ busy interval:\n$$ \\Delta(t_0) \\equiv \\inf \\{ \\Delta \\ge 0 \\mid t_0 + \\Delta \\notin \\bigcup_{n \\in \\mathbb{Z}} I_n \\}. $$\nBecause $Q_1$ is empty and there is no other $Q_2$ backlog at arrival, $\\tau$ will be dispatched immediately when $Q_0$ becomes idle. Therefore, the time to first response of $\\tau$ equals $\\Delta(t_0)$.\n\nWe now bound $\\Delta(t_0)$ uniformly over all arrival phases $t_0$ with respect to the periodic structure of $\\{I_n\\}_{n \\in \\mathbb{Z}}$.\n\nKey structural facts derived from the periodic on-off model:\n\n- Each busy interval $I_n$ has length $|I_n| = dP$.\n- Consecutive busy intervals are separated by an idle gap of length $(1-d)P$:\n  $$ \\text{gap}(I_n, I_{n+1}) = (n+1)P + \\phi - \\big(nP + \\phi + dP\\big) = P - dP = (1-d)P. $$\n- Consequently, no two busy intervals are adjacent; every busy interval is followed by an idle interval of fixed length $(1-d)P$.\n\nConsider two cases for the arrival time $t_0$:\n\n1. $t_0 \\notin \\bigcup_{n} I_n$ (arrival during an idle interval). Then $\\Delta(t_0) = 0$ because the CPU is immediately available to $Q_2$.\n\n2. $t_0 \\in I_k$ for some $k$ (arrival during a busy interval). Since $I_k$ is a contiguous interval of length $dP$, the remaining time until the end of $I_k$ is\n   $$ r(t_0) = \\big(nP + \\phi + dP\\big) - t_0 \\in (0, dP]. $$\n   The first instant when the CPU becomes available to $Q_2$ is precisely at the end of $I_k$, because the subsequent segment is an idle interval of length $(1-d)P$. Therefore,\n   $$ \\Delta(t_0) = r(t_0) \\le dP. $$\n\nCombining both cases yields the uniform bound\n$$ \\Delta(t_0) \\le dP. $$\n\nTightness: This bound is tight because there exists an arrival phase achieving equality. Choose $t_0 = nP + \\phi$ for any integer $n$, i.e., the arrival coincides with the start of a busy interval $I_n$. Then $r(t_0) = dP$, so $\\Delta(t_0) = dP$.\n\nHence, the tight worst-case upper bound on the time to first response of $\\tau$ is\n$$ dP. $$\n\nThis bound is expressed in time units (e.g., seconds) when $P$ is in seconds and $d$ is dimensionless. The final expression is provided in closed form in terms of $P$ and $d$ as required.",
            "answer": "$$\\boxed{dP}$$"
        },
        {
            "introduction": "Real-world systems need schedulers that can adapt to a process's changing behavior, promoting interactive tasks and demoting CPU-bound ones. This practice moves into the realm of dynamic policy design, challenging you to evaluate heuristics that prevent \"oscillation\"—rapid, unstable re-classification of tasks . Understanding mechanisms like hysteresis is key to building robust, fair, and efficient schedulers that perform well under mixed workloads.",
            "id": "3660873",
            "problem": "A computer system uses multilevel queue scheduling with two highest-priority queues: $Q_0$ (interactive) and $Q_1$ (batch). The scheduler enforces strict priority among queues: whenever $Q_0$ is nonempty, only $Q_0$ is scheduled; $Q_1$ runs only when $Q_0$ is empty. Each queue uses round-robin with its own time quantum: $Q_0$ has time quantum $q_0$ and $Q_1$ has time quantum $q_1$, with $q_0 \\ll q_1$. Newly created tasks enter $Q_1$ by default. A process alternates between Central Processing Unit (CPU) bursts and Input/Output (I/O) waits; interactive tasks tend to have short CPU bursts followed by I/O, while CPU-bound tasks have long CPU bursts with infrequent I/O. A voluntary yield indicates a process gave up the CPU before exhausting its time quantum, typically to initiate I/O. These are standard, widely observed facts that underlie scheduling design.\n\nConsider a task $P$ that currently resides in $Q_1$. Measurements show that in steady state: for most of its activity, $P$ voluntarily yields after short CPU bursts of about $b_\\text{short} \\approx 3\\,\\mathrm{ms}$, occurring frequently (e.g., $8$ out of $10$ recent bursts); however, approximately once every $60\\,\\mathrm{s}$, $P$ enters a CPU-intensive phase in which it executes a CPU burst around $b_\\text{long} \\approx 25\\,\\mathrm{ms}$. The system parameters are $q_0 = 5\\,\\mathrm{ms}$ and $q_1 = 20\\,\\mathrm{ms}$.\n\nYou are asked to decide whether $P$ should typically be placed in $Q_0$ and, more importantly, to choose a promotion/demotion heuristic with hysteresis that avoids oscillation between $Q_0$ and $Q_1$ based on momentary behavior. Oscillation here means frequent promotions and demotions due to transient short-term changes, which can harm fairness and responsiveness.\n\nSelect all options that implement a principled hysteresis-based policy that (i) promotes $P$ to $Q_0$ when its behavior is sustainedly interactive, (ii) demotes $P$ back to $Q_1$ only after sustained CPU-bound behavior, and (iii) reduces oscillations via explicit hysteresis mechanisms (such as separated thresholds or minimum residence/cool-down times), while preserving strict priority and avoiding starvation of $Q_1$ tasks.\n\nA. Promote any process to $Q_0$ as soon as it exhibits $k=2$ consecutive voluntary yields before consuming $0.5\\,q_1$ each time while in $Q_1$. Demote any process from $Q_0$ to $Q_1$ immediately after any single CPU burst in which it consumes more than $0.6\\,q_0$ without yielding. No additional timing restrictions apply.\n\nB. Maintain an exponentially weighted moving average (EWMA) $\\hat{b}$ of each process’s recent CPU-burst length using $\\hat{b} \\leftarrow \\alpha\\,b_\\text{new} + (1-\\alpha)\\,\\hat{b}$ with $\\alpha = 0.2$. Use two separated thresholds relative to $q_1$: $T_\\text{up} = 0.4\\,q_1$ and $T_\\text{down} = 0.8\\,q_1$, with $T_\\text{up} < T_\\text{down}$. Promote from $Q_1$ to $Q_0$ when $\\hat{b} < T_\\text{up}$ for $M=3$ consecutive bursts; demote from $Q_0$ to $Q_1$ when $\\hat{b} > T_\\text{down}$ for $N=3$ consecutive bursts. After any queue change, enforce a cool-down window of $W = 1\\,\\mathrm{s}$ during which further promotions/demotions for that process are suppressed.\n\nC. Use global CPU utilization as the only signal: when system-wide CPU utilization drops below $50\\%$, promote all $Q_1$ processes to $Q_0$; when it rises above $50\\%$, demote all $Q_0$ processes to $Q_1$. No per-process history is tracked.\n\nD. Keep $P$ permanently in $Q_1$ but halve its time quantum there to $q_1/2$ to emulate interactivity. Do not permit promotions to $Q_0$ for $P$. All other processes in $Q_1$ retain quantum $q_1$.\n\nE. Give each process a replenishing credit counter $C \\in [0, C_\\text{max}]$ with $C_\\text{max} = 100$. When a process yields before consuming $\\theta\\,q$ of its current quantum ($\\theta = 0.5$ and $q$ is the quantum of its current queue), it earns $e=5$ credits; while it runs on the CPU without yielding, it spends $s=1$ credit per $\\mathrm{ms}$ in $Q_0$ and $s=0.5$ credits per $\\mathrm{ms}$ in $Q_1$. Two distinct thresholds $L$ and $H$ define hysteresis with $L=30$, $H=70$, and $L < H$: if $C \\ge H$ and the process is in $Q_1$, promote it to $Q_0$; if $C \\le L$ and it is in $Q_0$, demote it to $Q_1$. Additionally, enforce a minimum residence time of $R=2\\,\\mathrm{s}$ in any queue after a transition before another transition can occur.\n\nWhich option(s) satisfy the stated criteria?",
            "solution": "We begin from standard scheduling and workload principles. In the widely used CPU–I/O burst model, a process alternates between CPU bursts and I/O waits. Interactive processes typically have short CPU bursts and frequent I/O, so they benefit from high-priority, short-quantum service to minimize response time. CPU-bound processes exhibit longer CPU bursts, where longer quanta and lower priority improve throughput and reduce preemption overhead for others. Multilevel queue scheduling enforces strict priority across queues, so classification errors that place long-running CPU-bound work in a high-priority queue can harm fairness by delaying lower queues indefinitely. Conversely, failing to promote clearly interactive tasks harms responsiveness. Therefore, a classifier must be robust to noise: it should promote only after sustained evidence of interactivity and demote only after sustained evidence of CPU-boundedness. This robustness is achieved via hysteresis mechanisms such as separated thresholds, consecutive-condition counters, cool-down windows, or minimum residence times.\n\nApply these principles to task $P$ with $q_0 = 5\\,\\mathrm{ms}$ and $q_1 = 20\\,\\mathrm{ms}$. Its typical bursts are $b_\\text{short} \\approx 3\\,\\mathrm{ms}$, clearly interactive relative to both $q_0$ and $q_1$. Occasionally, $P$ has a longer burst $b_\\text{long} \\approx 25\\,\\mathrm{ms}$ once every $60\\,\\mathrm{s}$. Since $b_\\text{short} \\ll q_0 \\ll q_1$, $P$ should generally be in $Q_0$ for good responsiveness. However, any policy that reacts to single events without hysteresis will tend to oscillate: a solitary $b_\\text{long}$ might trigger demotion, followed quickly by promotion on the very next few short bursts. Good designs therefore separate promotion and demotion conditions and require sustained evidence and/or time-based dampening.\n\nWe analyze each option.\n\nOption A: Promote on $k=2$ consecutive early yields; demote immediately upon a single long CPU burst in $Q_0$ that exceeds $0.6\\,q_0$. Quantitatively, in $Q_0$ with $q_0 = 5\\,\\mathrm{ms}$, the demotion trigger is $0.6\\,q_0 = 3\\,\\mathrm{ms}$. But $P$’s typical short burst is $b_\\text{short} \\approx 3\\,\\mathrm{ms}$, which is right at this threshold; a minor fluctuation above $3\\,\\mathrm{ms}$ would cause immediate demotion during normal interactive behavior, and any $b_\\text{long} \\approx 25\\,\\mathrm{ms}$ would certainly trigger demotion if $P$ happens to be in $Q_0$ at the time. With promotion requiring only $2$ consecutive early yields in $Q_1$, and demotion triggered by a single event in $Q_0$, the process will ping-pong: promote after two short bursts, then demote on any single burst slightly above the fragile threshold. There is no cool-down or minimum residence time, and the promotion/demotion criteria are not separated in strength (promotion is easier than demotion, but both are event-driven without sustained evidence). This lacks hysteresis and invites oscillation. Verdict: Incorrect.\n\nOption B: Use an exponentially weighted moving average (EWMA) with $\\alpha = 0.2$, two separated thresholds $T_\\text{up} = 0.4\\,q_1 = 8\\,\\mathrm{ms}$ and $T_\\text{down} = 0.8\\,q_1 = 16\\,\\mathrm{ms}$, with $M=3$ consecutive crossings required, and a cool-down $W=1\\,\\mathrm{s}$. This is a textbook hysteresis structure:\n- The EWMA $\\hat{b}$ smooths transient spikes: a single $b_\\text{long} \\approx 25\\,\\mathrm{ms}$ updates $\\hat{b}$ to $\\hat{b}' = 0.2 \\cdot 25 + 0.8 \\cdot \\hat{b}$. If $\\hat{b}$ had been near $3\\,\\mathrm{ms}$, the new $\\hat{b}' \\approx 7.4\\,\\mathrm{ms}$, still below $T_\\text{down} = 16\\,\\mathrm{ms}$. It would take several consecutive long bursts to push $\\hat{b}$ above $T_\\text{down}$. Given that $P$’s long bursts are rare (about once per $60\\,\\mathrm{s}$), the demotion condition (three consecutive $\\hat{b} > T_\\text{down}$) will almost never be met unless a sustained CPU-bound phase actually occurs. \n- Promotion requires $\\hat{b} < T_\\text{up} = 8\\,\\mathrm{ms}$ for $M=3$ consecutive bursts, which $P$ satisfies quickly during its normal short-burst regime. Thus $P$ will be promoted to $Q_0$ and remain there during typical interactive behavior.\n- The cool-down $W = 1\\,\\mathrm{s}$ prevents rapid reclassification even if counters and thresholds are transiently met, eliminating oscillation due to short-lived patterns.\n- Strict priority is preserved (no change), and fairness is maintained because processes that persistently exhibit long bursts will eventually see $\\hat{b}$ cross $T_\\text{down}$ for $N$ consecutive times, leading to demotion.\n\nAll three criteria (sustained evidence, separated thresholds, time-based dampening) are met. Verdict: Correct.\n\nOption C: Use only global CPU utilization thresholds at $50\\%$ to mass-promote or mass-demote. This ignores per-process behavior, lacks any hysteresis tailored to a process’s own CPU/I/O pattern, and would promote or demote $P$ based on unrelated workload fluctuations. It fails the requirement to promote $P$ based on sustained interactivity and to demote based on sustained CPU-boundedness; it also encourages oscillation as system utilization crosses the threshold. Verdict: Incorrect.\n\nOption D: Keep $P$ permanently in $Q_1$ and halve its time quantum there to $q_1/2 = 10\\,\\mathrm{ms}$. While a shorter quantum increases preemption frequency, strict queue priority means $Q_1$ is still deferred whenever $Q_0$ has work, degrading $P$’s responsiveness under interactive load from other $Q_0$ tasks. Moreover, this provides no promotion mechanism and no hysteresis—$P$ cannot enter $Q_0$ even when it behaves interactively. It fails the core requirement to place $P$ in $Q_0$ during sustained interactive phases. Verdict: Incorrect.\n\nOption E: Credit-based hysteresis with thresholds $L=30$ and $H=70$, earn rate $e=5$ for early yields (before $\\theta q$ with $\\theta = 0.5$), and spend rate $s$ proportional to CPU time, plus a minimum residence time $R=2\\,\\mathrm{s}$. This builds a classic hysteresis loop:\n- Two thresholds $L<H$ create a band: promotion occurs when $C \\ge H$ and demotion when $C \\le L$, preventing immediate reversal because after crossing one boundary the counter must traverse the band to cross the other. This is a direct instantiation of hysteresis.\n- Credits accumulate under sustained interactive behavior (frequent early yields) and deplete under sustained CPU-bound behavior (continuous CPU consumption), naturally distinguishing the two regimes and requiring sustained evidence to cross thresholds.\n- The minimum residence time $R$ prevents immediate reclassification after a transition, suppressing ping-pong even if the counter reverses quickly under short-term fluctuation.\n- With $b_\\text{short} \\approx 3\\,\\mathrm{ms}$ relative to $q_1=20\\,\\mathrm{ms}$ or $q_0=5\\,\\mathrm{ms}$, $P$ will repeatedly earn credits and remain above $H$ most of the time, keeping it in $Q_0$; the rare $b_\\text{long} \\approx 25\\,\\mathrm{ms}$ events will spend credits but are too infrequent to drive $C$ below $L$, so demotion occurs only under sustained CPU-boundedness. Strict priority is preserved, and demotions under sustained CPU usage protect $Q_1$ fairness.\n\nThis policy satisfies the criteria by combining separated thresholds and time-based dampening (minimum residence time). Verdict: Correct.\n\nConclusion: Options B and E implement principled hysteresis-based heuristics that classify $P$ appropriately and avoid oscillation while preserving fairness and strict priority. Options A, C, and D either lack hysteresis, rely on unrelated signals, or prevent appropriate promotion.",
            "answer": "$$\\boxed{BE}$$"
        }
    ]
}