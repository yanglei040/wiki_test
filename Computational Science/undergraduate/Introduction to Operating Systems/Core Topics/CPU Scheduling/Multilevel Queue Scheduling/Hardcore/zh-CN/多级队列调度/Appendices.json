{
    "hands_on_practices": [
        {
            "introduction": "多级队列调度的核心思想之一是如何在不同优先级的任务之间分配CPU资源。这个练习将带你回到问题的根本，探讨在一个带有预算限制的简化模型中，CPU时间是如何被稳定地分配的。通过分析这个理想化的场景，你将掌握资源守恒（work-conserving）和分层分配的基本原理。",
            "id": "3660877",
            "problem": "一个操作系统部署了多级队列调度（MLQS），有$3$个就绪队列，分别表示为$Q_0$（最高优先级）、$Q_1$和$Q_2$（最低优先级）。调度程序对前两个队列强制执行长期预算约束：队列$Q_0$的预算为$B_0$，队列$Q_1$的预算为$B_1$，其中$0  B_0  1$，$0  B_1  1$，且$B_0 + B_1 \\le 1$。假设在重负载下的稳态（每个队列始终有可运行的线程）满足以下基本属性：\n\n- 调度程序是工作保持的（work-conserving）：当有可运行的工作时，中央处理器（CPU）绝不会被有意闲置。\n- 预算约束是严格上限：饱和队列不能超过其预算的长期CPU时间份额。\n- 通过分层转赠确保无饥饿：任何未被较高优先级队列使用的容量立即可供较低优先级队列使用。\n\n令$S_i$表示队列$Q_i$获得的稳态服务份额（长期的CPU时间份额）。仅使用上述属性和定义，根据$B_0$和$B_1$推导$S_0$、$S_1$和$S_2$的表达式。将最终答案表示为一个包含$S_0$、$S_1$和$S_2$的单行矩阵，形式为最简闭式。无需四舍五入，服务份额为无量纲值。",
            "solution": "该问题是有效的，因为它在科学上基于操作系统调度的原理，问题提法恰当，具有一组自洽且一致的定义和约束，并以客观、可形式化的语言表达。\n\n令$S_i$表示队列$Q_i$的稳态服务份额，其中$i \\in \\{0, 1, 2\\}$。总可用CPU时间可以表示为分数$1$。“工作保持”属性指出，如果有工作要做，CPU绝不闲置。“重负载”假设保证了每个队列始终有可运行的线程。这两个属性结合起来，意味着所有队列的服务份额之和必须等于总可用CPU时间。\n$$S_0 + S_1 + S_2 = 1$$\n这个方程代表了CPU资源的完全分配。\n\n我们接下来确定每个队列的服务份额，从最高优先级的队列$Q_0$开始。队列$Q_0$具有最高优先级并且是饱和的（总是有工作）。因此，调度程序将始终从$Q_0$中选择一个线程来运行，受其预算的限制。问题指出，预算$B_0$是长期CPU时间份额的“严格上限”。因为$Q_0$是饱和的，它将完全利用其分配的预算。因此，$Q_0$的稳态服务份额恰好是其预算。\n$$S_0 = B_0$$\n\n接下来，我们分析队列$Q_1$。它的优先级低于$Q_0$但高于$Q_2$。除$Q_0$外其他队列可用的CPU时间是总时间减去$Q_0$消耗的时间，即$1 - S_0 = 1 - B_0$。“分层转赠”的属性确保了这部分剩余容量可供较低优先级的队列使用。由于$Q_1$的优先级高于$Q_2$，它对这部分容量有优先使用权。队列$Q_1$也是饱和的，并将尝试消耗尽可能多的可用时间。然而，它的消耗受到其自身预算$B_1$的限制。因此，服务份额$S_1$是可用容量和其预算中的较小者：\n$$S_1 = \\min(1 - B_0, B_1)$$\n问题给出了约束$B_0 + B_1 \\le 1$。这个不等式可以重排为$B_1 \\le 1 - B_0$。这表明$Q_1$的预算严格小于或等于在$Q_0$被服务后剩余的CPU容量。因此，对$Q_1$的限制因素是其自身的预算，而不是可用容量。\n$$S_1 = B_1$$\n\n最后，我们确定最低优先级队列$Q_2$的服务份额。由于调度程序是工作保持的，且$Q_2$始终可运行，它将获得所有未被较高优先级队列$Q_0$和$Q_1$消耗的CPU时间。我们使用初始的资源分配方程：\n$$S_0 + S_1 + S_2 = 1$$\n代入$S_0$和$S_1$的推导表达式：\n$$B_0 + B_1 + S_2 = 1$$\n解出$S_2$得到剩余的CPU时间份额：\n$$S_2 = 1 - B_0 - B_1$$\n给定条件$B_0 + B_1 \\le 1$确保了$S_2 \\ge 0$，这意味着最低优先级的队列不会发生CPU时间饥饿，这与问题陈述的属性是一致的。\n\n因此，稳态服务份额为$S_0 = B_0$，$S_1 = B_1$和$S_2 = 1 - B_0 - B_1$。这些需要表示为一个单行矩阵。",
            "answer": "$$\\boxed{\\begin{pmatrix} B_0  B_1  1 - B_0 - B_1 \\end{pmatrix}}$$"
        },
        {
            "introduction": "现实世界中的任务行为是动态变化的，一个优秀的调度器必须能够自适应地调整任务的优先级。本练习模拟了一个常见的调度器设计挑战：如何根据任务的行为动态地将其在交互式队列和批处理队列之间移动。你将探索和评估不同的启发式策略，并理解“迟滞”（hysteresis）机制在防止调度振荡、保证系统稳定性方面为何至关重要。",
            "id": "3660873",
            "problem": "一个计算机系统使用多级队列调度，其中有两个最高优先级的队列：$Q_0$（交互式）和$Q_1$（批处理）。调度器在队列之间强制执行严格优先级：只要$Q_0$非空，就只调度$Q_0$；只有当$Q_0$为空时，$Q_1$才运行。每个队列使用带有自身时间片的轮询调度：$Q_0$的时间片为$q_0$，$Q_1$的时间片为$q_1$，且$q_0 \\ll q_1$。新创建的任务默认进入$Q_1$。一个进程在中央处理器（CPU）突发和输入/输出（I/O）等待之间交替；交互式任务倾向于有短的CPU突发和随后的I/O，而CPU密集型任务则有长的CPU突发和不频繁的I/O。主动放弃（voluntary yield）表示一个进程在耗尽其时间片之前放弃了CPU，通常是为了发起I/O。这些是构成调度设计基础的标准、被广泛观察到的事实。\n\n考虑一个当前位于$Q_1$中的任务$P$。测量表明，在稳态下：在其大部分活动中，$P$在经过约$b_{\\text{short}} \\approx 3\\,\\mathrm{ms}$的短CPU突发后会主动放弃，这种情况频繁发生（例如，最近10次突发中有8次）；然而，大约每$60\\,\\mathrm{s}$一次，$P$会进入一个CPU密集型阶段，在此阶段它会执行一个约$b_{\\text{long}} \\approx 25\\,\\mathrm{ms}$的CPU突发。系统参数为$q_0 = 5\\,\\mathrm{ms}$和$q_1 = 20\\,\\mathrm{ms}$。\n\n要求你决定$P$是否通常应该被放置在$Q_0$中，更重要的是，选择一种带有滞后效应的提升/降级启发式策略，以避免基于瞬时行为而在$Q_0$和$Q_1$之间发生振荡。这里的振荡指由于短暂的短期变化而导致的频繁提升和降级，这会损害公平性和响应性。\n\n选择所有实现了基于原则的、带滞后效应的策略的选项，这些策略 (i) 在$P$的行为持续为交互式时将其提升到$Q_0$，(ii) 仅在$P$表现出持续的CPU密集型行为后才将其降级回$Q_1$，以及 (iii) 通过明确的滞后机制（如分离的阈值或最小驻留/冷却时间）来减少振荡，同时保留严格优先级并避免$Q_1$任务的饥饿。\n\nA. 任何进程在$Q_1$中连续$k=2$次在消耗少于$0.5\\,q_1$的时间后主动放弃，就立即将其提升到$Q_0$。任何进程在$Q_0$中只要有任何一次CPU突发中消耗超过$0.6\\,q_0$而没有放弃，就立即将其从$Q_0$降级到$Q_1$。没有额外的时序限制。\n\nB. 使用$\\hat{b} \\leftarrow \\alpha\\,b_\\text{new} + (1-\\alpha)\\,\\hat{b}$（其中$\\alpha = 0.2$）为每个进程最近的CPU突发长度维护一个指数加权移动平均值 (EWMA) $\\hat{b}$。使用两个相对于$q_1$的分离阈值：$T_{\\text{up}} = 0.4\\,q_1$和$T_{\\text{down}} = 0.8\\,q_1$，且$T_{\\text{up}}  T_{\\text{down}}$。当$\\hat{b}  T_{\\text{up}}$连续出现$M=3$次突发时，将进程从$Q_1$提升到$Q_0$；当$\\hat{b} > T_{\\text{down}}$连续出现$N=3$次突发时，将进程从$Q_0$降级到$Q_1$。在任何队列更改后，强制执行一个$W = 1\\,\\mathrm{s}$的冷却窗口，在此期间该进程的进一步提升/降级被抑制。\n\nC. 仅使用全局CPU利用率作为信号：当全系统CPU利用率低于$50\\%$时，将所有$Q_1$进程提升到$Q_0$；当利用率高于$50\\%$时，将所有$Q_0$进程降级到$Q_1$。不跟踪每个进程的历史记录。\n\nD. 将$P$永久保留在$Q_1$中，但将其在该队列的时间片减半至$q_1/2$以模拟交互性。不允许将$P$提升到$Q_0$。$Q_1$中的所有其他进程保留时间片$q_1$。\n\nE. 为每个进程提供一个可补充的信用计数器$C \\in [0, C_{\\text{max}}]$，其中$C_{\\text{max}} = 100$。当一个进程在其当前队列的时间片$q$的$\\theta q$（$\\theta = 0.5$）之内放弃时，它获得$e=5$个信用点；当它在CPU上运行时不放弃，它在$Q_0$中每毫秒花费$s=1$个信用点，在$Q_1$中每毫秒花费$s=0.5$个信用点。两个不同的阈值$L$和$H$（$L=30, H=70, L  H$）定义了滞后效应：如果$C \\ge H$且进程在$Q_1$中，则将其提升到$Q_0$；如果$C \\le L$且进程在$Q_0$中，则将其降级到$Q_1$。此外，在一次转换后，强制要求在任何队列中的最小驻留时间为$R=2\\,\\mathrm{s}$，然后才能进行另一次转换。\n\n哪些选项满足所述标准？",
            "solution": "我们从标准的调度和工作负载原则开始。在广泛使用的CPU-I/O突发模型中，一个进程在CPU突发和I/O等待之间交替。交互式进程通常具有短的CPU突发和频繁的I/O，因此它们受益于高优先级、短时间片的服务以最小化响应时间。CPU密集型进程表现出更长的CPU突发，其中更长的时间片和更低的优先级可以提高吞吐量并为其他进程减少抢占开销。多级队列调度在队列之间强制执行严格的优先级，因此将长时间运行的CPU密集型工作放入高优先级队列的分类错误会无限期地延迟较低优先级的队列，从而损害公平性。反之，未能提升明确的交互式任务则会损害响应性。因此，分类器必须对噪声具有鲁棒性：它只应在有持续的交互行为证据后才进行提升，并且只在有持续的CPU密集型行为证据后才进行降级。这种鲁棒性是通过滞后机制实现的，例如分离的阈值、连续条件计数器、冷却窗口或最小驻留时间。\n\n将这些原则应用于任务$P$，其参数为$q_0 = 5\\,\\mathrm{ms}$和$q_1 = 20\\,\\mathrm{ms}$。它的典型突发是$b_{\\text{short}} \\approx 3\\,\\mathrm{ms}$，相对于$q_0$和$q_1$都明显是交互式的。偶尔地，$P$每$60\\,\\mathrm{s}$会有一次较长的突发$b_{\\text{long}} \\approx 25\\,\\mathrm{ms}$。由于$b_{\\text{short}} \\ll q_0 \\ll q_1$，$P$通常应该在$Q_0$中以获得良好的响应性。然而，任何对单个事件做出反应而没有滞后效应的策略都容易发生振荡：一个孤立的$b_{\\text{long}}$可能会触发降级，紧接着又因为接下来的几个短突发而被提升。因此，好的设计会分离提升和降级的条件，并要求持续的证据和/或基于时间的阻尼。\n\n我们逐一分析每个选项。\n\n选项A：在$k=2$次连续的提前放弃后提升；在$Q_0$中只要有一次超过$0.6\\,q_0$的长CPU突发就立即降级。从数量上看，在$q_0 = 5\\,\\mathrm{ms}$的$Q_0$中，降级触发条件是$0.6\\,q_0 = 3\\,\\mathrm{ms}$。但是$P$的典型短突发是$b_{\\text{short}} \\approx 3\\,\\mathrm{ms}$，正好在这个阈值上；一个略高于$3\\,\\mathrm{ms}$的微小波动就会在其正常的交互行为期间导致立即降级，并且任何$b_{\\text{long}} \\approx 25\\,\\mathrm{ms}$的突发（如果$P$当时恰好在$Q_0$中）肯定会触发降级。由于提升只需要在$Q_1$中连续2次提前放弃，而降级由$Q_0$中的单个事件触发，该进程会发生乒乓效应：在两次短突发后提升，然后在任何一次略高于脆弱阈值的突发后降级。没有冷却时间或最小驻留时间，而且提升/降级的标准在强度上没有分离（提升比降级容易，但两者都是事件驱动的，没有持续的证据）。这缺乏滞后效应，容易引发振荡。结论：不正确。\n\n选项B：使用指数加权移动平均 (EWMA)，其中$\\alpha=0.2$，两个分离的阈值$T_{\\text{up}} = 0.4\\,q_1 = 8\\,\\mathrm{ms}$和$T_{\\text{down}} = 0.8\\,q_1 = 16\\,\\mathrm{ms}$，需要连续$M=N=3$次跨越阈值，并有一个$W=1\\,\\mathrm{s}$的冷却时间。这是一个教科书式的滞后结构：\n- EWMA $\\hat{b}$平滑了短暂的峰值：一个$b_{\\text{long}} \\approx 25\\,\\mathrm{ms}$的突发将$\\hat{b}$更新为$\\hat{b}' = 0.2 \\cdot 25 + 0.8 \\cdot \\hat{b}$。如果$\\hat{b}$之前接近$3\\,\\mathrm{ms}$，新的$\\hat{b}' \\approx 7.4\\,\\mathrm{ms}$，仍然低于$T_{\\text{down}} = 16\\,\\mathrm{ms}$。需要连续几个长突发才能将$\\hat{b}$推高到$T_{\\text{down}}$之上。鉴于$P$的长突发很罕见（大约每$60\\,\\mathrm{s}$一次），降级条件（连续三次$\\hat{b} > T_{\\text{down}}$）几乎永远不会满足，除非真正发生了持续的CPU密集型阶段。 \n- 提升需要连续$M=3$次突发满足$\\hat{b}  T_{\\text{up}} = 8\\,\\mathrm{ms}$，这在$P$的正常短突发模式下能很快满足。因此，$P$将被提升到$Q_0$并在其典型的交互行为期间保持在那里。\n- 冷却窗口$W = 1\\,\\mathrm{s}$防止了即使计数器和阈值被短暂满足时的快速重新分类，从而消除了由短期模式引起的振荡。\n- 严格优先级得以保留（没有改变），公平性也得到维护，因为持续表现出长突发的进程最终会看到其$\\hat{b}$连续$N$次超过$T_{\\text{down}}$，从而导致降级。\n\n所有三个标准（持续证据、分离阈值、基于时间的阻尼）都得到满足。结论：正确。\n\n选项C：仅使用全局CPU利用率阈值$50\\%$来进行大规模提升或大规模降级。这忽略了每个进程的行为，缺乏针对进程自身CPU/I/O模式的任何滞后效应，并且会根据不相关的工作负载波动来提升或降级$P$。它未能满足根据持续交互行为提升$P$和根据持续CPU密集型行为降级$P$的要求；当系统利用率跨越阈值时，它还会鼓励振荡。结论：不正确。\n\n选项D：将$P$永久保留在$Q_1$中，并将其时间片减半至$q_1/2 = 10\\,\\mathrm{ms}$。虽然较短的时间片增加了抢占频率，但严格的队列优先级意味着只要$Q_0$有工作，$Q_1$仍然会被推迟，这会降低$P$在面对来自其他$Q_0$任务的交互负载时的响应性。此外，这没有提供提升机制，也没有滞后效应——即使$P$表现出交互行为，也无法进入$Q_0$。它未能满足在持续交互阶段将$P$放入$Q_0$的核心要求。结论：不正确。\n\n选项E：基于信用的滞后机制，带有阈值$L=30$和$H=70$，提前放弃（在$\\theta q$之前，$\\theta = 0.5$）可获得$e=5$的信用点，CPU消耗则按速率$s$花费信用点，外加$R=2\\,\\mathrm{s}$的最小驻留时间。这构建了一个经典的滞后回环：\n- 两个阈值$L  H$创建了一个“无人区”，防止信用值在阈值附近波动时发生快速的来回切换。\n- $P$的短突发行为（在$3\\,\\mathrm{ms}$后放弃，远小于$0.5 \\times q_1 = 10\\,\\mathrm{ms}$）会稳定地获得信用点，使其信用值$C$倾向于超过$H=70$，从而被提升到$Q_0$。\n- 一旦在$Q_0$中，它会因短突发获得信用点，但也会因CPU使用而花费信用点。一个$b_{\\text{long}} \\approx 25\\,\\mathrm{ms}$的长突发会花费$25 \\times 1 = 25$个信用点。这会显著降低$C$，但由于该事件罕见，信用值可能会在下一次长突发到来之前恢复。只有在持续的CPU密集型行为下，$C$才会稳定下降到$L=30$以下触发降级。\n- 最小驻留时间$R=2\\,\\mathrm{s}$进一步抑制了由短期行为模式引起的快速振荡。\n- 这个策略满足了所有三个标准。结论：正确。",
            "answer": "$$\\boxed{BE}$$"
        },
        {
            "introduction": "在系统性能优化中，直觉有时会误导我们。这个练习将揭示一个调度中的“反常”现象：对一个高优先级任务的“优化”反而导致整个系统需要更长的时间来完成所有工作。通过精确计算和分析，你将深入理解抢占、上下文切换以及缓存失效等开销在系统总性能中所扮演的关键角色，并学会从更全面的角度审视性能问题。",
            "id": "3660936",
            "problem": "一个操作系统实现了具有严格优先级的多级队列（MLQ）调度，其中前台队列 $Q_1$（交互式）在任何 $Q_1$ 作业到达时，总是抢占后台队列 $Q_2$（批处理）。$Q_1$ 队列使用轮转（RR）调度，$Q_2$ 队列使用先来先服务（FCFS）调度。一次上下文切换消耗 $c = 0.2\\,\\mathrm{ms}$ 的 CPU 时间，每次抢占 $Q_2$ 作业都会产生额外的缓存和转译后备缓冲器（TLB）重预热开销 $\\delta = 0.8\\,\\mathrm{ms}$，之后 $Q_2$ 作业才能恢复有效执行。假设当有任何作业就绪时，中央处理器（CPU）从不空闲，并且每当一个 $Q_1$ 突发到达时，它会立即抢占正在运行的任何 $Q_2$ 作业。\n\n考虑以下工作负载，所有作业都在时间 $t=0$ 释放：\n- 一个 $Q_1$ 作业，记为 $I$，以及两个 $Q_2$ 作业，记为 $B_1$ 和 $B_2$。\n- $B_1$ 的总 CPU 需求为 $120\\,\\mathrm{ms}$，$B_2$ 的总 CPU 需求为 $80\\,\\mathrm{ms}$，因此 $Q_2$ 总共有 $200\\,\\mathrm{ms}$ 的 CPU 工作量。\n- 情况 $\\mathrm{Old}$（$I$ “加速”前）：作业 $I$ 需要 $30\\,\\mathrm{ms}$ 的 CPU，其结构为 $3$ 个各 $10\\,\\mathrm{ms}$ 的突发，连续突发之间有 $50\\,\\mathrm{ms}$ 的输入/输出（I/O）阻塞时间。\n- 情况 $\\mathrm{New}$（$I$ “加速”后）：作业 $I$ 经过优化，现在需要 $20\\,\\mathrm{ms}$ 的 CPU，其结构为 $20$ 个各 $1\\,\\mathrm{ms}$ 的突发，连续突发之间有 $5\\,\\mathrm{ms}$ 的 I/O 阻塞时间。\n\n仅使用严格优先级 MLQ、FCFS、抢占、上下文切换开销和完工时间（定义为所有作业完成时的挂钟时间）的核心定义，回答以下问题：\n\n1. 在给定假设下，计算情况 $\\mathrm{Old}$ 和情况 $\\mathrm{New}$ 中的工作负载完工时间。每次当 $Q_1$ 突发到达且 $Q_2$ 正在运行时，明确计算 $Q_2$ 面临的每次抢占开销（包括 $c$ 和 $\\delta$）。\n2. 尽管在情况 $\\mathrm{New}$ 中 $I$ 消耗的 CPU 比在情况 $\\mathrm{Old}$ 中少，但工作负载的完工时间却可能增加。哪个选项最能解释这种调度异常的根本原因？\n\n选项：\n- A. 在严格优先级 MLQ 中，更频繁的 $Q_1$ 到达会导致对 $Q_2$ 的额外抢占。每次抢占都会增加开销 $c+\\delta$ 并破坏 $Q_2$ 的局部性，因此如果累积的开销增加超过了 $I$ 的 CPU 需求减少量，完工时间就会增加。\n\n- B. $Q_1$ 和 $Q_2$ 之间的优先级反转导致 $Q_1$ 在 $Q_2$ 之后阻塞；加速 $Q_1$ 会加剧这种反转，从而延迟所有作业。\n\n- C. 该异常是由于 $Q_2$ 中的轮转调度使用过小的时间片，导致 $Q_2$ 突发碎片化；加速 $Q_1$ 仅仅揭示了这一潜在问题。\n\n- D. 即使上下文切换和抢占成本为零（即 $c=\\delta=0$），该异常仍然会发生；因此，根本原因在于抢占的时机而非开销。",
            "solution": "要解决这个问题，我们首先需要计算两种情况下所有作业完成所需的总时间，即完工时间（makespan）。由于CPU从不空闲，完工时间等于所有作业的有效CPU时间与所有调度开销的总和。\n\n总开销主要来自于对$Q_2$作业的抢占。根据题意，每当一个$Q_1$突发到达且一个$Q_2$作业正在运行时，就会发生一次抢占。每次抢占的总开销为上下文切换成本 $c$ 与缓存/TLB重预热开销 $\\delta$ 之和：\n$$ \\text{每次抢占开销} = c + \\delta = 0.2\\,\\mathrm{ms} + 0.8\\,\\mathrm{ms} = 1.0\\,\\mathrm{ms} $$\n\n所有后台作业($B_1, B_2$)的总CPU需求是恒定的：\n$$ \\text{后台总CPU} = 120\\,\\mathrm{ms} + 80\\,\\mathrm{ms} = 200\\,\\mathrm{ms} $$\n\n**1. 完工时间计算**\n\n**情况 $\\mathrm{Old}$**\n- **作业 $I$ 的CPU需求**：$3$个突发 $\\times$ $10\\,\\mathrm{ms}$/突发 = $30\\,\\mathrm{ms}$。\n- **抢占次数**：作业 $I$ 共有3个突发。第一个突发在 $t=0$ 时开始，此时CPU空闲，不产生抢占。此后，$I$ 会进行两次I/O，每次I/O结束后返回就绪态时，后台作业 $B_1$ 正在运行，因此会发生抢占。所以总共有 $3 - 1 = 2$ 次抢占。\n- **总开销**：$2$ 次抢占 $\\times$ $1.0\\,\\mathrm{ms}$/次 = $2.0\\,\\mathrm{ms}$。\n- **总CPU工作量**：$30\\,\\mathrm{ms}$ (来自 $I$) + $200\\,\\mathrm{ms}$ (来自 $B_1, B_2$) = $230\\,\\mathrm{ms}$。\n- **完工时间 ($\\mathrm{Old}$)**：总CPU工作量 + 总开销 = $230\\,\\mathrm{ms} + 2.0\\,\\mathrm{ms} = 232\\,\\mathrm{ms}$。\n\n**情况 $\\mathrm{New}$**\n- **作业 $I$ 的CPU需求**：$20$个突发 $\\times$ $1\\,\\mathrm{ms}$/突发 = $20\\,\\mathrm{ms}$。\n- **抢占次数**：作业 $I$ 共有20个突发。与之前类似，第一个突发不产生抢占。但随后的19个突发在每次I/O结束后都会抢占正在运行的后台作业。所以总共有 $20 - 1 = 19$ 次抢占。\n- **总开销**：$19$ 次抢占 $\\times$ $1.0\\,\\mathrm{ms}$/次 = $19\\,\\mathrm{ms}$。\n- **总CPU工作量**：$20\\,\\mathrm{ms}$ (来自 $I$) + $200\\,\\mathrm{ms}$ (来自 $B_1, B_2$) = $220\\,\\mathrm{ms}$。\n- **完工时间 ($\\mathrm{New}$)**：总CPU工作量 + 总开销 = $220\\,\\mathrm{ms} + 19\\,\\mathrm{ms} = 239\\,\\mathrm{ms}$。\n\n**2. 异常原因分析**\n\n计算结果表明，尽管在情况 $\\mathrm{New}$ 中作业 $I$ 的CPU需求减少了 $10\\,\\mathrm{ms}$，但总完工时间反而从 $232\\,\\mathrm{ms}$ 增加到了 $239\\,\\mathrm{ms}$。这是因为总开销从 $2\\,\\mathrm{ms}$ 急剧增加到 $19\\,\\mathrm{ms}$，增加了 $17\\,\\mathrm{ms}$。开销的增长（$17\\,\\mathrm{ms}$）超过了CPU需求的减少（$10\\,\\mathrm{ms}$），导致了整体性能下降。\n\n现在我们评估各个选项：\n\n- **A**：该选项正确地指出，更频繁的 $Q_1$ 到达导致了对 $Q_2$ 的额外抢占。每次抢占都带来了 $c+\\delta$ 的开销，这与我们的计算完全一致。当累积的开销增加量超过 $I$ 的CPU需求减少量时，完工时间就会增加。这是对该异常现象的根本原因的精确描述。\n- **B**：优先级反转是指高优先级任务等待低优先级任务。在这个问题中，高优先级的 $Q_1$ 作业从不等待 $Q_2$ 作业，而是直接抢占它。因此，不存在优先级反转。\n- **C**：该选项错误地指出 $Q_2$ 使用轮转调度。根据题意，$Q_2$ 使用的是先来先服务（FCFS）调度。\n- **D**：该选项声称即使开销为零，异常也会发生。我们可以检验这一点：如果 $c=\\delta=0$，则情况 $\\mathrm{Old}$ 的完工时间为 $230\\,\\mathrm{ms}$，情况 $\\mathrm{New}$ 的完工时间为 $220\\,\\mathrm{ms}$。在这种情况下，完工时间会减少，异常现象会消失。因此，开销是该异常的根本原因。\n\n综上所述，选项 A 是唯一正确的解释。",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}