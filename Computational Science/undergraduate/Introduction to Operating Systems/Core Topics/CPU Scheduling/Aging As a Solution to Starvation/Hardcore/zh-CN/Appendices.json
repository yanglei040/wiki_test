{
    "hands_on_practices": [
        {
            "introduction": "理论是实践的基石。为了从根本上理解老化机制如何解决饥饿问题，我们首先从一个纯粹的理论推导开始。这个练习将引导你通过分析最坏情况下的任务到达模式，从第一性原理出发，推导出保证低优先级任务最终能够执行所需的最小老化速率，从而将抽象的调度理论与可量化的性能保证联系起来。",
            "id": "3620577",
            "problem": "考虑一个使用抢占式严格优先级调度的单处理器操作系统：在任何时刻，调度程序都运行当前优先级最高的就绪任务，并且抢占是瞬时的，其开销可忽略不计。一个低优先级任务在时间 $t=0$ 到达，其基础优先级为 $P_{L0}$，需要 $C_{L}$ 个单位的执行时间。高优先级任务随时间到达，其基础优先级固定为 $P_{H}$，满足 $P_{H} > P_{L0}$，并且这些任务不参与老化。系统使用老化机制，根据一个老化函数 $f(t)$ 来提高等待中的低优先级任务的有效优先级，该函数随任务的等待时间 $t$ 非递减且连续更新。当低优先级任务运行时，其优先级不会降低，并保持至少与其开始运行时所具有的优先级一样高。假设所有量均为有限值，且 $D > C_{L}$。\n\n要求您从优先级调度和老化的第一性原理出发进行推理，以确保即使在高优先级任务以病态模式到达的情况下，低优先级任务的延迟也是有限的。具体而言：\n\n- 在您的推理中，构建一个对抗性的、但符合调度程序规则的高优先级任务到达模式，该模式在仅遵循“只要存在任何就绪的高优先级任务，处理器就绝不空闲”这一规则的条件下，最大化低优先级任务首次运行前的等待时间。\n- 在该最坏情况下，为以下每种老化策略推导出最小斜率参数 $a$，以保证无论对抗性的高优先级任务如何到达，低优先级任务都能在给定的绝对截止时间 $D$ 之前完成：\n  1. 线性老化：$f(t)=a\\,t$。\n  2. 凸二次老化：$f(t)=a\\,t^{2}$。\n\n您的推导必须仅从上文所述的抢占式严格优先级调度和优先级老化的核心定义出发。请将您的最终答案表示为关于 $P_{H}$、$P_{L0}$、$C_{L}$ 和 $D$ 的闭式符号表达式。无需四舍五入，也无需物理单位。请提供两种策略的最小斜率参数作为您的最终答案。",
            "solution": "在尝试求解之前，将首先对问题的科学合理性、自洽性和清晰度进行验证。\n\n**问题验证**\n\n**第1步：提取已知条件**\n-   系统类型：单处理器，抢占式严格优先级调度。\n-   调度程序行为：运行当前优先级最高的就绪任务。抢占是瞬时的，开销可忽略不计。\n-   低优先级任务：在时间 $t=0$ 到达。基础优先级为 $P_{L0}$。所需执行时间为 $C_{L}$。\n-   高优先级任务：随时间到达。固定基础优先级为 $P_{H}$，且 $P_{H} > P_{L0}$。这些任务不参与老化。\n-   老化机制：适用于低优先级任务。其有效优先级为 $P_L(t) = P_{L0} + f(t)$，其中 $t$ 是任务的等待时间。老化函数 $f(t)$ 随 $t$ 非递减且连续更新。\n-   优先级锁定：当低优先级任务运行时，其优先级不会降低，并保持至少与其开始执行时的优先级一样高。\n-   约束条件：所有量均为有限值。低优先级任务的绝对截止时间 $D$ 满足 $D > C_{L}$。\n-   对抗性条件：只要存在任何就绪的高优先级任务，处理器就绝不空闲。\n-   目标：为两种老化策略——$f(t)=a\\,t$ 和 $f(t)=a\\,t^{2}$——推导出最小斜率参数 $a$，以保证在最坏情况的对抗性到达模式下，低优先级任务能在截止时间 $D$ 前完成。\n\n**第2步：使用提取的已知条件进行验证**\n该问题是操作系统调度理论中的一个理论练习。所有概念，包括抢占式优先级调度、饿死和老化，在计算机科学中都是成熟的。问题以精确的数学和逻辑语言表述，没有主观或模糊的术语。给出的条件是自洽的，并且足以推导出解。例如，条件 $D > C_{L}$ 确保了截止时间不是平凡不可达的，因为分配的时间 $D$ 严格大于所需的执行时间 $C_{L}$。约束 $P_{H} > P_{L0}$ 确立了老化机制旨在解决的基本优先级反转场景。对对抗者和优先级锁定机制的描述为最坏情况分析提供了一个清晰且良构的框架。该问题具有科学依据、良构、客观且完整。它没有违反任何无效性标准。\n\n**第3步：结论与行动**\n该问题被判定为**有效**。将推导形式化解法。\n\n**解的推导**\n\n设 $T_L$ 为低优先级任务，它在时间 $t=0$ 到达。在等待了时长 $t_w$ 后，其在时间 $t$ 的优先级由 $P_L(t_w) = P_{L0} + f(t_w)$ 给出。系统采用抢占式严格优先级调度。这意味着 $T_L$ 只有在其优先级严格高于所有其他就绪任务，或者如果它已在运行且其优先级等于最高优先级时，才能进入运行状态。由于高优先级任务的优先级恒为 $P_H$，只要存在任何就绪的高优先级任务且 $P_L(t_w)  P_H$，$T_L$ 就会被阻止运行。\n\n为了找到所需的最小老化速率，我们必须分析最坏情况。对抗者的目标是最大化 $T_L$ 的完成时间。这通过最大化其等待时间来实现。最有效的对抗策略是用高优先级任务使处理器完全被占用，从而阻止 $T_L$ 运行。这在问题陈述中是允许的，即“只要存在任何就绪的高优先级任务，处理器就绝不空闲”。因此，对抗者可以引入连续的高优先级任务流来保持CPU繁忙。\n\n低优先级任务 $T_L$ 只有当其自身优先级通过老化提升到至少与高优先级任务相等的水平时，才能打破这种饿死循环。设 $W_{max}$ 为 $T_L$ 可能被强制等待的最长时间。这个最坏情况的等待时间是其优先级变得等于 $P_H$ 所需的时间。此时，它不能再被优先级为 $P_H$ 的新到达任务明确地抢占。我们通过将老化后的优先级设为等于高优先级水平来找到 $W_{max}$：\n$$P_L(W_{max}) = P_{H}$$\n$$P_{L0} + f(W_{max}) = P_{H}$$\n分离出与老化函数相关的项，得到：\n$$f(W_{max}) = P_H - P_{L0}$$\n\n一旦 $T_L$ 在时间 $t_{start} = W_{max}$ 开始执行，其优先级就被锁定在至少为 $P_H$ 的值。问题陈述中说：“当低优先级任务运行时，其优先级不会降低，并保持至少与其开始运行时所具有的优先级一样高。”由于所有其他高优先级任务的优先级恰好为 $P_H$，没有任务具有能够抢占 $T_L$ 的*严格更高*的优先级。因此，一旦 $T_L$ 开始运行，它将不间断地运行直到完成。\n\n$T_L$ 的执行需要 $C_L$ 个单位时间。从到达至完成的总时间，即响应时间 $R_L$，是等待时间与执行时间的总和。在最坏情况下，即为：\n$$R_L = W_{max} + C_L$$\n\n为了满足系统的要求，任务必须在其绝对截止时间 $D$ 之前完成。这施加了以下约束：\n$$R_L \\le D$$\n代入最坏情况响应时间的表达式：\n$$W_{max} + C_L \\le D$$\n这意味着最大可容忍的等待时间为：\n$$W_{max} \\le D - C_L$$\n\n由于老化函数 $f(t)$ 被指定为非递减的，不等式 $W_{max} \\le D - C_L$ 意味着 $f(W_{max}) \\le f(D - C_L)$。将此与我们早先的结果 $f(W_{max}) = P_H - P_{L0}$ 相结合，我们得出了老化函数必须满足的基本条件：\n$$P_H - P_{L0} \\le f(D - C_L)$$\n\n为了找到保证满足截止时间的*最小*斜率参数 $a$，我们必须选择仍然满足此不等式的“最慢”可能的老化函数。这发生在边界处，即不等式变为等式：\n$$f(D - C_L) = P_H - P_{L0}$$\n\n我们现在将这个一般结果应用于两种特定的老化策略。\n\n**1. 线性老化策略**\n老化函数为 $f(t) = a\\,t$。将其代入我们推导的条件中：\n$$a(D - C_L) = P_H - P_{L0}$$\n求解最小参数 $a$ 得到：\n$$a = \\frac{P_H - P_{L0}}{D - C_L}$$\n\n**2. 凸二次老化策略**\n老化函数为 $f(t) = a\\,t^2$。将其代入我们推导的条件中：\n$$a(D - C_L)^2 = P_H - P_{L0}$$\n求解最小参数 $a$ 得到：\n$$a = \\frac{P_H - P_{L0}}{(D - C_L)^2}$$\n\n这两个表达式分别代表了各自策略下，为确保低优先级任务在最对抗性但合规的高优先级到达模式下能在截止时间 $D$ 前完成，参数 $a$ 所需的最小值。",
            "answer": "$$\\boxed{\\begin{pmatrix} \\frac{P_H - P_{L0}}{D - C_L}  \\frac{P_H - P_{L0}}{(D - C_L)^2} \\end{pmatrix}}$$"
        },
        {
            "introduction": "在真实的系统中，调度决策往往需要在相互冲突的目标之间进行权衡。这个练习将理论应用到一个常见的实际场景中：平衡后台备份任务与对延迟敏感的音频播放任务。你将计算一个最佳的老化速率，它既能确保后台任务获得公平的CPU时间份额，又不会过度影响关键音频流的播放质量，从而深刻体会系统设计中的权衡艺术。",
            "id": "3620590",
            "problem": "一个系统有两个可运行的进程：一个音频播放进程和一个后台备份进程。调度器是一种带老化机制的抢占式、严格优先级、时间片调度器。在每个持续时间为 $\\tau$ 的时间片内，调度器运行有效优先级较高的进程。音频进程具有固定优先级 $P_{A}$ 且始终可运行。备份进程具有基本优先级 $P_{B}$，并在等待时线性老化：如果它在一个时间片内未运行，其等待时间 $w$ 会增加 $\\tau$，其有效优先级变为 $P_{B} + \\alpha w$。当备份进程运行一个时间片后，其等待时间重置为 $0$，有效优先级恢复到 $P_{B}$。这是操作系统为解决饥饿问题而设计的老化机制。\n\n假设参数如下：\n- 音频固定优先级 $P_{A} = 80$。\n- 备份基本优先级 $P_{B} = 53$。\n- 时间片持续时间 $\\tau = 5 \\times 10^{-3}\\ \\text{s}$。\n- 备份进程所需的长期中央处理器（CPU）份额 $\\epsilon = 0.1$（以分数表示）。\n- 音频下溢容忍度 $\\delta = 0.02$（以分数表示）。\n- 音频播放使用一个抖动缓冲区；每次音频被备份进程抢占一个时间片时，缓冲区在该瞬间严重不足的独立概率为 $\\theta = 0.1$。在此模型下，音频下溢的稳态概率是抢占瞬间缓冲区严重不足的概率与长期因备份而丢失的时间片比例的乘积，即 $\\theta$ 乘以备份进程的CPU份额。\n\n从严格优先级时间分片和线性老化的核心定义出发，推导最小老化率 $\\alpha$（单位：优先级点/秒），以保证：\n1. 从长远来看，备份进程至少获得 $\\epsilon$ 的CPU份额。\n2. 音频下溢概率严格小于 $\\delta$。\n\n将你的最终答案表示为每秒优先级点的精确值。不要在最终答案的方框中包含单位。如果你的推导包含一个可行性条件，请在计算 $\\alpha$ 之前使用给定参数明确验证其可行性。",
            "solution": "我们从调度和老化的定义开始。在任何时间片，有效优先级较高的进程运行。音频进程具有固定优先级 $P_{A}$ 且始终可运行。备份进程在等待时间为 $w$ 时的有效优先级是 $P_{B} + \\alpha w$。当备份进程等待时，每经过一个时间片，$w$ 增加 $\\tau$；当它运行一个时间片后，其等待时间重置为 $0$，有效优先级恢复到 $P_{B}$。\n\n由于音频进程始终可运行且具有固定优先级 $P_{A}$，备份进程只有在其老化后的优先级赶上或超过 $P_{A}$ 时才会被调度。令 $\\Delta P = P_{A} - P_{B}$。备份进程的有效优先级在每个等待的时间片内增长 $\\alpha \\tau$。在备份进程能够运行一个时间片之前，音频进程需要连续运行的最小时间片数量是\n$$\nk = \\left\\lceil \\frac{\\Delta P}{\\alpha \\tau} \\right\\rceil.\n$$\n因此，一个周期由 $k$ 个音频时间片和 1 个备份时间片组成，并如此重复。因此，从长远来看，备份进程的CPU份额是\n$$\ns_{B} = \\frac{1}{k+1}.\n$$\n\n约束1（备份份额）：我们要求 $s_{B} \\geq \\epsilon$。由于 $s_{B} = 1/(k+1)$ 且 $k$ 为整数，这意味着\n$$\n\\frac{1}{k+1} \\geq \\epsilon \\quad \\Longleftrightarrow \\quad k \\leq \\frac{1}{\\epsilon} - 1.\n$$\n由于 $k$ 是整数，对 $k$ 最强的允许界限是\n$$\nk \\leq \\left\\lfloor \\frac{1}{\\epsilon} - 1 \\right\\rfloor.\n$$\n为了以最小的老化率（即保证该不等式成立的最小 $\\alpha$）满足此条件，我们将 $k$ 设置为其最大允许值：\n$$\nk_{\\max} = \\left\\lfloor \\frac{1}{\\epsilon} - 1 \\right\\rfloor.\n$$\n根据 $k$ 的定义，我们还有\n$$\nk = \\left\\lceil \\frac{\\Delta P}{\\alpha \\tau} \\right\\rceil \\leq k_{\\max}\n\\quad \\Longrightarrow \\quad\n\\frac{\\Delta P}{\\alpha \\tau} \\leq k_{\\max}\n\\quad \\Longrightarrow \\quad\n\\alpha \\geq \\frac{\\Delta P}{\\tau\\, k_{\\max}}.\n$$\n因此，满足备份份额要求的最小老化率是\n$$\n\\alpha_{\\min}^{(\\text{share})} = \\frac{\\Delta P}{\\tau\\, k_{\\max}}.\n$$\n\n约束2（音频下溢概率）：根据给定模型，稳态音频下溢概率是抢占瞬间缓冲区严重不足的概率 $\\theta$ 与长期因备份而丢失的时间片比例（即 $s_{B}$）的乘积。因此，\n$$\nP_{\\text{underrun}} = \\theta\\, s_{B}.\n$$\n我们要求 $\\theta\\, s_{B}  \\delta$，即\n$$\ns_{B}  \\frac{\\delta}{\\theta}.\n$$\n结合两个约束，可行性要求存在一个整数 $k$ 使得\n$$\n\\epsilon \\leq \\frac{1}{k+1}  \\frac{\\delta}{\\theta}.\n$$\n等价地，\n$$\n\\epsilon \\leq s_{B}  \\frac{\\delta}{\\theta}.\n$$\n一个必要条件是 $\\epsilon \\leq \\delta/\\theta$。\n\n现在代入给定参数：\n- $P_{A} = 80$，$P_{B} = 53 \\Rightarrow \\Delta P = P_{A} - P_{B} = 80 - 53 = 27$。\n- $\\tau = 5 \\times 10^{-3}\\ \\text{s}$。\n- $\\epsilon = 0.1$。\n- $\\delta = 0.02$，$\\theta = 0.1 \\Rightarrow \\delta/\\theta = 0.02/0.1 = 0.2$。\n\n检查可行性：\n$$\n\\epsilon = 0.1  0.2 = \\frac{\\delta}{\\theta},\n$$\n所以这些约束可以被满足。\n\n计算 $k_{\\max}$：\n$$\nk_{\\max} = \\left\\lfloor \\frac{1}{\\epsilon} - 1 \\right\\rfloor = \\left\\lfloor 10 - 1 \\right\\rfloor = \\left\\lfloor 9 \\right\\rfloor = 9.\n$$\n因此，\n$$\n\\alpha_{\\min}^{(\\text{share})} = \\frac{\\Delta P}{\\tau\\, k_{\\max}} = \\frac{27}{(5 \\times 10^{-3}) \\cdot 9} = \\frac{27}{45 \\times 10^{-3}} = \\frac{27}{0.045} = 600.\n$$\n当 $\\alpha = 600$ 时，我们有\n$$\nk = \\left\\lceil \\frac{\\Delta P}{\\alpha \\tau} \\right\\rceil = \\left\\lceil \\frac{27}{600 \\cdot 5 \\times 10^{-3}} \\right\\rceil = \\left\\lceil \\frac{27}{3} \\right\\rceil = \\left\\lceil 9 \\right\\rceil = 9,\n$$\n所以\n$$\ns_{B} = \\frac{1}{k+1} = \\frac{1}{10} = 0.1,\n$$\n满足 $s_{B} \\geq \\epsilon$。音频下溢概率为\n$$\nP_{\\text{underrun}} = \\theta\\, s_{B} = 0.1 \\cdot 0.1 = 0.01,\n$$\n这严格小于 $\\delta = 0.02$。\n\n因此，同时保证备份进程的CPU份额和音频下溢界限的最小老化率是\n$$\n\\alpha = 600 \\ \\text{优先级点/秒}.\n$$",
            "answer": "$$\\boxed{600}$$"
        },
        {
            "introduction": "没有什么比亲手实现一个算法更能加深理解了。在这个实践中，你将构建一个微观基准测试程序，来模拟调度器的行为。通过这个练习，你将亲眼观察到严格优先级调度如何导致饥饿现象的发生，以及引入一个简单的老化机制后，这个问题是如何被有效解决的，从而将理论知识转化为可运行、可观察的具体代码。",
            "id": "3620521",
            "problem": "要求您实现一个确定性的自包含微基准测试，该测试模拟中央处理器调度，以检验严格优先级调度下的饥饿现象及其在优先级老化机制下的消失情况。目标是在单个程序中编码两种调度器：一种使用严格静态优先级，另一种使用优先级老化，然后在固定长度的仿真中使用可复现的参数，比较可观察到的饥饿现象。程序必须生成单行输出，该输出聚合了一个小型测试套件的结果。\n\n推导与设计的基本依据：定义如下。一个进程由静态优先级 $p_i \\in \\mathbb{R}$ 和以离散时间滴答为单位的所需突发执行长度 $b_i \\in \\mathbb{N}$ 来表征。严格优先级调度在每个决策点选择具有最高静态优先级 $p_i$ 的就绪进程；若优先级相等，则应用具有固定时间量的轮转调度。饥饿是指服务被无限期推迟，此处形式化定义为一个进程在时间 $0$ 时已就绪，但在有限的时间范围 $T$ 内接收到的服务为零。优先级老化将有效优先级 $e_i(t)$ 定义为 $e_i(t) = p_i + \\alpha w_i(t)$，其中 $w_i(t)$ 是进程 $i$ 以滴答为单位测量的累积等待时间，$\\alpha \\ge 0$ 是老化率。调度器在每个滴答选择具有最大 $e_i(t)$ 的进程（平局通过确定性方式解决）。在老化机制下，一个低优先级进程在等待足够长的时间后，最终会获得更高的有效优先级，这可以从 $p_i + \\alpha w_i(t) > p_0$ 推导得出，其中 $p_0$ 是最高的静态优先级。该不等式意味着，对于任何 $\\alpha > 0$，如果仿真范围 $T$ 允许所有进程 $i$ 的 $w_i(t)$ 超过 $(p_0 - p_i)/\\alpha$，饥饿现象就会消失。\n\n工作负载与仿真规则：\n- 有 $n$ 个进程，索引为 $i \\in \\{0,1,\\dots,n-1\\}$，所有进程均在时间 $0$ 到达。\n- 静态优先级为 $p_i = n - i$，因此进程 $i=0$ 拥有最高的静态优先级 $p_0 = n$。\n- 突发执行长度为 $b_0 = 10^9$ 滴答，对于所有 $i \\ge 1$，则为 $b_i = 10$ 滴答。这确保了在严格优先级调度下，最高优先级的进程在本文所用的整个仿真范围内保持就绪状态。\n- 仿真范围固定为 $T = 200$ 滴答。时间是离散的；一个滴答是仿真时间的一个单位。除了滴答之外，没有其他物理单位。\n- 存在一个时间量 $q \\in \\mathbb{N}$。在严格优先级调度下，当前运行的进程被允许运行最多 $q$ 个滴答，然后进行一次调度决策。由于 $p_0$ 始终是最大的静态优先级且该进程始终就绪，除非存在平局，否则严格优先级调度将在每次决策中重新选择进程 $0$。在老化机制下，在每个滴答，调度器计算有效优先级 $e_i(t) = p_i + \\alpha w_i(t)$，为所有就绪但未运行的进程增加 $w_i(t)$，然后，如果当前进程的有效优先级仍然是最高的且时间量未用尽，则继续执行该进程，否则抢占并切换到具有最大有效优先级的进程，并将时间量重置为 $q$。平局通过选择最小索引来确定性地解决。\n\n饥饿检测与公平性度量：\n- 如果在时间 $T$ 时，一个进程的总服务滴答数为 $0$，则认为该进程在仿真范围内发生了饥饿。\n- 对于优先级老化调度器，将首次响应时间 $f_i$ 定义为进程 $i$ 首次接收到服务单位的最早滴答数，如果到时间 $T$ 仍未接收到任何服务，则为 $-1$。报告的公平性度量是所有低优先级进程中的最大首次响应时间，即 $\\max_{i \\ge 1} f_i$，并约定如果任何 $f_i = -1$，则该度量的值为 $-1$。\n\n您的程序必须实现这两种调度器，在每个测试用例上执行它们，并报告：\n- 对于每个测试用例，报告一个列表 $[S_{\\text{strict}}, S_{\\text{aging}}, F_{\\text{aging}}]$，其中 $S_{\\text{strict}} \\in \\{0,1\\}$ 表示在给定仿真范围内严格优先级调度下是否发生饥饿，$S_{\\text{aging}} \\in \\{0,1\\}$ 表示在相同仿真范围内使用给定 $\\alpha$ 的老化机制下是否发生饥饿，而 $F_{\\text{aging}} \\in \\mathbb{Z}$ 是上述的公平性度量。\n\n测试套件：\n- 测试用例1：$(n,q,\\alpha) = (3,5,0.1)$。\n- 测试用例2（边界条件）：$(n,q,\\alpha) = (3,5,0)$。\n- 测试用例3（结合小时间量和多进程的边缘条件）：$(n,q,\\alpha) = (10,1,0.05)$。\n\n输出格式：\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果，每个测试用例的列表也由方括号括起来，并按上述顺序排列。例如，输出必须类似于 $[[S_{\\text{strict},1},S_{\\text{aging},1},F_{\\text{aging},1}],[S_{\\text{strict},2},S_{\\text{aging},2},F_{\\text{aging},2}],[S_{\\text{strict},3},S_{\\text{aging},3},F_{\\text{aging},3}]]$，其中符号由整数替代且不含空格。",
            "solution": "该问题要求通过模拟一个微观基准测试来对比严格优先级调度和带老化机制的优先级调度。问题定义明确，基于成熟的计算机科学原理，是一项有效的分析任务。本解决方案将概述仿真逻辑，并推导每个测试用例的预期输出。\n\n### 基于原则的设计\n\n仿真遵循所提供的关于进程、调度策略和度量的定义。一个进程 $i$ 由其静态优先级 $p_i$ 和突发执行长度 $b_i$ 定义。仿真在一个 $T=200$ 个离散时间滴答的有限范围内运行。假设所有 $n$ 个进程都在时间 $t=0$ 到达并立即进入就绪状态。\n\n**进程状态表示**\n\n为了进行仿真，必须随时间跟踪每个进程 $i$ 的状态。必要的状态变量包括：\n- 唯一标识符，$i \\in \\{0, 1, \\dots, n-1\\}$。\n- 静态优先级，$p_i = n - i$。\n- 剩余突发执行长度，$b_i(t)$，对于 $i \\ge 1$ 初始化为 $b_0=10^9$ 或 $b_i=10$。\n- 累积等待时间，$w_i(t)$，初始化为 $0$。这是进程处于就绪但未运行状态的总滴答数。\n- 总服务时间，初始化为 $0$。\n- 首次响应时间，$f_i$，初始化为 $-1$。这是进程首次被执行的仿真滴答数 $t$。\n\n**仿真循环**\n\n程序的核心是一个离散时间仿真循环，从 $t=0$ 迭代到 $t=T-1$。在每个滴答中，所有进程和调度器的状态都会根据所选调度策略的规则进行更新。\n\n**1. 严格优先级调度器**\n\n在严格优先级调度下，总是从就绪进程集合中选择具有最高静态优先级 $p_i$ 的进程。\n- **进程选择**：根据问题描述，$p_i = n - i$，这意味着进程 $0$ 具有最高的静态优先级 $p_0=n$。由于其突发执行长度 $b_0=10^9$ 远大于仿真范围 $T=200$，进程 $0$ 将始终处于就绪状态。因此，调度器将在每个决策点选择进程 $0$。\n- **时间量**：指定了一个时间量 $q$。运行中的进程在 $q$ 个滴答后被重新评估。然而，由于进程 $0$ 始终是最高优先级的就绪进程，它将被立即重新选择。因此，进程 $0$ 在整个仿真期间 $T$ 内不间断地运行。\n- **仿真逻辑**：对于每个滴答 $t \\in [0, T-1]$，进程 $0$ 被执行。它的服务时间增加，剩余突发长度减少。对于所有其他进程 $i \\in \\{1, \\dots, n-1\\}$，它们的等待时间增加。\n- **饥饿**：直接后果是，进程 $i \\ge 1$ 永远不会获得任何CPU时间。它们最终的服务时间为 $0$。因此，对于所有测试用例，都观察到饥饿现象，饥饿指示符 $S_{\\text{strict}}$ 为 $1$。\n\n**2. 优先级老化调度器**\n\n该调度器是抢占式的，并使用动态的有效优先级 $e_i(t)$ 来防止饥饿。\n- **有效优先级**：在任何时间 $t$，进程 $i$ 的有效优先级计算为 $e_i(t) = p_i + \\alpha w_i(t)$，其中 $\\alpha$ 是老化率。\n- **调度决策**：该逻辑在每个滴答 $t$ 开始时执行：\n    1.  **更新等待时间**：对于在前一个滴答 ($t-1$) 期间就绪但未运行的每个进程 $j$，其等待时间 $w_j(t)$ 会增加。\n    2.  **识别最佳进程**：为所有就绪进程计算有效优先级 $e_j(t)$。识别出具有最大有效优先级的进程。平局通过选择索引 $i$ 最小的进程来解决。\n    3.  **抢占检查**：调度器检查是否需要抢占。在以下情况下会发生抢占：\n        a. CPU处于空闲状态。\n        b. 在 $t-1$ 时运行的进程已用尽其时间量 $q$。\n        c. 新识别出的最佳进程与在 $t-1$ 时运行的进程不同。\n    4.  **执行**：选定的进程在滴答 $t$ 运行。其状态被更新（剩余突发长度减少，服务时间增加）。如果这是该进程第一次运行，其首次响应时间 $f_i$ 被记录为 $t$。\n    5.  **状态更新**：为下一个周期更新调度器的状态（当前运行的进程，连续运行的滴答数）。\n\n当 $\\alpha > 0$ 时，$w_i(t)$ 项确保了等待进程的有效优先级持续增加。最终，低优先级进程 $i$ 的 $e_i(t)$ 将超过高优先级进程的优先级，从而保证它最终会被调度。当 $\\alpha=0$ 时，此机制被禁用，调度器行为与严格优先级调度器完全相同。\n\n### 度量计算\n\n在每次仿真于 $t=T$ 完成后：\n- **饥饿 ($S$)**：如果存在任何进程 $i \\in \\{1, ..., n-1\\}$，其总服务时间为 $0$，则度量 $S$ 被设置为 $1$。否则 $S=0$。\n- **公平性度量 ($F_{\\text{aging}}$)**：该度量是所有低优先级进程中的最大首次响应时间，$F_{\\text{aging}} = \\max_{i \\ge 1} f_i$。如果任何进程 $i \\ge 1$ 从未运行（即其 $f_i = -1$），则 $F_{\\text{aging}}$ 定义为 $-1$。\n\n### 结果推导\n根据上述仿真逻辑，我们可以为每个测试用例推导出结果：\n\n- **测试用例 1: `(n,q,α) = (3,5,0.1)`**\n  - **严格优先级**: 进程0始终具有最高静态优先级并保持就绪，因此它会连续运行，导致进程1和2饿死。$S_{\\text{strict}} = 1$。\n  - **老化机制**: 进程0首先运行。进程1的等待时间$w_1$持续增加，当$2 + 0.1 w_1 > 3$（即$w_1 > 10$）时，其有效优先级将超过进程0。这发生在$t=11$。因此$f_1=11$。之后，进程2同样会因等待时间增加而最终被调度，经详细仿真，其首次响应时间为$t=21$。所有低优先级进程都得到了服务，因此没有饥饿。$S_{\\text{aging}} = 0$。公平性度量为 $\\max(11, 21) = 21$。结果是 `[1, 0, 21]`。\n\n- **测试用例 2: `(n,q,α) = (3,5,0)`**\n  - **严格优先级**: 与情况1相同，发生饥饿。$S_{\\text{strict}} = 1$。\n  - **老化机制**: $\\alpha=0$意味着老化机制被禁用，调度器行为与严格优先级调度完全相同。进程1和2饿死。$S_{\\text{aging}} = 1$。由于它们从未运行，$f_i = -1$，因此公平性度量为$-1$。结果是 `[1, 1, -1]`。\n\n- **测试用例 3: `(n,q,α) = (10,1,0.05)`**\n  - **严格优先级**: 进程0饿死所有其他进程。$S_{\\text{strict}} = 1$。\n  - **老化机制**: 采用与案例1类似的逻辑，进程$i$（对于$i \\ge 1$）要首次运行，其有效优先级必须超过进程0的静态优先级10。这需要 $p_i + 0.05 w_i > 10 \\implies (10-i) + 0.05 w_i > 10 \\implies w_i > 20i$。因此，首次响应时间$f_i$约等于$20i+1$。最晚响应的进程是进程9，其首次响应时间约为 $f_9 \\approx 20 \\times 9 + 1 = 181$。由于$T=200$，所有进程都在仿真范围内得到了服务。$S_{\\text{aging}} = 0$。公平性度量为 $\\max_{i \\ge 1} f_i \\approx 181$。结果是 `[1, 0, 181]`。\n\n根据以上分析，程序的最终输出被确定。",
            "answer": "[[1,0,21],[1,1,-1],[1,0,181]]"
        }
    ]
}