{
    "hands_on_practices": [
        {
            "introduction": "在分析复杂的多线程交互之前，我们必须首先理解操作系统内核内部延迟的根本来源。本练习  将探讨内核临界区和中断屏蔽是如何产生不可避免的延迟，这些延迟构成了所有调度性能分析的基础。通过这个练习，你将学会量化调度器分派延迟和中断响应延迟的关键组成部分。",
            "id": "3688825",
            "problem": "一个单核中央处理器（CPU）在操作系统（OS）内部运行一个基于优先级的、完全抢占式的线程调度器。内核有时在禁用线程抢占的临界区中执行。在该临界区的某个子区间内，硬件中断也会被屏蔽。以下条件成立。\n\n- 当内核中禁用线程抢占时，一个更高优先级的就绪线程无法抢占当前正在运行的线程，直到内核到达一个重新启用抢占的调度点。\n- 离开临界区后，内核会执行一次重新调度检查，如果一个更高优先级的线程已就绪，调度器会运行并执行一次上下文切换，然后新线程才开始执行。\n- 当中断被屏蔽时，CPU 会推迟对硬件中断的服务；一旦中断被解除屏蔽，CPU 会以有限的进入延迟跳转到相应的中断服务例程（ISR）。\n\n假设系统行为如下：\n\n- 内核禁用抢占的最坏情况持续时间为 $T_{\\text{crit}} = 84$ 微秒。\n- 在每个这样的临界区内，中断被屏蔽的最坏情况连续子区间为 $T_{\\text{mask}} = 31$ 微秒。\n- 调度器在重新调度检查后进行决策的开销为 $T_{\\text{sched}} = 11$ 微秒，随后的上下文切换开销为 $T_{\\text{cs}} = 19$ 微秒。\n- 硬件中断进入延迟（从中断解除屏蔽到ISR的第一条指令）为 $T_{\\text{irq}} = 7$ 微秒。\n- 忽略任何其他延迟，如缓存效应或不可屏蔽中断，并假设除了所描述的活动外没有并发活动。\n\n在时间 $t_0$，一个高优先级用户线程变为就绪状态，而一个低优先级线程正在运行，并且刚刚进入了禁用抢占的内核临界区。另外，考虑一个硬件事件，它在内核开始屏蔽子区间时恰好引发一个中断。\n\n仅使用抢占式优先级调度、内核临界区、调度点和中断屏蔽的核心定义，推导并计算：\n\n1. 从 $t_0$ 到高优先级用户线程开始执行其第一条用户模式指令的最坏情况时间。\n2. 从硬件事件到达其ISR的第一条指令的最坏情况时间。\n\n将两个最终答案都以微秒表示。无需四舍五入。您的最终答案应在一行中包含这两个数字，按上述顺序列出。",
            "solution": "问题陈述已经过验证，被认为是合理的。它在科学上基于操作系统设计的原理，特别是实时调度和中断处理。该问题定义明确，提供了计算所需延迟的所有必要参数，并且没有矛盾或含糊之处。\n\n该问题要求在具有抢占式、基于优先级调度器的单核系统上进行两种不同的最坏情况延迟计算。\n\n**第一部分：高优先级用户线程的最坏情况延迟**\n\n我们被要求计算从高优先级用户线程变为就绪状态（在时间 $t_0$）到它开始执行其第一条用户模式指令的最坏情况时间。这也被称为分派延迟。\n\n情景规定，在时间 $t_0$，一个低优先级线程正在运行，并且刚刚进入了禁用抢占的内核临界区。这种禁用抢占状态的持续时间的最坏情况值为 $T_{\\text{crit}}$。\n\n1.  **等待抢占点：** 由于当前运行的低优先级线程处于一个不可抢占的临界区，新就绪的高优先级线程必须等待。由于低优先级线程*刚刚进入*该区域，最坏情况的等待时间对应于整个临界区的持续时间，即 $T_{\\text{crit}}$。\n\n2.  **调度器开销：** 离开临界区后，内核到达一个调度点。它执行一次重新调度检查，发现一个更高优先级的线程已就绪。然后调用调度器进行决策。问题陈述此决策过程产生 $T_{\\text{sched}}$ 的开销。\n\n3.  **上下文切换开销：** 在调度器决定运行高优先级线程后，操作系统必须执行一次上下文切换。这涉及保存低优先级线程的状态并加载高优先级线程的状态。此过程有 $T_{\\text{cs}}$ 的开销。\n\n高优先级线程的总最坏情况延迟，我们称之为 $L_{\\text{thread}}$，是这些顺序延迟的总和。组件 $T_{\\text{mask}}$ 和 $T_{\\text{irq}}$ 与此计算无关，因为它们涉及硬件中断处理，而不是线程抢占。\n\n总时间由以下总和给出：\n$$L_{\\text{thread}} = T_{\\text{crit}} + T_{\\text{sched}} + T_{\\text{cs}}$$\n\n代入给定值：\n$T_{\\text{crit}} = 84$ 微秒\n$T_{\\text{sched}} = 11$ 微秒\n$T_{\\text{cs}} = 19$ 微秒\n\n$$L_{\\text{thread}} = 84 \\mu s + 11 \\mu s + 19 \\mu s = 114 \\mu s$$\n\n因此，到高优先级线程开始执行的最坏情况时间是 $114$ 微秒。\n\n**第二部分：硬件中断的最坏情况延迟**\n\n我们被要求计算从硬件事件到达其相应的中断服务例程（ISR）的第一条指令执行的最坏情况时间。这是中断延迟的一种度量。\n\n情景规定，硬件事件在内核开始一个屏蔽中断的连续子区间时恰好引发一个中断。此屏蔽时段的最坏情况持续时间为 $T_{\\text{mask}}$。\n\n1.  **等待中断解除屏蔽：** 当中断到达时，CPU 的中断是禁用（屏蔽）的。CPU 无法响应中断信号，并将推迟处理。内核继续执行。由于中断在屏蔽区间的最初时刻到达，系统必须等待整个最坏情况持续时间的区间过去，中断才会重新启用。这个时间是 $T_{\\text{mask}}$。\n\n2.  **中断进入延迟：** 一旦中断解除屏蔽，CPU 的中断控制器将发出挂起中断的信号。然后，CPU 保存最少的上下文并跳转到相应 ISR 的起始位置。问题将从中断解除屏蔽到执行第一条 ISR 指令的延迟定义为 $T_{\\text{irq}}$。\n\nISR 的总最坏情况延迟，我们称之为 $L_{\\text{irq}}$，是这两个顺序延迟的总和。较大临界区的持续时间（$T_{\\text{crit}}$）和线程调度开销（$T_{\\text{sched}}$，$T_{\\text{cs}}$）在这里不相关。中断分派是一种硬件级机制，通常会绕过线程调度器。一旦中断解除屏蔽，无论哪个线程正在运行，CPU 都会将控制权转移到 ISR。\n\n总时间由以下总和给出：\n$$L_{\\text{irq}} = T_{\\text{mask}} + T_{\\text{irq}}$$\n\n代入给定值：\n$T_{\\text{mask}} = 31$ 微秒\n$T_{\\text{irq}} = 7$ 微秒\n\n$$L_{\\text{irq}} = 31 \\mu s + 7 \\mu s = 38 \\mu s$$\n\n因此，从硬件事件到 ISR 开始的最坏情况时间是 $38$ 微秒。\n\n计算出的两个值是 $114$ 和 $38$，单位均为微秒。",
            "answer": "$$\\boxed{\\begin{pmatrix} 114  38 \\end{pmatrix}}$$"
        },
        {
            "introduction": "在掌握了基本的内核延迟之后，我们现在转向一个多线程环境。本练习  将带你进入固定优先级抢占式调度的核心概念，其中不同重要性的线程会争用CPU。你将应用实时系统中的基础技术——响应时间分析（Response Time Analysis, RTA），来计算一个线程因阻塞和抢占可能经历的最坏情况延迟。",
            "id": "3688824",
            "problem": "一个单处理器操作系统 (OS) 使用固定优先级抢占式调度，并带有短的不可抢占区域：每当一个线程在不可抢占区域中执行时，抢占最多被禁用 $L_{\\mathrm{np}}$ 个时间单位。所有线程都是周期性的且独立的。中央处理器 (CPU) 完全可供软件使用，没有直接内存访问或其他自主设备。\n\n有三个线程，其静态优先级从高到低依次为 $M \\succ H \\succ L$。线程 $M$ 是一个维护线程，其周期为 $T_{M}$，最坏情况执行时间 (WCET) 为 $C_{M}$；线程 $H$ 是我们关心的高优先级应用线程，其 WCET 为 $C_{H}$；线程 $L$ 是任何低优先级的后台活动。假设：\n- 在 $H$ 的一个作业被释放的瞬间，某个低优先级线程可能正在一个不可抢占区域内执行，因此 $H$ 在开始执行前可能会被阻塞一次，阻塞时间最多为 $L_{\\mathrm{np}}$。\n- 在 $H$ 的响应窗口期内，由于 $M$ 的优先级高于 $H$，只要 $M$ 有待处理的工作，它就可能到达并抢占 $H$。\n- 除了不可抢占区域外，没有其他共享资源；除不可抢占性引起的开销外，所有其他开销都可忽略不计，并已包含在 WCET 参数中。\n- 假设 $M$ 和 $H$ 之间存在最坏情况的相位关系，使得 $H$ 经历的延迟最大化。\n\n从第一性原理出发，使用固定优先级抢占式调度和有界不可抢占阻塞的定义，推导出一个刻画 $H$ 作业响应时间上限的方程（即从其释放到完成所经过的时间），该方程需考虑到由不可抢占性引起的一次性阻塞以及所有来自 $M$ 的抢占。然后为以下参数评估此界限：\n- $C_{H} = 2.0$ 毫秒，\n- $C_{M} = 0.8$ 毫秒，\n- $T_{M} = 3.0$ 毫秒，\n- $L_{\\mathrm{np}} = 0.3$ 毫秒。\n\n以毫秒为单位表示 $H$ 的最终响应时间，并将您的答案四舍五入到四位有效数字。",
            "solution": "首先将根据指定标准对问题进行验证。\n\n### 步骤 1：提取已知条件\n从问题陈述中逐字提取的已知条件如下：\n- 系统：单处理器操作系统 (OS)\n- 调度策略：固定优先级抢占式调度\n- 不可抢占区域：最大持续时间 $L_{\\mathrm{np}}$\n- 线程：周期性且独立\n- CPU 可用性：完全可用，无 DMA 或其他自主设备\n- 线程优先级：$M \\succ H \\succ L$（从高到低）\n- 线程 M：周期 $T_{M}$，最坏情况执行时间 (WCET) $C_{M}$\n- 线程 H：WCET $C_{H}$\n- 线程 L：任何低优先级的后台活动\n- 阻塞：线程 $H$ 可能被一个低优先级线程阻塞一次，时间最多为 $L_{\\mathrm{np}}$。\n- 抢占：线程 $M$ 可以抢占 $H$。\n- 开销：所有其他开销都可忽略不计并已包含在 WCET 中。\n- 相位：$M$ 和 $H$ 之间的最坏情况相位关系。\n- 任务 1：推导 $H$ 响应时间上限的方程。\n- 任务 2：为给定参数评估此界限。\n- 参数：\n  - $C_{H} = 2.0$ 毫秒\n  - $C_{M} = 0.8$ 毫秒\n  - $T_{M} = 3.0$ 毫秒\n  - $L_{\\mathrm{np}} = 0.3$ 毫秒\n- 输出要求：最终响应时间以毫秒为单位，四舍五入到四位有效数字。\n\n### 步骤 2：使用提取的已知条件进行验证\n对问题进行验证：\n- **科学依据：** 该问题牢固地建立在实时系统的既定理论之上，特别是关于固定优先级抢占式调度的理论。最坏情况执行时间 (WCET)、周期、优先级、抢占、阻塞和响应时间等概念在该领域都是标准概念。所描述的模型是响应时间分析 (RTA) 的一个经典场景。\n- **适定性：** 该问题是适定的。它要求推导一个标准方程并为一套完整的参数进行求值。目标明确，通过标准的迭代 RTA 方法可以获得一个唯一的、稳定的解。\n- **客观性：** 语言技术性强、精确，没有主观或模糊的陈述。\n- 该问题是自洽的，没有缺失或矛盾的信息。数值参数对于实时嵌入式系统而言是物理上合理的。\n\n### 步骤 3：结论与行动\n该问题有效。现在将提供完整的解答。\n\n### 解答推导\n问题要求计算线程 $H$ 的一个作业的最坏情况响应时间的上限，记为 $R_H$。响应时间是指从作业释放到其完成所经过的总时间。在固定优先级抢占式系统中，线程 $i$ 的响应时间由三部分组成：\n1.  其自身的最坏情况执行时间，$C_i$。\n2.  它可以被低优先级线程阻塞的最长时间，$B_i$。\n3.  抢占它的高优先级线程的总执行时间，称为干扰，$I_i$。\n\n响应时间 $R_i$ 的通用方程为：\n$$R_i = C_i + B_i + I_i$$\n\n对于线程 $H$，这变为：\n$$R_H = C_H + B_H + I_H$$\n\n我们现在将确定线程 $H$ 的每个组成部分。\n\n**1. 执行时间 ($C_H$)：**\n线程 $H$ 的 WCET 已给出，为 $C_H$。\n\n**2. 阻塞时间 ($B_H$)：**\n问题陈述指出，线程 $H$ 在其执行开始时，可能被任何处于不可抢占区域内的低优先级线程 ($L$) 阻塞一次。这种区域的最大持续时间已给出，为 $L_{\\mathrm{np}}$。因此，线程 $H$ 的最大阻塞时间为：\n$$B_H = L_{\\mathrm{np}}$$\n\n**3. 干扰 ($I_H$)：**\n对线程 $H$ 的干扰是由高优先级线程的执行引起的。唯一优先级高于 $H$ 的线程是 $M$。为了计算最坏情况的干扰，我们假设一个“临界瞬间”，即 $H$ 的一个作业与每个高优先级线程的一个作业同时释放。这种配置会使抢占最大化，从而使响应时间最大化。\n\n$H$ 的响应时间 $R_H$ 定义了我们必须考虑抢占的时间窗口。在这个长度为 $R_H$ 的区间内，线程 $M$ 将被释放特定次数。在区间 $R_H$ 内可以释放并执行的 $M$ 的最大作业数由 $\\lceil \\frac{R_H}{T_M} \\rceil$ 给出，其中 $T_M$ 是 $M$ 的周期。\n\n$M$ 的每个作业最多执行其 WCET，$C_M$ 的时间。因此，来自线程 $M$ 对线程 $H$ 的总干扰为：\n$$I_H = \\left\\lceil \\frac{R_H}{T_M} \\right\\rceil C_M$$\n\n**4. H 的响应时间方程：**\n将 $B_H$ 和 $I_H$ 的表达式代入 $H$ 的响应时间方程，我们得到刻画其响应时间上限的方程：\n$$R_H = C_H + L_{\\mathrm{np}} + \\left\\lceil \\frac{R_H}{T_M} \\right\\rceil C_M$$\n这个方程是一个递推关系，因为 $R_H$ 出现在等式两边。它可以通过迭代方法求解。我们定义 $R_H$ 的一个近似序列，记为 $R_H^{(k)}$，其中 $k$ 是迭代索引 ($k=0, 1, 2, \\dots$)。\n\n迭代公式为：\n$$R_H^{(k+1)} = C_H + L_{\\mathrm{np}} + \\left\\lceil \\frac{R_H^{(k)}}{T_M} \\right\\rceil C_M$$\n\n一个合适的迭代初始值 $R_H^{(0)}$ 是 $H$ 的执行时间加上任何阻塞，即假设没有干扰时的响应时间：\n$$R_H^{(0)} = C_H + L_{\\mathrm{np}}$$\n\n迭代持续进行，直到值稳定，即 $R_H^{(k+1)} = R_H^{(k)}$。这个稳定值就是最坏情况响应时间。\n\n### 数值计算\n我们现在使用提供的参数来评估此界限：\n- $C_{H} = 2.0$ 毫秒\n- $C_{M} = 0.8$ 毫秒\n- $T_{M} = 3.0$ 毫秒\n- $L_{\\mathrm{np}} = 0.3$ 毫秒\n\n**迭代 0：**\n用 $H$ 自身的执行时间与阻塞时间之和来初始化响应时间。\n$$R_H^{(0)} = C_H + L_{\\mathrm{np}} = 2.0 + 0.3 = 2.3~\\text{毫秒}$$\n\n**迭代 1：**\n使用 $R_H^{(0)}$ 计算下一个估计值 $R_H^{(1)}$。\n$$R_H^{(1)} = C_H + L_{\\mathrm{np}} + \\left\\lceil \\frac{R_H^{(0)}}{T_M} \\right\\rceil C_M$$\n$$R_H^{(1)} = 2.0 + 0.3 + \\left\\lceil \\frac{2.3}{3.0} \\right\\rceil \\times 0.8$$\n$$R_H^{(1)} = 2.3 + \\lceil 0.766... \\rceil \\times 0.8$$\n$$R_H^{(1)} = 2.3 + 1 \\times 0.8 = 3.1~\\text{毫秒}$$\n\n**迭代 2：**\n使用 $R_H^{(1)}$ 计算 $R_H^{(2)}$。\n$$R_H^{(2)} = C_H + L_{\\mathrm{np}} + \\left\\lceil \\frac{R_H^{(1)}}{T_M} \\right\\rceil C_M$$\n$$R_H^{(2)} = 2.0 + 0.3 + \\left\\lceil \\frac{3.1}{3.0} \\right\\rceil \\times 0.8$$\n$$R_H^{(2)} = 2.3 + \\lceil 1.033... \\rceil \\times 0.8$$\n$$R_H^{(2)} = 2.3 + 2 \\times 0.8 = 2.3 + 1.6 = 3.9~\\text{毫秒}$$\n\n**迭代 3：**\n使用 $R_H^{(2)}$ 计算 $R_H^{(3)}$。\n$$R_H^{(3)} = C_H + L_{\\mathrm{np}} + \\left\\lceil \\frac{R_H^{(2)}}{T_M} \\right\\rceil C_M$$\n$$R_H^{(3)} = 2.0 + 0.3 + \\left\\lceil \\frac{3.9}{3.0} \\right\\rceil \\times 0.8$$\n$$R_H^{(3)} = 2.3 + \\lceil 1.3 \\rceil \\times 0.8$$\n$$R_H^{(3)} = 2.3 + 2 \\times 0.8 = 2.3 + 1.6 = 3.9~\\text{毫秒}$$\n\n由于 $R_H^{(3)} = R_H^{(2)}$，迭代已经收敛。线程 $H$ 的最坏情况响应时间为 $R_H = 3.9$ 毫秒。\n\n问题要求答案四舍五入到四位有效数字。为了满足此要求，值 $3.9$ 写作 $3.900$。",
            "answer": "$$\\boxed{3.900}$$"
        },
        {
            "introduction": "超越严格的优先级模型，现代通用操作系统通常采用公平共享调度器。本练习  让你挑战模拟一个基于“虚拟运行时间”概念的调度器，这与Linux的完全公平调度器（CFS）的原理相似。通过亲手实现其核心逻辑，你将对调度器如何保证竞争线程之间的按权重比例公平获得深刻的实践理解。",
            "id": "3688841",
            "problem": "你需要编写一个完整的程序，该程序基于虚拟运行时归一化原则，模拟一个加权公平线程调度器，其精神源于Completely Fair Scheduler。该模拟必须以纯数学和逻辑术语表达，并且必须是自包含的。线程始终处于可运行状态，每个线程 $i$ 拥有一个权重 $w_i$，该权重可以在预定义的阶段中随时间变化，调度器为每个线程维护一个虚拟运行时 $v_i$，并在每个调度决策点选择具有最小 $v_i$ 的线程（平局必须通过最小的索引 $i$ 来确定性地打破）。模拟以离散的时间量子运行，每个时间量子的大小为 $q$ 毫秒。程序中所有的时间单位都必须视为毫秒，所有输出都必须表示为四舍五入到 $6$ 位小数的无单位十进制小数。\n\n基本定义和事实：\n- 加权处理器共享要求在任何权重固定的区间内，分配给线程 $i$ 的处理时间比例与其权重 $w_i$ 成正比。如果存在 $N$ 个权重为 $w_1,\\dots,w_N$ 的线程，那么线程 $i$ 的理想份额分数为 $s_i = \\dfrac{w_i}{\\sum_{j=1}^{N} w_j}$。等效地，在一个持续时间为 $\\Delta t$ 的小区间内，线程 $i$ 应获得 $\\Delta a_i = \\Delta t \\cdot s_i$ 单位的处理时间。\n- 虚拟运行时 $v_i$ 充当一种平衡势：调度器总是选择具有最小 $v_i$ 的线程。为实现与加权处理器共享相匹配的公平性，在执行期间 $v_i$ 的更新法则必须从上述不变性原则推导得出，并且必须确保低权重线程比高权重线程更快地累积 $v_i$。\n- 总时间 $T$ 是所有阶段持续时间的总和。对于一个权重可能按阶段变化的工作负载，线程 $i$ 的理想累积处理时间 $I_i$ 是 $s_i$ 在整个执行过程中的时间积分：通过权重恒定的阶段进行分段积分。实际累积处理时间 $A_i$ 是为线程 $i$ 执行的离散量子之和。\n\n你的程序必须：\n1. 从加权处理器共享的不变性和虚拟运行时选择的定义出发，推导出一个一致的更新法则，用于当线程 $i$ 运行时，在一个持续时间为 $q$ 的执行量子内更新 $v_i$。\n2. 为一组权重跨阶段变化的测试工作负载模拟调度器：\n   - 在时间 $t=0$ 时，为所有线程初始化 $v_i = 0$。\n   - 对于每个持续时间为 $D_p$ 毫秒且权重向量恒为 $\\{w_i^{(p)}\\}_{i=1}^N$ 的阶段 $p$，执行 $D_p / q$ 次大小为 $q$ 毫秒的离散调度决策。\n   - 在每次决策时，选择具有最小 $v_i$ 的线程（通过最小索引 $i$ 打破平局），运行它 $q$ 毫秒，根据你推导的法则更新其 $v_i$，并使用在 $q$ 毫秒内的份额 $s_i^{(p)} = \\dfrac{w_i^{(p)}}{\\sum_{j=1}^{N} w_j^{(p)}}$ 更新所有线程的理想累积值 $I_i$。\n3. 在最后一个阶段之后，计算公平性差距\n   $$G = \\max_{i \\in \\{1,\\dots,N\\}} \\frac{\\left|A_i - I_i\\right|}{T},$$\n   这是一个无单位的十进制小数。\n\n要实现的测试套件和参数：\n- 对所有情况使用调度量子 $q = 1$ 毫秒。\n- 情况1（理想路径，等权重）：$N = 2$，阶段数 $P = 1$，持续时间 $\\{D_1\\} = \\{40\\}$ 毫秒，每阶段权重 $\\{w^{(1)}\\} = \\{10, 10\\}$。\n- 情况2（动态权重，整数友好）：$N = 3$, $P = 2$，持续时间 $\\{D_1, D_2\\} = \\{60, 40\\}$ 毫秒，每阶段权重 $\\{w^{(1)}\\} = \\{1, 2, 3\\}$ 和 $\\{w^{(2)}\\} = \\{3, 1, 1\\}$。\n- 情况3（极端不平衡，边界覆盖）：$N = 4$, $P = 2$，持续时间 $\\{D_1, D_2\\} = \\{50, 50\\}$ 毫秒，每阶段权重 $\\{w^{(1)}\\} = \\{1, 1, 50, 1\\}$ 和 $\\{w^{(2)}\\} = \\{1, 50, 1, 1\\}$。\n\n最终输出规范：\n- 你的程序必须生成单行输出，其中包含一个逗号分隔的列表，用方括号括起每种情况的公平性差距 $G$，按情况1、情况2、情况3的顺序排列，并四舍五入到 $6$ 位小数。例如，输出格式必须严格符合 `[g_1,g_2,g_3]` 的形式，其中每个 $g_k$ 是一个四舍五入到 $6$ 位的小数。",
            "solution": "问题陈述已经过分析并被确定为**有效**。它在科学上基于操作系统调度理论的原理，问题设定良好，条件清晰明确，并以客观、可形式化的语言表达。模拟所需的所有数据均已提供。\n\n### 1. 虚拟运行时更新法则的推导\n\n加权公平调度器的目标是向一组竞争线程 $\\{1, \\dots, N\\}$ 分配处理时间，使得每个线程 $i$ 获得的时间部分与其分配的权重 $w_i$ 成正比。在给定的时间间隔内，线程 $i$ 的理想处理器份额由 $s_i = \\frac{w_i}{\\sum_{j=1}^{N} w_j}$ 给出。\n\n调度器为每个线程采用一个虚拟运行时 $v_i$。在任何调度点，选择虚拟运行时最小的线程来执行。这种机制确保了在“归一化”意义上运行较少的线程被优先处理，从而推动系统走向公平状态。\n\n为了建立 $v_i$ 的更新法则，我们必须将线程运行的物理时间与其虚拟运行时的增加联系起来。假设线程 $k$ 被选中运行一个持续时间为 $q$ 的离散时间量子。它的实际物理运行时增加了 $q$。为使系统公平，这次执行的“成本”（由其虚拟运行时 $\\Delta v_k$ 的增加来表示）必须根据其权重 $w_k$ 进行缩放。\n\n权重较高（$w_k$）的线程有权获得更多的处理器时间。因此，对于相同数量的物理执行时间，其虚拟运行时应该比低权重线程累积得更慢。这意味着虚拟运行时累积速率与权重之间存在反比关系。\n\n该原则最直接和基本的表述是将虚拟运行时的增加定义为经过的物理时间，并按线程权重的倒数进行缩放。因此，当线程 $k$ 执行一个量子 $q$ 时，其虚拟运行时的更新为：\n$$\n\\Delta v_k = \\frac{q}{w_k}\n$$\n那么，新的虚拟运行时为：\n$$\nv_k \\leftarrow v_k + \\frac{q}{w_k}\n$$\n在此量子期间，所有其他未执行线程 $j \\neq k$ 的虚拟运行时保持不变。\n\n这个更新法则保证了加权公平性。例如，考虑两个权重为 $w_a$ 和 $w_b$ 的线程。它们虚拟运行时增加的速率分别为 $\\frac{q}{w_a}$ 和 $\\frac{q}{w_b}$。为了让调度器长期保持它们的虚拟运行时大致相等（即 $v_a \\approx v_b$），分配的总物理时间 $A_a$ 和 $A_b$ 必须满足 $\\frac{A_a}{w_a} \\approx \\frac{A_b}{w_b}$，这可以简化为 $\\frac{A_a}{A_b} \\approx \\frac{w_a}{w_b}$。这正是加权处理器共享的定义。\n\n### 2. 模拟算法\n\n模拟通过根据指定规则对系统的离散时间演化进行建模来进行。\n\n**初始化：**\n1.  对于一个给定的包含 $N$ 个线程的工作负载，为每个线程 $i \\in \\{1, \\dots, N\\}$ 初始化虚拟运行时 $v_i$、实际累积时间 $A_i$ 和理想累积时间 $I_i$ 为 $0$。\n    $$\n    v_i = 0, \\quad A_i = 0, \\quad I_i = 0 \\quad \\forall i \\in \\{1, \\dots, N\\}\n    $$\n2.  初始化总模拟时间 $T$ 为 $0$。调度量子固定为 $q=1$ 毫秒。\n\n**执行循环：**\n模拟通过一系列阶段 $p \\in \\{1, \\dots, P\\}$ 进行。对于每个阶段 $p$：\n1.  确定阶段持续时间 $D_p$ 和恒定的权重向量 $\\{w_i^{(p)}\\}_{i=1}^N$。\n2.  将阶段持续时间加到总时间上：$T \\leftarrow T + D_p$。\n3.  计算当前阶段的权重总和：$W_{sum}^{(p)} = \\sum_{j=1}^{N} w_j^{(p)}$。\n4.  计算每个线程 $i$ 的理想份额分数：$s_i^{(p)} = w_i^{(p)} / W_{sum}^{(p)}$。\n5.  执行一个 $D_p/q$ 次迭代的循环，代表该阶段内的离散时间量子。在每次迭代中：\n    a. **选择线程：** 找到使虚拟运行时最小化的线程索引 $k$。\n       $$\n       k = \\arg\\min_{j \\in \\{1, \\dots, N\\}} \\{v_j\\}\n       $$\n       如果多个线程具有相同的最小虚拟运行时，则通过选择具有最小索引 $j$ 的线程来打破平局。\n    b. **更新实际时间：** 为所选线程 $k$ 增加实际时间。\n       $$\n       A_k \\leftarrow A_k + q\n       $$\n    c. **更新虚拟运行时：** 使用当前阶段的权重 $w_k^{(p)}$ 更新所选线程 $k$ 的虚拟运行时。\n       $$\n       v_k \\leftarrow v_k + \\frac{q}{w_k^{(p)}}\n       $$\n    d. **更新理想时间：** 对**所有**线程 $j \\in \\{1, \\dots, N\\}$，根据它们在当前阶段的份额增加其理想累积时间。\n       $$\n       I_j \\leftarrow I_j + q \\cdot s_j^{(p)}\n       $$\n\n**最终计算：**\n在所有阶段模拟完毕后：\n1.  计算公平性差距 $G$，定义为所有线程的实际累积时间与理想累积时间之间归一化偏差的最大值。\n    $$\n    G = \\max_{i \\in \\{1,\\dots,N\\}} \\frac{\\left|A_i - I_i\\right|}{T}\n    $$\n对提供的每个测试用例执行模拟，并报告最终的公平性差距 $G$。情况1和情况2的特定权重和持续时间经过选择，使得完美的零误差调度成为可能，从而导致 $G=0$。情况3使用的参数中，阶段持续时间不是公平周期长度的倍数，这会导致在阶段边界处产生非零差距，因此最终的 $G$ 也为非零。",
            "answer": "$$\\boxed{[0.000000, 0.000000, 0.001132]}$$"
        }
    ]
}