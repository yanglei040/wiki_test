{
    "hands_on_practices": [
        {
            "introduction": "Proportional-share scheduling is a key mechanism for ensuring fairness, where a process's priority is a weight that dictates its share of CPU time. This exercise challenges you to derive the fundamental relationship between a process's weight and the CPU time it receives over an interval $T$. By working from first principles of proportionality and resource conservation, you will solidify your understanding of how these schedulers operate in a steady state .",
            "id": "3671520",
            "problem": "An operating system uses a proportional-share scheduler to allocate Central Processing Unit (CPU) time among $n$ continuously runnable, CPU-bound classes, indexed by $i \\in \\{1,\\dots,n\\}$. Each class $i$ is assigned a positive priority weight $w_i \\in \\mathbb{R}_{>0}$. The scheduler is designed according to the following core definitions: (i) it is work-conserving, meaning the CPU never idles when any class is runnable, and (ii) it enforces proportionality, meaning that in steady state a class’s long-run service rate is proportional to its weight. The CPU capacity is normalized to $1$ unit of service per unit time. Consider an observation window of length $T > 0$ during which all $n$ classes remain runnable and the system remains in steady state.\n\nUsing only these definitions and the conservation of capacity, derive a closed-form expression for the expected CPU time allocated to class $i$ over the duration $T$ in terms of $w_i$, $\\sum_{j=1}^{n} w_j$, and $T$. Express your final answer as a single analytic expression. Do not include units in your final answer.",
            "solution": "The problem requires the derivation of a closed-form expression for the expected Central Processing Unit (CPU) time allocated to a specific class $i$ over a given time interval. We will formalize the provided definitions and constraints into a mathematical model to arrive at the solution.\n\nFirst, let's define the primary variables. There are $n$ runnable classes, indexed by $i \\in \\{1, \\dots, n\\}$. Each class $i$ is assigned a positive priority weight, denoted by $w_i$, where $w_i \\in \\mathbb{R}_{>0}$. The total duration of the observation window is $T > 0$. The total CPU capacity is normalized to $1$ unit of service per unit of time.\n\nLet $S_i$ be the long-run service rate allocated to class $i$. This represents the fraction of the total CPU capacity that class $i$ receives. The problem states that this rate is proportional to the class's weight $w_i$. We can express this proportionality relationship mathematically by introducing a constant of proportionality, $k$:\n$$S_i = k \\cdot w_i$$\nThis constant $k$ is the same for all classes $i=1, \\dots, n$, as it establishes the system-wide proportionality between weight and service rate.\n\nThe next piece of information is that the scheduler is work-conserving. A work-conserving scheduler ensures that the CPU does not idle as long as there is at least one runnable process. The problem statement specifies that all $n$ classes are continuously runnable throughout the observation window of length $T$. Consequently, the CPU is fully utilized during this period. The sum of the service rates allocated to all classes must therefore equal the total CPU capacity. Given that the capacity is normalized to $1$, we can write a conservation law:\n$$\\sum_{i=1}^{n} S_i = 1$$\nWe can now determine the value of the proportionality constant $k$ by substituting the expression for $S_i$ into the conservation equation:\n$$\\sum_{i=1}^{n} (k \\cdot w_i) = 1$$\nSince $k$ is a constant with respect to the summation index $i$, we can factor it out of the sum:\n$$k \\left( \\sum_{i=1}^{n} w_i \\right) = 1$$\nThe problem states that each weight $w_i$ is a positive real number. Therefore, the sum $\\sum_{j=1}^{n} w_j$ is strictly positive, and we can safely divide by it. Solving for $k$, we get:\n$$k = \\frac{1}{\\sum_{j=1}^{n} w_j}$$\nHere, we use $j$ as the summation index in the denominator as suggested by the prompt, though it is a dummy variable.\n\nWith the constant $k$ determined, we can now express the service rate $S_i$ for any class $i$ in terms of the given weights:\n$$S_i = k \\cdot w_i = \\frac{w_i}{\\sum_{j=1}^{n} w_j}$$\nThis equation gives the fraction of CPU time that class $i$ receives per unit time.\n\nFinally, we need to find the total expected CPU time allocated to class $i$ over the duration $T$. Let this quantity be denoted by $C_i(T)$. Since the system is specified to be in a steady state, the service rate $S_i$ is constant over the interval $T$. The total allocated time is the rate of allocation multiplied by the duration of the interval:\n$$C_i(T) = S_i \\times T$$\nSubstituting our derived expression for $S_i$ yields the final closed-form expression:\n$$C_i(T) = \\left( \\frac{w_i}{\\sum_{j=1}^{n} w_j} \\right) T$$\nThis can be written more compactly as:\n$$C_i(T) = \\frac{w_i T}{\\sum_{j=1}^{n} w_j}$$\nThis expression gives the expected CPU time for class $i$ in terms of its weight $w_i$, the sum of all weights $\\sum_{j=1}^{n} w_j$, and the observation time $T$, as required.",
            "answer": "$$\\boxed{\\frac{w_i T}{\\sum_{j=1}^{n} w_j}}$$"
        },
        {
            "introduction": "While priority scheduling is powerful, it is susceptible to critical flaws like priority inversion, where a high-priority task is unduly delayed by a medium-priority task due to resource contention. This practice places you in a classic priority inversion scenario, allowing you to quantitatively measure the delay and compare it to a system using Priority Inheritance (PI). This exercise demonstrates the dramatic performance improvement gained by a well-designed scheduling protocol that explicitly handles blocking on shared resources .",
            "id": "3623596",
            "problem": "Consider a preemptive fixed-priority time-sharing scheduler in a multiprogrammed operating system. Three tasks are present: a high-priority task $H$, a medium-priority task $M$, and a low-priority task $L$. Task $L$ currently holds a mutual exclusion (mutex) lock $X$ protecting a short critical section. At time $t=0$, task $L$ is executing inside $X$ with a remaining critical-section execution time of $c_{L}=2.4\\,\\mathrm{ms}$. At $t=0^{+}$, task $H$ arrives and immediately attempts to acquire $X$, thus blocking until $X$ is released. Also at $t=0^{+}$, task $M$ becomes ready to run with a single compute burst of $c_{M}=7.6\\,\\mathrm{ms}$ and requires no locks or input/output. Assume a single Central Processing Unit (CPU), preemptive fixed-priority scheduling, $H \\succ M \\succ L$ (higher priority denoted by $\\succ$), and that there are no other tasks or arrivals. Assume $0$ scheduling, context-switch, and lock/unlock overheads. \n\nDefine the priority inversion delay experienced by $H$ as the time from when $H$ requests $X$ at $t=0^{+}$ to when $H$ acquires $X$. Under standard scheduling without Priority Inheritance (PI), when a high-priority task $H$ blocks on a lock held by a lower-priority task $L$, any medium-priority task $M$ that is ready will preempt $L$, thereby extending $H$’s wait. Under Priority Inheritance (PI), when $H$ blocks on $X$, the lock holder $L$ temporarily inherits $H$’s priority until $X$ is released, preventing preemption by $M$.\n\nStarting from first principles of preemptive fixed-priority scheduling and the semantics of blocking and priority inheritance, derive expressions for the lock wait time of $H$ without PI and with PI. Then, compute the ratio \n$$R=\\frac{\\text{lock wait time without PI}}{\\text{lock wait time with PI}}.$$\nProvide $R$ as a pure number (dimensionless). Round your answer to four significant figures.",
            "solution": "This problem requires the analysis of task execution on a single Central Processing Unit (CPU) under a preemptive fixed-priority scheduling policy. The core of the problem is to determine the lock wait time experienced by a high-priority task, $H$, under two different scenarios: one without and one with the Priority Inheritance (PI) protocol. The lock wait time for task $H$ is defined as the duration from when it requests a mutex lock $X$ to when it successfully acquires it.\n\nLet us denote the priorities of the tasks as $P_H$, $P_M$, and $P_L$. The problem states that $H \\succ M \\succ L$, which translates to $P_H > P_M > P_L$. The scheduler is preemptive, meaning if a task with priority $P_{\\text{new}}$ becomes ready while a task with priority $P_{\\text{current}}$ is running, the running task will be preempted if $P_{\\text{new}} > P_{\\text{current}}$.\n\nThe initial conditions at time $t=0$ are:\n- Task $L$ (low priority) is executing in a critical section protected by mutex $X$.\n- The remaining execution time for $L$ to complete its critical section is $c_L = 2.4\\,\\mathrm{ms}$.\n\nAt time $t=0^{+}$ (an infinitesimally small time after $t=0$):\n- Task $H$ (high priority) arrives and requests lock $X$. Since $X$ is held by $L$, task $H$ enters a \"Blocked\" state.\n- Task $M$ (medium priority) becomes \"Ready\" to execute, with a CPU burst of duration $c_M = 7.6\\,\\mathrm{ms}$.\n\nWe analyze the system's evolution in two separate cases.\n\n### Case 1: Scheduling without Priority Inheritance (PI)\n\nIn this scenario, task priorities are static and do not change.\n\n1.  At $t=0^{+}$, the scheduler must decide which task to run. The states of the tasks are:\n    -   Task $H$: Blocked (waiting for lock $X$). Not eligible to run.\n    -   Task $M$: Ready.\n    -   Task $L$: Was running, but a scheduling decision must be made due to the arrival of a ready task $M$. For the purpose of scheduling, $L$ is considered Ready.\n\n2.  The scheduler compares the priorities of all *Ready* tasks: $P_M$ and $P_L$. Since $P_M > P_L$, the scheduler preempts task $L$ and dispatches task $M$.\n\n3.  From $t=0^{+}$ until task $M$ completes its CPU burst, task $M$ will occupy the CPU. This duration is $c_M = 7.6\\,\\mathrm{ms}$. During this interval, task $L$ remains in the Ready state, unable to make progress on its critical section. This is the classic priority inversion scenario where a medium-priority task delays a high-priority task.\n\n4.  At $t=c_M = 7.6\\,\\mathrm{ms}$, task $M$ completes its execution and is no longer Ready. The scheduler now re-evaluates. The only Ready task is $L$ (task $H$ is still Blocked). Therefore, the scheduler dispatches task $L$.\n\n5.  Task $L$ now runs for its remaining critical section time, $c_L = 2.4\\,\\mathrm{ms}$. It finishes its critical section at time $t = c_M + c_L = 7.6\\,\\mathrm{ms} + 2.4\\,\\mathrm{ms} = 10.0\\,\\mathrm{ms}$.\n\n6.  At $t=10.0\\,\\mathrm{ms}$, task $L$ releases the mutex lock $X$. The release of $X$ unblocks task $H$, changing its state from Blocked to Ready.\n\n7.  The scheduler must again make a decision. The Ready tasks are now $H$ and $L$. Since $P_H > P_L$, the scheduler immediately preempts $L$ and dispatches $H$. Task $H$ acquires the lock $X$ at this time.\n\nThe lock wait time for $H$ without PI, denoted $W_{\\text{noPI}}$, is the total time elapsed from its request at $t=0^{+}$ until it acquires the lock at $t=10.0\\,\\mathrm{ms}$.\n$$W_{\\text{noPI}} = c_M + c_L = 7.6\\,\\mathrm{ms} + 2.4\\,\\mathrm{ms} = 10.0\\,\\mathrm{ms}$$\n\n### Case 2: Scheduling with Priority Inheritance (PI)\n\nIn this scenario, the priority of a lock-holding task can be temporarily elevated.\n\n1.  At $t=0^{+}$, task $H$ attempts to acquire lock $X$ and blocks because $L$ holds it.\n2.  The Priority Inheritance protocol is triggered. Task $L$, the lock holder, temporarily inherits the priority of the highest-priority task it is blocking. In this case, $L$ inherits the priority of $H$. Let the effective priority of $L$ be $P'_L$. Then $P'_L = P_H$.\n3.  Simultaneously, task $M$ becomes Ready.\n4.  The scheduler must decide which task to run. The states of the tasks are:\n    -   Task $H$: Blocked.\n    -   Task $M$: Ready.\n    -   Task $L$: Ready, with an effective priority $P'_L = P_H$.\n\n5.  The scheduler compares the priorities of the Ready tasks: $M$ and $L$. Since $P'_L = P_H$ and $P_H > P_M$, the effective priority of $L$ is greater than the priority of $M$. Therefore, task $M$ cannot preempt task $L$. Task $L$ continues to run.\n\n6.  Task $L$ executes for its remaining critical section time, $c_L = 2.4\\,\\mathrm{ms}$. It starts at $t=0$ and finishes at $t=c_L = 2.4\\,\\mathrm{ms}$.\n\n7.  At $t=2.4\\,\\mathrm{ms}$, task $L$ releases the lock $X$. At this moment:\n    -   The priority of $L$ reverts to its original low value, $P_L$.\n    -   Task $H$ is unblocked and becomes Ready.\n\n8.  The scheduler makes a decision. The Ready tasks are $H$, $M$, and $L$. Their priorities are $P_H > P_M > P_L$. The scheduler dispatches the highest-priority task, $H$. Thus, task $H$ acquires the lock $X$ at $t=2.4\\,\\mathrm{ms}$.\n\nThe lock wait time for $H$ with PI, denoted $W_{\\text{PI}}$, is the total time elapsed from its request at $t=0^{+}$ until it acquires the lock at $t=2.4\\,\\mathrm{ms}$.\n$$W_{\\text{PI}} = c_L = 2.4\\,\\mathrm{ms}$$\n\n### Calculation of the Ratio R\n\nThe problem asks for the ratio $R = \\frac{\\text{lock wait time without PI}}{\\text{lock wait time with PI}}$.\n$$R = \\frac{W_{\\text{noPI}}}{W_{\\text{PI}}} = \\frac{c_M + c_L}{c_L}$$\nSubstituting the given numerical values:\n$$R = \\frac{7.6 + 2.4}{2.4} = \\frac{10.0}{2.4}$$\nTo compute the value:\n$$R = \\frac{10}{2.4} = \\frac{100}{24} = \\frac{25}{6} = 4.1666...$$\nThe problem requires the answer to be rounded to four significant figures.\n$$R \\approx 4.167$$\nThis ratio quantifies the performance improvement gained by using Priority Inheritance to mitigate the effects of priority inversion in this specific scenario.",
            "answer": "$$\\boxed{4.167}$$"
        },
        {
            "introduction": "In many systems, especially those with real-time requirements, static priorities are insufficient, and dynamic priorities that change over time are used to meet deadlines. This practice explores a deadline-aware aging policy, where a job's priority increases as it waits in the ready queue. You will work with a sophisticated, non-linear aging function to determine the critical parameter value needed to guarantee schedulability, providing insight into how schedulers are engineered to meet strict timing constraints .",
            "id": "3671612",
            "problem": "Consider a single-processor Central Processing Unit (CPU) system running a fully preemptive highest-priority-first scheduler. By definition, at any instant the scheduler selects the ready job with the highest dynamic priority value; ties are broken deterministically by a fixed rule favoring the deadline-constrained job only if its dynamic priority strictly exceeds the competing value by a positive margin. An aging policy is used to increase a job’s dynamic priority as a function of its waiting time, where waiting time is defined as the elapsed time since the job entered the ready queue without having completed its required service.\n\nA job $J$ arrives at time $0$ with a strict relative deadline $D$ and required service time $S$. The system’s priority scale is bounded with a maximum allowed value $P_{\\max}$. Job $J$ has initial dynamic priority $p_{0}$. All other jobs in the system have stationary (non-aging) priorities, with the highest competing value denoted $P^{\\star}$. To guarantee completion by its deadline under preemptive highest-priority-first scheduling, it is sufficient for job $J$ to start executing continuously by waiting time $w^{\\star} = D - S$ and then run non-stop until completion, which demands that its dynamic priority at $w^{\\star}$ strictly exceed the maximum competitor by a positive margin $\\delta$, that is,\n\n$$\np(w^{\\star}) \\geq P^{\\star} + \\delta.\n$$\n\nTo avoid collapsing priority differentiation (i.e., to maintain separability among jobs early in their lifetimes), the aging function must grow slowly when $w$ is small but accelerate as the deadline approaches, while remaining bounded by $P_{\\max}$. Consider the following deadline-aware aging family that satisfies these constraints:\n\n$$\np(w) = p_{0} + \\left(P_{\\max} - p_{0}\\right)\\left(1 - \\exp\\!\\left(-\\alpha \\cdot \\frac{w}{D - w}\\right)\\right), \\quad \\text{for } 0 \\leq w < D,\n$$\n\nwith parameter $\\alpha > 0$. Assume that the CPU executes at unit rate when scheduled.\n\nGiven the numerical parameters $D = 100\\,\\text{ms}$, $S = 30\\,\\text{ms}$, $p_{0} = 10$, $P_{\\max} = 100$, $P^{\\star} = 65$, and $\\delta = 1$, determine the minimal value of $\\alpha$ that guarantees job $J$ will begin continuous execution by $w^{\\star} = D - S$ and thus complete by its deadline according to the scheduler’s rule. Round your final answer for $\\alpha$ to four significant figures. Express the final answer as a dimensionless quantity.",
            "solution": "The problem requires the determination of the minimal value of the aging parameter $\\alpha$ that ensures a specific job, $J$, completes its execution by its deadline. This is framed as a schedulability condition based on the job's dynamic priority.\n\nThe governing condition, as stated in the problem, is that the dynamic priority of job $J$, denoted $p(w)$, must satisfy the following inequality at a critical waiting time $w^{\\star}$:\n$$p(w^{\\star}) \\geq P^{\\star} + \\delta$$\nHere, $P^{\\star}$ is the highest priority of any competing job, and $\\delta$ is a specified positive margin.\n\nThe critical waiting time $w^{\\star}$ is the latest possible time the job can start its continuous execution and still meet its deadline $D$, given it requires a service time of $S$. This is calculated as:\n$$w^{\\star} = D - S$$\nWith the provided values $D = 100\\,\\text{ms}$ and $S = 30\\,\\text{ms}$, we find:\n$$w^{\\star} = 100 - 30 = 70\\,\\text{ms}$$\n\nThe dynamic priority $p(w)$ is defined by the given aging function:\n$$p(w) = p_{0} + \\left(P_{\\max} - p_{0}\\right)\\left(1 - \\exp\\!\\left(-\\alpha \\cdot \\frac{w}{D - w}\\right)\\right)$$\nwhere $p_0$ is the initial priority, $P_{\\max}$ is the maximum possible priority, and $\\alpha$ is the aging parameter.\n\nTo find the minimal value of $\\alpha$ that satisfies the schedulability condition, we first examine the dependence of $p(w^{\\star})$ on $\\alpha$. The term inside the exponential is $-\\alpha \\cdot \\frac{w^{\\star}}{D - w^{\\star}}$. Since $\\alpha > 0$ and the ratio $\\frac{w^{\\star}}{D-w^{\\star}}$ is positive (as $0 \\le w^{\\star} < D$), the argument of the exponential is negative. As $\\alpha$ increases, this negative argument decreases (becomes more negative). Consequently, the value of the exponential term, $\\exp(-\\dots)$, decreases towards $0$. This causes the term $(1 - \\exp(-\\dots))$ to increase, which in turn causes $p(w^{\\star})$ to increase. Therefore, $p(w^{\\star})$ is a monotonically increasing function of $\\alpha$.\n\nGiven this monotonic relationship, the minimal value of $\\alpha$ that satisfies the inequality $p(w^{\\star}) \\geq P^{\\star} + \\delta$ is the value for which equality holds:\n$$p(w^{\\star}) = P^{\\star} + \\delta$$\n\nWe can express this equality by substituting the aging function evaluated at $w^{\\star}$:\n$$p_{0} + \\left(P_{\\max} - p_{0}\\right)\\left(1 - \\exp\\!\\left(-\\alpha \\cdot \\frac{w^{\\star}}{D - w^{\\star}}\\right)\\right) = P^{\\star} + \\delta$$\n\nNow, we substitute the given numerical values into this equation: $p_{0} = 10$, $P_{\\max} = 100$, $P^{\\star} = 65$, $\\delta = 1$, $D = 100$, and $w^{\\star} = 70$. The ratio in the exponent is:\n$$\\frac{w^{\\star}}{D - w^{\\star}} = \\frac{70}{100 - 70} = \\frac{70}{30} = \\frac{7}{3}$$\n\nSubstituting all values into the equation:\n$$10 + (100 - 10)\\left(1 - \\exp\\!\\left(-\\alpha \\cdot \\frac{7}{3}\\right)\\right) = 65 + 1$$\n$$10 + 90\\left(1 - \\exp\\!\\left(-\\frac{7\\alpha}{3}\\right)\\right) = 66$$\n\nWe now proceed to solve this equation for $\\alpha$.\n$$90\\left(1 - \\exp\\!\\left(-\\frac{7\\alpha}{3}\\right)\\right) = 66 - 10$$\n$$90\\left(1 - \\exp\\!\\left(-\\frac{7\\alpha}{3}\\right)\\right) = 56$$\n$$1 - \\exp\\!\\left(-\\frac{7\\alpha}{3}\\right) = \\frac{56}{90}$$\nSimplifying the fraction gives $\\frac{56}{90} = \\frac{28}{45}$.\n$$1 - \\exp\\!\\left(-\\frac{7\\alpha}{3}\\right) = \\frac{28}{45}$$\n\nIsolating the exponential term:\n$$\\exp\\!\\left(-\\frac{7\\alpha}{3}\\right) = 1 - \\frac{28}{45}$$\n$$\\exp\\!\\left(-\\frac{7\\alpha}{3}\\right) = \\frac{45}{45} - \\frac{28}{45} = \\frac{17}{45}$$\n\nTo find $\\alpha$, we take the natural logarithm of both sides of the equation:\n$$\\ln\\left(\\exp\\!\\left(-\\frac{7\\alpha}{3}\\right)\\right) = \\ln\\left(\\frac{17}{45}\\right)$$\n$$-\\frac{7\\alpha}{3} = \\ln\\left(\\frac{17}{45}\\right)$$\n\nFinally, we solve for $\\alpha$:\n$$\\alpha = -\\frac{3}{7} \\ln\\left(\\frac{17}{45}\\right)$$\nUsing the logarithmic identity $\\ln(a/b) = -\\ln(b/a)$, we can express $\\alpha$ as:\n$$\\alpha = \\frac{3}{7} \\ln\\left(\\frac{45}{17}\\right)$$\n\nThis provides the exact analytical solution for $\\alpha$. The problem asks for a numerical answer rounded to four significant figures. We compute the value:\n$$\\alpha = \\frac{3}{7} \\ln\\left(\\frac{45}{17}\\right) \\approx \\frac{3}{7} \\ln(2.6470588...)$$\n$$\\alpha \\approx 0.4285714 \\times 0.9734901...$$\n$$\\alpha \\approx 0.41721005...$$\n\nRounding to four significant figures, we get:\n$$\\alpha \\approx 0.4172$$\nThis result is a dimensionless quantity, which is consistent with the requirement that the argument of the exponential function be dimensionless.",
            "answer": "$$\\boxed{0.4172}$$"
        }
    ]
}