{
    "hands_on_practices": [
        {
            "introduction": "死锁是并发编程中最危险的陷阱之一。这个练习将通过一个看似简单的场景，揭示不当使用信号量如何导致灾难性的系统停滞。我们将直接对比二进制信号量和计数信号量，通过分析一个线程尝试两次获取同一信号量的行为，来理解不同类型的信号量如何从根本上改变死锁风险的性质 ()。",
            "id": "3629421",
            "problem": "考虑一个操作系统（OS），其标准信号量实现满足以下核心定义：信号量维护一个整数状态 $s$；一个 $wait$ 操作是原子的，当 $s  0$ 时将 $s$ 减一，当 $s = 0$ 时阻塞调用者；一个 $signal$ 操作将 $s$ 加一，并可能唤醒一个被阻塞的调用者。二元信号量将 $s$ 限制在 $\\{0, 1\\}$，而计数信号量允许 $s \\in \\mathbb{N}$（非负整数集）。这些操作不跟踪所有权且是非递归的，这意味着线程在尝试多次获取时，不能依靠其身份来绕过因 $wait$ 导致的阻塞。\n\n设计并分析以下两个实验，使用 $n$ 个线程，标记为 $T_1, T_2, \\dots, T_n$，其中每个线程执行序列 $wait$; $wait$; $signal$; $signal$，且两次 $wait$ 操作之间没有介入的 $signal$ 操作：\n\n- 实验 $1$：一个初始状态为 $s_B = 1$ 的二元信号量 $B$。每个线程 $T_i$ 执行 $wait(B)$; $wait(B)$; (一些工作); $signal(B)$; $signal(B)$。\n- 实验 $2$：一个初始状态为 $s_C = n$ 的计数信号量 $C$。每个线程 $T_i$ 执行 $wait(C)$; $wait(C)$; (一些工作); $signal(C)$; $signal(C)$。\n\n假设调度器可以任意交错操作，但保证 $wait$ 和 $signal$ 的原子性。仅使用关于 $wait$/$signal$ 语义和死锁的必要条件（互斥、持有并等待、不可抢占和循环等待）的基本原理，确定哪些关于死锁风险及其预防的陈述是正确的。\n\n选择所有适用的选项：\n\nA. 在实验 $1$ 中，必然发生死锁：第一个执行其第二次 $wait(B)$ 的线程在持有着唯一单元的情况下被阻塞，并且没有线程能够到达 $signal(B)$。\n\nB. 在实验 $2$ 中，不可能发生死锁，因为初始状态 $s_C = n$ 为每个线程提供一个单元，并且每个线程最终都将在没有任何 $signal(C)$ 发生的情况下获得其第二个单元。\n\nC. 在实验 $2$ 中，如果 $n$ 个线程中的每一个都恰好获得一个单元，然后在第二次 $wait(C)$ 时阻塞，就可能发生死锁；要排除在这种每个线程需要 $2$ 个单元的模式下发生死锁的可能性，初始计数值必须至少为 $n + 1$。\n\nD. 为了避免实验 $2$ 中的死锁，计数信号量必须初始化为 $2n$ 个单元；任何更小的初始计数值都会使死锁不可避免。",
            "solution": "首先验证问题陈述，以确保其科学上合理、表述清晰且客观。\n\n### 步骤 1：提取已知信息\n- **信号量定义**：一个整数状态 $s$；一个原子的 `wait` 操作，当 $s  0$ 时将 $s$ 减一，当 $s = 0$ 时阻塞；一个原子的 `signal` 操作，将 $s$ 加一。\n- **信号量类型**：二元信号量限制 $s \\in \\{0, 1\\}$。计数信号量允许 $s \\in \\mathbb{N}$（非负整数）。\n- **信号量属性**：操作是非递归的，这意味着持有信号量单元的线程在信号量计数为 $0$ 时，执行后续的 `wait` 操作仍可能被阻塞。\n- **系统设置**：$n$ 个线程，标记为 $T_1, T_2, \\dots, T_n$。\n- **线程行为**：每个线程 $T_i$ 执行序列 `wait`; `wait`; `(一些工作)`; `signal`; `signal`。\n- **实验 1**：一个初始状态为 $s_B = 1$ 的二元信号量 $B$。每个线程执行 `wait(B)`; `wait(B)`; `...`; `signal(B)`; `signal(B)`。\n- **实验 2**：一个初始状态为 $s_C = n$ 的计数信号量 $C$。每个线程执行 `wait(C)`; `wait(C)`; `...`; `signal(C)`; `signal(C)`。\n- **调度器**：调度器可以任意交错线程操作，但保证 `wait` 和 `signal` 的原子性。\n- **任务**：根据基本原理确定哪些关于死锁的陈述是正确的。\n\n### 步骤 2：使用提取的已知信息进行验证\n该问题基于计算机科学和操作系统理论中标准的、定义明确的概念，即计数和二元信号量、线程和死锁。提供的信号量操作定义是标准的。所描述的场景是抽象的，但代表了并发编程中有效且可分析的情况。问题是自包含的，提供了所有必要的初始条件和行为规则。语言精确且客观。没有科学或逻辑上的矛盾，问题表述清晰，可以对死锁条件进行确定性分析。\n\n### 步骤 3：结论与行动\n问题陈述是**有效的**。可以进行全面分析。\n\n### 推导与分析\n\n**实验 1 分析：二元信号量**\n\n在这个实验中，我们使用一个初始状态为 $s_B = 1$ 的二元信号量 $B$。有 $n$ 个线程，每个线程都试图连续执行两次 `wait(B)`。\n\n考虑任何一个首先被调度的线程，比如 $T_1$。\n1.  $T_1$ 执行其第一次 `wait(B)`。由于 $s_B = 1  0$，操作成功。信号量的状态被减一，因此 $s_B$ 变为 $0$。$T_1$ 现在名义上持有着信号量。\n2.  接下来，$T_1$ 试图执行其第二次 `wait(B)`。此时，$s_B = 0$。根据 `wait` 操作的定义，$T_1$ 将被阻塞，因为它必须等待 $s_B$ 变为正数。\n3.  问题陈述中说明信号量是非递归的。这意味着即使是 $T_1$ 导致 $s_B$ 变为 $0$，它也无法在其第二次 `wait(B)` 时绕过阻塞条件。\n4.  一旦 $T_1$ 被阻塞，它就无法继续执行其 `signal(B)` 调用。$T_1$ 解除阻塞的唯一方法是让另一个线程执行 `signal(B)`。\n5.  考虑任何其他线程 $T_j$（其中 $j \\ne 1$）。如果调度器运行 $T_j$，它将尝试其第一次 `wait(B)`。然而，由于 $s_B$ 已经为 $0$（因为 $T_1$ 的第一次 `wait`），$T_j$ 也将被阻塞。\n6.  这种情况适用于所有 $n$ 个线程。一个线程（$T_1$）在其第二次 `wait(B)` 时被阻塞，而所有其他线程将在其第一次 `wait(B)` 时被阻塞。没有线程能够到达 `signal(B)` 指令。\n\n这种情况满足了死锁的四个必要条件：\n- **互斥**：二元信号量确保一次只有一个线程可以持有该资源。\n- **持有并等待**：线程 $T_1$ 成功获取了信号量（完成了第一次 `wait`），并在等待再次获取该信号量时被阻塞（在第二次 `wait` 时）。\n- **不可抢占**：信号量不能被强制从 $T_1$ 手中夺走；它必须通过 `signal` 操作释放。\n- **循环等待**：这是一个循环等待的平凡案例，即一个进程等待一个它自己持有的资源。$T_1$ 等待一个 `signal(B)`，而这个信号只有在 $T_1$ 自己完成任务后才能发出，但它无法完成任务，因为它正在等待。\n\n死锁不仅是可能的，而且是只要任何一个线程按顺序执行其两次 `wait(B)` 操作就会出现的必然结果。\n\n**实验 2 分析：计数信号量**\n\n在这个实验中，我们使用一个初始状态为 $s_C = n$ 的计数信号量 $C$。有 $n$ 个线程，每个线程都试图执行两次 `wait(C)`。每个线程需要从信号量中获取 $2$ 个单元才能完成其工作，然后才释放它们。可用单元的总数是 $n$。\n\n让我们分析一个“最坏情况”的调度场景，该场景会最大化资源竞争：\n1.  调度器交错执行 $n$ 个线程，使得每个线程恰好执行一次 `wait(C)` 操作。\n2.  线程 $T_1$ 执行 `wait(C)`。$s_C$ 变为 $n-1$。\n3.  线程 $T_2$ 执行 `wait(C)`。$s_C$ 变为 $n-2$。\n4.  ...\n5.  这个过程一直持续到线程 $T_n$ 执行 `wait(C)`。此时，$s_C$ 变为 $n-n = 0$。\n6.  现在，每个线程都成功地从信号量中获取了一个单元，并准备请求其第二个单元。信号量的计数为 $s_C = 0$。\n7.  让任何一个线程，比如 $T_1$，尝试其第二次 `wait(C)`。由于 $s_C = 0$，$T_1$ 将被阻塞。\n8.  任何其他被调度的线程都将遭遇同样的命运。所有 $n$ 个线程都将尝试其第二次 `wait(C)` 并被阻塞。\n9.  现在所有 $n$ 个线程都处于阻塞状态，每个都在等待 $s_C$ 变为正数。然而，所有线程都在其 `signal(C)` 调用之前被阻塞。没有线程可以继续执行以发出信号，所以 $s_C$ 将永远保持为 $0$。\n\n这是一个经典的死锁。每个线程持有一个资源并等待另一个资源，但可用资源池已空。死锁的所有四个条件都已满足。因此，在实验 2 中死锁是可能发生的。\n\n为了防止这种死锁，我们可以应用死锁避免的原则。系统中有 $n$ 个进程（线程），每个进程最多需要 $k=2$ 个资源（信号量单元）。设 $m$ 是初始资源数（$s_C$）。如果 $m  n(k-1)$，则可以保证避免死锁。\n在我们的例子中，$k=2$，所以条件是 $m  n(2-1)$，简化为 $m  n$。保证避免死锁的最小整数单元数是 $m = n+1$。如果 $s_C$ 初始化为 $n+1$，在最坏的情况下，即每个 $n$ 个线程都拿走一个单元，信号量计数将为 $(n+1) - n = 1$。这留下了一个可用单元，允许一个线程获取其第二个单元，完成其工作，并释放其两个单元，从而打破潜在的死锁。\n\n### 逐项分析\n\n**A. 在实验 1 中，必然发生死锁：第一个执行其第二次 $wait(B)$ 的线程在持有着唯一单元的情况下被阻塞，并且没有线程能够到达 $signal(B)$。**\n根据对实验 1 的分析，二元信号量的非递归特性意味着一个线程试图连续两次获取它将导致自我死锁。第一次 `wait(B)` 将 $s_B$ 设为 $0$，同一线程的第二次 `wait(B)` 将其阻塞。没有其他线程可以获取该信号量来发出信号。因此，死锁是必然会发生的。\n\n**结论：正确。**\n\n**B. 在实验 2 中，不可能发生死锁，因为 $s_C = n$ 初始为每个线程提供一个单元，并且每个线程最终都将在没有任何 $signal(C)$ 发生的情况下获得其第二个单元。**\n根据对实验 2 的分析，如果调度器交错线程使得每个线程都获取一个信号量单元，死锁是可能发生的。在这种情况下，信号量计数变为 $0$，所有线程在尝试获取第二个单元时都会阻塞。“每个线程最终将获得其第二个单元”的说法对于这种特定的、有效的交错方式是错误的。\n\n**结论：不正确。**\n\n**C. 在实验 2 中，如果 $n$ 个线程中的每一个都恰好获得一个单元，然后在第二次 $wait(C)$ 时阻塞，就可能发生死锁；要排除在这种每个线程需要 $2$ 个单元的模式下发生死锁的可能性，初始计数值必须至少为 $n + 1$。**\n这个陈述有两个部分。第一部分正确地指出了导致实验 2 中死锁的特定事件序列，这与我们的分析相符。第二部分提供了一个防止这种死锁的条件。根据死锁避免原则推导，为保证在每个线程都拿走 $1$ 个单元（最坏情况）后至少有一个线程可以继续执行，初始单元数必须至少为 $n+1$。这确保了在 $n$ 个单元被拿走后，还剩下 $1$ 个单元，允许一个线程获取其第二个单元并最终释放其资源。陈述的两个部分都是正确的。\n\n**结论：正确。**\n\n**D. 为了避免实验 2 中的死锁，计数信号量必须初始化为 $2n$ 个单元；任何更小的初始计数值都会使死锁不可避免。**\n将信号量初始化为 $s_C=2n$ 是避免死锁的充分条件，因为它提供了足够的单元，让每个线程都能在不阻塞的情况下获取其所需的两个单元。然而，这不是一个必要条件。正如在对选项 C 的分析中确立的，初始计数为 $n+1$ 也足以防止死锁。对于任何 $n1$，$n+1  2n$。因此，“任何更小的初始计数值都会使死锁不可避免”的说法是错误的。例如，如果 $n=5$，计数为 $6$（小于 $2n=10$）就足以避免死锁。\n\n**结论：不正确。**",
            "answer": "$$\\boxed{AC}$$"
        },
        {
            "introduction": "健壮的系统不仅要在正常情况下正确运行，还必须能优雅地处理超时或线程取消等异常。本练习探讨了在这些意外发生时如何正确管理信号量资源，强调了资源守恒的关键原则。你将通过分析补偿逻辑，理解为何每次成功的 $\\text{wait}$ 都必须有一个对应的 $\\text{post}$，从而学会编写能维护信号量完整性的健壮代码 ()。",
            "id": "3629405",
            "problem": "在一门操作系统（OS）课程中，考虑一个容量为 $C$ 的计数信号量 $S$，它用于控制对一个相同许可证池的访问。该计数信号量维护一个非负整数 $count$，表示当前可用的许可证数量。操作 $\\text{wait}(S)$ 原子地检查 $count$ 是否大于 $0$；如果是，它将 $count$ 减 1 并返回成功，否则阻塞。操作 $\\text{post}(S)$ 原子地将 $count$ 加 1，并可能唤醒一个等待中的线程。定时等待 $\\text{wait}(S, t)$ 是一个变体，它最多阻塞 $t$ 秒，然后返回成功（意味着在某个时刻获取了一个许可证且 $count$ 已被递减）或返回超时（意味着没有获取许可证且 $count$ 未被递减）。根据定义，容量 $C$ 是恒定的，并且线程持有的许可证数量加上可用的许可证数量绝不能超过 $C$。\n\n现在考虑一个容量 $C = 2$ 的计数信号量 $S$ 的以下场景。在时间 $0$，两个线程 $X$ 和 $Y$ 调用 $\\text{wait}(S)$ 并且都成功了，因此 $count = 0$ 且持有者数量为 $2$。第三个线程 $Z$ 调用 $\\text{wait}(S, t)$（其中 $t  0$）并阻塞。在时间区间 $[0, t)$ 内没有线程调用 $\\text{post}(S)$，因此在时间 $t$，$Z$ 的调用返回超时，且 $Z$ 没有获取到许可证。超时后，$Z$ 立即执行一个取消处理器。你必须决定 $Z$ 是否应该调用 $\\text{post}(S)$ 来“补偿”其被中止的尝试，并且你必须推断不匹配的 $\\text{wait}$/$\\text{post}$ 调用的后果。然后将其与二进制信号量（容量 $C = 1$）进行对比。\n\n仅使用上述核心定义和“可用许可证数量加上持有许可证数量受 $C$ 限制”这一不变量，评估以下论断。选择所有正确的选项。\n\nA. 在一个容量为 $C$ 的计数信号量中，如果一个线程从 $\\text{wait}(S, t)$ 超时而未获取许可证，那么为了补偿而调用 $\\text{post}(S)$ 是不正确的，因为它在没有相应获取操作的情况下增加了 $count$，违反了资源核算并产生了泄漏的许可证。\n\nB. 在一个计数信号量中，如果一个线程在 $\\text{wait}(S, t)$ 返回成功后（即它持有一个许可证）但在调用 $\\text{post}(S)$ 之前被取消，它必须在其取消处理器中恰好调用一次 $\\text{post}(S)$，以避免无限期地保留该许可证。\n\nC. 对于二进制信号量（容量 $C=1$），任何超时后的无条件 $\\text{post}(S)$ 调用是无害的，因为信号量计数不能超过 $1$，所以额外的 $\\text{post}(S)$ 调用不会将并发性增加到超出预期限制。\n\nD. 在实现带超时的计数信号量上的 $\\text{wait}(S, t)$ 时，正确的补偿逻辑是跟踪是否获取了许可证（例如，使用一个仅在成功时设置的布尔标志），并且当且仅当该标志为真时才调用 $\\text{post}(S)$；否则，不应发出 $\\text{post}(S)$ 调用，从而维护“可用许可证加上持有许可证的数量永远不超过 $C$”这一不变量。",
            "solution": "首先必须确定问题陈述的有效性。\n\n### 步骤 1：提取已知条件\n- **信号量类型**：容量为 $C$ 的计数信号量 $S$。\n- **状态变量**：一个非负整数 `count` ($N_{avail}$)，表示当前可用的许可证数量。\n- **$\\text{wait}(S)$ 操作**：原子地检查 `count` 是否  0。如果是，则将 `count` 减 1 并返回成功。否则，阻塞。\n- **$\\text{post}(S)$ 操作**：原子地将 `count` 加 1。它可能会唤醒一个等待中的线程。\n- **$\\text{wait}(S, t)$ 操作**：一种定时等待，最多阻塞 $t$ 秒。如果获取了许可证（意味着 `count` 已被递减），则返回成功；如果未获取许可证（意味着 `count` 未被递减），则返回超时。\n- **不变量**：线程持有的许可证数量 ($N_{held}$) 加上可用的许可证数量 ($N_{avail}$) 不得超过容量 $C$。这可以写成 $N_{held} + N_{avail} \\le C$。\n- **场景**：\n    - 容量 $C=2$。\n    - 在时间 $t=0$，线程 $X$ 和 $Y$ 调用 $\\text{wait}(S)$ 并成功。状态变为 $N_{held}=2$，$N_{avail}=0$。\n    - 第三个线程 $Z$ 调用 $\\text{wait}(S, t)$（其中 $t  0$）并阻塞。\n    - 在时间区间 $[0, t)$ 内没有线程调用 $\\text{post}(S)$。\n    - 在时间 $t$，$Z$ 的调用返回超时。$Z$ 没有获取许可证。\n    - 紧接着，$Z$ 执行一个取消处理器。\n- **任务**：评估关于 $Z$ 是否应调用 $\\text{post}(S)$ 的论断，以及不匹配的 $\\text{wait}/\\text{post}$ 调用的一般后果。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据**：该问题基于计数信号量和二进制信号量的标准和基本概念，这些是操作系统和并发编程的基石。$\\text{wait}$（P 操作）和 $\\text{post}$（V 操作）、定时等待和取消处理器的定义都是标准的。\n- **问题定义良好**：定义精确，场景描述清晰且按时间顺序。所述不变量 $N_{held} + N_{avail} \\le C$ 是信号量的一个关键安全属性。问题要求基于这些形式化定义评估具体论断，这是一个可解的问题。\n- **客观性**：问题以形式化、客观的语言陈述，没有歧义或主观性。\n\n问题陈述没有指令中列出的缺陷。它是科学合理的、定义良好的和客观的。它提出了一个标准的、不平凡的同步问题。\n\n### 步骤 3：结论与行动\n问题陈述是**有效的**。将推导出一个解决方案。\n\n### 基于原则的推导\n控制计数信号量的核心原则是许可证的守恒定律。信号量初始化时 $N_{avail} = C$ 且 $N_{held} = 0$。一个正确的程序必须维持不变量 $N_{held} + N_{avail} = C$。问题陈述提供了一个稍弱但仍然关键的安全不变量：$N_{held} + N_{avail} \\le C$。违反此不变量表明使用信号量的程序逻辑中存在缺陷。\n\n一个成功的 `wait` 操作代表一个许可证从“可用”池转换到“持有”状态。这意味着 $N_{avail}$ 减少 1，$N_{held}$ 增加 1，它们的总和保持不变。\n一个 `post` 操作应该用于将一个持有的许可证返回到可用池。这意味着 $N_{avail}$ 增加 1，$N_{held}$ 减少 1，它们的总和也保持不变。\n\n一个不持有许可证的线程调用 `post` 是一个错误。它会在没有相应减少 $N_{held}$ 的情况下增加 $N_{avail}$。这会增加总和 $N_{held} + N_{avail}$，导致 $N_{held} + N_{avail}  C$。这种现象，有时被称为许可证创建或膨胀，会破坏信号量的状态，允许多于 $C$ 个线程并发访问资源。\n\n我们现在将基于这一原则评估每个论断。\n\n### 逐项分析\n\n**A. 在一个容量为 $C$ 的计数信号量中，如果一个线程从 $\\text{wait}(S, t)$ 超时而未获取许可证，那么为了补偿而调用 $\\text{post}(S)$ 是不正确的，因为它在没有相应获取操作的情况下增加了 $count$，违反了资源核算并产生了泄漏的许可证。**\n\n- **分析**：问题陈述指出，从 $\\text{wait}(S, t)$ 超时意味着“没有获取许可证且 $count$ 未被递减”。因此，该线程不持有许可证。如果该线程调用 $\\text{post}(S)$，它将在没有许可证可释放的情况下（即没有相应地减少 $N_{held}$）增加 $count$（$N_{avail}$）。此行为人为地创建了一个新许可证。\n让我们分析其对不变量的影响。假设在虚假的 $\\text{post}(S)$ 调用之前的状态是 $N_{held}$ 和 $N_{avail}$。我们有 $N_{held} + N_{avail} \\le C$。调用 $\\text{post}(S)$ 之后，新状态是 $N'_{held} = N_{held}$ 和 $N'_{avail} = N_{avail} + 1$。总和变为 $N'_{held} + N'_{avail} = N_{held} + N_{avail} + 1$。如果信号量已满负荷使用（即 $N_{held} + N_{avail} = C$），总和将变为 $C+1$，直接违反了不变量 $N_{held} + N_{avail} \\le C$。这破坏了信号量的资源核算。术语“泄漏的许可证”(leaked permits)稍有不确；“虚假创建的许可证”(spuriously created permits)或“许可证膨胀”(permit inflation)更准确，但意图是明确的。该调用绝对是不正确的。\n- **结论**：**正确**。\n\n**B. 在一个计数信号量中，如果一个线程在 $\\text{wait}(S, t)$ 返回成功后（即它持有一个许可证）但在调用 $\\text{post}(S)$ 之前被取消，它必须在其取消处理器中恰好调用一次 $\\text{post}(S)$，以避免无限期地保留该许可证。**\n\n- **分析**：如果 $\\text{wait}(S, t)$ 返回成功，则该线程已获取一个许可证。这意味着 $N_{avail}$ 被递减，$N_{held}$ 被递增。该线程现在对这个许可证负责。如果该线程在其能够执行正常的 `post(S)` 调用之前被取消，该许可证将保持在“持有”状态，与一个现已终止的线程相关联。这个许可证对系统来说实际上是丢失了，这是一种资源泄漏，会永久性地减少可用资源的数量。为了防止这种情况，一个行为良好的取消处理器必须清理已获取的资源。在这种情况下，这意味着恰好调用一次 $\\text{post}(S)$，将持有的许可证返回给信号量，从而恢复不变量并防止资源泄漏。\n- **结论**：**正确**。\n\n**C. 对于二进制信号量（容量 $C = 1$），任何超时后的无条件 $\\text{post}(S)$ 调用是无害的，因为信号量计数不能超过 $1$，所以额外的 $\\text{post}(S)$ 调用不会将并发性增加到超出预期限制。**\n\n- **分析**：二进制信号量是计数信号量在 $C=1$ 时的特例，通常用于互斥。让我们假设信号量已被锁定，意味着资源正在使用中。状态是 $N_{held}=1$ 和 $N_{avail}=0$。一个调用 `wait` 的线程将会阻塞。如果它超时了，它就没有获取许可证。如果它随后无条件地调用 $\\text{post}(S)$，$N_{avail}$ 将被增加到 $1$。状态变为 $N_{held}=1, N_{avail}=1$。总和为 $2$，这违反了不变量 $N_{held} + N_{avail} \\le 1$。信号量现在指示资源是可用的（$N_{avail}=1$），即使它仍然被持有（$N_{held}=1$）。第三个线程现在可以调用 `wait(S)`，成功，并进入临界区。这导致两个线程同时处于临界区内，完全破坏了互斥的保证。认为这个行为是“无害的”这个前提是灾难性地错误。声称“信号量计数不能超过 $1$”也无法由所提供的 `post(S)` 定义来保证，该定义只是简单地增加 `count`。即使某个实现将 `count` 的上限限制为 $1$，这个虚假的 `post` 也会错误地将 `count` 设置为 $1$（而它本应是 $0$），导致同样的失败。\n- **结论**：**不正确**。\n\n**D. 在实现带超时的计数信号量上的 $\\text{wait}(S, t)$ 时，正确的补偿逻辑是跟踪是否获取了许可证（例如，使用一个仅在成功时设置的布尔标志），并且当且仅当该标志为真时才调用 $\\text{post}(S)$；否则，不应发出 $\\text{post}(S)$ 调用，从而维护“可用许可证加上持有许可证的数量永远不超过 $C$”这一不变量。**\n\n- **分析**：这个论断描述了一种通用且健壮的模式，用于处理可能失败的资源获取情况下的取消操作。逻辑“当且仅当获取了许可证时才调用 `post(S)`”正确地处理了在 A 和 B 中讨论的两种情况。\n    1.  如果 `wait` 操作超时或失败，则没有获取许可证。标志将为假。该逻辑规定不调用 `post(S)`。这与分析 A 的结论相符，并防止了许可证膨胀。\n    2.  如果 `wait` 操作成功，则获取了许可证。标志将为真。该逻辑规定在取消时调用 `post(S)`。这与分析 B 的结论相符，并防止了许可证泄漏。\n这种“获取-执行-释放”模式，在编程语言中通常通过 `try...finally` 块或 RAII 结构实现，是确保资源安全的标准、正确方法。它保证了每一次成功的获取都有一次相应的释放，从而维护了信号量的不变量。\n- **结论**：**正确**。",
            "answer": "$$\\boxed{ABD}$$"
        },
        {
            "introduction": "在确保程序的正确性之后，性能成为衡量系统优劣的关键指标。选择错误的同步工具可能会导致严重的性能瓶颈。这个练习将引导你运用一个基于排队论的假设模型，来量化分析在一个多资源场景下，误用二进制信号量替代计数信号量所带来的性能影响，从而揭示资源利用率可能出现的巨大差异 ()。",
            "id": "3629427",
            "problem": "考虑一个系统，它有 $n$ 个相同、独立的资源，每个资源都保护着对代码临界区的进入。作业根据速率为 $\\lambda$ 的泊松过程到达系统，每个作业需要独占一个资源，其服务时间服从速率为 $\\mu$ 的指数分布（因此平均服务时间为 $1/\\mu$）。系统使用信号量来控制并发访问：\n- 一个具有 $n$ 个初始许可的计数信号量允许最多 $n$ 个作业并发执行。\n- 一个二进制信号量即使存在 $n$ 个资源，也只允许最多一个作业并发执行；假设它被应用于保护整个资源池，从而强制实现单一并发。\n\n当没有可用许可时到达的作业，会在一个无限的先到先-先服务 (FCFS) 队列中等待，直到有许可变为可用。系统没有抢占。将资源池的稳态利用率 $U$ 定义为 $n$ 个资源被占用的长期平均比例，即长期平均被占用的许可数除以 $n$。\n\n从生灭过程和泊松/指数服务系统的核心定义和经过充分检验的事实出发，推导：\n1. 在计数信号量下，假设系统是稳定的，即 $\\lambda  n\\mu$，求稳态利用率 $U_{\\mathrm{count}}(\\lambda,\\mu,n)$。\n2. 在二进制信号量下，假设系统是稳定的，即 $\\lambda  \\mu$，求稳态利用率 $U_{\\mathrm{binary}}(\\lambda,\\mu,n)$。\n3. 在二进制信号量下可达到的最大稳态利用率与在计数信号量下可达到的最大稳态利用率之比 $R$，两者均在其各自的稳定范围内取值。\n\n将您的最终答案表示为一个单行矩阵，按顺序包含 $\\left(U_{\\mathrm{count}},\\,U_{\\mathrm{binary}},\\,R\\right)$。无需四舍五入。",
            "solution": "问题陈述已经过验证，被认为是基于排队论的一个合理且定义明确的问题。我们将逐步推导所需的量。\n\n该问题要求计算与两种不同信号量控制方案下的资源利用率相关的三个量。让我们分别分析每种情况，然后计算所需的比率。整个过程中的关键概念是稳态利用率 $U$ 的定义，即长期平均被占用的资源数量（我们表示为 $L_s$）除以资源总数 $n$。\n$$U = \\frac{L_s}{n}$$\n排队论中的一个基本结果，利特尔法则，应用于系统的服务部分，指出服务中的平均作业数 $L_s$ 等于进入服务的有效到达率 $\\lambda_{\\text{eff}}$ 乘以作业在服务中花费的平均时间 $W_s$。\n$$L_s = \\lambda_{\\text{eff}} W_s$$\n在一个具有无限队列的稳定系统中，没有作业会丢失，因此进入服务设施的有效到达率等于系统的总到达率，即 $\\lambda_{\\text{eff}} = \\lambda$。问题陈述指出服务时间服从速率为 $\\mu$ 的指数分布，所以平均服务时间为 $W_s = 1/\\mu$。\n将这些代入 $L_s$ 的公式，我们得到平均被占用的资源数：\n$$L_s = \\lambda \\cdot \\frac{1}{\\mu} = \\frac{\\lambda}{\\mu}$$\n$L_s$ 的这个结果是通用的，并且在系统稳定的前提下，对任意数量的服务台都成立。两种信号量方案之间的差异将通过它们的稳定条件以及我们如何将 $L_s$ 与资源总数 $n$ 联系起来而体现出来。\n\n1.  **使用计数信号量时的稳态利用率，$U_{\\mathrm{count}}$**\n\n使用具有 $n$ 个初始许可的计数信号量的系统是一个经典的 M/M/n 排队模型。在这里，到达是速率为 $\\lambda$ 的泊松过程，有 $n$ 个并行的同构服务台，每个服务台的指数服务速率为 $\\mu$。只要 $n$ 个资源中至少有一个是空闲的，作业就可以被服务。\n\n平均被占用的资源（服务台）数是 $L_s = \\frac{\\lambda}{\\mu}$。资源池的利用率 $U_{\\mathrm{count}}$ 是这个平均数除以资源总数 $n$。\n$$U_{\\mathrm{count}}(\\lambda, \\mu, n) = \\frac{L_s}{n} = \\frac{\\lambda / \\mu}{n} = \\frac{\\lambda}{n\\mu}$$\n如题所给，M/M/n 队列的稳定条件是 $\\lambda  n\\mu$。这可以重写为 $\\frac{\\lambda}{n\\mu}  1$。这证实了我们推导出的利用率（也称为流量强度 $\\rho$）必须小于1，系统才能保持稳定。\n\n2.  **使用二进制信号量时的稳态利用率，$U_{\\mathrm{binary}}$**\n\n二进制信号量即使有 $n$ 个物理资源可用，也只允许最多一个作业并发执行。这个约束实际上将系统转变为一个 M/M/1 队列，其中只有一个“逻辑”服务台（单个信号量许可）。\n\n必须计算平均被占用的物理资源数 $L_s$。在这个 M/M/1 系统中，任何给定时刻，要么没有资源被占用（系统空闲），要么恰好有一个资源被占用（一个作业正在执行）。一个资源被占用的概率等于 M/M/1 模型中单个逻辑服务台的利用率。M/M/1 服务台的利用率由 $\\rho_1 = \\frac{\\lambda}{\\mu}$ 给出。\n因此，平均被占用的资源数是：\n$$L_s = (1 \\times \\text{Prob(系统繁忙)}) + (0 \\times \\text{Prob(系统空闲)}) = 1 \\cdot \\rho_1 + 0 \\cdot (1-\\rho_1) = \\rho_1 = \\frac{\\lambda}{\\mu}$$\n这个结果与早先通过利特尔法则得到的结果相同。可用资源总数仍然是 $n$。因此，资源池的利用率 $U_{\\mathrm{binary}}$ 是平均繁忙资源数除以 $n$：\n$$U_{\\mathrm{binary}}(\\lambda, \\mu, n) = \\frac{L_s}{n} = \\frac{\\lambda / \\mu}{n} = \\frac{\\lambda}{n\\mu}$$\n如题所给，这个 M/M/1 系统的稳定条件是 $\\lambda  \\mu$。使用单服务台利用率可以将其重写为 $\\rho_1 = \\frac{\\lambda}{\\mu}  1$。\n\n值得注意的是，$U_{\\mathrm{count}}$ 和 $U_{\\mathrm{binary}}$ 的表达式是相同的。系统性能的差异来自于它们不同的稳定边界。\n\n3.  **最大可达到利用率之比，$R$**\n\n我们需要找到比率 $R = \\frac{\\max(U_{\\mathrm{binary}})}{\\max(U_{\\mathrm{count}})}$。每个系统的最大可达到利用率是通过在其各自的稳定范围内取利用率函数的上确界得到的。\n\n对于计数信号量（M/M/n 系统）：\n利用率为 $U_{\\mathrm{count}} = \\frac{\\lambda}{n\\mu}$，稳定条件为 $\\lambda  n\\mu$。\n最大可达到利用率是当到达率接近其上界时的极限：\n$$\\max(U_{\\mathrm{count}}) = \\sup_{\\lambda  n\\mu} \\left( \\frac{\\lambda}{n\\mu} \\right) = \\lim_{\\lambda \\to (n\\mu)^{-}} \\frac{\\lambda}{n\\mu} = \\frac{n\\mu}{n\\mu} = 1$$\n这意味着当负载接近系统的总容量时，资源在极限情况下可以被完全利用。\n\n对于二进制信号量（等效的 M/M/1 系统）：\n利用率为 $U_{\\mathrm{binary}} = \\frac{\\lambda}{n\\mu}$，稳定条件为 $\\lambda  \\mu$。\n最大可达到利用率是当到达率接近其（更严格的）上界时的极限：\n$$\\max(U_{\\mathrm{binary}}) = \\sup_{\\lambda  \\mu} \\left( \\frac{\\lambda}{n\\mu} \\right) = \\lim_{\\lambda \\to \\mu^{-}} \\frac{\\lambda}{n\\mu} = \\frac{\\mu}{n\\mu} = \\frac{1}{n}$$\n这意味着由于一次只能使用一个资源，整个 $n$ 个资源池的最大利用率被限制为 $\\frac{1}{n}$，这种情况发生在那个唯一可用的资源被加载到其全部容量时。\n\n最后，我们计算比率 $R$：\n$$R = \\frac{\\max(U_{\\mathrm{binary}})}{\\max(U_{\\mathrm{count}})} = \\frac{1/n}{1} = \\frac{1}{n}$$\n\n因此，所要求的三个量是 $U_{\\mathrm{count}} = \\frac{\\lambda}{n\\mu}$，$U_{\\mathrm{binary}} = \\frac{\\lambda}{n\\mu}$，和 $R = \\frac{1}{n}$。",
            "answer": "$$\\boxed{\\begin{pmatrix} \\frac{\\lambda}{n\\mu}  \\frac{\\lambda}{n\\mu}  \\frac{1}{n} \\end{pmatrix}}$$"
        }
    ]
}