{
    "hands_on_practices": [
        {
            "introduction": "Before we can build complex systems with semaphores, we must have a rock-solid understanding of their fundamental rules. This first exercise challenges you to think like the operating system itself, purely in terms of a semaphore's internal state. By analyzing a chronological log of semaphore operations, you will determine the minimum number of resources required for that sequence to be valid, reinforcing your grasp of the core invariants that govern semaphore behavior .",
            "id": "3681948",
            "problem": "A counting semaphore is an abstract data type with an integer state. Let $S$ be a single counting semaphore that protects access to an identical pool of resources. The semaphore $S$ is initialized to an unknown nonnegative integer $k$, which equals the number of resource units initially available. The operation $P(S)$ (also called wait or down) attempts to acquire one unit: it completes only if at least one unit is available, in which case the internal state of $S$ decreases by $1$; otherwise, the caller blocks and the operation cannot complete until some future $V(S)$ increases availability. The operation $V(S)$ (also called signal or up) releases one unit and increases the internal state of $S$ by $1$, potentially allowing one blocked $P(S)$ to complete. Assume there is no ownership requirement: any thread may invoke $V(S)$.\n\nYou are given a completion trace of operations on $S$ from $6$ threads $\\{A,B,C,D,E,F\\}$. The trace lists the global real-time order in which each $P(S)$ or $V(S)$ operation completed. Because the trace records only completions (not attempts), a $P(S)$ that would have blocked cannot appear in the trace until after sufficient $V(S)$ operations have completed to make a unit available.\n\nThe observed completion trace is the following ordered sequence of thread-operation pairs:\n$(A,P)$, $(B,P)$, $(C,P)$, $(B,V)$, $(D,P)$, $(E,P)$, $(C,V)$, $(F,P)$, $(A,V)$, $(D,V)$, $(B,P)$, $(E,V)$, $(F,V)$, $(C,P)$, $(B,V)$, $(A,P)$, $(A,V)$, $(C,V)$, $(D,P)$, $(D,V)$.\n\nUnder the standard counting semaphore semantics described above, determine the smallest integer $k$ for which this trace is legal, meaning that no completed $P(S)$ in the trace could have completed at a time when no unit was available. Provide your answer as a single integer (no units). If rounding were necessary, you would be instructed to round to a specified number of significant figures; however, in this problem, the exact integer is required.",
            "solution": "The problem asks for the smallest non-negative integer value of the initial semaphore count, $k$, for which a given trace of completed semaphore operations is legal.\n\nLet the state of the counting semaphore $S$ after the $t$-th operation in the trace has completed be denoted by $S_t$. The initial state of the semaphore is $S_0 = k$, where $k$ is a non-negative integer representing the initial number of available resources.\n\nThe standard semantics for the semaphore operations are as follows:\n1.  A $P(S)$ operation (wait) at step $t$ can complete only if the semaphore's value before the operation, $S_{t-1}$, is greater than $0$. Since the semaphore value is an integer, this is equivalent to $S_{t-1} \\ge 1$. Upon completion, the semaphore's value is decremented: $S_t = S_{t-1} - 1$.\n2.  A $V(S)$ operation (signal) at step $t$ unconditionally completes and increments the semaphore's value: $S_t = S_{t-1} + 1$.\n\nA direct consequence of these rules is that the semaphore's internal state must always be non-negative. If $S_{t-1} \\ge 1$ for a $P$ operation, then after the operation, $S_t = S_{t-1} - 1 \\ge 0$. For a $V$ operation, if $S_{t-1} \\ge 0$, then $S_t = S_{t-1} + 1 \\ge 1$. Since the initial state $k$ is non-negative, the semaphore value $S_t$ must remain non-negative for all $t \\ge 0$.\n\nTo analyze the trace, we can define a function $C_t$ representing the net number of resources acquired after $t$ operations. This is the total number of completed $P$ operations minus the total number of completed $V$ operations up to step $t$. Let $P_t$ and $V_t$ be the cumulative counts of $P$ and $V$ operations, respectively, in the first $t$ steps of the trace. Then, $C_t = P_t - V_t$.\n\nThe value of the semaphore after $t$ operations can be expressed in terms of its initial value $k$ and the net acquisitions $C_t$:\n$$S_t = S_0 - (P_t - V_t) = k - C_t$$\n\nFor the trace to be legal, two conditions derived from the semaphore semantics must be met for all steps $t=1, \\dots, 20$:\n1.  The semaphore value must never be negative: $S_t \\ge 0$. This implies $k - C_t \\ge 0$, or $k \\ge C_t$ for all $t \\in \\{1, \\dots, 20\\}$.\n2.  For any step $t$ that is a $P$ operation, the value before the operation must be at least $1$: $S_{t-1} \\ge 1$. This implies $k - C_{t-1} \\ge 1$, or $k \\ge 1 + C_{t-1}$.\n\nLet us analyze the relationship between these two conditions. For any $P$ operation at step $t$, we have $C_t = C_{t-1} + 1$. The second condition, $k \\ge 1 + C_{t-1}$, can be rewritten as $k \\ge C_t$. This means the condition for a $P$ operation at step $t$ is equivalent to requiring $k \\ge C_t$, where $C_t$ is the net acquisition count *after* the $P$ operation.\n\nFor any $V$ operation at step $t$, we have $C_t = C_{t-1} - 1$. The first condition, $k \\ge C_t$, is less strict than $k \\ge C_{t-1}$ (which must hold because $t-1$ is a valid step in the trace). Therefore, the critical constraints on $k$ arise from ensuring $S_t \\ge 0$ for all $t$. The maximum number of concurrently held resources must not exceed the initial number of resources, $k$.\n\nCombining these, a single, necessary and sufficient condition for the entire trace to be legal is that $k$ must be greater than or equal to the net acquisition count $C_t$ at every step $t$. To find the smallest possible integer $k$, we must find the maximum value that $C_t$ attains throughout the trace.\n$$k_{min} = \\max_{t \\in \\{0, 1, \\dots, 20\\}} C_t$$\n\nWe now compute the value of $C_t$ for each step in the given trace. Let $C_0 = 0$.\n\n- $t=1: (A,P) \\implies C_1 = C_0 + 1 = 1$\n- $t=2: (B,P) \\implies C_2 = C_1 + 1 = 2$\n- $t=3: (C,P) \\implies C_3 = C_2 + 1 = 3$\n- $t=4: (B,V) \\implies C_4 = C_3 - 1 = 2$\n- $t=5: (D,P) \\implies C_5 = C_4 + 1 = 3$\n- $t=6: (E,P) \\implies C_6 = C_5 + 1 = 4$\n- $t=7: (C,V) \\implies C_7 = C_6 - 1 = 3$\n- $t=8: (F,P) \\implies C_8 = C_7 + 1 = 4$\n- $t=9: (A,V) \\implies C_9 = C_8 - 1 = 3$\n- $t=10: (D,V) \\implies C_{10} = C_9 - 1 = 2$\n- $t=11: (B,P) \\implies C_{11} = C_{10} + 1 = 3$\n- $t=12: (E,V) \\implies C_{12} = C_{11} - 1 = 2$\n- $t=13: (F,V) \\implies C_{13} = C_{12} - 1 = 1$\n- $t=14: (C,P) \\implies C_{14} = C_{13} + 1 = 2$\n- $t=15: (B,V) \\implies C_{15} = C_{14} - 1 = 1$\n- $t=16: (A,P) \\implies C_{16} = C_{15} + 1 = 2$\n- $t=17: (A,V) \\implies C_{17} = C_{16} - 1 = 1$\n- $t=18: (C,V) \\implies C_{18} = C_{17} - 1 = 0$\n- $t=19: (D,P) \\implies C_{19} = C_{18} + 1 = 1$\n- $t=20: (D,V) \\implies C_{20} = C_{19} - 1 = 0$\n\nThe sequence of values for $C_t$ for $t \\in \\{1, \\dots, 20\\}$ is:\n$\\{1, 2, 3, 2, 3, 4, 3, 4, 3, 2, 3, 2, 1, 2, 1, 2, 1, 0, 1, 0\\}$.\n\nThe maximum value in this sequence is:\n$$\\max(C_t) = 4$$\nThis maximum is reached at two points in the trace: after the $6^{th}$ operation $(E,P)$ and after the $8^{th}$ operation $(F,P)$.\n\nFor the trace to be legal, $k$ must be at least this maximum value. Thus, $k \\ge 4$. The smallest integer value for $k$ is $4$.\n\nTo verify, if we choose $k=3$, the trace would be illegal. At step $t=6$, the operation is $(E,P)$. The state before this operation would be $S_5 = k - C_5 = 3 - 3 = 0$. A $P$ operation cannot complete if the semaphore value is $0$, as it requires the value to be at least $1$. Therefore, $k=3$ is not a valid initial value.\n\nIf we choose $k=4$, the state before the $6^{th}$ operation is $S_5 = k - C_5 = 4 - 3 = 1$. This is a valid state for a $P$ operation to complete. After the operation, the state becomes $S_6 = S_5 - 1 = 0$, which is non-negative. A check of all $P$ operations confirms that $k=4$ makes the entire trace legal.\n\nTherefore, the smallest non-negative integer $k$ for which the trace is legal is $4$.",
            "answer": "$$\\boxed{4}$$"
        },
        {
            "introduction": "While a single semaphore is a powerful tool, most real-world problems involve multiple resources and multiple threads, creating opportunities for complex and dangerous interactions. This next practice moves from a single component to a system-wide view, asking you to diagnose a potential deadlock by tracing the interactions between threads and semaphores. Your task is to pinpoint the exact moment when a circular wait dependency forms, a critical skill for debugging concurrent programs .",
            "id": "3681944",
            "problem": "Consider a system with two counting semaphores, $S$ and $T$, each initialized to the integer value $1$. All semaphore operations follow the canonical definitions: the \"wait\" operation $P(X)$ decrements $X$ if its value is strictly greater than $0$; otherwise, the calling thread is blocked and enqueued on $X$'s wait queue. The \"signal\" operation $V(X)$ increments $X$ if no threads are waiting; otherwise, one waiting thread is dequeued and that thread completes its pending $P(X)$, leaving the semaphore's integer value unchanged at $0$. Queues use First-In, First-Out (FIFO) discipline. Blocked threads cannot execute further operations until they are unblocked by a corresponding $V$ on the semaphore they are waiting on. All $P$ and $V$ operations have negligible execution time at their timestamps. There is no preemption of held semaphores.\n\nThree threads, $T_1$, $T_2$, and $T_3$, perform the following operations at the given timestamps, measured in milliseconds:\n- At $t = 0\\,\\mathrm{ms}$, thread $T_1$ invokes $P(S)$.\n- At $t = 1\\,\\mathrm{ms}$, thread $T_2$ invokes $P(T)$.\n- At $t = 2\\,\\mathrm{ms}$, thread $T_3$ invokes $P(S)$.\n- At $t = 3\\,\\mathrm{ms}$, thread $T_1$ invokes $P(T)$.\n- At $t = 4\\,\\mathrm{ms}$, thread $T_2$ invokes $P(S)$.\n\nNo further $P$ or $V$ operations occur after $t = 4\\,\\mathrm{ms}$. Using only the fundamental definitions of $P$ and $V$ for counting semaphores and the standard deadlock conditions, reconstruct the possible values of $S$ and $T$ and the membership of their wait queues over time at each listed timestamp. Then determine the earliest timestamp $t^\\star$ (in milliseconds) at which a genuine deadlock can arise in this system, given the log above and the stated semantics.\n\nExpress your final answer as a single numerical timestamp in milliseconds. Do not round; report the exact value.",
            "solution": "The user wants me to analyze a multithreaded system with semaphores and determine the earliest time a deadlock occurs.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n- System Components: Two counting semaphores, $S$ and $T$.\n- Initial State: $S$ is initialized to $1$. $T$ is initialized to $1$.\n- Semaphore Semantics:\n  - Wait operation $P(X)$: If the value of semaphore $X$ is strictly greater than $0$, decrement the value of $X$. Otherwise, the calling thread blocks and is enqueued on $X$'s wait queue.\n  - Signal operation $V(X)$: If $X$'s wait queue is empty, increment the value of $X$. Otherwise, one waiting thread is dequeued and completes its pending $P(X)$ operation, leaving the value of $X$ unchanged at $0$.\n- Queueing Discipline: First-In, First-Out (FIFO).\n- Threads: Three threads, $T_1$, $T_2$, and $T_3$.\n- Operation Log:\n  - At $t = 0\\,\\mathrm{ms}$, thread $T_1$ invokes $P(S)$.\n  - At $t = 1\\,\\mathrm{ms}$, thread $T_2$ invokes $P(T)$.\n  - At $t = 2\\,\\mathrm{ms}$, thread $T_3$ invokes $P(S)$.\n  - At $t = 3\\,\\mathrm{ms}$, thread $T_1$ invokes $P(T)$.\n  - At $t = 4\\,\\mathrm{ms}$, thread $T_2$ invokes $P(S)$.\n- Constraints: No further operations occur after $t = 4\\,\\mathrm{ms}$. All operations are atomic and have negligible execution time at their timestamps.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is scientifically grounded, well-posed, and objective. It provides a complete and consistent set of initial conditions, operational semantics for semaphores, and a deterministic sequence of events. The concepts of semaphores, threads, and deadlock are fundamental to operating systems theory. The problem is formalizable and requires a rigorous step-by-step analysis rather than relying on analogy or subjective interpretation. There are no contradictions, missing data, or scientifically unsound premises.\n\n**Step 3: Verdict and Action**\nThe problem is valid. A complete solution will be provided.\n\n### Solution\n\nWe will trace the state of the system at each specified timestamp. The state is defined by the integer values of semaphores $S$ and $T$, the contents of their respective wait queues (which we will denote as $Q_S$ and $Q_T$), and the status of each thread ($T_1, T_2, T_3$).\n\n**Initial State (before $t = 0\\,\\mathrm{ms}$):**\n- Semaphore values: $S = 1$, $T = 1$.\n- Wait queues: $Q_S = []$, $Q_T = []$ (both are empty).\n- Thread states: $T_1$, $T_2$, $T_3$ are ready to run.\n\n**At $t = 0\\,\\mathrm{ms}$:**\n- **Operation:** Thread $T_1$ invokes $P(S)$.\n- **Analysis:** The value of $S$ is $1$, which is $> 0$. The operation succeeds. $S$ is decremented. $T_1$ does not block and continues execution. In the context of semaphore logic, $T_1$ now \"holds\" one unit of the resource represented by $S$.\n- **State after $t = 0\\,\\mathrm{ms}$:**\n  - $S = 0$, $Q_S = []$\n  - $T = 1$, $Q_T = []$\n  - $T_1$: Running\n  - $T_2$: Ready\n  - $T_3$: Ready\n\n**At $t = 1\\,\\mathrm{ms}$:**\n- **Operation:** Thread $T_2$ invokes $P(T)$.\n- **Analysis:** The value of $T$ is $1$, which is $> 0$. The operation succeeds. $T$ is decremented. $T_2$ does not block and continues execution. $T_2$ now \"holds\" one unit of the resource represented by $T$.\n- **State after $t = 1\\,\\mathrm{ms}$:**\n  - $S = 0$, $Q_S = []$\n  - $T = 0$, $Q_T = []$\n  - $T_1$: Running\n  - $T_2$: Running\n  - $T_3$: Ready\n\n**At $t = 2\\,\\mathrm{ms}$:**\n- **Operation:** Thread $T_3$ invokes $P(S)$.\n- **Analysis:** The value of $S$ is $0$. The operation cannot complete. Thread $T_3$ is blocked and added to the wait queue for $S$. The value of $S$ remains $0$.\n- **State after $t = 2\\,\\mathrm{ms}$:**\n  - $S = 0$, $Q_S = [T_3]$\n  - $T = 0$, $Q_T = []$\n  - $T_1$: Running\n  - $T_2$: Running\n  - $T_3$: Blocked on $S$\n\n**At $t = 3\\,\\mathrm{ms}$:**\n- **Operation:** Thread $T_1$ invokes $P(T)$.\n- **Analysis:** The value of $T$ is $0$. The operation cannot complete. Thread $T_1$ is blocked and added to the wait queue for $T$. The value of $T$ remains $0$.\n- **State after $t = 3\\,\\mathrm{ms}$:**\n  - $S = 0$, $Q_S = [T_3]$\n  - $T = 0$, $Q_T = [T_1]$\n  - $T_1$: Blocked on $T$\n  - $T_2$: Running\n  - $T_3$: Blocked on $S$\n- **Deadlock Check:** At this point, $T_1$ holds resource $S$ and is waiting for resource $T$. $T_3$ is waiting for resource $S$. However, $T_2$ holds resource $T$ and is still in a running state. Because $T_2$ is not blocked, it could theoretically perform a $V(S)$ or $V(T)$ operation, which would break the dependencies. Therefore, the system is not yet in a deadlock state.\n\n**At $t = 4\\,\\mathrm{ms}$:**\n- **Operation:** Thread $T_2$ invokes $P(S)$.\n- **Analysis:** The value of $S$ is $0$. The operation cannot complete. Thread $T_2$ is blocked and added to the wait queue for $S$. Since the queue is FIFO, $T_2$ is placed after $T_3$. The value of $S$ remains $0$.\n- **State after $t = 4\\,\\mathrm{ms}$:**\n  - $S = 0$, $Q_S = [T_3, T_2]$\n  - $T = 0$, $Q_T = [T_1]$\n  - $T_1$: Blocked on $T$\n  - $T_2$: Blocked on $S$\n  - $T_3$: Blocked on $S$\n\n**Deadlock Analysis at $t^\\star = 4\\,\\mathrm{ms}$:**\nA deadlock occurs if the four necessary conditions are met:\n1.  **Mutual Exclusion:** This is inherent in the use of semaphores initialized to $1$ to protect resources. Multiple threads cannot concurrently decrement the semaphore value past $0$.\n2.  **Hold and Wait:**\n    - $T_1$ successfully completed $P(S)$, so it \"holds\" $S$. It is now blocked waiting for $T$.\n    - $T_2$ successfully completed $P(T)$, so it \"holds\" $T$. It is now blocked waiting for $S$.\n    This condition is met.\n3.  **No Preemption:** The problem specifies that resources (semaphore \"units\") cannot be forcibly taken from threads. A thread must voluntarily release a resource via a $V$ operation. This condition holds.\n4.  **Circular Wait:** This is the critical condition that arises at $t = 4\\,\\mathrm{ms}$. We can visualize the dependencies:\n    - Thread $T_1$ is waiting for resource $T$ (request edge $T_1 \\rightarrow T$).\n    - Resource $T$ is held by thread $T_2$ (hold edge $T \\rightarrow T_2$).\n    - Thread $T_2$ is waiting for resource $S$ (request edge $T_2 \\rightarrow S$).\n    - Resource $S$ is held by thread $T_1$ (hold edge $S \\rightarrow T_1$).\n    This forms a cycle: $T_1 \\rightarrow T \\rightarrow T_2 \\rightarrow S \\rightarrow T_1$.\n\nAt $t = 4\\,\\mathrm{ms}$, the operation $T_2$ invoking $P(S)$ causes $T_2$ to block, completing the circular wait condition. At this instant, all threads that hold necessary resources ($T_1$ and $T_2$) are themselves blocked. No thread is in a running state, and since no further $V$ operations are scheduled, no thread can ever be unblocked. The system is in a genuine, unrecoverable deadlock.\n\nThe earliest timestamp at which this state of deadlock arises is precisely when the last dependency needed to form the unresolvable circular wait is established. This occurs at $t = 4\\,\\mathrm{ms}$ when $T_2$ blocks on $S$. Therefore, $t^\\star = 4\\,\\mathrm{ms}$.",
            "answer": "$$\\boxed{4}$$"
        },
        {
            "introduction": "Having analyzed semaphore mechanics and failure modes, it's time to use them constructively to build a coordinated system. In this final practice, you will implement a simulation of a resource scheduler where a counting semaphore manages a fixed number of concurrent tasks, much like managing upload slots in a file-sharing application. This hands-on coding task challenges you to integrate semaphore-based resource management with scheduling logic to build a fair and efficient system .",
            "id": "3681933",
            "problem": "Consider a discrete-time simulation of peer-to-peer file sharing coordinated by a counting semaphore. There are $n$ peers, indexed by $i \\in \\{0,1,\\dots,n-1\\}$, and a fixed number of upload slots $k$ representing concurrent capacity. Time advances in unit ticks $t = 0,1,2,\\dots$. Each peer $i$ has an arrival time $A_i \\in \\mathbb{Z}_{\\ge 0}$, an upload duration $D_i \\in \\mathbb{Z}_{>0}$, and an initial tit-for-tat credit $C_i \\in \\mathbb{R}_{\\ge 0}$. A peer becomes waiting at time $t$ when $t \\ge A_i$ and it has not yet started its upload. Waiting peers accumulate waiting time $W_i(t)$, defined as the number of ticks they have been continuously waiting without starting, and may start when a slot becomes free. A counting semaphore with internal value $S(t)$ enforces the invariant that the number of concurrently running uploads never exceeds $k$, and that a waiting peer can only start when $S(t) > 0$, after which the semaphore immediately decrements by $1$ (the \"wait\" operation). When a running upload completes, the semaphore increments by $1$ (the \"signal\" operation).\n\nThe scheduler must implement a tit-for-tat priority policy with starvation avoidance by aging: among all waiting peers at time $t$, it selects up to $k - R(t)$ peers to start, where $R(t)$ is the current number of running uploads, choosing those with maximal priority $$P_i(t) = C_i + \\alpha \\cdot W_i(t),$$ where $\\alpha \\in \\mathbb{R}_{>0}$ is a fixed aging weight. Ties in $P_i(t)$ must be broken deterministically by the smallest peer index. Once a peer starts at time $t$, it runs for exactly $D_i$ ticks and then completes, freeing its slot. Each peer performs exactly one upload in the simulation.\n\nStarting from the fundamental definition that a counting semaphore maintains safe access to $k$ identical resources through atomic \"wait\" and \"signal\" operations, design and implement a single-threaded deterministic program that simulates this process and produces quantifiable outputs. Your program must compute, for each test case:\n- A boolean represented as an integer $0$ or $1$ indicating whether any peer starved; here starvation is defined as the event that a peer never starts before the simulation completes. Under correct aging, this should be $1$ (meaning no starvation occurred) if all peers eventually start.\n- The average waiting time $\\overline{W} = \\frac{1}{n}\\sum_{i=0}^{n-1}(S_i - A_i)$, where $S_i$ is the start time of peer $i$, as a floating-point value printed with exactly six decimal places.\n- The start order list, containing the peer indices in the exact sequence they started (if multiple peers start at the same tick, the order among them must respect the tie-breaking rule by smallest index).\n\nUse the following test suite with parameters given explicitly:\n\nTest case $1$ (happy path with multiple slots):\n- $k = 2$\n- $n = 4$\n- Arrival times $[0, 0, 1, 2]$\n- Durations $[3, 2, 1, 2]$\n- Initial credits $[5, 3, 1, 4]$\n- Aging weight $\\alpha = 0.5$\n\nTest case $2$ (boundary case with a single slot and extreme credit skew):\n- $k = 1$\n- $n = 3$\n- Arrival times $[0, 0, 0]$\n- Durations $[3, 3, 3]$\n- Initial credits $[100, 0, 0]$\n- Aging weight $\\alpha = 1.0$\n\nTest case $3$ (edge case with simultaneous arrivals, unequal durations, and one highly credited peer):\n- $k = 3$\n- $n = 5$\n- Arrival times $[0, 0, 0, 0, 0]$\n- Durations $[1, 2, 3, 4, 5]$\n- Initial credits $[0, 0, 10, 0, 0]$\n- Aging weight $\\alpha = 0.1$\n\nFinal output format requirement:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case result is itself a list of the form $[\\,\\text{no\\_starvation},\\ \\overline{W},\\ [\\text{start\\_order}]\\,]$. For the three test cases above, the output must therefore be of the form\n\"[ [ns1,avg1,[o1,...]], [ns2,avg2,[o2,...]], [ns3,avg3,[o3,...]] ]\", but printed without any spaces, like \"[[ns1,avg1,[o1,...]],[ns2,avg2,[o2,...]],[ns3,avg3,[o3,...]]]\".",
            "solution": "The problem requires the design and implementation of a deterministic, discrete-time simulation of a peer-to-peer file sharing system. The system's concurrency is managed by a counting semaphore, and peer scheduling is governed by a priority policy that incorporates aging to prevent starvation.\n\nThe problem is first validated to ensure it is scientifically grounded, well-posed, and objective.\n\n### Step 1: Extract Givens\n- **System Parameters**:\n    - $n$: number of peers, indexed by $i \\in \\{0, 1, \\dots, n-1\\}$.\n    - $k$: a fixed number of upload slots (initial value of the semaphore).\n    - $t$: discrete time ticks, $t = 0, 1, 2, \\dots$.\n    - $\\alpha$: a fixed aging weight, $\\alpha \\in \\mathbb{R}_{>0}$.\n- **Peer Attributes**:\n    - $A_i$: arrival time of peer $i$, $A_i \\in \\mathbb{Z}_{\\ge 0}$.\n    - $D_i$: upload duration for peer $i$, $D_i \\in \\mathbb{Z}_{>0}$.\n    - $C_i$: initial credit for peer $i$, $C_i \\in \\mathbb{R}_{\\ge 0}$.\n- **Simulation Dynamics**:\n    - A peer becomes *waiting* at time $t$ if $t \\ge A_i$ and it has not yet started.\n    - $S(t)$: the internal value of the counting semaphore at time $t$. Initially $S(0) = k$.\n    - **Wait Operation**: A peer can start an upload only if $S(t) > 0$. Upon starting, $S(t)$ is decremented by $1$.\n    - **Signal Operation**: When an upload completes, $S(t)$ is incremented by $1$.\n    - $W_i(t)$: the waiting time of peer $i$ at time $t$, defined as the number of ticks it has been continuously waiting.\n    - $R(t)$: the number of currently running uploads at time $t$.\n- **Scheduling Policy**:\n    - At each time tick $t$, the scheduler selects waiting peers to start, up to the number of available slots, $k-R(t)$, which is equivalent to $S(t)$.\n    - The selection is based on maximizing the priority function $P_i(t) = C_i + \\alpha \\cdot W_i(t)$.\n    - Ties in priority $P_i(t)$ are broken by choosing the peer with the smallest index $i$.\n- **Outputs to Compute**:\n    1.  `no_starvation`: A boolean ($1$ for true, $0$ for false) indicating if all peers successfully started and completed their upload.\n    2.  $\\overline{W}$: The average waiting time, defined as $\\frac{1}{n}\\sum_{i=0}^{n-1}(S_i - A_i)$, where $S_i$ is the start time of peer $i$.\n    3.  `start_order`: A list of peer indices in the exact sequence they began their uploads.\n\n### Step 2: Validate Using Extracted Givens\nThe problem describes a discrete-time simulation model based on fundamental concepts in operating systems, namely counting semaphores and priority-based scheduling with aging.\n- **Scientifically Grounded**: The model is a valid and standard abstraction used in computer science to study scheduling algorithms. It rests on clear logical and mathematical principles.\n- **Well-Posed**: All parameters are provided in the test cases. The rules for state transition (peer arrival, starting, finishing) and the scheduling algorithm (priority calculation and tie-breaking) are deterministic. This guarantees a unique and computable sequence of events for any given input.\n- **Objective**: The problem is stated using precise, formal language without ambiguity or subjective elements.\n\nThe problem passes all validation criteria. It is not scientifically unsound, incomplete, contradictory, unrealistic, or ill-posed. The task is a standard implementation of a well-defined algorithm.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A solution will be provided.\n\n### Solution Design\nThe simulation will be implemented as a discrete-time process, advancing in ticks $t=0, 1, 2, \\dots$. The simulation loop continues as long as not all peers have completed their uploads.\n\n**State Representation:**\nThe state of each peer $i$ is maintained throughout the simulation, tracking:\n- `status`: The current state of the peer, which can be `NOT_ARRIVED`, `WAITING`, `RUNNING`, or `COMPLETED`.\n- `wait_ticks`: A counter for $W_i(t)$, the number of ticks the peer has been in the `WAITING` state.\n- `start_time`: The tick $t$ at which the peer starts its upload.\n- `completion_time`: The tick at which the peer's upload will finish, calculated as $S_i + D_i$.\n\n**Simulation Loop Algorithm:**\nThe simulation proceeds by iterating through time $t$. In each tick, the following sequence of operations is performed in a specific order to ensure correctness:\n\n1.  **Process Completions**: Iterate through all `RUNNING` peers. If for peer $i$, its `completion_time` is equal to the current time $t$, its status is changed to `COMPLETED`. For each completion, the semaphore value $S(t)$ is incremented (a \"signal\" operation), making a slot available.\n2.  **Process Arrivals and Update Waiting Times**: Iterate through all peers.\n    - If a peer $i$ with status `NOT_ARRIVED` has an arrival time $A_i$ equal to the current time $t$, its status is changed to `WAITING`.\n    - If a peer $i$ is in the `WAITING` state, its `wait_ticks` counter is incremented.\n3.  **Schedule New Uploads**: This step is executed as long as there are available slots ($S(t) > 0$) and peers in the `WAITING` state. In each iteration of this sub-step:\n    a. Identify the set of all currently `WAITING` peers.\n    b. If this set is empty, no more peers can be scheduled at this time.\n    c. For each peer $j$ in the `WAITING` set, calculate its priority $P_j(t) = C_j + \\alpha \\cdot W_j(t)$, using its current `wait_ticks` for $W_j(t)$.\n    d. Select the peer with the maximum priority. The tie-breaking rule (smallest index $i$) is applied if multiple peers share the same maximum priority.\n    e. The selected peer is scheduled to start:\n        - The semaphore value $S(t)$ is decremented (a \"wait\" operation).\n        - The peer's `status` is changed to `RUNNING`.\n        - Its `start_time` is recorded as the current time $t$.\n        - Its `completion_time` is calculated as $t + D_i$.\n        - Its index is appended to the `start_order` list.\n4.  **Advance Time**: Increment the simulation time $t$.\n\nThe main loop terminates once all $n$ peers have reached the `COMPLETED` state. Finally, the required outputs (`no_starvation`, $\\overline{W}$, and `start_order`) are calculated and formatted. The average wait time $\\overline{W}$ is computed from the recorded start times $S_i$ and given arrival times $A_i$.\n\nThis deterministic, step-by-step process correctly models the specified system and produces the required quantifiable results.",
            "answer": "[[1,0.500000,[0,1,3,2]],[1,3.000000,[0,1,2]],[1,0.600000,[2,0,1,3,4]]]"
        }
    ]
}