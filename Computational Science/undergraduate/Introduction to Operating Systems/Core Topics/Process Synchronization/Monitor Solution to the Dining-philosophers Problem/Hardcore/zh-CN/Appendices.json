{
    "hands_on_practices": [
        {
            "introduction": "本练习提供了对哲学家就餐系统的高层次、量化理解。通过推导系统吞吐量 $\\Lambda$ 的表达式，您将学习如何基于资源约束（例如，最多 $M$ 位哲学家同时进餐）和需求速率来识别性能瓶颈。这个练习  将帮助你从系统整体性能的角度分析并发控制算法的宏观效应。",
            "id": "3659316",
            "problem": "考虑一个经典的哲学家就餐问题系统，有 $N$ 位哲学家围坐在一张圆桌旁，以及 $N$ 把叉子，每对相邻的哲学家之间放一把。每位哲学家确定性地在思考（时长 $\\tau$）和进餐（时长 $\\sigma$）两种状态之间交替，并无限重复此循环。一个管程通过条件变量实现互斥与协调，以确保：\n\n- 没有两个相邻的哲学家同时进餐，即如果哲学家 $i$ 在进餐，那么哲学家 $i-1$ 和 $i+1$（索引对 $N$ 取模）不在进餐。\n- 最多有 $M$ 位哲学家同时进餐，其中 $M \\le \\lfloor N/2 \\rfloor$。\n- 请求进餐的哲学家会在管程中阻塞，直到其两边的叉子都可用且未达到全局同时进餐人数上限；进餐完成后，管程会释放叉子并通知等待的哲学家，以确保系统能够继续运行并避免饥饿。\n\n假设管程操作和信号通知的开销可忽略不计，管程中采用公平的调度策略以确保被阻塞的哲学家最终会被唤醒，并且系统能达到一个稳定状态。令 $\\Lambda(N,M,\\tau,\\sigma)$ 表示以“餐/秒”为单位的长期吞吐率（即进餐阶段完成的时间平均速率）。\n\n从互斥和服务时间守恒的第一性原理出发，推导 $\\Lambda(N,M,\\tau,\\sigma)$ 的闭式解析表达式。该表达式应为一个单一表达式，且能隐式地刻画上限 $M$ 何时成为约束以及它如何影响吞吐率。最终答案以“餐/秒”为单位表示，不要对结果进行四舍五入。你的推理必须基于管程所强制执行的、基于不变量的约束，以及每个完成的进餐阶段恰好消耗 $\\sigma$ 单位服务时间，并且在没有阻塞的情况下每个哲学家的周期时长为 $\\tau+\\sigma$ 这一事实。请给出 $\\Lambda(N,M,\\tau,\\sigma)$ 的最终表达式。",
            "solution": "问题要求推导哲学家就餐系统的长期吞吐率 $\\Lambda(N,M,\\tau,\\sigma)$ 的闭式解析表达式。推导过程将从第一性原理出发，从两个角度考虑系统：请求服务的哲学家和提供服务的资源。实际吞吐率将是这两个角度所确定的速率中的最小值，这是一个经典的瓶颈分析。\n\n设 $N$ 为哲学家数量，$\\tau$ 为思考时间，$\\sigma$ 为进餐时间。系统受到的约束是，没有两个相邻的哲学家同时进餐，并且在任何时刻最多有 $M$ 位哲学家在进餐，其中 $M \\le \\lfloor N/2 \\rfloor$。我们假设系统达到一个稳定、对称的稳态，在此状态下所有哲学家都表现出相同的平均行为。\n\n首先，我们从单个哲学家的角度分析系统。在一个完整的周期中，一位哲学家花费 $\\tau$ 的时间思考，花费 $W_{wait}$ 的时间等待资源（叉子和进餐名额），并花费 $\\sigma$ 的时间进餐。因此，单个哲学家的总平均周期时间为 $T_{cycle} = \\tau + \\sigma + W_{wait}$。单个哲学家的吞吐率，即他完成进餐的速率，是 $1 / T_{cycle}$。由于有 $N$ 位行为相同的哲学家，系统总吞吐率 $\\Lambda$ 是单个哲学家吞吐率的 $N$ 倍：\n$$\n\\Lambda = \\frac{N}{\\tau + \\sigma + W_{wait}}\n$$\n这个方程将系统吞吐率与平均等待时间联系起来，而平均等待时间目前是未知的。\n\n其次，我们从资源（即“进餐名额”）的角度分析系统。设 $E$ 为稳态下同时进餐的哲学家平均数量。这 $E$ 位哲学家中的每一位都在 $\\sigma$ 秒内完成进餐。根据利用率定律（Little's Law 的一个直接推论），一个系统的吞吐率等于繁忙服务器的平均数量除以平均服务时间。在这里，“服务器”是正在进餐的哲学家，“服务时间”是 $\\sigma$。因此，总吞吐率 $\\Lambda$ 由下式给出：\n$$\n\\Lambda = \\frac{E}{\\sigma}\n$$\n这为 $\\Lambda$ 提供了第二个表达式，将其与平均并发进餐人数 $E$ 联系起来。\n\n为了找到实际的吞吐率，我们必须确定系统的瓶颈。吞吐率要么受限于哲学家请求进餐的速率，要么受限于系统能够服务这些请求的速率。\n\n如果资源是无限的，系统可能达到的最大吞吐率，我们称之为需求驱动吞吐率 $\\Lambda_{demand}$，出现在没有资源竞争，因此没有等待时间（$W_{wait} = 0$）的情况下。在这种场景下，每个哲学家的周期时间就是 $\\tau + \\sigma$。吞吐率将是：\n$$\n\\Lambda_{demand} = \\frac{N}{\\tau + \\sigma}\n$$\n\n资源所能支持的最大吞吐率，我们称之为供给驱动吞吐率 $\\Lambda_{supply}$，由并发进餐的约束条件决定。问题陈述了两个约束：没有两个相邻的哲学家同时进餐，以及最多有 $M$ 位哲学家同时进餐。第一个约束意味着最多有 $\\lfloor N/2 \\rfloor$ 位并发进餐者。第二个约束是一个明确的上限 $M$。由于问题规定 $M \\le \\lfloor N/2 \\rfloor$，因此更严格的约束始终是全局上限 $M$。因此，平均进餐哲学家数 $E$ 不能超过 $M$。当系统以其最大容量运行时，系统达到饱和，这意味着 $E$ 达到其最大可能值 $E_{max} = M$。此时，供给方能支持的最大吞吐率为：\n$$\n\\Lambda_{supply} = \\frac{E_{max}}{\\sigma} = \\frac{M}{\\sigma}\n$$\n\n系统的实际稳态吞吐率 $\\Lambda$ 既不能超过需求速率，也不能超过供给速率。因此，吞吐率是这两个值的最小值：\n$$\n\\Lambda(N,M,\\tau,\\sigma) = \\min(\\Lambda_{demand}, \\Lambda_{supply})\n$$\n代入 $\\Lambda_{demand}$ 和 $\\Lambda_{supply}$ 的表达式，我们得到最终的闭式表达式：\n$$\n\\Lambda(N,M,\\tau,\\sigma) = \\min\\left(\\frac{N}{\\tau + \\sigma}, \\frac{M}{\\sigma}\\right)\n$$\n这个单一表达式隐式地刻画了系统的两种运行模式。\n1.  如果 $\\frac{N}{\\tau + \\sigma} \\le \\frac{M}{\\sigma}$，系统是受需求限制的（或受哲学家限制的）。吞吐率为 $\\Lambda = \\frac{N}{\\tau + \\sigma}$，资源上限 $M$ 不是约束瓶颈。这个不等式等价于 $\\frac{N\\sigma}{\\tau + \\sigma} \\le M$，这意味着哲学家所需求的平均进餐人数在系统容量之内。在这种情况下，$W_{wait} = 0$。\n\n2.  如果 $\\frac{N}{\\tau + \\sigma}  \\frac{M}{\\sigma}$，系统是受供给限制的（或受资源限制的）。吞吐率上限为 $\\Lambda = \\frac{M}{\\sigma}$。在这种模式下，存在资源竞争，哲学家会经历非零的平均等待时间，$W_{wait}  0$。上限 $M$ 是约束瓶颈。\n表达式 $\\min\\left(\\frac{N}{\\tau + \\sigma}, \\frac{M}{\\sigma}\\right)$ 巧妙地涵盖了这两种情况。",
            "answer": "$$\\boxed{\\min\\left(\\frac{N}{\\tau + \\sigma}, \\frac{M}{\\sigma}\\right)}$$"
        },
        {
            "introduction": "管程解决方案的效率取决于精确和最小化的信令。这个问题  挑战您去优化一个管程内部的信令逻辑，移除冗余操作以避免不必要的上下文切换，同时保持系统的正确性和活性。通过这个练习，你将深刻理解为何以及何时对一个特定的条件变量 $c[i]$ 发出信号是必要的。",
            "id": "3659274",
            "problem": "一个基于管程的哲学家就餐问题解决方案在条件变量的 Mesa 风格语义下实现，其中 signal 操作会唤醒一个等待线程并将其置于管程的入口队列，而 wait 操作会释放管程并挂起线程直到收到信号。哲学家的数量为 $N \\ge 5$，索引为 $0, 1, \\dots, N-1$。令 $\\mathrm{left}(i) = (i-1) \\bmod N$ 且 $\\mathrm{right}(i) = (i+1) \\bmod N$。每个哲学家 $i$ 维护一个状态 $s[i] \\in \\{\\mathrm{THINKING}, \\mathrm{HUNGRY}, \\mathrm{EATING}\\}$ 并拥有一个私有条件变量 $c[i]$。还有一个全局条件变量 $g$。所有对共享状态的访问都发生在管程内部，这保证了互斥。\n\n定义哲学家 $j$ 的启用谓词为\n$$\nP(j) \\equiv \\big(s[j] = \\mathrm{HUNGRY}\\big) \\land \\big(s[\\mathrm{left}(j)] \\ne \\mathrm{EATING}\\big) \\land \\big(s[\\mathrm{right}(j)] \\ne \\mathrm{EATING}\\big).\n$$\n\n考虑以下带有标记信号点 $S_1, S_2, \\dots, S_7$ 的详细管程代码。过程 $\\mathrm{test}(i)$ 检查启用谓词，如果为真，则将该哲学家转换为进食状态。\n\n- $\\mathrm{test}(i)$:\n  - 如果 $P(i)$ 成立，则\n    - 设置 $s[i] := \\mathrm{EATING}$。\n    - $S_1$: signal $c[i]$。\n    - $S_2$: signal $c[\\mathrm{left}(i)]$。\n    - $S_3$: signal $c[\\mathrm{right}(i)]$。\n\n- $\\mathrm{pickup}(i)$:\n  - 设置 $s[i] := \\mathrm{HUNGRY}$。\n  - 调用 $\\mathrm{test}(i)$。\n  - 当 $s[i] \\ne \\mathrm{EATING}$ 时，在 $c[i]$ 上 wait。\n  - $S_4$: signal $g$。\n\n- $\\mathrm{putdown}(i)$:\n  - 设置 $s[i] := \\mathrm{THINKING}$。\n  - $S_5$: signal $c[\\mathrm{left}(i)]$。\n  - $S_6$: signal $c[\\mathrm{right}(i)]$。\n  - 调用 $\\mathrm{test}(\\mathrm{left}(i))$; 然后调用 $\\mathrm{test}(\\mathrm{right}(i))$。\n  - $S_7$: broadcast $g$。\n\n假设如下：\n- 使用 Mesa 风格的条件变量，每个等待的线程在一个 while 循环中重新检查其条件。\n- 管程为上述所有操作提供互斥。\n- 调度器是弱公平的：一个持续被启用且无限次处于就绪状态的线程最终会运行。\n- 除非某个线程的启用谓词因管程内部发生的状态变化而刚刚变为真，否则不应向该线程发送信号，以避免伪唤醒。目标是在此准则下移除冗余的信号操作，同时保留安全性（没有两个相邻的哲学家同时进食）和活性（如果一个哲学家 $p$ 一直保持饥饿且其邻居最终停止进食，那么 $p$ 最终会进食）。\n\n哪个选项留下了代码中必须保留的最小信号操作集，以在遵守“仅当特定哲学家的启用谓词刚刚变为真时才发送信号”这一准则的同时，保留所述的安全性和活性属性，并移除所有其他冗余的信号/广播操作？\n\nA. 仅保留 $\\mathrm{test}(i)$ 内部的 $S_1$；移除 $S_2, S_3, S_4, S_5, S_6, S_7$。\n\nB. 保留 $S_1$ 并同时保留 $S_5$ 和 $S_6$；移除 $S_2, S_3, S_4, S_7$。\n\nC. 移除 $S_1, S_2, S_3, S_4, S_5, S_6$；仅保留 $S_7$（在 $\\mathrm{putdown}(i)$ 中对全局变量进行广播）。\n\nD. 移除 $S_1, S_4, S_7$；保留 $S_2, S_3, S_5, S_6$（在 $\\mathrm{test}$ 和 $\\mathrm{putdown}$ 中仅对邻居发信号）。",
            "solution": "用户希望我分析一个基于管程的哲学家就餐问题解决方案，并确定在遵守特定信号发送准则的同时，为维持安全性和活性所需的最小信号操作集。\n\n### 步骤 1：提取已知条件\n- **系统**：基于管程的哲学家就餐问题解决方案。\n- **哲学家数量**：$N \\ge 5$，索引为 $0, 1, \\dots, N-1$。\n- **邻居函数**：$\\mathrm{left}(i) = (i-1) \\bmod N$ 和 $\\mathrm{right}(i) = (i+1) \\bmod N$。\n- **哲学家状态**：$s[i] \\in \\{\\mathrm{THINKING}, \\mathrm{HUNGRY}, \\mathrm{EATING}\\}$。\n- **同步**：\n    - Mesa 风格的条件变量 (CV)：`signal` 将一个等待线程置于管程的入口队列；`wait` 释放管程并挂起线程。\n    - 每个哲学家的私有条件变量：$c[i]$。\n    - 一个全局条件变量：$g$。\n    - 管程保证所有操作的互斥性。\n- **启用谓词**：对于哲学家 $j$，$P(j) \\equiv \\big(s[j] = \\mathrm{HUNGRY}\\big) \\land \\big(s[\\mathrm{left}(j)] \\ne \\mathrm{EATING}\\big) \\land \\big(s[\\mathrm{right}(j)] \\ne \\mathrm{EATING}\\big)$。\n- **管程过程**：\n    - $\\mathrm{test}(i)$：如果 $P(i)$ 成立，则设置 $s[i] := \\mathrm{EATING}$ 并包含信号点 $S_1, S_2, S_3$。\n    - $\\mathrm{pickup}(i)$：设置 $s[i] := \\mathrm{HUNGRY}$，调用 $\\mathrm{test}(i)$，在 `while` 循环 (`while s[i] \\ne \\mathrm{EATING}`) 中等待 $c[i]$，并包含信号点 $S_4$。\n    - $\\mathrm{putdown}(i)$：设置 $s[i] := \\mathrm{THINKING}$，包含信号点 $S_5, S_6$，调用 $\\mathrm{test}(\\mathrm{left}(i))$ 和 $\\mathrm{test}(\\mathrm{right}(i))$，并包含信号点 $S_7$。\n- **信号点**：\n    - $S_1: \\mathrm{signal}~c[i]$ (在 $\\mathrm{test}(i)$ 中)\n    - $S_2: \\mathrm{signal}~c[\\mathrm{left}(i)]$ (在 $\\mathrm{test}(i)$ 中)\n    - $S_3: \\mathrm{signal}~c[\\mathrm{right}(i)]$ (在 $\\mathrm{test}(i)$ 中)\n    - $S_4: \\mathrm{signal}~g$ (在 $\\mathrm{pickup}(i)$ 中)\n    - $S_5: \\mathrm{signal}~c[\\mathrm{left}(i)]$ (在 $\\mathrm{putdown}(i)$ 中)\n    - $S_6: \\mathrm{signal}~c[\\mathrm{right}(i)]$ (在 $\\mathrm{putdown}(i)$ 中)\n    - $S_7: \\mathrm{broadcast}~g$ (在 $\\mathrm{putdown}(i)$ 中)\n- **假设与要求**：\n    - 线程在从 `wait` 唤醒后重新检查其条件（Mesa 语义的标准行为）。\n    - 弱公平的调度器。\n    - 信号发送准则：仅当线程的启用谓词因管程内的状态变化而刚刚变为真时，才应向其发送信号。\n    - 目标：找到保留安全性和活性的最小信号集。\n\n### 步骤 2：使用提取的已知条件进行验证\n问题陈述使用标准术语（管程、Mesa 语义、条件变量、哲学家就餐问题）描述了一个计算机科学中的经典同步问题。所有组件都得到了正式定义，前提与操作系统中的既定原则一致。该问题定义明确、客观且具有科学依据。它需要对给定的代码和同步原语进行严谨的分析，以确定一个最小的工作集。未发现任何缺陷。\n\n### 步骤 3：推导最小信号集\n\n问题的核心在于信号发送准则：仅当哲学家 $j$ 的谓词 $P(j)$ 刚刚变为真时才向其发送信号。让我们分析 $P(j)$ 何时可以从假变为真。\n谓词是 $P(j) \\equiv \\big(s[j] = \\mathrm{HUNGRY}\\big) \\land \\big(s[\\mathrm{left}(j)] \\ne \\mathrm{EATING}\\big) \\land \\big(s[\\mathrm{right}(j)] \\ne \\mathrm{EATING}\\big)$。\n要使 $P(j)$ 变为真，所有三个子句都必须为真。管程内部的状态变化必须导致最后一个为假的子句变为真。\n- 当哲学家 $j$ 调用 $\\mathrm{pickup}(j)$ 时，$s[j] = \\mathrm{HUNGRY}$ 这一项变为真。\n- 当哲学家 $\\mathrm{left}(j)$ 结束进食并调用 $\\mathrm{putdown}(\\mathrm{left}(j))$，将其状态从 $\\mathrm{EATING}$ 更改为 $\\mathrm{THINKING}$ 时，$s[\\mathrm{left}(j)] \\ne \\mathrm{EATING}$ 这一项变为真。\n- 当哲学家 $\\mathrm{right}(j)$ 调用 $\\mathrm{putdown}(\\mathrm{right}(j))$ 时，$s[\\mathrm{right}(j)] \\ne \\mathrm{EATING}$ 这一项变为真。\n\n因此，唯一能使一个正在等待的饥饿哲学家的谓词变为真的事件是其邻居结束进食。这发生在该邻居的 `putdown` 过程中。正确的逻辑是让结束进食的哲学家检查其行为是否使其任一邻居能够进食。给定的代码通过让 `putdown(i)` 调用 `test(left(i))` 和 `test(right(i))` 来实现这一点。\n\n现在，我们基于此原则以及对正确性（安全性和活性）的需求来分析每个信号。\n\n- **对 `test(i)` 中信号的分析**：\n  - $S_1: \\mathrm{signal}~c[i]$: 如果发现 $P(i)$ 为真并且状态被设置为 $s[i] := \\mathrm{EATING}$，则发出此信号。哲学家 $i$ 在 `pickup(i)` 过程中以条件 `while s[i] \\ne \\mathrm{EATING}` 等待 $c[i]$。在另一个线程执行 `test(i)` 并设置 `s[i] := \\mathrm{EATING}` 后，必须唤醒哲学家 $i$，以便它重新评估其循环条件，发现条件为假，然后继续进食。没有这个信号，一个被批准进食的哲学家将永远等待。因此，$S_1$ 对于**活性是必不可少的**。此信号不违反准则，因为它是对 $P(i)$ 已变为真且已被验证这一事实采取行动的直接后果。\n  - $S_2: \\mathrm{signal}~c[\\mathrm{left}(i)]$ 和 $S_3: \\mathrm{signal}~c[\\mathrm{right}(i)]$: 这些信号在 `test(i)` 成功后发送，意味着 $s[i]$ 刚刚被设置为 $\\mathrm{EATING}$。这个状态变化导致谓词 $P(\\mathrm{left}(i))$ 和 $P(\\mathrm{right}(i))$ 变为*假*（因为他们的一个邻居现在正在进食）。向一个其启用条件刚刚变为假的线程发送信号，直接违反了信号发送准则，且毫无用处。因此，根据指定的准则，$S_2$ 和 $S_3$ 是**冗余且不正确的**。\n\n- **对 `pickup(i)` 中信号的分析**：\n  - $S_4: \\mathrm{signal}~g$: 此信号在哲学家 $i$ 成功通过 `wait` 循环并被认为正在进食后发送。状态变化是 `s[i]` 变为 $\\mathrm{EATING}$。如前所述，这使得邻居的谓词变为假。它不会使任何其他先验未知的哲学家的谓词变为真。该信号作用于全局条件变量 $g$，但尚不清楚谁会等待它或为什么等待。鉴于存在特定的 `c[i]` 变量，此信号似乎没有目的。它肯定不符合信号发送准则。因此，$S_4$ 是**冗余的**。\n\n- **对 `putdown(i)` 中信号的分析**：\n  - $S_5: \\mathrm{signal}~c[\\mathrm{left}(i)]$ 和 $S_6: \\mathrm{signal}~c[\\mathrm{right}(i)]$: 这些信号在调用 `test(left(i))` 和 `test(right(i))` *之前*发送。当 `putdown(i)` 向 `c[left(i)]` 发送信号时，哲学家 `left(i)`（如果饥饿且在等待）将被唤醒。由于 Mesa 语义，它会重新进入管程并重新评估其等待条件：`s[left(i)] \\ne \\mathrm{EATING}`。这个条件仍然为假（其状态是 `HUNGRY`），因为会将其状态更改为 `EATING` 的 `test(left(i))` 调用尚未发生。所以，该哲学家会重新进入睡眠状态。这是一个伪唤醒。正确且高效的流程是先调用 `test(left(i))`，它将状态设置为 `EATING`，*然后*再发送信号（通过 $S_1$）。由于 `test` 调用与 $S_1$ 相结合提供了正确的信号机制，因此 $S_5$ 和 $S_6$ 是**冗余且低效的**。\n  - $S_7: \\mathrm{broadcast}~g$: 这会唤醒所有在全局条件变量 $g$ 上等待的线程。然而，`pickup` 过程指定哲学家等待其私有条件变量 `c[i]`。在 $g$ 上的广播不会唤醒它们。即使我们假设线程在 $g$ 上等待，广播的效率也远低于 `test` 调用提供的定向信号。它会导致“惊群效应”，即所有等待的哲学家都被唤醒并竞争管程，结果大多数发现它们的条件仍然为假。鉴于存在私有条件变量，$S_7$ 是**冗余且无效的**。\n\n**推导结论**：\n唯一既对活性至关重要又符合该解决方案逻辑的信号是 $S_1$。当一个哲学家 `i` 放下叉子时，它会对其邻居调用 `test`。如果一个邻居 `j` 现在可以进食，`test(j)` 会设置 `s[j] := \\mathrm{EATING}` 并使用 `S_1`（即 `signal c[j]`）来唤醒哲学家 `j`。这是该管程解决方案公认的正确且最小的结构。\n\n### 步骤 4：逐项分析选项\n\n- **A. 仅保留 $\\mathrm{test}(i)$ 内部的 $S_1$；移除 $S_2, S_3, S_4, S_5, S_6, S_7$。**\n  - 该选项反映了我们推导的结论。仅保留 $S_1$ 创建了由 Tanenbaum 为哲学家就餐问题提出的标准、正确且高效的解决方案。安全性由管程互斥内的谓词检查来保证。活性得到保证（在问题的定义下），因为一个结束进食的哲学家会测试其邻居，如果邻居可以进食，它就会被发信号。这是一个最小集，因为移除 $S_1$ 会破坏活性。\n  - **判定：正确。**\n\n- **B. 保留 $S_1$ 并同时保留 $S_5$ 和 $S_6$；移除 $S_2, S_3, S_4, S_7$。**\n  - 该选项保留了必要的信号 $S_1$，但也包含了冗余的信号 $S_5$ 和 $S_6$。如前分析，$S_5$ 和 $S_6$ 在状态被 `test` 调用改变*之前*发送，导致伪唤醒。由于目标是*最小*信号集，而 $S_5$ 和 $S_6$ 是冗余的，因此该选项不正确。\n  - **判定：不正确。**\n\n- **C. 移除 $S_1, S_2, S_3, S_4, S_5, S_6$；仅保留 $S_7$（在 $\\mathrm{putdown}(i)$ 中对全局变量进行广播）。**\n  - 该选项移除了必要的信号 $S_1$。没有 $S_1$，一个其状态被 `test` 调用设置为 `EATING` 的哲学家将永远不会从其在 `c[i]` 上的等待中被唤醒。此外，广播 $S_7$ 是作用在全局变量 $g$ 上的，而哲学家们正在等待他们的私有变量 $c[i]$。系统将无法工作并发生死锁。\n  - **判定：不正确。**\n\n- **D. 移除 $S_1, S_4, S_7$；保留 $S_2, S_3, S_5, S_6$（在 $\\mathrm{test}$ 和 $\\mathrm{putdown}$ 中仅对邻居发信号）。**\n  - 该选项移除了对活性至关重要的信号 $S_1$。它保留了违反信号准则的信号（$S_2, S_3$）和冗余且导致伪唤醒的信号（$S_5, S_6$）。这个信号集完全不正确。\n  - **判定：不正确。**",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "验证并发程序的正确性是出了名的困难。本练习  指导您构建一个确定性模拟器来测试管程的逻辑，通过设计断言来系统地检测一个与条件变量信令相关的微妙错误。这种方法将“不变量”等抽象概念变得具体化，并为你提供一种强大的并发代码测试技术。",
            "id": "3659295",
            "problem": "要求你设计并分析一个解决哲学家进餐问题的小型确定性模拟器，该模拟器基于管程，并明确以使用断言来检测一类特定的同步错误为目标。目标概念是使用单一互斥管程和一组针对每个哲学家的条件变量数组的管程解决方案，以确保正确且无死锁的同步。你将从第一性原理（管程语义和不变量）出发进行推理，并对这些语义进行编码，实现一个离散事件、单线程的模拟，从而使行为在独立程序中完全确定且可测试。\n\n你必须使用的基本依据包括来自经典操作系统的以下经过充分检验的定义和事实：\n- 管程对其方法强制实施互斥；任何时候最多只有一个线程在管程内部执行。\n- 条件变量支持 `wait` 和 `signal` 两个操作，用于根据共享状态的谓词来挂起和恢复线程。\n- 对于有 $N$ 个哲学家的哲学家进餐问题，一个安全性不变量是：任何两个相邻的哲学家不能同时进餐。\n- 标准的基于管程的解决方案维护一个状态数组 $\\text{state}[i] \\in \\{\\text{THINKING}, \\text{HUNGRY}, \\text{EATING}\\}$，并为每个哲学家 $i$ 维护一个条件变量 $\\text{self}[i]$。存在两个管程方法：$\\text{pickup}(i)$ 用于请求叉子，$\\text{putdown}(i)$ 用于释放叉子。一个辅助函数 $\\text{test}(i)$ 用于检查哲学家 $i$ 在其邻居的状态下是否可以进餐。\n\n你的模拟器不应创建线程。相反，它必须在一个确定的方法调用序列下，通过离散步骤来模拟管程操作和条件变量的效果。请使用以下精确模型：\n- 哲学家的索引为 $i \\in \\{0,1,\\dots,N-1\\}$。设 $\\ell(i) = (i-1) \\bmod N$ 且 $r(i) = (i+1) \\bmod N$。\n- 管程状态由数组 $\\text{state}[i] \\in \\{0,1,2\\}$（编码 THINKING (思考, $0$)、HUNGRY (饥饿, $1$) 和 EATING (进餐, $2$)）以及 $\\text{waiting}[i] \\in \\{\\text{false}, \\text{true}\\}$（指示哲学家 $i$ 是否在模拟的等待中被挂起）组成。\n- 模拟的方法定义如下：\n  - $\\text{pickup}(i)$:\n    1. 设置 $\\text{state}[i] \\leftarrow 1$。\n    2. 调用 $\\text{test}(i)$。\n    3. 如果 $\\text{state}[i] \\neq 2$，则设置 $\\text{waiting}[i] \\leftarrow \\text{true}$；否则立即返回。\n  - $\\text{putdown}(i)$:\n    1. 要求 $\\text{state}[i] = 2$；然后设置 $\\text{state}[i] \\leftarrow 0$。\n    2. 调用 $\\text{test}(\\ell(i))$，然后调用 $\\text{test}(r(i))$。\n  - $\\text{test}(i)$:\n    1. 如果 $\\text{state}[i] = 1$ 且 $\\text{state}[\\ell(i)] \\neq 2$ 且 $\\text{state}[r(i)] \\neq 2$，则设置 $\\text{state}[i] \\leftarrow 2$ 并向某个条件变量索引 $k$ 发出一个模拟信号。\n    2. 否则，不执行任何操作。\n- 模拟的信号传递通过清除一个等待标志来建模：当向索引 $k$ 发送信号时，如果 $\\text{waiting}[k]$ 为 $\\text{true}$，则设置 $\\text{waiting}[k] \\leftarrow \\text{false}$，否则不执行任何操作。\n\n引入一个单一的错误参数 $b \\in \\{0,1\\}$，它控制当哲学家 $i$ 进餐的前提条件满足时，在 $\\text{test}(i)$ 中如何选择索引 $k$：\n- 如果 $b=0$（无错误），则 $k \\leftarrow i$（向正确的、针对该哲学家的条件变量发送信号）。\n- 如果 $b=1$（注入错误），则 $k \\leftarrow r(i)$（向错误的条件变量发送信号：向右边邻居的条件变量而非哲学家 $i$ 自己的条件变量发送信号）。\n\n在每个模拟的管程方法返回后，你必须设计并检查以下断言：\n- 安全性不变量：对所有 $i$，$\\lnot(\\text{state}[i]=2 \\wedge \\text{state}[r(i)]=2)$。\n- 唤醒-安全性不变量：对所有 $i$，$\\lnot(\\text{state}[i]=2 \\wedge \\text{waiting}[i]=\\text{true})$。\n\n其背后的直觉是，第一个不变量编码了哲学家进餐问题的核心安全性，而第二个不变量编码了正确的条件信号语义：没有哲学家可以在处于 EATING (进餐) 状态的同时仍被标记为等待。\n\n你的程序必须：\n- 精确实现上述模拟器。\n- 运行一组固定的调度测试套件。一个调度是指一系列形如 $\\text{pickup}(i)$ 或 $\\text{putdown}(i)$ 的管程方法调用，作用于指定的哲学家索引。每个调度都从所有哲学家都处于 THINKING (思考) 状态且不等待的初始状态开始执行。\n- 对于每个调度，返回一个布尔结果，指示在该调度的整个执行过程中是否所有断言都成立。\n\n测试套件：\n- 案例 A (正常路径，无错误)：$N=5$, $b=0$, 调度 $\\big[\\text{pickup}(0), \\text{pickup}(1), \\text{pickup}(4), \\text{putdown}(0), \\text{putdown}(4), \\text{putdown}(1)\\big]$。\n- 案例 B (在启用邻居时触发错误)：$N=5$, $b=1$, 调度 $\\big[\\text{pickup}(0), \\text{pickup}(1), \\text{pickup}(4), \\text{putdown}(0), \\text{putdown}(4), \\text{putdown}(1)\\big]$。\n- 案例 C (边界情况 $N=2$，触发错误)：$N=2$, $b=1$, 调度 $\\big[\\text{pickup}(0), \\text{pickup}(1), \\text{putdown}(0)\\big]$。\n- 案例 D (存在错误但未被触发)：$N=5$, $b=1$, 调度 $\\big[\\text{pickup}(0), \\text{putdown}(0)\\big]$。\n\n答案规格：\n- 对于每个案例，如果所有断言在整个调度过程中都成立，则程序必须输出 $1$，否则输出 $0$。\n- 最终输出格式必须是单行，包含一个用方括号括起来的逗号分隔的结果列表，例如 $\\big[1,0,1\\big]$。\n\n你的程序应生成单行输出，包含用方括号括起来的逗号分隔的结果列表（例如，\"[1,0,0,1]\"）。此问题不涉及任何物理单位、角度或百分比；所有输出都是编码为整数的布尔值。",
            "solution": "该问题要求设计并实现一个用于哲学家进餐问题基于管程解决方案的确定性、单线程模拟器。该模拟器的目的是使用断言来验证正确性属性，特别是检测与不正确的条件变量信号发送相关的错误。\n\n### 基于原理的设计与模拟模型\n\n问题的核心在于将管程和条件变量的抽象语义转化为一个具体的、确定性的算法。在真实的多线程环境中，调度器的行为会引入非确定性。通过创建一个单线程、离散事件的模拟，我们可以确定性地分析特定操作序列的逻辑后果。\n\n**1. 状态表示**\n\n系统的状态（通常在管程内部管理）由两个大小为 $N$ 的数组表示，对应 $N$ 个哲学家：\n-   `state[i]`：一个整数数组，存储哲学家 $i$ 的状态。我们使用以下映射：$0$ 代表 THINKING (思考)，$1$ 代表 HUNGRY (饥饿)，$2$ 代表 EATING (进餐)。\n-   `waiting[i]`：一个布尔数组（表示为整数 $0$ 或 $1$），指示哲学家 $i$ 是否在一个条件变量上被挂起。`waiting[i] = 1` 意味着哲学家 $i$ 在管程内被阻塞，等待某个条件变为真。\n\n哲学家的索引是循环的，因此哲学家 $i$ 的左邻居和右邻居分别由 $\\ell(i) = (i - 1 + N) \\pmod{N}$ 和 $r(i) = (i + 1) \\pmod{N}$ 给出。\n\n**2. 管程操作的模拟**\n\n管程的同步方法（`pickup`、`putdown`）和内部辅助例程（`test`）被建模为操作此共享状态的函数。由于模拟是单线程的，互斥是隐式的；在任何给定时间只有一个函数在操作状态。\n\n-   **`test(i)`**：这是检查一个饥饿的哲学家是否可以开始进餐的核心逻辑。条件是哲学家 $i$ 必须是 HUNGRY (`state[i] = 1`) 并且它的两个邻居都不能是 EATING (`state[\\ell(i)] \\neq 2` 且 `state[r(i)] \\neq 2`)。如果满足此条件，`state[i]` 被设置为 EATING ($2$)。该函数还封装了信号机制。\n-   **条件变量信号发送 (`signal`)**：对条件变量的 `signal` 操作通过针对一个特定的等待中的哲学家来模拟。当 `test(i)` 确定哲学家 $i$ 可以进餐时，它应该对哲学家 $i$ 正在等待的条件变量发送信号。在我们的模型中，这是 `self[i]`。对哲学家 $k$ 的 `signal` 被建模为：如果 `waiting[k]` 为真，则将其设置为假。这代表了阻塞哲学家的“唤醒”。\n-   **`pickup(i)`**：这模拟了哲学家 $i$ 尝试获取叉子的过程。它首先将自己的状态设置为 HUNGRY (`state[i] = 1`)，然后调用 `test(i)` 看是否能立即进餐。如果 `test(i)` 的结果不是使其进入 EATING 状态，该哲学家就必须阻塞。这通过设置 `waiting[i] = 1` 来建模。\n-   **`putdown(i)`**：这模拟了哲学家 $i$ 释放其叉子的过程。它将其状态设置回 THINKING (`state[i] = 0`)。这个动作可能会使其饥饿的邻居能够进餐。因此，它调用 `test(\\ell(i))` 和 `test(r(i))` 来检查任一邻居现在是否可以继续。\n\n**3. 错误注入**\n\n为了测试系统的鲁棒性和我们断言的有效性，通过一个参数 $b \\in \\{0, 1\\}$ 引入了一个特定的错误。该错误针对 `test(i)` 函数内的信号发送逻辑。\n-   如果 $b=0$ (正确行为)，当哲学家 $i$ 可以进餐时，信号被发送给哲学家 $i$ (即 `signal(i)`)。如果哲学家 $i$ 正在等待，这会正确地唤醒它。\n-   如果 $b=1$ (错误行为)，信号被发送给右邻居，即哲学家 $r(i)$ (即 `signal(r(i))`)。这模拟了并发编程中常见的差一错误或指针错误。\n\n**4. 基于断言的验证**\n\n在每次模拟操作（`pickup` 或 `putdown`）之后，我们检查两个不变量以确保系统状态保持正确。任何一个断言在任何时候失败都会使该调度的执行无效。\n\n1.  **安全性不变量**：$\\forall i \\in \\{0, \\dots, N-1\\}, \\lnot(\\text{state}[i] = 2 \\wedge \\text{state}[r(i)] = 2)$。这是哲学家进餐问题的基本安全属性：任何两个相邻的哲学家不能同时进餐。\n2.  **唤醒-安全性不变量**：$\\forall i \\in \\{0, \\dots, N-1\\}, \\lnot(\\text{state}[i] = 2 \\wedge \\text{waiting}[i] = \\text{true})$。这是一个新颖的不变量，旨在测试条件变量机制本身的正确性。它断言一个哲学家不能在处于 EATING (进餐) 状态的同时也被标记为等待。从逻辑上讲，一个正在进餐的哲学家已经成功获取了必要的资源，不应该被阻塞。违反此不变量表明一个哲学家的状态被更改为 EATING，但相应的 `signal` 操作未能清除其 `waiting` 标志，这正是我们旨在检测的那个错误。\n\n**5. 测试案例分析**\n\n让我们追踪案例 B：$N=5$, $b=1$, 调度 `[pickup(0), pickup(1), pickup(4), putdown(0), ...]`。\n-   初始时，所有状态都是 $0$ (THINKING)，并且 `waiting` 标志都为假。\n-   `pickup(0)`：`test(0)` 成功。`state[0]` 变为 $2$ (EATING)。由于 $b=1$，信号被发送给哲学家 $r(0)=1$，但 `waiting[1]` 为假，所以这是一个空操作。所有断言都成立。\n-   `pickup(1)`：`test(1)` 失败，因为邻居 $0$ 正在进餐。`state[1]` 为 $1$ (HUNGRY)，并且 `waiting[1]` 被设置为真。所有断言都成立。\n-   `pickup(4)`：`test(4)` 失败，因为邻居 $0$ 正在进餐。`state[4]` 为 $1$ (HUNGRY)，并且 `waiting[4]` 被设置为真。所有断言都成立。\n-   `putdown(0)`：`state[0]` 变为 $0$ (THINKING)。这会调用 `test(l(0)=4)` 和 `test(r(0)=1)`。\n    -   `test(4)`：现在成功。`state[4]` 变为 $2$ (EATING)。错误的信号被发送给 $r(4)=0$。`waiting[0]` 为假，因此这是一个空操作。关键的是，信号*没有*发给哲学家 $4$，所以 `waiting[4]` 仍然为真。\n    -   `test(1)`：也成功。`state[1]` 变为 $2$ (EATING)。错误的信号被发送给 $r(1)=2$。`waiting[2]` 为假，是一个空操作。`waiting[1]` 仍然为真。\n-   在 `putdown(0)` 返回后，检查断言。现在的状态是 `state=[0,2,0,0,2]` 和 `waiting=[0,1,0,0,1]`。\n    -   检查唤醒-安全性不变量 $\\lnot(\\text{state}[i]=2 \\wedge \\text{waiting}[i]=\\text{true})$。\n    -   对于 $i=1$：`state[1]=2` 且 `waiting[1]=1`。条件为真，因此不变量被违反。\n    -   对于 $i=4$：`state[4]=2` 且 `waiting[4]=1`。条件为真，因此不变量被违反。\n案例 B 的模拟正确地返回 $0$ (失败)。这证明了所选断言在检测指定同步错误方面的有效性。",
            "answer": "[1,0,0,1]"
        }
    ]
}