{
    "hands_on_practices": [
        {
            "introduction": "正确使用锁不仅仅是简单地在代码中加入 `lock()` 和 `unlock()` 调用。一个更关键的问题是：锁应该保护什么？这个练习  揭示了一个常见的编程陷阱，即锁只保护了最终的写操作，却没有保护用来决定写入位置的整个逻辑。这种保护范围的不足导致了“撕裂读”（torn read）漏洞，使得多个线程可能意外地写入同一位置，从而破坏了数据的一致性。\n\n通过分析这个场景，你将学会如何精确地界定临界区的范围。这不仅是保护一个共享变量的写入，而是要保护一个必须以原子方式执行的完整“读-改-写”序列。这项练习将磨练你识别并发代码中微妙数据竞争的能力，并加深对互斥锁正确作用域的理解。",
            "id": "3687271",
            "problem": "两个生产者线程 $T_1$ 和 $T_2$ 将记录附加到一个大小为 $R \\times C$ 的共享二维缓冲区 $B$ 中，其中 $C = 2$ 列。$B$ 中的一个位置由一对 $(i,j)$ 寻址，$(i,j)$ 的线性索引为 $s(i,j) = i \\cdot C + j$。有一个共享光标 $(I,J)$，用于编码下一个空闲槽位。为了减少感知到的竞争，该实现使用以下有缺陷的协议：\n- 每个线程在不持有锁的情况下，分别读取 $I$ 和 $J$ 到每个线程的本地变量 $(i,j)$ 中。\n- 然后每个线程获取一个互斥锁 $L$，将其记录写入 $B[i][j]$，然后释放 $L$。\n- 释放 $L$ 后，每个线程通过非原子存储来推进共享光标：它首先设置 $J := (j+1) \\bmod C$，如果结果为 $0$，它随后设置 $I := I + 1$。对 $J$ 和 $I$ 的这两个更新不是原子执行的，并且两者都不受 $L$ 的保护。\n\n假设初始共享状态为 $(I,J) = (k,0)$，其中 $k$ 为某个 $\\ge 0$ 的整数，并且两个线程都严格按照所描述的协议执行。系统是一个传统的中央处理器（CPU），对于单变量的读写具有顺序一致性排序，但不能保证对作为复合状态的 $(I,J)$ 对的原子性。在本问题中，“重复条目”指的是将来自 $T_1$ 和 $T_2$ 的不同记录两次写入到同一个 $B[i][j]$ 槽位。\n\n尽管存在互斥锁 $L$，但由于对 $I$ 或 $J$ 的更新是非原子的并且发生在 $L$ 的保护之外，下列哪种交错执行会在 $B$ 中产生重复条目？\n\nA. 安全推进，无撕裂读：\n- $T_1$：读取 $I = k$；读取 $J = 0$；获取 $L$；写入 $B[k][0]$；释放 $L$；设置 $J := 1$。\n- $T_2$：读取 $I = k$；读取 $J = 1$；获取 $L$；写入 $B[k][1]$；释放 $L$；设置 $J := 0$；设置 $I := k + 1$。\n\nB. 跨非原子更新的撕裂读导致重复：\n- $T_1$：读取 $I = k$。\n- $T_2$：获取 $L$；写入 $B[k][0]$；释放 $L$；设置 $J := 1$。\n- $T_1$：读取 $J = 1$；其本地变量现在是 $(i_1,j_1) = (k,1)$。\n- $T_2$：读取 $I = k$；读取 $J = 1$；获取 $L$；写入 $B[k][1]$；释放 $L$；设置 $J := 0$；设置 $I := k + 1$。\n- $T_1$：获取 $L$；写入 $B[k][1]$；释放 $L$；设置 $J := 0$；设置 $I := k + 1$。\n\nC. 跨线程的回绕分割但槽位仍然唯一：\n- $T_1$：读取 $I = k$；读取 $J = 0$；获取 $L$；写入 $B[k][0]$；释放 $L$；设置 $J := 1$。\n- $T_2$：读取 $I = k$；读取 $J = 1$；获取 $L$；写入 $B[k][1]$；释放 $L$；设置 $J := 0$；设置 $I := k + 1$。\n- $T_1$：稍后读取 $I = k + 1$；读取 $J = 0$；获取 $L$；写入 $B[k+1][0]$；释放 $L$。\n\nD. $I$ 的增量丢失但没有重复槽位：\n- $T_1$：读取 $I = k$；读取 $J = 0$；获取 $L$；写入 $B[k][0]$；释放 $L$；设置 $J := 1$。\n- $T_2$：读取 $I = k$；读取 $J = 1$；获取 $L$；写入 $B[k][1]$；释放 $L$；设置 $J := 0$。\n- $T_1$：设置 $I := k + 1$；$T_2$ 也设置 $I := k + 1$；两者在下一次迭代中都以 $I = k + 1$ 和 $J = 0$ 继续进行。\n\n选择唯一的正确选项。\n\n你的推理必须从临界区问题的核心定义及其正确性要求（互斥、前进、有界等待）以及共享状态更新的原子性定义开始。然后，推断每种交错执行是否会导致对同一 $B[i][j]$ 槽位的重复写入，并解释为什么互斥锁 $L$ 在强制执行必要的正确性方面失败或成功。",
            "solution": "用户希望我验证并解决一个与并发和临界区问题相关的问题。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n\n*   **线程：** 两个生产者线程，$T_1$ 和 $T_2$。\n*   **共享缓冲区：** $B$，一个大小为 $R \\times C$ 的二维缓冲区。\n*   **缓冲区列数：** $C = 2$。\n*   **缓冲区寻址：** 一个位置 $(i,j)$ 的线性索引为 $s(i,j) = i \\cdot C + j$。\n*   **共享状态：** 一个光标 $(I,J)$ 指示下一个可用槽位。\n*   **协议：**\n    1.  每个线程分别将共享变量 $I$ 和 $J$ 读入各自的本地变量 $(i,j)$ 中。此操作不持有任何锁。\n    2.  每个线程获取一个互斥锁 $L$。\n    3.  每个线程将其记录写入缓冲区槽位 $B[i][j]$。\n    4.  每个线程释放互斥锁 $L$。\n    5.  释放 $L$ 后，每个线程更新共享光标。它首先执行 $J := (j+1) \\bmod C$。如果此操作导致 $J$ 被设置为 $0$，它随后执行 $I := I + 1$。对 $I$ 和 $J$ 的这些更新不是原子地一起执行的，也不受互斥锁 $L$ 的保护。\n*   **初始条件：** 共享光标的初始状态为 $(I,J) = (k,0)$，其中 $k$ 为某个 $\\ge 0$ 的整数。\n*   **系统模型：** 对单变量的读写具有顺序一致性。$(I,J)$ 对不能被原子地读取或写入。\n*   **关键定义：** “重复条目”被定义为将来自 $T_1$ 和 $T_2$ 的两个不同记录写入同一个缓冲区槽位 $B[i][j]$。\n*   **问题：** 用户想确定在所提供的交错执行中，哪一个会因为光标更新的非原子性（这些更新发生在由 $L$ 保护的临界区之外）而导致重复条目。\n\n**步骤 2：使用提取的已知条件进行验证**\n\n1.  **科学基础：** 该问题是并发编程中竞态条件的经典示例，是操作系统和计算机科学的核心主题。所使用的元素——线程、共享内存、互斥锁、非原子操作和竞态条件——都是基本且公认的概念。\n2.  **适定性：** 协议的描述足够详细，可以分析特定执行交错的后果。初始状态已定义，问题要求在一组封闭的选项中找到一个具体的、可识别的结果（重复条目）。可以确定一个唯一的正确答案。\n3.  **客观性：** 问题以精确、正式的语言陈述，没有歧义或主观主张。诸如“非原子”、“互斥锁”和“顺序一致”等术语在此上下文中具有标准的、客观的含义。\n4.  **缺陷清单：**\n    *   **科学不严谨：** 无。该场景真实地描绘了一个常见的编程错误。\n    *   **不相关性：** 该问题与临界区问题、原子性以及并发系统中的正确性条件等主题直接相关。\n    *   **不完整/矛盾：** 问题是自洽的，并提供了跟踪执行场景所需的所有信息。“有缺陷的协议”的描述是一个前提，而不是一个矛盾。\n    *   **不切实际：** 该场景非常现实。程序员经常犯一个错误，即不保护用于确定对共享资源访问的状态，即使他们保护了访问本身。\n    *   **不适定：** 问题的结构使得通过仔细分析可以得出一个唯一的正确答案。\n    *   **琐碎/同义反复：** 问题不琐碎。它需要仔细跟踪程序状态，并理解互斥锁的保护范围如何可能不足。互斥锁 $L$ 的存在可能会错误地让人相信所有竞态条件都已避免，但错误在于 $L$ 的保护范围之外。\n\n**步骤 3：结论和行动**\n\n问题陈述是**有效**的。它科学严谨、适定、客观，并为分析提供了明确的基础。我将继续推导解决方案。\n\n### 解决方案推导\n\n解决临界区问题的正确性要求确保互斥、前进和有界等待。在这个问题中，共享资源是缓冲区 $B$。该协议试图确保每个线程都写入一个唯一的槽位。互斥锁 $L$ 正确地对写操作`将其记录写入 B[i][j]`强制执行了互斥。这意味着如果两个线程试图同时写入完全相同的槽位 $B[i][j]$，互斥锁将序列化它们的访问，防止字节级别的写损坏。但是，它并不能防止一个线程完成的写入被另一个线程随后对同一位置的写入所覆盖。\n\n如定义所述，“重复条目”错误将在两个线程 $T_1$ 和 $T_2$ 在写入前计算出相同的本地索引对 $(i,j)$ 时发生。如果确定下一个空闲槽位的逻辑不是原子的，就会发生这种情况。该协议的漏洞在于，读取共享光标 $(I,J)$ 及其后续更新不是作为一个由互斥锁 $L$ 保护的单一原子操作来执行的。这允许了破坏预期逻辑的交错执行。\n\n光标更新逻辑规定，在写入槽位 $(i,j)$ 后，线程计算 $J_{new} = (j+1) \\bmod 2$。如果 $J_{new}=0$，意味着该行已满，线程还必须增加 $I$。这个两步更新（先 $J$，然后可能是 $I$）是非原子的，并且发生在锁之外。由于最初对 $I$ 和 $J$ 的读取也是分开且未受保护的，这个漏洞被进一步加剧。\n\n让我们以初始共享状态 $(I,J) = (k,0)$ 和 $C=2$ 来分析每个选项。\n\n**选项 A：安全推进，无撕裂读**\n1.  $T_1$：读取 $I \\to i_1:=k$；读取 $J \\to j_1:=0$。本地索引为 $(k,0)$。\n2.  $T_1$：获取 $L$，写入 $B[k][0]$，释放 $L$。\n3.  $T_1$：更新共享状态。$j_1=0$，因此它计算 $(0+1)\\bmod 2=1$。设置共享 $J:=1$。共享状态为 $(I,J)=(k,1)$。\n4.  $T_2$：读取 $I \\to i_2:=k$；读取 $J \\to j_2:=1$。本地索引为 $(k,1)$。\n5.  $T_2$：获取 $L$，写入 $B[k][1]$，释放 $L$。\n6.  $T_2$：更新共享状态。$j_2=1$，因此它计算 $(1+1)\\bmod 2=0$。设置共享 $J:=0$。因为结果是 $0$，它接着设置共享 $I:=I+1$，变为 $k+1$。最终共享状态为 $(I,J)=(k+1,0)$。\n这种交错执行正确地填充了槽位 $B[k][0]$ 和 $B[k][1]$，没有冲突。\n**结论：** 不正确。\n\n**选项 B：跨非原子更新的撕裂读导致重复**\n该跟踪意味着在跟踪开始之前，$T_2$ 已经确定其槽位为 $(k,0)$。让我们假设 $T_2$ 之前已经读取了 $(I,J)=(k,0)$ 以获得其本地索引 $(i_2, j_2)=(k,0)$。\n1.  共享状态：$(I,J)=(k,0)$。\n2.  $T_1$：读取 $I$。本地变量 $i_1$ 现在是 $k$。\n3.  $T_2$：（使用其预先计算的本地索引 $(k,0)$）获取 $L$，写入 $B[k][0]$，释放 $L$。\n4.  $T_2$：更新共享状态。其本地变量 $j_2=0$，因此它设置共享 $J:=(0+1)\\bmod 2 = 1$。共享光标现在是 $(I,J)=(k,1)$。\n5.  $T_1$：读取 $J$。它读到值 $1$。其本地索引现在组装为 $(i_1,j_1)=(k,1)$。这是一个“撕裂读”，因为 $T_1$ 从状态 $(k,0)$ 读取了 $I$，而从状态 $(k,1)$ 读取了 $J$。\n6.  $T_2$：开始其下一个操作。它读取共享的 $I=k$ 和共享的 $J=1$。其新的本地索引为 $(i_2,j_2)=(k,1)$。\n7.  现在，$T_1$ 和 $T_2$ 都计算出了相同的目标地址：槽位 $B[k][1]$。\n8.  根据跟踪：$T_2$ 先执行。它获取 $L$，将其记录写入 $B[k][1]$，然后释放 $L$。\n9.  然后，$T_1$ 执行。它获取 $L$，将其记录写入 $B[k][1]$，然后释放 $L$。\n$T_1$ 的写入覆盖了 $T_2$ 刚刚写入的记录。这构成了对同一槽位的“重复条目”（或者更准确地说，是一次丢失的更新），违反了程序的意图。这个失败的发生，正是因为 $T_2$ 对共享光标的非原子更新使得 $T_1$ 得以执行一次撕裂读。\n**结论：** 正确。\n\n**选项 C：跨线程的回绕分割但槽位仍然唯一**\n这个跟踪基本上结合了选项 A 的操作，然后展示了多一个步骤。\n1.  $T_1$：写入 $B[k][0]$。共享光标变为 $(k,1)$。\n2.  $T_2$：写入 $B[k][1]$。共享光标变为 $(k+1,0)$。\n3.  $T_1$：（在其下一次迭代中）读取 $I=k+1$ 和 $J=0$。获取 $L$ 并写入 $B[k+1][0]$。\n在这个序列中，写入操作分别针对 $B[k][0]$、$B[k][1]$ 和 $B[k+1][0]$。这些都是不同的槽位。没有发生重复条目。\n**结论：** 不正确。\n\n**选项 D：$I$ 的增量丢失但没有重复槽位**\n这个跟踪描述了 $T_1$ 写入 $B[k][0]$ 且 $T_2$ 写入 $B[k][1]$ 的场景。\n1.  $T_1$ 写入 $B[k][0]$。其本地变量 $j_1=0$。它将共享的 $J$ 更新为 $1$。根据协议，它*不*更新 $I$。\n2.  $T_2$ 写入 $B[k][1]$。其本地变量 $j_2=1$。它将共享的 $J$ 更新为 $0$。根据协议，它*负责*增加 $I$。\n跟踪陈述：“$T_1$：设置 $I := k + 1$”。这个陈述与问题指定的协议相矛盾，因为在这种情况下 $T_1$ 没有任何条件来更新 $I$。不管跟踪描述中存在这种协议违规，跟踪本身显示了对 $B[k][0]$ 和 $B[k][1]$ 的写入，它们是不同的槽位。描述甚至明确表示“没有重复槽位”。$I$ 的增量丢失是另一种类型的并发错误（对 $I$ 本身的数据竞争），它会导致行被跳过或稍后被覆盖，但不会以所描述的方式立即导致重复槽位写入。\n**结论：** 不正确。",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "许多经典的并发算法，如 Peterson 算法，其正确性证明通常建立在一个理想化的“顺序一致性”（Sequential Consistency）内存模型之上。然而，现代多核处理器为了性能通常采用“弱内存模型”。这个练习  让你直面理论与现实的差距：当一个在顺序一致性模型下完美的算法，在没有内存屏障（memory fence）的弱内存模型硬件上运行时，会发生什么？\n\n此练习的核心是理解硬件可能对内存操作进行重排序，导致一个线程看到的事件顺序与另一个线程的不同，从而破坏算法的內在逻辑。通过移除 Peterson 算法中的关键内存屏障，你将构造一个违反互斥性的反例。这项实践不仅揭开了内存模型的神秘面纱，也让你深刻体会到内存屏障在编写正确底层同步原语中的关键作用。",
            "id": "3687333",
            "problem": "考虑一个双进程锁，它是 Peterson 双进程算法的一个栅栏增强变体，并且已知在具有每核存储缓冲区的弱序架构上满足三个临界区正确性要求——互斥、进展和有界等待。存在两个进程 $P_0$ 和 $P_1$ 以及三个共享变量：一个布尔数组 $flag[\\,]$，由进程标识符 $\\{0,1\\}$ 索引；以及一个共享变量 $turn \\in \\{0,1\\}$。初始状态为 $flag[0] = \\text{false}$，$flag[1] = \\text{false}$ 和 $turn = 0$。每个进程 $P_i$（其中 $i \\in \\{0,1\\}$）在进入其临界区之前执行以下进入协议，并在离开后执行退出协议：\n\n$P_i$ 的进入协议：\n- 设置 $flag[i] \\leftarrow \\text{true}$。\n- 执行一个完整的内存栅栏 $F$。\n- 设置 $turn \\leftarrow 1 - i$。\n- 当 $(flag[1-i] \\land (turn = 1-i))$ 时忙等待。\n- 进入临界区。\n\n$P_i$ 的退出协议：\n- 设置 $flag[i] \\leftarrow \\text{false}$。\n\n假设硬件实现了每核存储缓冲：一个进程的存储操作对该进程立即变得可见，但可能在非确定性延迟后才对另一个进程可见。一个进程的加载操作可以从内存中读取，而无需等待该进程之前对不同地址的存储操作对另一个进程可见。一个完整的内存栅栏 $F$ 会在允许任何后续内存操作进行之前，清空发出进程的存储缓冲区。对同一地址的存储操作不会重排序，并且系统尊重每个位置的一致性。这是一个简化且广泛使用的、带有存储缓冲的弱内存的操作性描述，足以用于对此程序进行推理。\n\n假设我们从进入协议中移除单个栅栏 $F$（即删除“执行一个完整的内存栅栏 $F$”这一行），并保持所有其他步骤不变。在上述模型下，修改后的锁可能满足也可能不满足正确性要求。\n\n您的任务是选择下面的交错，该交错在指定的内存模型下既是可行的，又通过容许一个 $P_0$ 和 $P_1$ 同时处于临界区内的执行，展示了对互斥性的违反。在每个选项中，“已缓冲”意味着存储操作仍保留在发出核心的存储缓冲区中（尚未对其他进程可见），而“可见”意味着存储操作已传播并可被其他进程读取。\n\nA. 利用了两个进程的存储缓冲的交错：\n- 步骤 1：$P_0$：$flag[0] \\leftarrow \\text{true}$ (已缓冲)。\n- 步骤 2：$P_1$：$flag[1] \\leftarrow \\text{true}$ (已缓冲)。\n- 步骤 3：$P_0$：$turn \\leftarrow 1$ (可见)。之前的 $flag[0]$ 存储操作仍处于缓冲状态。\n- 步骤 4：$P_1$：$turn \\leftarrow 0$ (可见)。之前的 $flag[1]$ 存储操作仍处于缓冲状态。\n- 步骤 5：$P_0$：加载 $flag[1]$ 并读到 $\\text{false}$ (因为 $P_1$ 的 $flag[1]$ 仍在缓冲中)，将条件 $(flag[1] \\land (turn = 1))$ 评估为 $\\text{false}$，并进入临界区。\n- 步骤 6：$P_1$：加载 $flag[0]$ 并读到 $\\text{false}$ (因为 $P_0$ 的 $flag[0]$ 仍在缓冲中)，将条件 $(flag[0] \\land (turn = 0))$ 评估为 $\\text{false}$，并进入临界区。\n- 结果：$P_0$ 和 $P_1$ 同时处于临界区内。\n\nB. 因 $flag$ 产生竞争但由 $turn$ 解决的交错：\n- 步骤 1：$P_0$：$flag[0] \\leftarrow \\text{true}$ (可见)。\n- 步骤 2：$P_1$：$flag[1] \\leftarrow \\text{true}$ (可见)。\n- 步骤 3：$P_0$：$turn \\leftarrow 1$ (可见)。\n- 步骤 4：$P_1$：$turn \\leftarrow 0$ (可见)。\n- 步骤 5：$P_0$：加载 $flag[1]$ 为 $\\text{true}$ 和 $turn$ 为 $0$，评估 $(\\text{true} \\land (0 = 1)) = \\text{false}$，并进入临界区，而 $P_1$ 则自旋等待。\n- 结果：只有一个进程进入临界区。\n\nC. 假设对同一观察者存在写-写重排序的交错：\n- 步骤 1：$P_0$：$flag[0] \\leftarrow \\text{true}$ (已缓冲)。\n- 步骤 2：$P_0$：$turn \\leftarrow 1$ (在 $flag[0]$ 之前对 $P_1$ 可见)。\n- 步骤 3：$P_1$：加载 $flag[0]$ 为 $\\text{true}$ (即使 $P_0$ 的 $flag[0]$ 存储仍在缓冲中) 并自旋等待。\n- 结果：$P_1$ 等待，互斥性得以保持。\n\nD. 导致两个进程在进入循环中死锁的交错：\n- 步骤 1：$P_0$ 和 $P_1$ 都使其对 $flag$ 的存储变得可见。\n- 步骤 2：两者都将 $turn$ 设置为对方的标识符。\n- 步骤 3：两者都读取 $flag[\\cdot]$ 为 $\\text{true}$ 并同时读取 $turn$ 等于对方的标识符，因此两个条件都为 $\\text{true}$，两者都永远自旋等待。\n- 结果：两个进程都无限期地卡在进入循环中。\n\n在移除单个栅栏后，哪个选项正确描述了一个在给定模型下破坏互斥性的可行反例交错？\n\n- A\n- B\n- C\n- D",
            "solution": "首先对问题陈述进行验证。\n\n**步骤 1：提取已知条件**\n- **进程：** 两个进程，$P_0$ 和 $P_1$。\n- **共享变量：** 一个布尔数组 $flag[\\,]$，由进程标识符 $\\{0,1\\}$ 索引；以及一个共享变量 $turn \\in \\{0,1\\}$。\n- **初始状态：** $flag[0] = \\text{false}$，$flag[1] = \\text{false}$ 和 $turn = 0$。\n- **$P_i$ (其中 $i \\in \\{0,1\\}$) 的修改后进入协议 (已移除栅栏)：**\n    1. 设置 $flag[i] \\leftarrow \\text{true}$。\n    2. 设置 $turn \\leftarrow 1 - i$。\n    3. 当 $(flag[1-i] \\land (turn = 1-i))$ 时忙等待。\n    4. 进入临界区。\n- **$P_i$ 的退出协议：**\n    1. 设置 $flag[i] \\leftarrow \\text{false}$。\n- **内存模型：**\n    - 实现了每核存储缓冲。\n    - 存储操作对发出进程立即变得可见。\n    - 存储操作在非确定性延迟后对其他进程变得可见。\n    - 加载操作可以继续进行，无需等待发出进程之前对不同地址的存储操作对其他进程可见。\n    - 一个完整的内存栅栏 $F$ (在问题场景中被移除) 会清空存储缓冲。\n    - 对同一内存地址的存储操作不会被重排序 (尊重每个位置的一致性)。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题具有科学依据。所描述的场景涉及用于互斥的 Peterson 算法以及一个简化但标准的弱内存一致性模型（具体来说，是一个带有存储缓冲的模型，类似于总存储顺序或 TSO）。这些是操作系统和计算机体系结构中的基本主题。问题陈述清晰，要求在给定规则下找出一个特定的反例（违反互斥性）。语言客观而精确。前提之间并不矛盾；移除栅栏是其后果有待探讨的核心变化。这个设置并非微不足道，需要仔细推理算法和内存模型之间的交互。问题有效。\n\n**步骤 3：结论与行动**\n问题有效。我将继续进行解题推导和选项分析。\n\n**推导与选项分析**\n\n目标是为修改后的算法找到一个可行的指令交错，从而导致违反互斥性，即 $P_0$ 和 $P_1$ 同时处于其临界区内。\n\n如果 $P_0$ 绕过了其忙等待循环，并且 $P_1$ 也绕过了其忙等待循环，就会发生互斥性违规。\n- 要使 $P_0$ 进入，条件 $(flag[1] \\land (turn = 1))$ 必须评估为 $\\text{false}$。\n- 要使 $P_1$ 进入，条件 $(flag[0] \\land (turn = 0))$ 必须评估为 $\\text{false}$。\n\n指定内存模型的关键特性是存储缓冲。当 $P_i$ 执行像 $flag[i] \\leftarrow \\text{true}$ 这样的存储指令时，新值被写入其本地存储缓冲。要让另一个进程 $P_{1-i}$ 看到这个新值，该存储必须从 $P_i$ 的缓冲刷新到主内存，这在非确定性延迟后发生。关键的是，在没有内存栅栏的情况下，$P_i$ 可以在其对 $flag[i]$ 的存储变得全局可见之前，执行后续指令（如设置 $turn$ 或读取 $flag[1-i]$）。\n\n让我们基于这个原则构建一个反例：\n1.  $P_0$ 执行 `Set $flag[0] \\leftarrow \\text{true}$`。这个写操作被保存在 $P_0$ 的存储缓冲中。主内存中仍然是 $flag[0] = \\text{false}$。\n2.  $P_1$ 执行 `Set $flag[1] \\leftarrow \\text{true}$`。这个写操作被保存在 $P_1$ 的存储缓冲中。主内存中仍然是 $flag[1] = \\text{false}$。\n3.  $P_0$ 继续执行其忙等待检查：`while $(flag[1] \\land (turn = 1))$`。它执行对 $flag[1]$ 的加载操作。由于 $P_1$ 对 $flag[1]$ 的写操作仍在它的缓冲中，$P_0$ 从主内存中读取到的值是 $\\text{false}$。\n4.  $P_0$ 的条件变为 $(\\text{false} \\land (\\dots))$，这明确地为 $\\text{false}$。因此，$P_0$ 退出循环并进入临界区。\n5.  $P_1$ 继续执行其忙等待检查：`while $(flag[0] \\land (turn = 0))$`。它执行对 $flag[0]$ 的加载操作。由于 $P_0$ 对 $flag[0]$ 的写操作仍在它的缓冲中，$P_1$ 从主内存中读取到的值是 $\\text{false}$。\n6.  $P_1$ 的条件变为 $(\\text{false} \\land (\\dots))$，这明确地为 $\\text{false}$。因此，$P_1$ 也退出其循环并进入临界区。\n\n这个序列导致 $P_0$ 和 $P_1$ 同时处于临界区内，这明显违反了互斥性。在这种情况下，对 $turn$ 变量的操作是无关紧要的，因为逻辑与表达式的第一部分 ($flag[1-i]$) 足以使两个进程的整个条件都为假。这个场景在指定的弱内存模型下是可行的。\n\n现在，我们根据这一理解来评估每个提供的选项。\n\n**A. 利用了两个进程的存储缓冲的交错：**\n- **步骤 1：$P_0$：$flag[0] \\leftarrow \\text{true}$ (已缓冲)。** 可行。\n- **步骤 2：$P_1$：$flag[1] \\leftarrow \\text{true}$ (已缓冲)。** 可行。\n- **步骤 3 & 4：** 对 $turn$ 的写操作发生。我们假设它们变得可见，且 $P_1$ 的写操作是最后的，所以内存中的 $turn=0$。对 $flag$ 的写操作仍然处于缓冲状态。这是合理的，因为对不同地址的存储操作在可见性上可以被重排序。\n- **步骤 5：$P_0$：加载 $flag[1]$ 并读到 $\\text{false}$ (因为 $P_1$ 的 $flag[1]$ 仍在缓冲中)，将条件 $(flag[1] \\land (turn = 1))$ 评估为 $\\text{false}$，并进入临界区。** 这是正确的。$P_0$ 从内存中读取了 $flag[1]$ 的旧值，即 $\\text{false}$。布尔条件 $(\\text{false} \\land \\dots)$ 评估为 $\\text{false}$，$P_0$ 进入临界区。\n- **步骤 6：$P_1$：加载 $flag[0]$ 并读到 $\\text{false}$ (因为 $P_0$ 的 $flag[0]$ 仍在缓冲中)，将条件 $(flag[0] \\land (turn = 0))$ 评估为 $\\text{false}$，并进入临界区。** 这也是正确的。$P_1$ 读取了 $flag[0]$ 的旧值 $\\text{false}$。条件 $(\\text{false} \\land \\dots)$ 评估为 $\\text{false}$，$P_1$ 进入临界区。\n- **结果：$P_0$ 和 $P_1$ 同时处于临界区内。**\n这个选项准确地描述了一个在给定内存模型下可行且展示了互斥性违规的有效反例。\n**结论：正确。**\n\n**B. 因 `flag` 产生竞争但由 `turn` 解决的交错：**\n这个选项描述了一种所有写操作都立即变得可见的场景，这是顺序一致性系统的特征，而非指定的模型。它追踪了 Peterson 算法的一次正确执行，其中互斥性得到了维护：`flag` 表明竞争，而 `turn` 解决了竞争。由于问题要求的是一个 *违反* 互斥性的交错，所以这个选项是错误的。\n**结论：错误。**\n\n**C. 假设对同一观察者存在写-写重排序的交错：**\n- **步骤 3：$P_1$：加载 $flag[0]$ 为 `true` (即使 $P_0$ 的 $flag[0]$ 存储仍在缓冲中) ...** 这个陈述包含一个直接的矛盾。如果一个存储操作在 $P_0$ 中是“已缓冲”的，这意味着它对 $P_1$ 还不可见。因此，$P_1$ 不可能加载到值 `true`。它会从内存中加载旧值 (`false`)。这一步的前提在定义的内存模型下是不可能的。\n**结论：错误。**\n\n**D. 导致两个进程在进入循环中死锁的交错：**\n这个选项声称两个进程都可能永远卡在它们的忙等待循环中。让我们来分析一下。假设内存状态为 $flag[0] = \\text{true}$，$flag[1] = \\text{true}$，以及 (在两个进程都对其写入后) $turn = 0$。\n- $P_0$ 检查 $(flag[1] \\land (turn = 1))$。这是 $(\\text{true} \\land (0 = 1))$，结果为 $\\text{false}$。$P_0$ 进入临界区。\n- $P_1$ 检查 $(flag[0] \\land (turn = 0))$。这是 $(\\text{true} \\land (0 = 0))$，结果为 $\\text{true}$。$P_1$ 自旋等待。\n不存在死锁。`turn` 变量成功地仲裁了访问，确保了一个进程可以继续。此外，死锁违反的是 *进展* 属性，而问题明确要求的是违反 *互斥性*。\n**结论：错误。**\n\n只有选项 A 提供了一个在指定内存模型下可行的交错，并且正确地展示了对互斥属性的违反。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "手动推演并寻找导致并发错误的特定指令交错序列，不仅乏味，而且极易出错。一种更系统、更强大的方法是编写程序来自动化地探索并发执行的可能状态空间。这个编码练习  要求你亲手构建一个确定性的测试工具，通过生成随机调度来实证性地检验一个锁协议是否违反了互斥性。\n\n这个任务将抽象的理论概念——如“调度”（schedule）、“交错”（interleaving）和“反例”（counterexample）——转化为具体的代码实现。你将模拟多线程环境，重放执行序列，并检测临界区是否同时有多个线程进入。这不仅是一项编程挑战，更是一次将理论应用于实践的宝贵经历，让你掌握验证并发系统正确性的一项实用技能。",
            "id": "3687277",
            "problem": "您需要用 C 语言实现一个确定性测试工具，通过生成线程步骤的随机交错（调度）来经验性地检查一个简单共享锁协议的互斥属性，并在属性被违反时报告最小反例。该测试工具必须完全自包含，除了生成最终要求的单行输出外，不执行任何输入或输出，并且不得访问网络或文件系统。\n\n基本和核心定义：\n- 设有 $n$ 个并发线程，每个线程都试图执行一个临界区。互斥的正确性要求指出，在任何逻辑时间 $t$，临界区中的线程数最多为 $1$，即 $\\forall t,\\; c(t) \\le 1$，其中 $c(t)$ 表示在精确 $t$ 个离散交错步骤后临界区中的线程数。\n- 我们采用交错语义：一个全局执行被建模为一个有限调度 $\\sigma \\in \\{0,1,\\dots,n-1\\}^{L}$，其中 $L$ 是调度长度，$\\sigma[k]$ 表示被选中执行第 $(k+1)$ 步的线程。从初始状态执行调度 $\\sigma$ 会通过重复应用由每个线程在共享内存上的步进函数所引发的转换关系，从而产生一个全局状态序列。在模型中，语义在单个步进操作的粒度上是顺序一致的。\n- 我们将互斥的反例定义为一个调度的前缀 $\\pi$，当执行 $\\pi$ 时，存在第一个索引 $k$，使得 $c(k) \\ge 2$。最小反例是就长度而言最短的此类前缀。\n\n被测系统（需要建模的两个锁协议）：\n- 模型 $\\mathsf{BROKEN}$（非原子的检查后设置）：共享锁是一个整数 $\\ell \\in \\{0,1\\}$，初始为 $\\ell = 0$。每个线程 $i$ 使用一个私有寄存器 $r_i$ 执行以下步骤序列：\n  - 步骤 A：将 $\\ell$ 的值读入 $r_i$。\n  - 步骤 B：如果 $r_i = 0$ 则写入 $\\ell \\leftarrow 1$，否则跳到完成状态。\n  - 步骤 C：进入临界区（将 $c$ 增加 $1$）。\n  - 步骤 D：退出临界区（将 $c$ 减少 $1$ 并写入 $\\ell \\leftarrow 0$），然后完成。\n  已知该协议在交错语义下是不正确的，因为两个线程都可能在任一方写入之前读取到 $\\ell = 0$，从而导致两者都进入临界区。\n- 模型 $\\mathsf{ATOMIC}$（原子性的测试并设置）：用一个单一的原子步骤取代 A 和 B：如果 $\\ell = 0$ 则写入 $\\ell \\leftarrow 1$ 并进入临界区，否则跳到完成状态。步骤 C 和 D 相同。在交错语义下，该协议强制实现互斥。\n\n测试工具要求：\n- 随机调度生成：对于给定的参数元组 $(n, L_{\\max}, A, s, \\text{model})$，生成最多 $A$ 个候选调度，每个调度的长度最多为 $L_{\\max}$。生成方式为在每一步中，从尚未达到完成状态的线程集合中，均匀随机地选择一个可运行的线程索引 $i \\in \\{0,\\dots,n-1\\}$。使用一个以整数种子 $s$ 播种的伪随机数生成器来确保确定性。每个被选中的线程按照模型规定精确地前进一步协议步骤，并且该选择被记录在候选调度中。如果在达到长度 $L_{\\max}$ 之前所有线程都已完成，则提前停止。如果在生成过程中的第 $k$ 步检测到互斥违规，则立即停止该候选调度的生成，并将其长度为 $k$ 的前缀作为初始反例。\n- 违规检测：给定任意有限调度 $\\sigma$ 和模型，定义一个模拟过程，该过程从初始状态重放 $\\sigma$，在每个位置为所选线程应用至多一个步骤，并在第 $k$ 步后临界区中的线程数超过 $1$ 时，返回第一个违规的索引 $k \\in \\{1,\\dots,|\\sigma|\\}$；如果在 $\\sigma$ 内未发生违规，则返回 $0$。如果一个索引指向一个已经处于完成状态的线程，则该步骤为无操作。\n- 通过删除法进行最小反例缩减：对于任何违规的调度 $\\sigma$，执行迭代删除：尝试从 $\\sigma$ 中移除单个位置（一次一个，从左到右扫描），然后重新模拟；如果缩短后的调度仍然发生违规（可能在更早的索引处），则保留该删除并从同一索引继续扫描；否则，撤销该特定删除并前进到下一个位置。重复此过程直到达到一个不动点。结果必须是相对于单元素删除而言是最小的反例。\n- 跨尝试的聚合：对于每个参数元组，在 $A$ 个生成的候选调度中进行搜索，将每个违规的候选调度缩减为最小反例，并保留找到的最短长度（任意打破平局）。如果在所有 $A$ 次尝试中都未找到违规，则报告该参数元组的结果为 $0$。\n\n测试套件和要求的输出：\n为以下四个参数集提供结果，每个参数集指定为 $(n, \\text{model}, L_{\\max}, A, s)$：\n- 测试 $1$：$(n=\\;2,\\; \\text{model}=\\;\\mathsf{BROKEN},\\; L_{\\max}=\\;20,\\; A=\\;500,\\; s=\\;1)$。对于此情况，存在一个长度为 $6$ 的最小反例，因为两个线程各需要精确的三步（读取、写入、进入）才能达到违规状态，即第二个线程在第一个线程位于临界区内时进入。\n- 测试 $2$：$(n=\\;2,\\; \\text{model}=\\;\\mathsf{ATOMIC},\\; L_{\\max}=\\;20,\\; A=\\;500,\\; s=\\;2)$。不存在反例；正确的协议强制实现互斥。\n- 测试 $3$：$(n=\\;3,\\; \\text{model}=\\;\\mathsf{BROKEN},\\; L_{\\max}=\\;5,\\; A=\\;1000,\\; s=\\;3)$。不存在长度最多为 $5$ 的反例，因为最短的违规至少需要 $6$ 步。\n- 测试 $4$：$(n=\\;1,\\; \\text{model}=\\;\\mathsf{BROKEN},\\; L_{\\max}=\\;10,\\; A=\\;200,\\; s=\\;4)$。根据定义，单个线程不存在反例。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含四个测试的结果，形式为一个用方括号括起来的逗号分隔的整数列表，没有空格也没有其他文本。例如，一个有效的形式是 $[x,y,z,w]$。对于本问题，程序必须精确地按照上述测试的顺序打印最小反例长度的列表，对于在指定的尝试次数和长度限制内未找到违规的任何测试，使用 $0$。",
            "solution": "设计一个确定性测试工具来经验性地检查互斥违规的问题是有效的。它在科学上基于并发编程和操作系统理论中公认的原理，特别是临界区问题。该问题定义明确，为系统模型（$\\mathsf{BROKEN}$ 和 $\\mathsf{ATOMIC}$ 协议）、执行语义（交错）、正确性属性（互斥）以及所需的测试算法程序（随机调度生成、违规模拟和反例缩减）提供了一套完整且一致的定义。测试套件的参数和预期结果都已明确指定且计算上可行。整个问题是可形式化和客观的，不依赖于主观论断或不可验证的前提。\n\n解决方案涉及实现一个单线程 C 程序，该程序根据给定的调度模拟 $n$ 个线程的并发执行。该测试工具将随机生成调度、检查违规，并对任何发现的反例应用确定性缩减算法。最终的实现将是自包含的，并通过为指定的测试套件编排这些组件来产生所需的输出。\n\n该设计基于以下原则和数据结构：\n\n**1. 系统状态表示**\n为了模拟系统，我们必须对共享的全局状态和每个线程的私有状态进行建模。\n\n-   **模型枚举**：定义了一个枚举 `Model`，以区分被测试的两种协议：$\\mathsf{BROKEN}$ 和 $\\mathsf{ATOMIC}$。\n-   **线程私有状态 (`ThreadState`)**：一个结构体 `ThreadState` 存储单个线程 $i$ 的状态。它包含：\n    -   `int pc`：一个程序计数器，用于跟踪线程在锁定协议中的当前步骤（例如，步骤 A、B、C 或 D）。\n    -   `int r`：在 $\\mathsf{BROKEN}$ 模型中使用的私有寄存器 $r_i$，用于存储最后读取的锁的值。\n    -   `bool done`：一个标志，指示线程是否已完成其执行并进入“完成”状态。\n-   **全局共享状态 (`GlobalState`)**：一个结构体 `GlobalState` 封装了整个系统的状态。它包含：\n    -   `int lock`：共享锁变量 $\\ell$，可以是 $0$（未锁定）或 $1$（已锁定）。它被初始化为 $0$。\n    -   `int cs_count`：一个计数器 $c(t)$，用于记录当前在临界区中的线程数。如果 $c(t) > 1$，则发生违规。\n    -   `ThreadState* threads`：一个大小为 $n$ 的动态分配数组，用于保存所有线程的状态。\n\n**2. 模拟引擎**\n测试工具的核心是模拟给定调度 $\\sigma$ 的执行能力。这由两个函数处理。\n\n-   **`step_thread(GlobalState* state, int thread_id, Model model)`**：此函数根据指定的 `thread_id` 的当前 `pc` 和指定的 `model` 将其向前推进一个步骤。它实现了问题中定义的状态转换规则。例如，在 $\\mathsf{BROKEN}$ 模型中，如果一个线程的 `pc` 对应于步骤 A，此函数将执行 `state->threads[thread_id].r = state->lock;` 并递增 `pc`。如果一个线程被标记为 `done`，则此函数按要求执行无操作。\n-   **`simulate(const int* schedule, int len, int n, Model model)`**：此函数模拟一个完整的调度。它首先初始化一个 `GlobalState`。然后，它从索引 $k=0$ 到 $k=len-1$ 遍历 `schedule` 数组。在每次迭代中，它为 `schedule[k]` 指定的线程调用 `step_thread`。每一步之后，它检查 `state->cs_count > 1` 是否成立。如果成立，则发生了互斥违规，函数立即返回从 1 开始的步骤索引 $k+1$。如果整个调度执行完毕而计数器未超过 $1$，则返回 $0$。\n\n**3. 随机调度生成与即时检查**\n测试工具必须生成随机调度来探测状态空间以寻找错误。\n\n-   **`generate_and_check(int n, Model model, int l_max, unsigned int seed, int* out_schedule)`**：此函数使用整数 $s$ 播种，生成一个长度最多为 $L_{\\max}$ 的随机调度。在生成的每一步中，它识别出*可运行*线程（那些不处于 `done` 状态的线程）的集合。然后，它使用 `rand()` 函数从这个集合中均匀随机地选择一个线程。所选线程的索引被附加到调度中，并使用 `step_thread` 将其状态向前推进一个步骤。关键的是，在模拟每一步之后，函数都会检查是否存在互斥违规。如果在第 $k$ 步发现违规，生成将立即停止，长度为 $k$ 的违规前缀存储在 `out_schedule` 中，并返回其长度 $k$。如果没有发生违规并且所有线程都变为 `done`，或者调度达到长度 $L_{\\max}$，则函数返回 $0$。\n\n**4. 反例缩减**\n仅仅找到一个违规的调度是不够的；问题要求找到一个*最小*的。指定的缩减算法是迭代删除。\n\n-   **`reduce_counterexample(int** schedule_ptr, int* len_ptr, int n, Model model)`**：此函数接受一个违规的调度并尝试缩短它。它实现了一个贪婪的不动点算法。它从左到右重复扫描调度（索引 $i=0, 1, \\dots$）。在每个位置 $i$，它创建一个移除了第 $i$ 个元素的临时调度。然后，它对此缩短的调度调用 `simulate`。如果违规仍然存在（`simulate` 返回一个非零值），则该删除被永久化：原始调度被较短的调度替换，并且缩减过程从现在已修改的调度上的同一索引 $i$ 继续。如果删除消除了违规，则更改被丢弃，扫描继续到下一个索引 $i+1$。整个过程重复进行，直到对调度的完整遍历没有产生任何成功的删除，此时已达到不动点，并且该调度相对于单元素删除是最小的。\n\n**5. 编排与测试执行**\n`main` 函数为给定的测试套件编排整个过程。\n\n-   它定义了一个 `TestCase` 结构体数组，每个结构体持有一个参数元组 $(n, \\text{model}, L_{\\max}, A, s)$。\n-   它遍历每个测试用例。对于给定的测试用例，它用 $s$ 为伪随机数生成器播种。\n-   它运行一个循环进行 $A$ 次尝试。在每次尝试中，它调用 `generate_and_check`。如果发现违规，生成的调度将被传递给 `reduce_counterexample`。然后将缩减后的调度长度与此测试用例迄今为止找到的最短长度进行比较，并保留最小值。\n-   如果在所有 $A$ 次尝试中都未发现违guī，则该测试用例的结果为 $0$。\n-   最后，程序以指定格式打印所有测试用例的结果：`[result1,result2,result3,result4]`。\n\n这种设计以结构化且可验证的方式系统地实现了问题陈述的所有要求。",
            "answer": "$$\\boxed{[6,0,0,0]}$$"
        }
    ]
}