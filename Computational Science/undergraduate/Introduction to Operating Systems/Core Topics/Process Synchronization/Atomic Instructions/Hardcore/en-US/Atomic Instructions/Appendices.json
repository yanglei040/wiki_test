{
    "hands_on_practices": [
        {
            "introduction": "At the heart of concurrent programming is the need for indivisible operations. But what happens when the data you need to update atomically is larger than the native word size of your processor's atomic instructions? This exercise challenges you to explore a common but flawed approach: emulating a large atomic operation using a sequence of smaller ones. By analyzing a specific interleaving, you will discover the critical concept of linearizability and see firsthand why such simple compositions fail, leading to corrupted data states known as \"torn writes\" .",
            "id": "3621937",
            "problem": "An operating system can rely on processor-provided atomic instructions to implement concurrency primitives. Consider the definition of an atomic Compare-And-Swap (CAS): CAS takes a memory location $M$, an expected value $E$, and a desired value $N$, and performs, as one indivisible operation, the check-and-set, leaving $M$ equal to $N$ and returning a success flag only if $M$ was equal to $E$ at the instant of the operation. In contrast, any sequence of multiple instructions has a window in which interleavings can occur. Assume a sequentially consistent memory model, where every individual instruction (including each $64$-bit CAS) is atomic with respect to other instructions, but there is no mechanism to compose multiple instructions into a single atomic step.\n\nSuppose we have a $128$-bit shared object $X$ implemented as two adjacent $64$-bit words: $X_{hi}$ and $X_{lo}$. The goal is to emulate a $128$-bit CAS on $X$ using two $64$-bit CAS operations. Two threads, $T_1$ and $T_2$, simultaneously attempt to update $X$ from the same expected value\n$$\nX = (X_{hi}, X_{lo}) = (A, B),\n$$\nto different new values:\n$$\nT_1 \\text{ wants } (A, B) \\rightarrow (C, D), \\quad T_2 \\text{ wants } (A, B) \\rightarrow (E, F).\n$$\nEach thread uses the same emulation algorithm: it first performs a $64$-bit CAS on $X_{hi}$ with expected $A$ and desired $C$ (for $T_1$) or $E$ (for $T_2$), and then performs a $64$-bit CAS on $X_{lo}$ with expected $B$ and desired $D$ (for $T_1$) or $F$ (for $T_2$). If any CAS fails, the thread immediately returns failure; there is no rollback or locking.\n\nAtomicity for the intended $128$-bit CAS requires linearizability: each attempted update must appear to occur at a single instant, such that at most one of $T_1$ or $T_2$ succeeds, and the final state of $X$ must be either $(C, D)$, $(E, F)$, or remain $(A, B)$ if both fail, with no intermediate or “torn” combinations visible or committed.\n\nWhich of the following interleavings of the two $64$-bit CAS operations is a valid counterexample showing that the two-step emulation is not equivalent to a truly atomic $128$-bit CAS?\n\nA. $T_1$ performs CAS on $X_{hi}$ with expected $A$ and desired $C$ and succeeds; $T_1$ performs CAS on $X_{lo}$ with expected $B$ and desired $D$ and succeeds; $T_2$ subsequently attempts CAS on $X_{hi}$ with expected $A$ and fails, then returns failure. Final $X$ is $(C, D)$.\n\nB. $T_1$ performs CAS on $X_{hi}$ with expected $A$ and desired $C$ and succeeds; $T_2$ performs CAS on $X_{lo}$ with expected $B$ and desired $F$ and succeeds; $T_1$ then performs CAS on $X_{lo}$ with expected $B$ and desired $D$ and fails; $T_2$ then performs CAS on $X_{hi}$ with expected $A$ and desired $E$ and fails. Final $X$ is $(C, F)$.\n\nC. $T_1$ performs CAS on $X_{hi}$ with expected $A$ and desired $C$ and succeeds; $T_2$ immediately attempts CAS on $X_{hi}$ with expected $A$ and desired $E$ and fails; $T_1$ performs CAS on $X_{lo}$ with expected $B$ and desired $D$ and succeeds. Final $X$ is $(C, D)$.\n\nD. $T_2$ runs to completion before $T_1$ starts: $T_2$ performs CAS on $X_{hi}$ with expected $A$ and desired $E$ and succeeds; $T_2$ performs CAS on $X_{lo}$ with expected $B$ and desired $F$ and succeeds; $T_1$ subsequently attempts CAS on $X_{hi}$ with expected $A$ and fails, then returns failure. Final $X$ is $(E, F)$.\n\nSelect all correct options.",
            "solution": "The user has requested a critical validation of the provided problem statement, followed by a complete solution and evaluation of the given options.\n\n### Problem Validation\n\nI will first validate the problem statement according to the specified criteria.\n\n#### Step 1: Extract Givens\n\nThe problem provides the following information:\n*   An atomic instruction, Compare-And-Swap (CAS), is defined as: `CAS(M, E, N)` atomically checks if the value at memory location $M$ is equal to an expected value $E$. If it is, $M$ is updated to a new value $N$, and a success flag is returned. Otherwise, the operation fails.\n*   The memory model is sequentially consistent. Individual instructions, including a $64$-bit CAS, are atomic.\n*   There is no hardware support for composing multiple instructions into a single atomic operation.\n*   A shared $128$-bit object $X$ is composed of two adjacent $64$-bit words, $X_{hi}$ and $X_{lo}$.\n*   The initial state of the shared object is $X = (X_{hi}, X_{lo}) = (A, B)$.\n*   Two threads, $T_1$ and $T_2$, simultaneously attempt to update $X$ from $(A, B)$ to different new values.\n    *   $T_1$ intends to perform the update $(A, B) \\rightarrow (C, D)$.\n    *   $T_2$ intends to perform the update $(A, B) \\rightarrow (E, F)$.\n*   The emulation algorithm for a $128$-bit CAS, used by both threads, is a two-step sequence:\n    1.  Perform a $64$-bit CAS on $X_{hi}$.\n    2.  Perform a $64$-bit CAS on $X_{lo}$.\n*   The specific sequence for $T_1$ is:\n    1.  `CAS(&X_{hi}, A, C)`\n    2.  `CAS(&X_{lo}, B, D)`\n*   The specific sequence for $T_2$ is:\n    1.  `CAS(&X_{hi}, A, E)`\n    2.  `CAS(&X_{lo}, B, F)`\n*   Failure condition: If any CAS in the sequence fails, the thread immediately returns failure. There is no rollback mechanism.\n*   Atomicity requirement (Linearizability): A successful emulation must appear to occur at a single instant. This implies two conditions:\n    1.  At most one thread ($T_1$ or $T_2$) can succeed.\n    2.  The final state of $X$ must be one of three possibilities: $(C, D)$ if $T_1$ succeeds, $(E, F)$ if $T_2$ succeeds, or $(A, B)$ if both fail. Any other final state, such as a \"torn\" or mixed combination, is a violation of atomicity.\n*   The question asks to identify an interleaving from the options that serves as a counterexample to the atomicity of this emulation algorithm.\n\n#### Step 2: Validate Using Extracted Givens\n\n*   **Scientifically Grounded:** The problem is firmly based on fundamental concepts in concurrent programming and operating systems, specifically the challenge of implementing multi-word atomic operations using single-word atomic primitives. The Compare-And-Swap instruction and the concept of linearizability are standard and well-defined in computer science.\n*   **Well-Posed:** The problem is well-posed. The initial state, the process for each thread, the conditions for success and failure, and the definition of a correct outcome (linearizability) are all explicitly stated. The question asks for a specific counterexample, which is a logically sound and solvable task.\n*   **Objective:** The problem is stated in precise, objective, and formal language. There is no ambiguity or subjectivity.\n\nThe problem statement does not violate any of the invalidity criteria. It is a standard, sound, and well-defined problem in its domain.\n\n#### Step 3: Verdict and Action\n\nThe problem statement is **valid**. I will now proceed to solve it by analyzing the provided options.\n\n### Solution Derivation\n\nThe goal is to find a counterexample demonstrating that the two-step $64$-bit CAS procedure is not atomic for a $128$-bit value. A counterexample is an execution trace (an interleaving of instructions from $T_1$ and $T_2$) that violates the specified linearizability condition. The most direct violation would be an execution where the final state of $X$ is neither the initial state $(A, B)$, nor $T_1$'s target state $(C, D)$, nor $T_2$'s target state $(E, F)$. Such a state is often called a \"torn write\".\n\nThe initial state is $X = (X_{hi}, X_{lo}) = (A, B)$.\n\n#### Option-by-Option Analysis\n\n**A. $T_1$ performs CAS on $X_{hi}$ with expected $A$ and desired $C$ and succeeds; $T_1$ performs CAS on $X_{lo}$ with expected $B$ and desired $D$ and succeeds; $T_2$ subsequently attempts CAS on $X_{hi}$ with expected $A$ and fails, then returns failure. Final $X$ is $(C, D)$.**\n\n1.  Initial state: $X = (A, B)$.\n2.  $T_1$ executes `CAS(&X_{hi}, A, C)`. This succeeds, as $X_{hi}$ is $A$. The state becomes $X = (C, B)$.\n3.  $T_1$ executes `CAS(&X_{lo}, B, D)`. This succeeds, as $X_{lo}$ is $B$. The state becomes $X = (C, D)$. $T_1$ reports success.\n4.  $T_2$ executes `CAS(&X_{hi}, A, E)`. This fails, as $X_{hi}$ is now $C$, not the expected value $A$. $T_2$ reports failure.\n5.  Final State: $X = (C, D)$.\nThis execution is linearizable. It appears as if the $128$-bit operation of $T_1$ completed successfully before $T_2$ began its attempt. The final state $(C, D)$ is one of the valid outcomes. Therefore, this trace does not constitute a counterexample.\n\n**Verdict for A: Incorrect.**\n\n**B. $T_1$ performs CAS on $X_{hi}$ with expected $A$ and desired $C$ and succeeds; $T_2$ performs CAS on $X_{lo}$ with expected $B$ and desired $F$ and succeeds; $T_1$ then performs CAS on $X_{lo}$ with expected $B$ and desired $D$ and fails; $T_2$ then performs CAS on $X_{hi}$ with expected $A$ and desired $E$ and fails. Final $X$ is $(C, F)$.**\n\n1.  Initial state: $X = (A, B)$.\n2.  $T_1$ executes `CAS(&X_{hi}, A, C)`. This succeeds. The state becomes $X = (C, B)$.\n3.  An interleaving occurs. $T_2$ executes `CAS(&X_{lo}, B, F)`. This succeeds, as $X_{lo}$ is still $B$. The state becomes $X = (C, F)$.\n4.  $T_1$ resumes and executes its second step, `CAS(&X_{lo}, B, D)`. This fails, because $X_{lo}$ is now $F$, not the expected value $B$. $T_1$ reports failure.\n5.  $T_2$ resumes and executes its second step (its first step was interleaved), `CAS(&X_{hi}, A, E)`. This fails, because $X_{hi}$ is $C$ (changed by $T_1$), not the expected value $A$. $T_2$ reports failure.\n6.  Final State: $X = (C, F)$.\nIn this scenario, both threads report failure. According to the problem's atomicity requirement, if both threads fail, the state must remain the initial state, $(A, B)$. However, the final state is $(C, F)$, which is a \"torn\" state composed of a partial update from $T_1$ ($C$ for $X_{hi}$) and a partial update from $T_2$ ($F$ for $X_{lo}$). This state is not $(A, B)$, $(C, D)$, or $(E, F)$. This trace is a direct violation of the linearizability condition.\n\n**Verdict for B: Correct.**\n\n**C. $T_1$ performs CAS on $X_{hi}$ with expected $A$ and desired $C$ and succeeds; $T_2$ immediately attempts CAS on $X_{hi}$ with expected $A$ and desired $E$ and fails; $T_1$ performs CAS on $X_{lo}$ with expected $B$ and desired $D$ and succeeds. Final $X$ is $(C, D)$.**\n\n1.  Initial state: $X = (A, B)$.\n2.  $T_1$ executes `CAS(&X_{hi}, A, C)`. This succeeds. State becomes $X = (C, B)$.\n3.  $T_2$ executes `CAS(&X_{hi}, A, E)`. This fails, as $X_{hi}$ is $C$, not $A$. $T_2$ reports failure.\n4.  $T_1$ executes `CAS(&X_{lo}, B, D)`. This succeeds, as $X_{lo}$ is $B$. State becomes $X = (C, D)$. $T_1$ reports success.\n5.  Final State: $X = (C, D)$.\nThis execution is linearizable. $T_1$ successfully completes its operation, while $T_2$'s attempt is preempted and fails. The final state is a valid outcome. This is not a counterexample.\n\n**Verdict for C: Incorrect.**\n\n**D. $T_2$ runs to completion before $T_1$ starts: $T_2$ performs CAS on $X_{hi}$ with expected $A$ and desired $E$ and succeeds; $T_2$ performs CAS on $X_{lo}$ with expected $B$ and desired $F$ and succeeds; $T_1$ subsequently attempts CAS on $X_{hi}$ with expected $A$ and fails, then returns failure. Final $X$ is $(E, F)$.**\n\n1.  Initial state: $X = (A, B)$.\n2.  $T_2$ executes `CAS(&X_{hi}, A, E)`. This succeeds. State becomes $X = (E, B)$.\n3.  $T_2$ executes `CAS(&X_{lo}, B, F)`. This succeeds. State becomes $X = (E, F)$. $T_2$ reports success.\n4.  $T_1$ executes `CAS(&X_{hi}, A, C)`. This fails, as $X_{hi}$ is $E$, not $A$. $T_1$ reports failure.\n5.  Final State: $X = (E, F)$.\nThis is another linearizable execution, symmetric to option A. $T_2$ completes its operation atomically, and $T_1$'s subsequent attempt fails. The final state is a valid outcome. This is not a counterexample.\n\n**Verdict for D: Incorrect.**\n\nBased on the analysis, only the interleaving described in option B leads to a state that violates the correctness condition for an atomic $128$-bit CAS.",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "Even with a powerful atomic primitive like compare-and-swap (CAS), building correct lock-free data structures is fraught with subtle hazards. This practice introduces the infamous ABA problem, a scenario where a CAS can erroneously succeed because a shared memory location has been modified and then changed back to its original value, hiding a series of intermediate operations. Through this exercise, you will not only demonstrate how the ABA anomaly can corrupt a lock-free stack but also derive the fundamental technique used to prevent it: versioning with tag bits .",
            "id": "3621915",
            "problem": "A lock-free Last-In-First-Out (LIFO) free list is implemented as a singly linked stack whose head is updated using the atomic compare-and-swap (CAS) instruction. Compare-and-swap (CAS) takes three arguments, an address, an expected value, and a new value; it atomically compares the current contents at the address with the expected value and, only if they are bitwise equal, writes the new value, returning whether it succeeded. In the basic design, the head is a single-word pointer to the top node. Consider two threads, each performing either a push or pop, with all updates linearized at the successful CAS.\n\nPart A. Illustrate how the classic ABA anomaly can occur in this free list without any tag or versioning, by specifying a plausible interleaving where one thread reads the head pointer as a node labeled $A$, another thread pops $A$, performs some sequence of pushes and pops, and eventually restores the head pointer to $A$, causing a stale CAS by the first thread to succeed even though the logical stack has changed.\n\nTo mitigate ABA, the head is augmented to be a pair $\\left(p, t\\right)$ packed into a single machine word, where $p$ is the pointer and $t$ is a $b$-bit tag. On every successful head update, the implementation increments $t$ by $1$ modulo $2^{b}$ and writes the new pair using a single CAS on the packed word. A CAS by any thread compares both $p$ and $t$ to the stale pair it previously read.\n\nPart B. Suppose that, for any thread between the moment it reads $\\left(p, t\\right)$ and the moment it executes its CAS, there can be at most $n$ successful head updates by all threads combined. Derive, from first principles, the minimal tag width $b$ as a function of $n$ that guarantees that no stale pair $\\left(p, t\\right)$ can match the current head pair again within that window, even if the pointer $p$ is reused, so that a stale CAS cannot succeed due to tag wraparound. Express your final answer as a single closed-form analytic expression in terms of $n$. Do not assume any particular data word size, and treat $n$ as an arbitrary positive integer. The final answer must be an expression without units.",
            "solution": "We begin from the operational definition of compare-and-swap (CAS): CAS on an address atomically compares the current value with an expected value and writes a new value if and only if they are bitwise equal. In a lock-free free list implemented as a stack, both push and pop operations update the head pointer using CAS. Linearizability requires that the logical effect of an operation occurs at the moment its CAS succeeds.\n\nPart A requires demonstrating the ABA anomaly. Consider the head initially pointing to node labeled $A$. A typical interleaving is:\n- Thread $T_{1}$ reads the head pointer and observes $A$. It computes a new head based on this observation but is delayed before performing its CAS.\n- Thread $T_{2}$ pops $A$ from the stack. The head now points to some other node, say $B$, or becomes $\\text{null}$ if the stack was of size $1$.\n- Thread $T_{2}$ proceeds to push and pop additional nodes in some sequence. In particular, it may push $A$ back onto the top of the stack, restoring the head pointer to $A$.\n- Thread $T_{1}$ resumes and performs its CAS, which compares only the pointer value. Because the head pointer is again $A$, the CAS sees the expected pointer and succeeds, even though the logical contents of the stack between $T_{1}$’s read and CAS changed arbitrarily. This is the ABA anomaly: the observed value went from $A$ to some $X$ and back to $A$, masking intervening changes.\n\nPart B augments the head with a version tag to distinguish different incarnations of the same pointer value. The head is the pair $\\left(p, t\\right)$, where $t$ is a $b$-bit counter that is incremented by $1$ modulo $2^{b}$ on each successful head update. A CAS by a thread now compares both $p$ and $t$ to its previously read pair. The goal is to choose $b$ so that, within any window in which a thread may attempt a CAS after reading $\\left(p, t\\right)$, there has not been sufficient wraparound to return the tag to the same value for the same pointer, even if the pointer $p$ is reused.\n\nWe formalize the requirement: let a thread read the head as $\\left(p_{0}, t_{0}\\right)$ at time $\\tau$. Between $\\tau$ and the thread’s CAS at time $\\tau'$, suppose there are $k$ successful head updates by any threads, where $k$ satisfies $1 \\leq k \\leq n$. Each successful update increments the tag by $1$ modulo $2^{b}$. Therefore, at time $\\tau'$, the current tag value associated with the head is\n$$\nt' \\equiv t_{0} + k \\pmod{2^{b}}.\n$$\nTo prevent a stale CAS from succeeding due to tag wraparound, we must ensure that no $k$ in the range $1 \\leq k \\leq n$ yields $t' = t_{0}$ modulo $2^{b}$. That is, we require\n$$\n\\forall k \\in \\{1, 2, \\dots, n\\}, \\quad k \\not\\equiv 0 \\pmod{2^{b}}.\n$$\nEquivalently, we require that the modulus $2^{b}$ exceeds the maximum possible number of increments in the window, so that no multiple of $2^{b}$ lies in $\\{1, \\dots, n\\}$. This condition is\n$$\n2^{b} > n.\n$$\nThe minimal integer $b$ satisfying this strict inequality is obtained by taking the base-$2$ logarithm and using the ceiling function: $b = \\left\\lceil \\log_{2}\\!\\left(n+1\\right) \\right\\rceil.$\nTo verify minimality, suppose $b' = \\left\\lceil \\log_{2}\\!\\left(n+1\\right) \\right\\rceil - 1$. Then $2^{b'} \\leq n$, so there exists some $k = 2^{b'}$ with $1 \\leq k \\leq n$ and $k \\equiv 0 \\pmod{2^{b'}}$, implying possible wraparound to the same tag. Therefore any smaller $b$ fails to guarantee non-reuse within the window. Thus the derived expression is both necessary and sufficient.\n\nThis derivation relies only on the definition of CAS atomicity, the increment-by-one update rule for the tag on each successful head change, and basic modular arithmetic. It ensures that, even if the pointer $p$ reappears (for example, due to memory reuse), the tag component will differ within any window of at most $n$ updates, preventing a stale CAS from succeeding on an identical $\\left(p, t\\right)$ pair.",
            "answer": "$$\\boxed{\\left\\lceil \\log_{2}\\!\\left(n+1\\right) \\right\\rceil}$$"
        },
        {
            "introduction": "Moving from theory to practice, this exercise asks you to implement a concurrent bitmap allocator, a common component in operating systems for managing resources. You will use C atomic operations to safely manipulate shared data without locks, directly applying the principles of atomicity to solve a real-world problem. Furthermore, this practice guides you to measure and analyze the effects of memory contention, and to implement a hashing strategy to distribute memory access and improve scalability .",
            "id": "3621176",
            "problem": "You are to design and analyze a concurrent bitmap allocator that uses atomic instructions to manipulate individual bits. The allocator maintains a shared bit-vector of length $N$ where each bit represents an allocatable slot: a bit value of $0$ denotes a free slot and a bit value of $1$ denotes an allocated slot. Multiple threads attempt to allocate slots by setting bits concurrently.\n\nFundamental base and definitions to use:\n- Atomic read-modify-write operations are linearizable under the C standard memory model. An atomic operation appears to take effect instantaneously at some point between its invocation and its return, producing a total order consistent with program order. This is a well-tested and widely accepted fact in computer organization and architecture.\n- A bitmap allocator uses bitwise operations to mark allocation. A correct atomic bit-test-and-set must guarantee that exactly one allocator observes the transition from $0$ to $1$ for a particular bit; all other concurrent attempts on that bit observe $1$ and register failure. This captures the essence of Test-and-Set and Compare-and-Swap semantics for slot acquisition.\n- Load-Linked/Store-Conditional (LL/SC) provides an equivalent mechanism for atomic update: a thread loads a value and then conditionally stores a new value only if no intervening stores have occurred. While LL/SC is not directly used in the program, its semantics justify the correctness of an atomic fetch-and-set approach.\n\nAllocation attempt model:\n- There are $T$ threads indexed by $i \\in \\{0,1,\\dots,T-1\\}$.\n- Each thread performs $M$ allocation attempts.\n- To reduce contention, each thread uses a hash-seeded probe sequence. Define a per-thread hash function\n$$ h(i) = (a \\cdot i + b) \\pmod{N} $$\nwith integer parameters $a$ and $b$. The $j$-th attempt by thread $i$ targets index\n$$ \\text{idx}(i,j) = (h(i) + j \\cdot s) \\pmod{N} $$\nwhere $s$ is a stride. Choosing $s$ co-prime with $N$ maximizes coverage of indices before repeating, but the program will accept any provided $s$.\n\nAtomic bit-test-and-set specification:\n- For a target bit at index $k$, the allocator issues an atomic read-modify-write that sets the bit and returns the prior word value containing $k$. If the prior value had bit $k$ equal to $0$, the attempt is counted as a success; if bit $k$ was $1$, the attempt is counted as a failure. This models Test-and-Set semantics at the bit granularity.\n\nCollision definition and metric:\n- A collision is defined as any failed attempt where the target bit is already $1$. The collision rate is\n$$ c = \\frac{F}{T \\cdot M} $$\nwhere $F$ is the total number of failed attempts aggregated across all threads.\n\nYour task:\n- Implement the concurrent bitmap allocator with an atomic bit-test-and-set using the C language atomic facilities. Use a single shared bitmap across threads per test case. Each thread computes its probe sequence according to $h(i)$ and $\\text{idx}(i,j)$ and attempts to set the corresponding bit atomically.\n- Measure the collision rate $c$ after all threads complete their $M$ attempts.\n\nTest suite:\nProvide results for the following parameter sets, each treated as an independent run with a fresh bitmap initialized to all zeros:\n1. Case A (hashed, happy path): $N=1024$, $T=8$, $M=64$, $s=3$, $a=17$, $b=5$.\n2. Case B (baseline, no hashing): $N=1024$, $T=8$, $M=64$, $s=3$, $a=0$, $b=0$.\n3. Case C (boundary, non-word-aligned $N$): $N=1000$, $T=16$, $M=120$, $s=7$, $a=19$, $b=11$.\n4. Case D (edge, high contention and repetition): $N=64$, $T=32$, $M=128$, $s=1$, $a=0$, $b=0$.\n\nFinal output format:\n- Your program should produce a single line of output containing the collision rates for the four cases as a comma-separated list enclosed in square brackets, for example, [$c_A,c_B,c_C,c_D$].\n\nScientific realism and constraints:\n- Use only atomic operations for bit setting; no locks are allowed for allocating individual bits.\n- Ensure that the allocator is correct under concurrent access by relying on the linearizability of atomic read-modify-write operations.\n- The code must be self-contained, require no input, and run deterministically given the specified parameters.\n\nAnswer type:\n- For each test case, output a single floating-point number $c$ rounded to six decimal places. Aggregate all four results into a single bracketed list on one line as specified.",
            "solution": "The problem statement has been analyzed and found to be valid. It is scientifically grounded in the principles of concurrent programming and computer architecture, well-posed with a complete and consistent set of definitions and parameters, and objective in its formulation. The task is to implement a simulation of a concurrent bitmap allocator and measure its performance under specified conditions, which is a standard and verifiable problem in computer science.\n\nWe now proceed with the design and solution.\n\nThe core of the problem is to simulate a concurrent bitmap allocator and quantify the contention among threads, measured by a collision rate. The allocator manages a bit-vector of length $N$, where a bit at index $k$ being $0$ signifies a free slot and $1$ signifies an allocated slot. $T$ threads concurrently perform $M$ allocation attempts each, for a total of $T \\cdot M$ attempts.\n\nFirst, we must represent the bitmap in memory. Since C11/C23 atomic operations are defined for integer types, not individual bits, we must model the bit-vector as an array of atomic unsigned integers. A common and efficient choice is `_Atomic unsigned long`. Let us denote the number of bits in an `unsigned long` as $B_{\\text{word}}$. This value is system-dependent and can be obtained by a constant expression such as `sizeof(unsigned long) * CHAR_BIT`. The total number of `unsigned long` elements required to represent $N$ bits is $\\lceil N / B_{\\text{word}} \\rceil$, which can be computed using integer arithmetic as $(N + B_{\\text{word}} - 1) / B_{\\text{word}}$. Let this array be denoted `bitmap`. The bitmap is initialized to all zeros, representing an initially empty set of slots.\n\nEach of the $T$ threads, indexed by $i \\in \\{0, 1, \\dots, T-1\\}$, executes a sequence of $M$ allocation attempts, indexed by $j \\in \\{0, 1, \\dots, M-1\\}$. The target bit index for thread $i$ on its $j$-th attempt is determined by a linear probing sequence seeded by a per-thread hash function. The hash is given by:\n$$ h(i) = (a \\cdot i + b) \\pmod{N} $$\nThe target index for the $j$-th attempt is then:\n$$ \\text{idx}(i,j) = (h(i) + j \\cdot s) \\pmod{N} $$\nHere, $a$, $b$, and $s$ are integer parameters defining the access pattern.\n\nThe critical operation is the atomic bit-test-and-set. For a target bit index $k = \\text{idx}(i,j)$, we must perform an atomic read-modify-write operation on the word in the `bitmap` array that contains this bit. The index of the word within the `bitmap` array is $k_{\\text{word}} = \\lfloor k / B_{\\text{word}} \\rfloor$, and the index of the bit within that word is $k_{\\text{bit}} = k \\pmod{B_{\\text{word}}}$.\n\nTo set the bit, we create a bitmask, `m = 1UL  k_bit`. The atomic operation is then performed using the C `stdatomic.h` intrinsic `atomic_fetch_or`. The call `atomic_fetch_or(bitmap[k_{\\text{word}}], m)` atomically performs a bitwise OR of the word at `bitmap[k_{\\text{word}}]` with the mask $m$ and returns the value of the word *before* the modification. Let this prior value be $v_{\\text{old}}$.\n\nAccording to the problem definition, an allocation attempt is a success if the target bit was previously $0$. This condition can be checked by testing the corresponding bit in the returned value $v_{\\text{old}}$. If `(v_old  m) == 0`, the bit was $0$, and the allocation is a success. If `(v_old  m) != 0`, the bit was already $1$, meaning another thread had previously allocated this slot. This constitutes a failed attempt, also defined as a collision.\n\nTo measure the total number of collisions, we use a single shared counter, `total_failures`, initialized to $0$. This counter must be an atomic type, such as `_Atomic unsigned long long`, to allow for safe concurrent increments from multiple threads. Whenever a thread detects a collision, it atomically increments this counter.\n\nThe overall simulation procedure for a single test case is as follows:\n1.  Initialize a shared `bitmap` of the required size with all bits set to $0$.\n2.  Initialize a shared atomic counter `total_failures` to $0$.\n3.  Create and launch $T$ threads. Each thread is passed its unique ID $i$ and the parameters for the current test case ($N$, $M$, $s$, $a$, $b$).\n4.  Each thread $i$ executes a loop for $j$ from $0$ to $M-1$. In each iteration, it calculates the target index $\\text{idx}(i,j)$, performs the atomic bit-test-and-set, and atomically increments `total_failures` if a collision occurs.\n5.  The main thread waits for all $T$ threads to complete their execution using `thrd_join`.\n6.  Once all threads have terminated, the final value of the `total_failures` counter, $F$, is read.\n7.  The collision rate $c$ is calculated using the formula provided:\n$$ c = \\frac{F}{T \\cdot M} $$\nThis entire process is repeated independently for each of the four test cases specified in the problem statement. The resulting collision rates, $c_A, c_B, c_C, c_D$, are then formatted as required. The use of `atomic_fetch_or` and `atomic_fetch_add` with a relaxed memory order (`memory_order_relaxed`) is sufficient for this problem, as we are only concerned with the atomicity of the updates and the final count, not the relative ordering of memory operations between different variables.",
            "answer": "```c\n#include stdio.h\n#include stdlib.h\n#include string.h\n#include threads.h\n#include stdatomic.h\n#include limits.h\n\n// A struct to hold the parameters for a single test case.\ntypedef struct {\n    int N;\n    int T;\n    int M;\n    int s;\n    int a;\n    int b;\n} TestCase;\n\n// A struct to hold the parameters for a worker thread.\ntypedef struct {\n    int thread_id;\n    const TestCase* params;\n    _Atomic unsigned long* bitmap;\n    _Atomic unsigned long long* total_failures;\n} ThreadArgs;\n\n// The number of bits in an unsigned long.\n#define UL_BITS (sizeof(unsigned long) * CHAR_BIT)\n\n// The function executed by each worker thread.\nint worker_thread(void* arg) {\n    ThreadArgs* args = (ThreadArgs*)arg;\n    int i = args-thread_id;\n    const TestCase* p = args-params;\n    \n    // Extract parameters for clarity.\n    long N = p-N;\n    long M = p-M;\n    long s = p-s;\n    long a = p-a;\n    long b = p-b;\n\n    // Calculate the per-thread hash.\n    long h_i = (a * i + b) % N;\n\n    for (long j = 0; j  M; ++j) {\n        // Calculate the target bit index for this attempt.\n        long target_bit_idx = (h_i + j * s) % N;\n        \n        // Determine the word index and the bit position within the word.\n        long word_idx = target_bit_idx / UL_BITS;\n        int bit_in_word = target_bit_idx % UL_BITS;\n        \n        // Create the mask for the target bit.\n        unsigned long mask = 1UL  bit_in_word;\n        \n        // Perform the atomic bit-test-and-set operation.\n        // `atomic_fetch_or` atomically sets the bit and returns the OLD value of the word.\n        unsigned long old_word = atomic_fetch_or_explicit(args-bitmap[word_idx], mask, memory_order_relaxed);\n        \n        // Check if the bit was already set in the old word.\n        // If (old_word  mask) is non-zero, the bit was already 1, which means a collision occurred.\n        if ((old_word  mask) != 0) {\n            atomic_fetch_add_explicit(args-total_failures, 1, memory_order_relaxed);\n        }\n    }\n    \n    return thrd_success;\n}\n\n// Function to run a single test case and return the collision rate.\ndouble run_test_case(const TestCase* test_case) {\n    // Calculate the required size of the bitmap in unsigned long words.\n    size_t bitmap_size_words = (test_case-N + UL_BITS - 1) / UL_BITS;\n    \n    // Allocate memory for the bitmap.\n    _Atomic unsigned long* bitmap = calloc(bitmap_size_words, sizeof(_Atomic unsigned long));\n    if (!bitmap) {\n        perror(\"Failed to allocate bitmap\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Shared counter for total failed attempts (collisions).\n    _Atomic unsigned long long total_failures = 0;\n    \n    thrd_t threads[test_case-T];\n    ThreadArgs thread_args[test_case-T];\n\n    // Create and launch T threads.\n    for (int i = 0; i  test_case-T; ++i) {\n        thread_args[i] = (ThreadArgs){\n            .thread_id = i,\n            .params = test_case,\n            .bitmap = bitmap,\n            .total_failures = total_failures\n        };\n        if (thrd_create(threads[i], worker_thread, thread_args[i]) != thrd_success) {\n            perror(\"Failed to create thread\");\n            free(bitmap);\n            exit(EXIT_FAILURE);\n        }\n    }\n    \n    // Wait for all threads to complete.\n    for (int i = 0; i  test_case-T; ++i) {\n        thrd_join(threads[i], NULL);\n    }\n    \n    // Read the final count of failures.\n    unsigned long long F = atomic_load(total_failures);\n    \n    // Clean up allocated memory.\n    free(bitmap);\n    \n    // Calculate the total number of attempts.\n    long long total_attempts = (long long)test_case-T * test_case-M;\n    \n    // Calculate and return the collision rate.\n    return (double)F / total_attempts;\n}\n\nint main(void) {\n    // Define the test cases from the problem statement.\n    TestCase test_cases[] = {\n        { .N=1024, .T=8,  .M=64,  .s=3, .a=17, .b=5  }, // Case A\n        { .N=1024, .T=8,  .M=64,  .s=3, .a=0,  .b=0  }, // Case B\n        { .N=1000, .T=16, .M=120, .s=7, .a=19, .b=11 }, // Case C\n        { .N=64,   .T=32, .M=128, .s=1, .a=0,  .b=0  }  // Case D\n    };\n\n    // Calculate the number of test cases.\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    double results[num_cases];\n\n    // Calculate the result for each test case.\n    for (int i = 0; i  num_cases; ++i) {\n        results[i] = run_test_case(test_cases[i]);\n    }\n\n    // Print the results in the EXACT REQUIRED format before the final return statement.\n    printf(\"[%.6f,%.6f,%.6f,%.6f]\\n\", results[0], results[1], results[2], results[3]);\n\n    return EXIT_SUCCESS;\n}\n```"
        }
    ]
}