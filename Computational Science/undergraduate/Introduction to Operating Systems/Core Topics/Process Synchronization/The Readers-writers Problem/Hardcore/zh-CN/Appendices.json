{
    "hands_on_practices": [
        {
            "introduction": "在深入研究使用信号量或条件变量等同步原语实现读写锁之前，首先理解其背后的调度逻辑至关重要。这个练习将引导你构建一个离散时间模拟器，以实现一个具有写者优先策略的调度程序。通过将抽象的调度规则（例如，当有写者等待时，新读者不能开始）转化为具体的代码逻辑，你将能够深刻理解管理读者和写者请求所需的状态转换和决策过程 。",
            "id": "2422634",
            "problem": "给定一个共享内存并行系统，其中有一个逻辑共享对象，可通过两种类型的操作访问：读取者和写入者。每个操作都是一个请求，具有到达时间和执行时长两个特性，两者都以离散的无单位时间步长来衡量。一个操作一旦开始，将在其开始时间到开始时间加上其时长的半开区间内占用共享对象，即区间 $\\left[ s_i, s_i + d_i \\right)$，其中 $s_i$ 是开始时间，$d_i$ 是时长。\n\n系统必须满足以下语义和约束。\n\n1) 安全性约束。设 $R(t)$ 表示时间 $t$ 的活跃读取者数量，设 $W(t) \\in \\{0,1\\}$ 表示时间 $t$ 的活跃写入者数量。系统必须确保在任何时间 $t$，如果 $W(t) = 1$，则 $R(t) = 0$。此外，任何时候都不能有超过一个写入者同时活跃。当没有写入者活跃时，可以有多个读取者并发活跃。\n\n2) 写入者公平性约束（写入者免于饥饿）。一旦一个写入者到达并等待开始，直到没有等待中的写入者之前，任何新的读取者都不能开始。形式上，如果在时间 $t$ 存在一个写入者 $j$，其到达时间 $a_j \\le t$，开始时间 $s_j$ 满足 $s_j > t$，那么在时间 $t$ 就不能有任何读取者开始。\n\n3) 确定性调度语义。时间在一组离散的决策时间点上推进。在每个决策时间 $t$，假定在瞬间 $t$ 内遵循以下顺序：首先，所有结束时间恰好为 $t$ 的操作完成并释放资源；其次，所有到达时间等于 $t$ 的操作被视为已到达并加入等待集合；第三，根据以下规则确定新的开始操作：\n   a) 如果至少有一个等待中的写入者，并且没有活跃的读取者和写入者，那么最早到达的那个等待中的写入者必须在时间 $t$ 开始。\n   b) 否则，如果没有等待中的写入者且没有活跃的写入者，那么所有等待中的读取者都必须在时间 $t$ 开始。\n   c) 否则，在时间 $t$ 没有新的操作开始。\n如果多个请求的到达时间相同，它们的相对顺序以该测试用例输入中给出的顺序为准。操作的开始时间不得早于其到达时间。\n\n您的任务是实现一个程序，该程序为每个测试用例给定一个有限的请求列表，为所有请求构建遵循上述语义的开始时间，然后为每个测试用例计算以下三个量：\n- 一个布尔值，指示生成的调度是否同时满足上面定义的安全性约束和写入者公平性约束。\n- 最大并发读取者数量，即在整个调度中 $\\max_{t} R(t)$。\n- 完工时间（makespan），定义为最晚完成时间 $\\max_i \\left( s_i + d_i \\right)$ 与最早到达时间 $\\min_i a_i$ 之间的差值。\n\n测试套件。使用以下 $5$ 个测试用例。每个测试用例都是一个请求列表。每个请求是一个三元组 $(\\text{type}, a, d)$，其中 $\\text{type} \\in \\{\\text{R}, \\text{W}\\}$，$a$ 是到达时间，$d$ 是时长。对于测试用例内到达时间相同的情况，下面列出的请求顺序即为所需的打破平局的顺序。\n\n- 测试用例 1：\n  $[(\\text{R},\\, 0,\\, 5),\\, (\\text{R},\\, 1,\\, 3),\\, (\\text{W},\\, 2,\\, 4),\\, (\\text{R},\\, 6,\\, 2),\\, (\\text{W},\\, 6,\\, 1)]$.\n\n- 测试用例 2：\n  $[(\\text{R},\\, 0,\\, 2),\\, (\\text{R},\\, 0,\\, 2),\\, (\\text{R},\\, 1,\\, 1)]$.\n\n- 测试用例 3：\n  $[(\\text{W},\\, 0,\\, 2),\\, (\\text{W},\\, 1,\\, 2),\\, (\\text{W},\\, 3,\\, 1)]$.\n\n- 测试用例 4：\n  $[(\\text{R},\\, 0,\\, 5),\\, (\\text{R},\\, 1,\\, 5),\\, (\\text{W},\\, 2,\\, 2),\\, (\\text{R},\\, 2,\\, 1),\\, (\\text{R},\\, 3,\\, 1)]$.\n\n- 测试用例 5：\n  $[(\\text{R},\\, 0,\\, 1),\\, (\\text{W},\\, 0,\\, 1)]$.\n\n最终输出格式。您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。每个元素对应一个测试用例，并且其本身必须是按顺序排列的三元素列表 $[\\text{valid}, \\text{max\\_readers}, \\text{makespan}]$，不含空格。例如，一个有效的输出格式为\n$[[\\text{True},2,7],[\\text{False},1,3],[\\text{True},3,5],[\\text{True},2,4],[\\text{True},1,1]]$\n但实际值由您的实现针对指定的测试套件确定。",
            "solution": "该问题要求针对共享资源上的读写者问题，模拟一种确定性调度策略。解决方案包括两个主要阶段：首先，通过离散时间步长模拟系统以生成调度；其次，分析此调度以计算所需的指标。\n\n**1. 调度策略的模拟**\n\n任务的核心是实现一个严格遵守给定调度语义的离散时间模拟器。系统在任何时间 `t` 的状态可以通过活跃操作集合和等待操作集合来描述。\n\n我们来形式化状态变量：\n- 一个未处理请求的列表，按其到达时间 `a_i` 排序，若有平局则按输入顺序排序。每个请求 `i` 是一个元组 (类型, `a_i`, `d_i`)。我们将为其增加一个唯一ID和一个用于记录开始时间 `s_i` 的字段。\n- 一个等待中的读取者队列，`waiting_readers`。\n- 一个等待中的写入者队列，`waiting_writers`，根据到达时间按先进先出 (FIFO) 顺序维护。\n- 一个活跃读取者列表，`active_readers`。\n- 一个用于单个活跃写入者的变量，`active_writer`。\n\n模拟通过从 $t=0$ 开始递增时间变量 `t` 来进行。当所有请求都已到达、开始并完成后，模拟终止。\n\n在每个时间步 `t`，必须按照问题陈述中的规定，执行以下操作序列：\n\n**步骤 1：处理完成的操作**\n任何完成时间 `s_i + d_i` 等于 `t` 的活跃操作 `i` 会结束其执行。\n- 如果一个活跃的写入者 `j` 的 `s_j + d_j = t`，则通过将 `active_writer` 设置为 null 来释放资源。\n- 任何 `s_k + d_k = t` 的活跃读取者 `k` 都将从 `active_readers` 列表中移除。\n\n**步骤 2：处理到达的请求**\n所有到达时间 `a_i = t` 的请求 `i` 都将从未处理列表中移至相应的等待队列（`waiting_readers` 或 `waiting_writers`）。添加到队列时必须遵守平局打破规则（对于到达时间相同的请求，使用输入顺序）。\n\n**步骤 3：做出调度决策**\n根据活跃队列和等待队列的当前状态，遵循一套严格的规则来启动新的操作：\n- **规则 (a)：**如果 `waiting_writers` 非空 并且 `active_readers` 为空 并且 `active_writer` 为 null，则从 `waiting_writers` 中出列最早到达的写入者并启动它。其开始时间 `s_i` 设置为 `t`，并成为 `active_writer`。\n- **规则 (b)：**否则，如果 `waiting_writers` 为空 并且 `active_writer` 为 null，则启动 `waiting_readers` 中的所有读取者。对于这些读取者中的每一个，其开始时间 `s_i` 设置为 `t`，并将其移至 `active_readers` 列表。然后清空 `waiting_readers` 队列。\n- **规则 (c)：**在所有其他情况下（例如，资源被一个写入者占用，或在有写入者等待时被读取者占用），在时间 `t` 不能有新的操作开始。\n\n这个 `t++` 模拟循环将一直持续到所有请求都完成为止。\n\n**2. 对生成的调度进行分析**\n\n一旦模拟完成，所有请求都将有一个分配好的开始时间 `s_i`。然后我们分析这个完整的调度，为每个测试用例计算三个量。\n\n**A. 调度有效性**\n问题要求一个布尔值，用以指示生成的调度是否满足安全性和写入者公平性约束。所提供的调度规则旨在通过其构造来生成一个有效的调度。因此，这个检查可以作为对模拟器实现的验证。\n- **安全性检查：**一个调度是安全的，如果在任何时间 `t` 都没有一个写入者与任何其他操作（读取者或写入者）并发活跃，并且任何时候活跃的写入者都不超过一个。这可以通过遍历时间并检查活跃操作的集合来验证。\n- **公平性检查：**写入者免于饥饿的规则规定，如果有写入者在等待，那么在时间 `t` 不能有新的读取者开始。这可以通过检查每个读取者的开始时间 `s_k` 来核实。在 `t = s_k` 时，我们验证不存在任何写入者 `j` 满足 `a_j \\le s_k` 且 `s_j > s_k`。\n\n如果两项检查都通过，则调度是有效的。鉴于这些是确定性规则，对于正确的实现，这应该总是 `True`。\n\n**B. 最大并发读取者数量**\n这是在整个调度期间 `R(t)` 的最大值，其中 `R(t)` 是时间 `t` 的活跃读取者数量。这可以通过分析调度来计算。一个有效的方法是在时间 `s_i` 和 `s_i+d_i` 分别创建 `START_READER` 和 `END_READER` 事件列表。通过对这些事件进行排序并按时间扫描，我们可以跟踪当前活跃的读取者数量并找到其最大值。\n\n**C. 完工时间（Makespan）**\n完工时间（makespan）被定义为从第一个请求到达​​到最后一个请求完成所经过的总时间。其计算公式为：\n$$\n\\text{Makespan} = \\left( \\max_{i} (s_i + d_i) \\right) - \\left( \\min_{i} a_i \\right)\n$$\n最小到达时间 `min(a_i)` 可从输入数据中找到。最大完成时间 `max(s_i + d_i)` 由生成的调度确定。\n\n通过对每个测试用例遵循此程序，我们可以系统地得出所需的结果。使用简单的时间步进模拟可确保对问题形式化规范的直接而忠实的实现。",
            "answer": "```python\nimport numpy as np\nfrom collections import deque\n\ndef solve():\n    \"\"\"\n    Solves the readers-writers scheduling problem for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        [('R', 0, 5), ('R', 1, 3), ('W', 2, 4), ('R', 6, 2), ('W', 6, 1)],\n        # Test case 2\n        [('R', 0, 2), ('R', 0, 2), ('R', 1, 1)],\n        # Test case 3\n        [('W', 0, 2), ('W', 1, 2), ('W', 3, 1)],\n        # Test case 4\n        [('R', 0, 5), ('R', 1, 5), ('W', 2, 2), ('R', 2, 1), ('R', 3, 1)],\n        # Test case 5\n        [('R', 0, 1), ('W', 0, 1)],\n    ]\n\n    all_results = []\n    for case_data in test_cases:\n        # 1. Initialize requests\n        requests = [{'id': i, 'type': req_type, 'a': arrival, 'd': duration, 's': -1} \n                    for i, (req_type, arrival, duration) in enumerate(case_data)]\n        total_requests = len(requests)\n        \n        # 2. Simulation\n        time = 0\n        num_completed = 0\n        arrived_queue = deque(sorted(requests, key=lambda r: (r['a'], r['id'])))\n        waiting_readers = deque()\n        waiting_writers = deque()\n        active_readers = []\n        active_writer = None\n\n        while num_completed  total_requests:\n            # Process completions at the beginning of time t\n            if active_writer and (active_writer['s'] + active_writer['d'] == time):\n                num_completed += 1\n                active_writer = None\n            \n            remaining_active_readers = []\n            for r in active_readers:\n                if r['s'] + r['d'] == time:\n                    num_completed += 1\n                else:\n                    remaining_active_readers.append(r)\n            active_readers = remaining_active_readers\n\n            # Process arrivals at time t\n            while arrived_queue and arrived_queue[0]['a'] == time:\n                req = arrived_queue.popleft()\n                if req['type'] == 'R':\n                    waiting_readers.append(req)\n                else:\n                    waiting_writers.append(req)\n            \n            # Schedule new operations based on rules\n            if waiting_writers and not active_readers and not active_writer:\n                writer_to_start = waiting_writers.popleft()\n                writer_to_start['s'] = time\n                active_writer = writer_to_start\n            elif not waiting_writers and not active_writer:\n                while waiting_readers:\n                    reader_to_start = waiting_readers.popleft()\n                    reader_to_start['s'] = time\n                    active_readers.append(reader_to_start)\n            \n            # Advance time. If idle, jump to the next event.\n            if num_completed  total_requests:\n                if not active_readers and not active_writer and not waiting_readers and not waiting_writers and arrived_queue:\n                    if time  arrived_queue[0]['a']:\n                        time = arrived_queue[0]['a']\n                        continue\n                time += 1\n\n        # 3. Analysis of the generated schedule\n        schedule = requests\n        is_valid = True\n        max_time = max((r['s'] + r['d'] for r in schedule), default=0) if schedule else 0\n\n        # Check safety and calculate max readers\n        max_readers_count = 0\n        for t in range(max_time):\n            num_r = sum(1 for r in schedule if r['type'] == 'R' and r['s'] = t  r['s'] + r['d'])\n            num_w = sum(1 for r in schedule if r['type'] == 'W' and r['s'] = t  r['s'] + r['d'])\n            max_readers_count = max(max_readers_count, num_r)\n            if num_w > 1 or (num_w > 0 and num_r > 0):\n                is_valid = False\n                break\n        \n        # Check writer fairness\n        if is_valid:\n            for reader in schedule:\n                if reader['type'] == 'R':\n                    for writer in schedule:\n                        if writer['type'] == 'W' and writer['a'] = reader['s'] and writer['s'] > reader['s']:\n                            is_valid = False\n                            break\n                    if not is_valid:\n                        break\n        \n        # Calculate makespan\n        min_arrival_time = min((r['a'] for r in schedule), default=0) if schedule else 0\n        makespan = max_time - min_arrival_time\n\n        all_results.append([is_valid, max_readers_count, makespan])\n\n    # Format final output\n    result_str = \",\".join([f\"[{v},{r},{m}]\" for v, r, m in all_results])\n    print(f\"[{result_str}]\")\n\n\nsolve()\n```"
        },
        {
            "introduction": "掌握了调度逻辑之后，下一步便是使用现代同步工具来实现它。条件变量 (Condition Variables, CVs) 是一种功能强大的工具，但也伴随着一些微妙的陷阱，尤其是在Mesa语义和可能发生伪唤醒 (spurious wake-ups) 的环境中。本练习将挑战你辨别在实现写者优先策略时，读者线程正确的等待模式，从而确保代码的安全性与活性，这是编写正确并发程序的关键技能 。",
            "id": "3687757",
            "problem": "您正在为一个操作系统（OS）设计经典的读写者问题的同步机制，该机制具有写者优先策略并使用条件变量（CV）。共享状态包括一个互斥锁 $m$、条件变量 $canRead$ 和 $canWrite$、一个整数 $activeReaders$、一个整数 $waitingWriters$ 以及一个布尔值 $writerActive$。其语义如下：(i) `wait(cv, m)` 原子地释放 $m$ 并阻塞调用线程；当等待返回时，$m$ 已被重新获取；(ii) `signal(cv)` 或 `broadcast(cv)` 可能会唤醒一个或多个等待者，但允许虚假唤醒（即等待的线程可能在没有任何 `signal` 或 `broadcast` 调用的情况下被唤醒）；(iii) 应用 Mesa 风格的条件变量语义：被通知的线程只有在发出通知的线程释放 $m$ 之后才能运行，因此在等待者运行时，条件可能已经改变。\n\n要求的安全性属性是：最多只有一个写者是活动的，并且当有写者活动时，不能有任何读者在读取。形式上，当 $writerActive = \\text{true}$ 时，则 $activeReaders = 0$。写者优先策略要求，如果有任何写者正在活动或等待，新的读者不能进入。形式上，一个读者只有在 $\\lnot writerActive \\land waitingWriters = 0$ 的条件下才能进入临界区。\n\n考虑两种读者进入部分的代码形式，它们使用上述共享状态变量非正式地写成。两者都在持有 $m$ 的情况下执行，并在返回给调用者之前增加 $activeReaders$ 的值。\n\n- 单次检查版本：如果准入谓词为假，则执行一次 `wait(canRead, m)`，然后继续增加 $activeReaders$。\n- 循环版本：当准入谓词为假时，循环执行 `wait(canRead, m)`，当循环退出时，继续增加 $activeReaders$。\n\n您的任务是根据上述定义进行推理，选择关于在存在虚假唤醒和写者优先的情况下如何保护读者入口的正确陈述。\n\n以下哪些选项是正确的？\n\nA. 能够保持安全性和写者优先策略的循环守卫是：当 $\\big(writerActive \\lor waitingWriters  0\\big)$ 时，调用 `wait(canRead, m)`。只有当循环退出时，才应执行 $activeReaders \\leftarrow activeReaders + 1$。\n\nB. 循环守卫可以弱化为：当 $\\big(writerActive \\land waitingWriters  0\\big)$ 时，调用 `wait(canRead, m)`，因为如果两者中只有一个为真，不会发生违规。\n\nC. 带有单个 if 测试的单次检查版本是安全的，如果在单个 `wait(canRead, m)` 调用前检查一次 $\\big(writerActive \\lor waitingWriters  0\\big)$，因为 `wait` 在返回前会重新获取 $m$，因此条件不会意外改变。\n\nD. 存在一个调度序列可以证明单次检查版本在虚假唤醒下会失败：在时间 $t_1$，一个写者设置 $writerActive \\leftarrow \\text{true}$ 并持有 $m$；在时间 $t_2$，一个读者 $R$ 执行单个 if 测试，发现 $\\big(writerActive \\lor waitingWriters  0\\big)$ 为真，并调用 `wait(canRead, m)`；在时间 $t_3$，发生了一次虚假唤醒，$R$ 从 `wait` 返回并持有 $m$，而此时 $writerActive$ 仍然为 $\\text{true}$；在时间 $t_4$，由于没有重新检查，$R$ 增加了 $activeReaders$ 的值并与写者并发执行，从而违反了安全性。\n\nE. 当写者释放资源时，使用 `signal(canRead)` 而不是 `broadcast(canRead)` 可以消除读者代码中循环的需要，因为最多只有一个读者会被唤醒，并且当它运行时状态将是稳定的。\n\n选择所有适用的选项。",
            "solution": "用户希望对带有写者优先策略、使用 Mesa 风格条件变量的读写者问题的同步策略进行批判性分析。我将首先验证问题陈述，在确认其有效后，继续对每个选项进行详细分析。\n\n### **问题验证**\n\n**第一步：提取已知条件**\n\n-   **问题领域**：操作系统中的经典读写者问题。\n-   **同步策略**：写者优先。\n-   **原语**：互斥锁 $m$ 和条件变量（CVs）$canRead$ 和 $canWrite$。\n-   **共享状态**：整数 $activeReaders$、整数 $waitingWriters$、布尔值 $writerActive$。\n-   **条件变量语义**：\n    -   (i) `wait(cv, m)` 原子地释放 $m$，阻塞，并在返回时重新获取 $m$。\n    -   (ii) 允许虚假唤醒。\n    -   (iii) 应用 Mesa 风格语义：被通知的线程只有在发出通知的线程释放互斥锁 $m$ 后才能恢复执行。\n-   **安全性属性**：如果 $writerActive = \\text{true}$，则 $activeReaders = 0$。\n-   **写者优先策略**：一个读者只有在 $\\lnot writerActive \\land waitingWriters = 0$ 时才能进入其临界区。\n-   **待比较的代码结构**：\n    1.  **单次检查**：一个 `if` 语句在可能的 `wait` 之前对准入谓词进行一次测试。\n    2.  **循环**：一个 `while` 循环在继续执行前重复测试准入谓词。\n\n**第二步：使用提取的已知条件进行验证**\n\n问题陈述是**有效的**。\n-   它是**基于科学**且**客观的**：该问题是关于并发控制的一个典型的计算机科学问题。其术语（Mesa 语义、虚假唤醒、互斥锁、条件变量）和形式化属性在操作系统领域都是标准且被精确定义的。\n-   它是**定义明确的**：该问题提供了一整套规则（原语语义、安全属性、策略），并要求根据这些规则评估特定的实现选择。这允许进行唯一且逻辑的分析。\n-   设置中没有矛盾、歧义或事实错误。\n\n### **推导与求解**\n\n问题的核心在于读者准入条件与 Mesa 风格条件变量语义之间的相互作用。\n\n**Mesa 风格条件变量的基本原则：**\n问题陈述指出 (ii) 虚假唤醒是可能的，并且 (iii) 由于 Mesa 风格的语义，当等待的线程最终重新获取互斥锁并运行时，当初触发 `signal` 的条件可能已不再成立。这两个事实都意味着一个关键的设计原则：**从 `wait` 调用中唤醒后，线程不能假设期望的条件已经满足。**它必须重新评估该条件。\n\n使用 Mesa 风格条件变量等待条件 $P$ 变为真的标准且正确的模式是将 `wait` 调用放在一个 `while` 循环内：\n\n`lock(m);`\n`while (!P)`\n`    wait(cv, m);`\n`// ... 继续执行，此处保证 P 为真`\n`unlock(m);`\n\n任何在 `wait` 之前使用单个 `if` 检查的实现都存在固有缺陷，因为它在唤醒后未能重新检查条件。\n\n**将原则应用于本问题：**\n写者优先策略规定，读者只有在条件 $P \\equiv (\\lnot writerActive \\land waitingWriters = 0)$ 为真时才能继续。因此，需要等待的条件是 $\\lnot P$。使用德摩根定律：\n$$ \\lnot(\\lnot writerActive \\land waitingWriters = 0) \\equiv (\\lnot(\\lnot writerActive) \\lor \\lnot(waitingWriters = 0)) $$\n$$ \\equiv (writerActive \\lor waitingWriters \\neq 0) $$\n假设 $waitingWriters$ 不能为负，这等价于 $(writerActive \\lor waitingWriters  0)$。\n\n因此，正确的读者进入代码必须锁定互斥锁 $m$，在 $(writerActive \\lor waitingWriters  0)$ 的条件下循环，并且只有在循环终止后（即满足继续执行的条件时）才增加 $activeReaders$。\n\n### **逐项分析**\n\n**A. 能够保持安全性和写者优先策略的循环守卫是：当 $\\big(writerActive \\lor waitingWriters  0\\big)$ 时，调用 `wait(canRead, m)`。只有当循环退出时，才应执行 $activeReaders \\leftarrow activeReaders + 1$。**\n\n-   **分析**：该选项描述了从第一性原理推导出的确切实现。`while` 循环通过重新检查谓词，正确处理了虚假唤醒和 Mesa 风格语义固有的条件变化。谓词本身 $writerActive \\lor waitingWriters  0$ 是读者需要等待的正确条件，因为它是准入谓词 $\\lnot writerActive \\land waitingWriters = 0$ 的否定。在循环之后增加 $activeReaders$ 确保了只有在被授予访问权限后才对读者进行计数，从而保持了共享状态的完整性。\n-   **结论**：正确。\n\n**B. 循环守卫可以弱化为：当 $\\big(writerActive \\land waitingWriters  0\\big)$ 时，调用 `wait(canRead, m)`，因为如果两者中只有一个为真，不会发生违规。**\n\n-   **分析**：这提出了一个错误的等待条件。如果 $\\lnot(writerActive \\land waitingWriters  0)$ 为真，即 $\\lnot writerActive \\lor waitingWriters = 0$，循环就会终止。这不是所要求的准入条件。\n    -   情况 1：如果 $writerActive$ 为真且 $waitingWriters = 0$，循环条件为假。读者将退出循环并增加 $activeReaders$，导致状态变为 $writerActive = \\text{true}$ 且 $activeReaders  0$。这直接违反了指定的安全性属性。\n    -   情况 2：如果 $writerActive$ 为假且 $waitingWriters  0$，循环条件为假。读者将退出循环并继续执行，这违反了要求读者等待正在等待的写者的写者优先策略。\n-   **结论**：不正确。\n\n**C. 带有单个 if 测试的单次检查版本是安全的，如果在单个 `wait(canRead, m)` 调用前检查一次 $\\big(writerActive \\lor waitingWriters  0\\big)$，因为 `wait` 在返回前会重新获取 $m$，因此条件不会意外改变。**\n\n-   **分析**：这个选项为单次检查版本辩护。其推理存在根本性缺陷。虽然 `wait(canRead, m)` 确实会重新获取 $m$，但在线程被通知（或虚假唤醒）到它重新获取锁之间的这段时间里，其他线程可以运行。另一个线程可能已经获取了 $m$，改变了状态（例如，一个新的写者到达并设置了 $waitingWriters  0$），然后释放了 $m$。此外，虚假唤醒根本不提供任何关于状态的信息。处理这些情况需要一个 `while` 循环；一个 `if` 语句是不充分且不安全的。声称“条件不会意外改变”是错误的。\n-   **结论**：不正确。\n\n**D. 存在一个调度序列可以证明单次检查版本在虚假唤醒下会失败：在时间 $t_1$，一个写者设置 $writerActive \\leftarrow \\text{true}$ 并持有 $m$；在时间 $t_2$，一个读者 $R$ 执行单个 if 测试，发现 $\\big(writerActive \\lor waitingWriters  0\\big)$ 为真，并调用 `wait(canRead, m)`；在时间 $t_3$，发生了一次虚假唤醒，$R$ 从 `wait` 返回并持有 $m$，而此时 $writerActive$ 仍然为 $\\text{true}$；在时间 $t_4$，由于没有重新检查，$R$ 增加了 $activeReaders$ 的值并与写者并发执行，从而违反了安全性。**\n\n-   **分析**：该选项为单次检查版本提供了一个具体的失败场景。虽然措辞“在时间 $t_1$，一个写者...持有 $m$”和“在时间 $t_2$，一个读者 $R$ 执行”略有不精确（两个线程不能同时持有同一个互斥锁），但它所描述的状态逻辑序列是有效的，并展示了一个关键缺陷。一个更精确的时间线是：一个写者获取 $m$，设置 $writerActive \\leftarrow \\text{true}$，然后释放 $m$ 去工作。接着，读者 $R$ 获取 $m$，看到 $writerActive$ 为真，并调用 `wait(canRead, m)`，从而释放 $m$。然后，发生一次虚假唤醒。$R$ 重新获取 $m$。此时，写者仍然是活动的（$writerActive = \\text{true}$）。单次检查代码没有重新测试条件，所以 $R$ 错误地继续增加 $activeReaders$ 并进入临界区。这导致状态变为 $writerActive = \\text{true}$ 且 $activeReaders  0$，明显违反了安全性属性。所描述的场景是解释为什么必须使用 `while` 循环的经典例子。\n-   **结论**：正确。\n\n**E. 当写者释放资源时，使用 `signal(canRead)` 而不是 `broadcast(canRead)` 可以消除读者代码中循环的需要，因为最多只有一个读者会被唤醒，并且当它运行时状态将是稳定的。**\n\n-   **分析**：这个选项不正确，主要有两个原因。首先，声称“当它运行时状态将是稳定的”在 Mesa 风格语义下是错误的。如前所述，另一个线程可以在 `signal` 和等待者恢复运行之间改变状态。其次，它完全忽略了虚假唤醒的可能性，而虚假唤醒与使用 `signal` 还是 `broadcast` 无关。一次虚假唤醒仍然会导致单次检查代码失败。因此，切换到 `signal(canRead)` 并不能消除对 `while` 循环的需求。\n-   **结论**：不正确。",
            "answer": "$$\\boxed{AD}$$"
        },
        {
            "introduction": "一个逻辑上正确的并发实现，如果不能妥善处理预期之外的错误，仍然可能导致整个系统失灵。本练习展示了一个非常实际的场景：当一个读者线程因异常而意外终止，未能执行其清理代码时，将如何导致写者永久饥饿。通过分析这个故障，你将认识到保证资源清理（例如，递减读者计数）的极端重要性，并学习到使用 `try-finally` 等结构来构建健壮、具有异常安全性的并发代码 。",
            "id": "3687699",
            "problem": "一个系统使用单个互斥锁 $mutex$ 和两个条件变量 $canRead$ 和 $canWrite$ 实现了一个读写者协议。共享状态包括一个整数计数器 $rw\\_count$ 和一个布尔值 $writerActive$。预期的不变量是 $rw\\_count$ 等于当前活跃的读者线程数，并且写者只有在 $rw\\_count = 0$ 且 $writerActive = \\text{false}$ 时才能继续执行。预期的进入/退出行为如下：读者进入时获取 $mutex$，在 $writerActive = \\text{true}$ 时等待，增加 $rw\\_count$，然后释放 $mutex$；读者退出时获取 $mutex$，减少 $rw\\_count$，如果 $rw\\_count = 0$ 则向 $canWrite$ 发送信号，然后释放 $mutex$。写者进入时获取 $mutex$，在 $(rw\\_count  0) \\lor (writerActive = \\text{true})$ 时等待，将 $writerActive$ 设置为 $\\text{true}$，然后释放 $mutex$；写者退出时获取 $mutex$，将 $writerActive$ 设置为 $\\text{false}$，广播 $canRead$ 并向 $canWrite$ 发送信号，然后释放 $mutex$。\n\n考虑以下有 $3$ 个读者和 $2$ 个写者的场景。读者 $R\\_1$ 执行进入操作（获取 $mutex$，观察到 $writerActive = \\text{false}$，将 $rw\\_count$ 增加到 $1$，释放 $mutex$）并开始读取。读者 $R\\_2$ 和 $R\\_3$ 随后进入并将 $rw\\_count$ 增加到 $3$。写者 $W\\_1$ 尝试进入并因 $rw\\_count  0$ 而等待。在读取过程中，$R\\_2$ 遇到了一个触发异常的输入/输出错误，导致 $R\\_2$ 立即返回，而没有执行读者退出例程。结果，即使在 $R\\_2$ 停止读取后，$rw\\_count$ 仍然为 $3$，而 $W\\_1$ 继续等待。随着时间的推移，更多的写者到达并被卡住，等待 $rw\\_count$ 变为 $0$。在此期间没有线程操作 $writerActive$。\n\n仅使用互斥、条件变量和陈述的不变量 $rw\\_count = \\text{活跃读者数量}$ 的基本定义，分析为什么写者会被卡住，并找出最稳健的修正方案，该方案即使在读者代码中存在异常的情况下，也能保持安全性（写入期间无并发读取）和活性（读者完成后写者最终能继续执行）。\n\n哪个选项既能正确诊断故障，又提出了正确的修复模式？\n\nA. 问题在于 $rw\\_count$ 的增加和减少操作不是原子的；修复方法是使 $rw\\_count$ 成为原子类型，这样异常就无法干扰更新。\n\nB. 问题在于异常路径跳过了读者退出例程，违反了不变量 $rw\\_count = \\text{活跃读者数量}$；修复方法是将读取部分包装在 try-finally 块中：在 $mutex$ 保护下增加 $rw\\_count$ 并释放 $mutex$ 后，在 try 块中执行读取操作，并在 finally 块中重新获取 $mutex$，减少 $rw\\_count$，如果 $rw\\_count = 0$ 则向 $canWrite$ 发送信号，然后释放 $mutex$。\n\nC. 问题在于写者在错误的条件变量上等待；修复方法是让写者在 $canRead$ 上等待，以便读者完成时可以唤醒写者。\n\nD. 问题在于读者增加 $rw\\_count$ 的操作相对于检查 $writerActive$ 的顺序不当；修复方法是将增加 $rw\\_count$ 的操作移到读取完成后，这样异常就不会导致 $rw\\_count$ 的值过高。\n\nE. 问题是写者的等待中缺少超时机制；修复方法是添加一个超时，以便写者在有界延迟后无论 $rw\\_count$ 值如何都能继续执行。",
            "solution": "用户希望我扮演一名STEM教授，解决一个与读写者问题相关的计算机科学问题。\n\n我的计划如下：\n1.  **验证问题陈述**。我将逐字提取所有给定条件，并检查其科学合理性、良构性及其他标准。\n2.  **如果有效，从第一性原理推导解决方案**。我将分析所描述的故障模式的原因，并确定正确的架构模式以防止该故障，同时保持正确性（安全性和活性）。\n3.  **评估每个选项**。我将根据推导出的解决方案和并发编程的原则，系统地分析选项 A、B、C、D 和 E。\n4.  **格式化输出**。我将严格遵守所有格式化规则，特别是对所有数学和符号实体强制使用 LaTeX。\n\n### 第1步：提取给定条件\n\n*   **同步原语**：一个互斥锁 `$mutex$` 和两个条件变量 `$canRead$` 和 `$canWrite$`。\n*   **共享状态**：一个整数计数器 `$rw\\_count$` 和一个布尔值 `$writerActive$`。\n*   **预期不变量**：`$rw\\_count$` 等于当前活跃的读者线程数。\n*   **写者前置条件**：写者只有在 `$rw\\_count = 0$` 且 `$writerActive = \\text{false}$` 时才能继续执行。\n*   **读者进入协议**：获取 `$mutex$`，在 `$writerActive = \\text{true}$` 时等待，增加 `$rw\\_count$`，然后释放 `$mutex$`。\n*   **读者退出协议**：获取 `$mutex$`，减少 `$rw\\_count$`，如果 `$rw\\_count = 0$` 则向 `$canWrite$` 发信号，然后释放 `$mutex$`。\n*   **写者进入协议**：获取 `$mutex$`，在 `$(rw\\_count  0) \\lor (writerActive = \\text{true})$` 时等待，设置 `$writerActive = \\text{true}$`，然后释放 `$mutex$`。\n*   **写者退出协议**：获取 `$mutex$`，设置 `$writerActive = \\text{false}$`，广播 `$canRead$` 并向 `$canWrite$` 发信号，然后释放 `$mutex$`。\n*   **场景**：\n    *   一个有 `$3$` 个读者（`$R\\_1$`、`$R\\_2$`、`$R\\_3$`）和 `$2$` 个写者的系统。\n    *   `$R\\_1$`、`$R\\_2$` 和 `$R\\_3$` 成功执行读者进入协议。`$rw\\_count$` 变为 `$3$`。\n    *   一个写者 `$W_1$` 尝试进入并阻塞，等待 `$rw\\_count` 变为 `$0$`。\n    *   读者 `$R\\_2$` 遇到一个I/O错误，触发了一个异常，导致它立即终止任务。\n    *   关键是，`$R\\_2$` **没有执行读者退出例程**。\n    *   因此，`$rw\\_count$` 保持在一个较高的值。即使在 `$R\\_1$` 和 `$R\\_3$` 退出后，`$rw\\_count$` 将是 `$1$`，而不是 `$0$`。包括 `$W_1$` 在内的写者们将无限期地等待下去。\n\n### 第2步：使用提取的给定条件进行验证\n\n*   **科学依据**：该问题位于并发编程和操作系统的领域，涉及经典的读写者问题。所使用的原语（`mutex`、条件变量）和故障模式（异常安全性）是计算机科学中标准且易于理解的概念。该问题在科学上和技术上都是合理的。\n*   **良构性**：该问题描述了一个具体的实现、一个具体的故障场景，并要求诊断和稳健的修复。修复的目标（保持安全性和活性）已明确说明。可以推导出一个明确的概念性解决方案。\n*   **客观性**：描述是事实性的，没有主观或模糊的语言。系统的行为是根据协议规则确定性地描述的。\n*   **缺陷清单**：该问题没有违反任何指定的缺陷条件。它不是不合理、不完整、不切实际或不良构的。异常短路清理逻辑的场景是现实世界系统中常见且严重的错误，这使其成为一个相关且不简单的问题。\n\n### 第3步：结论和行动\n\n问题陈述是**有效的**。我将继续进行解答。\n\n### 解答推导\n\n读写者问题的核心是维护保证安全性和活性的不变量。这种“读者优先”或“共享读锁”模式的安全性不变量是双重的：\n$1$. 允许多个读者并发：`(写者数量) = 0`。\n$2$. 只允许单个写者独占：`(写者数量) = 1` $\\implies$ `(读者数量) = 0`。\n\n所提供的实现使用状态变量 `$rw\\_count$` 和 `$writerActive$` 来强制执行这些不变量。其逻辑依赖于预期的不变量：`$rw\\_count$` 精确反映当前正在执行读操作的线程数。\n\n**故障分析**：\n问题陈述指出，读者 `$R\\_2$` 在遇到异常时，“立即返回而没有执行读者退出例程”。\n\n读者进入例程执行以下状态更改：`$rw\\_count \\leftarrow rw\\_count + 1$`。\n读者退出例程负责相应的状态更改：`$rw\\_count \\leftarrow rw\\_count - 1$`。\n\n当 `$R\\_2$` 没有执行退出例程就终止时，对 `$rw\\_count$` 的增加操作就永远不会被撤销。变量 `$rw\\_count$` 现在永久性地多报了活跃读者的数量。系统状态与物理现实变得不一致；不变量 `$rw\\_count = \\text{活跃读者数量}$` 被违反了。\n\n写者进入协议包含条件 `wait while ($rw\\_count > 0$)`。因为 `$rw\\_count$` 永远不会返回到 `$0$`（它被永久性地偏移了 `$1$`），所以写者继续执行的条件将永远不会被满足。这导致所有写者线程的饥饿。\n\n**稳健修正的原则**：\n根本问题是在存在异常控制流的情况下，未能保证资源清理或状态恢复。这里的“资源”是对读锁的声明，由增加的 `$rw\\_count$` 表示。应应用的原则是，任何获取资源或修改共享状态的操作，都必须与一个相应的释放/恢复操作配对，该操作必须保证被执行，无论中间的代码是正常完成还是因异常而终止。\n\n在大多数支持异常的现代编程语言中，这种保证由 `try...finally` 块（或 `try...catch...finally`）提供。可能抛出异常的代码放在 `try` 块中，清理代码放在 `finally` 块中。`finally` 的语义保证了在因任何原因退出 `try` 块时它都会被执行。实现相同目标的另一个模式是“作用域界定资源管理”（Scope-Bound Resource Management, SBRM），在C++中也称为“资源获取即初始化”（Resource Acquisition Is Initialization, RAII）。\n\n一个稳健的读者实现的正确结构是：\n$1$. 读者进入：\n   - 获取 `$mutex$`。\n   - 等待读取权限（例如 `while ($writerActive$) { canRead.wait(mutex); }`）。\n   - 增加 `$rw\\_count$`。\n   - 释放 `$mutex$`。\n$2$. **受保护的读操作**：\n   - `try`\n      - 执行读操作（这是可能发生I/O错误和异常的地方）。\n   - `finally`\n      - 执行读者退出协议：\n         - 获取 `$mutex$`。\n         - 减少 `$rw\\_count$`。\n         - 如果 `$rw\\_count = 0$`，向 `$canWrite$` 发信号。\n         - 释放 `$mutex$`。\n\n这种结构确保了每次成功增加 `$rw\\_count$`，都保证会相应地执行一次减少操作，从而维护了共享状态的完整性和协议的正确性。\n\n### 逐项分析选项\n\n**A. 问题在于 `$rw\\_count$` 的增加和减少操作不是原子的；修复方法是使 `$rw\\_count$` 成为原子类型，这样异常就无法干扰更新。**\n- **分析**：问题指出对 `$rw\\_count$` 的更新是在持有 `$mutex$` 的情况下执行的。这已经保证了增加和减少操作相对于其他线程是原子的。失败的原因不是增加操作本身被中断，而是整个*退出例程*（其中包含减少操作）因异常而被跳过。将 `$rw\\_count$` 设为硬件支持的原子类型（如 C++ 中的 `std::atomic`）并不能解决这个问题，因为执行原子减少操作的那行代码仍然会被跳过。\n- **结论**：**不正确**。\n\n**B. 问题在于异常路径跳过了读者退出例程，违反了不变量 `$rw\\_count = \\text{活跃读者数量}$`；修复方法是将读取部分包装在 try-finally 块中：在 $mutex$ 保护下增加 $rw\\_count$ 并释放 $mutex$ 后，在 try 块中执行读取操作，并在 finally 块中重新获取 $mutex$，减少 $rw\\_count$，如果 $rw\\_count = 0$ 则向 $canWrite$ 发送信号，然后释放 $mutex$。**\n- **分析**：这个选项给出了完美的诊断：异常路径跳过了清理代码，导致不变量被破坏。提议的解决方案是使用一个 `try-finally` 块来包裹可能出错的读操作。放在 `finally` 块中的代码是完整的读者退出协议。这种架构模式是在面对异常时确保资源释放和状态一致性的经典且稳健的解决方案。这与从第一性原理推导出的解决方案相匹配。\n- **结论**：**正确**。\n\n**C. 问题在于写者在错误的条件变量上等待；修复方法是让写者在 $canRead$ 上等待，以便读者完成时可以唤醒写者。**\n- **分析**：在所描述的协议中，离开的读者向 `$canWrite$` 发信号，而写者在 `$canWrite$` 上等待。这是一个逻辑上正确的配对。变量 `$canRead$` 是由退出的写者用来向等待的读者发信号的。让写者在 `$canRead$` 上等待在语义上是不正确的。此外，问题不在于写者没有被唤醒；问题在于它等待的条件（`$rw\\_count = 0$`）由于状态损坏而永远无法变为真。改变条件变量并不能解决根本原因。\n- **结论**：**不正确**。\n\n**D. 问题在于读者增加 $rw\\_count$ 的操作相对于检查 $writerActive$ 的顺序不当；修复方法是将增加 $rw\\_count$ 的操作移到读取完成后，这样异常就不会导致 $rw\\_count$ 的值过高。**\n- **分析**：这个修复尝试解决状态损坏问题，但引入了严重的安全违规。如果 `$rw\\_count$` 仅在读操作*完成之后*才增加，那么在整个读操作期间，`$rw\\_count$` 并没有计入这个活跃的读者。如果另一个线程，一个写者，试图进入，它可能会看到 `$rw\\_count = 0$`（如果没有其他活跃的读者），然后它将继续写入。这会导致一个写者与一个读者并发操作，违反了读写者问题的基本安全性要求。\n- **结论**：**不正确**。\n\n**E. 问题是写者的等待中缺少超时机制；修复方法是添加一个超时，以便写者在有界延迟后无论 $rw\\_count$ 值如何都能继续执行。**\n- **分析**：这个“修复”建议写者在等待一段时间后，应该忽略等待条件（`$rw\\_count  0$`）并继续执行。这将导致写者在读者仍然活跃时开始写入，从而引发竞争条件和灾难性的安全违规。虽然超时可以用来检测和处理活性故障（如死锁或饥饿），但它们并不授予线程违反安全不变量的权限。超时的正确用法是记录错误、重试或上报，而不是盲目地继续。这个选项通过破坏协议的安全性来掩盖活性问题。\n- **结论**：**不正确**。",
            "answer": "$$\\boxed{B}$$"
        }
    ]
}