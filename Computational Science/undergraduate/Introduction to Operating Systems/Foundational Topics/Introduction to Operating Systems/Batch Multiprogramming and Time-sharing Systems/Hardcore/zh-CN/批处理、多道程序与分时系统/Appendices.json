{
    "hands_on_practices": [
        {
            "introduction": "多道程序设计是现代操作系统的基石，它允许CPU在某些进程等待I/O时保持繁忙。本练习使用一个简单而强大的概率模型，帮助您量化这一优势。通过将CPU利用率计算为进程数量的函数，您将对为何并发运行多个作业如此高效获得基本理解。",
            "id": "3623637",
            "problem": "一个分时多道程序操作系统以一个固定的多道程序度 $n$ 运行 $n$ 个独立的用户程序。在任意随机选择的时刻，每个程序都独立地以概率 $p \\in (0,1)$ 处于输入/输出 (I/O) 等待状态，并以概率 $1-p$ 处于就绪状态准备计算。假设调度程序是理想的：只要至少有一个程序处于就绪状态，中央处理器 (CPU) 就立即保持繁忙（没有调度开销或抢占延迟）。仅使用基本概率原理（独立事件和互补事件）作为你的出发点。\n\n(a) 设 $U(n,p)$ 表示长期 CPU 利用率，定义为在任意时刻 CPU 处于繁忙状态的概率。请从第一性原理出发，推导出用 $n$ 和 $p$ 表示的 $U(n,p)$。\n\n(b) 使用你的表达式，从数学上证明为什么在固定的 $p \\in (0,1)$ 条件下，增加 $n$ 会严格提高 $U(n,p)$，以及为什么当 $n$ 增大时 $U(n,p)$ 会趋近于完全利用。你的证明必须基于你在 (a) 部分推导出的定义以及独立事件的概率性质。\n\n(c) 对于给定的 I/O 等待概率 $p=0.7$，确定最小的整数 $n$，使得利用率目标 $U(n,p) \\ge 0.99$ 得以实现。请提供你所求解的精确不等式以及获得 $n$ 的步骤。最终答案必须是一个整数。无需进行四舍五入，因为答案是一个确切的整数。",
            "solution": "我们将首先验证问题的前提，然后使用概率论的基本原理依次解决每个部分。\n\n(a) CPU 利用率 $U(n,p)$ 的推导。\n\n系统由 $n$ 个独立的用户程序组成。在任意给定时刻，每个程序 $i$（其中 $i \\in \\{1, 2, \\dots, n\\}$）处于以下两种状态之一：\n1.  处于输入/输出 (I/O) 等待状态，概率为 $p$。设此事件为 $W_i$。因此，$P(W_i) = p$。\n2.  处于就绪状态准备计算，概率为 $1-p$。设此事件为 $R_i$。因此，$P(R_i) = 1-p$。\n\n问题指出调度程序是理想的，这意味着中央处理器 (CPU) 繁忙当且仅当至少有一个程序处于就绪状态。CPU 利用率 $U(n,p)$ 定义为 CPU 繁忙的概率。\n\n更直接的方法是首先计算其互补事件的概率：CPU 空闲。CPU 空闲当且仅当所有 $n$ 个程序同时处于 I/O 等待状态。设“CPU 空闲”事件为 $I_{CPU}$。\n$$ I_{CPU} \\iff W_1 \\cap W_2 \\cap \\dots \\cap W_n $$\n问题明確指出程序是独立的。因此，这些事件交集的概率是它们各自概率的乘积：\n$$ P(I_{CPU}) = P(W_1 \\cap W_2 \\cap \\dots \\cap W_n) = P(W_1) \\times P(W_2) \\times \\dots \\times P(W_n) $$\n因为对所有 $i$ 都有 $P(W_i) = p$，所以上式变为：\n$$ P(I_{CPU}) = \\prod_{i=1}^{n} P(W_i) = p \\times p \\times \\dots \\times p \\text{ ($n$ 次)} = p^n $$\n“CPU 繁忙”事件是“CPU 空闲”事件的互补事件。因此，CPU 利用率 $U(n,p)$ 是：\n$$ U(n,p) = 1 - P(I_{CPU}) $$\n代入 $P(I_{CPU})$ 的表达式，我们从第一性原理得到 CPU 利用率的表达式：\n$$ U(n,p) = 1 - p^n $$\n\n(b) 对 $U(n,p)$ 行为的数学证明。\n\n首先，我们将证明对于固定的 $p \\in (0,1)$，增加多道程序度 $n$ 会严格提高 CPU 利用率 $U(n,p)$。这需要证明对于任何整数 $n \\ge 1$，都有 $U(n+1, p) > U(n, p)$。\n\n根据我们推导出的表达式：\n$$ U(n+1, p) = 1 - p^{n+1} $$\n$$ U(n, p) = 1 - p^n $$\n因此，不等式 $U(n+1, p) > U(n, p)$ 等价于：\n$$ 1 - p^{n+1} > 1 - p^n $$\n两边同时减 1 得到：\n$$ -p^{n+1} > -p^n $$\n两边同乘以 -1，不等号反向：\n$$ p^{n+1}  p^n $$\n由于 $p \\in (0,1)$，$p$ 是严格正数，所以我们可以用 $p^n$ 除两边而不改变不等号的方向：\n$$ \\frac{p^{n+1}}{p^n}  \\frac{p^n}{p^n} $$\n$$ p  1 $$\n根据问题的定义 $p \\in (0,1)$，这最后一个不等式是成立的。因此，从数学上证明了 $U(n,p)$ 是关于 $n$ 的严格递增函数。\n\n其次，我们将证明当 $n$ 增大时，$U(n,p)$ 会趋近于完全利用（即 1）。这需要计算当 $n \\to \\infty$ 时 $U(n,p)$ 的极限。\n$$ \\lim_{n \\to \\infty} U(n,p) = \\lim_{n \\to \\infty} (1 - p^n) $$\n我们可以将其写为：\n$$ \\lim_{n \\to \\infty} 1 - \\lim_{n \\to \\infty} p^n $$\n对于任何满足 $|p|  1$ 的实数 $p$，当 $n \\to \\infty$ 时 $p^n$ 的极限为 0。问题中规定 $p \\in (0,1)$，这满足该条件。\n$$ \\lim_{n \\to \\infty} p^n = 0 $$\n因此，利用率的极限是：\n$$ \\lim_{n \\to \\infty} U(n,p) = 1 - 0 = 1 $$\n这表明随着多道程序度变得非常大，CPU 利用率趋近于 100%。\n\n(c) 最小多道程序度 $n$ 的计算。\n\n我们已知 I/O 等待概率 $p=0.7$ 和一个至少为 $0.99$ 的目标利用率。我们需要找到满足 $U(n, 0.7) \\ge 0.99$ 的最小整数 $n$。\n\n需要求解的不等式是：\n$$ 1 - (0.7)^n \\ge 0.99 $$\n我们开始求解 $n$。首先，分离出含有 $n$ 的项：\n$$ -(0.7)^n \\ge 0.99 - 1 $$\n$$ -(0.7)^n \\ge -0.01 $$\n乘以 -1 并反转不等号：\n$$ (0.7)^n \\le 0.01 $$\n为了解出指数 $n$，我们对不等式两边取自然对数。由于自然对数函数 $\\ln(x)$ 在 $x > 0$ 时是严格递增的，所以不等号的方向保持不变。\n$$ \\ln((0.7)^n) \\le \\ln(0.01) $$\n使用对数幂法则 $\\ln(a^b) = b \\ln(a)$：\n$$ n \\ln(0.7) \\le \\ln(0.01) $$\n现在，我们必须除以 $\\ln(0.7)$。关键要注意，由于 $0.7  1$，$\\ln(0.7)$ 的值是负数。不等式两边同除以一个负数会使不等号的方向反转。\n$$ n \\ge \\frac{\\ln(0.01)}{\\ln(0.7)} $$\n我们可以计算出右侧的数值：\n$$ \\ln(0.01) \\approx -4.60517 $$\n$$ \\ln(0.7) \\approx -0.35667 $$\n$$ n \\ge \\frac{-4.60517}{-0.35667} \\approx 12.911 $$\n因此，我们必须有 $n \\ge 12.911$。由于多道程序度 $n$ 必須是整数，满足此条件的最小整数 $n$ 是大于 12.911 的下一个整数，即 13。\n为了验证：\n当 $n=12$ 时，$U(12, 0.7) = 1 - (0.7)^{12} \\approx 1 - 0.01384 = 0.98616$，小于 $0.99$。\n当 $n=13$ 时，$U(13, 0.7) = 1 - (0.7)^{13} \\approx 1 - 0.009688 = 0.990312$，大于或等于 $0.99$。\n因此，最小整数 $n$ 是 $13$。",
            "answer": "$$\\boxed{13}$$"
        },
        {
            "introduction": "选择正确的调度算法对系统性能至关重要，一个糟糕的选择可能导致“护航效应”等病态行为。本练习让您亲身体验，分析一个专门设计用于困住简单“先来先服务”（FCFS）调度程序的工作负载。通过将其性能与抢占式的“最短剩余时间”（SRT）算法进行比较，您将具体衡量性能的显著提升，并理解抢占的价值。",
            "id": "3623594",
            "problem": "考虑一个单处理器操作系统，它使用先到先服务 (FCFS) 或最短剩余时间 (SRT) 算法来调度进程。系统没有上下文切换开销，处理器非空闲，并且每个进程都由单个、无阻塞、无输入/输出的中央处理器 (CPU) 突发组成。工作负载被特意设计用来在 FCFS 算法下引发护航效应：一个长进程 $J_{0}$ 在时间 $t=0$ 到达，需要 $100$ 毫秒的 CPU 突发时间；另有 $10$ 个短进程 $J_{1},J_{2},\\dots,J_{10}$ 分别在时间 $t=1,2,\\dots,10$ 到达，每个进程需要 $1$ 毫秒的 CPU 突发时间。\n\n使用以下基本定义：进程 $J_{i}$ 的完成时间 $C_{i}$ 是其 CPU 突发完成的时刻，到达时间为 $A_{i}$，周转时间为 $T_{i}=C_{i}-A_{i}$。平均周转时间是工作负载中所有进程的 $T_{i}$ 的算术平均值。\n\n(a) 在 FCFS 算法下，确定所有进程的完成时间并计算平均周转时间。\n\n(b) 在 SRT 算法下，确定所有进程的完成时间并计算平均周转时间。假设当一个剩余时间严格更短的进程到达时，会立即发生抢占，并且当在某个进程到达的精确时刻需要做出调度决策时，优先选择最近到达的较短作业来打破平局。\n\n(c) 将改进因子定义为比率\n$$I=\\frac{\\text{FCFS 下的平均周转时间}}{\\text{SRT 下的平均周转时间}}。$$\n计算该工作负载的 $I$。将最终的改进因子表示为一个纯数（无量纲），并将您的答案四舍五入到四位有效数字。",
            "solution": "该系统有一个长进程 $J_{0}$，其到达时间 $A_{0}=0$，CPU 突发时间为 $100$；还有十个短进程 $J_{k}$，其到达时间为 $A_{k}=k$（其中 $k\\in\\{1,2,\\dots,10\\}$），CPU 突发时间为 $1$。\n\n我们从定义开始：完成时间 $C_{i}$ 是进程完成其 CPU 突发的时间，周转时间是 $T_{i}=C_{i}-A_{i}$。平均周转时间为 $\\frac{1}{n}\\sum_{i=0}^{10}T_{i}$，其中 $n=11$ 是进程总数。\n\n(a) FCFS 算法：FCFS 是非抢占式的，它会调度就绪队列头部的最早到达的进程，直到该进程完成。由于 $J_{0}$ 在 $t=0$ 到达，它立即开始并连续运行 $100$ 毫秒。因此，\n- $J_{0}$ 从 $t=0$ 运行到 $t=100$，所以 $C_{0}=100$，$T_{0}=100-0=100$。\n\n所有短进程 $J_{k}$ 在时间间隔 $t\\in[1,10]$ 内到达，但在 FCFS 算法下，它们不能抢占 $J_{0}$。它们在 $J_{0}$ 后面排队，并在 $J_{0}$ 完成后按到达顺序得到服务。在 $t=100$ 之后，进程 $J_{1},J_{2},\\dots,J_{10}$ 每个需要 $1$ 毫秒，并按到达顺序执行。因此，它们的完成时间是\n- $J_{1}$：$C_{1}=100+1=101$，所以 $T_{1}=101-1=100$，\n- $J_{2}$：$C_{2}=101+1=102$，所以 $T_{2}=102-2=100$，\n- $\\dots$\n- $J_{10}$：$C_{10}=109+1=110$，所以 $T_{10}=110-10=100$。\n\n因此，在 FCFS 算法下，每个进程的周转时间都是 $100$。FCFS 下的平均周转时间是\n$$\\overline{T}_{\\text{FCFS}}=\\frac{1}{11}\\sum_{i=0}^{10}T_{i}=\\frac{1}{11}\\cdot 11\\cdot 100=100.$$\n这展示了护航效应：排在头部的单个长进程导致所有后续的短进程等待，从而增大了它们的周转时间。\n\n(b) SRT 算法：SRT 是抢占式的，并且总是运行剩余时间最短的进程。在 $t=0$ 时，$J_{0}$ 是唯一就绪的进程，所以它开始运行。在 $t=1$ 时，$J_{1}$ 到达，其剩余时间为 $1$，严格小于 $J_{0}$ 的剩余时间（99），因此 $J_{0}$ 被抢占，$J_{1}$ 开始运行。\n\n我们追踪调度过程：\n- 从 $t=0$ 到 $t=1$，$J_{0}$ 运行了 $1$ 毫秒，剩下 $99$ 毫秒的执行时间。\n- 在 $t=1$ 时，$J_{1}$ 到达并从 $t=1$ 运行到 $t=2$，在 $C_{1}=2$ 完成。其周转时间为 $T_{1}=2-1=1$。\n- 在 $t=2$ 时，$J_{2}$ 在 $J_{1}$ 完成的同一时刻到达。根据所述的平局打破规则，$J_{2}$ 从 $t=2$ 运行到 $t=3$，在 $C_{2}=3$ 完成。其周转时间为 $T_{2}=3-2=1$。\n- 这个模式继续下去：对于每个 $k\\in\\{3,4,\\dots,10\\}$，$J_{k}$ 在 $t=k$ 到达并立即运行 $1$ 毫秒，在 $C_{k}=k+1$ 完成，周转时间为 $T_{k}=(k+1)-k=1$。\n\n在各进程到达的间隔期间，没有空闲时间，因为每个短进程都在下一个短进程到达的下一个整数时刻精确完成，所以 $J_{0}$ 在 $t=1$ 和 $t=11$ 之间没有取得进展。在 $J_{10}$ 于 $t=11$ 完成后，$J_{0}$ 恢复运行，带着剩余的 $99$ 毫秒不间断地运行直到在 $t=11+99=110$ 完成。因此，\n- $C_{0}=110$ 且 $T_{0}=110-0=110$。\n\n汇总 SRT 算法下的周转时间：\n- 对于 $J_{0}$：$T_{0}=110$，\n- 对于每个 $k\\in\\{1,2,\\dots,10\\}$ 的 $J_{k}$：$T_{k}=1$。\n\nSRT 下的平均周转时间是\n$$\\overline{T}_{\\text{SRT}}=\\frac{1}{11}\\left(T_{0}+\\sum_{k=1}^{10}T_{k}\\right)=\\frac{1}{11}\\left(110+10\\cdot 1\\right)=\\frac{120}{11}.$$\n\n(c) 改进因子的定义为\n$$I=\\frac{\\overline{T}_{\\text{FCFS}}}{\\overline{T}_{\\text{SRT}}}=\\frac{100}{120/11}=\\frac{100\\cdot 11}{120}=\\frac{1100}{120}=\\frac{110}{12} = \\frac{55}{6}.$$\n数值上，$\\frac{55}{6} \\approx 9.1666...$。四舍五入到四位有效数字，得到 $I\\approx 9.167$。",
            "answer": "$$\\boxed{9.167}$$"
        },
        {
            "introduction": "在分时系统中，轮询调度（Round-Robin）算法提供了公平性和响应性，但其性能取决于一个关键参数：时间量 $q$。本练习挑战您调整此时间量，以满足交互式任务严格的响应时间保证，从而在服务众多进程的需求与上下文切换的开销之间取得平衡。您将从第一性原理出发，推导出允许的最大时间量，这是性能调优中的一项核心技能。",
            "id": "3623608",
            "problem": "一个分时系统使用时间片轮转（Round-Robin, RR）调度程序，其具有固定的时间量 $q$ 和每次切换的非重叠上下文切换时间 $s$。有 $N$ 个后台就绪进程，每个进程在阻塞等待输入/输出或完成之前，需要最多 $c_i$ 的中央处理器（CPU）服务时间，其中 $i \\in \\{1,\\dots,N\\}$。一个新到达的交互式进程产生一个回显事件，该事件需要 $e$ 的 CPU 时间来产生字符回显，然后阻塞。假设调度是基于就绪队列的严格 RR 调度，交互式进程在最坏可能的时间到达（即，它被附加到就绪队列的末尾，在所有 $N$ 个后台进程之后），并且每次抢占或进程完成时都会产生上下文切换开销 $s$，包括切换到交互式进程。\n\n根据分时和 RR 调度的基本原理，确定最大时间量 $q_{\\max}$（以毫秒为单位），以保证最坏情况下的回显响应时间 $R_{\\text{echo}}$（从交互式进程到达到着手完成回显）不超过 $100$ 毫秒。使用以下参数和进程 CPU 需求：\n- $s = 1$ 毫秒,\n- $N = 8$,\n- $e = 2$ 毫秒,\n- $(c_1,\\dots,c_8) = (22, 25, 19, 30, 24, 21, 27, 23)$ 毫秒。\n\n将您的最终答案表示为 $q_{\\max}$ 的单个数值（以毫秒为单位）。最终答案中不要包含单位。无需四舍五入；请提供精确值。",
            "solution": "回显响应时间 $R_{\\text{echo}}$ 是指从交互式进程到达系统，到其完成所需 CPU 时间 $e$ 的总时长。为了计算最坏情况下的响应时间，我们遵循问题设定：交互式进程被添加到已有 $N=8$ 个后台进程的就绪队列末尾。\n\n响应时间的计算取决于时间量 $q$ 与回显所需时间 $e$ 的相对大小。\n\n**情况 1：$q \\ge e$ (即 $q \\ge 2\\,\\mathrm{ms}$)**\n\n在此情况下，交互式进程可以在单个时间片内完成其工作，不会被中途抢占。\n最坏情况下的响应时间包括：\n1.  等待队列中所有 $N=8$ 个后台进程运行其时间片所花费的时间。对于每个后台进程 $i$，它将运行 $\\min(c_i, q)$ 的时间，随后产生一次耗时为 $s$ 的上下文切换。因此，等待一个后台进程的总时间为 $\\min(c_i, q) + s$。\n2.  交互式进程自身的执行时间 $e$。\n\n因此，总响应时间 $R_{\\text{echo}}$ 为：\n$$R_{\\text{echo}}(q) = \\sum_{i=1}^{N} (\\min(c_i, q) + s) + e = \\left(\\sum_{i=1}^{N} \\min(c_i, q)\\right) + Ns + e$$\n由于所有后台进程的 CPU 需求 $c_i$（最小为 $19\\,\\mathrm{ms}$）都远大于 $e=2\\,\\mathrm{ms}$，我们可以分析 $q$ 在 $[2, 19]$ 区间内的情况。在此区间内，对所有 $i$ 都有 $\\min(c_i, q) = q$。\n代入已知值 $N=8, s=1\\,\\mathrm{ms}, e=2\\,\\mathrm{ms}$，响应时间函数简化为：\n$$R_{\\text{echo}}(q) = \\sum_{i=1}^{8} q + 8(1) + 2 = 8q + 10$$\n根据约束条件 $R_{\\text{echo}} \\le 100\\,\\mathrm{ms}$：\n$$8q + 10 \\le 100$$\n$$8q \\le 90$$\n$$q \\le \\frac{90}{8} = 11.25\\,\\mathrm{ms}$$\n此结果 $q \\le 11.25\\,\\mathrm{ms}$ 与我们分析的区间 $q \\ge 2\\,\\mathrm{ms}$ 是一致的。由于当 $q > 11.25\\,\\mathrm{ms}$ 时，$R_{\\text{echo}}(q)$ 是一个增函数，会超过 $100\\,\\mathrm{ms}$ 的限制，因此在这种情况下的最大允许时间量是 $11.25\\,\\mathrm{ms}$。\n\n**情况 2：$q  e$ (即 $q  2\\,\\mathrm{ms}$)**\n\n在此情况下，交互式进程需要多于一个时间片才能完成。它将需要 $k = \\lceil e/q \\rceil = \\lceil 2/q \\rceil$ 个时间片。\n让我们分析 $q \\in (1, 2)$ 的子情况，此时 $k=2$。\n响应时间的计算如下：\n1.  初始等待 $N$ 个后台进程：每个进程运行 $q$ 并切换，总时间为 $N(q+s)$。\n2.  交互式进程运行第一个时间片：耗时 $q$。之后被抢占，产生一次切换开销 $s$。\n3.  再次等待 $N$ 个后台进程：总时间为 $N(q+s)$。\n4.  交互式进程运行第二个（也是最后一个）时间片：耗时 $e-q$。\n\n总响应时间为这些部分之和：\n$$R_{\\text{echo}}(q) = N(q+s) + q + s + N(q+s) + (e-q)$$\n$$R_{\\text{echo}}(q) = 2N(q+s) + s + e$$\n代入 $N=8, s=1, e=2$：\n$$R_{\\text{echo}}(q) = 2(8)(q+1) + 1 + 2 = 16(q+1) + 3 = 16q + 19$$\n应用约束条件 $16q + 19 \\le 100$，得出 $16q \\le 81$，即 $q \\le 5.0625\\,\\mathrm{ms}$。此条件对于整个区间 $q \\in (1, 2)$ 均成立。\n\n**结论**\n我们要求解的是满足约束的 *最大* 时间量 $q_{\\max}$。我们已经分析得出：\n- 对于 $q \\ge 2\\,\\mathrm{ms}$，允许的最大值为 $11.25\\,\\mathrm{ms}$。\n- 对于 $q  2\\,\\mathrm{ms}$ 的区间，所有解都小于 $2\\,\\mathrm{ms}$。\n\n综合所有情况，满足条件的最大时间量 $q_{\\max}$ 是 $11.25\\,\\mathrm{ms}$。",
            "answer": "$$\\boxed{11.25}$$"
        }
    ]
}