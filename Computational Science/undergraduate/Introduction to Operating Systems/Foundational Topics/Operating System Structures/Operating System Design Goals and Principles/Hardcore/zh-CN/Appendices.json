{
    "hands_on_practices": [
        {
            "introduction": "随着多核处理器的普及，调度器设计面临着新的挑战：如何在保证公平和效率的同时，最大限度地利用所有核心？这个练习  引导我们探讨两种经典的运行队列设计——全局队列与每核队列——之间的性能权衡。通过运用队列论模型，你将亲手计算出在不同核心数量下，两种设计的开销，并确定可伸缩性更强的每核队列设计开始超越传统全局队列的临界点，从而深刻理解可伸缩性作为一项关键的操作系统设计原则。",
            "id": "3664851",
            "problem": "一位操作系统（OS）设计师正在评估两种调度器运行队列设计，这两种设计将运行在具有 $n$ 个相同核心的对称多处理器上，且工作负载处于饱和状态（就绪队列永不为空）。每个作业的执行时间是确定的 $s$ 秒。设计师的目标是从第一性原理出发，推断排队开销作为 $n$ 的函数的可扩展性，并确定在每个作业的预期调度器引发延迟方面，何时每核心设计优于全局队列设计。\n\n设计A（全局运行队列）：一个单一的先进先出（FIFO）运行队列受一个锁保护。每次出队操作都会进入一个持续时间固定的临界区，时长为 $c$ 秒。在饱和状态下，每个核心重复获取锁，将一个作业出队，执行 $s$ 秒，然后重复此过程。将该锁建模为具有马尔可夫到达和马尔可夫服务时间的单服务器队列（M/M/1），其中服务率为 $1/c$，到达率等于出队尝试的总速率。假设只有当到达率严格小于服务率时，系统才能保持稳定。\n\n设计B（每核心运行队列）：每个核心都有自己的私有运行队列，每个作业的本地入队/出队成本为 $c_{\\ell}$，并且在通常情况下没有锁竞争。通过工作窃取（work stealing）偶尔进行负载均衡：对于每个作业，一个核心有 $p(n)$ 的概率执行一次窃取尝试，成本为 $d$ 秒。为本模型之目的，假设 $p(n) = \\kappa / n$，其中 $\\kappa \\in (0,1)$ 是一个常数，这反映了在饱和状态下，需要跨核心移动的作业比例随 $n$ 的增加而减少。\n\n对于两种设计，将每个作业由调度器引起的开销定义为在排队和调度活动中花费的预期时间，不包括作业本身的执行时间 $s$。使用设计A的锁的M/M/1稳定性条件和预期在系统中的时间，以及设计B给定的每个作业的本地成本和窃取成本，推导出每种设计的关于 $n$ 的开销函数。然后，对于以下参数值\n- $s = 5.0 \\times 10^{-4}\\,\\mathrm{s}$,\n- $c = 2.0 \\times 10^{-6}\\,\\mathrm{s}$,\n- $c_{\\ell} = 2.0 \\times 10^{-7}\\,\\mathrm{s}$,\n- $d = 1.5 \\times 10^{-5}\\,\\mathrm{s}$,\n- $\\kappa = 0.8$,\n确定最小的整数 $n \\geq 1$，使得每核心设计的每个作业的预期调度器引发开销小于或等于全局队列设计的每个作业的预期调度器引发开销。如果对于该 $n$ 值，设计A中的锁会变得不稳定，则报告满足优势条件和稳定性条件的最小 $n$。将您的最终答案以单个整数（核心数）的形式提供。由于要求是整数，因此不需要四舍五入的说明。使用 $\\mathrm{s}$ 表示任何以秒为单位的中间量。",
            "solution": "用户希望我作为一名STEM教授来解决一个问题，该问题涉及比较两种操作系统调度器设计。第一步是验证问题陈述。\n\n### 步骤1：提取给定信息\n-   核心数：$n$\n-   作业执行时间：$s = 5.0 \\times 10^{-4}\\,\\mathrm{s}$ (确定性)\n-   工作负载：饱和（就绪队列永不为空）\n\n**设计A（全局运行队列）：**\n-   带锁的单一FIFO队列。\n-   锁临界区持续时间（服务时间）：$c = 2.0 \\times 10^{-6}\\,\\mathrm{s}$\n-   模型：锁是一个M/M/1队列。\n-   锁队列的服务率：$\\mu = 1/c$\n-   锁队列的到达率：$\\lambda$，等于出队尝试的总速率。\n-   稳定性条件：$\\lambda  \\mu$。\n\n**设计B（每核心运行队列）：**\n-   每个核心有私有运行队列。\n-   本地入队/出队成本：$c_{\\ell} = 2.0 \\times 10^{-7}\\,\\mathrm{s}$\n-   每个作业的工作窃取概率：$p(n) = \\kappa / n$\n-   工作窃取成本：$d = 1.5 \\times 10^{-5}\\,\\mathrm{s}$\n-   工作窃取常数：$\\kappa = 0.8$\n\n**目标：**\n-   为两种设计定义每个作业由调度器引起的开销，不包括作业执行时间 $s$，分别表示为 $O_A(n)$ 和 $O_B(n)$。\n-   在设计A保持稳定的前提下，找到最小的整数 $n \\geq 1$，使得 $O_B(n) \\leq O_A(n)$。\n\n### 步骤2：使用提取的给定信息进行验证\n1.  **科学基础：** 该问题在计算机科学原理，特别是操作系统设计和使用排队论进行的性能分析方面有很好的基础。M/M/1模型是分析锁等共享资源竞争的标准工具，尽管它是一种简化模型。\n2.  **问题的适定性：** 该问题提供了清晰的定义和所有必要的参数，以推导开销函数并找到所需的整数值 $n$。目标是具体且可量化的。\n3.  **客观性：** 问题陈述是客观的，并使用了该领域的精确术语。\n4.  **完整性和一致性：** 该问题是自洽的。“将该锁建模为具有马尔可夫到达的单服务器队列”的指令指定了使用M/M/1模型，这解决了潜在的建模歧义。该指令是一个简化的假设，在性能建模中很常见，旨在使问题易于处理。\n5.  **不切实际或不可行：** 执行时间和开销的数值在现代多核处理器的实际范围内。\n6.  **不适定或结构不良：** 该问题结构良好。\n7.  **伪深刻、琐碎或同义反复：** 该问题需要对排队论和代数运算进行非平凡的应用。\n8.  **超出科学可验证性：** 该问题是一个数学建模练习，并且完全可以验证。\n\n### 步骤3：结论与行动\n该问题被认为是**有效的**。我们可以继续进行解答。\n\n### 开销函数的推导\n\n**设计A：全局运行队列开销, $O_A(n)$**\n\n每个作业由调度器引起的开销 $O_A(n)$，是一个核心为出队一个作业而等待和获取锁所花费的总时间。在指定的M/M/1模型背景下，这就是在系统中的预期总时间 $W$。\n\n锁服务器的服务率为 $\\mu = 1/c$。\n\n到达率 $\\lambda$ 是来自 $n$ 个核心的出队尝试的总速率。在饱和系统中，每个核心一旦完成前一个作业，就会立即尝试获取一个新作业。一个核心完成一个作业周期的时间包括作业执行时间 $s$ 和调度开销。在竞争下，开销起主导作用，超过了固定的执行时间。对此类分析的一个标准简化假设是，将来自 $n$ 个独立核心的到达率近似为在没有竞争情况下的最大可能吞吐量，其中每个核心贡献的速率为 $1/s$。因此，总到达率为 $\\lambda = n/s$。\n\nM/M/1队列仅在到达率严格小于服务率时才稳定，即 $\\lambda  \\mu$。\n$$ \\frac{n}{s}  \\frac{1}{c} \\implies n  \\frac{s}{c} $$\n对于一个稳定的系统，在排队系统中的预期时间（等待时间 + 服务时间）由以下公式给出：\n$$ O_A(n) = \\frac{1}{\\mu - \\lambda} $$\n代入 $\\mu$ 和 $\\lambda$ 的表达式：\n$$ O_A(n) = \\frac{1}{\\frac{1}{c} - \\frac{n}{s}} = \\frac{cs}{s - cn} $$\n这个开销表达式仅对满足稳定性条件的 $n$ 有效。\n\n**设计B：每核心运行队列开销, $O_B(n)$**\n\n每核心设计的开销包括两部分：一个恒定的本地成本和一个概率性的工作窃取成本。\n1.  本地入队/出队成本为 $c_{\\ell}$，每个作业都会产生。\n2.  每次作业有 $p(n) = \\kappa/n$ 的概率发生一次工作窃取尝试，成本为 $d$。\n\n每个作业的预期开销是本地成本和预期工作窃取成本的总和：\n$$ O_B(n) = c_{\\ell} + p(n) \\cdot d $$\n代入 $p(n)$ 的表达式：\n$$ O_B(n) = c_{\\ell} + \\frac{\\kappa d}{n} $$\n\n### 比较与计算\n\n我们需要找到最小的整数 $n \\ge 1$，使得 $O_B(n) \\le O_A(n)$，同时确保设计A对于该 $n$ 是稳定的。\n\n首先，我们使用给定的参数确定设计A的稳定性极限：\n-   $s = 5.0 \\times 10^{-4}\\,\\mathrm{s}$\n-   $c = 2.0 \\times 10^{-6}\\,\\mathrm{s}$\n稳定性条件是 $n  s/c$：\n$$ n  \\frac{5.0 \\times 10^{-4}}{2.0 \\times 10^{-6}} = 250 $$\n因此，当 $n \\ge 250$ 时，设计A是不稳定的。我们对 $n$ 的搜索范围被限制在 $[1, 249]$ 内。\n\n现在，我们建立不等式 $O_B(n) \\leq O_A(n)$：\n$$ c_{\\ell} + \\frac{\\kappa d}{n} \\le \\frac{cs}{s - cn} $$\n代入给定的参数值：\n-   $c_{\\ell} = 2.0 \\times 10^{-7}\\,\\mathrm{s}$\n-   $d = 1.5 \\times 10^{-5}\\,\\mathrm{s}$\n-   $\\kappa = 0.8$\n$$ 2.0 \\times 10^{-7} + \\frac{0.8 \\cdot (1.5 \\times 10^{-5})}{n} \\le \\frac{(2.0 \\times 10^{-6})(5.0 \\times 10^{-4})}{5.0 \\times 10^{-4} - (2.0 \\times 10^{-6})n} $$\n$$ 2.0 \\times 10^{-7} + \\frac{1.2 \\times 10^{-5}}{n} \\le \\frac{1.0 \\times 10^{-9}}{5.0 \\times 10^{-4} - (2.0 \\times 10^{-6})n} $$\n这个不等式很难解析求解。我们可以通过测试数值来找到最小的整数 $n$。我们观察到，当 $n$ 较小时，$O_A(n)$ 从一个接近 $c$ 的值缓慢增加，而 $O_B(n)$ 由于 $1/n$ 项而较大，并随着 $n$ 的增加而减小。我们预计每核心设计将在某个交叉点变得更有效率。\n\n让我们对小的整数 $n$ 值计算这两个函数：\n\n对于 $n=6$：\n$$ O_A(6) = \\frac{1.0 \\times 10^{-9}}{5.0 \\times 10^{-4} - 6 \\cdot (2.0 \\times 10^{-6})} = \\frac{1.0 \\times 10^{-9}}{5.0 \\times 10^{-4} - 1.2 \\times 10^{-5}} = \\frac{1.0 \\times 10^{-9}}{4.88 \\times 10^{-4}} \\approx 2.049 \\times 10^{-6}\\,\\mathrm{s} $$\n$$ O_B(6) = 2.0 \\times 10^{-7} + \\frac{1.2 \\times 10^{-5}}{6} = 2.0 \\times 10^{-7} + 2.0 \\times 10^{-6} = 2.2 \\times 10^{-6}\\,\\mathrm{s} $$\n在 $n=6$ 时，我们有 $O_B(6) > O_A(6)$。条件未满足。\n\n对于 $n=7$：\n$$ O_A(7) = \\frac{1.0 \\times 10^{-9}}{5.0 \\times 10^{-4} - 7 \\cdot (2.0 \\times 10^{-6})} = \\frac{1.0 \\times 10^{-9}}{5.0 \\times 10^{-4} - 1.4 \\times 10^{-5}} = \\frac{1.0 \\times 10^{-9}}{4.86 \\times 10^{-4}} \\approx 2.058 \\times 10^{-6}\\,\\mathrm{s} $$\n$$ O_B(7) = 2.0 \\times 10^{-7} + \\frac{1.2 \\times 10^{-5}}{7} \\approx 2.0 \\times 10^{-7} + 1.714 \\times 10^{-6} = 1.914 \\times 10^{-6}\\,\\mathrm{s} $$\n在 $n=7$ 时，我们有 $O_B(7) \\approx 1.914 \\times 10^{-6}\\,\\mathrm{s}$ 和 $O_A(7) \\approx 2.058 \\times 10^{-6}\\,\\mathrm{s}$。因此，$O_B(7)  O_A(7)$。\n\n由于条件 $O_B(n) \\le O_A(n)$ 在 $n=6$ 时不满足，但在 $n=7$ 时满足，因此使得每核心设计的开销小于或等于全局队列设计开销的最小整数是 $n=7$。\n\n最后，我们必须检查设计A在 $n=7$ 时是否稳定。稳定性极限是 $n  250$。由于 $7  250$，稳定性条件得到满足。因此，同时满足优势条件和稳定性条件的最小整数 $n$ 是 $7$。",
            "answer": "$$\n\\boxed{7}\n$$"
        },
        {
            "introduction": "高效的内存管理是实现多道程序设计的基石，但当系统内存资源不足时，可能会陷入“颠簸”（thrashing）的灾难性状态，即系统花费绝大部分时间在页面换入换出上，而非执行有效工作。这个练习  将带你使用经典的工作集模型来量化进程的内存需求。你将分析一个具体的系统场景，判断其是否处于颠簸状态，并根据操作系统的资源管理策略，计算出为恢复系统性能所需采取的最小矫正措施，这让你直观地体验到操作系统在维持系统稳定性和吞吐量之间的动态平衡。",
            "id": "3664899",
            "problem": "一个具有大小为 $R$ 的随机存取存储器 (RAM) 的多道程序系统正在运行 $n$ 个进程。根据工作集模型，每个进程 $i$ 在最近的 $ \\Delta $ 次内存引用窗口内都有一个工作集 $W_i(\\Delta)$；该集合的大小为 $|W_i|$，以页或等效的内存单位计量。颠簸（Thrashing）是一种操作状态，在此状态下，系统花费了不成比例的大部分时间来处理页错误，而不是执行有用的工作；在实践中，当活动工作集所要求的总驻留内存无法由可用的物理内存满足时，就会观察到这种情况。\n\n从这些原则出发，推导出一个阈值条件，该条件用包含 $R$ 和 $\\{|W_i|\\}_{i=1}^{n}$ 的不等式表示，标志着在稳态下工作集模型中颠簸的开始，假设工作集中的每一页都必须驻留在内存中以维持较低的页错误率。然后将此条件应用于以下具体情景，并确定一个与常见操作系统设计目标（例如在防止颠簸的同时保持吞吐量）一致的最小纠正措施：\n\n- 物理 RAM: $R = 16$ GiB。\n- 进程数量: $n = 7$。\n- 工作集大小（单位 GiB）: $|W_1| = 2.5$, $|W_2| = 3.0$, $|W_3| = 4.5$, $|W_4| = 1.0$, $|W_5| = 5.5$, $|W_6| = 2.0$, $|W_7| = 1.5$。\n- 操作系统采用安全余量策略：为了降低颠簸风险并适应短期波动，其目标是保留 RAM 的一个空闲内存余量分数 $\\beta$，其中 $\\beta = 0.2$。也就是说，它的目标是使活动工作集的总大小不超过 $(1 - \\beta) R$。\n\n任务：\n1. 仅使用上述定义，推导出用 $R$ 和 $\\{|W_i|\\}$ 表示的描述颠簸开始的符号阈值不等式。\n2. 对于给定的 $R$ 和 $\\{|W_i|\\}$，计算总工作集需求，并确定系统是否正在颠簸。\n3. 如果系统正在颠簸，确定操作系统必须挂起的最小进程数（选择挂起进程以最小化该数量），从而使剩余的活动工作集大小总和不超过安全目标 $(1 - \\beta) R$。若有平局，则优先挂起 $|W_i|$ 值最大的进程，这与为给定缩减量最小化挂起数量的原则一致。\n4. 最终答案只报告需要挂起的最小进程数。不要包含单位。此整数结果无需四舍五入。中间内存量根据需要以 GiB 表示，但最终答案必须是一个纯数字。",
            "solution": "将通过首先提取所有给定信息，然后评估其科学基础、一致性和完整性来验证该问题。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n\n-   总 RAM 大小：$R$\n-   进程数量：$n$\n-   进程 $i$ 的工作集大小：$|W_i|$\n-   颠簸条件：活动工作集所要求的总驻留内存超过了可用的物理内存。\n-   低页错误率的要求：工作集中的每一页都必须驻留在 RAM 中。\n-   具体情景数值：\n    -   物理 RAM：$R = 16$ GiB\n    -   进程数量：$n = 7$\n    -   工作集大小：$|W_1| = 2.5$ GiB, $|W_2| = 3.0$ GiB, $|W_3| = 4.5$ GiB, $|W_4| = 1.0$ GiB, $|W_5| = 5.5$ GiB, $|W_6| = 2.0$ GiB, $|W_7| = 1.5$ GiB。\n-   操作系统策略：\n    -   维持一个 $\\beta = 0.2$ 的空闲内存余量分数。\n    -   活动工作集总大小的目标是不超过 $(1 - \\beta)R$。\n-   任务：\n    1.  推导颠簸开始的符号阈值不等式。\n    2.  根据其策略，确定给定系统是否正在颠簸。\n    3.  找出为满足策略目标而需挂起的最小进程数。挂起策略是最小化进程数量，若有平局则优先挂起 $|W_i|$ 较大的进程。\n    4.  报告需要挂起的最小进程数。\n\n**步骤 2：使用提取的已知条件进行验证**\n\n-   **科学基础：** 该问题基于公认的程序行为工作集模型和颠簸概念，这些是操作系统中的基本主题。定义和关系都是标准的。此标准已满足。\n-   **问题适定性：** 该问题提供了所有必要的数值和明确、无歧义的纠正措施目标（最小化挂起进程的数量）。可以确定唯一的解决方案。此标准已满足。\n-   **客观性：** 该问题使用精确的量化语言陈述。它不含主观或基于意见的断言。此标准已满足。\n-   **缺陷清单：**\n    1.  **科学或事实不健全：** 无。该模型是计算机科学中使用的标准且有效的抽象。\n    2.  **不可形式化或不相关：** 无。该问题是一个可形式化的计算任务，与操作系统资源管理直接相关。\n    3.  **设置不完整或矛盾：** 无。所有需要的数据和约束都已提供且自洽。\n    4.  **不切实际或不可行：** 无。内存和工作集的大小对于现代多道程序系统是现实的。\n    5.  **不适定或结构不良：** 无。该问题导向一个唯一、稳定且有意义的解。\n    6.  **伪深刻、琐碎或同义反复：** 无。该问题需要一个涉及推导、计算和优化的多步逻辑过程，这是非平凡的。\n    7.  **超出科学可验证性范围：** 无。计算在给定模型内是可验证的。\n\n**步骤 3：结论与行动**\n该问题有效。将提供完整解答。\n\n### 解答\n\n**1. 符号阈值不等式的推导**\n\n问题将颠簸定义为系统的可用物理内存不足以容纳所有运行中进程的活动工作集的情况。设 $R$ 为随机存取存储器 (RAM) 的总大小。设有 $n$ 个进程，进程 $i$ 的工作集大小表示为 $|W_i|$。\n\n为使系统避免频繁的页错误，每个活动进程的工作集都必须驻留在内存中。因此，所有 $n$ 个进程所需求的总内存是它们各自工作集大小的总和。这个总需求 $D_{total}$ 由下式给出：\n$$\nD_{total} = \\sum_{i=1}^{n} |W_i|\n$$\n当这个总需求超过可用物理内存 $R$ 时，颠簸开始发生。因此，阈值条件由以下不等式表示：\n$$\n\\sum_{i=1}^{n} |W_i|  R\n$$\n问题进一步指定了一个要求安全余量的操作系统策略。总 RAM 的一部分（比例为 $\\beta$）需要保持空闲。这意味着可用于分配给工作集的内存实际上减少到 $(1 - \\beta)R$。根据此策略，如果总需求超过这个减少后的分配量，系统就被认为处于需要纠正措施的状态（一个策略定义的颠簸状态）。针对此情景的控制不等式是：\n$$\n\\sum_{i=1}^{n} |W_i|  (1 - \\beta)R\n$$\n这就是我们必须为给定情景评估的条件。\n\n**2. 系统状态分析**\n\n给定以下数值：\n-   $R = 16$ GiB\n-   $\\beta = 0.2$\n-   工作集大小的集合为 $\\{2.5, 3.0, 4.5, 1.0, 5.5, 2.0, 1.5\\}$，单位均为 GiB。\n\n首先，我们计算总工作集需求 $D_{total}$：\n$$\nD_{total} = 2.5 + 3.0 + 4.5 + 1.0 + 5.5 + 2.0 + 1.5 = 20.0 \\text{ GiB}\n$$\n接下来，我们根据安全策略计算目标内存容量 $R_{target}$：\n$$\nR_{target} = (1 - \\beta)R = (1 - 0.2) \\times 16 = 0.8 \\times 16 = 12.8 \\text{ GiB}\n$$\n现在，我们检查是否满足策略定义的颠簸条件：\n$$\nD_{total}  R_{target}\n$$\n$$\n20.0 \\text{ GiB}  12.8 \\text{ GiB}\n$$\n该不等式成立。因此，根据其自身的资源管理策略，系统处于颠簸状态，必须采取纠正措施。\n\n**3. 确定最小纠正措施**\n\n系统必须挂起一个或多个进程，以将总工作集需求 $D_{total}$ 降低到小于或等于 $R_{target}$ 的值。所需的内存需求减少量 $\\Delta D_{req}$ 为：\n$$\n\\Delta D_{req} = D_{total} - R_{target} = 20.0 - 12.8 = 7.2 \\text{ GiB}\n$$\n为了挂起最少数量的进程以释放至少 $7.2$ GiB 内存，我们应该采用贪婪策略：首先挂起工作集最大的进程。这种方法对于最小化挂起进程的数量是最优的。\n\n首先，我们按工作集大小 $|W_i|$ 的降序对进程进行排序：\n1.  进程 5: $|W_5| = 5.5$ GiB\n2.  进程 3: $|W_3| = 4.5$ GiB\n3.  进程 2: $|W_2| = 3.0$ GiB\n4.  进程 1: $|W_1| = 2.5$ GiB\n5.  进程 6: $|W_6| = 2.0$ GiB\n6.  进程 7: $|W_7| = 1.5$ GiB\n7.  进程 4: $|W_4| = 1.0$ GiB\n\n现在，我们累积计算被挂起进程的工作集大小，直到释放的总内存达到或超过 $\\Delta D_{req} = 7.2$ GiB。\n\n-   **挂起第一个进程（进程 5）：**\n    -   挂起的进程数 = $1$。\n    -   释放的总内存 = $|W_5| = 5.5$ GiB。\n    -   由于 $5.5  7.2$，这还不够。我们必须再挂起一个进程。\n\n-   **挂起第二个进程（进程 3）：**\n    -   挂起的进程数 = $2$。\n    -   释放的总内存 = $5.5 + |W_3| = 5.5 + 4.5 = 10.0$ GiB。\n    -   由于 $10.0 \\ge 7.2$，所需减少量已达到。\n\n通过挂起两个进程（工作集大小分别为 $5.5$ GiB 和 $4.5$ GiB 的进程），总内存需求减少了 $10.0$ GiB。新的需求为 $20.0 - 10.0 = 10.0$ GiB，小于目标值 $12.8$ GiB。\n\n只挂起一个进程（最大的，即 $|W_5|=5.5$ GiB）是不够的。挂起任何其他两个进程所减少的内存都会比挂起最大的两个要少（例如， $|W_3|+|W_2| = 4.5+3.0=7.5$，虽然也满足要求，但规则是优先挂起最大的以确保最优性）。因此，通过选择最大的进程可以实现最小化挂起进程数的目标。\n\n因此，操作系统必须挂起的最小进程数是 $2$。",
            "answer": "$$\n\\boxed{2}\n$$"
        },
        {
            "introduction": "操作系统的一个核心设计目标是提供进程间的隔离，以确保一个进程的错误或恶意行为不会影响到系统的其他部分，这是实现系统安全和稳定性的关键。此练习  通过一个抽象的“引用监视器”模型，让你亲手模拟基于白名单的系统调用过滤机制，这正是“最小权限原则”的体现。你将追踪一个模拟进程的系统调用序列，并根据给定的安全策略，判断其行为是否被允许、在何处被终止，以及是否有害操作成功“逃逸”，从而将抽象的安全设计原则转化为可观察、可度量的具体结果。",
            "id": "3664897",
            "problem": "设计并实现一个独立的程序，通过一个抽象的、确定性的引用监视器来模拟操作系统中的隔离原则，该监视器强制执行一个系统调用的白名单。该模型旨在捕捉通过完全中介和最小权限实现隔离的设计目标，其精神类似于系统调用过滤机制。程序不得依赖任何操作系统接口；相反，它必须模拟该策略及其对工作负载轨迹的影响。\n\n您的推理应基于以下基本定义，这些定义应被视为唯一允许的推导起点：\n\n- 系统调用是访问内核特权的唯一受控接口；引用监视器中介每个系统调用（完全中介），并通过允许或阻止尝试的系统调用来强制执行安全策略。\n- 在失效-停止策略下，当尝试的系统调用不在允许的调用白名单中时，进程将立即终止，并且不再尝试后续的系统调用。\n- 最小权限原则通过只允许一个大小为 $n$ 的许可系统调用集合来体现，该集合表示为白名单。\n\n抽象模型和语义：\n\n- 设系统调用的全集由整数索引，并设 $\\mathcal{A}$ 表示允许的系统调用标识符集合，其中 $\\lvert \\mathcal{A} \\rvert = n$。\n- 设 $\\mathcal{H}$ 表示被视为有害的标识符集合。\n- 设 $W = \\langle w_0, w_1, \\dots, w_{L-1} \\rangle$ 表示一个尝试的系统调用的工作负载轨迹，其中每个 $w_i$ 是一个整数标识符。\n- 在策略下，对 $W$ 的执行从左到右进行，并采用完全中介。若 $w_i \\in \\mathcal{A}$，则 $w_i$ 被执行。若 $w_i \\notin \\mathcal{A}$，则进程在索引 $i$ 处终止（失效-停止），并且对于 $j  i$ 的后续 $w_j$ 不再执行。\n- 定义一个有害逃逸指示器 $E$ 如下：如果存在索引 $i$ 使得 $w_i \\in \\mathcal{H}$ 且 $w_i$ 在策略下被执行，则 $E = 1$；否则 $E = 0$。\n- 定义允许执行计数 $C$ 为在终止之前（如果未发生终止，则为 $W$ 中的全部调用）已执行的系统调用数量。\n- 定义阻塞索引 $B$ 为遇到的第一个不允许的调用的索引；如果没有不允许的调用，则令 $B = -1$。\n- 定义遏制成功 $S$ 为：若 $E = 0$，则 $S = 1$，否则 $S = 0$。\n\n您的任务：\n\n- 实现一个程序，对于下面指定的固定测试用例，根据上述语义模拟执行，并为每个测试用例输出四元组 $[S, C, B, E]$。\n- 布尔值必须表示为整数：使用 $1$ 表示真，$0$ 表示假。\n- 不涉及物理单位。\n\n测试套件：\n\n请提供以下测试用例的结果。对于每个用例，提供了宇宙大小 $S$ 作为上下文，但只有 $\\mathcal{A}$、$\\mathcal{H}$ 和 $W$ 影响模拟。\n\n- 测试用例 $T_1$：$S = 8$，$n = 3$，$\\mathcal{A} = \\{0, 1, 2\\}$，$\\mathcal{H} = \\{5, 6\\}$，$W = \\langle 0, 1, 5, 3, 6 \\rangle$。\n- 测试用例 $T_2$：$S = 8$，$n = 0$，$\\mathcal{A} = \\varnothing$，$\\mathcal{H} = \\{2, 3\\}$，$W = \\langle 2, 7, 3 \\rangle$。\n- 测试用例 $T_3$：$S = 8$，$n = 4$，$\\mathcal{A} = \\{0, 2, 5, 7\\}$，$\\mathcal{H} = \\{5, 6\\}$，$W = \\langle 0, 5, 2, 7 \\rangle$。\n- 测试用例 $T_4$：$S = 8$，$n = 3$，$\\mathcal{A} = \\{0, 4, 6\\}$，$\\mathcal{H} = \\{6, 7\\}$，$W = \\langle 0, 4, 1, 6, 7 \\rangle$。\n- 测试用例 $T_5$：$S = 8$，$n = 2$，$\\mathcal{A} = \\{1, 3\\}$，$\\mathcal{H} = \\{2\\}$，$W = \\langle \\rangle$ (空轨迹)。\n- 测试用例 $T_6$：$S = 8$，$n = 3$，$\\mathcal{A} = \\{1, 5, 7\\}$，$\\mathcal{H} = \\{5\\}$，$W = \\langle 1, 5, 2 \\rangle$。\n\n要求的最终输出格式：\n\n- 您的程序应生成单行输出，其中包含从 $T_1$ 到 $T_6$ 的结果，格式为每个测试用例列表的逗号分隔列表，不含空格。例如，要求的格式严格如下\n$[[S_1,C_1,B_1,E_1],[S_2,C_2,B_2,E_2],\\dots,[S_6,C_6,B_6,E_6]]$，\n打印在单行上，且没有其他内容。\n- 程序必须是自包含的，不得读取任何输入，并且必须根据上述规范从测试套件计算结果。",
            "solution": "问题陈述是有效的。它提出了一个定义明确、自包含且有科学依据的引用监视器抽象模型，这是操作系统安全中的一个基本概念。该模型基于完全中介、最小权限和失效-停止策略等既定原则。定义、语义和测试用例清晰、精确且逻辑一致，从而可以推导出唯一的、确定性的解决方案。\n\n任务是模拟引用监视器在给定的工作负载轨迹上强制执行安全策略的过程。模拟必须遵循所提供的抽象模型及其确定性语义。核心原则是：\n\n1.  **完全中介**：工作负载轨迹中的每一次系统调用尝试都必须由引用监视器进行中介。\n2.  **最小权限**：安全策略是一个白名单，由集合 $\\mathcal{A}$ 表示。进程仅被授予在 $\\mathcal{A}$ 中明确列出的权限（即系统调用）。\n3.  **失效-停止**：如果一个进程尝试调用不在 $\\mathcal{A}$ 中的系统调用，其执行将立即被终止。\n\n设系统调用的全集是一个整数集合。策略由两个集合定义：\n-   $\\mathcal{A}$：允许的系统调用标识符集合。\n-   $\\mathcal{H}$：有害的系统调用标识符集合。\n\n一个进程的行为由工作负载轨迹 $W = \\langle w_0, w_1, \\dots, w_{L-1} \\rangle$ 建模，它是一个尝试的系统调用标识符序列。\n\n模拟根据轨迹执行评估四个指标：\n-   $C$：在白名单 $\\mathcal{A}$ 中的已执行系统调用计数。\n-   $B$：$W$ 中第一个不在 $\\mathcal{A}$ 中的系统调用的索引。如果 $W$ 中的所有调用都被允许，则 $B = -1$。\n-   $E$：一个二元指示器，如果任何已执行的系统调用同时也是有害集合 $\\mathcal{H}$ 的成员，则 $E = 1$，否则 $E = 0$。已执行的调用是指在白名单 $\\mathcal{A}$ 中的调用。\n-   $S$：遏制成功的二元指示器，定义为若 $E=0$ 则 $S = 1$，若 $E=1$ 则 $S = 0$。这等价于 $S = 1 - E$。\n\n每个测试用例的模拟算法如下：\n\n1.  初始化状态变量：\n    -   允许执行计数：$C = 0$。\n    -   有害逃逸指示器：$E = 0$。\n    -   阻塞索引：$B = -1$。\n\n2.  从索引 $i=0$ 到 $L-1$（其中 $L$ 是轨迹的长度）遍历工作负载轨迹 $W$。这实现了**完全中介**原则，因为每个调用都被检查。\n\n3.  对于索引 $i$ 处的每个系统调用标识符 $w_i$：\n    a.  检查其是否为白名单 $\\mathcal{A}$ 的成员。此步骤强制执行**最小权限**原则。\n    b.  如果 $w_i \\in \\mathcal{A}$：\n        i.  调用被允许。增加已执行计数：$C \\leftarrow C + 1$。\n        ii. 检查是否有害。如果 $w_i \\in \\mathcal{H}$，设置有害逃逸指示器：$E \\leftarrow 1$。\n        iii. 继续处理轨迹中的下一个系统调用 $w_{i+1}$。\n    c.  如果 $w_i \\notin \\mathcal{A}$：\n        i.  调用被阻塞。执行**失效-停止**策略。\n        ii. 设置阻塞索引：$B \\leftarrow i$。\n        iii. 立即终止当前轨迹的模拟。对于 $j  i$ 的后续调用 $w_j$ 不再处理。\n\n4.  循环终止后（无论是因完成轨迹还是因失效-停止）：\n    a.  如果循环完成而没有发生失效-停止，则保留初始值 $B=-1$，这正确地表明没有调用被阻塞。\n    b.  计算遏制成功：$S \\leftarrow 1 - E$。\n\n这个确定性算法被应用于六个指定的测试用例中的每一个。实现需要一个辅助函数来检查一个整数是否存在于给定的集合中（表示为数组）。最终输出被构造成单行，其中包含每个测试用例的四元组 $[S, C, B, E]$ 列表。",
            "answer": "[[1,2,2,0],[1,0,0,0],[0,4,-1,1],[1,2,2,0],[1,0,-1,0],[0,2,2,1]]"
        }
    ]
}