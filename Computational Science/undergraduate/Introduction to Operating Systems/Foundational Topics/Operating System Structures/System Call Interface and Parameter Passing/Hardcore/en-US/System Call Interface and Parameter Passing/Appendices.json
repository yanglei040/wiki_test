{
    "hands_on_practices": [
        {
            "introduction": "System calls form the fundamental conversation between a user program and the operating system kernel. However, this dialogue is not always simple; a request is not always fulfilled in its entirety in one go. This first practice explores the common scenario of a \"partial write,\" where the `write` system call reports that it has written fewer bytes than requested, a standard behavior for I/O operations. Mastering the logic to handle this outcome is essential for writing robust programs that ensure data integrity without sending duplicate data, a cornerstone skill in systems programming .",
            "id": "3686250",
            "problem": "A user-space program on a system conforming to the Portable Operating System Interface (POSIX) issues the `write` system call to transfer a contiguous message from a buffer in memory to a file descriptor. The system call interface on the prevalent Application Binary Interface (ABI) for a widely used 64-bit architecture passes arguments such that the buffer pointer and byte count are provided as the second and third arguments, respectively. The operating system kernel may legally complete fewer bytes than requested and return the number of bytes actually written as a nonnegative value.\n\nStarting from the core definitions that (i) the `write` system call returns the number of bytes actually written, and (ii) pointer arithmetic on a byte-addressable buffer of element type character advances by one byte per unit increment, derive how to adjust the arguments for the next `write` system call to avoid re-sending bytes that have already been written in the case of a partial success.\n\nConcretely, suppose the program initially passes buffer pointer $p = 0x7\\mathrm{fff}00001000$ and length $n = 4096$ bytes to write, and the kernel returns $k = 1723$ with $0 < k < n$. For the subsequent `write` system call intended to transmit only the remaining bytes, compute the two argument values that should be placed into the buffer pointer register and the length register, respectively, expressed as exact integers. Provide your final answer as a single row matrix containing the updated buffer pointer followed by the updated length, with both entries written exactly. No rounding is needed and no units are required in the final answer.",
            "solution": "The user-space program's objective is to write a total of $n$ bytes from a memory buffer starting at address $p$. The `write` system call is invoked with these parameters. The system call returns a value, $k$, indicating that only the first $k$ bytes of the buffer were successfully written. This scenario, where $0 \\le k < n$, is known as a partial write or a short write and is a standard, documented behavior for this system call, particularly when writing to entities like pipes, sockets, or a disk with limited space.\n\nTo complete the data transfer, the program must issue one or more subsequent `write` calls to transmit the remaining data. The problem asks for the correct arguments for the very next call, which should attempt to send the portion of the data that was not sent in the first attempt.\n\nLet the initial buffer pointer be $p$ and the initial number of bytes to write be $n$. The given values are:\n- $p = 0x7\\mathrm{fff}00001000$ (a 64-bit memory address represented in hexadecimal)\n- $n = 4096$ bytes\nThe system call returns $k = 1723$, indicating that $1723$ bytes were written. Since $0 < 1723 < 4096$, this is a partial write.\n\nThe first $k$ bytes of the buffer, located at memory addresses from $p$ to $p + k - 1$, have been successfully transferred. The remaining data consists of the bytes from offset $k$ to the end of the original buffer.\n\nThe task is to determine the new buffer pointer, $p'$, and the new length, $n'$, for the subsequent `write` call.\n\n1.  **Calculating the New Buffer Pointer ($p'$)**:\n    The remaining data segment begins immediately after the first $k$ bytes that were written. The starting address of this segment is therefore at an offset of $k$ bytes from the original starting address $p$.\n    The problem states that \"pointer arithmetic on a byte-addressable buffer... advances by one byte per unit increment.\" This formalizes the standard behavior of pointer arithmetic in C-like languages for pointers to character types (e.g., `char*`) or void pointers (`void*`), which are typically used for raw memory buffers. Adding an integer $k$ to such a pointer yields a new pointer that is offset by $k$ bytes in memory.\n    Therefore, the new buffer pointer $p'$ is calculated as:\n    $$p' = p + k$$\n    We are given $p = 0x7\\mathrm{fff}00001000$ and $k = 1723$. The addition must be performed. It is conventional in systems programming to represent memory addresses in hexadecimal and perform arithmetic in this base. To do so, we first convert the decimal integer $k$ to its hexadecimal equivalent.\n    - $1723 \\div 16 = 107$ with a remainder of $11$ (which is $\\mathrm{B}_{16}$).\n    - $107 \\div 16 = 6$ with a remainder of $11$ (which is $\\mathrm{B}_{16}$).\n    - $6 \\div 16 = 0$ with a remainder of $6$.\n    Reading the remainders in reverse order of calculation gives $1723_{10} = 6\\mathrm{BB}_{16}$.\n    Now, we perform the hexadecimal addition:\n    $$p' = 0x7\\mathrm{fff}00001000_{16} + 6\\mathrm{BB}_{16} = 0x7\\mathrm{fff}000016\\mathrm{BB}_{16}$$\n    So, the updated buffer pointer argument is $0x7\\mathrm{fff}000016\\mathrm{BB}$.\n\n2.  **Calculating the New Length ($n'$)**:\n    The original request was to write $n$ bytes. Since $k$ bytes have already been written, the number of bytes remaining to be written is the original total less the amount completed.\n    Therefore, the new length $n'$ is:\n    $$n' = n - k$$\n    Substituting the given values:\n    $$n' = 4096 - 1723 = 2373$$\n    The updated length argument is $2373$ bytes.\n\nIn summary, for the subsequent call to `write` to transmit the rest of the message, the program should use a buffer pointer of $p' = 0x7\\mathrm{fff}000016\\mathrm{BB}$ and a length of $n' = 2373$. These are the two values to be placed into the appropriate registers as per the system's ABI.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0x7\\mathrm{fff}000016\\mathrm{BB} & 2373\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "Having seen how a user program must correctly react to the kernel, we now shift our focus to the kernel's perspective as the system's ultimate gatekeeper. A system call is a controlled entry into a privileged execution context, and the kernel must assume that all user-supplied parameters could be incorrect or even malicious. This exercise delves into a critical security task: validating a user-supplied memory region, defined by a starting address and a length, to prevent attacks that exploit integer overflow and wrap-around. By analyzing different validation strategies, you will learn to think adversarially and design defenses that are provably sound, a core element of building secure and stable operating systems .",
            "id": "3686254",
            "problem": "An operating system kernel implements a system call that takes a user-space pointer and a length, denoted by the pair $\\big(addr, len\\big)$. The kernel must validate the arguments before invoking a user-to-kernel copy routine such as copyin to ensure that the entire half-open interval $\\big[addr, addr + len\\big)$ lies within the permitted user-space region. Assume the following fundamental base:\n\n- Addresses and lengths are represented as unsigned $n$-bit integers, with arithmetic performed modulo $2^n$.\n- The permitted user-space region is the half-open interval $\\big[0, L\\big)$, where $L$ is an implementation-defined limit with $0 < L \\le 2^n$.\n- The kernel must reject any input for which $\\big[addr, addr + len\\big)$ is not a subset of $\\big[0, L\\big)$, including the case where $addr + len$ wraps around modulo $2^n$.\n\nConsider a scenario on a $n = 64$ architecture with $L$ a proper subset of $[0, 2^{64})$, and a malicious user passes $addr$ near $2^{64} - 1$ together with a nonzero $len$ so that the computed $addr + len$ wraps around modulo $2^{64}$ to a small value. The kernel seeks a validation strategy that is provably sound: it must detect any integer overflow in computing $addr + len$ prior to invoking copyin and reject any interval that escapes the user-space boundary.\n\nWhich of the following validation strategies are sound under the stated model? Select all that apply.\n\nA. Accept if $addr < L$ and $len \\le L - addr$.\n\nB. Accept if $addr < L$ and $(addr + len) \\le L$, where the sum is computed in unsigned $n$-bit arithmetic modulo $2^n$.\n\nC. Accept if $addr < L$, compute $end = addr + len$ in unsigned $n$-bit arithmetic modulo $2^n$, reject if $end < addr$, otherwise accept only if $end \\le L$.\n\nD. Cast $addr$ and $len$ to signed $n$-bit integers and accept if $(addr + len) \\ge addr$ and $(addr + len) \\le L$ using signed arithmetic.\n\nE. Promote $addr$ and $len$ to a strictly wider unsigned integer type of width $n' \\ge n + 1$ bits, compute $end = addr + len$ without wrap-around in that wider type, and accept only if $addr < L$ and $end \\le L$.",
            "solution": "The problem asks to identify sound validation strategies for a user-provided memory interval $(addr, len)$ against a permitted user-space region $[0, L)$. The arithmetic is unsigned $n$-bit, which implies wrap-around (modulo $2^n$). A sound strategy must ensure the entire interval $[addr, addr + len)$ is a subset of $[0, L)$, correctly handling potential integer overflows.\n\nA sound validation must satisfy three conditions:\n1. The start address `addr` must be within the valid region: $addr  L$.\n2. The sum `addr + len` must not overflow the $n$-bit integer representation. An overflow occurs if the mathematical sum is $\\ge 2^n$.\n3. The end of the interval, `addr + len`, must be within the region's boundary: $addr + len \\le L$.\n\nLet's evaluate each option based on these criteria.\n\n**A. Accept if $addr  L$ and $len \\le L - addr$.**\nThis approach is sound. The first check, $addr  L$, correctly establishes the starting point. The second check, $len \\le L - addr$, is a rearrangement of the inequality $addr + len \\le L$. Since the first check guarantees $addr  L$, the subtraction $L - addr$ does not underflow in unsigned arithmetic and gives the correct mathematical result. This single inequality cleverly combines the overflow check and the boundary check. If an overflow were to occur (i.e., mathematical sum $addr + len \\ge 2^n$), then $len \\ge 2^n - addr$. Since $L \\le 2^n$, it follows that $L - addr \\le 2^n - addr$. For an overflow to occur, $len$ must be at least $2^n - addr$. If $L  2^n$, then $L-addr  2^n-addr$, so the check $len \\le L-addr$ would correctly fail. If $L = 2^n$, overflow means $len \\ge 2^n - addr$, and the check $len \\le 2^n - addr$ would only pass for the single non-overflowing case where $len = 2^n - addr$. Thus, this method correctly rejects all overflowing inputs that would lead out of bounds. Verdict: **Correct**.\n\n**B. Accept if $addr  L$ and $(addr + len) \\le L$, where the sum is computed in unsigned $n$-bit arithmetic modulo $2^n$.**\nThis strategy is unsound because it fails to detect overflow. Consider a malicious input where `addr` is large and `len` is chosen such that `addr + len` wraps around. For example, let $n=64$, $L = 2^{64}-100$, $addr = 2^{64}-10$, and $len = 20$.\n1. $addr  L$ is false ($2^{64}-10$ is not less than $2^{64}-100$). Let's pick a better example: $L = 0xF00...0$, $addr = 0xE00...0$, $len = 0x300...0$.\nLet's use the example from the problem. Let $n=64$, $L=2^{64}-5$, $addr=2^{64}-10$, and $len=20$.\n1. $addr  L$: True ($2^{64}-10  2^{64}-5$).\n2. The sum $(addr+len)$ computed with wrap-around is $(2^{64}-10) + 20 \\pmod{2^{64}} = 10$.\n3. Check $(addr+len) \\le L$: True ($10 \\le 2^{64}-5$).\nThe check passes, but the intended memory range spans from $2^{64}-10$ to the end of memory and wraps around, which is not contained in $[0, L)$. Verdict: **Incorrect**.\n\n**C. Accept if $addr  L$, compute $end = addr + len$ in unsigned $n$-bit arithmetic modulo $2^n$, reject if $end  addr$, otherwise accept only if $end \\le L$.**\nThis strategy is sound. It explicitly checks for the three required conditions.\n1. $addr  L$: Correctly checks the start boundary.\n2. `reject if end  addr`: This is the standard method for detecting unsigned integer overflow (assuming `len` is positive, which it must be for an overflow). If $len=0$, $end=addr$, and the check correctly doesn't trigger.\n3. `accept only if end \\le L`: If no overflow occurred, `end` is the true mathematical sum, and this check correctly validates the end boundary.\nThis sequence of checks is logically complete and robust. Verdict: **Correct**.\n\n**D. Cast `addr` and `len` to signed $n$-bit integers and accept if $(addr + len) \\ge addr$ and $(addr + len) \\le L$ using signed arithmetic.**\nThis approach is fundamentally flawed. Casting large unsigned addresses (where the most significant bit is 1) to signed types turns them into negative numbers, making comparisons nonsensical. Furthermore, signed integer overflow is undefined behavior in C/C++, making any strategy that relies on it non-portable and unsound. This method fails to handle the semantics of memory addressing correctly. Verdict: **Incorrect**.\n\n**E. Promote `addr` and `len` to a strictly wider unsigned integer type of width $n' \\ge n + 1$ bits, compute $end = addr + len$ without wrap-around in that wider type, and accept only if $addr  L$ and $end \\le L$.**\nThis strategy is sound. By promoting the numbers to a wider type (e.g., 128-bit for 64-bit addresses), the sum `addr + len` can be computed without any possibility of wrap-around. The resulting `end` is the true mathematical sum. The subsequent checks, $addr  L$ and $end \\le L$, are then performed on values that represent their true mathematical quantities, making the validation straightforward and correct. This method directly checks that the true interval $[addr, addr+len]$ is contained within $[0, L]$. Verdict: **Correct**.\n\nFinal selection includes the sound strategies.",
            "answer": "$$\\boxed{ACE}$$"
        },
        {
            "introduction": "Our final practice introduces the complexities of concurrency, where parameter validity becomes a moving target. In a multithreaded process, a check that is valid at one moment can be invalidated by another thread an instant later, creating a dangerous window for error. This exercise tackles the classic Time-of-Check-to-Time-of-Use (TOCTOU) race condition, using the example of a file descriptor that is checked for validity but then closed by another thread before it can be used. This problem challenges you to evaluate modern synchronization protocols that make parameter lookup and use an atomic operation, introducing you to the advanced techniques required to build correct and highly scalable concurrent systems .",
            "id": "3686201",
            "problem": "A multithreaded process uses a per-process file descriptor table that maps an integer descriptor $fd$ to a kernel file object $F$. The operating system maintains a reference count $ref(F)$ on each file object. A system call, denoted $\\mathrm{do\\_op}(fd, \\dots)$, first checks that $fd$ is in range and present in the caller’s descriptor table, and then uses the corresponding file object $F$ to perform the operation. Another thread in the same process may concurrently invoke `close(fd)`, which removes the $fd \\rightarrow F$ mapping and decrements $ref(F)$; when $ref(F)$ reaches $0$, $F$ becomes reclaimable.\n\nConsider the classic time-of-check-to-time-of-use window: thread $T_1$ enters $\\mathrm{do\\_op}(fd, \\dots)$ and validates $fd$, while thread $T_2$ concurrently executes `close(fd)`. Between validation and first use of $F$, $T_2$ may remove the mapping and potentially allow $fd$ to be reused for a different file object $F'$, creating a use-after-free or wrong-object hazard.\n\nFrom the following candidate designs, choose all that implement a file descriptor reference acquisition protocol that is atomic with respect to `close(fd)` at system call entry, satisfies the correctness property “either fail with an error if $fd$ is not valid at entry, or return a stable reference to exactly the file object $F$ that was mapped at entry and prevent its reclamation until release,” and preserves scalability by keeping the critical section minimal and not serializing unrelated system calls.\n\nA. At system call entry, acquire the process’s file descriptor table lock, verify $0 \\le fd  N$ and that the entry points to a non-null file object $F$, increment $ref(F)$ while still holding the lock, then drop the lock. Proceed with the system call using $F$, and later decrement $ref(F)$ when done. If the entry is null, return an error (for example, `-EBADF`).\n\nB. Disable preemption and interrupts on the calling central processing unit (CPU) while validating $fd$ and fetching $F$, then re-enable them before using $F$. Assume that preventing context switches makes the window small enough to ignore.\n\nC. Copy the integer $fd$ from user space into kernel memory at system call entry and validate its range. Use this kernel copy later when accessing the descriptor table, without any further synchronization, since the kernel copy cannot be altered by user space.\n\nD. Use Read-Copy-Update (RCU) for the descriptor table: enter an RCU read-side critical section, read the table entry to get pointer $F$ and a per-entry generation counter $g$, then attempt an atomic increment of $ref(F)$ (for example, via a compare-and-swap on $ref(F)$) to “pin” $F$. After the increment succeeds, re-read the generation counter as $g'$ and check $g' = g$. If equal, exit the RCU read-side critical section and proceed with $F$; if not, drop the reference to $F$ and retry on a slow path that takes the table lock. If the entry is empty, return an error. When the system call completes, decrement $ref(F)$.\n\nE. Serialize descriptor operations by taking a single global mutex across the entire duration of every system call that uses an $fd$ (from entry through completion), and also for every `close(fd)`. Within this mutex, validate and fetch $F$ and then perform the operation; release the mutex at the end.\n\nSelect all correct choices.",
            "solution": "The problem describes a classic time-of-check-to-time-of-use (TOCTOU) race condition in the context of file descriptor management within a multithreaded process. The goal is to identify synchronization protocols that can atomically look up a file descriptor $fd$, acquire a stable reference to the underlying file object $F$, and prevent its premature reclamation, while also maintaining system scalability. A valid solution must satisfy two main properties:\n1.  **Correctness:** The operation must be atomic with respect to a concurrent `close(fd)`. It must either fail cleanly if the $fd$ is invalid at the time of the call, or it must secure a reference to the correct file object $F$ that was mapped at that time, ensuring $F$ is not reclaimed for the duration of the system call.\n2.  **Scalability:** The critical section must be minimal, and the solution must not needlessly serialize unrelated system calls, which would create a performance bottleneck.\n\nWe will now evaluate each candidate design against these criteria.\n\n### Option A Evaluation\nThis option proposes using a lock to protect the file descriptor table. The sequence of operations is:\n1.  Acquire the lock for the process's file descriptor table.\n2.  Validate the $fd$ and look up the corresponding file object $F$.\n3.  If valid, increment the reference count $ref(F)$.\n4.  Release the lock.\n5.  Proceed with the operation using $F$.\n6.  Decrement $ref(F)$ upon completion.\n\n**Correctness:** This design correctly solves the race condition. The lock ensures that the sequence of validating the $fd$, retrieving the pointer to $F$, and incrementing $ref(F)$ is atomic with respect to any other operation that modifies the file descriptor table, such as `close(fd)`. If thread $T_1$ (executing `do_op`) acquires the lock first, it will increment $ref(F)$ before releasing the lock. A subsequent `close(fd)` by thread $T_2$ will remove the $fd \\rightarrow F$ mapping and decrement $ref(F)$, but since $T_1$ holds a reference, $ref(F)$ will not drop to $0$, and the object $F$ will not be reclaimed. If $T_2$ acquires the lock first, it will remove the mapping. When $T_1$ subsequently acquires the lock, it will find that the $fd$ is invalid and correctly return an error (e.g., `-EBADF`). This satisfies the correctness property.\n\n**Scalability:** The lock is held for a very short duration—only long enough to perform a range check, a table lookup, and a reference count increment. This is a minimal critical section. The lock is specific to one process's file descriptor table, so it does not serialize system calls from different processes. While it does serialize concurrent file descriptor operations within the same process, this is often an acceptable trade-off and is far better than a global lock. The design thus preserves scalability to a reasonable degree.\n\n**Verdict:** **Correct**. This is a standard, robust, and widely-used solution.\n\n### Option B Evaluation\nThis option suggests disabling preemption and interrupts on the calling CPU to create an atomic-like section.\n\n**Correctness:** This approach is fundamentally flawed in a multiprocessor environment. Disabling preemption and interrupts on a single CPU core (let's say CPU$_0$) only prevents other threads from being scheduled on CPU$_0$. It does absolutely nothing to stop another thread, $T_2$, from running concurrently on a different core (e.g., CPU$_1$), acquiring any necessary locks for the `close` operation, modifying the shared file descriptor table, and causing the very race condition we are trying to prevent. The assumption that this makes the window \"small enough to ignore\" is a dangerous reliance on timing rather than a guarantee of correctness, and it is false on any modern multi-core system.\n\n**Scalability:** The scalability is irrelevant as the method is incorrect.\n\n**Verdict:** **Incorrect**. This fails to provide the required atomicity on multiprocessor systems, which are standard today.\n\n### Option C Evaluation\nThis option proposes copying the integer $fd$ from user space to kernel space and then using this kernel copy.\n\n**Correctness:** This proposal misunderstands the nature of the TOCTOU vulnerability. The problem is not that the user-space program might maliciously change the value of the variable holding the file descriptor number *after* the kernel has read it. The problem is that the state of the *shared kernel data structure* (the file descriptor table) can be changed by another kernel-level thread of execution (e.g., $T_2$ running `close(fd)`) between the time $T_1$ checks the table and the time it uses the result of that check. Copying the integer $fd$ into kernel memory does nothing to synchronize access to the file descriptor table itself. Thread $T_1$ can read the kernel copy of $fd$, validate it, but before it can use the associated file object $F$, thread $T_2$ can close the $fd$, leading to a use-after-free or wrong-object-use bug.\n\n**Scalability:** The scalability is irrelevant as the method is incorrect.\n\n**Verdict:** **Incorrect**. It fails to address the actual concurrency issue.\n\n### Option D Evaluation\nThis option describes a lock-free optimistic approach using Read-Copy-Update (RCU) and a generation counter.\n\n**Correctness:** This is a sophisticated and correct design.\n1.  Entering an RCU read-side critical section prevents the file descriptor table structure itself from being freed while the reader is traversing it.\n2.  The reader fetches the pointer to $F$ and a generation counter $g$. The generation counter is incremented by any writer (a `close` or `dup2` operation) that modifies this specific table entry.\n3.  The reader attempts to \"pin\" the file object by atomically incrementing its reference count, $ref(F)$.\n4.  The crucial step is to re-read the generation counter as $g'$ and verify that $g' = g$. If they are equal, it means no writer has modified this specific $fd$ entry between the initial read and the successful pinning of $F$. The reader has acquired a stable reference to the correct object and can proceed.\n5.  If $g' \\neq g$, a race with a writer occurred. The reader's reference is potentially on a stale object, so it must undo its action (decrement $ref(F)$) and retry, typically via a \"slow path\" that uses a conventional lock (as in Option A).\nThis protocol correctly ensures that the reader either obtains a stable reference to the object that was present at the call's entry or safely detects the race and retries.\n\n**Scalability:** This design is highly scalable. The fast path for readers involves no locking, only RCU primitives and atomic operations, which are very efficient. This allows many concurrent system calls (`do_op`) to proceed in parallel without blocking each other. Writers (`close`) would need to take a lock to update the table and the generation counter, but in many workloads, reads are far more common than writes, making this an excellent optimization. This design explicitly minimizes the critical section and avoids serializing unrelated calls.\n\n**Verdict:** **Correct**. This is a valid, high-performance solution used in advanced operating systems.\n\n### Option E Evaluation\nThis option proposes serializing all file-descriptor-related system calls using a single global mutex held for the entire duration of the call.\n\n**Correctness:** This would indeed prevent the race condition. By serializing all operations that touch file descriptors, it removes all concurrency, and thus the TOCTOU hazard cannot occur. The validation of $fd$ and the use of $F$ would happen under the exclusive protection of the global mutex.\n\n**Scalability:** This solution is catastrophically poor for scalability. It serializes not only related operations within a process but *all* file descriptor operations across the *entire system*. A thread in one process performing a long, blocking `read()` on a pipe would prevent a thread in a completely unrelated process from opening a new file. This directly violates the requirement to \"preserve scalability by keeping the critical section minimal and not serializing unrelated system calls.\" Holding a lock for the duration of a potentially blocking I/O operation is a major design flaw in kernel development.\n\n**Verdict:** **Incorrect**. It fails the scalability requirement in the most extreme way possible.",
            "answer": "$$\\boxed{AD}$$"
        }
    ]
}