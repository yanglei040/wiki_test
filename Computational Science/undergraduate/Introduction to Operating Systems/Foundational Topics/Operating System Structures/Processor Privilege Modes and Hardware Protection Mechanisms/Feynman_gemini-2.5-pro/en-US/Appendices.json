{
    "hands_on_practices": [
        {
            "introduction": "Understanding hardware protection begins with the ability to trace the CPU's logic step-by-step. This exercise presents a hypothetical but realistic security scenario: a kernel that, due to a bug, fails to validate a user-provided pointer before using it. By reasoning through the sequence of hardware checks from first principles, you will develop a precise mental model of how features like privilege levels, the MMU, SMAP, and SMEP work in concert to enforce system integrity. ",
            "id": "3673118",
            "problem": "A $64$-bit Central Processing Unit (CPU) implements two privilege modes with Current Privilege Level (CPL) $3$ for user mode and CPL $0$ for kernel mode, virtual memory with $4$-level page tables, and the User/Supervisor ($U/S$) bit in each Page Table Entry (PTE). The system enables Supervisor Mode Access Prevention (SMAP), Supervisor Mode Execution Prevention (SMEP), and sets the write-protect bit in control register 0 (CR0.WP). The operating system maps all user-space pages with $U/S = 1$ and all kernel-only pages with $U/S = 0$. Consider a process in user mode (CPL $3$) that invokes a system call via the SYSCALL instruction, passing a single pointer argument stored in a general-purpose register. The pointer value is a canonical virtual address that lies in the kernel half of the address space and maps to a present, readable kernel data page with $U/S = 0$. Due to a bug, the kernel entry path immediately dereferences this pointer to read $8$ bytes before performing any software validation or address sanitation.\n\nFrom first principles about privilege modes, virtual address translation, and hardware protection mechanisms, reason about the exact sequence of hardware checks that are exercised from the moment the system call is invoked until the dereference completes or faults. Which option best describes what hardware checks will be exercised and whether they will fault in this scenario?\n\nA. The system call entry hardware validates user arguments and rejects pointers to supervisor memory; SYSCALL raises a fault before switching to CPL $0$.\n\nB. The CPU switches to CPL $0$ normally; on dereference in supervisor mode, the Memory Management Unit (MMU) enforces a canonical-address check and performs a page-table walk. Because the target PTE is present, readable, and has $U/S = 0$, the access is permitted in supervisor mode. Neither SMAP nor SMEP causes a fault. A page fault would occur only for non-present or disallowed access types.\n\nC. SMAP raises a fault at dereference because the pointer originated from user space, regardless of the $U/S$ bit on the target page.\n\nD. SMEP raises a fault at dereference because the kernel is about to use a user-provided address that points into kernel space.\n\nE. A segmentation limit check on the user data segment triggers at dereference because the address lies outside the user segment, preventing the access.",
            "solution": "The user has provided a problem concerning CPU privilege modes, virtual memory, and hardware protection mechanisms. I will first validate the problem statement and then proceed to a detailed solution.\n\n### Step 1: Extract Givens\n\n-   **CPU Architecture:** $64$-bit Central Processing Unit (CPU).\n-   **Privilege Modes:** $2$ modes implemented. Current Privilege Level (CPL) $3$ for user mode and CPL $0$ for kernel mode.\n-   **Memory Management:** Virtual memory with $4$-level page tables. Each Page Table Entry (PTE) contains a User/Supervisor ($U/S$) bit.\n-   **Hardware Protections Enabled:**\n    1.  Supervisor Mode Access Prevention (SMAP).\n    2.  Supervisor Mode Execution Prevention (SMEP).\n    3.  The write-protect bit in control register 0 (CR0.WP) is set.\n-   **Operating System Policy:**\n    -   All user-space pages are mapped with the PTE $U/S$ bit set to $1$ ($U/S = 1$).\n    -   All kernel-only pages are mapped with the PTE $U/S$ bit set to $0$ ($U/S = 0$).\n-   **Scenario:**\n    1.  A process is executing in user mode (CPL $3$).\n    2.  It invokes a system call via the `SYSCALL` instruction.\n    3.  It passes a single pointer argument in a general-purpose register.\n    4.  The pointer value is a canonical virtual address that lies in the kernel half of the address space.\n    5.  This virtual address maps to a page that is present, readable, and has PTE attributes with $U/S = 0$.\n    6.  The kernel code, due to a bug, immediately dereferences this pointer to perform an $8$-byte read, without prior software validation.\n\n### Step 2: Validate Using Extracted Givens\n\nThe problem statement describes a realistic scenario on a modern x86-64 processor. The specified features—CPLs $0$ and $3$, $4$-level paging, the $U/S$ bit, SMAP, SMEP, CR0.WP, and the `SYSCALL` instruction—are all standard components of this architecture. The described scenario, where the kernel mishandles a pointer supplied by user-space, represents a common class of security vulnerabilities. The problem is scientifically grounded, well-posed, and objective. It provides sufficient information for a deterministic analysis based on processor architecture principles. There are no contradictions, ambiguities, or factual inaccuracies.\n\n### Step 3: Verdict and Action\n\nThe problem statement is **valid**. A step-by-step derivation of the outcome is possible based on the provided hardware configuration.\n\n### Derivation of the Correct Answer\n\nThe analysis must proceed chronologically from the invocation of the system call.\n\n**1. `SYSCALL` Instruction Execution:**\nA process running at CPL $3$ executes the `SYSCALL` instruction. The hardware purpose of `SYSCALL` is to provide a fast transition to a predefined kernel entry point at CPL $0$. It saves a minimal user-mode context (e.g., instruction pointer `RIP` and flags `RFLAGS`) and loads a minimal kernel-mode context (e.g., a new `RIP` and stack pointer `RSP` from model-specific registers). Critically, the `SYSCALL` instruction hardware **does not** perform any validation on the contents of general-purpose registers, which are used for passing arguments like the pointer in this scenario. Therefore, the transition from CPL $3$ to CPL $0$ occurs successfully, and control is transferred to the kernel's system call handler. The potentially malicious pointer value is now available to the kernel code, which is executing at CPL $0$.\n\n**2. Pointer Dereference in Kernel Mode (CPL $0$):**\nThe problem states the kernel immediately attempts to read $8$ bytes from the address specified by the user-provided pointer. This constitutes a data read access while the CPU is in supervisor mode (CPL $0$). We must analyze the hardware checks that the Memory Management Unit (MMU) and associated protection logic will perform for this access.\n\n-   **Canonical Address Check:** The problem explicitly states the pointer is a \"canonical virtual address\". In $64$-bit mode, virtual addresses must have bits $63$ through $47$ all identical (either all $0$s for the user-space half or all $1$s for the kernel-space half). Since the address is canonical, this initial check passes. An attempt to use a non-canonical address would have resulted in a general-protection fault (#GP).\n\n-   **Page Table Walk and Basic Permissions:** The MMU performs a $4$-level page table walk to translate the virtual address. The problem states the address maps to a \"present, readable kernel data page with $U/S=0$\".\n    -   **Present Bit:** The page is present, so a page fault (#PF) for a non-present page does not occur.\n    -   **Access Type:** The access is a read, and the page is readable. No fault occurs due to access permissions (e.g., trying to write to a read-only page).\n    -   **Privilege Level ($U/S$ bit):** The access is initiated from CPL $0$ (supervisor mode). The target page's PTE has the $U/S$ bit set to $0$, which explicitly reserves the page for supervisor-only access. An access from CPL $0$ to a page with $U/S=0$ is always permitted by this fundamental check.\n\n-   **CR0.WP (Write-Protect) Check:** The CR0.WP bit, when set, prevents the supervisor from writing to read-only pages. This scenario involves a *read* operation, not a write. Therefore, the state of CR0.WP is irrelevant to the outcome of this specific access and will not cause a fault.\n\n-   **SMEP (Supervisor Mode Execution Prevention) Check:** SMEP is enabled. It prevents the supervisor (CPL $< 3$) from *fetching instructions* (executing code) from any page marked as user-accessible ($U/S=1$). The operation in this problem is a *data read*, not an instruction fetch. Thus, SMEP does not apply and will not cause a fault.\n\n-   **SMAP (Supervisor Mode Access Prevention) Check:** SMAP is enabled. It prevents the supervisor (CPL $< 3$) from performing *data accesses* (reads or writes) to any page marked as user-accessible ($U/S=1$). The core condition for SMAP to trigger a fault is an access to a page with $U/S=1$. In this problem, the target page is explicitly defined as having $U/S=0$. Therefore, the condition for a SMAP-induced fault is not met. SMAP does not track the origin of the pointer value; it only checks the privilege level of the access and the attributes of the target page. The access is from CPL $0$ to a $U/S=0$ page, which SMAP allows.\n\n-   **Segmentation Checks:** In $64$-bit long mode, segmentation is largely vestigial for memory protection. For the flat memory model used by modern operating systems, data segment registers (DS, ES, SS) have their base address fixed at $0$ and limit checks are not performed on data accesses. Protection is enforced by the paging mechanism. Thus, no segmentation fault will occur.\n\n**Conclusion of Hardware Checks:**\nAll hardware checks will pass. The `SYSCALL` instruction will successfully transition to CPL $0$. The subsequent dereference is a read from CPL $0$ to an address that translates to a present, readable, supervisor-only ($U/S=0$) page. None of the enabled advanced protection mechanisms (SMAP, SMEP, CR0.WP) are applicable to this specific access. The $8$-byte read will complete successfully from a hardware perspective, demonstrating a security flaw in the kernel's software logic.\n\n### Evaluation of Options\n\n-   **A. The system call entry hardware validates user arguments and rejects pointers to supervisor memory; SYSCALL raises a fault before switching to CPL $0$.**\n    This is **Incorrect**. The `SYSCALL` hardware mechanism is designed for speed and does not validate arguments passed in registers. This responsibility falls upon the OS software handler.\n\n-   **B. The CPU switches to CPL $0$ normally; on dereference in supervisor mode, the Memory Management Unit (MMU) enforces a canonical-address check and performs a page-table walk. Because the target PTE is present, readable, and has $U/S = 0$, the access is permitted in supervisor mode. Neither SMAP nor SMEP causes a fault. A page fault would occur only for non-present or disallowed access types.**\n    This is **Correct**. This option accurately describes the sequence of events as derived above. The system call succeeds, the CPL becomes $0$, and the subsequent access from CPL $0$ to a $U/S=0$ page is permitted by the MMU. SMAP and SMEP are not triggered because their specific conditions (access to a $U/S=1$ page) are not met.\n\n-   **C. SMAP raises a fault at dereference because the pointer originated from user space, regardless of the $U/S$ bit on the target page.**\n    This is **Incorrect**. SMAP's behavior depends critically on the $U/S$ bit of the target page. It triggers on supervisor access to *user pages* ($U/S=1$). The statement \"regardless of the $U/S$ bit\" is false. Since the target page has $U/S = 0$, SMAP does not fault.\n\n-   **D. SMEP raises a fault at dereference because the kernel is about to use a user-provided address that points into kernel space.**\n    This is **Incorrect**. SMEP relates to *execution prevention*, not data access prevention. Furthermore, it prevents execution on *user pages* ($U/S=1$), not kernel pages. This option is wrong on both counts.\n\n-   **E. A segmentation limit check on the user data segment triggers at dereference because the address lies outside the user segment, preventing the access.**\n    This is **Incorrect**. In $64$-bit mode, protection for data accesses is almost exclusively handled by paging, not segmentation. Segment limit checks are not performed for data accesses in the standard flat memory model.",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "Building on a conceptual understanding of hardware checks, this practice moves into the realm of implementation. A kernel must carefully manage protection features like Supervisor Mode Execution Prevention (SMEP) and Supervisor Mode Access Prevention (SMAP), enabling and disabling them only when absolutely necessary and for the briefest possible time. This exercise challenges you to simulate this process by modeling the correct toggling sequence for safe user memory access and quantifying the security risk when this logic is flawed, providing a concrete understanding of how software bugs can create dangerous vulnerabilities. ",
            "id": "3673113",
            "problem": "You are to mathematically model, simulate, and evaluate a minimal operating system kernel’s handling of processor privilege mode protection features by surrounding user memory accesses with explicit toggling of Supervisor Mode Execution Prevention (SMEP) and Supervisor Mode Access Prevention (SMAP). The core objective is to derive, from first principles, safe and unsafe conditions and then implement a precise state-machine simulation that exposes the consequences when toggling is performed incorrectly.\n\nFundamental base and core definitions to use:\n- A processor has a Current Privilege Level (CPL) that is either user mode or supervisor mode. In this problem, the kernel runs in supervisor mode. Represent supervisor mode as $p=\\mathrm{S}$ and user mode as $p=\\mathrm{U}$.\n- Memory regions are classified into user and kernel. Represent the region type as $r \\in \\{\\mathrm{user}, \\mathrm{kernel}\\}$.\n- The processor enforces Supervisor Mode Execution Prevention (SMEP), modeled as a bit $b_{\\mathrm{SMEP}} \\in \\{0,1\\}$, where $b_{\\mathrm{SMEP}}=1$ enables SMEP and $b_{\\mathrm{SMEP}}=0$ disables SMEP.\n- The processor enforces Supervisor Mode Access Prevention (SMAP), modeled as a bit $b_{\\mathrm{SMAP}} \\in \\{0,1\\}$, where $b_{\\mathrm{SMAP}}=1$ enables SMAP and $b_{\\mathrm{SMAP}}=0$ disables SMAP.\n- The Alignment Check flag (AC) in the processor state can be used to temporarily allow supervisor-mode access to user memory under SMAP; model it as $b_{\\mathrm{AC}} \\in \\{0,1\\}$, where $b_{\\mathrm{AC}}=1$ allows supervisor-mode data accesses to user pages despite SMAP and $b_{\\mathrm{AC}}=0$ blocks them under SMAP.\n- The kernel uses page permissions such that executing code from a user page while in supervisor mode is forbidden by SMEP when $b_{\\mathrm{SMEP}}=1$, and reading or writing user memory while in supervisor mode is forbidden by SMAP when $b_{\\mathrm{SMAP}}=1$ and $b_{\\mathrm{AC}}=0$.\n\nModel the permit function as a predicate that, given $p$, an operation $o$, a region $r$, and bits ($b_{\\mathrm{SMEP}}$, $b_{\\mathrm{SMAP}}$, $b_{\\mathrm{AC}}$), determines whether the access would be allowed by hardware:\n- For execution: If $p=\\mathrm{S}$, $o=\\mathrm{execute}$, $r=\\mathrm{user}$, and $b_{\\mathrm{SMEP}}=1$, then the access is not permitted; otherwise it is permitted.\n- For data read or write: If $p=\\mathrm{S}$, $o \\in \\{\\mathrm{read}, \\mathrm{write}\\}$, $r=\\mathrm{user}$, $b_{\\mathrm{SMAP}}=1$, and $b_{\\mathrm{AC}}=0$, then the access is not permitted; otherwise it is permitted.\n- For any $p=\\mathrm{U}$, accesses to user memory are permitted (user mode is not constrained by SMEP and SMAP in the same way), and accesses to kernel memory are not considered in this problem.\n\nThe minimal kernel policy to implement in the simulation:\n- Around every user memory data access (read or write), the kernel toggles bits only for the duration of that access. Concretely: it sets $b_{\\mathrm{AC}} \\leftarrow 1$ immediately before the access and then $b_{\\mathrm{AC}} \\leftarrow 0$ immediately after; it also disables supervisor-mode execution prevention only around the data access by setting $b_{\\mathrm{SMEP}} \\leftarrow 0$ immediately before the access and then $b_{\\mathrm{SMEP}} \\leftarrow 1$ immediately after. The global configuration keeps $b_{\\mathrm{SMAP}}=1$.\n- Wrong toggling is characterized by any of the following deviations: failing to clear $b_{\\mathrm{AC}}$ after the access, failing to re-enable $b_{\\mathrm{SMEP}}$ after the access, or disabling $b_{\\mathrm{SMEP}}$ too early (a specified number of timeline steps before the actual user memory access). These deviations introduce windows in which unintended operations could occur.\n\nRisk definition from first principles:\n- Define a risk counter $R$ that counts unsafe events that would have been prevented by correct toggling but become permitted under wrong toggling.\n- An unsafe event increments $R$ if and only if its access would be permitted by the current bits ($b_{\\mathrm{SMEP}}$, $b_{\\mathrm{SMAP}}$, $b_{\\mathrm{AC}}$) under supervisor mode $p=\\mathrm{S}$, and the event corresponds to either unintended supervisor execution from a user-region function pointer or unintended supervisor data access to user memory.\n\nOperations to be simulated (each step happens in supervisor mode $p=\\mathrm{S}$):\n- Map integers to operation tags as follows (the integers in the list are the codes to be used by your program):\n  - $0$: read user memory (intended user data access).\n  - $1$: write user memory (intended user data access).\n  - $2$: attempt to execute a user-space function pointer (unintended execution).\n  - $3$: stray read from user memory (unintended data access).\n  - $4$: interrupt handler that performs a stray read from user memory (unintended data access inside an interrupt).\n  - $5$: interrupt handler that tries to execute a user-space function pointer (unintended execution inside an interrupt).\n  - $6$: read kernel memory (benign).\n  - $7$: execute kernel code (benign).\n\nSimulation rules to implement:\n- Initialize $b_{\\mathrm{SMEP}}=1$, $b_{\\mathrm{SMAP}}=1$, $b_{\\mathrm{AC}}=0$, $p=\\mathrm{S}$, and $R=0$.\n- At each step, before handling the current operation, check whether there is a forthcoming user data access (an operation with code $0$ or $1$). If the wrong-toggling parameter “early disable steps” equals $k$ with $k>0$, then when the current timeline index equals the index of that forthcoming access minus $k$, apply $b_{\\mathrm{SMEP}} \\leftarrow 0$ early. This early window persists until $b_{\\mathrm{SMEP}}$ is re-enabled by a later correct action or remains disabled if re-enabling is incorrectly omitted.\n- When handling a user data access ($0$ or $1$), apply the minimal kernel policy: set $b_{\\mathrm{AC}} \\leftarrow 1$ and $b_{\\mathrm{SMEP}} \\leftarrow 0$ immediately before the access. After the access, if “wrong clear AC” is $1$, leave $b_{\\mathrm{AC}}$ at $1$; otherwise set $b_{\\mathrm{AC}} \\leftarrow 0$. If “wrong re-enable SMEP” is $1$, leave $b_{\\mathrm{SMEP}}$ at $0$; otherwise set $b_{\\mathrm{SMEP}} \\leftarrow 1$.\n- When handling unintended execution events ($2$ or $5$), increment $R$ if and only if $b_{\\mathrm{SMEP}}=0$ (since with $b_{\\mathrm{SMEP}}=1$ such execution would be blocked).\n- When handling unintended user data access events ($3$ or $4$), increment $R$ if and only if $b_{\\mathrm{SMAP}}=1$ and $b_{\\mathrm{AC}}=1$ (since with $b_{\\mathrm{AC}}=0$ such access would be blocked by SMAP).\n- Benign kernel events ($6$ and $7$) do not affect $R$.\n\nTest suite:\nFor each test case, the parameters are a triple $(w_{\\mathrm{AC}}, w_{\\mathrm{SMEP}}, k)$ where $w_{\\mathrm{AC}} \\in \\{0,1\\}$ flags “wrong clear AC” after user access, $w_{\\mathrm{SMEP}} \\in \\{0,1\\}$ flags “wrong re-enable SMEP” after user access, and $k \\in \\mathbb{Z}_{\\ge 0}$ is the number of early-disable steps for $b_{\\mathrm{SMEP}}$. Each test also includes a fixed operation sequence.\n\n- Test case $1$ (happy path):\n  - Parameters: $(w_{\\mathrm{AC}}, w_{\\mathrm{SMEP}}, k)=(0,0,0)$.\n  - Sequence: $[6,0,7,2,6]$.\n  - Expected behavior: correct toggling yields no unsafe execution or data access.\n\n- Test case $2$ (wrong clear AC after user access):\n  - Parameters: $(w_{\\mathrm{AC}}, w_{\\mathrm{SMEP}}, k)=(1,0,0)$.\n  - Sequence: $[0,3,7]$.\n  - Expected behavior: leaving $b_{\\mathrm{AC}}=1$ after the intended user read allows a stray user read; precisely one unsafe data access.\n\n- Test case $3$ (both wrong: SMEP left disabled and AC left set; interrupts interleave):\n  - Parameters: $(w_{\\mathrm{AC}}, w_{\\mathrm{SMEP}}, k)=(1,1,0)$.\n  - Sequence: $[0,5,4,2]$.\n  - Expected behavior: user access leaves $b_{\\mathrm{SMEP}}=0$ and $b_{\\mathrm{AC}}=1$, allowing unintended execution and data access in the interrupt, and a subsequent unintended execution; three unsafe events.\n\n- Test case $4$ (boundary early disable of SMEP):\n  - Parameters: $(w_{\\mathrm{AC}}, w_{\\mathrm{SMEP}}, k)=(0,0,2)$.\n  - Sequence: $[6,2,6,0,7]$.\n  - Expected behavior: $b_{\\mathrm{SMEP}}$ is disabled two steps before the user access, creating an early window during which an unintended execution occurs; one unsafe event.\n\nYour task:\n- Implement a complete, runnable program that deterministically simulates the above state machine for the provided test suite.\n- For each test case, compute the final risk count $R$ as defined.\n- Output specification: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test cases, for example $[r_1,r_2,r_3,r_4]$ where each $r_i$ is the integer risk count for test case $i$.\n\nNo input should be read. No physical units or angles are involved. All risk counts are integers.",
            "solution": "The problem is valid. It is scientifically grounded in the principles of modern processor hardware protection mechanisms, specifically Supervisor Mode Execution Prevention (SMEP) and Supervisor Mode Access Prevention (SMAP). The problem is well-posed, providing a complete set of deterministic rules for a state-machine simulation, an unambiguous objective, and a clear definition of all terms and parameters. The setup is self-contained, consistent, and requires no external information.\n\nThe task is to simulate a state machine that models a simplified operating system kernel's interaction with hardware security features. The state of the system is defined by a set of control bits: $b_{\\mathrm{SMEP}}$, $b_{\\mathrm{SMAP}}$, and $b_{\\mathrm{AC}}$. The simulation evolves over a discrete timeline, processing a sequence of operations. The goal is to compute a risk counter, $R$, which quantifies the number of unsafe operations permitted due to incorrect handling of these control bits.\n\nThe core principles being modeled are:\n$1$. **Principle of Least Privilege**: The kernel, running in a high-privilege supervisor mode ($p=\\mathrm{S}$), should not execute code from or access data in lower-privilege user memory ($r=\\mathrm{user}$) unless explicitly intended.\n$2$. **Hardware Enforcement**: SMEP and SMAP are hardware features that enforce this separation. SMEP, when enabled ($b_{\\mathrm{SMEP}}=1$), blocks the supervisor from executing user-space code. SMAP, when enabled ($b_{\\mathrm{SMAP}}=1$), blocks the supervisor from accessing user-space data.\n$3$. **Explicit Policy Override**: For legitimate operations, like copying data to or from a user process, the kernel must temporarily and explicitly bypass these protections. The model represents this bypass for data access by setting the Alignment Check flag ($b_{\\mathrm{AC}} \\leftarrow 1$), which the hardware interprets as an override for SMAP. The bypass for potential execution is modeled by disabling SMEP ($b_{\\mathrm{SMEP}} \\leftarrow 0$).\n\nThe simulation logic is designed to precisely implement the state transitions and risk assessment rules provided.\n\n**State Variables:**\n- $b_{\\mathrm{SMEP}} \\in \\{0,1\\}$: The SMEP enable bit.\n- $b_{\\mathrm{SMAP}} \\in \\{0,1\\}$: The SMAP enable bit, which is globally fixed to $b_{\\mathrm{SMAP}}=1$.\n- $b_{\\mathrm{AC}} \\in \\{0,1\\}$: The AC flag for SMAP override.\n- $R \\in \\mathbb{Z}_{\\ge 0}$: The cumulative risk counter.\n\n**Initial State:** For each test case, the simulation begins with the secure default configuration: $b_{\\mathrm{SMEP}}=1$, $b_{\\mathrm{SMAP}}=1$, $b_{\\mathrm{AC}}=0$, and $R=0$. The processor is in supervisor mode, $p=\\mathrm{S}$, throughout the simulation.\n\n**State Transition Logic:**\nThe simulation proceeds step-by-step through a given operation sequence. At each step $i$ with operation $o_i$, the state is updated according to the following logic, executed in order:\n\n$1$. **Early SMEP Disable Check**: Per the problem, we must check for an early disable condition. If the \"early disable steps\" parameter is $k > 0$, we search for the index $j \\ge i$ of the next operation that is an intended user data access (code $0$ or $1$). If such an operation exists at index $j$, and if the current step index $i$ is equal to $j-k$, we apply the pre-emptive state change $b_{\\mathrm{SMEP}} \\leftarrow 0$. This models a programming error where a security feature is disabled prematurely.\n\n$2$. **Intended Access Toggling (Before)**: If the current operation $o_i$ is an intended user data access (code $0$ or $1$), the correct kernel policy dictates an immediate, temporary override. The state is updated just before the access: $b_{\\mathrm{AC}} \\leftarrow 1$ and $b_{\\mathrm{SMEP}} \\leftarrow 0$.\n\n$3$. **Risk Assessment**: After any preliminary state changes, the risk of the current operation $o_i$ is evaluated. a risk is incurred if an unintended, privileged operation on user memory becomes permitted.\n    - For an unintended execution attempt ($o_i \\in \\{2, 5\\}$), the access is permitted if and only if SMEP is disabled ($b_{\\mathrm{SMEP}}=0$). If this condition holds, the risk counter is incremented: $R \\leftarrow R+1$.\n    - For an unintended data access attempt ($o_i \\in \\{3, 4\\}$), the access is permitted if and only if the SMAP override is active ($b_{\\mathrm{AC}}=1$, given $b_{\\mathrm{SMAP}}=1$). If this condition holds, the risk counter is incremented: $R \\leftarrow R+1$.\n    - Benign operations ($o_i \\in \\{6, 7\\}$) and intended user data accesses ($o_i \\in \\{0, 1\\}$) do not increment the risk counter.\n\n$4$. **Intended Access Toggling (After)**: If the current operation $o_i$ was an intended user data access, the kernel policy requires restoring the secure state. This step models potential errors in the restoration logic.\n    - If the \"wrong clear AC\" parameter $w_{\\mathrm{AC}}$ is $0$, the override is correctly removed: $b_{\\mathrm{AC}} \\leftarrow 0$. If $w_{\\mathrm{AC}}=1$, this step is skipped, leaving $b_{\\mathrm{AC}}=1$.\n    - If the \"wrong re-enable SMEP\" parameter $w_{\\mathrm{SMEP}}$ is $0$, SMEP is correctly re-enabled: $b_{\\mathrm{SMEP}} \\leftarrow 1$. If $w_{\\mathrm{SMEP}}=1$, this step is skipped, leaving $b_{\\mathrm{SMEP}}=0$.\n\nThis sequence of logic is applied for every operation in the test case's sequence. The final value of $R$ is the result for that test case. The implementation will consist of a function that encapsulates this state machine, which is then called for each of the four test cases defined in the problem. The final output is a list of the resulting $R$ values.",
            "answer": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n// Note: As per the rules, complex.h, threads.h, and stdatomic.h are not used.\n// The included headers suffice for this problem.\n\n// Operation codes as defined in the problem statement.\n// 0: read user memory (intended user data access).\n// 1: write user memory (intended user data access).\n// 2: attempt to execute a user-space function pointer (unintended execution).\n// 3: stray read from user memory (unintended data access).\n// 4: interrupt handler that performs a stray read from user memory (unintended data access).\n// 5: interrupt handler that tries to execute a user-space function pointer (unintended execution).\n// 6: read kernel memory (benign).\n// 7: execute kernel code (benign).\n\n// A struct to hold the parameters for a single test case.\ntypedef struct {\n    int w_ac;                 // \"wrong clear AC\" flag\n    int w_smep;               // \"wrong re-enable SMEP\" flag\n    int k;                    // \"early disable steps\" for SMEP\n    const int* op_sequence;   // Pointer to the operation sequence\n    int seq_len;              // Length of the sequence\n} TestCase;\n\n// Simulates a single test case and returns the final risk count R.\nint run_simulation(const TestCase* tc) {\n    // Initialize state variables\n    int b_smep = 1;\n    int b_smap = 1; // This is constant throughout the simulation\n    int b_ac = 0;\n    int R = 0;\n\n    // Main simulation loop over the operation sequence\n    for (int i = 0; i < tc->seq_len; ++i) {\n        \n        // 1. Check for early SMEP disable\n        if (tc->k > 0) {\n            int next_user_access_idx = -1;\n            // Find the index of the next user data access (op 0 or 1)\n            for (int j = i; j < tc->seq_len; ++j) {\n                if (tc->op_sequence[j] == 0 || tc->op_sequence[j] == 1) {\n                    next_user_access_idx = j;\n                    break;\n                }\n            }\n            \n            // If a forthcoming access exists and the timeline matches, disable SMEP early\n            if (next_user_access_idx != -1) {\n                if (i == next_user_access_idx - tc->k) {\n                    b_smep = 0;\n                }\n            }\n        }\n\n        int current_op = tc->op_sequence[i];\n        int is_intended_user_data_access = (current_op == 0 || current_op == 1);\n        \n        // 2. Toggling for intended access (before the access)\n        if (is_intended_user_data_access) {\n            b_ac = 1;\n            b_smep = 0;\n        }\n\n        // 3. Risk assessment for the current operation\n        switch (current_op) {\n            case 2: // Unintended execution\n            case 5: // Unintended execution in interrupt\n                if (b_smep == 0) {\n                    R++;\n                }\n                break;\n            case 3: // Unintended data access\n            case 4: // Unintended data access in interrupt\n                if (b_smap == 1 && b_ac == 1) {\n                    R++;\n                }\n                break;\n            // Benign ops (0, 1, 6, 7) do not increment risk\n            default:\n                break;\n        }\n\n        // 4. Toggling for intended access (after the access)\n        if (is_intended_user_data_access) {\n            if (tc->w_ac == 0) { // Correct behavior: clear AC\n                b_ac = 0;\n            }\n            if (tc->w_smep == 0) { // Correct behavior: re-enable SMEP\n                b_smep = 1;\n            }\n        }\n    }\n    \n    return R;\n}\n\nint main(void) {\n    // Define the operation sequences for the test suite.\n    const int seq1[] = {6, 0, 7, 2, 6};\n    const int seq2[] = {0, 3, 7};\n    const int seq3[] = {0, 5, 4, 2};\n    const int seq4[] = {6, 2, 6, 0, 7};\n\n    // Define the test cases from the problem statement.\n    TestCase test_cases[] = {\n        {0, 0, 0, seq1, sizeof(seq1) / sizeof(seq1[0])}, // Test case 1\n        {1, 0, 0, seq2, sizeof(seq2) / sizeof(seq2[0])}, // Test case 2\n        {1, 1, 0, seq3, sizeof(seq3) / sizeof(seq3[0])}, // Test case 3\n        {0, 0, 2, seq4, sizeof(seq4) / sizeof(seq4[0])}  // Test case 4\n    };\n\n    // Calculate the number of test cases.\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    int results[num_cases];\n\n    // Calculate the result for each test case.\n    for (int i = 0; i < num_cases; ++i) {\n        results[i] = run_simulation(&test_cases[i]);\n    }\n\n    // Print the results in the EXACT REQUIRED format before the final return statement.\n    printf(\"[\");\n    for (int i = 0; i < num_cases; ++i) {\n        printf(\"%d\", results[i]);\n        if (i < num_cases - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\\n\");\n\n    return EXIT_SUCCESS;\n}\n```"
        },
        {
            "introduction": "Secure systems must also be performant, and hardware protection mechanisms have an associated performance cost. When a privileged instruction is attempted in user mode, the resulting hardware fault is not an instantaneous event; it consumes valuable CPU cycles. This final practice guides you to build a quantitative model from first principles, calculating the expected latency of such a fault by accounting for both deterministic hardware actions and probabilistic micro-architectural effects like cache misses, thus translating abstract security events into concrete performance metrics. ",
            "id": "3673091",
            "problem": "A single Central Processing Unit (CPU) with two privilege modes (user mode and kernel mode) enforces hardware protection by generating a synchronous exception when a privileged instruction is attempted in user mode. The exception handling path is well understood: hardware detects the violation, flushes the pipeline, consults a trap vector, switches to a privileged stack and mode, executes a handler body, and then returns to the original context. The operating system must be modeled from first principles using cycle accounting and probability to estimate the expected latency of these fault-driven exceptions.\n\nYou must write a complete, runnable program that computes the expected fault latency when a privileged instruction is intentionally executed in user mode, along with the fraction of that latency attributable to the handler’s body. The calculation must start from basic definitions: aggregation of deterministic cycle costs for each micro-action in the exception path and use of the linearity of expectation for stochastic micro-architectural effects. The expected latency must be converted to time using the CPU frequency. All results must be derived in purely mathematical terms.\n\nFundamental base for derivation:\n- Privilege enforcement definition: attempting a privileged instruction in user mode causes a synchronous exception (a trap).\n- Cycle accounting: total cycles for a sequence of actions equals the sum of each action’s cycle cost.\n- Linearity of expectation: for independent events with probabilities, the expected additional cycles equal the probability multiplied by the event’s cycle penalty, summed across events.\n- Frequency-to-time relation: if an event takes $L$ cycles on a CPU with frequency $f$ in $\\mathrm{Hz}$, then the time in seconds is $t = \\dfrac{L}{f}$.\n\nModel definitions and variables:\n- Deterministic cycle costs per fault attempt: pipeline flush $C_f$, privilege violation detection $C_d$, trap entry work $C_e$, handler body $C_h$, and return-from-trap $C_x$.\n- Stochastic penalties: Translation Lookaside Buffer miss probability $p_T$ with penalty $C_T$, instruction cache miss probability $p_I$ with penalty $C_I$, scheduler involvement probability $p_S$ with penalty $C_S$, and the probability of a nested privileged fault within the handler $p_N$ with nested sub-costs $C_{Nd}$, $C_{Ne}$, $C_{Nh}$, $C_{Nx}$.\n- CPU frequency $f$ in $\\mathrm{Hz}$.\n- Expected fault latency in cycles $L$ is the sum of the deterministic path cycles and the expected stochastic penalties.\n- Handler share fraction $H$ is the fraction of $L$ attributable to the handler body, including any nested handler body cycles, specifically $(C_h + p_N \\cdot C_{Nh})$ divided by the total $L$.\n\nYour program must implement these computations for each provided test case and produce a single line of output with results aggregated for all cases.\n\nUnits and output specification:\n- Convert cycles to time in nanoseconds. If $L$ cycles and frequency $f$ in $\\mathrm{Hz}$ are given, compute nanoseconds as $L \\cdot \\dfrac{10^9}{f}$.\n- Express all outputs as decimal floats.\n- For each test case, output three values in order: expected cycles $L$, expected time in nanoseconds, and handler share fraction $H$. Print floats with exactly $6$ digits after the decimal point.\n- Final output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered by test case and metric, that is, $[L_1,\\mathrm{ns}_1,H_1,L_2,\\mathrm{ns}_2,H_2,\\ldots]$.\n\nTest suite:\n- Test case $1$ (happy path):\n  - $f = 3.2 \\times 10^9\\,\\mathrm{Hz}$, $C_f = 100$, $C_d = 12$, $C_e = 350$, $C_h = 220$, $C_x = 180$,\n  - $p_T = 0.05$, $C_T = 80$, $p_I = 0.10$, $C_I = 160$, $p_S = 0.02$, $C_S = 1500$, $p_N = 0.01$,\n  - $C_{Nd} = 12$, $C_{Ne} = 350$, $C_{Nh} = 100$, $C_{Nx} = 180$.\n- Test case $2$ (boundary: no stochastic penalties, zero handler body):\n  - $f = 5.0 \\times 10^9\\,\\mathrm{Hz}$, $C_f = 80$, $C_d = 10$, $C_e = 300$, $C_h = 0$, $C_x = 150$,\n  - $p_T = 0$, $C_T = 100$, $p_I = 0$, $C_I = 200$, $p_S = 0$, $C_S = 0$, $p_N = 0$,\n  - $C_{Nd} = 0$, $C_{Ne} = 0$, $C_{Nh} = 0$, $C_{Nx} = 0$.\n- Test case $3$ (worst-case heavy penalties):\n  - $f = 1.0 \\times 10^9\\,\\mathrm{Hz}$, $C_f = 200$, $C_d = 20$, $C_e = 600$, $C_h = 800$, $C_x = 400$,\n  - $p_T = 1.0$, $C_T = 200$, $p_I = 1.0$, $C_I = 300$, $p_S = 0.5$, $C_S = 4000$, $p_N = 0.3$,\n  - $C_{Nd} = 20$, $C_{Ne} = 600$, $C_{Nh} = 500$, $C_{Nx} = 400$.\n- Test case $4$ (edge: high frequency, small costs):\n  - $f = 10.0 \\times 10^9\\,\\mathrm{Hz}$, $C_f = 50$, $C_d = 8$, $C_e = 200$, $C_h = 90$, $C_x = 90$,\n  - $p_T = 0.01$, $C_T = 60$, $p_I = 0.01$, $C_I = 100$, $p_S = 0$, $C_S = 0$, $p_N = 0$,\n  - $C_{Nd} = 0$, $C_{Ne} = 0$, $C_{Nh} = 0$, $C_{Nx} = 0$.\n- Test case $5$ (handler always triggers nested fault and scheduler):\n  - $f = 0.5 \\times 10^9\\,\\mathrm{Hz}$, $C_f = 150$, $C_d = 15$, $C_e = 400$, $C_h = 300$, $C_x = 250$,\n  - $p_T = 0.2$, $C_T = 120$, $p_I = 0.2$, $C_I = 180$, $p_S = 1.0$, $C_S = 2000$, $p_N = 1.0$,\n  - $C_{Nd} = 15$, $C_{Ne} = 400$, $C_{Nh} = 150$, $C_{Nx} = 250$.\n\nYour program must compute the outputs for all test cases and print them in the exact required final output format on a single line.",
            "solution": "The problem is valid as it is scientifically grounded in the principles of computer architecture and operating systems, is well-posed with a complete and consistent set of definitions and data, and is expressed in objective, formalizable language.\n\nThe objective is to compute the expected fault latency in cycles ($L$), the corresponding time in nanoseconds ($t_{ns}$), and the fraction of latency attributable to the handler body ($H$) for a privileged instruction fault. The solution is derived from first principles of cycle accounting and probability theory.\n\nFirst, we formulate the expression for the total expected fault latency, $L$. The problem states that $L$ is the sum of deterministic cycle costs and expected stochastic penalties. This is a direct application of the linearity of expectation, $E[X+Y] = E[X] + E[Y]$.\n\nThe deterministic path consists of a sequence of micro-actions, and by the principle of cycle accounting, its total cost is the sum of the costs of its components. Let $L_{det}$ be the deterministic latency.\n$$\nL_{det} = C_f + C_d + C_e + C_h + C_x\n$$\nwhere $C_f$ is the pipeline flush cost, $C_d$ is the violation detection cost, $C_e$ is the trap entry cost, $C_h$ is the handler body execution cost, and $C_x$ is the return-from-trap cost.\n\nThe stochastic part of the latency, $L_{stoch}$, arises from probabilistic events. The expected cost of a probabilistic event is its probability multiplied by its cycle penalty. Using linearity of expectation, the total expected stochastic cost is the sum of the expected costs of each independent event. The stochastic events are:\n$1$. Translation Lookaside Buffer (TLB) miss: occurs with probability $p_T$ and incurs a penalty of $C_T$ cycles. The expected cost is $p_T C_T$.\n$2$. Instruction cache miss: occurs with probability $p_I$ and incurs a penalty of $C_I$ cycles. The expected cost is $p_I C_I$.\n$3$. Scheduler involvement: occurs with probability $p_S$ and incurs a penalty of $C_S$ cycles. The expected cost is $p_S C_S$.\n$4$. Nested privileged fault: occurs within the handler with probability $p_N$. The cost of this nested fault is the sum of its own micro-action costs: detection ($C_{Nd}$), entry ($C_{Ne}$), handler body ($C_{Nh}$), and return ($C_{Nx}$). The total cost of a single nested fault event is $C_{N,event} = C_{Nd} + C_{Ne} + C_{Nh} + C_{Nx}$. The expected cost added to the total latency is therefore $p_N (C_{Nd} + C_{Ne} + C_{Nh} + C_{Nx})$.\n\nThe total expected stochastic latency, $L_{stoch_E}$, is the sum of these expected penalties:\n$$\nL_{stoch_E} = p_T C_T + p_I C_I + p_S C_S + p_N (C_{Nd} + C_{Ne} + C_{Nh} + C_{Nx})\n$$\n\nThe total expected fault latency, $L$, is the sum of the deterministic and expected stochastic components:\n$$\nL = L_{det} + L_{stoch_E} = (C_f + C_d + C_e + C_h + C_x) + p_T C_T + p_I C_I + p_S C_S + p_N(C_{Nd} + C_{Ne} + C_{Nh} + C_{Nx})\n$$\n\nSecond, we determine the time in nanoseconds, $t_{ns}$. Given a CPU frequency $f$ in Hertz ($\\mathrm{Hz}$), the time in seconds for an event taking $L$ cycles is $t_s = L/f$. To convert this to nanoseconds, we multiply by $10^9$:\n$$\nt_{ns} = \\frac{L}{f} \\times 10^9\n$$\n\nThird, we formulate the handler share fraction, $H$. The problem defines this as the fraction of the total expected latency $L$ attributable to the handler body activities. This includes the deterministic execution of the primary handler body, $C_h$, and the expected cost of the nested handler body, which is $p_N C_{Nh}$. The total expected cycles for handler bodies is $L_{H\\_body} = C_h + p_N C_{Nh}$. The fraction $H$ is this value divided by the total expected latency $L$:\n$$\nH = \\frac{C_h + p_N C_{Nh}}{L}\n$$\n\nThese three equations for $L$, $t_{ns}$, and $H$ will be systematically applied to each test case to compute the required results.",
            "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n// #include <complex.h>\n// #include <threads.h>\n// #include <stdatomic.h>\n\n// A struct to hold the parameters for a single test case.\ntypedef struct {\n    double f;\n    double Cf, Cd, Ce, Ch, Cx;\n    double pT, CT;\n    double pI, CI;\n    double pS, CS;\n    double pN, CNd, CNe, CNh, CNx;\n} TestCase;\n\nint main(void) {\n    // Define the test cases from the problem statement.\n    TestCase test_cases[] = {\n        {\n            .f = 3.2e9, .Cf = 100, .Cd = 12, .Ce = 350, .Ch = 220, .Cx = 180,\n            .pT = 0.05, .CT = 80, .pI = 0.10, .CI = 160, .pS = 0.02, .CS = 1500, .pN = 0.01,\n            .CNd = 12, .CNe = 350, .CNh = 100, .CNx = 180\n        },\n        {\n            .f = 5.0e9, .Cf = 80, .Cd = 10, .Ce = 300, .Ch = 0, .Cx = 150,\n            .pT = 0, .CT = 100, .pI = 0, .CI = 200, .pS = 0, .CS = 0, .pN = 0,\n            .CNd = 0, .CNe = 0, .CNh = 0, .CNx = 0\n        },\n        {\n            .f = 1.0e9, .Cf = 200, .Cd = 20, .Ce = 600, .Ch = 800, .Cx = 400,\n            .pT = 1.0, .CT = 200, .pI = 1.0, .CI = 300, .pS = 0.5, .CS = 4000, .pN = 0.3,\n            .CNd = 20, .CNe = 600, .CNh = 500, .CNx = 400\n        },\n        {\n            .f = 10.0e9, .Cf = 50, .Cd = 8, .Ce = 200, .Ch = 90, .Cx = 90,\n            .pT = 0.01, .CT = 60, .pI = 0.01, .CI = 100, .pS = 0, .CS = 0, .pN = 0,\n            .CNd = 0, .CNe = 0, .CNh = 0, .CNx = 0\n        },\n        {\n            .f = 0.5e9, .Cf = 150, .Cd = 15, .Ce = 400, .Ch = 300, .Cx = 250,\n            .pT = 0.2, .CT = 120, .pI = 0.2, .CI = 180, .pS = 1.0, .CS = 2000, .pN = 1.0,\n            .CNd = 15, .CNe = 400, .CNh = 150, .CNx = 250\n        }\n    };\n\n    // Calculate the number of test cases.\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    \n    // Print the results in the EXACT REQUIRED format before the final return statement\n    printf(\"[\");\n    for (int i = 0; i < num_cases; ++i) {\n        TestCase tc = test_cases[i];\n\n        // Calculate expected fault latency in cycles (L)\n        double L_det = tc.Cf + tc.Cd + tc.Ce + tc.Ch + tc.Cx;\n        double L_stoch_E = tc.pT * tc.CT + tc.pI * tc.CI + tc.pS * tc.CS + \n                           tc.pN * (tc.CNd + tc.CNe + tc.CNh + tc.CNx);\n        double L = L_det + L_stoch_E;\n\n        // Calculate expected time in nanoseconds (t_ns)\n        double t_ns = (L / tc.f) * 1e9;\n\n        // Calculate handler share fraction (H)\n        double H = (tc.Ch + tc.pN * tc.CNh) / L;\n        if (L == 0) { // Avoid division by zero, though not expected with given data\n             H = 0;\n        }\n\n        // Print results for the current test case\n        printf(\"%.6f,%.6f,%.6f\", L, t_ns, H);\n\n        // Add a comma if it's not the last test case\n        if (i < num_cases - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\");\n\n    return EXIT_SUCCESS;\n}\n```"
        }
    ]
}