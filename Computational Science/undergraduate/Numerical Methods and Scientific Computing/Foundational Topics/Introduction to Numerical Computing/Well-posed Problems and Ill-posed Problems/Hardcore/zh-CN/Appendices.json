{
    "hands_on_practices": [
        {
            "introduction": "线性方程组是科学计算的基石，但当系统是“病态”的，即对输入数据的微小变化极其敏感时，求解过程会变得非常棘手。这个练习通过一个简单的 $2 \\times 2$ 例子，直观地展示了病态问题是如何违反稳定性条件的。你将亲手计算并看到，对测量数据一个极小的扰动，如何导致解发生巨大的变化，从而深刻理解适定性中连续依赖性准则的重要性。",
            "id": "2197153",
            "problem": "在许多科学和工程应用中，我们会遇到形式为 $Ax = b$ 的线性方程组，其中我们需要在给定矩阵 $A$ 和向量 $b$ 的情况下求解向量 $x$。向量 $b$ 通常代表测量值，而这些测量值会受到微小误差的影响。病态系统是指 $b$ 中的微小误差可能导致解 $x$ 中产生巨大误差的系统。\n\n考虑以下病态线性系统：\n$$\nA = \\begin{pmatrix} 1 & 1 \\\\ 1 & 1.001 \\end{pmatrix}\n$$\n我们首先考虑测量向量恰好为以下值的情况：\n$$\nb_{\\text{orig}} = \\begin{pmatrix} 2 \\\\ 2.001 \\end{pmatrix}\n$$\n对应的解向量为 $x_{\\text{orig}}$，满足 $A x_{\\text{orig}} = b_{\\text{orig}}$。\n\n现在，假设出现了一个微小的测量误差，导致产生了一个新的、受扰动的测量向量：\n$$\nb_{\\text{pert}} = \\begin{pmatrix} 2 \\\\ 2.002 \\end{pmatrix}\n$$\n新的解向量为 $x_{\\text{pert}}$，满足 $A x_{\\text{pert}} = b_{\\text{pert}}$。\n\n你的任务是量化测量向量中这个微小扰动的影响。计算解向量变化的幅度，该幅度由差值的欧几里得范数 $\\| x_{\\text{pert}} - x_{\\text{orig}} \\|_2$ 给出。将你的最终答案四舍五入到三位有效数字。",
            "solution": "我们使用 $x = A^{-1} b$ 求解这两个线性系统。对于一个 $2 \\times 2$ 矩阵 $A = \\begin{pmatrix} a & b \\\\ c & d \\end{pmatrix}$，其逆矩阵为 $A^{-1} = \\frac{1}{ad - bc} \\begin{pmatrix} d & -b \\\\ -c & a \\end{pmatrix}$。在本题中，\n$$\nA = \\begin{pmatrix} 1 & 1 \\\\ 1 & 1.001 \\end{pmatrix},\n\\quad \\det(A) = 1 \\cdot 1.001 - 1 \\cdot 1 = 0.001.\n$$\n因此，\n$$\nA^{-1} = \\frac{1}{0.001} \\begin{pmatrix} 1.001 & -1 \\\\ -1 & 1 \\end{pmatrix} = \\begin{pmatrix} 1001 & -1000 \\\\ -1000 & 1000 \\end{pmatrix}.\n$$\n对于 $b_{\\text{orig}} = \\begin{pmatrix} 2 \\\\ 2.001 \\end{pmatrix}$，\n$$\nx_{\\text{orig}} = A^{-1} b_{\\text{orig}} = \\begin{pmatrix} 1001 & -1000 \\\\ -1000 & 1000 \\end{pmatrix} \\begin{pmatrix} 2 \\\\ 2.001 \\end{pmatrix}\n= \\begin{pmatrix} 1001 \\cdot 2 - 1000 \\cdot 2.001 \\\\ -1000 \\cdot 2 + 1000 \\cdot 2.001 \\end{pmatrix}\n= \\begin{pmatrix} 2002 - 2001 \\\\ -2000 + 2001 \\end{pmatrix}\n= \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}.\n$$\n对于 $b_{\\text{pert}} = \\begin{pmatrix} 2 \\\\ 2.002 \\end{pmatrix}$，\n$$\nx_{\\text{pert}} = A^{-1} b_{\\text{pert}} = \\begin{pmatrix} 1001 & -1000 \\\\ -1000 & 1000 \\end{pmatrix} \\begin{pmatrix} 2 \\\\ 2.002 \\end{pmatrix}\n= \\begin{pmatrix} 1001 \\cdot 2 - 1000 \\cdot 2.002 \\\\ -1000 \\cdot 2 + 1000 \\cdot 2.002 \\end{pmatrix}\n= \\begin{pmatrix} 2002 - 2002 \\\\ -2000 + 2002 \\end{pmatrix}\n= \\begin{pmatrix} 0 \\\\ 2 \\end{pmatrix}.\n$$\n解的变化为\n$$\nx_{\\text{pert}} - x_{\\text{orig}} = \\begin{pmatrix} 0 \\\\ 2 \\end{pmatrix} - \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} -1 \\\\ 1 \\end{pmatrix},\n$$\n其欧几里得范数为\n$$\n\\|x_{\\text{pert}} - x_{\\text{orig}}\\|_{2} = \\sqrt{(-1)^{2} + 1^{2}} = \\sqrt{2}.\n$$\n将 $\\sqrt{2}$ 四舍五入到三位有效数字，得到 $1.41$。",
            "answer": "$$\\boxed{1.41}$$"
        },
        {
            "introduction": "从带噪声的数据中估算导数是许多领域中的一个基本任务，但它也是一个典型的不适定问题，因为它会不可避免地放大高频噪声。为了获得一个稳定且有意义的解，我们必须采用正则化技术，通过平滑数据来抑制噪声。这个练习将引导你分析一种正则化方法，推导一个在偏差和方差之间取得平衡的最优平滑宽度，并将其付诸实践，让你体验到理论分析在解决实际计算问题中的力量。",
            "id": "3286744",
            "problem": "您的任务是根据均匀采样且带噪声的观测值 $y_i = f(x_i) + \\epsilon_i$ 来估计导数 $f'(x_0)$。这些观测值位于网格 $x_i = x_0 + i \\,\\Delta x$上，其中噪声 $\\epsilon_i$ 是独立同分布的，均值为零，方差为 $\\sigma^2$。请使用 Jacques Hadamard 提出的适定性定义（解的存在性、唯一性以及对数据的连续依赖性），将数值微分问题构建为一个反问题，并通过证明高频噪声在微分过程中被放大来解释其为何是病态的。然后，为了稳定估计，请考虑以下用于 $f'(x_0)$ 的两步线性估计器：\n- 首先用宽度为 $h$ 的对称箱式（均匀）核平滑数据（因此平滑后的函数为 $f * K_h$，其中 $K_h$ 为偶函数且已归一化）。\n- 然后对平滑后的信号应用步长为 $\\Delta x$ 的中心差分公式。\n\n仅从以下基本事实出发：\n- 卷积的导数满足 $(f * K_h)' = f' * K_h$。\n- 对称、归一化的箱式核的二阶矩为 $\\mu_2(K_h) = h^2/12$。\n- 对 $m \\approx h/\\Delta x$ 个独立样本进行移动平均，可将方差减小 $m$ 倍，而对两个独立样本求差会使其方差相加。\n推导某点的主导阶均方误差，\n$$\n\\operatorname{MSE}(h) \\approx \\text{bias}^2(h) + \\text{var}(h),\n$$\n其中偏差由局部三阶导数 $f^{(3)}(x_0)$ 控制，方差由 $\\sigma^2$、$\\Delta x$ 和 $h$ 控制。证明最小化此渐近表达式可得到最优宽度\n$$\nh_\\star \\;=\\; \\left(\\frac{72\\,\\sigma^2}{\\Delta x\\,\\big(f^{(3)}(x_0)\\big)^2}\\right)^{1/5}.\n$$\n在实践中，$h$ 不能小于 $\\Delta x$，且不应超过用户根据域或趋势尺度考虑确定的最大值 $H_{\\max}$。此外，当 $\\lvert f^{(3)}(x_0)\\rvert$ 极小时，偏差可以忽略不计，最优宽度应饱和在 $H_{\\max}$。\n\n您的程序必须实现以下映射：\n$$\n(\\Delta x,\\;\\sigma,\\;H_{\\max},\\;x_0,\\;f)\\;\\longmapsto\\; h,\n$$\n使用以下规则：\n- 如果对于一个很小的阈值 $\\tau$，有 $\\lvert f^{(3)}(x_0)\\rvert \\le \\tau$，则设 $h = H_{\\max}$。\n- 否则，计算 $h_\\star = \\left(\\frac{72\\,\\sigma^2}{\\Delta x\\,[f^{(3)}(x_0)]^2}\\right)^{1/5}$ 并将其裁剪到 $[\\Delta x,\\;H_{\\max}]$ 范围内。\n\n角度应以弧度为单位。本问题不涉及物理单位。对于数值报告，将每个 $h$ 表示为四舍五入到小数点后六位的小数。\n\n测试套件。对于下方的每种情况，使用上述规则计算 $h$。每个函数 $f$ 都是光滑的，其三阶导数 $f^{(3)}$ 也已解析给出：\n- 情况 A：$f(x) = \\sin(x)$，因此 $f^{(3)}(x) = -\\cos(x)$。参数：$x_0 = 1.0$，$\\Delta x = 0.01$，$\\sigma = 0.02$，$H_{\\max} = 2.0$。\n- 情况 B：$f(x) = e^{x}$，因此 $f^{(3)}(x) = e^{x}$。参数：$x_0 = 0.0$，$\\Delta x = 0.005$，$\\sigma = 0.05$，$H_{\\max} = 2.0$。\n- 情况 C：$f(x) = x^3$，因此 $f^{(3)}(x) = 6$。参数：$x_0 = 0.2$，$\\Delta x = 0.1$，$\\sigma = 0.0001$，$H_{\\max} = 2.0$。\n- 情况 D：$f(x) = \\cos(5x)$，因此 $f^{(3)}(x) = 125\\,\\sin(5x)$。参数：$x_0 = 0.0$，$\\Delta x = 0.01$，$\\sigma = 0.1$，$H_{\\max} = 1.0$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个逗号分隔的四个计算出的 $h$ 值列表，按 A、B、C、D 的顺序排列，四舍五入到小数点后六位，并用方括号括起来，例如 `[h_A,h_B,h_C,h_D]`。",
            "solution": "经评估，问题陈述有效。它在科学上基于数值分析和反问题研究的原理，特别是病态问题的正则化。问题是适定的、自洽的，所有数据、定义和约束都已提供且相互一致。任务是首先为所用方法提供理论依据，然后基于推导出的结果实现一个特定算法。\n\n### 数值微分的病态性质\n\n从一组数据点中求函数 $f$ 的导数 $f'$ 的问题可以构建为一个反问题。设 $D$ 为微分算子，使得 $D(f) = f'$。我们的目标是在给定含噪数据 $y = f + \\epsilon$ 的情况下恢复 $f'$。将算子 $D$ 应用于数据，得到 $D(y) = D(f) + D(\\epsilon) = f' + \\epsilon'$。问题的关键在于噪声项 $D(\\epsilon) = \\epsilon'$ 的行为。\n\n根据 Jacques Hadamard 的理论，一个问题如果其解存在、唯一且连续依赖于输入数据，则该问题是适定的。数值微分违反了第三个准则。要理解这一点，可以考虑数据中的一个高频噪声分量，其形式为 $\\epsilon(x) = A \\sin(\\omega x)$，其中振幅 $A$ 很小，频率 $\\omega$ 很大。这个对函数 $f$ 的扰动大小最多为 $A$。然而，对导数 $f'$ 的扰动是 $\\epsilon'(x) = A \\omega \\cos(\\omega x)$，其大小为 $A\\omega$。通过选择一个足够大的频率 $\\omega$，即使数据中的误差 $A$ 无限小，导数中的误差 $A\\omega$ 也可以变得任意大。\n\n这表明解（导数）并不连续依赖于输入数据。输入中微小的高频扰动可以被放大为输出中任意大的扰动。因此，数值微分是一个病态问题。为了获得稳定且有意义的解，需要一种正则化技术，这通常涉及在微分前对数据进行平滑处理。\n\n### 正则化估计器的分析\n\n所提出的估计器通过先平滑数据再应用有限差分公式来对问题进行正则化。这两个步骤是：\n1.  使用宽度为 $h$ 的对称箱式（均匀）核 $K_h$ 平滑含噪数据 $y$。平滑后的信号为 $\\tilde{y} = y * K_h$。\n2.  对平滑后的信号 $\\tilde{y}$ 应用步长为 $\\Delta x$ 的中心差分公式，以近似 $x_0$ 处的导数。\n\n因此，$f'(x_0)$ 的估计器由下式给出：\n$$\n\\hat{f}'(x_0) = \\frac{\\tilde{y}(x_0 + \\Delta x) - \\tilde{y}(x_0 - \\Delta x)}{2 \\Delta x} = \\frac{(y * K_h)(x_0 + \\Delta x) - (y * K_h)(x_0 - \\Delta x)}{2 \\Delta x}\n$$\n此估计器的性能由其均方误差（$\\operatorname{MSE}$）来表征，该误差可以分解为偏差平方和方差之和：\n$$\n\\operatorname{MSE}(h) = \\text{bias}^2(h) + \\text{var}(h) = \\left( E[\\hat{f}'(x_0)] - f'(x_0) \\right)^2 + \\operatorname{Var}(\\hat{f}'(x_0))\n$$\n\n#### 偏差推导\n偏差是估计器的系统误差。由于噪声 $\\epsilon_i$ 的均值为零（$E[\\epsilon_i]=0$），估计器的期望值可以通过将其应用于无噪声函数 $f(x)$ 来找到：\n$$\nE[\\hat{f}'(x_0)] = \\frac{(f * K_h)(x_0 + \\Delta x) - (f * K_h)(x_0 - \\Delta x)}{2 \\Delta x}\n$$\n这是函数 $g(x) = (f * K_h)(x)$ 在 $x=x_0$ 处导数的中心差分近似。对于足够小的 $\\Delta x$，该表达式是 $g'(x_0)$ 的一个良好近似。利用给定的事实 $(f * K_h)' = f' * K_h$，我们有 $g'(x_0) = (f' * K_h)(x_0)$。中心差分公式本身引入的误差是 $O((\\Delta x)^2)$ 阶的，与平滑偏差相比被认为是高阶项，因此对于主导阶偏差，我们可以近似为 $E[\\hat{f}'(x_0)] \\approx (f' * K_h)(x_0)$。\n\n于是，偏差是期望平滑导数与真实导数之间的差：\n$$\n\\text{bias}(h) = E[\\hat{f}'(x_0)] - f'(x_0) \\approx (f' * K_h)(x_0) - f'(x_0)\n$$\n为了分析这一点，我们在卷积积分内将 $f'$ 在 $x_0$ 附近展开为泰勒级数：\n$$\n(f' * K_h)(x_0) = \\int_{-\\infty}^{\\infty} f'(x_0 - u) K_h(u) du \\approx \\int_{-\\infty}^{\\infty} \\left[ f'(x_0) - u f''(x_0) + \\frac{u^2}{2} f^{(3)}(x_0) \\right] K_h(u) du\n$$\n由于核 $K_h$ 是归一化的（$\\int K_h(u) du = 1$）和对称的（$\\int u K_h(u) du = 0$），上式简化为：\n$$\n(f' * K_h)(x_0) \\approx f'(x_0) \\int K_h(u) du - f''(x_0) \\int u K_h(u) du + \\frac{f^{(3)}(x_0)}{2} \\int u^2 K_h(u) du\n$$\n$$\n(f' * K_h)(x_0) \\approx f'(x_0) + \\frac{f^{(3)}(x_0)}{2} \\mu_2(K_h)\n$$\n其中 $\\mu_2(K_h)$ 是核的二阶矩。利用给定的事实 $\\mu_2(K_h) = h^2/12$，主导阶偏差为：\n$$\n\\text{bias}(h) \\approx \\frac{h^2}{24} f^{(3)}(x_0)\n$$\n因此，偏差的平方为：\n$$\n\\text{bias}^2(h) \\approx \\frac{h^4}{576} \\left(f^{(3)}(x_0)\\right)^2\n$$\n\n#### 方差推导\n估计器的方差捕捉了随机噪声 $\\epsilon_i$ 的影响。\n$$\n\\operatorname{Var}(\\hat{f}'(x_0)) = \\operatorname{Var}\\left( \\frac{(\\epsilon * K_h)(x_0 + \\Delta x) - (\\epsilon * K_h)(x_0 - \\Delta x)}{2 \\Delta x} \\right)\n$$\n令 $\\tilde{\\epsilon}(x) = (\\epsilon * K_h)(x)$ 为平滑后的噪声。方差为：\n$$\n\\operatorname{Var}(\\hat{f}'(x_0)) = \\frac{1}{4(\\Delta x)^2} \\operatorname{Var}\\left( \\tilde{\\epsilon}(x_0 + \\Delta x) - \\tilde{\\epsilon}(x_0 - \\Delta x) \\right)\n$$\n根据提供的提示，使用移动平均对 $m \\approx h/\\Delta x$ 个样本进行平滑，可将噪声方差从 $\\sigma^2$ 减小到 $\\sigma^2/m = \\sigma^2 \\Delta x / h$。\n因此，$\\operatorname{Var}(\\tilde{\\epsilon}(x)) \\approx \\sigma^2 \\Delta x / h$。\n第二个提示指出，对两个独立样本求差会使其方差相加。为了进行主导阶分析，我们假设在 $x_0+\\Delta x$ 和 $x_0-\\Delta x$ 处的平滑噪声值近似独立，这在 $h \\gg \\Delta x$ 时是合理的。那么它们差的方差就是它们方差的和：\n$$\n\\operatorname{Var}\\left( \\tilde{\\epsilon}(x_0 + \\Delta x) - \\tilde{\\epsilon}(x_0 - \\Delta x) \\right) \\approx \\operatorname{Var}(\\tilde{\\epsilon}(x_0+\\Delta x)) + \\operatorname{Var}(\\tilde{\\epsilon}(x_0-\\Delta x)) \\approx 2 \\frac{\\sigma^2 \\Delta x}{h}\n$$\n将此代回估计器方差的表达式中：\n$$\n\\operatorname{var}(h) \\approx \\frac{1}{4(\\Delta x)^2} \\left( \\frac{2 \\sigma^2 \\Delta x}{h} \\right) = \\frac{\\sigma^2}{2 h \\Delta x}\n$$\n\n#### 均方误差最小化与最优宽度\n结合偏差平方和方差，得到渐近均方误差：\n$$\n\\operatorname{MSE}(h) \\approx \\frac{h^4}{576} \\left(f^{(3)}(x_0)\\right)^2 + \\frac{\\sigma^2}{2 h \\Delta x}\n$$\n为了找到最小化此 $\\operatorname{MSE}$ 的最优核宽度 $h_\\star$，我们对 $h$ 求导并令结果为零：\n$$\n\\frac{d}{dh}\\operatorname{MSE}(h) = \\frac{4h^3}{576} \\left(f^{(3)}(x_0)\\right)^2 - \\frac{\\sigma^2}{2 h^2 \\Delta x} = 0\n$$\n$$\n\\frac{h^3}{144} \\left(f^{(3)}(x_0)\\right)^2 = \\frac{\\sigma^2}{2 h^2 \\Delta x}\n$$\n求解 $h^5$：\n$$\nh^5 = \\frac{144 \\sigma^2}{2 \\Delta x \\left(f^{(3)}(x_0)\\right)^2} = \\frac{72 \\sigma^2}{\\Delta x \\left(f^{(3)}(x_0)\\right)^2}\n$$\n这给出了最优宽度 $h_\\star$：\n$$\nh_\\star = \\left(\\frac{72\\,\\sigma^2}{\\Delta x\\,\\big(f^{(3)}(x_0)\\big)^2}\\right)^{1/5}\n$$\n此推导证实了问题陈述中提供的公式。用于实现的算法将计算此值，处理 $f^{(3)}(x_0)$ 接近零的情况，并确保所得的 $h$ 在物理和实际界限 $[\\Delta x, H_{\\max}]$ 之内。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the optimal smoothing width h for numerical differentiation\n    based on a bias-variance trade-off analysis.\n    \"\"\"\n    \n    # A small threshold to handle cases where the third derivative is zero or very close to it.\n    # This prevents division by zero and implements the saturation logic described.\n    tau = 1e-9\n\n    # Define the test cases from the problem statement.\n    # Each case is a dictionary for clarity.\n    test_cases = [\n        # Case A\n        {\n            \"f_name\": \"sin(x)\",\n            \"f3\": lambda x: -np.cos(x),\n            \"x0\": 1.0,\n            \"dx\": 0.01,\n            \"sigma\": 0.02,\n            \"Hmax\": 2.0,\n        },\n        # Case B\n        {\n            \"f_name\": \"exp(x)\",\n            \"f3\": lambda x: np.exp(x),\n            \"x0\": 0.0,\n            \"dx\": 0.005,\n            \"sigma\": 0.05,\n            \"Hmax\": 2.0,\n        },\n        # Case C\n        {\n            \"f_name\": \"x^3\",\n            \"f3\": lambda x: 6.0,\n            \"x0\": 0.2,\n            \"dx\": 0.1,\n            \"sigma\": 0.0001,\n            \"Hmax\": 2.0,\n        },\n        # Case D\n        {\n            \"f_name\": \"cos(5x)\",\n            \"f3\": lambda x: 125 * np.sin(5 * x),\n            \"x0\": 0.0,\n            \"dx\": 0.01,\n            \"sigma\": 0.1,\n            \"Hmax\": 1.0,\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        dx = case[\"dx\"]\n        sigma = case[\"sigma\"]\n        Hmax = case[\"Hmax\"]\n        \n        # Calculate the third derivative at x0\n        f3_val = case[\"f3\"](case[\"x0\"])\n        \n        # Apply the rule specified in the problem statement\n        if abs(f3_val) = tau:\n            # If the third derivative is negligible, bias is negligible.\n            # We choose the maximum smoothing to minimize variance.\n            h = Hmax\n        else:\n            # Calculate the optimal width h_star based on the derived formula\n            numerator = 72 * sigma**2\n            denominator = dx * f3_val**2\n            h_star = (numerator / denominator)**(1/5)\n            \n            # Clip the result to the valid range [dx, Hmax]\n            # h cannot be smaller than the grid spacing, and should not exceed Hmax.\n            h = np.clip(h_star, dx, Hmax)\n            \n        results.append(h)\n\n    # Final print statement in the exact required format.\n    # Each h value is formatted to six decimal places.\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "平滑样条是一种强大的正则化工具，它通过在数据拟合和解的光滑度之间进行权衡来解决不适定问题。这个练习将带你深入研究平滑样条的离散形式，并通过计算来量化正则化参数 $\\lambda$ 如何控制解的稳定性。你将通过计算谱范数等指标，直观地看到正则化是如何“驯服”一个不适定问题，将一个对噪声极度敏感的计算过程转变为一个稳健的估计器。",
            "id": "3286808",
            "problem": "本题要求您精确描述、量化并以计算方式展示平滑参数在经典平滑样条的离散模拟中所扮演的角色，并当数据被加性噪声破坏时，将其与原始插值进行比较。请在一维均匀网格上进行操作，并以弧度表示所有角度。\n\n考虑 $[0,1]$ 上的一个包含 $N$ 个点的均匀网格，定义为 $x_i = i h$，其中 $i \\in \\{0,1,\\dots,N-1\\}$，间距为 $h = 1/(N-1)$。设未知真实信号为 $f^{\\star}(x) = \\sin(2\\pi x) + \\tfrac{1}{2}\\cos(5\\pi x)$，并假设我们观测到含噪样本 $y_i = f^{\\star}(x_i) + \\epsilon_i$，其中 $\\epsilon_i$ 是标准差为 $\\sigma$ 的独立零均值高斯扰动。请通过将生成器种子设为 $0$ 并抽取一个长度为 $N$ 的向量来使用确定性伪随机序列，从而对每个 $(N,\\sigma)$ 对使用单个固定的噪声实现。\n\n将平滑样条估计量 $f_{\\lambda}$ 的离散模拟定义为 $\\mathbb{R}^N$ 中使罚最小二乘泛函最小化的向量\n$$\nJ_{\\lambda}(f) = \\sum_{i=0}^{N-1} (f_i - y_i)^2 + \\lambda \\lVert D_2 f \\rVert_2^2,\n$$\n其中 $D_2$ 是标准的二阶差分算子，用内部节点上的中心差分来近似二阶导数。具体来说，对于每个内部索引 $i \\in \\{1,2,\\dots,N-2\\}$，\n$$\n(D_2 f)_{i-1} = \\frac{f_{i-1} - 2 f_{i} + f_{i+1}}{h^2},\n$$\n因此 $D_2 \\in \\mathbb{R}^{(N-2)\\times N}$ 且 $L = D_2^{\\top} D_2 \\in \\mathbb{R}^{N\\times N}$。证明该最小化子满足正规方程\n$$\n(I + \\lambda L) f_{\\lambda} = y,\n$$\n其中 $I \\in \\mathbb{R}^{N\\times N}$ 是单位矩阵，$y \\in \\mathbb{R}^N$ 是由 $y_i$ 堆叠而成的向量。将 $\\lambda = 0$ 的情况解释为在网格节点上的原始插值（即对含噪数据进行精确拟合 $f_0 = y$）。对于 $\\lambda  0$，定义线性平滑算子 $S_{\\lambda} = (I + \\lambda L)^{-1}$，从而有 $f_{\\lambda} = S_{\\lambda} y$。\n\n您的计算任务是量化平滑参数 $\\lambda$ 如何在 Hadamard 适定性的意义上控制对噪声的稳定性。具体而言，通过算子 $D_2 S_{\\lambda}$ 检验估计曲率的稳定性。对于下述每个测试用例，计算三个标量诊断指标：\n\n- 曲率的谱噪声放大，由诱导 2-范数给出\n$$\na_{\\mathrm{spec}}(\\lambda) = \\lVert D_2 S_{\\lambda} \\rVert_2,\n$$\n该范数量化了估计二阶导数中噪声的最坏情况放大。\n\n- 在固定噪声实现上的经验曲率放大，\n$$\na_{\\mathrm{emp}}(\\lambda) = \\frac{\\lVert D_2 S_{\\lambda} \\epsilon \\rVert_2}{\\lVert \\epsilon \\rVert_2},\n$$\n其中 $\\epsilon$ 是用于构成 $y$ 的确定性噪声向量。\n\n- 重构信号的均方误差，\n$$\n\\mathrm{MSE}(\\lambda) = \\frac{1}{N} \\sum_{i=0}^{N-1} \\bigl(f_{\\lambda,i} - f^{\\star}(x_i)\\bigr)^2.\n$$\n\n使用以下参数三元组 $(N,\\lambda,\\sigma)$ 的测试套件，所有角度均以弧度为单位：\n\n- 用例 1: $(N,\\lambda,\\sigma) = (50, 0, 0.05)$。\n- 用例 2: $(N,\\lambda,\\sigma) = (50, 0.01, 0.05)$。\n- 用例 3: $(N,\\lambda,\\sigma) = (50, 0.1, 0.05)$。\n- 用例 4: $(N,\\lambda,\\sigma) = (50, 1.0, 0.05)$。\n- 用例 5: $(N,\\lambda,\\sigma) = (200, 0, 0.05)$。\n- 用例 6: $(N,\\lambda,\\sigma) = (200, 0.1, 0.05)$。\n\n您的程序必须对每个用例构建 $x_i$，使用从标准差为 $\\sigma$、伪随机生成器种子为 $0$ 的高斯分布中抽取的单个固定噪声向量来构成 $y_i = f^{\\star}(x_i) + \\epsilon_i$，建立 $D_2$，计算 $S_{\\lambda}$，然后计算三个诊断指标 $(a_{\\mathrm{spec}}, a_{\\mathrm{emp}}, \\mathrm{MSE})$。所有计算都是无量纲的。将每个诊断指标报告为四舍五入到六位小数的浮点数。\n\n最终输出格式：您的程序应生成单行内容，包含一个长度为六的列表，每个条目对应一个测试用例。每个条目本身必须是一个三元素列表，顺序为 $[a_{\\mathrm{spec}}, a_{\\mathrm{emp}}, \\mathrm{MSE}]$。例如，输出必须类似于 $[\\,[a_{\\mathrm{spec}}^{(1)},a_{\\mathrm{emp}}^{(1)},\\mathrm{MSE}^{(1)}],\\dots,[a_{\\mathrm{spec}}^{(6)},a_{\\mathrm{emp}}^{(6)},\\mathrm{MSE}^{(6)}]\\,]$，其中每个浮点数都四舍五入到六位小数。",
            "solution": "问题陈述已经过验证，被认为是数值分析中一个有效、自洽且适定的问题。它提出了一个关于使用平滑样条的离散模拟来对不适定逆问题（数值微分）进行正则化的标准练习。所有定义、参数和目标标准都已明确指定。\n\n问题的核心在于最小化向量 $f \\in \\mathbb{R}^N$ 的罚最小二乘泛函：\n$$\nJ_{\\lambda}(f) = \\sum_{i=0}^{N-1} (f_i - y_i)^2 + \\lambda \\lVert D_2 f \\rVert_2^2\n$$\n其中 $y \\in \\mathbb{R}^N$ 是含噪观测向量，$\\lambda \\geq 0$ 是平滑参数，$D_2 \\in \\mathbb{R}^{(N-2)\\times N}$ 是二阶差分矩阵算子。\n\n首先，我们推导最小化子 $f_{\\lambda}$ 的正规方程。我们可以将泛函写成矩阵-向量形式：\n$$\nJ_{\\lambda}(f) = (f - y)^{\\top}(f - y) + \\lambda (D_2 f)^{\\top}(D_2 f)\n$$\n展开各项，我们得到：\n$$\nJ_{\\lambda}(f) = f^{\\top}f - 2y^{\\top}f + y^{\\top}y + \\lambda f^{\\top}D_2^{\\top}D_2 f\n$$\n为了找到最小值，我们计算这个二次型关于 $f$ 的梯度并将其设为零。令 $L = D_2^{\\top}D_2$。矩阵 $L$ 是对称的。\n$$\n\\nabla_f J_{\\lambda}(f) = 2f - 2y + 2\\lambda L f\n$$\n将梯度设为零，得到最小值的必要条件：\n$$\n2f_{\\lambda} - 2y + 2\\lambda L f_{\\lambda} = 0\n$$\n$$\n(I + \\lambda L) f_{\\lambda} = y\n$$\n这证实了问题陈述中给出的正规方程。对于 $\\lambda > 0$，矩阵 $(I + \\lambda L)$ 是对称正定的（因为 $I$ 是正定的，而 $L$ 是半正定的），保证了唯一解 $f_{\\lambda}$ 的存在。对于 $\\lambda = 0$ 的情况，方程变为 $I f_0 = y$，即 $f_0 = y$。这对应于对含噪数据的原始插值，因为没有应用平滑。因此，解由 $f_{\\lambda} = (I + \\lambda L)^{-1} y$ 给出。我们定义线性平滑算子为 $S_{\\lambda} = (I + \\lambda L)^{-1}$。\n\n对于每个测试用例 $(N, \\lambda, \\sigma)$ 的计算过程如下：\n\n1.  **网格与信号生成**：在区间 $[0, 1]$ 上创建一个包含 $N$ 个点的均匀网格 $x_i = i h$，其中 $i \\in \\{0, 1, \\dots, N-1\\}$，间距为 $h = 1/(N-1)$。计算真实信号向量 $f^{\\star} \\in \\mathbb{R}^N$，其分量为 $f^{\\star}_i = \\sin(2\\pi x_i) + \\frac{1}{2}\\cos(5\\pi x_i)$。\n\n2.  **噪声生成**：为每个唯一的 $(N, \\sigma)$ 对生成一个确定的噪声向量 $\\epsilon \\in \\mathbb{R}^N$。这是通过将伪随机数生成器的种子设为 $0$，并从均值为 $0$、标准差为 $\\sigma$ 的高斯分布中抽取 $N$ 个样本来完成的。然后，通过 $y = f^{\\star} + \\epsilon$ 合成含噪观测值。\n\n3.  **算子构建**：构建二阶差分矩阵 $D_2 \\in \\mathbb{R}^{(N-2) \\times N}$。对于每一行 $j \\in \\{0, \\dots, N-3\\}$，将对应于列 $\\{j, j+1, j+2\\}$ 的条目分别设置为 $1/h^2, -2/h^2, 1/h^2$，以实现中心差分公式 $(f_{j} - 2f_{j+1} + f_{j+2})/h^2$。请注意，问题陈述中存在轻微的索引不匹配，即对于 $i \\in \\{1, \\dots, N-2\\}$ 的 $(D_2f)_{i-1}$，这等效于使用列 $j, j+1, j+2$ 的、对于 $j \\in \\{0, \\dots, N-3\\}$ 的 $(D_2f)_j$。我们遵循了后者更清晰的构造方式。然后计算惩罚矩阵 $L \\in \\mathbb{R}^{N \\times N}$ 为 $L = D_2^{\\top}D_2$。\n\n4.  **平滑算子计算**：计算平滑算子 $S_{\\lambda} \\in \\mathbb{R}^{N \\times N}$。如果 $\\lambda = 0$，$S_0$ 是单位矩阵 $I$。如果 $\\lambda > 0$，则通过对矩阵 $(I + \\lambda L)$ 求逆来计算 $S_{\\lambda}$。\n\n5.  **诊断指标计算**：使用生成的算子和向量计算三个诊断指标：\n    -   谱噪声放大，$a_{\\mathrm{spec}}(\\lambda) = \\lVert D_2 S_{\\lambda} \\rVert_2$，是矩阵 $D_2 S_{\\lambda}$ 的诱导 2-范数（或谱范数）。它量化了输入扰动在估计曲率中的最坏情况放大。\n    -   经验曲率放大，$a_{\\mathrm{emp}}(\\lambda) = \\frac{\\lVert D_2 S_{\\lambda} \\epsilon \\rVert_2}{\\lVert \\epsilon \\rVert_2}$，测量了特定于生成的噪声实现 $\\epsilon$ 的放大因子。\n    -   均方误差，$\\mathrm{MSE}(\\lambda) = \\frac{1}{N} \\lVert f_{\\lambda} - f^{\\star} \\rVert_2^2$，量化了重构信号 $f_{\\lambda} = S_{\\lambda}y$ 相对于真实信号 $f^{\\star}$ 的准确性。\n\n对六个指定的测试用例中的每一个都执行此完整过程。$\\lambda=0$ 的情况展示了对含噪数据进行微分的不适定性，其特点是 $a_{\\mathrm{spec}}$ 和 $a_{\\mathrm{emp}}$ 的值很大。$\\lambda > 0$ 的情况说明了平滑样条的正则化效应，它稳定了微分过程（降低了放大因子），但代价是在信号估计中引入了偏差，这种权衡反映在 MSE 中。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes diagnostics for a discrete smoothing spline problem across several test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, lambda, sigma)\n        (50, 0, 0.05),\n        (50, 0.01, 0.05),\n        (50, 0.1, 0.05),\n        (50, 1.0, 0.05),\n        (200, 0, 0.05),\n        (200, 0.1, 0.05),\n    ]\n\n    all_results = []\n    \n    # Cache for noise vectors to ensure the same realization is used for each (N, sigma) pair.\n    noise_cache = {}\n\n    for N, lam, sigma in test_cases:\n        # 1. Grid and Signal Generation\n        h = 1.0 / (N - 1)\n        x = np.linspace(0, 1, N)\n        f_star = np.sin(2 * np.pi * x) + 0.5 * np.cos(5 * np.pi * x)\n\n        # 2. Noise Generation (with caching)\n        if (N, sigma) in noise_cache:\n            epsilon = noise_cache[(N, sigma)]\n        else:\n            np.random.seed(0)\n            epsilon = sigma * np.random.randn(N)\n            noise_cache[(N, sigma)] = epsilon\n\n        # 3. Noisy Data\n        y = f_star + epsilon\n\n        # 4. Operator Construction\n        D2 = np.zeros((N - 2, N))\n        for i in range(N - 2):\n            D2[i, i:i+3] = [1.0, -2.0, 1.0]\n        D2 /= (h**2)\n        \n        I = np.identity(N)\n\n        # 5. Smoother Calculation\n        if lam == 0:\n            S_lambda = I\n        else:\n            L = D2.T @ D2\n            matrix_to_invert = I + lam * L\n            S_lambda = np.linalg.inv(matrix_to_invert)\n\n        # 6. Diagnostic Computation\n        \n        # Spectral noise amplification\n        a_spec = np.linalg.norm(D2 @ S_lambda, 2)\n\n        # Empirical curvature amplification\n        norm_epsilon = np.linalg.norm(epsilon, 2)\n        if norm_epsilon > 0:\n            a_emp = np.linalg.norm(D2 @ S_lambda @ epsilon, 2) / norm_epsilon\n        else:\n            a_emp = 0.0\n\n        # Mean Squared Error\n        f_lambda = S_lambda @ y\n        mse = np.mean((f_lambda - f_star)**2)\n\n        # Append formatted results for the current case\n        all_results.append([\n            f\"{a_spec:.6f}\",\n            f\"{a_emp:.6f}\",\n            f\"{mse:.6f}\"\n        ])\n\n    # Format the final output string as a list of lists.\n    output_str = \"[\" + \",\".join([f\"[{','.join(res)}]\" for res in all_results]) + \"]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}