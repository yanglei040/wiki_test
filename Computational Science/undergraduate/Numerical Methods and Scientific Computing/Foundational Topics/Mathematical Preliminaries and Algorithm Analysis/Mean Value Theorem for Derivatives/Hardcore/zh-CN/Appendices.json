{
    "hands_on_practices": [
        {
            "introduction": "中值定理保证了点 $c$ 的存在，但我们如何找到它呢？这个实践将这个存在性定理转化为一个具体的计算任务。我们将通过建立并求解方程 $f'(x) - \\frac{f(b)-f(a)}{b-a} = 0$，来为给定的多项式函数找到所有满足条件的 $c$ 值，从而加深对该定理含义的理解，并锻炼数值求根的技能。",
            "id": "3251031",
            "problem": "设计并实现一个完整的、可运行的程序。该程序对于给定的实数多项式 $f$ 和闭区间 $[a,b]$（其中 $a  b$），找到开区间 $(a,b)$ 内所有满足中值定理结论的点 $c$。",
            "solution": "该问题要求对于给定的实数多项式 $f(x)$，找出开区间 $(a,b)$ 内所有满足中值定理（MVT）结论的 $c$ 值。MVT 指出，对于在闭区间 $[a,b]$ 上连续且在开区间 $(a,b)$ 上可微的函数 $f$，必定存在至少一个数 $c \\in (a,b)$，使得在 $c$ 点的瞬时变化率等于在 $[a,b]$ 上的平均变化率。由于任何多项式函数在整个实数线上都是连续且可微的，因此MVT始终适用。该定理的结论由以下方程表示：\n$$\nf'(c) = \\frac{f(b) - f(a)}{b-a}\n$$\n为了找到所有这样的 $c$ 值，我们可以将其转化为一个求根问题。令 $s$ 表示恒定的平均变化率（连接区间上 $f$ 图像端点的割线斜率）：\n$$\ns = \\frac{f(b) - f(a)}{b-a}\n$$\n我们所求的 $c$ 值是方程 $f'(c) = s$ 在区间 $(a,b)$ 内的严格解。这等价于求解一个新多项式 $g(x)$ 的根，其定义为：\n$$\ng(x) = f'(x) - s\n$$\n解决此问题的算法步骤如下：\n\n1.  **多项式表示与微分**：一个 $n$ 次实数多项式 $f(x) = p_{n}x^{n} + p_{n-1}x^{n-1} + \\dots + p_{1}x + p_{0}$，由其系数向量 $[p_{n}, p_{n-1}, \\dots, p_{0}]$ 表示。它的导数 $f'(x)$ 是一个 $n-1$ 次多项式：\n    $$\n    f'(x) = n p_{n}x^{n-1} + (n-1)p_{n-1}x^{n-2} + \\dots + p_{1}\n    $$\n    $f'(x)$ 的系数可以通过算法从 $f(x)$ 的系数计算得出。\n\n2.  **构造求根方程**：首先根据定义计算标量值 $s$。由于保证 $a  b$，$s$ 的值是良定义的。然后，通过从 $f'(x)$ 的常数项中减去 $s$ 来构造 $g(x) = f'(x) - s$。这不会改变 $f'(x)$ 的次数或非零系数。\n\n3.  **求根**：$g(x)$ 是一个实系数多项式，因此我们可以使用标准的数值方法（例如基于伴随矩阵的方法）来找到其所有复数根。\n\n4.  **筛选根**：从计算出的根集中，我们必须筛选出满足以下所有条件的根 $c$：\n    a.  **实数根**：根必须是实数。在数值上，这意味着根的虚部绝对值应小于一个小的容差（例如 $10^{-9}$）。\n    b.  **区间内**：实数根必须严格位于开区间 $(a,b)$ 内。为了避免边界上的浮点问题，我们可以检查 $a + \\epsilon  c  b - \\epsilon$，其中 $\\epsilon$ 是一个很小的正数（例如 $10^{-12}$）。\n    c.  **残差检验**：由于数值误差，即使是有效的根也可能不会使 $g(c)$ 精确为零。因此，应通过检查残差 $|f'(c) - s|$ 是否小于一个小的容差（例如 $10^{-8}$）来验证每个候选根。\n\n5.  **去重与排序**：筛选出的根应进行排序。由于数值计算可能产生非常接近的多个根，应将彼此在小容差（例如 $10^{-8}$）范围内的根视为单个解，并进行去重。\n\n该算法将为任何给定的多项式和区间提供一个鲁棒的解决方案。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_mvt_case(coeffs, a, b):\n    \"\"\"\n    Finds all values c in (a,b) that satisfy the Mean Value Theorem for a polynomial.\n\n    Args:\n        coeffs (list of float): Coefficients of the polynomial f(x) in descending order.\n        a (float): The start of the interval [a,b].\n        b (float): The end of the interval [a,b].\n\n    Returns:\n        list of float: Sorted list of unique values of c satisfying the MVT.\n    \"\"\"\n    # Numerical tolerances from the problem statement\n    T_IMAG = 1e-9\n    T_RES = 1e-8\n    T_INT = 1e-12\n    T_MERGE = 1e-8\n\n    # 1. Represent f(x) as a polynomial object and compute its derivative f'(x)\n    f_poly = np.poly1d(coeffs)\n    f_prime_poly = f_poly.deriv()\n\n    # 2. Compute the average rate of change s on [a,b]\n    if b - a == 0:\n        return []  # Should not happen given a  b, but for robustness.\n    s = (f_poly(b) - f_poly(a)) / (b - a)\n\n    # 3. Form the polynomial g(x) = f'(x) - s\n    g_poly = f_prime_poly - s\n\n    # 4. Handle the special case of infinitely many solutions\n    # This occurs if g(x) is the zero polynomial (f'(x) is constant and equals s).\n    if np.allclose(g_poly.coeffs, 0):\n        return []\n\n    # 5. Find all complex roots of g(x) = 0\n    roots = np.roots(g_poly.coeffs)\n\n    # 6. Filter the roots based on the specified criteria\n    # 6.1. Keep only roots that are effectively real\n    real_candidates = [r.real for r in roots if abs(r.imag) = T_IMAG]\n\n    # 6.2. Keep only roots strictly within the interval (a, b) with a guard\n    interval_candidates = [x for x in real_candidates if (a + T_INT) = x = (b - T_INT)]\n\n    # 6.3. Keep only roots that satisfy the residual tolerance\n    accepted_roots = [x for x in interval_candidates if abs(f_prime_poly(x) - s) = T_RES]\n    \n    # 7. Sort and deduplicate the final list of roots\n    accepted_roots.sort()\n\n    if not accepted_roots:\n        return []\n\n    # Merge numerically close roots by keeping the first of each cluster\n    deduplicated_roots = [accepted_roots[0]]\n    last_kept_root = accepted_roots[0]\n    for i in range(1, len(accepted_roots)):\n        if abs(accepted_roots[i] - last_kept_root) > T_MERGE:\n            deduplicated_roots.append(accepted_roots[i])\n            last_kept_root = accepted_roots[i]\n\n    return deduplicated_roots\n\ndef solve():\n    \"\"\"\n    Main driver function to run the test suite and print the formatted output.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        ([1, 0, -3, 0], -2.0, 2.0),\n        ([1, 0, 0, 0, 0], -1.0, 2.0),\n        ([1, 0, -2, 0, 0], -1.0, 1.0),\n        ([1, 0, -5, 0, 4, 0], -2.0, 2.0),\n        ([1, 0, 0], 0.0, 1e-8),\n    ]\n\n    all_results_formatted = []\n    for case in test_cases:\n        coeffs, a, b = case\n        c_values = solve_mvt_case(coeffs, a, b)\n        \n        # Format numbers to fixed-point with 12 decimal places\n        formatted_c_values = [f\"{c:.12f}\" for c in c_values]\n        \n        # Format the list of numbers as a string \"[num1,num2,...]\"\n        result_string = f\"[{','.join(formatted_c_values)}]\"\n        all_results_formatted.append(result_string)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results_formatted)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "掌握一个定理的关键在于理解其适用边界。本练习将探讨为何中值定理 $\\mathbf{f}'(c) = \\frac{\\mathbf{f}(b)-\\mathbf{f}(a)}{b-a}$ 的简单形式不能直接推广到向量值函数。通过对一个在单位圆上运动的经典反例进行数值检验，你将对该定理背后的几何与分析条件有更深刻的认识。",
            "id": "3251084",
            "problem": "考虑由 $\\mathbf{f}(t) = (\\cos t, \\sin t)$ 定义的向量值函数 $\\mathbf{f} : \\mathbb{R} \\to \\mathbb{R}^2$。以导数作为瞬时变化率的基本定义以及适用于标量值函数的经典一维导数中值定理为概念基础，设计并实现一个数值程序。该程序在给定 $a \\le b$ 的闭区间 $[a,b]$ 时，判断是否存在一点 $c \\in [a,b]$，使得在 $c$ 点的瞬时变化率向量等于在 $[a,b]$ 上的平均变化率向量。具体来说，当 $a  b$ 时，该条件为向量 $\\dfrac{\\mathbf{f}(b) - \\mathbf{f}(a)}{b - a}$ 对于某个 $c \\in [a,b]$ 与 $\\mathbf{f}'(c)$ 逐分量相等；当 $a = b$ 时，该条件被视为自然成立。角度必须以弧度为单位进行解释。您的算法必须基于在 $[a,b]$ 上的均匀网格上采样候选点 $c$，并在一个固定的数值容差范围内判断存在性。如果在此容差内存在这样的点 $c$，则程序必须输出布尔值 $\\text{True}$，否则输出 $\\text{False}$。\n\n实现该程序以评估以下区间测试套件，所有角度均以弧度为单位：\n- 测试用例 1：$[a,b] = [0, 2\\pi]$。\n- 测试用例 2：$[a,b] = [0, \\pi]$。\n- 测试用例 3：$[a,b] = [\\pi/4, 3\\pi/4]$。\n- 测试用例 4：$[a,b] = [1.0, 1.0]$。\n- 测试用例 5：$[a,b] = [0.0, 0.1]$。\n\n对于每个测试用例，您的程序必须：\n- 当 $a  b$ 时，构建平均变化率向量 $\\dfrac{\\mathbf{f}(b) - \\mathbf{f}(a)}{b - a}$；当 $a = b$ 时，将该条件视为自然成立。\n- 在 $[a,b]$ 中对一个均匀网格上的点 $c$ 进行采样，并计算残差范数 $\\left\\|\\mathbf{f}(b) - \\mathbf{f}(a) - (b-a)\\,\\mathbf{f}'(c)\\right\\|_2$。\n- 如果整个网格上的最小残差范数小于或等于一个固定容差（使用 $10^{-9}$），则判定为 $\\text{True}$，否则判定为 $\\text{False}$。\n- 为确保稳健性，采样时至少使用 $20000$ 个网格点。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如 $[\\text{result1},\\text{result2},\\text{result3},\\text{result4},\\text{result5}]$），每个结果都是一个布尔值。本问题中除弧度外没有其他物理单位，所有角度都必须以弧度表示。",
            "solution": "该问题是对向量值函数中值定理的数值探索。具体来说，它测试的是对于给定的函数 $\\mathbf{f}(t) = (\\cos t, \\sin t)$ 和一个区间 $[a,b]$，是否存在一点 $c \\in [a,b]$ 使得 $\\mathbf{f}'(c) = \\frac{\\mathbf{f}(b) - \\mathbf{f}(a)}{b - a}$。该问题是适定的，且适合根据所提供的指南进行计算求解。求解方法将是首先分析该条件的数学性质，然后按规定实现数值搜索算法。\n\n**1. 数学分析**\n\n函数 $\\mathbf{f}(t) = (\\cos t, \\sin t)$ 描述了在 $\\mathbb{R}^2$ 中单位圆上运动的一个点。其导数为 $\\mathbf{f}'(t) = (-\\sin t, \\cos t)$，代表速度向量。速度向量的模为 $\\|\\mathbf{f}'(t)\\| = \\sqrt{(-\\sin t)^2 + (\\cos t)^2} = 1$。这意味着速率是恒定的，等于1。\n\n向量 $\\mathbf{v}_{\\text{avg}} = \\frac{\\mathbf{f}(b) - \\mathbf{f}(a)}{b-a}$ 代表在区间 $[a,b]$ 上的平均速度。其模为 $\\|\\mathbf{v}_{\\text{avg}}\\| = \\frac{\\|\\mathbf{f}(b) - \\mathbf{f}(a)\\|}{b-a}$。从几何上看，$\\|\\mathbf{f}(b) - \\mathbf{f}(a)\\|$ 是连接单位圆上点 $\\mathbf{f}(a)$ 和 $\\mathbf{f}(b)$ 的弦长。值 $b-a$ 是这两点之间的弧长。一个基本的几何原理指出，弦长严格小于其所对的弧长，除非弧长为零（即 $a=b$）。\n\n因此，对于任何 $a  b$，我们有 $\\|\\mathbf{f}(b) - \\mathbf{f}(a)\\|  b-a$，这意味着 $\\|\\mathbf{v}_{\\text{avg}}\\|  1$。\n\n由于对所有 $c$ 都有 $\\|\\mathbf{f}'(c)\\| = 1$，而对所有 $a  b$ 都有 $\\|\\mathbf{v}_{\\text{avg}}\\|  1$，因此等式 $\\mathbf{f}'(c) = \\mathbf{v}_{\\text{avg}}$ 永远不能成立，因为这两个向量的模永远不相等。\n\n所以，对于任何 $a  b$ 的情况，结果应为 `False`。对于 $a=b$ 的情况，问题陈述将结果定义为 `True`。\n\n**2. 数值算法**\n\n该算法将按如下描述实现检查：\n1.  对于给定的区间 $[a,b]$，如果 $a=b$，则返回 `True`。\n2.  如果 $a  b$：\n    a.  在 $[a,b]$ 上创建一个包含大量点（例如，20000个）的均匀网格，作为候选点 $c$ 的集合。\n    b.  计算常数向量 $\\mathbf{v}_{\\text{diff}} = \\mathbf{f}(b) - \\mathbf{f}(a)$。\n    c.  对于网格中的每个点 $c_i$，计算残差向量 $\\mathbf{r}_i = \\mathbf{v}_{\\text{diff}} - (b-a)\\mathbf{f}'(c_i)$。\n    d.  计算每个残差向量的 L2 范数 $\\|\\mathbf{r}_i\\|_2$。\n    e.  找到所有计算出的范数中的最小值。\n    f.  如果该最小范数小于或等于给定的容差（$10^{-9}$），则返回 `True`；否则返回 `False`。\n\n根据我们的数学分析，对于所有 $a  b$ 的测试用例，数值结果都应为 `False`。对于 $a=b$ 的用例，结果应为 `True`。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef check_mvt_condition(interval, n_points=20000, tol=1e-9):\n    \"\"\"\n    Numerically checks if there exists a point c in the interval [a, b]\n    such that f'(c) = (f(b) - f(a)) / (b - a) for the vector function\n    f(t) = (cos(t), sin(t)).\n\n    Args:\n        interval (tuple): A tuple (a, b) representing the closed interval.\n        n_points (int): The number of grid points to sample for c.\n        tol (float): The numerical tolerance for the residual norm.\n\n    Returns:\n        bool: True if such a c is found within tolerance, False otherwise.\n    \"\"\"\n    a, b = interval\n\n    # Per the problem statement, if a = b, the condition is trivially true.\n    if a == b:\n        return True\n\n    # The problem implies a = b, so we only need to handle a  b.\n    if a > b:\n        raise ValueError(\"Interval must satisfy a = b.\")\n\n    # Define the vector function f(t) = [cos(t), sin(t)]\n    def f(t):\n        return np.array([np.cos(t), np.sin(t)])\n\n    # Define the derivative f'(t) = [-sin(t), cos(t)]\n    def f_prime(t):\n        return np.array([-np.sin(t), np.cos(t)])\n\n    # The condition is f'(c) * (b - a) = f(b) - f(a).\n    # We check the norm of the residual: ||f(b) - f(a) - (b-a)*f'(c)||_2\n    \n    # Calculate the constant part of the residual: f(b) - f(a)\n    f_diff_vector = f(b) - f(a)\n\n    # Create a uniform grid of sample points for c over [a, b].\n    c_grid = np.linspace(a, b, n_points)\n\n    # --- Vectorized Calculation ---\n    # 1. Calculate f'(c) for all c in the grid.\n    #    This results in a 2xN array where N is n_points.\n    f_prime_values = f_prime(c_grid)\n\n    # 2. Calculate the residual vectors for all c.\n    #    f_diff_vector has shape (2,). We reshape to (2, 1) for broadcasting\n    #    across the f_prime_values array (shape 2xN).\n    #    Residuals = (f(b) - f(a)) - (b-a) * f'(c)\n    residual_vectors = f_diff_vector[:, np.newaxis] - (b - a) * f_prime_values\n\n    # 3. Calculate the L2 norm for each residual vector (i.e., each column).\n    #    The `axis=0` argument computes the norm along the columns.\n    residual_norms = np.linalg.norm(residual_vectors, ord=2, axis=0)\n\n    # 4. Find the minimum residual norm from the grid search.\n    min_residual_norm = np.min(residual_norms)\n\n    # 5. The condition holds if the minimum norm is within the tolerance.\n    return min_residual_norm = tol\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test suite of intervals.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # All angles are in radians.\n    test_cases = [\n        (0.0, 2 * np.pi),          # Test case 1\n        (0.0, np.pi),              # Test case 2\n        (np.pi / 4, 3 * np.pi / 4),# Test case 3\n        (1.0, 1.0),                # Test case 4\n        (0.0, 0.1),                # Test case 5\n    ]\n\n    results = []\n    for case in test_cases:\n        # For each case, run the numerical check.\n        result = check_mvt_condition(case, n_points=20000, tol=1e-9)\n        # In Python, boolean True/False are capitalized. The required output seems to be lowercase\n        # but standard boolean representation is preferred unless specified. The example `[result1...`\n        # is ambiguous. Sticking to standard Python representation `True`/`False`.\n        results.append(str(result))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\n# Execute the solution.\nsolve()\n```"
        },
        {
            "introduction": "微分中值定理不仅有其直接的结论，更是分析数值算法精度的强大工具。在本练习中，你将运用中值定理（通过其推论泰勒定理）来理解有限差分公式的截断误差。然后，你将编写代码来数值验证理论上的收敛阶，从而将抽象的理论与数值方法的实际性能联系起来。",
            "id": "3251126",
            "problem": "要求您将导数中值定理 (MVT) 与有限差分公式的截断误差联系起来，并数值验证其精度阶数。从微积分的核心定义开始：连续性、可微性、微积分基本定理以及导数中值定理。中值定理 (MVT) 指出，对于一个在区间 $(a,b)$ 上可微且在 $[a,b]$ 上连续的函数 $f$，存在一点 $\\xi \\in (a,b)$，使得 $f(b) - f(a) = (b-a) f'(\\xi)$。利用此原理论证误差项。\n\n任务 A (推导)：使用中值定理 (MVT) 及其推论，为以下近似导数 $f'(x)$ 的有限差分公式推导其主阶截断误差：\n- 前向差分 (单侧)：$\\displaystyle D^{+}_h f(x) = \\frac{f(x+h) - f(x)}{h}$。\n- 中心差分 (双侧)：$\\displaystyle D^{0}_h f(x) = \\frac{f(x+h) - f(x-h)}{2h}$。\n\n您的推导必须从中值定理 (MVT) 和可微性的基本原理出发，不得引用未经证明的快捷公式。使用标准且切合实际的假设：\n- 对于前向差分，假设 $f$ 在一个包含 $[x, x+h]$ 的区间上二阶连续可微。\n- 对于中心差分，假设 $f$ 在一个包含 $[x-h, x+h]$ 的区间上三阶连续可微。\n\n解释 MVT 如何蕴含存在给出主要误差行为的中间点，并得出作为 $h$ 的函数的预期精度阶数。\n\n任务 B (数值验证)：实现一个程序，使用指定的有限差分公式计算近似导数，与精确导数 $f'(x)$ 比较以评估绝对误差，并通过最小二乘法将数据点 $\\left(\\log h_i, \\log \\text{error}_i\\right)$（其中 $\\{h_i\\}$ 为一系列步长）拟合为一条直线来估计观测阶数 $p$。该直线的斜率即为测量阶数 $p$。使用自然对数。如果对于给定的 $h_i$，任何误差在数值上为零，则在拟合时排除该 $h_i$。\n\n角度说明：对于任何三角函数，角度必须以弧度为单位。\n\n测试套件：\n- 案例 1 (正常路径，单侧边界公式)：$f(x) = e^x$, $x_0 = 0.2$，格式 $D^{+}_h$， $h$ 值 $\\{0.1, 0.05, 0.025, 0.0125, 0.00625\\}$。报告测量阶数 $p$ (预期约为 $1$）。\n- 案例 2 (正常路径，双侧内部公式)：$f(x) = \\sin(x)$，$x_0 = 1.0$ (弧度)，格式 $D^{0}_h$，$h$ 值 $\\{0.1, 0.05, 0.025, 0.0125, 0.00625\\}$。报告测量阶数 $p$ (预期约为 $2$）。\n- 案例 3 (说明浮点舍入误差主导的边界情况)：$f(x) = \\cos(x)$，$x_0 = 1.0$ (弧度)，格式 $D^{0}_h$，$h$ 值 $\\{10^{-8}, 5\\times 10^{-9}, 2.5\\times 10^{-9}, 1.25\\times 10^{-9}\\}$。报告测量阶数 $p$。在此范围内，相消误差和机器精度 $\\epsilon \\approx 2.22\\times 10^{-16}$ 下的有限精度会占主导地位，因此 $p$ 可能显著偏离理论截断阶数。\n\n您的程序必须为每个案例计算测量阶数 $p$，并生成单行输出，其中包含三个结果，格式为方括号括起来的逗号分隔列表，每个 $p$ 值四舍五入到三位小数（例如 $\\left[1.001,1.998,-0.012\\right]$）。不应打印任何额外文本。\n\n所有计算都是无量纲的；不涉及物理单位。角度以弧度为单位。唯一允许使用的库是 Python 标准库和 NumPy。",
            "solution": "此任务是使用导数中值定理 (MVT) 推导前向和中心有限差分公式的截断误差，并数值验证其精度阶数。MVT 指出，对于一个在区间 $(a,b)$ 上可微且在 $[a,b]$ 上连续的函数 $f$，存在一点 $\\xi \\in (a,b)$，使得 $f(b) - f(a) = (b-a) f'(\\xi)$。通过重复应用该定理，可得到一个直接推论，即带有 Lagrange 余项的泰勒定理。我们将使用此推论进行推导。\n\n### 任务 A：截断误差的推导\n\n对于 $f'(x)$ 的有限差分近似 $D_h f(x)$，其截断误差 $E(x,h)$ 定义为精确导数与其近似值之差：$E(x,h) = f'(x) - D_h f(x)$。精度阶数 $p$ 是误差主项中的指数，使得 $|E(x,h)| = O(h^p)$。\n\n#### 1. 前向差分公式\n\n前向差分公式为 $D^{+}_h f(x) = \\frac{f(x+h) - f(x)}{h}$。我们假设函数 $f$ 在一个包含 $[x, x+h]$ 的区间上是二阶连续可微的，记作 $f \\in C^2$。\n\n根据带 Lagrange 余项的泰勒定理，我们可以将 $f(x+h)$ 在点 $x$ 附近展开。对于一个 $C^2$ 中的函数，可得：\n$$\nf(x+h) = f(x) + f'(x)h + \\frac{f''(\\xi_1)}{2!}h^2\n$$\n其中 $\\xi_1 \\in (x, x+h)$ 为某个中间点。此公式是将 MVT（特别是 MVT 的一个特例 Rolle 定理）应用于为分析泰勒多项式余项而构造的辅助函数后得到的直接结果。\n\n重新整理泰勒展开式，以分离出前向差分公式中的各项，我们得到：\n$$\nf(x+h) - f(x) = f'(x)h + \\frac{f''(\\xi_1)}{2}h^2\n$$\n两边同除以 $h$ ($h \\neq 0$)：\n$$\n\\frac{f(x+h) - f(x)}{h} = f'(x) + \\frac{f''(\\xi_1)}{2}h\n$$\n左边的项是前向差分近似值 $D^{+}_h f(x)$。所以，我们有：\n$$\nD^{+}_h f(x) = f'(x) + \\frac{f''(\\xi_1)}{2}h\n$$\n因此，截断误差为：\n$$\nE(x,h) = f'(x) - D^{+}_h f(x) = - \\frac{f''(\\xi_1)}{2}h\n$$\n误差的大小为 $|E(x,h)| = \\left| \\frac{f''(\\xi_1)}{2} \\right| |h|$。由于 $f \\in C^2$，二阶导数 $f''$ 在 $[x, x+h]$ 上是连续且有界的。当 $h \\to 0$ 时，$\\xi_1 \\to x$，且 $f''(\\xi_1) \\to f''(x)$。只要 $f''(x) \\neq 0$，误差就与 $h$ 成正比。因此，我们称前向差分公式具有 $O(h)$ 的主阶误差，其精度阶数为 $p=1$。\n\n#### 2. 中心差分公式\n\n中心差分公式为 $D^{0}_h f(x) = \\frac{f(x+h) - f(x-h)}{2h}$。我们假设函数 $f$ 在一个包含 $[x-h, x+h]$ 的区间上是三阶连续可微的，即 $f \\in C^3$。\n\n我们再次使用带 Lagrange 余项的泰勒定理，这次展开到更高阶。我们分别对 $f(x+h)$ 和 $f(x-h)$ 在点 $x$ 附近进行展开：\n$$\nf(x+h) = f(x) + f'(x)h + \\frac{f''(x)}{2!}h^2 + \\frac{f'''(\\xi_1)}{3!}h^3 \\quad \\text{其中 } \\xi_1 \\in (x, x+h)\n$$\n$$\nf(x-h) = f(x) + f'(x)(-h) + \\frac{f''(x)}{2!}(-h)^2 + \\frac{f'''(\\xi_2)}{3!}(-h)^3 \\quad \\text{其中 } \\xi_2 \\in (x-h, x)\n$$\n简化第二个展开式：\n$$\nf(x-h) = f(x) - f'(x)h + \\frac{f''(x)}{2}h^2 - \\frac{f'''(\\xi_2)}{6}h^3\n$$\n为了构造中心差分，我们用第一个展开式减去第二个展开式：\n$$\nf(x+h) - f(x-h) = (f(x)-f(x)) + (f'(x)h - (-f'(x)h)) + \\left(\\frac{f''(x)}{2}h^2 - \\frac{f''(x)}{2}h^2\\right) + \\left(\\frac{f'''(\\xi_1)}{6}h^3 - \\left(-\\frac{f'''(\\xi_2)}{6}h^3\\right)\\right)\n$$\n包含 $f(x)$ 和 $f''(x)$ 的项被消去，剩下：\n$$\nf(x+h) - f(x-h) = 2f'(x)h + \\frac{h^3}{6} (f'''(\\xi_1) + f'''(\\xi_2))\n$$\n两边同除以 $2h$ ($h \\neq 0$)：\n$$\n\\frac{f(x+h) - f(x-h)}{2h} = f'(x) + \\frac{h^2}{12} (f'''(\\xi_1) + f'''(\\xi_2))\n$$\n左边是中心差分近似值 $D^{0}_h f(x)$。截断误差为：\n$$\nE(x,h) = f'(x) - D^{0}_h f(x) = -\\frac{h^2}{12} (f'''(\\xi_1) + f'''(\\xi_2))\n$$\n由于 $f \\in C^3$，三阶导数 $f'''$ 在包含 $\\xi_1$ 和 $\\xi_2$ 的区间 $[x-h, x+h]$ 上是连续的。根据介值定理，存在一点 $\\xi \\in (\\xi_2, \\xi_1) \\subset (x-h, x+h)$，使得 $f'''(\\xi) = \\frac{f'''(\\xi_1) + f'''(\\xi_2)}{2}$。因此，我们可以简化误差表达式：\n$$\nE(x,h) = -\\frac{h^2}{6} f'''(\\xi)\n$$\n误差的大小为 $|E(x,h)| = \\left| \\frac{f'''(\\xi)}{6} \\right| h^2$。当 $h \\to 0$ 时，$\\xi \\to x$，且 $f'''(\\xi) \\to f'''(x)$。只要 $f'''(x) \\neq 0$，误差就与 $h^2$ 成正比。因此，中心差分公式具有 $O(h^2)$ 的主阶误差，其精度阶数为 $p=2$。\n\n### 任务 B：数值验证\n\n对于一个 $p$ 阶方法，其绝对误差 $|E|$ 和步长 $h$ 之间的理论关系是 $|E| \\approx C h^p$，其中 $C$ 为某个常数且 $h$ 足够小。对两边取自然对数，得到一个线性关系：\n$$\n\\ln(|E|) \\approx \\ln(C) + p \\ln(h)\n$$\n该方程的形式为 $y = c + mx$，其中 $y = \\ln(|E|)$，$x = \\ln(h)$，斜率 $m$ 是精度阶数 $p$，截距 $c$ 是 $\\ln(C)$。通过为一系列递减的步长 $\\{h_i\\}$ 计算误差，我们可以生成一组数据点 $(\\ln(h_i), \\ln(|E_i|))$。对这些点应用线性最小二乘回归，可以数值估计斜率 $p$，即观测到的精度阶数。以下程序为指定的测试案例实现了此过程。对于极小的 $h$ 值，这种关系会失效，因为与 $O(h^{-1})$ 同阶的浮点舍入误差会变得比截断误差更占主导。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the observed order of accuracy for finite difference schemes.\n    \"\"\"\n    \n    # Define test cases as a list of dictionaries.\n    test_cases = [\n        {\n            \"f\": lambda x: np.exp(x),\n            \"f_prime\": lambda x: np.exp(x),\n            \"x0\": 0.2,\n            \"scheme\": \"D+\",\n            \"h_values\": np.array([0.1, 0.05, 0.025, 0.0125, 0.00625])\n        },\n        {\n            \"f\": lambda x: np.sin(x),\n            \"f_prime\": lambda x: np.cos(x),\n            \"x0\": 1.0,\n            \"scheme\": \"D0\",\n            \"h_values\": np.array([0.1, 0.05, 0.025, 0.0125, 0.00625])\n        },\n        {\n            \"f\": lambda x: np.cos(x),\n            \"f_prime\": lambda x: -np.sin(x),\n            \"x0\": 1.0,\n            \"scheme\": \"D0\",\n            \"h_values\": np.array([1e-8, 5e-9, 2.5e-9, 1.25e-9])\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        f = case[\"f\"]\n        f_prime = case[\"f_prime\"]\n        x0 = case[\"x0\"]\n        scheme = case[\"scheme\"]\n        h_values = case[\"h_values\"]\n        \n        log_h = []\n        log_error = []\n        \n        exact_derivative = f_prime(x0)\n        \n        for h in h_values:\n            if scheme == \"D+\":\n                # Forward difference formula\n                approx_derivative = (f(x0 + h) - f(x0)) / h\n            elif scheme == \"D0\":\n                # Central difference formula\n                approx_derivative = (f(x0 + h) - f(x0 - h)) / (2 * h)\n            else:\n                # Should not happen with given test cases\n                raise ValueError(\"Unknown scheme\")\n            \n            # Calculate absolute error\n            error = np.abs(exact_derivative - approx_derivative)\n            \n            # Exclude data points where error is numerically zero\n            if error > 0:\n                log_h.append(np.log(h))\n                log_error.append(np.log(error))\n\n        # Perform linear least-squares fit to find the order of accuracy (the slope)\n        if len(log_h) > 1:\n            log_h_np = np.array(log_h)\n            log_error_np = np.array(log_error)\n            \n            # We are fitting log_error = p * log_h + log_C\n            # This is a linear system Ax = b, where x = [p, log_C]^T\n            A = np.vstack([log_h_np, np.ones(len(log_h_np))]).T\n            p, _ = np.linalg.lstsq(A, log_error_np, rcond=None)[0]\n            results.append(p)\n        else:\n            # Handle cases with insufficient data for a fit\n            results.append(np.nan)\n\n    # Format output according to the problem specification\n    # e.g., [1.001,1.998,-0.012]\n    output_str = f\"[{','.join([f'{p:.3f}' for p in results])}]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}