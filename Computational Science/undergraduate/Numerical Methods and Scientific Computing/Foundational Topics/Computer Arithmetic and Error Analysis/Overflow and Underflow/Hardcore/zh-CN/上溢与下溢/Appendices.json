{
    "hands_on_practices": [
        {
            "introduction": "计算大数的阶乘，如 $171!$，会迅速超出标准浮点数的表示范围，导致溢出。本练习将指导你运用对数变换这一核心技巧，将乘法运算转换为加法运算，从而在不产生溢出的情况下，精确计算极大数值的科学记数法表示。这是处理极端尺度问题的基本策略。",
            "id": "3260852",
            "problem": "您需要设计并实现一个在浮点环境中稳健的计算方法，用于在计算阶乘函数时避免上溢和下溢。您的推导基础是阶乘作为乘积的定义，以及对数和伽马函数的一般性质。计算环境为电气和电子工程师协会（IEEE）$754$ 双精度浮点算术标准。在此类系统中，规格化数的可表示范围是有限的，对于较大的 $n$，直接计算 $n!$ 或其倒数可能会导致上溢或下溢。您的任务是从第一性原理出发，重构计算过程，以确保所有中间步骤的数值都保持在可表示范围内。\n\n请从阶乘 $n!$ 对于整数 $n \\ge 0$ 的有限乘积定义 $\\prod_{k=1}^{n} k$ 出发，并利用伽马函数 $\\Gamma(x)$ 和对数 $\\log(x)$ 的一般性质，不要假设任何快捷公式。您可以假设存在一个黑盒函数，该函数能为 $x  0$ 返回 $\\log(\\Gamma(x))$，并且您可以认为它在双精度环境下是数值稳定的。您的算法必须在以 10 为底的对数表示下运行，以便在不引起数值上溢或下溢的情况下，概括表示 $n!$ 和 $1/n!$。\n\n规格说明：\n- 对于每个整数输入 $n \\ge 0$，计算 $n!$ 及其倒数 $1/n!$ 的以 10 为底的科学记数法表示形式 $m \\times 10^{e}$，其中 $m \\in [1,10)$ 且 $e \\in \\mathbb{Z}$。令 $m_f$ 和 $e_f$ 分别表示 $n!$ 的尾数和指数，令 $m_r$ 和 $e_r$ 分别表示 $1/n!$ 的尾数和指数。\n- 仅使用从 $\\log(\\Gamma(\\cdot))$ 和对数性质推导出的以 10 为底的对数值来获取 $m_f$、$e_f$、$m_r$ 和 $e_r$，不得以标准浮点形式直接计算 $n!$ 或 $1/n!$。\n- 将尾数 $m_f$ 和 $m_r$ 四舍五入到 10 位小数，同时保持指数 $e_f$ 和 $e_r$ 为精确整数。\n\n测试套件：\n- 使用以下 $n$ 的测试值列表：$[0, 10, 170, 171, 100000]$。选择这些值是为了涵盖多个方面：\n  - $n = 0$ 用于检查阶乘恒等式的边界条件。\n  - $n = 10$ 是一个典型情况，朴素计算是安全的，可作为一致性检查。\n  - $n = 170$ 接近在 IEEE $754$ 双精度标准下 $n!$ 的有限表示的上限。\n  - $n = 171$ 超过了在 IEEE $754$ 双精度标准下 $n!$ 的上溢阈值。\n  - $n = 100000$ 是一个极大的数值，用于检验对数方法的性能。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。列表中的每个元素对应一个测试用例，并且本身必须是按 $[m_f, e_f, m_r, e_r]$ 顺序排列的四个值的列表。例如，输出格式必须与以下示例完全一致：\n  - $[[m_{f,0}, e_{f,0}, m_{r,0}, e_{r,0}], [m_{f,1}, e_{f,1}, m_{r,1}, e_{r,1}], \\dots]$\n- 所有尾数必须是四舍五入到 10 位小数的浮点数，所有指数必须是整数。\n\n您的答案中不应包含任何物理单位，也不要使用百分比。所有角度（如果出现，在此任务中不会出现）默认单位为弧度。",
            "solution": "该问题要求设计一种数值稳定的算法，用于计算非负整数 $n$ 的阶乘 $n!$ 及其倒数 $1/n!$ 的科学记数法表示 $m \\times 10^e$。核心挑战在于避免因在标准浮点算术中直接计算 $n!$（尤其是在 $n$ 值较大时）而产生的上溢和下溢问题。指定的方法论是从第一性原理出发，利用对数的性质和一个用于计算伽马函数对数 $\\log(\\Gamma(x))$ 的稳定函数。为了推导方便，我们假设 $\\log(x)$ 表示自然对数 $\\ln(x)$，这在科学计算环境和函数库中是标准做法。\n\n### 对数计算原理\n\n处理乘积产生的极大或极小数的基本策略是将计算转换到对数域。一项乘积会变成各项对数的和：\n$$ \\log\\left(\\prod_{i=1}^{n} x_i\\right) = \\sum_{i=1}^{n} \\log(x_i) $$\n对于定义为 $n! = \\prod_{k=1}^{n} k$（$n \\ge 1$）的阶乘函数，该性质意味着：\n$$ \\ln(n!) = \\ln\\left(\\prod_{k=1}^{n} k\\right) = \\sum_{k=1}^{n} \\ln(k) $$\n对数的和比数字本身的乘积增长得慢得多。例如，虽然 $171!$ 超过了 IEEE $754$ 双精度算术中可表示的最大值（约 $1.8 \\times 10^{308}$），但其自然对数 $\\ln(171!) \\approx 711.8$ 是一个完全可控的数。这种从乘法到加法的转换是防止上溢的关键。同样，在处理倒数 $1/n!$ 时，它也能防止下溢。\n\n### 与伽马函数的联系\n\n问题提供了一个黑盒函数，能以数值稳定的方式计算 $\\ln(\\Gamma(x))$。伽马函数 $\\Gamma(x)$ 是阶乘函数在复数上的推广。对于任意非负整数 $n$，它满足以下恒等式：\n$$ \\Gamma(n+1) = n! $$\n对等式两边取自然对数，提供了一种无需计算可能不稳定的和即可求得 $\\ln(n!)$ 的直接方法：\n$$ \\ln(n!) = \\ln(\\Gamma(n+1)) $$\n因此，我们可以使用所提供的稳定 `log-gamma` 函数来获得 $\\ln(n!)$ 的精确值，即使对于非常大的 $n$ 也是如此。\n\n### 转换为以 10 为底的科学记数法\n\n目标是将一个数 $X$（即 $n!$ 或 $1/n!$）表示为以 10 为底的科学记数法形式 $X = m \\times 10^e$，其中尾数 $m$ 在范围 $[1, 10)$ 内，指数 $e$ 是一个整数。\n\n为了求出 $m$ 和 $e$，我们对该方程取以 10 为底的对数：\n$$ \\log_{10}(X) = \\log_{10}(m \\times 10^e) = \\log_{10}(m) + \\log_{10}(10^e) = \\log_{10}(m) + e $$\n对尾数的约束 $1 \\le m  10$ 意味着其以 10 为底的对数在范围 $0 \\le \\log_{10}(m)  1$ 内。这意味着 $\\log_{10}(m)$ 是 $\\log_{10}(X)$ 的小数部分，而 $e$ 是其整数部分。\n\n令 $L = \\log_{10}(X)$。指数 $e$ 和尾数 $m$ 可以通过以下方式提取：\n- 指数是 $L$ 的向下取整：$e = \\lfloor L \\rfloor$。\n- 尾数由 $L$ 的小数部分导出：$m = 10^{(L - \\lfloor L \\rfloor)}$。\n\n### $n!$ 和 $1/n!$ 的算法\n\n现在我们将此分解方法应用于 $n!$ 和 $1/n!$。\n\n1.  **计算 $n!$ 的以 10 为底的对数**：\n    首先，我们使用对数伽马函数求得 $\\ln(n!) = \\ln(\\Gamma(n+1))$。然后，我们使用换底公式 $\\log_{10}(x) = \\frac{\\ln(x)}{\\ln(10)}$ 将其转换为以 10 为底的对数。令该值为 $L_f$。\n    $$ L_f = \\log_{10}(n!) = \\frac{\\ln(\\Gamma(n+1))}{\\ln(10)} $$\n\n2.  **提取 $n!$ 的尾数和指数**：\n    根据上面推导的逻辑，$n!$ 的尾数 $m_f$ 和指数 $e_f$ 为：\n    $$ e_f = \\lfloor L_f \\rfloor $$\n    $$ m_f = 10^{(L_f - e_f)} = 10^{(L_f - \\lfloor L_f \\rfloor)} $$\n\n3.  **提取 $1/n!$ 的尾数和指数**：\n    对于倒数 $1/n!$，其以 10 为底的对数 $L_r$ 恰好是 $L_f$ 的负数：\n    $$ L_r = \\log_{10}(1/n!) = \\log_{10}(n!^{-1}) = - \\log_{10}(n!) = -L_f $$\n    我们对 $L_r$ 应用相同的分解方法来求得尾数 $m_r$ 和指数 $e_r$：\n    $$ e_r = \\lfloor L_r \\rfloor = \\lfloor -L_f \\rfloor $$\n    $$ m_r = 10^{(L_r - e_r)} = 10^{(-L_f - \\lfloor -L_f \\rfloor)} $$\n\n4.  **处理 $n=0$ 的情况**：\n    根据定义，$0! = 1$。算法也必须正确处理这个基本情况。\n    对于 $n=0$，我们有 $\\Gamma(0+1) = \\Gamma(1) = 1$。于是 $\\ln(\\Gamma(1)) = \\ln(1) = 0$。这得出 $L_f = \\log_{10}(1) = 0$。\n    对于 $n!$：$e_f = \\lfloor 0 \\rfloor = 0$ 且 $m_f = 10^{(0-0)} = 1$。这对应于 $1 \\times 10^0$，是正确的。\n    对于 $1/n!$：$L_r = -0 = 0$。因此，$e_r = \\lfloor 0 \\rfloor = 0$ 且 $m_r = 10^{(0-0)} = 1$。这也是正确的。\n    因此，该算法对所有 $n \\ge 0$ 都有效。\n\n此过程仅使用对数域运算对良态数进行操作，从而计算出 $n!$ 和 $1/n!$ 的尾数和指数，稳健地避免了任何上溢或下溢。最终的实现将按要求把计算出的尾数四舍五入到 10 位小数。",
            "answer": "```python\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Computes the scientific notation representation for n! and 1/n!\n    for a list of test cases, avoiding overflow and underflow.\n    \"\"\"\n\n    test_cases = [0, 10, 170, 171, 100000]\n    \n    # Pre-calculate the natural logarithm of 10 for change of base.\n    LN_10 = math.log(10)\n\n    def calculate_sci_notation(n: int) - list:\n        \"\"\"\n        Calculates m_f, e_f, m_r, e_r for a given integer n.\n        \n        Args:\n            n: A non-negative integer.\n\n        Returns:\n            A list containing [m_f, e_f, m_r, e_r], where m_f and m_r are\n            mantissas rounded to 10 decimal places, and e_f and e_r are\n            integer exponents.\n        \"\"\"\n        if n == 0:\n            # Base case: 0! = 1.\n            # 1 = 1.0 * 10^0. Reciprocal is the same.\n            return [1.0, 0, 1.0, 0]\n\n        # Use the identity ln(n!) = ln(Gamma(n+1)).\n        # math.lgamma(x) computes ln(|Gamma(x)|) stably.\n        ln_factorial = math.lgamma(n + 1)\n        \n        # Convert to base-10 logarithm: log10(x) = ln(x) / ln(10).\n        log10_factorial = ln_factorial / LN_10\n        \n        # --- For n! ---\n        # The exponent is the integer part of the base-10 logarithm.\n        e_f = math.floor(log10_factorial)\n        # The mantissa is 10 raised to the power of the fractional part.\n        m_f = 10**(log10_factorial - e_f)\n        \n        # --- For 1/n! ---\n        # log10(1/n!) = -log10(n!)\n        log10_reciprocal = -log10_factorial\n        \n        # The exponent is the integer part.\n        e_r = math.floor(log10_reciprocal)\n        # The mantissa is 10 raised to the power of the fractional part.\n        m_r = 10**(log10_reciprocal - e_r)\n        \n        # Return the results, rounded and typed as specified.\n        return [\n            round(m_f, 10),\n            int(e_f),\n            round(m_r, 10),\n            int(e_r)\n        ]\n\n    results = []\n    for n in test_cases:\n        results.append(calculate_sci_notation(n))\n\n    # The format requires no spaces inside the inner lists' string representation.\n    # Python's default str(list) includes spaces. This custom formatting avoids them.\n    formatted_results = []\n    for res in results:\n        # Format \"m_f\" as a float string, \"e_f\" as an int, etc.\n        # The rounding to 10 places is handled in the function, so we just format.\n        formatted_inner_list = f\"[{res[0]},{res[1]},{res[2]},{res[3]}]\"\n        formatted_results.append(formatted_inner_list)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "双曲正切函数 $\\tanh(x)$ 的直接计算公式在 $x$ 的绝对值很大时会因计算 $\\exp(x)$ 而失败，尽管其极限值是良态的 $1$ 或 $-1$。本练习将展示如何通过简单的代数重构，避免计算导致溢出的中间项，从而设计出在整个定义域上都数值稳定的算法。这个例子说明，有时问题的关键不在于最终结果，而在于计算路径。",
            "id": "3260871",
            "problem": "您的任务是设计一个数值稳定的算法，用于计算实数输入下的双曲正切函数。目标是在广泛的输入数量级范围内生成精确的函数值，同时避免上溢和下溢。此任务的基础是基于指数函数的双曲函数定义，以及由电气与电子工程师协会 (IEEE) 754 标准规定的浮点运算特性。\n\n从第一性原理出发，使用基于指数函数的定义：\n- 双曲正弦定义为 $$\\sinh(x) = \\frac{e^{x} - e^{-x}}{2}.$$\n- 双曲余弦定义为 $$\\cosh(x) = \\frac{e^{x} + e^{-x}}{2}.$$\n- 双曲正切定义为 $$\\tanh(x) = \\frac{\\sinh(x)}{\\cosh(x)}.$$\n\n您的任务是重写 $$\\tanh(x)$$ 的表达式，以避免当 $$x$$ 为大的正数时（此时对 $$e^{x}$$ 的朴素计算可能超出可表示范围）出现数值上溢，以及当 $$x$$ 为大的负数时（此时对 $$e^{-x}$$ 的朴素计算可能下溢为零）出现数值下溢。然后，您必须将此稳定表达式实现在一个完整的、可运行的程序中。\n\n最终程序必须：\n- 实现一个函数，该函数使用根据上述定义和在 IEEE 754 模型下合理的浮点运算推导出的数值稳定表达式来计算 $$\\tanh(x)$$。\n- 将该函数应用于以下涵盖典型和极端情况的输入测试套件：\n  1. $$x = 0.0$$\n  2. $$x = 10^{-12}$$\n  3. $$x = -10^{-12}$$\n  4. $$x = 1.0$$\n  5. $$x = -1.0$$\n  6. $$x = 709.0$$\n  7. $$x = -709.0$$\n  8. $$x = 750.0$$\n  9. $$x = -750.0$$\n- 以浮点数形式生成输出，不带单位（该量为无量纲）。\n- 输出格式规范：您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，“[result1,result2,result3]”）。不应打印任何其他文本。\n\n您的设计和实现应明确避免那些在输入为大的正数时会引发上溢，或在输入为大的负数时会导致不必要的下溢引发精度损失的表达式，并遵循浮点运算的约束。",
            "solution": "目标是为实数输入 $x$ 构建一个计算双曲正切函数 $\\tanh(x)$ 的数值稳定算法。推导从双曲正弦 $\\sinh(x)$ 和双曲余弦 $\\cosh(x)$ 以指数函数表示的基本定义开始。\n\n定义如下：\n$$ \\sinh(x) = \\frac{e^{x} - e^{-x}}{2} $$\n$$ \\cosh(x) = \\frac{e^{x} + e^{-x}}{2} $$\n\n由此，双曲正切被定义为它们的比值：\n$$ \\tanh(x) = \\frac{\\sinh(x)}{\\cosh(x)} = \\frac{\\frac{e^{x} - e^{-x}}{2}}{\\frac{e^{x} + e^{-x}}{2}} = \\frac{e^{x} - e^{-x}}{e^{x} + e^{-x}} $$\n\n最后一个表达式 $\\tanh(x) = \\frac{e^{x} - e^{-x}}{e^{x} + e^{-x}}$ 构成了朴素的计算公式。我们必须在有限精度浮点运算的约束下分析其行为，特别是针对双精度数的 IEEE 754 标准。\n\n浮点运算的一个关键限制是其有限的范围。对于标准的双精度浮点数，最大可表示值约为 $1.797 \\times 10^{308}$。指数函数 $e^x$ 增长非常迅速。当 $x$ 的值使得 $e^x$ 超过这个最大值时，即 $x  \\ln(1.797 \\times 10^{308}) \\approx 709.78$。任何试图计算超出此阈值的 $x$ 的 $e^x$ 都会导致数值上溢，通常表示为无穷大 ($\\infty$)。\n\n让我们根据这一限制来分析朴素公式：\n1.  对于大的正数 $x$（例如，$x  709.78$）：项 $e^x$ 上溢为 $\\infty$。项 $e^{-x}$ 正确地计算为一个非常小的正数（或下溢为 $0$）。表达式变为 $\\frac{\\infty - 0}{\\infty + 0}$，这是一个 $\\frac{\\infty}{\\infty}$ 的不定式，计算结果为 `NaN`（非数值）。这在数值上是不正确的，因为数学上的极限是 $\\lim_{x \\to \\infty} \\tanh(x) = 1$。\n\n2.  对于大的负数量级 $x$（例如，$x  -709.78$）：令 $x = -y$，其中 $y$ 是大的正数。项 $e^x = e^{-y}$ 正确地计算为一个非常小的正数（或 $0$）。然而，项 $e^{-x} = e^y$ 上溢为 $\\infty$。表达式变为 $\\frac{0 - \\infty}{0 + \\infty}$，这是一个 $\\frac{-\\infty}{\\infty}$ 的不定式，结果同样是 `NaN`。这再次不正确，因为数学上的极限是 $\\lim_{x \\to -\\infty} \\tanh(x) = -1$。\n\n为了构建一个稳定的算法，我们必须重新构造表达式，以避免计算大的正数的指数。这可以通过代数操作来实现，从而得到一个基于 $x$ 符号的分段函数。\n\n**情况 1：$x \\ge 0$**\n对于非负的 $x$，项 $e^x$ 是潜在上溢的来源。我们可以通过将分子和分母同乘以 $e^{-x}$ 来消除它：\n$$ \\tanh(x) = \\frac{e^x - e^{-x}}{e^x + e^{-x}} \\cdot \\frac{e^{-x}}{e^{-x}} = \\frac{e^x e^{-x} - e^{-x} e^{-x}}{e^x e^{-x} + e^{-x} e^{-x}} = \\frac{1 - e^{-2x}}{1 + e^{-2x}} $$\n在这种形式 $\\tanh(x) = \\frac{1 - e^{-2x}}{1 + e^{-2x}}$ 中，指数函数的参数是 $-2x$。由于 $x \\ge 0$，参数 $-2x$ 始终是非正数。计算 $e^{-2x}$ 绝不会上溢。对于大的正数 $x$，$-2x$ 变成一个大的负数量级数，而 $e^{-2x}$ 会无害地向下溢出到 $0$。在此极限下，表达式正确地计算为 $\\frac{1 - 0}{1 + 0} = 1$。这种形式对于所有 $x \\ge 0$ 都是数值稳定的。\n\n**情况 2：$x  0$**\n对于负数 $x$，项 $e^{-x}$ 是潜在上溢的来源。我们可以通过将原始表达式的分子和分母同乘以 $e^x$ 来消除这一项：\n$$ \\tanh(x) = \\frac{e^x - e^{-x}}{e^x + e^{-x}} \\cdot \\frac{e^x}{e^x} = \\frac{e^x e^x - e^{-x} e^x}{e^x e^x + e^{-x} e^x} = \\frac{e^{2x} - 1}{e^{2x} + 1} $$\n在这种形式 $\\tanh(x) = \\frac{e^{2x} - 1}{e^{2x} + 1}$ 中，指数函数的参数是 $2x$。由于 $x  0$，参数 $2x$ 始终是负数。计算 $e^{2x}$ 绝不会上溢。对于大的负数量级 $x$，$2x$ 变成一个大的负数量级数，而 $e^{2x}$ 会无害地向下溢出到 $0$。在此极限下，表达式正确地计算为 $\\frac{0 - 1}{0 + 1} = -1$。这种形式对于所有 $x  0$ 都是数值稳定的。这个结果也与奇函数性质 $\\tanh(x) = -\\tanh(-x)$ 一致，该性质也会得出相同的表达式。\n\n**最终算法**\n推导出的用于计算 $\\tanh(x)$ 的数值稳定算法是一个分段函数：\n$$\n\\tanh(x) =\n\\begin{cases}\n    \\frac{1 - e^{-2x}}{1 + e^{-2x}}  \\text{若 } x \\ge 0 \\\\\n    \\frac{e^{2x} - 1}{e^{2x} + 1}  \\text{若 } x  0\n\\end{cases}\n$$\n该算法通过确保指数函数的参数始终为非正数，避免了所有实数输入 $x$ 的数值上溢问题。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef stable_tanh(x):\n    \"\"\"\n    Computes tanh(x) using a numerically stable algorithm to avoid\n    overflow and underflow issues for large magnitude inputs.\n\n    This function implements a piecewise expression for tanh(x) derived\n    from first principles to ensure that the argument to the exponential\n    function is always non-positive, thus preventing overflow.\n    \"\"\"\n    # Ensure the input is treated as a 64-bit float for consistency\n    # with standard double-precision floating-point arithmetic (IEEE 754).\n    x_f64 = np.float64(x)\n\n    # For non-negative x, use the form tanh(x) = (1 - exp(-2x)) / (1 + exp(-2x)).\n    # The exponent (-2x) is guaranteed to be non-positive, thus np.exp\n    # will not overflow. It may underflow to 0 for large x, which is\n    # the desired behavior, yielding a result of 1.0.\n    if x_f64 = 0.0:\n        exp_val = np.exp(-2.0 * x_f64)\n        return (1.0 - exp_val) / (1.0 + exp_val)\n    \n    # For negative x, use the form tanh(x) = (exp(2x) - 1) / (exp(2x) + 1).\n    # The exponent (2x) is guaranteed to be negative, thus np.exp\n    # will not overflow. It may underflow to 0 for large-magnitude\n    # negative x, which is the desired behavior, yielding a result of -1.0.\n    else:\n        exp_val = np.exp(2.0 * x_f64)\n        return (exp_val - 1.0) / (exp_val + 1.0)\n\ndef solve():\n    \"\"\"\n    Main function to execute the test cases and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        0.0,\n        1e-12,\n        -1e-12,\n        1.0,\n        -1.0,\n        709.0,\n        -709.0,\n        750.0,\n        -750.0,\n    ]\n\n    results = []\n    for case in test_cases:\n        # Calculate the result for one case using the stable function.\n        result = stable_tanh(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The map(str, ...) function converts each float in the results list\n    # to its string representation before joining them with commas.\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the main function.\nsolve()\n```"
        },
        {
            "introduction": "从简单的函数求值扩展到迭代算法，我们会发现即使一个问题的精确解是有界的，用于求解的数值方法本身也可能不稳定并导致溢出。本练习通过求解一个简单的常微分方程来揭示这一现象。你将看到，不恰当的参数选择（如时间步长 $h$）如何导致数值解无限增长并最终溢出，这为理解数值稳定性提供了直观的实例。",
            "id": "3260938",
            "problem": "构造并分析一个标量常微分方程，其中一个朴素的前向显式欧拉方法会表现出数值溢出，尽管其解析解保持有界。使用以下基本依据：标量线性常微分方程的定义，从一阶泰勒近似推导出的前向显式欧拉方法，以及关于溢出和下溢的电气和电子工程师协会（IEEE）$754$ 双精度浮点运算的行为。\n\n您必须处理标量线性测试问题 $$\\frac{dy}{dt}=\\lambda y,$$ 其中参数 $\\lambda\\in\\mathbb{R}$ 为常数，初始值为 $y(0)=y_0$。通过分离变量法得到的解析解为 $$y(t)=y_0 e^{\\lambda t}.$$ 在步长为 $h0$ 的均匀网格上应用前向显式欧拉方法，产生递推关系 $$y_{n+1}=y_n+h f(t_n,y_n)=y_n+h \\lambda y_n=(1+h\\lambda)\\,y_n,$$ 其中 $t_n=n h$。在有限精度算法中，如果 $|1+h\\lambda|1$ 且 $n$ 足够大，序列 $\\{y_n\\}$ 的量级可能会增长并超过可表示的最大 IEEE $754$ 双精度数，导致溢出为一个表示 $+\\infty$ 或 $-\\infty$ 的特殊值。相比之下，对于 $\\lambda0$，解析解 $y(t)=y_0 e^{\\lambda t}$ 是有界的，并且当 $t\\to\\infty$ 时衰减到 $0$。您的程序必须展示这种现象并验证溢出条件。\n\n您的程序必须：\n- 使用标准的浮点类型，在 IEEE $754$ 双精度算术中实现显式欧拉方法更新 $y_{n+1}=(1+h\\lambda)\\,y_n$，$n=0,1,\\dots,N-1$。\n- 在欧拉迭代期间，通过每一步检查 $y_n$ 的有限性来检测数值溢出；将非有限值（无穷大或非数字）视为溢出。\n- 计算最终时间 $T=N h$ 时的解析值 $y(T)=y_0 e^{\\lambda T}$，并检查此解析值在 IEEE $754$ 双精度算术中是否是有限的（有界的）。\n- 对于每个测试用例，报告一个布尔值，指示欧拉迭代是否在解析解保持有界的情况下发生溢出，即，当且仅当欧拉迭代在某一步产生非有限值且解析值 $y(T)$ 是有限的时，报告 $\\text{True}$；否则报告 $\\text{False}$。\n\n使用以下测试套件，其旨在覆盖不同的行为：\n- 情况 $1$（不稳定的欧拉，溢出）：$\\lambda=-1000$, $y_0=1$, $h=0.01$, $N=400$。\n- 情况 $2$（稳定的欧拉，无溢出）：$\\lambda=-1$, $y_0=1$, $h=0.1$, $N=200$。\n- 情况 $3$（稳定性边界，无溢出）：$\\lambda=-1$, $y_0=1$, $h=2.0$, $N=1000$。\n\n您的程序应该生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[result_1,result_2,result_3]$），其中每个 $result_i$ 是按上述规定计算的布尔值。此问题不涉及物理单位，也不使用角度。所有参数和计算都是纯数值的。输出必须是确定性的，并且无需任何外部输入即可复现。",
            "solution": "该问题要求对一个特定的标量常微分方程（ODE）进行前向显式欧拉方法的分析，展示数值不稳定性如何能在真实解析解有界的情况下导致溢出。我们将首先建立理论基础，然后将其应用于给定的测试用例。\n\n该问题围绕标量线性测试方程展开：\n$$\n\\frac{dy}{dt} = \\lambda y\n$$\n其中 $\\lambda$ 是实常数参数，初始条件为 $y(t=0) = y_0$。\n\n这个常微分方程的解析解可以通过分离变量法求得：\n$$\n\\frac{dy}{y} = \\lambda dt \\implies \\int_{y_0}^{y(t)} \\frac{d\\tilde{y}}{\\tilde{y}} = \\int_0^t \\lambda d\\tilde{t} \\implies \\ln\\left(\\frac{y(t)}{y_0}\\right) = \\lambda t\n$$\n对两边取指数，得到精确解：\n$$\ny(t) = y_0 e^{\\lambda t}\n$$\n在本问题考虑的情况下，$\\lambda  0$。在这种情况下，解析解 $y(t)$ 是一个指数衰减函数。当 $t \\to \\infty$ 时，$y(t) \\to 0$。对于任何有限时间 $T$，值 $y(T) = y_0 e^{\\lambda T}$ 是一个定义良好且有限的数。\n\n前向显式欧拉方法是一种近似常微分方程解的数值格式。它源自解 $y(t)$ 在时间 $t_n$ 附近的一阶泰勒级数展开：\n$$\ny(t_{n+1}) = y(t_n + h) \\approx y(t_n) + h y'(t_n)\n$$\n其中 $h$ 是时间步长。代入常微分方程 $y'(t_n) = f(t_n, y(t_n)) = \\lambda y(t_n)$，我们得到数值近似 $y_n \\approx y(t_n)$ 的递推关系：\n$$\ny_{n+1} = y_n + h (\\lambda y_n) = (1 + h\\lambda) y_n\n$$\n这是一个等比数列。展开递推关系可得到 $y_n$ 的显式公式：\n$$\ny_n = (1 + h\\lambda)^n y_0\n$$\n数值解 $\\{y_n\\}$ 的行为完全取决于放大因子 $R = 1 + h\\lambda$。如果数值解的量级不无限增长，则认为它是稳定的。这当且仅当 $|R| \\le 1$ 时发生，这是前向欧拉方法对此测试问题的绝对稳定性条件。\n$$\n|1 + h\\lambda| \\le 1\n$$\n由于问题指定 $\\lambda  0$，我们可以将其写为：\n$$\n-1 \\le 1 + h\\lambda \\le 1\n$$\n右侧不等式 $1 + h\\lambda \\le 1$ 简化为 $h\\lambda \\le 0$，对于 $h > 0$ 和 $\\lambda  0$ 总是成立。关键条件来自左侧不等式：\n$$\n-1 \\le 1 + h\\lambda \\implies -2 \\le h\\lambda \\implies h \\le -\\frac{2}{\\lambda}\n$$\n如果步长 $h$ 违反此条件，即 $h > -2/\\lambda$，则该方法变得不稳定。在这种情况下，$1 + h\\lambda  -1$，因此放大因子 $R$ 的量级大于 $1$。数值解 $y_n = R^n y_0$ 将以指数增长的振幅振荡。在有限精度算术中，例如 IEEE $754$ 双精度，这种快速增长最终将导致 $|y_n|$ 的值超过可表示的最大有限数（约 $1.8 \\times 10^{308}$），从而导致数值溢出，通常表示为 `inf` 或 `-inf`。\n\n任务是找出在解析解 $y(T)=y_0e^{\\lambda T}$ 保持有限的情况下，发生数值溢出（$y_n$ 变为非有限）的情况。这种现象突显了一种纯粹的数值假象，即所选择的离散化（步长 $h$）不适合问题的刚度（$\\lambda$ 的量级）。\n\n让我们分析给定的测试用例：\n\n情况 $1$：$\\lambda=-1000$, $y_0=1$, $h=0.01$, $N=400$。\n- 稳定性边界：$h \\le -2/\\lambda = -2/(-1000) = 0.002$。\n- 选择的步长为 $h=0.01$。由于 $0.01 > 0.002$，该方法不稳定。\n- 放大因子为 $R = 1 + (0.01)(-1000) = 1 - 10 = -9$。\n- 数值解为 $y_n = (-9)^n$。其量级 $|y_n| = 9^n$ 增长得非常快。对于一个足够大但小于 $N$ 的 $n$，$y_n$ 的值将会溢出。例如，$9^{324}$ 大于 $10^{308}$，因此溢出将在远未达到最后一步 $N=400$ 时发生。\n- 在最终时间 $T = N h = 400 \\times 0.01 = 4.0$ 时的解析解是 $y(4.0) = 1 \\cdot e^{-1000 \\times 4.0} = e^{-4000}$。这是一个极小的正数，它是有限且可表示的（在双精度中它会下溢到 $0.0$，但 $0.0$ 是一个有限数）。\n- 结论：欧拉方法溢出，而解析解是有限的。结果为 $\\text{True}$。\n\n情况 $2$：$\\lambda=-1$, $y_0=1$, $h=0.1$, $N=200$。\n- 稳定性边界：$h \\le -2/\\lambda = -2/(-1) = 2.0$。\n- 选择的步长为 $h=0.1$。由于 $0.1 \\le 2.0$，该方法是稳定的。\n- 放大因子为 $R = 1 + (0.1)(-1) = 0.9$。\n- 数值解为 $y_n = (0.9)^n$。由于 $|R|  1$，解会衰减到 $0$ 并且不会溢出。\n- 在 $T = N h = 200 \\times 0.1 = 20.0$ 时的解析解是 $y(20.0) = 1 \\cdot e^{-1 \\times 20.0} = e^{-20}$，这是一个小但有限的正数。\n- 结论：欧拉方法不溢出，且解析解是有限的。结果为 $\\text{False}$。\n\n情况 $3$：$\\lambda=-1$, $y_0=1$, $h=2.0$, $N=1000$。\n- 稳定性边界：$h \\le -2/\\lambda = -2/(-1) = 2.0$。\n- 选择的步长为 $h=2.0$，正好在稳定性边界上。\n- 放大因子为 $R = 1 + (2.0)(-1) = -1$。\n- 数值解为 $y_n = (-1)^n y_0 = (-1)^n$。值将在 $1$ 和 $-1$ 之间交替。量级保持不变且不增长，因此不会发生溢出。\n- 在 $T = N h = 1000 \\times 2.0 = 2000.0$ 时的解析解是 $y(2000.0) = 1 \\cdot e^{-1 \\times 2000.0} = e^{-2000}$。这是一个极小的正数，在双精度算术中将计算为 $0.0$，这是一个有限值。\n- 结论：欧拉方法不溢出，且解析解是有限的。结果为 $\\text{False}$。\n\n实现将遵循此逻辑，迭代欧拉步骤，检查非有限值，计算最终时间的解析解，并结合这些检查以产生所需的布尔输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(lambda_val, y0, h, N):\n    \"\"\"\n    Runs the forward Euler simulation for the ODE y' = lambda * y and checks for overflow.\n\n    Args:\n        lambda_val (float): The parameter lambda in the ODE.\n        y0 (float): The initial value y(0).\n        h (float): The time step size.\n        N (int): The number of steps.\n\n    Returns:\n        bool: True if Euler overflowed and the analytical solution is finite, False otherwise.\n    \"\"\"\n    # Use numpy.float64 for explicit IEEE 754 double-precision arithmetic.\n    y = np.float64(y0)\n    lambda_val_f64 = np.float64(lambda_val)\n    h_f64 = np.float64(h)\n\n    euler_overflowed = False\n    \n    # Calculate the amplification factor once.\n    amplification_factor = 1.0 + h_f64 * lambda_val_f64\n\n    # Perform the Euler iterations\n    for _ in range(N):\n        # Update the numerical solution\n        y = amplification_factor * y\n        \n        # Check for overflow (inf) or invalid number (nan)\n        if not np.isfinite(y):\n            euler_overflowed = True\n            break\n            \n    # Calculate the final time T\n    T = N * h_f64\n    \n    # Compute the analytical solution y(T) = y0 * exp(lambda * T)\n    # np.exp handles large negative exponents by underflowing to 0.0, which is finite.\n    analytical_val = np.float64(y0) * np.exp(lambda_val_f64 * T)\n    \n    # Check if the analytical solution is a finite number\n    analytical_is_finite = np.isfinite(analytical_val)\n    \n    # The problem asks to report True only if Euler overflowed AND the analytical solution is finite.\n    return euler_overflowed and analytical_is_finite\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases as tuples of (lambda, y0, h, N).\n    test_cases = [\n        # Case 1: Unstable Euler, should overflow\n        (-1000.0, 1.0, 0.01, 400),\n        # Case 2: Stable Euler, no overflow\n        (-1.0, 1.0, 0.1, 200),\n        # Case 3: Stability boundary, no overflow\n        (-1.0, 1.0, 2.0, 1000),\n    ]\n\n    results = []\n    for case in test_cases:\n        lambda_val, y0, h, N = case\n        result = run_simulation(lambda_val, y0, h, N)\n        # The output format requires lowercase booleans.\n        results.append(str(result).lower())\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}