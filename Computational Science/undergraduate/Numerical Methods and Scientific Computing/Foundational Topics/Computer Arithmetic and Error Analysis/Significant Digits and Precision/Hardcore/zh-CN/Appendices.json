{
    "hands_on_practices": [
        {
            "introduction": "在我们深入研究计算误差之前，首先需要理解哪些数字可以在计算机中被*完美*地表示。这项练习将挑战你确定 `binary64` 浮点格式能够精确表示阶乘 ($n!$) 的最大整数 $n$。通过这个过程，你将把有效数字位长度这一抽象概念与一个具体的计算边界联系起来，从而深化对浮点数如何存储整数的理解。",
            "id": "3273447",
            "problem": "考虑电气和电子工程师协会 (IEEE) 754 binary64 格式，该格式使用1位符号位、11位指数位和52位小数域来表示实数，并带有1个隐含的前导1，从而得到53位的有效数。一个整数 $N$ 能够在此格式中被精确表示，当且仅当它的二进制表示可以被规格化，使得有效数能够无需舍入地对其进行编码。利用二进制规格化的基本性质和阶乘的素因数分解，确定最大的整数 $n$，使得 $n!$ 能够被精确地表示为一个 binary64 数。从关于二进制精度和 $n!$ 中以2为底的因子的基本原理出发，证明你的答案。你的最终答案应为一个整数。无需舍入。",
            "solution": "用户要求我找到最大的整数 `n`，使得 `n!` 可以被 IEEE 754 binary64 格式精确表示。\n\n### 步骤 1：问题验证\n\n**1.1. 提取已知条件：**\n- 格式：IEEE 754 binary64。\n- 符号位：$1$ 位。\n- 指数场：$11$ 位。\n- 小数域：$52$ 位。\n- 有效数：$53$ 位（隐含的前导 $1$ 加上 $52$ 位小数位）。\n- 精确表示的条件：一个整数 $N$ 是可精确表示的，如果它的二进制表示可以被规格化以适应有效数而无需舍入。\n- 目标：找到最大的整数 $n$，使得 $n!$ 可以被精确表示。\n- 方法：利用二进制规格化的性质和阶乘的素因数分解。\n\n**1.2. 使用提取的已知条件进行验证：**\n- **科学依据：** 该问题基于明确定义的 IEEE 754 标准和标准数学概念（阶乘、素因数分解、对数）。这是数值分析中的一个标准问题。前提条件在事实上是正确的。\n- **适定性：** 问题要求找到“最大的整数”，这意味着期望一个唯一的解。精确表示的条件清晰且足以确定这样的一个整数。\n- **客观性：** 问题以精确、技术性的语言陈述，没有主观或模糊的术语。\n\n**1.3. 结论与行动：**\n问题有效。现在开始求解过程。\n\n### 步骤 2：求解推导\n\n在 IEEE 754 binary64 格式中，一个数被表示为 $N = (-1)^s \\times m \\times 2^e$，其中 $s$ 是符号位，$m$ 是 53 位有效数，$e$ 是指数。有效数是一个形式为 $(1.f_{51}f_{50}...f_0)_2$ 的二进制数，其中前导的 $1$ 是隐含的，而 $52$ 位的小数 $f$ 是显式存储的。有效数 $m$ 的值总是在范围 $1 \\le m  2$ 内。\n\n一个整数 $N > 0$ 是可精确表示的，当且仅当它可以被写成 $m \\times 2^k$ 的形式（对于某个整数 $k$），其中 $m$ 可以被 53 位有效数精确表示。设整数 $N$ 的二进制表示为 $N = (b_p b_{p-1} \\dots b_q 0 \\dots 0)_2$，其中 $b_p=1$ 是最高有效位，$b_q=1$ 是最低有效位。尾随零的个数是 $q$。我们可以将 $N$ 写成 $O \\times 2^q$，其中 $O = (b_p b_{p-1} \\dots b_q)_2$ 是一个奇数。\n\n为了用浮点格式表示 $N$，我们将其规格化：\n$$N = (1.b_{p-1}b_{p-2} \\dots b_q)_2 \\times 2^p$$\n有效数是 $(1.b_{p-1}b_{p-2} \\dots b_q)_2$。为了使此表示精确，该数的所有位都必须被有效数捕获。binary64 格式有 53 位的有效数。这意味着从前导的 $1$（在位置 $p$）到最后的 $1$（在位置 $q$）的总位数最多为 $53$。这些位的数量是 $p - q + 1$。这恰好是奇数部分 $O$ 的二进制表示中的位数。\n\n设 $O$ 中的位数为 $L_O$。精确表示的条件是 $L_O \\le 53$。一个需要 $L_O$ 位的整数 $O$ 满足 $2^{L_O-1} \\le O  2^{L_O}$。因此，条件 $L_O \\le 53$ 等价于 $O  2^{53}$。\n\n我们的任务是找到最大的整数 $n$，使得 $n!$ 可以被精确表示。这要求 $n!$ 的奇数部分（我们记作 $O_n$）必须满足条件：\n$$O_n  2^{53}$$\n对两边取以 2 为底的对数，这等价于：\n$$\\log_2(O_n)  53$$\n$n!$ 的奇数部分由 $O_n = \\frac{n!}{2^{v_2(n!)}}$ 给出，其中 $v_2(n!)$ 是能整除 $n!$ 的 2 的最高次幂的指数。根据勒让德公式 (Legendre's formula)，该指数计算如下：\n$$v_2(n!) = \\sum_{i=1}^{\\infty} \\left\\lfloor \\frac{n}{2^i} \\right\\rfloor$$\n让我们定义函数 $L(n) = \\log_2(O_n)$。我们有：\n$$L(n) = \\log_2\\left(\\frac{n!}{2^{v_2(n!)}}\\right) = \\log_2(n!) - v_2(n!)$$\n函数 $L(n)$ 对于 $n \\ge 1$ 是单调不减的。为了找到满足条件的最大整数 $n$，我们必须找到 $L(n)$ 穿过阈值 $53$ 的点。我们将计算不同 $n$ 值对应的 $L(n)$，直到这种情况发生。\n\n让我们计算 $n=22$ 时的 $L(n)$：\n$$v_2(22!) = \\left\\lfloor \\frac{22}{2} \\right\\rfloor + \\left\\lfloor \\frac{22}{4} \\right\\rfloor + \\left\\lfloor \\frac{22}{8} \\right\\rfloor + \\left\\lfloor \\frac{22}{16} \\right\\rfloor = 11 + 5 + 2 + 1 = 19$$\n现在我们计算 $\\log_2(22!)$：\n$$\\log_2(22!) = \\sum_{k=1}^{22} \\log_2(k) = \\frac{1}{\\ln(2)} \\sum_{k=1}^{22} \\ln(k)$$\n为了保证精度，使用计算工具：\n$$\\ln(22!) \\approx 48.465903$$\n$$\\log_2(22!) \\approx \\frac{48.465903}{0.693147} \\approx 69.92164$$\n所以，对于 $n=22$：\n$$L(22) = \\log_2(22!) - v_2(22!) \\approx 69.92164 - 19 = 50.92164$$\n因为 $L(22) \\approx 50.92164  53$，所以数字 $22!$ 可以在 binary64 格式中精确表示。\n\n现在，让我们计算 $n=23$ 时的 $L(n)$：\n数字 $23$ 是奇数，所以它的奇数部分就是 $23$ 本身。$23!$ 的奇数部分与 $22!$ 的奇数部分关系如下：\n$$O_{23} = O_{22} \\times 23$$\n取以 2 为底的对数：\n$$L(23) = \\log_2(O_{23}) = \\log_2(O_{22}) + \\log_2(23) = L(22) + \\log_2(23)$$\n我们计算 $\\log_2(23)$：\n$$\\log_2(23) = \\frac{\\ln(23)}{\\ln(2)} \\approx \\frac{3.135494}{0.693147} \\approx 4.52356$$\n所以，对于 $n=23$：\n$$L(23) \\approx 50.92164 + 4.52356 = 55.4452$$\n因为 $L(23) \\approx 55.4452 > 53$，所以 $23!$ 的奇数部分大于 $2^{53}$，因此 $23!$ 不能被精确表示。\n\n因为 $L(n)$ 是一个关于 $n$ 的非递减函数，并且我们已经发现 $L(22)  53$ 且 $L(23) > 53$，所以使得 $n!$ 在 binary64 格式中可精确表示的最大整数 $n$ 是 $22$。\n\n我们还应该确认指数在 binary64 的允许范围内。规格化数 $N = O_n \\times 2^{v_2(n!)}$ 的指数大约是 $p = v_2(n!) + \\lfloor \\log_2(O_n) \\rfloor$。对于 $n=22$：\n$$p_{22} = v_2(22!) + \\lfloor L(22) \\rfloor = 19 + \\lfloor 50.92164 \\rfloor = 19 + 50 = 69$$\nIEEE 754 binary64 格式使用 11 位指数，偏置值为 1023。可存储的指数范围是从 $1-1023=-1022$ 到 $2046-1023=1023$。值 $69$ 完全在此范围内。因此，限制因素确实是有效数的精度，而不是指数的范围。",
            "answer": "$$\n\\boxed{22}\n$$"
        },
        {
            "introduction": "有效数字丢失最常见的原因之一是“灾难性抵消”（catastrophic cancellation），即两个几乎相等的数相减。本练习提供了一个这一现象的经典案例，并引导你使用一个简单的代数技巧将表达式重构为一个数值稳定的形式。掌握这项技能是编写稳健科学计算代码的基础。",
            "id": "3273448",
            "problem": "在数值分析中广泛接受的标准浮点运算模型中，对实数 $y$ 的每次基本运算都会产生一个浮点结果 $\\operatorname{fl}(y)$，该结果满足 $\\operatorname{fl}(y) = y(1+\\delta)$，其中 $|\\delta| \\leq u$，$u$ 表示单位舍入误差。当相减两个几乎相等的数时，会发生有效位损失（loss of significance），因为每一项独立舍入所引入的相对误差可能会远大于微小的真实差值。\n\n考虑函数 $f(x) = \\sqrt{x+1} - \\sqrt{x}$，其中 $x  0$ 且为大数。仅使用基本代数恒等式和上述误差模型作为基础，为 $f(x)$ 推导出一个代数上等价的表达式，以避免当 $x$ 很大时因相减抵消（subtractive cancellation）而导致的有效位损失。你的推导必须清楚地说明为什么新表达式对舍入误差不那么敏感。请将最终表达式以关于 $x$ 的单一闭式解析函数的形式给出。无需进行数值近似或舍入。你的最终答案应该是一个关于 $x$ 的单一解析表达式。",
            "solution": "出发点是浮点误差模型 $\\operatorname{fl}(y) = y(1+\\delta)$（其中 $|\\delta| \\leq u$）以及一个观察：相减两个几乎相等的数会放大相对误差。对于函数 $f(x) = \\sqrt{x+1} - \\sqrt{x}$，当 $x$ 很大时，$\\sqrt{x+1}$ 和 $\\sqrt{x}$ 在量级上非常接近：具体来说，对于大 $x$，\n$$\n\\sqrt{x+1} \\approx \\sqrt{x} + \\frac{1}{2\\sqrt{x}},\n$$\n因此 $f(x)$ 是一个小量，数量级为 $\\frac{1}{2\\sqrt{x}}$，而每一项 $\\sqrt{x+1}$ 和 $\\sqrt{x}$ 的数量级均为 $\\sqrt{x}$。两个大的、几乎相等的项相减产生一个小的结果，这个结果很容易因为每一项的舍入而产生巨大的相对误差。\n\n为了避免相减抵消，我们寻找一个代数上等价的、不需要相减两个几乎相等数值的形式。一个适用于此变换的基本恒等式是平方差恒等式：\n$$\n(a - b)(a + b) = a^{2} - b^{2}.\n$$\n令 $a = \\sqrt{x+1}$ 且 $b = \\sqrt{x}$。则\n$$\n(\\sqrt{x+1} - \\sqrt{x})(\\sqrt{x+1} + \\sqrt{x}) = (x+1) - x = 1.\n$$\n假设 $x  0$，从而所有平方根和加和均为正且非零，我们可以将等式两边同除以 $\\sqrt{x+1} + \\sqrt{x}$ 得到\n$$\n\\sqrt{x+1} - \\sqrt{x} = \\frac{1}{\\sqrt{x+1} + \\sqrt{x}}.\n$$\n该表达式与原表达式代数等价，但避免了几乎相等数值的相减。在浮点运算中，计算 $\\sqrt{x+1}$ 和 $\\sqrt{x}$ 仍然会引入至多为 $u$ 的微小相对误差，但构造 $\\sqrt{x+1} + \\sqrt{x}$ 是将两个正项相加，得到一个量级约为 $2\\sqrt{x}$ 的结果，这是良态的（well conditioned）。随后的倒数运算不会重新引入相消问题。\n\n为了证明其数值行为得到了改善，我们考虑在浮点模型下的误差传播。令 $\\widehat{a} = \\operatorname{fl}(\\sqrt{x+1}) = \\sqrt{x+1}(1+\\delta_{1})$ 且 $\\widehat{b} = \\operatorname{fl}(\\sqrt{x}) = \\sqrt{x}(1+\\delta_{2})$，其中 $|\\delta_{1}|, |\\delta_{2}| \\leq u$。在相减形式中，计算出的差值为\n$$\n\\operatorname{fl}(\\widehat{a} - \\widehat{b}) \\approx (\\sqrt{x+1} - \\sqrt{x}) + \\sqrt{x+1}\\,\\delta_{1} - \\sqrt{x}\\,\\delta_{2},\n$$\n因此绝对误差的数量级为 $\\sqrt{x}\\,u$，而真实值的数量级为 $\\frac{1}{2\\sqrt{x}}$，这导致相对误差的数量级为 $2x u$，该误差随 $x$ 增长，当 $x$ 很大时可能非常大。相比之下，在改写的形式中，\n$$\nf(x) = \\frac{1}{\\sqrt{x+1} + \\sqrt{x}},\n$$\n计算出的分母 $\\operatorname{fl}(\\widehat{a} + \\widehat{b})$ 的相对误差被一个小的 $u$ 的倍数所界定，且分母本身的数量级为 $2\\sqrt{x}$，因此分母的绝对误差数量级为 $\\sqrt{x}\\,u$。最终倒数的相对误差的数量级则为 $u$，与 $x$ 无关，这对于大 $x$ 来说是数值稳定的。\n\n因此，数值上稳定且代数上等价的表达式是\n$$\n\\frac{1}{\\sqrt{x+1} + \\sqrt{x}}.\n$$",
            "answer": "$$\\boxed{\\frac{1}{\\sqrt{x+1}+\\sqrt{x}}}$$"
        },
        {
            "introduction": "在灾难性抵消概念的基础上，本练习将展示其在真实世界场景——计算统计方差——中的巨大影响。你将通过编程比较一个“朴素”的单遍扫描公式和一个更稳健的两遍扫描算法。这个动手实践任务将通过实验证明，一个代数上完全正确的公式为何在浮点运算中可能得出灾难性的错误结果，并凸显算法选择对数值精度的关键作用。",
            "id": "3273473",
            "problem": "考虑在浮点运算中从有限数据集计算总体方差。总体方差根据第一性原理定义为 $$\\mathrm{Var}(x) = \\frac{1}{n}\\sum_{i=1}^{n}\\left(x_i - \\mu\\right)^2,\\quad \\mu = \\frac{1}{n}\\sum_{i=1}^{n}x_i,$$ 其中 $n$ 是数据点的数量。在遵循 IEEE 754 标准（Institute of Electrical and Electronics Engineers 754）的 binary64 格式（通常称为双精度）的浮点运算中，每个基本运算被建模为 $$\\mathrm{fl}(a \\circ b) = (a \\circ b)(1+\\delta),\\quad |\\delta| \\le u,$$ 其中 $u$ 是单位舍入误差。对于就近舍入，$u = 2^{-53}$。\n\n你的任务是编写一个完整的程序，经验性地分析当数据集具有大位置偏移和小离差时，方差计算的有效位损失。具体来说：\n\n1) 在 binary64 运算中实现两种方差计算方法：\n   - 一种“基于定义”的两遍扫描计算方法，直接评估 $$\\mathrm{Var}(x) = \\frac{1}{n}\\sum_{i=1}^{n}\\left(x_i - \\mu\\right)^2,$$ 其中 $\\mu$ 在第一遍扫描中计算，而离差平方和在第二遍扫描中计算。\n   - 一种单遍扫描计算方法，在单次遍历中仅累加 $x_i$ 和 $x_i^2$ 的和，然后使用标准实数代数从这两个和构建代数上等价的总体方差。除了这次单次遍历和最终的代数组合外，不要使用补偿求和或任何多遍扫描校正。\n\n2) 使用以下确定性数据集测试套件。对于每个测试，通过选择一个具有相等数量的整数模式 $k_i \\in \\{-1,0,+1\\}$ 以使得 $\\sum_{i=1}^{n} k_i = 0$，然后设置 $$x_i = M + d\\,k_i.$$ 具体来说，取前 $n/3$ 个条目，其 $k_i = -1$，接下来的 $n/3$ 个条目，其 $k_i = 0$，最后 $n/3$ 个条目，其 $k_i = +1$。这在实数运算中产生等于 $$V_{\\mathrm{true}} = \\mathbb{E}[d^2 k^2] = \\frac{2}{3}\\,d^2$$ 的精确总体方差。\n\n   使用这四个测试用例（每个用例的 $n$ 都能被 $3$ 整除）：\n   - 测试 A：$n = 6000$, $M = 0$, $d = 10^{-3}$。\n   - 测试 B：$n = 6000$, $M = 10^{6}$, $d = 1$。\n   - 测试 C：$n = 6000$, $M = 10^{12}$, $d = 1$。\n   - 测试 D：$n = 6000$, $M = 10^{16}$, $d = 1$。\n\n3) 对每个测试用例，计算：\n   - 如上所述的朴素单遍扫描方差值 $V_{\\mathrm{naive}}$。\n   - 如上所述的两遍扫描方差值 $V_{\\mathrm{2pass}}$。\n   - 朴素方法相对于精确实数值方差 $V_{\\mathrm{true}}$ 的相对误差：$$\\varepsilon_{\\mathrm{rel}} = \\frac{|V_{\\mathrm{naive}} - V_{\\mathrm{true}}|}{V_{\\mathrm{true}}}.$$\n   - 朴素方法实现的正确有效位数，定义为 $$D_{\\mathrm{ach}} = \\max\\left(0,\\;\\min\\left(-\\log_{10}(\\varepsilon_{\\mathrm{rel}}),\\;-\\log_{10}(u)\\right)\\right),$$ 其中以 $-\\log_{10}(u)$ 作为上限反映了 binary64 运算中可能达到的最佳位数。\n   - 基于对消分析，对朴素方法保留的正确有效位数的第一性原理预测。当 $|M| \\gg |d|$ 时，朴素公式会减去两个量级为 $\\Theta(n M^2)$ 的几乎相等的大数值的和，以获得一个量级为 $\\Theta(n d^2)$ 的结果，因此一个粗略模型给出 $$\\varepsilon_{\\mathrm{rel}} \\approx C\\,u\\left(\\frac{M}{d}\\right)^2,$$ 其中 $C$ 是某个量级为 1 且依赖于问题的常数。通过忽略 $C$ 并以 $-\\log_{10}(u)$ 设上限，将其转换为位数预测：$$D_{\\mathrm{pred}} = \\max\\left(0,\\;\\min\\left(-\\log_{10}(u) - 2\\log_{10}\\left(\\frac{|M|}{|d|}\\right),\\;-\\log_{10}(u)\\right)\\right),$$ 并约定如果 $M = 0$，则 $D_{\\mathrm{pred}} = -\\log_{10}(u)$。\n\n4) 最终输出格式。你的程序应该生成单行输出，包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个测试用例贡献一个按顺序为 $[\\varepsilon_{\\mathrm{rel}}, D_{\\mathrm{ach}}, D_{\\mathrm{pred}}]$ 的方括号括起来的3元组。因此，完整输出是形如\n   $$[[e_A, dA_{\\mathrm{ach}}, dA_{\\mathrm{pred}}],[e_B, dB_{\\mathrm{ach}}, dB_{\\mathrm{pred}}],[e_C, dC_{\\mathrm{ach}}, dC_{\\mathrm{pred}}],[e_D, dD_{\\mathrm{ach}}, dD_{\\mathrm{pred}}]].$$\n\n约束和说明：\n- 仅使用 binary64 运算；不要使用扩展精度、任意精度、补偿求和或随机舍入。\n- 所有答案都是没有物理单位的纯数字。\n- 不涉及角度。\n- 输出必须是指定方括号列表格式的单行，且不含空格。",
            "solution": "用户的问题陈述已经过严格验证，并被确定为 **有效的**。这是一个在数值分析领域内适定、有科学依据的问题，没有矛盾、歧义或事实错误。\n\n目标是经验性地分析两种计算数据集总体方差的不同算法的数值稳定性，特别是在存在相对于数据离差的大均值偏移的情况下。该分析将使用 binary64 浮点运算进行。\n\n数据集 $\\{x_i\\}_{i=1}^{n}$ 的总体方差定义为与总体均值 $\\mu$ 的离差平方的均值：\n$$\n\\mathrm{Var}(x) = \\frac{1}{n}\\sum_{i=1}^{n}\\left(x_i - \\mu\\right)^2, \\quad \\text{其中} \\quad \\mu = \\frac{1}{n}\\sum_{i=1}^{n}x_i\n$$\n\n我们被要求实现并比较两种计算方法：\n\n1. **两遍扫描算法**：该方法直接实现其定义。\n    - **第一遍**：计算均值 $\\mu = \\frac{1}{n}\\sum_{i=1}^{n}x_i$。\n    - **第二遍**：使用预先计算的均值计算离差平方和，得到 $\\mathrm{Var}_{\\mathrm{2pass}}(x) = \\frac{1}{n}\\sum_{i=1}^{n}(x_i - \\mu)^2$。\n    该算法通常是数值稳定的。通过先计算均值然后计算离差，它在平方之前将数据以0为中心。这可以防止在原始数据 $x_i$ 远离原点时，中间量 $(x_i - \\mu)^2$ 变得过大，从而保持精度。\n\n2. **朴素单遍扫描算法**：该方法使用一个代数上等价的公式，推导如下：\n$$\n\\mathrm{Var}(x) = \\mathbb{E}[(x-\\mu)^2] = \\mathbb{E}[x^2 - 2x\\mu + \\mu^2] = \\mathbb{E}[x^2] - 2\\mu\\mathbb{E}[x] + \\mu^2 = \\mathbb{E}[x^2] - 2\\mu^2 + \\mu^2 = \\mathbb{E}[x^2] - \\mu^2\n$$\n用求和的形式表示为：\n$$\n\\mathrm{Var}_{\\mathrm{naive}}(x) = \\left(\\frac{1}{n}\\sum_{i=1}^{n}x_i^2\\right) - \\left(\\frac{1}{n}\\sum_{i=1}^{n}x_i\\right)^2\n$$\n这允许通过同时累加 $\\sum x_i$ 和 $\\sum x_i^2$ 来在单遍扫描中计算方差。然而，如果标准差远小于均值，该方法在数值上是不稳定的。如果数据点 $x_i$ 都聚集在远离原点的地方，即对于一个大的 $M$ 有 $x_i \\approx M$，那么 $\\mathbb{E}[x^2] \\approx M^2$ 且 $\\mu^2 \\approx M^2$。该公式涉及两个几乎相等的大数相减，这个操作被称为**灾难性对消**，会导致严重的精度损失。\n\n该问题定义了一个特定的测试套件来展示这种效应。数据集被构建为 $x_i = M + d\\,k_i$，其中 $n$ 是点的总数，对于每个 $k_i \\in \\{-1, 0, +1\\}$ 我们都有 $n/3$ 个点。\n对于这种数据集结构，实数运算中的精确均值为：\n$$\n\\mu = \\mathbb{E}[M+d k] = M + d\\,\\mathbb{E}[k] = M + d\\left(\\frac{1}{3}(-1) + \\frac{1}{3}(0) + \\frac{1}{3}(+1)\\right) = M\n$$\n实数运算中的精确总体方差 $V_{\\mathrm{true}}$ 为：\n$$\nV_{\\mathrm{true}} = \\mathrm{Var}(x) = \\mathbb{E}[(x-\\mu)^2] = \\mathbb{E}[((M+dk) - M)^2] = \\mathbb{E}[(dk)^2] = d^2\\mathbb{E}[k^2]\n$$\n$k^2$ 的期望值为：\n$$\n\\mathbb{E}[k^2] = \\frac{1}{3}(-1)^2 + \\frac{1}{3}(0)^2 + \\frac{1}{3}(+1)^2 = \\frac{1}{3} + 0 + \\frac{1}{3} = \\frac{2}{3}\n$$\n因此，所有测试用例的精确方差为 $V_{\\mathrm{true}} = \\frac{2}{3}d^2$。\n\n这四个测试用例旨在改变比率 $|M/d|$：\n-   测试 A：$n = 6000$, $M = 0$, $d = 10^{-3}$。此处 $|M/d| = 0$。\n-   测试 B：$n = 6000$, $M = 10^{6}$, $d = 1$。此处 $|M/d| = 10^6$。\n-   测试 C：$n = 6000$, $M = 10^{12}$, $d = 1$。此处 $|M/d| = 10^{12}$。\n-   测试 D：$n = 6000$, $M = 10^{16}$, $d = 1$。此处 $|M/d| = 10^{16}$。\n\n对于每个测试，我们将为朴素方法计算以下量：\n1. 相对误差 $\\varepsilon_{\\mathrm{rel}} = \\frac{|V_{\\mathrm{naive}} - V_{\\mathrm{true}}|}{V_{\\mathrm{true}}}$。\n2. 实现的有效位数 $D_{\\mathrm{ach}} = \\max\\left(0,\\;\\min\\left(-\\log_{10}(\\varepsilon_{\\mathrm{rel}}),\\;-\\log_{10}(u)\\right)\\right)$。这量化了实际精度，以 binary64 运算的理论最大精度为上限，其中 $u = 2^{-53}$ 是单位舍入误差，且 $-\\log_{10}(u) \\approx 15.95$。\n3. 预测的有效位数 $D_{\\mathrm{pred}}$。这基于灾难性对消的一阶误差分析，该分析表明相对误差增长为 $\\varepsilon_{\\mathrm{rel}} \\propto u(M/d)^2$。忽略比例常数，损失的位数约为 $2\\log_{10}(|M/d|)$。因此，预测由 $D_{\\mathrm{pred}} = \\max\\left(0,\\;\\min\\left(-\\log_{10}(u) - 2\\log_{10}\\left(\\frac{|M|}{|d|}\\right),\\;-\\log_{10}(u)\\right)\\right)$ 给出。对于 $M=0$，不会发生对消，预测的位数为最大值，即 $-\\log_{10}(u)$。\n\n程序将遍历四个测试用例，为每个用例构建数据集，计算 $V_{\\mathrm{naive}}$，然后计算元组 $(\\varepsilon_{\\mathrm{rel}}, D_{\\mathrm{ach}}, D_{\\mathrm{pred}})$。最终输出将是这些元组的列表。\n正如预期的那样，结果将显示对于测试 A ($M=0$)，朴素方法是高度准确的。对于测试 B、C 和 D，随着比率 $|M/d|$ 的增加，灾难性对消变得更加严重，导致相对误差急剧增加，相应地，正确有效位数减少，实现的位数与理论预测紧密匹配。测试 C 和 D 很可能会导致有效数字完全丢失。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef naive_variance(x: np.ndarray) - float:\n    \"\"\"\n    Computes variance using the unstable single-pass algorithm.\n    Var(x) = E[x^2] - (E[x])^2\n    \"\"\"\n    n = len(x)\n    sum_x = np.sum(x)\n    sum_x_sq = np.sum(x * x)\n    # Using float64 for all calculations to emulate binary64\n    mean_of_squares = sum_x_sq / n\n    square_of_mean = (sum_x / n)**2\n    return mean_of_squares - square_of_mean\n\ndef two_pass_variance(x: np.ndarray) - float:\n    \"\"\"\n    Computes variance using the stable two-pass algorithm.\n    Var(x) = E[(x - E[x])^2]\n    \"\"\"\n    n = len(x)\n    # Pass 1: compute the mean\n    mu = np.sum(x) / n\n    # Pass 2: compute the sum of squared deviations\n    sum_sq_dev = np.sum((x - mu)**2)\n    return sum_sq_dev / n\n\ndef solve():\n    \"\"\"\n    Main function to run the analysis and produce the final output.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple (n, M, d).\n    test_cases = [\n        (6000, 0.0, 1e-3),\n        (6000, 1e6, 1.0),\n        (6000, 1e12, 1.0),\n        (6000, 1e16, 1.0),\n    ]\n\n    # Unit roundoff for binary64 (double precision)\n    u = 2**-53\n    log10_u = np.log10(u)\n    \n    results = []\n    \n    for n, M, d in test_cases:\n        # 1. Construct the dataset x_i = M + d*k_i\n        n_div_3 = n // 3\n        # Ensure data is float64 (binary64)\n        x = np.concatenate([\n            np.full(n_div_3, M - d, dtype=np.float64),\n            np.full(n_div_3, M, dtype=np.float64),\n            np.full(n_div_3, M + d, dtype=np.float64),\n        ])\n\n        # 2. Compute true variance, V_naive, and V_2pass\n        V_true = (2.0 / 3.0) * d**2\n        V_naive = naive_variance(x)\n        # V_2pass is computed as required by the problem description,\n        # though not used in the final output values. It serves as a\n        # demonstration of a stable algorithm.\n        V_2pass = two_pass_variance(x)\n\n        # 3. Compute relative error of the naive method\n        # Handle the case where V_true is zero (not in this problem)\n        if V_true == 0.0:\n            epsilon_rel = 0.0 if V_naive == 0.0 else np.inf\n        else:\n            epsilon_rel = np.abs(V_naive - V_true) / V_true\n\n        # 4. Compute achieved significant digits\n        # Handle epsilon_rel = 0 to avoid log10(0)\n        if epsilon_rel == 0.0:\n            d_achieved = -log10_u\n        else:\n            d_achieved = np.max([0.0, np.min([-np.log10(epsilon_rel), -log10_u])])\n\n        # 5. Compute predicted significant digits\n        if M == 0.0:\n            d_predicted = -log10_u\n        else:\n            # Note: np.abs is used just in case of negative M or d.\n            log10_ratio = np.log10(np.abs(M) / np.abs(d))\n            pred_val = -log10_u - 2.0 * log10_ratio\n            d_predicted = np.max([0.0, np.min([pred_val, -log10_u])])\n        \n        results.append([epsilon_rel, d_achieved, d_predicted])\n\n    # Final print statement in the exact required format.\n    # Build the string representation manually to avoid spaces.\n    formatted_results = []\n    for res in results:\n        # e.g., res is [1.0, 2.0, 3.0]\n        # creates string \"[1.0,2.0,3.0]\"\n        formatted_results.append(f\"[{res[0]},{res[1]},{res[2]}]\")\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}