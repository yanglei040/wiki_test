{
    "hands_on_practices": [
        {
            "introduction": "理论知识是基础，但真正的理解始于实践。本节的第一个练习将带你深入浮点数的核心结构。我们将通过一个具体的例子，手动将一个32位二进制模式解码为其对应的十进制值，从而巩固你对符号、指数和尾数如何协同工作的理解。这个基础练习是理解更复杂数值问题的关键第一步。",
            "id": "1948832",
            "problem": "在一个32位微处理器架构中，一个浮点单元寄存器包含十六进制值 $0xC1E80000$。该值需要根据电气和电子工程师协会 (IEEE) 754 单精度浮点数标准进行解释。\n\n32位单精度格式的结构如下：\n- 1位符号字段 (S)，位于第31位（最高有效位）。\n- 8位偏置指数字段 (E)，位于第30位到第23位。\n- 23位小数部分字段 (F)，位于第22位到第0位。\n\n对于一个规格化数（指数字段不全为0也不全为1），其十进制值由公式 $N = (-1)^S \\times (1.F)_2 \\times 2^{(E - \\text{bias})}$ 给出，其中 $(1.F)_2$ 表示隐含的前导1后跟小数部分位，并解释为一个二进制数。单精度的指数偏置值为127。\n\n确定由位模式 $0xC1E80000$ 表示的数的十进制值。",
            "solution": "根据IEEE 754单精度标准，字段包括：符号位 $S$（第31位）、指数字段 $E$（第30位到第23位）和小数部分字段 $F$（第22位到第0位）。对于规格化数，其值为 $N = (-1)^{S} \\times (1.F)_{2} \\times 2^{(E - 127)}$。\n\n十六进制值 $0x\\text{C1E80000}$ 的二进制表示分组为 $1100\\,0001\\,1110\\,1000\\,0000\\,0000\\,0000\\,0000$。符号位是 $S = 1$（负数）。指数位（第30位到第23位）是 $(10000011)_{2}$，所以\n$$\nE = 1 \\cdot 2^{7} + 0 \\cdot 2^{6} + \\cdots + 0 \\cdot 2^{2} + 1 \\cdot 2^{1} + 1 \\cdot 2^{0} = 128 + 2 + 1 = 131.\n$$\n由于 $E \\neq 0$ 且 $E \\neq 255$，该数是规格化的，无偏指数为\n$$\ne = E - 127 = 131 - 127 = 4.\n$$\n小数部分字段 $F$ 在第22、21和19位（从第22位向下计数）有非零位，所以尾数是\n$$\n(1.F)_{2} = 1 + 2^{-1} + 2^{-2} + 2^{-4} = 1 + \\frac{1}{2} + \\frac{1}{4} + \\frac{1}{16} = \\frac{29}{16}.\n$$\n因此，表示的值是\n$$\nN = (-1)^{1} \\times \\frac{29}{16} \\times 2^{4} = - \\frac{29}{16} \\times 16 = -29.\n$$",
            "answer": "$$\\boxed{-29}$$"
        },
        {
            "introduction": "在理解了浮点数的内部构造后，我们自然会问：它的表示能力有何限制？这个练习将挑战一个常见的误解，即计算机可以精确表示所有整数。通过从第一性原理出发，寻找第一个无法用 `binary32` 格式精确表示的正整数，你将深刻体会到浮点数精度有限且分布不均的本质。",
            "id": "3210700",
            "problem": "一个模拟系统以 Institute of Electrical and Electronics Engineers (IEEE) 754 单精度二进制浮点格式（通常称为 binary32）记录非负整数事件计数。一个 binary32 数使用 $1$ 个符号位、一个偏置为 $127$ 的 $8$ 位指数场以及一个 $23$ 位小数场；规格化值在有效数中有一个隐含的前导 $1$，从而产生 $24$ 位的精度。仅使用规格化二进制浮点表示的核心定义和关于二进制展开的第一性原理推导，确定不能在 binary32 中被精确表示的最小正整数 $n$。然后，令 $x$ 表示严格大于 $n$ 的最小可由 binary32 表示的实数；定义间隙 $g$ 为 $g = x - n$。通过分析在 $n$ 的量级上可表示值的间距，从第一性原理计算 $g$。提供 $n$ 和 $g$ 的最终答案，形式为精确值。无需四舍五入，不涉及单位。",
            "solution": "题目要求我们确定不能用 IEEE 754 单精度（binary32）格式精确表示的最小正整数 $n$，然后计算 $n$ 与下一个更大的可表示数之间的间隙 $g$。该分析将从第一性原理出发，基于 binary32 浮点数的结构进行。\n\n一个 binary32 格式的数表示为 $v = (-1)^s \\times M \\times 2^E$，其中 $s$ 是符号位，$M$ 是有效数，$E$ 是指数。题目说明我们处理的是非负整数，所以符号位 $s$ 为 $0$。\n\nbinary32 格式规定了一个8位指数场和一个23位小数场。对于规格化数，有效数 $M$ 有一个隐含的前导位 $1$。它的形式为 $M = (1.f)_{2}$，其中 $f$ 是23位的小数部分。这意味着有效数由1个整数位和23个小数位组成，总精度为 $p=24$ 位。小数部分 $f$ 可以写成一个和式：\n$$f = \\sum_{i=1}^{23} d_i 2^{-i}$$\n其中每个 $d_i$ 为0或1。因此有效数为 $M = 1 + f$。指数 $E$ 是通过8位指数场的值 $e$ 使用127的偏置计算得出的，即 $E = e - 127$。对于规格化数，$1 \\le e \\le 254$，这对应于指数范围 $-126 \\le E \\le 127$。\n\n一个整数可以被精确表示，当且仅当它能使用允许的小数 $f$ 和指数 $E$ 写成 $v = (1.f)_2 \\times 2^E$ 的形式。这当且仅当该整数的二进制表示可以用不超过24个有效位来表示时才可能。\n\n让我们检查一些整数，以找到最小的不可表示的整数。\n任何整数 $I$ 都可以用二进制写成 $(b_k b_{k-1} \\dots b_1 b_0)_2$。要将其表示为规格化浮点形式，我们将其写为 $(1.b_{k-1} \\dots b_0)_2 \\times 2^k$。有效数是 $(1.b_{k-1} \\dots b_0)_2$。小数部分有 $k$ 位。为了能在 binary32 中表示，小数部分的位数最多为23位。这个条件是 $k \\le 23$。整数 $I$ 的总有效位数为 $k+1$。所以，如果 $k+1 \\le 24$，该整数是可表示的。\n\n这意味着所有可以用最多24个有效位写出的整数都可以被精确表示。最大的这类整数是其二进制表示由24个1组成：\n$$ 2^{24} - 1 = \\sum_{i=0}^{23} 2^i = (11\\dots1)_{2} \\quad (24 \\text{ 个1}) $$\n这个数可以写成 $(1.11\\dots1)_2 \\times 2^{23}$（小数点后有23个1），它是完全可以表示的，因为小数部分符合23位的可用空间。\n\n现在，考虑下一个整数，$2^{24}$。在二进制中，这是一个1后面跟着24个0：$(100\\dots0)_{2}$。这个数在其标准整数表示中有25位。然而，在科学记数法中，它是 $(1.0)_2 \\times 2^{24}$。\n- 有效数是 $M=1.0$。小数部分是 $f=0$。这是可以表示的。\n- 指数是 $E=24$。编码后的指数将是 $e = E + 127 = 24 + 127 = 151$。由于 $1 \\le 151 \\le 254$，这是一个规格化数的有效指数。\n因此，整数 $2^{24}$ 在 binary32 中是可精确表示的。\n\n因此，从1到 $2^{24}$ 的所有整数都是可精确表示的。\n\n让我们检查下一个整数，$n = 2^{24} + 1$。它的值是 $16,777,216 + 1 = 16,777,217$。$n$ 的二进制表示是：\n$$ n = (1000000000000000000000001)_2 $$\n这由位置24上的一个1和位置0上的一个1组成。要将其表示为规格化浮点形式，我们必须将其写为：\n$$ n = (1.000000000000000000000001)_2 \\times 2^{24} $$\n所需的有效数是 $M = 1 + 2^{-24}$。所需的小数部分是 $f = 2^{-24}$。\nbinary32 格式的23位小数场只能表示 $\\sum_{i=1}^{23} d_i 2^{-i}$ 形式的分数。能形成的最小非零项是 $2^{-23}$。不可能形成 $2^{-24}$ 这一项。因此，有效数 $1+2^{-24}$ 无法被创建，且整数 $n=2^{24}+1$ 不能被精确表示。这使其成为不能被精确表示的最小正整数。\n所以，$n = 2^{24} + 1 = 16,777,217$。\n\n接下来，我们必须找到严格大于 $n$ 的最小的可由 binary32 表示的实数 $x$，并计算间隙 $g=x-n$。\n量级接近 $n = 2^{24}+1$ 的数落在指数为 $E=24$ 的范围内。对于区间 $[2^{24}, 2^{25})$ 内的任何数 $v$，其指数为 $E=24$。\n在此范围内的可表示数具有以下形式：\n$$ v = (1.f_1f_2\\dots f_{23})_2 \\times 2^{24} $$\n小数部分的值 $f = \\sum_{i=1}^{23} d_i 2^{-i}$，可以表示为 $k \\cdot 2^{-23}$，其中 $k$ 是一个整数且 $0 \\le k \\le 2^{23}-1$。\n将此代入 $v$ 的表达式中：\n$$ v_k = (1 + k \\cdot 2^{-23}) \\times 2^{24} = 2^{24} + k \\cdot 2^{24-23} = 2^{24} + 2k $$\n这表明对于整数 $k \\ge 0$，在这个量级上的可表示数是 $2^{24}$、$2^{24}+2$、$2^{24}+4$ 等等。连续可表示数之间的间距是2。这个间距被称为该范围内的“末位单位”(Unit in the Last Place, ULP)。\n\n我们的不可表示整数是 $n = 2^{24}+1$。我们可以将其置于两个连续的可表示数之间：\n$$ 2^{24}  2^{24}+1  2^{24}+2 $$\n题目要求的是 $x$，即严格大于 $n$ 的最小可由 binary32 表示的实数。根据上面的不等式，这个数必须是 $x = 2^{24}+2$。\n\n最后，我们计算由 $g = x - n$ 定义的间隙 $g$：\n$$ g = (2^{24}+2) - (2^{24}+1) = 1 $$\n\n这两个值是 $n=2^{24}+1 = 16,777,217$ 和 $g=1$。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 16777217  1 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "在掌握了浮点数的表示法及其限制后，是时候探讨它们在实际计算中可能遇到的陷阱了。本练习通过一个经典的例子——计算两个相近数值的平方差——来揭示灾难性抵消的危害。你将编写代码，比较两种代数上等价的公式 $x^2 - y^2$ 和 $(x-y)(x+y)$ 在二进制和十进制浮点运算中的数值稳定性差异。",
            "id": "3210660",
            "problem": "您需要编写一个完整、可运行的程序，该程序比较两种代数上等价的公式，用于在两种浮点数格式（二进制格式和十进制格式）下计算近似相等的输入的平方差。代数恒等式为 $x^2 - y^2 = (x-y)(x+y)$。要比较的两种公式是：朴素公式 $x^2 - y^2$ 和因式分解公式 $(x-y)(x+y)$。您的程序必须在两种格式下计算这两种公式，相对于高精度参考值测量它们的数值误差，并确定哪种公式能更好地保持有效性。二进制格式应使用电气与电子工程师协会 (IEEE) $754$ 标准（通常称为 binary64）的原生双精度浮点数算术来实现，十进制格式应使用精度为 16 位有效数字且采用“向最近舍入，偶数优先”模式的十进制浮点数算术来实现。\n\n基本推理和设计依据：\n- 浮点表示法通过一组有限的可表示值来近似实数。在 IEEE $754$ 二进制格式中，值被编码为符号、二进制指数和二进制有效数。在十进制浮点数中，值被编码为符号、十进制指数和十进制有效数。\n- 每种浮点数格式都根据一种舍入模式将值舍入到最接近的可表示值。我们将对两种格式都使用“向最近舍入，偶数优先”。\n- 当两个几乎相等的数在有限精度下相减时，会发生相减抵消，导致结果产生巨大的相对误差。代数重构可以减轻或加剧抵消，这取决于计算了哪些中间量。\n\n测量定义：\n- 设 $x$ 和 $y$ 以十进制字符串形式给出；设 $t = x^2 - y^2$ 为高精度参考值，该参考值使用高精度十进制算术计算得出，相对于 binary64 和 16 位十进制算术，这种计算能充分减少舍入效应。\n- 对于一个计算结果 $r$（在任一格式和公式下），定义缩放相对误差\n$$\nE(r; x, y) = \\frac{|r - t|}{\\max\\{ |t|, \\, S \\}}, \\quad \\text{其中} \\quad S = \\left(\\max\\{ |x|, |y| \\}\\right)^2.\n$$\n当 $t = 0$ 时，该定义回退为由自然量级 $S$ 缩放的绝对误差，从而避免了除以零，同时产生一个无量纲的指标。较小的 $E$ 表示更好地保持了有效性。\n\n您的程序必须执行的任务：\n1. 从十进制字符串解析每个测试用例 $(x, y)$。\n2. 使用具有足够高精度（至少 100 个十进制位）和“向最近舍入，偶数优先”模式的十进制算术计算高精度参考值 $t = x^2 - y^2$。\n3. 在 IEEE $754$ binary64 中：\n   - 将 $x$ 和 $y$ 转换为 binary64。\n   - 计算朴素结果 $r_{\\mathrm{bn}} = x^2 - y^2$。\n   - 计算因式分解结果 $r_{\\mathrm{bf}} = (x-y)(x+y)$。\n   - 使用上述定义的高精度 $t$ 和缩放因子 $S$ 计算 $E(r_{\\mathrm{bn}}; x, y)$ 和 $E(r_{\\mathrm{bf}}; x, y)$。\n   - 通过比较 $E(r_{\\mathrm{bf}}; x, y)$ 和 $E(r_{\\mathrm{bn}}; x, y)$ 来确定在 binary64 中哪种更好。\n4. 在具有 16 位有效数字和“向最近舍入，偶数优先”模式的十进制浮点数中：\n   - 将 $x$ 和 $y$ 量化到十进制 16 位上下文中，然后在该上下文中执行算术运算。\n   - 计算朴素结果 $r_{\\mathrm{dn}} = x^2 - y^2$。\n   - 计算因式分解结果 $r_{\\mathrm{df}} = (x-y)(x+y)$。\n   - 如上所述，使用相同的高精度 $t$ 和缩放因子 $S$ 计算 $E(r_{\\mathrm{dn}}; x, y)$ 和 $E(r_{\\mathrm{df}}; x, y)$。\n   - 通过比较 $E(r_{\\mathrm{df}}; x, y)$ 和 $E(r_{\\mathrm{dn}}; x, y)$ 来确定在十进制中哪种更好。\n\n测试套件：\n使用以下六对以十进制字符串形式提供的 $(x,y)$，它们涵盖了典型、边界和边缘情况，包括近似抵消、完全相等、大量级操作数、小量级操作数和异号：\n- 案例 A（1 附近的近似值）：$x = \\text{\"1.0000001\"}$, $y = \\text{\"0.9999999\"}$。\n- 案例 B（非常接近，不对称）：$x = \\text{\"1.0000001\"}$, $y = \\text{\"1.0000000\"}$。\n- 案例 C（非常大、近似相等的整数）：$x = \\text{\"10000000000000001\"}$, $y = \\text{\"9999999999999999\"}$。\n- 案例 D（非常小、近似相等）：$x = \\text{\"1.0000001e-16\"}$, $y = \\text{\"9.999999e-17\"}$。\n- 案例 E（异号，量级近似相等）：$x = \\text{\"10000000000000001\"}$, $y = \\text{\"-9999999999999999\"}$。\n- 案例 F（完全相等）：$x = \\text{\"1.23456789012345\"}$, $y = \\text{\"1.23456789012345\"}$。\n\n最终输出格式：\n- 对于每个测试用例，您的程序必须按以下固定顺序生成一个包含六个元素的列表：\n  - 浮点数 $E(r_{\\mathrm{bn}}; x, y)$，\n  - 浮点数 $E(r_{\\mathrm{bf}}; x, y)$，\n  - 一个布尔值，指示在 binary64 中因式分解公式是否更好（即，$E(r_{\\mathrm{bf}}; x, y)  E(r_{\\mathrm{bn}}; x, y)$ 是否成立），\n  - 浮点数 $E(r_{\\mathrm{dn}}; x, y)$，\n  - 浮点数 $E(r_{\\mathrm{df}}; x, y)$，\n  - 一个布尔值，指示在十进制 16 位算术中因式分解公式是否更好。\n- 将每个案例的列表聚合到一个单一列表中，并将其作为单行打印。具体来说，程序应打印一行，看起来像这样：\n  $$\n  \\texttt{[[e\\_bn\\_A, e\\_bf\\_A, better\\_bin\\_A, e\\_dn\\_A, e\\_df\\_A, better\\_dec\\_A],\\dots,[e\\_bn\\_F, e\\_bf\\_F, better\\_bin\\_F, e\\_dn\\_F, e\\_df\\_F, better\\_dec\\_F]]}\n  $$\n- 所有布尔值、整数和浮点数输出必须是纯数值；不应打印任何额外的文本、单位或注释。\n\n此问题不涉及任何物理单位或角度。所有数字都是无量纲的。确保所有算术和比较都遵循上述描述。参考值、二进制和十进制的计算必须在您的程序内执行；不应要求任何用户输入或外部数据文件。程序必须是确定性的和自包含的。",
            "solution": "该问题要求对计算平方差 $x^2 - y^2$ 的两种代数等价公式，在两种不同的浮点算术系统（标准的 IEEE 754 binary64 格式和 16 位十进制格式）下进行比较分析。目标是量化每种公式的数值误差，并确定哪种公式对于有效性损失更具鲁棒性。\n\n所考察的两种公式是：\n1.  **朴素公式**：$f_n(x, y) = x^2 - y^2$\n2.  **因式分解公式**：$f_f(x, y) = (x-y)(x+y)$\n\n这个问题的核心数值原理是**相减抵消**。当两个几乎相等的数在有限精度算术中相减时，就会发生这种现象。这些数的开头有效数字相互抵消，留下的结果由不太重要且可能不准确的尾随数字主导。这可能导致灾难性的相对精度损失。\n\n在 $x^2 - y^2$ 的背景下，如果 $x$ 和 $y$ 的量级相近 ($|x| \\approx |y|$)，那么 $x^2$ 和 $y^2$ 也将非常接近。朴素公式 $x^2 - y^2$ 会计算这两个几乎相等的中间值然后相减，使其容易受到相减抵消的影响。\n\n相反，因式分解公式 $(x-y)(x+y)$ 计算中间量 $x-y$ 和 $x+y$。\n-   如果 $x \\approx y$ 且它们符号相同，首先计算 $x-y$ 项。虽然这是一个减法，但精度损失发生在不同的阶段。$x-y$ 的值可能很小，但通常可以被精确表示。第二项 $x+y \\approx 2x$ 不涉及抵消。最终的乘积保留了在 $x-y$ 项中捕获的有效性。\n-   如果 $x \\approx -y$，则抵消会发生在 $x+y$ 项中，而 $x-y \\approx 2x$ 将是准确的。在这种情况下，因式分解形式也容易发生抵消，但在一个不同的中间步骤中。朴素形式，即相减两个大的正数（$x^2$ 和 $y^2$），仍然是易受抵消影响的形式。需要仔细分析。当 $x \\approx -y$ 时，如果我们写成 $y = -x + \\delta$，其中 $\\delta$ 很小，那么 $x^2 - y^2$ 不涉及几乎相等的数相减。那么 $x^2-y^2 = x^2 - (-x+\\delta)^2 = x^2 - (x^2 - 2x\\delta + \\delta^2) = 2x\\delta - \\delta^2$。朴素方法会计算 $x^2$ 和 $y^2$ 并相减，这两个值仍然几乎相等，因此不稳定。因式分解形式 $(x-y)(x+y)$ 会计算 $(x-(-x+\\delta))(x+(-x+\\delta)) = (2x-\\delta)(\\delta)$，这应该更稳定。因此，当 $|x| \\approx |y|$ 时，因式分解形式通常更优越。\n\n解决方案将通过为每个测试用例 $(x, y)$ 执行以下步骤来实现：\n\n1.  **高精度参考值**：一个可信的“真”值 $t = x^2 - y^2$ 是使用 100 位精度的十进制算术计算的。这种高精度上下文最大限度地减少了舍入误差，为比较提供了可靠的基线。缩放因子 $S = (\\max(|x|, |y|))^2$ 也是在此上下文中计算的。\n\n2.  **Binary64 算术**：$x$ 和 $y$ 的输入字符串被转换为原生的 IEEE 754 双精度浮点数 (`binary64`)。朴素结果 $r_{\\mathrm{bn}}$ 和因式分解结果 $r_{\\mathrm{bf}}$ 都使用标准浮点运算来计算。\n\n3.  **Decimal16 算术**：建立一个独立的十进制算术上下文，精度为 16 位，舍入模式为“向最近舍入，偶数优先”。输入 $x$ 和 $y$ 被量化到此精度。然后，朴素结果 ($r_{\\mathrm{dn}}$) 和因式分解结果 ($r_{\\mathrm{df}}$) 完全在该十进制上下文中计算。\n\n4.  **误差分析**：对于四个计算结果 $r$ 中的每一个，根据指定公式计算缩放相对误差：\n    $$\n    E(r; x, y) = \\frac{|r - t|}{\\max\\{ |t|, \\, S \\}}\n    $$\n    此计算使用高精度上下文执行，以确保误差测量本身是准确的。结果 $r$（可能是一个 `binary64` 浮点数或一个 `Decimal16` 对象）首先被提升为一个高精度的 `Decimal`，以便与参考值 $t$ 进行精确比较。\n\n5.  **结论**：对于每个算术系统（二进制和十进制），比较两种公式的误差（$E(r_{\\mathrm{bf}})$ vs. $E(r_{\\mathrm{bn}})$ 和 $E(r_{\\mathrm{df}})$ vs. $E(r_{\\mathrm{dn}})$）以确定哪种公式产生了更准确的结果。一个布尔值指示因式分解形式是否更好（即，误差是否严格更小）。\n\n这种系统化的方法将具体展示数值稳定性的原理，并突显二进制和十进制浮点系统在面临有问题计算时的行为差异。测试套件旨在探究各种场景，包括严重抵消、不存在抵消问题的情况，以及初始输入量化误差超过算法选择影响的情况。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom decimal import Decimal, Context, ROUND_HALF_EVEN\n\ndef solve():\n    \"\"\"\n    Compares two formulations for x^2 - y^2 in binary64 and decimal16 floating-point arithmetic.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: nearby around 1\n        (\"1.0000001\", \"0.9999999\"),\n        # Case B: very close, asymmetric\n        (\"1.0000001\", \"1.0000000\"),\n        # Case C: very large, near-equal integers\n        (\"10000000000000001\", \"9999999999999999\"),\n        # Case D: very small, near-equal\n        (\"1.0000001e-16\", \"9.999999e-17\"),\n        # Case E: opposite signs, near equal magnitude\n        (\"10000000000000001\", \"-9999999999999999\"),\n        # Case F: exact equality\n        (\"1.23456789012345\", \"1.23456789012345\"),\n    ]\n\n    # Setup for arithmetic contexts\n    # High-precision for reference calculations\n    ctx_hp = Context(prec=100, rounding=ROUND_HALF_EVEN)\n    # 16-digit decimal for testing\n    ctx_d16 = Context(prec=16, rounding=ROUND_HALF_EVEN)\n\n    results = []\n    \n    for x_str, y_str in test_cases:\n        # 1. High-precision reference computation\n        x_hp = ctx_hp.create_decimal(x_str)\n        y_hp = ctx_hp.create_decimal(y_str)\n\n        # Compute reference t = x^2 - y^2 using the stable factored form in high precision.\n        t_ref = ctx_hp.multiply(ctx_hp.subtract(x_hp, y_hp), ctx_hp.add(x_hp, y_hp))\n        \n        # Compute scale S = (max(|x|,|y|))^2\n        s_scale = ctx_hp.power(max(x_hp.copy_abs(), y_hp.copy_abs()), 2)\n        \n        # Denominator for error formula, handles t=0 case\n        error_denominator = max(t_ref.copy_abs(), s_scale)\n        # Avoid division by zero if x=y=0 (not in test suite, but good practice)\n        if error_denominator == 0:\n            error_denominator = Decimal(1)\n\n        # 2. IEEE 754 binary64 computation\n        x_b64 = np.float64(x_str)\n        y_b64 = np.float64(y_str)\n        \n        # Naive formulation\n        r_bn = x_b64**2 - y_b64**2\n        \n        # Factored formulation\n        r_bf = (x_b64 - y_b64) * (x_b64 + y_b64)\n\n        # 3. Decimal 16-digit computation\n        x_d16 = ctx_d16.create_decimal(x_str)\n        y_d16 = ctx_d16.create_decimal(y_str)\n\n        # Naive formulation\n        r_dn = ctx_d16.subtract(ctx_d16.power(x_d16, 2), ctx_d16.power(y_d16, 2))\n        \n        # Factored formulation\n        r_df = ctx_d16.multiply(ctx_d16.subtract(x_d16, y_d16), ctx_d16.add(x_d16, y_d16))\n\n        # 4. Error calculation\n        def get_error(r, t_ref, den, high_prec_ctx):\n            # Promote computed result r (float or Decimal) to a high-precision Decimal\n            # The Decimal constructor accurately represents the exact value of a float.\n            if isinstance(r, (float, np.floating)):\n                r_hp = high_prec_ctx.create_decimal(r)\n            else: # r is already a Decimal\n                r_hp = r\n\n            # Calculate error numerator |r - t| in high precision\n            err_num = high_prec_ctx.subtract(r_hp, t_ref).copy_abs()\n            \n            # Calculate scaled relative error\n            return float(high_prec_ctx.divide(err_num, den))\n\n        e_bn = get_error(r_bn, t_ref, error_denominator, ctx_hp)\n        e_bf = get_error(r_bf, t_ref, error_denominator, ctx_hp)\n        e_dn = get_error(r_dn, t_ref, error_denominator, ctx_hp)\n        e_df = get_error(r_df, t_ref, error_denominator, ctx_hp)\n\n        # 5. Determine which formulation is better\n        better_bin = e_bf  e_bn\n        better_dec = e_df  e_dn\n        \n        case_result = [e_bn, e_bf, better_bin, e_dn, e_df, better_dec]\n        results.append(case_result)\n\n    # Final print statement in the exact required format.\n    # The default string representation of list of lists is the desired format.\n    print(f\"{results}\")\n\nsolve()\n```"
        }
    ]
}