{
    "hands_on_practices": [
        {
            "introduction": "理论知识只有通过实践才能真正内化。本节的第一个练习将带你深入 IEEE 754 标准的核心，直接与浮点数的二进制表示打交道。你将通过编写一个分类器，学习如何仅根据位模式（bit pattern）来区分正常数、次规范数、零、无穷大和 NaN 。这项练习将从根本上巩固你对浮点数内部结构的理解，让你明白计算机是如何解释这些 0 和 1 序列的。",
            "id": "3240373",
            "problem": "你需要从基本原理出发，为电气与电子工程师协会（IEEE）754 binary64 编码（通常称为双精度）实现一个分类器。该分类器将接受一组固定的无符号 $64$ 位模式作为输入，并对每一个模式进行判断，确定其代表的是规格化有限数、非规格化数、带符号零、带符号无穷大，还是非数值（NaN）。你必须从 binary64 的字段级定义出发，来证明分类逻辑的合理性。\n\n从以下构成基础的核心定义开始：\n- 一个 binary64 数据由一个符号位 $s$（$1$ 位）、一个指数场 $E$（$11$ 位）和一个小数场 $F$（$52$ 位）组成。存储的指数使用 $1023$ 的偏置值。\n- 该编码标准通过组合 $s$、$E$ 和 $F$ 来定义数值的解释。你的分类必须通过对这些字段定义以及指数极端值 $E = 0$ 和 $E = 2^{11}-1$ 含义的推理得出。\n- 分类必须考虑到指数场全为零或全为一的边界情况，并且必须严格区分 $s$、$E$ 和 $F$ 的作用。\n\n你的程序必须：\n- 实现一个函数，该函数给定一个无符号 $64$ 位整数模式，提取 $s$、$E$ 和 $F$，并将数据分类为以下类别之一，并以整数编码：\n  - $0$：规格化有限数\n  - $1$：非规格化数\n  - $2$：$+0$\n  - $3$：$-0$\n  - $4$：$+\\infty$\n  - $5$：$-\\infty$\n  - $6$：NaN\n- 仅使用对 $64$ 位模式的位级操作；不要为了分类而将其转换为原生浮点数。\n\n在你的解决方案中解释每种分类是如何从 binary64 字段定义中得出的。特别是，解释 $E = 0$ 和 $E = 2^{11}-1$ 的边界情况，以及符号位 $s$ 如何只影响特定类别。\n\n测试套件：\n对以下十个以十六进制形式给出的无符号 $64$ 位模式进行分类。根据 binary64 编码，将每个模式视为原始位模式。\n- $\\texttt{0x3FF0000000000000}$\n- $\\texttt{0x0000000000000001}$\n- $\\texttt{0x8000000000000001}$\n- $\\texttt{0x0000000000000000}$\n- $\\texttt{0x8000000000000000}$\n- $\\texttt{0x7FF0000000000000}$\n- $\\texttt{0xFFF0000000000000}$\n- $\\texttt{0x7FF8000000000001}$\n- $\\texttt{0x7FEFFFFFFFFFFFFF}$\n- $\\texttt{0x0010000000000000}$\n\n最终输出格式：\n你的程序应生成一行输出，其中包含一个逗号分隔的整数代码列表，顺序与测试套件相同，并用方括号括起来。例如，如果有三个测试用例，其代码分别为 $0$、$1$ 和 $6$，则输出将是 $\\texttt{[0,1,6]}$。",
            "solution": "根据 IEEE 754 binary64 标准对给定的 $64$ 位模式进行分类是一个定义明确的任务，它依赖于将位模式划分为三个不同的字段：符号位（$s$）、指数场（$E$）和小数场（$F$）。位模式的解释由一组基于这些字段值的规则确定。该问题是有效的，因为它在科学上基于普遍接受的 IEEE 754 标准，是自洽的，并为确定性分类提供了所有必要的信息。\n\n一个 $64$ 位 binary64 模式的结构如下：\n- **符号位（$s$）**：$1$ 位（第 $63$ 位）\n- **指数场（$E$）**：$11$ 位（第 $62$ 位到第 $52$ 位）\n- **小数场（$F$）**：$52$ 位（第 $51$ 位到第 $0$ 位）\n\n给定模式所表示的数值 $v$ 是 $s$、$E$ 和 $F$ 的函数。将数值分类为规格化数、非规格化数、零、无穷大或非数值（NaN），主要取决于指数场 $E$ 的特殊值。$E$ 的两个关键情况是其位全为零（$E=0$）或全为一（$E=2^{11}-1 = 2047$）。\n\n为了实现分类器，我们必须首先从给定的 $64$ 位无符号整数模式（我们记为 $p$）中提取这三个字段。这通过位运算实现：掩码和右移。\n- 符号位 $s$ 是最高有效位（MSB）。可以通过将模式右移 $63$ 位来提取：\n  $$s = p \\gg 63$$\n- 指数场 $E$ 由接下来的 $11$ 位组成。我们可以通过先将模式右移 $52$ 位以移除小数部分，然后应用一个掩码来仅保留结果的最低 $11$ 位，从而隔離出这些位。$11$ 位的掩碼是 $2^{11}-1$，十进制为 $2047$，十六进制为 $\\texttt{0x7FF}$。\n  $$E = (p \\gg 52) \\& \\text{0x7FF}$$\n- 小数场 $F$ 包含最低有效位的 $52$ 位。我们可以通过应用一个只保留这 $52$ 位的掩码来提取它。该掩码是 $2^{52}-1$，十六进制为 $\\texttt{0x000FFFFFFFFFFFFF}$。\n  $$F = p \\& \\text{0x000FFFFFFFFFFFFF}$$\n\n提取出 $s$、$E$ 和 $F$ 后，分类就按照 IEEE 754 标准定义的规则进行，这些规则构成了一个基于 $E$ 和 $F$ 值的决策树。\n\n**情况 1：$E$ 全为一（$E = 2047$）**\n这种情况表示无穷大和 NaN 这两种特殊值。它们之间的选择取决于小数场 $F$。\n- 如果 $F = 0$：该模式表示**无穷大**。无穷大的符号由符号位 $s$ 决定。\n    - 如果 $s=0$，则为正无穷大（$+\\infty$）。这对应于代码 $4$。\n    - 如果 $s=1$，则为负无穷大（$-\\infty$）。这对应于代码 $5$。\n    其值由 $v = (-1)^s \\times \\infty$ 给出。\n- 如果 $F \\neq 0$：该模式表示**非数值（NaN）**。标准根据 $F$ 的最高有效位来区分静默 NaN（qNaN）和信令 NaN（sNaN），但对于本问题，所有此类模式都简单地归类为 NaN。符号位 $s$ 是 NaN 载荷的一部分，但不影响其作为 NaN 的分类。所有 $E=2047$ 且 $F \\neq 0$ 的模式都被归类为 NaN。这对应于代码 $6$。\n\n**情况 2：$E$ 全为零（$E = 0$）**\n这种情况表示零和非规格化数（或称非正规数）。区别基于小数场 $F$。这些数的数值有不同的解释方式，其有效指数固定为最小值，且有效数中没有隐藏的前导 $1$。\n- 如果 $F = 0$：该模式表示**零**。IEEE 754 标准包括正零和负零，通过符号位 $s$ 区分。\n    - 如果 $s=0$，则为正零（$+0$）。这对应于代码 $2$。\n    - 如果 $s=1$，则为负零（$-0$）。这对应于代码 $3$。\n    其值为 $v = (-1)^s \\times 0$。\n- 如果 $F \\neq 0$：该模式表示**非规格化数**。这些数通过牺牲精度来实现渐进下溢。其值由 $v = (-1)^s \\times 2^{1-\\text{bias}} \\times (0.F)_2$ 给出，其中 $\\text{bias} = 1023$ 且 $(0.F)_2$ 是小数 $F$ 被解释为二进制数的小数部分。符号由 $s$ 决定，但问题为所有非规格化数指定了单一类别。这对应于代码 $1$。\n\n**情况 3：$E$ 既不全为零也不全为一（$0 < E < 2047$）**\n这是所有**规格化有限数**的情况。对于这些数，指数通过从字段值 $E$ 中减去偏置值 $1023$ 来计算。有效数（小数场和一个隐藏的前导位的组合）是 $1.F$。规格化数的值由以下公式给出：\n$$v = (-1)^s \\times 2^{E-1023} \\times (1.F)_2$$\n符号位 $s$ 决定了数是正还是负，而字段 $E$ 和 $F$ 决定了其量值。然而，此范围内的所有数，无论其符号或量值如何，都属于“规格化有限数”这一个类别。这对应于代码 $0$。\n\n这套规则是完整且无歧义的，为 $2^{64}$ 种可能的位模式中的任意一种提供了唯一的分类。实现将直接遵循这一逻辑。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Classifies a set of IEEE 754 binary64 patterns and prints the results.\n    \"\"\"\n\n    def classify_binary64(pattern: np.uint64) -> int:\n        \"\"\"\n        Classifies a 64-bit pattern according to IEEE 754 binary64 rules.\n\n        The classification logic is based on the field definitions:\n        - s: sign (1 bit)\n        - E: exponent (11 bits)\n        - F: fraction (52 bits)\n\n        The classification codes are:\n        - 0: normal finite\n        - 1: subnormal\n        - 2: +0\n        - 3: -0\n        - 4: +infinity\n        - 5: -infinity\n        - 6: NaN\n\n        Args:\n            pattern: An unsigned 64-bit integer representing the bit pattern.\n\n        Returns:\n            An integer code representing the classification.\n        \"\"\"\n        # Define masks to extract the fields from the 64-bit pattern.\n        # These are defined as uint64 to match the pattern type.\n        sign_mask = np.uint64(0x8000000000000000)\n        exponent_mask = np.uint64(0x7FF0000000000000)\n        fraction_mask = np.uint64(0x000FFFFFFFFFFFFF)\n\n        # Extract the sign bit 's'.\n        # s = 0 for positive, s = 1 for negative.\n        s = 1 if (pattern & sign_mask) != 0 else 0\n\n        # Extract the 11-bit exponent field 'E'.\n        # The exponent is bits 62-52. Shift right by 52.\n        E = np.uint64((pattern & exponent_mask) >> np.uint64(52))\n\n        # Extract the 52-bit fraction field 'F'.\n        F = pattern & fraction_mask\n\n        # Maximum possible value for the 11-bit exponent field.\n        E_max = np.uint64(0x7FF)  # 2^11 - 1 = 2047\n\n        # Classification logic based on the values of E and F.\n\n        # Case 1: E is all ones (E = 2047). Special values: infinity or NaN.\n        if E == E_max:\n            if F == 0:\n                # Infinity\n                return 4 if s == 0 else 5  # +inf or -inf\n            else:\n                # Not-a-Number (NaN)\n                return 6\n\n        # Case 2: E is all zeros (E = 0). Special values: zero or subnormal.\n        elif E == 0:\n            if F == 0:\n                # Zero\n                return 2 if s == 0 else 3  # +0 or -0\n            else:\n                # Subnormal (denormalized) number\n                return 1\n\n        # Case 3: 0 < E < 2047. Normal finite numbers.\n        else:\n            return 0  # Normal finite number\n\n    # The test suite provided in the problem statement.\n    test_cases_hex = [\n        \"0x3FF0000000000000\", # 1.0 (normal)\n        \"0x0000000000000001\", # Smallest positive subnormal\n        \"0x8000000000000001\", # Smallest negative subnormal\n        \"0x0000000000000000\", # +0\n        \"0x8000000000000000\", # -0\n        \"0x7FF0000000000000\", # +infinity\n        \"0xFFF0000000000000\", # -infinity\n        \"0x7FF8000000000001\", # Quiet NaN\n        \"0x7FEFFFFFFFFFFFFF\", # Largest normal finite number\n        \"0x0010000000000000\", # Smallest positive normal number\n    ]\n\n    # Convert hex strings to numpy.uint64 integers.\n    test_cases = [np.uint64(int(h, 16)) for h in test_cases_hex]\n\n    # Classify each test case.\n    results = [classify_binary64(case) for case in test_cases]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "理解了浮点数的结构之后，下一个关键步骤是探索其表示的局限性。由于计算机内存有限，浮点数在实数轴上是离散分布的，数字之间存在间隙。这个练习将引导你探索机器精度的概念，特别是“单位舍入误差”$u$ 。通过计算使 $1.0 + x$ 的计算结果不等于 $1.0$ 的最小浮点数 $x$，你将亲手触及浮点数表示精度的边界。",
            "id": "3240413",
            "problem": "考虑在电气和电子工程师协会（IEEE）754 binary32格式下的加法，使用默认的舍入模式，即“舍入到最近，平局时偏向偶数”（rounding to nearest with ties to even）。一个规格化的binary32数具有 $m \\times 2^{E}$ 的形式，其中 $m \\in [1,2)$ 且有一个23位的小数部分，而 $E$ 是一个整数指数，偏置为 $127$。令 $1.0$ 表示 $m = 1$ 且 $E = 0$ 的binary32数。定义 $x$ 为一个正的、有限的binary32数。仅使用binary32表示的结构特性和上述舍入规则，确定最大的这样一个 $x$ ，使得在binary32算术中计算 $1.0 + x$ 得到的最终舍入结果为 $1.0$ 。将您的答案表示为2的精确幂。此外，给出该值在标准数值分析中的术语名称。最终的数值必须写成一个单一的精确表达式；不需要舍入。",
            "solution": "用户希望找到最大的正有限IEEE 754 binary32数 $x$ ，使得在使用binary32算术和“舍入到最近，平局时偏向偶数”模式执行操作 $1.0 + x$ 时，结果为 $1.0$ 。\n\n首先，我们分析IEEE 754 binary32格式中数字的表示方法。一个规格化数的形式为 $(-1)^s \\times m \\times 2^E$ ，其中 $s$ 是符号位， $m$ 是有效数（或称尾数）， $E$ 是指数。\n对于binary32：\n- 有效数 $m$ 的精度为 $p=24$ 位（1个隐含的前导位和23个显式的小数位）。对于一个规格化数， $m$ 的形式为 $1.f$ ，其中 $f$ 是23位的小数部分，因此 $m \\in [1, 2)$ 。\n- 指数 $E$ 以偏置形式存储，偏置量为 $127$ 。对于规格化数，真实指数 $E$ 的有效范围是 $[-126, 127]$ 。\n\n数字 $1.0$ 在此格式中表示。其值为 $1.0 \\times 2^0$ 。\n- 符号为正，所以 $s=0$ 。\n- 指数为 $E=0$ 。存储的偏置指数是 $0+127=127$ 。\n- 有效数是 $m=1.0$ 。在二进制中，这是 $1.000...0_2$ 。隐含位是 $1$ ，23个小数位全为 $0$ 。我们将 $1.0$ 的有效数表示为 $m_1$ 。\n$m_1 = 1.\\underbrace{000...000}_{23 \\text{ bits}}$\n\n问题要求计算出的 $1.0$ 和 $x$ 的和舍入回 $1.0$ 。让这个计算出的和表示为 $\\text{fl}(1.0+x)$ 。我们正在寻找最大的可表示数 $x > 0$ ，使得 $\\text{fl}(1.0+x) = 1.0$ 。\n\n舍入模式是“舍入到最近，平局时偏向偶数”。这意味着精确结果被舍入到最接近的可表示浮点数。如果精确结果恰好在两个可表示数之间的一半，则它被舍入到有效数最低有效位（LSB）为 $0$ 的那个数（即“偶数”）。\n\n让我们确定与此问题相关的两个可表示数：\n1.  数字 $y_1 = 1.0$ 。\n2.  大于 $1.0$ 的下一个可表示数，我们称之为 $y_2$ 。\n\n为了找到 $y_2$ ，我们将 $y_1$ 的有效数的最低有效位加一。23位小数部分的最低有效位对应的值是 $2^{-23}$ 。\n所以， $y_2 = 1.0 + 2^{-23}$ 。\n其有效数为 $m_2 = 1.\\underbrace{000...001}_{23 \\text{ bits}}$ 。\n\n为了使操作结果舍入到 $y_1=1.0$ ，精确结果必须比 $y_2$ 更接近 $y_1$ ，或者恰好在它们的中点。让我们找到 $y_1$ 和 $y_2$ 之间的中点 $M$ ：\n$$M = \\frac{y_1 + y_2}{2} = \\frac{1.0 + (1.0 + 2^{-23})}{2} = \\frac{2.0 + 2^{-23}}{2} = 1.0 + 2^{-24}$$\n\n根据舍入规则：\n- 如果精确和 $1.0+x < M$ ，它会向下舍入到 $y_1=1.0$ 。\n- 如果精确和 $1.0+x > M$ ，它会向上舍入到 $y_2=1.0+2^{-23}$ 。\n- 如果精确和 $1.0+x = M$ ，则出现平局。在这种情况下，我们舍入到“偶数”。 $y_1=1.0$ 的有效数以 $0$ 结尾，而 $y_2=1.0+2^{-23}$ 的有效数以 $1$ 结尾。因此， $y_1$ 是“偶数”，结果向下舍入到 $1.0$ 。\n\n综合这些条件，为了使 $\\text{fl}(1.0+x)$ 为 $1.0$ ，精确和必须满足：\n$$1.0 + x \\le M$$\n$$1.0 + x \\le 1.0 + 2^{-24}$$\n这可以简化为：\n$$x \\le 2^{-24}$$\n\n问题要求找到满足此条件的最大*可表示binary32数* $x$ 。我们必须检查 $2^{-24}$ 本身是否是一个可表示的binary32数。\n我们可以将 $2^{-24}$ 写成规格化形式 $m \\times 2^E$ ：\n$$2^{-24} = 1.0 \\times 2^{-24}$$\n- 有效数是 $m=1.0$ 。这是一个规格化数的有效有效数（隐含位为 $1$ ，小数部分全为零）。\n- 指数是 $E=-24$ 。偏置指数是 $E_{biased} = -24 + 127 = 103$ 。该值在规格化数的偏置指数的有效范围 $[1, 254]$ 内。\n\n由于 $2^{-24}$ 是一个有效的规格化binary32数，并且我们要求 $x \\le 2^{-24}$ ，其中 $x$ 也必须是一个可表示的数，所以 $x$ 的最大可能值恰好是 $2^{-24}$ 。\n\n问题还要求给出该值在标准数值分析中的术语。这个值代表 $1.0$ 与下一个可表示数之间间距的一半，被称为**单位舍入误差**（unit roundoff）。它通常用 $u$ 表示。对于一个基数为 $\\beta$ 、精度为 $p$ 并使用“舍入到最近”的浮点系统，单位舍入误差定义为 $u = \\frac{1}{2}\\beta^{1-p}$ 。对于binary32， $\\beta=2$ 且 $p=24$ ，所以 $u = \\frac{1}{2}(2)^{1-24} = 2^{-1} \\cdot 2^{-23} = 2^{-24}$ 。这个值代表将一个数舍入到最接近的浮点表示时可能产生的最大相对误差。它是机器epsilon ($\\epsilon = 2^{-23}$) 的一半。\n\n因此，最大的这样的 $x$ 是 $2^{-24}$ 。",
            "answer": "$$\\boxed{2^{-24}}$$"
        },
        {
            "introduction": "在掌握了浮点数的结构和精度限制后，让我们来看一个经典的综合案例，它揭示了浮点运算中微妙而出乎意料的行为。这个练习要求你分析一个看似简单的计算：$5 \\times 0.2$ 。你将首先面对一个挑战：像 $0.2$ 这样简单的十进制小数在二进制中是无限循环的，因此其表示必然存在误差。接着，你将跟踪这个带有表示误差的数在乘法运算中如何被处理，以及最终结果如何通过“舍入到最近，偶数优先”规则再次被精确化，从而产生一个可能出乎你意料的最终误差。这个过程将加深你对表示误差和计算误差相互作用的理解。",
            "id": "3240494",
            "problem": "一位工程师正在分析十进制小数在电气和电子工程师协会 (IEEE) 754 binary64 格式下的表示方式及其算术运算中的使用。在 binary64 格式中，一个规格化有限数由一个符号位 $s \\in \\{0,1\\}$、一个偏移量为 $1023$ 的 $11$ 位偏置指数 $E_{\\text{bias}} \\in \\{1,\\dots,2046\\}$ 以及一个表示尾数 $1 + F/2^{52}$ 的 $52$ 位小数字段 $F \\in \\{0,1,\\dots,2^{52}-1\\}$ 编码。其值为\n$$\n(-1)^{s} \\left(1 + \\frac{F}{2^{52}}\\right) 2^{E_{\\text{bias}} - 1023},\n$$\n并且基本运算采用“舍入到最近，偶数优先”的规则。\n\n仅使用这些定义以及基数转换和舍入的基本原理，完成以下任务：\n\n1. 确定十进制数 $0.2$（即 $1/5$）的精确 binary64 编码。识别出符号位 $s$、11 位指数位和 52 位小数位，并给出这个 64 位字的整合的 16 位十六进制编码。\n\n2. 现在考虑在 binary64 算术中计算 $5 \\times 0.2$。将此计算建模为：首先将十进制字面量 $0.2$ 转换为其精确的 binary64 值，然后乘以可精确表示的整数 $5$，最后根据“舍入到最近，偶数优先”的规则进行一次舍入到 binary64 格式。假设精确的实数结果为 $1$。这次 binary64 计算的绝对误差，定义为 $\\left|\\operatorname{fl}(5 \\times 0.2) - 1\\right|$，是多少？\n\n请给出所有推导过程。作为最终答案，仅报告绝对误差这一个实数。最终答案无需舍入，因为它是一个精确值。",
            "solution": "该问题经评估为有效，因为它科学地基于 IEEE 754 标准，问题陈述清晰且信息充分，并使用了客观、正式的语言。我们可以开始解题。\n\n该问题包含两部分。首先，我们必须确定十进制数 $0.2$ 的 IEEE 754 binary64 表示。其次，我们必须计算浮点运算 $5 \\times 0.2$ 的绝对误差。\n\n### 第 1 部分：$0.2$ 的 Binary64 编码\n\n一个规格化的 binary64 数的值由 $v = (-1)^{s} \\left(1 + \\frac{F}{2^{52}}\\right) 2^{e}$ 给出，其中 $e = E_{\\text{bias}} - 1023$。\n\n1.  **转换为二进制：**\n    十进制数 $0.2$ 等价于分数 $\\frac{1}{5}$。要将其转换为二进制，我们反复乘以 $2$ 并记录整数部分：\n    $0.2 \\times 2 = 0.4 \\implies 0$\n    $0.4 \\times 2 = 0.8 \\implies 0$\n    $0.8 \\times 2 = 1.6 \\implies 1$\n    $0.6 \\times 2 = 1.2 \\implies 1$\n    小数部分 $0.2$ 再次出现，因此其二进制表示是一个循环小数：\n    $$0.2_{10} = 0.00110011..._{2} = 0.\\overline{0011}_{2}$$\n\n2.  **规格化：**\n    为符合 IEEE 754 格式，我们将二进制数规格化为 $1.M \\times 2^e$ 的形式：\n    $$0.\\overline{0011}_{2} = 1.\\overline{1001}_{2} \\times 2^{-3}$$\n\n3.  **确定编码字段：**\n    -   **符号位 ($s$):** 该数为正数，所以 $s=0$。\n    -   **指数 ($e$):** 真实指数为 $e = -3$。\n    -   **偏置指数 ($E_{\\text{bias}}$):** 偏移量为 $1023$，则偏置指数为 $E_{\\text{bias}} = e + 1023 = -3 + 1023 = 1020$。用 11 位二进制表示，即为 $1020_{10} = 01111111100_{2}$。\n    -   **小数字段 ($F$):** 尾数为 $1.\\overline{1001}_{2}$。小数字段 $F$ 存储隐含的前导 $1$ 之后的 $52$ 位。未舍入的小数位是循环模式 `1001...` 的前 $52$ 位，即 `1001` 重复十三次。\n        $$1.\\underbrace{10011001...1001}_{52 \\text{ bits}} \\vert 1001...$$\n        第一个被截断的位（保护位，在第 $53$ 位）是 $1$。随后的位（粘滞位）是 $001...$，它们不全为零。根据“舍入到最近，偶数优先”规则，当保护位为 $1$ 且粘滞位不全为零时，我们必须向上舍入。这涉及到给 52 位的小数部分加 $1$。\n        未舍入的 52 位小数是 $(\\underbrace{1001...1001}_{13 \\text{ times}})_2$。将此二进制数加 $1$ 得到：\n        $$(\\underbrace{1001...1001}_{12 \\text{ times}}1001)_2 + 1_2 = (\\underbrace{1001...1001}_{12 \\text{ times}}1010)_2$$\n        因此，小数字段 $F$ 的最终 52 位是十二次重复的 `1001` 后跟 `1010`。\n\n4.  **组合成 64 位十六进制表示：**\n    我们将符号位、指数位和小数位拼接起来：\n    -   符号位（1 位）：$0$\n    -   指数位（11 位）：$01111111100$\n    -   小数位（52 位）：$(1001)^{12}1010_2$\n\n    完整的 64 位字是：\n    $$0 \\underbrace{01111111100}_{\\text{Exponent}} \\underbrace{10011001...10011010}_{\\text{Fraction}}$$\n    从左到右将这些位分成 4 位的半字节（nibble）：\n    -   `0011` $\\rightarrow$ $3_{16}$\n    -   `1111` $\\rightarrow$ $F_{16}$\n    -   `1100` $\\rightarrow$ $C_{16}$\n    -   小数部分以 `1001` $\\rightarrow$ $9_{16}$ 开始。这个模式重复 $12$ 次。\n    -   小数部分的最后 $4$ 位是 `1010` $\\rightarrow$ $A_{16}$。\n\n    整合的 16 位十六进制编码是 `3FC999999999999A`。\n\n### 第 2 部分：$5 \\times 0.2$ 的绝对误差\n\n1.  **$\\operatorname{fl}(0.2)$ 的值：**\n    设 $x_{64} = \\operatorname{fl}(0.2)$ 为 $0.2$ 的 binary64 表示。其值由我们找到的字段决定。必须计算小数字段 $F$ 的整数值。一种方法是意识到我们是从精确值向上舍入的。所需的精确尾数是 $1.6 = 1 + \\frac{3}{5}$。我们需要用 $\\frac{F}{2^{52}}$ 来近似 $\\frac{3}{5}$。\n    $$F \\approx \\frac{3}{5} \\times 2^{52}$$\n    精确值 $\\frac{3}{5} \\times 2^{52}$ 对于某个整数 $k$ 是 $k+0.6$。舍入到最近的整数得到 $k+1$。\n    $$F = \\text{round}\\left(\\frac{3}{5} \\times 2^{52}\\right) = \\left\\lfloor \\frac{3}{5} \\times 2^{52} \\right\\rfloor + 1 = \\frac{3 \\cdot 2^{52}-3}{5} + 1 = \\frac{3 \\cdot 2^{52}+2}{5}$$\n    $x_{64}$ 的值为：\n    $$x_{64} = \\left(1 + \\frac{F}{2^{52}}\\right) \\times 2^{-3} = \\left(1 + \\frac{(3 \\cdot 2^{52}+2)/5}{2^{52}}\\right) \\times 2^{-3}$$\n    $$x_{64} = \\left(1 + \\frac{3}{5} + \\frac{2}{5 \\cdot 2^{52}}\\right) \\times 2^{-3} = \\left(\\frac{8}{5} + \\frac{2}{5 \\cdot 2^{52}}\\right) \\times 2^{-3}$$\n    $$x_{64} = \\frac{8}{5 \\cdot 2^3} + \\frac{2}{5 \\cdot 2^{52} \\cdot 2^3} = \\frac{1}{5} + \\frac{2}{5 \\cdot 2^{55}} = \\frac{1}{5} + \\frac{1}{5 \\cdot 2^{54}}$$\n    所以，存储的值略大于 $0.2$ 的真实值。\n\n2.  **$\\operatorname{fl}(5)$ 的值：**\n    整数 $5$ 表示为 $5_{10} = 101_2 = 1.01_2 \\times 2^2$。这可以在 binary64 中精确表示，因为尾数只需要 3 位。因此，$\\operatorname{fl}(5) = 5$。\n\n3.  **执行乘法：**\n    该计算被建模为对 $\\operatorname{fl}(5)$ 和 $\\operatorname{fl}(0.2)$ 的精确乘積进行舍入。\n    设 $P$ 为精确乘积：\n    $$P = 5 \\times x_{64} = 5 \\times \\left(\\frac{1}{5} + \\frac{1}{5 \\cdot 2^{54}}\\right) = 1 + \\frac{5}{5 \\cdot 2^{54}} = 1 + 2^{-54}$$\n\n4.  **对乘积进行舍入：**\n    我们必须将结果 $P = 1 + 2^{-54}$ 舍入到最近的 binary64 数。数字 $1$ 是可以精确表示的。下一个更大的可表示数具有相同的指数（$e=0$），其小数字段是最小的可能非零值，即 $1$。其尾数为 $1+2^{-52}$。\n    夹在 $P$ 两侧的两个 binary64 数是：\n    -   $N_1 = 1$，尾数为 $1.0$，指数为 $0$。\n    -   $N_2 = 1+2^{-52}$，尾数为 $1.0...01$，指数为 $0$。\n\n    为了使用“舍入到最近”规则，我们将 $P$ 与 $N_1$ 和 $N_2$ 之间的中点 $M$ 进行比较：\n    $$M = \\frac{N_1 + N_2}{2} = \\frac{1 + (1+2^{-52})}{2} = 1 + \\frac{2^{-52}}{2} = 1 + 2^{-53}$$\n    我们将我们的乘积 $P$ 与这个中点进行比较：\n    $$P = 1 + 2^{-54}$$\n    由于 $2^{-54} < 2^{-53}$，我们有 $P < M$。值 $P$ 更接近 $N_1 = 1$ 而非 $N_2 = 1+2^{-52}$。\n    因此，计算的最终舍入结果是：\n    $$\\operatorname{fl}(5 \\times 0.2) = \\operatorname{round}(1 + 2^{-54}) = 1$$\n\n5.  **计算绝对误差：**\n    问题要求计算结果与精确数学结果（即 $1$）之间的绝对误差。\n    $$\\text{Absolute Error} = |\\operatorname{fl}(5 \\times 0.2) - 1| = |1 - 1| = 0$$",
            "answer": "$$\\boxed{0}$$"
        }
    ]
}