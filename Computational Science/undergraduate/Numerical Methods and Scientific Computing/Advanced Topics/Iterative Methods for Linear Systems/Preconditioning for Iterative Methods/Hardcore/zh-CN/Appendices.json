{
    "hands_on_practices": [
        {
            "introduction": "理论是重要的，但通过实践来巩固理解更为关键。让我们从一个直观的例子开始：当一个线性系统的方程组尺度差异巨大时，迭代求解器可能会遇到困难。这个练习旨在通过一种最简单的预处理技术——对角缩放（或行均衡），来处理一个病态的线性系统，让你亲手感受预处理如何通过简单的变换改善矩阵的性质。",
            "id": "2194457",
            "problem": "考虑线性方程组 $Ax = b$，其中矩阵 $A$ 和向量 $b$ 由下式给出：\n$$\nA = \\begin{pmatrix} 2  -1  0 \\\\ 1000  2000  -1000 \\\\ 0  -1  2 \\end{pmatrix}, \\quad b = \\begin{pmatrix} 1 \\\\ 0 \\\\ 1 \\end{pmatrix}\n$$\n我们观察到，通过将系统转换为一个等价系统 $A'x = b'$，可以改善许多迭代求解器的收敛性，其中新矩阵 $A'$ 的各行具有更均匀的“大小”。这种转换是通过使用一个可逆矩阵 $P$ 实现的，使得 $A' = PA$ 且 $b' = Pb$。\n\n你的任务是找到一个形如下式的对角矩阵 $P$\n$$\nP = \\begin{pmatrix} p_1  0  0 \\\\ 0  p_2  0 \\\\ 0  0  p_3 \\end{pmatrix}\n$$\n用以对 $A$ 进行行均衡。具体来说，需要确定 $p_1, p_2,$ 和 $p_3$ 的值，使得结果矩阵 $A'$ 中每个行向量的无穷范数都等于 1。向量 $v = (v_1, v_2, \\dots, v_n)$ 的无穷范数定义为 $\\|v\\|_{\\infty} = \\max_{i} |v_i|$。为简单起见，你可以假设 $P$ 的对角元素是正数。\n\n将你的最终答案表示为 3x3 矩阵 $P$。",
            "solution": "我们寻求一个对角缩放矩阵 $P=\\operatorname{diag}(p_{1},p_{2},p_{3})$，使得 $A' = PA$ 的每一行的无穷范数都等于 $1$。令 $a_{i}^{T}$ 表示 $A$ 的第 $i$ 行。那么 $A'$ 的第 $i$ 行是 $p_{i}a_{i}^{T}$。由于 $p_{i} > 0$，无穷范数的缩放关系为\n$$\n\\|p_{i}a_{i}^{T}\\|_{\\infty} = p_{i}\\|a_{i}^{T}\\|_{\\infty}.\n$$\n施加条件 $\\|p_{i}a_{i}^{T}\\|_{\\infty} = 1$ 得到\n$$\np_{i} = \\frac{1}{\\|a_{i}^{T}\\|_{\\infty}} \\quad \\text{对于 } i=1,2,3.\n$$\n计算 $A$ 的行无穷范数：\n- 第1行：$a_{1}^{T}=(2,-1,0)$，所以 $\\|a_{1}^{T}\\|_{\\infty}=\\max\\{|2|,|{-1}|,|0|\\}=2$，因此 $p_{1}=\\frac{1}{2}$。\n- 第2行：$a_{2}^{T}=(1000,2000,-1000)$，所以 $\\|a_{2}^{T}\\|_{\\infty}=\\max\\{1000,2000,1000\\}=2000$，因此 $p_{2}=\\frac{1}{2000}$。\n- 第3行：$a_{3}^{T}=(0,-1,2)$，所以 $\\|a_{3}^{T}\\|_{\\infty}=\\max\\{|0|,|{-1}|,|2|\\}=2$，因此 $p_{3}=\\frac{1}{2}$。\n\n因此，\n$$\nP=\\begin{pmatrix}\n\\frac{1}{2}  0  0 \\\\\n0  \\frac{1}{2000}  0 \\\\\n0  0  \\frac{1}{2}\n\\end{pmatrix}.\n$$\n这个选择确保了 $A' = PA$ 的每一行的无穷范数都等于 $1$。",
            "answer": "$$\\boxed{\\begin{pmatrix}\\frac{1}{2}  0  0 \\\\ 0  \\frac{1}{2000}  0 \\\\ 0  0  \\frac{1}{2}\\end{pmatrix}}$$"
        },
        {
            "introduction": "在上一个练习中，我们直观地看到了缩放如何“平衡”一个系统。现在，让我们深入探讨预处理的核心数学目标：最小化条件数。这个练习将挑战你为一个简单的 $2 \\times 2$ 矩阵设计一个“完美”的对角预处理器，使其预处理后的系统条件数恰好为 $1$，从而将收敛速度理论上提升到极致。",
            "id": "2194479",
            "problem": "在数值线性代数中，迭代法常用于求解形如 $A\\mathbf{x} = \\mathbf{b}$ 的大型线性方程组的近似解。许多这类方法的效率在很大程度上取决于系数矩阵 $A$ 的性质，特别是其条件数 $\\kappa(A)$。为了改善收敛性，使用了一种称为预处理的技术。原始系统被转换为一个等价的系统 $M\\mathbf{x} = \\mathbf{c}$，其中 $M = P^{-1}A$ 且 $\\mathbf{c} = P^{-1}\\mathbf{b}$。矩阵 $P$ 被称为预处理矩阵，选择它的目的是使预处理后的矩阵 $M$ 的条件数 $\\kappa(M)$ 尽可能接近 1，同时确保 $P^{-1}$ 易于计算。\n\n考虑由下式给出的矩阵 $A$：\n$$A = \\begin{pmatrix} 1  2 \\\\ -4  2 \\end{pmatrix}$$\n我们正在寻找一个形如下式的对角预处理矩阵 $P$：\n$$P = \\begin{pmatrix} p_1  0 \\\\ 0  p_2 \\end{pmatrix}$$\n其中 $p_1$ 和 $p_2$ 是正实数。\n\n求比值 $p_2/p_1$ 的值，使得预处理后的矩阵 $P^{-1}A$ 关于矩阵 2-范数的条件数 $\\kappa_2(P^{-1}A)$ 恰好为 1。",
            "solution": "我们希望 $\\kappa_{2}(P^{-1}A)=1$。对于矩阵 2-范数，$\\kappa_{2}(M)=1$ 当且仅当存在 $\\alpha>0$ 使得 $M^{T}M=\\alpha I$。设 $M=P^{-1}A$，其中 $P=\\mathrm{diag}(p_{1},p_{2})$ 且 $p_{1},p_{2}>0$。那么\n$$\nM^{T}M=A^{T}P^{-T}P^{-1}A=A^{T}P^{-2}A,\n$$\n因为 $P$ 是对角元为正的对角矩阵。记 $D=P^{-2}=\\mathrm{diag}(d_{1},d_{2})$，其中 $d_{1}=p_{1}^{-2}$ 且 $d_{2}=p_{2}^{-2}$。我们寻找 $d_{1},d_{2}>0$ 和 $\\alpha>0$ 使得\n$$\nA^{T}DA=\\alpha I.\n$$\n当 $A=\\begin{pmatrix}1  2\\\\ -4  2\\end{pmatrix}$ 时，首先计算\n$$\nDA=\\begin{pmatrix}d_{1}  2d_{1}\\\\ -4d_{2}  2d_{2}\\end{pmatrix},\n$$\n然后\n$$\nA^{T}DA=\\begin{pmatrix}1  -4\\\\ 2  2\\end{pmatrix}\\begin{pmatrix}d_{1}  2d_{1}\\\\ -4d_{2}  2d_{2}\\end{pmatrix}\n=\\begin{pmatrix}d_{1}+16d_{2}  2d_{1}-8d_{2}\\\\ 2d_{1}-8d_{2}  4d_{1}+4d_{2}\\end{pmatrix}.\n$$\n为了使该矩阵等于 $\\alpha I$，非对角元素必须为零，且对角元素必须相等。非对角元素的条件给出\n$$\n2d_{1}-8d_{2}=0 \\quad \\Longrightarrow \\quad d_{1}=4d_{2}.\n$$\n根据这个关系，对角元素自动相等：\n$$\nd_{1}+16d_{2}=4d_{2}+16d_{2}=20d_{2}, \\quad 4d_{1}+4d_{2}=16d_{2}+4d_{2}=20d_{2}.\n$$\n因此 $D$ 必须满足 $d_{1}=4d_{2}$。用 $p_{1},p_{2}$ 表示，这等价于\n$$\np_{1}^{-2}=4p_{2}^{-2} \\quad \\Longrightarrow \\quad \\frac{p_{1}^{-2}}{p_{2}^{-2}}=4 \\quad \\Longrightarrow \\quad \\frac{p_{2}^{2}}{p_{1}^{2}}=4 \\quad \\Longrightarrow \\quad \\frac{p_{2}}{p_{1}}=2,\n$$\n使用 $p_{1},p_{2}0$。因此，$\\kappa_{2}(P^{-1}A)=1$ 当且仅当 $p_{2}/p_{1}=2$。",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "现在，我们将理论与实际的科学计算问题相结合。这个动手编码练习将探讨一个源于一维对流扩散方程的线性系统。你将使用高斯-赛德尔方法作为预处理器，并探索一个深刻的见解：预处理器的效果如何依赖于未知量的排序，特别是当排序方向与物理问题中的对流方向一致或相反时，这个练习将揭示数值策略与问题背后物理原理之间的紧密联系。",
            "id": "3263468",
            "problem": "考虑区间 $[0,1]$ 上具有齐次狄利克雷边界条件的一维稳态对流扩散边界值问题：寻找一个函数 $u(x)$ 使得\n$$\n-\\epsilon \\, \\frac{d^2 u}{dx^2} + \\beta \\, \\frac{d u}{dx} = f(x), \\quad x \\in (0,1), \\quad u(0) = 0, \\quad u(1) = 0,\n$$\n其中 $\\epsilon  0$ 是扩散系数，$\\beta$ 是对流速度。使用具有 $n$ 个内部点、网格间距为 $h = \\frac{1}{n+1}$ 的均匀网格对此问题进行离散化，并构建线性系统 $A \\, x = b$，其中 $x \\in \\mathbb{R}^n$。对扩散项使用标准的二阶中心差分，对对流项使用与 $\\beta$ 符号一致的一阶迎风差分：\n- 若 $\\beta \\ge 0$，则将 $\\frac{d u}{dx}$ 近似为 $\\frac{u_i - u_{i-1}}{h}$。\n- 若 $\\beta  0$，则将 $\\frac{d u}{dx}$ 近似为 $\\frac{u_{i+1} - u_i}{h}$。\n\n将 $f(x)$ 离散化为常数强迫项，设 $b$ 为 $\\mathbb{R}^n$ 中所有元素为1的向量。得到的矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 是一个三对角矩阵，其元素由 $\\epsilon$、$\\beta$ 和 $h$ 决定。\n\n使用左预处理的广义最小残差方法 (GMRES) 求解该线性系统，其中左预处理器 $M^{-1}$ 选择为高斯-赛德尔预处理器。基于未知数的排列（排序）$\\pi$ 定义高斯-赛德尔预处理器如下：\n- 设 $P_\\pi$ 是与排序 $\\pi$ 相关的排列矩阵，因此 $P_\\pi^\\top A P_\\pi$ 是根据 $\\pi$ 重新排序的矩阵。\n- 定义 $M_\\pi$ 为 $P_\\pi^\\top A P_\\pi$ 的下三角部分（包括对角线）。\n- 预处理操作将 $M_\\pi^{-1}$ 应用于排列后坐标中的向量，然后通过 $P_\\pi$ 将结果映射回去。\n\n从零初始猜测开始，实现左预处理的GMRES方法，通过使用由 $M_\\pi^{-1} A$ 和初始残差 $M_\\pi^{-1} b$ 生成的克雷洛夫子空间，来求解系统 $M_\\pi^{-1} A x = M_\\pi^{-1} b$。在每次迭代 $k$ 中，从克雷洛夫基构建近似解 $x_k$ 并计算相对残差\n$$\n\\rho_k = \\frac{\\|b - A x_k\\|_2}{\\|b\\|_2}.\n$$\n当 $\\rho_k \\le 10^{-8}$ 或迭代次数达到 $200$ 时终止，以先到者为准。对于给定的排序 $\\pi$，预处理器的有效性度量是达到容差 $10^{-8}$ 所需的迭代次数；如果在 $200$ 次迭代内未达到收敛，则报告迭代次数为 $200$。\n\n通过运行以下测试套件，展示高斯-赛德尔预处理器的有效性如何依赖于未知数相对于对流方向的排序。固定 $n = 80$。对于每个测试用例，使用指定的 $(\\epsilon,\\beta,\\pi)$：\n- 测试用例 1：$(\\epsilon, \\beta, \\pi) = (0.01, 20, \\text{自然排序})$，其中 $\\pi$ 是自然的从左到右排序。\n- 测试用例 2：$(\\epsilon, \\beta, \\pi) = (0.01, 20, \\text{反向排序})$，其中 $\\pi$ 是从右到左排序。\n- 测试用例 3：$(\\epsilon, \\beta, \\pi) = (0.01, -20, \\text{自然排序})$。\n- 测试用例 4：$(\\epsilon, \\beta, \\pi) = (0.01, -20, \\text{反向排序})$。\n- 测试用例 5：$(\\epsilon, \\beta, \\pi) = (1.0, 2, \\text{自然排序})$。\n- 测试用例 6：$(\\epsilon, \\beta, \\pi) = (1.0, 2, \\text{反向排序})$。\n\n您的程序必须：\n- 根据上述离散化规则为每个 $(\\epsilon,\\beta)$ 构建 $A$。\n- 基于指定的排序 $\\pi$ 构建高斯-赛德尔预处理器。\n- 运行左预处理的GMRES并记录达到 $\\rho_k \\le 10^{-8}$ 所需的迭代次数（如果未达到则为 $200$）。\n- 生成单行输出，其中包含六个迭代次数，格式为方括号括起来的逗号分隔列表，顺序为测试用例 1 到 6（例如 $[i_1,i_2,i_3,i_4,i_5,i_6]$），其中每个 $i_j$ 是一个整数。",
            "solution": "用户希望解决一个一维对流扩散问题，并分析具有不同排序的高斯-赛德尔预处理器的性能。\n\n### 1. 问题验证\n\n所提供的问题是偏微分方程数值方法中的一个标准练习。\n-   **给定条件**：所有参数（$\\epsilon$，$\\beta$）、离散化规则（扩散项用中心差分，对流项用迎风差分）、线性系统设置（$A x=b$，$b$为全1向量）、求解器（左预处理GMRES）、预处理器定义（依赖于排序的高斯-赛德尔）、终止准则（$\\rho_k \\le 10^{-8}$ 或 200 次迭代）以及测试用例都得到了明确无误的定义。\n-   **科学依据**：该问题植根于数值分析和科学计算的基本原理。对流扩散方程是物理学和工程学中的一个典型模型。离散化方案、GMRES算法和高斯-赛德尔预处理都是成熟的标准技术。\n-   **适定性与客观性**：该问题在数学上是适定的。离散化得到一个非奇异M矩阵 $A$，保证了线性系统的唯一解。GMRES算法是一个形式化过程，对于给定的输入将产生一个确定性的结果（迭代次数）。问题陈述是客观且无歧义的。\n\n该问题有效。我们着手求解。\n\n### 2. 离散化与矩阵组装\n\n对流扩散方程由下式给出：\n$$\n-\\epsilon \\, \\frac{d^2 u}{dx^2} + \\beta \\, \\frac{d u}{dx} = f(x)\n$$\n在区间 $[0,1]$ 上，具有齐次狄利克雷边界条件 $u(0)=u(1)=0$。我们使用一个有 $n$ 个内部点 $x_i = i h$（$i=1, \\dots, n$）的均匀网格，其中网格间距为 $h = 1/(n+1)$。设 $u_i \\approx u(x_i)$。\n\n在点 $x_i$ 处，扩散项的二阶中心差分为：\n$$\n-\\epsilon \\frac{d^2 u}{dx^2}\\bigg|_{x_i} \\approx -\\epsilon \\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2} = \\frac{-\\epsilon}{h^2}u_{i-1} + \\frac{2\\epsilon}{h^2}u_i - \\frac{\\epsilon}{h^2}u_{i+1}\n$$\n\n对流项的一阶迎风差分取决于速度 $\\beta$ 的符号。\n-   若 $\\beta \\ge 0$（从左向右流动），该格式使用“迎风”点 $x_{i-1}$：\n    $$\n    \\beta \\frac{d u}{dx}\\bigg|_{x_i} \\approx \\beta \\frac{u_i - u_{i-1}}{h} = -\\frac{\\beta}{h}u_{i-1} + \\frac{\\beta}{h}u_i\n    $$\n-   若 $\\beta  0$（从右向左流动），该格式使用“迎风”点 $x_{i+1}$：\n    $$\n    \\beta \\frac{d u}{dx}\\bigg|_{x_i} \\approx \\beta \\frac{u_{i+1} - u_i}{h} = -\\frac{\\beta}{h}u_i + \\frac{\\beta}{h}u_{i+1}\n    $$\n\n结合这些离散化方法，得到线性系统 $A x = b$ 的第 $i$ 行。\n\n**情况 1: $\\beta \\ge 0$**\n第 $i$ 行的方程为：\n$$\n\\left(-\\frac{\\epsilon}{h^2} - \\frac{\\beta}{h}\\right)u_{i-1} + \\left(\\frac{2\\epsilon}{h^2} + \\frac{\\beta}{h}\\right)u_i + \\left(-\\frac{\\epsilon}{h^2}\\right)u_{i+1} = b_i\n$$\n得到的矩阵 $A$ 是一个三对角矩阵，其对角线元素为：\n-   次对角线：$A_{i, i-1} = -\\frac{\\epsilon}{h^2} - \\frac{\\beta}{h}$\n-   主对角线：$A_{i, i} = \\frac{2\\epsilon}{h^2} + \\frac{\\beta}{h}$\n-   超对角线：$A_{i, i+1} = -\\frac{\\epsilon}{h^2}$\n\n**情况 2: $\\beta  0$**\n第 $i$ 行的方程为：\n$$\n\\left(-\\frac{\\epsilon}{h^2}\\right)u_{i-1} + \\left(\\frac{2\\epsilon}{h^2} - \\frac{\\beta}{h}\\right)u_i + \\left(-\\frac{\\epsilon}{h^2} + \\frac{\\beta}{h}\\right)u_{i+1} = b_i\n$$\n矩阵 $A$ 是一个三对角矩阵，其对角线元素为：\n-   次对角线：$A_{i, i-1} = -\\frac{\\epsilon}{h^2}$\n-   主对角线：$A_{i, i} = \\frac{2\\epsilon}{h^2} - \\frac{\\beta}{h} = \\frac{2\\epsilon}{h^2} + \\frac{|\\beta|}{h}$\n-   超对角线：$A_{i, i+1} = -\\frac{\\epsilon}{h^2} + \\frac{\\beta}{h} = -\\frac{\\epsilon}{h^2} - \\frac{|\\beta|}{h}$\n\n在这两种情况下，该结构适用于内部行 $i=2, \\dots, n-1$。对于 $i=1$ 和 $i=n$，由于边界条件，$u_0$ 和 $u_{n+1}$ 项为零，因此该结构仍然成立。向量 $b$ 被设置为全1向量。\n\n### 3. 预处理GMRES求解器\n\n我们实现广义最小残差 (GMRES) 方法来求解线性系统。该方法是左预处理的，意味着我们求解等价系统 $M^{-1}Ax = M^{-1}b$。\n\n**GMRES 算法：**\n从初始猜测 $x_0=0$ 开始，该算法迭代地为克雷洛夫子空间 $\\mathcal{K}_{k+1}(M^{-1}A, M^{-1}r_0)$（其中 $r_0=b-Ax_0=b$）构建一个标准正交基 $\\{v_0, v_1, \\dots, v_k\\}$。在每次迭代 $k$ 中，它在仿射空间 $x_0 + \\text{span}\\{v_0, \\dots, v_{k-1}\\}$ 中找到一个近似解 $x_k$，该解最小化预处理后的残差范数 $\\|M^{-1}(b-Ax_k)\\|_2$。具体步骤如下：\n1.  初始化：$x_0=0$，计算 $r_0=b$, $r_{tilde_0}=M^{-1}r_0$, $\\gamma = \\|r_{tilde_0}\\|_2$, $v_0 = r_{tilde_0}/\\gamma$。\n2.  **Arnoldi 迭代**：对于 $k=0, 1, \\dots$：\n    -   计算 $w = M^{-1}A v_k$。\n    -   通过 Gram-Schmidt 方法将 $w$ 与 $\\{v_0, \\dots, v_k\\}$ 正交化：对于 $j=0, \\dots, k$，设置 $h_{j,k} = w^T v_j$ 并且 $w \\leftarrow w-h_{j,k}v_j$。\n    -   设置 $h_{k+1,k} = \\|w\\|_2$ 并且 $v_{k+1} = w/h_{k+1,k}$。这将填充 $(k+1) \\times k$ 的 Hessenberg 矩阵 $H$。\n3.  **求解最小二乘问题**：找到 $y_k \\in \\mathbb{R}^{k+1}$ 以最小化 $\\|\\gamma e_1 - H_{k+1, k} y\\|_2$，其中 $e_1=[1,0,\\dots,0]^T$。\n4.  **更新解**：形成解 $x_k = x_0 + [v_0, \\dots, v_k] y_k$。\n5.  **检查收敛**：计算真实相对残差 $\\rho_k = \\|b - A x_k\\|_2 / \\|b\\|_2$。如果 $\\rho_k \\le 10^{-8}$，则终止。\n6.  如果迭代次数达到 $200$，则终止。\n\n**高斯-赛德尔预处理器：**\n预处理器 $M$ 依赖于未知数 $\\{0, 1, \\dots, n-1\\}$ 的一个排列（排序）$\\pi$。\n1.  设 $P_\\pi$ 是与 $\\pi$ 相关的排列矩阵。此处的解释是，对于一个向量 $v$，$v[\\pi]$ 是排列后的向量。逆排列是 $v[\\pi_{inv}]$，其中 $\\pi_{inv}$ 是逆排列数组。\n2.  矩阵 $A$ 被重新排序为 $A_\\pi = P_\\pi^T A P_\\pi$。在 `numpy` 中，这通过 `A[np.ix_(pi, pi)]` 实现。\n3.  排列空间中的预处理器矩阵是 $M_\\pi = \\text{tril}(A_\\pi)$，即 $A_\\pi$ 的下三角部分，包括其对角线。\n4.  预处理操作 $y = M^{-1}z$ 被定义为在排列后的坐标中应用高斯-赛德尔扫描的逆。其实现如下：\n    a. 排列输入向量：$z_\\pi = z[\\pi]$。\n    b. 使用前向代入求解下三角系统 $M_\\pi y_\\pi = z_\\pi$ 以得到 $y_\\pi$。\n    c. 将结果排列回原始排序：$y[\\pi] = y_\\pi$。\n\n该预处理器的有效性取决于 $\\pi$ 的选择。对于对流主导的问题，信息沿流动方向 $\\beta$ 传播。高斯-赛德尔扫描也根据其排序传播信息。如果排序 $\\pi$ 与物理流动方向一致，预处理器会成为一个很好的近似求解器，从而导致快速收敛。如果排序与流动方向相反，其有效性将大大降低。\n\n-   $\\beta  0$：流动方向为从左到右（从索引 $i$ 到 $i+1$）。**自然排序** `(0, 1, ...)` 与流动方向一致。\n-   $\\beta  0$：流动方向为从右到左（从索引 $i$ 到 $i-1$）。**反向排序** `(n-1, n-2, ...)` 与流动方向一致。\n我们期望当排序与流动方向一致时迭代次数较少，而当它们相反时迭代次数较多。\n\n实现将遵循这一逻辑，为每个测试用例构建相应的矩阵 $A$ 和预处理器 $M_\\pi$，然后运行预处理的GMRES算法以找到收敛所需的迭代次数。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the convection-diffusion problem for a suite of test cases\n    using left-preconditioned GMRES with an ordering-dependent\n    Gauss-Seidel preconditioner.\n    \"\"\"\n\n    def _solve_lower_triangular(L, b):\n        \"\"\"\n        Solves the lower triangular system L*x = b via forward substitution.\n        \"\"\"\n        n = len(b)\n        x = np.zeros(n, dtype=float)\n        for i in range(n):\n            s = np.dot(L[i, :i], x[:i])\n            if abs(L[i, i])  1e-16:\n                # Should not happen as the diagonal is positive definite\n                raise ValueError(\"Matrix is singular or near-singular.\")\n            x[i] = (b[i] - s) / L[i, i]\n        return x\n\n    def _run_preconditioned_gmres(A, b, precon_M_pi, precon_pi, tol, max_iter):\n        \"\"\"\n        Implementation of the left-preconditioned GMRES algorithm.\n        \"\"\"\n        n = A.shape[0]\n\n        def apply_preconditioner(z):\n            \"\"\"\n            Applies the Gauss-Seidel preconditioner M_inv.\n            y = M_inv * z\n            \"\"\"\n            # 1. Permute z to the new coordinate system\n            z_perm = z[precon_pi]\n            \n            # 2. Solve the lower triangular system in the permuted system\n            y_perm = _solve_lower_triangular(precon_M_pi, z_perm)\n            \n            # 3. Permute the solution back to the original coordinate system\n            y = np.zeros_like(y_perm)\n            y[precon_pi] = y_perm\n            return y\n\n        # Initial state for GMRES\n        x = np.zeros(n, dtype=float)\n        norm_b = np.linalg.norm(b)\n\n        if norm_b == 0:\n            return 0\n        \n        r0 = b - A @ x\n        initial_rel_res = np.linalg.norm(r0) / norm_b\n        if initial_rel_res = tol:\n            return 0\n\n        # Starting vector for Arnoldi iteration\n        r_tilde = apply_preconditioner(r0)\n        beta_gmres = np.linalg.norm(r_tilde)\n        \n        if beta_gmres  1e-16:\n            return 0\n\n        V = np.zeros((n, max_iter + 1), dtype=float)\n        H = np.zeros((max_iter + 1, max_iter), dtype=float)\n        V[:, 0] = r_tilde / beta_gmres\n\n        for k in range(max_iter):\n            # Arnoldi process (Modified Gram-Schmidt)\n            w = A @ V[:, k]\n            w_tilde = apply_preconditioner(w)\n            \n            for j in range(k + 1):\n                H[j, k] = np.dot(w_tilde, V[:, j])\n                w_tilde -= H[j, k] * V[:, j]\n            \n            H[k + 1, k] = np.linalg.norm(w_tilde)\n            \n            # Check for breakdown\n            if H[k + 1, k]  1e-16:\n                k_eff = k + 1\n                break\n            \n            V[:, k + 1] = w_tilde / H[k + 1, k]\n            \n            # Solve least squares and check for convergence on the true residual\n            k_eff = k + 1\n            H_k_sub = H[:k_eff + 1, :k_eff]\n            g0 = np.zeros(k_eff + 1)\n            g0[0] = beta_gmres\n            \n            y, _, _, _ = np.linalg.lstsq(H_k_sub, g0, rcond=None)\n            \n            x = V[:, :k_eff] @ y\n            rel_res = np.linalg.norm(b - A @ x) / norm_b\n            \n            if rel_res = tol:\n                return k_eff\n        else: # Loop completed without convergence\n          k_eff = max_iter\n\n        # Final check if loop was broken by breakdown or finished\n        H_k_sub = H[:k_eff, :k_eff]\n        g0 = np.zeros(k_eff)\n        g0[0] = beta_gmres\n        y, _, _, _ = np.linalg.lstsq(H_k_sub, g0, rcond=None)\n        x = V[:, :k_eff] @ y\n        rel_res = np.linalg.norm(b - A @ x) / norm_b\n        if rel_res = tol:\n            return k_eff\n\n        return max_iter\n\n    test_cases = [\n        (0.01, 20.0, \"natural\"),\n        (0.01, 20.0, \"reversed\"),\n        (0.01, -20.0, \"natural\"),\n        (0.01, -20.0, \"reversed\"),\n        (1.0, 2.0, \"natural\"),\n        (1.0, 2.0, \"reversed\"),\n    ]\n\n    n = 80\n    tol = 1e-8\n    max_iter = 200\n    h = 1.0 / (n + 1)\n    b = np.ones(n, dtype=float)\n    \n    results = []\n\n    for epsilon, beta, ordering_str in test_cases:\n        A = np.zeros((n, n), dtype=float)\n        \n        # Assemble the matrix A based on upwind discretization\n        if beta >= 0:\n            diag_val = 2 * epsilon / h**2 + beta / h\n            sub_diag_val = -epsilon / h**2 - beta / h\n            super_diag_val = -epsilon / h**2\n        else:  # beta  0\n            diag_val = 2 * epsilon / h**2 - beta / h\n            sub_diag_val = -epsilon / h**2\n            super_diag_val = -epsilon / h**2 + beta / h\n        \n        np.fill_diagonal(A, diag_val)\n        np.fill_diagonal(A[1:], sub_diag_val)\n        np.fill_diagonal(A[:, 1:], super_diag_val)\n        \n        # Define the permutation for the Gauss-Seidel preconditioner\n        if ordering_str == \"natural\":\n            pi = np.arange(n)\n        else:  # \"reversed\"\n            pi = np.arange(n - 1, -1, -1)\n            \n        # Construct the preconditioner matrix M_pi\n        A_perm = A[np.ix_(pi, pi)]\n        M_pi = np.tril(A_perm)\n\n        iterations = _run_preconditioned_gmres(A, b, M_pi, pi, tol, max_iter)\n        results.append(iterations)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}