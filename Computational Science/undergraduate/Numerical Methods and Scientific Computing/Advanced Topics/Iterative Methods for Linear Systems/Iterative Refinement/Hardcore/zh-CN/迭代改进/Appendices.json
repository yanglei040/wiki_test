{
    "hands_on_practices": [
        {
            "introduction": "这个练习将引导您手动完成一个迭代改进的步骤。通过处理一个简单的 $2 \\times 2$ 病态系统，您将亲身体验如何从一个初始近似解出发，计算残差并求解修正方程，从而获得一个更精确的解。这个实践旨在揭示迭代改进算法的核心机制，并直观地展示了为何一个小的残差并不总代表一个精确的解。",
            "id": "2182580",
            "problem": "考虑线性方程组 $Ax = b$，其中矩阵 $A$ 和向量 $b$ 定义如下：\n$$A = \\begin{pmatrix} 1  1 \\\\ 1  1.001 \\end{pmatrix}, \\quad b = \\begin{pmatrix} 3 \\\\ 3.002 \\end{pmatrix}$$\n该系统的一个近似解，记为 $x_0$，给定为 $x_0 = \\begin{pmatrix} 2.998 \\\\ 0 \\end{pmatrix}$。\n使用给定的矩阵 $A$ 和初始近似 $x_0$，执行一步迭代求精来计算一个更精确的解 $x_1$。在这一步中，要求精确求解对应的校正方程。\n\n请给出精炼解向量 $x_1$ 的分量。将最终答案表示为一个包含 $x_1$ 两个分量的行矩阵。如有必要，将每个分量四舍五入到四位有效数字。",
            "solution": "我们执行一步迭代求精。给定 $x_{0} = \\begin{pmatrix} 2.998 \\\\ 0 \\end{pmatrix}$，计算残差\n$$r = b - A x_{0}.$$\n首先计算\n$$A x_{0} = \\begin{pmatrix} 1  1 \\\\ 1  1.001 \\end{pmatrix} \\begin{pmatrix} 2.998 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 2.998 \\\\ 2.998 \\end{pmatrix}.$$\n因此\n$$r = \\begin{pmatrix} 3 \\\\ 3.002 \\end{pmatrix} - \\begin{pmatrix} 2.998 \\\\ 2.998 \\end{pmatrix} = \\begin{pmatrix} 0.002 \\\\ 0.004 \\end{pmatrix}.$$\n校正量 $d$ 通过精确求解校正方程得到\n$$A d = r, \\quad \\text{即} \\quad \\begin{pmatrix} 1  1 \\\\ 1  1.001 \\end{pmatrix} \\begin{pmatrix} d_{1} \\\\ d_{2} \\end{pmatrix} = \\begin{pmatrix} 0.002 \\\\ 0.004 \\end{pmatrix}.$$\n这给出了方程组\n$$d_{1} + d_{2} = 0.002, \\quad d_{1} + 1.001 d_{2} = 0.004.$$\n用第二个方程减去第一个方程：\n$$(d_{1} + 1.001 d_{2}) - (d_{1} + d_{2}) = 0.004 - 0.002 \\;\\Rightarrow\\; 0.001 d_{2} = 0.002 \\;\\Rightarrow\\; d_{2} = 2.$$\n然后\n$$d_{1} = 0.002 - d_{2} = 0.002 - 2 = -1.998.$$\n更新近似解：\n$$x_{1} = x_{0} + d = \\begin{pmatrix} 2.998 \\\\ 0 \\end{pmatrix} + \\begin{pmatrix} -1.998 \\\\ 2 \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix}.$$\n因此，精炼解恰好是 $\\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix}$，这已经满足了任何四舍五入的要求。",
            "answer": "$$\\boxed{\\begin{pmatrix} 1  2 \\end{pmatrix}}$$"
        },
        {
            "introduction": "在理解了迭代改进的基本流程后，下一个关键问题是：该算法在实际计算中为何有效？此练习通过一个精心设计的浮点运算场景，揭示了该方法的一个核心要求——使用更高精度计算残差。您将验证在低工作精度下，计算出的残差可能为零，从而掩盖了真实误差，而使用更高精度的“保护位”则能揭示真相。",
            "id": "3245538",
            "problem": "考虑一个标准化的以10为基的浮点系统 $\\mathcal{F}_{10}(t)$，该系统有 $t$ 位有效数字，采用舍入到最近的偶数（ties to even）的规则。假设工作精度为 $t_{w} = 2$，保护精度为 $t_{g} = 5$。在求解线性系统 $A x = b$ 的迭代改进法中，用于形成修正量的残差计算公式为 $r^{(0)}_{t} = \\operatorname{fl}_{t}\\!\\left(b - \\operatorname{fl}_{t}(A x^{(0)})\\right)$，其中 $\\operatorname{fl}_{t}$ 表示在 $\\mathcal{F}_{10}(t)$ 中将每个中间运算结果舍入到 $t$ 位有效数字。对于对角矩阵，矩阵向量积简化为分量式的标量积。\n\n请通过选择以下数据来设计一个例子，使得在工作精度下产生一个误导性的零残差，而在保护精度下则显示一个非零残差：\n$$\nA = \\begin{pmatrix}\n1.0005  0 \\\\\n0  0.9996\n\\end{pmatrix}, \\quad\nb = \\begin{pmatrix}\n1.0 \\\\\n1.0\n\\end{pmatrix}, \\quad\nx^{(0)} = \\begin{pmatrix}\n1.0 \\\\\n1.0\n\\end{pmatrix},\n$$\n其中 $A$、$b$ 和 $x^{(0)}$ 以保护精度 $\\mathcal{F}_{10}(t_{g})$ 存储。\n\n仅使用上述规则和浮点运算中残差的基本定义，完成以下任务：\n- 验证工作精度残差 $r^{(0)}_{t_{w}}$ 在 $\\mathcal{F}_{10}(t_{w})$ 中恰好为零向量。\n- 计算保护精度残差 $r^{(0)}_{t_{g}}$ 在 $\\mathcal{F}_{10}(t_{g})$ 中。\n- 计算欧几里得范数（2-范数）$\\|r^{(0)}_{t_{g}}\\|_{2}$。\n\n将 $\\|r^{(0)}_{t_{g}}\\|_{2}$ 的最终数值结果舍入到四位有效数字。无需单位。",
            "solution": "该问题要求在两种不同的浮点精度下分析残差计算，以说明迭代改进法中的一个潜在陷阱。浮点系统是以10为基的 $\\mathcal{F}_{10}(t)$，采用舍入到最近的偶数（ties to even）规则。\n\n提供的数据如下：\n工作精度位数，$t_w = 2$。\n保护精度位数，$t_g = 5$。\n矩阵 $A = \\begin{pmatrix} 1.0005  0 \\\\ 0  0.9996 \\end{pmatrix}$。\n向量 $b = \\begin{pmatrix} 1.0 \\\\ 1.0 \\end{pmatrix}$。\n初始猜测 $x^{(0)} = \\begin{pmatrix} 1.0 \\\\ 1.0 \\end{pmatrix}$。\n数据 $A$、$b$ 和 $x^{(0)}$ 以保护精度 $\\mathcal{F}_{10}(5)$ 存储。\n残差定义为 $r^{(0)}_{t} = \\operatorname{fl}_{t}\\!\\left(b - \\operatorname{fl}_{t}(A x^{(0)})\\right)$，其中 $\\operatorname{fl}_{t}$ 表示每个中间运算结果都舍入到 $t$ 位有效数字。\n\n该问题分为三个任务：验证工作精度残差为零，计算保护精度残差，以及求出保护精度残差的欧几里得范数。\n\n**第一部分：验证工作精度残差 $r^{(0)}_{t_{w}}$**\n\n我们使用工作精度 $t_w = 2$ 来计算残差。公式为 $r^{(0)}_{t_{w}} = \\operatorname{fl}_{2}\\!\\left(b - \\operatorname{fl}_{2}(A x^{(0)})\\right)$。计算按分量进行。\n\n首先，我们计算矩阵向量积 $y = \\operatorname{fl}_{2}(A x^{(0)})$。项 $\\operatorname{fl}_{2}(A x^{(0)})$ 意味着计算该乘积的算术运算在 $\\mathcal{F}_{10}(2)$ 中执行。输入矩阵 $A$ 和 $x^{(0)}$ 使用其 $t_g=5$ 的存储值，运算结果舍入到 $t_w=2$ 位数字。\n\n对于第一个分量 $y_1$：\n$$\ny_1 = \\operatorname{fl}_{2}\\left( A_{11} x_1^{(0)} + A_{12} x_2^{(0)} \\right) = \\operatorname{fl}_{2}\\left( 1.0005 \\times 1.0 + 0 \\times 1.0 \\right) = \\operatorname{fl}_{2}(1.0005)\n$$\n要将 $1.0005$ 舍入到2位有效数字，我们将其写成规格化形式 $1.0005 \\times 10^0$。我们必须在第二位有效数字后截断。第三位数字是0，小于5，所以我们向下舍入。\n$$\ny_1 = 1.0\n$$\n\n对于第二个分量 $y_2$：\n$$\ny_2 = \\operatorname{fl}_{2}\\left( A_{21} x_1^{(0)} + A_{22} x_2^{(0)} \\right) = \\operatorname{fl}_{2}\\left( 0 \\times 1.0 + 0.9996 \\times 1.0 \\right) = \\operatorname{fl}_{2}(0.9996)\n$$\n要将 $0.9996$ 舍入到2位有效数字，我们将其写成 $9.996 \\times 10^{-1}$。我们必须在第二位有效数字后截断。第三位数字是9，大于等于5，所以我们向上舍入。数字 $9.9$ 向上舍入为 $10$。\n$$\ny_2 = 10 \\times 10^{-1} = 1.0\n$$\n因此，在工作精度下计算的矩阵向量积为 $\\operatorname{fl}_{2}(A x^{(0)}) = \\begin{pmatrix} 1.0 \\\\ 1.0 \\end{pmatrix}$。\n\n接下来，我们计算残差向量 $r^{(0)}_{t_w} = \\operatorname{fl}_{2}(b - y)$。向量 $b$ 的分量为 $b_1 = 1.0$ 和 $b_2 = 1.0$。\n对于残差的第一个分量：\n$$\nr^{(0)}_{t_w, 1} = \\operatorname{fl}_{2}(b_1 - y_1) = \\operatorname{fl}_{2}(1.0 - 1.0) = \\operatorname{fl}_{2}(0.0) = 0.0\n$$\n对于残差的第二个分量：\n$$\nr^{(0)}_{t_w, 2} = \\operatorname{fl}_{2}(b_2 - y_2) = \\operatorname{fl}_{2}(1.0 - 1.0) = \\operatorname{fl}_{2}(0.0) = 0.0\n$$\n因此，工作精度残差是零向量，这与待验证的结论一致：\n$$\nr^{(0)}_{t_{w}} = \\begin{pmatrix} 0.0 \\\\ 0.0 \\end{pmatrix}\n$$\n\n**第二部分：计算保护精度残差 $r^{(0)}_{t_{g}}$**\n\n我们现在使用保护精度 $t_g = 5$ 来计算残差。公式为 $r^{(0)}_{t_{g}} = \\operatorname{fl}_{5}\\!\\left(b - \\operatorname{fl}_{5}(A x^{(0)})\\right)$。所有数据（$A, b, x^{(0)}$）都已存储在 $\\mathcal{F}_{10}(5)$ 中，因此直接使用它们的值。\n- $A=\\begin{pmatrix} 1.0005  0 \\\\ 0  0.99960 \\end{pmatrix}$\n- $b=\\begin{pmatrix} 1.0000 \\\\ 1.0000 \\end{pmatrix}$\n- $x^{(0)}=\\begin{pmatrix} 1.0000 \\\\ 1.0000 \\end{pmatrix}$\n\n首先，我们计算矩阵向量积 $y = \\operatorname{fl}_{5}(A x^{(0)})$。\n对于第一个分量 $y_1$：\n$$\ny_1 = \\operatorname{fl}_{5}\\left( 1.0005 \\times 1.0000 \\right) = \\operatorname{fl}_{5}(1.0005)\n$$\n数字 $1.0005$ 有5位有效数字，因此无需舍入。$y_1 = 1.0005$。\n\n对于第二个分量 $y_2$：\n$$\ny_2 = \\operatorname{fl}_{5}\\left( 0.99960 \\times 1.0000 \\right) = \\operatorname{fl}_{5}(0.99960)\n$$\n数字 $0.99960$（$9.9960 \\times 10^{-1}$）有5位有效数字，因此无需舍入。$y_2 = 0.99960$。\n因此，$\\operatorname{fl}_{5}(A x^{(0)}) = \\begin{pmatrix} 1.0005 \\\\ 0.99960 \\end{pmatrix}$。\n\n接下来，我们计算残差向量 $r^{(0)}_{t_g} = \\operatorname{fl}_{5}(b - y)$。\n对于第一个分量：\n$$\nr^{(0)}_{t_g, 1} = \\operatorname{fl}_{5}(b_1 - y_1) = \\operatorname{fl}_{5}(1.0000 - 1.0005) = \\operatorname{fl}_{5}(-0.0005)\n$$\n数字 $-0.0005$ 在 $\\mathcal{F}_{10}(5)$ 中可以写成 $-5.0000 \\times 10^{-4}$。无需舍入。$r^{(0)}_{t_g, 1} = -0.0005$。\n\n对于第二个分量：\n$$\nr^{(0)}_{t_g, 2} = \\operatorname{fl}_{5}(b_2 - y_2) = \\operatorname{fl}_{5}(1.0000 - 0.99960) = \\operatorname{fl}_{5}(0.00040)\n$$\n数字 $0.00040$ 在 $\\mathcal{F}_{10}(5)$ 中可以写成 $4.0000 \\times 10^{-4}$。无需舍入。$r^{(0)}_{t_g, 2} = 0.0004$。\n\n因此，保护精度残差为：\n$$\nr^{(0)}_{t_{g}} = \\begin{pmatrix} -0.0005 \\\\ 0.0004 \\end{pmatrix}\n$$\n\n**第三部分：计算欧几里得范数 $\\|r^{(0)}_{t_{g}}\\|_{2}$**\n\n最后一步是计算保护精度残差向量 $r^{(0)}_{t_{g}}$ 的欧几里得范数。计算以精确算术进行，最终结果舍入到四位有效数字。\n$$\n\\|r^{(0)}_{t_{g}}\\|_{2} = \\sqrt{(r^{(0)}_{t_g, 1})^2 + (r^{(0)}_{t_g, 2})^2} = \\sqrt{(-0.0005)^2 + (0.0004)^2}\n$$\n我们计算平方根内的各项：\n$$\n(-0.0005)^2 = (-5 \\times 10^{-4})^2 = 25 \\times 10^{-8}\n$$\n$$\n(0.0004)^2 = (4 \\times 10^{-4})^2 = 16 \\times 10^{-8}\n$$\n将这些值相加：\n$$\n25 \\times 10^{-8} + 16 \\times 10^{-8} = 41 \\times 10^{-8} = 4.1 \\times 10^{-7}\n$$\n现在，我们取平方根：\n$$\n\\|r^{(0)}_{t_{g}}\\|_{2} = \\sqrt{41 \\times 10^{-8}} = \\sqrt{41} \\times 10^{-4}\n$$\n数值计算 $\\sqrt{41}$：\n$$\n\\sqrt{41} \\approx 6.403124237\n$$\n所以，范数约为 $6.403124237 \\times 10^{-4}$。将此值舍入到四位有效数字，我们得到：\n$$\n\\|r^{(0)}_{t_{g}}\\|_{2} \\approx 6.403 \\times 10^{-4}\n$$",
            "answer": "$$\\boxed{6.403 \\times 10^{-4}}$$"
        },
        {
            "introduction": "现在，让我们从纸笔计算走向实际编程。这个练习要求您实现迭代改进算法，并将其应用于求解以病态著称的希尔伯特矩阵线性系统。通过追踪每次迭代后解的有效数字增加量，您将能够量化地观察该方法在不同病态程度下的收敛效能及其局限性，从而将理论知识与计算实践紧密联系起来。",
            "id": "3245403",
            "problem": "您需要实现并分析迭代求精方法，用以求解一个以经典的病态矩阵——希尔伯特矩阵为系数的线性方程组。目标是量化每次迭代在解中获得的以10为底的精度位数。\n\n使用的基本原理和定义：\n- 一个线性方程组的形式为 $A x = b$，其中 $A \\in \\mathbb{R}^{n \\times n}$，$x \\in \\mathbb{R}^{n}$，$b \\in \\mathbb{R}^{n}$。希尔伯特矩阵 $H \\in \\mathbb{R}^{n \\times n}$ 定义为 $H_{ij} = \\frac{1}{i + j - 1}$，其中 $i, j \\in \\{1, \\dots, n\\}$。\n- 第 $k$ 次迭代的残差为 $r^{(k)} = b - A x^{(k)}$。\n- 第 $k$ 次迭代的迭代求精更新通过求解 $A d^{(k)} = r^{(k)}$ 生成一个校正量 $d^{(k)}$，并设置 $x^{(k+1)} = x^{(k)} + d^{(k)}$。\n- 第 $k$ 次迭代时正确的以10为底的位数定义为\n$$\nD^{(k)} = -\\log_{10}\\!\\left(\\frac{\\lVert x^{(k)} - x^\\star \\rVert_\\infty}{\\lVert x^\\star \\rVert_\\infty}\\right),\n$$\n其中 $x^\\star$ 是精确解。为了在双精度运算中保持数值稳定性，报告的 $D^{(k)}$ 应在16位处饱和，即使用\n$$\n\\tilde{D}^{(k)} = -\\log_{10}\\!\\left(\\max\\!\\left(\\frac{\\lVert x^{(k)} - x^\\star \\rVert_\\infty}{\\lVert x^\\star \\rVert_\\infty},\\,10^{-16}\\right)\\right).\n$$\n- 每次迭代中正确位数的增益为 $G^{(k)} = \\tilde{D}^{(k)} - \\tilde{D}^{(k-1)}$，其中 $k \\ge 1$。初始精度 $\\tilde{D}^{(0)}$ 对应于在任何求精迭代之前通过直接求解 $A x = b$ 得到的解。\n\n科学真实性和设置：\n- 已知希尔伯特矩阵是病态的，其条件数随着 $n$ 的增加而迅速增长。迭代求精可以通过求解残差方程来校正累积误差，从而改善解的精度。\n- 所有计算均使用双精度浮点运算（$64$位）。\n\n程序要求：\n- 构建大小为 $n$ 的希尔伯特矩阵 $A$。\n- 将真实解设置为 $x^\\star = \\mathbf{1}$（长度为 $n$ 的全1向量）。计算 $b = A x^\\star$。\n- 通过直接求解 $A x = b$ 计算初始解 $x^{(0)}$。\n- 执行 $m$ 步上述的迭代求精过程。\n- 在每次迭代 $k \\in \\{1, \\dots, m\\}$ 后，计算并记录 $G^{(k)}$。\n- 对于每个测试用例，输出列表 $[G^{(1)}, G^{(2)}, \\dots, G^{(m)}]$。\n\n测试套件：\n- 情况1：$n = 2$, $m = 5$（边界情况，相对良态）。\n- 情况2：$n = 5$, $m = 5$（中度病态）。\n- 情况3：$n = 8$, $m = 5$（具有挑战性的病态）。\n- 情况4：$n = 12$, $m = 5$（严重病态的边缘情况）。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含所有测试用例的每次迭代增益，格式为由逗号分隔的列表的列表，不含空格，并用方括号括起来。例如，输出应类似于 $[[g_{1,1},\\dots,g_{1,m}],[g_{2,1},\\dots,g_{2,m}],\\dots]$，其中 $g_{i,k}$ 是测试用例 $i$ 中第 $k$ 次迭代的增益。\n- 所有数字都应以标准十进制浮点数形式打印，此问题不涉及任何物理单位。",
            "solution": "用户提供的问题陈述已经过独立验证，并被确定为数值线性代数领域中一个定义明确、有科学依据且客观的问题。该问题没有矛盾、歧义和事实错误。因此，下面提供了完整的解决方案。\n\n该问题要求实现并分析迭代求精算法，用于求解线性方程组 $A x = b$，其中 $A$ 是臭名昭著的病态矩阵——希尔伯特矩阵。目标是量化在每个求精步骤中解的精度增益，以10为底的位数来衡量。\n\n大小为 $n \\times n$ 的希尔伯特矩阵 $H$ 由其元素 $H_{ij} = \\frac{1}{i + j - 1}$ 定义，其中行和列索引 $i, j$ 从1开始。其条件数随 $n$ 的增加而急剧增长，使其成为数值稳定性的经典测试案例。对于一个方程组 $A x = b$，当 $A$ 是病态矩阵时，使用像LU分解这样的直接方法求解会累积显著的浮点误差，导致计算出的解不准确。\n\n迭代求精是一种旨在提高计算解精度的方法。设 $x^{(0)}$ 是通过直接求解器获得的初始解。由于有限精度运算，$x^{(0)}$ 与真实解 $x^\\star$ 之间存在误差 $e^{(0)} = x^\\star - x^{(0)}$。该方法的基础在于估计和校正这个误差。\n\n对于近似解 $x^{(k)}$，残差向量定义为 $r^{(k)} = b - A x^{(k)}$。通过代入 $b = A x^\\star$，残差可以与真实误差 $e^{(k)} = x^\\star - x^{(k)}$ 相关联：\n$$\nr^{(k)} = A x^\\star - A x^{(k)} = A (x^\\star - x^{(k)}) = A e^{(k)}\n$$\n这个方程表明，真实误差 $e^{(k)}$ 是线性方程组 $A e^{(k)} = r^{(k)}$ 的解。虽然我们无法精确计算 $e^{(k)}$（因为这相当于完美地解决了原始问题），但我们可以通过求解残差系统来计算它的一个近似值，我们记为 $d^{(k)}$：\n$$\nA d^{(k)} = r^{(k)}\n$$\n向量 $d^{(k)}$ 作为当前解的计算校正量。下一个（希望更精确的）解 $x^{(k+1)}$ 通过应用这个校正量获得：\n$$\nx^{(k+1)} = x^{(k)} + d^{(k)}\n$$\n这个过程被迭代重复。迭代求精的一个关键方面是，理想情况下，残差 $r^{(k)}$ 的计算精度应高于其余计算。然而，本问题指定所有运算均使用标准双精度（64位浮点数），这使我们能够观察到在没有更高精度可用时该方法的局限性。\n\n为了量化算法的性能，我们测量每一步解的精度。解 $x^{(k)}$ 中正确的以10为底的位数是相对于真实解 $x^\\star$ 定义的：\n$$\nD^{(k)} = -\\log_{10}\\!\\left(\\frac{\\lVert x^{(k)} - x^\\star \\rVert_\\infty}{\\lVert x^\\star \\rVert_\\infty}\\right)\n$$\n其中 $\\lVert \\cdot \\rVert_\\infty$ 是无穷范数（向量分量绝对值的最大值）。由于双精度浮点运算的有限精度约为16个十进制位，因此使用一个饱和的精度度量是实用的，该度量不超过此限制并避免对零取对数：\n$$\n\\tilde{D}^{(k)} = -\\log_{10}\\!\\left(\\max\\!\\left(\\frac{\\lVert x^{(k)} - x^\\star \\rVert_\\infty}{\\lVert x^\\star \\rVert_\\infty},\\,10^{-16}\\right)\\right)\n$$\n在第 $k$ 次迭代中的精度增益是与上一步正确位数的差异：\n$$\nG^{(k)} = \\tilde{D}^{(k)} - \\tilde{D}^{(k-1)} \\quad \\text{for } k \\ge 1\n$$\n这里，$\\tilde{D}^{(0)}$ 是通过直接求解得到的初始解 $x^{(0)}$ 的精度。\n\n每个测试用例 $(n, m)$ 的算法流程如下：\n1.  **系统设置**：\n    *   构建 $n \\times n$ 的希尔伯特矩阵 $A$，其中基于零的行索引 $i$ 和列索引 $j$ 处的元素为 $A_{ij} = \\frac{1}{(i+1) + (j+1) - 1} = \\frac{1}{i+j+1}$。\n    *   将真实解定义为全1向量，$x^\\star = \\mathbf{1} \\in \\mathbb{R}^n$。\n    *   计算右侧向量 $b = A x^\\star$。这确保了误差计算有一个已知的基准真相。由于对所有 $j$ 都有 $x^\\star_j = 1$，每个分量 $b_i$ 都是 $A$ 的第 $i$ 行的和：$b_i = \\sum_{j=1}^{n} \\frac{1}{i+j-1}$。\n\n2.  **初始解**：\n    *   使用标准的直接数值求解器求解方程组 $A x = b$，计算初始近似解 $x^{(0)}$。\n    *   计算初始精度 $\\tilde{D}^{(0)}$。\n\n3.  **迭代求精**：\n    *   初始化当前解 $x \\leftarrow x^{(0)}$ 和前一次的精度 $D_{prev} \\leftarrow \\tilde{D}^{(0)}$。\n    *   对于 $k$ 从 $1$ 到 $m$：\n        a. 计算残差：$r = b - A x$。\n        b. 求解校正量：$A d = r$。\n        c. 更新解：$x \\leftarrow x + d$。\n        d. 计算新的精度：$D_{current} = \\tilde{D}^{(k)}$。\n        e. 计算并记录增益：$G^{(k)} = D_{current} - D_{prev}$。\n        f. 更新前一次的精度：$D_{prev} \\leftarrow D_{current}$。\n\n4.  **输出**：为每个测试用例报告增益列表 $[G^{(1)}, G^{(2)}, \\dots, G^{(m)}]$。\n\n对于条件数较低的矩阵（例如，$n=2$），初始解已经非常精确，求精几乎不带来增益。随着 $n$ 的增加（$n=5, 8$），条件数增长，初始解的质量下降，预计迭代求精将在最初几次迭代中提供显著的精度增益。对于 $n=12$，希尔伯特矩阵的条件数超过 $10^{16}$，这大约是双精度数的精度极限。此时，计算出的残差被噪声主导，求精过程预计会停滞或失败，产生极小甚至负的增益。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and analyzes iterative refinement for linear systems involving\n    the Hilbert matrix for a suite of test cases.\n    \"\"\"\n    # Test cases are defined as tuples (n, m), where n is the matrix size\n    # and m is the number of refinement iterations.\n    test_cases = [\n        (2, 5),   # Case 1: Well-conditioned\n        (5, 5),   # Case 2: Moderately ill-conditioned\n        (8, 5),   # Case 3: Challenging ill-conditioning\n        (12, 5),  # Case 4: Severe ill-conditioning\n    ]\n\n    all_results = []\n\n    for n, m in test_cases:\n        # Step 1: System Setup\n        # Construct the n x n Hilbert matrix A.\n        # For 0-based indices i, j, the formula is H_ij = 1 / (i + j + 1).\n        A = np.fromfunction(lambda i, j: 1.0 / (i + j + 1), (n, n), dtype=float)\n\n        # Define the true solution as the all-ones vector.\n        x_star = np.ones(n, dtype=float)\n\n        # Calculate the right-hand side vector b = A * x_star.\n        b = A @ x_star\n\n        # Define a helper function to calculate the number of correct digits.\n        def get_saturated_digits(x_approx, x_true):\n            \"\"\"\n            Calculates the saturated number of correct base-10 digits.\n            \"\"\"\n            # The infinity norm of x_star is always 1.0.\n            norm_x_true_inf = 1.0\n            \n            # Calculate relative error using the infinity norm.\n            relative_error = np.linalg.norm(x_approx - x_true, np.inf) / norm_x_true_inf\n            \n            # Apply saturation at 10^-16 to handle finite precision and avoid log(0).\n            effective_error = max(relative_error, 1e-16)\n            \n            return -np.log10(effective_error)\n\n        # Step 2: Initial Solution\n        # Compute the initial solution x^(0) using a direct solver.\n        x_k = np.linalg.solve(A, b)\n\n        # Calculate the initial number of correct digits, D_tilde^(0).\n        D_prev = get_saturated_digits(x_k, x_star)\n\n        # Step 3: Iterative Refinement\n        gains_for_case = []\n        for _ in range(m):\n            # a. Compute the residual in double precision.\n            r_k = b - A @ x_k\n\n            # b. Solve for the correction vector d.\n            d_k = np.linalg.solve(A, r_k)\n\n            # c. Update the solution.\n            x_k = x_k + d_k\n\n            # d. Calculate the new accuracy.\n            D_current = get_saturated_digits(x_k, x_star)\n\n            # e. Calculate and record the gain.\n            gain = D_current - D_prev\n            gains_for_case.append(gain)\n\n            # f. Update the previous accuracy for the next iteration.\n            D_prev = D_current\n        \n        all_results.append(gains_for_case)\n\n    # Final print statement in the exact required format.\n    # Format each sublist of gains into a comma-separated string \"[g1,g2,...]\".\n    formatted_sublists = [f\"[{','.join(map(str, sublist))}]\" for sublist in all_results]\n    # Join all formatted sublists into the final output string.\n    print(f\"[{','.join(formatted_sublists)}]\")\n\nsolve()\n```"
        }
    ]
}