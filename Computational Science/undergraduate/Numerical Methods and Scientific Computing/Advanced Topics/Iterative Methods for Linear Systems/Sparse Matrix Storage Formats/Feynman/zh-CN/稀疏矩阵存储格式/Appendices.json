{
    "hands_on_practices": [
        {
            "introduction": "要真正掌握稀疏矩阵格式，我们必须首先学会解读它们的语言。第一个练习提供了一个基础的动手实践：将一个以广泛使用的压缩稀疏行（CSR）格式存储的矩阵，转换回我们所熟悉的密集形式 。通过手动追踪指针和索引，你将建立一个关于CSR格式如何高效组织非零数据的具体心智模型。",
            "id": "2204554",
            "problem": "在许多科学和工程应用中，矩阵通常是“稀疏”的，这意味着它们的大部分元素都为零。存储所有这些零是低效的。压缩稀疏行（CSR）格式是一种通过使用三个一维数组来存储稀疏矩阵的常用方法。\n\n考虑一个大小为 $4 \\times 4$ 的稀疏矩阵 $A$。在 CSR 格式中（使用从0开始的索引），该矩阵由以下三个数组表示：\n1.  一个数组 `V`，包含 $A$ 的非零元素，按行从左到右读取。\n2.  一个数组 `C`，包含 `V` 中每个对应元素的列索引。\n3.  一个大小为 $m+1$（其中 $m$ 是行数）的数组 `R`（行指针），其中第 $i$ 个元素指示第 $i$ 行的数据在 `V` 和 `C` 中的起始索引。`R` 的最后一个元素是非零元素的总数。\n\n用于我们的 $4 \\times 4$ 矩阵 $A$ 的三个数组如下所示：\n- `V = [5.1, -1.2, 2.0, -3.5, 4.0, 9.8]`\n- `C = [1, 3, 0, 2, 3, 0]`\n- `R = [0, 2, 3, 5, 6]`\n\n重建原始的 $4 \\times 4$ 稠密矩阵 $A$。请将您的答案以 $4 \\times 4$ 矩阵的形式呈现。",
            "solution": "我们使用基于0索引的 CSR 定义。对于每个行索引 $i \\in \\{0,1,2,3\\}$，第 $i$ 行的非零项存储在 `V` 和 `C` 中索引 $j$ 从 $R[i]$ 到 $R[i+1]-1$ 的部分，其中列索引为 $C[j]$，值为 $V[j]$。最后一个元素 $R[4]=6$ 等于非零项的总数，这与 $\\lvert V \\rvert=6$ 相匹配。\n\n第0行：索引 $j=R[0]\\ldots R[1]-1=0\\ldots 1$。\n- $j=0$：$C[0]=1$，$V[0]=5.1$ 得到 $A_{0,1}=5.1$。\n- $j=1$：$C[1]=3$，$V[1]=-1.2$ 得到 $A_{0,3}=-1.2$。\n因此，第0行为 $[0,\\,5.1,\\,0,\\,-1.2]$。\n\n第1行：索引 $j=R[1]\\ldots R[2]-1=2\\ldots 2$。\n- $j=2$：$C[2]=0$，$V[2]=2.0$ 得到 $A_{1,0}=2.0$。\n因此，第1行为 $[2.0,\\,0,\\,0,\\,0]$。\n\n第2行：索引 $j=R[2]\\ldots R[3]-1=3\\ldots 4$。\n- $j=3$：$C[3]=2$，$V[3]=-3.5$ 得到 $A_{2,2}=-3.5$。\n- $j=4$：$C[4]=3$，$V[4]=4.0$ 得到 $A_{2,3}=4.0$。\n因此，第2行为 $[0,\\,0,\\,-3.5,\\,4.0]$。\n\n第3行：索引 $j=R[3]\\ldots R[4]-1=5\\ldots 5$。\n- $j=5$：$C[5]=0$，$V[5]=9.8$ 得到 $A_{3,0}=9.8$。\n因此，第3行为 $[9.8,\\,0,\\,0,\\,0]$。\n\n因此，重建的稠密矩阵 $A$ 为\n$$\n\\begin{pmatrix}\n0  & 5.1  & 0  & -1.2 \\\\\n2.0  & 0  & 0  & 0 \\\\\n0  & 0  & -3.5  & 4.0 \\\\\n9.8  & 0  & 0  & 0\n\\end{pmatrix}.\n$$",
            "answer": "$$\\boxed{\\begin{pmatrix}0 & 5.1 & 0 & -1.2 \\\\ 2.0 & 0 & 0 & 0 \\\\ 0 & 0 & -3.5 & 4.0 \\\\ 9.8 & 0 & 0 & 0\\end{pmatrix}}$$"
        },
        {
            "introduction": "稀疏矩阵格式不仅仅是静态的数据结构；它们的适用性常常取决于数据需要如何被修改。这个实践通过让你量化在坐标（COO）和压缩稀疏行（CSR）两种格式中删除一个元素的“更新成本”，来深入探究稀疏格式的动态特性 。这一比较将揭示一个更简单、更灵活的格式（COO）与一个为矩阵运算设计、结构化更强、更高效的格式（CSR）之间的实际权衡。",
            "id": "2204564",
            "problem": "在数值分析中，稀疏矩阵（其中大部分元素为零的矩阵）通常使用专门的格式进行存储，以节省内存和计算时间。两种常见的格式是坐标（COO）格式和压缩稀疏行（CSR）格式。假设所有数组索引都是从0开始的。\n\n-   在**坐标（COO）**格式中，一个矩阵由三个长度为 `nnz`（非零元素的数量）的数组表示：`values`、`row_indices` 和 `col_indices`。对于每个非零元素，其值、行索引和列索引存储在这三个数组的相应位置。这些元素通常按行排序，然后按列排序。\n\n-   在**压缩稀疏行（CSR）**格式中，一个矩阵由三个数组表示：`values`（长度为 `nnz`）、`col_indices`（长度为 `nnz`）和 `row_ptr`（长度为 `num_rows + 1`）。`values` 和 `col_indices` 数组按行存储非零元素的值及其列索引。`row_ptr` 数组存储每行起始元素在 `values` 数组中的索引。具体来说，第 `i` 行的非零元素存储在 `values` 数组中从索引 `row_ptr[i]` 到 `row_ptr[i+1] - 1` 的位置。\n\n考虑以下 5x5 的稀疏矩阵 `M`：\n$$\nM = \\begin{pmatrix}\n7  & 0  & 0  & 2  & 0 \\\\\n0  & 0  & 8  & 0  & 0 \\\\\n1  & 0  & 0  & 0  & 3 \\\\\n0  & 5  & 0  & 9  & 0 \\\\\n0  & 0  & 4  & 0  & 6\n\\end{pmatrix}\n$$\n\n假设此矩阵以 COO 和 CSR 两种格式存储。对矩阵进行了一项修改：将非零元素 `M[3, 1]`（其值为 5）设置为 0。为了在存储格式中反映这一变化，必须从存储数组中删除相应的条目，以保持紧凑的表示（即，不显式存储零）。这个删除操作是通过将相关数组中所有后续元素向前移动以填补空缺来实现的。\n\n我们将“更新成本”定义为在存储数组（`values`、`row_indices`、`col_indices`、`row_ptr`）中必须重写为新值的单个数字的总数。这包括被移动的元素以及任何需要调整的指针。\n\n设 `C_COO` 为 COO 格式的更新成本，`C_CSR` 为 CSR 格式的更新成本。计算总更新成本 `C_total = C_COO + C_CSR`。请用一个整数表示你的答案。",
            "solution": "首先计算非零元素的数量并确定一个一致的顺序。矩阵在位置 $(0,0),(0,3),(1,2),(2,0),(2,4),(3,1),(3,3),(4,2),(4,4)$ 处有非零元素，所以 $\\mathrm{nnz}=9$。在行主序（按行排序，然后按列排序）下，线性索引 $0$ 到 $8$ 依次对应这些位置，因此 $(3,1)$ 的线性索引为 $k=5$。\n\nCOO 更新成本：三个数组 $\\text{values}$、$\\text{row\\_indices}$、$\\text{col\\_indices}$ 的长度均为 $9$。删除索引 $k=5$ 处的条目需要将每个后续元素向左移动一个位置以填补空缺。每个数组中被移动的元素数量为 $\\mathrm{nnz}-(k+1)=9-6=3$。每个被移动的元素都是一次重写。因此，\n$$\nC_{\\mathrm{COO}}=3 \\text{ 个数组}\\times 3 \\text{ 次重写/数组}=9.\n$$\n\nCSR 更新成本：各数组为\n- $\\text{values}=[7,2,8,1,3,5,9,4,6]$,\n- $\\text{col\\_indices}=[0,3,2,0,4,1,3,2,4]$,\n- $\\text{row\\_ptr}=(0,2,3,5,7,9)$,\n其中 $\\text{row\\_ptr}[i+1]-\\text{row\\_ptr}[i]$ 等于第 $i$ 行的非零元素数量。\n\n条目 $(3,1)$ 是第 $3$ 行的第一个元素，位于全局索引 $k=5$ 处。删除它会强制将连续的 $\\text{values}$ 和 $\\text{col\\_indices}$ 数组中的所有后续元素向左移动，即每个数组需要 $\\mathrm{nnz}-(k+1)=9-6=3$ 次重写。因此，这两个数组贡献了 $3+3=6$ 次重写。\n\n对于 $\\text{row\\_ptr}$，被修改行之后的所有行的条目必须减 1。具体来说，$\\text{row\\_ptr}[4]$ 和 $\\text{row\\_ptr}[5]$ 发生变化（从 $7$ 变为 $6$，从 $9$ 变为 $8$），而 $\\text{row\\_ptr}[0],\\text{row\\_ptr}[1],\\text{row\\_ptr}[2],\\text{row\\_ptr}[3]$ 保持不变。因此，有 $2$ 次指针重写。\n\n因此，\n$$\nC_{\\mathrm{CSR}}=3+3+2=8.\n$$\n\n将两种格式的成本相加，得到\n$$\nC_{\\text{total}}=C_{\\mathrm{COO}}+C_{\\mathrm{CSR}}=9+8=17.\n$$",
            "answer": "$$\\boxed{17}$$"
        },
        {
            "introduction": "理解的最终检验是应用。这个高级实践将挑战你实现科学计算中最基础的算法之一：稀疏矩阵乘法（SpGEMM）。你将把一个CSR格式的矩阵与一个CSC格式的矩阵相乘，这种组合可以实现一个特别优雅和高效的算法。成功完成此任务，表明你对这些格式如何支持高性能计算已具备了深入、实用的掌握。",
            "id": "2440279",
            "problem": "您必须编写一个完整的程序，计算稀疏矩阵-矩阵乘积 $C = A \\cdot B$，其中 $A$ 以压缩稀疏行（CSR）格式给出，$B$ 以压缩稀疏列（CSC）格式给出。所有索引都是从零开始的。乘积必须在实数上进行，输出必须仅表示 $C$ 的非零元，省略掉任何绝对值严格小于预设容差的元素。\n\n定义和要求：\n\n- 矩阵 $A$ 的形状为 $m \\times k$，并由三个数组以 CSR 格式指定：$A_p$（长度为 $m+1$ 的行指针）、$A_j$（长度为 $\\mathrm{nnz}(A)$ 的列索引）和 $A_x$（长度为 $\\mathrm{nnz}(A)$ 的值）。$A$ 的第 $i$ 行的非零元位于段 $A_p[i]$ 到 $A_p[i+1]-1$ 中，相应的列索引来自 $A_j$，值来自 $A_x$。允许在同一行中出现重复的列索引，并且必须将其解释为对该矩阵元素值的累加贡献。\n- 矩阵 $B$ 的形状为 $k \\times n$，并由三个数组以 CSC 格式指定：$B_p$（长度为 $n+1$ 的列指针）、$B_i$（长度为 $\\mathrm{nnz}(B)$ 的行索引）和 $B_x$（长度为 $\\mathrm{nnz}(B)$ 的值）。$B$ 的第 $c$ 列的非零元位于段 $B_p[c]$ 到 $B_p[c+1]-1$ 中，相应的行索引来自 $B_i$，值来自 $B_x$。允许在同一列中出现重复的行索引，并且必须将其解释为对该矩阵元素值的累加贡献。\n- 乘积由基本规则定义\n$$\nC_{i,c} = \\sum_{j=0}^{k-1} A_{i,j} \\, B_{j,c},\n$$\n对于所有行索引 $i \\in \\{0,\\dots,m-1\\}$ 和列索引 $c \\in \\{0,\\dots,n-1\\}$。\n- 您的程序必须以坐标（COO）格式构建 $C$ 作为非零元的列表，并先按行后按列排序：输出三个列表 $I$、$J$ 和 $V$，其中 $I[t]$ 和 $J[t]$ 是第 $t$ 个非零元的行和列索引，$V[t]$ 是其值，且 $(I[t],J[t])$ 按行再按列的字典序排序。任何绝对值严格小于容差 $\\tau$ 的元素都必须省略；取 $\\tau = 10^{-12}$。\n- 所有索引必须是从零开始的整数。所有值都是实数。不涉及物理单位。\n\n测试套件：\n\n您的程序必须为以下四个测试用例计算结果。每个测试用例提供 $m$、$k$、$n$、用于 $A$ 的 CSR 数组以及用于 $B$ 的 CSC 数组。\n\n- 测试用例 1：\n  - $m = 3$, $k = 4$, $n = 2$.\n  - $A_p = [0,3,4,6]$, $A_j = [0,1,1,2,1,3]$, $A_x = [1.0,-2.0,0.5,3.0,4.0,-1.0]$.\n  - $B_p = [0,4,7]$, $B_i = [0,1,1,3,1,2,3]$, $B_x = [5.0,1.0,-1.0,2.0,-3.0,1.0,4.0]$.\n- 测试用例 2：\n  - $m = 2$, $k = 0$, $n = 3$.\n  - $A_p = [0,0,0]$, $A_j = []$, $A_x = []$.\n  - $B_p = [0,0,0,0]$, $B_i = []$, $B_x = []$.\n- 测试用例 3：\n  - $m = 2$, $k = 3$, $n = 2$.\n  - $A_p = [0,0,2]$, $A_j = [0,2]$, $A_x = [2.0,-2.0]$.\n  - $B_p = [0,0,2]$, $B_i = [0,2]$, $B_x = [-1.0,-1.0]$.\n- 测试用例 4：\n  - $m = 1$, $k = 1$, $n = 1$.\n  - $A_p = [0,1]$, $A_j = [0]$, $A_x = [-7.5]$.\n  - $B_p = [0,1]$, $B_i = [0]$, $B_x = [0.2]$.\n\n答案规范：\n\n- 对于每个测试用例，您的程序必须输出列表三元组 $[I,J,V]$，以行主序描述 $C$ 的非零元，如上所述。请完全按照输入数组定义的从零开始的索引，并应用容差 $\\tau = 10^{-12}$ 来丢弃绝对值严格小于 $\\tau$ 的元素。\n- 最终输出格式：您的程序必须生成单行，其中包含所有四个测试用例的结果列表。每个测试用例的结果本身是一个包含三个列表的列表。最后一行必须是一个由方括号括起来的列表，其中条目由逗号分隔，且没有任何空格。例如，如果有两个测试用例，格式将是 $[[I_1,J_1,V_1],[I_2,J_2,V_2]]$，但会用实际计算出的列表替换。\n\n您的程序不能读取任何输入，除了所要求的单个输出行外，也不能写入任何内容。唯一可接受的输出是如上所述的列表中的整数和浮点数；不允许有任何额外的文本。",
            "solution": "所述问题是有效的。这是一个在数值线性代数中定义明确、有科学依据的问题，而数值线性代数是计算科学与工程中的一个基础学科。稀疏矩阵格式——压缩稀疏行（CSR）和压缩稀疏列（CSC）——以及矩阵乘法运算的定义都是标准的。测试用例所需的所有参数和数据都已提供，问题本身没有歧义或矛盾。\n\n目标是计算矩阵乘积 $C = A \\cdot B$，其中 $A$ 是一个 $m \\times k$ 的 CSR 格式矩阵，$B$ 是一个 $k \\times n$ 的 CSC 格式矩阵。得到的 $m \\times n$ 矩阵 $C$ 必须以坐标（COO）格式表示，由三个列表组成，分别用于行索引（$I$）、列索引（$J$）和值（$V$）。\n\n矩阵乘积的基本定义给出了矩阵 $C$ 的元素 $C_{i,c}$，即 $A$ 的第 $i$ 行与 $B$ 的第 $c$ 列的点积：\n$$\nC_{i,c} = \\sum_{j=0}^{k-1} A_{i,j} B_{j,c}\n$$\n所提供的存储格式对于此计算是最佳的。$A$ 的 CSR 格式允许对任何给定行的元素进行高效、连续的访问。$B$ 的 CSC 格式允许对任何给定列的元素进行高效、连续的访问。因此，计算每个 $C_{i,c}$ 涉及两个稀疏向量的点积，这两个向量都可以从输入数据结构中轻松获得。\n\n一个关键的预备步骤是处理指定的重复索引处理方式。问题指出，$A$ 的某一行或 $B$ 的某一列中的重复索引意味着它们对应的值应该相加。因此，在进行主乘法之前，有必要对输入矩阵进行“规范化”。该过程对于 $A$ 的每一行和 $B$ 的每一列包括：\n1. 聚合任何重复索引的值。一个临时的类似映射（map-like）的结构适用于此，将索引映射到其累加值。\n2. 过滤掉任何绝对值严格小于容差 $\\tau = 10^{-12}$ 的结果条目。\n3. 按索引对剩余的非零条目进行排序。\n这种规范化确保了用于点积的每个稀疏向量（$A$ 的行或 $B$ 的列）都具有唯一且排序的索引，这是最高效点积算法的先决条件。\n\n让规范化后的矩阵用带撇的数组表示：$A'_p, A'_j, A'_x$ 和 $B'_p, B'_i, B'_x$。算法的核心是计算 $C$ 的每个元素。要求输出的 COO 列表按 $(I, J)$ 对进行字典序排序，这可以通过从 $0$ 到 $m-1$ 遍历 $C$ 的行 $i$，并对每一行从 $0$ 到 $n-1$ 遍历 $C$ 的列 $c$ 来自然满足。\n\n对于每对 $(i, c)$，我们计算 $C_{i,c}$。这是 $A$ 的第 $i$ 个（稀疏）行与 $B$ 的第 $c$ 个（稀疏）列的点积。由于我们规范化后的稀疏向量中的索引是排序的，所以可以使用类似合并连接的双指针算法高效地计算此点积。我们使用一个指针，比如 $p_A$，用于 $A$ 的第 $i$ 行的非零元素，另一个指针 $p_B$ 用于 $B$ 的第 $c$ 列。\n指针根据 $A$ 的列索引（$A'_j[p_A]$）和 $B$ 的行索引（$B'_i[p_B]$）的比较结果来推进。只有当这些索引匹配时，才会将一个乘积项加到 $C_{i,c}$ 的总和中。\n\n最终算法如下：\n1. 为输出的 COO 矩阵 $C$ 初始化空列表 $I, J, V$。\n2. 将输入矩阵 $A$ 规范化为一个新的 CSR 表示，其中每行都具有唯一且排序的列索引。\n3. 将输入矩阵 $B$ 规范化为一个新的 CSC 表示，其中每列都具有唯一且排序的行索引。\n4. 遍历每个行索引 $i$ 从 $0$ 到 $m-1$。\n5. 在此循环内，遍历每个列索引 $c$ 从 $0$ 到 $n-1$。\n6. 对于每对 $(i, c)$，使用双指针方法计算 $A$ 的规范化第 $i$ 行与 $B$ 的规范化第 $c$ 列的点积。设结果为 $v$。\n7. 如果 $|v| \\ge \\tau$，则将 $i$ 附加到 $I$，将 $c$ 附加到 $J$，将 $v$ 附加到 $V$。\n8. 遍历完所有 $(i, c)$ 对后，列表 $I, J, V$ 即表示所需排序的 COO 格式矩阵 $C$。\n此过程是稳健、正确的，并且尊重输入矩阵的稀疏性以实现高效计算。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    TOLERANCE = 1e-12\n\n    def canonicalize_csr(m, p, j, x):\n        new_p = np.zeros(m + 1, dtype=int)\n        new_j_list, new_x_list = [], []\n        for i in range(m):\n            row_map = {}\n            start, end = p[i], p[i+1]\n            for ptr in range(start, end):\n                col_idx, val = j[ptr], x[ptr]\n                row_map[col_idx] = row_map.get(col_idx, 0.0) + val\n            \n            sorted_indices = sorted(row_map.keys())\n            for col_idx in sorted_indices:\n                val = row_map[col_idx]\n                if abs(val) >= TOLERANCE:\n                    new_j_list.append(col_idx)\n                    new_x_list.append(val)\n            new_p[i+1] = len(new_j_list)\n        return new_p, np.array(new_j_list, dtype=int), np.array(new_x_list, dtype=float)\n\n    def canonicalize_csc(n, k, p, i_indices, x):\n        new_p = np.zeros(n + 1, dtype=int)\n        new_i_list, new_x_list = [], []\n        for c in range(n):\n            col_map = {}\n            start, end = p[c], p[c+1]\n            for ptr in range(start, end):\n                row_idx, val = i_indices[ptr], x[ptr]\n                col_map[row_idx] = col_map.get(row_idx, 0.0) + val\n            \n            sorted_indices = sorted(col_map.keys())\n            for row_idx in sorted_indices:\n                val = col_map[row_idx]\n                if abs(val) >= TOLERANCE:\n                    new_i_list.append(row_idx)\n                    new_x_list.append(val)\n            new_p[c+1] = len(new_i_list)\n        return new_p, np.array(new_i_list, dtype=int), np.array(new_x_list, dtype=float)\n\n    def compute_product(m, k, n, Ap, Aj, Ax, Bp, Bi, Bx):\n        Ap_c, Aj_c, Ax_c = canonicalize_csr(m, Ap, Aj, Ax)\n        Bp_c, Bi_c, Bx_c = canonicalize_csc(n, k, Bp, Bi, Bx)\n\n        C_I, C_J, C_V = [], [], []\n\n        for i in range(m):\n            for c in range(n):\n                sum_val = 0.0\n                pa = Ap_c[i]\n                pa_end = Ap_c[i+1]\n                pb = Bp_c[c]\n                pb_end = Bp_c[c+1]\n                \n                while pa  pa_end and pb  pb_end:\n                    col_a = Aj_c[pa]\n                    row_b = Bi_c[pb]\n                    \n                    if col_a  row_b:\n                        pa += 1\n                    elif col_a > row_b:\n                        pb += 1\n                    else:\n                        sum_val += Ax_c[pa] * Bx_c[pb]\n                        pa += 1\n                        pb += 1\n                \n                if abs(sum_val) >= TOLERANCE:\n                    C_I.append(i)\n                    C_J.append(c)\n                    C_V.append(sum_val)\n        return [C_I, C_J, C_V]\n\n    test_cases = [\n        {\"m\": 3, \"k\": 4, \"n\": 2, \"Ap\": np.array([0, 3, 4, 6]), \"Aj\": np.array([0, 1, 1, 2, 1, 3]), \"Ax\": np.array([1.0, -2.0, 0.5, 3.0, 4.0, -1.0]), \"Bp\": np.array([0, 4, 7]), \"Bi\": np.array([0, 1, 1, 3, 1, 2, 3]), \"Bx\": np.array([5.0, 1.0, -1.0, 2.0, -3.0, 1.0, 4.0])},\n        {\"m\": 2, \"k\": 0, \"n\": 3, \"Ap\": np.array([0, 0, 0]), \"Aj\": np.array([]), \"Ax\": np.array([]), \"Bp\": np.array([0, 0, 0, 0]), \"Bi\": np.array([]), \"Bx\": np.array([])},\n        {\"m\": 2, \"k\": 3, \"n\": 2, \"Ap\": np.array([0, 0, 2]), \"Aj\": np.array([0, 2]), \"Ax\": np.array([2.0, -2.0]), \"Bp\": np.array([0, 0, 2]), \"Bi\": np.array([0, 2]), \"Bx\": np.array([-1.0, -1.0])},\n        {\"m\": 1, \"k\": 1, \"n\": 1, \"Ap\": np.array([0, 1]), \"Aj\": np.array([0]), \"Ax\": np.array([-7.5]), \"Bp\": np.array([0, 1]), \"Bi\": np.array([0]), \"Bx\": np.array([0.2])}\n    ]\n\n    results_as_strings = []\n    for case in test_cases:\n        C_I, C_J, C_V = compute_product(case[\"m\"], case[\"k\"], case[\"n\"], case[\"Ap\"], case[\"Aj\"], case[\"Ax\"], case[\"Bp\"], case[\"Bi\"], case[\"Bx\"])\n        \n        I_str = \",\".join(map(str, C_I))\n        J_str = \",\".join(map(str, C_J))\n        V_str = \",\".join(f\"{v:.16g}\" for v in C_V)\n        \n        results_as_strings.append(f\"[[{I_str}],[{J_str}],[{V_str}]]\")\n    \n    print(f\"[{','.join(results_as_strings)}]\")\n\nsolve()\n```[[[0,0,1,2,2],[0,1,1,0,1],[5,4.5,3,-2,-16]],[[],[],[]],[[],[],[]],[[0],[0],[-1.5]]]"
        }
    ]
}