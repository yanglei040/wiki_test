{
    "hands_on_practices": [
        {
            "introduction": "第一个实践将引导你从零开始构建一个三角插值器。我们将从复指数基的离散正交性出发，推导插值多项式系数的公式，并了解如何使用快速傅里叶变换（FFT）高效地实现它。这个练习将巩固三角插值的核心机制，并能处理更通用的复值数据情况。",
            "id": "3284416",
            "problem": "您的任务是为在等距节点上采样的复值周期数据构建和分析一个三角插值多项式。三角插值基于用三角多项式表示周期函数以及复指数的正交性。您的推导应基于以下核心事实：次数至多为 $m$ 的三角多项式空间由 $\\{e^{i k x}\\}_{k=-m}^{m}$ 张成；插值节点在一个周期内等距分布；复指数在等距网格上表现出离散正交性。\n\n从上述基础出发，推导一个算法，用于构建一个次数至多为 $m$ 的唯一三角多项式，该多项式在一个周期内的 $N$ 个等距节点上对一个复值函数进行插值，其中 $N$ 为奇数且 $m = \\frac{N - 1}{2}$。您的推导必须使用 $\\{e^{i k x}\\}$ 在等距网格上的正交性，并得出一个可实现的程序来：\n- 从复数样本计算插值三角多项式的系数，以及\n- 在任意点上对插值多项式求值，以获得复平面中的一条光滑曲线。\n\n所有角度必须以弧度为单位。您必须通过基 $\\{e^{i k x}\\}$ 所蕴含的复数算术，同时对实部和虚部进行插值，从而严格地处理复值数据。\n\n在一个完整且可运行的程序中实现您的算法，该程序针对下面指定的测试套件，构建插值多项式，在均匀网格上对其求值以表示光滑曲线，然后为每个测试用例报告一个单一的标量诊断值：插值多项式与底层生成函数在求值网格上的最大绝对误差。将这些诊断值汇总成所需的最终输出格式。\n\n定义和设置：\n- 设节点为 $x_j = \\frac{2\\pi j}{N}$，其中 $j=0,1,\\dots,N-1$，位于区间 $[0,2\\pi)$ 上。\n- 设 $f_j = f(x_j)$ 为复值样本。\n- 设插值三角多项式为 $p(x)$，其次数至多为 $m = \\frac{N-1}{2}$，使得对所有 $j$ 都有 $p(x_j) = f_j$。\n\n测试套件和评估要求（角度以弧度为单位）：\n- 案例1（正常路径）：$N = 15$, $f(x) = e^{i 2 x} + 0.3\\, e^{-i 3 x} + 0.2 i\\, e^{i 5 x}$。在 $[0,2\\pi)$ 内的 $200$ 个均匀分布点上评估插值多项式，并返回最大绝对误差 $\\max_{x} |p(x) - f(x)|$。\n- 案例2（常数复函数）：$N = 9$, $f(x) = 2 + 0.5 i$。在 $[0,2\\pi)$ 内的 $64$ 个点上进行评估，并返回 $\\max_{x} |p(x) - f(x)|$。\n- 案例3（边界次数覆盖）：$N = 21$, $f(x) = 0.2\\, e^{i 10 x} + 0.1\\, e^{-i 9 x} + 0.05 i\\, e^{i x}$。在 $[0,2\\pi)$ 内的 $256$ 个点上进行评估，并返回 $\\max_{x} |p(x) - f(x)|$。\n- 案例4（最小样本集）：$N = 1$, $f(x) = 1 + 2 i$。在 $[0,2\\pi)$ 内的 $32$ 个点上进行评估，并返回 $\\max_{x} |p(x) - f(x)|$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含四个结果，格式为方括号括起来的逗号分隔列表（例如，$[r_1,r_2,r_3,r_4]$），其中每个 $r_k$ 是相应测试用例的浮点数最大绝对误差。\n\n您的解决方案必须是独立且可运行的，使用弧度单位的角度，并通过一个从复指数基的正交性推导出的、有原则的算法来计算奇数 $N$ 的插值多项式。不要依赖外部数据或用户输入。对于概念推导部分，实现语言不受限制，但最终答案必须是符合指定运行时环境和输出格式的Python代码。",
            "solution": "该问题要求推导并实现一个算法，用于对在 $N$ 个等距节点上采样的复值数据进行三角插值，其中 $N$ 为奇数。推导过程必须基于复指数基函数的离散正交性。\n\n设插值节点为 $x_j = \\frac{2\\pi j}{N}$，其中 $j=0, 1, \\dots, N-1$。给定 $N$ 个复值样本 $f_j = f(x_j)$。我们寻求一个次数至多为 $m = \\frac{N-1}{2}$ 的三角多项式 $p(x)$，它对这些样本进行插值，即对所有 $j$ 满足 $p(x_j) = f_j$。\n\n**步骤1：三角插值多项式的形式**\n\n次数至多为 $m$ 的三角多项式空间由复指数函数集 $\\{e^{ikx}\\}_{k=-m}^{m}$ 张成。因此，插值多项式 $p(x)$ 可以写成这些基函数的线性组合：\n$$\np(x) = \\sum_{k=-m}^{m} c_k e^{ikx}\n$$\n系数 $\\{c_k\\}$ 是复数。有 $2m+1$ 个系数待定。由于 $m = \\frac{N-1}{2}$，我们有 $2m+1 = 2\\left(\\frac{N-1}{2}\\right) + 1 = (N-1) + 1 = N$ 个未知系数，这与数据点的数量相匹配。\n\n**步骤2：插值条件**\n\n多项式 $p(x)$ 必须在节点 $x_j$ 处与样本值 $f_j$ 相匹配。这为 $N$ 个未知系数 $c_k$ 提供了一个包含 $N$ 个线性方程的方程组：\n$$\nf_j = p(x_j) = \\sum_{k=-m}^{m} c_k e^{ikx_j} = \\sum_{k=-m}^{m} c_k e^{ik(2\\pi j/N)}, \\quad \\text{for } j = 0, 1, \\dots, N-1\n$$\n\n**步骤3：基函数的离散正交性**\n\n为了求解系数 $c_k$，我们利用基函数 $\\{e^{ikx}\\}$ 在节点集 $\\{x_j\\}$ 上的离散正交性。我们来考虑两个基函数 $e^{ikx_j}$ 和 $e^{-ilx_j}$ 乘积在所有节点上的和，其中 $k$ 和 $l$ 是范围在 $[-m, m]$ 内的整数：\n$$\n\\sum_{j=0}^{N-1} e^{ikx_j} e^{-ilx_j} = \\sum_{j=0}^{N-1} e^{i(k-l)x_j} = \\sum_{j=0}^{N-1} e^{i(k-l)\\frac{2\\pi j}{N}} = \\sum_{j=0}^{N-1} \\left(e^{i(k-l)\\frac{2\\pi}{N}}\\right)^j\n$$\n这是一个公比为 $r = e^{i(k-l)\\frac{2\\pi}{N}}$ 的有限几何级数。\n\n情况1：$k = l$。公比为 $r = e^0 = 1$。和变为：\n$$\n\\sum_{j=0}^{N-1} 1 = N\n$$\n情况2：$k \\neq l$。由于 $k, l \\in \\{-m, \\dots, m\\}$，差值 $k-l$ 是一个满足 $-(2m) \\le k-l \\le 2m$ 的整数。当 $m = (N-1)/2$ 时，这个范围是 $-(N-1) \\le k-l \\le N-1$。因为 $k \\neq l$，$k-l$ 是一个非零且不是 $N$ 的倍数的整数。因此，公比 $r = e^{i(k-l)\\frac{2\\pi}{N}}$ 不等于 $1$。该几何级数的和为：\n$$\n\\sum_{j=0}^{N-1} r^j = \\frac{r^N - 1}{r - 1} = \\frac{\\left(e^{i(k-l)\\frac{2\\pi}{N}}\\right)^N - 1}{r - 1} = \\frac{e^{i(k-l)2\\pi} - 1}{r - 1}\n$$\n由于 $k-l$ 是整数，$e^{i(k-l)2\\pi} = \\cos(2\\pi(k-l)) + i\\sin(2\\pi(k-l)) = 1$。因此，分子是 $1-1=0$，和为 $0$。\n\n结合这两种情况，我们得到离散正交关系：\n$$\n\\sum_{j=0}^{N-1} e^{ikx_j} e^{-ilx_j} = N \\delta_{kl}\n$$\n其中 $\\delta_{kl}$ 是克罗内克δ (Kronecker delta)。\n\n**步骤4：系数公式的推导**\n\n现在我们可以利用正交关系来分离出每个系数 $c_l$。我们取插值条件方程，对于一个特定的整数 $l \\in \\{-m, \\dots, m\\}$，将方程两边同乘以 $e^{-ilx_j}$，然后对所有节点 $j=0, \\dots, N-1$ 求和：\n$$\n\\sum_{j=0}^{N-1} f_j e^{-ilx_j} = \\sum_{j=0}^{N-1} \\left( \\sum_{k=-m}^{m} c_k e^{ikx_j} \\right) e^{-ilx_j}\n$$\n交换右侧的求和顺序（对于有限和是允许的）：\n$$\n\\sum_{j=0}^{N-1} f_j e^{-ilx_j} = \\sum_{k=-m}^{m} c_k \\left( \\sum_{j=0}^{N-1} e^{ikx_j} e^{-ilx_j} \\right)\n$$\n应用正交关系 $\\sum_{j=0}^{N-1} e^{ikx_j} e^{-ilx_j} = N \\delta_{kl}$：\n$$\n\\sum_{j=0}^{N-1} f_j e^{-ilx_j} = \\sum_{k=-m}^{m} c_k (N \\delta_{kl})\n$$\n当 $k=l$ 时，右侧的和简化为唯一的非零项：\n$$\n\\sum_{j=0}^{N-1} f_j e^{-ilx_j} = N c_l\n$$\n解出 $c_l$，我们得到系数的显式公式：\n$$\nc_l = \\frac{1}{N} \\sum_{j=0}^{N-1} f_j e^{-ilx_j} = \\frac{1}{N} \\sum_{j=0}^{N-1} f_j e^{-i 2\\pi lj/N}\n$$\n该公式对所有 $l \\in \\{-m, \\dots, m\\}$ 成立。\n\n**步骤5：与离散傅里叶变换（DFT）的联系**\n\n序列 $\\{y_j\\}_{j=0}^{N-1}$ 的离散傅里叶变换的标准定义由下式给出：\n$$\n\\hat{y}_k = \\sum_{j=0}^{N-1} y_j e^{-i 2\\pi kj/N}, \\quad \\text{for } k=0, 1, \\dots, N-1\n$$\n将此与我们的 $c_l$ 公式进行比较，我们发现这些系数就是数据序列 $\\{f_j\\}$ 的DFT的缩放版本：\n$$\nc_l = \\frac{1}{N} \\hat{f}_l\n$$\n其中 $\\hat{f}_l = \\text{DFT}(\\{f_j\\})_l$。标准的DFT算法计算索引为 $k=0, \\dots, N-1$ 的 $\\hat{f}_k$。这些必须映射到我们的多项式系数索引 $l=-m, \\dots, m$。该映射基于复指数核的周期性，$e^{-i 2\\pi (l+N) j/N} = e^{-i 2\\pi lj/N} e^{-i 2\\pi j} = e^{-i 2\\pi lj/N}$。因此，索引 $k=N+l$ 处的DFT系数与索引 $l$ 处的相同。对于负索引 $l = -1, \\dots, -m$，我们可以使用相应的正索引 $k=N-1, \\dots, N-m$。用于快速傅里叶变换（FFT）的高效计算库会隐式地处理这种索引，通常会提供一个相应的频率数组，直接映射到索引 $l = 0, \\dots, m, -m, \\dots, -1$。\n\n**步骤6：最终算法**\n\n构建和评估三角插值多项式的完整过程如下：\n\n1.  **系数计算**：\n    a. 给定 $N$ 个数据样本 $f_0, f_1, \\dots, f_{N-1}$。\n    b. 计算此序列的离散傅里叶变换：$\\{\\hat{f}_k\\} = \\text{DFT}(\\{f_j\\})$。\n    c. 计算多项式系数：$c_k = \\frac{1}{N} \\hat{f}_k$。这些系数对应于基函数 $e^{ilx}$，其中整数波数 $l$ 与DFT索引 $k$ 相关联。\n\n2.  **多项式求值**：\n    a. 要在一组任意点 $\\{x_{eval}\\}$ 上评估插值多项式 $p(x)$，计算以下和：\n    $$\n    p(x_{eval}) = \\sum_{l=-m}^{m} c_l e^{il x_{eval}}\n    $$\n    b. 在实现中，这通过确定与标准DFT输出顺序对应的波数向量 $l \\in \\{0, 1, \\dots, m, -m, \\dots, -1\\}$，然后计算系数与基函数在求值点处的值之间的矩阵-向量积来实现。\n\n对于给定的测试用例，生成函数 $f(x)$ 本身就是一个次数至多为 $m$ 的三角多项式。根据三角插值多项式的唯一性，构建的多项式 $p(x)$ 必须与 $f(x)$ 完全相同。因此，理论误差 $|p(x) - f(x)|$ 为零。任何非零结果都将归因于浮点表示和算术误差。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the trigonometric interpolation problem for a suite of test cases.\n    \"\"\"\n\n    def construct_and_evaluate_interpolant(N, f_func, n_eval):\n        \"\"\"\n        Constructs and evaluates a trigonometric interpolant for a given function.\n\n        Args:\n            N (int): The number of sample points (must be odd).\n            f_func (callable): The complex-valued generating function f(x).\n            n_eval (int): The number of points for evaluation.\n\n        Returns:\n            float: The maximum absolute error |p(x) - f(x)| on the evaluation grid.\n        \"\"\"\n        if N == 0:\n            raise ValueError(\"Number of samples N must be positive.\")\n        if N % 2 == 0:\n            raise ValueError(\"Number of samples N must be odd for this problem.\")\n\n        # Step 1: Generate sample points and data\n        # Nodes: x_j = 2*pi*j / N for j=0,...,N-1\n        x_j_grid = 2 * np.pi * np.arange(N) / N\n        # Sample data: f_j = f(x_j)\n        f_j_data = f_func(x_j_grid)\n\n        # Step 2: Compute coefficients using FFT\n        # The derivation shows c_k = (1/N) * DFT(f_j), where p(x) = sum(c_k * e^(i*k*x))\n        # numpy.fft.fft computes the DFT.\n        coeffs = np.fft.fft(f_j_data) / N\n\n        # Step 3: Get the corresponding integer wavenumbers\n        # numpy.fft.fftfreq gives frequencies [0, 1/N, ..., m/N, -m/N, ..., -1/N]\n        # To get integer wavenumbers k, we multiply by N.\n        # This gives k = [0, 1, ..., m, -m, ..., -1], with m=(N-1)/2.\n        k_vals = np.fft.fftfreq(N) * N\n\n        # Step 4: Define evaluation grid\n        # Uniform grid of n_eval points in [0, 2*pi)\n        x_eval_grid = np.linspace(0, 2 * np.pi, n_eval, endpoint=False)\n\n        # Step 5: Evaluate the interpolating polynomial p(x) on the evaluation grid\n        # p(x) = sum_k c_k * exp(i*k*x)\n        # This can be computed efficiently using an outer product and a matrix multiplication.\n        # V_kj = exp(i * k_k * x_j), a Vandermonde-like matrix of basis functions\n        V = np.exp(1j * np.outer(k_vals, x_eval_grid))\n        # p_eval = coeffs . V\n        p_eval = coeffs @ V\n\n        # Step 6: Evaluate the true function f(x) on the evaluation grid\n        f_eval = f_func(x_eval_grid)\n\n        # Step 7: Calculate the maximum absolute error\n        max_error = np.max(np.abs(p_eval - f_eval))\n\n        return max_error\n\n    # Define test cases\n    test_cases = [\n        {\n            'N': 15,\n            'f_func': lambda x: np.exp(1j * 2 * x) + 0.3 * np.exp(-1j * 3 * x) + 0.2j * np.exp(1j * 5 * x),\n            'n_eval': 200,\n        },\n        {\n            'N': 9,\n            'f_func': lambda x: (2 + 0.5j) * np.ones_like(x),\n            'n_eval': 64,\n        },\n        {\n            'N': 21,\n            'f_func': lambda x: 0.2 * np.exp(1j * 10 * x) + 0.1 * np.exp(-1j * 9 * x) + 0.05j * np.exp(1j * x),\n            'n_eval': 256,\n        },\n        {\n            'N': 1,\n            'f_func': lambda x: (1 + 2j) * np.ones_like(x),\n            'n_eval': 32,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        error = construct_and_evaluate_interpolant(case['N'], case['f_func'], case['n_eval'])\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "现实世界的数据往往包含噪声。本实践探讨了一个关键问题：我们应该精确拟合数据（插值），还是近似它以捕捉潜在趋势（回归）？通过在含噪数据上比较完整三角插值与截断最小二乘模型，你将对过拟合和泛化能力有更实际的理解，这是现代数据分析和机器学习的基石。",
            "id": "3284517",
            "problem": "您的任务是设计并实现一个实验，用以在存在噪声的情况下区分三角插值和最小二乘三角回归，并量化它们在未见点上的泛化性能。所有角度都必须以弧度为单位。\n\n从以下基本依据出发：\n- 复指数在周期区间上的正交性，即集合 $\\{e^{\\mathrm{i} k t}\\}_{k\\in\\mathbb{Z}}$ 在一个周期上是正交的。\n- 三角插值的定义，即一个周期性的三角多项式，它精确地穿过在一个完整周期上以等距节点采样的给定数据。\n- 最小二乘回归的定义，即指定模型类别相对于观测数据的残差平方和的最小化器。\n\n您必须：\n1) 推导在一个周期内以 $N$ 个等距节点采样的周期函数的精确三角插值的计算公式。该插值函数必须在训练节点上与带噪样本完全匹配，并且可以表示为一个有限三角级数。您可以使用离散傅里叶变换作为计算工具，但必须从正交性和插值条件出发证明其使用的合理性。\n2) 推导对同一训练数据以最小二乘法拟合一个 $M$ 阶截断实三角模型的计算公式。该模型形式为\n$$\ns_M(t) = a_0 + \\sum_{k=1}^{M} \\big( a_k \\cos(kt) + b_k \\sin(kt) \\big),\n$$\n其系数必须通过最小化训练节点上的残差平方和来获得。\n3) 实现这两种方法，并通过在一个密集的测试网格上计算每种方法相对于无噪声的真实周期函数的均方根误差 (RMSE) 来比较它们的样本外性能。\n\n数据生成协议（角度以弧度为单位）：\n- 训练节点：对于每种情况，使用 $t_j = 2\\pi j / N$，$j=0,1,\\dots,N-1$。\n- 真实周期目标函数指定为\n$$\nf(t) = a_0 + \\sum_{k=1}^{K} \\big( a_k \\cos(kt) + b_k \\sin(kt) \\big).\n$$\n- 观测值是带噪声的：$y_j = f(t_j) + \\varepsilon_j$，其中 $\\varepsilon_j$ 是均值为 $0$、标准差为 $\\sigma$ 的独立同分布正态随机变量，使用固定的随机种子生成以保证可复现性。\n- 测试网格必须是一个周期上的 $T$ 个等距点集：$t^{\\ast}_m = 2\\pi m / T$，$m=0,1,\\dots,T-1$。使用 $T = 4096$。\n\n性能度量：\n- 对每种方法，计算样本外均方根误差\n$$\n\\mathrm{RMSE} = \\sqrt{\\frac{1}{T} \\sum_{m=0}^{T-1} \\big( \\hat{f}(t^{\\ast}_m) - f(t^{\\ast}_m) \\big)^2 },\n$$\n其中 $\\hat{f}$ 是三角插值函数或截断的最小二乘拟合函数。较低的 $\\mathrm{RMSE}$ 表示对真实底层函数的泛化能力更好。\n\n您的程序必须实现上述内容并评估以下测试用例集。在每种情况下，生成噪声前都应使用相同的种子 $314159$ 初始化伪随机数生成器，以确保结果是可复现的。对于每种情况，报告一个布尔值，指示最小二乘截断模型是否比精确插值模型泛化得更好，即 $\\mathrm{RMSE}_{\\mathrm{LS}} < \\mathrm{RMSE}_{\\mathrm{Interp}}$ 是否成立。\n\n带有系数和参数的测试用例集：\n- 情况 1：$N = 64$，$K = 3$，$\\sigma = 0.2$，$M = 3$，$a_0 = 0.1$，其中对于 $k = 1,2,3$，$a_k$ 等于 $\\{1.0,\\,0.5,\\,0.2\\}$，对于 $k = 1,2,3$，$b_k$ 等于 $\\{0.5,\\,-0.3,\\,0.1\\}$。\n- 情况 2：$N = 64$，$K = 6$，$\\sigma = 0.0$，$M = 3$，$a_0 = 0.0$，其中对于 $k = 1,2,3,4,5,6$，$a_k$ 等于 $\\{0.7,\\,-0.4,\\,0.3,\\,0.2,\\,-0.1,\\,0.05\\}$，对于 $k = 1,2,3,4,5,6$，$b_k$ 等于 $\\{-0.2,\\,0.3,\\,-0.1,\\,0.25,\\,0.2,\\,-0.05\\}$。\n- 情况 3：$N = 64$，$K = 5$，$\\sigma = 1.0$，$M = 3$，$a_0 = 0.2$，其中对于 $k = 1,2,3,4,5$，$a_k$ 等于 $\\{0.9,\\,-0.6,\\,0.4,\\,-0.3,\\,0.15\\}$，对于 $k = 1,2,3,4,5$，$b_k$ 等于 $\\{0.5,\\,0.4,\\,-0.2,\\,0.3,\\,-0.1\\}$。\n- 情况 4：$N = 16$，$K = 3$，$\\sigma = 0.5$，$M = 3$，$a_0 = -0.1$，其中对于 $k = 1,2,3$，$a_k$ 等于 $\\{0.9,\\,0.4,\\,-0.2\\}$，对于 $k = 1,2,3$，$b_k$ 等于 $\\{-0.4,\\,0.35,\\,0.15\\}$。\n\n实现要求：\n- 使用其匹配所有训练样本的定义属性以及复指数在一个周期上的正交性来构建精确的三角插值。您可以使用适用于等距样本的离散傅里叶变换来计算其系数，并在密集的测试网格上评估该插值函数。\n- 通过使用训练数据求解系数 $\\{a_0,a_1,\\dots,a_M,b_1,\\dots,b_M\\}$ 的线性最小二乘问题，来构建 $M$ 阶的最小二乘截断实三角拟合，然后在密集的测试网格上评估拟合后的模型。\n- 对于每种情况，在测试网格上计算 $\\mathrm{RMSE}_{\\mathrm{Interp}}$ 和 $\\mathrm{RMSE}_{\\mathrm{LS}}$ 相对于真实函数 $f(t)$ 的值。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，并按上述情况排序。每个条目必须是一个布尔值，当且仅当该情况下 $\\mathrm{RMSE}_{\\mathrm{LS}} < \\mathrm{RMSE}_{\\mathrm{Interp}}$ 时等于 $\\mathrm{True}$，否则等于 $\\mathrm{False}$。例如：$[True,False,True,True]$。",
            "solution": "### 第 1 步：提取已知信息\n- **任务**：设计并实现一个实验，以比较三角插值和最小二乘三角回归。所有角度均以弧度为单位。\n- **基本依据**：\n    - $\\{e^{\\mathrm{i} k t}\\}_{k\\in\\mathbb{Z}}$ 在一个周期区间上的正交性。\n    - 三角插值：精确穿过在完整周期上以等距节点采样的周期性三角多项式。\n    - 最小二乘回归：指定模型类别的残差平方和的最小化器。\n\n- **推导要求**：\n    1.  针对 $N$ 个等距节点的精确三角插值的计算公式，使用并证明 DFT 的合理性。\n    2.  通过最小二乘法拟合一个 $M$ 阶截断实三角模型的计算公式：\n        $$\n        s_M(t) = a_0 + \\sum_{k=1}^{M} \\big( a_k \\cos(kt) + b_k \\sin(kt) \\big)\n        $$\n\n- **实现与比较**：\n    - 实现这两种方法。\n    - 使用均方根误差 (RMSE) 在一个密集的测试网格上，与无噪声的真实函数进行比较，评估样本外性能。\n\n- **数据生成协议**：\n    - 训练节点：$t_j = 2\\pi j / N$，$j=0,1,\\dots,N-1$。\n    - 真实目标函数：$f(t) = a_0 + \\sum_{k=1}^{K} \\big( a_k \\cos(kt) + b_k \\sin(kt) \\big)$。\n    - 带噪观测值：$y_j = f(t_j) + \\varepsilon_j$，其中 $\\varepsilon_j \\sim \\mathcal{N}(0, \\sigma^2)$，独立同分布。\n    - 噪声生成的随机种子：$314159$。\n    - 测试网格：$t^{\\ast}_m = 2\\pi m / T$，$m=0,1,\\dots,T-1$，其中 $T = 4096$。\n\n- **性能度量**：\n    - RMSE：$\\sqrt{\\frac{1}{T} \\sum_{m=0}^{T-1} \\big( \\hat{f}(t^{\\ast}_m) - f(t^{\\ast}_m) \\big)^2 }$，其中 $\\hat{f}$ 是插值函数或最小二乘拟合函数。\n\n- **最终输出**：一个布尔值列表，其中若 $\\mathrm{RMSE}_{\\mathrm{LS}} < \\mathrm{RMSE}_{\\mathrm{Interp}}$，则对应条目为 $\\mathrm{True}$。\n\n- **测试用例集**：\n    - 情况 1：$N = 64$，$K = 3$，$\\sigma = 0.2$，$M = 3$，$a_0 = 0.1$，$a_k = \\{1.0,\\,0.5,\\,0.2\\}$，$b_k = \\{0.5,\\,-0.3,\\,0.1\\}$。\n    - 情况 2：$N = 64$，$K = 6$，$\\sigma = 0.0$，$M = 3$，$a_0 = 0.0$，$a_k = \\{0.7,\\,-0.4,\\,0.3,\\,0.2,\\,-0.1,\\,0.05\\}$，$b_k = \\{-0.2,\\,0.3,\\,-0.1,\\,0.25,\\,0.2,\\,-0.05\\}$。\n    - 情况 3：$N = 64$，$K = 5$，$\\sigma = 1.0$，$M = 3$，$a_0 = 0.2$，$a_k = \\{0.9,\\,-0.6,\\,0.4,\\,-0.3,\\,0.15\\}$，$b_k = \\{0.5,\\,0.4,\\,-0.2,\\,0.3,\\,-0.1\\}$。\n    - 情况 4：$N = 16$，$K = 3$，$\\sigma = 0.5$，$M = 3$，$a_0 = -0.1$，$a_k = \\{0.9,\\,0.4,\\,-0.2\\}$，$b_k = \\{-0.4,\\,0.35,\\,0.15\\}$。\n\n### 第 2 步：使用提取的已知信息进行验证\n该问题具有科学依据，是数值分析和应用傅里叶分析中的一个标准练习。它涉及三角插值、最小二乘逼近以及统计建模中偏差-方差权衡等已被广泛认可的概念。该问题是适定的：它为每个测试用例提供了所有必要的数据、参数和定义。目标陈述清晰，语言精确无歧义。任务可以形式化为一个具体的计算实验。整个设置是自洽且一致的。不存在科学或逻辑上的缺陷。\n\n### 第 3 步：结论与行动\n问题有效。将提供解决方案。\n\n### 基于原理的解决方案\n\n该问题要求对两种从带噪样本中逼近周期函数的方法进行对比分析：精确三角插值和截断最小二乘三角回归。这种比较突显了函数逼近中偏差与方差之间的基本权衡。插值法完美地拟合了训练数据（包括噪声），这通常会导致模型方差过高，泛化能力差（即过拟合）。相比之下，使用 $M$ 阶截断模型的最小二乘回归则充当一个低通滤波器，通过不拟合高频噪声来降低方差，但如果真实信号包含大于 $M$ 的频率，则可能会引入偏差。\n\n**1. 精确三角插值的公式化**\n\n给定一组 $N$ 个数据点 $(t_j, y_j)$，其中 $t_j = 2\\pi j/N$，$j=0, 1, \\dots, N-1$，目标是找到一个三角多项式 $p(t)$，满足插值条件 $p(t_j) = y_j$ 对所有 $j$ 成立。对于偶数个点 $N$（如测试用例中所指定），唯一一个阶数至多为 $N/2$ 的三角多项式可以写成实数形式：\n$$\np(t) = A_0 + \\sum_{k=1}^{N/2-1} \\left( A_k \\cos(kt) + B_k \\sin(kt) \\right) + A_{N/2} \\cos\\left(\\frac{N}{2}t\\right)\n$$\n该多项式有 $1 + 2(N/2 - 1) + 1 = N$ 个自由度，对应于系数 $\\{A_k\\}_{k=0}^{N/2}$ 和 $\\{B_k\\}_{k=1}^{N/2-1}$。\n\n这些系数是通过利用三角基函数在节点集 $\\{t_j\\}$ 上的离散正交性质来确定的。这些性质是复指数在离散点集上正交性的直接推论。具体来说，对于整数 $k, l \\in [0, N/2]$：\n$$\n\\sum_{j=0}^{N-1} \\cos(kt_j)\\cos(lt_j) = \\begin{cases} N & k=l=0 \\text{ or } N/2 \\\\ N/2 & k=l \\in \\{1,\\dots,N/2-1\\} \\\\ 0 & k \\neq l \\end{cases}\n$$\n$$\n\\sum_{j=0}^{N-1} \\sin(kt_j)\\sin(lt_j) = \\begin{cases} N/2 & k=l \\in \\{1,\\dots,N/2-1\\} \\\\ 0 & k \\neq l \\end{cases}\n$$\n$$\n\\sum_{j=0}^{N-1} \\cos(kt_j)\\sin(lt_j) = 0 \\quad \\forall k, l\n$$\n通过将 $t=t_j$ 代入 $p(t)$ 的表达式，令其等于 $y_j$，再乘以一个基函数（例如 $\\cos(kt_j)$），并对所有 $j$ 求和，由于这些正交关系，我们可以分离出每个系数。这个过程得出了系数的以下公式：\n$$\nA_0 = \\frac{1}{N} \\sum_{j=0}^{N-1} y_j\n$$\n$$\nA_k = \\frac{2}{N} \\sum_{j=0}^{N-1} y_j \\cos(kt_j), \\quad k \\in \\{1, \\dots, N/2-1\\}\n$$\n$$\nB_k = \\frac{2}{N} \\sum_{j=0}^{N-1} y_j \\sin(kt_j), \\quad k \\in \\{1, \\dots, N/2-1\\}\n$$\n$$\nA_{N/2} = \\frac{1}{N} \\sum_{j=0}^{N-1} y_j \\cos\\left(\\frac{N}{2}t_j\\right) = \\frac{1}{N} \\sum_{j=0}^{N-1} y_j (-1)^j\n$$\n这些和式定义了离散傅里叶变换 (DFT)。可以使用快速傅里叶变换 (FFT) 算法高效地计算这些系数。设 $\\{C_k\\}_{k=0}^{N/2}$ 是序列 $\\{y_j\\}_{j=0}^{N-1}$ 的实值 FFT 的结果。这些系数与 FFT 输出的关系如下：\n$A_0 = C_0 / N$, $A_{N/2} = C_{N/2} / N$，且对于 $k=1, \\dots, N/2-1$：\n$$\nA_k = \\frac{2}{N} \\mathrm{Re}(C_k)\n$$\n$$\nB_k = -\\frac{2}{N} \\mathrm{Im}(C_k)\n$$\n\n**2. 最小二乘三角回归的公式化**\n\n第二种方法涉及将一个指定阶数 $M < N/2$ 的三角多项式拟合到数据。模型为：\n$$\ns_M(t) = a_0 + \\sum_{k=1}^{M} \\left( a_k \\cos(kt) + b_k \\sin(kt) \\right)\n$$\n目标是找到系数 $\\{a_k\\}_{k=0}^M$ 和 $\\{b_k\\}_{k=1}^M$ 以最小化残差平方和：\n$$\nS = \\sum_{j=0}^{N-1} \\left( y_j - s_M(t_j) \\right)^2\n$$\n这是一个线性最小二乘问题。设未知系数向量为 $\\boldsymbol{\\theta} = [a_0, a_1, \\dots, a_M, b_1, \\dots, b_M]^T$。该问题可以写成矩阵形式，即最小化 $\\|\\mathbf{y} - \\mathbf{X}\\boldsymbol{\\theta}\\|_2^2$，其中 $\\mathbf{y} = [y_0, \\dots, y_{N-1}]^T$ 是观测向量，$\\mathbf{X}$ 是一个 $N \\times (1+2M)$ 的设计矩阵，其列是在训练节点 $t_j$ 处求值的基函数：\n$$\n\\mathbf{X} = \\begin{bmatrix}\n1 & \\cos(1 t_0) & \\dots & \\cos(M t_0) & \\sin(1 t_0) & \\dots & \\sin(M t_0) \\\\\n1 & \\cos(1 t_1) & \\dots & \\cos(M t_1) & \\sin(1 t_1) & \\dots & \\sin(M t_1) \\\\\n\\vdots & \\vdots & \\ddots & \\vdots & \\vdots & \\ddots & \\vdots \\\\\n1 & \\cos(1 t_{N-1}) & \\dots & \\cos(M t_{N-1}) & \\sin(1 t_{N-1}) & \\dots & \\sin(M t_{N-1})\n\\end{bmatrix}\n$$\n解 $\\boldsymbol{\\theta}$ 通过求解正规方程 $\\mathbf{X}^T\\mathbf{X}\\boldsymbol{\\theta} = \\mathbf{X}^T\\mathbf{y}$ 得到。由于 $M < N/2$，离散正交关系对 $\\mathbf{X}$ 的列成立，使得矩阵 $\\mathbf{X}^T\\mathbf{X}$ 是对角矩阵：\n$$\n\\mathbf{X}^T\\mathbf{X} = \\mathrm{diag}\\left(N, \\frac{N}{2}, \\dots, \\frac{N}{2}, \\frac{N}{2}, \\dots, \\frac{N}{2}\\right)\n$$\n求解 $\\boldsymbol{\\theta}$ 得到的系数表达式与完全插值的前 $M$ 个傅里叶系数相同：\n$$\na_0 = \\frac{1}{N} \\sum_{j=0}^{N-1} y_j\n$$\n$$\na_k = \\frac{2}{N} \\sum_{j=0}^{N-1} y_j \\cos(kt_j), \\quad k \\in \\{1, \\dots, M\\}\n$$\n$$\nb_k = \\frac{2}{N} \\sum_{j=0}^{N-1} y_j \\sin(kt_j), \\quad k \\in \\{1, \\dots, M\\}\n$$\n因此，使用此模型的最小二乘逼近等价于截断数据的傅里叶级数。虽然存在这种解析解，但一个鲁棒的数值实现可以直接使用标准的最小二乘求解器来解决这个线性系统，这也是这里采用的方法。\n\n**3. 实验设计与评估**\n\n对于每个测试用例，实验将按以下步骤进行：\n1.  在 $N$ 个训练节点上生成真实函数值 $f(t_j)$ 和带噪观测值 $y_j = f(t_j) + \\varepsilon_j$。\n2.  使用 $\\{y_j\\}$ 的 FFT 计算精确三角插值 $p(t)$ 的系数。\n3.  求解线性最小二乘问题，找到截断模型 $s_M(t)$ 的系数。\n4.  在 $T$ 个测试点的密集网格 $\\{t^*_m\\}$ 上评估 $p(t)$ 和 $s_M(t)$。\n5.  在同一测试网格上计算真实函数值 $f(t^*_m)$。\n6.  计算两种方法相对于真实函数值 $f(t^*_m)$ 的 RMSE。\n7.  比较 RMSE 值，以确定哪种方法提供更好的泛化性能，即在未见数据上的误差更低。布尔结果 $\\mathrm{RMSE}_{\\mathrm{LS}} < \\mathrm{RMSE}_{\\mathrm{Interp}}$ 量化了这种比较。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of comparing trigonometric interpolation and least-squares\n    regression by running a suite of test cases.\n    \"\"\"\n    \n    test_cases = [\n        # Case 1\n        {\n            'N': 64, 'K': 3, 'sigma': 0.2, 'M': 3, 'a0': 0.1,\n            'a_k': [1.0, 0.5, 0.2], 'b_k': [0.5, -0.3, 0.1]\n        },\n        # Case 2\n        {\n            'N': 64, 'K': 6, 'sigma': 0.0, 'M': 3, 'a0': 0.0,\n            'a_k': [0.7, -0.4, 0.3, 0.2, -0.1, 0.05],\n            'b_k': [-0.2, 0.3, -0.1, 0.25, 0.2, -0.05]\n        },\n        # Case 3\n        {\n            'N': 64, 'K': 5, 'sigma': 1.0, 'M': 3, 'a0': 0.2,\n            'a_k': [0.9, -0.6, 0.4, -0.3, 0.15],\n            'b_k': [0.5, 0.4, -0.2, 0.3, -0.1]\n        },\n        # Case 4\n        {\n            'N': 16, 'K': 3, 'sigma': 0.5, 'M': 3, 'a0': -0.1,\n            'a_k': [0.9, 0.4, -0.2], 'b_k': [-0.4, 0.35, 0.15]\n        }\n    ]\n\n    T = 4096\n    seed = 314159\n    results = []\n\n    for case in test_cases:\n        N = case['N']\n        K = case['K']\n        sigma = case['sigma']\n        M = case['M']\n        \n        # --- Data Generation ---\n        # Initialize RNG with fixed seed for reproducibility\n        rng = np.random.default_rng(seed)\n\n        # Training nodes\n        t_train = 2 * np.pi * np.arange(N) / N\n\n        # True function definition\n        def f(t, params):\n            val = np.full_like(t, params['a0'])\n            for k in range(1, params['K'] + 1):\n                val += params['a_k'][k-1] * np.cos(k * t) + params['b_k'][k-1] * np.sin(k * t)\n            return val\n\n        # True values and noisy observations at training nodes\n        f_train = f(t_train, case)\n        noise = rng.normal(0, sigma, N)\n        y_train = f_train + noise\n\n        # Test grid and true values on the test grid\n        t_test = 2 * np.pi * np.arange(T) / T\n        f_test = f(t_test, case)\n\n        # --- Method 1: Trigonometric Interpolation ---\n        # Compute coefficients using Real FFT\n        C = np.fft.rfft(y_train)\n        A_interp = np.zeros(N // 2 + 1)\n        B_interp = np.zeros(N // 2 + 1)\n        \n        A_interp[0] = C[0] / N\n        if N > 1:\n            A_interp[1:N//2] = 2 * np.real(C[1:N//2]) / N\n            B_interp[1:N//2] = -2 * np.imag(C[1:N//2]) / N\n            if N % 2 == 0:\n              A_interp[N//2] = C[N//2] / N\n\n        # Evaluate interpolant on the test grid\n        y_interp_pred = np.full_like(t_test, A_interp[0])\n        if N > 1:\n            for k in range(1, N // 2):\n                y_interp_pred += A_interp[k] * np.cos(k * t_test) + B_interp[k] * np.sin(k * t_test)\n            if N % 2 == 0:\n                y_interp_pred += A_interp[N//2] * np.cos((N // 2) * t_test)\n\n        # --- Method 2: Least-Squares Trigonometric Regression ---\n        # Construct the design matrix X\n        num_coeffs = 1 + 2 * M\n        X = np.zeros((N, num_coeffs))\n        X[:, 0] = 1  # Column for a0\n        for k in range(1, M + 1):\n            X[:, k] = np.cos(k * t_train)      # Columns for a_k\n            X[:, M + k] = np.sin(k * t_train)  # Columns for b_k\n            \n        # Solve the linear least-squares problem\n        coeffs_ls, _, _, _ = np.linalg.lstsq(X, y_train, rcond=None)\n        a_ls = coeffs_ls[0:M+1]\n        b_ls = coeffs_ls[M+1:]\n        \n        # Evaluate the least-squares model on the test grid\n        y_ls_pred = np.full_like(t_test, a_ls[0])\n        for k in range(1, M + 1):\n            y_ls_pred += a_ls[k] * np.cos(k * t_test) + b_ls[k-1] * np.sin(k * t_test)\n\n        # --- Performance Evaluation ---\n        # Calculate RMSE for both methods\n        rmse_interp = np.sqrt(np.mean((y_interp_pred - f_test)**2))\n        rmse_ls = np.sqrt(np.mean((y_ls_pred - f_test)**2))\n\n        # Append boolean result\n        results.append(rmse_ls < rmse_interp)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "三角插值不仅仅是一种曲线拟合工具，它更是一种强大的信号重建技术。在最后一个实践中，你将实现一个“超分辨率”算法，从少数低分辨率样本中生成高分辨率的周期信号。这个练习展示了在频域中工作的威力，并为三角插值在信号与图像处理领域提供了一个直观的应用。",
            "id": "3284404",
            "problem": "您的任务是设计并实现一个基于原理的周期信号“超分辨率”算法，该算法通过三角插值实现，并从数值方法和科学计算的第一性原理推导得出。考虑在定义域 $[0,2\\pi]$ 上周期为 $2\\pi$ 的实值连续函数（角度单位为弧度）。您的算法必须通过构建一个与给定样本一致并在整个定义域上自然延伸的三角插值多项式，从低分辨率、等距间隔的样本中生成底层周期信号的高分辨率近似。推导和算法必须从傅里叶级数定义和周期函数离散采样的基本基础出发。您必须确保数值上的稳健性，除了这些基础定义外，不得假定使用任何快捷公式。\n\n定义和要求：\n- 设 $f:[0,2\\pi]\\to\\mathbb{R}$ 是一个周期为 $2\\pi$ 的函数。傅里叶级数理论指出，$f(x)$ 可以用复指数 $e^{\\mathrm{i}kx}$（其中 $k\\in\\mathbb{Z}$）和傅里叶系数 $\\hat{f}_k$ 来表示，这些系数刻画了每个模式的贡献。\n- 给定在节点 $x_j = 2\\pi j/N$（其中 $j\\in\\{0,1,\\dots,N-1\\}$）上的 $N$ 个等距样本 $f(x_j)$，三角插值多项式是一个有限三角多项式，其在这些节点上的值与采样数据匹配。利用傅里叶级数的定义和均匀网格上离散采样的结构，该插值多项式的系数由样本值的离散傅里叶变换得到，系数的缩放与样本值和系数之间的逆关系一致。当在 $[0,2\\pi]$ 中的任意点 $x$ 上求值时，该三角插值多项式提供了一种“超分辨率”重构，因为它能生成一个与粗糙样本一致的、貌似合理的高分辨率周期信号。\n- 您的数值程序必须使用傅里叶分析所蕴含的基本关系，从粗糙样本中计算离散频率系数，然后在一个更精细的、包含 $M$ 个点 $y_m = 2\\pi m/M$（其中 $m\\in\\{0,1,\\dots,M-1\\}$）的网格上对相应的三角插值多项式求值。\n\n角度单位规定：\n- 所有角度都应以弧度为单位进行解释。\n\n测试套件：\n实现您的算法，并在以下四个测试用例上进行评估。对每个用例，请使用指定的函数 $f(x)$、低分辨率样本数 $N$ 和期望的高分辨率求值点数 $M$。\n\n1. 正常情况（带限）：\n   - $f(x) = \\sin(3x) + 0.5\\cos(5x)$\n   - $N = 32$\n   - $M = 1024$\n\n2. 边界情况，包含最小采样和奈奎斯特分量：\n   - $f(x) = \\cos(x)$\n   - $N = 2$\n   - $M = 128$\n\n3. 存在混叠（频率超出粗糙网格的奈奎斯特极限）：\n   - $f(x) = \\sin(20x) + 0.3\\cos(2x)$\n   - $N = 16$\n   - $M = 1024$\n\n4. 非光滑周期信号（在 $[0,2\\pi)$ 上的分段线性锯齿波）：\n   - $f(x) = \\left(\\frac{(x \\bmod 2\\pi)}{\\pi}\\right) - 1$\n   - $N = 64$\n   - $M = 2048$\n\n对于每个测试用例，计算以下两个量化指标：\n- 粗糙网格上的一致性误差：在粗糙节点上求值的三角插值多项式与给定粗糙样本之间的最大绝对差（$\\max_j |p(x_j) - f(x_j)|$）。该值必须是浮点数。\n- 高分辨率误差：在精细网格上求值的三角插值多项式与同一精细网格上的真实函数值之间的最大绝对差（$\\max_m |p(y_m) - f(y_m)|$）。该值必须是浮点数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表应包含八个浮点数，按四个测试用例的以下顺序排列：$[consistency_1,hires_1,consistency_2,hires_2,consistency_3,hires_3,consistency_4,hires_4]$。\n- 输出行中不允许出现任何额外的文本或字符。\n\n所有计算都必须以弧度为单位，并使用指定的周期 $2\\pi$。请基于傅里叶级数和用于三角插值的离散采样的基础定义，确保数值的稳定性和正确性。程序必须是完整且可运行的，无需外部输入或资源。",
            "solution": "该问题要求从第一性原理出发，设计并实现一个用于信号超分辨率的三角插值算法。该算法将从一组低分辨率、等距间隔的样本中重构一个高分辨率的周期信号。\n\n### 1. 问题验证\n\n**步骤1：提取已知条件**\n- **函数：**一个在定义域 $[0, 2\\pi]$ 上周期为 $2\\pi$ 的实值连续函数 $f(x)$。\n- **低分辨率采样：**在节点 $x_j = 2\\pi j/N$（其中 $j \\in \\{0, 1, \\dots, N-1\\}$）上的 $N$ 个等距样本 $f(x_j)$。\n- **高分辨率求值：**插值多项式将在一个更精细的、包含 $M$ 个点 $y_m = 2\\pi m/M$（其中 $m \\in \\{0, 1, \\dots, M-1\\}$）的网格上进行求值。\n- **核心原理：**插值多项式的系数由样本值的离散傅里叶变换 (DFT) 推导得出。\n- **测试用例：**\n    1. $f(x) = \\sin(3x) + 0.5\\cos(5x)$, $N = 32$, $M = 1024$。\n    2. $f(x) = \\cos(x)$, $N = 2$, $M = 128$。\n    3. $f(x) = \\sin(20x) + 0.3\\cos(2x)$, $N = 16$, $M = 1024$。\n    4. $f(x) = (\\frac{(x \\bmod 2\\pi)}{\\pi}) - 1$, $N = 64$, $M = 2048$。\n- **指标：**\n    - 一致性误差：$\\max_j |p(x_j) - f(x_j)|$\n    - 高分辨率误差：$\\max_m |p(y_m) - f(y_m)|$\n- **角度单位：**所有角度均为弧度。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题具有科学依据，是适定且客观的。这是数值分析和信号处理中的一个标准问题，基于成熟的傅里叶分析和离散傅里叶变换理论。已知条件是完整的、一致的，并且可以形式化为一个可解的数值问题。测试用例经过精心选择，旨在探究三角插值的不同方面：一个带限情况，一个奈奎斯特边界情况，一个混叠情况，以及一个非光滑情况。问题没有科学缺陷、歧义或矛盾。\n\n**步骤3：结论与行动**\n问题有效。将开发一个完整的解决方案。\n\n### 2. 从第一性原理推导\n\n我们的目标是找到一个三角多项式 $p(x)$，它能插值给定的数据点 $(x_j, y_j)$，其中 $y_j = f(x_j)$。这意味着对于 $j = 0, \\dots, N-1$，有 $p(x_j) = y_j$。\n\n一个通用的周期为 $2\\pi$ 的函数 $f(x)$ 可以用其傅里叶级数表示：\n$$\nf(x) = \\sum_{k=-\\infty}^{\\infty} \\hat{f}_k e^{\\mathrm{i}kx}\n$$\n其中傅里叶系数 $\\hat{f}_k$ 由下式给出：\n$$\n\\hat{f}_k = \\frac{1}{2\\pi} \\int_0^{2\\pi} f(t) e^{-\\mathrm{i}kt} dt\n$$\n由于我们只有函数 $f(x)$ 在离散点 $x_j$ 上的样本，我们无法直接计算这个积分。但是，我们可以使用数值求积法则，特别是通过在均匀网格点 $x_j$ 上求黎曼和，来近似它：\n$$\n\\hat{f}_k \\approx \\frac{1}{2\\pi} \\sum_{j=0}^{N-1} f(x_j) e^{-\\mathrm{i}kx_j} \\Delta x\n$$\n当 $x_j = 2\\pi j/N$ 且 $\\Delta x = 2\\pi/N$ 时，上式变为：\n$$\n\\hat{f}_k \\approx \\frac{1}{2\\pi} \\sum_{j=0}^{N-1} y_j e^{-\\mathrm{i}k(2\\pi j/N)} \\left(\\frac{2\\pi}{N}\\right) = \\frac{1}{N} \\sum_{j=0}^{N-1} y_j e^{-2\\pi\\mathrm{i}kj/N}\n$$\n右侧的表达式是经过缩放的离散傅里叶变换 (DFT) 的定义。我们定义离散傅里叶系数 $c_k$ (对于 $k=0, \\dots, N-1$) 如下：\n$$\nc_k = \\frac{1}{N} \\sum_{j=0}^{N-1} y_j e^{-2\\pi\\mathrm{i}kj/N}\n$$\n三角插值多项式 $p(x)$ 是一个有限三角多项式，它是利用一组有限的、可由 $N$ 个样本唯一确定的频率模式构建的。对于 $N$ 个样本，我们可以分辨出 $N$ 个频率分量。对于实值数据 $y_j$，其系数表现出共轭对称性：$c_{N-k} = \\overline{c_k}$。\n\n当 $N$ 为偶数时，可以分辨的唯一整数频率集合为 $k \\in \\{0, \\pm 1, \\dots, \\pm(N/2-1), N/2\\}$。在采样网格上，模式 $e^{\\mathrm{i}(N/2)x_j}$ 和 $e^{-\\mathrm{i}(N/2)x_j}$ 是相同的，因为 $e^{\\pm\\mathrm{i}(N/2)x_j} = e^{\\pm\\mathrm{i}\\pi j} = (-1)^j$。因此，它们无法被区分，我们将它们合并成一个单一的余弦项。\n\n对于偶数个点 $N$，三角插值多项式 $p(x)$ 由下式给出：\n$$\np(x) = \\sideset{}{'}\\sum_{k=-N/2}^{N/2} \\hat{c}_k e^{\\mathrm{i}kx}\n$$\n其中求和符号上的撇号表示第一项（$k=-N/2$）和最后一项（$k=N/2$）的权重为 1/2。系数 $\\hat{c}_k$ 是通过对 DFT 系数 $c_k$ 重新索引得到的：\n- 对于 $k = 0, 1, \\dots, N/2$，$\\hat{c}_k = c_k$。\n- 对于 $k = -1, \\dots, -N/2+1$，$\\hat{c}_k = c_{k+N}$。\n\n由于共轭对称性（$c_{N-k} = \\overline{c_k}$），我们有 $\\hat{c}_{-k} = \\overline{\\hat{c}_k}$。这确保了 $p(x)$ 是实值的。对于实数数据，奈奎斯特系数 $\\hat{c}_{N/2} = c_{N/2}$ 是实数。该求和可以展开为：\n$$\np(x) = \\hat{c}_0 + \\sum_{k=1}^{N/2-1} (\\hat{c}_k e^{\\mathrm{i}kx} + \\hat{c}_{-k} e^{-\\mathrm{i}kx}) + \\frac{1}{2}(\\hat{c}_{N/2} e^{\\mathrm{i}(N/2)x} + \\hat{c}_{-N/2} e^{-\\mathrm{i}(N/2)x})\n$$\n使用 $\\hat{c}_{-k} = \\overline{\\hat{c}_k}$ 和 $\\hat{c}_{-N/2} = \\hat{c}_{N/2}$（因为 $c_{N/2}$ 是实数），上式可简化为：\n$$\np(x) = \\hat{c}_0 + \\sum_{k=1}^{N/2-1} 2 \\text{Re}(\\hat{c}_k e^{\\mathrm{i}kx}) + \\hat{c}_{N/2} \\cos(Nx/2)\n$$\n这种形式保证了对于所有 $j=0, \\dots, N-1$，都有 $p(x_j) = y_j$。\n\n### 3. 通过傅里叶空间中的零填充实现超分辨率\n\n为了在一个由 $M$ 个点 $y_m=2\\pi m/M$ 组成的精细网格上计算 $p(x)$，我们可以直接计算求和。然而，一种更高效的方法是使用快速傅里叶逆变换 (IFFT)。这可以通过创建一个更大的、包含 $M$ 个傅里叶系数的向量来实现，其中原始系数被放置在它们对应的频率位置上，而额外的高频系数被设置为零。这个过程被称为零填充。\n\n设 `c_low` 是通过 `fft(y)` 计算得到的包含 $N$ 个未缩放的 DFT 系数的数组。新的 $M$ 点系数数组 `c_high` 按如下方式构建（当 $N, M$ 均为偶数时）：\n1.  将非负频率直至原始奈奎斯特极限的系数复制过来：\n    `c_high[0 : N//2] = c_low[0 : N//2]`\n2.  将负频率的系数复制到新数组中的相应位置：\n    `c_high[M - N//2 + 1 : M] = c_low[N//2 + 1 : N]`\n3.  在 $M$ 点的上下文中，原始的奈奎斯特频率 $k=N/2$ 不再是奈奎斯特频率。它的能量必须在 $k=N/2$ 和 $k=-N/2$ 的模式之间分配。\n    `c_high[N//2] = c_low[N//2] / 2.0`\n    `c_high[M - N//2] = c_low[N//2] / 2.0`\n4.  `c_high` 的所有其他项保持为零，这相当于假设底层信号不包含幅度大于 $N/2$ 的频率。\n\n然后通过应用一个经过缩放的 IFFT 来获得插值 $p(y_m)$：\n$$\np_m = \\frac{M}{N} \\text{real}(\\text{ifft}(\\text{c\\_high}))_m\n$$\n缩放因子 $M/N$ 解释了 DFT（在我们的定义中为 $1/N$）和 IFFT（在标准算法中为 $1/M$）的缩放约定。\n\n这个过程得出了三角插值多项式 $p(x)$ 在 $M$ 个高分辨率网格点上的值，从而实现了“超分辨率”。\n\n### 4. 算法实现\n\n总体算法如下：\n1.  **输入：**一个函数定义 $f(x)$、一个低分辨率样本数 $N$ 和一个高分辨率样本数 $M$。\n2.  **采样：**生成粗糙网格 $x_j = 2\\pi j/N$ 和样本值 $y_j = f(x_j)$，其中 $j=0, \\dots, N-1$。\n3.  **DFT：**计算样本的未缩放 DFT：`c_low = np.fft.fft(y_j)`。\n4.  **零填充：**使用第3节中描述的逻辑，从 `c_low` 构建 $M$ 点系数数组 `c_high`。\n5.  **IDFT：**通过经过缩放的 IFFT 计算高分辨率信号：`p_highres = (M/N) * np.real(np.fft.ifft(c_high))`。\n6.  **计算误差：**\n    a.  **一致性误差：**根据构造，三角插值多项式必须与样本完全匹配。误差 $p(x_j) - y_j$ 通过对高分辨率结果进行子采样来评估：`p_highres[::M//N]`。计算最大绝对差。此误差应在机器精度的数量级上。\n    b.  **高分辨率误差：**在精细网格上生成真实函数值 $f(y_m)$，并计算 `p_highres` 与这些真实值之间的最大绝对差。\n\n现在将该算法应用于问题中指定的四个测试用例。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the trigonometric interpolation problem for a suite of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"f\": lambda x: np.sin(3 * x) + 0.5 * np.cos(5 * x),\n            \"N\": 32,\n            \"M\": 1024,\n            \"name\": \"Happy path (band-limited)\"\n        },\n        {\n            \"f\": lambda x: np.cos(x),\n            \"N\": 2,\n            \"M\": 128,\n            \"name\": \"Boundary case with minimal sampling\"\n        },\n        {\n            \"f\": lambda x: np.sin(20 * x) + 0.3 * np.cos(2 * x),\n            \"N\": 16,\n            \"M\": 1024,\n            \"name\": \"Aliasing present\"\n        },\n        {\n            \"f\": lambda x: np.fmod(x, 2 * np.pi) / np.pi - 1.0,\n            \"N\": 64,\n            \"M\": 2048,\n            \"name\": \"Non-smooth periodic signal\"\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        f, N, M = case[\"f\"], case[\"N\"], case[\"M\"]\n\n        # 1. Generate low-resolution grid and sample the function.\n        # x_j = 2 * pi * j / N for j = 0, ..., N-1\n        x_coarse = 2 * np.pi * np.arange(N) / N\n        y_coarse = f(x_coarse)\n\n        # 2. Compute the DFT of the low-resolution samples.\n        # The coefficients are c_k = (1/N) * sum(y_j * exp(-2*pi*i*j*k/N)).\n        # We compute the unscaled DFT first: c_low = fft(y_coarse).\n        c_low = np.fft.fft(y_coarse)\n\n        # 3. Create high-resolution coefficients by zero-padding in Fourier space.\n        # This is the core of the \"super-resolution\" process.\n        c_high = np.zeros(M, dtype=np.complex128)\n\n        # All test cases have N as an even number.\n        # Positive frequencies (and DC component at k=0)\n        # Indices 0 to N/2 - 1 for freqs k=0,...,N/2-1\n        k_pos_limit = N // 2\n        c_high[0:k_pos_limit] = c_low[0:k_pos_limit]\n\n        # Negative frequencies go at the end of the array for 'fft' convention\n        # Indices N/2 + 1 to N - 1 correspond to freqs k = -N/2+1,...,-1\n        # These are mapped to indices M-N/2+1 to M-1 in the high-res array.\n        k_neg_start = N // 2 + 1\n        c_high[M - (N - k_neg_start):] = c_low[k_neg_start:]\n\n        # The Nyquist frequency k = N/2 component must be split.\n        # Its energy is distributed between the +k and -k modes in the new basis.\n        # In the original N-point DFT, +N/2 and -N/2 were indistinguishable.\n        nyquist_idx = N // 2\n        nyquist_coeff = c_low[nyquist_idx]\n        c_high[nyquist_idx] = nyquist_coeff / 2.0\n        c_high[M - nyquist_idx] = nyquist_coeff / 2.0\n        \n        # 4. Perform inverse FFT to get the high-resolution signal.\n        # The scaling factor M/N arises from our coefficient definition (1/N)\n        # and the standard IFFT algorithm's scaling (1/M).\n        # We want p(x) = sum(c_k * exp(ikx)), where c_k is the scaled coefficient.\n        # Our c_high is based on unscaled DFT.\n        # ifft(c_high) computes (1/M) * sum(c_high[k] * exp(2*pi*i*k*m/M)).\n        # We have c_high_k ~ N*c_k. So ifft(c_high) ~ (N/M) * p(y_m).\n        # Thus, p(y_m) = (M/N) * ifft(c_high).\n        p_highres = (M / N) * np.real(np.fft.ifft(c_high))\n\n        # 5. Calculate the two required error metrics.\n        \n        # Consistency error on the coarse grid.\n        # The trigonometric interpolant must match the samples at the coarse nodes.\n        # The coarse nodes correspond to every M/N-th sample of the fine grid.\n        # Due to floating-point arithmetic, this will be close to zero.\n        subsample_step = M // N\n        p_coarse_from_highres = p_highres[::subsample_step]\n        consistency_error = np.max(np.abs(p_coarse_from_highres - y_coarse))\n        \n        # High-resolution error\n        # Compare the interpolant with the true function on the fine grid.\n        y_fine = 2 * np.pi * np.arange(M) / M\n        y_true_fine = f(y_fine)\n        hires_error = np.max(np.abs(p_highres - y_true_fine))\n        \n        results.append(consistency_error)\n        results.append(hires_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}