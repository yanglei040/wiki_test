{
    "hands_on_practices": [
        {
            "introduction": "在应用像POD这样强大的数据分析技术之前，一个关键的初始步骤是数据预处理。本练习将探讨减去数据的时间均值所带来的影响。通过这个实践 ，我们将看到均值减法如何将动态变化从静态平均中分离出来，从而得到一组更有意义的、描述系统波动的POD模态。",
            "id": "3265876",
            "problem": "给定一个合成快照矩阵族，表示在一维空间网格上随时间测量的温度场。目标是分析减去时间平均值如何影响本征正交分解（POD）基。本征正交分解（POD）被定义为通过奇异值分解（SVD）从数据矩阵的左奇异向量得到的标准正交基，它在最小二乘意义上最优地捕获数据的方差（能量）。具体来说，如果一个数据矩阵表示为 $X \\in \\mathbb{R}^{n \\times m}$，其列为快照，则SVD为 $X = U \\Sigma V^{\\top}$，其中 $U \\in \\mathbb{R}^{n \\times n}$ 的列是标准正交的（空间模态），$\\Sigma \\in \\mathbb{R}^{n \\times m}$ 是对角矩阵，其对角线元素非负（奇异值），$V \\in \\mathbb{R}^{m \\times m}$ 的列是标准正交的（时间系数）。第一模态捕获的能量由 $\\sigma_{1}^{2} / \\sum_{i} \\sigma_{i}^{2}$ 量化，其中 $\\sigma_{i}$ 是奇异值。\n\n您将从第一性原理构建数据矩阵，如下所示。考虑一个空间网格，有 $n$ 个点 $x_{j}$ 均匀分布在 $[0,1)$ 上，以及 $m$ 个时间快照，索引为 $k = 0, 1, \\dots, m-1$。定义两种空间模式：一个平均模式 $\\phi_{\\mathrm{mean}}(x) \\equiv 1$ 和一个振荡模式 $\\phi_{\\mathrm{osc}}(x) \\equiv \\sin(2 \\pi x)$。将每个空间模式归一化，使其在 $\\mathbb{R}^{n}$ 中的欧几里得范数为单位1。设相位为 $\\theta_{k} = 2 \\pi k / m$。将每个快照（$\\mathbb{R}^{n}$ 中的一个列向量）定义为\n$$\nT_{k} = A \\,\\phi_{\\mathrm{mean}} + B \\cos(\\theta_{k}) \\,\\phi_{\\mathrm{osc}},\n$$\n并组装快照矩阵 $X = [T_{0}\\; T_{1}\\; \\cdots\\; T_{m-1}] \\in \\mathbb{R}^{n \\times m}$。\n\n对于每个 $X$，需要计算两个版本的POD基：\n- 未中心化版本直接使用 $X$。\n- 均值中心化版本使用 $X_{\\mathrm{c}} = X - \\mu \\mathbf{1}^{\\top}$，其中 $\\mu = \\frac{1}{m} \\sum_{k=0}^{m-1} T_{k}$ 是时间平均场，$\\mathbf{1} \\in \\mathbb{R}^{m}$ 是全1向量。\n\n从每次SVD中，提取：\n- 第一个左奇异向量 $u_{1}$（单位范数）和奇异值 $\\{\\sigma_{i}\\}$。\n- 定义 $u_{1}$ 和平均场 $\\mu$ 之间的绝对相关性为\n$$\nr \\equiv \\begin{cases}\n\\left| \\dfrac{u_{1}^{\\top} \\mu}{\\| \\mu \\|_{2}} \\right|,  &\\text{if } \\| \\mu \\|_{2} > 0,\\\\[6pt]\n0,  &\\text{if } \\| \\mu \\|_{2} = 0,\n\\end{cases}\n$$\n其中 $\\| \\cdot \\|_{2}$ 表示欧几里得范数。如果数据矩阵（中心化或未中心化）在数值上为零，以至于 $\\sum_{i} \\sigma_{i}^{2} = 0$，则按惯例将其第一模态能量分数定义为 $0$，并将相关性 $r$ 设为 $0$。\n\n对于下面的每个测试用例，计算四个量：\n- $r_{\\mathrm{unc}}$：未中心化的第一模态与 $\\mu$ 之间的绝对相关性。\n- $r_{\\mathrm{cen}}$：中心化的第一模态与 $\\mu$ 之间的绝对相关性。\n- $e_{\\mathrm{unc}}$：未中心化的第一模态能量分数，等于 $X$ 的 $\\sigma_{1}^{2} / \\sum_{i} \\sigma_{i}^{2}$。\n- $e_{\\mathrm{cen}}$：中心化的第一模态能量分数，等于 $X_{\\mathrm{c}}$ 的 $\\sigma_{1}^{2} / \\sum_{i} \\sigma_{i}^{2}$。\n\n使用以下固定参数（不允许随机性）：\n- 空间网格大小 $n = 128$，其中 $x_{j}$ 在 $[0,1)$ 中均匀分布。\n- 快照数量 $m = 80$，其中 $\\theta_{k} = 2 \\pi k / m$，对于 $k = 0, 1, \\dots, m-1$。\n\n参数值 $(A, B)$ 的测试套件：\n- 情况 1（非零均值主导）：$(A, B) = (3, 1)$。\n- 情况 2（零均值）：$(A, B) = (0, 1)$。\n- 情况 3（恒定场）：$(A, B) = (2, 0)$。\n- 情况 4（振荡主导，均值较小）：$(A, B) = (0.1, 2)$。\n\n您的程序必须：\n- 完全按照规定为每种情况构建 $X$。\n- 为每种情况计算 $(r_{\\mathrm{unc}}, r_{\\mathrm{cen}}, e_{\\mathrm{unc}}, e_{\\mathrm{cen}})$。\n- 将每个报告值四舍五入到 $6$ 位小数。\n\n最终输出格式：\n- 您的程序应生成单行输出，包含一个结果列表，每个测试用例一个结果，其中每个测试用例的结果是列表 $[r_{\\mathrm{unc}}, r_{\\mathrm{cen}}, e_{\\mathrm{unc}}, e_{\\mathrm{cen}}]$。\n- 整个输出必须打印为单行，没有空格，使用方括号和逗号分隔符，例如 `[[a_{11},a_{12},a_{13},a_{14}],[a_{21},a_{22},a_{23},a_{24}],\\dots]`，其中每个 $a_{ij}$ 是一个四舍五入到 $6$ 位小数的浮点数。",
            "solution": "用户提供的问题已经过分析，并被确定为有效。它在科学上基于数值线性代数的原理，特别是奇异值分解（SVD）及其通过本征正交分解（POD）在数据分析中的应用。该问题定义良好，所有参数、定义和过程都明确无误地陈述。没有内部矛盾或信息缺失。我现在将提供一个完整的解决方案。\n\n该问题要求比较给定合成数据集 $X$ 及其均值中心化版本 $X_c$ 的POD基。分析重点是第一个POD模态、其与时间平均场的对齐程度，以及它所捕获的总方差的比例。\n\n首先，我将根据问题的定义建立理论框架。\n\n**1. 空间基的构建**\n空间域是一个具有 $n=128$ 个点的一维网格，$x_j = j/n$ 对于 $j=0, 1, \\dots, n-1$。定义了两种空间模式：\n- 一个常数模式：$\\phi_{\\mathrm{mean}}(x) = 1$。离散向量是一个由1组成的 $n$ 维向量。\n- 一个振荡模式：$\\phi_{\\mathrm{osc}}(x) = \\sin(2\\pi x)$。离散向量是 $[\\sin(2\\pi x_0), \\dots, \\sin(2\\pi x_{n-1})]^{\\top}$。\n\n这些向量被归一化，使其在 $\\mathbb{R}^n$ 中的欧几里得范数为单位1。设未归一化的向量为 $v_{\\mathrm{mean}} = [1, \\dots, 1]^{\\top}$ 和 $v_{\\mathrm{osc}} = [\\sin(2\\pi x_0), \\dots, \\sin(2\\pi x_{n-1})]^{\\top}$。它们的范数平方为 $\\|v_{\\mathrm{mean}}\\|_2^2 = \\sum_{j=0}^{n-1} 1^2 = n$ 和 $\\|v_{\\mathrm{osc}}\\|_2^2 = \\sum_{j=0}^{n-1} \\sin^2(2\\pi j/n) = \\sum_{j=0}^{n-1} \\frac{1 - \\cos(4\\pi j/n)}{2} = \\frac{n}{2} - \\frac{1}{2}\\sum_{j=0}^{n-1}\\cos(4\\pi j/n)$。对于 $n>2$，余弦和为零，所以 $\\|v_{\\mathrm{osc}}\\|_2^2 = n/2$。\n归一化后的向量为 $\\phi_{\\mathrm{mean}} = v_{\\mathrm{mean}}/\\sqrt{n}$ 和 $\\phi_{\\mathrm{osc}} = v_{\\mathrm{osc}}/\\sqrt{n/2}$。\n这两个向量是正交的，因为它们的点积为 $\\sum_{j=0}^{n-1} \\sin(2\\pi j/n)$，这是 $\\sum_{j=0}^{n-1} \\exp(i 2\\pi j/n) = 0$（对于 $n>1$）的虚部。\n\n**2. 时间基的构建**\n时间行为由 $m=80$ 个快照决定。对于每个快照 $k \\in \\{0, \\dots, m-1\\}$，相位为 $\\theta_k = 2\\pi k/m$。与平均和振荡空间模式相关的时间向量是：\n- 一个常数向量：$\\mathbf{1} = [1, \\dots, 1]^{\\top} \\in \\mathbb{R}^m$。\n- 一个余弦向量：$c = [\\cos(\\theta_0), \\dots, \\cos(\\theta_{m-1})]^{\\top} \\in \\mathbb{R}^m$。\n\n这些向量也是正交的，因为它们的点积是 $\\mathbf{1}^\\top c = \\sum_{k=0}^{m-1} \\cos(2\\pi k/m)$，这是 $\\sum_{k=0}^{m-1} \\exp(i 2\\pi k/m) = 0$（对于 $m>1$）的实部。它们的范数平方为 $\\|\\mathbf{1}\\|_2^2=m$ 和 $\\|c\\|_2^2 = \\sum_{k=0}^{m-1} \\cos^2(2\\pi k/m) = m/2$（对于 $m>2$）。\n\n**3. 快照矩阵及其SVD**\n第 $k$ 个快照是 $T_k = A \\phi_{\\mathrm{mean}} + B \\cos(\\theta_k) \\phi_{\\mathrm{osc}}$。快照矩阵 $X = [T_0 \\dots T_{m-1}]$ 可以写成外积和的形式：\n$$\nX = A \\phi_{\\mathrm{mean}}\\mathbf{1}^{\\top} + B \\phi_{\\mathrm{osc}}c^{\\top}\n$$\n令 $X_{\\mathrm{mean}} = A \\phi_{\\mathrm{mean}}\\mathbf{1}^{\\top}$ 和 $X_{\\mathrm{osc}} = B \\phi_{\\mathrm{osc}}c^{\\top}$。由于空间向量 $(\\phi_{\\mathrm{mean}}, \\phi_{\\mathrm{osc}})$ 和时间向量 $(\\mathbf{1}, c)$ 形成正交对，$X$ 的SVD由 $X_{\\mathrm{mean}}$ 和 $X_{\\mathrm{osc}}$ 的SVD组成。\n$X_{\\mathrm{mean}}$ 的SVD是 $u_1 = \\phi_{\\mathrm{mean}}$，$v_1 = \\mathbf{1}/\\sqrt{m}$，以及 $\\sigma_1 = A\\sqrt{m}$。\n$X_{\\mathrm{osc}}$ 的SVD是 $u_1' = \\phi_{\\mathrm{osc}}$，$v_1' = c/\\sqrt{m/2}$，以及 $\\sigma_1' = B\\sqrt{m/2}$。\n因此，$X$ 的SVD包含两个非零奇异值，$\\sigma_{\\mathrm{mean}} = A\\sqrt{m}$ 和 $\\sigma_{\\mathrm{osc}} = B\\sqrt{m/2}$，对应的左奇异向量为 $\\phi_{\\mathrm{mean}}$ 和 $\\phi_{\\mathrm{osc}}$。第一个POD模态 $u_1$ 将是与较大奇异值相关联的那个。\n\n**4. 平均场和中心化数据**\n时间平均场为 $\\mu = \\frac{1}{m}\\sum_k T_k$。\n$$\n\\mu = \\frac{1}{m} \\sum_{k=0}^{m-1} (A \\phi_{\\mathrm{mean}} + B \\cos(\\theta_k) \\phi_{\\mathrm{osc}}) = A \\phi_{\\mathrm{mean}} + B \\phi_{\\mathrm{osc}} \\left(\\frac{1}{m} \\sum_{k=0}^{m-1} \\cos(\\theta_k)\\right)\n$$\n由于 $\\sum \\cos(\\theta_k) = 0$，我们有 $\\mu = A \\phi_{\\mathrm{mean}}$。\n均值中心化数据矩阵为：\n$$\nX_c = X - \\mu \\mathbf{1}^{\\top} = (A \\phi_{\\mathrm{mean}}\\mathbf{1}^{\\top} + B \\phi_{\\mathrm{osc}}c^{\\top}) - (A \\phi_{\\mathrm{mean}})\\mathbf{1}^{\\top} = B \\phi_{\\mathrm{osc}}c^{\\top} = X_{\\mathrm{osc}}\n$$\n因此，$X_c$ 是一个秩为1的矩阵，其唯一的POD模态是 $\\phi_{\\mathrm{osc}}$。\n\n有了这个理论基础，我可以预测每个测试用例的结果。\n- $r_{\\mathrm{unc}} = |u_1^{\\mathrm{unc}\\top}\\mu / \\|\\mu\\|_2|$\n- $e_{\\mathrm{unc}} = \\sigma_1^2 / (\\sigma_{\\mathrm{mean}}^2 + \\sigma_{\\mathrm{osc}}^2)$\n- $r_{\\mathrm{cen}} = |u_1^{\\mathrm{cen}\\top}\\mu / \\|\\mu\\|_2|$\n- $e_{\\mathrm{cen}} = \\sigma_{1,c}^2 / \\sum \\sigma_{i,c}^2$\n\n**情况 1: $(A, B) = (3, 1)$**\n$\\sigma_{\\mathrm{mean}} = 3\\sqrt{80} \\approx 26.83$，$\\sigma_{\\mathrm{osc}} = 1\\sqrt{40} \\approx 6.32$。$\\sigma_{\\mathrm{mean}} > \\sigma_{\\mathrm{osc}}$，所以 $u_1^{\\mathrm{unc}} = \\phi_{\\mathrm{mean}}$。\n$\\mu = 3\\phi_{\\mathrm{mean}} \\neq 0$。\n$r_{\\mathrm{unc}} = |\\phi_{\\mathrm{mean}}^{\\top}(3\\phi_{\\mathrm{mean}}) / \\|3\\phi_{\\mathrm{mean}}\\|_2| = 1$。\n$e_{\\mathrm{unc}} = \\frac{(3\\sqrt{80})^2}{(3\\sqrt{80})^2 + (1\\sqrt{40})^2} = \\frac{9 \\cdot 80}{9 \\cdot 80 + 1 \\cdot 40} = \\frac{720}{760} = \\frac{18}{19} \\approx 0.947368$。\n$X_c = X_{\\mathrm{osc}}$，秩为1。$u_1^{\\mathrm{cen}} = \\phi_{\\mathrm{osc}}$。$e_{\\mathrm{cen}} = 1$。\n$r_{\\mathrm{cen}} = |\\phi_{\\mathrm{osc}}^{\\top}(3\\phi_{\\mathrm{mean}}) / \\|3\\phi_{\\mathrm{mean}}\\|_2| = 0$（因正交性）。\n预期：$[1.0, 0.0, 0.947368, 1.0]$。\n\n**情况 2: $(A, B) = (0, 1)$**\n$\\mu = 0 \\cdot \\phi_{\\mathrm{mean}} = 0$。$X = X_{\\mathrm{osc}}$。秩为1。$u_1^{\\mathrm{unc}}=\\phi_{\\mathrm{osc}}$。\n根据定义，由于 $\\mu=0$，$r_{\\mathrm{unc}} = 0$。\n$e_{\\mathrm{unc}} = 1$，因为 $X$ 是秩为1的。\n$X_c = X - 0 = X$。所以中心化的结果是相同的。\n$r_{\\mathrm{cen}} = 0$，$e_{\\mathrm{cen}} = 1$。\n预期：$[0.0, 0.0, 1.0, 1.0]$。\n\n**情况 3: $(A, B) = (2, 0)$**\n$X = 2\\phi_{\\mathrm{mean}}\\mathbf{1}^{\\top} = X_{\\mathrm{mean}}$。秩为1。$u_1^{\\mathrm{unc}} = \\phi_{\\mathrm{mean}}$。\n$\\mu = 2\\phi_{\\mathrm{mean}} \\neq 0$。\n$r_{\\mathrm{unc}} = |\\phi_{\\mathrm{mean}}^{\\top}(2\\phi_{\\mathrm{mean}}) / \\|2\\phi_{\\mathrm{mean}}\\|_2| = 1$。\n$e_{\\mathrm{unc}} = 1$。\n$X_c = X - \\mu\\mathbf{1}^{\\top} = X_{\\mathrm{mean}} - X_{\\mathrm{mean}} = 0$。\n对于零矩阵，根据定义，$r_{\\mathrm{cen}}=0$ 和 $e_{\\mathrm{cen}}=0$。\n预期：$[1.0, 0.0, 1.0, 0.0]$。\n\n**情况 4: $(A, B) = (0.1, 2)$**\n$\\sigma_{\\mathrm{mean}} = 0.1\\sqrt{80} \\approx 0.894$，$\\sigma_{\\mathrm{osc}} = 2\\sqrt{40} \\approx 12.65$。$\\sigma_{\\mathrm{osc}} > \\sigma_{\\mathrm{mean}}$，所以 $u_1^{\\mathrm{unc}} = \\phi_{\\mathrm{osc}}$。\n$\\mu = 0.1\\phi_{\\mathrm{mean}} \\neq 0$。\n$r_{\\mathrm{unc}} = |\\phi_{\\mathrm{osc}}^{\\top}(0.1\\phi_{\\mathrm{mean}}) / \\|0.1\\phi_{\\mathrm{mean}}\\|_2| = 0$。\n$e_{\\mathrm{unc}} = \\frac{(2\\sqrt{40})^2}{(0.1\\sqrt{80})^2 + (2\\sqrt{40})^2} = \\frac{4 \\cdot 40}{0.01 \\cdot 80 + 4 \\cdot 40} = \\frac{160}{0.8 + 160} = \\frac{160}{160.8} = \\frac{200}{201} \\approx 0.995025$。\n$X_c = X_{\\mathrm{osc}}$，秩为1。$u_1^{\\mathrm{cen}} = \\phi_{\\mathrm{osc}}$。$e_{\\mathrm{cen}} = 1$。\n$r_{\\mathrm{cen}} = |\\phi_{\\mathrm{osc}}^{\\top}(0.1\\phi_{\\mathrm{mean}}) / \\|0.1\\phi_{\\mathrm{mean}}\\|_2| = 0$。\n预期：$[0.0, 0.0, 0.995025, 1.0]$。\n\n以下程序以数值方式实现这些计算。",
            "answer": "```python\nimport numpy as np\n\ndef compute_pod_metrics(A, B, n, m):\n    \"\"\"\n    Computes POD metrics for a given set of parameters.\n\n    Args:\n        A (float): Amplitude of the mean pattern.\n        B (float): Amplitude of the oscillatory pattern.\n        n (int): Number of spatial grid points.\n        m (int): Number of time snapshots.\n\n    Returns:\n        tuple: A tuple containing (r_unc, r_cen, e_unc, e_cen).\n    \"\"\"\n    # 1. Define grid and spatial patterns\n    x = np.linspace(0, 1, n, endpoint=False)\n    phi_mean_raw = np.ones(n)\n    phi_osc_raw = np.sin(2 * np.pi * x)\n\n    # 2. Normalize spatial patterns to unit Euclidean norm\n    norm_mean = np.linalg.norm(phi_mean_raw)\n    norm_osc = np.linalg.norm(phi_osc_raw)\n    \n    # Avoid division by zero if a pattern is somehow zero (e.g., n=1)\n    phi_mean = phi_mean_raw / norm_mean if norm_mean > 0 else phi_mean_raw\n    phi_osc = phi_osc_raw / norm_osc if norm_osc > 0 else phi_osc_raw\n\n    # 3. Construct the snapshot matrix X\n    k_vals = np.arange(m)\n    theta_k = 2 * np.pi * k_vals / m\n    cos_theta = np.cos(theta_k)\n\n    # Use broadcasting via np.outer for efficient construction\n    X = A * np.outer(phi_mean, np.ones(m)) + B * np.outer(phi_osc, cos_theta)\n    \n    # 4. Calculate the temporal mean field mu\n    mu = np.mean(X, axis=1)\n    mu_norm = np.linalg.norm(mu)\n\n    # 5. Compute metrics for the uncentered data X\n    U_unc, s_unc, _ = np.linalg.svd(X, full_matrices=False)\n    total_energy_sq_unc = np.sum(s_unc**2)\n\n    if total_energy_sq_unc > 1e-14:\n        e_unc = s_unc[0]**2 / total_energy_sq_unc\n        u1_unc = U_unc[:, 0]\n        if mu_norm > 1e-14:\n            r_unc = np.abs(np.dot(u1_unc, mu) / mu_norm)\n        else:\n            r_unc = 0.0\n    else: # This case corresponds to a numerically zero matrix\n        e_unc = 0.0\n        r_unc = 0.0\n\n    # 6. Compute metrics for the mean-centered data X_c\n    # X_c = X - mu * 1^T. Broadcasting handles this efficiently.\n    X_c = X - mu.reshape(-1, 1)\n    \n    U_cen, s_cen, _ = np.linalg.svd(X_c, full_matrices=False)\n    total_energy_sq_cen = np.sum(s_cen**2)\n\n    if total_energy_sq_cen > 1e-14:\n        e_cen = s_cen[0]**2 / total_energy_sq_cen\n        u1_cen = U_cen[:, 0]\n        if mu_norm > 1e-14:\n            r_cen = np.abs(np.dot(u1_cen, mu) / mu_norm)\n        else:\n            r_cen = 0.0\n    else: # This case corresponds to a numerically zero centered matrix\n        e_cen = 0.0\n        r_cen = 0.0\n        \n    return r_unc, r_cen, e_unc, e_cen\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n    # Fixed parameters from the problem statement\n    n = 128\n    m = 80\n\n    # Test suite of parameter values (A, B)\n    test_cases = [\n        (3.0, 1.0),   # Case 1: non-zero-mean dominant\n        (0.0, 1.0),   # Case 2: zero mean\n        (2.0, 0.0),   # Case 3: constant field\n        (0.1, 2.0)    # Case 4: oscillation dominant with small mean\n    ]\n\n    all_results = []\n    for A, B in test_cases:\n        # Compute the four required quantities for the current case\n        results_tuple = compute_pod_metrics(A, B, n, m)\n        \n        # Format the results as strings rounded to 6 decimal places\n        formatted_results = [f\"{val:.6f}\" for val in results_tuple]\n        \n        # Create the inner list string, e.g., \"[1.000000,0.000000,...]\"\n        all_results.append(f\"[{','.join(formatted_results)}]\")\n\n    # Join all case results into a single string in the required final format\n    final_output = f\"[{','.join(all_results)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "理解了数据预处理后，下一个实际挑战是计算成本，特别是对于高分辨率数据。本练习介绍“快照法”，这项关键技术使得POD在空间维度远大于观测次数的系统中变得可行。你将通过实现该方法 ，来分析数据集并计算捕获能量、重构误差和数值秩等关键指标。",
            "id": "3266011",
            "problem": "您的任务是使用快照法（method of snapshots）为在网格上表示的一系列空间场实现本征正交分解（POD），适用场景为网格点数远大于快照数。快照法的出发点是POD的基本原理，即在空间域中寻找一个标准正交基，以在标准欧几里得内积下最小化快照集的均方重构误差。数据被组织成一个矩阵，其列是不同时间的场快照。在构建分解之前，应移除快照间的样本均值场。该方法通过在快照空间中求解特征值问题来降低其维度。三角函数中使用的所有角度都必须是弧度制。\n\n构建一个程序，建立以下综合数据集的测试套件，并使用快照法计算从POD导出的量。对于每个数据集，令 $X \\in \\mathbb{R}^{m \\times n}$ 表示数据矩阵，其列是在区间 $[0,1]$ 上的均匀网格 $x_i$ 上采样的快照 $x^{(j)} \\in \\mathbb{R}^{m}$。对于每个数据集，减去快照间的样本均值场，即对每个空间坐标 $i$，从 $X_{i,j}$ 中减去 $j$ 上的平均值，得到一个均值移除矩阵 $X_c$。然后构建快照空间矩阵 $S = X_c^{\\top} X_c$。通过求解 $S$ 的对称特征值问题，将特征值从大到小排序，并形成相应的空间模态来实现POD。所有计算必须是确定性的，并且只能使用指定的环境。以下数据集通过显式公式定义 $X$；所有三角函数参数均为弧度。\n\n- 测试用例 $1$（通用高瘦情况）：$m = 200$，$n = 5$。令 $x_i = \\frac{i}{m-1}$ 对于 $i \\in \\{0,1,\\dots,m-1\\}$，$t_j = j$ 对于 $j \\in \\{0,1,\\dots,n-1\\}$。定义空间模式 $\\phi_1(x) = \\sin(\\pi x)$ 和 $\\phi_2(x) = \\cos(2\\pi x)$。对于每个快照 $j$，设置\n$$\nx^{(j)}(x) = 3\\,\\phi_1(x)\\left(1 + 0.5\\cos(0.8 t_j)\\right) + 1.5\\,\\phi_2(x)\\left(0.5\\sin(1.2 t_j)\\right) + 0.05\\,\\sin(5\\pi x)\\cos(2.3 t_j).\n$$\n计算使得累积捕获能量（$S$ 的前导特征值之和除以 $S$ 的所有特征值之和）至少为 $0.95$ 所需的最小POD模态数。以整数形式输出此数字。\n\n- 测试用例 $2$（主导第一模态）：$m = 300$，$n = 3$。令 $x_i = \\frac{i}{m-1}$ 和 $t_j = j$。定义 $\\phi_d(x) = \\sin(\\pi x)$ 和 $\\phi_s(x) = \\cos(3\\pi x)$。对于每个 $j$，设置\n$$\nx^{(j)}(x) = 4\\,\\phi_d(x)\\left(1.1 + 0.9\\sin(0.5 t_j)\\right) + 0.6\\,\\phi_s(x)\\left(\\cos(0.8 t_j)\\right).\n$$\n计算第一POD模态捕获的能量分数，定义为 $S$ 的最大特征值除以 $S$ 的所有特征值之和。以浮点数形式输出此值。\n\n- 测试用例 $3$（使用两个模态的重构误差）：$m = 50$，$n = 10$。令 $x_i = \\frac{i}{m-1}$ 和 $t_j = j$。定义 $\\phi_1(x) = \\sin(2\\pi x)$，$\\phi_2(x) = \\cos(\\pi x)$，以及 $\\phi_3(x) = \\sin(4\\pi x)$。对于每个 $j$，设置\n$$\nx^{(j)}(x) = 2\\,\\phi_1(x)\\sin(0.7 t_j) + 1.5\\,\\phi_2(x)\\cos(1.1 t_j) + 0.3\\,\\phi_3(x)\\sin(0.9 t_j).\n$$\n使用从 $S$ 计算出的前 $2$ 个POD模态，通过将 $X_c$ 投影到前两个空间模态的张成空间上，形成均值移除数据的秩为 $2$ 的重构，并计算相对重构误差，定义为\n$$\n\\frac{\\lVert X_c - X_{c,2} \\rVert_F}{\\lVert X_c \\rVert_F},\n$$\n其中 $\\lVert \\cdot \\rVert_F$ 表示弗罗贝尼乌斯范数，$X_{c,2}$ 是 $X_c$ 到前两个模态上的投影。以浮点数形式输出此值。\n\n- 测试用例 $4$（退化快照，秩测试）：$m = 400$，$n = 6$。令 $x_i = \\frac{i}{m-1}$。显式构建快照为列：\n$$\nx^{(0)}(x) = \\sin(\\pi x) + \\cos(2\\pi x), \\quad\nx^{(1)}(x) = 2\\sin(2\\pi x) - 0.5\\cos(3\\pi x), \\quad\nx^{(2)}(x) = x^{(1)}(x), \\\\\nx^{(3)}(x) = 0.7\\sin(3\\pi x) + 0.1\\cos(\\pi x), \\quad\nx^{(4)}(x) = x^{(0)}(x), \\quad\nx^{(5)}(x) = 1.3\\sin(4\\pi x) - 0.9\\cos(2\\pi x).\n$$\n在移除快照间的均值后，通过计算 $S$ 的严格正特征值的数量来计算 $X_c$ 的数值秩，使用的相对容差定义为：如果一个特征值大于 $S$ 的最大特征值的 $10^{-10}$ 倍，则将其标记为非零。以整数形式输出此秩。\n\n您的程序应生成一行输出，其中包含四个测试用例的结果，格式为方括号括起来的逗号分隔列表（例如，$[result_1,result_2,result_3,result_4]$）。四个结果必须按顺序为：测试用例1的整数模态数，测试用例2中第一模态的浮点数能量分数，测试用例3的浮点数相对重构误差，以及测试用例4的整数秩。",
            "solution": "该问题要求通过快照法对几个合成数据集实施本征正交分解（POD）。此方法的核心是分析一系列快照（不同时间实例的空间数据场），以找到一个能最优地捕获数据方差的低维基。\n\n设数据被组织在一个矩阵 $X \\in \\mathbb{R}^{m \\times n}$ 中，其中 $m$ 是空间网格点的数量，$n$ 是快照的数量。$X$ 的第 $j$ 列是时间 $t_j$ 的快照向量 $x^{(j)} \\in \\mathbb{R}^{m}$。问题规定网格点数远大于快照数，即 $m \\gg n$。\n\n规定的POD流程如下：\n$1$. **数据中心化**：第一步是移除快照的时间均值。均值快照计算为 $\\bar{x} = \\frac{1}{n} \\sum_{j=0}^{n-1} x^{(j)}$。通过从 $X$ 的每一列中减去 $\\bar{x}$ 来形成一个均值移除的数据矩阵 $X_c$。$X_c$ 的列是 $x_c^{(j)} = x^{(j)} - \\bar{x}$。\n$2$. **快照法**：直接的POD方法需要为 $m \\times m$ 的空间协方差矩阵 $C = X_c X_c^\\top$ 求解一个特征值问题。当 $m \\gg n$ 时，这在计算上是不可行的。快照法通过在较小的快照空间中求解一个特征值问题来规避此问题。我们构建 $n \\times n$ 的快照矩阵（或格拉姆矩阵）$S = X_c^\\top X_c$。\n$3$. **特征值问题**：我们求解 $S$ 的对称特征值问题：\n$$\nS v_k = \\lambda_k v_k, \\quad \\text{对于 } k = 1, \\dots, n.\n$$\n$S$ 的特征值 $\\lambda_k$ 是较大协方差矩阵 $C$ 的非零特征值。这些特征值按降序排列 $\\lambda_1 \\ge \\lambda_2 \\ge \\dots \\ge \\lambda_n \\ge 0$，代表每个相应模态捕获的能量或方差。均值中心化数据的总能量（方差）由 $S$ 的迹给出，它等于其特征值的总和：$\\sum_{k=1}^n \\lambda_k = \\text{tr}(S) = \\lVert X_c \\rVert_F^2$。\n$4$. **POD模态**：空间POD模态 $\\Psi_k \\in \\mathbb{R}^m$ 可以通过关系式 $\\Psi_k = \\frac{1}{\\sqrt{\\lambda_k}} X_c v_k$ 从 $S$ 的特征向量 $v_k$ 构建。这些模态构成了空间数据的标准正交基。\n\n我们现在将此框架应用于所提供的四个测试用例。\n\n**测试用例1：累积能量**\n数据集定义为 $m = 200$ 和 $n = 5$。快照在空间网格 $x_i = \\frac{i}{m-1}$（对于 $i \\in \\{0, \\dots, 199\\}$）和时间 $t_j = j$（对于 $j \\in \\{0, \\dots, 4\\}$）上生成。快照公式为：\n$$\nx^{(j)}(x) = 3 \\sin(\\pi x) \\left(1 + 0.5\\cos(0.8 t_j)\\right) + 0.75 \\cos(2\\pi x) \\sin(1.2 t_j) + 0.05 \\sin(5\\pi x)\\cos(2.3 t_j).\n$$\n在构建数据矩阵 $X$ 及其中心化版本 $X_c$ 后，我们计算快照矩阵 $S = X_c^\\top X_c$ 及其特征值 $\\lambda_1, \\dots, \\lambda_5$，按降序排列。前 $k$ 个模态捕获的累积能量是部分特征值和与总和的比率：\n$$\nE_k = \\frac{\\sum_{i=1}^k \\lambda_i}{\\sum_{i=1}^5 \\lambda_i}.\n$$\n我们需要找到使 $E_k \\ge 0.95$ 的最小整数 $k$。这通过计算排序后特征值的累积和并检查 $k = 1, 2, \\dots, 5$ 的条件来完成。\n\n**测试用例2：主导模态能量**\n该数据集有 $m = 300$ 和 $n = 3$。快照在网格 $x_i = \\frac{i}{m-1}$ 上，时间为 $t_j=j$（对于 $j \\in \\{0, 1, 2\\}$），使用以下公式生成：\n$$\nx^{(j)}(x) = 4 \\sin(\\pi x) \\left(1.1 + 0.9\\sin(0.5 t_j)\\right) + 0.6 \\cos(3\\pi x) \\cos(0.8 t_j).\n$$\n遵循POD程序，我们计算 $3 \\times 3$ 快照矩阵 $S$ 的特征值 $\\lambda_1, \\lambda_2, \\lambda_3$。第一（最主导的）POD模态捕获的能量分数由以下公式给出：\n$$\n\\frac{\\lambda_1}{\\sum_{i=1}^3 \\lambda_i}.\n$$\n此值将以浮点数形式计算并输出。\n\n**测试用例3：重构误差**\n此案例使用 $m = 50$ 和 $n = 10$。在时间 $t_j=j$（对于 $j \\in \\{0, \\dots, 9\\}$）的快照由以下公式给出：\n$$\nx^{(j)}(x) = 2 \\sin(2\\pi x) \\sin(0.7 t_j) + 1.5 \\cos(\\pi x) \\cos(1.1 t_j) + 0.3 \\sin(4\\pi x) \\sin(0.9 t_j).\n$$\n我们计算 $10 \\times 10$ 矩阵 $S$ 的特征值 $\\lambda_1, \\dots, \\lambda_{10}$。$X_c$ 的秩为 $k$ 的POD近似表示为 $X_{c,k}$。重构误差的弗罗贝尼乌斯范数的平方是被忽略的特征值的和：\n$$\n\\lVert X_c - X_{c,k} \\rVert_F^2 = \\sum_{i=k+1}^n \\lambda_i.\n$$\n总能量，或 $X_c$ 的弗罗贝尼乌斯范数的平方，是 $\\lVert X_c \\rVert_F^2 = \\sum_{i=1}^n \\lambda_i$。因此，对于秩为2的近似（$k=2$），相对重构误差为：\n$$\n\\text{Error} = \\frac{\\lVert X_c - X_{c,2} \\rVert_F}{\\lVert X_c \\rVert_F} = \\sqrt{\\frac{\\sum_{i=3}^{10} \\lambda_i}{\\sum_{i=1}^{10} \\lambda_i}}.\n$$\n此值将以浮点数形式计算并输出。\n\n**测试用例4：数值秩**\n此案例有 $m = 400$，$n = 6$。快照是明确定义的，有两对相同的快照：$x^{(2)} = x^{(1)}$ 和 $x^{(4)} = x^{(0)}$。$X$ 列中的这些线性相关性降低了其秩。均值中心化操作保留了这些相关性：$x_c^{(2)} = x_c^{(1)}$ 和 $x_c^{(4)} = x_c^{(0)}$。此外，$X_c$ 的列向量之和总是零向量，这引入了另一个线性相关性。因此 $X_c$ 的秩最多为 $n-1-2 = 3$。$X_c$ 的秩等于 $S=X_c^\\top X_c$ 的秩，也就是其非零特征值的数量。我们计算 $S$ 的特征值 $\\lambda_1, \\dots, \\lambda_6$。数值秩是通过使用相对容差计算有多少个特征值是严格正的来确定的。如果特征值 $\\lambda_k > 10^{-10} \\lambda_1$，其中 $\\lambda_1$ 是最大特征值，则认为其非零。我们将计算满足此条件的特征值数量。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef perform_pod_analysis(X):\n    \"\"\"\n    Performs POD analysis on a snapshot matrix X.\n\n    Args:\n        X (np.ndarray): The data matrix of shape (m, n), where m is the number of\n                        spatial points and n is the number of snapshots.\n\n    Returns:\n        tuple: A tuple containing:\n            - np.ndarray: The mean-centered data matrix X_c.\n            - np.ndarray: A 1D array of eigenvalues of the snapshot matrix S,\n                          sorted in descending order.\n    \"\"\"\n    # Step 1: Mean removal\n    mean_field = X.mean(axis=1, keepdims=True)\n    X_c = X - mean_field\n\n    # Step 2: Form the snapshot matrix S\n    S = X_c.T @ X_c\n\n    # Step 3: Solve the eigenvalue problem for S\n    # np.linalg.eigh is used for symmetric matrices and returns eigenvalues in ascending order\n    eigenvalues = np.linalg.eigh(S)[0]\n\n    # Sort eigenvalues in descending order\n    eigenvalues = np.sort(eigenvalues)[::-1]\n    \n    # Ensure eigenvalues are non-negative due to potential floating point inaccuracies\n    eigenvalues[eigenvalues < 0] = 0\n\n    return X_c, eigenvalues\n\ndef solve_case1():\n    \"\"\"Calculates the minimal number of POD modes for >= 95% energy.\"\"\"\n    m = 200\n    n = 5\n    x = np.linspace(0, 1, m)\n    t = np.arange(n)\n\n    phi1 = np.sin(np.pi * x)\n    phi2 = np.cos(2 * np.pi * x)\n    noise_phi = np.sin(5 * np.pi * x)\n\n    time_dep1 = 3 * (1 + 0.5 * np.cos(0.8 * t))\n    time_dep2 = 1.5 * (0.5 * np.sin(1.2 * t))\n    noise_time_dep = 0.05 * np.cos(2.3 * t)\n\n    X = (phi1[:, np.newaxis] * time_dep1[np.newaxis, :] +\n         phi2[:, np.newaxis] * time_dep2[np.newaxis, :] +\n         noise_phi[:, np.newaxis] * noise_time_dep[np.newaxis, :])\n    \n    _, eigenvalues = perform_pod_analysis(X)\n    \n    total_energy = np.sum(eigenvalues)\n    if total_energy == 0:\n        return n\n        \n    cumulative_energy = np.cumsum(eigenvalues) / total_energy\n    \n    num_modes = np.searchsorted(cumulative_energy, 0.95, side='left') + 1\n    return int(num_modes)\n\ndef solve_case2():\n    \"\"\"Calculates the energy fraction of the first POD mode.\"\"\"\n    m = 300\n    n = 3\n    x = np.linspace(0, 1, m)\n    t = np.arange(n)\n\n    phi_d = np.sin(np.pi * x)\n    phi_s = np.cos(3 * np.pi * x)\n\n    time_dep_d = 4 * (1.1 + 0.9 * np.sin(0.5 * t))\n    time_dep_s = 0.6 * np.cos(0.8 * t)\n\n    X = (phi_d[:, np.newaxis] * time_dep_d[np.newaxis, :] +\n         phi_s[:, np.newaxis] * time_dep_s[np.newaxis, :])\n    \n    _, eigenvalues = perform_pod_analysis(X)\n    \n    total_energy = np.sum(eigenvalues)\n    if total_energy == 0:\n        return 0.0\n\n    energy_fraction = eigenvalues[0] / total_energy\n    return float(energy_fraction)\n\ndef solve_case3():\n    \"\"\"Calculates the relative reconstruction error with 2 modes.\"\"\"\n    m = 50\n    n = 10\n    x = np.linspace(0, 1, m)\n    t = np.arange(n)\n\n    phi1 = np.sin(2 * np.pi * x)\n    phi2 = np.cos(np.pi * x)\n    phi3 = np.sin(4 * np.pi * x)\n\n    time_dep1 = 2 * np.sin(0.7 * t)\n    time_dep2 = 1.5 * np.cos(1.1 * t)\n    time_dep3 = 0.3 * np.sin(0.9 * t)\n\n    X = (phi1[:, np.newaxis] * time_dep1[np.newaxis, :] +\n         phi2[:, np.newaxis] * time_dep2[np.newaxis, :] +\n         phi3[:, np.newaxis] * time_dep3[np.newaxis, :])\n\n    _, eigenvalues = perform_pod_analysis(X)\n    \n    num_modes_for_reconstruction = 2\n    \n    total_energy = np.sum(eigenvalues)\n    if total_energy == 0:\n        return 0.0\n        \n    neglected_energy = np.sum(eigenvalues[num_modes_for_reconstruction:])\n    \n    relative_error = np.sqrt(neglected_energy / total_energy)\n    return float(relative_error)\n\ndef solve_case4():\n    \"\"\"Calculates the numerical rank of the mean-centered data.\"\"\"\n    m = 400\n    n = 6\n    x = np.linspace(0, 1, m)\n    X = np.zeros((m, n))\n\n    X[:, 0] = np.sin(np.pi * x) + np.cos(2 * np.pi * x)\n    X[:, 1] = 2 * np.sin(2 * np.pi * x) - 0.5 * np.cos(3 * np.pi * x)\n    X[:, 2] = X[:, 1]\n    X[:, 3] = 0.7 * np.sin(3 * np.pi * x) + 0.1 * np.cos(np.pi * x)\n    X[:, 4] = X[:, 0]\n    X[:, 5] = 1.3 * np.sin(4 * np.pi * x) - 0.9 * np.cos(2 * np.pi * x)\n    \n    _, eigenvalues = perform_pod_analysis(X)\n    \n    if len(eigenvalues) == 0 or eigenvalues[0] == 0:\n        return 0\n        \n    tolerance = 1e-10 * eigenvalues[0]\n    numerical_rank = np.sum(eigenvalues > tolerance)\n    \n    return int(numerical_rank)\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    result1 = solve_case1()\n    result2 = solve_case2()\n    result3 = solve_case3()\n    result4 = solve_case4()\n\n    results = [result1, result2, result3, result4]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}