{
    "hands_on_practices": [
        {
            "introduction": "这个练习将引导你为一个小型矩阵具体地、一步步地执行Arnoldi迭代。通过亲手完成算法的前几个步骤，你将牢固掌握其核心机制：为Krylov子空间生成标准正交基，并同时构建上Hessenberg矩阵 。在处理更复杂的应用之前，这项基础性练习对于建立直观理解至关重要。",
            "id": "2154379",
            "problem": "阿诺德迭代是一种用于近似计算矩阵特征值的数值算法，对于大型稀疏矩阵尤其有效。该算法为与矩阵 $A$ 和向量 $b$ 相关的克雷洛夫子空间构建一个标准正交基。\n\n设矩阵 $A$ 和初始向量 $b$ 由下式给出：\n$$\nA = \\begin{pmatrix}\n2  3  1 \\\\\n1  1  1 \\\\\n-1  0  2\n\\end{pmatrix}, \\quad b = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix}\n$$\n阿诺德过程生成一系列标准正交向量 $\\{v_1, v_2, \\dots, v_k\\}$，它们构成了克雷洛夫子空间 $\\mathcal{K}_k(A, b)$ 的一个基，同时还生成一个 $k \\times k$ 的上Hessenberg矩阵 $H_k$。该过程通过设置 $v_1 = b / \\|b\\|$ 来初始化。在阿诺德分解 $AV_k = V_kH_k + \\tilde{v}_{k+1} e_k^T$ 中，其中 $V_k = [v_1, \\dots, v_k]$，Hessenberg矩阵的元素由关系式 $h_{ij} = v_i^T A v_j$ 定义。\n\n执行三步阿诺德迭代，求得的 $3 \\times 3$ 上Hessenberg矩阵 $H_3$。",
            "solution": "我们从 $v_{1} = \\dfrac{b}{\\|b\\|} = \\begin{pmatrix}1 \\\\ 0 \\\\ 0\\end{pmatrix}$ 开始。\n\n第一步阿诺德迭代（$j=1$）：\n计算 $w = A v_{1} = \\begin{pmatrix}2 \\\\ 1 \\\\ -1\\end{pmatrix}$。然后\n$$\nh_{11} = v_{1}^{T} A v_{1} = 2,\\quad\nw \\leftarrow w - h_{11} v_{1} = \\begin{pmatrix}0 \\\\ 1 \\\\ -1\\end{pmatrix}.\n$$\n计算\n$$\nh_{21} = \\|w\\| = \\sqrt{2},\\quad v_{2} = \\frac{w}{h_{21}} = \\frac{1}{\\sqrt{2}}\\begin{pmatrix}0 \\\\ 1 \\\\ -1\\end{pmatrix}.\n$$\n\n第二步阿诺德迭代（$j=2$）：\n计算\n$$\nA v_{2} = \\frac{1}{\\sqrt{2}}\\begin{pmatrix}2 \\\\ 0 \\\\ -2\\end{pmatrix}.\n$$\n然后\n$$\nh_{12} = v_{1}^{T} A v_{2} = \\frac{2}{\\sqrt{2}} = \\sqrt{2},\\quad\nw \\leftarrow A v_{2} - h_{12} v_{1} = \\begin{pmatrix}0 \\\\ 0 \\\\ -\\sqrt{2}\\end{pmatrix}.\n$$\n接下来\n$$\nh_{22} = v_{2}^{T} A v_{2} = 1,\\quad\nw \\leftarrow w - h_{22} v_{2} = \\begin{pmatrix}0 \\\\ -\\frac{1}{\\sqrt{2}} \\\\ -\\frac{1}{\\sqrt{2}}\\end{pmatrix}.\n$$\n然后\n$$\nh_{32} = \\|w\\| = 1,\\quad v_{3} = \\frac{w}{h_{32}} = \\begin{pmatrix}0 \\\\ -\\frac{1}{\\sqrt{2}} \\\\ -\\frac{1}{\\sqrt{2}}\\end{pmatrix}.\n$$\n\n第三步阿诺德迭代（$j=3$）：\n计算\n$$\nA v_{3} = -\\frac{1}{\\sqrt{2}}\\begin{pmatrix}4 \\\\ 2 \\\\ 2\\end{pmatrix} = \\begin{pmatrix}-2\\sqrt{2} \\\\ -\\sqrt{2} \\\\ -\\sqrt{2}\\end{pmatrix}.\n$$\n那么Hessenberg矩阵的元素为\n$$\nh_{13} = v_{1}^{T} A v_{3} = -2\\sqrt{2},\\quad\nh_{23} = v_{2}^{T} A v_{3} = 0,\\quad\nh_{33} = v_{3}^{T} A v_{3} = 2.\n$$\n因为空间是三维的，并且我们已经构建了三个标准正交向量，所以减去这些分量后的残差为零，不会再产生新的向量。\n\n汇总所有元素，得到的 $3\\times 3$ 上Hessenberg矩阵为\n$$\nH_{3} = \\begin{pmatrix}\nh_{11}  h_{12}  h_{13} \\\\\nh_{21}  h_{22}  h_{23} \\\\\n0  h_{32}  h_{33}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n2  \\sqrt{2}  -2\\sqrt{2} \\\\\n\\sqrt{2}  1  0 \\\\\n0  1  2\n\\end{pmatrix}.\n$$",
            "answer": "$$\\boxed{\\begin{pmatrix}2  \\sqrt{2}  -2\\sqrt{2} \\\\ \\sqrt{2}  1  0 \\\\ 0  1  2\\end{pmatrix}}$$"
        },
        {
            "introduction": "下一个练习将从纯粹的计算转向概念理解，探索Arnoldi迭代的一个特殊情况。该算法的行为可以揭示矩阵深层的结构特性，而这个问题探讨了导致其立即终止（通常称为“幸运”中断）的条件 。通过确定哪个初始向量会导致这种情况发生，你将揭示Arnoldi过程、不变子空间和特征向量之间的根本联系。",
            "id": "2154381",
            "problem": "Arnoldi迭代是一种用于近似特征值的数值算法。对于给定的方阵 $A$ 和起始向量 $v_1$，第一步涉及将向量归一化为 $q_1 = v_1 / \\|v_1\\|_2$，计算 $w = A q_1$，然后计算残差向量 $r_1 = w - (q_1^T w) q_1$。如果残差向量 $r_1$ 是零向量，则算法在第一步之后终止。\n\n考虑一个 $3 \\times 3$ 矩阵 $A$，其元素定义为 $A_{11}=1$, $A_{12}=0$, $A_{13}=1$, $A_{21}=1$, $A_{22}=1$, $A_{23}=1$, $A_{31}=1$, $A_{32}=1$ 和 $A_{33}=-1$。当选择下列哪个列向量作为起始向量 $v_1$ 时，会导致Arnoldi迭代仅在一步之后就终止？\n\nA. 分量为 (1, 1, 1) 的向量。\n\nB. 分量为 (1, 2, 1) 的向量。\n\nC. 分量为 (1, -1, 0) 的向量。\n\nD. 分量为 (0, 1, 1) 的向量。\n\nE. 分量为 (1, 0, -1) 的向量。",
            "solution": "问题要求确定哪个起始向量 $v_1$ 会导致Arnoldi迭代在第一步之后终止。\n根据问题描述，如果残差向量 $r_1$ 是零向量，Arnoldi迭代的第一步就会终止。\n残差向量定义为 $r_1 = w - h_{11} q_1$，其中 $q_1 = v_1 / \\|v_1\\|_2$，$w = A q_1$，且 $h_{11} = q_1^T w = q_1^T A q_1$。\n\n令 $r_1 = 0$，我们得到：\n$$\nw - h_{11} q_1 = 0 \\implies w = h_{11} q_1\n$$\n代入 $w$ 的表达式：\n$$\nA q_1 = h_{11} q_1\n$$\n这是特征向量和特征值的定义。该方程表明向量 $q_1$ 必须是矩阵 $A$ 的一个特征向量，而标量 $h_{11}$ 必须是对应的特征值。\n\n由于 $q_1$ 只是起始向量 $v_1$ 的归一化版本（即 $q_1$ 是 $v_1$ 乘以 $1/\\|v_1\\|_2$），如果 $q_1$ 是一个特征向量，那么 $v_1$ 也必须是 $A$ 的一个特征向量。具体来说，如果 $A q_1 = \\lambda q_1$，那么：\n$$\nA \\left(\\frac{v_1}{\\|v_1\\|_2}\\right) = \\lambda \\left(\\frac{v_1}{\\|v_1\\|_2}\\right)\n$$\n两边同乘以标量 $\\|v_1\\|_2$ 得到：\n$$\nA v_1 = \\lambda v_1\n$$\n因此，问题简化为找出给定向量中哪一个是矩阵 $A$ 的特征向量。\n\n矩阵 $A$ 由其分量给出：\n$$\nA = \\begin{pmatrix} 1  0  1 \\\\ 1  1  1 \\\\ 1  1  -1 \\end{pmatrix}\n$$\n我们现在通过将矩阵 $A$ 与该选项中的向量 $v_1$ 相乘，并检查结果向量是否为原始向量的标量倍数，来测试每个选项。\n\nA. 对于 $v_1 = \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix}$：\n$$\nA v_1 = \\begin{pmatrix} 1  0  1 \\\\ 1  1  1 \\\\ 1  1  -1 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 1(1) + 0(1) + 1(1) \\\\ 1(1) + 1(1) + 1(1) \\\\ 1(1) + 1(1) - 1(1) \\end{pmatrix} = \\begin{pmatrix} 2 \\\\ 3 \\\\ 1 \\end{pmatrix}\n$$\n是否存在某个标量 $\\lambda$ 使得 $\\begin{pmatrix} 2 \\\\ 3 \\\\ 1 \\end{pmatrix} = \\lambda \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix}$？不存在，因为 $2/1 \\neq 3/1$。\n\nB. 对于 $v_1 = \\begin{pmatrix} 1 \\\\ 2 \\\\ 1 \\end{pmatrix}$：\n$$\nA v_1 = \\begin{pmatrix} 1  0  1 \\\\ 1  1  1 \\\\ 1  1  -1 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 2 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 1(1) + 0(2) + 1(1) \\\\ 1(1) + 1(2) + 1(1) \\\\ 1(1) + 1(2) - 1(1) \\end{pmatrix} = \\begin{pmatrix} 2 \\\\ 4 \\\\ 2 \\end{pmatrix}\n$$\n是否存在某个标量 $\\lambda$ 使得 $\\begin{pmatrix} 2 \\\\ 4 \\\\ 2 \\end{pmatrix} = \\lambda \\begin{pmatrix} 1 \\\\ 2 \\\\ 1 \\end{pmatrix}$？是的，如果我们令 $\\lambda=2$，我们有 $2 \\begin{pmatrix} 1 \\\\ 2 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 2 \\\\ 4 \\\\ 2 \\end{pmatrix}$。这个向量是 $A$ 的一个特征向量。\n\nC. 对于 $v_1 = \\begin{pmatrix} 1 \\\\ -1 \\\\ 0 \\end{pmatrix}$：\n$$\nA v_1 = \\begin{pmatrix} 1  0  1 \\\\ 1  1  1 \\\\ 1  1  -1 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ -1 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 1(1) + 0(-1) + 1(0) \\\\ 1(1) + 1(-1) + 1(0) \\\\ 1(1) + 1(-1) - 1(0) \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix}\n$$\n是否存在某个标量 $\\lambda$ 使得 $\\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix} = \\lambda \\begin{pmatrix} 1 \\\\ -1 \\\\ 0 \\end{pmatrix}$？不存在。例如，第二个分量是 $0 = \\lambda(-1)$，这意味着 $\\lambda=0$，但第一个分量是 $1 = \\lambda(1)$，这意味着 $\\lambda=1$。这是一个矛盾。\n\nD. 对于 $v_1 = \\begin{pmatrix} 0 \\\\ 1 \\\\ 1 \\end{pmatrix}$：\n$$\nA v_1 = \\begin{pmatrix} 1  0  1 \\\\ 1  1  1 \\\\ 1  1  -1 \\end{pmatrix} \\begin{pmatrix} 0 \\\\ 1 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 1(0) + 0(1) + 1(1) \\\\ 1(0) + 1(1) + 1(1) \\\\ 1(0) + 1(1) - 1(1) \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ 2 \\\\ 0 \\end{pmatrix}\n$$\n是否存在某个标量 $\\lambda$ 使得 $\\begin{pmatrix} 1 \\\\ 2 \\\\ 0 \\end{pmatrix} = \\lambda \\begin{pmatrix} 0 \\\\ 1 \\\\ 1 \\end{pmatrix}$？不存在。第一个分量要求 $1 = \\lambda(0)$，这是不可能的。\n\nE. 对于 $v_1 = \\begin{pmatrix} 1 \\\\ 0 \\\\ -1 \\end{pmatrix}$：\n$$\nA v_1 = \\begin{pmatrix} 1  0  1 \\\\ 1  1  1 \\\\ 1  1  -1 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\\\ -1 \\end{pmatrix} = \\begin{pmatrix} 1(1) + 0(0) + 1(-1) \\\\ 1(1) + 1(0) + 1(-1) \\\\ 1(1) + 1(0) - 1(-1) \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 2 \\end{pmatrix}\n$$\n是否存在某个标量 $\\lambda$ 使得 $\\begin{pmatrix} 0 \\\\ 0 \\\\ 2 \\end{pmatrix} = \\lambda \\begin{pmatrix} 1 \\\\ 0 \\\\ -1 \\end{pmatrix}$？不存在。第一个分量要求 $0 = \\lambda(1)$，这意味着 $\\lambda=0$。但第三个分量要求 $2 = \\lambda(-1)$，这意味着 $\\lambda=-2$。这是一个矛盾。\n\n只有选项B中的向量是 $A$ 的特征向量。因此，选择这个向量作为起始向量 $v_1$ 将导致Arnoldi迭代在第一步之后终止。",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "从理论走向实践，这最后一个练习将探讨数值算法的一个关键方面：稳定性。在有限精度的计算机算术中，理论上等价的不同实现策略可能会产生截然不同的结果。这个编程挑战  要求你在Arnoldi迭代中实现并比较两种正交化方案——经典格拉姆-施密特（CGS）和修正格拉姆-施密特（MGS）方法。通过这个过程，你将直接观察到数值稳定性的实际影响，并理解为什么算法的选择至关重要。",
            "id": "3206345",
            "problem": "您需要使用两种正交化策略实现 Arnoldi 迭代：经典 Gram-Schmidt (CGS) 和修正 Gram-Schmidt (MGS)。从给定方阵的 Krylov 子空间的基本定义出发，Arnoldi 过程构建一个标准正交基和相应的上 Hessenberg 矩阵。您的目标是实现这两种变体，量化在有限精度算术中的正交性损失，并找出一个 CGS因正交性损失而失败但 MGS 成功的矩阵。\n\n从以下基本概念开始：\n- 对于给定的矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 和非零向量 $b \\in \\mathbb{R}^{n}$，第 $k$ 个 Krylov 子空间为 $K_k(A,b) = \\text{span}\\{b, Ab, A^2 b, \\dots, A^{k-1} b\\}$。\n- Arnoldi 迭代构建 $K_k(A,b)$ 的一个标准正交基 $\\{q_1,\\dots,q_k\\}$ 和一个上 Hessenberg 矩阵 $H_{k+1,k}$，使得 $A Q_k = Q_{k+1} H_{k+1,k}$，其中 $Q_k = [q_1,\\dots,q_k]$ 且 $Q_{k+1} = [q_1,\\dots,q_{k+1}]$。$Q_k$ 的正交性对于数值稳定性和准确性至关重要。\n\n需要实现和验证的任务：\n1. 实现两个 Arnoldi 过程：\n   - 经典 Gram-Schmidt (CGS)：在每个 Arnoldi 步骤 $j$，计算 $v = A q_j$，然后通过一次矩阵向量乘积步骤计算系数向量 $h = Q_j^\\top v$，并更新 $v \\leftarrow v - Q_j h$。最后计算 $h_{j+1,j} = \\|v\\|_2$，如果非零，则设置 $q_{j+1} = v / h_{j+1,j}$。当 $h_{j+1,j} = 0$ 时检测到中断并停止。\n   - 修正 Gram-Schmidt (MGS)：在每个 Arnoldi 步骤 $j$，计算 $v = A q_j$，然后对于 $i = 1,\\dots,j$ 依次计算 $h_{i,j} = q_i^\\top v$ 并更新 $v \\leftarrow v - h_{i,j} q_i$。最后计算 $h_{j+1,j} = \\|v\\|_2$ 并按上述方式继续，并进行中断检测。\n2. 对每次运行，计算正交性误差\n   $$E_k = \\left\\| Q_k^\\top Q_k - I_k \\right\\|_F,$$\n   其中 $I_k$ 是大小为 $k$ 的单位矩阵，$\\|\\cdot\\|_F$ 表示 Frobenius 范数。将 CGS 和 MGS 的 $E_k$ 报告为浮点数。\n3. 在发生中断的情况下，报告生成的有效 Krylov 维数，记为 $k_{\\text{eff}}$，它等于在 $Q_k$ 中实际构建的列数，直到中断为止（包括初始向量 $q_1$）。\n\n您的程序必须运行以下测试套件。对于每个测试用例，按此顺序输出四个值 $(E_k^{\\text{CGS}}, E_k^{\\text{MGS}}, k_{\\text{eff}}^{\\text{CGS}}, k_{\\text{eff}}^{\\text{MGS}})$。将所有测试用例聚合到最终输出的单个扁平列表中，如下所述。\n\n测试套件：\n- 测试用例 1（良态，正常路径）：\n  - 矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 是三对角 Toeplitz 矩阵，其中 $A_{i,i} = -2$, $A_{i,i+1} = 1$, $A_{i+1,i} = 1$ (对于 $i = 1,\\dots,n-1$)，其他位置为零。使用 $n = 40$。\n  - 起始向量 $b \\in \\mathbb{R}^{n}$ 按分量定义为 $b_i = i$ (对于 $i = 1,\\dots,n$)，然后归一化为单位 $2$-范数。\n  - Arnoldi 步骤 $k = 20$。\n- 测试用例 2（非正规 Jordan 块，预期 CGS 会失去正交性，MGS 会成功）：\n  - 矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 是对角线上为一、超对角线上为一的 Jordan 块：$A_{i,i} = 1$, $A_{i,i+1} = 1$ (对于 $i = 1,\\dots,n-1$)，其他位置为零。使用 $n = 60$。\n  - 起始向量 $b = e_1 \\in \\mathbb{R}^{n}$，即第一个标准基向量。\n  - Arnoldi 步骤 $k = 40$。\n- 测试用例 3（中断边界情况）：\n  - 矩阵 $A = 2 I \\in \\mathbb{R}^{n \\times n}$，其中 $n = 20$，$I$ 是单位矩阵。\n  - 起始向量 $b \\in \\mathbb{R}^{n}$，其中 $b_i = 1$ (对于 $i = 1,\\dots,n$)，然后归一化为单位 $2$-范数。\n  - Arnoldi 步骤 $k = 5$。\n  - 在精确算术中，中断发生在第一步之后，因为 $A q_1$ 与 $q_1$ 共线；您的实现必须检测到这一点并相应地报告有效维数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。该列表必须按顺序包含所有测试用例的 $[E_k^{\\text{CGS}}, E_k^{\\text{MGS}}, k_{\\text{eff}}^{\\text{CGS}}, k_{\\text{eff}}^{\\text{MGS}}]$ 的串联。\n- 对于指定的三个测试用例，最终输出因此必须包含 12 个条目：$[E_1^{\\text{CGS}}, E_1^{\\text{MGS}}, k_{1,\\text{eff}}^{\\text{CGS}}, k_{1,\\text{eff}}^{\\text{MGS}}, E_2^{\\text{CGS}}, E_2^{\\text{MGS}}, k_{2,\\text{eff}}^{\\text{CGS}}, k_{2,\\text{eff}}^{\\text{MGS}}, E_3^{\\text{CGS}}, E_3^{\\text{MGS}}, k_{3,\\text{eff}}^{\\text{CGS}}, k_{3,\\text{eff}}^{\\text{MGS}}]$。\n- 所有角度（如果出现）都必须以弧度为单位。本问题中没有物理单位。所有报告的数字必须是实数或整数。不允许使用百分号；对任何小数值请使用小数。",
            "solution": "本任务要求实现并比较 Arnoldi 迭代算法的两种变体，用于为 Krylov 子空间构建标准正交基。这两种变体在正交化过程的选择上有所不同：经典 Gram-Schmidt (CGS) 过程和修正 Gram-Schmidt (MGS) 过程。目标是通过量化特定测试用例的正交性损失来分析它们的数值稳定性，其中包括一个旨在突显 MGS 在有限精度算术中卓越稳定性的案例。\n\n### Arnoldi 迭代与 Krylov 子空间\n\n给定一个方阵 $A \\in \\mathbb{R}^{n \\times n}$ 和一个非零起始向量 $b \\in \\mathbb{R}^{n}$，第 $k$ 个 Krylov 子空间（记为 $K_k(A, b)$）是由矩阵向量乘积序列中的前 $k$ 个向量张成的向量空间：\n$$\nK_k(A, b) = \\text{span}\\{b, Ab, A^2b, \\dots, A^{k-1}b\\}\n$$\nArnoldi 迭代是为该子空间生成标准正交基 $\\{q_1, q_2, \\dots, q_k\\}$ 的一种算法。该过程是迭代的。假设我们已经构建了一个标准正交集 $\\{q_1, \\dots, q_j\\}$，下一个向量 $q_{j+1}$ 是通过取向量 $A q_j$，使其与所有先前的基向量 $q_1, \\dots, q_j$ 正交，然后将其归一化来找到的。\n\n此过程构建了一个矩阵 $Q_k = [q_1, q_2, \\dots, q_k]$，其列构成了标准正交基。它还生成一个上 Hessenberg 矩阵 $H_{k+1,k} \\in \\mathbb{R}^{(k+1) \\times k}$，满足基本的 Arnoldi 关系：\n$$\nA Q_k = Q_{k+1} H_{k+1,k}\n$$\n这里，$Q_{k+1} = [Q_k, q_{k+1}]$，而 $H_{k+1,k}$ 的元素（记为 $h_{i,j}$）是来自正交化步骤的系数。\n\n算法的核心在于正交化步骤。在步骤 $j$（对于 $j=1, \\dots, k$），我们计算 $v = A q_j$，然后将 $v$ 与现有基 $\\{q_1, \\dots, q_j\\}$ 进行正交化。\n\n### 正交化方法：CGS vs. MGS\n\n**1. 基于经典 Gram-Schmidt (CGS) 的 Arnoldi：**\n在 CGS 变体中，向量 $v = A q_j$ 与所有先前的基向量 $\\{q_1, \\dots, q_j\\}$ 同时进行正交化。首先计算投影系数 $h_{i,j}$，然后在一个步骤中从 $v$ 中减去它们的组合投影。\n\n步骤 $j$ 的过程如下：\n1.  计算新的候选向量：$v = A q_j$。\n2.  计算所有投影系数：$h_{i,j} = q_i^\\top v$（对于 $i=1, \\dots, j$）。矩阵形式为 $h_j = Q_j^\\top v$，其中 $h_j$ 是 $H_{k,k}$ 的第 $j$ 列的一部分。\n3.  计算正交向量：$w_j = v - \\sum_{i=1}^j h_{i,j} q_i$。矩阵形式为 $w_j = v - Q_j h_j$。\n4.  计算归一化因子：$h_{j+1,j} = \\|w_j\\|_2$。\n5.  归一化得到下一个基向量：$q_{j+1} = w_j / h_{j+1,j}$。\n\n虽然在数学上是正确的，但 CGS 以其数值不稳定性而闻名。在计算 $h_{i,j}$ 和减法过程中的舍入误差可能导致计算出的 $w_j$ 并非完全与基 $\\{q_1, \\dots, q_j\\}$ 正交，从而导致矩阵 $Q_k$ 的正交性迅速丧失。\n\n**2. 基于修正 Gram-Schmidt (MGS) 的 Arnoldi：**\nMGS 变体通过重新排序正交化操作来解决 CGS 的不稳定性问题。它不是减去投影的总和，而是依次减去每个投影。\n\n步骤 $j$ 的过程如下：\n1.  初始化待正交化的向量：$v^{(0)} = A q_j$。\n2.  依次移除沿 $q_i$ 的分量：对于 $i = 1, \\dots, j$：\n    a. 计算投影系数：$h_{i,j} = q_i^\\top v^{(i-1)}$。\n    b. 更新向量：$v^{(i)} = v^{(i-1)} - h_{i,j} q_i$。\n3.  最终的正交向量是 $w_j = v^{(j)}$。\n4.  计算归一化因子：$h_{j+1,j} = \\|w_j\\|_2$。\n5.  归一化得到下一个基向量：$q_{j+1} = w_j / h_{j+1,j}$。\n\n这种顺序过程在数值上更为稳健。通过在每个子步骤更新向量 $v$，MGS 更有效地减少了沿先前基向量的分量，从而减轻了舍入误差的累积。\n\n### 中断与误差测量\n\n**中断条件：**\n如果在步骤 $j$，向量 $w_j$ 变为零（或者在数值上，其范数 $h_{j+1,j}$ 小于给定容差），Arnoldi 迭代可能会提前终止。这一事件被称为中断。它发生在向量 $A q_j$ 已经包含在子空间 $K_j(A, b) = \\text{span}\\{q_1, \\dots, q_j\\}$ 中时。这意味着 Krylov 子空间是 $A$ 的一个不变子空间。在这种情况下，过程停止，构建的子空间的有效维数为 $k_{\\text{eff}} = j$。\n\n**正交性误差：**\n为了量化 CGS 和 MGS 的数值稳定性，我们测量生成的基矩阵 $Q_k$ 的正交性损失。一个完美的标准正交矩阵 $Q_k$ 满足 $Q_k^\\top Q_k = I_k$，其中 $I_k$ 是 $k \\times k$ 的单位矩阵。任何偏差都表示正交性的损失。我们使用差值的 Frobenius 范数来测量这个误差：\n$$\nE_k = \\| Q_k^\\top Q_k - I_k \\|_F\n$$\n较小的 $E_k$ 值表示更好的数值性能。如果中断发生在维数 $k_{\\text{eff}}$ 处，则为生成的矩阵 $Q_{k_{\\text{eff}}}$ 计算误差。\n\n所提供的测试用例旨在验证实现并展示这些数值特性。测试用例 1 使用一个行为良好的对称矩阵，两种方法都应表现良好。测试用例 2 使用一个非正规 Jordan 块，这是一个经典的例子，其中 CGS 的性能预计会比 MGS 差。测试用例 3 是一个简单的案例，旨在测试算法对提前中断的处理能力。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef arnoldi_iteration(A, b, k_max, method='mgs'):\n    \"\"\"\n    Performs Arnoldi iteration to find an orthonormal basis of the Krylov subspace.\n\n    Args:\n        A (np.ndarray): The square matrix of size n x n.\n        b (np.ndarray): The starting vector of size n.\n        k_max (int): The number of Arnoldi steps to perform.\n        method (str): The orthogonalization method, 'cgs' or 'mgs'.\n\n    Returns:\n        tuple: A tuple containing:\n            - Q_k_eff (np.ndarray): Matrix with orthonormal columns spanning the\n              Krylov subspace of effective dimension k_eff.\n            - H (np.ndarray): The upper Hessenberg matrix.\n            - k_eff (int): The effective dimension of the Krylov subspace.\n    \"\"\"\n    n = A.shape[0]\n    # Use float64 for higher precision, crucial for observing stability differences\n    Q = np.zeros((n, k_max + 1), dtype=np.float64)\n    H = np.zeros((k_max + 1, k_max), dtype=np.float64)\n\n    # Normalize the starting vector b\n    b_norm = np.linalg.norm(b)\n    if b_norm == 0:\n        # If b is a zero vector, the subspace is trivial.\n        return Q[:, :1], H[:1, :0], 0\n    Q[:, 0] = b / b_norm\n\n    k_eff = k_max\n    # A small tolerance to detect numerical breakdown\n    breakdown_tol = 1e-12\n\n    for j in range(k_max):\n        # v = A * q_j\n        v = A @ Q[:, j]\n\n        if method == 'cgs':\n            # Classical Gram-Schmidt\n            # h = Q_j^T * v\n            h_col = Q[:, :j + 1].T @ v\n            H[:j + 1, j] = h_col\n            # v_ortho = v - Q_j * h\n            v_ortho = v - Q[:, :j + 1] @ h_col\n        elif method == 'mgs':\n            # Modified Gram-Schmidt\n            v_ortho = v.copy()\n            for i in range(j + 1):\n                # h_ij = q_i^T * v_ortho\n                h_ij = Q[:, i].T @ v_ortho\n                H[i, j] = h_ij\n                # v_ortho = v_ortho - h_ij * q_i\n                v_ortho -= h_ij * Q[:, i]\n        else:\n            raise ValueError(\"Method must be 'cgs' or 'mgs'\")\n\n        h_next = np.linalg.norm(v_ortho)\n        H[j + 1, j] = h_next\n\n        if h_next  breakdown_tol:\n            # Breakdown occurred, the subspace is invariant\n            k_eff = j + 1\n            break\n\n        # q_{j+1} = v_ortho / h_{j+1, j}\n        Q[:, j + 1] = v_ortho / h_next\n\n    # Truncate Q to the effective dimension\n    Q_k_eff = Q[:, :k_eff]\n\n    return Q_k_eff, H, k_eff\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases\n    test_cases = []\n\n    # Test case 1 (well-conditioned)\n    n1 = 40\n    k1 = 20\n    A1 = np.diag(-2 * np.ones(n1)) + np.diag(np.ones(n1 - 1), 1) + np.diag(np.ones(n1 - 1), -1)\n    b1 = np.arange(1, n1 + 1, dtype=np.float64)\n    b1 /= np.linalg.norm(b1)\n    test_cases.append({'A': A1, 'b': b1, 'k': k1})\n\n    # Test case 2 (non-normal Jordan block)\n    n2 = 60\n    k2 = 40\n    A2 = np.eye(n2) + np.diag(np.ones(n2 - 1), 1)\n    b2 = np.zeros(n2, dtype=np.float64)\n    b2[0] = 1.0\n    test_cases.append({'A': A2, 'b': b2, 'k': k2})\n    \n    # Test case 3 (breakdown)\n    n3 = 20\n    k3 = 5\n    A3 = 2 * np.eye(n3)\n    b3 = np.ones(n3, dtype=np.float64)\n    b3 /= np.linalg.norm(b3)\n    test_cases.append({'A': A3, 'b': b3, 'k': k3})\n\n    results = []\n    for case in test_cases:\n        A, b, k = case['A'], case['b'], case['k']\n        \n        # Run CGS\n        Q_cgs, _, k_eff_cgs = arnoldi_iteration(A, b, k, method='cgs')\n        I_cgs = np.eye(k_eff_cgs)\n        error_cgs = np.linalg.norm(Q_cgs.T @ Q_cgs - I_cgs, 'fro')\n        \n        # Run MGS\n        Q_mgs, _, k_eff_mgs = arnoldi_iteration(A, b, k, method='mgs')\n        I_mgs = np.eye(k_eff_mgs)\n        error_mgs = np.linalg.norm(Q_mgs.T @ Q_mgs - I_mgs, 'fro')\n\n        results.extend([error_cgs, error_mgs, k_eff_cgs, k_eff_mgs])\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}