{
    "hands_on_practices": [
        {
            "introduction": "要掌握任何算法，我们都必须从其基本操作开始。第一个练习将引导您完成 Arnoldi 迭代的一个完整步骤。通过亲手计算第一个海森伯格矩阵（Hessenberg matrix）元素和第二个 Arnoldi 向量，您将对该算法的核心机制——即向量归一化、矩阵向量乘积和格拉姆-施密特（Gram-Schmidt）正交化——获得具体的理解。",
            "id": "2154392",
            "problem": "在数值线性代数中，Arnoldi 迭代是一种为由矩阵 $A$ 和向量 $b$ 生成的 Krylov 子空间构建标准正交基的算法。考虑如下给出的方阵 $A$ 和初始向量 $b$：\n$$ A = \\begin{pmatrix} 1  1  0 \\\\ 1  1  0 \\\\ 0  0  1 \\end{pmatrix}, \\quad b = \\begin{pmatrix} 1 \\\\ 2 \\\\ 2 \\end{pmatrix} $$\nArnoldi 过程的第一步是将初始向量单位化以获得第一个基向量 $v_1 = b / \\|b\\|_2$，其中 $\\|\\cdot\\|_2$ 表示标准的欧几里得范数。然后，该迭代过程继续生成后续的向量以及一个上 Hessenberg 矩阵 $H$ 的元素。\n\n执行一步完整的 Arnoldi 迭代，以计算 Hessenberg 矩阵的元素 $h_{1,1}$ 和第二个 Arnoldi 基向量 $v_2$。\n\n你的最终答案应以一个单行矩阵的形式给出，该矩阵按以下顺序包含四个精确的符号值：$h_{1,1}$ 的值，其后是向量 $v_2$ 的第一、第二和第三个分量。",
            "solution": "我们执行一步 Arnoldi 迭代。\n\n首先，将 $b$ 单位化得到 $v_{1}$。其欧几里得范数为\n$$\n\\|b\\|_{2}=\\sqrt{1^{2}+2^{2}+2^{2}}=\\sqrt{9}=3,\n$$\n所以\n$$\nv_{1}=\\frac{b}{\\|b\\|_{2}}=\\begin{pmatrix}\\frac{1}{3} \\\\ \\frac{2}{3} \\\\ \\frac{2}{3}\\end{pmatrix}.\n$$\n计算 $w=A v_{1}$：\n$$\nw=A v_{1}=\\begin{pmatrix}1  1  0\\\\ 1  1  0\\\\ 0  0  1\\end{pmatrix}\\begin{pmatrix}\\frac{1}{3} \\\\ \\frac{2}{3} \\\\ \\frac{2}{3}\\end{pmatrix}=\\begin{pmatrix}1 \\\\ 1 \\\\ \\frac{2}{3}\\end{pmatrix}.\n$$\nHessenberg 元素为\n$$\nh_{1,1}=v_{1}^{\\top}w=\\frac{1}{3}\\cdot 1+\\frac{2}{3}\\cdot 1+\\frac{2}{3}\\cdot\\frac{2}{3}= \\frac{13}{9}.\n$$\n正交化并单位化以得到 $v_{2}$。定义\n$$\nr=w-h_{1,1}v_{1}=\\begin{pmatrix}1 \\\\ 1 \\\\ \\frac{2}{3}\\end{pmatrix}-\\frac{13}{9}\\begin{pmatrix}\\frac{1}{3} \\\\ \\frac{2}{3} \\\\ \\frac{2}{3}\\end{pmatrix}=\\begin{pmatrix}\\frac{14}{27} \\\\ \\frac{1}{27} \\\\ -\\frac{8}{27}\\end{pmatrix}.\n$$\n其范数为\n$$\n\\|r\\|_{2}=\\sqrt{\\left(\\frac{14}{27}\\right)^{2}+\\left(\\frac{1}{27}\\right)^{2}+\\left(-\\frac{8}{27}\\right)^{2}}=\\frac{1}{27}\\sqrt{261}=\\frac{\\sqrt{29}}{9}.\n$$\n因此\n$$\nv_{2}=\\frac{r}{\\|r\\|_{2}}=\\frac{9}{\\sqrt{29}}\\begin{pmatrix}\\frac{14}{27} \\\\ \\frac{1}{27} \\\\ -\\frac{8}{27}\\end{pmatrix}=\\begin{pmatrix}\\frac{14}{3\\sqrt{29}} \\\\ \\frac{1}{3\\sqrt{29}} \\\\ -\\frac{8}{3\\sqrt{29}}\\end{pmatrix}.\n$$\n因此，$h_{1,1}=\\frac{13}{9}$ 且 $v_{2}=\\left(\\frac{14}{3\\sqrt{29}},\\,\\frac{1}{3\\sqrt{29}},\\,-\\frac{8}{3\\sqrt{29}}\\right)^{\\top}$。",
            "answer": "$$\\boxed{\\begin{pmatrix}\\frac{13}{9}  \\frac{14}{3\\sqrt{29}}  \\frac{1}{3\\sqrt{29}}  -\\frac{8}{3\\sqrt{29}}\\end{pmatrix}}$$"
        },
        {
            "introduction": "Arnoldi 迭代并非总能完成预设的全部步数；有时它会提前终止。这种“幸运终止”（lucky breakdown）并非错误，而是揭示了矩阵与所选初始向量的内在结构特性。这个问题挑战您去发现导致迭代仅在一步之后就终止的特定条件，从而将该算法与特征向量和不变子空间这些基本概念直接联系起来。",
            "id": "2154381",
            "problem": "Arnoldi迭代是一种用于近似特征值的数值算法。对于给定的方阵 $A$ 和一个起始向量 $v_1$，第一步包括将向量单位化为 $q_1 = v_1 / \\|v_1\\|_2$，计算 $w = A q_1$，然后计算残差向量 $r_1 = w - (q_1^T w) q_1$。如果残差向量 $r_1$ 是零向量，则算法在第一步之后终止。\n\n考虑一个 $3 \\times 3$ 矩阵 $A$，其元素定义为 $A_{11}=1$, $A_{12}=0$, $A_{13}=1$, $A_{21}=1$, $A_{22}=1$, $A_{23}=1$, $A_{31}=1$, $A_{32}=1$, $A_{33}=-1$。当选择下列哪个列向量作为起始向量 $v_1$ 时，会导致Arnoldi迭代仅在一步之后就终止？\n\nA. 分量为 (1, 1, 1) 的向量。\n\nB. 分量为 (1, 2, 1) 的向量。\n\nC. 分量为 (1, -1, 0) 的向量。\n\nD. 分量为 (0, 1, 1) 的向量。\n\nE. 分量为 (1, 0, -1) 的向量。",
            "solution": "问题要求确定哪个起始向量 $v_1$ 会导致Arnoldi迭代在第一步后终止。\n根据问题描述，如果残差向量 $r_1$ 是零向量，Arnoldi迭代的第一步就会终止。\n残差向量定义为 $r_1 = w - h_{11} q_1$，其中 $q_1 = v_1 / \\|v_1\\|_2$，$w = A q_1$，以及 $h_{11} = q_1^T w = q_1^T A q_1$。\n\n令 $r_1 = 0$，我们得到：\n$$\nw - h_{11} q_1 = 0 \\implies w = h_{11} q_1\n$$\n代入 $w$ 的表达式：\n$$\nA q_1 = h_{11} q_1\n$$\n这是特征向量和特征值的定义。该方程表明向量 $q_1$ 必须是矩阵 $A$ 的一个特征向量，而标量 $h_{11}$ 必须是对应的特征值。\n\n由于 $q_1$ 只是起始向量 $v_1$ 的单位化版本（即，$q_1$ 是 $v_1$ 乘以 $1/\\|v_1\\|_2$），如果 $q_1$ 是一个特征向量，那么 $v_1$ 也必须是 $A$ 的一个特征向量。具体来说，如果 $A q_1 = \\lambda q_1$，那么：\n$$\nA \\left(\\frac{v_1}{\\|v_1\\|_2}\\right) = \\lambda \\left(\\frac{v_1}{\\|v_1\\|_2}\\right)\n$$\n两边同时乘以标量 $\\|v_1\\|_2$ 得到：\n$$\nA v_1 = \\lambda v_1\n$$\n因此，问题简化为找出给定向量中哪一个是矩阵 $A$ 的特征向量。\n\n矩阵 $A$ 由其分量给出：\n$$\nA = \\begin{pmatrix} 1  0  1 \\\\ 1  1  1 \\\\ 1  1  -1 \\end{pmatrix}\n$$\n我们现在通过将矩阵 $A$ 乘以每个选项中的向量 $v_1$ 来测试每个选项，并检查结果向量是否为原始向量的标量倍。\n\nA. 对于 $v_1 = \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix}$：\n$$\nA v_1 = \\begin{pmatrix} 1  0  1 \\\\ 1  1  1 \\\\ 1  1  -1 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 1(1) + 0(1) + 1(1) \\\\ 1(1) + 1(1) + 1(1) \\\\ 1(1) + 1(1) - 1(1) \\end{pmatrix} = \\begin{pmatrix} 2 \\\\ 3 \\\\ 1 \\end{pmatrix}\n$$\n是否存在某个标量 $\\lambda$ 使得 $\\begin{pmatrix} 2 \\\\ 3 \\\\ 1 \\end{pmatrix} = \\lambda \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix}$？不存在，因为 $2/1 \\neq 3/1$。\n\nB. 对于 $v_1 = \\begin{pmatrix} 1 \\\\ 2 \\\\ 1 \\end{pmatrix}$：\n$$\nA v_1 = \\begin{pmatrix} 1  0  1 \\\\ 1  1  1 \\\\ 1  1  -1 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 2 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 1(1) + 0(2) + 1(1) \\\\ 1(1) + 1(2) + 1(1) \\\\ 1(1) + 1(2) - 1(1) \\end{pmatrix} = \\begin{pmatrix} 2 \\\\ 4 \\\\ 2 \\end{pmatrix}\n$$\n是否存在某个标量 $\\lambda$ 使得 $\\begin{pmatrix} 2 \\\\ 4 \\\\ 2 \\end{pmatrix} = \\lambda \\begin{pmatrix} 1 \\\\ 2 \\\\ 1 \\end{pmatrix}$？是的，如果我们令 $\\lambda=2$，我们有 $2 \\begin{pmatrix} 1 \\\\ 2 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 2 \\\\ 4 \\\\ 2 \\end{pmatrix}$。这个向量是 $A$ 的一个特征向量。\n\nC. 对于 $v_1 = \\begin{pmatrix} 1 \\\\ -1 \\\\ 0 \\end{pmatrix}$：\n$$\nA v_1 = \\begin{pmatrix} 1  0  1 \\\\ 1  1  1 \\\\ 1  1  -1 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ -1 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 1(1) + 0(-1) + 1(0) \\\\ 1(1) + 1(-1) + 1(0) \\\\ 1(1) + 1(-1) - 1(0) \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix}\n$$\n是否存在某个标量 $\\lambda$ 使得 $\\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix} = \\lambda \\begin{pmatrix} 1 \\\\ -1 \\\\ 0 \\end{pmatrix}$？不存在。例如，第二个分量是 $0 = \\lambda(-1)$，这意味着 $\\lambda=0$，但第一个分量是 $1 = \\lambda(1)$，这意味着 $\\lambda=1$。这是一个矛盾。\n\nD. 对于 $v_1 = \\begin{pmatrix} 0 \\\\ 1 \\\\ 1 \\end{pmatrix}$：\n$$\nA v_1 = \\begin{pmatrix} 1  0  1 \\\\ 1  1  1 \\\\ 1  1  -1 \\end{pmatrix} \\begin{pmatrix} 0 \\\\ 1 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 1(0) + 0(1) + 1(1) \\\\ 1(0) + 1(1) + 1(1) \\\\ 1(0) + 1(1) - 1(1) \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ 2 \\\\ 0 \\end{pmatrix}\n$$\n是否存在某个标量 $\\lambda$ 使得 $\\begin{pmatrix} 1 \\\\ 2 \\\\ 0 \\end{pmatrix} = \\lambda \\begin{pmatrix} 0 \\\\ 1 \\\\ 1 \\end{pmatrix}$？不存在。第一个分量要求 $1 = \\lambda(0)$，这是不可能的。\n\nE. 对于 $v_1 = \\begin{pmatrix} 1 \\\\ 0 \\\\ -1 \\end{pmatrix}$：\n$$\nA v_1 = \\begin{pmatrix} 1  0  1 \\\\ 1  1  1 \\\\ 1  1  -1 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\\\ -1 \\end{pmatrix} = \\begin{pmatrix} 1(1) + 0(0) + 1(-1) \\\\ 1(1) + 1(0) + 1(-1) \\\\ 1(1) + 1(0) - 1(-1) \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 2 \\end{pmatrix}\n$$\n是否存在某个标量 $\\lambda$ 使得 $\\begin{pmatrix} 0 \\\\ 0 \\\\ 2 \\end{pmatrix} = \\lambda \\begin{pmatrix} 1 \\\\ 0 \\\\ -1 \\end{pmatrix}$？不存在。第一个分量要求 $0 = \\lambda(1)$，这意味着 $\\lambda=0$。但第三个分量要求 $2 = \\lambda(-1)$，这意味着 $\\lambda=-2$。这是一个矛盾。\n\n只有选项B中的向量是 $A$ 的特征向量。因此，选择这个向量作为起始向量 $v_1$ 将导致Arnoldi迭代在第一步之后终止。",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "在数值计算的世界里，由于有限精度算术的存在，理论上的等价并不能保证实践中得到相同的结果。这个高级练习将您从纸笔计算带到计算机编程，要求您实现并比较 Arnoldi 迭代的两种变体：一种使用经典格拉姆-施密特（CGS）过程，另一种使用修正的格拉姆-施密特（MGS）过程。您将通过观察 MGS 更优越的数值稳定性，从经验上验证为何它在实际应用中更受青睐。",
            "id": "3206345",
            "problem": "要求您使用两种正交化策略实现阿诺德迭代：经典格拉姆-施密特（CGS）和修正格拉姆-施密特（MGS）。从给定方阵的克雷洛夫子空间的基本定义出发，阿诺德过程构建一个标准正交基和相应的上赫森伯格矩阵。您的目标是实现这两种变体，量化在有限精度算术中的正交性损失，并找出一个矩阵，在该矩阵上CGS因正交性损失而失败，而MGS成功。\n\n从以下基本概念开始：\n- 对于给定的矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 和非零向量 $b \\in \\mathbb{R}^{n}$，第 $k$ 个克雷洛夫子空间为 $K_k(A,b) = \\text{span}\\{b, Ab, A^2 b, \\dots, A^{k-1} b\\}$。\n- 阿诺德迭代为 $K_k(A,b)$ 构建一个标准正交基 $\\{q_1,\\dots,q_k\\}$ 和一个上赫森伯格矩阵 $H_{k+1,k}$，使得 $A Q_k = Q_{k+1} H_{k+1,k}$，其中 $Q_k = [q_1,\\dots,q_k]$ 且 $Q_{k+1} = [q_1,\\dots,q_{k+1}]$。$Q_k$ 的正交性对数值稳定性和准确性至关重要。\n\n需要实现和验证的任务：\n1. 实现两种阿诺德过程：\n   - 经典格拉姆-施密特（CGS）：在每个阿诺德步骤 $j$，计算 $v = A q_j$，然后在一个矩阵-向量步骤中计算系数向量 $h = Q_j^\\top v$，并更新 $v \\leftarrow v - Q_j h$。最后计算 $h_{j+1,j} = \\|v\\|_2$，如果非零，则设置 $q_{j+1} = v / h_{j+1,j}$。当 $h_{j+1,j} = 0$ 时检测到崩溃并停止。\n   - 修正格拉姆-施密特（MGS）：在每个阿诺德步骤 $j$，计算 $v = A q_j$，然后对于 $i = 1,\\dots,j$，依次计算 $h_{i,j} = q_i^\\top v$ 并更新 $v \\leftarrow v - h_{i,j} q_i$。最后计算 $h_{j+1,j} = \\|v\\|_2$ 并如上继续，同时进行崩溃检测。\n2. 对于每次运行，计算正交性误差\n   $$E_k = \\left\\| Q_k^\\top Q_k - I_k \\right\\|_F,$$\n   其中 $I_k$ 是大小为 $k$ 的单位矩阵，$\\|\\cdot\\|_F$ 表示弗罗贝尼乌斯范数。以浮点数形式报告 CGS 和 MGS 的 $E_k$。\n3. 如果发生崩溃，报告产生的有效克雷洛夫维度，记为 $k_{\\text{eff}}$，它等于在 $Q_k$ 中直到崩溃时（包括初始向量 $q_1$）实际构建的列数。\n\n您的程序必须运行以下测试套件。对于每个测试用例，按此顺序输出四个值 $(E_k^{\\text{CGS}}, E_k^{\\text{MGS}}, k_{\\text{eff}}^{\\text{CGS}}, k_{\\text{eff}}^{\\text{MGS}})$。按照下面的规定，将所有测试用例的结果聚合到一个扁平列表中作为最终输出。\n\n测试套件：\n- 测试用例 1（良态，理想情况）：\n  - 矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 是三对角托普利兹矩阵，其中 $A_{i,i} = -2$，$A_{i,i+1} = 1$，$A_{i+1,i} = 1$（对于 $i = 1,\\dots,n-1$），其余元素为零。使用 $n = 40$。\n  - 起始向量 $b \\in \\mathbb{R}^{n}$ 按分量定义为 $b_i = i$（对于 $i = 1,\\dots,n$），然后归一化为单位 $2$-范数。\n  - 阿诺德步数 $k = 20$。\n- 测试用例 2（非正规若尔当块，预计 CGS 会损失正交性，MGS 会成功）：\n  - 矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 是对角线为1、上对角线为1的若尔当块：$A_{i,i} = 1$，$A_{i,i+1} = 1$（对于 $i = 1,\\dots,n-1$），其余元素为零。使用 $n = 60$。\n  - 起始向量 $b = e_1 \\in \\mathbb{R}^{n}$，即第一个标准基向量。\n  - 阿诺德步数 $k = 40$。\n- 测试用例 3（崩溃边界情况）：\n  - 矩阵 $A = 2 I \\in \\mathbb{R}^{n \\times n}$，其中 $n = 20$，$I$ 是单位矩阵。\n  - 起始向量 $b \\in \\mathbb{R}^{n}$，其中 $b_i = 1$（对于 $i = 1,\\dots,n$），然后归一化为单位 $2$-范数。\n  - 阿诺德步数 $k = 5$。\n  - 在精确算术中，第一步之后就会发生崩溃，因为 $A q_1$ 与 $q_1$ 共线；您的实现必须检测到这一点并相应地报告有效维度。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按顺序包含所有测试用例的结果串联：$[E_k^{\\text{CGS}}, E_k^{\\text{MGS}}, k_{\\text{eff}}^{\\text{CGS}}, k_{\\text{eff}}^{\\text{MGS}}]$。\n- 因此，对于指定的三个测试用例，最终输出必须包含 $12$ 个条目：$[E_1^{\\text{CGS}}, E_1^{\\text{MGS}}, k_{1,\\text{eff}}^{\\text{CGS}}, k_{1,\\text{eff}}^{\\text{MGS}}, E_2^{\\text{CGS}}, E_2^{\\text{MGS}}, k_{2,\\text{eff}}^{\\text{CGS}}, k_{2,\\text{eff}}^{\\text{MGS}}, E_3^{\\text{CGS}}, E_3^{\\text{MGS}}, k_{3,\\text{eff}}^{\\text{CGS}}, k_{3,\\text{eff}}^{\\text{MGS}}]$。\n- 所有角度（如果出现）必须以弧度为单位。此问题中没有物理单位。所有报告的数字必须是实数或整数。不允许使用百分号；任何分数值请使用小数表示。",
            "solution": "当前任务要求实现并比较阿诺德迭代算法的两种变体，用于为克雷洛夫子空间构建标准正交基。这两种变体在正交化过程的选择上有所不同：经典格拉姆-施密特（CGS）过程和修正格拉姆-施密特（MGS）过程。目标是通过量化特定测试用例的正交性损失来分析它们的数值稳定性，其中包括一个旨在突显 MGS 在有限精度算术中优越稳定性的测试用例。\n\n### 阿诺德迭代与克雷洛夫子空间\n\n给定一个方阵 $A \\in \\mathbb{R}^{n \\times n}$ 和一个非零起始向量 $b \\in \\mathbb{R}^{n}$，第 $k$ 个克雷洛夫子空间，记为 $K_k(A, b)$，是由矩阵-向量乘积序列中的前 $k$ 个向量张成的向量空间：\n$$\nK_k(A, b) = \\text{span}\\{b, Ab, A^2b, \\dots, A^{k-1}b\\}\n$$\n阿诺德迭代是一种为该子空间生成标准正交基 $\\{q_1, q_2, \\dots, q_k\\}$ 的算法。该过程是迭代的。假设我们已经构建了一个标准正交集 $\\{q_1, \\dots, q_j\\}$，下一个向量 $q_{j+1}$ 是通过取向量 $A q_j$，使其与所有先前的基向量 $q_1, \\dots, q_j$ 正交，然后将其归一化得到的。\n\n此过程构建一个矩阵 $Q_k = [q_1, q_2, \\dots, q_k]$，其列构成标准正交基。它还生成一个上赫森伯格矩阵 $H_{k+1,k} \\in \\mathbb{R}^{(k+1) \\times k}$，满足基本的阿诺德关系：\n$$\nA Q_k = Q_{k+1} H_{k+1,k}\n$$\n这里，$Q_{k+1} = [Q_k, q_{k+1}]$，而 $H_{k+1,k}$ 的元素，记为 $h_{i,j}$，是正交化步骤中的系数。\n\n该算法的核心在于正交化步骤。在第 $j$ 步（对于 $j=1, \\dots, k$），我们计算 $v = A q_j$，然后将 $v$ 与现有基 $\\{q_1, \\dots, q_j\\}$ 进行正交化。\n\n### 正交化方法：CGS vs. MGS\n\n**1. 基于经典格拉姆-施密特（CGS）的阿诺德迭代：**\n在 CGS 变体中，向量 $v = A q_j$ 同时与所有先前的基向量 $\\{q_1, \\dots, q_j\\}$ 正交化。首先计算投影系数 $h_{i,j}$，然后在一个步骤中从 $v$ 中减去它们的组合投影。\n\n第 $j$ 步的流程是：\n1.  计算新的候选向量：$v = A q_j$。\n2.  计算所有投影系数：$h_{i,j} = q_i^\\top v$（对于 $i=1, \\dots, j$）。以矩阵形式表示，即为 $h_j = Q_j^\\top v$，其中 $h_j$ 是 $H_{k,k}$ 的第 $j$ 列。\n3.  计算正交向量：$w_j = v - \\sum_{i=1}^j h_{i,j} q_i$。以矩阵形式表示，$w_j = v - Q_j h_j$。\n4.  计算归一化因子：$h_{j+1,j} = \\|w_j\\|_2$。\n5.  归一化以获得下一个基向量：$q_{j+1} = w_j / h_{j+1,j}$。\n\n尽管在数学上是正确的，但 CGS 以其数值不稳定性而闻名。在计算 $h_{i,j}$ 和减法过程中的舍入误差可能导致计算出的 $w_j$ 与基 $\\{q_1, \\dots, q_j\\}$ 不完全正交，从而导致矩阵 $Q_k$ 的正交性迅速丧失。\n\n**2. 基于修正格拉姆-施密特（MGS）的阿诺德迭代：**\nMGS 变体通过重新排序正交化操作来解决 CGS 的不稳定性。它不是减去投影的总和，而是依次减去每个投影。\n\n第 $j$ 步的流程是：\n1.  初始化待正交化的向量：$v^{(0)} = A q_j$。\n2.  沿 $q_i$ 依次移除分量：对于 $i = 1, \\dots, j$：\n    a. 计算投影系数：$h_{i,j} = q_i^\\top v^{(i-1)}$。\n    b. 更新向量：$v^{(i)} = v^{(i-1)} - h_{i,j} q_i$。\n3.  最终的正交向量是 $w_j = v^{(j)}$。\n4.  计算归一化因子：$h_{j+1,j} = \\|w_j\\|_2$。\n5.  归一化以获得下一个基向量：$q_{j+1} = w_j / h_{j+1,j}$。\n\n这个顺序过程在数值上更稳健。通过在每个子步骤更新向量 $v$，MGS 更有效地减少了沿先前基向量的分量，从而减轻了舍入误差的累积。\n\n### 崩溃与误差测量\n\n**崩溃条件：**\n如果在第 $j$ 步，向量 $w_j$ 变为零（或在数值上，其范数 $h_{j+1,j}$ 小于给定容差），阿诺德迭代可能会提前终止。此事件称为崩溃。当向量 $A q_j$ 已包含在子空间 $K_j(A, b) = \\text{span}\\{q_1, \\dots, q_j\\}$ 中时，就会发生这种情况。这意味着克雷洛夫子空间是 $A$ 的一个不变子空间。在这种情况下，过程停止，构建的子空间的有效维度为 $k_{\\text{eff}} = j$。\n\n**正交性误差：**\n为了量化 CGS 和 MGS 的数值稳定性，我们测量生成的基矩阵 $Q_k$ 的正交性损失。一个完美的标准正交矩阵 $Q_k$ 满足 $Q_k^\\top Q_k = I_k$，其中 $I_k$ 是 $k \\times k$ 的单位矩阵。任何偏差都表示正交性的损失。我们使用差值的弗罗贝尼乌斯范数来测量此误差：\n$$\nE_k = \\| Q_k^\\top Q_k - I_k \\|_F\n$$\n较小的 $E_k$ 值表示更好的数值性能。如果在维度 $k_{\\text{eff}}$ 处发生崩溃，则为生成的矩阵 $Q_{k_{\\text{eff}}}$ 计算误差。\n\n提供的测试用例旨在验证实现并展示这些数值特性。测试用例 1 使用一个表现良好的对称矩阵，两种方法都应表现良好。测试用例 2 使用一个非正规的若尔当块，这是一个经典的例子，预期 CGS 的表现会比 MGS 差。测试用例 3 是一个旨在测试算法处理早期崩溃的简单情况。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef arnoldi_iteration(A, b, k_max, method='mgs'):\n    \"\"\"\n    Performs Arnoldi iteration to find an orthonormal basis of the Krylov subspace.\n\n    Args:\n        A (np.ndarray): The square matrix of size n x n.\n        b (np.ndarray): The starting vector of size n.\n        k_max (int): The number of Arnoldi steps to perform.\n        method (str): The orthogonalization method, 'cgs' or 'mgs'.\n\n    Returns:\n        tuple: A tuple containing:\n            - Q_k_eff (np.ndarray): Matrix with orthonormal columns spanning the\n              Krylov subspace of effective dimension k_eff.\n            - H (np.ndarray): The upper Hessenberg matrix.\n            - k_eff (int): The effective dimension of the Krylov subspace.\n    \"\"\"\n    n = A.shape[0]\n    # Use float64 for higher precision, crucial for observing stability differences\n    Q = np.zeros((n, k_max + 1), dtype=np.float64)\n    H = np.zeros((k_max + 1, k_max), dtype=np.float64)\n\n    # Normalize the starting vector b\n    b_norm = np.linalg.norm(b)\n    if b_norm == 0:\n        # If b is a zero vector, the subspace is trivial.\n        return Q[:, :1], H[:1, :0], 0\n    Q[:, 0] = b / b_norm\n\n    k_eff = k_max\n    # A small tolerance to detect numerical breakdown\n    breakdown_tol = 1e-12\n\n    for j in range(k_max):\n        # v = A * q_j\n        v = A @ Q[:, j]\n\n        if method == 'cgs':\n            # Classical Gram-Schmidt\n            # h = Q_j^T * v\n            h_col = Q[:, :j + 1].T @ v\n            H[:j + 1, j] = h_col\n            # v_ortho = v - Q_j * h\n            v_ortho = v - Q[:, :j + 1] @ h_col\n        elif method == 'mgs':\n            # Modified Gram-Schmidt\n            v_ortho = v.copy()\n            for i in range(j + 1):\n                # h_ij = q_i^T * v_ortho\n                h_ij = Q[:, i].T @ v_ortho\n                H[i, j] = h_ij\n                # v_ortho = v_ortho - h_ij * q_i\n                v_ortho -= h_ij * Q[:, i]\n        else:\n            raise ValueError(\"Method must be 'cgs' or 'mgs'\")\n\n        h_next = np.linalg.norm(v_ortho)\n        H[j + 1, j] = h_next\n\n        if h_next  breakdown_tol:\n            # Breakdown occurred, the subspace is invariant\n            k_eff = j + 1\n            break\n\n        # q_{j+1} = v_ortho / h_{j+1, j}\n        Q[:, j + 1] = v_ortho / h_next\n\n    # Truncate Q to the effective dimension\n    Q_k_eff = Q[:, :k_eff]\n\n    return Q_k_eff, H, k_eff\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases\n    test_cases = []\n\n    # Test case 1 (well-conditioned)\n    n1 = 40\n    k1 = 20\n    A1 = np.diag(-2 * np.ones(n1)) + np.diag(np.ones(n1 - 1), 1) + np.diag(np.ones(n1 - 1), -1)\n    b1 = np.arange(1, n1 + 1, dtype=np.float64)\n    b1 /= np.linalg.norm(b1)\n    test_cases.append({'A': A1, 'b': b1, 'k': k1})\n\n    # Test case 2 (non-normal Jordan block)\n    n2 = 60\n    k2 = 40\n    A2 = np.eye(n2) + np.diag(np.ones(n2 - 1), 1)\n    b2 = np.zeros(n2, dtype=np.float64)\n    b2[0] = 1.0\n    test_cases.append({'A': A2, 'b': b2, 'k': k2})\n    \n    # Test case 3 (breakdown)\n    n3 = 20\n    k3 = 5\n    A3 = 2 * np.eye(n3)\n    b3 = np.ones(n3, dtype=np.float64)\n    b3 /= np.linalg.norm(b3)\n    test_cases.append({'A': A3, 'b': b3, 'k': k3})\n\n    results = []\n    for case in test_cases:\n        A, b, k = case['A'], case['b'], case['k']\n        \n        # Run CGS\n        Q_cgs, _, k_eff_cgs = arnoldi_iteration(A, b, k, method='cgs')\n        I_cgs = np.eye(k_eff_cgs)\n        error_cgs = np.linalg.norm(Q_cgs.T @ Q_cgs - I_cgs, 'fro')\n        \n        # Run MGS\n        Q_mgs, _, k_eff_mgs = arnoldi_iteration(A, b, k, method='mgs')\n        I_mgs = np.eye(k_eff_mgs)\n        error_mgs = np.linalg.norm(Q_mgs.T @ Q_mgs - I_mgs, 'fro')\n\n        results.extend([error_cgs, error_mgs, k_eff_cgs, k_eff_mgs])\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}