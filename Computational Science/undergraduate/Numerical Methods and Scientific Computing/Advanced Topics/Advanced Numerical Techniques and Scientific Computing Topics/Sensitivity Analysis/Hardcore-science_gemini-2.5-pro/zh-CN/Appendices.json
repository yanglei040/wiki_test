{
    "hands_on_practices": [
        {
            "introduction": "敏感性分析通常从直接的数学方法入手。我们可以使用偏导数来精确衡量模型输出对其输入参数微小变化的响应程度。这项练习将敏感性这一抽象概念置于一个具体的计算之中，通过一个经典的微观经济学模型，展示了如何利用微积分为理解模型行为提供精确的洞察。",
            "id": "3191079",
            "problem": "一位计算经济学家正在建立一个简单的市场模型，以研究响应参数的估计值如何影响计算出的均衡价格。该模型使用线性的供给和需求函数，其中供给量和需求量取决于价格。设供给函数为 $Q_{s} = a + bP$，需求函数为 $Q_{d} = c - dP$，其中 $Q_{s}$ 和 $Q_{d}$ 是数量，$P$ 是价格，$a$、$b$、$c$、$d$ 是严格为正的参数，分别代表基准水平（$a$、$c$）和响应系数（$b$、$d$）。假设 $c > a$，以确保市场出清价格为正。\n\n从市场均衡（供给量等于需求量）和灵敏度分析（模型输出相对于其参数的变化，通过偏导数定义）的定义出发，推导出均衡价格 $P^{*}$ 作为 $a$、$b$、$c$ 和 $d$ 的函数。然后，从第一性原理出发，通过计算精确的偏导数 $\\frac{\\partial P^{*}}{\\partial b}$ 和 $\\frac{\\partial P^{*}}{\\partial d}$，来量化 $P^{*}$ 对响应系数 $b$ 和 $d$ 的灵敏度。\n\n将您的最终答案表示为以 $a$、$b$、$c$ 和 $d$ 表示的两个闭式解析表达式。无需四舍五入，最终表达式中不应包含任何单位。",
            "solution": "问题陈述将首先经过一个严格的验证过程。\n\n### 步骤1：提取已知条件\n问题陈述中提供的明确信息如下：\n- 供给函数：$Q_{s} = a + bP$\n- 需求函数：$Q_{d} = c - dP$\n- 变量：$Q_s$（供给量）、$Q_d$（需求量）、$P$（价格）。\n- 参数：$a, b, c, d$ 均为严格为正的实数。\n- 参数解释：$a, c$ 是基准水平；$b, d$ 是响应系数。\n- 约束条件：$c > a$。\n- 市场均衡的定义：$Q_s = Q_d$。\n- 灵敏度分析的定义：通过模型输出对其参数的偏导数来量化。\n- 目标：\n    1. 推导均衡价格 $P^*$，作为 $a, b, c, d$ 的函数。\n    2. 计算灵敏度 $\\frac{\\partial P^{*}}{\\partial b}$ 和 $\\frac{\\partial P^{*}}{\\partial d}$。\n\n### 步骤2：使用提取的已知条件进行验证\n该问题根据既定标准进行评估：\n- **科学依据：** 该问题使用了标准的线性供给-需求模型，这是微观经济学理论的基石，也是计算建模中的一个常见例子。市场均衡和灵敏度分析的概念是基本且公认的原则。该设置在科学上是合理的。\n- **适定性：** 该问题提供了确定唯一解所需的所有方程和约束。条件 $b > 0$ 和 $d > 0$ 确保供给曲线具有正斜率，需求曲线具有负斜率，这是标准情况。和 $b + d$ 将出现在价格表达式的分母中；由于两者都严格为正，它们的和不为零，从而避免了除以零的情况。条件 $c > a$ 确保得出的均衡价格 $P^*$ 为正，这在这种背景下具有实际意义。因此，存在一个唯一的、稳定的且有意义的解。\n- **客观性：** 该问题使用精确且无歧义的数学和经济学语言进行陈述。没有主观断言或意见。\n\n### 步骤3：结论与行动\n该问题在科学上是合理的、适定的、客观的和完整的。这是一个需要进行形式推导的有效问题。我们可以继续进行求解。\n\n### 解题推导\n目标是找到均衡价格 $P^*$，然后计算其相对于参数 $b$ 和 $d$ 的灵敏度。\n\n首先，我们确定均衡价格 $P^*$。当供给量等于需求量时，即 $Q_s = Q_d$，市场达到均衡。我们代入给定的供给和需求函数形式：\n$$a + bP = c - dP$$\n为了求解价格 $P$，我们重新整理方程以分离出 $P$。我们将所有包含 $P$ 的项移到方程的一边，将常数项移到另一边。\n$$bP + dP = c - a$$\n从左侧提取 $P$ 得到：\n$$P(b + d) = c - a$$\n然后通过除以项 $(b+d)$ 来求得均衡价格 $P^*$。由于 $b > 0$ 且 $d > 0$，可以保证 $b+d > 0$，因此这个除法是良定义的。\n$$P^{*} = \\frac{c - a}{b + d}$$\n问题规定 $c > a$，这确保了分子 $c - a$ 为正。分母 $b+d$ 也为正。因此，均衡价格 $P^*$ 严格为正，这与经济现实相符。\n\n接下来，我们量化均衡价格 $P^*$ 对响应系数 $b$ 和 $d$ 的灵敏度。这通过计算 $P^*$ 对这些参数中每一个的偏导数来完成。\n\n为了计算 $P^*$ 对 $b$ 的偏导数，记为 $\\frac{\\partial P^{*}}{\\partial b}$，我们将 $a$、$c$ 和 $d$ 视为常数。我们对 $P^*$ 的表达式应用微分的商法则：\n$$\\frac{\\partial P^{*}}{\\partial b} = \\frac{\\partial}{\\partial b} \\left( \\frac{c - a}{b + d} \\right)$$\n商法则指出，对于函数 $f(x) = \\frac{u(x)}{v(x)}$，其导数为 $f'(x) = \\frac{u'(x)v(x) - u(x)v'(x)}{[v(x)]^2}$。在我们的例子中，变量是 $b$，分子是 $u(b) = c - a$，分母是 $v(b) = b + d$。\n$u$ 和 $v$ 对 $b$ 的导数是：\n$$\\frac{\\partial u}{\\partial b} = \\frac{\\partial}{\\partial b}(c - a) = 0$$\n$$\\frac{\\partial v}{\\partial b} = \\frac{\\partial}{\\partial b}(b + d) = 1$$\n将这些代入商法则公式：\n$$\\frac{\\partial P^{*}}{\\partial b} = \\frac{(0)(b + d) - (c - a)(1)}{(b + d)^2}$$\n这可以简化为：\n$$\\frac{\\partial P^{*}}{\\partial b} = -\\frac{c - a}{(b + d)^2}$$\n\n类似地，为了计算 $P^*$ 对 $d$ 的偏导数，记为 $\\frac{\\partial P^{*}}{\\partial d}$，我们将 $a$、$b$ 和 $c$ 视为常数。我们再次对 $P^*$ 的表达式应用商法则：\n$$\\frac{\\partial P^{*}}{\\partial d} = \\frac{\\partial}{\\partial d} \\left( \\frac{c - a}{b + d} \\right)$$\n这里，变量是 $d$，分子是 $u(d) = c - a$，分母是 $v(d) = b + d$。\n$u$ 和 $v$ 对 $d$ 的导数是：\n$$\\frac{\\partial u}{\\partial d} = \\frac{\\partial}{\\partial d}(c - a) = 0$$\n$$\\frac{\\partial v}{\\partial d} = \\frac{\\partial}{\\partial d}(b + d) = 1$$\n将这些代入商法则公式：\n$$\\frac{\\partial P^{*}}{\\partial d} = \\frac{(0)(b + d) - (c - a)(1)}{(b + d)^2}$$\n这可以简化为：\n$$\\frac{\\partial P^{*}}{\\partial d} = -\\frac{c - a}{(b + d)^2}$$\n\n因此，这两个灵敏度是相同的。两个导数都为负，这符合预期。供给响应度（$b$）或需求响应度（$d$）的增加都会导致均衡价格下降，因为一个更具弹性的市场对价格变化的反应更强烈，从而拉低了均衡价格。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n-\\frac{c-a}{(b+d)^{2}}  -\\frac{c-a}{(b+d)^{2}}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "超越解析公式，敏感性分析是理解算法和离散优化问题的强大工具。在这里，敏感性不是通过微分来评估，而是通过系统地扰动一个输入（一个物品的重量），并观察其对背包问题最优解造成的影响。这项练习突显了“假设”分析的广泛适用性，要求你实现一个动态规划求解器，以计算方式衡量输入变化对离散结果的影响。",
            "id": "3272426",
            "problem": "您将处理经典的0-1背包优化问题，并需要对动态规划解中单个物品重量的变化进行离散灵敏度分析。背包问题可表述如下：给定物品重量 $w_j \\in \\mathbb{Z}_{\\ge 1}$、物品价值 $v_j \\in \\mathbb{Z}_{\\ge 0}$（其中 $j \\in \\{0,1,\\dots,n-1\\}$）以及背包容量 $C \\in \\mathbb{Z}_{\\ge 0}$，选择决策变量 $x_j \\in \\{0,1\\}$ 以在满足容量约束的前提下最大化总价值。本任务的目标是量化当单个物品的重量发生整数扰动时，最优值如何变化。\n\n基本原理：使用源自0-1背包问题定义的、用于动态规划的Bellman最优性原理。从“在一组物品和剩余容量下的最优值等于在可行时，不放入或放入当前物品两者之间的最优选择”这一定义出发。您不得假定任何封闭形式的捷径。\n\n灵敏度定义：对于一个固定的测试实例，令 $V^\\star$ 表示原始实例的最优目标值。固定一个目标物品索引 $i \\in \\{0,1,\\dots,n-1\\}$ 和一个整数扰动 $d$。通过仅改变物品 $i$ 的重量，从 $w_i$ 变为 $\\tilde{w}_i(d) = \\max(1, w_i + d)$，同时保持所有其他数据不变，来构成扰动实例。令 $V^\\star(d)$ 为扰动实例的最优值。对于扰动 $d$ 的离散灵敏度为 $S(d) = V^\\star(d) - V^\\star$。\n\n边界情况处理要求：如果 $w_i + d \\le 0$，您必须将扰动后的重量限定为 $\\tilde{w}_i(d) = 1$，以确保问题在非负整数容量上是良定义的。所有输入均使用整数重量、价值和容量。\n\n算法要求：实现一个0-1背包问题的动态规划求解器，该求解器需忠实于最优性原理，并使用整数算术。不要使用近似方案或贪心启发式算法。您可以实现一维或二维的动态规划数组，只要它能在 $O(nC)$ 时间内正确计算出精确的最优值即可。\n\n输出要求：对于每个测试用例，计算基准最优值 $V^\\star$，然后按给定顺序计算每个指定扰动 $d$ 的离散灵敏度 $S(d)$。将所有测试用例的结果汇总到一个扁平的整数列表中，顺序如下文所述。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，“[1,2,3]”）。\n\n角度单位：不适用。\n\n物理单位：不适用。\n\n百分比：不适用。\n\n需实现和评估的测试套件：\n- 测试用例1：重量 $w = [3,4,5]$，价值 $v = [30,50,60]$，容量 $C = 8$，扰动物品索引 $i = 2$（从零开始），扰动量 $D = [1,-1,3,-2]$。此测试用例的输出应为基准值 $V^\\star$，其后依次是 $S(1)$、$S(-1)$、$S(3)$、$S(-2)$。\n- 测试用例2：重量 $w = [5,5,5]$，价值 $v = [10,40,30]$，容量 $C = 5$，扰动物品索引 $i = 1$，扰动量 $D = [1,-1,-5,5]$。此测试用例的输出应为基准值 $V^\\star$，其后依次是 $S(1)$、$S(-1)$、$S(-5)$、$S(5)$。\n- 测试用例3：重量 $w = [2,2,3]$，价值 $v = [3,7,9]$，容量 $C = 3$，扰动物品索引 $i = 0$，扰动量 $D = [-1,1,3,-2]$。此测试用例的输出应为基准值 $V^\\star$，其后依次是 $S(-1)$、$S(1)$、$S(3)$、$S(-2)$。\n- 测试用例4：重量 $w = [1,2,2,3]$，价值 $v = [2,4,4,6]$，容量 $C = 4$，扰动物品索引 $i = 3$，扰动量 $D = [1,-1,100,-2]$。此测试用例的输出应为基准值 $V^\\star$，其后依次是 $S(1)$、$S(-1)$、$S(100)$、$S(-2)$。\n- 测试用例5：重量 $w = [4,6,5,3]$，价值 $v = [7,12,10,6]$，容量 $C = 10$，扰动物品索引 $i = 1$，扰动量 $D = [-1,1,-3,4]$。此测试用例的输出应为基准值 $V^\\star$，其后依次是 $S(-1)$、$S(1)$、$S(-3)$、$S(4)$。\n\n最终输出格式：您的程序必须打印单行文本，该文本是一个包含 $25$ 个整数的扁平列表，对应于每个测试用例的五个数字，并按照上述测试用例的顺序连接，用方括号括起来，并用逗号分隔，无空格。",
            "solution": "该问题要求对0-1背包问题的最优值执行离散灵敏度分析。此分析涉及扰动单个物品的重量，并计算最大可实现价值因此发生的变化。解决方案必须遵循Bellman最优性原理，使用动态规划从第一性原理推导得出。\n\n### 1. 0-1背包问题的动态规划公式\n\n0-1背包问题是一个经典的组合优化问题。给定一组 $n$ 个物品，索引为 $j \\in \\{0, 1, \\dots, n-1\\}$，每个物品都有一个重量 $w_j \\in \\mathbb{Z}_{\\ge 1}$ 和一个价值 $v_j \\in \\mathbb{Z}_{\\ge 0}$，以及一个容量为 $C \\in \\mathbb{Z}_{\\ge 0}$ 的背包，目标是选择一个物品子集，使其总价值最大化，同时不超过容量 $C$。\n\n令 $dp(k, c)$ 表示使用前 $k$ 个物品（即索引从 $0$ 到 $k-1$ 的物品）在总容量为 $c$ 的情况下可以获得的最大价值。根据Bellman最优性原理，最优解可以由子问题的最优解构造而成。对于物品 $k-1$，我们有两个选择：\n\n1.  **不放入物品 $k-1$**：最大价值由前 $k-1$ 个物品在相同容量 $c$ 下的最优解决定。这由 $dp(k-1, c)$ 给出。\n2.  **放入物品 $k-1$**：仅当其重量 $w_{k-1}$ 小于或等于当前容量 $c$ 时，此操作才可行。如果放入，它会贡献其价值 $v_{k-1}$，而剩余的容量 $c - w_{k-1}$ 必须用前 $k-1$ 个物品最优地填充。此选择的价值为 $v_{k-1} + dp(k-1, c - w_{k-1})$。\n\n最优值 $dp(k, c)$ 是这两个选择中的最大值。这产生了以下递推关系：\n$$\ndp(k, c) = \\begin{cases}\n    dp(k-1, c)  \\text{if } w_{k-1} > c \\\\\n    \\max(dp(k-1, c), v_{k-1} + dp(k-1, c - w_{k-1}))  \\text{if } w_{k-1} \\le c\n\\end{cases}\n$$\n对于 $k = 1, \\dots, n$ 和 $c = 1, \\dots, C$。基本情况是对于所有的 $c$，$dp(0, c) = 0$，因为没有物品时价值为零。整个问题的最终最优值是 $dp(n, C)$。\n\n这个二维递推关系可以优化为使用一个大小为 $C+1$ 的一维数组，我们称之为 $DP$。$DP[c]$ 将存储容量为 $c$ 时的最大价值。对于每个物品 $j \\in \\{0, 1, \\dots, n-1\\}$，我们更新这个数组。为确保每个物品最多被考虑一次（即“0-1”属性），容量循环必须从 $C$ 向下迭代到 $w_j$。物品 $j$ 的更新规则是：\n$$ \\text{对于 } c \\text{ 从 } C \\text{ 向下到 } w_j, \\quad DP[c] \\leftarrow \\max(DP[c], v_j + DP[c - w_j]) $$\n在遍历所有物品后，$DP[C]$ 将包含问题的最优值。这种方法的时间复杂度为 $O(nC)$。\n\n### 2. 灵敏度分析算法\n\n任务的核心是分析最优值对单个物品重量变化的灵敏度。设 $V^\\star$ 为给定基准实例 $(w, v, C)$ 的最优值。我们需要计算灵敏度 $S(d) = V^\\star(d) - V^\\star$，其中 $V^\\star(d)$ 是扰动实例的最优值。\n\n扰动实例是通过将特定物品 $i$ 的重量从 $w_i$ 更改为 $\\tilde{w}_i(d) = w_i + d$ 来创建的。一个关键约束是重量必须是正整数，因此扰动后的重量定义为 $\\tilde{w}_i(d) = \\max(1, w_i + d)$。\n\n每个测试用例的总体流程如下：\n\n1.  **定义背包求解器**：基于上述一维动态规划算法，实现一个函数 `solve_knapsack(weights, values, capacity)`。该函数将接受一组重量、价值和容量，并返回可实现的最大价值。\n\n2.  **处理测试用例**：对于每个给定的测试用例，包括重量 $w$、价值 $v$、容量 $C$、目标物品索引 $i$ 以及扰动列表 $D$：\n    a. **计算基准值**：通过在原始输入上调用求解器来计算基准最优值：$V^\\star = \\text{solve\\_knapsack}(w, v, C)$。\n    b. **遍历扰动量**：对于列表 $D$ 中的每个扰动量 $d$：\n        i. 创建一个新的重量列表 $\\tilde{w}$，方法是复制原始重量 $w$。\n        ii. 计算物品 $i$ 的新重量：$\\tilde{w}_i = \\max(1, w_i + d)$。在列表 $\\tilde{w}$ 中更新此重量。\n        iii. 计算扰动后的最优值：$V^\\star(d) = \\text{solve\\_knapsack}(\\tilde{w}, v, C)$。\n        iv. 计算灵敏度：$S(d) = V^\\star(d) - V^\\star$。\n    c. **收集结果**：存储当前测试用例的 $V^\\star$ 和计算出的灵敏度序列 $S(d)$。\n\n3.  **汇总与格式化**：将所有测试用例的结果连接成一个单一的扁平列表。最终输出是这个列表，格式化为用方括号括起来的逗号分隔字符串。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to perform sensitivity analysis on the knapsack problem\n    for a suite of test cases.\n    \"\"\"\n\n    def knapsack_solver(weights, values, capacity):\n        \"\"\"\n        Solves the zero-one knapsack problem using dynamic programming.\n\n        Args:\n            weights (list[int]): A list of item weights.\n            values (list[int]): A list of item values.\n            capacity (int): The knapsack capacity.\n\n        Returns:\n            int: The maximum value that can be achieved.\n        \"\"\"\n        num_items = len(weights)\n        # DP table stores the max value for each capacity from 0 to C.\n        dp_table = np.zeros(capacity + 1, dtype=np.int64)\n\n        for i in range(num_items):\n            weight = weights[i]\n            value = values[i]\n            # Iterate backwards to ensure each item is used at most once.\n            for c in range(capacity, weight - 1, -1):\n                dp_table[c] = max(dp_table[c], value + dp_table[c - weight])\n\n        return int(dp_table[capacity])\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (weights, values, capacity, item_index_to_perturb, perturbations)\n        ([3, 4, 5], [30, 50, 60], 8, 2, [1, -1, 3, -2]),\n        ([5, 5, 5], [10, 40, 30], 5, 1, [1, -1, -5, 5]),\n        ([2, 2, 3], [3, 7, 9], 3, 0, [-1, 1, 3, -2]),\n        ([1, 2, 2, 3], [2, 4, 4, 6], 4, 3, [1, -1, 100, -2]),\n        ([4, 6, 5, 3], [7, 12, 10, 6], 10, 1, [-1, 1, -3, 4]),\n    ]\n\n    all_results = []\n\n    for w_orig, v_orig, C, i, D in test_cases:\n        case_results = []\n\n        # 1. Calculate the baseline optimal value\n        baseline_optimal_value = knapsack_solver(w_orig, v_orig, C)\n        case_results.append(baseline_optimal_value)\n\n        # 2. Calculate sensitivities for each perturbation\n        for d in D:\n            w_perturbed = list(w_orig)\n            \n            # Apply perturbation and clamp the weight to be at least 1\n            perturbed_weight = max(1, w_orig[i] + d)\n            w_perturbed[i] = perturbed_weight\n            \n            # Calculate perturbed optimal value\n            perturbed_optimal_value = knapsack_solver(w_perturbed, v_orig, C)\n\n            # Calculate and store the sensitivity\n            sensitivity = perturbed_optimal_value - baseline_optimal_value\n            case_results.append(sensitivity)\n\n        all_results.extend(case_results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "敏感性分析在图像处理等领域有着至关重要的应用，在这些领域，模型参数会极大地影响视觉结果。这项练习展示了如何通过将微积分与快速傅里叶变换等数值方法相结合，来量化一个复杂的高维输出（一幅模糊图像）对于一个连续参数（高斯滤波器的 $\\sigma$）的敏感性。通过实施这一分析，你将在一个现代计算科学问题中获得应用敏感性概念的实践经验，从而弥合理论导数与大规模实际计算之间的差距。",
            "id": "3272432",
            "problem": "考虑一个二维离散图像，表示为实值数组 $I \\in \\mathbb{R}^{n \\times n}$，其中 $n = 16$。标准差为 $\\sigma > 0$ 的高斯模糊定义为图像 $I$ 与一个二维可分离高斯核 $K_{\\sigma}$ 的卷积，该核由一维高斯函数 $g(x;\\sigma)$ 沿每个轴构建。一维高斯函数由以下基本定义给出：\n$$\ng(x;\\sigma) = \\frac{1}{\\sqrt{2\\pi}\\,\\sigma}\\exp\\!\\left(-\\frac{x^{2}}{2\\sigma^{2}}\\right),\n$$\n而有限模板上的二维核为 $K_{\\sigma}(x,y) = g(x;\\sigma)\\,g(y;\\sigma)$，它在整数网格点 $(x,y) \\in \\{-R,\\ldots,R\\} \\times \\{-R,\\ldots,R\\}$ 上求值，其中 $R = 7$ 是用于数值近似的固定模板半宽。当 $R$ 相对于 $\\sigma$ 足够大时，这种有限支撑近似在科学上是合理的，并且在此处它被固定下来，以保证所有测试用例的可复现性。\n\n对于离散图像，卷积通过二维离散傅里叶变换 (DFT) 执行，这对应于周期性边界条件下的卷积（循环卷积）。具体来说，模糊后的图像 $B_{\\sigma}$ 由下式给出：\n$$\nB_{\\sigma} = \\mathcal{F}^{-1}\\!\\left(\\mathcal{F}(I)\\,\\odot\\,\\mathcal{F}(K_{\\sigma}^{\\mathrm{pad}})\\right),\n$$\n其中 $\\mathcal{F}$ 表示 DFT，$\\mathcal{F}^{-1}$ 表示其逆变换，$\\odot$ 表示逐点乘法，而 $K_{\\sigma}^{\\mathrm{pad}}$ 是将核 $K_{\\sigma}$ 零填充至图像大小 $n \\times n$ 并进行循环移位，使其中心与 DFT 域中零移位的位置对齐后的结果。\n\n将高斯模糊后的图像对 $\\sigma$ 的灵敏度定义为以下比率：\n$$\nS(I,\\sigma) = \\frac{\\left\\lVert \\frac{\\partial B_{\\sigma}}{\\partial \\sigma} \\right\\rVert_{F}}{\\left\\lVert B_{\\sigma} \\right\\rVert_{F}},\n$$\n其中 $\\lVert\\cdot\\rVert_{F}$ 表示 Frobenius 范数。如果 $\\lVert B_{\\sigma} \\rVert_{F} = 0$，则按照惯例定义 $S(I,\\sigma) = 0$ 以避免除零。利用乘积结构 $K_{\\sigma}(x,y) = g(x;\\sigma)g(y;\\sigma)$ 以及微分和卷积的线性性质，该灵敏度可以通过将 $I$ 与 $\\frac{\\partial K_{\\sigma}}{\\partial \\sigma}$ 进行卷积来计算，而后者本身是通过一维高斯函数关于 $\\sigma$ 的导数得到的：\n$$\n\\frac{\\partial g(x;\\sigma)}{\\partial \\sigma} = g(x;\\sigma)\\left(\\frac{x^{2}}{\\sigma^{3}} - \\frac{1}{\\sigma}\\right),\n$$\n然后对可分离的二维核应用乘法法则。\n\n您的任务是实现一个程序，该程序能够：\n- 对于每个给定的 $\\sigma$，在大小为 $(2R+1)\\times(2R+1)$（其中 $R=7$）的有限模板上构建 $K_{\\sigma}$ 和 $\\frac{\\partial K_{\\sigma}}{\\partial \\sigma}$。\n- 使用 DFT 执行循环卷积，以获得 $B_{\\sigma}$ 和 $\\frac{\\partial B_{\\sigma}}{\\partial \\sigma}$。\n- 对于每个测试用例，使用 Frobenius 范数计算 $S(I,\\sigma)$。\n\n使用以下图像和参数的测试套件：\n- 用例 1：$I$ 是一个脉冲图像，其中 $I_{8,8} = 1$，所有其他元素均为 $0$，$\\sigma = 1.0$。\n- 用例 2：$I$ 是一个斜坡图像，定义为 $I_{i,j} = \\frac{i + j}{30}$，其中索引 $i,j \\in \\{0,\\ldots,15\\}$，$\\sigma = 0.5$。\n- 用例 3：$I$ 是一个常数图像，其中对于所有的 $i,j$，都有 $I_{i,j} = 1$，$\\sigma = 2.0$。\n- 用例 4：$I$ 是一个棋盘格图像，定义为 $I_{i,j} = (-1)^{i+j}$，$\\sigma = 3.0$。\n- 用例 5：$I$ 是一个随机图像，由种子为 $0$ 的伪随机数生成器生成，其元素独立地从 $[0,1]$ 上的均匀分布中抽取，$\\sigma = 0.1$。\n\n所有图像的大小均为 $16 \\times 16$。不使用角度。不涉及物理单位。每个用例的输出必须是代表 $S(I,\\sigma)$ 的一个实数。\n\n您的程序应生成单行输出，其中包含以逗号分隔的列表形式的结果，并用方括号括起来（例如 $[s_{1},s_{2},s_{3},s_{4},s_{5}]$）。每个 $s_{k}$ 都必须是浮点数。为了便于阅读，您可以将每个数字格式化为六位小数。",
            "solution": "该问题是有效的。它提出了一个应用于图像处理领域的、明确定义的数值灵敏度分析任务。所有概念，包括高斯模糊、通过离散傅里叶变换 (DFT) 实现的卷积以及灵敏度的定义，在科学和数学上都是合理的。该问题是自包含的，提供了所有必需的参数、公式和测试用例，以得到一个唯一的、可验证的解。\n\n目标是计算高斯模糊后的图像 $B_{\\sigma}$ 关于高斯标准差 $\\sigma$ 的灵敏度 $S(I, \\sigma)$。灵敏度定义为模糊后图像关于 $\\sigma$ 的导数的 Frobenius 范数与模糊后图像本身的 Frobenius 范数的比值：\n$$\nS(I,\\sigma) = \\frac{\\left\\lVert \\frac{\\partial B_{\\sigma}}{\\partial \\sigma} \\right\\rVert_{F}}{\\left\\lVert B_{\\sigma} \\right\\rVert_{F}}\n$$\n其中 $\\lVert\\cdot\\rVert_{F}$ 表示 Frobenius 范数。对于一个矩阵 $A \\in \\mathbb{R}^{n \\times n}$，其 Frobenius 范数为 $\\lVert A \\rVert_{F} = \\sqrt{\\sum_{i=0}^{n-1} \\sum_{j=0}^{n-1} |A_{ij}|^2}$。按照惯例，如果分母为零，则 $S(I,\\sigma) = 0$。\n\n对于每个测试用例，计算过程分为几个步骤，每个用例都将一个输入图像 $I \\in \\mathbb{R}^{n \\times n}$（其中 $n=16$）与一个参数 $\\sigma$ 配对。\n\n首先，我们构建所需的卷积核。模糊操作通过一个定义在离散模板上的可分离二维高斯核 $K_{\\sigma}$ 执行。该核由一维高斯函数构建：\n$$\ng(x;\\sigma) = \\frac{1}{\\sqrt{2\\pi}\\,\\sigma}\\exp\\!\\left(-\\frac{x^{2}}{2\\sigma^{2}}\\right)\n$$\n问题指定了一个半宽为 $R=7$ 的有限模板，因此离散坐标为 $x, y \\in \\{-7, -6, \\ldots, 6, 7\\}$。二维核是在这些坐标上求值的一维函数的外积：$K_{\\sigma}(x,y) = g(x;\\sigma)g(y;\\sigma)$。\n\n为了计算灵敏度表达式的分子，我们需要模糊后图像的导数 $\\frac{\\partial B_{\\sigma}}{\\partial \\sigma}$。由于卷积和微分的线性性质，这等价于将原始图像 $I$ 与核的导数 $\\frac{\\partial K_{\\sigma}}{\\partial \\sigma}$ 进行卷积。我们首先求出一维高斯函数关于 $\\sigma$ 的导数：\n$$\n\\frac{\\partial g(x;\\sigma)}{\\partial \\sigma} = g(x;\\sigma)\\left(\\frac{x^{2}}{\\sigma^{3}} - \\frac{1}{\\sigma}\\right)\n$$\n对可分离的二维核 $K_{\\sigma}(x,y) = g(x;\\sigma)g(y;\\sigma)$ 使用微分的乘法法则，我们得到其导数：\n$$\n\\frac{\\partial K_{\\sigma}(x,y)}{\\partial \\sigma} = \\frac{\\partial g(x;\\sigma)}{\\partial \\sigma} g(y;\\sigma) + g(x;\\sigma) \\frac{\\partial g(y;\\sigma)}{\\partial \\sigma}\n$$\n$K_{\\sigma}$ 和 $\\frac{\\partial K_{\\sigma}}{\\partial \\sigma}$ 都被构建为 $(2R+1) \\times (2R+1) = 15 \\times 15$ 的矩阵。\n\n其次，我们使用离散傅里叶变换 (DFT) 执行卷积。卷积定理指出，空间域中的卷积等价于频率域中的逐点乘法。因此，模糊后的图像 $B_{\\sigma}$ 及其导数 $\\frac{\\partial B_{\\sigma}}{\\partial \\sigma}$ 可按如下方式计算：\n$$\nB_{\\sigma} = \\mathcal{F}^{-1}\\!\\left(\\mathcal{F}(I)\\,\\odot\\,\\mathcal{F}(K_{\\sigma}^{\\mathrm{pad}})\\right)\n$$\n$$\n\\frac{\\partial B_{\\sigma}}{\\partial \\sigma} = I * \\frac{\\partial K_{\\sigma}}{\\partial \\sigma} = \\mathcal{F}^{-1}\\!\\left(\\mathcal{F}(I)\\,\\odot\\,\\mathcal{F}\\left(\\left[\\frac{\\partial K_{\\sigma}}{\\partial \\sigma}\\right]^{\\mathrm{pad}}\\right)\\right)\n$$\n此处，$\\mathcal{F}$ 和 $\\mathcal{F}^{-1}$ 分别表示二维 DFT 及其逆变换，而 $\\odot$ 是逐点乘法。该操作要求将核填充以匹配图像大小 $n \\times n = 16 \\times 16$。符号 $K^{\\mathrm{pad}}$ 表示将 $15 \\times 15$ 的核放置在一个 $16 \\times 16$ 的零数组中，并进行循环移位。该移位将核的概念中心（在模板上的坐标 $(0,0)$）与 DFT 域中的零频分量对齐，后者对应于数组的索引 $(0,0)$。这是通过 DFT 实现卷积的标准流程。\n\n总体算法如下：\n1.  对于每个测试用例，生成 $16 \\times 16$ 的图像矩阵 $I$ 并设置对应的 $\\sigma$ 值。\n2.  定义从 $x=-7$ 到 $x=7$ 的一维模板坐标。\n3.  为模板上的所有点计算一维高斯函数 $g(x;\\sigma)$ 及其导数 $\\frac{\\partial g(x;\\sigma)}{\\partial \\sigma}$ 的值。\n4.  使用一维数组的外积构建二维 $15 \\times 15$ 核 $K_{\\sigma}$ 和 $\\frac{\\partial K_{\\sigma}}{\\partial \\sigma}$。\n5.  创建这些核的大小为 $16 \\times 16$ 的填充和移位版本，$K_{\\sigma}^{\\mathrm{pad}}$ 和 $[\\frac{\\partial K_{\\sigma}}{\\partial \\sigma}]^{\\mathrm{pad}}$。\n6.  计算图像 $I$ 和两个填充后核的二维 DFT。\n7.  在频域中执行逐点乘法，以获得 $B_{\\sigma}$ 和 $\\frac{\\partial B_{\\sigma}}{\\partial \\sigma}$ 的频谱。\n8.  计算这些频谱的二维逆 DFT，以获得空间域矩阵 $B_{\\sigma}$ 和 $\\frac{\\partial B_{\\sigma}}{\\partial \\sigma}$。取结果的实部以舍弃由数值不精确性产生的可忽略的虚部。\n9.  计算 Frobenius 范数 $\\left\\lVert B_{\\sigma} \\right\\rVert_{F}$ 和 $\\left\\lVert \\frac{\\partial B_{\\sigma}}{\\partial \\sigma} \\right\\rVert_{F}$。\n10. 将它们的比值计算为灵敏度 $S(I,\\sigma)$，并处理分母为零的情况。\n11. 整理所有测试用例的结果，并转换为最终输出格式。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the sensitivity of a Gaussian-blurred image to the blur parameter sigma.\n    \"\"\"\n\n    def calculate_sensitivity(I, sigma, n, R):\n        \"\"\"\n        Calculates S(I, sigma) for a given image I and parameter sigma.\n        \n        Args:\n            I (np.ndarray): The input image (n x n).\n            sigma (float): The standard deviation of the Gaussian blur.\n            n (int): The dimension of the image.\n            R (int): The half-width of the kernel stencil.\n\n        Returns:\n            float: The computed sensitivity.\n        \"\"\"\n        # 1. Construct Kernels\n        k_size = 2 * R + 1\n        x_coords = np.arange(-R, R + 1, dtype=float)\n        \n        # 1D Gaussian function\n        # Check for sigma being very small to avoid overflow in exp, though not needed for test cases\n        if sigma  1e-9: \n            return 0.0\n        g_1d = (1 / (np.sqrt(2 * np.pi) * sigma)) * np.exp(-x_coords**2 / (2 * sigma**2))\n        \n        # 1D Gaussian derivative with respect to sigma\n        dg_dsigma_1d = g_1d * (x_coords**2 / sigma**3 - 1 / sigma)\n\n        # 2D kernels from outer products, based on separability\n        K_sigma = np.outer(g_1d, g_1d)\n        dK_dsigma = np.outer(dg_dsigma_1d, g_1d) + np.outer(g_1d, dg_dsigma_1d)\n\n        # 2. Pad and shift kernels for DFT convolution\n        def pad_and_shift(kernel, n_pad):\n            \"\"\"Pads a kernel to size n_pad x n_pad and shifts it for FFT convolution.\"\"\"\n            padded = np.zeros((n_pad, n_pad), dtype=float)\n            padded[:k_size, :k_size] = kernel\n            # Roll to move kernel center (R, R) to (0, 0)\n            return np.roll(padded, (-R, -R), axis=(0, 1))\n\n        K_sigma_pad = pad_and_shift(K_sigma, n)\n        dK_dsigma_pad = pad_and_shift(dK_dsigma, n)\n        \n        # 3. Perform convolution via DFT\n        F_I = np.fft.fft2(I)\n        F_K = np.fft.fft2(K_sigma_pad)\n        F_dK = np.fft.fft2(dK_dsigma_pad)\n        \n        # 4. Get results in the spatial domain via inverse DFT\n        # The result should be real; np.real handles small imaginary parts from numerical error.\n        B_sigma = np.real(np.fft.ifft2(F_I * F_K))\n        dB_dsigma = np.real(np.fft.ifft2(F_I * F_dK))\n        \n        # 5. Calculate norms and sensitivity\n        norm_B = np.linalg.norm(B_sigma)  # Frobenius norm is the default for 2D arrays\n        norm_dB = np.linalg.norm(dB_dsigma)\n        \n        if norm_B == 0:\n            return 0.0\n        else:\n            return norm_dB / norm_B\n\n    # Define problem parameters and test cases\n    n = 16\n    R = 7\n\n    # Case 1: Impulse image\n    I1 = np.zeros((n, n), dtype=float)\n    I1[8, 8] = 1.0\n\n    # Case 2: Ramp image\n    ii, jj = np.ogrid[0:n, 0:n]\n    I2 = (ii + jj) / 30.0\n\n    # Case 3: Constant image\n    I3 = np.ones((n, n), dtype=float)\n\n    # Case 4: Checkerboard image\n    I4 = ((-1)**(ii + jj)).astype(float)\n\n    # Case 5: Random image\n    rng = np.random.default_rng(seed=0)\n    I5 = rng.uniform(0, 1, size=(n, n))\n\n    test_cases = [\n        (I1, 1.0),\n        (I2, 0.5),\n        (I3, 2.0),\n        (I4, 3.0),\n        (I5, 0.1),\n    ]\n\n    results = []\n    for I, sigma in test_cases:\n        sensitivity = calculate_sensitivity(I, sigma, n, R)\n        results.append(sensitivity)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}