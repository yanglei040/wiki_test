{
    "hands_on_practices": [
        {
            "introduction": "在深入探讨卷积定理的强大功能之前，首先必须掌握卷积运算本身的基本机理。本练习通过一个简单的离散序列例子，引导你逐步完成线性卷积的计算。理解这种“翻转-滑动-乘积累加”的过程，是建立对卷积更深刻直观认识的基石。",
            "id": "539926",
            "problem": "求序列 $x[n] = \\{1, 3, 2\\}$ 和 $h[n] = \\{2, -1\\}$ 的线性卷积。假设两个序列仅在 $n \\geq 0$ 时有定义，在其他情况下均为零。线性卷积 $y[n] = x[n] * h[n]$ 由下式给出：\n\n$$\ny[n] = \\sum_{k=-\\infty}^{\\infty} x[k] \\cdot h[n - k].\n$$\n\n计算结果序列 $y[n]$ 在所有其值不为零的 $n$ 上的取值，并按 $n$ 递增的顺序将答案表示为一个有序序列。",
            "solution": "卷积和定义为：\n\n$$\ny[n] = \\sum_{k=-\\infty}^{\\infty} x[k] \\cdot h[n - k].\n$$\n\n已知当 $n  0$ 或 $n > 2$ 时 $x[n] = 0$，当 $n  0$ 或 $n > 1$ 时 $h[n] = 0$，因此卷积 $y[n]$ 仅在 $n$ 从 $0$ 到 $3$ 的范围内非零（因为 $y[n]$ 的长度为 $3 + 2 - 1 = 4$）。我们计算 $n = 0, 1, 2, 3$ 时的 $y[n]$：\n\n- 当 $n = 0$ 时：\n\n$$\ny[0] = \\sum_{k=0}^{2} x[k] \\cdot h[0 - k] = x[0] \\cdot h[0] + x[1] \\cdot h[-1] + x[2] \\cdot h[-2].\n$$\n\n因为 $h[-1] = h[-2] = 0$，\n\n$$\ny[0] = (1) \\cdot (2) + (3) \\cdot (0) + (2) \\cdot (0) = 2.\n$$\n\n\n- 当 $n = 1$ 时：\n\n$$\ny[1] = \\sum_{k=0}^{2} x[k] \\cdot h[1 - k] = x[0] \\cdot h[1] + x[1] \\cdot h[0] + x[2] \\cdot h[-1].\n$$\n\n因为 $h[-1] = 0$，\n\n$$\ny[1] = (1) \\cdot (-1) + (3) \\cdot (2) + (2) \\cdot (0) = -1 + 6 = 5.\n$$\n\n\n- 当 $n = 2$ 时：\n\n$$\ny[2] = \\sum_{k=0}^{2} x[k] \\cdot h[2 - k] = x[0] \\cdot h[2] + x[1] \\cdot h[1] + x[2] \\cdot h[0].\n$$\n\n因为 $h[2] = 0$，\n\n$$\ny[2] = (1) \\cdot (0) + (3) \\cdot (-1) + (2) \\cdot (2) = -3 + 4 = 1.\n$$\n\n\n- 当 $n = 3$ 时：\n\n$$\ny[3] = \\sum_{k=0}^{2} x[k] \\cdot h[3 - k] = x[0] \\cdot h[3] + x[1] \\cdot h[2] + x[2] \\cdot h[1].\n$$\n\n因为 $h[3] = h[2] = 0$，\n\n$$\ny[3] = (1) \\cdot (0) + (3) \\cdot (0) + (2) \\cdot (-1) = -2.\n$$\n\n\n- 对于 $n  0$ 或 $n > 3$ 的情况，$y[n] = 0$。  \n\n因此，$y[n]$ 的非零值为 $y[0] = 2$，$y[1] = 5$，$y[2] = 1$，$y[3] = -2$。",
            "answer": "线性卷积序列为 $y[n] = \\{2, 5, 1, -2\\}$，对应于 $n = 0, 1, 2, 3$。  \n$$ \\boxed{(2,\\ 5,\\ 1,\\ -2)} $$"
        },
        {
            "introduction": "掌握了卷积的基本计算后，我们可以探索卷积定理如何将复杂问题化繁为简。这个练习展示了该定理在解决实际问题中的威力，特别是“反卷积”问题，即根据系统响应和输出信号来推断输入信号。通过在频域中进行简单的代数运算，我们可以有效地解决时域中复杂的积分方程。",
            "id": "540096",
            "problem": "考虑一个线性时不变（LTI）系统，其输入-输出关系由卷积积分 $y(t) = (x * h)(t) = \\int_{-\\infty}^{\\infty} x(\\tau) h(t-\\tau) d\\tau$ 描述，其中 $x(t)$ 是输入信号，$h(t)$ 是系统的冲激响应，$y(t)$ 是输出信号。\n\n分析将在连续时间域内使用傅里叶变换进行，其定义为 $F(\\omega) = \\mathcal{F}\\{f(t)\\} = \\int_{-\\infty}^{\\infty} f(t) e^{-i\\omega t} dt$。其逆变换由下式给出 $f(t) = \\mathcal{F}^{-1}\\{F(\\omega)\\} = \\frac{1}{2\\pi} \\int_{-\\infty}^{\\infty} F(\\omega) e^{i\\omega t} d\\omega$。\n\n我们定义两种基本脉冲形状：\n1. 单位矩形脉冲：$\\Pi(t) = \\begin{cases} 1, |t|  1/2 \\\\ 0, |t| > 1/2 \\end{cases}$\n2. 单位三角脉冲：$\\Lambda(t) = \\begin{cases} 1 - |t|, |t|  1 \\\\ 0, |t| > 1 \\end{cases}$\n\n该LTI系统的冲激响应由一个振幅为 $A$、宽度为 $W$ 的矩形脉冲给出：\n$$h(t) = A \\cdot \\Pi\\left(\\frac{t}{W}\\right)$$\n当某个未知的输入信号 $x(t)$ 施加到该系统时，观测到的输出是一个振幅为 $B$、总基底宽度为 $4W$ 的三角脉冲：\n$$y(t) = B \\cdot \\Lambda\\left(\\frac{t}{2W}\\right)$$\n在此，$A$、$B$ 和 $W$ 均为正常数。\n\n你的任务是确定产生此输出的输入信号 $x(t)$。请将最终答案表示为包含 $A$、$B$、$W$ 和单位矩形脉冲函数 $\\Pi(t)$ 的单一闭式解析表达式。",
            "solution": "LTI系统的输入 $x(t)$、冲激响应 $h(t)$ 和输出 $y(t)$ 之间的关系由卷积 $y(t) = (x*h)(t)$ 给出。\n\n根据卷积定理，两个信号卷积的傅里叶变换是它们各自傅里叶变换的乘积。设 $X(\\omega)$、$H(\\omega)$ 和 $Y(\\omega)$ 分别为 $x(t)$、$h(t)$ 和 $y(t)$ 的傅里叶变换。那么，\n$$Y(\\omega) = X(\\omega) H(\\omega)$$\n为了求得输入信号 $x(t)$，我们可以先求解其傅里叶变换 $X(\\omega)$：\n$$X(\\omega) = \\frac{Y(\\omega)}{H(\\omega)}$$\n然后，通过对 $X(\\omega)$ 进行傅里叶逆变换来求得 $x(t)$。\n\n**步骤1：计算冲激响应 $h(t)$ 的傅里叶变换**\n冲激响应为 $h(t) = A \\cdot \\Pi\\left(\\frac{t}{W}\\right)$。\n首先，我们求单位矩形脉冲 $\\Pi(t)$ 的傅里叶变换：\n$$\\mathcal{F}\\{\\Pi(t)\\} = \\int_{-1/2}^{1/2} 1 \\cdot e^{-i\\omega t} dt = \\left[\\frac{e^{-i\\omega t}}{-i\\omega}\\right]_{-1/2}^{1/2} = \\frac{e^{-i\\omega/2} - e^{i\\omega/2}}{-i\\omega} = \\frac{2\\sin(\\omega/2)}{\\omega} = \\text{sinc}\\left(\\frac{\\omega}{2}\\right)$$\n使用傅里叶变换的尺度变换性质，$\\mathcal{F}\\{f(at)\\} = \\frac{1}{|a|}F(\\frac{\\omega}{a})$，其中 $a=1/W$：\n$$\\mathcal{F}\\left\\{\\Pi\\left(\\frac{t}{W}\\right)\\right\\} = W \\cdot \\frac{2\\sin(W\\omega/2)}{W\\omega} = W \\cdot \\text{sinc}\\left(\\frac{W\\omega}{2}\\right)$$\n因此，$h(t)$ 的傅里叶变换为：\n$$H(\\omega) = \\mathcal{F}\\left\\{A \\cdot \\Pi\\left(\\frac{t}{W}\\right)\\right\\} = A W \\cdot \\text{sinc}\\left(\\frac{W\\omega}{2}\\right) = A W \\frac{\\sin(W\\omega/2)}{W\\omega/2}$$\n\n**步骤2：计算输出信号 $y(t)$ 的傅里叶变换**\n输出信号为 $y(t) = B \\cdot \\Lambda\\left(\\frac{t}{2W}\\right)$。\n单位三角脉冲可以表示为单位矩形脉冲与自身的卷积：$\\Lambda(t) = \\Pi(t) * \\Pi(t)$。\n根据卷积定理，其傅里叶变换为：\n$$\\mathcal{F}\\{\\Lambda(t)\\} = \\mathcal{F}\\{\\Pi(t)\\} \\cdot \\mathcal{F}\\{\\Pi(t)\\} = \\left(\\text{sinc}\\left(\\frac{\\omega}{2}\\right)\\right)^2$$\n现在，我们应用尺度变换性质，其中 $a = 1/(2W)$：\n$$\\mathcal{F}\\left\\{\\Lambda\\left(\\frac{t}{2W}\\right)\\right\\} = 2W \\cdot \\left(\\text{sinc}\\left(\\frac{2W\\omega}{2}\\right)\\right)^2 = 2W \\cdot \\text{sinc}^2(W\\omega)$$\n因此，输出 $y(t)$ 的傅里叶变换为：\n$$Y(\\omega) = \\mathcal{F}\\left\\{B \\cdot \\Lambda\\left(\\frac{t}{2W}\\right)\\right\\} = 2BW \\cdot \\text{sinc}^2(W\\omega) = 2BW \\left(\\frac{\\sin(W\\omega)}{W\\omega}\\right)^2$$\n\n**步骤3：求解 $X(\\omega)$**\n$$X(\\omega) = \\frac{Y(\\omega)}{H(\\omega)} = \\frac{2BW \\left(\\frac{\\sin(W\\omega)}{W\\omega}\\right)^2}{AW \\frac{\\sin(W\\omega/2)}{W\\omega/2}} = \\frac{2B}{A} \\frac{\\sin^2(W\\omega)}{(W\\omega)^2} \\frac{W\\omega/2}{\\sin(W\\omega/2)}$$\n$$X(\\omega) = \\frac{B}{A} \\frac{\\sin^2(W\\omega)}{W\\omega \\sin(W\\omega/2)}$$\n使用二倍角恒等式 $\\sin(2\\theta) = 2\\sin(\\theta)\\cos(\\theta)$，我们有 $\\sin(W\\omega) = 2\\sin(W\\omega/2)\\cos(W\\omega/2)$。\n$$X(\\omega) = \\frac{B}{A} \\frac{\\left(2\\sin(W\\omega/2)\\cos(W\\omega/2)\\right)^2}{W\\omega \\sin(W\\omega/2)} = \\frac{B}{A} \\frac{4\\sin^2(W\\omega/2)\\cos^2(W\\omega/2)}{W\\omega \\sin(W\\omega/2)}$$\n$$X(\\omega) = \\frac{4B}{A} \\frac{\\sin(W\\omega/2)\\cos^2(W\\omega/2)}{W\\omega} = \\frac{2B}{A} \\frac{\\sin(W\\omega/2)}{W\\omega/2} \\cos^2(W\\omega/2)$$\n使用恒等式 $\\cos^2(\\theta) = \\frac{1+\\cos(2\\theta)}{2}$：\n$$X(\\omega) = \\frac{2B}{A} \\frac{\\sin(W\\omega/2)}{W\\omega/2} \\left(\\frac{1+\\cos(W\\omega)}{2}\\right) = \\frac{B}{A} \\left( \\frac{\\sin(W\\omega/2)}{W\\omega/2} + \\frac{\\sin(W\\omega/2)\\cos(W\\omega)}{W\\omega/2} \\right)$$\n使用积化和差恒等式 $\\sin(\\alpha)\\cos(\\beta) = \\frac{1}{2}[\\sin(\\alpha+\\beta) + \\sin(\\alpha-\\beta)]$：\n$$\\sin(W\\omega/2)\\cos(W\\omega) = \\frac{1}{2}[\\sin(3W\\omega/2) + \\sin(-W\\omega/2)] = \\frac{1}{2}[\\sin(3W\\omega/2) - \\sin(W\\omega/2)]$$\n将此代回 $X(\\omega)$ 的表达式中：\n$$X(\\omega) = \\frac{B}{A} \\left( \\frac{\\sin(W\\omega/2)}{W\\omega/2} + \\frac{\\frac{1}{2}[\\sin(3W\\omega/2) - \\sin(W\\omega/2)]}{W\\omega/2} \\right)$$\n$$X(\\omega) = \\frac{B}{A} \\left( \\frac{2\\sin(W\\omega/2)}{W\\omega} + \\frac{\\sin(3W\\omega/2)}{W\\omega} - \\frac{\\sin(W\\omega/2)}{W\\omega} \\right)$$\n$$X(\\omega) = \\frac{B}{A W} \\left( \\frac{\\sin(W\\omega/2)}{\\omega} + \\frac{\\sin(3W\\omega/2)}{\\omega} \\right)$$\n\n**步骤4：计算 $X(\\omega)$ 的傅里叶逆变换以求得 $x(t)$**\n我们需要求解形如 $\\frac{\\sin(k\\omega)}{\\omega}$ 的项的傅里叶逆变换。根据矩形脉冲的变换对：\n$$\\mathcal{F}\\left\\{\\Pi\\left(\\frac{t}{2k}\\right)\\right\\} = 2k \\frac{\\sin(k\\omega)}{k\\omega} = \\frac{2\\sin(k\\omega)}{\\omega}$$\n因此，逆变换为：\n$$\\mathcal{F}^{-1}\\left\\{\\frac{\\sin(k\\omega)}{\\omega}\\right\\} = \\frac{1}{2}\\Pi\\left(\\frac{t}{2k}\\right)$$\n对于 $X(\\omega)$ 中的第一项，$k_1 = W/2$：\n$$\\mathcal{F}^{-1}\\left\\{\\frac{\\sin(W\\omega/2)}{\\omega}\\right\\} = \\frac{1}{2}\\Pi\\left(\\frac{t}{2(W/2)}\\right) = \\frac{1}{2}\\Pi\\left(\\frac{t}{W}\\right)$$\n对于第二项，$k_2 = 3W/2$：\n$$\\mathcal{F}^{-1}\\left\\{\\frac{\\sin(3W\\omega/2)}{\\omega}\\right\\} = \\frac{1}{2}\\Pi\\left(\\frac{t}{2(3W/2)}\\right) = \\frac{1}{2}\\Pi\\left(\\frac{t}{3W}\\right)$$\n结合这些结果：\n$$x(t) = \\mathcal{F}^{-1}\\{X(\\omega)\\} = \\frac{B}{AW} \\left[ \\frac{1}{2}\\Pi\\left(\\frac{t}{W}\\right) + \\frac{1}{2}\\Pi\\left(\\frac{t}{3W}\\right) \\right]$$\n$$x(t) = \\frac{B}{2AW} \\left[ \\Pi\\left(\\frac{t}{W}\\right) + \\Pi\\left(\\frac{t}{3W}\\right) \\right]$$\n该表达式是两个中心对齐但宽度不同的矩形脉冲之和。$\\Pi(t/W)$ 的宽度为 $W$，$\\Pi(t/3W)$ 的宽度为 $3W$。\n得到的信号是一个两级或‘婚礼蛋糕’脉冲。\n- 当 $|t|  W/2$ 时，$\\Pi(t/W)$ 和 $\\Pi(t/3W)$ 均为1。此时高度为 $\\frac{B}{2AW}(1+1) = \\frac{B}{AW}$。\n- 当 $W/2 \\le |t|  3W/2$ 时，$\\Pi(t/W)=0$ 且 $\\Pi(t/3W)=1$。此时高度为 $\\frac{B}{2AW}(0+1) = \\frac{B}{2AW}$。\n- 当 $|t| \\ge 3W/2$ 时，两项均为零。\n最终的表达式是最紧凑的解析形式。",
            "answer": "$$ \\boxed{\\frac{B}{2AW} \\left[ \\Pi\\left(\\frac{t}{W}\\right) + \\Pi\\left(\\frac{t}{3W}\\right) \\right]} $$"
        },
        {
            "introduction": "卷积定理是现代科学计算中高效算法（如基于快速傅里叶变换FFT的卷积）的理论核心。然而，这种计算上的便利也带来了一个必须注意的细节：离散傅里叶变换（DFT）本质上计算的是循环卷积，而非线性卷积。本练习将通过一个编程实践，让你亲手构建一个诊断工具，以识别和理解因循环卷积产生的“缠绕”效应，这是所有计算科学家在使用FFT进行信号处理时必备的一项关键技能。",
            "id": "3219738",
            "problem": "给定长度分别为 $L$ 和 $M$ 的实值离散时间序列 $x[n]$ 和脉冲响应 $h[m]$，其索引 $n \\in \\{0,1,\\dots,L-1\\}$，$m \\in \\{0,1,\\dots,M-1\\}$。$x[n]$ 与 $h[m]$ 的长度为 $L$ 的循环卷积定义如下：\n$$\ny[k] = \\sum_{n=0}^{L-1} x[n]\\, h[(k-n) \\bmod L], \\quad k \\in \\{0,1,\\dots,L-1\\}.\n$$\n序列 $x[n]$ 的长度为 $L$ 的离散傅里叶变换 (DFT) 定义如下：\n$$\nX[\\ell] = \\sum_{n=0}^{L-1} x[n]\\, e^{-j \\frac{2\\pi}{L}\\,\\ell n}, \\quad \\ell \\in \\{0,1,\\dots,L-1\\},\n$$\n其逆变换为：\n$$\nx[n] = \\frac{1}{L} \\sum_{\\ell=0}^{L-1} X[\\ell]\\, e^{j \\frac{2\\pi}{L}\\,\\ell n}, \\quad n \\in \\{0,1,\\dots,L-1\\}.\n$$\n在数值实践中，基于快速傅里叶变换 (FFT) 的长度为 $L$ 的卷积计算的是循环卷积 $y[k]$。如果物理脉冲响应在 $\\{0,1,\\dots,M-1\\}$ 上具有有限支撑，那么 $y[k]$ 的边界区域 $k \\in \\{0,1,\\dots,M-2\\}$ 和 $k \\in \\{L-(M-1),\\dots,L-1\\}$ 是唯一可能因循环回卷 (circular wrap-around) 而污染本应是线性卷积结果的位置，因为来自 $x[n]$ 边界之外的采样点的贡献可以通过模运算重新进入。本问题要求您构建一个诊断程序，通过检查一个给定的基于 FFT 的数值卷积结果 $y[k]$ 的末端分段，并将其与基于 $h[m]$ 有限支撑的预期结果进行比较，来识别该结果是否被循环回卷所污染。\n\n你的任务是实现一个程序，该程序：\n- 使用上述 DFT 定义，通过基于 FFT 的长度为 $L$ 的循环卷积计算 $y[k]$。\n- 构建一个利用预期脉冲响应支撑宽度 $w = M-1$ 的诊断程序：\n    - 为测试起始段 $k \\in \\{0,1,\\dots,w-1\\}$，在将 $x[n]$ 的最后 $w$ 个采样点置零后，重新计算循环卷积。将原始卷积的前 $w$ 个采样点与重新计算的卷积的相应采样点进行比较。如果最大绝对差值超过容差 $\\varepsilon$，则将起始段标记为受污染。\n    - 为测试结束段 $k \\in \\{L-w,\\dots,L-1\\}$，在将 $x[n]$ 的前 $w$ 个采样点置零后，重新计算循环卷积。类似地比较最后 $w$ 个采样点。如果最大绝对差值超过 $\\varepsilon$，则将结束段标记为受污染。\n    - 如果 $w = 0$，报告无污染。\n- 返回一个布尔值，指示是否在任一段检测到污染。\n\n使用数值容差 $\\varepsilon = 10^{-9}$。本任务不涉及物理单位。\n\n实现程序以处理以下测试套件。对于每种情况，$x[n]$ 和 $h[m]$ 都有明确定义，您必须计算上述布尔输出：\n- 情况1（理想情况，因末端置零而无回卷）：$L=16$，$M=5$。定义 $x[n] = \\sin\\left(\\frac{2\\pi n}{16}\\right)$，其中 $n \\in \\{0,1,\\dots,15\\}$，然后覆盖 $x[0]=x[1]=x[2]=x[3]=0$ 和 $x[12]=x[13]=x[14]=x[15]=0$。定义 $h[m]=1$，其中 $m \\in \\{0,1,2,3,4\\}$。\n- 情况2（可能存在回卷）：$L=16$，$M=5$。定义 $x[n] = \\sin\\left(\\frac{2\\pi n}{16}\\right)$，其中 $n \\in \\{0,1,\\dots,15\\}$。定义 $h[m]=1$，其中 $m \\in \\{0,1,2,3,4\\}$。\n- 情况3（边界条件，零支撑宽度）：$L=16$，$M=1$。定义 $x[n] = \\sin\\left(\\frac{2\\pi n}{16}\\right)$，其中 $n \\in \\{0,1,\\dots,15\\}$。定义 $h[0]=1$。\n- 情况4（显著支撑和明显回卷）：$L=32$，$M=9$。定义 $x[n] = 1$，其中 $n \\in \\{0,1,\\dots,31\\}$。定义 $h[m]$ 如下：$h[0]=0.20$, $h[1]=0.15$, $h[2]=0.12$, $h[3]=0.10$, $h[4]=0.08$, $h[5]=0.06$, $h[6]=0.05$, $h[7]=0.03$, $h[8]=0.02$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个条目是按给定顺序排列的相应测试用例的布尔值（例如，$[{\\text{True}},{\\text{False}},\\dots]$）。",
            "solution": "所提出的问题是有效的。其科学依据是数字信号处理的原理，特别是应用离散傅里葉變換 (DFT) 来计算卷积。该问题提法明确，提供了所有必要的定义、数据，以及一个用于诊断循环回卷失真的清晰、确定性的算法。\n\n问题的核心是实现一个诊断测试，以确定使用快速傅里叶变换 (FFT) 计算的长度为 $L$ 的循环卷积是否被“回卷”效应所污染。当循环卷积被用作近似线性卷积的快速方法时，尤其是在处理有限脉冲响应 (FIR) 滤波器时，就会发生这种污染。长度为 $L$ 的序列 $x[n]$ 与长度为 $M$ 的脉冲响应 $h[m]$ 的线性卷积的输出是一个长度为 $L+M-1$ 的序列。相比之下，循环卷积产生一个长度为 $L$ 的输出，这可以被概念化为线性卷积结果的混叠版本。\n\n问题中规定的诊断程序基于一个可靠的原则：要检测输出段是否被非局部输入（即“回卷”）污染，可以移除那些非局部输入的来源，并观察输出是否发生变化。\n\n**1. 数学框架：基于 FFT 的循环卷积**\n\n卷积定理指出，时域中的循环卷积等效于频域中的逐元素相乘。给定两个离散序列，$x[n]$（长度为 $L$）和 $h[m]$（长度为 $M$，其中 $M \\le L$），我们可以按如下方式计算它们的长度为 $L$ 的循环卷积：\n首先，对脉冲响应 $h[m]$进行补零，以创建一个长度为 $L$ 的序列 $h_L[n]$：\n$$\nh_L[n] = \\begin{cases} h[n]  \\text{for } 0 \\le n \\le M-1 \\\\ 0  \\text{for } M \\le n \\le L-1 \\end{cases}\n$$\n接下来，计算 $x[n]$ 和 $h_L[n]$ 的 DFT：\n$$\nX[\\ell] = \\mathcal{F}\\{x[n]\\}[\\ell] = \\sum_{n=0}^{L-1} x[n]\\, e^{-j \\frac{2\\pi}{L}\\,\\ell n}\n$$\n$$\nH_L[\\ell] = \\mathcal{F}\\{h_L[n]\\}[\\ell] = \\sum_{n=0}^{L-1} h_L[n]\\, e^{-j \\frac{2\\pi}{L}\\,\\ell n}\n$$\n它们频谱的乘积得到输出的频谱 $Y[\\ell]$：\n$$\nY[\\ell] = X[\\ell] \\cdot H_L[\\ell]\n$$\n最后，对 $Y[\\ell]$ 进行逆 DFT (IDFT) 即可得到循环卷积结果 $y[k]$：\n$$\ny[k] = \\mathcal{F}^{-1}\\{Y[\\ell]\\}[k] = \\frac{1}{L} \\sum_{\\ell=0}^{L-1} Y[\\ell]\\, e^{j \\frac{2\\pi}{L}\\,\\ell k}\n$$\n此过程将使用 `numpy.fft` 模块实现，其中的 `fft` 和 `ifft` 函数直接对应于问题中定义的 $\\mathcal{F}$ 和 $\\mathcal{F}^{-1}$ 操作。\n\n**2. 诊断算法**\n\n脉冲响应 $h[m]$ 具有一个由 $w = M-1$ 定义的有限支撑宽度。这意味着 $h[m]$ 仅在 $m \\in \\{0, 1, \\dots, w\\}$ 上非零。回卷失真会污染输出 $y[k]$ 的前 $w$ 个采样点和后 $w$ 个采样点。该算法分别测试这些污染。数值容差 $\\varepsilon = 10^{-9}$ 用于比较。\n\n**特殊情况**：如果支撑宽度 $w = M-1$ 为 $0$（即 $M=1$），则脉冲响应是一个单点 ($h[0]$)。在这种情况下，卷积只是简单的缩放，所定义的回卷不会发生。问题正确地指明，在这种情况下，应报告无污染。\n\n**起始段测试**：输出起始段 $y[k]$ for $k \\in \\{0, \\dots, w-1\\}$ 的污染是由输入结束段 $x[n]$ for $n \\in \\{L-w, \\dots, L-1\\}$ 的“回卷”引起的。该测试验证了这种依赖关系：\n1.  使用输入信号 $x[n]$ 计算原始卷积 $y[k]$。\n2.  创建一个修改后的输入信号 $x'[n]$，方法是将 $x[n]$ 的最后 $w$ 个采样点设为零：$x'[n]=0$ for $n \\in \\{L-w, \\dots, L-1\\}$。\n3.  使用 $x'[n]$ 计算新的卷积 $y'[k]$。\n4.  如果回卷效应存在且显著，$y[k]$ 和 $y'[k]$ 将在起始段有所不同。我们通过找到最大绝对差 $\\max_{k \\in \\{0, \\dots, w-1\\}} |y[k] - y'[k]|$ 来量化这一点。\n5.  如果这个差值超过 $\\varepsilon$，则起始段被标记为受污染。\n\n**结束段测试**：对称地，输出结束段 $y[k]$ for $k \\in \\{L-w, \\dots, L-1\\}$ 的污染是由输入起始段 $x[n]$ for $n \\in \\{0, \\dots, w-1\\}$ 的“回卷”引起的。对此的测试是类似的：\n1.  计算原始卷积 $y[k]$（如果尚未计算）。\n2.  创建一个修改后的输入信号 $x''[n]$，方法是将 $x[n]$ 的前 $w$ 个采样点设为零：$x''[n]=0$ for $n \\in \\{0, \\dots, w-1\\}$。\n3.  使用 $x''[n]$ 计算新的卷积 $y''[k]$。\n4.  通过比较 $y[k]$ 和 $y''[k]$ 的结束段来确定是否存在污染。我们计算最大绝对差 $\\max_{k \\in \\{L-w, \\dots, L-1\\}} |y[k] - y''[k]|$。\n5.  如果这个差值超过 $\\varepsilon$，则结束段被标记为受污染。\n\n对于给定的测试用例，最终结果是一个单一的布尔值：如果发现起始段或结束段（或两者）被污染，则为 `True`，否则为 `False`。\n\n**3. 测试套件的实现**\n\n完整的程序将定义一个函数来执行上述诊断检查。该函数将应用于所提供的 4 个测试用例中的每一个。\n\n-   **情况1**：$L=16$，$M=5$，因此 $w=4$。输入信号 $x[n]$ 被显式地构建，其前 4 个和后 4 个位置均为零。因此，当这些区域被置零时，诊断测试将发现没有变化，从而导致零差异和 `False` 的结果。\n-   **情况2**：$L=16$，$M=5$，因此 $w=4$。输入信号 $x[n]$ 是一个完整的正弦波，在其边界处非零。将 $x[n]$ 的边界区域置零将导致输出 $y[k]$ 的相应边界区域发生显著变化，从而导致 `True` 的结果。\n-   **情况3**：$L=16$，$M=1$，因此 $w=0$。这是算法必须立即返回 `False` 的特殊情况。\n-   **情况4**：$L=32$，$M=9$，因此 $w=8$。输入信号 $x[n]$ 是常数 $1$，因此处处非零。与情况2类似，诊断测试将检测到显著变化，从而导致 `True` 的结果。\n\n所有情况的结果被收集并以指定的列表格式打印。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem, processing all test cases and printing the final result.\n    \"\"\"\n\n    def fft_based_circular_convolution(x, h_padded):\n        \"\"\"\n        Computes the circular convolution of x and h_padded using FFT.\n        Assumes x and h_padded are of the same length.\n        \"\"\"\n        X = np.fft.fft(x)\n        H = np.fft.fft(h_padded)\n        Y = X * H\n        y = np.fft.ifft(Y)\n        # The result should be real, so we discard negligible imaginary parts\n        # from floating-point inaccuracies.\n        return np.real(y)\n\n    def check_contamination(x, h, L, M, epsilon):\n        \"\"\"\n        Implements the diagnostic to check for circular wrap-around contamination.\n        \n        Args:\n            x (np.ndarray): The input signal of length L.\n            h (np.ndarray): The impulse response of length M.\n            L (int): Length of the signal x.\n            M (int): Length of the impulse response h.\n            epsilon (float): The numerical tolerance for comparison.\n        \n        Returns:\n            bool: True if contamination is detected, False otherwise.\n        \"\"\"\n        w = M - 1\n\n        # Per problem specification, if support width is 0, no contamination is reported.\n        if w == 0:\n            return False\n\n        # Pad the impulse response h with zeros to have length L.\n        h_padded = np.zeros(L)\n        h_padded[:M] = h\n\n        # 1. Compute the original circular convolution.\n        y = fft_based_circular_convolution(x, h_padded)\n\n        # Contamination flags\n        start_contaminated = False\n        end_contaminated = False\n\n        # 2. Test for contamination in the start segment.\n        # Create a modified signal x' with the last w samples zeroed out.\n        x_prime = x.copy()\n        x_prime[L - w:] = 0\n        \n        # Compute the convolution y' with the modified signal.\n        y_prime = fft_based_circular_convolution(x_prime, h_padded)\n        \n        # Compare the first w samples of y and y'.\n        diff_start = np.max(np.abs(y[:w] - y_prime[:w]))\n        if diff_start > epsilon:\n            start_contaminated = True\n\n        # 3. Test for contamination in the end segment.\n        # Create a modified signal x'' with the first w samples zeroed out.\n        x_double_prime = x.copy()\n        x_double_prime[:w] = 0\n        \n        # Compute the convolution y'' with the modified signal.\n        y_double_prime = fft_based_circular_convolution(x_double_prime, h_padded)\n        \n        # Compare the last w samples of y and y''.\n        diff_end = np.max(np.abs(y[L - w:] - y_double_prime[L - w:]))\n        if diff_end > epsilon:\n            end_contaminated = True\n        \n        return start_contaminated or end_contaminated\n\n    epsilon = 1e-9\n\n    # Define the test cases from the problem statement.\n    # Case 1\n    L1, M1 = 16, 5\n    x1 = np.sin(2 * np.pi * np.arange(L1) / L1)\n    x1[0:4] = 0\n    x1[12:16] = 0\n    h1 = np.ones(M1)\n\n    # Case 2\n    L2, M2 = 16, 5\n    x2 = np.sin(2 * np.pi * np.arange(L2) / L2)\n    h2 = np.ones(M2)\n\n    # Case 3\n    L3, M3 = 16, 1\n    x3 = np.sin(2 * np.pi * np.arange(L3) / L3)\n    h3 = np.ones(M3)\n\n    # Case 4\n    L4, M4 = 32, 9\n    x4 = np.ones(L4)\n    h4 = np.array([0.20, 0.15, 0.12, 0.10, 0.08, 0.06, 0.05, 0.03, 0.02])\n\n    test_cases = [\n        {'x': x1, 'h': h1, 'L': L1, 'M': M1},\n        {'x': x2, 'h': h2, 'L': L2, 'M': M2},\n        {'x': x3, 'h': h3, 'L': L3, 'M': M3},\n        {'x': x4, 'h': h4, 'L': L4, 'M': M4},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = check_contamination(case['x'], case['h'], case['L'], case['M'], epsilon)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}