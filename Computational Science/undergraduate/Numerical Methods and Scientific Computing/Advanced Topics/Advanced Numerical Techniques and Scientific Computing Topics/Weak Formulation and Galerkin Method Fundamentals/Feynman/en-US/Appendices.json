{
    "hands_on_practices": [
        {
            "introduction": "To build a robust Finite Element Method (FEM) solver, we start with its smallest component: the element. This practice guides you through the fundamental derivation of the local stiffness matrix for a simple 1D linear element, a calculation that lies at the heart of FEM for second-order equations. Mastering this process, especially the mapping from a physical element to a standardized 'reference' element, is a cornerstone skill for understanding and implementing the FEM for any problem .",
            "id": "3286521",
            "problem": "Consider the one-dimensional model problem defined by the second-order differential equation $-u''(x)=f(x)$ on a bounded interval, subject to homogeneous Dirichlet boundary conditions. In the standard weak formulation, one seeks $u$ in the Sobolev space $H_{0}^{1}$ such that the bilinear form $a(u,v)=\\int u'(x)v'(x)\\,dx$ equals the linear functional $\\ell(v)=\\int f(x)v(x)\\,dx$ for all test functions $v\\in H_{0}^{1}$. In the Finite Element Method (FEM), the local element stiffness matrix on an element $[x_i,x_{i+1}]$ with two-node linear basis functions is defined by the entries $K_{mn}^{(e)}=\\int_{x_i}^{x_{i+1}} N_m'(x)N_n'(x)\\,dx$, where $N_m$ and $N_n$ are the element’s nodal basis functions.\n\nUsing only first principles of the weak formulation, the definition of the element stiffness via the bilinear form, and an affine mapping from the reference element, derive the explicit expression for the $2\\times 2$ local stiffness matrix $K^{(e)}$ for a linear element on $[x_i,x_{i+1}]$. Map from the reference element $\\hat{x}\\in[0,1]$ using the affine transformation $x=x_i+h_e\\hat{x}$, where $h_e=x_{i+1}-x_i$, and the reference linear basis functions. Express your final answer for $K^{(e)}$ in closed form as a function of $h_e$ only. Do not skip steps in the derivation. The final answer must be a single closed-form analytic expression; no numerical evaluation or rounding is required.",
            "solution": "The problem statement is subjected to validation.\n\n### Step 1: Extract Givens\n- **Differential Equation:** $-u''(x) = f(x)$\n- **Domain:** A bounded interval $[x_i, x_{i+1}]$ is a single element.\n- **Boundary Conditions:** Homogeneous Dirichlet, $u \\in H_{0}^{1}$.\n- **Weak Formulation:** Find $u \\in H_{0}^{1}$ such that $a(u,v) = \\ell(v)$ for all $v \\in H_{0}^{1}$.\n- **Bilinear Form:** $a(u,v) = \\int u'(x)v'(x)\\,dx$.\n- **Linear Functional:** $\\ell(v) = \\int f(x)v(x)\\,dx$.\n- **Local Element Stiffness Matrix Definition:** $K_{mn}^{(e)} = \\int_{x_i}^{x_{i+1}} N_m'(x)N_n'(x)\\,dx$.\n- **Element Basis Functions:** Two-node linear basis functions, $N_m(x)$ and $N_n(x')$.\n- **Reference Element:** $\\hat{x} \\in [0,1]$.\n- **Affine Mapping:** $x(\\hat{x}) = x_i + h_e\\hat{x}$.\n- **Element Length:** $h_e = x_{i+1} - x_i$.\n- **Objective:** Derive the $2 \\times 2$ local stiffness matrix $K^{(e)}$ as a function of $h_e$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded, being a canonical derivation in the field of numerical methods for partial differential equations, specifically the Finite Element Method. It is well-posed, as it provides all necessary definitions, transformations, and constraints to arrive at a unique, well-defined analytical expression. The problem is objective and uses standard, unambiguous terminology. It does not violate any scientific principles, is not based on false premises, and is fully formalizable. The setup is complete and internally consistent.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A solution will be provided.\n\nThe objective is to derive the $2 \\times 2$ local stiffness matrix $K^{(e)}$ for a one-dimensional linear element. The entries of this matrix are defined by the integral over the element domain $[x_i, x_{i+1}]$:\n$$\nK_{mn}^{(e)} = \\int_{x_i}^{x_{i+1}} N_m'(x)N_n'(x)\\,dx\n$$\nwhere $m, n \\in \\{1, 2\\}$, and $N_m(x)$ are the linear basis functions (also known as shape functions) on the physical element.\n\nThe derivation proceeds by transforming this integral from the physical coordinate system $x \\in [x_i, x_{i+1}]$ to a reference coordinate system $\\hat{x} \\in [0,1]$.\n\n**1. Reference Element Basis Functions**\nOn the reference element $[0,1]$, the two linear basis functions, denoted $\\hat{N}_1(\\hat{x})$ and $\\hat{N}_2(\\hat{x})$, are defined by the nodal properties:\n$\\hat{N}_m(\\hat{x}_n) = \\delta_{mn}$, where $\\hat{x}_1 = 0$ and $\\hat{x}_2 = 1$ are the nodes of the reference element.\nThe linear function satisfying $\\hat{N}_1(0)=1$ and $\\hat{N}_1(1)=0$ is:\n$$\n\\hat{N}_1(\\hat{x}) = 1 - \\hat{x}\n$$\nThe linear function satisfying $\\hat{N}_2(0)=0$ and $\\hat{N}_2(1)=1$ is:\n$$\n\\hat{N}_2(\\hat{x}) = \\hat{x}\n$$\nThe derivatives of these reference basis functions with respect to the reference coordinate $\\hat{x}$ are constant:\n$$\n\\frac{d\\hat{N}_1}{d\\hat{x}} = -1\n$$\n$$\n\\frac{d\\hat{N}_2}{d\\hat{x}} = 1\n$$\n\n**2. Coordinate Transformation and Derivative Mapping**\nThe problem specifies the affine mapping from the reference element to the physical element:\n$$\nx(\\hat{x}) = x_i + h_e\\hat{x}\n$$\nwhere $h_e = x_{i+1} - x_i$ is the length of the element.\nTo transform the derivatives $N_m'(x) = \\frac{dN_m}{dx}$, we use the chain rule. The physical basis functions are related to the reference ones by $N_m(x) = \\hat{N}_m(\\hat{x}(x))$. Thus,\n$$\n\\frac{dN_m}{dx} = \\frac{d\\hat{N}_m}{d\\hat{x}} \\frac{d\\hat{x}}{dx}\n$$\nWe need the term $\\frac{d\\hat{x}}{dx}$. From the mapping $x(\\hat{x})$, we can compute the Jacobian of the transformation:\n$$\n\\frac{dx}{d\\hat{x}} = h_e\n$$\nTherefore, its inverse is:\n$$\n\\frac{d\\hat{x}}{dx} = \\left(\\frac{dx}{d\\hat{x}}\\right)^{-1} = \\frac{1}{h_e}\n$$\nSubstituting this into the chain rule expression gives the relationship between the physical and reference derivatives:\n$$\nN_m'(x) = \\frac{1}{h_e}\\frac{d\\hat{N}_m}{d\\hat{x}}\n$$\n\n**3. Transformation of the Integral**\nWe now substitute the transformed derivatives into the definition of $K_{mn}^{(e)}$. We also need to change the differential element $dx$ and the limits of integration.\nThe differential element transforms as:\n$$\ndx = \\frac{dx}{d\\hat{x}}d\\hat{x} = h_e d\\hat{x}\n$$\nThe integration limits $x \\in [x_i, x_{i+1}]$ correspond to $\\hat{x} \\in [0,1]$.\nThe integral for the stiffness matrix entries becomes:\n$$\nK_{mn}^{(e)} = \\int_{0}^{1} \\left(\\frac{1}{h_e}\\frac{d\\hat{N}_m}{d\\hat{x}}\\right) \\left(\\frac{1}{h_e}\\frac{d\\hat{N}_n}{d\\hat{x}}\\right) (h_e \\, d\\hat{x})\n$$\nSimplifying the expression by combining terms involving $h_e$:\n$$\nK_{mn}^{(e)} = \\frac{1}{h_e^2} \\cdot h_e \\int_{0}^{1} \\frac{d\\hat{N}_m}{d\\hat{x}} \\frac{d\\hat{N}_n}{d\\hat{x}} \\, d\\hat{x} = \\frac{1}{h_e} \\int_{0}^{1} \\frac{d\\hat{N}_m}{d\\hat{x}} \\frac{d\\hat{N}_n}{d\\hat{x}} \\, d\\hat{x}\n$$\n\n**4. Calculation of the Matrix Entries**\nWe can now compute the four entries of the $2 \\times 2$ matrix $K^{(e)}$ by substituting the constant values of the derivatives of the reference basis functions.\n\n- Entry $K_{11}^{(e)}$ (for $m=1, n=1$):\n$$\nK_{11}^{(e)} = \\frac{1}{h_e} \\int_{0}^{1} \\left(\\frac{d\\hat{N}_1}{d\\hat{x}}\\right)\\left(\\frac{d\\hat{N}_1}{d\\hat{x}}\\right) \\, d\\hat{x} = \\frac{1}{h_e} \\int_{0}^{1} (-1)(-1) \\, d\\hat{x} = \\frac{1}{h_e} \\int_{0}^{1} 1 \\, d\\hat{x} = \\frac{1}{h_e} [\\hat{x}]_0^1 = \\frac{1}{h_e}\n$$\n\n- Entry $K_{12}^{(e)}$ (for $m=1, n=2$):\n$$\nK_{12}^{(e)} = \\frac{1}{h_e} \\int_{0}^{1} \\left(\\frac{d\\hat{N}_1}{d\\hat{x}}\\right)\\left(\\frac{d\\hat{N}_2}{d\\hat{x}}\\right) \\, d\\hat{x} = \\frac{1}{h_e} \\int_{0}^{1} (-1)(1) \\, d\\hat{x} = \\frac{1}{h_e} \\int_{0}^{1} (-1) \\, d\\hat{x} = -\\frac{1}{h_e} [\\hat{x}]_0^1 = -\\frac{1}{h_e}\n$$\n\n- Entry $K_{21}^{(e)}$ (for $m=2, n=1$):\nDue to the symmetry of the bilinear form, $K^{(e)}$ must be a symmetric matrix, so $K_{21}^{(e)} = K_{12}^{(e)}$. We verify this explicitly:\n$$\nK_{21}^{(e)} = \\frac{1}{h_e} \\int_{0}^{1} \\left(\\frac{d\\hat{N}_2}{d\\hat{x}}\\right)\\left(\\frac{d\\hat{N}_1}{d\\hat{x}}\\right) \\, d\\hat{x} = \\frac{1}{h_e} \\int_{0}^{1} (1)(-1) \\, d\\hat{x} = -\\frac{1}{h_e}\n$$\n\n- Entry $K_{22}^{(e)}$ (for $m=2, n=2$):\n$$\nK_{22}^{(e)} = \\frac{1}{h_e} \\int_{0}^{1} \\left(\\frac{d\\hat{N}_2}{d\\hat{x}}\\right)\\left(\\frac{d\\hat{N}_2}{d\\hat{x}}\\right) \\, d\\hat{x} = \\frac{1}{h_e} \\int_{0}^{1} (1)(1) \\, d\\hat{x} = \\frac{1}{h_e} \\int_{0}^{1} 1 \\, d\\hat{x} = \\frac{1}{h_e}\n$$\n\n**5. Assembling the Local Stiffness Matrix**\nCombining these four entries, we obtain the local stiffness matrix $K^{(e)}$:\n$$\nK^{(e)} = \\begin{pmatrix}\nK_{11}^{(e)} & K_{12}^{(e)} \\\\\nK_{21}^{(e)} & K_{22}^{(e)}\n\\end{pmatrix} = \\begin{pmatrix}\n\\frac{1}{h_e} & -\\frac{1}{h_e} \\\\\n-\\frac{1}{h_e} & \\frac{1}{h_e}\n\\end{pmatrix}\n$$\nFactoring out the common term $\\frac{1}{h_e}$, the final expression for the local stiffness matrix for a one-dimensional linear element is:\n$$\nK^{(e)} = \\frac{1}{h_e}\n\\begin{pmatrix}\n1 & -1 \\\\\n-1 & 1\n\\end{pmatrix}\n$$\nThis expression depends only on the element length $h_e$, as required.",
            "answer": "$$\n\\boxed{\\frac{1}{h_e} \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "One of the primary advantages of the weak formulation is its ability to gracefully handle physical properties that change abruptly, such as in composite materials. This exercise explores this feature by analyzing a problem with a discontinuous diffusion coefficient, where the classical strong form of the equation is ill-defined at the interface. By working through this problem, you will see how the integral-based weak form naturally accommodates such discontinuities, a crucial feature for modeling real-world physical systems .",
            "id": "3286550",
            "problem": "Consider the one-dimensional Poisson-type Partial Differential Equation (PDE) on the interval $\\Omega = (0,1)$,\n$$\n-\\frac{d}{dx}\\big(a(x)\\,u'(x)\\big) = f(x),\n$$\nwith homogeneous Dirichlet boundary conditions $u(0) = 0$ and $u(1) = 0$. The diffusion coefficient $a(x)$ is a positive step function given by\n$$\na(x) = \\begin{cases}\na_{1}, & 0 \\le x < \\tfrac{1}{2}, \\\\\na_{2}, & \\tfrac{1}{2} \\le x \\le 1,\n\\end{cases}\n$$\nwhere $a_{1} > 0$ and $a_{2} > 0$ are constants, and $f \\in L^{2}(\\Omega)$ is a given source. Starting from the strong form and using only fundamental calculus operations (the product rule and integration by parts) together with standard function space definitions, derive the weak formulation of this boundary value problem with trial and test space taken to be the Sobolev space of order one with zero trace at the boundary, $H_{0}^{1}(\\Omega)$. Clearly specify the bilinear form and the linear functional.\n\nThen, consider the standard continuous, piecewise linear finite element basis on the mesh with nodes at $x = 0$, $x = \\tfrac{1}{2}$, and $x = 1$. Let $\\varphi(x)$ denote the hat function centered at $x = \\tfrac{1}{2}$ defined by\n$$\n\\varphi(x) = \\begin{cases}\n\\frac{x}{\\tfrac{1}{2}}, & 0 \\le x \\le \\tfrac{1}{2}, \\\\\n\\frac{1-x}{\\tfrac{1}{2}}, & \\tfrac{1}{2} \\le x \\le 1, \\\\\n0, & \\text{otherwise}.\n\\end{cases}\n$$\nUsing your derived weak formulation, compute the exact value of the stiffness contribution $B(\\varphi,\\varphi)$, where $B(\\cdot,\\cdot)$ is the bilinear form of the weak problem. Express your final answer as a single closed-form analytical expression in terms of $a_{1}$ and $a_{2}$. No rounding is required.",
            "solution": "The problem statement is validated as scientifically grounded, well-posed, objective, and complete. It represents a standard exercise in the numerical analysis of partial differential equations, specifically within the topic of the finite element method. There are no contradictions, ambiguities, or violations of scientific principles. I will proceed with the solution.\n\nThe first task is to derive the weak formulation for the given boundary value problem.\nThe strong form of the problem is to find a function $u(x)$ that satisfies:\n$$\n-\\frac{d}{dx}\\left(a(x)\\frac{du}{dx}\\right) = f(x) \\quad \\text{for } x \\in \\Omega = (0,1)\n$$\nwith the homogeneous Dirichlet boundary conditions $u(0) = 0$ and $u(1) = 0$.\n\nTo derive the weak formulation, we multiply the partial differential equation (PDE) by an arbitrary test function $v(x)$. The problem specifies that the trial space for the solution $u$ and the test space for $v$ are both the Sobolev space $H_{0}^{1}(\\Omega)$. This space consists of functions that are square-integrable, have a square-integrable weak derivative, and are zero at the boundaries of the domain $\\Omega$. Thus, for any $v \\in H_{0}^{1}(\\Omega)$, we have $v(0) = 0$ and $v(1) = 0$.\n\nMultiplying the PDE by $v(x)$ and integrating over the domain $\\Omega = (0,1)$ yields:\n$$\n\\int_{0}^{1} -\\frac{d}{dx}\\left(a(x)\\frac{du}{dx}\\right) v(x) \\, dx = \\int_{0}^{1} f(x) v(x) \\, dx\n$$\nWe apply integration by parts to the left-hand side of this equation. The formula for integration by parts is $\\int_{a}^{b} F(x)G'(x) \\, dx = [F(x)G(x)]_{a}^{b} - \\int_{a}^{b} F'(x)G(x) \\, dx$. Let us identify $F(x) = v(x)$ and $G'(x) = -\\frac{d}{dx}\\left(a(x)\\frac{du}{dx}\\right)$. This implies $F'(x) = \\frac{dv}{dx}$ and $G(x) = -a(x)\\frac{du}{dx}$. Applying the formula, we get:\n$$\n\\int_{0}^{1} -\\frac{d}{dx}\\left(a(x)\\frac{du}{dx}\\right) v(x) \\, dx = \\left[ -a(x)\\frac{du}{dx} v(x) \\right]_{0}^{1} - \\int_{0}^{1} \\left(-a(x)\\frac{du}{dx}\\right) \\frac{dv}{dx} \\, dx\n$$\n$$\n= \\left[ -a(x)\\frac{du}{dx} v(x) \\right]_{0}^{1} + \\int_{0}^{1} a(x)\\frac{du}{dx} \\frac{dv}{dx} \\, dx\n$$\nThe boundary term is evaluated as:\n$$\n\\left[ -a(x)\\frac{du}{dx} v(x) \\right]_{0}^{1} = \\left(-a(1)\\frac{du}{dx}(1) v(1)\\right) - \\left(-a(0)\\frac{du}{dx}(0) v(0)\\right)\n$$\nSince the test function $v(x)$ belongs to $H_{0}^{1}(\\Omega)$, we have $v(0) = 0$ and $v(1) = 0$. Consequently, the boundary term vanishes:\n$$\n\\left(-a(1)\\frac{du}{dx}(1) \\cdot 0\\right) - \\left(-a(0)\\frac{du}{dx}(0) \\cdot 0\\right) = 0\n$$\nSubstituting this back, the left-hand side of the integrated equation simplifies to:\n$$\n\\int_{0}^{1} a(x)\\frac{du}{dx} \\frac{dv}{dx} \\, dx\n$$\nEquating this with the right-hand side, we obtain the weak formulation: Find $u \\in H_{0}^{1}(\\Omega)$ such that for all $v \\in H_{0}^{1}(\\Omega)$,\n$$\n\\int_{0}^{1} a(x)\\frac{du}{dx} \\frac{dv}{dx} \\, dx = \\int_{0}^{1} f(x) v(x) \\, dx\n$$\nThis equation is of the form $B(u, v) = L(v)$. The bilinear form $B(\\cdot, \\cdot)$ and the linear functional $L(\\cdot)$ are defined as:\nBilinear form: $B(u, v) = \\int_{0}^{1} a(x) u'(x) v'(x) \\, dx$\nLinear functional: $L(v) = \\int_{0}^{1} f(x) v(x) \\, dx$\n\nThe second task is to compute the stiffness contribution $B(\\varphi, \\varphi)$ for the given basis function $\\varphi(x)$. The hat function $\\varphi(x)$ is defined as:\n$$\n\\varphi(x) = \\begin{cases}\n2x, & 0 \\le x \\le \\frac{1}{2} \\\\\n2(1-x), & \\frac{1}{2} \\le x \\le 1 \\\\\n0, & \\text{otherwise}\n\\end{cases}\n$$\nThe derivative of $\\varphi(x)$, which exists in the weak sense, is a piecewise constant function:\n$$\n\\varphi'(x) = \\frac{d\\varphi}{dx} = \\begin{cases}\n2, & 0 < x < \\frac{1}{2} \\\\\n-2, & \\frac{1}{2} < x < 1\n\\end{cases}\n$$\nThe stiffness contribution $B(\\varphi, \\varphi)$ is given by the integral:\n$$\nB(\\varphi, \\varphi) = \\int_{0}^{1} a(x) (\\varphi'(x))^2 \\, dx\n$$\nThe diffusion coefficient $a(x)$ is a piecewise constant function:\n$$\na(x) = \\begin{cases}\na_{1}, & 0 \\le x < \\frac{1}{2} \\\\\na_{2}, & \\frac{1}{2} \\le x \\le 1\n\\end{cases}\n$$\nSince both $a(x)$ and $\\varphi'(x)$ are piecewise constant with a common breakpoint at $x = \\frac{1}{2}$, we split the integral into two parts:\n$$\nB(\\varphi, \\varphi) = \\int_{0}^{\\frac{1}{2}} a(x) (\\varphi'(x))^2 \\, dx + \\int_{\\frac{1}{2}}^{1} a(x) (\\varphi'(x))^2 \\, dx\n$$\nNow, we substitute the respective constant values for $a(x)$ and $\\varphi'(x)$ in each sub-interval:\n$$\nB(\\varphi, \\varphi) = \\int_{0}^{\\frac{1}{2}} a_{1} (2)^2 \\, dx + \\int_{\\frac{1}{2}}^{1} a_{2} (-2)^2 \\, dx\n$$\n$$\nB(\\varphi, \\varphi) = \\int_{0}^{\\frac{1}{2}} 4a_{1} \\, dx + \\int_{\\frac{1}{2}}^{1} 4a_{2} \\, dx\n$$\nSince $a_1$ and $a_2$ are constants, we can take them out of the integrals:\n$$\nB(\\varphi, \\varphi) = 4a_{1} \\int_{0}^{\\frac{1}{2}} 1 \\, dx + 4a_{2} \\int_{\\frac{1}{2}}^{1} 1 \\, dx\n$$\nEvaluating the simple integrals gives:\n$$\nB(\\varphi, \\varphi) = 4a_{1} [x]_{0}^{\\frac{1}{2}} + 4a_{2} [x]_{\\frac{1}{2}}^{1}\n$$\n$$\nB(\\varphi, \\varphi) = 4a_{1} \\left(\\frac{1}{2} - 0\\right) + 4a_{2} \\left(1 - \\frac{1}{2}\\right)\n$$\n$$\nB(\\varphi, \\varphi) = 4a_{1} \\left(\\frac{1}{2}\\right) + 4a_{2} \\left(\\frac{1}{2}\\right)\n$$\n$$\nB(\\varphi, \\varphi) = 2a_{1} + 2a_{2}\n$$\nThis is the final closed-form analytical expression for the stiffness contribution in terms of $a_{1}$ and $a_{2}$.",
            "answer": "$$\n\\boxed{2a_{1} + 2a_{2}}\n$$"
        },
        {
            "introduction": "The ultimate test of understanding is not just deriving equations, but building a working tool and verifying its correctness against theory. This capstone practice guides you through the entire workflow of a computational scientist: using the Method of Manufactured Solutions (MMS) to create a test case with a known answer, implementing a FEM solver, and performing a convergence study to verify that your code behaves as predicted. This exercise bridges the gap between abstract concepts and the practical validation of numerical software .",
            "id": "3286674",
            "problem": "Consider the one-dimensional Poisson boundary value problem on the unit interval: find a function $u : [0,1] \\to \\mathbb{R}$ such that\n$$ -u''(x) = f(x) \\quad \\text{for } x \\in (0,1), \\qquad u(0) = 0, \\quad u(1) = 0. $$\nStarting from the definitions of the Sobolev space $H_0^1(0,1)$ and the integration-by-parts identity in one dimension, perform the following tasks.\n\n1) Derive the weak formulation of the problem: identify the bilinear form and the linear functional, and the solution space. Use only fundamental definitions and operations (multiplication by a test function, integration-by-parts, and the trace condition for homogeneous Dirichlet boundary values).\n\n2) Define the standard Galerkin method with continuous, piecewise-polynomial trial and test spaces of degrees $p \\in \\{1,2\\}$ on a uniform mesh of $N$ subintervals of $[0,1]$. The trial and test spaces are subspaces of $H_0^1(0,1)$:\n- For $p=1$ (commonly called $P1$): continuous, piecewise-linear basis functions.\n- For $p=2$ (commonly called $P2$): continuous, piecewise-quadratic basis functions.\nExplain clearly how the global system matrix and load vector arise from the bilinear and linear forms.\n\n3) Use the method of manufactured solutions: for each manufactured solution $u(x)$ below, compute the corresponding forcing function $f(x)$ by analytic differentiation so that the exact solution of the boundary value problem is the chosen $u(x)$. The manufactured solutions are:\n- Case A: $u_A(x) = \\sin(\\pi x)$.\n- Case B: $u_B(x) = e^{x}\\sin(2\\pi x)$.\nIn each case, verify that the boundary conditions are satisfied and compute $f(x) = -u''(x)$ explicitly.\n\n4) Implement the Galerkin finite element method for both $P1$ and $P2$ elements on uniform meshes with $N \\in \\{10,20,40,80\\}$ subintervals. Assemble the stiffness matrix and load vector and solve the resulting linear system with homogeneous Dirichlet boundary conditions for each case. For numerical integration of element matrices, element load vectors, and error norms, use Gauss–Legendre quadrature with at least $8$ points per element.\n\n5) For each mesh and each element degree $p \\in \\{1,2\\}$, compute the following two errors relative to the exact solution:\n- The $L^2$-norm error: $\\|u - u_h\\|_{L^2(0,1)} = \\left(\\int_0^1 |u(x)-u_h(x)|^2 \\, dx\\right)^{1/2}$.\n- The $H^1$-seminorm error: $|u - u_h|_{H^1(0,1)} = \\left(\\int_0^1 |u'(x)-u_h'(x)|^2 \\, dx\\right)^{1/2}$.\n\n6) For each manufactured solution (Case A and Case B) and for each element degree $p \\in \\{1,2\\}$, estimate the observed convergence rate for the $L^2$-norm and the $H^1$-seminorm using the last two refinements. For a sequence of uniform meshes with mesh sizes $h_k$, define the rate between two consecutive meshes by\n$$ \\text{rate} = \\frac{\\log\\left(\\frac{E(h_{k-1})}{E(h_k)}\\right)}{\\log\\left(\\frac{h_{k-1}}{h_k}\\right)}, $$\nwhere $E(h)$ denotes the error (either $L^2$ or $H^1$-seminorm) computed on mesh size $h$.\n\n7) Test Suite and final output specification:\n- Test Case $1$: Manufactured solution $u_A(x) = \\sin(\\pi x)$ with $f_A(x)$ derived from step $3$, for $N \\in \\{10,20,40,80\\}$ and $p \\in \\{1,2\\}$.\n- Test Case $2$: Manufactured solution $u_B(x) = e^{x}\\sin(2\\pi x)$ with $f_B(x)$ derived from step $3$, for $N \\in \\{10,20,40,80\\}$ and $p \\in \\{1,2\\}$.\n- For each test case, report four numbers: observed $L^2$-rate for $P1$, observed $H^1$-rate for $P1$, observed $L^2$-rate for $P2$, observed $H^1$-rate for $P2$. This yields a total of $8$ numbers.\n- Your program should produce a single line of output containing these $8$ results as a comma-separated list enclosed in square brackets, in the order\n$$ [r^{A}_{L^2,P1}, r^{A}_{H^1,P1}, r^{A}_{L^2,P2}, r^{A}_{H^1,P2}, r^{B}_{L^2,P1}, r^{B}_{H^1,P1}, r^{B}_{L^2,P2}, r^{B}_{H^1,P2}], $$\nwhere $r^{A/B}_{\\cdot,\\cdot}$ denotes the observed rate for Case $A$ or Case $B$. Print each number rounded to three decimal places.\n\nNo physical units are involved. All angles, when present in trigonometric arguments, are in radians. The final output must be exactly one line in the specified bracketed format.",
            "solution": "The problem is assessed to be **valid**. It is a well-posed, scientifically-grounded problem from the field of numerical analysis for partial differential equations, with a complete and consistent set of requirements.\n\n### 1. Derivation of the Weak Formulation\n\nThe strong form of the one-dimensional Poisson problem is given by:\n$$\n-u''(x) = f(x) \\quad \\text{for } x \\in (0,1)\n$$\nwith homogeneous Dirichlet boundary conditions $u(0) = 0$ and $u(1) = 0$.\n\nThe solution $u$ is sought in the Sobolev space $H_0^1(0,1)$. This space consists of functions defined on the interval $(0,1)$ that are square-integrable, have a square-integrable weak derivative, and satisfy the homogeneous boundary conditions $u(0)=u(1)=0$ in the sense of traces.\n\nTo derive the weak formulation, we multiply the partial differential equation by an arbitrary test function $v$ from the same space, $v \\in H_0^1(0,1)$, and integrate over the domain $\\Omega = (0,1)$:\n$$\n\\int_0^1 -u''(x) v(x) \\, dx = \\int_0^1 f(x) v(x) \\, dx\n$$\nWe apply integration by parts to the left-hand side term. The integration-by-parts formula states $\\int_a^b g'(x) h(x) \\, dx = [g(x)h(x)]_a^b - \\int_a^b g(x) h'(x) \\, dx$. Letting $g'(x) = u''(x)$ (so $g(x) = u'(x)$) and $h(x) = v(x)$, we have:\n$$\n\\int_0^1 u'(x) v'(x) \\, dx - [u'(x)v(x)]_0^1 = \\int_0^1 f(x) v(x) \\, dx\n$$\nSince the test function $v$ belongs to $H_0^1(0,1)$, it must satisfy the boundary conditions $v(0) = 0$ and $v(1) = 0$. Therefore, the boundary term vanishes:\n$$\n[u'(x)v(x)]_0^1 = u'(1)v(1) - u'(0)v(0) = u'(1) \\cdot 0 - u'(0) \\cdot 0 = 0\n$$\nThis leaves us with the weak formulation: Find $u \\in H_0^1(0,1)$ such that\n$$\n\\int_0^1 u'(x) v'(x) \\, dx = \\int_0^1 f(x) v(x) \\, dx \\quad \\forall v \\in H_0^1(0,1)\n$$\nThis equation can be written in the abstract form $a(u,v) = L(v)$, where:\n-   The solution space is $V = H_0^1(0,1)$.\n-   The bilinear form is $a(u,v) = \\int_0^1 u'(x) v'(x) \\, dx$.\n-   The linear functional is $L(v) = \\int_0^1 f(x) v(x) \\, dx$.\n\n### 2. The Galerkin Method\n\nThe Galerkin method seeks an approximate solution $u_h$ in a finite-dimensional subspace $V_h \\subset H_0^1(0,1)$. The problem specifies $V_h$ as the space of continuous, piecewise-polynomial functions of degree $p \\in \\{1,2\\}$ on a uniform mesh of $N$ subintervals of $[0,1]$. The mesh size is $h = 1/N$.\n\nThe discrete problem is: Find $u_h \\in V_h$ such that\n$$\na(u_h, v_h) = L(v_h) \\quad \\forall v_h \\in V_h\n$$\nLet $\\{\\phi_i\\}_{i=1}^{N_{dof}}$ be a basis for $V_h$, where $N_{dof}$ is the number of degrees of freedom (DoFs) corresponding to the interior nodes of the mesh.\n- For $P1$ elements ($p=1$), the DoFs are at the $N-1$ interior nodes $x_i = i/N$ for $i=1,\\dots,N-1$. Thus, $N_{dof} = N-1$.\n- For $P2$ elements ($p=2$), the DoFs are at the element vertices and midpoints. There are $2N+1$ nodes in total, so there are $2N-1$ interior nodes and $N_{dof} = 2N-1$.\n\nThe approximate solution $u_h$ is a linear combination of these basis functions:\n$$\nu_h(x) = \\sum_{j=1}^{N_{dof}} U_j \\phi_j(x)\n$$\nwhere $U_j$ are the unknown coefficients to be determined. Substituting this into the discrete problem and choosing the test functions to be the basis functions themselves, $v_h = \\phi_i$ for $i=1, \\dots, N_{dof}$, we obtain a system of linear equations:\n$$\n\\sum_{j=1}^{N_{dof}} U_j a(\\phi_j, \\phi_i) = L(\\phi_i) \\quad \\text{for } i = 1, \\dots, N_{dof}\n$$\nThis is a linear system $K U = F$, where:\n-   $U = [U_1, \\dots, U_{N_{dof}}]^T$ is the vector of unknown coefficients.\n-   $K$ is the stiffness matrix with entries $K_{ij} = a(\\phi_j, \\phi_i) = \\int_0^1 \\phi_j'(x) \\phi_i'(x) \\, dx$.\n-   $F$ is the load vector with entries $F_i = L(\\phi_i) = \\int_0^1 f(x) \\phi_i(x) \\, dx$.\n\nThe matrix $K$ and vector $F$ are assembled by summing contributions from each element of the mesh. Numerical quadrature is used to evaluate the integrals.\n\n### 3. Method of Manufactured Solutions\n\nWe manufacture solutions to test the implementation. For a chosen $u(x)$, the forcing function $f(x)$ is computed as $f(x) = -u''(x)$.\n\n-   **Case A:** $u_A(x) = \\sin(\\pi x)$\n    -   Boundary Conditions: $u_A(0) = \\sin(0) = 0$, $u_A(1) = \\sin(\\pi) = 0$. The conditions are satisfied.\n    -   Derivatives: $u_A'(x) = \\pi \\cos(\\pi x)$, $u_A''(x) = -\\pi^2 \\sin(\\pi x)$.\n    -   Forcing function: $f_A(x) = -u_A''(x) = \\pi^2 \\sin(\\pi x)$.\n\n-   **Case B:** $u_B(x) = e^{x}\\sin(2\\pi x)$\n    -   Boundary Conditions: $u_B(0) = e^0 \\sin(0) = 0$, $u_B(1) = e^1 \\sin(2\\pi) = 0$. The conditions are satisfied.\n    -   Derivatives:\n        $u_B'(x) = e^x\\sin(2\\pi x) + 2\\pi e^x\\cos(2\\pi x)$\n        $u_B''(x) = e^x(\\sin(2\\pi x) + 2\\pi\\cos(2\\pi x)) + e^x(2\\pi\\cos(2\\pi x) - 4\\pi^2\\sin(2\\pi x)) = e^x((1-4\\pi^2)\\sin(2\\pi x) + 4\\pi\\cos(2\\pi x))$\n    -   Forcing function: $f_B(x) = -u_B''(x) = -e^x((1-4\\pi^2)\\sin(2\\pi x) + 4\\pi\\cos(2\\pi x)) = e^x((4\\pi^2-1)\\sin(2\\pi x) - 4\\pi\\cos(2\\pi x))$.\n\n### 4. & 5. Implementation, Quadrature, and Error Calculation\n\nThe finite element method is implemented for $P1$ and $P2$ elements. The domain $[0,1]$ is divided into $N$ elements $[x_k, x_{k+1}]$ of size $h=1/N$. On each element, computations are performed on a reference element $[-1,1]$ using a coordinate transformation $x(\\xi) = x_k + \\frac{h}{2}(1+\\xi)$. The chain rule gives $\\frac{d}{dx} = \\frac{2}{h}\\frac{d}{d\\xi}$ and $dx = \\frac{h}{2}d\\xi$.\n\nIntegrals for the element stiffness matrix $K^k$ and load vector $F^k$ are computed using Gauss-Legendre quadrature with $8$ points $(\\xi_q, w_q)$:\n$$\nK^k_{ij} = \\int_{x_k}^{x_{k+1}} \\phi_j' \\phi_i' \\, dx = \\int_{-1}^1 \\left(\\frac{d\\hat{\\phi}_j}{d\\xi}\\frac{2}{h}\\right) \\left(\\frac{d\\hat{\\phi}_i}{d\\xi}\\frac{2}{h}\\right) \\frac{h}{2} \\, d\\xi \\approx \\frac{2}{h} \\sum_q w_q \\frac{d\\hat{\\phi}_j}{d\\xi}(\\xi_q) \\frac{d\\hat{\\phi}_i}{d\\xi}(\\xi_q)\n$$\n$$\nF^k_i = \\int_{x_k}^{x_{k+1}} f(x) \\phi_i(x) \\, dx = \\int_{-1}^1 f(x(\\xi)) \\hat{\\phi}_i(\\xi) \\frac{h}{2} \\, d\\xi \\approx \\frac{h}{2} \\sum_q w_q f(x(\\xi_q)) \\hat{\\phi}_i(\\xi_q)\n$$\nAfter solving the global system for the coefficients $U$, the numerical solution $u_h$ is known. The $L^2$-norm and $H^1$-seminorm errors are computed by summing element-wise contributions, also using Gauss quadrature:\n$$\n\\|u - u_h\\|_{L^2}^2 = \\sum_k \\int_{x_k}^{x_{k+1}} (u-u_h)^2 dx \\approx \\sum_k \\sum_q w_q (u(x_q) - u_h(x_q))^2 \\frac{h}{2}\n$$\n$$\n|u - u_h|_{H^1}^2 = \\sum_k \\int_{x_k}^{x_{k+1}} (u'-u_h')^2 dx \\approx \\sum_k \\sum_q w_q (u'(x_q) - u_h'(x_q))^2 \\frac{h}{2}\n$$\n\n### 6. Convergence Rate Estimation\n\nThe convergence rate is estimated using results from the two finest meshes ($N=40$ and $N=80$). Let $E(h)$ be the error on a mesh of size $h$. The rate is given by:\n$$\n\\text{rate} = \\frac{\\log(E(h_1)/E(h_2))}{\\log(h_1/h_2)}\n$$\nHere, $h_1 = 1/40$ and $h_2 = 1/80$, so $h_1/h_2 = 2$. The formula simplifies to $\\text{rate} = \\log_2(E_{40}/E_{80})$. For smooth solutions, the expected theoretical convergence rates are $p+1$ for the $L^2$-norm and $p$ for the $H^1$-seminorm. This means for $P1$ ($p=1$), we expect rates of $2$ ($L^2$) and $1$ ($H^1$), and for $P2$ ($p=2$), rates of $3$ ($L^2$) and $2$ ($H^1$).",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_reference_elements(p):\n    \"\"\"\n    Returns reference basis functions and their derivatives for polynomial degree p.\n    \n    Args:\n        p (int): Polynomial degree (1 or 2).\n\n    Returns:\n        tuple: A tuple containing a list of lambda functions for the basis functions\n               and a list of lambda functions for their derivatives on [-1, 1].\n    \"\"\"\n    if p == 1:\n        # P1: Linear Lagrange basis functions for nodes at -1, 1\n        phi_hat = [\n            lambda xi: 0.5 * (1.0 - xi),\n            lambda xi: 0.5 * (1.0 + xi)\n        ]\n        dphi_hat = [\n            lambda xi: -0.5,\n            lambda xi: 0.5\n        ]\n    elif p == 2:\n        # P2: Quadratic Lagrange basis functions for nodes at -1, 0, 1\n        phi_hat = [\n            lambda xi: 0.5 * xi * (xi - 1.0),\n            lambda xi: 1.0 - xi**2,\n            lambda xi: 0.5 * xi * (xi + 1.0)\n        ]\n        dphi_hat = [\n            lambda xi: xi - 0.5,\n            lambda xi: -2.0 * xi,\n            lambda xi: xi + 0.5\n        ]\n    else:\n        raise ValueError(\"Polynomial degree p must be 1 or 2.\")\n    return phi_hat, dphi_hat\n\ndef run_fem(u_exact, up_exact, f, N, p, num_quad_points=8):\n    \"\"\"\n    Solves the 1D Poisson problem using the Finite Element Method.\n\n    Args:\n        u_exact (callable): The exact solution function u(x).\n        up_exact (callable): The derivative of the exact solution u'(x).\n        f (callable): The forcing function f(x).\n        N (int): The number of subintervals (elements).\n        p (int): The polynomial degree of basis functions (1 or 2).\n        num_quad_points (int): The number of Gauss-Legendre quadrature points.\n\n    Returns:\n        tuple: A tuple containing the L2-norm error and the H1-seminorm error.\n    \"\"\"\n    h = 1.0 / N\n    phi_hat, dphi_hat = get_reference_elements(p)\n    num_local_dofs = p + 1\n\n    if p == 1:\n        num_dofs = N + 1\n        dof_map = lambda k: [k, k + 1]\n    else:  # p == 2\n        num_dofs = 2 * N + 1\n        dof_map = lambda k: [2 * k, 2 * k + 1, 2 * k + 2]\n\n    num_interior_dofs = num_dofs - 2\n    K = np.zeros((num_interior_dofs, num_interior_dofs))\n    F = np.zeros(num_interior_dofs)\n\n    xi_q, w_q = np.polynomial.legendre.leggauss(num_quad_points)\n\n    for k in range(N):\n        x_k = k * h\n        K_elem = np.zeros((num_local_dofs, num_local_dofs))\n        F_elem = np.zeros(num_local_dofs)\n\n        for q in range(num_quad_points):\n            xi, weight = xi_q[q], w_q[q]\n            x_val = x_k + 0.5 * h * (1.0 + xi)\n            \n            phi_vals_at_xi = np.array([phi(xi) for phi in phi_hat])\n            dphi_vals_at_xi = np.array([dphi(xi) for dphi in dphi_hat])\n\n            # K_ij = integral(phi_i' * phi_j') dx\n            K_elem += np.outer(dphi_vals_at_xi, dphi_vals_at_xi) * (2.0 / h) * weight\n\n            # F_i = integral(f * phi_i) dx\n            F_elem += f(x_val) * phi_vals_at_xi * (h / 2.0) * weight\n\n        global_dof_indices = dof_map(k)\n        for i in range(num_local_dofs):\n            gi = global_dof_indices[i]\n            if 1 = gi  num_dofs - 1:\n                F[gi - 1] += F_elem[i]\n                for j in range(num_local_dofs):\n                    gj = global_dof_indices[j]\n                    if 1 = gj  num_dofs - 1:\n                        K[gi - 1, gj - 1] += K_elem[i, j]\n\n    U_interior = np.linalg.solve(K, F)\n    U = np.zeros(num_dofs)\n    U[1:-1] = U_interior\n\n    l2_error_sq, h1_error_sq = 0.0, 0.0\n    for k in range(N):\n        x_k = k * h\n        global_dof_indices = dof_map(k)\n        U_local = U[global_dof_indices]\n\n        for q in range(num_quad_points):\n            xi, weight = xi_q[q], w_q[q]\n            x_val = x_k + 0.5 * h * (1.0 + xi)\n            \n            phi_vals_at_xi = np.array([phi(xi) for phi in phi_hat])\n            dphi_vals_at_xi = np.array([dphi(xi) for dphi in dphi_hat])\n\n            u_h = np.dot(U_local, phi_vals_at_xi)\n            u_h_prime = np.dot(U_local, dphi_vals_at_xi) * (2.0 / h)\n\n            l2_error_sq += (u_exact(x_val) - u_h)**2 * (h / 2.0) * weight\n            h1_error_sq += (up_exact(x_val) - u_h_prime)**2 * (h / 2.0) * weight\n\n    return np.sqrt(l2_error_sq), np.sqrt(h1_error_sq)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Case A: u(x) = sin(pi*x)\n    u_A = lambda x: np.sin(np.pi * x)\n    up_A = lambda x: np.pi * np.cos(np.pi * x)\n    f_A = lambda x: np.pi**2 * np.sin(np.pi * x)\n\n    # Case B: u(x) = exp(x)*sin(2*pi*x)\n    u_B = lambda x: np.exp(x) * np.sin(2.0 * np.pi * x)\n    up_B = lambda x: np.exp(x) * (np.sin(2.0 * np.pi * x) + 2.0 * np.pi * np.cos(2.0 * np.pi * x))\n    f_B = lambda x: -np.exp(x) * ((1.0 - 4.0 * np.pi**2) * np.sin(2.0 * np.pi * x) + 4.0 * np.pi * np.cos(2.0 * np.pi * x))\n    \n    test_cases = [\n        {'u': u_A, 'up': up_A, 'f': f_A},\n        {'u': u_B, 'up': up_B, 'f': f_B}\n    ]\n\n    mesh_resolutions = [10, 20, 40, 80]\n    p_degrees = [1, 2]\n    all_rates = []\n\n    for case in test_cases:\n        for p in p_degrees:\n            errors = {}\n            for N in mesh_resolutions:\n                l2_err, h1_err = run_fem(case['u'], case['up'], case['f'], N, p)\n                errors[N] = {'L2': l2_err, 'H1': h1_err}\n            \n            # Calculate rates using N=40 and N=80\n            N1, N2 = 40, 80\n            # h_ratio = h1/h2 = N2/N1\n            h_ratio = float(N2) / N1\n            \n            rate_l2 = np.log(errors[N1]['L2'] / errors[N2]['L2']) / np.log(h_ratio)\n            rate_h1 = np.log(errors[N1]['H1'] / errors[N2]['H1']) / np.log(h_ratio)\n            \n            all_rates.append(rate_l2)\n            all_rates.append(rate_h1)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join([f'{r:.3f}' for r in all_rates])}]\")\n\nsolve()\n```\n\n**Final Output:**\n```\n[2.004,1.001,3.001,2.000,2.003,1.001,3.001,2.000]\n```"
        }
    ]
}