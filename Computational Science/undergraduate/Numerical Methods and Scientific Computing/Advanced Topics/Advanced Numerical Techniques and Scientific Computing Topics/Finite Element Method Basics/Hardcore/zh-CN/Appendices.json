{
    "hands_on_practices": [
        {
            "introduction": "有限元方法的核心在于将复杂的连续域分解为简单的“单元”。这个练习将带你回到第一性原理，通过手工推导一个标准三角形单元的刚度矩阵和质量矩阵，从而打下坚实的基础。通过这个过程，你将深刻理解物理问题是如何被离散化并转化为可计算的代数形式的。",
            "id": "3229959",
            "problem": "考虑有限元方法（FEM）中使用的参考三角形，其顶点位于 $ (0,0) $、$ (1,0) $ 和 $ (0,1) $。令 $ T $ 表示该三角形，令 $ \\{N_1(x,y), N_2(x,y), N_3(x,y)\\} $ 为与三个顶点相关的线性拉格朗日形函数，其定义满足基本插值性质，即 $ N_i $ 在顶点 $ i $ 处等于 $ 1 $，在其他两个顶点处等于 $ 0 $。仅使用第一性原理和核心定义，按以下步骤进行：\n\n1. 推导 $ N_1(x,y) $、$ N_2(x,y) $ 和 $ N_3(x,y) $ 的符号表达式，并验证单位分解性 $ N_1 + N_2 + N_3 = 1 $ 和线性完备性（即，$ x $ 和 $ y $ 可以通过形函数的适当线性组合精确再生）。\n\n2. 使用解析积分 $ \\int_T 1 \\, \\mathrm{d}A $ 计算 $ T $ 的面积 $ A $ 并确认其值。\n\n3. 计算 $ T $ 上的常梯度 $ \\nabla N_1 $、$ \\nabla N_2 $ 和 $ \\nabla N_3 $，并通过直接积分验证由下式定义的单元刚度矩阵 $ K \\in \\mathbb{R}^{3 \\times 3} $ 的各项\n$$\nK_{ij} \\;=\\; \\int_T \\nabla N_i \\cdot \\nabla N_j \\, \\mathrm{d}A \\quad \\text{for } i,j \\in \\{1,2,3\\}.\n$$\n解释为什么 $ K $ 具有一维零空间。\n\n4. 通过解析积分计算由下式定义的一致单元质量矩阵 $ M \\in \\mathbb{R}^{3 \\times 3} $ 的各项\n$$\nM_{ij} \\;=\\; \\int_T N_i \\, N_j \\, \\mathrm{d}A \\quad \\text{for } i,j \\in \\{1,2,3\\}.\n$$\n\n你的最终任务是提供此三角形的质量矩阵 $ M $ 的行列式的精确值。将最终答案表示为一个无单位的实数。无需四舍五入。",
            "solution": "该问题是适定的，并且是有限元方法中的一个基础练习。我们按照要求进行系统的推导和计算。\n\n令参考三角形 $T$ 的顶点为 $P_1 = (0,0)$、$P_2 = (1,0)$ 和 $P_3 = (0,1)$。\n\n**1. 形函数的推导与性质验证**\n\n线性拉格朗日形函数 $N_i(x,y)$ 的一般形式为 $N_i(x,y) = a_i + b_i x + c_i y$。系数 $a_i, b_i, c_i$ 由基本插值性质 $N_i(P_j) = \\delta_{ij}$ 决定，其中 $\\delta_{ij}$ 是克罗内克（Kronecker）δ函数。\n\n对于与顶点 $P_1=(0,0)$ 相关的 $N_1(x,y)$：\n- $N_1(0,0) = a_1 = 1$\n- $N_1(1,0) = a_1 + b_1(1) + c_1(0) = 1 + b_1 = 0 \\implies b_1 = -1$\n- $N_1(0,1) = a_1 + b_1(0) + c_1(1) = 1 + c_1 = 0 \\implies c_1 = -1$\n因此，$N_1(x,y) = 1 - x - y$。\n\n对于与顶点 $P_2=(1,0)$ 相关的 $N_2(x,y)$：\n- $N_2(0,0) = a_2 = 0$\n- $N_2(1,0) = a_2 + b_2(1) + c_2(0) = b_2 = 1$\n- $N_2(0,1) = a_2 + b_2(0) + c_2(1) = a_2 + c_2 = 0 \\implies c_2 = 0$\n因此，$N_2(x,y) = x$。\n\n对于与顶点 $P_3=(0,1)$ 相关的 $N_3(x,y)$：\n- $N_3(0,0) = a_3 = 0$\n- $N_3(1,0) = a_3 + b_3(1) + c_3(0) = a_3 + b_3 = 0 \\implies b_3 = 0$\n- $N_3(0,1) = a_3 + b_3(0) + c_3(1) = c_3 = 1$\n因此，$N_3(x,y) = y$。\n\n推导出的形函数为 $N_1(x,y) = 1-x-y$，$N_2(x,y) = x$ 和 $N_3(x,y) = y$。这些是该三角形的重心坐标。\n\n单位分解性验证：\n$$ N_1(x,y) + N_2(x,y) + N_3(x,y) = (1-x-y) + x + y = 1 $$\n该和在整个平面上恒等于 $1$，因此验证了单位分解性。\n\n线性完备性验证：\n一个线性场 $f(x,y)=c_0 + c_1 x + c_2 y$ 可以表示为形函数的线性组合，$f(x,y) = \\sum_{i=1}^3 f(P_i) N_i(x,y)$。\n为了再生坐标函数 $x$，令 $f(x,y) = x$。节点值为 $f(P_1)=0$，$f(P_2)=1$，$f(P_3)=0$。\n$$ \\sum_{i=1}^3 x_i N_i(x,y) = (0)N_1(x,y) + (1)N_2(x,y) + (0)N_3(x,y) = N_2(x,y) = x $$\n为了再生坐标函数 $y$，令 $f(x,y) = y$。节点值为 $f(P_1)=0$，$f(P_2)=0$，$f(P_3)=1$。\n$$ \\sum_{i=1}^3 y_i N_i(x,y) = (0)N_1(x,y) + (0)N_2(x,y) + (1)N_3(x,y) = N_3(x,y) = y $$\n这证实了线性基底可以精确表示任何线性函数，满足线性完备性。\n\n**2. T 的面积计算**\n\n三角形 $T$ 的面积 $A$ 由在其域上对 $1$ 进行积分得到。该区域由 $0 \\le x \\le 1$ 和 $0 \\le y \\le 1-x$ 描述。\n$$ A = \\int_T 1 \\, \\mathrm{d}A = \\int_0^1 \\left( \\int_0^{1-x} 1 \\, \\mathrm{d}y \\right) \\mathrm{d}x $$\n$$ A = \\int_0^1 [y]_0^{1-x} \\, \\mathrm{d}x = \\int_0^1 (1-x) \\, \\mathrm{d}x = \\left[x - \\frac{x^2}{2}\\right]_0^1 = 1 - \\frac{1}{2} = \\frac{1}{2} $$\n面积为 $A = 1/2$，这与底为 $1$、高为 $1$ 的三角形的标准公式一致。\n\n**3. 单元刚度矩阵 K 的计算**\n\n首先，我们计算形函数的梯度：\n$$ \\nabla N_1 = \\begin{pmatrix} \\frac{\\partial N_1}{\\partial x} \\\\ \\frac{\\partial N_1}{\\partial y} \\end{pmatrix} = \\begin{pmatrix} -1 \\\\ -1 \\end{pmatrix} $$\n$$ \\nabla N_2 = \\begin{pmatrix} \\frac{\\partial N_2}{\\partial x} \\\\ \\frac{\\partial N_2}{\\partial y} \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} $$\n$$ \\nabla N_3 = \\begin{pmatrix} \\frac{\\partial N_3}{\\partial x} \\\\ \\frac{\\partial N_3}{\\partial y} \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} $$\n梯度是常数向量。刚度矩阵的项为 $K_{ij} = \\int_T \\nabla N_i \\cdot \\nabla N_j \\, \\mathrm{d}A$。由于被积函数 $\\nabla N_i \\cdot \\nabla N_j$ 在 $T$ 上是常数，该积分就是这个常数与面积 $A$ 的乘积。\n$$ K_{ij} = (\\nabla N_i \\cdot \\nabla N_j) A = \\frac{1}{2}(\\nabla N_i \\cdot \\nabla N_j) $$\n我们计算必要的点积：\n- $\\nabla N_1 \\cdot \\nabla N_1 = (-1)^2 + (-1)^2 = 2$\n- $\\nabla N_2 \\cdot \\nabla N_2 = 1^2 + 0^2 = 1$\n- $\\nabla N_3 \\cdot \\nabla N_3 = 0^2 + 1^2 = 1$\n- $\\nabla N_1 \\cdot \\nabla N_2 = (-1)(1) + (-1)(0) = -1$\n- $\\nabla N_1 \\cdot \\nabla N_3 = (-1)(0) + (-1)(1) = -1$\n- $\\nabla N_2 \\cdot \\nabla N_3 = (1)(0) + (0)(1) = 0$\n使用这些值以及对称性 $K_{ij}=K_{ji}$：\n$$ K = \\frac{1}{2} \\begin{pmatrix} 2 & -1 & -1 \\\\ -1 & 1 & 0 \\\\ -1 & 0 & 1 \\end{pmatrix} = \\begin{pmatrix} 1 & -1/2 & -1/2 \\\\ -1/2 & 1/2 & 0 \\\\ -1/2 & 0 & 1/2 \\end{pmatrix} $$\n矩阵 $K$ 具有一维零空间。如果 $K\\mathbf{u}=\\mathbf{0}$，则向量 $\\mathbf{u} = (u_1, u_2, u_3)^T$ 位于 $K$ 的零空间中。这对应于一个离散函数 $u_h(x,y) = \\sum_{i=1}^3 u_i N_i(x,y)$，其狄利克雷（Dirichlet）能量为零：\n$$ \\mathbf{u}^T K \\mathbf{u} = \\int_T \\nabla u_h \\cdot \\nabla u_h \\, \\mathrm{d}A = \\int_T |\\nabla u_h|^2 \\, \\mathrm{d}A = 0 $$\n由于被积函数是非负的，积分仅在 $\\nabla u_h = \\mathbf{0}$ 在 $T$ 中处处成立时才可能为零。这意味着 $u_h(x,y)$ 必须是一个常数函数，例如 $u_h(x,y) = c$。在顶点处求值，我们发现 $u_1=c$，$u_2=c$ 和 $u_3=c$。因此，零空间中的任何向量都必须是 $\\mathbf{u}=c(1,1,1)^T$ 的形式。这描述了一个由向量 $(1,1,1)^T$ 张成的一维子空间。该零空间对应于梯度为零的常数函数（例如，恒定势、刚体平移）。\n\n**4. 单元质量矩阵 M 的计算**\n\n质量矩阵的项为 $M_{ij} = \\int_T N_i N_j \\, \\mathrm{d}A$。我们使用三角形上重心坐标的积分公式：\n$$ \\int_T N_1^\\alpha N_2^\\beta N_3^\\gamma \\, \\mathrm{d}A = (2A) \\frac{\\alpha! \\beta! \\gamma!}{(\\alpha+\\beta+\\gamma+2)!} $$\n由于 $A = 1/2$，$2A=1$，公式简化为 $\\int_T N_1^\\alpha N_2^\\beta N_3^\\gamma \\, \\mathrm{d}A = \\frac{\\alpha! \\beta! \\gamma!}{(\\alpha+\\beta+\\gamma+2)!}$。\n\n对角线项：\n- $M_{11} = \\int_T N_1^2 \\, \\mathrm{d}A = \\frac{2!0!0!}{(2+0+0+2)!} = \\frac{2}{4!} = \\frac{2}{24} = \\frac{1}{12}$\n- $M_{22} = \\int_T N_2^2 \\, \\mathrm{d}A = \\frac{0!2!0!}{(0+2+0+2)!} = \\frac{2}{4!} = \\frac{2}{24} = \\frac{1}{12}$\n- $M_{33} = \\int_T N_3^2 \\, \\mathrm{d}A = \\frac{0!0!2!}{(0+0+2+2)!} = \\frac{2}{4!} = \\frac{2}{24} = \\frac{1}{12}$\n\n非对角线项（根据对称性 $M_{ij}=M_{ji}$）：\n- $M_{12} = \\int_T N_1 N_2 \\, \\mathrm{d}A = \\frac{1!1!0!}{(1+1+0+2)!} = \\frac{1}{4!} = \\frac{1}{24}$\n- $M_{13} = \\int_T N_1 N_3 \\, \\mathrm{d}A = \\frac{1!0!1!}{(1+0+1+2)!} = \\frac{1}{4!} = \\frac{1}{24}$\n- $M_{23} = \\int_T N_2 N_3 \\, \\mathrm{d}A = \\frac{0!1!1!}{(0+1+1+2)!} = \\frac{1}{4!} = \\frac{1}{24}$\n\n组装矩阵 $M$：\n$$ M = \\begin{pmatrix} 1/12 & 1/24 & 1/24 \\\\ 1/24 & 1/12 & 1/24 \\\\ 1/24 & 1/24 & 1/12 \\end{pmatrix} = \\frac{1}{24} \\begin{pmatrix} 2 & 1 & 1 \\\\ 1 & 2 & 1 \\\\ 1 & 1 & 2 \\end{pmatrix} $$\n\n**最终任务：M 的行列式计算**\n\n为了求 $M$ 的行列式，我们使用对于 $n \\times n$ 矩阵的性质 $\\det(c \\cdot A) = c^n \\det(A)$。这里，$c = 1/24$ 且 $n=3$。\n$$ \\det(M) = \\det\\left(\\frac{1}{24} \\begin{pmatrix} 2 & 1 & 1 \\\\ 1 & 2 & 1 \\\\ 1 & 1 & 2 \\end{pmatrix}\\right) = \\left(\\frac{1}{24}\\right)^3 \\det\\begin{pmatrix} 2 & 1 & 1 \\\\ 1 & 2 & 1 \\\\ 1 & 1 & 2 \\end{pmatrix} $$\n内部矩阵的行列式为：\n$$ \\det\\begin{pmatrix} 2 & 1 & 1 \\\\ 1 & 2 & 1 \\\\ 1 & 1 & 2 \\end{pmatrix} = 2(2 \\cdot 2 - 1 \\cdot 1) - 1(1 \\cdot 2 - 1 \\cdot 1) + 1(1 \\cdot 1 - 2 \\cdot 1) $$\n$$ = 2(3) - 1(1) + 1(-1) = 6 - 1 - 1 = 4 $$\n因此，质量矩阵的行列式为：\n$$ \\det(M) = \\left(\\frac{1}{24}\\right)^3 \\cdot 4 = \\frac{4}{24^3} = \\frac{4}{13824} = \\frac{1}{3456} $$",
            "answer": "$$\\boxed{\\frac{1}{3456}}$$"
        },
        {
            "introduction": "掌握了单个单元的理论后，下一步是将其组装成一个完整的求解器。本练习将指导你从零开始编写一个一维有限元方法的代码，并为每个关键模块设计诊断性测试。这不仅能让你熟悉从单元计算到全局组装和求解的完整流程，还能培养编写可靠数值程序的良好习惯。",
            "id": "3230085",
            "problem": "请从第一性原理出发，为模型边值问题实现一个一维有限元方法（FEM）代码：求解函数 $u$，使得在闭区间 $[0,1]$ 上有 $-u'' = f$，并满足齐次 Dirichlet 边界条件 $u(0)=0$ 和 $u(1)=0$。请从核心变分定义开始：在 Sobolev 空间 $H_0^1(0,1)$ 中找到 $u$，使得双线性形式和线性泛函满足\n$$\n\\int_0^1 u'(x)\\,v'(x)\\,dx = \\int_0^1 f(x)\\,v(x)\\,dx \\quad \\text{对所有 } v \\in H_0^1(0,1).\n$$\n使用一个由 $[0,1]$ 上的 $N$ 个均匀子区间构成的网格，在参考单元上使用线性 Lagrange 基函数，从参考单元到每个物理单元使用等参映射，并使用一个对次数最高为 $3$ 的多项式精确的 Gauss–Legendre 求积法则来近似计算单元积分。组装全局线性系统，并通过消除边界自由度来施加齐次 Dirichlet 边界条件。您的实现必须是模块化的，并且必须清晰地展示每一步：参考单元定义、形函数求值、数值求积、局部单元矩阵和向量计算、全局组装、边界条件应用以及线性求解器。\n\n仅从以下基本依据出发，推导出您实现中所需的所有公式：\n- 上述给出的弱（变分）形式。\n- 对于线性基函数 $\\{\\hat{\\varphi}_1,\\hat{\\varphi}_2\\}$，在参考单元 $[0,1]$ 上的 Lagrange 插值条件，该基函数在参考节点 $\\xi_1=0$ 和 $\\xi_2=1$ 处满足 $\\hat{\\varphi}_i(\\xi_j)=\\delta_{ij}$。\n- 在从参考单元到物理单元的仿射映射下，积分的变量替换公式。\n- 在 $[-1,1]$ 上的 Gauss–Legendre 求积节点和权重的定义，以及它们到 $[0,1]$ 的仿射变换。\n\n设计您的程序以计算一个诊断测试套件，用于验证各个组件和端到端解。请使用以下测试和约定：\n- 所有理论上精确的比较都应在 $10^{-14}$ 的绝对容差内进行验证。\n- 对于要求浮点数误差的测试，请在可能的情况下解析地计算精确值，并以非负实数的形式报告绝对误差。\n- 对于矩阵对称性，使用矩阵与其转置之差的 Frobenius 范数来量化对称性误差。\n\n需要实现并按此确切顺序报告的测试套件：\n1. 参考形函数：验证参考单元 $[0,1]$ 上线性 Lagrange 基函数的节点插值性质和单位分解性。具体来说，检查 $\\hat{\\varphi}_1(0)=1$、$\\hat{\\varphi}_2(0)=0$、$\\hat{\\varphi}_1(1)=0$、$\\hat{\\varphi}_2(1)=1$、$\\hat{\\varphi}_1(1/2)=\\hat{\\varphi}_2(1/2)$ 以及对于 $\\xi \\in \\{0,1/2,1\\}$，$\\hat{\\varphi}_1(\\xi)+\\hat{\\varphi}_2(\\xi)=1$。输出一个单一布尔值，当且仅当所有这些检查在规定的容差内通过时，该值为真。\n2. 求积精确性：在 $[0,1]$ 上使用一个 $2$ 点 Gauss–Legendre 法则，对 $k \\in \\{0,1,2,3\\}$ 的 $x^k$ 进行数值积分，并报告这 $4$ 种情况下的最大绝对误差（精确积分为 $\\int_0^1 x^k\\,dx = 1/(k+1)$）。\n3. 单位单元上的局部刚度矩阵：对于物理单元 $[0,1]$，使用您的参考基函数、映射和求积法则计算局部刚度矩阵。同时，通过对 $[0,1]$ 上形函数的梯度进行解析积分来计算精确的局部刚度矩阵。以非负实数的形式报告数值局部刚度矩阵与精确局部刚度矩阵之差的 Frobenius 范数。\n4. 粗网格上的端到端解精度：设置 $f(x) = \\pi^2 \\sin(\\pi x)$，使得精确解为 $u(x) = \\sin(\\pi x)$。在具有 $N=2$ 个单元的均匀网格上求解有限元系统。以非负实数的形式报告最大绝对节点误差 $\\max_i |u_h(x_i) - u(x_i)|$。\n5. 细网格上的端到端解精度：使用 $N=10$ 个单元重复测试 $4$，并以非负实数的形式报告最大绝对节点误差。\n6. 对称性与正定性：对于 $N=4$ 和 $f(x)=1$，在施加齐次 Dirichlet 边界条件后，组装约化后的全局刚度矩阵。输出一个单一布尔值，当且仅当约化后的矩阵在规定容差内是对称的，并且其所有特征值都严格为正时，该值为真。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按测试 $1$ 到 $6$ 的顺序包含结果，例如，$\\texttt{[result1,result2,result3,result4,result5,result6]}$。\n- 所有布尔值必须是字面值 $\\texttt{True}$ 或 $\\texttt{False}$，所有实数必须以标准十进制表示法打印。任何输出都不需要单位。",
            "solution": "用户要求从第一性原理出发，实现一个求解一维泊松方程的有限元方法（FEM）求解器。本文档概述了必要公式的理论推导，并遵循了指定的约束。\n\n### 1. 变分形式与离散化\n\n模型问题是在域 $\\Omega = [0,1]$ 上的边值问题（BVP）：\n$$ -u''(x) = f(x) \\quad \\text{对于 } x \\in (0,1) $$\n$$ u(0) = 0, \\quad u(1) = 0 $$\n有限元方法从弱（或变分）形式开始。我们将微分方程乘以一个来自合适函数空间的检验函数 $v$，然后在域上积分：\n$$ -\\int_0^1 u''(x) v(x) \\,dx = \\int_0^1 f(x) v(x) \\,dx $$\n对左侧应用分部积分可得：\n$$ \\int_0^1 u'(x) v'(x) \\,dx - [u'(x)v(x)]_0^1 = \\int_0^1 f(x) v(x) \\,dx $$\n我们在 Sobolev 空间 $H_0^1(0,1)$ 中寻找解 $u$，该空间由平方可积、一阶导数平方可积且满足齐次 Dirichlet 边界条件的函数组成。通过从同一空间 $H_0^1(0,1)$ 中选择检验函数 $v$，边界项 $[u'(x)v(x)]_0^1$ 因为 $v(0)=v(1)=0$ 而为零。这得到了所需的弱形式：找到 $u \\in H_0^1(0,1)$，使得\n$$ \\int_0^1 u'(x) v'(x) \\,dx = \\int_0^1 f(x) v(x) \\,dx \\quad \\text{对所有 } v \\in H_0^1(0,1) $$\nFEM 通过在有限维子空间 $V_h \\subset H_0^1(0,1)$ 中寻找近似解 $u_h$ 来离散化此问题。域 $[0,1]$ 被剖分为 $N$ 个长度为 $h=1/N$ 的均匀子区间（单元）$K_e = [x_e, x_{e+1}]$。此网格的节点为 $x_i = i h$，其中 $i=0, \\dots, N$。子空间 $V_h$ 由连续的分片线性基函数（“帽”函数）$\\phi_i(x)$ 张成，这些基函数定义为 $\\phi_i(x_j) = \\delta_{ij}$。近似解表示为这些基函数的线性组合：\n$$ u_h(x) = \\sum_{j=0}^{N} U_j \\phi_j(x) $$\n其中 $U_j=u_h(x_j)$ 是未知的节点值。Galerkin 方法将检验函数 $v$ 设置为基函数 $\\phi_i$，其中 $i=0, \\dots, N$。这导出一个线性方程组 $AU=F$，其中 $A_{ij} = \\int_0^1 \\phi_j'(x) \\phi_i'(x) \\,dx$ 且 $F_i = \\int_0^1 f(x) \\phi_i(x) \\,dx$。\n\n### 2. 参考单元、基函数和映射\n\n为了标准化计算，所有在物理单元 $K_e = [x_e, x_{e+1}]$ 上的积分都被变换到一个参考单元 $\\hat{K}=[0,1]$。\n\n**参考基函数**：在 $\\hat{K}$上，我们为对应于局部节点 $\\xi_1=0$ 和 $\\xi_2=1$ 的 $i=1,2$ 定义局部线性基函数 $\\hat{\\varphi}_i(\\xi)$。它们由 Lagrange 插值条件 $\\hat{\\varphi}_i(\\xi_j) = \\delta_{ij}$ 定义。\n对于 $\\hat{\\varphi}_1(\\xi) = a\\xi+b$：\n条件 $\\hat{\\varphi}_1(0)=1$ 和 $\\hat{\\varphi}_1(1)=0$ 得到 $b=1$ 和 $a=-1$。因此，$\\hat{\\varphi}_1(\\xi) = 1-\\xi$。\n对于 $\\hat{\\varphi}_2(\\xi) = c\\xi+d$：\n条件 $\\hat{\\varphi}_2(0)=0$ 和 $\\hat{\\varphi}_2(1)=1$ 得到 $d=0$ 和 $c=1$。因此，$\\hat{\\varphi}_2(\\xi) = \\xi$。\n这些参考基函数的导数是常数：$\\frac{d\\hat{\\varphi}_1}{d\\xi} = -1$ 和 $\\frac{d\\hat{\\varphi}_2}{d\\xi} = 1$。\n\n**等参映射**：仿射映射 $F_e: \\hat{K} \\to K_e$ 使用相同的基函数定义：$x(\\xi) = x_e \\hat{\\varphi}_1(\\xi) + x_{e+1} \\hat{\\varphi}_2(\\xi) = x_e(1-\\xi) + x_{e+1}\\xi$。对于均匀网格，这简化为 $x(\\xi) = x_e + h\\xi$。\n此变换的雅可比是 $J_e = \\frac{dx}{d\\xi} = h$。根据链式法则，关于 $x$ 的导数通过 $\\frac{d}{dx} = \\frac{d\\xi}{dx}\\frac{d}{d\\xi} = \\frac{1}{J_e}\\frac{d}{d\\xi} = \\frac{1}{h}\\frac{d}{d\\xi}$ 与关于 $\\xi$ 的导数相关联。\n\n### 3. 数值求积\n\n问题要求在 $[0,1]$ 上使用一个对次数最高为 $3$ 的多项式精确的 Gauss-Legendre 求积法则。一个 $n$ 点 Gauss-Legendre 法则对次数为 $2n-1$ 的多项式是精确的。因此，我们需要 $2n-1 \\geq 3$，这意味着 $n \\geq 2$。我们选择一个 $2$ 点法则。标准的节点 $\\hat{z}_k$ 和权重 $\\hat{w}_k$ 定义在 $[-1,1]$ 上：\n$$ \\hat{z}_1 = -1/\\sqrt{3}, \\quad \\hat{z}_2 = 1/\\sqrt{3} \\qquad \\hat{w}_1 = 1, \\quad \\hat{w}_2 = 1 $$\n我们使用仿射映射 $\\xi(\\hat{z}) = \\frac{1}{2}(\\hat{z}+1)$ 将它们变换到参考单元 $\\hat{K}=[0,1]$。此映射的雅可比是 $\\frac{d\\xi}{d\\hat{z}} = 1/2$。$[0,1]$ 上的求积节点 $\\xi_q$ 是 $\\hat{z}_k$ 的像，权重 $w_q$ 则乘以该雅可比：\n$$ \\xi_q = \\frac{1}{2}(\\hat{z}_q+1), \\quad w_q = \\hat{w}_q \\cdot \\frac{1}{2} $$\n这给出了法则 $\\int_0^1 g(\\xi) d\\xi \\approx \\sum_{q=1}^2 w_q g(\\xi_q)$，其中：\n- 节点：$\\xi_1 = \\frac{1}{2}(1 - 1/\\sqrt{3})$，$\\xi_2 = \\frac{1}{2}(1 + 1/\\sqrt{3})$。\n- 权重：$w_1 = 1/2$，$w_2 = 1/2$。\n\n### 4. 单元刚度矩阵和载荷向量\n\n全局刚度矩阵 $A$ 和载荷向量 $F$ 的条目是由单元级别的贡献组装而成的。\n\n**局部刚度矩阵**：对于一个单元 $K_e$，其 $2 \\times 2$ 的局部刚度矩阵 $A^{(e)}$ 的条目为 $A_{ij}^{(e)} = \\int_{K_e} (\\varphi_j^{(e)})'(x) (\\varphi_i^{(e)})'(x) \\,dx$，其中 $\\varphi_i^{(e)}$ 是局部基函数。变换到参考单元：\n$$ A_{ij}^{(e)} = \\int_0^1 \\left(\\frac{1}{h}\\frac{d\\hat{\\varphi}_j}{d\\xi}\\right) \\left(\\frac{1}{h}\\frac{d\\hat{\\varphi}_i}{d\\xi}\\right) h \\,d\\xi = \\frac{1}{h} \\int_0^1 \\frac{d\\hat{\\varphi}_i}{d\\xi} \\frac{d\\hat{\\varphi}_j}{d\\xi} \\,d\\xi $$\n由于参考基函数的导数是常数，被积函数是一个常数（0 次多项式）。我们的 $2$ 点求积法则对该积分是精确的。进行解析积分：\n$A_{11}^{(e)} = \\frac{1}{h} \\int_0^1 (-1)(-1) d\\xi = \\frac{1}{h}$，\n$A_{12}^{(e)} = A_{21}^{(e)} = \\frac{1}{h} \\int_0^1 (-1)(1) d\\xi = -\\frac{1}{h}$，\n$A_{22}^{(e)} = \\frac{1}{h} \\int_0^1 (1)(1) d\\xi = \\frac{1}{h}$。\n所以，局部刚度矩阵是 $A^{(e)} = \\frac{1}{h} \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}$。\n\n**局部载荷向量**：$2 \\times 1$ 的局部载荷向量 $F^{(e)}$ 的条目为 $F_i^{(e)} = \\int_{K_e} f(x) \\varphi_i^{(e)}(x) \\,dx$。变换到参考单元并应用求积法则：\n$$ F_i^{(e)} = \\int_0^1 f(x(\\xi)) \\hat{\\varphi}_i(\\xi) h \\,d\\xi \\approx h \\sum_{q=1}^2 w_q f(x_e + h \\xi_q) \\hat{\\varphi}_i(\\xi_q) $$\n\n### 5. 组装、边界条件和求解\n\n全局矩阵 $A$（尺寸 $(N+1) \\times (N+1)$）和 $F$（尺寸 $(N+1) \\times 1$）是通过对所有局部矩阵 $A^{(e)}$ 和向量 $F^{(e)}$ 的贡献求和来构建的。单元 $e$ 上的局部索引 $(1, 2)$ 映射到全局索引 $(e, e+1)$。\n\n齐次 Dirichlet 边界条件 $u(0)=0$ 和 $u(1)=0$ 意味着节点值 $U_0$ 和 $U_N$ 为零。这些自由度从线性系统中消除。这是通过从全局刚度矩阵 $A$ 中移除第一行和最后一行以及第一列和最后一列，并从全局载荷向量 $F$ 中移除第一个和最后一个条目来实现的。这产生了一个尺寸为 $(N-1) \\times (N-1)$ 的约化线性系统 $A_{red} U_{red} = F_{red}$，其中 $U_{red}=[U_1, \\dots, U_{N-1}]^T$。约化后的刚度矩阵 $A_{red}$ 是对称正定的，保证了唯一解。该系统被求解以获得未知的内部节点值。然后，完整的解向量被组装为 $U = [0, U_1, \\dots, U_{N-1}, 0]^T$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a 1D FEM solver and runs a diagnostic test suite.\n    \"\"\"\n    TOL = 1e-14\n\n    # ------------------ Core FEM Components ------------------\n\n    def get_reference_element_data():\n        \"\"\"\n        Defines basis functions and quadrature on the reference element [0,1].\n        \"\"\"\n        # Linear Lagrange basis functions and their derivatives on [0,1]\n        phi_hat = [lambda xi: 1 - xi, lambda xi: xi]\n        d_phi_hat = [lambda xi: -1.0, lambda xi: 1.0]\n\n        # 2-point Gauss-Legendre quadrature on [0,1]\n        # Transformed from standard rule on [-1,1]\n        quad_points = [0.5 * (1 - 1/np.sqrt(3)), 0.5 * (1 + 1/np.sqrt(3))]\n        quad_weights = [0.5, 0.5]\n\n        return phi_hat, d_phi_hat, quad_points, quad_weights\n\n    def compute_local_stiffness(h, d_phi_hat, quad_points, quad_weights):\n        \"\"\"\n        Numerically computes the 2x2 local stiffness matrix.\n        \"\"\"\n        A_local = np.zeros((2, 2))\n        for i in range(2):\n            for j in range(2):\n                integrand_val = 0\n                for q_idx in range(len(quad_points)):\n                    xi = quad_points[q_idx]\n                    w = quad_weights[q_idx]\n                    integrand_val += d_phi_hat[i](xi) * d_phi_hat[j](xi) * w\n                A_local[i, j] = (1/h) * integrand_val\n        return A_local\n\n    def compute_local_load(f, xe, h, phi_hat, quad_points, quad_weights):\n        \"\"\"\n        Numerically computes the 2x1 local load vector.\n        \"\"\"\n        F_local = np.zeros(2)\n        for i in range(2):\n            integrand_val = 0\n            for q_idx in range(len(quad_points)):\n                xi = quad_points[q_idx]\n                w = quad_weights[q_idx]\n                # Map reference coordinate xi to physical coordinate x\n                x = xe + h * xi\n                integrand_val += f(x) * phi_hat[i](xi) * w\n            F_local[i] = h * integrand_val\n        return F_local\n\n    def solve_bvp(N, f):\n        \"\"\"\n        Solves -u'' = f on [0,1] with u(0)=u(1)=0 using N elements.\n        \"\"\"\n        h = 1.0 / N\n        nodes = np.linspace(0, 1, N + 1)\n\n        phi_hat, d_phi_hat, quad_points, quad_weights = get_reference_element_data()\n\n        # Assembly\n        A_global = np.zeros((N + 1, N + 1))\n        F_global = np.zeros(N + 1)\n\n        for e in range(N):\n            xe = nodes[e]\n            A_local = compute_local_stiffness(h, d_phi_hat, quad_points, quad_weights)\n            F_local = compute_local_load(f, xe, h, phi_hat, quad_points, quad_weights)\n            \n            # Add local contributions to global matrices\n            global_indices = [e, e + 1]\n            for i in range(2):\n                for j in range(2):\n                    A_global[global_indices[i], global_indices[j]] += A_local[i, j]\n                F_global[global_indices[i]] += F_local[i]\n\n        # Apply homogeneous Dirichlet boundary conditions\n        interior_indices = slice(1, N)\n        A_reduced = A_global[interior_indices, interior_indices]\n        F_reduced = F_global[interior_indices]\n\n        # Solve the linear system\n        if A_reduced.shape[0] > 0:\n            U_reduced = np.linalg.solve(A_reduced, F_reduced)\n        else: # Case N=1, no interior nodes\n            U_reduced = np.array([])\n            \n        # Construct full solution vector\n        U_full = np.zeros(N + 1)\n        U_full[interior_indices] = U_reduced\n\n        return nodes, U_full, A_reduced\n\n    # ------------------ Test Suite ------------------\n    \n    results = []\n\n    # Test 1: Reference shape functions\n    def test_1():\n        phi_hat, _, _, _ = get_reference_element_data()\n        ph1, ph2 = phi_hat[0], phi_hat[1]\n        \n        c1 = abs(ph1(0.0) - 1.0) < TOL\n        c2 = abs(ph2(0.0) - 0.0) < TOL\n        c3 = abs(ph1(1.0) - 0.0) < TOL\n        c4 = abs(ph2(1.0) - 1.0) < TOL\n        c5 = abs(ph1(0.5) - ph2(0.5)) < TOL\n        \n        partition_of_unity_ok = True\n        for xi_test in [0.0, 0.5, 1.0]:\n            if abs(ph1(xi_test) + ph2(xi_test) - 1.0) > TOL:\n                partition_of_unity_ok = False\n                break\n        \n        return all([c1, c2, c3, c4, c5, partition_of_unity_ok])\n    results.append(test_1())\n\n    # Test 2: Quadrature exactness\n    def test_2():\n        _, _, quad_points, quad_weights = get_reference_element_data()\n        errors = []\n        for k in range(4): # k=0, 1, 2, 3\n            g = lambda x: x**k\n            exact_integral = 1.0 / (k + 1)\n            \n            numeric_integral = 0.0\n            for i in range(len(quad_points)):\n                numeric_integral += quad_weights[i] * g(quad_points[i])\n            \n            errors.append(abs(numeric_integral - exact_integral))\n        return max(errors)\n    results.append(test_2())\n\n    # Test 3: Local stiffness matrix on the unit element\n    def test_3():\n        _, d_phi_hat, quad_points, quad_weights = get_reference_element_data()\n        A_num = compute_local_stiffness(1.0, d_phi_hat, quad_points, quad_weights)\n        A_exact = np.array([[1.0, -1.0], [-1.0, 1.0]])\n        diff_norm = np.linalg.norm(A_num - A_exact, 'fro')\n        return diff_norm\n    results.append(test_3())\n\n    # Test 4  5: End-to-end solution accuracy\n    f_test = lambda x: np.pi**2 * np.sin(np.pi * x)\n    u_exact_func = lambda x: np.sin(np.pi * x)\n\n    def run_e2e_test(N, f, u_exact):\n        nodes, U_h, _ = solve_bvp(N, f)\n        u_exact_vals = u_exact(nodes)\n        nodal_errors = np.abs(U_h - u_exact_vals)\n        return np.max(nodal_errors)\n    \n    # Test 4\n    results.append(run_e2e_test(N=2, f=f_test, u_exact=u_exact_func))\n\n    # Test 5\n    results.append(run_e2e_test(N=10, f=f_test, u_exact=u_exact_func))\n\n    # Test 6: Symmetry and positive definiteness\n    def test_6():\n        _, _, A_red = solve_bvp(N=4, f=lambda x: 1.0)\n        \n        # Symmetry check\n        symmetry_error = np.linalg.norm(A_red - A_red.T, 'fro')\n        is_symmetric = symmetry_error  TOL\n        \n        # Positive definiteness check\n        eigenvalues = np.linalg.eigvalsh(A_red)\n        is_pd = np.all(eigenvalues  0)\n        \n        return is_symmetric and is_pd\n    results.append(test_6())\n    \n    # Final print statement\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "拥有了自己编写的求解器后，我们便可以探索一些更高级且在工程中至关重要的话题。本练习将聚焦于梁单元中的“剪切自锁”现象——一个经典的数值难题，并演示如何通过“缩减积分”技术来有效克服它。通过亲自实现和对比，你将体会到数值积分方案的选择对仿真结果物理真实性的深刻影响。",
            "id": "3230075",
            "problem": "您将实现一个简单的一维双节点 Timoshenko 梁有限元，并对剪切项使用带有选择性减缩积分的高斯求积 (GQ) 来演示剪切闭锁的缓解。剪切闭锁是指在细长梁极限情况下，Timoshenko 梁单元会变得过度剛硬的现象，因为离散插值无法在表示弯曲曲率的同时处处强制施加零剪切约束。对剪切项进行选择性欠积分可以减少与这种不兼容性相关的人为刚度。您的程序必须计算若干测试用例的尖端挠度，并比较两种积分策略。所有数学实体，包括符号、变量、函数、运算符和数字，都必须用 LaTeX 书写。\n\n从 Timoshenko 梁能量泛函开始。对于一根占据 $x \\in [0,L]$ 区间的梁，其横向位移为 $w(x)$，转角为 $\\varphi(x)$，应变度量为曲率 $\\kappa(x) = \\varphi'(x)$ 和剪切应变 $\\gamma(x) = w'(x) - \\varphi(x)$。总应变能为\n$$\nU = \\frac{1}{2}\\int_0^L \\left( E I \\, \\kappa(x)^2 + k \\, A \\, G \\, \\gamma(x)^2 \\right) \\, dx,\n$$\n其中 $E$ 是杨氏模量，$I$ 是面积二次矩，$k$ 是剪切修正因子，$A$ 是横截面积，$G$ 是剪切模量。\n\n使用有限元法 (FEM) 将梁离散化为 $n$ 个等长单元。每个单元的范围是 $x \\in [x_e, x_e + L_e]$，其中 $L_e = L/n$。对 $w(x)$ 和 $\\varphi(x)$ 均使用带有线性形函数的双节点单元。在母坐标 $\\xi \\in [-1,1]$ 中，形函数为 $N_1(\\xi) = \\frac{1}{2}(1-\\xi)$ 和 $N_2(\\xi) = \\frac{1}{2}(1+\\xi)$，坐标映射为 $x(\\xi) = \\frac{L_e}{2}\\xi + x_{\\text{mid}}$，其中 $dx/d\\xi = L_e/2$。插值形式为\n$$\nw(\\xi) = N_1(\\xi) \\, w_1 + N_2(\\xi) \\, w_2, \\quad\n\\varphi(\\xi) = N_1(\\xi) \\, \\varphi_1 + N_2(\\xi) \\, \\varphi_2,\n$$\n因此\n$$\nw'(x) = \\frac{w_2 - w_1}{L_e}, \\quad\n\\varphi'(x) = \\frac{\\varphi_2 - \\varphi_1}{L_e}, \\quad\n\\gamma(\\xi) = \\frac{w_2 - w_1}{L_e} - N_1(\\xi)\\varphi_1 - N_2(\\xi)\\varphi_2.\n$$\n对单元刚度的弯曲贡献来自于曲率项，并为转动自由度产生一个常数矩阵，而剪切贡献则需要对 $\\gamma(\\xi)^2$ 进行积分。您将使用高斯求积 (GQ) 通过两种策略计算剪切刚度：\n- 完全积分：在 $\\xi \\in [-1,1]$ 上使用标准的两点高斯求积，积分点为 $\\xi = \\pm \\frac{1}{\\sqrt{3}}$，权重为 $w = 1$，并包含雅可比行列式 $dx/d\\xi = L_e/2$。\n- 减缩积分：在 $\\xi \\in [-1,1]$ 上使用单点高斯求积，积分点为中点 $\\xi = 0$，权重为 $w = 2$，并包含雅可比行列式 $dx/d\\xi = L_e/2$；这仅应用于剪切项，而弯曲项则被精确积分。\n\n为一根在 $x=0$ 处固支（施加 $w(0)=0$ 和 $\\varphi(0)=0$）并在 $x=L$ 处承受单位大小为 $P$ 牛顿的尖端剪力（施加于最右侧节点的横向位移自由度上）的悬臂梁组装全局刚度矩阵。求解该线性系统，以获得两种积分策略下的尖端挠度 $w(L)$（单位为米）。\n\n对于每个测试用例，按如下方式计算参考尖端挠度（单位为米）：\n- 对于剪切可以忽略的细长梁，使用 Euler–Bernoulli 参考值 $\\delta_{\\mathrm{EB}} = \\dfrac{P L^3}{3 E I}$。\n- 对于包含剪切效应的一般梁，使用 Timoshenko 参考值 $\\delta_{\\mathrm{T}} = \\dfrac{P L^3}{3 E I} + \\dfrac{P L}{k A G}$。\n\n您的程序必须为每个测试用例产生两个浮点数：\n- 比率 $\\rho_{\\text{full}} = \\dfrac{\\delta_{\\text{full}}}{\\delta_{\\text{ref}}}$，其中 $\\delta_{\\text{full}}$ 是使用完全积分剪切项计算出的尖端挠度，$\\delta_{\\text{ref}}$ 是所选的参考挠度。\n- 比率 $\\rho_{\\text{red}} = \\dfrac{\\delta_{\\text{reduced}}}{\\delta_{\\text{ref}}}$，其中 $\\delta_{\\text{reduced}}$ 是使用减缩积分剪切项计算出的尖端挠度。\n\n输出必须是单行文本，包含所有测试用例的这些比率按顺序排列的展平列表，形式为方括号内以逗号分隔的列表，例如 $[r_1, r_2, r_3, r_4]$。\n\n必须一致地使用物理单位：$L$ 的单位是米，$b$ 和 $t$ 的单位是米，$A = b \\, t$ 的单位是平方米，$I = \\dfrac{b t^3}{12}$ 的单位是米的四次方，$E$ 和 $G$ 的单位是帕斯卡，$P$ 的单位是牛顿，所有挠度的单位都是米。\n\n请根据上述第一性原理实现计算，除了经过充分检验的高斯求积法则和标准的有限元组装方法外，不要使用任何简化推导路径的公式。不要硬编码任何解析刚度矩阵，除非它直接源于给定的应变-位移关系和能量泛函。\n\n测试套件：\n使用以下测试套件来评估和演示减缩积分对剪切闭锁的影响：\n- 案例 $1$（细长梁，粗网格，Euler–Bernoulli 参考值）：$L = 10$，$b = 0.1$，$t = 0.01$，$n = 1$，$P = 1000$，$E = 210\\times 10^9$，$G = 80\\times 10^9$，$k = \\dfrac{5}{6}$，参考类型 $\\mathrm{EB}$。\n- 案例 $2$（细长梁，细化网格，Euler–Bernoulli 参考值）：$L = 10$，$b = 0.1$，$t = 0.01$，$n = 20$，$P = 1000$，$E = 210\\times 10^9$，$G = 80\\times 10^9$，$k = \\dfrac{5}{6}$，参考类型 $\\mathrm{EB}$。\n- 案例 $3$（中等厚度梁，Timoshenko 参考值）：$L = 1$，$b = 0.1$，$t = 0.5$，$n = 4$，$P = 1000$，$E = 210\\times 10^9$，$G = 80\\times 10^9$，$k = \\dfrac{5}{6}$，参考类型 $\\mathrm{T}$。\n\n您的程序应生成单行输出，其中包含精确格式 $[\\rho_{\\text{full,1}},\\rho_{\\text{red,1}},\\rho_{\\text{full,2}},\\rho_{\\text{red,2}},\\rho_{\\text{full,3}},\\rho_{\\text{red,3}}]$ 的展平比率，每个条目都是一个浮点数。",
            "solution": "用户的请求是验证并解决一个关于实现一维 Timoshenko 梁有限元的问题。问题的核心是演示剪切闭锁现象及其通过选择性减缩积分得到的缓解。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n\n- **控制理论**：Timoshenko 梁理论。\n- **定义域**：一根长度为 $L$ 的梁，从 $x \\in [0,L]$。\n- **状态变量**：横向位移 $w(x)$，横截面转角 $\\varphi(x)$。\n- **应变度量**：曲率 $\\kappa(x) = \\varphi'(x)$，剪切应变 $\\gamma(x) = w'(x) - \\varphi(x)$。\n- **应变能泛函**：$U = \\frac{1}{2}\\int_0^L \\left( E I \\, \\kappa(x)^2 + k \\, A \\, G \\, \\gamma(x)^2 \\right) \\, dx$。\n- **材料/几何属性**：杨氏模量 $E$，面积二次矩 $I$，剪切修正因子 $k$，横截面积 $A$，剪切模量 $G$。\n- **有限元离散化**：\n    - $n$ 个等长单元，长度为 $L_e = L/n$。\n    - 双节点线性单元。\n    - 母坐标 $\\xi \\in [-1,1]$ 中的形函数：$N_1(\\xi) = \\frac{1}{2}(1-\\xi)$，$N_2(\\xi) = \\frac{1}{2}(1+\\xi)$。\n    - 坐标映射的雅可比行列式：$dx/d\\xi = L_e/2$。\n    - 位移 $w(\\xi) = N_1(\\xi)w_1 + N_2(\\xi)w_2$ 和转角 $\\varphi(\\xi) = N_1(\\xi)\\varphi_1 + N_2(\\xi)\\varphi_2$ 的节点插值。\n- **离散应变-位移关系**：$w'(x) = \\frac{w_2 - w_1}{L_e}$，$\\varphi'(x) = \\frac{\\varphi_2 - \\varphi_1}{L_e}$，$\\gamma(\\xi) = \\frac{w_2 - w_1}{L_e} - N_1(\\xi)\\varphi_1 - N_2(\\xi)\\varphi_2$。\n- **数值积分**：\n    - **弯曲项**：精确积分。\n    - **剪切项**：\n        - **完全积分**：两点高斯求积 (GQ)，积分点为 $\\xi = \\pm \\frac{1}{\\sqrt{3}}$，权重为 $w = 1$。\n        - **减缩积分**：单点高斯求积，积分点为 $\\xi = 0$，权重为 $w = 2$。\n- **边界条件**：悬臂梁。\n    - 在 $x=0$ 处固支：$w(0)=0$，$\\varphi(0)=0$。\n    - 在 $x=L$ 处受载：横向点力 $P$。\n- **参考解**：\n    - Euler-Bernoulli：$\\delta_{\\mathrm{EB}} = \\frac{P L^3}{3 E I}$。\n    - Timoshenko：$\\delta_{\\mathrm{T}} = \\frac{P L^3}{3 E I} + \\frac{P L}{k A G}$。\n- **输出指标**：对于每个案例，计算比率 $\\rho_{\\text{full}} = \\delta_{\\text{full}}/\\delta_{\\text{ref}}$ 和 $\\rho_{\\text{red}} = \\delta_{\\text{reduced}}/\\delta_{\\text{ref}}$。\n- **物理属性**：矩形截面，宽度为 $b$，厚度为 $t$，因此 $A = b t$，$I = \\frac{b t^3}{12}$。\n- **测试用例**：提供了三组特定的参数。\n\n**步骤 2：使用提取的已知条件进行验证**\n\n- **科学性**：该问题是计算固体力学中的一个典型案例研究，根植于成熟的 Timoshenko 梁理论和有限元方法。剪切闭锁和选择性减缩积分的概念是高等有限元课程中的标准和基础主题。\n- **适定性**：该问题是适定的。它描述了一个线性椭圆偏微分方程的离散化，具有足够的边界条件以确保唯一解的存在。由此产生的线性代数系统 $\\mathbf{K}\\mathbf{D}=\\mathbf{F}$ 是可解的。\n- **客观性**：该问题以完全客观的方式陈述，使用了精确的数学和工程术语。所有参数都得到了定义和量化，并且明确指定了所需的输出。\n- **完整性与一致性**：问题陈述是自洽的，提供了进行完整求解所需的所有数据、方程、边界条件和测试参数。没有内部矛盾。\n- **真实性**：材料的物理参数（$E$，$G$）代表了钢材。几何和加载条件是结构分析基准测试中的标准条件。\n\n**步骤 3：结论与行动**\n\n该问题是**有效的**。它是一个定义明确、科学合理的工程数值方法问题。将按要求进行求解。\n\n### 解法\n\n该解法需要实现一个 Timoshenko 梁的有限元模型。该过程涉及推导单元刚度矩阵、组装全局系统、施加边界条件以及求解节点位移。为了研究剪切闭锁，将针对剪切项采用两种不同的数值积分方案来完成此过程。\n\n**1. 单元构建**\n应变能 $U$ 是弯曲能 $U_b$ 和剪切能 $U_s$ 的总和：\n$U = U_b + U_s = \\frac{1}{2}\\int_0^{L_e} EI (\\varphi')^2 dx + \\frac{1}{2}\\int_0^{L_e} kAG \\gamma^2 dx$。\n单元刚度矩阵 $\\mathbf{K}^e$ 是弯曲刚度 $\\mathbf{K}_b^e$ 和剪切刚度 $\\mathbf{K}_s^e$ 的和。单元节点自由度 (DOFs) 为 $\\mathbf{d}^e = [w_1, \\varphi_1, w_2, \\varphi_2]^T$。\n\n**2. 弯曲刚度矩阵 $\\mathbf{K}_b^e$**\n对于线性形函数，转角梯度 $\\varphi'(x) = (\\varphi_2 - \\varphi_1)/L_e$ 在单元内是常数。弯曲能积分是精确的：\n$U_b = \\frac{1}{2} EI \\left(\\frac{\\varphi_2 - \\varphi_1}{L_e}\\right)^2 L_e = \\frac{1}{2} \\frac{EI}{L_e} (\\varphi_2 - \\varphi_1)^2$。\n此能量对应于弯曲刚度矩阵 $\\mathbf{K}_b^e$：\n$$\n\\mathbf{K}_b^e = \\frac{E I}{L_e}\n\\begin{bmatrix}\n0  0  0  0 \\\\\n0  1  0  -1 \\\\\n0  0  0  0 \\\\\n0  -1  0  1\n\\end{bmatrix}\n$$\n\n**3. 剪切刚度矩阵 $\\mathbf{K}_s^e$**\n剪切应变为 $\\gamma(\\xi) = \\frac{w_2 - w_1}{L_e} - (N_1(\\xi)\\varphi_1 + N_2(\\xi)\\varphi_2)$。剪切能通过数值积分计算：\n$U_s = \\frac{1}{2} \\int_{-1}^{1} kAG (\\gamma(\\xi))^2 \\frac{L_e}{2} d\\xi$。\n剪切刚度矩阵为 $\\mathbf{K}_s^e = \\int_{-1}^1 \\mathbf{B}_s(\\xi)^T (kAG) \\mathbf{B}_s(\\xi) \\frac{L_e}{2} d\\xi$，其中 $\\mathbf{B}_s(\\xi)$ 是剪切应变-位移矩阵。\n\n- **完全积分（两点高斯求积）**：两点高斯求积对最高三次的多项式是精确的。$\\mathbf{K}_s^e$ 的被积函数包含最高 $\\xi^2$ 的项（来自 $N_i(\\xi)N_j(\\xi)$），因此两点高斯求积为此公式提供了精确积分。结果如下：\n$$\n\\mathbf{K}_{s, \\text{full}}^e = k A G\n\\begin{bmatrix}\n1/L_e  1/2  -1/L_e  1/2 \\\\\n1/2  L_e/3  -1/2  L_e/6 \\\\\n-1/L_e  -1/2  1/L_e  -1/2 \\\\\n1/2  L_e/6  -1/2  L_e/3\n\\end{bmatrix}\n$$\n对于细长梁，此公式会产生过度刚硬的结果，这一现象被称为剪切闭锁。单元试图在两个不同的点上强制施加零剪切条件（$\\gamma=0$），这会过度约束运动学场并阻止其产生正确的弯曲变形。\n\n- **减缩积分（单点高斯求积）**：单点高斯求积仅使用中点 $\\xi=0$，在该点 $\\gamma(0) = \\frac{w_2-w_1}{L_e} - \\frac{\\varphi_1+\\varphi_2}{2}$。这种积分是近似的，仅在该点计算被积函数的值。这会产生一个不同的刚度矩阵：\n$$\n\\mathbf{K}_{s, \\text{red}}^e = k A G\n\\begin{bmatrix}\n 1/L_e  1/2  -1/L_e  1/2 \\\\\n 1/2  L_e/4  -1/2  L_e/4 \\\\\n-1/L_e  -1/2  1/L_e  -1/2 \\\\\n 1/2  L_e/4  -1/2  L_e/4\n\\end{bmatrix}\n$$\n该矩阵是秩亏的且刚度较小。通过仅在单元中心施加剪切约束，它允许了否则会受到惩罚的弯曲变形，从而缓解了剪切闭锁。\n\n**4. 全局组装与求解**\n总单元刚度矩阵为 $\\mathbf{K}^e = \\mathbf{K}_b^e + \\mathbf{K}_s^e$（使用 $\\mathbf{K}_{s, \\text{full}}^e$ 或 $\\mathbf{K}_{s, \\text{red}}^e$）。这些单元矩阵被组装成整个梁（$n$ 个单元，$n+1$ 个节点）的全局刚度矩阵 $\\mathbf{K}$。全局系统为 $\\mathbf{K}\\mathbf{D} = \\mathbf{F}$，其中 $\\mathbf{D}$ 是所有节点自由度的向量，$\\mathbf{F}$ 是全局力向量。\n- **边界条件**：对于悬臂梁，固支端（$x=0$）的自由度是固定的：$w(0)=0$，$\\varphi(0)=0$。这通过修改全局矩阵 $\\mathbf{K}$ 和力向量 $\\mathbf{F}$ 来施加。\n- **载荷**：在自由端（$x=L$），一个点力 $P$ 被施加到横向位移自由度上。修改后，求解系统以获得位移向量 $\\mathbf{D}$。尖端挠度是最后一个节点的横向位移。\n\n**5. 测试用例分析**\n代码为每个指定的测试用例实现了此过程，分别使用完全积分和减缩积分各计算一次。\n- **案例 1（细长梁，$n=1$）**：一个非常细长的梁（$L/t = 1000$），使用单个单元。这是剪切闭锁的典型案例。预计完全积分会产生极度刚硬的响应（挠度远小于实际值，因此 $\\rho_{\\text{full}} \\ll 1$），而减缩积分应提供更合理的结果（$\\rho_{\\text{red}}$ 接近 $1$）。\n- **案例 2（细长梁，$n=20$）**：同样的细长梁，但使用细化的网格（$L_e/t = 50$）。通过使用更小的单元，即使是完全积分的单元也能更好地近似弯曲行为。剪切闭锁将显著减少，$\\rho_{\\text{full}}$ 和 $\\rho_{\\text{red}}$ 都应接近 $1$。\n- **案例 3（厚梁，$n=4$）**：一个短而厚的梁（$L/t=2$），其剪切变形显著，必须精确建模。Timoshenko 理论在此处适用。由于剪切效应是真实存在的，预计更精确的完全积分和减缩积分都会表现良好。两个比率都应接近 $1$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes tip deflections for a cantilevered Timoshenko beam using Finite Element Method\n    with both full and selective reduced integration to demonstrate shear locking.\n    \"\"\"\n\n    def _compute_tip_deflection(L, b, t, n_elements, P, E, G, k, integration_type):\n        \"\"\"\n        Calculates the tip deflection of a cantilever beam for a given integration scheme.\n\n        Args:\n            L (float): Beam length (m)\n            b (float): Cross-section width (m)\n            t (float): Cross-section thickness (m)\n            n_elements (int): Number of finite elements\n            P (float): Tip load (N)\n            E (float): Young's modulus (Pa)\n            G (float): Shear modulus (Pa)\n            k (float): Shear correction factor\n            integration_type (str): 'full' or 'reduced'\n\n        Returns:\n            float: Tip deflection (m)\n        \"\"\"\n        # 1. Geometric and Material Properties\n        A = b * t\n        I = (b * t**3) / 12.0\n        Le = L / n_elements\n\n        # 2. Element Stiffness Matrix Formulation\n        # Bending stiffness matrix (constant for both integration schemes)\n        # Directly derived from 1/2 * (EI/Le) * (phi2-phi1)^2\n        K_b_e = (E * I / Le) * np.array([\n            [0.,  0., 0.,  0.],\n            [0.,  1., 0., -1.],\n            [0.,  0., 0.,  0.],\n            [0., -1., 0.,  1.]\n        ])\n\n        # Shear stiffness matrix (dependent on integration scheme)\n        # Derived from integral of kAG * gamma^2 * (Le/2) d_xi\n        # where gamma = (w2-w1)/Le - (N1*phi1 + N2*phi2)\n        # N1 = (1-xi)/2, N2 = (1+xi)/2\n        if integration_type == 'full':\n            # Full (2-point) Gaussian Quadrature gives the exact integral for this case\n            K_s_e = (k * A * G) * np.array([\n                [1. / Le,   0.5,      -1. / Le,   0.5],\n                [0.5,       Le / 3.0, -0.5,       Le / 6.0],\n                [-1. / Le,  -0.5,      1. / Le,  -0.5],\n                [0.5,       Le / 6.0, -0.5,       Le / 3.0]\n            ])\n        elif integration_type == 'reduced':\n            # Reduced (1-point) Gaussian Quadrature (evaluate at xi=0)\n            K_s_e = (k * A * G) * np.array([\n                [1. / Le,   0.5,      -1. / Le,   0.5],\n                [0.5,       Le / 4.0, -0.5,       Le / 4.0],\n                [-1. / Le,  -0.5,      1. / Le,  -0.5],\n                [0.5,       Le / 4.0, -0.5,       Le / 4.0]\n            ])\n        else:\n            raise ValueError(\"integration_type must be 'full' or 'reduced'\")\n\n        # Total element stiffness matrix\n        K_e = K_b_e + K_s_e\n\n        # 3. Global Matrix Assembly\n        n_nodes = n_elements + 1\n        n_dof = 2 * n_nodes\n        K_global = np.zeros((n_dof, n_dof))\n\n        for i in range(n_elements):\n            dof_indices = [2 * i, 2 * i + 1, 2 * (i + 1), 2 * (i + 1) + 1]\n            for r_local, r_global in enumerate(dof_indices):\n                for c_local, c_global in enumerate(dof_indices):\n                    K_global[r_global, c_global] += K_e[r_local, c_local]\n\n        # 4. Global Force Vector and Boundary Conditions\n        F_global = np.zeros(n_dof)\n        \n        # Apply tip load P at the transverse DOF of the last node\n        tip_dof_idx = 2 * n_elements # This is the w-dof of the last node (node n_elements)\n        F_global[tip_dof_idx] = P\n\n        # Apply clamped boundary conditions at x=0 (w(0)=0, phi(0)=0)\n        # Using the penalty method would be another option, but elimination is simple here.\n        # We modify the matrix to enforce D[0]=0 and D[1]=0\n        # This is equivalent to removing rows/cols 0 and 1\n        # For simplicity of implementation, we set diagonal to 1 and off-diagonals to 0\n        K_global[0, :] = 0.0\n        K_global[:, 0] = 0.0\n        K_global[0, 0] = 1.0\n        F_global[0] = 0.0\n\n        K_global[1, :] = 0.0\n        K_global[:, 1] = 0.0\n        K_global[1, 1] = 1.0\n        F_global[1] = 0.0\n\n        # 5. Solve the Linear System\n        displacements = np.linalg.solve(K_global, F_global)\n\n        # 6. Return Tip Deflection\n        return displacements[tip_dof_idx]\n\n    # --- Main Execution Logic ---\n    test_cases = [\n        # (L, b, t, n_elements, P, E, G, k, ref_type)\n        (10.0, 0.1, 0.01, 1, 1000.0, 210e9, 80e9, 5.0/6.0, 'EB'),\n        (10.0, 0.1, 0.01, 20, 1000.0, 210e9, 80e9, 5.0/6.0, 'EB'),\n        (1.0, 0.1, 0.5, 4, 1000.0, 210e9, 80e9, 5.0/6.0, 'T'),\n    ]\n\n    results = []\n    for case in test_cases:\n        L, b, t, n, P, E, G, k, ref_type = case\n\n        # Calculate properties\n        I = (b * t**3) / 12.0\n        A = b * t\n\n        # Calculate reference deflection\n        delta_EB = (P * L**3) / (3.0 * E * I)\n        if ref_type == 'EB':\n            delta_ref = delta_EB\n        elif ref_type == 'T':\n            delta_T = delta_EB + (P * L) / (k * A * G)\n            delta_ref = delta_T\n        else:\n            raise ValueError(f\"Invalid reference type: {ref_type}\")\n\n        # Compute FEM solutions\n        delta_full = _compute_tip_deflection(L, b, t, n, P, E, G, k, 'full')\n        delta_reduced = _compute_tip_deflection(L, b, t, n, P, E, G, k, 'reduced')\n        \n        # Compute and store the ratios\n        rho_full = delta_full / delta_ref\n        rho_red = delta_reduced / delta_ref\n        results.extend([rho_full, rho_red])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}