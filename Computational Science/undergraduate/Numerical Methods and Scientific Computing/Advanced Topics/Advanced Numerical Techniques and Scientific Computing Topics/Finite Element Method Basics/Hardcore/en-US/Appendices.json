{
    "hands_on_practices": [
        {
            "introduction": "The heart of the Finite Element Method lies in the formulation of individual elements. This first practice takes you through the fundamental, from-scratch derivation of the elemental matrices for a classic linear triangle . By deriving the shape functions and computing the stiffness and mass matrices analytically, you will gain a tangible understanding of how the abstract concepts of the weak form are translated into the concrete algebraic components used in a computer simulation.",
            "id": "3229959",
            "problem": "Consider the reference triangle used in the Finite Element Method (FEM), with vertices at $ (0,0) $, $ (1,0) $, and $ (0,1) $. Let $ T $ denote this triangle and let $ \\{N_1(x,y), N_2(x,y), N_3(x,y)\\} $ be the linear Lagrange shape functions associated with the three vertices, defined by the fundamental interpolation property that $ N_i $ equals $ 1 $ at vertex $ i $ and $ 0 $ at the other two vertices. Using only first principles and core definitions, proceed as follows:\n\n1. Derive symbolic expressions for $ N_1(x,y) $, $ N_2(x,y) $, and $ N_3(x,y) $, and verify the partition of unity $ N_1 + N_2 + N_3 = 1 $ and linear completeness (i.e., that $ x $ and $ y $ are reproduced exactly by appropriate linear combinations of the shape functions).\n\n2. Compute the area $ A $ of $ T $ using an analytical integral $ \\int_T 1 \\, \\mathrm{d}A $ and confirm its value.\n\n3. Compute the constant gradients $ \\nabla N_1 $, $ \\nabla N_2 $, and $ \\nabla N_3 $ over $ T $ and verify, by direct integration, the entries of the elemental stiffness matrix $ K \\in \\mathbb{R}^{3 \\times 3} $ defined by\n$$\nK_{ij} \\;=\\; \\int_T \\nabla N_i \\cdot \\nabla N_j \\, \\mathrm{d}A \\quad \\text{for } i,j \\in \\{1,2,3\\}.\n$$\nExplain why $ K $ has a one-dimensional null space.\n\n4. Compute, by analytical integration, the entries of the consistent elemental mass matrix $ M \\in \\mathbb{R}^{3 \\times 3} $ defined by\n$$\nM_{ij} \\;=\\; \\int_T N_i \\, N_j \\, \\mathrm{d}A \\quad \\text{for } i,j \\in \\{1,2,3\\}.\n$$\n\nYour final task is to provide the exact value of the determinant of the mass matrix $ M $ for this triangle. Express the final answer as a single real number with no units. No rounding is required.",
            "solution": "The problem is well-posed and represents a fundamental exercise in the Finite Element Method. We proceed with a systematic derivation and calculation as requested.\n\nLet the vertices of the reference triangle $T$ be $P_1 = (0,0)$, $P_2 = (1,0)$, and $P_3 = (0,1)$.\n\n**1. Derivation of Shape Functions and Verification of Properties**\n\nA linear Lagrange shape function $N_i(x,y)$ has the general form $N_i(x,y) = a_i + b_i x + c_i y$. The coefficients $a_i, b_i, c_i$ are determined by the fundamental interpolation property $N_i(P_j) = \\delta_{ij}$, where $\\delta_{ij}$ is the Kronecker delta.\n\nFor $N_1(x,y)$, associated with vertex $P_1=(0,0)$:\n- $N_1(0,0) = a_1 = 1$\n- $N_1(1,0) = a_1 + b_1(1) + c_1(0) = 1 + b_1 = 0 \\implies b_1 = -1$\n- $N_1(0,1) = a_1 + b_1(0) + c_1(1) = 1 + c_1 = 0 \\implies c_1 = -1$\nThus, $N_1(x,y) = 1 - x - y$.\n\nFor $N_2(x,y)$, associated with vertex $P_2=(1,0)$:\n- $N_2(0,0) = a_2 = 0$\n- $N_2(1,0) = a_2 + b_2(1) + c_2(0) = b_2 = 1$\n- $N_2(0,1) = a_2 + b_2(0) + c_2(1) = a_2 + c_2 = 0 \\implies c_2 = 0$\nThus, $N_2(x,y) = x$.\n\nFor $N_3(x,y)$, associated with vertex $P_3=(0,1)$:\n- $N_3(0,0) = a_3 = 0$\n- $N_3(1,0) = a_3 + b_3(1) + c_3(0) = a_3 + b_3 = 0 \\implies b_3 = 0$\n- $N_3(0,1) = a_3 + b_3(0) + c_3(1) = c_3 = 1$\nThus, $N_3(x,y) = y$.\n\nThe derived shape functions are $N_1(x,y) = 1-x-y$, $N_2(x,y) = x$, and $N_3(x,y) = y$. These are the barycentric coordinates for this triangle.\n\nVerification of partition of unity:\n$$ N_1(x,y) + N_2(x,y) + N_3(x,y) = (1-x-y) + x + y = 1 $$\nThe sum is identically $1$ over the entire plane, thus verifying the partition of unity property.\n\nVerification of linear completeness:\nA linear field $f(x,y)=c_0 + c_1 x + c_2 y$ can be represented as a linear combination of shape functions, $f(x,y) = \\sum_{i=1}^3 f(P_i) N_i(x,y)$.\nTo reproduce the coordinate function $x$, let $f(x,y) = x$. The nodal values are $f(P_1)=0$, $f(P_2)=1$, $f(P_3)=0$.\n$$ \\sum_{i=1}^3 x_i N_i(x,y) = (0)N_1(x,y) + (1)N_2(x,y) + (0)N_3(x,y) = N_2(x,y) = x $$\nTo reproduce the coordinate function $y$, let $f(x,y) = y$. The nodal values are $f(P_1)=0$, $f(P_2)=0$, $f(P_3)=1$.\n$$ \\sum_{i=1}^3 y_i N_i(x,y) = (0)N_1(x,y) + (0)N_2(x,y) + (1)N_3(x,y) = N_3(x,y) = y $$\nThis confirms that the linear basis can exactly represent any linear function, satisfying linear completeness.\n\n**2. Computation of the Area of T**\n\nThe area $A$ of the triangle $T$ is given by the integral of $1$ over its domain. The domain is described by $0 \\le x \\le 1$ and $0 \\le y \\le 1-x$.\n$$ A = \\int_T 1 \\, \\mathrm{d}A = \\int_0^1 \\left( \\int_0^{1-x} 1 \\, \\mathrm{d}y \\right) \\mathrm{d}x $$\n$$ A = \\int_0^1 [y]_0^{1-x} \\, \\mathrm{d}x = \\int_0^1 (1-x) \\, \\mathrm{d}x = \\left[x - \\frac{x^2}{2}\\right]_0^1 = 1 - \\frac{1}{2} = \\frac{1}{2} $$\nThe area is $A = 1/2$, which is consistent with the standard formula for a triangle with base $1$ and height $1$.\n\n**3. Computation of the Elemental Stiffness Matrix K**\n\nFirst, we compute the gradients of the shape functions:\n$$ \\nabla N_1 = \\begin{pmatrix} \\frac{\\partial N_1}{\\partial x} \\\\ \\frac{\\partial N_1}{\\partial y} \\end{pmatrix} = \\begin{pmatrix} -1 \\\\ -1 \\end{pmatrix} $$\n$$ \\nabla N_2 = \\begin{pmatrix} \\frac{\\partial N_2}{\\partial x} \\\\ \\frac{\\partial N_2}{\\partial y} \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} $$\n$$ \\nabla N_3 = \\begin{pmatrix} \\frac{\\partial N_3}{\\partial x} \\\\ \\frac{\\partial N_3}{\\partial y} \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} $$\nThe gradients are constant vectors. The entries of the stiffness matrix are $K_{ij} = \\int_T \\nabla N_i \\cdot \\nabla N_j \\, \\mathrm{d}A$. Since the integrand $\\nabla N_i \\cdot \\nabla N_j$ is constant over $T$, the integral is simply the product of this constant and the area $A$.\n$$ K_{ij} = (\\nabla N_i \\cdot \\nabla N_j) A = \\frac{1}{2}(\\nabla N_i \\cdot \\nabla N_j) $$\nWe compute the necessary dot products:\n- $\\nabla N_1 \\cdot \\nabla N_1 = (-1)^2 + (-1)^2 = 2$\n- $\\nabla N_2 \\cdot \\nabla N_2 = 1^2 + 0^2 = 1$\n- $\\nabla N_3 \\cdot \\nabla N_3 = 0^2 + 1^2 = 1$\n- $\\nabla N_1 \\cdot \\nabla N_2 = (-1)(1) + (-1)(0) = -1$\n- $\\nabla N_1 \\cdot \\nabla N_3 = (-1)(0) + (-1)(1) = -1$\n- $\\nabla N_2 \\cdot \\nabla N_3 = (1)(0) + (0)(1) = 0$\nUsing these values, and the symmetry $K_{ij}=K_{ji}$:\n$$ K = \\frac{1}{2} \\begin{pmatrix} 2  -1  -1 \\\\ -1  1  0 \\\\ -1  0  1 \\end{pmatrix} = \\begin{pmatrix} 1  -1/2  -1/2 \\\\ -1/2  1/2  0 \\\\ -1/2  0  1/2 \\end{pmatrix} $$\nThe matrix $K$ has a one-dimensional null space. A vector $\\mathbf{u} = (u_1, u_2, u_3)^T$ is in the null space of $K$ if $K\\mathbf{u}=\\mathbf{0}$. This corresponds to a discrete function $u_h(x,y) = \\sum_{i=1}^3 u_i N_i(x,y)$ for which the Dirichlet energy is zero:\n$$ \\mathbf{u}^T K \\mathbf{u} = \\int_T \\nabla u_h \\cdot \\nabla u_h \\, \\mathrm{d}A = \\int_T |\\nabla u_h|^2 \\, \\mathrm{d}A = 0 $$\nSince the integrand is non-negative, the integral can be zero only if $\\nabla u_h = \\mathbf{0}$ everywhere in $T$. This implies that $u_h(x,y)$ must be a constant function, say $u_h(x,y) = c$. Evaluating at the vertices, we find $u_1=c$, $u_2=c$, and $u_3=c$. Therefore, any vector in the null space must be of the form $\\mathbf{u}=c(1,1,1)^T$. This describes a one-dimensional subspace spanned by the vector $(1,1,1)^T$. This null space corresponds to constant functions (e.g., constant potentials, rigid-body translations) which have zero gradient.\n\n**4. Computation of the Elemental Mass Matrix M**\n\nThe entries of the mass matrix are $M_{ij} = \\int_T N_i N_j \\, \\mathrm{d}A$. We use the integration formula for barycentric coordinates over a triangle:\n$$ \\int_T N_1^\\alpha N_2^\\beta N_3^\\gamma \\, \\mathrm{d}A = (2A) \\frac{\\alpha! \\beta! \\gamma!}{(\\alpha+\\beta+\\gamma+2)!} $$\nSince $A = 1/2$, $2A = 1$, the formula simplifies to $\\int_T N_1^\\alpha N_2^\\beta N_3^\\gamma \\, \\mathrm{d}A = \\frac{\\alpha! \\beta! \\gamma!}{(\\alpha+\\beta+\\gamma+2)!}$.\n\nDiagonal entries:\n- $M_{11} = \\int_T N_1^2 \\, \\mathrm{d}A = \\frac{2!0!0!}{(2+0+0+2)!} = \\frac{2}{4!} = \\frac{2}{24} = \\frac{1}{12}$\n- $M_{22} = \\int_T N_2^2 \\, \\mathrm{d}A = \\frac{0!2!0!}{(0+2+0+2)!} = \\frac{2}{4!} = \\frac{2}{24} = \\frac{1}{12}$\n- $M_{33} = \\int_T N_3^2 \\, \\mathrm{d}A = \\frac{0!0!2!}{(0+0+2+2)!} = \\frac{2}{4!} = \\frac{2}{24} = \\frac{1}{12}$\n\nOff-diagonal entries (by symmetry $M_{ij}=M_{ji}$):\n- $M_{12} = \\int_T N_1 N_2 \\, \\mathrm{d}A = \\frac{1!1!0!}{(1+1+0+2)!} = \\frac{1}{4!} = \\frac{1}{24}$\n- $M_{13} = \\int_T N_1 N_3 \\, \\mathrm{d}A = \\frac{1!0!1!}{(1+0+1+2)!} = \\frac{1}{4!} = \\frac{1}{24}$\n- $M_{23} = \\int_T N_2 N_3 \\, \\mathrm{d}A = \\frac{0!1!1!}{(0+1+1+2)!} = \\frac{1}{4!} = \\frac{1}{24}$\n\nAssembling the matrix $M$:\n$$ M = \\begin{pmatrix} 1/12  1/24  1/24 \\\\ 1/24  1/12  1/24 \\\\ 1/24  1/24  1/12 \\end{pmatrix} = \\frac{1}{24} \\begin{pmatrix} 2  1  1 \\\\ 1  2  1 \\\\ 1  1  2 \\end{pmatrix} $$\n\n**Final Task: Computation of the Determinant of M**\n\nTo find the determinant of $M$, we use the property $\\det(c \\cdot A) = c^n \\det(A)$ for an $n \\times n$ matrix. Here, $c = 1/24$ and $n=3$.\n$$ \\det(M) = \\det\\left(\\frac{1}{24} \\begin{pmatrix} 2  1  1 \\\\ 1  2  1 \\\\ 1  1  2 \\end{pmatrix}\\right) = \\left(\\frac{1}{24}\\right)^3 \\det\\begin{pmatrix} 2  1  1 \\\\ 1  2  1 \\\\ 1  1  2 \\end{pmatrix} $$\nThe determinant of the inner matrix is:\n$$ \\det\\begin{pmatrix} 2  1  1 \\\\ 1  2  1 \\\\ 1  1  2 \\end{pmatrix} = 2(2 \\cdot 2 - 1 \\cdot 1) - 1(1 \\cdot 2 - 1 \\cdot 1) + 1(1 \\cdot 1 - 2 \\cdot 1) $$\n$$ = 2(3) - 1(1) + 1(-1) = 6 - 1 - 1 = 4 $$\nTherefore, the determinant of the mass matrix is:\n$$ \\det(M) = \\left(\\frac{1}{24}\\right)^3 \\cdot 4 = \\frac{4}{24^3} = \\frac{4}{13824} = \\frac{1}{3456} $$",
            "answer": "$$\\boxed{\\frac{1}{3456}}$$"
        },
        {
            "introduction": "After understanding how an element is formulated, the next step is to assemble these building blocks into a functional solver. This practice guides you through the implementation of a complete 1D FEM code, emphasizing a modular, test-driven approach to verify each component from shape functions to the final solution . This exercise is crucial for developing not just a working program, but also the confidence that it is mathematically correct at every step.",
            "id": "3230085",
            "problem": "Implement, from first principles, a one-dimensional Finite Element Method (FEM) code for the model boundary value problem: find $u$ such that $-u'' = f$ on the closed interval $[0,1]$ with homogeneous Dirichlet boundary conditions $u(0)=0$ and $u(1)=0$. Start from the core variational definition: find $u$ in the Sobolev space $H_0^1(0,1)$ such that the bilinear form and linear functional satisfy\n$$\n\\int_0^1 u'(x)\\,v'(x)\\,dx = \\int_0^1 f(x)\\,v(x)\\,dx \\quad \\text{for all } v \\in H_0^1(0,1).\n$$\nUse a mesh of $N$ uniform subintervals of $[0,1]$, linear Lagrange basis functions on the reference element, an isoparametric mapping from the reference element to each physical element, and a Gauss–Legendre quadrature rule exact for polynomials up to degree $3$ to approximate the element integrals. Assemble the global linear system and enforce the homogeneous Dirichlet boundary conditions by eliminating boundary degrees of freedom. Your implementation must be modular and must expose each step: reference element definition, shape function evaluation, numerical quadrature, local element matrix and vector computation, global assembly, boundary condition application, and linear solver.\n\nFrom the following fundamental bases only, derive all formulas you need in your implementation:\n- The weak (variational) form given above.\n- The Lagrange interpolation conditions on the reference element $[0,1]$ for linear basis functions $\\{\\hat{\\varphi}_1,\\hat{\\varphi}_2\\}$ satisfying $\\hat{\\varphi}_i(\\xi_j)=\\delta_{ij}$ at the reference nodes $\\xi_1=0$ and $\\xi_2=1$.\n- The change-of-variables formula for integrals under an affine mapping from the reference element to a physical element.\n- The definition of Gauss–Legendre quadrature nodes and weights on $[-1,1]$ and their affine transformation to $[0,1]$.\n\nDesign your program to compute a diagnostic test suite that verifies individual components and the end-to-end solution. Use the following tests and conventions:\n- All comparisons that are theoretically exact should be validated within an absolute tolerance of $10^{-14}$.\n- For tests that request a float error, compute the exact quantity analytically where possible and report the absolute error as a nonnegative real number.\n- For matrix symmetry, use the Frobenius norm of the difference of a matrix and its transpose to quantify symmetry error.\n\nTest suite to implement and report, in this exact order:\n1. Reference shape functions: verify the nodal interpolation properties and partition of unity for the linear Lagrange basis on the reference element $[0,1]$. Specifically, check that $\\hat{\\varphi}_1(0)=1$, $\\hat{\\varphi}_2(0)=0$, $\\hat{\\varphi}_1(1)=0$, $\\hat{\\varphi}_2(1)=1$, $\\hat{\\varphi}_1(1/2)=\\hat{\\varphi}_2(1/2)$, and $\\hat{\\varphi}_1(\\xi)+\\hat{\\varphi}_2(\\xi)=1$ for $\\xi \\in \\{0,1/2,1\\}$. Output a single boolean that is true if and only if all these checks pass within the stated tolerance.\n2. Quadrature exactness: using a $2$-point Gauss–Legendre rule on $[0,1]$, numerically integrate $x^k$ for $k \\in \\{0,1,2,3\\}$, and report the maximum absolute error across these $4$ cases (the exact integrals are $\\int_0^1 x^k\\,dx = 1/(k+1)$).\n3. Local stiffness matrix on the unit element: for the physical element $[0,1]$, compute the local stiffness matrix using your reference basis, mapping, and quadrature. Also compute the exact local stiffness matrix by analytic integration of the gradients of the shape functions on $[0,1]$. Report the Frobenius norm of the difference between the numerical and exact local stiffness matrices as a nonnegative real number.\n4. End-to-end solution accuracy on a coarse mesh: set $f(x) = \\pi^2 \\sin(\\pi x)$ so that the exact solution is $u(x) = \\sin(\\pi x)$. Solve the finite element system on a uniform mesh with $N=2$ elements. Report the maximum absolute nodal error $\\max_i |u_h(x_i) - u(x_i)|$ as a nonnegative real number.\n5. End-to-end solution accuracy on a finer mesh: repeat test $4$ with $N=10$ elements and report the maximum absolute nodal error as a nonnegative real number.\n6. Symmetry and positive definiteness: for $N=4$ and $f(x)=1$, assemble the reduced global stiffness matrix after enforcing homogeneous Dirichlet boundary conditions. Output a single boolean that is true if and only if the reduced matrix is symmetric within the stated tolerance and all its eigenvalues are strictly positive.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the order of tests $1$ through $6$, for example, $\\texttt{[result1,result2,result3,result4,result5,result6]}$.\n- All booleans must be literal $\\texttt{True}$ or $\\texttt{False}$, and all real numbers must be printed in standard decimal notation. No units are required for any outputs.",
            "solution": "The user requires an implementation of a one-dimensional Finite Element Method (FEM) solver for the Poisson equation from first principles. This document outlines the theoretical derivation of the necessary formulas, adhering to the specified constraints.\n\n### 1. Variational Formulation and Discretization\n\nThe model problem is the boundary value problem (BVP) on the domain $\\Omega = [0,1]$:\n$$ -u''(x) = f(x) \\quad \\text{for } x \\in (0,1) $$\n$$ u(0) = 0, \\quad u(1) = 0 $$\nThe Finite Element Method begins with the weak (or variational) formulation. We multiply the differential equation by a test function $v$ from a suitable function space and integrate over the domain:\n$$ -\\int_0^1 u''(x) v(x) \\,dx = \\int_0^1 f(x) v(x) \\,dx $$\nApplying integration by parts to the left-hand side yields:\n$$ \\int_0^1 u'(x) v'(x) \\,dx - [u'(x)v(x)]_0^1 = \\int_0^1 f(x) v(x) \\,dx $$\nWe seek a solution $u$ in the Sobolev space $H_0^1(0,1)$, which is the space of functions that are square-integrable, have square-integrable first derivatives, and satisfy the homogeneous Dirichlet boundary conditions. By choosing the test functions $v$ from the same space $H_0^1(0,1)$, the boundary term $[u'(x)v(x)]_0^1$ vanishes because $v(0)=v(1)=0$. This results in the required weak form: find $u \\in H_0^1(0,1)$ such that\n$$ \\int_0^1 u'(x) v'(x) \\,dx = \\int_0^1 f(x) v(x) \\,dx \\quad \\text{for all } v \\in H_0^1(0,1) $$\nThe FEM discretizes this problem by seeking an approximate solution $u_h$ in a finite-dimensional subspace $V_h \\subset H_0^1(0,1)$. The domain $[0,1]$ is partitioned into $N$ uniform subintervals (elements) $K_e = [x_e, x_{e+1}]$ of length $h=1/N$. The nodes of this mesh are $x_i = i h$ for $i=0, \\dots, N$. The subspace $V_h$ is spanned by continuous, piecewise linear basis functions (\"hat\" functions) $\\phi_i(x)$ defined such that $\\phi_i(x_j) = \\delta_{ij}$. The approximate solution is expressed as a linear combination of these basis functions:\n$$ u_h(x) = \\sum_{j=0}^{N} U_j \\phi_j(x) $$\nwhere $U_j=u_h(x_j)$ are the unknown nodal values. The Galerkin method sets the test functions $v$ to be the basis functions $\\phi_i$ for $i=0, \\dots, N$. This leads to a system of linear equations $AU=F$, where $A_{ij} = \\int_0^1 \\phi_j'(x) \\phi_i'(x) \\,dx$ and $F_i = \\int_0^1 f(x) \\phi_i(x) \\,dx$.\n\n### 2. Reference Element, Basis Functions, and Mapping\n\nTo standardize computations, all integrals over a physical element $K_e = [x_e, x_{e+1}]$ are transformed to a reference element, $\\hat{K}=[0,1]$.\n\n**Reference Basis Functions**: On $\\hat{K}$, we define local linear basis functions $\\hat{\\varphi}_i(\\xi)$ for $i=1,2$ corresponding to local nodes $\\xi_1=0$ and $\\xi_2=1$. They are defined by the Lagrange interpolation conditions $\\hat{\\varphi}_i(\\xi_j) = \\delta_{ij}$.\nFor $\\hat{\\varphi}_1(\\xi) = a\\xi+b$:\nThe conditions $\\hat{\\varphi}_1(0)=1$ and $\\hat{\\varphi}_1(1)=0$ yield $b=1$ and $a=-1$. Thus, $\\hat{\\varphi}_1(\\xi) = 1-\\xi$.\nFor $\\hat{\\varphi}_2(\\xi) = c\\xi+d$:\nThe conditions $\\hat{\\varphi}_2(0)=0$ and $\\hat{\\varphi}_2(1)=1$ yield $d=0$ and $c=1$. Thus, $\\hat{\\varphi}_2(\\xi) = \\xi$.\nThe derivatives of these reference basis functions are constants: $\\frac{d\\hat{\\varphi}_1}{d\\xi} = -1$ and $\\frac{d\\hat{\\varphi}_2}{d\\xi} = 1$.\n\n**Isoparametric Mapping**: The affine mapping $F_e: \\hat{K} \\to K_e$ is defined using the same basis functions: $x(\\xi) = x_e \\hat{\\varphi}_1(\\xi) + x_{e+1} \\hat{\\varphi}_2(\\xi) = x_e(1-\\xi) + x_{e+1}\\xi$. For a uniform mesh, this simplifies to $x(\\xi) = x_e + h\\xi$.\nThe Jacobian of this transformation is $J_e = \\frac{dx}{d\\xi} = h$. By the chain rule, a derivative with respect to $x$ is related to the derivative with respect to $\\xi$ by $\\frac{d}{dx} = \\frac{d\\xi}{dx}\\frac{d}{d\\xi} = \\frac{1}{J_e}\\frac{d}{d\\xi} = \\frac{1}{h}\\frac{d}{d\\xi}$.\n\n### 3. Numerical Quadrature\n\nThe problem requires a Gauss-Legendre quadrature rule on $[0,1]$ that is exact for polynomials up to degree $3$. A $n$-point Gauss-Legendre rule is exact for polynomials of degree $2n-1$. Thus, we need $2n-1 \\geq 3$, which implies $n \\geq 2$. We select a $2$-point rule. The standard nodes $\\hat{z}_k$ and weights $\\hat{w}_k$ are defined on $[-1,1]$:\n$$ \\hat{z}_1 = -1/\\sqrt{3}, \\quad \\hat{z}_2 = 1/\\sqrt{3} \\qquad \\hat{w}_1 = 1, \\quad \\hat{w}_2 = 1 $$\nWe transform these to the reference element $\\hat{K}=[0,1]$ using the affine map $\\xi(\\hat{z}) = \\frac{1}{2}(\\hat{z}+1)$. The Jacobian of this map is $\\frac{d\\xi}{d\\hat{z}} = 1/2$. The quadrature nodes $\\xi_q$ on $[0,1]$ are the images of $\\hat{z}_k$, and the weights $w_q$ are scaled by the Jacobian:\n$$ \\xi_q = \\frac{1}{2}(\\hat{z}_q+1), \\quad w_q = \\hat{w}_q \\cdot \\frac{1}{2} $$\nThis gives the rule $\\int_0^1 g(\\xi) d\\xi \\approx \\sum_{q=1}^2 w_q g(\\xi_q)$ with:\n- Nodes: $\\xi_1 = \\frac{1}{2}(1 - 1/\\sqrt{3})$, $\\xi_2 = \\frac{1}{2}(1 + 1/\\sqrt{3})$.\n- Weights: $w_1 = 1/2$, $w_2 = 1/2$.\n\n### 4. Element Stiffness Matrix and Load Vector\n\nThe entries of the global stiffness matrix $A$ and load vector $F$ are assembled from element-level contributions.\n\n**Local Stiffness Matrix**: For an element $K_e$, the $2 \\times 2$ local stiffness matrix $A^{(e)}$ has entries $A_{ij}^{(e)} = \\int_{K_e} (\\varphi_j^{(e)})'(x) (\\varphi_i^{(e)})'(x) \\,dx$, where $\\varphi_i^{(e)}$ are the local basis functions. Transforming to the reference element:\n$$ A_{ij}^{(e)} = \\int_0^1 \\left(\\frac{1}{h}\\frac{d\\hat{\\varphi}_j}{d\\xi}\\right) \\left(\\frac{1}{h}\\frac{d\\hat{\\varphi}_i}{d\\xi}\\right) h \\,d\\xi = \\frac{1}{h} \\int_0^1 \\frac{d\\hat{\\varphi}_i}{d\\xi} \\frac{d\\hat{\\varphi}_j}{d\\xi} \\,d\\xi $$\nSince the derivatives of the reference basis functions are constant, the integrand is a constant (a polynomial of degree $0$). Our $2$-point quadrature rule is exact for this integral. Performing the integration analytically:\n$A_{11}^{(e)} = \\frac{1}{h} \\int_0^1 (-1)(-1) d\\xi = \\frac{1}{h}$,\n$A_{12}^{(e)} = A_{21}^{(e)} = \\frac{1}{h} \\int_0^1 (-1)(1) d\\xi = -\\frac{1}{h}$,\n$A_{22}^{(e)} = \\frac{1}{h} \\int_0^1 (1)(1) d\\xi = \\frac{1}{h}$.\nSo, the local stiffness matrix is $A^{(e)} = \\frac{1}{h} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix}$.\n\n**Local Load Vector**: The $2 \\times 1$ local load vector $F^{(e)}$ has entries $F_i^{(e)} = \\int_{K_e} f(x) \\varphi_i^{(e)}(x) \\,dx$. Transforming to the reference element and applying quadrature:\n$$ F_i^{(e)} = \\int_0^1 f(x(\\xi)) \\hat{\\varphi}_i(\\xi) h \\,d\\xi \\approx h \\sum_{q=1}^2 w_q f(x_e + h \\xi_q) \\hat{\\varphi}_i(\\xi_q) $$\n\n### 5. Assembly, Boundary Conditions, and Solution\n\nThe global matrices $A$ (size $(N+1) \\times (N+1)$) and $F$ (size $(N+1) \\times 1$) are constructed by summing the contributions from all local matrices $A^{(e)}$ and vectors $F^{(e)}$. The local indices $(1, 2)$ on element $e$ map to global indices $(e, e+1)$.\n\nThe homogeneous Dirichlet boundary conditions $u(0)=0$ and $u(1)=0$ imply that the nodal values $U_0$ and $U_N$ are zero. These degrees of freedom are eliminated from the linear system. This is achieved by removing the first and last rows and columns from the global stiffness matrix $A$ and the first and last entries from the global load vector $F$. This yields a reduced linear system $A_{red} U_{red} = F_{red}$ of size $(N-1) \\times (N-1)$, where $U_{red}=[U_1, \\dots, U_{N-1}]^T$. The reduced stiffness matrix $A_{red}$ is symmetric and positive definite, guaranteeing a unique solution. This system is solved for the unknown interior nodal values. The full solution vector is then assembled as $U = [0, U_1, \\dots, U_{N-1}, 0]^T$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a 1D FEM solver and runs a diagnostic test suite.\n    \"\"\"\n    TOL = 1e-14\n\n    # ------------------ Core FEM Components ------------------\n\n    def get_reference_element_data():\n        \"\"\"\n        Defines basis functions and quadrature on the reference element [0,1].\n        \"\"\"\n        # Linear Lagrange basis functions and their derivatives on [0,1]\n        phi_hat = [lambda xi: 1 - xi, lambda xi: xi]\n        d_phi_hat = [lambda xi: -1.0, lambda xi: 1.0]\n\n        # 2-point Gauss-Legendre quadrature on [0,1]\n        # Transformed from standard rule on [-1,1]\n        quad_points = [0.5 * (1 - 1/np.sqrt(3)), 0.5 * (1 + 1/np.sqrt(3))]\n        quad_weights = [0.5, 0.5]\n\n        return phi_hat, d_phi_hat, quad_points, quad_weights\n\n    def compute_local_stiffness(h, d_phi_hat, quad_points, quad_weights):\n        \"\"\"\n        Numerically computes the 2x2 local stiffness matrix.\n        \"\"\"\n        A_local = np.zeros((2, 2))\n        for i in range(2):\n            for j in range(2):\n                integrand_val = 0\n                for q_idx in range(len(quad_points)):\n                    xi = quad_points[q_idx]\n                    w = quad_weights[q_idx]\n                    integrand_val += d_phi_hat[i](xi) * d_phi_hat[j](xi) * w\n                A_local[i, j] = (1/h) * integrand_val\n        return A_local\n\n    def compute_local_load(f, xe, h, phi_hat, quad_points, quad_weights):\n        \"\"\"\n        Numerically computes the 2x1 local load vector.\n        \"\"\"\n        F_local = np.zeros(2)\n        for i in range(2):\n            integrand_val = 0\n            for q_idx in range(len(quad_points)):\n                xi = quad_points[q_idx]\n                w = quad_weights[q_idx]\n                # Map reference coordinate xi to physical coordinate x\n                x = xe + h * xi\n                integrand_val += f(x) * phi_hat[i](xi) * w\n            F_local[i] = h * integrand_val\n        return F_local\n\n    def solve_bvp(N, f):\n        \"\"\"\n        Solves -u'' = f on [0,1] with u(0)=u(1)=0 using N elements.\n        \"\"\"\n        h = 1.0 / N\n        nodes = np.linspace(0, 1, N + 1)\n\n        phi_hat, d_phi_hat, quad_points, quad_weights = get_reference_element_data()\n\n        # Assembly\n        A_global = np.zeros((N + 1, N + 1))\n        F_global = np.zeros(N + 1)\n\n        for e in range(N):\n            xe = nodes[e]\n            A_local = compute_local_stiffness(h, d_phi_hat, quad_points, quad_weights)\n            F_local = compute_local_load(f, xe, h, phi_hat, quad_points, quad_weights)\n            \n            # Add local contributions to global matrices\n            global_indices = [e, e + 1]\n            for i in range(2):\n                for j in range(2):\n                    A_global[global_indices[i], global_indices[j]] += A_local[i, j]\n                F_global[global_indices[i]] += F_local[i]\n\n        # Apply homogeneous Dirichlet boundary conditions\n        interior_indices = slice(1, N)\n        A_reduced = A_global[interior_indices, interior_indices]\n        F_reduced = F_global[interior_indices]\n\n        # Solve the linear system\n        if A_reduced.shape[0]  0:\n            U_reduced = np.linalg.solve(A_reduced, F_reduced)\n        else: # Case N=1, no interior nodes\n            U_reduced = np.array([])\n            \n        # Construct full solution vector\n        U_full = np.zeros(N + 1)\n        U_full[interior_indices] = U_reduced\n\n        return nodes, U_full, A_reduced\n\n    # ------------------ Test Suite ------------------\n    \n    results = []\n\n    # Test 1: Reference shape functions\n    def test_1():\n        phi_hat, _, _, _ = get_reference_element_data()\n        ph1, ph2 = phi_hat[0], phi_hat[1]\n        \n        c1 = abs(ph1(0.0) - 1.0)  TOL\n        c2 = abs(ph2(0.0) - 0.0)  TOL\n        c3 = abs(ph1(1.0) - 0.0)  TOL\n        c4 = abs(ph2(1.0) - 1.0)  TOL\n        c5 = abs(ph1(0.5) - ph2(0.5))  TOL\n        \n        partition_of_unity_ok = True\n        for xi_test in [0.0, 0.5, 1.0]:\n            if abs(ph1(xi_test) + ph2(xi_test) - 1.0)  TOL:\n                partition_of_unity_ok = False\n                break\n        \n        return all([c1, c2, c3, c4, c5, partition_of_unity_ok])\n    results.append(test_1())\n\n    # Test 2: Quadrature exactness\n    def test_2():\n        _, _, quad_points, quad_weights = get_reference_element_data()\n        errors = []\n        for k in range(4): # k=0, 1, 2, 3\n            g = lambda x: x**k\n            exact_integral = 1.0 / (k + 1)\n            \n            numeric_integral = 0.0\n            for i in range(len(quad_points)):\n                numeric_integral += quad_weights[i] * g(quad_points[i])\n            \n            errors.append(abs(numeric_integral - exact_integral))\n        return max(errors)\n    results.append(test_2())\n\n    # Test 3: Local stiffness matrix on the unit element\n    def test_3():\n        _, d_phi_hat, quad_points, quad_weights = get_reference_element_data()\n        A_num = compute_local_stiffness(1.0, d_phi_hat, quad_points, quad_weights)\n        A_exact = np.array([[1.0, -1.0], [-1.0, 1.0]])\n        diff_norm = np.linalg.norm(A_num - A_exact, 'fro')\n        return diff_norm\n    results.append(test_3())\n\n    # Test 4  5: End-to-end solution accuracy\n    f_test = lambda x: np.pi**2 * np.sin(np.pi * x)\n    u_exact_func = lambda x: np.sin(np.pi * x)\n\n    def run_e2e_test(N, f, u_exact):\n        nodes, U_h, _ = solve_bvp(N, f)\n        u_exact_vals = u_exact(nodes)\n        nodal_errors = np.abs(U_h - u_exact_vals)\n        return np.max(nodal_errors)\n    \n    # Test 4\n    results.append(run_e2e_test(N=2, f=f_test, u_exact=u_exact_func))\n\n    # Test 5\n    results.append(run_e2e_test(N=10, f=f_test, u_exact=u_exact_func))\n\n    # Test 6: Symmetry and positive definiteness\n    def test_6():\n        _, _, A_red = solve_bvp(N=4, f=lambda x: 1.0)\n        \n        # Symmetry check\n        symmetry_error = np.linalg.norm(A_red - A_red.T, 'fro')\n        is_symmetric = symmetry_error  TOL\n        \n        # Positive definiteness check\n        eigenvalues = np.linalg.eigvalsh(A_red)\n        is_pd = np.all(eigenvalues  0)\n        \n        return is_symmetric and is_pd\n    results.append(test_6())\n    \n    # Final print statement\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A robust understanding of any numerical method requires knowing not only its procedures but also the principles that guarantee its success. This final practice is a thought experiment that challenges you to analyze the consequences of violating a cornerstone of element formulation: the partition of unity property . By exploring what goes wrong when this condition is not met, you will develop a deeper appreciation for the theoretical foundations that ensure the accuracy and physical consistency of the Finite Element Method.",
            "id": "3229931",
            "problem": "Consider the standard scalar diffusion model problem on a connected domain $\\Omega \\subset \\mathbb{R}^d$ with material coefficient $k(\\mathbf{x})  0$:\n$$\n- \\nabla \\cdot \\left( k(\\mathbf{x}) \\, \\nabla u(\\mathbf{x}) \\right) = f(\\mathbf{x}) \\quad \\text{in } \\Omega,\n$$\nwith boundary conditions chosen as needed. The Galerkin formulation seeks $u \\in H^1(\\Omega)$ such that\n$$\n\\int_{\\Omega} \\nabla v(\\mathbf{x})^{\\top} \\, k(\\mathbf{x}) \\, \\nabla u(\\mathbf{x}) \\, \\mathrm{d}\\Omega = \\int_{\\Omega} v(\\mathbf{x}) \\, f(\\mathbf{x}) \\, \\mathrm{d}\\Omega \\quad \\text{for all } v \\in H^1(\\Omega),\n$$\nwhere $H^1(\\Omega)$ is the Sobolev space of square-integrable functions with square-integrable weak gradients. In the Finite Element Method (FEM), the approximate solution $u_h(\\mathbf{x})$ is represented in terms of shape functions $N_i(\\mathbf{x})$ as\n$$\nu_h(\\mathbf{x}) = \\sum_{i=1}^{n_\\text{dof}} N_i(\\mathbf{x}) \\, u_i,\n$$\nwhere $u_i$ are the nodal degrees of freedom and $n_\\text{dof}$ is the number of degrees of freedom. The discrete linear system $\\mathbf{K}\\mathbf{u} = \\mathbf{f}$ has entries\n$$\nK_{ij} = \\int_{\\Omega} \\left( \\nabla N_i(\\mathbf{x}) \\right)^{\\top} \\, k(\\mathbf{x}) \\, \\nabla N_j(\\mathbf{x}) \\, \\mathrm{d}\\Omega, \n\\qquad \nf_i = \\int_{\\Omega} N_i(\\mathbf{x}) \\, f(\\mathbf{x}) \\, \\mathrm{d}\\Omega.\n$$\nA common requirement for basic, consistent finite elements is that the shape functions form a partition of unity on each element, that is, $\\sum_{i} N_i(\\mathbf{x}) \\equiv 1$. In this problem, you must analyze the consequences when the shape functions on one or more elements violate this property, so that $\\sum_{i} N_i(\\mathbf{x}) \\neq 1$ within those elements, while all other standard conditions (such as continuity across element boundaries) are assumed to remain as in typical conforming FEM.\n\nSelect all statements that are true under the assumption that $\\sum_{i} N_i(\\mathbf{x}) \\neq 1$ on at least one element.\n\nA. Even if all nodal values on the mesh are set to the same constant $c$, the finite element interpolant $u_h(\\mathbf{x})$ is not constant inside elements that violate $\\sum_i N_i = 1$, and the element fails the constant patch test.\n\nB. For a uniform body force $f(\\mathbf{x}) \\equiv f_0$ with $f_0$ a constant, the global total nodal load assembled by the consistent Galerkin formulation satisfies $\\sum_{i} f_i = \\int_{\\Omega} f_0 \\, \\mathrm{d}\\Omega$ regardless of whether $\\sum_i N_i = 1$ holds.\n\nC. For the pure Neumann problem with $f(\\mathbf{x}) \\equiv 0$ and homogeneous Neumann boundary conditions, the discrete stiffness matrix $\\mathbf{K}$ becomes nonsingular (that is, the physical null space of constant fields is lost), so the discrete solution is artificially constrained and not constant.\n\nD. In small-strain linear elasticity with zero external loads, rigid-body translations (constant displacement fields) are still represented exactly, so no spurious strains or stresses are produced by elements that violate $\\sum_i N_i = 1$.\n\nProvide your answer by choosing the correct option(s) and justify your choice from first principles using the weak form and the finite element interpolation structure.",
            "solution": "The problem statement is critically analyzed for validity before proceeding to a solution.\n\n### Step 1: Extract Givens\n- **Governing Equation:** The scalar diffusion equation is $- \\nabla \\cdot \\left( k(\\mathbf{x}) \\, \\nabla u(\\mathbf{x}) \\right) = f(\\mathbf{x})$ on a domain $\\Omega$, with $k(\\mathbf{x})  0$.\n- **Galerkin Weak Form:** Find $u \\in H^1(\\Omega)$ such that $\\int_{\\Omega} \\nabla v^{\\top} \\, k \\, \\nabla u \\, \\mathrm{d}\\Omega = \\int_{\\Omega} v \\, f \\, \\mathrm{d}\\Omega$ for all test functions $v \\in H^1(\\Omega)$ (assuming homogeneous boundary conditions for simplicity, as is standard when presenting the core weak form).\n- **Finite Element Approximation:** The approximate solution $u_h(\\mathbf{x})$ is expressed as a linear combination of nodal degrees of freedom $u_i$ and shape functions $N_i(\\mathbf{x})$: $u_h(\\mathbf{x}) = \\sum_{i=1}^{n_\\text{dof}} N_i(\\mathbf{x}) \\, u_i$.\n- **Discrete System:** The resulting linear system is $\\mathbf{K}\\mathbf{u} = \\mathbf{f}$, with stiffness matrix entries $K_{ij} = \\int_{\\Omega} \\left( \\nabla N_i \\right)^{\\top} \\, k \\, \\nabla N_j \\, \\mathrm{d}\\Omega$ and load vector entries $f_i = \\int_{\\Omega} N_i \\, f \\, \\mathrm{d}\\Omega$.\n- **Core Condition:** The analysis is to be performed under the assumption that the shape functions do not form a partition of unity on at least one element. That is, the property $\\sum_{i} N_i(\\mathbf{x}) = 1$ is violated, so $\\sum_{i} N_i(\\mathbf{x}) \\neq 1$ within one or more elements.\n- **Ancillary Condition:** All other standard properties of conforming finite elements, such as inter-element continuity, are assumed to hold.\n\n### Step 2: Validate Using Extracted Givens\nThe problem presented is a theoretical exercise within the field of numerical methods, specifically the Finite Element Method. It asks for an analysis of the consequences of violating a standard property of shape functions, namely the partition of unity.\n\n- **Scientifically Grounded:** The problem is firmly rooted in the mathematical theory of the Finite Element Method. The partition of unity property is a cornerstone for element consistency and convergence. Analyzing the consequences of its absence is a standard pedagogical tool.\n- **Well-Posed:** The problem provides a clear premise ($\\sum_i N_i \\neq 1$) and asks for logical deductions about the properties of the resulting discrete system. The questions posed in the options are specific and can be answered through mathematical derivation.\n- **Objective:** The language is formal and unambiguous. The concepts of shape functions, partition of unity, patch test, and stiffness matrix singularity are all well-defined in the context of FEM.\n\nThe problem does not exhibit any flaws such as scientific unsoundness, missing information, or ambiguity. It is a valid, well-posed problem that tests fundamental understanding of FEM principles.\n\n### Step 3: Verdict and Action\nThe problem statement is **valid**. A full analysis of each option is warranted.\n\n### Derivation and Option-by-Option Analysis\n\nThe central premise is that on one or more elements, the sum of the shape functions is not identically unity. Let's define the sum $S(\\mathbf{x}) = \\sum_{i} N_i(\\mathbf{x})$. The premise implies $S(\\mathbf{x}) \\neq 1$ for $\\mathbf{x}$ in at least one element.\n\n**A. Evaluation of Statement A**\n\nThe statement claims that if all nodal values are a constant $c$, the interpolant $u_h(\\mathbf{x})$ is not constant in elements where $\\sum_i N_i \\neq 1$, leading to a failure of the constant patch test.\n\nLet all nodal degrees of freedom be set to the same constant value, $u_i = c$ for all $i = 1, \\dots, n_\\text{dof}$. The finite element interpolant is:\n$$u_h(\\mathbf{x}) = \\sum_{i} N_i(\\mathbf{x}) u_i = \\sum_{i} N_i(\\mathbf{x}) c = c \\left( \\sum_{i} N_i(\\mathbf{x}) \\right) = c \\, S(\\mathbf{x})$$\nFor $u_h(\\mathbf{x})$ to be constant and equal to $c$, it is necessary that $S(\\mathbf{x}) = \\sum_{i} N_i(\\mathbf{x}) = 1$ for all $\\mathbf{x}$. The problem explicitly states that this condition is violated within certain elements. In those elements, $u_h(\\mathbf{x}) = c \\, S(\\mathbf{x}) \\neq c$. Since the shape functions $N_i(\\mathbf{x})$ are generally non-constant functions of position within an element, their sum $S(\\mathbf{x})$ will also be a non-constant function. Thus, $u_h(\\mathbf{x})$ is not constant.\n\nThe constant patch test requires that the FEM solution exactly reproduces any constant-valued solution. A constant function $u(\\mathbf{x}) = c$ is a solution to the governing differential equation when $f(\\mathbf{x}) = 0$ (and with appropriate boundary conditions). The FEM solution passes the test if, given nodal values $u_i = c$, the resulting discrete equations are satisfied and the interpolant is $u_h(\\mathbf{x}) = c$. As shown, the interpolant is not constant, so the element cannot exactly represent a constant field. This implies that the gradient $\\nabla u_h(\\mathbf{x}) = c \\, \\nabla S(\\mathbf{x})$ will be non-zero in the elements where $S(\\mathbf{x}) \\neq 1$, leading to spurious fluxes or strains. This constitutes a failure of the constant patch test.\n\nTherefore, statement A is **Correct**.\n\n**B. Evaluation of Statement B**\n\nThe statement claims that for a uniform force $f(\\mathbf{x}) = f_0$, the sum of all nodal loads $\\sum_i f_i$ equals the total integrated force $\\int_{\\Omega} f_0 \\, \\mathrm{d}\\Omega$.\n\nThe $i$-th entry of the consistent load vector is $f_i = \\int_{\\Omega} N_i(\\mathbf{x}) f(\\mathbf{x}) \\, \\mathrm{d}\\Omega$. The sum of all nodal loads is:\n$$\\sum_i f_i = \\sum_i \\int_{\\Omega} N_i(\\mathbf{x}) f(\\mathbf{x}) \\, \\mathrm{d}\\Omega$$\nBy linearity of the integral and sum, we can interchange them:\n$$\\sum_i f_i = \\int_{\\Omega} \\left( \\sum_i N_i(\\mathbf{x}) \\right) f(\\mathbf{x}) \\, \\mathrm{d}\\Omega = \\int_{\\Omega} S(\\mathbf{x}) f(\\mathbf{x}) \\, \\mathrm{d}\\Omega$$\nFor the case $f(\\mathbf{x}) = f_0$, a constant, this becomes:\n$$\\sum_i f_i = f_0 \\int_{\\Omega} S(\\mathbf{x}) \\, \\mathrm{d}\\Omega$$\nThe total physical load applied to the domain is $\\int_{\\Omega} f(\\mathbf{x}) \\, \\mathrm{d}\\Omega = \\int_{\\Omega} f_0 \\, \\mathrm{d}\\Omega = f_0 \\operatorname{volume}(\\Omega)$.\nThe statement claims that $\\sum_i f_i = \\int_{\\Omega} f_0 \\, \\mathrm{d}\\Omega$, which means:\n$$f_0 \\int_{\\Omega} S(\\mathbf{x}) \\, \\mathrm{d}\\Omega = f_0 \\int_{\\Omega} 1 \\, \\mathrm{d}\\Omega$$\nThis equality holds if and only if $\\int_{\\Omega} (S(\\mathbf{x}) - 1) \\, \\mathrm{d}\\Omega = 0$. Since we are given that $S(\\mathbf{x}) \\neq 1$ within at least one element, there is no guarantee that the integral of $S(\\mathbf{x}) - 1$ over the domain will be zero. For example, if $S(\\mathbf{x})  1$ everywhere in an element, its contribution to the integral will be strictly positive. Thus, in general, $\\sum_i f_i \\neq \\int_{\\Omega} f_0 \\, \\mathrm{d}\\Omega$. This means that global conservation of the load is violated.\n\nTherefore, statement B is **Incorrect**.\n\n**C. Evaluation of Statement C**\n\nThe statement addresses the pure Neumann problem ($f \\equiv 0$, homogeneous Neumann BCs) and claims the stiffness matrix $\\mathbf{K}$ becomes nonsingular.\n\nFor the pure Neumann problem, the solution is unique only up to an additive constant. The constant functions form the null space of the continuous differential operator. A faithful discrete model must reflect this property. The discrete equivalent of a constant field $u=c$ is a nodal vector where all entries are equal, i.e., $\\mathbf{u} = c \\mathbf{1}$, where $\\mathbf{1}$ is the vector of all ones. For this to be in the null space of the discrete system, we must have $\\mathbf{K}(c\\mathbf{1}) = c(\\mathbf{K}\\mathbf{1}) = \\mathbf{0}$, which requires $\\mathbf{K}\\mathbf{1} = \\mathbf{0}$.\n\nLet's examine the product $\\mathbf{K}\\mathbf{1}$. The $i$-th component is $(\\mathbf{K}\\mathbf{1})_i = \\sum_j K_{ij} \\cdot 1 = \\sum_j K_{ij}$.\n$$\\sum_j K_{ij} = \\sum_j \\int_{\\Omega} (\\nabla N_i)^{\\top} \\, k \\, (\\nabla N_j) \\, \\mathrm{d}\\Omega = \\int_{\\Omega} (\\nabla N_i)^{\\top} \\, k \\, \\left( \\sum_j \\nabla N_j \\right) \\, \\mathrm{d}\\Omega$$\nWe can write $\\sum_j \\nabla N_j = \\nabla \\left( \\sum_j N_j \\right) = \\nabla S(\\mathbf{x})$. So,\n$$\\sum_j K_{ij} = \\int_{\\Omega} (\\nabla N_i)^{\\top} \\, k \\, (\\nabla S(\\mathbf{x})) \\, \\mathrm{d}\\Omega$$\nIf the partition of unity holds, $S(\\mathbf{x}) = 1$, then its gradient $\\nabla S(\\mathbf{x}) = \\mathbf{0}$. In this case, $\\sum_j K_{ij} = 0$ for all $i$. This means the sum of the entries in each row of $\\mathbf{K}$ is zero, so $\\mathbf{K}\\mathbf{1} = \\mathbf{0}$ and $\\mathbf{K}$ is singular, correctly capturing the physical null space.\n\nUnder the problem's assumption, $S(\\mathbf{x}) \\neq 1$ in some elements, and therefore $\\nabla S(\\mathbf{x})$ is generally non-zero in those elements. The integral defining the row sum, $\\sum_j K_{ij}$, will not be zero in general. If even one row sum is non-zero, then $\\mathbf{K}\\mathbf{1} \\neq \\mathbf{0}$. The constant vector is no longer in the null space of $\\mathbf{K}$. By losing its null space, the matrix $\\mathbf{K}$ (which is symmetric and at least positive semi-definite) becomes positive definite and thus nonsingular (invertible). For the homogeneous system $\\mathbf{K}\\mathbf{u}=\\mathbf{0}$, the only solution is $\\mathbf{u}=\\mathbf{0}$. This artificially constrains the system, eliminating the valid constant-field solutions.\n\nTherefore, statement C is **Correct**.\n\n**D. Evaluation of Statement D**\n\nThis statement applies the same reasoning to linear elasticity. It claims that rigid-body translations are represented exactly and produce no spurious strains even if $\\sum_i N_i \\neq 1$.\n\nA rigid-body translation is a constant displacement field, $\\mathbf{u}(\\mathbf{x}) = \\mathbf{c}$, where $\\mathbf{c}$ is a constant vector. The corresponding finite element representation is obtained by setting all nodal displacement vectors to $\\mathbf{c}$, i.e., $\\mathbf{u}_i = \\mathbf{c}$ for all $i$. The interpolated displacement field is:\n$$\\mathbf{u}_h(\\mathbf{x}) = \\sum_i N_i(\\mathbf{x}) \\mathbf{u}_i = \\sum_i N_i(\\mathbf{x}) \\mathbf{c} = \\left(\\sum_i N_i(\\mathbf{x})\\right) \\mathbf{c} = S(\\mathbf{x}) \\mathbf{c}$$\nFor the translation to be represented exactly, we must have $\\mathbf{u}_h(\\mathbf{x}) = \\mathbf{c}$, which requires $S(\\mathbf{x}) = 1$. Since $S(\\mathbf{x}) \\neq 1$, the rigid-body translation is *not* represented exactly.\n\nThe strain tensor is derived from the gradient of the displacement field. The true strain for a rigid-body motion is zero. The strain from the FE approximation is computed from $\\mathbf{u}_h(\\mathbf{x})$:\n$$\\boldsymbol{\\varepsilon}(\\mathbf{u}_h) = \\frac{1}{2}(\\nabla \\mathbf{u}_h + (\\nabla \\mathbf{u}_h)^{\\top})$$\nThe gradient of $\\mathbf{u}_h$ is:\n$$\\nabla \\mathbf{u}_h(\\mathbf{x}) = \\nabla (S(\\mathbf{x}) \\mathbf{c}) = \\mathbf{c} \\otimes \\nabla S(\\mathbf{x})$$\nSince $S(\\mathbf{x}) \\neq 1$, its gradient $\\nabla S(\\mathbf{x})$ is non-zero in the faulty elements. This means $\\nabla \\mathbf{u}_h$ is non-zero, and consequently, the strain tensor $\\boldsymbol{\\varepsilon}(\\mathbf{u}_h)$ is non-zero. These are spurious strains, as they arise from a configuration that should be strain-free. Spurious strains, in turn, generate spurious stresses via the material's constitutive law. The statement claims the opposite.\n\nTherefore, statement D is **Incorrect**.",
            "answer": "$$\\boxed{AC}$$"
        }
    ]
}