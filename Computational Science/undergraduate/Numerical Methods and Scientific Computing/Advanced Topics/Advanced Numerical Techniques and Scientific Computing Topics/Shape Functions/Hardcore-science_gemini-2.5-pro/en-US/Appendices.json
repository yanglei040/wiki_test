{
    "hands_on_practices": [
        {
            "introduction": "To begin, we will construct the foundational building blocks of the Finite Element Method: the shape functions. This first exercise  guides you through deriving the quadratic Lagrange shape functions for a simple one-dimensional element from first principles. By verifying key properties like the partition of unity and polynomial reproduction, you will build a solid intuition for why these functions are so effective at approximating complex fields.",
            "id": "2635745",
            "problem": "A one-dimensional bar element is used to approximate the axial displacement field in the Finite Element Method (FEM). Consider the parent (isoparametric) coordinate $\\xi \\in [-1,1]$ with three nodes located at $\\xi_1=-1$, $\\xi_2=0$, and $\\xi_3=1$. Let the approximate displacement be interpolated using three quadratic Lagrange shape functions $N_1(\\xi)$, $N_2(\\xi)$, and $N_3(\\xi)$, each a polynomial of degree at most $2$, such that they satisfy the Kronecker-delta interpolation conditions $N_i(\\xi_j)=\\delta_{ij}$ for $i,j\\in\\{1,2,3\\}$.\n\nStarting from the core definition of nodal interpolation and polynomial completeness, derive explicit expressions for $N_1(\\xi)$, $N_2(\\xi)$, and $N_3(\\xi)$ by enforcing the nodal conditions and the quadratic polynomial requirement. Then, verify two essential properties expected from such an interpolation:\n- Polynomial reproduction up to degree $2$: for any quadratic polynomial displacement field $u(\\xi)=a_0+a_1\\,\\xi+a_2\\,\\xi^2$, show that the interpolant $u^h(\\xi)=\\sum_{i=1}^3 N_i(\\xi)\\,u(\\xi_i)$ equals $u(\\xi)$ identically for all $\\xi\\in[-1,1]$.\n- Partition of unity: show that $\\sum_{i=1}^3 N_i(\\xi)=1$ for all $\\xi\\in[-1,1]$.\n\nProvide your final answer as the single row vector $\\left[N_1(\\xi)\\;N_2(\\xi)\\;N_3(\\xi)\\right]$ consisting of closed-form analytic expressions in terms of $\\xi$. No numerical rounding is required. Do not include units in your final answer.",
            "solution": "The problem presented is a standard exercise in the theory of the Finite Element Method. It is scientifically grounded, well-posed, objective, and complete. It contains no inconsistencies or fallacies. Therefore, I will proceed with its solution.\n\nThe task is to derive the quadratic Lagrange shape functions for a one-dimensional, three-noded parent element and verify two of their fundamental properties. The element is defined on the isoparametric coordinate domain $\\xi \\in [-1, 1]$, with nodes located at $\\xi_1 = -1$, $\\xi_2 = 0$, and $\\xi_3 = 1$.\n\nThe shape functions, denoted by $N_i(\\xi)$ for $i \\in \\{1, 2, 3\\}$, are polynomials of degree at most $2$. They are defined by the Kronecker-delta property at the nodal locations:\n$$ N_i(\\xi_j) = \\delta_{ij} = \\begin{cases} 1  \\text{if } i=j \\\\ 0  \\text{if } i \\neq j \\end{cases} $$\nWe shall derive each function by assuming a general quadratic form, $N(\\xi) = a\\xi^2 + b\\xi + c$, and solving for the coefficients $a$, $b$, and $c$ by enforcing these nodal conditions.\n\nDerivation of $N_1(\\xi)$:\nThe conditions for $N_1(\\xi)$ are $N_1(\\xi_1) = 1$, $N_1(\\xi_2) = 0$, and $N_1(\\xi_3) = 0$.\nLet $N_1(\\xi) = a_1\\xi^2 + b_1\\xi + c_1$.\n1.  At node $\\xi_2=0$: $N_1(0) = a_1(0)^2 + b_1(0) + c_1 = c_1 = 0$.\n2.  At node $\\xi_3=1$: $N_1(1) = a_1(1)^2 + b_1(1) + c_1 = a_1 + b_1 + 0 = 0$. This implies $b_1 = -a_1$.\n3.  At node $\\xi_1=-1$: $N_1(-1) = a_1(-1)^2 + b_1(-1) + c_1 = a_1 - b_1 + 0 = 1$.\nSubstituting $b_1 = -a_1$ into the third equation gives $a_1 - (-a_1) = 2a_1 = 1$, which yields $a_1 = \\frac{1}{2}$. Consequently, $b_1 = -\\frac{1}{2}$.\nThus, the expression for $N_1(\\xi)$ is:\n$$ N_1(\\xi) = \\frac{1}{2}\\xi^2 - \\frac{1}{2}\\xi = \\frac{1}{2}\\xi(\\xi-1) $$\n\nDerivation of $N_2(\\xi)$:\nThe conditions for $N_2(\\xi)$ are $N_2(\\xi_1) = 0$, $N_2(\\xi_2) = 1$, and $N_2(\\xi_3) = 0$.\nLet $N_2(\\xi) = a_2\\xi^2 + b_2\\xi + c_2$.\n1.  At node $\\xi_2=0$: $N_2(0) = a_2(0)^2 + b_2(0) + c_2 = c_2 = 1$.\n2.  At node $\\xi_3=1$: $N_2(1) = a_2(1)^2 + b_2(1) + c_2 = a_2 + b_2 + 1 = 0$.\n3.  At node $\\xi_1=-1$: $N_2(-1) = a_2(-1)^2 + b_2(-1) + c_2 = a_2 - b_2 + 1 = 0$.\nWe have a system of two linear equations for $a_2$ and $b_2$:\n$$ a_2 + b_2 = -1 $$\n$$ a_2 - b_2 = -1 $$\nAdding these two equations gives $2a_2 = -2$, so $a_2 = -1$. Substituting this into the first equation gives $-1 + b_2 = -1$, so $b_2 = 0$.\nThus, the expression for $N_2(\\xi)$ is:\n$$ N_2(\\xi) = (-1)\\xi^2 + (0)\\xi + 1 = 1 - \\xi^2 $$\n\nDerivation of $N_3(\\xi)$:\nThe conditions for $N_3(\\xi)$ are $N_3(\\xi_1) = 0$, $N_3(\\xi_2) = 0$, and $N_3(\\xi_3) = 1$.\nLet $N_3(\\xi) = a_3\\xi^2 + b_3\\xi + c_3$.\n1.  At node $\\xi_2=0$: $N_3(0) = a_3(0)^2 + b_3(0) + c_3 = c_3 = 0$.\n2.  At node $\\xi_1=-1$: $N_3(-1) = a_3(-1)^2 + b_3(-1) + c_3 = a_3 - b_3 + 0 = 0$. This implies $b_3 = a_3$.\n3.  At node $\\xi_3=1$: $N_3(1) = a_3(1)^2 + b_3(1) + c_3 = a_3 + b_3 + 0 = 1$.\nSubstituting $b_3 = a_3$ into the third equation gives $a_3 + a_3 = 2a_3 = 1$, which yields $a_3 = \\frac{1}{2}$. Consequently, $b_3 = \\frac{1}{2}$.\nThus, the expression for $N_3(\\xi)$ is:\n$$ N_3(\\xi) = \\frac{1}{2}\\xi^2 + \\frac{1}{2}\\xi = \\frac{1}{2}\\xi(\\xi+1) $$\n\nNow, we verify the two required properties.\n\nVerification of the Partition of Unity:\nWe must show that $\\sum_{i=1}^3 N_i(\\xi) = 1$ for all $\\xi \\in [-1, 1]$.\n$$ \\sum_{i=1}^3 N_i(\\xi) = N_1(\\xi) + N_2(\\xi) + N_3(\\xi) $$\n$$ = \\left(\\frac{1}{2}\\xi^2 - \\frac{1}{2}\\xi\\right) + (1 - \\xi^2) + \\left(\\frac{1}{2}\\xi^2 + \\frac{1}{2}\\xi\\right) $$\nCollect terms with like powers of $\\xi$:\n$$ = \\left(\\frac{1}{2} - 1 + \\frac{1}{2}\\right)\\xi^2 + \\left(-\\frac{1}{2} + \\frac{1}{2}\\right)\\xi + 1 $$\n$$ = (0)\\xi^2 + (0)\\xi + 1 = 1 $$\nThe partition of unity property is satisfied identically for all $\\xi$.\n\nVerification of Polynomial Reproduction:\nWe must show that for an arbitrary quadratic polynomial $u(\\xi) = a_0 + a_1\\xi + a_2\\xi^2$, the interpolant $u^h(\\xi) = \\sum_{i=1}^3 N_i(\\xi)u(\\xi_i)$ is identical to $u(\\xi)$.\nFirst, evaluate the nodal values of $u(\\xi)$:\n$u(\\xi_1) = u(-1) = a_0 - a_1 + a_2$\n$u(\\xi_2) = u(0) = a_0$\n$u(\\xi_3) = u(1) = a_0 + a_1 + a_2$\nNow, construct the interpolant $u^h(\\xi)$:\n$$ u^h(\\xi) = N_1(\\xi)(a_0 - a_1 + a_2) + N_2(\\xi)(a_0) + N_3(\\xi)(a_0 + a_1 + a_2) $$\nRearrange the expression by factoring out the coefficients $a_0$, $a_1$, and $a_2$:\n$$ u^h(\\xi) = a_0 [N_1(\\xi)+N_2(\\xi)+N_3(\\xi)] + a_1 [-N_1(\\xi)+N_3(\\xi)] + a_2 [N_1(\\xi)+N_3(\\xi)] $$\nLet us analyze the coefficient of each $a_k$:\nThe coefficient of $a_0$ is $\\sum_{i=1}^3 N_i(\\xi)$, which we have already proven to be $1$.\nThe coefficient of $a_1$ is $-N_1(\\xi)+N_3(\\xi)$:\n$$ -N_1(\\xi)+N_3(\\xi) = -\\left(\\frac{1}{2}\\xi^2 - \\frac{1}{2}\\xi\\right) + \\left(\\frac{1}{2}\\xi^2 + \\frac{1}{2}\\xi\\right) = -\\frac{1}{2}\\xi^2 + \\frac{1}{2}\\xi + \\frac{1}{2}\\xi^2 + \\frac{1}{2}\\xi = \\xi $$\nThe coefficient of $a_2$ is $N_1(\\xi)+N_3(\\xi)$:\n$$ N_1(\\xi)+N_3(\\xi) = \\left(\\frac{1}{2}\\xi^2 - \\frac{1}{2}\\xi\\right) + \\left(\\frac{1}{2}\\xi^2 + \\frac{1}{2}\\xi\\right) = \\xi^2 $$\nSubstituting these results back into the expression for $u^h(\\xi)$:\n$$ u^h(\\xi) = a_0(1) + a_1(\\xi) + a_2(\\xi^2) = a_0 + a_1\\xi + a_2\\xi^2 $$\nThis is identical to $u(\\xi)$. The capacity to reproduce any quadratic polynomial is confirmed. This is a direct consequence of the fact that the basis functions $\\{N_i(\\xi)\\}$ can represent the monomials $\\{1, \\xi, \\xi^2\\}$, which we have just demonstrated.\n\nThe derivations and verifications are complete. The final answer is the set of explicit expressions for the shape functions.",
            "answer": "$$ \\boxed{ \\begin{pmatrix} \\frac{1}{2}\\xi(\\xi-1)  1-\\xi^2  \\frac{1}{2}\\xi(\\xi+1) \\end{pmatrix} } $$"
        },
        {
            "introduction": "Next, we apply our understanding to a two-dimensional problem, linking the abstract mathematics of shape functions to the physical concept of strain. This practice  involves constructing the strain-displacement matrix ($\\mathbf{B}$ matrix) for a linear triangular element. You will discover why this element is called a Constant Strain Triangle and, more importantly, understand its inherent limitations in modeling more complex deformations like bending.",
            "id": "2635801",
            "problem": "Consider a two-dimensional linear triangular finite element (often called the Constant Strain Triangle) used in the Finite Element Method (FEM) for small-strain plane problems. Let the three nodes have Cartesian coordinates $(x_{1},y_{1})=(0,0)$, $(x_{2},y_{2})=(3,0)$, and $(x_{3},y_{3})=(1,2)$. The element has the usual linear shape functions $N_{1}(x,y)$, $N_{2}(x,y)$, and $N_{3}(x,y)$, each a linear polynomial in $x$ and $y$, satisfying the Kronecker-delta nodal interpolation property $N_{i}(x_{j},y_{j})=\\delta_{ij}$ and the partition of unity $\\sum_{i=1}^{3}N_{i}(x,y)=1$. The displacement field is interpolated as $u(x,y)=\\sum_{i=1}^{3}N_{i}(x,y)\\,u_{i}$ and $v(x,y)=\\sum_{i=1}^{3}N_{i}(x,y)\\,v_{i}$, where $u_{i}$ and $v_{i}$ are the nodal displacement components at node $i$ in the $x$- and $y$-directions, respectively. The small-strain vector is defined as $\\boldsymbol{\\varepsilon}=\\begin{pmatrix}\\varepsilon_{x}  \\varepsilon_{y}  \\gamma_{xy}\\end{pmatrix}^{\\mathsf{T}}=\\begin{pmatrix}\\partial u/\\partial x  \\partial v/\\partial y  \\partial u/\\partial y + \\partial v/\\partial x\\end{pmatrix}^{\\mathsf{T}}$. By definition of the element strain-displacement matrix, $\\boldsymbol{\\varepsilon}=\\mathbf{B}\\,\\mathbf{d}$ with $\\mathbf{d}=\\begin{pmatrix}u_{1}  v_{1}  u_{2}  v_{2}  u_{3}  v_{3}\\end{pmatrix}^{\\mathsf{T}}$.\n\nStarting only from the fundamental properties of the shape functions stated above and the definition of small strain, perform the following:\n\n1) Construct the linear shape functions $N_{1}(x,y)$, $N_{2}(x,y)$, and $N_{3}(x,y)$ consistent with the given nodal coordinates, and compute their constant gradients $\\partial N_{i}/\\partial x$ and $\\partial N_{i}/\\partial y$.\n\n2) Assemble the element strain-displacement matrix $\\mathbf{B}$ such that $\\boldsymbol{\\varepsilon}=\\mathbf{B}\\,\\mathbf{d}$, written in the standard ordering $\\boldsymbol{\\varepsilon}=\\begin{pmatrix}\\varepsilon_{x}  \\varepsilon_{y}  \\gamma_{xy}\\end{pmatrix}^{\\mathsf{T}}$ and $\\mathbf{d}=\\begin{pmatrix}u_{1}  v_{1}  u_{2}  v_{2}  u_{3}  v_{3}\\end{pmatrix}^{\\mathsf{T}}$.\n\n3) Using only first principles, explain why the matrix $\\mathbf{B}$ is constant over the element domain, and deduce the consequences: that the element produces a uniform (constant) strain field under any nodal displacement vector and therefore cannot represent a pure bending state that requires a spatially varying normal strain. Make your argument by characterizing the most general displacement field the element can produce and differentiating it.\n\nProvide the final $\\mathbf{B}$ matrix with exact rational entries. Do not round. Your final boxed answer must be the single matrix $\\mathbf{B}$ without units.",
            "solution": "The problem statement is validated as scientifically grounded, well-posed, and objective. It represents a standard, fundamental exercise in the theory of the Finite Element Method. All provided data are self-contained and consistent. We proceed with the solution.\n\nThe problem requires the construction of the strain-displacement matrix $\\mathbf{B}$ for a linear triangular element, along with a first-principles explanation of its properties. This will be performed in three parts as requested.\n\n**Part 1: Construction of Shape Functions and Gradients**\n\nA linear shape function for a two-dimensional element has the general form:\n$$N_{i}(x,y) = \\alpha_{i0} + \\alpha_{i1} x + \\alpha_{i2} y$$\nThe three coefficients for each shape function are determined by enforcing the Kronecker-delta property, $N_{i}(x_{j},y_{j})=\\delta_{ij}$, at the three nodes. The given nodal coordinates are $(x_{1},y_{1})=(0,0)$, $(x_{2},y_{2})=(3,0)$, and $(x_{3},y_{3})=(1,2)$.\n\nFor shape function $N_{1}(x,y)$:\n1. $N_{1}(x_{1},y_{1})=N_{1}(0,0) = \\alpha_{10} = 1$\n2. $N_{1}(x_{2},y_{2})=N_{1}(3,0) = \\alpha_{10} + 3\\alpha_{11} = 1 + 3\\alpha_{11} = 0 \\implies \\alpha_{11} = -1/3$\n3. $N_{1}(x_{3},y_{3})=N_{1}(1,2) = \\alpha_{10} + \\alpha_{11} + 2\\alpha_{12} = 1 - 1/3 + 2\\alpha_{12} = 0 \\implies 2/3 + 2\\alpha_{12} = 0 \\implies \\alpha_{12} = -1/3$\nThus, $N_{1}(x,y) = 1 - \\frac{1}{3}x - \\frac{1}{3}y$.\n\nFor shape function $N_{2}(x,y)$:\n1. $N_{2}(x_{1},y_{1})=N_{2}(0,0) = \\alpha_{20} = 0$\n2. $N_{2}(x_{2},y_{2})=N_{2}(3,0) = \\alpha_{20} + 3\\alpha_{21} = 3\\alpha_{21} = 1 \\implies \\alpha_{21} = 1/3$\n3. $N_{2}(x_{3},y_{3})=N_{2}(1,2) = \\alpha_{20} + \\alpha_{21} + 2\\alpha_{22} = 1/3 + 2\\alpha_{22} = 0 \\implies \\alpha_{22} = -1/6$\nThus, $N_{2}(x,y) = \\frac{1}{3}x - \\frac{1}{6}y$.\n\nFor shape function $N_{3}(x,y)$:\n1. $N_{3}(x_{1},y_{1})=N_{3}(0,0) = \\alpha_{30} = 0$\n2. $N_{3}(x_{2},y_{2})=N_{3}(3,0) = \\alpha_{30} + 3\\alpha_{31} = 3\\alpha_{31} = 0 \\implies \\alpha_{31} = 0$\n3. $N_{3}(x_{3},y_{3})=N_{3}(1,2) = \\alpha_{30} + \\alpha_{31} + 2\\alpha_{32} = 2\\alpha_{32} = 1 \\implies \\alpha_{32} = 1/2$\nThus, $N_{3}(x,y) = \\frac{1}{2}y$.\n\nThe partition of unity condition, $\\sum_{i=1}^{3}N_{i}=1$, is satisfied:\n$$ \\left(1 - \\frac{1}{3}x - \\frac{1}{3}y\\right) + \\left(\\frac{1}{3}x - \\frac{1}{6}y\\right) + \\left(\\frac{1}{2}y\\right) = 1 + \\left(-\\frac{1}{3}+\\frac{1}{3}\\right)x + \\left(-\\frac{1}{3}-\\frac{1}{6}+\\frac{1}{2}\\right)y = 1 $$\nThe gradients of the shape functions are computed by direct differentiation. As the shape functions are linear polynomials in $x$ and $y$, their gradients are constant.\n$$ \\frac{\\partial N_{1}}{\\partial x} = -\\frac{1}{3}, \\quad \\frac{\\partial N_{1}}{\\partial y} = -\\frac{1}{3} $$\n$$ \\frac{\\partial N_{2}}{\\partial x} = \\frac{1}{3}, \\quad \\frac{\\partial N_{2}}{\\partial y} = -\\frac{1}{6} $$\n$$ \\frac{\\partial N_{3}}{\\partial x} = 0, \\quad \\frac{\\partial N_{3}}{\\partial y} = \\frac{1}{2} $$\n\n**Part 2: Assembly of the Strain-Displacement Matrix $\\mathbf{B}$**\n\nThe displacement field $(u, v)$ is interpolated from the nodal displacements $(u_i, v_i)$ using the shape functions:\n$$ u(x,y) = \\sum_{i=1}^{3} N_{i}(x,y) u_{i} = N_{1}u_{1} + N_{2}u_{2} + N_{3}u_{3} $$\n$$ v(x,y) = \\sum_{i=1}^{3} N_{i}(x,y) v_{i} = N_{1}v_{1} + N_{2}v_{2} + N_{3}v_{3} $$\nThe small-strain components are defined as:\n$$ \\varepsilon_{x} = \\frac{\\partial u}{\\partial x}, \\quad \\varepsilon_{y} = \\frac{\\partial v}{\\partial y}, \\quad \\gamma_{xy} = \\frac{\\partial u}{\\partial y} + \\frac{\\partial v}{\\partial x} $$\nBy substituting the interpolated displacement fields, we find the strains:\n$$ \\varepsilon_{x} = \\frac{\\partial}{\\partial x} \\left( \\sum_{i=1}^{3} N_{i} u_{i} \\right) = \\sum_{i=1}^{3} \\frac{\\partial N_{i}}{\\partial x} u_{i} = \\frac{\\partial N_{1}}{\\partial x}u_{1} + \\frac{\\partial N_{2}}{\\partial x}u_{2} + \\frac{\\partial N_{3}}{\\partial x}u_{3} $$\n$$ \\varepsilon_{y} = \\frac{\\partial}{\\partial y} \\left( \\sum_{i=1}^{3} N_{i} v_{i} \\right) = \\sum_{i=1}^{3} \\frac{\\partial N_{i}}{\\partial y} v_{i} = \\frac{\\partial N_{1}}{\\partial y}v_{1} + \\frac{\\partial N_{2}}{\\partial y}v_{2} + \\frac{\\partial N_{3}}{\\partial y}v_{3} $$\n$$ \\gamma_{xy} = \\frac{\\partial}{\\partial y} \\left( \\sum_{i=1}^{3} N_{i} u_{i} \\right) + \\frac{\\partial}{\\partial x} \\left( \\sum_{i=1}^{3} N_{i} v_{i} \\right) = \\sum_{i=1}^{3} \\left( \\frac{\\partial N_{i}}{\\partial y} u_{i} + \\frac{\\partial N_{i}}{\\partial x} v_{i} \\right) $$\nThese expressions can be written in matrix form $\\boldsymbol{\\varepsilon} = \\mathbf{B} \\mathbf{d}$, where $\\mathbf{d} = \\begin{pmatrix} u_{1}  v_{1}  u_{2}  v_{2}  u_{3}  v_{3} \\end{pmatrix}^{\\mathsf{T}}$:\n$$\n\\begin{pmatrix} \\varepsilon_{x} \\\\ \\varepsilon_{y} \\\\ \\gamma_{xy} \\end{pmatrix} =\n\\begin{pmatrix}\n\\frac{\\partial N_{1}}{\\partial x}  0  \\frac{\\partial N_{2}}{\\partial x}  0  \\frac{\\partial N_{3}}{\\partial x}  0 \\\\\n0  \\frac{\\partial N_{1}}{\\partial y}  0  \\frac{\\partial N_{2}}{\\partial y}  0  \\frac{\\partial N_{3}}{\\partial y} \\\\\n\\frac{\\partial N_{1}}{\\partial y}  \\frac{\\partial N_{1}}{\\partial x}  \\frac{\\partial N_{2}}{\\partial y}  \\frac{\\partial N_{2}}{\\partial x}  \\frac{\\partial N_{3}}{\\partial y}  \\frac{\\partial N_{3}}{\\partial x}\n\\end{pmatrix}\n\\begin{pmatrix} u_{1} \\\\ v_{1} \\\\ u_{2} \\\\ v_{2} \\\\ u_{3} \\\\ v_{3} \\end{pmatrix}\n$$\nThe matrix $\\mathbf{B}$ is thus identified. Substituting the constant gradients computed in Part 1 yields the final result for this element:\n$$ \\mathbf{B} = \\begin{pmatrix}\n-\\frac{1}{3}  0  \\frac{1}{3}  0  0  0 \\\\\n0  -\\frac{1}{3}  0  -\\frac{1}{6}  0  \\frac{1}{2} \\\\\n-\\frac{1}{3}  -\\frac{1}{3}  -\\frac{1}{6}  \\frac{1}{3}  \\frac{1}{2}  0\n\\end{pmatrix} $$\n\n**Part 3: First-Principles Explanation**\n\nThe constant-strain behavior of the linear triangular element is a direct consequence of the linearity of its shape functions.\n\n1.  **Why $\\mathbf{B}$ is constant:** The matrix $\\mathbf{B}$ is composed entirely of the first partial derivatives of the shape functions, $\\frac{\\partial N_{i}}{\\partial x}$ and $\\frac{\\partial N_{i}}{\\partial y}$. By definition, the shape functions $N_i(x, y)$ for this element type are linear polynomials of the form $\\alpha_{i0} + \\alpha_{i1} x + \\alpha_{i2} y$. The partial derivative of such a function with respect to $x$ or $y$ is a constant ($\\alpha_{i1}$ or $\\alpha_{i2}$, respectively). Since every entry in the $\\mathbf{B}$ matrix is one of these constant gradients (or zero), the entire matrix $\\mathbf{B}$ is constant across the element domain. Its values depend only on the nodal coordinates, which define the geometry, and not on the position $(x, y)$ within the element.\n\n2.  **Consequences (Constant Strain and failure to model bending):**\n    The displacement field, $u(x,y)$ and $v(x,y)$, is a linear combination of the linear shape functions. A linear combination of linear polynomials results in another linear polynomial. Therefore, the most general displacement field this element can represent is of the form:\n    $$ u(x,y) = c_{1} + c_{2}x + c_{3}y $$\n    $$ v(x,y) = c_{4} + c_{5}x + c_{6}y $$\n    where the coefficients $c_{k}$ are constants determined by the nodal displacements.\n    The strains are obtained by differentiating this displacement field:\n    $$ \\varepsilon_{x} = \\frac{\\partial u}{\\partial x} = c_{2} $$\n    $$ \\varepsilon_{y} = \\frac{\\partial v}{\\partial y} = c_{6} $$\n    $$ \\gamma_{xy} = \\frac{\\partial u}{\\partial y} + \\frac{\\partial v}{\\partial x} = c_{3} + c_{5} $$\n    The strain components are constants throughout the element. This is why the element is known as the Constant Strain Triangle (CST).\n\n    Pure bending, however, is fundamentally characterized by a linearly varying strain field. For instance, a beam bending in the $x-y$ plane has a normal strain $\\varepsilon_x$ that is a linear function of $y$, such as $\\varepsilon_{x}(y) = \\kappa y$, where $\\kappa$ is the curvature. A constant strain field can only be a non-constant linear function if both the constant and the slope are zero, which is the trivial case of no deformation. The CST element, by its formulation, is restricted to producing only a single, constant value for each strain component within its domain. It is therefore constitutionally incapable of representing the strain gradient essential to a pure bending state. An assemblage of such elements can only approximate a bending moment with a piecewise-constant \"staircase\" of stress, which is a poor representation and leads to numerical pathologies such as shear locking.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n-\\frac{1}{3}  0  \\frac{1}{3}  0  0  0 \\\\\n0  -\\frac{1}{3}  0  -\\frac{1}{6}  0  \\frac{1}{2} \\\\\n-\\frac{1}{3}  -\\frac{1}{3}  -\\frac{1}{6}  \\frac{1}{3}  \\frac{1}{2}  0\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "Finally, we transition from theory to computational practice by exploring the workhorse of 2D analysis: the four-node quadrilateral element. This programming-focused exercise  delves into the crucial concept of isoparametric mapping, where you will implement the calculation of the Jacobian determinant for distorted elements. By computing metrics that account for geometric distortion, you will gain a practical understanding of how element quality impacts the accuracy of finite element solutions.",
            "id": "3272799",
            "problem": "You are tasked with building the computational core of a two-dimensional color-mapping tool based on shape functions within the Finite Element Method (FEM). The visualization idea is as follows: a scalar \"color intensity\" over a quadrilateral element is assigned by a selected shape function $N_i(\\xi,\\eta)$ on the parent (reference) domain, while the element in physical space changes shape as its nodes are \"dragged.\" In this programming exercise, you will not implement any graphics or interactive features; instead, you will derive the relevant formulas from first principles and compute quantitative metrics of the \"color intensity\" field over a sample grid.\n\nFundamental base to use:\n- The reference (parent) domain is the square $[-1,1] \\times [-1,1]$ with coordinates $(\\xi,\\eta)$.\n- For a four-node bilinear quadrilateral element, define shape functions $N_1(\\xi,\\eta)$, $N_2(\\xi,\\eta)$, $N_3(\\xi,\\eta)$, and $N_4(\\xi,\\eta)$ such that the following interpolation properties hold: $N_i(\\xi_j,\\eta_j) = \\delta_{ij}$ at the four corners $(\\xi_j,\\eta_j) \\in \\{(-1,-1),(1,-1),(1,1),(-1,1)\\}$, where $\\delta_{ij}$ is the Kronecker delta, and the partition of unity property $\\sum_{i=1}^4 N_i(\\xi,\\eta) = 1$ holds for all $(\\xi,\\eta)$ in the reference domain.\n- Isoparametric mapping defines the physical coordinates $(x,y)$ as $x(\\xi,\\eta) = \\sum_{i=1}^4 N_i(\\xi,\\eta) x_i$ and $y(\\xi,\\eta) = \\sum_{i=1}^4 N_i(\\xi,\\eta) y_i$, where $(x_i,y_i)$ are the physical coordinates of the element nodes, ordered consistently with the reference corners as $(\\xi_1,\\eta_1)=(-1,-1)$, $(\\xi_2,\\eta_2)=(1,-1)$, $(\\xi_3,\\eta_3)=(1,1)$, $(\\xi_4,\\eta_4)=(-1,1)$.\n- The Jacobian matrix of the mapping is $\\mathbf{J}(\\xi,\\eta) = \\begin{bmatrix} \\frac{\\partial x}{\\partial \\xi}  \\frac{\\partial x}{\\partial \\eta} \\\\ \\frac{\\partial y}{\\partial \\xi}  \\frac{\\partial y}{\\partial \\eta} \\end{bmatrix}$ with determinant $J(\\xi,\\eta) = \\det \\mathbf{J}(\\xi,\\eta)$. For area-related weighting, you should use the absolute value $\\lvert J(\\xi,\\eta) \\rvert$.\n\nYour objectives:\n1. Derive explicit formulas for the four bilinear shape functions $N_i(\\xi,\\eta)$ from the interpolation properties in the reference domain.\n2. Derive the expressions for the partial derivatives $\\frac{\\partial N_i}{\\partial \\xi}$ and $\\frac{\\partial N_i}{\\partial \\eta}$, and use them to compute the Jacobian determinant $J(\\xi,\\eta)$ for any given element node positions.\n3. Implement a program that:\n   - Constructs a uniform grid of $n \\times n$ sample points over the reference domain $[-1,1] \\times [-1,1]$ (choose $n=41$).\n   - For a selected index $i \\in \\{1,2,3,4\\}$, treats $N_i(\\xi,\\eta)$ as the color intensity at $(\\xi,\\eta)$ and computes the following metrics over the grid:\n     a) The physically area-weighted mean color intensity, defined as $$\\overline{N_i} = \\frac{\\sum_{k=1}^{n^2} N_i(\\xi_k,\\eta_k) \\lvert J(\\xi_k,\\eta_k) \\rvert}{\\sum_{k=1}^{n^2} \\lvert J(\\xi_k,\\eta_k) \\rvert}.$$\n     b) The physically area-weighted standard deviation of the color intensity, defined as $$\\sigma_{N_i} = \\sqrt{\\frac{\\sum_{k=1}^{n^2} \\lvert J(\\xi_k,\\eta_k) \\rvert \\left(N_i(\\xi_k,\\eta_k) - \\overline{N_i}\\right)^2}{\\sum_{k=1}^{n^2} \\lvert J(\\xi_k,\\eta_k) \\rvert}}.$$\n     c) The minimum of $\\lvert J(\\xi,\\eta) \\rvert$ over the grid.\n     d) The maximum of $\\lvert J(\\xi,\\eta) \\rvert$ over the grid.\n     e) The maximum absolute deviation from the partition of unity, defined as $$\\max_{k=1,\\dots,n^2} \\left\\lvert \\sum_{j=1}^{4} N_j(\\xi_k,\\eta_k) - 1 \\right\\rvert.$$\n   - Note: The physically area-weighted quantities incorporate the geometric distortion from node dragging through $\\lvert J(\\xi,\\eta) \\rvert$. This simulates how the visualization would emphasize regions in physical space that occupy more area.\n\nTest suite:\nUse the following four test cases, each defined by the element node coordinates $\\left[(x_1,y_1),(x_2,y_2),(x_3,y_3),(x_4,y_4)\\right]$ and the selected shape function index $i$.\n- Case 1 (happy path, affine rectangle): nodes $[(0,0),(2,0),(2,1),(0,1)]$, $i=1$.\n- Case 2 (convex quadrilateral, non-affine): nodes $[(0,0),(2,0),(1.6,1.2),(0,1)]$, $i=2$.\n- Case 3 (slender near-degenerate element): nodes $[(0,0),(1,0),(0.8,0.05),(0,0.05)]$, $i=4$.\n- Case 4 (inverted/distorted element): nodes $[(0,0),(1,0),(0.2,1.0),(-0.1,0.1)]$, $i=3$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each test case, output the five floating-point metrics in the order $\\left[\\overline{N_i}, \\sigma_{N_i}, \\min \\lvert J \\rvert, \\max \\lvert J \\rvert, \\text{partition\\_of\\_unity\\_max\\_deviation}\\right]$ and aggregate all four cases sequentially into one flat list. For example, the general format is\n$[\\text{case1\\_mean},\\text{case1\\_std},\\text{case1\\_minJ},\\text{case1\\_maxJ},\\text{case1\\_pu\\_dev},\\text{case2\\_mean},\\dots,\\text{case4\\_pu\\_dev}]$.\nAll values should be reported as floating-point numbers. No physical units or angles are involved in this problem, so no unit specification is required.",
            "solution": "The problem statement is evaluated to be scientifically grounded, well-posed, objective, and complete. It describes a standard, albeit detailed, computational task within the framework of the Finite Element Method (FEM). All definitions, variables, and objectives are clearly specified, and the test cases provided are appropriate for verifying the implementation. The problem is therefore deemed **valid**, and a solution is provided below.\n\nThe solution is structured according to the objectives outlined in the problem statement. First, we derive the necessary analytical formulas for the shape functions and the Jacobian of the isoparametric mapping. Second, we describe the computational procedure for calculating the required metrics.\n\n**1. Derivation of Bilinear Shape Functions**\n\nThe four-node quadrilateral element uses bilinear shape functions $N_i(\\xi, \\eta)$, which are linear in both $\\xi$ and $\\eta$. They are defined on the parent domain, a square in $(\\xi, \\eta)$ space where $\\xi \\in [-1, 1]$ and $\\eta \\in [-1, 1]$. A common method for constructing these functions is by taking products of 1D linear Lagrange interpolation polynomials. The 1D basis functions on an interval $\\zeta \\in [-1, 1]$ are:\n$$L_1(\\zeta) = \\frac{1}{2}(1-\\zeta)$$\n$$L_2(\\zeta) = \\frac{1}{2}(1+\\zeta)$$\n$L_1$ is $1$ at $\\zeta=-1$ and $0$ at $\\zeta=1$, while $L_2$ is $0$ at $\\zeta=-1$ and $1$ at $\\zeta=1$.\n\nThe 2D shape functions are formed by combining these 1D functions for the $\\xi$ and $\\eta$ coordinates, corresponding to the four nodes of the parent element: Node 1 at $(-1, -1)$, Node 2 at $(1, -1)$, Node 3 at $(1, 1)$, and Node 4 at $(-1, 1)$.\n\n- **Shape Function $N_1(\\xi, \\eta)$ for Node 1 $(-1, -1)$:**\n  This function must be $1$ at $(\\xi, \\eta) = (-1, -1)$ and $0$ at the other three nodes. This is achieved by the product $L_1(\\xi)L_1(\\eta)$.\n  $$N_1(\\xi, \\eta) = \\frac{1}{2}(1-\\xi) \\frac{1}{2}(1-\\eta) = \\frac{1}{4}(1 - \\xi - \\eta + \\xi\\eta)$$\n\n- **Shape Function $N_2(\\xi, \\eta)$ for Node 2 $(1, -1)$:**\n  This function requires the product $L_2(\\xi)L_1(\\eta)$.\n  $$N_2(\\xi, \\eta) = \\frac{1}{2}(1+\\xi) \\frac{1}{2}(1-\\eta) = \\frac{1}{4}(1 + \\xi - \\eta - \\xi\\eta)$$\n\n- **Shape Function $N_3(\\xi, \\eta)$ for Node 3 $(1, 1)$:**\n  This function requires the product $L_2(\\xi)L_2(\\eta)$.\n  $$N_3(\\xi, \\eta) = \\frac{1}{2}(1+\\xi) \\frac{1}{2}(1+\\eta) = \\frac{1}{4}(1 + \\xi + \\eta + \\xi\\eta)$$\n\n- **Shape Function $N_4(\\xi, \\eta)$ for Node 4 $(-1, 1)$:**\n  This function requires the product $L_1(\\xi)L_2(\\eta)$.\n  $$N_4(\\xi, \\eta) = \\frac{1}{2}(1-\\xi) \\frac{1}{2}(1+\\eta) = \\frac{1}{4}(1 - \\xi + \\eta - \\xi\\eta)$$\n\nThese functions satisfy the Kronecker delta property $N_i(\\xi_j, \\eta_j) = \\delta_{ij}$ and the partition of unity property $\\sum_{i=1}^4 N_i(\\xi, \\eta) = 1$, which can be verified by direct summation. The latter serves as an important internal check for the computational implementation.\n\n**2. Derivation of the Jacobian Determinant**\n\nThe Jacobian matrix $\\mathbf{J}$ relates derivatives in the physical space $(x, y)$ to derivatives in the reference space $(\\xi, \\eta)$. Its components depend on the partial derivatives of the shape functions.\n\nFirst, we find the partial derivatives of each shape function with respect to $\\xi$ and $\\eta$:\n$$ \\frac{\\partial N_1}{\\partial \\xi} = \\frac{1}{4}(-1 + \\eta), \\quad \\frac{\\partial N_1}{\\partial \\eta} = \\frac{1}{4}(-1 + \\xi) $$\n$$ \\frac{\\partial N_2}{\\partial \\xi} = \\frac{1}{4}(1 - \\eta), \\quad \\frac{\\partial N_2}{\\partial \\eta} = \\frac{1}{4}(-1 - \\xi) $$\n$$ \\frac{\\partial N_3}{\\partial \\xi} = \\frac{1}{4}(1 + \\eta), \\quad \\frac{\\partial N_3}{\\partial \\eta} = \\frac{1}{4}(1 + \\xi) $$\n$$ \\frac{\\partial N_4}{\\partial \\xi} = \\frac{1}{4}(-1 - \\eta), \\quad \\frac{\\partial N_4}{\\partial \\eta} = \\frac{1}{4}(1 - \\xi) $$\n\nThe isoparametric mapping from reference to physical coordinates is given by:\n$$x(\\xi, \\eta) = \\sum_{i=1}^4 N_i(\\xi, \\eta) x_i$$\n$$y(\\xi, \\eta) = \\sum_{i=1}^4 N_i(\\xi, \\eta) y_i$$\nThe components of the Jacobian matrix $\\mathbf{J}$ are the partial derivatives of this mapping:\n$$ \\frac{\\partial x}{\\partial \\xi} = \\sum_{i=1}^4 \\frac{\\partial N_i}{\\partial \\xi} x_i, \\quad \\frac{\\partial x}{\\partial \\eta} = \\sum_{i=1}^4 \\frac{\\partial N_i}{\\partial \\eta} x_i $$\n$$ \\frac{\\partial y}{\\partial \\xi} = \\sum_{i=1}^4 \\frac{\\partial N_i}{\\partial \\xi} y_i, \\quad \\frac{\\partial y}{\\partial \\eta} = \\sum_{i=1}^4 \\frac{\\partial N_i}{\\partial \\eta} y_i $$\nThe Jacobian matrix is therefore:\n$$ \\mathbf{J}(\\xi, \\eta) = \\begin{bmatrix} \\sum_i \\frac{\\partial N_i}{\\partial \\xi} x_i  \\sum_i \\frac{\\partial N_i}{\\partial \\eta} x_i \\\\ \\sum_i \\frac{\\partial N_i}{\\partial \\xi} y_i  \\sum_i \\frac{\\partial N_i}{\\partial \\eta} y_i \\end{bmatrix} $$\nThe Jacobian determinant $J(\\xi, \\eta) = \\det \\mathbf{J}(\\xi, \\eta)$ is then computed as:\n$$ J(\\xi, \\eta) = \\left( \\frac{\\partial x}{\\partial \\xi} \\right) \\left( \\frac{\\partial y}{\\partial \\eta} \\right) - \\left( \\frac{\\partial x}{\\partial \\eta} \\right) \\left( \\frac{\\partial y}{\\partial \\xi} \\right) $$\nIn the context of area-related calculations, the absolute value of the determinant, $\\lvert J(\\xi, \\eta) \\rvert$, is used. This value represents the differential area ratio $dA_{phys} / dA_{ref}$. For a non-degenerate, non-inverted element, $J(\\xi, \\eta)  0$ throughout the domain.\n\n**3. Computational Implementation**\n\nThe program implements the derived formulas to compute the specified metrics for each test case.\n\n**Grid Generation:** A uniform grid of $n \\times n$ points (with $n=41$) is generated over the reference domain $[-1, 1] \\times [-1, 1]$. This is achieved using `numpy.linspace` to create coordinate vectors for $\\xi$ and $\\eta$, and `numpy.meshgrid` to produce 2D arrays representing the coordinates of each grid point.\n\n**Vectorized Computation:** To efficiently perform calculations over the entire grid, we leverage NumPy's vectorized operations. Functions are implemented to compute the values of all four shape functions $N_i$ and their partial derivatives $\\frac{\\partial N_i}{\\partial \\xi}, \\frac{\\partial N_i}{\\partial \\eta}$ for all $(\\xi, \\eta)$ grid points simultaneously. This results in arrays of shape $(4, n, n)$.\n\n**Jacobian Calculation:** For a given set of nodal coordinates $(x_i, y_i)$, the four terms of the Jacobian matrix are computed as tensor contractions (specifically, dot products) between the nodal coordinate vectors and the shape function derivative arrays. For instance, $\\frac{\\partial x}{\\partial \\xi}$ is computed over the grid as an array by summing the products of the $\\frac{\\partial N_i}{\\partial \\xi}$ arrays with their corresponding $x_i$ coordinates. This is efficiently done using `numpy.einsum`. The Jacobian determinant array $J$ is then calculated from these four component arrays.\n\n**Metrics Calculation:** With the grid arrays for the selected shape function $N_i(\\xi_k, \\eta_k)$ and the absolute Jacobian determinant $\\lvert J(\\xi_k, \\eta_k) \\rvert$ available, the five metrics are computed as follows:\n- **Mean Color Intensity ($\\overline{N_i}$):** A weighted average of $N_i$ values, with $\\lvert J \\rvert$ as the weights. This is computed as $\\frac{\\sum(N_i \\cdot \\lvert J \\rvert)}{\\sum \\lvert J \\rvert}$.\n- **Standard Deviation ($\\sigma_{N_i}$):** The square root of the weighted variance. The weighted variance is calculated as the weighted average of the squared differences from the weighted mean, $\\frac{\\sum(\\lvert J \\rvert \\cdot (N_i - \\overline{N_i})^2)}{\\sum \\lvert J \\rvert}$.\n- **Min/Max of $\\lvert J \\rvert$:** The minimum and maximum values in the $\\lvert J \\rvert$ array are found.\n- **Partition of Unity Deviation:** The four $N_i$ arrays are summed. The maximum absolute deviation of this sum from $1.0$ across the grid is calculated. This metric serves as a numerical verification of the shape function implementation; its value should be on the order of machine floating-point precision.\n\nThe program iterates through each test case, performs these computations, and aggregates the resulting five metrics into a single flat list for final output.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the FEM color-mapping problem by deriving and implementing\n    formulas for bilinear shape functions and the isoparametric Jacobian.\n    It computes five specified metrics for four test cases.\n    \"\"\"\n\n    # Test cases: [(node_coords), shape_function_index_i]\n    # Node coords are ordered [(x1,y1), (x2,y2), (x3,y3), (x4,y4)]\n    test_cases = [\n        (np.array([[0, 0], [2, 0], [2, 1], [0, 1]]), 1),  # Case 1\n        (np.array([[0, 0], [2, 0], [1.6, 1.2], [0, 1]]), 2),  # Case 2\n        (np.array([[0, 0], [1, 0], [0.8, 0.05], [0, 0.05]]), 4),  # Case 3\n        (np.array([[0, 0], [1, 0], [0.2, 1.0], [-0.1, 0.1]]), 3), # Case 4\n    ]\n\n    all_results = []\n    \n    # Grid parameters\n    n = 41\n    xi_coords = np.linspace(-1.0, 1.0, n)\n    eta_coords = np.linspace(-1.0, 1.0, n)\n    xi_grid, eta_grid = np.meshgrid(xi_coords, eta_coords)\n\n    def get_shape_functions_and_derivatives(xi, eta):\n        \"\"\"\n        Calculates bilinear shape functions and their derivatives\n        on a grid of (xi, eta) points.\n        \n        Args:\n            xi (np.ndarray): 2D array of xi coordinates.\n            eta (np.ndarray): 2D array of eta coordinates.\n            \n        Returns:\n            tuple: (N, dN_dxi, dN_deta)\n                N: (4, n, n) array of shape function values.\n                dN_dxi: (4, n, n) array of xi-derivatives.\n                dN_deta: (4, n, n) array of eta-derivatives.\n        \"\"\"\n        # Shape functions N_i(xi, eta)\n        N1 = 0.25 * (1 - xi) * (1 - eta)\n        N2 = 0.25 * (1 + xi) * (1 - eta)\n        N3 = 0.25 * (1 + xi) * (1 + eta)\n        N4 = 0.25 * (1 - xi) * (1 + eta)\n        \n        N = np.array([N1, N2, N3, N4])\n\n        # Derivatives wrt xi\n        dN1_dxi = 0.25 * (-1) * (1 - eta)\n        dN2_dxi = 0.25 * (1)  * (1 - eta)\n        dN3_dxi = 0.25 * (1)  * (1 + eta)\n        dN4_dxi = 0.25 * (-1) * (1 + eta)\n        dN_dxi = np.array([dN1_dxi, dN2_dxi, dN3_dxi, dN4_dxi])\n\n        # Derivatives wrt eta\n        dN1_deta = 0.25 * (1 - xi) * (-1)\n        dN2_deta = 0.25 * (1 + xi) * (-1)\n        dN3_deta = 0.25 * (1 + xi) * (1)\n        dN4_deta = 0.25 * (1 - xi) * (1)\n        dN_deta = np.array([dN1_deta, dN2_deta, dN3_deta, dN4_deta])\n        \n        return N, dN_dxi, dN_deta\n\n    # Pre-calculate shape functions and derivatives on the grid\n    N_vals, dN_dxi_vals, dN_deta_vals = get_shape_functions_and_derivatives(xi_grid, eta_grid)\n\n    for case_nodes, i_selected in test_cases:\n        x_nodes = case_nodes[:, 0]\n        y_nodes = case_nodes[:, 1]\n        \n        # Calculate Jacobian matrix components using einsum for clean tensor contraction\n        # J_11 = dx/dxi, J_12 = dx/deta, J_21 = dy/dxi, J_22 = dy/deta\n        J_11 = np.einsum('i,ijk-jk', x_nodes, dN_dxi_vals)\n        J_12 = np.einsum('i,ijk-jk', x_nodes, dN_deta_vals)\n        J_21 = np.einsum('i,ijk-jk', y_nodes, dN_dxi_vals)\n        J_22 = np.einsum('i,ijk-jk', y_nodes, dN_deta_vals)\n\n        # Calculate Jacobian determinant\n        J_det = J_11 * J_22 - J_12 * J_21\n        abs_J_det = np.abs(J_det)\n        \n        # Select the color intensity field from the pre-calculated shape functions\n        # Note: i is 1-based, array is 0-based\n        N_i_vals = N_vals[i_selected - 1]\n        \n        # (a) Physically area-weighted mean color intensity\n        # np.average handles the weighted average calculation: sum(a*w) / sum(w)\n        mean_Ni = np.average(N_i_vals, weights=abs_J_det)\n        \n        # (b) Physically area-weighted standard deviation\n        # Use np.average again for the weighted variance\n        variance_Ni = np.average((N_i_vals - mean_Ni)**2, weights=abs_J_det)\n        std_dev_Ni = np.sqrt(variance_Ni)\n        \n        # (c) Minimum of |J| over the grid\n        min_J = np.min(abs_J_det)\n        \n        # (d) Maximum of |J| over the grid\n        max_J = np.max(abs_J_det)\n\n        # (e) Maximum absolute deviation from partition of unity\n        sum_N = np.sum(N_vals, axis=0) # Sum over the 4 shape functions\n        pu_deviation = np.max(np.abs(sum_N - 1.0))\n        \n        # Collect results for this case\n        case_results = [mean_Ni, std_dev_Ni, min_J, max_J, pu_deviation]\n        all_results.extend(case_results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        }
    ]
}