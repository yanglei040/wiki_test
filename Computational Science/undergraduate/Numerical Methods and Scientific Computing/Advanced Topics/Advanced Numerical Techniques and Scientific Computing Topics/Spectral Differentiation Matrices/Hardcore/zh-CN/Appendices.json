{
    "hands_on_practices": [
        {
            "introduction": "使用谱方法求解偏微分方程时，一个核心挑战是如何精确地施加边界条件。本练习将指导您掌握一种处理狄利克雷（Dirichlet）边界条件的基本而强大的技术，即通过划分算子将系统简化为只求解内部节点未知量的常微分方程组 。通过这种方式，给定的边界值被视为一个时变的“驱动项”，从而将边界信息无缝地融入到系统的演化中。",
            "id": "3277262",
            "problem": "考虑区间 $[-1,1]$ 上的一维偏微分方程 (PDE)，\n$$\n\\frac{\\partial u}{\\partial t}(x,t) = \\frac{\\partial^2 u}{\\partial x^2}(x,t) + s(x,t),\n$$\n左端点具有随时间变化的狄利克雷边界条件，\n$$\nu(-1,t) = g(t),\n$$\n右端点具有狄利克雷边界条件，\n$$\nu(1,t) = 0.\n$$\n三角函数的角度必须以弧度为单位。谱配点框架在 $[-1,1]$ 上使用切比雪夫网格和谱微分矩阵来近似光滑函数的空间导数。\n\n你的任务是，从第一性原理出发，发展一种在谱配点框架内施加随时间变化的狄利克雷边界条件 $u(-1,t) = g(t)$ 的方法。其核心思想是消除边界自由度，并为内部配点值推导出一个降阶的常微分方程 (ODE)。这个降阶系统必须通过一个依赖于 $g(t)$ 的强迫项来考虑随时间变化的边界值。\n\n为了使问题具体且可测试，考虑一个构造的精确解\n$$\nu^\\ast(x,t) = \\cos(t)\\,\\frac{1-x}{2},\n$$\n它满足边界条件 $u^\\ast(-1,t) = \\cos(t)$ 和 $u^\\ast(1,t) = 0$。通过将 $u^\\ast$ 代入 PDE 来定义源项 $s(x,t)$，从而使 $u^\\ast$ 成为一个精确解：\n$$\ns(x,t) = \\frac{\\partial u^\\ast}{\\partial t}(x,t) - \\frac{\\partial^2 u^\\ast}{\\partial x^2}(x,t) = -\\sin(t)\\,\\frac{1-x}{2}.\n$$\n在具有 $N+1$ 个节点 $\\{x_j\\}_{j=0}^N$ 及相应的一阶和二阶谱微分矩阵的切比雪夫谱配点设置中进行计算。设 $u_I(t)$ 是对应于索引 $j=1,\\dots,N-1$ 的内部节点值的向量，并设 $u_b(t)$ 汇集了在 $x_0=-1$ 和 $x_N=1$ 处的边界值。通过划分完整的二阶导数算子，并严格表达随时间变化的边界值 $g(t)$ 如何作为强迫项进入方程，来推导 $u_I(t)$ 的降阶 ODE。然后，对于构造解 $u^\\ast$，在内部节点上计算残差\n$$\nR_I(t) = \\frac{\\partial u^\\ast_I}{\\partial t}(t) - \\left( A\\,u^\\ast_I(t) + b(t) \\right),\n$$\n其中 $A$ 是离散二阶导数算子的内-内部块，而 $b(t)$ 是汇集了边界值和源项 $s(x,t)$ 在内部节点上的贡献的强迫项。\n\n你的程序必须：\n- 从谱配点的核心定义（对通过节点的唯一插值多项式进行微分）出发，构建 $[-1,1]$ 上的切比雪夫网格及相应的一阶谱微分矩阵，并通过复合得到二阶微分矩阵。\n- 将离散算子划分为内部块和边界块。\n- 为内部节点实现降阶 ODE 的右侧项 $A\\,u_I(t) + b(t)$，其中 $b(t)$ 处理 $u(-1,t)=g(t)$ 的时间依赖性及源项 $s(x,t)$。\n- 使用上述构造解 $u^\\ast(x,t)$ 和 $s(x,t)$，为下面测试套件中的每组参数计算残差 $R_I(t)$ 的无穷范数。\n\n测试套件（每个测试用例是一对 $(N,t)$）：\n- 用例 1：$(N,t)=(2,\\,0.0)$，一个具有最少内部点且 $g'(t)=0$ 的边缘情况。\n- 用例 2：$(N,t)=(8,\\,1.0)$，一个中等规模的网格和非零的 $g'(t)$。\n- 用例 3：$(N,t)=(16,\\,1.234)$，一个更精细的网格和非平凡的时间值。\n- 用例 4：$(N,t)=(32,\\,2.0)$，一个更精细的网格和更大的时间值。\n\n对于每个用例，答案是内部节点上 $R_I(t)$ 的无穷范数，即一个浮点数。你的程序应生成单行输出，其中包含用逗号分隔并用方括号括起来的结果（例如，“[result1,result2,result3,result4]”）。",
            "solution": "目标是在谱配点方法中施加随时间变化的狄利克雷边界条件，并得出内部自由度的降阶演化方程。其基本原理是谱配点的定义：给定一组节点，我们用通过其节点值的唯一插值多项式来表示一个函数，并通过对该插值多项式进行精确微分来定义微分运算。\n\n$[-1,1]$ 上的切比雪夫谱配点使用 $N+1$ 个切比雪夫节点\n$$\nx_j = \\cos\\!\\left(\\frac{\\pi j}{N}\\right),\\quad j=0,1,\\dots,N.\n$$\n设 $p_N(x)$ 是节点值 $\\{u_j\\}_{j=0}^N$ 的唯一的 N 次插值多项式。一阶谱微分矩阵 $D$ 是这样一个算子，使得对所有 $j$ 都有 $(Du)_j = p_N'(x_j)$，而二阶微分矩阵是 $D^{(2)} = D\\,D$，从而 $(D^{(2)}u)_j = p_N''(x_j)$。\n\n为了在配点法中施加狄利克雷边界条件，我们将自由度划分为边界部分和内部分。设向量 $u$ 按顺序 $[u_0,u_1,\\dots,u_{N-1},u_N]^T$ 表示节点值，其中 $u_0=u(-1,t)$ 和 $u_N=u(1,t)$ 是边界值，而 $u_I$ 汇集了内部值 $[u_1,\\dots,u_{N-1}]^T$。将二阶导数矩阵按照此顺序划分为块：\n$$\nD^{(2)} = \\begin{pmatrix}\nD^{(2)}_{bb}  D^{(2)}_{bI} \\\\\nD^{(2)}_{Ib}  D^{(2)}_{II}\n\\end{pmatrix},\n$$\n其中下标 $b$ 指的是边界索引 $\\{0,N\\}$，下标 $I$ 指的是内部索引 $\\{1,\\dots,N-1\\}$。\n\nPDE 在内部节点处的配点半离散化形式为\n$$\n\\frac{d u_I}{dt} = \\left(D^{(2)}u\\right)_I + s_I(t) = D^{(2)}_{II} u_I + D^{(2)}_{Ib} u_b(t) + s_I(t),\n$$\n其中 $u_b(t) = \\begin{bmatrix}u_0(t) \\\\ u_N(t)\\end{bmatrix}$ 汇集了边界值。这就得到了内部节点的降阶常微分方程 (ODE)：\n$$\n\\frac{d u_I}{dt} = A u_I + b(t),\\quad A = D^{(2)}_{II},\\quad b(t) = D^{(2)}_{Ib}\\,u_b(t) + s_I(t).\n$$\n这种降阶方法通过将边界值视为已知的随时间变化的函数，并将其影响移至内部的强迫项中，从而显式地施加了狄利克雷边界条件。\n\n为了验证正确性并产生可量化的输出，我们使用一个构造的精确解：\n$$\nu^\\ast(x,t) = \\cos(t)\\,\\frac{1-x}{2}.\n$$\n该解满足边界条件 $u^\\ast(-1,t)=\\cos(t)$ 和 $u^\\ast(1,t)=0$，即左边界为 $g(t)=\\cos(t)$，右边界为零。其时间和空间导数为\n$$\n\\frac{\\partial u^\\ast}{\\partial t}(x,t) = -\\sin(t)\\,\\frac{1-x}{2},\\qquad\n\\frac{\\partial^2 u^\\ast}{\\partial x^2}(x,t) = 0,\n$$\n因为 $u^\\ast$ 对 $x$ 是线性的。因此，源项为\n$$\ns(x,t) = \\frac{\\partial u^\\ast}{\\partial t}(x,t) - \\frac{\\partial^2 u^\\ast}{\\partial x^2}(x,t) = -\\sin(t)\\,\\frac{1-x}{2}.\n$$\n在离散层面，当我们将二阶谱微分矩阵 $D^{(2)}$ 应用于多项式的节点值时，配点微分法可以精确地再现其直到 N 次的导数，因此对于线性函数，离散二阶导数在所有节点上均为零：\n$$\nD^{(2)} u^\\ast(\\cdot,t) \\equiv 0.\n$$\n因此，对于内部节点上的构造解\n$$\n\\frac{d u^\\ast_I}{dt}(t) = A\\,u^\\ast_I(t) + b(t) \\quad \\text{with} \\quad A\\,u^\\ast_I(t) + b(t) = D^{(2)}_{II} u^\\ast_I(t) + D^{(2)}_{Ib} u^\\ast_b(t) + s_I(t) = 0 + 0 + s_I(t).\n$$\n但是 $\\frac{d u^\\ast_I}{dt}(t) = -\\sin(t)\\,\\frac{1-x_I}{2} = s_I(t)$，所以残差\n$$\nR_I(t) = \\frac{d u^\\ast_I}{dt}(t) - \\left(A\\,u^\\ast_I(t) + b(t)\\right)\n$$\n在舍入误差范围内是零向量。$R_I(t)$ 的无穷范数应该处于浮点舍入误差的水平。\n\n算法步骤：\n- 选择 $N$，为 $j=0,\\dots,N$ 形成切比雪夫节点 $x_j$。\n- 使用基于类重心权重和节点差分的标准切比雪夫配点构造方法，构建一阶谱微分矩阵 $D$；然后设置 $D^{(2)}=D\\,D$。\n- 提取内部索引 $j=1,\\dots,N-1$；通过切片形成 $A=D^{(2)}_{II}$ 和 $D^{(2)}_{Ib}$。\n- 如上定义 $u^\\ast(x,t)$ 和 $s(x,t)$；在节点上组装 $u^\\ast_I(t)$、$u^\\ast_b(t)$ 和 $s_I(t)$。\n- 计算 $R_I(t)=\\frac{d u^\\ast_I}{dt}(t) - \\left(A\\,u^\\ast_I(t) + D^{(2)}_{Ib}\\,u^\\ast_b(t) + s_I(t)\\right)$。\n- 报告每个测试用例的 $\\|R_I(t)\\|_\\infty$。\n\n测试用例使用 $(N,t)=(2,\\,0.0)$、$(8,\\,1.0)$、$(16,\\,1.234)$ 和 $(32,\\,2.0)$，角度以弧度为单位。输出是包含四个残差范数的单行逗号分隔列表，并用方括号括起来。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef chebyshev_diff_matrix(N):\n    \"\"\"\n    Construct the Chebyshev first differentiation matrix D and nodes x on [-1,1]\n    using the standard spectral collocation formula.\n    \"\"\"\n    # Chebyshev nodes\n    j = np.arange(N + 1)\n    x = np.cos(np.pi * j / N)\n\n    # Weights c_j: 2 for endpoints, 1 otherwise\n    c = np.ones(N + 1)\n    c[0] = 2.0\n    c[-1] = 2.0\n\n    # Build D matrix\n    X = np.tile(x, (N + 1, 1))\n    dX = X - X.T\n\n    D = np.zeros((N + 1, N + 1))\n    # Off-diagonal entries\n    for m in range(N + 1):\n        for n in range(N + 1):\n            if m != n:\n                D[m, n] = (c[m] / c[n]) * ((-1.0) ** (m + n)) / (x[m] - x[n])\n\n    # Diagonal entries\n    D[0, 0] = (2.0 * N * N + 1.0) / 6.0\n    D[N, N] = -D[0, 0]\n    for k in range(1, N):\n        D[k, k] = -x[k] / (2.0 * (1.0 - x[k] ** 2))\n\n    return x, D\n\ndef manufactured_u(x, t):\n    # u*(x,t) = cos(t) * (1 - x)/2\n    return np.cos(t) * (1.0 - x) / 2.0\n\ndef du_dt_exact(x, t):\n    # du*/dt = -sin(t) * (1 - x)/2\n    return -np.sin(t) * (1.0 - x) / 2.0\n\ndef source_s(x, t):\n    # s(x,t) = du*/dt - u_xx; u_xx = 0 for the linear u*\n    return -np.sin(t) * (1.0 - x) / 2.0\n\ndef residual_infinity_norm(N, t):\n    # Build spectral differentiation matrices\n    x, D = chebyshev_diff_matrix(N)\n    D2 = D @ D\n\n    # Indices\n    interior = np.arange(1, N)  # 1..N-1\n    b_indices = [0, N]\n\n    # Manufactured solution and source at nodes\n    u_star = manufactured_u(x, t)\n    du_dt = du_dt_exact(x, t)\n    s_vals = source_s(x, t)\n\n    # Partition for interior system\n    A = D2[np.ix_(interior, interior)]\n    D2_Ib = D2[np.ix_(interior, b_indices)]\n\n    u_I = u_star[interior]\n    u_b = u_star[b_indices]\n    s_I = s_vals[interior]\n    du_I_dt = du_dt[interior]\n\n    # Reduced RHS: A u_I + D2_Ib u_b + s_I\n    rhs = A @ u_I + D2_Ib @ u_b + s_I\n\n    # Residual at interior: du/dt - rhs\n    R_I = du_I_dt - rhs\n    # Infinity norm\n    return float(np.max(np.abs(R_I))) if R_I.size > 0 else 0.0\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (2, 0.0),\n        (8, 1.0),\n        (16, 1.234),\n        (32, 2.0),\n    ]\n\n    results = []\n    for N, t in test_cases:\n        result = residual_infinity_norm(N, t)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在求解包含非线性项（如流体力学中的 $(u^2)_x$）的方程时，谱方法会面临一种独特的挑战，即“混叠误差”。本练习将揭示在离散网格上计算非线性乘积时，高频分量如何“伪装”成低频分量，从而污染计算结果 。您将亲手实现并对比一个朴素方法和一个采用“2/3法则”的反混叠方法，直观地理解为何以及如何处理这种关键的数值现象。",
            "id": "3277414",
            "problem": "考虑周期性域 $[0,2\\pi)$，其上有 $N$ 个等距配置点 $x_j = \\frac{2\\pi j}{N}$，其中 $j=0,1,\\dots,N-1$。您将构建一个傅里叶谱微分矩阵来近似空间导数，并研究在计算无粘性伯格斯方程 $u_t + (u^2)_x = 0$ 中出现的非线性通量导数 $(u^2)_x$ 时的混叠与去混叠问题。所有角度必须以弧度为单位解释。\n\n仅从基本原理出发，利用指数函数 $e^{i k x}$ 是微分算子的特征函数（即 $\\frac{d}{dx} e^{i k x} = i k e^{i k x}$，其中 $k$ 为整数），以及离散傅里叶变换通过其离散傅里叶系数来表示网格上的函数这两个事实。基于这些原则：\n\n- 推导傅里叶配置法中，一阶微分算子在网格 $\\{x_j\\}$ 上的矩阵表示 $D \\in \\mathbb{C}^{N \\times N}$。推导必须从离散傅里叶变换及其逆变换如何将节点值映射到离散傅里叶系数并返回开始，并利用 $e^{i k x}$ 的特征函数性质，不得假定任何预先给定的微分矩阵公式。得到的矩阵 $D$ 对于任何网格函数 $f \\in \\mathbb{C}^N$ 都应满足向量 $Df$ 在网格点处近似于 $\\frac{d f}{dx}$。\n- 解释为什么在物理空间中计算非线性乘积（例如，逐点计算 $u^2$）然后变换到傅里叶空间会引入混叠误差。使用离散卷积的解释来论证在具有 $N$ 个点的网格上，未分辨的高频模式如何折叠到低频模式中。\n- 实现 $(u^2)_x$ 的两种伪谱近似：\n  1. 一种朴素伪谱法：逐点计算 $f = u^2$，然后通过将谱微分矩阵 $D$ 应用于 $f$ 来近似 $(u^2)_x$，即 $(u^2)_x \\approx D f$。\n  2. 一种使用2/3法则的去混叠方法：在物理空间中形成 $f = u^2$ 后，将 $f$ 变换到傅里叶空间以获得 $\\hat{f}_k$，将所有满足 $|k| > \\lfloor N/3 \\rfloor$ 的模式置零，在傅里叶空间中乘以 $i k$，然后变换回物理空间，以获得 $(u^2)_x$ 的去混叠近似。\n\n对于下面的每个测试用例，根据给定的 $u(x)$ 和 $u_x(x)$ 计算逐点精确导数 $(u^2)_x = 2 u u_x$，然后计算以下两种误差：\n- 朴素伪谱最大范数误差 $E_{\\text{naive}} = \\max_{0 \\le j \\le N-1} \\left| (D f)_j - 2 u(x_j) u_x(x_j) \\right|$。\n- 2/3法则去混叠最大范数误差 $E_{2/3} = \\max_{0 \\le j \\le N-1} \\left| \\left[\\mathcal{F}^{-1}\\left( i k \\cdot \\chi_{|k| \\le \\lfloor N/3 \\rfloor} \\cdot \\hat{f}_k \\right)\\right]_j - 2 u(x_j) u_x(x_j) \\right|$，其中 $\\chi$ 是指示函数，$\\mathcal{F}^{-1}$ 是离散傅里叶逆变换。\n\n测试套件（所有角度以弧度为单位）：\n- 用例 A（分辨率良好的光滑输入）：$N = 32$， $u(x) = \\sin(x) + 0.5 \\sin(2x)$，因此 $u_x(x) = \\cos(x) + \\cos(2x)$ 且 $(u^2)_x = 2 u u_x$。\n- 用例 B（欠采样以暴露混叠）：$N = 15$， $u(x) = \\sin(5x) + 0.4 \\cos(7x)$，因此 $u_x(x) = 5 \\cos(5x) - 2.8 \\sin(7x)$ 且 $(u^2)_x = 2 u u_x$。\n- 用例 C（临界2/3法则内容）：$N = 12$， $u(x) = \\sin(4x)$，因此 $u_x(x) = 4 \\cos(4x)$ 且 $(u^2)_x = 2 u u_x$。\n\n您的程序必须：\n- 根据您的推导，从第一性原理构建傅里叶谱微分矩阵 $D$（您可以使用快速傅里叶变换例程来组装 $D$ 或应用它）。\n- 对于每个用例，计算上述定义的 $E_{\\text{naive}}$ 和 $E_{2/3}$。\n- 生成一行输出，其中包含按顺序 $[E_{\\text{naive}}^{\\text{A}}, E_{2/3}^{\\text{A}}, E_{\\text{naive}}^{\\text{B}}, E_{2/3}^{\\text{B}}, E_{\\text{naive}}^{\\text{C}}, E_{2/3}^{\\text{C}}]$ 排列的六个结果，形式为方括号内由逗号分隔的列表。值必须是十进制浮点数。\n\n不需要用户输入。所有计算都是无量纲和无单位的，所有关于 $x$ 的函数都使用弧度。",
            "solution": "该问题陈述科学合理、内容自洽且定义明确。它提出了数值分析中的一个标准任务：研究非线性项的谱微分和混叠误差。所有参数、函数和误差度量都得到了清晰客观的定义。因此，提供一个完整的解决方案是合理的。\n\n该解决方案分为三个部分：首先，从基本原理推导傅里叶谱微分矩阵；其次，解释非线性项中的混叠现象；第三，分析待实现的两种伪谱方法。\n\n### 1. 傅里叶谱微分矩阵的推导\n\n在周期性域 $[0, 2\\pi)$ 上定义的函数 $f(x)$，可以在由 $N$ 个等距点 $x_j = \\frac{2\\pi j}{N}$（其中 $j=0, 1, \\dots, N-1$）组成的网格上，通过其节点值的向量 $\\mathbf{f} = [f(x_0), f(x_1), \\dots, f(x_{N-1})]^T$ 来表示。傅里叶谱方法的核心原理是使用截断的傅里叶级数作为函数的全局插值。\n\n离散傅里叶变换（DFT）将物理空间值的向量 $\\mathbf{f}$ 映射到复傅里叶系数的向量 $\\hat{\\mathbf{f}}$。前向DFT的常规定义为：\n$$\n\\hat{f}_k = \\sum_{j=0}^{N-1} f_j e^{-i k x_j} = \\sum_{j=0}^{N-1} f_j e^{-i 2\\pi k j / N}\n$$\n其中 $f_j = f(x_j)$，整数 $k$ 代表波数指数。离散傅里叶逆变换（IDFT）将系数变换回物理空间值：\n$$\nf_j = \\frac{1}{N} \\sum_{k=0}^{N-1} \\hat{f}_k e^{i k x_j} = \\frac{1}{N} \\sum_{k=0}^{N-1} \\hat{f}_k e^{i 2\\pi k j / N}\n$$\n问题指出，复指数函数 $e^{ikx}$ 是微分算子的特征函数，即 $\\frac{d}{dx} e^{ikx} = ik e^{ikx}$。这个性质使得微分可以在傅里叶空间中通过简单的乘法来执行。$f(x)$ 的谱微分通过一个三步过程实现：\n1.  使用DFT将网格函数 $\\mathbf{f}$ 变换为其傅里叶系数 $\\hat{\\mathbf{f}}$。\n2.  将每个傅里叶系数 $\\hat{f}_k$ 乘以其对应的微分特征值 $ik'$，其中 $k'$ 是真实的角波数。\n3.  使用IDFT将得到的系数变换回物理空间。\n\n我们将微分后的傅里叶系数向量记为 $\\hat{\\mathbf{g}}$。那么，$\\hat{g}_k = ik' \\hat{f}_k$。在物理空间中得到的导数向量 $\\mathbf{g}$ 为 $\\mathbf{g} = \\mathcal{F}^{-1}(\\hat{\\mathbf{g}})$。\n\n必须建立从DFT索引 $k \\in \\{0, 1, \\dots, N-1\\}$ 到真实角波数 $k'$ 的映射。对于一个有 $N$ 个点的网格，可表示的波数是带限的。标准的波数集合对于 $N$ 为偶数时是 $k' \\in \\{0, \\pm 1, \\dots, \\pm (N/2-1), -N/2\\}$，对于 $N$ 为奇数时是 $k' \\in \\{0, \\pm 1, \\dots, \\pm (N-1)/2\\}$。这对应于 `numpy.fft.fftfreq` 提供的顺序。\n\n当 $N$ 为偶数时，会出现一个特殊情况。对应于 $k'=N/2$（或 $-N/2$）的奈奎斯特频率代表了最高频率模式 $e^{i (N/2) x_j} = e^{i\\pi j} = (-1)^j$。将此模式微分为 $i(N/2)e^{i(N/2)x_j}$ 将从一个实函数产生一个复数结果，这破坏了微分算子的实数到实数的性质。为了保持这一性质，奈奎斯特模式的导数通常被设置为零。\n\n我们可以将整个过程表示为单个矩阵-向量乘积 $\\mathbf{g} = D\\mathbf{f}$，其中 $D$ 是 $N \\times N$ 的谱微分矩阵。设 $\\mathcal{F}$ 和 $\\mathcal{F}^{-1}$ 是表示DFT和IDFT运算的矩阵，$\\Lambda$ 是特征值 $ik'$ 构成的对角矩阵。那么微分矩阵就是 $D = \\mathcal{F}^{-1} \\Lambda \\mathcal{F}$。\n\n矩阵 $D$ 的元素 $D_{jl}$ 可以被明确推导出来：\n$$\n(D\\mathbf{f})_j = \\frac{1}{N} \\sum_{k} (ik') \\left( \\sum_{l=0}^{N-1} f_l e^{-ik'x_l} \\right) e^{ik'x_j} = \\sum_{l=0}^{N-1} \\left( \\frac{1}{N} \\sum_{k} ik' e^{ik'(x_j - x_l)} \\right) f_l\n$$\n括号中的项是矩阵元素 $D_{jl}$，其中求和是对适当的波数集合 $k'$进行的。这表明 $D$ 是一个循环矩阵，因为其元素仅依赖于差值 $j-l$。虽然这个公式定义了 $D$，但在实践中，算子是通过高效的基于FFT的三步过程来应用的，而不是构建稠密矩阵 $D$。\n\n### 2. 非线性乘积产生的混叠误差\n\n当计算像 $u^2$ 这样的非线性项时，会产生新的频率。考虑一个带限函数 $u(x)$，意味着其傅里叶级数表示 $u(x) = \\sum_{k=-K}^{K} \\hat{u}_k e^{ikx}$ 包含有限数量的模式。那么乘积 $u^2(x)$ 就是：\n$$\nu^2(x) = \\left(\\sum_{p=-K}^{K} \\hat{u}_p e^{ipx}\\right) \\left(\\sum_{q=-K}^{K} \\hat{u}_q e^{iqx}\\right) = \\sum_{p=-K}^{K} \\sum_{q=-K}^{K} \\hat{u}_p \\hat{u}_q e^{i(p+q)x}\n$$\n得到的函数 $u^2(x)$ 具有波数高达 $p+q = \\pm 2K$ 的模式。\n\n在一个有 $N$ 个点的离散网格上，只有波数达到奈奎斯特频率（大约 $N/2$）才能被唯一表示。任何频率 $|k'| > N/2$ 都会被“混叠”，并且在网格上变得与一个较低的频率无法区分。这是因为对于任何整数 $m$：\n$$\ne^{i(k' + mN)x_j} = e^{i(k' + mN) \\frac{2\\pi j}{N}} = e^{ik' \\frac{2\\pi j}{N}} e^{i m N \\frac{2\\pi j}{N}} = e^{ik'x_j} e^{i 2\\pi mj} = e^{ik'x_j}\n$$\n因此，模式 $k'+mN$ 在网格上看起来与模式 $k'$ 完全相同。\n\n当我们在物理空间中逐点计算 $f_j = u(x_j)^2$ 时，我们隐式地创建了这些高频（高达 $2K$）。如果 $2K > N/2$，这些高频就会混叠到较低的频率上，从而污染了本应代表 $u^2(x)$ 真实低频内容的傅里叶系数。这种污染就是混叠误差。朴素伪谱法，即逐点计算 $u^2$ 然后进行微分，容易受到这种误差的影响。\n\n### 3. 伪谱近似与去混叠\n\n问题指定了两种方法来近似 $(u^2)_x$。\n\n**1. 朴素伪谱法：**\n该方法直接实现物理空间中的乘法。\n- 计算向量 $\\mathbf{f}$，其中 $f_j = u(x_j)^2$。如果 $u(x)$ 相对于网格大小 $N$ 不是充分带限的，这一步会引入混叠误差。\n- 将谱微分算子 $D$ 应用于 $\\mathbf{f}$。计算上，这表示为 $(u^2)_x \\approx \\mathcal{F}^{-1}(ik' \\cdot \\mathcal{F}(\\mathbf{f}))$。\n得到的近似值既包含了真实信号的导数，也包含了混叠误差的导数。\n\n**2. 2/3法则去混叠方法：**\n该方法试图减轻混叠。这个名字来源于完全防止混叠的条件：如果初始信号 $u(x)$ 的带限为 $|k| \\le N/3$，那么乘积 $u^2(x)$ 的模式将高达 $|k| \\le 2N/3$。因为对于 $N \\ge 0$ 有 $2N/3 \\le N$，更重要的是避免了最高频率的混叠相互作用，傅里叶空间中的卷积可以计算而没有环绕误差。\n\n问题中指定的程序是基于这一原理的低通滤波方法：\n- 如同朴素方法一样，计算 $\\mathbf{f}$，其中 $f_j = u(x_j)^2$。得到的网格函数是混叠的。\n- 变换到傅里叶空间得到混叠的系数 $\\hat{\\mathbf{f}}$。\n- 假设真实的、未混叠的信号主要包含在波数的低三分之一部分。将所有满足 $|k'| > \\lfloor N/3 \\rfloor$ 的傅里叶系数 $\\hat{f}_k$ 置零。这定义了一个新的滤波后系数集 $\\hat{\\mathbf{f}}_{\\text{filt}}$。\n- 通过计算 $ik' \\hat{\\mathbf{f}}_{\\text{filt}}$ 在傅里叶空间中进行微分。\n- 通过IDFT变换回物理空间。\n\n这种滤波移除了高频内容，这些内容被假定主要由混叠误差构成。然而，它无法纠正已经污染了被滤波器保留的低频模式的混叠误差。当真实信号在谱上与混叠分量有很好的分离时，这种方法最有效。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the spectral differentiation problem for three test cases, computing\n    the maximum-norm error for a naive pseudospectral method and a de-aliased\n    method using the 2/3-rule.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"id\": \"A\",\n            \"N\": 32,\n            \"u_func\": lambda x: np.sin(x) + 0.5 * np.sin(2 * x),\n            \"ux_func\": lambda x: np.cos(x) + np.cos(2 * x),\n        },\n        {\n            \"id\": \"B\",\n            \"N\": 15,\n            \"u_func\": lambda x: np.sin(5 * x) + 0.4 * np.cos(7 * x),\n            \"ux_func\": lambda x: 5 * np.cos(5 * x) - 2.8 * np.sin(7 * x),\n        },\n        {\n            \"id\": \"C\",\n            \"N\": 12,\n            \"u_func\": lambda x: np.sin(4 * x),\n            \"ux_func\": lambda x: 4 * np.cos(4 * x),\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        N = case[\"N\"]\n        u_func = case[\"u_func\"]\n        ux_func = case[\"ux_func\"]\n\n        # 1. Set up the grid and evaluate the exact functions\n        x_grid = 2 * np.pi * np.arange(N) / N\n        u_vec = u_func(x_grid)\n        ux_vec = ux_func(x_grid)\n\n        # The exact derivative of the nonlinear flux: (u^2)_x = 2*u*u_x\n        d_u2_exact = 2 * u_vec * ux_vec\n\n        # The nonlinear flux evaluated on the grid\n        f_vec = u_vec**2\n        \n        # 2. Naive Pseudospectral Method\n        \n        # Wavenumbers for differentiation. For real-valued functions, the\n        # derivative of the Nyquist mode (for N even) is set to 0.\n        k_wave = N * np.fft.fftfreq(N)\n        if N % 2 == 0:\n            k_wave[N // 2] = 0.0\n\n        # Differentiate in Fourier space and transform back\n        f_hat = np.fft.fft(f_vec)\n        d_u2_naive = np.real(np.fft.ifft(1j * k_wave * f_hat))\n\n        # Compute max-norm error\n        E_naive = np.max(np.abs(d_u2_naive - d_u2_exact))\n        results.append(E_naive)\n\n        # 3. 2/3-Rule De-aliased Method\n        \n        # Wavenumbers for filtering and differentiation\n        k_wave_dealias = N * np.fft.fftfreq(N)\n        \n        # Apply the 2/3-rule filter mask in Fourier space\n        K_cut = np.floor(N / 3)\n        mask = np.abs(k_wave_dealias) = K_cut\n        \n        f_hat_filtered = f_hat * mask\n\n        # Differentiate the filtered coefficients and transform back.\n        # No special Nyquist handling is needed for k_wave_dealias here because\n        # for N>3, floor(N/3)  N/2, so the filter mask already sets the\n        # Nyquist mode coefficient to zero.\n        d_u2_dealias = np.real(np.fft.ifft(1j * k_wave_dealias * f_hat_filtered))\n\n        # Compute max-norm error\n        E_2_3 = np.max(np.abs(d_u2_dealias - d_u2_exact))\n        results.append(E_2_3)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.15f}' for r in results)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "对于复杂几何形状或需要在不同区域使用不同分辨率的问题，单一的全局谱方法可能效率不高。本练习将引导您进入谱元法的世界，通过在多个子区间（“单元”）上构建局部的谱微分矩阵，然后将它们“组装”成一个作用于复合网格的全局微分算子 。这种方法极大地增强了谱方法的灵活性，使其能够高效地处理更广泛的科学与工程问题。",
            "id": "3277369",
            "problem": "要求您构建并应用一个全局谱微分算子，该算子作用于由不同分辨率的子区间联合形成的复合网格（一种基础的谱元法），并在几个测试案例上评估其精度。此构建必须基于在 Chebyshev–Gauss–Lobatto (CGL) 节点上的多项式插值。\n\n使用的基本原理如下：\n- 拉格朗日基中的多项式插值：一个在离散节点上采样的函数 $f$ 可由一个唯一的、次数最多为 $N$ 的、穿过这些采样点的多项式精确表示，而 $f$ 在这些节点处的导数则通过对该插值多项式求导来近似。\n- 参考区间上的 Chebyshev–Gauss–Lobatto (CGL) 节点定义为 $s_k = \\cos\\left(\\frac{\\pi k}{N}\\right)$，其中 $k = 0, 1, \\dots, N$。由于其良好的逼近性质和条件数，这些节点被广泛使用。\n- 将每个单元从参考区间 $[-1,1]$ 到物理单元 $[a,b]$ 的仿射映射由 $x = \\phi(s) = \\frac{a+b}{2} + \\frac{b-a}{2}s$ 给出，根据链式法则，在每个单元上可得 $\\frac{\\mathrm{d}}{\\mathrm{d}x} = \\frac{2}{b-a} \\frac{\\mathrm{d}}{\\mathrm{d}s}$。\n\n任务：\n1. 对于每个物理端点为 $[a_e, b_e]$、次数为 $N_e$ 的单元 $e$，在参考空间中的 CGL 节点上构建局部谱微分矩阵，并使用链式法则将其映射到物理空间。局部矩阵应作用于该单元上的节点值 $f(x)$，并生成这些单元节点上 $f'(x)$ 的近似值。\n2. 通过将单元节点集合并成一个单一、有序、唯一的全局节点集来构建全局复合网格。如果两个单元共享一个物理界面节点，则将其视为单个全局节点。\n3. 通过将每个局部微分矩阵应用于其单元上的函数样本，然后在全局节点上聚合得到的导数贡献，来组装全局微分算子。在属于两个相邻单元的共享界面节点上，使用两个单侧导数近似值的平均值来定义该节点的全局导数。仅属于一个单元的端点使用单个单元的贡献。\n4. 将您的全局算子应用于以下测试套件。对于每个测试案例，计算全局导数近似值与在全局节点上计算的精确导数之间的最大绝对误差。所有三角函数中的角度均以弧度为单位。\n\n测试套件定义：\n- 在所有案例中，定义域均为 $[0,1]$。每个案例都定义了两个单元的分割点 $x_\\mathrm{split}$、次数 $(N_1, N_2)$，以及一个函数 $f(x)$ 及其精确导数 $f'(x)$。\n- 案例1（一般光滑函数，非对称分辨率）：\n    - $x_\\mathrm{split} = 0.4$，$N_1 = 12$，$N_2 = 26$。\n    - $f(x) = \\sin(2\\pi x)$，$f'(x) = 2\\pi \\cos(2\\pi x)$。\n- 案例2（低次多项式，中等分辨率）：\n    - $x_\\mathrm{split} = 0.5$，$N_1 = 4$，$N_2 = 6$。\n    - $f(x) = x^3$，$f'(x) = 3x^2$。\n- 案例3（指数函数，边界偏斜分辨率且一个单元次数最小）：\n    - $x_\\mathrm{split} = 0.25$，$N_1 = 2$，$N_2 = 10$。\n    - $f(x) = e^x$，$f'(x) = e^x$。\n- 案例4（高频三角函数，强非均衡分辨率）：\n    - $x_\\mathrm{split} = 0.7$，$N_1 = 30$，$N_2 = 8$。\n    - $f(x) = \\sin(10\\pi x)$，$f'(x) = 10\\pi \\cos(10\\pi x)$。\n\n您的程序应：\n- 根据拉格朗日多项式插值的第一性原理和通过链式法则的仿射映射，在每个单元的 CGL 节点上实现局部谱微分矩阵。不要使用预计算或硬编码的微分矩阵。\n- 构建复合网格，并通过在共享界面节点处取平均值来组装全局导数近似。\n- 对于每个测试案例，计算在全局节点上近似导数与精确导数之间的最大绝对误差。\n- 生成单行输出，其中包含四个最大误差，格式为方括号括起来的逗号分隔列表，并四舍五入到八位小数（例如，“[0.00012345,0.0,0.1,2.5]”）。\n\n所有量都是没有物理单位的纯数，三角函数中的角度必须以弧度为单位。最终输出必须严格匹配所描述的单行格式。",
            "solution": "该问题要求在复合网格上构建并应用谱元微分算子。该方法基于在 Chebyshev-Gauss-Lobatto (CGL) 节点上的多项式插值。该过程被验证为科学上合理且适定的，下面提供了详细的解决方案。\n\n解决方案分为四个主要步骤：\n1.  在参考单元上构建微分矩阵。\n2.  将参考单元算子映射到物理单元。\n3.  将局部算子组装成全局导数近似。\n4.  在一系列测试案例上评估全局算子的精度。\n\n### 步骤1：参考区间上的局部微分矩阵\n谱微分法通过首先构建一个穿过一组 $N+1$ 个离散节点的多项式插值函数 $p(s)$，然后对该多项式进行微分来近似函数 $f(s)$ 在参考区间 $s \\in [-1, 1]$ 上的导数，即 $f'(s) \\approx p'(s)$。\n\n对于此问题，我们使用 Chebyshev-Gauss-Lobatto (CGL) 节点，定义如下：\n$$\ns_k = \\cos\\left(\\frac{k\\pi}{N}\\right), \\quad k = 0, 1, \\dots, N\n$$\n这 $N+1$ 个节点的范围从 $s_0=1$ 递减到 $s_N=-1$。次数最多为 $N$ 的多项式插值函数 $p(s)$ 可以使用拉格朗日基多项式 $L_k(s)$ 写成：\n$$\np(s) = \\sum_{k=0}^{N} f(s_k) L_k(s), \\quad \\text{其中 } L_k(s_j) = \\delta_{kj}\n$$\n插值函数的导数则为：\n$$\np'(s) = \\sum_{k=0}^{N} f(s_k) L'_k(s)\n$$\n在 CGL 节点 $s_j$ 处计算导数，得到一个线性系统：\n$$\np'(s_j) = \\sum_{k=0}^{N} L'_k(s_j) f(s_k)\n$$\n这可以表示为矩阵形式 $\\mathbf{f'} = D_N \\mathbf{f}$，其中 $\\mathbf{f}$ 是函数值向量 $[f(s_0), \\dots, f(s_N)]^T$，$\\mathbf{f'}$ 是近似导数值向量 $[p'(s_0), \\dots, p'(s_N)]^T$，而 $D_N$ 是 $(N+1) \\times (N+1)$ 的谱微分矩阵。该矩阵的元素为 $(D_N)_{jk} = L'_k(s_j)$。\n\n尽管这些元素可以从拉格朗日多项式的定义中推导出来，但实现中使用了 CGL 微分矩阵的标准、成熟公式。它们是：\n对于 $j \\neq k$：\n$$\n(D_N)_{jk} = \\frac{c_j}{c_k} \\frac{(-1)^{j+k}}{s_j - s_k}\n$$\n其中，当 $j=0$ 或 $j=N$ 时 $c_j = 2$，当 $1 \\le j \\le N-1$ 时 $c_j=1$。\n\n对于对角线元素，$j=k$：\n$$\n(D_N)_{jj} = \\begin{cases}\n\\frac{2N^2+1}{6}  \\text{对于 } j=0 \\\\\n-\\frac{s_j}{2(1-s_j^2)}  \\text{对于 } 1 \\le j \\le N-1 \\\\\n-\\frac{2N^2+1}{6}  \\text{对于 } j=N\n\\end{cases}\n$$\n将实现一个函数，用于为任意给定的多项式次数 $N$ 构建此矩阵 $D_N$。\n\n### 步骤2：映射到物理单元\n问题域 $[0, 1]$ 被划分为两个单元（子区间）。一个单元 $e$ 由其物理边界 $[a_e, b_e]$ 定义。来自参考区间 $[-1, 1]$ 的 CGL 节点通过仿射变换映射到每个单元内的物理节点 $x_k^{(e)}$：\n$$\nx^{(e)}(s) = \\frac{a_e+b_e}{2} + \\frac{b_e-a_e}{2}s\n$$\n函数 $g(x)$ 在物理坐标系中的导数通过链式法则与参考坐标系中的导数相关联：\n$$\n\\frac{\\mathrm{d}g}{\\mathrm{d}x} = \\frac{\\mathrm{d}g}{\\mathrm{d}s} \\frac{\\mathrm{d}s}{\\mathrm{d}x}\n$$\n变换的雅可比是 $\\frac{\\mathrm{d}x}{\\mathrm{d}s} = \\frac{b_e-a_e}{2}$，因此其逆为 $\\frac{\\mathrm{d}s}{\\mathrm{d}x} = \\frac{2}{b_e-a_e}$。\n因此，物理单元 $e$ 的微分矩阵 $D^{(e)}$ 是参考矩阵 $D_{N_e}$ 的一个缩放版本：\n$$\nD^{(e)} = \\frac{2}{b_e-a_e} D_{N_e}\n$$\n其中 $N_e$ 是单元 $e$ 的多项式次数。\n\n### 步骤3：全局导数的组装\n全局网格由所有单元的所有物理节点的并集构成。对于在 $x=x_{\\text{split}}$ 处对 $[0, 1]$ 的双单元划分，这两个单元是 $[0, x_{\\text{split}}]$ 和 $[x_{\\text{split}}, 1]$。全局节点集 $X$ 由两个单元中所有唯一的节点组成。位于 $x=x_{\\text{split}}$ 的节点是一个共享界面节点。\n\n全局导数向量 $U'$ 的组装过程如下：\n1.  对于每个单元 $e$，通过将其局部微分矩阵 $D^{(e)}$ 应用于在其物理节点上采样的函数值向量 $u^{(e)}$ 来计算局部导数向量 $u'^{(e)}$：$u'^{(e)} = D^{(e)} u^{(e)}$。\n2.  初始化一个全局导数向量 $U'$ 和一个计数器向量，两者的大小均与全局网格 $X$ 相同，并用零填充。\n3.  对于每个单元 $e$，将其计算出的局部导数贡献 $u'^{(e)}$ 添加到全局向量 $U'$ 的相应条目中。为每个对应的全局节点增加计数器的值。\n4.  处理完所有单元后，通过将求和后的导数 $U'$ 与计数器向量进行逐元素相除，得到最终的全局导数。\n此过程正确地实现了所需的逻辑：对于单元内部的节点，计数器为 $1$，因此导数就是局部贡献。对于共享界面节点，计数器为 $2$，导数则成为来自相邻单元的两个单侧导数近似值的平均值。\n\n### 步骤4：测试案例的误差评估\n对于提供的每个测试案例：\n- 定义域为 $[0, 1]$，在点 $x_{\\text{split}}$ 处分割。\n- 单元1跨越 $[0, x_{\\text{split}}]$，次数为 $N_1$；单元2跨越 $[x_{\\text{split}}, 1]$，次数为 $N_2$。\n- 执行步骤1-3中描述的过程，以计算全局网格 $X$ 上的近似导数向量 $U'$。\n- 在全局节点上计算精确导数 $f'(x)$，得到精确导数向量 $U'_{\\text{exact}}$。\n- 然后将最大绝对误差计算为差值的 $L_{\\infty}$-范数：\n$$\n\\text{Error} = \\max_j | U'_j - (U'_{\\text{exact}})_j |\n$$\n收集并报告所有四个案例的结果。对于案例2，其中使用次数为4和6的多项式对一个3次多项式进行微分，插值和微分都是精确的，因此误差预计接近机器精度（$0$）。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef chebyshev_diff_matrix(N):\n    \"\"\"\n    Constructs the (N+1)x(N+1) Chebyshev differentiation matrix for CGL nodes.\n    \n    Args:\n        N (int): The degree of the polynomial.\n\n    Returns:\n        numpy.ndarray: The differentiation matrix.\n    \"\"\"\n    if N == 0:\n        return np.array([[0.0]])\n    \n    # CGL nodes: s_j = cos(j*pi/N)\n    j = np.arange(N + 1)\n    s = np.cos(j * np.pi / N)\n\n    # Vectorized construction for off-diagonal entries\n    c = np.ones(N + 1)\n    c[0] = 2.0\n    c[-1] = 2.0\n    \n    c_ratio = c[:, np.newaxis] / c[np.newaxis, :]\n    \n    s_diff = s[:, np.newaxis] - s[np.newaxis, :]\n    # Avoid division by zero on the diagonal; will be overwritten later\n    # The value 1.0 is arbitrary and safe.\n    np.fill_diagonal(s_diff, 1.0) \n\n    # Meshgrid to compute (-1)^(j+k) without loops\n    J, K = np.meshgrid(j, j, indexing='ij')\n    sign = (-1)**(J + K)\n    \n    D = c_ratio * sign / s_diff\n    \n    # Correct the diagonal entries\n    diag = np.zeros(N + 1)\n    diag[0] = (2 * N**2 + 1) / 6.0\n    diag[N] = -(2 * N**2 + 1) / 6.0\n    # For 1 = j = N-1\n    diag[1:N] = -s[1:N] / (2 * (1 - s[1:N]**2))\n    \n    # Place diagonal entries into the matrix\n    np.fill_diagonal(D, diag)\n    \n    return D\n\ndef solve():\n    \"\"\"\n    Main solver function to run all test cases for spectral element differentiation.\n    \"\"\"\n    test_cases = [\n        # Case 1: General smooth function, asymmetric resolution\n        {\n            'x_split': 0.4, 'N1': 12, 'N2': 26,\n            'f': lambda x: np.sin(2 * np.pi * x),\n            'f_prime': lambda x: 2 * np.pi * np.cos(2 * np.pi * x)\n        },\n        # Case 2: Low-degree polynomial, moderate resolution\n        {\n            'x_split': 0.5, 'N1': 4, 'N2': 6,\n            'f': lambda x: x**3,\n            'f_prime': lambda x: 3 * x**2\n        },\n        # Case 3: Exponential, boundary-skewed resolution\n        {\n            'x_split': 0.25, 'N1': 2, 'N2': 10,\n            'f': lambda x: np.exp(x),\n            'f_prime': lambda x: np.exp(x)\n        },\n        # Case 4: Higher frequency trigonometric, strongly unbalanced resolution\n        {\n            'x_split': 0.7, 'N1': 30, 'N2': 8,\n            'f': lambda x: np.sin(10 * np.pi * x),\n            'f_prime': lambda x: 10 * np.pi * np.cos(10 * np.pi * x)\n        },\n    ]\n\n    results = []\n\n    for case in test_cases:\n        x_split, N1, N2 = case['x_split'], case['N1'], case['N2']\n        f, f_prime = case['f'], case['f_prime']\n\n        # --- Element 1: [0, x_split] ---\n        a1, b1 = 0.0, x_split\n        s1 = np.cos(np.arange(N1 + 1) * np.pi / N1) # Reference nodes\n        # Affine mapping from [-1, 1] to [a1, b1]\n        x1_nodes = (a1 + b1) / 2.0 + (b1 - a1) / 2.0 * s1\n        D_ref1 = chebyshev_diff_matrix(N1)\n        D1 = (2.0 / (b1 - a1)) * D_ref1\n        u1 = f(x1_nodes)\n        u1_prime = D1 @ u1\n\n        # --- Element 2: [x_split, 1] ---\n        a2, b2 = x_split, 1.0\n        s2 = np.cos(np.arange(N2 + 1) * np.pi / N2) # Reference nodes\n        # Affine mapping from [-1, 1] to [a2, b2]\n        x2_nodes = (a2 + b2) / 2.0 + (b2 - a2) / 2.0 * s2\n        D_ref2 = chebyshev_diff_matrix(N2)\n        D2 = (2.0 / (b2 - a2)) * D_ref2\n        u2 = f(x2_nodes)\n        u2_prime = D2 @ u2\n\n        # --- Global Assembly ---\n        # Combine all local nodes and derivative contributions\n        all_local_nodes = np.concatenate((x1_nodes, x2_nodes))\n        all_local_derivs = np.concatenate((u1_prime, u2_prime))\n        \n        # Get unique global nodes and an inverse map for assembly\n        global_nodes, inverse_map = np.unique(all_local_nodes, return_inverse=True)\n        \n        # Use bincount for efficient and correct assembly (summing contributions)\n        global_derivs_sum = np.bincount(inverse_map, weights=all_local_derivs)\n        # Bincount to find how many elements contribute to each node\n        counts = np.bincount(inverse_map)\n        \n        # Average at interface nodes (where count > 1)\n        global_derivs = global_derivs_sum / counts\n\n        # --- Error Calculation ---\n        exact_derivs = f_prime(global_nodes)\n        max_abs_error = np.max(np.abs(global_derivs - exact_derivs))\n        results.append(max_abs_error)\n\n    # Format the final output string exactly as required\n    output_str = f\"[{','.join([f'{r:.8f}' for r in results])}]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}