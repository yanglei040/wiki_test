{
    "hands_on_practices": [
        {
            "introduction": "双曲型偏微分方程描述了波的传播等现象，其中最基础的模型是一阶线性平流方程 $u_t + a u_x = 0$。这个练习  将指导你为该方程构建一个数值格式，通过实践来理解“迎风格式”的核心思想。你将学会如何让数值格式尊重由波速 $a$ 决定的信息传播方向，从而构建一个稳定且符合物理直觉的解法。",
            "id": "3229222",
            "problem": "考虑周期性空间域 $x \\in [0,1)$ 上的线性一阶平流方程 $u_t + a\\,u_x = 0$，其具有光滑、局部化的无量纲初始剖面。二阶波动方程 $u_{tt} = c^2\\,u_{xx}$ 具有达朗贝尔表示 $u(x,t) = f(x - c t) + g(x + c t)$，这可以解释为一阶平流方程的两个解的叠加，这两个解分别以速度 $a = +c$ 和 $a = -c$ 传播。在本问题中，您将通过算法模拟负速度和正速度下的平流过程，并在波动方程的左行和右行分量的背景下解释所得的传播方向。\n\n从基本原理出发，使用周期域 $[0,1)$ 和以下无量纲初始条件：\n$$\nu(x,0) \\equiv u_0(x) = \\exp\\!\\big(-50\\,d(x)^2\\big),\\quad d(x) = \\left[(x - 0.5) - \\mathrm{round}(x - 0.5)\\right],\n$$\n其中 $\\mathrm{round}(\\cdot)$ 将实数映射到最近的整数，因此 $d(x)$ 是到 $0.5$ 的最小周期距离。这将在 $x=0.5$ 处产生一个单一、光滑、局部化的“凸起”，并具有周期性延拓。\n\n您的任务是：\n- 从适用于双曲守恒律和特征线的基本原理出发，推导一个为 $u_t + a\\,u_x = 0$ 定制的一阶精度、单调的迎风有限差分法，该方法需满足 $[0,1)$ 上的周期性边界条件。离散化必须根据 $a$ 的符号选择正确的空间差分方向，并满足 Courant–Friedrichs–Lewy (CFL) 条件。\n- 在一个含 $N=400$ 个点、网格间距为 $\\Delta x = 1/N$ 的均匀网格上实现此方法，时间步长 $\\Delta t$ 通过指定的 CFL 数 $\\nu$ 选择，依据是当 $|a|>0$ 时满足 $|a|\\,\\Delta t / \\Delta x = \\nu$。当 $|a|=0$ 时，取 $\\Delta t = \\nu\\,\\Delta x$。通过使用整数个时间步长，将解精确推进到最终时间 $T$。\n- 使用周期性边界条件，并通过在移位的坐标处（进行周期性环绕）逐点计算 $u_0$ 来计算解析解 $u(x,T) = u_0(x - a T \\,\\mathrm{mod}\\, 1)$，然后计算离散 $L^2$ 误差\n$$\nE = \\left(\\Delta x \\sum_{i=0}^{N-1} \\big(u_i^{\\text{num}} - u_i^{\\text{exact}}\\big)^2\\right)^{1/2}.\n$$\n- 通过比较数值解在 $t=0$ 和 $t=T$ 时的质心（一阶矩）来推断模拟的传播方向。令\n$$\nx_{\\mathrm{cm}}(t) = \\frac{\\sum_{i} x_i\\,u_i(t)}{\\sum_{i} u_i(t)}.\n$$\n将方向标志 $D$ 定义为 $D=\\mathrm{sign}\\big(x_{\\mathrm{cm}}(T) - x_{\\mathrm{cm}}(0)\\big)$，约定 $D \\in \\{-1,0,+1\\}$，其中 $-1$ 表示向左传播，$+1$ 表示向右传播，$0$ 表示静止行为（使用一个小的阈值将可忽略的位移视为 $0$）。\n\n所有量均为无量纲。不涉及角度。无需物理单位。\n\n测试组：\n- 情况 1：$a=-1.0$，$\\nu=0.9$，$T=0.25$。\n- 情况 2：$a=-2.0$，$\\nu=0.8$，$T=0.10$。\n- 情况 3：$a=+1.0$，$\\nu=0.9$，$T=0.25$。\n- 情况 4：$a=0.0$，$\\nu=0.9$，$T=0.25$。\n- 情况 5：$a=-1.0$，$\\nu=1.0$，$T=0.25$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[E_1,D_1,E_2,D_2,E_3,D_3,E_4,D_4,E_5,D_5]$，其中 $E_k$ 是浮点数，$D_k$ 是对应情况的整数，这些值是使用指定方法和参数，在指定网格上计算至精确最终时间 $T$ 的结果。",
            "solution": "该问题要求在周期域上对一维线性平流方程 $u_t + a u_x = 0$ 进行数值模拟，并对结果进行分析。问题陈述经确认为自洽、科学上合理且适定的。\n\n### 一阶迎风法的推导\n\n控制偏微分方程 (PDE) 是线性平流方程：\n$$\n\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = 0\n$$\n其中 $u(x,t)$ 是守恒量，$a$ 是恒定的平流速度。\n\n该方程属于双曲型偏微分方程。其解可通过特征线法来理解。特征曲线是 $(x,t)$ 平面上的线，解 $u$ 沿着这些线保持不变。这些曲线由以下常微分方程定义：\n$$\n\\frac{dx}{dt} = a\n$$\n沿着这些曲线，$u$ 的全导数为：\n$$\n\\frac{d}{dt} u(x(t), t) = \\frac{\\partial u}{\\partial t} + \\frac{dx}{dt} \\frac{\\partial u}{\\partial x} = u_t + a u_x = 0\n$$\n这意味着 $u$ 沿着特征线是不变的。因此，解在点 $(x_i, t_n + \\Delta t)$ 的值等于它在前一时间步长上位于同一特征曲线上的点 $(x_i - a\\Delta t, t_n)$ 处的值。\n$$\nu(x_i, t_n + \\Delta t) = u(x_i - a\\Delta t, t_n)\n$$\n为了建立有限差分格式，我们必须使用时间 $t_n$ 上网格点 $\\{x_j\\}$ 的已知值来近似 $u(x_i - a\\Delta t, t_n)$ 的值。迎风法源于一种尊重信息流方向的一阶插值。\n\n我们使用空间间距为 $\\Delta x$、时间步长为 $\\Delta t$ 的均匀网格。令 $u_i^n \\approx u(x_i, t_n)$。\n\n**情况 1：$a > 0$（向右传播）**\n信息从左向右传播。点 $x_i - a\\Delta t$ 位于 $x_i$ 的左侧。对于一个稳定的格式，Courant–Friedrichs–Lewy (CFL) 条件要求数值格式的依赖域必须包含偏微分方程的依赖域。这导致条件 $a \\frac{\\Delta t}{\\Delta x} \\le 1$。在此条件下，点 $x_i - a\\Delta t$ 位于区间 $[x_{i-1}, x_i]$ 内。\n\n迎风原则要求在 $x_i$ 处使用来自“上风”方向（在此情况下为负 $x$ 方向）的值来近似空间导数 $\\frac{\\partial u}{\\partial x}$。我们使用一阶后向差分近似：\n$$\n\\frac{\\partial u}{\\partial x} \\bigg|_{x_i, t_n} \\approx \\frac{u_i^n - u_{i-1}^n}{\\Delta x}\n$$\n用前向欧拉步离散化时间导数，$\\frac{\\partial u}{\\partial t} \\approx \\frac{u_i^{n+1} - u_i^n}{\\Delta t}$，则偏微分方程变为：\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} + a \\left( \\frac{u_i^n - u_{i-1}^n}{\\Delta x} \\right) = 0\n$$\n求解 $u_i^{n+1}$：\n$$\nu_i^{n+1} = u_i^n - a \\frac{\\Delta t}{\\Delta x} (u_i^n - u_{i-1}^n)\n$$\n当 $a > 0$ 时，定义 CFL 数为 $\\nu = |a|\\frac{\\Delta t}{\\Delta x} = a\\frac{\\Delta t}{\\Delta x}$，则格式为：\n$$\nu_i^{n+1} = u_i^n - \\nu (u_i^n - u_{i-1}^n)\n$$\n\n**情况 2：$a  0$（向左传播）**\n信息从右向左传播。点 $x_i - a\\Delta t$ 位于 $x_i$ 的右侧。此时上风方向为正 $x$ 方向。我们对空间导数使用一阶前向差分：\n$$\n\\frac{\\partial u}{\\partial x} \\bigg|_{x_i, t_n} \\approx \\frac{u_{i+1}^n - u_i^n}{\\Delta x}\n$$\n半离散方程为：\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} + a \\left( \\frac{u_{i+1}^n - u_i^n}{\\Delta x} \\right) = 0\n$$\n求解 $u_i^{n+1}$：\n$$\nu_i^{n+1} = u_i^n - a \\frac{\\Delta t}{\\Delta x} (u_{i+1}^n - u_i^n)\n$$\n此时，CFL 数为 $\\nu = |a|\\frac{\\Delta t}{\\Delta x} = -a\\frac{\\Delta t}{\\Delta x}$，因此 $a\\frac{\\Delta t}{\\Delta x} = -\\nu$。格式变为：\n$$\nu_i^{n+1} = u_i^n - (-\\nu) (u_{i+1}^n - u_i^n) = u_i^n + \\nu (u_{i+1}^n - u_i^n)\n$$\n\n**情况 3：$a = 0$（静止）**\n偏微分方程简化为 $u_t = 0$。解在时间上是恒定的。数值格式应反映这一点：\n$$\nu_i^{n+1} = u_i^n\n$$\n当 $a=0$ 时，两个推导出的公式都能正确地简化为此结果（根据问题对 $a \\neq 0$ 的 CFL 定义，此时 $\\nu=0$，尽管对于 $a=0$ 的情况，我们的更新逻辑也只会执行 $u_i^{n+1} = u_i^n$）。\n\n这种显式一阶迎风格式的稳定性条件是 $0 \\le \\nu \\le 1$。\n\n### 实现细节\n\n**数值网格和时间步进：**\n空间域 $[0,1)$ 被离散为 $N=400$ 个点，$x_i = i \\Delta x$，$i=0, \\dots, N-1$，其中 $\\Delta x = 1/N$。通过对索引取模 $N$ 来实施周期性边界条件。\n最终时间 $T$ 必须在整数个步数内达到。给定 CFL 数 $\\nu$，对于 $a \\neq 0$ 的情况，基础时间步长计算为 $\\Delta t_{base} = \\nu \\Delta x / |a|$，对于 $a=0$ 的情况，$\\Delta t_{base} = \\nu \\Delta x$。整数步数为 $N_t = \\lceil T / \\Delta t_{base} \\rceil$。然后将模拟中实际使用的时间步长调整为 $\\Delta t = T / N_t$，这确保了模拟在恰好时间 $T$ 结束，同时满足 CFL 稳定性条件，因为 $\\Delta t \\le \\Delta t_{base}$。\n\n**初始条件：**\n初始条件为 $u(x,0) = \\exp(-50\\,d(x)^2)$。函数 $d(x) = (x-0.5) - \\mathrm{round}(x-0.5)$ 表示从 $x$ 到定义域中心 $0.5$ 的有符号周期距离。对于 $x \\in [0,1)$，这可以简化为 $d(x) = x-0.5$。因此，初始剖面为 $u_i^0 = \\exp(-50 (x_i - 0.5)^2)$。\n\n**解析解：**\n平流方程的解析解是初始剖面的简单平移：$u(x,t) = u_0(x-at)$。在周期域上，这变为 $u(x,t) = u_0((x-at) \\pmod 1)$。网格点上的精确解为：\n$$\nu_i^{\\text{exact}} = \\exp\\left(-50 \\left( ((x_i - aT) \\pmod 1) - 0.5 \\right)^2\\right)\n$$\n\n**误差和方向计算：**\n离散 $L^2$ 误差按指定方式计算：\n$$\nE = \\left(\\Delta x \\sum_{i=0}^{N-1} \\big(u_i^{\\text{num}}(T) - u_i^{\\text{exact}}(T)\\big)^2\\right)^{1/2}\n$$\n传播方向通过分布的质心（一阶矩）的变化来推断，$x_{\\mathrm{cm}}(t) = \\frac{\\sum_i x_i u_i(t)}{\\sum_i u_i(t)}$。方向标志 $D$ 为：\n$$\nD = \\mathrm{sign}\\big(x_{\\mathrm{cm}}(T) - x_{\\mathrm{cm}}(0)\\big)\n$$\n使用一个小的阈值来为可忽略的位移设置 $D=0$，以考虑浮点不精确性和静止情况。\n\n对每个测试用例实施该算法，并收集得到的误差 $E$ 和方向标志 $D$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the 1D linear advection equation using a first-order upwind scheme\n    for a set of test cases and computes the L2 error and propagation direction.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (a, nu, T)\n        (-1.0, 0.9, 0.25),\n        (-2.0, 0.8, 0.10),\n        (+1.0, 0.9, 0.25),\n        ( 0.0, 0.9, 0.25),\n        (-1.0, 1.0, 0.25),\n    ]\n\n    results = []\n    \n    # Grid parameters\n    N = 400\n    dx = 1.0 / N\n    x = np.linspace(0.0, 1.0, N, endpoint=False)\n\n    for a, nu, T in test_cases:\n        # 1. Initial Condition\n        # The definition d(x) = (x-0.5) - round(x-0.5) for x in [0,1) simplifies\n        # to d(x) = x - 0.5 because round(x-0.5) is 0 in this range.\n        u = np.exp(-50.0 * (x - 0.5)**2)\n        u_initial = np.copy(u)\n\n        # 2. Time-stepping parameters\n        if a == 0.0:\n            # For a=0, time step is defined differently.\n            # The equation is u_t = 0, so the solution is stationary.\n            # We still set up time steps to match final time T.\n            dt_base = nu * dx if nu * dx > 0 else 1e-9 # Avoid division by zero if T=0\n        else:\n            # CFL condition: nu = |a| * dt / dx\n            dt_base = nu * dx / abs(a)\n\n        # Calculate number of steps to reach T exactly\n        # Note: If T=0, n_steps=0. The loop won't run, u remains u_initial.\n        n_steps = math.ceil(T / dt_base) if T > 0 and dt_base > 0 else 0\n        dt = T / n_steps if n_steps > 0 else 0.0\n        \n        # 3. Compute initial centroid\n        x_cm0 = np.sum(x * u_initial) / np.sum(u_initial)\n\n        # 4. Time evolution loop\n        # The update uses vectorized numpy operations for efficiency.\n        # np.roll(u, 1) gets u_{i-1} at index i (periodic)\n        # np.roll(u, -1) gets u_{i+1} at index i (periodic)\n        \n        cfl_factor = a * dt / dx\n\n        for _ in range(n_steps):\n            if a > 0:\n                # Backward difference for u_x: (u_i - u_{i-1}) / dx\n                # u_new = u - (a*dt/dx) * (u - np.roll(u,1))\n                u = u - cfl_factor * (u - np.roll(u, 1))\n            elif a  0:\n                # Forward difference for u_x: (u_{i+1} - u_i) / dx\n                # u_new = u - (a*dt/dx) * (np.roll(u,-1) - u)\n                u = u - cfl_factor * (np.roll(u, -1) - u)\n            # If a == 0.0, u is unchanged.\n        \n        u_numerical = u\n\n        # 5. Compute final centroid and propagation direction\n        x_cmT = np.sum(x * u_numerical) / np.sum(u_numerical)\n        \n        delta_cm = x_cmT - x_cm0\n        # Use a small threshold for determining stationary behavior\n        if abs(delta_cm)  1e-9:\n            D = 0\n        else:\n            D = int(np.sign(delta_cm))\n        \n        # Correct for periodic wrapping in direction calculation.\n        # The provided test cases do not involve wrapping, so simple sign suffices.\n        # A more robust method would check the shortest periodic distance.\n        # For example: if delta_cm > 0.5, D should be -1. if delta_cm  -0.5, D should be 1.\n        # This is not needed for the given test values of a and T.\n            \n        # 6. Compute analytical solution and error\n        x_shifted = (x - a * T) % 1.0\n        # The simplified form of d(x) applies here as well.\n        u_exact = np.exp(-50.0 * (x_shifted - 0.5)**2)\n\n        # Discrete L2 error\n        error = np.sqrt(dx * np.sum((u_numerical - u_exact)**2))\n\n        results.extend([error, D])\n\n    # Final print statement in the exact required format.\n    # Convert results to string with desired formatting\n    formatted_results = []\n    for item in results:\n        if isinstance(item, int):\n            formatted_results.append(str(item))\n        else:\n            # Standard float formatting for consistency\n            formatted_results.append(f\"{item:.15g}\")\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "对于经典的二阶波动方程 $u_{tt} = c^2 u_{xx}$，中心差分格式是一种常用且精度较高的方法。然而，所有离散格式都会引入某种形式的误差，其中“数值频散”是一个关键问题，它会导致不同频率的波在模拟中以错误的速度传播。这个练习  将让你亲手构造一个“恶意”的初始条件——网格上可表示的最高频率波，来最大化并揭示数值频散效应，通过这个极限测试深刻理解数值格式的保真度限制。",
            "id": "3229319",
            "problem": "考虑在一维周期区间 $[0,L)$ 上定义的一维线性波偏微分方程 (PDE) $u_{tt} = c^2 u_{xx}$，其中 $u(x,t)$ 在时间和空间上二阶可微，$c$ 是恒定的波速，$L$ 是域的长度。该数值任务是研究一种标准的二阶显式有限差分方法的色散性质，其初始条件被特意选择为给定空间网格上可以表示的最高频率。\n\n您将使用一个包含 $N$ 个点的均匀网格，空间步长为 $\\Delta x = L/N$，时间步长为 $\\Delta t$。设网格点为 $x_i = i \\,\\Delta x$，其中 $i = 0,1,\\dots,N-1$，时间层为 $t^n = n \\,\\Delta t$，其中整数 $n \\ge 0$。使用周期性边界条件，意味着索引以 $N$ 为模进行环绕。该网格上可表示的最高波数（奈奎斯特模式）是 $k_{\\max} = \\pi/\\Delta x$。将“恶意”初始位移定义为 $u(x,0) = \\cos(k_{\\max} x)$，初始速度定义为 $u_t(x,0) = 0$。这个初始条件最大限度地暴露了数值色散的敏感性，因为它位于离散谱的边缘。\n\n在上述网格上，使用时间和空间上的中心差分，实现一个与 $u_{tt} = c^2 u_{xx}$ 相容的二阶精度显式有限差分方法。在逼近空间导数时使用周期性边界条件。根据 $u(x,0)$ 初始化 $u^0$，并利用 $u_t(x,0)$ 和该方法与 PDE 的相容性来构造 $u^1$，以使整个格式在时间上保持二阶精度。\n\n对于每次模拟，通过利用奈奎斯特模式在固定网格点上的离散时间行为，或通过将演化的解 $u^n$ 与初始空间模式 $\\phi_i = \\cos(k_{\\max} x_i)$ 相关联，来估计其数值角频率 $\\omega_{\\text{num}}$。具体来说，对于一个近似的单模时间序列，使用余弦序列的恒等式从序列 $\\{u^n\\}$ 中估计 $\\cos(\\omega_{\\text{num}} \\Delta t)$，并在多个时间层上对此估计值进行平均以减少数值噪声。计算该模式在连续 PDE 下的精确角频率 $\\omega_{\\text{exact}} = c\\,k_{\\max}$。将色散误差度量定义为无量纲浮点数\n$$\nE = \\left| \\frac{\\omega_{\\text{num}}}{\\omega_{\\text{exact}}} - 1 \\right|.\n$$\n\n所有物理量必须使用适当的单位处理：选择 $L$ 的单位为米，$c$ 的单位为米/秒，$\\Delta t$ 的单位为秒；三角函数中的角度单位为弧度。为了保证稳定性，应遵守 Courant–Friedrichs–Lewy (CFL) 条件；定义无量纲的库朗数 $s = \\frac{c\\,\\Delta t}{\\Delta x}$，并使用 $s \\le 1$ 的值。\n\n您的程序必须：\n- 使用 $k_{\\max} = \\pi/\\Delta x$ 构造恶意初始条件。\n- 在周期性边界条件下，使用二阶显式中心有限差分方法推进解。\n- 从时间序列中估计 $\\omega_{\\text{num}}$，并为每个测试用例计算 $E$。\n- 将每个 $E$ 四舍五入到 8 位小数。\n\n使用以下测试套件，在保持 $L$ 和 $c$ 固定的情况下，通过改变库朗数 $s$ 来探究不同工况下的色散：\n- 用例 1：$L = 1$ (米)，$c = 1$ (米/秒)，$N = 128$，$s = 0.2$，$n_{\\text{steps}} = 200$。\n- 用例 2：$L = 1$ (米)，$c = 1$ (米/秒)，$N = 128$，$s = 0.5$，$n_{\\text{steps}} = 200$。\n- 用例 3：$L = 1$ (米)，$c = 1$ (米/秒)，$N = 128$，$s = 0.9$，$n_{\\text{steps}} = 200$。\n- 用例 4：$L = 1$ (米)，$c = 1$ (米/秒)，$N = 128$，$s = 1.0$，$n_{\\text{steps}} = 200$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的结果按上述测试用例的顺序排列。例如，输出格式必须为\n$[E_1,E_2,E_3,E_4]$,\n其中每个 $E_j$ 是用例 $j$ 的色散误差，四舍五入到 8 位小数。",
            "solution": "该问题要求研究针对一维线性波方程 $u_{tt} = c^2 u_{xx}$ 的标准二阶显式有限差分方法的数值色散。分析重点是一个特定的初始条件，即奈奎斯特模式，它是离散网格上可表示的最高频率模式。这一选择最大限度地暴露了该格式的色散误差。\n\n首先，我们定义计算域和离散化。空间域是一个周期性区间 $[0,L)$，被离散为 $N$ 个点 $x_i = i \\Delta x$（$i=0, 1, \\dots, N-1$），网格间距为 $\\Delta x = L/N$。时间被离散为时间层 $t^n = n \\Delta t$，其中 $\\Delta t$ 是时间步长。在网格点 $x_i$ 和时间 $t^n$ 处的解记为 $u_i^n \\approx u(x_i, t^n)$。\n\n偏微分方程 $u_{tt} = c^2 u_{xx}$ 使用二阶精度的中心有限差分来逼近时间和空间导数：\n$$\n\\frac{\\partial^2 u}{\\partial t^2}\\bigg|_{i,n} \\approx \\frac{u_i^{n+1} - 2u_i^n + u_i^{n-1}}{(\\Delta t)^2}\n$$\n$$\n\\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{i,n} \\approx \\frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{(\\Delta x)^2}\n$$\n将这些表达式代入 PDE 并重新整理，得到显式时间推进格式，通常称为蛙跳法：\n$$\nu_i^{n+1} = 2u_i^n - u_i^{n-1} + \\left(\\frac{c \\Delta t}{\\Delta x}\\right)^2 (u_{i+1}^n - 2u_i^n + u_{i-1}^n)\n$$\n设 $s = \\frac{c \\Delta t}{\\Delta x}$ 为无量纲库朗数。该格式可以写成：\n$$\nu_i^{n+1} = 2(1-s^2)u_i^n + s^2(u_{i+1}^n + u_{i-1}^n) - u_i^{n-1}\n$$\n强制实施周期性边界条件，意味着索引以 $N$ 为模，使得 $u_N^n = u_0^n$ 和 $u_{-1}^n = u_{N-1}^n$。该格式在 $s \\le 1$ 时是稳定的。\n\n初始条件被指定为一种“恶意”模式，旨在探测最坏情况下的色散。初始位移为 $u(x,0) = \\cos(k_{\\max}x)$，其中 $k_{\\max} = \\pi/\\Delta x$ 是奈奎斯特波数。在离散网格上，这变为：\n$$\nu_i^0 = u(x_i, 0) = \\cos(k_{\\max} x_i) = \\cos\\left(\\frac{\\pi}{\\Delta x} i \\Delta x\\right) = \\cos(i\\pi) = (-1)^i\n$$\n这个初始条件对应于锯齿状或棋盘状模式，是网格上可以表示的最高频率波。初始速度为 $u_t(x,0)=0$。\n\n蛙跳格式是一种三层方法，需要前两个时间步的数据 $u^n$ 和 $u^{n-1}$ 来计算 $u^{n+1}$。为了求得第一个时间步的解 $u^1$，我们必须使用一种不同的方法来保持该格式的二阶精度。使用 $u(x,t)$ 在 $t=0$ 附近的泰勒级数展开：\n$$\nu(x, \\Delta t) = u(x,0) + \\Delta t \\, u_t(x,0) + \\frac{(\\Delta t)^2}{2} u_{tt}(x,0) + O((\\Delta t)^3)\n$$\n利用初始条件 $u_t(x,0)=0$ 和 PDE 本身 $u_{tt}(x,0) = c^2 u_{xx}(x,0)$，我们得到：\n$$\nu(x, \\Delta t) \\approx u(x,0) + \\frac{c^2 (\\Delta t)^2}{2} u_{xx}(x,0)\n$$\n在空间上离散化该表达式，得到 $u_i^1$ 的公式：\n$$\nu_i^1 = u_i^0 + \\frac{s^2}{2} (u_{i+1}^0 - 2u_i^0 + u_{i-1}^0) = (1-s^2)u_i^0 + \\frac{s^2}{2}(u_{i+1}^0 + u_{i-1}^0)\n$$\n在确定了 $u^0$ 和 $u^1$ 之后，主蛙跳循环就可以对所有后续时间步进行计算。\n\n为了量化色散误差，我们必须估计数值角频率 $\\omega_{\\text{num}}$，并将其与精确角频率 $\\omega_{\\text{exact}}$ 进行比较。对于波数为 $k$ 的波，连续 PDE 蕴含了线性色散关系 $\\omega = c k$。对于奈奎斯特模式，这给出：\n$$\n\\omega_{\\text{exact}} = c k_{\\max} = \\frac{c \\pi}{\\Delta x}\n$$\n对于指定的初始条件，数值解预期会按 $u_i^n \\approx (-1)^i \\cos(\\omega_{\\text{num}} n \\Delta t)$ 演化。该模式随时间变化的振幅 $A_n = \\cos(\\omega_{\\text{num}} n \\Delta t)$ 可以通过将数值解向量 $U^n = \\{u_i^n\\}_{i=0}^{N-1}$ 投影到初始模式形状向量 $\\phi = \\{(-1)^i\\}_{i=0}^{N-1}$ 上来分离出来：\n$$\nA_n = \\frac{1}{N} \\sum_{i=0}^{N-1} u_i^n \\phi_i\n$$\n序列 $\\{A_n\\}$ 遵循余弦的三项递推关系：$A_{n+1} + A_{n-1} = 2 A_n \\cos(\\omega_{\\text{num}} \\Delta t)$。我们可以重新整理它来估计相位步长的余弦值：\n$$\n\\cos(\\omega_{\\text{num}} \\Delta t) = \\frac{A_{n+1} + A_{n-1}}{2 A_n}\n$$\n通过为每个时间步 $n$（其中 $A_n$ 不接近于零）计算该量并对结果进行平均，我们获得了一个稳健的估计值 $\\cos_{\\text{est}}$。然后通过以下方式恢复数值角频率：\n$$\n\\omega_{\\text{num}} = \\frac{1}{\\Delta t} \\arccos(\\cos_{\\text{est}})\n$$\n最后，色散误差度量 $E$ 被计算为数值频率和精确频率之间的相对差异：\n$$\nE = \\left| \\frac{\\omega_{\\text{num}}}{\\omega_{\\text{exact}}} - 1 \\right|\n$$\n对每一组给定的参数重复此过程，以分析色散误差如何随库朗数 $s$ 变化。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the wave equation for the Nyquist mode to analyze numerical dispersion.\n    \"\"\"\n    # test_cases: (L, c, N, s, n_steps)\n    test_cases = [\n        (1.0, 1.0, 128, 0.2, 200),\n        (1.0, 1.0, 128, 0.5, 200),\n        (1.0, 1.0, 128, 0.9, 200),\n        (1.0, 1.0, 128, 1.0, 200),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        L, c, N, s, n_steps = case\n\n        # Grid and simulation parameters\n        dx = L / N\n        dt = s * dx / c\n        \n        # Store solution history\n        u_history = np.zeros((n_steps + 1, N))\n\n        # Initial condition u^0: Nyquist mode u(x,0) = cos(pi*x/dx)\n        # u_i^0 = cos(pi * i*dx / dx) = cos(i*pi) = (-1)^i\n        u_curr = np.array([(-1)**i for i in range(N)], dtype=float)\n        u_history[0, :] = u_curr\n        \n        # First time step u^1, using u_t(x,0) = 0\n        # u_i^1 = (1-s^2)u_i^0 + (s^2/2)(u_{i+1}^0 + u_{i-1}^0)\n        u_prev = np.copy(u_curr) # This will be u^0\n        u_ip1 = np.roll(u_curr, -1)\n        u_im1 = np.roll(u_curr, 1)\n        u_curr = (1 - s**2) * u_curr + (s**2 / 2.0) * (u_ip1 + u_im1)\n        u_history[1, :] = u_curr\n\n        # Main loop (leapfrog scheme)\n        for n in range(1, n_steps):\n            u_ip1 = np.roll(u_curr, -1)\n            u_im1 = np.roll(u_curr, 1)\n            u_next = 2.0 * (1.0 - s**2) * u_curr + s**2 * (u_ip1 + u_im1) - u_prev\n            \n            u_prev = np.copy(u_curr)\n            u_curr = np.copy(u_next)\n            u_history[n + 1, :] = u_curr\n\n        # Post-processing: Estimate numerical frequency\n        # Initial mode shape\n        phi = np.array([(-1)**i for i in range(N)], dtype=float)\n        \n        # Project solution onto the mode shape to get amplitudes A_n\n        # A_n = dot(u_n, phi) / N\n        amplitudes = np.dot(u_history, phi) / N\n\n        cos_estimates = []\n        # Estimate cos(omega_num * dt) from the amplitude recurrence\n        # cos(theta) = (A_{n+1} + A_{n-1}) / (2 * A_n)\n        for n in range(1, n_steps):\n            # Avoid division by zero or small numbers\n            if abs(amplitudes[n]) > 1e-10:\n                cos_est = (amplitudes[n+1] + amplitudes[n-1]) / (2.0 * amplitudes[n])\n                cos_estimates.append(cos_est)\n\n        if not cos_estimates:\n             # Fallback if no valid estimates could be made (highly unlikely)\n             # Use the analytical dispersion relation for the Nyquist mode\n             avg_cos_est = 1.0 - 2.0 * s**2\n        else:\n             avg_cos_est = np.mean(cos_estimates)\n\n        # Clip to handle potential floating-point errors pushing value outside [-1, 1]\n        avg_cos_est = np.clip(avg_cos_est, -1.0, 1.0)\n        \n        omega_num = np.arccos(avg_cos_est) / dt\n\n        # Calculate exact frequency and dispersion error\n        k_max = np.pi / dx\n        omega_exact = c * k_max\n        \n        # Ensure omega_exact is not zero to avoid division errors\n        if abs(omega_exact)  1e-12:\n            dispersion_error = 0.0 if abs(omega_num)  1e-12 else np.inf\n        else:\n            dispersion_error = abs(omega_num / omega_exact - 1.0)\n            \n        results.append(round(dispersion_error, 8))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "现在，我们将有限差分法应用于一个更真实的物理场景：模拟一根被拨动的琴弦，其声音由振动的谐波决定。这个动手实践  是一个综合性项目，它将数值模拟与傅里叶分析相结合，让你模拟一个包含丰富频率成分的三角波初始位移。通过对观测点振动历史进行离散傅里叶变换 (DFT)，并将其频谱与解析解进行定量比较，你将能全面检验数值方法的准确性。",
            "id": "3229336",
            "problem": "考虑描述理想弦横向位移的一维波动方程，其端点固定，\n$$\nu_{tt}(x,t) = c^2\\, u_{xx}(x,t), \\qquad 0  x  L, \\quad t  0,\n$$\n满足固定端点边界条件\n$$\nu(0,t) = 0, \\qquad u(L,t) = 0,\n$$\n以及“拨动”后的初始位移\n$$\nu(x,0) = u_0(x) = \n\\begin{cases}\n\\dfrac{A_0}{p L}\\, x,  0 \\le x \\le p L, \\\\\n\\dfrac{A_0}{(1-p) L}\\,(L - x),  p L \\le x \\le L,\n\\end{cases}\n\\qquad u_t(x,0) = 0,\n$$\n其中 $L$ 是弦长（单位：$\\mathrm{m}$），$c$ 是波速（单位：$\\mathrm{m/s}$），$A_0$ 是拨动振幅（单位：$\\mathrm{m}$），$p \\in (0,1)$ 是从 $x=0$ 处测量的归一化拨动位置。\n\n你将使用空间和时间上的均匀有限差分网格来近似求解。设空间网格点数为 $N_x$，间距为 $\\Delta x = L/(N_x-1)$，时间步长为 $\\Delta t$。使用显式二阶中心差分格式，\n$$\nu_j^{n+1} = 2 u_j^n - u_j^{n-1} + \\lambda^2 \\left(u_{j+1}^n - 2 u_j^n + u_{j-1}^n\\right),\n$$\n其中 $u_j^n$ 近似于 $u(x_j, t_n)$ 在 $x_j = j\\,\\Delta x$ 和 $t_n = n\\,\\Delta t$ 处的值，且 $\\lambda = \\dfrac{c\\,\\Delta t}{\\Delta x}$。使用针对零初始速度的二阶精度泰勒展开进行初始化，\n$$\nu_j^1 = u_j^0 + \\frac{1}{2}\\,\\lambda^2 \\left(u_{j+1}^0 - 2 u_j^0 + u_{j-1}^0\\right).\n$$\n\n对于固定端点边界条件，其解析模态展开为\n$$\nu(x,t) = \\sum_{n=1}^{\\infty} A_n \\sin\\!\\left(\\frac{n\\pi x}{L}\\right)\\cos\\!\\left(\\omega_n t\\right),\n\\qquad \\omega_n = \\frac{n\\pi c}{L}, \\qquad f_n = \\frac{\\omega_n}{2\\pi} = \\frac{n c}{2L},\n$$\n其中 $A_n$ 是初始剖面 $u_0(x)$ 的正弦级数系数：\n$$\nA_n = \\frac{2}{L}\\int_0^L u_0(x) \\sin\\!\\left(\\frac{n\\pi x}{L}\\right)\\,dx.\n$$\n\n任务1（推导）：从上述 $A_n$ 的定义和拨动后的初始形状 $u_0(x)$ 出发，推导出 $A_n$ 关于 $A_0$、$p$、$L$ 和 $n$ 的闭式表达式，然后推导出在观测点 $x_\\mathrm{obs}$ 处模态 $n$ 的解析振幅为\n$$\nB_n^\\mathrm{(theory)} = \\left|A_n \\sin\\!\\left(\\frac{n\\pi x_\\mathrm{obs}}{L}\\right)\\right|.\n$$\n使用弧度制表示角度。\n\n任务2（算法设计）：从上述波动方程和给定的显式格式出发，解释如何选择 $\\Delta t$ 和总模拟时间 $T_\\mathrm{total}$，以获得一个数值上良好分辨的频谱，该频谱能将离散傅里叶变换（DFT）的频率仓与解析模态频率 $f_n$ 对齐。使用 Courant–Friedrichs–Lewy (CFL) 数的定义 $\\lambda = \\dfrac{c\\,\\Delta t}{\\Delta x}$，并确保 $\\lambda = 1$，从而\n$$\n\\Delta t = \\frac{\\Delta x}{c}, \\qquad T_\\mathrm{total} = M\\,T_1 = \\frac{M}{f_1} = M\\,\\frac{2L}{c},\n$$\n其中 $M \\ge 1$ 是一个选定的整数。通过这种选择，第 $n$ 个模态的 DFT 频率仓将对应一个整数索引，从而可以直接比较不同模态间的谱幅值。\n\n任务3（实现与比较）：实现一个程序，该程序能够\n- 构建空间网格，并用拨动形状 $u_0(x)$ 初始化 $u_j^0$，以及使用给定公式初始化 $u_j^1$。\n- 使用显式更新公式将解在时间上推進，其中 $n=1,2,\\dots,N_t-1$，且 $N_t = \\lfloor T_\\mathrm{total}/\\Delta t\\rfloor$。\n- 通过选择最近的网格索引，在固定观测点 $x_\\mathrm{obs}$ 记录时间序列 $u(x_\\mathrm{obs}, t)$。\n- 计算所记录时间序列的DFT，并通过读取DFT在频率仓索引 $k_n = n M$（其中 $n=1,\\dots,K$，$K$ 为要比较的模态数量）处的值，提取在解析模态频率处的数值谱幅值。\n- 根据任务1的结果，为 $n=1,\\dots,K$ 构建理论振幅向量 $B_n^\\mathrm{(theory)}$。\n- 将数值和理论振幅向量分别除以其各自的最大值进行归一化，以关注相对谱形。\n- 计算归一化后的数值向量和理论向量之间的平均绝对差，为该测试用例生成一个单一的浮点数误差度量：\n$$\nE = \\frac{1}{K}\\sum_{n=1}^K \\left| \\frac{B_n^\\mathrm{(num)}}{\\max_m B_m^\\mathrm{(num)}} - \\frac{B_n^\\mathrm{(theory)}}{\\max_m B_m^\\mathrm{(theory)}} \\right|.\n$$\n\n物理单位：$L$ 的单位必须是 $\\mathrm{m}$，$c$ 的单位是 $\\mathrm{m/s}$，$A_0$ 的单位是 $\\mathrm{m}$，$T_\\mathrm{total}$ 的单位是 $\\mathrm{s}$。所有正弦函数中的角度均为弧度。最终的误差度量 $E$ 是无量纲的。\n\n测试套件：你的程序必须评估以下三个案例，并为每个案例输出一个浮点数，每个浮点数都按上述方法计算。\n- 案例1（中心拨动，奇次谐波主导）：$L = 1.0\\,\\mathrm{m}$，$c = 1.0\\,\\mathrm{m/s}$，$A_0 = 1.0\\,\\mathrm{m}$，$N_x = 129$，$p = 0.5$，$x_\\mathrm{obs} = 0.31\\,\\mathrm{m}$，$M = 32$，$K = 8$。\n- 案例2（偏心拨动，混合谐波）：$L = 1.0\\,\\mathrm{m}$，$c = 2.0\\,\\mathrm{m/s}$，$A_0 = 1.0\\,\\mathrm{m}$，$N_x = 129$，$p = 0.3$，$x_\\mathrm{obs} = 0.37\\,\\mathrm{m}$，$M = 32$，$K = 10$。\n- 案例3（近端拨动，高频分量更强）：$L = 1.0\\,\\mathrm{m}$，$c = 1.5\\,\\mathrm{m/s}$，$A_0 = 1.0\\,\\mathrm{m}$，$N_x = 257$，$p = 0.1$，$x_\\mathrm{obs} = 0.83\\,\\mathrm{m}$，$M = 16$，$K = 12$。\n\n最终输出格式：你的程序应生成单行输出，其中包含上述三个案例的误差度量，形式为用方括号括起来的逗号分隔列表，例如 `\"[e_1,e_2,e_3]\"`，其中每个 $e_i$ 是一个浮点数。",
            "solution": "该问题被评估为有效。它在科学上基于波传播的物理学以及偏微分方程和傅里叶分析的数学。它是一个适定问题，具有完整且一致的方程、边界条件、初始条件和参数。各项任务客观、定义清晰，并能得出一个可验证的数值结果。\n\n### 任务1：解析模态振幅的推导\n\n第一个任务是为初始位移剖面 $u_0(x)$ 的傅里叶正弦级数系数 $A_n$ 推导一个闭式表达式。系数 $A_n$ 定义为：\n$$\nA_n = \\frac{2}{L}\\int_0^L u_0(x) \\sin\\!\\left(\\frac{n\\pi x}{L}\\right)\\,dx\n$$\n初始形状 $u_0(x)$ 是一个分段线性函数：\n$$\nu_0(x) = \n\\begin{cases}\n\\dfrac{A_0}{p L}\\, x,  0 \\le x \\le p L, \\\\\n\\dfrac{A_0}{(1-p) L}\\,(L - x),  p L \\le x \\le L,\n\\end{cases}\n$$\n我们将 $u_0(x)$ 代入 $A_n$ 的积分中，并根据分段定义将积分分成两部分：\n$$\nA_n = \\frac{2}{L} \\left[ \\int_0^{pL} \\frac{A_0}{pL} x \\sin\\!\\left(\\frac{n\\pi x}{L}\\right) dx + \\int_{pL}^{L} \\frac{A_0}{(1-p)L} (L-x) \\sin\\!\\left(\\frac{n\\pi x}{L}\\right) dx \\right]\n$$\n让我们计算这两个积分，记为 $I_1$ 和 $I_2$。为简洁起见，设 $k = \\frac{n\\pi}{L}$。\n\n第一个积分是：\n$$\nI_1 = \\frac{2A_0}{pL^2} \\int_0^{pL} x \\sin(kx) \\,dx\n$$\n使用分部积分法，$\\int x \\sin(kx) \\,dx = -\\frac{x}{k}\\cos(kx) + \\frac{1}{k^2}\\sin(kx) + C$：\n$$\nI_1 = \\frac{2A_0}{pL^2} \\left[ -\\frac{x}{k}\\cos(kx) + \\frac{1}{k^2}\\sin(kx) \\right]_0^{pL}\n$$\n$$\nI_1 = \\frac{2A_0}{pL^2} \\left( \\left(-\\frac{pL}{k}\\cos(kpL) + \\frac{1}{k^2}\\sin(kpL)\\right) - (0) \\right)\n$$\n代入 $k = \\frac{n\\pi}{L}$ 和 $kpL = n\\pi p$：\n$$\nI_1 = \\frac{2A_0}{pL^2} \\left( -\\frac{pL^2}{n\\pi}\\cos(n\\pi p) + \\frac{L^2}{(n\\pi)^2}\\sin(n\\pi p) \\right) = \\frac{2A_0 \\sin(n\\pi p)}{p(n\\pi)^2} - \\frac{2A_0 \\cos(n\\pi p)}{n\\pi}\n$$\n第二个积分是：\n$$\nI_2 = \\frac{2A_0}{(1-p)L^2} \\int_{pL}^{L} (L-x) \\sin(kx) \\,dx = \\frac{2A_0}{(1-p)L^2} \\left[ L\\int_{pL}^L \\sin(kx)dx - \\int_{pL}^L x\\sin(kx)dx \\right]\n$$\n计算各项：\n$$\n\\int \\sin(kx)dx = -\\frac{1}{k}\\cos(kx)\n$$\n$$\n\\int (L-x)\\sin(kx)dx = -\\frac{L}{k}\\cos(kx) - \\left(-\\frac{x}{k}\\cos(kx) + \\frac{1}{k^2}\\sin(kx)\\right) = \\frac{x-L}{k}\\cos(kx) - \\frac{1}{k^2}\\sin(kx)\n$$\n因此，对于 $A_n$ 的第二部分积分：\n$$\nI_2 = \\frac{2A_0}{(1-p)L^2} \\left[ \\frac{x-L}{k}\\cos(kx) - \\frac{1}{k^2}\\sin(kx) \\right]_{pL}^L\n$$\n在上限 $x=L$ 处：$\\left[ 0 - \\frac{1}{k^2}\\sin(n\\pi) \\right] = 0$。\n在下限 $x=pL$ 处：$\\left[ \\frac{pL-L}{k}\\cos(n\\pi p) - \\frac{1}{k^2}\\sin(n\\pi p) \\right] = \\left[ -\\frac{(1-p)L}{k}\\cos(n\\pi p) - \\frac{1}{k^2}\\sin(n\\pi p) \\right]$。\n$$\nI_2 = \\frac{2A_0}{(1-p)L^2} \\left( 0 - \\left( -\\frac{(1-p)L^2}{n\\pi}\\cos(n\\pi p) - \\frac{L^2}{(n\\pi)^2}\\sin(n\\pi p) \\right) \\right)\n$$\n$$\nI_2 = \\frac{2A_0}{(1-p)L^2} \\left( \\frac{(1-p)L^2}{n\\pi}\\cos(n\\pi p) + \\frac{L^2}{(n\\pi)^2}\\sin(n\\pi p) \\right) = \\frac{2A_0 \\cos(n\\pi p)}{n\\pi} + \\frac{2A_0 \\sin(n\\pi p)}{(1-p)(n\\pi)^2}\n$$\n现在，我们将两部分贡献相加：$A_n = I_1 + I_2$。\n$$\nA_n = \\left( \\frac{2A_0 \\sin(n\\pi p)}{p(n\\pi)^2} - \\frac{2A_0 \\cos(n\\pi p)}{n\\pi} \\right) + \\left( \\frac{2A_0 \\cos(n\\pi p)}{n\\pi} + \\frac{2A_0 \\sin(n\\pi p)}{(1-p)(n\\pi)^2} \\right)\n$$\n余弦项相互抵消，得到：\n$$\nA_n = \\frac{2A_0 \\sin(n\\pi p)}{(n\\pi)^2} \\left( \\frac{1}{p} + \\frac{1}{1-p} \\right) = \\frac{2A_0 \\sin(n\\pi p)}{(n\\pi)^2} \\left( \\frac{1-p+p}{p(1-p)} \\right)\n$$\n这可以化简为 $A_n$ 的最终闭式表达式：\n$$\nA_n = \\frac{2A_0 \\sin(n\\pi p)}{n^2\\pi^2 p(1-p)}\n$$\n在观测点 $x_\\mathrm{obs}$ 处模态 $n$ 的解析振幅，记为 $B_n^\\mathrm{(theory)}$，是级数展开中第 $n$ 项在 $t=0$ 时的幅值（因为如果我们只考虑时间包络，$\\cos(\\omega_n t)$ 在 $t=0$ 时达到最大值）：\n$$\nB_n^\\mathrm{(theory)} = \\left|A_n \\sin\\!\\left(\\frac{n\\pi x_\\mathrm{obs}}{L}\\right)\\right| = \\left| \\frac{2A_0 \\sin(n\\pi p)}{n^2\\pi^2 p(1-p)} \\sin\\!\\left(\\frac{n\\pi x_\\mathrm{obs}}{L}\\right) \\right|\n$$\n\n### 任务2：频谱分析的算法设计\n\n目标是选择数值参数 $\\Delta t$ 和 $T_\\mathrm{total}$，以便于将离散傅里叶变换（DFT）得到的数值频谱与解析模态频率进行直接比较。\n\n解析模态频率为 $f_n = n \\frac{c}{2L}$（其中 $n=1, 2, \\dots$）。基频为 $f_1 = c/(2L)$，相应周期为 $T_1 = 1/f_1 = 2L/c$。\n\n对于总时长为 $T_\\mathrm{total}$ 的时间序列，其DFT的频率分辨率为 $\\Delta f = 1/T_\\mathrm{total}$。对应于第 $k$ 个DFT频率仓（其中 $k$ 为整数索引）的频率是 $f^\\mathrm{(DFT)}_k = k \\cdot \\Delta f = k/T_\\mathrm{total}$。\n\n为确保解析频率 $f_n$ 与特定的DFT频率仓对齐，我们需要满足 $f_n = f^\\mathrm{(DFT)}_{k_n}$，其中 $k_n$是一组整数频率仓索引。\n$$\nn \\frac{c}{2L} = \\frac{k_n}{T_\\mathrm{total}} \\implies T_\\mathrm{total} = k_n \\frac{2L}{nc}\n$$\n为了使频率仓索引 $k_n$ 成为模态数 $n$ 的简单整数倍，我们可以设置 $k_n = n M$，其中 $M \\ge 1$ 是某个整数。这导致了对总模拟时间的选择：\n$$\nT_\\mathrm{total} = (nM) \\frac{2L}{nc} = M \\frac{2L}{c} = M T_1\n$$\n这种选择确保了模拟运行时长为整数个（$M$个）基频周期。在此 $T_\\mathrm{total}$ 下，第 $n$ 个模态的频率 $f_n = n \\frac{c}{2L}$ 对应于DFT频率仓的频率 $f^\\mathrm{(DFT)}_{nM} = (nM) / T_\\mathrm{total} = (nM) / (M \\frac{2L}{c}) = n \\frac{c}{2L} = f_n$。因此，第 $n$ 个模态的振幅可以从DFT的频率仓索引 $k_n = nM$ 处提取。\n\n问题指定使用 Courant–Friedrichs–Lewy (CFL) 数 $\\lambda = \\frac{c\\Delta t}{\\Delta x} = 1$。对于显式格式，该值处于稳定性极限；对于一维波动方程，它在网格上提供了精确解（d'Alembert解）。这一选择决定了时间步长：\n$$\n\\Delta t = \\frac{\\Delta x}{c} = \\frac{L/(N_x-1)}{c} = \\frac{L}{c(N_x-1)}\n$$\n模拟所需的总时间步数 $N_t$ 则确定为：\n$$\nN_t = \\left\\lfloor \\frac{T_\\mathrm{total}}{\\Delta t} \\right\\rfloor = \\left\\lfloor \\frac{M \\frac{2L}{c}}{\\frac{L}{c(N_x-1)}} \\right\\rfloor = \\lfloor 2M(N_x-1) \\rfloor = 2M(N_x-1)\n$$\n由于 $M$ 和 $N_x$ 是整数，向下取整操作并非严格必需。\n\n### 任务3：实现与比较\n\n实现步骤如下：\n1.  **网格与参数设置：** 对于每个测试用例，定义 $L, c, A_0, N_x, p, x_\\mathrm{obs}, M, K$。根据这些参数计算 $\\Delta x = L/(N_x-1)$，$\\Delta t = \\Delta x/c$ 和 $N_t = 2M(N_x-1)$。空间网格为 $x_j = j\\Delta x$（其中 $j=0, \\dots, N_x-1$）。观测点 $x_\\mathrm{obs}$ 映射到最近的网格索引 $j_\\mathrm{obs}$。\n\n2.  **理论振幅：** 计算一个长度为 $K$ 的向量 $B^\\mathrm{(theory)}$。对于每个模态 $n=1,\\dots,K$，其元素 $B_n^\\mathrm{(theory)}$ 使用任务1中推导的公式计算。\n\n3.  **初始化：**\n    *   在时间 $n=0$ 时的解 $u_j^0$ 根据分段函数 $u_0(x_j)$ 在网格上进行初始化。\n    *   在时间 $n=1$ 时的解 $u_j^1$ 使用二阶精度启动格式计算：$u_j^1 = u_j^0 + \\frac{1}{2}\\lambda^2 (u_{j+1}^0 - 2 u_j^0 + u_{j-1}^0)$。由于我们设置了 $\\lambda=1$，该式变为 $u_j^1 = u_j^0 + \\frac{1}{2} (u_{j+1}^0 - 2 u_j^0 + u_{j-1}^0)$。对所有 $n$，施加边界条件 $u_0^n = u_{N_x-1}^n = 0$。\n\n4.  **时间演化：** 将解在时间上推进，其中 $n=1, 2, \\dots, N_t-1$。内部点（$j=1, \\dots, N_x-2$）的更新规则为：\n    $$\n    u_j^{n+1} = 2 u_j^n - u_j^{n-1} + \\lambda^2 (u_{j+1}^n - 2 u_j^n + u_{j-1}^n)\n    $$\n    当 $\\lambda=1$ 时，该式可大幅简化为：\n    $$\n    u_j^{n+1} = u_{j+1}^n + u_{j-1}^n - u_j^{n-1}\n    $$\n    在每个时间步 $n$，将观测点处的解的值 $u_{j_\\mathrm{obs}}^n$ 存储在一个时间序列数组中。\n\n5.  **频谱分析：**\n    *   计算所记录时间序列的DFT。\n    *   DFT通常是复数值。模态 $n$ 的数值谱振幅 $B_n^\\mathrm{(num)}$ 从DFT在频率仓索引 $k_n = nM$ 处的幅值中提取。需要一个归一化因子。对于长度为 $N_t$ 的实信号，正弦分量的振幅由 $2|\\mathrm{DFT}[k]|/N_t$ 给出。因此，$B_n^\\mathrm{(num)} = \\frac{2}{N_t} |\\mathrm{DFT}[nM]|$。构建一个长度为 $K$ 的向量 $B^\\mathrm{(num)}$。\n\n6.  **归一化与误差计算：**\n    *   将向量 $B^\\mathrm{(theory)}$ 和 $B^\\mathrm{(num)}$ 分别除以其各自的最大元素进行归一化。记归一化后的向量为 $\\hat{B}^\\mathrm{(theory)}$ 和 $\\hat{B}^\\mathrm{(num)}$。\n    *   误差度量 $E$ 计算为这些归一化向量之间的平均绝对差：\n    $$\n    E = \\frac{1}{K}\\sum_{n=1}^K \\left| \\hat{B}_n^\\mathrm{(num)} - \\hat{B}_n^\\mathrm{(theory)} \\right|\n    $$\n对所提供的三个测试用例中的每一个重复此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D wave equation using a finite difference method and compares\n    the numerical frequency spectrum to the analytical solution for three test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: center pluck, odd-harmonic dominance\n        {'L': 1.0, 'c': 1.0, 'A0': 1.0, 'Nx': 129, 'p': 0.5, 'x_obs': 0.31, 'M': 32, 'K': 8},\n        # Case 2: off-center pluck, mixed harmonics\n        {'L': 1.0, 'c': 2.0, 'A0': 1.0, 'Nx': 129, 'p': 0.3, 'x_obs': 0.37, 'M': 32, 'K': 10},\n        # Case 3: near-end pluck, stronger high-frequency content\n        {'L': 1.0, 'c': 1.5, 'A0': 1.0, 'Nx': 257, 'p': 0.1, 'x_obs': 0.83, 'M': 16, 'K': 12},\n    ]\n\n    results = []\n    for case in test_cases:\n        # Extract parameters for the current case\n        L = case['L']\n        c = case['c']\n        A0 = case['A0']\n        Nx = case['Nx']\n        p = case['p']\n        x_obs = case['x_obs']\n        M = case['M']\n        K = case['K']\n\n        # --- Task 1: Theoretical Amplitudes ---\n        n_modes = np.arange(1, K + 1)\n        \n        # Derived formula for An\n        # An = (2 * A0 * sin(n*pi*p)) / ( (n*pi)^2 * p * (1-p) )\n        numerator = 2 * A0 * np.sin(n_modes * np.pi * p)\n        denominator = (n_modes * np.pi)**2 * p * (1 - p)\n        # Handle cases where sin(n*pi*p) is zero, to avoid 0/0 if p makes denominator zero\n        An = np.divide(numerator, denominator, out=np.zeros_like(numerator), where=denominator!=0)\n\n        # Theoretical amplitude at observation point\n        B_theory = np.abs(An * np.sin(n_modes * np.pi * x_obs / L))\n        \n        # --- Task 2  3: Numerical Simulation and Comparison ---\n        \n        # Grid and time parameters\n        dx = L / (Nx - 1)\n        # CFL lambda = 1 is specified\n        dt = dx / c\n        # Total simulation time T_total = M * 2*L/c\n        # Total number of time steps Nt = T_total / dt\n        Nt = 2 * M * (Nx - 1)\n        \n        x_grid = np.linspace(0, L, Nx)\n        j_obs = np.argmin(np.abs(x_grid - x_obs))\n\n        # Initial condition u(x,0)\n        u0 = np.zeros(Nx)\n        pluck_pos = p * L\n        mask1 = x_grid = pluck_pos\n        mask2 = x_grid > pluck_pos\n        \n        # Apply piecewise definition\n        u0[mask1] = (A0 / pluck_pos) * x_grid[mask1] if p > 0 else 0\n        u0[mask2] = (A0 / (L - pluck_pos)) * (L - x_grid[mask2]) if (1-p) > 0 else 0\n\n        # Initial condition for the first time step u(x, dt)\n        # using u_j^1 = u_j^0 + 0.5 * lambda^2 * (u_{j+1}^0 - 2*u_j^0 + u_{j-1}^0)\n        # for lambda = 1\n        u1 = u0.copy()\n        u1[1:-1] = u0[1:-1] + 0.5 * (u0[2:] - 2*u0[1:-1] + u0[:-2])\n        # Boundaries are fixed at 0, which is naturally handled.\n\n        # Time evolution\n        u_prev = u0.copy()\n        u_curr = u1.copy()\n        time_series = np.zeros(Nt)\n        time_series[0] = u_prev[j_obs]\n        time_series[1] = u_curr[j_obs]\n\n        # FDM loop with lambda=1 simplified update rule\n        # u_j^{n+1} = u_{j+1}^n + u_{j-1}^n - u_j^{n-1}\n        for n in range(1, Nt - 1):\n            u_next = np.zeros(Nx)\n            u_next[1:-1] = u_curr[2:] + u_curr[:-2] - u_prev[1:-1]\n            u_prev, u_curr = u_curr, u_next\n            time_series[n + 1] = u_curr[j_obs]\n\n        # Spectral analysis of the numerical result\n        dft_result = np.fft.fft(time_series)\n        k_indices = n_modes * M\n        \n        # DFT amplitude normalization for a real signal\n        B_num = (2.0 / Nt) * np.abs(dft_result[k_indices])\n\n        # Normalization and error calculation\n        max_B_theory = np.max(B_theory)\n        if max_B_theory > 0:\n            B_theory_norm = B_theory / max_B_theory\n        else: # Handle case where all theoretical values are zero\n            B_theory_norm = B_theory\n            \n        max_B_num = np.max(B_num)\n        if max_B_num > 0:\n            B_num_norm = B_num / max_B_num\n        else: # Handle case where all numerical values are zero\n            B_num_norm = B_num\n\n        error = np.mean(np.abs(B_num_norm - B_theory_norm))\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}