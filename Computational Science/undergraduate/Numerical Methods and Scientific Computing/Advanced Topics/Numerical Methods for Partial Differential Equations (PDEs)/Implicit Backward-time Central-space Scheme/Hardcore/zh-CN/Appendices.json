{
    "hands_on_practices": [
        {
            "introduction": "在相信任何数值模拟的结果之前，我们必须验证我们的代码是正确的。本练习介绍了一种强大的验证技术，称为“人造解法”（Method of Manufactured Solutions）。我们首先构建一个已知的解析解，将其代入偏微分方程以得到一个对应的源项，然后用我们的数值格式求解这个带源项的方程，并验证其数值解是否以理论预期的收敛阶数趋近于我们的人造解。通过这个实践，你将学习如何严格地调试代码，并验证你的BTCS实现是否真正达到了理论上的时间一阶($O(\\Delta t)$)和空间二阶($O((\\Delta x)^2)$)精度。",
            "id": "3241236",
            "problem": "考虑定义在空间区间 $[0,1]$ 和时间区间 $[0,T]$ 上的一维热传导模型，\n$$\n\\frac{\\partial u}{\\partial t}(x,t) \\;=\\; \\alpha \\,\\frac{\\partial^2 u}{\\partial x^2}(x,t) \\;+\\; f(x,t),\n$$\n其狄利克雷边界条件为 $u(0,t)=0$ 和 $u(1,t)=0$ (对于所有 $t \\in [0,T]$)，初始条件为 $u(x,0)=\\sin(\\pi x)$。使用制造解方法验证隐式后向时间中心空间（BTCS）格式的准确性，该格式通常称为后向时间中心空间（BTCS）格式。\n\n您将从以下基本概念出发：\n- 热方程和中心有限差分的定义：对于一个足够光滑的函数 $u$，其空间二阶导数可近似为\n$$\n\\frac{\\partial^2 u}{\\partial x^2}(x_i,t) \\approx \\frac{u(x_{i-1},t) - 2u(x_i,t) + u(x_{i+1},t)}{(\\Delta x)^2},\n$$\n后向欧拉时间导数可近似为\n$$\n\\frac{\\partial u}{\\partial t}(x_i,t_{n+1}) \\approx \\frac{u(x_i,t_{n+1}) - u(x_i,t_n)}{\\Delta t}.\n$$\n- 制造解方法：选择一个光滑函数 $\\tilde{u}(x,t)$，将其代入偏微分方程，并定义 $f(x,t)$，使得 $\\tilde{u}(x,t)$ 成为该强迫问题的精确解。\n\n任务：\n1. 选择制造解 $\\tilde{u}(x,t)=e^{t}\\sin(\\pi x)$，并利用微积分推导出相应的源项 $f(x,t)$，使得 $\\tilde{u}(x,t)$ 精确满足该模型方程。\n2. 用网格点 $x_i = i\\,\\Delta x$（其中 $i=0,1,\\dots,N_x-1$，$ \\Delta x = 1/(N_x-1)$）离散化空间域，用时间层 $t_n = n\\,\\Delta t$（其中 $n=0,1,\\dots,N_t$）离散化时间域。施加狄利克雷边界条件 $u_0^n = 0$ 和 $u_{N_x-1}^n=0$（对于所有 $n$），以及初始条件 $u_i^0 = \\sin(\\pi x_i)$（对于 $i=1,\\dots,N_x-2$）。\n3. 结合后向欧拉时间近似和中心空间近似，并使用在时间 $t_{n+1}$ 处计算的源项 $f$，为内部节点 $i=1,\\dots,N_x-2$ 在每个时间步 $t_{n+1}$ 推导并实现 BTCS 线性系统。\n4. 通过在每个时间步求解得到的三对角线性系统，将解从 $t=0$推进到 $t=T$。通过将数值解 $u_i^{N_t}$ 与精确解 $\\tilde{u}(x_i,T)$ 进行比较，使用离散 $L^2$ 范数计算最终时间 $t=T$ 处的误差\n$$\nE_{L^2} \\;=\\; \\left(\\Delta x\\sum_{i=1}^{N_x-2}\\left(u_i^{N_t}-\\tilde{u}(x_i,T)\\right)^2\\right)^{1/2}\n$$\n以及离散 $L^\\infty$ 范数\n$$\nE_{L^\\infty} \\;=\\; \\max_{1\\le i \\le N_x-2}\\left|u_i^{N_t}-\\tilde{u}(x_i,T)\\right|.\n$$\n\n经验收敛性验证：\n- 为验证时间精度阶 $O(\\Delta t)$，使用非常密集的空间网格使空间误差可以忽略不计，并进行时间加密研究。固定 $\\alpha=0.1$，设置 $T=0.2$，选择 $N_x=1001$，并针对四个时间步数 $N_t\\in\\{10,20,40,80\\}$（对应 $\\Delta t\\in\\{0.02,0.01,0.005,0.0025\\}$）运行 BTCS 格式。对于每次运行，计算在 $t=T$ 时的 $E_{L^2}$。通过最小二乘法对 $(\\log(\\Delta t),\\log(E_{L^2}))$ 进行线性拟合，并取其斜率来估计观测到的时间收敛阶 $p_t$。\n- 为验证空间精度阶 $O((\\Delta x)^2)$，使用非常小的时间步长使时间误差可以忽略不计，并进行空间加密研究。固定 $\\alpha=0.1$，设置 $T=0.01$，选择 $N_t=1000$（因此 $\\Delta t=0.00001$），并针对 $N_x\\in\\{33,65,129,257\\}$（对应于每次加密空间步长减半）运行 BTCS 格式。对于每次运行，计算在 $t=T$ 时的 $E_{L^2}$。通过最小二乘法对 $(\\log(\\Delta x),\\log(E_{L^2}))$ 进行线性拟合，并取其斜率来估计观测到的空间收敛阶 $p_x$。\n- 极端情况鲁棒性检查：使用非常粗糙的网格进行测试，以确保线性系统组装和边界处理是正确的。固定 $\\alpha=0.1$，设置 $T=0.1$，选择 $N_x=5$ 和 $N_t=5$（因此 $\\Delta t=0.02$）。计算最终时间的离散无穷范数误差 $E_{L^\\infty}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，顺序必须为 $[p_t,p_x,E_{L^\\infty}]$。所有三个条目都必须是实数。不应打印任何其他文本。\n\n测试套件摘要：\n- 时间加密（预期为 $O(\\Delta t)$）：$\\alpha=0.1$，$T=0.2$，$N_x=1001$，$N_t\\in\\{10,20,40,80\\}$。\n- 空间加密（预期为 $O((\\Delta x)^2)$）：$\\alpha=0.1$，$T=0.01$，$N_t=1000$，$N_x\\in\\{33,65,129,257\\}$。\n- 极端情况：$\\alpha=0.1$，$T=0.1$，$N_x=5$，$N_t=5$。\n\n所有量均为无量纲；不需要物理单位。",
            "solution": "该问题要求使用制造解方法，对一维热方程的后向时间中心空间（BTCS）格式进行推导、实现和验证。解决方案分为四个部分：解析源项的推导、离散数值格式的推导、经验验证过程的概述以及算法的总结。\n\n**步骤 1：源项的推导**\n\n采用制造解方法来创建一个具有已知解析解的问题，该解可作为验证数值代码的基准。控制偏微分方程（PDE）为：\n$$\n\\frac{\\partial u}{\\partial t}(x,t) \\;=\\; \\alpha \\,\\frac{\\partial^2 u}{\\partial x^2}(x,t) \\;+\\; f(x,t)\n$$\n我们选择制造解 $\\tilde{u}(x,t) = e^{t}\\sin(\\pi x)$。该函数满足边界条件 $u(0,t)=e^t\\sin(0)=0$ 和 $u(1,t)=e^t\\sin(\\pi)=0$，以及初始条件 $u(x,0)=e^0\\sin(\\pi x)=\\sin(\\pi x)$。为了找到对应的源项 $f(x,t)$，我们计算 $\\tilde{u}(x,t)$ 的偏导数：\n时间导数为：\n$$\n\\frac{\\partial \\tilde{u}}{\\partial t} = \\frac{\\partial}{\\partial t} \\left( e^t \\sin(\\pi x) \\right) = e^t \\sin(\\pi x)\n$$\n空间二阶导数为：\n$$\n\\frac{\\partial^2 \\tilde{u}}{\\partial x^2} = \\frac{\\partial^2}{\\partial x^2} \\left( e^t \\sin(\\pi x) \\right) = \\frac{\\partial}{\\partial x} \\left( \\pi e^t \\cos(\\pi x) \\right) = -\\pi^2 e^t \\sin(\\pi x)\n$$\n将这些导数代入 PDE，即可解出 $f(x,t)$：\n$$\ne^t \\sin(\\pi x) = \\alpha \\left( -\\pi^2 e^t \\sin(\\pi x) \\right) + f(x,t)\n$$\n$$\nf(x,t) = e^t \\sin(\\pi x) + \\alpha \\pi^2 e^t \\sin(\\pi x) = (1 + \\alpha \\pi^2)e^t \\sin(\\pi x)\n$$\n这个推导出的源项确保了 $\\tilde{u}(x,t)$ 是该问题的精确解。\n\n**步骤 2：BTCS 离散化的推导**\n\nBTCS 格式通过在具有空间点 $x_i = i\\Delta x$ 和时间层 $t_n = n\\Delta t$ 的网格上离散化 PDE 来构建。我们使用一阶后向欧拉差分来近似时间导数，使用二阶中心差分来近似空间导数，两者都在未来的时间层 $t_{n+1}$ 进行计算：\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} \\approx \\alpha \\left( \\frac{u_{i-1}^{n+1} - 2u_i^{n+1} + u_{i+1}^{n+1}}{(\\Delta x)^2} \\right) + f(x_i, t_{n+1})\n$$\n其中 $u_i^n \\approx u(x_i, t_n)$。该格式是隐式的，因为它耦合了时间层 $n+1$ 上的多个未知值。为了求解它，我们将方程重排成一个线性系统。令 $c = \\frac{\\alpha \\Delta t}{(\\Delta x)^2}$ 为扩散数。我们将所有未知项（在时间 $n+1$）放在左侧（LHS），将已知项（在时间 $n$）放在右侧（RHS）：\n$$\nu_i^{n+1} - c (u_{i-1}^{n+1} - 2u_i^{n+1} + u_{i+1}^{n+1}) = u_i^n + \\Delta t f_i^{n+1}\n$$\n$$\n-c u_{i-1}^{n+1} + (1 + 2c)u_i^{n+1} - c u_{i+1}^{n+1} = u_i^n + \\Delta t f_i^{n+1}\n$$\n该方程对所有内部网格点 $i = 1, 2, \\dots, N_x-2$ 均有效。给定狄利克雷边界条件 $u_0^{n+1}=0$ 和 $u_{N_x-1}^{n+1}=0$，这些方程构成了一个关于内部未知量向量 $\\mathbf{u}^{n+1} = [u_1^{n+1}, \\dots, u_{N_x-2}^{n+1}]^T$ 的三对角线性系统 $A \\mathbf{u}^{n+1} = \\mathbf{b}^n$。这个 $(N_x-2) \\times (N_x-2)$ 的矩阵 $A$ 是：\n$$\nA = \\begin{pmatrix}\n1+2c  -c  0  \\dots  0 \\\\\n-c  1+2c  -c  \\dots  0 \\\\\n0  \\ddots  \\ddots  \\ddots  0 \\\\\n\\vdots  \\ddots  -c  1+2c  -c \\\\\n0  \\dots  0  -c  1+2c\n\\end{pmatrix}\n$$\n右侧向量 $\\mathbf{b}^n$ 取决于前一个时间步 $n$ 的解和时间步 $n+1$ 的源项。在每个时间步，都必须求解该系统以找到下一个时间层的解。\n\n**步骤 3：经验收敛性验证**\n\nBTCS 格式的理论精度在时间上是 $O(\\Delta t)$，在空间上是 $O((\\Delta x)^2)$。总误差 $E$ 近似为 $E \\approx C_t (\\Delta t)^{p_t} + C_x (\\Delta x)^{p_x}$，其中收敛阶 $p_t=1$ 且 $p_x=2$。\n为了经验性地测量 $p_t$，我们进行时间加密研究。通过使用一个非常密集的空间网格（$N_x=1001$），空间误差项 $C_x (\\Delta x)^2$ 变得可以忽略不计。此时误差主要由时间离散化决定，$E \\approx C_t (\\Delta t)^{p_t}$。取对数得到 $\\log(E) \\approx \\log(C_t) + p_t \\log(\\Delta t)$。收敛阶 $p_t$ 是对 $(\\log(\\Delta t), \\log(E))$ 数据点进行线性拟合后得到的直线的斜率。\n类似地，为了测量 $p_x$，我们进行空间加密研究。通过使用一个非常小的时间步长（$N_t=1000$），时间误差项 $C_t (\\Delta t)^{p_t}$ 变得可以忽略不计，因此 $E \\approx C_x (\\Delta x)^{p_x}$。收敛阶 $p_x$ 则是对 $(\\log(\\Delta x), \\log(E))$ 数据进行线性拟合后得到的直线的斜率。\n\n**步骤 4：算法实现**\n\n数值解的计算过程如下：\n1.  初始化参数 $\\alpha$、$T$、$N_x$、$N_t$，并计算网格间距 $\\Delta x$ 和 $\\Delta t$。\n2.  设置空间网格 $x$，并使用初始条件 $u(x,0)=\\sin(\\pi x)$ 初始化解向量 $u$。\n3.  根据给定参数构建常数三对角矩阵 $A$。\n4.  从 $n=0$ 迭代到 $N_t-1$。在每次迭代中：\n    a. 计算下一个时间层 $t_{n+1}$。\n    b. 使用上一步的解 $u^n$ 和源项 $f(x,t_{n+1})$ 来组装右侧向量 $\\mathbf{b}^n$。\n    c. 求解线性系统 $A \\mathbf{u}^{n+1} = \\mathbf{b}^n$，以获得下一个时间步的内部点的解。\n    d. 更新完整的解向量，同时保持边界值为 $0$。\n5.  循环结束后，通过将最终数值解与精确的制造解进行比较，按要求使用 $L^2$ 或 $L^\\infty$ 范数计算在 $t=T$ 时的最终误差。\n6.  对于收敛性研究，对每组加密参数重复此过程，收集误差，并对对数-对数数据执行线性最小二乘拟合，以找到斜率 $p_t$ 和 $p_x$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_btcs_and_get_error(alpha, T, Nx, Nt, error_norm_type):\n    \"\"\"\n    Runs the BTCS simulation for the 1D heat equation with a source term\n    and returns the specified error norm against the manufactured solution.\n\n    Args:\n        alpha (float): Thermal diffusivity constant.\n        T (float): Final time.\n        Nx (int): Number of spatial grid points.\n        Nt (int): Number of time steps.\n        error_norm_type (str): Type of error norm to compute ('L2' or 'L_inf').\n\n    Returns:\n        float: The computed error value.\n    \"\"\"\n    # Define the manufactured solution and the corresponding source term\n    def u_exact(x, t):\n        return np.exp(t) * np.sin(np.pi * x)\n\n    def f_source(x, t, alpha_val):\n        return (1.0 + alpha_val * np.pi**2) * np.exp(t) * np.sin(np.pi * x)\n\n    # Discretization parameters\n    dx = 1.0 / (Nx - 1)\n    dt = T / Nt\n    x = np.linspace(0, 1, Nx)\n    \n    # Grid for interior points\n    x_interior = x[1:-1]\n    M = Nx - 2  # Number of interior points\n\n    # Diffusion number\n    c = alpha * dt / (dx**2)\n\n    # Initial condition. The vector u_current includes boundary points.\n    u_current = u_exact(x, 0.0)\n    \n    # Construct the tridiagonal matrix A for a single time step.\n    # The matrix is constant for fixed parameters.\n    A = np.zeros((M, M))\n    np.fill_diagonal(A, 1.0 + 2.0 * c)\n    np.fill_diagonal(A[1:], -c)\n    np.fill_diagonal(A[:, 1:], -c)\n\n    # Time-stepping loop\n    for n in range(Nt):\n        t_next = (n + 1) * dt\n        \n        # Get the solution at interior points from the previous time step\n        u_current_interior = u_current[1:-1]\n        \n        # Construct the RHS vector b = u_current_interior + dt * f(t_next)\n        f_vec = f_source(x_interior, t_next, alpha)\n        b = u_current_interior + dt * f_vec\n        \n        # Dirichlet boundary conditions u(0,t)=0 and u(1,t)=0 are handled implicitly\n        # because the terms involving u_0 and u_{Nx-1} are zero and do not\n        # contribute to the RHS vector for the interior problem.\n        \n        # Solve the linear system A * u_next_interior = b\n        u_next_interior = np.linalg.solve(A, b)\n        \n        # Update solution vector for the next time step. Boundaries remain zero.\n        u_current[1:-1] = u_next_interior\n        \n    # At t=T, u_current holds the final numerical solution\n    u_numerical_final = u_current\n    \n    # Calculate the exact solution at the final time T\n    u_exact_final = u_exact(x, T)\n\n    # Calculate the error vector at interior points\n    error_vec = u_numerical_final[1:-1] - u_exact_final[1:-1]\n    \n    # Compute the requested error norm\n    if error_norm_type == 'L2':\n        error_val = np.sqrt(dx * np.sum(error_vec**2))\n    elif error_norm_type == 'L_inf':\n        error_val = np.max(np.abs(error_vec))\n    else:\n        raise ValueError(\"Invalid error_norm_type specified.\")\n        \n    return error_val\n\ndef solve():\n    \"\"\"\n    Performs the three specified tasks: time refinement, space refinement,\n    and an edge case test, printing the results in the required format.\n    \"\"\"\n    # --- Task 1: Time refinement study to find p_t ---\n    alpha_t = 0.1\n    T_t = 0.2\n    Nx_t = 1001\n    Nt_t_vals = [10, 20, 40, 80]\n    \n    dt_vals = [T_t / N for N in Nt_t_vals]\n    errors_t = []\n    for Nt_t in Nt_t_vals:\n        error = run_btcs_and_get_error(alpha_t, T_t, Nx_t, Nt_t, 'L2')\n        errors_t.append(error)\n        \n    # Fit a line to (log(dt), log(error)) to find the convergence order p_t\n    log_dt = np.log(dt_vals)\n    log_errors_t = np.log(errors_t)\n    p_t = np.polyfit(log_dt, log_errors_t, 1)[0]\n\n    # --- Task 2: Spatial refinement study to find p_x ---\n    alpha_x = 0.1\n    T_x = 0.01\n    Nt_x = 1000\n    Nx_x_vals = [33, 65, 129, 257]\n    \n    dx_vals = [1.0 / (N - 1) for N in Nx_x_vals]\n    errors_x = []\n    for Nx_x in Nx_x_vals:\n        error = run_btcs_and_get_error(alpha_x, T_x, Nx_x, Nt_x, 'L2')\n        errors_x.append(error)\n        \n    # Fit a line to (log(dx), log(error)) to find the convergence order p_x\n    log_dx = np.log(dx_vals)\n    log_errors_x = np.log(errors_x)\n    p_x = np.polyfit(log_dx, log_errors_x, 1)[0]\n\n    # --- Task 3: Edge case robustness check ---\n    alpha_e = 0.1\n    T_e = 0.1\n    Nx_e = 5\n    Nt_e = 5\n    E_Linf = run_btcs_and_get_error(alpha_e, T_e, Nx_e, Nt_e, 'L_inf')\n\n    # Final print statement in the exact required format\n    print(f\"[{p_t},{p_x},{E_Linf}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在验证了基本求解器的正确性之后，下一步是使其能够处理更贴近实际的物理问题。真实世界的问题通常涉及不同类型的边界条件，例如指定温度（Dirichlet条件）或指定热流（Neumann条件）。这个练习将指导你如何在一个BTCS求解器中灵活地处理这两种边界条件。你需要为边界上的节点推导并实现正确的离散方程，从而构建一个更通用、更强大的模拟工具，为解决传热学、流体力学等领域的实际问题打下坚实基础。",
            "id": "3241116",
            "problem": "您需要设计并实现一个程序，该程序使用隐式向后时间中心空间（BTCS）格式求解一维扩散方程，并能通过配置对象灵活切换任一边界上的狄利克雷（Dirichlet）和诺伊曼（Neumann）边界条件。其控制偏微分方程是在有界区间上的线性抛物线模型，\n$$\n\\frac{\\partial u}{\\partial t}(x,t) = \\alpha \\frac{\\partial^2 u}{\\partial x^2}(x,t), \\quad x \\in [0,L], \\ t \\in (0,T],\n$$\n其中 $u=u(x,t)$ 是我们关注的标量场，$\\alpha0$ 是扩散系数。初始条件为\n$$\nu(x,0)=u_0(x), \\quad x \\in [0,L],\n$$\n并且在 $x=0$ 和 $x=L$ 的每个边界上独立地满足狄利克雷条件，\n$$\nu(0,t)=g_L(t) \\ \\text{or} \\ u(L,t)=g_R(t),\n$$\n或诺伊曼条件，\n$$\n\\frac{\\partial u}{\\partial x}(0,t)=q_L(t) \\ \\text{or} \\ \\frac{\\partial u}{\\partial x}(L,t)=q_R(t).\n$$\n您的离散化必须从以下基本原则出发：(i) 在步长为 $\\Delta t$ 的均匀时间网格上，将时间导数定义为时间上的向后差分；(ii) 在网格间距为 $\\Delta x$ 的均匀空间网格上，将空间二阶导数定义为中心二阶差分；以及 (iii) 狄利克雷和诺伊曼边界条件的精确含义。您可以假定解具有足够的光滑性以保证二阶空间精度和一阶时间精度。请勿假设或使用任何不能从这些基本原则推导出的公式。\n\n您必须推导并实现一个全隐式格式，该格式在内部网格点上与时间向后差分和空间中心差分一致。在边界上，以与内部离散化精度阶数一致的方式施加狄利克雷或诺伊曼条件，且在最终的线性系统中不引入虚拟未知数。您的推导必须清晰地展示边界方程与内部方程的不同之处，以及边界数据 $g_L(t)$、$g_R(t)$、$q_L(t)$、$q_R(t)$ 如何进入右端项。在 $[0,L]$ 上使用包含 $M$ 个节点的均匀空间网格（即 $M$ 包括两个边界节点），使得 $\\Delta x = L/(M-1)$。使用均匀的时间步长 $\\Delta t$，从时间 $t^n=n\\Delta t$推进到 $t^{n+1}=(n+1)\\Delta t$。\n\n您的程序必须：\n- 每个时间步为 $t^{n+1}$ 时刻的所有节点未知数向量构建一个单一的线性系统，其系数由 BTCS 离散化以及左右两端的边界条件类型确定。\n- 允许任一边界为狄利克雷或诺伊曼条件，并使用在 $t^{n+1}$ 时刻计算的相应数据函数 $g_L(t)$、$g_R(t)$、$q_L(t)$、$q_R(t)$。\n- 接受一个类配置的数据结构（硬编码在程序中；不允许使用文件或外部输入），用于指定 $L$、$\\alpha$、$M$、$\\Delta t$、$T$、边界条件类型和数据，以及初始条件函数 $u_0(x)$。\n- 为了验证，请使用构造的精确解 $u_{\\text{exact}}(x,t)$，该精确解在所有 $t\\in[0,T]$ 上同时满足内部方程和所选的边界条件。使用 $u_0(x)=u_{\\text{exact}}(x,0)$ 进行初始化。\n\n测试套件。实现并运行以下五个测试案例，每个案例由程序内部的配置对象指定。在每个案例中，除非另有说明，否则扩散系数 $\\alpha=1$。报告在最终时间 $T$ 时，数值解与精确解在所有网格节点上的最大绝对误差。这五个案例是：\n- 案例1（狄利克雷-狄利克雷，齐次，正弦模态）：$L=\\pi$, $M=101$, $\\Delta t=5\\times 10^{-4}$, $T=5\\times 10^{-2}$，左边界为狄利克雷条件，$g_L(t)=0$；右边界为狄利克雷条件，$g_R(t)=0$；精确解为 $u_{\\text{exact}}(x,t)=\\exp(-\\alpha \\lambda^2 t)\\sin(\\lambda x)$，其中 $\\lambda=1$。\n- 案例2（诺伊曼-诺伊曼，齐次，余弦模态）：$L=\\pi$, $M=101$, $\\Delta t=5\\times 10^{-4}$, $T=5\\times 10^{-2}$，左边界为诺伊曼条件，$q_L(t)=0$；右边界为诺伊曼条件，$q_R(t)=0$；精确解为 $u_{\\text{exact}}(x,t)=\\exp(-\\alpha \\lambda^2 t)\\cos(\\lambda x)$，其中 $\\lambda=1$。\n- 案例3（狄利克雷-诺伊曼，齐次，半整数正弦模态）：$L=\\pi$, $M=101$, $\\Delta t=5\\times 10^{-4}$, $T=5\\times 10^{-2}$，左边界为狄利克雷条件，$g_L(t)=0$；右边界为诺伊曼条件，$q_R(t)=0$；精确解为 $u_{\\text{exact}}(x,t)=\\exp(-\\alpha \\lambda^2 t)\\sin(\\lambda x)$，其中 $\\lambda=\\tfrac{1}{2}$。\n- 案例4（诺伊曼-狄利克雷，齐次，半整数余弦模态）：$L=\\pi$, $M=101$, $\\Delta t=5\\times 10^{-4}$, $T=5\\times 10^{-2}$，左边界为诺伊曼条件，$q_L(t)=0$；右边界为狄利克雷条件，$g_R(t)=0$；精确解为 $u_{\\text{exact}}(x,t)=\\exp(-\\alpha \\lambda^2 t)\\cos(\\lambda x)$，其中 $\\lambda=\\tfrac{1}{2}$。\n- 案例5（稳态线性解，混合非齐次）：$L=1$, $M=51$, $\\Delta t=10^{-2}$, $T=10^{-1}$，左边界为狄利克雷条件，$g_L(t)=2$；右边界为诺伊曼条件，$q_R(t)=-\\tfrac{3}{2}$；精确解为 $u_{\\text{exact}}(x,t)=ax+b$，其中 $a=-\\tfrac{3}{2}$ 且 $b=2$（与时间无关）。\n\n最终输出格式。您的程序应生成单行输出，其中包含五个案例中每个案例在时间 $T$ 时的最大绝对误差，格式为一个由方括号括起来的逗号分隔的十进制数列表，按案例1到5的顺序排列。例如，三个假设案例的输出将如下所示：\n$$\n[\\text{err}_1,\\text{err}_2,\\text{err}_3]\n$$\n但您的程序必须输出与上述五个案例相对应的五个条目。",
            "solution": "任务是为一维扩散方程 $\\frac{\\partial u}{\\partial t} = \\alpha \\frac{\\partial^2 u}{\\partial x^2}$ 在有界域 $x \\in [0,L]$ 上推导并实现隐式向后时间中心空间（BTCS）格式，并提供在两端选择狄利克雷或诺伊曼边界条件的选项。推导过程将按要求从基本原理出发。\n\n我们将空间域 $[0,L]$ 离散化为一个包含 $M$ 个节点的均匀网格，节点索引为 $i=0, 1, \\dots, M-1$。网格点为 $x_i = i\\Delta x$，其中网格间距为 $\\Delta x = L/(M-1)$。时间域以均匀步长 $\\Delta t$ 进行离散化，时间层级表示为 $t^n = n\\Delta t$。解 $u(x_i, t^n)$ 的数值近似值表示为 $u_i^n$。\n\nBTCS 格式的构建方法是：使用一阶向后有限差分逼近时间导数，并使用二阶中心有限差分逼近空间二阶导数，两者都在未来的时间层 $t^{n+1}$ 上进行计算。因此，控制偏微分方程（PDE）被离散化为：\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} = \\alpha \\frac{u_{i+1}^{n+1} - 2u_i^{n+1} + u_{i-1}^{n+1}}{(\\Delta x)^2}\n$$\n该方程建立了已知时间 $t^n$ 的解与未知时间 $t^{n+1}$ 的解之间的关系。\n\n我们定义无量纲参数 $s = \\frac{\\alpha \\Delta t}{(\\Delta x)^2}$。将离散方程重新整理，把未知项（在 $n+1$ 层）放在左端（LHS），已知项（在 $n$ 层）放在右端（RHS），得到内部节点 $i \\in \\{1, 2, \\dots, M-2\\}$ 的方程：\n$$\n-s u_{i-1}^{n+1} + (1+2s) u_i^{n+1} - s u_{i+1}^{n+1} = u_i^n\n$$\n这些方程为未知向量 $\\mathbf{u}^{n+1} = [u_0^{n+1}, u_1^{n+1}, \\dots, u_{M-1}^{n+1}]^T$ 构成了一个线性方程组。系统中第一个（$i=0$）和最后一个（$i=M-1$）方程的具体形式取决于边界条件。\n\n边界条件必须以与内部格式相一致的精度进行离散化，即空间二阶精度。我们现在将在不向最终线性系统中引入虚拟节点的情况下，推导每个边界的方程。\n\n**左边界（$x=0$，节点 $i=0$）**\n\n1.  **狄利克雷条件**：$u(0,t) = g_L(t)$。\n    该条件直接应用于新的时间层 $t^{n+1}$。未知数 $u_0^{n+1}$ 的值被明确给出：\n    $$\n    u_0^{n+1} = g_L(t^{n+1})\n    $$\n    这在线性系统的第一行中体现为 $1 \\cdot u_0^{n+1} = g_L(t^{n+1})$。\n\n2.  **诺伊曼条件**：$\\frac{\\partial u}{\\partial x}(0,t) = q_L(t)$。\n    为了达到二阶精度，我们围绕 $x_0$ 使用中心差分来近似空间导数。这需要一个位于 $x_{-1} = -\\Delta x$ 的“虚拟”节点。在 $t^{n+1}$ 时的导数近似为：\n    $$\n    \\frac{u_1^{n+1} - u_{-1}^{n+1}}{2\\Delta x} = q_L(t^{n+1})\n    $$\n    由此，我们可以将虚拟节点的值 $u_{-1}^{n+1}$ 表示为 $u_{-1}^{n+1} = u_1^{n+1} - 2\\Delta x q_L(t^{n+1})$。然后，我们在边界节点 $i=0$ 处应用通用的 PDE 离散格式：\n    $$\n    -s u_{-1}^{n+1} + (1+2s) u_0^{n+1} - s u_1^{n+1} = u_0^n\n    $$\n    代入 $u_{-1}^{n+1}$ 的表达式以消除虚拟节点：\n    $$\n    -s (u_1^{n+1} - 2\\Delta x q_L(t^{n+1})) + (1+2s) u_0^{n+1} - s u_1^{n+1} = u_0^n\n    $$\n    合并各项，得到系统第一行的最终方程：\n    $$\n    (1+2s) u_0^{n+1} - 2s u_1^{n+1} = u_0^n - 2s\\Delta x q_L(t^{n+1})\n    $$\n    注意到 $2s\\Delta x = 2 \\frac{\\alpha \\Delta t}{(\\Delta x)^2} \\Delta x = \\frac{2\\alpha\\Delta t}{\\Delta x}$，方程变为 $(1+2s) u_0^{n+1} - 2s u_1^{n+1} = u_0^n - \\frac{2\\alpha\\Delta t}{\\Delta x} q_L(t^{n+1})$。\n\n**右边界（$x=L$，节点 $i=M-1$）**\n\n1.  **狄利克雷条件**：$u(L,t) = g_R(t)$。\n    与左边界类似，在 $t^{n+1}$ 时的条件直接给出了 $u_{M-1}^{n+1}$ 的值：\n    $$\n    u_{M-1}^{n+1} = g_R(t^{n+1})\n    $$\n    这定义了线性系统的最后一行：$1 \\cdot u_{M-1}^{n+1} = g_R(t^{n+1})$。\n\n2.  **诺伊曼条件**：$\\frac{\\partial u}{\\partial x}(L,t) = q_R(t)$。\n    围绕 $x_{M-1}$ 使用中心差分需要一个位于 $x_M = L+\\Delta x$ 的虚拟节点：\n    $$\n    \\frac{u_M^{n+1} - u_{M-2}^{n+1}}{2\\Delta x} = q_R(t^{n+1})\n    $$\n    这给出了虚拟节点的值 $u_M^{n+1} = u_{M-2}^{n+1} + 2\\Delta x q_R(t^{n+1})$。在 $i=M-1$ 处应用 PDE 离散格式：\n    $$\n    -s u_{M-2}^{n+1} + (1+2s) u_{M-1}^{n+1} - s u_M^{n+1} = u_{M-1}^n\n    $$\n    代入 $u_M^{n+1}$ 的表达式：\n    $$\n    -s u_{M-2}^{n+1} + (1+2s) u_{M-1}^{n+1} - s (u_{M-2}^{n+1} + 2\\Delta x q_R(t^{n+1})) = u_{M-1}^n\n    $$\n    合并各项，得到系统最后一行的最终方程：\n    $$\n    -2s u_{M-2}^{n+1} + (1+2s) u_{M-1}^{n+1} = u_{M-1}^n + 2s\\Delta x q_R(t^{n+1})\n    $$\n    涉及边界数据的项为 $\\frac{2\\alpha\\Delta t}{\\Delta x} q_R(t^{n+1})$。\n\n**矩阵系统公式**\n\n在每个时间步，我们求解一个线性系统 $\\mathbf{A} \\mathbf{u}^{n+1} = \\mathbf{b}$ 来得到未知向量 $\\mathbf{u}^{n+1}$。矩阵 $\\mathbf{A}$ 和向量 $\\mathbf{b}$ 的构造如下：\n\n设 $s = \\frac{\\alpha \\Delta t}{(\\Delta x)^2}$。\n矩阵 $\\mathbf{A}$ 是一个 $M \\times M$ 的矩阵，$\\mathbf{b}$ 是一个大小为 $M$ 的向量。\n\n**内部行（$i = 1, \\dots, M-2$）：**\n-   $A_{i,i-1} = -s$\n-   $A_{i,i} = 1+2s$\n-   $A_{i,i+1} = -s$\n-   $b_i = u_i^n$\n\n**第一行（$i=0$）：**\n-   如果左边界是狄利克雷条件：$A_{0,0}=1$，所有其他 $A_{0,j}=0$。$b_0 = g_L(t^{n+1})$。\n-   如果左边界是诺伊曼条件：$A_{0,0}=1+2s$, $A_{0,1}=-2s$。$b_0 = u_0^n - \\frac{2\\alpha\\Delta t}{\\Delta x} q_L(t^{n+1})$。\n\n**最后一行（$i=M-1$）：**\n-   如果右边界是狄利克雷条件：$A_{M-1,M-1}=1$，所有其他 $A_{M-1,j}=0$。$b_{M-1} = g_R(t^{n+1})$。\n-   如果右边界是诺伊曼条件：$A_{M-1,M-2}=-2s$, $A_{M-1,M-1}=1+2s$。$b_{M-1} = u_{M-1}^n + \\frac{2\\alpha\\Delta t}{\\Delta x} q_R(t^{n+1})$。\n\n**总体算法：**\n\n1.  从测试案例配置中初始化参数。\n2.  设置空间网格 $x_i$，其中 $i=0, \\dots, M-1$。\n3.  使用 $u_i^0 = u_{\\text{exact}}(x_i, 0)$ 计算初始解向量 $\\mathbf{u}^0$。\n4.  从 $n=0$ 开始迭代时间步，直到达到最终时间 $T$。在每一步中：\n    a. 确定当前时间 $t^{n+1} = (n+1)\\Delta t$。\n    b. 根据指定的边界条件和上面推导的公式构造矩阵 $\\mathbf{A}$ 和向量 $\\mathbf{b}$。\n    c. 求解线性系统 $\\mathbf{A} \\mathbf{u}^{n+1} = \\mathbf{b}$ 以找到新时间层的解。\n    d. 更新解以进行下一次迭代：$\\mathbf{u}^n \\leftarrow \\mathbf{u}^{n+1}$。\n5.  在最后一个时间步之后，计算在时间 $T$ 时的精确解 $\\mathbf{u}_{\\text{exact}}$。\n6.  计算最终数值解与精确解之间的最大绝对误差：$\\max_i |u_i^{\\text{final}} - u_{\\text{exact}}(x_i, T)|$。\n对每个测试案例重复此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the BTCS diffusion solver.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Dirichlet-Dirichlet\n        {\n            \"L\": np.pi, \"alpha\": 1.0, \"M\": 101, \"dt\": 5e-4, \"T\": 5e-2,\n            \"bc_left_type\": \"dirichlet\", \"bc_right_type\": \"dirichlet\",\n            \"g_L\": lambda t: 0.0, \"g_R\": lambda t: 0.0,\n            \"q_L\": lambda t: 0.0, \"q_R\": lambda t: 0.0,\n            \"u_exact\": lambda x, t, alpha: np.exp(-alpha * 1**2 * t) * np.sin(1 * x)\n        },\n        # Case 2: Neumann-Neumann\n        {\n            \"L\": np.pi, \"alpha\": 1.0, \"M\": 101, \"dt\": 5e-4, \"T\": 5e-2,\n            \"bc_left_type\": \"neumann\", \"bc_right_type\": \"neumann\",\n            \"g_L\": lambda t: 0.0, \"g_R\": lambda t: 0.0,\n            \"q_L\": lambda t: 0.0, \"q_R\": lambda t: 0.0,\n            \"u_exact\": lambda x, t, alpha: np.exp(-alpha * 1**2 * t) * np.cos(1 * x)\n        },\n        # Case 3: Dirichlet-Neumann\n        {\n            \"L\": np.pi, \"alpha\": 1.0, \"M\": 101, \"dt\": 5e-4, \"T\": 5e-2,\n            \"bc_left_type\": \"dirichlet\", \"bc_right_type\": \"neumann\",\n            \"g_L\": lambda t: 0.0, \"g_R\": lambda t: 0.0,\n            \"q_L\": lambda t: 0.0, \"q_R\": lambda t: 0.0,\n            \"u_exact\": lambda x, t, alpha: np.exp(-alpha * 0.5**2 * t) * np.sin(0.5 * x)\n        },\n        # Case 4: Neumann-Dirichlet\n        {\n            \"L\": np.pi, \"alpha\": 1.0, \"M\": 101, \"dt\": 5e-4, \"T\": 5e-2,\n            \"bc_left_type\": \"neumann\", \"bc_right_type\": \"dirichlet\",\n            \"g_L\": lambda t: 0.0, \"g_R\": lambda t: 0.0,\n            \"q_L\": lambda t: 0.0, \"q_R\": lambda t: 0.0,\n            \"u_exact\": lambda x, t, alpha: np.exp(-alpha * 0.5**2 * t) * np.cos(0.5 * x)\n        },\n        # Case 5: Dirichlet-Neumann, non-homogeneous steady state\n        {\n            \"L\": 1.0, \"alpha\": 1.0, \"M\": 51, \"dt\": 1e-2, \"T\": 1e-1,\n            \"bc_left_type\": \"dirichlet\", \"bc_right_type\": \"neumann\",\n            \"g_L\": lambda t: 2.0, \"g_R\": lambda t: 0.0,  # g_R not used\n            \"q_L\": lambda t: 0.0, \"q_R\": lambda t: -1.5, # q_L not used\n            \"u_exact\": lambda x, t, alpha: -1.5 * x + 2.0\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        error = run_btcs_simulation(case)\n        results.append(f\"{error:.15e}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef run_btcs_simulation(params):\n    \"\"\"\n    Executes a single simulation run for the 1D diffusion equation using BTCS.\n\n    Args:\n        params (dict): A dictionary containing all parameters for the simulation.\n\n    Returns:\n        float: The maximum absolute error at the final time T.\n    \"\"\"\n    # Unpack parameters\n    L = params[\"L\"]\n    alpha = params[\"alpha\"]\n    M = params[\"M\"]\n    dt = params[\"dt\"]\n    T = params[\"T\"]\n    \n    # Grid setup\n    dx = L / (M - 1)\n    x = np.linspace(0, L, M)\n    \n    # Dimensionless parameter\n    s = alpha * dt / (dx**2)\n    \n    # Time stepping\n    num_steps = int(round(T / dt))\n    \n    # Initial condition\n    u = params[\"u_exact\"](x, 0, alpha)\n\n    # Time evolution loop\n    for n in range(num_steps):\n        t_next = (n + 1) * dt\n        \n        # Setup the linear system A u_next = b\n        A = np.zeros((M, M))\n        b = np.zeros(M)\n        \n        # Interior points\n        for i in range(1, M - 1):\n            A[i, i-1] = -s\n            A[i, i]   = 1 + 2*s\n            A[i, i+1] = -s\n            b[i]      = u[i]\n            \n        # Boundary conditions\n        # Left boundary (i=0)\n        if params[\"bc_left_type\"] == \"dirichlet\":\n            A[0, 0] = 1.0\n            b[0] = params[\"g_L\"](t_next)\n        elif params[\"bc_left_type\"] == \"neumann\":\n            A[0, 0] = 1 + 2*s\n            A[0, 1] = -2*s\n            b[0] = u[0] - (2 * alpha * dt / dx) * params[\"q_L\"](t_next)\n\n        # Right boundary (i=M-1)\n        if params[\"bc_right_type\"] == \"dirichlet\":\n            A[M-1, M-1] = 1.0\n            b[M-1] = params[\"g_R\"](t_next)\n        elif params[\"bc_right_type\"] == \"neumann\":\n            A[M-1, M-2] = -2*s\n            A[M-1, M-1] = 1 + 2*s\n            b[M-1] = u[M-1] + (2 * alpha * dt / dx) * params[\"q_R\"](t_next)\n        \n        # Solve the system for the next time step\n        u_next = np.linalg.solve(A, b)\n        u = u_next\n\n    # Calculate final error\n    u_final_exact = params[\"u_exact\"](x, T, alpha)\n    max_error = np.max(np.abs(u - u_final_exact))\n    \n    return max_error\n\nsolve()\n```"
        },
        {
            "introduction": "BTCS格式并非求解抛物线型方程的唯一选择，另一个著名的方法是Crank-Nicolson (CN)格式，它具有时间二阶精度。那么，我们应该如何在这两者之间选择呢？本练习通过一个数值实验，深入探讨一个关键的性质——保正性。对于像浓度或绝对温度这样不能为负的物理量，数值格式不应产生虚假的负值。我们将通过一个具有尖锐梯度的初始条件，比较BTCS和CN格式的保正性表现，从而揭示BTCS格式在处理非光滑问题时更为稳健的优点，帮助你理解在选择数值方法时所需权衡的各种因素。",
            "id": "3241221",
            "problem": "考虑单位区间上具有齐次狄利克雷边界条件的一维热方程，该方程被建模为一个纯扩散过程。设 $u(x,t)$ 满足 $u_t = \\alpha u_{xx}$，其中 $x \\in (0,1)$ 且 $t  0$，边界条件为 $u(0,t) = 0$ 和 $u(1,t) = 0$，初始条件为非负且急剧局部化。您将比较当初始数据具有陡峭梯度时，此问题的两种时间步进格式：后向时间中心空间（BTCS）和 Crank-Nicolson（CN）的正性行为。\n\n您的任务是在一个包含 $N$ 个内部点的均匀网格上，使用网格间距 $\\Delta x = 1/(N+1)$，实现一个单时间步的全离散格式。请使用以下基本依据：\n- 偏微分方程 $u_t = \\alpha u_{xx}$。\n- 使用时间上的后向差分来近似时间导数，通过用后向有限差分替换新时间层级上的 $u_t$ 来定义。\n- 使用空间上的中心差分来近似二阶导数，通过用基于最近邻的二阶中心差分模板替换 $u_{xx}$ 来定义。\n- Crank-Nicolson 时间离散化通过在时间上对空间算子应用梯形法则获得，即在旧的和新的时间层级上对其值进行平均。\n\n使用一个标准的空间格式，其中包含 $N$ 个内部点和直接并入离散算子的齐次狄利克雷边界条件。用经典的三点中心差分模板在内部网格上表示二阶空间导数。\n\n将两种格式都实现为针对新时间层级的线性系统：\n- BTCS（一种使用中心空间差分的隐式后向欧拉时间步）。\n- CN（一种对使用相同中心空间差分法的空间算子进行时间梯形平均的方法）。\n\n为了探究正性，选择一个具有陡峭梯度的离散初始条件：在恰好一个内部节点（当 $N$ 为奇数时为唯一的中心索引）上设置 $u_i^0 = 1$，对所有其他内部节点设置 $u_i^0 = 0$。这是一个具有零边界值的离散非负尖峰。使用无量纲变量，并设 $\\alpha = 1$。\n\n定义无量纲网格傅里叶数 $r = \\alpha \\Delta t / \\Delta x^2$。对于每次测试，使用固定的网格和 $\\alpha = 1$ 来精确地实现一个指定的 $r$ 值。对于每个格式，从此初始数据开始演化一个时间步。\n\n对于每个测试用例 $r$，确定每个格式在一步之后达到的最小值。如果最小值在严格的数值容差（使用 $10^{-12}$ 的绝对容差）内严格为负，则声明该格式表现出下冲。对于每个测试用例 $r$，返回一个布尔值，当且仅当 BTCS 避免了下冲而 CN 表现出下冲时，该值为真。\n\n测试套件：\n- 使用 $N = 99$ 个内部点（因此存在一个唯一的中心尖峰）。\n- 使用 $\\alpha = 1$（无量纲）。\n- 仅使用一个时间步（$1$ 步）。\n- 使用集合 $\\{0.2, 1.0, 1.2, 2.5\\}$ 中的 $r$ 值。\n\n输出规格：\n- 对于上述列出的每个 $r$，计算一个布尔值，当且仅当 BTCS 没有下冲（最小值在容差范围内大于或等于零）且 CN 有下冲（最小值在容差范围内严格小于零）时，该值为真。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，没有空格，且顺序与测试套件的 $r$ 值相同。例如，输出可能看起来像 $[{\\rm True},{\\rm False},{\\rm True},{\\rm True}]$。\n\n所有量都是无量纲的；不需要物理单位。不涉及角度。不涉及百分比；此任务中不出现基于百分比的量。",
            "solution": "用户要求我解决一个数值分析问题。\n\n计划如下：\n1.  **验证问题**：我将仔细检查问题陈述是否适定、科学上合理且完整。\n2.  **解构数学**：我需要将问题描述转化为 BTCS 和 Crank-Nicolson 格式的精确数学公式。\n3.  **构建线性系统**：两种格式都会得到 `A * u_new = b` 形式的线性方程组。我需要为 BTCS 和 CN 推导矩阵 `A` 和右侧向量 `b`。\n4.  **实现解决方案**：我将使用 `numpy` 编写 Python 代码，为每个测试用例建立和求解这些线性系统。\n5.  **检查下冲**：对于每种格式和每个 `r` 值，我将找到解向量 `u_new` 的最小值，并将其与负容差进行比较，以确定是否发生了下冲。\n6.  **生成最终输出**：我将把结果合并成指定的布尔列表格式。\n\n### 步骤 1：问题验证\n\n**1.1. 提取给定条件：**\n-   **PDE**：$u_t = \\alpha u_{xx}$，对于 $x \\in (0,1)$，$t  0$。\n-   **边界条件 (BCs)**：$u(0,t) = 0$, $u(1,t) = 0$（齐次狄利克雷）。\n-   **网格**：均匀网格，$N$ 个内部点。\n-   **网格间距**：$\\Delta x = 1/(N+1)$。\n-   **时间离散化 (BTCS)**：对 $u_t$ 使用后向差分。\n-   **空间离散化**：对 $u_{xx}$ 使用中心差分。\n-   **时间离散化 (CN)**：对空间算子使用时间上的梯形法则。\n-   **初始条件 (IC)**：在唯一的中心索引处（对于奇数 $N$）$u_i^0 = 1$，其他地方 $u_i^0 = 0$。\n-   **扩散系数**：$\\alpha = 1$。\n-   **网格傅里叶数**：$r = \\alpha \\Delta t / \\Delta x^2$。\n-   **演化**：精确演化一个时间步。\n-   **下冲定义**：解的最小值严格为负，绝对容差为 $10^{-12}$。\n-   **任务**：对于每个 $r$，当 (BTCS 无下冲) 且 (CN 有下冲) 时返回 `True`。\n-   **测试套件**：\n    -   $N = 99$。\n    -   $\\alpha = 1$。\n    -   一个时间步。\n    -   $r \\in \\{0.2, 1.0, 1.2, 2.5\\}$。\n-   **输出格式**：`[True,False,True,True]`（示例）。\n\n**1.2. 使用提取的给定条件进行验证：**\n-   **科学依据**：该问题描述了一维热方程，这是物理学和工程学中的一个基本偏微分方程。BTCS 和 Crank-Nicolson 格式是求解抛物型偏微分方程的标准、成熟的数值方法。数值稳定性与保正性（或其缺乏，即下冲）的概念是数值分析的核心主题。该设置在科学和数学上是合理的。\n-   **适定性**：问题是适定的。具有狄利克雷边界条件和指定初始条件的热方程有唯一解。数值格式也定义良好。对于任何合理的 $r  0$，隐式格式（BTCS 和 CN）中涉及的矩阵都是可逆的，从而得到唯一的数值解。\n-   **客观性**：问题以精确的数学语言陈述。“下冲”、“BTCS”、“CN” 和初始条件都得到了明确的定义。任务是客观的：基于清晰的数值标准计算布尔值。\n-   **缺陷清单**：\n    1.  **科学/事实不合理**：否。物理（热扩散）和数学（数值方法）都是标准的。\n    2.  **无法形式化/不相关**：否。这是一个直接与指定主题相关的经典数值分析问题。\n    3.  **不完整/矛盾**：否。所有必要的参数（$N$、$\\alpha$、$r$ 值、初始条件）都已提供。定义是一致的。\n    4.  **不现实/不可行**：否。该设置是数值格式的标准测试用例。参数是无量纲且一致的。\n    5.  **不适定/结构不良**：否。问题结构导致每个测试用例都有唯一解。\n    6.  **伪深刻/琐碎**：否。它测试了数值格式的一个众所周知的、非平凡的性质：Crank-Nicolson 格式对于陡峭梯度会产生振荡（从而从正数据产生负值），特别是在较大时间步（较大 $r$）的情况下，而 BTCS 是 L-稳定的并保持正性。这需要实际的实现和计算。\n    7.  **超出科学可验证范围**：否。结果完全可以通过计算来验证。\n\n**1.3. 结论与行动：**\n问题**有效**。我将继续进行解答。\n\n### 步骤 2：解构数学与构建线性系统\n\n令 $u_i^n$ 为 $u(x_i, t_n)$ 的数值近似，其中 $x_i = i \\Delta x$ 且 $t_n = n \\Delta t$。内部网格点对应于索引 $i = 1, 2, \\dots, N$。齐次狄利克雷边界条件被强制为对所有时间步 $n$，都有 $u_0^n = 0$ 和 $u_{N+1}^n = 0$。\n\n控制偏微分方程是一维热方程：\n$$\n\\frac{\\partial u}{\\partial t} = \\alpha \\frac{\\partial^2 u}{\\partial x^2}\n$$\n\n我们在均匀网格上离散化此方程。令 $\\mathbf{u}^n = [u_1^n, u_2^n, \\dots, u_N^n]^T$ 为在时间层级 $t_n$ 上 $N$ 个内部网格点的解向量。二阶空间导数使用二阶中心差分模板近似。这可以表示为矩阵向量乘积 $\\alpha \\frac{\\partial^2 u}{\\partial x^2} \\approx \\alpha \\mathbf{L} \\mathbf{u}$，其中 $\\mathbf{L}$ 是 $N \\times N$ 离散拉普拉斯矩阵：\n$$\n\\mathbf{L} = \\frac{1}{\\Delta x^2} \\begin{pmatrix}\n-2  1  0  \\dots  0 \\\\\n1  -2  1  \\dots  0 \\\\\n0  1  -2  \\ddots  \\vdots \\\\\n\\vdots   \\ddots  \\ddots  1 \\\\\n0  \\dots  \\dots  1  -2\n\\end{pmatrix}\n$$\n半离散系统为 $\\frac{d\\mathbf{u}}{dt} = \\alpha \\mathbf{L} \\mathbf{u}$。现在我们将应用两种不同的时间步进格式。\n\n**1. 后向时间中心空间 (BTCS) 格式**\nBTCS 格式对时间导数使用一阶后向差分（隐式欧拉法），在新时间层级 $n+1$ 上进行计算：\n$$\n\\frac{\\mathbf{u}^{n+1} - \\mathbf{u}^n}{\\Delta t} = \\alpha \\mathbf{L} \\mathbf{u}^{n+1}\n$$\n重新整理以求解未知向量 $\\mathbf{u}^{n+1}$：\n$$\n(\\mathbf{I} - \\alpha \\Delta t \\mathbf{L}) \\mathbf{u}^{n+1} = \\mathbf{u}^n\n$$\n其中 $\\mathbf{I}$ 是单位矩阵。使用无量纲网格傅里叶数 $r = \\alpha \\Delta t / \\Delta x^2$，系统变为：\n$$\n\\mathbf{A}_{\\text{BTCS}} \\mathbf{u}^{n+1} = \\mathbf{u}^n\n$$\n矩阵 $\\mathbf{A}_{\\text{BTCS}}$ 是一个三对角矩阵，定义如下：\n$$\n\\mathbf{A}_{\\text{BTCS}} = (\\mathbf{I} - r \\Delta x^2 \\mathbf{L}) = \\begin{pmatrix}\n1+2r  -r  0  \\dots  0 \\\\\n-r  1+2r  -r  \\dots  0 \\\\\n0  \\ddots  \\ddots  \\ddots  \\vdots \\\\\n\\vdots  \\dots  -r  1+2r  -r \\\\\n0  \\dots  0  -r  1+2r\n\\end{pmatrix}\n$$\n右侧是前一个时间步的解，$\\mathbf{b}_{\\text{BTCS}} = \\mathbf{u}^n$。对于任何 $r  0$，$\\mathbf{A}_{\\text{BTCS}}$ 是一个 M-矩阵，这保证了如果初始数据 $\\mathbf{u}^n$ 是非负的，那么解 $\\mathbf{u}^{n+1}$ 也将是非负的。因此，BTCS 格式是无条件保正的。\n\n**2. Crank-Nicolson (CN) 格式**\nCrank-Nicolson 格式是一种二阶精度方法，它在旧的和新的时间层级上对空间算子进行平均（梯形法则）：\n$$\n\\frac{\\mathbf{u}^{n+1} - \\mathbf{u}^n}{\\Delta t} = \\frac{1}{2} \\left( \\alpha \\mathbf{L} \\mathbf{u}^{n+1} + \\alpha \\mathbf{L} \\mathbf{u}^n \\right)\n$$\n重新整理以求解 $\\mathbf{u}^{n+1}$：\n$$\n\\left(\\mathbf{I} - \\frac{\\alpha \\Delta t}{2} \\mathbf{L}\\right) \\mathbf{u}^{n+1} = \\left(\\mathbf{I} + \\frac{\\alpha \\Delta t}{2} \\mathbf{L}\\right) \\mathbf{u}^n\n$$\n使用傅里叶数 $r$，这会产生线性系统：\n$$\n\\mathbf{A}_{\\text{CN}} \\mathbf{u}^{n+1} = \\mathbf{B}_{\\text{CN}} \\mathbf{u}^n\n$$\n左侧矩阵 $\\mathbf{A}_{\\text{CN}}$ 是：\n$$\n\\mathbf{A}_{\\text{CN}} = \\left(\\mathbf{I} - \\frac{r}{2} \\Delta x^2 \\mathbf{L}\\right) = \\begin{pmatrix}\n1+r  -r/2  0  \\dots  0 \\\\\n-r/2  1+r  -r/2  \\dots  0 \\\\\n0  \\ddots  \\ddots  \\ddots  \\vdots \\\\\n\\vdots  \\dots  -r/2  1+r  -r/2 \\\\\n0  \\dots  0  -r/2  1+r\n\\end{pmatrix}\n$$\n右侧是向量 $\\mathbf{b}_{\\text{CN}} = \\mathbf{B}_{\\text{CN}} \\mathbf{u}^n$，其中矩阵 $\\mathbf{B}_{\\text{CN}}$ 是：\n$$\n\\mathbf{B}_{\\text{CN}} = \\left(\\mathbf{I} + \\frac{r}{2} \\Delta x^2 \\mathbf{L}\\right) = \\begin{pmatrix}\n1-r  r/2  0  \\dots  0 \\\\\nr/2  1-r  r/2  \\dots  0 \\\\\n0  \\ddots  \\ddots  \\ddots  \\vdots \\\\\n\\vdots  \\dots  r/2  1-r  r/2 \\\\\n0  \\dots  0  r/2  1-r\n\\end{pmatrix}\n$$\nCN 格式的正性取决于右侧算子 $\\mathbf{B}_{\\text{CN}}$。为了使 $\\mathbf{B}_{\\text{CN}}$ 将非负向量映射到非负向量，其所有元素必须为非负。这要求 $1-r \\ge 0$，即 $r \\le 1$。如果 $r  1$，对角线元素 $1-r$ 变为负值。对于像指定的尖峰这样具有陡峭梯度的初始条件，这个负的对角线元素可能在右侧向量 $\\mathbf{b}_{\\text{CN}}$ 中引入负值，这可能导致解 $\\mathbf{u}^{n+1}$ 中出现负值（下冲）。\n\n**实现策略**\n对于每个测试用例的 $r$ 值，我们执行以下步骤：\n1.  设置大小为 $N=99$ 的初始条件向量 $\\mathbf{u}^0$。除了中心元素（索引 $k = (99-1)/2 = 49$）$u_k^0 = 1$ 外，其余都为零。\n2.  对于 BTCS 格式，构建矩阵 $\\mathbf{A}_{\\text{BTCS}}$ 并求解系统 $\\mathbf{A}_{\\text{BTCS}} \\mathbf{u}^1 = \\mathbf{u}^0$ 得到 $\\mathbf{u}^1$。\n3.  对于 CN 格式，构建矩阵 $\\mathbf{A}_{\\text{CN}}$ 和 $\\mathbf{B}_{\\text{CN}}$。计算右侧向量 $\\mathbf{b}_{\\text{CN}} = \\mathbf{B}_{\\text{CN}} \\mathbf{u}^0$ 并求解系统 $\\mathbf{A}_{\\text{CN}} \\mathbf{u}^1 = \\mathbf{b}_{\\text{CN}}$ 得到 $\\mathbf{u}^1$。\n4.  对于每种格式，找到所得解向量 $\\mathbf{u}^1$ 中的最小值。\n5.  如果此最小值小于 $-10^{-12}$，则声明发生下冲。\n6.  对于给定的 $r$，如果 BTCS 没有下冲且 CN 有下冲，则最终的布尔结果为 `True`。对所有指定的 $r$ 值重复此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Compares the positivity of BTCS and Crank-Nicolson schemes for the 1D heat equation.\n    \"\"\"\n\n    # --- Test Suite Parameters ---\n    N = 99  # Number of interior grid points\n    alpha = 1.0  # Diffusion coefficient\n    r_values = [0.2, 1.0, 1.2, 2.5]  # Dimensionless mesh Fourier numbers\n    tolerance = 1e-12\n\n    # --- Initial Condition ---\n    # Sharply localized spike at the center of the grid.\n    # N=99 is odd, so there is a unique center index.\n    u0 = np.zeros(N)\n    center_index = (N - 1) // 2\n    u0[center_index] = 1.0\n\n    results = []\n    for r in r_values:\n        # --- BTCS (Backward-Time Central-Space) Scheme ---\n        # The system is A_btcs * u1 = u0\n        \n        # Construct the tridiagonal matrix A_btcs\n        diag_main_btcs = (1 + 2 * r) * np.ones(N)\n        diag_off_btcs = -r * np.ones(N - 1)\n        A_btcs = np.diag(diag_main_btcs) + np.diag(diag_off_btcs, k=1) + np.diag(diag_off_btcs, k=-1)\n\n        # Right-hand side is simply the initial condition\n        b_btcs = u0\n\n        # Solve for the new time step\n        u1_btcs = np.linalg.solve(A_btcs, b_btcs)\n\n        # Check for undershoot\n        min_btcs = np.min(u1_btcs)\n        btcs_no_undershoot = (min_btcs = -tolerance)\n\n        # --- Crank-Nicolson (CN) Scheme ---\n        # The system is A_cn * u1 = B_cn * u0\n        \n        # Construct the left-hand side matrix A_cn\n        diag_main_cn = (1 + r) * np.ones(N)\n        diag_off_cn = -r / 2.0 * np.ones(N - 1)\n        A_cn = np.diag(diag_main_cn) + np.diag(diag_off_cn, k=1) + np.diag(diag_off_cn, k=-1)\n        \n        # Construct the right-hand side vector b_cn = B_cn * u0.\n        # Since u0 is a spike at center_index, b_cn is just the center_index'th\n        # column of B_cn, where B_cn has diagonals (1-r) and off-diagonals (r/2).\n        b_cn = np.zeros(N)\n        b_cn[center_index] = 1.0 - r\n        if center_index  0:\n            b_cn[center_index - 1] = r / 2.0\n        if center_index  N - 1:\n            b_cn[center_index + 1] = r / 2.0\n\n        # Solve for the new time step\n        u1_cn = np.linalg.solve(A_cn, b_cn)\n\n        # Check for undershoot\n        min_cn = np.min(u1_cn)\n        cn_undershoot = (min_cn  -tolerance)\n\n        # --- Evaluate Condition ---\n        # The condition is True if BTCS has no undershoot AND CN has an undershoot.\n        final_result = btcs_no_undershoot and cn_undershoot\n        results.append(final_result)\n\n    # Final print statement in the exact required format.\n    # Python's str(True) is 'True', which matches the format implied by the example.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}