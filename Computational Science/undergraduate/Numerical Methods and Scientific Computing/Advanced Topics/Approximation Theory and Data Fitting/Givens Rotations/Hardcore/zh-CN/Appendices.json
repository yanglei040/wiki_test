{
    "hands_on_practices": [
        {
            "introduction": "Givens旋转的一个核心应用是在向量的特定位置引入零。这个练习将带你实践最基本也是最关键的一步：对于一个二维向量，如何计算出相应的Givens旋转矩阵参数 $c$ 和 $s$，从而将其旋转至一个坐标轴上。通过解决这个问题 ，你将掌握Givens旋转的构建方法，这是理解更复杂算法（如QR分解）的基石。",
            "id": "2176490",
            "problem": "在数值线性代数中，Givens旋转是一种在二维平面中旋转向量的操作，通常用于在QR分解等算法中将向量或矩阵中的元素置零。一个 2x2 的Givens矩阵是一个正交矩阵，其形式为\n$$\nG = \\begin{pmatrix} c  s \\\\ -s  c \\end{pmatrix}\n$$\n其中 $c$ 和 $s$ 是满足条件 $c^2 + s^2 = 1$ 的实数。\n\n考虑向量 $x = \\begin{pmatrix} 7 \\\\ -4 \\end{pmatrix}$。请确定一个特定的Givens矩阵 $G$，该矩阵将向量 $x$ 变换为一个新向量 $y = Gx$，其形式为 $\\begin{pmatrix} r \\\\ 0 \\end{pmatrix}$，并满足附加约束条件，即所得分量 $r$ 必须为正。\n\n请以一个包含精确数值的 2x2 矩阵形式给出您的答案。",
            "solution": "设 $G=\\begin{pmatrix} c  s \\\\ -s  c \\end{pmatrix}$ 满足 $c^{2}+s^{2}=1$，且 $x=\\begin{pmatrix} a \\\\ b \\end{pmatrix}$。则\n$$\nGx=\\begin{pmatrix} ca+sb \\\\ -sa+cb \\end{pmatrix}.\n$$\n为了得到 $Gx=\\begin{pmatrix} r \\\\ 0 \\end{pmatrix}$，需要使第二个分量为零：\n$$\n-sa+cb=0 \\quad \\Longleftrightarrow \\quad cb=sa.\n$$\n满足此条件和 $c^{2}+s^{2}=1$ 的一个标准选择是\n$$\nr=\\sqrt{a^{2}+b^{2}}, \\quad c=\\frac{a}{r}, \\quad s=\\frac{b}{r}.\n$$\n通过这个选择，\n$$\n-sa+cb=-\\frac{b}{r}a+\\frac{a}{r}b=0, \\quad ca+sb=\\frac{a^{2}+b^{2}}{r}=r,\n$$\n并且由于 $r=\\sqrt{a^{2}+b^{2}}$ 是正数，所以满足 $r0$ 的要求。\n\n对于 $x=\\begin{pmatrix} 7 \\\\ -4 \\end{pmatrix}$，我们有 $a=7$，$b=-4$，因此\n$$\nr=\\sqrt{7^{2}+(-4)^{2}}=\\sqrt{65}, \\quad c=\\frac{7}{\\sqrt{65}}, \\quad s=\\frac{-4}{\\sqrt{65}}.\n$$\n所以，\n$$\nG=\\begin{pmatrix} \\frac{7}{\\sqrt{65}}  \\frac{-4}{\\sqrt{65}} \\\\ \\frac{4}{\\sqrt{65}}  \\frac{7}{\\sqrt{65}} \\end{pmatrix}.\n$$\n这个 $G$ 矩阵得到 $Gx=\\begin{pmatrix} \\sqrt{65} \\\\ 0 \\end{pmatrix}$，其第一个分量为正，符合要求。",
            "answer": "$$\\boxed{\\begin{pmatrix} \\frac{7}{\\sqrt{65}}  \\frac{-4}{\\sqrt{65}} \\\\ \\frac{4}{\\sqrt{65}}  \\frac{7}{\\sqrt{65}} \\end{pmatrix}}$$"
        },
        {
            "introduction": "学会了如何构建Givens旋转矩阵后，下一步自然是学习如何应用它。这个练习  将演示一个为特定二维平面设计的Givens旋转如何作用于一个高维（三维）向量。你会发现，这种变换只影响旋转平面内的分量，而其他分量保持不变，这种“局部作用”的特性正是Givens旋转在数值算法中如此高效和实用的原因。",
            "id": "1365942",
            "problem": "在数值线性代数中，吉文斯旋转是在由两个坐标轴张成的平面中的一种旋转。吉文斯旋转矩阵 $G(i,j,c,s)$ 是一个单位矩阵，但其中四个元素不同，其设计用于在 $(i, j)$ 平面中执行旋转。对于三维欧几里得空间 $\\mathbb{R}^3$，矩阵 $G(i,j,c,s)$ 的定义使其元素为：当 $k \\notin \\{i, j\\}$ 时 $G_{kk} = 1$，$G_{ii} = c$，$G_{jj} = c$，$G_{ij} = s$ 以及 $G_{ji} = -s$，其中 $c$ 和 $s$ 是满足 $c^2 + s^2 = 1$ 的实数。所有其他非对角元素均为零。\n\n考虑一个在 $(1,3)$ 平面内的特定吉文斯旋转，记为 $G_{1,3}$，其参数为 $c = \\frac{3}{5}$ 和 $s = \\frac{4}{5}$。\n\n确定当此旋转应用于向量 $v = \\begin{pmatrix} 5 \\\\ 1 \\\\ 10 \\end{pmatrix}$ 时得到的结果向量。请将答案表示为结果向量的分量。",
            "solution": "在 $(i,j)$ 平面内的吉文斯旋转 $G(i,j,c,s)$ 具有一个 $2\\times 2$ 子块 $\\begin{pmatrix} c  s \\\\ -s  c \\end{pmatrix}$，它作用于向量 $v$ 的 $(v_{i},v_{j})$ 分量，而其他分量保持不变。因此，对于 $i=1$ 和 $j=3$，对向量 $v=\\begin{pmatrix} v_{1} \\\\ v_{2} \\\\ v_{3} \\end{pmatrix}$ 的作用由下式给出：\n$$\nv_{1}'=c\\,v_{1}+s\\,v_{3},\\quad v_{2}'=v_{2},\\quad v_{3}'=-s\\,v_{1}+c\\,v_{3}.\n$$\n当 $c=\\frac{3}{5}$，$s=\\frac{4}{5}$，且 $v=\\begin{pmatrix} 5 \\\\ 1 \\\\ 10 \\end{pmatrix}$ 时，计算每个分量：\n$$\nv_{1}'=\\frac{3}{5}\\cdot 5+\\frac{4}{5}\\cdot 10=3+8=11,\n$$\n$$\nv_{2}'=1,\n$$\n$$\nv_{3}'=-\\frac{4}{5}\\cdot 5+\\frac{3}{5}\\cdot 10=-4+6=2.\n$$\n因此，结果向量为 $\\begin{pmatrix} 11 \\\\ 1 \\\\ 2 \\end{pmatrix}$。",
            "answer": "$$\\boxed{\\begin{pmatrix} 11 \\\\ 1 \\\\ 2 \\end{pmatrix}}$$"
        },
        {
            "introduction": "在QR分解等实际应用中，我们通常需要施加一系列Givens旋转。这个最后的练习  将引导你从手动计算转向编程实践，要求你高效地实现这一过程。关键在于，你需要按顺序将旋转直接应用于向量，而不是先计算所有旋转矩阵的乘积，这对于保证计算性能和节省内存至关重要。这个练习将巩固你对Givens旋转实用价值的理解。",
            "id": "3236383",
            "problem": "给定一个平面旋转序列（即吉文斯旋转）和一个目标向量。目标是在不显式构造完整的正交矩阵的情况下，将该旋转序列应用于该向量。使用的基本原理是正交矩阵的定义以及吉文斯旋转的结构，即它作用于两个坐标，在除了一个二维正交块之外的所有地方都表现为单位变换。吉文斯旋转由索引 $i$ 和 $j$ 以及满足 $c^2 + s^2 = 1$ 的参数 $c$ 和 $s$ 定义。\n\n定义和约束：\n- 一个吉文斯旋转 $G(i,j;c,s)$ 作用于向量 $\\mathbf{x} \\in \\mathbb{R}^n$，通过一个二维正交块仅变换分量 $x_i$ 和 $x_j$\n$$\n\\begin{pmatrix}\nc  s \\\\\n-s  c\n\\end{pmatrix},\n$$\n而所有其他分量保持不变。参数满足 $c^2 + s^2 = 1$。\n- 旋转序列为 $Q = G_k \\dots G_1$，应用于向量时为 $Q \\mathbf{x}$，按照从 $G_1$到 $G_k$ 的列出顺序进行（即，首先将 $G_1$ 应用于 $\\mathbf{x}$，然后将 $G_2$ 应用于结果，依此类推）。\n- 所有索引 $i$ 和 $j$ 均使用从0开始的索引。\n- 不使用角度；每次旋转由其 $(c,s)$ 值指定。\n- 不要构造完整的矩阵 $Q$。算法每次旋转必须只更新相关的两个条目。\n\n任务：\n- 编写一个完整的程序，将给定的吉文斯旋转序列 $Q = G_k \\dots G_1$ 应用于长度为 $n$ 的向量 $\\mathbf{x}$，而无需显式构造矩阵 $Q$。\n- 对于每次旋转 $G(i,j;c,s)$，根据以下规则更新两个条目 $x_i$ 和 $x_j$\n$$\n\\begin{pmatrix}\nx_i' \\\\\nx_j'\n\\end{pmatrix}\n=\n\\begin{pmatrix}\nc  s \\\\\n-s  c\n\\end{pmatrix}\n\\begin{pmatrix}\nx_i \\\\\nx_j\n\\end{pmatrix},\n$$\n按从 $G_1$ 到 $G_k$ 的顺序应用。\n\n测试套件：\n将您的实现应用于以下参数集。每个测试用例由维度 $n$、初始向量 $\\mathbf{x}$ 和旋转的有序列表 $\\mathcal{G}$ 指定，其中每次旋转是一个使用从0开始的索引的元组 $(i,j,c,s)$。\n\n- 测试用例 1 (一般情况)：\n  - $n = 5$\n  - $\\mathbf{x} = [3.0, -1.0, 2.0, 0.5, -4.0]^\\top$\n  - $\\mathcal{G} = [(0, 1, 0.8, 0.6), (2, 4, 0.6, -0.8), (3, 4, 0.7071067811865476, 0.7071067811865475)]$\n\n- 测试用例 2 (边界情况：保持向量不变的单位旋转)：\n  - $n = 4$\n  - $\\mathbf{x} = [1.0, 2.0, 3.0, 4.0]^\\top$\n  - $\\mathcal{G} = [(1, 3, 1.0, 0.0)]$\n\n- 测试用例 3 (边缘情况：零向量在任何正交变换下都保持为零)：\n  - $n = 3$\n  - $\\mathbf{x} = [0.0, 0.0, 0.0]^\\top$\n  - $\\mathcal{G} = [(0, 2, 0.0, 1.0), (0, 1, 0.7071067811865476, -0.7071067811865475)]$\n\n- 测试用例 4 (边缘情况：空的旋转序列)：\n  - $n = 5$\n  - $\\mathbf{x} = [-2.5, 0.0, 7.25, 1.5, -3.5]^\\top$\n  - $\\mathcal{G} = []$\n\n- 测试用例 5 (边界情况：由 $c = 0$ 和 $s = \\pm 1$ 表示的纯 $90^\\circ$ 等效旋转，产生带符号的交换)：\n  - $n = 4$\n  - $\\mathbf{x} = [0.5, -1.5, 2.0, 3.0]^\\top$\n  - $\\mathcal{G} = [(0, 2, 0.0, 1.0), (1, 3, 0.0, -1.0)]$\n\n最终输出规范：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，`[result_1,result_2,result_3]`）。\n- 每个 `result_t` 本身必须是测试用例 $t$ 的结果向量，格式化为一个列表，其中条目四舍五入到八位小数，例如 `[x_0, x_1, ..., x_{n-1}]`。",
            "solution": "该问题是有效的。这是数值线性代数领域一个适定且有科学依据的任务。所有提供的数据都是一致的，足以进行求解。\n\n该问题要求将一个吉文斯旋转序列应用于一个向量。吉文斯旋转是一种正交变换，它只影响向量的两个分量，在它们定义的平面中进行旋转。给定一个向量 $\\mathbf{x} \\in \\mathbb{R}^n$，吉文斯旋转 $G(i, j; c, s)$ 用于修改分量 $x_i$ 和 $x_j$，其中 $i$ 和 $j$ 是对应于旋转平面的索引。向量 $\\mathbf{x}$ 的所有其他分量保持不变。\n\n该变换由一个作用于子向量 $\\begin{pmatrix} x_i \\\\ x_j \\end{pmatrix}$ 的 $2 \\times 2$ 矩阵定义。参数 $c$ 和 $s$ 分别是旋转角度的余弦和正弦，并且必须满足条件 $c^2 + s^2 = 1$，这确保了变换的正交性。更新后的分量，记为 $x_i'$ 和 $x_j'$，计算如下：\n$$\n\\begin{pmatrix}\nx_i' \\\\\nx_j'\n\\end{pmatrix}\n=\n\\begin{pmatrix}\nc  s \\\\\n-s  c\n\\end{pmatrix}\n\\begin{pmatrix}\nx_i \\\\\nx_j\n\\end{pmatrix}\n$$\n这个矩阵-向量乘法展开为两个标量方程：\n$$\nx_i' = c \\cdot x_i + s \\cdot x_j \\\\\nx_j' = -s \\cdot x_i + c \\cdot x_j\n$$\n问题规定，一个由 $k$ 个此类旋转组成的序列 $G_1, G_2, \\dots, G_k$ 必须应用于初始向量 $\\mathbf{x}$。最终向量 $\\mathbf{x}_{final}$ 是复合变换 $Q\\mathbf{x}$ 的结果，其中 $Q = G_k G_{k-1} \\dots G_1$。应用必须是顺序的：\n$$\n\\mathbf{x}^{(1)} = G_1 \\mathbf{x}^{(0)} \\\\\n\\mathbf{x}^{(2)} = G_2 \\mathbf{x}^{(1)} \\\\\n\\vdots \\\\\n\\mathbf{x}^{(k)} = G_k \\mathbf{x}^{(k-1)}\n$$\n其中 $\\mathbf{x}^{(0)}$ 是初始向量。\n\n关键约束是在不显式构造 $n \\times n$ 矩阵 $Q$ 的情况下执行此操作。这是应用吉文斯旋转的标准高效方法，因为它避免了构造和乘以大型稠密矩阵的存储和计算成本。算法通过迭代给定的旋转序列来进行。对于每次旋转 $G_m(i, j; c, s)$，只更新向量的第 $i$ 个和第 $j$ 个元素。\n\n算法步骤如下：\n1. 用提供的初始值初始化向量 $\\mathbf{x}$。\n2. 对于给定序列 $\\mathcal{G}$ 中的每次旋转 $(i, j, c, s)$：\n   a. 从向量 $\\mathbf{x}$ 中提取分量 $x_i$ 和 $x_j$ 的当前值。\n   b. 由于新值 $x_i'$ 和 $x_j'$ 的计算都依赖于 $x_i$ 和 $x_j$ 的原始值，因此必须注意在两次计算中都使用原始值。一种常见的实现方法是在覆盖原始值之前，将其中的一个（例如 $x_i$）存储在一个临时变量中。\n   c. 计算新值 $x_i' = c \\cdot x_i + s \\cdot x_j$。\n   d. 计算新值 $x_j' = -s \\cdot x_i + c \\cdot x_j$（使用原始的 $x_i$）。\n   e. 通过将其第 $i$ 个分量设置为 $x_i'$，第 $j$ 个分量设置为 $x_j'$来更新向量 $\\mathbf{x}$。\n3. 在序列中所有旋转都应用完毕后，得到的向量 $\\mathbf{x}$ 就是最终答案。\n\n此过程将应用于提供的每个测试用例。每个结果向量的最终数值将按照规定四舍五入到八位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Applies a sequence of Givens rotations to a vector for multiple test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1 (general case)\n        {\n            \"n\": 5,\n            \"x\": [3.0, -1.0, 2.0, 0.5, -4.0],\n            \"G\": [(0, 1, 0.8, 0.6), \n                  (2, 4, 0.6, -0.8), \n                  (3, 4, 0.7071067811865476, 0.7071067811865475)]\n        },\n        # Test case 2 (boundary case: identity rotation)\n        {\n            \"n\": 4,\n            \"x\": [1.0, 2.0, 3.0, 4.0],\n            \"G\": [(1, 3, 1.0, 0.0)]\n        },\n        # Test case 3 (edge case: zero vector)\n        {\n            \"n\": 3,\n            \"x\": [0.0, 0.0, 0.0],\n            \"G\": [(0, 2, 0.0, 1.0), \n                  (0, 1, 0.7071067811865476, -0.7071067811865475)]\n        },\n        # Test case 4 (edge case: empty sequence)\n        {\n            \"n\": 5,\n            \"x\": [-2.5, 0.0, 7.25, 1.5, -3.5],\n            \"G\": []\n        },\n        # Test case 5 (boundary case: 90-degree rotations)\n        {\n            \"n\": 4,\n            \"x\": [0.5, -1.5, 2.0, 3.0],\n            \"G\": [(0, 2, 0.0, 1.0), \n                  (1, 3, 0.0, -1.0)]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Initialize vector from the current test case.\n        # Use numpy array for vectorized operations and floating point precision.\n        x = np.array(case[\"x\"], dtype=np.float64)\n        \n        # Apply each Givens rotation in sequence.\n        for rotation in case[\"G\"]:\n            i, j, c, s = rotation\n            \n            # Store original values of x[i] and x[j]\n            xi = x[i]\n            xj = x[j]\n            \n            # Apply the rotation.\n            # The calculation of the new x[j] must use the original xi.\n            x[i] = c * xi + s * xj\n            x[j] = -s * xi + c * xj\n            \n        # Round the final vector to 8 decimal places.\n        rounded_x = np.round(x, 8)\n        \n        # Convert -0.0 to 0.0 for canonical representation, then convert to list.\n        result_list = [0.0 if val == -0.0 else val for val in rounded_x.tolist()]\n        \n        # Append the string representation of the list to the results.\n        results.append(str(result_list))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}