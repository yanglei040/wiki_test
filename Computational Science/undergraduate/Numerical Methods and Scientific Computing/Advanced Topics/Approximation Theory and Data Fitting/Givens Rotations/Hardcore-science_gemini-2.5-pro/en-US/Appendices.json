{
    "hands_on_practices": [
        {
            "introduction": "The fundamental power of a Givens rotation lies in its ability to selectively target and zero out a specific element of a vector. This first exercise is the foundational building block, where you will construct the precise $2 \\times 2$ rotation matrix needed to transform a vector such that one of its components becomes zero. Mastering this core calculation is the first step toward understanding how Givens rotations are used in more complex numerical algorithms. ",
            "id": "2176490",
            "problem": "In numerical linear algebra, a Givens rotation is an operation that rotates a vector in a two-dimensional plane and is often used to introduce zeros into vectors or matrices as part of algorithms like QR decomposition. A 2x2 Givens matrix is an orthogonal matrix of the form\n$$\nG = \\begin{pmatrix} c & s \\\\ -s & c \\end{pmatrix}\n$$\nwhere $c$ and $s$ are real numbers that satisfy the condition $c^2 + s^2 = 1$.\n\nConsider the vector $x = \\begin{pmatrix} 7 \\\\ -4 \\end{pmatrix}$. Determine the specific Givens matrix $G$ that transforms this vector $x$ into a new vector $y = Gx$ which has the form $\\begin{pmatrix} r \\\\ 0 \\end{pmatrix}$, under the additional constraint that the resulting component $r$ must be positive.\n\nPresent your answer as a 2x2 matrix with exact numerical entries.",
            "solution": "Let $G=\\begin{pmatrix} c & s \\\\ -s & c \\end{pmatrix}$ with $c^{2}+s^{2}=1$ and $x=\\begin{pmatrix} a \\\\ b \\end{pmatrix}$. Then\n$$\nGx=\\begin{pmatrix} ca+sb \\\\ -sa+cb \\end{pmatrix}.\n$$\nTo obtain $Gx=\\begin{pmatrix} r \\\\ 0 \\end{pmatrix}$, enforce the second component to vanish:\n$$\n-sa+cb=0 \\quad \\Longleftrightarrow \\quad cb=sa.\n$$\nA standard choice satisfying this and $c^{2}+s^{2}=1$ is\n$$\nr=\\sqrt{a^{2}+b^{2}}, \\quad c=\\frac{a}{r}, \\quad s=\\frac{b}{r}.\n$$\nWith this choice,\n$$\n-sa+cb=-\\frac{b}{r}a+\\frac{a}{r}b=0, \\quad ca+sb=\\frac{a^{2}+b^{2}}{r}=r,\n$$\nand since $r=\\sqrt{a^{2}+b^{2}}$ is positive, the requirement $r>0$ is satisfied.\n\nFor $x=\\begin{pmatrix} 7 \\\\ -4 \\end{pmatrix}$ we have $a=7$, $b=-4$, hence\n$$\nr=\\sqrt{7^{2}+(-4)^{2}}=\\sqrt{65}, \\quad c=\\frac{7}{\\sqrt{65}}, \\quad s=\\frac{-4}{\\sqrt{65}}.\n$$\nTherefore,\n$$\nG=\\begin{pmatrix} \\frac{7}{\\sqrt{65}} & \\frac{-4}{\\sqrt{65}} \\\\ \\frac{4}{\\sqrt{65}} & \\frac{7}{\\sqrt{65}} \\end{pmatrix}.\n$$\nThis $G$ yields $Gx=\\begin{pmatrix} \\sqrt{65} \\\\ 0 \\end{pmatrix}$ with the positive first component as required.",
            "answer": "$$\\boxed{\\begin{pmatrix} \\frac{7}{\\sqrt{65}} & \\frac{-4}{\\sqrt{65}} \\\\ \\frac{4}{\\sqrt{65}} & \\frac{7}{\\sqrt{65}} \\end{pmatrix}}$$"
        },
        {
            "introduction": "Building on the basic $2 \\times 2$ case, this next exercise demonstrates how Givens rotations are applied in higher-dimensional spaces. You will see that a Givens rotation acts as a \"surgical tool,\" modifying only two vector components in a chosen plane while leaving all other components completely untouched. This practice clarifies how we can use a sequence of these simple rotations to systematically shape a vector or matrix. ",
            "id": "1365942",
            "problem": "In numerical linear algebra, a Givens rotation is a rotation in the plane spanned by two coordinate axes. A Givens rotation matrix $G(i,j,c,s)$ is an identity matrix except for four elements, designed to perform a rotation in the $(i, j)$ plane. For a three-dimensional Euclidean space $\\mathbb{R}^3$, the matrix $G(i,j,c,s)$ is defined such that its entries are $G_{kk} = 1$ for $k \\notin \\{i, j\\}$, $G_{ii} = c$, $G_{jj} = c$, $G_{ij} = s$, and $G_{ji} = -s$, where $c$ and $s$ are real numbers satisfying $c^2 + s^2 = 1$. All other off-diagonal entries are zero.\n\nConsider a specific Givens rotation in the $(1,3)$-plane, denoted by $G_{1,3}$, with parameters $c = \\frac{3}{5}$ and $s = \\frac{4}{5}$.\n\nDetermine the resulting vector when this rotation is applied to the vector $v = \\begin{pmatrix} 5 \\\\ 1 \\\\ 10 \\end{pmatrix}$. Express your answer as the components of the resulting vector.",
            "solution": "A Givens rotation $G(i,j,c,s)$ in the $(i,j)$-plane has the $2\\times 2$ block $\\begin{pmatrix} c & s \\\\ -s & c \\end{pmatrix}$ acting on the $(v_{i},v_{j})$ components of a vector $v$, leaving other components unchanged. Therefore, for $i=1$ and $j=3$, the action on $v=\\begin{pmatrix} v_{1} \\\\ v_{2} \\\\ v_{3} \\end{pmatrix}$ is given by\n$$\nv_{1}'=c\\,v_{1}+s\\,v_{3},\\quad v_{2}'=v_{2},\\quad v_{3}'=-s\\,v_{1}+c\\,v_{3}.\n$$\nWith $c=\\frac{3}{5}$, $s=\\frac{4}{5}$, and $v=\\begin{pmatrix} 5 \\\\ 1 \\\\ 10 \\end{pmatrix}$, compute each component:\n$$\nv_{1}'=\\frac{3}{5}\\cdot 5+\\frac{4}{5}\\cdot 10=3+8=11,\n$$\n$$\nv_{2}'=1,\n$$\n$$\nv_{3}'=-\\frac{4}{5}\\cdot 5+\\frac{3}{5}\\cdot 10=-4+6=2.\n$$\nThus, the resulting vector is $\\begin{pmatrix} 11 \\\\ 1 \\\\ 2 \\end{pmatrix}$.",
            "answer": "$$\\boxed{\\begin{pmatrix} 11 \\\\ 1 \\\\ 2 \\end{pmatrix}}$$"
        },
        {
            "introduction": "With the mechanics of individual rotations understood, we now turn to their practical application in algorithms. This hands-on coding exercise addresses a key principle of scientific computing: efficiency. Instead of building and multiplying large, dense rotation matrices, you will implement the process of applying a sequence of rotations directly to a vector, a far more memory- and computationally-efficient approach that is essential for real-world numerical libraries. ",
            "id": "3236383",
            "problem": "You are given a sequence of plane rotations in the sense of Givens rotations and a target vector. The goal is to apply the sequence to the vector without explicitly forming the full orthogonal matrix. The fundamental base to use is the definition of orthogonal matrices and the structure of a Givens rotation acting on two coordinates as an identity everywhere except for a single two-dimensional orthogonal block. A Givens rotation is defined on indices $i$ and $j$ with parameters $c$ and $s$ satisfying $c^2 + s^2 = 1$.\n\nDefinitions and constraints:\n- A Givens rotation $G(i,j;c,s)$ acts on a vector $\\mathbf{x} \\in \\mathbb{R}^n$ by transforming only the components $x_i$ and $x_j$ via the two-dimensional orthogonal block\n$$\n\\begin{pmatrix}\nc & s \\\\\n-s & c\n\\end{pmatrix},\n$$\nand leaving all other components unchanged. The parameters satisfy $c^2 + s^2 = 1$.\n- The sequence of rotations is $Q = G_k \\dots G_1$, and the application to a vector is $Q \\mathbf{x}$ in the listed order from $G_1$ to $G_k$ (that is, first apply $G_1$ to $\\mathbf{x}$, then apply $G_2$ to the result, and so on).\n- Use $0$-based indexing for all indices $i$ and $j$.\n- Angles are not used; specify each rotation by its $(c,s)$ values.\n- Do not form the full matrix $Q$. The algorithm must update only the relevant two entries per rotation.\n\nTask:\n- Write a complete program that applies a given sequence of Givens rotations $Q = G_k \\dots G_1$ to a vector $\\mathbf{x}$ of length $n$, without explicitly forming the matrix $Q$.\n- For each rotation $G(i,j;c,s)$, update the two entries $x_i$ and $x_j$ by the rule\n$$\n\\begin{pmatrix}\nx_i' \\\\\nx_j'\n\\end{pmatrix}\n=\n\\begin{pmatrix}\nc & s \\\\\n-s & c\n\\end{pmatrix}\n\\begin{pmatrix}\nx_i \\\\\nx_j\n\\end{pmatrix},\n$$\napplied in sequence from $G_1$ to $G_k$.\n\nTest suite:\nApply your implementation to the following parameter sets. Each test case is specified by dimension $n$, initial vector $\\mathbf{x}$, and the ordered list $\\mathcal{G}$ of rotations, where each rotation is a tuple $(i,j,c,s)$ using $0$-based indices.\n\n- Test case $1$ (general case):\n  - $n = 5$\n  - $\\mathbf{x} = [3.0, -1.0, 2.0, 0.5, -4.0]^\\top$\n  - $\\mathcal{G} = [(0, 1, 0.8, 0.6), (2, 4, 0.6, -0.8), (3, 4, 0.7071067811865476, 0.7071067811865475)]$\n\n- Test case $2$ (boundary case: identity rotation that leaves the vector unchanged):\n  - $n = 4$\n  - $\\mathbf{x} = [1.0, 2.0, 3.0, 4.0]^\\top$\n  - $\\mathcal{G} = [(1, 3, 1.0, 0.0)]$\n\n- Test case $3$ (edge case: zero vector remains zero under any orthogonal transform):\n  - $n = 3$\n  - $\\mathbf{x} = [0.0, 0.0, 0.0]^\\top$\n  - $\\mathcal{G} = [(0, 2, 0.0, 1.0), (0, 1, 0.7071067811865476, -0.7071067811865475)]$\n\n- Test case $4$ (edge case: empty sequence of rotations):\n  - $n = 5$\n  - $\\mathbf{x} = [-2.5, 0.0, 7.25, 1.5, -3.5]^\\top$\n  - $\\mathcal{G} = []$\n\n- Test case $5$ (boundary case: pure $90^\\circ$-equivalents represented by $c = 0$ and $s = \\pm 1$ producing signed swaps):\n  - $n = 4$\n  - $\\mathbf{x} = [0.5, -1.5, 2.0, 3.0]^\\top$\n  - $\\mathcal{G} = [(0, 2, 0.0, 1.0), (1, 3, 0.0, -1.0)]$\n\nFinal output specification:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[\\text{result}_1,\\text{result}_2,\\text{result}_3]$).\n- Each $\\text{result}_t$ must itself be the resulting vector for test case $t$, formatted as a list with entries rounded to eight decimal places, such as $[x_0,x_1,\\dots,x_{n-1}]$.",
            "solution": "The problem requires the application of a sequence of Givens rotations to a vector. A Givens rotation is an orthogonal transformation that affects only two components of a vector, rotating them in the plane they define. Given a vector $\\mathbf{x} \\in \\mathbb{R}^n$, a Givens rotation $G(i, j; c, s)$ is designed to modify the components $x_i$ and $x_j$, where $i$ and $j$ are the indices corresponding to the plane of rotation. All other components of the vector $\\mathbf{x}$ remain unchanged.\n\nThe transformation is defined by a $2 \\times 2$ matrix acting on the subvector $\\begin{pmatrix} x_i \\\\ x_j \\end{pmatrix}$. The parameters $c$ and $s$ are the cosine and sine of the angle of rotation, respectively, and must satisfy the condition $c^2 + s^2 = 1$, which ensures the orthogonality of the transformation. The updated components, denoted $x_i'$ and $x_j'$, are calculated as follows:\n$$\n\\begin{pmatrix}\nx_i' \\\\\nx_j'\n\\end{pmatrix}\n=\n\\begin{pmatrix}\nc & s \\\\\n-s & c\n\\end{pmatrix}\n\\begin{pmatrix}\nx_i \\\\\nx_j\n\\end{pmatrix}\n$$\nThis matrix-vector multiplication expands to two scalar equations:\n$$\nx_i' = c \\cdot x_i + s \\cdot x_j \\\\\nx_j' = -s \\cdot x_i + c \\cdot x_j\n$$\nThe problem specifies that a sequence of $k$ such rotations, $G_1, G_2, \\dots, G_k$, must be applied to an initial vector $\\mathbf{x}$. The final vector $\\mathbf{x}_{final}$ is the result of the composite transformation $Q\\mathbf{x}$, where $Q = G_k G_{k-1} \\dots G_1$. The application must be sequential:\n$$\n\\mathbf{x}^{(1)} = G_1 \\mathbf{x}^{(0)} \\\\\n\\mathbf{x}^{(2)} = G_2 \\mathbf{x}^{(1)} \\\\\n\\vdots \\\\\n\\mathbf{x}^{(k)} = G_k \\mathbf{x}^{(k-1)}\n$$\nwhere $\\mathbf{x}^{(0)}$ is the initial vector.\n\nThe key constraint is to perform this operation without explicitly constructing the $n \\times n$ matrix $Q$. This is the standard and efficient method for applying Givens rotations, as it avoids the storage and computational cost of forming and multiplying large dense matrices. The algorithm proceeds by iterating through the given sequence of rotations. For each rotation $G_m(i, j; c, s)$, only the $i$-th and $j$-th elements of the vector are updated.\n\nThe algorithmic procedure is as follows:\n1. Initialize a vector $\\mathbf{x}$ with the provided starting values.\n2. For each rotation $(i, j, c, s)$ in the given sequence $\\mathcal{G}$:\n   a. Extract the current values of the components $x_i$ and $x_j$ from the vector $\\mathbf{x}$.\n   b. Since the calculation of both new values, $x_i'$ and $x_j'$, depends on the original values of $x_i$ and $x_j$, care must be taken to use the original values for both computations. A common way to implement this is to store one of the original values, say $x_i$, in a temporary variable before it is overwritten.\n   c. Calculate the new value $x_i' = c \\cdot x_i + s \\cdot x_j$.\n   d. Calculate the new value $x_j' = -s \\cdot x_i + c \\cdot x_j$ (using the original $x_i$).\n   e. Update the vector $\\mathbf{x}$ by setting its $i$-th component to $x_i'$ and its $j$-th component to $x_j'$.\n3. After all rotations in the sequence have been applied, the resulting vector $\\mathbf{x}$ is the final answer.\n\nThis procedure will be applied to each test case provided. The final numerical results for each resulting vector will be rounded to eight decimal places as specified.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Applies a sequence of Givens rotations to a vector for multiple test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1 (general case)\n        {\n            \"n\": 5,\n            \"x\": [3.0, -1.0, 2.0, 0.5, -4.0],\n            \"G\": [(0, 1, 0.8, 0.6), \n                  (2, 4, 0.6, -0.8), \n                  (3, 4, 0.7071067811865476, 0.7071067811865475)]\n        },\n        # Test case 2 (boundary case: identity rotation)\n        {\n            \"n\": 4,\n            \"x\": [1.0, 2.0, 3.0, 4.0],\n            \"G\": [(1, 3, 1.0, 0.0)]\n        },\n        # Test case 3 (edge case: zero vector)\n        {\n            \"n\": 3,\n            \"x\": [0.0, 0.0, 0.0],\n            \"G\": [(0, 2, 0.0, 1.0), \n                  (0, 1, 0.7071067811865476, -0.7071067811865475)]\n        },\n        # Test case 4 (edge case: empty sequence)\n        {\n            \"n\": 5,\n            \"x\": [-2.5, 0.0, 7.25, 1.5, -3.5],\n            \"G\": []\n        },\n        # Test case 5 (boundary case: 90-degree rotations)\n        {\n            \"n\": 4,\n            \"x\": [0.5, -1.5, 2.0, 3.0],\n            \"G\": [(0, 2, 0.0, 1.0), \n                  (1, 3, 0.0, -1.0)]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Initialize vector from the current test case.\n        # Use numpy array for vectorized operations and floating point precision.\n        x = np.array(case[\"x\"], dtype=np.float64)\n        \n        # Apply each Givens rotation in sequence.\n        for rotation in case[\"G\"]:\n            i, j, c, s = rotation\n            \n            # Store original values of x[i] and x[j]\n            xi = x[i]\n            xj = x[j]\n            \n            # Apply the rotation.\n            # The calculation of the new x[j] must use the original xi.\n            x[i] = c * xi + s * xj\n            x[j] = -s * xi + c * xj\n            \n        # Round the final vector to 8 decimal places.\n        rounded_x = np.round(x, 8)\n        \n        # Convert -0.0 to 0.0 for canonical representation, then convert to list.\n        result_list = [0.0 if val == -0.0 else val for val in rounded_x.tolist()]\n        \n        # Append the string representation of the list to the results.\n        results.append(str(result_list))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}