{
    "hands_on_practices": [
        {
            "introduction": "我们的第一个练习将吉洪诺夫正则化分解为其最核心的部分。通过一个简单但具有启发性的二维系统，你将亲手计算正则化解。这个实践让你能够直接观察正则化参数 $\\lambda$ 如何在拟合数据与控制解的复杂度之间进行权衡，从而对它的功能建立起具体而深刻的直观认识。",
            "id": "2223140",
            "problem": "在许多科学和工程应用中，我们会遇到形如 $Ax=b$ 的“病态”线性方程组。这意味着测量向量 $b$ 的微小变化可能导致解向量 $x$ 的巨大变化。Tikhonov 正则化是在这种情况下稳定解的一种常用方法。正则化解（记为 $x_{\\lambda}$）通过求解一个修正的优化问题得到，其公式为：\n$$x_{\\lambda} = (A^T A + \\lambda I)^{-1} A^T b$$\n其中，$A$ 是系统矩阵，$b$ 是测量向量，$I$ 是单位矩阵，而 $\\lambda  0$ 是一个由用户选择的正则化参数，它控制着数据拟合与解的稳定性之间的权衡。\n\n考虑一个由以下矩阵 $A$ 和测量向量 $b$ 表征的简单二维系统：\n$$A = \\begin{pmatrix} 1  0 \\\\ 0  0.1 \\end{pmatrix}, \\quad b = \\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix}$$\n矩阵 $A$ 中的小元素使得该系统对噪声敏感，因此很适合进行正则化。您的任务是研究正则化解 $x_{\\lambda}$ 的行为。\n\n确定正则化参数 $\\lambda$ 的具体值，使得解向量 $x_{\\lambda}$ 的两个分量相等。您的答案应为一个实数，并四舍五入到三位有效数字。",
            "solution": "我们使用 Tikhonov 公式求解正则化解：\n$$\nx_{\\lambda}=(A^{T}A+\\lambda I)^{-1}A^{T}b.\n$$\n对于给定的对角矩阵 $A=\\begin{pmatrix}1  0\\\\0  0.1\\end{pmatrix}$，我们有 $A^{T}=A$，因此\n$$\nA^{T}A=\\begin{pmatrix}1  0 \\\\ 0  0.01\\end{pmatrix}, \\quad A^{T}b=\\begin{pmatrix}1 \\\\ 0.2\\end{pmatrix} = \\begin{pmatrix}1\\\\ \\frac{1}{5}\\end{pmatrix}.\n$$\n于是，\n$$\nA^{T}A+\\lambda I=\\begin{pmatrix}1+\\lambda  0 \\\\ 0  \\lambda+\\frac{1}{100}\\end{pmatrix}, \\quad (A^{T}A+\\lambda I)^{-1}=\\begin{pmatrix}\\frac{1}{1+\\lambda}  0 \\\\ 0  \\frac{1}{\\lambda+\\frac{1}{100}}\\end{pmatrix}.\n$$\n因此，\n$$\nx_{\\lambda}=\\begin{pmatrix}\\frac{1}{1+\\lambda}  0 \\\\ 0  \\frac{1}{\\lambda+\\frac{1}{100}}\\end{pmatrix}\\begin{pmatrix}1\\\\ \\frac{1}{5}\\end{pmatrix}=\\begin{pmatrix}\\frac{1}{1+\\lambda}\\\\ \\frac{\\frac{1}{5}}{\\lambda+\\frac{1}{100}}\\end{pmatrix}.\n$$\n我们要求解 $\\lambda$ 使得两个分量相等：\n$$\n\\frac{1}{1+\\lambda}=\\frac{\\frac{1}{5}}{\\lambda+\\frac{1}{100}}.\n$$\n交叉相乘得到\n$$\n\\lambda+\\frac{1}{100}=\\frac{1}{5}(1+\\lambda).\n$$\n两边同乘以 $100$，\n$$\n100\\lambda+1=20+20\\lambda \\quad \\Rightarrow \\quad 80\\lambda=19 \\quad \\Rightarrow \\quad \\lambda=\\frac{19}{80}.\n$$\n数值上，$\\lambda=\\frac{19}{80}=0.2375$，四舍五入到三位有效数字为 $0.238$。",
            "answer": "$$\\boxed{0.238}$$"
        },
        {
            "introduction": "理解正则化参数 $\\lambda$ 的作用至关重要，但在实际应用中如何选择一个合适的值是另一个核心挑战。本练习将向你介绍一种强大的启发式方法——差异原则（Discrepancy Principle），它将 $\\lambda$ 的选择与数据中的噪声水平估计联系起来。你将通过计算，找出使解的残差误差与已知噪声水平相匹配的特定 $\\lambda$ 值，这是解决现实世界反问题的常用方法。",
            "id": "2223147",
            "problem": "在逆问题的研究中，人们经常遇到形如 $Ax=b$ 的不适定线性系统。一个常见的例子是试图从一组观测效应 $b$ 来确定一组因果参数 $x$。对于此类系统，矩阵 $A$ 通常是病态的或奇异的，这意味着测量向量 $b$ 中的微小噪声可能导致解向量 $x$ 出现大的、物理上无意义的振荡。\n\nTikhonov 正则化是解决此问题的一种广泛使用的技术。它不直接求解 $Ax=b$，而是寻求一个解 $x_{\\lambda}$，该解能最小化一个同时包含残差范数和解范数的复合目标函数：\n$$ \\min_{x} \\left( \\|Ax - b\\|_2^2 + \\lambda^2 \\|x\\|_2^2 \\right) $$\n这里，$\\lambda  0$ 是正则化参数，它控制着拟合数据与惩罚解的范数之间的权衡。\n\n此过程的一个关键部分是为 $\\lambda$ 选择一个合适的值。偏差原理为此选择提供了一种启发式方法。它假定，如果数据向量 $b$ 中的噪声水平已知或可以估计为 $\\delta = \\|b - b_{\\text{true}}\\|_2$，那么 $\\lambda$ 的一个好的选择是使正则化解的残差范数等于这个噪声水平。\n\n考虑一个由矩阵 $A$ 和测量数据向量 $b$ 描述的不适定系统：\n$$ A = \\begin{pmatrix} 1  1 \\\\ 1  1 \\end{pmatrix}, \\quad b = \\begin{pmatrix} 5 \\\\ 3 \\end{pmatrix} $$\n测量 $b$ 中的噪声水平经估计为 $\\delta = 3\\sqrt{2}$。\n\n通过应用偏差原理来确定正则化参数 $\\lambda$ 的值，在本例中，这意味着找到满足方程 $\\|A x_{\\lambda} - b\\|_2 = \\delta$ 的 $\\lambda  0$ 的值。请将您的最终答案表示为一个精确的、闭合形式的解析表达式。",
            "solution": "我们寻求 Tikhonov 正则化解\n$$\nx_{\\lambda}=\\arg\\min_{x}\\left(\\|Ax-b\\|_{2}^{2}+\\lambda^{2}\\|x\\|_{2}^{2}\\right),\n$$\n它满足正规方程\n$$\n(A^{T}A+\\lambda^{2}I)x_{\\lambda}=A^{T}b.\n$$\n对于给定的矩阵和向量，\n$$\nA=\\begin{pmatrix}1  1\\\\1  1\\end{pmatrix},\\quad b=\\begin{pmatrix}5\\\\3\\end{pmatrix},\n$$\n我们计算\n$$\nA^{T}A=\\begin{pmatrix}2  2\\\\2  2\\end{pmatrix},\\quad A^{T}b=Ab=\\begin{pmatrix}8\\\\8\\end{pmatrix}.\n$$\n令 $M= A^{T}A+\\lambda^{2}I=2J+\\lambda^{2}I$，其中 $J$ 是 $2\\times 2$ 的全一矩阵。向量 $u=(1,1)^{T}$ 是 $J$ 的一个特征向量，满足 $J u=2u$，因此 $M u=(4+\\lambda^{2})u$，而任何与 $u$ 正交的向量都是特征值为 $\\lambda^{2}$ 的特征向量。由于 $A^{T}b$ 与 $u$ 成正比，我们得到\n$$\nx_{\\lambda}=\\frac{8}{4+\\lambda^{2}}\\,u=\\frac{8}{4+\\lambda^{2}}\\begin{pmatrix}1\\\\1\\end{pmatrix}.\n$$\n残差为\n$$\nr_{\\lambda}=Ax_{\\lambda}-b=Jx_{\\lambda}-b=\\frac{16}{4+\\lambda^{2}}\\begin{pmatrix}1\\\\1\\end{pmatrix}-\\begin{pmatrix}5\\\\3\\end{pmatrix}.\n$$\n定义 $t=\\dfrac{16}{4+\\lambda^{2}}$。则\n$$\nr_{\\lambda}=\\begin{pmatrix}t-5\\\\ t-3\\end{pmatrix},\\quad \\|r_{\\lambda}\\|_{2}^{2}=(t-5)^{2}+(t-3)^{2}=2t^{2}-16t+34.\n$$\n偏差原理要求 $\\|r_{\\lambda}\\|_{2}=\\delta=3\\sqrt{2}$，即，\n$$\n2t^{2}-16t+34=18 \\quad\\Longrightarrow\\quad 2t^{2}-16t+16=0 \\quad\\Longrightarrow\\quad t^{2}-8t+8=0.\n$$\n解这个二次方程得到\n$$\nt=4\\pm 2\\sqrt{2}.\n$$\n由于 $t=\\dfrac{16}{4+\\lambda^{2}}$ 满足 $0  t  \\dfrac{16}{4}=4$，我们必须选择根 $t=4-2\\sqrt{2}$。因此，\n$$\n4+\\lambda^{2}=\\frac{16}{4-2\\sqrt{2}}=\\frac{16(4+2\\sqrt{2})}{16-8}=2(4+2\\sqrt{2})=8+4\\sqrt{2}.\n$$\n因此，$\\lambda^{2}=4+4\\sqrt{2}$，$\\lambda=\\sqrt{4+4\\sqrt{2}}=2\\sqrt{1+\\sqrt{2}}$。",
            "answer": "$$\\boxed{2\\sqrt{1+\\sqrt{2}}}$$"
        },
        {
            "introduction": "最后的这项实践将我们的视角从计算单个解提升到探索完整的“正则化路径”。你将基于奇异值分解（SVD）实现一个数值稳定的算法，以追踪当 $\\lambda$ 跨越多个数量级时解向量如何演变。这个综合性的计算练习将让你在一系列具有挑战性的场景中，通过实际观察来验证吉洪诺夫正则化的关键理论性质，例如系数收缩。",
            "id": "3200591",
            "problem": "给定带有噪声观测的线性系统，其中观测向量 $b \\in \\mathbb{R}^m$ 可通过矩阵 $A \\in \\mathbb{R}^{m \\times n}$ 和未知系数向量 $x^\\star \\in \\mathbb{R}^n$ 近似建模为 $b \\approx A x^\\star$。当矩阵 $A$ 是病态或秩亏时，为了稳定估计，我们考虑吉洪诺夫（Tikhonov）正则化目标函数\n$$\nJ_\\lambda(x) = \\lVert A x - b \\rVert_2^2 + \\lambda^2 \\lVert x \\rVert_2^2,\n$$\n其中 $\\lambda \\ge 0$ 是正则化参数，$\\lVert \\cdot \\rVert_2$ 表示欧几里得范数。统计岭回归路径是通过改变 $\\lambda$ 并观察系数如何收缩得到的。\n\n从上述基本定义和经过充分检验的线性代数事实（包括奇异值分解（SVD）和Moore-Penrose伪逆的存在性及性质）出发，推导一个数值稳定的算法，用于计算对数间隔的正则化强度 $\\lambda$ 网格上对应的 $J_\\lambda(x)$ 最小化子 $x_\\lambda$，并追踪此路径上的系数收缩情况。不要依赖本问题陈述中给出的任何捷径公式。\n\n您的程序必须实现该算法，并将其应用于以下测试套件。为了保证可复现性，所有随机抽样必须使用指定的种子和如指示的标准正态分布。\n\n- 测试用例1（良态，超定）：\n  - 维度：$m = 80$, $n = 20$。\n  - 随机种子：$42$。\n  - 构建方法：\n    - 抽取 $A \\in \\mathbb{R}^{80 \\times 20}$，其元素为独立的标准正态分布。\n    - 抽取 $x^\\text{true} \\in \\mathbb{R}^{20}$，其元素为独立的标准正态分布。\n    - 抽取 $\\epsilon \\in \\mathbb{R}^{80}$，其元素为独立的标准正态分布，然后按 $\\sigma = 0.01$ 进行缩放。\n    - 设置 $b = A x^\\text{true} + \\epsilon$。\n- 测试用例2（欠定，宽设计）：\n  - 维度：$m = 50$, $n = 100$。\n  - 随机种子：$123$。\n  - 构建方法：\n    - 抽取 $A \\in \\mathbb{R}^{50 \\times 100}$、$x^\\text{true} \\in \\mathbb{R}^{100}$ 和 $\\epsilon \\in \\mathbb{R}^{50}$，其元素均为独立的标准正态分布，其中 $\\epsilon$ 按 $\\sigma = 0.01$ 进行缩放。\n    - 设置 $b = A x^\\text{true} + \\epsilon$。\n- 测试用例3（秩亏设计）：\n  - 维度：$m = 40$, $n = 40$。\n  - 随机种子：$7$。\n  - 构建方法：\n    - 抽取 $A \\in \\mathbb{R}^{40 \\times 40}$，其元素为独立的标准正态分布。\n    - 强加精确的列重复以强制秩亏：将索引为10的列设置为与索引为5的列相同，将索引为15的列设置为与索引为5的列相同。\n    - 抽取 $x^\\text{true} \\in \\mathbb{R}^{40}$ 和 $\\epsilon \\in \\mathbb{R}^{40}$，其元素均为独立的标准正态分布，其中 $\\epsilon$ 按 $\\sigma = 0.01$ 进行缩放。\n    - 设置 $b = A x^\\text{true} + \\epsilon$。\n- 测试用例4（具有相关列的高度病态设计）：\n  - 维度：$m = 60$, $n = 20$。\n  - 随机种子：$314$。\n  - 构建方法：\n    - 抽取 $G \\in \\mathbb{R}^{60 \\times 20}$，其元素为独立的标准正态分布。\n    - 通过缩放创建相关且病态的列：对于列索引 $j \\in \\{0,1,\\dots,19\\}$，将 $A$ 的第 $j$ 列设置为 $G$ 的第 $j$ 列乘以 $10^{-\\frac{j}{3}}$。\n    - 抽取 $x^\\text{true} \\in \\mathbb{R}^{20}$ 和 $\\epsilon \\in \\mathbb{R}^{60}$，其元素均为独立的标准正态分布，其中 $\\epsilon$ 按 $\\sigma = 0.01$ 进行缩放。\n    - 设置 $b = A x^\\text{true} + \\epsilon$。\n\n对于每个测试用例，使用一个包含60个值的对数间隔网格\n$$\n\\lambda \\in \\{\\lambda_k \\mid \\lambda_k = 10^{\\ell_k},\\ \\ell_k \\text{ 在 } [-10,6] \\text{ 中等距分布}\\},\n$$\n即从 $10^{-10}$ 到 $10^{6}$。\n\n对于每个测试用例，计算正则化路径 $\\{x_{\\lambda_k}\\}$ 并评估以下三个布尔属性：\n\n1. 系数欧几里得范数的单调收缩：序列 $\\{\\lVert x_{\\lambda_k} \\rVert_2\\}_{k=1}^{60}$ 在一个小的数值容差范围内是非增的，即对所有 $k$，有 $\\lVert x_{\\lambda_{k}} \\rVert_2 \\le \\lVert x_{\\lambda_{k-1}} \\rVert_2 + \\tau$，其中 $\\tau = 10^{-12} \\cdot \\max(1, \\lVert x_{\\lambda_{k-1}} \\rVert_2)$。\n2. 在小正则化下与最小范数最小二乘解的近似一致性：设 $x_{\\mathrm{lsq}}$ 是使 $\\lVert A x - b \\rVert_2$ 最小化且具有最小 $\\lVert x \\rVert_2$ 的 Moore-Penrose 伪逆解。检查 $x_{\\lambda_{\\min}}$ 和 $x_{\\mathrm{lsq}}$ 之间的相对差异满足\n$$\n\\frac{\\lVert x_{\\lambda_{\\min}} - x_{\\mathrm{lsq}} \\rVert_2}{\\max(1,\\lVert x_{\\mathrm{lsq}} \\rVert_2)}  10^{-6}.\n$$\n3. 在非常大的正则化下系数趋近于零：检查是否满足\n$$\n\\frac{\\lVert x_{\\lambda_{\\max}} \\rVert_2}{\\max(1,\\lVert x_{\\mathrm{lsq}} \\rVert_2)}  10^{-6}.\n$$\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，各项结果按上述顺序按测试用例分组，并展平为所有测试用例的单一列表。具体来说，输出必须是一个包含12个布尔值的列表\n$$\n[\\text{m1\\_t1},\\text{m2\\_t1},\\text{m3\\_t1},\\ \\text{m1\\_t2},\\text{m2\\_t2},\\text{m3\\_t2},\\ \\text{m1\\_t3},\\text{m2\\_t3},\\text{m3\\_t3},\\ \\text{m1\\_t4},\\text{m2\\_t4},\\text{m3\\_t4}],\n$$\n其中，对于测试用例 $i$，$\\text{m1\\_t}i$ 是单调收缩检查，$\\text{m2\\_t}i$ 是小 $\\lambda$ 一致性检查，$\\text{m3\\_t}i$ 是大 $\\lambda$ 趋零检查。",
            "solution": "用户提供的问题是计算科学领域中一个有效的练习，具体涉及吉洪诺夫（Tikhonov）正则化这一主题。它要求推导并实现一个数值稳定的算法，用以计算一组明确定义的测试用例的正则化路径，并验证解的关键理论性质。该问题具有科学依据、适定性、客观性，并包含了求解所需的所有信息。\n\n### 数值稳定算法的推导\n\n吉洪诺夫正则化目标函数由下式给出：\n$$\nJ_\\lambda(x) = \\lVert A x - b \\rVert_2^2 + \\lambda^2 \\lVert x \\rVert_2^2\n$$\n其中 $A \\in \\mathbb{R}^{m \\times n}$，$b \\in \\mathbb{R}^m$，$x \\in \\mathbb{R}^n$，且 $\\lambda \\ge 0$ 是正则化参数。函数 $J_\\lambda(x)$ 对 $x$ 是凸的。对于 $\\lambda  0$，它是严格凸的，保证了唯一的最小化子。最小化子 $x_\\lambda$ 可以通过将 $J_\\lambda(x)$ 关于 $x$ 的梯度设置为零来找到。\n\n首先，我们展开目标函数：\n$$\nJ_\\lambda(x) = (A x - b)^T (A x - b) + \\lambda^2 x^T x = x^T A^T A x - 2 b^T A x + b^T b + \\lambda^2 x^T I x\n$$\n关于 $x$ 的梯度是：\n$$\n\\nabla_x J_\\lambda(x) = 2 A^T A x - 2 A^T b + 2 \\lambda^2 I x\n$$\n将梯度设为零，$\\nabla_x J_\\lambda(x) = 0$，得到吉洪诺夫正规方程组：\n$$\n(A^T A + \\lambda^2 I) x = A^T b\n$$\n解的形式为 $x_\\lambda = (A^T A + \\lambda^2 I)^{-1} A^T b$。然而，直接构建矩阵 $A^T A$ 在数值上是不稳定的，特别是当 $A$ 是病态矩阵时。$A^T A$ 的条件数是 $A$ 的条件数的平方，这可能导致严重的精度损失。\n\n使用 $A$ 的奇异值分解（SVD）可以推导出一种数值稳定的算法。设 $A$ 的 SVD 为：\n$$\nA = U \\Sigma V^T\n$$\n这里，$U \\in \\mathbb{R}^{m \\times m}$ 和 $V \\in \\mathbb{R}^{n \\times n}$ 是正交矩阵（$U^T U = I_m$, $V^T V = I_n$），$\\Sigma \\in \\mathbb{R}^{m \\times n}$ 是一个包含按降序排列的非负奇异值 $\\sigma_i$ 的矩形对角矩阵。令 $k = \\min(m, n)$。奇异值为 $(\\Sigma)_{ii} = \\sigma_i$，其中 $i=1, \\dots, k$。\n\n我们将SVD代入目标函数的第一项。利用欧几里得范数在正交变换下不变的性质（即 $\\lVert U z \\rVert_2 = \\lVert z \\rVert_2$），我们有：\n$$\n\\lVert A x - b \\rVert_2^2 = \\lVert U \\Sigma V^T x - b \\rVert_2^2 = \\lVert U^T (U \\Sigma V^T x - b) \\rVert_2^2 = \\lVert \\Sigma V^T x - U^T b \\rVert_2^2\n$$\n让我们引入变量替换。定义 $y = V^T x$ 和 $c = U^T b$。由于 $V$ 是正交的，所以 $x = V y$，且范数保持不变：$\\lVert x \\rVert_2^2 = \\lVert V y \\rVert_2^2 = \\lVert y \\rVert_2^2$。目标函数在 $y$ 的表示下转换为一个更简单的形式：\n$$\nJ_\\lambda(y) = \\lVert \\Sigma y - c \\rVert_2^2 + \\lambda^2 \\lVert y \\rVert_2^2\n$$\n这种形式是可分的。我们可以将其写成关于 $y$ 和 $c$ 各分量的和：\n$$\nJ_\\lambda(y) = \\sum_{i=1}^m \\left( (\\Sigma y)_i - c_i \\right)^2 + \\lambda^2 \\sum_{j=1}^n y_j^2\n$$\n考虑到 $\\Sigma$ 的结构：\n- 对于 $i \\le k = \\min(m, n)$，$(\\Sigma y)_i = \\sigma_i y_i$。\n- 对于 $i  k$，$(\\Sigma y)_i = 0$。\n目标函数变为：\n$$\nJ_\\lambda(y) = \\sum_{i=1}^k (\\sigma_i y_i - c_i)^2 + \\sum_{i=k+1}^m c_i^2 + \\lambda^2 \\left( \\sum_{i=1}^k y_i^2 + \\sum_{i=k+1}^n y_i^2 \\right)\n$$\n项 $\\sum_{i=k+1}^m c_i^2$ 相对于 $y$ 是一个常数。为了最小化 $J_\\lambda(y)$，我们可以对每个分量 $y_i$ 独立地最小化其余部分。\n对于 $i \\in \\{1, \\dots, k\\}$：我们最小化 $(\\sigma_i y_i - c_i)^2 + \\lambda^2 y_i^2$。将关于 $y_i$ 的导数设为零得到：\n$$\n2(\\sigma_i y_i - c_i)\\sigma_i + 2\\lambda^2 y_i = 0 \\implies (\\sigma_i^2 + \\lambda^2) y_i = \\sigma_i c_i\n$$\n$y_i$ 的解是：\n$$\ny_i = \\frac{\\sigma_i c_i}{\\sigma_i^2 + \\lambda^2}\n$$\n即使 $\\sigma_i = 0$，这个公式也是良定义的，此时 $y_i=0$（对于 $\\lambda  0$）。\n对于 $i \\in \\{k+1, \\dots, n\\}$（这种情况仅在 $nm$ 时发生，此时 $k=m$）：我们最小化 $\\lambda^2 y_i^2$。对于 $\\lambda  0$，最小值在 $y_i = 0$ 时取得。\n\n因此，解向量 $y_\\lambda \\in \\mathbb{R}^n$ 的分量为：\n$$\n(y_\\lambda)_i =\n\\begin{cases}\n\\frac{\\sigma_i (U^T b)_i}{\\sigma_i^2 + \\lambda^2}  \\text{for } 1 \\le i \\le k \\\\\n0  \\text{for } k  i \\le n\n\\end{cases}\n$$\n最后，我们使用 $x = V y$ 将解 $y_\\lambda$ 转换回原始变量 $x_\\lambda$：\n$$\nx_\\lambda = V y_\\lambda = \\sum_{i=1}^k (y_\\lambda)_i v_i\n$$\n其中 $v_i$ 是 $V$ 的列向量（或 $V^T$ 的行向量）。\n\n这就得到了以下数值稳定的算法：\n1.  计算 $A = U \\Sigma V^T$ 的完整 SVD。\n2.  计算变换后的向量 $c = U^T b$。\n3.  对于网格中每个期望的 $\\lambda$：\n    a. 初始化一个 $n$ 维零向量 $y_\\lambda$。\n    b. 对于 $i=1, \\dots, k=\\min(m,n)$，计算 $(y_\\lambda)_i = \\frac{\\sigma_i c_i}{\\sigma_i^2 + \\lambda^2}$。\n    c. 计算解 $x_\\lambda = V y_\\lambda$。\n该算法避免了 $A^T A$ 的构建，并依赖于稳健的 SVD 计算，使其在数值上更优越。它能正确处理秩亏和病态矩阵。\n\n### 性质验证\n\n该问题要求检查三个性质：\n1.  **范数的单调收缩**：我们必须验证 $\\lVert x_\\lambda \\rVert_2$ 是 $\\lambda$ 的一个非增函数。解析上，$\\lVert x_\\lambda \\rVert_2^2 = \\lVert y_\\lambda \\rVert_2^2 = \\sum_{i=1}^k \\left(\\frac{\\sigma_i c_i}{\\sigma_i^2 + \\lambda^2}\\right)^2$。和中的每一项都是 $\\lambda \\ge 0$ 的非增函数，因此它们的和也是非增的。所以，该性质预计在数值精度范围内成立。\n\n2.  **小 $\\lambda$ 极限**：当 $\\lambda \\to 0$ 时，$x_\\lambda$ 应趋近于最小范数最小二乘解 $x_{\\mathrm{lsq}} = A^+ b$，其中 $A^+$ 是 $A$ 的 Moore-Penrose 伪逆。根据我们的推导，当 $\\lambda \\to 0$ 时：\n    $$\n    (y_\\lambda)_i \\to\n    \\begin{cases}\n    c_i / \\sigma_i  \\text{if } \\sigma_i  0 \\\\\n    0  \\text{if } \\sigma_i = 0\n    \\end{cases}\n    $$\n    这个极限向量恰好是 $\\Sigma^+ c$。因此，$x_0 = V \\Sigma^+ c = V \\Sigma^+ U^T b = A^+ b$。该性质预计成立。\n\n3.  **大 $\\lambda$ 极限**：当 $\\lambda \\to \\infty$ 时，分母 $\\sigma_i^2 + \\lambda^2$ 增大，使得每个 $(y_\\lambda)_i \\to 0$。因此，$y_\\lambda \\to 0$ 且 $x_\\lambda = V y_\\lambda \\to 0$。系数预计将收缩至零。\n\n实现部分将生成测试用例，应用基于 SVD 的算法，并经验性地验证这三个性质。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import svd\n\ndef solve():\n    \"\"\"\n    为四个测试用例解决吉洪诺夫正则化问题，\n    并验证正则化路径的理论性质。\n    \"\"\"\n    test_cases_params = [\n        # (m, n, seed)\n        (80, 20, 42),\n        (50, 100, 123),\n        (40, 40, 7),\n        (60, 20, 314),\n    ]\n\n    all_results = []\n\n    for i, params in enumerate(test_cases_params):\n        m, n, seed = params\n        rng = np.random.default_rng(seed)\n\n        if i == 0:  # 用例1：良态，超定\n            A = rng.standard_normal((m, n))\n            x_true = rng.standard_normal(n)\n            epsilon = rng.standard_normal(m) * 0.01\n            b = A @ x_true + epsilon\n        elif i == 1:  # 用例2：欠定\n            A = rng.standard_normal((m, n))\n            x_true = rng.standard_normal(n)\n            epsilon = rng.standard_normal(m) * 0.01\n            b = A @ x_true + epsilon\n        elif i == 2:  # 用例3：秩亏\n            A = rng.standard_normal((m, n))\n            A[:, 10] = A[:, 5]\n            A[:, 15] = A[:, 5]\n            x_true = rng.standard_normal(n)\n            epsilon = rng.standard_normal(m) * 0.01\n            b = A @ x_true + epsilon\n        elif i == 3:  # 用例4：病态\n            G = rng.standard_normal((m, n))\n            A = np.zeros_like(G)\n            for j in range(n):\n                A[:, j] = G[:, j] * (10**(-j / 3.0))\n            x_true = rng.standard_normal(n)\n            epsilon = rng.standard_normal(m) * 0.01\n            b = A @ x_true + epsilon\n\n        # 正则化路径计算\n        lambda_grid = np.logspace(-10, 6, 60)\n        \n        # 基于SVD的解法\n        U, s, Vt = svd(A, full_matrices=True)\n        k = len(s)\n        V = Vt.T\n        c = U.T @ b\n\n        x_path = []\n        for lam in lambda_grid:\n            y = np.zeros(n)\n            y[:k] = (s * c[:k]) / (s**2 + lam**2)\n            x_lam = V @ y\n            x_path.append(x_lam)\n\n        x_path_norms = [np.linalg.norm(x) for x in x_path]\n\n        # 验证性检查\n        \n        # 1. 系数欧几里得范数的单调收缩\n        is_monotone = True\n        for k_idx in range(1, len(x_path_norms)):\n            norm_prev = x_path_norms[k_idx - 1]\n            norm_curr = x_path_norms[k_idx]\n            # 由于 lambda 网格是递增的，范数应为非增的\n            tolerance = 1e-12 * max(1, norm_prev)\n            if norm_curr > norm_prev + tolerance:\n                is_monotone = False\n                break\n        \n        # 2. 在小 lambda 下与最小二乘解的近似一致性\n        x_lsq = np.linalg.pinv(A) @ b\n        norm_x_lsq = np.linalg.norm(x_lsq)\n        x_lambda_min = x_path[0]\n        \n        rel_diff_small_lambda = np.linalg.norm(x_lambda_min - x_lsq) / max(1, norm_x_lsq)\n        agrees_at_small_lambda = rel_diff_small_lambda  1e-6\n        \n        # 3. 在非常大的 lambda 下系数趋近于零\n        x_lambda_max = x_path[-1]\n        norm_x_lambda_max = np.linalg.norm(x_lambda_max)\n        \n        ratio_large_lambda = norm_x_lambda_max / max(1, norm_x_lsq)\n        zero_at_large_lambda = ratio_large_lambda  1e-6\n\n        all_results.extend([is_monotone, agrees_at_small_lambda, zero_at_large_lambda])\n\n    # 按确切要求的格式进行最终打印输出。\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        }
    ]
}