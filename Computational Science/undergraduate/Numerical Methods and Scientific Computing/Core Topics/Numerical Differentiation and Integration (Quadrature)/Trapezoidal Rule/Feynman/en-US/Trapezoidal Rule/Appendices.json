{
    "hands_on_practices": [
        {
            "introduction": "To begin, let's ground the trapezoidal rule in a tangible application from physics. This problem asks us to approximate the work done when compressing a gas, which involves integrating a variable force function . By breaking the process into a small number of steps, you will practice the fundamental mechanics of applying the trapezoidal rule and reinforce its connection to the concept of area under a curve.",
            "id": "2222091",
            "problem": "In a materials science experiment, a piston is used to compress a gas in a cylinder. The process is carried out slowly, so it can be considered quasi-static and isothermal. The force $F$ required to hold the piston at a position $x$ (measured from the closed end of the cylinder) is found to vary according to the law $F(x) = \\frac{k}{x}$, where $k$ is a constant related to the temperature and the amount of gas.\n\nTo move the piston and compress the gas, work must be done. The exact work $W$ done by an external agent to move the piston from an initial position $x_i$ to a final position $x_f$ is given by the integral $W = \\int_{x_i}^{x_f} F(x) dx$.\n\nSuppose the piston is moved from $x_i = 1$ m to $x_f = 3$ m, and the constant $k$ is equal to 1 N·m. You are tasked with finding an approximate value for the work done. The approximation method consists of the following steps:\n1. Divide the total displacement interval $[x_i, x_f]$ into two subintervals of equal length.\n2. For each subinterval, approximate the area under the force-displacement curve by the area of a trapezoid formed by the x-axis, the vertical lines at the subinterval's endpoints, and the straight line segment connecting the force values at these endpoints.\n3. Sum the areas of these two trapezoids to get the total approximate work.\n\nUsing this method, calculate the approximate work done to move the piston. Express your answer in Joules as a simplified fraction.",
            "solution": "The problem asks for an approximation of the work done, $W$, by moving a piston against a force $F(x) = \\frac{k}{x}$ from $x_i = 1$ m to $x_f = 3$ m. We are given $k = 1$ N·m. The work is given by the integral:\n$$W = \\int_{1}^{3} \\frac{1}{x} dx$$\n\nThe problem describes a numerical approximation method which is equivalent to the composite trapezoidal rule with two segments. Let the interval be $[a, b] = [1, 3]$ and the number of segments be $n=2$. The function to integrate is $f(x) = \\frac{1}{x}$.\n\nFirst, we calculate the width, $h$, of each subinterval:\n$$h = \\frac{b - a}{n} = \\frac{3 - 1}{2} = 1$$\n\nThe two subintervals are $[1, 2]$ and $[2, 3]$. The evaluation points (the endpoints of the subintervals) are $x_0 = 1$, $x_1 = 2$, and $x_2 = 3$.\n\nThe approximation method described is to sum the areas of two trapezoids.\nThe area of the first trapezoid, over the interval $[x_0, x_1]$, is:\n$$A_1 = \\frac{h}{2} (f(x_0) + f(x_1))$$\nThe area of the second trapezoid, over the interval $[x_1, x_2]$, is:\n$$A_2 = \\frac{h}{2} (f(x_1) + f(x_2))$$\n\nThe total approximate work $W_{approx}$ is the sum of these two areas:\n$$W_{approx} = A_1 + A_2 = \\frac{h}{2}(f(x_0) + f(x_1)) + \\frac{h}{2}(f(x_1) + f(x_2))$$\nThis can be simplified to the standard composite trapezoidal rule formula:\n$$W_{approx} = \\frac{h}{2} (f(x_0) + 2f(x_1) + f(x_2))$$\n\nNow we evaluate the function $f(x) = \\frac{1}{x}$ at the points $x_0, x_1, x_2$:\n$$f(x_0) = f(1) = \\frac{1}{1} = 1$$\n$$f(x_1) = f(2) = \\frac{1}{2}$$\n$$f(x_2) = f(3) = \\frac{1}{3}$$\n\nNow, we substitute these values into the formula for $W_{approx}$. We also substitute $h=1$.\n$$W_{approx} = \\frac{1}{2} \\left( 1 + 2\\left(\\frac{1}{2}\\right) + \\frac{1}{3} \\right)$$\n\nWe simplify the expression inside the parentheses:\n$$W_{approx} = \\frac{1}{2} \\left( 1 + 1 + \\frac{1}{3} \\right)$$\n$$W_{approx} = \\frac{1}{2} \\left( 2 + \\frac{1}{3} \\right)$$\n\nTo add the terms inside the parentheses, we find a common denominator:\n$$W_{approx} = \\frac{1}{2} \\left( \\frac{6}{3} + \\frac{1}{3} \\right)$$\n$$W_{approx} = \\frac{1}{2} \\left( \\frac{7}{3} \\right)$$\n\nFinally, we perform the multiplication:\n$$W_{approx} = \\frac{7}{6}$$\n\nThe problem states that $k$ is in N·m and $x$ is in m, so the work $W$ is in Joules. The problem asks for the answer in Joules, expressed as a simplified fraction. Our result is $7/6$.",
            "answer": "$$\\boxed{\\frac{7}{6}}$$"
        },
        {
            "introduction": "While applying a numerical rule is straightforward, a crucial question in any scientific application is: how accurate is the result? This exercise explores the practical side of error analysis within a biomedical context, where you must determine the number of measurements needed to ensure the total drug exposure is calculated to a specific precision . Successfully solving this problem requires combining the trapezoidal rule's error formula with calculus to find the maximum curvature of the function, a key skill for guaranteeing the reliability of numerical approximations.",
            "id": "2210520",
            "problem": "In a pharmacokinetic study, the concentration of a new drug in a patient's bloodstream is modeled as a function of time, $t$, by the equation $C(t) = C_0 \\exp(-kt^2)$. Here, $t$ is the time in hours after injection, $C_0 = 50$ mg/L is the initial concentration, and $k = 0.5 \\text{ hr}^{-2}$ is a constant related to the drug's elimination rate.\n\nTo assess the total drug exposure over the first two hours, a biomedical engineer needs to calculate the Area Under the Curve (AUC), which is given by the definite integral $A = \\int_{0}^{T} C(t) dt$ with $T=2$ hours.\n\nThe engineer uses a numerical approximation method. The time interval $[0, T]$ is divided into $n$ equal subintervals, and the value of the integral is approximated by summing the areas of the trapezoids formed by connecting the points $(t_i, C(t_i))$ and $(t_{i+1}, C(t_{i+1}))$ for each subinterval.\n\nFor this specific numerical method, the absolute error, $|E_n|$, is known to be bounded by the inequality:\n$$|E_n| \\le \\frac{M(T-0)^3}{12n^2}$$\nwhere $M$ is the maximum absolute value of the second derivative of the concentration function, $M = \\max_{t \\in [0, T]} |C''(t)|$.\n\nDetermine the minimum integer number of subintervals, $n$, that the engineer must use to guarantee that the absolute error in the calculated AUC is less than $10^{-3}$ mg·hr/L.",
            "solution": "We are given $C(t) = C_{0}\\exp(-k t^{2})$ with $C_{0} = 50$ and $k = 0.5$, and the trapezoidal rule error bound\n$$|E_{n}| \\le \\frac{M(T-0)^{3}}{12 n^{2}}, \\quad M = \\max_{t \\in [0,T]} |C''(t)|, \\quad T=2.$$\n\nFirst compute $C''(t)$. Differentiating,\n$$C'(t) = C_{0}\\exp(-k t^{2})(-2 k t),$$\n$$C''(t) = C_{0}\\exp(-k t^{2})\\left(-2k + 4k^{2} t^{2}\\right) = 2k C_{0}\\exp(-k t^{2})\\left(-1 + 2k t^{2}\\right).$$\nThus\n$$|C''(t)| = 2k C_{0}\\exp(-k t^{2})\\left| -1 + 2k t^{2} \\right|.$$\n\nLet $t_{0} = \\frac{1}{\\sqrt{2k}}$. For $t \\in [0,t_{0}]$, we have $-1 + 2k t^{2} \\le 0$, so\n$$|C''(t)| = 2k C_{0}\\exp(-k t^{2})\\left(1 - 2k t^{2}\\right).$$\nDefine $h_{1}(t) = 2k C_{0}\\exp(-k t^{2})(1 - 2k t^{2})$. Its derivative is\n$$h_{1}'(t) = 4 k^{2} C_{0} t \\exp(-k t^{2})\\left(-3 + 2k t^{2}\\right).$$\nOn $(0,t_{0}]$, since $t_{0}^{2} = \\frac{1}{2k}$, we have $-3 + 2k t^{2} \\le -3 + 1 = -2 < 0$, hence $h_{1}'(t) < 0$. Therefore $h_{1}$ is decreasing on $[0,t_{0}]$ and attains its maximum at $t=0$:\n$$h_{1}(0) = 2k C_{0}.$$\n\nFor $t \\in [t_{0},T]$, we have $-1 + 2k t^{2} \\ge 0$, so\n$$|C''(t)| = 2k C_{0}\\exp(-k t^{2})\\left(-1 + 2k t^{2}\\right).$$\nDefine $h_{2}(t) = 2k C_{0}\\exp(-k t^{2})(-1 + 2k t^{2})$. Its derivative is\n$$h_{2}'(t) = 4 k^{2} C_{0} t \\exp(-k t^{2})\\left(3 - 2k t^{2}\\right).$$\nCritical points in $[t_{0},T]$ occur at $t = \\sqrt{\\frac{3}{2k}}$ if this lies in the interval. With $k = 0.5$, we have $t_{0} = 1$, $T=2$, and $\\sqrt{\\frac{3}{2k}} = \\sqrt{3} \\in [1,2]$. Evaluate $h_{2}$ at candidates:\n- At $t = t_{0}$, $h_{2}(t_{0}) = 0$.\n- At $t = \\sqrt{\\frac{3}{2k}}$, since $2k t^{2} = 3$,\n$$h_{2}\\!\\left(\\sqrt{\\frac{3}{2k}}\\right) = 2k C_{0} \\cdot 2 \\cdot \\exp\\!\\left(-\\frac{3}{2}\\right) = 4k C_{0}\\exp\\!\\left(-\\frac{3}{2}\\right).$$\n- At $t = T=2$,\n$$h_{2}(2) = 2k C_{0}\\left(-1 + 8k\\right)\\exp(-4k).$$\n\nCompare these to $2k C_{0}$. Note that\n$$4k C_{0}\\exp\\!\\left(-\\frac{3}{2}\\right) = 2k C_{0}\\cdot 2\\exp\\!\\left(-\\frac{3}{2}\\right) < 2k C_{0}$$\nbecause $\\exp\\!\\left(\\frac{3}{2}\\right) > 2$, hence $2\\exp(-\\frac{3}{2}) < 1$. Also $h_{2}(2)$ is smaller than $2k C_{0}$ for $k=0.5$. Therefore the maximum over $[0,2]$ is attained at $t=0$:\n$$M = \\max_{t \\in [0,2]} |C''(t)| = 2k C_{0} = 2 \\cdot 0.5 \\cdot 50 = 50.$$\n\nApply the error bound with $T=2$:\n$$|E_{n}| \\le \\frac{M T^{3}}{12 n^{2}} = \\frac{50 \\cdot 2^{3}}{12 n^{2}} = \\frac{100}{3 n^{2}}.$$\nRequire $|E_{n}| < 10^{-3}$:\n$$\\frac{100}{3 n^{2}} < 10^{-3} \\quad \\Longleftrightarrow \\quad n^{2} > \\frac{100}{3 \\cdot 10^{-3}} = \\frac{100000}{3}.$$\nThus $n > \\sqrt{\\frac{100000}{3}}$. Since $182^{2} = 33124 < \\frac{100000}{3} < 33489 = 183^{2}$, the minimal integer $n$ satisfying the inequality is\n$$n = 183.$$",
            "answer": "$$\\boxed{183}$$"
        },
        {
            "introduction": "Our final practice moves from applying a static rule to building an intelligent, dynamic algorithm. You are tasked with designing a simple adaptive quadrature scheme, a method that automatically concentrates its effort on the most challenging parts of a function . By comparing a one-trapezoid approximation with a two-trapezoid one, you will create a local error estimate that drives recursive subdivision, laying the foundation for the sophisticated and efficient integration tools used widely in scientific software.",
            "id": "3284305",
            "problem": "Implement a program that approximates definite integrals using a simple adaptive quadrature scheme based on the trapezoidal rule. The method must estimate the local error on an interval by comparing the trapezoidal approximation on the full interval against the sum of trapezoidal approximations on its two halves, and it must recursively subdivide intervals until the estimated local error is within a user-specified absolute tolerance or a specified maximum recursion depth is reached. The algorithmic design should be explained by first principles and the program must be self-contained.\n\nYour program must follow these specifications.\n\n- Fundamental base to use for the derivation and design: the definition of a definite integral as a limit of Riemann sums, the concept of piecewise-linear interpolation, and the basic properties of differentiable functions. You must not use or state any shortcut formula for the trapezoidal rule or its error in the problem statement. The implementation must be based on comparing the area computed by joining the endpoints of the interval with a straight line segment versus the summed areas computed by joining endpoints within each half-interval.\n\n- Inputs are fixed by the test suite; there is no user input. The program must:\n    1. Approximate the integral of a given function $f(x)$ over an interval $[a,b]$ by recursively halving subintervals and accepting a subinterval’s approximation when the local error estimate, computed by comparing the coarse single-interval trapezoid against the two half-interval trapezoids, is less than or equal to a given absolute tolerance.\n    2. Use a maximum recursion depth limit to prevent infinite subdivision; when the limit is reached before satisfying the tolerance, it must accept the current finest subdivision’s estimate without further refinement.\n    3. Handle the boundary case $a=b$ by returning $0$.\n\n- Angle unit: whenever trigonometric functions appear, angles must be taken in radians.\n\n- Output format: your program should produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets. For example, it should look like $[r_1,r_2,r_3,\\dots]$, where each $r_i$ is the floating-point approximation for test case $i$.\n\n- Test suite to implement and evaluate:\n    1. Smooth, non-polynomial case (happy path): $f_1(x)=e^{-x^2}$ on $[a,b]=[0,1]$ with absolute tolerance $\\tau=10^{-6}$ and maximum recursion depth $D=20$. There is no physical unit; output is dimensionless.\n    2. Highly oscillatory case: $f_2(x)=\\sin(20x)$ on $[a,b]=[0,\\pi]$ with absolute tolerance $\\tau=10^{-6}$ and maximum recursion depth $D=20$. Angles are in radians; output is dimensionless.\n    3. Non-smooth case with a corner: $f_3(x)=|x-0.3|$ on $[a,b]=[0,1]$ with absolute tolerance $\\tau=10^{-6}$ and maximum recursion depth $D=20$. Output is dimensionless.\n    4. Boundary case: $f_4(x)=\\cos(x)$ on $[a,b]=[\\pi,\\pi]$ with absolute tolerance $\\tau=10^{-12}$ and maximum recursion depth $D=20$. Angles are in radians; output is dimensionless.\n    5. Discontinuous case: the right-continuous unit step $f_5(x)=H(x-0.7)$ where $H(x-0.7)=0$ for $x < 0.7$ and $H(x-0.7)=1$ for $x >= 0.7$, on $[a,b]=[0,1]$ with absolute tolerance $\\tau=10^{-6}$ and maximum recursion depth $D=20$. Output is dimensionless.\n\n- Required final output format: your program must print a single line in the format $[r_1,r_2,r_3,r_4,r_5]$, where $r_i$ is the computed floating-point approximation for test case $i$ in the order listed above, with no additional text. Each $r_i$ must be a standard floating-point literal.\n\nEnsure scientific realism and internal consistency. The method must be implemented from first principles as described above, without relying on pre-specified shortcut formulas in the problem statement. The implementation details, including the justification of the local error estimate and recursive acceptance criterion, must be explained in the solution.",
            "solution": "The problem requires the implementation of an adaptive quadrature algorithm to approximate a definite integral $\\int_a^b f(x) dx$. The algorithm is to be based on recursive subdivision of the integration interval, using an error estimate derived from comparing two different approximations based on the trapezoidal rule.\n\nFirst, we establish the fundamental principle of the trapezoidal rule. The definite integral $\\int_a^b f(x) dx$ represents the area under the curve of the function $y = f(x)$ between $x=a$ and $x=b$. The simplest non-trivial method to approximate this area is to replace the curve $y=f(x)$ with a single straight line segment connecting the points $(a, f(a))$ and $(b, f(b))$. The area under this line segment forms a trapezoid with vertices at $(a, 0)$, $(b, 0)$, $(b, f(b))$, and $(a, f(a))$. The area of this single, or coarse, trapezoid, which we denote as $I_1$, is given by the formula for a trapezoid's area:\n$$\nI_1 = (b-a) \\frac{f(a) + f(b)}{2}\n$$\n\nThis approximation is accurate only if the function $f(x)$ is nearly linear over the interval $[a, b]$. To improve the approximation, we can apply the same principle over smaller segments of the interval. A natural refinement is to subdivide the interval $[a, b]$ into two equal halves, $[a, m]$ and $[m, b]$, where $m = (a+b)/2$ is the midpoint. We then approximate the integral as the sum of the areas of two trapezoids, one for each subinterval.\n\nThe area of the first trapezoid over $[a, m]$ is $(m-a) \\frac{f(a) + f(m)}{2}$.\nThe area of the second trapezoid over $[m, b]$ is $(b-m) \\frac{f(m) + f(b)}{2}$.\n\nSince $m-a = b-m = (b-a)/2$, the sum of these two areas, which we denote as the fine approximation $I_2$, is:\n$$\nI_2 = \\frac{b-a}{4} (f(a) + f(m)) + \\frac{b-a}{4} (f(m) + f(b)) = \\frac{b-a}{4} (f(a) + 2f(m) + f(b))\n$$\n\nThe adaptive nature of the required algorithm is based on a local error estimate. The problem specifies that this estimate is to be derived by comparing the coarse approximation $I_1$ with the more refined approximation $I_2$. The absolute difference, $E_{est} = |I_2 - I_1|$, provides a measure of how much the approximation changes upon refinement. For a sufficiently smooth function, this difference is related to the true error of the finer approximation $I_2$. A large difference suggests that the function is not well-approximated by a single line segment over $[a, b]$ and that further subdivision is necessary.\n\nThe core of the algorithm is a recursive procedure. Let us define a function that integrates $f(x)$ over an interval $[a, b]$ with a given absolute error tolerance $\\tau$.\n\n1.  **Termination and Base Cases**: The recursion must have well-defined termination conditions.\n    *   If the interval is degenerate, i.e., $a=b$, the integral is exactly $0$.\n    *   To prevent infinite recursion (e.g., for functions with singularities or in regions of high oscillation), a maximum recursion depth, $D$, is imposed. If the current recursion depth reaches $D$, the process must stop and return the best available estimate for the current interval, which is the fine approximation $I_2$.\n\n2.  **Recursive Step**: For a given interval $[a, b]$ and tolerance $\\tau$:\n    *   Calculate the coarse approximation $I_1$ and the fine approximation $I_2$.\n    *   Compute the error estimate $E_{est} = |I_2 - I_1|$.\n    *   **Decision Criterion**: Compare the error estimate with the tolerance $\\tau$.\n        *   If $E_{est} \\le \\tau$, the fine approximation $I_2$ is deemed sufficiently accurate for the current interval $[a, b]$. The value $I_2$ is returned.\n        *   If $E_{est} > \\tau$, the interval must be subdivided. The integral over $[a, b]$ is the sum of the integrals over its two halves: $\\int_a^b f(x) dx = \\int_a^m f(x) dx + \\int_m^b f(x) dx$. The algorithm then calls itself recursively for each subinterval. The total error tolerance $\\tau$ must be distributed among the subproblems. A simple and effective strategy is to require the error on each half to be bounded by $\\tau/2$. Therefore, the recursive calls will be for the interval $[a, m]$ with tolerance $\\tau/2$ and for $[m, b]$ with tolerance $\\tau/2$. The results of these two recursive calls are then summed to produce the result for the original interval $[a,b]$.\n\nTo improve efficiency, function evaluations, which can be computationally expensive, should be minimized. When subdividing, the function values at the endpoints of the parent interval, $f(a)$ and $f(b)$, as well as at the midpoint $f(m)$, are already known. These values can be passed down to the recursive calls for the subintervals $[a, m]$ and $[m, b]$ to avoid redundant computations. For instance, the call for $[a, m]$ can be provided with $f(a)$ and $f(m)$, and the call for $[m, b]$ can be provided with $f(m)$ and $f(b)$.\n\nThe overall algorithm is initiated by calling this recursive procedure on the main interval $[a, b]$ with the user-specified total tolerance $\\tau$ and an initial recursion depth of $0$. This design ensures that the algorithm concentrates its computational effort on regions where the function is \"difficult\" (i.e., highly non-linear), while quickly accepting approximations over regions where the function is \"easy\" (i.e., nearly linear).",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef _recursive_asr(f, a, b, tol, max_depth, depth, fa, fb):\n    \"\"\"\n    Recursive helper function for adaptive trapezoidal quadrature.\n\n    This function implements the core logic of subdividing the interval,\n    estimating the error, and deciding whether to accept the current\n    approximation or recurse further.\n    \n    Args:\n        f (callable): The function to integrate.\n        a (float): The start of the interval.\n        b (float): The end of the interval.\n        tol (float): The error tolerance for this interval.\n        max_depth (int): The maximum allowed recursion depth.\n        depth (int): The current recursion depth.\n        fa (float): The value of f(a), pre-computed.\n        fb (float): The value of f(b), pre-computed.\n\n    Returns:\n        float: The approximate value of the integral over [a, b].\n    \"\"\"\n    # Calculate midpoint and function value at midpoint\n    m = (a + b) / 2.0\n    fm = f(m)\n\n    # Coarse approximation (1 trapezoid over [a,b])\n    # I_1 = (b-a) * (f(a) + f(b)) / 2\n    i1 = (b - a) * (fa + fb) / 2.0\n\n    # Fine approximation (2 trapezoids over [a,m] and [m,b])\n    # I_2 = (m-a)*(f(a)+f(m))/2 + (b-m)*(f(m)+f(b))/2\n    # which simplifies to:\n    i2 = (b - a) / 4.0 * (fa + 2*fm + fb)\n\n    # If max depth is reached, accept the finest estimate available (i2)\n    # and terminate this branch of recursion.\n    if depth >= max_depth:\n        return i2\n\n    # Estimate the local error by comparing the coarse and fine approximations.\n    error_estimate = abs(i2 - i1)\n\n    # If the error estimate is within the tolerance for this interval,\n    # accept the more accurate approximation (i2) and return it.\n    if error_estimate = tol:\n        return i2\n    else:\n        # If the error is too large, subdivide the interval.\n        # The tolerance is split between the two new subproblems.\n        left_integral = _recursive_asr(f, a, m, tol / 2.0, max_depth, depth + 1, fa, fm)\n        right_integral = _recursive_asr(f, m, b, tol / 2.0, max_depth, depth + 1, fm, fb)\n        return left_integral + right_integral\n\ndef integrate(f, a, b, tol, max_depth):\n    \"\"\"\n    Public interface for the adaptive quadrature algorithm.\n\n    Args:\n        f (callable): The function to integrate.\n        a (float): The start of the integration interval.\n        b (float): The end of the integration interval.\n        tol (float): The desired absolute error tolerance for the total integral.\n        max_depth (int): The maximum recursion depth.\n\n    Returns:\n        float: The approximated definite integral.\n    \"\"\"\n    # Handle the boundary case where the interval is of zero width.\n    if a == b:\n        return 0.0\n\n    # Pre-compute function values at endpoints for the initial call.\n    fa = f(a)\n    fb = f(b)\n\n    # Initiate the recursive process.\n    return _recursive_asr(f, a, b, tol, max_depth, 0, fa, fb)\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite for the adaptive quadrature implementation.\n    \"\"\"\n    \n    # Test Suite Definition\n    # Each tuple contains: (function, interval_start, interval_end, tolerance, max_depth)\n    test_cases = [\n        # 1. Smooth, non-polynomial case\n        (lambda x: np.exp(-x**2), 0.0, 1.0, 1e-6, 20),\n        \n        # 2. Highly oscillatory case\n        (lambda x: np.sin(20 * x), 0.0, np.pi, 1e-6, 20),\n        \n        # 3. Non-smooth case with a corner\n        (lambda x: np.abs(x - 0.3), 0.0, 1.0, 1e-6, 20),\n        \n        # 4. Boundary case\n        (lambda x: np.cos(x), np.pi, np.pi, 1e-12, 20),\n        \n        # 5. Discontinuous case\n        # H(x-0.7)=0 for x  0.7, 1 for x >= 0.7.\n        # np.heaviside with the second argument as 1 makes it right-continuous.\n        (lambda x: np.heaviside(x - 0.7, 1), 0.0, 1.0, 1e-6, 20)\n    ]\n\n    results = []\n    for f, a, b, tol, max_depth in test_cases:\n        result = integrate(f, a, b, tol, max_depth)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}