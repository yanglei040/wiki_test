{
    "hands_on_practices": [
        {
            "introduction": "本练习是您学习过程的第一步，旨在巩固您对如何应用基本牛顿-柯特斯公式的理解。我们将使用复合梯形法则来近似一个常见的值 $\\ln(3)$，该值可以通过一个积分来定义。这个练习将帮助您建立设置和执行数值积分问题的基础技能。",
            "id": "2190937",
            "problem": "自然对数$\\ln(3)$的值可以表示为定积分$I = \\int_1^3 \\frac{1}{x} dx$。在不使用计算器直接计算对数或积分的情况下，您的任务是求出该值的数值近似值。\n\n应用具有$n=4$个子区间的复化梯形法则来近似积分$I$的值。请将您的答案表示为最简分数形式。",
            "solution": "题目要求我们使用具有$n=4$个子区间的复化梯形法则来近似积分$I = \\int_1^3 \\frac{1}{x} dx$。\n\n对于函数$f(x)$在区间$[a, b]$上使用$n$个子区间的复化梯形法则的公式为：\n$$T_n(f) = \\frac{h}{2} \\left[ f(x_0) + 2\\sum_{i=1}^{n-1} f(x_i) + f(x_n) \\right]$$\n其中步长为$h = \\frac{b-a}{n}$，网格点为$x_i = a + i \\cdot h$，其中$i = 0, 1, 2, \\dots, n$。\n\n在本题中，我们有：\n- 被积函数: $f(x) = \\frac{1}{x}$\n- 积分区间: $[a, b] = [1, 3]$\n- 子区间数量: $n=4$\n\n首先，我们计算步长$h$：\n$$h = \\frac{b-a}{n} = \\frac{3-1}{4} = \\frac{2}{4} = \\frac{1}{2}$$\n\n接下来，我们确定网格点$x_i$，$i = 0, 1, 2, 3, 4$：\n- $x_0 = a = 1$\n- $x_1 = 1 + 1 \\cdot \\frac{1}{2} = \\frac{3}{2}$\n- $x_2 = 1 + 2 \\cdot \\frac{1}{2} = 2$\n- $x_3 = 1 + 3 \\cdot \\frac{1}{2} = \\frac{5}{2}$\n- $x_4 = b = 1 + 4 \\cdot \\frac{1}{2} = 3$\n\n现在，我们在这些网格点上计算函数$f(x) = \\frac{1}{x}$的值：\n- $f(x_0) = f(1) = \\frac{1}{1} = 1$\n- $f(x_1) = f\\left(\\frac{3}{2}\\right) = \\frac{1}{3/2} = \\frac{2}{3}$\n- $f(x_2) = f(2) = \\frac{1}{2}$\n- $f(x_3) = f\\left(\\frac{5}{2}\\right) = \\frac{1}{5/2} = \\frac{2}{5}$\n- $f(x_4) = f(3) = \\frac{1}{3}$\n\n现在我们将这些值代入复化梯形法则公式：\n$$T_4(f) = \\frac{h}{2} [f(x_0) + 2f(x_1) + 2f(x_2) + 2f(x_3) + f(x_4)]$$\n$$T_4(f) = \\frac{1/2}{2} \\left[ 1 + 2\\left(\\frac{2}{3}\\right) + 2\\left(\\frac{1}{2}\\right) + 2\\left(\\frac{2}{5}\\right) + \\frac{1}{3} \\right]$$\n$$T_4(f) = \\frac{1}{4} \\left[ 1 + \\frac{4}{3} + 1 + \\frac{4}{5} + \\frac{1}{3} \\right]$$\n\n我们通过组合项来简化方括号内的表达式：\n$$T_4(f) = \\frac{1}{4} \\left[ (1 + 1) + \\left(\\frac{4}{3} + \\frac{1}{3}\\right) + \\frac{4}{5} \\right]$$\n$$T_4(f) = \\frac{1}{4} \\left[ 2 + \\frac{5}{3} + \\frac{4}{5} \\right]$$\n\n为了对方括号内的项求和，我们找到公分母，即$3 \\times 5 = 15$：\n$$2 + \\frac{5}{3} + \\frac{4}{5} = \\frac{2 \\cdot 15}{15} + \\frac{5 \\cdot 5}{15} + \\frac{4 \\cdot 3}{15} = \\frac{30}{15} + \\frac{25}{15} + \\frac{12}{15}$$\n$$= \\frac{30 + 25 + 12}{15} = \\frac{67}{15}$$\n\n最后，我们将此结果代回到$T_4(f)$的表达式中：\n$$T_4(f) = \\frac{1}{4} \\left( \\frac{67}{15} \\right) = \\frac{67}{4 \\cdot 15} = \\frac{67}{60}$$\n\n数字67是一个质数，而60不能被67整除。因此，分数$\\frac{67}{60}$是最简形式。",
            "answer": "$$\\boxed{\\frac{67}{60}}$$"
        },
        {
            "introduction": "数值方法之间常常存在着巧妙的联系。本练习将揭示，更为精确的辛普森法则可以通过巧妙地组合两次应用较简单的梯形法则来得到，这一过程被称为理查德森外推（Richardson extrapolation）。通过在代码中实现这一点，您不仅将验证这一重要的理论结果，还将在数值分析方面获得宝贵的编程实践经验。",
            "id": "3256181",
            "problem": "你需要编写一个完整的、可运行的程序，该程序针对一系列测试用例，在数值上验证以下事实：将 Richardson 外推应用于具有 $N$ 个子区间和 $2N$ 个子区间的均匀网格上的复化梯形法则，其结果与具有 $2N$ 个子区间的复化 Simpson 法则所得的数值完全相同。你的实现和推理必须基于 Newton–Cotes 公式（复化梯形法则和复化 Simpson 法则）的标准定义以及由 Euler–Maclaurin 求和公式提供的渐近误差展开。除这些基础知识外，你不得假定任何专门的或特定于问题的结论。在适用的情况下，所有角度都必须以弧度为单位进行解释。\n\n代码中需要实现的任务：\n- 给定函数 $f$、区间 $[a,b]$ 和一个偶数整数 $M$，实现具有 $M$ 个宽度为 $h_M = (b-a)/M$ 的均匀子区间的复化 Simpson 法则。\n- 给定函数 $f$、区间 $[a,b]$ 和一个正整数 $N$，实现具有 $N$ 个宽度为 $h_N = (b-a)/N$ 的均匀子区间的复化梯形法则。\n- 通过消除渐近展开中的主阶误差项，利用在具有 $N$ 和 $2N$ 个子区间的网格上计算出的两个复化梯形近似值，构造一个 Richardson 外推估计值。使用这两个值形成一个单一的外推估计。\n- 对于下面的每个测试用例，将 Richardson 外推值与在具有 $2N$ 个子区间的网格上计算的复化 Simpson 值进行比较，并返回一个布尔值，指示它们的绝对差是否小于或等于容差 $\\tau = 10^{-12}$。\n\n测试套件：\n- 用例 1：函数 $f(x) = \\sin(x)$，区间 $[a,b] = [0,\\pi]$，$N = 10$。$\\sin$ 以弧度解释。\n- 用例 2：函数 $f(x) = x^{3} - 2x + 1$，区间 $[a,b] = [-1,2]$，$N = 8$。\n- 用例 3：函数 $f(x) = e^{x}$，区间 $[a,b] = [0,1]$，$N = 2$。\n- 用例 4：函数 $f(x) = \\dfrac{1}{1+x^{2}}$，区间 $[a,b] = [-3,3]$，$N = 64$。\n\n输入和输出格式要求：\n- 没有外部输入。程序必须能直接运行，并在内部应用上述测试套件。\n- 你的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果的顺序与上面列出的用例顺序一致。例如，输出必须是 $[r_1,r_2,r_3,r_4]$ 的形式，其中每个 $r_i$ 是一个布尔值。\n\n注意：\n- 所有计算都必须以稳定且高效的方式使用浮点运算执行。\n- 确保对于 Simpson 法则，$M = 2N$ 是偶数。不需要其他假设。",
            "solution": "该问题要求对数值积分中的一个基本恒等式进行数值验证：即对复化梯形法则应用一阶 Richardson 外推会得到复化 Simpson 法则。我们将首先从理论上建立这个恒等式，然后实现一个程序来对一组给定的测试用例进行验证。\n\n**理论基础**\n\n设 $I = \\int_a^b f(x) dx$ 是一个足够光滑的函数 $f(x)$ 在区间 $[a,b]$ 上定积分的精确值。\n\n**1. 复化梯形法则及其误差展开**\n\n复化梯形法则，记为 $T_N$，使用 $N$ 个等宽子区间（宽度 $h = (b-a)/N$）来近似 $I$。其公式为：\n$$ T_N = \\frac{h}{2} \\left( f(x_0) + 2\\sum_{i=1}^{N-1} f(x_i) + f(x_N) \\right) $$\n其中 $x_i = a + i h$。\n\nEuler-Maclaurin 求和公式为梯形法则的误差提供了渐近展开。当应用于 $T_N$（我们可将其写作 $T(h)$）时，展开式为：\n$$ T(h) = I + C_1 h^2 + C_2 h^4 + C_3 h^6 + \\dots $$\n系数 $C_k$ 与 $h$ 无关，取决于函数 $f(x)$ 在端点 $a$ 和 $b$ 处的导数。主误差项的阶为 $O(h^2)$。\n\n**2. Richardson 外推**\n\nRichardson 外推的目标是组合两个不同步长的近似值，通过消除主误差项来获得更精确的估计。我们使用两种不同数量的子区间来计算积分：$N$ 和 $2N$。相应的步长分别为 $h = (b-a)/N$ 和 $h/2 = (b-a)/(2N)$。设 $T_N = T(h)$ 和 $T_{2N} = T(h/2)$。它们的误差展开式为：\n$$ T_N = I + C_1 h^2 + C_2 h^4 + O(h^6) $$\n$$ T_{2N} = I + C_1 \\left(\\frac{h}{2}\\right)^2 + C_2 \\left(\\frac{h}{2}\\right)^4 + O(h^6) = I + \\frac{1}{4} C_1 h^2 + \\frac{1}{16} C_2 h^4 + O(h^6) $$\n我们得到了一个关于未知数 $I$ 和 $C_1 h^2$ 的二元线性方程组。为了消去 $C_1 h^2$ 项，我们计算 $4T_{2N} - T_N$：\n$$ 4T_{2N} - T_N = \\left( 4I + C_1 h^2 + \\frac{1}{4} C_2 h^4 \\right) - \\left( I + C_1 h^2 + C_2 h^4 \\right) + O(h^6) = 3I - \\frac{3}{4} C_2 h^4 + O(h^6) $$\n解出 $I$ 即可得到外推近似值，我们将其记为 $R_N$：\n$$ R_N = \\frac{4T_{2N} - T_N}{3} = I - \\frac{1}{4} C_2 h^4 + O(h^6) $$\n这个新的近似值 $R_N$ 的误差阶为 $O(h^4)$，相比梯形法则的 $O(h^2)$ 误差有了显著的改进。\n\n**3. 复化 Simpson 法则**\n\n复化 Simpson 法则要求偶数个子区间。我们考虑 $M = 2N$ 个子区间。步长为 $h' = (b-a)/M = (b-a)/(2N)$。这与用于 $T_{2N}$ 的步长相同。设节点为 $x_i = a + i h'$，$i=0, 1, \\dots, 2N$。复化 Simpson 法则（记为 $S_{2N}$）的公式为：\n$$ S_{2N} = \\frac{h'}{3} \\left( f(x_0) + 4\\sum_{j=1}^{N} f(x_{2j-1}) + 2\\sum_{j=1}^{N-1} f(x_{2j}) + f(x_{2N}) \\right) $$\n已知复化 Simpson 法则的误差阶为 $O((h')^4)$。\n\n**4. 恒等式：$R_N = S_{2N}$**\n\n我们现在来证明 Richardson 外推值 $R_N$ 在代数上与复化 Simpson 法则的值 $S_{2N}$ 是完全相同的。我们使用公共的节点集 $x_i = a + i h'$，其中 $h' = (b-a)/(2N)$，$i \\in \\{0, 1, \\dots, 2N\\}$。\n\n近似值 $T_{2N}$ 使用所有 $2N+1$ 个节点：\n$$ T_{2N} = \\frac{h'}{2} \\left( f(x_0) + 2\\sum_{i=1}^{2N-1} f(x_i) + f(x_{2N}) \\right) $$\n近似值 $T_N$ 使用的步长为 $h=2h'$。它的节点是来自更精细网格的偶数索引节点：$x_0, x_2, \\dots, x_{2N}$。\n$$ T_N = \\frac{2h'}{2} \\left( f(x_0) + 2\\sum_{j=1}^{N-1} f(x_{2j}) + f(x_{2N}) \\right) = h' \\left( f(x_0) + f(x_{2N}) + 2\\sum_{j=1}^{N-1} f(x_{2j}) \\right) $$\n现在，我们将这些表达式代入 $R_N = \\frac{4T_{2N} - T_N}{3}$ 的公式中。\n$$\n\\begin{aligned}\n4T_{2N} - T_N = 4 \\left( \\frac{h'}{2} \\left[ f(x_0) + f(x_{2N}) + 2\\sum_{j=1}^{N} f(x_{2j-1}) + 2\\sum_{j=1}^{N-1} f(x_{2j}) \\right] \\right) \\\\\n \\quad - h' \\left[ f(x_0) + f(x_{2N}) + 2\\sum_{j=1}^{N-1} f(x_{2j}) \\right] \\\\\n= h' \\left[ 2(f(x_0) + f(x_{2N})) + 4\\sum_{j=1}^{N} f(x_{2j-1}) + 4\\sum_{j=1}^{N-1} f(x_{2j}) \\right] \\\\\n \\quad - h' \\left[ f(x_0) + f(x_{2N}) + 2\\sum_{j=1}^{N-1} f(x_{2j}) \\right] \\\\\n= h' \\left[ (f(x_0) + f(x_{2N})) + 4\\sum_{j=1}^{N} f(x_{2j-1}) + 2\\sum_{j=1}^{N-1} f(x_{2j}) \\right]\n\\end{aligned}\n$$\n除以 $3$ 可得：\n$$ R_N = \\frac{4T_{2N} - T_N}{3} = \\frac{h'}{3} \\left[ f(x_0) + f(x_{2N}) + 4\\sum_{j=1}^{N} f(x_{2j-1}) + 2\\sum_{j=1}^{N-1} f(x_{2j}) \\right] $$\n这恰好是复化 Simpson 法则 $S_{2N}$ 的公式。因此，恒等式 $R_N \\equiv S_{2N}$ 得以建立。\n\n**结论**\n\n该推导证实，在精确算术中，对复化梯形法则的近似值 $T_N$ 和 $T_{2N}$ 应用 Richardson 外推，在数学上等价于应用复化 Simpson 法则 $S_{2N}$。程序将在浮点运算中实现这些公式，并验证计算出的值在微小容差 $\\tau = 10^{-12}$ 内相等，该容差考虑了因浮点运算顺序而可能产生的微小差异。对于所有测试用例，预期结果都为 True。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef composite_trapezoidal(f, a, b, N):\n    \"\"\"\n    Computes the integral of f on [a,b] using the composite Trapezoidal rule\n    with N uniform subintervals.\n    \"\"\"\n    if N == 0:\n        raise ValueError(\"Number of subintervals N must be a positive integer.\")\n    \n    h = (b - a) / N\n    x = np.linspace(a, b, N + 1)\n    y = f(x)\n    \n    # Formula: (h/2) * (f(x0) + 2*f(x1) + ... + 2*f(x_{N-1}) + f(xN))\n    integral = (h / 2.0) * (y[0] + 2 * np.sum(y[1:-1]) + y[-1])\n    return integral\n\ndef composite_simpson(f, a, b, M):\n    \"\"\"\n    Computes the integral of f on [a,b] using the composite Simpson's rule\n    with M uniform subintervals. M must be an even integer.\n    \"\"\"\n    if M == 0 or M % 2 != 0:\n        raise ValueError(\"Number of subintervals M must be a positive even integer.\")\n        \n    h = (b - a) / M\n    x = np.linspace(a, b, M + 1)\n    y = f(x)\n    \n    # Formula: (h/3) * (f(x0) + 4f(x1) + 2f(x2) + ... + 4f(x_{M-1}) + f(xM))\n    # Slicing y[1:-1:2] gets all odd indices between the endpoints.\n    # Slicing y[2:-1:2] gets all even indices between the endpoints.\n    integral = (h / 3.0) * (y[0] + y[-1] + 4 * np.sum(y[1:-1:2]) + 2 * np.sum(y[2:-1:2]))\n    return integral\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'f': lambda x: np.sin(x), 'interval': (0.0, np.pi), 'N': 10},\n        {'f': lambda x: x**3 - 2*x + 1, 'interval': (-1.0, 2.0), 'N': 8},\n        {'f': lambda x: np.exp(x), 'interval': (0.0, 1.0), 'N': 2},\n        {'f': lambda x: 1.0 / (1.0 + x**2), 'interval': (-3.0, 3.0), 'N': 64},\n    ]\n\n    results = []\n    tolerance = 1e-12\n\n    for case in test_cases:\n        f = case['f']\n        a, b = case['interval']\n        N = case['N']\n        M = 2 * N\n\n        # 1. Compute Trapezoidal approximations for N and 2N subintervals.\n        T_N = composite_trapezoidal(f, a, b, N)\n        T_2N = composite_trapezoidal(f, a, b, M)\n        \n        # 2. Construct the Richardson-extrapolated estimate.\n        # This cancels the O(h^2) error term.\n        richardson_val = (4.0 * T_2N - T_N) / 3.0\n        \n        # 3. Compute the composite Simpson's rule value with 2N subintervals.\n        simpson_val = composite_simpson(f, a, b, M)\n\n        # 4. Compare the two results and check if they are equal within the tolerance.\n        are_equal = np.abs(richardson_val - simpson_val) = tolerance\n        results.append(are_equal)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "没有一种方法是完美无缺的。了解一个方法的局限性与掌握其使用方法同等重要。本练习将探讨一个辛普森法则表现出乎意料地差的场景，尽管它对于光滑函数具有很高的精度。通过分析一个带有“尖角”（即不可导点）的函数的积分，我们可以深刻理解牛顿-柯特斯公式精度背后的假设条件。",
            "id": "2191010",
            "problem": "在数值分析中，当解析解难以或无法找到时，一个常见的任务是近似计算一个定积分。对此，最基本的方法之一是辛普森1/3法则。\n\n考虑函数 $f(x) = |x - c|$，其中 $c$ 是一个常数。我们关心的是这个函数在区间 $[a, b]$ 上的定积分，其中 $a  c  b$。\n\n你的任务是分析辛普森1/3法则对此类函数的性能。\n具体来说，令函数为 $f(x) = |x - 1|$，积分区间为 $[0, 2]$。\n\n首先，计算积分的精确值，我们称之为 $I_{exact} = \\int_{0}^{2} |x - 1| \\, dx$。\n接下来，使用辛普森1/3法则在整个区间 $[0, 2]$ 上进行单次应用（这对应于使用 $n=2$ 个子区间），计算积分的近似值 $I_{S}$。\n\n最后，计算绝对误差 $E = |I_{exact} - I_{S}|$。将此绝对误差作为你的最终答案。将最终答案四舍五入到三位有效数字。",
            "solution": "我们通过在绝对值符号改变的点处分割积分来计算精确积分。由于 $f(x)=|x-1|$，在 $[0,1]$ 上有 $|x-1|=1-x$，在 $[1,2]$ 上有 $|x-1|=x-1$。因此，\n$$\nI_{\\text{exact}}=\\int_{0}^{2}|x-1|\\,dx=\\int_{0}^{1}(1-x)\\,dx+\\int_{1}^{2}(x-1)\\,dx.\n$$\n分别计算每一部分：\n$$\n\\int_{0}^{1}(1-x)\\,dx=\\left[x-\\frac{x^{2}}{2}\\right]_{0}^{1}=1-\\frac{1}{2}=\\frac{1}{2},\\quad\n\\int_{1}^{2}(x-1)\\,dx=\\left[\\frac{x^{2}}{2}-x\\right]_{1}^{2}=\\left(2-2\\right)-\\left(\\frac{1}{2}-1\\right)=\\frac{1}{2}.\n$$\n因此，\n$$\nI_{\\text{exact}}=\\frac{1}{2}+\\frac{1}{2}=1.\n$$\n\n现在，对区间 $[0,2]$ 应用辛普森1/3法则，其中 $n=2$ 个子区间。步长为 $h=\\frac{b-a}{2}=\\frac{2-0}{2}=1$。辛普森公式给出\n$$\nI_{S}=\\frac{h}{3}\\left[f(0)+4f(1)+f(2)\\right].\n$$\n计算函数值：\n$$\nf(0)=|0-1|=1,\\quad f(1)=|1-1|=0,\\quad f(2)=|2-1|=1.\n$$\n因此，\n$$\nI_{S}=\\frac{1}{3}\\left[1+4\\cdot 0+1\\right]=\\frac{1}{3}\\cdot 2=\\frac{2}{3}.\n$$\n\n绝对误差为\n$$\nE=\\left|I_{\\text{exact}}-I_{S}\\right|=\\left|1-\\frac{2}{3}\\right|=\\frac{1}{3}.\n$$\n四舍五入到三位有效数字，结果是 $0.333$。",
            "answer": "$$\\boxed{0.333}$$"
        }
    ]
}