{
    "hands_on_practices": [
        {
            "introduction": "理论是抽象的，而通过亲手演算来理解算法的内部工作机制是掌握知识最有效的方法之一。这项练习将带领你手动追踪一个自适应求积算法的每一步，在一个简单的二次函数上观察其如何通过递归和误差比较来划分区间，从而建立起对算法核心逻辑的直观理解。",
            "id": "2153105",
            "problem": "一个自适应求积算法会细化其计算网格以满足所需的误差容限。考虑以下旨在近似定积分 $I = \\int_a^b f(x) \\,dx$ 的递归算法。\n\n**自适应积分算法：**\n以一个函数 $f$、一个区间 $[a, b]$ 和一个容限 $\\epsilon$ 为输入的函数 `AdaptiveIntegrate(f, a, b, ε)`。\n\n1.  计算 $S_1$，即使用宽度为 $h_1 = b-a$ 的单个区间的梯形法则近似值。公式为 $S_1 = \\frac{h_1}{2}(f(a) + f(b))$。\n2.  令 $c = (a+b)/2$ 为区间的中点。计算 $S_2$，即使用两个子区间 $[a, c]$ 和 $[c, b]$（每个子区间的宽度为 $h_2 = (b-a)/2$）的复合梯形法则近似值。公式为 $S_2 = \\frac{h_2}{2}(f(a) + f(c)) + \\frac{h_2}{2}(f(c) + f(b))$。\n3.  更精确的近似值 $S_2$ 的误差估计基于这两个近似值之间的差异。停止准则为 $|S_2 - S_1| \\le 3\\epsilon$。\n4.  如果满足该准则，则该区间的过程终止并返回值 $S_2$。\n5.  如果不满足该准则，算法将细化该区间。它在两个子区间上递归调用自身，每个子区间的容限减半。区间 $[a, b]$ 的结果是这两个调用结果的总和：\n    `AdaptiveIntegrate(f, a, c, ε/2) + AdaptiveIntegrate(f, c, b, ε/2)`\n\n你的任务是手动追踪此算法，以找到积分\n$$ I = \\int_0^4 x^2 \\,dx $$\n在初始容限 $\\epsilon = 2$ 下的数值近似值。\n\n计算算法返回的积分的最终数值近似值。以精确的整数或分数形式提供你的答案。",
            "solution": "我们将给定的自适应梯形算法应用于在 $[0,4]$ 上的 $f(x)=x^2$，初始容限 $\\epsilon=2$。在 $[a,b]$ 上使用一个区间的梯形近似值为 $S_1=\\frac{h_1}{2}\\left(f(a)+f(b)\\right)$，其中 $h_1=b-a$，使用两个区间的梯形近似值为\n$$\nS_2=\\frac{h_2}{2}\\left(f(a)+f(c)\\right)+\\frac{h_2}{2}\\left(f(c)+f(b)\\right),\n$$\n其中 $c=\\frac{a+b}{2}$ 且 $h_2=\\frac{b-a}{2}$。一个区间的停止准则为 $|S_2-S_1| \\le 3\\epsilon$。如果不满足，我们在 $[a,c]$ 和 $[c,b]$ 上以各自容限 $\\epsilon/2$ 进行递归，并将其返回值相加。\n\n顶层区间 $[0,4]$，$\\epsilon=2$：\n- 计算 $h_1=4$, $S_1=\\frac{4}{2}\\left(f(0)+f(4)\\right)=2\\left(0+16\\right)=32$。\n- 中点 $c=2$, $h_2=2$, 并且\n$$\nS_2=\\frac{2}{2}\\left(f(0)+f(2)\\right)+\\frac{2}{2}\\left(f(2)+f(4)\\right)=1\\left(0+4\\right)+1\\left(4+16\\right)=4+20=24.\n$$\n- 误差检查：$|S_2-S_1|=|24-32|=8$，而 $3\\epsilon=3 \\cdot 2=6$。由于 $8 > 6$，准则不满足，我们在 $[0,2]$ 和 $[2,4]$ 上以各自容限 $\\epsilon/2=1$ 进行递归。\n\n子区间 $[0,2]$，$\\epsilon=1$：\n- 计算 $h_1=2$, $S_1=\\frac{2}{2}\\left(f(0)+f(2)\\right)=1\\left(0+4\\right)=4$。\n- 中点 $c=1$, $h_2=1$, 并且\n$$\nS_2=\\frac{1}{2}\\left(f(0)+f(1)\\right)+\\frac{1}{2}\\left(f(1)+f(2)\\right)=\\frac{1}{2}\\left(0+1\\right)+\\frac{1}{2}\\left(1+4\\right)=\\frac{1}{2}+\\frac{5}{2}=3.\n$$\n- 误差检查：$|S_2-S_1|=|3-4|=1$，而 $3\\epsilon=3 \\cdot 1=3$。由于 $1 \\le 3$，准则满足，接受 $[0,2]$ 的结果 $S_2=3$。\n\n子区间 $[2,4]$，$\\epsilon=1$：\n- 计算 $h_1=2$, $S_1=\\frac{2}{2}\\left(f(2)+f(4)\\right)=1\\left(4+16\\right)=20$。\n- 中点 $c=3$, $h_2=1$, 并且\n$$\nS_2=\\frac{1}{2}\\left(f(2)+f(3)\\right)+\\frac{1}{2}\\left(f(3)+f(4)\\right)=\\frac{1}{2}\\left(4+9\\right)+\\frac{1}{2}\\left(9+16\\right)=\\frac{13}{2}+\\frac{25}{2}=19.\n$$\n- 误差检查：$|S_2-S_1|=|19-20|=1$，而 $3\\epsilon=3$。由于 $1 \\le 3$，准则满足，接受 $[2,4]$ 的结果 $S_2=19$。\n\n最后，顶层调用返回接受的子区间结果之和：\n$$\n\\text{Result} = 3+19=22.\n$$\n这是算法返回的最终数值近似值。",
            "answer": "$$\\boxed{22}$$"
        },
        {
            "introduction": "任何数值算法都有其局限性，理解这些局限与理解算法本身同样重要。这个思想实验旨在挑战你对自适应求积误差估计的理解，通过构造一个“欺骗”算法的特殊函数，让你探索误差估计失效的条件，培养批判性思维。",
            "id": "2153040",
            "problem": "一个自适应求积算法被设计用于对连续函数 $f(x)$ 的定积分 $I = \\int_a^b f(x)\\,dx$ 进行数值近似，直至达到指定的容差 $\\epsilon > 0$。该算法基于辛普森法则，在任意给定区间 $[u, v]$ 上的运算如下：\n\n1.  使用辛普森法则在整个区间上计算一个粗略近似值：\n    $$S_1 = \\frac{v-u}{6}\\left(f(u) + 4f\\left(\\frac{u+v}{2}\\right) + f(v)\\right)$$\n2.  通过将两个半区间 $[u, w]$ 和 $[w, v]$（其中 $w = (u+v)/2$）上的辛普森法则结果相加，计算一个更精细的近似值：\n    $$S_2 = \\frac{w-u}{6}\\left(f(u) + 4f\\left(\\frac{u+w}{2}\\right) + f(w)\\right) + \\frac{v-w}{6}\\left(f(w) + 4f\\left(\\frac{w+v}{2}\\right) + f(v)\\right)$$\n3.  使用以下公式估计精细近似值 $S_2$ 的误差：\n    $$E = \\frac{1}{15}|S_2 - S_1|$$\n4.  如果估计误差 $E$ 小于为区间 $[u,v]$ 分配的容差，则算法在该区间上终止，并返回 $S_2$ 作为其值。否则，算法将递归地应用于子区间 $[u, w]$ 和 $[w, v]$，每个子区间的容差为前一个容差的一半。\n\n考虑在区间 $[-1, 1]$ 上计算一个函数积分的任务。下列哪个连续函数会导致该算法在第一次检查时就终止（即不进行任何递归），并返回一个不正确的数值 0？假设初始容差 $\\epsilon$ 是任意小的正数。\n\nA. $f(x) = 3x^2 - 1$\n\nB. $f(x) = \\sin(\\pi x)$\n\nC. $f(x) = \\cos\\left(\\frac{\\pi}{2} x\\right)$\n\nD. $f(x) = 16x^6 - 20x^4 + x^2 + 1$\n\nE. $f(x) = x^5 - x^3 + x$",
            "solution": "为使算法在第一次检查时就对任意小的正容差 $\\epsilon$ 终止，初始区间上的估计误差必须恰好为零。当 $[u,v]=[-1,1]$ 且 $w=0$ 时，两个辛普森近似值为\n$$\nS_{1}=\\frac{1}{3}\\left(f(-1)+4f(0)+f(1)\\right),\n$$\n$$\nS_{2}=\\frac{1}{6}\\left(f(-1)+4f\\left(-\\frac{1}{2}\\right)+f(0)\\right)+\\frac{1}{6}\\left(f(0)+4f\\left(\\frac{1}{2}\\right)+f(1)\\right)\n=\\frac{1}{6}\\left(f(-1)+f(1)+2f(0)+4f\\left(-\\frac{1}{2}\\right)+4f\\left(\\frac{1}{2}\\right)\\right).\n$$\n误差估计为\n$$\nE=\\frac{1}{15}|S_{2}-S_{1}|.\n$$\n为了对任意 $\\epsilon>0$ 终止，我们需要 $E=0$，即 $S_{2}=S_{1}$。为使算法返回不正确的值 0，我们还必须有 $S_{2}=0$，而真实积分 $\\int_{-1}^{1}f(x)\\,dx\\neq 0$。\n\n对每个选项计算 $S_{1}$ 和 $S_{2}$：\n\nA. $f(x)=3x^{2}-1$。计算 $f(-1)=2$, $f(0)=-1$, $f(1)=2$ 以及 $f\\left(\\pm\\frac{1}{2}\\right)=3\\cdot\\frac{1}{4}-1=-\\frac{1}{4}$。那么\n$$\nS_{1}=\\frac{1}{3}(2+4(-1)+2)=0,\\quad\nS_{2}=\\frac{1}{6}\\left(2+2+2(-1)+4\\left(-\\frac{1}{4}\\right)+4\\left(-\\frac{1}{4}\\right)\\right)=0.\n$$\n此外，$\\int_{-1}^{1}(3x^{2}-1)\\,dx=\\left[x^{3}-x\\right]_{-1}^{1}=0$，所以返回 0 是正确的，而不是不正确的。\n\nB. $f(x)=\\sin(\\pi x)$。计算 $f(-1)=0$, $f(0)=0$, $f(1)=0$, $f\\left(-\\frac{1}{2}\\right)=-1$, $f\\left(\\frac{1}{2}\\right)=1$。那么\n$$\nS_{1}=0,\\quad S_{2}=\\frac{1}{6}\\left(0+0+0+4(-1)+4(1)\\right)=0,\n$$\n并且 $\\int_{-1}^{1}\\sin(\\pi x)\\,dx=0$（被积函数为奇函数），所以返回 0 是正确的。\n\nC. $f(x)=\\cos\\left(\\frac{\\pi}{2}x\\right)$。计算 $f(-1)=0$, $f(0)=1$, $f(1)=0$, $f\\left(\\pm\\frac{1}{2}\\right)=\\cos\\left(\\pm\\frac{\\pi}{4}\\right)=\\frac{\\sqrt{2}}{2}$。那么\n$$\nS_{1}=\\frac{1}{3}(0+4\\cdot 1+0)=\\frac{4}{3},\\quad\nS_{2}=\\frac{1}{6}\\left(0+0+2\\cdot 1+4\\cdot\\frac{\\sqrt{2}}{2}+4\\cdot\\frac{\\sqrt{2}}{2}\\right)=\\frac{1}{6}\\left(2+4\\sqrt{2}\\right)=\\frac{1}{3}\\left(1+2\\sqrt{2}\\right)\\neq 0,\n$$\n所以算法不会返回 0。\n\nD. $f(x)=16x^{6}-20x^{4}+x^{2}+1$。计算 $f(-1)=-2$, $f(0)=1$, $f(1)=-2$ 以及 $f\\left(\\pm\\frac{1}{2}\\right)=16\\left(\\frac{1}{64}\\right)-20\\left(\\frac{1}{16}\\right)+\\frac{1}{4}+1=\\frac{1}{4}$。那么\n$$\nS_{1}=\\frac{1}{3}(-2+4\\cdot 1-2)=0,\\quad\nS_{2}=\\frac{1}{6}\\left(-2-2+2\\cdot 1+4\\cdot\\frac{1}{4}+4\\cdot\\frac{1}{4}\\right)=\\frac{1}{6}(-4+2+1+1)=0.\n$$\n因此 $E=0$ 且算法立即终止，返回 0。真实积分为\n$$\n\\int_{-1}^{1}\\left(16x^{6}-20x^{4}+x^{2}+1\\right)dx\n=2\\int_{0}^{1}\\left(16x^{6}-20x^{4}+x^{2}+1\\right)dx\n=2\\left(\\frac{16}{7}-4+\\frac{1}{3}+1\\right)\n=2\\left(\\frac{16}{7}-\\frac{8}{3}\\right)\n=-\\frac{16}{21}\\neq 0,\n$$\n所以返回的值 0 是不正确的。\n\nE. $f(x)=x^{5}-x^{3}+x$ 是奇函数，因此 $S_{1}=0$，$S_{2}=0$（根据节点和权重的对称性），并且 $\\int_{-1}^{1}f(x)\\,dx=0$，因此返回 0 是正确的。\n\n只有选项 D 满足要求：以 $E=0$ 立即终止，返回 0，而真实积分非零。",
            "answer": "$$\\boxed{D}$$"
        },
        {
            "introduction": "自适应求积方法最强大的地方在于其效率，它能智能地将计算资源集中在函数行为最复杂的区域。通过为这个在不同区域振荡频率迥异的分段函数编写代码，你将不仅实现一个完整的自适应算法，还将定量分析算法如何自动识别并加密处理高频部分，直观地感受其“自适应”的威力。",
            "id": "3203443",
            "problem": "考虑区间 $[0,2\\pi]$ 和分段定义的函数 $f(x)$，其定义为：当 $x  \\pi$ 时 $f(x)=\\sin(x)$，当 $x\\ge\\pi$ 时 $f(x)=\\sin(100x)$。任务是实现一种自适应求积方法，该方法从数值分析的基本原理出发，利用局部误差控制来决定在何处细分积分域。您必须构建一个程序，计算 $f(x)$ 在 $[0,2\\pi]$ 上的定积分近似值，并定量分析自适应过程在低频区域 $[0,\\pi)$ 与高频区域 $[\\pi,2\\pi]$ 中分配节点的情况。\n\n从定积分的定义和基于多项式插值的复合数值求积概念开始。使用基于原理的局部误差估计器来驱动细分，确保算法在估计误差较大的子区间进行加密。您必须实现一个基于辛普森型局部近似的自适应算法，该算法递归地二分区间，直到满足指定的绝对误差容限 $\\tau$ 或达到最大递归深度 $D_{\\max}$。您不应假设目标方法有任何预先推导的快捷公式；相反，应从数值积分和局部误差估计的核心定义来推导出决策。\n\n您的程序必须对每个测试输入执行以下操作：\n- 计算 $\\int_{0}^{2\\pi} f(x)\\,dx$ 的数值近似值 $I$。\n- 跟踪对 $f(x)$ 进行求值的唯一横坐标点集合，并报告在 $[0,\\pi)$ 和 $[\\pi,2\\pi]$ 中使用的唯一点的数量 $n_{\\text{low}}$ 和 $n_{\\text{high}}$。将 $x=\\pi$ 归类于高频区域。\n- 计算绝对误差 $e=|I-I_{\\text{exact}}|$，其中 $I_{\\text{exact}}$ 是根据三角函数积分的基本性质推导出的积分精确值。\n- 报告自适应方法是否为高频区域分配了严格多于低频区域的节点，即布尔值 $n_{\\text{high}}  n_{\\text{low}}$。\n\n测试套件：\n为以下参数集 $(\\tau,D_{\\max})$ 提供结果：\n1. $\\tau=10^{-6}$ 且 $D_{\\max}=40$（一般情况）。\n2. $\\tau=10^{-4}$ 且 $D_{\\max}=20$（中等容限）。\n3. $\\tau=10^{-8}$ 且 $D_{\\max}=12$（容限严格但递归深度有限的边界情况）。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。每个测试用例必须贡献一个形式为 $[I,e,n_{\\text{low}},n_{\\text{high}},\\text{high\\_more}]$ 的嵌套列表，其中 $I$ 和 $e$是浮点数，$n_{\\text{low}}$ 和 $n_{\\text{high}}$ 是整数，$\\text{high\\_more}$ 是布尔值。例如，整体输出必须类似于 $[[I_1,e_1,n_{\\text{low},1},n_{\\text{high},1},\\text{high\\_more}_1],[I_2,e_2,n_{\\text{low},2},n_{\\text{high},2},\\text{high\\_more}_2],[I_3,e_3,n_{\\text{low},3},n_{\\text{high},3},\\text{high\\_more}_3]]$。不涉及物理单位。",
            "solution": "用户提供的问题是数值分析中一个定义明确的任务。它要求基于基本原理实现并分析一种自适应求积算法。该问题在科学上是合理的、自成体系的且客观的。因此，它被认为是有效的。\n\n### 1. 自适应方法的基于原理的推导\n\n目标是近似计算定积分 $I = \\int_a^b f(x) \\, dx$。自适应求积方法通过细分那些估计近似误差较大的区间来加密积分域，从而将计算量集中在函数最难积分的部分。\n\n我们将方法建立在辛普森法则的基础上，该法则用一个二次多项式来近似被积函数。\n\n**使用辛普森法则的局部近似**\n\n对于给定的区间 $[a, b]$，令 $c = (a+b)/2$ 为中点。基本的辛普森法则使用三个点提供一个近似值 $S_1$：\n$$ S_1 = \\frac{b-a}{6} \\left( f(a) + 4f(c) + f(b) \\right) $$\n已知这个近似的误差为 $E_1 = -\\frac{(b-a)^5}{2880} f^{(4)}(\\xi_1)$，对于某个 $\\xi_1 \\in (a, b)$。\n\n为了在不知道 $f^{(4)}$ 的情况下估计这个误差，我们通过将辛普森法则应用于两个半区间 $[a, c]$ 和 $[c, b]$ 来计算一个更精确的近似值 $S_2$。令 $d = (a+c)/2$ 和 $e = (c+b)/2$ 为新的中点。在这两个子区间上使用复合辛普森法则得到：\n$$ S_2 = \\frac{c-a}{6} \\left( f(a) + 4f(d) + f(c) \\right) + \\frac{b-c}{6} \\left( f(c) + 4f(e) + f(b) \\right) $$\n由于 $c-a = b-c = (b-a)/2$，这可以简化为：\n$$ S_2 = \\frac{b-a}{12} \\left( f(a) + 4f(d) + 2f(c) + 4f(e) + f(b) \\right) $$\n这个5点近似 $S_2$ 的误差是两个子区间误差之和：\n$$ E_2 = -2 \\cdot \\frac{((b-a)/2)^5}{2880} f^{(4)}(\\xi_2) = -\\frac{1}{16} \\frac{(b-a)^5}{2880} f^{(4)}(\\xi_2) $$\n假设 $f^{(4)}(x)$ 在 $[a, b]$ 上近似为常数，我们有 $E_2 \\approx \\frac{1}{16} E_1$。\n\n**局部误差估计**\n\n令区间 $[a, b]$ 上的积分真值为 $I_{[a,b]}$。我们有以下关系：\n$I_{[a,b]} \\approx S_1 + E_1$\n$I_{[a,b]} \\approx S_2 + E_2 \\approx S_2 + \\frac{1}{16} E_1$\n\n将 $I_{[a,b]}$ 的两个表达式相等：\n$S_1 + E_1 \\approx S_2 + \\frac{1}{16} E_1 \\implies \\frac{15}{16} E_1 \\approx S_2 - S_1 \\implies E_1 \\approx \\frac{16}{15} (S_2 - S_1)$\n\n我们真正感兴趣的是我们*更优*近似值 $S_2$ 的误差。这个误差是 $E_2 \\approx \\frac{1}{16} E_1$。代入 $E_1$ 的表达式：\n$$ E_{\\text{local}} = E_2 \\approx \\frac{1}{16} \\left( \\frac{16}{15} (S_2 - S_1) \\right) = \\frac{S_2 - S_1}{15} $$\n因此，局部误差的大小可以估计为 $|S_2 - S_1| / 15$。\n\n**递归细分策略**\n\n自适应算法是递归实现的。对于一个区间 $[a, b]$ 和一个期望的局部容限 $\\tau_{\\text{local}}$：\n1. 计算粗略近似值 $S_1$ 和精细近似值 $S_2$。\n2. 估计误差 $E_{\\text{local}} = |S_2 - S_1|/15$。\n3. 如果 $E_{\\text{local}}  \\tau_{\\text{local}}$ 或者达到了最大递归深度 $D_{\\max}$，则停止细分。返回该区间上积分的最佳估计值。这可以是更精确的值 $S_2$，或者通过理查森外推法获得的更好的估计值：$I_{\\text{best}} = S_2 + E_{\\text{local}} = S_2 + (S_2 - S_1)/15$。我们将使用这个改进后的值。\n4. 如果误差太大，则将区间二分为 $[a, c]$ 和 $[c, b]$。对每个子区间递归调用该算法。容限被分配给子问题；一个常见的策略是为每个子问题分配父问题容限的一半，即 $\\tau_{\\text{child}} = \\tau_{\\text{local}}/2$。\n\n初始调用在整个域 $[0, 2\\pi]$ 上进行，使用用户指定的容限 $\\tau$ 和最大深度 $D_{\\max}$。\n\n### 2. 目标问题分析\n\n**函数定义**\n\n要在 $[0, 2\\pi]$ 上积分的函数是：\n$$ f(x) = \\begin{cases} \\sin(x)  \\text{for } x  \\pi \\\\ \\sin(100x)  \\text{for } x \\ge \\pi \\end{cases} $$\n该函数在 $[0, \\pi)$ 上有一个低频分量，在 $[\\pi, 2\\pi]$ 上有一个高频分量。预计自适应算法将在高频区域执行更多次细分，以解析 $\\sin(100x)$ 的快速振荡。\n\n**精确积分计算**\n\n计算误差需要积分的精确值。\n$$ I_{\\text{exact}} = \\int_{0}^{2\\pi} f(x) \\, dx = \\int_{0}^{\\pi} \\sin(x) \\, dx + \\int_{\\pi}^{2\\pi} \\sin(100x) \\, dx $$\n第一部分是：\n$$ \\int_{0}^{\\pi} \\sin(x) \\, dx = [-\\cos(x)]_{0}^{\\pi} = (-\\cos(\\pi)) - (-\\cos(0)) = -(-1) - (-1) = 1+1=2 $$\n第二部分是：\n$$ \\int_{\\pi}^{2\\pi} \\sin(100x) \\, dx = \\left[-\\frac{1}{100}\\cos(100x)\\right]_{\\pi}^{2\\pi} = -\\frac{1}{100} (\\cos(200\\pi) - \\cos(100\\pi)) = -\\frac{1}{100} (1 - 1) = 0 $$\n因此，积分的精确值为 $I_{\\text{exact}} = 2 + 0 = 2$。\n\n**计算方案**\n\n对于每个测试用例 $(\\tau, D_{\\max})$：\n1. 初始化一个空集合来存储唯一的横坐标点（求值点）。\n2. 在 $[0, 2\\pi]$ 上执行递归自适应求积算法。递归函数将填充横坐标点集合。\n3. 算法的结果是数值近似值 $I$。\n4. 计算绝对误差 $e = |I - I_{\\text{exact}}|$。\n5. 遍历唯一的横坐标点集合。将在 $[0, \\pi)$ 中的点数计为 $n_{\\text{low}}$，将在 $[\\pi, 2\\pi]$ 中的点数计为 $n_{\\text{high}}$（将 $x=\\pi$ 归类为高频）。\n6. 确定条件 $n_{\\text{high}} > n_{\\text{low}}$ 的布尔值。\n7. 收集这五个结果：$[I, e, n_{\\text{low}}, n_{\\text{high}}, (n_{\\text{high}} > n_{\\text{low}})]$。\n所有测试用例的结果将被编译成一个单独的列表作为最终输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases and print the final result.\n    \"\"\"\n\n    # Define the piecewise function f(x)\n    def f(x):\n        \"\"\"\n        The piecewise function to be integrated.\n        f(x) = sin(x) for x  pi\n        f(x) = sin(100x) for x = pi\n        \"\"\"\n        if isinstance(x, (list, np.ndarray)):\n            # Support for vectorized input, though the algorithm evaluates point-wise\n            return np.where(x  np.pi, np.sin(x), np.sin(100 * x))\n        else:\n            if x  np.pi:\n                return np.sin(x)\n            else:\n                return np.sin(100 * x)\n\n    class AdaptiveQuadrature:\n        \"\"\"\n        A class to encapsulate the adaptive quadrature logic and state.\n        This avoids using global variables for tracking evaluation points.\n        \"\"\"\n        def __init__(self, func, exact_value):\n            self.func = func\n            self.exact_value = exact_value\n            self.points_set = set()\n\n        def _recursive_solver(self, a, b, tol, depth):\n            \"\"\"\n            The recursive core of the adaptive Simpson's method.\n            \"\"\"\n            # 1. Define the 5 points for the two-level Simpson's rule\n            c = (a + b) / 2.0\n            d = (a + c) / 2.0\n            e = (c + b) / 2.0\n\n            # 2. Evaluate the function at the necessary points\n            # To avoid duplicate additions to the set, check first if needed,\n            # but for simplicity, we add all 5 and let the set handle uniqueness.\n            # This is less performant but conceptually clear.\n            fa, fb, fc = self.func(a), self.func(b), self.func(c)\n            fd, fe = self.func(d), self.func(e)\n            \n            # Record all unique evaluation points\n            self.points_set.update([a, b, c, d, e])\n\n            # 3. Compute coarse (S1) and fine (S2) approximations\n            # S1: Simpson's rule on [a, b]\n            s1 = (b - a) * (fa + 4 * fc + fb) / 6.0\n            # S2: Composite Simpson's rule on [a, c] and [c, b]\n            s2 = (b - a) * (fa + 4 * fd + 2 * fc + 4 * fe + fb) / 12.0\n\n            # 4. Estimate the error of the more accurate approximation, S2\n            # The error is estimated as |S2 - S1| / 15\n            error = abs(s2 - s1) / 15.0\n\n            # 5. Check stopping conditions\n            if depth = 0 or error = tol:\n                # Return the best estimate using Richardson extrapolation\n                return s2 + (s2 - s1) / 15.0\n            else:\n                # 6. Recurse on subintervals with scaled tolerance\n                left_integral = self._recursive_solver(a, c, tol / 2.0, depth - 1)\n                right_integral = self._recursive_solver(c, b, tol / 2.0, depth - 1)\n                return left_integral + right_integral\n\n        def compute(self, a, b, tau, d_max):\n            \"\"\"\n            Public method to run the adaptive quadrature for a given problem setup.\n            \"\"\"\n            self.points_set.clear()\n            \n            # Start the recursion\n            integral_approx = self._recursive_solver(a, b, tau, d_max)\n            \n            # Calculate absolute error\n            abs_error = abs(integral_approx - self.exact_value)\n            \n            # Analyze node distribution\n            n_low = 0\n            n_high = 0\n            pi_val = np.pi\n            for p in self.points_set:\n                if p  pi_val:\n                    n_low += 1\n                else:  # p = pi_val\n                    n_high += 1\n            \n            high_more = n_high  n_low\n            \n            return [integral_approx, abs_error, n_low, n_high, high_more]\n\n    # Define the problem's domain and exact integral value\n    a_domain, b_domain = 0, 2 * np.pi\n    i_exact = 2.0\n    \n    # Instantiate the solver\n    solver = AdaptiveQuadrature(func=f, exact_value=i_exact)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (tau, D_max)\n        (1e-6, 40),   # general case\n        (1e-4, 20),   # moderate tolerance\n        (1e-8, 12),   # tight tolerance, limited depth\n    ]\n\n    # Run the solver for each case and collect results\n    results = []\n    for tau, d_max in test_cases:\n        result = solver.compute(a_domain, b_domain, tau, d_max)\n        results.append(result)\n\n    # Format the final output string as required\n    # Custom formatter to handle boolean correctly as lowercased string\n    def format_item(item):\n        if isinstance(item, bool):\n            return str(item).lower()\n        return str(item)\n\n    # Format each inner list\n    formatted_results = []\n    for res_list in results:\n        formatted_list = f\"[{','.join(format_item(item) for item in res_list)}]\"\n        formatted_results.append(formatted_list)\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}