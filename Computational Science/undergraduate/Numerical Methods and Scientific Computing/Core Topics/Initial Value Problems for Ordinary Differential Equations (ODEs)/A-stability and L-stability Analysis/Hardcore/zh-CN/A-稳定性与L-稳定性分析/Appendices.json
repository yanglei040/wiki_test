{
    "hands_on_practices": [
        {
            "introduction": "首先，我们来练习如何应用 $A$-稳定性和 $L$-稳定性的核心定义。这个练习 () 提供了一个假设的稳定性函数，要求你通过直接计算来确定其性质。在探索这些函数如何从实际数值方法中产生以及它们的性质在实践中意味着什么之前，掌握这项基本技能是至关重要的。",
            "id": "2151768",
            "problem": "在分析求解常微分方程（ODEs）的数值方法时，方法的稳定性是一个关键性质。这通常通过将方法应用于 Dahlquist 测试方程 $y' = \\lambda y$ 来研究，其中 $\\lambda$ 是一个满足 $\\text{Re}(\\lambda) \\leq 0$ 的复数。该分析导出一个稳定性函数 $R(z)$，其中 $z = h\\lambda$，$h$ 是步长。$R(z)$ 的行为决定了该方法的稳定性质。\n\n两个重要的稳定性质是 A-稳定性和 L-稳定性：\n1.  如果一个方法的绝对稳定区域包含整个复左半平面，则该方法是 **A-稳定**的。对于一个具有有理稳定性函数 $R(z)$ 的方法，这等价于对于所有满足 $\\text{Re}(z) \\leq 0$ 的复数 $z$，条件 $|R(z)| \\leq 1$ 成立。\n2.  如果一个方法是 A-稳定的，并且其稳定性函数还满足条件 $\\lim_{|z| \\to \\infty} R(z) = 0$，则该方法是 **L-稳定**的。\n\n考虑一个假设的单步数值方法，其稳定性函数由以下有理函数给出：\n$$\nR(z) = \\frac{1+\\frac{1}{3}z}{1-\\frac{2}{3}z}\n$$\n\n根据所提供的定义，确定该方法的稳定性质。\n\nA. 该方法是 A-稳定的，但不是 L-稳定的。\nB. 该方法是 L-稳定的。\nC. 该方法不是 A-稳定的。\nD. 该方法既不是 A-稳定的，也不是 L-稳定的。",
            "solution": "给定的稳定性函数为\n$$\nR(z) = \\frac{1+\\frac{1}{3}z}{1-\\frac{2}{3}z}.\n$$\nA-稳定性要求绝对稳定区域\n$$\nS=\\{z\\in\\mathbb{C}:\\,|R(z)|\\leq 1\\}\n$$\n包含整个左半平面 $\\{z:\\,\\text{Re}(z)\\leq 0\\}$。我们通过求解不等式来分析 $S$\n$$\n\\left|\\frac{1+\\frac{1}{3}z}{1-\\frac{2}{3}z}\\right|\\leq 1\n\\quad\\Longleftrightarrow\\quad\n\\left|1+\\frac{1}{3}z\\right|\\leq\\left|1-\\frac{2}{3}z\\right|.\n$$\n令 $z=x+iy$，其中 $x,y\\in\\mathbb{R}$。对于实数 $\\alpha$，使用 $|1+\\alpha z|^{2}=(1+\\alpha x)^{2}+(\\alpha y)^{2}$，我们计算\n$$\n\\left|1+\\frac{1}{3}z\\right|^{2}=1+\\frac{2}{3}x+\\frac{1}{9}(x^{2}+y^{2}),\\qquad\n\\left|1-\\frac{2}{3}z\\right|^{2}=1-\\frac{4}{3}x+\\frac{4}{9}(x^{2}+y^{2}).\n$$\n因此\n$$\n1+\\frac{2}{3}x+\\frac{1}{9}(x^{2}+y^{2}) \\leq 1-\\frac{4}{3}x+\\frac{4}{9}(x^{2}+y^{2}).\n$$\n消去 $1$ 并合并各项，得到\n$$\n\\frac{2}{3}x+\\frac{1}{9}(x^{2}+y^{2}) \\leq -\\frac{4}{3}x+\\frac{4}{9}(x^{2}+y^{2}),\n$$\n$$\n\\frac{2}{3}x+\\frac{4}{3}x \\leq \\frac{4}{9}(x^{2}+y^{2})-\\frac{1}{9}(x^{2}+y^{2}),\n$$\n$$\n2x \\leq \\frac{1}{3}(x^{2}+y^{2}).\n$$\n乘以 3 并重新整理，得到\n$$\n6x \\leq x^{2}+y^{2}\\quad\\Longleftrightarrow\\quad x^{2}+y^{2}-6x \\geq 0.\n$$\n配方后，\n$$\n(x-3)^{2}+y^{2} \\geq 9.\n$$\n因此，绝对稳定区域 $S$ 是以 $(3,0)$ 为圆心，半径为 $3$ 的圆的外部（包括边界）。对于任何满足 $\\text{Re}(z)=x\\leq 0$ 的 $z$，我们有 $(x-3)^{2}\\geq 9$，因此 $(x-3)^{2}+y^{2}\\geq 9$，所以每个这样的 $z$ 都在 $S$ 中。因此，整个左半平面都被包含在内，该方法是 A-稳定的。\n\n为了检验 L-稳定性，计算当 $z\\to\\infty$ 时 $R(z)$ 的极限。由于分子和分母的次数相同，极限是首项系数之比：\n$$\n\\lim_{z\\to\\infty}R(z)=\\lim_{z\\to\\infty}\\frac{\\frac{1}{3}z}{-\\frac{2}{3}z}=-\\frac{1}{2}\\neq 0.\n$$\n因此，该方法不是 L-稳定的。\n\n综合这些结果，该方法是 A-稳定的但不是 L-稳定的，这对应于选项 A。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "既然我们已经练习了基本定义，现在让我们来探讨它们的实际影响。这个动手练习 () 将通过展示一个仅有 $A$-稳定性的方法如何对刚性问题产生不正确的振荡解，来揭示 $A$-稳定性 和 $L$-稳定性之间的关键区别。通过理论构建和编程任务，你将亲身体会到为什么 $L$-稳定性在科学计算中是一个至关重要的概念。",
            "id": "3202108",
            "problem": "要求您从基本原理出发，构建并分析一种用于常微分方程的特定线性多步法，然后实现一个程序，以数值方式验证其性质，并展示其在刚性问题上的定性失效。仅使用以下基本定义和事实作为基础：线性多步法是任何形式为 $\\sum_{j=0}^{s} \\alpha_j y_{n+j} = h \\sum_{j=0}^{s} \\beta_j f_{n+j}$ 且系数为常数的方法；一个方法是相容的，当且仅当 $\\sum_{j=0}^{s} \\alpha_j = 0$ 且 $\\sum_{j=0}^{s} j \\alpha_j = \\sum_{j=0}^{s} \\beta_j$；绝对稳定性（A-稳定性）的定义要求是，当应用于线性检验方程 $y' = \\lambda y$ 时，该方法的放大因子 $R(z)$（其中 $z = h \\lambda$）对于所有满足 $\\operatorname{Re}(z) \\le 0$ 的 $z$ 都满足 $\\lvert R(z) \\rvert \\le 1$；L-稳定性在此基础上还要求 $\\lim_{\\operatorname{Re}(z)\\to -\\infty} R(z) = 0$。不要假设任何不能从这些事实推导出的其他公式。\n\n任务 A。构建一个相容的、绝对稳定（A-稳定）但非 L-稳定的线性多步法。用具体系数将其表示为 $\\sum_{j=0}^{s} \\alpha_j y_{n+j} = h \\sum_{j=0}^{s} \\beta_j f_{n+j}$ 的形式，并通过将其应用于线性检验方程 $y'=\\lambda y$，推导出放大因子 $R(z)$（以 $z = h \\lambda$ 表示）的闭式解。仅使用上述基本定义来证明其相容性以及关于 A-稳定性和不满足 L-稳定性的论断。\n\n任务 B。确定一个刚性问题和一个时间步长 $h$，使得任务 A 中的方法在该问题上会产生不期望的振荡（尽管该方法是 A-稳定的），并解释导致这些振荡的机制。\n\n编程任务。将您的构建和分析实现在一个单一程序中，该程序执行以下操作。\n\n1) 通过为其系数 $\\alpha_j$ 和 $\\beta_j$ 指定数值（在代码中作为常量），来确定任务 A 中的方法。实现一个函数，该函数在给定复数 $z$ 的情况下，通过将方法代入检验方程 $y'=\\lambda y$ 并求解 $y_{n+1}/y_n$ 来计算方法的放大因子 $R(z)$。\n\n2) 相容性测试。使用相容性条件 $\\sum_{j=0}^{s} \\alpha_j = 0$ 和 $\\sum_{j=0}^{s} j \\alpha_j = \\sum_{j=0}^{s} \\beta_j$，返回一个布尔值，指示两个等式是否在 $10^{-12}$ 的绝对容差内成立。\n\n3) A-稳定性抽查。对于以下满足 $\\operatorname{Re}(z) \\le 0$ 的 $z$ 值测试集，计算布尔值，指示 $\\lvert R(z) \\rvert \\le 1$ 是否在 $10^{-12}$ 的容差内成立：\n- $z_1 = -1$\n- $z_2 = -100$\n- $z_3 = -1 + 10 i$\n- $z_4 = -50 + 200 i$\n\n4) 数值 L-稳定性检查。计算在 $z_\\star = -10^6$ 处的 $\\lvert R(z) \\rvert$，并返回一个布尔值，该值当且仅当 $\\lvert R(z_\\star)\\rvert  10^{-3}$ 时为真。这为 $\\lim_{\\operatorname{Re}(z)\\to -\\infty} R(z) = 0$ 提供了一个定量的代理。对于一个 L-稳定的方法，在如此大的负 $z_\\star$ 值下，此代理将评估为真；对于一个非 L-稳定的方法，它应评估为假。\n\n5) 刚性振荡演示。考虑刚性标量问题 $y' = \\lambda y$，其中 $\\lambda = -10000$，初始条件 $y(0) = 1$，终止时间 $T = 1$，以及固定步长 $h = 0.1$。使用任务 A 中的方法：\n- 计算 $N = T/h = 10$ 个步骤，并计算序列 $(y_0,y_1,\\dots,y_N)$ 中的符号变化次数，其中如果在步骤 $n$ 处 $y_n y_{n+1}  0$，则发生一次符号变化。\n- 报告最终的数值绝对值 $\\lvert y_N \\rvert$。\n- 计算精确的最终绝对值 $\\lvert y(T) \\rvert = \\lvert y(0) \\exp(\\lambda T) \\rvert$。\n- 报告绝对误差 $\\lvert y_N - y(T) \\rvert$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按以下顺序排列结果：\n- 来自步骤 2 的相容性布尔值，\n- 来自步骤 3 的四个布尔值列表，顺序为 $[z_1,z_2,z_3,z_4]$，\n- 来自步骤 4 的 L-稳定性代理布尔值，\n- 以及来自步骤 5 的列表 $[\\text{sign\\_changes}, \\lvert y_N\\rvert, \\lvert y(T)\\rvert, \\lvert y_N - y(T)\\rvert]$。\n例如，您的输出必须看起来像 \n$[\\text{True},[b_1,b_2,b_3,b_4],\\text{False},[k,a,e,\\varepsilon]]$ \n其中布尔值、整数和浮点数分别替换 $b_j$、$k$、$a$、$e$ 和 $\\varepsilon$。不应打印任何额外的文本或行。所有角度（如果出现）都必须以弧度为单位，但此处不需要。此问题中的所有量都是无量纲的，因此不需要进行物理单位转换。",
            "solution": "该问题是有效的。这是一个关于常微分方程数值分析的、适定的、自洽的练习，它基于标准的定义和原理。所有必要的信息都已提供。\n\n主要任务是构建并分析一种A-稳定但非L-稳定的线性多步法（LMM），然后通过计算来展示其行为。\n\n### 任务 A：方法构建与分析\n\n我们寻求一种形式为 $\\sum_{j=0}^{s} \\alpha_j y_{n+j} = h \\sum_{j=0}^{s} \\beta_j f_{n+j}$ 的相容线性多步法（LMM），它需要是A-稳定但非L-稳定的。这类方法的一个典型例子是梯形法则，它是一种单步法（$s=1$）。\n\n梯形法则是通过对常微分方程 $y' = f(t,y)$ 从 $t_n$ 到 $t_{n+1}$ 进行积分，并使用梯形求积法则来近似 $f$ 的积分而得到的：\n$$ y(t_{n+1}) - y(t_n) = \\int_{t_n}^{t_{n+1}} f(t, y(t)) dt \\approx \\frac{h}{2} [f(t_n, y(t_n)) + f(t_{n+1}, y(t_{n+1}))] $$\n这给出了数值方法：\n$$ y_{n+1} - y_n = \\frac{h}{2} (f_n + f_{n+1}) $$\n其中 $f_k = f(t_k, y_k)$ 且 $h = t_{n+1}-t_n$。\n\n为了将其表示为标准的LMM形式，我们将其重写为：\n$$ (1)y_{n+1} + (-1)y_n = h \\left( \\frac{1}{2} f_{n+1} + \\frac{1}{2} f_n \\right) $$\n将其与 $\\sum_{j=0}^{1} \\alpha_j y_{n+j} = h \\sum_{j=0}^{1} \\beta_j f_{n+j}$ 比较，我们确定系数如下：\n- $s = 1$\n- $\\alpha_0 = -1$, $\\alpha_1 = 1$\n- $\\beta_0 = \\frac{1}{2}$, $\\beta_1 = \\frac{1}{2}$\n\n**相容性证明：**\n一个方法是相容的，如果 $\\sum_{j=0}^{s} \\alpha_j = 0$ 且 $\\sum_{j=0}^{s} j \\alpha_j = \\sum_{j=0}^{s} \\beta_j$。\n1.  第一个条件：$\\sum_{j=0}^{1} \\alpha_j = \\alpha_0 + \\alpha_1 = -1 + 1 = 0$。该条件满足。\n2.  第二个条件：\n    - 左侧：$\\sum_{j=0}^{1} j \\alpha_j = (0 \\cdot \\alpha_0) + (1 \\cdot \\alpha_1) = 0 \\cdot (-1) + 1 \\cdot 1 = 1$。\n    - 右侧：$\\sum_{j=0}^{1} \\beta_j = \\beta_0 + \\beta_1 = \\frac{1}{2} + \\frac{1}{2} = 1$。\n    - 由于 $1=1$，第二个条件也满足。\n因此，梯形法则是相容的方法。\n\n**放大因子 $R(z)$ 的推导：**\n我们将该方法应用于线性检验方程 $y' = \\lambda y$，其中 $\\lambda \\in \\mathbb{C}$。对于此方程，$f_{n} = \\lambda y_{n}$ 且 $f_{n+1} = \\lambda y_{n+1}$。代入方法的公式中：\n$$ y_{n+1} - y_n = \\frac{h}{2} (\\lambda y_n + \\lambda y_{n+1}) $$\n令 $z = h \\lambda$。方程变为：\n$$ y_{n+1} - y_n = \\frac{z}{2} (y_n + y_{n+1}) $$\n我们求解放大因子 $R(z) = y_{n+1} / y_n$：\n$$ y_{n+1} - \\frac{z}{2} y_{n+1} = y_n + \\frac{z}{2} y_n $$\n$$ y_{n+1} \\left(1 - \\frac{z}{2}\\right) = y_n \\left(1 + \\frac{z}{2}\\right) $$\n$$ R(z) = \\frac{y_{n+1}}{y_n} = \\frac{1 + z/2}{1 - z/2} $$\n\n**稳定性证明：**\n-   **A-稳定性：** A-稳定性要求对于所有满足 $\\operatorname{Re}(z) \\le 0$ 的 $z$，都有 $|R(z)| \\le 1$。令 $z = x + iy$，其中 $x = \\operatorname{Re}(z) \\le 0$。\n    $$ |R(z)|^2 = \\left| \\frac{1 + (x+iy)/2}{1 - (x+iy)/2} \\right|^2 = \\frac{|(1 + x/2) + i(y/2)|^2}{|(1 - x/2) - i(y/2)|^2} = \\frac{(1+x/2)^2 + (y/2)^2}{(1-x/2)^2 + (y/2)^2} $$\n    条件 $|R(z)|^2 \\le 1$ 等价于：\n    $$ (1+x/2)^2 + (y/2)^2 \\le (1-x/2)^2 + (y/2)^2 $$\n    $$ 1 + x + \\frac{x^2}{4} \\le 1 - x + \\frac{x^2}{4} $$\n    $$ 2x \\le 0 \\implies x \\le 0 $$\n    这恰好是条件 $\\operatorname{Re}(z) \\le 0$。因此，梯形法则是 A-稳定的。\n\n-   **不满足 L-稳定性：** L-稳定性要求方法是 A-稳定的，并且还要求 $\\lim_{\\operatorname{Re}(z)\\to -\\infty} R(z) = 0$。我们计算我们推导出的 $R(z)$ 的极限：\n    $$ \\lim_{z \\to \\infty, \\operatorname{Re}(z) \\le 0} R(z) = \\lim_{z \\to \\infty, \\operatorname{Re}(z) \\le 0} \\frac{1 + z/2}{1 - z/2} $$\n    将分子和分母同除以 $z$：\n    $$ \\lim_{z \\to \\infty, \\operatorname{Re}(z) \\le 0} \\frac{1/z + 1/2}{1/z - 1/2} = \\frac{0 + 1/2}{0 - 1/2} = -1 $$\n    由于极限是 $-1$ 而不是 $0$，该方法不是 L-稳定的。\n\n### 任务 B：刚性振荡机制\n\n在求解刚性问题时，L-稳定性的缺失会导致不期望的行为。一个刚性常微分方程的解中包含以截然不同速率衰减的分量。高度稳定的分量对应于具有大的负实部的特征值 $\\lambda$。\n\n对于梯形法则，当 $\\operatorname{Re}(\\lambda)$ 是大的负数时，对于一个适中的步长 $h$，$z = h\\lambda$ 的值也是一个大的负数。正如我们刚才所示，对于这样的 $z$，放大因子 $R(z) \\to -1$。这意味着数值解遵循递推关系 $y_{n+1} \\approx -y_n$。\n\n这会导致数值解中出现持续不衰减的振荡（例如，$y_0, -y_0, y_0, -y_0, \\dots$）。然而，精确解的分量 $e^{\\lambda t}$ 应该极快地衰减到零且不发生振荡。数值方法未能衰减刚性分量的这种失效，正是一个方法是A-稳定但非L-稳定的标志。\n\n对于具体问题 $y' = \\lambda y$，其中 $\\lambda = -10000$，步长 $h=0.1$，我们有 $z = h\\lambda = 0.1 \\times (-10000) = -1000$。放大因子为\n$$ R(-1000) = \\frac{1 - 1000/2}{1 + 1000/2} = \\frac{-499}{501} \\approx -0.996 $$\n这个值非常接近 $-1$，所以我们预期 $y_{n+1} \\approx -y_n$，导致振荡衰减非常缓慢，其大小 $|y_n| = |R|^n |y_0|$ 保持在接近 $|y_0|$ 的水平。相比之下，精确解 $y(t) = y_0 e^{-10000t}$ 几乎瞬间就变得可以忽略不计。例如，在第一步结束时，$y(0.1) = y_0 e^{-1000} \\approx y_0 \\times 10^{-435}$。数值解完全无法捕捉到这种快速衰减。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs, analyzes, and demonstrates the properties of the trapezoidal rule,\n    a linear multistep method that is A-stable but not L-stable.\n    \"\"\"\n    \n    # Task A: Define the method.\n    # The method is the trapezoidal rule: y_{n+1} - y_n = h/2 * (f_n + f_{n+1})\n    # This is a one-step method (s=1).\n    # alpha_0*y_n + alpha_1*y_{n+1} = h * (beta_0*f_n + beta_1*f_{n+1})\n    alpha = np.array([-1.0, 1.0])\n    beta = np.array([0.5, 0.5])\n    \n    # 1) Amplification factor R(z) for the trapezoidal rule\n    # R(z) = (1 + z/2) / (1 - z/2)\n    def get_R(z: complex) - complex:\n        return (1.0 + 0.5 * z) / (1.0 - 0.5 * z)\n\n    # 2) Consistency test\n    # Condition 1: sum(alpha_j) = 0\n    # Condition 2: sum(j * alpha_j) = sum(beta_j)\n    consistency_c1 = np.isclose(np.sum(alpha), 0.0, atol=1e-12)\n    rho_prime_at_1 = np.sum(np.arange(len(alpha)) * alpha)\n    sigma_at_1 = np.sum(beta)\n    consistency_c2 = np.isclose(rho_prime_at_1, sigma_at_1, atol=1e-12)\n    consistency_ok = bool(consistency_c1 and consistency_c2)\n\n    # 3) A-stability spot checks\n    # Check if |R(z)| = 1 for Re(z) = 0.\n    # We add a tolerance to the right side to account for floating point error\n    # where |R(z)| should be exactly 1 but might be 1 + epsilon.\n    z_tests = [-1.0, -100.0, -1.0 + 10.0j, -50.0 + 200.0j]\n    astability_checks = []\n    for z in z_tests:\n        # For A-stability, |R(z)| must be = 1.\n        # Adding a small tolerance to the check.\n        is_stable = abs(get_R(z)) = 1.0 + 1e-12\n        astability_checks.append(is_stable)\n\n    # 4) Numerical L-stability check\n    # Check if lim_{Re(z) -> -inf} R(z) = 0.\n    # We use a large negative z as a proxy.\n    z_star = -1.0e6\n    R_mag_at_large_neg_z = abs(get_R(z_star))\n    # For L-stability, this magnitude should be close to 0. We test if it's  10^-3.\n    # For the trapezoidal rule, |R(z)| -> 1, so this check should fail.\n    lstability_check = bool(R_mag_at_large_neg_z  1e-3)\n    \n    # 5) Stiff-oscillation demonstration\n    lam = -10000.0\n    y0 = 1.0\n    T = 1.0\n    h = 0.1\n    N = int(T / h)\n    \n    # The numerical solution is y_n = R(h*lambda)^n * y_0\n    z = h * lam\n    amp_factor = get_R(z)\n    \n    y = np.array([y0 * (amp_factor**n) for n in range(N + 1)])\n    \n    # Count sign changes\n    sign_changes = 0\n    for i in range(N):\n        if y[i] * y[i+1]  0:\n            sign_changes += 1\n            \n    # Final numerical magnitude\n    yN_mag = abs(y[N])\n    \n    # Exact final magnitude\n    # y(T) = y(0) * exp(lambda * T)\n    # np.exp(-10000) underflows to 0.0 in standard double precision\n    yT_exact = y0 * np.exp(lam * T)\n    yT_exact_mag = abs(yT_exact)\n    \n    # Absolute error\n    abs_error = abs(y[N] - yT_exact)\n    \n    stiff_results = [sign_changes, yN_mag, yT_exact_mag, abs_error]\n\n    # Final output formatting\n    # Must match: [True,[b_1,b_2,b_3,b_4],False,[k,a,e,\\varepsilon]]\n    astab_str = ','.join([str(b).lower() for b in astability_checks])\n    stiff_str = ','.join(map(str, stiff_results))\n    \n    # Python's str() for booleans is \"True\" or \"False\", which is what's needed.\n    # f-string interpolation automatically calls str()\n    print(f\"[{str(consistency_ok).lower()},[{astab_str}],{str(lstability_check).lower()},[{stiff_str}]]\")\n\nsolve()\n```"
        },
        {
            "introduction": "我们最后的练习为稳定性讨论增加了一个至关重要的细微层次。虽然 $L$-稳定性对于像上一个练习 () 中那样的刚性问题至关重要，但在其他情况下，它可能会引入过度的数值耗散。这个练习 () 要求你在一个弱阻尼振荡问题上，比较一个 $L$-稳定性方法和一个耗散较小的 $A$-稳定性方法，从而强调“最佳”方法总是取决于具体问题。",
            "id": "3202129",
            "problem": "要求您在弱阻尼振荡的背景下，形式化并实现两种常微分方程隐式单步方法的数值稳定性比较。这两种方法是隐式梯形法则和后向欧拉法。此比较使用 Dahlquist 线性测试方程进行，该方程是绝对稳定性分析的基础。\n\n出发点和定义：\n- 考虑 Dahlquist 线性测试方程 $y'(t) = \\lambda y(t)$，其中 $\\lambda \\in \\mathbb{C}$ 且 $t \\in \\mathbb{R}$。对于常数步长 $h  0$，定义 $z = h \\lambda$。\n- 将数值单步方法应用于 Dahlquist 测试方程，会产生一个形式为 $y_{n+1} = R(z) y_n$ 的线性递推关系，其中 $R(z)$ 称为稳定性（放大）函数。\n- 如果对于所有满足 $\\operatorname{Re}(z) \\le 0$ 的 $z \\in \\mathbb{C}$，都有 $|R(z)| \\le 1$，则称该方法是 A-稳定的。\n- 如果一个方法是 A-稳定的，并且在负实轴上还满足 $\\lim_{|z| \\to -\\infty} R(z) = 0$，则称该方法是 L-稳定的。\n\n任务描述：\n1. 根据后向欧拉法和隐式梯形法则的定义，将其应用于 $y'(t) = \\lambda y(t)$，推导出相应的稳定性函数 $R_{\\mathrm{BE}}(z)$ 和 $R_{\\mathrm{TR}}(z)$，其中 $z = h \\lambda$。\n2. 考虑复参数 $\\lambda = -\\gamma + i \\omega$，其中 $\\gamma \\ge 0$ 且 $\\omega  0$。当 $\\gamma$ 很小时，它代表弱阻尼振荡。对于给定的步长 $h$ 和步数 $N$，精确解满足 $|y(Nh)| = |y(0)| \\exp(-\\gamma N h)$。数值方法会引起离散的振幅演化 $|y_N| = |R(z)|^N |y_0|$。为了比较振幅保持性，将 $N$ 步后的振幅误差定义为\n$$\nE_{\\mathrm{amp}} = \\left|\\, |R(z)|^N - \\exp(-\\gamma N h) \\,\\right|.\n$$\n3. 实现一个程序，对于下面测试套件中的每个测试用例，使用推导出的 $R_{\\mathrm{BE}}(z)$ 和 $R_{\\mathrm{TR}}(z)$ 计算两种方法的 $E_{\\mathrm{amp}}$，并返回一个布尔值，指示该测试用例中隐式梯形法则的振幅误差是否严格小于后向欧拉法的振幅误差。也就是说，如果 $E_{\\mathrm{amp}}^{\\mathrm{TR}}  E_{\\mathrm{amp}}^{\\mathrm{BE}}$，则为每个测试用例返回 $\\mathrm{True}$，否则返回 $\\mathrm{False}$。\n\n科学真实性要求：\n- 使用标量复数模型 $\\lambda = -\\gamma + i \\omega$（其中 $\\gamma$ 很小）来模拟弱阻尼振荡。本问题不涉及物理单位。没有明确使用角度，因此不需要指定角度单位。\n\n测试套件：\n- 情况 $1$（正常路径，弱阻尼，中等步长）：$\\gamma = 0.01$，$\\omega = 10.0$，$h = 0.1$，$N = 100$。\n- 情况 $2$（弱阻尼，接近振荡区域的大步长）：$\\gamma = 0.01$，$\\omega = 10.0$，$h = 0.5$，$N = 20$。\n- 情况 $3$（无阻尼振荡器，振幅保持边界）：$\\gamma = 0.0$，$\\omega = 10.0$，$h = 0.2$，$N = 50$。\n- 情况 $4$（强阻尼和大步长，说明 L-稳定性的优势）：$\\gamma = 50.0$，$\\omega = 10.0$，$h = 1.0$，$N = 10$。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含按顺序排列的测试用例的布尔结果，形式为方括号括起来的逗号分隔列表，例如 $\\texttt{[True,False,True,True]}$。不应打印其他任何文本。",
            "solution": "用户提供了一个用于验证和求解的问题陈述。\n\n### 步骤 1：提取已知条件\n- **Dahlquist 测试方程**：$y'(t) = \\lambda y(t)$，其中 $\\lambda \\in \\mathbb{C}$ 且 $t \\in \\mathbb{R}$。\n- **无量纲参数**：$z = h \\lambda$，对于常数步长 $h > 0$。\n- **数值递推**：$y_{n+1} = R(z) y_n$，其中 $R(z)$ 是稳定性（放大）函数。\n- **A-稳定性**：如果对于所有满足 $\\operatorname{Re}(z) \\le 0$ 的 $z \\in \\mathbb{C}$，都有 $|R(z)| \\le 1$，则方法是 A-稳定的。\n- **L-稳定性**：如果方法是 A-稳定的并且在负实轴上 $\\lim_{|z| \\to -\\infty} R(z) = 0$，则方法是 L-稳定的。\n- **任务 1**：为后向欧拉法推导稳定性函数 $R_{\\mathrm{BE}}(z)$，为隐式梯形法则推导 $R_{\\mathrm{TR}}(z)$。\n- **模型参数**：$\\lambda = -\\gamma + i \\omega$，其中 $\\gamma \\ge 0$ 且 $\\omega > 0$。\n- **总步数**：$N$。\n- **精确振幅**：$|y(Nh)| = |y(0)| \\exp(-\\gamma N h)$。\n- **数值振幅**：$|y_N| = |R(z)|^N |y_0|$。\n- **振幅误差定义**：$E_{\\mathrm{amp}} = \\left|\\, |R(z)|^N - \\exp(-\\gamma N h) \\,\\right|$。\n- **任务 2 和 3**：实现一个程序来评估两种方法的 $E_{\\mathrm{amp}}$，如果 $E_{\\mathrm{amp}}^{\\mathrm{TR}}  E_{\\mathrm{amp}}^{\\mathrm{BE}}$ 则返回 $\\mathrm{True}$，否则返回 $\\mathrm{False}$。\n- **测试套件**：\n    - 情况 1：$\\gamma = 0.01$，$\\omega = 10.0$，$h = 0.1$，$N = 100$。\n    - 情况 2：$\\gamma = 0.01$，$\\omega = 10.0$，$h = 0.5$，$N = 20$。\n    - 情况 3：$\\gamma = 0.0$，$\\omega = 10.0$，$h = 0.2$，$N = 50$。\n    - 情况 4：$\\gamma = 50.0$，$\\omega = 10.0$，$h = 1.0$，$N = 10$。\n\n### 步骤 2：使用提取的已知条件进行验证\n根据指定标准对问题进行评估：\n- **科学依据**：本问题是常微分方程数值分析中的一个典型练习。A-稳定性、L-稳定性、Dahlquist 测试方程以及具体方法（后向欧拉法、梯形法则）等概念，都是科学计算领域的基础且成熟的概念。所有定义和前提在事实上都是合理的。\n- **适定性**：该问题具有数学上的精确性。它提供了计算所需量所需的所有必要定义、方程和参数。比较标准明确，可为每个测试用例得出唯一的布尔结果。\n- **客观性**：该问题以正式、客观的语言陈述。分析基于一个定量的误差度量 $E_{\\mathrm{amp}}$，没有主观性。\n- **其他缺陷**：该问题没有其他列出的缺陷。它可以形式化，与指定主题直接相关，是完整、一致且科学可验证的。它并非微不足道，因为它需要正确推导和实现标准但非显而易见的数值分析概念。\n\n### 步骤 3：结论与行动\n此问题是**有效的**。将提供一个合理的解决方案。\n\n### 解法\n\n目标是比较后向欧拉法和隐式梯形法应用于弱阻尼振荡模型方程时的振幅误差。这一比较将通过绝对稳定性理论的视角进行。\n\n**1. 稳定性函数的推导**\n\n单步方法的稳定性函数 $R(z)$ 是通过将该方法应用于 Dahlquist 测试方程 $y'(t) = \\lambda y(t)$，并将第 $n+1$ 步的数值解 $y_{n+1}$ 表示为 $y_{n+1} = R(z) y_n$ 的形式而推导出来的，其中 $z = h\\lambda$。\n\n**后向欧拉法 (BE)：**\n后向欧拉法的公式为：\n$$ y_{n+1} = y_n + h f(t_{n+1}, y_{n+1}) $$\n对于测试方程，$f(t,y) = \\lambda y$。代入可得：\n$$ y_{n+1} = y_n + h \\lambda y_{n+1} $$\n我们求解 $y_{n+1}$：\n$$ y_{n+1} (1 - h\\lambda) = y_n $$\n$$ y_{n+1} = \\frac{1}{1 - h\\lambda} y_n $$\n通过定义 $z = h\\lambda$，我们确定后向欧拉法的稳定性函数为：\n$$ R_{\\mathrm{BE}}(z) = \\frac{1}{1-z} $$\n\n**隐式梯形法则 (TR)：**\n隐式梯形法则的公式为：\n$$ y_{n+1} = y_n + \\frac{h}{2} [f(t_n, y_n) + f(t_{n+1}, y_{n+1})] $$\n代入 $f(t,y) = \\lambda y$ 可得：\n$$ y_{n+1} = y_n + \\frac{h}{2} (\\lambda y_n + \\lambda y_{n+1}) $$\n我们将包含 $y_{n+1}$ 的项收集到左侧，将包含 $y_n$ 的项收集到右侧：\n$$ y_{n+1} \\left(1 - \\frac{h\\lambda}{2}\\right) = y_n \\left(1 + \\frac{h\\lambda}{2}\\right) $$\n求解 $y_{n+1}$：\n$$ y_{n+1} = \\frac{1 + h\\lambda/2}{1 - h\\lambda/2} y_n $$\n使用 $z = h\\lambda$，隐式梯形法则的稳定性函数为：\n$$ R_{\\mathrm{TR}}(z) = \\frac{1 + z/2}{1 - z/2} $$\n\n**2. 振幅误差分析**\n\n问题要求比较两种方法的振幅误差 $E_{\\mathrm{amp}}$。该误差定义为 $N$ 步后的数值振幅衰减因子 $|R(z)|^N$ 与精确振幅衰减因子 $\\exp(-\\gamma N h)$ 之间的绝对差。\n$$ E_{\\mathrm{amp}} = \\left|\\, |R(z)|^N - \\exp(-\\gamma N h) \\,\\right| $$\n参数 $z$ 是根据每个测试用例给定的 $\\gamma$、$\\omega$ 和 $h$ 计算得出的：\n$$ z = h\\lambda = h(-\\gamma + i\\omega) = -h\\gamma + i(h\\omega) $$\n已知这两种方法都是 A-稳定的，这意味着对于任何稳定的物理系统（$\\operatorname{Re}(\\lambda) \\le 0$），数值解都不会出现虚假的增长。然而，它们的定量行为有所不同。后向欧拉法是 L-稳定的，因为 $\\lim_{|z|\\to\\infty} R_{\\mathrm{BE}}(z) = \\lim_{|z|\\to\\infty} \\frac{1}{1-z} = 0$。对于某些分量应快速衰减的刚性问题，此特性是理想的。梯形法则不是 L-稳定的，因为 $\\lim_{|z|\\to\\infty} R_{\\mathrm{TR}}(z) = \\lim_{|z|\\to\\infty} \\frac{1+z/2}{1-z/2} = -1$。这意味着对于 $\\lambda$ 的实部为非常大的负数的分量，梯形法则将其衰减到接近 $(-1)^n y_0$ 的值，从而引入了虚假振荡，而不是将它们衰减到零。然而，梯形法则是二阶精确的，而后向欧拉法仅为一阶精确。这表明对于较小的步长，梯形法则会更准确。\n\n**3. 算法步骤**\n\n对于由元组 $(\\gamma, \\omega, h, N)$ 指定的每个测试用例：\n1.  计算复数 $z = h(-\\gamma + i\\omega)$。\n2.  计算稳定性函数值 $R_{\\mathrm{BE}}(z) = \\frac{1}{1-z}$ 和 $R_{\\mathrm{TR}}(z) = \\frac{1+z/2}{1-z/2}$。\n3.  计算绝对值 $|R_{\\mathrm{BE}}(z)|$ 和 $|R_{\\mathrm{TR}}(z)|$。\n4.  计算 $N$ 步后的数值振幅因子：$|R_{\\mathrm{BE}}(z)|^N$ 和 $|R_{\\mathrm{TR}}(z)|^N$。\n5.  计算精确振幅因子：$A_{\\mathrm{exact}} = \\exp(-\\gamma N h)$。\n6.  计算每种方法的振幅误差：\n    -   $E_{\\mathrm{amp}}^{\\mathrm{BE}} = \\big| |R_{\\mathrm{BE}}(z)|^N - A_{\\mathrm{exact}} \\big|$\n    -   $E_{\\mathrm{amp}}^{\\mathrm{TR}} = \\big| |R_{\\mathrm{TR}}(z)|^N - A_{\\mathrm{exact}} \\big|$\n7.  进行比较：确定是否 $E_{\\mathrm{amp}}^{\\mathrm{TR}}  E_{\\mathrm{amp}}^{\\mathrm{BE}}$。结果是一个布尔值。\n对所有测试用例重复此过程，并将布尔结果收集到一个列表中。\n-   **情况 1 和 2**：在此，阻尼较弱且步长适中。更高的精度阶数（TR 为 2 阶，BE 为 1 阶）预计将使梯形法则具有显著优势。\n-   **情况 3**：这是一个纯振荡系统（$\\gamma=0$）。精确解具有恒定振幅（$A_{\\mathrm{exact}}=1$）。已知梯形法则对此类问题是能量守恒的，即当 $\\operatorname{Re}(z)=0$ 时，有 $|R_{\\mathrm{TR}}(z)|=1$。因此，$E_{\\mathrm{amp}}^{\\mathrm{TR}}$ 将为零。后向欧拉法会引入数值耗散，因此 $|R_{\\mathrm{BE}}(z)|1$，从而导致非零误差。\n-   **情况 4**：此情况代表一个具有强阻尼的刚性问题。项 $\\exp(-\\gamma N h)$ 将非常接近于 $0$。后向欧拉法的 L-稳定性将确保 $|R_{\\mathrm{BE}}(z)|$ 非常小，使得 $E_{\\mathrm{amp}}^{\\mathrm{BE}}$ 也非常小。梯形法则缺乏 L-稳定性意味着 $|R_{\\mathrm{TR}}(z)|$ 将接近于 $1$，从而导致较大的振幅误差。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of comparing amplitude errors for Backward Euler\n    and Implicit Trapezoid methods for a set of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (gamma, omega, h, N)\n    test_cases = [\n        (0.01, 10.0, 0.1, 100),   # Case 1\n        (0.01, 10.0, 0.5, 20),    # Case 2\n        (0.0, 10.0, 0.2, 50),     # Case 3\n        (50.0, 10.0, 1.0, 10),    # Case 4\n    ]\n\n    results = []\n    for gamma, omega, h, N in test_cases:\n        # Calculate the complex parameter z = h * lambda\n        z = h * (-gamma + 1j * omega)\n\n        # ---- Backward Euler (BE) Method ----\n        # Stability function R_BE(z) = 1 / (1 - z)\n        R_be = 1.0 / (1.0 - z)\n        # Numerical amplitude after N steps\n        num_amp_be = np.abs(R_be)**N\n\n        # ---- Implicit Trapezoid (TR) Method ----\n        # Stability function R_TR(z) = (1 + z/2) / (1 - z/2)\n        R_tr = (1.0 + z / 2.0) / (1.0 - z / 2.0)\n        # Numerical amplitude after N steps\n        num_amp_tr = np.abs(R_tr)**N\n\n        # ---- Exact Amplitude ----\n        # The exact amplitude decay factor is exp(-gamma * N * h)\n        exact_amp = np.exp(-gamma * N * h)\n\n        # ---- Amplitude Error Calculation ----\n        # E_amp = | |R(z)|^N - exp(-gamma * N * h) |\n        E_amp_be = np.abs(num_amp_be - exact_amp)\n        E_amp_tr = np.abs(num_amp_tr - exact_amp)\n\n        # ---- Comparison ----\n        # Check if the trapezoid rule has a strictly smaller amplitude error\n        comparison_result = E_amp_tr  E_amp_be\n        results.append(comparison_result)\n\n    # Final print statement in the exact required format.\n    # The required format is [True,False,True,True] but with lowercase booleans\n    print(f\"[{','.join(map(lambda x: str(x).lower(), results))}]\")\n\nsolve()\n```"
        }
    ]
}