{
    "hands_on_practices": [
        {
            "introduction": "线性多步法的威力在于，它们可以根据所期望的准确度和稳定性等性质进行系统性地构建。第一个练习将引导你完成这一基本过程。通过施加准确度阶数和零点稳定性的条件，你将从头推导一个特定的两步法的系数，并分析其在经典测试问题上的行为，从而将抽象理论与可用的数值格式联系起来。",
            "id": "3254441",
            "problem": "考虑形式为 $y'(t)=f(t,y(t))$, $y(t_0)=y_0$ 的初值问题 (IVP)，以及在均匀网格 $t_n=t_0+n h$ 上通过以下形式的公式来近似其解的线性多步法：\n$$\ny_{n+1} \\;=\\; a_0\\,y_n \\;+\\; a_1\\,y_{n-1} \\;+\\; h\\bigl(b_{-1}\\,y'_{n+1} \\;+\\; b_0\\,y'_n\\bigr),\n$$\n其中 $h$ 是步长，且 $y'_k=f(t_k,y_k)$。\n\n推导此族中的一个特定的两步法，该方法满足：\n- 相容且为 $2$ 阶（即，对 $y(t)=1$, $y(t)=t$ 和 $y(t)=t^2$ 是精确的），\n- 零稳定，其特征多项式在 $\\xi=1$ 和 $\\xi=-1$ 处有单根。\n\n按以下步骤进行：\n1. 从线性多步法的定义原则出发，通过对多项式 $y(t)=1$、$y(t)=t$ 和 $y(t)=t^2$ 强制精确性，得到直至 $2$ 阶的阶条件，并在特征多项式在 $\\xi=1$ 和 $\\xi=-1$ 处有根的附加零稳定性约束下，确定系数 $a_0$、$a_1$、$b_{-1}$ 和 $b_0$。\n2. 通过将所得方法应用于线性测试方程 $y'(t)=\\lambda y(t)$（其中 $z=h\\lambda$），分析其绝对稳定性，并推导沿虚轴 $\\{z \\in \\mathbb{C}: z=\\mathrm{i}\\omega h,\\ \\omega\\in\\mathbb{R}\\}$ 的绝对稳定域。\n3. 利用虚轴上的稳定性条件，确定对于振荡测试方程 $y'(t)=\\mathrm{i}\\,\\omega\\,y(t)$（其中 $\\omega=7.5\\,\\mathrm{s}^{-1}$），保证绝对稳定性的最大允许时间步长 $h_{\\max}$。将答案四舍五入到四位有效数字，并以秒为单位表示最终步长。你的最终答案必须是一个数字。",
            "solution": "该问题要求推导和分析一个特定的两步线性多步法。整个过程分为三个部分：确定该方法的系数，分析其绝对稳定性，以及计算给定振荡问题的最大稳定步长。\n\n该两步法的一般形式为：\n$$\ny_{n+1} \\;=\\; a_0\\,y_n \\;+\\; a_1\\,y_{n-1} \\;+\\; h\\bigl(b_{-1}\\,y'_{n+1} \\;+\\; b_0\\,y'_n\\bigr)\n$$\n为了分析此方法，我们首先通过平移索引 $n \\to n+1$，将其表示为 $k$ 步线性多步法的标准形式 $\\sum_{j=0}^k \\alpha_j y_{n+j} = h \\sum_{j=0}^k \\beta_j f_{n+j}$。这得到：\n$$\ny_{n+2} \\;=\\; a_0\\,y_{n+1} \\;+\\; a_1\\,y_{n} \\;+\\; h\\bigl(b_{-1}\\,y'_{n+2} \\;+\\; b_0\\,y'_{n+1}\\bigr)\n$$\n整理成标准形式：\n$$\ny_{n+2} - a_0\\,y_{n+1} - a_1\\,y_{n} = h\\bigl(b_{-1}\\,y'_{n+2} + b_0\\,y'_{n+1}\\bigr)\n$$\n由此，我们确定第一和第二特征多项式的系数：\n$\\alpha_2=1$，$\\alpha_1=-a_0$，$\\alpha_0=-a_1$。\n$\\beta_2=b_{-1}$，$\\beta_1=b_0$，所有其他 $\\beta_j=0$。\n\n### 1. 方法系数的推导\n\n问题指明了两个约束条件来确定四个系数 $a_0, a_1, b_{-1}, b_0$。\n\n首先，我们使用零稳定性约束。第一特征多项式为 $\\rho(\\xi) = \\sum_{j=0}^{2} \\alpha_j \\xi^j = \\alpha_2 \\xi^2 + \\alpha_1 \\xi + \\alpha_0 = \\xi^2 - a_0 \\xi - a_1$。问题指出 $\\rho(\\xi)$ 的根是 $\\xi_1=1$ 和 $\\xi_2=-1$。具有这些根的多项式必须形如 $C(\\xi-1)(\\xi+1) = C(\\xi^2-1)$。由于 $\\rho(\\xi)$ 的首项系数是 $\\alpha_2=1$，我们有 $C=1$，因此 $\\rho(\\xi) = \\xi^2 - 1$。\n将其与 $\\rho(\\xi) = \\xi^2 - a_0 \\xi - a_1$ 进行比较，我们推导出系数：\n$-a_0 = 0 \\implies a_0 = 0$\n$-a_1 = -1 \\implies a_1 = 1$\n\n当 $a_0=0$ 和 $a_1=1$ 时，该方法简化为：\n$$\ny_{n+1} = y_{n-1} + h\\bigl(b_{-1}\\,y'_{n+1} + b_0\\,y'_n\\bigr)\n$$\n接下来，我们使用阶条件。该方法必须对多项式 $y(t)=1$、$y(t)=t$ 和 $y(t)=t^2$ 是精确的。我们可以通过将这些函数代入该方法的方程来检验。为简单起见，我们将网格点中心设在 $t_n$ 处，使得 $t_{n+1}=t_n+h$ 且 $t_{n-1}=t_n-h$。\n\n- **对 $y(t)=1$ 的精确性**：\n如果 $y(t)=1$，则 $y'(t)=0$。公式变为 $1 = 1 + h(b_{-1} \\cdot 0 + b_0 \\cdot 0)$，简化为 $1=1$。这个条件对 $b_{-1}, b_0$ 的任何选择都成立。这等价于相容性条件 $\\rho(1)=0$，而我们选择的根已经满足了此条件。\n\n- **对 $y(t)=t$ 的精确性**：\n如果 $y(t)=t$，则 $y'(t)=1$。在网格点处的精确值为 $y(t_{n+1})=t_{n+1}$ 和 $y(t_{n-1})=t_{n-1}$。公式变为：\n$t_{n+1} = t_{n-1} + h(b_{-1} \\cdot 1 + b_0 \\cdot 1)$\n$(t_n+h) = (t_n-h) + h(b_{-1} + b_0)$\n$2h = h(b_{-1} + b_0)$\n$b_{-1} + b_0 = 2$\n\n- **对 $y(t)=t^2$ 的精确性**：\n如果 $y(t)=t^2$，则 $y'(t)=2t$。精确值为 $y(t_{n+1})=t_{n+1}^2$、$y(t_{n-1})=t_{n-1}^2$、$y'(t_{n+1})=2t_{n+1}$ 和 $y'(t_n)=2t_n$。公式变为：\n$t_{n+1}^2 = t_{n-1}^2 + h\\bigl(b_{-1}(2t_{n+1}) + b_0(2t_n)\\bigr)$\n$(t_n+h)^2 = (t_n-h)^2 + 2h\\bigl(b_{-1}(t_n+h) + b_0 t_n\\bigr)$\n$t_n^2+2t_nh+h^2 = t_n^2-2t_nh+h^2 + 2h\\bigl((b_{-1}+b_0)t_n + b_{-1}h\\bigr)$\n$4t_nh = 2h\\bigl((b_{-1}+b_0)t_n + b_{-1}h\\bigr)$\n$2t_n = (b_{-1}+b_0)t_n + b_{-1}h$\n代入上一步得到的条件 $b_{-1}+b_0=2$：\n$2t_n = 2t_n + b_{-1}h$\n这意味着 $b_{-1}h = 0$。因为 $h \\neq 0$，我们必须有 $b_{-1}=0$。\n\n从 $b_{-1}+b_0=2$ 和 $b_{-1}=0$，我们得到 $b_0=2$。\n确定的系数为 $a_0=0, a_1=1, b_{-1}=0, b_0=2$。所得方法是显式两步中点法：\n$$\ny_{n+1} = y_{n-1} + 2h y'_n\n$$\n\n### 2. 绝对稳定性分析\n\n为了分析绝对稳定性，我们将该方法应用于 Dahlquist 测试方程 $y'(t)=\\lambda y(t)$，其中 $\\lambda \\in \\mathbb{C}$。将 $y'_n = \\lambda y_n$ 代入方法中，得到：\n$$\ny_{n+1} = y_{n-1} + 2h\\lambda y_n\n$$\n令 $z=h\\lambda$。递推关系为：\n$$\ny_{n+1} - 2z y_n - y_{n-1} = 0\n$$\n我们寻找形式为 $y_n = \\xi^n$ 的解。将此拟设代入递推关系中，得到稳定性多项式：\n$$\n\\xi^{n+1} - 2z\\xi^n - \\xi^{n-1} = 0\n$$\n两边同除以 $\\xi^{n-1}$（对于 $\\xi \\neq 0$），我们得到：\n$$\n\\xi^2 - 2z\\xi - 1 = 0\n$$\n对于给定的 $z$，如果该多项式的所有根 $\\xi$ 都满足 $|\\xi| \\le 1$，且任何满足 $|\\xi|=1$ 的根都是单根，则该方法是绝对稳定的。\n\n我们被要求找出沿虚轴的绝对稳定域，其中 $z=i\\alpha$，$ \\alpha = \\omega h \\in \\mathbb{R}$。稳定性多项式变为：\n$$\n\\xi^2 - 2i\\alpha\\xi - 1 = 0\n$$\n根由二次求根公式给出：\n$$\n\\xi = \\frac{2i\\alpha \\pm \\sqrt{(-2i\\alpha)^2 - 4(1)(-1)}}{2} = \\frac{2i\\alpha \\pm \\sqrt{-4\\alpha^2 + 4}}{2} = i\\alpha \\pm \\sqrt{1-\\alpha^2}\n$$\n我们根据 $\\alpha$ 的值来分析根的模：\n\n- **情况 1: $|\\alpha| < 1$**。在这种情况下，$1-\\alpha^2 > 0$，$\\sqrt{1-\\alpha^2}$ 是实数。根为 $\\xi_{1,2} = i\\alpha \\pm \\sqrt{1-\\alpha^2}$。这些复根的模的平方为：\n$|\\xi|^2 = (\\pm\\sqrt{1-\\alpha^2})^2 + (\\alpha)^2 = (1-\\alpha^2) + \\alpha^2 = 1$。\n所以 $|\\xi|=1$。由于 $\\alpha \\neq \\pm 1$，$\\sqrt{1-\\alpha^2}$ 项非零，这意味着两个根是不同的。因此，对于 $|\\alpha| < 1$，我们在单位圆上有两个不同的根。该方法是稳定的。\n\n- **情况 2: $|\\alpha|=1$**。在这种情况下，$1-\\alpha^2=0$。根为 $\\xi = i\\alpha$。这是一个在单位圆上的二重根（$|\\xi|=|i\\alpha|=|\\alpha|=1$）。一个在单位圆盘边界上有重根的方法不是绝对稳定的。\n\n- **情况 3: $|\\alpha|>1$**。在这种情况下，$1-\\alpha^2  0$。我们可以写成 $\\sqrt{1-\\alpha^2} = i\\sqrt{\\alpha^2-1}$。根为：\n$\\xi = i\\alpha \\pm i\\sqrt{\\alpha^2-1} = i(\\alpha \\pm \\sqrt{\\alpha^2-1})$。\n根是纯虚数。它们的模为 $|\\xi| = |\\alpha \\pm \\sqrt{\\alpha^2-1}|$。\n其中一个根的模为 $|\\xi_1| = |\\alpha| + \\sqrt{\\alpha^2-1}$。由于 $|\\alpha|1$，$\\sqrt{\\alpha^2-1}0$，所以 $|\\xi_1|  |\\alpha|  1$。\n因为有一个根的模大于1，该方法是不稳定的。\n\n综合这些发现，沿虚轴的绝对稳定域对应于 $|\\alpha|  1$ 的区间。端点不包括在内。该区域为 $\\{z \\in \\mathbb{C}: z=i\\alpha, -1  \\alpha  1 \\}$。\n\n### 3. 最大步长 $h_{\\max}$ 的计算\n\n我们得到振荡测试方程 $y'(t)=i\\omega y(t)$，其中 $\\omega=7.5\\,\\mathrm{s}^{-1}$。这对应于 $\\lambda = i\\omega$ 的 Dahlquist 测试方程。\n因此，$z = h\\lambda = i\\omega h$。在稳定性分析的记号中，$\\alpha = \\omega h$。\n绝对稳定性的条件是 $|\\alpha|  1$，这可以转化为：\n$$\n|\\omega h|  1\n$$\n给定 $\\omega=7.5\\,\\mathrm{s}^{-1}$ 并且步长 $h$ 必须为正，该不等式变为：\n$$\n7.5 h  1\n$$\n$$\nh  \\frac{1}{7.5} \\, \\mathrm{s}\n$$\n允许的时间步长集合是区间 $(0, 1/7.5)$。最大允许时间步长 $h_{\\max}$ 是这个集合的上确界。\n$$\nh_{\\max} = \\frac{1}{7.5} \\, \\mathrm{s} = \\frac{1}{15/2} \\, \\mathrm{s} = \\frac{2}{15} \\, \\mathrm{s}\n$$\n为了得到数值，我们计算该分数：\n$$\nh_{\\max} = \\frac{2}{15} \\approx 0.133333... \\, \\mathrm{s}\n$$\n问题要求将答案四舍五入到四位有效数字。\n$$\nh_{\\max} \\approx 0.1333 \\, \\mathrm{s}\n$$",
            "answer": "$$\\boxed{0.1333}$$"
        },
        {
            "introduction": "许多最稳健的多步法（例如Adams-Moulton族）都是隐式的，这带来了一个实际挑战：每个时间步都需要求解一个非线性代数方程。本练习深入探讨了这一关键的实现细节。你将实现并比较两种经典的迭代求解器——定点迭代法和牛顿法，以理解它们在应用于Adams-Moulton方法的隐式步骤时的相对性能和收敛特性。",
            "id": "3254452",
            "problem": "考虑初始值问题 $y' = f(y)$，其中 $f(y) = y^3 - y$，在一个均匀时间网格 $t_n = t_0 + n h$ 上，步长 $h  0$。从常微分方程的基本恒等式 $y(t_{n+1}) = y(t_n) + \\int_{t_n}^{t_{n+1}} f(y(t)) \\, dt$ 出发，通过使用梯形法则近似积分，推导二阶单步隐式 Adams–Moulton 方法。这将为 $y_{n+1}$ 得到一个以 $y_n$ 和 $h$ 表示的隐式标量方程，该方程必须在每一步求解。对于右端项 $f(y) = y^3 - y$，这个隐式方程是关于 $y_{n+1}$ 的三次多项式。\n\n您的任务是：\n- 从积分形式和梯形近似出发，推导 $y_{n+1}$ 的隐式标量方程。不要假设任何预先给定的离散公式；从 $y(t_{n+1}) = y(t_n) + \\int_{t_n}^{t_{n+1}} f(y(t)) \\, dt$ 开始并进行逻辑推导。\n- 为单步 $n \\to n+1$ 的隐式方程构建两个求解器：\n  1. 一个基于隐式形式所引出的自然迭代的不动点迭代求解器。\n  2. 一个应用于从隐式方程推导出的残差函数的牛顿法求解器。\n- 为每个求解器定义一个收敛判据和一个最大迭代次数上限。收敛必须通过隐式方程的残差小于指定的容差来检测，并且对于不动点迭代，还需通过连续迭代值之差小于指定的容差来检测。当迭代值变得非有限、超出指定界限，或者牛顿法因导数接近零而无法进行时，通过标记为失败来稳健地处理发散情况。\n\n为了比较收敛盆，对于下面的每个测试用例：\n- 使用其多项式形式计算三次隐式方程的精确实根，并通过从在指定范围内均匀间隔的一组初始猜测值 $\\{y^{(0)}\\}$ 运行每个求解器来对收敛盆进行分类。对于每个初始猜测值，运行求解器，并用最近根分配法确定它收敛到哪个根。如果方法未能收敛，则记录为失败。\n- 使用以下参数进行收敛盆扫描：\n  - 初始猜测值网格：在 $[-2, 2]$ 上均匀间隔的 $101$ 个点。\n  - 最大迭代次数：$100$。\n  - 成功阈值：两种方法的残差容差均为 $10^{-12}$；不动点迭代的连续迭代容差为 $10^{-10}$。\n  - 发散界限：如果 $|y|$ 超过 $10^6$，或者牛顿法在任何迭代中遇到小于 $10^{-14}$ 的导数幅值，则声明失败。\n\n测试套件（每一项是一个对 $(y_n, h)$）：\n- 测试 A（顺利情况）：$(y_n, h) = (0.2, 0.1)$。\n- 测试 B（中度非线性）：$(y_n, h) = (0.8, 1.0)$。\n- 测试 C（强非线性，对不动点迭代有挑战）：$(y_n, h) = (-0.5, 2.0)$。\n\n按如下方式精确定义最终输出格式。对于每个测试用例，设 $r_1  r_2  \\dots  r_k$ 为隐式三次方程的排序后的实根。您的程序必须为该测试用例生成一个单一列表，结构为\n$[c^{\\text{fp}}_1, c^{\\text{fp}}_2, \\dots, c^{\\text{fp}}_k, F^{\\text{fp}}, c^{\\text{N}}_1, c^{\\text{N}}_2, \\dots, c^{\\text{N}}_k, F^{\\text{N}}]$\n其中 $c^{\\text{fp}}_i$ 是在不动点迭代下收敛到根 $r_i$ 的初始猜测值数量，$F^{\\text{fp}}$ 是不动点迭代失败的次数，$c^{\\text{N}}_i$ 是在牛顿法下收敛到根 $r_i$ 的初始猜测值数量，$F^{\\text{N}}$ 是牛顿法失败的次数。在所有测试用例中，将这些每个用例的列表聚合到一个单一的顶层列表中，并将该顶层列表打印在一行上，作为一个用方括号括起来的逗号分隔列表，不含空格。输出为整数，不涉及物理单位或角度。\n\n您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的、不含空格的结果列表。例如，对于三个测试用例，输出必须如下所示：\n[[a1,a2,...,afp,b1,b2,...,bn],[c1,c2,...,cfp,d1,d2,...,dn],[e1,e2,...,efp,f1,f2,...,fn]]",
            "solution": "该问题要求对一个初始值问题（IVP）的数值方法进行推导和分析。我将首先验证问题陈述。\n\n### 第 1 步：提取给定条件\n- **IVP**：$y' = f(y)$，其中 $f(y) = y^3 - y$。\n- **时间网格**：$t_n = t_0 + n h$，步长 $h  0$。\n- **基本恒等式**：$y(t_n) + \\int_{t_n}^{t_{n+1}} f(y(t)) \\, dt = y(t_{n+1})$。\n- **数值方法**：二阶隐式 Adams-Moulton 方法，将通过对基本恒等式中的积分应用梯形法则来推导。\n- **求解器**：将为得到的隐式方程实现两种求根方法：(1) 不动点迭代，和 (2) 牛顿法。\n- **收敛盆分析参数**：\n    - **初始猜测值**：在区间 $[-2, 2]$ 上的 $101$ 个均匀分布的点。\n    - **最大迭代次数**：$100$。\n    - **容差**：两种方法的残差容差均为 $\\epsilon_{\\text{res}} = 10^{-12}$。仅用于不动点迭代的连续迭代值之差的容差为 $\\epsilon_{\\text{diff}} = 10^{-10}$。\n    - **发散判据**：如果迭代值 $y^{(k)}$ 的幅值 $|y^{(k)}|  10^6$，值为非有限，或者牛顿法中导数的幅值小于 $10^{-14}$，则失败。\n- **测试用例**：给定的 $(y_n, h)$ 对为 A: $(0.2, 0.1)$，B: $(0.8, 1.0)$，和 C: $(-0.5, 2.0)$。\n- **输出格式**：一个特定的嵌套列表格式，表示对于每个求解器和每个测试用例，收敛到隐式方程每个实根的初始猜测值的数量，以及失败的次数。\n\n### 第 2 步：使用提取的给定条件进行验证\n该问题在科学上和数学上是合理的。它涉及常微分方程数值分析中的标准概念：一个隐式积分器（梯形法则，即二阶 Adams-Moulton 方法）的推导，以及应用标准的迭代求根技术（不动点法和牛顿法）来求解每个时间步产生的非线性代数方程。\n\n所有参数、条件和测试用例都已明确指定。该任务是适定的、客观的且自洽的。它提出了一个标准的、非平凡的数值实验，以比较两种不同求解器的吸引盆，这是科学计算中的一个核心课题。不存在矛盾、事实错误或违反物理或数学原理的情况。\n\n### 第 3 步：结论与行动\n该问题被认为是**有效的**。将提供一个附带推理过程的完整解法。\n\n### 隐式方程的推导\n\n我们从 ODE $y' = f(y)$ 解 $y(t)$ 的基本精确恒等式开始：\n$$\ny(t_{n+1}) = y(t_n) + \\int_{t_n}^{t_{n+1}} f(y(t)) \\, dt\n$$\n设 $y_n$ 是 $y(t_n)$ 的数值近似。我们寻求 $y_{n+1} \\approx y(t_{n+1})$ 的近似值。该积分使用梯形法则进行近似：\n$$\n\\int_{t_n}^{t_{n+1}} g(t) \\, dt \\approx \\frac{t_{n+1} - t_n}{2} [g(t_n) + g(t_{n+1})]\n$$\n将此应用于我们的积分，其中 $g(t) = f(y(t))$ 且 $h = t_{n+1} - t_n$，我们得到：\n$$\n\\int_{t_n}^{t_{n+1}} f(y(t)) \\, dt \\approx \\frac{h}{2} [f(y(t_n)) + f(y(t_{n+1}))]\n$$\n将此代入基本恒等式的离散化版本，得到隐式单步方法：\n$$\ny_{n+1} = y_n + \\frac{h}{2} [f(y_n) + f(y_{n+1})]\n$$\n这是二阶单步 Adams-Moulton 方法，也称为 ODE 的梯形法则。对于给定的函数 $f(y) = y^3 - y$，方程变为：\n$$\ny_{n+1} = y_n + \\frac{h}{2} [(y_n^3 - y_n) + (y_{n+1}^3 - y_{n+1})]\n$$\n为了将其分析为关于 $y_{n+1}$ 的求根问题，我们重排各项以形成一个残差函数 $R(z)$，其中 $z$ 代表未知的 $y_{n+1}$。我们寻求使 $R(z) = 0$ 的 $z$。\n$$\nR(z) = z - y_n - \\frac{h}{2} [f(y_n) + f(z)] = 0\n$$\n代入 $f(z) = z^3 - z$ 得：\n$$\nR(z) = z - y_n - \\frac{h}{2} [(y_n^3 - y_n) + (z^3 - z)] = 0\n$$\n按 $z$ 的幂次对项进行分组，我们得到一个关于 $y_{n+1}$ 的三次多项式方程：\n$$\n-\\frac{h}{2} z^3 + (1 + \\frac{h}{2})z - \\left( y_n + \\frac{h}{2}(y_n^3 - y_n) \\right) = 0\n$$\n这就是在每个时间步必须为 $y_{n+1}$ 求解的隐式标量方程。\n\n### 数值求解器\n\n对于给定的 $y_n$ 和 $h$，我们必须找到三次方程 $R(z) = 0$ 的根。\n\n**1. 不动点迭代**\n\n隐式方程 $y_{n+1} = y_n + \\frac{h}{2} [f(y_n) + f(y_{n+1})]$ 自然地提出了一个不动点迭代格式。设 $z$ 是我们的未知数 $y_{n+1}$。我们定义一个迭代函数 $G(z)$ 和格式 $z^{(k+1)} = G(z^{(k)})$：\n$$\nG(z) = y_n + \\frac{h}{2} [f(y_n) + f(z)]\n$$\n对于特定的 $f(y) = y^3 - y$，这变为：\n$$\nz^{(k+1)} = y_n + \\frac{h}{2} [(y_n^3 - y_n) + ((z^{(k)})^3 - z^{(k)})]\n$$\n从一个初始猜测值 $z^{(0)}$ 开始，我们进行迭代直到达到收敛。收敛由两个条件确定：隐式方程的残差幅值 $|R(z^{(k+1)})|$ 必须小于 $\\epsilon_{\\text{res}} = 10^{-12}$，并且连续迭代值之差的幅值 $|z^{(k+1)} - z^{(k)}|$ 必须小于 $\\epsilon_{\\text{diff}} = 10^{-10}$。\n\n**2. 牛顿法**\n\n牛顿法使用以下迭代来找到 $R(z) = 0$ 的一个根：\n$$\nz^{(k+1)} = z^{(k)} - \\frac{R(z^{(k)})}{R'(z^{(k)})}\n$$\n我们有残差函数：\n$$\nR(z) = z - y_n - \\frac{h}{2} [f(y_n) + f(z)]\n$$\n它关于 $z$ 的导数是：\n$$\nR'(z) = \\frac{d}{dz} \\left( z - \\frac{h}{2}f(z) - \\text{const} \\right) = 1 - \\frac{h}{2} f'(z)\n$$\n对于 $f(y) = y^3 - y$，其导数为 $f'(y) = 3y^2 - 1$。所以，\n$$\nR'(z) = 1 - \\frac{h}{2} (3z^2 - 1)\n$$\n迭代从一个猜测值 $z^{(0)}$ 开始，并持续进行直到残差幅值 $|R(z^{(k+1)})|$ 小于 $\\epsilon_{\\text{res}} = 10^{-12}$。\n\n### 收敛盆分析\n\n对于每个测试用例 $(y_n, h)$，分析过程如下：\n1.  **识别根**：确定三次多项式 $R(z)=0$ 的系数。使用一个稳健的数值多项式求根器找到根。我们筛选出实根，并将其排序为 $r_1  r_2  \\dots  r_k$。对于一个三次多项式，$k$ 可以是 $1$ 或 $3$。\n2.  **扫描初始猜测值**：在区间 $[-2, 2]$ 上均匀地创建一个包含 $101$ 个初始猜测值 $\\{z^{(0)}\\}$ 的网格。\n3.  **运行和分类**：对于网格上的每个 $z^{(0)}$：\n    - 执行不动点求解器。如果它收敛到一个值 $z_{\\text{sol}}$，通过找到最接近 $z_{\\text{sol}}$ 的根 $r_j$ 来对结果进行分类。该根的计数器 $c^{\\text{fp}}_j$ 增加。如果求解器失败（由于达到最大迭代次数、发散或出现非有限值），失败计数器 $F^{\\text{fp}}$ 增加。\n    - 执行牛顿法求解器。结果以类似方式分类，增加相应的根计数器 $c^{\\text{N}}_j$ 或失败计数器 $F^{\\text{N}}$。\n4.  **聚合结果**：对于每个测试用例，将计数收集到一个单一列表 $[c^{\\text{fp}}_1, \\dots, c^{\\text{fp}}_k, F^{\\text{fp}}, c^{\\text{N}}_1, \\dots, c^{\\text{N}}_k, F^{\\text{N}}]$ 中。然后，将这些列表聚合为所有测试用例的最终列表的列表。\n\n这个过程为每个求解器的吸引盆大小提供了定量比较。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives, solves, and analyzes an implicit ODE solver to determine basins of convergence.\n    \"\"\"\n    # Define test cases: (yn, h) pairs\n    test_cases = [\n        (0.2, 0.1),  # Test A\n        (0.8, 1.0),  # Test B\n        (-0.5, 2.0), # Test C\n    ]\n\n    # Parameters for basin scan\n    initial_guesses = np.linspace(-2.0, 2.0, 101)\n    max_iter = 100\n    res_tol = 1e-12\n    fp_diff_tol = 1e-10\n    div_bound = 1e6\n    newton_deriv_tol = 1e-14\n\n    all_results = []\n\n    for yn, h in test_cases:\n        # Define the functions for this (yn, h)\n        def f(y):\n            return y**3 - y\n\n        def G_fp(y): # Fixed-point iteration function\n            return yn + h / 2.0 * (f(yn) + f(y))\n\n        def R(y): # Residual function R(y) = 0\n            return y - G_fp(y)\n\n        def R_prime(y): # Derivative of the residual function\n            return 1.0 - h / 2.0 * (3.0 * y**2 - 1.0)\n        \n        # Find the real roots of the cubic polynomial R(z) = 0\n        # R(z) = -h/2 * z^3 + (1 + h/2) * z - (yn + h/2 * (yn^3-yn)) = 0\n        poly_coeffs = [\n            -h / 2.0,\n            0.0,\n            1.0 + h / 2.0,\n            -(yn + h / 2.0 * f(yn))\n        ]\n        roots = np.roots(poly_coeffs)\n        real_roots = np.sort(roots[np.isreal(roots)].real)\n        num_roots = len(real_roots)\n\n        # Initialize counters for this test case\n        # [c_fp_1, ..., c_fp_k, F_fp, c_N_1, ..., c_N_k, F_N]\n        counts = np.zeros(2 * num_roots + 2, dtype=int)\n        \n        fp_failure_idx = num_roots\n        newton_start_idx = num_roots + 1\n        newton_failure_idx = 2 * num_roots + 1\n\n        for y0 in initial_guesses:\n            # --- Fixed-Point Iteration Solver ---\n            y = y0\n            converged = False\n            for _ in range(max_iter):\n                y_prev = y\n                y = G_fp(y)\n                if not np.isfinite(y) or np.abs(y) > div_bound:\n                    break\n                \n                res = np.abs(R(y))\n                diff = np.abs(y - y_prev)\n                \n                if res  res_tol and diff  fp_diff_tol:\n                    converged = True\n                    break\n            \n            if converged:\n                root_idx = np.argmin(np.abs(real_roots - y))\n                counts[root_idx] += 1\n            else:\n                counts[fp_failure_idx] += 1\n\n            # --- Newton's Method Solver ---\n            y = y0\n            converged = False\n            for _ in range(max_iter):\n                deriv = R_prime(y)\n                if not np.isfinite(y) or np.abs(deriv)  newton_deriv_tol:\n                    break\n                \n                step = R(y) / deriv\n                y = y - step\n                \n                if not np.isfinite(y) or np.abs(y) > div_bound:\n                    break\n                \n                if np.abs(R(y))  res_tol:\n                    converged = True\n                    break\n\n            if converged:\n                root_idx = np.argmin(np.abs(real_roots - y))\n                counts[newton_start_idx + root_idx] += 1\n            else:\n                counts[newton_failure_idx] += 1\n        \n        all_results.append(counts.tolist())\n\n    # Format output as specified: [[...],[...]]; no spaces\n    output_str = f\"[{','.join(str(sublist).replace(' ', '') for sublist in all_results)}]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "高效求解微分方程通常需要根据解的局部行为来调整数值方法。这个综合性练习将所有知识点融会贯通，要求你构建一个变阶预测-校正求解器。通过使用Adams-Bashforth预测值和Adams-Moulton校正值之间的差异来估计局部误差，你将实现一种在每一步动态选择最合适方法阶数的策略，从而创建一个更智能、更高效的求解器。",
            "id": "3254424",
            "problem": "为常微分方程（ODE）的初值问题（IVP）实现一个变阶 Adams–Bashforth–Moulton 预估-校正求解器。从 IVP 的基本定义开始：给定一个光滑的右端函数 $f(t,y)$，求解满足 $y^{\\prime}(t)=f(t,y)$ 和 $y(t_{0})=y_{0}$ 的 $y(t)$。您的求解器必须在均匀网格 $t_{n}=t_{0}+n h$ 上使用固定步长 $h$，并根据从该阶的 Adams–Bashforth 预估值和 Adams–Moulton 校正值之差导出的局部截断误差（LTE）估计，在每一步动态选择阶数 $p\\in\\{2,3,4\\}$。具体来说，在步 $n\\to n+1$ 处，计算一个预估值 $y_{n+1}^{\\text{pred},(p)}$ 和一个校正值 $y_{n+1}^{\\text{corr},(p)}$；将 LTE 估计定义为 $e_{n+1}^{(p)}=\\lvert y_{n+1}^{\\text{corr},(p)}-y_{n+1}^{\\text{pred},(p)}\\rvert$。在具有可用历史信息的可选阶数中，选择满足 $e_{n+1}^{(p)}\\le \\text{atol}$ 的最大阶数 $p\\in\\{2,3,4\\}$，其中 $\\text{atol}$ 是用户指定的绝对容差。如果没有阶数满足容差，则该步使用 $p=2$。任何三角函数求值均使用弧度。对于启动阶段，当历史信息不足时，您必须使用一个阶数至少为 4 的自启动单步法来生成所需的过去值；使用经典的四阶 Runge–Kutta 方法产生足够的初始步数，以便预估-校正方法可以运行。\n\n为标量 ODE 实现您的求解器。在积分过程中，您不得更改步长 $h$；只有阶数 $p$ 可以改变。在每个被接受的步骤，为了用于后续步骤，请在校正值 $y_{n+1}^{\\text{corr},(p)}$ 处计算 $f(t_{n+1},y_{n+1})$。\n\n测试套件。在以下四个初值问题上运行您的求解器。在所有情况下，都使用指定的绝对容差和步长。对于三角函数，使用弧度。\n\n- 测试 $1$ (指数衰减): $y^{\\prime}(t)=-y(t)$, $y(0)=1$, 积分至 $T=1$，使用 $h=0.05$ 和 $\\text{atol}=10^{-8}$。精确解为 $y(t)=e^{-t}$。\n- 测试 $2$ (随时间变化的速率呈指数增长): $y^{\\prime}(t)=t\\,y(t)$, $y(0)=1$, 积分至 $T=2$，使用 $h=0.1$ 和 $\\text{atol}=10^{-7}$。精确解为 $y(t)=\\exp\\!\\left(\\tfrac{1}{2}t^{2}\\right)$。\n- 测试 $3$ (带振荡的强迫线性系统): $y^{\\prime}(t)=\\cos(t)-y(t)$, $y(0)=0$, 积分至 $T=5$，使用 $h=0.05$ 和 $\\text{atol}=10^{-6}$。精确解为 $y(t)=\\tfrac{1}{2}\\big(\\cos t+\\sin t\\big)-\\tfrac{1}{2}e^{-t}$。\n- 测试 $4$ (多项式右端项): $y^{\\prime}(t)=t^{3}$, $y(0)=0$, 积分至 $T=1$，使用 $h=0.2$ 和 $\\text{atol}=10^{-10}$。精确解为 $y(t)=\\tfrac{1}{4}t^{4}$。\n\n对于每个测试，计算最终时间的绝对误差，即 $\\lvert y_{\\text{num}}(T)-y_{\\text{exact}}(T)\\rvert$，结果为浮点数。\n\n最终输出格式。您的程序应生成单行输出，其中包含按上述测试顺序列出的、用方括号括起来的逗号分隔列表的结果。例如，生成类似 `[result1,result2,result3,result4]` 的行，不含任何额外文本。三角函数求值所用的角度必须是弧度。",
            "solution": "该问题是有效的。它描述了数值分析中的一个明确定义的任务：实现一种变阶 Adams-Bashforth-Moulton (ABM) 预估-校正方法，用于求解一阶常微分方程（ODE），这是科学计算中的一个标准课题。所有必要的条件、参数和测试用例都已提供，并且该问题基于既定的数学原理。\n\n下面是附带推理的解决方案。\n\n### 1. 问题表述\n\n我们的任务是数值求解以下形式的标量初值问题（IVP）：\n$$\ny'(t) = f(t, y(t)), \\quad y(t_0) = y_0\n$$\n解是在固定步长 $h$ 的均匀时间网格 $t_n = t_0 + n h$ 上计算的。我们将精确解 $y(t_n)$ 的数值近似表示为 $y_n$，并将导函数的求值表示为 $f_n = f(t_n, y_n)$。\n\n### 2. Adams-Bashforth-Moulton (ABM) 方法\n\n该求解器的核心是一种预估-校正方法，它结合了用于预估步骤的显式 Adams-Bashforth (AB) 方法和用于校正步骤的隐式 Adams-Moulton (AM) 方法。这是以 PECE（预估-求值-校正-求值）的方式实现的。\n\n#### 2.1. Adams-Bashforth 预估式（显式）\n\nAB 方法是显式线性多步法，它使用导数的过去值 $\\{f_n, f_{n-1}, \\ldots\\}$ 来预估下一个值 $y_{n+1}$。阶数 $p=2, 3, 4$ 的公式如下：\n\n-   **阶 $p=2$ (AB2):** 需要历史信息 $\\{f_n, f_{n-1}\\}$。\n    $$\n    y_{n+1}^{\\text{pred},(2)} = y_n + \\frac{h}{2} (3f_n - f_{n-1})\n    $$\n-   **阶 $p=3$ (AB3):** 需要历史信息 $\\{f_n, f_{n-1}, f_{n-2}\\}$。\n    $$\n    y_{n+1}^{\\text{pred},(3)} = y_n + \\frac{h}{12} (23f_n - 16f_{n-1} + 5f_{n-2})\n    $$\n-   **阶 $p=4$ (AB4):** 需要历史信息 $\\{f_n, f_{n-1}, f_{n-2}, f_{n-3}\\}$。\n    $$\n    y_{n+1}^{\\text{pred},(4)} = y_n + \\frac{h}{24} (55f_n - 59f_{n-1} + 37f_{n-2} - 9f_{n-3})\n    $$\n\n#### 2.2. Adams-Moulton 校正式（隐式）\n\nAM 方法是隐式的，因为它们使用尚未确定的值 $f_{n+1} = f(t_{n+1}, y_{n+1})$。在 PECE 方案中，我们通过使用预估值 $y_{n+1}^{\\text{pred},(p)}$ 来评估导数，从而使校正步骤变为显式：$f_{n+1}^{\\text{pred},(p)} = f(t_{n+1}, y_{n+1}^{\\text{pred},(p)})$。阶数 $p=2, 3, 4$ 的 AM 公式如下：\n\n-   **阶 $p=2$ (AM2):**\n    $$\n    y_{n+1}^{\\text{corr},(2)} = y_n + \\frac{h}{2} (f_{n+1}^{\\text{pred},(2)} + f_n)\n    $$\n-   **阶 $p=3$ (AM3):**\n    $$\n    y_{n+1}^{\\text{corr},(3)} = y_n + \\frac{h}{12} (5f_{n+1}^{\\text{pred},(3)} + 8f_n - f_{n-1})\n    $$\n-   **阶 $p=4$ (AM4):**\n    $$\n    y_{n+1}^{\\text{corr},(4)} = y_n + \\frac{h}{24} (9f_{n+1}^{\\text{pred},(4)} + 19f_n - 5f_{n-1} + f_{n-2})\n    $$\n\n### 3. 误差估计与阶数选择\n\n该求解器的一个关键特性是其在每一步动态选择阶数 $p \\in \\{2, 3, 4\\}$ 的能力。这是由局部截断误差（LTE）的估计来指导的。同阶预估值和校正值之间的差异为 LTE 提供了一个方便且理论上可靠的代理。\n\n阶数 $p$ 的 LTE 估计定义为：\n$$\ne_{n+1}^{(p)} = \\lvert y_{n+1}^{\\text{corr},(p)} - y_{n+1}^{\\text{pred},(p)} \\rvert\n$$\n在每一步 $n \\to n+1$，求解器的逻辑如下：\n1.  对于每个可用阶数 $p \\in \\{4, 3, 2\\}$，计算预估值、校正值和 LTE 估计 $e_{n+1}^{(p)}$。\n2.  选择误差估计在指定绝对容差范围内的最大阶数 $p$：$e_{n+1}^{(p)} \\le \\text{atol}$。\n3.  如果没有阶数满足此条件，求解器默认使用最低可用阶数 $p=2$。\n\n### 4. 启动程序\n\n线性多步法不是自启动的；它们需要过去解点的历史信息。为了使用高达 $p=4$ 的全部阶数范围，我们需要四个初始点：$(t_0, y_0), (t_1, y_1), (t_2, y_2), (t_3, y_3)$，以及它们对应的导数评估值。\n\n问题指定为此目的使用一个阶数至少为 4 的单步法。我们将使用经典的四阶 Runge-Kutta (RK4) 方法。给定 $t_n$ 处的 $y_n$，下一个值 $y_{n+1}$ 通过以下方式找到：\n$$\nk_1 = f(t_n, y_n) \\\\\nk_2 = f(t_n + \\frac{h}{2}, y_n + \\frac{h}{2} k_1) \\\\\nk_3 = f(t_n + \\frac{h}{2}, y_n + \\frac{h}{2} k_2) \\\\\nk_4 = f(t_n + h, y_n + h k_3) \\\\\ny_{n+1} = y_n + \\frac{h}{6} (k_1 + 2k_2 + 2k_3 + k_4)\n$$\n我们将在前三个步骤（$n=0, 1, 2$）应用 RK4 来生成 $y_1, y_2$ 和 $y_3$，从而为 ABM 方法从第一步起以高达 4 阶的阶数运行提供足够的历史信息。\n\n### 5. 算法摘要\n\n求解器算法按以下步骤进行：\n\n1.  **初始化**：给定 $f, t_0, y_0, T, h, \\text{atol}$。创建数组来存储时间点 $t_n$、解值 $y_n$ 和导数值 $f_n$。用给定的 $(t_0, y_0)$ 进行初始化并计算 $f_0$。\n2.  **启动阶段**：对于步骤 $n=0, 1, 2$，使用 RK4 方法计算 $y_{n+1}$。存储每个计算出的 $(t_{n+1}, y_{n+1})$ 并计算和存储相应的 $f_{n+1}$。\n3.  **主循环**：对于步骤 $n=3$ 到 $N-1$，其中 $N$ 是总步数：\n    a.  为 $p \\in \\{2, 3, 4\\}$ 计算预估-校正对和误差估计 $e_{n+1}^{(p)}$。\n    b.  根据指定的容差标准选择最佳阶数 `chosen_p`。\n    c.  将下一个解值 $y_{n+1}$ 设置为所选阶数的校正值 $y_{n+1}^{\\text{corr},(\\text{chosen\\_p})}$。\n    d.  计算并存储 $f_{n+1} = f(t_{n+1}, y_{n+1})$ 以更新后续步骤的历史信息。\n4.  **最终结果**：解数组中的最后一个值 $y_N$ 是最终时间 $T$ 的数值近似。然后根据提供的精确解计算绝对误差。\n\n这种结构化的方法确保了求解器是鲁棒的，并遵守问题陈述的所有要求。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef variable_order_abm_solver(f, t0, y0, T, h, atol):\n    \"\"\"\n    Implements a variable-order Adams-Bashforth-Moulton solver.\n    \"\"\"\n    # 1. Grid and History Setup\n    # Use round() to mitigate floating point inaccuracies in step calculation\n    num_steps = int(round((T - t0) / h))\n    t_vals = t0 + np.arange(num_steps + 1) * h\n    y_vals = np.zeros(num_steps + 1)\n    f_vals = np.zeros(num_steps + 1)\n\n    y_vals[0] = y0\n    f_vals[0] = f(t_vals[0], y_vals[0])\n\n    # 2. Startup Phase (3 steps with RK4)\n    # This generates y_1, y_2, y_3 and populates history f_0 to f_3\n    # which is required to start the main loop with max order p=4.\n    for n in range(3):\n        tn, yn = t_vals[n], y_vals[n]\n        k1 = f(tn, yn)\n        k2 = f(tn + 0.5 * h, yn + 0.5 * h * k1)\n        k3 = f(tn + 0.5 * h, yn + 0.5 * h * k2)\n        k4 = f(tn + h, yn + h * k3)\n        y_vals[n + 1] = yn + (h / 6.0) * (k1 + 2 * k2 + 2 * k3 + k4)\n        f_vals[n + 1] = f(t_vals[n + 1], y_vals[n + 1])\n\n    # 3. Main Loop (Variable-order ABM)\n    for n in range(3, num_steps):\n        tnp1 = t_vals[n + 1]\n        yn = y_vals[n]\n        fn, fnm1, fnm2, fnm3 = f_vals[n], f_vals[n-1], f_vals[n-2], f_vals[n-3]\n\n        y_corr = {}\n        errors = {}\n\n        # --- Try Order p = 4 ---\n        y_pred_4 = yn + (h / 24.0) * (55*fn - 59*fnm1 + 37*fnm2 - 9*fnm3)\n        f_pred_4 = f(tnp1, y_pred_4)\n        y_corr[4] = yn + (h / 24.0) * (9*f_pred_4 + 19*fn - 5*fnm1 + 1*fnm2)\n        errors[4] = abs(y_corr[4] - y_pred_4)\n\n        # --- Try Order p = 3 ---\n        y_pred_3 = yn + (h / 12.0) * (23*fn - 16*fnm1 + 5*fnm2)\n        f_pred_3 = f(tnp1, y_pred_3)\n        y_corr[3] = yn + (h / 12.0) * (5*f_pred_3 + 8*fn - 1*fnm1)\n        errors[3] = abs(y_corr[3] - y_pred_3)\n\n        # --- Try Order p = 2 ---\n        y_pred_2 = yn + (h / 2.0) * (3*fn - 1*fnm1)\n        f_pred_2 = f(tnp1, y_pred_2)\n        y_corr[2] = yn + (h / 2.0) * (1*f_pred_2 + 1*fn)\n        errors[2] = abs(y_corr[2] - y_pred_2)\n        \n        # Order Selection: select largest p that satisfies tolerance\n        chosen_p = 0\n        if errors[4] = atol:\n            chosen_p = 4\n        elif errors[3] = atol:\n            chosen_p = 3\n        elif errors[2] = atol:\n            chosen_p = 2\n        else:\n            # Default to p=2 if no order meets the tolerance\n            chosen_p = 2\n\n        # 4. Update State\n        y_vals[n + 1] = y_corr[chosen_p]\n        f_vals[n + 1] = f(t_vals[n + 1], y_vals[n + 1])\n\n    return y_vals[-1]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"f\": lambda t, y: -y,\n            \"y0\": 1.0,\n            \"t0\": 0.0,\n            \"T\": 1.0,\n            \"h\": 0.05,\n            \"atol\": 1e-8,\n            \"y_exact\": lambda t: np.exp(-t),\n        },\n        {\n            \"f\": lambda t, y: t * y,\n            \"y0\": 1.0,\n            \"t0\": 0.0,\n            \"T\": 2.0,\n            \"h\": 0.1,\n            \"atol\": 1e-7,\n            \"y_exact\": lambda t: np.exp(0.5 * t**2),\n        },\n        {\n            \"f\": lambda t, y: np.cos(t) - y,\n            \"y0\": 0.0,\n            \"t0\": 0.0,\n            \"T\": 5.0,\n            \"h\": 0.05,\n            \"atol\": 1e-6,\n            \"y_exact\": lambda t: 0.5 * (np.cos(t) + np.sin(t)) - 0.5 * np.exp(-t),\n        },\n        {\n            \"f\": lambda t, y: t**3,\n            \"y0\": 0.0,\n            \"t0\": 0.0,\n            \"T\": 1.0,\n            \"h\": 0.2,\n            \"atol\": 1e-10,\n            \"y_exact\": lambda t: 0.25 * t**4,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        y_final_numeric = variable_order_abm_solver(\n            f=case[\"f\"],\n            t0=case[\"t0\"],\n            y0=case[\"y0\"],\n            T=case[\"T\"],\n            h=case[\"h\"],\n            atol=case[\"atol\"],\n        )\n        y_final_exact = case[\"y_exact\"](case[\"T\"])\n        error = abs(y_final_numeric - y_final_exact)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}