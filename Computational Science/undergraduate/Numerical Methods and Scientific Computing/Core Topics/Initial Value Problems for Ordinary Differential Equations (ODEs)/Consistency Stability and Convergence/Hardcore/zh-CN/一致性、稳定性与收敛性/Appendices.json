{
    "hands_on_practices": [
        {
            "introduction": "理论学习之后，最好的巩固方式莫过于亲手实践。我们将从一个简单的振荡系统入手，探索几种基本单步法的表现。这个核心测试问题 $y' = i\\omega y$ 的解析解在复平面上描绘一个完美的圆，其模长（代表能量或振幅）保持不变。通过比较前向欧拉法、后向欧拉法和梯形法则的数值解，你将直观地看到不同方法如何引入数值耗散或增长，从而深刻理解绝对稳定性的几何意义。",
            "id": "3216925",
            "problem": "考虑线性常微分方程 (ODE) $y'(t) = i\\omega y(t)$，其中频率 $\\omega  0$ 为实数，且初始条件 $y(0) = y_{0} \\in \\mathbb{C}$ 为复数。给定一个固定的时间步长 $h  0$，并考虑以下单步数值方法：前向欧拉法、后向欧拉法和梯形法则（也称为 Crank–Nicolson 方法）。从这些方法作为 $y'(t) = f(t,y)$ 的显式或隐式单步近似的基本定义出发，推导此常微分方程对应的离散更新关系。利用线性测试方程 $y' = \\lambda y$ 的放大因子（也称稳定性函数）的基本概念，其中单步更新可写为 $y_{n+1} = R(z)\\,y_{n}$，且 $z = \\lambda h$，求出每种方法的放大因子。然后，将情况特殊化至 $\\lambda = i\\omega$，并确定每种方法的放大因子的绝对值。从基本原理出发，解释随着 $n$ 的增加，这些绝对值如何决定离散解在复平面上是向外螺旋、向内螺旋还是保持在圆周上。最后，设 $r_{0} = |y_{0}|$ 且 $N \\in \\mathbb{N}$ 为所取的步数。提供每种方法产生的模 $|y_{N}|$ 关于 $\\omega$、$h$、$r_{0}$ 和 $N$ 的闭式表达式。将最终答案表示为一个单行矩阵，其中包含按前向欧拉法、后向欧拉法、梯形法则顺序排列的三个模。无需四舍五入，所有量均为无量纲。",
            "solution": "首先根据所需标准对问题陈述进行验证。\n\n**第 1 步：提取已知条件**\n- **常微分方程**：$y'(t) = i\\omega y(t)$\n- **常数和变量**：$\\omega \\in \\mathbb{R}$, $\\omega  0$; $h  0$; $N \\in \\mathbb{N}$\n- **初始条件**：$y(0) = y_{0} \\in \\mathbb{C}$\n- **定义**：$r_{0} = |y_{0}|$\n- **方法**：前向欧拉法、后向欧拉法、梯形法则 (Crank-Nicolson)\n- **框架**：线性测试方程 $y' = \\lambda y$ 导致单步更新 $y_{n+1} = R(z)y_{n}$，其中 $z = \\lambda h$。\n- **任务**：推导更新关系，求放大因子 $R(z)$，特殊化至 $\\lambda = i\\omega$ 以求得 $|R(i\\omega h)|$，解释放大因子大小的几何意义，并为每种方法提供 $|y_N|$ 的闭式表达式。\n\n**第 2 步：使用提取的已知条件进行验证**\n该问题具有科学依据，是适定的、客观的。这是常微分方程数值分析领域中一个标准的、基本的问题。它测试了在应用于纯振荡系统时，对基本数值方法稳定性的理解。问题陈述是自包含的，提供了所有必要的定义和变量。所使用的术语是精确和标准的。不存在矛盾、歧义或违反科学原理的情况。\n\n**第 3 步：结论与行动**\n问题有效。将提供完整解答。\n\n**离散更新关系的推导**\n给定常微分方程 $y'(t) = f(t,y)$，其中 $f(t,y) = i\\omega y(t)$。令 $y_n$ 为时间 $t_n = n h$ 时 $y(t_n)$ 的数值近似。\n\n1.  **前向欧拉法**：这是一种由 $y_{n+1} = y_n + h f(t_n, y_n)$ 定义的显式方法。\n    代入 $f(t_n, y_n) = i\\omega y_n$，我们得到：\n    $$y_{n+1} = y_n + h (i\\omega y_n) = (1 + i\\omega h) y_n$$\n\n2.  **后向欧拉法**：这是一种由 $y_{n+1} = y_n + h f(t_{n+1}, y_{n+1})$ 定义的隐式方法。\n    代入 $f(t_{n+1}, y_{n+1}) = i\\omega y_{n+1}$，我们得到：\n    $$y_{n+1} = y_n + h (i\\omega y_{n+1})$$\n    为了求出 $y_{n+1}$，我们必须解出它：\n    $$y_{n+1} - i\\omega h y_{n+1} = y_n$$\n    $$y_{n+1}(1 - i\\omega h) = y_n$$\n    $$y_{n+1} = \\frac{1}{1 - i\\omega h} y_n$$\n\n3.  **梯形法则 (Crank-Nicolson 方法)**：这是一种由 $y_{n+1} = y_n + \\frac{h}{2}(f(t_n, y_n) + f(t_{n+1}, y_{n+1}))$ 定义的隐式方法。\n    代入 $f$ 的具体形式，我们有：\n    $$y_{n+1} = y_n + \\frac{h}{2}(i\\omega y_n + i\\omega y_{n+1})$$\n    同样，我们解出 $y_{n+1}$：\n    $$y_{n+1} - \\frac{i\\omega h}{2} y_{n+1} = y_n + \\frac{i\\omega h}{2} y_n$$\n    $$y_{n+1}\\left(1 - \\frac{i\\omega h}{2}\\right) = y_n\\left(1 + \\frac{i\\omega h}{2}\\right)$$\n    $$y_{n+1} = \\frac{1 + \\frac{i\\omega h}{2}}{1 - \\frac{i\\omega h}{2}} y_n$$\n\n**放大因子及其模**\n对于线性测试方程 $y' = \\lambda y$，数值更新的形式为 $y_{n+1} = R(z)y_n$，其中 $z = \\lambda h$。函数 $R(z)$ 是放大因子或稳定性函数。对于我们的特定问题，$\\lambda = i\\omega$，因此 $z = i\\omega h$。\n\n1.  **前向欧拉法**：更新关系为 $y_{n+1} = (1 + i\\omega h) y_n$。将其与 $y_{n+1} = R(i\\omega h)y_n$ 比较，我们确定放大因子为：\n    $$R_{\\text{FE}}(i\\omega h) = 1 + i\\omega h$$\n    这个复数的绝对值（模）是：\n    $$|R_{\\text{FE}}(i\\omega h)| = |1 + i\\omega h| = \\sqrt{1^2 + (\\omega h)^2} = \\sqrt{1 + (\\omega h)^2}$$\n\n2.  **后向欧拉法**：更新关系为 $y_{n+1} = \\frac{1}{1 - i\\omega h} y_n$。放大因子为：\n    $$R_{\\text{BE}}(i\\omega h) = \\frac{1}{1 - i\\omega h}$$\n    其绝对值为：\n    $$|R_{\\text{BE}}(i\\omega h)| = \\left|\\frac{1}{1 - i\\omega h}\\right| = \\frac{|1|}{|1 - i\\omega h|} = \\frac{1}{\\sqrt{1^2 + (-\\omega h)^2}} = \\frac{1}{\\sqrt{1 + (\\omega h)^2}}$$\n\n3.  **梯形法则**：更新关系为 $y_{n+1} = \\frac{1 + i\\omega h/2}{1 - i\\omega h/2} y_n$。放大因子为：\n    $$R_{\\text{TR}}(i\\omega h) = \\frac{1 + \\frac{i\\omega h}{2}}{1 - \\frac{i\\omega h}{2}}$$\n    其绝对值为：\n    $$|R_{\\text{TR}}(i\\omega h)| = \\left|\\frac{1 + \\frac{i\\omega h}{2}}{1 - \\frac{i\\omega h}{2}}\\right| = \\frac{|1 + \\frac{i\\omega h}{2}|}{|1 - \\frac{i\\omega h}{2}|} = \\frac{\\sqrt{1^2 + (\\frac{\\omega h}{2})^2}}{\\sqrt{1^2 + (-\\frac{\\omega h}{2})^2}} = \\frac{\\sqrt{1 + \\frac{(\\omega h)^2}{4}}}{\\sqrt{1 + \\frac{(\\omega h)^2}{4}}} = 1$$\n    这是因为分子和分母是复共轭的，它们的模总是相等。\n\n**几何解释**\n对于 $y'(t) = i\\omega y(t)$ 且 $y(0) = y_0$，其精确解为 $y(t) = y_0 \\exp(i\\omega t)$。精确解的模为 $|y(t)| = |y_0||\\exp(i\\omega t)| = |y_0| = r_0$，对于所有时间 $t$ 都是常数。这意味着精确解在复平面上沿着一个半径为 $r_0$ 的圆运动。\n\n数值解遵循递推关系 $y_{n+1} = R(i\\omega h) y_n$。对两边取模得到 $|y_{n+1}| = |R(i\\omega h) y_n| = |R(i\\omega h)| |y_n|$。通过归纳法，经过 $n$ 步后，我们有 $|y_n| = |R(i\\omega h)|^n |y_0|$。数值解的模的行为取决于 $|R(i\\omega h)|$ 的值：\n\n-   如果 $|R(i\\omega h)|  1$：模 $|y_n|$ 每一步都会增长。数值解向外螺旋，偏离真实解的圆形路径。对于前向欧拉法，由于 $\\omega  0$ 和 $h  0$，我们有 $(\\omega h)^2  0$，这意味着 $|R_{\\text{FE}}(i\\omega h)| = \\sqrt{1 + (\\omega h)^2}  1$。因此，对于这个问题，前向欧拉法是无条件不稳定的，总是产生一个以指数级增加的振幅向外螺旋的解。\n\n-   如果 $|R(i\\omega h)|  1$：模 $|y_n|$ 每一步都会减小。数值解向内螺旋，衰减至原点。对于后向欧拉法，由于 $(\\omega h)^2  0$，我们有 $\\sqrt{1 + (\\omega h)^2}  1$，这意味着 $|R_{\\text{BE}}(i\\omega h)| = \\frac{1}{\\sqrt{1 + (\\omega h)^2}}  1$。因此，后向欧拉法引入了人为的数值耗散，导致解向内螺旋。\n\n-   如果 $|R(i\\omega h)| = 1$：模 $|y_n|$ 保持不变，对所有 $n$ 都有 $|y_n| = |y_0|$。数值解的点保持在半径为 $r_0$ 的初始圆上，就像精确解一样。对于梯形法则，我们发现对所有的 $\\omega$ 和 $h$，都有 $|R_{\\text{TR}}(i\\omega h)| = 1$。这意味着该方法是保守的；它精确地保持了解的模，这是所模拟的底层物理系统的一个关键属性（例如，能量或概率守恒）。\n\n**$|y_N|$ 的闭式表达式**\n使用关系式 $|y_N| = |R(i\\omega h)|^N |y_0|$ 和定义 $r_0 = |y_0|$，我们可以写出 $N$ 步后模的闭式表达式。\n\n1.  **前向欧拉法**：\n    $$|y_N|_{\\text{FE}} = \\left(\\sqrt{1 + (\\omega h)^2}\\right)^N r_0 = r_0 \\left(1 + (\\omega h)^2\\right)^{\\frac{N}{2}}$$\n\n2.  **后向欧拉法**：\n    $$|y_N|_{\\text{BE}} = \\left(\\frac{1}{\\sqrt{1 + (\\omega h)^2}}\\right)^N r_0 = r_0 \\left(1 + (\\omega h)^2\\right)^{-\\frac{N}{2}}$$\n\n3.  **梯形法则**：\n    $$|y_N|_{\\text{TR}} = (1)^N r_0 = r_0$$\n\n这些表达式量化了每种方法数值解的大小随时间的长期行为。",
            "answer": "$$\\boxed{\\begin{pmatrix} r_{0} \\left(1 + (\\omega h)^2\\right)^{\\frac{N}{2}}  r_{0} \\left(1 + (\\omega h)^2\\right)^{-\\frac{N}{2}}  r_{0} \\end{pmatrix}}$$"
        },
        {
            "introduction": "在掌握了单步法的基础上，我们转向更复杂的线性多步法。Dahlquist 等价定理告诉我们，一个数值方法要收敛，必须同时满足相容性和零稳定性。本次实践将通过一个反例，让你亲身體验违反零稳定性的后果：一个看似合理的相容方法，其计算结果却随着步长的减小而发散。通过分析和编程实现，你将揭示“寄生解”是如何破坏收敛性，并理解为何零稳定性是保证数值方法可靠性的基石。",
            "id": "3112000",
            "problem": "您需要通过分析和计算来证明，一个线性多步法可以满足相容性，但却不满足零点稳定性，并因此即使步长趋于零，在线性测试问题上也会发散。请严格依据核心定义和经过检验的事实进行操作。考虑线性测试常微分方程（ODE）$y'=\\lambda y$，其中 $\\lambda\\in\\mathbb{R}$ 为常数，以及以下两步法\n$$\ny_{n+1}-2y_n+y_{n-1}=h\\left(f_{n+1}-f_n\\right),\n$$\n其中 $f_k=f(t_k,y_k)$，$t_k=t_0+kh$，$h0$ 是时间步长。该格式对足够光滑的 $f$ 有定义，并使用两个过去的值 $y_{n}$ 和 $y_{n-1}$ 来计算 $y_{n+1}$。\n\n您必须：\n- 从第一性原理出发，推导该方法是否相容。请使用线性多步法相容性的定义，即对于光滑的精确解，当 $h\\to 0$ 时，局部截断误差趋于零。您的推导应基于精确解的泰勒展开和标准的线性多步法表示，不使用核心定义之外的快捷公式。\n- 从该方法的齐次部分（即当 $f\\equiv 0$ 时连接 $y_{n+1}$、$y_n$、$y_{n-1}$ 的多项式）所导出的特征多项式出发，分析零点稳定性的根条件，并确定该方法是否满足零点稳定性。\n- 解释为何不满足零点稳定性意味着在固定的最终时间 $T0$ 时，即使底层 ODE 的解有界（例如当 $\\lambda\\le 0$ 时），全局数值误差也可能随着 $h\\to 0$ 而无界增长。您的推理应将重根现象与寄生模式的增长以及对步数 $N=T/h$ 的依赖性联系起来。\n\n然后，在线性测试问题 $y'=\\lambda y$ 上实现该方法，使用精确的初始值 $y(0)=y_0$ 和一个被刻意扰动的第二个初始值。使用 $y_0=\\exp(0\\cdot\\lambda)=1$ 和 $y(h)=\\exp(\\lambda h)$ 作为精确的第一步。通过设置 $y_1^{\\text{start}}=\\exp(\\lambda h)+\\varepsilon$，向第二个初始值引入一个大小为 $\\varepsilon\\ge 0$ 的固定扰动。将递推关系演化至 $t=T$，并测量最终的绝对误差 $E(h)=|y_N-\\exp(\\lambda T)|$，其中 $N=T/h$ 是一个整数步数。对于每个测试用例，比较 $E(h_\\text{small})$ 和 $E(h_\\text{large})$ 以检测当 $h\\to 0$ 时是否发散。\n\n测试套件规范：\n- 所有用例均使用最终时间 $T=1$。\n- 使用两个步长 $h_\\text{large}=0.1$ 和 $h_\\text{small}=0.05$（这样 $N$ 对两者都是整数）。\n- 提供三个覆盖不同方面的测试用例：\n  1. 一般情况：$\\lambda=-1$，$\\varepsilon=10^{-8}$。\n  2. 具有常数解的边界情况：$\\lambda=0$，$\\varepsilon=10^{-8}$。\n  3. 具有完美初始值的边缘情况：$\\lambda=-1$，$\\varepsilon=0$。\n- 对于每个测试用例，计算布尔值 $B=\\big(E(h_\\text{small})E(h_\\text{large})\\big)$。对于表现出随着步长减小而发散的用例，该值应为 $\\text{True}$，否则为 $\\text{False}$。\n\n您的程序应产生单行输出，其中包含三个测试用例的布尔值，格式为方括号括起来的逗号分隔列表（例如，`[True,False,True]`）。本问题不涉及物理单位或角度单位。所有数学实体必须用 LaTeX 书写。程序必须是自包含的，不需要任何输入，并严格按照给定的测试用例实现指定的方法。",
            "solution": "该问题陈述是常微分方程（ODE）数值分析中一个有效的练习。它是自包含的，科学上根植于线性多步法的理论，并提出了一套明确定义的分析和计算任务。我们将着手解决。\n\n该问题要求分析应用于线性测试方程 $y' = \\lambda y$ 的两步法\n$$\ny_{n+1}-2y_n+y_{n-1}=h\\left(f_{n+1}-f_n\\right)\n$$\n对于该方程，$f(t,y) = \\lambda y$，因此 $f_k = \\lambda y_k$。\n\n### 第1部分：相容性分析\n\n一个线性多步法是相容的，如果它的局部截断误差（LTE）随着步长 $h \\to 0$ 而趋近于零。我们从第一性原理推导 LTE。设 $y(t)$ 是 ODE $y' = f(t, y(t))$ 的一个足够光滑的精确解。在第 $n+1$ 步的 LTE 是通过将精确解代入数值格式来定义的。为了与 $k$ 步法的标准定义对齐，我们将索引加1，将该方法表示为从前面的步骤计算第 $n+2$ 步：\n$$\ny_{n+2} - 2y_{n+1} + y_n = h(f_{n+2} - f_{n+1})\n$$\n该方法的线性差分算子 $\\mathcal{L}$ 为：\n$$\n\\mathcal{L}[y(t); h] = y(t+2h) - 2y(t+h) + y(t) - h\\left(y'(t+2h) - y'(t+h)\\right)\n$$\n局部截断误差为 $T_{n+2} = \\mathcal{L}[y(t_n); h]/h$。相容性要求对于任何足够光滑的解 $y(t)$，当 $h \\to 0$ 时，$T_{n+k} \\to 0$。\n\n我们对 $y(t+h)$、$y(t+2h)$、$y'(t+h)$ 和 $y'(t+2h)$ 在点 $t$ 附近进行泰勒级数展开：\n\\begin{align*}\ny(t+h) = y(t) + h y'(t) + \\frac{h^2}{2} y''(t) + \\frac{h^3}{6} y'''(t) + O(h^4) \\\\\ny(t+2h) = y(t) + 2h y'(t) + \\frac{(2h)^2}{2} y''(t) + \\frac{(2h)^3}{6} y'''(t) + O(h^4) \\\\\n= y(t) + 2h y'(t) + 2h^2 y''(t) + \\frac{4h^3}{3} y'''(t) + O(h^4) \\\\\ny'(t+h) = y'(t) + h y''(t) + \\frac{h^2}{2} y'''(t) + O(h^3) \\\\\ny'(t+2h) = y'(t) + 2h y''(t) + \\frac{(2h)^2}{2} y'''(t) + O(h^3) \\\\\n= y'(t) + 2h y''(t) + 2h^2 y'''(t) + O(h^3)\n\\end{align*}\n将这些展开式代入算子 $\\mathcal{L}[y(t); h]$：\n\n第一部分（涉及 $y$）：\n\\begin{align*}\n y(t+2h) - 2y(t+h) + y(t) \\\\\n= \\left(y(t) + 2h y' + 2h^2 y'' + \\frac{4h^3}{3} y'''\\right) - 2\\left(y(t) + h y' + \\frac{h^2}{2} y'' + \\frac{h^3}{6} y'''\\right) + y(t) + O(h^4) \\\\\n= (1-2+1)y(t) + (2-2)h y'(t) + (2-1)h^2 y''(t) + \\left(\\frac{4}{3} - \\frac{2}{6}\\right)h^3 y'''(t) + O(h^4) \\\\\n= h^2 y''(t) + h^3 y'''(t) + O(h^4)\n\\end{align*}\n\n第二部分（涉及 $y'$）：\n\\begin{align*}\n h\\left(y'(t+2h) - y'(t+h)\\right) \\\\\n= h\\left[ \\left(y'(t) + 2h y'' + 2h^2 y'''\\right) - \\left(y'(t) + h y'' + \\frac{h^2}{2} y'''\\right) + O(h^3) \\right] \\\\\n= h\\left[ h y''(t) + \\frac{3h^2}{2} y'''(t) + O(h^3) \\right] \\\\\n= h^2 y''(t) + \\frac{3h^3}{2} y'''(t) + O(h^4)\n\\end{align*}\n\n结合两部分：\n\\begin{align*}\n\\mathcal{L}[y(t); h] = \\left(h^2 y''(t) + h^3 y'''(t)\\right) - \\left(h^2 y''(t) + \\frac{3h^3}{2} y'''(t)\\right) + O(h^4) \\\\\n= -\\frac{1}{2}h^3 y'''(t) + O(h^4)\n\\end{align*}\n\n局部截断误差为 $T_{n+2} = \\mathcal{L}[y(t_n); h]/h = -\\frac{1}{2}h^2 y'''(t_n) + O(h^3)$。\n由于当 $h \\to 0$ 时 $T_{n+2} \\to 0$，该方法是**相容的**。精度阶为 $p=2$，因为 LTE 的主项是 $O(h^2)$。\n\n### 第2部分：零点稳定性分析\n\n零点稳定性涉及数值解在齐次问题 $y' = 0$ 下，或等价地，在极限 $h \\to 0$ 时的行为。对于给定的方法，设置 $f \\equiv 0$（或 $h=0$）得到齐次线性差分方程：\n$$\ny_{n+1} - 2y_n + y_{n-1} = 0\n$$\n为了分析其稳定性，我们考察其第一特征多项式 $\\rho(z)$ 的根。假设解的形式为 $y_n=z^n$，我们将其代入差分方程：\n$$\nz^{n-1}(z^2 - 2z + 1) = 0\n$$\n特征多项式为 $\\rho(z) = z^2 - 2z + 1 = (z-1)^2$。$\\rho(z)=0$ 的根是 $z_1=1$ 和 $z_2=1$，一个在 $z=1$ 处的二重根。\n\n零点稳定性的**根条件**规定：\n1.  $\\rho(z)$ 的所有根必须位于复平面的单位圆内或圆上（即 $|z_i| \\le 1$）。\n2.  任何位于单位圆上的根（即 $|z_i|=1$）必须是单根（即重数为1）。\n\n我们方法的根是 $z_1=z_2=1$。它们在单位圆上，满足第一个条件。然而，在 $z=1$ 处的根的重数为2，这违反了第二个条件。\n因此，该方法是**非零点稳定的**。\n\n### 第3部分：发散的解释\n\nDahlquist 等价定理指出，一个线性多步法是收敛的，当且仅当它既是相容的又是零点稳定的。由于我们的方法是相容的但非零点稳定，因此它是**不收敛的**。\n\n零点稳定性的失效意味着一旦引入误差，随着步数 $n$ 的增加，误差将被无界地放大。这可以通过考察齐次递推关系 $y_{n+1} - 2y_n + y_{n-1} = 0$ 的通解来看到。对于在 $z=1$ 处的二重根，通解不仅是 $c_1 (1)^n$，还包括一个线性增长的项：\n$$\ny_n = c_1 (1)^n + c_2 \\cdot n \\cdot (1)^n = c_1 + c_2 n\n$$\n$c_1$ 项对应于逼近真实解的主根。$c_2 n$ 项是一个寄生解，它不对应于 ODE 的行为。在固定的最终时间 $T$，步数是 $n = T/h$。因此，寄生分量的行为如同 $c_2 n = c_2 T/h$。随着步长 $h$ 减小（$h \\to 0$），步数 $n$ 增加，这个寄生解会无界增长。\n\n对于完整的问题 $y'=\\lambda y$，递推关系是 $y_{n+1}(1 - h\\lambda) = (2 - h\\lambda)y_n - y_{n-1}$。这是一个系数固定的（对于固定的 $h$）线性齐次差分方程。其特征方程是 $(1-h\\lambda)z^2 - (2-h\\lambda)z + 1 = 0$。它的根是 $z_1 = 1$ 和 $z_2 = (1-h\\lambda)^{-1}$。通解为 $y_n = c_1 z_2^n + c_2 z_1^n = c_1 \\left(\\frac{1}{1-h\\lambda}\\right)^n + c_2 (1)^n$。\n对于小的 $h$，根 $z_2 \\approx 1+h\\lambda$，并且 $z_2^n \\approx (e^{h\\lambda})^n = e^{\\lambda nh} = e^{\\lambda t_n}$，所以 $z_2$ 是追踪真实解的主根。根 $z_1=1$ 是寄生根。\n\n系数 $c_1$ 和 $c_2$ 由初始值 $y_0$ 和 $y_1$ 决定。初始值中的一个小的扰动 $\\varepsilon$，$y_1 = y_{\\text{exact}}(h) + \\varepsilon$，会激发寄生模式。分析表明 $c_2$ 与 $\\varepsilon/h$ 成正比。具体来说，对于 $\\lambda \\ne 0$，$c_2 \\approx -\\varepsilon/(\\lambda h)$；对于 $\\lambda=0$，$c_2=\\varepsilon$。在两种情况下，误差分量 $c_2$ 都随着 $h \\to 0$ 而增长。这意味着即使是无穷小的初始扰动也会被放大，导致全局误差以 $O(1/h)$ 的速度发散。\n\n对于具有完美初始值（$\\varepsilon=0$）的情况，系数 $c_2$ 与局部截断误差成正比，得到 $c_2 \\sim O(h)$。虽然这似乎暗示收敛，但计算中任何一步引入的浮点舍入误差都会像新的扰动一样，激发寄生模式。因此，发散是不可避免的，尽管如果初始数据非常精确，可能需要更多步才能变得明显。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Analyzes and implements an unstable linear multistep method to demonstrate\n    the consequences of failing the zero-stability condition.\n    \"\"\"\n\n    def compute_error(lambda_val, epsilon, h, T):\n        \"\"\"\n        Implements the given linear multistep method and computes the final error.\n\n        The method is: y_{n+1} - 2*y_n + y_{n-1} = h*(f_{n+1} - f_n)\n        For f(t,y) = lambda*y, this rearranges to:\n        y_{n+1} = ((2 - h*lambda)*y_n - y_{n-1}) / (1 - h*lambda)\n        \"\"\"\n        N = int(T / h)\n\n        # Starting values\n        # y_0 is the exact initial condition y(0)=1\n        y_prev = 1.0\n        # y_1 is the exact solution at t=h, plus a perturbation epsilon\n        y_curr = np.exp(lambda_val * h) + epsilon\n\n        # Handle the special case where lambda is 0\n        if lambda_val == 0:\n            # The recurrence simplifies to y_{n+1} = 2*y_n - y_{n-1}\n            for _ in range(N - 1): # Loop to compute y_2, y_3, ..., y_N\n                y_next = 2.0 * y_curr - y_prev\n                y_prev = y_curr\n                y_curr = y_next\n        else:\n            # Coefficients for the recurrence relation, pre-calculated for efficiency\n            c1 = (2.0 - h * lambda_val) / (1.0 - h * lambda_val)\n            c2 = -1.0 / (1.0 - h * lambda_val)\n            for _ in range(N - 1):\n                y_next = c1 * y_curr + c2 * y_prev\n                y_prev = y_curr\n                y_curr = y_next\n        \n        y_N = y_curr\n        \n        # Exact solution at time T\n        y_exact_T = np.exp(lambda_val * T)\n        \n        # Absolute error at final time T\n        error = np.abs(y_N - y_exact_T)\n        \n        return error\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (lambda, epsilon)\n        (-1.0, 1e-8),  # General case with stable ODE and perturbation\n        (0.0, 1e-8),   # Boundary case with constant solution and perturbation\n        (-1.0, 0.0),   # Edge case with stable ODE and no initial perturbation\n    ]\n    \n    T = 1.0\n    h_large = 0.1\n    h_small = 0.05\n    \n    results = []\n    for lambda_val, epsilon in test_cases:\n        # Compute error for the larger step size\n        error_large_h = compute_error(lambda_val, epsilon, h_large, T)\n        \n        # Compute error for the smaller step size\n        error_small_h = compute_error(lambda_val, epsilon, h_small, T)\n        \n        # Check for divergence: error increases as step size decreases\n        divergence_observed = error_small_h > error_large_h\n        results.append(divergence_observed)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "现实世界中的许多问题都是“刚性”的，即系统中包含多个时间尺度差异巨大的动态过程。本次实践将挑战你为一个刚性微分方程组实现一个自适应步长的显式欧拉法。你将发现一个在数值计算中至关重要却又十分微妙的现象：一个旨在控制局部误差（保证相容性）的自适应算法，并不总能保证全局稳定性。在特定情况下，它甚至会选择不稳定的步长，这揭示了在求解刚性问题时，稳定性和精度控制之间复杂的博弈关系。",
            "id": "3216936",
            "problem": "实现并分析用于线性刚性系统的自适应显式欧拉时间步进器，重点关注相容性、稳定性和收敛性之间的相互作用。该系统是线性自治常微分方程，其对角矩阵为 $$A = \\mathrm{diag}(-1,-1000)$$, 因此有 $$y'(t) = A\\,y(t), \\quad y(t) \\in \\mathbb{R}^2,$$，其精确解为 $$y(t) = \\big(y_1(0)\\,e^{-t},\\; y_2(0)\\,e^{-1000\\,t}\\big).$$ 你的程序必须基于基本定义完成以下任务。\n\n- 使用单步显式欧拉方法作为基本格式。相容性意味着当时间步长趋于零时，局部截断误差也趋于零。对于标量线性测试方程 $$z'(t) = \\lambda z(t),$$ 显式欧拉更新得出 $$z_{n+1} = z_n + h\\,\\lambda\\,z_n,$$ 其中 $$h0$$ 是时间步长。使用线性测试方程和基于单步法放大因子的绝对稳定性定义，推导绝对稳定域。你必须实现一个诊断功能，对于每个大小为 $$h$$ 的被接受的步，检查该步是否同时位于两个特征值 $$\\lambda_1 = -1$$ 和 $$\\lambda_2 = -1000$$ 的绝对稳定域内。\n\n- 使用步长加倍法作为局部误差估计器。对于时间 $$t_n$$ 的当前状态 $$y_n$$ 和试验步长 $$h$$，计算：\n  - 显式欧拉法的一个完整步：$$y^{(1)} = y_n + h\\,f(y_n), \\quad f(y) = A\\,y.$$\n  - 显式欧拉法的两个半步：$$y^{(2)} = y_n + \\tfrac{h}{2}\\,f(y_n), \\quad y^{(2)} = y^{(2)} + \\tfrac{h}{2}\\,f\\big(y^{(2)}\\big),$$ 为简洁起见，重复使用符号 $$y^{(2)}$$ 表示最终的加倍结果。\n  - 一个标量误差估计 $$\\mathrm{est} = \\lVert y^{(2)} - y^{(1)} \\rVert_{\\infty}.$$\n  如果 $$\\mathrm{est} \\le \\mathrm{tol},$$ 则接受该步，其中 $$\\mathrm{tol}  0$$ 是用户指定的容差。接受后，推进 $$y_{n+1} := y^{(2)}$$ 和 $$t_{n+1} := t_n + h.$$\n  使用基于一阶基本方法的步长加倍差异的二阶行为的标准控制器来更新下一步长：\n  $$h_{\\mathrm{new}} = \\min\\big(h_{\\max},\\; \\max\\big(h_{\\min},\\; s \\cdot h \\cdot \\max(0.1,\\; (\\mathrm{tol}/\\max(\\mathrm{est},\\epsilon))^{1/2})\\big)\\big).$$\n  其中安全因子为 $$s=0.9,$$，最小步长为 $$h_{\\min} = 10^{-16},$$，$$\\epsilon = 10^{-300}$$ 用于防止除以零。如果拒绝，保持 $$t_n, y_n$$ 不变，仅更新 $$h \\leftarrow h_{\\mathrm{new}}.$$ 通过在每次迭代中裁剪 $$h \\le T - t_n$$，确保最后一步正好到达最终时间。\n\n- 收敛性评估：计算最终时间的全局误差为 $$\\lVert y_{\\mathrm{num}}(T) - y_{\\mathrm{exact}}(T)\\rVert_{\\infty}.$$\n\n- 自适应下的稳定性评估：在积分过程中，维护一个布尔标志。当且仅当每个被接受的步都同时满足 $$\\lambda_1 = -1$$ 和 $$\\lambda_2 = -1000$$ 的显式欧拉绝对稳定性条件（根据从线性测试方程定义推导出的区域）时，该标志为 $$\\mathrm{True}$$。如果有任何被接受的步违反了此条件，则将该标志设置为 $$\\mathrm{False}$$ 并继续积分。\n\n- 终止与保障措施：当 $$t \\ge T$$ 时终止。使用 $$10^7$$ 次总试验步数的硬上限以避免无限循环；如果达到上限，则终止并报告截至该点的计算指标。\n\n测试套件和所需输入。对于每个测试用例，给定 $$(\\mathrm{tol},\\; y_1(0),\\; y_2(0),\\; T,\\; h_0,\\; h_{\\max}),$$ 其中 $$h_0$$ 是初始步长猜测值，$$h_{\\max}$$ 是允许的最大步长。如上所述，使用 $$h_{\\min} = 10^{-16}$$。测试套件包含以下四个用例：\n\n- 用例 A（在短时间范围内使用中等容差的顺利路径）：$$(\\mathrm{tol}, y_1(0), y_2(0), T, h_0, h_{\\max}) = (10^{-2},\\; 1,\\; 1,\\; 10^{-1},\\; 5\\times 10^{-2},\\; 5\\times 10^{-2}).$$\n- 用例 B（初始猜测值在稳定域之外；自适应性应能减小步长并维持稳定性）：$$(5\\times 10^{-2},\\; 1,\\; 1,\\; 10^{-2},\\; 10^{-2},\\; 10^{-2}).$$\n- 用例 C（刚性分量初始值极小；局部误差控制可能接受不稳定步长，展示自适应性如何破坏稳定性）：$$(10^{-1},\\; 1,\\; 10^{-12},\\; 5\\times 10^{-1},\\; 5\\times 10^{-2},\\; 5\\times 10^{-2}).$$\n- 用例 D（通过 $$h_{\\max}$$ 在绝对稳定边界设置硬上限）：$$(10^{-3},\\; 1,\\; 1,\\; 1,\\; 2\\times 10^{-3},\\; 2\\times 10^{-3}).$$\n\n对于每个用例，你的程序必须计算：\n- 最终时间的全局误差 $$E = \\lVert y_{\\mathrm{num}}(T) - y_{\\mathrm{exact}}(T)\\rVert_{\\infty}.$$\n- 布尔值 $$S$$，指示每个被接受的步是否都位于两个特征值的绝对稳定域内。\n\n最终输出格式。你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，顺序为\n$$[E_A,\\;S_A,\\;E_B,\\;S_B,\\;E_C,\\;S_C,\\;E_D,\\;S_D],$$\n其中每个 $$E_\\bullet$$ 是一个浮点数，每个 $$S_\\bullet$$ 是一个布尔值。此问题不涉及单位，也没有角度。在输出中以普通十进制浮点数表示数字。",
            "solution": "该问题要求实现并分析一种用于刚性线性常微分方程（ODE）系统的自适应显式欧拉方法。解决方案将分两部分介绍：首先是稳定性条件的理论推导，其次是所指定的自适应算法的纲要。\n\nODE 系统由 $y'(t) = A y(t)$ 给出，其中 $y(t) \\in \\mathbb{R}^2$ 且 $A = \\mathrm{diag}(-1, -1000)$。因此，矩阵 $A$ 的特征值为 $\\lambda_1 = -1$ 和 $\\lambda_2 = -1000$。这些特征值在数量级上的巨大差异表明该系统是刚性的。\n\n为了分析显式欧拉方法的数值稳定性，我们考虑标量线性测试方程 $z'(t) = \\lambda z(t)$，其中 $\\lambda \\in \\mathbb{C}$ 是一个常数。应用显式欧拉方法 $z_{n+1} = z_n + h f(t_n, z_n)$，其中时间步长 $h0$ 且 $f(t,z) = \\lambda z$，可得到递推关系：\n$$z_{n+1} = z_n + h \\lambda z_n = (1 + h\\lambda) z_n$$\n项 $g(w) = 1+w$（其中 $w = h\\lambda$）是放大因子。对于单步法，要使其绝对稳定，放大因子的模不得超过 1，以确保数值误差不会在连续的步骤中被放大。绝对稳定域是满足 $|g(w)| \\le 1$ 的 $w \\in \\mathbb{C}$ 的集合。\n$$ |1 + h\\lambda| \\le 1 $$\n对于给定的问题，特征值 $\\lambda_1 = -1$ 和 $\\lambda_2 = -1000$ 是实数和负数。因此，$w = h\\lambda$ 也是实数和负数。稳定性条件简化为：\n$$ -1 \\le 1 + h\\lambda \\le 1 $$\n这等价于两个不等式：\n1. $1 + h\\lambda \\le 1 \\implies h\\lambda \\le 0$。由于 $h0$ 且 $\\lambda0$，此条件始终满足。\n2. $-1 \\le 1 + h\\lambda \\implies -2 \\le h\\lambda$。\n\n因此，对于一个实的负 $\\lambda$，显式欧拉方法是绝对稳定的，当且仅当 $h\\lambda \\in [-2, 0]$。这对步长 $h$ 施加了一个上限：\n$$ h \\le -\\frac{2}{\\lambda} $$\n对于给定的系统，此条件必须同时对两个特征值成立：\n- 对于 $\\lambda_1 = -1$：$h \\le -\\frac{2}{-1} = 2$。\n- 对于 $\\lambda_2 = -1000$：$h \\le -\\frac{2}{-1000} = 0.002$。\n\n为了确保整个系统的稳定性，步长 $h$ 必须满足最严格的条件，即 $h \\le 0.002$。数值实现将跟踪每个被接受的步是否遵守此界限。\n\n自适应算法构造如下：\n1.  **基本方法**：单步显式欧拉方法，$y_{n+1} = y_n + h f(y_n)$，其中 $f(y) = Ay$。该方法具有一阶精度，意味着其局部截断误差（LTE）为 $\\mathcal{O}(h^2)$。\n\n2.  **局部误差估计**：使用步长加倍法。从时间 $t_n$ 的当前状态 $y_n$ 出发，计算两个在 $t_n+h$ 处的解的独立近似值：\n    - 一个大小为 $h$ 的单步：$y^{(1)} = y_n + h A y_n$。\n    - 两个大小为 $h/2$ 的连续步：计算一个临时状态 $y_{n+1/2} = y_n + \\frac{h}{2} A y_n$，然后是 $y^{(2)} = y_{n+1/2} + \\frac{h}{2} A y_{n+1/2}$。\n    $y^{(2)}$ 的 LTE 小于 $y^{(1)}$ 的 LTE。这两个近似值之间的差异提供了局部误差的估计。一个标量误差度量定义为 $\\mathrm{est} = \\lVert y^{(2)} - y^{(1)} \\rVert_{\\infty}$。\n\n3.  **步长控制**：如果误差估计在指定的容差范围内，即 $\\mathrm{est} \\le \\mathrm{tol}$，则接受该步。如果接受，则将状态推进到 $y_{n+1} = y^{(2)}$（使用更精确的近似值），并将时间推进到 $t_{n+1} = t_n + h$。如果拒绝，状态和时间保持为 $y_n$ 和 $t_n$。无论哪种情况，都使用标准的比例-积分（PI）型控制器逻辑为下一次迭代提出新的步长 $h_{\\mathrm{new}}$。一阶方法的 LTE 与 $h^2$ 成正比。为达到目标误差 $\\mathrm{tol}$，根据当前估计的误差调整新步长：$h_{\\mathrm{new}} \\approx h (\\mathrm{tol}/\\mathrm{est})^{1/2}$。该算法采用特定公式：\n    $$h_{\\mathrm{new}} = \\min\\big(h_{\\max},\\; \\max\\big(h_{\\min},\\; s \\cdot h \\cdot \\max(0.1,\\; (\\mathrm{tol}/\\max(\\mathrm{est},\\epsilon))^{1/2})\\big)\\big)$$\n    这里，$s=0.9$ 是一个安全因子，$\\epsilon$ 避免了除以零，而界限 $h_{\\min}$、$h_{\\max}$ 以及因子 $0.1$ 可防止步长发生过大或过小的变化。\n\n4.  **收敛性与稳定性评估**：\n    - **收敛性**：在最终时间 $T$ 计算全局误差为 $E = \\lVert y_{\\mathrm{num}}(T) - y_{\\mathrm{exact}}(T)\\rVert_{\\infty}$，其中 $y_{\\mathrm{exact}}(T) = (y_1(0)e^{-T}, y_2(0)e^{-1000T})$。\n    - **稳定性**：维护一个初始化为 $\\mathrm{True}$ 的布尔标志。如果有任何被接受的步长 $h  0.002$，则将该标志设置为 $\\mathrm{False}$，表示至少有一个步违反了由系统最刚性分量决定的绝对稳定性条件。\n\n这种设计能够对相容性（局部误差控制）、稳定性（数值解的有界性）和收敛性（最终全局解的准确性）之间的关系进行实践性检验，尤其是在刚性方程的背景下，此时局部误差控制不保证稳定性。用例 C 旨在说明这种特定的失效模式，即误差控制器可能接受一个不稳定的步，因为相应的不稳定解分量初始值太小，无法产生显著的局部误差估计。相比之下，用例 D 通过选择 $h_{\\max}$ 来强制实现稳定性，表明尽管维持了稳定性，但即使步长在稳定范围内，也可能因精度要求而受到严格限制。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_adaptive_euler(tol, y1_0, y2_0, T, h0, h_max):\n    \"\"\"\n    Implements an adaptive explicit Euler time-stepper for a linear stiff system.\n\n    Args:\n        tol (float): User-specified error tolerance.\n        y1_0 (float): Initial condition for the first component.\n        y2_0 (float): Initial condition for the second component.\n        T (float): Final integration time.\n        h0 (float): Initial step size guess.\n        h_max (float): Maximum allowed step size.\n\n    Returns:\n        tuple: A tuple containing:\n            - global_error (float): The final-time global error.\n            - all_steps_stable (bool): True if every accepted step was stable.\n    \"\"\"\n    # --- Problem Definition and Constants ---\n    A = np.diag([-1.0, -1000.0])\n    y0 = np.array([y1_0, y2_0], dtype=float)\n    \n    # --- Algorithm Parameters ---\n    h_min = 1e-16\n    s = 0.9  # Safety factor\n    epsilon = 1e-300\n    max_steps = 10_000_000\n    \n    # --- Initialization ---\n    t = 0.0\n    y = y0.copy()\n    h = h0\n    total_steps = 0\n    all_steps_stable = True\n    stability_limit = 2.0 / 1000.0  # h = 0.002 for stability\n\n    # --- Main Adaptive Loop ---\n    while t  T and total_steps  max_steps:\n        total_steps += 1\n        \n        # Use a temporary variable for the current step size\n        h_current = h\n        \n        # Clip step to not overshoot final time T\n        if t + h_current > T:\n            h_current = T - t\n            \n        # --- Step Doubling for Error Estimation ---\n        # Right-hand side evaluation\n        f_n = A @ y\n        \n        # One full step of size h_current\n        y_1_step = y + h_current * f_n\n        \n        # Two half-steps of size h_current/2\n        y_half_step_1 = y + (h_current / 2.0) * f_n\n        f_half = A @ y_half_step_1\n        y_2_step = y_half_step_1 + (h_current / 2.0) * f_half\n        \n        # --- Error Estimate and Step Control ---\n        error_est = np.linalg.norm(y_2_step - y_1_step, ord=np.inf)\n        \n        step_accepted = (error_est = tol or h_current == h_min)\n\n        if step_accepted:\n            t += h_current\n            y = y_2_step  # Advance with the more accurate result\n            \n            # Check if the accepted step violates the stability condition\n            if h_current > stability_limit:\n                all_steps_stable = False\n        # On rejection, t and y are not changed.\n        \n        # --- Update Step Size for Next Iteration ---\n        # The new step size is calculated based on the attempted step (h_current)\n        # and the resulting error estimate, as per the specified formula.\n        scale_factor = (tol / max(error_est, epsilon))**0.5\n        h_new = s * h_current * max(0.1, scale_factor)\n        \n        # Enforce step size bounds\n        h = min(h_max, max(h_min, h_new))\n        \n        # Break if the final time is reached\n        if t >= T:\n            break\n            \n    # --- Final Convergence and Stability Assessment ---\n    y_num_T = y\n    y_exact_T = np.array([y0[0] * np.exp(-T), y0[1] * np.exp(-1000.0 * T)])\n    \n    global_error = np.linalg.norm(y_num_T - y_exact_T, ord=np.inf)\n    \n    return global_error, all_steps_stable\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = {\n        'A': (1e-2, 1.0, 1.0, 1e-1, 5e-2, 5e-2),\n        'B': (5e-2, 1.0, 1.0, 1e-2, 1e-2, 1e-2),\n        'C': (1e-1, 1.0, 1e-12, 5e-1, 5e-2, 5e-2),\n        'D': (1e-3, 1.0, 1.0, 1.0, 2e-3, 2e-3),\n    }\n\n    results = []\n    # Process cases in specified order\n    for case_id in ['A', 'B', 'C', 'D']:\n        params = test_cases[case_id]\n        tol, y1_0, y2_0, T, h0, h_max = params\n        \n        error, stable = run_adaptive_euler(tol, y1_0, y2_0, T, h0, h_max)\n        \n        results.append(error)\n        results.append(stable)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}