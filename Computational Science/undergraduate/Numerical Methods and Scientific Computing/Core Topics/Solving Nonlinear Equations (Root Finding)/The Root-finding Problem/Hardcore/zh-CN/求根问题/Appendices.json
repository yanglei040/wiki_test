{
    "hands_on_practices": [
        {
            "introduction": "掌握任何迭代算法的第一步都是通过动手计算来获得直观感受。本练习  将引导您手动执行试位法（Method of False Position）的迭代步骤。此方法通过线性插值来近似根的位置，而不是像二分法那样简单地将区间一分为二，因此通常能更快地收敛。通过这个实践，您将深入理解该算法的几何直觉和计算流程。",
            "id": "2219756",
            "problem": "考虑非线性方程 $f(x) = \\exp(x/2) - 3 = 0$。我们希望使用试位法（也称为 Regula Falsi）来求此方程的根。对于一个包含根的区间 $[a_k, b_k]$，试位法的迭代公式如下：\n$$c_{k+1} = \\frac{a_k f(b_k) - b_k f(a_k)}{f(b_k) - f(a_k)}$$\n然后从两个子区间 $[a_k, c_{k+1}]$ 和 $[c_{k+1}, b_k]$ 中选择新的区间 $[a_{k+1}, b_{k+1}]$，以确保根在下一次迭代中仍被包围。\n\n从初始区间 $[a_0, b_0] = [0, 5]$ 开始，执行该方法的两次迭代以求得近似值 $c_2$。报告 $c_2$ 的值，四舍五入到五位有效数字。",
            "solution": "我们使用试位法在区间 $[a_{0}, b_{0}] = [0, 5]$ 上求解 $f(x) = \\exp(x/2) - 3$ 的根。迭代公式为\n$$\nc_{k+1} = \\frac{a_{k} f(b_{k}) - b_{k} f(a_{k})}{f(b_{k}) - f(a_{k})}.\n$$\n步骤 1 (初始函数值和第一次迭代):\n计算 $f(0) = \\exp(0) - 3 = 1 - 3 = -2$ 和 $f(5) = \\exp(5/2) - 3$。由于 $f(0)  0$ 且 $f(5) > 0$，根位于区间内。\n第一次试位迭代为\n$$\nc_{1} = \\frac{0 \\cdot f(5) - 5 \\cdot f(0)}{f(5) - f(0)} = \\frac{10}{\\exp(5/2) - 3 + 2} = \\frac{10}{\\exp(5/2) - 1}.\n$$\n数值上，$\\exp(5/2) \\approx 12.182493960703473$，所以 $f(5) \\approx 9.182493960703473$，并且\n$$\nc_{1} \\approx \\frac{10}{9.182493960703473 + 2} = \\frac{10}{11.182493960703473} \\approx 0.894254898.\n$$\n计算 $f(c_{1}) = \\exp(c_{1}/2) - 3$。当 $c_{1}/2 \\approx 0.447127449$ 时，\n$$\n\\exp(0.447127449) \\approx 1.56381359 \\quad \\Rightarrow \\quad f(c_{1}) \\approx -1.43618641.\n$$\n由于 $f(c_{1})  0$ 且 $f(5) > 0$，新的含根区间是 $[a_{1}, b_{1}] = [c_{1}, 5]$。\n\n步骤 2 (第二次迭代):\n使用 $a_{1} = c_{1}$ 和 $b_{1} = 5$ 应用试位法公式：\n$$\nc_{2} = \\frac{a_{1} f(b_{1}) - b_{1} f(a_{1})}{f(b_{1}) - f(a_{1})}.\n$$\n使用 $f(b_{1}) \\approx 9.182493960703473$ 和 $f(a_{1}) \\approx -1.43618641$ 计算\n$$\n\\text{分子} \\approx a_{1} f(b_{1}) - 5 f(a_{1}) \\approx (0.894254898)(9.182493960703473) + 7.18093205 \\approx 15.39242244,\n$$\n$$\n\\text{分母} \\approx f(b_{1}) - f(a_{1}) \\approx 9.182493960703473 - (-1.43618641) \\approx 10.61868037.\n$$\n因此，\n$$\nc_{2} \\approx \\frac{15.39242244}{10.61868037} \\approx 1.4495606.\n$$\n四舍五入到五位有效数字，得到 $c_{2} \\approx 1.4496$。",
            "answer": "$$\\boxed{1.4496}$$"
        },
        {
            "introduction": "许多迭代方法并非“一劳永逸”，其收敛性通常依赖于关键参数的设定。本练习  探討了一类广泛的不动点迭代法，并要求您分析其收敛条件。通过确定参数 $\\alpha$ 的取值范围以保证算法收敛，您将深入理解迭代格式的设计如何直接影响其稳定性和有效性，这是数值分析中的一个核心概念。",
            "id": "2219690",
            "problem": "一位工程师正在使用一种数值方法来求解方程 $e^{x} = 3$。他们选择了一种由以下递推关系定义的不动点迭代格式：\n$$\nx_{k+1} = x_{k} - \\alpha (e^{x_{k}} - 3)\n$$\n其中 $k$ 是迭代指数 ($k=0, 1, 2, \\dots$)，$\\alpha$ 是一个用于控制该方法收敛性的实值常数参数。为使迭代收敛到方程的真实根，参数 $\\alpha$ 必须位于一个特定的范围内。\n\n假设初始猜测值 $x_0$ 足够接近根，下列哪个选项代表了能保证收敛的 $\\alpha$ 的取值开区间？\n\nA. $(0, 1/3)$\n\nB. $(0, 2/3)$\n\nC. $(-1/3, 1/3)$\n\nD. $(0, 1)$\n\nE. $(-2/3, 2/3)$",
            "solution": "我们寻求迭代 $x_{k+1}=g(x_{k})$ 的不动点，其中\n$$\ng(x)=x-\\alpha\\left(\\exp(x)-3\\right).\n$$\n不动点 $x^{\\ast}$ 满足 $\\exp(x^{\\ast})=3$，因此 $x^{\\ast}=\\ln(3)$。\n\n假设 $x_{0}$ 足够接近 $x^{\\ast}$ 且 $g$ 在 $x^{\\ast}$ 附近连续可微，不动点迭代局部收敛的一个充分条件是收缩条件\n$$\n|g'(x^{\\ast})|1.\n$$\n计算导数：\n$$\ng'(x)=1-\\alpha\\exp(x),\n$$\n所以在不动点处，\n$$\ng'(x^{\\ast})=1-\\alpha\\exp(x^{\\ast})=1-3\\alpha.\n$$\n收敛条件变为\n$$\n|1-3\\alpha|1.\n$$\n这等价于双重不等式\n$$\n-11-3\\alpha1.\n$$\n从左边的等式：$-11-3\\alpha\\implies -2-3\\alpha\\implies 2>3\\alpha\\implies \\alpha  \\frac{2}{3}$。\n从右边的等式：$1-3\\alpha1\\implies -3\\alpha0\\implies 3\\alpha>0\\implies \\alpha>0$。\n结合起来得到\n$$\n0  \\alpha  \\frac{2}{3},\n$$\n这对应于选项 B。",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "在实际应用中，我们往往需要找到一个区间内所有的根，而不仅仅是一个根，并确保没有遗漏，这是一个更具挑战性的任务。本练习  将引导您设计一个能够实现这一目标的强大程序。您需要运用中值定理等基本微积分原理，构建一个“认证”机制，来严格证明某些子区间内不存在根，从而实现对整个区间的彻底搜索。这个综合性问题完美地桥接了理论分析与实际编程，是数值计算领域中鲁棒算法设计的绝佳实践。",
            "id": "3283618",
            "problem": "考虑连续函数 $f(x) = \\cos(10x) - x$ 的求根问题，其中余弦函数的角度以弧度为单位。任务是设计并实现一个程序，对于给定的闭区间 $[a,b]$，找出所有满足 $f(x) = 0$ 的实数 $x \\in [a,b]$，并提供一个严格的证明，确保没有遗漏任何根。您的设计必须从适用于数值方法的基本原理出发：连续性、介值定理和均值定理。使用有界导数论证来建立一个先验的利普希茨界 (Lipschitz bound)，并构建一个自适应网格划分过程，根据需要细分区间 $[a,b]$，以便检测根并证明不存在其他根。该证明必须从这些原理逻辑推导得出，并应确保每个子区间要么被证明无根，要么被不断细化，直到其中的任何根都被框定和求解。\n\n在此问题中，您必须：\n- 识别一个一致界 $L$，使得在所考虑的任何区间内，对于所有 $x$ 都满足 $\\lvert f'(x) \\rvert \\le L$。\n- 实现 $[a,b]$ 的自适应细分。当子区间端点的函数值符号相反时，使用区间法来隔离并逼近一个根。当它们符号相同时，使用有界导数论证来证明整个子区间不含根；否则，进一步细分。\n- 确保算法能够检测到可能存在的多个根，并且发现的根被唯一地报告。\n\n您的程序应将该方法应用于以下区间测试套件，并汇总结果：\n- 测试 $1$：$[0,1]$。\n- 测试 $2$：$[-1,0]$。\n- 测试 $3$：$[1.2,2.0]$。\n- 测试 $4$：$[-1,1]$。\n- 测试 $5$：$[0.14,0.18]$。\n\n对于每个测试，返回给定区间内所有根的列表，表示为四舍五入到十位小数的浮点数。最终输出必须是单行文本，包含所有测试的结果，格式为用方括号括起来的、逗号分隔的列表的列表。例如，格式应为 $[[r_{1,1},r_{1,2},\\dots],[r_{2,1},\\dots],\\dots]$，其中 $r_{i,j}$ 表示在第 $i$ 个测试中找到的第 $j$ 个根。如果一个区间不包含根，则为该区间返回一个空列表。角度必须以弧度为单位，不涉及任何物理单位。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，`[[r_{1,1},r_{1,2}],[\\dots],\\dots]`）。",
            "solution": "该问题要求我们找到函数 $f(x) = \\cos(10x) - x$ 在给定闭区间 $[a, b]$ 内的所有实根。任务的一个关键组成部分是基于微积分的基本原理，提供一个严格的证明，确保没有遗漏任何根。指定的方法论涉及将区间的自适应细分与基于导数的论证相结合。\n\n### 理论框架\n\n所讨论的函数是 $f(x) = \\cos(10x) - x$。该函数对于所有 $x \\in \\mathbb{R}$ 都是连续且无穷可微的。证明方法的核心依赖于界定其变化率。\n\n1.  **函数及其导数**：\n    函数为 $f(x) = \\cos(10x) - x$。\n    它对 $x$ 的导数是 $f'(x) = \\frac{d}{dx}(\\cos(10x) - x) = -10\\sin(10x) - 1$。\n\n2.  **利普希茨常数 (Lipschitz Constant) (有界导数)**：\n    为证明一个区域无根，我们需要函数导数大小的一个一致上界。这个界，即利普希茨常数 $L$，对于我们关注的定义域中的所有 $x$ 都满足条件 $|f'(x)| \\le L$。\n    正弦函数有界，满足 $-1 \\le \\sin(10x) \\le 1$。\n    因此，导数 $f'(x)$ 的界如下：\n    $$ -10(1) - 1 \\le -10\\sin(10x) - 1 \\le -10(-1) - 1 $$\n    $$ -11 \\le f'(x) \\le 9 $$\n    因此，$f'(x)$ 的最大绝对值为 $\\max(|-11|, |9|) = 11$。我们可以选择一个全局利普希茨常数 $L=11$。这意味着对于任意两点 $x_1$ 和 $x_2$，根据均值定理 (MVT) 可保证：\n    $$ |f(x_1) - f(x_2)| \\le L |x_1 - x_2| = 11 |x_1 - x_2| $$\n\n### 算法设计：带证明的自适应细分\n\n简单地搜索符号变化的朴素方法是不够的，因为一个区间的端点之间可能没有符号变化，但该区间内可能包含偶数个根。指定的方法通过系统地细分区间来克服此问题，直到每个子区间要么能被证明无根，要么小到足以隔离其中包含的任何根。\n\n该算法使用一个栈来处理待处理的区间，初始时栈中只有初始区间 $[a, b]$。\n\n1.  **证明原理**：\n    考虑一个子区间 $[c, d]$。我们计算它在端点处的函数值 $f(c)$ 和 $f(d)$。\n    如果 $f(c)$ 和 $f(d)$ 符号相同（例如，均为正），只有当函数值下降到零再返回时，才可能存在根。我们可以使用利普希茨常数 $L$ 为 $[c,d]$ 上的 $f(x)$ 构建一个下界。函数的图像必须位于两条线的上方，这两条线分别从 $(c, f(c))$ 和 $(d, f(d))$ 开始，斜率为 $\\pm L$。具体来说，对于 $x \\in [c, d]$，$f(x)$ 必须位于由 $y_1(x) = f(c) - L(x-c)$ 和 $y_2(x) = f(d) - L(d-x)$ 形成的包络线上方。\n    该包络线的最小值出现在这两条线的交点处，可以计算为 $y_{min} = \\frac{f(c)+f(d)}{2} - \\frac{L(d-c)}{2}$。\n    如果这个最小值为正，那么我们可以确定对于所有 $x \\in [c, d]$，都有 $f(x) > 0$。\n    如果 $f(c)$ 和 $f(d)$ 均为负，则可应用对称的论证。这导出了以下的一般证明条件：\n    如果 $f(c)$ 和 $f(d)$ 符号相同且满足 $|f(c) + f(d)| > L(d-c)$，则可以保证区间 $[c, d]$ 无根。\n\n2.  **递归细分算法**：\n    - 用起始区间 $[a, b]$ 初始化一个栈。\n    - 从栈中弹出一个区间 $[c, d]$。\n    - 如果区间小于预定义的 `SUBDIVISION_STOP_WIDTH`（例如，$10^{-9}$），则认为它是“原子的”。我们通过检查 $f(c)f(d) \\le 0$ 来测试是否存在根。如果条件成立，介值定理 (IVT) 保证存在一个根，然后使用像二分法这样的区间数值方法找到它。否则，这个微小区间被丢弃。\n    - 对于较大的区间：\n        - **情况 1：符号相同 ($f(c)f(d) > 0$)**：检验证明条件 $|f(c) + f(d)| > L(d-c)$。如果为真，则证明该区间无根并将其丢弃。如果为假，我们无法确定，因此将区间在其中心点 $m=(c+d)/2$ 处细分，并将产生的两个子区间 $[c, m]$ 和 $[m, d]$ 推入栈中以供进一步探查。\n        - **情况 2：符号改变 ($f(c)f(d) \\le 0$)**：介值定理保证至少存在一个根。但是，可能存在奇数个根（$3, 5, \\dots$）。由于我们无法证明不存在其他根，唯一严谨的做法是细分该区间。将 $[c, m]$ 和 $[m, d]$ 都推入栈中。\n\n3.  **根的隔离与唯一性**：\n    - 当细分过程产生一个包含符号变化的非常小的区间时，我们采用二分法以高精度（例如，容差为 $10^{-15}$）逼近根。\n    - 整个过程会填充一个已找到根的列表。由于单个根可能在两个相邻小区间的边界处被检测到，因此需要一个最终的筛选步骤。对根列表进行排序，并通过遍历排序后的列表来移除重复项，只保留与前一个根的差大于一个很小容差（例如，$10^{-12}$）的根。\n    - 最后，将唯一的根四舍五入到所要求的 $10$ 位小数。\n\n这个完整、系统化的过程确保了整个初始区间 $[a, b]$ 被穷尽搜索，并且不存在性证明测试与递归细分的结合保证了所有根都被找到。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Global constants defining the problem and algorithm parameters.\nL = 11.0  # Lipschitz constant for f(x)\nTOLERANCE_BISECT = 1e-15  # Tolerance for the bisection root-finding method.\nTOLERANCE_UNIQUENESS = 1e-12  # Tolerance for distinguishing unique roots.\n# Subdivision stops when an interval's width is below this threshold.\n# On such small intervals, we check for a root using IVT directly.\nSUBDIVISION_STOP_WIDTH = 1e-9\n\ndef f(x):\n    \"\"\"The function for which we are finding roots.\"\"\"\n    return np.cos(10 * x) - x\n\ndef bisection(c, d):\n    \"\"\"\n    Finds a root in the interval [c, d] using the bisection method.\n    It is assumed that f(c) * f(d) = 0.\n    \"\"\"\n    low, high = c, d\n    f_low = f(low)\n    \n    # Safety check for roots at endpoints.\n    if abs(f_low)  TOLERANCE_BISECT:\n        return low\n    if abs(f(high))  TOLERANCE_BISECT:\n        return high\n\n    # Bisection guarantees convergence. 100 iterations is more than\n    # sufficient for standard double precision floating-point numbers.\n    for _ in range(100):\n        if high - low  TOLERANCE_BISECT:\n            break\n        \n        mid = low + (high - low) / 2  # Numerically stable midpoint calculation\n        f_mid = f(mid)\n\n        if abs(f_mid)  TOLERANCE_BISECT:\n            return mid\n\n        # If signs are different, root is in the lower half.\n        if np.sign(f_low) != np.sign(f_mid):\n            high = mid\n        else: # Otherwise, root is in the upper half.\n            low = mid\n            f_low = f_mid\n            \n    return low + (high - low) / 2\n\ndef find_all_roots_certified(a, b):\n    \"\"\"\n    Finds all roots of f(x) in the interval [a, b] using an adaptive\n    subdivision algorithm with a rigorous certification of absence.\n    \"\"\"\n    stack = [(a, b)]\n    roots = []\n\n    while stack:\n        c, d = stack.pop()\n\n        if d = c:\n            continue\n\n        f_c = f(c)\n        f_d = f(d)\n\n        # Base case for recursion: interval is small enough.\n        if (d - c)  SUBDIVISION_STOP_WIDTH:\n            # For this small interval, check for a root using the Intermediate Value Theorem.\n            if f_c * f_d = 0:\n                root = bisection(c, d)\n                roots.append(root)\n            # If no sign change, the small interval is discarded.\n            continue\n\n        # Subdivision Step:\n        # Case 1: No sign change. Attempt to certify that no roots exist.\n        if f_c * f_d > 0:\n            # Certification condition: |f(c) + f(d)| > L * (d-c)\n            if abs(f_c + f_d) > L * (d - c):\n                # Interval is certified to be root-free. Discard it.\n                continue\n            else:\n                # Certification failed. Subdivide and check both halves.\n                m = c + (d-c)/2\n                stack.append((c, m))\n                stack.append((m, d))\n        # Case 2: Sign change detected.\n        else:  # f_c * f_d = 0\n            # A root is guaranteed, but more may exist. Subdivide to find all.\n            m = c + (d-c)/2\n            stack.append((c, m))\n            stack.append((m, d))\n\n    # Post-processing: remove duplicates and round.\n    if not roots:\n        return []\n\n    roots.sort()\n    \n    # Filter for unique roots based on a proximity tolerance.\n    unique_roots = [roots[0]]\n    for i in range(1, len(roots)):\n        if abs(roots[i] - unique_roots[-1]) > TOLERANCE_UNIQUENESS:\n            unique_roots.append(roots[i])\n\n    # Round the final unique roots to the specified number of decimal places.\n    return [round(r, 10) for r in unique_roots]\n\ndef solve():\n    \"\"\"\n    Main function to run the root-finding algorithm on the given test cases\n    and print the results in the specified format.\n    \"\"\"\n    test_cases = [\n        (0.0, 1.0),\n        (-1.0, 0.0),\n        (1.2, 2.0),\n        (-1.0, 1.0),\n        (0.14, 0.18),\n    ]\n\n    results = []\n    for a, b in test_cases:\n        # The result for each case is the list of roots found in the interval.\n        roots_list = find_all_roots_certified(a, b)\n        results.append(roots_list)\n\n    # Format the final output string to match the problem specification\n    # e.g., \"[[root1,root2],[],[root3]]\" with no spaces.\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```"
        }
    ]
}