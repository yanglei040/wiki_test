{
    "hands_on_practices": [
        {
            "introduction": "在许多科学和工程应用中，对称性是一种常见的结构特性。本练习将指导您利用对称三对角矩阵的特性，推导并实现一种比通用托马斯算法更高效的求解器。通过实践基于 $LDL^T$ 分解的算法，您将深刻理解如何利用矩阵结构来优化存储需求和计算成本 。",
            "id": "3208596",
            "problem": "考虑一个线性系统 $A x = f$，其中 $A$ 是一个 $n \\times n$ 维的对称三对角矩阵。根据定义，$A$ 的非零元素仅存在于其主对角线、第一条次对角线和第一条超对角线上，而对称性意味着次对角线等于超对角线。设主对角线由 $a_1,a_2,\\dots,a_n$ 指定，次（和超）对角线由 $b_1,b_2,\\dots,b_{n-1}$ 指定，因此对于 $i = 1,2,\\dots,n-1$，有 $A_{i,i} = a_i$ 和 $A_{i,i+1} = A_{i+1,i} = b_i$。向量 $x$ 是未知数，而 $f$ 是给定的右端项。\n\n从带状系统的高斯消元法基本原理和对称性的定义出发，推导一个专门的消元和回代方案，该方案利用对称性来最小化存储量和算术运算。具体而言：\n- 从针对三对角矩阵的、以相邻行局部操作形式写出的高斯消元法开始，并利用 $A$ 的对称性来推断在消元过程中得以保留的结构。证明该消元过程可以仅使用一个乘子序列和一个主元序列来组织，而无需存储不同的次对角线和超对角线数组。\n- 利用对称矩阵和顺序主子式的性质，证明消元过程会产生一个下三角和对角结构，该结构可用于对任何不会在消元过程中遇到零主元的右端项 $f$ 进行高效的前向和后向回代。\n- 提供一个清晰的、分步骤的算法，该算法首先执行一次前向扫描以计算必要的标量序列和一个中间向量，然后进行对角求解，最后进行一次后向扫描，整个过程仅使用主对角线数组 $a_i$、一个次对角线数组 $b_i$ 和右端项 $f$。\n- 与用于非对称三对角系统的通用Thomas算法相比，分析您专门方案的存储需求和运算计数，并精确指出在利用对称性时减少了哪些部分。\n\n在一个单一、可运行的程序中实现您推导的算法。该程序必须为以下每个测试用例求解系统 $A x = f$，这些用例共同探查了典型、边界和边缘行为：\n\n- 测试用例 $1$（对称正定“理想路径”）：$n = 6$，对于 $i = 1,\\dots,6$，$a_i = 2$；对于 $i = 1,\\dots,5$，$b_i = -1$；以及 $f = [\\,1,\\,1,\\,1,\\,1,\\,1,\\,1\\,]$（所有元素在 $\\text{LaTeX}$ 中写作 $1$）。\n- 测试用例 $2$（边界大小）：$n = 1$，$a_1 = 3$，$b$ 为空，以及 $f = [\\,6\\,]$。\n- 测试用例 $3$（对称不定但非奇异）：$n = 3$，$a = [\\,0.5,\\,-1.2,\\,0.5\\,]$，$b = [\\,1.0,\\,1.0\\,]$，以及 $f = [\\,1.0,\\,2.0,\\,3.0\\,]$。\n- 测试用例 $4$（对角矩阵，作为次对角线为零的三对角矩阵）：$n = 3$，$a = [\\,5,\\,7,\\,9\\,]$，$b = [\\,0,\\,0\\,]$，以及 $f = [\\,10,\\,14,\\,27\\,]$。\n\n所有输入均为无量纲实数。您必须将输出表示为实数。对于每个测试用例，输出是解向量 $x$，形式为浮点数列表。\n\n最终输出格式规范：\n- 您的程序应生成单行输出，其中包含四个测试用例的解，形式为方括号括起来的、以逗号分隔的列表的列表，不含空格。例如，如果四个解向量分别为 $[\\,x_1,x_2\\,]$、$[\\,y_1\\,]$、$[\\,z_1,z_2,z_3\\,]$ 和 $[\\,w_1,w_2,w_3\\,]$，则格式应精确为 $[[x_1,x_2],[y_1],[z_1,z_2,z_3],[w_1,w_2,w_3]]$。",
            "solution": "我们从三对角系统的高斯消元法开始。三对角矩阵的非零元素仅存在于主对角线、第一条次对角线和第一条超对角线上。对于一个一般的三对角系统 $A x = f$，Thomas算法执行前向消元，逐步将次对角线元素清零，从而产生一个上三角系统，随后进行后向回代。\n\n这里的特殊设定是 $A$ 是对称三对角矩阵。对称性意味着 $A_{i+1,i} = A_{i,i+1}$，因此只需要一个次对角线数组。设主对角线为 $a_1,\\dots,a_n$，次对角线为 $b_1,\\dots,b_{n-1}$。在第 $i$ 步（对于 $i = 2,\\dots,n$）的局部消元使用第 $i-1$ 行的主元来消去第 $i$ 行的次对角线元素。在带状系统中，由于稀疏性，消元仅影响相邻行。\n\n基本原理：用于三对角矩阵的高斯消元法通过将第 $i$ 行加上第 $i-1$ 行的 $\\ell_i$ 倍来消去 $A_{i,i-1}$，其中选择乘子 $\\ell_i$ 使得新的次对角线元素变为零。乘子的值为\n$$\n\\ell_i = \\frac{A_{i,i-1}}{\\tilde{A}_{i-1,i-1}},\n$$\n其中 $\\tilde{A}$ 表示经过先前消元后在该步骤中运行的、已修改的系数。对于三对角矩阵，在第 $i-1$ 步消元后，第 $i-1$ 行中可能影响第 $i$ 行的元素只有对角元 $\\tilde{A}_{i-1,i-1}$ 和超对角元 $\\tilde{A}_{i-1,i}$。根据对称性和带状特性，$\\tilde{A}_{i-1,i}$ 等于次对角线元素 $b_{i-1}$，因为由相邻行消元所保留的结构不会在第一超对角线之外引入填充元素。\n\n因此，第 $i$ 步的消元通过一个依赖于 $\\ell_i$ 和次对角线元素 $b_{i-1}$ 的秩一修正来更新第 $i$ 行的对角元，右端项 $f$ 也相应地进行更新以用于前向回代。具体来说，我们维护一个主元序列（记为 $d_i = \\tilde{A}_{i,i}$）和一个乘子序列（记为 $\\ell_i = \\tilde{A}_{i,i-1}/d_{i-1}$），其中 $d_1 = a_1$ 且 $\\ell_1$ 未使用。前向扫描遵循以下递推关系\n$$\n\\ell_i = \\frac{b_{i-1}}{d_{i-1}}, \\quad d_i = a_i - \\ell_i\\,b_{i-1}, \\quad y_i = f_i - \\ell_i\\,y_{i-1},\n$$\n对于 $i = 2,\\dots,n$，初始化为 $y_1 = f_1$。这些关系直接源于高斯消元法：从第 $i$ 行减去第 $i-1$ 行的 $\\ell_i$ 倍会消去次对角线元素，并且由于第 $i-1$ 行在其对角元之外唯一的非零元素是超对角元 $b_{i-1}$，因此第 $i$ 行的对角元减少了 $\\ell_i b_{i-1}$；第 $i$ 行的右端项则减少了 $\\ell_i y_{i-1}$。\n\n该结构可以解释为 $L D L^{\\mathsf{T}}$ 分解，对于在消元过程中不会出现主元分解（当所有顺序主子式非零时）的对称矩阵，这是一个经过充分验证的事实。具体地，\n$$\nA = L D L^{\\mathsf{T}},\n$$\n其中 $L$ 是单位下三角矩阵，其次对角线元素为 $\\ell_2,\\dots,\\ell_n$，主对角线元素为1；$D$ 是对角矩阵，其对角线元素为 $d_1,\\dots,d_n$。这是因为每一步消元都只用前一行的倍数来更新当前行，从而保持了对称性和三对角结构；累积效应等价于将 $A$ 分解为一个单位下三角矩阵 $L$、一个对角矩阵 $D$ 和 $L$ 的转置。该分解无需选主元即可成立的条件是对于所有 $i$ 都有 $d_i \\neq 0$，这等价于所有顺序主子式非零。\n\n一旦建立了 $A = L D L^{\\mathsf{T}}$，求解 $A x = f$ 的过程便可分为三个基于该分解的原则性步骤：\n1. 前向回代求解 $L y = f$。这使用递推关系\n$$\ny_1 = f_1, \\quad y_i = f_i - \\ell_i y_{i-1} \\quad \\text{for } i = 2,\\dots,n.\n$$\n2. 对角求解从 $D w = y$ 获得 $w$：\n$$\nw_i = \\frac{y_i}{d_i} \\quad \\text{for } i = 1,\\dots,n.\n$$\n3. 后向回代求解 $L^{\\mathsf{T}} x = w$。因为 $L^{\\mathsf{T}}$ 是单位上三角矩阵，其超对角线元素为 $\\ell_2,\\dots,\\ell_n$，递推关系为\n$$\nx_n = w_n, \\quad x_i = w_i - \\ell_{i+1} x_{i+1} \\quad \\text{for } i = n-1,n-2,\\dots,1.\n$$\n\n存储量的减少是因为对称性消除了携带独立的次对角线和超对角线数组的需要；仅需要一个次对角线数组。该分解存储一个标量序列的乘子 $\\ell_i$ 和一个标量序列的主元 $d_i$，矩阵因子总共需要 $n + (n-1)$ 个标量。在用于非对称三对角矩阵的通用Thomas算法中，必须携带三个对角数组（$n$个主对角元，$(n-1)$个次对角元，$(n-1)$个超对角元），并且前向扫描通常还会计算和使用修改后的上对角线元素，导致更多的内存访问。\n\n运算计数分析：\n- 具有对称性和三对角性的前向扫描在每一步 $i = 2,\\dots,n$ 计算 $\\ell_i$ 需要一次除法，更新 $d_i$ 需要一次乘法和一次减法，更新 $y_i$ 需要一次乘法和一次减法。这相当于每步一次除法和四次基本浮点运算，总计 $(n-1)$ 次除法和 $4(n-1)$ 次基本浮点运算。\n- 对角求解执行 $n$ 次除法来计算 $w_i$。\n- 后向回代对于 $i = n-1,\\dots,1$，每步执行一次乘法和一次减法，总计 $2(n-1)$ 次浮点运算。\n\n相比之下，用于非对称三对角矩阵的通用Thomas算法执行一次前向扫描，每步计算一个乘子（一次除法），更新主对角线（一次乘法和一次减法），并更新右端项（一次乘法和一次减法），而且还必须引用一个独立的超对角线数组。虽然每步的算术运算数量在主导阶上可能相似，但利用对称性无需存储或访问一个单独的超对角线数组，并能够形成一种分解形式，这种形式天然地可重用于多个右端项而无需重新计算消元过程，从而在存在多个 $f$ 时减少了每次求解的有效运算计数。\n\n适合实现的算法总结：\n- 输入：长度为 $n$ 的数组 $a$（主对角线）、长度为 $n-1$ 的数组 $b$（次对角线）和长度为 $n$ 的数组 $f$。\n- 前向分解与前向回代：\n  - 设置 $d_1 = a_1$，$y_1 = f_1$。\n  - 对于 $i = 2$ 到 $n$：\n    - 计算 $\\ell_i = b_{i-1} / d_{i-1}$。\n    - 计算 $d_i = a_i - \\ell_i b_{i-1}$。\n    - 计算 $y_i = f_i - \\ell_i y_{i-1}$。\n- 对角求解：\n  - 对于 $i = 1$ 到 $n$，设置 $w_i = y_i / d_i$。\n- 后向回代：\n  - 设置 $x_n = w_n$。\n  - 对于 $i = n-1$ 递减到 $1$，设置 $x_i = w_i - \\ell_{i+1} x_{i+1}$。\n- 输出 $x$。\n\n测试套件包含四个用例：\n- 用例 1：$n = 6$，对于 $i = 1,\\dots,6$，$a_i = 2$；对于 $i = 1,\\dots,5$，$b_i = -1$；$f = [\\,1,\\,1,\\,1,\\,1,\\,1,\\,1\\,]$。\n- 用例 2：$n = 1$，$a_1 = 3$，$b$ 为空，$f = [\\,6\\,]$。\n- 用例 3：$n = 3$，$a = [\\,0.5,\\,-1.2,\\,0.5\\,]$，$b = [\\,1.0,\\,1.0\\,]$，$f = [\\,1.0,\\,2.0,\\,3.0\\,]$。\n- 用例 4：$n = 3$，$a = [\\,5,\\,7,\\,9\\,]$，$b = [\\,0,\\,0\\,]$，$f = [\\,10,\\,14,\\,27\\,]$。\n\n程序必须打印单行输出，其中包含四个解向量，格式为指定的嵌套列表形式，不含空格：$[[\\cdot],[\\cdot],[\\cdot],[\\cdot]]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef symmetric_tridiagonal_ldl_solve(a, b, f):\n    \"\"\"\n    Solve A x = f for symmetric tridiagonal A using LDL^T factorization.\n    A has main diagonal a (length n) and off-diagonal b (length n-1).\n    Returns x as a list of floats.\n    \"\"\"\n    n = len(a)\n    if len(f) != n:\n        raise ValueError(\"Length of f must equal length of a.\")\n    if n == 0:\n        return []\n    if len(b) not in (0, max(0, n - 1)):\n        raise ValueError(\"Length of b must be 0 or n-1.\")\n\n    # Allocate arrays\n    d = np.empty(n, dtype=float)         # diagonal of D\n    l = np.empty(n, dtype=float)         # subdiagonal of L (l[0] unused/zero)\n    y = np.empty(n, dtype=float)         # intermediate vector for Ly=f\n\n    # Forward factorization and forward substitution\n    d[0] = float(a[0])\n    l[0] = 0.0\n    y[0] = float(f[0])\n    for i in range(1, n):\n        bi_1 = float(b[i - 1]) if len(b) > 0 else 0.0\n        li = bi_1 / d[i - 1]\n        l[i] = li\n        d[i] = float(a[i]) - li * bi_1\n        y[i] = float(f[i]) - li * y[i - 1]\n\n    # Diagonal solve: D w = y\n    w = y / d\n\n    # Backward substitution: L^T x = w\n    x = np.empty(n, dtype=float)\n    x[n - 1] = w[n - 1]\n    for i in range(n - 2, -1, -1):\n        x[i] = w[i] - l[i + 1] * x[i + 1]\n\n    return x.tolist()\n\ndef format_nested_list_no_spaces(list_of_lists):\n    \"\"\"\n    Format a list of lists of numbers as a string without spaces, e.g.,\n    [[1.0,2.0],[3.0]] -> '[[1.0,2.0],[3.0]]' but with no spaces.\n    \"\"\"\n    def format_list(lst):\n        return \"[\" + \",\".join(f\"{num:.12g}\" if isinstance(num, float) else str(num) for num in lst) + \"]\"\n    return \"[\" + \",\".join(format_list(inner) for inner in list_of_lists) + \"]\"\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (a, b, f)\n    test_cases = [\n        # Case 1: n=6, a_i=2, b_i=-1, f=ones\n        ([2, 2, 2, 2, 2, 2], [-1, -1, -1, -1, -1], [1, 1, 1, 1, 1, 1]),\n        # Case 2: n=1, a=[3], b=[], f=[6]\n        ([3], [], [6]),\n        # Case 3: n=3, symmetric indefinite\n        ([0.5, -1.2, 0.5], [1.0, 1.0], [1.0, 2.0, 3.0]),\n        # Case 4: n=3, diagonal matrix (b zeros)\n        ([5, 7, 9], [0, 0], [10, 14, 27]),\n    ]\n\n    results = []\n    for a, b, f in test_cases:\n        x = symmetric_tridiagonal_ldl_solve(a, b, f)\n        results.append(x)\n\n    # Final print statement in the exact required format: no spaces.\n    print(format_nested_list_no_spaces(results))\n\nsolve()\n```"
        },
        {
            "introduction": "现实世界中的问题矩阵往往并非严格的三对角形式，而可能包含一些微小的扰动。本练习将介绍一种强大的技巧——Sherman-Morrison 公式，用于求解“近似”三对角系统，即一个三对角矩阵加上一个秩-1矩阵扰动。通过这个实践，您将学会如何在一个已有的三对角求解器的基础上，解决更复杂的线性系统问题 。",
            "id": "3208725",
            "problem": "考虑一个大小为 $n \\times n$ 的线性系统 $A x = b$，其中 $A$ 是一个“近似”三对角矩阵，它是在一个严格三对角矩阵的右上角添加一个非零元素得到的。令 $T$ 表示 $A$ 的严格三对角部分，且附加元素位于位置 $(1,n)$，其值为 $\\gamma \\in \\mathbb{R}$。矩阵 $T$ 有一个非零的次对角线 $a$、主对角线 $d$ 和超对角线 $c$。矩阵 $A$ 的结构为 $A = T + \\gamma e_1 e_n^{\\top}$，其中 $e_1$ 和 $e_n$ 分别是 $\\mathbb{R}^n$ 中的第一个和最后一个标准基向量。\n\n你的任务是设计并实现一个求解器，该求解器：\n- 使用基于前向消元和后向代入（通常称为托马斯算法）的稳定三对角求解器来求解系统 $T y = b$。\n- 结合一个有原则的秩-1 更新来处理位置 $(1,n)$ 的附加元素，依赖于关于秩-1 扰动矩阵求逆的基本线性代数恒等式，而不预先假设任何快捷公式。\n- 为所有提供的测试用例生成数值上鲁棒的解。\n\n基本出发点包括：\n- 三对角矩阵和带状矩阵的定义。\n- 严格对角占优系统的解的存在性和唯一性。\n- 通过消元法求解三对角系统可以在 $\\mathcal{O}(n)$ 时间内完成的事实。\n- 一个被秩-1 矩阵扰动的矩阵的逆可以用原矩阵的逆和扰动向量的外积来表示的性质。\n\n你必须从这些原则推导出必要的步骤来实现该算法。实现必须能解决以下包含五个案例的测试套件。每个测试用例指定了 $n$、三对角数组 $a$、$d$、$c$、标量 $\\gamma$ 以及右侧向量 $b$。所有数值均为实数，所有向量的长度均为 $n$。\n\n测试套件：\n- 案例 1：$n = 5$，$a = [-1,-1,-1,-1]$，$d = [2,2,2,2,2]$，$c = [-1,-1,-1,-1]$，$\\gamma = 0.5$，$b = [1,1,1,1,1]$。\n- 案例 2：$n = 4$，$a = [-1,-1,-1]$，$d = [2,2,2,2]$，$c = [-1,-1,-1]$，$\\gamma = 0$，$b = [1,2,3,4]$。\n- 案例 3：$n = 6$，$a = [-1,-1,-1,-1,-1]$，$d = [2,2,2,2,2,2]$，$c = [-1,-1,-1,-1,-1]$，$\\gamma = -6.999$，$b = [0,1,0,1,0,1]$。\n- 案例 4：$n = 2$，$a = [-1]$，$d = [2,2]$，$c = [-1]$，$\\gamma = 0.3$，$b = [2,1]$。\n- 案例 5：$n = 5$，$a = [-1,-0.5,-1.5,-1.0]$，$d = [4,3.5,5,4.2,3.8]$，$c = [-1,-1.2,-0.7,-0.9]$，$\\gamma = 0.7$，$b = [1,0.5,-1,0.25,2]$。\n\n你的程序必须：\n- 使用前向消元和后向代入，以 $\\mathcal{O}(n)$ 的时间复杂度实现一个用于求解 $T y = b$ 的三对角求解器。\n- 仅使用基本线性代数恒等式来实现秩-1 更新，从而从三对角系统的解中获得 $A x = b$ 的解 $x$。\n- 对于每个测试用例，计算解向量 $x$ 并将每个分量四舍五入到 6 位小数。\n\n最终输出规范：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个条目本身都是一个表示一个测试用例解向量的方括号列表。例如，格式应为 $[[$x_{1,1},\\dots,x_{1,n_1}$],[$x_{2,1},\\dots,x_{2,n_2}$],\\dots]$，不含空格。\n- 不涉及物理单位，也不需要角度单位。\n- 每个测试用例的答案是一个浮点数列表，四舍五入到 6 位小数。",
            "solution": "用户提供的问题已经过验证，并被确定为数值线性代数中一个有效且适定的问题。任务是求解线性方程组 $A x = b$，其中矩阵 $A$ 是一个三对角矩阵 $T$ 加上一个秩-1 矩阵扰动。\n\n该系统定义为：\n$$A x = b$$\n其中 $A$ 是一个 $n \\times n$ 矩阵，由下式给出\n$$A = T + \\gamma e_1 e_n^{\\top}$$\n在这里，$T$ 是一个严格三对角矩阵，其次对角线元素为 $a_i$（对于 $i=2, \\dots, n$），主对角线元素为 $d_i$（对于 $i=1, \\dots, n$），超对角线元素为 $c_i$（对于 $i=1, \\dots, n-1$）。项 $\\gamma e_1 e_n^{\\top}$ 表示一个秩-1 更新，其中 $\\gamma \\in \\mathbb{R}$ 是一个标量，$e_1$ 和 $e_n$ 分别是 $\\mathbb{R}^n$ 中的第一个和最后一个标准基向量。这个更新在矩阵 $T$ 的位置 $(1, n)$ 上增加了一个非零元素 $\\gamma$。\n\n解 $x$ 可以形式化地写为 $x = A^{-1} b$。为了推导出一个计算算法，我们依赖于 Sherman-Morrison 公式，这是一个关于秩-1 扰动矩阵求逆的基本恒等式。该公式指出，对于一个可逆矩阵 $B$ 和向量 $u, v$，矩阵 $B + uv^{\\top}$ 的逆是：\n$$(B + uv^{\\top})^{-1} = B^{-1} - \\frac{B^{-1} u v^{\\top} B^{-1}}{1 + v^{\\top} B^{-1} u}$$\n该公式在 $1 + v^{\\top} B^{-1} u \\neq 0$ 的条件下成立。\n\n在我们的问题中，我们认定 $B=T$，$u = \\gamma e_1$，$v = e_n$。将这些代入公式，我们得到 $A$ 的逆：\n$$A^{-1} = \\left(T + (\\gamma e_1)e_n^{\\top}\\right)^{-1} = T^{-1} - \\frac{T^{-1}(\\gamma e_1)e_n^{\\top}T^{-1}}{1 + \\gamma e_n^{\\top}T^{-1}e_1}$$\n然后通过将 $A^{-1}$ 乘以 $b$ 来获得解向量 $x$：\n$$x = A^{-1} b = T^{-1} b - \\frac{T^{-1}(\\gamma e_1)e_n^{\\top}T^{-1}b}{1 + \\gamma e_n^{\\top}T^{-1}e_1}$$\n为了使这个表达式在计算上易于处理，我们引入两个辅助向量 $y$ 和 $z$，它们是涉及矩阵 $T$ 的三对角系统的解：\n1. 令 $y = T^{-1} b$。这等价于求解三对角系统 $T y = b$。\n2. 令 $z = T^{-1} e_1$。这等价于求解三对角系统 $T z = e_1$。\n\n使用这些定义，我们可以简化 $x$ 的表达式。\n- 项 $e_n^{\\top}T^{-1}b$ 是向量 $y$ 的第 $n$ 个分量，我们记为 $y_n$。\n- 项 $e_n^{\\top}T^{-1}e_1$ 是向量 $z$ 的第 $n$ 个分量，我们记为 $z_n$。\n- 项 $T^{-1}(\\gamma e_1)$ 变为 $\\gamma (T^{-1}e_1) = \\gamma z$。\n\n将这些代入 $x$ 的方程，我们得到最终表达式：\n$$x = y - \\frac{\\gamma y_n}{1 + \\gamma z_n} z$$\n这个简洁的公式将求解近似三对角系统的问题简化为求解两个严格三对角系统并执行一个简单的向量更新。如果 $\\gamma = 0$，公式正确地简化为 $x=y$，因为 $A=T$。$A$ 的奇异性取决于分母 $1 + \\gamma z_n$ 是否为零。\n\n两个三对角系统 $T y = b$ 和 $T z = e_1$ 可以使用托马斯算法在 $\\mathcal{O}(n)$ 时间内高效求解。我们采用一种基于 LU 分解的稳定算法变体。对于一个三对角系统 $T u = f$，该算法分三个阶段进行：\n\n1.  **LU 分解**：矩阵 $T$ 被分解为 $T = LU$，其中 $L$ 是一个下双对角矩阵，$U$ 是一个主对角线元素为 1 的上双对角矩阵。$L$ 的非零元素（对角线 $\\alpha_i$）和 $U$ 的非零元素（超对角线 $\\delta_i$）通过以下递推公式计算（对数组 $a, d, c$ 使用基于 0 的索引）：\n    $$ \\alpha_0 = d_0 $$\n    $$ \\delta_0 = c_0 / \\alpha_0 $$\n    对于 $i = 1, \\dots, n-2$:\n    $$ \\alpha_i = d_i - a_{i-1} \\delta_{i-1} $$\n    $$ \\delta_i = c_i / \\alpha_i $$\n    $$ \\alpha_{n-1} = d_{n-1} - a_{n-2} \\delta_{n-2} $$\n\n2.  **前向代入**：系统 $T u = LU u = f$ 被分解为两个更简单的系统。首先，我们求解 $L w = f$ 以得到中间向量 $w$。\n    $$ w_0 = f_0 / \\alpha_0 $$\n    对于 $i = 1, \\dots, n-1$:\n    $$ w_i = (f_i - a_{i-1} w_{i-1}) / \\alpha_i $$\n\n3.  **后向代入**：最后，我们求解 $U u = w$ 以得到解向量 $u$。\n    $$ u_{n-1} = w_{n-1} $$\n    对于 $i = n-2, \\dots, 0$:\n    $$ u_i = w_i - \\delta_i u_{i+1} $$\n\n整体算法如下：\n1.  处理平凡情况：如果 $\\gamma=0$，使用托马斯算法求解 $Tx=b$ 并返回 $x$。\n2.  使用托马斯算法求解 $Ty = b$ 得到 $y$。\n3.  使用托马斯算法求解 $Tz = e_1$ 得到 $z$。\n4.  提取最后一个分量，$y_{n-1}$ 和 $z_{n-1}$（使用基于 0 的索引）。\n5.  计算标量因子 $\\beta = \\frac{\\gamma y_{n-1}}{1 + \\gamma z_{n-1}}$。\n6.  计算最终解向量 $x = y - \\beta z$。\n7.  返回结果向量 $x$。\n对于对角占优矩阵 $T$，此过程是数值稳定的，并为问题提供了高效的 $\\mathcal{O}(n)$ 解法。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, solve them, and print the results.\n    \"\"\"\n\n    def tridiagonal_solver(a, d, c, f):\n        \"\"\"\n        Solves a tridiagonal linear system Tu=f using an LU decomposition-based\n        Thomas algorithm.\n        \n        Args:\n            a: Subdiagonal elements (length n-1).\n            d: Diagonal elements (length n).\n            c: Superdiagonal elements (length n-1).\n            f: Right-hand side vector (length n).\n            \n        Returns:\n            The solution vector u (numpy array of length n).\n        \"\"\"\n        n = len(d)\n        \n        # Ensure inputs are numpy arrays and create copies to avoid mutation.\n        ac, dc, cc, fc = map(lambda v: np.array(v, dtype=float), (a, d, c, f))\n\n        # LU Factorization (T = LU)\n        # alpha is the diagonal of L, delta is the superdiagonal of U.\n        alpha = np.zeros(n)\n        delta = np.zeros(n - 1)\n\n        alpha[0] = dc[0]\n        if n > 1:\n            delta[0] = cc[0] / alpha[0]\n\n        for i in range(1, n - 1):\n            alpha[i] = dc[i] - ac[i-1] * delta[i-1]\n            delta[i] = cc[i] / alpha[i]\n        \n        if n > 1:\n            alpha[n-1] = dc[n-1] - ac[n-2] * delta[n-2]\n\n        # Forward Substitution: Solve Lw = f for w\n        w = np.zeros(n)\n        w[0] = fc[0] / alpha[0]\n        for i in range(1, n):\n            w[i] = (fc[i] - ac[i-1] * w[i-1]) / alpha[i]\n            \n        # Backward Substitution: Solve Uu = w for u\n        u = np.zeros(n)\n        u[n-1] = w[n-1]\n        for i in range(n-2, -1, -1):\n            u[i] = w[i] - delta[i] * u[i+1]\n            \n        return u\n\n    def solve_almost_tridiagonal(n, a, d, c, gamma, b):\n        \"\"\"\n        Solves the almost-tridiagonal system using the Sherman-Morrison formula.\n        \"\"\"\n        # If gamma is zero, the system is purely tridiagonal.\n        if gamma == 0.0:\n            return tridiagonal_solver(a, d, c, b)\n        \n        # Step 1: Solve Ty = b\n        y = tridiagonal_solver(a, d, c, b)\n        \n        # Step 2: Solve Tz = e_1\n        e1 = np.zeros(n)\n        e1[0] = 1.0\n        z = tridiagonal_solver(a, d, c, e1)\n        \n        # Step 3: Apply the Sherman-Morrison update formula\n        # x = y - (gamma * y_n / (1 + gamma * z_n)) * z\n        y_n = y[-1]\n        z_n = z[-1]\n        \n        denominator = 1.0 + gamma * z_n\n        \n        if abs(denominator)  1e-15:\n            # This case should not occur with the given test data, but it's\n            # good practice to guard against singular matrices.\n            raise ValueError(\"Matrix A is singular or nearly singular.\")\n        \n        beta = (gamma * y_n) / denominator\n        x = y - beta * z\n        return x\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        (5, [-1,-1,-1,-1], [2,2,2,2,2], [-1,-1,-1,-1], 0.5, [1,1,1,1,1]),\n        # Case 2\n        (4, [-1,-1,-1], [2,2,2,2], [-1,-1,-1], 0.0, [1,2,3,4]),\n        # Case 3\n        (6, [-1,-1,-1,-1,-1], [2,2,2,2,2,2], [-1,-1,-1,-1,-1], -6.999, [0,1,0,1,0,1]),\n        # Case 4\n        (2, [-1], [2,2], [-1], 0.3, [2,1]),\n        # Case 5\n        (5, [-1,-0.5,-1.5,-1.0], [4,3.5,5,4.2,3.8], [-1,-1.2,-0.7,-0.9], 0.7, [1,0.5,-1,0.25,2]),\n    ]\n\n    all_solutions = []\n    for case_params in test_cases:\n        solution_vector = solve_almost_tridiagonal(*case_params)\n        \n        # Round each component to 6 decimal places.\n        rounded_solution = np.round(solution_vector, 6).tolist()\n        all_solutions.append(rounded_solution)\n\n    # Format the final output string as per the specification.\n    solution_strings = []\n    for sol in all_solutions:\n        # Create a comma-separated string for one solution vector without spaces.\n        sol_str = \",\".join(map(str, sol))\n        solution_strings.append(f\"[{sol_str}]\")\n    \n    # Join all solution strings into the final format.\n    final_output = f\"[{','.join(solution_strings)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "托马斯算法的基本原理可以从标量运算推广到矩阵运算，这在求解偏微分方程组的离散化问题时尤为重要。本练习将引导您开发一种“块托马斯算法”，用于处理其元素本身就是矩阵（分块）的线性系统。这个高级实践将挑战您将标量世界的算法思想，迁移到更抽象的块矩阵世界中 。",
            "id": "3208590",
            "problem": "考虑一个具有 $N$ 个块的块三对角线性方程组 (LSE)，其中每个块都是一个 $2 \\times 2$ 矩阵。全局系数矩阵 $\\mathbf{A}$ 具有以下块结构：对角块 $\\mathbf{D}_i \\in \\mathbb{R}^{2 \\times 2}$（对于 $i = 1, \\ldots, N$），上对角块 $\\mathbf{U}_i \\in \\mathbb{R}^{2 \\times 2}$（对于 $i = 1, \\ldots, N-1$），下对角块 $\\mathbf{L}_i \\in \\mathbb{R}^{2 \\times 2}$（对于 $i = 2, \\ldots, N$），以及由二维向量 $\\mathbf{f}_i \\in \\mathbb{R}^{2}$（对于 $i = 1, \\ldots, N$）组成的右端项。全局未知向量是块未知量 $\\mathbf{x}_i \\in \\mathbb{R}^{2}$（$i = 1, \\ldots, N$）的拼接，因此整个系统的维度为 $2N$。\n\n此问题的基本原理是线性系统 $\\mathbf{A}\\mathbf{x} = \\mathbf{b}$ 的定义以及应用于块级别的 Gaussian 消元法原理：消元过程使用遵循矩阵乘法结合律和分配律的块矩阵运算逐行进行，通过前向消元和后向代入求得解，前提是所有中间块主元均非奇异。\n\n你的任务是为这个块三对角系统实现一个块 Thomas 算法。该算法必须：\n- 纯粹对块 $\\mathbf{D}_i$、$\\mathbf{U}_i$、$\\mathbf{L}_i$ 和向量 $\\mathbf{f}_i$ 进行操作，而不形成完整的 $2N \\times 2N$ 矩阵。\n- 使用标准的矩阵和向量运算在块级别上执行前向消元和后向代入。\n- 假设每次所需的块求逆或块线性求解都是良定义的（即相关的 $2 \\times 2$ 矩阵是非奇异的）。\n\n为保证数值输出的一致性，请将解向量的每个分量四舍五入到 $8$ 位小数。\n\n实现程序以求解以下块三对角系统的测试套件。对于每个测试用例，数据由块数 $N$、列表 $\\{\\mathbf{D}_i\\}$、$\\{\\mathbf{U}_i\\}$、$\\{\\mathbf{L}_i\\}$ 和 $\\{\\mathbf{f}_i\\}$ 给出：\n\n测试用例 1（典型情况）：\n- $N = 3$。\n- 对角块：\n$$\n\\mathbf{D}_1 = \\begin{bmatrix} 4  1 \\\\ 1  3 \\end{bmatrix}, \\quad\n\\mathbf{D}_2 = \\begin{bmatrix} 3  0.5 \\\\ 0.5  4 \\end{bmatrix}, \\quad\n\\mathbf{D}_3 = \\begin{bmatrix} 2.5  0.4 \\\\ 0.4  2.0 \\end{bmatrix}.\n$$\n- 上对角块：\n$$\n\\mathbf{U}_1 = \\begin{bmatrix} 1  0 \\\\ 0  1 \\end{bmatrix}, \\quad\n\\mathbf{U}_2 = \\begin{bmatrix} -1  0.2 \\\\ 0.4  0.5 \\end{bmatrix}.\n$$\n- 下对角块：\n$$\n\\mathbf{L}_2 = \\begin{bmatrix} 0.5  -0.2 \\\\ 0.1  0.3 \\end{bmatrix}, \\quad\n\\mathbf{L}_3 = \\begin{bmatrix} -0.3  0.4 \\\\ 0.2  0.1 \\end{bmatrix}.\n$$\n- 右端项：\n$$\n\\mathbf{f}_1 = \\begin{bmatrix} 1 \\\\ 2 \\end{bmatrix}, \\quad\n\\mathbf{f}_2 = \\begin{bmatrix} 0 \\\\ -1 \\end{bmatrix}, \\quad\n\\mathbf{f}_3 = \\begin{bmatrix} 3 \\\\ 1 \\end{bmatrix}.\n$$\n\n测试用例 2（只有一个块的边界情况）：\n- $N = 1$。\n- 对角块：\n$$\n\\mathbf{D}_1 = \\begin{bmatrix} 2  -1 \\\\ -1  2 \\end{bmatrix}.\n$$\n- 没有上对角块或下对角块。\n- 右端项：\n$$\n\\mathbf{f}_1 = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}.\n$$\n\n测试用例 3（符号变化的较长链）：\n- $N = 4$。\n- 对角块：\n$$\n\\mathbf{D}_1 = \\begin{bmatrix} 3  0.2 \\\\ 0.2  2.5 \\end{bmatrix}, \\quad\n\\mathbf{D}_2 = \\begin{bmatrix} 2.8  -0.1 \\\\ -0.1  3.2 \\end{bmatrix}, \\quad\n\\mathbf{D}_3 = \\begin{bmatrix} 3.0  0.4 \\\\ 0.4  2.2 \\end{bmatrix}, \\quad\n\\mathbf{D}_4 = \\begin{bmatrix} 2.6  -0.3 \\\\ -0.3  2.9 \\end{bmatrix}.\n$$\n- 上对角块：\n$$\n\\mathbf{U}_1 = \\begin{bmatrix} 0.1  -0.2 \\\\ 0.3  0.0 \\end{bmatrix}, \\quad\n\\mathbf{U}_2 = \\begin{bmatrix} 0.0  0.25 \\\\ -0.3  0.15 \\end{bmatrix}, \\quad\n\\mathbf{U}_3 = \\begin{bmatrix} -0.2  0.1 \\\\ 0.25  -0.05 \\end{bmatrix}.\n$$\n- 下对角块：\n$$\n\\mathbf{L}_2 = \\begin{bmatrix} -0.05  0.2 \\\\ 0.1  -0.1 \\end{bmatrix}, \\quad\n\\mathbf{L}_3 = \\begin{bmatrix} 0.2  -0.1 \\\\ 0.05  0.3 \\end{bmatrix}, \\quad\n\\mathbf{L}_4 = \\begin{bmatrix} -0.1  0.0 \\\\ 0.15  -0.2 \\end{bmatrix}.\n$$\n- 右端项：\n$$\n\\mathbf{f}_1 = \\begin{bmatrix} 0.5 \\\\ -1.0 \\end{bmatrix}, \\quad\n\\mathbf{f}_2 = \\begin{bmatrix} 1.5 \\\\ 2.0 \\end{bmatrix}, \\quad\n\\mathbf{f}_3 = \\begin{bmatrix} -0.5 \\\\ 0.25 \\end{bmatrix}, \\quad\n\\mathbf{f}_4 = \\begin{bmatrix} 0.0 \\\\ -1.0 \\end{bmatrix}.\n$$\n\n测试用例 4（对角块接近奇异但仍可逆）：\n- $N = 3$。\n- 对角块：\n$$\n\\mathbf{D}_1 = \\begin{bmatrix} 10^{-3}  0.0 \\\\ 0.0  1.0 \\end{bmatrix}, \\quad\n\\mathbf{D}_2 = \\begin{bmatrix} 1.0  0.9999 \\\\ 0.9999  1.0 \\end{bmatrix}, \\quad\n\\mathbf{D}_3 = \\begin{bmatrix} 10^{-2}  0.0 \\\\ 0.0  2.0 \\end{bmatrix}.\n$$\n- 上对角块：\n$$\n\\mathbf{U}_1 = \\begin{bmatrix} 0.2  -0.1 \\\\ 0.1  0.0 \\end{bmatrix}, \\quad\n\\mathbf{U}_2 = \\begin{bmatrix} -0.1  0.0 \\\\ 0.0  0.1 \\end{bmatrix}.\n$$\n- 下对角块：\n$$\n\\mathbf{L}_2 = \\begin{bmatrix} 0.0  0.1 \\\\ 0.05  0.0 \\end{bmatrix}, \\quad\n\\mathbf{L}_3 = \\begin{bmatrix} 0.0  -0.05 \\\\ 0.02  0.0 \\end{bmatrix}.\n$$\n- 右端项：\n$$\n\\mathbf{f}_1 = \\begin{bmatrix} 1.0 \\\\ 0.0 \\end{bmatrix}, \\quad\n\\mathbf{f}_2 = \\begin{bmatrix} -1.0 \\\\ 1.0 \\end{bmatrix}, \\quad\n\\mathbf{f}_3 = \\begin{bmatrix} 0.5 \\\\ -0.5 \\end{bmatrix}.\n$$\n\n你的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果，每个元素是一个测试用例的解，表示为从块 1 到块 N 的长度为 $2N$ 的列表，并四舍五入到 $8$ 位小数。例如，整体输出格式必须如下所示\n$$\n\\texttt{[[x_{1,1},x_{1,2},\\ldots,x_{N,1},x_{N,2}],\\;[\\ldots],\\;[\\ldots],\\;[\\ldots]]}\n$$\n依次涵盖四个测试用例。",
            "solution": "所提出的问题是求解形如 $\\mathbf{A}\\mathbf{x} = \\mathbf{f}$ 的块三对角线性方程组。此问题是良定义的，在数值线性代数中有科学依据，并且所有测试用例的必要数据均已提供。所有中间块主元均非奇异的假设确保了通过所提出的块 Gaussian 消元法存在唯一解。因此，该问题被认为是有效的。\n\n该系统由 $N$ 个块方程定义。对于 $i=1, \\dots, N$，第 $i$ 个块方程为：\n$$ \\mathbf{L}_i \\mathbf{x}_{i-1} + \\mathbf{D}_i \\mathbf{x}_i + \\mathbf{U}_i \\mathbf{x}_{i+1} = \\mathbf{f}_i $$\n其中块为 $\\mathbf{L}_i, \\mathbf{D}_i, \\mathbf{U}_i \\in \\mathbb{R}^{2 \\times 2}$，向量为 $\\mathbf{x}_i, \\mathbf{f}_i \\in \\mathbb{R}^2$。按照惯例，$\\mathbf{L}_1$ 和 $\\mathbf{U}_N$ 是适当大小的零矩阵。求解该系统的算法是标量三对角系统 Thomas 算法的直接推广，称为块 Thomas 算法或块三对角算法。它包括两个主要阶段：前向消元扫描和后向代入扫描。\n\n其核心原理是执行逐块 Gaussian 消元，将系统转换为块上双对角形式，然后可以通过后向代入轻松求解。\n\n**1. 前向消元阶段**\n\n此阶段的目标是将每个块方程转换为以下形式：\n$$ \\mathbf{x}_i + \\mathbf{U}'_i \\mathbf{x}_{i+1} = \\mathbf{f}'_i $$\n这通过推导修改后的块系数 $\\mathbf{U}'_i$ 和右端向量 $\\mathbf{f}'_i$ 的递推关系来实现。\n\n对于第一个块行（$i=1$），方程为：\n$$ \\mathbf{D}_1 \\mathbf{x}_1 + \\mathbf{U}_1 \\mathbf{x}_2 = \\mathbf{f}_1 $$\n假设 $\\mathbf{D}_1$ 是非奇异的（根据问题陈述的保证），我们可以左乘其逆矩阵 $\\mathbf{D}_1^{-1}$：\n$$ \\mathbf{x}_1 + \\mathbf{D}_1^{-1} \\mathbf{U}_1 \\mathbf{x}_2 = \\mathbf{D}_1^{-1} \\mathbf{f}_1 $$\n这给出了我们递推的初始值：\n$$ \\mathbf{U}'_1 = \\mathbf{D}_1^{-1} \\mathbf{U}_1 $$\n$$ \\mathbf{f}'_1 = \\mathbf{D}_1^{-1} \\mathbf{f}_1 $$\n\n现在，考虑对于 $i = 2, \\ldots, N-1$ 的一般块行：\n$$ \\mathbf{L}_i \\mathbf{x}_{i-1} + \\mathbf{D}_i \\mathbf{x}_i + \\mathbf{U}_i \\mathbf{x}_{i+1} = \\mathbf{f}_i $$\n我们假设前一个块的关系式 $\\mathbf{x}_{i-1} = \\mathbf{f}'_{i-1} - \\mathbf{U}'_{i-1} \\mathbf{x}_i$ 已经建立。将此代入块 $i$ 的方程中：\n$$ \\mathbf{L}_i (\\mathbf{f}'_{i-1} - \\mathbf{U}'_{i-1} \\mathbf{x}_i) + \\mathbf{D}_i \\mathbf{x}_i + \\mathbf{U}_i \\mathbf{x}_{i+1} = \\mathbf{f}_i $$\n将含 $\\mathbf{x}_i$ 的项组合在一起：\n$$ (\\mathbf{D}_i - \\mathbf{L}_i \\mathbf{U}'_{i-1}) \\mathbf{x}_i + \\mathbf{U}_i \\mathbf{x}_{i+1} = \\mathbf{f}_i - \\mathbf{L}_i \\mathbf{f}'_{i-1} $$\n让我们将中间块主元定义为 $\\mathbf{D}'_i = \\mathbf{D}_i - \\mathbf{L}_i \\mathbf{U}'_{i-1}$。问题陈述保证 $\\mathbf{D}'_i$ 是非奇异的。左乘 $(\\mathbf{D}'_i)^{-1}$：\n$$ \\mathbf{x}_i + (\\mathbf{D}'_i)^{-1} \\mathbf{U}_i \\mathbf{x}_{i+1} = (\\mathbf{D}'_i)^{-1} (\\mathbf{f}_i - \\mathbf{L}_i \\mathbf{f}'_{i-1}) $$\n这给出了 $i=2, \\ldots, N-1$ 的递推关系：\n$$ \\mathbf{U}'_i = (\\mathbf{D}_i - \\mathbf{L}_i \\mathbf{U}'_{i-1})^{-1} \\mathbf{U}_i $$\n$$ \\mathbf{f}'_i = (\\mathbf{D}_i - \\mathbf{L}_i \\mathbf{U}'_{i-1})^{-1} (\\mathbf{f}_i - \\mathbf{L}_i \\mathbf{f}'_{i-1}) $$\n在实现中，求解线性系统比显式计算矩阵的逆在数值上更可取。因此，我们通过求解 $(\\mathbf{D}_i - \\mathbf{L}_i \\mathbf{U}'_{i-1}) \\mathbf{X} = \\mathbf{U}_i$ 来计算 $\\mathbf{U}'_i$，并类似地处理 $\\mathbf{f}'_i$。\n\n对于最后一个块行（$i=N$），方程为：\n$$ \\mathbf{L}_N \\mathbf{x}_{N-1} + \\mathbf{D}_N \\mathbf{x}_N = \\mathbf{f}_N $$\n使用步骤 $N-1$ 的关系式代入 $\\mathbf{x}_{N-1}$：\n$$ \\mathbf{L}_N (\\mathbf{f}'_{N-1} - \\mathbf{U}'_{N-1} \\mathbf{x}_N) + \\mathbf{D}_N \\mathbf{x}_N = \\mathbf{f}_N $$\n重新整理以求解 $\\mathbf{x}_N$：\n$$ (\\mathbf{D}_N - \\mathbf{L}_N \\mathbf{U}'_{N-1}) \\mathbf{x}_N = \\mathbf{f}_N - \\mathbf{L}_N \\mathbf{f}'_{N-1} $$\n令最终主元为 $\\mathbf{D}'_N = \\mathbf{D}_N - \\mathbf{L}_N \\mathbf{U}'_{N-1}$。最后一个未知块向量 $\\mathbf{x}_N$ 通过求解以下方程得到：\n$$ \\mathbf{x}_N = (\\mathbf{D}'_N)^{-1} (\\mathbf{f}_N - \\mathbf{L}_N \\mathbf{f}'_{N-1}) $$\n\n**2. 后向代入阶段**\n\n在计算出最后一个块向量 $\\mathbf{x}_N$ 后，我们可以通过从 $i=N-1$ 向下到 $1$ 进行后向代入来找到剩余的解向量。递推关系直接取自转换后的系统：\n$$ \\mathbf{x}_i = \\mathbf{f}'_i - \\mathbf{U}'_i \\mathbf{x}_{i+1} \\quad \\text{for } i = N-1, N-2, \\ldots, 1 $$\n这个过程计算出所有的 $\\mathbf{x}_i$，从而完成求解。\n\n**特殊情况：N=1**\n如果只有一个块（$N=1$），系统简化为 $\\mathbf{D}_1 \\mathbf{x}_1 = \\mathbf{f}_1$。解可以通过求解这个单一的 $2 \\times 2$ 系统直接获得：$\\mathbf{x}_1 = \\mathbf{D}_1^{-1} \\mathbf{f}_1$。\n\n**算法总结**\n\n1.  **如果 $N=1$**：求解 $\\mathbf{D}_1 \\mathbf{x}_1 = \\mathbf{f}_1$ 并返回 $\\mathbf{x}_1$。\n2.  **前向消元（$i=1$ 到 $N$）**：\n    a. 初始化：通过求解 $\\mathbf{D}_1 \\mathbf{X} = \\mathbf{U}_1$ 计算 $\\mathbf{U}'_1$，通过求解 $\\mathbf{D}_1 \\mathbf{y} = \\mathbf{f}_1$ 计算 $\\mathbf{f}'_1$。\n    b. 对 $i=2, \\ldots, N-1$ 迭代：\n       i.  计算主元 $\\mathbf{D}'_i = \\mathbf{D}_i - \\mathbf{L}_i \\mathbf{U}'_{i-1}$。\n       ii. 通过求解 $\\mathbf{D}'_i \\mathbf{X} = \\mathbf{U}_i$ 计算 $\\mathbf{U}'_i$。\n       iii.通过求解 $\\mathbf{D}'_i \\mathbf{y} = (\\mathbf{f}_i - \\mathbf{L}_i \\mathbf{f}'_{i-1})$ 计算 $\\mathbf{f}'_i$。\n    c. 最后一步：通过求解 $(\\mathbf{D}_N - \\mathbf{L}_N \\mathbf{U}'_{N-1}) \\mathbf{x}_N = (\\mathbf{f}_N - \\mathbf{L}_N \\mathbf{f}'_{N-1})$ 计算最后一个块向量 $\\mathbf{x}_N$。\n3.  **后向代入（$i=N-1$ 到 $1$）**：\n    a. 向下迭代：$\\mathbf{x}_i = \\mathbf{f}'_i - \\mathbf{U}'_i \\mathbf{x}_{i+1}$。\n4.  **结果**：解是有序向量集合 $\\{\\mathbf{x}_1, \\ldots, \\mathbf{x}_N\\}$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to define, solve, and format the results for the test cases.\n    \"\"\"\n\n    def solve_block_tridiagonal(N, D, U, L, f):\n        \"\"\"\n        Solves a block tridiagonal system of equations using the block Thomas algorithm.\n\n        Args:\n            N (int): The number of blocks.\n            D (list of np.ndarray): List of N diagonal 2x2 blocks.\n            U (list of np.ndarray): List of N-1 upper off-diagonal 2x2 blocks.\n            L (list of np.ndarray): List of N-1 lower off-diagonal 2x2 blocks.\n            f (list of np.ndarray): List of N right-hand side 2x1 vectors.\n\n        Returns:\n            list: The flattened solution vector x, with components rounded to 8 decimal places.\n        \"\"\"\n        # Handle the special case of a single block.\n        if N == 1:\n            x0 = np.linalg.solve(D[0], f[0])\n            solution_vecs = [x0]\n            flat_solution = np.concatenate(solution_vecs).ravel()\n            return [round(val, 8) for val in flat_solution]\n\n        # Storage for modified coefficients (forward sweep).\n        U_prime = [None] * (N - 1)\n        f_prime = [None] * (N - 1) # We only need up to N-1 for back-substitution.\n\n        # ----- Forward Elimination Phase -----\n\n        # Step 1: i = 1 (Python index 0)\n        # Solve D_1 * X = U_1 for U'_1 and D_1 * y = f_1 for f'_1\n        U_prime[0] = np.linalg.solve(D[0], U[0])\n        f_prime[0] = np.linalg.solve(D[0], f[0])\n        \n        # Step 2: i = 2 to N-1 (Python index 1 to N-2)\n        for i in range(1, N - 1):\n            D_i, U_i = D[i], U[i]\n            L_i = L[i-1] # L_i in math corresponds to L[i-1] in problem data\n            \n            # Compute intermediate pivot D'_i = D_i - L_i * U'_{i-1}\n            D_prime_i = D_i - L_i @ U_prime[i-1]\n            \n            # Solve D'_i * X = U_i for U'_i\n            U_prime[i] = np.linalg.solve(D_prime_i, U_i)\n            \n            # Solve D'_i * y = (f_i - L_i * f'_{i-1}) for f'_i\n            f_rhs = f[i] - L_i @ f_prime[i-1]\n            f_prime[i] = np.linalg.solve(D_prime_i, f_rhs)\n\n        # Step 3: Final step of forward sweep for i=N\n        # Solve D'_N * x_N = (f_N - L_N * f'_{N-1})\n        D_N = D[N-1]\n        L_N = L[N-2]\n        \n        D_prime_N = D_N - L_N @ U_prime[N-2]\n        f_rhs_N = f[N-1] - L_N @ f_prime[N-2]\n        \n        solution_vecs = [None] * N\n        solution_vecs[N-1] = np.linalg.solve(D_prime_N, f_rhs_N)\n\n        # ----- Backward Substitution Phase -----\n        # For i = N-1 down to 1 (Python indices N-2 down to 0)\n        for i in range(N - 2, -1, -1):\n            # x_i = f'_i - U'_i * x_{i+1}\n            solution_vecs[i] = f_prime[i] - U_prime[i] @ solution_vecs[i+1]\n\n        # Flatten the list of solution vectors and round each component\n        flat_solution = np.concatenate(solution_vecs).ravel()\n        rounded_solution = [round(val, 8) for val in flat_solution]\n        \n        return rounded_solution\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1\n        {\n            \"N\": 3,\n            \"D\": [[[4, 1], [1, 3]], [[3, 0.5], [0.5, 4]], [[2.5, 0.4], [0.4, 2.0]]],\n            \"U\": [[[1, 0], [0, 1]], [[-1, 0.2], [0.4, 0.5]]],\n            \"L\": [[[0.5, -0.2], [0.1, 0.3]], [[-0.3, 0.4], [0.2, 0.1]]],\n            \"f\": [[1, 2], [0, -1], [3, 1]]\n        },\n        # Test Case 2\n        {\n            \"N\": 1,\n            \"D\": [[[2, -1], [-1, 2]]],\n            \"U\": [],\n            \"L\": [],\n            \"f\": [[1, 0]]\n        },\n        # Test Case 3\n        {\n            \"N\": 4,\n            \"D\": [[[3, 0.2], [0.2, 2.5]], [[2.8, -0.1], [-0.1, 3.2]], [[3.0, 0.4], [0.4, 2.2]], [[2.6, -0.3], [-0.3, 2.9]]],\n            \"U\": [[[0.1, -0.2], [0.3, 0.0]], [[0.0, 0.25], [-0.3, 0.15]], [[-0.2, 0.1], [0.25, -0.05]]],\n            \"L\": [[[-0.05, 0.2], [0.1, -0.1]], [[0.2, -0.1], [0.05, 0.3]], [[-0.1, 0.0], [0.15, -0.2]]],\n            \"f\": [[0.5, -1.0], [1.5, 2.0], [-0.5, 0.25], [0.0, -1.0]]\n        },\n        # Test Case 4\n        {\n            \"N\": 3,\n            \"D\": [[[1e-3, 0.0], [0.0, 1.0]], [[1.0, 0.9999], [0.9999, 1.0]], [[1e-2, 0.0], [0.0, 2.0]]],\n            \"U\": [[[0.2, -0.1], [0.1, 0.0]], [[-0.1, 0.0], [0.0, 0.1]]],\n            \"L\": [[[0.0, 0.1], [0.05, 0.0]], [[0.0, -0.05], [0.02, 0.0]]],\n            \"f\": [[1.0, 0.0], [-1.0, 1.0], [0.5, -0.5]]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        N = case[\"N\"]\n        D_mats = [np.array(m) for m in case[\"D\"]]\n        U_mats = [np.array(m) for m in case[\"U\"]]\n        L_mats = [np.array(m) for m in case[\"L\"]]\n        f_vecs = [np.array(v) for v in case[\"f\"]]\n        \n        result = solve_block_tridiagonal(N, D_mats, U_mats, L_mats, f_vecs)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    formatted_results = ','.join([str(r).replace(' ', '') for r in results])\n    print(f\"[{formatted_results}]\")\n\nsolve()\n\n```"
        }
    ]
}