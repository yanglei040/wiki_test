{
    "hands_on_practices": [
        {
            "introduction": "在计算科学中，我们常常面临策略选择。当需要求解像 $A^k x = b$ 这样的方程组时，一个直接的想法是先计算出矩阵 $A^k$，然后再求解。但更聪明的办法是否存在呢？这个练习将通过浮点运算数的精确分析，揭示重用矩阵 $A$ 的 $LU$ 分解所带来的巨大计算优势，这是高效数值算法的核心思想。",
            "id": "3275805",
            "problem": "设 $A \\in \\mathbb{R}^{n \\times n}$ 是一个没有特殊结构的稠密非奇异矩阵，且 $k \\geq 2$ 是一个整数。对于一个给定的右端项 $b \\in \\mathbb{R}^{n}$，我们希望计算满足 $A^{k} x = b$ 的向量 $x$。考虑以下两种策略：\n\n(a) 通过顺序的稠密矩阵乘法显式地构造出 $A^{k}$，然后通过计算 $A^{k}$ 的LU（Lower-Upper）分解并进行前向和后向代换来求解线性系统 $A^{k} x = b$。\n\n(b) 计算 $A$ 的单次LU（Lower-Upper）分解，然后通过使用重用的因子进行前向和后向代换，求解 $k$ 个线性系统序列 $A y_{1} = b$, $A y_{2} = y_{1}$, $\\dots$, $A y_{k} = y_{k-1}$，从而得到 $x = y_{k}$。\n\n使用以下公认的稠密算法操作计数作为基本依据：一个稠密的 $n \\times n$ 矩阵-矩阵乘法需要 $2 n^{3}$ 次浮点运算，一个带部分主元法的稠密LU（Lower-Upper）分解需要 $\\frac{2}{3} n^{3}$ 次浮点运算，以及针对单个右端项的三角求解（无论是使用 $L$ 进行前向代换还是使用 $U$ 进行后向代换）需要 $n^{2}$ 次浮点运算。请推导策略 (a) 和 (b) 的总浮点运算次数的表达式，然后计算策略 (a) 的总运算次数与策略 (b) 的总运算次数之比，并表示为关于 $n$ 和 $k$ 的封闭形式表达式。忽略所述之外的所有低阶项，并视置换应用的开销为可忽略不计。\n\n将您的最终答案表示为一个关于 $n$ 和 $k$ 的单一简化解析表达式。",
            "solution": "该问题要求对求解线性系统 $A^{k} x = b$ 的两种不同策略的计算成本（以浮点运算次数，即 flops 衡量）进行比较分析。设 $C_a$ 和 $C_b$ 分别表示策略 (a) 和 (b) 的总浮点运算次数。此分析将基于所提供的基本稠密矩阵运算的操作计数。\n\n我们首先分析策略 (a)。该策略包括两个主要阶段：显式地构造矩阵 $A^{k}$，然后求解得到的线性系统。\n\n阶段 1(a)：构造 $A^{k}$。\n矩阵 $A^{k}$ 是通过执行 $k-1$ 次顺序的矩阵-矩阵乘法计算得出的：$A^2 = A \\cdot A$, $A^3 = A^2 \\cdot A$, ..., $A^k = A^{k-1} \\cdot A$。每次乘法都涉及两个稠密的 $n \\times n$ 矩阵。\n单次稠密 $n \\times n$ 矩阵-矩阵乘法的成本为 $2n^3$ 次浮点运算。\n由于有 $k-1$ 次这样的乘法，该阶段的总成本为：\n$$C_{1,a} = (k-1) \\times (2n^3) = (2k-2)n^3 \\text{ flops.}$$\n\n阶段 2(a)：求解系统 $A^{k} x = b$。\n设 $B = A^k$。需要求解的系统是 $B x = b$。指定的方法是LU分解，然后进行前向和后向代换。\n首先，计算稠密 $n \\times n$ 矩阵 $B$ 的LU分解。其成本为 $\\frac{2}{3}n^3$ 次浮点运算。\n接下来，通过两步求解该系统：\n1.  求解 $L y = b$ 以得到 $y$ (前向代换)。对单个右端项进行三角求解的成本为 $n^2$ 次浮点运算。\n2.  求解 $U x = y$ 以得到 $x$ (后向代換)。这也需要 $n^2$ 次浮点运算。\n此阶段的总成本是分解和两次代换的成本之和：\n$$C_{2,a} = \\frac{2}{3}n^3 + n^2 + n^2 = \\frac{2}{3}n^3 + 2n^2 \\text{ flops.}$$\n\n策略 (a) 的总运算次数为这两个阶段的成本之和：\n$$C_a(n,k) = C_{1,a} + C_{2,a} = (2k-2)n^3 + \\left(\\frac{2}{3}n^3 + 2n^2\\right)$$\n$$C_a(n,k) = \\left(2k - 2 + \\frac{2}{3}\\right)n^3 + 2n^2 = \\left(2k - \\frac{4}{3}\\right)n^3 + 2n^2.$$\n\n接下来，我们分析策略 (b)。该策略避免了构造 $A^k$，而是转而求解一个包含 $k$ 个线性系统的序列。方程 $A^k x = b$ 可以写成 $A(A(...A x)) = b$。这提示我们可以求解一个系统序列。设 $y_1, y_2, \\dots, y_k$ 为中间向量。\n- 令 $A y_1 = b$。\n- 令 $A y_2 = y_1$。将第一个方程代入此式，得到 $A(A y_2) = A^2 y_2 = b$。\n- 继续这个过程，我们定义 $A y_i = y_{i-1}$，其中 $i=2, \\dots, k$。\n最后一个系统是 $A y_k = y_{k-1}$，这意味着 $A^k y_k = b$。因此，解为 $x = y_k$。\n\n阶段 1(b)：$A$ 的LU分解。\n此操作仅在开始时执行一次。其成本是稠密 $n \\times n$ 矩阵LU分解的标准成本：\n$$C_{1,b} = \\frac{2}{3}n^3 \\text{ flops.}$$\n\n阶段 2(b)：求解 $k$ 个顺序线性系统。\n需要求解的 $k$ 个系统是 $A y_1 = b$ 和 $A y_i = y_{i-1}$ (其中 $i=2, \\dots, k$)。\n对于每个系统，都会重用 $A$ 的LU因子。使用已有的因子 $L$ 和 $U$ 求解一个这样的系统 $A z = w$ 需要一次前向代换（$L v = w$，成本 $n^2$）和一次后向代換（$U z = v$，成本 $n^2$）。\n求解单个系统的成本是 $n^2 + n^2 = 2n^2$ 次浮点运算。\n由于需要求解 $k$ 个这样的系统，该阶段的总成本为：\n$$C_{2,b} = k \\times (2n^2) = 2kn^2 \\text{ flops.}$$\n\n策略 (b) 的总运算次数为初始分解和 $k$ 次求解的成本之和：\n$$C_b(n,k) = C_{1,b} + C_{2,b} = \\frac{2}{3}n^3 + 2kn^2.$$\n\n最后，题目要求我们计算策略 (a) 的总运算次数与策略 (b) 的总运算次数之比。\n$$\\text{比率} = \\frac{C_a(n,k)}{C_b(n,k)} = \\frac{\\left(2k - \\frac{4}{3}\\right)n^3 + 2n^2}{\\frac{2}{3}n^3 + 2kn^2}.$$\n为了简化此表达式，由于 $n \\neq 0$，我们可以从分子和分母中提出公因数 $n^2$：\n$$\\text{比率} = \\frac{n^2 \\left[ \\left(2k - \\frac{4}{3}\\right)n + 2 \\right]}{n^2 \\left[ \\frac{2}{3}n + 2k \\right]} = \\frac{\\left(2k - \\frac{4}{3}\\right)n + 2}{\\frac{2}{3}n + 2k}.$$\n为了消除分数，我们将分子和分母同时乘以 $3$：\n$$\\text{比率} = \\frac{3 \\left[ \\left(2k - \\frac{4}{3}\\right)n + 2 \\right]}{3 \\left[ \\frac{2}{3}n + 2k \\right]} = \\frac{(6k - 4)n + 6}{2n + 6k}.$$\n我们可以从分子和分母中提出公因数 $2$：\n$$\\text{比率} = \\frac{2 \\left[ (3k - 2)n + 3 \\right]}{2 [n + 3k]} = \\frac{(3k - 2)n + 3}{n + 3k}.$$\n这就是表示成本之比的最终简化解析表达式。",
            "answer": "$$\n\\boxed{\\frac{(3k - 2)n + 3}{n + 3k}}\n$$"
        },
        {
            "introduction": "通用的 $LU$ 分解算法固然强大，但在物理和工程领域，许多现实世界的问题会产生具有特殊结构的矩阵。本练习将探讨一种常见的特殊矩阵——三对角矩阵。你将亲手推导出一个高度优化的、$O(n)$ 时间复杂度的 $LU$ 分解算法（即托马斯算法），并应用它解决一个具体问题，这是一个将通用理论特殊化以获得极致效率的经典范例。",
            "id": "3275855",
            "problem": "考虑一个 $n \\times n$ 的三对角矩阵 $A$，其下对角线元素为 $\\{a_i\\}_{i=2}^{n}$，主对角线元素为 $\\{b_i\\}_{i=1}^{n}$，上对角线元素为 $\\{c_i\\}_{i=1}^{n-1}$，因此有 $A_{i,i}=b_i$，$A_{i+1,i}=a_{i+1}$，以及 $A_{i,i+1}=c_i$。仅从下三角-上三角（LU）分解的定义和通过初等行变换进行高斯消元的机理出发，为满足 $A=LU$ 的单位下三角矩阵 $L$ 和上三角矩阵 $U$ 的元素推导显式标量递推关系。你的推导必须表明，每次索引更新都使用常数数量的算术运算，从而得到一个 $n$ 阶（大O表示为 $O(n)$）的算法。假设 $A$ 是严格对角占优的，因此不需要行主元选择。\n\n然后，应用你推导出的递推关系来求解特定 $5 \\times 5$ 三对角矩阵的线性系统 $A \\boldsymbol{x}=\\boldsymbol{f}$\n$$\nA=\\begin{pmatrix}\n4 & -1 & 0 & 0 & 0 \\\\\n-1 & 4 & -1 & 0 & 0 \\\\\n0 & -1 & 4 & -1 & 0 \\\\\n0 & 0 & -1 & 4 & -1 \\\\\n0 & 0 & 0 & -1 & 4\n\\end{pmatrix},\n$$\n其右端向量为\n$$\n\\boldsymbol{f}=\\begin{pmatrix}1 \\\\ 2 \\\\ 3 \\\\ 2 \\\\ 1\\end{pmatrix}.\n$$\n以精确有理数形式报告解 $\\boldsymbol{x}$ 的第五个分量 $x_5$ 的值。不要四舍五入；以有理数形式提供精确值。",
            "solution": "该问题包括两部分。第一部分，推导三对角矩阵LU分解的一般递推公式。第二部分，应用这些公式求解一个特定的线性系统。\n\n**第一部分：递推关系的推导**\n\n设 $A$ 是一个 $n \\times n$ 的三对角矩阵，其下对角线元素为 $\\{a_i\\}_{i=2}^{n}$，主对角线元素为 $\\{b_i\\}_{i=1}^{n}$，上对角线元素为 $\\{c_i\\}_{i=1}^{n-1}$。\n$$\nA = \\begin{pmatrix}\nb_1 & c_1 & 0 & \\dots & 0 \\\\\na_2 & b_2 & c_2 & \\ddots & \\vdots \\\\\n0 & a_3 & b_3 & \\ddots & 0 \\\\\n\\vdots & \\ddots & \\ddots & \\ddots & c_{n-1} \\\\\n0 & \\dots & 0 & a_n & b_n\n\\end{pmatrix}\n$$\n我们寻求一个 LU 分解 $A = LU$，其中 $L$ 是单位下三角矩阵，$U$ 是上三角矩阵。问题陈述 $A$ 是严格对角占优的，这确保了 LU 分解的存在而无需进行主元选择。$A$ 的三对角结构导致 $L$ 和 $U$（在其主对角线之外）都具有双对角结构。\n\n设 $L$ 是一个单位下双对角矩阵，$U$ 是一个上双对角矩阵：\n$$\nL = \\begin{pmatrix}\n1 & 0 & 0 & \\dots & 0 \\\\\nl_2 & 1 & 0 & \\ddots & \\vdots \\\\\n0 & l_3 & 1 & \\ddots & 0 \\\\\n\\vdots & \\ddots & \\ddots & \\ddots & 0 \\\\\n0 & \\dots & 0 & l_n & 1\n\\end{pmatrix}, \\quad\nU = \\begin{pmatrix}\nu_1 & d_1 & 0 & \\dots & 0 \\\\\n0 & u_2 & d_2 & \\ddots & \\vdots \\\\\n0 & 0 & u_3 & \\ddots & 0 \\\\\n\\vdots & \\ddots & \\ddots & \\ddots & d_{n-1} \\\\\n0 & \\dots & 0 & 0 & u_n\n\\end{pmatrix}\n$$\n这里，$L$ 是单位下三角矩阵，其非零元素为 $L_{i,i}=1$ 和 $L_{i,i-1}=l_i$。$U$ 是上三角矩阵，其非零元素为 $U_{i,i}=u_i$ 和 $U_{i,i+1}=d_i$。\n\n根据 LU 分解的定义，我们将 $A$ 的元素与乘积 $LU$ 的元素相等：\n$$\nA = LU = \\begin{pmatrix}\n1 & 0 & \\dots \\\\\nl_2 & 1 & \\\\\n\\vdots & \\ddots & \\ddots\n\\end{pmatrix}\n\\begin{pmatrix}\nu_1 & d_1 & 0 & \\dots \\\\\n0 & u_2 & d_2 & \\\\\n\\vdots &  \\ddots & \\ddots\n\\end{pmatrix}\n=\n\\begin{pmatrix}\nu_1 & d_1 & 0 & \\dots \\\\\nl_2 u_1 & l_2 d_1 + u_2 & d_2 & \\\\\n0 & l_3 u_2 & l_3 d_2 + u_3 & \\ddots \\\\\n\\vdots &  \\ddots & \\ddots\n\\end{pmatrix}\n$$\n逐行比较 $A$ 和 $LU$ 的元素：\n\n对于第一行 ($i=1$)：\n- 主对角线：$A_{1,1} = b_1 = (LU)_{1,1} = u_1$。所以，$u_1 = b_1$。\n- 上对角线：$A_{1,2} = c_1 = (LU)_{1,2} = d_1$。所以，$d_1 = c_1$。\n\n对于之后的每一行 $i=2, \\dots, n-1$：\n- 下对角线：$A_{i,i-1} = a_i = (LU)_{i,i-1} = l_i u_{i-1}$。这给出 $l_i = \\frac{a_i}{u_{i-1}}$。\n- 主对角线：$A_{i,i} = b_i = (LU)_{i,i} = l_i d_{i-1} + u_i$。这给出 $u_i = b_i - l_i d_{i-1}$。\n- 上对角线：$A_{i,i+1} = c_i = (LU)_{i,i+1} = d_i$。所以，$d_i = c_i$。\n\n对于最后一行 ($i=n$)：\n- 下对角线：$A_{n,n-1} = a_n = (LU)_{n,n-1} = l_n u_{n-1}$。这给出 $l_n = \\frac{a_n}{u_{n-1}}$。\n- 主对角线：$A_{n,n} = b_n = (LU)_{n,n} = l_n d_{n-1} + u_n$。这给出 $u_n = b_n - l_n d_{n-1}$。\n\n综合这些，我们注意到对于所有 $i=1, \\dots, n-1$ 都有 $d_i = c_i$。我们可以写出完整的递推关系集：\n\n1. 对 $i=1$ 进行初始化：\n   $u_1 = b_1$\n\n2. 对 $i=2, 3, \\dots, n$ 计算：\n   $l_i = \\frac{a_i}{u_{i-1}}$\n   $u_i = b_i - l_i c_{i-1}$\n\n这被称为三对角矩阵的 Crout 分解算法。为了找出 $L$ 和 $U$ 的所有元素，我们从 $i=2$ 迭代到 $n$。在每次迭代中，我们计算一个 $l_i$ 值（一次除法）和一个 $u_i$ 值（一次乘法和一次减法）。每次迭代的算术运算次数是常数（与 $n$ 无关）。由于循环运行 $n-1$ 次，总运算次数与 $n-1$ 成正比。因此，该算法的时间复杂度为 $O(n)$。\n\n**第二部分：对特定系统的应用**\n\n我们需要为特定的 $5 \\times 5$ 系统求解 $A \\boldsymbol{x}=\\boldsymbol{f}$。\n矩阵 $A$ 给出了参数：$n=5$，对所有 $i$ 有 $b_i = 4$，对 $i \\geq 2$ 有 $a_i = -1$，对 $i < 5$ 有 $c_i = -1$。向量 $\\boldsymbol{f}$ 的分量为 $f_1=1, f_2=2, f_3=3, f_4=2, f_5=1$。\n\n首先，我们使用推导出的递推关系来求 $A$ 的 LU 分解。\n- $i=1$:\n  $u_1 = b_1 = 4$\n- $i=2$:\n  $l_2 = \\frac{a_2}{u_1} = \\frac{-1}{4}$\n  $u_2 = b_2 - l_2 c_1 = 4 - (-\\frac{1}{4})(-1) = 4 - \\frac{1}{4} = \\frac{15}{4}$\n- $i=3$:\n  $l_3 = \\frac{a_3}{u_2} = \\frac{-1}{15/4} = -\\frac{4}{15}$\n  $u_3 = b_3 - l_3 c_2 = 4 - (-\\frac{4}{15})(-1) = 4 - \\frac{4}{15} = \\frac{56}{15}$\n- $i=4$:\n  $l_4 = \\frac{a_4}{u_3} = \\frac{-1}{56/15} = -\\frac{15}{56}$\n  $u_4 = b_4 - l_4 c_3 = 4 - (-\\frac{15}{56})(-1) = 4 - \\frac{15}{56} = \\frac{224-15}{56} = \\frac{209}{56}$\n- $i=5$:\n  $l_5 = \\frac{a_5}{u_4} = \\frac{-1}{209/56} = -\\frac{56}{209}$\n  $u_5 = b_5 - l_5 c_4 = 4 - (-\\frac{56}{209})(-1) = 4 - \\frac{56}{209} = \\frac{836-56}{209} = \\frac{780}{209}$\n\n方程 $A\\boldsymbol{x}=\\boldsymbol{f}$ 等价于 $LU\\boldsymbol{x}=\\boldsymbol{f}$。我们分两步求解：\n1. 求解 $L\\boldsymbol{y}=\\boldsymbol{f}$ 以得到 $\\boldsymbol{y}$（向前代入）。\n2. 求解 $U\\boldsymbol{x}=\\boldsymbol{y}$ 以得到 $\\boldsymbol{x}$（向后代入）。\n\n步骤1：向前代入求 $\\boldsymbol{y}$。\n系统 $L\\boldsymbol{y}=\\boldsymbol{f}$ 为：\n$y_1 = f_1$\n对于 $i=2, \\dots, 5$，$l_i y_{i-1} + y_i = f_i$，这意味着 $y_i = f_i - l_i y_{i-1}$。\n- $y_1 = f_1 = 1$\n- $y_2 = f_2 - l_2 y_1 = 2 - (-\\frac{1}{4})(1) = 2 + \\frac{1}{4} = \\frac{9}{4}$\n- $y_3 = f_3 - l_3 y_2 = 3 - (-\\frac{4}{15})(\\frac{9}{4}) = 3 + \\frac{9}{15} = 3 + \\frac{3}{5} = \\frac{18}{5}$\n- $y_4 = f_4 - l_4 y_3 = 2 - (-\\frac{15}{56})(\\frac{18}{5}) = 2 + \\frac{15 \\cdot 18}{56 \\cdot 5} = 2 + \\frac{3 \\cdot 18}{56} = 2 + \\frac{3 \\cdot 9}{28} = 2 + \\frac{27}{28} = \\frac{56+27}{28} = \\frac{83}{28}$\n- $y_5 = f_5 - l_5 y_4 = 1 - (-\\frac{56}{209})(\\frac{83}{28}) = 1 + \\frac{56 \\cdot 83}{209 \\cdot 28} = 1 + \\frac{2 \\cdot 83}{209} = 1 + \\frac{166}{209} = \\frac{209+166}{209} = \\frac{375}{209}$\n\n步骤2：向后代入求 $\\boldsymbol{x}$。\n系统 $U\\boldsymbol{x}=\\boldsymbol{y}$ 只需求解 $x_5$。该系统的最后一个方程是 $u_5 x_5 = y_5$。\n- $\\frac{780}{209} x_5 = \\frac{375}{209}$\n- $x_5 = \\frac{375/209}{780/209} = \\frac{375}{780}$\n\n最后，我们化简 $x_5$ 的分数：\n$$\nx_5 = \\frac{375}{780} = \\frac{375 \\div 5}{780 \\div 5} = \\frac{75}{156} = \\frac{75 \\div 3}{156 \\div 3} = \\frac{25}{52}\n$$\n数字 $25=5^2$ 和 $52=4 \\times 13$ 没有公因数，所以该分数已是最简形式。",
            "answer": "$$\n\\boxed{\\frac{25}{52}}\n$$"
        },
        {
            "introduction": "我们如何将求解 $AX=I$ 的理论概念转化为一个高效的算法，同时避免因计算整个逆矩阵而浪费计算资源？这个编程练习将挑战你利用已知的 $LU$ 分解因子，实现一个只计算 $A^{-1}$ 对角线元素的实用程序。这是对你是否真正掌握前向替换、后向替换以及逆矩阵按列定义这些核心概念的绝佳考验。",
            "id": "3275751",
            "problem": "给定一个数学任务，要求利用一个非奇异方阵的LU分解来计算该方阵逆矩阵的对角线元素。其基本原理是，一个方阵 $A$ 允许进行带部分主元法的LU分解（Lower-Upper factorization），写作 $PA = LU$。其中，$P$ 是由行交换产生的置换矩阵，$L$ 是单位下三角矩阵，$U$ 是上三角矩阵。三角系统 $Lx = b$ 和 $Uy = x$ 分别通过前向替换和反向替换求解。当逆矩阵 $A^{-1}$ 存在时，它可以表示为LU因子和 $P$ 的形式，但在这里，我们不需要也不希望显式计算 $A^{-1}$。\n\n您的任务是推导并实现一个算法，该算法在给定一个方阵 $A$ 的带部分主元法的LU分解 $PA = LU$ 所产生的 $L$、$U$ 以及置换 $P$ 的表示形式后，通过使用精心选择的右侧向量进行前向和反向替换，高效地计算出 $A^{-1}$ 的对角线元素。您不得构建完整的 $A$ 的逆矩阵。该算法必须基于 $PA = LU$ 和三角系统求解的性质从基本原理出发进行论证。\n\n在一个完整的、可运行的程序中实现以下步骤：\n- 对给定矩阵 $A$ 执行带部分主元的高斯消元法，以计算 $P$、$L$ 和 $U$，其中 $L$ 的对角线为单位元素，$U$ 为上三角矩阵。用一个置换向量 $p$ 来表示 $P$，其中 $p_i$ 记录了 $A$ 的原始行中出现在 $PA$ 的第 $i$ 行的是哪一行。必须一致地处理对 $P$ 的解释。\n- 仅使用 $L$、$U$ 和 $p$，推导并实现一个例程，用于计算 $A^{-1}$ 的对角线元素，而不形成 $A^{-1}$ 本身。您的例程必须使用前向替换解 $Lx = e_j$ 和反向替换解 $Uy = x$，其中 $e_j$ 是根据 $P$ 选择的标准基向量。必须正确提取第 $i$ 个对角线元素的结果。\n- 为通用的稠密三角矩阵实现数值稳定的前向和反向替换。\n- 为每个测试矩阵返回一个浮点数列表，其值等于 $A^{-1}$ 的对角线元素。不包含任何物理单位。不涉及角度单位。所有数值均表示为十进制浮点数。\n\n使用以下测试矩阵套件来检验算法：\n- 测试用例 1（一般的非奇异 $3 \\times 3$ 矩阵）：\n$$\nA_1 = \\begin{bmatrix}\n4 & 1 & -2 \\\\\n1 & 3 & 0 \\\\\n-2 & 0 & 5\n\\end{bmatrix}.\n$$\n- 测试用例 2（对角矩阵，边界情况，$3 \\times 3$）：\n$$\nA_2 = \\begin{bmatrix}\n1 & 0 & 0 \\\\\n0 & 2 & 0 \\\\\n0 & 0 & 3\n\\end{bmatrix}.\n$$\n- 测试用例 3（需要主元 pivoting，$3 \\times 3$）：\n$$\nA_3 = \\begin{bmatrix}\n0 & 1 & 2 \\\\\n1 & 0 & 3 \\\\\n4 & 5 & 6\n\\end{bmatrix}.\n$$\n- 测试用例 4（边界情况，$1 \\times 1$）：\n$$\nA_4 = \\begin{bmatrix}\n7\n\\end{bmatrix}.\n$$\n- 测试用例 5（病态但可逆，$3 \\times 3$）：\n$$\nA_5 = \\begin{bmatrix}\n10^{-8} & 1 & 0 \\\\\n0 & 10^{-8} & 1 \\\\\n1 & 0 & 10^{-8}\n\\end{bmatrix}.\n$$\n\n您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个元素对应一个测试用例，并且本身是该用例的 $A^{-1}$ 对角线元素的列表。例如，输出格式应为 $[[d_{11}^{(1)},d_{22}^{(1)},d_{33}^{(1)}],[d_{11}^{(2)},d_{22}^{(2)},d_{33}^{(2)}],\\dots]$，列表的大小根据每个矩阵进行适当调整。输出是浮点数列表。",
            "solution": "本问题的核心是高效计算矩阵逆 $(A^{-1})_{ii}$ 的对角线元素，而无需显式计算完整的逆矩阵 $A^{-1}$。该方法依赖于矩阵 $A$ 的带部分主元法的LU分解，表示为 $PA = LU$。\n\n设 $A$ 是一个 $n \\times n$ 的非奇异方阵。其逆矩阵 $A^{-1}$ 是满足 $AA^{-1} = I$ 的唯一矩阵，其中 $I$ 是单位矩阵。设 $A^{-1}$ 的列向量为 $X_j$，$I$ 的列向量为 $e_j$（标准基向量），其中 $j \\in \\{0, 1, \\dots, n-1\\}$。根据矩阵乘法的定义，逆矩阵的第 $j$ 列 $X_j$ 是线性方程组的解：\n$$AX_j = e_j$$\n$A^{-1}$ 的对角线元素是 $(A^{-1})_{jj}$。元素 $(A^{-1})_{jj}$ 是列向量 $X_j$ 的第 $j$ 个分量。因此，要找到 $(A^{-1})_{jj}$，我们必须计算方程组 $AX_j = e_j$ 的解的第 $j$ 个分量。\n\n问题提供了带部分主元法的LU分解，$PA = LU$。这里，$P$ 是一个置换矩阵，$L$ 是一个单位下三角矩阵（对角线上元素为1），$U$ 是一个上三角矩阵。我们可以利用这个分解来高效地求解方程组 $AX_j = e_j$。\n\n首先，我们在方程两边左乘 $P$：\n$$PAX_j = Pe_j$$\n代入 $PA = LU$：\n$$LUX_j = Pe_j$$\n这个矩阵方程可以分解为两个更简单的三角方程组来求解。设 $Y_j = UX_j$。那么第一个方程组是：\n$$LY_j = Pe_j$$\n这个方程组通过前向替换求解中间向量 $Y_j$。一旦 $Y_j$ 已知，第二个方程组是：\n$$UX_j = Y_j$$\n这个方程组通过反向替换求解我们需要的向量 $X_j$。\n\n第一个方程组的右侧项 $Pe_j$ 需要仔细解释。置换矩阵 $P$ 由一个长度为 $n$ 的置换向量 $p$ 表示，其中 $p_i$ 是 $A$ 的原始行中被移至置换后矩阵 $PA$ 的第 $i$ 行的索引。即 $(PA)_{i,:} = A_{p_i,:}$。当 $P$ 作用于标准基向量 $e_j$ 时，其结果 $Pe_j$ 是一个列向量，该向量是标准基向量 $e_k$，其中 $k$ 是满足 $p_k=j$ 的索引。换言之，$Pe_j$ 是一个在第 $k$ 行（其中原始的第 $j$ 行被移动到该行）为1，其他地方为0的向量。因此，为了求解 $AX_j = e_j$，我们实际上是求解 $LUX_j = e_k$。\n\n计算 $A^{-1}$ 对角线的完整算法如下：\n\n1.  **分解**：使用带部分主元的高斯消元法计算分解 $PA=LU$。这将得到矩阵 $L$ 和 $U$ 以及置换向量 $p$。\n2.  **逆置换**：计算逆置换向量 $p_{inv}$，使得 $p_{inv}[j]$ 给出满足 $p[k]=j$ 的索引 $k$。\n3.  **对每个对角线元素进行迭代**：对于从 $0$ 到 $n-1$ 的每个索引 $j$：\n    a.  **确定右侧项**：确定行索引 $k = p_{inv}[j]$。方程组 $LY_j = Pe_j$ 的右侧项是基向量 $e_k$。\n    b.  **前向替换**：求解单位下三角方程组 $LY_j = e_k$，得到向量 $Y_j$。由于 $L$ 的对角线为单位元素，这由下式给出：\n        $$ (Y_j)_i = (e_k)_i - \\sum_{m=0}^{i-1} L_{im} (Y_j)_m $$\n    c.  **反向替换**：求解上三角方程组 $UX_j = Y_j$，得到向量 $X_j$。这由下式给出：\n        $$ (X_j)_i = \\frac{1}{U_{ii}} \\left( (Y_j)_i - \\sum_{m=i+1}^{n-1} U_{im} (X_j)_m \\right) $$\n    d.  **提取对角线元素**：我们需要的对角线元素 $(A^{-1})_{jj}$ 是计算出的解向量的第 $j$ 个分量，即 $(X_j)_j$。\n\n这个过程比计算完整的逆矩阵更高效，因为它只计算了 $A^{-1}$ 中必需的列（并且只计算了后续计算对角线元素所需的那些列的分量）。具体来说，对于每个 $j$，我们执行一次前向和一次反向替换，这是一个复杂度为 $O(n^2)$ 的操作。对所有 $n$ 个对角线元素重复此过程，总复杂度为 $O(n^3)$，但其常数因子比完全矩阵求逆小，并且内存需求显著降低，因为从不存储完整的逆矩阵。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef forward_substitution(L, b):\n    \"\"\"\n    Solves the system Lx = b for x, where L is a unit lower triangular matrix.\n    Since L is unit triangular, L[i, i] is always 1.\n    \"\"\"\n    n = L.shape[0]\n    x = np.zeros(n, dtype=np.float64)\n    for i in range(n):\n        # x[i] = (b[i] - L[i, :i] @ x[:i]) / L[i, i]\n        # Since L is unit triangular, L[i, i] = 1\n        x[i] = b[i] - np.dot(L[i, :i], x[:i])\n    return x\n\ndef backward_substitution(U, y):\n    \"\"\"\n    Solves the system Ux = y for x, where U is an upper triangular matrix.\n    \"\"\"\n    n = U.shape[0]\n    x = np.zeros(n, dtype=np.float64)\n    for i in range(n - 1, -1, -1):\n        if U[i, i] == 0:\n            # Should not happen for a nonsingular matrix\n            raise ValueError(\"Matrix is singular or near-singular.\")\n        x[i] = (y[i] - np.dot(U[i, i+1:], x[i+1:])) / U[i, i]\n    return x\n\ndef lu_decomposition_pivoting(A):\n    \"\"\"\n    Computes the PA = LU factorization of a square matrix A.\n    \n    Args:\n        A (np.ndarray): The input square matrix.\n    \n    Returns:\n        L (np.ndarray): The unit lower triangular matrix.\n        U (np.ndarray): The upper triangular matrix.\n        p (np.ndarray): The permutation vector. p[i] gives the original row index\n                          that is in row i of the permuted matrix.\n    \"\"\"\n    n = A.shape[0]\n    LU = A.copy().astype(np.float64)\n    p = np.arange(n)\n    \n    for k in range(n - 1):\n        # Find pivot: row with the largest element in column k (from k downwards)\n        pivot_row = k + np.argmax(np.abs(LU[k:, k]))\n        \n        # Swap rows if necessary\n        if pivot_row != k:\n            LU[[k, pivot_row], :] = LU[[pivot_row, k], :]\n            p[[k, pivot_row]] = p[[pivot_row, k]]\n            \n        # Check for singularity\n        if LU[k, k] == 0:\n            # This indicates the matrix is singular, as even with pivoting, a zero pivot was found.\n            # For the given test cases, this should not be reached.\n            continue\n            \n        # Compute multipliers and store them in the lower part of LU\n        factors = LU[k+1:, k] / LU[k, k]\n        LU[k+1:, k] = factors\n        \n        # Update the trailing submatrix\n        LU[k+1:, k+1:] -= np.outer(factors, LU[k, k+1:])\n        \n    L = np.tril(LU, k=-1) + np.eye(n)\n    U = np.triu(LU)\n    \n    return L, U, p\n\ndef compute_diag_inverse(A):\n    \"\"\"\n    Computes the diagonal entries of the inverse of matrix A.\n    \"\"\"\n    n = A.shape[0]\n    \n    # Handle 1x1 case explicitly for simplicity\n    if n == 1:\n        return [1.0 / A[0, 0]]\n        \n    try:\n        L, U, p = lu_decomposition_pivoting(A)\n    except ValueError as e:\n        # Handle cases flagged as singular during factorization\n        print(f\"Error during LU decomposition: {e}\")\n        return []\n\n    # Create the inverse permutation vector p_inv\n    # p_inv[j] = k means that original row j is now in permuted row k.\n    p_inv = np.argsort(p)\n    \n    diag_entries = []\n    \n    for j in range(n):\n        # To find (A_inv)_jj, we solve A * X_j = e_j and take the j-th component of X_j.\n        # This is equivalent to solving LUX_j = P*e_j\n        # P*e_j is the basis vector e_k where p[k] = j.\n        \n        k = p_inv[j]\n        e_k = np.zeros(n)\n        e_k[k] = 1.0\n        \n        # 1. Solve L * y = e_k for y (forward substitution)\n        y = forward_substitution(L, e_k)\n        \n        # 2. Solve U * x = y for x (backward substitution)\n        x = backward_substitution(U, y)\n        \n        # x is the j-th column of A_inv. We need the j-th component.\n        diag_entries.append(x[j])\n        \n    return diag_entries\n\ndef solve():\n    \"\"\"\n    Main solver function that processes test cases.\n    \"\"\"\n    test_cases = [\n        np.array([[4, 1, -2], [1, 3, 0], [-2, 0, 5]]),\n        np.array([[1, 0, 0], [0, 2, 0], [0, 0, 3]]),\n        np.array([[0, 1, 2], [1, 0, 3], [4, 5, 6]]),\n        np.array([[7]]),\n        np.array([[1e-8, 1, 0], [0, 1e-8, 1], [1, 0, 1e-8]])\n    ]\n    \n    # Calculate the diagonal of the inverse for each test case\n    results = [compute_diag_inverse(A) for A in test_cases]\n    \n    # Format the output as specified\n    output_str = \"[\" + \",\".join([str(res) for res in results]) + \"]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}