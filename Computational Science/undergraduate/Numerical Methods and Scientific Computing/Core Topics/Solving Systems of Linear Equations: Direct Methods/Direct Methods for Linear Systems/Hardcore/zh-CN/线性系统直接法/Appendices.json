{
    "hands_on_practices": [
        {
            "introduction": "对于对称正定 (Symmetric Positive Definite, SPD) 这一特殊类别的矩阵，Cholesky 分解提供了一种更为高效和数值稳定的求解方法。本练习将数值线性代数与统计学联系起来，要求您对一个在数据分析中常见的相关系数矩阵进行 Cholesky 分解。此实践不仅锻炼您的计算能力，更重要的是，它强调了在使用特定算法前，必须先验证其理论前提——即检验矩阵的对称正定性。",
            "id": "3222494",
            "problem": "考虑三个联合分布的随机变量 $X_{1}$、$X_{2}$ 和 $X_{3}$，其中对于 $i \\in \\{1,2,3\\}$，有 $\\mathbb{E}[X_{i}]=0$ 且 $\\operatorname{Var}(X_{i})=1$。它们的两两相关系数分别为 $\\rho_{12} = 0.5$、$\\rho_{13} = 0.2$ 和 $\\rho_{23} = 0.8$。$3 \\times 3$ 的相关矩阵 $\\mathbf{R}$ 定义为：当 $i \\neq j$ 时 $R_{ij} = \\rho_{ij}$，当 $i = j$ 时 $R_{ii} = 1$。\n\n仅使用协方差和相关的定义、协方差和相关矩阵是对称半正定的事实，以及对称正定（SPD）矩阵的性质，证明 $\\mathbf{R}$ 是对称正定的。然后，推导 Cholesky 分解 $\\mathbf{R} = \\mathbf{L}\\mathbf{L}^{\\top}$，其中 $\\mathbf{L}$ 是一个对角线元素严格为正的下三角矩阵。你的推导过程应通过将 $\\mathbf{L}\\mathbf{L}^{\\top}$ 的元素与 $\\mathbf{R}$ 的元素相等，然后求解 $\\mathbf{L}$ 的元素来进行。\n\n请用精确形式（使用分数和根式，而非小数近似值）表示 $\\mathbf{L}$ 的元素。最终答案必须是明确写出的单个下三角矩阵 $\\mathbf{L}$。",
            "solution": "我们首先根据给定信息构建相关矩阵 $\\mathbf{R}$。根据 $R_{ii}=1$ 和当 $i\\neq j$ 时的 $R_{ij}=\\rho_{ij}$，我们有\n$$\n\\mathbf{R} = \n\\begin{pmatrix}\n1  0.5  0.2 \\\\\n0.5  1  0.8 \\\\\n0.2  0.8  1\n\\end{pmatrix}.\n$$\n为了进行精确计算，将非对角线元素重写为分数会很方便：$0.5 = \\frac{1}{2}$、$0.2 = \\frac{1}{5}$ 和 $0.8 = \\frac{4}{5}$。因此，\n$$\n\\mathbf{R} = \n\\begin{pmatrix}\n1  \\frac{1}{2}  \\frac{1}{5} \\\\\n\\frac{1}{2}  1  \\frac{4}{5} \\\\\n\\frac{1}{5}  \\frac{4}{5}  1\n\\end{pmatrix}.\n$$\n\n我们来证明 $\\mathbf{R}$ 是对称正定（SPD）的。对称性由构造直接得出，因为 $\\rho_{ij}=\\rho_{ji}$。实随机变量的相关矩阵是半正定的，因为对于任何向量 $\\mathbf{y}\\in\\mathbb{R}^{3}$，\n$$\n\\mathbf{y}^{\\top}\\mathbf{R}\\mathbf{y} = \\operatorname{Var}\\!\\left(\\sum_{i=1}^{3} y_{i} X_{i}\\right) \\geq 0.\n$$\n要确定这个特定的 $\\mathbf{R}$ 是正定的，只需证明其所有主子式都为正。计算行列式：\n- 第一个主子式是 $10$。\n- 第二个主子式是\n$$\n\\det\\begin{pmatrix}1  \\frac{1}{2}\\\\ \\frac{1}{2}  1\\end{pmatrix} = 1 - \\left(\\frac{1}{2}\\right)^{2} = \\frac{3}{4}  0.\n$$\n- 完整的行列式是\n\\begin{align*}\n\\det(\\mathbf{R}) \n= 1 \\cdot \\det\\begin{pmatrix}1  \\frac{4}{5}\\\\ \\frac{4}{5}  1\\end{pmatrix}\n- \\frac{1}{2} \\cdot \\det\\begin{pmatrix}\\frac{1}{2}  \\frac{4}{5}\\\\ \\frac{1}{5}  1\\end{pmatrix}\n+ \\frac{1}{5} \\cdot \\det\\begin{pmatrix}\\frac{1}{2}  1\\\\ \\frac{1}{5}  \\frac{4}{5}\\end{pmatrix} \\\\\n= 1 \\cdot \\left(1 - \\frac{16}{25}\\right)\n- \\frac{1}{2} \\cdot \\left(\\frac{1}{2} - \\frac{4}{25}\\right)\n+ \\frac{1}{5} \\cdot \\left(\\frac{1}{2}\\cdot \\frac{4}{5} - 1\\cdot \\frac{1}{5}\\right) \\\\\n= \\frac{9}{25} - \\frac{1}{2}\\cdot \\frac{17}{50} + \\frac{1}{5}\\cdot \\frac{1}{5}\n= \\frac{9}{25} - \\frac{17}{100} + \\frac{1}{25}\n= \\frac{36}{100} - \\frac{17}{100} + \\frac{4}{100}\n= \\frac{23}{100}  0.\n\\end{align*}\n因为所有主子式都为正，所以 $\\mathbf{R}$ 是对称正定（SPD）的。\n\n对于一个对称正定矩阵，其 Cholesky 分解存在且唯一，存在一个对角线元素严格为正的下三角因子 $\\mathbf{L}$，使得 $\\mathbf{R} = \\mathbf{L}\\mathbf{L}^{\\top}$。令\n$$\n\\mathbf{L} = \n\\begin{pmatrix}\n\\ell_{11}  0  0 \\\\\n\\ell_{21}  \\ell_{22}  0 \\\\\n\\ell_{31}  \\ell_{32}  \\ell_{33}\n\\end{pmatrix}.\n$$\n我们通过令 $\\mathbf{L}\\mathbf{L}^{\\top}$ 与 $\\mathbf{R}$ 相等来确定其元素。乘积 $\\mathbf{L}\\mathbf{L}^{\\top}$ 的元素为\n\\begin{align*}\nR_{11} = \\ell_{11}^{2}, \\\\\nR_{21} = \\ell_{21}\\ell_{11}, \\quad R_{31} = \\ell_{31}\\ell_{11}, \\\\\nR_{22} = \\ell_{21}^{2} + \\ell_{22}^{2}, \\\\\nR_{32} = \\ell_{31}\\ell_{21} + \\ell_{32}\\ell_{22}, \\\\\nR_{33} = \\ell_{31}^{2} + \\ell_{32}^{2} + \\ell_{33}^{2}.\n\\end{align*}\n代入相应的 $R_{ij}$ 值并依次求解：\n1. 从 $R_{11} = 1$，我们得到 $\\ell_{11}^{2} = 1$，根据对角线元素为正的要求，有 $\\ell_{11} = 1$。\n2. 从 $R_{21} = \\frac{1}{2}$，我们得到 $\\ell_{21}\\ell_{11} = \\frac{1}{2}$，所以 $\\ell_{21} = \\frac{1}{2}$。\n3. 从 $R_{31} = \\frac{1}{5}$，我们得到 $\\ell_{31}\\ell_{11} = \\frac{1}{5}$，所以 $\\ell_{31} = \\frac{1}{5}$。\n4. 从 $R_{22} = 1$，我们得到 $\\ell_{21}^{2} + \\ell_{22}^{2} = 1$，所以\n$$\n\\ell_{22}^{2} = 1 - \\left(\\frac{1}{2}\\right)^{2} = 1 - \\frac{1}{4} = \\frac{3}{4},\n\\quad \\ell_{22} = \\frac{\\sqrt{3}}{2}.\n$$\n5. 从 $R_{32} = \\frac{4}{5}$，我们得到\n$$\n\\ell_{31}\\ell_{21} + \\ell_{32}\\ell_{22} = \\frac{4}{5}\n\\quad\\Rightarrow\\quad\n\\frac{1}{5}\\cdot \\frac{1}{2} + \\ell_{32}\\cdot \\frac{\\sqrt{3}}{2} = \\frac{4}{5}.\n$$\n因此\n$$\n\\ell_{32}\\cdot \\frac{\\sqrt{3}}{2} = \\frac{4}{5} - \\frac{1}{10} = \\frac{7}{10}\n\\quad\\Rightarrow\\quad\n\\ell_{32} = \\frac{7}{10}\\cdot \\frac{2}{\\sqrt{3}} = \\frac{7}{5\\sqrt{3}}.\n$$\n6. 从 $R_{33} = 1$，我们得到\n$$\n\\ell_{31}^{2} + \\ell_{32}^{2} + \\ell_{33}^{2} = 1\n\\quad\\Rightarrow\\quad\n\\left(\\frac{1}{5}\\right)^{2} + \\left(\\frac{7}{5\\sqrt{3}}\\right)^{2} + \\ell_{33}^{2} = 1.\n$$\n计算前两项的和：\n$$\n\\left(\\frac{1}{5}\\right)^{2} = \\frac{1}{25}, \n\\quad\n\\left(\\frac{7}{5\\sqrt{3}}\\right)^{2} = \\frac{49}{25\\cdot 3} = \\frac{49}{75}.\n$$\n因此\n$$\n\\ell_{33}^{2} = 1 - \\frac{1}{25} - \\frac{49}{75}\n= 1 - \\frac{3}{75} - \\frac{49}{75}\n= 1 - \\frac{52}{75}\n= \\frac{23}{75},\n\\quad\n\\ell_{33} = \\sqrt{\\frac{23}{75}}.\n$$\n\n汇总所有元素，Cholesky 因子为\n$$\n\\mathbf{L} = \n\\begin{pmatrix}\n1  0  0 \\\\\n\\frac{1}{2}  \\frac{\\sqrt{3}}{2}  0 \\\\\n\\frac{1}{5}  \\frac{7}{5\\sqrt{3}}  \\sqrt{\\frac{23}{75}}\n\\end{pmatrix},\n$$\n这满足 $\\mathbf{R} = \\mathbf{L}\\mathbf{L}^{\\top}$ 且对角线元素严格为正的要求。",
            "answer": "$$\\boxed{\\begin{pmatrix}1  0  0 \\\\ \\frac{1}{2}  \\frac{\\sqrt{3}}{2}  0 \\\\ \\frac{1}{5}  \\frac{7}{5\\sqrt{3}}  \\sqrt{\\frac{23}{75}}\\end{pmatrix}}$$"
        },
        {
            "introduction": "为了在计算速度和求解精度之间取得平衡，现代科学计算常常采用混合精度算法。这项高级实践将带领您构建一个混合精度求解器，它结合了快速的低精度矩阵分解和高精度的迭代精化来恢复解的准确性。通过亲手实现，您将探索矩阵条件数 $\\kappa(A)$、计算机的单位舍入误差 $u$ 以及算法收敛性之间的关键关系，这是连接理论与现代高性能计算实践的桥梁。",
            "id": "3222481",
            "problem": "要求您构建并分析一个用于线性系统的混合精度直接求解器，该求解器结合了低精度分解与高精度迭代求精。其数学背景是求解方程组 $A x = b$ 中的 $x$，其中 $A \\in \\mathbb{R}^{n \\times n}$ 是非奇异矩阵，$b \\in \\mathbb{R}^{n}$。\n\n构建一个程序，该程序：\n\n- 在低算术精度（电气和电子工程师协会 (IEEE) $754$ binary$16$ (FP$16$) 或 binary$32$ (FP$32$)）下，使用部分主元法实现 $A$ 的直接分解。您必须完全在所选的低精度算术下执行消去操作、主元选择和三角求解。所选低精度的单位舍入 $u$ 仅用于分析和报告；程序应使用实际的数值类型实现算术运算。\n- 在 IEEE $754$ binary$64$ (FP$64$) 精度下应用迭代求精以改善解。在每个求精步骤中，在 FP$64$ 中计算残差 $r = b - A x_k$，使用先前计算的低精度因子和三角求解来解 $A d = r$，并在 FP$64$ 中更新 $x_{k+1} = x_k + d$。\n- 如果相对残差 $\\|r\\|_2 / \\|b\\|_2$ 在最多 $50$ 个求精步骤内降至阈值 $1 \\times 10^{-12}$ 以下，则宣布收敛。如果达到阈值，则为该测试用例返回布尔结果 $\\text{True}$；否则返回 $\\text{False}$。\n\n您的设计所需的基本基础：\n\n- 采用浮点运算的标准舍入模型：对于给定精度和单位舍入 $u$ 的任何基本算术运算 $\\circ \\in \\{+, -, \\times, \\div\\}$，计算结果满足 $\\operatorname{fl}(a \\circ b) = (a \\circ b) (1 + \\delta)$，其中 $|\\delta| \\le u$。\n- 使用 2-范数条件数 $\\kappa_2(A) = \\|A\\|_2 \\|A^{-1}\\|_2$ 的概念来推断灵敏度和误差放大。\n- 将直接分解的分析建立在带部分主元法的高斯消去法的后向稳定性解释之上：计算出的因子是邻近矩阵 $A + \\Delta A$ 的精确因子，其中 $\\|\\Delta A\\|$ 的界与 $u$ 和问题维度相关，并且三角求解产生的计算解是 $(A + \\Delta A) x = b$ 的精确解。\n\n测试套件和覆盖范围：\n\n对于每个测试用例，构造矩阵 $A$ 为 $\\mathbb{R}^{n \\times n}$ 中的对角矩阵，其对角线元素为 $[1, \\underbrace{1/\\kappa, \\ldots, 1/\\kappa}_{n-1 \\text{ times}}]$，使得 $\\kappa_2(A) = \\kappa$。使用 $n = 5$ 和右侧项 $b = [1, 2, 3, 4, 5]^T$。测试套件必须包括两种低精度类型和一系列条件数，以测试不同的情况：\n\n- 情况 1：FP$16$，$\\kappa = 10$。\n- 情况 2：FP$16$，$\\kappa = 1000$。\n- 情况 3：FP$16$，$\\kappa = 2048$（接近经典的 binary$16$ 边界）。\n- 情况 4：FP$16$，$\\kappa = 3000$。\n- 情况 5：FP$32$，$\\kappa = 10^5$。\n- 情况 6：FP$32$，$\\kappa = 2^{24} = 16{,}777{,}216$（接近经典的 binary$32$ 边界）。\n- 情况 7：FP$32$，$\\kappa = 5 \\times 10^7$。\n\n对于每种情况，按规定运行混合精度算法，并报告迭代求精是否在步骤限制内达到收敛标准。\n\n最终输出格式：\n\n您的程序应生成单行输出，其中包含按上述测试套件顺序排列的结果，形式为方括号内的逗号分隔列表。每个元素必须是表示该情况是否收敛的布尔值（例如，$[\\text{True}, \\text{False}, \\ldots]$）。此问题不涉及物理单位。",
            "solution": "用户提供的问题是有效的。这是一个在数值线性代数领域中提法恰当、有科学依据的问题。所有需要的数据、定义和约束都已提供，没有矛盾或含糊之处。该问题要求实现并分析一种用于求解线性系统的混合精度迭代求精算法，这是科学计算中一种标准且重要的技术。\n\n问题的核心在于理解迭代求精的收敛特性，即当矩阵 $A$ 的分解在低精度算术（例如 FP$16$ 或 FP$32$）中执行，而求精在高精度（FP$64$）中进行时。该方法的收敛性关键取决于矩阵 $A$ 的条件数（记为 $\\kappa(A)$）和低精度算術的单位舍入 $u_{low}$。\n\n设线性系统为 $A x = b$，其中 $A \\in \\mathbb{R}^{n \\times n}$。迭代求精过程从一个初始解 $x_0$ 开始，通过以下步骤生成一系列近似解 $x_k$：\n1. 在高精度下计算残差：$r_k = b - A x_k$。\n2. 使用 $A$ 的低精度分解求解系统 $A d_k = r_k$ 以得到校正量 $d_k$。\n3. 在高精度下更新解：$x_{k+1} = x_k + d_k$。\n\n关键步骤是校正量 $d_k$ 的计算。矩阵 $A$ 首先在低精度算術下被分解为 $\\hat{L}\\hat{U} \\approx A$。这个分解不是精确的；它对应于一个扰动矩阵 $\\hat{L}\\hat{U} = A + \\Delta A$ 的精确分解。后向误差 $\\Delta A$ 的界与 $\\|A\\|$ 和低精度单位舍入 $u_{low}$ 相关。然后使用这些因子求解校正方程。此外，在高精度下计算的残差 $r_k$ 在与低精度因子一同使用前，必须四舍五入到低精度。\n\n我们来分析误差传播。第 $k$ 步解的误差为 $e_k = x - x_k$。对应的残差是 $r_k = b - A x_k = A(x - x_k) = A e_k$。\n计算出的校正量 $\\hat{d}_k$ 是方程 $\\hat{L}\\hat{U} \\hat{d}_k = \\operatorname{fl}(r_k)$ 的解，其中 $\\operatorname{fl}(\\cdot)$ 表示舍入到低精度。这可以写成：\n$$ \\hat{d}_k = (\\hat{L}\\hat{U})^{-1} \\operatorname{fl}(r_k) = (A + \\Delta A)^{-1} (r_k + \\delta_k) $$\n其中 $\\delta_k = \\operatorname{fl}(r_k) - r_k$ 是对残差进行舍入所产生的误差。该舍入误差的大小由 $\\|\\delta_k\\| \\le u_{low} \\|r_k\\|$ 界定。\n\n新的解是 $x_{k+1} = x_k + \\hat{d}_k$，所以新的误差是：\n$$ e_{k+1} = x - x_{k+1} = (x - x_k) - \\hat{d}_k = e_k - (A + \\Delta A)^{-1} (A e_k + \\delta_k) $$\n对于小的 $\\Delta A$，使用近似 $(A + \\Delta A)^{-1} \\approx (I - A^{-1}\\Delta A)A^{-1}$，我们得到：\n$$ e_{k+1} \\approx e_k - (I - A^{-1}\\Delta A)A^{-1}(A e_k + \\delta_k) = e_k - (I - A^{-1}\\Delta A)(e_k + A^{-1}\\delta_k) $$\n展开此式并忽略二阶项（如 $\\Delta A \\cdot \\delta_k$），得到：\n$$ e_{k+1} \\approx e_k - (e_k + A^{-1}\\delta_k - A^{-1}\\Delta A e_k) = A^{-1}\\Delta A e_k - A^{-1}\\delta_k $$\n下一步的误差有两个组成部分，一个来自因式分解误差 $\\Delta A$，另一个来自残差舍入误差 $\\delta_k$。我们来界定新误差的范数：\n$$ \\|e_{k+1}\\| \\le \\|A^{-1}\\Delta A e_k\\| + \\|A^{-1}\\delta_k\\| $$\n对于带部分主元法的高斯消去法，后向误差的一个标准界是 $\\|\\Delta A\\| \\le C_n u_{low} \\|A\\|$，其中 $C_n$ 是一个取决于维度 $n$ 和增长因子的常数。第二项的界为 $\\|A^{-1}\\delta_k\\| \\le \\|A^{-1}\\| u_{low} \\|r_k\\| = \\|A^{-1}\\| u_{low} \\|A e_k\\| \\le u_{low} \\|A^{-1}\\| \\|A\\| \\|e_k\\| = u_{low} \\kappa(A) \\|e_k\\|$。\n两项都贡献了一个与 $u_{low} \\kappa(A)$成比例的因子。为了使误差收敛到零，从 $e_k$到 $e_{k+1}$的映射必须是一个压缩映射。这导致了迭代求精收敛的著名经验法则：\n$$ \\kappa(A) u_{low}  1 $$\n如果此条件成立，误差 $\\|e_k\\|$ 在每一步都会减小，求精过程收敛。如果 $\\kappa(A) u_{low} \\ge 1$，则不保证误差会减小，求精过程很可能会停滞或发散，无法达到高精度容差。\n\n指定精度的单位舍入分别是：FP$16$ 为 $u_{16} = 2^{-11} \\approx 4.88 \\times 10^{-4}$，FP$32$ 为 $u_{32} = 2^{-24} \\approx 5.96 \\times 10^{-8}$。我们现在可以根据收敛条件评估这些测试用例。\n\n- 情况 1：FP$16$，$\\kappa = 10$。$\\kappa u_{16} = 10 \\times 2^{-11} \\approx 0.005 \\ll 1$。预期会收敛。\n- 情况 2：FP$16$，$\\kappa = 1000$。$\\kappa u_{16} = 1000 \\times 2^{-11} \\approx 0.488  1$。预期会收敛。\n- 情况 3：FP$16$，$\\kappa = 2048 = 2^{11}$。$\\kappa u_{16} = 2^{11} \\times 2^{-11} = 1$。这是边界情况。预期无法收敛到严格的容差。\n- 情况 4：FP$16$，$\\kappa = 3000$。$\\kappa u_{16} = 3000 \\times 2^{-11} \\approx 1.46 > 1$。预期会发散或停滞。\n- 情况 5：FP$32$，$\\kappa = 10^5$。$\\kappa u_{32} = 10^5 \\times 2^{-24} \\approx 0.006 \\ll 1$。预期会收敛。\n- 情况 6：FP$32$，$\\kappa = 2^{24}$。$\\kappa u_{32} = 2^{24} \\times 2^{-24} = 1$。这是 FP$32$ 的边界情况。预期会失败。\n- 情况 7：FP$32$，$\\kappa = 5 \\times 10^7$。$\\kappa u_{32} = 5 \\times 10^7 \\times 2^{-24} \\approx 2.98 > 1$。预期会发散或停滞。\n\n此分析得出了测试套件的预期结果。提供的 Python 代码按所述实现了混合精度算法，包括带部分主元法的 LU 分解和迭代求精，并为每个步骤正确处理了指定的算术精度。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef lu_factor_pivoting(A):\n    \"\"\"\n    Performs LU factorization with partial pivoting for a square matrix A.\n    All arithmetic operations respect the dtype of A.\n\n    Args:\n        A (np.ndarray): The matrix to factorize, with a specific float dtype.\n\n    Returns:\n        tuple: A tuple containing:\n            - p_indices (np.ndarray): The permutation indices.\n            - L (np.ndarray): The lower triangular factor (unit diagonal).\n            - U (np.ndarray): The upper triangular factor.\n    \"\"\"\n    n = A.shape[0]\n    dtype = A.dtype\n    U = A.copy()\n    L = np.eye(n, dtype=dtype)\n    p_indices = np.arange(n)\n\n    for k in range(n - 1):\n        # Find pivot row in the sub-column\n        pivot_row_idx = np.argmax(np.abs(U[k:, k])) + k\n        \n        if pivot_row_idx != k:\n            # Swap rows in U\n            U[[k, pivot_row_idx], :] = U[[pivot_row_idx, k], :]\n            # Swap permutation indices\n            p_indices[[k, pivot_row_idx]] = p_indices[[pivot_row_idx, k]]\n            # Swap the computed part of L\n            if k > 0:\n                L[[k, pivot_row_idx], :k] = L[[pivot_row_idx, k], :k]\n\n        # Check for singularity within the given precision\n        if U[k, k] == dtype.type(0):\n            continue  # Matrix is singular in this precision.\n\n        # Elimination\n        for i in range(k + 1, n):\n            multiplier = U[i, k] / U[k, k]\n            L[i, k] = multiplier\n            # Vectorized update of the row\n            U[i, k:] -= multiplier * U[k, k:]\n            # Enforce zero to prevent floating point artifacts\n            U[i, k] = dtype.type(0)\n\n    return p_indices, L, U\n\ndef solve_lower_triangular(L, b):\n    \"\"\"\n    Solves Ly = b for y, where L is a unit lower triangular matrix.\n    Arithmetic is performed in the dtype of L and b.\n    \"\"\"\n    n = L.shape[0]\n    dtype = L.dtype\n    y = np.zeros(n, dtype=dtype)\n    for i in range(n):\n        # dot product is more efficient and maintains dtype\n        s = b[i] - np.dot(L[i, :i], y[:i])\n        y[i] = s\n    return y\n\ndef solve_upper_triangular(U, y):\n    \"\"\"\n    Solves Ux = y for x, where U is an upper triangular matrix.\n    Arithmetic is performed in the dtype of U and y.\n    \"\"\"\n    n = U.shape[0]\n    dtype = U.dtype\n    x = np.zeros(n, dtype=dtype)\n    for i in range(n - 1, -1, -1):\n        s = y[i] - np.dot(U[i, i + 1:], x[i + 1:])\n        if U[i, i] != dtype.type(0):\n            x[i] = s / U[i, i]\n    return x\n\ndef run_mixed_precision_solver(A_orig, b_orig, low_prec_str):\n    \"\"\"\n    Implements the mixed-precision solver with iterative refinement.\n    \"\"\"\n    # 1. Setup precisions and constants\n    low_prec = np.float16 if low_prec_str == 'float16' else np.float32\n    high_prec = np.float64\n    max_iter = 50\n    tolerance = 1e-12\n\n    A_high = A_orig.astype(high_prec)\n    b_high = b_orig.astype(high_prec)\n\n    # 2. Low-precision factorization\n    A_low = A_high.astype(low_prec)\n    p_indices, L_low, U_low = lu_factor_pivoting(A_low)\n    \n    # 3. Initial solve using low-precision factors\n    b_low = b_high.astype(low_prec)\n    Pb_low = b_low[p_indices]\n    \n    y = solve_lower_triangular(L_low, Pb_low)\n    x0_low = solve_upper_triangular(U_low, y)\n    \n    x_k = x0_low.astype(high_prec)\n\n    # 4. Iterative Refinement\n    norm_b = np.linalg.norm(b_high, 2)\n    if norm_b == 0:\n        return True # Trivial solution is x=0\n\n    for _ in range(max_iter):\n        # Compute residual in high precision\n        r_high = b_high - A_high @ x_k\n        \n        # Check for convergence\n        rel_residual = np.linalg.norm(r_high, 2) / norm_b\n        if rel_residual  tolerance:\n            return True\n            \n        # Solve for the correction d in low precision (A d = r)\n        r_low = r_high.astype(low_prec)\n        \n        # Apply permutation to r\n        Pr_low = r_low[p_indices]\n        \n        d_y = solve_lower_triangular(L_low, Pr_low)\n        d_x_low = solve_upper_triangular(U_low, d_y)\n        \n        # Update solution in high precision\n        d_high = d_x_low.astype(high_prec)\n        x_k += d_high\n        \n    # Final check in case convergence happened on the last iteration\n    r_high = b_high - A_high @ x_k\n    rel_residual = np.linalg.norm(r_high, 2) / norm_b\n    if rel_residual  tolerance:\n        return True\n\n    return False\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        ('float16', 10.),\n        ('float16', 1000.),\n        ('float16', 2048.),\n        ('float16', 3000.),\n        ('float32', 1e5),\n        ('float32', 2.**24),\n        ('float32', 5e7),\n    ]\n\n    results = []\n    n = 5\n    # Use high-precision for original b\n    b_vec = np.array([1, 2, 3, 4, 5], dtype=np.float64)\n\n    for prec_str, kappa in test_cases:\n        # Construct the matrix A in high precision\n        diag_A = np.ones(n, dtype=np.float64)\n        if kappa != 1:\n            diag_A[1:] = 1.0 / kappa\n        A_mat = np.diag(diag_A)\n        \n        converged = run_mixed_precision_solver(A_mat, b_vec, prec_str)\n        results.append(str(converged))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```"
        }
    ]
}