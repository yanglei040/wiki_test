{
    "hands_on_practices": [
        {
            "introduction": "在我们深入研究复杂的数值实现之前，让我们通过一个可以解析求解的线性问题来热身。这个练习  旨在阐明打靶法的核心思想：如何将一个边值问题（BVP）转化为一个关于未知初始斜率 $s$ 的代数方程求解问题。通过手动推导，你将清晰地看到 BVP 的解是如何依赖于我们为 $s$ 选择的正确值的。",
            "id": "3256898",
            "problem": "一根长度为 $L$ 的细杆进行一维热传导，其均匀且与温度无关的性质已被纳入一个归一化模型中。沿杆的稳态温度分布 $T(x)$ 由以下常微分方程 (ODE) 控制\n$$\nT''(x) = -q(x),\n$$\n其中 $q(x)$ 是一个给定的空间热源密度，其单位与 $T''(x)$ 的单位一致。杆的两端被保持在固定温度 $T(0) = T_a$ 和 $T(L) = T_b$。\n\n考虑以下具体情况\n$$\nL = 1,\\quad T_a = 310,\\quad T_b = 325,\\quad q(x) = 10\\,\\exp(2x).\n$$\n使用适用于非线性边值问题 (BVP) 的打靶法：引入未知初始斜率 $s = T'(0)$，将问题视为一个初值问题，并通过求解一个关于 $s$ 的标量一致性方程来施加在 $x=L$ 处的末端边界条件。通过进行必要的积分并从第一性原理求解 $s$，推导出 $T(x)$ 的闭式表达式。你的推导必须从模型 ODE 和边界条件开始，不得假定任何预先推导出的解公式。\n\n以开尔文为单位报告 $T(x)$ 的最终表达式。请提供精确表达式，不要进行四舍五入。",
            "solution": "该问题已经过验证，被认为是可靠的。它有科学依据，是适定的、客观的。所有必要的数据都已提供，不存在矛盾。该问题要求使用打靶法的概念框架来求解一个线性边值问题 (BVP) 的解析解。尽管打靶法通常用于数值求解非线性问题，但将其应用于此处的线性问题是一个有效的练习，它会得到一个关于未知初始条件的线性代数方程，而该方程可以解析求解。\n\n控制常微分方程 (ODE) 为：\n$$\nT''(x) = -q(x)\n$$\n具体热源为 $q(x) = 10 \\exp(2x)$。方程变为：\n$$\nT''(x) = -10 \\exp(2x)\n$$\n边界条件为 $T(0) = T_a = 310$ 和 $T(L) = T(1) = T_b = 325$。\n\n遵循打靶法，我们将这个 BVP 转换为一个初值问题 (IVP)。我们引入一个未知初始斜率 $s = T'(0)$。因此，该 IVP 由 ODE 和以下初始条件定义：\n$$\nT(0) = 310\n$$\n$$\nT'(0) = s\n$$\n我们的目标是找到 $s$ 的值，以确保该 IVP 的解也满足第二个边界条件 $T(1) = 325$。\n\n首先，我们将 ODE $T''(x) = -10 \\exp(2x)$ 对 $x$ 积分，以求得温度梯度 $T'(x)$ 的表达式：\n$$\nT'(x) = \\int -10 \\exp(2x) \\, dx = -10 \\frac{\\exp(2x)}{2} + C_1 = -5 \\exp(2x) + C_1\n$$\n其中 $C_1$ 是积分常数。我们使用初始条件 $T'(0) = s$ 来确定 $C_1$：\n$$\ns = T'(0) = -5 \\exp(2 \\cdot 0) + C_1 = -5 \\exp(0) + C_1 = -5(1) + C_1\n$$\n求解 $C_1$，我们得到：\n$$\nC_1 = s + 5\n$$\n将此代回 $T'(x)$ 的表达式中，我们有：\n$$\nT'(x) = -5 \\exp(2x) + s + 5\n$$\n接下来，我们将 $T'(x)$ 对 $x$ 积分，以求得温度分布 $T(x)$：\n$$\nT(x) = \\int \\left(-5 \\exp(2x) + s + 5\\right) \\, dx = -5 \\frac{\\exp(2x)}{2} + (s + 5)x + C_2\n$$\n$$\nT(x) = -\\frac{5}{2} \\exp(2x) + (s + 5)x + C_2\n$$\n其中 $C_2$ 是第二个积分常数。我们使用初始条件 $T(0) = 310$ 来确定 $C_2$：\n$$\n310 = T(0) = -\\frac{5}{2} \\exp(2 \\cdot 0) + (s+5)(0) + C_2 = -\\frac{5}{2} \\exp(0) + C_2 = -\\frac{5}{2} + C_2\n$$\n求解 $C_2$：\n$$\nC_2 = 310 + \\frac{5}{2} = \\frac{620}{2} + \\frac{5}{2} = \\frac{625}{2}\n$$\n因此，该 IVP 的解（它依赖于参数 $s$）为：\n$$\nT(x; s) = -\\frac{5}{2} \\exp(2x) + (s + 5)x + \\frac{625}{2}\n$$\n现在，我们施加第二个边界条件 $T(1) = 325$，来找到 $s$ 的正确值。我们设 $x=1$ 且 $T(1;s) = 325$：\n$$\n325 = T(1; s) = -\\frac{5}{2} \\exp(2 \\cdot 1) + (s + 5)(1) + \\frac{625}{2}\n$$\n$$\n325 = -\\frac{5}{2} \\exp(2) + s + 5 + \\frac{625}{2}\n$$\n现在，我们求解这个关于 $s$ 的线性方程。使用分数进行运算很方便：$325 = \\frac{650}{2}$ 以及 $5 = \\frac{10}{2}$。\n$$\n\\frac{650}{2} = -\\frac{5}{2} \\exp(2) + s + \\frac{10}{2} + \\frac{625}{2}\n$$\n$$\n\\frac{650}{2} = s + \\frac{635}{2} - \\frac{5}{2} \\exp(2)\n$$\n分离出 $s$：\n$$\ns = \\frac{650}{2} - \\frac{635}{2} + \\frac{5}{2} \\exp(2)\n$$\n$$\ns = \\frac{15}{2} + \\frac{5}{2} \\exp(2)\n$$\n找到了初始斜率 $s$ 的唯一值之后，我们将其代回通解 $T(x;s)$ 中，以获得 $T(x)$ 的最终表达式：\n$$\nT(x) = -\\frac{5}{2} \\exp(2x) + \\left( \\left(\\frac{15}{2} + \\frac{5}{2} \\exp(2)\\right) + 5 \\right)x + \\frac{625}{2}\n$$\n我们简化 $x$ 项的系数。注意到 $5 = \\frac{10}{2}$：\n$$\nT(x) = -\\frac{5}{2} \\exp(2x) + \\left( \\frac{15}{2} + \\frac{10}{2} + \\frac{5}{2} \\exp(2) \\right)x + \\frac{625}{2}\n$$\n$$\nT(x) = -\\frac{5}{2} \\exp(2x) + \\left( \\frac{25}{2} + \\frac{5}{2} \\exp(2) \\right)x + \\frac{625}{2}\n$$\n这就是沿杆温度分布 $T(x)$ 的闭式表达式。",
            "answer": "$$\n\\boxed{T(x) = -\\frac{5}{2} \\exp(2x) + \\left( \\frac{25}{2} + \\frac{5}{2} \\exp(2) \\right)x + \\frac{625}{2}}\n$$"
        },
        {
            "introduction": "现在，我们来解决一个真正的非线性边值问题，它无法轻易地得到解析解。这个实践  将指导你编写一个完整的数值求解器，你需要将二阶非线性ODE转化为一阶系统，使用龙格-库塔法进行数值积分，并利用割线法来寻找正确的初始“射击”斜率 $s$。这是实现非线性打靶法的一个基本而重要的一步。",
            "id": "3248424",
            "problem": "考虑定义在闭区间 $[a,b]$ 上的非线性二阶边值问题，其微分方程为 $y'' = y^2$，边界条件为 $y(a) = \\alpha$ 和 $y(b) = \\beta$。将此边值问题重构为一个关于打靶参数 $s$ 的一维求根问题，其中 $s$ 代表未知的初始斜率 $y'(a)$。具体来说，定义初始条件为 $y(a) = \\alpha$ 和 $y'(a) = s$ 的初值问题，积分到 $x=b$ 以获得 $y(b;s)$，并定义失配函数 $R(s) = y(b;s) - \\beta$。使用基于割线更新的求根算法来找到使 $R(s) = 0$ 的 $s$。\n\n您的程序必须：\n- 通过将二阶方程重写为一阶系统 $y' = v$ 和 $v' = y^2$，使用经典的四阶龙格-库塔方法（Runge–Kutta method）和均匀步长，实现对 $y'' = y^2$ 初值问题的数值积分。\n- 实现割线法（secant method）求解 $R(s) = 0$，其中每次计算 $R(s)$ 都需要用选定的 $s$ 对初值问题从 $x=a$ 到 $x=b$ 进行一次数值积分。\n- 对失配量级使用 $10^{-8}$ 的收敛容差，以及最多 50 次割线迭代。如果割线更新中的分母在数值上变为零，则终止并返回当前迭代值。\n- 围绕朴素的线性估计值 $s_{\\text{lin}} = (\\beta - \\alpha)/(b-a)$ 选择两个初始割线猜测值，例如 $s_0 = s_{\\text{lin}} - 0.1\\,(1+|s_{\\text{lin}}|)$ 和 $s_1 = s_{\\text{lin}} + 0.1\\,(1+|s_{\\text{lin}}|)$。\n\n您的推导和算法设计应基于以下基本原则：\n- 使用定义 $y' = v$ 和 $v' = y^2$ 将二阶常微分方程转换为一阶系统。\n- 打靶法（shooting method），该方法通过失配函数 $R(s)$ 强制满足终端边界条件，从而将边值问题简化为针对未知初始斜率的求根问题。\n- 割线法（secant method），该方法通过有限差分来近似牛顿法（Newton’s method）中的导数，在 $R(s_k) \\neq R(s_{k-1})$ 时产生更新式 $s_{k+1} = s_k - R(s_k)\\,(s_k - s_{k-1})/(R(s_k)-R(s_{k-1}))$。\n\n测试套件：\n在以下四个测试用例上运行您的程序，每个用例指定为一个元组 $(a,b,\\alpha,\\beta,N)$，其中 $N$ 是在 $[a,b]$ 上进行积分所使用的均匀龙格-库塔步数：\n1. $(0.0, 1.0, 0.0, 0.0, 200)$ 是一个具有平凡边界数据的基线用例。\n2. $(0.0, 1.0, 0.0, 0.1, 200)$ 是一个具有较小正终端值的“理想路径”用例。\n3. $(0.0, 0.5, 0.2, 0.25, 150)$ 在一个较短的区间上测试中等大小的正初始值和终端值。\n4. $(0.0, 0.5, 0.1, 0.0, 150)$ 测试一个需要负打靶参数才能从一个正初始值减小到更小的终端值的情况。\n\n答案规格：\n- 对于每个测试用例，计算并返回使 $R(s)$ 在指定容差内约等于零的打靶参数 $s$。\n- 最终输出必须为单行，包含四个计算出的 $s$ 值，以逗号分隔并用方括号括起。每个值必须是浮点数，打印时小数点后保留八位数字，并按上述测试用例的顺序排列，例如 $[s_1,s_2,s_3,s_4]$。\n- 此问题不涉及物理单位或角度单位。所有输出均为保留八位小数的实数。\n\n您的程序必须是一个完整、可运行的实现，能够执行所述计算并以指定的确切格式打印结果。",
            "solution": "非线性边值问题 (BVP) $y'' = y^2$（边界条件为 $y(a) = \\alpha$ 和 $y(b) = \\beta$）的解将基于打靶法构建。这涉及三个核心原则：将 BVP 转换为初值问题 (IVP)，对 IVP 进行数值积分，以及使用求根算法来满足终端边界条件。\n\n**1. 将二阶 ODE 转换为一阶系统**\n\n为了应用像龙格-库塔这样的标准数值积分器，必须将二阶 ODE 表示为一个一阶 ODE 系统。我们引入一个新的状态变量 $v$，代表 $y$ 的一阶导数：\n$$\ny' = v\n$$\n对该表达式求导得到 $y'' = v'$。将其代入原始 ODE $y'' = y^2$，得到：\n$$\nv' = y^2\n$$\n现在我们可以定义一个状态向量 $\\mathbf{u}(x) = [y(x), v(x)]^T$。该一阶系统则由下式给出：\n$$\n\\frac{d\\mathbf{u}}{dx} = \\mathbf{f}(x, \\mathbf{u}) = \\begin{pmatrix} y' \\\\ v' \\end{pmatrix} = \\begin{pmatrix} v \\\\ y^2 \\end{pmatrix}\n$$\n该系统在 $x=a$ 处的初始条件由 BVP 在 $a$ 处的条件和引入的打靶参数 $s$ 导出：\n$$\n\\mathbf{u}(a) = \\begin{pmatrix} y(a) \\\\ v(a) \\end{pmatrix} = \\begin{pmatrix} y(a) \\\\ y'(a) \\end{pmatrix} = \\begin{pmatrix} \\alpha \\\\ s \\end{pmatrix}\n$$\n\n**2. 打靶法与失配函数**\n\n打靶法将 BVP 重构为求根问题。对于任意选择的初始斜率 $s = y'(a)$，上述一阶系统成为一个适定的 IVP。我们可以将此 IVP 从 $x=a$ 积分到 $x=b$。在 $x=b$ 处得到的 $y$ 值将是初始选择 $s$ 的函数，我们将其表示为 $y(b; s)$。\n\n目标是找到特定的 $s$ 值，使得计算出的终端值与期望的边界条件 $y(b) = \\beta$ 相匹配。这通过定义一个失配函数 $R(s)$ 来表示，对于正确的 $s$，该函数必须为零：\n$$\nR(s) = y(b; s) - \\beta = 0\n$$\n求解 BVP 现在等价于找到函数 $R(s)$ 的根。\n\n**3. 通过四阶龙格-库塔 (RK4) 方法进行数值积分**\n\n为了对给定的 $s$ 求值 $R(s)$，我们必须从 $x=a$ 到 $x=b$ 数值求解该 IVP。问题指定使用经典的四阶龙格-库塔方法和均匀步长 $h = (b-a)/N$。给定第 $i$ 步的状态 $\\mathbf{u}_i$，下一步的状态 $\\mathbf{u}_{i+1}$ 计算如下：\n$$\n\\mathbf{k}_1 = h \\mathbf{f}(x_i, \\mathbf{u}_i) \\\\\n\\mathbf{k}_2 = h \\mathbf{f}(x_i + h/2, \\mathbf{u}_i + \\mathbf{k}_1/2) \\\\\n\\mathbf{k}_3 = h \\mathbf{f}(x_i + h/2, \\mathbf{u}_i + \\mathbf{k}_2/2) \\\\\n\\mathbf{k}_4 = h \\mathbf{f}(x_i + h, \\mathbf{u}_i + \\mathbf{k}_3) \\\\\n\\mathbf{u}_{i+1} = \\mathbf{u}_i + \\frac{1}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n$$\n其中 $\\mathbf{u}_i = [y_i, v_i]^T$。该过程从 $\\mathbf{u}_0 = [\\alpha, s]^T$ 开始，迭代 $N$ 次以获得 $\\mathbf{u}_N = [y_N, v_N]^T$，这是我们对 $\\mathbf{u}(b)$ 的数值近似。然后用 $y_N$ 来近似 $y(b;s)$。\n\n**4. 通过割线法进行求根**\n\n割线法是一种迭代求根算法，它使用有限差分来近似牛顿法中的导数。给定两个斜率的初始猜测值 $s_0$ 和 $s_1$，以及它们对应的函数值 $R_0 = R(s_0)$ 和 $R_1 = R(s_1)$，下一个猜测值 $s_2$ 通过线性外插到根来找到。通用的更新规则是：\n$$\ns_{k+1} = s_k - R(s_k) \\frac{s_k - s_{k-1}}{R(s_k) - R(s_{k-1})}\n$$\n求根的步骤如下：\n1.  计算朴素的线性斜率估计：$s_{\\text{lin}} = (\\beta - \\alpha)/(b-a)$。\n2.  生成两个初始猜测值：$s_0 = s_{\\text{lin}} - 0.1\\,(1+|s_{\\text{lin}}|)$ 和 $s_1 = s_{\\text{lin}} + 0.1\\,(1+|s_{\\text{lin}}|)$。\n3.  通过执行两次独立的 RK4 积分，计算 $R_0 = R(s_0)$ 和 $R_1 = R(s_1)$。\n4.  使用割线更新规则进行迭代，最多 50 次或直到 $|R(s_k)|  10^{-8}$。如果分母 $|R(s_k) - R(s_{k-1})|$ 变得过小，表明可能出现停滞或除以零，迭代也会终止。\n5.  满足收敛判据的最终迭代值 $s_k$ 就是所求的打靶参数。\n\n通过整合这四个原则，我们可以构建一个程序来为每个测试用例求解给定的 BVP。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the BVP for the given test cases and print the results.\n    \"\"\"\n\n    def run_rk4(f_ode, u0, x_span, n_steps):\n        \"\"\"\n        Integrates a system of first-order ODEs using the classical RK4 method.\n\n        Args:\n            f_ode (callable): The function defining the ODE system, f(x, u).\n            u0 (np.ndarray): The initial state vector [y0, v0].\n            x_span (tuple): The integration interval (a, b).\n            n_steps (int): The number of uniform steps for integration.\n\n        Returns:\n            np.ndarray: The final state vector [y_b, v_b].\n        \"\"\"\n        a, b = x_span\n        h = (b - a) / n_steps\n        u = u0.copy()\n        x = a\n\n        for _ in range(n_steps):\n            k1 = h * f_ode(x, u)\n            k2 = h * f_ode(x + h / 2.0, u + k1 / 2.0)\n            k3 = h * f_ode(x + h / 2.0, u + k2 / 2.0)\n            k4 = h * f_ode(x + h, u + k3)\n            u += (k1 + 2.0 * k2 + 2.0 * k3 + k4) / 6.0\n            x += h\n\n        return u\n\n    def shooting_solver(params):\n        \"\"\"\n        Solves the BVP for a single set of parameters using the shooting method with a secant root-finder.\n\n        Args:\n            params (tuple): A tuple containing (a, b, alpha, beta, N).\n\n        Returns:\n            float: The computed shooting parameter s.\n        \"\"\"\n        a, b, alpha, beta, N = params\n        \n        # Define the first-order ODE system: u' = f(x, u) = [v, y^2]\n        # where u = [y, v]\n        def f_ode(x, u):\n            return np.array([u[1], u[0]**2])\n\n        # Define the mismatch function R(s) = y(b; s) - beta\n        # Each evaluation requires one full RK4 integration.\n        def F(s):\n            u0 = np.array([alpha, s])\n            u_final = run_rk4(f_ode, u0, (a, b), N)\n            y_b = u_final[0]\n            return y_b - beta\n\n        # Secant method parameters\n        TOL = 1e-8\n        MAX_ITER = 50\n        NUM_ZERO = 1e-15 # Denominator tolerance\n\n        # 1. Calculate initial guesses for the secant method\n        if abs(b - a)  NUM_ZERO:\n            s_lin = 0.0 # Avoid division by zero, though not expected for given tests\n        else:\n            s_lin = (beta - alpha) / (b - a)\n\n        s0 = s_lin - 0.1 * (1.0 + abs(s_lin))\n        s1 = s_lin + 0.1 * (1.0 + abs(s_lin))\n        \n        f0 = F(s0)\n        f1 = F(s1)\n\n        # 2. Iterate using secant method\n        for _ in range(MAX_ITER):\n            # Check for convergence\n            if abs(f1)  TOL:\n                break\n            \n            # Check for stall / division by zero\n            denom = f1 - f0\n            if abs(denom)  NUM_ZERO:\n                break\n            \n            # Secant update\n            s_next = s1 - f1 * (s1 - s0) / denom\n            \n            # Update states\n            s0, s1 = s1, s_next\n            f0, f1 = f1, F(s1)\n            \n        return s1\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.0, 1.0, 0.0, 0.0, 200),  # Case 1\n        (0.0, 1.0, 0.0, 0.1, 200),  # Case 2\n        (0.0, 0.5, 0.2, 0.25, 150), # Case 3\n        (0.0, 0.5, 0.1, 0.0, 150),  # Case 4\n    ]\n\n    results = []\n    for case in test_cases:\n        s_final = shooting_solver(case)\n        results.append(s_final)\n    \n    # Format the results as specified\n    formatted_results = [f\"{r:.8f}\" for r in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "为了提高我们求解器的收敛效率，可以将割线法升级为牛顿法。这个高级实践  要求你推导并求解变分方程，以计算残差函数相对于射击参数 $s$ 的精确导数。通过将原ODE系统与变分方程系统联立求解，你将构建一个更强大、收敛更快的非线性打靶法求解器。",
            "id": "3256899",
            "problem": "实现一个程序，该程序使用打靶法求解非线性两点边值问题。此方法对未知的初始斜率采用牛顿-拉夫逊迭代，并同时对 $\\partial y/\\partial s$ 的变分（灵敏度）方程进行积分。该设计的基本原理是将一个二阶常微分方程（ODE）标准地降阶为一个一阶方程组，并应用链式法则计算终端值相对于初始斜率的灵敏度。\n\n给定一个标量二阶常微分方程，其形式为\n$$\ny''(x) = f\\big(x, y(x), y'(x)\\big),\n$$\n定义在区间 $[a,b]$ 上，并带有边界条件\n$$\ny(a) = \\alpha,\\quad y(b) = \\beta,\n$$\n其中 $f$ 是一个足够光滑的函数。打靶法将未知的初始斜率 $s = y'(a)$ 视为一个参数，并定义残差\n$$\nR(s) = y(b; s) - \\beta,\n$$\n其中 $y(b; s)$ 是通过对以下初值问题\n$$\n\\begin{aligned}\ny'(x) = p(x),\\\\\np'(x) = f(x, y(x), p(x)),\\\\\ny(a) = \\alpha,\\quad p(a) = s,\n\\end{aligned}\n$$\n从 $x=a$到 $x=b$ 积分得到的终端值。牛顿-拉夫逊迭代通过以下公式更新 $s$：\n$$\ns_{k+1} = s_k - \\frac{R(s_k)}{R'(s_k)},\n$$\n这需要导数 $R'(s)$。通过将一阶方程组对 $s$ 求导并应用链式法则，得到灵敏度方程组为\n$$\n\\begin{aligned}\nv_1'(x) = v_2(x),\\\\\nv_2'(x) = \\frac{\\partial f}{\\partial y}(x, y(x), p(x))\\, v_1(x) + \\frac{\\partial f}{\\partial p}(x, y(x), p(x))\\, v_2(x),\\\\\nv_1(a) = 0,\\quad v_2(a) = 1,\n\\end{aligned}\n$$\n其中 $v_1(x) = \\frac{\\partial y(x)}{\\partial s}$ 且 $v_2(x) = \\frac{\\partial p(x)}{\\partial s}$。于是有 $R'(s) = v_1(b)$。你的实现必须使用经典的四阶龙格-库塔法（RK4）同时对 $(y,p,v_1,v_2)$ 进行积分，并且必须执行对 $s$ 的牛顿-拉夫逊更新。为了促进稳健收敛，请对牛顿步长使用简单的回溯线搜索：如果一个完整的牛顿更新没有减小 $|R(s)|$ 的值，则反复将步长减半，直到实现减小或达到一个小的步长因子阈值。\n\n数值积分细节：\n- 对增广系统 $(y,p,v_1,v_2)$ 使用经典的四阶龙格-库塔法（RK4），采用均匀步长 $h = (b-a)/N$，其中 $N$ 是每个测试案例提供的正整数。\n- 当 $|R(s)| \\le \\varepsilon$（其中 $\\varepsilon = 10^{-10}$）或达到最大迭代次数 $M = 30$ 次时，终止牛顿-拉夫逊迭代。如果回溯在 $L = 20$ 次步长减半后仍未能减小残差，则接受尝试的更新并继续。\n\n测试套件：\n实现该求解器，并将其应用于以下三个边值问题。对于每个案例，定义 $f$、其偏导数 $\\frac{\\partial f}{\\partial y}$ 和 $\\frac{\\partial f}{\\partial p}$、区间端点 $a$ 和 $b$、边界值 $\\alpha$ 和 $\\beta$、初始猜测值 $s_0$ 以及积分步数 $N$。\n\n- 案例 $1$（非线性且依赖于 $y'$）：\n  - $f(x,y,p) = \\sin(y) + x\\,p$\n  - $\\frac{\\partial f}{\\partial y}(x,y,p) = \\cos(y)$\n  - $\\frac{\\partial f}{\\partial p}(x,y,p) = x$\n  - $a = 0$, $b = 1$\n  - $\\alpha = 0$, $\\beta = 0.5$\n  - $s_0 = 0.3$\n  - $N = 2000$\n\n- 案例 $2$（非线性，以平凡解作为边界条件的边界情况）：\n  - $f(x,y,p) = y^3 - y$\n  - $\\frac{\\partial f}{\\partial y}(x,y,p) = 3y^2 - 1$\n  - $\\frac{\\partial f}{\\partial p}(x,y,p) = 0$\n  - $a = 0$, $b = 1$\n  - $\\alpha = 0$, $\\beta = 0$\n  - $s_0 = 1.0$\n  - $N = 2000$\n\n- 案例 $3$（用于精度验证的线性参考问题）：\n  - $f(x,y,p) = y$\n  - $\\frac{\\partial f}{\\partial y}(x,y,p) = 1$\n  - $\\frac{\\partial f}{\\partial p}(x,y,p) = 0$\n  - $a = 0$, $b = 1$\n  - $\\alpha = 0$, $\\beta = 1$\n  - $s_0 = 0.5$\n  - $N = 2000$\n\n输出规格：\n- 对于每个测试案例，计算打靶参数 $s$ 的牛顿-拉夫逊估计值 $s^\\ast$，使得 $|R(s^\\ast)| \\le \\varepsilon$。\n- 将每个 $s^\\ast$ 表示为四舍五入到八位小数的十进制数。\n- 你的程序应该生成单行输出，其中包含三个四舍五入后的值，以逗号分隔并用方括号括起来，例如 $[s_1,s_2,s_3]$。\n\n本问题不涉及物理单位或角度单位。所有输出均为无量纲实数。",
            "solution": "所给问题要求实现一个数值算法，用于求解形式如下的非线性两点边值问题（BVP）：\n$$\ny''(x) = f\\big(x, y(x), y'(x)\\big), \\quad x \\in [a,b]\n$$\n其边界条件为 $y(a) = \\alpha$ 和 $y(b) = \\beta$。指定的方法是非线性打靶法，该方法将边值问题（BVP）转换为一个初值问题（IVP），并通过迭代调整未知的初始条件，直到满足远端的边界条件。迭代调整将使用牛顿-拉夫逊法进行，这需要计算最终状态相对于初始条件的导数。该导数通过对一组称为灵敏度方程的辅助微分方程进行积分来求得。\n\n首先，我们来形式化打靶法的框架。我们通过令 $p(x) = y'(x)$ 将二阶常微分方程降阶为一个由两个一阶常微分方程组成的方程组。该方程组如下：\n$$\n\\begin{aligned}\ny'(x) = p(x) \\\\\np'(x) = f(x, y(x), p(x)).\n\\end{aligned}\n$$\n边界条件为 $y(a) = \\alpha$ 和 $y(b) = \\beta$。在打靶法中，我们将其视为一个从 $x=a$ 开始的初值问题。初始条件 $y(a)=\\alpha$ 是已知的，但 $p(a) = y'(a)$ 未知。我们将这个未知的初始斜率记作参数 $s$，因此 $p(a) = s$。有了这个，我们就可以将该方程组从 $x=a$ 积分到 $x=b$。$x=b$ 处 $y$ 的值将取决于我们对 $s$ 的选择。我们将其函数依赖关系表示为 $y(b; s)$。目标是找到 $s$ 的值，使得计算出的终端值与要求的边界条件相匹配，即 $y(b; s) = \\beta$。这个条件通过定义一个残差函数 $R(s)$ 来表示，我们需要寻找该函数的根：\n$$\nR(s) = y(b; s) - \\beta = 0.\n$$\n这是一个关于单变量 $s$ 的求根问题。问题指定使用牛顿-拉夫逊法来完成此任务。用于将估计值 $s_k$ 更新为新估计值 $s_{k+1}$ 的迭代公式为：\n$$\ns_{k+1} = s_k - \\frac{R(s_k)}{R'(s_k)},\n$$\n其中 $R'(s_k)$ 是残差函数关于 $s$ 在 $s_k$ 处的导数。该导数为 $R'(s) = \\frac{d}{ds} \\left( y(b; s) - \\beta \\right) = \\frac{\\partial y(b; s)}{\\partial s}$。\n\n为了求得 $\\frac{\\partial y(b; s)}{\\partial s}$，我们推导灵敏度方程。我们定义灵敏度变量 $v_1(x) = \\frac{\\partial y(x)}{\\partial s}$ 和 $v_2(x) = \\frac{\\partial p(x)}{\\partial s}$。我们使用链式法则将一阶方程组对 $s$ 求导：\n$$\n\\frac{\\partial}{\\partial s} (y'(x)) = \\frac{\\partial}{\\partial s} (p(x)) \\implies \\left(\\frac{\\partial y}{\\partial s}\\right)' = \\frac{\\partial p}{\\partial s} \\implies v_1'(x) = v_2(x).\n$$\n$$\n\\frac{\\partial}{\\partial s} (p'(x)) = \\frac{\\partial}{\\partial s} f(x, y, p) \\implies \\left(\\frac{\\partial p}{\\partial s}\\right)' = \\frac{\\partial f}{\\partial y} \\frac{\\partial y}{\\partial s} + \\frac{\\partial f}{\\partial p} \\frac{\\partial p}{\\partial s} \\implies v_2'(x) = \\frac{\\partial f}{\\partial y} v_1(x) + \\frac{\\partial f}{\\partial p} v_2(x).\n$$\n这样我们就得到了一个关于灵敏度 $(v_1, v_2)$ 的线性常微分方程组。为了求解它，我们需要一组在 $x=a$ 处的初始条件。这些条件由主系统的初始条件推导而来：\n$$\ny(a) = \\alpha \\implies v_1(a) = \\frac{\\partial y(a)}{\\partial s} = \\frac{\\partial \\alpha}{\\partial s} = 0.\n$$\n$$\np(a) = s \\implies v_2(a) = \\frac{\\partial p(a)}{\\partial s} = \\frac{\\partial s}{\\partial s} = 1.\n$$\n残差的导数则为 $R'(s) = v_1(b)$。\n\n总体策略是求解一个关于状态向量 $\\mathbf{U}(x) = [y(x), p(x), v_1(x), v_2(x)]^T$ 的增广一阶常微分方程组（包含四个方程）。其控制方程为：\n$$\n\\mathbf{U}'(x) = \\mathbf{F}(x, \\mathbf{U}(x)) = \n\\begin{pmatrix}\np(x) \\\\\nf(x, y(x), p(x)) \\\\\nv_2(x) \\\\\n\\frac{\\partial f}{\\partial y} v_1(x) + \\frac{\\partial f}{\\partial p} v_2(x)\n\\end{pmatrix}.\n$$\n对于一个给定的猜测值 $s_k$，这个增广系统在 $x=a$ 处的初始条件是 $\\mathbf{U}(a) = [\\alpha, s_k, 0, 1]^T$。\n\n一次牛顿-拉夫逊迭代的数值步骤如下：\n1.  设置初始向量 $\\mathbf{U}(a) = [\\alpha, s_k, 0, 1]^T$。\n2.  使用经典的四阶龙格-库塔（RK4）方法，以步长 $h=(b-a)/N$ 对四维系统 $\\mathbf{U}'(x)$ 从 $x=a$ 积分到 $x=b$。积分得到终端状态向量 $\\mathbf{U}(b) = [y(b;s_k), p(b;s_k), v_1(b;s_k), v_2(b;s_k)]^T$。\n3.  计算残差 $R(s_k) = y(b;s_k) - \\beta$。\n4.  检查收敛性：如果 $|R(s_k)| \\le \\varepsilon=10^{-10}$，则过程终止。\n5.  计算残差的导数 $R'(s_k) = v_1(b;s_k)$。\n6.  计算牛顿步长 $\\Delta s_k = -R(s_k)/R'(s_k)$。\n7.  为确保稳健收敛，执行回溯线搜索。尝试完整的步长 $s_k + \\Delta s_k$。如果它没有减小残差的绝对值，即 $|R(s_k + \\Delta s_k)| \\ge |R(s_k)|$，则反复将步长减半。测试一个新的试验步长 $\\lambda \\Delta s_k$，其中 $\\lambda \\in \\{1, 1/2, 1/4, \\dots\\}$。接受第一个能使残差绝对值减小的 $\\lambda$ 值。\n8.  如果经过 $L=20$ 次步长减半仍未找到更好的步长，则接受最后一次尝试的更新（使用最小的 $\\lambda$），并继续迭代。\n9.  更新斜率估计值，$s_{k+1} = s_k + \\lambda \\Delta s_k$，并从步骤1开始重复。\n如果达到收敛条件或达到最大迭代次数 $M=30$ 次，则过程终止。$s_k$ 的最终值被视为解 $s^\\ast$。该算法将被实现并应用于三个指定的测试案例。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the specified boundary value problems and print the results.\n    \"\"\"\n    \n    # Define global constants for the Newton-Raphson solver\n    epsilon = 1e-10\n    max_iter = 30\n    max_backtrack = 20\n    \n    # Define the test cases from the problem statement\n    test_cases = [\n        {\n            \"f\": lambda x, y, p: np.sin(y) + x * p,\n            \"dfdy\": lambda x, y, p: np.cos(y),\n            \"dfdp\": lambda x, y, p: x,\n            \"a\": 0.0, \"b\": 1.0,\n            \"alpha\": 0.0, \"beta\": 0.5,\n            \"s0\": 0.3, \"N\": 2000\n        },\n        {\n            \"f\": lambda x, y, p: y**3 - y,\n            \"dfdy\": lambda x, y, p: 3 * y**2 - 1,\n            \"dfdp\": lambda x, y, p: 0.0,\n            \"a\": 0.0, \"b\": 1.0,\n            \"alpha\": 0.0, \"beta\": 0.0,\n            \"s0\": 1.0, \"N\": 2000\n        },\n        {\n            \"f\": lambda x, y, p: y,\n            \"dfdy\": lambda x, y, p: 1.0,\n            \"dfdp\": lambda x, y, p: 0.0,\n            \"a\": 0.0, \"b\": 1.0,\n            \"alpha\": 0.0, \"beta\": 1.0,\n            \"s0\": 0.5, \"N\": 2000\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        s_star = nonlinear_shooter(\n            case, epsilon, max_iter, max_backtrack\n        )\n        results.append(f\"{s_star:.8f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef nonlinear_shooter(params, epsilon, max_iter, max_backtrack):\n    \"\"\"\n    Solves a two-point BVP using the nonlinear shooting method with Newton's iteration.\n    \n    Args:\n        params (dict): A dictionary containing all problem-specific parameters.\n        epsilon (float): The tolerance for the residual.\n        max_iter (int): Maximum number of Newton-Raphson iterations.\n        max_backtrack (int): Maximum number of step halvings in the line search.\n        \n    Returns:\n        float: The converged value of the initial slope 's'.\n    \"\"\"\n    f = params[\"f\"]\n    dfdy = params[\"dfdy\"]\n    dfdp = params[\"dfdp\"]\n    a = params[\"a\"]\n    b = params[\"b\"]\n    alpha = params[\"alpha\"]\n    beta = params[\"beta\"]\n    s0 = params[\"s0\"]\n    N = params[\"N\"]\n    \n    h = (b - a) / N\n\n    def F_augmented(x, U):\n        \"\"\"\n        Defines the right-hand side of the augmented 4D system of ODEs.\n        U = [y, p, v1, v2]\n        \"\"\"\n        y, p, v1, v2 = U\n        dy_dx = p\n        dp_dx = f(x, y, p)\n        dv1_dx = v2\n        dv2_dx = dfdy(x, y, p) * v1 + dfdp(x, y, p) * v2\n        return np.array([dy_dx, dp_dx, dv1_dx, dv2_dx])\n\n    def integrate_ivp(s_guess):\n        \"\"\"\n        Integrates the augmented IVP from a to b using RK4 for a given initial slope s.\n        Returns the terminal value y(b) and the sensitivity v1(b).\n        \"\"\"\n        U = np.array([alpha, s_guess, 0.0, 1.0])\n        x = a\n        for _ in range(N):\n            k1 = h * F_augmented(x, U)\n            k2 = h * F_augmented(x + h/2, U + k1/2)\n            k3 = h * F_augmented(x + h/2, U + k2/2)\n            k4 = h * F_augmented(x + h, U + k3)\n            U += (k1 + 2*k2 + 2*k3 + k4) / 6\n            x += h\n        return U[0], U[2] # y(b), v1(b)\n\n    s = s0\n    for _ in range(max_iter):\n        y_b, v1_b = integrate_ivp(s)\n        \n        R_s = y_b - beta\n        \n        if abs(R_s) = epsilon:\n            return s\n            \n        Rp_s = v1_b\n        \n        if abs(Rp_s)  1e-12:  # Prevent division by zero or extremely large steps\n            break\n            \n        delta_s = -R_s / Rp_s\n        \n        # Backtracking line search\n        lambda_factor = 1.0\n        updated_in_backtrack = False\n        last_s_trial = s # Fallback value\n        \n        for _ in range(max_backtrack):\n            s_trial = s + lambda_factor * delta_s\n            last_s_trial = s_trial\n            y_b_trial, _ = integrate_ivp(s_trial)\n            R_s_new = y_b_trial - beta\n\n            if abs(R_s_new)  abs(R_s):\n                s = s_trial\n                updated_in_backtrack = True\n                break\n            \n            lambda_factor /= 2.0\n            \n        if not updated_in_backtrack:\n            # If no better step was found after L halvings, accept the last attempted update.\n            s = last_s_trial\n\n    return s\n\nsolve()\n```"
        }
    ]
}