{
    "hands_on_practices": [
        {
            "introduction": "Before applying a numerical solver to a problem with an unknown solution, it is crucial to verify that the code is working correctly. A powerful technique for this is the Method of Manufactured Solutions, where we start with a known function, derive a boundary value problem that it solves, and then check if our numerical method can recover the original function. This practice guides you through this fundamental validation process, starting from deriving the BVP, discretizing it with the finite difference method, and implementing a solver to measure its accuracy. ",
            "id": "3104017",
            "problem": "Consider the following manufactured-solution benchmark for a linear two-point Boundary Value Problem (BVP) for an ordinary differential equation (ODE) on the interval $[0,1]$. The exact solution is prescribed as $u(x)=e^{x}-x$, with Dirichlet boundary conditions $u(0)=1$ and $u(1)=e-1$. Your tasks:\n\n1) Derive a linear, constant-coefficient, second-order ODE with a polynomial right-hand side such that the exact solution $u(x)=e^{x}-x$ satisfies the ODE and the boundary conditions. Start from the definitions of the first and second derivatives and compute $u'(x)$ and $u''(x)$ to construct an ODE of the form $u''(x)-u(x)=g(x)$, then identify $g(x)$ that makes $u(x)$ an exact solution.\n\n2) Discretize the resulting BVP on a uniform grid $x_{i}=ih$ with $i\\in\\{0,1,\\dots,N+1\\}$, where $N$ is the number of interior points and $h=1/(N+1)$. Using the central-difference approximation for the second derivative derived from Taylor expansions, build the corresponding tridiagonal linear system for the unknowns $\\{u_{1},u_{2},\\dots,u_{N}\\}$ that enforces the boundary conditions $u_{0}=1$ and $u_{N+1}=e-1$.\n\n3) Implement a complete, runnable program that:\n- Constructs and solves the tridiagonal linear system for each $N$ in the test suite $N\\in\\{1,10,20,40\\}$.\n- Reconstructs the grid function including boundary values and computes the maximum absolute error over all grid points $x_{i}$, $i\\in\\{0,1,\\dots,N+1\\}$, compared to the exact solution $u(x)=e^{x}-x$.\n- Reports, for each $N$, the maximum absolute error as a floating-point number rounded to eight decimal places.\n\nFoundational base you may use:\n- Definitions of the first derivative $u'(x)=\\lim_{h\\to 0}\\dfrac{u(x+h)-u(x)}{h}$ and the second derivative $u''(x)=\\lim_{h\\to 0}\\dfrac{u(x+h)-2u(x)+u(x-h)}{h^{2}}$.\n- Taylor expansions about a point $x$ for a sufficiently smooth function.\n- Standard linear algebra for solving linear systems.\n\nScientific realism requirements:\n- Work purely in mathematical terms without physical units.\n- Angles and percentages are not involved.\n\nTest suite and output specification:\n- Use the test suite $N\\in\\{1,10,20,40\\}$.\n- For each $N$, compute the maximum absolute error over the full grid, including the endpoints.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test suite values of $N$. Each entry must be rounded to eight decimal places. For example, an output with three hypothetical results should look like [$r_{1},$ $r_{2},$ $r_{3}$], where each $r_{k}$ is a decimal number rounded to eight decimal places.\n- The program must be self-contained and require no user input.",
            "solution": "The user-provided problem is a well-defined exercise in numerical analysis, specifically the application of the finite difference method to a two-point boundary value problem (BVP). The problem is valid as it is mathematically sound, self-contained, and objective. It is based on established principles of calculus and numerical methods. All provided data, including the manufactured solution and boundary conditions, are consistent.\n$u(x) = e^x - x$\n$u(0) = e^0 - 0 = 1$\n$u(1) = e^1 - 1 = e-1$\nThe boundary conditions are correctly stated. The problem will be solved in three parts as requested.\n\n### Part 1: Derivation of the Boundary Value Problem\n\nThe problem asks to derive a linear, constant-coefficient, second-order ODE of the form $u''(x) - u(x) = g(x)$ for which the exact solution is $u(x) = e^x - x$.\n\nFirst, we compute the first and second derivatives of the given solution $u(x)$.\nThe exact solution is:\n$$u(x) = e^x - x$$\n\nThe first derivative, $u'(x)$, is:\n$$u'(x) = \\frac{d}{dx}(e^x - x) = e^x - 1$$\n\nThe second derivative, $u''(x)$, is:\n$$u''(x) = \\frac{d}{dx}(e^x - 1) = e^x$$\n\nNow, we substitute $u(x)$ and $u''(x)$ into the specified form of the ODE, $u''(x) - u(x) = g(x)$, to find the right-hand side function $g(x)$:\n$$g(x) = u''(x) - u(x) = (e^x) - (e^x - x)$$\n$$g(x) = e^x - e^x + x = x$$\n\nThe function $g(x) = x$ is a polynomial, as required. Therefore, the complete BVP is:\n$$\n\\begin{cases}\nu''(x) - u(x) = x,  x \\in [0, 1] \\\\\nu(0) = 1 \\\\\nu(1) = e - 1\n\\end{cases}\n$$\n\n### Part 2: Discretization and Formulation of the Linear System\n\nNext, we discretize the derived BVP using the finite difference method on a uniform grid. The domain $[0, 1]$ is divided into $N+1$ subintervals of equal width $h = 1/(N+1)$. The grid points are $x_i = ih$ for $i = 0, 1, \\dots, N+1$. The values of the solution at these grid points are denoted by $u_i = u(x_i)$.\n\nThe ODE $u''(x) - u(x) = x$ must hold at each interior grid point $x_i$ for $i = 1, 2, \\dots, N$:\n$$u''(x_i) - u(x_i) = x_i$$\n\nWe approximate the second derivative $u''(x_i)$ using the second-order central difference formula:\n$$u''(x_i) \\approx \\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2}$$\n\nSubstituting this approximation into the ODE gives a system of algebraic equations for the unknown interior values $\\{u_1, u_2, \\dots, u_N\\}$:\n$$\\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2} - u_i = x_i, \\quad \\text{for } i = 1, 2, \\dots, N$$\n\nTo form a linear system, we rearrange the equation, grouping terms involving the unknowns on the left side:\n$$u_{i-1} - 2u_i - h^2 u_i + u_{i+1} = h^2 x_i$$\n$$1 \\cdot u_{i-1} + (-2 - h^2)u_i + 1 \\cdot u_{i+1} = h^2 (ih) = ih^3$$\n\nThis set of $N$ equations forms a tridiagonal linear system $A\\mathbf{u} = \\mathbf{b}$, where $\\mathbf{u} = [u_1, u_2, \\dots, u_N]^T$.\n\nThe $N \\times N$ matrix $A$ has the following structure:\n- Main diagonal elements: $A_{ii} = -2 - h^2$\n- Sub-diagonal elements: $A_{i, i-1} = 1$\n- Super-diagonal elements: $A_{i, i+1} = 1$\n\n$$A = \\begin{pmatrix}\n-2-h^2  1  0  \\dots  0 \\\\\n1  -2-h^2  1  \\dots  0 \\\\\n0  1  -2-h^2  \\ddots  \\vdots \\\\\n\\vdots  \\ddots  \\ddots  \\ddots  1 \\\\\n0  \\dots  0  1  -2-h^2\n\\end{pmatrix}$$\n\nThe right-hand side vector $\\mathbf{b}$ is an $N \\times 1$ column vector. We must incorporate the given Dirichlet boundary conditions, $u_0 = 1$ and $u_{N+1} = e-1$.\n\nFor the general interior equations ($i=2, \\dots, N-1$), the right-hand side is simply:\n$$b_i = ih^3$$\n\nThe first and last equations are modified by the boundary conditions.\nFor the first equation ($i=1$):\n$$u_0 + (-2 - h^2)u_1 + u_2 = 1 \\cdot h^3$$\nSince $u_0 = 1$ is known, we move it to the right-hand side. This sets the first element of the vector $\\mathbf{b}$:\n$$b_1 = h^3 - u_0 = h^3 - 1$$\n\nFor the last equation ($i=N$):\n$$u_{N-1} + (-2 - h^2)u_N + u_{N+1} = N h^3$$\nSince $u_{N+1} = e-1$ is known, we move it to the right-hand side. This sets the last element of the vector $\\mathbf{b}$:\n$$b_N = Nh^3 - u_{N+1} = Nh^3 - (e-1)$$\n\nThe complete RHS vector $\\mathbf{b}$ is assembled by applying these rules. Note that in the case where $N=1$, the first and last equations are the same ($i=1$ and $i=N$), so both boundary conditions affect the single RHS element, which becomes $b_1 = h^3 - u_0 - u_2 = h^3 - 1 - (e-1) = h^3 - e$. The provided code implements this logic correctly by initializing the vector and then applying the modifications for the first and last elements.\n\n### Part 3: Implementation Algorithm\n\nThe implementation will perform the following steps for each value of $N$ in the test suite $\\{1, 10, 20, 40\\}$:\n1.  **Initialize Parameters**: Calculate the step size $h = 1/(N+1)$ and the value of $e$.\n2.  **Construct Linear System**:\n    -   Create the tridiagonal matrix $A$ in a banded format suitable for efficient solvers (e.g., `scipy.linalg.solve_banded`). This requires creating a $3 \\times N$ array where rows represent the super-diagonal, main diagonal, and sub-diagonal.\n    -   Construct the right-hand side vector $\\mathbf{b}$ of size $N$ according to the logic derived in Part 2.\n3.  **Solve System**: Solve the linear system $A\\mathbf{u} = \\mathbf{b}$ for the vector of interior solutions $\\mathbf{u} = [u_1, \\dots, u_N]^T$.\n4.  **Reconstruct Full Solution**: Assemble the complete numerical solution vector, including the boundary values: $U_{num} = [u_0, u_1, \\dots, u_N, u_{N+1}] = [1, \\mathbf{u}^T, e-1]^T$.\n5.  **Compute Exact Solution**: Create the vector of grid points $X = [x_0, x_1, \\dots, x_{N+1}]$ where $x_i = ih$. Evaluate the exact solution $u(x) = e^x - x$ at each grid point to get the vector $U_{exact}$.\n6.  **Calculate Error**: Compute the maximum absolute error between the numerical and exact solutions over all grid points: $E_{max} = \\max_{i \\in \\{0, \\dots, N+1\\}} |U_{num, i} - U_{exact, i}|$.\n7.  **Store and Format Result**: Round the computed maximum error to eight decimal places and store it. After processing all values of $N$, format the collected results into the specified string format.\n\nThis procedure will be encapsulated in a Python program using the `numpy` and `scipy` libraries as required.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Solves the BVP u''(x) - u(x) = x on [0,1] with u(0)=1, u(1)=e-1\n    using a finite difference scheme for a given set of N values.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [1, 10, 20, 40]\n\n    results = []\n    for N in test_cases:\n        # Step 1: Initialize Parameters\n        # N: number of interior points\n        # There are N+2 total points (including boundaries)\n        h = 1.0 / (N + 1)\n        \n        # Exact boundary values\n        u0 = 1.0\n        uN_plus_1 = np.e - 1.0\n\n        # Step 2: Construct the tridiagonal linear system A*u = b\n        \n        # Construct the tridiagonal matrix A in banded format for SciPy.\n        # The format is a (3, N) array:\n        # Row 0: Super-diagonal (padded with a 0 at the start)\n        # Row 1: Main diagonal\n        # Row 2: Sub-diagonal (padded with a 0 at the end)\n        ab = np.zeros((3, N))\n        ab[0, 1:] = 1.0  # Super-diagonal\n        ab[1, :] = -2.0 - h**2  # Main diagonal\n        ab[2, :-1] = 1.0  # Sub-diagonal\n\n        # Construct the right-hand side vector b\n        # Start with the base value b_i = i * h^3\n        b = np.array([(i + 1) * h**3 for i in range(N)])\n        \n        # Incorporate boundary conditions\n        b[0] -= u0\n        b[-1] -= uN_plus_1\n        \n        # Step 3: Solve the system for the interior points u\n        u_interior = solve_banded((1, 1), ab, b)\n        \n        # Step 4: Reconstruct the full numerical solution grid function\n        u_numerical = np.concatenate(([u0], u_interior, [uN_plus_1]))\n\n        # Step 5: Compute the exact solution at grid points\n        # Grid points x_i = i*h for i = 0, ..., N+1\n        x = np.linspace(0, 1, N + 2)\n        u_exact = np.exp(x) - x\n\n        # Step 6: Calculate the maximum absolute error\n        # The error at the boundaries is zero by construction (up to float precision)\n        max_error = np.max(np.abs(u_numerical - u_exact))\n        \n        # Add the rounded result to the list\n        results.append(max_error)\n\n    # Final print statement in the exact required format.\n    # Each result is formatted to eight decimal places.\n    formatted_results = [f\"{res:.8f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Many physical systems, such as those involving heat flux or fluid flow, are modeled using boundary conditions on the derivative of a function, known as Neumann conditions. Handling these conditions accurately is a common task in scientific computing. This hands-on exercise demonstrates how to extend the standard finite difference method to a mixed BVP by implementing the \"ghost point\" technique, a clever algebraic approach that preserves the second-order accuracy of the numerical scheme. ",
            "id": "3211343",
            "problem": "You are tasked with designing and implementing a second-order finite difference solver for a one-dimensional boundary value problem for an ordinary differential equation with a Neumann boundary condition. The mathematical model is the linear Poisson equation\n$$\nu''(x) = f(x), \\quad x \\in [0,1],\n$$\nwith a Neumann boundary condition at the left endpoint and a Dirichlet boundary condition at the right endpoint:\n$$\nu'(0) = \\alpha, \\quad u(1) = \\beta.\n$$\nYou must use a uniform grid with $$m$$ equal subdivisions of the interval $$[0,1]$$, with grid points $$x_i = i h$$ where $$h = 1/m$$ and $$i = 0,1,\\dots,m$$. Your numerical method must:\n- Use the standard second-order centered difference approximation of the second derivative at interior nodes.\n- Implement the Neumann condition at $$x=0$$ using a \"ghost point\" so that the derivative at the boundary is approximated by a centered difference, and eliminate the ghost point by invoking the ordinary differential equation $$u''(x)=f(x)$$ and appropriate Taylor expansions to preserve second-order accuracy. The design must start from fundamental definitions (grid, Taylor expansions, and the ordinary differential equation) and avoid ad hoc formulas.\n- Incorporate the Dirichlet boundary condition at $$x=1$$ in a way that retains second-order accuracy at the last interior node.\n\nYour program must solve the discrete linear system for the interior unknowns $$u(x_i)$$ at $$i=1,2,\\dots,m-1$$, and then evaluate the maximum absolute error relative to an exact analytical solution over the interior grid points $$\\{x_i\\}_{i=1}^{m-1}$$.\n\nFor validation, derive exact analytical solutions by integrating $$u''(x)=f(x)$$ twice and using the boundary conditions to determine integration constants. For each test case below, the program must compute:\n- The numerical solution at interior grid points using your second-order scheme with the ghost point treatment at $$x=0$$.\n- The exact solution at the same interior grid points.\n- The maximum absolute error (the infinity norm of the pointwise error vector) over interior points, expressed as a real number.\n\nAdditionally, for a convergence assessment test, compute the observed order of accuracy $$p$$ defined by\n$$\np = \\log_2\\left(\\frac{E_{h}}{E_{h/2}}\\right),\n$$\nwhere $$E_{h}$$ and $$E_{h/2}$$ are the maximum absolute errors for grids with $$m$$ and $$2m$$ subdivisions, respectively.\n\nUse the following test suite:\n1. Happy path: $$f(x) = 2$$, $$\\alpha = 1$$, $$\\beta = 0$$, $$m = 50$$. The exact solution is found by solving $$u''(x)=2$$ with the given boundary conditions.\n2. Boundary-condition-dominant coarse grid: $$f(x) = 0$$, $$\\alpha = 0$$, $$\\beta = 1$$, $$m = 4$$. The exact solution is constant.\n3. Oscillatory forcing: $$f(x) = -\\pi^2 \\sin(\\pi x)$$, $$\\alpha = 0$$, $$\\beta = 0$$, $$m = 64$$. The exact solution is obtained by solving $$u''(x) = -\\pi^2 \\sin(\\pi x)$$ with the given boundary conditions.\n4. Convergence order: $$f(x) = x$$, $$\\alpha = 0$$, $$\\beta = 0$$ with two grids $$m=20$$ and $$m=40$$. Compute the observed order $$p$$ as defined above.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test suite above. The first three entries must be real numbers representing the maximum absolute error for each case, and the last entry must be a real number representing the observed order for the convergence test. For example, the output should look like $$[e_1,e_2,e_3,p]$$, where each $$e_i$$ and $$p$$ are real numbers.",
            "solution": "The user-provided problem is valid as it is scientifically grounded in the theory of numerical methods for ordinary differential equations, is mathematically well-posed, and is defined with objective, formal criteria. This document provides a complete derivation of the numerical method and the analytical solutions for validation.\n\nThe problem is to solve the one-dimensional Poisson equation, a linear second-order ordinary differential equation (ODE), on the interval $x \\in [0,1]$:\n$$\nu''(x) = f(x)\n$$\nwith a Neumann boundary condition at $x=0$ and a Dirichlet boundary condition at $x=1$:\n$$\nu'(0) = \\alpha, \\quad u(1) = \\beta.\n$$\n\nWe will construct a second-order finite difference scheme to approximate the solution.\n\n**1. Discretization of the Domain**\n\nThe domain $[0,1]$ is discretized into a uniform grid with $m$ subdivisions. The grid spacing is $h = 1/m$. The grid points are defined as $x_i = i h$ for $i = 0, 1, \\dots, m$. Let $U_i$ be the numerical approximation of the exact solution $u(x_i)$ at grid point $x_i$. The boundary condition at $x=1$ gives $U_m = u(1) = \\beta$. The values to be determined are $U_0, U_1, \\dots, U_{m-1}$.\n\n**2. Finite Difference Approximation for Interior Points**\n\nFor any interior grid point $x_i$ where $i = 1, 2, \\dots, m-1$, we approximate the second derivative $u''(x_i)$ using the second-order centered difference formula. This is derived from Taylor series expansions of $u(x_{i+1})$ and $u(x_{i-1})$ around $x_i$:\n$$\nu(x_{i+1}) = u(x_i+h) = u(x_i) + h u'(x_i) + \\frac{h^2}{2} u''(x_i) + \\frac{h^3}{6} u'''(x_i) + O(h^4)\n$$\n$$\nu(x_{i-1}) = u(x_i-h) = u(x_i) - h u'(x_i) + \\frac{h^2}{2} u''(x_i) - \\frac{h^3}{6} u'''(x_i) + O(h^4)\n$$\nAdding these two expansions and rearranging for $u''(x_i)$ yields:\n$$\nu''(x_i) = \\frac{u(x_{i+1}) - 2u(x_i) + u(x_{i-1})}{h^2} - \\frac{h^2}{12} u^{(4)}(x_i) + \\dots\n$$\nThe approximation is second-order accurate, with a local truncation error of $O(h^2)$. Replacing $u(x_i)$ with $U_i$ and $u''(x_i)$ with $f(x_i)$ from the ODE, we obtain the discrete equations for the interior nodes:\n$$\n\\frac{U_{i-1} - 2U_i + U_{i+1}}{h^2} = f(x_i), \\quad \\text{for } i = 1, 2, \\dots, m-1.\n$$\n\n**3. Discretization of the Neumann Boundary Condition at $x=0$**\n\nThe problem requires using a ghost point to maintain second-order accuracy. We introduce a ghost point at $x_{-1} = -h$.\nFirst, we approximate the derivative $u'(0) = \\alpha$ using a second-order centered difference at $x_0 = 0$:\n$$\nu'(0) = \\frac{u(x_1) - u(x_{-1})}{2h} + O(h^2) \\implies \\frac{U_1 - U_{-1}}{2h} = \\alpha\n$$\nThis gives an expression for the ghost value $U_{-1}$:\n$$\nU_{-1} = U_1 - 2h\\alpha\n$$\nNext, we assume the ODE $u''(x) = f(x)$ also holds at the boundary point $x_0=0$. We apply the centered difference formula for $u''(0)$:\n$$\n\\frac{U_{-1} - 2U_0 + U_1}{h^2} = f(x_0)\n$$\nNow, we eliminate the ghost point $U_{-1}$ by substituting its expression into this equation:\n$$\n\\frac{(U_1 - 2h\\alpha) - 2U_0 + U_1}{h^2} = f(x_0)\n$$\nSimplifying this expression gives the equation for the node $i=0$:\n$$\n\\frac{-2U_0 + 2U_1 - 2h\\alpha}{h^2} = f(x_0) \\implies -2U_0 + 2U_1 = h^2 f(x_0) + 2h\\alpha\n$$\nThe local truncation error of this boundary scheme is $O(h)$, which is sufficient to ensure the global error of the overall method is $O(h^2)$.\n\n**4. Assembly of the Linear System**\n\nWe have a system of $m$ linear equations for the $m$ unknowns $U_0, U_1, \\dots, U_{m-1}$. Let $\\mathbf{U} = [U_0, U_1, \\dots, U_{m-1}]^T$ be the vector of unknowns. The system can be written as $A \\mathbf{U} = \\mathbf{b}$.\n\nThe equations are:\n- For $i=0$: $-2U_0 + 2U_1 = h^2 f(x_0) + 2h\\alpha$\n- For $i=1, \\dots, m-2$: $U_{i-1} - 2U_i + U_{i+1} = h^2 f(x_i)$\n- For $i=m-1$: $U_{m-2} - 2U_{m-1} + U_m = h^2 f(x_{m-1})$. Since $U_m = \\beta$, this becomes $U_{m-2} - 2U_{m-1} = h^2 f(x_{m-1}) - \\beta$.\n\nThe $m \\times m$ coefficient matrix $A$ is:\n$$\nA = \\begin{pmatrix}\n-2  2  0  \\cdots  \\cdots  0 \\\\\n1  -2  1  \\ddots   \\vdots \\\\\n0  1  -2  1  \\ddots  \\vdots \\\\\n\\vdots  \\ddots  \\ddots  \\ddots  \\ddots  0 \\\\\n\\vdots   \\ddots  1  -2  1 \\\\\n0  \\cdots  \\cdots  0  1  -2\n\\end{pmatrix}\n$$\nThe right-hand side vector $\\mathbf{b}$ of size $m$ is:\n$$\n\\mathbf{b} = \\begin{pmatrix}\nh^2 f(x_0) + 2h\\alpha \\\\\nh^2 f(x_1) \\\\\n\\vdots \\\\\nh^2 f(x_{m-2}) \\\\\nh^2 f(x_{m-1}) - \\beta\n\\end{pmatrix}\n$$\nThis linear system $A \\mathbf{U} = \\mathbf{b}$ is non-singular and can be solved to find the numerical solution $\\mathbf{U}$.\n\n**5. Error Calculation and Convergence Order**\n\nThe maximum absolute error $E_h$ is computed over the interior grid points $\\{x_i\\}_{i=1}^{m-1}$ as the infinity norm of the error vector:\n$$\nE_h = \\max_{i=1,\\dots,m-1} |U_i - u(x_i)|\n$$\nFor a second-order accurate method, the error is expected to behave as $E_h \\approx C h^2$ for some constant $C$. The order of accuracy $p$ can be observed numerically by comparing errors from two different grid sizes, $h$ and $h/2$.\n$$\nE_h \\approx C h^p \\quad \\text{and} \\quad E_{h/2} \\approx C (h/2)^p\n$$\nTaking the ratio gives $\\frac{E_h}{E_{h/2}} \\approx 2^p$. Solving for $p$ yields:\n$$\np = \\log_2\\left(\\frac{E_{h}}{E_{h/2}}\\right)\n$$\n\n**6. Analytical Solutions for Test Cases**\n\nThe exact solution $u(x)$ is found by integrating $u''(x) = f(x)$ twice and applying the boundary conditions $u'(0) = \\alpha$ and $u(1) = \\beta$ to determine the constants of integration.\n\n- **Case 1:** $f(x) = 2$, $\\alpha = 1$, $\\beta = 0$.\n$u'' = 2 \\implies u'(x) = 2x+C_1$. $u'(0)=C_1=1$. So $u'(x)=2x+1$.\n$u(x) = x^2+x+C_2$. $u(1)=1+1+C_2=0 \\implies C_2=-2$.\n$u(x) = x^2+x-2$.\n\n- **Case 2:** $f(x) = 0$, $\\alpha = 0$, $\\beta = 1$.\n$u'' = 0 \\implies u'(x) = C_1$. $u'(0)=C_1=0$. So $u'(x)=0$.\n$u(x) = C_2$. $u(1)=C_2=1$.\n$u(x) = 1$.\n\n- **Case 3:** $f(x) = -\\pi^2 \\sin(\\pi x)$, $\\alpha = 0$, $\\beta = 0$.\n$u''(x) = -\\pi^2 \\sin(\\pi x) \\implies u'(x) = \\pi \\cos(\\pi x)+C_1$. $u'(0)=\\pi+C_1=0 \\implies C_1=-\\pi$.\n$u'(x) = \\pi \\cos(\\pi x) - \\pi$.\n$u(x) = \\sin(\\pi x) - \\pi x + C_2$. $u(1)=\\sin(\\pi)-\\pi+C_2=0 \\implies C_2=\\pi$.\n$u(x) = \\sin(\\pi x) - \\pi x + \\pi$.\n\n- **Case 4:** $f(x) = x$, $\\alpha = 0$, $\\beta = 0$.\n$u''(x) = x \\implies u'(x) = x^2/2+C_1$. $u'(0)=C_1=0$. So $u'(x)=x^2/2$.\n$u(x) = x^3/6+C_2$. $u(1)=1/6+C_2=0 \\implies C_2=-1/6$.\n$u(x) = \\frac{x^3}{6} - \\frac{1}{6}$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the finite difference solver.\n    \"\"\"\n\n    def run_solver(f, alpha, beta, m):\n        \"\"\"\n        Solves u''(x) = f(x) with u'(0)=alpha, u(1)=beta on a grid with m subdivisions.\n        \n        Args:\n            f (callable): The forcing function f(x).\n            alpha (float): The Neumann boundary condition value at x=0.\n            beta (float): The Dirichlet boundary condition value at x=1.\n            m (int): The number of grid subdivisions.\n            \n        Returns:\n            tuple: A tuple containing:\n                - np.ndarray: Grid points for the interior, x_1, ..., x_{m-1}.\n                - np.ndarray: Numerical solution at the interior points, U_1, ..., U_{m-1}.\n        \"\"\"\n        # Grid setup\n        h = 1.0 / m\n        # We solve for unknowns at x_0, x_1, ..., x_{m-1}\n        x_nodes = np.linspace(0, 1, m + 1)\n        \n        # Assemble the m x m matrix A\n        A = np.zeros((m, m))\n        \n        # Fill diagonals for the standard interior stencil (1, -2, 1)\n        np.fill_diagonal(A, -2.0)\n        # Lower diagonal (k=-1): A[i, i-1] = 1 for i=1,...,m-1\n        np.fill_diagonal(A[1:], 1.0)\n        # Upper diagonal (k=1): A[i, i+1] = 1 for i=0,...,m-2\n        np.fill_diagonal(A[:, 1:], 1.0)\n        \n        # Modify the first row for the Neumann condition: -2*U_0 + 2*U_1 = ...\n        A[0, 1] = 2.0\n        \n        # Assemble the right-hand side vector b of size m\n        # We evaluate f at x_0, ..., x_{m-1}\n        b = h**2 * f(x_nodes[0:m])\n        \n        # Modify first and last elements of b for boundary conditions\n        # b_0 = h^2*f(x_0) + 2*h*alpha\n        b[0] += 2.0 * h * alpha\n        # b_{m-1} = h^2*f(x_{m-1}) - beta\n        b[m-1] -= beta\n        \n        # Solve the linear system A*U = b for U = [U_0, ..., U_{m-1}]\n        U = np.linalg.solve(A, b)\n        \n        # Return interior grid points and corresponding solution values\n        return x_nodes[1:m], U[1:]\n\n    results = []\n\n    # Test Case 1: Happy path\n    f1 = lambda x: 2.0 * np.ones_like(x)\n    u_exact1 = lambda x: x**2 + x - 2.0\n    alpha1, beta1, m1 = 1.0, 0.0, 50\n    x_interior1, U_interior1 = run_solver(f1, alpha1, beta1, m1)\n    u_exact_vals1 = u_exact1(x_interior1)\n    error1 = np.max(np.abs(U_interior1 - u_exact_vals1))\n    results.append(error1)\n\n    # Test Case 2: Boundary-condition-dominant coarse grid\n    f2 = lambda x: np.zeros_like(x)\n    u_exact2 = lambda x: np.ones_like(x)\n    alpha2, beta2, m2 = 0.0, 1.0, 4\n    x_interior2, U_interior2 = run_solver(f2, alpha2, beta2, m2)\n    u_exact_vals2 = u_exact2(x_interior2)\n    error2 = np.max(np.abs(U_interior2 - u_exact_vals2))\n    results.append(error2)\n\n    # Test Case 3: Oscillatory forcing\n    f3 = lambda x: -np.pi**2 * np.sin(np.pi * x)\n    u_exact3 = lambda x: np.sin(np.pi * x) - np.pi * x + np.pi\n    alpha3, beta3, m3 = 0.0, 0.0, 64\n    x_interior3, U_interior3 = run_solver(f3, alpha3, beta3, m3)\n    u_exact_vals3 = u_exact3(x_interior3)\n    error3 = np.max(np.abs(U_interior3 - u_exact_vals3))\n    results.append(error3)\n\n    # Test Case 4: Convergence order\n    f4 = lambda x: x\n    u_exact4 = lambda x: x**3 / 6.0 - 1.0 / 6.0\n    alpha4, beta4 = 0.0, 0.0\n    \n    # Solve on grid with m=20\n    m_h = 20\n    x_h, U_h = run_solver(f4, alpha4, beta4, m_h)\n    u_h = u_exact4(x_h)\n    E_h = np.max(np.abs(U_h - u_h))\n    \n    # Solve on grid with m=40\n    m_h2 = 40\n    x_h2, U_h2 = run_solver(f4, alpha4, beta4, m_h2)\n    u_h2 = u_exact4(x_h2)\n    E_h2 = np.max(np.abs(U_h2 - u_h2))\n    \n    order_p = np.log2(E_h / E_h2)\n    results.append(order_p)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Real-world problems often feature solutions with sharp gradients or thin boundary layers, where a uniform grid would be computationally inefficient. Nonuniform grids that concentrate resolution where it is most needed are an essential tool for tackling such problems. This practice challenges you to derive and implement a finite difference scheme on a nonuniform grid from first principles, and through a carefully chosen example, reveals important insights about the interaction between the discretization and the analytical nature of the solution itself. ",
            "id": "3103893",
            "problem": "You are asked to build a complete, runnable program that studies the influence of grid clustering on the numerical solution of a one-dimensional boundary value problem for an ordinary differential equation using finite differences on nonuniform grids. The boundary value problem is the linear, second-order two-point problem\n$$\n-\\varepsilon\\,u''(x)+u(x)=x,\\quad x\\in(0,1),\\qquad u(0)=0,\\quad u(1)=1,\n$$\nwhere $\\varepsilon0$ is a parameter. Your task is to derive and implement a principled nonuniform-grid finite difference method from first principles, and then measure errors for two different grid clustering strategies.\n\nUse as the fundamental base:\n- The definition of the first and second derivatives, the existence and uniqueness of solutions for linear second order boundary value problems, and Taylor expansions about a point for smooth functions.\n- The concept of a mesh mapping $\\phi:[0,1]\\to[0,1]$ to generate nonuniform grids from a uniform parameter $s\\in[0,1]$.\n- The method of finite differences using a three-point stencil on a nonuniform grid, derived from first principles by local Taylor expansion and differencing.\n\nDo not use any pre-derived discrete operator formulas from external references. Instead, derive the nonuniform second-derivative approximation using Taylor expansions and the definition of the derivative to construct a three-point second-derivative approximation at interior nodes. Treat the boundary values by enforcing the given boundary conditions directly.\n\nGrid generation:\n- Let $N$ be the number of grid points (including endpoints).\n- Define a uniform parameter grid $s_j=j/(N-1)$ for $j=0,1,\\ldots,N-1$.\n- Define a clustering exponent $p\\ge 1$ and generate two physical grids $x_j$ by\n  - Left clustering: $x_j=\\phi_{\\text{left}}(s_j)=s_j^p$.\n  - Right clustering: $x_j=\\phi_{\\text{right}}(s_j)=1-(1-s_j)^p$.\nBoth grids must satisfy $x_0=0$ and $x_{N-1}=1$, be strictly increasing, and become more clustered near $x=0$ or $x=1$ respectively as $p$ increases.\n\nDiscretization:\n- On the nonuniform grid $\\{x_j\\}_{j=0}^{N-1}$, derive a three-point approximation for $u''(x_j)$ at interior points $j=1,\\ldots,N-2$ using only neighboring values $u_{j-1}$, $u_j$, and $u_{j+1}$, starting from Taylor expansions of $u(x)$ about $x_j$ and eliminating higher-order terms consistently to obtain a second-order accurate approximation on nonuniform meshes.\n- Assemble the resulting linear system that represents the discrete version of $-\\varepsilon u''(x_j)+u(x_j)=x_j$ at interior points, and enforce the boundary conditions $u_0=0$ and $u_{N-1}=1$ exactly.\n\nAnalytic reference solution:\n- Derive the analytic solution to the boundary value problem to be used for measuring numerical error. Use fundamental methods of solving linear ordinary differential equations with constant coefficients and apply the boundary conditions.\n\nError measurement:\n- For each grid strategy (left and right clustering) and each test configuration below, compute the numerical solution values $\\{u_j^{\\text{num}}\\}$ and the analytic reference values $\\{u(x_j)\\}$ at the same grid points. Report the maximum absolute nodal error\n$$\nE_\\infty=\\max_{0\\le j\\le N-1}\\,|u_j^{\\text{num}}-u(x_j)|.\n$$\n\nProgram requirements:\n- Implement the nonuniform finite difference method you derive.\n- Implement a direct tridiagonal solver for the resulting linear system.\n- Implement both grid mappings as specified.\n- Use the analytic solution you derive to compute nodal errors.\n- No user input is permitted; the program must run as-is and print the requested results.\n\nTest suite:\nEvaluate and report the errors for the following five configurations, listed in order. Each configuration is a triple $(\\varepsilon,N,p)$:\n1. $(10^{-2},\\,41,\\,3)$\n2. $(10^{-6},\\,41,\\,3)$\n3. $(10^{-2},\\,5,\\,3)$\n4. $(1,\\,41,\\,3)$\n5. $(10^{-2},\\,101,\\,5)$\n\nOutput specification:\n- For each configuration, compute two floating-point error values: $E_\\infty^{\\text{left}}$ for left clustering and $E_\\infty^{\\text{right}}$ for right clustering.\n- Round each reported error to $8$ decimal places.\n- Your program should produce a single line of output containing the results as a comma-separated list of the five two-element lists in the same order as the test suite, where each inner list is formatted without spaces and each float is printed in fixed-point decimal notation with exactly $8$ digits after the decimal point. For example, a line like\n[ [0.12345678,0.23456789], [ ... ], ... ]\nis not acceptable due to spaces; instead, the exact required format is:\n[[0.12345678,0.23456789],[...],...]\n\nUnits:\n- The problem is dimensionless; no physical units apply.",
            "solution": "We begin with the boundary value problem\n$$\n-\\varepsilon\\,u''(x)+u(x)=x,\\quad x\\in(0,1),\\qquad u(0)=0,\\quad u(1)=1,\n$$\nwhere $\\varepsilon0$. The governing equation is linear with constant coefficients and a linear right-hand side.\n\nAnalytic solution for reference:\nWe first derive the exact solution to enable error measurement. The homogeneous equation is $-\\varepsilon u''(x)+u(x)=0$, which rearranges to $u''(x)=(1/\\varepsilon)u(x)$. Its general solution is\n$$\nu_h(x)=A\\,e^{x/\\sqrt{\\varepsilon}}+B\\,e^{-x/\\sqrt{\\varepsilon}},\n$$\nwhere $A$ and $B$ are constants. A particular solution to $-\\varepsilon u''(x)+u(x)=x$ can be guessed by the method of undetermined coefficients. Let $u_p(x)=\\alpha x+\\beta$. Then $u_p''(x)=0$, and substituting gives $-\\varepsilon\\cdot 0 + (\\alpha x+\\beta)=x$, implying $\\alpha=1$ and $\\beta=0$. Thus $u_p(x)=x$. The general solution is\n$$\nu(x)=x+A\\,e^{x/\\sqrt{\\varepsilon}}+B\\,e^{-x/\\sqrt{\\varepsilon}}.\n$$\nUsing $u(0)=0$ yields $0=0+A+B$, hence $B=-A$. Using $u(1)=1$ yields $1=1+A\\left(e^{1/\\sqrt{\\varepsilon}}-e^{-1/\\sqrt{\\varepsilon}}\\right)$, which forces $A=0$. Therefore the exact solution is simply\n$$\nu(x)=x.\n$$\n\nNonuniform-grid second derivative:\nWe discretize $(0,1)$ using a strictly increasing nonuniform grid $\\{x_j\\}_{j=0}^{N-1}$ with $x_0=0$ and $x_{N-1}=1$. Define $h_L=x_j-x_{j-1}$ and $h_R=x_{j+1}-x_j$ at an interior index $j$ with $1\\le j\\le N-2$. Starting from Taylor expansions of a smooth function $u(x)$ about $x_j$, we have\n$$\nu(x_{j+1})=u(x_j)+h_R\\,u'(x_j)+\\tfrac{1}{2}h_R^2\\,u''(x_j)+\\tfrac{1}{6}h_R^3\\,u^{(3)}(\\xi_R),\n$$\n$$\nu(x_{j-1})=u(x_j)-h_L\\,u'(x_j)+\\tfrac{1}{2}h_L^2\\,u''(x_j)-\\tfrac{1}{6}h_L^3\\,u^{(3)}(\\xi_L),\n$$\nfor some $\\xi_R\\in(x_j,x_{j+1})$ and $\\xi_L\\in(x_{j-1},x_j)$. Subtracting consecutive first differences,\n$$\n\\frac{u(x_{j+1})-u(x_j)}{h_R}-\\frac{u(x_j)-u(x_{j-1})}{h_L}\n= \\left(\\frac{h_R+h_L}{2}\\right)u''(x_j)+\\mathcal{O}(h_R^2+h_L^2).\n$$\nSolving for $u''(x_j)$ yields the well-known nonuniform three-point formula derived from first principles,\n$$\nu''(x_j)\\approx \\frac{2}{h_L+h_R}\\left(\\frac{u_{j+1}-u_j}{h_R}-\\frac{u_j-u_{j-1}}{h_L}\\right),\n$$\nwhich is second-order accurate provided $u$ is sufficiently smooth.\n\nDiscrete system:\nWe enforce the differential equation at interior nodes $j=1,\\ldots,N-2$:\n$$\n-\\varepsilon\\,\\frac{2}{h_L+h_R}\\left(\\frac{u_{j+1}-u_j}{h_R}-\\frac{u_j-u_{j-1}}{h_L}\\right)+u_j=x_j.\n$$\nCollecting coefficients of $u_{j-1}$, $u_j$, and $u_{j+1}$, we obtain a tridiagonal linear system $A\\mathbf{u}=\\mathbf{b}$ with\n- For interior $j$,\n$$\na_{j,j-1}=-\\varepsilon\\,\\frac{2}{h_L\\,(h_L+h_R)},\\quad\na_{j,j}=\\varepsilon\\,\\frac{2}{h_L+h_R}\\left(\\frac{1}{h_L}+\\frac{1}{h_R}\\right)+1,\\quad\na_{j,j+1}=-\\varepsilon\\,\\frac{2}{h_R\\,(h_L+h_R)},\n$$\nand $b_j=x_j$.\n- For boundary rows, we impose $u_0=0$ and $u_{N-1}=1$ exactly by setting $a_{0,0}=1$, $b_0=0$, and $a_{N-1,N-1}=1$, $b_{N-1}=1$, with the other entries in those rows equal to $0$.\n\nGrid clustering:\nWe construct nonuniform grids through mappings $\\phi:[0,1]\\to[0,1]$ applied to a uniform parameter grid $s_j=j/(N-1)$. Two clustering mappings are used:\n- Left clustering (toward $x=0$): $x_j=\\phi_{\\text{left}}(s_j)=s_j^p$ with $p\\ge 1$; larger $p$ yields finer spacing near $x=0$.\n- Right clustering (toward $x=1$): $x_j=\\phi_{\\text{right}}(s_j)=1-(1-s_j)^p$; larger $p$ yields finer spacing near $x=1$.\n\nError measurement:\nWe compute the numerical solution $\\{u_j^{\\text{num}}\\}$ by solving the tridiagonal system and evaluate the exact solution $\\{u(x_j)\\}$ with $u(x)=x$. The maximum absolute nodal error is\n$$\nE_\\infty=\\max_{0\\le j\\le N-1}\\,|u_j^{\\text{num}}-u(x_j)|.\n$$\n\nAlgorithmic design:\n- Generate the grid for a given $(\\varepsilon,N,p)$ for both clustering strategies.\n- Assemble the tridiagonal system as above for each grid.\n- Solve each tridiagonal system using a direct Thomas algorithm, which is stable for strictly diagonally dominant tridiagonal systems; here, the presence of the $+u_j$ term ensures a positive diagonal, and the discretization is well-posed.\n- Compute $E_\\infty$ for both grids.\n- Repeat for each test case and round each error to $8$ decimal places.\n\nInsight:\nBecause the exact solution is $u(x)=x$, which is linear, note that the discrete nonuniform second-derivative operator constructed from neighboring slopes satisfies\n$$\n\\frac{u_{j+1}-u_j}{h_R}=\\frac{u_j-u_{j-1}}{h_L}=\\text{constant},\n$$\nso the discrete second derivative is exactly zero at every interior node on any nonuniform grid. Consequently, for any $\\varepsilon0$, the discrete interior equation reduces to $u_j=x_j$ and, together with the exact boundary conditions, the finite difference scheme reproduces the exact solution at the nodes up to floating-point roundoff. Therefore, both left and right clustering will yield vanishing errors within numerical precision for all test configurations, illustrating that clustering offers no advantage in this particular problem because the solution has no boundary layer and is globally linear.\n\nOutput format:\nFor the five specified configurations, the program outputs a single line containing a comma-separated list of pairs $[E_\\infty^{\\text{left}},E_\\infty^{\\text{right}}]$, each rounded to $8$ decimal places, with no spaces anywhere, in the order prescribed:\n$$\n\\big[\\,[E_\\infty^{\\text{left}},E_\\infty^{\\text{right}}],\\;[E_\\infty^{\\text{left}},E_\\infty^{\\text{right}}],\\;\\ldots\\big].\n$$",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef generate_grid(n: int, p: float, side: str) - np.ndarray:\n    \"\"\"\n    Generate a nonuniform grid on [0,1] with clustering controlled by exponent p = 1.\n    side='left'  - x = s^p\n    side='right' - x = 1 - (1 - s)^p\n    \"\"\"\n    s = np.linspace(0.0, 1.0, n)\n    if side == 'left':\n        x = s ** p\n    elif side == 'right':\n        x = 1.0 - (1.0 - s) ** p\n    else:\n        raise ValueError(\"side must be 'left' or 'right'\")\n    # Enforce exact endpoints\n    x[0] = 0.0\n    x[-1] = 1.0\n    # Ensure strictly increasing (within floating tolerance)\n    if not np.all(np.diff(x)  0.0):\n        raise ValueError(\"Generated grid is not strictly increasing\")\n    return x\n\ndef assemble_tridiagonal(eps: float, x: np.ndarray):\n    \"\"\"\n    Assemble the tridiagonal system A u = b for the BVP:\n      -eps * u'' + u = x  on (0,1), with u(0)=0, u(1)=1\n    using the nonuniform 3-point second derivative approximation.\n    Returns (a, b, c, rhs) where:\n      a: sub-diagonal (length n) with a[0] unused (can be 0)\n      b: main diagonal (length n)\n      c: super-diagonal (length n) with c[-1] unused (can be 0)\n      rhs: right-hand side vector (length n)\n    \"\"\"\n    n = x.size\n    a = np.zeros(n, dtype=float)\n    b = np.zeros(n, dtype=float)\n    c = np.zeros(n, dtype=float)\n    rhs = np.zeros(n, dtype=float)\n\n    # Boundary rows for Dirichlet conditions\n    b[0] = 1.0\n    rhs[0] = 0.0\n    b[-1] = 1.0\n    rhs[-1] = 1.0\n\n    # Interior rows\n    for j in range(1, n - 1):\n        hL = x[j] - x[j - 1]\n        hR = x[j + 1] - x[j]\n        denom = hL + hR\n        # Coefficients based on: u''(x_j) â‰ˆ 2/(hL+hR) * ((u_{j+1}-u_j)/hR - (u_j - u_{j-1})/hL)\n        a[j] = -eps * (2.0 / (hL * denom))\n        c[j] = -eps * (2.0 / (hR * denom))\n        b[j] = eps * (2.0 / denom) * (1.0 / hL + 1.0 / hR) + 1.0\n        rhs[j] = x[j]\n\n    return a, b, c, rhs\n\ndef solve_tridiagonal(a: np.ndarray, b: np.ndarray, c: np.ndarray, d: np.ndarray) - np.ndarray:\n    \"\"\"\n    Solve a tridiagonal system with sub-diagonal a, main diagonal b, super-diagonal c,\n    and right-hand side d using the Thomas algorithm.\n    Assumes:\n      - a[0] is unused (0), c[-1] is unused (0).\n    \"\"\"\n    n = b.size\n    cp = np.zeros(n, dtype=float)\n    dp = np.zeros(n, dtype=float)\n    x = np.zeros(n, dtype=float)\n\n    # Forward sweep\n    beta = b[0]\n    if beta == 0.0:\n        raise ZeroDivisionError(\"Zero pivot encountered at row 0\")\n    cp[0] = c[0] / beta\n    dp[0] = d[0] / beta\n    for i in range(1, n):\n        denom = b[i] - a[i] * cp[i - 1]\n        if denom == 0.0:\n            # Very unlikely due to +1 on diagonal; protect against exact zero\n            denom = np.finfo(float).eps\n        if i  n - 1:\n            cp[i] = c[i] / denom\n        dp[i] = (d[i] - a[i] * dp[i - 1]) / denom\n\n    # Back substitution\n    x[-1] = dp[-1]\n    for i in range(n - 2, -1, -1):\n        x[i] = dp[i] - cp[i] * x[i + 1]\n\n    return x\n\ndef max_abs_error(u_num: np.ndarray, x: np.ndarray) - float:\n    \"\"\"\n    Compute max absolute nodal error against the exact solution u(x)=x.\n    \"\"\"\n    u_exact = x  # exact solution is u(x)=x\n    err = np.max(np.abs(u_num - u_exact))\n    return err\n\ndef sanitize_float(x: float, tol: float = 0.5e-8) - float:\n    \"\"\"\n    Avoid printing negative zeros after rounding.\n    \"\"\"\n    return 0.0 if abs(x)  tol else x\n\ndef format_results_nested(list_of_pairs):\n    \"\"\"\n    Format a list of [float, float] pairs into a single string without spaces,\n    each float with exactly 8 digits after the decimal point.\n    \"\"\"\n    def fmt_float(val: float) - str:\n        # Round to 8 decimals and sanitize near-zero negatives\n        val = round(val, 8)\n        val = sanitize_float(val)\n        return f\"{val:.8f}\"\n    inner_strs = []\n    for pair in list_of_pairs:\n        s = \"[\" + \",\".join(fmt_float(v) for v in pair) + \"]\"\n        inner_strs.append(s)\n    return \"[\" + \",\".join(inner_strs) + \"]\"\n\ndef solve():\n    # Define the test cases from the problem statement as (epsilon, N, p).\n    test_cases = [\n        (1e-2, 41, 3.0),\n        (1e-6, 41, 3.0),\n        (1e-2, 5, 3.0),\n        (1.0, 41, 3.0),\n        (1e-2, 101, 5.0),\n    ]\n\n    results = []\n    for eps, n, p in test_cases:\n        # Left clustering grid\n        x_left = generate_grid(n, p, side='left')\n        a, b, c, rhs = assemble_tridiagonal(eps, x_left)\n        u_left = solve_tridiagonal(a, b, c, rhs)\n        err_left = max_abs_error(u_left, x_left)\n\n        # Right clustering grid\n        x_right = generate_grid(n, p, side='right')\n        a, b, c, rhs = assemble_tridiagonal(eps, x_right)\n        u_right = solve_tridiagonal(a, b, c, rhs)\n        err_right = max_abs_error(u_right, x_right)\n\n        results.append([err_left, err_right])\n\n    # Final print statement in the exact required format:\n    # a single line, no spaces, each float with 8 digits after the decimal point.\n    print(format_results_nested(results))\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}