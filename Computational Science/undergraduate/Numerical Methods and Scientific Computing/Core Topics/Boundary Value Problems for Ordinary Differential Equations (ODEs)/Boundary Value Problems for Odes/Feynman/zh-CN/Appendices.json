{
    "hands_on_practices": [
        {
            "introduction": "理论是必要的，但真正的理解来自于实践。本节的第一个练习将指导你从头开始构建一个有限差分求解器。我们将使用一种称为“人造解”(manufactured solution)的强大验证技术，确保我们的数值方法能够精确求解一个具有已知解析解的边界值问题。这个练习将为你后续更复杂的挑战奠定坚实的编程和概念基础。",
            "id": "3104017",
            "problem": "考虑一个在区间 $[0,1]$ 上的常微分方程（ODE）的线性两点边值问题（BVP）的制造解基准问题。精确解被指定为 $u(x)=e^{x}-x$，狄利克雷边界条件为 $u(0)=1$ 和 $u(1)=e-1$。您的任务：\n\n1) 推导一个线性的、常系数的、右端项为多项式的二阶常微分方程，使得精确解 $u(x)=e^{x}-x$ 满足该常微分方程和边界条件。从一阶和二阶导数的定义出发，计算 $u'(x)$ 和 $u''(x)$ 来构建一个形如 $u''(x)-u(x)=g(x)$ 的常微分方程，然后确定使 $u(x)$ 成为精确解的 $g(x)$。\n\n2) 在均匀网格 $x_{i}=ih$（其中 $i\\in\\{0,1,\\dots,N+1\\}$，$N$ 是内部点数，$h=1/(N+1)$）上离散化得到的边值问题。使用从泰勒展开推导出的二阶导数的中心差分近似，为未知数 $\\{u_{1},u_{2},\\dots,u_{N}\\}$ 建立相应的三对角线性系统，并强制执行边界条件 $u_{0}=1$ 和 $u_{N+1}=e-1$。\n\n3) 实现一个完整、可运行的程序，该程序：\n- 为测试集 $N\\in\\{1,10,20,40\\}$ 中的每个 $N$ 构建并求解三对角线性系统。\n- 重构包含边界值的网格函数，并计算所有网格点 $x_{i}$（$i\\in\\{0,1,\\dots,N+1\\}$）上与精确解 $u(x)=e^{x}-x$ 相比的最大绝对误差。\n- 对于每个 $N$，以浮点数形式报告最大绝对误差，四舍五入到八位小数。\n\n您可以使用的基础知识：\n- 一阶导数 $u'(x)=\\lim_{h\\to 0}\\dfrac{u(x+h)-u(x)}{h}$ 和二阶导数 $u''(x)=\\lim_{h\\to 0}\\dfrac{u(x+h)-2u(x)+u(x-h)}{h^{2}}$ 的定义。\n- 对于一个足够光滑的函数，在点 $x$ 处的泰勒展开。\n- 用于求解线性系统的标准线性代数。\n\n科学真实性要求：\n- 纯粹在数学术语下工作，不涉及物理单位。\n- 不涉及角度和百分比。\n\n测试集和输出规范：\n- 使用测试集 $N\\in\\{1,10,20,40\\}$。\n- 对于每个 $N$，计算包括端点在内的整个网格上的最大绝对误差。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按测试集 $N$ 值的顺序排列。每个条目必须四舍五入到八位小数。例如，一个包含三个假设结果的输出应如下所示：[$r_{1},$ $r_{2},$ $r_{3}$]，其中每个 $r_{k}$ 是一个四舍五入到八位小数的十进制数。\n- 程序必须是自包含的，并且不需要用户输入。",
            "solution": "用户提供的问题是数值分析中一个明确定义的练习，具体来说是有限差分法在两点边值问题（BVP）上的应用。该问题是有效的，因为它在数学上是合理的、自包含的且客观的。它基于微积分和数值方法的既定原理。所有提供的数据，包括制造解和边界条件，都是一致的。\n$u(x) = e^x - x$\n$u(0) = e^0 - 0 = 1$\n$u(1) = e^1 - 1 = e-1$\n边界条件陈述正确。该问题将按要求分三部分解决。\n\n### 第1部分：边值问题的推导\n\n问题要求推导一个形如 $u''(x) - u(x) = g(x)$ 的线性、常系数二阶常微分方程，其精确解为 $u(x) = e^x - x$。\n\n首先，我们计算给定解 $u(x)$ 的一阶和二阶导数。\n精确解为：\n$$u(x) = e^x - x$$\n\n一阶导数 $u'(x)$ 为：\n$$u'(x) = \\frac{d}{dx}(e^x - x) = e^x - 1$$\n\n二阶导数 $u''(x)$ 为：\n$$u''(x) = \\frac{d}{dx}(e^x - 1) = e^x$$\n\n现在，我们将 $u(x)$ 和 $u''(x)$ 代入指定的常微分方程形式 $u''(x) - u(x) = g(x)$，以找到右端项函数 $g(x)$：\n$$g(x) = u''(x) - u(x) = (e^x) - (e^x - x)$$\n$$g(x) = e^x - e^x + x = x$$\n\n函数 $g(x) = x$ 是一个多项式，符合要求。因此，完整的边值问题是：\n$$\n\\begin{cases}\nu''(x) - u(x) = x,  x \\in [0, 1] \\\\\nu(0) = 1 \\\\\nu(1) = e - 1\n\\end{cases}\n$$\n\n### 第2部分：离散化与线性系统的构建\n\n接下来，我们使用有限差分法在均匀网格上离散化推导出的边值问题。域 $[0, 1]$ 被划分为 $N+1$ 个等宽的子区间，宽度为 $h = 1/(N+1)$。网格点为 $x_i = ih$，其中 $i = 0, 1, \\dots, N+1$。解在这些网格点上的值表示为 $u_i = u(x_i)$。\n\n常微分方程 $u''(x) - u(x) = x$ 必须在每个内部网格点 $x_i$（$i = 1, 2, \\dots, N$）上成立：\n$$u''(x_i) - u(x_i) = x_i$$\n\n我们使用二阶中心差分公式来近似二阶导数 $u''(x_i)$：\n$$u''(x_i) \\approx \\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2}$$\n\n将此近似代入常微分方程，得到一个关于未知内部值 $\\{u_1, u_2, \\dots, u_N\\}$ 的代数方程组：\n$$\\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2} - u_i = x_i, \\quad \\text{for } i = 1, 2, \\dots, N$$\n\n为了构成一个线性系统，我们重新整理方程，将包含未知数的项归到左侧：\n$$u_{i-1} - 2u_i - h^2 u_i + u_{i+1} = h^2 x_i$$\n$$1 \\cdot u_{i-1} + (-2 - h^2)u_i + 1 \\cdot u_{i+1} = h^2 (ih) = ih^3$$\n\n这 $N$ 个方程构成一个三对角线性系统 $A\\mathbf{u} = \\mathbf{b}$，其中 $\\mathbf{u} = [u_1, u_2, \\dots, u_N]^T$。\n\n$N \\times N$ 矩阵 $A$ 具有以下结构：\n- 主对角线元素：$A_{ii} = -2 - h^2$\n- 次对角线元素：$A_{i, i-1} = 1$\n- 超对角线元素：$A_{i, i+1} = 1$\n\n$$A = \\begin{pmatrix}\n-2-h^2  & 1  & 0  & \\dots  & 0 \\\\\n1  & -2-h^2  & 1  & \\dots  & 0 \\\\\n0  & 1  & -2-h^2  & \\ddots  & \\vdots \\\\\n\\vdots  & \\ddots  & \\ddots  & \\ddots  & 1 \\\\\n0  & \\dots  & 0  & 1  & -2-h^2\n\\end{pmatrix}$$\n\n右端项向量 $\\mathbf{b}$ 是一个 $N \\times 1$ 的列向量。我们必须合并给定的狄利克雷边界条件，$u_0 = 1$ 和 $u_{N+1} = e-1$。\n\n对于第一个方程（$i=1$）：\n$$u_0 + (-2 - h^2)u_1 + u_2 = 1 \\cdot h^3$$\n由于 $u_0 = 1$ 已知，我们将其移到右侧：\n$$(-2 - h^2)u_1 + u_2 = h^3 - u_0 = h^3 - 1$$\n因此，向量 $\\mathbf{b}$ 的第一个元素是 $b_1 = h^3 - 1$。\n\n对于最后一个方程（$i=N$）：\n$$u_{N-1} + (-2 - h^2)u_N + u_{N+1} = N h^3$$\n由于 $u_{N+1} = e-1$ 已知，我们将其移到右侧：\n$$u_{N-1} + (-2 - h^2)u_N = Nh^3 - u_{N+1} = Nh^3 - (e-1)$$\n因此，向量 $\\mathbf{b}$ 的最后一个元素是 $b_N = Nh^3 - e + 1$。\n\n对于一般的内部方程（$i=2, \\dots, N-1$）：\n$$u_{i-1} + (-2-h^2)u_i + u_{i+1} = ih^3$$\n$\\mathbf{b}$ 的相应元素是 $b_i = ih^3$。\n\n总之，右端项向量 $\\mathbf{b} = [b_1, b_2, \\dots, b_N]^T$ 是：\n$$b_i = \\begin{cases}\nh^3 - 1  & \\text{if } i=1 \\\\\nih^3  & \\text{if } 2 \\le i \\le N-1 \\\\\nNh^3 - (e-1)  & \\text{if } i=N\n\\end{cases}$$\n这种构造能正确处理 $N=1$ 的情况，因为 $i=1$ 和 $i=N$ 的条件都将应用于 $b_1$，导致 $b_1 = (h^3-1) - (e-1) = h^3 - e$，这对于单个方程 $u_0 + (-2-h^2)u_1 + u_2 = h^3 \\implies (-2-h^2)u_1 = h^3 - u_0 - u_2$ 是正确的。\n\n### 第3部分：实现算法\n\n实现将为测试集 $\\{1, 10, 20, 40\\}$ 中的每个 $N$ 值执行以下步骤：\n1.  **初始化参数**：计算步长 $h = 1/(N+1)$ 和 $e$ 的值。\n2.  **构建线性系统**：\n    -   以适用于高效求解器（例如 `scipy.linalg.solve_banded`）的带状格式创建三对角矩阵 $A$。这需要创建一个 $3 \\times N$ 的数组，其中各行分别代表超对角线、主对角线和次对角线。\n    -   根据第2部分推导的公式构造大小为 $N$ 的右端项向量 $\\mathbf{b}$。\n3.  **求解系统**：求解线性系统 $A\\mathbf{u} = \\mathbf{b}$，得到内部解向量 $\\mathbf{u} = [u_1, \\dots, u_N]^T$。\n4.  **重构完整解**：组装完整的数值解向量，包括边界值：$U_{num} = [u_0, u_1, \\dots, u_N, u_{N+1}] = [1, \\mathbf{u}^T, e-1]^T$。\n5.  **计算精确解**：创建网格点向量 $X = [x_0, x_1, \\dots, x_{N+1}]$，其中 $x_i = ih$。在每个网格点上计算精确解 $u(x) = e^x - x$，得到向量 $U_{exact}$。\n6.  **计算误差**：计算所有网格点上数值解与精确解之间的最大绝对误差：$E_{max} = \\max_{i \\in \\{0, \\dots, N+1\\}} |U_{num, i} - U_{exact, i}|$。\n7.  **存储并格式化结果**：将计算出的最大误差四舍五入到八位小数并存储。处理完所有 $N$ 值后，将收集到的结果格式化为指定的字符串格式。\n\n此过程将按要求封装在一个使用 `numpy` 和 `scipy` 库的 Python 程序中。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Solves the BVP u''(x) - u(x) = x on [0,1] with u(0)=1, u(1)=e-1\n    using a finite difference scheme for a given set of N values.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [1, 10, 20, 40]\n\n    results = []\n    for N in test_cases:\n        # Step 1: Initialize Parameters\n        # N: number of interior points\n        # There are N+2 total points (including boundaries)\n        h = 1.0 / (N + 1)\n        \n        # Exact boundary values\n        u0 = 1.0\n        uN_plus_1 = np.e - 1.0\n\n        # Step 2: Construct the tridiagonal linear system A*u = b\n        \n        # Construct the tridiagonal matrix A in banded format for SciPy.\n        # The format is a (3, N) array:\n        # Row 0: Super-diagonal (padded with a 0 at the start)\n        # Row 1: Main diagonal\n        # Row 2: Sub-diagonal (padded with a 0 at the end)\n        ab = np.zeros((3, N))\n        ab[0, 1:] = 1.0  # Super-diagonal\n        ab[1, :] = -2.0 - h**2  # Main diagonal\n        ab[2, :-1] = 1.0  # Sub-diagonal\n\n        # Construct the right-hand side vector b\n        # Start with the base value b_i = i * h^3\n        b = np.array([(i + 1) * h**3 for i in range(N)])\n        \n        # Incorporate boundary conditions\n        b[0] -= u0\n        b[-1] -= uN_plus_1\n        \n        # Step 3: Solve the system for the interior points u\n        u_interior = solve_banded((1, 1), ab, b)\n        \n        # Step 4: Reconstruct the full numerical solution grid function\n        u_numerical = np.concatenate(([u0], u_interior, [uN_plus_1]))\n\n        # Step 5: Compute the exact solution at grid points\n        # Grid points x_i = i*h for i = 0, ..., N+1\n        x = np.linspace(0, 1, N + 2)\n        u_exact = np.exp(x) - x\n\n        # Step 6: Calculate the maximum absolute error\n        # The error at the boundaries is zero by construction (up to float precision)\n        max_error = np.max(np.abs(u_numerical - u_exact))\n        \n        # Add the rounded result to the list\n        results.append(max_error)\n\n    # Final print statement in the exact required format.\n    # Each result is formatted to eight decimal places.\n    formatted_results = [f\"{res:.8f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了狄利克雷(Dirichlet)边界条件后，我们来处理一种更复杂但同样常见的情况：诺伊曼(Neumann)边界条件，它规定了函数在边界上的导数值。为了在不牺牲二阶精度的情况下处理这类条件，我们将引入并实现一种称为“虚拟点”(ghost point)的经典技巧。这个练习对于解决更广泛的物理和工程问题至关重要，因为在这些问题中，边界上的通量或梯度是已知的。",
            "id": "3211343",
            "problem": "您的任务是设计并实现一个二阶有限差分求解器，用于求解带诺伊曼边界条件的一维常微分方程边值问题。数学模型是线性泊松方程\n$$\nu''(x) = f(x), \\quad x \\in [0,1],\n$$\n在左端点有诺伊曼边界条件，在右端点有狄利克雷边界条件：\n$$\nu'(0) = \\alpha, \\quad u(1) = \\beta.\n$$\n您必须使用一个均匀网格，将区间 $[0,1]$ 分成 $m$ 个相等的子区间，网格点为 $x_i = i h$，其中 $h = 1/m$ 且 $i = 0,1,\\dots,m$。您的数值方法必须：\n- 在内部节点处使用标准的二阶中心差分来近似二阶导数。\n- 在 $x=0$ 处使用“虚拟点”实现诺伊曼条件，使得边界处的导数由中心差分近似，并通过调用常微分方程 $u''(x)=f(x)$ 和适当的泰勒展开来消去虚拟点，以保持二阶精度。设计必须从基本定义（网格、泰勒展开和常微分方程）出发，避免使用特定公式。\n- 在 $x=1$ 处引入狄利克雷边界条件，并确保在最后一个内部节点处保持二阶精度。\n\n您的程序必须求解内部未知数 $u(x_i)$（其中 $i=1,2,\\dots,m-1$）的离散线性系统，然后评估内部网格点 $\\{x_i\\}_{i=1}^{m-1}$ 上相对于精确解析解的最大绝对误差。\n\n为了进行验证，通过对 $u''(x)=f(x)$ 积分两次并使用边界条件来确定积分常数，从而推导出精确的解析解。对于下方的每个测试用例，程序必须计算：\n- 使用您在 $x=0$ 处采用虚拟点处理的二阶格式计算出的内部网格点上的数值解。\n- 相同内部网格点上的精确解。\n- 内部点上的最大绝对误差（逐点误差向量的无穷范数），表示为一个实数。\n\n此外，对于收敛性评估测试，计算观测到的精度阶 $p$，其定义为\n$$\np = \\log_2\\left(\\frac{E_{h}}{E_{h/2}}\\right),\n$$\n其中 $E_{h}$ 和 $E_{h/2}$ 分别是使用 $m$ 和 $2m$ 个子区间的网格所对应的最大绝对误差。\n\n使用以下测试套件：\n1. 理想情况：$f(x) = 2$，$\\alpha = 1$，$\\beta = 0$， $m = 50$。通过求解 $u''(x)=2$ 并应用给定的边界条件找到精确解。\n2. 边界条件主导的粗网格：$f(x) = 0$，$\\alpha = 0$，$\\beta = 1$， $m = 4$。精确解是一个常数。\n3. 振荡强迫项：$f(x) = -\\pi^2 \\sin(\\pi x)$，$\\alpha = 0$，$\\beta = 0$， $m = 64$。通过求解 $u''(x) = -\\pi^2 \\sin(\\pi x)$ 并应用给定的边界条件获得精确解。\n4. 收敛阶：$f(x) = x$，$\\alpha = 0$，$\\beta = 0$，使用两个网格 $m=20$ 和 $m=40$。计算如上定义的观测阶 $p$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按上述测试套件的顺序列出结果。前三个条目必须是表示每种情况下最大绝对误差的实数，最后一个条目必须是表示收敛性测试的观测阶的实数。例如，输出应类似于 $[e_1,e_2,e_3,p]$，其中每个 $e_i$ 和 $p$ 都是实数。",
            "solution": "用户提供的问题是有效的，因为它在科学上基于常微分方程数值方法理论，在数学上是适定的，并且由客观、形式化的标准定义。本文档为验证提供了数值方法和解析解的完整推导。\n\n问题是在区间 $x \\in [0,1]$ 上求解一维泊松方程，这是一个线性二阶常微分方程（ODE）：\n$$\nu''(x) = f(x)\n$$\n其在 $x=0$ 处有诺伊曼边界条件，在 $x=1$ 处有狄利克雷边界条件：\n$$\nu'(0) = \\alpha, \\quad u(1) = \\beta.\n$$\n\n我们将构建一个二阶有限差分格式来近似解。\n\n**1. 区域的离散化**\n\n区域 $[0,1]$ 被离散化为一个具有 $m$ 个子区间的均匀网格。网格间距为 $h = 1/m$。网格点定义为 $x_i = i h$，其中 $i = 0, 1, \\dots, m$。设 $U_i$ 是在网格点 $x_i$ 处精确解 $u(x_i)$ 的数值近似。$x=1$ 处的边界条件给出 $U_m = u(1) = \\beta$。待定的值为 $U_0, U_1, \\dots, U_{m-1}$。\n\n**2. 内部点的有限差分近似**\n\n对于任何内部网格点 $x_i$（其中 $i = 1, 2, \\dots, m-1$），我们使用二阶中心差分公式来近似二阶导数 $u''(x_i)$。这是通过围绕 $x_i$ 对 $u(x_{i+1})$ 和 $u(x_{i-1})$ 进行泰勒级数展开得到的：\n$$\nu(x_{i+1}) = u(x_i+h) = u(x_i) + h u'(x_i) + \\frac{h^2}{2} u''(x_i) + \\frac{h^3}{6} u'''(x_i) + O(h^4)\n$$\n$$\nu(x_{i-1}) = u(x_i-h) = u(x_i) - h u'(x_i) + \\frac{h^2}{2} u''(x_i) - \\frac{h^3}{6} u'''(x_i) + O(h^4)\n$$\n将这两个展开式相加并整理得到 $u''(x_i)$：\n$$\nu''(x_i) = \\frac{u(x_{i+1}) - 2u(x_i) + u(x_{i-1})}{h^2} - \\frac{h^2}{12} u^{(4)}(x_i) + \\dots\n$$\n该近似是二阶精度的，局部截断误差为 $O(h^2)$。将 $u(x_i)$ 替换为 $U_i$，并根据常微分方程将 $u''(x_i)$ 替换为 $f(x_i)$，我们得到内部节点的离散方程：\n$$\n\\frac{U_{i-1} - 2U_i + U_{i+1}}{h^2} = f(x_i), \\quad \\text{for } i = 1, 2, \\dots, m-1.\n$$\n\n**3. $x=0$ 处诺伊曼边界条件的离散化**\n\n该问题要求使用虚拟点来保持二阶精度。我们在 $x_{-1} = -h$ 处引入一个虚拟点。\n首先，我们使用在 $x_0 = 0$ 处的二阶中心差分来近似导数 $u'(0) = \\alpha$：\n$$\nu'(0) = \\frac{u(x_1) - u(x_{-1})}{2h} + O(h^2) \\implies \\frac{U_1 - U_{-1}}{2h} = \\alpha\n$$\n这给出了虚拟点值 $U_{-1}$ 的表达式：\n$$\nU_{-1} = U_1 - 2h\\alpha\n$$\n接下来，我们假设常微分方程 $u''(x) = f(x)$ 在边界点 $x_0=0$ 处也成立。我们对 $u''(0)$ 应用中心差分公式：\n$$\n\\frac{U_{-1} - 2U_0 + U_1}{h^2} = f(x_0)\n$$\n现在，我们通过将 $U_{-1}$ 的表达式代入此方程来消去虚拟点：\n$$\n\\frac{(U_1 - 2h\\alpha) - 2U_0 + U_1}{h^2} = f(x_0)\n$$\n化简该表达式得到节点 $i=0$ 的方程：\n$$\n\\frac{-2U_0 + 2U_1 - 2h\\alpha}{h^2} = f(x_0) \\implies -2U_0 + 2U_1 = h^2 f(x_0) + 2h\\alpha\n$$\n这个边界格式的局部截断误差是 $O(h^2)$，这足以确保整个方法的全局误差为 $O(h^2)$。\n\n**4. 线性系统的组装**\n\n我们有一个包含 $m$ 个线性方程的方程组，用于求解 $m$ 个未知数 $U_0, U_1, \\dots, U_{m-1}$。设 $\\mathbf{U} = [U_0, U_1, \\dots, U_{m-1}]^T$ 是未知向量。该系统可以写成 $A \\mathbf{U} = \\mathbf{b}$。\n\n方程如下：\n- 对于 $i=0$: $-2U_0 + 2U_1 = h^2 f(x_0) + 2h\\alpha$\n- 对于 $i=1, \\dots, m-2$: $U_{i-1} - 2U_i + U_{i+1} = h^2 f(x_i)$\n- 对于 $i=m-1$: $U_{m-2} - 2U_{m-1} + U_m = h^2 f(x_{m-1})$。由于 $U_m = \\beta$，这变为 $U_{m-2} - 2U_{m-1} = h^2 f(x_{m-1}) - \\beta$。\n\n$m \\times m$ 的系数矩阵 $A$ 是：\n$$\nA = \\begin{pmatrix}\n-2  & 2  & 0  & \\cdots  & \\cdots  & 0 \\\\\n1  & -2  & 1  & \\ddots   &   & \\vdots \\\\\n0  & 1  & -2  & 1  & \\ddots  & \\vdots \\\\\n\\vdots  & \\ddots  & \\ddots  & \\ddots  & \\ddots  & 0 \\\\\n\\vdots   &   & \\ddots  & 1  & -2  & 1 \\\\\n0  & \\cdots  & \\cdots  & 0  & 1  & -2\n\\end{pmatrix}\n$$\n大小为 $m$ 的右端向量 $\\mathbf{b}$ 是：\n$$\n\\mathbf{b} = \\begin{pmatrix}\nh^2 f(x_0) + 2h\\alpha \\\\\nh^2 f(x_1) \\\\\n\\vdots \\\\\nh^2 f(x_{m-2}) \\\\\nh^2 f(x_{m-1}) - \\beta\n\\end{pmatrix}\n$$\n这个线性系统 $A \\mathbf{U} = \\mathbf{b}$ 是非奇异的，可以求解以找到数值解 $\\mathbf{U}$。\n\n**5. 误差计算与收敛阶**\n\n最大绝对误差 $E_h$ 在内部网格点 $\\{x_i\\}_{i=1}^{m-1}$ 上计算，作为误差向量的无穷范数：\n$$\nE_h = \\max_{i=1,\\dots,m-1} |U_i - u(x_i)|\n$$\n对于一个二阶精度的方法，误差预期的行为是 $E_h \\approx C h^2$，其中 $C$ 是某个常数。通过比较两种不同网格尺寸 $h$ 和 $h/2$ 的误差，可以数值上观察到精度阶 $p$。\n$$\nE_h \\approx C h^p \\quad \\text{and} \\quad E_{h/2} \\approx C (h/2)^p\n$$\n两式相除得到 $\\frac{E_h}{E_{h/2}} \\approx 2^p$。解出 $p$ 得到：\n$$\np = \\log_2\\left(\\frac{E_{h}}{E_{h/2}}\\right)\n$$\n\n**6. 测试用例的解析解**\n\n精确解 $u(x)$ 是通过对 $u''(x) = f(x)$ 积分两次，并应用边界条件 $u'(0) = \\alpha$ 和 $u(1) = \\beta$ 来确定积分常数而得到的。\n\n- **用例1：** $f(x) = 2$, $\\alpha = 1$, $\\beta = 0$.\n$u'' = 2 \\implies u'(x) = 2x+C_1$。$u'(0)=C_1=1$。因此 $u'(x)=2x+1$。\n$u(x) = x^2+x+C_2$。$u(1)=1+1+C_2=0 \\implies C_2=-2$。\n$u(x) = x^2+x-2$。\n\n- **用例2：** $f(x) = 0$, $\\alpha = 0$, $\\beta = 1$.\n$u'' = 0 \\implies u'(x) = C_1$。$u'(0)=C_1=0$。因此 $u'(x)=0$。\n$u(x) = C_2$。$u(1)=C_2=1$。\n$u(x) = 1$。\n\n- **用例3：** $f(x) = -\\pi^2 \\sin(\\pi x)$, $\\alpha = 0$, $\\beta = 0$.\n$u''(x) = -\\pi^2 \\sin(\\pi x) \\implies u'(x) = \\pi \\cos(\\pi x)+C_1$。$u'(0)=\\pi+C_1=0 \\implies C_1=-\\pi$。\n$u'(x) = \\pi \\cos(\\pi x) - \\pi$。\n$u(x) = \\sin(\\pi x) - \\pi x + C_2$。$u(1)=\\sin(\\pi)-\\pi+C_2=0 \\implies C_2=\\pi$。\n$u(x) = \\sin(\\pi x) - \\pi x + \\pi$。\n\n- **用例4：** $f(x) = x$, $\\alpha = 0$, $\\beta = 0$.\n$u''(x) = x \\implies u'(x) = x^2/2+C_1$。$u'(0)=C_1=0$。因此 $u'(x)=x^2/2$。\n$u(x) = x^3/6+C_2$。$u(1)=1/6+C_2=0 \\implies C_2=-1/6$。\n$u(x) = \\frac{x^3}{6} - \\frac{1}{6}$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the finite difference solver.\n    \"\"\"\n\n    def run_solver(f, alpha, beta, m):\n        \"\"\"\n        Solves u''(x) = f(x) with u'(0)=alpha, u(1)=beta on a grid with m subdivisions.\n        \n        Args:\n            f (callable): The forcing function f(x).\n            alpha (float): The Neumann boundary condition value at x=0.\n            beta (float): The Dirichlet boundary condition value at x=1.\n            m (int): The number of grid subdivisions.\n            \n        Returns:\n            tuple: A tuple containing:\n                - np.ndarray: Grid points for the interior, x_1, ..., x_{m-1}.\n                - np.ndarray: Numerical solution at the interior points, U_1, ..., U_{m-1}.\n        \"\"\"\n        # Grid setup\n        h = 1.0 / m\n        # We solve for unknowns at x_0, x_1, ..., x_{m-1}\n        x_nodes = np.linspace(0, 1, m + 1)\n        \n        # Assemble the m x m matrix A\n        A = np.zeros((m, m))\n        \n        # Fill diagonals for the standard interior stencil (1, -2, 1)\n        np.fill_diagonal(A, -2.0)\n        # Lower diagonal (k=-1): A[i, i-1] = 1 for i=1,...,m-1\n        np.fill_diagonal(A[1:], 1.0)\n        # Upper diagonal (k=1): A[i, i+1] = 1 for i=0,...,m-2\n        np.fill_diagonal(A[:, 1:], 1.0)\n        \n        # Modify the first row for the Neumann condition: -2*U_0 + 2*U_1 = ...\n        A[0, 0] = -2.0\n        A[0, 1] = 2.0\n        \n        # Assemble the right-hand side vector b of size m\n        # We evaluate f at x_0, ..., x_{m-1}\n        b = h**2 * f(x_nodes[0:m])\n        \n        # Modify first and last elements of b for boundary conditions\n        # b_0 = h^2*f(x_0) + 2*h*alpha\n        b[0] += 2.0 * h * alpha\n        # b_{m-1} = h^2*f(x_{m-1}) - beta\n        b[m-1] -= beta\n        \n        # Solve the linear system A*U = b for U = [U_0, ..., U_{m-1}]\n        U = np.linalg.solve(A, b)\n        \n        # Return interior grid points and corresponding solution values\n        return x_nodes[1:m], U[1:]\n\n    results = []\n\n    # Test Case 1: Happy path\n    f1 = lambda x: 2.0 * np.ones_like(x)\n    u_exact1 = lambda x: x**2 + x - 2.0\n    alpha1, beta1, m1 = 1.0, 0.0, 50\n    x_interior1, U_interior1 = run_solver(f1, alpha1, beta1, m1)\n    u_exact_vals1 = u_exact1(x_interior1)\n    error1 = np.max(np.abs(U_interior1 - u_exact_vals1))\n    results.append(error1)\n\n    # Test Case 2: Boundary-condition-dominant coarse grid\n    f2 = lambda x: np.zeros_like(x)\n    u_exact2 = lambda x: np.ones_like(x)\n    alpha2, beta2, m2 = 0.0, 1.0, 4\n    x_interior2, U_interior2 = run_solver(f2, alpha2, beta2, m2)\n    u_exact_vals2 = u_exact2(x_interior2)\n    error2 = np.max(np.abs(U_interior2 - u_exact_vals2))\n    results.append(error2)\n\n    # Test Case 3: Oscillatory forcing\n    f3 = lambda x: -np.pi**2 * np.sin(np.pi * x)\n    u_exact3 = lambda x: np.sin(np.pi * x) - np.pi * x + np.pi\n    alpha3, beta3, m3 = 0.0, 0.0, 64\n    x_interior3, U_interior3 = run_solver(f3, alpha3, beta3, m3)\n    u_exact_vals3 = u_exact3(x_interior3)\n    error3 = np.max(np.abs(U_interior3 - u_exact_vals3))\n    results.append(error3)\n\n    # Test Case 4: Convergence order\n    f4 = lambda x: x\n    u_exact4 = lambda x: x**3 / 6.0 - 1.0 / 6.0\n    alpha4, beta4 = 0.0, 0.0\n    \n    # Solve on grid with m=20\n    m_h = 20\n    x_h, U_h = run_solver(f4, alpha4, beta4, m_h)\n    u_h = u_exact4(x_h)\n    E_h = np.max(np.abs(U_h - u_h))\n    \n    # Solve on grid with m=40\n    m_h2 = 40\n    x_h2, U_h2 = run_solver(f4, alpha4, beta4, m_h2)\n    u_h2 = u_exact4(x_h2)\n    E_h2 = np.max(np.abs(U_h2 - u_h2))\n    \n    order_p = np.log2(E_h / E_h2)\n    results.append(order_p)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "现实世界的问题很少能用均匀的网格完美捕捉，尤其是在解的某些区域变化剧烈时。这个练习将带你进入非均匀网格的世界，你将亲自推导并实现适用于任意网格间距的有限差分格式。通过一个精心设计的边界值问题，你不仅能验证你推导的正确性，还能深刻体会到数值方法的误差是如何与待求解的函数本身的性质紧密相关的。",
            "id": "3103893",
            "problem": "要求您构建一个完整的、可运行的程序，以研究网格聚类对使用非均匀网格上的有限差分法求解一维常微分方程边值问题数值解的影响。该边值问题是线性的二阶两点问题\n$$\n-\\varepsilon\\,u''(x)+u(x)=x,\\quad x\\in(0,1),\\qquad u(0)=0,\\quad u(1)=1,\n$$\n其中 $\\varepsilon>0$ 是一个参数。您的任务是从第一性原理出发，推导并实现一种规范的非均匀网格有限差分方法，然后针对两种不同的网格聚类策略测量误差。\n\n使用以下内容作为基本基础：\n- 一阶和二阶导数的定义、线性二阶边值问题解的存在性和唯一性，以及光滑函数在某点周围的 Taylor 展开。\n- 网格映射 $\\phi:[0,1]\\to[0,1]$ 的概念，用于从均匀参数 $s\\in[0,1]$ 生成非均匀网格。\n- 在非均匀网格上使用三点模板的有限差分法，通过局部 Taylor 展开和差分从第一性原理推导得出。\n\n不要使用任何来自外部参考文献的预先推导好的离散算子公式。相反，应使用 Taylor 展开和导数的定义来推导非均匀二阶导数近似，以构建内部节点上的三点二阶导数近似。通过直接强制施加给定的边界条件来处理边界值。\n\n网格生成：\n- 设 $N$ 为网格点（包括端点）的数量。\n- 定义均匀参数网格 $s_j=j/(N-1)$，其中 $j=0,1,\\ldots,N-1$。\n- 定义一个聚类指数 $p\\ge 1$，并通过以下方式生成两个物理网格 $x_j$：\n  - 左聚类：$x_j=\\phi_{\\text{left}}(s_j)=s_j^p$。\n  - 右聚类：$x_j=\\phi_{\\text{right}}(s_j)=1-(1-s_j)^p$。\n两个网格都必须满足 $x_0=0$ 和 $x_{N-1}=1$，是严格递增的，并且随着 $p$ 的增大，分别在 $x=0$ 或 $x=1$ 附近变得更加聚类。\n\n离散化：\n- 在非均匀网格 $\\{x_j\\}_{j=0}^{N-1}$上，对内部点 $j=1,\\ldots,N-2$ 处的 $u''(x_j)$，仅使用相邻值 $u_{j-1}$、$u_j$ 和 $u_{j+1}$ 推导一个三点近似。从 $u(x)$ 在 $x_j$ 点的 Taylor 展开开始，并一致地消除高阶项，以获得在非均匀网格上二阶精确的近似。\n- 构建得到的线性系统，该系统代表了内部点处 $-\\varepsilon u''(x_j)+u(x_j)=x_j$ 的离散版本，并精确地强制施加边界条件 $u_0=0$ 和 $u_{N-1}=1$。\n\n解析参考解：\n- 推导边值问题的解析解，用于测量数值误差。使用求解常系数线性常微分方程的基本方法，并应用边界条件。\n\n误差测量：\n- 对于每种网格策略（左聚类和右聚类）和下面的每个测试配置，计算相同网格点上的数值解 $\\{u_j^{\\text{num}}\\}$ 和解析参考值 $\\{u(x_j)\\}$。报告最大绝对节点误差\n$$\nE_\\infty=\\max_{0\\le j\\le N-1}\\,|u_j^{\\text{num}}-u(x_j)|.\n$$\n\n程序要求：\n- 实现您推导的非均匀有限差分法。\n- 为得到的线性系统实现一个直接三对角求解器。\n- 按规定实现两种网格映射。\n- 使用您推导的解析解来计算节点误差。\n- 不允许用户输入；程序必须能直接运行并打印所要求的结果。\n\n测试套件：\n评估并报告以下五个配置的误差，按顺序列出。每个配置是一个三元组 $(\\varepsilon,N,p)$：\n1. $(10^{-2},\\,41,\\,3)$\n2. $(10^{-6},\\,41,\\,3)$\n3. $(10^{-2},\\,5,\\,3)$\n4. $(1,\\,41,\\,3)$\n5. $(10^{-2},\\,101,\\,5)$\n\n输出规范：\n- 对于每个配置，计算两个浮点误差值：左聚类的 $E_\\infty^{\\text{left}}$ 和右聚类的 $E_\\infty^{\\text{right}}$。\n- 将报告的每个误差四舍五入到8位小数。\n- 您的程序应生成单行输出，其中包含五个双元素列表的逗号分隔列表，顺序与测试套件相同，其中每个内部列表的格式不含空格，每个浮点数以定点小数表示法打印，小数点后恰好有8位数字。例如，像下面这样的行\n[ [0.12345678,0.23456789], [ ... ], ... ]\n由于有空格是不可接受的；相反，确切要求的格式是：\n[[0.12345678,0.23456789],[...],...]\n\n单位：\n- 该问题是无量纲的；不适用任何物理单位。",
            "solution": "我们从边值问题开始\n$$\n-\\varepsilon\\,u''(x)+u(x)=x,\\quad x\\in(0,1),\\qquad u(0)=0,\\quad u(1)=1,\n$$\n其中 $\\varepsilon>0$。该控制方程是线性的，具有常系数和线性的右侧项。\n\n解析参考解：\n我们首先推导精确解，以便进行误差测量。齐次方程为 $-\\varepsilon u''(x)+u(x)=0$，可重排为 $u''(x)=(1/\\varepsilon)u(x)$。其通解是\n$$\nu_h(x)=A\\,e^{x/\\sqrt{\\varepsilon}}+B\\,e^{-x/\\sqrt{\\varepsilon}},\n$$\n其中 $A$ 和 $B$ 是常数。$-\\varepsilon u''(x)+u(x)=x$ 的一个特解可以通过待定系数法猜测。设 $u_p(x)=\\alpha x+\\beta$。那么 $u_p''(x)=0$，代入得到 $-\\varepsilon\\cdot 0 + (\\alpha x+\\beta)=x$，这意味着 $\\alpha=1$ 和 $\\beta=0$。因此 $u_p(x)=x$。通解是\n$$\nu(x)=x+A\\,e^{x/\\sqrt{\\varepsilon}}+B\\,e^{-x/\\sqrt{\\varepsilon}}.\n$$\n使用 $u(0)=0$ 得到 $0=0+A+B$，因此 $B=-A$。使用 $u(1)=1$ 得到 $1=1+A\\left(e^{1/\\sqrt{\\varepsilon}}-e^{-1/\\sqrt{\\varepsilon}}\\right)$，这迫使 $A=0$。因此，精确解就是\n$$\nu(x)=x.\n$$\n\n非均匀网格的二阶导数：\n我们使用一个严格递增的非均匀网格 $\\{x_j\\}_{j=0}^{N-1}$ 对 $(0,1)$ 进行离散化，其中 $x_0=0$ 且 $x_{N-1}=1$。在内部索引 $j$ 处（$1\\le j\\le N-2$），定义 $h_L=x_j-x_{j-1}$ 和 $h_R=x_{j+1}-x_j$。从光滑函数 $u(x)$ 在 $x_j$ 点的 Taylor 展开开始，我们有\n$$\nu(x_{j+1})=u(x_j)+h_R\\,u'(x_j)+\\tfrac{1}{2}h_R^2\\,u''(x_j)+\\tfrac{1}{6}h_R^3\\,u^{(3)}(\\xi_R),\n$$\n$$\nu(x_{j-1})=u(x_j)-h_L\\,u'(x_j)+\\tfrac{1}{2}h_L^2\\,u''(x_j)-\\tfrac{1}{6}h_L^3\\,u^{(3)}(\\xi_L),\n$$\n对于某个 $\\xi_R\\in(x_j,x_{j+1})$ 和 $\\xi_L\\in(x_{j-1},x_j)$。通过线性组合这两个展开式以消除 $u'(x_j)$ 项，可以推导出著名的非均匀三点公式：\n$$\nu''(x_j)\\approx \\frac{2}{h_L+h_R}\\left(\\frac{u_{j+1}-u_j}{h_R}-\\frac{u_j-u_{j-1}}{h_L}\\right),\n$$\n只要 $u$ 足够光滑，该公式的截断误差就是 $\\mathcal{O}(h_R - h_L)$，即一阶精度，除非网格是平滑变化的。\n\n离散系统：\n我们在内部节点 $j=1,\\ldots,N-2$ 处强制执行微分方程：\n$$\n-\\varepsilon\\,\\frac{2}{h_L+h_R}\\left(\\frac{u_{j+1}-u_j}{h_R}-\\frac{u_j-u_{j-1}}{h_L}\\right)+u_j=x_j.\n$$\n收集 $u_{j-1}$、$u_j$ 和 $u_{j+1}$ 的系数，我们得到一个三对角线性系统 $A\\mathbf{u}=\\mathbf{b}$，其中未知向量 $\\mathbf{u}=[u_1, \\ldots, u_{N-2}]^T$。\n\n对于内部方程 $j=1, \\ldots, N-2$：\n$$\n\\left(-\\varepsilon \\frac{2}{h_L(h_L+h_R)}\\right) u_{j-1} + \\left(1 + \\varepsilon \\frac{2}{h_L h_R}\\right) u_j + \\left(-\\varepsilon \\frac{2}{h_R(h_L+h_R)}\\right) u_{j+1} = x_j\n$$\n边界条件 $u_0=0$ 和 $u_{N-1}=1$ 被移到右侧。\n- 对 $j=1$: 第一个方程的 $u_0$ 项被移走，但由于 $u_0=0$，右侧不变。\n- 对 $j=N-2$: 最后一个方程的 $u_{N-1}$ 项被移到右侧。\n\n网格聚类：\n我们通过将映射 $\\phi:[0,1]\\to[0,1]$ 应用于均匀参数网格 $s_j=j/(N-1)$ 来构建非均匀网格。使用两种聚类映射：\n- 左聚类（朝向 $x=0$）：$x_j=\\phi_{\\text{left}}(s_j)=s_j^p$，其中 $p\\ge 1$；较大的 $p$ 会在 $x=0$ 附近产生更精细的间距。\n- 右聚类（朝向 $x=1$）：$x_j=\\phi_{\\text{right}}(s_j)=1-(1-s_j)^p$；较大的 $p$ 会在 $x=1$ 附近产生更精细的间距。\n\n误差测量：\n我们通过求解三对角系统来计算数值解 $\\{u_j^{\\text{num}}\\}$，并使用 $u(x)=x$ 来评估精确解 $\\{u(x_j)\\}$。最大绝对节点误差是\n$$\nE_\\infty=\\max_{0\\le j\\le N-1}\\,|u_j^{\\text{num}}-u(x_j)|.\n$$\n\n洞察：\n因为精确解是线性的 $u(x)=x$，其二阶导数在解析上为零。有限差分算子，即使在非均匀网格上，对于线性函数也是精确的。也就是说，对于 $u(x)=x$，我们有 $u_j = x_j$。因此\n$$\n\\frac{u_{j+1}-u_j}{h_R} = \\frac{x_{j+1}-x_j}{h_R} = 1 \\quad \\text{and} \\quad \\frac{u_j-u_{j-1}}{h_L} = \\frac{x_j-x_{j-1}}{h_L} = 1.\n$$\n代入二阶导数近似公式，我们得到 $u''(x_j) \\approx 0$。因此，离散的内部方程简化为 $-\\varepsilon \\cdot 0 + u_j = x_j \\implies u_j=x_j$。结合精确的边界条件 $u_0=0=x_0$ 和 $u_{N-1}=1=x_{N-1}$，有限差分格式在节点上再现了精确解，误差仅为浮点舍入误差。因此，对于所有测试配置，左聚类和右聚类都将产生在数值精度范围内的零误差。\n\n输出格式：\n对于五个指定的配置，程序输出单行，包含一个逗号分隔的 $[E_\\infty^{\\text{left}},E_\\infty^{\\text{right}}]$ 对的列表，每个值都四舍五入到8位小数，在任何地方都没有空格，并按规定的顺序排列：\n$$\n[[E_\\infty^{\\text{left}},E_\\infty^{\\text{right}}],[E_\\infty^{\\text{left}},E_\\infty^{\\text{right}}],\\ldots]\n$$",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef generate_grid(n: int, p: float, side: str) -> np.ndarray:\n    \"\"\"\n    Generate a nonuniform grid on [0,1] with clustering controlled by exponent p >= 1.\n    side='left'  -> x = s^p\n    side='right' -> x = 1 - (1 - s)^p\n    \"\"\"\n    s = np.linspace(0.0, 1.0, n)\n    if side == 'left':\n        x = s ** p\n    elif side == 'right':\n        x = 1.0 - (1.0 - s) ** p\n    else:\n        raise ValueError(\"side must be 'left' or 'right'\")\n    # Enforce exact endpoints\n    x[0] = 0.0\n    x[-1] = 1.0\n    return x\n\ndef assemble_and_solve(eps: float, x: np.ndarray):\n    \"\"\"\n    Assemble and solve the tridiagonal system for the BVP:\n      -eps * u'' + u = x  on (0,1), with u(0)=0, u(1)=1\n    using a custom Thomas algorithm implementation for the tridiagonal solver.\n    \"\"\"\n    n = x.size\n    n_int = n - 2\n    if n_int <= 0:\n        # Handle trivial cases with no interior points\n        return np.array([0.0, 1.0]) if n == 2 else np.array([0.0]) if n==1 else np.array([])\n\n    a = np.zeros(n_int)  # sub-diagonal\n    b = np.zeros(n_int)  # main diagonal\n    c = np.zeros(n_int)  # super-diagonal\n    rhs = np.zeros(n_int)\n\n    # Boundary values\n    u0 = 0.0\n    u_n_minus_1 = 1.0\n\n    # Build system for interior points u_1, ..., u_{n-2}\n    for i in range(n_int):\n        j = i + 1  # grid index\n        hL = x[j] - x[j - 1]\n        hR = x[j + 1] - x[j]\n        denom_sum = hL + hR\n\n        coeff_L = -eps * (2.0 / (hL * denom_sum))\n        coeff_R = -eps * (2.0 / (hR * denom_sum))\n        coeff_C = 1.0 + eps * (2.0 / (hL * hR))\n        \n        b[i] = coeff_C\n        rhs[i] = x[j]\n\n        if i > 0:\n            a[i] = coeff_L\n        if i  n_int - 1:\n            c[i] = coeff_R\n\n        # Account for boundary conditions\n        if i == 0: # First interior point, j=1\n            rhs[i] -= coeff_L * u0\n        if i == n_int - 1: # Last interior point, j=n-2\n            rhs[i] -= coeff_R * u_n_minus_1\n\n    # Solve the tridiagonal system for interior points using Thomas algorithm\n    # Forward sweep\n    c_prime = np.zeros(n_int)\n    d_prime = np.zeros(n_int)\n    \n    # First row\n    beta = b[0]\n    if abs(beta)  1e-15: beta = 1e-15 # Avoid division by zero\n    c_prime[0] = c[0] / beta\n    d_prime[0] = rhs[0] / beta\n\n    for i in range(1, n_int):\n        denom = b[i] - a[i] * c_prime[i-1]\n        if abs(denom)  1e-15: denom = 1e-15 # Avoid division by zero\n        if i  n_int - 1:\n            c_prime[i] = c[i] / denom\n        d_prime[i] = (rhs[i] - a[i] * d_prime[i-1]) / denom\n\n    # Back substitution\n    u_int = np.zeros(n_int)\n    u_int[-1] = d_prime[-1]\n    for i in range(n_int - 2, -1, -1):\n        u_int[i] = d_prime[i] - c_prime[i] * u_int[i+1]\n\n    # Reconstruct full solution\n    u_full = np.concatenate(([u0], u_int, [u_n_minus_1]))\n    return u_full\n\n\ndef max_abs_error(u_num: np.ndarray, x: np.ndarray) -> float:\n    \"\"\"\n    Compute max absolute nodal error against the exact solution u(x)=x.\n    \"\"\"\n    if x.size != u_num.size or x.size == 0:\n        return 0.0\n    u_exact = x  # exact solution is u(x)=x\n    err = np.max(np.abs(u_num - u_exact))\n    return err\n\ndef format_results_nested(list_of_pairs):\n    \"\"\"\n    Format a list of [float, float] pairs into a single string without spaces,\n    each float with exactly 8 digits after the decimal point.\n    \"\"\"\n    def fmt_float(val: float) -> str:\n        # Round to 8 decimals and handle potential negative zero.\n        val_rounded = round(val, 8)\n        if abs(val_rounded)  1e-9: # Treat anything smaller than 1e-9 as zero\n            val_rounded = 0.0\n        return f\"{val_rounded:.8f}\"\n    \n    inner_strs = [f\"[{fmt_float(p[0])},{fmt_float(p[1])}]\" for p in list_of_pairs]\n    return f\"[{','.join(inner_strs)}]\"\n\ndef solve():\n    test_cases = [\n        (1e-2, 41, 3.0),\n        (1e-6, 41, 3.0),\n        (1e-2, 5, 3.0),\n        (1.0, 41, 3.0),\n        (1e-2, 101, 5.0),\n    ]\n\n    all_results = []\n    for eps, n, p in test_cases:\n        # Left clustering\n        x_left = generate_grid(n, p, side='left')\n        u_left = assemble_and_solve(eps, x_left)\n        err_left = max_abs_error(u_left, x_left)\n\n        # Right clustering\n        x_right = generate_grid(n, p, side='right')\n        u_right = assemble_and_solve(eps, x_right)\n        err_right = max_abs_error(u_right, x_right)\n        \n        all_results.append([err_left, err_right])\n\n    print(format_results_nested(all_results))\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}