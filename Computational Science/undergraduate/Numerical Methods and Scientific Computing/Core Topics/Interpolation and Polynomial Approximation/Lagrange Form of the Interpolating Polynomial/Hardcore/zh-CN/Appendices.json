{
    "hands_on_practices": [
        {
            "introduction": "此练习是掌握拉格朗日插值的第一步。它要求您直接运用拉格朗日基多项式的定义，为一组给定的数据点构建唯一的插值多项式。通过这个具体的计算过程，您将熟悉插值多项式的结构，并巩固对基多项式“筛选”特性的理解。",
            "id": "3246519",
            "problem": "令 $x_{0}, x_{1}, x_{2}, x_{3}$ 为前四个质数 $x_{0}=2$, $x_{1}=3$, $x_{2}=5$, $x_{3}=7$。定义给定数据值 $y_{0}=0$, $y_{1}=0$, $y_{2}=24$, $y_{3}=120$。仅使用拉格朗日基多项式的定义性质和穿过点集 $\\{(x_{i},y_{i})\\}_{i=0}^{3}$ 的至多 $3$ 次插值多项式的唯一性，构建满足 $p(x_{i})=y_{i}$ ($i=0,1,2,3$) 的唯一插值多项式 $p(x)$，将其化简为标准多项式形式，然后计算 $p(11)$。给出 $p(11)$ 的精确值，无需四舍五入。",
            "solution": "我们回顾拉格朗日基多项式的定义性质。给定不同的节点 $x_{0},\\dots,x_{n}$，第 $j$ 个拉格朗日基多项式 $L_{j}(x)$ 定义为\n$$\nL_{j}(x)=\\prod_{\\substack{i=0 \\\\ i\\neq j}}^{n} \\frac{x-x_{i}}{x_{j}-x_{i}},\n$$\n它满足基本性质 $L_{j}(x_{i})=\\delta_{ij}$，其中 $\\delta_{ij}$ 是克罗内克 delta 符号。那么对数据 $\\{(x_{i},y_{i})\\}_{i=0}^{n}$ 进行插值的、次数至多为 $n$ 的唯一多项式 $p(x)$ 由下式给出\n$$\np(x)=\\sum_{j=0}^{n} y_{j}\\,L_{j}(x).\n$$\n在我们的问题中，$n=3$，节点为 $x_{0}=2$, $x_{1}=3$, $x_{2}=5$, $x_{3}=7$，值为 $y_{0}=0$, $y_{1}=0$, $y_{2}=24$, $y_{3}=120$。因为 $y_{0}=0$ 和 $y_{1}=0$，插值多项式简化为\n$$\np(x)=y_{2}\\,L_{2}(x)+y_{3}\\,L_{3}(x)=24\\,L_{2}(x)+120\\,L_{3}(x).\n$$\n我们显式地计算 $L_{2}(x)$ 和 $L_{3}(x)$。\n\n对于 $x_{2}=5$ 的 $L_{2}(x)$，\n$$\nL_{2}(x)=\\frac{(x-x_{0})(x-x_{1})(x-x_{3})}{(x_{2}-x_{0})(x_{2}-x_{1})(x_{2}-x_{3})}\n=\\frac{(x-2)(x-3)(x-7)}{(5-2)(5-3)(5-7)}\n=\\frac{(x-2)(x-3)(x-7)}{3\\cdot 2\\cdot(-2)}\n=-\\frac{(x-2)(x-3)(x-7)}{12}.\n$$\n对于 $x_{3}=7$ 的 $L_{3}(x)$，\n$$\nL_{3}(x)=\\frac{(x-x_{0})(x-x_{1})(x-x_{2})}{(x_{3}-x_{0})(x_{3}-x_{1})(x_{3}-x_{2})}\n=\\frac{(x-2)(x-3)(x-5)}{(7-2)(7-3)(7-5)}\n=\\frac{(x-2)(x-3)(x-5)}{5\\cdot 4\\cdot 2}\n=\\frac{(x-2)(x-3)(x-5)}{40}.\n$$\n因此，\n$$\np(x)=24\\left(-\\frac{(x-2)(x-3)(x-7)}{12}\\right)+120\\left(\\frac{(x-2)(x-3)(x-5)}{40}\\right)\n=-2\\,(x-2)(x-3)(x-7)+3\\,(x-2)(x-3)(x-5).\n$$\n提出公因式 $(x-2)(x-3)$：\n$$\np(x)=(x-2)(x-3)\\left[-2(x-7)+3(x-5)\\right]=(x-2)(x-3)\\left[(-2x+14)+(3x-15)\\right].\n$$\n化简方括号内的部分：\n$$\n(-2x+14)+(3x-15)=x-1,\n$$\n因此\n$$\np(x)=(x-2)(x-3)(x-1)=(x-1)(x-2)(x-3).\n$$\n最后，在 $x=11$ 处求值：\n$$\np(11)=(11-1)(11-2)(11-3)=10\\cdot 9\\cdot 8=720.\n$$\n根据对于四个不同节点的至多 $3$ 次多项式插值的唯一性，这个 $p(x)$ 是唯一的插值多项式，计算出的 $p(11)$ 是精确值。",
            "answer": "$$\\boxed{720}$$"
        },
        {
            "introduction": "这个练习超越了简单的数值计算，旨在检验您对拉格朗日插值背后核心理论的理解。您将利用插值多项式的唯一性这一基本而强大的性质，来证明一个看似复杂的和式实际上等价于一个非常简单的函数。这个过程将加深您对拉格朗日基函数作为一组“基”的认识。",
            "id": "3246595",
            "problem": "设 $n$ 是一个正整数，并设 $x_0, x_1, \\dots, x_n$ 是 $n+1$ 个不同的实数节点。定义拉格朗日基多项式 $L_j(x)$（$j=0,1,\\dots,n$）为\n$$\nL_j(x) \\;=\\; \\prod_{\\substack{m=0 \\\\ m \\ne j}}^{n} \\frac{x - x_m}{x_j - x_m}.\n$$\n对于一个固定的整数 $k$，满足 $0 \\le k \\le n$，考虑多项式\n$$\nQ(x) \\;=\\; \\sum_{j=0}^{n} x_j^{k}\\, L_j(x).\n$$\n仅使用上述定义和多项式的基本性质，确定 $Q(x)$ 的闭式解，该解应为一个关于 $x$ 和 $k$ 的单一解析表达式。请以单个表达式的形式给出最终结果，而非方程式，且不包含任何单位。",
            "solution": "这个问题可以通过巧妙地应用拉格朗日插值多项式的唯一性来解决。\n\n考虑函数 $f(x) = x^k$。这是一个次数为 $k$ 的多项式。\n\n根据拉格朗日插值公式，对于一组节点 $\\{x_j\\}_{j=0}^n$ 和对应的函数值 $\\{f(x_j)\\}_{j=0}^n$，唯一的、次数至多为 $n$ 的插值多项式 $P(x)$ 是：\n$$\nP(x) = \\sum_{j=0}^{n} f(x_j) L_j(x)\n$$\n\n在我们的例子中，函数值是 $f(x_j) = x_j^k$。将这些值代入插值公式，我们得到：\n$$\nP(x) = \\sum_{j=0}^{n} x_j^k L_j(x)\n$$\n这正是问题中定义的 $Q(x)$。\n\n现在，我们来考察 $f(x) = x^k$ 本身。它是一个多项式，并且它的次数为 $k$。由于问题设定 $0 \\le k \\le n$，所以 $f(x)$ 的次数小于或等于 $n$。\n\n同时，$f(x)$ 显然满足所有插值条件，即 $f(x_j) = x_j^k$ 对所有 $j=0, \\dots, n$ 成立。\n\n根据**插值多项式的唯一性定理**：对于 $n+1$ 个不同的节点，存在唯一的、次数至多为 $n$ 的多项式满足插值条件。\n\n我们已经找到了两个满足这些条件的多项式：\n1. $Q(x)$，通过拉格朗日公式构造得出。\n2. $f(x) = x^k$ 本身。\n\n由于唯一性，这两个多项式必须是同一个多项式。因此，我们得出结论：\n$$\nQ(x) = x^k\n$$\n这个结果对于任意满足条件的 $x$ 和 $k$ 都成立。",
            "answer": "$$ \\boxed{x^{k}} $$"
        },
        {
            "introduction": "理论上的完美插值在实践中可能会遇到挑战，尤其是在处理不光滑函数时。本练习是一个计算实验，要求您对一个包含跳跃间断点的函数进行插值，并比较全局拉格朗日插值与局部（分段）逼近方法的表现。通过这个实践，您将直观地观察到高阶多项式插值的潜在问题（如龙格现象），并理解在不同场景下选择合适逼近策略的重要性。",
            "id": "3246671",
            "problem": "你需要编写一个完整的、可运行的程序，用于比较不连续函数 $f(x) = \\mathrm{sign}(x)$ 在区间 $[-1,1]$ 上的拉格朗日意义下的全局多项式插值与局部逐段多项式逼近。请从以下数值方法和科学计算的基本概念开始：\n- 插值的定义：给定 $[-1,1]$ 中的不同节点 $\\{x_i\\}_{i=0}^{n-1}$ 和数据 $\\{y_i\\}_{i=0}^{n-1}$，插值函数是一个函数 $p(x)$，使得对所有 $i$ 都有 $p(x_i) = y_i$。当 $p(x)$ 是一个次数至多为 $n-1$ 的多项式时，这定义了全局多项式插值。对于 $n$ 个不同的数据点，存在且唯一一个次数至多为 $n-1$ 的多项式与之匹配，这是数值分析中的一个基本事实。\n- 局部逐段多项式逼近的概念：使用节点将 $[-1,1]$ 划分为子区间。在每个子区间上，定义一个仅依赖于该子区间局部数据的逼近函数，例如逐段常数函数（在每个子区间上为 $0$ 次）或逐段线性函数（在每个子区间上为 $1$ 次）。\n- 用于误差度量的范数：对于在 $[-1,1]$ 上逼近 $f(x)$ 的函数 $g(x)$，在离散网格 $\\{x_j\\}$ 上的上确界范数误差是 $\\max_j |g(x_j) - f(x_j)|$，它逼近连续的 $L^\\infty$ 误差。\n\n你的程序必须实现：\n1. 一个全局多项式插值 $P_n(x)$，对于给定的节点 $\\{x_i\\}$ 和值 $y_i = f(x_i)$，它将所有点 $\\{(x_i,y_i)\\}$ 同时插值为 $[-1,1]$ 上的单个多项式。使用上面陈述的插值定义属性来构造 $P_n(x)$。\n2. 一个局部逐段线性逼近 $L_n(x)$，通过在每个子区间 $[x_i, x_{i+1}]$ 上进行线性插值构造，并约定如果 $x$ 等于一个节点 $x_i$，则 $L_n(x) = y_i$。\n3. 一个局部逐段常数逼近 $C_n(x)$，在每个子区间上通过将最近节点的采样值赋给 $x$ 来定义，即，对于由连续节点之间的中点确定的单元格中的 $x$，$C_n(x)$ 等于 $y_k$，其中 $x_k$ 是最接近 $x$ 的节点。\n\n函数 $f(x)$ 必须实现为：当 $x  0$ 时 $f(x) = -1$，当 $x = 0$ 时 $f(x) = 0$，当 $x > 0$ 时 $f(x) = 1$。你的程序必须在 $[-1,1]$ 上一个包含 $N=2001$ 个点的固定均匀网格上评估每个逼近函数，并计算离散上确界范数误差：\n$$\nE_\\infty(P_n) = \\max_{j} \\left| P_n(x_j) - f(x_j) \\right|,\\quad\nE_\\infty(L_n) = \\max_{j} \\left| L_n(x_j) - f(x_j) \\right|,\\quad\nE_\\infty(C_n) = \\max_{j} \\left| C_n(x_j) - f(x_j) \\right|.\n$$\n\n你必须根据以下规则生成节点：\n- 等距节点：对于给定的整数 $n \\ge 2$，通过 $x_i = -1 + \\dfrac{2i}{n-1}$ 定义 $\\{x_i\\}_{i=0}^{n-1}$。\n- 第一类切比雪夫节点：对于给定的整数 $n \\ge 2$，通过 $x_i = \\cos\\!\\left( \\dfrac{2i+1}{2n} \\pi \\right)$ 定义 $\\{x_i\\}_{i=0}^{n-1}$，所有角度均以弧度为单位。\n\n测试套件：\n使用包含 $N = 2001$ 个点的均匀评估网格，并为以下每个参数集计算三个上确界范数误差：\n- 情况 $\\mathsf{A}$ (理想情况)：等距节点，n = 9。\n- 情况 $\\mathsf{B}$ (备用节点分布)：切比雪夫节点，n = 9 (角度以弧度为单位)。\n- 情况 $\\mathsf{C}$ (小样本边界条件)：等距节点，n = 3。\n- 情况 $\\mathsf{D}$ (间断点不与节点对齐的边界情况)：等距节点，n = 10。\n- 情况 $\\mathsf{E}$ (切比雪夫节点下更大的样本量)：切比雪夫节点，n = 25 (角度以弧度为单位)。\n\n对于每种情况，你的程序必须按此确切顺序输出三个浮点误差 $E_\\infty(P_n)$、$E_\\infty(L_n)$ 和 $E_\\infty(C_n)$。将所有情况的结果汇总到单行输出中，该行包含一个由方括号括起来的、包含 $15$ 个值的逗号分隔连接列表。每个浮点数必须四舍五入到小数点后恰好 $8$ 位。\n\n最终输出格式示例 (说明性；非实际值)：\n$$\n[\\text{caseA}_P,\\text{caseA}_L,\\text{caseA}_C,\\text{caseB}_P,\\ldots,\\text{caseE}_C]\n$$\n其中每个条目是格式化为小数点后八位的浮点数。不得打印任何其他文本。",
            "solution": "该问题要求对不连续的符号函数 $f(x) = \\mathrm{sign}(x)$ 在区间 $[-1, 1]$ 上比较三种数值逼近方案。这些方案是全局多项式插值、逐段线性插值和逐段常数逼近。比较基于在一个精细的均匀网格上评估的离散上确界范数误差。\n\n待逼近的函数定义为：\n$$\nf(x) =\n\\begin{cases}\n-1  \\text{if } x  0 \\\\\n0  \\text{if } x = 0 \\\\\n1  \\text{if } x > 0\n\\end{cases}\n$$\n该函数在 $x=0$ 处有一个跳跃间断点，这对依赖于光滑性的逼近方法，特别是全局多项式插值，构成了一个重大挑战。\n\n逼近函数 $g(x)$ 的误差是在 $[-1, 1]$ 上的一个包含 $N=2001$ 个点的均匀评估网格 $\\{z_j\\}_{j=0}^{N-1}$ 上度量的。度量标准是离散上确界范数 $E_\\infty$，定义为：\n$$\nE_\\infty(g) = \\max_{0 \\le j  N} |g(z_j) - f(z_j)|\n$$\n\n逼近方案是基于一组 $n$ 个不同的节点 $\\{x_i\\}_{i=0}^{n-1}$ 和相应的函数值 $\\{y_i\\}_{i=0}^{n-1}$ 构建的，其中 $y_i = f(x_i)$。指定了两种类型的节点分布：\n1.  **等距节点**：$x_i = -1 + \\frac{2i}{n-1}$，对于 $i=0, \\dots, n-1$。这些节点是均匀分布的。\n2.  **切比雪夫节点 (第一类)**：$x_i = \\cos\\left( \\frac{(2i+1)\\pi}{2n} \\right)$，对于 $i=0, \\dots, n-1$。这些节点是n次切比雪夫多项式 $T_n(x)$ 的根，它们在区间端点附近更密集地聚集。已知此特性可有效减轻与等距节点上的高次多项式插值相关的大幅度振荡（龙格现象）。\n\n三种逼近方法的实现如下：\n\n**1. 全局多项式插值 ($P_n(x)$)**\n对于一组给定的包含 $n$ 个数据点 $\\{(x_i, y_i)\\}_{i=0}^{n-1}$ 且节点 $x_i$ 各不相同的数据，存在一个唯一的次数至多为 $n-1$ 的多项式 $P_n(x)$，使得对所有 $i$ 都有 $P_n(x_i) = y_i$。该多项式可以用单项式基写为 $P_n(x) = \\sum_{k=0}^{n-1} c_k x^k$。系数 $\\{c_k\\}$ 可以通过求解以下线性方程组得到：\n$$\n\\begin{pmatrix}\n1  x_0  x_0^2  \\cdots  x_0^{n-1} \\\\\n1  x_1  x_1^2  \\cdots  x_1^{n-1} \\\\\n\\vdots  \\vdots  \\vdots  \\ddots  \\vdots \\\\\n1  x_{n-1}  x_{n-1}^2  \\cdots  x_{n-1}^{n-1}\n\\end{pmatrix}\n\\begin{pmatrix}\nc_0 \\\\\nc_1 \\\\\n\\vdots \\\\\nc_{n-1}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\ny_0 \\\\\ny_1 \\\\\n\\vdots \\\\\ny_{n-1}\n\\end{pmatrix}\n$$\n左边的矩阵是范德蒙矩阵。虽然求解这个系统在概念上很简单，但范德蒙矩阵通常是病态的，特别是对于等距节点和较大的 $n$。通常首选数值稳定的算法，例如基于重心插值的算法，但对于给定的参数，求解该系统是可行的。实现将确定系数，然后在网格 $\\{z_j\\}$ 上评估所得多项式。对于不连续函数，$P_n(x)$ 预计在间断点附近表现出振荡行为（吉布斯现象），并且当 $n$ 增加时，最大误差不会收敛到零。\n\n**2. 局部逐段线性逼近 ($L_n(x)$)**\n该方法构造一个由线性段组成的连续函数。首先，将节点 $\\{x_i\\}$ 按升序排序，称之为 $\\{x'_i\\}$。在每个子区间 $[x'_i, x'_{i+1}]$ 上，逼近函数 $L_n(x)$ 是连接点 $(x'_i, y'_i)$ 和 $(x'_{i+1}, y'_{i+1})$ 的直线，其中 $y'_i = f(x'_i)$。这是一个局部方案，因为在任何给定子区间上的逼近函数的定义仅依赖于其两端的数据点。该方法的误差是有界的，并且对于具有跳跃间断点的函数，误差不会收敛到零。最大误差将约为跳跃大小的一半，即 $\\approx 1.0$，并将出现在跨越间断点的子区间中。\n\n**3. 局部逐段常数逼近 ($C_n(x)$)**\n这是最简单的局部逼近方案。定义域根据与节点的邻近度被划分为单元格。对于 $[-1, 1]$ 中的任何点 $x$，逼近函数 $C_n(x)$ 的值是 $y_k = f(x_k)$，其中 $x_k$ 是最接近 $x$ 的节点。如果节点排序为 $x'_0  x'_1  \\dots  x'_{n-1}$，则这些单元格的边界是中点 $m_i = (x'_i + x'_{i+1})/2$。对应于内部节点 $x'_i$ 的单元格是 $[m_{i-1}, m_i)$。对于评估网格中的任何点 $z$，我们找到它属于哪个单元格，并赋以相应节点的函数值。与逐段线性情况类似，对于 $f(x) = \\mathrm{sign}(x)$，误差将有界于大约 $1.0$ 并且不会收敛到零。\n\n程序将系统地执行指定的测试用例，每个用例由节点数 $n$ 及其分布定义，并计算三个误差范数 $E_\\infty(P_n)$、$E_\\infty(L_n)$ 和 $E_\\infty(C_n)$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Compares global polynomial interpolation vs. local piecewise approximants\n    for the signum function f(x) = sign(x) on [-1, 1].\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'type': 'equispaced', 'n': 9},\n        {'type': 'chebyshev', 'n': 9},\n        {'type': 'equispaced', 'n': 3},\n        {'type': 'equispaced', 'n': 10},\n        {'type': 'chebyshev', 'n': 25},\n    ]\n\n    # Define the high-resolution evaluation grid\n    N = 2001\n    z_eval = np.linspace(-1, 1, N)\n    \n    # Evaluate the true function f(x) = sign(x) on the grid\n    # np.sign(0) is 0, which matches the problem's definition.\n    f_eval = np.sign(z_eval)\n    \n    all_results = []\n\n    for case in test_cases:\n        n = case['n']\n        node_type = case['type']\n\n        # 1. Generate interpolation nodes and corresponding y-values\n        if node_type == 'equispaced':\n            x_nodes = np.linspace(-1, 1, n)\n        else:  # 'chebyshev'\n            # Generates nodes in descending order\n            i = np.arange(n)\n            x_nodes = np.cos((2 * i + 1) * np.pi / (2 * n))\n        \n        y_nodes = np.sign(x_nodes)\n\n        # 2. Global Polynomial Interpolant P_n(x)\n        # We find the coefficients of the unique polynomial of degree n-1\n        # and then evaluate it on the fine grid. This is equivalent to\n        # solving the Vandermonde system.\n        poly_coeffs = np.polyfit(x_nodes, y_nodes, n - 1)\n        p_vals = np.polyval(poly_coeffs, z_eval)\n        error_p = np.max(np.abs(p_vals - f_eval))\n\n        # 3. Local Piecewise Linear Approximant L_n(x)\n        # np.interp requires x-coordinates to be in increasing order.\n        # Chebyshev nodes are generated in descending order, so we flip them.\n        if x_nodes[0] > x_nodes[-1]:\n            x_sorted_for_L = np.flip(x_nodes)\n            y_sorted_for_L = np.flip(y_nodes)\n        else:\n            x_sorted_for_L = x_nodes\n            y_sorted_for_L = y_nodes\n        l_vals = np.interp(z_eval, x_sorted_for_L, y_sorted_for_L)\n        error_l = np.max(np.abs(l_vals - f_eval))\n\n        # 4. Local Piecewise Constant Approximant C_n(x)\n        # This approximant assigns the value of the nearest node.\n        # We first sort the nodes to define the cells via their midpoints.\n        sort_indices = np.argsort(x_nodes)\n        x_sorted = x_nodes[sort_indices]\n        y_sorted = y_nodes[sort_indices]\n        \n        # Midpoints define the boundaries of the \"nearest node\" cells.\n        midpoints = (x_sorted[:-1] + x_sorted[1:]) / 2.0\n        \n        # For each evaluation point, find the index of the cell it falls into.\n        # This index corresponds to the index of the closest node in x_sorted.\n        closest_node_indices = np.searchsorted(midpoints, z_eval)\n        \n        c_vals = y_sorted[closest_node_indices]\n        error_c = np.max(np.abs(c_vals - f_eval))\n\n        # 5. Collate errors for the current case\n        all_results.extend([error_p, error_l, error_c])\n\n    # Final print statement in the exact required format.\n    # Each floating-point number is rounded to exactly 8 decimal digits.\n    formatted_results = [f\"{val:.8f}\" for val in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}