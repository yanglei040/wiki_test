{
    "hands_on_practices": [
        {
            "introduction": "理论知识需要通过实践来巩固。我们的第一项动手实践从分段多项式插值最基本的形式——分段线性插值——开始。在深入研究更复杂的三次样条之前，掌握线性插值的构建方法及其误差分析至关重要。这个练习 (  ) 将指导你为函数 $f(x) = x^4$ 构建一个简单的分段线性插值函数，并分析其在不同子区间上的插值误差。通过这个过程，你将直观地理解插值误差是如何产生和分布的，并学会使用微积分工具来精确定位最大误差点。",
            "id": "2193842",
            "problem": "在数值分析中，分段插值是逼近复杂函数的一种常用方法。考虑定义在区间 $[-1, 1]$ 上的函数 $f(x) = x^4$。我们希望使用一个连续分段线性插值函数（记为 $L(x)$）来逼近这个函数。该插值函数使用节点 $x_0 = -1$，$x_1 = 0$ 和 $x_2 = 1$ 构建。在给定子区间上的插值误差定义为该子区间上函数与其插值函数之间的最大绝对差，即 $\\max |f(x) - L(x)|$。\n\n你的任务是确定在哪一个子区间（$[-1, 0]$ 或 $[0, 1]$）上，插值误差最大。\n\n从以下选项中选择正确的陈述。\n\nA. 子区间 $[-1, 0]$。\n\nB. 子区间 $[0, 1]$。\n\nC. 两个子区间上的最大误差相同。\n\nD. 最大误差出现在节点 $x=0$ 处，因此没有哪个子区间的误差唯一更大。\n\nE. 信息不足，无法确定结果。",
            "solution": "问题要求我们为区间 $[-1, 1]$ 上的函数 $f(x) = x^4$ 构建一个使用节点 $x = -1, 0, 1$ 的分段线性插值函数 $L(x)$，然后比较在子区间 $[-1, 0]$ 和 $[0, 1]$ 上的最大插值误差。\n\n首先，我们在给定的节点上计算函数 $f(x)$ 的值：\n$f(x_0) = f(-1) = (-1)^4 = 1$\n$f(x_1) = f(0) = 0^4 = 0$\n$f(x_2) = f(1) = 1^4 = 1$\n\n现在，我们为每个子区间构建线性插值函数。\n\n**子区间 1: $[-1, 0]$**\n线性插值函数（我们称之为 $L_1(x)$）是穿过点 $(x_0, f(x_0)) = (-1, 1)$ 和 $(x_1, f(x_1)) = (0, 0)$ 的直线。\n这条直线的斜率是 $m_1 = \\frac{f(x_1) - f(x_0)}{x_1 - x_0} = \\frac{0 - 1}{0 - (-1)} = -1$。\n使用点 $(0, 0)$ 的点斜式，直线方程为：\n$L_1(x) - 0 = -1(x - 0)$，简化后得到 $L_1(x) = -x$。\n\n该子区间上的误差函数是 $E_1(x) = f(x) - L_1(x) = x^4 + x$。\n为了找到最大绝对误差，我们需要求出 $E_1(x)$ 在 $[-1, 0]$ 上的极值。我们对 $x$ 求导数，并令其为零：\n$E_1'(x) = \\frac{d}{dx}(x^4 + x) = 4x^3 + 1$。\n令 $E_1'(x) = 0$ 得 $4x^3 = -1$，所以 $x^3 = -1/4$。\n临界点是 $x_c = \\sqrt[3]{-1/4} = -\\frac{1}{\\sqrt[3]{4}}$。\n这个值位于区间 $[-1, 0]$ 内。\n根据插值定义，区间端点（即节点）处的误差为零：$E_1(-1) = (-1)^4 + (-1) = 0$ 且 $E_1(0) = 0^4 + 0 = 0$。\n因此，最大绝对误差必定出现在临界点 $x_c$ 处。\n该点的误差为：\n$E_1(x_c) = \\left(-\\frac{1}{\\sqrt[3]{4}}\\right)^4 + \\left(-\\frac{1}{\\sqrt[3]{4}}\\right) = \\frac{1}{4\\sqrt[3]{4}} - \\frac{1}{\\sqrt[3]{4}} = \\frac{1 - 4}{4\\sqrt[3]{4}} = -\\frac{3}{4\\sqrt[3]{4}}$。\n$[-1, 0]$ 上的最大绝对误差为 $|E_1(x_c)| = \\frac{3}{4\\sqrt[3]{4}}$。\n\n**子区间 2: $[0, 1]$**\n线性插值函数（我们称之为 $L_2(x)$）是穿过点 $(x_1, f(x_1)) = (0, 0)$ 和 $(x_2, f(x_2)) = (1, 1)$ 的直线。\n这条直线的斜率是 $m_2 = \\frac{f(x_2) - f(x_1)}{x_2 - x_1} = \\frac{1 - 0}{1 - 0} = 1$。\n使用点 $(0, 0)$ 的点斜式，直线方程为：\n$L_2(x) - 0 = 1(x - 0)$，简化后得到 $L_2(x) = x$。\n\n该子区间上的误差函数是 $E_2(x) = f(x) - L_2(x) = x^4 - x$。\n为了找到最大绝对误差，我们求出 $E_2(x)$ 在 $[0, 1]$ 上的极值。我们求其导数：\n$E_2'(x) = \\frac{d}{dx}(x^4 - x) = 4x^3 - 1$。\n令 $E_2'(x) = 0$ 得 $4x^3 = 1$，所以 $x^3 = 1/4$。\n临界点是 $x_d = \\sqrt[3]{1/4} = \\frac{1}{\\sqrt[3]{4}}$。\n该值位于区间 $[0, 1]$ 内。\n端点处的误差为零：$E_2(0) = 0^4 - 0 = 0$ 且 $E_2(1) = 1^4 - 1 = 0$。\n最大绝对误差必定出现在临界点 $x_d$ 处。\n该点的误差为：\n$E_2(x_d) = \\left(\\frac{1}{\\sqrt[3]{4}}\\right)^4 - \\left(\\frac{1}{\\sqrt[3]{4}}\\right) = \\frac{1}{4\\sqrt[3]{4}} - \\frac{1}{\\sqrt[3]{4}} = \\frac{1 - 4}{4\\sqrt[3]{4}} = -\\frac{3}{4\\sqrt[3]{4}}$。\n$[0, 1]$ 上的最大绝对误差为 $|E_2(x_d)| = \\frac{3}{4\\sqrt[3]{4}}$。\n\n**比较**\n$[-1, 0]$ 上的最大绝对误差为 $\\frac{3}{4\\sqrt[3]{4}}$。\n$[0, 1]$ 上的最大绝对误差为 $\\frac{3}{4\\sqrt[3]{4}}$。\n两个子区间上的最大误差相同。\n\n**使用对称性的另一种推理**\n函数 $f(x)=x^4$ 是一个偶函数，即 $f(x) = f(-x)$。\n节点关于 $x=0$ 对称分布。\n分段线性插值函数为：当 $x \\in [-1, 0]$ 时，$L(x) = -x$；当 $x \\in [0, 1]$ 时，$L(x) = x$。这可以紧凑地写作 $L(x) = |x|$。\n函数 $L(x) = |x|$ 也是一个偶函数。\n误差函数 $E(x) = f(x) - L(x) = x^4 - |x|$ 是两个偶函数之差，因此它也是一个偶函数。\n对于偶函数 $E(x)$，$|E(x)|$ 的值与 $|E(-x)|$ 的值相同。\n这意味着误差分布关于 $x=0$ 对称。\n因此，区间 $[-1, 0]$ 上的最大误差必须等于区间 $[0, 1]$ 上的最大误差。\n\n根据两种分析方法，两个子区间上的最大误差是相同的。这对应于选项 C。\n选项 D 是不正确的，因为根据插值的定义，节点 $x=0$ 处的误差为零，这是最小误差，而不是最大误差。",
            "answer": "$$\\boxed{C}$$"
        },
        {
            "introduction": "虽然分段线性插值简单易懂，但其结果曲线在节点处不平滑（一阶导数不连续）。为了获得更平滑的曲线，我们通常会使用更高阶的多项式，例如三次样条。然而，平滑性的提升有时会带来意想不到的副作用。这项实践 (  ) 揭示了标准“自然”三次样条的一个关键缺陷：它不一定能保持原始数据的形状特征，比如单调性。即使给定的数据点是单调递增的，生成的插值曲线也可能在节点之间出现“摆动”或局部极值，这在科学和工程应用中可能是不可接受的。通过解决这个问题，你将亲身体会到为什么需要更先进的保形插值方法。",
            "id": "2193854",
            "problem": "自然三次样条是一种对一组数据点 `(x_i, y_i)` 进行插值的常用方法。如果一个函数 `S(x)` 是一个分段三次多项式，并且在被称为节点的数据点上连续且具有连续的一阶和二阶导数，那么它就是一个三次样条。如果一个样条的二阶导数在第一个和最后一个节点处为零，则称该样条为“自然的”。\n\n考虑一组三个单调递增的数据点：`P_0 = (0, 0)`、`P_1 = (1, 1/9)` 和 `P_2 = (2, 1)`。构建一个自然三次样条 `S(x)` 以穿过这三个点。\n\n尽管数据点是严格递增的，但得到的插值函数 `S(x)` 在整个区间 `[0, 2]` 上并不是单调的。可以证明，在子区间 `[0, 1]` 内存在一个局部极值。\n\n确定这个局部极值的x坐标。将你的最终答案四舍五入到四位有效数字。",
            "solution": "设节点为 $x_{0}=0$, $x_{1}=1$, $x_{2}=2$，对应的值为 $y_{0}=0$, $y_{1}=\\frac{1}{9}$, $y_{2}=1$。令 $h_{i}=x_{i+1}-x_{i}$，所以 $h_{0}=h_{1}=1$。对于自然三次样条，其在节点处的二阶导数 $M_{i}=S''(x_{i})$ 满足 $M_{0}=0$, $M_{2}=0$，以及对于内部节点 $i=1$ 的三对角系统：\n$$\nh_{0}M_{0}+2(h_{0}+h_{1})M_{1}+h_{1}M_{2}\n=6\\left(\\frac{y_{2}-y_{1}}{h_{1}}-\\frac{y_{1}-y_{0}}{h_{0}}\\right).\n$$\n代入数据可得\n$$\n4M_{1}=6\\left(\\left(1-\\frac{1}{9}\\right)-\\left(\\frac{1}{9}-0\\right)\\right)\n=6\\left(\\frac{8}{9}-\\frac{1}{9}\\right)=6\\cdot\\frac{7}{9}=\\frac{14}{3},\n$$\n所以\n$$\nM_{1}=\\frac{7}{6},\\quad M_{0}=0,\\quad M_{2}=0.\n$$\n\n在 $[x_{0},x_{1}]=[0,1]$ 上，该样条段为\n$$\nS_{0}(x)=\\frac{M_{0}(x_{1}-x)^{3}}{6h_{0}}+\\frac{M_{1}(x-x_{0})^{3}}{6h_{0}}+\\left(y_{0}-\\frac{M_{0}h_{0}^{2}}{6}\\right)\\frac{x_{1}-x}{h_{0}}+\\left(y_{1}-\\frac{M_{1}h_{0}^{2}}{6}\\right)\\frac{x-x_{0}}{h_{0}}.\n$$\n使用上述值，\n$$\nS_{0}(x)=\\frac{\\frac{7}{6}x^{3}}{6}+\\left(\\frac{1}{9}-\\frac{\\frac{7}{6}}{6}\\right)x=\\frac{7}{36}x^{3}-\\frac{1}{12}x.\n$$\n求导以找到临界点：\n$$\nS_{0}'(x)=\\frac{7}{12}x^{2}-\\frac{1}{12}.\n$$\n令 $S_{0}'(x)=0$ 可得\n$$\n\\frac{7}{12}x^{2}-\\frac{1}{12}=0\\;\\;\\Longrightarrow\\;\\;7x^{2}-1=0\\;\\;\\Longrightarrow\\;\\;x^{2}=\\frac{1}{7}.\n$$\n在区间 $[0,1]$ 内，临界点是\n$$\nx=\\frac{1}{\\sqrt{7}}.\n$$\n数值上，$\\frac{1}{\\sqrt{7}}\\approx 0.377964\\ldots$，四舍五入到四位有效数字为 $0.3780$。",
            "answer": "$$\\boxed{0.3780}$$"
        },
        {
            "introduction": "上一项实践暴露了标准三次样条在保持单调性方面的不足。那么，我们如何构建一个既平滑又能忠实反映数据趋势的插值函数呢？这个高级实践 (  ) 正是对此问题的回答，它要求你从第一性原理出发，设计并实现一个“保形分段三次 Hermite 插值多项式”(PCHIP)。你需要推导保证单调性的充分条件，并通过限制节点处的导数值来实现这一目标。这个练习是一个综合性的挑战，它将理论推导、算法设计和编程实践融为一体，最终让你能够构建一个在处理单调数据时行为可预测且稳健的插值工具。",
            "id": "3261829",
            "problem": "要求您从第一性原理出发，设计并实现一个保形分段三次埃尔米特插值多项式 (PCHIP)，该多项式需保证在输入数据值为单调时，其插值结果也必定是单调的。该插值函数应连续可微，并且必须穿过所有给定的数据点。单调性保证必须通过使用斜率限制策略来选择节点导数以实现，该策略强制施加足够的局部条件，从而在每个子区间上，当相应数据为非递减（或非递增）时，三次函数段具有非负（或非正）的导数。您的设计必须从三次埃尔米特插值的定义以及一个基本概念出发，即区间上三次函数的导数可以表示为一个二次函数，通过对其系数施加适当的界限，可以强制该二次函数在闭区间上非负。您不得先验地假设任何快捷公式；相反，您必须推导如何约束节点导数，以在数据单调时满足区间单调性。\n\n定义和要求：\n- 设数据为节点 $x_0  x_1  \\cdots  x_{n-1}$ 及其对应值 $y_0, y_1, \\ldots, y_{n-1}$。在每个宽度为 $h_i = x_{i+1} - x_i$ 的子区间 $[x_i, x_{i+1}]$ 上，使用 $y_i$、$y_{i+1}$ 以及节点导数 $m_i$、$m_{i+1}$ 构造一个三次埃尔米特段。使用标准的三次埃尔米特基函数来定义该段，并通过在每个节点 $x_i$ 处对相邻段使用同一个导数 $m_i$ 来确保 $C^1$ 连续性。\n- 您的斜率限制规则必须强制规定：每当数据值 $\\{y_i\\}$ 是单调非减（或单调非增）时，所得的插值函数 $s(x)$ 在整个定义域 $[x_0, x_{n-1}]$ 上也必须是单调非减（或单调非增）的。仅使用从三次函数段的导数推导出的性质以及保证导数逐点非负性（或非正性）的区间充分条件。该规则必须能处理严格单调数据和带有平坦段的数据。\n- 为了定量测试插值函数的单调性，对于下面的每个数据集，在 $[x_0, x_{n-1}]$ 区间内的 $N = 1001$ 个等距点上对插值函数 $s(x)$进行求值。定义带符号的单调性裕度如下。设 $\\Delta s_j = s(x_{j+1}) - s(x_j)$ 为连续求值点上的差值，并定义 $\\sigma = \\operatorname{sign}(y_{n-1} - y_0)$，约定如果 $y_{n-1} = y_0$ 则 $\\sigma = 1$。裕度为\n$$\n\\mu = \\min_j \\sigma \\, \\Delta s_j.\n$$\n根据此定义，如果插值函数在所要求的方向上是单调的，则 $\\mu \\ge 0$。如果存在任何局部违反，则 $\\mu  0$。\n- 您的程序必须为每个数据集构建插值函数并计算 $\\mu$。每个 $\\mu$ 值必须四舍五入到 $8$ 位小数。\n- 最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的结果顺序与下面的测试套件一致，例如 $[\\mu_1,\\mu_2,\\mu_3,\\mu_4]$，其中每个条目在小数点后恰好有 $8$ 位数字。\n\n测试套件（每个案例提供 $(x,y)$）：\n1. 递增，非均匀间距：\n   - $x = [0.0,\\, 0.7,\\, 1.0,\\, 1.8,\\, 2.5,\\, 3.0]$\n   - $y = [0.0,\\, 0.2,\\, 0.9,\\, 1.1,\\, 2.0,\\, 2.2]$\n2. 递减，非均匀间距：\n   - $x = [0.0,\\, 0.5,\\, 1.5,\\, 2.2,\\, 3.0]$\n   - $y = [5.0,\\, 4.0,\\, 2.5,\\, 2.0,\\, 1.0]$\n3. 非单调值：\n   - $x = [0.0,\\, 0.6,\\, 1.0,\\, 1.4,\\, 2.0]$\n   - $y = [0.0,\\, 1.5,\\, 0.5,\\, 1.6,\\, 1.0]$\n4. 带平坦段的非递减：\n   - $x = [0.0,\\, 0.4,\\, 0.8,\\, 1.2,\\, 2.0]$\n   - $y = [1.0,\\, 1.0,\\, 1.3,\\, 1.3,\\, 2.0]$\n\n您的程序必须是一个完整、可运行的实现，能够：\n- 构建一个穿过数据的连续可微分段三次埃尔米特插值函数 $s(x)$。\n- 通过一个限制器选择节点导数，该限制器保证每当 $\\{y_i\\}$ 单调时，$s(x)$ 的单调性。\n- 对于每个数据集，使用在定义域 $[x_0, x_{n-1}]$ 上的 $N = 1001$ 个等距求值点计算单调性裕度 $\\mu$。\n- 以精确格式 $[\\mu_1,\\mu_2,\\mu_3,\\mu_4]$ 打印单行结果，其中每个 $\\mu_k$ 四舍五入到 $8$ 位小数。",
            "solution": "用户要求设计并实现一个保形分段三次埃尔米特插值多项式 (PCHIP)，该多项式保证在输入数据单调时，插值函数也具有单调性。解决方案必须从第一性原理推导得出。\n\n### 步骤 1：从第一性原理进行理论推导\n\n**1. 分段三次埃尔米特插值**\n给定一组数据点 $(x_0, y_0), (x_1, y_1), \\ldots, (x_{n-1}, y_{n-1})$，其中 $x_0  x_1  \\cdots  x_{n-1}$，一个分段三次埃尔米特插值函数 $s(x)$ 在每个子区间 $[x_i, x_{i+1}]$ 上构建。在这样一个子区间上，$s(x)$ 是一个由端点 $x_i, x_{i+1}$ 上的值 $y_i, y_{i+1}$ 和导数 $m_i, m_{i+1}$ 定义的三次多项式。通过确保在每个节点 $x_i$ 上的导数 $m_i$ 是唯一确定的，插值函数是连续可微的 ($C^1$)。\n\n令 $h_i = x_{i+1} - x_i$ 为区间宽度。我们引入一个局部坐标 $t = (x - x_i)/h_i$，它将区间 $[x_i, x_{i+1}]$ 映射到 $[0, 1]$。在 $[0,1]$ 上的三次多项式 $P_i(t)$ 由下式给出：\n$$P_i(t) = y_i H_{00}(t) + y_{i+1} H_{01}(t) + (h_i m_i) H_{10}(t) + (h_i m_{i+1}) H_{11}(t)$$\n其中 $H_{jk}(t)$ 是三次埃尔米特基函数：\n- $H_{00}(t) = 2t^3 - 3t^2 + 1$ ($t=0$ 处的值)\n- $H_{01}(t) = -2t^3 + 3t^2$ ($t=1$ 处的值)\n- $H_{10}(t) = t^3 - 2t^2 + t$ ($t=0$ 处的缩放导数)\n- $H_{11}(t) = t^3 - t^2$ ($t=1$ 处的缩放导数)\n\n插值函数 $s(x)$ 关于 $x$ 的导数通过链式法则与 $P_i(t)$ 关于 $t$ 的导数相关联：$s'(x) = \\frac{d P_i}{dt} \\frac{dt}{dx} = \\frac{1}{h_i} P_i'(t)$。\n\n**2. 单调性条件**\n为了使插值函数 $s(x)$ 在 $[x_i, x_{i+1}]$ 上单调，其导数 $s'(x)$ 在该区间上必须同号。假设数据是非递减的，因此割线斜率 $\\Delta_i = (y_{i+1} - y_i)/h_i \\ge 0$。我们要求对于所有 $x \\in [x_i, x_{i+1}]$，$s'(x) \\ge 0$。这意味着对于所有 $t \\in [0, 1]$，$P_i'(t) \\ge 0$。\n\n导数 $P_i'(t)$ 是一个关于 $t$ 的二次函数：\n$$P_i'(t) = y_i H'_{00}(t) + y_{i+1} H'_{01}(t) + h_i m_i H'_{10}(t) + h_i m_{i+1} H'_{11}(t)$$\n代入基函数的导数：\n- $H'_{00}(t) = 6t^2 - 6t$\n- $H'_{01}(t) = -6t^2 + 6t$\n- $H'_{10}(t) = 3t^2 - 4t + 1$\n- $H'_{11}(t) = 3t^2 - 2t$\n\n我们得到：\n$$P_i'(t) = (y_{i+1}-y_i)(6t-6t^2) + h_i m_i(3t^2 - 4t + 1) + h_i m_{i+1}(3t^2 - 2t)$$\n两边除以 $h_i$ 并代入 $\\Delta_i = (y_{i+1}-y_i)/h_i$：\n$$s'(x) = \\Delta_i(6t-6t^2) + m_i(3t^2 - 4t + 1) + m_{i+1}(3t^2 - 2t)$$\n为了使这个关于 $t$ 的二次函数在 $[0,1]$ 上非负，我们需要 $s'(x_i) = m_i \\ge 0$ 和 $s'(x_{i+1}) = m_{i+1} \\ge 0$。一个更强的充分条件可以从三次函数的凸性推导出来。一个由其贝塞尔控制点定义的三次函数段是单调的，当且仅当其控制点的y坐标是单调的。控制点为：\n$P_0 = (x_i, y_i)$, $P_1 = (x_i + \\frac{h_i}{3}, y_i + \\frac{h_i m_i}{3})$, $P_2 = (x_{i+1} - \\frac{h_i}{3}, y_{i+1} - \\frac{h_i m_{i+1}}{3})$, $P_3 = (x_{i+1}, y_{i+1})$。\n对于非递减数据 ($y_i \\le y_{i+1}$)，我们需要y坐标是非递减的：\n$y_i \\le y_i + \\frac{h_i m_i}{3} \\le y_{i+1} - \\frac{h_i m_{i+1}}{3} \\le y_{i+1}$。\n这产生三个条件：\n1. $m_i \\ge 0$\n2. $m_{i+1} \\ge 0$\n3. $y_i + \\frac{h_i m_i}{3} \\le y_{i+1} - \\frac{h_i m_{i+1}}{3} \\implies m_i + m_{i+1} \\le 3 \\frac{y_{i+1}-y_i}{h_i} = 3\\Delta_i$\n\n如果数据是非递增的（$\\Delta_i \\le 0$），条件变为 $m_i \\le 0$、$m_{i+1} \\le 0$ 和 $m_i + m_{i+1} \\ge 3\\Delta_i$。两种情况可以总结为：\n如果 $\\Delta_i=0$，则 $m_i=m_{i+1}=0$。\n如果 $\\Delta_i \\neq 0$：$\\mathrm{sign}(m_i) = \\mathrm{sign}(m_{i+1}) = \\mathrm{sign}(\\Delta_i)$，并且 $|\\frac{m_i}{\\Delta_i} + \\frac{m_{i+1}}{\\Delta_i}| \\le 3$。\n\n**3. 斜率限制器算法设计**\n\n要构建 PCHIP 插值函数，我们首先估计每个节点的初始导数，然后应用一个“限制器”来强制执行单调性条件。\n\n**a. 初始导数估计：**\n- 对于内部节点 $x_k$ ($k=1, \\ldots, n-2$)，如果相邻的割线斜率 $\\Delta_{k-1}$ 和 $\\Delta_k$ 符号相反，这表示一个局部极值，所以我们设置初始导数 $m_k = 0$。如果它们的符号相同，一个稳健的选择是割线斜率的加权调和平均值 (Fritsch  Butland, 1984)：\n    $$m_k = \\frac{w_1+w_2}{(w_1/\\Delta_{k-1}) + (w_2/\\Delta_k)} \\quad \\text{其中} \\quad w_1 = 2h_k + h_{k-1}, w_2 = h_k + 2h_{k-1}$$\n- 对于端点节点 $x_0$ 和 $x_{n-1}$，我们使用一个非中心三点公式，这等价于求一个穿过前三个/后三个点的二次函数的导数。\n    $$m_0 = \\frac{(2h_0+h_1)\\Delta_0 - h_0\\Delta_1}{h_0+h_1}$$\n    $$m_{n-1} = \\frac{(2h_{n-2}+h_{n-3})\\Delta_{n-2} - h_{n-2}\\Delta_{n-3}}{h_{n-2}+h_{n-3}}$$\n\n**b. 单调性强制（限制器）：**\n获得初始导数估计后，我们遍历每个区间 $[x_k, x_{k+1}]$ 并强制执行上面推导的充分条件。这可以通过从 $k=0$ 到 $n-2$ 的一次前向遍历完成。\n\n对于每个区间 $[x_k, x_{k+1}]$：\n1. 如果 $\\Delta_k = 0$，设置 $m_k=0$ 和 $m_{k+1}=0$。\n2. 否则，检查符号。如果 $\\mathrm{sign}(m_k) \\neq \\mathrm{sign}(\\Delta_k)$，设置 $m_k=0$。如果 $\\mathrm{sign}(m_{k+1}) \\neq \\mathrm{sign}(\\Delta_k)$，设置 $m_{k+1}=0$。\n3. 检查幅度条件。令 $s_k = \\mathrm{sign}(\\Delta_k)$。如果 $s_k(m_k + m_{k+1})  3 |\\Delta_k|$，则条件被违反。我们将两个导数都按比例缩小，使它们位于可接受区域的边界上：\n   $$m_k \\leftarrow \\frac{3\\Delta_k}{m_k+m_{k+1}} m_k \\quad \\text{和} \\quad m_{k+1} \\leftarrow \\frac{3\\Delta_k}{m_k+m_{k+1}} m_{k+1}$$\n这个过程的一次前向遍历是足够的，因为导数的绝对值只会被减小（或设为零），这会保持或改善先前区间条件的符合性。\n\n**4. 插值函数求值与单调性裕度**\n一旦确定了最终的导数 $\\{m_i\\}$，就可以在任何点 `x_eval` 处对插值函数 $s(x)$进行求值。首先找到包含 `x_eval` 的区间 $[x_k, x_{k+1}]$，计算 $t = (\\text{x\\_eval} - x_k)/h_k$，然后使用埃尔米特基多项式公式。\n\n计算单调性裕度 $\\mu = \\min_j \\sigma \\, \\Delta s_j$，其中 $\\Delta s_j$ 是在N个等距点上求值的插值函数的差值，$\\sigma = \\operatorname{sign}(y_{n-1} - y_0)$ (当 $y_{n-1}=y_0$ 时 $\\sigma=1$)。一个非负的 $\\mu$ 值确认插值函数与整体数据趋势具有相同的单调性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the PCHIP problem for the given test suite.\n    \"\"\"\n    # Test cases from the problem statement\n    test_cases = [\n        (np.array([0.0, 0.7, 1.0, 1.8, 2.5, 3.0]), np.array([0.0, 0.2, 0.9, 1.1, 2.0, 2.2])),\n        (np.array([0.0, 0.5, 1.5, 2.2, 3.0]), np.array([5.0, 4.0, 2.5, 2.0, 1.0])),\n        (np.array([0.0, 0.6, 1.0, 1.4, 2.0]), np.array([0.0, 1.5, 0.5, 1.6, 1.0])),\n        (np.array([0.0, 0.4, 0.8, 1.2, 2.0]), np.array([1.0, 1.0, 1.3, 1.3, 2.0])),\n    ]\n\n    results = []\n    for x, y in test_cases:\n        # Construct the PCHIP interpolator\n        interpolator = PchipInterpolator(x, y)\n        \n        # Evaluate at N=1001 points\n        N = 1001\n        x_eval = np.linspace(x[0], x[-1], N)\n        s_eval = interpolator.evaluate(x_eval)\n        \n        # Calculate monotonicity margin mu\n        delta_s = np.diff(s_eval)\n        \n        sigma_val = y[-1] - y[0]\n        sigma = 1.0 if sigma_val = 0 else -1.0\n        \n        mu = np.min(sigma * delta_s)\n        \n        results.append(f\"{mu:.8f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nclass PchipInterpolator:\n    \"\"\"\n    A shape-preserving Piecewise Cubic Hermite Interpolating Polynomial (PCHIP)\n    that guarantees monotonicity if the input data is monotonic.\n    The implementation is derived from first principles as requested.\n    \"\"\"\n    def __init__(self, x, y):\n        self.x = np.asarray(x, dtype=float)\n        self.y = np.asarray(y, dtype=float)\n        if self.x.ndim != 1 or self.y.ndim != 1 or self.x.shape != self.y.shape:\n            raise ValueError(\"x and y must be 1D arrays of the same shape.\")\n        if self.x.shape[0]  2:\n            raise ValueError(\"Need at least 2 data points for interpolation.\")\n        \n        # Calculate and store the final nodal derivatives after applying the limiter\n        self.m = self._calculate_derivatives(self.x, self.y)\n\n    def _calculate_derivatives(self, x, y):\n        \"\"\"\n        Calculates the nodal derivatives m_k for the PCHIP interpolant,\n        including initial estimation and a monotonicity-preserving limiter.\n        \"\"\"\n        n = len(x)\n        h = np.diff(x)\n        delta = np.diff(y) / h\n        \n        if n == 2:\n            # For two points, the interpolant is a line, derivative is constant\n            return np.array([delta[0], delta[0]])\n        \n        m = np.zeros(n)\n        \n        # Step 1: Initial derivative estimates at interior points (k=1..n-2)\n        for k in range(1, n - 1):\n            if np.sign(delta[k-1]) * np.sign(delta[k])  0:\n                # Weighted harmonic mean for same-sign adjacent secant slopes\n                w1 = 2 * h[k] + h[k-1]\n                w2 = h[k] + 2 * h[k-1]\n                m[k] = (w1 + w2) / (w1 / delta[k-1] + w2 / delta[k])\n            else:\n                # Zero derivative at extrema\n                m[k] = 0.0\n                \n        # Step 2: Initial derivative estimates at endpoints (k=0, n-1)\n        # These are based on fitting a quadratic to the first/last 3 points.\n        m[0] = ((2*h[0] + h[1])*delta[0] - h[0]*delta[1]) / (h[0] + h[1])\n        m[n-1] = ((2*h[n-2] + h[n-3])*delta[n-2] - h[n-2]*delta[n-3]) / (h[n-2] + h[n-3])\n        \n        # Step 3: Apply monotonicity constraints (the limiter) in a single pass.\n        for k in range(n - 1):\n            if delta[k] == 0.0:\n                # If the data is flat, the interpolant must be flat.\n                m[k] = 0.0\n                m[k+1] = 0.0\n            else:\n                # Enforce that derivatives have the same sign as the secant slope.\n                if np.sign(m[k]) != np.sign(delta[k]):\n                    m[k] = 0.0\n                if np.sign(m[k+1]) != np.sign(delta[k]):\n                    m[k+1] = 0.0\n                \n                # Check the magnitude condition derived from Bezier control points.\n                # Expressed generally: s_k * (m_k + m_{k+1}) = 3 * |delta_k|\n                # where s_k = sign(delta_k).\n                \n                # Check for violation\n                violation = False\n                if delta[k]  0 and m[k] + m[k+1]  3.0 * delta[k]:\n                    violation = True\n                elif delta[k]  0 and m[k] + m[k+1]  3.0 * delta[k]:\n                    violation = True\n\n                if violation:\n                    # Scale down m_k and m_{k+1} to meet the boundary\n                    # while preserving their ratio. This can only happen if m_k+m_{k+1} != 0.\n                    # Given the sign checks above, m_k+m_{k+1} will have same sign as delta_k.\n                    scale = (3.0 * delta[k]) / (m[k] + m[k+1])\n                    m[k] *= scale\n                    m[k+1] *= scale\n                        \n        return m\n\n    def evaluate(self, x_eval):\n        \"\"\"\n        Evaluates the PCHIP interpolant at the given points.\n        \"\"\"\n        x_eval = np.asarray(x_eval, dtype=float)\n        \n        # Find which interval each x_eval point belongs to.\n        indices = np.searchsorted(self.x, x_eval, side='right')\n        # Handle points outside the domain by clamping to boundary intervals.\n        indices = np.clip(indices, 1, len(self.x) - 1)\n        # The interval index `k` corresponds to [x_k, x_{k+1}]\n        k = indices - 1\n        \n        # Extract data for the corresponding intervals.\n        x_k = self.x[k]\n        x_k1 = self.x[k+1]\n        y_k = self.y[k]\n        y_k1 = self.y[k+1]\n        m_k = self.m[k]\n        m_k1 = self.m[k+1]\n        \n        h = x_k1 - x_k\n        \n        # Normalize evaluation points to the local coordinate t in [0, 1].\n        t = (x_eval - x_k) / h\n        \n        # Evaluate using the standard Hermite basis functions.\n        t2 = t * t\n        t3 = t2 * t\n        \n        h00 = 2*t3 - 3*t2 + 1\n        h01 = -2*t3 + 3*t2\n        h10 = t3 - 2*t2 + t\n        h11 = t3 - t2\n        \n        s_eval = h00*y_k + h01*y_k1 + h*(h10*m_k + h11*m_k1)\n        \n        return s_eval\n\nsolve()\n```"
        }
    ]
}