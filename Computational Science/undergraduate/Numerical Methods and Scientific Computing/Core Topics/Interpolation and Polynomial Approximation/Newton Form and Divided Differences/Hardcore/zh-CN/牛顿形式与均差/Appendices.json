{
    "hands_on_practices": [
        {
            "introduction": "插值的一个强大应用是近似求解复杂函数的根。如果一个函数 $f(x)$ 的方程 $f(x)=0$ 难以直接求解，我们可以先用一个多项式 $P_n(x)$ 来近似它，然后转而求解更简单的多项式方程 $P_n(x)=0$。这个练习 () 将引导你完成整个流程：从构建牛顿插值多项式，到将其转换为标准形式，再到最终找出近似根。",
            "id": "3254701",
            "problem": "给定一组不同的插值节点和一个在这些节点上定义的实值函数。目标是通过构建一个次数至多为 $n$ 的牛顿插值多项式来逼近该函数的根，该多项式在给定节点处与函数值相匹配，然后在指定区间内求出此多项式的实数根。该方法必须从基本定义出发：对于 $n+1$ 个不同的数据点，存在唯一的次数至多为 $n$ 的插值多项式；以及均差的递归定义。除了这些定义之外，您不能假定任何预先推导出的封闭形式“快捷”表达式。\n\n您的程序必须为每个测试用例实现以下步骤：\n- 使用均差的定义，构建次数至多为 $n$ 的牛顿插值多项式 $P_n(x)$，使其满足对于给定的节点 $\\{x_0, x_1, \\dots, x_n\\}$，有 $P_n(x_i) = f(x_i)$。\n- 将牛顿形式转换为具有系数 $\\{a_0, a_1, \\dots, a_n\\}$ 的标准单项式形式，使得 $P_n(x) = a_0 + a_1 x + \\cdots + a_n x^n$。\n- 计算 $P_n(x)$ 的所有根，并提取出满足以下条件的根：是实数（虚部绝对值小于 $10^{-10}$），位于指定区间内，并且在 $5 \\cdot 10^{-7}$ 的去重容差下代表不同的值。按升序对根进行排序。\n- 报告每个案例的实数根列表，每个根都四舍五入到 $8$ 位小数。\n- 任何三角函数的角度都必须以弧度为单位进行解释。\n\n测试套件规范：\n- 案例 $1$ (振荡减去线性，预期有多个根):\n  - 函数: $f(x) = \\sin(x) - 0.5\\,x$。\n  - 节点: $\\{0,\\;0.5,\\;1.0,\\;1.5,\\;2.0,\\;3.0,\\;4.0\\}$。\n  - 区间: $[0,\\;4]$。\n- 案例 $2$ (具有重根的多项式，预期插值能精确重现):\n  - 函数: $f(x) = x\\,(x-1)^2$。\n  - 节点: $\\{-0.5,\\;0.0,\\;0.75,\\;1.5\\}$。\n  - 区间: $[-0.5,\\;1.5]$。\n- 案例 $3$ (单调递减，预期有单个根):\n  - 函数: $f(x) = e^{-x} - 0.1$。\n  - 节点: $\\{0.0,\\;0.5,\\;1.0,\\;1.5,\\;2.0,\\;2.5,\\;3.0\\}$。\n  - 区间: $[0,\\;3]$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。每个测试用例的根列表本身也呈现为由方括号括起、无空格的逗号分隔列表。例如，如果三个案例产生的列表为 $L_1$、$L_2$ 和 $L_3$，则输出必须严格遵循 $[L_1,L_2,L_3]$ 的格式。\n- 每个根必须四舍五入到8位小数。\n\n所有测试用例的答案都是浮点数列表。不涉及物理单位。所有三角函数求值都必须使用以弧度为单位的角度。",
            "solution": "用户提供的问题是有效的。这是一个数值分析中定义明确的问题，基于多项式插值和求根的既定原则。所有必要的数据和约束都已提供，问题没有科学上的不可能性、矛盾或模糊之处。因此，我们可以着手解决。\n\n问题要求我们通过首先用其牛顿插值多项式 $P_n(x)$ 来逼近函数 $f(x)$，然后求解 $P_n(x)$ 的根，从而找到函数 $f(x)$ 在指定区间内的实数根。\n\n**1. 牛顿插值多项式**\n\n给定一组 $n+1$ 个不同的数据点 $(x_0, y_0), (x_1, y_1), \\dots, (x_n, y_n)$，其中 $y_i = f(x_i)$，存在一个唯一的次数至多为 $n$ 的多项式 $P_n(x)$，使得对所有的 $i = 0, \\dots, n$ 都有 $P_n(x_i) = y_i$。该多项式的牛顿形式为：\n\n$$P_n(x) = c_0 + c_1(x-x_0) + c_2(x-x_0)(x-x_1) + \\dots + c_n(x-x_0)(x-x_1)\\dots(x-x_{n-1})$$\n\n这可以用乘积符号更紧凑地表示：\n\n$$P_n(x) = \\sum_{k=0}^{n} c_k \\prod_{j=0}^{k-1} (x-x_j)$$\n\n系数 $c_k$ 是递归定义的均差。函数 $f$ 关于节点 $x_i, \\dots, x_{i+k}$ 的 $k$ 阶均差记为 $f[x_i, \\dots, x_{i+k}]$。\n\n递归定义如下：\n- **零阶：**\n  $$f[x_i] = f(x_i) = y_i$$\n- **$k$ 阶 (对于 $k \\ge 1$):**\n  $$f[x_i, x_{i+1}, \\dots, x_{i+k}] = \\frac{f[x_{i+1}, \\dots, x_{i+k}] - f[x_i, \\dots, x_{i+k-1}]}{x_{i+k} - x_i}$$\n\n牛顿多项式的系数 $c_k$ 是均差表上对角线上的值：\n$$c_k = f[x_0, x_1, \\dots, x_k]$$\n\n对于一组节点 $\\{x_0, \\dots, x_n\\}$，可以构建均差表。第一列包含函数值 $y_i = f(x_i)$。后续的每个条目都由前一列的两个条目计算得出。例如，对于 $n=3$：\n\n| $x_i$ | $f[x_i]$      | $f[x_i, x_{i+1}]$ | $f[x_i, x_{i+1}, x_{i+2}]$ | $f[x_0, x_1, x_2, x_3]$ |\n| :---- | :------------ | :---------------- | :------------------------- | :-------------------------- |\n| $x_0$ | $y_0 = c_0$   |                   |                            |                             |\n|       |               | $f[x_0, x_1]=c_1$ |                            |                             |\n| $x_1$ | $y_1$         |                   | $f[x_0, x_1, x_2]=c_2$     |                             |\n|       |               | $f[x_1, x_2]$     |                            | $f[x_0, x_1, x_2, x_3]=c_3$ |\n| $x_2$ | $y_2$         |                   | $f[x_1, x_2, x_3]$         |                             |\n|       |               | $f[x_2, x_3]$     |                            |                             |\n| $x_3$ | $y_3$         |                   |                            |                             |\n\n我们将实现一个过程来计算这个表并提取系数 $c_0, c_1, \\dots, c_n$。\n\n**2. 转换为单项式形式**\n\n牛顿形式适合求值，但不适用于标准的求根算法，后者通常处理单项式基下的多项式 $P_n(x) = \\sum_{i=0}^{n} a_i x^i$。我们必须将 $P_n(x)$ 转换为这种形式。\n\n一种稳定且直接的转换方法是使用嵌套乘法方案。牛顿形式可以重写为：\n$$P_n(x) = c_0 + (x-x_0)\\bigg(c_1 + (x-x_1)\\Big(c_2 + \\dots + (x-x_{n-1})c_n\\Big)\\dots\\bigg)$$\n\n这种结构揭示了一种迭代算法。设 $Q_k(x)$ 为第 $k$ 层嵌套内的多项式。\n- 从最内层的多项式开始：$Q_n(x) = c_n$ (一个 $0$ 次多项式)。\n- 对于 $k = n-1, n-2, \\dots, 0$，迭代计算外部多项式：\n  $$Q_k(x) = c_k + (x-x_k)Q_{k+1}(x)$$\n- 最终的多项式是 $P_n(x) = Q_0(x)$。\n\n我们可以通过操作单项式基下的多项式系数数组来执行此迭代。设 `coeffs(P)` 表示多项式 $P$ 的系数数组。\n1. 初始化 `coeffs(Q_n) = [c_n]`。\n2. 对于 $k$ 从 $n-1$ 遞减到 $0$：\n   a. 设 `p_coeffs = coeffs(Q_{k+1})`。\n   b. 计算 `coeffs((x-x_k)Q_{k+1}(x))`。这涉及将 `p_coeffs` 乘以 $x$ (移动系数数组) 和乘以 $-x_k$ (标量乘法)，然后将结果相加。\n   c. 将 $c_k$ 加到结果系数数组的常数项（第一个元素）上。这就得到了 `coeffs(Q_k)`。\n3. 最终的数组 `coeffs(Q_0)` 将包含单项式系数 $\\{a_0, a_1, \\dots, a_n\\}$。\n\n**3. 求根与筛选**\n\n一旦我们有了单项式系数 $\\{a_0, a_1, \\dots, a_n\\}$，我们就可以找到 $P_n(x) = 0$ 的根。一种标准数值方法，已在像`NumPy`这样的库中实现，是求解多项式的友矩阵 (companion matrix) 的特征值。对于首一多项式 (monic polynomial) $p(x) = x^n + p_{n-1}x^{n-1} + \\dots + p_0$，其友矩阵是：\n$$C(p) = \\begin{pmatrix}\n0  0  \\dots  0  -p_0 \\\\\n1  0  \\dots  0  -p_1 \\\\\n0  1  \\dots  0  -p_2 \\\\\n\\vdots  \\vdots  \\ddots  \\vdots  \\vdots \\\\\n0  0  \\dots  1  -p_{n-1}\n\\end{pmatrix}$$\n$C(p)$ 的特征值恰好是 $p(x)$ 的根。`NumPy` 的 `roots` 函数就是利用这个原理。\n\n找到的根通常是复数。我们必须根据问题的标准对它们进行筛选：\n1.  **实数根**：如果一个根 $z$ 的虚部绝对值可以忽略不计，即 $|\\text{Im}(z)|  10^{-10}$，则它被认为是实数根。\n2.  **区间检查**：实数根必须位于指定的区间 $[x_{\\text{min}}, x_{\\text{max}}]$ 内。\n3.  **去重**：数值方法找到的根，特别是重根，可能会有微小差异。为了找到不同的根集合，我们对筛选后的根进行排序，然后遍历它们，只保留与前一个根的差值大于容差 $5 \\cdot 10^{-7}$ 的根。\n4.  **排序与舍入**：最终的唯一实数根列表按升序排序，并且每个根都四舍五入到 $8$ 位小数以用于最终输出。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n\n    def divided_differences(x_nodes, y_values):\n        \"\"\"\n        Computes the divided differences table and returns the Newton coefficients.\n        \n        Args:\n            x_nodes (np.array): The distinct x-coordinates of the data points.\n            y_values (np.array): The y-coordinates of the data points (f(x)).\n\n        Returns:\n            np.array: The coefficients c_k of the Newton polynomial.\n        \"\"\"\n        n = len(x_nodes)\n        if n == 0:\n            return np.array([])\n        \n        # The table of divided differences.\n        # table[i, j] will store f[x_i, ..., x_{i+j}]\n        table = np.zeros((n, n))\n        table[:, 0] = y_values\n        \n        for j in range(1, n):\n            for i in range(n - j):\n                numerator = table[i + 1, j - 1] - table[i, j - 1]\n                denominator = x_nodes[i + j] - x_nodes[i]\n                table[i, j] = numerator / denominator\n                \n        # The coefficients are the top diagonal of the table: f[x_0], f[x_0,x_1], ...\n        return table[0, :]\n\n    def newton_to_monomial(x_nodes, newton_coeffs):\n        \"\"\"\n        Converts a polynomial from Newton form to monomial form.\n\n        Args:\n            x_nodes (np.array): The interpolation nodes x_0, x_1, ...\n            newton_coeffs (np.array): The Newton coefficients c_0, c_1, ...\n\n        Returns:\n            np.array: The coefficients a_0, a_1, ... of the monomial form.\n        \"\"\"\n        n = len(newton_coeffs) - 1\n        if n  0:\n            return np.array([])\n        \n        # Start with the highest-degree term: Q_n(x) = c_n\n        # poly_coeffs stores coeffs in increasing order of power [a_0, a_1, ...]\n        poly_coeffs = np.array([newton_coeffs[n]])\n        \n        # Iterate downwards: Q_k(x) = c_k + (x-x_k)Q_{k+1}(x)\n        for k in range(n - 1, -1, -1):\n            # Current poly_coeffs are for Q_{k+1}(x)\n            # Find coeffs for (x - x_k) * Q_{k+1}(x)\n            # Multiplying by x shifts coeffs up by one power. \n            # Pad with 0 at the start for the new constant term.\n            term_x_mult = np.pad(poly_coeffs, (1, 0), 'constant')\n\n            # Multiplying by -x_k is scalar multiplication. \n            # Pad with 0 at the end to match length.\n            term_xk_mult = -x_nodes[k] * np.pad(poly_coeffs, (0, 1), 'constant')\n\n            product_coeffs = term_x_mult + term_xk_mult\n\n            # Add the constant Newton coefficient c_k\n            product_coeffs[0] += newton_coeffs[k]\n            \n            poly_coeffs = product_coeffs\n\n        return poly_coeffs\n\n    def find_and_filter_roots(poly_coeffs, interval, imag_tol=1e-10, dedupe_tol=5e-7):\n        \"\"\"\n        Finds roots of a polynomial and filters them based on criteria.\n        \n        Args:\n            poly_coeffs (np.array): Monomial coefficients [a_0, a_1, ...].\n            interval (tuple): The interval [min, max] for filtering roots.\n            imag_tol (float): Tolerance for considering a root as real.\n            dedupe_tol (float): Tolerance for de-duplicating roots.\n\n        Returns:\n            list: A sorted list of unique, real roots within the interval.\n        \"\"\"\n        if len(poly_coeffs)  2:\n            return [] # Constant polynomial has no roots unless it's zero\n            \n        # numpy.roots expects coefficients from highest power to lowest\n        roots = np.roots(np.flip(poly_coeffs))\n        \n        # Filter for real roots\n        real_roots = roots[np.abs(np.imag(roots))  imag_tol].real\n        \n        # Filter for roots within the specified interval\n        x_min, x_max = interval\n        interval_roots = real_roots[(real_roots >= x_min)  (real_roots = x_max)]\n        interval_roots.sort()\n        \n        # De-duplicate roots\n        if len(interval_roots) == 0:\n            return []\n            \n        unique_roots = [interval_roots[0]]\n        for i in range(1, len(interval_roots)):\n            if interval_roots[i] - unique_roots[-1] > dedupe_tol:\n                unique_roots.append(interval_roots[i])\n                \n        return unique_roots\n    \n    # Test suite specification\n    test_cases = [\n        {\n            \"func\": lambda x: np.sin(x) - 0.5 * x,\n            \"nodes\": np.array([0., 0.5, 1.0, 1.5, 2.0, 3.0, 4.0]),\n            \"interval\": [0., 4.]\n        },\n        {\n            \"func\": lambda x: x * (x - 1)**2,\n            \"nodes\": np.array([-0.5, 0.0, 0.75, 1.5]),\n            \"interval\": [-0.5, 1.5]\n        },\n        {\n            \"func\": lambda x: np.exp(-x) - 0.1,\n            \"nodes\": np.array([0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0]),\n            \"interval\": [0., 3.]\n        }\n    ]\n    \n    final_results = []\n    \n    for case in test_cases:\n        func = case[\"func\"]\n        x_nodes = case[\"nodes\"]\n        interval = case[\"interval\"]\n        \n        y_values = func(x_nodes)\n        \n        # Step 1: Compute Newton coefficients\n        c_k = divided_differences(x_nodes, y_values)\n        \n        # Step 2: Convert to monomial form\n        a_i = newton_to_monomial(x_nodes, c_k)\n        \n        # Step 3: Find, filter, and process roots\n        roots_list = find_and_filter_roots(a_i, interval)\n        \n        # Step 4: Round roots to 8 decimal places\n        rounded_roots = [f\"{r:.8f}\" for r in roots_list]\n        \n        # Format for final output string\n        formatted_list = f\"[{','.join(rounded_roots)}]\"\n        final_results.append(formatted_list)\n        \n    print(f\"[{','.join(final_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在看到插值法的强大应用之后，理解其局限性也至关重要，其中最关键的就是外插的风险。这个练习 () 将通过数值实验，让你亲眼见证当我们在节点区间之外进行预测（即外插）时，插值多项式的误差会如何迅速增长。通过量化这种误差的增长，你将深刻理解为什么外插通常是不可靠的。",
            "id": "3254790",
            "problem": "考虑一个定义在区间 $[a,b]$ 上的函数 $f$ 和一组互不相同的节点 $\\{x_0,x_1,\\dots,x_n\\}$，其中 $x_0=a$ 且 $x_n=b$。满足所有 $i$ 都有 $p_n(x_i)=f(x_i)$ 的、次数至多为 $n$ 的唯一插值多项式 $p_n$ 可以写成由均差构造的牛顿形式。均差是根据多项式插值的基本性质和插值多项式的唯一性递归定义的。在本任务中，您将使用牛顿形式和均差来构建 $p_n$，然后通过计算在插值区间外对 $p_n$ 求值时的误差来量化外插的不稳定性。\n\n从多项式插值的核心定义和均差的递归构造出发，实现一个程序，该程序：\n- 对指定的节点 $\\{x_i\\}_{i=0}^n$，通过递归定义的均差构造牛顿插值多项式 $p_n$。\n- 在位于区间 $[x_0,x_n]$ 之外的点 $x$ 处计算 $p_n(x)$。\n- 计算在这些点上的绝对误差 $|f(x)-p_n(x)|$。\n- 对于有两个外部评估点 $x_{\\text{near}}$ 和 $x_{\\text{far}}$（其中 $x_{\\text{near}}$ 更靠近 $x_n$）的情况，返回定义为 $\\frac{|f(x_{\\text{far}})-p_n(x_{\\text{far}})|}{|f(x_{\\text{near}})-p_n(x_{\\text{near}})|}$ 的增长因子。该增长因子量化了当评估点离插值区间越远时，外插误差如何增加。\n\n使用以下测试套件来覆盖一系列行为：\n- 情况1：$f(x)=e^{x}$，区间 $[0,1]$，次数为 $n=10$ 的等距节点（即11个节点）。在 $x_{\\text{near}}=1.02$ 和 $x_{\\text{far}}=1.2$ 处求值。\n- 情况2：$f(x)=e^{x}$，区间 $[0,1]$，次数为 $n=10$ 的映射到 $[0,1]$ 上的第一类切比雪夫节点（即11个节点）。在 $x_{\\text{near}}=1.02$ 和 $x_{\\text{far}}=1.2$ 处求值。\n- 情况3：$f(x)=\\frac{1}{1+25x^2}$（龙格函数），区间 $[-1,1]$，次数为 $n=10$ 的等距节点（即11个节点）。在 $x_{\\text{near}}=1.02$ 和 $x_{\\text{far}}=1.2$ 处求值。\n- 情况4：$f(x)=\\cos(x)$，区间 $[0,\\pi]$，次数为 $n=12$ 的等距节点（即13个节点）。在 $x_{\\text{near}}=\\pi+0.01$ 和 $x_{\\text{far}}=\\pi+0.2$ 处求值。所有角度测量均使用弧度。\n- 情况5：$f(x)=e^{x}$，区间 $[0,1]$，次数为 $n=10$ 的等距节点，在一个邻近边界的点 $x_{\\text{only}}=1+10^{-12}$ 处求值（此情况只有一个外部点，因此只需返回绝对误差）。\n\n节点规格：\n- 对于 $[a,b]$ 上次数为 $n$ 的等距节点，使用 $n+1$ 个节点 $x_i=a+\\frac{i}{n}(b-a)$，其中 $i=0,1,\\dots,n$。\n- 对于 $[a,b]$ 上次数为 $n$ 的第一类切比雪夫节点，使用 $n+1$ 个节点 $x_k=\\frac{a+b}{2}+\\frac{b-a}{2}\\cos\\left(\\frac{k\\pi}{n}\\right)$，其中 $k=0,1,\\dots,n$。\n\n您的程序必须计算：\n- 对于情况1至4，计算增长因子 $\\gamma=\\frac{|f(x_{\\text{far}})-p_n(x_{\\text{far}})|}{|f(x_{\\text{near}})-p_n(x_{\\text{near}})|}$。\n- 对于情况5，计算单个绝对误差值 $|f(x_{\\text{only}})-p_n(x_{\\text{only}})|$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按情况1至5的顺序排列：$[\\gamma_1,\\gamma_2,\\gamma_3,\\gamma_4,E_5]$，其中 $\\gamma_i$ 是浮点数， $E_5$ 也是一个浮点数。不应打印任何额外文本。\n\n此问题不涉及物理单位。余弦函数的所有角度必须以弧度为单位进行解释。",
            "solution": "该问题要求构造牛顿形式的插值多项式，并分析其外插误差。这将通过首先计算给定节点集的均差来完成，这些均差作为牛顿多项式的系数。随后，将在插值区间外的点上对该多项式进行求值，以量化误差。\n\n存在一个次数至多为 $n$ 的唯一多项式 $p_n(x)$，它在 $n+1$ 个不同的节点 $\\{x_0, x_1, \\dots, x_n\\}$ 上对函数 $f(x)$ 进行插值，满足对所有 $i \\in \\{0, 1, \\dots, n\\}$ 都有 $p_n(x_i) = f(x_i)$。该多项式的牛顿形式由下式给出：\n$$ p_n(x) = \\sum_{k=0}^{n} c_k \\prod_{j=0}^{k-1} (x - x_j) $$\n可以明确地写为：\n$$ p_n(x) = c_0 + c_1(x-x_0) + c_2(x-x_0)(x-x_1) + \\dots + c_n(x-x_0)(x-x_1)\\dots(x-x_{n-1}) $$\n系数 $c_k$ 是均差，定义为 $c_k = f[x_0, x_1, \\dots, x_k]$。\n\n均差是递归计算的。零阶均差是函数值本身：\n$$ f[x_i] = f(x_i) $$\n高阶均差由递归公式定义：\n$$ f[x_i, \\dots, x_{i+j}] = \\frac{f[x_{i+1}, \\dots, x_{i+j}] - f[x_i, \\dots, x_{i+j-1}]}{x_{i+j} - x_i} $$\n牛顿多项式所需的系数 $c_k$ 是均差表上对角线上的值：$c_0 = f[x_0]$，$c_1 = f[x_0, x_1]$，依此类推，直到 $c_n = f[x_0, \\dots, x_n]$。一种计算效率高的方法是，在一个最初包含函数值 $y_i = f(x_i)$ 的数组上使用原地算法。设此数组为 $C$。该算法流程如下：\n对于 $k$ 从 $1$ 到 $n$：\n  对于 $i$ 从 $n$ 向下到 $k$：\n    $C[i] \\leftarrow \\frac{C[i] - C[i-1]}{x_i - x_{i-k}}$\n这些循环完成后，数组 $C$ 包含所需的系数：$C[k] = c_k = f[x_0, \\dots, x_k]$。此过程被实现用于计算每个测试用例的系数。\n\n一旦系数 $c_k$ 和节点 $x_k$ 确定，多项式 $p_n(x)$ 就可以在任何点 $x$ 处进行求值。为了数值稳定性和效率，我们使用霍纳方法（Horner's method），它将牛顿形式重排为嵌套乘法：\n$$ p_n(x) = c_0 + (x-x_0)\\bigg(c_1 + (x-x_1)\\Big(c_2 + \\dots + (x-x_{n-1})c_n\\Big)\\bigg) $$\n这是迭代求值的。设 $y$ 为正在计算的值。\n初始化 $y = c_n$。\n对于 $i$ 从 $n-1$ 向下到 $0$：\n  $y \\leftarrow c_i + (x - x_i)y$\n$y$ 的最终值即为 $p_n(x)$。\n\n问题为次数为 $n$ 的多项式指定了区间 $[a,b]$ 上的两种节点类型：\n1.  等距节点：$x_i = a + i \\frac{b-a}{n}$，其中 $i=0, 1, \\dots, n$。\n2.  第一类切比雪夫节点：这些是单位圆上等距点在直径上的投影。在 $[-1,1]$ 上的标准公式是 $\\cos(\\frac{k\\pi}{n})$。要将它们映射到 $[a,b]$，公式为 $x_k = \\frac{a+b}{2} + \\frac{b-a}{2}\\cos(\\frac{k\\pi}{n})$，其中 $k=0, 1, \\dots, n$。此公式生成的节点从 $b$到 $a$ 降序排列。为了在实现均差和求值算法时保持一致的升序 $x_0  x_1  \\dots  x_n$，生成的节点需要排序。\n\n主要目标是研究外插误差，该误差发生在插值区间 $[x_0, x_n]$ 之外的点 $x$ 处对 $p_n(x)$ 求值时。绝对误差为 $E(x) = |f(x) - p_n(x)|$。为了量化不稳定性，我们为两个外插点 $x_{\\text{near}}$ 和 $x_{\\text{far}}$（其中 $x_{\\text{near}}$ 更靠近区间边界）计算增长因子 $\\gamma$：\n$$ \\gamma = \\frac{E(x_{\\text{far}})}{E(x_{\\text{near}})} = \\frac{|f(x_{\\text{far}}) - p_n(x_{\\text{far}})|}{|f(x_{\\text{near}}) - p_n(x_{\\text{near}})|} $$\n$\\gamma$ 值较大表明，当离插值区间越远时，外插误差增长得越快。\n\n程序为五个测试用例中的每一个都实现了这些步骤。对于情况1至4，它计算增长因子 $\\gamma$。对于情况5，它涉及单个评估点 $x_{\\text{only}}$，程序计算绝对误差 $E(x_{\\text{only}})$。然后收集结果并按指定格式打印。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef newton_poly_coeffs(x_nodes, y_values):\n    \"\"\"\n    Computes the coefficients of the Newton interpolating polynomial.\n    This is done by calculating the divided differences.\n    The calculation is performed in-place for memory efficiency.\n\n    Args:\n        x_nodes (np.array): The x-coordinates of the interpolation nodes.\n        y_values (np.array): The y-coordinates (function values) at the nodes.\n\n    Returns:\n        np.array: The divided difference coefficients for the Newton polynomial.\n    \"\"\"\n    n = len(x_nodes) - 1\n    coeffs = np.copy(y_values)\n    for k in range(1, n + 1):\n        for i in range(n, k - 1, -1):\n            # Check for division by zero, although not expected with distinct nodes\n            denominator = x_nodes[i] - x_nodes[i-k]\n            if denominator == 0:\n                # This case implies non-distinct nodes, which violates problem constraints.\n                # However, for robustness, one could handle this.\n                raise ValueError(\"x_nodes must be distinct.\")\n            coeffs[i] = (coeffs[i] - coeffs[i-1]) / denominator\n    return coeffs\n\ndef evaluate_newton_poly(coeffs, x_nodes, x_eval):\n    \"\"\"\n    Evaluates the Newton form of the interpolating polynomial at a point x_eval.\n    Uses Horner's method for efficiency and numerical stability.\n\n    Args:\n        coeffs (np.array): The coefficients from the divided difference table.\n        x_nodes (np.array): The x-coordinates of the interpolation nodes.\n        x_eval (float): The point at which to evaluate the polynomial.\n\n    Returns:\n        float: The value of the polynomial p_n(x_eval).\n    \"\"\"\n    n = len(coeffs) - 1\n    result = coeffs[n]\n    for i in range(n - 1, -1, -1):\n        result = coeffs[i] + (x_eval - x_nodes[i]) * result\n    return result\n\ndef solve():\n    \"\"\"\n    Solves the specified set of interpolation and extrapolation problems.\n    \"\"\"\n    # Define the functions for the test cases\n    f1 = lambda x: np.exp(x)\n    f2 = lambda x: 1.0 / (1.0 + 25.0 * x**2)\n    f3 = lambda x: np.cos(x)\n\n    # Define the parameters for each test case\n    test_cases = [\n        {'f': f1, 'interval': [0.0, 1.0], 'n': 10, 'node_type': 'equispaced', 'eval_points': [1.02, 1.2]},\n        {'f': f1, 'interval': [0.0, 1.0], 'n': 10, 'node_type': 'chebyshev', 'eval_points': [1.02, 1.2]},\n        {'f': f2, 'interval': [-1.0, 1.0], 'n': 10, 'node_type': 'equispaced', 'eval_points': [1.02, 1.2]},\n        {'f': f3, 'interval': [0.0, np.pi], 'n': 12, 'node_type': 'equispaced', 'eval_points': [np.pi + 0.01, np.pi + 0.2]},\n        {'f': f1, 'interval': [0.0, 1.0], 'n': 10, 'node_type': 'equispaced', 'eval_points': [1.0 + 1e-12]}\n    ]\n\n    results = []\n\n    for case in test_cases:\n        f = case['f']\n        a, b = case['interval']\n        n = case['n']\n        node_type = case['node_type']\n        eval_points = case['eval_points']\n\n        # Step 1: Generate interpolation nodes\n        if node_type == 'equispaced':\n            x_nodes = np.linspace(a, b, n + 1)\n        else:  # chebyshev\n            k = np.arange(n + 1)\n            # Problem formula generates nodes in descending order. We sort them to be consistent.\n            nodes_desc = (a + b) / 2.0 + (b - a) / 2.0 * np.cos(k * np.pi / n)\n            x_nodes = np.sort(nodes_desc)\n        \n        y_values = f(x_nodes)\n\n        # Step 2: Compute Newton polynomial coefficients\n        coeffs = newton_poly_coeffs(x_nodes, y_values)\n\n        # Step 3: Evaluate and compute the required result (growth factor or error)\n        if len(eval_points) == 2:\n            x_near, x_far = eval_points\n\n            p_near = evaluate_newton_poly(coeffs, x_nodes, x_near)\n            f_near = f(x_near)\n            error_near = np.abs(f_near - p_near)\n            \n            p_far = evaluate_newton_poly(coeffs, x_nodes, x_far)\n            f_far = f(x_far)\n            error_far = np.abs(f_far - p_far)\n\n            if error_near == 0.0:\n                # Handle division by zero, though unlikely in these cases.\n                # If near error is zero, far error being non-zero implies infinite growth.\n                growth_factor = np.inf if error_far > 0.0 else 0.0\n            else:\n                growth_factor = error_far / error_near\n            results.append(growth_factor)\n        else:  # len == 1, Case 5\n            x_only = eval_points[0]\n            \n            p_only = evaluate_newton_poly(coeffs, x_nodes, x_only)\n            f_only = f(x_only)\n            error_only = np.abs(f_only - p_only)\n            results.append(error_only)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "为什么多项式插值对某些函数效果很好，而对另一些则不然？本练习 () 将深入探讨函数的光滑性与其差商行为之间的深刻联系。通过对在 $x=0$ 点不可导的函数 $f(x)=|x|$ 进行插值，你将观察到函数的“奇点”如何导致高阶插值多项式产生剧烈振荡，并学习如何用更简单、更稳健的方法来应对这类问题。",
            "id": "3254712",
            "problem": "考虑函数 $f(x)=|x|$ 以及使用差商的牛顿形式多项式插值。从两个不同节点 $x_0$ 和 $x_1$ 之间的一阶差商的基本定义出发，\n$$\n[x_0,x_1] = \\frac{f(x_1)-f(x_0)}{x_1-x_0},\n$$\n以及高阶差商的递归定义，\n$$\n[x_0,x_1,\\dots,x_k] = \\frac{[x_1,\\dots,x_k]-[x_0,\\dots,x_{k-1}]}{x_k - x_0},\n$$\n使用差商作为系数构建牛顿插值多项式。当节点集跨越 $x=0$ 时，分析 $f(x)=|x|$ 在 $x=0$ 处的不可导性如何体现在这些高阶差商中。然后，提出并实现一种避免大幅振荡的稳健插值策略，并与全局牛顿多项式相比，评估其有效性。\n\n您必须编写一个完整的程序，该程序：\n- 对于每个给定的节点集，计算 $f(x)=|x|$ 的差商表系数 $c_k=[x_0,\\dots,x_k]$ 并构建 $n$ 次牛顿插值多项式 $P_n(x)$。\n- 构建一个避免振荡的稳健插值函数 $L(x)$。在相邻节点 $(x_i,f(x_i))$ 上使用分段线性插值。\n- 在一个包含 $m=1001$ 个点的均匀网格上评估 $P_n(x)$ 和 $L(x)$，该网格跨越 $[x_{\\min},x_{\\max}]$，其中 $x_{\\min}$ 和 $x_{\\max}$ 是节点集中的最小和最大节点。\n- 对于每个节点集，报告最高阶差商系数的绝对值 $|c_n|$、牛顿多项式的最大绝对插值误差，\n$$\nE_{\\text{poly}} = \\max_{x\\in\\text{grid}} |P_n(x)-|x||,\n$$\n以及稳健分段线性插值函数的最大绝对插值误差，\n$$\nE_{\\text{robust}} = \\max_{x\\in\\text{grid}} |L(x)-|x||.\n$$\n\n使用以下节点集测试套件：\n1. $x=\\left[-1,\\,0,\\,1\\right]$ (跨越 $x=0$ 的对称节点；一般情况)。\n2. $x=\\left[-1,\\,-\\tfrac{1}{2},\\,0,\\,\\tfrac{1}{2},\\,1\\right]$ (更密集的对称节点；潜在的振荡)。\n3. $x=\\left[-10^{-3},\\,0,\\,10^{-3}\\right]$ (极度靠近 $x=0$ 的节点；高阶差商的边界行为)。\n4. $x=\\left[0.1,\\,0.2,\\,0.4,\\,0.8\\right]$ (所有节点均在正半轴；不跨越不可导点)。\n\n所有量均为无量纲。不涉及角度单位。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个测试用例贡献一个包含三个十进制数的子列表，顺序为 $\\left[|c_n|, E_{\\text{poly}}, E_{\\text{robust}}\\right]$。格式必须严格如下：\n`[[|c_n|,E_poly,E_robust],[|c_n|,E_poly,E_robust],...]`\n该行任何位置都不能有空格。",
            "solution": "该问题要求分析针对非光滑函数 $f(x) = |x|$ 的牛顿差商插值。我们必须计算插值多项式和一个稳健的分段线性替代方案，然后比较它们在几组节点上的最大绝对误差。\n\n分析的核心在于函数的平滑度与其差商行为之间的关系。对于在区间 $I$ 上 $k$ 次连续可微的函数 $f$，基于 $I$ 中不同节点 $x_0, x_1, \\dots, x_k$ 的 $k$ 阶差商通过差商中值定理与 $f$ 的 $k$ 阶导数相关联：\n$$ [x_0, x_1, \\dots, x_k] = \\frac{f^{(k)}(\\xi)}{k!} $$\n其中 $\\xi$ 位于节点所跨越的区间内。因此，牛顿插值多项式\n$$ P_n(x) = c_0 + c_1(x-x_0) + c_2(x-x_0)(x-x_1) + \\dots + c_n \\prod_{i=0}^{n-1}(x-x_i), $$\n的系数 $c_k = [x_0, \\dots, x_k]$ 可以看作是函数按比例缩放后的导数的近似值。对于解析函数，其导数是良态的，对于高次插值，高阶系数 $c_k$ 趋于零，从而导致 $P_n(x)$ 收敛于 $f(x)$。\n\n函数 $f(x)=|x|$ 是这种行为的一个关键例外。它处处连续，但在 $x=0$ 处不可微。它的一阶导数可以表示为符号函数 $f'(x) = \\text{sgn}(x)$，在 $x=0$ 处有一个跳跃间断点。二阶导数在经典意义上不存在；在分布理论的框架下，它是 Dirac delta 函数 $f''(x) = 2\\delta(x)$，在 $x=0$ 处是奇异的。\n\n这种非光滑性对多项式插值有深远的影响，我们可以根据节点配置进行分析：\n\n1.  **节点位于奇点的一侧：** 如果所有插值节点 $\\{x_i\\}$ 都在 $x=0$ 的一侧（即所有 $x_i > 0$ 或所有 $x_i  0$），那么在这些节点所跨越的区间上，$f(x)$ 等价于一个简单的多项式，即 $f(x)=x$ 或 $f(x)=-x$。对于 $f(x)=x$，一阶差商 $[x_i, x_j]$ 始终为 $1$，而所有 $k \\ge 2$ 的高阶差商 $[x_i, \\dots, x_k]$ 均为零。牛顿多项式将精确地重构该函数，从而插值误差为零。这在测试用例4中得到了证明。\n\n2.  **节点跨越奇点：** 当节点集包含 $x=0$ 两侧的点（也可能包含 $x=0$ 本身）时，插值区间就包含了这个不可微点。对于 $k \\ge 1$ 阶的导数，差商中值定理不再适用。差商不再逼近一个良态的导数，而是试图捕捉函数在 $x=0$ 处导数的奇异性质。具体来说，对于包围原点的节点，二阶差商 $[x_0, x_1, x_2]$ 会很大。对于对称节点 $x_0 = -\\epsilon, x_1 = 0, x_2 = \\epsilon$（其中 $\\epsilon > 0$），我们计算：\n    $$ [x_0, x_1] = \\frac{f(0) - f(-\\epsilon)}{0 - (-\\epsilon)} = \\frac{0 - \\epsilon}{\\epsilon} = -1 $$\n    $$ [x_1, x_2] = \\frac{f(\\epsilon) - f(0)}{\\epsilon - 0} = \\frac{\\epsilon - 0}{\\epsilon} = 1 $$\n    $$ c_2 = [x_0, x_1, x_2] = \\frac{[x_1, x_2] - [x_0, x_1]}{x_2 - x_0} = \\frac{1 - (-1)}{\\epsilon - (-\\epsilon)} = \\frac{2}{2\\epsilon} = \\frac{1}{\\epsilon} $$\n    当 $\\epsilon \\to 0$ 时，该系数发散，反映了奇异二阶导数的行为。高阶系数的这种增长导致全局多项式 $P_n(x)$ 表现出伪振荡（一种与 Runge 现象有关的行为），从而导致较大的最大误差 $E_{\\text{poly}}$。\n\n为了避免这个问题，稳健的插值策略必须是局部的，而不是全局的。所提出的分段线性插值函数 $L(x)$ 用直线连接每对相邻节点 $(x_i, f(x_i))$ 和 $(x_{i+1}, f(x_{i+1}))$。这种方法对函数的全局性质不敏感，仅依赖于局部数据。由于函数 $f(x)=|x|$ 本身由两段线性部分组成，通过位于 $f(x)$ 上的节点的分段线性插值函数 $L(x)$ 将与 $f(x)$ 本身完全相同。因此，插值误差 $E_{\\text{robust}} = \\max |L(x) - |x||$ 预计为零，或在机器精度水平。\n\n对于每个测试用例，算法按以下步骤进行：\n1.  给定节点集 $\\{x_i\\}_{i=0}^n$，计算相应的值 $\\{y_i = |x_i|\\}_{i=0}^n$。\n2.  构建差商表以找到牛顿系数 $c_k = [x_0, \\dots, x_k]$。最终的系数是 $c_n$。\n3.  使用 Horner 方法在一个包含 $m=1001$ 个点的稠密网格上评估牛顿多项式 $P_n(x)$。计算最大绝对误差 $E_{\\text{poly}} = \\max |P_n(x) - |x||$。\n4.  使用排序后的节点构建分段线性插值函数 $L(x)$。对于 $f(x)=|x|$，这将等同于 $|x|$。计算最大绝对误差 $E_{\\text{robust}} = \\max |L(x) - |x||$。\n5.  报告三元组 $[|c_n|, E_{\\text{poly}}, E_{\\text{robust}}]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the interpolation problem for f(x)=|x| for multiple test cases.\n    \"\"\"\n\n    def compute_divided_differences(x_nodes, y_nodes):\n        \"\"\"\n        Computes the divided differences table and returns the coefficients for\n        the Newton polynomial (the top diagonal of the table).\n        \n        Args:\n            x_nodes (np.ndarray): The x-coordinates of the interpolation nodes.\n            y_nodes (np.ndarray): The y-coordinates of the interpolation nodes.\n\n        Returns:\n            np.ndarray: The Newton polynomial coefficients (c_0, c_1, ..., c_n).\n        \"\"\"\n        n = len(x_nodes)\n        coeffs = np.copy(y_nodes)\n        for j in range(1, n):\n            for i in range(n - 1, j - 1, -1):\n                coeffs[i] = (coeffs[i] - coeffs[i - 1]) / (x_nodes[i] - x_nodes[i - j])\n        return coeffs\n\n    def evaluate_newton_poly(x_eval, x_nodes, coeffs):\n        \"\"\"\n        Evaluates the Newton form of the interpolation polynomial using Horner's method.\n        \n        Args:\n            x_eval (np.ndarray): Points at which to evaluate the polynomial.\n            x_nodes (np.ndarray): The x-coordinates of the interpolation nodes.\n            coeffs (np.ndarray): The Newton polynomial coefficients.\n\n        Returns:\n            np.ndarray: The value of the polynomial at each point in x_eval.\n        \"\"\"\n        n = len(coeffs) - 1\n        y = np.full_like(x_eval, coeffs[n])\n        for i in range(n - 1, -1, -1):\n            y = coeffs[i] + (x_eval - x_nodes[i]) * y\n        return y\n    \n    def process_case(x_nodes_list):\n        \"\"\"\n        Processes a single test case: computes coefficients, polynomials, and errors.\n        \n        Args:\n            x_nodes_list (list): A list of floating-point numbers for the nodes.\n\n        Returns:\n            list: A list containing [|c_n|, E_poly, E_robust].\n        \"\"\"\n        x_nodes = np.array(x_nodes_list, dtype=np.float64)\n        y_nodes = np.abs(x_nodes)\n        n = len(x_nodes) - 1\n\n        # 1. Compute divided differences and get the highest-order coefficient c_n\n        # We need to reorder the coefficients from the typical output of a DD table\n        # function to match the Newton form P(x) = c0 + c1(x-x0) + ...\n        # The function below computes coeffs in place: F[j,j] becomes the coefficient c_j\n        F = np.zeros((n + 1, n + 1))\n        F[:, 0] = y_nodes\n\n        for j in range(1, n + 1):\n            for i in range(j, n + 1):\n                F[i, j] = (F[i, j - 1] - F[i - 1, j - 1]) / (x_nodes[i] - x_nodes[i - j])\n        \n        coeffs = np.diag(F)\n        abs_cn = np.abs(coeffs[n])\n\n        # 2. Set up evaluation grid\n        m = 1001\n        x_min, x_max = np.min(x_nodes), np.max(x_nodes)\n        x_eval = np.linspace(x_min, x_max, m)\n        y_true = np.abs(x_eval)\n\n        # 3. Evaluate Newton polynomial and its error\n        y_poly = evaluate_newton_poly(x_eval, x_nodes, coeffs)\n        e_poly = np.max(np.abs(y_poly - y_true))\n\n        # 4. Evaluate piecewise linear interpolant and its error\n        # np.interp requires sorted x-coordinates\n        sort_indices = np.argsort(x_nodes)\n        x_sorted = x_nodes[sort_indices]\n        y_sorted = y_nodes[sort_indices]\n        y_robust = np.interp(x_eval, x_sorted, y_sorted)\n        e_robust = np.max(np.abs(y_robust - y_true))\n\n        return [abs_cn, e_poly, e_robust]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [-1.0, 0.0, 1.0],\n        [-1.0, -0.5, 0.0, 0.5, 1.0],\n        [-1e-3, 0.0, 1e-3],\n        [0.1, 0.2, 0.4, 0.8],\n    ]\n\n    results = []\n    for case in test_cases:\n        results.append(process_case(case))\n    \n    # Format the final output string exactly as required, with no spaces.\n    result_strings = []\n    for res_list in results:\n        # Format each number and join with commas, enclosed in brackets.\n        sublist_string = f\"[{res_list[0]},{res_list[1]},{res_list[2]}]\"\n        result_strings.append(sublist_string)\n\n    final_output = f\"[{','.join(result_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        }
    ]
}