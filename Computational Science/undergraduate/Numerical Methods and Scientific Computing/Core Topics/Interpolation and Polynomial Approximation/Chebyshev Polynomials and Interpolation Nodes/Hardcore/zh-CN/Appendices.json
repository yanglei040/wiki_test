{
    "hands_on_practices": [
        {
            "introduction": "虽然切比雪夫节点在标准的 $[-1, 1]$ 区间上有其理论定义，但现实世界中的问题往往发生在不同的区间上。本练习旨在帮助你掌握一项关键技能：如何将这些“理想”的节点映射到实际的物理域中，这是将理论付诸实践的第一步。通过这个练习 ，你将学会为任意区间计算最优插值点。",
            "id": "2187273",
            "problem": "一个结构工程师团队的任务是监测一根长10米的新型复合梁在静载荷作用下的挠度。他们计划使用二次多项式来建模挠度分布$d(x)$，其中$x$是沿梁从$x=0$米到$x=10$米的位置。由于预算限制，他们只能放置三个挠度传感器。为了构建最稳健的多项式模型，该模型能对任何良态的挠度函数最小化最大可能插值误差，他们决定将传感器放置在被称为切比雪夫节点的特定位置。\n\n计算梁上三个传感器的最佳位置，这些位置对应于在区间$[0, 10]$上进行二次插值的切比雪夫节点。将您的答案表示为一个行矩阵，其中包含三个位置（单位：米），并按从小到大的顺序排列。提供精确的数值。",
            "solution": "我们寻求在区间$[0,10]$上进行二次（2次）插值的三个切比雪夫节点。对于$N=n+1=3$个插值节点，其在区间$[-1,1]$上的第一类切比雪夫节点为\n$$\nt_{k}=\\cos\\left(\\frac{(2k-1)\\pi}{2N}\\right), \\quad k=1,2,3.\n$$\n在$[-1,1]$区间上所有$N$个节点的选择中，这些节点可以最小化最大插值误差。为了将它们映射到区间$[a,b]=[0,10]$，使用仿射变换\n$$\nx=\\frac{a+b}{2}+\\frac{b-a}{2}\\,t=\\frac{0+10}{2}+\\frac{10-0}{2}\\,t=5+5t.\n$$\n计算$t_{k}$的值：\n- 对于$k=1$：$t_{1}=\\cos\\left(\\frac{\\pi}{6}\\right)=\\frac{\\sqrt{3}}{2}$。\n- 对于$k=2$：$t_{2}=\\cos\\left(\\frac{3\\pi}{6}\\right)=\\cos\\left(\\frac{\\pi}{2}\\right)=0$。\n- 对于$k=3$：$t_{3}=\\cos\\left(\\frac{5\\pi}{6}\\right)=-\\frac{\\sqrt{3}}{2}$。\n\n通过$x=5+5t$将每个值映射到$[0,10]$：\n$$\nx_{1}=5+5\\cdot\\frac{\\sqrt{3}}{2}=5+\\frac{5\\sqrt{3}}{2},\\quad\nx_{2}=5+5\\cdot 0=5,\\quad\nx_{3}=5+5\\cdot\\left(-\\frac{\\sqrt{3}}{2}\\right)=5-\\frac{5\\sqrt{3}}{2}.\n$$\n从小到大排序得到：\n$$\n5-\\frac{5\\sqrt{3}}{2},\\quad 5,\\quad 5+\\frac{5\\sqrt{3}}{2}.\n$$\n这些就是三个传感器的精确位置（单位：米）。",
            "answer": "$$\\boxed{\\begin{pmatrix}5-\\frac{5\\sqrt{3}}{2}  5  5+\\frac{5\\sqrt{3}}{2}\\end{pmatrix}}$$"
        },
        {
            "introduction": "学习了如何找到最优插值点之后，下一个合乎逻辑的步骤就是构建实际的近似多项式。这个练习  将引导你完成这一过程，并揭示切比雪夫多项式的性质如何导出一个简洁且可能出乎意料的近似结果。这有助于你理解插值不仅仅是“连接点”，更是寻找一个函数的优质多项式表达。",
            "id": "2187288",
            "problem": "在数值分析中，使用Chebyshev节点进行插值是优于使用等距点的一种方法，尤其是在避免Runge现象方面。该方法选择的插值点是Chebyshev多项式的根，这些点聚集在区间的端点附近。\n\n考虑函数 $f(x) = x^3$ 在区间 $[-1, 1]$ 上的情况。您的任务是找到一个次数至多为 2 的唯一多项式，我们称之为 $P_2(x)$，它在该区间上的三个Chebyshev节点处对 $f(x)$ 进行插值。这些节点被定义为第一类三次Chebyshev多项式 $T_3(x)$ 的根。\n\n请将您的答案 $P_2(x)$ 表示为一个关于 $x$ 的简化多项式。",
            "solution": "给定函数 $f(x)=x^{3}$ 在 $[-1,1]$ 上，我们必须找到一个次数至多为 $2$ 的唯一多项式 $P_{2}(x)$，它在 $[-1,1]$ 上的三个Chebyshev节点处对 $f$ 进行插值，这些节点被定义为第一类三次Chebyshev多项式 $T_{3}(x)$ 的根。\n\n使用恒等式 $T_{3}(x)=\\cos(3\\arccos x)=4x^{3}-3x$。$T_{3}$ 的根即为三个Chebyshev节点：\n$$\nT_{3}(x)=4x^{3}-3x=x(4x^{2}-3)=0\n\\quad\\Longrightarrow\\quad\nx\\in\\left\\{0,\\;\\pm\\frac{\\sqrt{3}}{2}\\right\\}.\n$$\n设 $P_{2}(x)=A x^{2}+B x+C$。插值条件为在每个节点 $\\xi\\in\\left\\{0,\\pm\\frac{\\sqrt{3}}{2}\\right\\}$ 处，$P_{2}(\\xi)=\\xi^{3}$。\n\n1) 在 $x=0$ 处：\n$$\nP_{2}(0)=C=0 \\quad\\Longrightarrow\\quad C=0.\n$$\n\n2) 令 $a=\\frac{\\sqrt{3}}{2}$。在 $x=a$ 和 $x=-a$ 处：\n$$\nP_{2}(a)=A a^{2}+B a=a^{3},\\qquad P_{2}(-a)=A a^{2}-B a=-a^{3}.\n$$\n将这两个方程相加可以消去 $B$：\n$$\n(A a^{2}+B a)+(A a^{2}-B a)=a^{3}+(-a^{3})\n\\;\\Longrightarrow\\;\n2A a^{2}=0\n\\;\\Longrightarrow\\;\nA=0\n\\quad(\\text{因为 }a\\neq 0).\n$$\n将 $A=0$ 代入 $A a^{2}+B a=a^{3}$ 以解出 $B$：\n$$\nB a=a^{3}\\;\\Longrightarrow\\;B=a^{2}.\n$$\n当 $a=\\frac{\\sqrt{3}}{2}$ 时，我们有\n$$\na^{2}=\\left(\\frac{\\sqrt{3}}{2}\\right)^{2}=\\frac{3}{4}.\n$$\n因此，\n$$\nP_{2}(x)=B x=\\frac{3}{4}\\,x.\n$$\n快速验证：$P_{2}(0)=0=f(0)$，且 $P_{2}(\\pm a)=\\frac{3}{4}(\\pm a)=\\pm a\\cdot\\frac{3}{4}=\\pm a^{3}=f(\\pm a)$，因此在所有三个Chebyshev节点上都满足插值条件。\n\n因此，次数至多为 $2$ 的唯一插值多项式是 $P_{2}(x)=\\frac{3}{4}x$。",
            "answer": "$$\\boxed{\\frac{3}{4}x}$$"
        },
        {
            "introduction": "理论的优越性需要通过实践来验证，这个最终练习将通过直接的数值比较来阐明核心要点。通过为经典的龙格函数分别实现等距节点和切比雪夫节点的插值 ，你将亲眼目睹龙格现象的发生，并看到切比雪夫节点如何有效地抑制振荡。这个编码练习将理论优势转化为可触摸、可量化的结果，从而巩固你对切比雪夫插值重要性的理解。",
            "id": "3212557",
            "problem": "您需要研究函数 $f(x)=\\dfrac{1}{1+25x^2}$ 在区间 $[-1,1]$ 上的多项式插值的龙格现象，方法是比较两种节点选择：等距节点和切比雪夫-洛巴托节点。您的实现必须是一个完整的、可运行的程序，该程序以数值方式执行计算，并报告能够清晰比较这两种节点选择的量化指标。所有角度必须以弧度为单位。\n\n请仅使用基本定义和经过充分验证的事实作为出发点：\n- 插值问题是：给定 $[-1,1]$ 中的节点 $\\{x_j\\}_{j=0}^n$ 和数据值 $y_j=f(x_j)$，构造一个唯一的次数至多为 $n$ 的多项式 $p_n$，使得对所有 $j$ 都满足 $p_n(x_j)=y_j$。\n- 第一类切比雪夫多项式 $\\{T_k\\}_{k\\ge 0}$ 定义为 $T_k(\\cos\\theta)=\\cos(k\\theta)$，其中 $\\theta\\in\\mathbb{R}$。切比雪夫-洛巴托节点是 $T_n$ 的极值点，即 $x_k=\\cos\\left(\\dfrac{k\\pi}{n}\\right)$，其中 $k=0,1,\\dots,n$，$\\pi$ 以弧度为单位。\n- 龙格现象指的是在 $[-1,1]$ 上使用等距节点对解析函数进行高次多项式插值时，可能出现的端点处的大幅振荡。\n\n您的任务是：\n1. 对每种节点族和每个次数 $n$，构造插值多项式 $p_n$，不使用任何预先存在的黑箱插值例程。您可以使用任何与多项式插值定义一致的、数学上等价且数值稳定的公式（例如，拉格朗日插值的重心坐标实现，或由均差构造的牛顿形式）。请确保数值稳定性。\n2. 通过在 $[-1,1]$ 上的一个包含 $M$ 个点的均匀网格上对 $p_n$ 和 $f$ 进行采样，来近似计算 $[-1,1]$ 上的一致误差 $\\lVert f-p_n\\rVert_{\\infty}$。使用 $M=20001$。\n3. 在端点窗口的并集 $[-1,-1+w]\\cup[1-w,1]$（其中 $w=0.1$）上，使用两个度量来量化端点行为：\n   - 端点误差振幅 $E_{\\mathrm{end}}=\\max_{x\\in[-1,-1+w]\\cup[1-w,1]} |f(x)-p_n(x)|$。\n   - 端点振荡计数，定义为在采样网格上限制于 $[-1,-1+w]\\cup[1-w,1]$ 范围内的 $p_n$ 离散导数的严格符号变化次数。通过在均匀网格上使用中心有限差分计算导数，并将绝对值 $\\le \\tau$ 的值声明为零来对小幅值设置阈值，其中 $\\tau=10^{-8}$。每当两个连续的非零导数样本符号相反时，计为一个严格符号变化。零值应被忽略（不计数涉及零的转换；在确定变化时，通过沿用最后一个非零符号来压缩连续的零）。\n4. 对每个 $n$，使用上述指标比较等距节点和切比雪夫-洛巴托节点。\n\n测试套件和参数：\n- 使用次数 $n\\in\\{5,10,20\\}$。\n- 对每个 $n$，使用两种节点族：\n  - 等距节点：$x_j=-1+\\dfrac{2j}{n}$，其中 $j=0,1,\\dots,n$。\n  - 切比雪夫-洛巴托节点：$x_k=\\cos\\left(\\dfrac{k\\pi}{n}\\right)$，其中 $k=0,1,\\dots,n$，$\\pi$ 以弧度为单位。\n\n每个次数 $n$ 的要求输出：\n- 对于等距节点：按此顺序的三个值 $(\\lVert f-p_n\\rVert_{\\infty},\\ E_{\\mathrm{end}},\\ \\text{oscillation count})$。\n- 对于切比雪夫-洛巴托节点：按此顺序的三个值 $(\\lVert f-p_n\\rVert_{\\infty},\\ E_{\\mathrm{end}},\\ \\text{oscillation count})$。\n- 因此，对每个 $n$，报告六个值。对所有三个 $n$ 值，总共报告 $18$ 个值。\n\n最终输出格式：\n- 您的程序必须生成单行输出，其中包含所有 $18$ 个结果，形式为方括号括起来的逗号分隔列表，按 $n=5$，$n=10$，$n=20$ 的顺序排列，在每个 $n$ 内部，先是等距节点的三元组，然后是切比雪夫-洛巴托节点的三元组。例如，您的输出应如下所示：\n  $[a_1,a_2,a_3,a_4,a_5,a_6,\\ a_7,a_8,a_9,a_{10},a_{11},a_{12},\\ a_{13},a_{14},a_{15},a_{16},a_{17},a_{18}]$，\n  其中所有 $a_i$ 都是按指定顺序排列的数字。\n- 将所有浮点输出四舍五入到 $8$ 位小数；振荡计数必须是整数。\n\n角度单位说明：\n- 凡是使用余弦函数定义节点的地方，其参数必须以弧度为单位。\n\n您的程序必须是完全自包含的，不需要用户输入，并且只依赖于 Python 标准库和指定的数值库。唯一允许的数值库是一个标准的数值数组库。在给定规范下，输出必须是可复现的。",
            "solution": "我们从多项式插值的定义开始。对于节点 $\\{x_j\\}_{j=0}^n\\subset[-1,1]$ 和值 $y_j=f(x_j)$，存在一个唯一的多项式 $p_n\\in\\mathbb{P}_n$ 满足对所有 $j$ 都有 $p_n(x_j)=y_j$。任何与此定义一致的表示都是可接受的。从数值方法的角度来看，一种稳健的方法是使用重心拉格朗日公式，它能实现相同的插值多项式，但与朴素的拉格朗日公式相比，其数值稳定性更佳。\n\n使用的基本事实：\n1. 插值误差恒等式：对于 $f\\in C^{n+1}([-1,1])$，逐点误差可以表示为\n   $$ f(x)-p_n(x)=\\frac{f^{(n+1)}(\\xi_x)}{(n+1)!}\\prod_{j=0}^n (x-x_j), $$\n   其中某个 $\\xi_x\\in(-1,1)$ 依赖于 $x$。此恒等式表明，节点布局 $\\{x_j\\}$ 决定了因子 $\\prod_{j=0}^n(x-x_j)$ 的形态，从而影响误差的大小和分布。\n2. 第一类切比雪夫多项式 $\\{T_k\\}$ 满足 $T_k(\\cos\\theta)=\\cos(k\\theta)$，其中 $\\theta\\in\\mathbb{R}$。$T_n$ 的极值点出现在 $x_k=\\cos\\left(\\frac{k\\pi}{n}\\right)$，$k=0,\\dots,n$，这些点即为切比雪夫-洛巴托节点。这些节点在端点附近聚集，并且已知相对于等距节点，它们能够抑制 $[-1,1]$ 上 $\\prod_{j=0}^n(x-x_j)$ 的大小。\n3. 随着 $n$ 的增长，龙格现象在等距节点上表现得尤为突出，即使对于解析函数 $f$，也会放大端点附近的振荡。切比雪夫-洛巴托节点通过根据均匀分布的 $\\theta$ 所对应的映射 $x=\\cos\\theta$ 产生的密度来分布节点，从而缓解了这一现象。\n\n算法设计：\n- 函数和网格：\n  - 在 $[-1,1]$ 上定义 $f(x)=\\dfrac{1}{1+25x^2}$。\n  - 使用一个包含 $M=20001$ 个点、跨越 $[-1,1]$ 的均匀网格 $\\{x^{\\mathrm{eval}}_i\\}_{i=0}^{M-1}$，通过采样来近似 $\\lVert f-p_n\\rVert_{\\infty}$。\n- 节点生成：\n  - 等距节点：$x_j=-1+\\dfrac{2j}{n}$，其中 $j=0,\\dots,n$。\n  - 切比雪夫-洛巴托节点：$x_k=\\cos\\left(\\dfrac{k\\pi}{n}\\right)$，其中 $k=0,\\dots,n$，$\\pi$ 以弧度为单位。\n- 插值构造：\n  - 使用重心拉格朗日插值（它在数学上等价于唯一的插值多项式），权重为 $w_j=\\left(\\prod_{m\\ne j}(x_j-x_m)\\right)^{-1}$。将所有 $w_j$ 乘以一个共同的非零因子不会改变插值多项式，这可用于归一化权重以提高数值稳定性。\n  - 对于在点 $x$ 处的求值，第一重心公式为\n    $$ p_n(x)=\\frac{\\sum_{j=0}^n \\dfrac{w_j}{x-x_j} y_j}{\\sum_{j=0}^n \\dfrac{w_j}{x-x_j}}, $$\n    并约定如果 $x=x_j$（在数值容差内），则 $p_n(x)=y_j$ 以精确满足插值条件并避免除以零。\n  - 为了效率，对整个网格 $\\{x^{\\mathrm{eval}}_i\\}$ 的求值进行向量化。\n- 误差指标：\n  - 计算采样误差 $e_i=|f(x^{\\mathrm{eval}}_i)-p_n(x^{\\mathrm{eval}}_i)|$，并通过 $\\max_i e_i$ 来近似 $\\lVert f-p_n\\rVert_{\\infty}$。\n  - 将宽度 $w=0.1$ 的端点窗口定义为 $[-1,-1+w]\\cup[1-w,1]$，即 $[-1,-0.9]\\cup[0.9,1]$，并计算 $E_{\\mathrm{end}}=\\max\\{e_i: x^{\\mathrm{eval}}_i\\in[-1,-0.9]\\cup[0.9,1]\\}$。\n- 振荡指标：\n  - 通过中心有限差分来近似网格上 $p_n$ 的导数，即在均匀网格上使用带边界处理的标准二阶精度离散导数。\n  - 使用 $\\tau=10^{-8}$ 对小导数幅值设置阈值：将绝对值 $\\le \\tau$ 的值映射为 $0$，其他值保持不变。定义符号序列 $s_i=\\mathrm{sign}(p_n'(x^{\\mathrm{eval}}_i))$，并应用阈值处理。\n  - 将范围限制在端点窗口并集的索引内。通过将序列压缩至其非零元素来移除零，并计算严格符号变化：两个连续非零符号不同（即它们的乘积为负）的索引数量。这将为端点区域得出一个整数振荡计数。\n- 测试套件：\n  - 次数 $n\\in\\{5,10,20\\}$。对每个 $n$，首先为等距节点计算三元组 $(\\lVert f-p_n\\rVert_{\\infty}, E_{\\mathrm{end}}, \\text{oscillation count})$，然后为切比雪夫-洛巴托节点计算该三元组。\n- 输出格式化：\n  - 对每个 $n$，将等距节点的三元组与切比雪夫-洛巴托节点的三元组连接起来，当按顺序处理 $n=5,10,20$ 时，每个 $n$ 产生 $6$ 个值，总共产生 $18$ 个值。\n  - 将所有浮点输出四舍五入到 $8$ 位小数；振荡计数保持为整数。\n  - 以方括号括起来的逗号分隔列表形式打印单行。\n\n这为何能揭示龙格现象：\n- 根据误差恒等式，随着 $n$ 的增长，等距节点无法控制 $\\max_{x\\in[-1,1]}\\left|\\prod_{j=0}^n(x-x_j)\\right|$，即使对于解析函数 $f$ 也会导致大的端点振荡。源于 $T_n$ 极值点的切比雪夫-洛巴托节点，在缩放因子之内有效地最小化了节点多项式的上确界范数，从而使误差分布更均匀并抑制了端点误差的急剧增长。全局上确界范数误差和端点误差振幅直接量化了这些效应。振荡计数检测了 $p_n$ 在端点附近出现的、而在 $f$ 中（在每个端点窗口上是单调的）不存在的虚假振荡行为，提供了一种补充性的定性评估，该评估值对于切比雪夫-洛巴托节点而言相对于等距节点有所降低。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef f(x):\n    return 1.0 / (1.0 + 25.0 * x * x)\n\ndef equispaced_nodes(n):\n    # n: degree, so n+1 nodes including endpoints\n    j = np.arange(n + 1, dtype=float)\n    return -1.0 + 2.0 * j / n\n\ndef chebyshev_lobatto_nodes(n):\n    # x_k = cos(k*pi/n), k=0..n, with radians\n    k = np.arange(n + 1, dtype=float)\n    return np.cos(np.pi * k / n)\n\ndef barycentric_weights(x):\n    # Compute first-form barycentric weights: w_j = 1 / prod_{k!=j} (x_j - x_k)\n    # Normalize to avoid overflow/underflow; overall scaling cancels in formula.\n    x = np.asarray(x, dtype=float)\n    m = x.size\n    w = np.empty(m, dtype=float)\n    for j in range(m):\n        diffs = x[j] - np.delete(x, j)\n        w[j] = 1.0 / np.prod(diffs)\n    # Normalize weights to unit max absolute value\n    maxabs = np.max(np.abs(w))\n    if maxabs == 0.0 or not np.isfinite(maxabs):\n        return w\n    return w / maxabs\n\ndef barycentric_interpolate(x_nodes, y_nodes, w, x_eval, atol=1e-14):\n    # Vectorized first-form barycentric interpolation\n    x_nodes = np.asarray(x_nodes, dtype=float)\n    y_nodes = np.asarray(y_nodes, dtype=float)\n    w = np.asarray(w, dtype=float)\n    x_eval = np.asarray(x_eval, dtype=float)\n    # Compute differences matrix\n    Xdiff = x_eval[:, None] - x_nodes[None, :]\n    # Identify exact matches to nodes within tolerance\n    mask_eq = np.isclose(Xdiff, 0.0, rtol=0.0, atol=atol)\n    any_eq = np.any(mask_eq, axis=1)\n    # For non-matching points, compute barycentric formula\n    # Avoid division by zero by masking those rows later\n    with np.errstate(divide='ignore', invalid='ignore'):\n        tmp = w[None, :] / Xdiff\n        num = np.dot(tmp, y_nodes)\n        den = np.sum(tmp, axis=1)\n        y = num / den\n    # Fix rows where x_eval equals a node\n    if np.any(any_eq):\n        idxs = np.where(any_eq)[0]\n        # For each such row, pick the corresponding node value\n        # If multiple trues due to tolerance, take the first\n        j_star = np.argmax(mask_eq[idxs, :], axis=1)\n        y[idxs] = y_nodes[j_star]\n    return y\n\ndef endpoint_masks(x_grid, w=0.1):\n    left = x_grid = (-1.0 + w)\n    right = x_grid >= (1.0 - w)\n    return left | right\n\ndef count_strict_sign_changes(values, tol=1e-8):\n    # values: derivative samples on a 1D grid\n    v = np.asarray(values, dtype=float)\n    s = np.sign(v)\n    s[np.abs(v) = tol] = 0.0\n    nonzero = s[s != 0.0]\n    if nonzero.size = 1:\n        return 0\n    # Count transitions where consecutive signs differ\n    return int(np.sum(nonzero[1:] * nonzero[:-1]  0.0))\n\ndef interpolation_metrics(n, node_kind, x_eval, f_eval, tau=1e-8):\n    # node_kind: 'equispaced' or 'cheb_lobatto'\n    if node_kind == 'equispaced':\n        x_nodes = equispaced_nodes(n)\n    elif node_kind == 'cheb_lobatto':\n        x_nodes = chebyshev_lobatto_nodes(n)\n    else:\n        raise ValueError(\"Unknown node kind\")\n\n    y_nodes = f(x_nodes)\n    w = barycentric_weights(x_nodes)\n    p_eval = barycentric_interpolate(x_nodes, y_nodes, w, x_eval)\n\n    # Errors\n    err = np.abs(f_eval - p_eval)\n    E_inf = float(np.max(err))\n\n    # Endpoint window metrics\n    mask_end = endpoint_masks(x_eval, w=0.1)\n    E_end = float(np.max(err[mask_end]))\n\n    # Oscillation count via discrete derivative\n    # Use np.gradient with x grid for better edge approximation\n    dp = np.gradient(p_eval, x_eval, edge_order=2)\n    osc_count = count_strict_sign_changes(dp[mask_end], tol=tau)\n\n    return E_inf, E_end, osc_count\n\ndef solve():\n    # Define the test cases from the problem statement.\n    degrees = [5, 10, 20]  # n values\n    # Evaluation grid\n    M = 20001\n    x_eval = np.linspace(-1.0, 1.0, M, dtype=float)\n    f_eval = f(x_eval)\n\n    results = []\n    for n in degrees:\n        # Equispaced nodes metrics\n        E_inf_e, E_end_e, osc_e = interpolation_metrics(n, 'equispaced', x_eval, f_eval, tau=1e-8)\n        # Chebyshev–Lobatto nodes metrics\n        E_inf_c, E_end_c, osc_c = interpolation_metrics(n, 'cheb_lobatto', x_eval, f_eval, tau=1e-8)\n\n        # Round floats to 8 decimal places as required; integers unchanged\n        results.extend([\n            f\"{np.round(E_inf_e, 8):.8f}\",\n            f\"{np.round(E_end_e, 8):.8f}\",\n            str(int(osc_e)),\n            f\"{np.round(E_inf_c, 8):.8f}\",\n            f\"{np.round(E_end_c, 8):.8f}\",\n            str(int(osc_c)),\n        ])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}