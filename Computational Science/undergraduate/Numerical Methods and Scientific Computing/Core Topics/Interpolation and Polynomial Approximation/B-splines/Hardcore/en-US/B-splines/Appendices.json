{
    "hands_on_practices": [
        {
            "introduction": "The most effective way to truly grasp the mechanics of B-splines is to implement them from their fundamental definition. This exercise guides you through building a B-spline evaluator based on the recursive Cox–de Boor formula, the mathematical heart of the algorithm. By constructing curves with clamped knot vectors, you will programmatically verify the essential property of endpoint interpolation, which guarantees the curve passes directly through its first and last control points .",
            "id": "3207506",
            "problem": "You are asked to write a complete, runnable program that constructs and evaluates a Basis spline (B-spline) curve in a way that is guaranteed to interpolate its first and last control points. Your design must begin from the core recursive definition of B-spline basis functions and proceed to an algorithmic implementation that respects numerical stability and correctness.\n\nStart from the following fundamental base: the Cox–de Boor recursive definition of B-spline basis functions. For a given nondecreasing knot vector $\\{t_0, t_1, \\dots, t_m\\}$ and degree $p \\ge 0$, the basis functions $N_{i,p}(u)$ are defined recursively by\n$$\nN_{i,0}(u) = \n\\begin{cases}\n1,  t_i \\le u  t_{i+1} \\\\\n0,  \\text{otherwise}\n\\end{cases}\n$$\nand for $p \\ge 1$,\n$$\nN_{i,p}(u) = \\frac{u - t_i}{t_{i+p} - t_i} N_{i,p-1}(u) + \\frac{t_{i+p+1} - u}{t_{i+p+1} - t_{i+1}} N_{i+1,p-1}(u),\n$$\nwith the convention that terms with zero denominators are treated as zero. The parametric curve is then given by\n$$\n\\mathbf{C}(u) = \\sum_{i=0}^{n} N_{i,p}(u)\\,\\mathbf{P}_i,\n$$\nwhere $\\{\\mathbf{P}_0,\\dots,\\mathbf{P}_n\\}$ are the control points. When the knot vector is clamped (also called open), meaning the first and last knots are each repeated $p+1$ times, the curve is guaranteed to interpolate the first and last control points at the ends of the parametric domain. Your task is to implement an evaluation algorithm that uses these definitions and to demonstrate, through a test suite, that your curve passes exactly through its first and last control points.\n\nRequirements:\n- Implement B-spline curve evaluation based on the above recursive basis definition, using a numerically stable approach appropriate for advanced undergraduate numerical methods. You must ensure endpoint interpolation by using clamped knot vectors with multiplicity $p+1$ at both ends.\n- The domain of evaluation must be $[t_p, t_{m-p}]$. At $u = t_p$ and $u = t_{m-p}$, the curve must return $\\mathbf{P}_0$ and $\\mathbf{P}_n$, respectively.\n- Use Euclidean distance to compare vector equality up to a tolerance of $10^{-9}$, with zero relative tolerance. If the norm difference is less than or equal to $10^{-9}$, treat the values as equal.\n\nTest suite and parameters:\nFor each test case below, evaluate the curve at the left endpoint $u = t_p$ and the right endpoint $u = t_{m-p}$, and check whether these points match the first and last control points within the tolerance. Your program should produce one boolean per test case indicating whether both endpoint checks passed.\n\nLet each control point $\\mathbf{P}_i$ be a coordinate vector in either two dimensions or three dimensions as specified. The knot vectors are either explicitly given or must be constructed as clamped open-uniform knot vectors. An open-uniform clamped knot vector of length $m+1 = n + p + 2$ has the first $p+1$ entries equal to $0$, the last $p+1$ entries equal to $1$, and the interior knots evenly spaced in $(0,1)$.\n\n- Test case 1 (happy path, two dimensions, quadratic clamped open-uniform):\n  - Degree $p = 2$.\n  - Control points $\\mathbf{P}_0,\\dots,\\mathbf{P}_4$: $\\{(0,0),(1,2),(2,0.5),(3,3),(4,0)\\}$.\n  - Construct a clamped open-uniform knot vector for $n=4$, $p=2$.\n- Test case 2 (boundary case with minimal interior knots, cubic clamped open-uniform, Bezier-like):\n  - Degree $p = 3$.\n  - Control points $\\mathbf{P}_0,\\dots,\\mathbf{P}_3$: $\\{(0,0),(1,2),(3,2),(4,0)\\}$.\n  - Construct a clamped open-uniform knot vector for $n=3$, $p=3$.\n- Test case 3 (non-uniform clamped, two dimensions):\n  - Degree $p = 3$.\n  - Control points $\\mathbf{P}_0,\\dots,\\mathbf{P}_6$: $\\{(0,0),(1,1),(2,-1),(3,2),(4,-0.5),(5,1.5),(6,0)\\}$.\n  - Explicit clamped non-uniform knot vector: $\\{0,0,0,0,0.15,0.6,0.85,1,1,1,1\\}$.\n- Test case 4 (edge case, linear clamped open-uniform):\n  - Degree $p = 1$.\n  - Control points $\\mathbf{P}_0,\\dots,\\mathbf{P}_2$: $\\{(0,1),(1,0),(2,1.5)\\}$.\n  - Construct a clamped open-uniform knot vector for $n=2$, $p=1$.\n- Test case 5 (three dimensions, cubic clamped open-uniform):\n  - Degree $p = 3$.\n  - Control points $\\mathbf{P}_0,\\dots,\\mathbf{P}_5$: $\\{(0,0,0),(1,2,1),(2,-1,2),(3,3,2),(4,0,1),(5,1,0)\\}$.\n  - Construct a clamped open-uniform knot vector for $n=5$, $p=3$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $\\texttt{[true,false,true]}$. Use lowercase Python boolean formatting. The list must contain one boolean per test case, in the order listed above.",
            "solution": "The problem requires the implementation and verification of B-spline curve evaluation, demonstrating the endpoint interpolation property for clamped knot vectors. The solution is derived directly from the fundamental recursive definition of B-spline basis functions provided in the problem statement.\n\nA B-spline curve $\\mathbf{C}(u)$ of degree $p$ is a parametric curve defined as a weighted sum of $n+1$ control points $\\{\\mathbf{P}_0, \\dots, \\mathbf{P}_n\\}$:\n$$\n\\mathbf{C}(u) = \\sum_{i=0}^{n} N_{i,p}(u)\\,\\mathbf{P}_i\n$$\nThe weights are the B-spline basis functions $N_{i,p}(u)$, which are piecewise polynomials of degree $p$. Their definition depends on a non-decreasing sequence of real numbers $T = \\{t_0, t_1, \\dots, t_m\\}$ called the knot vector, where the relation $m = n+p+1$ must hold. The basis functions are defined by the Cox–de Boor recursion formula.\n\nFor $p=0$:\n$$\nN_{i,0}(u) = \n\\begin{cases}\n1,  \\text{if } t_i \\le u  t_{i+1} \\\\\n0,  \\text{otherwise}\n\\end{cases}\n$$\nThis definition implies that for any interval of zero length, where $t_i = t_{i+1}$, the basis function $N_{i,0}(u)$ is always $0$. A special consideration is required for the parameter value $u$ at the very end of the domain. If the curve domain is $[t_p, t_{n+1}]$, then for $u = t_{n+1}$, the relevant non-zero degree-$0$ basis function is taken to be $N_{n,0}(t_{n+1})=1$.\n\nFor $p \\ge 1$:\n$$\nN_{i,p}(u) = \\frac{u - t_i}{t_{i+p} - t_i} N_{i,p-1}(u) + \\frac{t_{i+p+1} - u}{t_{i+p+1} - t_{i+1}} N_{i+1,p-1}(u)\n$$\nThe problem specifies that if a denominator in this expression is zero, the corresponding term is treated as zero.\n\nThe core of the task is to implement an algorithm for $\\mathbf{C}(u)$ based on these definitions and verify that for a clamped knot vector, $\\mathbf{C}(t_p) = \\mathbf{P}_0$ and $\\mathbf{C}(t_{n+1}) = \\mathbf{P}_n$. A clamped knot vector has its first $p+1$ knots equal and its last $p+1$ knots equal. This structure ensures that $N_{0,p}(t_p)=1$ and $N_{n,p}(t_{n+1})=1$, while all other basis functions $N_{i,p}$ are zero at the respective endpoints, leading to interpolation.\n\nThe overall algorithm proceeds as follows for each test case:\n1.  **Parameter Setup**: The degree $p$ and the set of $n+1$ control points $\\{\\mathbf{P}_i\\}$ are defined.\n2.  **Knot Vector Construction**: The knot vector $T$ is constructed. For cases requiring a clamped open-uniform knot vector, the first $p+1$ knots are set to $0$, the last $p+1$ knots are set to $1$, and the $n-p$ interior knots are spaced uniformly in the interval $(0,1)$. The number of knots is $m+1 = n+p+2$.\n3.  **Curve Evaluation at Endpoints**:\n    *   The curve is evaluated at the left endpoint of its domain, $u_{left} = t_p$.\n    *   The curve is evaluated at the right endpoint of its domain, $u_{right} = t_{n+1}$.\n    *   The evaluation itself, $\\mathbf{C}(u)$, is performed by a function that calculates $\\sum_{i=0}^{n} N_{i,p}(u)\\,\\mathbf{P}_i$.\n4.  **Basis Function Calculation**: The value of each basis function $N_{i,p}(u)$ is calculated using a recursive function that directly implements the Cox-de Boor formula. To ensure computational feasibility, this recursive function is memoized (a form of dynamic programming), preventing redundant calculations of the same basis function values. The implementation of the base case $N_{i,0}(u)$ must carefully handle the half-open interval and the special case at the domain's right endpoint.\n5.  **Verification**: The computed point $\\mathbf{C}(u_{left})$ is compared to the first control point $\\mathbf{P}_0$, and $\\mathbf{C}(u_{right})$ is compared to the last control point $\\mathbf{P}_n$. The comparison is done by calculating the Euclidean distance between the vectors. If the distance is within the specified tolerance of $10^{-9}$ for both endpoints, the test case is considered passed.\n\nThe implementation encapsulates these steps. A main function iterates through the test suite, calling helper functions to construct knot vectors and evaluate the B-spline curve. The evaluation function `b_spline_eval` uses a nested helper function `_basis_function` to compute the basis functions recursively. This nested structure allows the recursive function to be clean while having access to the parameter $u$, the knot vector $T$, and the memoization dictionary, avoiding the use of global state. The result of each test case (a boolean value) is collected and printed in the specified format.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_clamped_uniform_knot_vector(n, p):\n    \"\"\"\n    Constructs a clamped open-uniform knot vector.\n    The domain for the interior knots is (0, 1).\n    \n    Args:\n        n (int): The number of control points minus 1.\n        p (int): The degree of the B-spline.\n        \n    Returns:\n        np.ndarray: The knot vector of length n + p + 2.\n    \"\"\"\n    num_knots = n + p + 2\n    T = np.zeros(num_knots, dtype=float)\n    \n    num_interior_knots = n - p\n    if num_interior_knots  0:\n      denominator = float(n - p + 1)\n      T[p + 1 : n + 1] = np.arange(1, num_interior_knots + 1) / denominator\n    \n    T[n + 1:] = 1.0\n    return T\n\ndef b_spline_eval(u, p, control_points, T):\n    \"\"\"\n    Evaluates the B-spline curve at a parameter value u using the recursive\n    Cox-de Boor basis function definition with memoization.\n    \n    Args:\n        u (float): The parameter value.\n        p (int): The degree of the B-spline.\n        control_points (np.ndarray): Array of control points.\n        T (np.ndarray): The knot vector.\n        \n    Returns:\n        np.ndarray: The computed point on the curve.\n    \"\"\"\n    n = len(control_points) - 1\n    memo = {}\n\n    def _basis_function(i, deg):\n        \"\"\"\n        Computes the value of the B-spline basis function N_i,deg(u) via\n        a memoized recursion. This is a nested function to capture u, T, n, and memo.\n        \"\"\"\n        if (i, deg) in memo:\n            return memo[(i, deg)]\n\n        if deg == 0:\n            # The curve domain is [t_p, t_{n+1}]. At the right boundary u = t_{n+1},\n            # the convention is that u falls in the last interval [t_n, t_{n+1}],\n            # making N_{n,0}(t_{n+1}) = 1.\n            if u == T[n + 1] and i == n:\n                res = 1.0\n            else:\n                # Standard definition for half-open interval [t_i, t_{i+1}).\n                # This is 0 if t_i == t_{i+1}.\n                res = 1.0 if T[i] = u  T[i + 1] else 0.0\n            memo[(i, deg)] = res\n            return res\n\n        # Recursive step\n        term1 = 0.0\n        den1 = T[i + deg] - T[i]\n        if den1 != 0.0:\n            term1 = ((u - T[i]) / den1) * _basis_function(i, deg - 1)\n\n        term2 = 0.0\n        den2 = T[i + deg + 1] - T[i + 1]\n        if den2 != 0.0:\n            term2 = ((T[i + deg + 1] - u) / den2) * _basis_function(i + 1, deg - 1)\n\n        res = term1 + term2\n        memo[(i, deg)] = res\n        return res\n\n    curve_point = np.zeros_like(control_points[0], dtype=float)\n    for i in range(n + 1):\n        basis_val = _basis_function(i, p)\n        # Optimization: only add if the basis function is non-zero\n        if basis_val  1e-12: # Check against small tolerance\n            curve_point += basis_val * control_points[i]\n            \n    return curve_point\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and verify endpoint interpolation.\n    \"\"\"\n    test_cases = [\n        # Case 1: 2D quadratic\n        {\n            \"p\": 2,\n            \"control_points\": np.array([\n                [0, 0], [1, 2], [2, 0.5], [3, 3], [4, 0]\n            ]),\n            \"knot_vector\": None \n        },\n        # Case 2: 2D cubic, Bezier-like\n        {\n            \"p\": 3,\n            \"control_points\": np.array([\n                [0, 0], [1, 2], [3, 2], [4, 0]\n            ]),\n            \"knot_vector\": None\n        },\n        # Case 3: 2D cubic, non-uniform knots\n        {\n            \"p\": 3,\n            \"control_points\": np.array([\n                [0, 0], [1, 1], [2, -1], [3, 2], [4, -0.5], [5, 1.5], [6, 0]\n            ]),\n            \"knot_vector\": np.array([0, 0, 0, 0, 0.15, 0.6, 0.85, 1, 1, 1, 1])\n        },\n        # Case 4: 2D linear\n        {\n            \"p\": 1,\n            \"control_points\": np.array([\n                [0, 1], [1, 0], [2, 1.5]\n            ]),\n            \"knot_vector\": None\n        },\n        # Case 5: 3D cubic\n        {\n            \"p\": 3,\n            \"control_points\": np.array([\n                [0, 0, 0], [1, 2, 1], [2, -1, 2], [3, 3, 2], [4, 0, 1], [5, 1, 0]\n            ]),\n            \"knot_vector\": None\n        }\n    ]\n\n    results = []\n    tolerance = 1e-9\n\n    for case in test_cases:\n        p = case[\"p\"]\n        P = case[\"control_points\"]\n        n = len(P) - 1\n\n        if case[\"knot_vector\"] is None:\n            T = build_clamped_uniform_knot_vector(n, p)\n        else:\n            T = case[\"knot_vector\"]\n        \n        # Endpoints of the parametric domain for a clamped knot vector\n        u_left = T[p]\n        u_right = T[n + 1]\n\n        # Evaluate curve at endpoints\n        C_left = b_spline_eval(u_left, p, P, T)\n        C_right = b_spline_eval(u_right, p, P, T)\n\n        # Verify interpolation\n        dist_left = np.linalg.norm(C_left - P[0])\n        dist_right = np.linalg.norm(C_right - P[-1])\n\n        check_left = dist_left = tolerance\n        check_right = dist_right = tolerance\n        \n        results.append(check_left and check_right)\n\n    # Format output as required\n    print(f\"[{','.join(map(str, results))}]\".lower())\n\nsolve()\n```"
        },
        {
            "introduction": "Beyond basic evaluation, precise shape control is paramount in B-spline modeling. This practice explores the powerful technique of manipulating knot multiplicity to alter a curve's local continuity from smooth ($C^{p-1}$) to sharp ($C^0$). You will investigate how inserting a knot multiple times affects the curve's shape and quantify this change by implementing and measuring the jump in the curve's derivative at the knot .",
            "id": "3099558",
            "problem": "You will investigate how increasing knot multiplicity in a cubic B-spline affects local shape, including possible overshoot relative to a baseline curve and the creation of corners or flat spots. Work entirely in a purely mathematical setting with two-dimensional control points and standard B-spline definitions. Your program must be a complete, runnable implementation that evaluates curves and their derivatives from first principles, and computes quantitative metrics for a small test suite.\n\nFundamental base and definitions:\n- A B-spline curve of degree $p$ with control points $\\{\\mathbf{P}_i\\}_{i=0}^{N-1}$ and nondecreasing knot vector $\\{t_j\\}_{j=0}^{N+p}$ is defined as\n$$\n\\mathbf{C}(t) = \\sum_{i=0}^{N-1} N_{i,p}(t)\\,\\mathbf{P}_i,\n$$\nwhere $N_{i,p}(t)$ are B-spline basis functions defined by the Cox–de Boor recursion:\n$$\nN_{i,0}(t) =\n\\begin{cases}\n1,  t_i \\le t lt t_{i+1},\\\\\n0,  \\text{otherwise},\n\\end{cases}\n$$\nand for $p \\ge 1$\n$$\nN_{i,p}(t) = \\frac{t - t_i}{t_{i+p} - t_i} N_{i,p-1}(t) + \\frac{t_{i+p+1} - t}{t_{i+p+1} - t_{i+1}} N_{i+1,p-1}(t),\n$$\nwith the convention that terms with zero denominators contribute $0$.\n- The derivative of the curve uses the derivatives of basis functions:\n$$\n\\mathbf{C}'(t) = \\sum_{i=0}^{N-1} \\frac{d N_{i,p}(t)}{dt}\\,\\mathbf{P}_i,\n$$\nwhere\n$$\n\\frac{d N_{i,p}(t)}{dt} = \\frac{p}{t_{i+p} - t_i} N_{i,p-1}(t) - \\frac{p}{t_{i+p+1} - t_{i+1}} N_{i+1,p-1}(t),\n$$\nagain interpreting divisions by zero as contributing $0$.\n- For a knot of multiplicity $m$ in a degree-$p$ B-spline, the curve continuity at that knot is $C^{p-m}$, meaning that the first $p-m$ derivatives are continuous while the $(p-m+1)$-st derivative generally has a jump. In particular, if $m = p+1$, the curve has a break (no positional continuity) at that knot.\n\nScenario and modeling setup:\n- Use degree $p = 3$ (cubic) and $N = 8$ control points in $\\mathbb{R}^2$.\n- Use an open knot vector with repeated endpoints:\n$$\n\\underbrace{0,0,0,0}_{p+1\\text{ times}}, \\text{interior knots}, \\underbrace{1,1,1,1}_{p+1\\text{ times}}.\n$$\n- Let the interior knot location of interest be $u_0 = 0.5$. The total number of interior knot entries is $N - p - 1 = 4$. For a chosen multiplicity $m \\in \\{1,2,3,4\\}$ at $u_0$, construct the interior knot multiset as follows. Include $m$ copies of $u_0$ and use the remaining $4 - m$ entries from the fixed list $\\{0.25,\\,0.33,\\,0.75\\}$, taking the smallest $4-m$ elements from this list and then sorting all interior entries. This produces exactly four interior knot entries for every $m$.\n- Define two scenarios of control points:\n  - Scenario A (hump-like):\n    - $\\mathbf{P}_0=(0.0, 0.0)$,\n    - $\\mathbf{P}_1=(1.0, 1.0)$,\n    - $\\mathbf{P}_2=(2.0, 2.0)$,\n    - $\\mathbf{P}_3=(3.0, 4.0)$,\n    - $\\mathbf{P}_4=(4.0, 2.0)$,\n    - $\\mathbf{P}_5=(5.0, 1.5)$,\n    - $\\mathbf{P}_6=(6.0, 1.2)$,\n    - $\\mathbf{P}_7=(7.0, 1.1)$.\n  - Scenario B (locally flat region):\n    - $\\mathbf{P}_0=(0.0, 0.0)$,\n    - $\\mathbf{P}_1=(1.0, 0.5)$,\n    - $\\mathbf{P}_2=(2.0, 1.0)$,\n    - $\\mathbf{P}_3=(3.0, 1.0)$,\n    - $\\mathbf{P}_4=(4.0, 1.0)$,\n    - $\\mathbf{P}_5=(5.0, 1.0)$,\n    - $\\mathbf{P}_6=(6.0, 1.2),\n    - $\\mathbf{P}_7=(7.0, 2.0)$.\n\nQuantities to compute:\n- Define the baseline curve to be the cubic B-spline with multiplicity $m=1$ at $u_0=0.5$, using the interior-knot construction above. Denote this baseline as $\\mathbf{C}_{\\mathrm{base}}(t)$.\n- For each scenario and for each $m \\in \\{1,2,3,4\\}$, construct the corresponding knot vector and compute:\n  1. The maximum absolute deviation from the baseline on a uniform sample of parameter values:\n     $$\n     D_{\\max}(m) = \\max_{t \\in \\mathcal{T}} \\left\\lVert \\mathbf{C}_m(t) - \\mathbf{C}_{\\mathrm{base}}(t) \\right\\rVert_2.\n     $$\n     Use the Euclidean norm. Let the sample $\\mathcal{T}$ be $4001$ equally spaced points in the open interval $(0,1)$, for instance $t_k$ linearly spaced from $10^{-6}$ to $1-10^{-6}$ to avoid evaluating exactly at knots.\n  2. A numerical measure of the slope discontinuity at the interior knot $u_0$:\n     $$\n     J(m) = \\left\\lVert \\mathbf{C}_m'(u_0^+) - \\mathbf{C}_m'(u_0^-) \\right\\rVert_2.\n     $$\n     To evaluate one-sided derivatives without hitting the knot exactly, choose\n     $$\n     \\delta = \\min\\left(0.1\\,(u_0 - u_\\text{L}),\\, 0.1\\,(u_\\text{R} - u_0),\\, 10^{-3}\\right),\n     $$\n     where $u_\\text{L}$ is the largest knot strictly less than $u_0$, and $u_\\text{R}$ is the smallest knot strictly greater than $u_0$ in the constructed knot vector. Then approximate the one-sided derivatives by evaluating $\\mathbf{C}_m'(u_0 - \\delta)$ and $\\mathbf{C}_m'(u_0 + \\delta)$ using the basis-derivative formula above. The Euclidean norm of their difference is $J(m)$.\n\nTest suite and required output:\n- Use both Scenario A and Scenario B control points.\n- For each scenario, evaluate the pair $\\left(D_{\\max}(m), J(m)\\right)$ for $m = 1, 2, 3, 4$.\n- Round each reported floating-point result to six decimal places.\n- Your program should produce a single line of output containing all results for both scenarios as a comma-separated list enclosed in square brackets. The ordering must be:\n  - Scenario A: $D_{\\max}(1)$, $J(1)$, $D_{\\max}(2)$, $J(2)$, $D_{\\max}(3)$, $J(3)$, $D_{\\max}(4)$, $J(4)$,\n  - followed by Scenario B in the same order.\nThat is, the output format is\n$$\n[\\;D_{\\max}^{A}(1),J^{A}(1),D_{\\max}^{A}(2),J^{A}(2),D_{\\max}^{A}(3),J^{A}(3),D_{\\max}^{A}(4),J^{A}(4),D_{\\max}^{B}(1),J^{B}(1),D_{\\max}^{B}(2),J^{B}(2),D_{\\max}^{B}(3),J^{B}(3),D_{\\max}^{B}(4),J^{B}(4)\\;].\n$$\nNo units are required because all quantities are dimensionless.",
            "solution": "The user has provided a well-defined computational problem concerning the properties of B-spline curves. I will first validate the problem statement and then provide a comprehensive solution based on fundamental principles.\n\n### Problem Validation\n\n1.  **Extraction of Givens**:\n    - **Curve Type**: B-spline curve of degree $p=3$ with $N=8$ control points in $\\mathbb{R}^2$.\n    - **Curve Definition**: $\\mathbf{C}(t) = \\sum_{i=0}^{N-1} N_{i,p}(t)\\,\\mathbf{P}_i$, with basis functions $N_{i,p}(t)$ defined by the Cox–de Boor recursion.\n    - **Curve Derivative**: $\\mathbf{C}'(t) = \\sum_{i=0}^{N-1} \\frac{d N_{i,p}(t)}{dt}\\,\\mathbf{P}_i$, with $\\frac{d N_{i,p}(t)}{dt} = \\frac{p}{t_{i+p} - t_i} N_{i,p-1}(t) - \\frac{p}{t_{i+p+1} - t_{i+1}} N_{i+1,p-1}(t)$.\n    - **Knot Vector**: Open knot vector with $p+1=4$ knots at $0$ and $4$ knots at $1$. It contains $N-p-1=4$ interior knots.\n    - **Interior Knot Construction**: For a multiplicity $m \\in \\{1,2,3,4\\}$ at $u_0 = 0.5$, the four interior knots are formed by $m$ copies of $0.5$ and the $4-m$ smallest values from the set $\\{0.25, 0.33, 0.75\\}$, sorted.\n    - **Control Point Scenarios**: Two sets of control points, Scenario A (hump-like) and Scenario B (locally flat region), are provided.\n    - **Metrics**:\n        1.  $D_{\\max}(m) = \\max_{t \\in \\mathcal{T}} \\left\\lVert \\mathbf{C}_m(t) - \\mathbf{C}_{\\mathrm{base}}(t) \\right\\rVert_2$, where $\\mathbf{C}_{\\mathrm{base}}$ is the curve for $m=1$. Evaluation grid $\\mathcal{T}$ has $4001$ points in $(0,1)$.\n        2.  $J(m) = \\left\\lVert \\mathbf{C}_m'(u_0^+) - \\mathbf{C}_m'(u_0^-) \\right\\rVert_2$, with one-sided derivatives approximated at $u_0 \\pm \\delta$. $\\delta$ is defined as $\\min\\left(0.1\\,(u_0 - u_\\text{L}),\\, 0.1\\,(u_\\text{R} - u_0),\\, 10^{-3}\\right)$.\n    - **Output Format**: A single line containing a comma-separated list of $16$ floating-point values rounded to six decimal places, representing $(D_{\\max}(m), J(m))$ for $m \\in \\{1,2,3,4\\}$ for each of the two scenarios.\n\n2.  **Validation against Criteria**:\n    - **Scientifically Grounded**: The problem is rooted in the standard mathematical theory of B-splines, a core topic in computational science and computer-aided geometric design. All definitions and formulas are correct.\n    - **Well-Posed**: The problem is specified with a high degree of precision. All parameters, data, construction rules, and formulas for the quantities to be computed are explicitly given. The setup is self-contained and sufficient to produce a unique, deterministic solution.\n    - **Objective**: The problem statement is entirely objective, using precise mathematical language and quantitative definitions. There are no subjective or ambiguous elements.\n    - **Other criteria**: The problem is not trivial, as it requires a correct from-first-principles implementation of a non-trivial algorithm. It is not contradictory, unrealistic, or ill-posed.\n\n3.  **Verdict and Action**:\n    The problem statement is **valid**. I will proceed with formulating and implementing a solution.\n\n### Solution Design\n\nThe solution requires implementing B-spline curve evaluation and its derivative from the provided fundamental definitions. A direct recursive implementation of the Cox-de Boor formula is computationally inefficient. A more robust and performant approach, based on algorithms from standard literature (e.g., \"The NURBS Book\" by Piegl and Tiller), will be used. This adheres to the \"from first principles\" requirement as the algorithms are direct implementations of the mathematical definitions.\n\n1.  **Core Algorithms**:\n    - **Knot Span Search**: A function `find_span` will be implemented to efficiently locate the knot interval (span) containing a given parameter value $t$. This is a prerequisite for efficient basis function evaluation and is typically implemented using binary search.\n    - **Basis Function Evaluation**: A function `basis_funs` will implement an iterative, dynamic programming approach (Algorithm A2.2 from The NURBS Book) to calculate the values of all non-zero basis functions of a given degree for a parameter $t$ within its knot span. This is significantly more efficient than a naive recursive approach.\n    - **Curve Evaluation**: The function `evaluate_bspline` will combine `find_span` and `basis_funs` to compute a point on the curve $\\mathbf{C}(t)$. It finds the relevant knot span, computes the non-zero basis functions, and then takes their weighted sum with the corresponding control points.\n    - **Curve Derivative Evaluation**: The function `evaluate_bspline_derivative` will compute $\\mathbf{C}'(t)$ by directly implementing the sum $\\sum_i \\frac{d N_{i,p}(t)}{dt} \\mathbf{P}_i$. The derivatives of the basis functions, $\\frac{d N_{i,p}(t)}{dt}$, will be calculated using the provided formula, which in turn requires basis functions of degree $p-1$. These will be efficiently computed using the same `basis_funs` algorithm.\n\n2.  **Workflow for a Single Case ($m$, Scenario)**:\n    - **Knot Vector Construction**: The full knot vector of length $N+p+1=12$ is constructed by concatenating the starting repeated knots ($p+1$ zeros), the four specified interior knots, and the ending repeated knots ($p+1$ ones).\n    - **Curve Evaluation for $D_{\\max}$**: For each $m$, the curve $\\mathbf{C}_m(t)$ is evaluated at $4001$ sample points in $(0,1)$. For $m=1$, these points define the baseline curve $\\mathbf{C}_{\\mathrm{base}}$. For $m1$, the Euclidean distance to the corresponding baseline points is computed, and the maximum of these distances gives $D_{\\max}(m)$. By definition, $D_{\\max}(1)=0$.\n    - **Derivative Jump Calculation for $J(m)$**: The small offset $\\delta$ is determined according to the problem's rule. The derivative $\\mathbf{C}_m'(t)$ is evaluated at $u_0 - \\delta$ and $u_0 + \\delta$. The Euclidean norm of the difference between these two derivative vectors gives the jump $J(m)$. The continuity properties of B-splines suggest that $J(1)$ and $J(2)$ should be near zero, while $J(3)$ and $J(4)$ may be significantly non-zero, providing a good sanity check for the implementation.\n\n3.  **Overall Structure**:\n    The main program will iterate through the two control point scenarios. Within each scenario, it will iterate through multiplicities $m$ from $1$ to $4$. In each sub-case, it will construct the appropriate knot vector, compute the pair $(D_{\\max}(m), J(m))$, and store the results. Finally, all $16$ scalar results will be formatted into a single string as required.",
            "answer": "```python\nimport numpy as np\n\ndef find_span(num_cp, degree, t, knots):\n    \"\"\"\n    Finds the knot span index for a given parameter t.\n    num_cp: number of control points (N).\n    degree: degree of the curve (p).\n    t: parameter value.\n    knots: knot vector.\n    Returns the index k such that knots[k] = t  knots[k+1].\n    \"\"\"\n    # For t=1.0, which can occur at the end of the domain for an open knot vector.\n    # The valid parameter range is [knots[p], knots[N]]. For an open knot vector,\n    # this is [0, 1]. The last span index is N-1.\n    if t = knots[num_cp]:\n        return num_cp - 1\n    \n    # Binary search for the span. The search space is [p, N-1].\n    low = degree\n    high = num_cp\n    \n    while low  high:\n        mid = (low + high) // 2\n        if t  knots[mid]:\n            high = mid\n        else:\n            low = mid + 1\n    return low - 1\n\ndef basis_funs(span, t, degree, knots):\n    \"\"\"\n    Computes the non-zero B-spline basis functions for a given parameter t.\n    (Algorithm A2.2 from The NURBS Book by Piegl and Tiller).\n    span: knot span index.\n    t: parameter value.\n    degree: degree of the curve.\n    knots: knot vector.\n    Returns an array of p+1 basis function values, N_{span-degree, degree}, ..., N_{span, degree}.\n    \"\"\"\n    basis = np.zeros(degree + 1)\n    left = np.zeros(degree + 1)\n    right = np.zeros(degree + 1)\n    \n    basis[0] = 1.0\n    for j in range(1, degree + 1):\n        left[j] = t - knots[span + 1 - j]\n        right[j] = knots[span + j] - t\n        saved = 0.0\n        for r in range(j):\n            # The denominator is knots[span+r+1] - knots[span+r+1-j]\n            den = knots[span + r + 1] - knots[span + r + 1 - j]\n            if den == 0.0:\n                temp = 0.0\n            else:\n                temp = basis[r] / den\n            basis[r] = saved + right[r + 1] * temp\n            saved = left[j - r] * temp\n        basis[j] = saved\n    return basis\n\ndef evaluate_bspline(t, num_cp, degree, knots, control_points):\n    \"\"\"\n    Evaluates a B-spline curve at a given parameter t.\n    \"\"\"\n    if t  knots[degree] or t  knots[num_cp]:\n        if t = knots[degree]: return control_points[0]\n        else: return control_points[-1]\n\n    span = find_span(num_cp, degree, t, knots)\n    basis_values = basis_funs(span, t, degree, knots)\n    \n    curve_point = np.zeros_like(control_points[0], dtype=float)\n    for i in range(degree + 1):\n        curve_point += basis_values[i] * control_points[span - degree + i]\n    return curve_point\n\ndef evaluate_bspline_derivative(t, num_cp, degree, knots, control_points):\n    \"\"\"\n    Evaluates the derivative of a B-spline curve at a given parameter t.\n    \"\"\"\n    if t  knots[degree] or t  knots[num_cp]:\n        return np.zeros_like(control_points[0], dtype=float)\n\n    span = find_span(num_cp, degree, t, knots)\n    basis_values_p_minus_1 = basis_funs(span, t, degree - 1, knots)\n    \n    deriv_point = np.zeros_like(control_points[0], dtype=float)\n    \n    for i in range(span - degree, span + 1):\n        # Contribution from control point P_i\n        # dN_{i,p}/dt = p/(t_{i+p}-t_i) * N_{i,p-1} - p/(t_{i+p+1}-t_{i+1}) * N_{i+1,p-1}\n        \n        # Term 1: involving N_{i, p-1}\n        num1 = 0.0\n        # The non-zero basis functions of degree p-1 for span k are N_{k-(p-1),p-1} to N_{k,p-1}\n        # In our case, span=span, degree=p-1. So N_{span-(p-1),p-1} to N_{span,p-1}.\n        if (span - (degree - 1)) = i = span:\n            num1 = basis_values_p_minus_1[i - (span - (degree - 1))]\n        \n        den1 = knots[i + degree] - knots[i]\n        term1 = 0.0\n        if den1 != 0.0:\n            term1 = degree * num1 / den1\n\n        # Term 2: involving N_{i+1, p-1}\n        num2 = 0.0\n        if (span - (degree - 1)) = (i + 1) = span:\n            num2 = basis_values_p_minus_1[i + 1 - (span - (degree - 1))]\n\n        den2 = knots[i + degree + 1] - knots[i + 1]\n        term2 = 0.0\n        if den2 != 0.0:\n            term2 = degree * num2 / den2\n        \n        d_basis = term1 - term2\n        deriv_point += d_basis * control_points[i]\n        \n    return deriv_point\n\n\ndef solve():\n    p = 3\n    N = 8\n    u0 = 0.5\n    \n    P_A = np.array([\n        [0.0, 0.0], [1.0, 1.0], [2.0, 2.0], [3.0, 4.0],\n        [4.0, 2.0], [5.0, 1.5], [6.0, 1.2], [7.0, 1.1]\n    ], dtype=float)\n    \n    P_B = np.array([\n        [0.0, 0.0], [1.0, 0.5], [2.0, 1.0], [3.0, 1.0],\n        [4.0, 1.0], [5.0, 1.0], [6.0, 1.2], [7.0, 2.0]\n    ], dtype=float)\n\n    scenarios = [(\"A\", P_A), (\"B\", P_B)]\n    interior_knot_pool = [0.25, 0.33, 0.75]\n    \n    t_samples = np.linspace(1e-6, 1.0 - 1e-6, 4001)\n    \n    all_results = []\n    \n    for _, P in scenarios:\n        C_base_pts = None\n        \n        for m in range(1, 5):\n            # 1. Construct knot vector\n            num_other_knots = 4 - m\n            interior_knots = sorted(interior_knot_pool[:num_other_knots] + [u0] * m)\n            knots = np.concatenate((np.zeros(p + 1, dtype=float), np.array(interior_knots, dtype=float), np.ones(p + 1, dtype=float)))\n\n            # 2. Compute curve points for D_max calculation\n            C_m_pts = np.array([evaluate_bspline(t, N, p, knots, P) for t in t_samples])\n            \n            if m == 1:\n                C_base_pts = C_m_pts\n                D_max = 0.0\n            else:\n                deviations = np.linalg.norm(C_m_pts - C_base_pts, axis=1)\n                D_max = np.max(deviations)\n\n            # 3. Compute slope discontinuity J(m)\n            unique_knots = sorted(list(set(knots)))\n            u_L_idx = np.searchsorted(unique_knots, u0, side='left') - 1\n            u_R_idx = np.searchsorted(unique_knots, u0, side='right')\n            u_L = unique_knots[u_L_idx] if u_L_idx = 0 else knots[0]\n            u_R = unique_knots[u_R_idx] if u_R_idx  len(unique_knots) else knots[-1]\n            \n            term_L = 0.1 * (u0 - u_L) if u_L  u0 else np.inf\n            term_R = 0.1 * (u_R - u0) if u_R  u0 else np.inf\n            delta = min(term_L, term_R, 1e-3)\n            \n            dC_left = evaluate_bspline_derivative(u0 - delta, N, p, knots, P)\n            dC_right = evaluate_bspline_derivative(u0 + delta, N, p, knots, P)\n            J_m = np.linalg.norm(dC_right - dC_left)\n            \n            all_results.extend([D_max, J_m])\n            \n    print(f\"[{','.join(f'{r:.6f}' for r in all_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Moving from geometric design to numerical analysis, B-splines serve as a powerful basis for function approximation. This advanced exercise demonstrates their role in scientific computing by tasking you with projecting a function onto a B-spline space via an $L^2$ projection. You will conduct a convergence study to empirically confirm the theoretical error bounds, observing how the approximation error scales with mesh size $h$ at a rate of $O(h^{p+1})$ .",
            "id": "3099508",
            "problem": "You are tasked with designing and implementing a numerical experiment that demonstrates the approximation power of B-splines in the setting of introduction to computational science. The experiment must be defined, executed, and its results reported by a complete, runnable program. The experiment focuses on projecting a smooth target function onto a spline space and studying how the approximation error scales under uniform mesh refinement.\n\nThe domain is the closed interval $[0,1]$. The target function is $f(x) = \\sin(10 x)$, where the argument of the sine function is measured in radians. The spline space is the B-spline space of degree $p$ with an open uniform knot vector on $[0,1]$. The knot vector should have $M$ uniform elements, where $h = 1/M$ is the mesh size, the endpoints $0$ and $1$ are each repeated $p+1$ times, and the interior knots are placed at the uniform subdivision points $x = i h$ for $i = 1,2,\\ldots,M-1$. The number of basis functions in this space is $n = M + p$.\n\nThe projection is the $L^2$ (square-integrable) projection. Let $S_{p,h}$ denote the spline space of degree $p$ and mesh size $h$. The $L^2$ projection $s \\in S_{p,h}$ of $f$ is characterized by the Galerkin orthogonality conditions with respect to the spline basis: for every basis function $v \\in S_{p,h}$, the residual satisfies $\\int_0^1 (f(x) - s(x)) \\, v(x) \\, dx = 0$. You must implement the normalized B-spline basis evaluation from first principles using the standard recursive definition (Cox–de Boor recursion) and assemble the linear system that enforces these orthogonality conditions on the coefficients of $s$. All integrations in the assembly and in the error computation must be performed numerically using Gaussian quadrature of sufficiently high order on each subinterval so that the quadrature error is negligible relative to the spline approximation error. Use Gauss–Legendre quadrature on each element, with at least $50$ quadrature points per element. All computations must be in double precision. Angles must be interpreted in radians, and norms and integrals carry no physical unit because the domain and function are nondimensional.\n\nThe $L^2$ error is the $L^2$ norm of the difference $f - s$, defined by $\\| f - s \\|_{L^2(0,1)} = \\left( \\int_0^1 (f(x) - s(x))^2 \\, dx \\right)^{1/2}$. Implement a reliable numerical evaluation of this error via element-wise Gaussian quadrature.\n\nYou must run a convergence study in which $h$ is refined uniformly and the error is measured for each refinement. For a fixed degree $p$, consider the mesh sizes corresponding to $M \\in \\{8, 16, 32, 64\\}$. For each degree $p \\in \\{0, 1, 2, 3\\}$, compute the list of $L^2$ errors for these mesh sizes and then compute the observed convergence rate by performing a linear least-squares fit of $\\log(\\text{error})$ versus $\\log(h)$; the fitted slope is the observed rate. The asymptotic expectation is that the rate should be approximately $p+1$ for smooth $f$.\n\nYour program must implement:\n- Construction of the open uniform knot vector for given $p$ and $M$.\n- Evaluation of all normalized B-spline basis functions of degree $p$ on a given set of points via the Cox–de Boor recursion.\n- Assembly of the $L^2$ projection linear system using numerical quadrature.\n- Solution of the linear system for the spline coefficients and computation of the $L^2$ error via quadrature.\n- Computation of the observed convergence rate from the $(h, \\text{error})$ data.\n\nTest suite specification:\n- Case $1$: $p = 0$ with $M \\in \\{8, 16, 32, 64\\}$.\n- Case $2$: $p = 1$ with $M \\in \\{8, 16, 32, 64\\}$.\n- Case $3$: $p = 2$ with $M \\in \\{8, 16, 32, 64\\}$.\n- Case $4$: $p = 3$ with $M \\in \\{8, 16, 32, 64\\}$.\n\nFor each case, report the observed convergence rate as a single floating-point number rounded to three decimal places. These four values together constitute the final output.\n\nFinal output format:\nYour program should produce a single line of output containing the four observed rates, ordered by increasing $p$, formatted as a comma-separated list enclosed in square brackets, for example, $[r_0,r_1,r_2,r_3]$, where each $r_p$ is a float rounded to three decimals. No additional text or lines should be printed.",
            "solution": "We begin from the fundamental definitions of B-splines and the $L^2$ projection.\n\nLet $[0,1]$ be partitioned uniformly into $M$ elements with mesh size $h = 1/M$. For a given degree $p \\in \\mathbb{N}_0$, we consider the open uniform knot vector. Denote the knot vector by $\\{t_i\\}_{i=0}^{K-1}$, where the endpoints are repeated $p+1$ times and the interior knots are placed at $i h$ for $i=1,2,\\ldots,M-1$. Explicitly,\n$$\nt_0 = t_1 = \\cdots = t_p = 0,\\quad\nt_{p+1} = h,\\quad\nt_{p+2} = 2h,\\quad \\ldots,\\quad t_{p+M-1} = (M-1)h,\\quad\nt_{K-p-1} = t_{K-p} = \\cdots = t_{K-1} = 1,\n$$\nwith $K = (M-1) + 2(p+1)$ and the number of basis functions $n = K - p - 1 = M + p$. The normalized B-spline basis functions $\\{N_{i,p}(x)\\}_{i=0}^{n-1}$ are defined recursively by the Cox–de Boor recursion. The base case for piecewise constants ($p = 0$) is the indicator of the half-open support interval:\n$$\nN_{i,0}(x) = \n\\begin{cases}\n1  \\text{if } t_i \\le x  t_{i+1}, \\\\\n0  \\text{otherwise}.\n\\end{cases}\n$$\nThe recursive definition for $p \\ge 1$ is\n$$\nN_{i,p}(x) = \\alpha_{i,p}(x)\\, N_{i,p-1}(x) + \\beta_{i,p}(x)\\, N_{i+1,p-1}(x),\n$$\nwith blending coefficients\n$$\n\\alpha_{i,p}(x) = \n\\begin{cases}\n\\dfrac{x - t_i}{t_{i+p} - t_i}  \\text{if } t_{i+p}  t_i,\\\\\n0  \\text{otherwise},\n\\end{cases}\n\\qquad\n\\beta_{i,p}(x) =\n\\begin{cases}\n\\dfrac{t_{i+p+1} - x}{t_{i+p+1} - t_{i+1}}  \\text{if } t_{i+p+1}  t_{i+1},\\\\\n0  \\text{otherwise}.\n\\end{cases}\n$$\nThese definitions imply that the basis functions are nonnegative, have minimal local support on $[t_i, t_{i+p+1}]$, and form a partition of unity on $[0,1]$.\n\nLet $S_{p,h} = \\operatorname{span}\\{N_{i,p}\\}_{i=0}^{n-1}$ be the spline space. The $L^2$ projection $s \\in S_{p,h}$ of a given function $f$ is defined by the Galerkin orthogonality:\n$$\n\\int_0^1 \\left( f(x) - s(x) \\right) v(x) \\, dx = 0 \\quad \\text{for all } v \\in S_{p,h}.\n$$\nWriting $s(x) = \\sum_{i=0}^{n-1} c_i\\, N_{i,p}(x)$ and choosing the test functions $v = N_{j,p}$ for $j = 0,1,\\ldots,n-1$, we obtain the linear system\n$$\n\\sum_{i=0}^{n-1} c_i \\int_0^1 N_{i,p}(x) N_{j,p}(x) \\, dx = \\int_0^1 f(x) N_{j,p}(x) \\, dx,\\quad j=0,\\ldots,n-1.\n$$\nDefining the mass matrix $M \\in \\mathbb{R}^{n \\times n}$ and the right-hand side $b \\in \\mathbb{R}^n$ by\n$$\nM_{j,i} = \\int_0^1 N_{i,p}(x) N_{j,p}(x) \\, dx,\\qquad\nb_j = \\int_0^1 f(x) N_{j,p}(x) \\, dx,\n$$\nthe coefficients $c = (c_0,\\ldots,c_{n-1})^\\top$ satisfy\n$$\nM c = b.\n$$\nThe $L^2$ approximation error is then\n$$\n\\| f - s \\|_{L^2(0,1)} = \\left( \\int_0^1 \\left( f(x) - \\sum_{i=0}^{n-1} c_i N_{i,p}(x) \\right)^2 \\, dx \\right)^{1/2}.\n$$\n\nNumerical integration is performed by Gauss–Legendre quadrature of order $q$ on each element. Let the reference Gauss–Legendre points and weights on $[-1,1]$ be $\\{\\xi_k, w_k\\}_{k=1}^q$. For the element interval $[a,b]$, the affine mapping $x = \\frac{b-a}{2} \\xi + \\frac{a+b}{2}$ yields the physical quadrature points $\\{x_k\\}$ and weights $\\{ \\hat{w}_k = \\frac{b-a}{2} w_k \\}$. Summing over all elements, integrals over $[0,1]$ are approximated by\n$$\n\\int_0^1 g(x)\\, dx \\approx \\sum_{e=1}^{M} \\sum_{k=1}^q \\hat{w}_{e,k}\\, g(x_{e,k}).\n$$\nIn our setting, we take $q \\ge 50$ to ensure that the quadrature error is negligible; this choice safely handles the polynomial products in the mass matrix and the oscillatory term $\\sin(10 x)$ in the right-hand side.\n\nThe algorithmic steps are:\n1. For given $p$ and $M$, construct the open uniform knot vector $\\{t_i\\}$ and compute the number of basis functions $n$.\n2. Create the global quadrature points and weights by looping over elements and mapping the $q$-point Gauss–Legendre rule to each element.\n3. Evaluate all basis functions $\\{N_{i,p}\\}_{i=0}^{n-1}$ at all quadrature points using the Cox–de Boor recursion. Organize the evaluations into a matrix $B \\in \\mathbb{R}^{n \\times N_q}$, where $N_q = M \\cdot q$ is the total number of quadrature points.\n4. Assemble the mass matrix using the weighted inner products,\n$$\nM = B \\, \\operatorname{diag}(w) \\, B^\\top,\n$$\nwhere $w \\in \\mathbb{R}^{N_q}$ are the global quadrature weights.\n5. Assemble the right-hand side by\n$$\nb = B \\left( w \\odot f(x) \\right),\n$$\nwhere $f(x) = \\sin(10 x)$ evaluated at the quadrature points and $\\odot$ denotes pointwise multiplication.\n6. Solve the linear system $M c = b$ for the coefficients $c$ in double precision.\n7. Compute the spline approximation values at the quadrature points by $s(x) = \\sum_i c_i N_{i,p}(x)$, which vectorizes to $s = B^\\top c$.\n8. Compute the $L^2$ error by\n$$\n\\| f - s \\|_{L^2(0,1)} \\approx \\left( \\sum_{k=1}^{N_q} w_k \\left( f(x_k) - s(x_k) \\right)^2 \\right)^{1/2}.\n$$\n9. For each degree $p \\in \\{0,1,2,3\\}$ and mesh sizes $M \\in \\{8,16,32,64\\}$, compute the errors, then perform a least-squares fit of $\\log(\\text{error})$ versus $\\log(h)$ to estimate the slope $r_p$. Concretely, if we denote $X = \\log(h)$ and $Y = \\log(\\text{error})$, then the fitted slope is\n$$\nr_p = \\frac{\\sum_i (X_i - \\bar{X})(Y_i - \\bar{Y})}{\\sum_i (X_i - \\bar{X})^2},\n$$\nwhere the sums run over the refinement levels and bars denote averages. In practice, this is obtained via polynomial fitting of degree one.\n\nBy approximation theory for spline spaces, for sufficiently smooth $f$ and uniform refinement, the $L^2$ projection error satisfies\n$$\n\\| f - s \\|_{L^2(0,1)} \\le C\\, h^{p+1} \\, |f|_{H^{p+1}(0,1)},\n$$\nfor some constant $C$ independent of $h$, which implies an observed convergence rate close to $p+1$. The test suite includes $p=0$ (piecewise constants) as a significant edge case, and increasingly higher degrees up to $p=3$, and it ranges from relatively coarse meshes ($M=8$) to fine meshes ($M=64$), covering the happy path and boundary conditions at the endpoints via the open knot construction.\n\nThe program outputs the four observed rates, rounded to three decimals, as a single comma-separated list enclosed in square brackets, ordered by increasing $p$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef open_uniform_knots(M: int, p: int) - np.ndarray:\n    \"\"\"\n    Construct open uniform knot vector on [0,1] with M elements and degree p.\n    Endpoints are repeated p+1 times. Interior knots are at i/M for i=1..M-1.\n    \"\"\"\n    interior = np.linspace(0.0, 1.0, M + 1)\n    # Exclude endpoints from interior\n    interior = interior[1:-1]\n    # Build knot vector\n    knots = np.concatenate([\n        np.zeros(p + 1),\n        interior,\n        np.ones(p + 1)\n    ])\n    return knots\n\ndef bspline_basis_matrix(knots: np.ndarray, p: int, x: np.ndarray) - np.ndarray:\n    \"\"\"\n    Evaluate all normalized B-spline basis functions of degree p defined by 'knots'\n    at points x using Cox-de Boor recursion. Returns shape (n_basis, len(x)).\n    \"\"\"\n    K = len(knots)\n    n_basis = K - p - 1\n    N = np.zeros((n_basis, x.size), dtype=np.float64)\n\n    # Base case p=0: indicator of half-open intervals [t_i, t_{i+1})\n    # Gauss-Legendre points lie inside elements, so endpoint handling is minimal.\n    for i in range(n_basis):\n        left = knots[i]\n        right = knots[i + 1]\n        # Indicator: include left, exclude right\n        mask = (x = left)  (x  right)\n        N[i, mask] = 1.0\n    # Handle the very end point x == 1 (if present) to ensure partition of unity\n    # Assign to the last basis.\n    if np.any(np.isclose(x, knots[-1])):\n        N[-1, np.isclose(x, knots[-1])] = 1.0\n\n    # Recursion for p=1\n    for d in range(1, p + 1):\n        N_next = np.zeros_like(N)\n        for i in range(n_basis):\n            # First term\n            denom1 = knots[i + d] - knots[i]\n            if denom1  0.0:\n                coeff1 = (x - knots[i]) / denom1\n                N_next[i, :] += coeff1 * N[i, :]\n            # Second term (uses N_{i+1, d-1})\n            if i + 1  n_basis:\n                denom2 = knots[i + d + 1] - knots[i + 1]\n                if denom2  0.0:\n                    coeff2 = (knots[i + d + 1] - x) / denom2\n                    N_next[i, :] += coeff2 * N[i + 1, :]\n        N = N_next\n\n    return N\n\ndef element_quadrature_points_weights(M: int, q: int) - tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Build global quadrature points and weights by mapping q-point Gauss-Legendre\n    rule to each of the M uniform elements on [0,1].\n    \"\"\"\n    # Gauss-Legendre on [-1,1]\n    xi, w = np.polynomial.legendre.leggauss(q)\n    points = []\n    weights = []\n    h = 1.0 / M\n    for e in range(M):\n        a = e * h\n        b = (e + 1) * h\n        # Affine map: x = 0.5*(b-a)*xi + 0.5*(b+a)\n        x_e = 0.5 * (b - a) * xi + 0.5 * (b + a)\n        w_e = 0.5 * (b - a) * w\n        points.append(x_e)\n        weights.append(w_e)\n    x_all = np.concatenate(points)\n    w_all = np.concatenate(weights)\n    return x_all, w_all\n\ndef l2_projection_error(p: int, M: int, q: int = 50) - float:\n    \"\"\"\n    Compute L2 projection of f(x)=sin(10x) onto spline space of degree p with M elements,\n    and return the L2 error norm via high-order Gaussian quadrature.\n    \"\"\"\n    # Build knots and basis dimension\n    knots = open_uniform_knots(M, p)\n    # Global quadrature\n    xq, wq = element_quadrature_points_weights(M, q)\n    # Evaluate basis matrix\n    B = bspline_basis_matrix(knots, p, xq)  # shape (n_basis, Nq)\n    # Assemble mass matrix M = B * diag(wq) * B^T\n    BW = B * wq[np.newaxis, :]\n    Mmat = BW @ B.T\n    # Assemble RHS b = B * (wq * f(xq))\n    fx = np.sin(10.0 * xq)  # radians\n    b = B @ (wq * fx)\n    # Solve for coefficients\n    c = np.linalg.solve(Mmat, b)\n    # Approximation values at quadrature points\n    sx = B.T @ c\n    # L2 error\n    err = np.sqrt(np.sum(wq * (fx - sx) ** 2))\n    return float(err)\n\ndef convergence_rate(p: int, Ms: list[int], q: int = 50) - float:\n    \"\"\"\n    Compute observed convergence rate via least-squares fit of log(error) vs log(h).\n    \"\"\"\n    hs = np.array([1.0 / M for M in Ms], dtype=np.float64)\n    errs = np.array([l2_projection_error(p, M, q=q) for M in Ms], dtype=np.float64)\n    X = np.log(hs)\n    Y = np.log(errs)\n    # Least squares slope\n    slope = np.polyfit(X, Y, 1)[0]\n    return float(slope)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_degrees = [0, 1, 2, 3]\n    Ms = [8, 16, 32, 64]\n    q = 50  # quadrature points per element\n\n    results = []\n    for p in test_degrees:\n        rate = convergence_rate(p, Ms, q=q)\n        results.append(f\"{rate:.3f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}