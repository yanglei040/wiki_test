{
    "hands_on_practices": [
        {
            "introduction": "参数曲线不仅仅是静态的几何形状，它还可以描述物体的运动轨迹。这个练习将帮助你区分两个关键概念：路径相交和粒子碰撞。通过分析两个机器人随时间变化的参数方程，你将深入理解参数在描述动态系统中的核心作用。",
            "id": "2140263",
            "problem": "两个自主移动机器人'Pathfinder'和'Rover'被编程在一个宽阔、平坦的工厂地面上导航。它们的位置由一个笛卡尔坐标系描述，单位为米。\n\nPathfinder的路径 $C_1$ 由其在内部时间 $t \\ge 0$（单位为秒）时的位置 $(x_1, y_1)$ 的参数方程描述：\n$$x_1(t) = 2t+1$$\n$$y_1(t) = t^2 - 2$$\n\nRover的路径 $C_2$ 由其在内部时间 $s \\ge 0$（单位为秒）时的位置 $(x_2, y_2)$ 的参数方程描述：\n$$x_2(s) = s-1$$\n$$y_2(s) = s+1$$\n\n对机器人的运动进行两种不同情景的分析：路径相交（它们的几何路径是否交叉？）和碰撞（它们是否在同一时间处于同一位置？）。如果存在时间参数 $t$ 和 $s$（不必相等）使得位置相同，则发生路径相交。仅当假设它们的时钟是同步的（$t=s$），并且对于*相同*的时间参数值，它们的位置相同时，才会发生碰撞。\n\n根据您对机器人路径的分析，下列哪个陈述是正确的？\n\nA. 路径不相交。\n\nB. 路径在点 $(3+2\\sqrt{6}, 5+2\\sqrt{6})$ 处相交，如果它们的时钟同步，机器人将在此点碰撞。\n\nC. 路径在点 $(3+2\\sqrt{6}, 5+2\\sqrt{6})$ 处相交，但即使它们的时钟同步，机器人也不会碰撞。\n\nD. 路径在点 $(3+2\\sqrt{6}, 5+2\\sqrt{6})$ 之外的某点相交，如果它们的时钟同步，机器人将在此另外的点碰撞。\n\nE. 路径在点 $(3+2\\sqrt{6}, 5+2\\sqrt{6})$ 之外的某点相交，但即使它们的时钟同步，机器人也不会在此另外的点碰撞。",
            "solution": "给定了平面上的两条参数化定义的路径。Pathfinder 沿着路径 $C_{1}$ 运动，其位置为 $(x_{1}(t), y_{1}(t))$，其中当 $t \\ge 0$ 时，$x_{1}(t) = 2t + 1$ 且 $y_{1}(t) = t^{2} - 2$。Rover 沿着路径 $C_{2}$ 运动，其位置为 $(x_{2}(s), y_{2}(s))$，其中当 $s \\ge 0$ 时，$x_{2}(s) = s - 1$ 且 $y_{2}(s) = s + 1$。\n\n为确定几何路径是否相交，我们必须找到 $t \\ge 0$ 和 $s \\ge 0$ 使得\n$$\nx_{1}(t) = x_{2}(s), \\quad y_{1}(t) = y_{2}(s).\n$$\n令 $x$ 坐标相等，得到\n$$\n2t + 1 = s - 1 \\quad \\Rightarrow \\quad s = 2t + 2.\n$$\n令 $y$ 坐标相等，得到\n$$\nt^{2} - 2 = s + 1 \\quad \\Rightarrow \\quad s = t^{2} - 3.\n$$\n令这两个关于 $s$ 的表达式相等，得出\n$$\n2t + 2 = t^{2} - 3 \\quad \\Rightarrow \\quad t^{2} - 2t - 5 = 0.\n$$\n解这个二次方程，\n$$\nt = \\frac{2 \\pm \\sqrt{4 + 20}}{2} = \\frac{2 \\pm \\sqrt{24}}{2} = 1 \\pm \\sqrt{6}.\n$$\n由于 $t \\ge 0$，我们接受 $t = 1 + \\sqrt{6}$ 并舍弃 $t = 1 - \\sqrt{6}  0$。那么\n$$\ns = 2t + 2 = 2(1 + \\sqrt{6}) + 2 = 4 + 2\\sqrt{6} \\ge 0.\n$$\n交点可以从任一路径计算；使用 $C_{1}$，\n$$\nx = 2t + 1 = 2(1 + \\sqrt{6}) + 1 = 3 + 2\\sqrt{6}, \\quad y = t^{2} - 2 = (1 + \\sqrt{6})^{2} - 2 = 5 + 2\\sqrt{6}.\n$$\n因此，路径在点 $(3 + 2\\sqrt{6}, 5 + 2\\sqrt{6})$ 处相交。\n\n为了确定在时钟同步的情况下它们是否会碰撞，我们要求时间参数相同，即 $t=s$，并且位置相同：\n$$\n2t + 1 = t - 1, \\quad t^{2} - 2 = t + 1.\n$$\n从第一个方程，\n$$\n2t + 1 = t - 1 \\quad \\Rightarrow \\quad t = -2,\n$$\n这违反了 $t \\ge 0$。因此，没有非负的 $t$ 能同时满足两个坐标等式，所以在时钟同步的情况下不会发生碰撞。\n\n因此，正确的陈述是路径在点 $(3 + 2\\sqrt{6}, 5 + 2\\sqrt{6})$ 处相交，但即使时钟同步，机器人也不会碰撞。",
            "answer": "$$\\boxed{C}$$"
        },
        {
            "introduction": "计算参数曲线的弧长是微分几何中的一个基本问题，在工程和物理学中有着广泛应用。这个练习要求你首先推导出一个特定参数曲线的弧长积分，然后使用复合梯形法则进行数值估算。这让你有机会将解析方法与数值计算技术结合起来，解决实际问题。",
            "id": "3215506",
            "problem": "考虑由 $x(t) = \\cos(t^{3})$ 和 $y(t) = \\sin(t^{3})$ 定义的参数曲线，其中 $t \\in [0,1]$。参数曲线 $(x(t), y(t))$ 在区间 $[a,b]$ 上的弧长由速度的积分给出，即 $\\int_{a}^{b} \\sqrt{(x'(t))^{2} + (y'(t))^{2}} \\, dt$。\n\n从黎曼积分的定义和在均匀剖分上用分段线性插值逼近光滑函数的思想出发，推导在 $[0,1]$ 区间上使用 $N$ 个等长子区间计算给定曲线弧长的复化梯形法则近似公式。然后，应用你推导出的近似公式，使用 $N = 12$ 个子区间，计算该曲线在 $[0,1]$ 上的弧长的数值估计。\n\n将最终数值答案表示为单个实数，并四舍五入到六位有效数字。不需要单位。",
            "solution": "第一步是确定弧长积分的被积函数。参数曲线由 $x(t) = \\cos(t^{3})$ 和 $y(t) = \\sin(t^{3})$ 给出，其中 $t$ 在区间 $[0,1]$ 内。弧长 $L$ 由公式 $L = \\int_{a}^{b} \\sqrt{(x'(t))^{2} + (y'(t))^{2}} \\, dt$ 给出。\n\n我们使用链式法则计算 $x(t)$ 和 $y(t)$ 对 $t$ 的导数：\n$x'(t) = \\frac{d}{dt} (\\cos(t^{3})) = -\\sin(t^{3}) \\cdot (3t^{2}) = -3t^{2}\\sin(t^{3})$\n$y'(t) = \\frac{d}{dt} (\\sin(t^{3})) = \\cos(t^{3}) \\cdot (3t^{2}) = 3t^{2}\\cos(t^{3})$\n\n接下来，我们计算这些导数的平方和：\n$(x'(t))^{2} + (y'(t))^{2} = (-3t^{2}\\sin(t^{3}))^{2} + (3t^{2}\\cos(t^{3}))^{2}$\n$= 9t^{4}\\sin^{2}(t^{3}) + 9t^{4}\\cos^{2}(t^{3})$\n$= 9t^{4}(\\sin^{2}(t^{3}) + \\cos^{2}(t^{3}))$\n\n使用毕达哥拉斯恒等式 $\\sin^{2}(\\theta) + \\cos^{2}(\\theta) = 1$，表达式简化为：\n$(x'(t))^{2} + (y'(t))^{2} = 9t^{4}$\n\n速度是该表达式的平方根。由于 $t$ 的区间是 $[0,1]$，$t$ 是非负的，因此我们有：\n$\\sqrt{(x'(t))^{2} + (y'(t))^{2}} = \\sqrt{9t^{4}} = 3t^{2}$\n\n因此，弧长积分为：\n$L = \\int_{0}^{1} 3t^{2} \\, dt$\n令 $f(t) = 3t^2$。我们需要求此积分的数值近似。值得注意的是，该积分可以精确求解：$L = [t^{3}]_{0}^{1} = 1^{3} - 0^{3} = 1$。然而，题目明确要求使用复化梯形法则。\n\n题目要求从分段线性插值的概念出发推导复化梯形法则。我们希望近似积分 $I = \\int_{a}^{b} f(t) \\, dt$。我们将区间 $[a,b]$ 剖分为 $N$ 个等长的子区间，每个子区间的宽度为 $h = \\frac{b-a}{N}$。剖分点为 $t_k = a + kh$，其中 $k = 0, 1, \\dots, N$。\n该积分可以表示为在这些子区间上的和：\n$I = \\sum_{k=1}^{N} \\int_{t_{k-1}}^{t_k} f(t) \\, dt$\n在每个子区间 $[t_{k-1}, t_k]$ 上，函数 $f(t)$ 被连接点 $(t_{k-1}, f(t_{k-1}))$ 和 $(t_k, f(t_k))$ 的直线所近似。这条线性函数的积分是一个梯形的面积：\n$\\int_{t_{k-1}}^{t_k} f(t) \\, dt \\approx \\frac{1}{2} (t_k - t_{k-1}) (f(t_{k-1}) + f(t_k)) = \\frac{h}{2} (f(t_{k-1}) + f(t_k))$\n将所有 $N$ 个子区间的这些近似值相加，得到复化梯形法则，记为 $L_N$：\n$L_N = \\sum_{k=1}^{N} \\frac{h}{2} (f(t_{k-1}) + f(t_k))$\n$= \\frac{h}{2} [(f(t_0)+f(t_1)) + (f(t_1)+f(t_2)) + \\dots + (f(t_{N-1})+f(t_N))]$\n$L_N = \\frac{h}{2} \\left[ f(t_0) + 2\\sum_{k=1}^{N-1} f(t_k) + f(t_N) \\right]$\n\n现在，我们为给定的弧长计算推导具体的近似公式。这里，$f(t) = 3t^{2}$，$a=0$，$b=1$。因此，$h = \\frac{1-0}{N} = \\frac{1}{N}$，剖分点为 $t_k = \\frac{k}{N}$，其中 $k=0, 1, \\dots, N$。\n在剖分点处的函数值为 $f(t_k) = f(\\frac{k}{N}) = 3(\\frac{k}{N})^{2} = \\frac{3k^{2}}{N^{2}}$。\n将这些值代入 $L_N$ 的通用公式中：\n$L_N = \\frac{1}{2N} \\left[ f(t_0) + 2\\sum_{k=1}^{N-1} f(t_k) + f(t_N) \\right]$\n$L_N = \\frac{1}{2N} \\left[ f(0) + 2\\sum_{k=1}^{N-1} \\frac{3k^{2}}{N^{2}} + f(1) \\right]$\n因为 $f(0) = 3(0)^{2} = 0$ 且 $f(1) = 3(1)^{2} = 3$：\n$L_N = \\frac{1}{2N} \\left[ 0 + 2 \\cdot \\frac{3}{N^{2}} \\sum_{k=1}^{N-1} k^{2} + 3 \\right] = \\frac{1}{2N} \\left[ \\frac{6}{N^{2}} \\sum_{k=1}^{N-1} k^{2} + 3 \\right]$\n这就是推导出的弧长近似公式。为简化计算，我们使用前 $N-1$ 个平方数的求和公式：$\\sum_{k=1}^{N-1} k^{2} = \\frac{(N-1)N(2N-1)}{6}$。\n将此公式代入 $L_N$ 的表达式中：\n$L_N = \\frac{1}{2N} \\left[ \\frac{6}{N^{2}} \\frac{(N-1)N(2N-1)}{6} + 3 \\right]$\n$L_N = \\frac{1}{2N} \\left[ \\frac{(N-1)(2N-1)}{N} + 3 \\right]$\n$L_N = \\frac{1}{2N} \\left[ \\frac{2N^{2}-3N+1}{N} + \\frac{3N}{N} \\right]$\n$L_N = \\frac{1}{2N} \\left[ \\frac{2N^{2}+1}{N} \\right] = \\frac{2N^{2}+1}{2N^{2}} = 1 + \\frac{1}{2N^{2}}$\n\n题目要求应用此近似公式，其中子区间数量 $N=12$。使用 $L_N$ 的简化公式：\n$L_{12} = 1 + \\frac{1}{2(12)^{2}} = 1 + \\frac{1}{2(144)} = 1 + \\frac{1}{288}$\n$L_{12} = \\frac{288}{288} + \\frac{1}{288} = \\frac{289}{288}$\n\n最后，我们计算数值并四舍五入到六位有效数字：\n$L_{12} = \\frac{289}{288} \\approx 1.00347222...$\n四舍五入到六位有效数字，我们得到 $1.00347$。",
            "answer": "$$\n\\boxed{1.00347}\n$$"
        },
        {
            "introduction": "在计算机图形学和数据可视化中，我们常常需要简化复杂的曲线，同时保持其基本形状。这个动手编程练习将指导你从基本原理出发，实现一个著名的曲线简化算法——Ramer-Douglas-Peucker算法。通过为给定的曲线在指定的误差容限内找到一个点数更少的近似表示，你将掌握处理和优化几何数据的核心计算思维。",
            "id": "3261322",
            "problem": "给定一个由连续映射 $C:[a,b]\\to\\mathbb{R}^2$ 指定的参数化平面曲线，其中 $C(t)=(x(t),y(t))$。您将在此曲线上均匀采样 $N$ 个点，形成一个有序点序列 $P_0,P_1,\\dots,P_{N-1}$，其中 $P_i=C(t_i)$，$t_i=a+i\\Delta t$ 且 $\\Delta t=(b-a)/(N-1)$。目标是算法性地将此采样折线简化为一个子序列 $Q_0,Q_1,\\dots,Q_{M-1}$，其中每个 $Q_j$ 都是原始的 $P_i$ 之一，且 $Q_0=P_0$ 和 $Q_{M-1}=P_{N-1}$，使得简化的折线在以下约束条件下保持在规定的容差 $\\,\\epsilon\\,$ 之内。\n\n从 $\\mathbb{R}^2$ 中欧几里得距离的基本定义开始，即对于点 $A=(a_x,a_y)$ 和 $B=(b_x,b_y)$，距离为 $\\|A-B\\|_2=\\sqrt{(a_x-b_x)^2+(a_y-b_y)^2}$。将点 $R$ 到端点为 $A$ 和 $B$ 的闭合线段的距离定义为 $R$ 到该线段上任意点的最小欧几里得距离。仅使用这些定义，构建一个方法来选择满足以下可接受性条件的采样点子序列：对于简化后折线中的任意线段（由连续的两个保留点 $Q_j=P_{i_j}$ 和 $Q_{j+1}=P_{i_{j+1}}$ 构成），所有被省略的原始点 $P_k$ （其中 $i_j  k  i_{j+1}$）到该线段的距离都必须小于或等于 $\\epsilon$。请将您的方法应用于下面提供的三个测试案例，并以指定格式输出保留点的索引。",
            "solution": "该问题要求实现一个算法来简化由点序列表示的折线，该算法通常称为 Ramer-Douglas-Peucker (RDP) 算法。算法的实现基于两个核心部分：(1) 计算一个点到一条线段的距离；(2) 一个递归精化的过程，用于决定保留或舍弃哪些点。\n\n### 1. 点到线段的距离\n\n问题要求计算从点 $R$ 到端点为 $A$ 和 $B$ 的闭合线段的最小欧几里得距离。设这些点由从原点出发的向量表示，记作 $\\vec{r}$、$\\vec{a}$ 和 $\\vec{b}$。\n\n通过 $A$ 和 $B$ 的无限直线上的一点可以参数化为 $L(u) = \\vec{a} + u(\\vec{b} - \\vec{a})$，其中标量参数 $u \\in \\mathbb{R}$。这条线上离 $R$ 最近的点是 $R$ 在该线上的正交投影。这发生在从投影点到 $R$ 的向量与线的方向向量 $\\vec{v} = \\vec{b} - \\vec{a}$ 正交时。\n\n$$(\\vec{r} - L(u)) \\cdot (\\vec{b} - \\vec{a}) = 0$$\n$$(\\vec{r} - (\\vec{a} + u(\\vec{b} - \\vec{a}))) \\cdot (\\vec{b} - \\vec{a}) = 0$$\n$$(\\vec{r} - \\vec{a}) \\cdot (\\vec{b} - \\vec{a}) - u(\\vec{b} - \\vec{a}) \\cdot (\\vec{b} - \\vec{a}) = 0$$\n\n求解 $u$ 可得：\n$$u = \\frac{(\\vec{r} - \\vec{a}) \\cdot (\\vec{b} - \\vec{a})}{\\|\\vec{b} - \\vec{a}\\|^2}$$\n\n这个参数 $u$ 决定了无限直线上最近点的位置。对于闭合线段，参数必须限制在 $u \\in [0, 1]$。这导致三种情况：\n\n1.  如果 $u \\in [0, 1]$，投影点落在该线段上。最近点是 $P_{proj} = \\vec{a} + u(\\vec{b} - \\vec{a})$，距离为 $\\|\\vec{r} - P_{proj}\\|$。\n2.  如果 $u  0$，线段上最近的点是端点 $A$。距离为 $\\|\\vec{r} - \\vec{a}\\|$。\n3.  如果 $u  1$，线段上最近的点是端点 $B$。距离为 $\\|\\vec{r} - \\vec{b}\\|$。\n\n如果 $A$ 和 $B$ 重合，即 $\\|\\vec{b} - \\vec{a}\\|^2 = 0$，则会出现一个特殊情况。在这种情况下，线段是一个单点，距离就是 $\\|\\vec{r} - \\vec{a}\\|$。\n\n### 2. 递归偏差精化算法\n\n问题要求一种具有‘递归偏差精化’精神的方法，这是对 Ramer-Douglas-Peucker 算法的描述性名称。给定一个点序列 $P_0, \\dots, P_{N-1}$，目标是找到一个以 $P_0$ 开始并以 $P_{N-1}$ 结束的简化子序列。\n\n该算法对折线的一个片段进行操作，该片段由起始索引 $i_{start}$ 和结束索引 $i_{end}$ 定义。最初，这是从索引 $0$ 到 $N-1$ 的完整折线。\n\n1.  考虑连接端点 $P_{i_{start}}$ 和 $P_{i_{end}}$ 的线段。\n2.  对于每个中间点 $P_k$（其中 $i_{start}  k  i_{end}$），使用上面推导的方法计算其到线段 $(P_{i_{start}}, P_{i_{end}})$ 的垂直距离。\n3.  找到距离线段最远的点 $P_{i_{max}}$，其最大距离为 $d_{max}$。\n4.  将 $d_{max}$ 与指定的容差 $\\epsilon$ 进行比较：\n    a. 如果 $d_{max} \\le \\epsilon$，则所有中间点都被认为与线段足够接近。这部分折线的简化结果就是两个端点 $P_{i_{start}}$ 和 $P_{i_{end}}$。\n    b. 如果 $d_{max}  \\epsilon$，则点 $P_{i_{max}}$ 是一个重要特征，必须保留。然后，将简化过程递归地应用于两个子折线：一个从 $P_{i_{start}}$ 到 $P_{i_{max}}$，另一个从 $P_{i_{max}}$ 到 $P_{i_{end}}$。\n\n所有保留点的集合（初始端点加上所有被发现超出容差的点，如 $P_{i_{max}}$）构成了最终简化的折线。该过程保证会终止，因为每个递归步骤都对一个严格更小的子问题进行操作，且点的数量是有限的。\n\n在实现上，基于栈的迭代方法在功能上等同于递归，并能避免潜在的深度递归限制。\n\n### 算法实现\n\n对于每个测试案例，整个程序将按以下步骤进行：\n1.  **采样**：通过在 $[a, b]$ 中创建 $t_i$ 值的均匀网格并计算 $(x(t_i), y(t_i))$ 来生成曲线 $C(t)$ 的 $N$ 个点。\n2.  **简化**：\n    a. 初始化一个要保留的索引集合 `kept_indices`，初始值为 $\\{0, N-1\\}$。\n    b. 将初始索引对 `(0, N-1)` 推入栈中。\n    c. 当栈不为空时：\n        i. 弹出一个索引对 `(start, end)`。\n        ii. 在 `start` 和 `end` 之间找到距离从 `points[start]` 到 `points[end]` 的线段最远的点，记录其索引 `max_dist_idx` 和距离值 `d_max`。\n        iii. 如果存在最远点（即 `start + 1  end`）并且 `d_max  epsilon`，则将 `max_dist_idx` 添加到 `kept_indices` 中，并将新的索引对 `(start, max_dist_idx)` 和 `(max_dist_idx, end)` 推入栈中。\n3.  **输出**：将最终的 `kept_indices` 集合转换为一个排序列表，并按要求格式化。\n\n这种结构化方法从第一性原理出发，正确地实现了指定的要求。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef point_segment_distance(point, start, end):\n    \"\"\"\n    Calculate the Euclidean distance from a point to a line segment.\n\n    Args:\n        point (np.ndarray): The point, shape (2,).\n        start (np.ndarray): The start point of the segment, shape (2,).\n        end (np.ndarray): The end point of the segment, shape (2,).\n\n    Returns:\n        float: The distance from the point to the segment.\n    \"\"\"\n    # Handle the case where the segment is a single point\n    if np.array_equal(start, end):\n        return np.linalg.norm(point - start)\n\n    line_vec = end - start\n    pnt_vec = point - start\n    \n    line_len_sq = np.dot(line_vec, line_vec)\n    \n    # Project point onto the line containing the segment.\n    # The parameter t is the projection factor.\n    t = np.dot(pnt_vec, line_vec) / line_len_sq\n    \n    if t  0.0:\n        # Projection is outside the segment, closer to the start point.\n        return np.linalg.norm(point - start)\n    elif t > 1.0:\n        # Projection is outside the segment, closer to the end point.\n        return np.linalg.norm(point - end)\n    else:\n        # Projection is on the segment.\n        projection = start + t * line_vec\n        return np.linalg.norm(point - projection)\n\ndef simplify_polyline(points, epsilon):\n    \"\"\"\n    Simplify a polyline using the Ramer-Douglas-Peucker algorithm.\n\n    Args:\n        points (np.ndarray): An array of points, shape (N, 2).\n        epsilon (float): The tolerance for simplification.\n\n    Returns:\n        list: A sorted list of indices of the points to keep.\n    \"\"\"\n    n_points = len(points)\n    if n_points  2:\n        return list(range(n_points))\n\n    # Use a stack for an iterative implementation of the algorithm\n    stack = [(0, n_points - 1)]\n    kept_indices = {0, n_points - 1}\n\n    while stack:\n        start_idx, end_idx = stack.pop()\n\n        # Find the point with the maximum distance\n        d_max = 0.0\n        max_dist_idx = -1\n\n        for i in range(start_idx + 1, end_idx):\n            d = point_segment_distance(points[i], points[start_idx], points[end_idx])\n            if d > d_max:\n                d_max = d\n                max_dist_idx = i\n\n        # If max distance is greater than epsilon, recursively simplify\n        if max_dist_idx != -1 and d_max > epsilon:\n            kept_indices.add(max_dist_idx)\n            # Push the two new sub-segments onto the stack\n            if max_dist_idx - start_idx > 1:\n                stack.append((start_idx, max_dist_idx))\n            if end_idx - max_dist_idx > 1:\n                stack.append((max_dist_idx, end_idx))\n                \n    return sorted(list(kept_indices))\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"x_func\": lambda t: np.cos(t),\n            \"y_func\": lambda t: np.sin(t),\n            \"t_range\": (0, np.pi / 2),\n            \"N\": 101,\n            \"epsilon\": 0.01\n        },\n        {\n            \"x_func\": lambda t: np.piecewise(t, [t = 0.5, t > 0.5], [lambda v: v, 0.5]),\n            \"y_func\": lambda t: np.piecewise(t, [t = 0.5, t > 0.5], [0, lambda v: 2 * (v - 0.5)]),\n            \"t_range\": (0, 1),\n            \"N\": 51,\n            \"epsilon\": 1e-12\n        },\n        {\n            \"x_func\": lambda t: t,\n            \"y_func\": lambda t: np.sin(3 * t),\n            \"t_range\": (0, 2 * np.pi),\n            \"N\": 401,\n            \"epsilon\": 100\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        t_start, t_end = case[\"t_range\"]\n        N = case[\"N\"]\n        epsilon = case[\"epsilon\"]\n        \n        # 1. Sample the curve\n        t_values = np.linspace(t_start, t_end, N)\n        x_values = case[\"x_func\"](t_values)\n        y_values = case[\"y_func\"](t_values)\n        points = np.vstack((x_values, y_values)).T\n\n        # 2. Compute the simplified subsequence\n        retained_indices = simplify_polyline(points, epsilon)\n        all_results.append(retained_indices)\n\n    # 3. Format the final output string\n    inner_results_str = [f\"[{','.join(map(str, res))}]\" for res in all_results]\n    final_output = f\"[{','.join(inner_results_str)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        }
    ]
}