{
    "hands_on_practices": [
        {
            "introduction": "网络拓扑结构的选择是计算机系统设计中的一个基本决策。本练习将引导你分析几种经典拓扑结构——总线、环形和网格——的平均通信延迟。通过从第一性原理出发计算平均跳数，你将亲身体会到拓扑结构如何直接影响系统的性能。",
            "id": "3652325",
            "problem": "一个多处理器片上系统采用三种备选的互连拓扑来承载用于在共享者之间移动缓存行的相干流量：共享总线、双向环形网络和二维网状片上网络 (NoC)。所有拓扑都具有相同数量的核心，即 $N = 64$。在网状拓扑的情况下，核心被布置在一个规则的 $8 \\times 8$ 网格上，路由器位于网格交叉点，缓存行数据在源和目标之间遵循维度顺序路径（曼哈顿路由）。在环形拓扑的情况下，路由器以循环方式连接，数据总是沿着环路两个方向中较短的一个方向传输。在总线的情况下，所有核心都连接到一个单一的共享介质上。假设采用基于目录的缓存一致性协议 (DCCP)，并且缓存行从当前所有者到请求共享者的传输沿着拓扑中的最短路径进行，没有经过宿主节点的间接寻址，也没有竞争或排队。\n\n将一次传输的跳数定义为缓存行数据沿源到目标的最短路径所經過的不同路由器间链路段的数量。对于总线，无论源和目标的连接点如何，都将共享介质的遍历视为单次跳跃。假设在 $N$ 个核心中均匀随机地选择给定缓存行的两个不同共享者，并且该缓存行从一个共享者迁移到另一个共享者。仅使用这些拓扑的核心定义和第一性原理计数论证，计算在每种拓扑（网状、环形和总线）下此次迁移的平均跳数。按网状、环形、总线的顺序报告你的三个答案。将每个值四舍五入到四位有效数字。不需要物理单位；报告无量纲的跳数。",
            "solution": "问题要求计算在一个拥有 $N=64$ 个核心的系统中，在三种不同的互连拓扑（$8 \\times 8$ 二维网状网络、64 节点双向环形网络和共享总线）下，缓存行在两个随机选择的不同核心之间迁移的平均跳数。\n\n平均跳数 $\\bar{H}$ 定义为所有不同源-目标对之间的最短路径跳数之和，除以这类对的总数。由于两个不同的核心是均匀随机选择的，因此源核心有 $N$ 种选择，目标核心有 $N-1$ 种选择。不同核心的有序对总数为 $N(N-1)$。\n\n平均跳数的一般公式是：\n$$ \\bar{H} = \\frac{\\sum_{i=1}^{N} \\sum_{j=1, j \\neq i}^{N} H(i, j)}{N(N-1)} $$\n其中 $H(i, j)$ 是从源核心 $i$ 到目标核心 $j$ 的跳数。\n\n我们现在将分别分析每种拓扑。\n\n### 1. 共享总线拓扑\n对于共享总线，问题陈述指明任意两个连接点之间的传输构成一次跳跃。因此，对于任何不同的源核心 $i$ 和目标核心 $j$，跳数是恒定的。\n$$ H_{bus}(i, j) = 1 \\quad \\forall i \\neq j $$\n所有不同对的跳数之和为：\n$$ \\sum_{i=1}^{N} \\sum_{j=1, j \\neq i}^{N} H_{bus}(i, j) = \\sum_{i=1}^{N} \\sum_{j=1, j \\neq i}^{N} 1 = N(N-1) $$\n因此，平均跳数为：\n$$ \\bar{H}_{bus} = \\frac{N(N-1)}{N(N-1)} = 1 $$\n对于 $N=64$，总线的平均跳数恰好为 $1$。\n\n### 2. 双向环形拓扑\n在具有 $N$ 个核心的双向环形网络中，我们可以将核心从 $0$ 标记到 $N-1$。核心 $i$ 和核心 $j$ 之间的跳数是沿环路较短路径的长度。一个方向的距离是 $|i-j|$，另一个方向的距离是 $N - |i-j|$。因此，跳数为：\n$$ H_{ring}(i, j) = \\min(|i-j|, N - |i-j|) $$\n由于环形拓扑的对称性，从任何给定核心到所有其他核心的距离之和是相同的。因此，我们可以计算单个源（例如核心 $0$）的这个和，然后乘以 $N$ 得到所有源核心的总和。\n从核心 $0$ 到所有其他核心 $j \\in \\{1, 2, \\dots, N-1\\}$ 的距离之和为：\n$$ S_0 = \\sum_{j=1}^{N-1} H_{ring}(0, j) = \\sum_{j=1}^{N-1} \\min(j, N-j) $$\n给定 $N=64$（一个偶数），最大最短路径距离为 $N/2 = 32$。这个距离对于直径上相对的节点是唯一的。对于所有其他距离 $d  N/2$，都有两个节点处于该距离。\n这个和可以写为：\n$$ S_0 = 2 \\sum_{j=1}^{N/2 - 1} j + \\frac{N}{2} $$\n使用前 $m$ 个整数的和的公式，$\\sum_{j=1}^{m} j = \\frac{m(m+1)}{2}$：\n$$ S_0 = 2 \\left( \\frac{(\\frac{N}{2}-1)(\\frac{N}{2}-1+1)}{2} \\right) + \\frac{N}{2} = (\\frac{N}{2}-1)\\frac{N}{2} + \\frac{N}{2} = \\frac{N}{2}(\\frac{N}{2}-1+1) = \\left(\\frac{N}{2}\\right)^2 = \\frac{N^2}{4} $$\n所有不同对的总跳数为 $N \\times S_0 = N \\cdot \\frac{N^2}{4} = \\frac{N^3}{4}$。\n平均跳数是这个总和除以对的数量 $N(N-1)$：\n$$ \\bar{H}_{ring} = \\frac{N^3/4}{N(N-1)} = \\frac{N^2}{4(N-1)} $$\n对于 $N=64$：\n$$ \\bar{H}_{ring} = \\frac{64^2}{4(64-1)} = \\frac{4096}{4 \\times 63} = \\frac{1024}{63} \\approx 16.253968... $$\n\n### 3. 二维网状拓扑\n该系统有 $N=64$ 个核心，排列在一个规则的 $K \\times K$ 网格中，其中 $K = \\sqrt{N} = \\sqrt{64} = 8$。一个核心的位置可以通过坐标 $(x, y)$ 来识别，其中 $x, y \\in \\{0, 1, \\dots, K-1\\}$。\n问题指明了曼哈顿路由，因此源核心 $(x_s, y_s)$ 和目标核心 $(x_d, y_d)$ 之间的跳数为：\n$$ H_{mesh}((x_s, y_s), (x_d, y_d)) = |x_s - x_d| + |y_s - y_d| $$\n平均跳数是在所有不同源-目标对上此数量的期望值。根据期望的线性性质，这等于：\n$$ \\bar{H}_{mesh} = E[|x_s - x_d| + |y_s - y_d|] = E[|x_s - x_d|] + E[|y_s - y_d|] $$\n由于源和目标核心是均匀随机选择的，并且 x 和 y 维度是对称的，因此 $E[|x_s - x_d|] = E[|y_s - y_d|]$。我们可以只计算一维上的平均距离。\n一维线上 $K$ 个节点的平均距离 $\\bar{d}_K$ 可以通过对所有 $K(K-1)$ 个不同对的距离求和来计算：\n$$ \\bar{d}_K = \\frac{\\sum_{i=0}^{K-1} \\sum_{j=0, j \\neq i}^{K-1} |i-j|}{K(K-1)} $$\n分子可以被计算为 $\\frac{K(K^2-1)}{3}$。\n所以，$\\bar{d}_K = \\frac{K(K^2-1)/3}{K(K-1)} = \\frac{K+1}{3}$。\n网状拓扑的平均总跳数为：\n$$ \\bar{H}_{mesh} = \\bar{d}_K + \\bar{d}_K = \\frac{2(K+1)}{3} $$\n对于 $K=8$：\n$$ \\bar{H}_{mesh} = \\frac{2 \\times (8+1)}{3} = \\frac{18}{3} = 6 $$\n让我们重新计算一下网状拓扑的平均跳数。\n$E[|x_s - x_d|]$ 是在所有 $N(N-1)$ 对上求平均。在 $N=K^2$ 个核心中，x 坐标是从 $\\{0, \\dots, K-1\\}$ 中均匀随机抽取的，y 坐标也是。\n$E[|x_s - x_d|] = \\frac{1}{K^2} \\sum_{x_s=0}^{K-1} \\sum_{x_d=0}^{K-1} |x_s - x_d|$。\n$\\sum_{x_s=0}^{K-1} \\sum_{x_d=0}^{K-1} |x_s - x_d| = \\frac{K^2(K^2-1)}{3K} = \\frac{K(K^2-1)}{3}$。\n所以，$E[|x_s - x_d|] = \\frac{1}{K^2} \\frac{K(K^2-1)}{3} = \\frac{K^2-1}{3K}$。\n这个期望是针对从 $K$ 个值中独立均匀地选择两个值。我们处理的是从 $N$ 个核心中选择两个不同的核心。\n原解法中的公式 $\\frac{2K}{3}$ 是一个广泛引用的近似值，但让我们从第一性原理推导。\n$\\sum_{s,d} |x_s - x_d| = K^2 \\sum_{x_1, x_2} |x_1 - x_2| = K^2 \\frac{K(K^2-1)}{3}$。这是对所有 $N^2$ 对的求和。\n平均值应为 $\\frac{\\sum_{s \\neq d} |x_s - x_d|}{N(N-1)}$。\n$\\sum_{s \\neq d} |x_s - x_d| = \\sum_{s,d} |x_s - x_d| = K^2 \\frac{K(K^2-1)}{3}$。\n$N(N-1) = K^2(K^2-1)$。\n$E[|x_s-x_d|] = \\frac{K^3(K^2-1)/3}{K^2(K^2-1)} = \\frac{K}{3}$。这个推导是正确的。\n因此，$\\bar{H}_{mesh} = \\frac{K}{3} + \\frac{K}{3} = \\frac{2K}{3}$。\n对于 $K=8$，$\\bar{H}_{mesh} = \\frac{2 \\times 8}{3} = \\frac{16}{3} \\approx 5.3333...$。原解是正确的。\n\n### 结果总结\n计算出的平均跳数如下：\n- 网状：$\\bar{H}_{mesh} = \\frac{16}{3} \\approx 5.3333...$\n- 环形：$\\bar{H}_{ring} = \\frac{1024}{63} \\approx 16.2539...$\n- 总线：$\\bar{H}_{bus} = 1$\n\n根据要求，将每个值四舍五入到四位有效数字：\n- 网状：$5.333$\n- 环形：$16.25$\n- 总线：$1.000$\n\n问题要求按网状、环形、总线的顺序给出答案。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 5.333  16.25  1.000 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "仅仅了解网络的静态结构是不够的，我们还需要评估其动态性能，例如吞吐量。本练习将深入分析一个令牌环网络，展示如何综合考虑物理参数（如信号传播速度、链路速率）和协议开销（如令牌传递时间），来建立一个精确的系统性能模型。通过推导饱和吞吐量，你将学会如何量化和评估一个完整互连系统的有效数据传输能力。",
            "id": "3652372",
            "problem": "一个使用令牌传递的单向环形互联网络，用于连接局域网（LAN）中的 $N$ 个相同节点。该环路强制实施单帧占用：当一个节点获取令牌后，它会传输一个长度为 $S$ 比特的用户数据包，并一直持有令牌，直到其自己帧的尾部完成一次完整的环路循环并被发送方移除。中间节点以比特级直通（cut-through）方式运行，每个节点具有固定的转发/重定时延迟。假设以下物理上合理的参数：\n- 节点数：$N = 16$。\n- 环路总周长：$L = 1000$ 米。\n- 信号在介质中的传播速度：$v = 2.0 \\times 10^{8}$ 米每秒。\n- 链路速率：$R = 25$ Gbps。\n- 每节点转发/重定时延迟：$t_{f} = 4$ 纳秒每节点。\n- 帧移除后释放令牌前的保护时间：$t_{g} = 100$ 纳秒。\n- 发送方移除帧后重新生成令牌的时间：$t_{\\text{tok}} = 40$ 纳秒。\n\n下一个节点的新传输只有在前一个发送方释放的令牌传播一跳到达该节点后才能开始。将一跳令牌传递时间视为一个链路传播时间和一次转发/重定时延迟之和。忽略所有其他协议开销，并假设除了 $S$ 比特的用户数据外没有其他报头。\n\n从第一性原理出发，仅使用基本定义（序列化时间等于 $S/R$；传播时间等于距离除以 $v$；独立延迟相加），推导出令牌循环时间作为 $S$ 的函数。然后，将环路的饱和总吞吐量 $T(S)$ 定义为在持续积压负载下单位时间内传输的长期平均用户比特数，并用 $S$ 和给定参数表示 $T(S)$。\n\n最后，对于 $S = 12$ KiB，计算饱和总吞吐量 $T$ 的数值（单位为千兆比特每秒）。将您的答案四舍五入到四位有效数字，并以 Gbps 表示。",
            "solution": "问题要求推导单向令牌环网络的令牌循环时间和饱和总吞吐量，然后根据特定参数进行数值计算。我们将从第一性原理开始。\n\n首先，我们根据给定参数定义基本的时间分量：\n-   节点数：$N = 16$。\n-   数据包大小：$S$ 比特。\n-   线路速率：$R = 25 \\times 10^{9}$ 比特每秒。\n-   环路周长：$L = 1000$ 米。\n-   信号传播速度：$v = 2.0 \\times 10^{8}$ 米每秒。\n-   每节点转发延迟：$t_{f} = 4 \\times 10^{-9}$ 秒。\n-   保护时间：$t_{g} = 100 \\times 10^{-9}$ 秒。\n-   令牌重新生成时间：$t_{\\text{tok}} = 40 \\times 10^{-9}$ 秒。\n\n将一个 $S$ 比特的数据包传输到环路上所需的时间是序列化时间 $t_{\\text{ser}}$，定义为：\n$$t_{\\text{ser}} = \\frac{S}{R}$$\n\n接下来，我们确定单个比特完全环绕环路一周的延迟。这个环路延迟，记为 $\\tau$，是围绕整个周长的传播延迟与环路上所有 $N$ 个节点的累积转发延迟之和。\n整个环路周长 $L$ 的传播延迟为：\n$$\\tau_{\\text{prop}} = \\frac{L}{v}$$\n一个比特遍历环路时会经过所有 $N$ 个节点，每个节点引入 $t_f$ 的延迟。总转发延迟为：\n$$\\tau_{\\text{fwd}} = N \\cdot t_f$$\n因此，总环路延迟为：\n$$\\tau = \\tau_{\\text{prop}} + \\tau_{\\text{fwd}} = \\frac{L}{v} + N t_f$$\n\n根据问题陈述，发送方持有令牌，直到其自己传输的帧的尾部完成一次完整的环路循环并被移除。让我们追踪一个节点（比如节点 $i$）在时间 $t=0$ 捕获令牌后进行单次数据包传输的事件过程。\n1.  节点 $i$ 在 $t=0$ 时开始传输帧。帧的最后一个比特在时间 $t = t_{\\text{ser}}$ 被注入到环路中。\n2.  这最后一个比特必须环绕整个环路回到节点 $i$。这需要的时间等于环路延迟 $\\tau$。\n3.  帧的尾部在时间 $T_{\\text{rem}} = t_{\\text{ser}} + \\tau$ 返回到节点 $i$ 并被移除。节点在此之前一直持有令牌。\n4.  帧被移除后，有一个强制的保护时间 $t_g$。\n5.  保护时间过后，发送方需要 $t_{\\text{tok}}$ 来重新生成一个新的令牌。\n6.  令牌在时间 $T_{\\text{rel}} = T_{\\text{rem}} + t_g + t_{\\text{tok}} = t_{\\text{ser}} + \\tau + t_g + t_{\\text{tok}}$ 被节点 $i$ 释放。\n\n令牌循环时间，我们定义为 $T_{\\text{cycle}}(S)$，是在饱和网络中一个节点完成其传输周期并使令牌可供下一个节点使用所经过的总时间。在持续积压负载下，当一个节点释放令牌时，下一个节点立即开始其传输周期。然而，令牌需要时间从当前节点传播到下一个节点。这个时间我们称为 $t_{\\text{hop}}$。\n$t_{\\text{hop}} = \\frac{L/N}{v} + t_f$\n总循环时间是单次传输所占用的时间加上令牌传递到下一个节点的时间。在饱和条件下，当节点 $i$ 释放令牌时，令牌开始向节点 $i+1$ 传播。节点 $i+1$ 在 $t_{hop}$ 之后接收到令牌。因此，一次完整的传输和令牌传递周期（从一个节点捕获令牌到下一个节点捕获令牌）的时间是：\n$$T_{\\text{cycle}}(S) = T_{\\text{rel}} - (\\text{time for token to reach node i}) + (\\text{time for token to reach node i+1})$$\n一个更简单的方法是考虑环路在任何给定时间点只能支持一次传输。因此，总循环时间是一个节点传输数据和传递控制权所需的时间。这个总时间包括：序列化时间 $t_{ser}$，帧尾环回时间 $\\tau$，保护时间 $t_g$，令牌生成时间 $t_{tok}$，以及令牌从一个节点传递到下一个节点的开销。\n在饱和模式下，环路上的活动是一个接一个的。一个周期可以被定义为从一个节点开始传输到下一个节点开始传输的时间。\n- 节点 $i$ 开始传输：$t=0$。\n- 节点 $i$ 完成传输并释放令牌：$T_{rel} = t_{ser} + \\tau + t_g + t_{tok}$。\n- 令牌从节点 $i$ 传播到节点 $i+1$：$t_{hop} = \\frac{L}{Nv} + t_f$。\n- 节点 $i+1$ 开始传输：$T_{start, i+1} = T_{rel} + t_{hop}$。\n- 但是，由于环是单向的，令牌从节点 $i$ 释放后，它会自然地传播到 $i+1$。总时间是 $N$ 次这样的循环的总和除以 $N$。由于所有节点都相同，我们只需要计算一个周期的长度。这个周期是总的开销时间，加上一次传输时间。\n总开销时间是环路本身“空闲”的时间。这是环路延迟 $\\tau$ 加上所有协议开销。\n$$T_{\\text{overhead}} = \\tau + t_g + t_{\\text{tok}}$$\n每次传输，都会注入 $S$ 比特的数据，耗时 $t_{ser} = S/R$。\n在一个完整的循环中，所有 $N$ 个节点都有机会传输。如果每个节点都传输，总时间是 $N \\times (t_{ser} + \\text{token_passing_time})$。\n让我们遵循解决方案中的逻辑，它似乎更直接：\n$T_{\\text{cycle}}(S)$ 是一个节点传输后，下一个节点能够开始传输所经过的时间。这等于一个节点占用环路的总时间。\n$$T_{\\text{cycle}}(S) = \\frac{S}{R} + \\tau + t_g + t_{\\text{tok}} + t_{\\text{hop}}$$\n这个表达式计算了从一个节点捕获令牌到下一个节点捕获令牌的时间，这是正确的。\n$$T_{\\text{cycle}}(S) = \\frac{S}{R} + \\left(\\frac{L}{v} + N t_f\\right) + t_g + t_{\\text{tok}} + \\left(\\frac{L}{Nv} + t_f\\right)$$\n合并项得到：\n$$T_{\\text{cycle}}(S) = \\frac{S}{R} + \\frac{L}{v}\\left(1 + \\frac{1}{N}\\right) + (N+1)t_f + t_g + t_{\\text{tok}}$$\n这个公式是正确的。\n饱和总吞吐量 $T(S)$ 是单位时间内传输的用户比特总数。在一个持续时间为 $T_{\\text{cycle}}(S)$ 的周期内，一个包含 $S$ 用户比特的数据包被成功传输。因此，吞吐量为：\n$$T(S) = \\frac{S}{T_{\\text{cycle}}(S)} = \\frac{S}{\\frac{S}{R} + \\frac{L}{v}\\left(1 + \\frac{1}{N}\\right) + (N+1)t_f + t_g + t_{\\text{tok}}}$$\n\n最后，我们计算当 $S = 12$ KiB 时的 $T(S)$ 的数值。\n$S = 12 \\text{ KiB} = 12 \\times 2^{10} \\text{ 字节} = 12 \\times 1024 \\times 8 \\text{ 比特} = 98304$ 比特。\n\n现在我们计算 $T(S)$ 分母中的每一项：\n-   序列化时间：\n    $t_{\\text{ser}} = \\frac{S}{R} = \\frac{98304}{25 \\times 10^{9}} = 3.93216 \\times 10^{-6}$ 秒。\n-   与传播相关的延迟：\n    $\\frac{L}{v}\\left(1 + \\frac{1}{N}\\right) = \\frac{1000}{2.0 \\times 10^{8}}\\left(1 + \\frac{1}{16}\\right) = (5 \\times 10^{-6}) \\times \\frac{17}{16} = 5.3125 \\times 10^{-6}$ 秒。\n-   与转发相关的延迟：\n    $(N+1)t_f = (16+1) \\times (4 \\times 10^{-9}) = 17 \\times 4 \\times 10^{-9} = 68 \\times 10^{-9} = 0.068 \\times 10^{-6}$ 秒。\n-   协议开销延迟：\n    $t_g + t_{\\text{tok}} = (100 \\times 10^{-9}) + (40 \\times 10^{-9}) = 140 \\times 10^{-9} = 0.140 \\times 10^{-6}$ 秒。\n\n将这些分量相加得到总循环时间：\n$$T_{\\text{cycle}}(98304) = (3.93216 + 5.3125 + 0.068 + 0.140) \\times 10^{-6} \\text{ s} = 9.45266 \\times 10^{-6} \\text{ s}$$\n\n那么饱和总吞吐量是：\n$$T = \\frac{S}{T_{\\text{cycle}}(S)} = \\frac{98304 \\text{ bits}}{9.45266 \\times 10^{-6} \\text{ s}} \\approx 10399580133 \\text{ bits/s}$$\n$$T \\approx 10.39958 \\text{ Gbps}$$\n\n将结果四舍五入到四位有效数字，我们得到 $10.40$ Gbps。",
            "answer": "$$\\boxed{10.40}$$"
        },
        {
            "introduction": "互连网络不仅是数据的搬运工，其设计还深刻影响着上层协议的正确性，尤其是在多处理器系统中。本练习探讨了不同互连架构（总线与片上网络）所提供的内存访问顺序保证的差异。通过分析这对缓存一致性协议设计的影响，你将理解为什么基于总线的监听协议相对简单，而基于片上网络的目录协议需要更复杂的机制来确保数据一致性。",
            "id": "3652369",
            "problem": "一个共享内存多处理器有四个核心 $C_0$, $C_1$, $C_2$, 和 $C_3$，并为单个缓存行 $X$ 实现缓存一致性。考虑两种互连设计：\n\n- 设计 B：一个带有中心化仲裁器的单一共享总线。一致性采用监听机制和原子总线请求；总线仲裁器一次只向一个请求者授权，所有缓存观察到相同的一致性事务序列。\n- 设计 N：一个片上网络 (NoC)，具体来说是一个二维网格，采用维度顺序路由和每链路先进先出 (FIFO) 队列。网络接口独立注入数据包，互连结构不对所有数据包强制执行单一全局顺序。一致性使用 $X$ 的主节点上的一个目录；失效和数据响应是独立的消息。\n\n请求的时间线如下：在时间 $t_1$，核心 $C_1$ 对 $X$ 发出写请求；在时间 $t_2$，核心 $C_2$ 对 $X$ 发出写请求；在时间 $t_3$，核心 $C_3$ 对 $X$ 发出读请求，其中 $t_1  t_2  t_3$。假设写请求使用写-失效策略，并且在更新 $X$ 之前必须获得独占所有权，并且 $C_0$ 最初持有一个干净的共享副本，主存的值与 $C_0$ 中的相同。\n\n使用排序和一致性的基本定义，分析由互连引起的排序如何影响可观察到的值，以及需要什么样的协议机制来维护单写多读不变量。选择所有正确的陈述。\n\nA. 在设计 B（总线）上，一致性请求的组合序列形成一个所有缓存都观察到的单一全序；监听协议可以依赖这种串行化来维护单写多读不变量，而无需每请求序列号。\n\nB. 在设计 N（NoC）上，每链路 FIFO 队列保证了整个网络中所有数据包的全局全序，因此可以不加改变地使用类似总线的监听协议。\n\nC. 在设计 N（NoC）上，为了在可能的消息重排序下保持一致性，协议必须要么通过诸如主节点上的目录、确认和瞬态等机制来强制执行每地址的排序，要么引入额外的虚拟通道或每源序列号来防止与重排序相关的竞争。\n\nD. 在设计 B（总线）上，如果 $C_1$ 和 $C_2$ 几乎同时对 $X$ 发出写请求，总线仲裁器的授权顺序定义了它们的串行化；如果 $C_3$ 的读请求在两个写授权之后发生，它将观察到两个写操作中较晚者的值，这与到仲裁器的物理距离无关。\n\nE. 在设计 N（NoC）中，维度顺序路由确保所有缓存观察到对同一地址的请求的相同顺序，因此与总线相比，协议复杂性降低了。\n\n选择所有适用的选项。",
            "solution": "从计算机组成和体系结构中的核心定义和广泛接受的事实开始：\n\n- 缓存一致性协议必须强制执行单写多读不变量：在任何逻辑时间，要么一个核心持有一个缓存行的独占、可写副本，要么多个核心持有共享的、只读的副本，并且写操作必须被串行化，以便读者看到一个一致的值。这要求对给定缓存行的操作允许一种与每个核心的程序顺序一致的串行化。\n- 带有仲裁的共享总线充当单一的串行化点：总线请求一次只被批准一个，所有观察者都看到相同的总线事务全序。监听协议利用此属性通过简单的状态转换来实现一致性，因为所有缓存都可以就所有权变更、失效和数据更新发生的顺序达成一致。\n- 一个采用分组交换、每链路 FIFO 队列和维度顺序路由的片上网络 (NoC)，通常不会为所有源自不同源、沿不同路径传输的数据包提供单一的全局全序。即使每个链路都保留了通过该链路的数据包的顺序，路径长度、争用和独立注入的差异也可能导致不同的观察者看到对给定地址的请求以不同的顺序到达，除非强制执行额外的排序机制。\n\n将这些应用到该场景中：\n\n对于设计 B (总线)，假设 $C_1$ 在时间 $t_1$ 请求独占所有权，$C_2$ 在时间 $t_2$ 请求，其中 $t_1  t_2$。总线仲裁器一次选择一个请求者；授权顺序为所有缓存定义了一个全序。如果 $C_1$ 首先获得授权，它会广播失效，通过监听或总线语义隐式地接收确认，然后将新值写入 $X$。当 $C_2$ 随后请求所有权时，它被串行化在 $C_1$ 之后，其写操作将在 $C_1$ 的写操作之后发生。如果 $C_3$ 在时间 $t_3$ 发出读请求，并且总线在两个写请求都获得授权并完成后处理它，那么该读请求被排序在后一个写操作之后，因此观察到后一个值。到仲裁器的物理线路延迟不会改变逻辑总线的串行化：总线定义了一个单一的、全局观察到的顺序。\n\n对于设计 N (NoC)，用于请求、失效、确认和数据响应的数据包会经过不同的路径。每链路 FIFO 排序只保留同一链路上数据包的顺序；它不会在所有链路和源之间创建一个全局全序。考虑 $C_1$ 和 $C_2$ 向 $X$ 的目录主节点发送请求。如果 $C_1$ 的请求需要经过 3 跳，而 $C_2$ 的请求需要经过 1 跳，那么即使 $t_1  t_2$，$C_2$ 的请求也可能首先到达目录。类似地，对共享者的失效和对请求者的数据响应可能会在不同时间、以不同的相对顺序到达每个核心，因为它们经历了不同的网络拥塞。如果没有额外的协议机制，一个假设单一串行化点的监听协议可能会失败：$C_3$ 的读请求可能在失效完成前就由内存提供服务，或者两个写者可能瞬时地认为它们都拥有权限。为了防止这种竞争，使用带有显式确认的基于目录的一致性协议来确保写者在完成前获得独占所有权，并且读者只有在失效完成后才被服务。额外的瞬态会跟踪在途的请求和确认。设计者还可以使用虚拟通道来分离请求、响应和确认流量，并使用每源序列号来防止必须按顺序处理的针对给定地址的消息发生重排序，从而相对于总线监听设计增加了协议的复杂性。\n\n逐项分析：\n\n- A. 该陈述与总线作为全局串行化点是一致的。所有缓存观察到相同的总线事务全序；监听协议利用了这一点，并且不需要每请求序列号，因为总线定义了顺序。结论：正确。\n\n- B. 每链路 FIFO 仅保证数据包在任何给定链路上不被重排序；它不会在整个网络上强加单一的全局全序。不同的路径和源导致不同的到达顺序。因此，在没有额外排序或目录机制的情况下，类似总线的监听协议不能在通用的 NoC 上不加改变地使用。结论：不正确。\n\n- C. 这正确地指出了在 NoC 情况下需要额外的排序和跟踪机制。目录控制器对每个地址的请求进行串行化，确认确保失效完成，瞬态跟踪在途操作，而虚拟通道或每源序列号用于防止死锁和对重排序敏感的竞争。结论：正确。\n\n- D. 在总线上，仲裁定义了串行化，而与物理距离无关。如果 $C_3$ 的读请求在总线上的排序位于两个写授权都完成之后，那么该读请求将观察到后一个写操作的值，这与单写多读不变量和总线串行化是一致的。结论：正确。\n\n- E. 维度顺序路由限制了数据包所走的路径，但不能确保所有缓存都观察到对同一地址的请求的相同顺序，特别是当数据包来自不同源并经过不同数量的跳数时。与总线相比，协议复杂性没有降低；它通常会增加，以处理重排序和分布式串行化。结论：不正确。\n\n因此，正确的选项是 A、C 和 D。",
            "answer": "$$\\boxed{ACD}$$"
        }
    ]
}