{
    "hands_on_practices": [
        {
            "introduction": "理论知识是基础，但真正的理解来自于实践。本节将通过一系列动手实践，带你深入探索非均匀访存架构（NUMA）的实际影响。第一个练习将聚焦于量化NUMA带来的基本性能损失。通过分析一个经典的“指针追逐”场景，你将计算出糟糕的内存布局如何导致严重的性能下降，并学习如何通过简单的NUMA感知内存分配策略来优化它。",
            "id": "3686974",
            "problem": "一个双插槽非统一内存访问 (NUMA) 系统拥有插槽 $\\mathrm{S0}$ 和 $\\mathrm{S1}$，每个插槽都有其自己的本地动态随机存取存储器 (DRAM)。一个单线程程序被绑定在 $\\mathrm{S0}$ 上运行。考虑遍历一个单链表，其节点大小为$64$字节，并在$64$字节的缓存行上对齐，因此跟随每个节点的 `next` 指针会为下一个节点导致一次末级缓存未命中和一次DRAM访问。工作集远大于缓存，硬件预取器无法预测指针追逐行为，因此内存级并行性实际上为$1$（串行化的未命中）。\n\n在这台机器上，以下延迟具有明确的特性：\n- 当 $\\mathrm{S0}$ 上的线程访问分配在 $\\mathrm{S0}$ 上的内存时的本地DRAM未命中延迟：$L_{\\mathrm{local}} = 90$ 纳秒。\n- 当 $\\mathrm{S0}$ 上的线程通过插槽间互连访问分配在 $\\mathrm{S1}$ 上的内存时的远程DRAM未命中延迟，包括一致性和目录开销：$L_{\\mathrm{remote}} = 180$ 纳秒。\n\n统一内存访问 (UMA) 指的是内存访问延迟与内存相对于处理器的位置无关的架构。相反，在NUMA架构中，访问延迟取决于内存是本地的还是远程的。\n\n构建以下病态的NUMA布局：对于 $i = 1, 2, \\dots, N$，如果 $i$ 是奇数，链表的节点 $i$ 分配在插槽 $\\mathrm{S0}$ 上；如果 $i$ 是偶数，则分配在插槽 $\\mathrm{S1}$ 上，其中头节点在 $\\mathrm{S0}$ 上。在这种布局下，平均而言，被遍历的节点中有一半是本地的，一半是远程的。\n\n从UMA和NUMA的核心定义以及串行化指针追逐使得遍历时间等于各次访问延迟之和这一观察出发，推导出在病态布局下每个节点的平均内存访问延迟 $L_{\\mathrm{avg,bad}}$ 的表达式。然后，提出一种重新设计，通过使用“首次接触”放置策略将所有链表节点分配在 $\\mathrm{S0}$ 上，以避免病态的交替分配，从而得到平均每节点延迟 $L_{\\mathrm{avg,good}}$。\n\n最后，计算重新设计的布局相对于病态布局的加速比 $S$，定义为\n$$\nS = \\frac{L_{\\mathrm{avg,bad}}}{L_{\\mathrm{avg,good}}}.\n$$\n将 $S$ 以一个四舍五入到四位有效数字的实数形式给出。最终答案不需要单位；在您的推导中，所有中间延迟都应以纳秒表示。假设 $N$ 足够大，以至于启动和末尾效应可以忽略不计，并且链表在遍历期间是只读的（没有写入），因此可以忽略由写入引起的一致性流量。将最终的加速比表示为一个四舍五入到四位有效数字的无量纲数。",
            "solution": "用户希望我分析在非统一内存访问 (NUMA) 系统上，两种不同内存分配布局下单链表遍历的性能，并计算优化布局相对于病态布局的加速比。\n\n首先，我将验证问题陈述。\n\n### 步骤1：提取已知条件\n- 系统：具有插槽 $\\mathrm{S0}$ 和 $\\mathrm{S1}$ 的双插槽NUMA系统。\n- 程序：单线程，被绑定在 $\\mathrm{S0}$ 上运行。\n- 数据结构：单链表。\n- 节点大小：64字节，在64字节缓存行上对齐。\n- 遍历特性：指针追逐导致每个节点一次末级缓存未命中和一次DRAM访问。工作集很大，硬件预取器无效。内存级并行性为1。\n- 延迟：\n  - 本地DRAM未命中延迟：$L_{\\mathrm{local}} = 90$ 纳秒。\n  - 远程DRAM未命中延迟：$L_{\\mathrm{remote}} = 180$ 纳秒。\n- 病态布局：对于索引为 $i = 1, 2, \\dots, N$ 的N个节点的列表，如果 $i$ 是奇数，节点 $i$ 位于插槽 $\\mathrm{S0}$ 上；如果 $i$ 是偶数，则位于插槽 $\\mathrm{S1}$ 上。头节点 ($i=1$) 位于 $\\mathrm{S0}$ 上。\n- 重新设计的布局：使用“首次接触”放置策略将所有链表节点分配在 $\\mathrm{S0}$ 上。\n- 加速比定义：$S = \\frac{L_{\\mathrm{avg,bad}}}{L_{\\mathrm{avg,good}}}$。\n- 假设：$N$ 足够大，可以忽略启动和末尾效应。遍历期间列表是只读的。\n\n### 步骤2：使用提取的已知条件进行验证\n问题陈述在计算机体系结构的原理（特别是内存层次结构和多插槽处理器系统上有科学依据。NUMA、UMA、缓存未命中、指针追逐、内存级并行性以及像“首次接触”这样的内存放置策略等概念都是标准且定义明确的。提供的延迟值（$L_{\\mathrm{local}} = 90 \\, \\text{ns}$，$L_{\\mathrm{remote}} = 180 \\, \\text{ns}$）对于现代服务器硬件是现实的，代表了2的NUMA因子。问题是适定的、客观的、自洽的，提供了推导出唯一解所需的所有必要信息和假设。所描述的“病态”场景是用于说明不感知NUMA的内存分配性能陷阱的经典例子。该问题不违反任何基本原理，没有歧义，并且可以直接使用提供的模型解决。\n\n### 步骤3：结论与行动\n问题是有效的。我将继续进行推导和求解。\n\n问题的核心在于计算两种不同场景下遍历单个节点的平均内存访问时间。问题陈述指出，由于指针追逐，链表遍历是串行化的，这意味着对节点 $i+1$ 的访问必须在对节点 $i$ 的访问完成后才能开始。因此，遍历 $N$ 个节点的总时间是每个节点各自内存访问延迟的总和。平均每节点延迟是该总时间除以 $N$。\n\n让我们首先分析病态的NUMA布局。线程在插槽 $\\mathrm{S0}$ 上执行。链表节点的内存分配在两个插槽之间交替：\n- 节点 $i=1$ 在 $\\mathrm{S0}$ 上（本地访问）。延迟为 $L_{\\mathrm{local}}$。\n- 节点 $i=2$ 在 $\\mathrm{S1}$ 上（远程访问）。延迟为 $L_{\\mathrm{remote}}$。\n- 节点 $i=3$ 在 $\\mathrm{S0}$ 上（本地访问）。延迟为 $L_{\\mathrm{local}}$。\n- 节点 $i=4$ 在 $\\mathrm{S1}$ 上（远程访问）。延迟为 $L_{\\mathrm{remote}}$。\n- ...依此类推。\n\n访问延迟的序列是 $L_{\\mathrm{local}}, L_{\\mathrm{remote}}, L_{\\mathrm{local}}, L_{\\mathrm{remote}}, \\dots$。\n由于假设节点数 $N$ 很大，我们可以忽略任何启动或末尾效应。在大量访问中，本地访问的次数将约等于远程访问的次数。具体来说，对于一个大的偶数 $N$，恰好有 $\\frac{N}{2}$ 次本地访问和 $\\frac{N}{2}$ 次远程访问。对于一个大的奇数 $N$，有 $\\frac{N+1}{2}$ 次本地访问和 $\\frac{N-1}{2}$ 次远程访问。在 $N \\to \\infty$ 的极限情况下，两种类型的访问都占总数的 $50\\%$。\n\n在病态布局下遍历 $N$ 个节点的总时间 $T_{\\mathrm{bad}}$ 是：\n$$T_{\\mathrm{bad}} \\approx \\frac{N}{2} \\cdot L_{\\mathrm{local}} + \\frac{N}{2} \\cdot L_{\\mathrm{remote}}$$\n平均每节点内存访问延迟 $L_{\\mathrm{avg,bad}}$ 是 $T_{\\mathrm{bad}}$ 除以 $N$：\n$$L_{\\mathrm{avg,bad}} = \\frac{T_{\\mathrm{bad}}}{N} = \\frac{\\frac{N}{2} (L_{\\mathrm{local}} + L_{\\mathrm{remote}})}{N} = \\frac{1}{2} (L_{\\mathrm{local}} + L_{\\mathrm{remote}})$$\n代入给定值，$L_{\\mathrm{local}} = 90 \\, \\text{ns}$ 和 $L_{\\mathrm{remote}} = 180 \\, \\text{ns}$：\n$$L_{\\mathrm{avg,bad}} = \\frac{1}{2} (90 \\, \\text{ns} + 180 \\, \\text{ns}) = \\frac{270}{2} \\, \\text{ns} = 135 \\, \\text{ns}$$\n\n接下来，我们分析重新设计的、感知NUMA的布局。这种布局使用“首次接触”放置策略。在这种策略中，操作系统在内存页首次被访问（写入或读取）的NUMA节点上为其分配内存。由于负责创建和遍历列表的单线程程序被绑定到插槽 $\\mathrm{S0}$，“首次接触”策略将确保所有链表节点的内存页都分配在 $\\mathrm{S0}$ 的本地内存上。\n\n因此，$\\mathrm{S0}$ 上的线程对链表节点的每次访问都将是本地内存访问。\n- 节点 $i=1$ 在 $\\mathrm{S0}$ 上（本地访问）。延迟为 $L_{\\mathrm{local}}$。\n- 节点 $i=2$ 在 $\\mathrm{S0}$ 上（本地访问）。延迟为 $L_{\\mathrm{local}}$。\n- ...依此类推，对所有 $N$ 个节点都是如此。\n\n在这种良好布局下遍历 $N$ 个节点的总时间 $T_{\\mathrm{good}}$ 是：\n$$T_{\\mathrm{good}} = N \\cdot L_{\\mathrm{local}}$$\n平均每节点内存访问延迟 $L_{\\mathrm{avg,good}}$ 是 $T_{\\mathrm{good}}$ 除以 $N$：\n$$L_{\\mathrm{avg,good}} = \\frac{T_{\\mathrm{good}}}{N} = \\frac{N \\cdot L_{\\mathrm{local}}}{N} = L_{\\mathrm{local}}$$\n代入给定值：\n$$L_{\\mathrm{avg,good}} = 90 \\, \\text{ns}$$\n\n最后，我们计算乘法加速比 $S$，即病态布局与重新设计布局的平均延迟之比。\n$$S = \\frac{L_{\\mathrm{avg,bad}}}{L_{\\mathrm{avg,good}}}$$\n代入推导出的表达式和值：\n$$S = \\frac{\\frac{1}{2} (L_{\\mathrm{local}} + L_{\\mathrm{remote}})}{L_{\\mathrm{local}}} = \\frac{L_{\\mathrm{local}} + L_{\\mathrm{remote}}}{2 \\cdot L_{\\mathrm{local}}}$$\n$$S = \\frac{135 \\, \\text{ns}}{90 \\, \\text{ns}} = \\frac{135}{90} = \\frac{3 \\times 45}{2 \\times 45} = \\frac{3}{2} = 1.5$$\n问题要求答案是一个四舍五入到四位有效数字的实数。\n$$S = 1.500$$\n1.500的加速比表明，感知NUMA的布局（确保所有内存访问都是本地的）使链表遍历比病态布局（强制一半的访问是远程的）快50%。",
            "answer": "$$\\boxed{1.500}$$"
        },
        {
            "introduction": "NUMA系统中的性能问题并不仅仅源于远程内存的访问延迟。一个更微妙但同样关键的问题是“伪共享”（false sharing），它会导致跨插槽（cross-socket）的缓存一致性流量激增。这个练习将引导你分析两种常见的数据布局——结构体数组（AoS）和数组结构体（SoA）——如何与缓存行交互，并量化它们在特定访问模式下产生的远程缓存失效数量。通过这个实践，你将体会到数据结构设计对多核系统性能的深远影响。",
            "id": "3687062",
            "problem": "考虑一个双路非统一内存访问（NUMA）系统。每个插槽（socket）都有私有缓存，并且系统强制执行一种基于目录的缓存一致性协议，该协议与“修改、独占、共享、无效”（MESI）协议一致。假设采用写失效语义：当一个插槽上的核心对另一个插槽缓存中当前存在的缓存行执行存储操作时，一致性协议会为每次所有权转移向另一个插槽精确地发出一个失效消息。缓存行大小为 $L = 64$ 字节。所有数组的起始地址都按 $64$ 字节对齐。\n\n一个程序在一个包含 $N = 2^{20}$ 个逻辑元素的数组上执行一个稳态迭代内核。考虑两种数据布局变体：\n\n1. 结构体数组 (AoS)：每个元素是一个大小为 $s = 32$ 字节的结构体，包含两个独立的字段 $x$ 和 $y$，每个字段占用 $8$ 字节，外加填充以达到总共 $32$ 字节。包含 $N$ 个元素的数组 $A$ 在内存中是连续的。\n\n2. 数组结构 (SoA)：两个独立的数组 $X$ 和 $Y$，每个数组的长度为 $N$，元素大小为 $8$ 字节。$X$ 的内存页仅由运行在插槽 0 上的线程首次访问，$Y$ 的内存页仅由运行在插槽 1 上的线程首次访问。\n\n每次迭代的工作分配如下。插槽 0 上的线程更新所有偶数索引 $i \\in \\{0, 2, 4, \\dots\\}$ 的字段 $x$，为每个这样的 $i$ 对 $x$ 执行一次存储操作。插槽 1 上的线程更新所有奇数索引 $i \\in \\{1, 3, 5, \\dots\\}$ 的字段 $y$，为每个这样的 $i$ 对 $y$ 执行一次存储操作。在迭代期间，没有线程读取或写入任何其他字段或索引。考虑稳态情况，即对于 AoS 布局中被两个插槽都访问的缓存行，由于前一次迭代的访问，这些缓存在每次迭代开始时都驻留在两个插槽的缓存中。\n\n基于上述非统一内存访问（NUMA）、缓存行和 MESI 写失效语义的定义，推导出 AoS 布局和 SoA 布局每次迭代产生的跨插槽（远程）失效消息的确切数量。将最终答案表示为一个双分量行向量 $\\left(I_{\\mathrm{AoS}}, I_{\\mathrm{SoA}}\\right)$，其中每个分量是每次迭代的远程失效次数。无需进行取整。",
            "solution": "该问题要求在一个采用基于 MESI 的写失效缓存一致性协议的双路 NUMA 系统上，推导两种数据布局——结构体数组（AoS）和数组结构（SoA）——每次迭代产生的跨插槽失效消息的数量。\n\n首先，我们确定给出的关键参数：\n- 缓存行大小：$L = 64$ 字节。\n- 逻辑元素数量：$N = 2^{20}$。\n- AoS 结构体大小：$s = 32$ 字节。\n- SoA 元素大小：$8$ 字节。\n\n一致性协议为存在于另一插槽缓存中的缓存行的每次所有权转移，精确地生成一个远程失效消息。\n\n**结构体数组（AoS）布局分析**\n\n在 AoS 布局中，数据存储在由 $N$ 个结构体组成的单个连续数组 $A$ 中。每个结构体的大小为 $s = 32$ 字节。缓存行大小为 $L = 64$ 字节。因此，单个缓存行可以容纳的结构体数量为：\n$$ \\frac{L}{s} = \\frac{64 \\text{ bytes}}{32 \\text{ bytes}} = 2 $$\n由于数组是 $64$ 字节对齐的，数组的第 $k$ 个缓存行（其中 $k$ 是从零开始的索引）将包含结构体 $A[2k]$ 和 $A[2k+1]$。\n\n工作分配如下：\n- 插槽 0 上的线程对所有偶数索引 $i$ 的 $A[i]$ 的字段 $x$ 执行存储操作。这对应于访问 $A[0], A[2], A[4], \\dots$。\n- 插槽 1 上的线程对所有奇数索引 $i$ 的 $A[i]$ 的字段 $y$ 执行存储操作。这对应于访问 $A[1], A[3], A[5], \\dots$。\n\n让我们分析对包含 $A[2k]$ 和 $A[2k+1]$ 的第 $k$ 个缓存行的访问。\n- 插槽 0 上的一个线程将写入 $A[2k]$ 内的一个字段。\n- 插槽 1 上的一个线程将写入 $A[2k+1]$ 内的一个字段。\n由于两次写操作都针对同一个缓存行，这种情况被称为伪共享。\n\n问题陈述，在稳态下，这些发生冲突的缓存行在每次迭代开始时都驻留在两个插槽的缓存中。在 MESI 协议中，这意味着该缓存在插槽 0 和插槽 1 的缓存中都处于**共享（S）**状态。\n\n我们现在追踪一个这样的缓存行在一次迭代期间的失效事件：\n1.  **第一次存储（例如，从插槽 0）：** 插槽 0 上的一个线程对 A[2k].x 执行存储操作。该缓存行处于 S 状态。为了写入，插槽 0 上的缓存必须获得独占所有权。它发送一个请求，将其状态升级为**修改（M）**。此操作需要使所有其他共享副本失效。因此，一致性协议向插槽 1 发送一个失效消息。插槽 1 的该缓存行副本转换到**无效（I）**状态。此时，发生了一次远程失效。该缓存行在插槽 0 上处于 M 状态，在插槽 1 上处于 I 状态。\n2.  **第二次存储（从插槽 1）：** 插槽 1 上的一个线程对 A[2k+1].y 执行存储操作。其本地副本处于 I 状态，因此这会导致写未命中。插槽 1 的缓存发送一个请求，要求获得该缓存行的独占所有权。目录将此请求转发到当前以 M 状态持有该行的插槽 0。插槽 0 必须放弃所有权。这构成了一次所有权转移。由于该行“当前存在于另一个插槽的缓存中”（即插槽 0 的缓存），协议向插槽 0 发出一个失效消息。插槽 0 的副本转换到 I 状态。此时，发生了第二次远程失效。该缓存行现在在插槽 0 上处于 I 状态，在插槽 1 上处于 M 状态。\n\n因此，对于每个包含被两个插槽都访问的数据的缓存行，每次迭代都会产生恰好两次跨插槽失效。\n\n现在，我们必须确定有多少缓存行表现出这种伪共享。数组 A 由 $N = 2^{20}$ 个结构体组成，每个结构体大小为 $s = 32$ 字节。数组的总大小为 $N \\times s = 2^{20} \\times 32$ 字节。该数组跨越的缓存行数量为：\n$$ \\text{Number of lines} = \\frac{N \\times s}{L} = \\frac{2^{20} \\times 32}{64} = \\frac{2^{20}}{2} = 2^{19} $$\n每个缓存行都包含一个偶数索引的结构体（由插槽 0 写入）和一个奇数索引的结构体（由插槽 1 写入），因此所有 $2^{19}$ 个缓存行都会发生伪共享。\n\nAoS 布局的总失效次数 $I_{\\mathrm{AoS}}$ 是冲突缓存行的数量乘以每行的失效次数：\n$$ I_{\\mathrm{AoS}} = (\\text{Number of lines}) \\times (\\text{Invalidations per line}) = 2^{19} \\times 2 = 2^{20} $$\n\n**数组结构（SoA）布局分析**\n\n在 SoA 布局中，数据被组织成两个独立的数组 $X$ 和 $Y$。数组 $X$ 包含所有的 $x$ 字段，数组 $Y$ 包含所有的 $y$ 字段。\n\n工作分配为：\n- 插槽 0 上的线程写入偶数索引 $i$ 的 $X[i]$。\n- 插槽 1 上的线程写入奇数索引 $i$ 的 $Y[i]$。\n\n关键在于，插槽 0 上的线程只访问数组 $X$，而插槽 1 上的线程只访问数组 $Y$。两个插槽访问的数组没有重叠。\n\n- **对数组 X 的访问：** 由于只有插槽 0 的线程访问数组 $X$，属于 $X$ 的缓存行将只被加载到插槽 0 的缓存中。它们永远不会出现在插槽 1 的缓存中。因此，当插槽 0 上的线程对来自 $X$ 的缓存行执行存储操作时，插槽 1 上没有需要使其失效的副本。不会产生跨插槽失效消息。\n- **对数组 Y 的访问：** 同样地，由于只有插槽 1 的线程访问数组 $Y$，属于 $Y$ 的缓存行将只被加载到插槽 1 的缓存中。它们永远不会出现在插槽 0 的缓存中。当插槽 1 上的线程执行存储操作时，插槽 0 上没有需要使其失效的副本。同样，不会产生跨插槽失效消息。\n\n首次接触页面放置策略将 $X$ 的页面分配给插槽 0 的本地内存，将 $Y$ 的页面分配给插槽 1 的本地内存，这减少了内存访问延迟，但并未改变基本的缓存一致性行为。决定性因素是数据访问的严格分离，这在缓存行级别上完全消除了插槽之间的数据共享。\n\n因此，SoA 布局的跨插槽总失效次数为零。\n$$ I_{\\mathrm{SoA}} = 0 $$\n\n最终答案是双分量行向量 $(I_{\\mathrm{AoS}}, I_{\\mathrm{SoA}})$。\n$$ (I_{\\mathrm{AoS}}, I_{\\mathrm{SoA}}) = (2^{20}, 0) $$",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n2^{20} & 0\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "除了优化数据布局，我们还可以在算法层面进行NUMA感知设计，以最大化数据局部性。本练习以科学计算中的基石——矩阵乘法为例，探讨如何通过合理地划分数据和计算任务（即分块策略）来最小化跨插槽的数据传输。你将需要为给定的数据分布和工作分配方案设计一个最优的计算调度，并计算其能够达到的最小通信开销。这个实践将展示在高性能计算中，算法设计与底层硬件架构协同工作的重要性。",
            "id": "3686977",
            "problem": "在一个双插槽非统一内存访问 (NUMA) 系统上执行一次稠密矩阵乘法 $C = A \\times B$，并与概念上的统一内存访问 (UMA) 系统进行对比。非统一内存访问 (NUMA) 指的是每个插槽拥有访问速度更快的本地内存和访问速度较慢的远程内存，而统一内存访问 (UMA) 指的是所有内存访问都具有统一的延迟和带宽，无论哪个插槽发起访问。设 $A \\in \\mathbb{R}^{N \\times N}$ 和 $B \\in \\mathbb{R}^{N \\times N}$，其中 $N = 32768$，每个元素占用 $8$ 字节存储。插槽 $0$ 拥有 $A$ 的前 $N/2$ 行和 $B$ 的前 $N/2$ 列，插槽 $1$ 拥有 $A$ 的后 $N/2$ 行和 $B$ 的后 $N/2$ 列。乘法计算的执行方式是：将 $C$ 的每个块行分配给拥有 $A$ 相应行的插槽，并按块列处理 $C$。你可以选择任何能放入缓存的方形块大小；假设只要 $B$ 的一个块列存在于某个插槽中，该插槽内就能实现理想的复用；并假设任何一个插槽所需的、但非其拥有的数据，都必须从另一个插槽传输一次，之后便可复用而无需进一步的远程传输。\n\n仅使用矩阵乘法的核心定义 $C_{ij} = \\sum_{\\ell=1}^{N} A_{i\\ell} B_{\\ell j}$，首先分析生成 $C$ 需要如何消耗 $A$ 的行和 $B$ 的列，然后提出一个分块调度方案，以最小化该 NUMA 系统上 $B$ 的远程传输量，并明确解释为何该方案能最小化远程带宽使用。然后，在你提出的方案下，确定为完成整个乘法计算，必须跨越插槽间链路传输的最小总字节数（两个插槽的总和）。用 gibibyte (GiB) 表示你的最终答案，并四舍五入到四位有效数字。",
            "solution": "该问题要求为一个在双插槽 NUMA 系统上执行的稠密矩阵乘法 $C = A \\times B$ 设计一个最优调度方案，并计算跨插槽间链路的最小数据传输量。\n\n首先，我们验证问题陈述的有效性。\n已知条件如下：\n- 操作：稠密矩阵乘法 $C = A \\times B$，其中 $A, B, C \\in \\mathbb{R}^{N \\times N}$。\n- 矩阵维度：$N = 32768$。\n- 元素大小：$8$ 字节。\n- 系统：一个双插槽非统一内存访问 (NUMA) 架构。\n- 数据分布：\n  - 插槽_0 拥有 $A$ 的第 $0$ 行到第 $N/2 - 1$ 行以及 $B$ 的第 $0$ 列到第 $N/2 - 1$ 列。\n  - 插槽_1 拥有 $A$ 的第 $N/2$ 行到第 $N - 1$ 行以及 $B$ 的第 $N/2$ 列到第 $N - 1$ 列。\n- 工作分配：\n  - 插槽_0 计算 $C$ 的第 $0$ 行到第 $N/2 - 1$ 行。\n  - 插槽_1 计算 $C$ 的第 $N/2$ 行到第 $N - 1$ 行。\n- 约束：$C$ 的计算按块列进行处理。\n- 假设：任何一个插槽所需的、但非其拥有的数据块仅传输一次。\n- 目标：提出一个最小化 $B$ 的远程传输的调度方案，证明其最优性，计算总传输字节数，并以 GiB 为单位表示结果，保留四位有效数字。\n\n该问题具有科学依据，提法明确且客观。它描述了高性能计算中的一个标准场景。所有必要信息均已提供，且无矛盾之处。因此，该问题是有效的。\n\n让我们通过将矩阵 $A$、$B$ 和 $C$ 划分为四个大小为 $(N/2) \\times (N/2)$ 的方块来形式化这个问题：\n$$ A = \\begin{pmatrix} A_{00}  A_{01} \\\\ A_{10}  A_{11} \\end{pmatrix}, \\quad B = \\begin{pmatrix} B_{00}  B_{01} \\\\ B_{10}  B_{11} \\end{pmatrix}, \\quad C = \\begin{pmatrix} C_{00}  C_{01} \\\\ C_{10}  C_{11} \\end{pmatrix} $$\n矩阵乘法可以用这些分块表示如下：\n$$ C_{00} = A_{00}B_{00} + A_{01}B_{10} $$\n$$ C_{01} = A_{00}B_{01} + A_{01}B_{11} $$\n$$ C_{10} = A_{10}B_{00} + A_{11}B_{10} $$\n$$ C_{11} = A_{10}B_{01} + A_{11}B_{11} $$\n\n根据问题陈述，我们可以定义每个数据块的所有权：\n- 插槽 $0$ 拥有 $A$ 的前 $N/2$ 行，对应于块 $A_{00}$ 和 $A_{01}$。它还拥有 $B$ 的前 $N/2$ 列，对应于块 $B_{00}$ 和 $B_{10}$。\n- 插槽 $1$ 拥有 $A$ 的后 $N/2$ 行，对应于块 $A_{10}$ 和 $A_{11}$。它还拥有 $B$ 的后 $N/2$ 列，对应于块 $B_{01}$ 和 $B_{11}$。\n\n工作分配也已定义：\n- 插槽 $0$ 计算 $C$ 的前 $N/2$ 行，即块 $C_{00}$ 和 $C_{01}$。\n- 插槽 $1$ 计算 $C$ 的后 $N/2$ 行，即块 $C_{10}$ 和 $C_{11}$。\n\n为了证明传输量的最小性，我们首先建立一个通信下界。\n为了完成其分配的工作，插槽 $0$ 必须计算 $C_{00}$ 和 $C_{01}$。\n- 对于 $C_{00}$，插槽 $0$ 需要 $A_{00}$、$A_{01}$、$B_{00}$ 和 $B_{10}$。所有这些块都归本地所有。\n- 对于 $C_{01}$，插槽 $0$ 需要 $A_{00}$、$A_{01}$、$B_{01}$ 和 $B_{11}$。块 $A_{00}$ 和 $A_{01}$ 是本地的。然而，块 $B_{01}$ 和 $B_{11}$ 归插槽 $1$ 所有。\n因此，为了完成其计算，插槽 $0$ 从根本上需要矩阵 $B$ 的全部后 $N/2$ 列。这部分数据，包括块 $B_{01}$ 和 $B_{11}$，必须从插槽 $1$ 传输到插槽 $0$。这些数据的大小为 $N \\times (N/2)$ 个元素。\n\n同样，为了完成其分配的工作，插槽 $1$ 必须计算 $C_{10}$ 和 $C_{11}$。\n- 对于 $C_{10}$，插槽 $1$ 需要 $A_{10}$、$A_{11}$、$B_{00}$ 和 $B_{10}$。块 $A_{10}$ 和 $A_{11}$ 是本地的。然而，块 $B_{00}$ 和 $B_{10}$ 归插槽 $0$ 所有。\n- 对于 $C_{11}$，插槽 $1$ 需要 $A_{10}$、$A_{11}$、$B_{01}$ 和 $B_{11}$。所有这些块都归本地所有。\n因此，为了完成其计算，插槽 $1$ 从根本上需要矩阵 $B$ 的全部前 $N/2$ 列。这部分数据，包括块 $B_{00}$ 和 $B_{10}$，必须从插槽 $0$ 传输到插槽 $1$。这些数据的大小为 $N \\times (N/2)$ 个元素。\n\n这种将 $C$ 的行计算分配给拥有 $A$ 相应行的插槽的工作分配方式，确保了矩阵 $A$ 的任何部分都不需要传输。通信成本完全来自矩阵 $B$ 的分布。最小总传输量是两个插槽所需远程数据的总和：\n$$ \\text{Volume}_\\text{min} = (\\text{Size of } B_{01} + B_{11}) + (\\text{Size of } B_{00} + B_{10}) $$\n每个块的大小为 $(N/2) \\times (N/2)$，包含 $(N/2)^2 = N^2/4$ 个元素。\n$$ \\text{Volume}_\\text{min, elements} = (N^2/4 + N^2/4) + (N^2/4 + N^2/4) = N^2/2 + N^2/2 = N^2 $$\n必须跨越插槽间链路传输的最小总元素数量为 $N^2$。\n\n现在，我们根据问题中按块列处理 $C$ 的约束，提出了一个能达到此下界的调度方案。\n**调度方案：按 C 的块列进行计算**\n- **阶段 1：计算 $C$ 的第一个块列。**\n  - 插槽 $0$ 计算 $C_{00} = A_{00}B_{00} + A_{01}B_{10}$。所有需要的数据（$A_{00}, A_{01}, B_{00}, B_{10}$）都是本地的。无需向插槽 $0$ 传输数据。\n  - 插槽 $1$ 计算 $C_{10} = A_{10}B_{00} + A_{11}B_{10}$。它需要来自插槽 $0$ 的块 $B_{00}$ 和 $B_{10}$。\n  - 阶段 1 的传输：插槽 $0$ 将 $B_{00}$ 和 $B_{10}$ 发送到插槽 $1$。传输量：$N^2/2$ 个元素。\n\n- **阶段 2：计算 $C$ 的第二个块列。**\n  - 插槽 $0$ 计算 $C_{01} = A_{00}B_{01} + A_{01}B_{11}$。它需要来自插槽 $1$ 的块 $B_{01}$ 和 $B_{11}$。\n  - 插槽 $1$ 计算 $C_{11} = A_{10}B_{01} + A_{11}B_{11}$。所有需要的数据（$A_{10}, A_{11}, B_{01}, B_{11}$）都是本地的。无需向插槽 $1$ 传输数据。\n  - 阶段 2 的传输：插槽 $1$ 将 $B_{01}$ 和 $B_{11}$ 发送到插槽 $0$。传输量：$N^2/2$ 个元素。\n\n该调度方案的总传输量是两个阶段传输量的总和：$N^2/2 + N^2/2 = N^2$ 个元素。由于这个传输量与推导出的下界相匹配，因此该调度在最小化远程传输总量方面是最优的。\n\n最后，我们计算总字节数。\n需要传输的元素数量为 $N^2$。\n给定 $N = 32768 = 2^{15}$。\n总传输元素数 = $(2^{15})^2 = 2^{30}$。\n每个元素占用 $8$ 字节存储。\n总传输字节数 = $8 \\times 2^{30}$ 字节。\n\n为了用 gibibyte (GiB) 表示，我们使用换算公式 $1 \\text{ GiB} = 2^{30}$ 字节。\n$$ \\text{Total GiB} = \\frac{8 \\times 2^{30} \\text{ bytes}}{2^{30} \\text{ bytes/GiB}} = 8 \\text{ GiB} $$\n问题要求答案四舍五入到四位有效数字。\n$$ 8.000 \\text{ GiB} $$\n这就是必须跨越插槽间链路的最小总字节数。",
            "answer": "$$\n\\boxed{8.000}\n$$"
        }
    ]
}