{
    "hands_on_practices": [
        {
            "introduction": "Clock gating is a foundational power-saving technique that disables the clock to idle parts of a circuit, thereby cutting their dynamic power consumption. This exercise  provides a hands-on opportunity to design a realistic clock-gating policy for a processor's functional unit. By analyzing a hypothetical bursty workload, you will quantify the net power savings while accounting for practical constraints such as control latency and energy overhead.",
            "id": "3666961",
            "problem": "A pipelined integer multiplier in a superscalar processor experiences a bursty workload: the pipeline presents valid operands for $30$ consecutive cycles, followed by $20$ consecutive cycles with no operands, repeating indefinitely. This repeating pattern implies an idle fraction of $40\\%$. During idle periods, the multiplierâ€™s internal sequential elements continue to toggle their local clock if ungated.\n\nAssume the following:\n- The supply voltage is $V = 0.9\\,\\mathrm{V}$ and the operating frequency is $f = 800\\,\\mathrm{MHz}$. Dynamic Voltage and Frequency Scaling (DVFS) is disabled during the interval of interest, so $V$ and $f$ are constant.\n- The effective clocked capacitance of the multiplier and its local clock distribution, when the clock is ungated, is $C_{\\mathrm{eff}} = 160\\,\\mathrm{pF}$.\n- The clock-gating cell has a wake-up latency of $L_{\\mathrm{wu}} = 2$ cycles (the clock must be re-enabled $2$ cycles before the next active operand arrives to meet timing).\n- To avoid thrashing, the gating controller requires $L_{\\mathrm{det}} = 2$ consecutive idle cycles before asserting the gate.\n- Each gate assertion and de-assertion pair consumes an overhead energy of $E_{\\mathrm{gate}} = 100\\,\\mathrm{pJ}$ in the gating control logic.\n\nPropose a reasonable clock-gating policy that respects the detection and wake-up latencies stated above, and then estimate the long-run average dynamic power saved by clock gating over the repeating workload pattern. Base your reasoning on first principles of dynamic power in synchronous circuits. Express the final saved power in milliwatts. Round your answer to four significant figures.",
            "solution": "The problem is to calculate the average power saved by a clock-gating policy that accounts for detection and wake-up latencies, as well as energy overhead for control.\n\n**1. Analyze the Workload and Policy Constraints**\nThe workload repeats over a period of $30 \\text{ active} + 20 \\text{ idle} = 50$ cycles.\nThe clock can be gated during the 20-cycle idle interval.\n- **Detection latency ($L_{\\text{det}}$):** 2 cycles. The controller must wait for 2 idle cycles before it can assert the clock gate.\n- **Wake-up latency ($L_{\\text{wu}}$):** 2 cycles. The clock must be re-enabled 2 cycles before the next active cycle. This means the clock must be on for the last 2 cycles of the idle interval.\n\n**2. Determine the Number of Gated Cycles**\nOut of the 20 idle cycles in each 50-cycle period, the first 2 are ungated due to detection latency, and the last 2 are ungated due to wake-up latency.\nThe number of cycles the multiplier's clock is actually gated is:\n$$N_{\\text{gated}} = \\text{Total Idle Cycles} - L_{\\text{det}} - L_{\\text{wu}} = 20 - 2 - 2 = 16 \\text{ cycles}$$\n\n**3. Calculate the Dynamic Power of the Multiplier**\nThe dynamic power consumed by the multiplier when its clock is active is given by $P_{\\text{mult}} = C_{\\text{eff}} V^2 f$. This is the amount of power saved during each gated cycle.\n$$P_{\\text{mult}} = (160 \\times 10^{-12}\\,\\text{F}) \\cdot (0.9\\,\\text{V})^2 \\cdot (800 \\times 10^6\\,\\text{Hz})$$\n$$P_{\\text{mult}} = (160 \\times 10^{-12}) \\cdot 0.81 \\cdot (8 \\times 10^8) = 103.68 \\times 10^{-3}\\,\\text{W} = 0.10368\\,\\text{W}$$\n\n**4. Calculate Net Energy Saved per Period**\nFirst, find the energy saved by gating the clock for $N_{\\text{gated}}$ cycles. The duration of one clock cycle is $T_{\\text{clk}} = 1/f$.\n$$E_{\\text{gating\\_saved}} = P_{\\text{mult}} \\times N_{\\text{gated}} \\times T_{\\text{clk}} = P_{\\text{mult}} \\times \\frac{N_{\\text{gated}}}{f}$$\n$$E_{\\text{gating\\_saved}} = 0.10368\\,\\text{W} \\times \\frac{16}{800 \\times 10^6\\,\\text{Hz}} = 2.0736 \\times 10^{-9}\\,\\text{J}$$\nThe problem states an energy overhead of $E_{\\text{gate}} = 100\\,\\text{pJ} = 0.1 \\times 10^{-9}\\,\\text{J}$ for each gating event (assertion/de-assertion pair). Since this happens once per 50-cycle period, we subtract this from the saved energy.\n$$E_{\\text{net\\_saved}} = E_{\\text{gating\\_saved}} - E_{\\text{gate}} = 2.0736 \\times 10^{-9}\\,\\text{J} - 0.1 \\times 10^{-9}\\,\\text{J} = 1.9736 \\times 10^{-9}\\,\\text{J}$$\n\n**5. Calculate Average Power Saved**\nThe average power saved is the net energy saved per period divided by the duration of the period. The period duration in seconds is $T_{\\text{period}} = 50 \\times T_{\\text{clk}} = 50 / f$.\n$$P_{\\text{avg\\_saved}} = \\frac{E_{\\text{net\\_saved}}}{T_{\\text{period}}} = \\frac{1.9736 \\times 10^{-9}\\,\\text{J}}{50 / (800 \\times 10^6\\,\\text{Hz})} = \\frac{1.9736 \\times 10^{-9}\\,\\text{J}}{6.25 \\times 10^{-8}\\,\\text{s}} = 0.0315776\\,\\text{W}$$\nConverting to milliwatts:\n$$P_{\\text{avg\\_saved}} = 31.5776\\,\\text{mW}$$\n\n**6. Final Answer**\nRounding to four significant figures, the average dynamic power saved is $31.58\\,\\text{mW}$.",
            "answer": "$$ \\boxed{31.58} $$"
        },
        {
            "introduction": "Dynamic Voltage and Frequency Scaling (DVFS) offers a powerful method for managing the trade-off between computational performance and energy consumption. This practice  delves into the theoretical principles of energy-optimal scheduling for a task with a strict deadline. You will work with a model processor that has discrete operating points to determine the schedule that minimizes total energy, illustrating a core concept in energy-aware computing.",
            "id": "3667039",
            "problem": "A single in-order core supports Dynamic Voltage and Frequency Scaling (DVFS) with three discrete operating points. The DVFS states are:\n- $\\left(V_{1}, f_{1}\\right) = \\left(0.7~\\text{V},~1.2~\\text{GHz}\\right)$,\n- $\\left(V_{2}, f_{2}\\right) = \\left(0.9~\\text{V},~1.8~\\text{GHz}\\right)$,\n- $\\left(V_{3}, f_{3}\\right) = \\left(1.1~\\text{V},~2.4~\\text{GHz}\\right)$.\n\nAssume the dynamic power is modeled by $P_{\\text{dyn}}(V,f) = C_{\\text{eff}} V^{2} f$ with effective switched capacitance $C_{\\text{eff}} = 1.5 \\times 10^{-9}~\\text{F}$, and the leakage power is modeled by $P_{\\text{leak}}(V) = k_{\\text{leak}} V$ with $k_{\\text{leak}} = 0.4~\\text{W/V}$. A task requires $W = 3.0 \\times 10^{9}$ cycles and must be completed within a deadline of $D = 1.6~\\text{s}$. Voltage and frequency transitions are instantaneous and incur negligible overhead. The processor must actively execute the task throughout the interval $\\left[0, D\\right]$ without idle gaps; that is, it cannot finish early and idle before the deadline.\n\nYou may arbitrarily time-share among the three DVFS states over the interval $\\left[0, D\\right]$. Let $t_{i}$ denote the total time spent in state $i$ during $\\left[0, D\\right]$, with $t_{i} \\ge 0$. The feasibility constraints are $\\sum_{i=1}^{3} t_{i} = D$ and $\\sum_{i=1}^{3} f_{i} t_{i} = W$. The total energy is\n$$\nE \\;=\\; \\int_{0}^{D} P(t)\\,dt \\;=\\; \\sum_{i=1}^{3} \\Big(P_{\\text{dyn}}(V_{i}, f_{i}) + P_{\\text{leak}}(V_{i})\\Big)\\, t_{i}.\n$$\n\nStarting from the stated power models and constraints, determine the minimum achievable energy over all feasible schedules. Express the final energy in Joules and round your answer to four significant figures.",
            "solution": "The problem is first validated to ensure it is scientifically grounded, well-posed, and objective.\n\n**Step 1: Extracted Givens**\n- DVFS State 1: $(V_{1}, f_{1}) = (0.7~\\text{V},~1.2~\\text{GHz})$\n- DVFS State 2: $(V_{2}, f_{2}) = (0.9~\\text{V},~1.8~\\text{GHz})$\n- DVFS State 3: $(V_{3}, f_{3}) = (1.1~\\text{V},~2.4~\\text{GHz})$\n- Dynamic Power Model: $P_{\\text{dyn}}(V,f) = C_{\\text{eff}} V^{2} f$\n- Effective Switched Capacitance: $C_{\\text{eff}} = 1.5 \\times 10^{-9}~\\text{F}$\n- Leakage Power Model: $P_{\\text{leak}}(V) = k_{\\text{leak}} V$\n- Leakage Coefficient: $k_{\\text{leak}} = 0.4~\\text{W/V}$\n- Workload: $W = 3.0 \\times 10^{9}$ cycles\n- Deadline: $D = 1.6~\\text{s}$\n- Time in state $i$: $t_{i}$, with $t_{i} \\ge 0$\n- Constraints: $\\sum_{i=1}^{3} t_{i} = D$ and $\\sum_{i=1}^{3} f_{i} t_{i} = W$\n- Energy Expression: $E = \\sum_{i=1}^{3} \\Big(P_{\\text{dyn}}(V_{i}, f_{i}) + P_{\\text{leak}}(V_{i})\\Big)\\, t_{i}$\n\n**Step 2: Validation**\nThe problem is a well-defined constrained optimization problem. The power models are standard, simplified representations used in computer architecture. The provided values are physically plausible for an academic problem. The constraints are linear, and the objective function is linear in the optimization variables $t_i$. The required average frequency is $f_{\\text{avg}} = W/D = (3.0 \\times 10^9)/(1.6) = 1.875 \\times 10^9~\\text{Hz} = 1.875~\\text{GHz}$. Since this frequency lies between the available frequencies $f_1=1.2~\\text{GHz}$ and $f_3=2.4~\\text{GHz}$, a feasible solution exists. The problem is self-contained, scientifically grounded, and well-posed.\n\n**Step 3: Verdict**\nThe problem is valid.\n\n**Solution Derivation**\nThe objective is to minimize the total energy $E$, which is a linear function of the time spent in each state, $t_i$:\n$$\nE(t_1, t_2, t_3) = P_1 t_1 + P_2 t_2 + P_3 t_3\n$$\nwhere $P_i$ is the total power in state $i$. The minimization is subject to the linear constraints:\n$$\n\\begin{cases}\nt_1 + t_2 + t_3 = D \\\\\nf_1 t_1 + f_2 t_2 + f_3 t_3 = W \\\\\nt_1, t_2, t_3 \\ge 0\n\\end{cases}\n$$\nThis formulation constitutes a linear program. The feasible region is the intersection of two planes with the non-negative octant, which forms a line segment. A linear function over a compact convex set, such as a line segment, attains its minimum at an extreme point (an endpoint of the segment). The endpoints of the feasible segment correspond to solutions where one of the $t_i$ variables is zero. Therefore, the optimal solution will involve time-sharing between at most two DVFS states.\n\nFirst, we calculate the total power $P_i$ for each state $i \\in \\{1, 2, 3\\}$ using the formula $P_i = C_{\\text{eff}} V_i^2 f_i + k_{\\text{leak}} V_i$.\nFor State 1: $(V_1, f_1) = (0.7~\\text{V}, 1.2~\\text{GHz})$\n$$P_1 = (1.5 \\times 10^{-9}~\\text{F}) (0.7~\\text{V})^2 (1.2 \\times 10^9~\\text{Hz}) + (0.4~\\text{W/V})(0.7~\\text{V})$$\n$$P_1 = (1.5 \\times 0.49 \\times 1.2)~\\text{W} + 0.28~\\text{W} = 0.882~\\text{W} + 0.28~\\text{W} = 1.162~\\text{W}$$\n\nFor State 2: $(V_2, f_2) = (0.9~\\text{V}, 1.8~\\text{GHz})$\n$$P_2 = (1.5 \\times 10^{-9}~\\text{F}) (0.9~\\text{V})^2 (1.8 \\times 10^9~\\text{Hz}) + (0.4~\\text{W/V})(0.9~\\text{V})$$\n$$P_2 = (1.5 \\times 0.81 \\times 1.8)~\\text{W} + 0.36~\\text{W} = 2.187~\\text{W} + 0.36~\\text{W} = 2.547~\\text{W}$$\n\nFor State 3: $(V_3, f_3) = (1.1~\\text{V}, 2.4~\\text{GHz})$\n$$P_3 = (1.5 \\times 10^{-9}~\\text{F}) (1.1~\\text{V})^2 (2.4 \\times 10^9~\\text{Hz}) + (0.4~\\text{W/V})(1.1~\\text{V})$$\n$$P_3 = (1.5 \\times 1.21 \\times 2.4)~\\text{W} + 0.44~\\text{W} = 4.356~\\text{W} + 0.44~\\text{W} = 4.796~\\text{W}$$\n\nWe have the three operating points in the frequency-power plane: $(1.2~\\text{GHz}, 1.162~\\text{W})$, $(1.8~\\text{GHz}, 2.547~\\text{W})$, and $(2.4~\\text{GHz}, 4.796~\\text{W})$.\n\nThe principle of energy-optimal scheduling dictates that for a target average frequency $f_{\\text{avg}}$, one should time-share between the two operating points $(f_i, P_i)$ and $(f_j, P_j)$ that lie on the lower convex hull of the set of all operating points and satisfy $f_i \\le f_{\\text{avg}} \\le f_j$.\nTo determine the lower convex hull, we check if the point for State 2, $(f_2, P_2)$, lies below the line segment connecting State 1 and State 3.\nThe power on the line connecting $(f_1, P_1)$ and $(f_3, P_3)$ at frequency $f_2$ is:\n$$ P_{\\text{line}}(f_2) = P_1 + \\frac{P_3 - P_1}{f_3 - f_1}(f_2 - f_1) $$\n$$ P_{\\text{line}}(1.8) = 1.162 + \\frac{4.796 - 1.162}{2.4 - 1.2}(1.8 - 1.2) = 1.162 + \\frac{3.634}{1.2}(0.6) = 1.162 + 1.817 = 2.979~\\text{W} $$\nSince $P_2 = 2.547~\\text{W}$ is less than $P_{\\text{line}}(1.8) = 2.979~\\text{W}$, the point $(f_2, P_2)$ lies below the line segment. Thus, the lower convex hull is formed by the segments connecting State 1 to State 2, and State 2 to State 3.\n\nThe required average frequency is $f_{\\text{avg}} = W/D = (3.0 \\times 10^9) / 1.6 = 1.875~\\text{GHz}$.\nSince $f_2 = 1.8~\\text{GHz}  f_{\\text{avg}}  f_3 = 2.4~\\text{GHz}$, the energy-optimal strategy is to time-share exclusively between State 2 and State 3. This means we set $t_1=0$.\n\nThe constraints reduce to a system of two equations for $t_2$ and $t_3$:\n$$ t_2 + t_3 = 1.6 $$\n$$ (1.8 \\times 10^9) t_2 + (2.4 \\times 10^9) t_3 = 3.0 \\times 10^9 $$\nDividing the second equation by $10^9$ gives:\n$$ 1.8 t_2 + 2.4 t_3 = 3.0 $$\nFrom the first equation, $t_3 = 1.6 - t_2$. Substituting this into the second equation:\n$$ 1.8 t_2 + 2.4(1.6 - t_2) = 3.0 $$\n$$ 1.8 t_2 + 3.84 - 2.4 t_2 = 3.0 $$\n$$ -0.6 t_2 = 3.0 - 3.84 $$\n$$ -0.6 t_2 = -0.84 $$\n$$ t_2 = \\frac{0.84}{0.6} = 1.4~\\text{s} $$\nThen, the time in State 3 is:\n$$ t_3 = 1.6 - t_2 = 1.6 - 1.4 = 0.2~\\text{s} $$\nThe times are $t_1=0~\\text{s}$, $t_2=1.4~\\text{s}$, and $t_3=0.2~\\text{s}$, which are all non-negative.\n\nFinally, we calculate the minimum total energy using these optimal times:\n$$ E_{\\text{min}} = P_1 t_1 + P_2 t_2 + P_3 t_3 $$\n$$ E_{\\text{min}} = (1.162~\\text{W})(0~\\text{s}) + (2.547~\\text{W})(1.4~\\text{s}) + (4.796~\\text{W})(0.2~\\text{s}) $$\n$$ E_{\\text{min}} = 0 + 3.5658 + 0.9592 $$\n$$ E_{\\text{min}} = 4.525~\\text{J} $$\nThe problem requires the answer to be rounded to four significant figures. The calculated value $4.525$ already has four significant figures.",
            "answer": "$$\n\\boxed{4.525}\n$$"
        },
        {
            "introduction": "While theoretical models can determine optimal energy usage, real-world systems often employ adaptive heuristics that respond to a program's dynamic behavior. This problem  challenges you to analyze such a heuristic, where the processor's frequency is adjusted based on its memory stall activity. This exercise demonstrates the crucial link between workload characteristics and effective power management strategies, bridging the gap between theory and practical system design.",
            "id": "3666964",
            "problem": "A processor implements Dynamic Voltage and Frequency Scaling (DVFS) with two operating points. The dynamic power and leakage power at each operating point are known. For a given workload, the measured execution time at the maximum frequency and the fraction of that time spent stalled on memory accesses are known. Consider a simple controller: if the memory stall fraction exceeds a threshold, it runs the workload at the minimum frequency; otherwise, it runs at the maximum frequency. Your task is to compute the per-workload energy savings of this heuristic relative to always running at the maximum frequency, and report the average savings across a set of workloads.\n\nUse the following foundational principles and modeling assumptions as the starting point:\n- Energy is the time integral of power: $E=\\int P(t)\\,dt$. For a run at a fixed operating point, total energy is $E=P_{\\text{total}}\\cdot T$, where $T$ is the execution time in seconds and $P_{\\text{total}}$ is the total power in watts.\n- Total power is the sum of dynamic and leakage components: $P_{\\text{total}}=P_{\\text{dyn}}+P_{\\text{leak}}$.\n- The dynamic component scales with switching activity, which depends on frequency, and the leakage component depends on operating conditions. For the purpose of this problem, you are given $P_{\\text{dyn}}$ and $P_{\\text{leak}}$ at each operating point, so you should not derive them.\n- Execution time at a different frequency changes because the compute-bound portion scales inversely with frequency, whereas the memory-stall portion is dominated by off-core latency and is modeled as independent of core frequency (in seconds).\n\nDefinitions and variables:\n- Maximum frequency $f_{\\max}$ in hertz (Hz).\n- Minimum frequency $f_{\\min}$ in hertz (Hz).\n- Dynamic power at $f_{\\max}$: $P_{\\text{dyn},\\max}$ in watts (W).\n- Leakage power at $f_{\\max}$: $P_{\\text{leak},\\max}$ in watts (W).\n- Dynamic power at $f_{\\min}$: $P_{\\text{dyn},\\min}$ in watts (W).\n- Leakage power at $f_{\\min}$: $P_{\\text{leak},\\min}$ in watts (W).\n- For each workload $i$, the measured execution time at $f_{\\max}$ is $T_{\\max}^{(i)}$ in seconds (s), and the measured memory stall fraction at $f_{\\max}$ is $m^{(i)}$, where $m^{(i)}\\in[0,1]$ is the fraction of $T_{\\max}^{(i)}$ spent stalled on memory at $f_{\\max}$.\n- Heuristic controller: if $m^{(i)}0.5$, run at $f_{\\min}$; else, run at $f_{\\max}$.\n\nYou must derive from the principles above how to compute the execution time $T(f)$ at an arbitrary chosen frequency $f\\in\\{f_{\\max},f_{\\min}\\}$ by decomposing the $f_{\\max}$ execution time into compute-bound and memory-stall portions, scaling the compute-bound portion inversely with frequency, and keeping the memory-stall portion unchanged. Then compute energy $E(f)=P_{\\text{total}}(f)\\cdot T(f)$ at the chosen operating point and the baseline energy $E_{\\text{base}}=P_{\\text{total}}(f_{\\max})\\cdot T_{\\max}^{(i)}$. Finally, compute the savings as a decimal fraction $s^{(i)}=(E_{\\text{base}}-E_{\\text{heur}})/E_{\\text{base}}$ for each workload $i$.\n\nUnits:\n- Frequencies must be treated in hertz (Hz), times in seconds (s), powers in watts (W), and energies in joules (J).\n- Report savings as decimal fractions (unitless), not with a percent sign.\n\nOperating points and powers:\n- $f_{\\max}=3.0\\times 10^{9}$ Hz,\n- $f_{\\min}=1.2\\times 10^{9}$ Hz,\n- $P_{\\text{dyn},\\max}=30$ W, $P_{\\text{leak},\\max}=10$ W,\n- $P_{\\text{dyn},\\min}=8$ W, $P_{\\text{leak},\\min}=6$ W.\n\nTest suite of workloads:\n- Workload $1$: $T_{\\max}^{(1)}=1.0$ s, $m^{(1)}=0.2$.\n- Workload $2$: $T_{\\max}^{(2)}=1.0$ s, $m^{(2)}=0.8$.\n- Workload $3$: $T_{\\max}^{(3)}=0.5$ s, $m^{(3)}=0.5$.\n- Workload $4$: $T_{\\max}^{(4)}=2.0$ s, $m^{(4)}=1.0$.\n- Workload $5$: $T_{\\max}^{(5)}=0.2$ s, $m^{(5)}=0.0$.\n\nBoundary condition:\n- Use $f_{\\max}$ when $m^{(i)}=0.5$.\n\nProgramming task:\n- Implement a program that, for each workload $i$ in the test suite, computes the savings $s^{(i)}$ of the heuristic relative to always running at $f_{\\max}$, and then computes the average savings $\\bar{s}$ across all workloads.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order $[s^{(1)},s^{(2)},s^{(3)},s^{(4)},s^{(5)},\\bar{s}]$, where each value is rounded to exactly $6$ decimal places using standard rounding rules. For example, $[0.123456,0.234567,0.345678,0.456789,0.567890,0.345276]$.",
            "solution": "The problem requires computing the energy savings of a simple Dynamic Voltage and Frequency Scaling (DVFS) heuristic for a set of workloads. The solution is derived by first establishing mathematical models for execution time and energy based on the provided principles, and then applying these models to the specific workloads.\n\nFirst, we determine the total power consumption at each of the two operating points. The total power, $P_{\\text{total}}$, is the sum of its dynamic ($P_{\\text{dyn}}$) and leakage ($P_{\\text{leak}}$) components.\n\nAt the maximum frequency, $f_{\\max} = 3.0 \\times 10^9$ Hz:\n$$P_{\\text{total},\\max} = P_{\\text{dyn},\\max} + P_{\\text{leak},\\max} = 30 \\text{ W} + 10 \\text{ W} = 40 \\text{ W}$$\nAt the minimum frequency, $f_{\\min} = 1.2 \\times 10^9$ Hz:\n$$P_{\\text{total},\\min} = P_{\\text{dyn},\\min} + P_{\\text{leak},\\min} = 8 \\text{ W} + 6 \\text{ W} = 14 \\text{ W}$$\n\nNext, we model the execution time for a generic workload $i$. The given execution time at maximum frequency, $T_{\\max}^{(i)}$, is composed of a compute-bound portion, $T_{\\text{comp},\\max}^{(i)}$, and a memory-stall portion, $T_{\\text{stall},\\max}^{(i)}$. Given the memory stall fraction $m^{(i)}$, we have:\n$$T_{\\text{stall},\\max}^{(i)} = m^{(i)} \\cdot T_{\\max}^{(i)}$$\n$$T_{\\text{comp},\\max}^{(i)} = T_{\\max}^{(i)} - T_{\\text{stall},\\max}^{(i)} = (1 - m^{(i)}) \\cdot T_{\\max}^{(i)}$$\n\nAccording to the modeling assumptions, when the core frequency changes from $f_{\\text{ref}}$ to $f$, the compute-bound time scales inversely, while the memory-stall time remains constant in seconds. The total execution time at frequency $f$, denoted $T^{(i)}(f)$, is therefore:\n$$T^{(i)}(f) = T_{\\text{comp},\\max}^{(i)} \\cdot \\frac{f_{\\max}}{f} + T_{\\text{stall},\\max}^{(i)}$$\nSubstituting the expressions for the component times:\n$$T^{(i)}(f) = (1 - m^{(i)}) \\cdot T_{\\max}^{(i)} \\cdot \\frac{f_{\\max}}{f} + m^{(i)} \\cdot T_{\\max}^{(i)}$$\n$$T^{(i)}(f) = T_{\\max}^{(i)} \\left( (1 - m^{(i)}) \\frac{f_{\\max}}{f} + m^{(i)} \\right)$$\n\nThe baseline energy, $E_{\\text{base}}^{(i)}$, is the energy consumed when running at $f_{\\max}$ for the entire duration:\n$$E_{\\text{base}}^{(i)} = P_{\\text{total},\\max} \\cdot T_{\\max}^{(i)}$$\n\nThe energy under the heuristic, $E_{\\text{heur}}^{(i)}$, depends on the frequency $f_{\\text{heur}}^{(i)}$ chosen by the controller. The controller's rule is to use $f_{\\min}$ if $m^{(i)}  0.5$, and $f_{\\max}$ otherwise (i.e., if $m^{(i)} \\le 0.5$).\n$$E_{\\text{heur}}^{(i)} = P_{\\text{total}}(f_{\\text{heur}}^{(i)}) \\cdot T^{(i)}(f_{\\text{heur}}^{(i)})$$\n\nThe energy savings, $s^{(i)}$, is defined as the fractional reduction in energy relative to the baseline:\n$$s^{(i)} = \\frac{E_{\\text{base}}^{(i)} - E_{\\text{heur}}^{(i)}}{E_{\\text{base}}^{(i)}} = 1 - \\frac{E_{\\text{heur}}^{(i)}}{E_{\\text{base}}^{(i)}}$$\n\nWe analyze the savings based on the two cases of the heuristic:\n\nCase 1: Low Stall Fraction ($m^{(i)} \\le 0.5$)\nThe heuristic selects $f_{\\text{heur}}^{(i)} = f_{\\max}$. The execution time is $T^{(i)}(f_{\\max}) = T_{\\max}^{(i)}$, and the energy is $E_{\\text{heur}}^{(i)} = P_{\\text{total},\\max} \\cdot T_{\\max}^{(i)}$, which is identical to the baseline energy $E_{\\text{base}}^{(i)}$.\nTherefore, the savings are:\n$$s^{(i)} = 1 - \\frac{E_{\\text{base}}^{(i)}}{E_{\\text{base}}^{(i)}} = 0$$\n\nCase 2: High Stall Fraction ($m^{(i)}  0.5$)\nThe heuristic selects $f_{\\text{heur}}^{(i)} = f_{\\min}$. The execution time at this frequency is $T^{(i)}(f_{\\min}) = T_{\\max}^{(i)} \\left( (1 - m^{(i)}) \\frac{f_{\\max}}{f_{\\min}} + m^{(i)} \\right)$. The energy is $E_{\\text{heur}}^{(i)} = P_{\\text{total},\\min} \\cdot T^{(i)}(f_{\\min})$.\nSubstituting into the savings formula:\n$$s^{(i)} = 1 - \\frac{P_{\\text{total},\\min} \\cdot T_{\\max}^{(i)} \\left( (1 - m^{(i)}) \\frac{f_{\\max}}{f_{\\min}} + m^{(i)} \\right)}{P_{\\text{total},\\max} \\cdot T_{\\max}^{(i)}}$$\nThe $T_{\\max}^{(i)}$ term cancels, indicating the savings fraction depends only on the stall fraction $m^{(i)}$ and the system parameters, not the workload's initial runtime:\n$$s^{(i)} = 1 - \\frac{P_{\\text{total},\\min}}{P_{\\text{total},\\max}} \\left( (1 - m^{(i)}) \\frac{f_{\\max}}{f_{\\min}} + m^{(i)} \\right)$$\n\nWe now substitute the numerical values. The key ratios are:\n- Frequency ratio: $\\frac{f_{\\max}}{f_{\\min}} = \\frac{3.0 \\times 10^9}{1.2 \\times 10^9} = 2.5$\n- Total power ratio: $\\frac{P_{\\text{total},\\min}}{P_{\\text{total},\\max}} = \\frac{14 \\text{ W}}{40 \\text{ W}} = 0.35$\n\nThe savings formula for $m^{(i)}  0.5$ becomes:\n$$s^{(i)} = 1 - 0.35 \\left( (1 - m^{(i)}) \\cdot 2.5 + m^{(i)} \\right) = 1 - 0.35 (2.5 - 2.5 m^{(i)} + m^{(i)}) = 1 - 0.35 (2.5 - 1.5 m^{(i)})$$\n\nCalculations for each workload:\n- Workload 1: $m^{(1)} = 0.2$. Since $0.2 \\le 0.5$, $s^{(1)} = 0$.\n- Workload 2: $m^{(2)} = 0.8$. Since $0.8  0.5$, we use the formula:\n  $s^{(2)} = 1 - 0.35 (2.5 - 1.5 \\cdot 0.8) = 1 - 0.35 (2.5 - 1.2) = 1 - 0.35(1.3) = 1 - 0.455 = 0.545$.\n- Workload 3: $m^{(3)} = 0.5$. Since $0.5 \\le 0.5$, $s^{(3)} = 0$.\n- Workload 4: $m^{(4)} = 1.0$. Since $1.0  0.5$:\n  $s^{(4)} = 1 - 0.35 (2.5 - 1.5 \\cdot 1.0) = 1 - 0.35 (1.0) = 0.65$.\n- Workload 5: $m^{(5)} = 0.0$. Since $0.0 \\le 0.5$, $s^{(5)} = 0$.\n\nThe individual savings are $s^{(1)}=0.0$, $s^{(2)}=0.545$, $s^{(3)}=0.0$, $s^{(4)}=0.65$, and $s^{(5)}=0.0$.\n\nFinally, we compute the average savings, $\\bar{s}$, across the $N=5$ workloads:\n$$\\bar{s} = \\frac{1}{N} \\sum_{i=1}^{N} s^{(i)} = \\frac{0.0 + 0.545 + 0.0 + 0.65 + 0.0}{5} = \\frac{1.195}{5} = 0.239$$\n\nThese computed values will be implemented in the C program and formatted to $6$ decimal places as required.",
            "answer": "```c\n#include stdio.h\n#include stdlib.h\n#include string.h\n#include math.h\n\n// A struct to hold the parameters for a single workload test case.\ntypedef struct {\n    double t_max;  // Execution time at f_max in seconds.\n    double m_frac; // Memory stall fraction at f_max.\n} TestCase;\n\nint main(void) {\n    // Define the fixed operating point parameters.\n    const double F_MAX = 3.0e9; // Hz\n    const double F_MIN = 1.2e9; // Hz\n    const double P_DYN_MAX = 30.0; // W\n    const double P_LEAK_MAX = 10.0; // W\n    const double P_DYN_MIN = 8.0; // W\n    const double P_LEAK_MIN = 6.0; // W\n    \n    // Heuristic threshold for memory stall fraction.\n    const double STALL_THRESHOLD = 0.5;\n\n    // Define the test suite of workloads.\n    TestCase test_cases[] = {\n        {1.0, 0.2}, // Workload 1\n        {1.0, 0.8}, // Workload 2\n        {0.5, 0.5}, // Workload 3\n        {2.0, 1.0}, // Workload 4\n        {0.2, 0.0}  // Workload 5\n    };\n\n    // Calculate the number of test cases.\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    double results[num_cases];\n    double sum_of_savings = 0.0;\n\n    // Pre-calculate derived constants for the energy savings model.\n    const double P_TOTAL_MAX = P_DYN_MAX + P_LEAK_MAX;\n    const double P_TOTAL_MIN = P_DYN_MIN + P_LEAK_MIN;\n    const double FREQ_RATIO = F_MAX / F_MIN;\n    const double POWER_RATIO_MIN_TO_MAX = P_TOTAL_MIN / P_TOTAL_MAX;\n\n    // Calculate the savings for each test case.\n    for (int i = 0; i  num_cases; ++i) {\n        double m = test_cases[i].m_frac;\n        double current_savings;\n\n        // Apply the heuristic: if stall fraction  0.5, switch to f_min.\n        // Otherwise, stay at f_max (zero savings).\n        if (m  STALL_THRESHOLD) {\n            // Savings = 1 - (E_heur / E_base)\n            // E_heur / E_base simplifies to a ratio of powers and a time scaling factor.\n            // Time scaling factor = ( (1-m)*FREQ_RATIO + m )\n            double time_scaling_factor = (1.0 - m) * FREQ_RATIO + m;\n            double energy_ratio = POWER_RATIO_MIN_TO_MAX * time_scaling_factor;\n            current_savings = 1.0 - energy_ratio;\n        } else {\n            // If the heuristic keeps the frequency at f_max,\n            // the energy is the same as the baseline, so savings are 0.\n            current_savings = 0.0;\n        }\n        \n        results[i] = current_savings;\n        sum_of_savings += current_savings;\n    }\n\n    // Calculate the average savings.\n    double average_savings = sum_of_savings / num_cases;\n\n    // Print the results in the EXACT REQUIRED format before the final return statement.\n    printf(\"[%.6f,%.6f,%.6f,%.6f,%.6f,%.6f]\\n\", \n           results[0], \n           results[1], \n           results[2], \n           results[3], \n           results[4], \n           average_savings);\n\n    return EXIT_SUCCESS;\n}\n```"
        }
    ]
}