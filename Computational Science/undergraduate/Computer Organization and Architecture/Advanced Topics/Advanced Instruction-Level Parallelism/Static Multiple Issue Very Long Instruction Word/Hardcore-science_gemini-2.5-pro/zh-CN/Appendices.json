{
    "hands_on_practices": [
        {
            "introduction": "VLIW 架构的核心在于编译器如何智能地将指令打包到指令束中。这个练习将带你亲身体验静态调度的基本挑战，通过处理功能单元的资源限制和多周期操作的占用约束，你将理解为何一个简单的、贪婪的调度策略是远远不够的。通过对比一个有效调度和一个会产生冲突的“天真”调度，本练习将揭示 VLIW 编译器精密工作的本质。",
            "id": "3681276",
            "problem": "考虑一个静态调度的超长指令字（VLIW）处理器，每个周期发射一个指令包。该指令包有四个类型化槽位：两个整数算术逻辑单元槽位 $S_{\\text{ALU},0}$ 和 $S_{\\text{ALU},1}$，一个乘法槽位 $S_{\\text{MUL}}$，以及一个内存槽位 $S_{\\text{MEM}}$。每条指令必须放置在一个指令包中，并精确地对应一个与其类型匹配的槽位。假设以下被广泛接受的基本事实和约束：\n- 静态多发射调度必须遵守真数据依赖：如果一条延迟为 $L$ 的指令产生了一个被其消费者指令使用的值，并且它在周期 $c$ 发射，那么其消费者指令最早只能在周期 $c + L$ 发射。\n- 必须遵守功能单元占用约束：当一条指令被发射到占用时间为 $O_s$ 的槽位 $s$ 时，从发射周期算起，该槽位在 $O_s$ 个连续周期内不能再发射其他指令。这包括占用时间跨越多个周期的多周期操作。\n- 整数加法的延迟为 $L_{\\text{ADD}} = 1$，占用其 ALU 槽位 $O_{\\text{ALU}} = 1$ 个周期。\n- 乘法的延迟为 $L_{\\text{MUL}} = 3$，占用 $S_{\\text{MUL}}$ 槽位 $O_{\\text{MUL}} = L_{\\text{MUL}}$ 个周期。\n- 加载指令的延迟为 $L_{\\text{LD}} = 2$，占用 $S_{\\text{MEM}}$ 槽位 $O_{\\text{MEM}} = 1$ 个周期。\n- 存储指令的延迟为 $L_{\\text{ST}} = 1$，占用 $S_{\\text{MEM}}$ 槽位 $O_{\\text{MEM}} = 1$ 个周期。\n\n待调度的程序是以下序列（除非声明了依赖关系，否则所用寄存器均不相同）：\n- $I_{1}$: $\\text{LD } r_{1} \\leftarrow [r_{A}]$。\n- $I_{2}$: $\\text{LD } r_{2} \\leftarrow [r_{B}]$。\n- $I_{3}$: $\\text{MUL } r_{3} \\leftarrow r_{1} \\times r_{2}$，依赖于 $I_{1}$ 和 $I_{2}$。\n- $I_{4}$: $\\text{ADD } r_{4} \\leftarrow r_{3} + r_{C}$，依赖于 $I_{3}$。\n- $I_{5}$: $\\text{MUL } r_{5} \\leftarrow r_{4} \\times r_{D}$，依赖于 $I_{4}$。\n- $I_{6}$: $\\text{ADD } r_{6} \\leftarrow r_{5} + r_{E}$，依赖于 $I_{5}$。\n- $I_{7}$: $\\text{MUL } r_{7} \\leftarrow r_{6} \\times r_{F}$，依赖于 $I_{6}$。\n- $I_{8}$: $\\text{ADD } r_{8} \\leftarrow r_{7} + r_{G}$，依赖于 $I_{7}$。\n- $I_{9}$: $\\text{ST } [r_{H}] \\leftarrow r_{8}$，依赖于 $I_{8}$。\n- $I_{10}$: $\\text{ADD } r_{10} \\leftarrow r_{11} + r_{12}$，无依赖。\n- $I_{11}$: $\\text{ADD } r_{13} \\leftarrow r_{14} + r_{15}$，无依赖。\n- $I_{12}$: $\\text{ADD } r_{16} \\leftarrow r_{17} + r_{18}$，无依赖。\n- $I_{13}$: $\\text{ADD } r_{19} \\leftarrow r_{20} + r_{21}$，无依赖。\n\n任务：\n- 首先，设计一个无冲突的静态调度，该调度遵守上述的数据依赖延迟和槽位占用约束。你可以假设每个周期发射一个指令包，并且可以机会性地将独立的 $\\text{ADD}$ 指令放置到可用的 $S_{\\text{ALU},0}$ 和 $S_{\\text{ALU},1}$ 槽位中，以填充它们，且不违反任何约束。\n- 其次，考虑一个天真的指令包打包策略，该策略忽略所有延迟和占用约束，只是简单地在每个周期按程序顺序取最多4条指令，并将它们按类型映射到匹配的槽位中（$\\text{LD}/\\text{ST} \\rightarrow S_{\\text{MEM}}$，$\\text{MUL} \\rightarrow S_{\\text{MUL}}$，$\\text{ADD} \\rightarrow S_{\\text{ALU},0}$ 或 $S_{\\text{ALU},1}$）。定义一个指令包冲突：在给定周期，当天真策略试图将一条指令分配到一个在该周期内因先前指令占用同一槽位而不可用的槽位时，就发生冲突（包括在同一周期内对 $S_{\\text{MEM}}$ 或 $S_{\\text{ALU},k}$ 的并发超额分配，或跨周期对 $S_{\\text{MUL}}$ 的多周期占用）。计算此天真策略对整个程序序列将产生的指令包冲突总数。\n\n仅提供指令包冲突的总数作为你的最终答案。无需四舍五入。",
            "solution": "问题要求计算在一个 VLIW 处理器上，对于给定的指令序列，采用一种天真的指令包打包策略所产生的指令包冲突总数。指令包冲突被定义为：天真策略试图将一条指令分配到一个不可用的槽位，该槽位不可用的原因可能是在同一周期内的并发分配（超额分配），也可能是由于前一个周期的指令对该槽位造成了多周期占用。\n\n该 VLIW 处理器每个指令包有四个槽位：两个整数 ALU 槽位（$S_{\\text{ALU},0}$, $S_{\\text{ALU},1}$）、一个乘法槽位（$S_{\\text{MUL}}$）和一个内存槽位（$S_{\\text{MEM}}$）。天真策略通过在每个周期按程序顺序取最多四条指令，并将它们映射到相应类型的槽位来形成指令包。对于 ALU 指令，该策略将首先填充 $S_{\\text{ALU},0}$，然后填充 $S_{\\text{ALU},1}$。\n\n我们将逐周期分析调度过程，跟踪每个槽位的占用情况，并在冲突发生时进行计数。令 $F_s$ 为槽位 $s$ 变为空闲的第一个周期。初始时，在周期 $C=1$，所有槽位都可用，因此对于所有槽位 $s$，$F_s = 1$。\n\n指令序列如下：\n- $I_1$: LD (MEM)\n- $I_2$: LD (MEM)\n- $I_3$: MUL (MUL)\n- $I_4$: ADD (ALU)\n- $I_5$: MUL (MUL)\n- $I_6$: ADD (ALU)\n- $I_7$: MUL (MUL)\n- $I_8$: ADD (ALU)\n- $I_9$: ST (MEM)\n- $I_{10}$: ADD (ALU)\n- $I_{11}$: ADD (ALU)\n- $I_{12}$: ADD (ALU)\n- $I_{13}$: ADD (ALU)\n\n**周期 $1$**\n\n第一个指令包由指令 $I_1, I_2, I_3, I_4$ 组成。\n- $C=1$ 时的初始槽位可用性：\n  - $F_{\\text{ALU},0} = 1$\n  - $F_{\\text{ALU},1} = 1$\n  - $F_{\\text{MUL}} = 1$\n  - $F_{\\text{MEM}} = 1$\n\n- 天真策略的分配尝试：\n  - $I_1$ (LD) 目标为 $S_{\\text{MEM}}$。该槽位可用（$F_{\\text{MEM}} \\le 1$）。\n  - $I_2$ (LD) 目标为 $S_{\\text{MEM}}$。由于 $I_1$ 的同时分配，该槽位不可用。这是一个资源超额分配。这构成 **$1$ 个冲突**。\n  - $I_3$ (MUL) 目标为 $S_{\\text{MUL}}$。该槽位可用（$F_{\\text{MUL}} \\le 1$）。\n  - $I_4$ (ADD) 目标为 $S_{\\text{ALU},0}$。该槽位可用（$F_{\\text{ALU},0} \\le 1$）。\n\n- 周期 1 的总冲突数：$1$。\n\n- 更新下一周期的槽位占用情况，假设未发生冲突的指令被发射。\n  - $I_1$ 在 $S_{\\text{MEM}}$ 中发射（$O_{\\text{MEM}}=1$）。新的 $F_{\\text{MEM}} = 1 + 1 = 2$。\n  - $I_3$ 在 $S_{\\text{MUL}}$ 中发射（$O_{\\text{MUL}}=3$）。新的 $F_{\\text{MUL}} = 1 + 3 = 4$。\n  - $I_4$ 在 $S_{\\text{ALU},0}$ 中发射（$O_{\\text{ALU}}=1$）。新的 $F_{\\text{ALU},0} = 1 + 1 = 2$。\n  - $S_{\\text{ALU},1}$ 仍未使用。$F_{\\text{ALU},1} = 1$。\n\n**周期 $2$**\n\n下一个指令包由指令 $I_5, I_6, I_7, I_8$ 组成。\n- $C=2$ 时的槽位可用性：\n  - $F_{\\text{ALU},0} = 2$ (可用)\n  - $F_{\\text{ALU},1} = 1$ (可用)\n  - $F_{\\text{MUL}} = 4$ (不可用，被 $I_3$ 占用)\n  - $F_{\\text{MEM}} = 2$ (可用)\n\n- 天真策略的分配尝试：\n  - $I_5$ (MUL) 目标为 $S_{\\text{MUL}}$。该槽位不可用，因为 $F_{\\text{MUL}} = 4 > 2$。这构成 **$1$ 个冲突**。\n  - $I_6$ (ADD) 目标为 $S_{\\text{ALU},0}$。该槽位可用（$F_{\\text{ALU},0} \\le 2$）。\n  - $I_7$ (MUL) 目标为 $S_{\\text{MUL}}$。该槽位不可用，因为 $F_{\\text{MUL}} = 4 > 2$。这是一个独立的、试图使用不可用槽位的尝试。这构成另外 **$1$ 个冲突**。\n  - $I_8$ (ADD) 目标为 $S_{\\text{ALU},1}$（指令包中的第二条 ADD）。该槽位可用（$F_{\\text{ALU},1} \\le 2$）。\n\n- 周期 2 的总冲突数：$2$。\n\n- 更新槽位占用情况：\n  - $I_6$ 在 $S_{\\text{ALU},0}$ 中发射（$O_{\\text{ALU}}=1$）。新的 $F_{\\text{ALU},0} = 2 + 1 = 3$。\n  - $I_8$ 在 $S_{\\text{ALU},1}$ 中发射（$O_{\\text{ALU}}=1$）。新的 $F_{\\text{ALU},1} = 2 + 1 = 3$。\n  - $S_{\\text{MUL}}$ 仍被 $I_3$ 占用。$F_{\\text{MUL}}$ 仍然是 $4$。\n\n**周期 $3$**\n\n下一个指令包由指令 $I_9, I_{10}, I_{11}, I_{12}$ 组成。\n- $C=3$ 时的槽位可用性：\n  - $F_{\\text{ALU},0} = 3$ (可用)\n  - $F_{\\text{ALU},1} = 3$ (可用)\n  - $F_{\\text{MUL}} = 4$ (不可用)\n  - $F_{\\text{MEM}} = 2$ (可用)\n\n- 天真策略的分配尝试：\n  - $I_9$ (ST) 目标为 $S_{\\text{MEM}}$。该槽位可用（$F_{\\text{MEM}} \\le 3$）。\n  - $I_{10}$ (ADD) 目标为 $S_{\\text{ALU},0}$。该槽位可用（$F_{\\text{ALU},0} \\le 3$）。\n  - $I_{11}$ (ADD) 目标为 $S_{\\text{ALU},1}$。该槽位可用（$F_{\\text{ALU},1} \\le 3$）。\n  - $I_{12}$ (ADD) 是第三条 ALU 类型的指令。天真策略试图将其映射到一个 ALU 槽位。然而，在同一周期内，$S_{\\text{ALU},0}$ 和 $S_{\\text{ALU},1}$ 已经成为 $I_{10}$ 和 $I_{11}$ 的目标。这是对 ALU 槽位的超额分配。这构成 **$1$ 个冲突**。\n\n- 周期 3 的总冲突数：$1$。\n\n- 更新槽位占用情况：\n  - $I_9$ 在 $S_{\\text{MEM}}$ 中发射（$O_{\\text{MEM}}=1$）。新的 $F_{\\text{MEM}} = 3 + 1 = 4$。\n  - $I_{10}$ 在 $S_{\\text{ALU},0}$ 中发射（$O_{\\text{ALU}}=1$）。新的 $F_{\\text{ALU},0} = 3 + 1 = 4$。\n  - $I_{11}$ 在 $S_{\\text{ALU},1}$ 中发射（$O_{\\text{ALU}}=1$）。新的 $F_{\\text{ALU},1} = 3 + 1 = 4$。\n  - $S_{\\text{MUL}}$ 仍被占用。$F_{\\text{MUL}}$ 仍然是 $4$。\n\n**周期 $4$**\n\n最后一个指令包由最后一条指令 $I_{13}$ 组成。\n- $C=4$ 时的槽位可用性：\n  - $F_{\\text{ALU},0} = 4$ (可用)\n  - $F_{\\text{ALU},1} = 4$ (可用)\n  - $F_{\\text{MUL}} = 4$ (可用)\n  - $F_{\\text{MEM}} = 4$ (可用)\n\n- 天真策略的分配尝试：\n  - $I_{13}$ (ADD) 目标为 $S_{\\text{ALU},0}$。该槽位可用（$F_{\\text{ALU},0} \\le 4$）。无冲突。\n\n- 周期 4 的总冲突数：$0$。\n\n**总冲突数**\n\n将每个周期的冲突数相加：\n总冲突数 = (周期 1 的冲突数) + (周期 2 的冲突数) + (周期 3 的冲突数) + (周期 4 的冲突数)\n总冲突数 = $1 + 2 + 1 + 0 = 4$。\n\n天真的指令包打包策略将导致总共 $4$ 个指令包冲突。",
            "answer": "$$\\boxed{4}$$"
        },
        {
            "introduction": "在掌握了基本的调度机制后，我们来探讨一个更高级的主题：编译器如何在不确定性中做出最优决策。本练习模拟了一个真实的编译器困境——处理可能发生别名的内存加载操作，这在并行化时可能导致昂贵的惩罚。你将运用期望值分析来量化并行执行与顺序执行之间的性能权衡，并确定一个关键的“别名概率”阈值，超过该阈值，保守的策略将变得更优。",
            "id": "3681231",
            "problem": "一个超长指令字（VLIW）处理器（Very Long Instruction Word (VLIW)）可以在同一个指令包中最多发射 $2$ 个内存操作。考虑两个加载操作 $L_1$ 和 $L_2$，它们的有效地址可能以概率 $a \\in [0,1]$ 发生地址冲突（aliasing）。如果 $L_1$ 和 $L_2$ 被放置在同一个包中并且它们发生地址冲突，微架构会检测到同地址冲突，并对该包的完成时间施加一个 $r = 6$ 个周期的确定性重放惩罚。如果这两个加载操作不在同一个周期内发射，则不会产生此惩罚。加载延迟是独立的随机变量，其分布如下：\n- $L_1$ 的延迟为 $\\ell_1 = 3$ 个周期的概率为 $2/3$，延迟为 $\\ell_1 = 11$ 个周期的概率为 $1/3$。\n- $L_2$ 的延迟为 $\\ell_2 = 5$ 个周期的概率为 $1/2$，延迟为 $\\ell_2 = 9$ 个周期的概率为 $1/2$。\n\n假设基于流水线时序的核心定义，采用以下完成时间模型：\n- 如果两个操作在同一个周期内发射，包的完成时间为 $\\max(\\ell_1,\\ell_2)$，当且仅当发生地址冲突时，再加上重放惩罚 $r$。\n- 如果 $L_1$ 在周期 $0$ 发射，$L_2$ 在周期 $1$ 发射（它们之间有一个单周期的栅栏或“停顿”），完成时间为 $\\max(\\ell_1,\\,1+\\ell_2)$。\n- 如果 $L_2$ 在周期 $0$ 发射，$L_1$ 在周期 $1$ 发射，完成时间为 $\\max(\\ell_2,\\,1+\\ell_1)$。\n\n您必须在三个选项中选择一个静态调度方案：并行发射（同一包）、错开发射且 $L_1$ 优先，或错开发射且 $L_2$ 优先。仅使用期望值的基本定义和给定的时序模型，推导出每个调度方案的期望完成周期，其中并行情况是关于 $a$ 的函数，而错开情况是常数。然后，通过比较这些期望值，确定临界地址冲突概率 $a^{\\star}$，在该概率下，最优静态选择对于并行发射和最佳的单周期错开顺序是无差异的。\n\n将 $a^{\\star}$ 的最终答案表示为精确分数。无需四舍五入。",
            "solution": "用户希望我解决以下问题：\n一个超长指令字（VLIW）处理器可以在同一个指令包中最多发射 $2$ 个内存操作。考虑两个加载操作 $L_1$ 和 $L_2$，它们的有效地址可能以概率 $a \\in [0,1]$ 发生地址冲突。如果 $L_1$ 和 $L_2$ 被放置在同一个包中并且它们发生地址冲突，微架构会检测到同地址冲突，并对该包的完成时间施加一个 $r = 6$ 个周期的确定性重放惩罚。如果这两个加载操作不在同一个周期内发射，则不会产生此惩罚。加载延迟是独立的随机变量，其分布如下：\n- $L_1$ 的延迟为 $\\ell_1 = 3$ 个周期的概率为 $2/3$，延迟为 $\\ell_1 = 11$ 个周期的概率为 $1/3$。\n- $L_2$ 的延迟为 $\\ell_2 = 5$ 个周期的概率为 $1/2$，延迟为 $\\ell_2 = 9$ 个周期的概率为 $1/2$。\n\n假设基于流水线时序的核心定义，采用以下完成时间模型：\n- 如果两个操作在同一个周期内发射，包的完成时间为 $\\max(\\ell_1,\\ell_2)$，当且仅当发生地址冲突时，再加上重放惩罚 $r$。\n- 如果 $L_1$ 在周期 $0$ 发射，$L_2$ 在周期 $1$ 发射（它们之间有一个单周期的栅栏或“停顿”），完成时间为 $\\max(\\ell_1,\\,1+\\ell_2)$。\n- 如果 $L_2$ 在周期 $0$ 发射，$L_1$ 在周期 $1$ 发射，完成时间为 $\\max(\\ell_2,\\,1+\\ell_1)$。\n\n我必须在三个选项中选择一个静态调度方案：并行发射（同一包）、错开发射且 $L_1$ 优先，或错开发射且 $L_2$ 优先。仅使用期望值的基本定义和给定的时序模型，我必须推导出每个调度方案的期望完成周期，其中并行情况是关于 $a$ 的函数，而错开情况是常数。然后，通过比较这些期望值，我将确定临界地址冲突概率 $a^{\\star}$，在该概率下，最优静态选择对于并行发射和最佳的单周期错开顺序是无差异的。\n\n### 步骤 1：提取已知条件\n- VLIW 处理器可以在每个指令包中最多发射 $2$ 个内存操作。\n- 两个加载操作，$L_1$ 和 $L_2$。\n- 地址冲突概率：$a \\in [0,1]$。\n- 同一包内发生地址冲突的重放惩罚：$r = 6$ 个周期。\n- $L_1$ 的延迟：$\\ell_1$ 是一个随机变量。$P(\\ell_1=3) = 2/3$，$P(\\ell_1=11) = 1/3$。\n- $L_2$ 的延迟：$\\ell_2$ 是一个随机变量。$P(\\ell_2=5) = 1/2$，$P(\\ell_2=9) = 1/2$。\n- 延迟 $\\ell_1$ 和 $\\ell_2$ 是独立的。\n- 完成时间模型：\n  - 并行发射（同一包）：$T_{\\text{par}} = \\max(\\ell_1, \\ell_2) + p$，其中如果发生地址冲突（概率为 $a$），$p=r$；否则 $p=0$。\n  - 错开发射，$L_1$ 优先：$T_{\\text{stag},1} = \\max(\\ell_1, 1+\\ell_2)$。\n  - 错开发射，$L_2$ 优先：$T_{\\text{stag},2} = \\max(\\ell_2, 1+\\ell_1)$。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题具有科学依据，是计算机体系结构中一个标准的性能分析问题。该问题定义明确，具有清晰定义的随机变量、总和为 $1$ 的概率以及明确的时序模型。问题是自包含且客观的。没有矛盾、歧义或信息缺失。该问题是有效的。\n\n### 步骤 3：结论与行动\n问题是有效的。我将继续进行解答。\n\n解决方案需要计算三种调度选项中每一种的期望完成时间。离散随机变量 $X$ 的期望值由 $E[X] = \\sum_i x_i P(X=x_i)$ 给出。\n\n**1. 并行发射的期望完成时间 ($E[T_{\\text{par}}]$)**\n\n并行调度的完成时间在没有地址冲突时（概率为 $1-a$）为 $T_{\\text{par}} = \\max(\\ell_1, \\ell_2)$，在有地址冲突时（概率为 $a$）为 $T_{\\text{par}} = \\max(\\ell_1, \\ell_2) + r$。\n使用全期望定律，期望完成时间为：\n$$E[T_{\\text{par}}] = E[\\max(\\ell_1, \\ell_2)] \\cdot (1-a) + E[\\max(\\ell_1, \\ell_2) + r] \\cdot a$$\n$$E[T_{\\text{par}}] = E[\\max(\\ell_1, \\ell_2)] - a \\cdot E[\\max(\\ell_1, \\ell_2)] + a \\cdot E[\\max(\\ell_1, \\ell_2)] + a \\cdot r$$\n$$E[T_{\\text{par}}] = E[\\max(\\ell_1, \\ell_2)] + a \\cdot r$$\n我们首先需要计算 $E[\\max(\\ell_1, \\ell_2)]$。由于 $\\ell_1$ 和 $\\ell_2$ 是独立的，我们可以列举出 $(\\ell_1, \\ell_2)$ 对的四种可能结果：\n- $(\\ell_1, \\ell_2) = (3, 5)$: $P = P(\\ell_1=3)P(\\ell_2=5) = \\frac{2}{3} \\cdot \\frac{1}{2} = \\frac{1}{3}$。$\\max(3,5)=5$。\n- $(\\ell_1, \\ell_2) = (3, 9)$: $P = P(\\ell_1=3)P(\\ell_2=9) = \\frac{2}{3} \\cdot \\frac{1}{2} = \\frac{1}{3}$。$\\max(3,9)=9$。\n- $(\\ell_1, \\ell_2) = (11, 5)$: $P = P(\\ell_1=11)P(\\ell_2=5) = \\frac{1}{3} \\cdot \\frac{1}{2} = \\frac{1}{6}$。$\\max(11,5)=11$。\n- $(\\ell_1, \\ell_2) = (11, 9)$: $P = P(\\ell_1=11)P(\\ell_2=9) = \\frac{1}{3} \\cdot \\frac{1}{2} = \\frac{1}{6}$。$\\max(11,9)=11$。\n\n最大值的期望值为：\n$$E[\\max(\\ell_1, \\ell_2)] = 5 \\cdot \\frac{1}{3} + 9 \\cdot \\frac{1}{3} + 11 \\cdot \\frac{1}{6} + 11 \\cdot \\frac{1}{6} = \\frac{5}{3} + \\frac{9}{3} + \\frac{11+11}{6} = \\frac{14}{3} + \\frac{22}{6} = \\frac{14}{3} + \\frac{11}{3} = \\frac{25}{3}$$\n将此结果代入 $E[T_{\\text{par}}]$ 的表达式中，其中 $r=6$：\n$$E[T_{\\text{par}}] = \\frac{25}{3} + a \\cdot 6 = 6a + \\frac{25}{3}$$\n\n**2. 错开发射（$L_1$ 优先）的期望完成时间 ($E[T_{\\text{stag},1}]$)**\n\n此调度的完成时间为 $T_{\\text{stag},1} = \\max(\\ell_1, 1+\\ell_2)$。没有地址冲突惩罚。我们通过考虑 $\\ell_1$ 和 $1+\\ell_2$ 的联合分布来计算期望值 $E[\\max(\\ell_1, 1+\\ell_2)]$。\n- $(\\ell_1, 1+\\ell_2) = (3, 1+5) = (3, 6)$: $P = \\frac{1}{3}$。$\\max(3,6)=6$。\n- $(\\ell_1, 1+\\ell_2) = (3, 1+9) = (3, 10)$: $P = \\frac{1}{3}$。$\\max(3,10)=10$。\n- $(\\ell_1, 1+\\ell_2) = (11, 1+5) = (11, 6)$: $P = \\frac{1}{6}$。$\\max(11,6)=11$。\n- $(\\ell_1, 1+\\ell_2) = (11, 1+9) = (11, 10)$: $P = \\frac{1}{6}$。$\\max(11,10)=11$。\n\n期望完成时间为：\n$$E[T_{\\text{stag},1}] = 6 \\cdot \\frac{1}{3} + 10 \\cdot \\frac{1}{3} + 11 \\cdot \\frac{1}{6} + 11 \\cdot \\frac{1}{6} = \\frac{6+10}{3} + \\frac{11+11}{6} = \\frac{16}{3} + \\frac{22}{6} = \\frac{16}{3} + \\frac{11}{3} = \\frac{27}{3} = 9$$\n\n**3. 错开发射（$L_2$ 优先）的期望完成时间 ($E[T_{\\text{stag},2}]$)**\n\n此调度的完成时间为 $T_{\\text{stag},2} = \\max(\\ell_2, 1+\\ell_1)$。我们通过考虑 $\\ell_2$ 和 $1+\\ell_1$ 的联合分布来计算期望值 $E[\\max(\\ell_2, 1+\\ell_1)]$。\n- $(\\ell_2, 1+\\ell_1) = (5, 1+3) = (5, 4)$: $P = P(\\ell_2=5)P(\\ell_1=3) = \\frac{1}{2} \\cdot \\frac{2}{3} = \\frac{1}{3}$。$\\max(5,4)=5$。\n- $(\\ell_2, 1+\\ell_1) = (5, 1+11) = (5, 12)$: $P = P(\\ell_2=5)P(\\ell_1=11) = \\frac{1}{2} \\cdot \\frac{1}{3} = \\frac{1}{6}$。$\\max(5,12)=12$。\n- $(\\ell_2, 1+\\ell_1) = (9, 1+3) = (9, 4)$: $P = P(\\ell_2=9)P(\\ell_1=3) = \\frac{1}{2} \\cdot \\frac{2}{3} = \\frac{1}{3}$。$\\max(9,4)=9$。\n- $(\\ell_2, 1+\\ell_1) = (9, 1+11) = (9, 12)$: $P = P(\\ell_2=9)P(\\ell_1=11) = \\frac{1}{2} \\cdot \\frac{1}{3} = \\frac{1}{6}$。$\\max(9,12)=12$。\n\n期望完成时间为：\n$$E[T_{\\text{stag},2}] = 5 \\cdot \\frac{1}{3} + 12 \\cdot \\frac{1}{6} + 9 \\cdot \\frac{1}{3} + 12 \\cdot \\frac{1}{6} = \\frac{5+9}{3} + \\frac{12+12}{6} = \\frac{14}{3} + \\frac{24}{6} = \\frac{14}{3} + 4 = \\frac{14}{3} + \\frac{12}{3} = \\frac{26}{3}$$\n\n**4. 确定临界地址冲突概率 ($a^{\\star}$)**\n\n问题要求的是并行调度与*最佳*错开调度等效时的概率 $a^{\\star}$。我们必须首先通过比较它们的恒定期望完成时间来确定最佳的错开调度方案。\n$$E[T_{\\text{stag},1}] = 9 = \\frac{27}{3}$$\n$$E[T_{\\text{stag},2}] = \\frac{26}{3}$$\n由于 $\\frac{26}{3} < \\frac{27}{3}$，最佳的错开调度是先发射 $L_2$，其期望完成时间为 $E[T_{\\text{stag,best}}] = \\frac{26}{3}$。\n\n临界概率 $a^{\\star}$ 是指并行调度的期望完成时间等于最佳错开调度的期望完成时间时的 $a$ 值。\n$$E[T_{\\text{par}}] = E[T_{\\text{stag,best}}]$$\n$$6a^{\\star} + \\frac{25}{3} = \\frac{26}{3}$$\n现在，我们求解 $a^{\\star}$：\n$$6a^{\\star} = \\frac{26}{3} - \\frac{25}{3}$$\n$$6a^{\\star} = \\frac{1}{3}$$\n$$a^{\\star} = \\frac{1}{3 \\cdot 6}$$\n$$a^{\\star} = \\frac{1}{18}$$\n在此概率下，静态调度器对于并行发射加载或以 $L_2$ 优先的方式错开发射加载是无差异的。当 $a < a^{\\star}$ 时，并行调度是最佳的。当 $a > a^{\\star}$ 时，错开调度是最佳的。",
            "answer": "$$\\boxed{\\frac{1}{18}}$$"
        },
        {
            "introduction": "对于循环密集型代码，软件流水线是发挥 VLIW 处理器性能的关键。这个综合性练习将引导你完成一个完整的优化过程：首先通过循环不变代码外提来减少冗余计算，然后应用模调度技术来最小化循环启动间隔（$II$），从而最大化吞吐率。通过这个过程，你不仅能体验到如何显著提升循环性能，还将分析这些优化对寄存器需求的具体影响，从而深入理解性能与资源之间的复杂关系。",
            "id": "3681186",
            "problem": "一个静态调度的超长指令字 (VLIW) 处理器拥有完全流水线化的功能单元，其每周期可用性和延迟如下：每周期一个内存加载/存储单元（生成寄存器结果的延迟为 $3$ 个周期），每周期一个整数乘法器（延迟 $2$ 个周期），以及每周期两个整数加法器（延迟 $1$ 个周期）。考虑下面的循环，其中所有数组都是非混叠的，内存仅通过单个加载/存储单元进行单端口访问，并且除了数据显示的依赖关系外，所有操作都是独立的。程序变量 $acc$ 在循环前被初始化，并在迭代中累加。数组元素 $K[0]$ 在每次迭代中都会被读取，尽管它是循环不变的。\n\n对于迭代索引 $i \\in \\{0,1,\\dots,N-1\\}$，循环体如下：\n- $t_A \\leftarrow \\mathrm{加载}\\;A[i]$\n- $t_B \\leftarrow \\mathrm{加载}\\;B[i]$\n- $k \\leftarrow \\mathrm{加载}\\;K[0]$\n- $s_1 \\leftarrow t_A + k$\n- $p \\leftarrow s_1 \\times t_B$\n- $acc \\leftarrow p + acc$\n\n假设循环中没有其他指令，并忽略启动/收尾效应；仅分析稳态模调度核心。您需要执行两个转换：首先，执行循环不变代码外提，将 $K[0]$ 的加载操作提升出循环，此后将其值保存在一个非轮转标量寄存器中；其次，使用模调度重新调度循环，以在给定的资源和依赖约束下最小化启动间隔 (II)。将每次迭代的临时变量和循环携带的累加器视为从大小为 $R$ 的轮转寄存器堆中分配，并将提升后的循环不变量 $k$ 视为不消耗轮转寄存器的非轮转标量。\n\n从资源约束和递归约束的启动间隔的核心定义，以及模调度中值的生命周期的概念出发，完成以下任务：\n- 确定转换前以及提升和重新调度后的最小可实现启动间隔。\n- 对于这两种调度，构建一个满足延迟和资源约束的可行模调度（模 II 的槽位分配，带有整数阶段偏移），并从中确定稳态核心内从生产者发射到最后一个消费者发射的每个值的生命周期（以周期为单位）。\n- 使用生命周期和所选的 II，确定轮转寄存器堆中每个临时值所需的并行活跃实例数；总轮转寄存器需求是所有值的生命周期除以 II 的向上取整之和。\n- 报告由于提升和重新调度导致的启动间隔减少量，以及最终（转换后）核心中未使用的轮转寄存器数量（作为 $R$ 的函数）。\n\n将您的最终答案表示为一个包含两个条目的行矩阵：启动间隔的减少量和最终核心中未使用的轮转寄存器数量（用 $R$ 表示）。无需四舍五入。",
            "solution": "我们从超长指令字架构的模调度中使用的两个核心且被广泛接受的定义开始：\n\n1. 资源约束的启动间隔，记为 $II_{\\mathrm{res}}$，其下界为对每个功能单元类别，每次迭代的需求除以每周期容量的最大值，并向上取整。\n\n2. 递归约束的启动间隔，记为 $II_{\\mathrm{rec}}$，其下界为对所有循环携带的依赖环路，环路上的总延迟除以距离（以迭代次数计）的最大值，并向上取整。\n\n因此，可实现的启动间隔下界为 $II \\ge \\max\\{II_{\\mathrm{res}}, II_{\\mathrm{rec}}\\}$，对于具有整数容量的完全流水线化发射，我们的目标是通过构建一个可行的模调度使 $II$ 等于该下界。\n\n第1步：提升前每次迭代的基线资源需求和 $II$。在给定的每次迭代的循环体中，我们有：\n- 内存加载/存储单元：$3$ 次加载（$t_A$, $t_B$, $k$），每周期容量为 $1$，因此内存对 $II_{\\mathrm{res}}$ 的贡献是 $\\lceil 3/1 \\rceil = 3$。\n- 整数乘法器：$1$ 次乘法（$p \\leftarrow s_1 \\times t_B$），每周期容量为 $1$，贡献为 $\\lceil 1/1 \\rceil = 1$。\n- 整数加法器：$2$ 次加法（$s_1 \\leftarrow t_A + k$ 和 $acc \\leftarrow p + acc$），每周期容量为 $2$，贡献为 $\\lceil 2/2 \\rceil = 1$。\n\n因此 $II_{\\mathrm{res,\\,before}} = \\max\\{3, 1, 1\\} = 3$。\n\n对于循环携带的递归，唯一的显式递归是累加器：$acc$ 从迭代 $i-1$ 流入迭代 $i$ 的加法中。该递归环路包含产生 $acc$ 的加法，其延迟为 $1$ 个周期，距离为 $1$ 次迭代，因此 $II_{\\mathrm{rec}} = \\lceil 1/1 \\rceil = 1$。根据非混叠和每次迭代独立的数组元素的假设，不存在内存携带的依赖。\n\n因此，在提升之前，$II_{\\mathrm{before}} = \\max\\{II_{\\mathrm{res}}, II_{\\mathrm{rec}}\\} = \\max\\{3, 1\\} = 3$。\n\n第2步：提升前的可行模调度和稳态生命周期。我们选择一个模 $II=3$ 的调度，槽位标记为 $0,1,2$，并分配阶段偏移（$II$ 的倍数）以满足延迟和资源约束。设迭代 $i$ 的发射时间为绝对时间 $T = \\mathrm{slot} + 3 \\times \\mathrm{stage} + 3 i$。一种可行的分配方案是：\n- $t_A \\leftarrow \\mathrm{加载}\\;A[i]$：槽位 $0$，阶段 $0$；$T = 0 + 0 + 3 i$。\n- $t_B \\leftarrow \\mathrm{加载}\\;B[i]$：槽位 $1$，阶段 $0$；$T = 1 + 0 + 3 i$。\n- $k \\leftarrow \\mathrm{加载}\\;K[0]$：槽位 $2$，阶段 $0$；$T = 2 + 0 + 3 i$。\n- $s_1 \\leftarrow t_A + k$：槽位 $2$，阶段 $1$；$T = 2 + 3 + 3 i = 5 + 3 i$。操作数准备就绪的时间不早于 $3 + 3 i$（来自延迟为 $3$ 的 $t_A$）和 $5 + 3 i$（来自 $k$），因此在 $5 + 3 i$ 发射是有效的。每周期两个加法器允许在槽位 $2$ 中进行两次加法。\n- $p \\leftarrow s_1 \\times t_B$：槽位 $0$，阶段 $2$；$T = 0 + 6 + 3 i = 6 + 3 i$，考虑到 $s_1$ 在 $5+3i$ 发射且延迟为 1 (在 $6+3i$ 就绪)，而 $t_B$ 在 $1+3+3i=4+3i$ 就绪。\n- $acc \\leftarrow p + acc$：槽位 $2$，阶段 $2$；$T = 2 + 6 + 3 i = 8 + 3 i$，考虑到 $p$ 在 $6 + 3 i$ 发射且延迟为 $2$（在 $8 + 3 i$ 就绪）。到下一次迭代 $acc$ 的递归在 $8 + 3 (i+1) = 11 + 3 i$ 消耗此值，考虑到 $1$ 周期的延迟和核心中迭代间 $3$ 周期的间隔，这至少在生产后一个周期。\n\n这个分配方案满足了每个槽位的容量：槽位 $0$ 有一次加载和一次乘法，槽位 $1$ 有一次加载，槽位 $2$ 有两次加法和一次加载，这是允许的，因为有两个加法器和一个内存单元，并且乘法操作不在槽位 $2$。\n\n根据这些发射时间，计算稳态核心中从生产者发射到消费者发射的每个值的生命周期：\n- $t_A$：在 $0 + 3 i$ 生产，在 $5 + 3 i$ 被 $s_1$ 使用；生命周期 $\\ell_{t_A} = (5 + 3 i) - (0 + 3 i) = 5$ 个周期。\n- $t_B$：在 $1 + 3 i$ 生产，在 $6 + 3 i$ 被乘法使用；生命周期 $\\ell_{t_B} = 5$ 个周期。\n- $k$（提升前）：在 $2 + 3 i$ 生产，在 $5 + 3 i$ 被 $s_1$ 使用；生命周期 $\\ell_{k} = 3$ 个周期。\n- $s_1$：在 $5 + 3 i$ 生产，在 $6 + 3 i$ 被乘法使用；生命周期 $\\ell_{s_1} = 1$ 个周期。\n- $p$：在 $6 + 3 i$ 生产，在 $8 + 3 i$ 被 $acc$ 使用；生命周期 $\\ell_{p} = 2$ 个周期。\n- $acc$ 递归实例：在 $8 + 3 (i-1)$ 生产，在 $8 + 3 i$ 使用；生命周期 $\\ell_{acc} = 3$ 个周期。\n\n在轮转寄存器堆中，每个值的同时活跃实例数等于跨迭代的重叠实例数，对于生命周期为 $\\ell$ 的模调度，该值由 $\\left\\lceil \\frac{\\ell}{II} \\right\\rceil$ 给出。当 $II=3$ 时：\n- $t_A$: $\\left\\lceil \\frac{5}{3} \\right\\rceil = 2$。\n- $t_B$: $\\left\\lceil \\frac{5}{3} \\right\\rceil = 2$。\n- $k$: $\\left\\lceil \\frac{3}{3} \\right\\rceil = 1$。\n- $s_1$: $\\left\\lceil \\frac{1}{3} \\right\\rceil = 1$。\n- $p$: $\\left\\lceil \\frac{2}{3} \\right\\rceil = 1$。\n- $acc$: $\\left\\lceil \\frac{3}{3} \\right\\rceil = 1$。\n\n因此，提升前的总轮转寄存器需求为 $2 + 2 + 1 + 1 + 1 + 1 = 8$ 个寄存器。\n\n第3步：提升 $k$ 并重新调度后，重新计算 $II$ 和生命周期。提升操作将循环不变的加载从循环中移除。每次迭代的需求变为：\n- 内存加载/存储单元：每次迭代 $2$ 次加载（$t_A$, $t_B$），容量为 $1$，贡献为 $\\lceil 2/1 \\rceil = 2$。\n- 整数乘法器：每次迭代 $1$ 次，贡献为 $\\lceil 1/1 \\rceil = 1$。\n- 整数加法器：每次迭代 $2$ 次，贡献为 $\\lceil 2/2 \\rceil = 1$。\n\n因此 $II_{\\mathrm{res,\\,after}} = \\max\\{2, 1, 1\\} = 2$。对 $acc$ 的递归没有改变，$II_{\\mathrm{rec}} = 1$。因此，提升后的最小启动间隔为 $II_{\\mathrm{after}} = \\max\\{2, 1\\} = 2$。\n\n构建一个模 $2$ 的可行模调度，槽位标记为 $0,1$，迭代 $i$ 的绝对发射时间为 $T = \\mathrm{slot} + 2 \\times \\mathrm{stage} + 2 i$：\n- $t_A \\leftarrow \\mathrm{加载}\\;A[i]$：槽位 $0$，阶段 $0$；$T = 0 + 0 + 2 i = 0 + 2 i$。\n- $t_B \\leftarrow \\mathrm{加载}\\;B[i]$：槽位 $1$，阶段 $0$；$T = 1 + 0 + 2 i = 1 + 2 i$。\n- $s_1 \\leftarrow t_A + k$：槽位 $1$，阶段 $1$；$T = 1 + 2 + 2 i = 3 + 2 i$，考虑到 $t_A$ 在 $0 + 2 i$ 发射且延迟为 $3$（在 $3 + 2 i$ 就绪），并且 $k$ 作为一个非轮转标量可用，在核心内没有生产延迟。\n- $p \\leftarrow s_1 \\times t_B$：槽位 $0$，阶段 $2$；$T = 0 + 4 + 2 i = 4 + 2 i$，考虑到 $s_1$ 在 $3 + 2 i$ 发射且延迟为 $1$（在 $4 + 2 i$ 就绪），而 $t_B$ 在 $1 + 3 + 2 i = 4 + 2 i$ 就绪。\n- $acc \\leftarrow p + acc$：槽位 $0$，阶段 $3$；$T = 0 + 6 + 2 i = 6 + 2 i$，考虑到 $p$ 在 $4 + 2 i$ 发射且延迟为 $2$（在 $6 + 2 i$ 就绪）。到迭代 $i+1$ 的递归在 $6 + 2 (i+1) = 8 + 2 i$ 消耗，考虑到 $1$ 周期的延迟和每次迭代 $2$ 周期的间隔，这在生产后是安全的。\n\n每个槽位的容量都得到满足：槽位 $0$ 有一次加载、一次乘法和一次加法；槽位 $1$ 有一次加载和一次加法；这些容量与每周期一个内存单元、一个乘法器和两个加法器相匹配。\n\n计算提升后从生产者发射到消费者发射的生命周期：\n- $t_A$：在 $0 + 2 i$ 生产，在 $3 + 2 i$ 被 $s_1$ 使用；生命周期 $\\ell'_{t_A} = 3$ 个周期。\n- $t_B$：在 $1 + 2 i$ 生产，在 $4 + 2 i$ 被乘法使用；生命周期 $\\ell'_{t_B} = 3$ 个周期。\n- $s_1$：在 $3 + 2 i$ 生产，在 $4 + 2 i$ 被乘法使用；生命周期 $\\ell'_{s_1} = 1$ 个周期。\n- $p$：在 $4 + 2 i$ 生产，在 $6 + 2 i$ 被 $acc$ 使用；生命周期 $\\ell'_{p} = 2$ 个周期。\n- $acc$ 递归实例：在 $6 + 2 (i-1) = 4 + 2 i$ 生产，在 $6 + 2 i$ 使用；生命周期 $\\ell'_{acc} = 2$ 个周期。\n\n循环不变量 $k$ 不再消耗轮转寄存器，因为它被提升并存储在一个非轮转标量寄存器中。\n\n当 $II=2$ 时，每个值的同时活跃实例数等于 $\\left\\lceil \\frac{\\ell'}{2} \\right\\rceil$：\n- $t_A$: $\\left\\lceil \\frac{3}{2} \\right\\rceil = 2$。\n- $t_B$: $\\left\\lceil \\frac{3}{2} \\right\\rceil = 2$。\n- $s_1$: $\\left\\lceil \\frac{1}{2} \\right\\rceil = 1$。\n- $p$: $\\left\\lceil \\frac{2}{2} \\right\\rceil = 1$。\n- $acc$: $\\left\\lceil \\frac{2}{2} \\right\\rceil = 1$。\n\n因此，提升后的总轮转寄存器需求为 $2 + 2 + 1 + 1 + 1 = 7$ 个寄存器。\n\n第4步：所要求的量。启动间隔的减少量等于 $II_{\\mathrm{before}} - II_{\\mathrm{after}} = 3 - 2 = 1$。对于一个大小为 $R$ 的轮转寄存器堆，最终核心中未使用的轮转寄存器数量等于 $R - 7$。\n\n因此，所要求的对是包含条目 $1$ 和 $R-7$ 的行矩阵。",
            "answer": "$$\\boxed{\\begin{pmatrix}1  R-7\\end{pmatrix}}$$"
        }
    ]
}