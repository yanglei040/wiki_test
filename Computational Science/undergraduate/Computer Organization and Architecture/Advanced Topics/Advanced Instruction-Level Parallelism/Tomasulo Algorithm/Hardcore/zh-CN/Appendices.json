{
    "hands_on_practices": [
        {
            "introduction": "理论知识需要通过实践来巩固。这个练习将带领你手动模拟一个 Tomasulo 算法处理器的运行过程，让你亲身体验指令如何在动态调度下实现乱序完成。通过追踪一组精心设计的、包含数据依赖和资源竞争的指令，你将清晰地看到 Tomasulo 算法是如何利用保留站和公共数据总线（CDB）来解决数据冒险，从而提升处理器性能的 。",
            "id": "3685502",
            "problem": "考虑一个具有以下特性和定义的托马索罗 (Tomasulo) 风格的动态调度流水线。托马索罗算法使用保留站 (RS) 进行寄存器重命名，以消除读后写 (WAR) 和写后写 (WAW) 冒险，一旦所有操作数都可用就在功能单元 (FU) 中开始执行，并在单个公共数据总线 (CDB) 上广播产生的结果，以唤醒相关的保留站条目。系统中没有重排序缓冲 (ROB)；寄存器堆在CDB广播时立即更新。一个保留站条目捕获操作数值或用于在CDB上匹配的标签，并且只有当两个操作数都可用且相应的功能单元空闲时才开始执行。在此系统中：\n- 发射率为每个周期一条指令，从周期 $1$ 开始。\n- 加法使用两个相同的加法功能单元 (FU)，延迟为 $L_{\\text{add}} = 2$ 个周期。\n- 乘法使用一个乘法功能单元 (FU)，延迟为 $L_{\\text{mul}} = 5$ 个周期。\n- 加法保留站：$3$ 个条目；乘法保留站：$2$ 个条目。\n- 如果两个操作数都可用且功能单元空闲，则执行在发射后的下一个周期立即开始；否则，在两个操作数都可用且功能单元空闲后的下一个周期立即开始。\n- 功能单元产生的结果在最后一个执行周期结束后的下一个周期在CDB上广播。如果多个结果在同一周期争用CDB，索引较低的保留站条目获胜，另一个结果延迟一个周期。\n- 源操作数 $R_5$、$R_6$、$R_8$ 和 $R_9$ 在周期 $1$ 可用。操作数 $R_3$ 在周期 $1$ 可用。操作数 $R_2$ 由于之前的长延迟加载指令而在发射时不可用，并将在周期 $6$ 在CDB上变为可用。\n\n给定以下指令序列（按程序顺序），其中三个加法指令相互独立，两个乘法指令与加法指令构成依赖链：\n1. $I_1$: $R_1 \\leftarrow R_2 + R_3$\n2. $I_2$: $R_4 \\leftarrow R_5 + R_6$\n3. $I_3$: $R_7 \\leftarrow R_8 + R_9$\n4. $I_4$: $R_{10} \\leftarrow R_1 \\times R_4$\n5. $I_5$: $R_{11} \\leftarrow R_{10} \\times R_7$\n\n假设保留站索引在每个保留站文件中按程序顺序分配（即，第一个加法指令获得 $\\text{A1}$，下一个加法指令获得 $\\text{A2}$，以此类推；第一个乘法指令获得 $\\text{M1}$，下一个乘法指令获得 $\\text{M2}$），并且在出现争用时，保留站索引决定CDB仲裁优先级。除了周期 $6$ 时 $R_2$ 的延迟可用之外，没有其他缓存未命中，也没有超出上述功能单元数量的结构性冒险。\n\n任务：\n- 使用上述操作定义，确定每条指令 $I_k$ ($k \\in \\{1,2,3,4,5\\}$) 的确切CDB写回周期。\n- 根据这些写回时间，确定在这个没有重排序缓冲的托马索罗系统中，目标寄存器提交到寄存器堆的最终顺序。\n\n将最终提交顺序表示为包含目标寄存器标识符的单行LaTeX矩阵。无需四舍五入。",
            "solution": "问题提供了一个基于托马索罗的动态调度处理器的详细规范，并要求确定五条特定指令的写回周期以及它们的目标寄存器的最终提交顺序。此分析需要对指令流经流水线阶段（发射、执行和写回）进行逐周期模拟。\n\n首先，我们为每条指令建立从发射到在公共数据总线 (CDB) 上写回的时间线。处理器从周期 $1$ 开始，每个周期发射一条指令。\n\n指令 $I_1: R_1 \\leftarrow R_2 + R_3$\n- **发射**：$I_1$ 在周期 $1$ 发射。它被分配到第一个可用的加法保留站 $\\text{A1}$。\n- **操作数可用性**：$R_3$ 的值在周期 $1$ 可用。$R_2$ 的值被指定在周期 $6$ 在CDB上变为可用。因此，$I_1$ 的两个操作数在周期 $6$ 结束时准备就绪。\n- **执行**：根据规则，执行在操作数就绪且功能单元 (FU) 空闲的下一个周期立即开始。在周期 $6$ 结束时，两个加法FU都空闲。因此，$I_1$ 在周期 $7$ 开始执行。加法延迟为 $L_{\\text{add}} = 2$ 个周期。执行发生在周期 $7$ 和 $8$，在周期 $8$ 结束时完成。\n- **写回 (CDB)**：结果在最后一个执行周期结束后的下一个周期在CDB上广播。这发生在周期 $8+1 = 9$。\n- **$I_1$ 的CDB写回周期：$9$**。\n\n指令 $I_2: R_4 \\leftarrow R_5 + R_6$\n- **发射**：$I_2$ 在周期 $2$ 发射。它被分配到保留站 $\\text{A2}$。\n- **操作数可用性**：$R_5$ 和 $R_6$ 的值在周期 $1$ 就可用，因此在发射时就已就绪。\n- **执行**：在周期 $2$ 结束时，两个操作数都已就绪，并且一个加法FU是空闲的。执行在周期 $2+1 = 3$ 开始。它使用两个加法FU中的一个。延迟为 $L_{\\text{add}} = 2$ 个周期，执行发生在周期 $3$ 和 $4$，在周期 $4$ 结束时完成。\n- **写回 (CDB)**：结果在周期 $4+1 = 5$ 在CDB上广播。\n- **$I_2$ 的CDB写回周期：$5$**。\n\n指令 $I_3: R_7 \\leftarrow R_8 + R_9$\n- **发射**：$I_3$ 在周期 $3$ 发射。它被分配到保留站 $\\text{A3}$。\n- **操作数可用性**：$R_8$ 和 $R_9$ 的值在周期 $1$ 就可用，因此在发射时就已就绪。\n- **执行**：在周期 $3$ 结束时，两个操作数都已就绪。在周期 $4$ 开始时，一个加法FU正被 $I_2$ 占用。然而，第二个加法FU是空闲的。因此，$I_3$ 在周期 $3+1 = 4$ 开始执行。延迟为 $L_{\\text{add}} = 2$ 个周期，执行发生在周期 $4$ 和 $5$，在周期 $5$ 结束时完成。\n- **写回 (CDB)**：结果准备好在周期 $5+1 = 6$ 进行广播。然而，问题陈述指出 $R_2$ 的值在周期 $6$ 在CDB上变为可用。这造成了CDB争用。问题陈述为这个外部事件给出了一个固定的时间，这意味着它有更高的优先级。根据争用规则，竞争失败的结果将被延迟一个周期。因此，$I_3$ 在周期 $6+1 = 7$ 将其结果写入CDB。\n- **$I_3$ 的CDB写回周期：$7$**。\n\n指令 $I_4: R_{10} \\leftarrow R_1 \\times R_4$\n- **发射**：$I_4$ 在周期 $4$ 发射。它被分配到第一个乘法保留站 $\\text{M1}$。\n- **操作数可用性**：$I_4$ 依赖于 $I_1$（产生 $R_1$）和 $I_2$（产生 $R_4$）的结果。保留站条目 $\\text{M1}$ 将等待标签 $\\text{A1}$ 和 $\\text{A2}$。\n  - $I_2$ 的结果（标签 $\\text{A2}$）在周期 $5$ 在CDB上广播。\n  - $I_1$ 的结果（标签 $\\text{A1}$）在周期 $9$ 在CDB上广播。\n  $I_4$ 的两个操作数在周期 $9$ 结束时都可用。\n- **执行**：单个乘法FU是可用的。执行在周期 $9+1 = 10$ 开始。乘法延迟为 $L_{\\text{mul}} = 5$ 个周期。执行发生在周期 $10, 11, 12, 13, 14$，在周期 $14$ 结束时完成。\n- **写回 (CDB)**：结果在周期 $14+1 = 15$ 在CDB上广播。\n- **$I_4$ 的CDB写回周期：$15$**。\n\n指令 $I_5: R_{11} \\leftarrow R_{10} \\times R_7$\n- **发射**：$I_5$ 在周期 $5$ 发射。它被分配到第二个乘法保留站 $\\text{M2}$。\n- **操作数可用性**：$I_5$ 依赖于 $I_4$（产生 $R_{10}$）和 $I_3$（产生 $R_7$）的结果。保留站条目 $\\text{M2}$ 将等待标签 $\\text{M1}$ 和 $\\text{A3}$。\n  - $I_3$ 的结果（标签 $\\text{A3}$）在周期 $7$ 在CDB上广播。\n  - $I_4$ 的结果（标签 $\\text{M1}$）在周期 $15$ 在CDB上广播。\n  $I_5$ 的两个操作数在周期 $15$ 结束时都可用。\n- **执行**：乘法FU被 $I_4$ 使用直到周期 $14$ 结束，在周期 $15$ 时是空闲的。执行在周期 $15+1 = 16$ 开始。延迟为 $L_{\\text{mul}} = 5$ 个周期，执行发生在周期 $16, 17, 18, 19, 20$，在周期 $20$ 结束时完成。\n- **写回 (CDB)**：结果在周期 $20+1 = 21$ 在CDB上广播。\n- **$I_5$ 的CDB写回周期：$21$**。\n\nCDB写回周期总结：\n- $I_1$ (写入 $R_1$): 周期 $9$\n- $I_2$ (写入 $R_4$): 周期 $5$\n- $I_3$ (写入 $R_7$): 周期 $7$\n- $I_4$ (写入 $R_{10}$): 周期 $15$\n- $I_5$ (写入 $R_{11}$): 周期 $21$\n\n问题指出没有重排序缓冲 (ROB)，寄存器堆在CDB广播时立即更新。这意味着目标寄存器的提交顺序由其CDB写回事件的时间顺序决定。\n\n按周期号对写回事件进行排序：\n1. 周期 $5$：$I_2$ 写入 $R_4$。\n2. 周期 $7$：$I_3$ 写入 $R_7$。\n3. 周期 $9$：$I_1$ 写入 $R_1$。\n4. 周期 $15$：$I_4$ 写入 $R_{10}$。\n5. 周期 $21$：$I_5$ 写入 $R_{11}$。\n\n因此，目标寄存器的最终提交顺序是 $R_4$、然后是 $R_7$、然后是 $R_1$、然后是 $R_{10}$，最后是 $R_{11}$。此序列表示为包含寄存器标识符的行矩阵。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\nR_4  R_7  R_1  R_{10}  R_{11}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "掌握了基本原理后，让我们来探讨一个更深层次的微架构设计挑战。在一个高吞吐量的处理器中，资源（如标签）的快速重用是至关重要的，但这也会引入潜在的正确性问题，例如“陈旧唤醒”风险 。这个练习要求你分析这种由于标签重用而引发的微妙时序冒险，并从多个备选方案中评估出最可靠的硬件解决方案，从而培养像处理器设计师一样思考的严谨性。",
            "id": "3685482",
            "problem": "考虑一台实现Tomasulo算法的机器，该算法通过标签和单个公共数据总线（CDB）实现动态调度和寄存器重命名。该机器有一个大小为$N$的有限标签命名空间，标签表示为$T_0, T_1, \\dots, T_{N-1}$。每条生产者指令都会为其目标寄存器分配一个标签$T_i$；消费者的保留站（RS）条目在其源字段中记录生产者的标签。当一个功能单元完成时，元组$\\langle T_i, V \\rangle$会在CDB上广播，所有包含$T_i$的RS源字段会捕获值$V$并被唤醒。当生产者指令写回时，标签被释放；被释放的标签可以立即被标签分配器重新分配给新的生产者指令。\n\n假设针对一个特定的冒险场景有以下时序模型：在周期$c$，指令$I_1$是标签$T_k$的唯一生产者并完成执行；在周期$c+1$，CDB为$I_1$广播$\\langle T_k, V_1 \\rangle$。标签分配器在周期$c+1$的开始释放$T_k$，并在同一周期$c+1$将$T_k$重新分配给一条新发射的指令$I_2$。同样在周期$c+1$，一个依赖于$I_2$结果的消费者指令$I_3$被发射，并在其RS源字段中记录$T_k$。RS比较器在周期$c+1$内执行针对CDB广播的标签相等性检查。\n\n根据Tomasulo算法的核心定义，唤醒规则是：一个RS源操作数在一个周期内变为就绪，当且仅当CDB上载有一个元组$\\langle T_i, V \\rangle$，使得RS源存储的标签等于$T_i$。考虑到有限的标签命名空间和立即重用，该系统可能会遇到“陈旧唤醒”（stale wake-up）冒险：一个新分配标签$T_k$的消费者可能会错误地从一个较早的生产者$I_1$那里捕获值$\\langle T_k, V_1 \\rangle$，即使它在语义上依赖于$I_2$。这是一个由同一标签的不同“代”之间不可区分性引起的标签重用冒险。\n\n下列哪项设计变更可以可证明地防止上述场景中的陈旧唤醒冒险，同时不降低标签重用率且硬件成本适中，并说明原因？\n\nA. 依赖重排序缓存（ROB）强制执行的程序顺序：允许RS在任何匹配其标签的CDB广播上唤醒，但确保ROB提交阶段丢弃或纠正任何乱序捕获的操作数。\n\nB. 添加一个每个标签的纪元（代）计数器$E[T_i]$，并在CDB上广播$\\langle T_i, E[T_i], V \\rangle$；当标签$T_i$被释放时，将$E[T_i]$模一个小整数递增，并让每个RS源在发射时存储对$(T_i, E[T_i])$；RS源仅在标签和纪元都与CDB广播匹配时才唤醒。\n\nC. 在任何RS源记录一个标签后，精确地抑制RS比较器活动$1$个周期，这样新分配的标签就不会在同一周期内匹配到广播；在下一个周期，启用正常的比较器。\n\nD. 要求RS比较器除了检查标签外，还检查消费者的ROB索引，仅在两者都匹配时才唤醒；继续在写回时立即重用标签，不增加额外的元数据。\n\n选择唯一的最佳选项，并根据Tomasulo算法的基本唤醒语义和所述时序进行论证。",
            "solution": "问题陈述已经过验证，被认为是合理的。它描述了一个经典的微体系结构冒险，称为标签重用冒险或陈旧唤醒，这是并发系统中ABA问题的一个具体实例。该设置在计算机体系结构原理，特别是使用Tomasulo算法的动态调度方面，具有科学依据。时序模型定义明确，允许对所提出的解决方案进行严格的分析。\n\n问题的核心在于标签`$T_k$`的歧义性。在周期`$c+1$`中，标签`$T_k$`同时与两条不同的动态指令相关联：正在广播其结果`$\\langle T_k, V_1 \\rangle$`的旧生产者`$I_1$`，以及其结果正被消费者`$I_3$`等待的新生产者`$I_2$`。简单的唤醒规则只检查标签标识符的相等性，无法区分与`$I_1$`关联的`$T_k$`的“代”和与`$I_2$`关联的新一代。因此，`$I_3$`错误地在`$I_1$`的结果上唤醒。一个有效的解决方案必须引入一种机制来唯一标识标签的每个实例或代，从而打破这种歧义。\n\n我们现在将评估每个提议的选项。\n\n**A. 依赖重排序缓存（ROB）强制执行的程序顺序：允许RS在任何匹配其标签的CDB广播上唤醒，但确保ROB提交阶段丢弃或纠正任何乱序捕获的操作数。**\n\n这种方法在根本上是有缺陷的。保留站（RS）唤醒逻辑的目的是确保正确的数据流，只允许指令在其真实依赖得到满足时才执行。允许像`$I_3$`这样的指令用不正确的操作数（`$V_1$`而不是`$V_2$`）唤醒并执行，会破坏数据流图。任何依赖于`$I_3$`的后续指令也将使用错误的数据执行。这将引发一串可能很长的错误推测指令的级联，这些指令必须被冲刷并重新执行。ROB的作用是强制按序提交，并为从异常和分支预测错误中恢复提供便利，而不是常规地清理执行核心中基本的数据流错误。这个解决方案并不能*防止*冒险；它提出了一个效率极低且复杂的*恢复*机制，这与高效乱序处理器的设计目标背道而驰。\n\n**结论：不正确。**\n\n**B. 添加一个每个标签的纪元（代）计数器$E[T_i]$，并在CDB上广播$\\langle T_i, E[T_i], V \\rangle$；当标签$T_i$被释放时，将$E[T_i]$模一个小整数递增，并让每个RS源在发射时存储对$(T_i, E[T_i])$；RS源仅在标签和纪元都与CDB广播匹配时才唤醒。**\n\n这个解决方案直接且可证明地解决了问题。它通过对每个标签进行版本控制来工作。\n1. 当`$I_1$`被发射时，它被分配了标签`$T_k$`和当前的纪元值，比如说`$(T_k, e)$`。\n2. 当`$I_1$`的标签`$T_k$`在周期`$c+1$`被释放时，纪元计数器`$E[T_k]$`递增到`$e+1$`（模计数器大小）。\n3. 当`$I_2$`在周期`$c+1$`被发射时，它被分配了标签和新的纪元，即`$(T_k, e+1)$`。\n4. 消费者`$I_3$`被发射，其RS条目存储`$(T_k, e+1)``作为其源操作数的标识符。\n5. 在周期`$c+1$`，`$I_1$`广播其结果元组，现在包含其原始纪元：`$\\langle T_k, e, V_1 \\rangle$`。\n6. `$I_3$`的RS条目将广播的元组`$(T_k, e)`与其所需的源元组`$(T_k, e+1)`进行比较。由于纪元不匹配（`$e \\neq e+1$`），`$I_3$`不会唤醒。陈旧唤醒被防止了。\n7. 稍后，当`$I_2$`完成时，它将广播`$\\langle T_k, e+1, V_2 \\rangle$`。`$I_3$`的RS条目将找到完全匹配并正确唤醒。\n这个解决方案是稳健的，不依赖于特定的流水线时序，不降低标签重用率，并且硬件成本（每个标签一个小编码器，更宽的CDB，更宽的比较器）是适度的。\n\n**结论：正确。**\n\n**C. 在任何RS源记录一个标签后，精确地抑制RS比较器活动$1$个周期，这样新分配的标签就不会在同一周期内匹配到广播；在下一个周期，启用正常的比较器。**\n\n这个解决方案是一个依赖于时序的、脆弱的修复方案，并非普遍正确。虽然它在所描述的确切场景中防止了冒险，但在其他可能的场景中会失败。\n在给定的场景中：\n- 周期`$c+1$`：`$I_3$`被发射，记录`$T_k$`。其比较器被抑制。`$I_1$`广播`$\\langle T_k, V_1 \\rangle$`。`$I_3$`没有唤醒。冒险被避免了。\n然而，考虑一个在Tomasulo算法的一般模型下允许的轻微变化：CDB争用。\n- 周期`$c$`：`$I_1$`完成执行。\n- 周期`$c+1$`：`$I_2$`和`$I_3$`被发射，`$T_k$`被重用。`$I_3$`的RS条目记录`$T_k$`并在此周期抑制其比较器。然而，由于CDB正忙于处理另一个结果，`$I_1$`无法广播。\n- 周期`$c+2$`：`$I_1$`赢得CDB仲裁并广播`$\\langle T_k, V_1 \\rangle$`。到这个周期，对`$I_3$`比较器的抑制已经解除。比较器处于活动状态，它们在CDB上看到了`$T_k$`，于是`$I_3$`错误地在陈旧值`$V_1$`上唤醒。\n因为如果陈旧广播哪怕只延迟一个周期，这个解决方案就会失败，所以它不能*可证明地*防止该冒险。\n\n**结论：不正确。**\n\n**D. 要求RS比较器除了检查标签外，还检查消费者的ROB索引，仅在两者都匹配时才唤醒；继续在写回时立即重用标签，不增加额外的元数据。**\n\n这个选项定义不明确，并且包含一个矛盾。使用像重排序缓存（ROB）索引这样的唯一指令标识符的基本思想是一个有效的体系结构解决方案，但这里的描述是有缺陷的。\n1. **措辞模糊**：“检查消费者的ROB索引”。CDB上的广播来自*生产者*指令（`$I_1$`或`$I_2$`），而不是消费者（`$I_3$`）。RS中的比较必须是在所需生产者的标识符和广播生产者的标识符之间进行。一个善意的解释是，消费者（`$I_3$`）的RS条目存储其生产者（`$I_2$`）的ROB索引，并且CDB广播生产者的ROB索引以及标签和值。这是可行的，因为在飞行指令的ROB索引是唯一的。然而，这并非该选项所陈述的内容。\n2. **矛盾**：该选项声称“不增加额外的元数据”。生产者的ROB索引正是解决歧义所需的*额外元数据*。它必须存储在寄存器别名表（RAT）和RS条目中，并且必须在CDB上广播。这在功能上等同于选项B中的纪元计数器——两者都是版本控制元数据的形式。声称需要“不增加额外的元数据”在事实上是不正确的。\n由于其模糊的措辞和直接的自相矛盾，即使它暗示了一个正确的机制（使用ROB索引进行消歧），这个选项也不是一个格式良好或有效的解决方案描述。与清晰且正确描述的选项B相比，选项D较差。\n\n**结论：不正确。**\n\n总而言之，选项B是唯一一个描述了在给定约束下，能够稳健、可证明地正确且清晰地防止陈旧唤醒冒险的机制。",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "现代高性能处理器不仅仅是乱序执行，它们还会在遇到分支指令时不确定其走向的情况下进行推测执行。这个综合性练习将 Tomasulo 算法与分支预测和推测执行这两个高级概念结合起来 。你的任务是分析在一个支持多路径推测的复杂模型中，当分支预测错误时，系统如何精确地清除被错误执行的指令，这对于理解现代 CPU 的核心纠错机制至关重要。",
            "id": "3685443",
            "problem": "考虑一个超标量处理器，该处理器实现了 Tomasulo 算法，支持动态调度、寄存器重命名，并使用基于每个分支的路径掩码进行推测性的多路径控制流跟踪。每条指令都带有一个推测路径标签，该标签是一个针对未解析分支的位向量；每个位对应一个未解析分支的预测方向。处理器最多同时跟踪两个未解析的分支，表示为 $B_{1}$ 和 $B_{2}$。处理器按路径分区分配保留站（Reservation Station, RS）条目，以避免在不同的推测路径之间混合依赖关系。公共数据总线（Common Data Bus, CDB）广播结果以唤醒相关的 RS 条目，重排序缓冲区（ReOrder Buffer, ROB）确保按序提交；然而，就本问题而言，仅在分支解析的时刻计算 RS 条目。假设任何已经在 CDB 上广播其结果的指令已经释放了其 RS 条目，因此不计为被作废。\n\n微架构参数：\n- 发射宽度为每个周期 $W=3$ 条指令。\n- 有 $2$ 个算术逻辑单元（ALU）功能单元和 $1$ 个乘法（MUL）功能单元。\n- 延迟为：ALU 加法或比较为 $1$ 个周期，MUL 为 $3$ 个周期，Load 为 $3$ 个周期。如果一条延迟为 $L$ 的指令在周期 $c$ 发射且其所有操作数都已就绪，它将在周期 $c+L$ 广播其结果。\n- RS 大小和分区策略：\n  - ALU RS 有 $N_{\\text{ALU}}=12$ 个条目。当存在一个未解析分支 $B_{1}$ 时，条目被平均分为 $6$ 个用于路径 $b_{1}=0$（不跳转）和 $6$ 个用于路径 $b_{1}=1$（跳转）。如果第二个未解析分支 $B_{2}$ 仅沿着 $b_{1}=1$ 路径被取指，那么 $b_{1}=1$ 分区被细分为 $3$ 个条目用于 $(b_{1}=1,b_{2}=0)$ 和 $3$ 个用于 $(b_{1}=1,b_{2}=1)$。在 $b_{1}=1$ 路径上、$B_{2}$ 之前的指令带有标签 $(b_{1}=1,b_{2}=\\varnothing)$，并根据 $b_{1}=1$ 的预算进行分配，在分配时占用特定的子分区。\n  - MUL RS 有 $N_{\\text{MUL}}=4$ 个条目，在 $B_{1}$ 未解析期间，分为 $2$ 个用于 $b_{1}=0$ 和 $2$ 个用于 $b_{1}=1$。在这种情况下，不需要为 $B_{2}$ 进行进一步细分。\n  - Load/Store RS 有 $N_{\\text{LS}}=4$ 个条目，并且在这种情况下不是瓶颈。\n\n指令流和依赖设置：\n- 分支前设置：\n  - $I_{0}$: $\\text{R}_{1} \\leftarrow \\text{LOAD}[\\text{R}_{14}]$ (LD, 延迟 $3$)。\n  - $I_{1}$: $\\text{R}_{2} \\leftarrow \\text{R}_{1} \\times \\text{R}_{3}$ (MUL, 延迟 $3$), 依赖于 $I_{0}$ 的 $\\text{R}_{1}$。\n  - $I_{2}$: $B_{1}$: 如果 $\\text{R}_{2} = 0$ 则分支 (ALU 比较, 延迟 $1$), 依赖于 $I_{1}$ 的 $\\text{R}_{2}$。$B_{1}$ 的预测器预测为 $b_{1}=1$ (跳转)，但实际结果将是 $b_{1}=0$ (不跳转)。\n- 在预测 $B_{1}$ 跳转 ($b_{1}=1$) 的路径下，包含第二个分支 $B_{2}$：\n  - $T_{3}$: $\\text{R}_{9} \\leftarrow \\text{R}_{10} \\times \\text{R}_{11}$ (MUL, 延迟 $3$), 标签 $(b_{1}=1)$。\n  - $T_{1}$: $\\text{R}_{4} \\leftarrow \\text{R}_{9} + \\text{R}_{6}$ (ALU, 延迟 $1$), 标签 $(b_{1}=1,b_{2}=\\varnothing)$, 依赖于 $T_{3}$ 的 $\\text{R}_{9}$。\n  - $T_{2}$: $\\text{R}_{7} \\leftarrow \\text{R}_{4} + \\text{R}_{8}$ (ALU, 延迟 $1$), 标签 $(b_{1}=1,b_{2}=\\varnothing)$, 依赖于 $T_{1}$ 的 $\\text{R}_{4}$。\n  - $T_{4}$: $B_{2}$: 如果 $\\text{R}_{9}  \\text{R}_{12}$ 则分支 (ALU 比较, 延迟 $1$), 标签 $(b_{1}=1,b_{2}=\\varnothing)$, 依赖于 $T_{3}$ 的 $\\text{R}_{9}$。$B_{2}$ 的预测器预测为 $b_{2}=1$ (跳转)。\n  - $B_{2}$ 后的推测性副本：\n    - $\\text{TT}_{1}$: $\\text{R}_{30} \\leftarrow \\text{R}_{4} + \\text{R}_{31}$ (ALU, 延迟 $1$), 标签 $(b_{1}=1,b_{2}=1)$, 依赖于 $T_{1}$ 的 $\\text{R}_{4}$。\n    - $\\text{NT}_{1}$: $\\text{R}_{32} \\leftarrow \\text{R}_{4} + \\text{R}_{33}$ (ALU, 延迟 $1$), 标签 $(b_{1}=1,b_{2}=0)$, 依赖于 $T_{1}$ 的 $\\text{R}_{4}$。\n- 在 $B_{1}$ 不跳转 ($b_{1}=0$) 的直通路径下：\n  - $N_{3}$: $\\text{R}_{19} \\leftarrow \\text{R}_{20} \\times \\text{R}_{21}$ (MUL, 延迟 $3$), 标签 $(b_{1}=0)$。\n  - $N_{1}$: $\\text{R}_{13} \\leftarrow \\text{R}_{15} + \\text{R}_{16}$ (ALU, 延迟 $1$), 标签 $(b_{1}=0)$, 独立。\n  - $N_{2}$: $\\text{R}_{17} \\leftarrow \\text{R}_{18} + \\text{R}_{13}$ (ALU, 延迟 $1$), 标签 $(b_{1}=0)$, 依赖于 $N_{1}$ 的 $\\text{R}_{13}$。\n  - $N_{4}$: $\\text{R}_{25} \\leftarrow \\text{R}_{26} + \\text{R}_{27}$ (ALU, 延迟 $1$), 标签 $(b_{1}=0)$, 独立。\n\n发射调度和功能单元使用：\n- 周期 $1$：发射 $I_{0}$ (LD RS), $I_{1}$ (MUL RS), $I_{2}$ (ALU RS)。$I_{0}$ 将在周期 $4$ 广播。$I_{1}$ 只能在 $I_{0}$ 广播后开始；它在周期 $4$ 开始，并在周期 $7$ 广播。$I_{2}$ 将在周期 $7$ 开始，并在周期 $8$ 广播，从而在周期 $8$ 解析 $B_{1}$。\n- 周期 $2$：发射 $T_{3}$ (MUL RS, 标签 $(b_{1}=1)$), $N_{3}$ (MUL RS, 标签 $(b_{1}=0)$), $N_{1}$ (ALU RS, 标签 $(b_{1}=0)$)。唯一的 MUL 单元被 $I_{1}$ 占用直到周期 $7$，所以 $T_{3}$ 和 $N_{3}$ 都不能在周期 $8$ 之前开始。\n- 周期 $3$：发射 $T_{1}$ (ALU RS, 标签 $(b_{1}=1,b_{2}=\\varnothing)$, 在 $(b_{1}=1,b_{2}=1)$ 子分区中分配), $T_{2}$ (ALU RS, 标签 $(b_{1}=1,b_{2}=\\varnothing)$, 在 $(b_{1}=1,b_{2}=1)$ 子分区中分配), $N_{2}$ (ALU RS, 标签 $(b_{1}=0)$)。\n- 周期 $4$：发射 $T_{4}$ (ALU RS, 标签 $(b_{1}=1,b_{2}=\\varnothing)$, 在 $(b_{1}=1,b_{2}=0)$ 子分区中分配), $\\text{TT}_{1}$ (ALU RS, 标签 $(b_{1}=1,b_{2}=1)$), $\\text{NT}_{1}$ (ALU RS, 标签 $(b_{1}=1,b_{2}=0)$)。此时 $b_{1}=1$ 下的 ALU RS 子分区计数为：$(b_{1}=1,b_{2}=1)$ 持有 $T_{1}$, $T_{2}$, $\\text{TT}_{1}$ ($3$ 个中的 $3$ 个)；$(b_{1}=1,b_{2}=0)$ 持有 $T_{4}$, $\\text{NT}_{1}$ ($3$ 个中的 $2$ 个)。\n- 周期 $5$：发射 $N_{4}$ (ALU RS, 标签 $(b_{1}=0)$)。当 $N_{1}$ 和 $N_{2}$ 的操作数就绪时，ALU 单元可以执行它们；这些指令可能会在周期 $8$ 之前释放它们的 RS 条目。这不影响作废条目的计数，因为它们在正确的路径 $b_{1}=0$ 上。\n\n在周期 $8$，$B_{1}$ 解析为不跳转 ($b_{1}=0$)。在那一刻：\n- $T_{3}$ 尚未开始，因为 MUL 单元直到周期 $7$ 都被 $I_{1}$ 占用，并且只能在周期 $8$ 开始一个新的 MUL 操作。因此，$T_{3}$ 仍然占用其 MUL RS 条目。\n- 来自 $T_{3}$ 的 $\\text{R}_{9}$ 不可用，所以 $T_{1}$、$T_{2}$ 和 $T_{4}$ 都在 ALU RS 中等待（因操作数缺失而阻塞）。\n- $\\text{TT}_{1}$ 和 $\\text{NT}_{1}$ 依赖于来自 $T_{1}$ 的 $\\text{R}_{4}$，也正在 ALU RS 中等待。\n- $N_{1}$、$N_{2}$、$N_{3}$ 和 $N_{4}$ 位于正确路径 $b_{1}=0$ 上，不会被作废。\n- $I_{0}$ 和 $I_{1}$ 是分支前指令，没有被标记为 $b_{1}=1$；它们不会被作废。$I_{2}$ 解析该分支并在周期 $8$ 结束时释放其 RS 条目。\n\n根据 Tomasulo 算法的基本原理和上述调度，计算在 $B_{1}$ 预测错误时（周期 $8$）被作废的 RS 条目总数。计算所有 RS 类型的条目。用一个数字表示你的答案。无需四舍五入。",
            "solution": "问题要求计算在分支 $B_1$ 被解析为预测错误时被作废的保留站（RS）条目的总数。该处理器架构使用带有推测执行的 Tomasulo 算法，其中错误预测路径上的指令被清除（squashed）。在这种情况下，清除一条已经发射但尚未完成并释放其资源的指令，意味着使其 RS 条目作废。\n\n预测错误的时刻被指定为周期 $8$，此时指令 $I_2$（即分支指令本身）广播其结果。在这一刻，实际的分支结果被确定为不跳转 ($b_1=0$)，这与预测的跳转结果 ($b_1=1$) 相矛盾。因此，所有在对应于 $b_1=1$ 的路径上被推测性发射的指令都必须被作废。在正确路径 ($b_1=0$) 上的指令和分支前的指令不会被作废。\n\n在错误预测路径 ($b_1=1$) 上发射的指令集合是：\n1.  $T_3$: $\\text{R}_{9} \\leftarrow \\text{R}_{10} \\times \\text{R}_{11}$ (MUL 类型，发射到 MUL RS)\n2.  $T_1$: $\\text{R}_{4} \\leftarrow \\text{R}_{9} + \\text{R}_{6}$ (ALU 类型，发射到 ALU RS)\n3.  $T_2$: $\\text{R}_{7} \\leftarrow \\text{R}_{4} + \\text{R}_{8}$ (ALU 类型，发射到 ALU RS)\n4.  $T_4$: $B_{2}$: branch if $\\text{R}_{9}  \\text{R}_{12}$ (ALU 类型，发射到 ALU RS)\n5.  $\\text{TT}_{1}$: $\\text{R}_{30} \\leftarrow \\text{R}_{4} + \\text{R}_{31}$ (ALU 类型，发射到 ALU RS)\n6.  $\\text{NT}_{1}$: $\\text{R}_{32} \\leftarrow \\text{R}_{4} + \\text{R}_{33}$ (ALU 类型，发射到 ALU RS)\n\n我们必须确定这 $6$ 条指令中哪些在周期 $8$ 时仍然占用 RS 条目。一条指令只有在完成执行并在公共数据总线（CDB）上广播其结果后，才会释放其 RS 条目。为了确定这些指令的状态，我们必须分析执行时间线和数据依赖关系。\n\n首先，考虑决定 $B_1$ 何时解析的分支前指令。\n- $I_0$ ($\\text{LOAD}$) 在周期 $1$ 发射。它的延迟是 $3$ 个周期。它在周期 $1+3=4$ 广播其结果。\n- $I_1$ ($\\text{MUL}$) 在周期 $1$ 发射，并依赖于 $I_0$ 的结果。唯一的 MUL 功能单元可用。$I_1$ 在周期 $4$（当来自 $I_0$ 的操作数可用时）开始执行，延迟为 $3$ 个周期。它在周期 $4+3=7$ 广播其结果。\n- $I_2$（分支 $B_1$，一个 ALU 比较）在周期 $1$ 发射，并依赖于 $I_1$ 的结果。它在周期 $7$（当来自 $I_1$ 的操作数可用时）开始执行，延迟为 $1$ 个周期。它在周期 $7+1=8$ 广播其结果。这个在周期 $8$ 的广播是解析该分支的事件。\n\n根据问题陈述，一条广播了其结果的指令已经释放了其 RS 条目。在周期 $8$，$I_0$ 和 $I_1$ 都已完成并释放了它们的 RS 条目。$I_2$ 在周期 $8$ 广播，所以它也释放了其条目。无论如何，这些都是分支前指令，不在错误预测路径上，所以它们无论如何都不会被作废。\n\n现在，我们分析在周期 $8$ 作废的时刻，错误预测路径 ($b_1=1$) 上的指令状态。\n\n- 指令 $T_3$ ($\\text{MUL}$) 在周期 $2$ 发射到 MUL RS。它需要唯一的 MUL 功能单元。该单元从周期 $4$ 开始到周期 $7$ 结束都被指令 $I_1$ 占用。因此，$T_3$ 最早能在周期 $8$ 开始执行。在周期 $8$ 作废的时刻，$T_3$ 尚未开始执行，也未广播其结果，因此仍然占用其在 MUL RS 中的条目。这计为 $1$ 个被作废的条目。\n\n- 指令 $T_1$ ($\\text{ALU}$) 在周期 $3$ 发射，并依赖于 $T_3$ 的结果（寄存器 $\\text{R}_9$）。由于 $T_3$ 到周期 $8$ 仍未广播其结果，$T_1$ 在 ALU RS 中被阻塞，等待其操作数。它占用了其 RS 条目。这又计为 $1$ 个被作废的条目。\n\n- 指令 $T_4$ ($B_2$，一个 ALU 比较) 在周期 $4$ 发射，同样依赖于 $T_3$ 的结果（寄存器 $\\text{R}_9$）。与 $T_1$ 类似，$T_4$ 在周期 $8$ 时也在 ALU RS 中被阻塞。它占用了其 RS 条目。这又计为另一个被作废的条目。\n\n- 指令 $T_2$ ($\\text{ALU}$) 在周期 $3$ 发射，并依赖于 $T_1$ 的结果（寄存器 $\\text{R}_4$）。由于 $T_1$ 因等待 $T_3$ 而被阻塞，$T_2$ 也被阻塞在 ALU RS 中。它占用了其 RS 条目。这是另一个被作废的条目。\n\n- 指令 $\\text{TT}_{1}$ ($\\text{ALU}$) 在周期 $4$ 发射，并依赖于 $T_1$ 的结果（寄存器 $\\text{R}_4$）。由于 $T_1$ 被阻塞，$\\text{TT}_{1}$ 也被阻塞在 ALU RS 中。它占用了其 RS 条目。这为被作废条目的计数再加一。\n\n- 指令 $\\text{NT}_{1}$ ($\\text{ALU}$) 在周期 $4$ 发射，同样依赖于 $T_1$ 的结果（寄存器 $\\text{R}_4$）。它也被阻塞在 ALU RS 中并占用其条目。这是我们必须考虑的最后一个被作废的条目。\n\n总之，在周期 $8$，所有在错误预测路径上发射的六条指令（$T_3, T_1, T_2, T_4, \\text{TT}_1, \\text{NT}_1$）都因为源于 $T_3$ 的数据依赖而被阻塞，而 $T_3$ 本身又因为资源冒险（MUL 单元繁忙）而被阻塞。它们中没有一条广播了其结果。因此，所有六条指令仍然驻留在它们各自的保留站中。\n\n被作废的条目是：\n- 在 MUL RS 中：$1$ 个条目（用于 $T_3$）。\n- 在 ALU RS 中：$5$ 个条目（用于 $T_1$、$T_2$、$T_4$、$\\text{TT}_1$、$\\text{NT}_1$）。\n\n被作废的 RS 条目总数是这些计数的总和。\n总作废数 = $1 + 5 = 6$。\n关于 RS 分区的信息用于确认处理器有足够的资源来发射这些指令，但这并不改变作废条目的计数，因为所有在被冲刷路径上已发射但尚未完成的指令都必须被清除。",
            "answer": "$$\\boxed{6}$$"
        }
    ]
}