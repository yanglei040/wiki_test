{
    "hands_on_practices": [
        {
            "introduction": "理论上，无限的指令级并行似乎是可能的，但现实中的处理器受限于其物理资源。即使程序中存在大量可并行的指令，处理器的性能上限也取决于其最繁忙的功能单元。这个练习将帮助我们量化这种由结构性风险（即资源瓶颈）所带来的性能限制。",
            "id": "3651306",
            "problem": "一个乱序超标量处理器设计有以下执行资源和假设。该处理器有两个整数算术逻辑单元 (ALU) 和一个加载/存储单元 (LSU)。所有功能单元都是完全流水线化的，每个单元每个周期可以启动一个新操作。指令窗口足够大，可以揭示所有可用的并行性；寄存器重命名是完美的，内存消歧是完美的，分支预测也是完美的；除了结构资源争用之外的控制和数据依赖可以忽略。提交带宽不是瓶颈。任何周期内的发射宽度仅受限于可用功能单元可以启动的操作数量。内存系统是理想化的，因此在稳态下，LSU 每个周期可以启动一个内存操作。指令级并行 (ILP) 定义为每个周期完成的稳态平均指令数，等效于以每周期指令数 (IPC) 为单位的稳态吞吐量。\n\n考虑两个独立的指令流，其动态混合仅由整数 ALU 操作和内存操作 (加载或存储) 组成，没有其他指令类型：\n\n- 整数密集型混合：整数 ALU 操作的比例为 $p_{\\text{ALU}}^{(I)} = \\frac{4}{5}$，内存操作的比例为 $p_{\\text{MEM}}^{(I)} = \\frac{1}{5}$。\n- 内存密集型混合：整数 ALU 操作的比例为 $p_{\\text{ALU}}^{(M)} = \\frac{2}{5}$，内存操作的比例为 $p_{\\text{MEM}}^{(M)} = \\frac{3}{5}$。\n\n仅使用流守恒推理以及由两个 ALU 和一个 LSU 所隐含的容量限制，确定每种混合的最大可持续指令级并行度，然后计算整数密集型 ILP 与内存密集型 ILP 的比率。请以精确的实数形式提供最终答案 (不要四舍五入)。最终答案不需要单位。",
            "solution": "该问题要求计算在理想化的超标量处理器上，两种不同指令混合的最大可持续指令级并行度 ($ILP$) 之间的比率。$ILP$ 定义为每个周期完成的稳态平均指令数 ($IPC$)。处理器的性能受其功能单元容量的限制。问题指示使用“流守恒推理”，这意味着稳态吞吐量由首先饱和的资源决定，即瓶颈。\n\n设 $N_{ALU}$ 为整数算术逻辑单元 ($ALU$) 的数量，$N_{LSU}$ 为加载/存储单元 ($LSU$) 的数量。根据问题描述，该处理器配备有：\n$$ N_{ALU} = 2 $$\n$$ N_{LSU} = 1 $$\n\n每个功能单元都是完全流水线化的，每个周期可以启动一个新操作。因此，$ALU$ 操作的最大速率是每周期 $2$ 个，内存操作的最大速率是每周期 $1$ 个。\n\n对于任何给定的动态指令流，设 $p_{ALU}$ 为 $ALU$ 操作的比例，$p_{MEM}$ 为内存操作的比例。如果处理器维持每周期 $I$ 条指令的总吞吐量，那么执行 $ALU$ 指令的速率为 $I \\times p_{ALU}$，执行内存指令的速率为 $I \\times p_{MEM}$。\n\n为了使稳态成为可能，对每种资源的需求都不能超过其容量。这对 $I$ 的最大可能值产生了两个独立的约束：\n\n1.  $ALU$ 约束：$ALU$ 指令的执行速率不能超过总 $ALU$ 容量。\n    $$ I \\times p_{ALU} \\le N_{ALU} \\implies I \\le \\frac{N_{ALU}}{p_{ALU}} $$\n2.  $LSU$ 约束：内存指令的执行速率不能超过总 $LSU$ 容量。\n    $$ I \\times p_{MEM} \\le N_{LSU} \\implies I \\le \\frac{N_{LSU}}{p_{MEM}} $$\n\n最大可持续 $ILP$ (我们将其表示为 $ILP_{max}$)，是同时满足这两个约束的 $I$ 的最高值。该值由两个上界中更严格的那个决定，对应于瓶颈资源。\n$$ ILP_{max} = \\min\\left(\\frac{N_{ALU}}{p_{ALU}}, \\frac{N_{LSU}}{p_{MEM}}\\right) $$\n\n我们现在将此框架应用于所提供的两种指令混合。\n\n**整数密集型混合 (I)**\n对于这种混合，比例为 $p_{\\text{ALU}}^{(I)} = \\frac{4}{5}$ 和 $p_{\\text{MEM}}^{(I)} = \\frac{1}{5}$。\n由 $ALU$ 资源施加的 $ILP$ 上限为：\n$$ I_{ALU-bound}^{(I)} = \\frac{N_{ALU}}{p_{\\text{ALU}}^{(I)}} = \\frac{2}{4/5} = \\frac{2 \\times 5}{4} = \\frac{10}{4} = 2.5 $$\n由 $LSU$ 资源施加的 $ILP$ 上限为：\n$$ I_{LSU-bound}^{(I)} = \\frac{N_{LSU}}{p_{\\text{MEM}}^{(I)}} = \\frac{1}{1/5} = 5 $$\n整数密集型混合的最大可持续 $ILP$ ($ILP_I$) 是这两个上界的最小值：\n$$ ILP_I = \\min(2.5, 5) = 2.5 $$\n在这种情况下，两个 $ALU$ 是瓶颈。\n\n**内存密集型混合 (M)**\n对于这种混合，比例为 $p_{\\text{ALU}}^{(M)} = \\frac{2}{5}$ 和 $p_{\\text{MEM}}^{(M)} = \\frac{3}{5}$。\n由 $ALU$ 资源施加的 $ILP$ 上限为：\n$$ I_{ALU-bound}^{(M)} = \\frac{N_{ALU}}{p_{\\text{ALU}}^{(M)}} = \\frac{2}{2/5} = \\frac{2 \\times 5}{2} = 5 $$\n由 $LSU$ 资源施加的 $ILP$ 上限为：\n$$ I_{LSU-bound}^{(M)} = \\frac{N_{LSU}}{p_{\\text{MEM}}^{(M)}} = \\frac{1}{3/5} = \\frac{5}{3} $$\n内存密集型混合的最大可持续 $ILP$ ($ILP_M$) 是这两个上界的最小值：\n$$ ILP_M = \\min\\left(5, \\frac{5}{3}\\right) = \\frac{5}{3} $$\n在这种情况下，单个 $LSU$ 是瓶颈。\n\n**比率计算**\n最后，我们计算整数密集型 $ILP$ 与内存密集型 $ILP$ 的比率：\n$$ \\text{Ratio} = \\frac{ILP_I}{ILP_M} $$\n代入计算出的值：\n$$ \\text{Ratio} = \\frac{2.5}{5/3} = \\frac{5/2}{5/3} = \\frac{5}{2} \\times \\frac{3}{5} = \\frac{15}{10} = \\frac{3}{2} $$\n将此表示为精确实数，得到 $1.5$。",
            "answer": "$$\\boxed{1.5}$$"
        },
        {
            "introduction": "除了硬件资源，代码本身固有的数据依赖性也设定了性能的根本极限。最长的数据依赖链，即“关键路径”，决定了任务执行所需的最短时间。通过这个练习，我们将探讨关键路径长度和处理器指令分发宽度如何共同决定最终的执行性能。",
            "id": "3651332",
            "problem": "一个程序基本块仅包含算术指令，并在两种基于相同流水线设计的微架构上执行：一个每周期最多能发射 $1$ 条指令的标量核心，以及一个每周期最多能发射 $w$ 条指令的超标量核心，其中 $w=4$。两个核心都是乱序执行，具有完美的寄存器重命名、无限制的指令窗口，以及足够多的相同整数算术功能单元，因此唯一的每周期资源限制是发射宽度。所有指令都是单周期整数算术运算，具有单位延迟，没有多周期效应。忽略缓存未命中、内存消歧、与真数据依赖无关的流水线气泡以及分支预测错误的所有影响。假设只有真数据依赖限制重排序。考虑基本块内的以下数据依赖关系：\n- 有一个长度为 $10$ 的单一真依赖链，由以下 $10$ 条指令（均为整数加法）组成，其中每条指令都依赖于列表中紧邻其前的一条指令：\n  $I_{1}$ 定义一个临时变量，$I_{2}$ 使用 $I_{1}$ 的结果，$I_{3}$ 使用 $I_{2}$ 的结果，以此类推，直到 $I_{10}$ 使用 $I_{9}$ 的结果。\n- 此外，还有 $17$ 条其他算术指令，它们彼此相互独立，并且也独立于上述的 $10$ 指令链。\n\n设块中指令总数为 $N$，最长真依赖链的长度（以周期为单位，单位延迟下）为 $L$。每周期指令数（IPC）定义为，在遵守发射宽度限制和真数据依赖的最优乱序调度下，该基本块执行所退役的指令总数除以总周期数。\n\n在上述假设下，计算 $w=4$ 的超标量核心在独立执行此基本块时所能达到的预期稳态 IPC。以精确值表示你的答案，无需四舍五入。",
            "solution": "问题陈述已经过评估并被认为是有效的。这是一个在计算机体系结构领域中定义明确、自成体系的问题，它基于指令级并行和超标量处理器性能分析的既定原则。所有必要的参数和简化假设都已提供。\n\n目标是计算一个给定的基本块在超标量、乱序处理器上执行的每周期指令数（IPC）。IPC 定义为执行的指令总数除以执行所需的总周期数。\n\n设 $N$ 为基本块中的指令总数。\n设 $L$ 为最长真依赖链的长度，以周期为单位。\n设 $w$ 为超标量核心的最大发射宽度。\n\n根据问题陈述，我们已知：\n有一个由 $10$ 条指令组成的单一真依赖链。\n有 $17$ 条其他指令，它们独立于该链并且相互独立。\n发射宽度为 $w=4$。\n所有指令的单位延迟为 $1$ 个周期。\n\n首先，我们确定指令总数 $N$。这是依赖链中的指令数和独立指令数之和。\n$$N = 10 + 17 = 27$$\n\n接下来，我们确定关键路径的长度 $L$。问题陈述中指出，有一个由 $10$ 条指令组成的链，其中每条指令 $I_{k+1}$ 都依赖于前一条指令 $I_k$ 的结果。由于每条指令的延迟为 $1$ 个周期，因此该链的执行是顺序的。假设 $I_1$ 在周期 $1$ 发射并执行。其结果在周期 $2$ 开始时可用。因此，$I_2$ 可以在周期 $2$ 发射并执行。这个过程沿着链继续下去，指令 $I_k$ 在周期 $k$ 执行。链中的最后一条指令 $I_{10}$ 只能在周期 $10$ 执行。它将在周期 $10$ 结束时完成。因此，决定了最小可能执行时间的关​​键依赖路径的长度是 $10$ 个周期。问题将此值定义为 $L$。\n$$L = 10 \\text{ cycles}$$\n\n乱序超标量处理器的性能受两个主要因素制约：\n$1$. 数据依赖，它定义了关键路径长度 ($L$)。总执行时间 $T$ 不能小于 $L$。\n$$T \\ge L$$\n$2$. 资源限制，主要是指令发射宽度 ($w$)。处理器每周期最多可以发射 $w$ 条指令。要执行 $N$ 条指令，即使在无限并行的情况下，也需要一个最小的周期数。\n$$w \\times T \\ge N \\implies T \\ge \\frac{N}{w}$$\n由于周期数 $T$ 必须是一个整数，这个基于资源的下限是 $T \\ge \\lceil \\frac{N}{w} \\rceil$。\n\n结合这两个界限，总执行时间 $T$ 必须至少是这两个下限中的最大值：\n$$T \\ge \\max\\left(L, \\left\\lceil \\frac{N}{w} \\right\\rceil\\right)$$\n让我们代入问题中的数值：\n$$T \\ge \\max\\left(10, \\left\\lceil \\frac{27}{4} \\right\\rceil\\right)$$\n$$T \\ge \\max(10, \\lceil 6.75 \\rceil)$$\n$$T \\ge \\max(10, 7)$$\n$$T \\ge 10 \\text{ cycles}$$\n\n这给出了执行时间的理论下限。我们现在需要验证 $T=10$ 个周期的执行时间是否可以实现。一个具有无限制指令窗口的乱序机器中的最优调度器会尝试用独立指令来填充每个周期的发射槽。\n\n关键路径要求在 $10$ 个周期中的每一个周期内执行一条指令。这会占用每个周期一个发射槽。发射宽度为 $w=4$，因此在执行关键路径指令的每个周期中，都有 $w-1 = 4-1 = 3$ 个额外的发射槽可用于独立指令。\n\n在由关键路径决定的 $L=10$ 个周期内，可用于独立指令的总槽位数是：\n$$ \\text{可用于独立工作的槽位} = (w-1) \\times L = (4-1) \\times 10 = 30 $$\n需要执行的独立指令数量是 $17$。\n\n由于独立指令的数量（$17$）小于与关键路径并行执行它们所需的可用槽位数（$30$），所有独立指令都可以在不将总执行时间延长到关键路径所需的 $10$ 个周期之外的情况下被发射和执行。\n\n让我们用一个明确的调度来说明：\n-   周期 $1$：发射 $I_1$（关键路径）和 $3$ 条独立指令。\n-   周期 $2$：发射 $I_2$（关键路径）和 $3$ 条独立指令。\n-   周期 $3$：发射 $I_3$（关键路径）和 $3$ 条独立指令。\n-   周期 $4$：发射 $I_4$（关键路径）和 $3$ 条独立指令。\n-   周期 $5$：发射 $I_5$（关键路径）和 $3$ 条独立指令。（总共已发射 $15$ 条独立指令）\n-   周期 $6$：发射 $I_6$（关键路径）和剩下的 $2$ 条独立指令。（所有 $17$ 条独立指令现已发射）\n-   周期 $7$：发射 $I_7$（关键路径）。\n-   周期 $8$：发射 $I_8$（关键路径）。\n-   周期 $9$：发射 $I_9$（关键路径）。\n-   周期 $10$：发射 $I_{10}$（关键路径）。\n\n在周期 $10$ 结束时，所有 $27$ 条指令都已发射。最后完成的指令是 $I_{10}$，它在周期 $10$ 发射，并由于其单位延迟而在周期 $10$ 结束时完成。所有其他指令完成的时间不晚于此。\n因此，总执行时间确实由关键路径长度决定。\n$$T = L = 10 \\text{ cycles}$$\n\n最后，我们可以计算 IPC。\n$$ \\text{IPC} = \\frac{\\text{指令总数}}{\\text{总周期数}} = \\frac{N}{T} $$\n$$ \\text{IPC} = \\frac{27}{10} = 2.7 $$\n该基本块的预期稳态 IPC 为 $2.7$。",
            "answer": "$$\\boxed{2.7}$$"
        },
        {
            "introduction": "并非所有依赖关系都会阻碍并行。有些是“伪”依赖，源于对存储位置（如寄存器）名称的重用，而非真正的数据流。这个练习将通过一个经典的标志寄存器例子，揭示这些伪依赖如何人为地串行化代码，并展示寄存器重命名技术是如何巧妙地消除它们以释放并行性的。",
            "id": "3654313",
            "problem": "一个现代的乱序超标量核心试图通过重叠执行独立的操作来发掘指令级并行（ILP），但这受限于数据相关和资源约束。考虑一台具有以下特性的机器：无限的功能单元，所有整数操作的延迟均为单周期，按序提交，通用寄存器重命名，以及一个单一的架构状态寄存器（SR），其中包含条件码（CC），如进位标志（CF）和零标志（ZF）。每条产生标志位的指令都会将整个SR作为一个架构名称进行写入，而每条消耗标志位的指令都会读取程序顺序中最近的前一条产生标志位的指令所产生的SR值。在该代码块内没有控制流的改变，并且我们假设在代码块之外有完美的推测和分支预测。该代码块是：\n\n- $I_1$: $ADD~r_1, r_2$; 写入 $SR$。\n- $I_2$: $ADC~r_3, r_4$; 从最近的前一个 $SR$ 写入者读取 $CF$，然后写入 $SR$。\n- $I_3$: $CMP~r_5, r_6$; 写入 $SR$。\n- $I_4$: $CMOVZ~r_7, r_8$; 从最近的前一个 $SR$ 写入者读取 $ZF$；不写入 $SR$。\n- $I_5$: $ADD~r_9, r_{10}$; 写入 $SR$。\n- $I_6$: $CMOVC~r_{11}, r_{12}$; 从最近的前一个 $SR$ 写入者读取 $CF$；不写入 $SR$。\n\n所有通用寄存器 $r_i$ 都是不同的，并且在指令之间不被重用，因此在通用寄存器上不存在数据相关。唯一的相关性来自于对 $SR$ 的读和写。该机器最初不支持标志位重命名；稍后，我们考虑一种可以重命名 $SR$ 的变体，它为每条产生标志位的指令分配一个不同的物理标志位版本，并将每条消耗标志位的指令链接到相应的生产者版本，从而在保留架构语义的同时，消除了对单一 $SR$ 的伪名相关。\n\n使用数据相关（写后读、读后写和写后写）的基本定义以及定义了消费者必须观察哪个 $SR$ 值的程序顺序语义，判断下列哪些陈述是正确的：\n\nA. 在没有标志位重命名的情况下，SR作为一个单一的架构名称，在$I_1$到$I_6$之间引入了一系列的写后读、读后写和写后写相关，迫使所有六条指令串行化执行；最小完成时间为$6$个周期，该代码块的平均ILP为$1$。\n\nB. 在有标志位重命名的情况下，三个生产者-消费者对 $\\left(I_1 \\rightarrow I_2\\right)$、$\\left(I_3 \\rightarrow I_4\\right)$ 和 $\\left(I_5 \\rightarrow I_6\\right)$ 成为独立的链，其消费者仅对各自的生产者存在写后读相关；通过在周期1发射$I_1$、$I_3$、$I_5$并在周期2发射$I_2$、$I_4$、$I_6$，最小完成时间减少到$2$个周期，从而得到平均ILP为$3$。\n\nC. 标志位重命名消除了对标志位的写后读相关，因此$I_2$、$I_4$和$I_6$可以分别与$I_1$、$I_3$和$I_5$在同一个周期发射。\n\nD. 在没有标志位重命名的情况下观察到的串行化，根本上是由于对单一SR的伪名相关（写后写和读后写）造成的，这些相关性将原本独立的生产者-消费者链连接在一起，并阻止乱序调度器重叠执行它们。\n\nE. 即使没有标志位重命名，$I_3$和$I_5$也可以并行发射，因为它们写入不同的条件码位（$ZF$和$CF$），所以在SR上没有写后写冒险。\n\n选择所有适用的选项。",
            "solution": "在进行求解之前，对问题陈述的有效性进行严格分析。\n\n### 步骤1：提取已知条件\n- **机器模型**：乱序超标量核心，无限功能单元，通用寄存器重命名，按序提交。\n- **指令延迟**：所有整数操作的延迟均为单周期。\n- **无重命名的状态寄存器（$SR$）**：存在一个单一的架构状态寄存器（$SR$），包含如进位标志（$CF$）和零标志（$ZF$）等条件码。每条产生标志位的指令都将*整个* $SR$ 作为一个单一的架构名称进行写入。每条消耗标志位的指令都从程序顺序中最近的前一条产生标志位的指令读取 $SR$ 值。\n- **有重命名的状态寄存器（$SR$）**：另一种机器配置支持对 $SR$ 进行重命名。每次对 $SR$ 的写入都被分配一个不同的物理版本，消费者被链接到正确的版本，从而消除了伪名相关（写后写和读后写）。\n- **指令序列**：\n    - $I_1$: $ADD~r_1, r_2$; 写入 $SR$。\n    - $I_2$: $ADC~r_3, r_4$; 从 $I_1$ 读取 $CF$，然后写入 $SR$。\n    - $I_3$: $CMP~r_5, r_6$; 写入 $SR$。\n    - $I_4$: $CMOVZ~r_7, r_8$; 从 $I_3$ 读取 $ZF$；不写入 $SR$。\n    - $I_5$: $ADD~r_9, r_{10}$; 写入 $SR$。\n    - $I_6$: $CMOVC~r_{11}, r_{12}$; 从 $I_5$ 读取 $CF$；不写入 $SR$。\n- **数据相关**：通用寄存器 $r_i$ 都是不同的，因此它们之间不存在相关性。相关性仅由 $SR$ 产生。\n\n### 步骤2：使用提取的已知条件进行验证\n- **科学依据**：该问题很好地植根于计算机组成与体系结构的原理，特别关注指令级并行（$ILP$）、数据相关（写后读、写后写、读后写）和寄存器重命名。这些都是现代高性能处理器设计中的基本概念。\n- **问题的明确性**：问题定义清晰。机器模型、指令语义和相关性规则都已明确，从而可以对指令块在两种指定场景（有无标志位重命名）下的执行时间和 $ILP$ 进行唯一且确定性的分析。\n- **客观性**：语言技术性强，精确，没有主观或含糊的术语。诸如“将整个SR作为一个架构名称进行写入”之类的约束是明确的，并且对分析至关重要。\n\n### 步骤3：结论与行动\n问题陈述是**有效的**。这是一个定义明确、科学合理的问题，可以通过严格应用数据相关性分析来解决。\n\n### 推导与选项分析\n\n我们来分析两种情况下的数据相关和执行调度。从指令$I_i$到$I_j$的相关性表示为 $I_i \\rightarrow I_j$。\n\n**情况1：无标志位重命名**\n\n在这种情况下，SR是一个单一的架构寄存器。我们必须识别所有三种类型的数据相关：\n- **写后读 (RAW)**：真正的相关性，一条指令消耗前一条指令产生的值。\n    - $I_1 \\rightarrow I_2$：$I_2$ 读取由 $I_1$ 产生的 $CF$。\n    - $I_3 \\rightarrow I_4$：$I_4$ 读取由 $I_3$ 产生的 $ZF$。\n    - $I_5 \\rightarrow I_6$：$I_6$ 读取由 $I_5$ 产生的 $CF$。\n- **写后写 (WAW)**：伪（名）相关，两条指令写入同一位置。为确保最终状态正确，写入必须按程序顺序进行。问题陈述说明整个SR作为一个名称被写入。\n    - $I_1 \\rightarrow I_2$, $I_1 \\rightarrow I_3$, $I_1 \\rightarrow I_5$\n    - $I_2 \\rightarrow I_3$, $I_2 \\rightarrow I_5$\n    - $I_3 \\rightarrow I_5$\n- **读后写 (WAR)**：伪（名）相关，一条指令写入一个先前指令读取的位置。写入操作不能在读取完成之前完成。\n    - $I_2 \\rightarrow I_3$：$I_2$ 读取 $SR$（来自 $I_1$），而 $I_3$ 写入 $SR$。为保留语义，$I_2$ 必须读取来自 $I_1$ 的值，而不是来自后面的指令 $I_3$。这迫使 $I_3$ 等待 $I_2$ 发射并读取其源操作数之后才能执行。\n    - $I_4 \\rightarrow I_5$：$I_4$ 读取 $SR$（来自 $I_3$），而 $I_5$ 写入 $SR$。这迫使 $I_5$ 等待 $I_4$ 读取其源操作数。\n\n结合这些相关性，我们形成了一个单一的相关链：\n$I_1 \\xrightarrow{\\text{RAW}} I_2 \\xrightarrow{\\text{WAR/WAW}} I_3 \\xrightarrow{\\text{RAW}} I_4 \\xrightarrow{\\text{WAR}} I_5 \\xrightarrow{\\text{RAW}} I_6$。\n这种完全的串行化意味着一次只能执行一条指令。鉴于每条指令的延迟为单周期，执行过程如下：\n- 周期 1: $I_1$ 执行。\n- 周期 2: $I_2$ 执行。\n- 周期 3: $I_3$ 执行。\n- 周期 4: $I_4$ 执行。\n- 周期 5: $I_5$ 执行。\n- 周期 6: $I_6$ 执行。\n完成这$6$条指令的总时间是$6$个周期。平均指令级并行（$ILP$）是指令数除以周期数，即 $6/6 = 1$。\n\n**情况2：有标志位重命名**\n\n标志位重命名通过为SR的每个新值分配一个唯一的物理存储位置来消除伪名相关（WAW和WAR）。只剩下真正的数据相关（RAW）。\nRAW相关如下：\n1.  $I_1 \\rightarrow I_2$\n2.  $I_3 \\rightarrow I_4$\n3.  $I_5 \\rightarrow I_6$\n\n伪相关（$I_2 \\rightarrow I_3$，$I_4 \\rightarrow I_5$ 等）被消除了。这将一个长的串行链分成了三个独立的、较短的链。由于有无限的功能单元，这三个链可以并行执行。\n执行调度如下：\n- **周期 1**：每个链的头部指令，即没有未决相关性的指令，可以同时发射：$I_1, I_3, I_5$。它们都在这个周期内完成。\n- **周期 2**：来自 $I_1, I_3$ 和 $I_5$ 的结果现在可用。相关的指令 $I_2, I_4$ 和 $I_6$ 可以同时发射。它们都在这个周期内完成。\n完成所有$6$条指令的总时间是$2$个周期。平均 $ILP$ 是 $6 / 2 = 3$。\n\n### 逐项分析\n\n**A. 在没有标志位重命名的情况下，SR作为一个单一的架构名称，在$I_1$到$I_6$之间引入了一系列的写后读、读后写和写后写相关，迫使所有六条指令串行化执行；最小完成时间为$6$个周期，该代码块的平均ILP为$1$。**\n我们对情况1的分析完全证实了这一陈述。在单一SR上的RAW、WAR和WAW相关的组合创建了一个串行相关链，导致执行时间为$6$个周期，ILP为$1$。\n**结论：正确。**\n\n**B. 在有标志位重命名的情况下，三个生产者-消费者对 $\\left(I_1 \\rightarrow I_2\\right)$、$\\left(I_3 \\rightarrow I_4\\right)$ 和 $\\left(I_5 \\rightarrow I_6\\right)$ 成为独立的链，其消费者仅对各自的生产者存在写后读相关；通过在周期1发射$I_1$、$I_3$、$I_5$并在周期2发射$I_2$、$I_4$、$I_6$，最小完成时间减少到$2$个周期，从而得到平均ILP为$3$。**\n我们对情况2的分析完全证实了这一陈述。重命名消除了伪相关，留下了三个独立的RAW链。并行执行调度、2个周期的完成时间以及3的平均ILP都是正确的。\n**结论：正确。**\n\n**C. 标志位重命名消除了对标志位的写后读相关，因此$I_2$、$I_4$和$I_6$可以分别与$I_1$、$I_3$和$I_5$在同一个周期发射。**\n这个陈述根本上是错误的。寄存器重命名是一种消除*伪*（名）相关（WAR和WAW）的技术，而不是*真*数据相关（RAW）。RAW相关代表了从生产者到消费者的基本数据流；消费者在接收到数据之前无法执行。因此，像$I_2$这样的消费者必须等待其生产者$I_1$完成。声称它们可以在同一周期发射是错误的。\n**结论：错误。**\n\n**D. 在没有标志位重命名的情况下观察到的串行化，根本上是由于对单一SR的伪名相关（写后写和读后写）造成的，这些相关性将原本独立的生产者-消费者链连接在一起，并阻止乱序调度器重叠执行它们。**\n这一陈述为两种情况之间的性能差异提供了正确的概念性解释。三个生产者-消费者对$(I_1, I_2)$、$(I_3, I_4)$和$(I_5, I_6)$在数据流方面是逻辑上独立的。然而，没有重命名，单一架构名称'$SR$'的重用会产生伪WAR和WAW相关（例如，在$I_2$和$I_3$之间，以及在$I_4$和$I_5$之间），这些相关将这些链连接在一起，迫使串行执行。这正是寄存器重命名所解决的问题。\n**结论：正确。**\n\n**E. 即使没有标志位重命名，$I_3$和$I_5$也可以并行发射，因为它们写入不同的条件码位（$ZF$和$CF$），所以在SR上没有写后写冒险。**\n这一陈述与问题的一个关键前提相矛盾：“每条产生标志位的指令都会将**整个SR作为一个架构名称**进行写入。”这意味着硬件将SR视为一个原子单元。任何写入都是对整个寄存器的写入，无论修改的是哪些单独的位。因此，在$I_3$和$I_5$之间存在WAW相关，阻止了它们的并行执行。所描述的机器不支持此选项所暗示的子寄存器粒度。\n**结论：错误。**",
            "answer": "$$\\boxed{ABD}$$"
        }
    ]
}