{
    "hands_on_practices": [
        {
            "introduction": "本练习是掌握动态多发射处理器核心原理的基础。通过手动模拟一个超标量处理器如何执行一系列指令，你将学会如何创建一个最优的指令发射调度方案。这项实践将帮助你深入理解如何处理数据依赖和功能单元资源冲突，从而最大限度地提高处理器的指令级并行度（ILP）和每周期指令数（IPC）。",
            "id": "3637599",
            "problem": "一个动态调度的超标量处理器使用动态多发射、乱序执行和寄存器重命名技术，每个周期发射多条指令。考虑在一个具有以下特征的处理器上执行一个基本块。\n\n- 超标量宽度为 $4$：如果存在足够的资源和就绪的操作数，每个周期最多可以发射 $4$ 条指令。\n- 有 $2$ 个用于整数加/减类型操作的算术逻辑单元 (ALU) 流水线和 $1$ 个用于整数乘法操作的乘法单元 (MUL) 流水线。该基本块中不使用其他指令类型。\n- ALU 的延迟为 $1$ 个周期，乘法单元 (MUL) 的延迟为 $3$ 个周期。所有流水线都是完全流水化的，每个流水线每个周期的发射率为 $1$ 个操作。\n- 结果是前递的，一个在周期 $t$ 发射且延迟为 $L$ 的操作，其产生的结果可以从周期 $t+L$ 开始被依赖的操作使用。\n- 存在完美的分支预测、无限的重命名寄存器、足够大的重排序缓冲区 (ROB)，并且没有缓存或内存停顿。\n- 提交宽度为 $4$，相对于发射和执行，它不会对此基本块产生约束。\n\n该基本块由以下 $12$ 个操作组成（寄存器名称是抽象的，除了由依赖关系明确指定的源操作数外，所有其他源操作数最初都是就绪的）：\n- $I_1$: $R_1 \\leftarrow R_2 + R_3$ (ALU)\n- $I_2$: $R_4 \\leftarrow R_5 \\times R_6$ (MUL)\n- $I_3$: $R_7 \\leftarrow R_8 + R_9$ (ALU)\n- $I_4$: $R_{10} \\leftarrow R_{11} + R_{12}$ (ALU)\n- $I_5$: $R_{13} \\leftarrow R_4 + R_{14}$ (ALU)，对 $I_2$ 有真依赖\n- $I_6$: $R_{15} \\leftarrow R_1 \\times R_{16}$ (MUL)，对 $I_1$ 有真依赖\n- $I_7$: $R_{17} \\leftarrow R_7 + R_{18}$ (ALU)，对 $I_3$ 有真依赖\n- $I_8$: $R_{19} \\leftarrow R_{20} \\times R_{10}$ (MUL)，对 $I_4$ 有真依赖\n- $I_9$: $R_{21} \\leftarrow R_{15} + R_{22}$ (ALU)，对 $I_6$ 有真依赖\n- $I_{10}$: $R_{23} \\leftarrow R_{19} + R_{24}$ (ALU)，对 $I_8$ 有真依赖\n- $I_{11}$: $R_{25} \\leftarrow R_{26} \\times R_{27}$ (MUL)\n- $I_{12}$: $R_{28} \\leftarrow R_{25} + R_{29}$ (ALU)，对 $I_{11}$ 有真依赖\n\n仅使用所述的架构约束和依赖关系，构建一个发射调度，以最小化此基本块的总执行时间（以周期为单位）。总执行时间定义为从第一条指令发射的周期（周期 $1$）到最后一条指令完成且其结果可供其消费者使用的周期（含）的总周期数。然后，计算在此时间间隔内最大化的平均每周期指令数 (IPC)，其定义为总指令数除以该总执行时间。\n\n将最终的 IPC 以实数形式给出，并四舍五入到四位有效数字。答案中不要包含任何单位。",
            "solution": "该问题陈述是计算机体系结构领域一个定义明确的练习，特别涉及动态调度超标量处理器上的指令级并行。它自成体系，具有科学依据，并提供了所有必要的数据和约束来推导出一个唯一的、最优的解决方案。因此，该问题是有效的。\n\n目标是确定一个给定的包含 $12$ 条指令的基本块的最小执行时间，并随后计算出最大平均每周期指令数 (IPC)。通过构建一个遵循数据依赖和资源约束的最优发射调度，可以最小化执行时间。\n\n首先，我们确定架构约束：\n- 超标量发射宽度：每个周期最多 $4$ 条指令。\n- 功能单元 (FU)：$2$ 个算术逻辑单元 (ALU) 和 $1$ 个乘法单元 (MUL)。\n- 指令延迟：在周期 $t$ 发射的、延迟为 $L$ 的操作，其结果在周期 $t+L$ 开始时提供给依赖指令。ALU 操作的延迟为 $L_{ALU} = 1$ 个周期，MUL 操作的延迟为 $L_{MUL} = 3$ 个周期。所有单元都是完全流水化的。\n- 要执行的总指令数为 $12$。\n\n接下来，我们分析指令之间的数据依赖关系。这些依赖关系形成了几个独立的链：\n- $I_1 \\rightarrow I_6 \\rightarrow I_9$\n- $I_2 \\rightarrow I_5$\n- $I_3 \\rightarrow I_7$\n- $I_4 \\rightarrow I_8 \\rightarrow I_{10}$\n- $I_{11} \\rightarrow I_{12}$\n\n没有前驱指令的指令（$I_1, I_2, I_3, I_4, I_{11}$）在执行开始时（即周期 $1$）就已准备好发射。\n\n我们将通过逐周期模拟发射过程来构建最优调度。在每个周期中，我们发射最大数量的就绪指令，上限为发射宽度 $4$ 条，并受限于可用的功能单元。我们采用贪心策略，优先处理就绪指令以最大化功能单元 (FU) 的利用率。当多个就绪指令可以选用同一个功能单元时，在这个特定问题中，选择哪个指令不会影响最终执行时间，因为竞争的依赖链具有对称的长度。我们将使用指令的索引作为平局决胜规则。\n\n**周期 1：**\n- 准备发射的指令：{$I_1$(ALU), $I_2$(MUL), $I_3$(ALU), $I_4$(ALU), $I_{11}$(MUL)}。\n- 可用资源：$2$ 个 ALU，$1$ 个 MUL。\n- 已发射：$I_1$ (在 ALU1 上)，$I_3$ (在 ALU2 上)，以及 $I_2$ (在 MUL 上)。共发射了 $3$ 条指令。\n- $I_1$ 在周期 $1$ 发射；其结果在周期 $1+L_{ALU} = 2$ 开始时就绪。\n- $I_3$ 在周期 $1$ 发射；其结果在周期 $1+L_{ALU} = 2$ 开始时就绪。\n- $I_2$ 在周期 $1$ 发射；其结果在周期 $1+L_{MUL} = 4$ 开始时就绪。\n\n**周期 2：**\n- 准备发射的指令：{$I_4$(ALU), $I_{11}$(MUL)}（在周期 $1$ 未发射），以及新就绪的指令。\n- 在周期 $2$ 开始时，$I_1$ 和 $I_3$ 的结果可用。这使得它们的依赖指令 $I_6$(MUL) 和 $I_7$(ALU) 变为就绪状态。\n- 完整的就绪指令集是 {$I_4$(ALU), $I_7$(ALU), $I_6$(MUL), $I_{11}$(MUL)}。\n- 可用资源：$2$ 个 ALU，$1$ 个 MUL。\n- 已发射：$I_4$ (在 ALU1 上)，$I_7$ (在 ALU2 上)，以及 $I_6$ (在 MUL 上)。共发射了 $3$ 条指令。\n- $I_4$ 在周期 $2$ 发射；结果在周期 $2+1 = 3$ 开始时就绪。\n- $I_7$ 在周期 $2$ 发射；结果在周期 $2+1 = 3$ 开始时就绪。\n- $I_6$ 在周期 $2$ 发射；结果在周期 $2+3 = 5$ 开始时就绪。\n\n**周期 3：**\n- 准备发射的指令：{$I_{11}$(MUL)}（之前未发射）。\n- 在周期 $3$ 开始时，$I_4$ 的结果可用，这使得 $I_8$(MUL) 变为就绪状态。\n- 完整的就绪指令集是 {$I_8$(MUL), $I_{11}$(MUL)}。\n- 可用资源：$2$ 个 ALU，$1$ 个 MUL。\n- 两条就绪指令都需要唯一的 MUL 单元。我们发射其中一条，$I_8$。共发射了 $1$ 条指令。\n- $I_8$ 在周期 $3$ 发射；结果在周期 $3+3 = 6$ 开始时就绪。\n\n**周期 4：**\n- 准备发射的指令：{$I_{11}$(MUL)}（之前未发射）。\n- 在周期 $4$ 开始时，$I_2$ 的结果可用，这使得 $I_5$(ALU) 变为就绪状态。\n- 完整的就绪指令集是 {$I_5$(ALU), $I_{11}$(MUL)}。\n- 可用资源：$2$ 个 ALU，$1$ 个 MUL。\n- 已发射：$I_5$ (在 ALU1 上) 和 $I_{11}$ (在 MUL 上)。共发射了 $2$ 条指令。\n- $I_5$ 在周期 $4$ 发射；结果在周期 $4+1 = 5$ 开始时就绪。\n- $I_{11}$ 在周期 $4$ 发射；结果在周期 $4+3 = 7$ 开始时就绪。\n\n**周期 5：**\n- 没有等待的指令。\n- 在周期 $5$ 开始时，$I_6$ 的结果可用，这使得 $I_9$(ALU) 变为就绪状态。\n- 完整的就绪指令集是 {$I_9$(ALU)}。\n- 已发射：$I_9$ (在 ALU1 上)。共发射了 $1$ 条指令。\n- $I_9$ 在周期 $5$ 发射；结果在周期 $5+1 = 6$ 开始时就绪。\n\n**周期 6：**\n- 没有等待的指令。\n- 在周期 $6$ 开始时，$I_8$ 的结果可用，这使得 $I_{10}$(ALU) 变为就绪状态。\n- 完整的就绪指令集是 {$I_{10}$(ALU)}。\n- 已发射：$I_{10}$ (在 ALU1 上)。共发射了 $1$ 条指令。\n- $I_{10}$ 在周期 $6$ 发射；结果在周期 $6+1 = 7$ 开始时就绪。\n\n**周期 7：**\n- 没有等待的指令。\n- 在周期 $7$ 开始时，$I_{11}$ 的结果可用，这使得 $I_{12}$(ALU) 变为就绪状态。\n- 完整的就绪指令集是 {$I_{12}$(ALU)}。\n- 已发射：$I_{12}$ (在 ALU1 上)。共发射了 $1$ 条指令。\n- $I_{12}$ 在周期 $7$ 发射；结果在周期 $7+1 = 8$ 开始时就绪。\n\n所有 $12$ 条指令现已全部发射。最终的调度和完成时间总结如下：\n\n| 指令        | 发射周期 | 结果就绪于周期开始时 |\n|-------------|----------|--------------------------|\n| $I_1$       | $1$      | $2$                      |\n| $I_2$       | $1$      | $4$                      |\n| $I_3$       | $1$      | $2$                      |\n| $I_4$       | $2$      | $3$                      |\n| $I_5$       | $4$      | $5$                      |\n| $I_6$       | $2$      | $5$                      |\n| $I_7$       | $2$      | $3$                      |\n| $I_8$       | $3$      | $6$                      |\n| $I_9$       | $5$      | $6$                      |\n| $I_{10}$    | $6$      | $7$                      |\n| $I_{11}$    | $4$      | $7$                      |\n| $I_{12}$    | $7$      | $8$                      |\n\n最后完成的指令是 $I_{12}$，其结果在周期 $8$ 开始时可用。根据问题的定义，总执行时间是从第一次发射（周期 $1$）到最后一个结果可用（周期 $8$）的周期数，包含两端。\n总执行时间, $T = 8 - 1 + 1 = 8$ 个周期。\n\n平均每周期指令数 (IPC) 是总指令数除以总执行时间。\n$$\n\\text{IPC} = \\frac{\\text{Total Instructions}}{T} = \\frac{12}{8} = 1.5\n$$\n问题要求答案四舍五入到四位有效数字。\n$$\n\\text{IPC} = 1.500\n$$\n这个调度是最佳的，因为主要瓶颈是唯一的 MUL 单元，它必须处理 $4$ 条乘法指令。我们的调度在数据依赖和资源可用性允许的情况下，在连续的 $4$ 个周期块（周期 $1$ 到周期 $4$）中使用了 MUL 单元，这无法再改进。最终的完成时间由链 $I_{11} \\rightarrow I_{12}$ 决定，其中 $I_{11}$ 是四条乘法指令中最后一条被发射的。",
            "answer": "$$\n\\boxed{1.500}\n$$"
        },
        {
            "introduction": "在掌握了基本的调度技巧后，我们来挑战一个更接近真实世界处理器的复杂场景。现代处理器包含多种不同类型的执行单元，并且对指令发射有着更严格的结构性约束。这项实践要求你在一个混合了整数、浮点和内存操作的指令序列中，仔细权衡资源分配，以找到最短的执行时间。这能有效地训练你在面对多重约束时进行性能优化的能力。",
            "id": "3637664",
            "problem": "一个超标量处理器支持动态多发射，并具有独立的整数和浮点流水线。每个周期的最大发射宽度为 $3$，并受以下结构性约束的限制：\n- 每个周期最多可以开始执行 $2$ 条整数类指令和最多 $1$ 条浮点类指令。\n- 所有内存操作（加载和存储）都属于整数类，并共享一个内存端口；每个周期最多可以开始 $1$ 次内存操作。\n- 功能单元是完全流水化的，可以在上述发射限制下每个周期接受一个新的操作。\n\n延迟模型如下（延迟 $\\ell$ 指的是在周期 $c$ 开始的指令所产生的结果，在周期 $c+\\ell$ 开始时对相关指令可用）：\n- 整数算术（例如，加法）延迟：$1$。\n- 整数或浮点加载延迟：整数加载 $=3$，浮点加载 $=4$。\n- 存储延迟：$1$（无结果，但在发射时占用内存端口 $1$ 个周期）。\n- 浮点加法延迟：$3$。\n- 浮点乘法延迟：$4$。\n- 整数到浮点转换延迟：$2$。\n\n假设采用带寄存器重命名（无伪相关）的乱序发射/执行，没有分支指令，也没有缓存未命中。所有基址寄存器和常数操作数在周期 $1$ 开始时初始就绪：\n- 整数寄存器 $R6$、$R10$、$R11$、$R12$、$R13$ 已就绪。\n- 浮点寄存器 $F3$ 已就绪。\n\n考虑以下混合代码片段，其中 $I_k$ 表示第 $k$ 条指令：\n- $I_1$：加载整数 $R1 \\leftarrow \\operatorname{Mem}[R10]$（整数类，延迟 $3$）。\n- $I_2$：加载整数 $R7 \\leftarrow \\operatorname{Mem}[R11]$（整数类，延迟 $3$）。\n- $I_3$：整数加法 $R2 \\leftarrow R1 + R7$（整数类，延迟 $1$）。\n- $I_4$：整数到浮点转换 $F4 \\leftarrow \\operatorname{I2F}(R2)$（浮点类，延迟 $2$）。\n- $I_5$：加载浮点数 $F1 \\leftarrow \\operatorname{Mem}[R12]$（整数类，延迟 $4$）。\n- $I_6$：浮点乘法 $F2 \\leftarrow F1 \\times F3$（浮点类，延迟 $4$）。\n- $I_7$：浮点加法 $F5 \\leftarrow F2 + F4$（浮点类，延迟 $3$）。\n- $I_8$：整数加法 $R8 \\leftarrow R2 + R6$（整数类，延迟 $1$）。\n- $I_9$：存储 $\\operatorname{Mem}[R13] \\leftarrow R8$（整数类，延迟 $1$）。\n\n依赖关系：\n- $I_3$ 依赖于 $I_1$ 和 $I_2$。\n- $I_4$ 依赖于 $I_3$。\n- $I_6$ 依赖于 $I_5$ 并使用就绪的操作数 $F3$。\n- $I_7$ 依赖于 $I_6$ 和 $I_4$。\n- $I_8$ 依赖于 $I_3$。\n- $I_9$ 依赖于 $I_8$。\n\n使用动态调度和流水线延迟的基本原理，并遵守发射宽度和结构性约束，确定从第一条指令发射开始，直到所有指令结果可用且存储操作完成所需的最少总周期数。请用整数周期数表示您的答案。",
            "solution": "该问题要求计算在特定的动态调度超标量处理器上执行给定指令序列所需的最少总周期数。为解决此问题，我们必须模拟指令的执行过程，并遵守所有指定约束：数据依赖、发射宽度和功能单元的结构限制。\n\n首先，我们对指令、它们的类别、延迟和依赖关系进行形式化描述。\n令 'Int' 表示整数类，'FP' 表示浮点类，'Mem' 表示内存操作。延迟用 $\\ell$ 表示。\n\n- $I_1$：`load integer` $R1 \\leftarrow \\operatorname{Mem}[R10]$（Int, Mem, $\\ell=3$）。无依赖。\n- $I_2$：`load integer` $R7 \\leftarrow \\operatorname{Mem}[R11]$（Int, Mem, $\\ell=3$）。无依赖。\n- $I_3$：`integer add` $R2 \\leftarrow R1 + R7$（Int, $\\ell=1$）。依赖于 $I_1, I_2$。\n- $I_4$：`integer-to-float` $F4 \\leftarrow \\operatorname{I2F}(R2)$（FP, $\\ell=2$）。依赖于 $I_3$。\n- $I_5$：`load float` $F1 \\leftarrow \\operatorname{Mem}[R12]$（Int, Mem, $\\ell=4$）。无依赖。注意：为了发射目的，该指令被指定为“整数类”。\n- $I_6$：`floating multiply` $F2 \\leftarrow F1 \\times F3$（FP, $\\ell=4$）。依赖于 $I_5$。\n- $I_7$：`floating add` $F5 \\leftarrow F2 + F4$（FP, $\\ell=3$）。依赖于 $I_4, I_6$。\n- $I_8$：`integer add` $R8 \\leftarrow R2 + R6$（Int, $\\ell=1$）。依赖于 $I_3$。\n- $I_9$：`store` $\\operatorname{Mem}[R13] \\leftarrow R8$（Int, Mem, $\\ell=1$）。依赖于 $I_8$。\n\n处理器约束如下：\n- 总发射宽度：最多 $3$ 条指令/周期。\n- 整数类发射宽度：最多 $2$ 条指令/周期。\n- 浮点类发射宽度：最多 $1$ 条指令/周期。\n- 内存端口：最多 $1$ 次内存操作（加载或存储）/周期。\n\n目标是找到一个最小化完成时间的最优调度。我们可以通过在每个周期做出贪心调度决策，优先处理关键路径上的指令来实现这一点。关键路径是就执行时间而言最长的依赖链。让我们分析从初始就绪指令（$I_1, I_2, I_5$）开始的主要依赖链上的延迟总和：\n- 经由 $I_5$ 的路径：$I_5 \\to I_6 \\to I_7$。延迟总和 = $\\ell(I_5) + \\ell(I_6) + \\ell(I_7) = 4 + 4 + 3 = 11$。\n- 经由 $I_1/I_2$ 的路径：$I_1 \\to I_3 \\to I_4 \\to I_7$。延迟总和 = $\\ell(I_1) + \\ell(I_3) + \\ell(I_4) + \\ell(I_7) = 3 + 1 + 2 + 3 = 9$。\n- 经由 $I_1/I_2$ 的路径：$I_1 \\to I_3 \\to I_8 \\to I_9$。延迟总和 = $\\ell(I_1) + \\ell(I_3) + \\ell(I_8) + \\ell(I_9) = 3 + 1 + 1 + 1 = 6$。\n以 $I_5$ 开始的路径具有最长的延迟总和，这表明它是关键路径。因此，为了最小化总执行时间，$I_5$ 应被尽早调度。\n\n我们现在进行逐周期模拟。如果一条指令的所有数据依赖都已满足，则它位于“就绪集”中。\n- **初始状态（周期 1 开始时）：** 就绪集为 {$I_1, I_2, I_5$}。\n\n- **周期 1：**\n  - 就绪集：{$I_1, I_2, I_5$}。它们都是内存操作，所以只能发射一个。\n  - 决策：发射 $I_5$ 以优先处理关键路径。\n  - 已发射：{$I_5$}。使用资源：$1$ 个整数类槽位，$1$ 个内存端口。\n  - 状态：$I_5$ 开始执行。其结果将在周期 $1 + \\ell(I_5) = 1 + 4 = 5$ 开始时就绪。\n\n- **周期 2：**\n  - 就绪集：{$I_1, I_2$}。两者都是内存操作。\n  - 决策：发射 $I_1$。\n  - 已发射：{$I_1$}。使用资源：$1$ 个整数类槽位，$1$ 个内存端口。\n  - 状态：$I_1$ 开始执行。结果在周期 $2 + \\ell(I_1) = 2 + 3 = 5$ 开始时就绪。\n\n- **周期 3：**\n  - 就绪集：{$I_2$}。\n  - 决策：发射 $I_2$。\n  - 已发射：{$I_2$}。使用资源：$1$ 个整数类槽位，$1$ 个内存端口。\n  - 状态：$I_2$ 开始执行。结果在周期 $3 + \\ell(I_2) = 3 + 3 = 6$ 开始时就绪。\n\n- **周期 4：**\n  - 就绪集：{}。没有指令的所有依赖都已满足。\n  - 已发射：{}。处理器停顿。\n\n- **周期 5：**\n  - 周期开始时状态：$I_1$ 和 $I_5$ 的结果现在可用。\n  - 就绪集：{$I_6$}（依赖于 $I_5$）。$I_3$ 尚未就绪，因为它仍需要 $I_2$。\n  - 决策：发射 $I_6$。\n  - 已发射：{$I_6$}。使用资源：$1$ 个浮点类槽位。\n  - 状态：$I_6$ 开始执行。结果在周期 $5 + \\ell(I_6) = 5 + 4 = 9$ 开始时就绪。\n\n- **周期 6：**\n  - 周期开始时状态：$I_2$ 的结果现在可用。\n  - 就绪集：{$I_3$}（依赖于 $I_1, I_2$）。\n  - 决策：发射 $I_3$。\n  - 已发射：{$I_3$}。使用资源：$1$ 个整数类槽位。\n  - 状态：$I_3$ 开始执行。结果在周期 $6 + \\ell(I_3) = 6 + 1 = 7$ 开始时就绪。\n\n- **周期 7：**\n  - 周期开始时状态：$I_3$ 的结果现在可用。\n  - 就绪集：{$I_4, I_8$}（都依赖于 $I_3$）。\n  - 决策：同时发射 $I_4$ 和 $I_8$。这是可行的，因为 $I_4$ 使用一个浮点槽位，$I_8$ 使用一个整数槽位，总发射宽度（$2$）在限制（$3$）之内。\n  - 已发射：{$I_4, I_8$}。使用资源：$1$ 个整数类槽位，$1$ 个浮点类槽位。\n  - 状态：$I_4$ 的结果在周期 $7 + \\ell(I_4) = 7 + 2 = 9$ 开始时就绪。$I_8$ 的结果在周期 $7 + \\ell(I_8) = 7 + 1 = 8$ 开始时就绪。\n\n- **周期 8：**\n  - 周期开始时状态：$I_8$ 的结果现在可用。\n  - 就绪集：{$I_9$}（依赖于 $I_8$）。\n  - 决策：发射 $I_9$。\n  - 已发射：{$I_9$}。使用资源：$1$ 个整数类槽位，$1$ 个内存端口。\n  - 状态：$I_9$ 是一个存储指令，在周期 $8$ 结束时完成其执行。\n\n- **周期 9：**\n  - 周期开始时状态：$I_4$ 和 $I_6$ 的结果现在可用。\n  - 就绪集：{$I_7$}（依赖于 $I_4, I_6$）。\n  - 决策：发射 $I_7$。\n  - 已发射：{$I_7$}。使用资源：$1$ 个浮点类槽位。\n  - 状态：$I_7$ 开始执行。结果在周期 $9 + \\ell(I_7) = 9 + 3 = 12$ 开始时就绪。\n\n- **周期 10、11：**\n  - 没有新的指令可发射。$I_7$ 继续执行。\n\n最终完成时间：\n问题要求找到直到所有结果可用且存储操作完成为止的总周期数。\n- 存储指令 $I_9$ 在周期 $8$ 结束时完成。\n- 最后一个可用的结果来自 $I_7$。它在周期 $9$ 发射，延迟为 $3$ 个周期。它在周期 $9, 10, 11$ 执行。\n- $I_7$ 的结果在周期 $12$ 开始时可用。这意味着它的执行在周期 $11$ 结束时完成。\n- 整个指令序列从周期 $1$ 开始执行，最后一条指令在周期 $11$ 结束时完成执行。\n- 因此，从周期 $1$ 的开始到周期 $11$ 的结束，总共经过的时间是 $11$ 个周期。\n\n让我们总结一下时间线：\n| 指令      | 发射周期 | 执行周期      | 结果可用时间（周期开始时） |\n|-------------|----------|-----------------|--------------------------------|\n| $I_5$       | $1$      | $1, 2, 3, 4$    | $5$                            |\n| $I_1$       | $2$      | $2, 3, 4$       | $5$                            |\n| $I_2$       | $3$      | $3, 4, 5$       | $6$                            |\n| $I_6$       | $5$      | $5, 6, 7, 8$    | $9$                            |\n| $I_3$       | $6$      | $6$             | $7$                            |\n| $I_4$       | $7$      | $7, 8$          | $9$                            |\n| $I_8$       | $7$      | $7$             | $8$                            |\n| $I_9$       | $8$      | $8$             | 不适用（存储，周期8结束时完成） |\n| $I_7$       | $9$      | $9, 10, 11$     | $12$                           |\n\n最后的指令 $I_7$ 在周期 $11$ 结束时完成执行。所有其他指令此时都已完成。总周期数是 $11$。",
            "answer": "$$ \\boxed{11} $$"
        },
        {
            "introduction": "精通微观层面的指令调度后，我们需要将视角提升到系统级性能分析。这个练习是一个思想实验，旨在揭示计算机体系结构中的一个关键原则：系统的整体性能受限于其最窄的瓶颈。通过分析这个场景，你将理解为什么简单地增加处理器的执行宽度并不总能带来性能提升，尤其是在受内存访问限制（memory-bound）的应用中。",
            "id": "3637569",
            "problem": "一个动态调度超标量处理器正在执行一个稳态单线程流式循环。该处理器具有乱序执行 (OoO) 功能，配备一个大小为 $R = 256$ 个条目的大型重排序缓冲 (ROB)，并且能够利用跨多个循环迭代的指令级并行。前端每个周期最多可以取指和译码 $D = 8$ 条指令，后端每个周期最多可以向功能单元发射 $W$ 条指令。指令引退按程序顺序进行，当指令就绪时，引退本身不构成瓶颈。\n\n每次迭代的循环体包含 $I = 16$ 条指令，其中包括一条加载指令，其地址流足够大，以至于总是在一级数据缓存 (L1D) 中缺失，并访问主内存。缺失服务时间为 $L = 200$ 个核心周期。L1D 支持多达 $M = 16$ 个缺失状态保持寄存器 (MSHRs)（缺失状态保持寄存器 (MSHR)：用于跟踪未完成的缓存缺失的结构），一旦所有 MSHR 都被分配，新的 L1D 缺失必须等到一个未完成的缺失处理完毕并释放一个 MSHR 后，才能发送到内存。假设每次迭代有足够多的独立算术指令，以便在等待内存时，处理器可以用后续迭代的指令填满 ROB，并且该循环每次迭代的单次加载缺失位于该次迭代引退的关键路径上。假设缺失率和延迟不受发射宽度的影响，并且当 $W$ 改变时缓存竞争不会增加。\n\n考虑将发射宽度从 $W = 2$ 增加到 $W = 8$，而不改变 $M$。根据内存层次结构中吞吐率和并发性的基本原理，哪个陈述最能描述此场景下稳态平均每周期指令数 (IPC)？\n\nA. 对于 $W = 2$ 和 $W = 8$，平均 $IPC$ 均保持在约 $1.28$，因为受 $M$ 和 $L$ 限制的缺失完成率限制了引退吞吐率。\n\nB. 平均 $IPC$ 从约 $1.28$ 增加到约 $2.00$，因为更宽的发射宽度能更快地执行非内存操作，从而在 MSHR 限制之外隐藏更多的内存延迟。\n\nC. 平均 $IPC$ 增加到约 $8.00$，因为当独立指令充足时，$IPC$ 与 $W$ 呈线性关系。\n\nD. 平均 $IPC$ 降低到约 $1.00$，因为更宽的发射宽度增加了缓存竞争，从而提高了缺失率。",
            "solution": "用户要求对问题陈述进行严格验证，然后严谨地推导解决方案并评估所有选项。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n- 处理器：动态调度超标量，乱序执行 (OoO)。\n- 重排序缓冲大小：$R = 256$ 个条目。\n- 前端宽度（取指/译码）：$D = 8$ 条指令/周期。\n- 后端宽度（发射）：$W$，分为 $W = 2$ 和 $W = 8$ 两种情况。\n- 循环迭代大小：$I = 16$ 条指令。\n- 关键路径：每次迭代恰好有一次加载，该加载总是在 L1D 缓存中缺失。\n- L1D 缺失延迟：$L = 200$ 个核心周期。\n- 内存级并行度限制：$M = 16$ 个缺失状态保持寄存器 (MSHRs)。\n- MSHR 行为：当所有 $M$ 个 MSHR 都在使用时，新的缺失无法发送到内存。\n- 假设1：处理器有充足的独立非内存指令来隐藏延迟。\n- 假设2：每次迭代的单次加载缺失位于该次迭代引退的关键路径上。\n- 假设3：缺失率和延迟是恒定的，不受 $W$ 变化的影响。\n- 假设4：引退是按序的，其机制不是瓶颈。\n\n**步骤2：使用已知条件进行验证**\n1.  **科学性**：该问题是计算机体系结构性能分析中的一个典型案例研究。它使用标准模型和术语（OoO、IPC、ROB、MSHR、MLP）来探讨执行资源和内存系统限制之间的关系。该问题在科学上是合理的。\n2.  **良构性**：该问题是良构的。它提供了所有必要的数值和简化假设，以得出一个唯一的、定量的答案。问题精确地要求在发射宽度 $W$ 的两种不同条件下，计算稳态的每周期指令数 (IPC)。\n3.  **客观性**：该问题使用客观、技术性的语言陈述。没有主观或含糊的术语。\n4.  **不完整或矛盾的设置**：该问题是自洽且一致的。“缓存竞争没有增加”等假设旨在隔离正在研究的特定体系结构权衡，这是一种标准的教学技巧。所提供的值不会产生任何内部矛盾。\n5.  **不切实际或不可行**：参数（$L=200$，$M=16$，$R=256$，$W=8$）在现代高性能处理器的合理取值范围内，使得场景具有现实意义。\n6.  **伪深刻、琐碎或同义反复**：该问题并非琐碎。它要求解答者正确地为系统吞吐率建模，从几个潜在瓶颈中识别出主要的性能瓶颈，并对内存子系统应用定量分析（与利特尔法则相关）。\n\n**步骤3：结论与行动**\n问题陈述有效。将推导完整解决方案。\n\n### 解决方案推导\n\n稳态的每周期指令数 (IPC) 受处理器流水线中吞吐率最低的组件限制。我们必须分析前端、后端（发射宽度）和内存子系统所支持的最大 IPC。\n\n**1. 前端限制：**\n处理器每个周期最多可以取指和译码 $D=8$ 条指令。因此，$IPC \\le 8$。\n\n**2. 后端（发射）限制：**\n处理器每个周期最多可以发射 $W$ 条指令。\n- 对于 $W=2$，$IPC \\le 2$。\n- 对于 $W=8$，$IPC \\le 8$。\n\n**3. 内存子系统限制：**\n这是最关键的约束。循环每执行 $I=16$ 条指令，就会产生一次关键路径上的缓存缺失。处理器引退指令的速率从根本上受限于这些关键缺失被解决的速率。\n\n内存系统最多可以并发处理 $M=16$ 次缺失。每次缺失需要 $L=200$ 个周期才能完成。在饱和的稳态下，内存系统每 $L$ 个周期完成 $M$ 次缺失。\n最大缺失完成率为：\n$$ \\text{Rate}_{\\text{miss}} = \\frac{M}{L} = \\frac{16 \\text{ misses}}{200 \\text{ cycles}} = 0.08 \\frac{\\text{misses}}{\\text{cycle}} $$\n\n处理器产生缺失的速率与其 IPC 成正比。每 $I$ 条指令有 $1$ 次缺失。\n缺失产生率为：\n$$ \\text{Rate}_{\\text{gen}} = \\frac{1 \\text{ miss}}{I \\text{ instructions}} \\times IPC \\frac{\\text{instructions}}{\\text{cycle}} = \\frac{IPC}{I} \\frac{\\text{misses}}{\\text{cycle}} $$\n\n为了使系统在稳态下保持稳定，缺失产生率不能超过缺失完成率：\n$$ \\frac{IPC}{I} \\le \\frac{M}{L} $$\n这使我们能够计算出内存系统所允许的最大 IPC：\n$$ IPC \\le \\frac{M \\times I}{L} $$\n代入给定值：\n$$ IPC \\le \\frac{16 \\times 16}{200} = \\frac{256}{200} = 1.28 $$\n\n由于内存级并行度（$M$）和延迟（$L$）的限制，内存子系统对性能施加了一个硬性上限，即 $IPC = 1.28$。问题还提到 ROB 大小为 $R = 256$。对于关键路径延迟为 $L=200$ 个周期且吞吐率为 $IPC=1.28$ 的情况，从分派阶段到引退阶段之间在途的指令数量为 $L \\times IPC = 200 \\times 1.28 = 256$。这证实了 ROB 的大小是足够的，可以在不成为更严格瓶颈的情况下维持这一吞吐率水平。\n\n**场景分析：**\n\n**情况1：发射宽度 $W = 2$**\n潜在的 IPC 限制是：\n- 前端：$IPC \\le 8$\n- 后端：$IPC \\le 2$\n- 内存：$IPC \\le 1.28$\n实际 IPC 是这些值的最小值。因此，$IPC = 1.28$。发射宽度 $W=2$ 足以支持此吞吐率，因为 $1.28  2$。\n\n**情况2：发射宽度 $W = 8$**\n潜在的 IPC 限制是：\n- 前端：$IPC \\le 8$\n- 后端：$IPC \\le 8$\n- 内存：$IPC \\le 1.28$\n实际 IPC 仍然是最小值，即 $IPC = 1.28$。根本瓶颈是内存系统的吞吐率，根据问题的明确假设，该吞吐率与发射宽度 $W$ 无关。将 $W$ 从 $2$ 增加到 $8$ 提供了更多的执行资源，但处理器无法使用它们，因为它是“内存受限”的——它受限于来自内存的数据，而不是功能单元。\n\n因此，在两种情况下，IPC 都保持在约 $1.28$。\n\n### 逐项分析\n\n**A. 对于 $W = 2$ 和 $W = 8$，平均 $IPC$ 均保持在约 $1.28$，因为受 $M$ 和 $L$ 限制的缺失完成率限制了引退吞吐率。**\n这个陈述与推导完全一致。计算得出的 IPC 在 $W=2$ 和 $W=8$ 时均为 $1.28$。其给出的原因——性能受限于缺失完成率（$\\frac{M}{L}$），而该速率又制约了引退——是正确的物理和定量解释。\n**结论：正确**\n\n**B. 平均 $IPC$ 从约 $1.28$ 增加到约 $2.00$，因为更宽的发射宽度能更快地执行非内存操作，从而在 MSHR 限制之外隐藏更多的内存延迟。**\n这是不正确的。IPC 受 MSHR 容量和内存延迟的限制，上限为 $1.28$。“在 MSHR 限制之外隐藏更多的内存延迟”这一说法在问题的规则下是不可能实现的；一旦 $M=16$ 个 MSHR 全部占满，就无法发起新的缺失。内存级并行度不能超过 $M$。\n**结论：不正确**\n\n**C. 平均 $IPC$ 增加到约 $8.00$，因为当独立指令充足时，$IPC$ 与 $W$ 呈线性关系。**\n这是不正确的。它忽略了瓶颈原理（或阿姆达尔定律）。系统的性能由其最慢的组件决定。在这种情况下，内存系统吞吐率是瓶颈，而不是发射宽度。虽然存在大量独立指令，但如果关键路径上的内存操作无法足够快地得到服务，这些指令也无法执行。\n**结论：不正确**\n\n**D. 平均 $IPC$ 降低到约 $1.00$，因为更宽的发射宽度增加了缓存竞争，从而提高了缺失率。**\n这是不正确的，因为它违反了问题陈述中的一个直接假设：“假设缺失率和延迟不受发射宽度的影响，并且当 $W$ 改变时缓存竞争不会增加。” 解决方案必须在所提供的模型框架内推导。\n**结论：不正确**",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}