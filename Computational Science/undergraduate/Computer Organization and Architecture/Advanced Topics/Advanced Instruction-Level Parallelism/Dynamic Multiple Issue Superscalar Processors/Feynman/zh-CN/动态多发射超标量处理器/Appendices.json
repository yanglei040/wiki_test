{
    "hands_on_practices": [
        {
            "introduction": "理论学习之后，最好的巩固方式就是亲自动手。本节的第一个练习将带你扮演动态超标量处理器中调度器的角色。通过对一个简单的指令序列进行逐周期调度，你将深入理解数据依赖、资源约束和指令延迟是如何共同作用，从而决定处理器性能的。这个练习旨在帮助你掌握最大化指令级并行度的基本技巧，并计算关键的性能指标——每周期指令数（IPC）。",
            "id": "3637599",
            "problem": "一个动态调度的超标量处理器使用动态多发射、乱序执行和寄存器重命名技术，每个周期发射多条指令。考虑在一个具有以下特征的处理器上执行一个基本块。\n\n- 超标量宽度为 $4$：如果存在足够的资源和就绪的操作数，每个周期最多可发射 $4$ 条指令。\n- 有 $2$ 个算术逻辑单元 (ALU) 流水线用于整数加/减法类型操作，以及 $1$ 个乘法单元 (MUL) 流水线用于整数乘法操作。此块中不使用其他指令类型。\n- ALU 的延迟为 $1$ 个周期，乘法单元 (MUL) 的延迟为 $3$ 个周期。所有流水线都是完全流水线化的，每个流水线的发射率为每个周期 $1$ 个操作。\n- 结果会被前向传递，在周期 $t$ 发射的、延迟为 $L$ 的操作所产生的结果，可以在周期 $t+L$ 开始时被相关的后续操作使用。\n- 存在完美的分支预测，无限的重命名寄存器，足够大的重排序缓存 (ROB)，并且没有缓存或内存停顿。\n- 提交宽度为 $4$，相对于发射和执行，它不会对此块构成约束。\n\n该基本块包含以下 $12$ 个操作（寄存器名称是抽象的，除了由相关性明确指定的源操作数外，所有其他源操作数初始时都是就绪的）：\n- $I_1$: $R_1 \\leftarrow R_2 + R_3$ (ALU)\n- $I_2$: $R_4 \\leftarrow R_5 \\times R_6$ (MUL)\n- $I_3$: $R_7 \\leftarrow R_8 + R_9$ (ALU)\n- $I_4$: $R_{10} \\leftarrow R_{11} + R_{12}$ (ALU)\n- $I_5$: $R_{13} \\leftarrow R_4 + R_{14}$ (ALU)，对 $I_2$ 有真相关\n- $I_6$: $R_{15} \\leftarrow R_1 \\times R_{16}$ (MUL)，对 $I_1$ 有真相关\n- $I_7$: $R_{17} \\leftarrow R_7 + R_{18}$ (ALU)，对 $I_3$ 有真相关\n- $I_8$: $R_{19} \\leftarrow R_{20} \\times R_{10}$ (MUL)，对 $I_4$ 有真相关\n- $I_9$: $R_{21} \\leftarrow R_{15} + R_{22}$ (ALU)，对 $I_6$ 有真相关\n- $I_{10}$: $R_{23} \\leftarrow R_{19} + R_{24}$ (ALU)，对 $I_8$ 有真相关\n- $I_{11}$: $R_{25} \\leftarrow R_{26} \\times R_{27}$ (MUL)\n- $I_{12}$: $R_{28} \\leftarrow R_{25} + R_{29}$ (ALU)，对 $I_{11}$ 有真相关\n\n仅使用所述的架构约束和相关性，构建一个发射调度，以最小化该块的总执行时间（以周期为单位）。总执行时间定义为从任何指令被发射的第一个周期（周期 $1$）到最后一条指令完成并其结果可供其消费者使用的周期（含）的总周期数。然后计算在此区间内最大化的平均每周期指令数 (IPC)，其定义为总指令数除以总执行时间。\n\n以保留四位有效数字的实数形式提供最终的 IPC。答案中不要包含任何单位。",
            "solution": "该问题陈述是计算机体系结构领域中一个定义明确的练习，具体涉及动态调度超标量处理器上的指令级并行。问题是自包含的，具有科学依据，并提供了推导唯一最优解所需的所有数据和约束。因此，该问题是有效的。\n\n目标是确定给定包含 $12$ 条指令的基本块的最小执行时间，并随后计算最大平均每周期指令数 (IPC)。通过构建一个遵循数据相关性和资源约束的最优发射调度，可以最小化执行时间。\n\n首先，我们确定架构约束：\n- 超标量发射宽度：每个周期最多 $4$ 条指令。\n- 功能单元 (FU)：$2$ 个算术逻辑单元 (ALU) 和 $1$ 个乘法单元 (MUL)。\n- 指令延迟：在周期 $t$ 发射、延迟为 $L$ 的操作，其结果在周期 $t+L$ 开始时对相关指令可用。ALU 操作的延迟为 $L_{ALU} = 1$ 个周期，MUL 操作的延迟为 $L_{MUL} = 3$ 个周期。所有单元都是完全流水线化的。\n- 需要执行的总指令数是 $12$ 条。\n\n接下来，我们分析指令之间的数据相关性。这些相关性形成了几个独立链：\n- $I_1 \\rightarrow I_6 \\rightarrow I_9$\n- $I_2 \\rightarrow I_5$\n- $I_3 \\rightarrow I_7$\n- $I_4 \\rightarrow I_8 \\rightarrow I_{10}$\n- $I_{11} \\rightarrow I_{12}$\n\n没有前驱指令的指令（$I_1, I_2, I_3, I_4, I_{11}$）在执行开始时，即周期 $1$，就已准备好发射。\n\n我们将通过逐周期模拟发射过程来构建一个最优调度。在每个周期中，我们发射最大数量的就绪指令，最多不超过 $4$ 条的发射宽度，并受限于可用的功能单元。我们采用贪心策略，优先处理就绪指令以最大化功能单元的利用率。当多个就绪指令可以选用同一个功能单元时，在这个特定问题中，选择哪个指令不会影响最终的执行时间，因为竞争的相关链长度对称。我们将使用指令的索引作为决胜的依据。\n\n**周期 1:**\n- 准备发射的指令：{$I_1$(ALU), $I_2$(MUL), $I_3$(ALU), $I_4$(ALU), $I_{11}$(MUL)}。\n- 可用资源：$2$ 个 ALU，$1$ 个 MUL。\n- 已发射：$I_1$ (在 ALU1 上), $I_3$ (在 ALU2 上), 和 $I_2$ (在 MUL 上)。共发射 $3$ 条指令。\n- $I_1$ 在周期 $1$ 发射；其结果在周期 $1+L_{ALU} = 2$ 开始时就绪。\n- $I_3$ 在周期 $1$ 发射；其结果在周期 $1+L_{ALU} = 2$ 开始时就绪。\n- $I_2$ 在周期 $1$ 发射；其结果在周期 $1+L_{MUL} = 4$ 开始时就绪。\n\n**周期 2:**\n- 准备发射的指令：{$I_4$(ALU), $I_{11}$(MUL)} (在周期 $1$ 未发射)，以及新就绪的指令。\n- 在周期 $2$ 开始时，$I_1$ 和 $I_3$ 的结果可用。这使其后继指令 $I_6$(MUL) 和 $I_7$(ALU) 变为就绪。\n- 完整的就绪集是 {$I_4$(ALU), $I_7$(ALU), $I_6$(MUL), $I_{11}$(MUL)}。\n- 可用资源：$2$ 个 ALU，$1$ 个 MUL。\n- 已发射：$I_4$ (ALU1), $I_7$ (ALU2), 和 $I_6$ (MUL)。共发射 $3$ 条指令。\n- $I_4$ 在周期 $2$ 发射；结果在周期 $2+1 = 3$ 开始时就绪。\n- $I_7$ 在周期 $2$ 发射；结果在周期 $2+1 = 3$ 开始时就绪。\n- $I_6$ 在周期 $2$ 发射；结果在周期 $2+3 = 5$ 开始时就绪。\n\n**周期 3:**\n- 准备发射的指令：{$I_{11}$(MUL)} (之前未发射)。\n- 在周期 $3$ 开始时，$I_4$ 的结果可用，使 $I_8$(MUL) 变为就绪。\n- 完整的就绪集是 {$I_8$(MUL), $I_{11}$(MUL)}。\n- 可用资源：$2$ 个 ALU，$1$ 个 MUL。\n- 两条就绪指令都需要唯一的 MUL 单元。我们发射其中一个，$I_8$。共发射 $1$ 条指令。\n- $I_8$ 在周期 $3$ 发射；结果在周期 $3+3 = 6$ 开始时就绪。\n\n**周期 4:**\n- 准备发射的指令：{$I_{11}$(MUL)} (之前未发射)。\n- 在周期 $4$ 开始时，$I_2$ 的结果可用，使 $I_5$(ALU) 变为就绪。\n- 完整的就绪集是 {$I_5$(ALU), $I_{11}$(MUL)}。\n- 可用资源：$2$ 个 ALU，$1$ 个 MUL。\n- 已发射：$I_5$ (ALU1) 和 $I_{11}$ (MUL)。共发射 $2$ 条指令。\n- $I_5$ 在周期 $4$ 发射；结果在周期 $4+1 = 5$ 开始时就绪。\n- $I_{11}$ 在周期 $4$ 发射；结果在周期 $4+3 = 7$ 开始时就绪。\n\n**周期 5:**\n- 没有等待的指令。\n- 在周期 $5$ 开始时，$I_6$ 的结果可用，使 $I_9$(ALU) 变为就绪。\n- 完整的就绪集是 {$I_9$(ALU)}。\n- 已发射：$I_9$ (ALU1)。共发射 $1$ 条指令。\n- $I_9$ 在周期 $5$ 发射；结果在周期 $5+1 = 6$ 开始时就绪。\n\n**周期 6:**\n- 没有等待的指令。\n- 在周期 $6$ 开始时，$I_8$ 的结果可用，使 $I_{10}$(ALU) 变为就绪。\n- 完整的就绪集是 {$I_{10}$(ALU)}。\n- 已发射：$I_{10}$ (ALU1)。共发射 $1$ 条指令。\n- $I_{10}$ 在周期 $6$ 发射；结果在周期 $6+1 = 7$ 开始时就绪。\n\n**周期 7:**\n- 没有等待的指令。\n- 在周期 $7$ 开始时，$I_{11}$ 的结果可用，使 $I_{12}$(ALU) 变为就绪。\n- 完整的就绪集是 {$I_{12}$(ALU)}。\n- 已发射：$I_{12}$ (ALU1)。共发射 $1$ 条指令。\n- $I_{12}$ 在周期 $7$ 发射；结果在周期 $7+1 = 8$ 开始时就绪。\n\n所有 $12$ 条指令现已发射完毕。最终的调度和完成时间总结如下：\n\n| 指令        | 发射周期 | 结果就绪于周期开始时 |\n|-------------|----------|------------------------|\n| $I_1$       | $1$      | $2$                    |\n| $I_2$       | $1$      | $4$                    |\n| $I_3$       | $1$      | $2$                    |\n| $I_4$       | $2$      | $3$                    |\n| $I_5$       | $4$      | $5$                    |\n| $I_6$       | $2$      | $5$                    |\n| $I_7$       | $2$      | $3$                    |\n| $I_8$       | $3$      | $6$                    |\n| $I_9$       | $5$      | $6$                    |\n| $I_{10}$    | $6$      | $7$                    |\n| $I_{11}$    | $4$      | $7$                    |\n| $I_{12}$    | $7$      | $8$                    |\n\n最后完成的指令是 $I_{12}$，其结果在周期 $8$ 开始时可用。根据问题的定义，总执行时间是从第一次发射（周期 $1$）到最后一个结果可用（周期 $8$）的周期数，包含两端。\n总执行时间, $T = 8 - 1 + 1 = 8$ 个周期。\n\n平均每周期指令数 (IPC) 是总指令数除以总执行时间。\n$$\n\\text{IPC} = \\frac{\\text{总指令数}}{T} = \\frac{12}{8} = 1.5\n$$\n问题要求答案保留四位有效数字。\n$$\n\\text{IPC} = 1.500\n$$\n这个调度是最优的，因为主要的瓶颈是单个 MUL 单元，它必须处理 $4$ 条乘法指令。我们的调度在数据相关性和资源可用性允许的情况下，在连续的 $4$ 个周期（周期 $1$ 至 $4$）内使用了 MUL 单元，这已无法改进。最终的完成时间由链 $I_{11} \\rightarrow I_{12}$ 决定，其中 $I_{11}$ 是四条乘法指令中最后一条被发射的。",
            "answer": "$$\n\\boxed{1.500}\n$$"
        },
        {
            "introduction": "在掌握了基本的调度原则后，让我们来挑战一个更接近真实处理器所面临的复杂场景。这个练习引入了混合类型的指令（整数和浮点数）、非对称的功能单元限制，以及一个关键的共享资源——单一的内存访问端口。通过解决这个问题，你将学会如何在多重约束下识别并优先处理关键路径上的指令，这对于理解现代处理器如何应对结构性冲突和资源竞争至关重要。",
            "id": "3637664",
            "problem": "一个超标量处理器支持动态多发射，并拥有独立的整数和浮点流水线。每个周期的最大发射宽度为 $3$，并受以下结构约束的限制：\n- 每周期最多可以开始执行 $2$ 条整数类指令和最多 $1$ 条浮点类指令。\n- 所有内存操作（加载和存储）都属于整数类指令，并共享一个内存端口；每周期最多可以开始执行 $1$ 次内存操作。\n- 功能单元是完全流水化的，在上述发射限制下，每个周期可以接受一个新的操作。\n\n延迟模型如下（延迟 $\\ell$ 表示在周期 $c$ 开始的指令所产生的结果，在周期 $c+\\ell$ 开始时对相关指令可用）：\n- 整数算术（例如，加法）延迟：$1$。\n- 整数或浮点加载延迟：整数加载 $=3$，浮点加载 $=4$。\n- 存储延迟：$1$（无结果，但在发射时占用内存端口 $1$ 个周期）。\n- 浮点加法延迟：$3$。\n- 浮点乘法延迟：$4$。\n- 整数到浮点转换延迟：$2$。\n\n假设采用乱序发射/执行和寄存器重命名（无伪相关），没有分支指令，也没有缓存未命中。所有基址寄存器和常数操作数在周期 $1$ 开始时初始就绪：\n- 整数寄存器 $R6$、$R10$、$R11$、$R12$、$R13$ 已就绪。\n- 浮点寄存器 $F3$ 已就绪。\n\n考虑以下混合代码片段，其中 $I_k$ 表示第 $k$ 条指令：\n- $I_1$: 整数加载 $R1 \\leftarrow \\operatorname{Mem}[R10]$ (整数类，延迟 $3$)。\n- $I_2$: 整数加载 $R7 \\leftarrow \\operatorname{Mem}[R11]$ (整数类，延迟 $3$)。\n- $I_3$: 整数加法 $R2 \\leftarrow R1 + R7$ (整数类，延迟 $1$)。\n- $I_4$: 整数到浮点转换 $F4 \\leftarrow \\operatorname{I2F}(R2)$ (浮点类，延迟 $2$)。\n- $I_5$: 浮点加载 $F1 \\leftarrow \\operatorname{Mem}[R12]$ (整数类，延迟 $4$)。\n- $I_6$: 浮点乘法 $F2 \\leftarrow F1 \\times F3$ (浮点类，延迟 $4$)。\n- $I_7$: 浮点加法 $F5 \\leftarrow F2 + F4$ (浮点类，延迟 $3$)。\n- $I_8$: 整数加法 $R8 \\leftarrow R2 + R6$ (整数类，延迟 $1$)。\n- $I_9$: 存储 $\\operatorname{Mem}[R13] \\leftarrow R8$ (整数类，延迟 $1$)。\n\n依赖关系：\n- $I_3$ 依赖于 $I_1$ 和 $I_2$。\n- $I_4$ 依赖于 $I_3$。\n- $I_6$ 依赖于 $I_5$ 并使用就绪的操作数 $F3$。\n- $I_7$ 依赖于 $I_6$ 和 $I_4$。\n- $I_8$ 依赖于 $I_3$。\n- $I_9$ 依赖于 $I_8$。\n\n请根据动态调度和流水线延迟的基本原理，并遵循发射宽度和结构约束，确定从第一条指令发射开始，直到所有指令结果可用且存储操作完成所需的最少总周期数。以整数周期数表示你的答案。",
            "solution": "该问题要求计算在一个特定的动态调度超标量处理器上执行给定指令序列所需的最小总周期数。为了解决这个问题，我们必须模拟指令的执行过程，同时遵守所有指定的约束：数据依赖、发射宽度以及功能单元的结构限制。\n\n首先，我们对指令、它们的类别、延迟和依赖关系进行形式化描述。\n令 'Int' 表示整数类，'FP' 表示浮点类，'Mem' 表示内存操作。延迟用 $\\ell$ 表示。\n\n- $I_1$: `整数加载` $R1 \\leftarrow \\operatorname{Mem}[R10]$ (Int, Mem, $\\ell=3$)。无依赖。\n- $I_2$: `整数加载` $R7 \\leftarrow \\operatorname{Mem}[R11]$ (Int, Mem, $\\ell=3$)。无依赖。\n- $I_3$: `整数加法` $R2 \\leftarrow R1 + R7$ (Int, $\\ell=1$)。依赖于 $I_1, I_2$。\n- $I_4$: `整数到浮点` $F4 \\leftarrow \\operatorname{I2F}(R2)$ (FP, $\\ell=2$)。依赖于 $I_3$。\n- $I_5$: `浮点加载` $F1 \\leftarrow \\operatorname{Mem}[R12]$ (Int, Mem, $\\ell=4$)。无依赖。注意：为了发射目的，该指令被指定为“整数类”。\n- $I_6$: `浮点乘法` $F2 \\leftarrow F1 \\times F3$ (FP, $\\ell=4$)。依赖于 $I_5$。\n- $I_7$: `浮点加法` $F5 \\leftarrow F2 + F4$ (FP, $\\ell=3$)。依赖于 $I_4, I_6$。\n- $I_8$: `整数加法` $R8 \\leftarrow R2 + R6$ (Int, $\\ell=1$)。依赖于 $I_3$。\n- $I_9$: `存储` $\\operatorname{Mem}[R13] \\leftarrow R8$ (Int, Mem, $\\ell=1$)。依赖于 $I_8$。\n\n处理器约束如下：\n- 总发射宽度：最多 $3$ 条指令/周期。\n- 整数类指令发射宽度：最多 $2$ 条指令/周期。\n- 浮点类指令发射宽度：最多 $1$ 条指令/周期。\n- 内存端口：最多 $1$ 次内存操作（加载或存储）/周期。\n\n目标是找到一个最优调度以最小化完成时间。我们可以通过在每个周期做出贪心调度决策，优先处理关键路径上的指令来实现这一点。关键路径是执行时间上最长的依赖链。我们来分析一下从初始就绪指令（$I_1, I_2, I_5$）开始的主要依赖链的延迟总和：\n- 经由 $I_5$ 的路径：$I_5 \\to I_6 \\to I_7$。延迟总和 = $\\ell(I_5) + \\ell(I_6) + \\ell(I_7) = 4 + 4 + 3 = 11$。\n- 经由 $I_1/I_2$ 的路径：$I_1 \\to I_3 \\to I_4 \\to I_7$。延迟总和 = $\\ell(I_1) + \\ell(I_3) + \\ell(I_4) + \\ell(I_7) = 3 + 1 + 2 + 3 = 9$。\n- 经由 $I_1/I_2$ 的路径：$I_1 \\to I_3 \\to I_8 \\to I_9$。延迟总和 = $\\ell(I_1) + \\ell(I_3) + \\ell(I_8) + \\ell(I_9) = 3 + 1 + 1 + 1 = 6$。\n以 $I_5$ 开始的路径具有最长的延迟总和，这表明它是关键路径。因此，为了最小化总执行时间，应尽早调度 $I_5$。\n\n现在我们进行逐周期模拟。如果一条指令的所有数据依赖都已满足，它就处于“就绪集”中。\n- **初始状态（周期 1 开始）：** 就绪集为 {$I_1, I_2, I_5$}。\n\n- **周期 1：**\n  - 就绪集：{$I_1, I_2, I_5$}。所有都是内存操作，因此只能发射一个。\n  - 决策：发射 $I_5$ 以优先处理关键路径。\n  - 已发射：{$I_5$}。使用的资源：$1$ 个整数类槽位，$1$ 个内存端口。\n  - 状态：$I_5$ 开始执行。其结果将在周期 $1 + \\ell(I_5) = 1 + 4 = 5$ 开始时就绪。\n\n- **周期 2：**\n  - 就绪集：{$I_1, I_2$}。两者都是内存操作。\n  - 决策：发射 $I_1$。\n  - 已发射：{$I_1$}。使用的资源：$1$ 个整数类槽位，$1$ 个内存端口。\n  - 状态：$I_1$ 开始执行。结果将在周期 $2 + \\ell(I_1) = 2 + 3 = 5$ 开始时就绪。\n\n- **周期 3：**\n  - 就绪集：{$I_2$}。\n  - 决策：发射 $I_2$。\n  - 已发射：{$I_2$}。使用的资源：$1$ 个整数类槽位，$1$ 个内存端口。\n  - 状态：$I_2$ 开始执行。结果将在周期 $3 + \\ell(I_2) = 3 + 3 = 6$ 开始时就绪。\n\n- **周期 4：**\n  - 就绪集：{}。没有指令的所有依赖都得到满足。\n  - 已发射：{}。处理器停顿。\n\n- **周期 5：**\n  - 周期开始时状态：$I_1$ 和 $I_5$ 的结果现在可用。\n  - 就绪集：{$I_6$} (依赖于 $I_5$) 。$I_3$ 尚未就绪，因为它仍在等待 $I_2$。\n  - 决策：发射 $I_6$。\n  - 已发射：{$I_6$}。使用的资源：$1$ 个浮点类槽位。\n  - 状态：$I_6$ 开始执行。结果将在周期 $5 + \\ell(I_6) = 5 + 4 = 9$ 开始时就绪。\n\n- **周期 6：**\n  - 周期开始时状态：$I_2$ 的结果现在可用。\n  - 就绪集：{$I_3$} (依赖于 $I_1, I_2$) 。\n  - 决策：发射 $I_3$。\n  - 已发射：{$I_3$}。使用的资源：$1$ 个整数类槽位。\n  - 状态：$I_3$ 开始执行。结果将在周期 $6 + \\ell(I_3) = 6 + 1 = 7$ 开始时就绪。\n\n- **周期 7：**\n  - 周期开始时状态：$I_3$ 的结果现在可用。\n  - 就绪集：{$I_4, I_8$} (都依赖于 $I_3$) 。\n  - 决策：同时发射 $I_4$ 和 $I_8$。这是可能的，因为 $I_4$ 使用一个浮点槽位，$I_8$ 使用一个整数槽位，并且总发射宽度（$2$）在限制（$3$）之内。\n  - 已发射：{$I_4, I_8$}。使用的资源：$1$ 个整数类槽位，$1$ 个浮点类槽位。\n  - 状态：$I_4$ 的结果在 $7 + \\ell(I_4) = 7 + 2 = 9$ 开始时就绪。$I_8$ 的结果在 $7 + \\ell(I_8) = 7 + 1 = 8$ 开始时就绪。\n\n- **周期 8：**\n  - 周期开始时状态：$I_8$ 的结果现在可用。\n  - 就绪集：{$I_9$} (依赖于 $I_8$) 。\n  - 决策：发射 $I_9$。\n  - 已发射：{$I_9$}。使用的资源：$1$ 个整数类槽位，$1$ 个内存端口。\n  - 状态：$I_9$ 是一个存储操作，在周期 8 结束时完成执行。\n\n- **周期 9：**\n  - 周期开始时状态：$I_4$ 和 $I_6$ 的结果现在可用。\n  - 就绪集：{$I_7$} (依赖于 $I_4, I_6$) 。\n  - 决策：发射 $I_7$。\n  - 已发射：{$I_7$}。使用的资源：$1$ 个浮点类槽位。\n  - 状态：$I_7$ 开始执行。结果将在周期 $9 + \\ell(I_7) = 9 + 3 = 12$ 开始时就绪。\n\n- **周期 10, 11：**\n  - 没有新的指令可以发射。$I_7$ 继续执行。\n\n最终完成时间：\n问题要求找到从第一条指令发射开始，直到所有结果可用且存储操作完成所需的总周期数。\n- 存储指令 $I_9$ 在周期 $8$ 结束时完成。\n- 最后一个可用的结果来自 $I_7$。它在周期 $9$ 发射，延迟为 $3$ 个周期。它在周期 $9、10、11$ 执行。\n- $I_7$ 的结果在周期 $12$ 开始时可用。这意味着其执行在周期 $11$ 结束时完成。\n- 整个指令序列在周期 $1$ 开始执行，最后一条指令在周期 $11$ 结束时完成执行。\n- 因此，从周期 $1$ 开始到周期 $11$ 结束，总共经过的时间是 $11$ 个周期。\n\n我们来总结一下时间线：\n| 指令 | 发射周期 | 执行周期 | 结果可用时间（周期开始时） |\n|-------------|-------------|------------------|-----------------------------------|\n| $I_5$ | $1$ | $1, 2, 3, 4$ | $5$ |\n| $I_1$ | $2$ | $2, 3, 4$ | $5$ |\n| $I_2$ | $3$ | $3, 4, 5$ | $6$ |\n| $I_6$ | $5$ | $5, 6, 7, 8$ | $9$ |\n| $I_3$ | $6$ | $6$ | $7$ |\n| $I_4$ | $7$ | $7, 8$ | $9$ |\n| $I_8$ | $7$ | $7$ | $8$ |\n| $I_9$ | $8$ | $8$ | 不适用（存储指令，在周期8结束时完成） |\n| $I_7$ | $9$ | $9, 10, 11$ | $12$ |\n\n最后一条指令 $I_7$ 在周期 11 结束时完成执行。此时，所有其他指令均已完成。总周期数为 11。",
            "answer": "$$ \\boxed{11} $$"
        },
        {
            "introduction": "前面的练习侧重于“如何调度”，而本次实践则将我们的视角提升到“是什么限制了调度”的系统层面。这个思想实验旨在揭示计算机体系结构中的一个核心原则：系统的整体性能受限于其最慢的组件，即阿姆达尔定律的体现。通过分析为何增加核心的执行宽度并不总能带来性能提升，你将理解到内存子系统等部件是如何成为现代高性能处理器的真正瓶颈的，这对于培养系统性的性能分析思维至关重要。",
            "id": "3637569",
            "problem": "一个动态调度的超标量处理器执行一个稳态的单线程流式循环。该处理器具有乱序执行（OoO）能力和一个大小为 $R = 256$ 条目的大型重排序缓冲区（ROB），并且可以利用跨多个循环迭代的指令级并行。前端每个周期最多可以取指和译码 $D = 8$ 条指令，后端每个周期最多可以向功能单元发射 $W$ 条指令。指令按程序顺序退役，并且当指令就绪时，退役本身不会成为瓶颈。\n\n每个迭代的循环体包含 $I = 16$ 条指令，其中包括一条加载指令，其地址流足够大，以至于总是在一级数据缓存（L1D）中未命中，并需要访问主存。未命中服务时间为 $L = 200$ 个核心周期。L1D最多支持 $M = 16$ 个未命中状态保持寄存器（MSHRs）（未命中状态保持寄存器（MSHR）：跟踪未完成的缓存未命中的结构），一旦所有MSHRs被分配，新的L1D未命中就无法发送到内存，直到一个未完成的未命中完成并释放一个MSHR。假设每次迭代有足够多的独立算术指令，以便在等待内存时，处理器可以用后续迭代的指令填满ROB，并且该循环中每次迭代的单个未命中加载指令位于该迭代退役的关键路径上。假设未命中率和延迟不受发射宽度的影响，并且当 $W$ 改变时，缓存争用不会增加。\n\n考虑将发射宽度从 $W = 2$ 增加到 $W = 8$，而不改变 $M$。基于存储层次结构中吞吐率和并发性的基本原理，哪个陈述最能描述此场景下稳态的平均每周期指令数（IPC）？\n\nA. 对于 $W = 2$ 和 $W = 8$，$IPC$ 的平均值都保持在约 $1.28$，因为受 $M$ 和 $L$ 限制的未命中完成率限制了退役吞吐率。\n\nB. $IPC$ 的平均值从约 $1.28$ 增加到约 $2.00$，因为更宽的发射可以更快地执行非内存工作，从而在MSHR限制之外隐藏更多的内存延迟。\n\nC. $IPC$ 的平均值增加到约 $8.00$，因为当独立指令充足时，$IPC$ 会随 $W$ 线性扩展。\n\nD. $IPC$ 的平均值下降到约 $1.00$，因为更宽的发射增加了缓存争用，从而增加了未命中率。",
            "solution": "用户要求对问题陈述进行严格验证，然后严谨地推导解决方案并评估所有选项。\n\n### 问题验证\n\n**步骤 1：提取给定条件**\n- 处理器：动态调度超标量，乱序执行 (OoO)。\n- 重排序缓冲区大小：$R = 256$ 条目。\n- 前端宽度 (取指/译码)：$D = 8$ 指令/周期。\n- 后端宽度 (发射)：$W$，考虑 $W = 2$ 和 $W = 8$ 的情况。\n- 循环迭代大小：$I = 16$ 条指令。\n- 关键路径：每次迭代恰好有一次加载，该加载总是在 L1D 缓存中未命中。\n- L1D 未命中延迟：$L = 200$ 核心周期。\n- 内存级并行度限制：$M = 16$ 个未命中状态保持寄存器 (MSHRs)。\n- MSHR 行为：当所有 $M$ 个 MSHR 都在使用时，新的未命中无法发送到内存。\n- 假设 1：处理器有充足的独立非内存指令来隐藏延迟。\n- 假设 2：每次迭代的单个加载未命中位于该迭代退役的关键路径上。\n- 假设 3：未命中率和延迟是恒定的，不受 $W$ 变化的影响。\n- 假设 4：退役是按序的，其机制不是瓶颈。\n\n**步骤 2：使用提取的条件进行验证**\n1.  **科学依据**：该问题是计算机体系结构性能分析中的一个典型案例研究。它使用标准模型和术语（OoO, IPC, ROB, MSHR, MLP）来探讨执行资源和存储系统限制之间的关系。它在科学上是合理的。\n2.  **适定性**：该问题是适定的。它提供了所有必要的数值和简化假设，从而能够得出一个唯一的、定量的答案。问题精确地要求在两种不同的发射宽度 $W$ 条件下计算稳态的每周期指令数（IPC）。\n3.  **客观性**：问题使用了客观、技术性的语言陈述。没有主观或模糊的术语。\n4.  **不完整或矛盾的设置**：问题是自洽且一致的。诸如“缓存争用不会增加”之类的假设，旨在分离出正在研究的特定体系结构权衡，这是一种标准的教学技巧。所提供的值不会产生任何内部矛盾。\n5.  **不切实际或不可行**：参数（$L=200$, $M=16$, $R=256$, $W=8$）在现代高性能处理器的合理值范围内，使得该场景是现实的。\n6.  **伪深刻、琐碎或同义反复**：该问题并非琐碎。它要求解答者正确地为系统吞吐率建模，从几个潜在的候选项中识别出主要的性能瓶颈，并对存储子系统应用定量分析（与利特尔定律相关）。\n\n**步骤 3：结论和行动**\n问题陈述有效。将推导完整的解决方案。\n\n### 解决方案推导\n\n稳态的每周期指令数（IPC）受限于处理器流水线中吞吐率最低的组件。我们必须分析前端、后端（发射宽度）和存储子系统所支持的最大 IPC。\n\n**1. 前端限制：**\n处理器每个周期最多可以取指和译码 $D=8$ 条指令。因此，$IPC \\le 8$。\n\n**2. 后端（发射）限制：**\n处理器每个周期最多可以发射 $W$ 条指令。\n- 对于 $W=2$，$IPC \\le 2$。\n- 对于 $W=8$，$IPC \\le 8$。\n\n**3. 存储子系统限制：**\n这是最关键的约束。循环每执行 $I=16$ 条指令就会产生一次关键路径上的缓存未命中。处理器退役指令的速率从根本上受限于这些关键未命中被解决的速率。\n\n存储系统最多可以并发处理 $M=16$ 次未命中。每次未命中需要 $L=200$ 个周期才能完成。在饱和的稳态下，存储系统每 $L$ 个周期完成 $M$ 次未命中。\n最大未命中完成率为：\n$$ \\text{Rate}_{\\text{miss}} = \\frac{M}{L} = \\frac{16 \\text{ misses}}{200 \\text{ cycles}} = 0.08 \\frac{\\text{misses}}{\\text{cycle}} $$\n\n处理器产生未命中的速率与其 IPC 成正比。每 $I$ 条指令有 $1$ 次未命中。\n未命中产生率为：\n$$ \\text{Rate}_{\\text{gen}} = \\frac{1 \\text{ miss}}{I \\text{ instructions}} \\times IPC \\frac{\\text{instructions}}{\\text{cycle}} = \\frac{IPC}{I} \\frac{\\text{misses}}{\\text{cycle}} $$\n\n为了使系统在稳态下保持稳定，产生率不能超过完成率：\n$$ \\frac{IPC}{I} \\le \\frac{M}{L} $$\n这使我们能够计算出存储系统所允许的最大 IPC：\n$$ IPC \\le \\frac{M \\times I}{L} $$\n代入给定值：\n$$ IPC \\le \\frac{16 \\times 16}{200} = \\frac{256}{200} = 1.28 $$\n\n由于内存级并行度（$M$）和延迟（$L$）的限制，存储子系统对性能施加了一个硬性上限，即 $IPC = 1.28$。题目还提到 ROB 大小为 $R = 256$。对于 $L=200$ 个周期的关键路径延迟和 $IPC=1.28$ 的吞吐率，在调度阶段和退役阶段之间的在途指令数为 $L \\times IPC = 200 \\times 1.28 = 256$。这证实了ROB的大小足以维持此级别的吞吐率，而不会成为更严格的瓶颈。\n\n**情景分析：**\n\n**情况 1：发射宽度 $W = 2$**\n潜在的 IPC 限制是：\n- 前端：$IPC \\le 8$\n- 后端：$IPC \\le 2$\n- 存储：$IPC \\le 1.28$\n实际的 IPC 是这些值中的最小值。因此，$IPC = 1.28$。$W=2$ 的发射宽度足以支持此吞吐率，因为 $1.28  2$。\n\n**情况 2：发射宽度 $W = 8$**\n潜在的 IPC 限制是：\n- 前端：$IPC \\le 8$\n- 后端：$IPC \\le 8$\n- 存储：$IPC \\le 1.28$\n实际的 IPC 仍然是最小值，即 $IPC = 1.28$。根本的瓶颈是存储系统的吞吐率，根据问题的明确假设，它与发射宽度 $W$ 无关。将 $W$ 从 $2$ 增加到 $8$ 提供了更多的执行资源，但处理器无法使用它们，因为它受“内存限制”——它渴望来自内存的数据，而不是功能单元。\n\n因此，在两种情况下，IPC 都保持在约 $1.28$。\n\n###逐项选项分析\n\n**A. 对于 $W = 2$ 和 $W = 8$，$IPC$ 的平均值都保持在约 $1.28$，因为受 $M$ 和 $L$ 限制的未命中完成率限制了退役吞吐率。**\n这个陈述与推导完全一致。计算出的 IPC 对 $W=2$ 和 $W=8$ 都是 $1.28$。其给出的理由——性能受限于未命中完成率（$\\frac{M}{L}$），而该速率又限制了退役——是正确的物理和定量解释。\n**结论：正确**\n\n**B. $IPC$ 的平均值从约 $1.28$ 增加到约 $2.00$，因为更宽的发射可以更快地执行非内存工作，从而在MSHR限制之外隐藏更多的内存延迟。**\n这是不正确的。IPC受MSHR容量和内存延迟的限制，上限为 $1.28$。在问题的规则下，“在MSHR限制之外隐藏更多的内存延迟”这个说法在物理上是不可能的；一旦 $M=16$ 个MSHR已满，就无法发起新的未命中。内存级并行度不能超过 $M$。\n**结论：不正确**\n\n**C. $IPC$ 的平均值增加到约 $8.00$，因为当独立指令充足时，$IPC$ 会随 $W$ 线性扩展。**\n这是不正确的。它忽略了瓶颈原则（或 Amdahl 定律）。系统的性能由其最慢的组件决定。在这种情况下，存储系统吞吐率是瓶颈，而不是发射宽度。虽然存在大量独立指令，但如果关键路径上的内存操作无法足够快地得到服务，它们也无法执行。\n**结论：不正确**\n\n**D. $IPC$ 的平均值下降到约 $1.00$，因为更宽的发射增加了缓存争用，从而增加了未命中率。**\n这是不正确的，因为它违反了问题陈述中给出的一个直接假设：“假设未命中率和延迟不受发射宽度的影响，并且当 $W$ 改变时，缓存争用不会增加。” 解决方案必须在所提供模型的约束内推导得出。\n**结论：不正确**",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}