{
    "hands_on_practices": [
        {
            "introduction": "To truly understand how out-of-order processors achieve high performance, one must learn to trace the flow of instructions through the machine's core components. This exercise guides you through a detailed, cycle-by-cycle simulation of a processor implementing Tomasulo's algorithm. By tracking the state of the reservation stations, register alias table, and common data bus, you will see firsthand how the hardware dynamically resolves data hazards and manages execution with different instruction latencies .",
            "id": "3632065",
            "problem": "A superscalar floating-point core uses Tomasulo’s algorithm with dynamic register renaming to eliminate Write-After-Write (WAW) and Write-After-Read (WAR) hazards while tolerating Read-After-Write (RAW) hazards via operand forwarding on the Common Data Bus (CDB). The machine has reservation stations for addition and multiplication and executes the following instruction sequence in program order, one instruction issued per cycle starting at cycle $1$:\n$$\nI_1: \\ \\text{ADD } R_1, R_2, R_3 \\qquad\nI_2: \\ \\text{MUL } R_1, R_4, R_5 \\qquad\nI_3: \\ \\text{ADD } R_6, R_1, R_7.\n$$\nAssume the following microarchitectural model, which you must use as the fundamental base for your reasoning:\n\n- There is one addition functional unit (ADD) with $2$ addition reservation stations, and one multiplication functional unit (MUL) with $2$ multiplication reservation stations.\n- The ADD unit has an execution latency of $L_{\\text{ADD}} = 2$ cycles per operation, and the MUL unit has an execution latency of $L_{\\text{MUL}} = 5$ cycles per operation.\n- There is exactly one Common Data Bus (CDB), so at most one result can be broadcast per cycle.\n- All registers $R_1$ through $R_7$ are initially ready with no pending tags in the Register Alias Table (RAT), and their values are not needed numerically (only readiness matters).\n- Per cycle, sub-stages occur in this strict order: write result on the CDB (if any), then execute (start or continue execution in functional units), then issue (allocate reservation stations and update the RAT).\n- An instruction can be issued in the issue sub-stage of a cycle if a matching reservation station is free. When issued, the RAT maps its destination architectural register to the reservation station’s tag, and its source operands are either captured into value fields if ready or recorded as tags if not ready.\n- If the last needed operand for a reservation station arrives on the CDB in cycle $c$, then the earliest cycle it may begin its first execution cycle is $c+1$.\n- Each functional unit can execute at most one operation at a time; an operation occupies its unit for exactly its latency $L$ cycles once started. When those $L$ cycles complete at the end of some cycle $c$, the result is eligible to broadcast on the CDB in cycle $c+1$ (subject to CDB availability). A broadcast updates any reservation station listening for that tag, and the architectural register file is only updated if the RAT still maps that architectural register to the broadcaster’s tag (thereby avoiding WAW).\n- Issue bandwidth is $1$ instruction per cycle. If no reservation station is available for the next instruction, issue stalls; otherwise, issue proceeds in program order. For this sequence, assume no stalls due to reservation station unavailability.\n\nUsing these rules, determine the exact cycle number at which instruction $I_3$ writes its result on the CDB. Provide your answer as a single integer cycle count with no units. No rounding is required.",
            "solution": "The problem requires determining the cycle at which instruction $I_3$ completes its write-back stage on a dynamically scheduled processor implementing Tomasulo's algorithm. To solve this, we must perform a detailed cycle-by-cycle simulation of the processor's state, tracking the status of instructions, reservation stations (RS), the Register Alias Table (RAT), and the Common Data Bus (CDB).\n\nThe machine model has the following key parameters:\n- ADD unit latency: $L_{\\text{ADD}} = 2$ cycles.\n- MUL unit latency: $L_{\\text{MUL}} = 5$ cycles.\n- One ADD functional unit and one MUL functional unit.\n- One Common Data Bus (CDB).\n- Issue rate of $1$ instruction per cycle.\n- Cycle sub-stages occur in the order: Write Result, Execute, Issue.\n\nThe instruction sequence is:\n$I_1: \\ \\text{ADD } R_1, R_2, R_3 \\implies R_1 \\leftarrow (R_2) + (R_3)$\n$I_2: \\ \\text{MUL } R_1, R_4, R_5 \\implies R_1 \\leftarrow (R_4) \\times (R_5)$\n$I_3: \\ \\text{ADD } R_6, R_1, R_7 \\implies R_6 \\leftarrow (R_1) + (R_7)$\n\nLet us denote the two ADD reservation stations as `Add1` and `Add2`, and the two MUL reservation stations as `Mul1` and `Mul2`. The RAT maps an architectural register to the tag of the reservation station that will produce its next value. Initially, all registers $R_1$ through $R_7$ are ready, so the RAT is empty.\n\n**Cycle 1:**\n- **Write Result:** No instruction has completed execution. The CDB is idle.\n- **Execute:** No instruction is ready for execution.\n- **Issue:** Instruction $I_1$ (`ADD R1, R2, R3`) is issued.\n    - It is allocated to reservation station `Add1`.\n    - Since source registers $R_2$ and $R_3$ are ready, their values are latched into `Add1`. `Add1` is ready to begin execution.\n    - The RAT is updated for the destination register $R_1$: `RAT[R_1] ← Tag(Add1)`.\n\n**Cycle 2:**\n- **Write Result:** The CDB is idle.\n- **Execute:**\n    - `Add1` has its operands and the ADD functional unit is free. It begins execution. It will execute for $2$ cycles (Cycle $2$ and Cycle $3$).\n- **Issue:** Instruction $I_2$ (`MUL R1, R4, R5`) is issued.\n    - It is allocated to reservation station `Mul1`.\n    - Source registers $R_4$ and $R_5$ are ready, so their values are latched into `Mul1`. `Mul1` is ready to begin execution.\n    - The destination register is $R_1$. This creates a Write-After-Write (WAW) hazard with $I_1$. Tomasulo's algorithm resolves this by updating the RAT. The mapping for $R_1$ is changed to point to the new producer: `RAT[R_1] ← Tag(Mul1)`. Any subsequent instruction that needs the value of $R_1$ will now be directed to wait for the result from `Mul1`.\n\n**Cycle 3:**\n- **Write Result:** The CDB is idle.\n- **Execute:**\n    - `Add1` continues its execution (cycle $2$ of $2$). It will complete at the end of this cycle.\n    - `Mul1` has its operands and the MUL functional unit is free. It begins execution. It will execute for $5$ cycles (Cycles $3, 4, 5, 6, 7$).\n- **Issue:** Instruction $I_3$ (`ADD R6, R1, R7`) is issued.\n    - It is allocated to reservation station `Add2`.\n    - For its source operands, it checks the RAT. Register $R_7$ is ready, so its value is latched. Register $R_1$ is not ready; the RAT indicates its value will be produced by `Tag(Mul1)`. `Add2` will therefore wait for the result from `Mul1`. This is a true Read-After-Write (RAW) dependency on the result of $I_2$.\n    - The RAT is updated for the destination register $R_6$: `RAT[R_6] ← Tag(Add2)`.\n\n**Cycle 4:**\n- **Write Result:** `Add1` ($I_1$) completed execution at the end of Cycle $3$. It now broadcasts its result and tag, `Tag(Add1)`, on the CDB.\n    - No waiting reservation station is listening for `Tag(Add1)`.\n    - The RAT entry for $R_1$ is `Tag(Mul1)`, not `Tag(Add1)`. Therefore, the architectural register $R_1$ is not updated. The result of $I_1$ is effectively discarded in terms of the final architectural state, correctly resolving the WAW hazard.\n- **Execute:** `Mul1` continues its execution (cycle $2$ of $5$). `Add2` is still waiting for an operand.\n- **Issue:** No more instructions to issue.\n\n**Cycle 5:**\n- **Write Result:** The CDB is idle.\n- **Execute:** `Mul1` continues its execution (cycle $3$ of $5$).\n- **Issue:** None.\n\n**Cycle 6:**\n- **Write Result:** The CDB is idle.\n- **Execute:** `Mul1` continues its execution (cycle $4$ of $5$).\n- **Issue:** None.\n\n**Cycle 7:**\n- **Write Result:** The CDB is idle.\n- **Execute:** `Mul1` continues its execution (cycle $5$ of $5$). It will complete at the end of this cycle.\n- **Issue:** None.\n\n**Cycle 8:**\n- **Write Result:** `Mul1` ($I_2$) completed execution at the end of Cycle $7$. It broadcasts its result and tag, `Tag(Mul1)`, on the CDB.\n    - `Add2` is waiting for this tag. It captures the result from the CDB. Now, both of its operands are ready.\n    - The RAT entry for $R_1$ is `Tag(Mul1)`, so the architectural register $R_1$ is updated with the result from $I_2$.\n- **Execute:** According to the rules, an instruction whose last operand arrives on the CDB in cycle $c$ can begin execution no earlier than cycle $c+1$. Thus, `Add2` cannot yet start execution.\n- **Issue:** None.\n\n**Cycle 9:**\n- **Write Result:** The CDB is idle.\n- **Execute:** `Add2` is now ready to execute and the ADD unit is free. It begins execution. It will execute for $2$ cycles (Cycle $9$ and Cycle $10$).\n- **Issue:** None.\n\n**Cycle 10:**\n- **Write Result:** The CDB is idle.\n- **Execute:** `Add2` continues its execution (cycle $2$ of $2$). It will complete at the end of this cycle.\n- **Issue:** None.\n\n**Cycle 11:**\n- **Write Result:** `Add2` ($I_3$) completed execution at the end of Cycle $10$. It now broadcasts its result and tag, `Tag(Add2)`, on the CDB.\n    - The RAT entry for $R_6$ is `Tag(Add2)`, so the architectural register $R_6$ is updated with the result from $I_3$.\n    - This is the cycle in which instruction $I_3$ writes its result on the CDB.\n- **Execute:** No instruction is executing.\n- **Issue:** None.\n\nThe simulation shows that instruction $I_3$ writes its result to the Common Data Bus in cycle $11$.",
            "answer": "$$\\boxed{11}$$"
        },
        {
            "introduction": "A key innovation of Tomasulo's algorithm is its elegant solution to false data dependencies through dynamic register renaming. This practice zeroes in on a classic Write-After-Write (WAW) hazard to illustrate how the algorithm maintains logical consistency. You will determine how tags are used to direct a dependent instruction to the correct producer, ensuring that obsolete results are discarded and the final architectural state is correct .",
            "id": "3685456",
            "problem": "Consider a single-issue implementation of Tomasulo’s algorithm with Reservation Stations (RS) and a Common Data Bus (CDB), and no explicit Reorder Buffer. The machine has separate functional units for integer addition and integer multiplication. The integer addition latency is $2$ cycles and the integer multiplication latency is $4$ cycles. Assume one result can be broadcast per cycle on the Common Data Bus (CDB), issue is in program order, and there are sufficient Reservation Stations so that no structural hazards occur at issue. The architectural register file initially holds $R1 = 0$, $R2 = 8$, $R3 = 4$, and $R4 = 0$. The following instruction sequence is issued in order:\n- $I_1$: $R1 \\leftarrow R2 + 10$ (integer add),\n- $I_2$: $R1 \\leftarrow R3 \\times 2$ (integer multiply),\n- $I_3$: $R4 \\leftarrow R1 + 1$ (integer add).\n\nA write-after-write (WAW) false dependency exists on $R1$ between $I_1$ and $I_2$. At issue, Tomasulo’s algorithm performs register renaming by associating a unique tag with each destination. Let the tag assigned to the destination of $I_1$ be $T_1$, and the tag assigned to the destination of $I_2$ be $T_2$. When an instruction reads a source register that is not yet ready, it copies the current tag from the register file and later captures the value when the matching tag is broadcast on the CDB.\n\nTasks:\n- Assign tags $T_1$ and $T_2$ to the destinations writing $R1$ in program order, and determine which tag $I_3$ must track for its $R1$ source to ensure logical $R1$ value consistency in the presence of the WAW hazard.\n- Using only the core mechanism of Tomasulo’s algorithm (in-order issue, RS operand capture via tag matching on the CDB, and register file updates gated by tag equality), reason about which producer value $I_3$ will actually use for its $R1$ source, given the specified latencies.\n\nFinally, compute the final architectural value of $R4$ after all three instructions complete and their results have been propagated through the CDB and reflected in the architectural register file. Express your answer as a single integer. No rounding is required.",
            "solution": "The problem asks for an analysis of a sequence of three instructions executed on a processor implementing Tomasulo's algorithm. We must determine the data flow for an instruction dependent on a register with a write-after-write (WAW) hazard and compute the final result.\n\nThe instruction sequence is:\n- $I_1$: $R1 \\leftarrow R2 + 10$\n- $I_2$: $R1 \\leftarrow R3 \\times 2$\n- $I_3$: $R4 \\leftarrow R1 + 1$\nInitial values: $R2=8, R3=4$. Latencies: ADD=2 cycles, MUL=4 cycles.\n\nWe will trace the state of the Register Alias Table (RAT) as each instruction is issued in order:\n1.  **Issue of $I_1$: $R1 \\leftarrow R2 + 10$**. $I_1$ is assigned tag $T_1$. The RAT is updated: $RAT[R1] \\leftarrow T_1$. The instruction is sent to an adder RS with the value of $R2$ (which is 8).\n2.  **Issue of $I_2$: $R1 \\leftarrow R3 \\times 2$**. $I_2$ is assigned tag $T_2$. The RAT entry for $R1$ is overwritten: $RAT[R1] \\leftarrow T_2$. This is the key step of register renaming that resolves the WAW hazard. Any subsequent instruction reading $R1$ will now be directed to wait for tag $T_2$. The instruction is sent to a multiplier RS with the value of $R3$ (which is 4).\n3.  **Issue of $I_3$: $R4 \\leftarrow R1 + 1$**. When $I_3$ is issued, it needs the value of $R1$. It consults the RAT and finds that the valid producer for $R1$ has tag $T_2$. Therefore, the adder RS for $I_3$ will store tag $T_2$ for its first source operand and monitor the Common Data Bus (CDB) for this tag.\n\nNow, we trace execution and writeback:\n- $I_1$ (ADD, 2 cycles) will finish before $I_2$ (MUL, 4 cycles).\n- When $I_1$ finishes, it broadcasts its result ($8 + 10 = 18$) and its tag ($T_1$) on the CDB.\n    - The RS for $I_3$ is waiting for tag $T_2$, so it ignores the broadcast.\n    - The architectural register file update logic also checks the RAT. The RAT entry for $R1$ points to $T_2$, not $T_1$. Therefore, the architectural register $R1$ is **not** updated. The result of $I_1$ is correctly discarded as obsolete.\n- Later, $I_2$ finishes and broadcasts its result ($4 \\times 2 = 8$) and its tag ($T_2$).\n    - The RS for $I_3$ sees its expected tag $T_2$ and captures the value $8$. Now, $I_3$ is ready to execute.\n    - The RAT entry for $R1$ matches tag $T_2$, so the architectural register $R1$ is updated with the value $8$.\n- Instruction $I_3$ can now execute the operation $R4 \\leftarrow R1 + 1$, which is $8 + 1 = 9$.\n- After its execution completes, $I_3$ will broadcast the value $9$, which will update the architectural register $R4$.\n\nTherefore, the final value of the architectural register $R4$ is $9$.",
            "answer": "$$\\boxed{9}$$"
        },
        {
            "introduction": "Beyond just data dependencies, the performance of an out-of-order processor is dictated by its finite physical resources. This advanced practice presents a scenario where a burst of consumer instructions fills the reservation station, creating a bottleneck that stalls the issue stage. You will analyze this \"head-of-line blocking\" effect and calculate the system's recovery time, connecting the abstract concepts of data flow and resource management to tangible performance metrics .",
            "id": "3628431",
            "problem": "Consider an out-of-order core that uses Tomasulo’s algorithm with Reservation Stations (RS) and a single Common Data Bus (CDB). The CDB (Common Data Bus) broadcasts one result per cycle to all waiting RS entries. The RS for a single floating-point add cluster has capacity $R = 8$ entries and feeds $U = 2$ identical pipelined floating-point add Functional Units (FU), each with initiation interval $1$ cycle and latency $L = 3$ cycles. The core issues up to $w = 2$ instructions per cycle into this RS cluster in program order. If the RS cluster is full, decode and issue for any instruction targeting this cluster stall in program order (i.e., no bypass of earlier stalled instructions is allowed). When an RS entry dispatches an operation to a FU, its RS slot is freed; freed slots become available to decode/issue in the next cycle.\n\nAn adversarial code sequence is constructed around a single producer instruction $P$ that generates a value $x$. The producer $P$ finishes and broadcasts the value $x$ on the CDB at cycle $t = 0$. There are $N = 12$ floating-point add consumers, each needing $x$ as one of their operands, and all of them target the same RS cluster. These $N$ consumers arrive over $k = 6$ consecutive cycles strictly before $P$’s broadcast, at a uniform issue rate of $w = 2$ per cycle, specifically at cycles $t = -6, -5, -4, -3, -2, -1$. Prior to $t = 0$, no consumer can execute because $x$ is not yet available; thus consumers occupy RS entries and remain there until $t = 0$, when the CDB broadcast makes $x$ available. After $t = 0$, any consumer already inserted into the RS becomes ready and may be selected for dispatch to an FU, subject to $U = 2$ dispatch slots per cycle.\n\nAdditionally, there is one independent floating-point add instruction $Q$ that does not depend on $x$ but also targets the same RS cluster. This independent instruction $Q$ reaches decode at cycle $t = -2$ in program order after some of the consumers. Because decode respects program order and cannot bypass earlier stalled instructions, $Q$ cannot be issued into the RS while earlier consumers are stalled due to a full RS. After $t = 0$, the RS begins to drain as ready consumers dispatch to the $U = 2$ FUs, freeing $2$ RS slots per cycle. Any freed RS slot is usable for new issue in the next cycle, and decode continues to insert instructions at a rate of $w = 2$ per cycle in program order (the remaining consumers first, then $Q$).\n\nDefine the following two quantities for the instruction $Q$:\n- The head-of-line blocking time $H$ is the number of cycles from $Q$’s arrival at decode to the cycle before $Q$ successfully issues into the RS.\n- The recovery time $T_{\\mathrm{rec}}$ is the number of cycles from the producer’s broadcast at $t = 0$ to the cycle when $Q$ successfully issues into the RS.\n\nUnder the assumptions above, compute the value of $H + T_{\\mathrm{rec}}$. Provide a single numeric answer in cycles. No rounding is required.",
            "solution": "The problem asks for the sum of two time intervals, the head-of-line blocking time $H$ and the recovery time $T_{\\mathrm{rec}}$, for an independent instruction $Q$. To determine these values, we must perform a cycle-by-cycle analysis of the state of the reservation station (RS) cluster, tracking instruction issue, dispatch, and RS occupancy.\n\nFirst, let us formalize the given parameters of the system:\n- Reservation Station capacity: $R = 8$ entries.\n- Number of floating-point add Functional Units (FUs): $U = 2$.\n- Issue width into the RS cluster: $w = 2$ instructions per cycle.\n- Total number of consumer instructions: $N = 12$.\n- Arrival period of consumers: $k=6$ cycles, from $t = -6$ to $t = -1$.\n- Producer broadcast time: $t = 0$.\n- Arrival time of instruction $Q$ at decode: $t_{\\mathrm{arrival}}(Q) = -2$.\n\nWe divide the analysis into two phases: the pre-broadcast phase ($t < 0$) and the post-broadcast phase ($t \\ge 0$).\n\n**Phase 1: Pre-broadcast State Analysis ($t < 0$)**\n\nThe $N = 12$ consumer instructions arrive at the issue stage at a rate of $w = 2$ per cycle over $k = 6$ consecutive cycles, from $t = -6$ to $t = -1$. These instructions cannot execute until the producer $P$ broadcasts its result at $t = 0$. Therefore, they occupy RS entries upon issue. We track the filling of the RS:\n\n- Cycle $t = -6$: $2$ consumers are issued into the RS. Occupancy: $2/8$.\n- Cycle $t = -5$: $2$ more consumers are issued. Occupancy: $4/8$.\n- Cycle $t = -4$: $2$ more consumers are issued. Occupancy: $6/8$.\n- Cycle $t = -3$: $2$ more consumers are issued. Occupancy: $8/8$. The RS is now full.\n\nAt the end of cycle $t = -3$, a total of $4 \\times 2 = 8$ consumers have been issued and occupy all $R=8$ RS slots.\n\n- Cycle $t = -2$: The next $2$ consumers in program order arrive at the issue stage. Since the RS is full, they cannot be issued and stall. This stall blocks the issue stage for any subsequent instructions targeting this RS cluster due to the in-order issue policy.\n- Cycle $t = -1$: The final $2$ consumers arrive and are also stalled behind the instructions from the previous cycle.\n\nThe problem states that instruction $Q$ arrives at decode at cycle $t = -2$. Due to the head-of-line blocking caused by the stalled consumers ahead of it in program order, $Q$ also stalls.\n\nAt the beginning of cycle $t=0$, the state of the system is as follows:\n- The RS contains $8$ consumer instructions (let's call them $C_1$ through $C_8$), all waiting for the value $x$.\n- The issue stage is stalled with a queue of instructions in program order: $4$ remaining consumers ($C_9$ through $C_{12}$) followed by instruction $Q$.\n\n**Phase 2: Post-broadcast State Analysis ($t \\ge 0$)**\n\nAt $t=0$, the producer $P$ broadcasts its result. This makes all consumers $C_1, \\dots, C_8$ in the RS ready to execute. The system now begins to recover. An RS slot is freed upon dispatch and becomes available for issue in the *next* cycle.\n\n- **Cycle $t = 0$**:\n    - **Event**: Producer broadcasts value $x$. Consumers $C_1, \\dots, C_8$ in the RS become ready.\n    - **Dispatch**: The $U=2$ FUs are available. Two ready consumers, $C_1$ and $C_2$, are dispatched. Their RS slots are freed.\n    - **Issue**: Issue is stalled because the freed slots are not available until the next cycle.\n    - **RS Occupancy (end of cycle)**: $8 - 2 = 6$ entries occupied ($C_3, \\dots, C_8$).\n\n- **Cycle $t = 1$**:\n    - **Issue**: $2$ RS slots are available from the previous cycle. The issue stage unstalls and issues the next $2$ instructions from its queue, which are consumers $C_9$ and $C_{10}$. Since value $x$ is already available, they enter the RS as ready.\n    - **RS Occupancy (after issue)**: $6 + 2 = 8$. The RS is full again.\n    - **Dispatch**: There are $6 + 2 = 8$ ready consumers in the RS ($C_3, \\dots, C_{10}$). Two of them, $C_3$ and $C_4$, are dispatched.\n    - **RS Occupancy (end of cycle)**: $8 - 2 = 6$ entries occupied ($C_5, \\dots, C_{10}$).\n\n- **Cycle $t = 2$**:\n    - **Issue**: $2$ RS slots are available. The issue stage issues the final $2$ consumers, $C_{11}$ and $C_{12}$. They enter the RS as ready.\n    - **RS Occupancy (after issue)**: $6 + 2 = 8$. The RS is full.\n    - **Dispatch**: There are $6+2=8$ ready consumers in the RS ($C_5, \\dots, C_{12}$). Two of them, $C_5$ and $C_6$, are dispatched.\n    - **RS Occupancy (end of cycle)**: $8 - 2 = 6$ entries occupied ($C_7, \\dots, C_{12}$).\n    - **Issue Queue**: Only instruction $Q$ remains.\n\n- **Cycle $t = 3$**:\n    - **Issue**: $2$ RS slots are available. The issue stage issues the next instruction in its queue, which is $Q$.\n    - **Conclusion**: Instruction $Q$ is successfully issued into the RS in cycle $t=3$. So, $t_{\\mathrm{issue}}(Q) = 3$.\n\n**Calculation of $H$ and $T_{\\mathrm{rec}}$**\n\nNow we compute the two specified quantities.\n\n1.  **Recovery Time ($T_{\\mathrm{rec}}$)**: This is defined as the number of cycles from the producer's broadcast at $t=0$ to the cycle when $Q$ successfully issues.\n    - Producer broadcast is at $t_{\\mathrm{broadcast}} = 0$.\n    - $Q$ issues at $t_{\\mathrm{issue}}(Q) = 3$.\n    - The duration is $T_{\\mathrm{rec}} = t_{\\mathrm{issue}}(Q) - t_{\\mathrm{broadcast}} = 3 - 0 = 3$ cycles.\n\n2.  **Head-of-Line Blocking Time ($H$)**: This is defined as the number of cycles from $Q$’s arrival at decode to the cycle before $Q$ successfully issues into the RS.\n    - $Q$'s arrival at decode is given as $t_{\\mathrm{arrival}}(Q) = -2$.\n    - $Q$ issues in cycle $t=3$. The cycle *before* issue is $t = 2$.\n    - The blocking period for $Q$ spans the cycles $t = -2, -1, 0, 1, 2$.\n    - The number of cycles in this interval is $2 - (-2) + 1 = 5$.\n    - Thus, the head-of-line blocking time is $H = 5$ cycles.\n\n**Final Calculation**\n\nThe problem asks for the value of $H + T_{\\mathrm{rec}}$.\n$$ H + T_{\\mathrm{rec}} = 5 + 3 = 8 $$\nThe total is $8$ cycles.",
            "answer": "$$\\boxed{8}$$"
        }
    ]
}