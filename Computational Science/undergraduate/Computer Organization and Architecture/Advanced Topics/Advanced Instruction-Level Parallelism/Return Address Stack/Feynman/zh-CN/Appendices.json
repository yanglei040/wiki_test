{
    "hands_on_practices": [
        {
            "introduction": "现代图形处理器（GPU）通过单指令多线程（SIMT）架构实现了大规模并行计算，但这引入了线程发散的挑战。此练习旨在探讨为何在这种环境下共享返回地址栈（RAS）是不足的，并引导你通过具体计算来量化为每个线程配备私有RAS所需的存储成本。通过这个实践，你将具体地理解在并行处理器设计中，架构决策如何直接转化为硬件资源开销。",
            "id": "3673883",
            "problem": "考虑一个实现单指令多线程 (SIMT) 执行的图形处理单元 (GPU)。在 SIMT 中，一个流式多处理器 (SM) 调度由 $U$ 个线程组成的 warp (线程束)，在任何给定时间，最多可以有 $W$ 个 warp 驻留。其控制流机制支持着色器程序中的函数调用和返回。返回地址栈 (RAS) 是一种微架构结构，用于预测返回指令的目标，它提供在调用时压入、在返回时弹出的栈顶返回地址。在传统的中央处理器 (CPU) 流水线中，RAS 通过利用一个不变量来提高返回目标预测的准确性：返回地址等于调用指令之后的下一个程序计数器 (PC)，这是调用指令位置的一个确定性函数。在 SIMT 中，同一 warp 内的线程可能由于数据相关的控制流而发生分化，因此每个线程的调用和返回可能发生在不同的动态时间。\n\n假设该 GPU 正在评估是否为着色器中的调用实现每线程 RAS。SM 的参数为每个 warp $U=32$ 个线程，以及 $W=64$ 个驻留 warp，因此每个 SM 上最大同时驻留的线程数为 $T=W \\cdot U$。每个线程的 RAS 必须最多能容纳 $K=8$ 个嵌套调用帧。每个 RAS 条目必须存储一个位宽为 $p=40$ 位的返回程序计数器，以及 $c=2$ 位的最小上下文元数据，因此每个条目的位宽为 $w=p+c$ 位。假设 SM 为控制流预测结构保留了 $B=1.0 \\times 10^{6}$ 位的片上预算。\n\n从 SIMT 执行模型和返回地址栈的功能出发，解释为什么在存在分化的情况下，warp 级共享单个 RAS 是不足的，并说明为什么每线程 RAS 能消除这种风险。然后，计算为 SM 上所有驻留线程配置每线程 RAS 所需的总存储空间。将最终的存储成本以比特为单位表示为一个单一数字，该数字通过组合 $T$、$K$ 和 $w$ 得出，其依据是每个线程存储 $K$ 个位宽为 $w$ 的条目这一要求。在最终的方框答案中不要包含任何单位，但应将其解释为比特。不需要四舍五入。",
            "solution": "该问题被评估为有效。它在科学上基于计算机体系结构的原理，特别是 GPU 的单指令多线程 (SIMT) 模型。该问题定义良好，为进行唯一且有意义的计算提供了所有必要的参数，并且其前提是一致和客观的。\n\n所解决的核心问题是在以线程分化为特征的 SIMT 执行环境中管理函数调用的返回地址。返回地址栈 (RAS) 是一种硬件堆栈，它存储子程序调用的返回地址，以预测后续返回指令的目标。在简单的单线程处理器中，函数调用的后进先出 (LIFO) 特性使得 RAS 非常有效。`CALL` 指令将下一条指令的地址压入 RAS，而 `RETURN` 指令则弹出此地址并将其用作分支目标。\n\n在 SIMT 体系结构中，一组称为 warp 的线程名义上以锁步方式执行相同的指令。设每个 warp 的线程数为 $U$。如果一个 warp 中的所有 $U$ 个线程都遵循完全相同的控制流路径，它们将同时执行一个 `CALL` 指令，并且原则上可以共享一个 warp 级的 RAS。它们都会压入相同的返回地址，之后在执行 `RETURN` 指令时又都会弹出该地址。\n\n然而，使情况复杂化的 SIMT 的决定性特征是线程分化。由于数据相关的条件分支（例如 `if-then-else` 结构），一个 warp 内的单个线程可以采取不同的执行路径。例如，考虑一个由 $U$ 个线程组成的 warp，其中一个线程子集 $S_1$ 满足某个条件并在一个 `if` 代码块内执行 `CALL` 指令，而其互补子集 $S_2$ 则不执行。\n\n在这种分化场景下，单个共享的 warp 级 RAS 是不足的，原因有以下几点：\n$1$. **状态模糊性：** 单个 RAS 只能容纳一个返回地址堆栈。它不能同时表示 $S_1$ 中的线程已经进行了函数调用而 $S_2$ 中的线程没有进行调用的状态。如果 $S_1$ 中的线程压入一个返回地址，那么该地址现在就位于共享堆栈的顶部。\n$2$. **对未调用线程的错误预测：** 当 $S_1$ 中的线程最终执行 `RETURN` 指令时，它们需要之前压入的返回地址。然而，`RETURN` 指令对于 $S_1$ 中的线程是活动的，但对于 $S_2$ 中的线程是不活动的（被谓词屏蔽）。如果硬件要弹出共享 RAS，它将提供一个返回地址预测，而这个预测对于从未进行相应调用的 $S_2$ 线程来说是无意义且不正确的。如果处理不当，这可能导致错误预测或停顿。\n$3$. **嵌套和交错分化：** 随着嵌套调用和进一步的分化，问题会变得更加复杂。一些线程可能会进行一次调用，然后进行另一次嵌套调用，而其他线程可能只进行第一次调用，还有一些线程则不进行任何调用。单个堆栈无法跟踪这些多个独立的调用历史。\n\n配置每线程 RAS 可以解决这个风险。通过为每个线程分配一个私有 RAS，每个线程的控制流状态可以被独立管理。\n- 当一个线程执行 `CALL` 指令时，它会将其唯一的返回地址压入自己的私有 RAS。\n- 当同一个线程稍后执行 `RETURN` 指令时，它会从自己的 RAS 中弹出地址。\n此操作完全不受同一 warp 中其他线程是否正在进行调用的影响。因此，返回地址预测的正确性与相邻线程的执行路径解耦，使得该机制对线程分化具有鲁棒性。\n\n现在我们可以计算在单个流式多处理器 (SM) 上为所有同时驻留的线程实现每线程 RAS 的总存储成本。\n\n给定的参数是：\n- 每个 warp 的线程数：$U = 32$\n- 每个 SM 的驻留 warp 数：$W = 64$\n- 每个线程的最大 RAS 条目数：$K = 8$\n- 返回程序计数器 (PC) 的位宽：$p = 40$ 位\n- 每个条目的上下文元数据位宽：$c = 2$ 位\n\n首先，我们计算每个 SM 的总驻留线程数，记为 $T$。\n$$T = W \\cdot U$$\n代入给定值：\n$$T = 64 \\cdot 32 = 2048 \\text{ 个线程}$$\n\n接下来，我们确定单个 RAS 条目的存储大小，记为 $w$。这是 PC 位宽和元数据位宽的总和。\n$$w = p + c$$\n代入给定值：\n$$w = 40 + 2 = 42 \\text{ 位}$$\n\n每个线程都需要自己的 RAS，能够存储 $K$ 个这样的条目。单个线程的 RAS 所需的总存储量 $S_{\\text{thread}}$ 为：\n$$S_{\\text{thread}} = K \\cdot w$$\n$$S_{\\text{thread}} = 8 \\cdot 42 = 336 \\text{ 位}$$\n\n最后，为 SM 上所有 $T$ 个驻留线程实现每线程 RAS 所需的总存储量 $S_{\\text{total}}$，是线程数与每个线程所需存储量的乘积。\n$$S_{\\text{total}} = T \\cdot S_{\\text{thread}}$$\n$$S_{\\text{total}} = T \\cdot K \\cdot w$$\n代入已计算和给定的值：\n$$S_{\\text{total}} = 2048 \\cdot 8 \\cdot 42$$\n$$S_{\\text{total}} = 16384 \\cdot 42$$\n$$S_{\\text{total}} = 688128 \\text{ 位}$$\n\n因此，为 SM 上所有驻留线程配置每线程 RAS 的总存储成本为 $688,128$ 比特。这个成本在指定的片上预算 $B = 1.0 \\times 10^6$ 比特之内。",
            "answer": "$$\n\\boxed{688128}\n$$"
        },
        {
            "introduction": "在处理器设计中，“越大越好”往往是一种误区，返回地址栈（RAS）的深度设计便是绝佳的例子。一个更深的RAS虽然能减少返回地址预测错误，提升性能，但也会增加芯片面积和功耗，甚至可能因散热限制而被迫降低时钟频率。本练习将引导你通过建立一个实际的优化模型，来寻找RAS深度的“最佳点”，从而掌握在相互制约的工程约束（性能、功耗、面积）下进行设计决策的核心技能。",
            "id": "3673912",
            "problem": "一个标量乱序处理器采用返回地址栈 (RAS) 来预测函数返回的目标地址。一个具有 $K$ 个条目的返回地址栈 (RAS) 可以减少返回目标地址的预测错误，从而提高有效的每周期指令数 (IPC)。设计必须遵守片上面积预算，而增加 $K$ 也会增加动态功耗，这在固定的散热方案下会降低可实现的时钟频率。\n\n使用以下基于标准计算机体系结构关系的建模假设：\n\n- 以每秒指令数计的吞吐率建模为 $S(K) = \\text{IPC}(K) \\cdot f(K)$，其中 $\\text{IPC}(K)$ 是每周期指令数 (IPC)，$f(K)$ 是时钟频率。\n- 由较大的 $K$ 带来的收益递减效应通过一个饱和IPC模型来捕捉\n  $$\\text{IPC}(K) = \\text{IPC}_{0} + \\Delta \\text{IPC}\\left(1 - \\exp(-\\alpha K)\\right),$$\n  其中 $\\text{IPC}_{0}$、$\\Delta \\text{IPC}$ 和 $\\alpha$ 是正常数。\n- 一个线性化的热功耗约束将总功耗与时钟频率关联起来，其形式为\n  $$f(K) = f_{0} - \\kappa \\left(P_{0} + P_{\\mathrm{e}} K\\right),$$\n  其中 $f_{0}$ 和 $\\kappa$ 是正常数，$P_{0}$ 是 $K=0$ 时的基准功耗，$P_{\\mathrm{e}}$ 是每增加一个RAS条目的边际功耗。假设线性化在工作区域内有效，并且在最优点处 $f(K) > 0$。\n- 每个RAS条目的硅片面积为 $A$，可用于RAS的面积预算为 $A_{\\max}$，由此得出硬约束 $A K \\le A_{\\max}$。\n\n给定数值参数\n- $\\text{IPC}_{0} = 1.2$, $\\Delta \\text{IPC} = 0.4$, $\\alpha = 0.08$,\n- $f_{0} = 4.0$, $\\kappa = 0.05$, $P_{0} = 50$, $P_{\\mathrm{e}} = 0.02$,\n- $A = 0.02$ 和 $A_{\\max} = 1.5$,\n\n建立并求解以下约束优化问题\n$$\\max_{K \\ge 0} \\; S(K) \\quad \\text{subject to} \\quad A K \\le A_{\\max}.$$\n\n假设在优化中 $K$ 可以被视为一个实数变量。求出在面积约束下最大化 $S(K)$ 的最优 $K^{\\star}$。将你的最终数值答案 $K^{\\star}$ 四舍五入到四位有效数字。答案中不要包含单位。",
            "solution": "此问题是一个约束优化任务，它具有科学依据、问题定义明确，并基于计算机体系结构中有效的建模假设。所提供的数据是完整且一致的。因此，该问题是有效的，可以求得其解。\n\n目标是关于返回地址栈 (RAS) 条目数 $K$ 来最大化吞吐率 $S(K)$。吞吐率由每周期指令数 $\\text{IPC}(K)$ 和时钟频率 $f(K)$ 的乘积给出。\n$$S(K) = \\text{IPC}(K) \\cdot f(K)$$\n构成模型如下：\n$$\\text{IPC}(K) = \\text{IPC}_{0} + \\Delta \\text{IPC}\\left(1 - \\exp(-\\alpha K)\\right)$$\n$$f(K) = f_{0} - \\kappa \\left(P_{0} + P_{\\mathrm{e}} K\\right)$$\n代入给定的数值参数：\n- $\\text{IPC}_{0} = 1.2$, $\\Delta \\text{IPC} = 0.4$, $\\alpha = 0.08$\n- $f_{0} = 4.0$, $\\kappa = 0.05$, $P_{0} = 50$, $P_{\\mathrm{e}} = 0.02$\n\n模型变为：\n$$\\text{IPC}(K) = 1.2 + 0.4(1 - \\exp(-0.08 K)) = 1.6 - 0.4 \\exp(-0.08 K)$$\n$$f(K) = 4.0 - 0.05(50 + 0.02 K) = 4.0 - 2.5 - 0.001 K = 1.5 - 0.001 K$$\n\n因此，目标函数 $S(K)$ 为：\n$$S(K) = \\left(1.6 - 0.4 \\exp(-0.08 K)\\right) \\left(1.5 - 0.001 K\\right)$$\n\n该优化受约束 $K \\ge 0$ 和面积预算 $A K \\le A_{\\max}$ 的限制。给定参数 $A = 0.02$ 和 $A_{\\max} = 1.5$，面积约束为：\n$$0.02 K \\le 1.5 \\implies K \\le \\frac{1.5}{0.02} = 75$$\n因此，问题是在闭区间 $K \\in [0, 75]$ 上找到使 $S(K)$ 最大化的 $K$ 值。一个连续可微函数在闭区间上的最大值必然出现在边界点（$K=0$ 或 $K=75$）或区间 $(0, 75)$ 内导数为 $S'(K_c) = 0$ 的临界点 $K_c$。\n\n为了找到临界点，我们使用乘法法则 $(uv)' = u'v + uv'$ 计算 $S(K)$ 关于 $K$ 的导数。令 $u(K) = 1.6 - 0.4 \\exp(-0.08 K)$ 和 $v(K) = 1.5 - 0.001 K$。\n导数分别为：\n$$u'(K) = \\frac{d}{dK} \\left(1.6 - 0.4 \\exp(-0.08 K)\\right) = -0.4 \\cdot (-0.08) \\exp(-0.08 K) = 0.032 \\exp(-0.08 K)$$\n$$v'(K) = \\frac{d}{dK} \\left(1.5 - 0.001 K\\right) = -0.001$$\n$S(K)$ 的导数为：\n$$S'(K) = u'(K)v(K) + u(K)v'(K)$$\n$$S'(K) = \\left(0.032 \\exp(-0.08 K)\\right) \\left(1.5 - 0.001 K\\right) + \\left(1.6 - 0.4 \\exp(-0.08 K)\\right) \\left(-0.001\\right)$$\n展开并合并同类项：\n$$S'(K) = 0.048 \\exp(-0.08 K) - 0.000032 K \\exp(-0.08 K) - 0.0016 + 0.0004 \\exp(-0.08 K)$$\n$$S'(K) = \\left(0.0484 - 0.000032 K\\right) \\exp(-0.08 K) - 0.0016$$\n令导数为零，$S'(K) = 0$，以寻找临界点：\n$$\\left(0.0484 - 0.000032 K\\right) \\exp(-0.08 K) = 0.0016$$\n这是一个关于 $K$ 的超越方程，必须通过数值方法求解。令 $h(K) = S'(K)$。对 $h(K)$ 在区间 $[0, 75]$ 上的分析表明，它是一个单调递减函数（因为它的导数 $S''(K)$ 在整个区间内为负），且只在一个点穿过零。\n- 在 $K=0$ 处，$h(0) = (0.0484)\\exp(0) - 0.0016 = 0.0468 > 0$。\n- 在 $K=75$ 处，$h(75) = (0.0484 - 0.000032 \\cdot 75)\\exp(-0.08 \\cdot 75) - 0.0016 = 0.046 \\exp(-6) - 0.0016 \\approx 0.046(0.002479) - 0.0016 \\approx -0.001486 < 0$。\n由于 $h(K)$ 是连续的，并且符号由正变负，因此在 $(0, 75)$ 内存在唯一的根 $K_c$。这个临界点对应一个局部最大值，因为 $S''(K_c) < 0$。\n\n可以采用数值方法（如牛顿-拉夫逊法或二分法）来求根。通过迭代计算可以得到 $K_c$ 的解。例如，测试一些值：\n- 对于 $K=42$，$S'(42) \\approx 0.00002$。\n- 对于 $K=43$，$S'(43) \\approx -0.00001$。\n根在 $42$ 和 $43$ 之间。更精确的计算给出：\n$$K_c \\approx 42.2644$$\n这个临界点 $K_c$ 位于可行域 $[0, 75]$ 内。为了确认这是全局最大值，我们可以比较在 $K_c$ 和边界点处的吞吐率 $S(K)$：\n$$S(0) = (1.6 - 0.4)(1.5) = 1.2 \\times 1.5 = 1.8$$\n$$S(75) = (1.6 - 0.4 \\exp(-6))(1.5 - 0.075) \\approx (1.599)(1.425) \\approx 2.279$$\n$$S(K_c \\approx 42.26) = (1.6 - 0.4 \\exp(-0.08 \\cdot 42.26))(1.5 - 0.001 \\cdot 42.26) \\approx 2.313$$\n由于 $S(K_c)$ 是最大值，因此RAS条目的最优数量是 $K^{\\star} = K_c$。\n\n问题要求将最终数值答案 $K^{\\star}$ 四舍五入到四位有效数字。\n$$K^{\\star} = 42.2644 \\dots \\approx 42.26$$\n最优的RAS条目数是 $42.26$。",
            "answer": "$$\\boxed{42.26}$$"
        },
        {
            "introduction": "在现代超标量乱序处理器中，推测执行是提升性能的关键，但也给RAS等预测结构的正确性带来了严峻挑战。由于错误路径上的指令也可能被解码并影响RAS状态，导致其与真实的函数调用栈不再匹配，从而引发预测错误。这个练习将带你深入分析一个由推测执行引起的微妙错误，并评估一种基于标签的修复机制，让你理解在复杂微架构中确保状态正确性的重要性与方法。",
            "id": "3673889",
            "problem": "您正在分析一个超标量、乱序处理器，它使用返回地址栈 (RAS) 来预测返回指令的目标。返回地址栈 (RAS) 是一个后进先出的结构，在解码调用指令时，它会推入返回地址（紧跟在调用指令之后的指令的程序计数器 PC），而在遇到返回指令时，它通过读取栈顶条目来预测返回目标，然后弹出栈顶。在此机器上，以下事实成立：\n- 在调用解码时，机器会推测性地将预测的返回地址推入 RAS。机器不会对 RAS 进行检查点操作，因此由错误路径解码引起的推入操作不会被自动撤销。\n- 在返回指令退役时，如果预测的返回目标与真实的体系结构返回地址不同，会发生预测错误冲刷，并且 RAS 仍然会弹出其栈顶条目（即，机器无法“取消弹出”）。\n- 没有尾调用或异常；只有分支预测错误会导致错误路径解码。RAS 的深度足够大（至少为 $8$），因此在这种情况下不会发生溢出。\n\n考虑以下同时包含递归和相互递归的代码结构。设 $M$ 表示主函数，$F$ 和 $G$ 是两个函数，它们在执行路径上如下相互递归：\n- $M$ 在我们标记为 $C_{MF}$ 的调用点调用 $F$，对应的正确返回地址为 $R_{MF}$。\n- 在 $F$ 的早期，有一个条件分支被错误预测了一次，导致前端在错误路径上解码了在调用点 $C_{FH}$ 对一个不相关函数 $H$ 的调用，预测的返回地址为 $R_{FH}$。对 $H$ 的调用实际上没有执行（错误路径被冲刷），但由于缺少 RAS 检查点，将 $R_{FH}$ 推入 RAS 的操作仍然存在。\n- 仍在 $F$ 的正确路径上，$F$ 在调用点 $C_{FG1}$ 调用 $G$，返回地址为 $R_{FG1}$。\n- 在 $G$ 中，在调用点 $C_{GF1}$ 有一个对 $F$ 的调用，返回地址为 $R_{GF1}$。\n- 最内层的 $F$ 到达基本情况并执行返回。然后 $G$ 返回。然后外层的 $F$ 返回到 $M$。\n\n假设此事件中唯一的错误路径事件是上述单个 $R_{FH}$ 的伪推入。设 RAS 上的动态推入序列恰好是对应于 $R_{MF}$ 的推入，然后是伪推入的 $R_{FH}$，然后是 $R_{FG1}$，然后是 $R_{GF1}$，按从栈底到栈顶的顺序。\n\n现在考虑为 RAS 的每个条目增加一个小标签，其值等于 $h(ID)$，其中 $h(\\cdot)$ 是一个固定的哈希函数，$ID$ 是与调用相关联的某个标识符。在返回时，机器可以仅根据返回时可用的信息（在弹出之前）计算一个标签 $t$，如果栈顶标签与 $t$ 不匹配，则允许向下扫描到第一个标签与 $t$ 匹配的条目，并在生成预测之前丢弃其上方的任何条目。假设对于所考虑的标识符，$h(\\cdot)$ 的冲突概率可以忽略不计。\n\n哪个选项正确地描述了以下两点：\n(i) 在所述事件中使用未标记的 RAS 时，返回预测错误的数量和位置，以及\n(ii) 一个可行的 $ID$ 选择，该选择允许带标签的 RAS 使用上述比较和扫描策略，在存在递归和相互递归的情况下避免这些预测错误？\n\nA. 恰好有 $1$ 个返回被错误预测，即从外层 $F$ 返回到 $M$ 的返回；选择 $ID$ 作为被调用者的函数标识（例如，当前函数的入口 PC，因此标签为 $h(F)$、$h(G)$ 等）是可行的，因为在返回时被调用者的标识是已知的，并且扫描到最近的匹配 $h(F)$ 会跳过伪推入的 $R_{FH}$，即使存在相互递归也能恢复对齐。\n\nB. 没有发生预测错误，因为调用和返回的后进先出特性确保了即使有伪推入，相互递归也总是保持 RAS 对齐。\n\nC. 恰好有 $1$ 个返回被错误预测，但只有选择 $ID$ 作为调用者的调用点标识（即标签为 $h(C_{MF})$、$h(C_{FG1})$ 等）才能避免它；被调用者标识标签在相互递归中无法消除歧义。\n\nD. 恰好有 $2$ 个返回被错误预测（从 $F$ 到 $G$ 的返回和从 $F$ 到 $M$ 的返回）；避免这两个错误需要选择 $ID$ 作为确切的返回目标地址（标签为 $h(R)$），因为只有返回目标才足够独特，以在返回时消除调用点上下文的歧义。",
            "solution": "问题陈述描述了一个涉及乱序处理器中返回地址栈（`RAS`）的场景，该场景内部一致，科学上基于计算机体系结构的原理，并且问题定义良好。该场景是分析推测性微架构结构行为的标准形式问题。因此，该问题是有效的，并且可以推导出解决方案。\n\n解决方案分两部分展开：首先，分析基准的、未标记的 `RAS` 的行为以确定预测错误的数量；其次，评估所提出的带标签的 `RAS` 机制以及不同的标识符（`ID`），以评估其可行性和有效性。\n\n### 第一部分：未标记 RAS 的分析\n\n`RAS` 是一个后进先出（`LIFO`）栈。我们将通过所描述的事件序列来追踪其状态。假设栈由一个列表表示，左侧为栈底，右侧为栈顶。\n\n1.  **初始状态：** `RAS` 为空：`[]`。\n2.  **`M` 调用 `F`：** 在调用点 `C_{MF}`，从 `M` 到函数 `F` 的 `call` 推入返回地址 `R_{MF}`。\n    `RAS` 状态：`[R_{MF}]`\n3.  **伪推入：** 由于 `F` 中的一次分支预测错误，在错误路径上解码了在调用点 `C_{FH}` 对函数 `H` 的 `call`。相应的返回地址 `R_{FH}`被推测性地推入。此推入操作不会被撤销。\n    `RAS` 状态：`[R_{MF}, R_{FH}]`\n4.  **`F` 调用 `G`：** 在正确路径上，在 `C_{FG1}` 处对 `G` 的 `call` 推入返回地址 `R_{FG1}`。\n    `RAS` 状态：`[R_{MF}, R_{FH}, R_{FG1}]`\n5.  **`G` 调用 `F`：** 在 `C_{GF1}` 处对 `F` 的 `call` 推入返回地址 `R_{GF1}`。\n    `RAS` 状态：`[R_{MF}, R_{FH}, R_{FG1}, R_{GF1}]`\n\n现在，我们分析 `return` 指令的序列。\n\n1.  **最内层的 `F` 返回到 `G`：**\n    *   正确的体系结构返回地址是 `R_{GF1}`。\n    *   `RAS` 通过读取其栈顶条目 `R_{GF1}` 来预测目标。\n    *   预测 `R_{GF1}` 是 **正确** 的。\n    *   `RAS` 弹出 `R_{GF1}`。\n    *   `RAS` 状态：`[R_{MF}, R_{FH}, R_{FG1}]`\n\n2.  **`G` 返回到外层 `F`：**\n    *   正确的体系结构返回地址是 `R_{FG1}`。\n    *   `RAS` 通过读取其新的栈顶条目 `R_{FG1}` 进行预测。\n    *   预测 `R_{FG1}` 是 **正确** 的。\n    *   `RAS` 弹出 `R_{FG1}`。\n    *   `RAS` 状态：`[R_{MF}, R_{FH}]`\n\n3.  **外层 `F` 返回到 `M`：**\n    *   正确的体系结构返回地址是 `R_{MF}`。\n    *   `RAS` 通过读取其栈顶条目进行预测，该条目是伪地址 `R_{FH}`。\n    *   由于 `R_{FH}` 对应于对不相关函数 `H` 的调用，它不等于 `R_{MF}`。预测 `R_{FH}` 是 **错误** 的。\n    *   发生预测错误冲刷。根据问题陈述，无论预测是否错误，`RAS` 都会弹出其栈顶条目 `R_{FH}`。\n    *   `RAS` 状态：`[R_{MF}]`\n\n在整个事件中，恰好有 **$1$** 次返回预测错误。这次预测错误发生在外层 `F` 函数返回到 `M` 时。这立即表明选项 B（声称 $0$ 次预测错误）和 D（声称 $2$ 次预测错误）是不正确的。\n\n### 第二部分：带标签 RAS 的分析及 ID 选择的可行性\n\n带标签 `RAS` 的目标是检测和修复 `RAS` 的损坏，例如由 `R_{FH}` 的伪推入引起的损坏。在 `return` 时，会计算一个标签 `t`，如果栈顶标签不匹配，`RAS` 会向下扫描以查找匹配的条目，并丢弃其上不匹配的条目。关键约束是 `t` 必须 `仅根据返回时可用的信息` 计算。\n\n让我们分析标识符 `ID` 的建议选择，其哈希值 `h(ID)` 构成标签。\n\n**选项 A：`ID` 是被调用者的函数标识**\n`return` 指令是函数体的一部分。包含 `return` 的函数的标识是原始 `call` 指令的*被调用者*。此标识（例如，函数的入口程序计数器 (`PC`)）在处理器执行 `return` 指令时是随时可用的。因此，这个 `ID` 选择是 **可行** 的。\n\n让我们用这种方案追踪最后那个有问题的、从外层 `F` 到 `M` 的返回：\n*   在此返回之前，`RAS` 的状态是 `[R_{MF}, R_{FH}]`。带标签的 `RAS` 状态应为 `[(R_MF, h(F)), (R_FH, h(H))]`。当外层 `F` 执行返回指令时，处理器知道它在函数 `F` 内部，因此它计算出目标标签 `t = h(F)`。\n*   `RAS` 检查其栈顶条目 `(R_{FH}, h(H))`。标签 `h(H)` 与目标标签 `t` 不匹配。\n*   根据所提出的机制，`RAS` 丢弃这个不匹配的条目，并向下扫描到下一个条目。\n*   下一个条目是 `(R_{MF}, h(F))`。它的标签 `h(F)` 与目标标签 `t` 匹配。\n*   `RAS` 使用这个条目的地址 `R_{MF}` 作为预测。这是正确的返回地址，因此预测是 **正确** 的。这个带标签的机制成功地避免了预测错误。\n*   该方案即使在相互递归（`F` 调用 `G`，`G` 调用 `F`）的情况下也有效。例如，当从 `G` 返回到 `F` 时，处理器知道它在 `G` 中，并寻找标签 `h(G)`，这会正确匹配 `R_{FG1}` 对应的条目。\n\n现在，我们来评估其他选项的不可行性：\n*   **选项 C：** 建议使用调用者的调用点标识作为 `ID`。在执行 `return` 指令时，处理器本身并不知道它是由哪个调用点调用的——这正是 `RAS` 试图解决的问题。因此，该信息不可用，此方案不可行。\n*   **选项 D：** 建议使用确切的返回目标地址作为 `ID`。这同样是 `RAS` 试图预测的信息，在预测发生之前是未知的。因此，此方案也不可行。\n\n**结论：**\n在未标记的 `RAS` 中，恰好有 1 次返回预测错误。一个可行的修复方案是使用被调用者的函数标识作为 `ID` 来标记 `RAS` 条目。该方案能够检测并跳过因错误路径推测而引入的伪条目，从而纠正预测，并且该机制在相互递归的情况下依然稳健。因此，选项 A 是对两个问题的唯一正确描述。",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}