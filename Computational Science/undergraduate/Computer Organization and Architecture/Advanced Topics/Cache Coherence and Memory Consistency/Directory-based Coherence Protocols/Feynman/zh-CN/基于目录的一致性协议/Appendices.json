{
    "hands_on_practices": [
        {
            "introduction": "更高级的缓存一致性协议（如 MOESI）通过引入新状态来优化性能，但其优势并非在所有场景下都能体现。本练习旨在通过分析一个特定的“写乒乓”工作负载，揭示 MOESI 协议中“Owned”状态的真正价值所在。通过亲手计算和对比，你将深入理解协议状态转换的成本，并认识到协议性能与具体应用行为之间的密切关系。",
            "id": "3635489",
            "problem": "考虑一个基于目录的高速缓存一致性系统，该系统带有一个中心化目录，为每个缓存行维护一个共享者向量和（如果适用）一个单一的所有者标识符。互连是可靠且有序的，目录通过向节点发送消息并接收相应的确认或数据来执行一致性操作。我们考虑两种协议：修改-独占-共享-无效（MESI）和修改-拥有-独占-共享-无效（MOESI），其中MOESI协议增加了“拥有”（Owned）状态，允许一个脏数据行在不写回内存的情况下提供给共享者。假设有两个核心，表示为$C_0$和$C_1$，它们以背靠背的方式交替对同一个缓存行$x$进行写操作，从冷状态开始，此时缓存行$x$未被任何核心缓存，目录将其标记为未缓存。具体来说，总共有$10$次写操作：$C_0$写入，然后$C_1$写入，这个过程重复进行，直到每个核心都写入了$5$次。\n\n将一次“往返”视为由目录向任一节点（即内存控制器或核心）发起的一次请求-响应对。因此，一次往返由一条目录到节点的一致性操作消息和完成该操作所需的相应节点到目录的确认或数据消息组成。只计算由目录发起的往返；不计算核心到目录的请求、目录到核心的数据响应或任何本地缓存命中处理。忽略容量驱逐，并假设所有必要的缓存到缓存传输都由目录协调，除非在冷未命中时从内存中获取数据，否则不涉及内存控制器。\n\n使用MESI和MOESI协议的基本定义以及基于目录的所有权转移语义，分析完整的$10$次背靠背写操作序列，并计算在MESI下由目录发起的总往返次数（表示为$R_{\\text{MESI}}$）和在MOESI下由目录发起的总往返次数（表示为$R_{\\text{MOESI}}$）。然后，通过评估相对改进来量化“拥有”状态是否能减少写乒乓效应\n$$I \\equiv \\frac{R_{\\text{MESI}} - R_{\\text{MOESI}}}{R_{\\text{MESI}}}.$$\n将$I$报告为单个实数。无需四舍五入。假设系统具有以下属性：对于处于修改（Modified）或拥有（Owned）状态的行，目录通过向当前所有者发送转发/无效化请求来进行所有者干预，所有者直接用所需的确认或数据响应目录，任何共享者无效化操作都需要向目录发送确认后才能完成。在此工作负载中，除了$C_0$和$C_1$之外，没有并发的第三方共享者。",
            "solution": "该问题要求分析特定工作负载在一个基于目录的高速缓存一致性系统上的表现，以比较MESI和MOESI协议的性能。性能指标是在两个核心$C_0$和$C_1$对同一缓存行$x$进行10次交替写操作的序列中，由目录发起的总往返次数$R$。然后必须计算MOESI相对于MESI的相对改进$I$。\n\n首先，我们必须根据问题陈述精确定义什么是“往返”。一次往返是由目录向另一个节点（核心或内存控制器）发起的请求-响应对。具体来说，它是一条目录到节点的消息，后跟相应的节点到目录的确认或数据消息。核心到目录的请求和目录到核心的纯数据响应被明确排除在此计数之外。\n\n该工作负载包含对单个缓存行$x$的总共$10$次写操作。序列是：$C_0$写，$C_1$写，依此类推，每个核心写$5$次。最初，该行未被任何核心缓存（两个核心都将其置于无效（I）状态），并且目录将其标记为未缓存。\n\n让我们首先分析MESI协议的序列以确定$R_{\\text{MESI}}$。\n\n**MESI协议分析**\n\n*   **写操作 1 ($C_0$ 写入 $x$):**\n    1.  $C_0$中该行的状态为I，导致写未命中。它向目录发送一个获取独占（Get Exclusive, GetX）请求。这不计入次数。\n    2.  目录收到GetX请求。它看到该行处于未缓存状态。为服务此未命中，目录必须从主存获取数据。\n    3.  目录向内存控制器发送“获取数据”请求。内存控制器用数据块响应。这构成一次目录发起的请求和相应的响应，因此计为$1$次往返。\n    4.  目录更新其内部状态，将$C_0$标记为修改（M）状态的所有者。然后它将数据发送给$C_0$（不计次）。\n    5.  $C_0$接收数据，将缓存行置于M状态，并执行写操作。\n    *   此步骤的往返次数：$1$。\n    *   写操作1之后的状态：目录=(M, 所有者=$C_0$, 共享者={})，$C_0$=(M)，$C_1$=(I)。\n\n*   **写操作 2 ($C_1$ 写入 $x$):**\n    1.  $C_1$中该行的状态为I，导致写未命中。它向目录发送一个GetX请求（不计次）。\n    2.  目录收到GetX请求。它看到该行处于M状态，所有者是$C_0$。为了授予$C_1$独占访问权，目录必须从$C_0$检索最新数据并使$C_0$的副本无效。\n    3.  目录向当前所有者$C_0$发送“转发/无效化”请求。$C_0$收到此请求，使其副本无效（从M转换到I），并将数据块发送回目录。这个由目录发起的请求-响应对计为$1$次往返。\n    4.  目录从$C_0$接收数据，更新其状态以将$C_1$标记为新的M状态所有者，并将数据转发给$C_1$（不计次）。\n    5.  $C_1$将缓存行置于M状态并执行写操作。\n    *   此步骤的往返次数：$1$。\n    *   写操作2之后的状态：目录=(M, 所有者=$C_1$, 共享者={})，$C_0$=(I)，$C_1$=(M)。\n\n*   **后续写操作 (3 到 10):**\n    在写操作2中建立的模式会在后续的每次写操作中重复。每次写操作都来自当前不拥有该行的核心。该核心的行状态为I，导致写未命中。目录将识别另一个核心为M状态的所有者，并向该所有者发起一次“转发/无效化”往返，以检索数据并强制独占性。例如，对于写操作3，$C_0$发送GetX，目录向$C_1$发送“转发/无效化”请求，$C_1$向目录响应。这花费$1$次往返。这种“乒乓”行为在所有剩余的写操作中持续存在。\n\n*   **MESI的总往返次数 ($R_{\\text{MESI}}$):**\n    有$1$次写操作是冷未命中，还有$10-1 = 9$次写操作导致两个核心之间的所有权转移。\n    $$R_{\\text{MESI}} = \\underbrace{1}_{\\text{写操作 1}} + \\underbrace{9 \\times 1}_{\\text{写操作 2-10}} = 10$$\n    在MESI下，由目录发起的总往返次数为$R_{\\text{MESI}} = 10$。\n\n现在，我们分析MOESI协议的序列以确定$R_{\\text{MOESI}}$。\n\n**MOESI协议分析**\n\nMOESI协议增加了拥有（O）状态。O状态是一种*共享脏*状态，它允许一个核心持有一个被修改的缓存行副本，同时其他核心持有只读（共享，S）副本。这在具有脏数据读共享的工作负载中是有益的，因为它允许所有者向其他读取者提供数据，而无需先将其写回内存。\n\n然而，指定的工作负载完全由写操作组成。核心的写操作需要对缓存行的独占所有权。为获得此权限，核心发送获取独占（GetX）请求。在收到GetX请求后，目录的主要职责是确保没有其他核心保留该行的副本，从而将独占权授予请求者。\n\n让我们检查在MOESI下给定工作负载的状态转换：\n*   **写操作 1 ($C_0$ 写入 $x$):** 行为与MESI相同。冷未命中从内存服务。$C_0$以M状态获得该行。这花费$1$次往返（目录 $\\leftrightarrow$ 内存）。\n*   **写操作 2 ($C_1$ 写入 $x$):** $C_1$发送一个GetX请求。目录看到$C_0$以M状态拥有该行。为满足GetX请求，目录必须使$C_0$的副本无效。M $\\rightarrow$ O的转换在这里不适用，因为这意味着共享，这与$C_1$写操作所需的独占访问权相悖。因此，目录向$C_0$发送一个“转发/无效化”请求，$C_0$用数据响应并将自己的状态从M转换到I。这与MESI的情况完全相同，花费$1$次往返。\n*   **后续写操作 (3 到 10):** 同样的逻辑适用。每次写操作都是一个没有有效副本的核心发出的GetX请求。目录必须使当前的M状态所有者无效，以转移独占所有权。“拥有”状态从未被进入，因为从来没有针对脏数据行的获取共享（GetS）请求会触发M $\\rightarrow$ O的转换。\n\n对于这种纯写、乒乓行为的工作负载，MOESI下的操作和消息序列与MESI下的完全相同。\n\n*   **MOESI的总往返次数 ($R_{\\text{MOESI}}$):**\n    计算与MESI的情况相同。\n    $$R_{\\text{MOESI}} = \\underbrace{1}_{\\text{写操作 1}} + \\underbrace{9 \\times 1}_{\\text{写操作 2-10}} = 10$$\n    在MOESI下，由目录发起的总往返次数为$R_{\\text{MOESI}} = 10$。\n\n最后，我们计算相对改进 $I$。\n\n**相对改进的计算 ($I$)**\n\n相对改进的定义为：\n$$I = \\frac{R_{\\text{MESI}} - R_{\\text{MOESI}}}{R_{\\text{MESI}}}$$\n代入计算出的值：\n$$I = \\frac{10 - 10}{10} = \\frac{0}{10} = 0$$\n结果$I=0$表明，对于这种背靠背写操作的特定工作负载，MOESI协议在目录发起的往返次数方面相对于MESI协议没有提供任何改进。“拥有”状态是MOESI的关键特性，但没有被不涉及脏数据读共享的工作负载所利用。",
            "answer": "$$\\boxed{0}$$"
        },
        {
            "introduction": "伪共享（False sharing）是多处理器系统中一个常见的性能瓶颈，它源于缓存行粒度的不精确共享跟踪。本练习将探讨一种重要的架构优化技术——子行粒度（subline granularity），并量化其核心权衡。你将计算目录存储开销的增加与无效化消息减少带来的通信收益，从而具体地理解解决伪共享问题的工程代价与回报。",
            "id": "3635515",
            "problem": "考虑一个共享内存多处理器，它实现了一个基于目录的、采用写无效语义的高速缓存一致性协议。该目录跟踪哪些私有高速缓存持有一个高速缓存行的副本。在基准设计中，每个目录条目包含一个高速缓存行粒度的共享者位向量。在增强设计中，目录通过在字级别跟踪共享者来支持子行粒度。假设一致性协议为“修改-独占-共享-无效”（MESI），其中执行写入的核心必须获得独占所有权，并使所写数据的其他共享者无效。\n\n使用以下基本事实和定义。\n- 在写无效方案中，当一个核心写入一个存在于其他核心共享（Shared）状态下的位置时，它必须使其他共享者无效，以转换到独占（Exclusive）或修改（Modified）状态。\n- 当不同的核心访问同一高速缓存行内的不同字时，会发生伪共享，这会导致对于实际数据依赖而言不必要的一致性操作。\n- 在行粒度下，对一个行的任意字的写入都需要使该行的所有其他共享者无效。\n- 在字粒度下，对特定字的写入仅需要使该字的其他共享者无效。\n\n用于量化的模型假设：\n1. 系统中有 $N$ 个核心。每个高速缓存行包含 $L$ 个字。基准目录为每行使用一个 $N$ 位的共享者向量，而子行目录则使用 $N \\times L$ 位（行中每个字一个 $N$ 位向量）。\n2. 在每次写入之前，目标高速缓存行在 $S_{\\ell}$ 个核心（包括写入者）中处于共享状态。因此，行粒度的无效操作将针对 $S_{\\ell} - 1$ 个其他共享者。\n3. 比例为 $f$ 的写入是伪共享写入，写入的是当前没有其他共享者访问的字；对于此类写入，特定被写入字的共享者数量为 $S_{w}^{(\\text{false})} = 1$（仅写入者）。剩余比例为 $1 - f$ 的写入是真共享写入，被写入字的平均共享者数量为 $S_{w}$（包括写入者）。\n4. 消息度量仅计算发送给其他核心的无效请求消息；不计算确认、数据传输或目录控制消息。根据上述参数确定性地处理平均计数。\n\n任务：\n- 根据这些定义，推导目录复杂度增加因子 $C$（字级设计与行级设计中每个目录条目的位数之比）的表达式。\n- 推导从行级粒度切换到字级粒度时，每次写入的无效请求消息的预期变化量 $\\Delta M$，表示为 $\\Delta M = M_{\\text{word}} - M_{\\text{line}}$。\n\n给定参数：\n- $N = 64$\n- $L = 8$\n- $S_{\\ell} = 8$\n- $f = 0.6$\n- $S_{w} = 3$\n\n在这些参数下计算数对 $(C, \\Delta M)$。将你的最终答案表示为一个行矩阵 $\\begin{pmatrix} C  \\Delta M \\end{pmatrix}$，不要四舍五入；提供没有单位的精确值。",
            "solution": "该问题要求推导和计算与基于目录的高速缓存一致性协议相关的两个量：目录复杂度增加因子（$C$）以及从高速缓存行粒度转为字级粒度时每次写入的无效消息变化量（$\\Delta M$）。\n\n首先，对问题陈述进行验证。\n\n**步骤1：提取给定信息**\n- 核心协议：基于目录，写无效（MESI）。\n- 基准粒度：高速缓存行级别。\n- 增强粒度：字级别。\n- 写入规则：一次写入需要使其他共享者无效以获得独占所有权。\n- 伪共享：当核心访问同一高速缓存行中的不同字时发生。\n- 行粒度无效：写入一个字会使该行的所有其他共享者无效。\n- 字粒度无效：写入一个字仅使该字的其他共享者无效。\n- 核心数：$N$。\n- 每高速缓存行字数：$L$。\n- 基准目录每行位数：$N$。\n- 子行目录每行位数：$N \\times L$。\n- 写入前一行的共享者数：$S_{\\ell}$（包括写入者）。\n- 伪共享写入的比例：$f$。\n- 伪共享写入时特定字的共享者数：$S_{w}^{(\\text{false})} = 1$。\n- 真共享写入的比例：$1 - f$。\n- 真共享写入时特定字的平均共享者数：$S_{w}$（包括写入者）。\n- 消息度量：发送到其他核心的无效请求消息计数。\n- 给定参数：$N = 64$，$L = 8$，$S_{\\ell} = 8$，$f = 0.6$，$S_{w} = 3$。\n\n**步骤2：使用提取的给定信息进行验证**\n该问题具有科学依据，描述了计算机体系结构中关于高速缓存一致性粒度的一个标准权衡。目录协议、MESI、伪共享和子块（sub-blocking）等概念是公认的。该问题是适定（well-posed）的，提供了推导唯一确定性解所需的所有必要定义、变量和参数。语言客观而精确。所提供的参数在物理上和逻辑上是一致的（例如，$S_{w} \\le S_{\\ell}$）。该问题不违反任何无效性标准。\n\n**步骤3：结论与行动**\n问题被判定为有效。将制定一个完整的解决方案。\n\n**目录复杂度增加因子 $C$ 的推导**\n\n复杂度增加因子 $C$ 定义为字级设计中每个目录条目的位数与行级设计中每个目录条目的位数之比。设 $B_{\\text{word}}$ 为字级设计的位数，$B_{\\text{line}}$ 为行级设计的位数。\n\n根据模型假设1：\n- 基准（行级）目录为每行使用一个 $N$ 位的共享者向量。因此，$B_{\\text{line}} = N$。\n- 子行（字级）目录为行中的 $L$ 个字各使用一个 $N$ 位向量。因此，$B_{\\text{word}} = N \\times L$。\n\n那么复杂度增加因子 $C$ 为：\n$$\nC = \\frac{B_{\\text{word}}}{B_{\\text{line}}} = \\frac{N \\times L}{N} = L\n$$\n代入给定值 $L = 8$：\n$$\nC = 8\n$$\n\n**无效消息变化量 $\\Delta M$ 的推导**\n\n每次写入的无效消息变化量 $\\Delta M$ 定义为 $\\Delta M = M_{\\text{word}} - M_{\\text{line}}$，其中 $M_{\\text{word}}$ 和 $M_{\\text{line}}$ 分别是字级和行级粒度下每次写入的预期无效消息数。\n\n首先，我们确定 $M_{\\text{line}}$。\n对于行级粒度，对高速缓存行的任何写入都需要使该行的所有其他共享者无效。根据假设2，该行被 $S_{\\ell}$ 个核心共享，包括执行写入的核心。因此，其他共享者的数量是 $S_{\\ell} - 1$。在此模型中，每次写入发送的无效消息数量是恒定的。\n$$\nM_{\\text{line}} = S_{\\ell} - 1\n$$\n代入给定值 $S_{\\ell} = 8$：\n$$\nM_{\\text{line}} = 8 - 1 = 7\n$$\n\n接下来，我们确定 $M_{\\text{word}}$。\n对于字级粒度，无效的数量取决于共享正在被写入的特定字的其他核心的数量。这是一个基于写入构成真共享还是伪共享的概率计算。预期的消息数是各种结果按其概率加权后的总和。\n\n问题为一次写入定义了两种互斥的情况：\n1. **伪共享写入：** 这种情况以概率（比例） $f$ 发生。对于此类写入，特定字的共享者数量为 $S_{w}^{(\\text{false})} = 1$（仅写入者）。发送的无效消息数量为 $S_{w}^{(\\text{false})} - 1 = 1 - 1 = 0$。\n2. **真共享写入：** 这种情况以概率 $1 - f$ 发生。对于此类写入，特定字的平均共享者数量为 $S_{w}$。发送的平均无效消息数量为 $S_{w} - 1$。\n\n每次写入的预期无效消息数 $M_{\\text{word}}$ 为：\n$$\nM_{\\text{word}} = f \\times (S_{w}^{(\\text{false})} - 1) + (1 - f) \\times (S_{w} - 1)\n$$\n代入 $S_{w}^{(\\text{false})} = 1$：\n$$\nM_{\\text{word}} = f \\times (1 - 1) + (1 - f) \\times (S_{w} - 1) = (1 - f)(S_{w} - 1)\n$$\n代入给定值 $f = 0.6$ 和 $S_{w} = 3$：\n$$\nM_{\\text{word}} = (1 - 0.6) \\times (3 - 1) = 0.4 \\times 2 = 0.8\n$$\n\n最后，我们计算变化量 $\\Delta M$：\n$$\n\\Delta M = M_{\\text{word}} - M_{\\text{line}}\n$$\n使用推导出的表达式：\n$$\n\\Delta M = (1 - f)(S_{w} - 1) - (S_{\\ell} - 1)\n$$\n代入计算出的数值：\n$$\n\\Delta M = 0.8 - 7 = -6.2\n$$\n负值表示无效消息的减少，这是子行粒度对于具有显著伪共享的工作负载的预期好处。\n\n计算出的数对是 $(C, \\Delta M) = (8, -6.2)$。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 8  -6.2 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "目录协议的整体效率不仅取决于其自身设计，还深受系统中各私有缓存（private cache）策略的影响。本练习以经典的生产者-消费者模型为背景，分析并量化一级缓存的写回（write-back）与写通（write-through）策略对全局一致性消息流量的影响。通过这个练习，你将学会如何将局部决策与系统级性能联系起来，这是评估复杂计算机系统时的一项关键技能。",
            "id": "3635552",
            "problem": "一个计算机系统实现了一种集中式基于目录的缓存一致性协议，其修改-独占-共享-无效 (MESI) 状态在共享的末级缓存（该缓存也容纳了目录）中进行跟踪。考虑一个在共享内存中以环形缓冲区形式实现的单生产者/单消费者队列。生产者核心为每个队列槽位写入一个标量值，消费者核心按程序顺序将每个生产出的值精确读取一次。定义行复用率 $u$ 为，在消费者对某个缓存行执行首次读取之前，生产者映射并写入该缓存行的连续项目（生产出的值）的期望数量；假设 $u \\ge 1$，并且 $u$ 可被视为一个代表平均值的实值参数。假设存在以下微架构和协议条件，每一条都是标准且科学上现实的：\n\n- 目录是包容性的，并与末级缓存位于同一位置，末级缓存向请求者提供数据，除非某个私有缓存以“修改 (Modified)”状态持有该行。\n- 生产者和消费者核心是唯一会访问队列缓存行的缓存。没有其他共享者。\n- 消费者读完一个缓存行后，两个缓存都可以“共享 (Shared)”状态保留该行。在生产者再次写入该行之前，它以“共享 (Shared)”状态持有该行，并且必须升级到“修改 (Modified)”状态。在所考虑的时间间隔内，没有容量驱逐，也没有预取。\n- 消费者对生产者刚更新过的行的首次读取，会导致消费者私有缓存的读未命中。消费者对同一行的后续读取将在本地命中，不产生一致性流量。\n- 只计算在私有缓存和目录之间，或目录和私有缓存之间传输的点对点一致性消息。末级缓存内部的内存阵列访问不单独计数。每条不同的一致性或数据消息都精确地计为 $1$ 条消息。\n\n在保持目录协议不变的情况下，私有一级缓存可以配置为以下两种策略之一：\n\n- 写回策略 (WB)：对处于“修改 (Modified)”状态的行的存储操作不会向目录发送数据，直到一致性协议要求降级或写回为止。\n- 写通策略 (WT)：对处于“修改 (Modified)”状态的行的存储操作会立即将更新后的数据发送到目录/末级缓存。假设采用写分配策略，并且每个存储操作都会精确地向目录产生 $1$ 条写通数据消息。\n\n在这些假设下，对于单个缓存行的生产者-消费者“交接”周期（生产者写入该行，然后消费者读取一次），会发生以下一致性操作：\n\n- 在新周期中，生产者对其首次存储到该行之前，会从“共享”升级到“修改”状态：从生产者到目录恰好有 $1$ 条升级请求，从目录到消费者恰好有 $1$ 条无效化消息，从消费者到目录恰好有 $1$ 条确认消息。升级时没有数据发送给生产者，因为它已经持有一个有效的“共享”副本。\n- 周期内消费者对该行的首次读未命中：\n  - 在 WB 策略下：从消费者到目录恰好有 $1$ 条读请求；因为生产者以“修改”状态持有最新数据，目录向生产者发送恰好 $1$ 条召回消息，从生产者接收恰好 $1$ 条写回数据消息，然后向消费者发送恰好 $1$ 条数据响应，这也会将生产者的状态降级为“共享”。\n  - 在 WT 策略下：从消费者到目录恰好有 $1$ 条读请求；由于写通策略，末级缓存已持有最新数据，因此目录向消费者发送恰好 $1$ 条数据响应，并向生产者发送恰好 $1$ 条降级消息，生产者以恰好 $1$ 条确认消息作为回复。\n\n设计一个由这类交接周期的长期稳态运行组成的微基准测试，并根据第一性原理和上述定义，推导对于写回和写通两种策略，每个生产出的项目对应的目录可见消息的期望总数，作为行复用率 $u$ 的函数的闭式表达式。你的推导必须：\n\n- 从 MESI 状态和目录介导的状态转换的定义，以及上面规定的消息序列出发。\n- 考虑到消费者在首次未命中后对同一行的后续读取不产生一致性消息这一事实。\n- 在 WT 策略下，考虑到生产者的 $u$ 次行内存储每次都会向目录生成一条写通数据消息，而在 WB 策略下，稳态中没有因每次存储而产生的消息。\n\n将你的最终结果以单行矩阵的形式报告，其中第一个条目是写回策略下每个项目的期望消息数，第二个条目是写通策略下每个项目的期望消息数。不需要进行数值舍入，最终结果应为关于 $u$ 的精确解析表达式。",
            "solution": "目标是为单生产者/单消费者队列推导出每个生产出的项目对应的目录可见消息的期望数量的闭式表达式。推导将针对两种私有缓存策略进行：写回 (WB) 和写通 (WT)。分析基于单个缓存行的稳态交接周期，该周期对应于 $u$ 个项目的生产，其中 $u$ 是行复用率。\n\n题目将一个交接周期定义为从生产者准备写入共享缓存行开始，写入 $u$ 个项目，随后消费者读取这 $u$ 个项目的事件序列。我们将计算这样一个周期的一致性消息总数，然后除以 $u$，以得到每个项目的平均消息数。\n\n让我们按照题目描述，分不同阶段来分析这个周期。一个周期开始时，生产者和消费者的缓存都以前一个周期遗留的共享 (S) 状态持有该行。\n\n阶段 1：生产者升级\n为了写入缓存行，生产者必须首先通过将其状态从共享 (S) 升级到修改 (M) 来获得独占所有权。根据题目，此操作需要：\n- 从生产者到目录的 $1$ 条升级请求消息。\n- 从目录到消费者缓存的 $1$ 条无效化消息。\n- 从消费者到目录的 $1$ 条确认消息。\n升级阶段的总消息数 $N_{upg}$ 对两种策略都是恒定的：\n$$N_{upg} = 1 + 1 + 1 = 3$$\n\n阶段 2：生产者存储\n在获得“修改”状态后，生产者向缓存行中写入 $u$ 个不同的标量值。这些存储操作的消息成本取决于缓存策略。\n\n阶段 3：消费者读取\n消费者读取生产出的 $u$ 个项目。消费者对更新后的行的首次读取将导致读未命中，因为其副本已在阶段 1 中被无效化。对同一行中其他 $u-1$ 个项目的后续读取将是本地命中，并且如前所述，不产生一致性流量。我们只需要计算由初始读未命中产生的消息。\n\n现在我们来为每种策略计算每个周期和每个项目的总消息数。\n\n**写回 (WB) 策略**\n\n在 WB 策略中，对处于“修改”状态的行的存储操作在生产者的私有缓存中本地处理，不产生网络流量。\n- 阶段 2 (生产者存储)：$u$ 次存储不产生任何消息。\n$$N_{stores, WB} = 0$$\n- 阶段 3 (消费者的首次读取)：消费者的读未命中得到服务。题目明确了 WB 的序列：目录必须从生产者那里召回数据，因为生产者以“修改”状态持有唯一的最新副本。\n  - 从消费者到目录的 $1$ 条读请求。\n  - 从目录到生产者的 $1$ 条召回消息。\n  - 从生产者到目录的 $1$ 条写回数据消息。\n  - 从目录到消费者的 $1$ 条数据响应消息。\n在 WB 策略下，消费者读未命中产生的总消息数是：\n$$N_{read, WB} = 1 + 1 + 1 + 1 = 4$$\n\n一个完整交接周期的总消息数 ($N_{cycle, WB}$) 是所有阶段消息数的总和：\n$$N_{cycle, WB} = N_{upg} + N_{stores, WB} + N_{read, WB} = 3 + 0 + 4 = 7$$\n这个周期对应于 $u$ 个项目的生产。每个项目的期望消息数 $M_{item, WB}$ 是每个周期的总消息数除以 $u$：\n$$M_{item, WB} = \\frac{N_{cycle, WB}}{u} = \\frac{7}{u}$$\n\n**写通 (WT) 策略**\n\n在 WT 策略中，每次对处于“修改”状态的行的存储操作也会将数据发送到目录。\n- 阶段 2 (生产者存储)：$u$ 次存储中的每一次都会向目录生成一条写通数据消息。\n$$N_{stores, WT} = u \\times 1 = u$$\n- 阶段 3 (消费者的首次读取)：消费者的读未命中得到服务。对于 WT 策略，目录/L3 已经拥有最新数据。题目明确了序列：\n  - 从消费者到目录的 $1$ 条读请求。\n  - 从目录到消费者的 $1$ 条数据响应。\n  - 从目录到生产者的 $1$ 条降级消息（将其状态从 M 更改为 S）。\n  - 从生产者到目录的 $1$ 条确认消息。\n在 WT 策略下，消费者读未命中产生的总消息数是：\n$$N_{read, WT} = 1 + 1 + 1 + 1 = 4$$\n\n一个完整交接周期的总消息数 ($N_{cycle, WT}$) 是所有阶段消息数的总和：\n$$N_{cycle, WT} = N_{upg} + N_{stores, WT} + N_{read, WT} = 3 + u + 4 = u + 7$$\n这个周期同样对应于 $u$ 个项目的生产。每个项目的期望消息数 $M_{item, WT}$ 是每个周期的总消息数除以 $u$：\n$$M_{item, WT} = \\frac{N_{cycle, WT}}{u} = \\frac{u + 7}{u} = 1 + \\frac{7}{u}$$\n\n最终结果是一个行矩阵，分别包含 WB 和 WT 策略下每个项目的期望消息数的表达式。",
            "answer": "$$ \\boxed{ \\begin{pmatrix} \\frac{7}{u} & 1 + \\frac{7}{u} \\end{pmatrix} } $$"
        }
    ]
}