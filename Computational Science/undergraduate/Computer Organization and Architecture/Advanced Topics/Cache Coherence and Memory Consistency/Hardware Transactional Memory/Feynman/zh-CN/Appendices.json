{
    "hands_on_practices": [
        {
            "introduction": "理解事务冲突的可能性是分析硬件事务内存（HTM）性能的第一步。这项练习提供了一个基础模型，让你能够根据线程数、内存大小和缓存行大小等关键系统参数来量化冲突概率。通过这个练习，你将建立起关于争用如何随着系统规模扩展的直观认识。",
            "id": "3645919",
            "problem": "一个微基准测试被设计用来压力测试硬件事务内存 (HTM) 中的冲突行为。有 $N$ 个并发线程。每个线程执行恰好一个事务，该事务原子地执行以下步骤：从一个数组中均匀随机地选取单个缓存行，并向其写入一个机器字。该数组总大小为 $M$ 字节，按缓存行边界对齐，且缓存行大小为 $L$ 字节。假设 $M$ 是 $L$ 的整数倍，因此数组中恰好有 $M/L$ 个不同的缓存行。硬件在缓存行粒度上检测写-写和写-读重叠的冲突，如果任何其他并发事务访问（读取或写入）其写集中的任何缓存行，事务就会中止。在这个基准测试中，所有事务都进行写入操作而不进行读取操作，因此唯一可能的冲突是缓存行上的写-写重叠。所有 $N$ 个事务在时间上重叠，并尝试同时提交。每个线程对缓存行的选择是独立的，并且在 $M/L$ 个缓存行上均匀分布。\n\n仅使用 HTM 冲突检测的核心定义和基本概率法则，推导出一个特定线程的事务因冲突而中止的概率的精确封闭形式表达式，该表达式是关于 $N$、$M$ 和 $L$ 的函数。将您的最终答案表示为关于 $N$、$M$ 和 $L$ 的简化符号表达式。不要进行近似或四舍五入。",
            "solution": "问题陈述已经过严格验证，被认为是有效的。它在科学上基于计算机体系结构和概率论的原理，问题定义明确、客观且自洽。因此，将提供一个解决方案。\n\n设 $N$ 为并发线程的数量，$M$ 为数组的总大小（以字节为单位），$L$ 为缓存行的大小（以字节为单位）。问题陈述指出 $M$ 是 $L$ 的整数倍。因此，不同缓存行的总数（我们记为 $C$）由下式给出：\n$$C = \\frac{M}{L}$$\n$N$ 个线程中的每一个都执行一个事务，该事务涉及向从 $C$ 个可用缓存行中独立且均匀随机选择的单个缓存行进行写入。\n\n我们被要求计算一个*特定*线程的事务中止的概率。让我们任意选择一个线程，比如线程1，并计算其事务中止的概率。如果存在冲突，则会发生中止。根据问题描述，线程1发生冲突的条件是，任何其他并发事务访问了线程1为其写入操作选择的同一个缓存行。由于总共有 $N$ 个线程，因此有 $N-1$ 个其他线程可能与线程1产生冲突。\n\n如果其他 $N-1$ 个线程中至少有一个选择了与线程1相同的缓存行，那么线程1的事务将中止。在概率论中，计算互补事件通常更简单：即线程1的事务*成功*（即不中止）的概率。我们将线程1中止的事件记为 $A$，成功的事件记为 $A^c$。我们寻求的概率是 $P(A)$。我们将首先计算 $P(A^c)$，然后使用关系式 $P(A) = 1 - P(A^c)$。\n\n线程1的事务成功的充要条件是，*所有*其他 $N-1$ 个线程都选择了与线程1所选缓存行*不同*的缓存行。\n\n设 $c_i$ 为线程 $i$ 选择的缓存行，其中 $i \\in \\{1, 2, \\dots, N\\}$。每个 $c_i$ 都是一个在 $C$ 个缓存行集合上均匀分布的独立随机变量。\n\n让我们考虑另一个线程，比如线程 $j$，其中 $j \\in \\{2, 3, \\dots, N\\}$。线程1选择的缓存行 $c_1$ 可以是 $C$ 个缓存行中的任意一个。线程 $j$ 选择的缓存行 $c_j$ 也可以是 $C$ 个缓存行中的任意一个。由于选择是均匀的，线程 $j$ 选择与线程1完全相同的缓存行的概率是：\n$$P(c_j = c_1) = \\frac{1}{C}$$\n因此，线程 $j$ 选择与线程1*不同*的缓存行的概率是：\n$$P(c_j \\neq c_1) = 1 - P(c_j = c_1) = 1 - \\frac{1}{C} = \\frac{C-1}{C}$$\n事件 $A^c$（线程1成功）发生，当且仅当条件 $c_j \\neq c_1$ 对所有其他线程（即 $j = 2, 3, \\dots, N$）都成立。\n$$A^c \\equiv (c_2 \\neq c_1) \\land (c_3 \\neq c_1) \\land \\dots \\land (c_N \\neq c_1)$$\n问题陈述指出每个线程对缓存行的选择是独立的。因此，这个复合事件的概率是各个独立事件概率的乘积：\n$$P(A^c) = P(c_2 \\neq c_1) \\times P(c_3 \\neq c_1) \\times \\dots \\times P(c_N \\neq c_1)$$\n因为有 $N-1$ 个这样的线程，并且每个线程的概率都相同，我们得到：\n$$P(A^c) = \\left( \\frac{C-1}{C} \\right)^{N-1}$$\n现在，我们可以求出中止的概率 $P(A)$，这正是问题所要求的：\n$$P(A) = 1 - P(A^c) = 1 - \\left( \\frac{C-1}{C} \\right)^{N-1}$$\n最后一步是将 $C$ 的表达式用给定的变量 $M$ 和 $L$ 代入。\n$$C = \\frac{M}{L}$$\n将此代入我们关于 $P(A)$ 的表达式中：\n$$P(A) = 1 - \\left( \\frac{\\frac{M}{L} - 1}{\\frac{M}{L}} \\right)^{N-1}$$\n我们可以简化括号内的项：\n$$\\frac{\\frac{M}{L} - 1}{\\frac{M}{L}} = 1 - \\frac{1}{\\frac{M}{L}} = 1 - \\frac{L}{M}$$\n因此，一个特定线程的事务中止的概率的精确封闭形式表达式为：\n$$P(A) = 1 - \\left( 1 - \\frac{L}{M} \\right)^{N-1}$$\n该表达式是关于 $N$、$M$ 和 $L$ 的函数，符合要求。",
            "answer": "$$ \\boxed{1 - \\left(1 - \\frac{L}{M}\\right)^{N-1}} $$"
        },
        {
            "introduction": "在了解了直接数据冲突之后，我们来探讨一个更微妙的问题：伪共享（false sharing）。由于HTM的冲突检测粒度是缓存行级别，即使事务没有访问完全相同的内存地址，只要它们访问了位于同一缓存行内的不同数据，也可能导致事务中止 。本练习将指导你应用一种具体的优化技术——数据填充（padding），通过将数据结构与缓存行边界对齐来减少伪共享，从而提升性能。",
            "id": "3645968",
            "problem": "一个多处理器实现了硬件事务内存（HTM），它以缓存行粒度检测冲突：如果两个并发事务访问位于同一缓存行上的不同对象，并且至少有一次访问是写操作，那么这两个事务就会发生冲突。\n\n考虑一个在内存中连续存储的相同结构体数组。每个结构体的有效负载大小为 $S$ 字节。您可以在每个结构体之后插入大小为 $P$ 字节的显式填充，以使每个对象的步长为 $B = S + P$ 字节。分配器将数组的起始地址与缓存行边界对齐，并且您必须遵守一个对齐约束，即 $B$ 必须是 $a$ 字节的倍数。假设 $B \\le L$，因此没有对象会跨越缓存行边界。在这些条件下，每个缓存行恰好包含 $k = \\left\\lfloor \\frac{L}{B} \\right\\rfloor$ 个对象。\n\n工作负载模型：在每个冲突检测窗口中，恰好有两个并发事务。它们从一个由 $W$ 个连续缓存行组成的热工作集中，以均匀随机且不放回的方式选择两个不同的对象。这些缓存行完全由数组对象填充。每个事务对其选定的对象执行一次写操作。当且仅当两个选定的对象不同但映射到同一缓存行时，会发生伪冲突。\n\n仅使用上述核心定义（缓存行粒度的冲突检测和从 $W$ 行工作集中均匀不放回选择），确定最小的整数填充 $P$（以字节为单位），使得伪冲突的概率小于或等于给定的阈值 $\\theta$。\n\n使用以下参数：\n- 缓存行大小：$L = 64$ 字节。\n- 结构体有效负载大小：$S = 20$ 字节。\n- 要求步长对齐：$a = 8$ 字节。\n- 工作集大小：$W = 32$ 个缓存行。\n- 阈值：$\\theta = 0.02$。\n\n将您的最终答案表述为最小填充 $P$（以字节为单位）。无需四舍五入。将最终答案表示为单个字节数。",
            "solution": "用户希望我在验证问题后解决以下问题。\n\n### 步骤1：提取已知条件\n- 硬件事务内存（HTM），冲突检测粒度为缓存行。\n- 冲突条件：两个并发事务访问同一缓存行上的不同对象，且至少有一次访问是写操作。\n- 一个相同结构体的数组在内存中连续存储。\n- 结构体有效负载大小：$S$ 字节。\n- 每个结构体的显式填充：$P$ 字节。\n- 每个对象的步长：$B = S + P$ 字节。\n- 数组起始地址与缓存行边界对齐。\n- 对齐约束：$B$ 必须是 $a$ 字节的倍数。\n- 步长约束：$B \\le L$。\n- 每个缓存行的对象数量：$k = \\left\\lfloor \\frac{L}{B} \\right\\rfloor$。\n- 工作负载：每个冲突检测窗口中有两个并发事务。\n- 对象选择：从一个热工作集中以均匀随机且不放回的方式选择两个不同的对象。\n- 工作集：$W$ 个连续的缓存行，完全由数组对象填充。\n- 访问类型：每个事务执行一次写操作。\n- 伪冲突：两个选定的对象不同但映射到同一缓存行。\n- 目标：找到最小的整数填充 $P$（以字节为单位），使得伪冲突的概率小于或等于阈值 $\\theta$。\n- 参数：\n    - 缓存行大小：$L = 64$ 字节。\n    - 结构体有效负载大小：$S = 20$ 字节。\n    - 要求步长对齐：$a = 8$ 字节。\n    - 工作集大小：$W = 32$ 个缓存行。\n    - 阈值：$\\theta = 0.02$。\n\n### 步骤2：使用提取的已知条件进行验证\n该问题具有科学依据，因为它使用了计算机体系结构研究中常见的缓存行为和硬件事务内存的标准简化模型。缓存行、填充、对齐和冲突检测等概念定义明确。该问题是适定的，提供了所有必要的参数和一个明确的目标（在概率约束下最小化整数 $P$）。语言客观且正式。设置在内部是一致的，没有违反任何物理或数学原理。该问题是将组合概率论应用于计算机体系结构场景的一个非平凡的应用。因此，它是有效的。\n\n### 步骤3：结论与行动\n问题有效。我将继续进行解答。\n\n### 解题推导\n目标是找到满足一组约束条件的最小整数填充 $P \\ge 0$。我们首先推导伪冲突概率 $P_f$ 的表达式。\n\n工作集由 $W$ 个缓存行组成。每个缓存行完全填充了 $k$ 个对象，其中 $k = \\lfloor \\frac{L}{B} \\rfloor$ 且 $B = S + P$。工作集中的对象总数为 $N = W \\cdot k$。\n\n工作负载是从这 $N$ 个对象中以均匀随机且不放回的方式选择两个不同的对象。选择两个不同对象的总方式数由二项式系数 $\\binom{N}{2}$ 给出：\n$$ \\text{总对数} = \\binom{N}{2} = \\frac{N(N-1)}{2} $$\n如果两个选定的对象不同但位于同一缓存行上，则会发生伪冲突。为了计算此类对象对的数量，我们可以单独考虑每个缓存行。在一个缓存行内，有 $k$ 个对象。从这一个缓存行中选择两个不同对象的方式数为 $\\binom{k}{2}$。\n$$ \\text{每行的冲突对数} = \\binom{k}{2} = \\frac{k(k-1)}{2} $$\n由于工作集中有 $W$ 个独立的缓存行，导致伪冲突的总对数是该值的 $W$ 倍：\n$$ \\text{总冲突对数} = W \\cdot \\binom{k}{2} = W \\frac{k(k-1)}{2} $$\n伪冲突的概率 $P_f$ 是冲突对数与总对数的比值：\n$$ P_f = \\frac{W \\frac{k(k-1)}{2}}{\\frac{N(N-1)}{2}} = \\frac{W k(k-1)}{N(N-1)} $$\n将 $N = Wk$ 代入 $P_f$ 的表达式中：\n$$ P_f = \\frac{W k(k-1)}{Wk(Wk-1)} = \\frac{k-1}{Wk-1} $$\n这个 $P_f$ 的表达式在 $k > 1$ 时有效。如果 $k=1$，每个缓存行只有一个对象，不可能从同一行中选择两个不同的对象。在这种情况下，冲突对数为 $0$，因此 $P_f = 0$。公式 $\\frac{k-1}{Wk-1}$ 在 $k=1$ 时正确地得出 $0$。\n\n我们需要找到满足以下条件的最小整数 $P \\ge 0$：\n1. 步长 $B = S + P$ 必须是 $a$ 的倍数。\n2. 步长 $B$ 不能超过缓存行大小，即 $B \\le L$。\n3. 伪冲突的概率必须最多为 $\\theta$，即 $P_f \\le \\theta$。\n\n代入给定参数：$S=20$，$L=64$，$a=8$，$W=32$，和 $\\theta=0.02$。\n步长为 $B = 20 + P$。每个缓存行的对象数量为 $k = \\lfloor \\frac{64}{20+P} \\rfloor$。\n这些条件变为：\n1. $20+P$ 必须是 $8$ 的倍数。\n2. $20+P \\le 64$，这意味着 $P \\le 44$。\n3. $\\frac{k-1}{32k-1} \\le 0.02$。\n\n我们来分析这些约束条件。函数 $f(k) = \\frac{k-1}{Wk-1}$ 对于 $k \\ge 1$ 是单调递增的（因为 $W > 1$）。为了满足 $P_f \\le \\theta$，我们需要使 $P_f$ 更小。这需要使 $k$ 更小。为了使 $k = \\lfloor L/B \\rfloor$ 更小，我们必须使步长 $B = S+P$ 更大。因此，我们需要找到最小的填充 $P$，使得 $B$ 足够大，从而将 $k$ 减小到满足概率约束的水平。\n\n我们可以系统地测试 $P$ 的允许值，从最小的可能值开始，直到找到一个满足所有条件的值。\n根据约束1，$20+P$ 必须是 $8$ 的倍数。由于 $20 \\pmod 8 = 4$，我们必须有 $(4+P) \\pmod 8 = 0$。这意味着 $P$ 必须是 $8m - 4$ 的形式，其中 $m$ 是某个正整数。通过取 $m=1, 2, 3, \\dots$，可以得到 $P$ 的最小非负整数值：\n- $m=1: P = 8(1)-4 = 4$\n- $m=2: P = 8(2)-4 = 12$\n- $m=3: P = 8(3)-4 = 20$\n- 以此类推。所有这些潜在的 $P$ 值都小于或等于 $44$。\n\n让我们测试最小的可能值，$P=4$。\n- **测试 $P=4$**：\n    - 这是满足对齐约束的最小非负整数 $P$。\n    - 计算步长：$B = S+P = 20+4 = 24$ 字节。\n    - 检查约束2：$B=24 \\le 64$。此条件满足。\n    - 计算每个缓存行的对象数量：$k = \\lfloor \\frac{L}{B} \\rfloor = \\lfloor \\frac{64}{24} \\rfloor = \\lfloor 2.66\\dots \\rfloor = 2$。\n    - 计算 $k=2$ 时的伪冲突概率：\n      $$ P_f = \\frac{k-1}{Wk-1} = \\frac{2-1}{32(2)-1} = \\frac{1}{64-1} = \\frac{1}{63} $$\n    - 检查概率约束（条件3）：\n      $$ \\frac{1}{63} \\le 0.02 $$\n      为了检查这个不等式，我们可以将 $0.02$ 写成 $\\frac{2}{100} = \\frac{1}{50}$。不等式为 $\\frac{1}{63} \\le \\frac{1}{50}$，这是成立的。\n      或者，$1 \\le 0.02 \\times 63 = 1.26$，这也是成立的。\n\n由于满足对齐约束的最小可能填充 $P=4$ 也满足概率阈值，因此它是所需的最小填充。无需测试更大的 $P$ 值。\n\n最小整数填充为 $4$ 字节。",
            "answer": "$$\\boxed{4}$$"
        },
        {
            "introduction": "当事务不可避免地因冲突而中止时，系统的重试策略就变得至关重要。这个练习将我们的关注点从“预防冲突”转移到“管理冲突”。通过对两种常见的重试策略——有界重试和指数退避——进行建模和比较，你将能够定量地分析它们在不同争用水平下的性能表现，并理解选择合适争用管理策略的重要性 。",
            "id": "3645908",
            "problem": "一个处理器实现了硬件事务内存（HTM）。考虑一个单线程在有许多对称竞争者的静态环境中使用HTM。将来自其他线程的冲突临界区到达建模为速率为 $\\lambda$ 的泊松过程。一个事务的脆弱执行窗口长度为 $t_s$，竞争水平定义为 $c \\equiv \\lambda t_s$。根据泊松过程的性质，一个HTM尝试在其脆弱窗口期间遇到零个冲突到达的概率是 $\\exp(-\\lambda t_s)=\\exp(-c)$。每次成功的HTM尝试在时间 $t_s$ 内完成。每次中止的HTM尝试会产生该次尝试的开销外加一笔中止惩罚 $h$，总成本为 $t_s+h$。在用尽重试预算后，线程将回退到一条固定的、时间为 $t_f$ 的非事务性慢速路径。\n\n考虑两种重试策略：\n- 有界重试无退避：连续进行最多 $r$ 次事务性尝试（没有刻意等待），如果所有事务性尝试都中止，则调用慢速路径。在此策略下，假设每次尝试的成功概率是恒定的，等于 $\\exp(-c)$。\n- 指数退避：在第 $k$ 次事务性尝试之前，线程等待一个退避时长 $w_k=d_0 \\alpha^{k-1}$，其中 $d_0>0$ 和 $\\alpha>1$ 是固定值。假设这种协调的退避将第 $k$ 次尝试的有效冲突率降低到 $\\lambda/\\alpha^{k-1}$，因此第 $k$ 次尝试的成功概率为 $\\exp\\!\\big(-\\lambda t_s/\\alpha^{k-1}\\big)=\\exp\\!\\big(-c/\\alpha^{k-1}\\big)$。如果所有 $R_b$ 次由退避控制的尝试都中止，则采用慢速路径。\n\n仅从 $c$ 的定义、泊松“无到达”定律以及独立尝试的标准概率出发：\n1) 推导有界重试策略的预期成功时间 $E[T]$ 的解析表达式，该表达式是 $r$、$c$、$t_s$、$h$ 和 $t_f$ 的函数。\n2) 推导限制为 $R_b$ 次尝试的指数退避策略的预期成功时间 $E[T]$ 的解析表达式，该表达式是 $c$、$\\alpha$、$d_0$、$t_s$、$h$ 和 $t_f$ 的函数。\n3) 使用您在第 (1) 部分得到的表达式，确定最优整数重试限制 $r^{\\*}$，以最小化在以下参数集下的有界重试 $E[T]$：\n- $t_s = 20$ 微秒，\n- $h = 5$ 微秒，\n- $t_f = 120$ 微秒，\n- $c = 2$。\n然后，使用相同的参数以及指数退避参数：\n- $d_0 = 10$ 微秒，\n- $\\alpha = 2$，\n- $R_b = 3$，\n数值评估在 $r^{\\*}$ 处的有界重试 $E[T]$ 和在 $R_b$ 次尝试处的指数退避 $E[T]$。\n\n将所有数值时间值四舍五入到 $4$ 位有效数字。时间以微秒表示。将您的最终答案以行矩阵 $\\big(r^{\\*},\\,E[T]_{\\text{bounded at }r^{\\*}},\\,E[T]_{\\text{backoff at }R_b}\\big)$ 的形式报告。",
            "solution": "用户提供了一个关于在两种不同重试策略下对硬件事务内存（HTM）性能进行建模的问题。我将首先验证问题陈述，然后进行完整解答。\n\n### 问题验证\n\n**步骤1：提取给定信息**\n\n- **过程模型**：冲突临界区的到达被建模为速率为 $\\lambda$ 的泊松过程。\n- **脆弱窗口**：事务的脆弱执行窗口长度为 $t_s$。\n- **竞争水平**：$c \\equiv \\lambda t_s$。\n- **成功概率（通用）**：在脆弱窗口期间零冲突到达的概率为 $\\exp(-\\lambda t_s) = \\exp(-c)$。\n- **尝试成本**：\n    - 一次成功的HTM尝试在时间 $t_s$ 内完成。\n    - 一次中止的HTM尝试成本为 $t_s+h$，其中 $h$ 是中止惩罚。\n- **回退路径**：在用尽重试预算后，采用一条固定的、时间为 $t_f$ 的非事务性慢速路径。\n\n- **策略1：有界重试无退避**\n    - **重试限制**：连续进行最多 $r$ 次尝试。\n    - **成功概率**：每次尝试的成功概率是恒定的，$P_s = \\exp(-c)$。\n\n- **策略2：指数退避**\n    - **重试限制**：最多 $R_b$ 次尝试。\n    - **退避等待**：在第 $k$ 次尝试前，线程等待 $w_k = d_0 \\alpha^{k-1}$，其中 $d_0>0$ 且 $\\alpha>1$。\n    - **成功概率**：第 $k$ 次尝试的成功概率为 $P_{s,k} = \\exp(-c/\\alpha^{k-1})$。\n\n- **第3部分的数值参数**：\n    - $t_s = 20$ 微秒\n    - $h = 5$ 微秒\n    - $t_f = 120$ 微秒\n    - $c = 2$\n    - $d_0 = 10$ 微秒\n    - $\\alpha = 2$\n    - $R_b = 3$\n\n- **要求输出**：\n    1. 有界重试策略的预期成功时间 $E[T]$ 的解析表达式。\n    2. 指数退避策略的预期成功时间 $E[T]$ 的解析表达式。\n    3. 在给定参数下，有界重试策略的最优整数重试限制 $r^*$。\n    4. 在其指定的重试限制（$r^*$ 和 $R_b$）下，两种策略的 $E[T]$ 的数值。最终答案以行矩阵形式呈现：$(r^{\\*},\\,E[T]_{\\text{bounded at }r^{\\*}},\\,E[T]_{\\text{backoff at }R_b}\\big)$，时间值四舍五入到4位有效数字。\n\n**步骤2：使用提取的给定信息进行验证**\n\n- **科学性**：该问题在计算机体系结构领域有坚实的基础，特别是关于HTM等并发控制机制的性能建模。使用泊松过程对冲突进行建模以及指数退避的概念是该领域标准的、成熟的技术。\n- **适定性**：问题是适定的。假设被清晰陈述，允许推导出唯一的预期成功时间解析表达式。数值部分拥有产生特定数值答案所需的所有数据。\n- **客观性**：问题以精确、客观的语言陈述。所有术语都有数学定义。\n- **无缺陷**：问题不违反任何无效性标准。它不是科学上不合理的、不可形式化的、不完整的、不切实际的、不适定的、伪深刻的或超出科学可验证范围的。这些假设是对现实的简化，但它们被明确提供以创建一个自洽的、可解的数学模型，这在性能分析中是标准做法。\n\n**步骤3：结论与行动**\n\n问题是**有效的**。我将进行详细解答。\n\n### 解答\n\n预期成功时间 $E[T]$ 是每条可能执行路径所用时间与该路径发生概率之乘积的总和。\n\n**1) 有界重试策略**\n\n对于此策略，任何给定尝试的成功概率为 $P_s = \\exp(-c)$，失败（中止）概率为 $P_f = 1 - P_s = 1 - \\exp(-c)$。尝试是连续进行的，因此没有等待时间。\n\n执行可以通过以下两种方式之一终止：\n- **在第 $k$ 次尝试时成功（其中 $1 \\le k \\le r$）**：这需要 $k-1$ 次失败，然后一次成功。此路径的概率为 $P_f^{k-1} P_s$。所用时间为 $(k-1)$ 次失败尝试（每次成本为 $t_s+h$）加上一次成功尝试（成本为 $t_s$）。总时间：$(k-1)(t_s+h) + t_s$。\n- **$r$ 次失败后回退**：如果所有 $r$ 次尝试都失败，则会发生这种情况。概率为 $P_f^r$。所用时间为 $r$ 次失败尝试加上回退时间 $t_f$。总时间：$r(t_s+h) + t_f$。\n\n预期时间 $E[T]$ 是所有这些互斥路径的总和：\n$$E[T] = \\sum_{k=1}^{r} \\left[ ((k-1)(t_s+h) + t_s) P_f^{k-1} P_s \\right] + (r(t_s+h) + t_f) P_f^r$$\n这个表达式是一个有效的解析结果。但是，可以推导出更紧凑的形式。设 $E_i$ 为在 $i-1$ 次尝试已经失败的情况下，剩余的预期时间。我们想求 $E[T] = E_1$。\n对于尝试 $i \\le r$，它以概率 $P_s$ 成功，耗时 $t_s$；或者以概率 $P_f$ 失败，耗时 $t_s+h$，然后我们进行第 $i+1$ 次尝试。对于最终的回退，我们可以定义 $E_{r+1} = t_f$。\n递推关系为：\n$$E_i = t_s P_s + (t_s+h + E_{i+1})P_f \\quad \\text{对于 } 1 \\leq i \\leq r$$\n$E_i = t_s(1-P_f) + (t_s+h)P_f + E_{i+1}P_f = t_s + hP_f + E_{i+1}P_f$。\n设 $C = t_s + hP_f$。递推关系为 $E_i = C + P_f E_{i+1}$。从 $i=1$ 开始展开：\n$E_1 = C + P_f E_2 = C + P_f(C + P_f E_3) = C(1+P_f) + P_f^2 E_3 = \\dots$\n$E_1 = C \\sum_{j=0}^{r-1} P_f^j + P_f^r E_{r+1} = C \\left(\\frac{1-P_f^r}{1-P_f}\\right) + t_f P_f^r$。\n代入 $C=t_s+hP_f$ 和 $1-P_f=P_s$，并使用 $P_f=1-\\exp(-c)$：\n$$E[T] = (t_s + h(1-\\exp(-c))) \\frac{1 - (1-\\exp(-c))^r}{\\exp(-c)} + t_f (1-\\exp(-c))^r$$\n这是所要求的解析表达式。\n\n**2) 指数退避策略**\n\n对于此策略，第 $k$ 次尝试（对于 $1 \\le k \\le R_b$）的参数为：\n- 等待时间：$w_k = d_0 \\alpha^{k-1}$\n- 成功概率：$P_{s,k} = \\exp(-c/\\alpha^{k-1})$\n- 失败概率：$P_{f,k} = 1 - P_{s,k}$\n第 $k$ 次尝试成功的成本是 $w_k+t_s$。第 $k$ 次尝试失败的成本是 $w_k+t_s+h$。\n\n我们对所有可能的路径求和：\n- **在第 $k$ 次尝试时成功（$1 \\le k \\le R_b$）**：这要求第 $1, \\dots, k-1$ 次尝试都失败。\n    - 概率：$P(\\text{在 k 次成功}) = \\left(\\prod_{j=1}^{k-1} P_{f,j}\\right) P_{s,k}$。\n    - 时间：总时间是 $k-1$ 次失败尝试和一次成功尝试的成本之和：$T_k = \\sum_{j=1}^{k-1} (w_j+t_s+h) + (w_k+t_s)$。\n- **$R_b$ 次失败后回退**：\n    - 概率：$P(\\text{回退}) = \\prod_{j=1}^{R_b} P_{f,j}$。\n    - 时间：总时间是 $R_b$ 次失败尝试的成本加上回退时间：$T_{fall} = \\sum_{j=1}^{R_b} (w_j+t_s+h) + t_f$。\n\n预期时间 $E[T]$ 是这些路径上（时间 $\\times$ 概率）的总和：\n$$E[T] = \\sum_{k=1}^{R_b} \\left[ \\left( \\sum_{j=1}^{k-1}(w_j+t_s+h) + w_k+t_s \\right) P_{s,k} \\prod_{j=1}^{k-1} P_{f,j} \\right] + \\left( \\left( \\sum_{j=1}^{R_b}(w_j+t_s+h) \\right) + t_f \\right) \\prod_{j=1}^{R_b}P_{f,j}$$\n其中空乘积为 $1$，空和为 $0$。这是所要求的解析表达式。\n\n**3) 数值评估**\n\n给定的参数为：$t_s=20$，$h=5$，$t_f=120$，$c=2$，$d_0=10$，$\\alpha=2$，$R_b=3$。所有时间单位均为微秒。\n\n**有界重试最优重试限制 $r^*$**\n$E[T](r)$ 的表达式形式为 $E[T](r) = A + B \\cdot p^r$，其中 $p=P_f=1-\\exp(-c)$。\n$E[T](r) = \\frac{t_s+hP_f}{P_s} (1-P_f^r) + t_f P_f^r = \\frac{t_s+hP_f}{P_s} + \\left( t_f - \\frac{t_s+hP_f}{P_s} \\right) P_f^r$。\n让我们评估 $P_f^r$ 的系数：\n当 $c=2$ 时，$P_s = \\exp(-2)$ 且 $P_f = 1-\\exp(-2)$。\n$$ \\frac{t_s+hP_f}{P_s} = \\frac{20+5(1-\\exp(-2))}{\\exp(-2)} = \\frac{25-5\\exp(-2)}{\\exp(-2)} = 25\\exp(2)-5 $$\n$t_f - \\frac{t_s+hP_f}{P_s} = 120 - (25\\exp(2)-5) = 125 - 25\\exp(2)$。\n由于 $\\exp(2) \\approx 7.389$，我们有 $125 - 25(7.389) = 125 - 184.725 = -59.725  0$。\n所以，$E[T](r)$ 的形式为 $C_1 - C_2 \\cdot P_f^r$，其中 $C_1, C_2 > 0$ 且 $0  P_f  1$。\n随着 $r$ 的增加，$P_f^r$ 减小，因此 $-C_2 P_f^r$ 增大。因此，$E[T](r)$ 是 $r$ 的一个严格递增函数。问题要求一个最优整数重试限制，我们理解为 $r \\ge 1$。因此，在 $r$ 的最小可能值处达到最小预期时间，即 $r^*=1$。\n\n**评估 $E[T]_{\\text{bounded at }r^*=1}$**\n使用 $r=1$ 的 $E[T](r)$ 公式：\n$E[T](1) = (t_s+hP_f) \\frac{1-P_f}{P_s} + t_f P_f = (t_s+hP_f) \\frac{P_s}{P_s} + t_f P_f = t_s + hP_f + t_f P_f = t_s + (h+t_f)P_f$。\n$E[T](1) = 20 + (5+120)(1-\\exp(-2)) = 20 + 125(1-\\exp(-2))$。\n$E[T](1) = 145 - 125\\exp(-2) \\approx 145 - 125(0.135335) \\approx 145 - 16.9169 = 128.0831 \\mu s$。\n四舍五入到4位有效数字，$E[T]_{\\text{有界于 }r^*=1} \\approx 128.1 \\mu s$。\n\n**评估 $E[T]_{\\text{backoff at }R_b=3}$**\n我们计算每次尝试（$k=1, 2, 3$）的参数：\n- 尝试 1：$w_1 = 10(2^0)=10$。$P_{s,1}=\\exp(-2)$。$P_{f,1}=1-\\exp(-2)$。成功时间为 $w_1+t_s=30$。中止时间为 $w_1+t_s+h=35$。\n- 尝试 2：$w_2 = 10(2^1)=20$。$P_{s,2}=\\exp(-2/2)=\\exp(-1)$。$P_{f,2}=1-\\exp(-1)$。成功时间为 $w_2+t_s=40$。中止时间为 $w_2+t_s+h=45$。\n- 尝试 3：$w_3 = 10(2^2)=40$。$P_{s,3}=\\exp(-2/4)=\\exp(-0.5)$。$P_{f,3}=1-\\exp(-0.5)$。成功时间为 $w_3+t_s=60$。中止时间为 $w_3+t_s+h=65$。\n\n现在我们对每条可能路径的（时间 $\\times$ 概率）求和：\n- 在 $k=1$ 时成功：\n    - 时间 = $30$。概率 = $P_{s,1} = \\exp(-2)$。\n- 在 $k=1$ 失败，在 $k=2$ 成功：\n    - 时间 = $35+40=75$。概率 = $P_{f,1}P_{s,2} = (1-\\exp(-2))\\exp(-1)$。\n- 在 $k=1,2$ 失败，在 $k=3$ 成功：\n    - 时间 = $35+45+60=140$。概率 = $P_{f,1}P_{f,2}P_{s,3} = (1-\\exp(-2))(1-\\exp(-1))\\exp(-0.5)$。\n- 在 $k=1,2,3$ 失败，回退：\n    - 时间 = $35+45+65+t_f = 145+120=265$。概率 = $P_{f,1}P_{f,2}P_{f,3} = (1-\\exp(-2))(1-\\exp(-1))(1-\\exp(-0.5))$。\n\n$E[T]_{\\text{退避}} = 30\\exp(-2) + 75(1-\\exp(-2))\\exp(-1) + 140(1-\\exp(-2))(1-\\exp(-1))\\exp(-0.5) + 265(1-\\exp(-2))(1-\\exp(-1))(1-\\exp(-0.5))$\n$E[T]_{\\text{退避}} \\approx 30(0.135335) + 75(0.864665)(0.367879) + 140(0.864665)(0.632121)(0.606531) + 265(0.864665)(0.632121)(0.393469)$\n$E[T]_{\\text{退避}} \\approx 4.060058 + 23.834054 + 46.409943 + 57.001506 \\approx 131.30556 \\mu s$。\n四舍五入到4位有效数字，$E[T]_{\\text{退避于 }R_b=3} \\approx 131.3 \\mu s$。\n\n最终结果是 $r^*=1$，$E[T]_{\\text{有界于 }r^*=1} \\approx 128.1 \\mu s$，以及 $E[T]_{\\text{退避于 }R_b=3} \\approx 131.3 \\mu s$。",
            "answer": "$$ \\boxed{ \\begin{pmatrix} 1  128.1  131.3 \\end{pmatrix} } $$"
        }
    ]
}