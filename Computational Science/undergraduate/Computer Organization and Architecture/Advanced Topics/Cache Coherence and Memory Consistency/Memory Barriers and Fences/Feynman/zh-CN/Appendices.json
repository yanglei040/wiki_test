{
    "hands_on_practices": [
        {
            "introduction": "同步的实现需要线程间的“协作”。仅有写入者执行`release`操作是不够的，读取者必须执行相应的`acquire`操作来建立“同步于”（synchronizes-with）关系。本练习将通过一个经典案例，帮助你诊断由于读取者未能履行其“协议”责任而导致的数据竞争问题，从而深刻理解为何`release`与`acquire`必须成对出现。",
            "id": "3656251",
            "problem": "考虑两个线程，一个写入线程和一个读取线程，它们运行在一个弱序指令集架构（ISA）上。存在两个共享变量：一个初始化为 $0$ 的普通整数 $data$，以及一个初始化为 $0$ 的原子标志 $ready$。写入线程按程序顺序执行：首先是 $data \\leftarrow 42$，然后是对 $ready$ 进行带 release 语义的原子存储，将 $ready$ 设置为 $1$。读取线程使用 relaxed 加载对 $ready$ 进行自旋，直到观察到 $ready = 1$，然后将 $data$ 读入本地寄存器 $r$。具体来说：\n- 写入线程：$data \\leftarrow 42$; `atomic_store_release(ready, 1)`。\n- 读取线程：`while (atomic_load_relaxed(ready) == 0) { }` ; $r \\leftarrow data$。\n\n假设缓存一致性为每个内存位置提供单一的全序，但其本身并不对不同位置的操作进行排序，并且语言和硬件允许在所选原子语义的约束下进行编译器和硬件重排序。在这些假设下，根据程序顺序、缓存一致性、release/acquire 同步以及先行发生关系（happens-before）的核心定义进行推理，并回答以下问题：\n\n哪个选项最能描述在读取线程看到 $ready = 1$ 后，$r$ 是否可能被观察为 $0$，并指出了一个依赖于适当内存屏障或栅栏的正确的最小化修复方案？\n\nA. 不会。由于缓存一致性，观察到 $ready = 1$ 保证了 $data$ 是最新的；不需要栅栏。\n\nB. 会。写入者带 release 语义的存储仅相对于读取者匹配的 acquire 加载对其之前的写入进行排序；一个 relaxed 加载不进行同步，因此在弱内存模型上 $r$ 可能为 $0$。一个最小化的修复方案是将自旋加载变为 acquire 加载，或者在读取 $ready$ 和读取 $data$ 之间插入一个 acquire 栅栏。\n\nC. 会。但修复方案是将 $data$ 声明为原子类型，并以 relaxed 语义读取它；不需要对 $ready$ 进行排序。\n\nD. 不会。对 $ready$ 的 release 存储禁止任何后续的读取者重排序其后续的加载，因此当前写法是安全的。\n\nE. 会。但最小化的修复方案是让写入者对 $ready$ 使用顺序一致性存储；读取者无需更改。",
            "solution": "首先应验证用户提供的问题陈述的科学性和逻辑完整性。\n\n### 第一步：提取已知条件\n- **系统**：两个线程，一个写入者和一个读取者，运行在弱序指令集架构（ISA）上。\n- **共享变量**：\n    - 普通整数 $data$，初始化为 $0$。\n    - 原子标志 $ready$，初始化为 $0$。\n- **写入线程逻辑**：\n    1. $data \\leftarrow 42$\n    2. `atomic_store_release(ready, 1)`\n- **读取线程逻辑**：\n    1. `while (atomic_load_relaxed(ready) == 0) { }`\n    2. $r \\leftarrow data$ (其中 $r$ 是一个本地寄存器)。\n- **假设**：\n    1. 缓存一致性为每个内存位置提供单一的全序。\n    2. 缓存一致性不对不同内存位置上的操作进行排序。\n    3. 允许编译器和硬件重排序，仅受指定的原子语义约束。\n- **问题**：在读取线程观察到 $ready = 1$ 之后，寄存器 $r$ 是否可能被观察到持有值 $0$，以及正确的最小化修复方案是什么？\n\n### 第二步：使用已知条件进行验证\n问题陈述描述了一个经典的生产者-消费者或标志同步模式。所使用的概念——弱序架构、缓存一致性、程序顺序、先行发生（happens-before）语义，以及具有不同内存顺序（`release`、`relaxed`）的原子操作——都是计算机组成与体系结构以及像 C++ 和 Rust 这类语言的内存模型中的基础且明确定义的主题。\n\n- **科学上成立**：该问题坚实地基于内存一致性模型的既定原则。该场景是一个标准的教科书示例，用于说明需要适当的内存同步。它在科学上是合理的。\n- **问题定义明确**：问题定义清晰，包含了所有必要的初始条件、线程行为和底层架构假设。它提出的问题是具体的，并且在所提供的框架下有确定的答案。\n- **客观性**：语言精确、技术性强，没有含糊不清或主观的陈述。\n\n问题陈述没有缺陷。这是一个有效的、结构良好的计算机体系结构问题。\n\n### 第三步：结论与行动\n问题是**有效的**。将推导完整解决方案。\n\n### 解决方案的推导\n\n此问题的核心在于“先行发生”（happens-before）关系，它定义了不同线程中操作之间正式的内存排序保证。\n\n1.  **程序顺序与 Release 语义（写入者）**：写入线程按程序顺序执行其操作。\n    - `W1`: $data \\leftarrow 42$\n    - `W2`: `atomic_store_release(ready, 1)`\n    操作 `W2` 的 `release` 语义保证了同一线程中所有之前的内存写入（在此例中为 `W1`）对与此操作同步的其他线程可见。一个 `release` 操作充当一个屏障，防止 `W1` 被重排序到 `W2` *之后*。因此，从写入者的角度来看，内存系统被指示将 $data$ 的新值对其他核心可见的时间不晚于 $ready$ 的新值。\n\n2.  **Relaxed 语义与重排序（读取者）**：读取线程执行：\n    - `R1`：一个 `atomic_load_relaxed(ready)` 的循环，直到读取到 $1$。\n    - `R2`：$r \\leftarrow data$\n    对 $ready$ 的加载使用 `relaxed` 内存顺序。`relaxed` 原子操作只保证原子性（加载不会看到“撕裂”的值），但它们**不提供任何同步或排序保证**。具体来说，一个 `relaxed` 加载不与一个 `release` 存储“同步于”（synchronizes-with）。\n\n3.  **同步失败**：为了保证对 $data$ 的写入在从 $data$ 读取之前可见，必须在 `W1` 和 `R2` 之间建立一个“先行发生”（happens-before）关系。在 release-acquire 模型中，这是通过 `release` 存储（`W2`）与一个 `acquire` 加载“同步于”来实现的。由于读取者执行的是一个 `relaxed` 加载（`R1`），这种同步没有发生。\n\n4.  **在弱序 ISA 上的后果**：没有同步点，系统可以自由地重排序操作。\n    - 对 $data$ 的写入和对 $ready$ 的写入发生在两个不同的内存位置。缓存一致性保证了对 $ready$ 的所有写入有一个全序，对 $data$ 的所有写入有另一个独立的全序，但它不保证 $data$ 相对于 $ready$ 的可见性顺序。\n    - 写入者对 $ready$ 的存储有可能在对 $data$ 的存储变得可见之前，就对读取者的核心可见。读取者的核心可能看到 $ready = 1$ 并退出循环，但其后续对 $data$ 的读取可能由其本地缓存提供服务，而缓存中仍持有旧值 $0$。\n    - 或者，读取者的处理器本身可能会重排序操作，在循环（`R1`）明确终止之前，推测性地执行从 $data$ 的加载（`R2`）。在没有适当内存栅栏/屏障的情况下，弱序处理器允许这种不受数据依赖约束的重排序。\n\n因此，读取线程完全有可能在观察到 $ready = 1$ 之后，从 $data$ 中读到初始值 $0$ 并存入 $r$。代码存在数据竞争。\n\n5.  **最小化修复方案**：为了修正这个数据竞争，必须在写入者对 $ready$ 的存储和读取者后续对 $data$ 的加载之间建立一个“同步于”（synchronizes-with）关系。写入者的 `release` 存储必须与读取者的一个 `acquire` 操作配对。有两种标准方法可以实现这一点：\n    a.  修改读取者对标志的加载：将 `atomic_load_relaxed(ready)` 更改为 `atomic_load_acquire(ready)`。这是最直接的修复。`acquire` 加载与 `release` 存储同步，从而建立先行发生关系。`acquire` 语义作为一个屏障，确保写入者的前序写入 $data$ 在读取者线程中任何后续内存操作（如读取 $data$）执行之前都是可见的。\n    b.  插入一个 `acquire` 栅栏：在循环中保留 `relaxed` 加载，但在循环之后、读取 $data$ 之前插入一个 `acquire` 栅栏。\n        `while (atomic_load_relaxed(ready) == 0) { }`\n        `atomic_thread_fence(memory_order_acquire);`\n        `$r \\leftarrow data$;`\n        `acquire` 栅栏与之前的 `release` 存储同步，提供了与 `acquire` 加载相同的保证。\n\n两种修复方案都被认为是最小化的。\n\n### 逐项分析选项\n\n**A. 不会。由于缓存一致性，观察到 $ready = 1$ 保证了 $data$ 是最新的；不需要栅栏。**\n- **分析**：这个陈述是根本错误的。如问题假设和上述推导所述，缓存一致性为单个内存位置提供一致性，但并不强制不同位置（$data$ 和 $ready$）之间的排序。这误解了缓存一致性（coherence）和内存一致性（consistency）之间的区别。\n- **结论**：不正确。\n\n**B. 会。写入者带 release 语义的存储仅相对于读取者匹配的 acquire 加载对其之前的写入进行排序；一个 relaxed 加载不进行同步，因此在弱内存模型上 $r$ 可能为 $0$。一个最小化的修复方案是将自旋加载变为 acquire 加载，或者在读取 $ready$ 和读取 $data$ 之间插入一个 acquire 栅栏。**\n- **分析**：这个陈述正确地指出 $r$ 可能为 $0$。它准确地解释了原因：一个 `release` 存储需要一个匹配的 `acquire` 操作来同步，而一个 `relaxed` 加载不提供此功能。然后它正确地指出了两种标准的最小化修复方案：将加载更改为 `acquire` 或插入一个 `acquire` 栅栏。这个分析与现代内存模型的原理完全一致。\n- **结论**：正确。\n\n**C. 会。但修复方案是将 $data$ 声明为原子类型，并以 relaxed 语义读取它；不需要对 $ready$ 进行排序。**\n- **分析**：这是不正确的。仅仅将 $data$ 设为原子类型并对其使用 `relaxed` 加载并不能解决排序问题。核心问题是线程之间缺少同步，而这正是 $ready$ 标志的目的。没有对 $ready$ 的排序，对 $data$ 的读取仍然可能相对于对 $ready$ 的读取被重排序或读到旧值。这个提议的修复方案未能建立必要的先行发生关系。\n- **结论**：不正确。\n\n**D. 不会。对 $ready$ 的 release 存储禁止任何后续的读取者重排序其后续的加载，因此当前写法是安全的。**\n- **分析**：这个陈述是不正确的。一个线程的 `release` 存储不会对一个没有执行相应 `acquire` 操作的无关读取线程施加排序约束。排序保证是以读取者参与同步协议为条件的。\n- **结论**：不正确。\n\n**E. 会。但最小化的修复方案是让写入者对 $ready$ 使用顺序一致性存储；读取者无需更改。**\n- **分析**：在写入者上使用顺序一致性存储（`atomic_store_seq_cst`）确实可以修复数据竞争，因为一个 `seq_cst` 操作会与另一个线程中读取该写入值的任何原子操作同步。然而，问题要求的是*最小化*修复方案。`release-acquire` 排序是专门为这种单向同步设计的，并且比顺序一致性限制更少（因此可能性能更高）。将写入者的 `release` 升级到 `seq_cst` 是一个比必要更强的更改。最小化的修复方案是在读取者端用一个匹配的 `acquire` 来完成现有的 `release` 操作，如选项 B 所述。\n- **结论**：不正确。",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "在理解了`release-acquire`配对的重要性之后，我们来主动地为一种常见的“消息传递”模式设计一个正确的解决方案。在这个场景中，一个线程准备好数据，然后设置一个标志位来通知另一个线程。本练习旨在让你动手实践，在弱序内存模型上正确地放置最小化的内存屏障，以确保数据在标志位被观察到之后是可见且一致的。",
            "id": "3656212",
            "problem": "考虑在不同中央处理器（CPU）上运行的两个线程之间的以下消息传递模式：\n\n- 共享状态：一个字节数组 $B[0 \\ldots N-1]$ 和一个标志 $R$；初始时，$B$ 的内容未指定，且 $R = 0$。\n- 写入线程 $T_w$ 按程序顺序执行：对于每个索引 $i$（$0 \\le i \\le N-1$），将 $0$ 写入 $B[i]$，然后将 $1$ 写入 $R$。\n- 读取线程 $T_r$ 执行：自旋直到读取到 $R = 1$，然后立即读取所有元素 $B[0 \\ldots N-1]$ 并依赖于每次读取的值都等于 $0$。\n\n假设在一个弱序多处理器上，该处理器具有按位置的缓存一致性，但对独立位置没有隐式的全局排序，并且以下情况为真：\n\n- 除非受同步约束，否则线程内的程序顺序不意味着对其他线程关于不同位置的可见性顺序。\n- 释放屏障（release fence）禁止将之前的内存访问重排序到屏障之后；获取屏障（acquire fence）禁止将之后的内存访问重排序到屏障之前。\n- 除非被排序阻止，否则对一个位置的写入可能会在对其他位置的更早写入之前对其他CPU变得可见。\n- 正确性准则为：一旦 $T_r$ 观察到 $R = 1$，对于所有 $i$（$0 \\le i \\le N-1$），$T_w$ 设置 $B[i] = 0$ 的所有写入必须对 $T_r$ 可见。\n\n您的任务是确保读取者在 $B$ 的任何元素仍然持有写入零之前的值时，永远不会观察到 $R = 1$。请选择屏障的最小化放置和强度，以在各种弱序但缓存一致的架构上建立必要的排序，从而保证正确性准则。“最小化”指在这些架构上足以强制写入者对 $B$ 的清零操作 happens-before（先于）读取者在看到 $R = 1$ 后对 $B$ 的后续读取操作的最小总排序强度和数量。\n\n哪个选项正确指定了最小化的屏障？\n\nA. 在 $T_w$ 中：在对 $B$ 清零和写入 $R \\leftarrow 1$ 之间放置一个释放屏障。在 $T_r$ 中：在读取到 $R = 1$ 之后、读取任何 $B$ 的元素之前，立即放置一个获取屏障。\n\nB. 在 $T_w$ 中：在对 $B$ 清零和写入 $R \\leftarrow 1$ 之间放置一个释放屏障。在 $T_r$ 中：不需要屏障；在观察到 $R = 1$ 后立即读取 $B$。\n\nC. 在 $T_w$ 中：不需要屏障；在对 $B$ 清零后写入 $R \\leftarrow 1$。在 $T_r$ 中：在读取到 $R = 1$ 之后、读取任何 $B$ 的元素之前，立即放置一个获取屏障。\n\nD. 在 $T_w$ 和 $T_r$ 的关键操作前后都放置一个完全顺序一致性屏障（同时具有获取和释放效应），即每个线程使用 $2$ 个完整屏障包围清零和标志操作。\n\nE. 仅在 $T_r$ 中通过从读取 $R$ 的值计算单个索引 $j$ 来引入数据依赖，然后首先读取 $B[j]$；任何地方都不需要屏障，其余对 $B$ 的读取按普通程序顺序进行。",
            "solution": "### 问题验证\n\n该问题是**有效的**。它描述了一个经典的并发编程场景——消息传递或标志同步，并要求在弱内存模型下使用内存屏障来保证正确性。问题陈述清晰，提供了所有必要的定义（线程行为、内存模型属性、屏障语义、正确性准则），并且基于计算机体系结构中的标准概念。\n\n### 解决方案的推导\n\n1.  **风险识别**：在弱序内存模型中，主要风险是内存操作的重排序。\n    *   **写入者风险**：写入者 $T_w$ 对标志 $R$ 的写入（`R = 1`）可能会被处理器重排序，从而在对数组 $B$ 的所有写入（`B[i] = 0`）对其他处理器可见*之前*，就先对读取者 $T_r$ 可见。\n    *   **读取者风险**：读取者 $T_r$ 对数组 $B$ 的读取可能会被处理器重排序（例如，通过推测执行），从而在确认 $R$ 的值为 $1$ *之前*就发生。\n    如果这两种风险中的任何一种发生，$T_r$ 都可能在看到 $R=1$ 后，从 $B$ 中读到旧的、未初始化的值，从而违反正确性准则。\n\n2.  **制定排序要求**：为了防止这些风险，我们需要建立一个“先行发生”（happens-before）关系，确保事件按逻辑顺序对所有相关线程可见。\n    *   在 $T_w$ 中，所有对 $B$ 的写入必须“先于”对 $R$ 的写入。\n    *   在 $T_r$ 中，对 $R$ 的读取（并观察到值 $1$）必须“先于”所有对 $B$ 的读取。\n    *   $T_w$ 对 $R$ 的写入和 $T_r$ 对 $R$ 的读取必须同步，以将这两个顺序链连接起来。\n\n3.  **应用同步原语（屏障）**：\n    *   **对于写入者 $T_w$**：我们需要一个屏障，防止在它*之前*的内存写入（对 $B$ 的写入）被重排序到它*之后*的内存写入（对 $R$ 的写入）之后。根据定义，**释放屏障（release fence）** 正好提供了这种保证。因此，$T_w$ 的正确序列是：清零 $B$ 数组 -> `release_fence` -> 写入 $R=1$。\n    *   **对于读取者 $T_r$**：我们需要一个屏障，防止在它*之后*的内存读取（对 $B$ 的读取）被重排序到它*之前*的内存读取（对 $R$ 的读取）之前。根据定义，**获取屏障（acquire fence）** 提供了这种保证。因此，$T_r$ 的正确序列是：自旋直到 $R=1$ -> `acquire_fence` -> 读取 $B$ 数组。\n\n4.  **评估“最小化”**：\n    *   这种“释放-获取”配对是为这种单向数据传递模式设计的标准、最小化同步机制。\n    *   只在一方使用屏障是不够的，因为另一方仍然可以进行破坏性的重排序。\n    *   使用更强的屏障（如完全顺序一致性屏障）是有效的，但不符合“最小化”的要求。\n    *   依赖数据依赖（选项 E）不是一个通用的解决方案，并且不能保证对整个数组的读取都有序。\n\n### 逐项分析\n\n**A. 在 $T_w$ 中：在对 $B$ 清零和写入 $R \\leftarrow 1$ 之间放置一个释放屏障。在 $T_r$ 中：在读取到 $R = 1$ 之后、读取任何 $B$ 的元素之前，立即放置一个获取屏障。**\n- **分析**：这与上述推导完全吻合。$T_w$ 中的释放屏障确保了数据在标志位之前被“发布”。$T_r$ 中的获取屏障确保了在确认标志位之后才去“接收”数据。这种配对正确地建立了必要的“先行发生”关系，并且是解决此类问题的标准最小化方案。\n- **结论**：正确。\n\n**B. 在 $T_w$ 中：在对 $B$ 清零和写入 $R \\leftarrow 1$ 之间放置一个释放屏障。在 $T_r$ 中：不需要屏障；在观察到 $R = 1$ 后立即读取 $B$。**\n- **分析**：不正确。缺少了 $T_r$ 中的获取屏障，读取者的处理器可能会重排序操作，在确认 $R=1$ 之前就推测性地读取 $B$ 的内容，从而读到旧数据。\n- **结论**：不正确。\n\n**C. 在 $T_w$ 中：不需要屏障；在对 $B$ 清零后写入 $R \\leftarrow 1$。在 $T_r$ 中：在读取到 $R = 1$ 之后、读取任何 $B$ 的元素之前，立即放置一个获取屏障。**\n- **分析**：不正确。缺少了 $T_w$ 中的释放屏障，写入者的处理器可能会重排序操作，让 $R=1$ 的写入在对 $B$ 的写入对其他处理器可见之前就先可见了。\n- **结论**：不正确。\n\n**D. 在 $T_w$ 和 $T_r$ 的关键操作前后都放置一个完全顺序一致性屏障（同时具有获取和释放效应），即每个线程使用 $2$ 个完整屏障包围清零和标志操作。**\n- **分析**：这种方法虽然能保证正确性，但它不是最小化的。它使用了比所需强度更强的屏障，并且数量也过多。问题要求的是“最小化”的放置和强度。\n- **结论**：不正确。\n\n**E. 仅在 $T_r$ 中通过从读取 $R$ 的值计算单个索引 $j$ 来引入数据依赖，然后首先读取 $B[j]$；任何地方都不需要屏障，其余对 $B$ 的读取按普通程序顺序进行。**\n- **分析**：这依赖于“地址依赖排序”，这种保证并非在所有弱序架构上都存在。更重要的是，即使它能排序对 $B[j]$ 的读取，它也不能保证对数组 $B$ 中其他元素的读取的顺序。因此，这不是一个完整或通用的解决方案。\n- **结论**：不正确。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "除了使用显式的内存屏障，现代编程语言和架构还提供了将内存排序语义与原子操作本身相结合的更高效、更符合语言习惯的工具。本练习将带你评估一系列用于保障单生产者单消费者（SPSC）队列安全的同步策略，包括独立的栅栏（fences）和集成了顺序保证的原子操作。通过此练习，你将学会比较不同同步机制的有效性，并为特定场景选择最合适的解决方案。",
            "id": "3656195",
            "problem": "考虑一个在共享内存、缓存一致性多处理器环境下的单生产者、单消费者 (SPSC) 消息队列。假设队列槽是一个单一指针位置 $Q$（初始为 $0$），地址为 $p$ 的消息对象包含三个字段 $A$、$B$ 和 $C$（每个字段初始为 $0$）。生产者按程序顺序执行：在地址 $p$ 分配一个消息，将新的非零值 $v_A$、$v_B$、$v_C$ 写入 $A$、$B$、$C$，然后通过将 $p$ 写入 $Q$ 来发布它（入队）。消费者按程序顺序执行：将 $Q$ 读入 $p$（出队），如果 $p \\neq 0$，则从 $p$ 读取 $A$、$B$ 和 $C$。\n\n假设关于硬件内存系统有以下基本事实和定义：\n\n- 系统提供缓存一致性，并对每个位置的写操作具有全序关系，因此对于每个地址 $x$，所有中央处理器 (CPU) 观察到对 $x$ 的写入顺序是相同的，但内存模型在不同地址之间是弱序的。\n- 线程内的程序顺序本身并不能强制其他线程在不同地址间观察到相同的顺序；对不同地址的加载和存储操作可能会被观察到乱序执行，除非受到内存屏障 (fence) 的约束。\n- 释放屏障 (release fence) 保证在程序顺序中位于屏障之前的所有内存写入，在位于屏障之后的任何写入变得可见之前，对所有 CPU 可见。\n- 获取屏障 (acquire fence) 保证在程序顺序中位于屏障之后的任何内存读取，都不会被观察到在位于屏障之前的任何读取生效之前生效；特别是，它阻止后续的读取被重排到屏障之前，并确保它们能看到通过匹配的同步操作而先行发生于屏障的效果。\n- 全局屏障 (full fence) 提供获取和释放两种效果，防止读和写在任一方向上跨越屏障进行重排。\n- 对 $Q$ 的释放存储 (store-release) 和从 $Q$ 的获取加载 (load-acquire) 在 $Q$ 上建立了一个同步于 (synchronizes-with) 的边；结合程序顺序，这产生了从生产者的释放前操作到消费者的获取后操作的先行发生 (happens-before) 关系。如果没有这样的一对操作（或等效的显式屏障），在生产者的对 $A$、$B$、$C$ 的写入和消费者的对 $A$、$B$、$C$ 的读取之间，就不存在线程间的先行发生关系。\n\n假设入队和出队操作在其他方面是无锁的，并且除非下面明确说明，否则不添加任何隐式屏障。您的任务是确保一旦消费者出队一个刚刚发布的指针 $p$，它就永远不会随后从该 $p$ 对应的 $A$、$B$ 或 $C$ 中读到默认值 $0$。\n\n在弱序但缓存一致的架构上，以下哪些策略足以确保消费者在成功出队 $p$ 后，永远不会立即在 $A$、$B$ 或 $C$ 中观察到默认值？选择所有适用的选项。\n\nA. 生产者：写入 $A \\leftarrow v_A$，$B \\leftarrow v_B$，$C \\leftarrow v_C$，然后发出一个存储-存储屏障，然后写入 $Q \\leftarrow p$。消费者：读取 $p \\leftarrow Q$，然后读取 $A$、$B$、$C$；消费者侧无屏障。\n\nB. 生产者：写入 $A \\leftarrow v_A$，$B \\leftarrow v_B$，$C \\leftarrow v_C$，然后发出一个释放屏障，然后写入 $Q \\leftarrow p$。消费者：读取 $p \\leftarrow Q$，然后发出一个获取屏障，然后读取 $A$、$B$、$C$。\n\nC. 生产者：写入 $A \\leftarrow v_A$，$B \\leftarrow v_B$，$C \\leftarrow v_C$，然后发出一个全局屏障，然后写入 $Q \\leftarrow p$。消费者：读取 $p \\leftarrow Q$，然后发出一个获取屏障，然后读取 $A$、$B$、$C$。\n\nD. 生产者：写入 $A \\leftarrow v_A$，$B \\leftarrow v_B$，$C \\leftarrow v_C$，然后写入 $Q \\leftarrow p$。消费者：读取 $p \\leftarrow Q$，然后发出一个全局屏障，然后读取 $A$、$B$、$C$。\n\nE. 入队操作对 $Q \\leftarrow p$ 执行释放存储（生产者中无额外显式屏障），而出队操作对 $p \\leftarrow Q$ 执行获取加载（消费者中无额外显式屏障）。生产者仍然在入队前写入 $A$、$B$、$C$；消费者在出队后读取 $A$、$B$、$C$。\n\nF. 生产者：发出一个全局屏障，然后写入 $A \\leftarrow v_A$，$B \\leftarrow v_B$，$C \\leftarrow v_C$，然后写入 $Q \\leftarrow p$。消费者：读取 $p \\leftarrow Q$，然后发出一个获取屏障，然后读取 $A$、$B$、$C$。",
            "solution": "### 问题验证\n\n该问题陈述是**有效的**。它准确地描述了一个经典的“安全发布”并发模式，并提供了清晰、科学合理的内存模型定义和公理，要求根据这些规则评估不同的同步策略。\n\n### 解题推导\n\n问题的核心是确保生产者对消息字段（$A, B, C$）的写入，“先于”（happens-before）消费者对这些字段的读取。在弱内存模型中，这需要一个显式的同步操作。\n\n根据问题中给出的定义，这种同步可以通过两种主要方式实现：\n1.  **显式屏障**：生产者在写入数据（$A, B, C$）和写入标志指针（$Q$）之间放置一个**释放屏障**。消费者在读取标志指针（$Q$）和读取数据（$A, B, C$）之间放置一个**获取屏障**。\n2.  **集成原子操作**：生产者使用**释放存储（store-release）**来写入标志指针 $Q$。消费者使用**获取加载（load-acquire）**来读取标志指针 $Q$。\n\n这两种方式都能在生产者对 $Q$ 的存储和消费者对 $Q$ 的加载之间建立一个“同步于”（synchronizes-with）关系，从而保证所需的“先于”关系。现在我们逐一评估每个选项。\n\n### 逐项分析\n\n**A. 生产者：写入 $A \\leftarrow v_A, B \\leftarrow v_B, C \\leftarrow v_C$，然后发出一个存储-存储屏障，然后写入 $Q \\leftarrow p$。消费者：读取 $p \\leftarrow Q$，然后读取 $A, B, C$；消费者侧无屏障。**\n- **分析**：一个`store-store`屏障通常只在单个处理器内部强制执行存储顺序，它不提供跨处理器的`release`可见性保证。此外，消费者方面完全没有屏障，其处理器可以自由地重排序读取操作。此策略在两端都存在缺陷。\n- **结论：不正确。**\n\n**B. 生产者：写入 $A \\leftarrow v_A, B \\leftarrow v_B, C \\leftarrow v_C$，然后发出一个释放屏障，然后写入 $Q \\leftarrow p$。消费者：读取 $p \\leftarrow Q$，然后发出一个获取屏障，然后读取 $A, B, C$。**\n- **分析**：这是使用显式屏障的经典正确解决方案。生产者的释放屏障确保了对 $A, B, C$ 的写入在对 $Q$ 的写入之前对所有其他CPU可见。消费者的获取屏障确保了对 $A, B, C$ 的读取在从 $Q$ 成功读取之后才发生。这对屏障正确地建立了同步。\n- **结论：正确。**\n\n**C. 生产者：写入 $A \\leftarrow v_A, B \\leftarrow v_B, C \\leftarrow v_C$，然后发出一个全局屏障，然后写入 $Q \\leftarrow p$。消费者：读取 $p \\leftarrow Q$，然后发出一个获取屏障，然后读取 $A, B, C$。**\n- **分析**：全局屏障（Full Fence）同时具有获取和释放效应。因为它包含了释放屏障的功能，所以它能正确地满足生产者方面的排序要求。虽然比单纯的释放屏障要强（可能性能更低），但它是充分且正确的。消费者方面也正确地使用了获取屏障。因此，该策略是正确的。\n- **结论：正确。**\n\n**D. 生产者：写入 $A \\leftarrow v_A, B \\leftarrow v_B, C \\leftarrow v_C$，然后写入 $Q \\leftarrow p$。消费者：读取 $p \\leftarrow Q$，然后发出一个全局屏障，然后读取 $A, B, C$。**\n- **分析**：生产者方面没有屏障，这意味着对 $Q$ 的写入可能在对 $A, B, C$ 的写入完成之前就对消费者可见。同步需要生产者和消费者共同参与；仅消费者一方的屏障无法弥补生产者一方的缺失。\n- **结论：不正确。**\n\n**E. 入队操作对 $Q \\leftarrow p$ 执行释放存储（生产者中无额外显式屏障），而出队操作对 $p \\leftarrow Q$ 执行获取加载（消费者中无额外显式屏障）。**\n- **分析**：这是使用集成了内存排序语义的原子操作的经典正确解决方案。`store-release`操作等同于`release fence`后跟一个普通存储，而`load-acquire`操作等同于一个普通加载后跟一个`acquire fence`。根据问题定义，这对操作直接建立了`synchronizes-with`关系，从而保证了正确性。这通常是比使用显式屏障更高效的方法。\n- **结论：正确。**\n\n**F. 生产者：发出一个全局屏障，然后写入 $A \\leftarrow v_A, B \\leftarrow v_B, C \\leftarrow v_C$，然后写入 $Q \\leftarrow p$。消费者：读取 $p \\leftarrow Q$，然后发出一个获取屏障，然后读取 $A, B, C$。**\n- **分析**：屏障的位置是错误的。生产者在写入消息字段*之前*放置了屏障。这个屏障无法对后续的对 $A, B, C$ 的写入和对 $Q$ 的写入之间的顺序施加任何约束。处理器仍然可以自由地将对 $Q$ 的写入重排序到对 $A, B, C$ 的写入之前。\n- **结论：不正确。**",
            "answer": "$$\\boxed{BCE}$$"
        }
    ]
}