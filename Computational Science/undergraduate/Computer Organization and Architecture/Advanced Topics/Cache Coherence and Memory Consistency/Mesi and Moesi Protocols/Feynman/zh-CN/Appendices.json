{
    "hands_on_practices": [
        {
            "introduction": "理论是重要的，但没有什么比通过计算来理解一个概念的实际优势更有效了。这个练习将带你深入探讨MOESI协议相比于MESI协议的核心性能优势。通过一个基于概率的场景，你将量化当多个核心读取一个被修改过的缓存行时，由于引入了“拥有”（Owned）状态而节省的总延迟，从而清晰地看到MOESI协议在减少内存总线流量和提高系统响应速度方面的价值。",
            "id": "3658472",
            "problem": "考虑一个具有 $N=8$ 个核心的对称多处理器，该处理器使用基于监听的缓存一致性协议。有两种可用的一致性协议：修改、独占、共享、无效 (MESI) 和修改、拥有者、独占、共享、无效 (MOESI)。在修改、独占、共享、无效 (MESI) 协议中，当一个核心对另一个核心中当前处于“修改”状态的缓存行执行读取操作时，持有修改后数据的核心必须首先将该行写回内存，然后请求者才能获取数据，因此读取操作实际上是由主内存服务的。在修改、拥有者、独占、共享、无效 (MOESI) 协议中，“拥有者”状态允许持有修改后缓存行的缓存直接向请求者提供数据，而无需立即写回内存。\n\n假设有以下延迟：\n- 缓存到缓存的传输延迟 $t_{cc} = 20\\,\\text{ns}$。\n- 主内存（动态随机存取存储器）延迟 $t_{\\text{dram}} = 80\\,\\text{ns}$。\n\n假设核心发出了 $k=1000$ 次读取请求，并且每个请求都针对一个当前恰好在 $N$ 个缓存之一中处于“修改”状态的缓存行。将请求核心和拥有核心（持有“修改”状态缓存行的核心）的选择建模为在 $N$ 个核心上的独立且均匀的随机选择。在这些假设下，从第一性原理出发，推导由于拥有者服务传输，修改、拥有者、独占、共享、无效 (MOESI) 协议相对于修改、独占、共享、无效 (MESI) 协议所实现的总预期延迟节省，然后使用上述参数值对表达式进行数值计算。以纳秒为单位表示最终的延迟节省，并将您的答案四舍五入到四位有效数字。",
            "solution": "我们的目标是计算在 $k$ 次读取请求中，MOESI 协议相对于 MESI 协议的总预期延迟节省。总节省是单次请求的预期节省与请求次数 $k$ 的乘积。\n\n首先，我们分析单次读取请求的延迟。设 $C_r$ 为发出读取请求的核心，$C_o$ 为持有“修改”状态缓存行的核心。根据题意，$C_r$ 和 $C_o$ 是从 $N$ 个核心中独立且均匀随机选择的。因此，存在两种情况：\n1.  请求核心与持有核心是同一个，即 $C_r = C_o$。\n2.  请求核心与持有核心不同，即 $C_r \\neq C_o$。\n\n这两个事件的概率可以计算如下。总共有 $N \\times N = N^2$ 种同样可能的 $(C_r, C_o)$ 组合。\n$C_r = C_o$ 的情况有 $N$ 种（即 $(C_1, C_1), (C_2, C_2), \\dots, (C_N, C_N)$）。其概率为：\n$$ P(C_r = C_o) = \\frac{N}{N^2} = \\frac{1}{N} $$\n因此，$C_r \\neq C_o$ 的概率为：\n$$ P(C_r \\neq C_o) = 1 - P(C_r = C_o) = 1 - \\frac{1}{N} = \\frac{N-1}{N} $$\n\n接下来，我们分析两种协议在不同情况下的延迟：\n- 当 $C_r = C_o$ 时，请求是本地缓存命中，其延迟 $t_{\\text{hit}}$ 在两种协议下是相同的，因为不涉及核心间通信。\n- 当 $C_r \\neq C_o$ 时，延迟取决于协议：\n    - **MESI 协议**：持有核心 $C_o$ 将数据写回主存，然后请求核心 $C_r$ 从主存读取。延迟由主存访问决定，为 $t_{\\text{dram}}$。\n    - **MOESI 协议**：持有核心 $C_o$ 直接将数据通过缓存间传输提供给 $C_r$。延迟为 $t_{cc}$。\n\n单次请求的预期延迟节省 $\\Delta L$ 是两种协议预期延迟之差：\n$$ \\Delta L = E[L_{\\text{MESI}}] - E[L_{\\text{MOESI}}] $$\n$$ \\Delta L = \\left(\\frac{1}{N} t_{\\text{hit}} + \\frac{N-1}{N} t_{\\text{dram}}\\right) - \\left(\\frac{1}{N} t_{\\text{hit}} + \\frac{N-1}{N} t_{cc}\\right) $$\n本地命中延迟项 $t_{\\text{hit}}$ 被抵消，因为节省只发生在 $C_r \\neq C_o$ 的情况下。\n$$ \\Delta L = \\frac{N-1}{N} t_{\\text{dram}} - \\frac{N-1}{N} t_{cc} = \\frac{N-1}{N} (t_{\\text{dram}} - t_{cc}) $$\n\n对于 $k$ 次独立请求，总预期延迟节省 $\\Delta L_{\\text{total}}$ 为：\n$$ \\Delta L_{\\text{total}} = k \\cdot \\Delta L = k \\frac{N-1}{N} (t_{\\text{dram}} - t_{cc}) $$\n\n现在，代入给定的数值：$k = 1000$，$N=8$，$t_{\\text{dram}} = 80\\,\\text{ns}$，以及 $t_{cc} = 20\\,\\text{ns}$。\n$$ \\Delta L_{\\text{total}} = 1000 \\cdot \\frac{8-1}{8} (80\\,\\text{ns} - 20\\,\\text{ns}) $$\n$$ \\Delta L_{\\text{total}} = 1000 \\cdot \\frac{7}{8} (60\\,\\text{ns}) $$\n$$ \\Delta L_{\\text{total}} = 1000 \\cdot 0.875 \\cdot 60\\,\\text{ns} $$\n$$ \\Delta L_{\\text{total}} = 875 \\cdot 60\\,\\text{ns} $$\n$$ \\Delta L_{\\text{total}} = 52500\\,\\text{ns} $$\n该结果需要四舍五入到四位有效数字，即 $5.250 \\times 10^4$ 纳秒。",
            "answer": "$$\n\\boxed{5.250 \\times 10^{4}}\n$$"
        },
        {
            "introduction": "缓存一致性协议虽然在硬件层面保证了数据的一致性，但如果不了解其工作原理，程序员可能会无意中写出性能极差的代码。这个练习聚焦于一个典型的性能陷阱：“伪共享”（false sharing）。你将分析一个场景，其中不相关的数据项因位于同一缓存行而导致了大量的缓存失效事件，并计算通过优化数据布局可以消除多少此类不必要的开销，从而体会到数据结构设计对多核性能的深远影响。",
            "id": "3658524",
            "problem": "一个对称多处理器有 $4$ 个相同的核心，每个核心都有一个私有的 L1 数据缓存。该缓存是写回（write-back）、写分配（write-allocate）的，并通过一种监听协议（snooping protocol）来强制实现一致性。该协议可以是 Modified–Exclusive–Shared–Invalid (MESI) 或 Modified–Owned–Exclusive–Shared–Invalid (MOESI)。缓存行大小为 $64$ 字节。所有缓存最初都是空的。\n\n考虑一个数据结构，它由 $4$ 个不相关的 $8$ 字节计数器组成，这些计数器在内存中连续排列，地址为 $A_0 + 8k$（其中 $k \\in \\{0,1,2,3\\}$），并且 $A_0$ 与一个 $64$ 字节的缓存行边界对齐。因此，这 $4$ 个计数器都占用同一个缓存行。核心 $k$ 重复执行一个紧凑循环，将其位于地址 $A_0 + 8k$ 的计数器精确地增加 $W$ 次，其中 $W = 10^{6}$。对这些地址没有其他内存访问。执行过程按严格的轮询顺序在核心之间调度，每个时间片每个核心执行一次存储操作，因此共享缓存行的所有权在每次存储时都在核心之间交替。将“失效事件”定义为：由于另一个核心的请求，某个核心中的缓存行因一致性协议而从一个有效状态（$M$、$E$、$S$ 或 $O$）转换到无效状态（$I$）。\n\n仅使用 MESI 和 MOESI 状态的标准语义、写分配行为以及“两个地址当且仅当它们落在同一个 $64$ 字节块内时才映射到同一个缓存行”这一事实，回答以下问题：\n\n- 在 MESI 协议下，对于给定的布局和调度，推导由对 $4$ 个计数器的 $4W$ 次存储操作所引起的失效事件总数。\n- 论证对于这种特定的写-写模式，在 MOESI 协议下该总数是否会改变，并从基本原理出发证明你的结论。\n- 提出一种转换方法，将这 $4$ 个不相关的计数器分置于不同的缓存行中（例如，通过填充使每个计数器都始于一个独立的、以 $64$ 字节对齐的 $64$ 字节缓存行的开头），并推导在应用此转换后，在相同调度和 $W$ 值下的失效事件总数。\n\n令 $D$ 表示转换前的失效事件总数与转换后的总数之差。计算 $D$ 的值，结果为一个整数。以无单位的整数形式表达你的最终答案。不要四舍五入。",
            "solution": "本题旨在分析“伪共享”场景下，因缓存一致性协议引起的失效事件数量，并与数据对齐优化后的情况进行对比。\n\n**第一部分：转换前分析（伪共享）**\n\n在此场景中，所有 4 个大小为 8 字节的计数器都位于单个 64 字节的缓存行中，因为基地址 $A_0$ 是对齐的，且它们的总大小（$4 \\times 8 = 32$ 字节）小于单个缓存行的大小（64 字节）。这是一个典型的伪共享情况。\n\n核心 $k$ 对地址 $A_0+8k$ 的计数器进行写操作。由于所有计数器共享同一缓存行，对任何一个计数器的写操作都需要获得整个缓存行的独占所有权。调度是严格的轮询：$C_0, C_1, C_2, C_3, C_0, \\ldots$。\n\n**MESI 协议下的失效推导：**\n我们追踪共享缓存行在 4 个核心中的状态。\n1.  **第 1 次存储（核心 $C_0$）：** $C_0$ 发生写未命中，发出一个请求所有权的读请求（`BusRdX`）。由于缓存行最初无效，主存提供数据。$C_0$ 的缓存加载该行，状态置为 **修改（$M$）**。此时，其他核心的缓存行状态仍为 **无效（$I$）**。\n    - **失效事件：0**。\n\n2.  **第 2 次存储（核心 $C_1$）：** $C_1$ 发生写未命中，发出 `BusRdX` 请求。$C_0$ 监听到此请求，由于它持有该行的 $M$ 状态副本，它必须放弃所有权。$C_0$ 将数据提供给 $C_1$（或写回内存），并使其自己的副本失效（$M \\to I$）。$C_1$ 获得数据，状态置为 $M$。\n    - **失效事件：1**（在 $C_0$ 中）。\n\n3.  **第 3 次存储（核心 $C_2$）：** $C_2$ 发出 `BusRdX` 请求。$C_1$（当前所有者）的缓存行失效（$M \\to I$）。$C_2$ 状态变为 $M$。\n    - **失效事件：1**（在 $C_1$ 中）。\n\n这个模式持续下去。除了第一次存储操作外，随后的每一次存储操作都会导致前一个持有该缓存行的核心发生一次失效事件。总共有 $4W$ 次存储操作。\n\n因此，转换前的总失效事件数 $N_{before}$ 为：\n$$N_{before} = 0 + (4W-1) \\times 1 = 4W-1$$\n\n**MOESI 协议下的理由：**\nMOESI 协议引入的“持有”（$O$）状态用于优化**脏共享**的**读**请求。当一个持有 $M$ 状态缓存行的核心监听到一个**读请求**（`BusRd`）时，它会将状态变为 $O$ 并提供数据。然而，本题的工作负载只包含写操作（被视为需要独占所有权的 `BusRdX` 请求）。由于没有读请求来触发 $M \\to O$ 的转换，$O$ 状态永远不会被进入。因此，事件序列和状态转换与 MESI 协议完全相同。缓存行的所有权在核心之间迁移，每次迁移都导致一次失效。故在 MOESI 协议下，失效总数不变，仍为 $4W-1$。\n\n**第二部分：转换后分析（数据对齐）**\n\n转换后，通过填充，每个计数器位于其自己独立的 64 字节缓存行中。核心 $C_k$ 只访问其专属的缓存行 $L_k$。\n\n1.  **$C_k$ 的第一次存储：** 核心 $C_k$ 对其缓存行 $L_k$ 发生一次强制性未命中（compulsory miss）。它发出 `BusRdX` 请求，从内存获取数据，并将 $L_k$ 的状态置为 $M$。\n    - **失效事件：0**。\n\n2.  **$C_k$ 的后续 $W-1$ 次存储：** 所有后续的写操作都将命中其私有缓存中处于 $M$ 状态的 $L_k$。这些都是本地写命中，不产生任何总线流量或一致性事件。\n\n由于没有其他核心会访问 $L_k$，一旦 $L_k$ 被加载到 $C_k$ 的缓存中，它将一直保持 $M$ 状态，不会再发生失效。这对所有四个核心都成立。因此，在整个执行过程中，由一致性协议引起的失效事件总数为零。\n\n$$N_{after} = 0$$\n\n**第三部分：最终计算**\n\n我们计算转换前后的失效事件总数之差 $D$。\n给定 $W = 10^6$。\n\n$$D = N_{before} - N_{after}$$\n$$D = (4W - 1) - 0$$\n$$D = 4 \\times 10^6 - 1$$\n$$D = 4,000,000 - 1$$\n$$D = 3,999,999$$\n\n这个巨大的差异凸显了伪共享带来的严重性能损失，以及通过数据对齐进行优化的有效性。",
            "answer": "$$\\boxed{3999999}$$"
        },
        {
            "introduction": "掌握MESI和MOESI协议不仅需要理解它们的状态定义，更需要能够在具体的事件序列中精确追踪状态的演变。本练习提供了一个带有时间戳的操作序列，要求你模拟一个多核系统中的缓存行状态变化。通过仔细考虑每个请求的响应来源（缓存或主存）及其不同的延迟，你将能够精确推导出在两种协议下缓存行的最终状态和操作的完成时间，从而深化对协议细节和性能差异的理解。",
            "id": "3658496",
            "problem": "一个具有 $4$ 个私有、写回、写分配高速缓存的共享总线多处理器实现了一个监听无目录协议。考虑单个缓存行 $X$，在时间 $t=0$ 时，它不存在于任何缓存中，并且在主存中是干净的。该系统遵守单写多读 (SWMR) 不变性：在任何时刻，最多只有一个缓存可以持有可写副本，而任意数量的缓存可以持有只读副本。考虑两种一致性协议：修改、独占、共享、无效 (MESI) 和修改、属主、独占、共享、无效 (MOESI)。所有核心在单个广播地址总线上发出一致性请求。以下固定延迟响应模型适用于所有请求，延迟从请求地址被广播的周期开始计算：\n- 主存数据响应延迟为 $L_{\\mathrm{mem}}=20$ 个周期。\n- 从提供数据的缓存（在 MESI 协议下仅指处于“修改”状态的缓存，在 MOESI 协议下指处于“修改”或“属主”状态的缓存）进行的缓存到缓存数据响应延迟为 $L_{\\mathrm{cc}}=8$ 个周期。\n- 来自每个共享者的失效确认在地址广播后 $L_{\\mathrm{inv}}=4$ 个周期到达。请求者只有在收到所有必需的失效确认并且行数据已到达后才能继续进行写操作；完成时间是这两个到达时间的最大值。\n- 如果缓存和主存都可以为同一请求提供数据，则第一个出现在数据总线上的有效数据响应“获胜”，所有后续的数据响应都将被中止。处于“共享”或“独占”状态的缓存不提供数据；在这些情况下，只有主存提供干净数据。在 MESI 协议中，当一次读操作命中某个其他缓存中的“修改”状态行时，“修改”状态的缓存提供数据并降级为“共享”状态，并且内存在事务完成时被更新（视为干净）。在 MOESI 协议中，当一次读操作命中“修改”状态行时，供应者降级为“属主”状态，内存保持过时状态。\n\n以下请求轨迹在给定的时间戳（单位：周期）发生，其中“BusRd”表示请求只读副本的读未命中，“BusRdX”表示请求可写副本的为所有权的读（写未命中）：\n- 在时间 $t=0$，$C_{0}$ 核心为 $X$ 发出 BusRd 请求。\n- 在时间 $t=25$，$C_{1}$ 核心为 $X$ 发出 BusRd 请求。\n- 在时间 $t=50$，$C_{0}$ 核心对 $X$ 发出写操作（如果其持有 $X$ 的“共享”副本，则会发出 BusUpgr 请求）。\n- 在时间 $t=60$，$C_{2}$ 核心为 $X$ 发出 BusRd 请求。\n- 在时间 $t=80$，$C_{3}$ 核心为 $X$ 发出 BusRdX 请求。\n\n假设在所示的每个时间戳，总线仲裁会立即授予地址总线（即，地址广播恰好在所述时间发生），并且数据传输和失效确认根据上述固定延迟异步进行。除了针对同一请求的并发潜在数据供应者的“赢者通吃”规则外，数据总线上没有结构性冒险。\n\n任务：\n- 对于每个请求，对监听响应进行排序，并确定哪个代理（缓存或主存）提供数据，需与给定的延迟和 SWMR 不变性保持一致。确定在 MESI 和 MOESI 两种协议下，每次请求完成后，所涉及缓存中 $X$ 的一致性状态转换。\n- 设 $T_{\\mathrm{MESI}}$ 为在 MESI 协议下，核心 $C_{3}$ 对 $X$ 的 BusRdX 请求能够执行写操作的完成时间（单位：周期），设 $T_{\\mathrm{MOESI}}$ 为在 MOESI 协议下相应的完成时间。计算差值 $\\Delta T = T_{\\mathrm{MESI}} - T_{\\mathrm{MOESI}}$。\n\n将 $\\Delta T$ 的最终答案表示为整数个周期。无需四舍五入。",
            "solution": "我们将分别在 MESI 和 MOESI 协议下，追踪缓存行 $X$ 在四个核心的缓存（$C_0, C_1, C_2, C_3$）以及主存中的状态演变，并计算核心 $C_3$ 写请求的完成时间。初始状态（$t=0$）为：所有缓存中 $X$ 均为无效（I），主存中为干净。\n\n**MESI 协议分析**\n\n1.  **$t=0$：$C_0$ 为 $X$ 发出 BusRd 请求。**\n    - 这是一个读未命中。没有其他缓存持有 $X$，主存提供数据。\n    - 数据到达时间：$t = 0 + L_{\\mathrm{mem}} = 20$ 周期。\n    - 请求在 $t=20$ 完成。由于 $C_0$ 是唯一的持有者，其状态变为**独占 (E)**。\n    - $t=20$ 时的状态：$C_0(\\text{E}), C_1(\\text{I}), C_2(\\text{I}), C_3(\\text{I})$, 内存(干净)。\n\n2.  **$t=25$：$C_1$ 为 $X$ 发出 BusRd 请求。**\n    - 这是一个读未命中。$C_0$ 持有 E 状态副本，根据规则，E 状态缓存不提供数据，由主存提供。\n    - 数据到达时间：$t = 25 + L_{\\mathrm{mem}} = 45$ 周期。\n    - 请求在 $t=45$ 完成。$C_0$ 因共享而降级为**共享 (S)**，$C_1$ 获得 S 状态副本。\n    - $t=45$ 时的状态：$C_0(\\text{S}), C_1(\\text{S}), C_2(\\text{I}), C_3(\\text{I})$, 内存(干净)。\n\n3.  **$t=50$：$C_0$ 对 $X$ 发出写请求。**\n    - 这是一个升级请求（BusUpgr），因为 $C_0$ 持有 S 状态副本。\n    - $C_1$ 必须使其 S 状态副本失效，并发送一个失效确认（ack）。\n    - 失效确认到达时间：$t = 50 + L_{\\mathrm{inv}} = 54$ 周期。\n    - $C_0$ 已有数据，只需等待确认。写操作在 $t=54$ 完成。$C_0$ 状态变为**修改 (M)**，$C_1$ 变为 I。\n    - $t=54$ 时的状态：$C_0(\\text{M}), C_1(\\text{I}), C_2(\\text{I}), C_3(\\text{I})$, 内存(过时)。\n\n4.  **$t=60$：$C_2$ 为 $X$ 发出 BusRd 请求。**\n    - 这是一个读未命中。$C_0$ 持有 M 状态副本，它必须提供数据（缓存到缓存传输）。\n    - 数据到达时间：$t = 60 + L_{\\mathrm{cc}} = 68$ 周期。\n    - 请求在 $t=68$ 完成。根据 MESI 规则，$C_0$ 提供数据后降级为 **S**，内存被更新。$C_2$ 获得 **S** 状态副本。\n    - $t=68$ 时的状态：$C_0(\\text{S}), C_1(\\text{I}), C_2(\\text{S}), C_3(\\text{I})$, 内存(干净)。\n\n5.  **$t=80$：$C_3$ 为 $X$ 发出 BusRdX 请求。**\n    - 这是一个写未命中。$C_0$ 和 $C_2$ 必须使其 S 状态副本失效并发送确认。\n    - 失效确认到达时间：$t = 80 + L_{\\mathrm{inv}} = 84$ 周期。\n    - 由于 $C_0$ 和 $C_2$ 的副本是干净的（S 状态），主存提供数据。\n    - 数据到达时间：$t = 80 + L_{\\mathrm{mem}} = 100$ 周期。\n    - 写操作完成时间为数据和所有确认都到达后的最晚时间：$\\max(100, 84) = 100$ 周期。\n    - 因此，$T_{\\mathrm{MESI}} = 100$。\n\n**MOESI 协议分析**\n\n前三个事件的最终状态与 MESI 相同。\n1.  $t=20$ 完成：$C_0(\\text{E}), C_1(\\text{I}), C_2(\\text{I}), C_3(\\text{I})$, 内存(干净)。\n2.  $t=45$ 完成：$C_0(\\text{S}), C_1(\\text{S}), C_2(\\text{I}), C_3(\\text{I})$, 内存(干净)。\n3.  $t=54$ 完成：$C_0(\\text{M}), C_1(\\text{I}), C_2(\\text{I}), C_3(\\text{I})$, 内存(过时)。\n\n4.  **$t=60$：$C_2$ 为 $X$ 发出 BusRd 请求。**\n    - $C_0$ 持有 M 状态副本，通过缓存到缓存传输提供数据。\n    - 数据到达时间：$t = 60 + L_{\\mathrm{cc}} = 68$ 周期。\n    - 请求在 $t=68$ 完成。根据 MOESI 规则，供应者 $C_0$ 降级为**属主 (O)**，内存保持过时。$C_2$ 获得 **S** 状态副本。\n    - $t=68$ 时的状态：$C_0(\\text{O}), C_1(\\text{I}), C_2(\\text{S}), C_3(\\text{I})$, 内存(过时)。\n\n5.  **$t=80$：$C_3$ 为 $X$ 发出 BusRdX 请求。**\n    - 这是一个写未命中。$C_0$ (O) 和 $C_2$ (S) 必须使其副本失效并发送确认。\n    - 失效确认到达时间：$t = 80 + L_{\\mathrm{inv}} = 84$ 周期。\n    - 由于存在一个“属主”（$C_0$），它持有最新的数据，因此它必须通过缓存到缓存传输来提供数据。\n    - 数据到达时间：$t = 80 + L_{\\mathrm{cc}} = 88$ 周期。\n    - 写操作完成时间：$\\max(88, 84) = 88$ 周期。\n    - 因此，$T_{\\mathrm{MOESI}} = 88$。\n\n**最终计算**\n\n计算两种协议下 $C_3$ 写操作完成时间的差值 $\\Delta T$。\n$$\n\\Delta T = T_{\\mathrm{MESI}} - T_{\\mathrm{MOESI}} = 100 - 88 = 12\n$$\n这个差值源于最后一步的数据来源不同：MESI 协议下由较慢的主存提供数据，而 MOESI 协议下由较快的“属主”缓存提供数据。",
            "answer": "$$\\boxed{12}$$"
        }
    ]
}