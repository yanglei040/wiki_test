{
    "hands_on_practices": [
        {
            "introduction": "比较并交换（Compare-And-Swap, CAS）操作是现代并发编程的基石。本练习将引导您对争用情况下的CAS性能进行量化分析，使用基本的概率论来对其过程进行建模。通过计算预期的周期成本，您将更深刻地体会到争用如何直接影响同步原语的效率。",
            "id": "3645749",
            "problem": "一组线程使用硬件原语“比较并交换”（CAS）来争夺一个单字锁的所有权。假设为独立竞争：所有线程的每次 CAS 尝试成功概率为恒定的 $p$，且与其他尝试无关；失败时，线程在固定的退避后立即执行另一次 CAS。通过一系列独立的伯努利试验来对 CAS 尝试序列进行建模，并使用此模型推导出成功前 CAS 重试的期望次数（作为 $p$ 的函数）。然后，将此期望重试次数映射到以下微架构上的时钟周期。\n\n微架构模型 (Auriga-64):\n- 每次 CAS 尝试都有 $c_{i} = 12$ 个时钟周期的解码/分派/执行开销。\n- 一次成功的 CAS 会产生额外的 $c_{s} = 80$ 个时钟周期的一致性完成成本。\n- 一次失败的 CAS 会产生额外的 $c_{f} = 40$ 个时钟周期的一致性未命中成本。\n- 每次 CAS 失败后，线程在下一次尝试前执行 $b = 60$ 个时钟周期的固定退避。\n\n假设线程重复尝试直到首次 CAS 成功。仅使用独立性假设以及伯努利试验和几何等待时间的核心定义，推导出期望重试次数以及在 Auriga-64 上实现一次成功 CAS 所需的期望总时钟周期的符号表达式（用 $p$、$c_{i}$、$c_{s}$、$c_{f}$ 和 $b$ 表示）。最后，当 $p = 0.3$ 时，计算该期望时钟周期数，并仅报告期望时钟周期。将您的答案四舍五入到四位有效数字。以时钟周期为单位表示最终的期望时钟周期数。",
            "solution": "“比较并交换”（CAS）操作试图原子地将内存中的值与一个期望值进行比较，如果相等，则换入一个新值。在独立竞争条件下，每次尝试以概率 $p$ 成功，以概率 $1-p$ 失败，且与所有其他尝试独立。\n\n基础模型与定义：\n- 每次尝试都是一次成功概率为 $p$ 的伯努利试验。\n- 设 $R$ 为随机变量，表示首次成功前的失败次数。根据定义，$R$ 服从参数为 $p$、定义域为 $\\{0,1,2,\\dots\\}$ 的几何分布，因为 $R=k$ 意味着连续 $k$ 次失败后有一次成功，从而得到\n$$\n\\Pr(R = k) = (1-p)^{k} p, \\quad k \\in \\{0,1,2,\\dots\\}.\n$$\n- 直到首次成功所需的尝试次数 $T$ 为 $T = R + 1$。\n\n期望重试次数的推導：\n我们直接从几何分布计算 $\\mathbb{E}[R]$。使用幂级数恒等式 $\\sum_{k=0}^{\\infty} x^{k} = \\frac{1}{1-x}$ (对于 $|x|  1$)，对 $x$ 求导可得\n$$\n\\sum_{k=0}^{\\infty} k x^{k-1} = \\frac{1}{(1-x)^{2}} \\quad \\Rightarrow \\quad \\sum_{k=0}^{\\infty} k x^{k} = \\frac{x}{(1-x)^{2}}.\n$$\n设 $x = 1-p$，其中 $0  p \\leq 1$，使得 $|x|1$，则\n$$\n\\mathbb{E}[R] = \\sum_{k=0}^{\\infty} k \\Pr(R=k) = \\sum_{k=0}^{\\infty} k (1-p)^{k} p = p \\cdot \\frac{1-p}{(1-(1-p))^{2}} = p \\cdot \\frac{1-p}{p^{2}} = \\frac{1-p}{p}.\n$$\n因此，\n$$\n\\mathbb{E}[R] = \\frac{1-p}{p}, \\quad \\text{and} \\quad \\mathbb{E}[T] = \\mathbb{E}[R] + 1 = \\frac{1}{p}.\n$$\n\n映射到时钟周期：\n每次尝试产生基础指令开销 $c_{i}$。单次成功的 CAS 额外产生 $c_{s}$ 的成本。每次失败额外产生 $c_{f}$ 的成本以及在下一次尝试前 $b$ 个时钟周期的退避。因此，在 $R$ 次失败和 $T=R+1$ 次尝试后实现一次成功所需的总时钟周期 $C$ 可写作\n$$\nC = c_{i} \\cdot T + c_{s} + (c_{f} + b) \\cdot R.\n$$\n根据几何分布求期望，并利用期望的线性性质，\n$$\n\\mathbb{E}[C] = c_{i} \\cdot \\mathbb{E}[T] + c_{s} + (c_{f} + b) \\cdot \\mathbb{E}[R].\n$$\n代入 $\\mathbb{E}[T]$ 和 $\\mathbb{E}[R]$ 的表达式：\n$$\n\\mathbb{E}[C] = c_{i} \\cdot \\frac{1}{p} + c_{s} + (c_{f} + b) \\cdot \\frac{1-p}{p}.\n$$\n\n对于 Auriga-64 参数和 $p = 0.3$ 的数值计算：\n已知 $c_{i} = 12$，$c_{s} = 80$，$c_{f} = 40$，$b = 60$，且 $p = 0.3$，\n$$\n\\mathbb{E}[C] = 12 \\cdot \\frac{1}{0.3} + 80 + (40 + 60) \\cdot \\frac{1-0.3}{0.3}.\n$$\n计算各项：\n$$\n12 \\cdot \\frac{1}{0.3} = 12 \\cdot \\frac{10}{3} = 40,\n$$\n$$\n(40 + 60) = 100,\n$$\n$$\n\\frac{1-0.3}{0.3} = \\frac{0.7}{0.3} = \\frac{7}{3},\n$$\n所以\n$$\n\\mathbb{E}[C] = 40 + 80 + 100 \\cdot \\frac{7}{3} = 120 + \\frac{700}{3} = \\frac{1060}{3}.\n$$\n因此，期望时钟周期为\n$$\n\\mathbb{E}[C] = \\frac{1060}{3} \\approx 353.333\\ldots\n$$\n四舍五入到四位有效数字，结果为 $353.3$ 个时钟周期。",
            "answer": "$$\\boxed{353.3}$$"
        },
        {
            "introduction": "并行系统中的性能不仅仅是避免锁，还涉及理解数据在内存中的布局方式。本练习探讨“伪共享”（false sharing），这是一个微妙但代价高昂的性能陷阱，其中不相关的数据项在缓存中相互干扰。您将量化内存填充作为一种解决方案的有效性，学会评估空间与速度之间的权衡。",
            "id": "3645711",
            "problem": "一个对称多处理器使用 Modified, Exclusive, Shared, Invalid (MESI) 缓存一致性协议。考虑一个由 $T$ 个软件线程使用的锁数组，这些线程一对一地固定在 $T$ 个不同的核心上。每个线程重复地获取和释放一个专用的锁变量，该变量位于一个连续锁数组中的唯一索引处。每次锁操作都会对单个锁字执行一次原子写操作。该数组包含 $N$ 个锁，每个锁字的大小为 $s$ 字节。缓存行大小为 $C$ 字节。假设 $N = T$ 并且锁数组在内存中是连续布局的，除非显式填充，否则没有间隙。所有核心都以相同的稳定速率运行，每个线程的锁操作到达过程是独立的，且服从速率为每秒 $r$ 次操作的泊松分布。\n\n在 MESI 协议下，一个核心对某个缓存行的写操作会使其余核心上该行的副本失效。当映射到同一缓存行的不同锁被不同核心写入时，缓存行的所有权会来回“乒乓”，并导致伪共享（false-sharing）一致性未命中。忽略强制性未命中和容量性未命中；只计算由驻留在同一缓存行上的不同锁之间的伪共享引起的额外一致性未命中。\n\n你通过填充每个锁来评估一种缓解措施，使得每个锁都占据一个完整的缓存行，从而消除锁之间的伪共享。填充将总内存占用从 $N s$ 字节增加到 $N C$ 字节。\n\n给定参数 $T = N = 24$，$s = 8$ 字节，$C = 64$ 字节，以及 $r = 5.0 \\times 10^{4}$ 次操作/秒/线程，计算填充的效率。该效率定义为每秒每增加一千比字节（kibibyte）内存所避免的伪共享一致性未命中次数。一千比字节是 $1024$ 字节。将最终效率以 未命中次数/秒/千比字节 表示，并将你的答案四舍五入到四位有效数字。",
            "solution": "目标是计算填充的效率，其定义为每秒每增加一千比字节内存所避免的伪共享一致性未命中次数。我们可以将此效率 $E$ 表示为：\n$$E = \\frac{\\text{每秒避免的伪共享未命中总次数}}{\\text{额外内存占用（千比字节）}}$$\n\n我们将分别计算分子和分母。\n\n首先，让我们确定在原始未填充配置中发生的伪共享一致性未命中的数量。每个锁填充以占据一个完整缓存行的缓解策略消除了锁之间的所有伪共享。因此，避免的未命中次数等于未填充系统中伪共享未命中的总次数。\n\n给定条件如下：\n线程/核心数，$T = 24$。\n锁的数量，$N = 24$。\n锁字大小，$s = 8$ 字节。\n缓存行大小，$C = 64$ 字节。\n每个线程的锁操作速率，$r = 5.0 \\times 10^{4}$ 次操作/秒。\n\n在未填充配置中，多个锁可以驻留在单个缓存行上。每个缓存行的锁数量 $k$ 为：\n$$k = \\left\\lfloor \\frac{C}{s} \\right\\rfloor = \\left\\lfloor \\frac{64 \\text{ 字节}}{8 \\text{ 字节}} \\right\\rfloor = 8$$\n由于锁数组是连续的，这 $N=24$ 个锁被分成若干组，每组 $k=8$ 个锁，每组共享一个缓存行。这样的组数 $N_g$ 为：\n$$N_g = \\frac{N}{k} = \\frac{24}{8} = 3$$\n这 $3$ 组锁中的每一组都由相应的 $8$ 个不同核心组成的小组访问。在每个小组内，这 $8$ 个核心竞争其共享缓存行的所有权。\n\n让我们分析一个这样由 $k=8$ 个核心组成的小组内的动态。该小组中的每个核心以速率 $r$ 对其专用锁执行原子写操作。来自该小组对单个共享缓存行的总写操作速率为 $k \\times r$。当一个核心试图写入缓存行，但由于前一次写操作，另一个核心以独占（Modified）状态持有该行时，就会发生伪共享一致性未命中。\n\n鉴于每个线程的锁操作到达是独立且服从泊松分布的，我们可以确定给定的写操作导致未命中的概率。一个核心的写操作只有在紧邻的前一次对该缓存行的写操作是由同一个核心执行时，才会命中。由于小组中的所有 $k$ 个核心都具有统计上相同的写速率 $r$，因此下一次对该行的写操作来自任何特定核心的概率是 $\\frac{1}{k}$。因此，下一次写操作是命中（来自刚刚写入的同一个核心）的概率是 $\\frac{1}{k}$。下一次写操作是未命中（来自其他 $k-1$ 个核心之一）的概率是 $1 - \\frac{1}{k} = \\frac{k-1}{k}$。\n\n对于一个由 $k$ 个核心组成的小组，其伪共享未命中率 $M_{group}$ 是对该行的总写入速率乘以未命中的概率：\n$$M_{group} = (k \\times r) \\times \\left(\\frac{k-1}{k}\\right) = (k-1)r$$\n对于我们的参数，每个小组的未命中率为：\n$$M_{group} = (8-1)r = 7r$$\n由于有 $N_g=3$ 个这样的独立小组，整个系统的总伪共享未命中率 $M_{total}$ 为：\n$$M_{total} = N_g \\times M_{group} = 3 \\times (7r) = 21r$$\n这个值代表了通过填充方案所避免的未命中次数。代入 $r$ 的值：\n$$M_{total} = 21 \\times (5.0 \\times 10^{4} \\text{ s}^{-1}) = 105 \\times 10^{4} \\text{ s}^{-1} = 1.05 \\times 10^{6} \\text{ 未命中/秒}$$\n这是我们效率计算的分子。\n\n接下来，我们计算分母：以千比字节（kibibyte）为单位的额外内存占用。\n原始内存占用：$M_{orig} = N \\times s = 24 \\times 8 \\text{ 字节} = 192 \\text{ 字节}$。\n填充后内存占用：$M_{pad} = N \\times C = 24 \\times 64 \\text{ 字节} = 1536 \\text{ 字节}$。\n所需的额外内存 $\\Delta M_{bytes}$ 是：\n$$\\Delta M_{bytes} = M_{pad} - M_{orig} = N(C-s) = 24 \\times (64 - 8) = 24 \\times 56 = 1344 \\text{ 字节}$$\n问题要求以千比字节（KiB）表示，其中 $1 \\text{ KiB} = 1024$ 字节。\n$$\\Delta M_{KiB} = \\frac{\\Delta M_{bytes}}{1024} = \\frac{1344}{1024} = 1.3125 \\text{ KiB}$$\n这是我们效率计算的分母。\n\n最后，我们计算效率 $E$：\n$$E = \\frac{M_{total}}{\\Delta M_{KiB}} = \\frac{1.05 \\times 10^{6} \\text{ 未命中/秒}}{1.3125 \\text{ KiB}} = 800000 \\frac{\\text{未命中}}{\\text{s} \\cdot \\text{KiB}}$$\n按照要求，将其写成科学记数法并四舍五入到四位有效数字：\n$$E = 8.000 \\times 10^{5} \\frac{\\text{未命中}}{\\text{s} \\cdot \\text{KiB}}$$",
            "answer": "$$\\boxed{8.000 \\times 10^{5}}$$"
        },
        {
            "introduction": "除了性能，同步的最终目标是正确性。本练习深入探讨了臭名昭著的“ABA问题”，这是一个可能破坏基于CAS构建的无锁算法的微妙错误。您将推导出“标记指针”（tagged pointers）的需求，这是一种利用内存地址中被浪费的比特位来确保正确性的巧妙解决方案，突显了硬件特性与并发软件设计之间的协同作用。",
            "id": "3645713",
            "problem": "一个系统实现了一个无锁的后进先出（LIFO）栈，它对栈顶指针使用原子比较并交换（CAS）操作。比较并交换（CAS）操作会原子地将一个内存位置的内容与一个给定的期望值进行比较，并且只有在它们相同时，才会原子地将该位置更新为一个新值。为了缓解“ABA”问题——即一个线程观察到栈顶指针的值为 $A$，在该线程执行其CAS操作之前，该值变为 $B$，然后又变回 $A$——系统使用了带标签的指针：一个版本计数器被嵌入到栈顶指针的低位比特中，并在每次成功的栈顶更新时递增。\n\n假设节点在具有 $16$ 字节对齐的 $64$ 位架构上分配，因此每个有效节点地址的最低 $4$ 个有效位都等于 $0$，这些位可以被重新用于存储版本标签。设版本标签为一个 $b$ 位计数器，在每次成功更新栈顶指针的入栈或出栈操作时，该计数器以 $2^{b}$ 为模加 $1$。\n\n运行时使用基于纪元的回收（Epoch-Based Reclamation, EBR），它限制了在任何线程加载栈顶指针与其后续CAS尝试之间可能发生的最大栈顶更新次数。具体来说，在最坏情况下，该窗口期内最多可能发生 $R = 12$ 次成功的栈顶更新。\n\n从原子CAS语义、计数器的模运算以及指针对齐使有效地址的低位比特固定为零的特性出发，推导出所需的最小标签位数 $b$，以确保标签在最坏情况的窗口期内不会回绕，从而防止ABA问题未被检测到。你还必须确保 $b$ 不超过由对齐保证为零的低位比特数。请提供最终答案，形式为单个整数。无需单位。",
            "solution": "该问题要求确定版本标签所需的最小位数 $b$，以在一个无锁栈实现中防止ABA问题。解决方案必须满足两个主要约束：标签在指定的操作窗口期内不得回绕，并且用于标签的位数不得超过因内存对齐而可用的位数。\n\n首先，让我们在这种情况下形式化地描述未被检测到的ABA问题。一个线程读取一个栈顶指针值，该值由一个内存地址和一个版本标签组成。设这个初始值为 $(A, T)$，其中 $A$ 是地址， $T$ 是标签。然后，该线程在尝试进行比较并交换（CAS）操作之前会执行一些工作。如果在该时间间隔内，栈顶指针变为某个其他值 $(B, T+1)$，然后又变回具有原始地址 $A$ 的值，比如说 $(A, T')$，那么就发生了ABA问题。如果栈顶指针的最终状态与初始读取的状态完全相同，即如果 $(A, T') = (A, T)$，这意味着 $T' = T$，那么就发生了未被检测到的ABA。\n\n版本标签是一个 $b$ 位计数器，每次成功更新栈顶指针时，它都会加 $1$。这个递增操作是模 $2^b$ 的。如果初始标签是 $T$，经过 $N$ 次成功更新后，新的标签 $T'$ 将由以下关系式给出：\n$$T' = (T + N) \\pmod{2^b}$$\n如果在 $N$ 次更新后，标签值返回到其原始值 $T$，那么在地址 $A$ 上就有可能发生未被检测到的ABA。这对应于条件 $T' = T$，即：\n$$(T + N) \\pmod{2^b} = T$$\n这个方程成立的充分必要条件是 $N$ 是模数 $2^b$ 的倍数。即：\n$$N \\equiv 0 \\pmod{2^b}$$\n由于ABA情景意味着至少有一次变化，我们关心的是 $N \\ge 1$ 的情况。因此，要发生未被检测到的ABA，更新次数 $N$ 必须是 $2^b$ 的一个非零倍数。\n\n问题指出，基于纪元的回收（EBR）保证了在一个线程加载栈顶指针与其后续CAS尝试之间的窗口期内，最多可以发生 $R = 12$ 次成功的栈顶更新。这意味着中间的更新次数 $N$ 的范围是 $1 \\le N \\le R = 12$。\n\n为保证ABA总是能被检测到，我们必须确保标签在这个窗口期内不能回绕到其原始值。这要求对于范围 $[1, R]$ 内任何可能的 $N$ 值，条件 $N \\equiv 0 \\pmod{2^b}$ 都永远不会满足。为确保这一点， $2^b$ 的最小非零倍数（即 $2^b$ 本身）必须大于 $N$ 的最大可能值。 $N$ 的最大值为 $R$。因此，我们必须满足不等式：\n$$2^b  R$$\n代入给定的值 $R=12$：\n$$2^b  12$$\n我们必须找到满足这个不等式的最小整数 $b$。我们可以测试 $b$ 的值：\n当 $b=1$ 时, $2^1 = 2$，不大于 $12$。\n当 $b=2$ 时, $2^2 = 4$，不大于 $12$。\n当 $b=3$ 时, $2^3 = 8$，不大于 $12$。\n当 $b=4$ 时, $2^4 = 16$，大于 $12$。\n因此，防止标签回绕所需的最小位数为 $b = 4$。\n\n接下来，我们必须根据指针对齐所施加的物理约束来验证这个结果。系统使用64位架构，并且节点以16字节对齐方式分配。如果一个地址是16的倍数，那么它就是16字节对齐的。在二进制表示中，数字16是 $10000_2$。因此，任何是16的倍数的内存地址，其最低4个有效位必须等于0。这样，这4个位就可以被重新用于存储版本标签，而不会与地址信息冲突。\n可用位数为4。我们推导出的最小需求是 $b=4$。由于 $b=4$ 不超过可用位数（$4 \\le 4$），这个解决方案在物理上是可行的。\n\n因此，既能防止在最坏情况窗口期内发生未被检测到的ABA，又能容纳在指针可用低位比特中的最小标签位数 $b$ 是 $4$。",
            "answer": "$$\\boxed{4}$$"
        }
    ]
}