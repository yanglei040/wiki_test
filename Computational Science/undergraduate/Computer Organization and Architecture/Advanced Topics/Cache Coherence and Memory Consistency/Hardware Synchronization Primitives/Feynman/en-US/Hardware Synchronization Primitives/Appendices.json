{
    "hands_on_practices": [
        {
            "introduction": "Efficient synchronization begins not with complex algorithms, but with a fundamental understanding of how data interacts with the underlying hardware. On modern multicore systems, seemingly unrelated data can interfere at the cache level, causing severe performance degradation through phenomena like false sharing and cache set conflicts. This practice  challenges you to act as a performance engineer, applying first principles of cache organization to proactively design a memory layout that avoids these costly hardware-level hazards.",
            "id": "3645721",
            "problem": "A Central Processing Unit (CPU) implements a physically indexed, physically tagged, set-associative First-Level Data Cache (L1 D$). The cache has total capacity $C = 32 \\text{ KiB}$, associativity $A = 8$, and cache line size $B = 64 \\text{ bytes}$. A lock array is to be placed in memory such that concurrent lock acquisitions do not suffer from false sharing and do not induce avoidable index conflicts in the L1 D$.\n\nThe lock array consists of identical lock objects of size $L = 12 \\text{ bytes}$. The array base address $X_{0}$ is aligned to a cache line boundary, that is, $X_{0} \\equiv 0 \\ (\\bmod\\ B)$. You are allowed to choose a stride $s$ (in bytes) between successive locks in the array by inserting padding, but the stride must be an integer multiple of the lock size $L$ due to allocator constraints. The number of locks that may be simultaneously hot is $N = 160$.\n\nStarting from first principles of set-associative cache indexing, and the definition of false sharing in coherent caches, derive the minimal stride $s$ (in bytes) that simultaneously satisfies the following requirements:\n\n- Each lock begins at the start of a distinct cache line to avoid false sharing under a write-intensive workload.\n- The sequence of cache sets indexed by the lock addresses is uniformly distributed over the $S$ sets of the L1 D$, ensuring that with $N$ hot locks, no set holds more than $A$ hot lines.\n\nExpress the final stride $s$ in bytes. No rounding is required. All assumptions must be explicitly justified from the given parameters and the fundamental definitions of cache indexing and coherence. Do not assume any undocumented behavior beyond the provided parameters.",
            "solution": "The problem statement has been validated and is deemed self-contained, scientifically grounded, and well-posed. We may proceed with a formal derivation.\n\nThe objective is to find the minimal stride $s$ for a lock array that satisfies two specific requirements related to cache performance: avoidance of false sharing and uniform distribution of cache set accesses.\n\nFirst, we establish the fundamental parameters of the L1 Data Cache (L1 D$).\nThe givens are:\n- Cache capacity $C = 32 \\text{ KiB} = 32 \\times 2^{10} \\text{ bytes} = 2^5 \\times 2^{10} = 2^{15} \\text{ bytes}$.\n- Associativity $A = 8 = 2^3$.\n- Cache line (block) size $B = 64 \\text{ bytes} = 2^6 \\text{ bytes}$.\n\nThe number of sets $S$ in a set-associative cache is given by the relation $C = S \\times A \\times B$.\nTherefore, the number of sets is:\n$$S = \\frac{C}{A \\times B} = \\frac{2^{15}}{2^3 \\times 2^6} = \\frac{2^{15}}{2^9} = 2^6 = 64$$\nA physical memory address is partitioned into a tag, an index, and an offset. The number of offset bits is $\\log_2(B) = \\log_2(64) = 6$. The number of index bits is $\\log_2(S) = \\log_2(64) = 6$. The cache set for a physical address `addr` is determined by its index bits, which can be computed as $\\lfloor \\text{addr} / B \\rfloor \\pmod S$.\n\nWe now analyze the two requirements for the lock array stride $s$.\n\n**Requirement 1: Avoidance of False Sharing**\nThe problem stipulates, \"Each lock begins at the start of a distinct cache line to avoid false sharing under a write-intensive workload.\"\nLet the addresses of the locks in the array be $X_i$ for $i = 0, 1, 2, \\ldots$. The address of the $i$-th lock is $X_i = X_0 + i \\cdot s$, where $X_0$ is the base address and $s$ is the stride.\nWe are given that the base address is aligned to a cache line boundary, meaning $X_0 \\equiv 0 \\pmod B$.\nThe requirement that each lock begins at the start of a cache line means that for every lock $i$, its address $X_i$ must be a multiple of the cache line size $B$.\n$$X_i \\equiv 0 \\pmod B \\quad \\forall i \\ge 0$$\nSubstituting the expression for $X_i$ and the known alignment of $X_0$:\n$$X_0 + i \\cdot s \\equiv 0 \\pmod B$$\n$$0 + i \\cdot s \\equiv 0 \\pmod B$$\nThis condition must hold for all $i$. For $i=1$, it implies $s \\equiv 0 \\pmod B$. Thus, the stride $s$ must be an integer multiple of the cache line size $B = 64$ bytes.\n\nAdditionally, the problem states a constraint from the memory allocator: \"the stride must be an integer multiple of the lock size $L$\". We are given $L = 12$ bytes.\nTherefore, $s$ must also be an integer multiple of $L=12$.\n\nTo satisfy both conditions simultaneously, the stride $s$ must be a common multiple of $B$ and $L$. To find the minimal possible stride satisfying this requirement, $s$ must be a multiple of the least common multiple (LCM) of $B$ and $L$.\nWe calculate the LCM of $B=64$ and $L=12$:\n- Prime factorization of $L$: $12 = 2^2 \\times 3^1$.\n- Prime factorization of $B$: $64 = 2^6$.\n- $\\text{lcm}(12, 64) = 2^{\\max(2,6)} \\times 3^{\\max(1,0)} = 2^6 \\times 3^1 = 64 \\times 3 = 192$.\n\nThus, from Requirement 1 and the allocator constraint, the stride $s$ must be an integer multiple of $192$ bytes. Let $s = j \\cdot 192$ for some positive integer $j$.\n\n**Requirement 2: Uniform Distribution of Set Indices**\nThe second requirement is, \"The sequence of cache sets indexed by the lock addresses is uniformly distributed over the $S$ sets of the L1 D$$, ensuring that with $N$ hot locks, no set holds more than $A$ hot lines.\"\nThe set index for the $i$-th lock at address $X_i$ is given by $I_i = \\lfloor X_i / B \\rfloor \\pmod S$.\nSubstituting $X_i = X_0 + i \\cdot s$ and using the fact that $X_0 = k_0 B$ for some integer $k_0$:\n$$I_i = \\left\\lfloor \\frac{k_0 B + i \\cdot s}{B} \\right\\rfloor \\pmod S = \\lfloor k_0 + i \\cdot \\frac{s}{B} \\rfloor \\pmod S$$\nFrom Requirement 1, we established that $s$ must be a multiple of $B$, so the term $s/B$ is an integer. Let $m = s/B$.\n$$I_i = (k_0 + i \\cdot m) \\pmod S$$\nThe sequence of set indices $I_0, I_1, I_2, \\ldots$ forms an arithmetic progression modulo $S$ with a common difference of $m$. This sequence is uniformly distributed over the $S$ sets if and only if the set indices visit every set in a cycle of length $S$. This occurs when the common difference $m$ is relatively prime to the modulus $S$.\nThe condition for uniform distribution is therefore:\n$$\\gcd(m, S) = 1 \\implies \\gcd(\\frac{s}{B}, S) = 1$$\nSubstituting the known values $B=64$ and $S=64$:\n$$\\gcd(\\frac{s}{64}, 64) = 1$$\nThe prime factorization of $S=64$ is $2^6$. For the greatest common divisor to be $1$, the term $s/64$ must not share any prime factors with $64$. This means $s/64$ must not be divisible by $2$, i.e., $s/64$ must be an odd integer.\n\nThe second part of this requirement, \"ensuring that with $N=160$ hot locks, no set holds more than $A=8$ hot lines,\" is a consequence of this uniform distribution. If the indices are uniformly distributed, the $N=160$ hot locks will be spread as evenly as possible over the $S=64$ sets. The maximum number of locks mapping to any single set will be $\\lceil N/S \\rceil$.\n$$\\text{Max locks per set} = \\left\\lceil \\frac{N}{S} \\right\\rceil = \\left\\lceil \\frac{160}{64} \\right\\rceil = \\lceil 2.5 \\rceil = 3$$\nThe cache can hold up to $A=8$ lines per set. Since $3 \\le 8$, this condition is satisfied by ensuring uniform distribution.\n\n**Combining Requirements to Find the Minimal Stride**\nWe must find the smallest positive stride $s$ that satisfies both derived conditions:\n1. $s$ is a multiple of $192$. So, $s = j \\cdot 192$ for some integer $j \\ge 1$.\n2. $s/64$ is an odd integer.\n\nLet's substitute the first condition into the second:\n$$\\frac{s}{64} = \\frac{j \\cdot 192}{64} = j \\cdot 3$$\nThe condition becomes that $3j$ must be an odd integer. Since the product of two integers is odd if and only if both integers are odd, and $3$ is odd, it follows that $j$ must be an odd integer.\n\nTo find the minimal stride $s$, we must choose the smallest positive integer $j$ that is odd. This value is $j=1$.\n\nSubstituting $j=1$ back into the expression for $s$:\n$$s = 1 \\cdot 192 = 192$$\n\nThe minimal stride that satisfies all stated conditions is $192$ bytes.\n- It is a multiple of $L=12$ ($192 = 16 \\times 12$).\n- It ensures each lock begins at the start of a cache line (as $192$ is a multiple of $B=64$).\n- It ensures uniform set index distribution, since $s/B = 192/64 = 3$, and $\\gcd(3, 64) = 1$.\n- This uniform distribution guarantees that for $N=160$ locks, the busiest set has $\\lceil 160/64 \\rceil = 3$ locks, which is less than the associativity $A=8$.\nThere is no smaller integer that satisfies all these criteria.",
            "answer": "$$\\boxed{192}$$"
        },
        {
            "introduction": "Once an optimal memory layout is established, the next challenge is to quantify the performance of atomic operations under real-world contention. The Compare-And-Swap (CAS) primitive is a cornerstone of modern synchronization, but its effectiveness diminishes as more threads compete for the same resource. In this exercise , you will develop a powerful probabilistic model to analyze the performance of a CAS-based spinlock, connecting abstract probability theory to the concrete, cycle-level costs of a processor's microarchitecture.",
            "id": "3645749",
            "problem": "A group of threads contends for ownership of a single-word lock using the hardware primitive Compare-And-Swap (CAS). Assume independent contention: each CAS attempt across all threads succeeds with constant probability $p$, independently of other attempts, and on failure the thread immediately performs another CAS after a fixed backoff. Model the sequence of CAS attempts by a series of independent Bernoulli trials and use this model to derive the expected number of CAS retries before a success as a function of $p$. Then, map this expected retry count to cycles on the following microarchitecture.\n\nMicroarchitecture model (Auriga-64):\n- Each CAS attempt has a decode/dispatch/execute overhead of $c_{i} = 12$ cycles.\n- A successful CAS incurs an additional coherence completion cost of $c_{s} = 80$ cycles.\n- A failed CAS incurs an additional coherence miss cost of $c_{f} = 40$ cycles.\n- After each failed CAS, the thread performs a fixed backoff of $b = 60$ cycles before the next attempt.\n\nAssume the thread repeats attempts until the first successful CAS. Using only the independence assumption and core definitions of Bernoulli trials and geometric waiting times, derive a symbolic expression for the expected number of retries and then for the expected total cycles required to achieve one successful CAS on Auriga-64 in terms of $p$, $c_{i}$, $c_{s}$, $c_{f}$, and $b$. Finally, evaluate this expected cycle count for $p = 0.3$ and report only the expected cycles. Round your answer to four significant figures. Express the final expected cycles in cycles.",
            "solution": "The Compare-And-Swap (CAS) operation attempts to atomically compare the value in memory to an expected value and, if equal, swap in a new value. Under independent contention, each attempt succeeds with probability $p$ and fails with probability $1-p$, independently of all other attempts.\n\nFoundational model and definitions:\n- Each attempt is a Bernoulli trial with success probability $p$.\n- Let $R$ be the random variable counting the number of failures before the first success. By definition, $R$ follows a geometric distribution over $\\{0,1,2,\\dots\\}$ with parameter $p$, since $R=k$ means $k$ consecutive failures followed by one success, yielding\n$$\n\\Pr(R = k) = (1-p)^{k} p, \\quad k \\in \\{0,1,2,\\dots\\}.\n$$\n- The number of attempts $T$ until the first success is $T = R + 1$.\n\nDerivation of the expected number of retries:\nWe compute $\\mathbb{E}[R]$ directly from the geometric distribution. Using the power series identity $\\sum_{k=0}^{\\infty} x^{k} = \\frac{1}{1-x}$ for $|x| < 1$, differentiate with respect to $x$ to obtain\n$$\n\\sum_{k=0}^{\\infty} k x^{k-1} = \\frac{1}{(1-x)^{2}} \\quad \\Rightarrow \\quad \\sum_{k=0}^{\\infty} k x^{k} = \\frac{x}{(1-x)^{2}}.\n$$\nSet $x = 1-p$ with $0 < p \\leq 1$ so that $|x|<1$, then\n$$\n\\mathbb{E}[R] = \\sum_{k=0}^{\\infty} k \\Pr(R=k) = \\sum_{k=0}^{\\infty} k (1-p)^{k} p = p \\cdot \\frac{1-p}{(1-(1-p))^{2}} = p \\cdot \\frac{1-p}{p^{2}} = \\frac{1-p}{p}.\n$$\nHence,\n$$\n\\mathbb{E}[R] = \\frac{1-p}{p}, \\quad \\text{and} \\quad \\mathbb{E}[T] = \\mathbb{E}[R] + 1 = \\frac{1}{p}.\n$$\n\nMapping to cycles:\nEach attempt incurs the base instruction overhead $c_{i}$. A single successful CAS additionally incurs $c_{s}$. Each failure additionally incurs $c_{f}$ and a backoff of $b$ cycles before the next attempt. Therefore, the total cycles $C$ to achieve one success after $R$ failures and $T=R+1$ attempts can be written as\n$$\nC = c_{i} \\cdot T + c_{s} + (c_{f} + b) \\cdot R.\n$$\nTaking expectation with respect to the geometric distribution and using linearity of expectation,\n$$\n\\mathbb{E}[C] = c_{i} \\cdot \\mathbb{E}[T] + c_{s} + (c_{f} + b) \\cdot \\mathbb{E}[R].\n$$\nSubstitute the expressions for $\\mathbb{E}[T]$ and $\\mathbb{E}[R]$:\n$$\n\\mathbb{E}[C] = c_{i} \\cdot \\frac{1}{p} + c_{s} + (c_{f} + b) \\cdot \\frac{1-p}{p}.\n$$\n\nNumerical evaluation for the Auriga-64 parameters and $p = 0.3$:\nGiven $c_{i} = 12$, $c_{s} = 80$, $c_{f} = 40$, $b = 60$, and $p = 0.3$,\n$$\n\\mathbb{E}[C] = 12 \\cdot \\frac{1}{0.3} + 80 + (40 + 60) \\cdot \\frac{1-0.3}{0.3}.\n$$\nCompute the terms:\n$$\n12 \\cdot \\frac{1}{0.3} = 12 \\cdot \\frac{10}{3} = 40,\n$$\n$$\n(40 + 60) = 100,\n$$\n$$\n\\frac{1-0.3}{0.3} = \\frac{0.7}{0.3} = \\frac{7}{3},\n$$\nso\n$$\n\\mathbb{E}[C] = 40 + 80 + 100 \\cdot \\frac{7}{3} = 120 + \\frac{700}{3} = \\frac{1060}{3}.\n$$\nThus, the expected cycles are\n$$\n\\mathbb{E}[C] = \\frac{1060}{3} \\approx 353.333\\ldots\n$$\nRounded to four significant figures, this is $353.3$ cycles.",
            "answer": "$$\\boxed{353.3}$$"
        },
        {
            "introduction": "While performance is a key goal, the absolute priority in concurrent programming is correctness. Lock-free algorithms built upon primitives like Compare-And-Swap (CAS) can offer great performance but are also susceptible to subtle and dangerous bugs, with the \"ABA problem\" being a classic example. This final practice  delves into this critical correctness issue, tasking you with engineering a robust solution using tagged pointers and demonstrating how low-level hardware features, such as memory alignment, can be cleverly exploited to build safe and reliable concurrent software.",
            "id": "3645713",
            "problem": "A system implements a lock-free Last-In-First-Out (LIFO) stack using an atomic compare-and-swap (CAS) on the stack head pointer. The compare-and-swap (CAS) operation atomically compares the contents of a memory location to a given expected value and, only if they are the same, atomically updates that location to a new value. To mitigate the \"ABA\" problem—where a thread observes the head pointer value as $A$, it changes to $B$, and then back to $A$ before the thread performs its CAS—the system uses tagged pointers: a version counter is embedded in the low-order bits of the head pointer and incremented on every successful head update.\n\nAssume nodes are allocated on a $64$-bit architecture with $16$-byte alignment, so every valid node address has its $4$ least significant bits equal to $0$, which can be repurposed to hold a version tag. Let the version tag be a $b$-bit counter that increments by $1$ modulo $2^{b}$ on every successful push or pop that updates the head pointer.\n\nThe runtime uses Epoch-Based Reclamation (EBR), which bounds the number of head updates that can occur between any thread’s load of the head pointer and its subsequent CAS attempt. Specifically, in the worst case, at most $R = 12$ successful head updates can occur during that window.\n\nStarting from the definitions of atomic CAS semantics, modulo arithmetic for counters, and the property of pointer alignment that fixes low-order bits at zero for valid addresses, derive the minimal number of tag bits $b$ required to ensure the tag cannot wrap within the worst-case window and thus prevent an ABA from being undetected. You must also ensure that $b$ does not exceed the number of low-order bits guaranteed zero by alignment. Provide the final answer as a single integer. No units are required.",
            "solution": "The problem requires the determination of the minimum number of bits, $b$, for a version tag to prevent the ABA problem in a lock-free stack implementation. The solution must satisfy two primary constraints: the tag must not wrap around within a specified window of operations, and the number of bits used for the tag must not exceed the number of bits available due to memory alignment.\n\nFirst, let us formalize the problem of an undetected ABA in this context. A thread reads a head pointer value, which is a composite of a memory address and a version tag. Let this initial value be $(A, T)$, where $A$ is the address and $T$ is the tag. The thread then proceeds with some work before attempting a compare-and-swap (CAS) operation. An ABA problem occurs if, during this interval, the head pointer changes to some other value $(B, T+1)$, and then subsequently changes back to a value with the original address $A$, say $(A, T')$. An undetected ABA occurs if the final state of the head pointer is identical to the one initially read, i.e., if $(A, T') = (A, T)$, which implies $T' = T$.\n\nThe version tag is a $b$-bit counter that increments by $1$ on every successful update to the head pointer. This incrementation is performed modulo $2^b$. If the initial tag is $T$, after $N$ successful updates, the new tag $T'$ will be given by the relation:\n$$T' = (T + N) \\pmod{2^b}$$\nAn undetected ABA on address $A$ is possible if the tag value returns to its original value $T$ after $N$ updates. This corresponds to the condition $T' = T$, which means:\n$$(T + N) \\pmod{2^b} = T$$\nThis equation holds if and only if $N$ is a multiple of the modulus, $2^b$. That is:\n$$N \\equiv 0 \\pmod{2^b}$$\nSince an ABA scenario implies at least one change, we are concerned with $N \\ge 1$. Thus, for an undetected ABA to occur, the number of updates $N$ must be a non-zero multiple of $2^b$.\n\nThe problem states that Epoch-Based Reclamation (EBR) guarantees that at most $R = 12$ successful head updates can occur in the window between a thread's load of the head pointer and its subsequent CAS attempt. This means the number of intervening updates, $N$, is bounded by $1 \\le N \\le R = 12$.\n\nTo guarantee that an ABA is always detected, we must ensure that the tag cannot wrap back to its original value within this window. This requires that the condition $N \\equiv 0 \\pmod{2^b}$ is never met for any possible value of $N$ in the range $[1, R]$. To ensure this, the smallest non-zero multiple of $2^b$, which is $2^b$ itself, must be larger than the maximum possible value of $N$. The maximum value for $N$ is $R$. Therefore, we must satisfy the inequality:\n$$2^b > R$$\nSubstituting the given value $R=12$:\n$$2^b > 12$$\nWe must find the smallest integer $b$ that satisfies this inequality. We can test values of $b$:\nFor $b=1$, $2^1 = 2$, which is not greater than $12$.\nFor $b=2$, $2^2 = 4$, which is not greater than $12$.\nFor $b=3$, $2^3 = 8$, which is not greater than $12$.\nFor $b=4$, $2^4 = 16$, which is greater than $12$.\nThus, the minimum number of bits required to prevent tag wrap-around is $b = 4$.\n\nNext, we must verify this result against the physical constraint imposed by pointer alignment. The system uses a $64$-bit architecture, and nodes are allocated with $16$-byte alignment. An address is $16$-byte aligned if it is a multiple of $16$. In binary representation, the number $16$ is $10000_2$. Any memory address that is a multiple of $16$ must therefore have its $4$ least significant bits equal to $0$. These $4$ bits are thus available to be repurposed for storing the version tag without conflicting with the address information.\nThe number of available bits is $4$. Our derived minimal requirement is $b=4$. Since $b=4$ does not exceed the number of available bits ($4 \\le 4$), this solution is physically realizable.\n\nTherefore, the minimal number of tag bits $b$ that both prevents an undetected ABA within the worst-case window and fits within the available low-order bits of the pointer is $4$.",
            "answer": "$$\\boxed{4}$$"
        }
    ]
}