{
    "hands_on_practices": [
        {
            "introduction": "要构建高效的并发系统，我们必须首先理解其底层原子构建块的性能。本练习将引导您对普遍使用的“比较并交换”（Compare-And-Swap, CAS）操作在竞争条件下的性能进行建模。通过将每次CAS尝试视为一个概率性事件，您将推导出获取一个锁所需的期望时间，从而将抽象的竞争概念转化为具体的处理器周期数。这项实践对于培养对同步相关成本的直觉至关重要。",
            "id": "3645749",
            "problem": "一组线程使用硬件原语“比较并交换”(CAS)来竞争一个单字锁的所有权。假设为独立竞争：所有线程的每次CAS尝试都以恒定概率 $p$ 成功，且与其他尝试独立；失败时，线程在经过一个固定的退避后立即执行另一次CAS。将CAS尝试序列建模为一系列独立的伯努利试验，并使用此模型推导成功前CAS重试的期望次数，将其表示为 $p$ 的函数。然后，将此期望重试次数映射到以下微架构上的时钟周期数。\n\n微架构模型 (Auriga-64):\n- 每次CAS尝试有 $c_{i} = 12$ 个时钟周期的解码/分派/执行开销。\n- 一次成功的CAS会产生 $c_{s} = 80$ 个时钟周期的一致性完成额外成本。\n- 一次失败的CAS会产生 $c_{f} = 40$ 个时钟周期的一致性未命中额外成本。\n- 每次CAS失败后，线程在下一次尝试前执行 $b = 60$ 个时钟周期的固定退避。\n\n假设线程重复尝试，直到第一次CAS成功。仅使用独立性假设以及伯努利试验和几何等待时间的核心定义，推导期望重试次数的符号表达式，然后推导在Auriga-64上实现一次成功CAS所需的总期望时钟周期数的符号表达式，用 $p$、$c_{i}$、$c_{s}$、$c_{f}$ 和 $b$ 表示。最后，计算当 $p = 0.3$ 时此期望时钟周期数的值，并只报告期望时钟周期数。将您的答案四舍五入到四位有效数字。以“时钟周期”为单位表示最终的期望时钟周期。",
            "solution": "比较并交换(CAS)操作试图原子地将内存中的值与一个期望值进行比较，如果相等，则换入一个新值。在独立竞争下，每次尝试以概率 $p$ 成功，以概率 $1-p$ 失败，且与所有其他尝试独立。\n\n基础模型与定义：\n- 每次尝试是一次成功概率为 $p$ 的伯努利试验。\n- 令 $R$ 为第一次成功前失败次数的随机变量。根据定义，$R$ 服从定义在 $\\{0,1,2,\\dots\\}$ 上、参数为 $p$ 的几何分布，因为 $R=k$ 意味着 $k$ 次连续失败后有一次成功，可得\n$$\n\\Pr(R = k) = (1-p)^{k} p, \\quad k \\in \\{0,1,2,\\dots\\}.\n$$\n- 直到第一次成功的尝试次数 $T$ 为 $T = R + 1$。\n\n期望重试次数的推导：\n我们直接从几何分布计算 $\\mathbb{E}[R]$。使用幂级数恒等式 $\\sum_{k=0}^{\\infty} x^{k} = \\frac{1}{1-x}$ (对于 $|x|  1$)，对 $x$ 求导可得\n$$\n\\sum_{k=0}^{\\infty} k x^{k-1} = \\frac{1}{(1-x)^{2}} \\quad \\Rightarrow \\quad \\sum_{k=0}^{\\infty} k x^{k} = \\frac{x}{(1-x)^{2}}.\n$$\n令 $x = 1-p$，$0  p \\leq 1$ 使得 $|x|1$，则\n$$\n\\mathbb{E}[R] = \\sum_{k=0}^{\\infty} k \\Pr(R=k) = \\sum_{k=0}^{\\infty} k (1-p)^{k} p = p \\cdot \\frac{1-p}{(1-(1-p))^{2}} = p \\cdot \\frac{1-p}{p^{2}} = \\frac{1-p}{p}.\n$$\n因此，\n$$\n\\mathbb{E}[R] = \\frac{1-p}{p}, \\quad \\text{and} \\quad \\mathbb{E}[T] = \\mathbb{E}[R] + 1 = \\frac{1}{p}.\n$$\n\n映射到时钟周期：\n每次尝试产生基础指令开销 $c_{i}$。一次成功的CAS额外产生 $c_{s}$。每次失败额外产生 $c_{f}$ 以及在下一次尝试前的 $b$ 个时钟周期的退避。因此，在 $R$ 次失败和 $T=R+1$ 次尝试后实现一次成功所需的总时钟周期数 $C$ 可以写为\n$$\nC = c_{i} \\cdot T + c_{s} + (c_{f} + b) \\cdot R.\n$$\n对几何分布取期望，并利用期望的线性性质，\n$$\n\\mathbb{E}[C] = c_{i} \\cdot \\mathbb{E}[T] + c_{s} + (c_{f} + b) \\cdot \\mathbb{E}[R].\n$$\n代入 $\\mathbb{E}[T]$ 和 $\\mathbb{E}[R]$ 的表达式：\n$$\n\\mathbb{E}[C] = c_{i} \\cdot \\frac{1}{p} + c_{s} + (c_{f} + b) \\cdot \\frac{1-p}{p}.\n$$\n\n对 Auriga-64 参数和 $p = 0.3$ 进行数值计算：\n给定 $c_{i} = 12$, $c_{s} = 80$, $c_{f} = 40$, $b = 60$ 以及 $p = 0.3$，\n$$\n\\mathbb{E}[C] = 12 \\cdot \\frac{1}{0.3} + 80 + (40 + 60) \\cdot \\frac{1-0.3}{0.3}.\n$$\n计算各项：\n$$\n12 \\cdot \\frac{1}{0.3} = 12 \\cdot \\frac{10}{3} = 40,\n$$\n$$\n(40 + 60) = 100,\n$$\n$$\n\\frac{1-0.3}{0.3} = \\frac{0.7}{0.3} = \\frac{7}{3},\n$$\n所以\n$$\n\\mathbb{E}[C] = 40 + 80 + 100 \\cdot \\frac{7}{3} = 120 + \\frac{700}{3} = \\frac{1060}{3}.\n$$\n因此，期望时钟周期数为\n$$\n\\mathbb{E}[C] = \\frac{1060}{3} \\approx 353.333\\ldots\n$$\n四舍五入到四位有效数字，结果为 $353.3$ 个时钟周期。",
            "answer": "$$\\boxed{353.3}$$"
        },
        {
            "introduction": "竞争会严重降低性能，但并非所有竞争都是由对同一数据的直接争用引起的。本问题将介绍“伪共享”（false sharing），这是一个棘手的性能问题，其中逻辑上独立的变量仅仅因为位于同一缓存行而相互干扰。通过这个练习，您将量化伪共享造成的性能损失，并评估一种常见缓解技术——数据填充——的效率。这将磨练您对软件数据布局与硬件缓存一致性协议之间关键相互作用的推理能力。",
            "id": "3645711",
            "problem": "一个对称多处理器使用修改、独占、共享、无效（MESI）缓存一致性协议。考虑一个由 $T$ 个软件线程使用的锁数组，这些线程一对一地固定在 $T$ 个不同的核心上。每个线程重复地获取和释放位于连续锁数组中唯一索引处的专用锁变量。每个锁操作都对单个锁字执行原子写入。该数组由 $N$ 个锁组成，每个锁字为 $s$ 字节。缓存行大小为 $C$ 字节。假设 $N = T$，并且锁数组在内存中连续布局，除非显式填充，否则没有间隙。所有核心以相同的稳定速率运行，每个线程的锁操作到达过程是独立的，并遵循速率为每秒 $r$ 次操作的泊松分布。\n\n在 MESI 协议下，一个核心对某个缓存行的写入会使其他核心上该行的副本失效。当映射到同一缓存行的不同锁被不同核心写入时，缓存行的所有权会来回“乒乓”，并导致伪共享（false-sharing）一致性未命中。忽略强制性未命中和容量未命中；只计算由驻留在同一缓存行上的不同锁之间的伪共享引起的额外一致性未命中。\n\n你通过对每个锁进行填充来评估一种缓解措施，使得每个锁都占据一个完整的缓存行，从而消除锁之间的伪共享。填充将总内存占用从 $N s$ 字节增加到 $N C$ 字节。\n\n给定参数 $T = N = 24$，$s = 8$ 字节，$C = 64$ 字节，以及 $r = 5.0 \\times 10^{4}$ 次操作/秒/线程，计算填充的效率。该效率定义为每秒每增加一千比字节（kibibyte）内存所避免的伪共享一致性未命中次数。一千比字节（kibibyte）是 $1024$ 字节。以 未命中数/秒/千比字节 为单位表示最终效率，并将你的答案四舍五入到四位有效数字。",
            "solution": "目标是计算填充的效率，其定义为每秒每增加一千比字节（kibibyte）内存所避免的伪共享一致性未命中次数。我们可以将这个效率 $E$ 表示为：\n$$E = \\frac{\\text{每秒避免的伪共享未命中总数}}{\\text{以千比字节为单位的额外内存占用}}$$\n\n我们将分别计算分子和分母。\n\n首先，让我们确定在原始的、未填充的配置中发生的伪共享一致性未命中的数量。每个锁填充至占据一个完整缓存行的缓解策略消除了所有锁之间的伪共享。因此，避免的未命中次数等于未填充系统中伪共享未命中的总次数。\n\n给定参数如下：\n线程/核心数，$T = 24$。\n锁的数量，$N = 24$。\n锁字大小，$s = 8$ 字节。\n缓存行大小，$C = 64$ 字节。\n每个线程的锁操作速率，$r = 5.0 \\times 10^{4}$ 次操作/秒。\n\n在未填充的配置中，多个锁可以驻留在单个缓存行上。每个缓存行的锁数量 $k$ 为：\n$$k = \\left\\lfloor \\frac{C}{s} \\right\\rfloor = \\left\\lfloor \\frac{64 \\text{ 字节}}{8 \\text{ 字节}} \\right\\rfloor = 8$$\n由于锁数组是连续的，这 $N=24$ 个锁被分成若干组，每组 $k=8$ 个锁，每组共享一个单独的缓存行。这样的组数 $N_g$ 为：\n$$N_g = \\frac{N}{k} = \\frac{24}{8} = 3$$\n这 $3$ 组锁中的每一组都由相应的 $8$ 个不同核心访问。在每个组内，这 $8$ 个核心争夺其共享缓存行的所有权。\n\n让我们分析一个这样的 $k=8$ 个核心组内的动态。组中的每个核心以速率 $r$ 对其专用锁执行原子写入。来自该组对单个共享缓存行的总写入操作速率为 $k \\times r$。当一个核心尝试写入缓存行，但由于前一次写入，另一个核心以独占（修改）状态持有该行时，就会发生伪共享一致性未命中。\n\n鉴于每个线程的锁操作到达是独立且遵循泊松分布的，我们可以确定给定的写入操作导致未命中的概率。一个核心的写入操作只有在该核心执行了对该缓存行的紧邻前一次写入时，才会是命中。由于组中所有 $k$ 个核心都具有统计上相同的写入速率 $r$，因此下一次对该行的写入来自任何特定核心的概率是 $\\frac{1}{k}$。因此，下一次写入是命中（来自刚刚写入的同一个核心）的概率是 $\\frac{1}{k}$。下一次写入是未命中（来自其他 $k-1$ 个核心之一）的概率是 $1 - \\frac{1}{k} = \\frac{k-1}{k}$。\n\n对于一个包含 $k$ 个核心的组，伪共享未命中的速率 $M_{group}$ 是该行的总写入速率乘以未命中的概率：\n$$M_{group} = (k \\times r) \\times \\left(\\frac{k-1}{k}\\right) = (k-1)r$$\n对于我们的参数，每个组的未命中率为：\n$$M_{group} = (8-1)r = 7r$$\n由于有 $N_g=3$ 个这样的独立组，整个系统的伪共享未命中总速率 $M_{total}$ 为：\n$$M_{total} = N_g \\times M_{group} = 3 \\times (7r) = 21r$$\n这个值代表了通过填充方案避免的未命中次数。代入 $r$ 的值：\n$$M_{total} = 21 \\times (5.0 \\times 10^{4} \\text{ s}^{-1}) = 105 \\times 10^{4} \\text{ s}^{-1} = 1.05 \\times 10^{6} \\text{ 未命中/秒}$$\n这是我们效率计算的分子。\n\n接下来，我们计算分母：以千比字节（kibibyte）为单位的额外内存占用。\n原始内存占用：$M_{orig} = N \\times s = 24 \\times 8 \\text{ 字节} = 192 \\text{ 字节}$。\n填充后内存占用：$M_{pad} = N \\times C = 24 \\times 64 \\text{ 字节} = 1536 \\text{ 字节}$。\n所需的额外内存 $\\Delta M_{bytes}$ 为：\n$$\\Delta M_{bytes} = M_{pad} - M_{orig} = N(C-s) = 24 \\times (64 - 8) = 24 \\times 56 = 1344 \\text{ 字节}$$\n问题要求将其表示为千比字节（KiB），其中 $1 \\text{ KiB} = 1024$ 字节。\n$$\\Delta M_{KiB} = \\frac{\\Delta M_{bytes}}{1024} = \\frac{1344}{1024} = 1.3125 \\text{ KiB}$$\n这是我们效率计算的分母。\n\n最后，我们计算效率 $E$：\n$$E = \\frac{M_{total}}{\\Delta M_{KiB}} = \\frac{1.05 \\times 10^{6} \\text{ 未命中/秒}}{1.3125 \\text{ KiB}} = 800000 \\frac{\\text{未命中}}{\\text{秒} \\cdot \\text{KiB}}$$\n按照要求，用科学记数法表示并四舍五入到四位有效数字：\n$$E = 8.000 \\times 10^{5} \\frac{\\text{未命中}}{\\text{秒} \\cdot \\text{KiB}}$$",
            "answer": "$$\\boxed{8.000 \\times 10^{5}}$$"
        },
        {
            "introduction": "在并发编程中，除了性能之外，保证正确性至关重要。本实践将探讨臭名昭著的“ABA问题”，这是一个微妙的错误，它可能破坏使用CAS等原子原语构建的无锁算法的正确性。您将探索为什么一个简单的CAS循环会以不明显的方式失败，然后推导出一种健壮解决方案——带标签的指针——的设计要求。这项练习展示了如何通过巧妙利用内存对齐等底层硬件特性，将版本信息直接嵌入指针中，从而防止这种逻辑缺陷。",
            "id": "3645713",
            "problem": "一个系统通过对栈顶指针执行原子性比较并交换（CAS）操作，实现了一个无锁的后进先出（LIFO）栈。比较并交换（CAS）操作会原子性地将一个内存位置的内容与给定的期望值进行比较，并且只有在两者相同时，才会原子性地将该位置更新为新值。为了缓解“ABA”问题——即一个线程观察到栈顶指针值为 $A$，在该线程执行CAS操作之前，该值变为 $B$，然后又变回 $A$——系统使用了带标签的指针：一个版本计数器被嵌入到栈顶指针的低位比特中，并在每次成功更新栈顶时递增。\n\n假设节点在具有 $16$ 字节对齐的 $64$ 位架构上分配，因此每个有效节点地址的最低 $4$ 个有效位都等于 $0$，这些位可以被重新用于存储版本标签。设版本标签为一个 $b$ 位计数器，在每次成功更新栈顶指针的推入或弹出操作时，该计数器以 $2^{b}$ 为模加 $1$。\n\n运行时使用基于纪元回收（EBR）的机制，该机制限制了在任何线程加载栈顶指针与其后续尝试CAS操作之间可能发生的最大栈顶更新次数。具体来说，在最坏情况下，该时间窗口内最多可能发生 $R = 12$ 次成功的栈顶更新。\n\n根据原子性CAS语义、计数器的模运算以及指针特性（有效地址的低位比特因对齐而固定为零）的定义，推导出所需的最少标签位数 $b$，以确保标签在最坏情况的时间窗口内不会回绕，从而防止未被检测到的ABA问题。您还必须确保 $b$ 不超过因对齐而保证为零的低位比特数。请以单个整数形式提供最终答案，无需单位。",
            "solution": "该问题要求确定版本标签所需的最少位数 $b$，以在无锁栈的实现中防止ABA问题。解决方案必须满足两个主要约束：标签不能在指定的操作窗口内回绕，并且用于标签的位数不能超过因内存对齐而可用的位数。\n\n首先，让我们在这种情况下将未被检测到的ABA问题形式化。一个线程读取一个栈顶指针值，该值由一个内存地址和一个版本标签组成。设初始值为 $(A, T)$，其中 $A$ 是地址，$T$ 是标签。然后，该线程在尝试进行比较并交换（CAS）操作之前执行一些工作。如果在该时间间隔内，栈顶指针变为某个其他值 $(B, T+1)$，随后又变回具有原始地址 $A$ 的值，例如 $(A, T')$，则发生了ABA问题。如果栈顶指针的最终状态与最初读取的状态完全相同，即 $(A, T') = (A, T)$，这意味着 $T' = T$，那么就发生了未被检测到的ABA问题。\n\n版本标签是一个 $b$ 位计数器，每次成功更新栈顶指针时加 $1$。这个递增是按模 $2^b$ 进行的。如果初始标签是 $T$，经过 $N$ 次成功更新后，新的标签 $T'$ 将由以下关系式给出：\n$$T' = (T + N) \\pmod{2^b}$$\n如果在 $N$ 次更新后，标签值返回其原始值 $T$，那么在地址 $A$ 上就可能发生未被检测到的ABA。这对应于条件 $T' = T$，即：\n$$(T + N) \\pmod{2^b} = T$$\n这个方程成立当且仅当 $N$ 是模数 $2^b$ 的倍数。即：\n$$N \\equiv 0 \\pmod{2^b}$$\n由于ABA情景意味着至少有一次变化，我们关心的是 $N \\ge 1$ 的情况。因此，要发生未被检测到的ABA，更新次数 $N$ 必须是 $2^b$ 的一个非零倍数。\n\n问题指出，基于纪元回收（EBR）的机制保证，在一个线程加载栈顶指针与其后续CAS尝试之间的时间窗口内，最多可以发生 $R = 12$ 次成功的栈顶更新。这意味着中间的更新次数 $N$ 的范围是 $1 \\le N \\le R = 12$。\n\n为保证ABA总是能被检测到，我们必须确保标签不能在此时间窗口内回绕到其原始值。这要求对于范围 $[1, R]$ 内任何可能的 $N$ 值，条件 $N \\equiv 0 \\pmod{2^b}$ 都不能满足。为确保这一点，$2^b$ 的最小非零倍数（即 $2^b$ 本身）必须大于 $N$ 的最大可能值。$N$ 的最大值是 $R$。因此，我们必须满足不等式：\n$$2^b  R$$\n代入给定的值 $R=12$：\n$$2^b  12$$\n我们必须找到满足此不等式的最小整数 $b$。我们可以测试 $b$ 的值：\n当 $b=1$ 时，$2^1 = 2$，不大于 $12$。\n当 $b=2$ 时，$2^2 = 4$，不大于 $12$。\n当 $b=3$ 时，$2^3 = 8$，不大于 $12$。\n当 $b=4$ 时，$2^4 = 16$，大于 $12$。\n因此，防止标签回绕所需的最少位数为 $b = 4$。\n\n接下来，我们必须根据指针所施加的物理约束来验证这一结果。系统使用 $64$ 位架构，并且节点以 $16$ 字节对齐方式进行分配。如果一个地址是 $16$ 的倍数，那么它就是 $16$ 字节对齐的。在二进制表示中，数字 $16$ 是 $10000_2$。因此，任何是 $16$ 的倍数的内存地址，其最低 $4$ 个有效位必须等于 $0$。因此，这 $4$ 个位可以被重新用于存储版本标签，而不会与地址信息冲突。\n可用位数为 $4$。我们推导出的最小要求是 $b=4$。由于 $b=4$ 不超过可用位数（$4 \\le 4$），因此该解决方案在物理上是可行的。\n\n因此，既能在最坏情况窗口内防止未被检测到的ABA，又能容纳在指针可用低位比特内的最小标签位数 $b$ 是 $4$。",
            "answer": "$$\\boxed{4}$$"
        }
    ]
}