{
    "hands_on_practices": [
        {
            "introduction": "我们首先来探讨选择不同原子操作对性能的深远影响。本练习构建了一个高强度竞争的场景，用于比较基于软件的“比较并交换”（$CAS$）循环与专用的硬件“读取并加和”（$FAA$）指令在实现并发计数器时的性能表现。通过这个分析，我们将精确地量化为何专用硬件支持对于构建可扩展的并发程序至关重要。",
            "id": "3621231",
            "problem": "一个具有 $N$ 个相同核心的多核处理器对存储在单个缓存行中的共享热点计数器进行递增操作。考虑两种设计：\n\n- 使用比较并交换（Compare-and-Swap, CAS）的循环，即每个核心重复执行读取计数器、本地计算递增后的值，并发出一个 CAS 指令，试图将旧值与递增后的值进行交换。没有退避机制；所有 $N$ 个核心都运行紧凑循环，并持续竞争同一个缓存行。\n- 硬件的取值并加（Fetch-and-Add, FAA）指令，即每个核心对计数器发出一个原子加法指令。\n\n假设有一个一致性内存系统，该系统将所有对该缓存行的原子尝试（无论最终成功或失败）进行串行化。每个到达一致性/互连队列头部的原子尝试都需要对该缓存行的独占所有权，并占用串行化点正好 $L$ 个周期，之后该行被释放。在饱和稳态下，队列中始终至少有一个待处理的原子请求。假设竞争者是对称的，本地计算时间与 $L$ 相比可以忽略不计，并且一致性仲裁是公平的。\n\n仅从原子性（在串行化点一次一个的可见性）的定义以及上述串行化和对称性假设出发，推导以下两种情况下完成的计数器递增操作的稳态吞吐量（以每周期完成的递增次数为单位）：\n\n- 在所述紧凑循环竞争下的基于 CAS 的计数器。\n- 在相同内存系统下的基于 FAA 的设计。\n\n然后，将吞吐量比率 $R$ 定义为 FAA 吞吐量除以 CAS 吞吐量，并用 $N$ 的封闭形式表达式表示 $R$。只需提供 $R$ 的最终表达式作为您的答案。无需四舍五入。",
            "solution": "问题要求计算在一个具有 $N$ 个核心的多核处理器上，使用两种不同方法递增共享计数器的吞吐量比率：一种是使用硬件的取值并加（Fetch-and-Add, FAA）指令，另一种是使用带有比较并交换（Compare-and-Swap, CAS）指令的软件循环。吞吐量定义为稳态下每周期完成的递增次数。\n\n系统模型规定，所有原子尝试（无论成功与否）都会被串行化。内存控制器处理的每次尝试都会占用串行化点 $L$ 个周期。系统处于饱和稳态，意味着总有一个待处理请求的队列，并且在 $N$ 个对称核心之间的仲裁是公平的。\n\n我们来推导每种情况下的吞吐量。\n\n**1. 取值并加（FAA）的吞吐量**\n\n取值并加（FAA）指令是一个单一的原子操作，它读取一个内存位置的值，给它加上一个值，然后将结果写回。根据其定义，一个 FAA 操作在执行时，总能成功地完成递增操作。\n\n根据问题描述，内存系统将原子尝试串行化，每次处理的尝试需要 $L$ 个周期。在基于 FAA 的设计中，每次原子尝试都是一个 FAA 指令。由于每个被串行化的 FAA 指令都能完成一次成功的递增，系统在每个 $L$ 周期的时隙内恰好执行一次递增。\n\n完成的递增速率，即吞吐量，是递增次数除以周期数。\n$$\n\\text{Throughput}_{\\text{FAA}} = \\frac{1 \\text{ increment}}{L \\text{ cycles}} = \\frac{1}{L}\n$$\n这个吞吐量与核心数 $N$ 无关，因为瓶颈在于内存系统中的单个串行化点，它一次只能服务一个请求。饱和假设保证了这个瓶颈总是处于繁忙状态。\n\n**2. 比较并交换（CAS）的吞吐量**\n\n基于 CAS 的方法涉及一个循环，其中每个核心首先读取计数器的当前值，本地计算新值，然后使用 CAS 指令尝试原子地更新计数器。一个 `CAS(address, expected_value, new_value)` 操作只有在 `address` 处的值等于 `expected_value` 时才会成功。\n\n考虑系统处于稳态，计数器持有一个值 $v$。由于“紧凑循环”和“持续竞争”的设定，所有 $N$ 个核心都会读取值 $v$ 并准备执行 `CAS(address, v, v+1)`。然后，所有 $N$ 个核心在互连队列中都会有一个待处理的 CAS 请求。\n\n公平的仲裁器将从这 $N$ 个请求中选择一个进行服务。假设选择了核心 $C_1$ 的请求。由于内存中的值仍然是 $v$，这个 CAS 将会成功。这次成功的原子尝试需要 $L$ 个周期，计数器的值被更新为 $v+1$。\n\n现在，考虑剩下的 $N-1$ 个核心。它们待处理的 CAS 尝试都基于旧的、过时的 `expected_value` $v$。当公平的仲裁器逐一服务这 $N-1$ 个请求时，每个 CAS 都会失败，因为内存中的值现在是 $v+1$，与期望值 $v$ 不匹配。根据问题描述，这些失败的原子尝试中的每一次也会占用串行化点 $L$ 个周期。\n\n因此，为了发生一次成功的递增，系统必须处理一次成功的 CAS 尝试，然后是 $N-1$ 次失败的 CAS 尝试。一次成功的递增所需的串行化尝试总数为 $1 + (N-1) = N$。\n\n完成一次递增所花费的总时间是这 $N$ 次串行化尝试的时间：\n$$\n\\text{Total time per increment} = N \\text{ attempts} \\times L \\frac{\\text{cycles}}{\\text{attempt}} = NL \\text{ cycles}\n$$\n因此，基于 CAS 的设计的吞吐量为：\n$$\n\\text{Throughput}_{\\text{CAS}} = \\frac{1 \\text{ increment}}{NL \\text{ cycles}} = \\frac{1}{NL}\n$$\n这个结果也可以从概率的角度来理解。在多个核心以相同的 `expected_value` 进行竞争的任何时刻，任何给定核心的尝试成功的概率是 $\\frac{1}{N}$。对于成功概率为 $p$ 的几何分布，获得一次成功所需的试验次数的期望值是 $\\frac{1}{p}$。在这里，“试验”是串行化的 $L$ 周期时隙，而在任何给定槽中成功的有效概率是 $\\frac{1}{N}$（一个成功结果分布在 $N$ 个竞争尝试中）。因此，每次递增所需的时隙（也就是尝试）的期望数量是 $N$，从而导致期望时间为 $NL$ 个周期。\n\n**3. 吞吐量比率 R**\n\n问题将吞吐量比率 $R$ 定义为 FAA 吞吐量除以 CAS 吞吐量。\n$$\nR = \\frac{\\text{Throughput}_{\\text{FAA}}}{\\text{Throughput}_{\\text{CAS}}}\n$$\n代入上面推导出的表达式：\n$$\nR = \\frac{\\frac{1}{L}}{\\frac{1}{NL}}\n$$\n简化表达式可得：\n$$\nR = \\frac{1}{L} \\times \\frac{NL}{1} = N\n$$\n吞吐量比率 $R$ 等于核心数 $N$。这表明，对于这种没有退避机制的高竞争模型，硬件 FAA 原语在利用内存串行化点执行此特定任务方面的效率是基于软件的 CAS 循环的 $N$ 倍。",
            "answer": "$$\n\\boxed{N}\n$$"
        },
        {
            "introduction": "在探讨了性能之后，我们转向原子操作的另一个核心议题：正确性。本练习将剖析一个经典的并发设计模式——双重检查锁定（double-checked locking）。在采用弱内存模型的现代处理器上，仅仅使用原子指令本身并不足以避免微妙的数据竞争，你将学习如何运用“释放-获取”（release-acquire）等内存排序语义，来确保共享对象被安全地“发布”，从而防止其他线程观察到部分初始化的对象状态。",
            "id": "3621227",
            "problem": "一个并发程序使用双重检查初始化模式来发布一个堆分配的单例对象。有一个共享的原子指针 $P$，指向一个结构体 $S$，该结构体有两个整数字段 $a$ 和 $b$。指针 $P$ 最初为 $\\text{null}$。目标是确保一旦任何线程观察到 $P \\neq \\text{null}$，它随后将观察到 $r \\rightarrow a = 1$ 和 $r \\rightarrow b = 2$，其中 $r = P$。\n\n线程执行以下高级逻辑：\n- 读线程中的快速路径检查：以内存顺序 $mo_R$ 读取 $P$。如果结果不是 $\\text{null}$，则从 $P$ 指向的对象中读取字段 $a$ 和 $b$。\n- 当 $P$ 为 $\\text{null}$ 时，在恰好一个线程中的慢速路径（初始化）：\n  1. 分配一个类型为 $S$ 的新对象 $t$。\n  2. 在程序顺序中使用普通（非原子）存储写入 $t \\rightarrow a \\leftarrow 1$ 和 $t \\rightarrow b \\leftarrow 2$。\n  3. 使用具有内存顺序 $mo_W$ 的原子原语将 $t$ 发布到 $P$ 中。\n\n假设一个弱序多处理器（例如，一个其硬件在没有排序约束的情况下可能重排独立内存操作的系统）。同时假设原子操作的标准 release/acquire 公理：一个具有 release 语义的存储操作可以与一个读取该存储所写值的具有 acquire 语义的加载操作建立 synchronizes-with 关系，从而创建一个 happens-before 边，使得先前的写操作在观察线程中排序于后续的读操作之前。具有宽松内存顺序的操作仅对该位置强制原子性，但本身不排序跨线程的其他内存操作。\n\n在步骤 3 和读线程中可以使用以下机制：\n- 比较并交换 (CAS)：一种原子性的读-修改-写操作，成功时写入新值并返回成功；失败时返回观察到的旧值。其成功和失败的内存顺序可以选择。\n- 链接加载/条件存储 (LL/SC)：一个原子操作对，加载一个值 (LL) 并在没有发生冲突写入的情况下有条件地存储一个新值 (SC)。\n- 测试并设置 (TAS)：一种原子原语，它写入一个值（例如，设置一个锁）并返回旧值。\n\n考虑以下关于双重检查初始化的正确性以及当 $mo$ 为宽松时在弱内存模型上可能结果的五个论断。选择所有正确的论断。\n\n选项是：\n- A\n\n- B\n\n- C\n\n- D\n\n- E",
            "solution": "本问题旨在分析在弱序多处理器上双重检查锁定（double-checked locking）模式的正确性。核心挑战是防止数据竞争，确保当一个读线程看到已发布的非空指针时，它也能看到被指向对象的完全初始化状态。\n\n在弱内存模型中，为了保证正确性，必须在初始化对象字段的写操作与另一个线程读取这些字段的操作之间建立一个 $\\text{happens-before}$（先于发生）关系。这通常通过对共享指针 `$P$` 的成对原子操作来实现：初始化线程使用 `release` 语义的写操作，而读线程使用 `acquire` 语义的读操作。\n\n**A. 使用比较并交换 (CAS) 将 $t$ 发布到 $P$ 中，其中成功的 CAS 对 $mo_W$ 具有 release 语义，并且让读线程通过以 acquire 语义加载 $P$ 来执行快速路径检查，这保证了任何观察到 $P \\neq \\text{null}$ 的读线程随后都会观察到 $r \\rightarrow a = 1$ 和 $r \\rightarrow b = 2$。**\n\n- **分析：** 这是实现双重检查锁定的标准正确方法。写线程中对字段 `$a$` 和 `$b$` 的初始化，$\\text{happens-before}$ 具有 `release` 语义的 $\\text{CAS}$ 操作。读线程中具有 `acquire` 语义的加载操作，如果它读到了 $\\text{CAS}$ 写入的值，那么它将与该 $\\text{CAS}$ 操作 $\\text{synchronizes-with}$（同步于）。这就在字段的写入和读取之间建立了必要的 $\\text{happens-before}$ 关系，从而保证了可见性。\n- **结论：** **正确**。\n\n**B. 如果步骤 3 中的发布操作和读线程的快速路径加载都使用宽松内存顺序（即 $mo_W = \\text{relaxed}$ 和 $mo_R = \\text{relaxed}$），那么在弱序架构上，读线程有可能在观察到 $P \\neq \\text{null}$ 的同时仍然读到 $r \\rightarrow a = 0$ 和 $r \\rightarrow b = 0$。**\n\n- **分析：** `relaxed` 内存顺序只保证对指针 `$P$` 本身操作的原子性，不提供任何跨线程的排序保证。因此，处理器或编译器可能会将对 `$P$` 的写操作重排到对字段 `$a$` 和 `$b$` 的写操作之前。即使没有重排，内存更新的传播也可能乱序。结果是，读线程可能看到已更新的指针 `$P$`，但读到尚未初始化的字段值。\n- **结论：** **正确**。\n\n**C. 用链接加载/条件存储 (LL/SC) 对替换 CAS 来将 $t$ 发布到 $P$ 中，不使用任何显式内存屏障，并且读线程仍然使用对 $P$ 的宽松加载，这足以保证一旦观察到 $P \\neq \\text{null}$，随后的读取将看到 $r \\rightarrow a = 1$ 和 $r \\rightarrow b = 2$。**\n\n- **分析：** 即使一个成功的条件存储（$\\text{SC}$）操作具有隐式的 `release` 语义，它也必须与一个具有 `acquire` 语义的加载操作配对才能建立同步。由于读线程使用的是 `relaxed` 加载，$\\text{happens-before}$ 关系没有建立起来，因此仍然存在数据竞争的风险。\n- **结论：** **不正确**。\n\n**D. 使用以测试并设置 (TAS) 实现的自旋锁来保护初始化，该锁提供互斥但加锁时没有 acquire 语义，解锁时没有 release 语义，而读线程在快速路径上仍然使用对 $P$ 的宽松加载，这足以防止任何读线程在 $P$ 变为非 $\\text{null}$ 后观察到部分初始化的对象。**\n\n- **分析：** 锁确实能保证只有一个线程执行初始化代码（互斥）。然而，如果锁的解锁操作没有 `release` 语义，那么在临界区内的写操作（对字段和指针的写入）就不保证对临界区外的其他线程可见。读线程不与锁交互，并且使用 `relaxed` 加载，因此它与写线程之间没有任何同步。\n- **结论：** **不正确**。\n\n**E. 使用显式内存屏障代替 release/acquire 原子操作如下是足够的：初始化线程在一个发布 $t$ 到 $P$ 的宽松存储之前立即执行一个 release 屏障，任何发现 $P \\neq \\text{null}$ 的读线程在宽松加载 $P$ 之后、读取 $r \\rightarrow a$ 和 $r \\rightarrow b$ 之前立即执行一个 acquire 屏障。**\n\n- **分析：** 这是另一种实现所需排序的有效方法。在写线程中，`release` 屏障确保其之前的所有写操作（字段初始化）在对 `$P$` 的 `relaxed` 存储操作之前完成并对其他线程可见。在读线程中，`acquire` 屏障确保在读取字段之前，对 `$P$` 的 `relaxed` 加载操作已经完成，并且可以看到由 `release` 屏障同步的写操作。这种屏障与原子操作的组合同样可以建立 `synchronizes-with` 关系。\n- **结论：** **正确**。",
            "answer": "$$\\boxed{ABE}$$"
        },
        {
            "introduction": "最后的练习将带你深入了解无锁编程中最臭名昭著的陷阱之一：ABA问题。这个问题首先要求你展示这个微妙的错误如何破坏一个无锁栈的正确性，然后引导你设计一个使用“标签指针”的稳健解决方案。通过计算所需标签位的最小数量，你将把一个概念上的风险，与一个具体的、可量化的工程解决方案联系起来。",
            "id": "3621915",
            "problem": "一个无锁的后进先出 (LIFO) 空闲列表被实现为一个单向链式栈，其栈顶通过原子比较并交换 (CAS) 指令进行更新。比较并交换 (CAS) 指令接受三个参数：一个地址、一个期望值和一个新值；它原子地将该地址的当前内容与期望值进行比较，并且只有在它们按位相等时，才写入新值，并返回操作是否成功。在基本设计中，栈顶是一个指向栈顶节点的单字长指针。考虑两个线程，每个线程执行入栈或出栈操作，所有更新都在 CAS 操作成功时线性化。\n\nA部分。请通过指定一种可能的交错执行，说明经典的 ABA 异常如何在没有任何标签或版本控制的空闲列表中发生。在这种交错执行中，一个线程读取栈顶指针为标记为 $A$ 的节点，另一个线程将 $A$ 出栈，执行一系列的入栈和出栈操作，并最终将栈顶指针恢复为 $A$，导致第一个线程过期的 CAS 操作成功，尽管逻辑栈已经发生了改变。\n\n为缓解 ABA 问题，栈顶指针被增强为一个值对 $\\left(p, t\\right)$，并被压缩到单个机器字中，其中 $p$ 是指针，$t$ 是一个 $b$ 位的标签。每当栈顶更新成功时，实现会将 $t$ 的值加 1（模 $2^{b}$），并使用对该压缩字的单次 CAS 操作写入新的值对。任何线程执行的 CAS 操作都会将 $p$ 和 $t$ 与其先前读取的过期值对进行比较。\n\nB部分。假设对于任何线程，在其读取 $\\left(p, t\\right)$ 的时刻到其执行 CAS 的时刻之间，所有线程总共最多可以有 $n$ 次成功的栈顶更新。请从第一性原理出发，推导最小标签宽度 $b$ 作为 $n$ 的函数。该宽度需保证在上述时间窗口内，即使指针 $p$ 被重用，任何过期的值对 $\\left(p, t\\right)$ 也不会与当前的栈顶值对再次匹配，从而避免因标签回绕导致过期的 CAS 操作成功。请将你的最终答案表示为关于 $n$ 的单个闭式解析表达式。不要假设任何特定的数据字长，并将 $n$ 视作任意正整数。最终答案必须是一个不带单位的表达式。",
            "solution": "我们从比较并交换 (CAS) 的操作定义开始：对一个地址执行 CAS 操作，会原子地将当前值与一个期望值进行比较，并且当且仅当它们按位相等时，才写入一个新值。在一个实现为栈的无锁空闲列表中，入栈和出栈操作都使用 CAS 来更新栈顶指针。线性化要求操作的逻辑效果在其 CAS 成功的那一刻发生。\n\nA部分要求展示 ABA 异常。考虑栈顶最初指向标记为 $A$ 的节点。一个典型的交错执行如下：\n- 线程 $T_{1}$ 读取栈顶指针并观察到 $A$。它基于此观察计算出新的栈顶，但在执行其 CAS 操作前被延迟。\n- 线程 $T_{2}$ 从栈中弹出 $A$。此时栈顶指向某个其他节点，比如 $B$，或者如果栈的大小为 1，则变为 $\\text{null}$。\n- 线程 $T_{2}$ 继续按某种顺序入栈和出栈其他节点。特别是，它可能将 $A$ 重新推入栈顶，从而将栈顶指针恢复为 $A$。\n- 线程 $T_{1}$ 恢复执行并执行其 CAS 操作，该操作只比较指针值。因为栈顶指针再次变为 $A$，CAS 看到了期望的指针并成功执行，尽管在 $T_{1}$ 读取和执行 CAS 之间，栈的逻辑内容已经发生了任意改变。这就是 ABA 异常：观察到的值从 $A$ 变为某个 $X$ 再变回 $A$，掩盖了期间的变更。\n\nB部分通过增加一个版本标签来增强栈顶，以区分同一指针值的不同“实例”。栈顶是一个值对 $\\left(p, t\\right)$，其中 $t$ 是一个 $b$ 位的计数器，每次栈顶成功更新时，其值会加 1（模 $2^{b}$）。现在，一个线程执行的 CAS 操作会将其先前读取的值对与当前的 $p$ 和 $t$ 进行比较。目标是选择合适的 $b$，以保证在一个线程读取 $\\left(p, t\\right)$ 后尝试执行 CAS 的时间窗口内，即使指针 $p$ 被重用，标签也不会因为回绕而回到原来的值，从而导致一个过期的 CAS 由于指针重用而成功。\n\n我们将此要求形式化：假设一个线程在时刻 $\\tau$ 读取到栈顶为 $\\left(p_{0}, t_{0}\\right)$。在 $\\tau$ 与该线程在时刻 $\\tau'$ 执行 CAS 之间，假设所有线程共进行了 $k$ 次成功的栈顶更新，其中 $k$ 满足 $1 \\leq k \\leq n$。每次成功的更新都会将标签加 1（模 $2^{b}$）。因此，在时刻 $\\tau'$，与栈顶关联的当前标签值为\n$$\nt' \\equiv t_{0} + k \\pmod{2^{b}}\n$$\n为防止因标签回绕导致过期的 CAS 成功，我们必须确保在 $1 \\leq k \\leq n$ 范围内的任何 $k$ 都不会导致 $t' = t_{0}$ 模 $2^{b}$。也就是说，我们需要满足\n$$\n\\forall k \\in \\{1, 2, \\dots, n\\}, \\quad k \\not\\equiv 0 \\pmod{2^{b}}\n$$\n这等价于要求模数 $2^{b}$ 超过窗口内可能的最大增量次数，从而保证 $2^{b}$ 的任何倍数都不在集合 $\\{1, \\dots, n\\}$ 中。此条件为\n$$\n2^{b} > n\n$$\n满足此严格不等式的最小整数 $b$ 可以通过对 $n+1$ 取以 2 为底的对数并使用向上取整函数得到：\n$$\nb = \\left\\lceil \\log_{2}\\!\\left(n+1\\right) \\right\\rceil\n$$\n为了验证其最小性，假设 $b' = \\left\\lceil \\log_{2}\\!\\left(n+1\\right) \\right\\rceil - 1$。那么 $2^{b'} \\leq n$，因此存在某个 $k = 2^{b'}$，满足 $1 \\leq k \\leq n$ 且 $k \\equiv 0 \\pmod{2^{b'}}$，这意味着标签可能回绕到相同的值。因此，任何更小的 $b$ 都无法保证在时间窗口内标签不被重用。故所推导的表达式是充分且必要的。\n\n该推导仅依赖于 CAS 的原子性定义、每次成功更新栈顶时标签加一的更新规则，以及基本的模运算。它确保了即使指针 $p$ 再次出现（例如，由于内存重用），在最多 $n$ 次更新的任何窗口内，标签部分也会不同，从而防止过期的 CAS 在相同的 $\\left(p, t\\right)$ 值对上成功。",
            "answer": "$$\\boxed{\\left\\lceil \\log_{2}\\!\\left(n+1\\right) \\right\\rceil}$$"
        }
    ]
}