{
    "hands_on_practices": [
        {
            "introduction": "从用户模式转换到特权模式并非没有代价。这个练习将帮助你建立一个量化模型，来计算系统调用所涉及的开销，其中会考虑流水线管理、状态保存和缓存性能等因素。通过这个练习，你将对跨越用户/内核边界的性能影响有一个基础的理解。",
            "id": "3669149",
            "problem": "一个精简指令集计算机 (RISC) 处理器使用一个五级流水线，其阶段包括指令获取 (IF)、指令解码 (ID)、执行 (EX)、内存访问 (MEM) 和写回 (WB)。该处理器支持用户模式和特权监督模式，通过处理器状态寄存器 (PSR) 中的一个模式位进行切换。来自用户模式的系统调用会触发一个陷入 (trap) 进入监督模式，这会排空流水线，分派给一个陷阱处理程序，并在执行特权指令前执行设置。该架构使用类似于可扩展处理器架构 (SPARC) 的寄存器窗口，其中陷入监督模式会尝试切换到监督者窗口；如果寄存器窗口用尽，陷阱处理程序会执行一次寄存器窗口溢出 (spill) 操作到内存。返回用户模式时，流水线被重新填充，用户可见的架构状态被恢复。\n\n使用以下场景和基本事实，为从用户模式到监督模式再返回的单次系统调用转换的总周期成本建模。总周期成本定义为保存所需状态、执行陷阱、进入监督模式以及返回用户模式的周期成本之和。您必须计算此总和并提供一个单一的数值答案。\n\n基本基础和场景：\n- 从用户模式到监督模式的陷阱通过停止获取并允许正在执行的指令完成来排空流水线。在一个有 $p$ 级流水线中，排空成本为 $p$ 个周期，稍后重新填充的成本也为 $p$ 个周期。\n- 陷阱向量分派在排空后执行，由于陷阱路由和权限检查，需要固定数量的周期。\n- 监督者进入序列会执行少量特权设置指令，并可能因控制冒险而引入气泡 (bubbles)。\n- 陷阱处理程序保存特殊寄存器并在需要时执行寄存器窗口溢出；保存和溢出操作通过对一级 (L1) 数据缓存的存储指令实现。\n- 返回用户模式时，处理程序恢复特殊寄存器并通过加载指令执行寄存器窗口填充；切换回用户模式后，流水线被重新填充。\n\n给定参数：\n- 流水线有 $p = 5$ 级。\n- 陷阱向量分派成本 $C_{\\text{vector}} = 12$ 个周期。\n- 陷阱处理程序保存 $n_{s} = 6$ 个特殊寄存器：程序计数器 (PC)、下一程序计数器 (nPC)、处理器状态寄存器 (PSR)、窗口无效掩码 (WIM)、陷阱基址寄存器 (TBR) 和用户堆栈指针 (USP)。\n- 进入时发生寄存器窗口溢出，溢出 $n_{w} = 16$ 个寄存器，由于溢出控制序列，有固定的溢出开销 $o_{s} = 4$ 个周期。\n- 每次存储到 L1 数据缓存的平均周期数由 $c_{s} = h_{s} \\cdot 1 + (1 - h_{s}) \\cdot m_{s}$ 建模，其中命中率 $h_{s} = 0.75$，未命中惩罚 $m_{s} = 8$ 个周期。\n- 监督者进入时执行 $n_{e} = 5$ 条设置指令（例如，切换 PSR 模式位、加载内核堆栈指针），由于控制冒险产生 $b = 2$ 个气泡周期。\n- 返回时，处理程序恢复 $n_{r} = 3$ 个特殊寄存器 ($PC$, $nPC$, $PSR$) 并执行 $n_{w} = 16$ 个寄存器的寄存器窗口填充，有固定的填充开销 $o_{f} = 4$ 个周期。\n- 每次从 L1 数据缓存加载的平均周期数由 $c_{\\ell} = h_{\\ell} \\cdot 1 + (1 - h_{\\ell}) \\cdot m_{\\ell}$ 建模，其中命中率 $h_{\\ell} = 0.80$，未命中惩罚 $m_{\\ell} = 10$ 个周期。\n\n计算此系统调用的总周期成本 $C$，汇总以下组成部分：\n- 陷阱处理成本（流水线排空加陷阱向量分派）。\n- 进入时的状态保存成本（保存特殊寄存器并执行寄存器窗口溢出）。\n- 监督者进入序列成本。\n- 返回用户模式成本（流水线重新填充加恢复特殊寄存器并执行寄存器窗口填充）。\n\n将您的最终答案表示为单个实值周期数。将您的答案四舍五入到四位有效数字。最终方框内的值不需要单位。",
            "solution": "该问题要求计算系统调用转换的总周期成本 $C$。总成本是四个不同组成部分的总和：陷阱处理成本、状态保存成本、监督者进入序列成本和返回用户模式成本。我们将根据提供的参数系统地计算每个组成部分。\n\n总成本 $C$ 由以下总和给出：\n$$C = C_{\\text{trap\\_entry}} + C_{\\text{save}} + C_{\\text{supervisor\\_entry}} + C_{\\text{return}}$$\n\n我们首先计算每一项。\n\n1.  **陷阱处理成本 ($C_{\\text{trap\\_entry}}$)**\n    该成本包括流水线排空和陷阱向量分派。流水线有 $p = 5$ 级，因此排空成本为 $p = 5$ 个周期。陷阱向量分派成本给定为 $C_{\\text{vector}} = 12$ 个周期。\n    $$C_{\\text{trap\\_entry}} = p + C_{\\text{vector}} = 5 + 12 = 17 \\text{ 周期}$$\n\n2.  **进入时的状态保存成本 ($C_{\\text{save}}$)**\n    该成本包括保存特殊寄存器和执行寄存器窗口溢出。这两个操作都涉及对一级 (L1) 数据缓存的存储操作。首先，我们必须计算每次存储的平均周期数 $c_s$。\n    $c_s$ 的公式由 $c_{s} = h_{s} \\cdot 1 + (1 - h_{s}) \\cdot m_{s}$ 给出，其中存储命中率 $h_{s} = 0.75$，未命中惩罚 $m_{s} = 8$ 个周期。\n    $$c_{s} = (0.75 \\cdot 1) + (1 - 0.75) \\cdot 8 = 0.75 + (0.25 \\cdot 8) = 0.75 + 2 = 2.75 \\text{ 周期/存储}$$\n    需要保存的寄存器总数是特殊寄存器数 $n_s = 6$ 和窗口溢出寄存器数 $n_w = 16$ 的总和。溢出操作还有一个固定的开销 $o_s = 4$ 个周期。\n    $$C_{\\text{save}} = (n_s + n_w) \\cdot c_s + o_s = (6 + 16) \\cdot 2.75 + 4 = 22 \\cdot 2.75 + 4$$\n    $$C_{\\text{save}} = 60.5 + 4 = 64.5 \\text{ 周期}$$\n\n3.  **监督者进入序列成本 ($C_{\\text{supervisor\\_entry}}$)**\n    这是执行 $n_e = 5$ 条设置指令的成本，这些指令因控制冒险而产生 $b = 2$ 个气泡周期。该成本是指令周期数（假设在稳态下每条指令一个周期，因为流水线填充/排空效应已在别处核算）和气泡周期数的总和。\n    $$C_{\\text{supervisor\\_entry}} = n_e + b = 5 + 2 = 7 \\text{ 周期}$$\n\n4.  **返回用户模式成本 ($C_{\\text{return}}$)**\n    该成本由流水线重新填充、恢复特殊寄存器和执行寄存器窗口填充组成。流水线重新填充成本等于流水线级数，即 $p = 5$ 个周期。寄存器操作涉及从 L1 数据缓存中加载。首先，我们计算每次加载的平均周期数 $c_{\\ell}$。\n    $c_{\\ell}$ 的公式由 $c_{\\ell} = h_{\\ell} \\cdot 1 + (1 - h_{\\ell}) \\cdot m_{\\ell}$ 给出，其中加载命中率 $h_{\\ell} = 0.80$，未命中惩罚 $m_{\\ell} = 10$ 个周期。\n    $$c_{\\ell} = (0.80 \\cdot 1) + (1 - 0.80) \\cdot 10 = 0.80 + (0.20 \\cdot 10) = 0.80 + 2 = 2.80 \\text{ 周期/加载}$$\n    需要恢复的特殊寄存器数量为 $n_r = 3$，窗口填充的寄存器数量为 $n_w = 16$。填充操作产生一个固定的开销 $o_f = 4$ 个周期。\n    $$C_{\\text{return}} = p + (n_r + n_w) \\cdot c_{\\ell} + o_f = 5 + (3 + 16) \\cdot 2.80 + 4$$\n    $$C_{\\text{return}} = 9 + 19 \\cdot 2.80 = 9 + 53.2 = 62.2 \\text{ 周期}$$\n\n最后，我们将这四个组成部分相加，得到总周期成本 $C$。\n$$C = C_{\\text{trap\\_entry}} + C_{\\text{save}} + C_{\\text{supervisor\\_entry}} + C_{\\text{return}}$$\n$$C = 17 + 64.5 + 7 + 62.2$$\n$$C = 150.7$$\n问题要求答案四舍五入到四位有效数字。计算出的值 $150.7$ 已经有四位有效数字，因此无需进一步四舍五入。",
            "answer": "$$\\boxed{150.7}$$"
        },
        {
            "introduction": "在理解了陷入（trap）的基本开销之后，我们将这个概念应用于一个常见且重要的操作系统机制：写时复制（Copy-on-Write）。在这个练习中，你将计算处理一个写时复制错误的端到端延迟，这需要结合处理器周期成本和内存带宽限制。这个实践展示了架构特性如何直接影响高级操作系统服务的性能。",
            "id": "3669132",
            "problem": "在单处理器系统上，一个用户模式线程写入一个当前以写时复制（COW）方式共享的内存页面。在写入时，处理器检测到保护冲突，并引发一个同步陷阱，进入以监管者模式运行的操作系统。内核通过以下步骤解决此COW错误：分配一个新的物理页面，将旧页面的内容复制到新页面中，更新页表以指向具有写入权限的新页面，使转换后备缓冲区（TLB; Translation Lookaside Buffer）无效，然后返回用户模式。假设如下：\n\n- 处理器频率为 $f = 3.2 \\times 10^{9}\\,\\text{Hz}$。\n- 页面大小为 $P = 4\\,\\text{KiB}$。\n- 在此错误期间，内核复制例程可用的有效持续内存带宽为 $B = 12 \\times 2^{30}\\,\\text{bytes}/\\text{s}$。\n- 陷阱进入和返回序列，包括保存和恢复状态以及最少的调度器工作，在此工作负载上总共消耗 $1520$ 个周期。\n- 页面分配器的元数据工作（锁获取、空闲列表操作和记账），不包括实际的数据复制，消耗 $840$ 个周期。\n- 页表更新和本地TLB失效序列（无处理器间击落）消耗 $680$ 个周期。\n- 所有阶段严格按顺序发生，没有重叠。\n- 忽略超出所提供周期和带宽参数所反映的缓存预热效应。\n\n仅从以下定义出发：(i) 陷阱是从用户模式到监管者模式的受控转移，其相关的状态保存/恢复成本以周期为单位度量；(ii) 每个周期的时间是 $1/f$；(iii) 在持续带宽 $B$ 下，大小为 $P$ 的页面的批量复制时间是 $P/B$。请确定处理此单个COW写入错误的总端到端延迟，从发生错误的指令陷阱瞬间到映射更新后控制权返回用户模式的瞬间。\n\n请以微秒表示您的最终数值答案，并四舍五入到四位有效数字。",
            "solution": "处理写时复制错误的总端到端延迟 $T_{total}$ 是问题中所述的各个顺序阶段延迟的总和。该过程可以分解为两种类型的成本：以处理器周期计量的成本和批量数据传输的成本。\n\n总延迟由以下公式给出：\n$$T_{total} = T_{overhead} + T_{copy}$$\n其中，$T_{overhead}$ 是花在处理器密集型任务（陷阱处理、页面分配和页表更新）上的时间，而 $T_{copy}$ 是花在内存密集型的页面复制操作上的时间。\n\n首先，我们计算处理器密集型任务的总周期数 $C_{overhead}$。这是每个指定阶段的周期数之和：\n$$C_{overhead} = C_{trap} + C_{alloc} + C_{update}$$\n代入给定值：\n$$C_{overhead} = 1520 + 840 + 680 = 3040\\,\\text{cycles}$$\n\n一个处理器周期的时间是处理器频率的倒数，即 $T_{cycle} = 1/f$。因此，开销任务的总时间为：\n$$T_{overhead} = \\frac{C_{overhead}}{f}$$\n代入 $C_{overhead}$ 和 $f$ 的值：\n$$T_{overhead} = \\frac{3040}{3.2 \\times 10^9\\,\\text{Hz}}$$\n\n接下来，我们计算复制页面数据所需的时间 $T_{copy}$。该时间由页面大小 $P$ 除以有效内存带宽 $B$ 给出：\n$$T_{copy} = \\frac{P}{B}$$\n\n在代入数值之前，我们必须确保单位一致。页面大小为 $P = 4\\,\\text{KiB}$。一个千位二进制字节（KiB）是 $2^{10}$ 字节。\n$$P = 4 \\times 2^{10}\\,\\text{bytes}$$\n内存带宽给定为 $B = 12 \\times 2^{30}\\,\\text{bytes/s}$。\n将这些值代入 $T_{copy}$ 的表达式中：\n$$T_{copy} = \\frac{4 \\times 2^{10}\\,\\text{bytes}}{12 \\times 2^{30}\\,\\text{bytes/s}} = \\frac{4}{12} \\times \\frac{2^{10}}{2^{30}}\\,\\text{s} = \\frac{1}{3} \\times 2^{-20}\\,\\text{s}$$\n\n现在我们可以通过将两个分量相加来计算总延迟 $T_{total}$：\n$$T_{total} = T_{overhead} + T_{copy} = \\frac{3040}{3.2 \\times 10^9}\\,\\text{s} + \\frac{1}{3} \\times 2^{-20}\\,\\text{s}$$\n\n我们现在计算每一项的数值。\n对于开销时间：\n$$T_{overhead} = \\frac{3040}{3.2 \\times 10^9} = \\frac{3.04 \\times 10^3}{3.2 \\times 10^9} = 0.95 \\times 10^{-6}\\,\\text{s}$$\n\n对于复制时间：\n$2^{20} = (2^{10})^2 = 1024^2 = 1048576$。\n$$T_{copy} = \\frac{1}{3 \\times 1048576} = \\frac{1}{3145728} \\approx 0.31789145 \\times 10^{-6}\\,\\text{s}$$\n\n将两个时间分量相加：\n$$T_{total} = (0.95 \\times 10^{-6} + 0.31789145 \\times 10^{-6})\\,\\text{s}$$\n$$T_{total} = (0.95 + 0.31789145) \\times 10^{-6}\\,\\text{s}$$\n$$T_{total} \\approx 1.26789145 \\times 10^{-6}\\,\\text{s}$$\n\n问题要求最终答案以微秒（$\\mu\\text{s}$）表示，其中 $1\\,\\mu\\text{s} = 10^{-6}\\,\\text{s}$。\n$$T_{total} \\approx 1.26789145\\,\\mu\\text{s}$$\n\n最后，我们将结果四舍五入到四位有效数字。前四位有效数字是 $1.267$。第五位数字是 $8$，所以我们将第四位数字向上取整。\n$$T_{total} \\approx 1.268\\,\\mu\\text{s}$$",
            "answer": "$$\\boxed{1.268}$$"
        },
        {
            "introduction": "最后的这个练习将重点从性能转向安全，这也是特权级别分离的主要原因。你将分析一个假设的攻击场景，并识别出防止用户程序破坏内核的多层硬件防御机制，包括隔离的陷入处理、影子堆栈和内存保护。这个练习凸显了体系结构设计在构建安全、稳健系统中的关键作用。",
            "id": "3669128",
            "problem": "一个架构提供了两种特权级别，用户模式 ($U$) 和监管者模式 ($S$)，并强制执行以下经过充分测试和广泛使用的机制：\n\n- 当从 $U$ 模式到 $S$ 模式发生系统调用陷阱时（例如通过像 $ECALL$ 这样的指令），中央处理器（CPU）会将当前的用户程序计数器（$PC$）保存到一个特权异常寄存器（$EPC$）中，将当前的栈指针（$SP$）从用户栈指针 $SP_u$ 切换到一个存储在特权控制寄存器中的特权内核栈指针 $SP_k$，将特权状态更新为 $S$，并将一个陷阱帧推入由 $SP_k$ 指向的内核栈。\n- 从陷阱返回时，操作系统（OS）执行一条特权返回指令（例如 $SRET$），该指令从 $EPC$ 恢复 $PC$ 并将 $SP$ 恢复为 $SP_u$，以便在 $U$ 模式下，在原始 $ECALL$ 指令之后的指令处恢复执行。\n- 虚拟内存系统使用带有用户/监管者位的页表项（PTE）。在 $U$ 模式下，只有标记为用户可访问的页面才允许进行指令获取、加载和存储。内核代码和数据页被标记为仅监管者可访问，因此在 $U$ 模式下从仅监管者可访问的页面获取指令会触发保护错误。\n- 调用约定使用硬件管理的影子栈。对于每个 $CALL$ 指令，硬件将返回地址推入一个内部影子栈（SS），其指针（$SSP$）软件不能直接访问。对于每个 $RET$ 指令，硬件会将常规栈上的返回地址与 SS 顶部的条目进行比较，如果不同则引发异常，从而防止控制流劫持。只有在成功匹配时，CPU 才会从 SS 弹出并转移控制。\n\n一个开发者构建了以下用户模式测试工具，意图通过操纵返回地址来提升权限：\n\n- 在 $U$ 模式下，一个函数 $foo$ 在用户栈上的某个用户虚拟地址 $A_u$ 处分配了一个大小为 $N = 64$ 字节的局部缓冲区。一个漏洞允许将 $N + 16 = 80$ 字节复制到这个缓冲区中，从而覆盖了 $foo$ 在用户栈上的激活记录中保存的返回地址。\n- 该测试工具用地址 $A_k = 0xFFFF000000100000$ 覆盖了保存的返回地址，已知该地址位于一个映射为只读且仅监管者可访问的内核代码页内。假设内核代码占据范围 $[A_k, A_k + 0x1000)$ 并且在 PTE 中未被映射为用户可访问。\n- 在破坏保存的返回地址后， $foo$ 立即发出一个 $ECALL$ 来调用一个系统服务。内核处理程序在 $S$ 模式下执行一些代码，并使用 $SRET$ 返回到 $U$ 模式。\n- 返回到 $U$ 模式后，$foo$ 中的执行继续到其函数尾声，在那里它会执行一个 $RET$ 指令以从 $foo$ 返回。\n\n在所描述的架构中，选择所有正确解释为什么此测试工具未能将控制转移到 $A_k$（即，为什么它未能在任何特权级别执行 $A_k$ 处的代码）的陈述。\n\nA. 伪造的用户模式下保存的返回地址无法影响在 $S$ 模式下的控制流，因为在 $ECALL$ 时，CPU 会切换到 $SP_k$，将 $PC$ 保存到 $EPC$ 中，并且内核使用 $EPC$ 通过 $SRET$ 返回；在陷阱处理期间，内核从不查阅用户栈以获取控制数据。\n\nB. 当 $U$ 模式下的 $RET$ 试图使用伪造的返回地址 $A_k$ 时，硬件管理的影子栈会检测到栈上的返回地址与受保护的 SS 条目不匹配，并在任何控制转移之前引发异常，从而在 $U$ 模式下阻止该漏洞利用。\n\nC. 即使没有影子栈，从 $U$ 模式试图将控制转移到 $A_k$ 也会失败，因为从 $A_k$ 获取指令会违反 PTE 上的用户/监管者权限检查，触发保护错误，并阻止在 $U$ 模式下执行仅监管者可访问的代码。\n\nD. 如果攻击者在 $ECALL$ 之前将 $A_k$ 放置在内核栈上，则此漏洞利用会成功；从系统调用返回后，内核会从其自己的栈中弹出 $A_k$ 并在 $S$ 模式下跳转到它。\n\n以字母形式提供您的选择。",
            "solution": "该问题描述了一次在一个假设但现实的处理器架构上，试图将权限从用户模式（$U$）提升到监管者模式（$S$）的尝试。该攻击涉及一个经典的基于栈的缓冲区溢出，以覆盖一个函数的返回地址。我们将分析事件序列和架构特性，以确定攻击失败的原因。\n\n事件序列如下：\n1.  在用户模式（$U$）下，函数 `foo` 正在执行。用户栈上的一个缓冲区溢出覆盖了为 `foo` 保存的返回地址。原始的、正确的返回地址被一个伪造的地址 $A_k = 0xFFFF000000100000$ 替换，该地址指向一个仅监管者可访问的内核代码页内的位置。\n2.  至关重要的是，该架构具有硬件管理的影子栈（SS）。当 `foo` 最初被调用时，正确的返回地址被推入了这个受保护的 SS。这个 SS 不受用户栈上缓冲区溢出的影响。\n3.  在栈被破坏后，`foo` 执行一个 `ECALL` 指令，陷入内核。\n4.  CPU 通过切换到监管者模式（$S$），将用户模式的程序计数器（$PC_{user}$）保存到异常程序计数器寄存器（$EPC$）中，并将栈指针从用户栈指针（$SP_u$）切换到内核栈指针（$SP_k$）来处理该陷阱。控制权被转移给内核的系统调用处理程序。\n5.  内核在 $S$ 模式下使用内核栈执行其服务例程。被破坏的用户栈不用于内核控制流。\n6.  为了返回用户模式，内核执行一条特权 `SRET` 指令。该指令从 `EPC` 中存储的值恢复 $PC$，并将特权级别切换回 $U$。执行在 `foo` 中紧随 `ECALL` 之后的指令处恢复。\n7.  函数 `foo` 继续执行直到其函数尾声，在那里它执行一条 `RET` 指令以返回其调用者。\n8.  `RET` 指令试图转移控制权。它从用户栈中弹出伪造的地址 $A_k$。然后，硬件将此地址与存储在影子栈上的合法返回地址进行比较。\n\n现在，我们将根据此序列和架构规则评估每个陈述。\n\nA. **伪造的用户模式下保存的返回地址无法影响在 $S$ 模式下的控制流，因为在 $ECALL$ 时，CPU 会切换到 $SP_k$，将 $PC$ 保存到 $EPC$ 中，并且内核使用 $EPC$ 通过 $SRET$ 返回；在陷阱处理期间，内核从不查阅用户栈以获取控制数据。**\n\n这个陈述准确地描述了陷阱处理机制。从 $U$ 到 $S$ 通过 `ECALL` 的转换以及从 $S$ 到 $U$ 通过 `SRET` 的返回，形成了一个安全且隔离的路径。异常的控制流返回路径是通过专用的 `EPC` 寄存器管理的，而不是通过用户栈上的任何数据。内核在其自己的私有栈（$SP_k$）上操作。因此，用户栈上返回地址的损坏对 CPU 处于监管者模式时或在从系统调用立即返回期间的执行流没有影响。这是一个关键的安全特性，可防止该漏洞利用在系统调用期间直接劫持内核。这个陈述正确地指出了整体攻击策略失败的一个原因。\n\n**结论：正确。**\n\nB. **当 $U$ 模式下的 $RET$ 试图使用伪造的返回地址 $A_k$ 时，硬件管理的影子栈会检测到栈上的返回地址与受保护的 SS 条目不匹配，并在任何控制转移之前引发异常，从而在 $U$ 模式下阻止该漏洞利用。**\n\n这个陈述描述了当 `foo` 试图返回其调用者时发生的事件。在 `SRET` 将控制权返回给 `foo` 之后，该函数最终会执行一条 `RET` 指令。根据问题描述，硬件在执行 `RET` 时会执行两个操作：它从常规栈中读取返回地址（即伪造的地址 $A_k$），并将其与从影子栈弹出的返回地址（即原始的、合法的地址）进行比较。由于缓冲区溢出只修改了用户栈，这两个地址将不匹配。架构规定，在不匹配的情况下，会引发一个异常。这种硬件检查，一种控制流完整性（CFI）的形式，直接阻止了使用被破坏的返回地址来劫持控制流。跳转到 $A_k$ 的尝试从未发生。\n\n**结论：正确。**\n\nC. **即使没有影子栈，从 $U$ 模式试图将控制转移到 $A_k$ 也会失败，因为从 $A_k$ 获取指令会违反 PTE 上的用户/监管者权限检查，触发保护错误，并阻止在 $U$ 模式下执行仅监管者可访问的代码。**\n\n这个陈述考虑了一个没有影子栈的假设情景，这突显了另一层防御。在这种情况下，`RET` 指令会从栈中弹出 $A_k$ 并尝试将程序计数器（$PC$）设置为此值。然而，执行仍然在用户模式（$U$）。地址 $A_k$ 位于一个在其页表项（PTE）中标记为“仅监管者可访问”的页面中。虚拟内存系统被指定要强制执行这种保护：“在 $U$ 模式下...指令获取...只允许在标记为用户可访问的页面上进行。”因此，当在 $U$ 模式下尝试从 $A_k$ 获取指令时，内存管理单元（MMU）会检测到权限违规。这将触发一个保护错误，这是一个将控制权转移给操作系统内核的异常。位于 $A_k$ 的恶意代码将不会被执行。这个陈述正确地指出了一个同样导致攻击失败的基本内存保护机制。\n\n**结论：正确。**\n\nD. **如果攻击者在 $ECALL$ 之前将 $A_k$ 放置在内核栈上，则此漏洞利用会成功；从系统调用返回后，内核会从其自己的栈中弹出 $A_k$ 并在 $S$ 模式下跳转到它。**\n\n这个陈述根本上是错误的。前提“在 $ECALL$ 之前将 $A_k$ 放置在内核栈上”在所描述的架构下是不可能的。内核栈位于标记为“仅监管者可访问”的内存页中。在用户模式（$U$）下运行的进程没有必要的权限来写入这些页面。用户模式测试工具任何试图写入内核栈上地址的尝试都会导致保护错误，从而在执行 `ECALL` 之前很久就停止恶意代码。此外，结论也是不正确的。内核不会在从系统调用返回时从其栈中“弹出”任意地址并跳转到它们。从系统调用的返回是由 `SRET` 指令处理的，它使用 `EPC` 寄存器。内核*内部*函数的任何返回都使用由内核自己执行的 `CALL` 指令放置在内核栈上的地址。这个前提是不可能的，并且结论错误地描述了内核操作。\n\n**结论：不正确。**\n\n总而言之，陈述 A、B 和 C 都基于所提供的架构特性，描述了所描述的权限提升工具未能将控制转移到目标地址 $A_k$ 的有效且不同的原因。",
            "answer": "$$\\boxed{ABC}$$"
        }
    ]
}