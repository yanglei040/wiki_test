{
    "hands_on_practices": [
        {
            "introduction": "在计算实现精确异常的成本之前，我们如何能确定一个处理器是否正确地实现了它？本练习要求你使用汇编语言创建一个最小化的“石蕊测试”。你的目标是设计一个指令序列，如果处理器在异常发生后未能隐藏推测执行的结果，该序列就能揭示这个错误。通过思考如何“打破”精确异常的规则，这个练习可以加深你对核心原则的理解。",
            "id": "3667580",
            "problem": "一个乱序执行的中央处理器（CPU）实现了寄存器重命名、一个重排缓冲区（Reorder Buffer, ROB）和一个加载-存储队列（Load-Store Queue, LSQ）。如果在陷入（trap）的时刻，体系结构状态与程序顺序中所有在异常指令之前的指令都已执行并提交、而所有在其之后的指令都未产生任何体系结构影响时的状态完全一致，那么这个同步异常（例如，除零或页错误）就被称为精确的（precise）。形式上，如果动态指令流按程序顺序索引为 $I_1, I_2, \\dots, I_n$，并且指令 $I_k$ 导致了一次陷入，那么陷入时的体系结构状态必须反映 $\\{I_i \\mid i  k\\}$ 的效果，并且必须排除 $\\{I_i \\mid i \\ge k\\}$ 的效果。乱序执行允许对 $\\{I_i \\mid i \\ge k\\}$ 进行推测执行，但 ROB 和 LSQ 会强制按序提交（in-order commit）以维持此不变量。\n\n你需要设计一个最小化的伪汇编“石蕊测试”（litmus test），用于在这种 CPU 中检测不精确的异常行为。在代码片段执行前，初始体系结构寄存器状态为 $R_0 = 0$，$R_1 = 0$，$R_2 = 0$。异常处理程序在陷入时同步读取体系结构寄存器并记录其值；除了此读取操作外，不要假设任何特殊的操作系统功能。当除数 $R_t$ 为零时，除法指令 $DIV\\, R_d, R_s, R_t$ 会触发一个同步异常。假设内存存储仅在 LSQ 中提交后才全局可见，并且精确陷入会清除 ROB 中所有较新指令的推测状态。\n\n下列哪个最小化的汇编代码片段能够在不依赖内存副作用或异常指令本身的目标寄存器的情况下，通过异常处理程序记录的体系结构寄存器值中可检测到的不匹配，可靠地暴露不精确异常？\n\nA.\n$I_1$: $ADD\\, R_1, R_1, 1$  \n$I_2$: $DIV\\, R_3, R_4, R_0$  \n$I_3$: $ADD\\, R_2, R_2, 1$  \n\n处理程序检查：在精确异常下，预期 $R_1 = 1$ 且 $R_2 = 0$；如果不精确的提交发生，则会观察到 $R_2 = 1$。\n\nB.\n$I_1$: $ADD\\, R_1, R_1, 1$  \n$I_2$: $DIV\\, R_3, R_4, R_0$  \n$I_3$: $STORE\\, [M], R_2$ 其中 $M$ 是处理程序已知的一个内存地址\n\n处理程序检查：在处理程序中读取 $[M]$；在精确异常下，预期存储操作不可见。\n\nC.\n$I_1$: $ADD\\, R_1, R_1, 1$  \n$I_2$: $DIV\\, R_1, R_2, R_0$  \n$I_3$: $MOV\\, R_1, 7$  \n\n处理程序检查：在精确异常下，预期 $R_1 = 1$；检测到 $R_1 \\ne 1$ 即为不精确。\n\nD.\n$I_1$: $ADD\\, R_1, R_1, 1$  \n$I_2$: $FENCE$ (串行化指令)\n$I_3$: $DIV\\, R_3, R_4, R_0$  \n$I_4$: $ADD\\, R_2, R_2, 1$  \n\n处理程序检查：在精确异常下，预期 $R_1 = 1$ 且 $R_2 = 0$。\n\n选择满足所述标准的唯一最佳选项，并根据精确异常的定义以及 ROB 和 LSQ 强制的按序提交机制来证明你的选择。",
            "solution": "### 第 1 步：提取已知条件\n- **CPU 架构**：乱序执行、寄存器重命名、重排缓冲区（ROB）、加载-存储队列（LSQ）。\n- **精确异常定义**：如果指令 $I_k$ 导致陷入，体系结构状态必须反映所有指令 $\\{I_i \\mid i  k\\}$ 的效果，并排除所有指令 $\\{I_i \\mid i \\ge k\\}$ 的效果。\n- **CPU 行为**：ROB 和 LSQ 强制按序提交。同步异常会清除 ROB 中较新指令的推测状态。\n- **初始状态**：体系结构寄存器 $R_0 = 0$，$R_1 = 0$，$R_2 = 0$。\n- **异常机制**：如果 $R_t = 0$，指令 $DIV\\, R_d, R_s, R_t$ 会触发一个同步异常。\n- **处理程序行为**：异常处理程序在陷入时同步读取并记录体系结构寄存器的值。\n- **存储行为**：内存存储仅在从 LSQ 提交后才全局可见。\n- **任务约束**：\n    1. 设计一个最小化的伪汇编石蕊测试来检测不精确的异常行为。\n    2. 该测试必须表现为处理程序记录的体系结构寄存器值中可检测到的不匹配。\n    3. 该测试**不得**依赖内存副作用。\n    4. 该测试**不得**依赖异常指令本身的目标寄存器。\n\n### 第 2 步：使用提取的已知条件进行验证\n问题陈述具有科学依据、定义明确且客观。\n- **科学依据**：所述概念（乱序执行、寄存器重命名、ROB、LSQ、精确异常）是现代计算机体系结构中的基础和标准主题。精确异常的定义是形式化且正确的。\n- **定义明确**：问题要求提供一个满足一组清晰约束的最小化代码片段，以测试一种特定的、定义明确的处理器行为（不精确异常）。可以从提供的定义中逻辑地推导出解决方案。\n- **客观性**：问题以形式化的技术语言陈述，没有歧义或主观因素。成功标准被明确定义（在特定约束下寄存器值中可检测到的不匹配）。\n- **完整性与一致性**：问题提供了所有必要信息：初始状态、导致异常的指令、异常处理机制以及微体系结构的属性（ROB、LSQ）。约束是明确的，并且与目标一致。\n\n### 第 3 步：结论与行动\n问题陈述是**有效**的。开始进行解决方案推导。\n\n### 基于原理的推导\n如果不精确异常发生，那么在指令 $I_k$ 陷入时，体系结构状态会反映任何 $j > k$ 的指令 $I_j$ 的效果。在乱序处理器中，比 $I_k$ 年轻的指令（如 $I_{k+1}$）可以在 $I_k$ 完成之前被推測执行。一个实现精确异常的处理器必须确保，在检测到 $I_k$ 的异常时，所有来自推测执行的较新指令的状态更改都在异常处理程序被调用前被丢弃（squashed）。体系结构状态必须只反映比 $I_k$ 老的指令的已提交结果。\n\n要构建一个石蕊测试，我们需要一个指令序列：\n1.  一条修改体系结构状态的指令 $I_{k-1}$。其效果*应该*对处理程序可见。\n2.  一条保证会引起同步异常的指令 $I_k$。\n3.  一条独立于 $I_k$ 并修改体系结构状态的指令 $I_{k+1}$。其效果*不应该*对处理程序可见。乱序执行的机器很可能会推测性地执行这条指令。\n\n如果处理程序观察到来自 $I_{k+1}$ 的状态变化，则该测试检测到不精确性。该测试还必须遵守负面约束：无内存副作用，且不依赖于异常指令的目标寄存器。\n\n初始状态：$R_0 = 0$，$R_1 = 0$，$R_2 = 0$。\n\n### 逐项分析\n\n**A.**\n$I_1$: $ADD\\, R_1, R_1, 1$\n$I_2$: $DIV\\, R_3, R_4, R_0$\n$I_3$: $ADD\\, R_2, R_2, 1$\n\n处理程序检查：预期 $R_1 = 1$ 且 $R_2 = 0$。\n\n分析：\n- $I_1$ 比异常指令 $I_2$ 老。其执行将 $R_1$ 从 0 变为 1。根据精确异常的定义，这一变化必须被提交并对处理程序可见。\n- $I_2$ 将导致除零异常，因为它的第三个操作数是 $R_0$，其值为 0。目标寄存器是 $R_3$。\n- $I_3$ 比 $I_2$ 年轻。一个激进的乱序处理器可能会推测性地执行 $I_3$，与 $I_2$ 并发执行，甚至在 $I_2$ 完成其执行阶段之前。这种推测执行将计算出 $R_2 = 1$。\n- **精确行为**：当来自 $I_2$ 的异常被确认时，处理器必须从流水线和 ROB 中冲刷掉所有较新的指令（$I_3$）。对 $R_2$ 的推测性更新被丢棄。$I_1$ 是较早的指令，因此其结果被提交。处理程序看到的体系结构状态将是 $R_1 = 1, R_2 = 0$。\n- **不精确行为**：如果处理器在处理来自 $I_2$ 的异常之前，不精确地提交了推测执行的 $I_3$ 的结果，那么处理程序将观察到 $R_1 = 1$ 和 $R_2 = 1$。这种与预期的 $R_2 = 0$ 的不匹配可靠地暴露了不精确行为。\n- **约束检查**：\n    1.  依赖于寄存器（$R_1, R_2$），而非内存。**满足。**\n    2.  检查对象是 $R_1$ 和 $R_2$。异常指令（$I_2$）的目标是 $R_3$。测试不依赖于 $R_3$ 的值。**满足。**\n    3.  该序列是最小化的，包含异常事件前、中、后各一条指令。**满足。**\n\n结论：**正确**。此选项提供了一个最小且有效的石蕊测试，并遵守所有约束。\n\n**B.**\n$I_1$: $ADD\\, R_1, R_1, 1$\n$I_2$: $DIV\\, R_3, R_4, R_0$\n$I_3$: $STORE\\, [M], R_2$\n\n处理程序检查：在处理程序中读取 $[M]$。\n\n分析：\n指令 $I_3$ 是一条 $STORE$ 指令。其目的是观察这个推测性存储是否在内存系统中变得可见，如果可见则表明存在不精确性。然而，问题陈述包含了明确的约束：“不依赖内存副作用”。此选项直接违反了此约束。此外，问题指出 LSQ 确保存储仅在提交时才可见，而一个精确异常会在推测性存储提交之前将其从 LSQ 中冲刷掉。\n\n结论：**不正确**。它违反了“无内存副作用”的约束。\n\n**C.**\n$I_1$: $ADD\\, R_1, R_1, 1$\n$I_2$: $DIV\\, R_1, R_2, R_0$\n$I_3$: $MOV\\, R_1, 7$\n\n处理程序检查：预期 $R_1 = 1$。\n\n分析：\n异常指令是 $I_2: DIV\\, R_1, R_2, R_0$。其目标寄存器是 $R_1$。处理程序的检查被指定为 `expect R_1 = 1`，这意味着测试结果完全取决于 $R_1$ 的最终值。这直接违反了问题的约束：“不依赖于……异常指令本身的目标寄存器”。尽管寄存器重命名可能会使内部状态复杂化，但体系结构检查是针对作为错误指令（$I_2$）目标的寄存器（$R_1$）进行的。\n\n结论：**不正确**。它违反了“不依赖于异常指令的目标寄存器”的约束。\n\n**D.**\n$I_1$: $ADD\\, R_1, R_1, 1$\n$I_2$: $FENCE$\n$I_3$: $DIV\\, R_3, R_4, R_0$\n$I_4$: $ADD\\, R_2, R_2, 1$\n\n处理程序检查：预期 $R_1 = 1$ 且 $R_2 = 0$。\n\n分析：\n这个序列引入了一条 `FENCE` 指令（$I_2$）。`FENCE` 是一条串行化指令。其目的是强制指令执行的顺序。$I_2$ 处的 `FENCE` 通常会强制处理器等待，直到 $I_1$ 完成并提交后，才允许任何后续指令（如 $I_3$ 或 $I_4$）继续执行。虽然处理器仍然可以越过 $I_3$ 推测性地执行 $I_4$，但 `FENCE` 指令是一个强同步原语。石蕊测试应该是*最小化*的。`FENCE` 的存在不满足最小化原则，因为它增加了一个不必要的显式同步结构来测试核心行为。更重要的是，一些 `FENCE` 的实现可能非常“重”，以至于会排空流水线，这将阻止 $I_4$ 的推测执行。如果 $I_4$ 从未被推测执行，那么该测试就不可能检测到与其推测状态相关的不精确性。因此，`FENCE` 不仅不满足最小化原则，而且可能适得其反，因为它可能会掩盖它本应测试的行为。选项 A 在没有这条多余且可能混淆视听的指令的情况下测试了相同的逻辑。\n\n结论：**不正确**。它违反了“最小化石蕊测试”的要求，并且 `FENCE` 可能会阻止暴露缺陷所需的推测执行。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "处理精确异常的一个关键部分是恢复寄存器状态。在使用寄存器重命名的现代处理器中，这涉及到丢弃为推测执行而分配的物理寄存器。本问题提供了一个处理器在异常发生瞬间的状态快照，并要求你计算必须返回到空闲列表中的物理寄存器总数。这让你对“回滚”过程有一个具体的感受。",
            "id": "3667618",
            "problem": "一个乱序超标量核心通过使用寄存器重命名、针对每个体系结构寄存器的推测版本链以及一个按序重排序缓冲区（ROB）来维持精确异常。该机器拥有分离的整数和浮点寄存器堆，其重命名由寄存器别名表（RAT）管理。当重排序缓冲区（ROB）头部的最旧未提交指令是一条产生异常的指令时，会触发一个精确异常。在那一刻，所有更旧的指令都已提交，体系结构状态必须恢复到产生异常的指令之前的状态，从而消除该指令及所有更年轻指令的任何影响。\n\n本问题的基本定义：\n- 每条写入体系结构寄存器的动态指令都会分配一个新的物理寄存器，并更新该体系结构寄存器的RAT条目，使其指向这个最新的物理版本。先前的映射关系被保留在针对每个寄存器的历史堆栈上。\n- 对于每个体系结构寄存器，推测链长度 $\\ell(r)$ 是堆叠在最后一个已提交版本之上的未提交物理版本的数量。在异常时恢复精确状态需要将每个体系结构寄存器的RAT回滚到最后一个已提交的版本，并丢弃其推测链中的所有未提交版本。\n\n将要处理异常时，处理器状态如下。\n- 整数部分：\n  - 体系结构整数寄存器为 $r_0,\\dots,r_7$（共8个）。\n  - 整数RAT $M_{\\text{int}}$ 当前映射如下：\n    - $M_{\\text{int}}(r_0)=P_{17}$, $M_{\\text{int}}(r_1)=P_{3}$, $M_{\\text{int}}(r_2)=P_{11}$, $M_{\\text{int}}(r_3)=P_{6}$,\n    - $M_{\\text{int}}(r_4)=P_{19}$, $M_{\\text{int}}(r_5)=P_{8}$, $M_{\\text{int}}(r_6)=P_{14}$, $M_{\\text{int}}(r_7)=P_{21}$.\n  - 整数体系结构寄存器的推测链长度（计算了产生异常的指令和所有更年轻的指令）为：\n    - $\\ell_{\\text{int}}(r_0)=2$, $\\ell_{\\text{int}}(r_1)=0$, $\\ell_{\\text{int}}(r_2)=1$, $\\ell_{\\text{int}}(r_3)=3$,\n    - $\\ell_{\\text{int}}(r_4)=0$, $\\ell_{\\text{int}}(r_5)=1$, $\\ell_{\\text{int}}(r_6)=0$, $\\ell_{\\text{int}}(r_7)=2$.\n- 浮点部分：\n  - 体系结构浮点寄存器为 $f_0,\\dots,f_5$（共6个）。\n  - 浮点RAT $M_{\\text{fp}}$ 当前映射如下：\n    - $M_{\\text{fp}}(f_0)=F_{7}$, $M_{\\text{fp}}(f_1)=F_{2}$, $M_{\\text{fp}}(f_2)=F_{12}$, $M_{\\text{fp}}(f_3)=F_{4}$,\n    - $M_{\\text{fp}}(f_4)=F_{9}$, $M_{\\text{fp}}(f_5)=F_{15}$.\n  - 浮点体系结构寄存器的推测链长度为：\n    - $\\ell_{\\text{fp}}(f_0)=1$, $\\ell_{\\text{fp}}(f_1)=0$, $\\ell_{\\text{fp}}(f_2)=2$,\n    - $\\ell_{\\text{fp}}(f_3)=0$, $\\ell_{\\text{fp}}(f_4)=1$, $\\ell_{\\text{fp}}(f_5)=0$.\n\n假设整数和浮点物理寄存器堆是相互独立的，并且在异常时恢复精确状态包括将RAT回滚到最后提交的映射，并将所有被丢弃的推测性物理寄存器返回到空闲列表中。\n\n仅使用上述基本定义，计算在处理此精确异常时，在整数和浮点寄存器堆中总共必须恢复（即，解除映射并返回到空闲列表）的物理寄存器数量。请以单个整数形式给出答案，不带单位。无需四舍五入。",
            "solution": "用户请求解答一个关于乱序处理器中精确异常处理的计算机体系结构问题。首先，我将验证问题陈述的有效性。\n\n### 步骤1：提取已知条件\n\n- **系统**：一个乱序超标量核心，具有寄存器重命名、针对每个体系结构寄存器的推测版本链和一个按序重排序缓冲区（ROB）。\n- **寄存器堆**：分离的整数和浮点寄存器堆。重命名由寄存器别名表（RAT）管理。\n- **精确异常**：当ROB头部的最旧未提交指令是一条产生异常的指令时，触发一个异常。\n- **状态恢复**：发生异常时，体系结构状态恢复到产生异常的指令之前的状态。这包括消除该指令及所有更年轻指令的影响。\n- **寄存器重命名定义**：一条写入体系结构寄存器的指令会分配一个新的物理寄存器。RAT被更新，先前的映射被保存在该体系结构寄存器的历史堆栈中。\n- **推测链长度定义**：对于一个体系结构寄存器 $r$，推测链长度 $\\ell(r)$ 是堆叠在最后一个已提交版本之上的未提交物理版本的数量。“在异常时恢复精确状态需要将每个体系结构寄存器的RAT回滚到最后一个已提交的版本，并丢弃其推测链中的所有未提交版本。”\n- **整数寄存器**：8个体系结构整数寄存器，$r_0$ 到 $r_7$。\n- **整数RAT状态**：$M_{\\text{int}}(r_0)=P_{17}$, $M_{\\text{int}}(r_1)=P_{3}$, $M_{\\text{int}}(r_2)=P_{11}$, $M_{\\text{int}}(r_3)=P_{6}$, $M_{\\text{int}}(r_4)=P_{19}$, $M_{\\text{int}}(r_5)=P_{8}$, $M_{\\text{int}}(r_6)=P_{14}$, $M_{\\text{int}}(r_7)=P_{21}$。\n- **整数推测链长度**：$\\ell_{\\text{int}}(r_0)=2$, $\\ell_{\\text{int}}(r_1)=0$, $\\ell_{\\text{int}}(r_2)=1$, $\\ell_{\\text{int}}(r_3)=3$, $\\ell_{\\text{int}}(r_4)=0$, $\\ell_{\\text{int}}(r_5)=1$, $\\ell_{\\text{int}}(r_6)=0$, $\\ell_{\\text{int}}(r_7)=2$。此计数包括产生异常的指令和所有更年轻的指令。\n- **浮点寄存器**：6个体系结构浮点寄存器，$f_0$ 到 $f_5$。\n- **浮点RAT状态**：$M_{\\text{fp}}(f_0)=F_{7}$, $M_{\\text{fp}}(f_1)=F_{2}$, $M_{\\text{fp}}(f_2)=F_{12}$, $M_{\\text{fp}}(f_3)=F_{4}$, $M_{\\text{fp}}(f_4)=F_{9}$, $M_{\\text{fp}}(f_5)=F_{15}$。\n- **浮点推测链长度**：$\\ell_{\\text{fp}}(f_0)=1$, $\\ell_{\\text{fp}}(f_1)=0$, $\\ell_{\\text{fp}}(f_2)=2$, $\\ell_{\\text{fp}}(f_3)=0$, $\\ell_{\\text{fp}}(f_4)=1$, $\\ell_{\\text{fp}}(f_5)=0$。\n- **任务**：计算在整数和浮点寄存器堆中总共必须恢复（即，解除映射并返回到空闲列表）的物理寄存器数量。\n\n### 步骤2：使用提取的已知条件进行验证\n\n该问题具有科学依据。所描述的模型是在乱序处理器中实现精确异常的标准且被广泛理解的机制，这是计算机体系结构中的一个基本主题。重排序缓冲区（ROB）、寄存器别名表（RAT）、物理寄存器和推测执行等概念是该领域的核心。\n\n该问题提法得当。它提供了清晰的定义和所有必要的数据，可以得出一个唯一的解。“推测链长度”的定义直接对应于给定体系结构寄存器的推测性（未提交）物理寄存器版本的数量。任务是计算必须丢弃的这些推测性寄存器的总数，这是对所提供定义和数据的直接应用。\n\n该问题是客观且无歧义的。所提供的RAT映射与推测状态的快照一致，但对于计算而言并非严格必要，因为链长已明确给出。包含这些映射不会产生矛盾。\n\n结论是该问题是有效的。\n\n### 步骤3：行动\n\n该问题是有效的。将提供一个完整的、有理有据的解决方案。\n\n问题要求我们计算在处理精确异常时返回到各自空闲列表的物理寄存器总数。问题陈述提供了一个关键定义：“在异常时恢复精确状态需要将每个体系结构寄存器的RAT回滚到最后一个已提交的版本，并丢弃其推测链中的所有未提交版本。”\n\n这意味着对于每个体系结构寄存器 $r$，必须释放的物理寄存器数量等于与其关联的未提交版本的数量。这个数量被明确定义并作为推测链长度 $\\ell(r)$ 给出。\n\n因此，要恢复的物理寄存器总数是所有整数和浮点体系结构寄存器的推测链长度之和。\n\n设 $N_{\\text{total}}$ 为要恢复的物理寄存器总数。这个总数是自整数寄存器堆恢复的寄存器数量 $N_{\\text{int}}$ 和自浮点寄存器堆恢复的寄存器数量 $N_{\\text{fp}}$ 之和。\n\n首先，我们通过对所有整数体系结构寄存器的给定推测链长度求和，来计算要恢复的整数物理寄存器数量：\n$$\nN_{\\text{int}} = \\sum_{i=0}^{7} \\ell_{\\text{int}}(r_i)\n$$\n代入给定值：\n$$\nN_{\\text{int}} = \\ell_{\\text{int}}(r_0) + \\ell_{\\text{int}}(r_1) + \\ell_{\\text{int}}(r_2) + \\ell_{\\text{int}}(r_3) + \\ell_{\\text{int}}(r_4) + \\ell_{\\text{int}}(r_5) + \\ell_{\\text{int}}(r_6) + \\ell_{\\text{int}}(r_7)\n$$\n$$\nN_{\\text{int}} = 2 + 0 + 1 + 3 + 0 + 1 + 0 + 2\n$$\n$$\nN_{\\text{int}} = 9\n$$\n所以，必须有 $9$ 个整数物理寄存器返回到整数空闲列表。\n\n接下来，我们通过对所有浮点体系结构寄存器的给定推测链长度求和，来计算要恢复的浮点物理寄存器数量：\n$$\nN_{\\text{fp}} = \\sum_{j=0}^{5} \\ell_{\\text{fp}}(f_j)\n$$\n代入给定值：\n$$\nN_{\\text{fp}} = \\ell_{\\text{fp}}(f_0) + \\ell_{\\text{fp}}(f_1) + \\ell_{\\text{fp}}(f_2) + \\ell_{\\text{fp}}(f_3) + \\ell_{\\text{fp}}(f_4) + \\ell_{\\text{fp}}(f_5)\n$$\n$$\nN_{\\text{fp}} = 1 + 0 + 2 + 0 + 1 + 0\n$$\n$$\nN_{\\text{fp}} = 4\n$$\n所以，必须有 $4$ 个浮点物理寄存器返回到浮点空闲列表。\n\n最后，恢复的物理寄存器总数 $N_{\\text{total}}$ 是 $N_{\\text{int}}$ 和 $N_{\\text{fp}}$ 的和：\n$$\nN_{\\text{total}} = N_{\\text{int}} + N_{\\text{fp}}\n$$\n$$\nN_{\\text{total}} = 9 + 4 = 13\n$$\n\n必须解除映射并返回到空闲列表的物理寄存器总数为 $13$。当前的RAT映射（$M_{\\text{int}}$ 和 $M_{\\text{fp}}$）代表了最具推测性的状态，但对于计算并非直接需要，因为问题提供了推测链长度，而这正是恢复过程定义所确切需要的量。",
            "answer": "$$\\boxed{13}$$"
        },
        {
            "introduction": "精确异常要求在指令提交之前，任何架构性副作用——不仅仅是寄存器写操作——都不能成为永久性的。这意味着推测性的内存存储、控制寄存器更新和标志位改变都必须被临时缓冲。本练习要求你推导这些缓冲区所需的总存储硬件的表达式，从而将精确性这一高级概念与随处理器指令窗口大小扩展的具体芯片成本联系起来。",
            "id": "3667573",
            "problem": "乱序处理器通过确保架构可见的副作用仅在按序提交时才变得可见，来维持精确异常。为此，它会缓冲在执行期间产生的推测性副作用。考虑一个核心，其指令窗口大小为 $N$（等于重排序缓冲区 (Reorder Buffer, ROB) 中的条目数）。该核心实现了三种副作用缓冲结构：\n\n- 一个存储缓冲区，用于在提交前保存推测性内存存储。\n- 一个控制和状态寄存器 (Control and Status Register, CSR) 影子缓冲区，为写 CSR 的指令记录更新前的 CSR 快照。\n- 一个条件码标志快照文件，为写架构标志的指令记录标志值。\n\n假设如下：\n\n- 物理内存地址宽度为 $W_{a}$ 位。\n- 存储的架构数据宽度为 $W_{d}$ 位。\n- 条件码标志宽度为 $W_{f}$ 位。\n- CSR 值宽度为 $W_{\\text{csr}}$ 位，并且有 $M_{\\text{csr}}$ 个不同的 CSR 地址。\n- 执行中的指令中，最多有比例为 $p_{s}$ 的是存储指令，最多有比例为 $p_{\\text{csr}}$ 的是写 CSR 的指令，最多有比例为 $p_{f}$ 的是写标志的指令。假设 $p_{s} N$、$p_{\\text{csr}} N$ 和 $p_{f} N$ 均为整数。\n- 为支持精确异常和正确重放，每个存储缓冲区条目包含：\n  - 存储的物理地址（$W_{a}$ 位）。\n  - 存储的数据负载（$W_{d}$ 位）。\n  - 一个字节使能掩码（$W_{d}/8$ 位）。\n  - 一个编码写入字节数的大小字段（$\\lceil \\log_{2}(W_{d}/8) \\rceil$ 位）。\n  - 产生者 ROB 索引（$\\lceil \\log_{2} N \\rceil$ 位）。\n  - 一个有效位（$1$ 位）。\n- 每个 CSR 影子条目包含：\n  - CSR 标识符（$\\lceil \\log_{2} M_{\\text{csr}} \\rceil$ 位）。\n  - 更新前的 CSR 值（$W_{\\text{csr}}$ 位）。\n  - 产生者 ROB 索引（$\\lceil \\log_{2} N \\rceil$ 位）。\n  - 一个有效位（$1$ 位）。\n- 每个标志快照条目包含：\n  - 标志值（$W_{f}$ 位）。\n  - 产生者 ROB 索引（$\\lceil \\log_{2} N \\rceil$ 位）。\n  - 一个有效位（$1$ 位）。\n\n忽略对齐、存储体以及任何额外的保护、奇偶校验或纠错位。只计算明确列出的字段。所有三个结构都必须配置为能够容纳由比例 $p_{s}$、$p_{\\text{csr}}$ 和 $p_{f}$ 乘以 $N$ 所隐含的最大相关执行中更新的数量。\n\n仅使用精确异常要求任何架构可见的副作用都不能乱序提交这一基本定义，推导出一个单一的闭式表达式，用于表示缓冲这些副作用所需的总存储容量（以字节为单位），该表达式是 $N$、$W_{a}$、$W_{d}$、$W_{f}$、$W_{\\text{csr}}$、$M_{\\text{csr}}$、$p_{s}$、$p_{\\text{csr}}$ 和 $p_{f}$ 的函数。将你的最终答案表示为一个以字节为单位的单一解析表达式。无需取整。",
            "solution": "问题陈述已经过验证，被认为是科学合理的、定义明确的、客观的且内部一致的。它在计算机体系结构领域提供了一个可形式化的问题，并有足够的信息来推导出唯一的解决方案。\n\n其基本原理是，为了支持精确异常，乱序处理器必须不允许推测性的架构副作用在产生它们的指令被确认为非推测性并按程序顺序提交之前变为全局可见。这需要缓冲这些副作用。问题要求计算三种此类缓冲结构所需的总存储容量（以字节为单位）：一个存储缓冲区、一个控制和状态寄存器 (CSR) 影子缓冲区以及一个条件码标志快照文件。\n\n总存储容量 $S_{\\text{total}}$ 是每个独立结构所需存储容量的总和：\n$$S_{\\text{total}} = S_{\\text{store}} + S_{\\text{csr}} + S_{\\text{flag}}$$\n我们将以位为单位计算每个结构的存储容量，然后通过除以 $8$ 将总和转换为字节。\n\n首先，我们确定存储缓冲区 $S_{\\text{store}}$ 所需的存储容量。\n存储缓冲区中单个条目的大小 $B_{\\text{store}}$（以位为单位）是问题中指定的其组成字段大小的总和：\n$B_{\\text{store}} = (\\text{物理地址}) + (\\text{数据负载}) + (\\text{字节使能掩码}) + (\\text{大小字段}) + (\\text{产生者 ROB 索引}) + (\\text{有效位})$\n代入每个字段的给定宽度：\n$$B_{\\text{store}} = W_{a} + W_{d} + \\frac{W_{d}}{8} + \\left\\lceil \\log_{2}\\left(\\frac{W_{d}}{8}\\right) \\right\\rceil + \\lceil \\log_{2}(N) \\rceil + 1$$\n合并与 $W_d$ 相关的项：\n$$B_{\\text{store}} = W_{a} + \\frac{9}{8}W_{d} + \\left\\lceil \\log_{2}\\left(\\frac{W_{d}}{8}\\right) \\right\\rceil + \\lceil \\log_{2}(N) \\rceil + 1$$\n问题指出，存储缓冲区必须配置为能够容纳最大数量的执行中存储。该数量为 $p_{s}N$。\n存储缓冲区的总存储容量（以位为单位）$S_{\\text{store}}$ 是条目数乘以每个条目的大小：\n$$S_{\\text{store}} = (p_{s}N) \\times B_{\\text{store}} = p_{s}N \\left( W_{a} + \\frac{9}{8}W_{d} + \\left\\lceil \\log_{2}\\left(\\frac{W_{d}}{8}\\right) \\right\\rceil + \\lceil \\log_{2}(N) \\rceil + 1 \\right)$$\n\n其次，我们确定 CSR 影子缓冲区 $S_{\\text{csr}}$ 的存储容量。\n单个 CSR 影子条目的大小 $B_{\\text{csr}}$（以位为单位）是其字段大小的总和：\n$B_{\\text{csr}} = (\\text{CSR 标识符}) + (\\text{更新前的 CSR 值}) + (\\text{产生者 ROB 索引}) + (\\text{有效位})$\n代入给定的宽度：\n$$B_{\\text{csr}} = \\lceil \\log_{2}(M_{\\text{csr}}) \\rceil + W_{\\text{csr}} + \\lceil \\log_{2}(N) \\rceil + 1$$\n执行中写 CSR 指令的最大数量为 $p_{\\text{csr}}N$。\nCSR 缓冲区的总存储容量（以位为单位）$S_{\\text{csr}}$ 为：\n$$S_{\\text{csr}} = (p_{\\text{csr}}N) \\times B_{\\text{csr}} = p_{\\text{csr}}N \\left( W_{\\text{csr}} + \\lceil \\log_{2}(M_{\\text{csr}}) \\rceil + \\lceil \\log_{2}(N) \\rceil + 1 \\right)$$\n\n第三，我们确定标志快照文件 $S_{\\text{flag}}$ 的存储容量。\n单个标志快照条目的大小 $B_{\\text{flag}}$（以位为单位）是其字段大小的总和：\n$B_{\\text{flag}} = (\\text{标志值}) + (\\text{产生者 ROB 索引}) + (\\text{有效位})$\n代入给定的宽度：\n$$B_{\\text{flag}} = W_{f} + \\lceil \\log_{2}(N) \\rceil + 1$$\n执行中写标志指令的最大数量为 $p_{f}N$。\n标志快照文件的总存储容量（以位为单位）$S_{\\text{flag}}$ 为：\n$$S_{\\text{flag}} = (p_{f}N) \\times B_{\\text{flag}} = p_{f}N \\left( W_{f} + \\lceil \\log_{2}(N) \\rceil + 1 \\right)$$\n\n最后，所需的总存储容量（以位为单位）$S_{\\text{total, bits}}$ 是所有三个结构存储容量的总和：\n$$S_{\\text{total, bits}} = S_{\\text{store}} + S_{\\text{csr}} + S_{\\text{flag}}$$\n$$S_{\\text{total, bits}} = p_{s}N \\left( W_{a} + \\frac{9}{8}W_{d} + \\left\\lceil \\log_{2}\\left(\\frac{W_{d}}{8}\\right) \\right\\rceil + \\lceil \\log_{2}(N) \\rceil + 1 \\right) + p_{\\text{csr}}N \\left( W_{\\text{csr}} + \\lceil \\log_{2}(M_{\\text{csr}}) \\rceil + \\lceil \\log_{2}(N) \\rceil + 1 \\right) + p_{f}N \\left( W_{f} + \\lceil \\log_{2}(N) \\rceil + 1 \\right)$$\n提取公因数 $N$：\n$$S_{\\text{total, bits}} = N \\left[ p_{s} \\left( W_{a} + \\frac{9}{8}W_{d} + \\left\\lceil \\log_{2}\\left(\\frac{W_{d}}{8}\\right) \\right\\rceil + \\lceil \\log_{2}(N) \\rceil + 1 \\right) + p_{\\text{csr}} \\left( W_{\\text{csr}} + \\lceil \\log_{2}(M_{\\text{csr}}) \\rceil + \\lceil \\log_{2}(N) \\rceil + 1 \\right) + p_{f} \\left( W_{f} + \\lceil \\log_{2}(N) \\rceil + 1 \\right) \\right]$$\n问题要求最终答案以字节为单位。为了从位转换为字节，我们除以 $8$。\n$$S_{\\text{total, bytes}} = \\frac{S_{\\text{total, bits}}}{8}$$\n这就得出了总存储容量（以字节为单位）的最终闭式表达式：\n$$S_{\\text{total, bytes}} = \\frac{N}{8} \\left[ p_{s}\\left( W_{a} + \\frac{9}{8}W_{d} + \\left\\lceil \\log_{2}\\left(\\frac{W_{d}}{8}\\right) \\right\\rceil + \\lceil \\log_{2}(N) \\rceil + 1 \\right) + p_{\\text{csr}}\\left( W_{\\text{csr}} + \\lceil \\log_{2}(M_{\\text{csr}}) \\rceil + \\lceil \\log_{2}(N) \\rceil + 1 \\right) + p_{f}\\left( W_{f} + \\lceil \\log_{2}(N) \\rceil + 1 \\right) \\right]$$\n该表达式表示了为存储、CSR 写入和标志更新缓冲推测性副作用所需的总存储容量，从而确保所述的乱序处理器能够实现精确异常。",
            "answer": "$$ \\boxed{ \\frac{N}{8} \\left[ p_{s}\\left( W_{a} + \\frac{9}{8}W_{d} + \\left\\lceil \\log_{2}\\left(\\frac{W_{d}}{8}\\right) \\right\\rceil + \\lceil \\log_{2}(N) \\rceil + 1 \\right) + p_{\\text{csr}}\\left( W_{\\text{csr}} + \\lceil \\log_{2}(M_{\\text{csr}}) \\rceil + \\lceil \\log_{2}(N) \\rceil + 1 \\right) + p_{f}\\left( W_{f} + \\lceil \\log_{2}(N) \\rceil + 1 \\right) \\right] } $$"
        }
    ]
}