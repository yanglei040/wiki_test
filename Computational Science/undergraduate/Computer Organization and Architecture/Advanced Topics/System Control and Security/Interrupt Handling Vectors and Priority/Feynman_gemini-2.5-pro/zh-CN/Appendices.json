{
    "hands_on_practices": [
        {
            "introduction": "在嵌入式和实时系统中，中断，特别是可嵌套的中断，会消耗栈空间来保存上下文。如果对栈空间的需求估算不足，可能导致栈溢出——这是最危险也最难调试的系统故障之一。本练习  将指导您完成一次最坏情况下的栈使用分析，通过结合应用程序的函数调用链和嵌套中断的上下文帧，您将掌握一项设计高可靠性系统的基本技能。",
            "id": "3652658",
            "problem": "一个表示为架构 $\\mathcal{A}$ 的微控制器，在具有 $32$ 位字的满递减栈上执行单个线程。该系统采用一个具有严格抢占式优先级的向量中断控制器：任何挂起的中断，只要其优先级值低于当前运行上下文的优先级，就允许立即抢占。优先级 $0$ 是最高的；在此场景中没有启用不可屏蔽中断。中断向量表将四个可屏蔽中断分配给对应以下优先级的向量条目：$\\mathrm{I_A}$ 优先级为 $7$，$\\mathrm{I_B}$ 优先级为 $5$，$\\mathrm{I_C}$ 优先级为 $3$，以及 $\\mathrm{I_D}$ 优先级为 $1$。假设在最坏情况下的到达时间，即每个更高优先级的中断都可以在当前执行的中断完成之前到达并抢占它，并且控制器和编译器除了下面描述的架构延迟外，不引入其他人为延迟。\n\n在每次异常入口（包括中断入口）时，架构 $\\mathcal{A}$ 的硬件会自动将一个固定的核心上下文压栈，该上下文由通用寄存器 $r0$ 到 $r3$、寄存器 $r12$、链接寄存器 $lr$、程序计数器 $pc$ 和程序状态寄存器 $\\mathrm{psr}$ 组成。这些寄存器各占一个字，因此核心上下文压栈的字数是固定的。该微控制器包含一个浮点单元。操作系统将处理器配置为在每次中断入口时总是保存浮点上下文。当保存浮点上下文时，硬件会额外压入寄存器 $f0$ 到 $f15$ 以及浮点状态和控制寄存器 $\\mathrm{fpscr}$，并且它会插入正好一个填充字以在入口处保持 $8$ 字节的栈对齐。假设中断的编写方式避免了超出硬件压栈上下文的额外栈使用。假设所述的填充已经满足了栈对齐要求，因此不需要进一步的填充。\n\n在第一个中断发生时，被中断的线程正在执行一个由三个函数组成的调用链 $T \\rightarrow P \\rightarrow C$。该应用程序使用一种标准调用约定，其中每个函数的栈帧由其局部存储、已保存的被调用者保存寄存器和链接寄存器 $lr$ 组成。三个活动栈帧的组成如下：\n- 在 $T$ 中：$124$ 字节的局部存储；已保存的被调用者保存寄存器 $r4$ 到 $r11$（八个寄存器）；以及 $lr$。\n- 在 $P$ 中：$44$ 字节的局部存储；已保存的被调用者保存寄存器 $r4$ 到 $r9$（六个寄存器）；以及 $lr$。\n- 在 $C$ 中：$36$ 字节的局部存储；已保存的被调用者保存寄存器 $r4$ 到 $r7$（四个寄存器）；以及 $lr$。\n\n假设每个寄存器为一个字，每个字为 $4$ 字节。由于对齐约束，每个函数的帧大小都向上取整到 $8$ 字节的倍数；上述局部存储大小是未取整的数量。在第一个中断发生时，所有三个函数都已执行完其序言代码，因此它们的完整栈帧都存在于栈上。\n\n仅使用抢占式优先级中断处理和上下文压栈的基本原理，确定在最坏情况下所需的最小栈分配 $S$（以字节为单位），以避免溢出。最坏情况是指四个中断 $\\mathrm{I_A}$、$\\mathrm{I_B}$、$\\mathrm{I_C}$ 和 $\\mathrm{I_D}$ 嵌套到其最大深度，并且每个中断处理程序至少执行一条浮点指令，从而在入口处触发浮点上下文保存路径。忽略尾链对压栈帧同时驻留的任何影响。\n\n将您的最终答案表示为单个整数字节数。无需四舍五入。在最终的方框答案中不要包含单位，但在您的推理过程中请以字节为单位表示答案。",
            "solution": "该问题要求计算在嵌套中断的最坏情况下防止栈溢出所需的最小栈分配 $S$（以字节为单位）。总栈使用量是被中断的应用程序线程所消耗的栈空间与最大可能数量的嵌套中断服务程序所消耗的空间之和。\n\n字大小被指定为 $32$ 位，即 $4$ 字节。\n\n首先，我们计算应用程序线程使用的栈空间。该线程正在执行一个调用链 $T \\rightarrow P \\rightarrow C$，并且所有三个函数（$T$、$P$ 和 $C$）的栈帧都存在于栈上。必须计算每个函数帧的大小，包括局部存储、已保存的被调用者保存寄存器和已保存的链接寄存器（$lr$），然后为了对齐向上取整到 $8$ 字节的倍数。\n\n单个寄存器的大小为一个字，即 $4$ 字节。\n\n函数 $C$ 的栈帧：\n- 局部存储：$36$ 字节。\n- 已保存的被调用者保存寄存器（$r4$ 到 $r7$）：$4$ 个寄存器 $\\times 4$ 字节/寄存器 = $16$ 字节。\n- 已保存的链接寄存器（$lr$）：$1$ 个寄存器 $\\times 4$ 字节/寄存器 = $4$ 字节。\n- 帧 $C$ 的未对齐总大小：$S_{C, \\text{unaligned}} = 36 + 16 + 4 = 56$ 字节。\n由于 $56$ 是 $8$ 的倍数，对齐后的大小为 $S_C = 56$ 字节。\n\n函数 $P$ 的栈帧：\n- 局部存储：$44$ 字节。\n- 已保存的被调用者保存寄存器（$r4$ 到 $r9$）：$6$ 个寄存器 $\\times 4$ 字节/寄存器 = $24$ 字节。\n- 已保存的链接寄存器（$lr$）：$1$ 个寄存器 $\\times 4$ 字节/寄存器 = $4$ 字节。\n- 帧 $P$ 的未对齐总大小：$S_{P, \\text{unaligned}} = 44 + 24 + 4 = 72$ 字节。\n由于 $72$ 是 $8$ 的倍数，对齐后的大小为 $S_P = 72$ 字节。\n\n函数 $T$ 的栈帧：\n- 局部存储：$124$ 字节。\n- 已保存的被调用者保存寄存器（$r4$ 到 $r11$）：$8$ 个寄存器 $\\times 4$ 字节/寄存器 = $32$ 字节。\n- 已保存的链接寄存器（$lr$）：$1$ 个寄存器 $\\times 4$ 字节/寄存器 = $4$ 字节。\n- 帧 $T$ 的未对齐总大小：$S_{T, \\text{unaligned}} = 124 + 32 + 4 = 160$ 字节。\n由于 $160$ 是 $8$ 的倍数，对齐后的大小为 $S_T = 160$ 字节。\n\n应用程序线程的总栈使用量 $S_{\\text{thread}}$ 是这三个帧大小的总和：\n$$S_{\\text{thread}} = S_C + S_P + S_T = 56 + 72 + 160 = 288 \\text{ 字节}$$\n\n接下来，我们计算单个中断使用的栈空间。问题指明，在每次中断入口时，核心上下文和浮点上下文都会被保存。\n\n核心上下文由寄存器 $r0$ 到 $r3$（$4$ 个寄存器）、$r12$（$1$ 个寄存器）、$lr$（$1$ 个寄存器）、$pc$（$1$ 个寄存器）和 $\\mathrm{psr}$（$1$ 个寄存器）组成。总共是 $4+1+1+1+1=8$ 个寄存器。\n核心上下文栈帧的大小是：\n$$S_{\\text{core}} = 8 \\text{ 个寄存器} \\times 4 \\text{ 字节/寄存器} = 32 \\text{ 字节}$$\n\n浮点上下文保存会压入寄存器 $f0$ 到 $f15$（$16$ 个寄存器）、$\\mathrm{fpscr}$（$1$ 个寄存器）和一个填充字（$1$ 个字）以维持 $8$ 字节对齐。这总共是 $16+1+1 = 18$ 个字。\n浮点上下文栈帧的大小是：\n$$S_{\\text{fp}} = 18 \\text{ 个字} \\times 4 \\text{ 字节/字} = 72 \\text{ 字节}$$\n\n单个中断消耗的总栈空间 $S_{\\text{interrupt}}$ 是核心上下文和浮点上下文大小的总和：\n$$S_{\\text{interrupt}} = S_{\\text{core}} + S_{\\text{fp}} = 32 + 72 = 104 \\text{ 字节}$$\n\n最坏情况涉及所有四个指定中断的最大嵌套。这些中断是 $\\mathrm{I_A}$（优先级 $7$）、$\\mathrm{I_B}$（优先级 $5$）、$\\mathrm{I_C}$（优先级 $3$）和 $\\mathrm{I_D}$（优先级 $1$）。由于较低的优先级数值表示较高的抢占优先级，最深的嵌套发生在最低优先级的中断被下一个更高优先级的中断抢占，依此类推。顺序是：线程执行被 $\\mathrm{I_A}$ 抢占，$\\mathrm{I_A}$ 又被 $\\mathrm{I_B}$ 抢占，$\\mathrm{I_B}$ 又被 $\\mathrm{I_C}$ 抢占，最后 $\\mathrm{I_C}$ 被 $\\mathrm{I_D}$ 抢占。这导致 $4$ 个中断处理上下文被压入栈中。\n\n所有嵌套中断的总栈使用量为：\n$$S_{\\text{interrupts\\_total}} = 4 \\times S_{\\text{interrupt}} = 4 \\times 104 = 416 \\text{ 字节}$$\n\n最后，为避免溢出所需的最小总栈分配 $S$ 是线程的栈使用量与总中断栈使用量之和：\n$$S = S_{\\text{thread}} + S_{\\text{interrupts\\_total}} = 288 + 416 = 704 \\text{ 字节}$$",
            "answer": "$$\\boxed{704}$$"
        },
        {
            "introduction": "中断处理的速度直接决定了系统的响应能力。在中断处理的开销（例如保存寄存器、获取中断向量）上花费的每一个时钟周期，都意味着执行有效任务的时间减少了一个周期。本练习  将帮助您量化中断开销对性能的影响，通过计算不同架构优化策略下的总周期成本和最终的事件处理率，您将能更深刻地理解设计高性能中断驱动系统时所面临的权衡。",
            "id": "3652721",
            "problem": "一个中央处理器（CPU）在饱和稳态下执行一个单一的高优先级中断服务例程（ISR），这意味着来自一个设备的中断连续不断地到达，服务之间没有空闲周期。该 CPU 通过一个具有固定优先级的可编程中断控制器（PIC）使用向量中断方案。系统参数和微架构成本如下：\n\n- 时钟频率: $f_{clk} = 250 \\times 10^{6}\\,\\text{Hz}$。\n- 基线中断进入序列成本：\n  - PIC 中断确认握手：$3$ 个周期。\n  - 优先级解析：$3$ 个周期。\n  - 从片外存储器获取向量：$1$ 个总线周期加 $2$ 个等待状态 $\\Rightarrow$ 共 $3$ 个周期。\n  - 流水线刷新：$5$ 个周期。\n  - 保存 $12$ 个通用寄存器，每个 $2$ 个周期：$24$ 个周期。\n  - 切换到中断状态的模式：$2$ 个周期。\n- 针对热点设备的基线 ISR 主体工作：\n  - 读取状态寄存器：$3$ 个周期。\n  - 读取数据寄存器：$3$ 个周期。\n  - 写入设备确认：$3$ 个周期。\n  - 算术和逻辑运算：$4$ 个周期。\n  - 条件分支：$3$ 个周期。\n- 基线中断退出序列成本：\n  - 向 PIC 写入中断结束（EOI）：$3$ 个周期。\n  - 恢复 $12$ 个寄存器，每个 $2$ 个周期：$24$ 个周期。\n  - 从中断返回指令：$4$ 个周期。\n  - 流水线重新填充：$5$ 个周期。\n\n您最多可以启用以下微架构优化策略中的一种；它们不能组合使用：\n\n- 策略 S1（向量缓存和优先级屏蔽）：消除 PIC 握手和片外向量获取；通过屏蔽到单一来源将优先级解析减少到 $1$ 个周期；在 PIC 中启用自动 EOI，从而无需在退出时显式写入 EOI。\n- 策略 S2（带分组寄存器的快速中断请求 (FIRQ)）：仅保存/恢复 $4$ 个寄存器，每个 $2$ 个周期（其余由分组寄存器覆盖）；将向量表重定位到片上暂存器，以实现 $1$ 个周期的向量获取；其他进入和退出活动保持不变。\n- 策略 S3（针对来自同一来源的连续中断的硬件尾链）：当退出时有新的中断挂起，硬件会绕过完整的退出和下一次的完整进入过程。从一个 ISR 实例到下一个实例的稳态转换会产生一个固定的 $14$ 个周期的链边界开销（包括 $1$ 个周期的优先级检查，$1$ 个周期重用相同向量，$8$ 个周期的最小流水线调整，以及 $4$ 个周期的内务处理，包括 EOI）。在稳态下，每个事件的成本是 ISR 的工作量加上这个链边界开销。\n\n假设系统被同一高优先级设备持续饱和，因此稳态假设适用。基于 $f_{clk}$ 和周期计数，从第一性原理推导每种策略的稳态事件率（事件/秒），然后确定 S1、S2 和 S3 中可实现的最大稳态事件率。以事件/秒为单位表示最终速率，并将最终报告的答案四舍五入到四位有效数字。",
            "solution": "目标是确定在三种不同的微架构优化策略下，单个高优先级中断源可实现的最大稳态事件率。事件率 $R$ 是时钟频率 $f_{clk}$ 除以每个事件的总时钟周期数 $T_{total}$。\n$$R = \\frac{f_{clk}}{T_{total}}$$\n给定时钟频率为 $f_{clk} = 250 \\times 10^{6}\\,\\text{Hz}$。我们必须计算每种策略的 $T_{total}$。\n\n首先，我们通过对中断处理的三个阶段——进入、ISR 主体工作和退出——的周期计数求和，来确定基线成本。\n\nISR 主体工作的总周期数 $T_{work}$ 在所有情景中都是恒定的。\n$T_{work} = (\\text{读取状态}) + (\\text{读取数据}) + (\\text{写入确认}) + (\\text{ALU 操作}) + (\\text{分支})$\n$T_{work} = 3 + 3 + 3 + 4 + 3 = 16$ 个周期。\n\n基线进入成本 $T_{entry,base}$ 为：\n$T_{entry,base} = (\\text{PIC 确认}) + (\\text{优先级解析}) + (\\text{向量获取}) + (\\text{流水线刷新}) + (\\text{保存寄存器}) + (\\text{模式切换})$\n$T_{entry,base} = 3 + 3 + 3 + 5 + (12 \\times 2) + 2 = 3 + 3 + 3 + 5 + 24 + 2 = 40$ 个周期。\n\n基线退出成本 $T_{exit,base}$ 为：\n$T_{exit,base} = (\\text{写入 EOI}) + (\\text{恢复寄存器}) + (\\text{从中断返回}) + (\\text{流水线重填})$\n$T_{exit,base} = 3 + (12 \\times 2) + 4 + 5 = 3 + 24 + 4 + 5 = 36$ 个周期。\n\n基线总处理时间将是 $T_{total,base} = T_{entry,base} + T_{work} + T_{exit,base} = 40 + 16 + 36 = 92$ 个周期。\n\n现在，我们将分析每种策略，以找出其每个事件的总周期数。\n\n**策略 S1：向量缓存和优先级屏蔽**\n该策略对基线进入和退出序列的修改如下：\n- PIC 中断确认握手（$3$ 个周期）被消除。\n- 优先级解析从 $3$ 个周期减少到 $1$ 个周期。\n- 片外向量获取（$3$ 个周期）被消除。\n- 由于自动 EOI，退出时的显式 EOI 写入（$3$ 个周期）被消除。\n\n新的进入成本 $T_{entry,S1}$ 是应用了这些修改后的基线进入成本。\n$T_{entry,S1} = T_{entry,base} - 3_{\\text{ack}} - (3-1)_{\\text{prio}} - 3_{\\text{vector}} = 40 - 3 - 2 - 3 = 32$ 个周期。\n或者，从剩余部分计算：\n$T_{entry,S1} = 1_{\\text{prio}} + 5_{\\text{flush}} + 24_{\\text{save}} + 2_{\\text{mode}} = 32$ 个周期。\n\n新的退出成本 $T_{exit,S1}$ 是不含 EOI 写入的基线退出成本。\n$T_{exit,S1} = T_{exit,base} - 3_{\\text{EOI}} = 36 - 3 = 33$ 个周期。\n或者，从剩余部分计算：\n$T_{exit,S1} = 24_{\\text{restore}} + 4_{\\text{reti}} + 5_{\\text{refill}} = 33$ 个周期。\n\n策略 S1 的总周期计数是：\n$T_{total,S1} = T_{entry,S1} + T_{work} + T_{exit,S1} = 32 + 16 + 33 = 81$ 个周期。\n\n策略 S1 的事件率是：\n$R_{S1} = \\frac{f_{clk}}{T_{total,S1}} = \\frac{250 \\times 10^6}{81}$ 事件/秒。\n\n**策略 S2：带分组寄存器的快速中断请求 (FIRQ)**\n该策略对基线的修改如下：\n- 只保存和恢复 $4$ 个寄存器，每个耗时 $4 \\times 2 = 8$ 个周期，而不是 $12$ 个寄存器的 $24$ 个周期。\n- 向量获取来自片上存储器，耗时 $1$ 个周期而不是 $3$ 个周期。\n\n新的进入成本 $T_{entry,S2}$ 是应用了这些变化的基线进入成本。寄存器保存成本的减少量为 $24 - (4 \\times 2) = 16$ 个周期。向量获取成本的减少量为 $3 - 1 = 2$ 个周期。\n$T_{entry,S2} = T_{entry,base} - 16_{\\text{save}} - 2_{\\text{vector}} = 40 - 16 - 2 = 22$ 个周期。\n或者，从各部分计算：\n$T_{entry,S2} = 3_{\\text{ack}} + 3_{\\text{prio}} + 1_{\\text{vector}} + 5_{\\text{flush}} + (4 \\times 2)_{\\text{save}} + 2_{\\text{mode}} = 3+3+1+5+8+2 = 22$ 个周期。\n\n新的退出成本 $T_{exit,S2}$ 用减少的寄存器恢复成本更新。减少量为 $24 - (4 \\times 2) = 16$ 个周期。\n$T_{exit,S2} = T_{exit,base} - 16_{\\text{restore}} = 36 - 16 = 20$ 个周期。\n或者，从各部分计算：\n$T_{exit,S2} = 3_{\\text{EOI}} + (4 \\times 2)_{\\text{restore}} + 4_{\\text{reti}} + 5_{\\text{refill}} = 3+8+4+5 = 20$ 个周期。\n\n策略 S2 的总周期计数是：\n$T_{total,S2} = T_{entry,S2} + T_{work} + T_{exit,S2} = 22 + 16 + 20 = 58$ 个周期。\n\n策略 S2 的事件率是：\n$R_{S2} = \\frac{f_{clk}}{T_{total,S2}} = \\frac{250 \\times 10^6}{58}$ 事件/秒。\n\n**策略 S3：硬件尾链**\n这个策略有根本性的不同。在饱和稳态下，硬件会绕过来自同一来源的中断之间的完整退出和进入序列。每个事件的成本是 ISR 工作量加上一个固定的链边界开销。\n$T_{overhead,S3} = 14$ 个周期。\nISR 工作量保持为 $T_{work} = 16$ 个周期。\n\n策略 S3 的总周期计数是：\n$T_{total,S3} = T_{work} + T_{overhead,S3} = 16 + 14 = 30$ 个周期。\n\n策略 S3 的事件率是：\n$R_{S3} = \\frac{f_{clk}}{T_{total,S3}} = \\frac{250 \\times 10^6}{30}$ 事件/秒。\n\n**事件率比较**\n现在我们比较这三个速率以找到最大值。\n$R_{S1} = \\frac{250 \\times 10^6}{81} \\approx 3.086 \\times 10^6$ 事件/秒。\n$R_{S2} = \\frac{250 \\times 10^6}{58} \\approx 4.310 \\times 10^6$ 事件/秒。\n$R_{S3} = \\frac{250 \\times 10^6}{30} = \\frac{25}{3} \\times 10^6 \\approx 8.333 \\times 10^6$ 事件/秒。\n\n通过比较分母（$30  58  81$），很明显 $R_{S3}$ 是最大值。\n$R_{\\max} = R_{S3} = \\frac{250 \\times 10^6}{30} = 8333333.\\overline{3}$ 事件/秒。\n\n问题要求最终答案四舍五入到四位有效数字。\n$R_{\\max} \\approx 8.333 \\times 10^6$ 事件/秒。",
            "answer": "$$\\boxed{8.333 \\times 10^6}$$"
        },
        {
            "introduction": "真实世界的中断系统常常涉及多个设备共享同一根中断线，并且可能受到电气噪声的干扰，产生“伪中断”。如果对这些情况，特别是对电平触发中断处理不当，极易导致系统死锁或活锁。本练习  旨在挑战您通过选择正确的操作序列来设计一个健壮的中断服务程序（ISR），它将强化您对正确识别中断源、安全处理伪事件以及与中断控制器正确“握手”以确保系统稳定性的关键逻辑的理解。",
            "id": "3652686",
            "problem": "一个中央处理器 (CPU) 连接到一条共享的电平触发中断线，由一个可编程中断控制器 (PIC) 服务。该 PIC 对多条中断线执行固定优先级解析，并在任何设备置位该线路时向 CPU 传递一个中断向量 $v$。一组设备共享此线路，并公开一个内存映射的状态寄存器 $SR$，其位域 $\\{b_0, b_1, \\ldots, b_{m-1}\\}$ 指示待处理的中断源；读取 $SR$ 是原子性且无副作用的，而每个设备的中断原因在服务后通过写入设备的特定原因清除寄存器来清除。PIC 仅在接受到有效请求时为该线路设置一个服务中锁存器 $IS$；在罕见的由噪声引起的情况下，CPU 可能会在 $SR=0$ 时收到向量 $v$，而 PIC 并未为该事件设置 $IS$。中断结束 (EOI) 命令会为有效中断清除 $IS$。CPU 可以在中断服务程序 (ISR) 执行期间提高其中断优先级 (IPL)，以屏蔽相同或更低优先级的其他中断，其中 ISR 代表中断服务程序 (Interrupt Service Routine)。\n\n您必须选择一种 ISR 执行序列，既能正确处理真实中断，又能安全地处理由电气噪声引起的伪中断，而不会进入活锁。系统级要求如下：\n\n- 电平触发语义下的正确性：如果一个设备是真正的中断源，ISR 必须通过读取 $SR$ 来识别待处理的源，根据软件优先级函数 $\\pi : \\{0,1,\\ldots,m-1\\} \\to \\mathbb{N}$ 服务最高优先级的待处理源，并清除其中断原因，以使共享线路取消置位。只有在服务完有效源之后，ISR 才应向 PIC 发出 EOI。\n- 伪中断鲁棒性：如果在进入 ISR 时 $SR = 0$，ISR 必须检测到没有待处理的源，增加计数器 $C_{\\text{spurious}}$ 的值，然后返回且不产生活锁。在这种情况下，不应执行忙等待循环或重复确认。\n- 优先级管理规范：在服务期间，ISR 应防止对同一向量的重入，并避免在当前中断源处理完毕前被较低优先级的中断抢占。\n\n哪个选项最能满足这些要求？\n\nA. 进入时，提高 IPL 以屏蔽相同向量。读取一次 $SR$。如果 $SR = 0$，则增加 $C_{\\text{spurious}}$ 并返回，不发出 EOI。如果 $SR \\neq 0$，选择最高优先级的待处理位索引 $i^\\ast = \\arg\\min_{i \\in \\{0,\\ldots,m-1\\},\\, b_i=1} \\pi(i)$，服务设备 $i^\\ast$，清除其中断原因，然后向 PIC 发出 EOI，降低 IPL，并返回。\n\nB. 进入时，提高 IPL。在一个循环中持续轮询 $SR$ 直到 $SR \\neq 0$。当一个位被设置时，通过 $\\pi(\\cdot)$ 选择 $i^\\ast$，进行服务并清除，然后发出 EOI 并返回。如果 $SR$ 保持为 $0$，则无限期地继续轮询。\n\nC. 进入时，立即向 PIC 发出 EOI 以释放较低优先级的中断，然后读取 $SR$。如果 $SR = 0$，则增加 $C_{\\text{spurious}}$ 并返回。如果 $SR \\neq 0$，通过 $\\pi(\\cdot)$ 选择 $i^\\ast$，进行服务并清除，降低 IPL，并返回。\n\nD. 进入时，如果 $SR = 0$，则在 PIC 中屏蔽共享中断线，忙等待一段时间 $T$（其中 $T  0$）以查看 $SR$ 中是否有任何位被设置，如果没有，则增加 $C_{\\text{spurious}}$，取消对线路的屏蔽，并返回。如果 $SR \\neq 0$，通过 $\\pi(\\cdot)$ 选择 $i^\\ast$，进行服务并清除，发出 EOI，并返回。",
            "solution": "基于基本原理和所述要求，一个健壮的 ISR 必须按特定顺序执行其操作，以确保正确性和稳定性。\n\n1.  **优先级管理与重入防护**：进入 ISR 后，第一个动作必须是提高 CPU 的中断优先级（IPL），以防止当前的 ISR 被另一个相同或更低优先级的中断抢占，并防止对同一中断向量的重入。\n2.  **源识别与伪中断处理**：ISR 必须读取共享设备状态寄存器 $SR$。如果 $SR=0$，则中断是伪中断。此时不应发送 EOI，因为 PIC 的服务中锁存器未被设置。ISR 应记录事件并返回。\n3.  **有效中断处理**：如果 $SR \\neq 0$，ISR 必须服务最高优先级的源，清除设备端的中断条件，然后才能向 PIC 发送 EOI 命令。在清除源之前发送 EOI 会导致电平触发中断立即重新触发，造成活锁。\n\n基于以上原则对各选项进行分析：\n\n*   **选项 A**：完全遵循了上述正确序列。它首先提高 IPL，然后正确处理了伪中断（不发 EOI）和有效中断（服务 -> 清除源 -> 发送 EOI）两种情况。因此，此选项是正确的。\n\n*   **选项 B**：在遇到伪中断时会无限期轮询，这是一种活锁，违反了“无忙等待”的要求。因此，此选项不正确。\n\n*   **选项 C**：在 ISR 开始时就发送 EOI，这是处理电平触发中断的经典错误，会导致系统锁死。因此，此选项不正确。\n\n*   **选项 D**：在处理伪中断时引入了忙等待，违反了要求。此外，它没有在 ISR 开始时提高 IPL，无法防止重入。因此，此选项不正确。\n\n结论：选项 A 是唯一能够正确、安全地处理所有情况的序列。",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}