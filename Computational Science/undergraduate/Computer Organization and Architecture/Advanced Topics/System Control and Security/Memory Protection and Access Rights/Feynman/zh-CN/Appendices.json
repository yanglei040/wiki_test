{
    "hands_on_practices": [
        {
            "introduction": "我们从内存保护的核心机制开始。本练习将带你深入了解内存管理单元（MMU）如何检查页表条目中的读（$r$）、写（$w$）和执行（$x$）权限位。通过计算在不同权限设置下访问内存所产生的保护异常总数，你将对硬件如何逐个操作地实施访问控制有一个具体而清晰的认识。()",
            "id": "3658221",
            "problem": "在计算机系统中，单个虚拟内存页面由页表条目中维护的三个权限位保护：读权限位 $r$、写权限位 $w$ 和执行权限位 $x$。内存管理单元（MMU）强制执行这些权限：当且仅当 $r$ 被设置时，允许内存读取；当且仅当 $w$ 被设置时，允许内存写入；当且仅当 $x$ 被设置时，允许指令提取（执行）。任何当前权限位不允许的尝试操作都会导致保护异常（错误）。假设权限更改是原子的，并在指定时间立即生效，没有缓存延迟。\n\n在时间 $t_0$，页面的权限设置为 $(r, w, x)$，并尝试了 5 次读取、9 次写入和 7 次指令提取。在时间 $t_1$，权限更改为 $(r, \\neg w, \\neg x)$，并尝试了 11 次读取、4 次写入和 6 次指令提取。在时间 $t_2$，权限再次更改为 $(\\neg r, \\neg w, \\neg x)$，并尝试了 3 次读取、2 次写入和 1 次指令提取。计算这三个时间点上发生的保护异常总数。",
            "solution": "问题要求计算在一系列由变化的权限集控制的、在特定时间点进行的内存访问尝试所产生的保护错误的总数。问题的核心在于内存管理单元（MMU）强制执行的逻辑规则。\n\n我们将权限位的状态形式化。我们可以将权限集表示为一个向量 $(r, w, x)$，其中如果权限被授予（设置），则该位为 $1$；如果被拒绝（未设置），则为 $0$。三种操作类型是读取、写入和指令提取（执行）。\n\n强制执行的规则是：\n1.  当且仅当 $r=1$ 时，允许读取操作。当 $r=0$ 时尝试读取会导致错误。\n2.  当且仅当 $w=1$ 时，允许写入操作。当 $w=0$ 时尝试写入会导致错误。\n3.  当且仅当 $x=1$ 时，允许执行操作（指令提取）。当 $x=0$ 时尝试执行会导致错误。\n\n对于给定的操作类型，如果相应的权限位为 $0$，则错误数量为尝试次数；如果权限位为 $1$，则错误数量为零。\n\n设 $F_i$ 为时间 $t_i$ 的总错误数。设 $(r_i, w_i, x_i)$ 为时间 $t_i$ 的权限状态。设 $A_i, B_i, C_i$ 分别为在时间 $t_i$ 尝试的读取、写入和执行的次数。\n\n在时间 $t_i$ 每种操作类型的错误数可以表示为：\n- 读取错误: $F_{\\text{read}, i} = A_i \\cdot (1 - r_i)$\n- 写入错误: $F_{\\text{write}, i} = B_i \\cdot (1 - w_i)$\n- 执行错误: $F_{\\text{exec}, i} = C_i \\cdot (1 - x_i)$\n\n在时间 $t_i$ 的总错误数为 $F_i = F_{\\text{read}, i} + F_{\\text{write}, i} + F_{\\text{exec}, i}$。所有时间点的总错误数为 $F_{\\text{total}} = F_0 + F_1 + F_2$。\n\n我们现在将分析每个时间点的事件。\n\n**在时间 $t_0$ 的分析：**\n- 权限设置为 $(r, w, x)$。在我们的二进制表示法中，状态为 $(r_0, w_0, x_0) = (1, 1, 1)$。\n- 尝试的操作是 $A_0=5$ 次读取，$B_0=9$ 次写入，以及 $C_0=7$ 次指令提取。\n- 计算在 $t_0$ 的错误：\n  - 读取错误: $F_{\\text{read}, 0} = 5(1-1) = 0$。\n  - 写入错误: $F_{\\text{write}, 0} = 9(1-1) = 0$。\n  - 执行错误: $F_{\\text{exec}, 0} = 7(1-1) = 0$。\n- 在 $t_0$ 的总错误数为 $F_0 = 0 + 0 + 0 = 0$。\n\n**在时间 $t_1$ 的分析：**\n- 权限更新为 $(r, \\neg w, \\neg x)$。在我们的二进制表示法中，状态为 $(r_1, w_1, x_1) = (1, 0, 0)$。\n- 尝试的操作是 $A_1=11$ 次读取，$B_1=4$ 次写入，以及 $C_1=6$ 次指令提取。\n- 计算在 $t_1$ 的错误：\n  - 读取错误: $F_{\\text{read}, 1} = 11(1-1) = 0$。\n  - 写入错误: $F_{\\text{write}, 1} = 4(1-0) = 4$。\n  - 执行错误: $F_{\\text{exec}, 1} = 6(1-0) = 6$。\n- 在 $t_1$ 的总错误数为 $F_1 = 0 + 4 + 6 = 10$。\n\n**在时间 $t_2$ 的分析：**\n- 权限更新为 $(\\neg r, \\neg w, \\neg x)$。在我们的二进制表示法中，状态为 $(r_2, w_2, x_2) = (0, 0, 0)$。\n- 尝试的操作是 $A_2=3$ 次读取，$B_2=2$ 次写入，以及 $C_2=1$ 次指令提取。\n- 计算在 $t_2$ 的错误：\n  - 读取错误: $F_{\\text{read}, 2} = 3(1-0) = 3$。\n  - 写入错误: $F_{\\text{write}, 2} = 2(1-0) = 2$。\n  - 执行错误: $F_{\\text{exec}, 2} = 1(1-0) = 1$。\n- 在 $t_2$ 的总错误数为 $F_2 = 3 + 2 + 1 = 6$。\n\n**总错误数计算：**\n为了求出总错误数，我们将每个时间点的错误数相加：\n$$F_{\\text{total}} = F_0 + F_1 + F_2$$\n$$F_{\\text{total}} = 0 + 10 + 6 = 16$$\n因此，在这三个时间点上，总共会产生 $16$ 个保护错误。",
            "answer": "$$\n\\boxed{16}\n$$"
        },
        {
            "introduction": "最后，让我们将视野提升到系统层面，在这里多个进程共享内存资源。本练习引入了权限矩阵和系统级的安全不变量，例如“单写者”原则和“写异或执行”（W^X）策略。通过找出安全地授予和撤销权限所需的最小操作步骤，你将学会从动态管理的角度思考内存保护，理解在任何时候都必须维护整个系统的完整性。()",
            "id": "3658191",
            "problem": "考虑一个通过权限矩阵 $M \\in \\mathbb{Z}^{n \\times m}$ 来实施进程-页面内存保护的系统，其中条目 $M_{ij}$ 编码了进程 $i$ 对页面 $j$ 的访问权限。每个条目是集合 $\\{r,w,x\\}$ 上的一个位掩码，其中 $r \\mapsto 1$，$w \\mapsto 2$，$x \\mapsto 4$。权限通过组合其数值进行编码。例如，同时拥有 $r$ 和 $w$ 权限编码为 $1+2=3$，同时拥有 $r$ 和 $x$ 权限编码为 $1+4=5$。当前矩阵为\n$$\nM=\n\\begin{pmatrix}\n5  1  0 \\\\\n1  3  4 \\\\\n0  0  0 \\\\\n1  1  0\n\\end{pmatrix},\n$$\n行由进程 $i \\in \\{1,2,3,4\\}$ 索引，列由页面 $j \\in \\{1,2,3\\}$ 索引。必须始终保持两个系统不变量：\n\n1. 每页单写入者：对于每个页面 $j$，\n$$\n\\sum_{i=1}^{n} \\mathbf{1}_{\\{w \\in M_{ij}\\}} \\leq 1,\n$$\n其中，如果 $w$ 存在于 $M_{ij}$ 中，则 $\\mathbf{1}_{\\{w \\in M_{ij}\\}}$ 等于 $1$，否则为 $0$。\n\n2. 写异或执行 (W^X) 策略：如果对于页面 $j$ 存在任何进程 $i$ 使得 $x \\in M_{ij}$，那么对于所有进程 $k$，\n$$\nw \\notin M_{kj}.\n$$\n\n一个工作流要求进程 $p=3$ 在页面 $q=2$ 上获得 $(r,w)$ 访问权限，且仅在一次事务处理期间有效。访问权限可以通过翻转条目 $M_{ij}$ 中的单个权限位来更改；单次位翻转可将单个 $M_{ij}$ 中的 $\\{r,w,x\\}$ 之一从存在变为不存在，或反之。事务完成后必须恢复原始矩阵。确定所需的最少总位数翻转次数，以 (i) 达到一个状态，在该状态下进程 $3$ 对页面 $2$ 具有 $(r,w)$ 权限且两个不变量均成立，然后 (ii) 将矩阵恢复到其原始状态，并确保在整个更改序列中两个不变量始终成立。以位翻转的总整数计数形式提供最终答案。无需四舍五入。",
            "solution": "首先，我们将初始权限矩阵 $M$ 从其整数表示解码为权限集合。权限对应于矩阵条目二进制表示中的位：$x \\leftrightarrow 4$，$w \\leftrightarrow 2$，$r \\leftrightarrow 1$。\n初始矩阵是：\n$$\nM=\n\\begin{pmatrix}\n5  1  0 \\\\\n1  3  4 \\\\\n0  0  0 \\\\\n1  1  0\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\{r,x\\}  \\{r\\}  \\{\\} \\\\\n\\{r\\}  \\{r,w\\}  \\{x\\} \\\\\n\\{\\}  \\{\\}  \\{\\} \\\\\n\\{r\\}  \\{r\\}  \\{\\}\n\\end{pmatrix}\n$$\n接下来，我们验证初始状态是否满足两个不变量。\n- **不变量1 (单写入者)**：\n  - 页面 1：没有写入者。$0 \\leq 1$。成立。\n  - 页面 2：只有进程 2 拥有写权限 ($M_{22}=\\{r,w\\}$)。写入者总数为 $1 \\leq 1$。成立。\n  - 页面 3：没有写入者。$0 \\leq 1$。成立。\n- **不变量2 (W^X)**：\n  - 页面 1：进程 1 拥有执行权限。没有进程拥有对页面 1 的写权限。成立。\n  - 页面 2：没有进程拥有执行权限。不变量平凡成立。\n  - 页面 3：进程 2 拥有执行权限。没有进程拥有对页面 3 的写权限。成立。\n初始配置是有效的。\n\n#### 第 (i) 部分：为进程 3 获取权限\n\n目标是让进程 3 在页面 2 上获得 $\\{r,w\\}$ 访问权限。这意味着条目 $M_{32}$ 必须从 $0$（即 $\\{\\}$）更改为 $3$（即 $\\{r,w\\}$）。\n1.  为 $M_{32}$ 开启 'r' 位（从 $0$ 到 $1$）：这需要 1 次位翻转。此操作不影响任何不变量。\n2.  为 $M_{32}$ 开启 'w' 位（从 $1$ 到 $3$）：这需要 1 次位翻转。\n\n然而，在开启 $M_{32}$ 的 'w' 位之前，我们必须考虑不变量 1。最初，进程 2 对页面 2 拥有写权限 ($w \\in M_{22}$)。如果我们直接授予进程 3 写权限，页面 2 将同时有两个写入者，违反了不变量 1。因此，为了在整个序列中始终保持不变量，我们必须在授予进程 3 写权限之前，先撤销进程 2 的写权限。\n3.  为 $M_{22}$ 关闭 'w' 位（从 $3$ 到 $1$）：这需要 1 次位翻转。\n\n因此，一个保持不变量的有效操作序列如下：\n- **翻转 1**：为 $M_{22}$ 关闭 'w' 位。$M_{22}$ 从 $3 \\rightarrow 1$。现在页面 2 没有写入者。不变量成立。\n- **翻转 2**：为 $M_{32}$ 开启 'r' 位。$M_{32}$ 从 $0 \\rightarrow 1$。不变量成立。\n- **翻转 3**：为 $M_{32}$ 开启 'w' 位。$M_{32}$ 从 $1 \\rightarrow 3$。现在进程 3 是页面 2 的唯一写入者。不变量成立。\n\n第 (i) 部分所需的最少翻转次数为 3 次。\n\n#### 第 (ii) 部分：恢复原始状态\n\n事务完成后，矩阵必须从当前状态（$M_{22}=1$, $M_{32}=3$）恢复到其原始状态（$M_{22}=3$, $M_{32}=0$）。这需要撤销第 (i) 部分的操作。\n1.  为 $M_{32}$ 关闭 'r' 位（从 $3$ 到 $2$）：1 次翻转。\n2.  为 $M_{32}$ 关闭 'w' 位（从 $2$ 到 $0$）：1 次翻转。\n3.  为 $M_{22}$ 开启 'w' 位（从 $1$ 到 $3$）：1 次翻转。\n\n同样，我们必须注意不变量 1。当前，进程 3 是页面 2 的写入者。我们不能在撤销其写权限之前，就将写权限授予进程 2。因此，为 $M_{32}$ 关闭 'w' 位的操作必须先于为 $M_{22}$ 开启 'w' 位的操作。\n一个保持不变量的有效恢复序列如下：\n- **翻转 1**：为 $M_{32}$ 关闭 'w' 位。$M_{32}$ 从 $3 \\rightarrow 1$。现在页面 2 没有写入者。不变量成立。\n- **翻转 2**：为 $M_{22}$ 开启 'w' 位。$M_{22}$ 从 $1 \\rightarrow 3$。现在进程 2 是页面 2 的唯一写入者。不变量成立。\n- **翻转 3**：为 $M_{32}$ 关闭 'r' 位。$M_{32}$ 从 $1 \\rightarrow 0$。矩阵恢复到原始状态。不变量成立。\n\n第 (ii) 部分所需的最少翻转次数为 3 次。\n\n#### 总翻转次数\n\n最少总位数翻转次数是两部分翻转次数的总和。\n总翻转次数 = (第 i 部分的翻转次数) + (第 ii 部分的翻转次数) = $3 + 3 = 6$。",
            "answer": "$$\\boxed{6}$$"
        }
    ]
}