## 引言
旁路信道攻击是现代计算安全领域中一个深刻而普遍的威胁。与利用软件漏洞的传统攻击不同，它通过观测计算过程的物理副产品——如[功耗](@entry_id:264815)、执行时间或[电磁辐射](@entry_id:152916)——来窃取敏感信息。这种攻击揭示了一个基本事实：任何计算系统的物理实现都可能无意中泄露其处理的数据，这为构建真正安全的系统带来了巨大挑战。本文旨在系统性地剖析旁路信道攻击。在“原理与机制”一章中，我们将深入探讨信息如何通过[微架构](@entry_id:751960)[状态和](@entry_id:193625)[资源竞争](@entry_id:191325)泄露。接着，在“应用与[交叉](@entry_id:147634)学科联系”一章中，我们将展示这些原理在密码学、[操作系统](@entry_id:752937)和异构系统等真实场景中的广泛应用。最后，通过“动手实践”部分，读者将有机会通过具体问题来巩固和应用所学知识，将理论与实践紧密结合。

## 原理与机制

继前一章对旁路信道攻击进行总体介绍之后，本章将深入探讨其核心原理与具体实现机制。我们将揭示，计算过程并非如其在软件层面表现出的那般抽象；相反，它在硬件中会引发一系列可观测的物理效应。正是这些效应，为攻击者打开了一扇窥探机密信息的大门。我们将系统地分析信息是如何通过处理器[微架构](@entry_id:751960)的“状态”和共享“资源”的“竞争”来泄露的，并探讨这些攻击在物理层面的表现形式，最后讨论如何从噪声中提取出微弱的泄露信号。

### 基本原理：状态、竞争与数据依赖性

所有旁路信道攻击都根植于一个共同的来源：**数据依赖性（Data Dependency）**。当计算机执行程序时，其操作指令的序列或操作数据本身，都会对硬件的[状态和](@entry_id:193625)性能产生影响。攻击者通过精确测量这些影响，便能反推出其背后的机密数据。这些信道大体可分为两大类：

1.  **基于状态的信道（State-based Channels）**：当一个依赖于机密数据的操作执行后，它会在系统的[微架构](@entry_id:751960)（如缓存、分支预测器）或物理状态（如[电荷](@entry_id:275494)）中留下可观测的痕“迹”。即使该操作在软件层面是瞬时的，其在硬件层面留下的状态变化也可能是持久的。攻击者可以通过后续操作来“探测”这些状态，从而推断出机密信息。

2.  **基于竞争的信道（Contention-based Channels）**：现代处理器为了提升性能，大量采用共享资源（如执行单元、缓存、[内存控制器](@entry_id:167560)）。当一个依赖于机密数据的程序（受害者）运行时，它对这些共享资源的使用模式会随之改变。一个并行的攻击者程序可以通过测量自身访问这些资源时的性能变化（如延迟增加或[吞吐量](@entry_id:271802)下降），来感知受害者的行为，进而推断机密。

一个常见的误区是，认为只要代码的执行路径不依赖于机密数据，即所谓的“恒定时间（Constant-Time）”编程，就能杜绝所有旁路信道。然而，这仅仅消除了因控制流变化（如分支）导致的**时序信道（Timing Channels）**。数据本身的位模式（Bit Pattern）依然可以在其他维度上产生可观测的效应。

例如，考虑一个用于比较两个数组 `a` 和 `b` 是否相等的无分支实现。该算法循环计算 $x_i = a_i \oplus b_i$（位异或），并累加结果 $d_{i+1} = d_i \lor x_i$（位或），初始值 $d_0 = 0$。最终通过检查 $d_n$ 是否为零来判断数组是否相等。这个算法的指令序列是固定的，不随输入数据变化。然而，其[功耗](@entry_id:264815)并非恒定。在[CMOS](@entry_id:178661)电路中，动态[功耗](@entry_id:264815)主要源于晶体管的开关活动，即比特位从 $0$ 变为 $1$ 或从 $1$ 变为 $0$。一个常用的[功耗](@entry_id:264815)模型是，当一个新值被写入寄存器时，产生的能耗与新旧值之间的**汉明距离（Hamming Distance, HD）**，即不同比特位的数量，成正比。在上述算法中，中间值 $x_i$ 和[累加器](@entry_id:175215)值 $d_{i+1}$ 都直接依赖于操作数 $b_i$ 的位模式。因此，每一次写操作的[功耗](@entry_id:264815)都会因 $b_i$ 的不同而变化。一个精确的功耗模型，如基于寄存器或总线上承载的 $\{x_i\}$ 和 $\{d_i\}$ 序列的汉明距离模型，能够捕获这种一阶（First-order）的[数据依赖](@entry_id:748197)性[功耗](@entry_id:264815)泄露。因此，即便没有分支，操作数 $b_i$ 的位模式依然通过[数据依赖](@entry_id:748197)的开关活动影响着动态[功耗](@entry_id:264815)，为[功耗](@entry_id:264815)分析攻击留下了窗口 。

### [微架构](@entry_id:751960)状态信道

处理器的内部状态远比程序员在[指令集架构](@entry_id:172672)（ISA）层面看到的寄存器和内存要复杂得多。这些被称为[微架构](@entry_id:751960)的状态组件，如缓存和分支预测器，虽然对程序透明，却会因程序的执行而改变，从而成为[信息泄露](@entry_id:155485)的载体。

#### 缓存作为旁路信道

缓存（Cache）是现代处理器中用于弥合CPU速度与主存速度鸿沟的关键组件。访问缓存中的数据（命中，Hit）远快于从[主存](@entry_id:751652)中获取数据（未命中，Miss），这一显著的时间差异是缓存旁路信道的基础。

要理解缓存如何泄露信息，我们必须首先理解内存地址是如何映射到缓存中的。一个内存地址通常被划分为三个部分：**标签（Tag）**、**索引（Set Index）**和**块偏移（Block Offset）**。
- **块偏移**：地址的最低几位，用于确定数据在缓存行（Cache Line）内的具体位置。
- **索引**：接下来的几位，用于选择数据应存放在缓存的哪个“组”（Set）中。
- **标签**：地址的最高几位，用于在一个组内的多个缓存行中，唯一标识具体的内存块。

当攻击者能够分辨出一次访存操作访问了哪个缓存组时，他实际上就获知了该内存地址的**索引位**。假设一个[直接映射缓存](@entry_id:748451)（Direct-mapped Cache）有 $S$ 个组，每个缓存行大小为 $B$ 字节。一个[查找表](@entry_id:177908)例程访问数组 $T$ 的第 $x$ 个元素，地址为 $A_0 + x$（$A_0$ 为基地址且与缓存行对齐）。攻击者可以通过经典的**素数+探测（Prime+Probe）**攻击获知访问命中了哪个缓存组。由于访问同一缓存行内的不同字节在时间上无法区分（若已命中），地址的块偏移部分（即 $x$ 的最低 $\log_2(B)$ 位）不会泄露。而地址的高位（标签）决定了是否命中，但仅通过探测哪个组被访问，并不能直接得到标签值。真正泄露的是由地址中间位决定的组索引。因此，攻击者学到的是关于 $x$ 的高于最低 $\log_2(B)$ 位的信息。攻击能够区分的，是那些映射到不同缓存组索引的 $x$ 值。更精确地说，每次测量将 $x$ 的可能值划分到一个等价类中，该[等价类](@entry_id:156032)由共享相同组索引的索引值构成。理论上，每次访问泄露的[信息量](@entry_id:272315)上限由缓存的几何结构和被访问数据的大小共同决定，约为 $\min(\log_2(S), \log_2(N/B))$ 比特，其中 $N$ 是数组 $T$ 的总字节数 。

#### [推测执行](@entry_id:755202)与瞬态状态

为了追求极致性能，现代处理器广泛采用**[乱序执行](@entry_id:753020)（Out-of-Order Execution）**和**[推测执行](@entry_id:755202)（Speculative Execution）**。处理器会预测分支的结果并提前执行后续指令。如果预测错误，这些[推测执行](@entry_id:755202)的指令将被“撤销”（squashed），其对**架构状态**（如寄存器文件、内存）的修改会被回滚，仿佛从未发生。然而，一个颠覆性的发现是，这些“瞬态”指令对**[微架构](@entry_id:751960)状态**的修改往往不会被回滚。

这构成了如Spectre等攻击的基础。设想一个场景：一条[推测执行](@entry_id:755202)路径上的加载指令，其访问的内存地址由一个机密值决定。虽然这条指令最终因为分支预测错误而被撤销，但它在被撤销前已经“触碰”了内存系统。这个加载操作会在[微架构](@entry_id:751960)层面留下痕迹。例如：
- **[数据缓存](@entry_id:748188)**：机密值索引的缓存行会被加载到L1[数据缓存](@entry_id:748188)中。
- **分支预测器**：推测路径上的分支会更新分支历史和模式历史表。
- **转译后备缓冲器（TLB）**：为机密地址进行的[虚拟到物理地址转换](@entry_id:756527)结果会被缓存到TLB中。

当处理器发现预测错误并清空[推测执行](@entry_id:755202)的指令时，上述这些[微架构](@entry_id:751960)组件的状态可能并未恢复。攻击者可以在[推测执行](@entry_id:755202)事件发生后，通过时序测量（如Prime+Probe）来探测这些持久化的[微架构](@entry_id:751960)状态，从而反推出[瞬态执行](@entry_id:756108)过程中使用的机密值 。这揭示了一个深刻的原理：即使在架构层面不可见的操作，也可能在[微架构](@entry_id:751960)层面产生可观测的、持久的副作用。

#### 分支预测器作为信道

分支预测器本身也是一个复杂的[状态机](@entry_id:171352)，它的状态会根据历史分支结果进行调整，因此也能成为[信息泄露](@entry_id:155485)的载体。一个典型的两级全局历史分支预测器包含一个**全局历史寄存器（Global History Register, GHR）**和一个**模式历史表（Pattern History Table, PHT）**。GHR记录最近的分支结果，其值用于索引PHT，而PHT中的条目（通常是[2位饱和计数器](@entry_id:746151)）则根据历史模式来预测当前分支是“跳转（Taken）”还是“不跳转（Not Taken）”。

如果一个分支的跳转行为与某个机密比特 $s$ 相关（例如，当 $s=1$ 时跳转概率为 $p_1$，当 $s=0$ 时为 $p_0$），那么重复执行这个分支就会“训练”GHR指向的那个PHT计数器。攻击者可以预先将目标PHT条目置于一个已知的状态（例如“弱跳转”），然后让受害者程序执行这个与机密相关的分支。如果分支的实际结果与预测不符，就会发生**分支预测错误（Misprediction）**，导致[处理器流水线](@entry_id:753773)被清空和重建，从而引入一个显著的额外延迟 $\Delta t$。通过多次测量并平均受害者程序的执行时间，攻击者可以分辨出两种机密值下不同的平均预测错误率，从而推断出机密 $s$ 的值 。

### [资源竞争](@entry_id:191325)信道

与利用状态变化不同，竞争信道利用的是多个逻辑单元对同一个物理资源的争用。当受害者程序对某个共享资源的使用强度依赖于机密数据时，攻击者可以通过测量自己在使用该资源时感受到的“拥堵”程度来推断机密。

#### CPU核内竞争：[同时多线程](@entry_id:754892)

**[同时多线程](@entry_id:754892)（Simultaneous Multithreading, SMT）**，如英特尔的超线程技术，允许在单个物理CPU核上同时运行多个硬件线程（逻辑核）。这些线程共享核心的关键资源，如执行单元、缓存和缓冲区。这种共享为跨线程的旁路信道创造了温床。

一个典型的例子是**执行端口（Execution Ports）**的竞争。一个SMT物理核拥有多个独立的执行端口，用于分发不同类型的[微操作](@entry_id:751957)（如算术、加载、存储）。假设核上有两个端口 $p_0$ 和 $p_1$，容量分别为每周期 $C_0=2$ 和 $C_1=1$ 个[微操作](@entry_id:751957)。攻击者线程可以构造一个循环，每个迭代都需要一个 $p_0$ 操作和一个 $p_1$ 操作。受害者线程的执行路径则依赖于机密比特 $s$：若 $s=0$，它持续向 $p_0$ 发送大量操作；若 $s=1$，则持续占用 $p_1$。

根据**瓶颈原则（Bottleneck Principle）**，一个需要多种资源的工作流，其最终性能受限于最稀缺的那个资源。
- 当 $s=0$ 时，受害者与攻击者竞争 $p_0$。在公平仲裁下，攻击者获得 $p_0$ 服务率的一半，即 $C_0/2 = 1$。它独占 $p_1$，获得服务率 $C_1=1$。攻击者的吞吐量瓶颈是 $\min(1, 1) = 1$ 次迭代/周期。
- 当 $s=1$ 时，受害者与攻击者竞争 $p_1$。攻击者获得 $p_1$ 服务率的一半，即 $C_1/2 = 1/2$。它独占 $p_0$，获得服务率 $C_0=2$。此时瓶颈变为 $p_1$，吞吐量降为 $\min(2, 1/2) = 1/2$ 次迭代/周期。

通过测量自身[吞吐量](@entry_id:271802)的变化（$1$ vs $1/2$），攻击者可以清晰地分辨出受害者的行为，从而推断出机密 $s$ 。

除了执行端口，SMT线程还共享处理缓存未命中的**行填充缓冲区（Line Fill Buffers, LFB）**或**未命中状态保持寄存器（MSHRs）**。这些缓冲区容量有限。如果受害者线程因机密相关操作（如一次“存储风暴”）产生大量缓存未命中，将迅速占满共享的LFB。当攻击者线程的加载操作也发生缓存未命中时，会因为没有可用的LFB条目而被迫[停顿](@entry_id:186882)（Stall），产生**背压（Backpressure）**。这种停顿会显著增加攻击者的加载延迟。通过将LFB[系统建模](@entry_id:197208)为一个有限容量的队列，我们可以看到，当总的未命中[到达率](@entry_id:271803)（$\lambda_{rfo} + \lambda_{lm}$）超过服务率（$\mu$）时，系统饱和，导致可观测的排队延迟 。

#### [存储层次结构](@entry_id:755484)中的竞争

[资源竞争](@entry_id:191325)不仅限于单个SMT核心内部，它可以延伸到整个[存储层次结构](@entry_id:755484)，甚至实现跨物理核心的攻击。

- **DRAM竞争**：动态随机存取存储器（DRAM）的性能行为也非均一。D[RAM](@entry_id:173159)被组织成多个Bank，每个Bank有一个**行缓冲区（Row Buffer）**。访问已在行缓冲区中的数据（[行命中](@entry_id:754442)）速度很快（时间 $t_r$），而访问不同行的数据（[行冲突](@entry_id:754441)或行未命中）则需要先关闭当前行再打开新行，速度慢得多（时间 $t_m > t_r$）。如果受害者程序的内存访问模式（例如，是倾向于重复访问同一行，还是在两行之间交替访问）与机密 $b$ 相关，那么它产生的[行命中](@entry_id:754442)概率 $q_b$ 就会随之变化。攻击者可以通过在同一Bank制造流量并观察平均服务时间的改变，或者，更[隐蔽](@entry_id:196364)地，通过另一个核心的活动引发的D[RAM](@entry_id:173159)总线拥堵来感知受害者的行为。受害者的平均访存时间可以被建模为 $\mathbb{E}[\overline{T} \mid b] = q_b t_r + (1 - q_b) t_m$，其变化直接泄露了关于 $q_b$ 进而关于 $b$ 的信息 。

- **跨核缓存竞争**：在[多核处理器](@entry_id:752266)中，各核心通常拥有私有的L1和L2缓存，但共享一个**末级缓存（Last-Level Cache, LLC）**。这种共享结构使得一个核心上的恶意程序可以监控甚至影响另一个核心的内存访问行为。一个位于核心 $j$ 的受害者进程，其产生的L2缓存未命中会向上访问共享的LLC。这些访问请求会成为一个位于核心 $i$ 的攻击者进程的“背景流量”。通过将共享资源（如LLC的某个Bank、连接各核心的片上互联网络、共享的D[RAM](@entry_id:173159)控制器）建模为[排队系统](@entry_id:273952)，我们可以清晰地看到泄露机制：
    1.  **LLC Bank竞争**：如果受害者和攻击者的内存访问恰好映射到同一个LLC Bank，它们的请求将在该Bank的端口处排队，直接增加访问延迟 [@problem_id:3676174, A]。
    2.  **DRAM控制器竞争**：即使访问映射到不同的LLC Bank，如果它们都在LLC中未命中，最终都会汇集到共享的DRAM控制器处排队。高强度的受害者内存活动可以使DRAM控制器饱和，从而显著增加攻击者自身LLC未命中的服务延迟 [@problem_id:3676174, C]。
    3.  **互联网络竞争**：所有核心与LLC之间的[数据传输](@entry_id:276754)都需经过共享的片上互联网络。高流量同样会在此处造成拥堵和仲裁延迟。
    4.  **[硬件预取](@entry_id:750156)器效应**：受害者的访问模式可能触发[硬件预取](@entry_id:750156)器，产生额外的、攻击者不可见的内存请求。这些预取请求同样会消耗上述共享资源，即使受害者本身的访存需求不大，也可能放大竞争效应，产生可观测的信号 [@problem_id:3676174, E]。

### 物理旁路信道：功耗

除了通过测量时间来推断信息外，攻击者还可以直接测量计算过程产生的物理辐射，其中最典型的是**[功耗](@entry_id:264815)分析（Power Analysis）**。如前所述，[CMOS](@entry_id:178661)电路的动态[功耗](@entry_id:264815)与晶体管的开关活动密切相关。当数据在处理器内部被处理、传输和存储时，其位模式的变化会直接反映在[功耗](@entry_id:264815)曲线上。

一个基础且强大的模型是**汉明重量（Hamming Weight, HW）**模型。汉明重量指一个比特向量中“1”的个数。在许多操作中，例如一个字节的数据从总线驱动器发出，其消耗的能量近似地与这个字节的汉明重量成正比。更通用的模型是[汉明距离](@entry_id:157657)模型，能耗与新旧两个状态之间的[汉明距离](@entry_id:157657)成正比。

考虑一个密码学操作，其中一个固定的密钥字节 $k$ 与一个输入的明文字节 $p$ 进行异或操作，结果为 $k \oplus p$。假设这个结果被写入一个寄存器。该操作的[功耗](@entry_id:264815)中，与数据相关的部分将与 $HW(k \oplus p)$ 强相关。攻击者可以精确测量每次操作的[功耗](@entry_id:264815)，并根据不同的明文 $p$ 值，建立功耗与 $HW(k \oplus p)$ 之间关系的假设。通过统计分析（如差分功耗分析，DPA），攻击者可以确定哪个密钥假设 $k$ 值能最好地解释观测到的[功耗](@entry_id:264815)变化。我们可以通过计算由数据引入的功耗[方差](@entry_id:200758) $\operatorname{Var}_{p}[P]$，并将其与背景噪声[方差](@entry_id:200758) $\sigma_{\eta}^{2}$ 比较，来量化这个信号的可区分度，即[信噪比](@entry_id:185071) 。

### 信号、噪声与测量

在实践中，旁路信道泄露的“信号”通常非常微弱，并且淹没在巨大的测量噪声和[微架构](@entry_id:751960)噪声中。因此，成功的攻击不仅需要理解泄露的物理机制，还需要运用信号处理技术来提取信号。

核心概念是**信噪比（Signal-to-Noise Ratio, SNR）**，它量化了信号强度与噪声强度的比值。攻击者的目标是通过各种手段提高SNR，直到能够以足够低的错误率做出决策。例如，在前述的分支预测攻击中，信号强度与平均时间差 $|\mu_1 - \mu_0| = \Delta t |p_1 - p_0|$ 成正比，而噪声主要由测量误差 $\sigma$ 决定。为了达到目标错误率 $\alpha$，攻击者需要的测量次数 $n$ 必须满足 $n \ge \left( \frac{2\sigma Q^{-1}(\alpha)}{\Delta t |p_1 - p_0|} \right)^2$，其中 $Q^{-1}$ 是标准[高斯分布](@entry_id:154414)的逆尾函数。这表明，信号越弱或噪声越强，就需要越多的样本来可靠地分辨信号 。

一个至关重要的技术是**信号聚合（Signal Aggregation）**。当单次测量的信号太弱而无法检测时，攻击者可以通过重复执行目标操作 $n$ 次并测量其总时间来放大信号。这种“时间驱动”的测量策略在对抗诸如粗粒度计时器等防御措施时尤其有效。假设单次操作的信号（平均时间差）为 $\delta$，[微架构](@entry_id:751960)噪声[方差](@entry_id:200758)为 $\sigma^2$，而计时器引入的量化噪声[方差](@entry_id:200758)为 $q^2/12$。
- **访问驱动（单次测量）**的SNR约为 $\text{SNR}_{\text{access}} = \frac{\delta^2}{\sigma^2 + q^2/12}$。
- **时间驱动（$n$ 次聚合）**的总信号为 $n\delta$，而总噪声[方差](@entry_id:200758)为 $n\sigma^2 + q^2/12$（[微架构](@entry_id:751960)噪声累加，[量化噪声](@entry_id:203074)仅作用于最终的总时间）。其SNR为 $\text{SNR}_{\text{time}}(n) = \frac{(n\delta)^2}{n\sigma^2 + q^2/12}$。

关键在于，信号的平方（与决策能力相关）以 $n^2$ 的速度增长，而噪声[方差](@entry_id:200758)的增长速度则慢得多（近似于 $n$）。这意味着 $\text{SNR}_{\text{time}}(n)$ 是 $n$ 的增函数。因此，即使 $\text{SNR}_{\text{access}}$ 低于攻击所需的阈值 $\tau$，攻击者几乎总能通过选择一个足够大的 $n$ 来使得 $\text{SNR}_{\text{time}}(n) \ge \tau$。这揭示了通过大量重复测量来克服噪声和防御措施的基本攻击策略 。