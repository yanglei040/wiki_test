{
    "hands_on_practices": [
        {
            "introduction": "Many side-channel attacks rely on measuring time differences that are far smaller than the resolution of typical software-accessible timers. This foundational exercise explores the essential technique of signal amplification, a cornerstone for turning such theoretical vulnerabilities into practical exploits. By methodically repeating an operation, we can magnify a minuscule timing discrepancy until it becomes reliably detectable, demonstrating how persistence can overcome the limitations of our measurement tools .",
            "id": "3676151",
            "problem": "An attacker is mounting a timing side-channel attack on a Central Processing Unit (CPU) by measuring the time of a code path that may include exactly one extra Last-Level Cache (LLC) miss. The one-miss penalty adds a small true-time increment of size $\\delta$ to the execution time relative to a miss-free baseline, with $\\delta \\ll \\Delta$. The available timer has finite resolution $\\Delta$: any true elapsed time $T$ is returned as the largest multiple of $\\Delta$ not exceeding $T$.\n\nThe attacker can amplify the timing difference by repeating the same measurement-sensitive operation back-to-back $R$ times and then reading the timer once, both for the baseline path and for the path that incurs one extra miss per operation. Assume all other noise sources are negligible compared to quantization due to the timer resolution, and that the true per-operation miss penalty $\\delta$ is constant and independent across repetitions.\n\nStarting only from the following fundamental bases:\n- If a single operation exhibits a true-time difference of $\\delta$ between two conditions, $R$ identical back-to-back repetitions exhibit a true-time difference of $R \\delta$ between those conditions.\n- The timer returns measured time $M(T) = \\Delta \\left\\lfloor \\frac{T}{\\Delta} \\right\\rfloor$ for a true time $T$, where $\\left\\lfloor \\cdot \\right\\rfloor$ is the floor function.\n\nDerive a condition on $R$ that guarantees the two measured times (baseline versus one-miss-per-operation) will be different for any possible alignment of the true time within a quantization bin. Then, determine the minimal integer $R$ that satisfies this condition. Express your final answer as a single closed-form analytical expression in terms of $\\Delta$ and $\\delta$.",
            "solution": "The problem requires the derivation of a condition on the number of repetitions, $R$, that guarantees a measurable timing difference, and from this, the minimal integer value of $R$. The analysis will proceed from the fundamental definitions provided.\n\nFirst, let us define the true execution times. Let $T_{0}$ be the true execution time of the baseline (miss-free) operation.\nThe true execution time for $R$ repetitions of the baseline path is:\n$$T_{base} = R T_{0}$$\n\nThe path with one extra miss per operation has a true execution time of $T_{0} + \\delta$ for a single operation. For $R$ back-to-back repetitions, the true execution time is:\n$$T_{miss} = R (T_{0} + \\delta) = R T_{0} + R \\delta$$\n\nThe timer has a finite resolution $\\Delta$. The measured time $M$ for a true time $T$ is given by the function:\n$$M(T) = \\Delta \\left\\lfloor \\frac{T}{\\Delta} \\right\\rfloor$$\nwhere $\\lfloor \\cdot \\rfloor$ is the floor function.\n\nApplying this to our two scenarios, the measured time for the baseline path is:\n$$M_{base} = M(T_{base}) = \\Delta \\left\\lfloor \\frac{R T_{0}}{\\Delta} \\right\\rfloor$$\n\nThe measured time for the path with misses is:\n$$M_{miss} = M(T_{miss}) = \\Delta \\left\\lfloor \\frac{R T_{0} + R \\delta}{\\Delta} \\right\\rfloor$$\n\nThe objective is to find a condition on $R$ that guarantees $M_{miss} \\neq M_{base}$ for any possible value of $T_{0}$. Since the miss penalty $\\delta$ is a positive time increment, $T_{miss} > T_{base}$. Consequently, the measured time cannot decrease, so $M_{miss} \\ge M_{base}$. The condition for the measured times to be different is therefore equivalent to requiring $M_{miss} > M_{base}$.\n\n$$ \\Delta \\left\\lfloor \\frac{R T_{0} + R \\delta}{\\Delta} \\right\\rfloor > \\Delta \\left\\lfloor \\frac{R T_{0}}{\\Delta} \\right\\rfloor $$\n\nDividing by $\\Delta$ (which is a positive time quantity) preserves the inequality:\n$$ \\left\\lfloor \\frac{R T_{0}}{\\Delta} + \\frac{R \\delta}{\\Delta} \\right\\rfloor > \\left\\lfloor \\frac{R T_{0}}{\\Delta} \\right\\rfloor $$\n\nLet us introduce the dimensionless variables $x = \\frac{R T_{0}}{\\Delta}$ and $y = \\frac{R \\delta}{\\Delta}$. The required condition becomes:\n$$ \\lfloor x + y \\rfloor > \\lfloor x \\rfloor $$\nThis inequality must hold for any value of $x \\ge 0$, because the baseline time $T_{0}$ is unknown and can result in any \"alignment of the true time within a quantization bin\". The variable $x$ represents this alignment, scaled by the number of repetitions $R$.\n\nThe inequality $\\lfloor x + y \\rfloor > \\lfloor x \\rfloor$ fails to hold if and only if there is no integer in the interval $(x, x+y]$. This situation, $\\lfloor x+y \\rfloor = \\lfloor x \\rfloor$, poses the greatest challenge to the attacker. We need to find a condition on $y$ (and thus on $R$) that prevents this equality from being possible for any $x$.\n\nThe worst-case scenario for distinguishing the times occurs when the baseline true time $T_{base}$ (and thus $x$) is positioned such that the addition of the amplified penalty $R\\delta$ (and thus $y$) is least likely to cross an integer boundary of the timer resolution. This happens when the baseline time $T_{base}$ is just slightly greater than a multiple of $\\Delta$.\n\nLet us formalize this. Let $k = \\lfloor x \\rfloor$ be an integer. The value of $x$ can be written as $x = k + \\epsilon$, where $0 \\le \\epsilon < 1$. The variable $\\epsilon$ represents the fractional part of $x$, corresponding to the alignment within a timer quantization interval. The problem states that this must hold for *any* possible alignment, so we must consider all possible values of $\\epsilon \\in [0, 1)$.\n\nThe inequality becomes:\n$$ \\lfloor k + \\epsilon + y \\rfloor > \\lfloor k + \\epsilon \\rfloor $$\nSince $k$ is an integer and $0 \\le \\epsilon < 1$, we have $\\lfloor k + \\epsilon \\rfloor = k$. The condition is:\n$$ \\lfloor k + \\epsilon + y \\rfloor > k $$\nThis is equivalent to requiring:\n$$ k + \\epsilon + y \\ge k+1 $$\n$$ \\epsilon + y \\ge 1 $$\n\nThis inequality, $y \\ge 1 - \\epsilon$, must be satisfied for all possible values of $\\epsilon \\in [0, 1)$. To guarantee this, we must satisfy the inequality for the \"worst-case\" value of $\\epsilon$, which is the value that makes the condition hardest to meet. The right-hand side, $1-\\epsilon$, is maximized when $\\epsilon$ is minimized. The lower bound of $\\epsilon$ is $0$. To ensure the condition holds for an arbitrarily small positive $\\epsilon$, we must consider the limit as $\\epsilon \\to 0^{+}$.\nIn this limit, the condition becomes:\n$$ y \\ge 1 $$\n\nSubstituting back $y = \\frac{R\\delta}{\\Delta}$:\n$$ \\frac{R\\delta}{\\Delta} \\ge 1 $$\n$$ R\\delta \\ge \\Delta $$\n\nThis is the general condition on $R$ that guarantees the measured times will be different, regardless of the initial timing alignment. The total amplified time difference, $R\\delta$, must be at least as large as a single timer resolution interval, $\\Delta$.\n\nThe final step is to determine the minimal *integer* $R$ that satisfies this condition. From the inequality $R\\delta \\ge \\Delta$, we can isolate $R$:\n$$ R \\ge \\frac{\\Delta}{\\delta} $$\nSince $R$ must be an integer, the smallest integer value of $R$ that satisfies this inequality is the ceiling of the ratio $\\frac{\\Delta}{\\delta}$. The ceiling function $\\lceil z \\rceil$ gives the smallest integer greater than or equal to $z$.\n\nTherefore, the minimal integer number of repetitions is:\n$$ R_{min} = \\left\\lceil \\frac{\\Delta}{\\delta} \\right\\rceil $$\nThis expression is the complete and final analytical solution for the minimal integer $R$. The initial condition $\\delta \\ll \\Delta$ from the problem statement implies that $\\frac{\\Delta}{\\delta} \\gg 1$, confirming that a significant number of repetitions is indeed necessary for the attack to succeed, which is consistent with the premise of amplifying a small signal.",
            "answer": "$$\\boxed{\\left\\lceil \\frac{\\Delta}{\\delta} \\right\\rceil}$$"
        },
        {
            "introduction": "Building on the ability to measure small time differences, we now explore how these differences can arise from a fundamental hardware component: the data cache. This practice models a classic cache-timing attack on a cryptographic substitution box (S-box), illustrating how secret-dependent memory access patterns can leak sensitive information . This exercise moves beyond mere detection to quantifying the magnitude of the leak, introducing information-theoretic concepts to precisely measure the remaining uncertainty about the secret key.",
            "id": "3676164",
            "problem": "A single-byte substitution box (S-box) with $256$ entries is stored contiguously in memory and aligned to a $64$-byte boundary. Each entry has size $e$ bytes, where $e$ is a power of two with $1 \\leq e \\leq 64$, and the table occupies exactly $256e$ bytes. The central processing unit (CPU) cache has a cache line size of $64$ bytes. Assume that each S-box lookup accesses exactly one cache line and that there are no hardware features (such as prefetching) that would fetch unrelated lines.\n\nA single secret key byte $k \\in \\{0,1,\\dots,255\\}$ is used to form the S-box index $i = p \\oplus k$, where $\\oplus$ denotes bitwise exclusive OR, and $p$ is a known plaintext byte provided by the attacker. The attacker can perform $m \\geq 1$ chosen-plaintext queries with plaintext bytes $p_{1},\\dots,p_{m}$ and, for each query, can observe only the cache line index $\\ell \\in \\{0,1,\\dots,L-1\\}$ accessed by the S-box lookup, where $L$ is the number of cache lines spanned by the table.\n\nStarting from first principles in computer organization relevant to caches and memory addressing, answer the following:\n\n1. Derive the set of S-box indices $i$ that map to a given cache line index $\\ell$. Express your derivation in terms of $e$, $64$, and $\\ell$ without using any shortcut formulas.\n\n2. Under a uniform prior for $k$ over $\\{0,\\dots,255\\}$ and assuming $m \\geq 1$ observations with known $p_{j}$, quantify the remaining uncertainty about $k$ after these observations by computing the Shannon entropy of the posterior in bits. Express your final result as a closed-form expression in terms of $e$. Do not round; express the result in bits.",
            "solution": "This problem is divided into two parts. First, we must derive the relationship between an S-box index and its corresponding cache line index. Second, we must use this relationship to quantify the information leaked about a secret key, using Shannon entropy.\n\n### Part 1: Derivation of S-box Indices per Cache Line\n\nWe are given an S-box table with $256$ entries, stored contiguously in memory. The table's starting address is aligned to a $64$-byte boundary. Let the base address of the S-box table be $A_{\\text{base}}$. The alignment condition means that $A_{\\text{base}}$ is a multiple of $64$. Mathematically, $A_{\\text{base}} \\pmod{64} = 0$.\n\nEach entry in the S-box has a size of $e$ bytes. The S-box is indexed by $i \\in \\{0, 1, \\dots, 255\\}$. The memory address of the first byte of the entry for index $i$ is given by:\n$$A_i = A_{\\text{base}} + i \\cdot e$$\nThe CPU cache has a line size of $C_S = 64$ bytes. A memory address $A$ is mapped to a physical cache line. The index of the cache line containing address $A$ is $\\lfloor A / C_S \\rfloor = \\lfloor A / 64 \\rfloor$.\n\nThe problem states that the attacker observes a relative cache line index $\\ell$. This is the index of the cache line relative to the start of the S-box table. The first cache line occupied by the table has the absolute index $\\lfloor A_{\\text{base}} / 64 \\rfloor$. Since $A_{\\text{base}}$ is a multiple of $64$, lets say $A_{\\text{base}} = 64 \\cdot N$ for some integer $N$, this index is simply $N$.\n\nThe absolute cache line index for the memory address $A_i$ is $\\lfloor A_i / 64 \\rfloor$. The relative index $\\ell$ is the difference between this and the base index:\n$$\\ell = \\lfloor \\frac{A_i}{64} \\rfloor - \\lfloor \\frac{A_{\\text{base}}}{64} \\rfloor$$\nSubstituting the expressions for $A_i$ and $A_{\\text{base}}$:\n$$\\ell = \\left\\lfloor \\frac{64 \\cdot N + i \\cdot e}{64} \\right\\rfloor - \\left\\lfloor \\frac{64 \\cdot N}{64} \\right\\rfloor$$\nUsing the property of the floor function $\\lfloor x+k \\rfloor = \\lfloor x \\rfloor + k$ for any integer $k$:\n$$\\ell = \\left\\lfloor \\frac{i \\cdot e}{64} + N \\right\\rfloor - N = \\left\\lfloor \\frac{i \\cdot e}{64} \\right\\rfloor + N - N = \\left\\lfloor \\frac{i \\cdot e}{64} \\right\\rfloor$$\nThis equation provides the mapping from an S-box index $i$ to the observed relative cache line index $\\ell$.\n\nTo find the set of S-box indices $i$ that map to a given cache line index $\\ell$, we must solve this equation for $i$. From the definition of the floor function, the equation $\\ell = \\lfloor x \\rfloor$ is equivalent to the inequality $\\ell \\le x < \\ell + 1$. Applying this to our equation:\n$$\\ell \\le \\frac{i \\cdot e}{64} < \\ell + 1$$\nTo isolate $i$, we multiply the inequality by $64/e$:\n$$\\frac{64\\ell}{e} \\le i < \\frac{64(\\ell+1)}{e}$$\nSince $i$ must be an integer and is restricted to the range $\\{0, 1, \\dots, 255\\}$, the set of S-box indices $S_\\ell$ that map to a specific cache line index $\\ell$ is:\n$$S_\\ell = \\left\\{ i \\in \\{0, 1, \\dots, 255\\} \\, \\middle| \\, \\frac{64\\ell}{e} \\le i < \\frac{64(\\ell+1)}{e} \\right\\}$$\nThe number of S-box indices per cache line is constant for all $\\ell$ and is equal to $\\frac{64(\\ell+1)}{e} - \\frac{64\\ell}{e} = \\frac{64}{e}$. Let us denote this quantity by $N_C = \\frac{64}{e}$. Since $e$ is a power of two and $1 \\le e \\le 64$, $N_C$ is also a power of two and $1 \\le N_C \\le 64$. The set of indices can thus be written as $\\{i \\mid \\ell N_C \\le i < (\\ell+1)N_C\\}$.\n\n### Part 2: Quantifying Remaining Uncertainty\n\nThe attacker performs a chosen-plaintext attack. For a chosen plaintext $p$, the S-box index is $i = p \\oplus k$, where $k$ is the secret key. The attacker observes the cache line index $\\ell = \\lfloor (p \\oplus k) \\cdot e / 64 \\rfloor$. This observation reveals which set $S_\\ell$ the value $p \\oplus k$ belongs to.\n\nThe condition $i \\in S_\\ell$ is equivalent to $\\lfloor i/N_C \\rfloor = \\ell$, where $N_C = 64/e$. As established, $N_C$ is a power of two. Let $N_C = 2^n$. The operation $i \\to \\lfloor i/2^n \\rfloor$ is equivalent to an arithmetic right shift of the $8$-bit integer $i$ by $n$ positions. This operation effectively extracts the most significant $8-n$ bits of $i$. The bottom $n$ bits of $i$ are discarded.\n\nTherefore, observing $\\ell$ for the index $i=p \\oplus k$ is equivalent to learning the most significant $8-n$ bits of the value $p \\oplus k$.\nThe bitwise XOR operation has no carries, meaning each bit of the result $p \\oplus k$ depends only on the corresponding bits of $p$ and $k$. Let $x_{MSB}$ and $x_{LSB}$ denote the most significant $8-n$ bits and least significant $n$ bits of an $8$-bit value $x$, respectively. Then:\n$$(p \\oplus k)_{MSB} = p_{MSB} \\oplus k_{MSB}$$\n$$(p \\oplus k)_{LSB} = p_{LSB} \\oplus k_{LSB}$$\nThe attacker observes $(p \\oplus k)_{MSB}$. Since the attacker chose $p$, they know $p_{MSB}$. Thus, they can compute the most significant $8-n$ bits of the secret key:\n$$k_{MSB} = (p \\oplus k)_{MSB} \\oplus p_{MSB}$$\nA single observation with any known $p$ is sufficient to determine $k_{MSB}$. Any further observations with other plaintexts $p_j$ will only reconfirm this same information about $k_{MSB}$.\n\nCritically, the observation provides no information whatsoever about the least significant $n$ bits of the key, $k_{LSB}$. The prior distribution for $k$ is uniform over all $256$ possibilities, which implies each of the $8$ bits of $k$ is an independent and uniformly random binary digit. After the attack, the top $8-n$ bits are known, but the bottom $n$ bits remain completely unknown and are still uniformly distributed.\n\nThe set of possible keys is reduced to those that share the determined $k_{MSB}$. Since there are $n$ unknown bits in $k_{LSB}$, there are $2^n$ possible keys remaining. The posterior probability distribution is uniform over this set of $2^n$ keys. The probability of each of these remaining keys is $P(k) = 1/2^n$.\n\nThe Shannon entropy of the posterior distribution of the key $K$ is given by $H(K) = -\\sum_{k} P(k) \\log_2 P(k)$. For our uniform distribution over $2^n$ outcomes:\n$$H(K) = - \\sum_{j=1}^{2^n} \\frac{1}{2^n} \\log_2\\left(\\frac{1}{2^n}\\right) = - 2^n \\cdot \\frac{1}{2^n} \\log_2(2^{-n}) = -(-n) = n$$\nThe remaining uncertainty is $n$ bits. We must express this in terms of the given parameter $e$. We have the relation $N_C = 2^n$, and $N_C=64/e$.\n$$2^n = \\frac{64}{e}$$\nTaking the base-$2$ logarithm of both sides:\n$$n = \\log_2\\left(\\frac{64}{e}\\right) = \\log_2(64) - \\log_2(e) = \\log_2(2^6) - \\log_2(e) = 6 - \\log_2(e)$$\nThus, the remaining uncertainty about the key $k$, quantified by the Shannon entropy of its posterior distribution, is $6 - \\log_2(e)$ bits.",
            "answer": "$$\n\\boxed{6 - \\log_{2}(e)}\n$$"
        },
        {
            "introduction": "The effectiveness of a side-channel attack is not universal; it often depends critically on subtle microarchitectural design choices. This practice delves into these nuances by examining how a processor's cache coherence policy—specifically, an inclusive versus an exclusive Last-Level Cache (LLC)—affects the viability of a Flush+Reload attack . By analyzing the persistence of a secret-dependent cache line under different policies, you will gain a deeper appreciation for how hardware design directly influences system security.",
            "id": "3676178",
            "problem": "Consider a symmetric multiprocessor with $2$ cores, each core having a private Level-$1$ Data cache (L1D) and sharing a unified Last-Level Cache (LLC). The attacker and victim map the same physical page read-only, enabling a Flush+Reload style side channel. In a Flush+Reload style channel, the attacker first forces a target cache line to be removed, waits for the victim to execute, and then measures the reload latency for the target line to infer whether the victim accessed it. Assume Modified, Exclusive, Shared, Invalid (MESI) coherence with globally visible invalidations and writebacks, random replacement in private caches, and a physically indexed and tagged LLC.\n\nTwo LLC policies are compared: inclusive and exclusive. In an inclusive LLC, every line present in any private cache must also be present in the LLC; eviction or invalidation of a line in the LLC invalidates all private-cache duplicates. In an exclusive LLC, lines present in private caches need not be duplicated in the LLC; eviction of a line from the LLC does not, by itself, require invalidation of private-cache copies.\n\nTo avoid relying on explicit cache-flush instructions, the attacker uses eviction-by-conflict: it accesses $W+d$ addresses congruent to the target LLC set to evict the target line by replacement pressure, where $W$ is the LLC set associativity and $d$ is a small overfill margin. Let the probability that this eviction process successfully removes the target line from the LLC be $p$. Assume that the victim initially holds the target line in its L1D.\n\nGiven the following parameters for the victim’s L1D and workload:\n- L1D capacity $32\\,\\mathrm{KB}$, line size $64\\,\\mathrm{B}$, associativity $8$-way.\n- Thus, the number of sets is $N_S = \\frac{32\\,\\mathrm{KB}}{64\\,\\mathrm{B} \\cdot 8}$.\n- Victim L1D miss-and-fill stream arrives as a memoryless process with rate $r_V = 128$ fills per microsecond, uniformly across sets.\n- Replacement within a set is random: each fill into a set evicts one of the $W = 8$ resident ways uniformly at random.\n- Attacker’s eviction success probability is $p = 0.9$.\n\nUsing only the core definitions above and first-principles reasoning about inclusion/exclusion and random replacement, analyze how inclusivity versus exclusivity affects the persistence of the shared target line immediately after the attacker’s eviction, and compute the expected post-eviction persistence time (mean time until the target line is absent from all caches relevant to the victim) under both policies. Then, select the correct statement about which policy reduces shared-line persistence and the corresponding computed values.\n\nOptions:\n\nA. With an inclusive LLC and eviction success probability $p = 0.9$, the expected post-eviction shared-line persistence is $0.4\\,\\mu\\mathrm{s}$, which is $10\\times$ lower than with an exclusive LLC under the given parameters.\n\nB. With an exclusive LLC, the expected post-eviction persistence equals $(1-p) \\cdot 4\\,\\mu\\mathrm{s} = 0.4\\,\\mu\\mathrm{s}$ because LLC eviction still invalidates private caches through coherence, independent of inclusivity.\n\nC. Inclusivity does not change persistence; both policies yield an expected persistence of $4\\,\\mu\\mathrm{s}$ because private L1D replacement dominates.\n\nD. Inclusive LLC increases shared-line persistence due to duplication, so the expected persistence is $4\\,\\mu\\mathrm{s}$ for inclusive and $0.4\\,\\mu\\mathrm{s}$ for exclusive under the given parameters.",
            "solution": "We proceed from the stated definitions and assumptions. A Flush+Reload style channel depends on an attacker’s ability to remove a shared target line such that the victim’s subsequent access must re-fetch it, enabling timing-based inference. Eviction-by-conflict acts on the LLC; coherence handles visibility of evictions and invalidations.\n\nFirst, compute the number of L1D sets:\n$$\nN_S = \\frac{32\\,\\mathrm{KB}}{64\\,\\mathrm{B} \\cdot 8} = \\frac{32 \\cdot 1024\\,\\mathrm{B}}{64\\,\\mathrm{B} \\cdot 8} = \\frac{32768}{512} = 64.\n$$\nVictim fills arrive uniformly across sets at rate $r_V = 128$ per microsecond, so fills into the specific set containing the target line arrive at rate\n$$\nr_{\\text{set}} = \\frac{r_V}{N_S} = \\frac{128}{64} = 2 \\ \\text{fills per microsecond}.\n$$\nWith random replacement within a set of associativity $W = 8$, each fill into that set chooses one of $8$ resident ways uniformly at random to evict. The instantaneous hazard rate that the specific target line is evicted by a fill into its set is therefore\n$$\nh = r_{\\text{set}} \\cdot \\frac{1}{W} = 2 \\cdot \\frac{1}{8} = 0.25 \\ \\text{per microsecond}.\n$$\nUnder a memoryless process and random replacement, the survival time of a given resident line is exponentially distributed with mean\n$$\n\\tau = \\frac{1}{h} = \\frac{1}{0.25} = 4 \\ \\mu\\mathrm{s}.\n$$\n\nNow compare LLC policies.\n\nInclusive LLC:\n- By definition, any line in a private cache is duplicated in the LLC. When the attacker’s eviction-by-conflict succeeds in evicting the target line from the LLC, inclusion requires invalidation of all private-cache duplicates. Hence, conditional on eviction success, the post-eviction persistence time until the line is absent from the victim’s L1D is effectively $0$ (ignoring coherence latency, which we treat as negligible relative to microsecond-scale mean times).\n- If the eviction attempt fails (probability $1-p$), the target line remains in the LLC and therefore in the victim’s L1D. It will then persist until private-cache replacement removes it, with expected time $\\tau = 4\\,\\mu\\mathrm{s}$.\n\nTherefore, the expected post-eviction persistence time under inclusivity is\n$$\nE[T_{\\text{inc}}] = p \\cdot 0 + (1 - p) \\cdot \\tau = (1 - 0.9) \\cdot 4 = 0.4 \\ \\mu\\mathrm{s}.\n$$\n\nExclusive LLC:\n- A line present in a private cache need not be present in the LLC. Evicting a line from the LLC via conflict does not, by itself, require invalidation of private-cache copies solely due to exclusivity; coherence ensures consistency for writes and ownership transitions, but a replacement event in the LLC does not cascade invalidations to private caches absent inclusion constraints.\n- Consequently, regardless of whether the attacker’s LLC eviction succeeds, the victim’s L1D copy persists until replaced by the victim’s own activity. Under the random-replacement, memoryless-fill model, the expected persistence time is $\\tau = 4\\,\\mu\\mathrm{s}$. This is independent of $p$ in this model because eviction pressure is applied at the LLC, not at the victim’s private cache, and exclusivity removes the duplication linkage that would force invalidation.\n\nThus,\n$$\nE[T_{\\text{exc}}] = \\tau = 4 \\ \\mu\\mathrm{s}.\n$$\n\nComparing policies:\n$$\n\\frac{E[T_{\\text{inc}}]}{E[T_{\\text{exc}}]} = \\frac{0.4}{4} = 0.1,\n$$\nso inclusivity reduces shared-line persistence by a factor of $10$ under the given parameters. This strengthens Flush+Reload style channels by making the attacker’s “flush” more effective at removing all shared copies.\n\nOption-by-option analysis:\n- Option A states that with inclusive LLC and $p = 0.9$, the expected post-eviction persistence is $0.4\\,\\mu\\mathrm{s}$, which is $10\\times$ lower than with exclusive LLC. This matches the derived $E[T_{\\text{inc}}] = 0.4\\,\\mu\\mathrm{s}$ and $E[T_{\\text{exc}}] = 4\\,\\mu\\mathrm{s}$, so A is Correct.\n- Option B claims that with exclusive LLC the expected persistence equals $(1-p) \\cdot 4\\,\\mu\\mathrm{s} = 0.4\\,\\mu\\mathrm{s}$ because LLC eviction still invalidates private caches through coherence, independent of inclusivity. This misstates exclusivity and the role of inclusion: coherence does not cause private-cache invalidation on LLC replacement alone absent inclusion constraints. The correct value is $4\\,\\mu\\mathrm{s}$, independent of $p$. Hence B is Incorrect.\n- Option C claims inclusivity does not change persistence and both policies yield $4\\,\\mu\\mathrm{s}$. This ignores the invalidation cascade guaranteed by inclusion when LLC eviction succeeds; we computed $E[T_{\\text{inc}}] = 0.4\\,\\mu\\mathrm{s}$. Hence C is Incorrect.\n- Option D asserts inclusive LLC increases persistence due to duplication, flipping the computed values. Inclusion causes faster removal through invalidation, not slower persistence; our calculations show the opposite. Hence D is Incorrect.",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}