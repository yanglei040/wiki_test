{
    "hands_on_practices": [
        {
            "introduction": "硬件设计中的性能优化有时会无意中打开信息泄露的窗口。一个典型的例子是时序侧信道，当操作的执行时间依赖于秘密输入时，攻击者便可通过精确测量时间来推断敏感数据。在本练习中 ，我们将探讨一种为整数除法器设计的恒定时间执行策略，通过计算为消除时序泄露而引入的预期“填充周期”成本，你将亲身体会到安全与性能之间最直接的权衡。",
            "id": "3645417",
            "problem": "您正在设计一个恒定时间的整数除法器，以消除通过时间侧信道 (TSC) 造成的时间泄露。现有的除法器实现了一种微架构优化：对于任何非零的 $w$ 位除数 $d$，可写为 $d = 2^{t} m$，其中 $m$ 为奇数，$t \\in \\{0,1,\\dots,w-1\\}$ 是 $d$ 的二进制表示中尾随零的数量。经过优化的除法器为每个尾随零节省一个恒定的 $\\delta$ 周期，因此其完成时间为 $C_{\\text{gen}} - \\delta t$ 个周期，其中 $C_{\\text{gen}}$ 是没有优化的基准通用路径的周期数。为了强制实现恒定时间操作，您需要对优化的情况进行 $\\delta t$ 个周期的填充，使得每次除法都耗时 $C_{\\text{gen}}$ 个周期，并且没有关于 $t$ 的信息通过时间泄露。\n\n假设秘密除数 $d$ 在非零的 $w$ 位整数集合 $\\{1,2,\\dots,2^{w}-1\\}$ 上均匀分布，并且除以零的情况永不发生。从第一性原理（基于非零 $w$ 位整数集合的计数论证，以及除以 $2^{t}$ 等价于右移 $t$ 位的算术性质）出发，推导在该均衡方案下，每次除法所需填充周期的期望数的精确闭式表达式，该表达式应以 $w$ 和 $\\delta$ 表示。然后，当 $w = 32$ 和 $\\delta = 1$ 时，计算该表达式的值。将最终答案表示为一个单一的精确有理数（单位为周期）。不要进行近似或四舍五入。",
            "solution": "问题要求计算使优化的整数除法器以恒定时间运行所需的填充周期的期望数。对于一个给定的非零 $w$ 位除数 $d$，填充周期的数量为 $\\delta t$，其中 $\\delta$ 是一个常数，$t$ 是 $d$ 的二进制表示中尾随零的数量。除数 $d$ 被假设在非零 $w$ 位整数集合 $\\{1, 2, \\dots, 2^w-1\\}$ 上均匀分布。\n\n首先，我们将问题形式化。设 $D$ 是代表除数的随机变量，它在样本空间 $\\Omega = \\{1, 2, \\dots, 2^w - 1\\}$ 上均匀分布。样本空间的大小为 $|\\Omega| = 2^w - 1$。任何特定除数 $d \\in \\Omega$ 的概率为 $\\mathbb{P}(D=d) = \\frac{1}{2^w - 1}$。\n\n设 $t(d)$ 是将除数 $d$ 映射到其尾随零数量的函数。对于一个除数 $d$，其填充周期数是一个随机变量 $P(d) = \\delta \\cdot t(d)$。我们需要求这些填充周期的期望值 $E[P]$。\n\n根据离散随机变量的期望值定义，我们有：\n$$E[P] = \\sum_{d \\in \\Omega} P(d) \\cdot \\mathbb{P}(D=d)$$\n代入给定值：\n$$E[P] = \\sum_{d=1}^{2^w-1} \\delta \\cdot t(d) \\cdot \\frac{1}{2^w - 1}$$\n我们可以提出常数项 $\\delta$ 和 $\\frac{1}{2^w-1}$：\n$$E[P] = \\frac{\\delta}{2^w - 1} \\sum_{d=1}^{2^w-1} t(d)$$\n问题的核心是计算从 1 到 $2^w-1$ 的所有整数的尾随零总和 $S = \\sum_{d=1}^{2^w-1} t(d)$。\n\n整数 $d$ 的尾随零数量 $t(d)$ 是能整除 $d$ 的 2 的最高次幂。也就是说，$d$ 可被 $2^{t(d)}$ 整除，但不能被 $2^{t(d)+1}$ 整除。另一种描述是 $t(d) = \\sum_{k=1}^{\\infty} [2^k | d]$，其中 $[2^k|d]$ 是一个指示函数，如果 $2^k$ 整除 $d$，则为 1，否则为 0。一个有 $t$ 个尾随零的整数 $d$ 对 $2^1$ 的倍数计数贡献 1，对 $2^2$ 的倍数计数贡献 1，...，对 $2^t$ 的倍数计数贡献 1。\n\n利用这一见解，我们可以通过改变求和顺序来重新表示和 $S$。我们不对每个 $d$ 的尾随零数量求和，而是对 2 的幂次求和，并对每个幂次 $2^k$ 计算集合 $\\Omega$ 中有多少个数可以被它整除。\n$$S = \\sum_{d=1}^{2^w-1} t(d) = \\sum_{d=1}^{2^w-1} \\sum_{k=1}^{w-1} [2^k | d]$$\n在 $\\Omega$ 中能整除一个数的 2 的最大幂是 $2^{w-1}$（它能整除 $2^{w-1}$ 本身），所以对 $k$ 的求和可以在 $w-1$ 处终止。\n通过交换求和顺序：\n$$S = \\sum_{k=1}^{w-1} \\sum_{d=1}^{2^w-1} [2^k | d]$$\n内层和 $\\sum_{d=1}^{2^w-1} [2^k|d]$ 恰好是集合 $\\{1, 2, \\dots, 2^w-1\\}$ 中 $2^k$ 的倍数的个数。这个数量由 $\\lfloor \\frac{2^w-1}{2^k} \\rfloor$ 给出。\n\n让我们分析这一项。对于任何整数 $k \\ge 1$，我们可以写出：\n$$\\lfloor \\frac{2^w-1}{2^k} \\rfloor = \\lfloor \\frac{2^w}{2^k} - \\frac{1}{2^k} \\rfloor = \\lfloor 2^{w-k} - 2^{-k} \\rfloor$$\n因为 $k \\ge 1$，所以 $0  2^{-k} \\le \\frac{1}{2}$。因此，$2^{w-k} - 2^{-k}$ 不是一个整数，其下取整为 $2^{w-k} - 1$。\n所以，集合中 $2^k$ 的倍数个数为 $2^{w-k}-1$。\n\n现在我们可以计算和 $S$：\n$$S = \\sum_{k=1}^{w-1} (2^{w-k}-1) = \\left(\\sum_{k=1}^{w-1} 2^{w-k}\\right) - \\left(\\sum_{k=1}^{w-1} 1\\right)$$\n第二项就是 $w-1$。\n对于第一项，我们可以进行换元。令 $j = w-k$。当 $k$ 从 1 变到 $w-1$ 时，$j$ 从 $w-1$ 变到 1。\n$$\\sum_{k=1}^{w-1} 2^{w-k} = \\sum_{j=1}^{w-1} 2^j = (2^1 + 2^2 + \\dots + 2^{w-1})$$\n这是一个首项 $a=2$，公比 $r=2$，项数为 $n=w-1$ 的等比数列。其和为 $a\\frac{r^n-1}{r-1} = 2\\frac{2^{w-1}-1}{2-1} = 2(2^{w-1}-1) = 2^w - 2$。\n\n将这些结果代回 $S$ 的表达式中：\n$$S = (2^w-2) - (w-1) = 2^w - 2 - w + 1 = 2^w - w - 1$$\n\n现在我们将这个和代回到填充周期期望数的公式中：\n$$E[P] = \\frac{\\delta}{2^w - 1} (2^w - w - 1)$$\n这就是所求的用 $w$ 和 $\\delta$ 表示的填充周期期望数的精确闭式表达式。\n\n题目接着要求当 $w=32$ 和 $\\delta=1$ 时计算该表达式的值。\n代入这些值：\n$$E[P] = \\frac{1 \\cdot (2^{32} - 32 - 1)}{2^{32} - 1} = \\frac{2^{32} - 33}{2^{32} - 1}$$\n这就是题目所要求的一个精确有理数。我们也可以将其写为：\n$$E[P] = \\frac{(2^{32} - 1) - 32}{2^{32} - 1} = 1 - \\frac{32}{2^{32} - 1}$$\n这种形式表明，填充周期的期望数略小于 1 个周期。$\\frac{2^{32}-33}{2^{32}-1}$ 的形式是一个单一的有理数。",
            "answer": "$$\\boxed{\\frac{2^{32}-33}{2^{32}-1}}$$"
        },
        {
            "introduction": "除了时序，处理器内部共享的微架构状态也是一个主要的泄露来源。例如，多个安全域共享的分支预测器可能会泄露一个域的分支行为给另一个域，这在Spectre等攻击中得到了证实。为了应对这一挑战，一种常见的防御方法是状态隔离 ，这个练习将指导你量化实现这种隔离所需付出的硬件代价，具体来说，就是为每个安全域配备独立的预测器历史表所带来的额外存储开销。",
            "id": "3645422",
            "problem": "现代乱序处理器使用由分支预测引导的推测执行。在基线设计中，预测器维护一个单一的分支历史表 (BHT)，该表被定义为一个由程序计数器的低位比特索引的数组，其中每个条目是一个用于预测分支方向的饱和计数器。跨域交互会产生微架构侧信道，其中在一个安全域中学习到的预测器状态会影响另一个安全域中的预测行为，这可能违反信息流安全中的不干涉原则。硬件安全中一种广泛使用的缓解措施是跨域隔离预测器状态，从而使预测器行为不会将信息从一个域传递到另一个域。\n\n考虑以下隔离机制：处理器为每个安全域维护一个专属的 BHT（即每个安全域一个 BHT），并在操作系统更改安全域时，根据域标识符切换活动的 BHT。假设如下：\n- 基线预测器使用一个包含 $H$ 个条目的单一 BHT。\n- 每个 BHT 条目存储一个 $2$ 位饱和计数器（这是分支预测中一个经过充分测试的标准）。\n- 在隔离设计中，有 $D$ 个安全域，每个域都有自己的 BHT，包含 $H$ 个条目，每个条目同样使用 $2$ 位饱和计数器。\n- 处理器还维护一个域标识符寄存器，该寄存器使用足够的比特来编码当前域，以表示所有 $D$ 个域。\n- 忽略所有非存储开销（例如，组合选择逻辑、导线以及除域标识符寄存器之外的控制触发器）。只将存储阵列和域标识符寄存器中存储的比特计为存储。\n\n基于以上定义和不干涉的安全目标，推导并以一个关于 $H$ 和 $D$ 的单一闭式解析表达式来表示隔离设计相对于基线设计的总存储开销。请以比特为单位表示您的最终答案。不要进行任何数值代入。不要四舍五入；返回精确的符号表达式。",
            "solution": "目标是推导出一个表达式，用于表示隔离的分支预测器设计相对于基线设计的总存储开销。开销定义为隔离设计所需的额外存储量，以比特为单位。\n\n设 $S_{baseline}$ 为基线设计的总存储量（以比特为单位）。\n设 $S_{isolated}$ 为隔离设计的总存储量（以比特为单位）。\n那么，存储开销 $S_{overhead}$ 定义为：\n$$S_{overhead} = S_{isolated} - S_{baseline}$$\n\n首先，我们计算基线设计 $S_{baseline}$ 的存储量。基线设计包含一个单一的分支历史表（BHT）。\n- BHT 有 $H$ 个条目。\n- 每个条目是一个 $2$ 位饱和计数器。\n基线 BHT 的总存储量是条目数与每个条目大小（以比特为单位）的乘积。\n$$S_{baseline} = H \\times 2$$\n\n接下来，我们计算隔离设计 $S_{isolated}$ 的存储量。问题指明，此设计包含两个需要计算存储量的组件：每个域专属的 BHT 和一个域标识符寄存器。\n1.  **BHT 的存储量：**\n    - 有 $D$ 个安全域。\n    - 每个域有一个专用的 BHT，包含 $H$ 个条目。\n    - 每个 BHT 中的每个条目都是一个 $2$ 位饱和计数器。\n    所有 $D$ 个 BHT 的总存储量是域的数量、每个 BHT 的条目数以及每个条目大小的乘积。\n    $$S_{BHTs\\_isolated} = D \\times H \\times 2 = 2DH$$\n\n2.  **域标识符寄存器的存储量：**\n    - 该寄存器必须编码当前的安全域，共有 $D$ 个域。\n    - 为了表示 $D$ 个不同的状态，所需的最小比特数（记为 $k$）必须满足不等式 $2^k \\ge D$。\n    - 对 $k$ 求解得到 $k \\ge \\log_2(D)$。因为比特数必须是整数，所以我们取该值的向上取整。\n    - 因此，域标识符寄存器的存储量为：\n    $$S_{register} = \\lceil \\log_2(D) \\rceil$$\n\n隔离设计的总存储量 $S_{isolated}$ 是 BHT 的存储量和域标识符寄存器的存储量之和。\n$$S_{isolated} = S_{BHTs\\_isolated} + S_{register} = 2DH + \\lceil \\log_2(D) \\rceil$$\n\n最后，我们通过从隔离设计的存储量中减去基线设计的存储量来计算存储开销 $S_{overhead}$。\n$$S_{overhead} = S_{isolated} - S_{baseline}$$\n$$S_{overhead} = \\left( 2DH + \\lceil \\log_2(D) \\rceil \\right) - (2H)$$\n重新整理各项并提出公因式 $2H$，得到最终的开销闭式表达式：\n$$S_{overhead} = 2DH - 2H + \\lceil \\log_2(D) \\rceil$$\n$$S_{overhead} = 2H(D-1) + \\lceil \\log_2(D) \\rceil$$\n这个表达式表示了隔离设计所需的总额外存储量（以比特为单位），以 BHT 条目数 $H$ 和安全域数 $D$ 表示。",
            "answer": "$$\\boxed{2H(D-1) + \\lceil \\log_{2}(D) \\rceil}$$"
        },
        {
            "introduction": "当威胁模型扩展到能监视外部内存总线的攻击者时，仅仅隐藏执行时间或内部状态是不够的，内存访问地址序列本身也可能成为泄露源。为了实现更强的安全保证，我们可以采用“不经意随机访问内存”（ORAM）等混淆技术，它旨在使内存访问模式与实际访问的地址无关。在本实践中 ，你将分析一种简化的类ORAM硬件方案，并计算其为实现访问模式混淆所导致的巨大内存流量开销，从而深刻理解高级别安全保证所需付出的性能代价。",
            "id": "3645349",
            "problem": "某个处理器为不经意随机访问内存 (ORAM) 类的不经意内存访问实现了硬件支持，以缓解单插槽系统中的内存总线侧信道攻击。该威胁模型假设存在一个攻击者，他可以观察内存总线地址流以及读写序列，但无法观察传输的数据值。为确保每次逻辑内存访问都与其他任何访问无法区分，控制器对每次逻辑访问强制执行固定的外部内存访问模式。\n\n内存系统以大小为 $L$ 字节的固定大小缓存行传输数据。一个容量为 $S$ 行的专用片上暂存缓冲区用于存放最近使用的行和诱饵行，并且在内存总线上不可直接观察。对于每次对一行的逻辑内存访问，控制器执行以下外部内存序列：\n\n- 通过发出 $W$ 次整行读取，将一个包含 $W$ 行的连续窗口从主存暂存到暂存缓冲区，其中窗口位置是逻辑时间索引的确定性函数，并且与秘密地址无关。该窗口始终包含目标行。\n- 在暂存缓冲区处理后，通过发出 $W$ 次整行写入来写回相同的窗口，即使某些行中的数据没有改变，以使读/写模式保持不变。\n- 每次逻辑访问时，从暂存缓冲区向主存驱逐 $E$ 行，以保持暂存缓冲区的占用率有界。为了使每次访问的读/写次数与数据值和访问类型无关，每次驱逐都包括一次整行读取（以标准化操作），然后是一次整行写入，使用由每个周期播种的伪随机函数选择的诱饵地址，且与秘密地址无关。\n\n假设基准（非不经意）系统每次逻辑读取传输 $L$ 字节，每次逻辑写入额外传输 $L$ 字节，逻辑访问中写入操作的比例为 $\\alpha$，其中 $0 \\leq \\alpha \\leq 1$。所有传输都是整行传输，且没有压缩。\n\n仅使用这些假设以及为实现不经意性而要求每次访问的可观察踪迹必须具有固定长度和组成这一条件，推导一个闭式解析表达式，用于计算由类 ORAM 暂存缓冲区设计相对于基准系统引入的每次逻辑访问的额外外部内存流量 $\\tau$（以每次访问的字节数衡量）。将你的答案表示为关于 $L$、$W$、$E$ 和 $\\alpha$ 的单个解析表达式。在最终的方框答案中不要包含单位。如果你选择简化，请确保代数步骤有效；不需要四舍五入。",
            "solution": "攻击者观察内存总线，包括地址以及每个操作是读还是写。为了实现不经意性，每次逻辑访问的可观察序列必须相对于秘密地址和数据保持不变；也就是说，每次访问必须对外部可见的内存位置引发相同数量的读写操作，而与访问类型和内容无关。这促使每次逻辑访问都发出固定的内存操作集。\n\n我们首先量化基准流量。在非不经意的基准系统中，每次逻辑读取传输 $L$ 字节，而每次逻辑写入（例如，读后写）传输 $2L$ 字节。如果逻辑访问中写入操作的比例是 $\\alpha$，那么每次逻辑访问的预期基准流量是：\n$$\nT_{\\text{base}} = (1-\\alpha) \\cdot L + \\alpha \\cdot (2L) = L(1-\\alpha+2\\alpha) = L(1+\\alpha).\n$$\n\n现在考虑不经意方案。每次逻辑访问，控制器执行：\n- 一个窗口暂存阶段，包括 $W$ 次整行读取和 $W$ 次整行写入。这贡献了 $W$ 次读取和 $W$ 次写入，总计 $2W$ 次行传输。\n- 驱逐阶段，包括 $E$ 次整行读取和 $E$ 次整行写入。这贡献了 $E$ 次读取和 $E$ 次写入，总计 $2E$ 次行传输。\n\n因为每次读取或写入都传输一整行 $L$ 字节，并且无论访问类型如何都执行这些操作，所以在不经意方案下，每次逻辑访问的总外部内存流量是：\n$$\nT_{\\text{obl}} = L \\cdot \\big(2W + 2E\\big) = 2L(W+E).\n$$\n\n不经意方案相对于基准系统引入的每次逻辑访问的额外外部内存流量 $\\tau$ 是两者之差：\n$$\n\\tau = T_{\\text{obl}} - T_{\\text{base}}.\n$$\n代入上面推导出的表达式，\n$$\n\\tau = 2L(W+E) - L(1+\\alpha).\n$$\n\n提取公因式 $L$，\n$$\n\\tau = L \\left[ 2(W+E) - (1+\\alpha) \\right].\n$$\n\n该表达式是关于 $L$、$W$、$E$ 和 $\\alpha$ 的闭式解析函数。它反映了每次访问的可观察踪迹必须具有固定组成的要求：用于窗口暂存的 $W$ 次读取和 $W$ 次写入，加上用于标准化驱逐的 $E$ 次读取和 $E$ 次写入，且与秘密无关。基准预期包括每次访问的平均流量。该差值量化了通过固定访问模式强制实现不经意性所带来的开销。",
            "answer": "$$\\boxed{L\\left(2\\,(W+E)-(1+\\alpha)\\right)}$$"
        }
    ]
}