{
    "hands_on_practices": [
        {
            "introduction": "中断是计算机系统中的基本机制，但它们会消耗关键的系统资源，尤其是栈空间。在嵌套中断情景中（这在嵌入式和实时系统中很常见），不当的栈管理可能导致灾难性的栈溢出。本练习将通过计算最大安全中断嵌套深度，帮助您量化中断处理过程中的栈使用情况，从而将抽象的中断概念与设计稳定可靠系统的工程实践联系起来。",
            "id": "3640485",
            "problem": "一个单核嵌入式处理器使用单个向下增长的堆栈为线程模式和处理程序模式实现向量化、可抢占的中断。中断服务程序 (ISR) 是为响应中断而执行的例程。每次中断进入时，硬件会自动在当前堆栈上保存一个上下文帧；然后，编译器生成的 ISR 序言会在同一堆栈上保存额外的软件状态。系统没有尾链优化或延迟堆栈操作；每次中断进入都会推入一个完整的硬件帧，并且每个 ISR 都使用相同的最坏情况序言。\n\n假设以下具体的、架构层面的事实，所有这些事实在不同中断和嵌套深度下都是不变的：\n\n- 堆栈总大小为 $S=3072$ 字节。\n- 在第一个中断到达的瞬间，线程已经使用了 $B=1024$ 字节的堆栈。\n- 必须保留 $G=256$ 字节的保护边距以应对异步活动和作为安全边距，因此超过 $S-G$ 字节的使用量是不安全的。\n- 每次中断进入时，硬件会推入一个固定大小的帧，该帧由返回程序计数器（$8$ 字节）、处理器状态（$8$ 字节）和中断标识符（$8$ 字节）组成，然后进行填充以保持进入 ISR 时堆栈指针的 $16$ 字节对齐。因此，每次进入的硬件帧为 $32$ 字节。\n- 每个 ISR 序言保守地保存 $6$ 个被调用者保存的寄存器（每个 $8$ 字节），并分配 $16$ 字节的局部溢出区域，同时保持 $16$ 字节对齐。因此，每个 ISR 的软件使用量为 $64$ 字节。\n- 存在 $P=24$ 个不同的、严格排序的中断优先级，并且抢占仅在较高优先级的中断进入较低优先级的 ISR 时发生。每个优先级在任何时候最多只能有一个 ISR 处于活动状态。\n\n考虑在时间轴 $t$ 上的一个最坏情况下的嵌套抢占场景，其中一个最低优先级的 ISR 在时间 $t_0$ 开始，并在进入后立即在 $t_1$ 被一个更高优先级的中断抢占，该中断又在 $t_2$ 被抢占，以此类推，构建一个嵌套深度为 $d$ 的时间图，其中时间 $t_0 < t_1 < \\dots < t_{d-1}$ 严格递增，优先级也严格递增。在每次抢占时，堆栈会增长，增长量为新 ISR 的硬件帧和 ISR 软件序言的总和，并且在达到最大嵌套深度之前，没有 ISR 返回。\n\n从中断的定义、每个嵌套中断向堆栈添加其自己独立的上下文这一不变性，以及总堆栈使用量必须严格低于不安全阈值的要求出发，从第一性原理推导出一个封闭形式的表达式，用于计算最大安全嵌套深度 $d_{\\max}$，该表达式是 $S$、$B$、$G$ 和每级堆栈增长量的函数。然后，使用上面给出的参数，计算 $d_{\\max}$ 的值。以精确整数（无单位）报告最大安全嵌套深度。",
            "solution": "首先根据指定标准对问题进行验证。\n\n### 问题验证\n\n**第 1 步：提取已知条件**\n- 堆栈总大小：$S=3072$ 字节。\n- 初始线程堆栈使用量：$B=1024$ 字节。\n- 保护边距：$G=256$ 字节。\n- 每次中断的硬件帧大小：$H=32$ 字节。这包括一个 $8$ 字节的返回程序计数器、$8$ 字节的处理器状态、$8$ 字节的中断标识符以及为保持 $16$ 字节对齐的填充。\n- 每个 ISR 的软件堆栈使用量：$W_{sw}=64$ 字节。这包括 $6$ 个寄存器，每个 $8$ 字节（共 $48$ 字节），以及 $16$ 字节的局部溢出区域，同时保持 $16$ 字节对齐。\n- 不同且严格排序的中断优先级数量：$P=24$。\n- 不安全状态的条件是堆栈使用量超过 $S-G$。\n- 场景为最坏情况下的嵌套抢占，其中每次中断都向堆栈添加一个完整的上下文帧。\n\n**第 2 步：使用提取的已知条件进行验证**\n- **科学依据：** 问题陈述描述了嵌入式系统中用于可抢占、嵌套中断的堆栈管理的标准模型。硬件/软件上下文保存、堆栈保护以及基于优先级的抢占等概念是计算机体系结构和实时操作系统的基本原理。所提供的值是现实的。该问题在科学上是合理的。\n- **问题定义良好：** 问题定义清晰，提供了所有必要的参数（$S$、$B$、$G$、每级堆栈成本）。它要求一个具体的、可计算的量，即最大安全嵌套深度 $d_{\\max}$。约束是明确的。存在唯一、稳定的解。\n- **客观性：** 问题以精确的技术语言陈述，不含主观性或意见。\n\n**第 3 步：结论与行动**\n问题被判定为**有效**，因为它具有科学依据、定义良好且客观。将推导解决方案。\n\n### 解决方案推导\n\n支配此问题的基本原理是，总堆栈使用量不得超过最大安全限制。堆栈向下增长，但其大小（使用量）是从堆栈基址测量的正值。\n\n设 $S$ 为堆栈的总大小，$B$ 为在任何中断发生前线程的初始堆栈使用量，$G$ 为必须保持未使用的保护边距。因此，最大允许堆栈使用量 $U_{max}$ 是总堆栈大小减去保护边距。\n$$U_{max} = S - G$$\n\n在所描述的最坏情况下，发生了一系列 $d$ 次嵌套中断。每个中断级别都会向堆栈添加固定量的数据。这个每级堆栈增长量，我们称之为 $W_{level}$，是硬件推入的上下文帧 $H$ 和由 ISR 序言保存的软件管理的上下文 $W_{sw}$ 的总和。\n$$W_{level} = H + W_{sw}$$\n\n设 $d$ 为中断的嵌套深度。由于 $d$ 次嵌套中断中的每一次都在堆栈上消耗 $W_{level}$ 字节，因此由中断贡献的总堆栈使用量为 $d \\cdot W_{level}$。\n\n对于嵌套深度为 $d$ 的情况，总堆栈使用量 $U(d)$ 是初始线程使用量 $B$ 与 $d$ 次嵌套中断的使用量之和。\n$$U(d) = B + d \\cdot W_{level}$$\n\n为使系统保持在安全状态，总堆栈使用量 $U(d)$ 必须小于或等于最大允许使用量 $U_{max}$。\n$$U(d) \\leq U_{max}$$\n代入 $U(d)$ 和 $U_{max}$ 的表达式：\n$$B + d \\cdot W_{level} \\leq S - G$$\n\n为了找到最大安全嵌套深度 $d_{\\max}$，我们必须求解此不等式以获得 $d$ 的最大可能整数值。\n$$d \\cdot W_{level} \\leq S - B - G$$\n$$d \\leq \\frac{S - B - G}{W_{level}}$$\n\n由于嵌套深度 $d$ 必须是整数，因此它可以安全取得的最大值 $d_{\\max}$ 是右侧表达式的向下取整。\n$$d_{\\max} = \\left\\lfloor \\frac{S - B - G}{W_{level}} \\right\\rfloor$$\n这个表达式给出了受堆栈空间限制的最大深度。问题还指出有 $P=24$ 个不同的优先级，这对嵌套深度施加了一个绝对的物理限制。因此，真正的最大深度是根据堆栈约束推导出的值与优先级数量的最小值。然而，问题特别询问的是最大*安全*嵌套深度，这指的是资源限制。我们将根据公式计算该值，并验证它不超过 $P$。\n\n现在，我们将给定的数值代入推导出的表达式中。\n- $S = 3072$ 字节\n- $B = 1024$ 字节\n- $G = 256$ 字节\n- $H = 32$ 字节\n- $W_{sw} = 64$ 字节\n- $P = 24$\n\n首先，计算每级堆栈增长量 $W_{level}$：\n$$W_{level} = H + W_{sw} = 32 + 64 = 96 \\text{ 字节}$$\n接下来，计算可用于中断上下文的堆栈空间，即总大小减去初始使用量和保护边距：\n$$\\text{可用空间} = S - B - G = 3072 - 1024 - 256 = 1792 \\text{ 字节}$$\n现在，我们可以找到最大嵌套深度：\n$$d_{\\max} = \\left\\lfloor \\frac{1792}{96} \\right\\rfloor$$\n为了简化分数 $\\frac{1792}{96}$，我们可以将分子和分母同时除以它们的最大公约数。两者都可以被 $32$ 整除。\n$$d_{\\max} = \\left\\lfloor \\frac{1792 \\div 32}{96 \\div 32} \\right\\rfloor = \\left\\lfloor \\frac{56}{3} \\right\\rfloor$$\n计算该分数：\n$$\\frac{56}{3} = 18.666...$$\n应用向下取整函数得到最大整数深度：\n$$d_{\\max} = \\lfloor 18.666... \\rfloor = 18$$\n此结果 $18$ 小于中断优先级的总数 $P=24$。因此，限制因素是可用的堆栈空间，而不是优先级的数量。最大安全嵌套深度为 $18$。",
            "answer": "$$\n\\boxed{18}\n$$"
        },
        {
            "introduction": "在理解了中断的资源影响后，下一步是确保处理中断的软件（即陷阱处理程序）的正确性。处理程序中的一个微小错误可能会导致灾难性的后果，例如跳过关键指令或返回到错误的程序位置。本练习将让您扮演系统调试者的角色，通过分析一个有缺陷的陷阱处理程序，您将深刻理解异常程序计数器（EPC）的关键作用以及从异常中正确返回的精确语义。",
            "id": "3640478",
            "problem": "一个 $32$ 位精简指令集计算机（RISC）处理器使用定长 $4$ 字节指令和精确异常。根据精确异常的定义，当一个同步陷阱发生在某个程序计数器处时，硬件会将引发异常的指令的程序计数器（PC）记录到异常程序计数器（EPC）中，将 $PC$ 设置为陷阱向量，并清空流水线，以确保后续指令均未提交。异常返回指令（此处表示为 $ERET$）通过设置 $PC \\leftarrow EPC$ 来恢复控制。\n\n考虑以下实验：一个用户程序在地址 $0x00001000$ 处的一条加载指令上触发了一个同步陷阱。陷阱处理程序的序言部分将通用寄存器保存到栈中，并且出于从早期仅有中断的设计中继承的调试目的，包含一行在进行任何修复前将 $EPC$ 调整一个指令的代码：\n\n- 处理程序设置栈指针（SP）为栈帧腾出空间：$SP \\leftarrow SP - 20$。\n- 它将几个寄存器存储在距 $SP$ 偏移量为 $0$、$4$ 和 $8$ 的位置。\n- 它将 $EPC$ 存储在距 $SP$ 偏移量为 $12$ 的位置。\n- 它将处理程序的返回地址寄存器存储在距 $SP$ 偏移量为 $16$ 的位置。\n- 然后它执行一个无条件调整 $EPC \\leftarrow EPC + 4$（意图是“跳过”出错的指令）。\n- 在修复故障后（例如，映射缺失的页面），处理程序执行 $ERET$，根据定义，该指令会设置 $PC \\leftarrow EPC$。\n\n根据经验观察，在执行 $ERET$ 后，观察到的 $PC$ 是 $0x00001004$，并且用户在 $0x00001000$ 处的出错加载指令没有重新执行。仅使用上述给出的关于 $EPC$、$PC$ 和 $ERET$ 的基本语义以及所描述的处理程序序言，哪种解释最能说明返回到错误的 $PC$ 的原因？\n\nA. 处理程序错误地解释了 $EPC$ 的语义，并在序言部分错误地将 $EPC$ 增加了一个指令（$+4$ 字节）。因为 $EPC$ 已经包含了出错指令的地址，这个差一的调整迫使 $ERET$ 在 $0x00001004$ 而不是 $0x00001000$ 处恢复执行。\n\nB. 对于同步陷阱，硬件将 $EPC$ 记录为下一个顺序 $PC$（$PC + 4$），所以在 $0x00001004$ 处恢复执行是预期行为，并且没有错误。\n\nC. 序言部分的栈布局有一个槽位的偏差，因此在恢复时，处理程序从返回地址槽位加载 $EPC$，导致 $ERET$ 跳转到 $0x00001004$；这个差一的错误源于未对齐的栈偏移量，而非 $EPC$ 的语义。\n\nD. 分支延迟槽语义导致 $EPC$ 指向延迟槽，无条件的 $ERET$ 在 $PC + 4$ 处恢复执行；这个差一的错误是由于延迟分支造成的，尽管出错的指令是一条加载指令。",
            "solution": "在进行解答之前，首先对问题陈述进行严格验证。\n\n### 步骤 1：提取已知条件\n- **处理器**：$32$ 位精简指令集计算机（RISC）。\n- **指令大小**：定长 $4$ 字节指令。\n- **异常模型**：精确异常。\n- **同步陷阱定义**：\n    - 在特定的程序计数器（$PC$）处发生。\n    - 硬件行为：将引发异常的指令的 $PC$ 记录到异常程序计数器（$EPC$）中。\n    - 硬件行为：将 $PC$ 设置为陷阱向量。\n    - 硬件行为：清空流水线。\n- **异常返回指令（$ERET$）定义**：\n    - 通过设置 $PC \\leftarrow EPC$ 恢复控制。\n- **实验场景**：\n    - 一个用户程序触发了一个同步陷阱。\n    - 陷阱位置（$PC$）：$0x00001000$。\n    - 出错指令类型：一条加载指令。\n- **陷阱处理程序序言操作**：\n    1.  $SP \\leftarrow SP - 20$。\n    2.  将通用寄存器存储在距 $SP$ 偏移量为 $0$、$4$ 和 $8$ 的位置。\n    3.  将 $EPC$ 存储在距 $SP$ 偏移量为 $12$ 的位置。\n    4.  将处理程序的返回地址寄存器存储在距 $SP$ 偏移量为 $16$ 的位置。\n    5.  执行一个无条件调整：$EPC \\leftarrow EPC + 4$。\n- **修复后操作**：处理程序执行 $ERET$。\n- **观察到的经验结果**：\n    - 执行 $ERET$ 后，观察到的 $PC$ 为 $0x00001004$。\n    - 在 $0x00001000$ 处的出错加载指令没有重新执行。\n- **问题**：*仅*基于所提供的语义和描述，对于返回到错误的 $PC$ 的最佳解释是什么？\n\n### 步骤 2：使用提取的已知条件进行验证\n评估问题陈述的有效性。\n- **科学依据**：该问题描述了 RISC 架构中标准的异常处理模型，与真实世界的处理器（例如 MIPS）一致。程序计数器（$PC$）、异常程序计数器（$EPC$）、精确异常、同步陷阱（故障）、陷阱处理程序以及异常返回指令（$ERET$）等概念是计算机组成和体系结构中的基本主题。描述在事实上和科学上都是合理的。\n- **定义明确**：该问题是定义明确的。它为硬件在遇到陷阱和执行 $ERET$ 时的行为提供了明确的定义。它描述了一系列事件和一个清晰、具体的结果。问题要求给出一个逻辑解释，将初始状态和处理程序的操作与最终结果联系起来。可以从所提供的信息中推导出唯一且确定性的解决方案。\n- **客观性**：语言是精确和技术性的。所有操作和状态都进行了定量描述（例如，内存地址、寄存器操作）。没有主观或模糊的术语。\n\n### 步驟 3：结论与行动\n问题陈述是**有效的**。它是自包含的、逻辑一致的，并且基于计算机体系结构的既定原则。下面将推导解决方案。\n\n### 正确行为的推導\n分析的核心是追踪 $EPC$ 寄存器在整个事件序列中的值。\n\n1.  **陷阱触发**：在执行 $PC = 0x00001000$ 处的指令时发生同步陷阱。\n2.  **硬件对陷阱的响应**：根据问题定义（“硬件将引发异常的指令的程序计数器（PC）记录到异常程序计数器（EPC）中”），硬件执行以下操作：\n    $$EPC \\leftarrow 0x00001000$$\n    此时，控制权转移给陷阱处理程序。\n3.  **陷阱处理程序执行**：处理程序开始执行其序言。与本分析相关的操作是对 $EPC$ 寄存器的显式修改。问题陈述处理程序执行：\n    $$EPC \\leftarrow EPC + 4$$\n    代入上一步中 $EPC$ 的值：\n    $$EPC \\leftarrow 0x00001000 + 4$$\n    $$EPC \\leftarrow 0x00001004$$\n    其他的序言操作，例如将寄存器保存到栈中，并不会改变将由 $ERET$ 使用的硬件 $EPC$ 寄存器的值。它们是用来分散注意力的，与核心逻辑无关。\n4.  **从异常返回**：在故障被假定修复后，处理程序执行 $ERET$ 指令。$ERET$ 的行为被明确定义为：\n    $$PC \\leftarrow EPC$$\n    使用 $EPC$ 寄存器的当前值：\n    $$PC \\leftarrow 0x00001004$$\n5.  **结论**：处理器在地址 $0x00001004$ 处的指令恢复执行。这意味着地址 $0x00001000$ 处的指令被跳過了。这个推导出的结果（$PC = 0x00001004$）与观察到的经验结果完全匹配。\n\n这被认为是“错误的 PC”的原因是，对于一个出错的指令（比如导致页错误的加载指令），修复故障后的标准行为是重新执行该指令。这将需要返回到其地址 $0x00001000$。处理程序增加 $EPC$ 的行为对于这种类型的异常来说是一个错误；它把故障当作一个应该在返回时“跳过”的事件（比如软件中断/`syscall`）。因此，错误完全在于陷阱处理程序软件的逻辑中。\n\n### 逐项分析选项\n\n**A. 处理程序错误地解释了 $EPC$ 的语义，并在序言部分错误地将 $EPC$ 增加了一个指令（$+4$ 字节）。因为 $EPC$ 已经包含了出错指令的地址，这个差一的调整迫使 $ERET$ 在 $0x00001004$ 而不是 $0x00001000$ 处恢复执行。**\n该选项正确地指出了如上所述的事件链。硬件正确地将 $EPC$ 设置为出错地址（$0x00001000$）。然后处理程序软件错误地将其值修改为 $0x00001004$。$ERET$ 指令接着使用这个修改后的值，导致了观察到的结果。“错误地解释了 EPC 语义”这句话是对该错误的高层次准确描述：处理程序未能理解对于这种类型的陷阱，应保留 $EPC$ 的值以便重新执行。\n**结论：正确。**\n\n**B. 对于同步陷阱，硬件将 $EPC$ 记录为下一个顺序 $PC$（$PC + 4$），所以在 $0x00001004$ 处恢复执行是预期行为，并且没有错误。**\n这个选项与问题陈述中给出的一个基本前提相矛盾。问题明确定义“硬件将引发异常的指令的程序计数器（PC）记录到异常程序计数器（EPC）中”。这意味着 $EPC$ 被设置为 $PC$，而不是 $PC+4$。如果这个选项是真的，硬件最初会将 $EPC$ 设置为 $0x00001004$。然后处理程序的调整（$EPC \\leftarrow EPC + 4$）会得到 $EPC = 0x00001008$。$ERET$ 接着会导致跳转到 $0x00001008$，这与观察到的 $0x00001004$ 的结果相矛盾。\n**结论：不正确。**\n\n**C. 序言部分的栈布局有一个槽位的偏差，因此在恢复时，处理程序从返回地址槽位加载 $EPC$，导致 $ERET$ 跳转到 $0x00001004$；这个差一的错误源于未对齐的栈偏移量，而非 $EPC$ 的语义。**\n这个选项假设了一个问题中没有描述的栈恢复操作。问题描述处理程序在其序言中*存储*值到栈中，然后执行 $ERET$。$ERET$ 的定义是 $PC \\leftarrow EPC$，意味着它直接从硬件 $EPC$ 寄存器中读取。没有提到在 $ERET$ 之前有从栈中恢复寄存器的结尾部分。硬件 $EPC$ 寄存器的最终值是由 $EPC \\leftarrow EPC + 4$ 指令决定的，而不是由任何从栈中加载的操作决定的。\n**结论：不正确。**\n\n**D. 分支延迟槽语义导致 $EPC$ 指向延迟槽，无条件的 $ERET$ 在 $PC + 4$ 处恢复执行；这个差一的错误是由于延迟分支造成的，尽管出错的指令是一条加载指令。**\n这个选项引入了分支延迟槽的概念，这在问题描述中任何地方都沒有提到。必须*仅*根据给定的信息进行推理。此外，分支延迟槽与分支指令相关联。出错的指令明确是一条*加载*指令，使得分支延迟槽语义与该故障本身无关。所提供的信息足以解释结果，无需猜测未提及的架构特性。\n**结论：不正确。**",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "在掌握了资源管理和逻辑正确性之后，我们现在可以探讨性能优化。处理异常，特别是上下文切换，会带来显著的开销，而操作系统开发者会采用巧妙的策略来最小化这些成本。本练习介绍了一种真实世界中被称为“惰性上下文切换”的优化技术，您将运用概率论和期望值的知识来分析“即时”策略与“惰性”策略之间的性能权衡，从而体会定量分析在构建高效系统中的指导作用。",
            "id": "3640499",
            "problem": "一个计算机系统实现了惰性浮点上下文切换，以降低平均中断处理成本。考虑一个单核中央处理器（CPU）上运行的操作系统（OS），该系统在存在硬件异常和陷阱的情况下，采用两种备选策略来处理由中断引发的上下文切换时的浮点单元（FPU）状态：\n\n- 积极策略（Eager policy）：在每次由中断引发的上下文切换时，操作系统立即保存传出任务的FPU状态，并恢复传入任务的FPU状态。\n- 惰性策略（Lazy policy）：在由中断引发的上下文切换时，操作系统不保存FPU状态。而是设置一个软件标志，并将FPU标记为不可用。如果传入任务执行了浮点指令，就会发生同步陷阱，之后操作系统会保存传出任务的FPU状态，并恢复传入任务的FPU状态，从而启用FPU。\n\n假设以下符合科学实际的成本，以CPU周期表示：\n- 保存FPU状态的成本为 $C_{s} = 520$。\n- 恢复FPU状态的成本为 $C_{r} = 480$。\n- 处理第一条浮点指令的陷阱开销（包括异常进入/退出和最小寄存器帧处理）为 $C_{t} = 300$。\n- 惰性策略在每次上下文切换时产生的簿记开销（例如设置任务切换标志和禁用FPU）为 $C_{\\ell} = 35$。\n- 中断进入/退出开销 $C_{i}$ 对两种策略是相同的，可以视为一个公共的加法常数。\n\n设 $p$ 表示传入任务在下一次上下文切换前至少执行一条浮点指令的概率。假设在惰性策略下，每个任务在每次上下文切换中要么触发零次陷阱，要么触发一次陷阱。\n\n从异步中断、同步陷阱和概率论中期望值的基础定义出发，并且不使用任何快捷公式，完成以下任务：\n1. 推导在积极策略下，每次由中断引发的上下文切换的期望周期数，将其表示为 $C_{s}$、$C_{r}$ 和 $C_{i}$ 的函数。\n2. 推导在惰性策略下，每次由中断引发的上下文切换的期望周期数，将其表示为 $p$、$C_{\\ell}$、$C_{t}$、$C_{s}$、$C_{r}$ 和 $C_{i}$ 的函数。\n3. 推导使用惰性策略而非积极策略时，每次中断节省的期望周期数的表达式，将其表示为 $p$、$C_{\\ell}$、$C_{t}$、$C_{s}$ 和 $C_{r}$ 的函数（以每次中断的周期数表示）。\n4. 确定临界概率 $p^{\\star}$，使得每次中断节省的期望周期数为零，即惰性策略和积极策略具有相等的期望成本。使用给定的常数数值计算 $p^{\\star}$。\n\n将节省的期望周期数以每次中断的周期数表示。仅报告 $p^{\\star}$ 的最终值，作为一个无量纲数。将你的 $p^{\\star}$ 值四舍五入到四位有效数字。",
            "solution": "该问题要求分析在中断引发的上下文切换期间处理浮点单元（FPU）状态的两种策略。我们将基于概率论原理对成本进行建模，以确定性能上的权衡。分析将首先验证问题陈述的有效性，然后通过逐步推导进行。\n\n### 问题验证\n给定的问题是有效的。\n1.  **提取已知条件**：\n    *   保存FPU状态的成本：$C_s = 520$ 周期。\n    *   恢复FPU状态的成本：$C_r = 480$ 周期。\n    *   惰性策略的陷阱处理开销：$C_t = 300$ 周期。\n    *   惰性策略每次上下文切换的簿记开销：$C_{\\ell} = 35$ 周期。\n    *   公共的中断进入/退出开销：$C_i$ 周期。\n    *   传入任务执行浮点指令的概率：$p$。\n2.  **验证结论**：\n    *   **科学依据**：该问题描述了惰性FPU上下文切换，这是操作系统中的一种标准优化技术。异步中断和同步陷阱之间的区别是计算机体系结构的基础。使用期望值是分析概率条件下性能的正确数学工具。\n    *   **问题明确**：问题陈述清晰，所有必要参数均已定义。它要求进行具体的推导和数值计算，这些都可以从给定信息中唯一确定。\n    *   **客观性**：该问题使用精确的技术术语表述，并提供客观的数值数据，没有主观偏见。\n\n因此，该问题是有效的，可以推导出解决方案。\n\n### 基本原理\n**异步中断**是由CPU当前指令流外部的硬件（例如，磁盘控制器发出的I/O完成信号）生成的事件。其发生时间相对于程序执行是不可预测的。**同步陷阱**（或异常）是直接因执行某条指令而发生的事件（例如，除以零，或者在本问题中，尝试使用已禁用的FPU）。\n\n一个离散随机变量 $X$ 的**期望值**，记为 $E[X]$，是其所有可能值的概率加权平均值。如果 $X$ 可以取值为 $\\{x_1, x_2, \\dots, x_n\\}$，对应的概率为 $\\{P(X=x_1), P(X=x_2), \\dots, P(X=x_n)\\}$，则其期望值由下式给出：\n$$E[X] = \\sum_{k=1}^{n} x_k P(X=x_k)$$\n在我们的情境中，随机变量是上下文切换所需的周期数，它取决于传入的任务是否使用FPU。\n\n### 任务1：积极策略的期望周期数 ($E_{eager}$)\n在积极策略下，每次由中断引发的上下文切换时，传出任务的FPU状态总是被保存，传入任务的FPU状态总是被恢复。这一系列操作是确定性的。总成本是公共中断开销与保存和恢复FPU状态的特定成本之和。\n每次上下文切换的成本是恒定的。\n$$\n\\text{Cost}_{eager} = C_i + C_s + C_r\n$$\n由于此成本以概率 $1$ 发生，因此每次上下文切换的期望周期数 $E_{eager}$ 等于此成本。\n$$\nE_{eager} = C_i + C_s + C_r\n$$\n\n### 任务2：惰性策略的期望周期数 ($E_{lazy}$)\n在惰性策略下，成本取决于传入任务是否执行浮点指令。每次上下文切换有两种互斥的结果：\n\n1.  **情况1：传入任务不执行任何浮点指令。** 此事件发生的概率为 $1-p$。在这种情况下，操作系统仅产生禁用FPU的初始簿记开销。昂贵的保存和恢复操作被完全避免。这种情况下的成本是：\n    $$\n    \\text{Cost}_1 = C_i + C_{\\ell}\n    $$\n2.  **情况2：传入任务执行至少一条浮点指令。** 此事件发生的概率为 $p$。首次尝试执行浮点指令会触发一个同步陷阱。操作系统陷阱处理程序随后保存前一个任务的FPU状态，并为当前任务恢复FPU状态。总成本包括簿记开销、陷阱处理开销以及保存和恢复FPU状态的成本。这种情况下的成本是：\n    $$\n    \\text{Cost}_2 = C_i + C_{\\ell} + C_t + C_s + C_r\n    $$\n\n根据期望值的定义，惰性策略下每次上下文切换的期望周期数 $E_{lazy}$ 是每种情况的成本乘以其各自概率的总和：\n$$\nE_{lazy} = (\\text{Cost}_1 \\times (1-p)) + (\\text{Cost}_2 \\times p)\n$$\n代入成本表达式：\n$$\nE_{lazy} = (C_i + C_{\\ell})(1-p) + (C_i + C_{\\ell} + C_t + C_s + C_r)p\n$$\n我们可以通过分配各项来简化此表达式：\n$$\nE_{lazy} = C_i(1-p) + C_{\\ell}(1-p) + C_i p + C_{\\ell} p + (C_t + C_s + C_r)p\n$$\n$$\nE_{lazy} = C_i - C_i p + C_{\\ell} - C_{\\ell} p + C_i p + C_{\\ell} p + p(C_t + C_s + C_r)\n$$\n项 $-C_i p$ 和 $+C_i p$ 相互抵消，$-C_{\\ell} p$ 和 $+C_{\\ell} p$ 也相互抵消。这导出了简化形式：\n$$\nE_{lazy} = C_i + C_{\\ell} + p(C_t + C_s + C_r)\n$$\n\n### 任务3：每次中断节省的期望周期数 ($\\Delta E$)\n节省的期望周期数 $\\Delta E$ 是积极策略的期望成本与惰性策略的期望成本之差。\n$$\n\\Delta E = E_{eager} - E_{lazy}\n$$\n代入任务1和任务2中推导出的表达式：\n$$\n\\Delta E = (C_i + C_s + C_r) - \\left( C_i + C_{\\ell} + p(C_t + C_s + C_r) \\right)\n$$\n公共中断开销 $C_i$ 被抵消：\n$$\n\\Delta E = C_s + C_r - C_{\\ell} - p(C_t + C_s + C_r)\n$$\n这个表达式可以重新排列，以突出节省的成本与额外成本的对比：\n$$\n\\Delta E = (1-p)(C_s + C_r) - C_{\\ell} - pC_t\n$$\n这种形式表明，在概率为 $1-p$ 的情况下，我们节省了完全保存/恢复的成本 $C_s+C_r$。然而，我们总是会产生惰性簿记成本 $C_{\\ell}$，并且在概率为 $p$ 的情况下，我们会产生额外的陷阱成本 $C_t$。两种形式是等价的。我们将在下一步中使用第一种推导出的形式。\n$$\n\\Delta E = (C_s + C_r - C_{\\ell}) - p(C_t + C_s + C_r)\n$$\n\n### 任务4：临界概率 ($p^{\\star}$)\n临界概率 $p^{\\star}$ 是指两种策略具有相等期望成本时的 $p$ 值。这发生在节省的期望周期数 $\\Delta E$ 为零时。\n$$\n\\Delta E = 0\n$$\n$$\n(C_s + C_r - C_{\\ell}) - p^{\\star}(C_t + C_s + C_r) = 0\n$$\n求解 $p^{\\star}$：\n$$\np^{\\star}(C_t + C_s + C_r) = C_s + C_r - C_{\\ell}\n$$\n$$\np^{\\star} = \\frac{C_s + C_r - C_{\\ell}}{C_t + C_s + C_r}\n$$\n现在，我们代入给定的数值：$C_s = 520$，$C_r = 480$，$C_t = 300$，以及 $C_{\\ell} = 35$。\n$$\np^{\\star} = \\frac{520 + 480 - 35}{300 + 520 + 480}\n$$\n$$\np^{\\star} = \\frac{1000 - 35}{300 + 1000}\n$$\n$$\np^{\\star} = \\frac{965}{1300}\n$$\n进行除法运算：\n$$\np^{\\star} \\approx 0.74230769...\n$$\n四舍五入到四位有效数字，我们得到：\n$$\np^{\\star} \\approx 0.7423\n$$\n这意味着，如果超过大约 $74.23\\%$ 的上下文切换之后会执行浮点指令，那么积极策略将比惰性策略更高效。",
            "answer": "$$\\boxed{0.7423}$$"
        }
    ]
}