{
    "hands_on_practices": [
        {
            "introduction": "现代DRAM的操作受到一系列复杂时序规则的制约，内存控制器最基本的功能就是在遵守这些约束的前提下发布命令。这个练习  要求你手动调度一个DRAM命令序列，并仔细追踪由 $t_{\\mathrm{RCD}}$、$t_{\\mathrm{RTW}}$ 和 $t_{\\mathrm{RAS}}$ 等各种时序参数所施加的依赖关系。通过解决这个问题，你将对决定内存延迟的关键路径以及所有内存调度器都必须遵守的基本约束有一个具体的理解。",
            "id": "3656949",
            "problem": "一个内存控制器针对一个单列（single-rank）、单存储体（single-bank）的动态随机存取存储器（DRAM）设备，并且必须向同一个存储体调度以下固定的命令序列：激活（$\\mathrm{ACT}$）、读取（$\\mathrm{RD}$）、写入（$\\mathrm{WR}$）、读取（$\\mathrm{RD}$）、预充电（$\\mathrm{PRE}$）。该控制器在每个命令时钟周期最多发出一个命令。以下所有时序参数均以命令时钟周期为单位。\n\n使用以下设备级约束，这些是控制器为保证正确性必须遵守的不变时序规则：\n- 行至列延迟：向一个存储体发出$\\mathrm{ACT}$命令后，发往该存储体的第一个列命令（$\\mathrm{RD}$或$\\mathrm{WR}$）必须至少延迟$t_{\\mathrm{RCD}}$个周期。\n- 列至列延迟：在向同一内存列发出的任意两个连续列命令（任何$\\mathrm{RD}$或$\\mathrm{WR}$）之间，必须至少有$t_{\\mathrm{CCD}}$个周期。\n- 读到写总线转换：从一个$\\mathrm{RD}$命令到一个后续的$\\mathrm{WR}$命令，必须至少有$t_{\\mathrm{RTW}}$个周期以允许数据总线转换。\n- 写到读总线转换：从一个$\\mathrm{WR}$命令到一个后续的$\\mathrm{RD}$命令，必须至少有$t_{\\mathrm{WTR}}$个周期以允许数据总线转换。\n- 激活到预充电（行激活时间）：向一个存储体发出$\\mathrm{ACT}$命令后，向同一个存储体发出的$\\mathrm{PRE}$命令必须至少延迟$t_{\\mathrm{RAS}}$个周期。\n- 读到预充电：向一个存储体发出$\\mathrm{RD}$命令后，向同一个存储体发出的$\\mathrm{PRE}$命令必须至少延迟$t_{\\mathrm{RTP}}$个周期。\n- 写恢复：向一个存储体发出$\\mathrm{WR}$命令后，向同一个存储体发出的$\\mathrm{PRE}$命令必须至少延迟$t_{\\mathrm{WR}}$个周期。\n\n假设：\n- 在发出$\\mathrm{ACT}$命令之前，DRAM处于空闲并已预充电状态。\n- 命令速率为每个周期一个命令（一个命令恰好占用一个命令时钟周期）。\n- 序列中的所有命令都针对同一内存列中的同一存储体。\n- 没有向任何存储体或内存列发出其他命令。\n\n时序参数为：\n- $t_{\\mathrm{RCD}} = 4$, $t_{\\mathrm{CCD}} = 4$, $t_{\\mathrm{RTW}} = 6$, $t_{\\mathrm{WTR}} = 3$, $t_{\\mathrm{RAS}} = 12$, $t_{\\mathrm{RTP}} = 4$, $t_{\\mathrm{WR}} = 6$.\n\n定义调度从周期$0$发出$\\mathrm{ACT}$命令开始。设调度长度$L$为发出$\\mathrm{PRE}$命令时的周期索引（即，从周期$0$发出$\\mathrm{ACT}$到发出$\\mathrm{PRE}$所经过的周期数）。计算满足上述所有约束的最小可能$L$。以周期为单位，用一个整数表示你的答案。",
            "solution": "该问题要求确定一个固定的动态随机存取存储器（DRAM）命令序列的最小调度长度。调度长度$L$定义为发出最后一个命令，即预充电（$\\mathrm{PRE}$）时的周期索引。调度必须遵守一组指定的时序约束。\n\n首先，让我们将问题形式化。命令序列为$\\mathrm{ACT}$、$\\mathrm{RD}$、$\\mathrm{WR}$、$\\mathrm{RD}$、$\\mathrm{PRE}$。为了区分两个读取命令，我们将其表示为$\\mathrm{RD}_1$和$\\mathrm{RD}_2$。因此，序列为$\\mathrm{ACT}, \\mathrm{RD}_1, \\mathrm{WR}, \\mathrm{RD}_2, \\mathrm{PRE}$。\n\n设$C(cmd)$为命令$cmd$发出时的周期数。问题规定调度从周期$0$发出$\\mathrm{ACT}$开始。\n所以，$C(\\mathrm{ACT}) = 0$。\n\n我们的目标是通过找到序列中每个命令的最早可能发出周期，来计算$L = C(\\mathrm{PRE})$的最小可能值。我们将按时间顺序进行。\n\n1.  **发出第一个读取命令（$\\mathrm{RD}_1$）**：\n    $\\mathrm{ACT}$之后的第一个命令是$\\mathrm{RD}_1$。由于$\\mathrm{RD}_1$是一个列命令，其发出时间受相对于$\\mathrm{ACT}$命令的行至列延迟$t_{\\mathrm{RCD}}$的约束。\n    约束为：\n    $$C(\\mathrm{RD}_1) - C(\\mathrm{ACT}) \\ge t_{\\mathrm{RCD}}$$\n    代入给定值$C(\\mathrm{ACT}) = 0$和$t_{\\mathrm{RCD}} = 4$：\n    $$C(\\mathrm{RD}_1) - 0 \\ge 4 \\implies C(\\mathrm{RD}_1) \\ge 4$$\n    可以发出$\\mathrm{RD}_1$的最早周期是周期$4$。因此，我们设定$C(\\mathrm{RD}_1) = 4$。\n\n2.  **发出写入命令（$\\mathrm{WR}$）**：\n    $\\mathrm{WR}$命令跟在$\\mathrm{RD}_1$之后。$\\mathrm{WR}$的发出受相对于$\\mathrm{RD}_1$的两个约束：\n    a.  两个连续列命令之间的列至列延迟$t_{\\mathrm{CCD}}$。\n        $$C(\\mathrm{WR}) - C(\\mathrm{RD}_1) \\ge t_{\\mathrm{CCD}}$$\n        $$C(\\mathrm{WR}) \\ge C(\\mathrm{RD}_1) + t_{\\mathrm{CCD}} = 4 + 4 = 8$$\n    b.  当$\\mathrm{WR}$跟在$\\mathrm{RD}$之后时，所需的读到写总线转换时间$t_{\\mathrm{RTW}}$。\n        $$C(\\mathrm{WR}) - C(\\mathrm{RD}_1) \\ge t_{\\mathrm{RTW}}$$\n        $$C(\\mathrm{WR}) \\ge C(\\mathrm{RD}_1) + t_{\\mathrm{RTW}} = 4 + 6 = 10$$\n    为了同时满足这两个约束，$C(\\mathrm{WR})$必须大于或等于这两个下限中的最大值：\n    $$C(\\mathrm{WR}) \\ge \\max(8, 10) = 10$$\n    $\\mathrm{WR}$的最早周期是周期$10$。因此，我们设定$C(\\mathrm{WR}) = 10$。\n\n3.  **发出第二个读取命令（$\\mathrm{RD}_2$）**：\n    $\\mathrm{RD}_2$命令跟在$\\mathrm{WR}$之后。其发出受相对于$\\mathrm{WR}$的两个约束：\n    a.  列至列延迟$t_{\\mathrm{CCD}}$。\n        $$C(\\mathrm{RD}_2) - C(\\mathrm{WR}) \\ge t_{\\mathrm{CCD}}$$\n        $$C(\\mathrm{RD}_2) \\ge C(\\mathrm{WR}) + t_{\\mathrm{CCD}} = 10 + 4 = 14$$\n    b.  当$\\mathrm{RD}$跟在$\\mathrm{WR}$之后时，所需的写到读总线转换时间$t_{\\mathrm{WTR}}$。\n        $$C(\\mathrm{RD}_2) - C(\\mathrm{WR}) \\ge t_{\\mathrm{WTR}}$$\n        $$C(\\mathrm{RD}_2) \\ge C(\\mathrm{WR}) + t_{\\mathrm{WTR}} = 10 + 3 = 13$$\n    为了同时满足这两个约束，$C(\\mathrm{RD}_2)$必须大于或等于这两个下限中的最大值：\n    $$C(\\mathrm{RD}_2) \\ge \\max(14, 13) = 14$$\n    $\\mathrm{RD}_2$的最早周期是周期$14$。因此，我们设定$C(\\mathrm{RD}_2) = 14$。\n\n4.  **发出预充电命令（$\\mathrm{PRE}$）**：\n    最后一个命令是$\\mathrm{PRE}$，其周期索引是$L = C(\\mathrm{PRE})$。$\\mathrm{PRE}$命令关闭当前激活的行。其时序受前面几个命令的约束。\n    a.  激活到预充电时间$t_{\\mathrm{RAS}}$，即行必须保持激活的最短时间。这是从$\\mathrm{ACT}$命令开始测量的。\n        $$C(\\mathrm{PRE}) - C(\\mathrm{ACT}) \\ge t_{\\mathrm{RAS}}$$\n        $$C(\\mathrm{PRE}) \\ge C(\\mathrm{ACT}) + t_{\\mathrm{RAS}} = 0 + 12 = 12$$\n    b.  写恢复时间$t_{\\mathrm{WR}}$，即在发出$\\mathrm{WR}$命令后，存储体可以被预充电之前必须经过的时间。\n        $$C(\\mathrm{PRE}) - C(\\mathrm{WR}) \\ge t_{\\mathrm{WR}}$$\n        $$C(\\mathrm{PRE}) \\ge C(\\mathrm{WR}) + t_{\\mathrm{WR}} = 10 + 6 = 16$$\n    c.  读到预充电时间$t_{\\mathrm{RTP}}$，即在发出$\\mathrm{RD}$命令后，存储体可以被预充电之前必须经过的时间。此约束必须相对于*最后*发出的读取命令来满足，即$\\mathrm{RD}_2$。\n        $$C(\\mathrm{PRE}) - C(\\mathrm{RD}_2) \\ge t_{\\mathrm{RTP}}$$\n        $$C(\\mathrm{PRE}) \\ge C(\\mathrm{RD}_2) + t_{\\mathrm{RTP}} = 14 + 4 = 18$$\n        （注意：来自$\\mathrm{RD}_1$的约束$C(\\mathrm{PRE}) \\ge C(\\mathrm{RD}_1) + t_{\\mathrm{RTP}} = 4 + 4 = 8$被来自$\\mathrm{RD}_2$的约束严格主导，因此可以忽略。）\n\n    为了满足所有这些约束，$C(\\mathrm{PRE})$必须大于或等于所有下限中的最大值：\n    $$L = C(\\mathrm{PRE}) \\ge \\max(12, 16, 18) = 18$$\n    发出$\\mathrm{PRE}$命令的最小可能周期索引是$18$。\n\n最小延迟调度如下：\n- 周期$0$：$\\mathrm{ACT}$\n- 周期$4$：$\\mathrm{RD}_1$（受$t_{\\mathrm{RCD}}$约束）\n- 周期$10$：$\\mathrm{WR}$（受$t_{\\mathrm{RTW}}$约束）\n- 周期$14$：$\\mathrm{RD}_2$（受$t_{\\mathrm{CCD}}$约束）\n- 周期$18$：$\\mathrm{PRE}$（受来自$\\mathrm{RD}_2$的$t_{\\mathrm{RTP}}$约束）\n\n最小调度长度$L$是$\\mathrm{PRE}$命令的周期索引，即$18$。",
            "answer": "$$\\boxed{18}$$"
        },
        {
            "introduction": "除了单个命令的时序，内存控制器的性能还取决于它如何处理连续的请求流，而排队论为分析这种系统级行为提供了强大的工具。该练习  将指导你应用 $M/D/1$ 排队模型（一种经典的性能分析工具）来估算内存请求的平均等待时间。这个练习展示了如何将复杂的硬件抽象成数学模型，以预测在给定工作负载下的延迟等性能指标，这是系统架构师的一项关键技能。",
            "id": "3656957",
            "problem": "一个单通道动态随机存取存储器 (DRAM) 控制器对中央处理器 (CPU) 生成的读请求采用先来先服务 (FCFS) 调度策略。经验测量表明，请求的到达间隔时间可以很好地用速率为 $\\lambda$ 的泊松过程来建模，并且控制器的服务时间主要由固定的行周期和数据突发决定，因此服务时间可以近似为确定性的，其均值为 $E[S]$。假设这是一个单服务器队列，请求不会中途放弃，且控制器是工作保持的。\n\n从泊松到达过程的基本性质、单服务器系统流量强度 $\\rho$ 的定义、泊松到达见时间平均 (PASTA) 性质以及更新过程的剩余服务时间出发，推导出一个 $M/D/1$ 队列近似模型，用于计算队列中的平均等待时间 $E[W]$（即从请求到达至其服务开始的时间，不包括其自身的服务时间）。然后，使用以下测量参数计算所得表达式的值：\n- 到达率 $\\lambda = 16 \\times 10^{6}$ 请求/秒。\n- 确定性服务时间 $E[S] = 42 \\times 10^{-9}$ 秒。\n\n使用 $M/D/1$ 近似模型，并根据给定参数提供 $E[W]$ 的数值。将您的答案四舍五入到四位有效数字，并以纳秒为单位表示。",
            "solution": "该问题要求推导 M/D/1 队列的平均等待时间，并随后进行数值计算。该系统是一个单服务器队列，具有泊松到达 (M)、确定性服务时间 (D) 和一个服务器 (1)。调度策略是先来先服务 (FCFS)。\n\n首先，我们为 M/G/1 系统（泊松到达，通用服务时间分布）推导队列中平均等待时间 $E[W]$ 的通用公式。问题指明了此推导所需的起点。一个新到达请求的等待时间 $W$ 是其在服务开始前于队列中度过的时间。这个时间等于处理该请求到达时系统中已存在的所有请求所需的总服务时间。\n\n假设一个任意请求在时间 $t$ 到达。该请求的等待时间 $W$ 是两部分之和：\n1.  当前正在服务的请求（如果有的话）的剩余服务时间 $S_{res}$。\n2.  队列中所有其他已在等待的请求的完整服务时间之和。\n\n设 $N_q$ 为我们测试请求到达时队列中的请求数量（不包括正在服务的请求）。设 $S_i$ 为队列中第 $i$ 个请求的服务时间。等待时间可以表示为：\n$$W = S_{res} + \\sum_{i=1}^{N_q} S_i$$\n为了求得平均等待时间 $E[W]$，我们对该表达式取期望：\n$$E[W] = E[S_{res}] + E\\left[\\sum_{i=1}^{N_q} S_i\\right]$$\n对于 M/G/1 队列，服务时间 $S_i$ 是独立同分布的，并且也与一个到达者所看到的队列长度 $N_q$ 无关。使用 Wald's identity，该和的期望变为：\n$$E\\left[\\sum_{i=1}^{N_q} S_i\\right] = E[N_q] E[S]$$\n其中 $E[S]$ 是平均服务时间。由于泊松到达见时间平均 (PASTA) 性质，一个到达请求所看到的队列中请求的平均数量 $E[N_q]$ 等于队列中请求数量的时间平均值。根据应用于等待请求队列的 Little's Law，这由 $E[N_q] = \\lambda E[W]$ 给出，其中 $\\lambda$ 是到达率。\n\n将这些结果代回，我们得到：\n$$E[W] = E[S_{res}] + (\\lambda E[W]) E[S]$$\n令 $\\rho = \\lambda E[S]$ 为流量强度或服务器利用率。方程变为：\n$$E[W] = E[S_{res}] + \\rho E[W]$$\n整理可得 $E[W]$（假设系统稳定，即 $\\rho  1$）：\n$$E[W](1 - \\rho) = E[S_{res}]$$\n$$E[W] = \\frac{E[S_{res}]}{1 - \\rho}$$\n下一步是求平均剩余服务时间 $E[S_{res}]$。一个到达的请求发现服务器忙碌的概率为 $\\rho$（同样根据 PASTA 性质），发现服务器空闲的概率为 $1-\\rho$。如果服务器空闲，$S_{res} = 0$。如果服务器忙碌，该请求在一个服务周期内的某个随机时间点到达。在某个服务周期内发生了一次到达的条件下，该服务周期的预期剩余时间，是更新理论中与检查悖论相关的一个经典结果。对于代表服务时间的随机变量 $S$，预期剩余寿命由 $\\frac{E[S^2]}{2 E[S]}$ 给出。\n\n因此，总平均剩余服务时间为：\n$$E[S_{res}] = P(\\text{server busy}) \\times E[\\text{residual time} | \\text{busy}] + P(\\text{server idle}) \\times 0$$\n$$E[S_{res}] = \\rho \\times \\frac{E[S^2]}{2 E[S]}$$\n代入 $\\rho = \\lambda E[S]$：\n$$E[S_{res}] = (\\lambda E[S]) \\frac{E[S^2]}{2 E[S]} = \\frac{\\lambda E[S^2]}{2}$$\n现在，我们将 $E[S_{res}]$ 的这个表达式代回到我们关于 $E[W]$ 的方程中：\n$$E[W] = \\frac{\\frac{\\lambda E[S^2]}{2}}{1 - \\rho} = \\frac{\\lambda E[S^2]}{2(1 - \\rho)}$$\n这就是 M/G/1 队列平均等待时间的 Pollaczek-Khinchine 公式。\n\n问题指定了确定性服务时间，这对应于 M/D/1 队列。对于确定性服务时间，服务持续时间 $S$ 是一个常数。设此常数为 $D$。那么，平均服务时间为 $E[S] = D$。其二阶矩为 $E[S^2] = D^2 = (E[S])^2$。\n将 $E[S^2] = (E[S])^2$ 代入 Pollaczek-Khinchine 公式：\n$$E[W] = \\frac{\\lambda (E[S])^2}{2(1 - \\rho)}$$\n由于 $\\rho = \\lambda E[S]$，我们可以将其重写为：\n$$E[W] = \\frac{(\\lambda E[S]) E[S]}{2(1 - \\rho)} = \\frac{\\rho E[S]}{2(1 - \\rho)}$$\n这是 M/D/1 队列中平均等待时间的最终表达式。\n\n现在，我们使用给定的参数计算此表达式的值：\n- 到达率 $\\lambda = 16 \\times 10^6$ 请求/秒。\n- 确定性服务时间 $E[S] = 42 \\times 10^{-9}$ 秒。\n\n首先，计算流量强度 $\\rho$：\n$$\\rho = \\lambda E[S] = (16 \\times 10^6 \\, \\text{s}^{-1}) \\times (42 \\times 10^{-9} \\, \\text{s})$$\n$$\\rho = 16 \\times 42 \\times 10^{-3} = 672 \\times 10^{-3} = 0.672$$\n由于 $\\rho = 0.672  1$，该队列是稳定的，存在稳态等待时间。\n\n接下来，计算平均等待时间 $E[W]$：\n$$E[W] = \\frac{\\rho E[S]}{2(1 - \\rho)} = \\frac{0.672 \\times (42 \\times 10^{-9} \\, \\text{s})}{2(1 - 0.672)}$$\n$$E[W] = \\frac{28.224 \\times 10^{-9} \\, \\text{s}}{2(0.328)} = \\frac{28.224 \\times 10^{-9} \\, \\text{s}}{0.656}$$\n$$E[W] \\approx 43.02439 \\times 10^{-9} \\, \\text{s}$$\n问题要求答案以纳秒为单位，并四舍五入到四位有效数字。由于 $1 \\, \\text{ns} = 10^{-9} \\, \\text{s}$：\n$$E[W] \\approx 43.02439 \\, \\text{ns}$$\n四舍五入到四位有效数字得到 $43.02 \\, \\text{ns}$。",
            "answer": "$$\\boxed{43.02}$$"
        },
        {
            "introduction": "像“先到先服务”这样的简单调度器虽然易于实现，但通常并非最优，高级调度器则通过预测未来的请求来做出智能的、前瞻性的决策以提升性能。在这个练习中 ，你将设计并实现一个前瞻性预充电策略，这是现代内存控制器中的一种常用技术。这个动手设计问题连接了理论与实践，展示了如何通过平衡利用行缓冲区局部性与为未来潜在的冲突访问做准备之间的权衡，来创建一个更智能的调度器。",
            "id": "3656923",
            "problem": "您的任务是设计并实现一个周期精确但简化的动态随机存取存储器 (DRAM) bank级调度器，该调度器会优先执行行关闭（预充电命令），以便在预测的重用分数指导下，释放bank以供未来的激活操作使用。您的设计必须从以下基本且广为接受的DRAM事实和定义出发，并逻辑地推导出一个具体的调度规则。\n\n基本依据：\n- 一个DRAM设备被划分为多个bank。每个bank都有一个行缓冲区，一次可以保持一个打开的行。\n- DRAM的核心操作是激活 (ACT)、读或写 (RD/WR) 和预充电 (PRE)。我们使用以下标准时序常数：\n  - 行到列延迟 $t_{\\mathrm{RCD}}$：从ACT到最早的RD/WR之间的最小时间。\n  - 列访问延迟 $t_{\\mathrm{CL}}$：行被激活后，服务一次读取（或写入）所需的时间。\n  - 预充电时间 $t_{\\mathrm{RP}}$：关闭当前打开行所需的时间。\n- 请求延迟定义为从请求到达bank到其完成所经过的周期数。我们假设：\n  - 如果目标行已打开（行命中），请求一旦开始服务，需要 $t_{\\mathrm{CL}}$ 个周期。\n  - 如果bank是关闭的（没有打开的行），请求一旦开始服务，需要 $t_{\\mathrm{RCD}} + t_{\\mathrm{CL}}$ 个周期。\n  - 如果打开的是一个不同的行（行冲突），服务该请求一旦开始，需要 $t_{\\mathrm{RP}} + t_{\\mathrm{RCD}} + t_{\\mathrm{CL}}$ 个周期。\n- 各个bank被独立地服务，在此模型中，命令总线不是瓶颈。一个bank不能重叠服务两个请求；它只有在当前请求完成后才能再次变为可用。\n\n预测的重用分数：\n- 对于任何当前打开的行 $r$，都会提供一个预测的重用分数 $s(r) \\in [0,1]$。将 $s(r)$ 理解为下一次访问该bank将命中同一行 $r$ 的概率，而 $1 - s(r)$ 则是命中不同行的概率。\n\n调度问题：\n- 您必须设计一个bank级策略，当一个bank变为空闲时（在当前时间或之前没有待处理的请求），该策略决定是否立即发出一个预充电（PRE）命令来关闭当前打开的行 $r$。您的设计必须是一个基于基本依据推导出的理性决策，该决策利用到下一个请求的预期关键路径时间，并且只用 $t_{\\mathrm{RCD}}$、$t_{\\mathrm{CL}}$、$t_{\\mathrm{RP}}$ 和 $s(r)$ 来表示。\n- 具体来说，推导出一个决策规则，该规则比较在空闲时间发出主动PRE的预期收益和成本，并将其实现为一个“如果 $s(r)  \\theta$ 则发出PRE”形式的阈值规则，其中 $\\theta$ 必须从基本依据中得到证明，并且只能用 $t_{\\mathrm{RCD}}$ 和 $t_{\\mathrm{RP}}$ 来表示。除了 $s(r)$ 之外，不要假设对未来的到达有任何预知能力；控制器只能在bank空闲时发出主动PRE。如果在当前时间或之前有待处理的请求，bank必须服务该请求，而不能在其前面插入一个额外的主动PRE。\n\n仿真模型：\n- 每个测试用例使用一个bank。该bank要么处于关闭状态，要么有一个打开的行，其标识符为 $r \\in \\mathbb{Z}_{\\ge 0}$。\n- 请求以元组 $(t_{\\mathrm{arr}}, r, \\mathrm{op})$ 的时间有序序列给出，其中 $t_{\\mathrm{arr}}$ 是以周期为单位的整数到达时间， $r$ 是目标行，$\\mathrm{op} \\in \\{\\mathrm{R}, \\mathrm{W}\\}$ 是操作类型。在 $t_{\\mathrm{CL}}$ 下，读和写的服务时间相同。\n- bank只有在时间 $t$ 空闲且在时间 $t$ 或之前没有已到达的请求时，才能执行主动PRE。如果选择执行主动PRE，它会在当前bank空闲时间立即开始，并占用bank $t_{\\mathrm{RP}}$ 个周期，之后bank关闭。\n- 请求在它的到达时间和当前bank空闲时间中的最大值开始服务，然后产生由该开始时间点bank状态（行命中、关闭或行冲突，如上所述）决定的相应服务时间。\n- 一个请求的延迟是其完成时间减去其到达时间，单位为周期。一个测试用例的结果是该用例中所有请求延迟的算术平均值（平均值），以周期为单位表示为一个实数。\n\n测试套件：\n使用以下四个测试用例。在每个用例中，所有时间都以周期为单位，因此输出也以周期为单位报告。预测的重用分数 $s(r)$ 按行标识符给出，并假定在整个仿真过程中保持不变。\n\n所有用例的全局时序参数：\n- $t_{\\mathrm{RCD}} = 12$\n- $t_{\\mathrm{CL}} = 10$\n- $t_{\\mathrm{RP}} = 12$\n\n用例1：\n- 时间0时的初始bank状态：打开行1。\n- 预测的重用分数：$s(1) = 0.1$。\n- 请求：一个请求 $(40, 2, \\mathrm{R})$。\n\n用例2：\n- 时间0时的初始bank状态：打开行3。\n- 预测的重用分数：$s(3) = 0.9$。\n- 请求：一个请求 $(5, 3, \\mathrm{R})$。\n\n用例3：\n- 时间0时的初始bank状态：打开行7。\n- 预测的重用分数：$s(7) = 0.5$。\n- 请求：一个请求 $(50, 9, \\mathrm{R})$。\n\n用例4：\n- 时间0时的初始bank状态：打开行4。\n- 预测的重用分数：$s(4) = 0.3$, $s(8) = 0.2$。\n- 请求：三个请求 $(0, 4, \\mathrm{R})$, $(15, 8, \\mathrm{R})$, $(60, 1, \\mathrm{R})$。\n\n要求的最终输出：\n- 您的程序应产生单行输出，其中包含每个测试用例的平均请求延迟（以周期为单位），格式为方括号括起来的逗号分隔列表，每个值四舍五入到小数点后三位，例如 $[x_1,x_2,x_3,x_4]$。\n\n程序不应读取任何输入；它必须是自包含的，并计算上述测试套件的结果。",
            "solution": "问题的核心是推导出一个理性的、基于阈值的策略，用于在DRAM bank变为空闲时发出主动预充电命令（PRE）。该决策必须基于最小化对该bank的下一个请求的预期延迟。决策规则将采用以下形式：如果一个打开的行 $r$ 的预测重用分数 $s(r)$ 低于某个阈值 $\\theta$，则为其发出一个PRE。\n\n首先，我们确定决策点。在bank变为空闲的时刻（比如时间 $t_{idle}$），考虑是否进行主动PRE。此时，有一个打开的行 $r$，并且在 $t_{idle}$ 或之前没有已到达的待处理请求。调度器必须在两种操作之间做出选择：\n\n1.  **保持打开**：在行缓冲区中保持行 $r$ 打开。\n2.  **主动预充电**：立即发出PRE命令关闭行 $r$。\n\n最优决策是能够最小化*下一个*请求的预期服务时间的决策。主动预充电策略的关键洞见在于，预充电时间 $t_{\\mathrm{RP}}$ 可以在bank的空闲期间被“隐藏”起来。我们的推导将基于这一原则，假设空闲期足够长，可以吸收 $t_{\\mathrm{RP}}$ 的成本。\n\n让我们比较在每种策略下，下一个请求的预期服务时间。\n\n**策略1：保持打开**\n如果我们保持行 $r$ 打开，下一个请求的服务时间取决于它是行命中还是行冲突。\n-   以概率 $s(r)$，下一个请求命中同一行 $r$，导致行命中。服务时间为 $t_{\\mathrm{CL}}$。\n-   以概率 $1 - s(r)$，下一个请求命中不同的行，导致行冲突。这需要一个PRE、一个ACT，然后是RD/WR访问。服务时间为 $t_{\\mathrm{RP}} + t_{\\mathrm{RCD}} + t_{\\mathrm{CL}}$。\n\n如果我们保持行打开，预期服务时间 $E_{\\text{keep}}$ 为：\n$$E_{\\text{keep}} = s(r) \\cdot t_{\\mathrm{CL}} + (1 - s(r)) \\cdot (t_{\\mathrm{RP}} + t_{\\mathrm{RCD}} + t_{\\mathrm{CL}})$$\n\n**策略2：主动预充电**\n如果我们发出一个主动PRE，当下一个请求到达时，bank将处于关闭状态。这假设从bank在 $t_{idle}$ 变为空闲到下一个请求到达之间的空闲时间大于 $t_{\\mathrm{RP}}$。\n-   以概率 $1$，下一个请求将发现一个关闭的bank，导致bank未命中（或行未命中）。这需要一个ACT命令，然后是RD/WR访问。服务时间为 $t_{\\mathrm{RCD}} + t_{\\mathrm{CL}}$。\n\n如果我们主动预充电，预期服务时间 $E_{\\text{precharge}}$ 为：\n$$E_{\\text{precharge}} = 1 \\cdot (t_{\\mathrm{RCD}} + t_{\\mathrm{CL}}) = t_{\\mathrm{RCD}} + t_{\\mathrm{CL}}$$\n\n一个理性的调度器应该在主动PRE的预期服务时间低于保持行打开的预期服务时间时，选择发出主动PRE。因此，预充电的条件是 $E_{\\text{precharge}}  E_{\\text{keep}}$。\n\n$$t_{\\mathrm{RCD}} + t_{\\mathrm{CL}}  s(r) \\cdot t_{\\mathrm{CL}} + (1 - s(r)) \\cdot (t_{\\mathrm{RP}} + t_{\\mathrm{RCD}} + t_{\\mathrm{CL}})$$\n\n让我们展开并简化这个不等式，以找到 $s(r)$ 的阈值：\n$$t_{\\mathrm{RCD}} + t_{\\mathrm{CL}}  s(r) t_{\\mathrm{CL}} + t_{\\mathrm{RP}} + t_{\\mathrm{RCD}} + t_{\\mathrm{CL}} - s(r)t_{\\mathrm{RP}} - s(r)t_{\\mathrm{RCD}} - s(r) t_{\\mathrm{CL}}$$\n\n右侧的 $s(r) t_{\\mathrm{CL}}$ 项相互抵消。\n$$t_{\\mathrm{RCD}} + t_{\\mathrm{CL}}  t_{\\mathrm{RP}} + t_{\\mathrm{RCD}} + t_{\\mathrm{CL}} - s(r)(t_{\\mathrm{RP}} + t_{\\mathrm{RCD}})$$\n\n我们可以从两侧减去 $t_{\\mathrm{RCD}} + t_{\\mathrm{CL}}$：\n$$0  t_{\\mathrm{RP}} - s(r)(t_{\\mathrm{RP}} + t_{\\mathrm{RCD}})$$\n\n现在，我们求解 $s(r)$：\n$$s(r)(t_{\\mathrm{RP}} + t_{\\mathrm{RCD}})  t_{\\mathrm{RP}}$$\n$$s(r)  \\frac{t_{\\mathrm{RP}}}{t_{\\mathrm{RP}} + t_{\\mathrm{RCD}}}$$\n\n这就得到了我们想要的阈值规则。阈值 $\\theta$ 是：\n$$\\theta = \\frac{t_{\\mathrm{RP}}}{t_{\\mathrm{RP}} + t_{\\mathrm{RCD}}}$$\n策略是：当bank变为空闲时，如果当前打开的行 $r$ 的重用分数 $s(r)  \\theta$，则发出一个主动PRE。否则，保持该行打开。\n\n使用全局指定的时序参数：\n-   $t_{\\mathrm{RCD}} = 12$ 个周期\n-   $t_{\\mathrm{RP}} = 12$ 个周期\n\n阈值 $\\theta$ 的数值为：\n$$\\theta = \\frac{12}{12 + 12} = \\frac{12}{24} = 0.5$$\n我们的调度策略是，如果 $s(r)  0.5$，则发出一个主动PRE。\n\n现在，我们将应用此策略来仿真给定的测试用例。我们同样使用 $t_{\\mathrm{CL}} = 10$。\n\n**用例1：**\n-   初始状态：时间 $t=0$，bank在行1上打开，bank空闲于 $t_{free}=0$。\n-   重用分数：$s(1) = 0.1$。\n-   请求：$(40, 2, \\mathrm{R})$。\n1.  在 $t=0$ 时，bank是空闲的。下一个请求在 $t_{arr}=40$ 到达。由于 $t_{free} \\le t_{arr}$，可以做出主动决策。\n2.  打开的行是1，其分数为 $s(1)=0.1$。我们检查条件：$s(1)  0.5$？是的，$0.1  0.5$。\n3.  操作：发出一个主动PRE。它从 $t=0$ 开始，耗时 $t_{\\mathrm{RP}}=12$ 个周期。Bank变为关闭状态，并在 $t_{free} = 0 + 12 = 12$ 时再次空闲。\n4.  请求 $(40, 2, \\mathrm{R})$ 在 $t=40$ 到达。它可以在 $\\max(t_{arr}, t_{free}) = \\max(40, 12) = 40$ 时开始服务。\n5.  在 $t=40$ 时，bank是关闭的。对行2的请求是bank未命中。服务时间 = $t_{\\mathrm{RCD}} + t_{\\mathrm{CL}} = 12 + 10 = 22$ 个周期。\n6.  请求在 $t_{comp} = 40 + 22 = 62$ 完成。\n7.  延迟 = $t_{comp} - t_{arr} = 62 - 40 = 22$ 个周期。平均延迟为 $22.0$。\n\n**用例2：**\n-   初始状态：时间 $t=0$，bank在行3上打开，bank空闲于 $t_{free}=0$。\n-   重用分数：$s(3) = 0.9$。\n-   请求：$(5, 3, \\mathrm{R})$。\n1.  在 $t=0$ 时，bank是空闲的。下一个请求在 $t_{arr}=5$ 到达。由于 $t_{free} \\le t_{arr}$，可以做出主动决策。\n2.  打开的行是3，其分数为 $s(3)=0.9$。我们检查条件：$s(3)  0.5$？不，$0.9 \\not 0.5$。\n3.  操作：保持行3打开。Bank保持空闲，空闲于 $t_{free}=0$。\n4.  请求 $(5, 3, \\mathrm{R})$ 在 $t=5$ 到达。它可以在 $\\max(5, 0) = 5$ 时开始服务。\n5.  在 $t=5$ 时，bank已打开行3。该请求针对行3，是行命中。服务时间 = $t_{\\mathrm{CL}} = 10$ 个周期。\n6.  请求在 $t_{comp} = 5 + 10 = 15$ 完成。\n7.  延迟 = $15 - 5 = 10$ 个周期。平均延迟为 $10.0$。\n\n**用例3：**\n-   初始状态：时间 $t=0$，bank在行7上打开，bank空闲于 $t_{free}=0$。\n-   重用分数：$s(7) = 0.5$。\n-   请求：$(50, 9, \\mathrm{R})$。\n1.  在 $t=0$ 时，bank是空闲的。下一个请求在 $t_{arr}=50$ 到达。由于 $t_{free} \\le t_{arr}$，可以做出主动决策。\n2.  打开的行是7，其分数为 $s(7)=0.5$。我们检查：$s(7)  0.5$？不，$0.5 \\not 0.5$（严格不等式）。\n3.  操作：保持行7打开。Bank空闲于 $t_{free}=0$。\n4.  请求 $(50, 9, \\mathrm{R})$ 在 $t=50$ 到达。它可以在 $\\max(50, 0) = 50$ 时开始服务。\n5.  在 $t=50$ 时，bank已打开行7。该请求针对行9，是行冲突。服务时间 = $t_{\\mathrm{RP}} + t_{\\mathrm{RCD}} + t_{\\mathrm{CL}} = 12 + 12 + 10 = 34$ 个周期。\n6.  请求在 $t_{comp} = 50 + 34 = 84$ 完成。\n7.  延迟 = $84 - 50 = 34$ 个周期。平均延迟为 $34.0$。\n\n**用例4：**\n-   初始状态：时间 $t=0$，bank在行4上打开，bank空闲于 $t_{free}=0$。\n-   分数：$s(4) = 0.3$, $s(8) = 0.2$。其他行分数默认为0。\n-   请求：$(0, 4, \\mathrm{R})$, $(15, 8, \\mathrm{R})$, $(60, 1, \\mathrm{R})$。\n1.  **请求1: (0, 4, R)**。在 $t_{arr}=0$ 到达。由于一个请求在 $t_{free}=0$ 时已到达，不考虑主动PRE。\n    -   开始时间：$\\max(0, 0) = 0$。\n    -   Bank已打开行4。请求针对行4。行命中。服务时间：$t_{\\mathrm{CL}} = 10$。\n    -   完成时间：$t_{comp} = 0 + 10 = 10$。延迟：$10 - 0 = 10$。\n    -   Bank现在在 $t_{free}=10$ 时空闲，行4保持打开。\n2.  **请求间歇期1**。在 $t=10$ 时，bank空闲。下一个请求在 $t_{arr}=15$ 到达。可以做出主动决策。\n    -   打开的行是4，$s(4) = 0.3$。检查：$0.3  0.5$？是的。\n    -   操作：发出主动PRE。这需要 $t_{\\mathrm{RP}}=12$ 个周期。Bank现在关闭，并在 $t_{free} = 10 + 12 = 22$ 时空闲。\n3.  **请求2: (15, 8, R)**。在 $t_{arr}=15$ 到达。\n    -   开始时间：$\\max(15, 22) = 22$。\n    -   Bank是关闭的。Bank未命中。服务时间：$t_{\\mathrm{RCD}} + t_{\\mathrm{CL}} = 12 + 10 = 22$。\n    -   现在打开行8。\n    -   完成时间：$t_{comp} = 22 + 22 = 44$。延迟：$44 - 15 = 29$。\n    -   Bank现在在 $t_{free}=44$ 时空闲，行8保持打开。\n4.  **请求间歇期2**。在 $t=44$ 时，bank空闲。下一个请求在 $t_{arr}=60$ 到达。可以做出主动决策。\n    -   打开的行是8，$s(8) = 0.2$。检查：$0.2  0.5$？是的。\n    -   操作：发出主动PRE。这需要 $t_{\\mathrm{RP}}=12$ 个周期。Bank现在关闭，并在 $t_{free} = 44 + 12 = 56$ 时空闲。\n5.  **请求3: (60, 1, R)**。在 $t_{arr}=60$ 到达。\n    -   开始时间：$\\max(60, 56) = 60$。\n    -   Bank是关闭的。Bank未命中。服务时间：$t_{\\mathrm{RCD}} + t_{\\mathrm{CL}} = 22$。\n    -   完成时间：$t_{comp} = 60 + 22 = 82$。延迟：$82 - 60 = 22$。\n6.  总延迟 = $10 + 29 + 22 = 61$。请求数 = $3$。\n7.  平均延迟 = $61 / 3 \\approx 20.333$。\n\n最终结果：\n-   用例1: $22.000$\n-   用例2: $10.000$\n-   用例3: $34.000$\n-   用例4: $20.333$",
            "answer": "[22.000, 10.000, 34.000, 20.333]"
        }
    ]
}