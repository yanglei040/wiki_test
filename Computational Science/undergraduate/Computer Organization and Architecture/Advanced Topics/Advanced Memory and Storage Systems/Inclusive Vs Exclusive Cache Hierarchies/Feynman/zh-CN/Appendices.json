{
    "hands_on_practices": [
        {
            "introduction": "包容性与排他性缓存之间最根本的区别在于它们如何管理可用空间。包容性缓存会造成数据冗余，与同样大小的排他性缓存相比，这会降低其存储唯一数据的有效容量。本练习使用一个假设的工作负载来探讨这种容量权衡的直接性能影响，帮助您量化在何种情况下包容性会成为一种负担。",
            "id": "3649269",
            "problem": "考虑一个两级数据缓存层次结构，包含上层缓存 $L_1$ 和下层缓存 $L_2$。$L_2$ 实现了包含属性（$L_1 \\subseteq L_2$，称为包含型层次结构）或排他属性（各级之间没有重复数据，称为排他型层次结构）。两个缓存都采用写回策略，使用最近最少使用 (LRU) 替换算法，并假设为全相联以分离纯粹的容量效应。设 $L_1$ 的容量为 $S_1 = 32\\,\\text{KiB}$，$L_2$ 的容量为 $S_2 = 256\\,\\text{KiB}$，块大小为 $B = 64\\,\\text{B}$。假设工作负载重复执行多个轮次，每个轮次包括：首先，重复访问一个大小为 $\\lvert H \\rvert$ 的热点集 $H$，该集合恰好能装入 $L_1$ 并常驻其中；其次，对一个大小为 $\\lvert C \\rvert$ 块的冷点集 $C$ 进行单次顺序遍历，遍历内部没有时间局部性。定义 $L_2$ 未命中率 $M_{L_2}$ 为 $L_1$ 未命中中同时也在 $L_2$ 未命中的比例。假设 $L_1$ 命中不访问 $L_2$，并且测量关注于多轮运行后的稳态，因此启动瞬态可以忽略不计。您可以假设，当 $\\lvert C \\rvert$ 能装入 $L_2$ 中未被 $H$ 的副本占用的可用容量时，冷点集的块会在不同轮次间持久保留在 $L_2$ 中；否则，它们不会持久保留。\n\n仅根据这些事实和定义，判断以下关于包含策略与排他策略如何影响 $M_{L_2}$ 的陈述中哪些是正确的。选择所有适用的选项。\n\nA. 对于 $\\lvert C \\rvert = 4000$ 块，包含型 $L_2$ 会复制 $H$ 导致没有足够空间容纳 $C$，因此稳态下对冷点集访问的 $M_{L_2}$ 接近 $1$；排他型 $L_2$ 有足够空间容纳 $C$，因此对冷点集访问的 $M_{L_2}$ 接近 $0$。在这种情况下，包含策略增加了 $M_{L_2}$。\n\nB. 对于 $\\lvert C \\rvert = 3000$ 块，包含型和排他型 $L_2$ 都能在不同轮次间保留整个冷点集，因此稳态下对冷点集访问的 $M_{L_2}$ 接近 $0$；包含策略没有增加 $M_{L_2}$。\n\nC. 对于 $\\lvert C \\rvert = 4096$ 块，包含型和排他型 $L_2$ 在稳态下都会因访问 $C$ 而发生抖动，因此包含策略不会改变 $M_{L_2}$。\n\nD. 对于 $\\lvert C \\rvert = 3584$ 块，包含型和排他型 $L_2$ 都能在不同轮次间保留冷点集，因此稳态下对冷点集访问的 $M_{L_2}$ 接近 $0$；包含策略没有增加 $M_{L_2}$。\n\nE. 对于此工作负载，包含策略降低了 $M_{L_2}$，因为 $H$ 存在于 $L_2$ 中，使得即使 $L_1$ 命中，$L_2$ 也能服务对 $H$ 的命中。",
            "solution": "## 问题验证\n\n### 第一步：提取已知条件\n-   **缓存层次结构**：两级数据缓存，上层缓存 $L_1$ 和下层缓存 $L_2$。\n-   **$L_2$ 策略**：包含型 ($L_1 \\subseteq L_2$) 或排他型 (无重复)。\n-   **缓存参数**：两个缓存都采用写回策略，使用最近最少使用 (LRU) 替换算法，并且是全相联的。\n-   **容量和块大小**：\n    -   $L_1$ 容量：$S_1 = 32\\,\\text{KiB}$。\n    -   $L_2$ 容量：$S_2 = 256\\,\\text{KiB}$。\n    -   块大小：$B = 64\\,\\text{B}$。\n-   **工作负载**：重复执行多个轮次。每个轮次包括：\n    1.  重复访问一个大小为 $\\lvert H \\rvert$ 的热点集 $H$，该集合恰好能装入 $L_1$ 并常驻其中。\n    2.  对一个大小为 $\\lvert C \\rvert$ 块的冷点集 $C$ 进行单次顺序遍历，遍历内部没有时间局部性。\n-   **度量指标**：$L_2$ 未命中率，$M_{L_2}$，是 $L_1$ 未命中中同时也在 $L_2$ 未命中的比例。\n-   **假设**：\n    1.  $L_1$ 命中不访问 $L_2$。\n    2.  测量关注于稳态；启动瞬态可以忽略不计。\n    3.  当 $\\lvert C \\rvert$ 能装入 $L_2$ 中未被 $H$ 的副本占用的可用容量时，冷点集的块会在不同轮次间持久保留在 $L_2$ 中；否则，它们不会持久保留。\n\n### 第二步：使用提取的已知条件进行验证\n根据验证标准对问题陈述进行评估。\n\n-   **科学依据**：该问题很好地基于计算机体系结构的原理，特别是缓存存储器层次结构。包含型和排他型缓存策略是标准的、定义明确的概念。该工作负载虽然经过简化，但是一个用于分析具有高局部性和流式数据混合的缓存性能的标准模型。\n-   **适定性**：问题定义清晰。目标是在变化的工作负载参数下，比较两种不同缓存策略的 $M_{L_2}$。给定的条件足以确定结果。关于集合 $C$ 稳态持久性的假设为分析提供了一个清晰、确定性的规则，使得问题可解。\n-   **客观性**：问题使用精确、定量的语言陈述。“热点集”和“冷点集”由其访问模式定义，而非主观标签。\n-   **完整性和一致性**：问题是自包含的。所有必要的容量、大小和行为都已指定。热点集 $H$ 的大小被隐式定义为 $L_1$ 的容量。让我们以块为单位计算相关大小。\n    -   $L_1$ 容量（以块计）：$S_{1, \\text{blocks}} = S_1 / B = (32 \\times 1024\\,\\text{B}) / (64\\,\\text{B}) = 512$ 块。\n    -   $L_2$ 容量（以块计）：$S_{2, \\text{blocks}} = S_2 / B = (256 \\times 1024\\,\\text{B}) / (64\\,\\text{B}) = 4096$ 块。\n    -   热点集大小：$\\lvert H \\rvert = S_{1, \\text{blocks}} = 512$ 块，因为它“恰好能装入 $L_1$”。\n    设置中没有矛盾之处。\n-   **无其他缺陷**：该问题并非不切实际、不适定、模棱两可或微不足道。它要求将包含型和排他型缓存的定义正确应用于基于容量的分析。\n\n### 第三步：结论与行动\n问题陈述有效。可以根据所提供的信息推导出严谨的解决方案。\n\n## 解题推导\n\n问题的核心是确定在包含型和排他型策略下，$L_2$ 中可用于冷点集 $C$ 的容量，然后应用给定的稳态规则。\n\n工作负载有两部分：\n1.  对热点集 $H$ 的访问。这些都是 $L_1$ 命中。问题陈述中提到“$L_1$ 命中不访问 $L_2$”。因此，这些访问不会产生到 $L_2$ 的流量，也不会影响其状态或 $M_{L_2}$ 指标。\n2.  对冷点集 $C$ 的顺序遍历。由于 $L_1$ 被常驻集 $H$ 占满，对 $C$ 中任何块的访问都将是 $L_1$ 未命中。因此，每轮的 $L_1$ 未命中次数为 $\\lvert C \\rvert$。\n$L_2$ 未命中率 $M_{L_2}$ 是这些 $L_1$ 未命中中同时也在 $L_2$ 未命中的比例。\n\n稳态行为取决于集合 $C$ 是否能在不同轮次间持久保留在 $L_2$ 中。\n-   如果 $C$ 持久保留（即，它能装入可用的 $L_2$ 容量），那么在第一轮之后，对 $C$ 的后续访问将是 $L_2$ 命中。在稳态下，$M_{L_2} \\approx 0$。\n-   如果 $C$ 不持久保留（即，它大于可用的 $L_2$ 容量），那么在一轮中获取的 $C$ 的块将在下一轮之前被逐出。在稳态下，对 $C$ 中每个块的访问都将是 $L_2$ 未命中，因此 $M_{L_2} \\approx 1$。\n\n我们来分析每种策略下可用的 $L_2$ 容量。$L_2$ 的总容量为 $S_{2, \\text{blocks}} = 4096$ 块。热点集的大小为 $\\lvert H \\rvert = 512$ 块。\n\n### 包含型层次结构 ($L_1 \\subseteq L_2$)\n根据包含属性，任何存在于 $L_1$ 中的块也必须存在于 $L_2$ 中。由于热点集 $H$ 常驻于 $L_1$，所有 $\\lvert H \\rvert = 512$ 个 $H$ 的块也必须常驻于 $L_2$。这些块被重复访问，使它们成为最近使用的块，因此它们不会被对 $C$ 的顺序扫描所逐出。\n$L_2$ 中可用于冷点集 $C$ 的容量是 $L_2$ 的总容量减去 $H$ 的副本所占用的空间：\n$$ \\text{Available } L_2 \\text{ Capacity (Inclusive)} = S_{2, \\text{blocks}} - \\lvert H \\rvert = 4096 - 512 = 3584 \\text{ blocks} $$\n因此，对于包含型层次结构，$C$ 会持久保留如果 $\\lvert C \\rvert \\le 3584$。\n-   如果 $\\lvert C \\rvert \\le 3584$，$M_{L_2} \\approx 0$。\n-   如果 $\\lvert C \\rvert > 3584$，$M_{L_2} \\approx 1$。\n\n### 排他型层次结构\n根据排他属性，一个块不能同时存在于 $L_1$ 和 $L_2$ 中。热点集 $H$ 驻留在 $L_1$ 中。因此，$H$ 的块不在 $L_2$ 中。$L_2$ 的全部容量都可用于其他数据，例如冷点集 $C$。\n$$ \\text{Available } L_2 \\text{ Capacity (Exclusive)} = S_{2, \\text{blocks}} = 4096 \\text{ blocks} $$\n因此，对于排他型层次结构，$C$ 会持久保留如果 $\\lvert C \\rvert \\le 4096$。\n-   如果 $\\lvert C \\rvert \\le 4096$，$M_{L_2} \\approx 0$。\n-   如果 $\\lvert C \\rvert > 4096$，$M_{L_2} \\approx 1$。\n\n## 逐项分析\n\n现在我们使用这些推导出的阈值来评估每个陈述。\n\n**A. 对于 $\\lvert C \\rvert = 4000$ 块，包含型 $L_2$ 会复制 $H$ 导致没有足够空间容纳 $C$，因此稳态下对冷点集访问的 $M_{L_2}$ 接近 $1$；排他型 $L_2$ 有足够空间容纳 $C$，因此对冷点集访问的 $M_{L_2}$ 接近 $0$。在这种情况下，包含策略增加了 $M_{L_2}$。**\n-   **包含型**：$\\lvert C \\rvert = 4000$。可用容量为 $3584$ 块。由于 $4000 > 3584$，冷点集 $C$ 无法装入。$C$ 的块不会持久保留，$L_2$ 将发生抖动。因此，$M_{L_2} \\approx 1$。该推理正确。\n-   **排他型**：$\\lvert C \\rvert = 4000$。可用容量为 $4096$ 块。由于 $4000 \\le 4096$，冷点集 $C$ 可以装入。$C$ 的块将会持久保留。因此，$M_{L_2} \\approx 0$。该推理正确。\n-   **比较**：包含策略导致 $M_{L_2} \\approx 1$，而排他策略导致 $M_{L_2} \\approx 0$。包含策略明显增加了 $M_{L_2}$。整个陈述是正确的。\n-   结论：**正确**。\n\n**B. 对于 $\\lvert C \\rvert = 3000$ 块，包含型和排他型 $L_2$ 都能在不同轮次间保留整个冷点集，因此稳态下对冷点集访问的 $M_{L_2}$ 接近 $0$；包含策略没有增加 $M_{L_2}$。**\n-   **包含型**：$\\lvert C \\rvert = 3000$。可用容量为 $3584$ 块。由于 $3000 \\le 3584$，$C$ 可以装入并持久保留。$M_{L_2} \\approx 0$。\n-   **排他型**：$\\lvert C \\rvert = 3000$。可用容量为 $4096$ 块。由于 $3000 \\le 4096$，$C$ 可以装入并持久保留。$M_{L_2} \\approx 0$。\n-   **比较**：两种策略都导致 $M_{L_2} \\approx 0$。因此，两者都能保留冷点集，并且包含策略没有增加 $M_{L_2}$（它保持在 $0$ 不变）。该陈述正确。\n-   结论：**正确**。\n\n**C. 对于 $\\lvert C \\rvert = 4096$ 块，包含型和排他型 $L_2$ 在稳态下都会因访问 $C$ 而发生抖动，因此包含策略不会改变 $M_{L_2}$。**\n-   **包含型**：$\\lvert C \\rvert = 4096$。可用容量为 $3584$ 块。由于 $4096 > 3584$，包含型 $L_2$ 没有足够空间容纳 $C$ 并将发生抖动。$M_{L_2} \\approx 1$。\n-   **排他型**：$\\lvert C \\rvert = 4096$。可用容量为 $4096$ 块。由于 $4096 \\le 4096$，冷点集 $C$ 恰好能装入并将持久保留。$M_{L_2} \\approx 0$。\n-   **比较**：该陈述声称两者都会抖动，这是错误的。排他型 $L_2$ 不会抖动。包含策略将 $M_{L_2}$ 从大约 $0$ 变为大约 $1$。该陈述不正确。\n-   结论：**不正确**。\n\n**D. 对于 $\\lvert C \\rvert = 3584$ 块，包含型和排他型 $L_2$ 都能在不同轮次间保留冷点集，因此稳态下对冷点集访问的 $M_{L_2}$ 接近 $0$；包含策略没有增加 $M_{L_2}$。**\n-   **包含型**：$\\lvert C \\rvert = 3584$。可用容量为 $3584$ 块。由于 $3584 \\le 3584$，$C$ 恰好能装入并持久保留。$M_{L_2} \\approx 0$。\n-   **排他型**：$\\lvert C \\rvert = 3584$。可用容量为 $4096$ 块。由于 $3584 \\le 4096$，$C$ 可以装入并持久保留。$M_{L_2} \\approx 0$。\n-   **比较**：两种策略都导致 $M_{L_2} \\approx 0$。因此，两者都能保留冷点集，并且包含策略没有增加 $M_{L_2}$。该陈述正确。\n-   结论：**正确**。\n\n**E. 对于此工作负载，包含策略降低了 $M_{L_2}$，因为 $H$ 存在于 $L_2$ 中，使得即使 $L_1$ 命中，$L_2$ 也能服务对 $H$ 的命中。**\n-   该陈述提出了两个主张。首先，包含策略*减少*了 $M_{L_2}$。我们的分析表明，对于此工作负载，包含策略要么增加 $M_{L_2}$（例如，当 $3584  \\lvert C \\rvert \\le 4096$ 时），要么使其保持不变（当 $\\lvert C \\rvert \\le 3584$ 或 $\\lvert C \\rvert > 4096$ 时）。它从未减少过 $M_{L_2}$。\n-   其次，给出的理由是“$L_2$ 可以服务对 $H$ 的命中”。这与问题假设“$L_1$ 命中不访问 $L_2$”明确矛盾。由于对 $H$ 的所有访问都是 $L_1$ 命中，因此 $H$ 在 $L_2$ 中的存在对命中没有任何好处。实际上，这是一种损害，因为它减少了 $L_2$ 对冷数据流 $C$ 的有效容量。该选项的整个前提都是有缺陷的。\n-   结论：**不正确**。",
            "answer": "$$\\boxed{ABD}$$"
        },
        {
            "introduction": "除了容量之外，包容性与排他性层次结构的选择通常还会影响其他设计决策，例如缓存的写策略。本练习要求您对两种常见设计组合所产生的写流量进行建模和比较：直写式 $L1$ 配备包容性 $L2$，与回写式 $L1$ 配备排他性 $L2$。通过推导写流量倍增器，您将深入了解这些架构选择如何影响内存带宽的消耗。",
            "id": "3649274",
            "problem": "考虑一个单核、两级缓存层次结构，其中一级（L1）数据缓存和二级（L2）缓存位于处理器和主内存之间。评估了两种设计变体对从L1到L2的写流量的影响。\n\n变体A在L1缓存中使用写通策略，并维持一个包容性的L2缓存层次结构。变体B在L1缓存中使用写回策略，并维持一个独占性的L2缓存层次结构。对于两种变体，L2缓存对主内存使用写回策略，L1缓存在写未命中时使用写分配策略。假设单字存储的大小为 $b$ 字节，缓存行大小为 $B$ 字节，且 $0  b \\leq B$。\n\n给定一个长期的稳态内存引用流，其中写引用的比例为 $w$，且 $0  w  1$。假设以下建模假设，以隔离写策略对L1到L2写流量的影响：\n\n- 在变体A（写通和包容性）中，每次在L1中命中的写操作都会立即向L2传播一个大小恰好为 $b$ 字节的写操作。读引用不会产生L1到L2的写流量。忽略任何额外的为获得所有权的读取效应；仅计算因写策略而从L1写入L2的字节数。\n\n- 在变体B（写回和独占性）中，一个驻留在L1中的缓存行在被驱逐前会经历恰好 $k$ 次访问，其中 $k$ 是一个正整数，并且与写或读的结果无关。这 $k$ 次访问中的每一次都独立地以概率 $w$ 成为写操作，以概率 $1 - w$ 成为读操作。当该缓存行最终从L1被驱逐时，只有当它在L1驻留期间至少发生过一次写操作，它才会被写入L2。如果发生这样的写回，它会向L2传输恰好 $B$ 字节。忽略任何非由写策略直接引起的其他流量。\n\n将写流量乘数 $\\mu$ 定义为变体A（写通和包容性）下每次内存引用从L1写入L2的期望字节数与变体B（写回和独占性）下相同数量的比值。推导 $\\mu$ 作为 $w$、$b$、$B$ 和 $k$ 的函数的闭式解析表达式。将最终答案表示为单个解析表达式。不需要四舍五入，最终表达式中不应包含单位。",
            "solution": "用户提供了一个来自计算机体系结构领域的问题，要求推导写流量乘数 $\\mu$ 的表达式。我将首先验证问题陈述。\n\n### 步骤1：提取已知条件\n- **系统配置**：单核处理器，两级缓存层次结构（一级或L1，二级或L2），主内存。\n- **缓存策略**：\n    - **变体A**：L1缓存为写通策略；L2缓存为包容性。\n    - **变体B**：L1缓存为写回策略；L2缓存为独占性。\n- **共享策略**：L2缓存对主内存使用写回策略。L1缓存在写未命中时使用写分配策略。\n- **数据大小**：单字存储大小为 $b$ 字节。缓存行大小为 $B$ 字节。约束：$0  b \\leq B$。\n- **工作负载**：一个长期的稳态内存引用流。写引用的比例为 $w$，其中 $0  w  1$。\n- **变体A的建模假设**：每次在L1命中的写操作都会向L2传播一个 $b$ 字节的写操作。读引用不产生L1到L2的写流量。\n- **变体B的建模假设**：L1中的一个缓存行在被驱逐前被精确访问 $k$ 次，其中 $k$ 是一个正整数。这 $k$ 次访问中的每一次都以概率 $w$ 独立地成为写操作。从L1被驱逐时，当且仅当在其驻留期间至少发生了一次写操作，该行才会被写入L2（传输 $B$ 字节）。\n- **目标**：推导写流量乘数 $\\mu$ 的闭式表达式，其定义为变体A下每次内存引用从L1写入L2的期望字节数与变体B下相同数量的比值。\n\n### 步骤2：使用提取的已知条件进行验证\n该问题在科学上基于计算机体系结构和缓存系统的原理。写通、写回、包容性/独占性层次结构以及写分配等概念都是标准术语。问题是良定的；它提供了一个简化但自洽的随机模型，并要求根据给定参数（$w, b, B, k$）推导一个特定的、可导出的量（$\\mu$）。语言客观而精确。\n\n该模型做出了一些简化假设，例如“恰好 $k$ 次访问”和定义特定的流量规则而忽略其他规则。这些是在学术背景下创建易于处理的分析模型以隔离和研究特定策略效果的典型做法。该问题不包含科学或事实上的不健全之处，是可形式化的，并且对于所要求的推导而言是完整的。“长期的稳态流”这一短语证明了使用概率期望以及在引用流上对事件（如驱逐）进行摊销是合理的。该问题被认为是有效的。\n\n### 步骤3：结论与行动\n问题是有效的。我现在将继续进行求解。\n\n问题要求推导写流量乘数 $\\mu$，其定义为：\n$$\n\\mu = \\frac{E_A}{E_B}\n$$\n其中 $E_A$ 和 $E_B$ 分别是变体A和变体B下每次内存引用从L1缓存写入L2缓存的期望字节数。\n\n**变体A（L1写通，L2包容性）分析**\n\n让我们计算 $E_A$。我们考虑来自稳态流的单个任意内存引用。\n此引用是写的概率给定为 $w$。\n此引用是读的概率为 $1-w$。\n\n问题陈述，对于变体A，“每次在L1中命中的写操作都会立即向L2传播一个大小恰好为 $b$ 字节的写操作”。它还指明L1缓存使用写分配策略。这意味着，如果一个写操作在L1中未命中，相应的缓存行首先从L2或内存取入L1。然后写操作继续进行，此时它就变成了在L1中的一次命中。由于写通策略，这次写操作随后被传播到L2。因此，由处理器发起的每一次写操作，无论最初是命中还是未命中，最终都会导致从L1向L2写入 $b$ 字节。读操作不产生写流量。\n\n每次内存引用写入的期望字节数是来自写引用和读引用的贡献之和，并按其概率加权：\n$$\nE_A = P(\\text{write}) \\times (\\text{bytes per write}) + P(\\text{read}) \\times (\\text{bytes per read})\n$$\n代入给定值：\n$$\nE_A = w \\cdot b + (1-w) \\cdot 0\n$$\n$$\nE_A = wb\n$$\n\n**变体B（L1写回，L2独占性）分析**\n\n现在，让我们计算 $E_B$。在写回缓存中，从L1到L2的写流量仅在“脏”缓存行从L1被驱逐时发生。如果一个缓存行自加载到缓存后被写入过，则认为它是脏的。\n\n模型陈述，一个缓存行在被驱逐前在L1中驻留恰好 $k$ 次访问。在一个长期的稳态引用流中，这意味着平均每 $k$ 次内存引用发生一次缓存行驱逐。因此，每次内存引用的驱逐事件频率为 $\\frac{1}{k}$。\n\n一个被驱逐的行如果是脏的，则向L2传输 $B$ 字节；如果是干净的，则传输 $0$ 字节。因此，每次驱逐的期望字节数为 $P(\\text{dirty}) \\times B$。\n每次内存引用写入的期望字节数 $E_B$ 是驱逐频率与每次驱逐传输的期望字节数的乘积：\n$$\nE_B = (\\text{Frequency of eviction}) \\times E[\\text{bytes per eviction}] = \\frac{1}{k} \\times P(\\text{dirty}) \\times B\n$$\n我们需要确定 $P(\\text{dirty})$。如果一个行在其驻留期间的 $k$ 次访问中至少有一次是写操作，则该行为脏。计算其互补事件的概率更容易：该行为干净。一个行是干净的当且仅当所有 $k$ 次访问都是读操作。\n\n各次访问是独立的。对于单次访问：\n- 成为写的概率：$w$\n- 成为读的概率：$1-w$\n\n所有 $k$ 次独立访问都是读的概率是：\n$$\nP(\\text{clean}) = P(\\text{all } k \\text{ accesses are reads}) = (1-w)^k\n$$\n该行为脏的概率是其补集：\n$$\nP(\\text{dirty}) = 1 - P(\\text{clean}) = 1 - (1-w)^k\n$$\n现在，我们可以将其代回到 $E_B$ 的表达式中：\n$$\nE_B = \\frac{B}{k} \\left(1 - (1-w)^k\\right)\n$$\n\n**写流量乘数 $\\mu$ 的计算**\n\n最后，我们计算比率 $\\mu = \\frac{E_A}{E_B}$：\n$$\n\\mu = \\frac{wb}{\\frac{B}{k} \\left(1 - (1-w)^k\\right)}\n$$\n化简此表达式得到最终的闭式结果：\n$$\n\\mu = \\frac{wbk}{B\\left(1 - (1-w)^k\\right)}\n$$\n这个 $\\mu$ 的表达式是 $w$、$b$、$B$ 和 $k$ 的函数，符合要求。",
            "answer": "$$\n\\boxed{\\frac{wbk}{B(1 - (1-w)^{k})}}\n$$"
        },
        {
            "introduction": "维护包容性属性并非没有代价；它需要一种称为反向无效化（back-invalidation）的一致性机制，即从低层级缓存中逐出的数据行会使其在上层级缓存中的对应行无效。本练习模拟了一种潜在的竞争条件，即反向无效化操作与 $L1$ 访问发生冲突，从而导致停顿。通过应用泊松过程模型，您将量化这种性能风险的概率，揭示包容性设计中一个微妙但重要的开销。",
            "id": "3649215",
            "problem": "一个单核中央处理器（CPU）拥有一个私有的 Level $1$ (L$1$) 数据缓存和一个私有的 Level $2$ (L$2$) 缓存。该缓存层次结构是包容性的：存在于 L$1$ 中的每一行也存在于 L$2$ 中，当 L$2$ 驱逐某一行时，它会向 L$1$ 发送针对该行的回溯无效化（back-invalidation）请求。考虑一个特定的缓存行，记为 $X$，它当前在 L$1$ 和 L$2$ 中都有效。命中 L$1$ 的对 $X$ 的加载操作具有确定性的服务时间，为 $\\tau_{L1} = 5$ 个周期。\n\n当 $X$ 驻留在 L$2$ 中且有效时，由 L$2$ 驱逐 $X$ 并触发对 L$1$ 的回溯无效化可以在 L$1$ 层面建模为一个均匀泊松到达过程，其无效化消息的到达率为每个周期 $\\lambda_{i} = 0.03$。假设对 $X$ 的加载操作的发出时间与无效化到达过程无关，并且在对 $X$ 的加载开始在 L$1$ 中服务之前，$X$ 在 L$1$ 中是有效的。\n\n定义一个停顿事件如下：如果在加载的 L$1$ 服务期间的开放区间内，即在 $[t, t + \\tau_{L1})$ 内（其中 $t$ 是加载的 L$1$ 服务开始时间），L$1$ 接收到针对 $X$ 的无效化请求，则该加载操作被取消并重试，从而产生归因于包容性回溯无效化竞争的停顿。\n\n仅使用包容性缓存的基本定义和均匀泊松过程的标准性质，从第一性原理推导出一个表达式，用于计算一个随机发出的对 $X$ 的加载操作因这种包容性回溯无效化竞争而停顿的概率 $p_{s}$，然后根据给定的 $\\lambda_{i}$ 和 $\\tau_{L1}$ 计算其数值。将您的答案四舍五入到 $4$ 位有效数字。最终结果以不带单位的小数形式表示。作为背景知识，简要解释为什么在排他性层次结构中（其中 L$2$ 不维护 L$1$ 中缓存行的副本），同样的竞争不会发生。",
            "solution": "首先将根据指定的完备性和合理性标准对问题进行验证。\n\n### 问题验证\n\n**步骤1：提取给定信息**\n-   系统：一个单核中央处理器（CPU）。\n-   缓存层次结构：一个私有的 Level $1$ (L$1$) 数据缓存和一个私有的 Level $2$ (L$2$) 缓存。\n-   包容性：该层次结构是包容性的，意味着存在于 L$1$ 中的每一行也存在于 L$2$ 中。当 L$2$ 驱逐某一行时，它会向 L$1$ 发送针对该行的回溯无效化请求。\n-   状态：一个缓存行 $X$ 当前在 L$1$ 和 L$2$ 中都有效。\n-   L$1$ 服务时间：命中 L$1$ 的对 $X$ 的加载操作具有确定性的服务时间，为 $\\tau_{L1} = 5$ 个周期。\n-   无效化模型：由 L$2$ 驱逐 $X$ 并触发对 L$1$ 的回溯无效化可以在 L$1$ 层面建模为一个均匀泊松到达过程，其到达率为每个周期 $\\lambda_{i} = 0.03$。\n-   假设：\n    1.  对 $X$ 的加载操作的发出时间与无效化到达过程无关。\n    2.  在对 $X$ 的加载开始在 L$1$ 中服务之前，$X$ 在 L$1$ 中是有效的。\n-   停顿事件定义：在加载的 L$1$ 服务期间的开放区间 $[t, t + \\tau_{L1})$ 内（其中 $t$ 是加载的 L$1$ 服务开始时间），L$1$ 接收到针对 $X$ 的无效化请求。\n-   要求输出：\n    1.  从第一性原理推导停顿概率 $p_{s}$ 的表达式。\n    2.  根据给定的 $\\lambda_{i}$ 和 $\\tau_{L1}$ 计算 $p_{s}$ 的数值，并四舍五入到 $4$ 位有效数字。\n    3.  简要解释为什么这种竞争条件在排他性缓存层次结构中不会发生。\n\n**步骤2：使用提取的给定信息进行验证**\n-   **科学基础**：该问题基于计算机体系结构的既定原则，特别是包容性缓存层次结构的行为。L$2$ 驱逐时进行回溯无效化是维持包容性属性的基本概念。使用均匀泊松过程是为系统性能分析中随机、独立事件建模的标准且科学有效的方法。\n-   **适定性**：该问题是适定的。它提供了所有必要的参数（$\\lambda_{i}$, $\\tau_{L1}$）、一个清晰的概率模型，以及对目标事件（停顿）的精确定义。这使得推导和计算唯一且有意义的解成为可能。\n-   **客观性**：语言正式、精确，没有主观或含糊的术语。\n-   **完整性与一致性**：该问题是自包含且内部一致的。关键假设——在加载服务开始时缓存行 $X$ 在 L$1$ 中有效——将问题隔离到服务间隔期间的竞争条件上，而这正是需要分析的核心。没有缺失必要信息，也没有相互矛盾的约束。\n-   **现实性与可行性**：提供的 L$1$ 服务时间（$\\tau_{L1} = 5$ 个周期）和无效化率（每个周期 $\\lambda_{i} = 0.03$）的数值对于现代处理器架构是物理上合理的。\n\n**步骤3：结论与行动**\n该问题被判定为**有效**，因为它科学合理、适定且完整。将提供完整的解决方案。\n\n### 解题推导\n\n该问题要求计算一个特定停顿事件的概率。该事件定义为：在 L$1$ 缓存为缓存行 $X$ 的加载操作提供服务期间，至少有一个针对该行 $X$ 的回溯无效化消息到达。\n\n设 $N(T)$ 为表示在持续时间为 $T$ 的时间间隔内无效化消息到达数量的随机变量。问题指出，这些到达遵循一个恒定率为 $\\lambda_{i}$ 的均匀泊松过程。泊松过程的概率质量函数给出了在持续时间为 $T$ 的间隔内观察到恰好 $k$ 个事件的概率：\n$$ P(N(T) = k) = \\frac{(\\lambda_{i} T)^{k} \\exp(-\\lambda_{i} T)}{k!} $$\n其中 $k$ 是一个非负整数（$k=0, 1, 2, \\dots$）。\n\n对缓存行 $X$ 的加载具有确定性的服务时间 $\\tau_{L1}$。如果在该服务期间有一个或多个无效化消息到达，则发生停顿事件。因此，所考虑的时间间隔的持续时间为 $T = \\tau_{L1}$。\n\n停顿概率 $p_{s}$ 是在长度为 $\\tau_{L1}$ 的间隔内无效化消息到达次数大于或等于一的概率。\n$$ p_{s} = P(N(\\tau_{L1}) \\ge 1) $$\n\n更直接的方法是首先计算其互补事件的概率：即在该间隔内没有无效化消息到达。使用泊松概率质量函数，设 $k=0$ 和 $T=\\tau_{L1}$：\n$$ P(N(\\tau_{L1}) = 0) = \\frac{(\\lambda_{i} \\tau_{L1})^{0} \\exp(-\\lambda_{i} \\tau_{L1})}{0!} $$\n\n根据定义，对于任何非零 $x$，$x^{0} = 1$，并且 $0! = 1$。这可将表达式简化为：\n$$ P(N(\\tau_{L1}) = 0) = \\exp(-\\lambda_{i} \\tau_{L1}) $$\n\n至少发生一个事件的概率是零个事件概率的补集。因此，停顿概率 $p_{s}$ 从第一性原理推导如下：\n$$ p_{s} = 1 - P(N(\\tau_{L1}) = 0) = 1 - \\exp(-\\lambda_{i} \\tau_{L1}) $$\n这就是停顿概率的解析表达式。\n\n接下来，我们使用给定的参数计算其数值：\n-   无效化率：$\\lambda_{i} = 0.03 \\text{ 周期}^{-1}$\n-   L$1$ 服务时间：$\\tau_{L1} = 5 \\text{ 周期}$\n\n指数的参数是乘积 $\\lambda_{i} \\tau_{L1}$：\n$$ \\lambda_{i} \\tau_{L1} = (0.03) \\times (5) = 0.15 $$\n该乘积是一个无量纲的量，符合指数的要求。\n\n将该值代入 $p_{s}$ 的表达式中：\n$$ p_{s} = 1 - \\exp(-0.15) $$\n\n计算数值：\n$$ \\exp(-0.15) \\approx 0.860707976... $$\n$$ p_{s} \\approx 1 - 0.860707976... = 0.139292023... $$\n\n将结果四舍五入到 $4$ 位有效数字，我们得到：\n$$ p_{s} \\approx 0.1393 $$\n\n### 排他性层次结构背景\n\n问题的最后一部分询问为什么这种竞争条件在排他性缓存层次结构中不会发生。排他性层次结构强制执行一个属性，即一个给定的缓存行最多只能存在于层次结构中的一个缓存中（不包括主内存）。具体来说，如果一个缓存行存在于 L$1$ 缓存中，它就不能同时存在于 L$2$ 缓存中。\n\n1.  **竞争的基本前提**：所描述的竞争条件是由 L$2$ 缓存驱逐引发的。L$2$ 缓存驱逐缓存行 $X$，并且由于层次结构是包容性的，它必须向 L$1$ 缓存发送一个回溯无效化请求，以移除其在 L$1$ 中的 $X$ 副本并维持包容性属性。这个无效化请求可能在 L$1$ 正在为对 $X$ 的加载操作提供服务时到达，从而导致停顿。\n\n2.  **排他性防止了触发条件**：在排他性层次结构中，如果缓存行 $X$ 在 L$1$ 缓存中有效（如同加载操作正在服务时的情况），那么根据定义，它*不*存在于 L$2$ 缓存中。由于缓存行 $X$ 不在 L$2$ 缓存中，L$2$ 缓存无法驱逐它。L$2$ 的驱逐只能针对驻留在 L$2$ 中的缓存行。因此，在包容性情况下触发回溯无效化的事件——即 L$2$ 对缓存行 $X$ 的驱逐——在排他性层次结构中是结构上不可能发生的。因此，L$1$ 加载访问与源自 L$2$ 的针对同一缓存行的回溯无效化之间的特定竞争条件不会发生。",
            "answer": "$$\\boxed{0.1393}$$"
        }
    ]
}