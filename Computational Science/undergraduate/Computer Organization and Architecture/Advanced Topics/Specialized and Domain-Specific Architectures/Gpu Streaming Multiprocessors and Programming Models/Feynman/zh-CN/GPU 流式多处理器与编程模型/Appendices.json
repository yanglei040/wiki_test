{
    "hands_on_practices": [
        {
            "introduction": "在GPU编程中，全局内存访问通常是性能的主要瓶颈。为了最大化吞吐量，理解和优化内存访问模式至关重要。此练习将引导您量化跨步访问（strided access）如何影响全局内存带宽利用率，这是理解内存合并（memory coalescing）背后机制的关键一步()。通过计算一个warp访问所产生的内存事务数量，您将掌握分析和改进内核内存效率的基本技能。",
            "id": "3644542",
            "problem": "图形处理单元（GPU）的流式多处理器（SM）以 $W$ 个线程为一组（称为线程束）来执行线程；在当代架构中，对于 NVIDIA 线程束，$W = 32$。考虑一个单指令多线程（SIMT）内核，其中每个线程从一个线性数组中执行一次 $b$ 字节的全局内存加载。全局内存以大小为 $S$ 字节的对齐段来服务加载请求；一个线程束的加载请求，会为该线程束中任一线程所触及的每个不同的 $S$ 字节段，产生一次事务。假设以下被广泛使用并经过实验验证的架构事实作为出发点：\n- 对于 $4$ 字节的字加载，全局内存事务是按线程束所触及的每个不同的、对齐的 $S = 128$ 字节段来发出的。\n- 每个线程束中第一个线程的基地址，记为 $A_0$，是与 $S$ 字节对齐的。\n- 线程束中的每个线程 $t \\in \\{0,1,\\dots,W-1\\}$ 读取索引为 $i_0 + t s$ 的元素，其中 $s \\in \\mathbb{N}$ 是以元素为单位的步长，每个元素 $b = 4$ 字节，因此其地址是 $A_0 + b s t$。\n\n假设内核总共读取 $N$ 个元素，其中 $N$ 是 $W$ 的倍数，从而启动整数个线程束。将内核的全局内存带宽利用率定义为，在上述事务模型下，线程实际请求的有效负载字节数与内存系统为服务这些请求而传输的总字节数之比。从上述基本定义出发，推导以下各项的闭式表达式：\n1. 每个线程束的全局内存事务数量，作为步长 $s$ 的函数。\n2. 此内核相对于完全合并的访问模式（这将为每个线程束产生一个事务）所能达到的峰值全局内存带宽的比例。\n\n在你的最终表达式中明确使用 $W = 32$、$b = 4$ 和 $S = 128$。将你的最终答案表示为关于 $s$ 的闭式解析表达式。不需要四舍五入，最终表达式中不应包含任何单位。",
            "solution": "### 推导过程\n\n#### 1. 每个线程束的全局内存事务数量\n\n设 $T(s)$ 为给定步长 $s$ 时每个线程束的全局内存事务数量。根据问题陈述，对于线程束中任一线程所触及的每个不同的 $S$ 字节内存段，都会发出一个事务。\n\n线程 $t$ 访问的内存地址由下式给出：\n$$A_t = A_0 + bst, \\quad \\text{其中 } t \\in \\{0, 1, \\dots, W-1\\}$$\n其中 $A_0$ 是基地址，$b$ 是每个元素的大小（以字节为单位），$s$ 是以元素为单位的访问步长，$t$ 是线程束内的线程索引。\n\n内存段是一个 $S$ 字节对齐的内存块。包含地址 $A$ 的段的索引由 $\\lfloor A/S \\rfloor$ 给出。线程束访问的每个唯一段索引都需要一个新的事务。\n\n线程 $t$ 的段索引，我们称之为 $k_t$，是：\n$$k_t = \\left\\lfloor \\frac{A_t}{S} \\right\\rfloor = \\left\\lfloor \\frac{A_0 + bst}{S} \\right\\rfloor$$\n\n问题陈述，基地址 $A_0$ 与 $S$ 字节对齐。这意味着 $A_0$ 是 $S$ 的整数倍，因此对于某个整数 $m$，$A_0 = mS$。这简化了 $k_t$ 的表达式：\n$$k_t = \\left\\lfloor \\frac{mS + bst}{S} \\right\\rfloor = \\left\\lfloor m + \\frac{bst}{S} \\right\\rfloor = m + \\left\\lfloor \\frac{bst}{S} \\right\\rfloor$$\n\n事务数量 $T(s)$ 是 $t \\in \\{0, 1, \\dots, W-1\\}$ 时 $k_t$ 的不同值的数量。由于 $m$ 对于线程束中的所有线程都是一个常数偏移量，因此计算 $k_t$ 的不同值的数量等同于计算 $\\lfloor bst/S \\rfloor$ 的不同值的数量。\n$$T(s) = \\left| \\left\\{ \\left\\lfloor \\frac{bst}{S} \\right\\rfloor \\mid t \\in \\{0, 1, \\dots, W-1\\} \\right\\} \\right|$$\n\n我们被给予了具体值 $W=32$、$b=4$ 和 $S=128$。将这些值代入表达式中：\n$$T(s) = \\left| \\left\\{ \\left\\lfloor \\frac{4s t}{128} \\right\\rfloor \\mid t \\in \\{0, 1, \\dots, 31\\} \\right\\} \\right| = \\left| \\left\\{ \\left\\lfloor \\frac{st}{32} \\right\\rfloor \\mid t \\in \\{0, 1, \\dots, 31\\} \\right\\} \\right|$$\n\n为了找到这个集合的大小，我们分析序列 $f(t) = \\lfloor st/32 \\rfloor$ 在 $t \\in \\{0, 1, \\dots, 31\\}$ 上的行为。$f(t)$ 的值是非负整数。最小值为 $f(0) = \\lfloor 0 \\rfloor = 0$。最大值为 $f(31) = \\lfloor 31s/32 \\rfloor$。\n\n我们根据步长 $s$ 考虑两种情况。\n\n情况 1：$1 \\le s \\le 32$。\n在这种情况下，连续线程之间向下取整函数参数的增量是 $s/32 \\le 1$。\n序列中连续值之间的差异是：\n$$f(t+1) - f(t) = \\left\\lfloor \\frac{s(t+1)}{32} \\right\\rfloor - \\left\\lfloor \\frac{st}{32} \\right\\rfloor$$\n设 $x = st/32$ 和 $\\delta = s/32$。差异是 $\\lfloor x+\\delta \\rfloor - \\lfloor x \\rfloor$。因为 $0  \\delta \\le 1$，这个差异只能是 $0$ 或 $1$。这意味着随着 $t$ 的增加，段索引序列 $f(t)$ 不会跳过任何整数值。值的集合是从最小值到最大值的完整整数范围。因此，不同值的数量是：\n$$T(s) = f(31) - f(0) + 1 = \\left\\lfloor \\frac{31s}{32} \\right\\rfloor - 0 + 1 = \\left\\lfloor \\frac{31s}{32} \\right\\rfloor + 1$$\n\n情况 2：$s > 32$。\n在这种情况下，以字节为单位的步长 $bs = 4s$ 大于段大小 $S=128$。向下取整函数参数的增量是 $s/32 > 1$。\n连续线程段索引之间的差异是：\n$$f(t+1) - f(t) = \\left\\lfloor \\frac{s(t+1)}{32} \\right\\rfloor - \\left\\lfloor \\frac{st}{32} \\right\\rfloor \\ge \\left\\lfloor \\frac{s}{32} \\right\\rfloor \\ge 1$$\n这表明对于所有 $t$，$\\lfloor s(t+1)/32 \\rfloor > \\lfloor st/32 \\rfloor$。段索引随着线程索引 $t$ 严格增加。因此，$W=32$ 个线程中的每一个都访问一个唯一的内存段。因此，事务的数量是：\n$$T(s) = W = 32$$\n\n结合这两种情况，我们可以找到一个单一的闭式表达式。\n对于 $1 \\le s \\le 32$，我们发现 $T(s) = \\lfloor 31s/32 \\rfloor + 1$。由于 $s \\le 32$，$31s/32 \\le 31$，所以 $\\lfloor 31s/32 \\rfloor \\le 31$。这意味着 $T(s) \\le 32$。\n对于 $s > 32$，$T(s)=32$。\n\n让我们测试表达式 $\\min(32, \\lfloor 31s/32 \\rfloor + 1)$。\n如果 $1 \\le s  32$，$\\lfloor 31s/32 \\rfloor + 1  32$，所以最小值是 $\\lfloor 31s/32 \\rfloor + 1$。这是正确的。\n如果 $s = 32$，$\\min(32, \\lfloor 31 \\cdot 32 / 32 \\rfloor + 1) = \\min(32, 31 + 1) = 32$。这是正确的。\n如果 $s > 32$，$s/32 > 1$。那么 $31s/32 = 31 + 31(s-32)/32$。\n$\\lfloor 31s/32 \\rfloor + 1 = 31 + \\lfloor 31(s-32)/32 \\rfloor + 1 = 32 + \\lfloor 31(s-32)/32 \\rfloor$。\n由于 $s > 32$，$s-32 \\ge 1$，所以向下取整项是非负的。因此，$\\lfloor 31s/32 \\rfloor + 1 > 32$。\n在这种情况下，$\\min(32, \\lfloor 31s/32 \\rfloor + 1) = 32$。这也是正确的。\n\n因此，每个线程束的事务数量由下式给出：\n$$T(s) = \\min\\left(32, \\left\\lfloor \\frac{31s}{32} \\right\\rfloor + 1\\right)$$\n\n#### 2. 峰值全局内存带宽的比例\n\n当每个线程束的事务数量最小时，达到峰值全局内存带宽。最小事务数量为 $1$，这发生在完全合并的访问模式下（例如，对于 $s=1$，$T(1) = \\lfloor 31/32 \\rfloor + 1 = 1$）。\n\n设 $BW(s)$ 为给定步长 $s$ 的有效带宽。带宽是单位时间内传输的有用字节数。\n每个线程束的有用负载字节数 = $W \\times b = 32 \\times 4 = 128$ 字节。\n每个线程束传输的总字节数 = $T(s) \\times S = T(s) \\times 128$ 字节。\n服务一个线程束请求所需的时间与事务数量成正比，即时间 $\\propto T(s)$。\n所以，$BW(s) \\propto \\frac{\\text{有用负载字节数}}{T(s)} = \\frac{Wb}{T(s)}$。\n\n峰值带宽 $BW_{peak}$ 对应于最小事务数量 $T_{min}=1$。\n$BW_{peak} \\propto \\frac{Wb}{1}$。\n\n达到的峰值带宽比例 $F(s)$ 是比率 $BW(s) / BW_{peak}$：\n$$F(s) = \\frac{Wb / T(s)}{Wb / 1} = \\frac{1}{T(s)}$$\n\n代入 $T(s)$ 的表达式：\n$$F(s) = \\frac{1}{\\min\\left(32, \\left\\lfloor \\frac{31s}{32} \\right\\rfloor + 1\\right)}$$\n\n所求两个量的最终表达式是：\n1.  每个线程束的事务数量：$\\min\\left(32, \\left\\lfloor \\frac{31s}{32} \\right\\rfloor + 1\\right)$\n2.  峰值带宽的比例：$\\frac{1}{\\min\\left(32, \\left\\lfloor \\frac{31s}{32} \\right\\rfloor + 1\\right)}$",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\min\\left(32, \\left\\lfloor \\frac{31s}{32} \\right\\rfloor + 1\\right)  \\frac{1}{\\min\\left(32, \\left\\lfloor \\frac{31s}{32} \\right\\rfloor + 1\\right)}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "共享内存为GPU线程块提供了一个高速暂存区，但其性能高度依赖于避免访问冲突。当多个线程同时访问同一个内存“bank”时，就会发生所谓的“bank冲突”，导致访问被串行化，从而严重降低性能。此练习将带您分析一个在矩阵乘法中常见的场景：由于不当的数据布局，导致了严重的32路bank冲突()。您将学习如何通过对数据结构进行填充（padding）来解决此问题，并定量计算由此带来的性能提升。",
            "id": "3644606",
            "problem": "考虑一个采用单指令多线程 (SIMT) 执行模型的图形处理器 (GPU) 流式多处理器 (SM)。该 SM 提供由程序员管理的共享内存，该内存被组织成 $32$ 个存储体，每个存储体每个周期可服务一个 4 字节的字。假设一个线程束包含 $32$ 个线程，一个线程束中的线程访问共享内存时，当且仅当所请求的字映射到不同的存储体时，访问才能无串行化地被服务。一个 $n$ 路存储体冲突会将访问串行化为 $n$ 个步骤。对于一个位于字节地址 $a$ 的 4 字节字，其存储体索引由经过充分测试的硬件映射规则 $b = \\left\\lfloor \\frac{a}{4} \\right\\rfloor \\bmod 32$ 给出。\n\n一个通用矩阵乘法 (GEMM) 核函数使用了共享内存分块技术。每个块以行主序存储为 $M \\times K$ 个单精度浮点数，其主维度为 $K$，元素索引 $(i,j)$ 映射到线性字索引 $iK + j$，其中 $0 \\leq i  M$ 且 $0 \\leq j  K$。假设一个线程束协同加载块中固定列索引 $j$ 的一列数据，使用线程索引 $i = 0,1,\\dots,31$ 来覆盖 $32$ 行。对于本问题，设 $K = 32$ 且 $M \\geq 32$。\n\n从以上定义出发：\n- 推导在这种按列访问模式下，原始 $M \\times K$ 布局会产生 $32$ 路存储体冲突的条件。\n- 指定一种通过将主维度填充至 $K' = K + 1$ 来避免存储体冲突的重映射布局，并写出在该重映射布局下按列访问对应的存储体索引函数。简要论证为什么这种方式能为一个访问单列的线程束消除冲突。\n\n假设以下性能模型：一次无冲突的线程束共享内存访问消耗 $1$ 个周期。一次 $n$ 路存储体冲突会为超出一步之外的每个额外串行步骤增加 $c$ 个周期的惩罚，因此带有 $n$ 路冲突的线程束访问总周期数为 $1 + (n-1)c$。假设核函数在相关阶段的运行时间主要由这些共享内存访问主导，并且所有其他成本因重映射而保持不变。\n\n在这些假设下，将因重映射带来的整体加速因子表示为关于 $c$ 的单个闭式解析表达式。无需进行取整。仅提供该加速因子作为您的最终答案。",
            "solution": "解答过程按要求分为三部分：分析原始内存布局、分析重映射布局以及计算加速比。\n\n首先，在原始布局下，共享内存中的一个块以行主序存储为一个 $M \\times K$ 的单精度（4 字节）浮点数数组。主维度为 $K$。位于 $(i,j)$ 的元素的线性字索引是 $w_{i,j} = iK + j$。这个字的字节地址是 $a_{i,j} = 4(iK+j)$。存储体索引 $b$ 由硬件规则给出：\n$$b = \\left\\lfloor \\frac{a}{4} \\right\\rfloor \\bmod 32 = (iK + j) \\bmod 32$$\n我们考虑一个包含 $32$ 个线程的线程束，其索引为 $t \\in \\{0, 1, \\dots, 31\\}$，它加载固定索引 $j_0$ 处的单一一列。线程 $t$ 访问行 $i=t$ 处的元素。因此，线程 $t$ 访问元素 $(t, j_0)$。线程 $t$ 访问的存储体索引 $b_t$ 是：\n$$b_t = (tK + j_0) \\bmod 32$$\n问题指定 $K = 32$。代入这个值，我们得到线程 $t$ 的存储体索引：\n$$b_t = (t \\cdot 32 + j_0) \\bmod 32$$\n使用模运算的性质，$(A+B) \\bmod N = ((A \\bmod N) + (B \\bmod N)) \\bmod N$：\n$$b_t = \\left( (t \\cdot 32) \\bmod 32 + j_0 \\bmod 32 \\right) \\bmod 32$$\n因为 $t$ 是一个整数，$t \\cdot 32$ 总是 $32$ 的倍数，所以 $(t \\cdot 32) \\bmod 32 = 0$。这简化了 $b_t$ 的表达式：\n$$b_t = (0 + j_0 \\bmod 32) \\bmod 32 = j_0 \\bmod 32$$\n这个结果表明，线程束中任何线程 $t$ 访问的存储体索引都与 $t$ 无关，而仅由列索引 $j_0$ 决定。所有 $32$ 个线程都试图访问映射到同一个存储体 $j_0 \\bmod 32$ 的内存字。这构成了一个 $32$ 路存储体冲突。这种按列访问模式导致 $32$ 路存储体冲突的一般条件是，主维度 $K$ 是存储体数量的倍数，即 $K \\bmod 32 = 0$。鉴于 $K=32$，此条件得到满足。\n\n接下来，分析重映射布局。为避免这种存储体冲突，对主维度进行了填充。新的主维度是 $K' = K + 1 = 32 + 1 = 33$。现在，元素 $(i,j)$ 映射到线性字索引 $w'_{i,j} = iK' + j$。相应的存储体索引函数为：\n$$b'_{i,j} = (iK' + j) \\bmod 32$$\n对于相同的按列访问，线程 $t$ 访问元素 $(t, j_0)$，其存储体索引 $b'_t$ 是：\n$$b'_t = (tK' + j_0) \\bmod 32$$\n代入 $K' = 33$：\n$$b'_t = (t \\cdot 33 + j_0) \\bmod 32 = (t \\cdot (32 + 1) + j_0) \\bmod 32 = (32t + t + j_0) \\bmod 32$$\n再次应用模运算性质：\n$$b'_t = \\left( (32t) \\bmod 32 + (t+j_0) \\bmod 32 \\right) \\bmod 32 = (0 + (t+j_0) \\bmod 32) \\bmod 32$$\n因此，在重映射布局下按列访问的存储体索引函数为：\n$$b'_t = (t + j_0) \\bmod 32$$\n这种重映射消除了存储体冲突。为了证明这一点，我们检查线程束中的线程（$t = 0, 1, \\dots, 31$）所访问的存储体索引集合。该存储体索引集合是 $\\{ (0+j_0)\\bmod 32, (1+j_0)\\bmod 32, \\dots, (31+j_0)\\bmod 32 \\}$。集合 $\\{0, 1, \\dots, 31\\}$ 是一个模 32 的完全剩余系。将一个常数整数 $j_0$ 加到该集合的每个元素上，再对 32 取模，会得到原始集合的一个排列。因此，被访问的存储体索引集合是 $\\{0, 1, \\dots, 31\\}$，其中每个索引恰好出现一次。由于所有 $32$ 个线程都访问不同的存储体，因此该访问是无冲突的。\n\n最后，计算加速因子。加速比是原始（有冲突的）访问的执行时间与新的（无冲突的）访问的执行时间之比。设 $T_{old}$ 为原始访问的时间，$T_{new}$ 为重映射后访问的时间。一次带有 $n$ 路冲突的线程束访问的时间是 $1 + (n-1)c$。\n\n对于原始布局，我们确定存在一个 $32$ 路存储体冲突，所以 $n=32$。所需时间为：\n$$T_{old} = 1 + (32-1)c = 1 + 31c$$\n对于重映射布局，访问是无冲突的。这意味着访问任何单个存储体的最大线程数是 $n=1$。所需时间为：\n$$T_{new} = 1 + (1-1)c = 1$$\n这与问题陈述中无冲突访问需要 $1$ 个周期的说法是一致的。\n\n整体加速因子是比率 $\\frac{T_{old}}{T_{new}}$。由于问题陈述核函数的运行时间主要由这些访问主导，这个比率就代表了整体加速比。\n$$\\text{加速比} = \\frac{T_{old}}{T_{new}} = \\frac{1 + 31c}{1} = 1 + 31c$$",
            "answer": "$$\\boxed{1 + 31c}$$"
        },
        {
            "introduction": "优化一个GPU内核的最终目标是平衡计算和内存访问，以充分利用硬件资源。一个内核的性能可能受限于其计算强度（计算密集型）或其数据传输速度（带宽密集型）。此练习通过一个并行的“求和规约”算法，向您介绍一种“roofline”风格的性能分析方法()。您将为一种现代的、基于warp shuffle指令的实现方案分别建立计算时间和内存时间的模型，并确定该内核从计算密集型转变为带宽密集型的临界点。",
            "id": "3644608",
            "problem": "考虑一个图形处理单元（GPU）的单个流式多处理器（SM）正在对 $N$ 个 $32$ 位浮点元素执行求和归约。我们考虑两种CUDA风格的内核：\n- 内核A使用共享内存执行树形归约，该归约在每个减半步骤都需要同步，导致在每线程累加之后，计算阶段的规模呈 $\\mathcal{O}(\\log N)$ 个warp级步骤。\n- 内核B使用warp shuffle操作来归约每线程的部分和，从而避免了使用共享内存和块级屏障。每个线程首先通过网格步长循环将其分配的元素累加到一个寄存器中，然后执行一次warp内shuffle归约，再执行一次warp间归约，以产生线程块的结果。\n\n假设该单个SM具有以下硬件和执行模型：\n- SM时钟频率为 $f = 1.0 \\times 10^{9}$ $\\text{Hz}$（即 $1.0$ $\\text{GHz}$）。\n- 此内核的持续发射率为 $I_{\\text{eff}} = 1$ warp指令/周期（即每个周期可以发射一条warp级指令）。\n- Warp大小为 $32$ 个线程，内核在SM上启动一个大小为 $T = 1024$ 个线程的线程块，该线程块会执行完毕，然后其他线程块才会被调度到此SM上。\n- 此SM有效可用的全局内存带宽为 $B = 12.0 \\times 10^{9}$ $\\text{字节} \\cdot \\text{s}^{-1}$。\n- 所有全局内存加载都是完全合并的，缓存为冷状态，且每个元素仅被读取一次。输出写操作是一个单独的 $4$ 字节存储，为完整起见可将其包括在内。\n- 内核B的warp级指令计数如下：\n  1. 每元素累加：每个元素在其所属线程中贡献一次加法；在warp级别，这对应于在所有warp上执行的 $\\frac{N}{32}$ 条warp加法指令。\n  2. Warp内归约：每个warp执行 $5$ 个shuffle步骤和 $5$ 次加法（偏移量为 $16, 8, 4, 2, 1$），每个warp总共需要 $10$ 条warp指令。对于 $W = \\frac{T}{32}$ 个warp，总共是 $10 W$ 条warp指令。\n  3. Warp间归约：一个warp使用另外 $5$ 个shuffle步骤和 $5$ 次加法来归约 $W$ 个warp的部分和，额外需要 $10$ 条warp指令。\n\n使用吞吐量的第一性原理和Roofline风格的推理，即当一个内核的总时间主要由数据移动而非指令发射主导时，该内核是带宽受限的。将内核B的总计算时间建模为warp级指令总数除以持续的warp指令吞吐量 $I_{\\text{eff}} f$，将总内存时间建模为传输的字节数除以 $B$。在这些假设下，通过求解计算时间等于内存时间的方程来确定使内核B在此单个SM上变为带宽受限的最小 $N$ 值（元素数量）。将 $N$ 表示为一个纯数字，并将最终答案四舍五入到三位有效数字。",
            "solution": "问题要求找到内核执行时间从计算受限过渡到内存受限时的 $N$ 值。这个过渡点定义为计算时间 $T_{\\text{compute}}$ 等于内存访问时间 $T_{\\text{memory}}$ 的条件。\n\n$$T_{\\text{compute}} = T_{\\text{memory}}$$\n\n首先，我们构建总内存时间 $T_{\\text{memory}}$ 的表达式。这是传输的总字节数除以可用内存带宽 $B$。传输的总数据包括读取 $N$ 个浮点元素和写入一个最终的浮点结果。由于每个元素是 $32$ 位浮点数，其大小为 $4$ 字节。\n\n读取的总字节数为 $4N$。写入的总字节数为 $4$。\n$$ \\text{Bytes}_{\\text{total}} = 4N + 4 = 4(N+1) $$\n\n给定的可用内存带宽为 $B = 12.0 \\times 10^{9}$ $\\text{字节} \\cdot \\text{s}^{-1}$。\n因此，内存时间为：\n$$ T_{\\text{memory}} = \\frac{\\text{Bytes}_{\\text{total}}}{B} = \\frac{4(N+1)}{12.0 \\times 10^{9}} \\text{ s} $$\n\n接下来，我们构建总计算时间 $T_{\\text{compute}}$ 的表达式。这是执行的warp级指令总数除以持续的warp指令吞吐量。\n\nwarp级指令的总数 $I_{\\text{total}}$ 是指定的三个部分之和：\n1.  **每元素累加：** $N$ 个元素中的每一个都需要一次加法。由于一个warp包含 $32$ 个线程，这些在整个块中的加法对应于 $\\frac{N}{32}$ 条warp级加法指令。\n2.  **Warp内归约：** 内核启动一个包含 $T = 1024$ 个线程的线程块。Warp大小为 $32$，因此块中的warp数量为 $W = \\frac{T}{32} = \\frac{1024}{32} = 32$ 个warp。每个warp执行一次内部归约，耗费 $10$ 条warp指令。此阶段总共需要 $10 \\times W = 10 \\times 32 = 320$ 条指令。\n3.  **Warp间归约：** 一个warp对来自块中所有warp的 $W=32$ 个部分和进行归约。对这 $32$ 个值进行归约需要 $\\log_2(32)=5$ 个shuffle步骤和 $5$ 次加法，总共 $10$ 条warp指令。\n\n将这些部分相加，得到warp指令的总数：\n$$ I_{\\text{total}} = \\frac{N}{32} + 320 + 10 = \\frac{N}{32} + 330 $$\n\n持续的warp指令吞吐量是发射率 $I_{\\text{eff}}$ 和时钟频率 $f$ 的乘积。\n$$ \\text{Throughput} = I_{\\text{eff}} \\times f = 1 \\frac{\\text{warp-instr}}{\\text{cycle}} \\times 1.0 \\times 10^{9} \\frac{\\text{cycles}}{\\text{s}} = 1.0 \\times 10^{9} \\frac{\\text{warp-instr}}{\\text{s}} $$\n\n因此，计算时间为：\n$$ T_{\\text{compute}} = \\frac{I_{\\text{total}}}{\\text{Throughput}} = \\frac{\\frac{N}{32} + 330}{1.0 \\times 10^{9}} \\text{ s} $$\n\n现在，我们令 $T_{\\text{compute}} = T_{\\text{memory}}$，并求解 $N$。\n$$ \\frac{\\frac{N}{32} + 330}{1.0 \\times 10^{9}} = \\frac{4(N+1)}{12.0 \\times 10^{9}} $$\n\n我们可以消去两边分母中的 $10^{9}$ 因子。\n$$ \\frac{N}{32} + 330 = \\frac{4(N+1)}{12.0} $$\n$$ \\frac{N}{32} + 330 = \\frac{N+1}{3.0} $$\n\n为了求解 $N$，我们通过两边同乘以一个公倍数（例如 $3.0 \\times 32 = 96$）来消去分母。\n$$ 96 \\left( \\frac{N}{32} \\right) + 96(330) = 96 \\left( \\frac{N+1}{3.0} \\right) $$\n$$ 3.0N + 31680 = 32(N+1) $$\n$$ 3N + 31680 = 32N + 32 $$\n\n重新整理各项以分离出 $N$：\n$$ 31680 - 32 = 32N - 3N $$\n$$ 31648 = 29N $$\n$$ N = \\frac{31648}{29} \\approx 1091.3103... $$\n\n问题要求将答案四舍五入到三位有效数字。\n$$ N \\approx 1090 $$\n\n因此，对于一个大约包含 $1090$ 个元素的数据集，计算所花费的时间等于从全局内存进行数据移动所花费的时间。当 $N$ 大于此值时，内核将是内存受限的。",
            "answer": "$$\\boxed{1090}$$"
        }
    ]
}