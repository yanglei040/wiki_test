{
    "hands_on_practices": [
        {
            "introduction": "A core tenet of System-on-Chip (SoC) design is the integration of specialized hardware accelerators to improve performance on critical tasks. However, the overall system speedup is not solely determined by how fast the accelerator is. This exercise applies Amdahl's Law, a fundamental principle in computer architecture, to quantify the real-world performance gain and its limitations. By working through this problem, you will develop the crucial skill of evaluating whether adding an accelerator is a worthwhile investment based on the portion of the workload it can actually improve .",
            "id": "3684378",
            "problem": "A System-on-Chip (SoC) integrating a fixed-function Advanced Encryption Standard (AES) accelerator is being evaluated. In the unaccelerated baseline, the total execution time of a representative workload is normalized to $1$. A fraction $p$ of this baseline time is spent in AES computations, and the remaining fraction $1-p$ is non-AES work. When the AES accelerator is integrated, it provides a $20\\times$ speedup on the AES portion relative to the baseline software running on the general-purpose core; the non-AES portion is unaffected.\n\nStarting from the definition of speedup $S$ as $S=\\frac{T_{\\text{base}}}{T_{\\text{new}}}$, and using only the partitioning of execution time into the AES and non-AES fractions, derive the overall speedup $S$ as a function of $p$ when the AES portion is accelerated by a factor of $20$. Then, determine the minimal value of $p$ required for the overall speedup to satisfy $S \\ge 3$.\n\nExpress the minimal $p$ as an exact fraction. No rounding is required.",
            "solution": "The problem is subjected to validation against the provided criteria.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n- The total execution time of the baseline workload is normalized to $1$.\n- A fraction $p$ of the baseline time is spent in AES computations.\n- The remaining fraction $1-p$ is non-AES work.\n- An AES accelerator provides a $20\\times$ speedup on the AES portion.\n- The non-AES portion is unaffected.\n- The definition of speedup is $S = \\frac{T_{\\text{base}}}{T_{\\text{new}}}$.\n- The task is to derive the overall speedup $S$ as a function of $p$.\n- The task is to determine the minimal value of $p$ required for the overall speedup to satisfy $S \\ge 3$.\n- The minimal $p$ must be expressed as an exact fraction.\n\n**Step 2: Validate Using Extracted Givens**\n- **Scientifically Grounded**: The problem is a direct application of Amdahl's Law, a fundamental concept in computer architecture used to predict the theoretical maximum speedup for a system when only part of it is improved. The context of an SoC with a hardware accelerator is realistic and scientifically sound.\n- **Well-Posed**: The problem is clearly stated and provides all necessary information to construct a mathematical model and solve for the unknowns. The goal is unambiguous.\n- **Objective**: The problem uses precise, quantitative language and is free of subjective or opinion-based statements.\n- **Completeness and Consistency**: The problem is self-contained, and the given conditions are consistent with each other. The normalization of the baseline time is a standard technique that simplifies the formulation without loss of generality.\n\n**Step 3: Verdict and Action**\nThe problem is deemed **valid** as it is scientifically grounded, well-posed, and objective. A complete solution will be provided.\n\n### Solution\n\nLet $T_{\\text{base}}$ be the total execution time of the workload on the baseline system. As stated in the problem, we normalize this time to $1$.\n$$T_{\\text{base}} = 1$$\nThe total execution time is composed of two parts: the time spent on AES computations and the time spent on non-AES work. The fraction of time for AES computations is given as $p$. Therefore, the time for the AES portion in the baseline system is:\n$$T_{\\text{AES,base}} = p \\times T_{\\text{base}} = p \\times 1 = p$$\nThe remaining fraction of time, $1-p$, is for the non-AES portion:\n$$T_{\\text{non-AES,base}} = (1-p) \\times T_{\\text{base}} = (1-p) \\times 1 = 1-p$$\n\nNext, we consider the new system with the AES accelerator. Let $T_{\\text{new}}$ be the total execution time on this new system. The AES accelerator provides a speedup of $20$ for the AES portion of the workload. The new execution time for the AES portion, $T_{\\text{AES,new}}$, is the original time divided by the speedup factor:\n$$T_{\\text{AES,new}} = \\frac{T_{\\text{AES,base}}}{20} = \\frac{p}{20}$$\nThe non-AES portion of the workload is unaffected by the accelerator, so its execution time remains the same:\n$$T_{\\text{non-AES,new}} = T_{\\text{non-AES,base}} = 1-p$$\nThe total execution time of the new system is the sum of the execution times of its components:\n$$T_{\\text{new}} = T_{\\text{non-AES,new}} + T_{\\text{AES,new}} = (1-p) + \\frac{p}{20}$$\n\nThe overall speedup $S$ is defined as the ratio of the baseline execution time to the new execution time. Substituting the expressions for $T_{\\text{base}}$ and $T_{\\text{new}}$, we can derive the overall speedup $S$ as a function of $p$:\n$$S(p) = \\frac{T_{\\text{base}}}{T_{\\text{new}}} = \\frac{1}{(1-p) + \\frac{p}{20}}$$\nThis expression represents the overall speedup as a function of the fraction of the workload that is accelerated. This is the first part of the required derivation.\n\nTo simplify the denominator:\n$$S(p) = \\frac{1}{\\frac{20(1-p)}{20} + \\frac{p}{20}} = \\frac{1}{\\frac{20 - 20p + p}{20}} = \\frac{20}{20 - 19p}$$\n\nThe second part of the problem requires finding the minimal value of $p$ for which the overall speedup $S$ is at least $3$. We set up the inequality:\n$$S(p) \\ge 3$$\n$$\\frac{20}{20 - 19p} \\ge 3$$\nSince $p$ represents a fraction of execution time, it must be that $0 \\le p \\le 1$. For this range of $p$, the denominator $20 - 19p$ is always positive. When $p=0$, the denominator is $20$. When $p=1$, the denominator is $1$. Thus, we can multiply both sides of the inequality by $20 - 19p$ without changing the direction of the inequality sign.\n$$20 \\ge 3(20 - 19p)$$\n$$20 \\ge 60 - 57p$$\nNow, we solve for $p$:\n$$57p \\ge 60 - 20$$\n$$57p \\ge 40$$\n$$p \\ge \\frac{40}{57}$$\nThe minimal value of $p$ that satisfies the condition $S \\ge 3$ is therefore $\\frac{40}{57}$. Since the problem asks for an exact fraction, this is the final answer.\nA quick verification: if $p = \\frac{40}{57}$, then $S = \\frac{20}{20 - 19(\\frac{40}{57})} = \\frac{20}{20 - \\frac{760}{57}} = \\frac{20}{\\frac{1140 - 760}{57}} = \\frac{20}{\\frac{380}{57}} = \\frac{20 \\times 57}{380} = \\frac{57}{19} = 3$. This confirms the boundary condition is met.",
            "answer": "$$\\boxed{\\frac{40}{57}}$$"
        },
        {
            "introduction": "Once an SoC's key components like processors and accelerators are chosen, they must be connected by a high-performance on-chip bus. The performance of this interconnect can become a critical system bottleneck, limiting the effectiveness of even the fastest components. This practice will guide you in distinguishing between theoretical peak bandwidth and the more realistic effective bandwidth of an industry-standard bus like AMBA AXI. You will learn to account for protocol overheads and bus arbitration, a fundamental skill for analyzing and designing an SoC's data pathways .",
            "id": "3684382",
            "problem": "A System-on-Chip (SoC) interconnect uses an Advanced Microcontroller Bus Architecture Advanced eXtensible Interface version 4 (AMBA AXI4) write data channel with a $64$-bit data bus clocked at $500\\,\\text{MHz}$. Assume a single data rate synchronous interface in which at most one data beat is transferred per clock cycle when both VALID and READY are asserted continuously. A burst consists of $L$ contiguous data beats on the data channel. Assume only one burst is outstanding at a time and that there is an average single-cycle bubble between consecutive bursts due to address/control handshaking and burst boundary effects; ignore any additional effects such as error-correcting code (ECC), interleave, or response channel back-pressure.\n\n1. Using only fundamental definitions of bandwidth as data-per-transfer times transfers-per-second, determine the theoretical peak sustained bandwidth of the data channel when bursts are back-to-back with no stalls and protocol overhead is ignored.\n\n2. Now assume the interconnect arbiter grants this master an average utilization factor $u=0.70$ of the data channel over long time windows, and that the average burst length is $L=8$ beats under the single-bubble-per-burst assumption stated above. Estimate the long-run effective bandwidth of the data channel.\n\nExpress both results in $\\text{GB/s}$ using the decimal convention $1\\,\\text{GB}=10^{9}\\,\\text{B}$. Round both numerical answers to four significant figures. Provide your final numerical results as a two-entry row vector in the order $\\big($peak bandwidth, effective bandwidth$\\big)$.",
            "solution": "The user wants me to solve a problem that calculates the bandwidth of a System-on-Chip (SoC) interconnect.\n\n### Step 1: Extract Givens\n- Bus architecture: Advanced Microcontroller Bus Architecture Advanced eXtensible Interface version 4 (AMBA AXI4) write data channel\n- Data bus width, $W_{bus}$: $64$-bit\n- Clock frequency, $f_{clk}$: $500\\,\\text{MHz}$\n- Interface type: single data rate (SDR), at most one data beat per clock cycle\n- Condition for transfer: VALID and READY asserted continuously\n- Inter-burst overhead: average of one cycle bubble between bursts\n- Average burst length, $L$: $8$ beats (for part 2)\n- Average utilization factor, $u$: $0.70$ (for part 2)\n- Output units: $\\text{GB/s}$\n- Unit conversion: $1\\,\\text{GB} = 10^{9}\\,\\text{B}$\n- Rounding: four significant figures\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded, deriving from the principles of digital logic design and computer architecture. The AXI protocol is a standard on-chip bus interconnect specification, and the concepts of bus width, clock frequency, data bursts, and channel utilization are fundamental to performance analysis in this domain. All parameters provided ($64$-bit bus, $500\\,\\text{MHz}$ clock, burst length of $8$, utilization of $70\\%$) are realistic and commonly encountered in SoC design.\n\nThe problem is well-posed. It is broken into two distinct parts: a calculation of theoretical peak bandwidth and a calculation of effective bandwidth under more realistic operating conditions. The assumptions for each part are clearly stated (e.g., \"bursts are back-to-back with no stalls\" for part 1, and \"average burst length is $L=8$\" with a \"single-cycle bubble\" and utilization factor for part 2). The problem provides all necessary data to arrive at a unique, meaningful solution for both parts. The language is objective and unambiguous.\n\nThe problem does not violate any of the invalidity criteria. It is formalizable, self-contained, and scientifically sound.\n\n### Step 3: Verdict and Action\nThe problem is valid. I will proceed with the solution.\n\n### Part 1: Theoretical Peak Sustained Bandwidth\n\nThe theoretical peak sustained bandwidth, $BW_{peak}$, is defined as the maximum rate of data transfer. This occurs when data is transferred on every clock cycle without any stalls or protocol overhead.\n\nThe data transferred in a single beat is equal to the data bus width, $W_{bus}$. We convert this from bits to bytes:\n$$ W_{bus} = 64\\,\\text{bits} \\times \\frac{1\\,\\text{Byte}}{8\\,\\text{bits}} = 8\\,\\text{Bytes} $$\n\nThe rate of transfers is determined by the clock frequency, $f_{clk}$, since the interface is single data rate and we assume a transfer occurs on every cycle.\n$$ f_{clk} = 500\\,\\text{MHz} = 500 \\times 10^{6}\\,\\text{Hz} = 500 \\times 10^{6}\\,\\text{cycles/second} $$\nIn the peak scenario, the transfer rate is $500 \\times 10^{6}\\,\\text{beats/second}$.\n\nThe peak bandwidth is the product of the data per beat and the beats per second:\n$$ BW_{peak} = W_{bus} \\times f_{clk} $$\n$$ BW_{peak} = (8\\,\\text{Bytes/beat}) \\times (500 \\times 10^{6}\\,\\text{beats/second}) $$\n$$ BW_{peak} = 4000 \\times 10^{6}\\,\\text{Bytes/second} = 4 \\times 10^{9}\\,\\text{Bytes/second} $$\n\nUsing the given decimal convention ($1\\,\\text{GB} = 10^{9}\\,\\text{B}$):\n$$ BW_{peak} = 4\\,\\text{GB/s} $$\n\nRounding to four significant figures, the result is $4.000\\,\\text{GB/s}$.\n\n### Part 2: Long-Run Effective Bandwidth\n\nThe long-run effective bandwidth, $BW_{eff}$, accounts for protocol-level inefficiencies and arbitration. Two sources of inefficiency are given: the single-cycle bubble between bursts and the arbiter utilization factor.\n\nFirst, we calculate the efficiency of data transfer due to the burst structure, $\\eta_{burst}$. A transaction consists of a burst of $L$ data beats followed by a $1$-cycle bubble.\nThe number of clock cycles to transfer the data in one burst is $L$.\nThe total number of clock cycles for one complete burst transaction (data plus overhead) is $L+1$.\n\nThe efficiency is the ratio of cycles used for data transfer to the total cycles for the transaction:\n$$ \\eta_{burst} = \\frac{\\text{Data transfer cycles}}{\\text{Total cycles}} = \\frac{L}{L+1} $$\n\nGiven an average burst length of $L=8$:\n$$ \\eta_{burst} = \\frac{8}{8+1} = \\frac{8}{9} $$\n\nSecond, the interconnect arbiter grants this master access to the data channel for only a fraction of the time, given by the utilization factor $u = 0.70$.\n\nThe effective bandwidth is the theoretical peak bandwidth reduced by both of these inefficiency factors:\n$$ BW_{eff} = BW_{peak} \\times \\eta_{burst} \\times u $$\nSubstituting the values:\n$$ BW_{eff} = (4 \\times 10^{9}\\,\\text{B/s}) \\times \\left(\\frac{8}{9}\\right) \\times 0.70 $$\n$$ BW_{eff} = \\frac{4 \\times 8 \\times 0.70}{9} \\times 10^{9}\\,\\text{B/s} $$\n$$ BW_{eff} = \\frac{22.4}{9} \\times 10^{9}\\,\\text{B/s} $$\n$$ BW_{eff} \\approx 2.4888... \\times 10^{9}\\,\\text{B/s} $$\n$$ BW_{eff} \\approx 2.4888...\\,\\text{GB/s} $$\n\nRounding to four significant figures, the result is $2.489\\,\\text{GB/s}$.\n\nThe final answer requires a two-entry row vector containing the peak bandwidth and the effective bandwidth, both in $\\text{GB/s}$ and rounded to four significant figures.\nThe values are $4.000$ and $2.489$.",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 4.000 & 2.489 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "In modern SoC design, particularly for mobile and embedded applications, power efficiency is often as important as raw performance. The software architecture and its interaction with the hardware have a profound impact on the system's total energy consumption. This exercise contrasts two fundamental I/O handling strategies—busy-wait polling and interrupt-driven servicing—to explore this trade-off. Using a standard dynamic power model, you will quantify how architectural decisions can enable low-power sleep states, dramatically improving the energy efficiency of the system .",
            "id": "3684444",
            "problem": "A system-on-chip (SoC) integrates a general-purpose core that services a periodic sensor producing one sample every $1\\,\\text{kHz}$ (period $T = 1\\,\\text{ms}$). Two servicing strategies are considered: busy-wait polling and interrupt-driven handling. The core runs at clock frequency $f_{\\text{cpu}} = 100\\,\\text{MHz}$ and supply voltage $V = 1.0\\,\\text{V}$. Use the standard dynamic power model $P_{\\text{dyn}} = \\alpha C_{\\text{L}} V^{2} f$, where $\\alpha$ is the activity factor and $C_{\\text{L}}$ is the effective switched capacitance. Assume $C_{\\text{L}} = 0.5\\,\\text{nF}$. When sleeping, the core consumes constant power $P_{\\text{sleep}} = 2\\,\\text{mW}$.\n\nThe per-sample work is identical across strategies and consists of reading and processing the sensor data plus control overhead totaling $2400$ cycles, specifically $1200$ cycles for acquisition, $800$ cycles for computation, $300$ cycles for control overhead, and $100$ cycles for wake-up/context operations. When executing this work, the activity factor is $\\alpha_{\\text{proc}} = 0.6$. In the busy-wait polling strategy, the core continuously executes a tight status-check loop for the entire period when not processing data, with activity factor $\\alpha_{\\text{spin}} = 0.2$. In the interrupt-driven strategy, the core sleeps whenever not processing data; upon the interrupt, it executes the same $2400$ cycles of work with $\\alpha_{\\text{proc}} = 0.6$ and then returns to sleep.\n\nStarting from first principles, derive the central processing unit (CPU) utilization $u_{\\text{poll}}$ and $u_{\\text{int}}$ as the fraction of time the CPU is active in the polling and interrupt strategies, respectively. Then, using the dynamic power model and the sleep power, derive the energy per event for each strategy over one sensor period $T$, and compute the energy difference $\\Delta E = E_{\\text{poll}} - E_{\\text{int}}$. Based on the sign of $\\Delta E$, decide which strategy is energetically preferable, but report only the requested numeric outputs.\n\nAnswer specification:\n- Report the CPU utilizations $u_{\\text{poll}}$ and $u_{\\text{int}}$ as decimal fractions (not percentages).\n- Report the energy difference $\\Delta E$ in microjoules.\n- Round all three reported quantities to four significant figures.\n\nProvide your final answer as a single row matrix $\\begin{pmatrix} u_{\\text{poll}} & u_{\\text{int}} & \\Delta E \\end{pmatrix}$.",
            "solution": "The problem is subjected to validation.\n\n### Step 1: Extract Givens\n- Sensor sampling frequency: $f_{\\text{sensor}} = 1\\,\\text{kHz}$\n- Sensor period: $T = 1\\,\\text{ms} = 1 \\times 10^{-3}\\,\\text{s}$\n- Core clock frequency: $f_{\\text{cpu}} = 100\\,\\text{MHz} = 100 \\times 10^6\\,\\text{Hz}$\n- Supply voltage: $V = 1.0\\,\\text{V}$\n- Dynamic power model: $P_{\\text{dyn}} = \\alpha C_{\\text{L}} V^{2} f$\n- Effective switched capacitance: $C_{\\text{L}} = 0.5\\,\\text{nF} = 0.5 \\times 10^{-9}\\,\\text{F}$\n- Sleep power (constant): $P_{\\text{sleep}} = 2\\,\\text{mW} = 2 \\times 10^{-3}\\,\\text{W}$\n- Total cycles for per-sample work: $N_{\\text{proc}} = 2400$ cycles\n- Activity factor for processing: $\\alpha_{\\text{proc}} = 0.6$\n- Activity factor for busy-wait spinning: $\\alpha_{\\text{spin}} = 0.2$\n- Polling strategy: Core is active for the entire period $T$, either processing or spin-waiting.\n- Interrupt strategy: Core is active only during processing, and sleeps otherwise.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded, well-posed, and objective. It uses the standard dynamic power model for CMOS logic ($P \\propto \\alpha C V^2 f$) and explores a classic trade-off in embedded systems design between polling and interrupt-driven I/O. All parameters are provided, are dimensionally consistent, and fall within realistic ranges for a modern system-on-chip. The problem is self-contained and free of contradictions or ambiguities.\n\n### Step 3: Verdict and Action\nThe problem is valid. A complete solution will be provided.\n\n### Solution Derivation\n\nThe goal is to compute the CPU utilization for both polling and interrupt strategies ($u_{\\text{poll}}$, $u_{\\text{int}}$) and the energy difference between them ($\\Delta E$) over one sensor period, $T$.\n\nFirst, we calculate the time required for the CPU to perform the per-sample work. The work consists of $N_{\\text{proc}} = 2400$ cycles, and the CPU clock frequency is $f_{\\text{cpu}} = 100\\,\\text{MHz}$. The processing time, $t_{\\text{proc}}$, is:\n$$t_{\\text{proc}} = \\frac{N_{\\text{proc}}}{f_{\\text{cpu}}} = \\frac{2400\\,\\text{cycles}}{100 \\times 10^6\\,\\text{cycles/s}} = 24 \\times 10^{-6}\\,\\text{s} = 24\\,\\mu\\text{s}$$\nThe sensor period is given as $T = 1\\,\\text{ms} = 1000\\,\\mu\\text{s}$.\n\n**CPU Utilization**\n\nCPU utilization, $u$, is defined as the fraction of time the CPU is in an active state (not sleeping) over the total period $T$.\n\nFor the **busy-wait polling strategy**, the CPU first executes the processing task for time $t_{\\text{proc}}$. For the remainder of the period, $T - t_{\\text{proc}}$, it executes a tight spin-wait loop. Since spinning is an active state, the CPU is active for the entire duration of the period $T$.\n$$t_{\\text{active, poll}} = t_{\\text{proc}} + (T - t_{\\text{proc}}) = T$$\nTherefore, the utilization for the polling strategy, $u_{\\text{poll}}$, is:\n$$u_{\\text{poll}} = \\frac{t_{\\text{active, poll}}}{T} = \\frac{T}{T} = 1$$\n\nFor the **interrupt-driven strategy**, the CPU is active only when performing the processing work for time $t_{\\text{proc}}$. After completion, it enters a low-power sleep state for the remainder of the period, $T - t_{\\text{proc}}$.\n$$t_{\\text{active, int}} = t_{\\text{proc}}$$\nTherefore, the utilization for the interrupt strategy, $u_{\\text{int}}$, is:\n$$u_{\\text{int}} = \\frac{t_{\\text{active, int}}}{T} = \\frac{t_{\\text{proc}}}{T} = \\frac{24 \\times 10^{-6}\\,\\text{s}}{1 \\times 10^{-3}\\,\\text{s}} = 0.024$$\n\n**Energy per Event**\n\nEnergy consumption is the integral of power over time. Since power is constant within each phase (processing, spinning, sleeping), the energy over one period $T$ is the sum of the products of the power and duration of each phase.\n\nFirst, we calculate the power consumption in each active state using the dynamic power model $P_{\\text{dyn}} = \\alpha C_{\\text{L}} V^2 f_{\\text{cpu}}$.\n- $C_{\\text{L}} = 0.5 \\times 10^{-9}\\,\\text{F}$\n- $V = 1.0\\,\\text{V}$\n- $f_{\\text{cpu}} = 100 \\times 10^6\\,\\text{Hz}$\n\nThe base power term, for $\\alpha=1$, is:\n$$ C_{\\text{L}} V^2 f_{\\text{cpu}} = (0.5 \\times 10^{-9}\\,\\text{F}) \\times (1.0\\,\\text{V})^2 \\times (100 \\times 10^6\\,\\text{s}^{-1}) = 0.05\\,\\text{W} $$\n\nPower during processing ($P_{\\text{proc}}$), with $\\alpha_{\\text{proc}} = 0.6$:\n$$P_{\\text{proc}} = \\alpha_{\\text{proc}} C_{\\text{L}} V^2 f_{\\text{cpu}} = 0.6 \\times 0.05\\,\\text{W} = 0.03\\,\\text{W} = 30\\,\\text{mW}$$\n\nPower during spin-waiting ($P_{\\text{spin}}$), with $\\alpha_{\\text{spin}} = 0.2$:\n$$P_{\\text{spin}} = \\alpha_{\\text{spin}} C_{\\text{L}} V^2 f_{\\text{cpu}} = 0.2 \\times 0.05\\,\\text{W} = 0.01\\,\\text{W} = 10\\,\\text{mW}$$\n\nThe sleep power is given as $P_{\\text{sleep}} = 2\\,\\text{mW} = 0.002\\,\\text{W}$.\n\nNow, we calculate the total energy per period for each strategy.\n\nFor the **polling strategy**, the total energy $E_{\\text{poll}}$ is the sum of the energy consumed during processing and the energy consumed during spin-waiting.\n$$E_{\\text{poll}} = P_{\\text{proc}} \\cdot t_{\\text{proc}} + P_{\\text{spin}} \\cdot (T - t_{\\text{proc}})$$\n$$E_{\\text{poll}} = (0.03\\,\\text{W}) \\cdot (24 \\times 10^{-6}\\,\\text{s}) + (0.01\\,\\text{W}) \\cdot (1000 \\times 10^{-6}\\,\\text{s} - 24 \\times 10^{-6}\\,\\text{s})$$\n$$E_{\\text{poll}} = (0.72 \\times 10^{-6}\\,\\text{J}) + (0.01\\,\\text{W}) \\cdot (976 \\times 10^{-6}\\,\\text{s})$$\n$$E_{\\text{poll}} = 0.72 \\times 10^{-6}\\,\\text{J} + 9.76 \\times 10^{-6}\\,\\text{J} = 10.48 \\times 10^{-6}\\,\\text{J} = 10.48\\,\\mu\\text{J}$$\n\nFor the **interrupt-driven strategy**, the total energy $E_{\\text{int}}$ is the sum of the energy consumed during processing and the energy consumed during sleep.\n$$E_{\\text{int}} = P_{\\text{proc}} \\cdot t_{\\text{proc}} + P_{\\text{sleep}} \\cdot (T - t_{\\text{proc}})$$\n$$E_{\\text{int}} = (0.03\\,\\text{W}) \\cdot (24 \\times 10^{-6}\\,\\text{s}) + (0.002\\,\\text{W}) \\cdot (976 \\times 10^{-6}\\,\\text{s})$$\n$$E_{\\text{int}} = 0.72 \\times 10^{-6}\\,\\text{J} + 1.952 \\times 10^{-6}\\,\\text{J} = 2.672 \\times 10^{-6}\\,\\text{J} = 2.672\\,\\mu\\text{J}$$\n\nFinally, we compute the energy difference $\\Delta E = E_{\\text{poll}} - E_{\\text{int}}$.\n$$\\Delta E = E_{\\text{poll}} - E_{\\text{int}} = 10.48 \\times 10^{-6}\\,\\text{J} - 2.672 \\times 10^{-6}\\,\\text{J} = 7.808 \\times 10^{-6}\\,\\text{J}$$\nIn the required units of microjoules, $\\Delta E = 7.808\\,\\mu\\text{J}$.\n\n**Final Numeric Values**\n\nThe problem requires rounding the results to four significant figures.\n- $u_{\\text{poll}} = 1 \\rightarrow 1.000$\n- $u_{\\text{int}} = 0.024 \\rightarrow 0.02400$\n- $\\Delta E = 7.808\\,\\mu\\text{J} \\rightarrow 7.808$\n\nThe positive sign of $\\Delta E$ indicates that the polling strategy is more energy-intensive than the interrupt-driven strategy.\n\nThe final answer will be presented as a row matrix $\\begin{pmatrix} u_{\\text{poll}} & u_{\\text{int}} & \\Delta E \\end{pmatrix}$.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix} 1.000 & 0.02400 & 7.808 \\end{pmatrix}\n}\n$$"
        }
    ]
}