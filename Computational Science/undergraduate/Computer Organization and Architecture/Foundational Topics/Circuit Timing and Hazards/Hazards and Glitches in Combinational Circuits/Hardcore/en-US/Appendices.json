{
    "hands_on_practices": [
        {
            "introduction": "The first step in designing robust combinational circuits is learning to identify and eliminate static hazards. This practice focuses on the classic method for handling static-1 hazards in sum-of-products (SOP) circuits using Karnaugh maps . By visualizing the function, you will see how transitions between adjacent states covered by different product terms can cause glitches and learn to add redundant 'bridging' terms to ensure the output remains stable.",
            "id": "3647551",
            "problem": "A combinational network implements the Boolean function $f$ in sum-of-products form using two-input AND gates and a multi-input OR gate. The function is $f=(A\\cdot B)+(C\\cdot D)+(\\overline{A}\\cdot \\overline{D})$, where $A$, $B$, $C$, and $D$ are binary inputs. Because the physical gates have nonzero propagation delays, the network can exhibit static glitches (static hazards) if adjacent $1$-cells on the Karnaugh map (K-map) are covered by different product terms with no single product term covering both. Starting from the foundational definition that a static-$1$ hazard occurs when the output should remain at logic $1$ for a single-input transition but momentarily falls to logic $0$ due to unequal path delays, construct the $4$-variable K-map for $f$, mark the groupings corresponding to the given implicants, analyze all single-variable adjacencies that remain uncovered by a single implicant, and add only the minimal bridging implicants needed to eliminate every static-$1$ hazard while preserving the logical function of $f$. Report the final hazard-free sum-of-products expression using only the variables $A$, $B$, $C$, $D$, the logical AND $\\cdot$, OR $+$, and complement $\\overline{(\\cdot)}$. Your final answer must be a single closed-form expression.",
            "solution": "The problem requires the elimination of static-1 hazards from a combinational circuit implementing the function $f=(A\\cdot B)+(C\\cdot D)+(\\overline{A}\\cdot \\overline{D})$. A static-1 hazard may occur in a sum-of-products (SOP) implementation when two adjacent minterms on a Karnaugh map (K-map) are covered by different product terms, and no single product term covers both. This can cause the output to momentarily go to $0$ during a single-input variable transition for which the output should remain at a constant $1$.\n\nFirst, we construct the $4$-variable K-map for the function $f$. The variables are $A$, $B$, $C$, and $D$. We will arrange the map with $AB$ on the vertical axis and $CD$ on the horizontal axis, using Gray code ordering. The minterms (represented by their decimal values) are placed in the grid as follows:\n$$\n\\begin{array}{c|c|c|c|c|}\n\\multicolumn{1}{c}{}  \\multicolumn{4}{c}{CD} \\\\\n\\cline{3-5}\n\\multicolumn{1}{c}{AB}  00  01  11  10 \\\\\n\\cline{2-5}\n00  m_0  m_1  m_3  m_2 \\\\\n\\cline{2-5}\n01  m_4  m_5  m_7  m_6 \\\\\n\\cline{2-5}\n11  m_{12}  m_{13}  m_{15}  m_{14} \\\\\n\\cline{2-5}\n10  m_8  m_9  m_{11}  m_{10} \\\\\n\\cline{2-5}\n\\end{array}\n$$\nWe populate the map by placing a $1$ for each minterm included in the function $f$.\nThe function is $f=P_1+P_2+P_3$, where $P_1=(A\\cdot B)$, $P_2=(C\\cdot D)$, and $P_3=(\\overline{A}\\cdot \\overline{D})$.\n\\begin{itemize}\n    \\item The term $P_1 = (A\\cdot B)$ covers the minterms where $A=1$ and $B=1$: $\\{m_{12}, m_{13}, m_{14}, m_{15}\\}$.\n    \\item The term $P_2 = (C\\cdot D)$ covers the minterms where $C=1$ and $D=1$: $\\{m_3, m_7, m_{11}, m_{15}\\}$.\n    \\item The term $P_3 = (\\overline{A}\\cdot \\overline{D})$ covers the minterms where $A=0$ and $D=0$: $\\{m_0, m_2, m_4, m_6\\}$.\n\\end{itemize}\nThe complete set of minterms for which $f=1$ is the union of these sets: $S = \\{0, 2, 3, 4, 6, 7, 11, 12, 13, 14, 15\\}$.\nThe populated K-map is:\n$$\n\\begin{array}{c|c|c|c|c|}\n\\multicolumn{1}{c}{}  \\multicolumn{4}{c}{CD} \\\\\n\\cline{3-5}\n\\multicolumn{1}{c}{AB}  00  01  11  10 \\\\\n\\cline{2-5}\n00  \\mathbf{1}_{P_3}  0  \\mathbf{1}_{P_2}  \\mathbf{1}_{P_3} \\\\\n\\cline{2-5}\n01  \\mathbf{1}_{P_3}  0  \\mathbf{1}_{P_2}  \\mathbf{1}_{P_3} \\\\\n\\cline{2-5}\n11  \\mathbf{1}_{P_1}  \\mathbf{1}_{P_1}  \\mathbf{1}_{P_1,P_2}  \\mathbf{1}_{P_1} \\\\\n\\cline{2-5}\n10  0  0  \\mathbf{1}_{P_2}  0 \\\\\n\\cline{2-5}\n\\end{array}\n$$\nThe subscripts indicate which of the original product terms cover each $1$-cell.\n\nStatic-1 hazards exist for transitions between adjacent $1$-cells that are not covered by a common product term. We can identify these by inspection of the map or by computing the consensus terms between pairs of product terms that have one variable in common, one complemented and one not. The consensus theorem states that for an expression $XY + \\overline{X}Z$, the consensus term is $YZ$. Adding this term eliminates the hazard associated with the transition of variable $X$.\n\nWe examine the pairs of given product terms:\n1.  $P_1=(A\\cdot B)$ and $P_3=(\\overline{A}\\cdot \\overline{D})$: These terms have the variable $A$ in opposition. The consensus term is $(B) \\cdot (\\overline{D}) = B\\cdot \\overline{D}$.\n    This term covers the adjacencies between 1s covered by $P_1$ and 1s covered by $P_3$.\n    For example, the transition between $m_4(0100)$ and $m_{12}(1100)$ involves a change in $A$ while $B=1, C=0, D=0$. For these inputs, $f$ reduces to $f = (A\\cdot 1) + (0\\cdot 0) + (\\overline{A}\\cdot \\overline{0}) = A + \\overline{A}$, which is a classic static hazard. Adding the term $B\\overline{D}$ covers both $m_4$ and $m_{12}$ (since for both, $B=1, D=0$), resolving the hazard. Similarly, it covers the adjacency between $m_6(0110)$ and $m_{14}(1110)$.\n\n2.  $P_2=(C\\cdot D)$ and $P_3=(\\overline{A}\\cdot \\overline{D})$: These terms have the variable $D$ in opposition. The consensus term is $(C) \\cdot (\\overline{A}) = \\overline{A}\\cdot C$.\n    This term covers adjacencies between 1s covered by $P_2$ and 1s covered by $P_3$.\n    For example, consider the transition between $m_2(0010)$ and $m_3(0011)$, which involves a change in $D$ while $A=0, B=0, C=1$. For these inputs, $f$ reduces to $f = (0\\cdot 0) + (1\\cdot D) + (\\overline{0}\\cdot \\overline{D}) = D + \\overline{D}$, a static hazard. Adding the term $\\overline{A}C$ covers both $m_2$ and $m_3$ (since for both, $A=0, C=1$), resolving the hazard. Similarly, it covers the adjacency between $m_6(0110)$ and $m_7(0111)$.\n\n3.  $P_1=(A\\cdot B)$ and $P_2=(C\\cdot D)$: These terms do not have any variable appearing in both complemented and uncomplemented form. Therefore, there is no consensus term to be generated from this pair.\n\nThe minimal bridging implicants required to eliminate all static-1 hazards are the two consensus terms we found: $B\\cdot\\overline{D}$ and $\\overline{A}\\cdot C$. It is important to verify that these terms only cover cells that are already $1$ in the original function, ensuring the logic function of $f$ is preserved.\n\\begin{itemize}\n    \\item Term $B\\cdot \\overline{D}$ covers minterms where $B=1, D=0$: $\\{m_4, m_6, m_{12}, m_{14}\\}$. All are $1$s in $f$.\n    \\item Term $\\overline{A}\\cdot C$ covers minterms where $A=0, C=1$: $\\{m_2, m_3, m_6, m_7\\}$. All are $1$s in $f$.\n\\end{itemize}\nThe condition is satisfied. The final hazard-free expression is the logical OR of the original terms and the two new bridging terms.\n\nThe original function is $f_{orig} = (A\\cdot B)+(C\\cdot D)+(\\overline{A}\\cdot \\overline{D})$.\nThe added hazard-covering terms are $(B \\cdot \\overline{D})$ and $(\\overline{A} \\cdot C)$.\nThe final hazard-free function is $f_{hf} = (A\\cdot B)+(C\\cdot D)+(\\overline{A}\\cdot \\overline{D})+(B\\cdot \\overline{D})+(\\overline{A}\\cdot C)$.\nThis expression is guaranteed to be free of static-1 hazards.",
            "answer": "$$\\boxed{(A\\cdot B)+(C\\cdot D)+(\\overline{A}\\cdot \\overline{D})+(B\\cdot \\overline{D})+(\\overline{A}\\cdot C)}$$"
        },
        {
            "introduction": "A logical hazard does not always translate into a problematic glitch at the output; the physical nature of the gates plays a critical role. This exercise explores this concept by comparing two fundamental delay models: the idealized transport delay and the more realistic inertial delay . Through a simulated scenario, you will discover how inertial delay can naturally filter out short transient pulses, a key principle in understanding why some circuits are more resilient to hazards than others.",
            "id": "3647505",
            "problem": "You are asked to study hazards and glitches in combinational circuits by comparing two delay models for a simple Boolean network implementing the function $f(A,B)=\\overline{A}+\\overline{B}$. The network is composed of two NOT gates that generate $\\overline{A}$ and $\\overline{B}$, followed by an OR gate that computes the sum. You must analytically derive, and then simulate, how a single glitch on input $A$ propagates to the output under two delay models: transport delay and inertial delay. You must start from the following fundamental base:\n- Boolean algebra and logic gate definitions: a NOT gate outputs the logical complement; an OR gate outputs logical $1$ if any input is logical $1$, otherwise logical $0$.\n- Timing semantics of delay models:\n  1. Transport delay: a gate outputs the input waveform delayed by its propagation delay; any pulse of width $w$ is transmitted unchanged in width (only time-shifted).\n  2. Inertial delay: a gate requires the input to be stable for at least its propagation delay $d$ before an output transition occurs; pulses of width $wd$ are eliminated, while pulses of width $w\\ge d$ propagate with their width preserved (only time-shifted).\n\nAssume all times are expressed in nanoseconds and answer in nanoseconds. Consider the following physically plausible parameters:\n- NOT gate propagation delay $d_{\\text{inv}}=1.0$ nanoseconds.\n- OR gate propagation delay $d_{\\text{or}}=1.5$ nanoseconds.\n- Input $A$ experiences a single low-going glitch (i.e., $A$ momentarily switches from its nominal level to the opposite level and back) with width $w$.\n- Input $B$ is held constant at either logical $0$ or logical $1$ throughout.\n\nYour task is to implement a complete program that, given the test suite below, computes for each case:\n- The output glitch width at $f$ under transport delay.\n- The output glitch width at $f$ under inertial delay using the elimination rule described above.\n- A boolean indicating whether the inertial model masks the hazard relative to transport, defined as $1$ if the inertial output glitch width is strictly less than the transport output glitch width and $0$ otherwise.\n\nUse the following test suite, where each case specifies $w$ and $B$:\n- Case $1$: $w=0.8$ nanoseconds, $B=1$.\n- Case $2$: $w=1.0$ nanoseconds, $B=1$.\n- Case $3$: $w=1.5$ nanoseconds, $B=1$.\n- Case $4$: $w=1.6$ nanoseconds, $B=1$.\n- Case $5$: $w=2.5$ nanoseconds, $B=0$.\n\nScientific realism and logical consistency must be preserved by adhering to the delay model definitions and Boolean gate behavior. The program must not accept input at runtime and must compute the results deterministically for the given parameters.\n\nFinal output format requirement:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a sublist of the form $[w_{\\text{transport}},w_{\\text{inertial}},m]$, with $w_{\\text{transport}}$ and $w_{\\text{inertial}}$ printed as decimal numbers rounded to three digits after the decimal point (in nanoseconds), and $m$ printed as an integer $0$ or $1$.\n- For example, the overall structure must be $[[w_{\\text{t1}},w_{\\text{i1}},m_1],[w_{\\text{t2}},w_{\\text{i2}},m_2],\\dots]$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[[\\dots],[\\dots],\\dots]$).",
            "solution": "We begin from Boolean algebra and standard gate definitions. The function $f(A,B)=\\overline{A}+\\overline{B}$ is an OR of two complements. Using De Morgan's law, $f(A,B)=\\overline{A\\cdot B}$, but the physical implementation under study is two NOT gates feeding an OR gate. Hazards and glitches arise when transient pulses propagate through such networks due to finite gate delays.\n\nWe define two models:\n- Transport delay: an idealized line that shifts the entire waveform by a delay and preserves pulse width. If the input to a gate presents a pulse of width $w$, the gate’s output presents the same pulse width $w$ delayed by the gate’s propagation delay.\n- Inertial delay: a gate with energy storage and finite slew that filters pulses narrower than its delay; if the input changes and remains stable for at least $d$, then the output transitions after $d$, otherwise the output does not respond. Under the simplifying and widely used rule, a pulse of width $w$ is eliminated if $wd$ and is preserved (width unchanged) if $w\\ge d$.\n\nThe circuit has two NOT gates, each with delay $d_{\\text{inv}}$, producing $\\overline{A}$ and $\\overline{B}$, and a final OR gate with delay $d_{\\text{or}}$. Input $B$ is constant, and input $A$ has a single low-going glitch of width $w$. The output glitch width at $f$ depends on the combination of logic and delay:\n\nLogical reduction:\n- If $B=1$, then $\\overline{B}=0$, so $f=\\overline{A}+0=\\overline{A}$. The output equals the delayed version of $\\overline{A}$ passing through the OR gate.\n- If $B=0$, then $\\overline{B}=1$, so $f=\\overline{A}+1=1$. The output is logically fixed at $1$ with no glitch regardless of $A$.\n\nTransport model computation:\n- For $B=1$: the glitch on $A$ of width $w$ becomes a high pulse on $\\overline{A}$ of width $w$ after the NOT gate and then arrives at the OR input; the OR gate transmits that pulse width unchanged in transport. Therefore, the output glitch width is $w$.\n- For $B=0$: $f$ is constant $1$, so the output glitch width is $0$.\n\nInertial model computation with elimination rule applied sequentially:\n- For $B=1$:\n  1. NOT stage: the input pulse of width $w$ is preserved only if $w\\ge d_{\\text{inv}}$, otherwise it is eliminated. The pulse width after the NOT is $w_{\\text{inv}}=\\begin{cases}w  \\text{if } w\\ge d_{\\text{inv}},\\\\ 0  \\text{if } wd_{\\text{inv}}.\\end{cases}$\n  2. OR stage: the input pulse width $w_{\\text{inv}}$ is preserved only if $w_{\\text{inv}}\\ge d_{\\text{or}}$, otherwise eliminated. The output width is $w_{\\text{out}}=\\begin{cases}w_{\\text{inv}}  \\text{if } w_{\\text{inv}}\\ge d_{\\text{or}},\\\\ 0  \\text{if } w_{\\text{inv}}d_{\\text{or}}.\\end{cases}$\n- For $B=0$: the output is logically fixed at $1$, so the output glitch width is $0$.\n\nA hazard is considered masked by the inertial model if the inertial output glitch width is strictly less than the transport output glitch width. Physically, inertial delay models the finite response of real gates, which cannot respond to pulses shorter than their intrinsic delay; such pulses do not produce output transitions and are hence filtered. Transport delay models ideal transmission lines (for combinational logic abstraction) that reproduce waveforms shifted in time, allowing any pulse to propagate.\n\nGiven the parameters $d_{\\text{inv}}=1.0$ and $d_{\\text{or}}=1.5$ (both in nanoseconds), we evaluate the test suite:\n\n- Case $1$: $w=0.8$, $B=1$.\n  - Transport: $w_{\\text{t}}=0.8$.\n  - Inertial: NOT filters ($0.81.0$), so $w_{\\text{i}}=0$. Masked: $1$.\n\n- Case $2$: $w=1.0$, $B=1$.\n  - Transport: $w_{\\text{t}}=1.0$.\n  - Inertial: NOT passes ($1.0\\ge1.0$), OR filters ($1.01.5$), so $w_{\\text{i}}=0$. Masked: $1$.\n\n- Case $3$: $w=1.5$, $B=1$.\n  - Transport: $w_{\\text{t}}=1.5$.\n  - Inertial: NOT passes ($1.5\\ge1.0$), OR passes ($1.5\\ge1.5$), so $w_{\\text{i}}=1.5$. Masked: $0$.\n\n- Case $4$: $w=1.6$, $B=1$.\n  - Transport: $w_{\\text{t}}=1.6$.\n  - Inertial: NOT passes ($1.6\\ge1.0$), OR passes ($1.6\\ge1.5$), so $w_{\\text{i}}=1.6$. Masked: $0$.\n\n- Case $5$: $w=2.5$, $B=0$.\n  - Transport: $f$ is constant $1$, so $w_{\\text{t}}=0$.\n  - Inertial: also $w_{\\text{i}}=0$. Masked: $0$.\n\nThus, for pulses shorter than at least one gate’s delay, the inertial model masks the hazard by eliminating the output glitch, while the transport model preserves it. For pulses equal to or longer than all relevant delays, both models pass the glitch with its width preserved.\n\nThe program implements this logic deterministically and prints the results as a single bracketed list, with sublists $[w_{\\text{transport}},w_{\\text{inertial}},m]$ rounded to three decimals, in nanoseconds.",
            "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n#include stdio.h\n#include stdlib.h\n#include string.h\n#include math.h\n\n// A struct to hold the parameters for a single test case.\ntypedef struct {\n    double glitch_width_ns; // Width of the low-going glitch on A, in nanoseconds.\n    int B_const;            // Constant value of B: 0 or 1.\n} TestCase;\n\nstatic double d_inv_ns = 1.0; // NOT gate propagation delay in nanoseconds.\nstatic double d_or_ns  = 1.5; // OR gate propagation delay in nanoseconds.\n\n// Compute transport delay output glitch width for f = ~A + ~B with given parameters.\n// Transport preserves width; logical reduction applies (if B==0 = f=1 constant).\nstatic double transport_output_width(double w_ns, int B) {\n    if (B == 0) {\n        // ~B = 1 = f = ~A + 1 = 1; output is constant, no glitch.\n        return 0.0;\n    } else {\n        // B == 1: ~B = 0 = f = ~A; transport preserves pulse width through NOT and OR.\n        return w_ns;\n    }\n}\n\n// Compute inertial delay output glitch width using elimination rule sequentially.\n// Each gate passes pulses only if width = gate delay, otherwise filters out.\nstatic double inertial_output_width(double w_ns, int B) {\n    if (B == 0) {\n        // ~B = 1 = output fixed at 1; no glitch can appear.\n        return 0.0;\n    } else {\n        // B == 1: f = ~A at logic level, but subject to inertial filtering in NOT then OR.\n        double w_after_inv = (w_ns = d_inv_ns) ? w_ns : 0.0;\n        double w_after_or  = (w_after_inv = d_or_ns) ? w_after_inv : 0.0;\n        return w_after_or;\n    }\n}\n\nint main(void) {\n    // Define the test cases from the problem statement.\n    TestCase test_cases[] = {\n        { 0.8, 1 },\n        { 1.0, 1 },\n        { 1.5, 1 },\n        { 1.6, 1 },\n        { 2.5, 0 }\n    };\n\n    // Calculate the number of test cases.\n    int num_cases = (int)(sizeof(test_cases) / sizeof(test_cases[0]));\n\n    // Arrays to hold results.\n    double transport[num_cases];\n    double inertial[num_cases];\n    int masked[num_cases]; // 1 if inertial masks relative to transport, else 0.\n\n    // Calculate the result for each test case.\n    for (int i = 0; i  num_cases; ++i) {\n        double w = test_cases[i].glitch_width_ns;\n        int B    = test_cases[i].B_const;\n\n        double wt = transport_output_width(w, B);\n        double wi = inertial_output_width(w, B);\n\n        transport[i] = wt;\n        inertial[i]  = wi;\n        masked[i]    = (wi  wt) ? 1 : 0;\n    }\n\n    // Print the results in the EXACT REQUIRED format before the final return statement\n    // Overall structure: [[wt1,wi1,m1],[wt2,wi2,m2],...]\n    printf(\"[\");\n    for (int i = 0; i  num_cases; ++i) {\n        printf(\"[%.3f,%.3f,%d]\", transport[i], inertial[i], masked[i]);\n        if (i  num_cases - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\\n\");\n\n    return EXIT_SUCCESS;\n}\n```"
        },
        {
            "introduction": "Theory becomes practice when we apply hazard analysis to essential building blocks like the full adder. This hands-on problem challenges you to perform a detailed timing analysis of two different gate-level implementations for the adder's SUM output . By comparing a simple cascaded design with a more balanced multiplexer-based structure, you will gain a practical understanding of how circuit topology influences glitch generation and learn to appreciate design techniques that promote robustness.",
            "id": "3647517",
            "problem": "A one-bit full adder has three Boolean inputs $A$, $B$, and $C_{in}$ and produces the Boolean outputs $S$ (SUM) and $C_{out}$ (CARRY). The SUM function has odd-parity behavior, and the CARRY function is a threshold behavior where the output is asserted when at least two inputs are asserted. Consider two realizations of the SUM output that use common gate-level building blocks. Each gate is modeled as having fixed inertial propagation delay for each input-to-output path, and wires feeding each gate may introduce input-specific path skew.\n\nThe first realization, denoted $\\mathcal{X}$, is the cascaded exclusive-or network\n$$S_{\\mathcal{X}} = (A \\oplus B) \\oplus C_{in},$$\nimplemented with two two-input exclusive-or gates in series. The upstream exclusive-or gate $G_1$ receives $A$ and $B$, and its output $P$ drives the downstream exclusive-or gate $G_2$ together with $C_{in}$. The propagation delays are as follows: the $A \\to P$ path through $G_1$ has delay $\\tau_{A\\to P} = 80\\,\\mathrm{ps}$, the $B \\to P$ path through $G_1$ has delay $\\tau_{B\\to P} = 120\\,\\mathrm{ps}$ (this includes a $40\\,\\mathrm{ps}$ wire skew on the $B$ input to $G_1$), and each input-to-output path of $G_2$ has delay $\\tau_{G_2} = 80\\,\\mathrm{ps}$.\n\nThe second realization, denoted $\\mathcal{M}$, uses a majority gate for the CARRY and a balanced complementary-select multiplexer form for the SUM. Specifically, compute the propagate signal $P = A \\oplus B$ and its complement $P' = A \\odot B$ (exclusive-not-or), both produced by a single complementary exclusive-or/exclusive-not-or cell arranged so that the $A \\to P$ and $B \\to P$ delays equalize to $\\tau_{P} = 100\\,\\mathrm{ps}$ and the $A \\to P'$ and $B \\to P'$ delays equalize to $\\tau_{P'} = 100\\,\\mathrm{ps}$ (no input skew within this cell). Then,\n$$S_{\\mathcal{M}} = P' \\cdot C_{in} \\;+\\; P \\cdot \\overline{C_{in}},$$\nimplemented as a two-input inverter on $C_{in}$ with delay $\\tau_I = 40\\,\\mathrm{ps}$ feeding one data input of a $2{:}1$ multiplexer whose select inputs are $P$ and $P'$ and whose data inputs are $C_{in}$ and $\\overline{C_{in}}$. The multiplexer has input-to-output delay $\\tau_M = 60\\,\\mathrm{ps}$ on both data arms and both select arms. The majority gate for CARRY is\n$$C_{out} = \\mathrm{Maj}(A,B,C_{in}) = A B \\;+\\; A C_{in} \\;+\\; B C_{in},$$\nbut $C_{out}$ is not used within $S_{\\mathcal{M}}$; it is provided here to make explicit that the overall full adder uses the majority form for carry and the complementary-select form for sum.\n\nAssume the initial inputs are $A=0$, $B=0$, $C_{in}=0$, and at global time $t=0$ all three primary inputs toggle simultaneously to $A=1$, $B=1$, $C_{in}=1$ at the input pins feeding the networks (i.e., each primary input transitions at $t=0$). Analyze the output waveforms under the given inertial delay model and determine the presence and width of any unintended transient pulses (glitches) at $S_{\\mathcal{X}}$ and $S_{\\mathcal{M}}$, where a glitch is defined as any temporary excursion to a logic value that is not the correct steady-state value for a nonzero duration caused solely by reconvergent path delay differences.\n\nWhich option is correct?\n\nA. $S_{\\mathcal{X}}$ exhibits two glitches with widths $80\\,\\mathrm{ps}$ and $40\\,\\mathrm{ps}$; $S_{\\mathcal{M}}$ is glitch-free.\n\nB. $S_{\\mathcal{X}}$ exhibits a single glitch of width $40\\,\\mathrm{ps}$; $S_{\\mathcal{M}}$ is glitch-free.\n\nC. $S_{\\mathcal{X}}$ is glitch-free; $S_{\\mathcal{M}}$ exhibits a static hazard pulse of width $60\\,\\mathrm{ps}$.\n\nD. Both $S_{\\mathcal{X}}$ and $S_{\\mathcal{M}}$ are glitch-free under the stated delays.",
            "solution": "The user-provided problem statement has been meticulously validated and is determined to be sound. It is scientifically grounded, well-posed, objective, and internally consistent, allowing for a rigorous analysis.\n\nThe problem requires a timing analysis of two different gate-level implementations of the SUM function of a one-bit full adder, $S = A \\oplus B \\oplus C_{in}$, under a specific input transition. We must determine if glitches (transient hazards) occur at the outputs $S_{\\mathcal{X}}$ and $S_{\\mathcal{M}}$.\n\n**Input Transition and Steady-State Analysis**\n\nThe specified input transition is from $(A, B, C_{in}) = (0, 0, 0)$ to $(A, B, C_{in}) = (1, 1, 1)$ at time $t=0$.\n\n*   The initial output value (for $t  0$) is $S = 0 \\oplus 0 \\oplus 0 = 0$.\n*   The final steady-state output value (for $t \\to \\infty$) is $S = 1 \\oplus 1 \\oplus 1 = (0) \\oplus 1 = 1$.\n\nTherefore, for both circuits, the output is expected to transition from logic $0$ to logic $1$. A glitch is any temporary deviation from this monotonic transition, such as $0 \\to 1 \\to 0 \\to 1$.\n\n**Analysis of Realization $\\mathcal{X}$**\n\nThe first realization is $S_{\\mathcal{X}} = (A \\oplus B) \\oplus C_{in}$. Let $P = A \\oplus B$. The circuit consists of a gate $G_1$ computing $P$, which feeds a gate $G_2$ that computes $S_{\\mathcal{X}} = P \\oplus C_{in}$.\n\n1.  **Analysis of the intermediate signal $P$**:\n    The signal $P = A \\oplus B$ is the output of gate $G_1$. The propagation delays from the inputs to $P$ are given as $\\tau_{A\\to P} = 80\\,\\mathrm{ps}$ and $\\tau_{B\\to P} = 120\\,\\mathrm{ps}$.\n    *   Initial state: $A=0, B=0 \\implies P = 0 \\oplus 0 = 0$.\n    *   Final state: $A=1, B=1 \\implies P = 1 \\oplus 1 = 0$.\n    The signal $P$ should remain stable at $0$. However, the unequal delays (path skew) create a hazard.\n    Let's trace the events at the output of $G_1$:\n    *   For $t  80\\,\\mathrm{ps}$, the effects of the input changes at $t=0$ have not yet propagated. $P$ remains at its initial value of $0$.\n    *   At $t=80\\,\\mathrm{ps}$, the change from $A$ (which is faster) propagates to the output. The gate effectively sees inputs $(A,B)=(1,0)$. It computes $P = 1 \\oplus 0 = 1$. Thus, $P$ transitions $0 \\to 1$.\n    *   At $t=120\\,\\mathrm{ps}$, the change from $B$ (which is slower) propagates to the output. The gate now sees inputs $(A,B)=(1,1)$. It computes $P = 1 \\oplus 1 = 0$. Thus, $P$ transitions $1 \\to 0$.\n    The signal $P(t)$ exhibits a static-0 hazard. It produces a transient pulse: $P$ is $0$, pulses to $1$ during the interval $[80\\,\\mathrm{ps}, 120\\,\\mathrm{ps})$, and returns to $0$. The width of this glitch on signal $P$ is $120\\,\\mathrm{ps} - 80\\,\\mathrm{ps} = 40\\,\\mathrm{ps}$.\n\n2.  **Analysis of the final output $S_{\\mathcal{X}}$**:\n    The signal $S_{\\mathcal{X}} = P \\oplus C_{in}$ is the output of gate $G_2$. Both input paths to $G_2$ have a delay of $\\tau_{G_2} = 80\\,\\mathrm{ps}$.\n    The inputs to $G_2$ are the primary input $C_{in}(t)$ and the internal signal $P(t)$.\n    *   $C_{in}(t)$ transitions $0 \\to 1$ at $t=0$.\n    *   $P(t)$ has the $0 \\to 1 \\to 0$ pulse described above.\n    We can determine the behavior of $S_{\\mathcal{X}}$ by tracking the propagation of events through $G_2$:\n    *   **Event 1**: The change in $C_{in}$ at $t=0$ propagates through $G_2$ and affects $S_{\\mathcal{X}}$ at $t = 0 + \\tau_{G_2} = 80\\,\\mathrm{ps}$.\n    *   **Event 2**: The rising edge of the pulse on $P$ at $t=80\\,\\mathrm{ps}$ propagates through $G_2$ and affects $S_{\\mathcal{X}}$ at $t = 80\\,\\mathrm{ps} + \\tau_{G_2} = 160\\,\\mathrm{ps}$.\n    *   **Event 3**: The falling edge of the pulse on $P$ at $t=120\\,\\mathrm{ps}$ propagates through $G_2$ and affects $S_{\\mathcal{X}}$ at $t = 120\\,\\mathrm{ps} + \\tau_{G_2} = 200\\,\\mathrm{ps}$.\n\n    Now, we construct the waveform of $S_{\\mathcal{X}}(t)$ based on the values of $P$ and $C_{in}$ seen by the logic of $G_2$:\n    *   For $t  80\\,\\mathrm{ps}$: No events have yet affected $S_{\\mathcal{X}}$. It remains at its initial value, $S_{\\mathcal{X}} = P_{initial} \\oplus C_{in, initial} = 0 \\oplus 0 = 0$.\n    *   For $t \\in [80\\,\\mathrm{ps}, 160\\,\\mathrm{ps})$: Event 1 has occurred. The change in $C_{in}$ is now effective at the output. The value of $P$ is still seen as its initial value of $0$. So, $S_{\\mathcal{X}} = P_{initial} \\oplus C_{in, final} = 0 \\oplus 1 = 1$. The output correctly transitions to its final state.\n    *   For $t \\in [160\\,\\mathrm{ps}, 200\\,\\mathrm{ps})$: Event 2 has occurred. The rising edge of the $P$ pulse is now effective. $S_{\\mathcal{X}} = P_{pulse} \\oplus C_{in, final} = 1 \\oplus 1 = 0$. The output deviates from its correct final state, creating a glitch.\n    *   For $t \\ge 200\\,\\mathrm{ps}$: Event 3 has occurred. The falling edge of the $P$ pulse is now effective. $S_{\\mathcal{X}} = P_{final} \\oplus C_{in, final} = 0 \\oplus 1 = 1$. The output returns to its correct final state.\n\n    The output waveform $S_{\\mathcal{X}}(t)$ is $0 \\to 1 \\to 0 \\to 1$. This is a dynamic hazard, which manifests as a single unintended pulse to $0$. The glitch exists for the duration $[160\\,\\mathrm{ps}, 200\\,\\mathrm{ps})$. Its width is $200\\,\\mathrm{ps} - 160\\,\\mathrm{ps} = 40\\,\\mathrm{ps}$.\n\n**Analysis of Realization $\\mathcal{M}$**\n\nThe second realization is $S_{\\mathcal{M}} = P' \\cdot C_{in} + P \\cdot \\overline{C_{in}}$, where $P = A \\oplus B$ and $P' = A \\odot B = \\bar{P}$. This logic is equivalent to $S_{\\mathcal{M}} = P \\oplus C_{in}$.\n\n1.  **Analysis of intermediate signals $P$, $P'$, and $\\overline{C_{in}}$**:\n    *   **Signals $P$ and $P'$**: These are produced by a complementary cell with equalized delays: $\\tau_P = \\tau_{P'} = 100\\,\\mathrm{ps}$ for both $A$ and $B$ inputs.\n        *   For $P = A \\oplus B$: Initial value is $0 \\oplus 0 = 0$. Final value is $1 \\oplus 1 = 0$. Since the delays from $A$ and $B$ are equal, the effects of their transitions effectively arrive simultaneously at the XOR logic. The gate transitions from computing based on $(0,0)$ to computing based on $(1,1)$, both of which yield $P=0$. Therefore, $P$ remains stable at $0$ and is glitch-free.\n        *   For $P' = A \\odot B$: Initial value is $0 \\odot 0 = 1$. Final value is $1 \\odot 1 = 1$. For the same reason, $P'$ remains stable at $1$ and is glitch-free.\n    *   **Signal $\\overline{C_{in}}$**: This is produced by an inverter with delay $\\tau_I = 40\\,\\mathrm{ps}$. Since $C_{in}$ transitions $0 \\to 1$ at $t=0$, $\\overline{C_{in}}$ transitions $1 \\to 0$ at $t = 40\\,\\mathrm{ps}$.\n\n2.  **Analysis of the final output $S_{\\mathcal{M}}$**:\n    The MUX implements $S_{\\mathcal{M}} = P' \\cdot C_{in} + P \\cdot \\overline{C_{in}}$. Let's assume $P$ is the select line.\n    *   Since $P(t)=0$ for all time, the MUX is permanently selecting the data input associated with $P=0$. The MUX expression is of the form $\\bar{P} D_0 + P D_1$. Here $P'=\\bar{P}$ and the data input for the $\\bar{P}$ leg is $C_{in}$.\n    *   Thus, the logic simplifies to $S_{\\mathcal{M}} = (1) \\cdot C_{in} + (0) \\cdot \\overline{C_{in}} = C_{in}$.\n    *   The output $S_{\\mathcal{M}}$ should simply follow the input $C_{in}$, delayed by the propagation through the MUX.\n    *   The relevant path is from the $C_{in}$ data input to the MUX output. The delay for this path is given as $\\tau_M = 60\\,\\mathrm{ps}$.\n    *   $C_{in}$ transitions $0 \\to 1$ at $t=0$. Therefore, $S_{\\mathcal{M}}$ transitions $0 \\to 1$ at $t = 0 + \\tau_M = 60\\,\\mathrm{ps}$.\n    *   The change in the other data input, $\\overline{C_{in}}$, at $t=40\\,\\mathrm{ps}$ is irrelevant because that path is not selected (since $P$ is stable at $0$).\n    The output $S_{\\mathcal{M}}$ transitions cleanly and monotonically from $0$ to $1$ at $t=60\\,\\mathrm{ps}$. The transition is glitch-free.\n\n**Evaluation of Options**\n\n*   **A. $S_{\\mathcal{X}}$ exhibits two glitches with widths $80\\,\\mathrm{ps}$ and $40\\,\\mathrm{ps}$; $S_{\\mathcal{M}}$ is glitch-free.**\n    Our analysis shows $S_{\\mathcal{X}}$ has only a single glitch of width $40\\,\\mathrm{ps}$. Thus, this option is **Incorrect**.\n\n*   **B. $S_{\\mathcal{X}}$ exhibits a single glitch of width $40\\,\\mathrm{ps}$; $S_{\\mathcal{M}}$ is glitch-free.**\n    Our analysis shows that $S_{\\mathcal{X}}$ has one glitch pulse of value $0$ with a duration of $40\\,\\mathrm{ps}$. Our analysis also shows that $S_{\\mathcal{M}}$ is glitch-free. This option perfectly matches our findings. Thus, this option is **Correct**.\n\n*   **C. $S_{\\mathcal{X}}$ is glitch-free; $S_{\\mathcal{M}}$ exhibits a static hazard pulse of width $60\\,\\mathrm{ps}$.**\n    Our analysis shows $S_{\\mathcal{X}}$ has a glitch and $S_{\\mathcal{M}}$ is glitch-free. This option states the opposite. Thus, this option is **Incorrect**.\n\n*   **D. Both $S_{\\mathcal{X}}$ and $S_{\\mathcal{M}}$ are glitch-free under the stated delays.**\n    Our analysis shows $S_{\\mathcal{X}}$ is not glitch-free. Thus, this option is **Incorrect**.",
            "answer": "$$\\boxed{B}$$"
        }
    ]
}