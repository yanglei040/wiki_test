{
    "hands_on_practices": [
        {
            "introduction": "浮点数运算无法做到绝对精确，为了处理这种不精确性，IEEE 754标准定义了明确的舍入模式。本练习将通过一个具体的加法计算，展示四种主要舍入模式（向最近偶数舍入、向零舍入、向正无穷舍入、向负无穷舍入）如何处理一个恰好落在两个可表示数之间的精确结果，这有助于为它们的行为建立一个基本直觉。",
            "id": "3642267",
            "problem": "考虑一个符合电气和电子工程师协会 (IEEE) $754$ 浮点算术标准的系统，该系统使用单精度二进制格式 (binary $32$)。一个规格化的 binary $32$ 浮点数由一个符号位、一个8位的指数场（偏置值为127）和一个23位的小数场表示，小数场构成形式为 $(1.f)$ 的有效数，其中 $f$ 是一个23位的二进制小数串。在区间 $[1,2)$ 内，连续的可表示数之间相差小数部分的最后一位。\n\n设 $x=1.0$ 且 $y=2^{-25}$。假设计算出精确的实数值和 $x+y$，然后根据四种 IEEE $754$ 舍入模式中的每一种，将其舍入一次到最接近的可表示的 binary $32$ 数：向最近舍入，偶数优先（$\\text{RN}$）、向零舍入（$\\text{RZ}$）、向正无穷舍入（$\\text{RU}$）和向负无穷舍入（$\\text{RD}$）。\n\n仅使用二进制规格化有效数的基本定义和四种舍入模式的语义，确定在 $\\text{RN}$、$\\text{RZ}$、$\\text{RU}$ 和 $\\text{RD}$ 模式下，$x+y$ 在 binary $32$ 格式中的舍入结果。将你的最终答案以 $\\text{RN}$、$\\text{RZ}$、$\\text{RU}$、$\\text{RD}$ 的顺序表示为一个行矩阵。不需要数值近似；请提供精确值。",
            "solution": "本题要求确定两个数 $x=1.0$ 和 $y=2^{-25}$ 的和，在 IEEE $754$ 单精度 (binary$32$) 格式下，根据四种指定的舍入模式进行舍入后的结果。\n\n首先，我们必须验证问题陈述的有效性。\n\n### 步骤1：提取已知条件\n- 系统：IEEE $754$ 标准，单精度二进制格式 (binary$32$)。\n- 规格化的 binary$32$ 数表示法：\n  - $1$ 个符号位。\n  - $8$ 位指数场，偏置值为 $127$。\n  - $23$ 位小数场，记为 $f$。\n- 规格化数的有效数形式：$(1.f)_2$。\n- 在区间 $[1,2)$ 内，连续可表示数之间的差值为小数部分的最后一位单位 (ULP)。\n- 给定值：$x=1.0$ 和 $y=2^{-25}$。\n- 任务：计算精确和 $z=x+y$，并根据四种舍入模式中的每一种，将其舍入到最接近的可表示的 binary$32$ 数：\n  - $\\text{RN}$：向最近舍入，偶数优先。\n  - $\\text{RZ}$：向零舍入。\n  - $\\text{RU}$：向 $+\\infty$ 舍入。\n  - $\\text{RD}$：向 $-\\infty$ 舍入。\n- 输出格式：一个包含四个结果的行矩阵，顺序为 $\\text{RN}$、$\\text{RZ}$、$\\text{RU}$、$\\text{RD}$。\n\n### 步骤2：使用提取的已知条件进行验证\n该问题具有科学依据，因为它基于定义明确的 IEEE $754$ 浮点算术标准，这是计算机体系结构和数值分析中的一个基本课题。其语言精确客观。所有必要的信息（数字格式、偏置值、数值、舍入模式）都已提供，使得问题是适定且自洽的。问题中没有矛盾、歧义或不科学的前提。该问题考察了浮点算术的一个核心概念，并且并非微不足道。\n\n### 步骤3：结论与行动\n问题有效。将提供完整解答。\n\n### 解题推导\n\n解题过程是首先计算精确的实数值和，然后确定它与最接近的可表示的 binary$32$ 浮点数之间的关系。\n\n1.  **分析输入及其精确和。**\n    给定值为 $x=1.0$ 和 $y=2^{-25}$。\n    数 $x=1.0$ 是一个在 binary$32$ 格式中可以精确表示的数。其表示法为：\n    - 符号位：$0$（正数）。\n    - 未偏置指数：$0$，因为 $1.0 = (1.0)_2 \\times 2^0$。\n    - 偏置指数：$E = 0 + 127 = 127$。\n    - 小数：$f = 0$，因为有效数是 $(1.0)_2$。\n\n    精确的实数值和是 $z = x+y = 1.0 + 2^{-25}$。\n\n2.  **确定两个相邻的可表示数。**\n    和 $z$ 的值位于区间 $[1,2)$ 内。对于该区间内的任何值 $v$，其规格化的 binary$32$ 表示形式为 $v = (-1)^S \\times (1.f)_2 \\times 2^0$，其中 $f$ 是23位小数。该范围的最后一位单位 (ULP) 是小数部分最低有效位的值，即 $2^{-23}$。\n    在此范围内，连续的可表示数相差 $2^{-23}$。\n\n    精确和是 $z = 1.0 + 2^{-25}$。这个值不能被精确表示，因为其小数部分 $2^{-25}$ 在二进制小数点后需要超过23位的精度。我们需要找到将 $z$ 包夹在中间的两个可表示数。\n\n    设 $N_1$ 为小于或等于 $z$ 的最大可表示数。这个数可以通过将 $z$ 的二进制表示截断到23位小数位来获得。\n    $z = 1.0 + 2^{-25} = (1.\\underbrace{00\\dots0}_{24}1)_2 \\times 2^0$。\n    在第 $23^{rd}$ 位小数后截断，得到的有效数是 $(1.\\underbrace{00\\dots0}_{23})_2$。\n    因此， $N_1 = (1.0)_2 \\times 2^0 = 1.0$。\n\n    设 $N_2$ 为大于或等于 $z$ 的最小可表示数。这是 $N_1$ 之后的下一个可表示数。\n    $N_2 = N_1 + \\text{ULP} = 1.0 + 2^{-23}$。\n\n    我们可以确认 $N_1  z  N_2$：\n    $1.0  1.0 + 2^{-25}  1.0 + 2^{-23}$ 因为 $0  2^{-25}  2^{-23}$。\n\n3.  **应用舍入模式。**\n    舍入的选择取决于具体的模式，对于 $\\text{RN}$ 模式，还取决于 $z$ 相对于区间 $[N_1, N_2]$ 的中点 $M$ 的位置。\n    中点是 $M = \\frac{N_1 + N_2}{2} = \\frac{1.0 + (1.0 + 2^{-23})}{2} = 1.0 + \\frac{2^{-23}}{2} = 1.0 + 2^{-24}$。\n\n    - **向最近舍入，偶数优先 ($\\text{RN}$):**\n      我们将 $z$ 与中点 $M$进行比较。\n      $z = 1.0 + 2^{-25}$\n      $M = 1.0 + 2^{-24}$\n      因为 $2^{-25}  2^{-24}$，所以我们有 $z  M$。这意味着 $z$ 更接近 $N_1$ 而非 $N_2$。不存在相等的情况。规则要求舍入到最接近的可表示数，即 $N_1$。\n      $\\text{RN}$ 的结果：$1.0$。\n\n    - **向零舍入 ($\\text{RZ}$):**\n      此模式将值向0截断。对于像 $z$ 这样的正数，这意味着向下舍入到小于或等于 $z$ 的最大可表示数。这个数是 $N_1$。\n      $\\text{RZ}$ 的结果：$1.0$。\n\n    - **向 $+\\infty$ 舍入 ($\\text{RU}$):**\n      此模式将值向上舍入到大于或等于 $z$ 的最小可表示数。由于 $z$ 不能被精确表示，这个数是 $N_2$。\n      $\\text{RU}$ 的结果：$1.0 + 2^{-23}$。\n\n    - **向 $-\\infty$ 舍入 ($\\text{RD}$):**\n      此模式将值向下舍入到小于或等于 $z$ 的最大可表示数。对于任何数，这都对应于 $N_1$。\n      $\\text{RD}$ 的结果：$1.0$。\n\n4.  **最终结果。**\n    在四种指定的舍入模式下，和 $x+y$ 的舍入结果是：\n    - $\\text{RN}(x+y) = 1.0$\n    - $\\text{RZ}(x+y) = 1.0$\n    - $\\text{RU}(x+y) = 1.0 + 2^{-23}$\n    - $\\text{RD}(x+y) = 1.0$",
            "answer": "$$\\boxed{\\begin{pmatrix} 1.0  1.0  1.0 + 2^{-23}  1.0 \\end{pmatrix}}$$"
        },
        {
            "introduction": "在了解了舍入的发生机制后，让我们来看看它在一系列运算中所带来的后果。这个练习揭示了一个令人惊讶的事实：在浮点运算中，像 $(y+a)-a=y$ 这样的基本代数定律并非总是成立。通过精心选择导致“平局”(tie)情况的数值，我们可以看到特定的舍入模式如何系统性地引入无法抵消的误差。",
            "id": "3642467",
            "problem": "一个处理器实现了电气和电子工程师协会 (IEEE) 754 binary32（单精度）浮点格式。在 binary32 中，一个规格化的浮点数有一个尾数，包含 $23$ 个显式存储的小数位和一个隐含的前导 $1$，从而得到 $p=24$ 位的精度。算术运算产生一个实数结果，该结果会根据当前活动的舍入模式进行舍入，然后存回到 binary32 格式中。可用的舍入模式包括向最近舍入（偶数优先）、向 $+\\infty$ 舍入、向 $-\\infty$ 舍入和向 $0$ 舍入。在给定数量级上的最后一位单位 (ULP) 是该数量级上相邻可表示规格化数之间的间距。\n\n一个程序首先使用向最近舍入（偶数优先）模式计算并存储变量 $y$，作为精确实数 $1$ 的 binary32 表示。之后，由于运行时更改，所有后续浮点运算的舍入模式被设置为向 $+\\infty$ 舍入。在这个改变了的环境中，程序在 binary32 中计算两个连续的操作：\n$$\nt \\leftarrow y + 2^{-24}, \\quad x \\leftarrow t - 2^{-24},\n$$\n其中，每个操作的结果在被下一步使用之前，都根据向 $+\\infty$ 舍入模式以 binary32 精度进行舍入。计算出 $x$ 后，程序立即根据等式 $x==y$ 进行分支。\n\n仅使用 IEEE 754 二进制浮点表示的核心定义、精度 $p$ 以及舍入模式的语义，推导 $x - y$ 的精确值，并以单个封闭形式表达式表示。以 2 的幂的精确形式给出你的最终答案。最终答案不需要舍入。",
            "solution": "本问题将通过根据 IEEE 754 标准对 binary32 格式的浮点运算进行逐步分析来解决，同时考虑指定的舍入模式。\n\n首先，我们确定变量 $y$ 的值。问题陈述 $y$ 是精确实数 $1$ 的 binary32 表示。数字 $1$ 在 binary32 中是精确可表示的。它在二进制科学记数法中的表示是 $1.0 \\times 2^0$。对于 binary32 格式（单精度），尾数的精度为 $p=24$ 位（1 个隐含的前导位和 23 个显式的小数位）。值 $1$ 的表示是尾数为 $(1.00...0)_2$（小数点后有 $23$ 个零），指数为 $0$。由于该值是精确的，因此不需要舍入。因此，$y$ 的值精确为：\n$$y = 1$$\n\n接下来，舍入模式更改为向 $+\\infty$ 舍入。我们分析第一个计算：\n$$t \\leftarrow y + 2^{-24}$$\n这个和的精确实数值是：\n$$R_t = y + 2^{-24} = 1 + 2^{-24}$$\n这个结果必须经过舍入以适应 binary32 格式。在范围 $[1, 2)$ 内的规格化 binary32 数具有 $(1.f_{1}f_{2}...f_{23})_2 \\times 2^0$ 的形式。两个这样的数之间的最小增量由小数部分的最后一位 $f_{23}$ 决定，其对应的值为 $2^{-23}$。这是该范围内数值的最后一位单位 (ULP)。\n让我们确定夹住精确结果 $R_t$ 的两个可表示的 binary32 数。\n数字 $1$ 是可表示的：$N_1 = 1 = (1.00...0)_2 \\times 2^0$。\n下一个更大的可表示数是 $N_2 = 1 + 2^{-23} = (1.00...1)_2 \\times 2^0$，其中最后一位小数位是 $1$。\n\n精确结果 $R_t = 1 + 2^{-24}$ 位于这两个可表示数之间。我们可以确定它相对于这两个数的位置。$N_1$ 和 $N_2$ 之间的中点是：\n$$\\frac{N_1 + N_2}{2} = \\frac{1 + (1 + 2^{-23})}{2} = \\frac{2 + 2^{-23}}{2} = 1 + 2^{-24}$$\n因此，精确结果 $R_t$ 正好是两个连续可表示数的中点。\n\n当前的舍入模式是向 $+\\infty$ 舍入。该模式规定，任何不能精确表示的结果都必须舍入到大于或等于该精确结果的最小可表示数。由于 $R_t = 1 + 2^{-24}$ 是不可表示的，它必须向上舍入到下一个可表示值，即 $N_2$。\n因此，存储在变量 $t$ 中的值是：\n$$t = 1 + 2^{-23}$$\n\n现在，我们分析第二个计算：\n$$x \\leftarrow t - 2^{-24}$$\n舍入模式仍然是向 $+\\infty$ 舍入。我们首先使用我们刚刚确定的 $t$ 的值，来求出差的精确实数值：\n$$R_x = t - 2^{-24} = (1 + 2^{-23}) - 2^{-24}$$\n为了简化这个表达式，我们可以将 $2^{-23}$ 写成 $2 \\times 2^{-24}$：\n$$R_x = 1 + (2 \\times 2^{-24}) - 2^{-24} = 1 + (2-1) \\times 2^{-24} = 1 + 2^{-24}$$\n精确结果 $R_x$ 与上一步的精确结果 $R_t$ 相同。它是可表示数 $1$ 和 $1 + 2^{-23}$ 之间的中点。\n\n我们必须使用向 $+\\infty$ 舍入模式对 $R_x$ 进行舍入。和之前一样，结果向上舍入到大于或等于 $R_x$ 的最小可表示数。\n因此，存储在变量 $x$ 中的值是：\n$$x = 1 + 2^{-23}$$\n\n最后，问题要求差值 $x-y$ 的精确值。使用我们为 $x$ 和 $y$ 推导出的值：\n$$x - y = (1 + 2^{-23}) - 1 = 2^{-23}$$\n这个结果是从 $x$ 和 $y$ 的数学值推导出来的，而不是浮点减法的结果。结果是 2 的一个精确幂。",
            "answer": "$$\\boxed{2^{-23}}$$"
        },
        {
            "introduction": "现在我们来深入探讨浮点运算中一个更微妙的方面：正零 ($+0$) 和负零 ($-0$) 的存在。本练习将探索一个场景，其中两个几乎相等的数相减得到了精确的零。我们将看到不同的舍入模式如何决定这个零的符号，这个特性对程序中的数值比较和分支控制具有重要意义。",
            "id": "3642510",
            "problem": "给定电气和电子工程师协会 (IEEE) 754 标准的 binary32（单精度）浮点格式。考虑两个十进制输入 $x_{\\mathrm{dec}} = 1.0000001$ 和 $y_{\\mathrm{dec}} = 1.0000000$。计算遵循 IEEE 754 模型：每个十进制输入首先在当前有效的舍入模式下转换为 binary32 数据，然后执行精确的实数减法，最后将精确结果在相同的舍入模式下舍入为 binary32。\n\n需要考虑两种舍入模式：\n1. 朝零舍入。\n2. 朝负无穷大舍入。\n\n仅使用 IEEE 754 binary32 的基本属性及其舍入模式，确定在两种模式下计算 $x - y$ 的最终浮点结果，如果结果为零，则包括零的符号。您可以使用以下事实作为起点：\n- 在 binary32 中，区间 $[1,2)$ 内的数字的间距（最后一位的单位 (ULP)）等于 $2^{-23}$。\n- 值 $y_{\\mathrm{dec}} = 1.0000000$ 在 binary32 中是精确可表示的。\n- 朝零舍入将一个实数映射到与其同号且绝对值小于或等于该精确值的可表示值；朝负无穷大舍入将一个实数映射到小于或等于该精确值的最大可表示值。\n\n将您的最终答案表示为一个 $1 \\times 2$ 的行矩阵 $\\big[z_{\\mathrm{tz}} \\;\\; z_{-\\infty}\\big]$，其中 $z_{\\mathrm{tz}}$ 是在朝零舍入模式下计算的结果，而 $z_{-\\infty}$ 是在朝负无穷大舍入模式下计算的结果。如果出现零，请用 $-0$ 表示负零，用 $0$ 表示正零来指明其符号。不需要进行小数位舍入。",
            "solution": "首先验证问题，以确保其科学基础扎实、定义明确且客观。\n\n### 步骤 1：提取给定条件\n- **浮点格式：** 电气和电子工程师协会 (IEEE) 754 `binary32` (单精度)。\n- **十进制输入：** $x_{\\mathrm{dec}} = 1.0000001$ 和 $y_{\\mathrm{dec}} = 1.0000000$。\n- **计算模型：**\n    1. 每个十进制输入在当前有效的舍入模式下转换为 `binary32` 数据。\n    2. 对转换后的数执行精确的实数减法。\n    3. 精确结果在相同的舍入模式下舍入为 `binary32`。\n- **需要考虑的舍入模式：**\n    1. 朝零舍入 ($z_{\\mathrm{tz}}$)。\n    2. 朝负无穷大舍入 ($z_{-\\infty}$)。\n- **已知事实：**\n    1. 在 `binary32` 中，对于区间 $[1, 2)$ 内的数，其间距（最后一位的单位，ULP）为 $2^{-23}$。\n    2. 值 $y_{\\mathrm{dec}} = 1.0000000$ 在 `binary32` 中是精确可表示的。\n    3. 提供了两种舍入模式的定义。\n- **要求输出：** 一个 $1 \\times 2$ 的行矩阵 $\\begin{pmatrix} z_{\\mathrm{tz}}  z_{-\\infty} \\end{pmatrix}$，如果适用，需指明零的符号。\n\n### 步骤 2：使用提取的给定条件进行验证\n该问题定义明确且科学上合理。它基于浮点运算的 IEEE 754 标准，这是计算机体系结构和数值计算中的一个基本主题。所有术语都得到了精确定义，并提供了所需的数据。前提条件在事实上是正确的：`binary32` 中 $[1, 2)$ 区间内数字的 ULP 确实是 $2^{-23}$，且 $1.0$ 是一个精确可表示的值。该问题是可形式化且可解的。因此，该问题被认为是有效的。\n\n### 步骤 3：求解\n对于给定的十进制输入 $x_{\\mathrm{dec}}$ 和 $y_{\\mathrm{dec}}$ 以及舍入模式 $\\text{round}_{\\text{mode}}$，结果 $z$ 的总体计算过程如下：\n$$z = \\text{round}_{\\text{mode}} \\left( \\text{round}_{\\text{mode}}(x_{\\mathrm{dec}}) - \\text{round}_{\\text{mode}}(y_{\\mathrm{dec}}) \\right)$$\n\n我们首先分析输入在 `binary32` 格式中的表示。\n\n输入 $y_{\\mathrm{dec}} = 1.0$ 被说明是精确可表示的。因此，在任何舍入模式下将其转换为 `binary32` 都会得到精确值 $1.0$。我们将此浮点数表示为 $y_{fp}$。\n$$y_{fp} = \\text{round}_{\\text{mode}}(y_{\\mathrm{dec}}) = 1.0 \\quad (\\text{for any mode})$$\n\n现在，我们来分析输入 $x_{\\mathrm{dec}} = 1.0000001$。我们需要确定它相对于相邻的可表示 `binary32` 数字的位置。问题指出，对于范围在 $[1, 2)$ 内的数字，连续可表示数字之间的间隔（ULP）是 $2^{-23}$。数字 $1.0$ 是可表示的。比 $1.0$ 大的下一个可表示数字是 $1.0 + 2^{-23}$。\n我们来计算 ULP 的值：\n$$2^{-23} = \\frac{1}{2^{23}} = \\frac{1}{8388608} = 0.00000011920928955...$$\n我们将 $x_{\\mathrm{dec}}$ 与这个下一个可表示数的值进行比较：\n$$x_{\\mathrm{dec}} = 1.0000001$$\n$$1.0 + 2^{-23} \\approx 1.0000001192$$\n通过这个比较，很明显 $x_{\\mathrm{dec}}$ 严格位于两个连续的 `binary32` 数之间：\n$$1.0  x_{\\mathrm{dec}}  1.0 + 2^{-23}$$\n\n我们现在继续计算每种指定舍入模式下的最终结果。\n\n**1. 朝零舍入 (tz)**\n\n首先，我们使用此模式将输入转换为 `binary32`。我们将 $x_{\\mathrm{dec}}$ 的转换表示为 $x_{fp, \\mathrm{tz}}$。\n- 对于 $y_{\\mathrm{dec}}$，$y_{fp, \\mathrm{tz}} = 1.0$。\n- 对于 $x_{\\mathrm{dec}}$，“朝零舍入”模式将一个实数映射到与其同号且绝对值小于或等于该实数绝对值的可表示值。对于正数，这等同于截断。由于 $1.0  x_{\\mathrm{dec}}  1.0 + 2^{-23}$，小于或等于 $x_{\\mathrm{dec}}$ 的最大可表示数是 $1.0$。\n$$x_{fp, \\mathrm{tz}} = \\text{round}_{\\mathrm{tz}}(1.0000001) = 1.0$$\n接下来，我们对转换后的浮点数执行精确减法：\n$$z_{exact, \\mathrm{tz}} = x_{fp, \\mathrm{tz}} - y_{fp, \\mathrm{tz}} = 1.0 - 1.0 = 0.0$$\n最后，我们将精确结果 $z_{exact, \\mathrm{tz}}$ 舍入为 `binary32`。值 $0.0$ 是精确可表示的，因此舍入操作不会改变其值。唯一剩下的考虑是符号。根据 IEEE 754 标准（第 6.3 节），当两个同号操作数的差产生精确的零时，除了“朝负无穷大舍入”模式外，在所有舍入模式中结果的符号都是正的。由于当前模式是“朝零舍入”，结果是正零，表示为 $0$。\n$$z_{\\mathrm{tz}} = \\text{round}_{\\mathrm{tz}}(0.0) = +0$$\n\n**2. 朝负无穷大舍入 ($-\\infty$)**\n\n首先，我们使用此模式将输入转换为 `binary32`。我们将 $x_{\\mathrm{dec}}$ 的转换表示为 $x_{fp, -\\infty}$。\n- 对于 $y_{\\mathrm{dec}}$，$y_{fp, -\\infty} = 1.0$。\n- 对于 $x_{\\mathrm{dec}}$，“朝负无穷大舍入”模式将一个实数映射到小于或等于它的最大可表示值。由于 $1.0  x_{\\mathrm{dec}}  1.0 + 2^{-23}$，小于或等于 $x_{\\mathrm{dec}}$ 的最大可表示数是 $1.0$。\n$$x_{fp, -\\infty} = \\text{round}_{-\\infty}(1.0000001) = 1.0$$\n接下来，我们执行精确减法：\n$$z_{exact, -\\infty} = x_{fp, -\\infty} - y_{fp, -\\infty} = 1.0 - 1.0 = 0.0$$\n最后，我们将精确结果 $z_{exact, -\\infty}$ 舍入为 `binary32`。值 $0.0$ 是精确可表示的。我们使用 IEEE 754 规则来确定符号。对于同号操作数的差为精确零的情况，当且仅当舍入模式为“朝负无穷大舍入”时，符号为负。此条件得到满足。因此，结果是负零，表示为 $-0$。\n$$z_{-\\infty} = \\text{round}_{-\\infty}(0.0) = -0$$\n\n将两种舍入模式的结果组合成所需的矩阵格式，得到 $\\begin{pmatrix} z_{\\mathrm{tz}}  z_{-\\infty} \\end{pmatrix}$。",
            "answer": "$$ \\boxed{ \\begin{pmatrix} 0  -0 \\end{pmatrix} } $$"
        }
    ]
}