{
    "hands_on_practices": [
        {
            "introduction": "A given pattern of bits has no inherent meaning until we apply a representational scheme to interpret it. This exercise solidifies your understanding of how to decode bit patterns by comparing the sign-magnitude and two's complement systems. By analyzing the specific and often ambiguous pattern $100...0$, you will uncover fundamental differences in how these schemes handle the number zero and define their range of values .",
            "id": "3676847",
            "problem": "Let $n \\geq 3$ be a positive integer denoting the word size. Consider the $n$-bit pattern $p$ whose most significant bit (MSB) is $1$ and whose remaining $n-1$ bits are all $0$, that is, $p = 1\\underbrace{00\\cdots0}_{n-1\\ \\text{zeros}}$. Under sign-magnitude semantics, adopt the convention that a “valid negative” requires the sign bit to be $1$ and the magnitude field to be a strictly positive binary integer; the code word with sign bit $1$ and all-zero magnitude is the so-called “negative zero,” which numerically equals $0$ but is not considered a valid negative under this convention. First, determine whether $p$ is a valid negative in sign-magnitude and identify the integer it denotes in sign-magnitude. Next, interpret the same fixed bit pattern $p$ under two’s complement semantics (Two’s Complement, abbreviated as TC, interpreted in the standard way used in computer arithmetic), without altering the bits. Compute the signed integer value obtained by this two’s complement reinterpretation as a function of $n$. Report only the closed-form expression for this value. No rounding is required, and no units are involved.",
            "solution": "The problem is deemed valid as it is scientifically grounded in the principles of computer arithmetic, well-posed with unambiguous definitions, and objective in its language. It presents a standard exercise in comparing signed number representations.\n\nThe problem defines an $n$-bit pattern, where $n \\geq 3$, denoted by $p$. This pattern has a most significant bit (MSB) of $1$ and all other $n-1$ bits are $0$. Symbolically, this can be written as $p = 1\\underbrace{00\\cdots0}_{n-1}$. We are asked to analyze this pattern under two different signed integer semantics: sign-magnitude and two's complement.\n\nFirst, we analyze the pattern $p$ under sign-magnitude semantics. In this representation, the MSB serves as the sign bit, where $1$ denotes a negative number and $0$ denotes a positive number. The remaining $n-1$ bits represent the magnitude of the number.\nFor the pattern $p = 100\\cdots0$:\n- The sign bit is $b_{n-1} = 1$, which indicates the number is negative.\n- The magnitude is given by the remaining $n-1$ bits, which are all $0$. The integer value of an all-zero binary string is $0$.\nTherefore, the number represented by $p$ in sign-magnitude is $-(0)$, which is equal to $0$. This specific representation, $100\\cdots0$, is commonly referred to as \"negative zero.\"\n\nThe problem imposes a specific convention for a \"valid negative\": the sign bit must be $1$ and the magnitude field must represent a strictly positive binary integer. In our case, the magnitude is $0$, which is not strictly positive. Consequently, under this given convention, the pattern $p$ represents the integer $0$ but does not qualify as a \"valid negative.\"\n\nNext, we interpret the same $n$-bit pattern $p = 100\\cdots0$ under two's complement (TC) semantics. The value of an $n$-bit binary number $b_{n-1}b_{n-2}\\cdots b_1b_0$ in the two's complement system is calculated using the formula:\n$$V = -b_{n-1} \\cdot 2^{n-1} + \\sum_{i=0}^{n-2} b_i \\cdot 2^i$$\nFor the pattern $p$, the bits are:\n- $b_{n-1} = 1$ (the MSB)\n- $b_i = 0$ for all $i$ from $0$ to $n-2$.\n\nSubstituting these bit values into the formula:\nThe summation term becomes:\n$$\\sum_{i=0}^{n-2} b_i \\cdot 2^i = \\sum_{i=0}^{n-2} 0 \\cdot 2^i = 0$$\nThe term for the MSB is:\n$$-b_{n-1} \\cdot 2^{n-1} = -1 \\cdot 2^{n-1} = -2^{n-1}$$\nCombining these results, the total value $V$ of the pattern $p$ in two's complement is:\n$$V = -2^{n-1} + 0 = -2^{n-1}$$\nThis value, $-2^{n-1}$, represents the most negative integer that can be expressed with $n$ bits in the two's complement system. The problem asks for the closed-form expression for this value as a function of $n$.\n\nThe final expression for the value of the bit pattern $p$ when interpreted under two's complement semantics is $-2^{n-1}$.",
            "answer": "$$\\boxed{-2^{n-1}}$$"
        },
        {
            "introduction": "Computer arithmetic operates within the finite constraints of a register, which is elegantly modeled by modular arithmetic. This practice explores the consequences of two's complement arithmetic, which behaves like arithmetic in the ring of integers modulo $2^n$ ($\\mathbb{Z}_{2^n}$). By calculating the results of adding to the maximum positive integer and subtracting from the minimum negative integer, you will develop a concrete understanding of the \"wrap-around\" behavior that defines arithmetic overflow .",
            "id": "3676829",
            "problem": "An Arithmetic Logic Unit (ALU) performs addition and subtraction on $n$-bit words using two’s complement representation, with wrap-around semantics identical to arithmetic in the ring of integers modulo $2^{n}$, denoted by $\\mathbb{Z}_{2^{n}}$. For a fixed integer $n \\ge 2$, define the two maps between bit patterns (viewed as elements of $\\{0,1,\\ldots,2^{n}-1\\} \\subset \\mathbb{Z}_{2^{n}}$) and signed integers:\n- The encoding map $E:\\mathbb{Z}\\to\\{0,1,\\ldots,2^{n}-1\\}$ given by $E(y)$ equals the residue class of $y$ modulo $2^{n}$, interpreted as its canonical representative in $\\{0,1,\\ldots,2^{n}-1\\}$.\n- The decoding map $D:\\{0,1,\\ldots,2^{n}-1\\}\\to\\mathbb{Z}$ given by\n$$\nD(x)=\n\\begin{cases}\nx,  0 \\le x \\le 2^{n-1}-1,\\\\\nx-2^{n},  2^{n-1} \\le x \\le 2^{n}-1.\n\\end{cases}\n$$\nThe ALU’s operational semantics are equivalent to performing addition or subtraction on encoded values in $\\mathbb{Z}_{2^{n}}$, then decoding the result via $D(\\cdot)$.\n\nStarting only from these definitions and the ring properties of $\\mathbb{Z}_{2^{n}}$, consider the following two boundary operations:\n1. Compute $A$ by taking the largest representable nonnegative signed integer $2^{n-1}-1$, adding $1$ in $\\mathbb{Z}_{2^{n}}$, and decoding: $A := D\\!\\left(\\left(2^{n-1}-1 + 1\\right) \\bmod 2^{n}\\right)$.\n2. Compute $B$ by taking the most negative representable signed integer $-2^{n-1}$, subtracting $1$ using the ALU’s subtraction (which is subtraction in $\\mathbb{Z}_{2^{n}}$ on the encoded value), and decoding: $B := D\\!\\left(\\left(E(-2^{n-1}) - 1\\right) \\bmod 2^{n}\\right)$.\n\nDerive, from first principles, the closed-form value of\n$$\nS(n) = A + B,\n$$\nas a real integer. Provide your final answer as a single simplified number or closed-form expression. No rounding is required and no units should be included in your final answer.",
            "solution": "The problem is well-posed and grounded in the standard principles of signed integer arithmetic in computer systems. We are asked to derive the value of $S(n) = A + B$ for an integer $n \\ge 2$, where $A$ and $B$ are the results of specific boundary-case arithmetic operations in an $n$-bit two's complement system. We shall proceed by calculating $A$ and $B$ separately, based on the provided definitions.\n\nFirst, we compute the value of $A$. The definition is given as:\n$$\nA := D\\!\\left(\\left(2^{n-1}-1 + 1\\right) \\bmod 2^{n}\\right)\n$$\nThis expression models the result of taking the largest representable positive integer, $2^{n-1}-1$, and adding $1$ to it within the arithmetic of $\\mathbb{Z}_{2^{n}}$. We simplify the expression inside the parentheses:\n$$\n(2^{n-1}-1 + 1) \\bmod 2^{n} = 2^{n-1} \\bmod 2^{n}\n$$\nSince $n \\ge 2$, we have $2^{n-1} \\ge 2^{2-1} = 2$. It is also true that $2^{n-1}  2^n$. Thus, the value $2^{n-1}$ is within the interval $[0, 2^n-1]$, which means its value modulo $2^n$ is itself.\n$$\n2^{n-1} \\bmod 2^{n} = 2^{n-1}\n$$\nSubstituting this back, we get:\n$$\nA = D(2^{n-1})\n$$\nWe now apply the decoding map $D(x)$ to the argument $x = 2^{n-1}$. The definition of $D(x)$ is:\n$$\nD(x)=\n\\begin{cases}\nx,  0 \\le x \\le 2^{n-1}-1,\\\\\nx-2^{n},  2^{n-1} \\le x \\le 2^{n}-1.\n\\end{cases}\n$$\nThe argument $x = 2^{n-1}$ satisfies the condition for the second case, $2^{n-1} \\le x \\le 2^{n}-1$. Therefore, we apply the rule $D(x) = x - 2^n$:\n$$\nA = D(2^{n-1}) = 2^{n-1} - 2^{n} = 2^{n-1} - 2 \\cdot 2^{n-1} = -2^{n-1}\n$$\nThis result, $A = -2^{n-1}$, represents the arithmetic overflow where adding $1$ to the maximum positive number yields the most negative number.\n\nNext, we compute the value of $B$. The definition is given as:\n$$\nB := D\\!\\left(\\left(E(-2^{n-1}) - 1\\right) \\bmod 2^{n}\\right)\n$$\nThis expression models taking the most negative integer, $-2^{n-1}$, and subtracting $1$ from it. First, we must evaluate the encoded value $E(-2^{n-1})$. The encoding map $E(y)$ gives the canonical representative of $y$ in $\\{0, 1, \\ldots, 2^n - 1\\}$.\n$$\nE(-2^{n-1}) = (-2^{n-1}) \\bmod 2^{n} = -2^{n-1} + 2^{n} = 2^{n-1}\n$$\nNow we substitute this into the expression for $B$:\n$$\nB = D\\!\\left(\\left(2^{n-1} - 1\\right) \\bmod 2^{n}\\right)\n$$\nFor $n \\ge 2$, we have $2^{n-1}-1 \\ge 2^{1}-1 = 1$. Also, $2^{n-1}-1  2^n$. Thus, the value $2^{n-1}-1$ is in the interval $[0, 2^n-1]$, and its value modulo $2^n$ is itself.\n$$\n(2^{n-1} - 1) \\bmod 2^{n} = 2^{n-1} - 1\n$$\nSo, the expression for $B$ simplifies to:\n$$\nB = D(2^{n-1} - 1)\n$$\nWe apply the decoding map $D(x)$ to the argument $x = 2^{n-1} - 1$. This argument satisfies the condition for the first case, $0 \\le x \\le 2^{n-1}-1$. Therefore, we apply the rule $D(x) = x$:\n$$\nB = D(2^{n-1} - 1) = 2^{n-1} - 1\n$$\nThis result, $B = 2^{n-1} - 1$, represents the arithmetic underflow where subtracting $1$ from the minimum negative number yields the largest positive number.\n\nFinally, we compute the sum $S(n) = A + B$.\n$$\nS(n) = A + B = (-2^{n-1}) + (2^{n-1} - 1)\n$$\nSimplifying the expression, we obtain:\n$$\nS(n) = -2^{n-1} + 2^{n-1} - 1 = -1\n$$\nThe value of $S(n)$ is a constant, $-1$, for all integers $n \\ge 2$.",
            "answer": "$$\n\\boxed{-1}\n$$"
        },
        {
            "introduction": "The most elegant and efficient code often arises from a deep understanding of the underlying number system. This hands-on task challenges you to move beyond simple conditionals and derive a \"branchless\" algorithm for the absolute value function. By using only bitwise operations and arithmetic, you will not only create a clever piece of code but also directly confront the critical overflow behavior that occurs for the most negative number in a two's complement system .",
            "id": "3676833",
            "problem": "You are given a signed integer $x$ represented in two's complement on $n$ bits, where $n \\geq 2$. In an $n$-bit two's complement system, the representable set is all integers in the range $[-2^{n-1}, 2^{n-1}-1]$. All arithmetic and bitwise operations are taken modulo $2^n$ with the understanding that the signed value of a bit pattern $u \\in [0, 2^n-1]$ is its two's complement interpretation: if the most significant bit is $0$, the value is $u$, otherwise it is $u - 2^n$. The fundamental facts you may use are: the signed negation in two's complement is equivalent to bitwise complement followed by adding one modulo $2^n$, that is, $-x \\equiv \\tilde{x} + 1 \\pmod{2^n}$, and the most significant bit of $x$ is its sign bit.\n\nTask 1: Starting from these fundamental definitions, derive a branchless expression for the absolute value $\\lvert x \\rvert$ using only bitwise exclusive-or $\\oplus$, subtraction, and a mask derived solely from the sign of $x$. The mask must be obtained from the sign information derivable by an arithmetic right shift by $n-1$ positions (i.e., shifting in copies of the sign bit), but you must not use conditional branches in your derivation. Prove why your expression yields $\\lvert x \\rvert$ for all $x$ in the representable range except possibly at a boundary value. Identify that boundary value precisely as a function of $n$ and explain, using the two's complement modular arithmetic model, what happens in that case, and why the behavior is unavoidable.\n\nTask 2: Implement a complete, runnable program that, for each test case $(n,x)$, computes:\n- The branchless absolute value result as a signed integer within the $n$-bit two's complement interpretation.\n- An overflow indicator that is $1$ if the mathematical absolute value $\\lvert x \\rvert$ is not representable on $n$ bits (i.e., if $x = -2^{n-1}$), and $0$ otherwise.\n\nYour implementation must simulate $n$-bit two's complement arithmetic explicitly and must not rely on the behavior of the C language right shift on negative values. All internal arithmetic for the $n$-bit operations must be performed modulo $2^n$, and the conversion back to a signed result must follow the two's complement interpretation.\n\nTest Suite: Your program must compute results for the following $(n,x)$ pairs, where each $x$ is guaranteed to be within the representable range $[-2^{n-1}, 2^{n-1}-1]$:\n- $(8, 0)$\n- $(8, 127)$\n- $(8, -128)$\n- $(8, -1)$\n- $(8, -42)$\n- $(16, -32768)$\n- $(16, 32767)$\n- $(16, -12345)$\n- $(2, -2)$\n- $(2, 1)$\n- $(12, -2048)$\n- $(12, -2047)$\n- $(32, -2147483648)$\n- $(32, 2147483647)$\n\nFinal Output Format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each element of the list corresponds to one test case, in the same order as listed above, and must itself be a two-item list of the form $[a,b]$ where $a$ is the computed branchless absolute value as a signed integer and $b$ is the overflow indicator ($0$ or $1$). For example, the overall output should look like $[[a_1,b_1],[a_2,b_2],\\dots,[a_{14},b_{14}]]$. No other text should be printed.",
            "solution": "The problem requires the derivation of a branchless expression for the absolute value of a signed integer in an $n$-bit two's complement system, followed by an implementation that simulates this logic.\n\n### Part 1: Derivation and Analysis\n\nWe are given a signed integer $x$ represented in an $n$-bit two's complement system, where $n \\geq 2$. The representable range of integers is $[-2^{n-1}, 2^{n-1}-1]$. All arithmetic is performed modulo $2^n$. The mathematical definition of the absolute value is conditional:\n$$\n\\lvert x \\rvert = \n\\begin{cases} \nx  \\text{if } x \\geq 0 \\\\\n-x  \\text{if } x  0 \n\\end{cases}\n$$\nOur goal is to find a single, branchless expression that implements this logic using only the bitwise exclusive-or operator ($\\oplus$), subtraction, and a special mask.\n\n**1. Deriving the Mask**\n\nThe expression must distinguish between non-negative and negative numbers. This information is encoded in the sign bit of $x$, which is its most significant bit (MSB) at position $n-1$. The sign bit is $0$ if $x \\geq 0$ and $1$ if $x  0$.\n\nThe problem specifies that a mask, let us call it $m$, must be derived from an arithmetic right shift of $x$ by $n-1$ positions. Let's denote this operation as $x \\gg_{arith} (n-1)$. An arithmetic right shift propagates the sign bit into the vacated positions.\n\n-   If $x \\geq 0$, its sign bit is $0$. Shifting this right by $n-1$ positions fills the entire $n$-bit word with zeros. The resulting bit pattern is $00...0_2$, which represents the integer $0$.\n-   If $x  0$, its sign bit is $1$. Shifting this right by $n-1$ positions fills the entire $n$-bit word with ones. The resulting bit pattern is $11...1_2$, which in two's complement representation is the integer $-1$.\n\nThus, the mask $m$ is defined as:\n$$ m = x \\gg_{arith} (n-1) = \n\\begin{cases} \n0  \\text{if } x \\geq 0 \\\\\n-1  \\text{if } x  0 \n\\end{cases}\n$$\n\n**2. Constructing the Branchless Expression**\n\nWe seek an expression $f(x, m)$ that equals $x$ when $m=0$ and $-x$ when $m=-1$. Let's use the provided identity for two's complement negation: $-x \\equiv \\tilde{x} + 1 \\pmod{2^n}$, where $\\tilde{x}$ is the bitwise complement of $x$.\n\nA key property of the bitwise XOR operation ($\\oplus$) is that for any bit pattern $b$, $b \\oplus 0 = b$ and $b \\oplus 1 = \\neg b$ (the inverted bit). When we XOR an entire word $x$ with a word of all ones (which represents $-1$), the result is the bitwise complement of $x$:\n$$ x \\oplus (-1) = \\tilde{x} $$\n\nLet's examine the expression $x \\oplus m$:\n-   If $x \\geq 0$, then $m=0$. The expression evaluates to $x \\oplus 0 = x$.\n-   If $x  0$, then $m=-1$. The expression evaluates to $x \\oplus (-1) = \\tilde{x}$.\n\nThis is a promising intermediate step. We have generated $x$ for the non-negative case and $\\tilde{x}$ for the negative case. To obtain the final absolute value, we must adjust this intermediate result.\n-   When $x \\geq 0$, we have $x$ and we need $x$. No adjustment is needed.\n-   When $x  0$, we have $\\tilde{x}$ and we need $-x = \\tilde{x} + 1$. We need to add $1$.\n\nWe need to find a single operation that adds $0$ in the first case and adds $1$ in the second. Observe that this is precisely the operation of adding $-m$:\n-   If $x \\geq 0$, $m=0$, so we add $-m = 0$.\n-   If $x  0$, $m=-1$, so we add $-m = 1$.\n\nIn two's complement arithmetic, adding $-m$ is equivalent to subtracting $m$. Therefore, the complete branchless expression for the computed absolute value, let's call it $v$, is:\n$$ v = (x \\oplus m) - m $$\n\n**3. Proof of Correctness**\n\nLet's verify this expression for all values of $x$ in the representable range.\n\n**Case 1: $x \\geq 0$** ($x \\in [0, 2^{n-1}-1]$)\nIn this case, the mask $m=0$. The expression becomes:\n$$ v = (x \\oplus 0) - 0 = x $$\nSince $x \\geq 0$, $\\lvert x \\rvert = x$, so the expression is correct.\n\n**Case 2: $x  0$** ($x \\in [-2^{n-1}, -1]$)\nIn this case, the mask $m=-1$. The expression becomes:\n$$ v = (x \\oplus (-1)) - (-1) = (x \\oplus (-1)) + 1 $$\nAs established, $x \\oplus (-1)$ is the bitwise complement $\\tilde{x}$. So the expression evaluates to $\\tilde{x} + 1$. By the definition of two's complement negation, this is congruent to $-x$ modulo $2^n$.\n$$ v \\equiv -x \\pmod{2^n} $$\nFor any $x  0$, its mathematical absolute value is $\\lvert x \\rvert = -x$. The expression gives the correct value, provided $-x$ is representable.\n\n**4. The Boundary Case and Unavoidable Overflow**\n\nThe representable range for an $n$-bit two's complement system is $[-2^{n-1}, 2^{n-1}-1]$. Let's examine if $-x$ is always representable for $x  0$.\n\n-   If $x \\in [-2^{n-1}+1, -1]$, then $-x \\in [1, 2^{n-1}-1]$. This range is entirely within the representable positive part of the number system. For these values, our expression computes the correct mathematical absolute value.\n\n-   The boundary value is the most negative number, $x_{min} = -2^{n-1}$. Its mathematical absolute value is $\\lvert -2^{n-1} \\rvert = 2^{n-1}$. This value, $2^{n-1}$, is outside the representable range, as the maximum positive representable number is $2^{n-1}-1$. Therefore, it is impossible for any operation within the $n$-bit system to produce the true mathematical absolute value of $x_{min}$.\n\nLet's see what our expression computes for $x = -2^{n-1}$. The bit pattern for $x$ is $100...0_2$ (which has the unsigned value $2^{n-1}$).\nSince $x  0$, the mask is $m=-1$. The expression computes $v \\equiv -x \\pmod{2^n}$.\nTo compute the negation of $x = -2^{n-1}$ (bit pattern $u_x = 2^{n-1}$), we find its complement and add one:\n-   Bitwise complement: $\\tilde{u_x} = \\text{NOT}(100...0_2) = 011...1_2$. This pattern has the value $2^{n-1}-1$.\n-   Add one: $(\\tilde{u_x} + 1) = (2^{n-1}-1) + 1 = 2^{n-1}$.\nThe resulting bit pattern is $2^{n-1}$, which is $100...0_2$. This is the exact same bit pattern as the original number $x = -2^{n-1}$. When interpreted as a signed integer, this pattern represents the value $-2^{n-1}$.\n\nTherefore, for the boundary value $x = -2^{n-1}$, our expression computes:\n$$ v = ((-2^{n-1}) \\oplus (-1)) - (-1) = -2^{n-1} $$\nThis behavior is an inescapable consequence of the two's complement representation. The negation of $-2^{n-1}$ overflows and wraps around to itself within the modulo $2^n$ arithmetic.\n\nThe overflow indicator required by the problem should be $1$ if and only if $x=-2^{n-1}$. This corresponds exactly to the case where the computed absolute value $v$ is a negative number. For any other input $x$, the computed value $v = \\lvert x \\rvert$ is non-negative. Thus, the overflow condition can be detected by checking if the sign bit of the result $v$ is $1$.",
            "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n#include stdio.h\n#include stdlib.h\n\n// A struct to hold the parameters for a single test case.\ntypedef struct {\n    int n;\n    long long x;\n} TestCase;\n\n// A struct to hold the result of one computation.\ntypedef struct {\n    long long abs_val;\n    int overflow;\n} Result;\n\n/**\n * @brief Simulates the branchless computation of the absolute value for an n-bit two's complement integer.\n *\n * @param n The number of bits in the two's complement representation (2 = n = 64).\n * @param x_val The signed integer value to process.\n * @return A Result struct containing the computed absolute value and an overflow flag.\n */\nResult simulate_abs(int n, long long x_val) {\n    // A mask to truncate all intermediate and final results to n bits.\n    // Handles the edge case for n=64, where 1ULL  64 is undefined behavior.\n    unsigned long long n_bit_mask = (n == 64) ? ~0ULL : (1ULL  n) - 1;\n\n    // Convert the signed input value x_val to its n-bit two's complement bit pattern.\n    // Unsigned arithmetic in C provides the correct bit pattern for negative numbers.\n    unsigned long long u_x = x_val  n_bit_mask;\n\n    // Derive the mask 'm' based on the sign bit of x.\n    // The mask is all 1s (-1) if x is negative, and all 0s (0) if x is non-negative.\n    // This is a branchless C equivalent of 'm = x _{arith} (n-1)'.\n    unsigned long long sign_bit = (u_x  (n - 1))  1;\n    unsigned long long u_m = (-(unsigned long long)sign_bit)  n_bit_mask;\n\n    // Compute the absolute value using the derived branchless expression: (x ^ m) - m.\n    // Subtraction on unsigned types is well-defined to be modular, matching the problem's constraints.\n    unsigned long long u_abs = ((u_x ^ u_m) - u_m)  n_bit_mask;\n\n    // Convert the n-bit unsigned result back to a signed long long value.\n    long long signed_result;\n    if ((u_abs  (n - 1))  1) {\n        // If the MSB is 1, the number is negative. We must sign-extend it to 64 bits.\n        // OR-ing with the inverted n-bit mask sets all higher bits to 1.\n        signed_result = u_abs | ~n_bit_mask;\n    } else {\n        // If the MSB is 0, the number is positive, and its value is just the bit pattern itself.\n        signed_result = u_abs;\n    }\n    \n    // As derived, overflow occurs if and only if the input is the most negative number,\n    // which is the only case where the computed absolute value is negative.\n    int overflow_flag = (signed_result  0);\n    \n    Result res;\n    res.abs_val = signed_result;\n    res.overflow = overflow_flag;\n    \n    return res;\n}\n\nint main(void) {\n    // Define the test cases from the problem statement.\n    TestCase test_cases[] = {\n        {8, 0},\n        {8, 127},\n        {8, -128},\n        {8, -1},\n        {8, -42},\n        {16, -32768},\n        {16, 32767},\n        {16, -12345},\n        {2, -2},\n        {2, 1},\n        {12, -2048},\n        {12, -2047},\n        {32, -2147483648LL},\n        {32, 2147483647LL}\n    };\n\n    // Calculate the number of test cases.\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    Result results[num_cases];\n\n    // Calculate the result for each test case.\n    for (int i = 0; i  num_cases; ++i) {\n        results[i] = simulate_abs(test_cases[i].n, test_cases[i].x);\n    }\n\n    // Print the results in the EXACT REQUIRED format before the final return statement.\n    printf(\"[\");\n    for (int i = 0; i  num_cases; ++i) {\n        printf(\"[%lld,%d]\", results[i].abs_val, results[i].overflow);\n        if (i  num_cases - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\");\n\n    return EXIT_SUCCESS;\n}\n```"
        }
    ]
}