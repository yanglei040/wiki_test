{
    "hands_on_practices": [
        {
            "introduction": "在计算机内部，一串二进制位本身没有意义；它的值取决于我们如何解释它。本练习将通过分析一个关键的位模式，帮助你对比符号-数值表示法和二进制补码表示法这两种体系。理解它们的区别，是掌握有符号数系统的第一步 。",
            "id": "3676847",
            "problem": "设 $n \\geq 3$ 是一个表示字长的正整数。考虑一个 $n$ 位模式 $p$，其最高有效位 (MSB) 为 $1$，其余 $n-1$ 位全为 $0$，即 $p = 1\\underbrace{00\\cdots0}_{n-1\\ \\text{个零}}$。在符号-数值表示法下，采用这样的约定：“有效的负数”要求符号位为 $1$，且数值域为一个严格为正的二进制整数；符号位为 $1$ 且数值域全为零的码字是所谓的“负零”，其数值上等于 $0$，但在此约定下不被视为有效的负数。首先，判断在符号-数值表示法中 $p$ 是否为一个有效的负数，并确定它所表示的整数。接下来，在不改变这些位的情况下，根据二的补码语义（Two’s Complement，缩写为 TC，按计算机算术中使用的标准方式解释）解释同一个固定的位模式 $p$。计算通过这种二的补码重新解释得到的有符号整数值，结果表示为 $n$ 的函数。只需报告该值的闭式表达式。无需四舍五入，也不涉及单位。",
            "solution": "该问题被认为是有效的，因为它在科学上基于计算机算术的原理，定义明确、提法恰当，并且语言客观。它提供了一个比较有符号数表示法的标准练习。\n\n该问题定义了一个 $n$ 位模式 $p$，其中 $n \\geq 3$。该模式的最高有效位（MSB）为 $1$，其余所有 $n-1$ 位均为 $0$。符号上，这可以写作 $p = 1\\underbrace{00\\cdots0}_{n-1}$。我们被要求在两种不同的有符号整数语义下分析这个模式：符号-数值表示法和二的补码。\n\n首先，我们在符号-数值表示法下分析模式 $p$。在这种表示法中，MSB 作为符号位，其中 $1$ 表示负数，$0$ 表示正数。剩下的 $n-1$ 位表示数的大小（量值）。\n对于模式 $p = 100\\cdots0$：\n- 符号位为 $b_{n-1} = 1$，表示该数为负数。\n- 数值由剩下的 $n-1$ 位给出，这些位全为 $0$。一个全零二进制字符串的整数值为 $0$。\n因此，在符号-数值表示法中，$p$ 所表示的数是 $-(0)$，它等于 $0$。这种特定表示 $100\\cdots0$ 通常被称为“负零”。\n\n问题对“有效的负数”施加了一个特定约定：符号位必须为 $1$，且数值域必须表示一个严格为正的二进制整数。在我们的例子中，数值为 $0$，它不是严格为正的。因此，根据这个给定的约定，模式 $p$ 表示整数 $0$，但不符合“有效的负数”的资格。\n\n接下来，我们在二的补码（TC）语义下解释相同的 $n$ 位模式 $p = 100\\cdots0$。在二的补码系统中，一个 $n$ 位二进制数 $b_{n-1}b_{n-2}\\cdots b_1b_0$ 的值使用以下公式计算：\n$$V = -b_{n-1} \\cdot 2^{n-1} + \\sum_{i=0}^{n-2} b_i \\cdot 2^i$$\n对于模式 $p$，各位为：\n- $b_{n-1} = 1$（MSB）\n- 对于所有从 $0$ 到 $n-2$ 的 $i$，$b_i = 0$。\n\n将这些位值代入公式：\n求和项变为：\n$$\\sum_{i=0}^{n-2} b_i \\cdot 2^i = \\sum_{i=0}^{n-2} 0 \\cdot 2^i = 0$$\nMSB的项是：\n$$-b_{n-1} \\cdot 2^{n-1} = -1 \\cdot 2^{n-1} = -2^{n-1}$$\n结合这些结果，模式 $p$ 在二的补码中的总值 $V$ 是：\n$$V = -2^{n-1} + 0 = -2^{n-1}$$\n这个值 $-2^{n-1}$ 表示在二的补码系统中可以用 $n$ 位表示的最负的整数。问题要求将这个值表示为 $n$ 的函数的闭式表达式。\n\n当位模式 $p$ 在二的补码语义下解释时，其值的最终表达式是 $-2^{n-1}$。",
            "answer": "$$\\boxed{-2^{n-1}}$$"
        },
        {
            "introduction": "理解了数字如何表示后，让我们来探究算术运算是如何工作的，尤其是在表示范围的边界处。本练习使用一个正式的数学模型来研究二进制补码算术的“回环”或“溢出”行为，这种现象对于理解为何最大正整数加一常常会变成最小负整数至关重要 。这也是计算机运算底层模运算 ($Z_{2^n}$) 的直接体现。",
            "id": "3676829",
            "problem": "一个算术逻辑单元 (ALU) 使用二进制补码表示法对 $n$ 位字执行加法和减法，其环绕语义与整数模 $2^{n}$ 环（记为 $\\mathbb{Z}_{2^{n}}$）中的算术相同。对于一个固定的整数 $n \\ge 2$，定义位模式（视为 $\\{0,1,\\ldots,2^{n}-1\\} \\subset \\mathbb{Z}_{2^{n}}$ 的元素）和有符号整数之间的两个映射：\n- 编码映射 $E:\\mathbb{Z}\\to\\{0,1,\\ldots,2^{n}-1\\}$，由 $E(y)$ 等于 $y$ 模 $2^{n}$ 的剩余类给出，该剩余类被解释为其在 $\\{0,1,\\ldots,2^{n}-1\\}$ 中的规范表示。\n- 解码映射 $D:\\{0,1,\\ldots,2^{n}-1\\}\\to\\mathbb{Z}$，由下式给出\n$$\nD(x)=\n\\begin{cases}\nx,  0 \\le x \\le 2^{n-1}-1,\\\\\nx-2^{n},  2^{n-1} \\le x \\le 2^{n}-1.\n\\end{cases}\n$$\nALU 的操作语义等价于在 $\\mathbb{Z}_{2^{n}}$ 中对编码值执行加法或减法，然后通过 $D(\\cdot)$ 解码结果。\n\n仅从这些定义以及 $\\mathbb{Z}_{2^{n}}$ 的环性质出发，考虑以下两个边界操作：\n1. 计算 $A$：取可表示的最大非负有符号整数 $2^{n-1}-1$，在 $\\mathbb{Z}_{2^{n}}$ 中加 $1$，然后解码：$A := D\\!\\left(\\left(2^{n-1}-1 + 1\\right) \\bmod 2^{n}\\right)$。\n2. 计算 $B$：取可表示的最小（最负）有符号整数 $-2^{n-1}$，使用 ALU 的减法（即在编码值上进行 $\\mathbb{Z}_{2^{n}}$ 中的减法）减去 $1$，然后解码：$B := D\\!\\left(\\left(E(-2^{n-1}) - 1\\right) \\bmod 2^{n}\\right)$。\n\n从第一性原理推导\n$$\nS(n) = A + B,\n$$\n的闭式值，结果为一个实整数。请将您的最终答案表示为一个简化的数字或闭式表达式。不需要四舍五入，最终答案中不应包含任何单位。",
            "solution": "该问题是良定的，并且基于计算机系统中有符号整数算术的标准原理。题目要求我们对于整数 $n \\ge 2$，推导 $S(n) = A + B$ 的值，其中 $A$ 和 $B$ 是在 $n$ 位二进制补码系统中特定边界情况下的算术运算结果。我们将基于所提供的定义，分别计算 $A$ 和 $B$。\n\n首先，我们计算 $A$ 的值。其定义如下：\n$$\nA := D\\!\\left(\\left(2^{n-1}-1 + 1\\right) \\bmod 2^{n}\\right)\n$$\n该表达式模拟了取可表示的最大正整数 $2^{n-1}-1$，并在 $\\mathbb{Z}_{2^{n}}$ 的算术体系中对其加 1 的结果。我们简化括号内的表达式：\n$$\n(2^{n-1}-1 + 1) \\bmod 2^{n} = 2^{n-1} \\bmod 2^{n}\n$$\n由于 $n \\ge 2$，我们有 $2^{n-1} \\ge 2^{2-1} = 2$。同时，$2^{n-1}  2^n$ 也成立。因此，值 $2^{n-1}$ 在区间 $[0, 2^n-1]$ 内，这意味着它模 $2^n$ 的值就是其本身。\n$$\n2^{n-1} \\bmod 2^{n} = 2^{n-1}\n$$\n将此代回，我们得到：\n$$\nA = D(2^{n-1})\n$$\n现在我们将解码映射 $D(x)$ 应用于参数 $x = 2^{n-1}$。$D(x)$ 的定义是：\n$$\nD(x)=\n\\begin{cases}\nx,  0 \\le x \\le 2^{n-1}-1,\\\\\nx-2^{n},  2^{n-1} \\le x \\le 2^{n}-1.\n\\end{cases}\n$$\n参数 $x = 2^{n-1}$ 满足第二种情况的条件 $2^{n-1} \\le x \\le 2^{n}-1$。因此，我们应用规则 $D(x) = x - 2^n$：\n$$\nA = D(2^{n-1}) = 2^{n-1} - 2^{n} = 2^{n-1} - 2 \\cdot 2^{n-1} = -2^{n-1}\n$$\n这个结果 $A = -2^{n-1}$ 表示算术溢出，即最大正数加 1 得到最小（最负）的数。\n\n接下来，我们计算 $B$ 的值。其定义如下：\n$$\nB := D\\!\\left(\\left(E(-2^{n-1}) - 1\\right) \\bmod 2^{n}\\right)\n$$\n该表达式模拟了取最小（最负）的整数 $-2^{n-1}$ 并从中减去 1。首先，我们必须计算编码值 $E(-2^{n-1})$。编码映射 $E(y)$ 给出 $y$ 在 $\\{0, 1, \\ldots, 2^n - 1\\}$ 中的规范表示。\n$$\nE(-2^{n-1}) = (-2^{n-1}) \\bmod 2^{n} = -2^{n-1} + 2^{n} = 2^{n-1}\n$$\n现在我们将此代入 $B$ 的表达式中：\n$$\nB = D\\!\\left(\\left(2^{n-1} - 1\\right) \\bmod 2^{n}\\right)\n$$\n对于 $n \\ge 2$，我们有 $2^{n-1}-1 \\ge 2^{1}-1 = 1$。同时，$2^{n-1}-1  2^n$。因此，值 $2^{n-1}-1$ 在区间 $[0, 2^n-1]$ 内，它模 $2^n$ 的值就是其本身。\n$$\n(2^{n-1} - 1) \\bmod 2^{n} = 2^{n-1} - 1\n$$\n所以，$B$ 的表达式简化为：\n$$\nB = D(2^{n-1} - 1)\n$$\n我们将解码映射 $D(x)$ 应用于参数 $x = 2^{n-1} - 1$。这个参数满足第一种情况的条件 $0 \\le x \\le 2^{n-1}-1$。因此，我们应用规则 $D(x) = x$：\n$$\nB = D(2^{n-1} - 1) = 2^{n-1} - 1\n$$\n这个结果 $B = 2^{n-1} - 1$ 表示算术下溢，即从最小负数减 1 得到最大正数。\n\n最后，我们计算和 $S(n) = A + B$。\n$$\nS(n) = A + B = (-2^{n-1}) + (2^{n-1} - 1)\n$$\n简化表达式，我们得到：\n$$\nS(n) = -2^{n-1} + 2^{n-1} - 1 = -1\n$$\n对于所有整数 $n \\ge 2$，$S(n)$ 的值是一个常数 $-1$。",
            "answer": "$$\n\\boxed{-1}\n$$"
        },
        {
            "introduction": "让我们将理论知识应用到一个实际的编程任务中，这个任务展示了二进制补码性质的力量与精妙。本题挑战你使用巧妙的位运算而非标准的条件分支来实现一个绝对值函数，这是一种常见的优化技巧 。这将巩固你对位操作的理解，以及如何处理最负数的关键边界情况，因为在这种情况下，简单的取反操作会失败。",
            "id": "3676833",
            "problem": "给定一个在 $n$ 位二进制补码系统中表示的有符号整数 $x$，其中 $n \\geq 2$。在一个 $n$ 位二进制补码系统中，可表示的集合是范围在 $[-2^{n-1}, 2^{n-1}-1]$ 内的所有整数。所有的算术和按位运算都以 $2^n$ 为模进行，并且我们理解一个位模式 $u \\in [0, 2^n-1]$ 的有符号值是其二进制补码的解释：如果最高有效位是 $0$，则值为 $u$，否则为 $u - 2^n$。你可以使用的基本事实是：二进制补码中的有符号数取反等价于按位取反后加一（模 $2^n$），即 $-x \\equiv \\tilde{x} + 1 \\pmod{2^n}$，并且 $x$ 的最高有效位是其符号位。\n\n任务 1：从这些基本定义出发，推导出一个计算绝对值 $\\lvert x \\rvert$ 的无分支表达式，该表达式仅使用按位异或 $\\oplus$、减法以及一个仅从 $x$ 的符号派生出的掩码。该掩码必须通过将 $x$ 算术右移 $n-1$ 位（即移入符号位的副本）来获取符号信息，但在推导过程中不得使用条件分支。证明为什么你的表达式对于可表示范围内的所有 $x$（可能在某个边界值处除外）都能得出 $\\lvert x \\rvert$。精确地将该边界值表示为 $n$ 的函数，并使用二进制补码模算术模型解释在该情况下会发生什么，以及为什么这种行为是不可避免的。\n\n任务 2：实现一个完整、可运行的程序，对于每个测试用例 $(n,x)$，计算：\n- 无分支绝对值的结果，作为 $n$ 位二进制补码解释下的有符号整数。\n- 一个溢出指示符，如果数学上的绝对值 $\\lvert x \\rvert$ 在 $n$ 位上不可表示（即，如果 $x = -2^{n-1}$），则为 $1$，否则为 $0$。\n\n你的实现必须显式地模拟 $n$ 位二进制补码算术，并且不得依赖 C 语言对负值的右移操作的行为。所有用于 $n$ 位运算的内部算术必须以 $2^n$ 为模进行，并且转换回有符号结果必须遵循二进制补码的解释。\n\n测试套件：你的程序必须为以下 $(n,x)$ 对计算结果，其中每个 $x$ 都保证在可表示的范围 $[-2^{n-1}, 2^{n-1}-1]$ 内：\n- $(8, 0)$\n- $(8, 127)$\n- $(8, -128)$\n- $(8, -1)$\n- $(8, -42)$\n- $(16, -32768)$\n- $(16, 32767)$\n- $(16, -12345)$\n- $(2, -2)$\n- $(2, 1)$\n- $(12, -2048)$\n- $(12, -2047)$\n- $(32, -2147483648)$\n- $(32, 2147483647)$\n\n最终输出格式：你的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素对应一个测试用例，顺序与上面列出的一致，并且本身必须是一个形式为 $[a,b]$ 的双元素列表，其中 $a$ 是计算出的无分支绝对值（作为有符号整数），$b$ 是溢出指示符（$0$ 或 $1$）。例如，整体输出应类似于 $[[a_1,b_1],[a_2,b_2],\\dots,[a_{14},b_{14}]]$. 不应打印任何其他文本。",
            "solution": "该问题要求在一个 $n$ 位二进制补码系统中，推导一个用于计算有符号整数绝对值的无分支表达式，并随后实现一个模拟此逻辑的程序。\n\n### 第 1 部分：推导与分析\n\n给定一个在 $n$ 位二进制补码系统中表示的有符号整数 $x$，其中 $n \\geq 2$。整数的可表示范围是 $[-2^{n-1}, 2^{n-1}-1]$。所有算术运算都以 $2^n$ 为模进行。绝对值的数学定义是条件性的：\n$$\n\\lvert x \\rvert = \n\\begin{cases} \nx  \\text{如果 } x \\geq 0 \\\\\n-x  \\text{如果 } x  0 \n\\end{cases}\n$$\n我们的目标是找到一个单一的、无分支的表达式，仅使用按位异或运算符（$\\oplus$）、减法和一个特殊掩码来实现这个逻辑。\n\n**1. 推导掩码**\n\n该表达式必须能区分非负数和负数。这个信息编码在 $x$ 的符号位中，也就是位于第 $n-1$ 位的最高有效位 (MSB)。如果 $x \\geq 0$，符号位为 $0$；如果 $x  0$，符号位为 $1$。\n\n问题规定，一个掩码（我们称之为 $m$）必须通过将 $x$ 算术右移 $n-1$ 位得到。我们将此操作表示为 $x \\gg_{arith} (n-1)$。算术右移会将符号位传播到空出的位置。\n\n-   如果 $x \\geq 0$，其符号位为 $0$。将其右移 $n-1$ 位会用零填充整个 $n$ 位字。得到的位模式是 $00...0_2$，代表整数 $0$。\n-   如果 $x  0$，其符号位为 $1$。将其右移 $n-1$ 位会用一填充整个 $n$ 位字。得到的位模式是 $11...1_2$，在二进制补码表示中是整数 $-1$。\n\n因此，掩码 $m$ 定义为：\n$$ m = x \\gg_{arith} (n-1) = \n\\begin{cases} \n0  \\text{如果 } x \\geq 0 \\\\\n-1  \\text{如果 } x  0 \n\\end{cases}\n$$\n\n**2. 构建无分支表达式**\n\n我们寻求一个表达式 $f(x, m)$，当 $m=0$ 时等于 $x$，当 $m=-1$ 时等于 $-x$。让我们使用提供的二进制补码取反恒等式：$-x \\equiv \\tilde{x} + 1 \\pmod{2^n}$，其中 $\\tilde{x}$ 是 $x$ 的按位取反。\n\n按位异或运算（$\\oplus$）的一个关键属性是，对于任何位模式 $b$，$b \\oplus 0 = b$ 且 $b \\oplus 1 = \\neg b$（反转的位）。当我们将一个完整的字 $x$ 与一个全为一的字（代表 $-1$）进行异或时，结果是 $x$ 的按位取反：\n$$ x \\oplus (-1) = \\tilde{x} $$\n\n让我们考察表达式 $x \\oplus m$：\n-   如果 $x \\geq 0$，则 $m=0$。表达式求值为 $x \\oplus 0 = x$。\n-   如果 $x  0$，则 $m=-1$。表达式求值为 $x \\oplus (-1) = \\tilde{x}$。\n\n这是一个很有希望的中间步骤。我们已经为非负数情况生成了 $x$，为负数情况生成了 $\\tilde{x}$。为了得到最终的绝对值，我们必须调整这个中间结果。\n-   当 $x \\geq 0$ 时，我们得到 $x$，需要的就是 $x$。无需调整。\n-   当 $x  0$ 时，我们得到 $\\tilde{x}$，需要的是 $-x = \\tilde{x} + 1$。我们需要加 $1$。\n\n我们需要找到一个单一的操作，在第一种情况下加 $0$，在第二种情况下加 $1$。观察到，这恰好是加上 $-m$ 的操作：\n-   如果 $x \\geq 0$, $m=0$, 所以我们加上 $-m = 0$。\n-   如果 $x  0$, $m=-1$, 所以我们加上 $-m = 1$。\n\n在二进制补码算术中，加上 $-m$ 等价于减去 $m$。因此，计算出的绝对值的完整无分支表达式（我们称之为 $v$）是：\n$$ v = (x \\oplus m) - m $$\n\n**3. 正确性证明**\n\n让我们为可表示范围内的所有 $x$ 值验证这个表达式。\n\n**情况 1：$x \\geq 0$** ($x \\in [0, 2^{n-1}-1]$)\n在这种情况下，掩码 $m=0$。表达式变为：\n$$ v = (x \\oplus 0) - 0 = x $$\n因为 $x \\geq 0$，所以 $\\lvert x \\rvert = x$，表达式是正确的。\n\n**情况 2：$x  0$** ($x \\in [-2^{n-1}, -1]$)\n在这种情况下，掩码 $m=-1$。表达式变为：\n$$ v = (x \\oplus (-1)) - (-1) = (x \\oplus (-1)) + 1 $$\n如前所述，$x \\oplus (-1)$ 是按位取反 $\\tilde{x}$。所以表达式求值为 $\\tilde{x} + 1$。根据二进制补码取反的定义，这与 $-x$ 模 $2^n$ 同余。\n$$ v \\equiv -x \\pmod{2^n} $$\n对于任何 $x  0$，其数学上的绝对值是 $\\lvert x \\rvert = -x$。只要 $-x$ 是可表示的，该表达式就能给出正确的值。\n\n**4. 边界情况与不可避免的溢出**\n\n一个 $n$ 位二进制补码系统的可表示范围是 $[-2^{n-1}, 2^{n-1}-1]$。让我们检查对于 $x  0$，$-x$ 是否总是可表示的。\n\n-   如果 $x \\in [-2^{n-1}+1, -1]$，那么 $-x \\in [1, 2^{n-1}-1]$。这个范围完全在数字系统的可表示正数部分内。对于这些值，我们的表达式计算出正确的数学绝对值。\n\n-   边界值是最小的负数，$x_{min} = -2^{n-1}$。其数学上的绝对值是 $\\lvert -2^{n-1} \\rvert = 2^{n-1}$。这个值 $2^{n-1}$ 超出了可表示范围，因为可表示的最大正数是 $2^{n-1}-1$。因此，在 $n$ 位系统内，任何操作都不可能产生 $x_{min}$ 的真正数学绝对值。\n\n让我们看看我们的表达式对 $x = -2^{n-1}$ 计算出什么。$x$ 的位模式是 $100...0_2$（其无符号值为 $2^{n-1}$）。\n由于 $x  0$，掩码为 $m=-1$。表达式计算 $v \\equiv -x \\pmod{2^n}$。\n要计算 $x = -2^{n-1}$（位模式 $u_x = 2^{n-1}$）的负值，我们求其补码并加一：\n-   按位取反：$\\tilde{u_x} = \\text{NOT}(100...0_2) = 011...1_2$。这个模式的值是 $2^{n-1}-1$。\n-   加一：$(\\tilde{u_x} + 1) = (2^{n-1}-1) + 1 = 2^{n-1}$。\n得到的位模式是 $2^{n-1}$，即 $100...0_2$。这与原始数字 $x = -2^{n-1}$ 的位模式完全相同。当作为有符号整数解释时，此模式代表值 $-2^{n-1}$。\n\n因此，对于边界值 $x = -2^{n-1}$，我们的表达式计算出：\n$$ v = ((-2^{n-1}) \\oplus (-1)) - (-1) = -2^{n-1} $$\n这种行为是二进制补码表示法不可避免的结果。在模 $2^n$ 算术中，$-2^{n-1}$ 的负值会溢出并回绕到其自身。\n\n问题所要求的溢出指示符当且仅当 $x=-2^{n-1}$ 时应为 $1$。这恰好对应于计算出的绝对值 $v$ 是一个负数的情况。对于任何其他输入 $x$，计算出的值 $v = \\lvert x \\rvert$ 是非负的。因此，可以通过检查结果 $v$ 的符号位是否为 $1$ 来检测溢出条件。",
            "answer": "[[0, 0], [127, 0], [-128, 1], [1, 0], [42, 0], [-32768, 1], [32767, 0], [12345, 0], [-2, 1], [1, 0], [-2048, 1], [2047, 0], [-2147483648, 1], [2147483647, 0]]"
        }
    ]
}