{
    "hands_on_practices": [
        {
            "introduction": "计算机科学中的一个基本问题是如何用二进制位来表示信息。本练习将通过一个为字符集编码的实际例子，来阐明确定唯一标识一个集合中所有项目所需位数的根本原则。这个练习将抽象的二进制数与像文本这样的具体数据联系起来，让你亲身体会信息容量和二进制宽度之间的直接关系。",
            "id": "3622814",
            "problem": "一个计算系统必须为一个与设备无关的文本和控制接口编码一个统一的符号集。该符号集包含由美国信息交换标准代码 (ASCII) 定义的所有字符以及一个额外的设备特定控制集。美国信息交换标准代码 (ASCII) 定义了 $128$ 个不同的码点。设备特定控制集向此统一符号集添加了 $24$ 个新的、不同的控制符号。系统设计者规定每个符号使用一个定长二进制码，其中每个码字恰好有 $b$ 位，并且每个符号必须单射地映射到一个唯一的 $b$ 位字符串。\n\n从一个长度为 $b$ 的、基于两个符号 $\\{0,1\\}$ 的字母表的定长二进制字有 $2^{b}$ 个不同模式这一定义出发，推导出编码该统一符号集所需的最小整数位数 $b$。在你的推理中，请论证文本编码历史上使用 $7$ 位与 $8$位的缘由，并解释典型内存系统中的硬件字节对齐如何影响 $b$ 的选择。请以单个整数形式提供最终答案。无需四舍五入，不涉及物理单位。最终答案仅需写出最小位数 $b$。",
            "solution": "该问题要求确定唯一编码一个统一符号集所需的最小整数位数 $b$。解决方案必须从信息论和计算机体系结构的基本原理推导得出。\n\n首先，我们必须确定需要唯一二进制表示的不同符号的总数。一个长度为 $b$ 的二进制字由 $b$ 个比特的序列组成，其中每个比特可以是两个符号之一，通常是 $\\{0, 1\\}$。用 $b$ 个比特可以形成的不同模式或码字的总数由表达式 $2^b$ 给出。为了使定长编码有效，集合中的每个符号都必须单射地映射到一个唯一的码字。这要求可用的码字数量至少等于要编码的符号总数。如果我们将符号总数表示为 $N$，则该条件可以正式表示为以下不等式：\n$$2^b \\ge N$$\n\n问题指明，统一符号集由两个子集组成：美国信息交换标准代码 (ASCII) 符号集和设备特定的控制集。\n\nASCII 集合中的符号数量为 $N_{ASCII} = 128$。\n设备特定控制集中的额外不同符号数量为 $N_{device} = 24$。\n\n统一集合中的符号总数 $N$ 是这两个不相交集合中符号数量的总和：\n$$N = N_{ASCII} + N_{device} = 128 + 24 = 152$$\n\n现在，我们必须找到满足不等式 $2^b \\ge 152$ 的最小整数 $b$。我们可以通过测试 2 的连续整数次幂来解决这个问题：\n对于 $b=1$, $2^1 = 2$\n对于 $b=2$, $2^2 = 4$\n对于 $b=3$, $2^3 = 8$\n对于 $b=4$, $2^4 = 16$\n对于 $b=5$, $2^5 = 32$\n对于 $b=6$, $2^6 = 64$\n对于 $b=7$, $2^7 = 128$。这不足够，因为 $128  152$。\n对于 $b=8$, $2^8 = 256$。这足够了，因为 $256 \\ge 152$。\n\n使该不等式成立的最小整数 $b$ 值为 $b=8$。\n\n或者，我们可以通过对不等式 $2^b \\ge N$ 两边取以 2 为底的对数来求解：\n$$b \\ge \\log_2(N)$$\n代入 $N=152$，我们得到：\n$$b \\ge \\log_2(152)$$\n我们知道 $\\log_2(128) = 7$ 且 $\\log_2(256) = 8$。由于 $128  152  256$，因此 $7  \\log_2(152)  8$。因为 $b$ 必须是整数，所以满足此条件的最小整数 $b$ 值为 $b=8$。这等价于计算对数的向上取整：$b = \\lceil \\log_2(152) \\rceil = 8$。\n\n该问题还要求论证文本编码历史上使用 $7$ 位与 $8$ 位的缘由，以及硬件字节对齐的影响。\n\n最初的 ASCII 标准使用 $7$ 位，提供了 $2^7 = 128$ 个码点。这足以表示大写和小写英文字母、数字、标点符号和一组控制字符。在那个时代的系统中，数据通常是串行传输的，字节的第 $8$ 位可用作错误检测的奇偶校验位，或者干脆设置为 $0$。\n\n过渡到使用完整的 $8$ 位来表示字符代码本身，而不仅仅是 $7$ 位加上一个奇偶校验位，催生了“扩展ASCII”。此扩展提供了额外的 $128$ 个码点，总计 $2^8 = 256$ 个。这些额外的位置被用来编码原始 ASCII 中不存在的符号，例如特定外语的字母（如 é, ä, ç）、货币符号和块图形字符。这种 $8$ 位编码成为了主流。\n\n硬件字节对齐的影响是系统设计中的一个关键因素。现代计算机内存和处理器几乎普遍设计为以字节为单位操作数据，其中一个字节定义为 $8$ 位。内存是字节寻址的，意味着每个字节都有一个唯一的内存地址。数据总线被设计为传输 $8$ 位的倍数的数据。因此，使用非 $8$ 的倍数的编码长度效率极低。例如，在一个 $8$ 位字节寻址的内存中存储一串 $7$ 位字符流，要么会浪费每个字节一位，要么需要复杂的位打包和解包操作（移位和掩码），这会产生显著的计算开销并使硬件和软件设计复杂化。\n\n对于这个问题，数学上确定的所需最小位数为 $8$。这与 $8$ 位字节的硬件标准完美契合。即使符号集需要，例如 $9$ 位（例如，如果 $N=300$），一个实际的系统设计几乎肯定会为每个符号分配 $16$ 位（两个字节）以保持字节对齐以及在内存寻址和数据处理中的相关效率。因此，选择 $b=8$ 不仅是为了容纳 $152$ 个符号而在数学上是必需的，而且从计算机体系结构的角度来看，也是最实用和最高效的选择。",
            "answer": "$$\\boxed{8}$$"
        },
        {
            "introduction": "现代处理器为了追求极致性能，非常青睐可预测的指令流，并尽量避免使用分支（即条件判断）。本练习将展示一个精妙的“位操作技巧”，它利用二进制补码表示法的内在属性，无需任何条件逻辑即可计算绝对值。这个例子完美地诠释了如何利用数字系统的底层特性来编写出乎意料的高效代码。",
            "id": "3622812",
            "problem": "一个使用二进制补码系统、固定字长为 $w$ 位的中央处理器 (CPU) 支持按位异或 (XOR)、加法、减法和算术右移。在二进制补码中，一个 $w$ 位向量 $x = x_{w-1} x_{w-2} \\dots x_{0}$ 的数值由 $-x_{w-1} 2^{w-1} + \\sum_{i=0}^{w-2} x_i 2^i$ 给出，其中最高有效位 (MSB) $x_{w-1}$ 是符号位。算术右移会将 $x_{w-1}$ 复制到每个空出的位置。\n\n- 仅使用这些基本定义和操作，推导出一个根据符号位构建的掩码 $m(x)$，使得当 $x$ 为非负数时 $m(x)$ 等于 $0$，当 $x$ 为负数时 $m(x)$ 等于 $-1$ (即在二进制补码中所有位都为 $1$)。\n- 从第一性原理出发，推导出一个计算绝对值 $\\mathrm{abs}(x)$ 的无分支闭式表达式，该表达式仅使用 $\\oplus$、 $+$ 或 $-$ 以及掩码 $m(x)$；并证明为何除了可能的极值 $x = -2^{w-1}$ 外，它对所有可表示的 $x$ 都能产生正确的结果。\n- 在 $w=32$ 位的设置下，将您推导的表达式应用于其二进制补码表示为十六进制 $0x\\mathrm{F0A3B7C9}$ 的有符号整数 $x$，并计算 $\\mathrm{abs}(x)$。将最终结果表示为十进制整数。无需四舍五入。",
            "solution": "### 解题推导\n\n**第1部分：掩码 $m(x)$ 的推导**\n\n问题要求一个掩码 $m(x)$，它根据 $x$ 的符号选择性地等于 $0$ 或 $-1$。在所述的二进制补码系统中，整数 $x$ 的符号完全由其最高有效位 (MSB) $x_{w-1}$ 决定。\n- 如果 $x \\ge 0$，其符号位为 $x_{w-1} = 0$。\n- 如果 $x  0$，其符号位为 $x_{w-1} = 1$。\n\n我们需要 $m(x)$ 在 $x_{w-1}=0$ 时是全零的位模式（代表整数 $0$），在 $x_{w-1}=1$ 时是全一的位模式（代表整数 $-1$）。\n\n算术右移操作被定义为复制符号位。我们将算术右移 $k$ 位记为 $\\gg_a k$。当我们将 $x$ 算术右移 $w-1$ 个位置时，原始的 $w-1$ 个最低有效位被移出。最高有效位 $x_{w-1}$ 被复制以填充所有 $w-1$ 个空出的位位置。最高有效位本身保持为 $x_{w-1}$。因此，结果数字的所有 $w$ 位都变得与原始符号位 $x_{w-1}$ 相等。\n\n让我们分析操作 $x \\gg_a (w-1)$ 的结果：\n- 如果 $x \\ge 0$，则 $x_{w-1} = 0$。操作 $x \\gg_a (w-1)$ 产生一个全零的 $w$ 位向量。该向量的数值为 $0$。\n- 如果 $x  0$，则 $x_{w-1} = 1$。操作 $x \\gg_a (w-1)$ 产生一个全一的 $w$ 位向量。在二进制补码中，全一的位向量代表整数 $-1$。\n\n此行为与掩码 $m(x)$ 的要求完全匹配。因此，掩码可以表示为：\n$$m(x) = x \\gg_a (w-1)$$\n\n**第2部分：$\\mathrm{abs}(x)$ 的推导与证明**\n\n绝对值函数的定义如下：\n$$ \\mathrm{abs}(x) = \\begin{cases} x  \\text{if } x \\ge 0 \\\\ -x  \\text{if } x  0 \\end{cases} $$\n我们需要构建一个单一的、无分支的表达式，使用允许的操作和掩码 $m(x)$ 来实现这个逻辑。在二进制补码中，一个数 $y$ 的相反数 $-y$ 计算为 $(\\sim y) + 1$，其中 $\\sim y$ 是 $y$ 的按位取反。按位取反操作可以使用异或实现，因为对于任何位 $b$，有 $b \\oplus 1 = \\sim b$。因此，对一个 $w$ 位数 $y$ 进行按位取反等价于 $y \\oplus (-1)$，因为 $-1$ 被表示为全一的位向量。所以，$-y = (y \\oplus (-1)) + 1$。\n\n让我们为 $\\mathrm{abs}(x)$ 提出以下表达式：\n$$ \\mathrm{abs}(x) = (x \\oplus m(x)) - m(x) $$\n\n我们必须针对 $x$ 符号的两种情况来证明这个表达式的正确性。\n\n情况1：$x \\ge 0$。\n在这种情况下，$m(x) = 0$。将其代入表达式得到：\n$$ (x \\oplus 0) - 0 $$\n异或操作 $x \\oplus 0$ 的结果是 $x$。表达式简化为 $x - 0 = x$。这对于非负数是正确的结果。\n\n情况2：$x  0$。\n在这种情况下，$m(x) = -1$。将其代入表达式得到：\n$$ (x \\oplus (-1)) - (-1) = (x \\oplus (-1)) + 1 $$\n如前所述，项 $x \\oplus (-1)$ 是 $x$ 的按位取反 (即 $\\sim x$)。因此表达式变为 $(\\sim x) + 1$，这是二进制补码取反的标准公式。结果是 $-x$。这对于负数是正确的绝对值。\n\n因此，公式 $\\mathrm{abs}(x)=(x \\oplus m(x)) - m(x)$ 对于所有结果可表示的值都是正确的。\n\n关于例外情况 $x = -2^{w-1}$ 的证明：\n一个 $w$ 位二进制补码系统的可表示整数范围是 $[-2^{w-1}, 2^{w-1}-1]$。对于最小值 $x = -2^{w-1}$，其数学绝对值为 $|-2^{w-1}| = 2^{w-1}$，这超出了可表示范围。\n让我们跟踪公式在 $x = -2^{w-1}$ 时的执行过程。该值由位向量 $100\\dots0$ 表示。\n由于 $x  0$，$m(x) = -1$。\n表达式计算为 $(x \\oplus (-1)) + 1$。\n- $x$ 是 $100\\dots0$。\n- $-1$ 是 $111\\dots1$。\n- $x \\oplus (-1)$ 得到 $011\\dots1$。这是 $2^{w-1}-1$ 的位表示。\n- 对此结果加 $1$：$(2^{w-1}-1) + 1 = 2^{w-1}$。然而，这是使用 $w$ 位算术执行的。\n- 加法 $(011\\dots1) + (000\\dots1)$ 的结果是 $100\\dots0$，产生的进位被丢弃。\n最终的位模式是 $100\\dots0$，它代表原始数字 $-2^{w-1}$。\n所以，对于 $x=-2^{w-1}$，表达式产生 $-2^{w-1}$，而不是数学上的绝对值。这种行为是整数溢出的结果，这是定宽二进制补码算术固有的特性，也证实了问题中指出的限制。\n\n**第3部分：应用于 $w=32$ 和 $x=0x\\mathrm{F0A3B7C9}$**\n\n我们已知 $w=32$ 且 $x$ 的十六进制表示为 $0x\\mathrm{F0A3B7C9}$。\n\n首先，我们确定 $x$ 的符号。十六进制表示的最高有效数字是 `F`，即 $1111_2$。因此，该 $32$ 位整数的最高有效位是 $1$，表明 $x$ 是一个负数。\n\n由于 $x  0$，掩码 $m(x)$ 是 $-1$。对于 $w=32$ 位，$-1$ 在十六进制中表示为 $0x\\mathrm{FFFFFFFF}$。\n\n我们应用推导出的绝对值公式：\n$$ \\mathrm{abs}(x) = (x \\oplus m(x)) - m(x) = (x \\oplus (-1)) + 1 $$\n\n让我们用十六进制进行运算：\n- $x = 0x\\mathrm{F0A3B7C9}$\n- $m(x) = -1 = 0x\\mathrm{FFFFFFFF}$\n\n1.  计算异或操作：$x \\oplus m(x)$。\n    $$ 0x\\mathrm{F0A3B7C9} \\oplus 0x\\mathrm{FFFFFFFF} = 0x\\mathrm{0F5C4836} $$\n    此操作等价于按位取反。\n\n2.  减去掩码：$(x \\oplus m(x)) - m(x)$。这等价于加 $1$。\n    $$ 0x\\mathrm{0F5C4836} - (0x\\mathrm{FFFFFFFF}) = 0x\\mathrm{0F5C4836} + 1 = 0x\\mathrm{0F5C4837} $$\n\n结果 $\\mathrm{abs}(x)$ 的十六进制表示为 $0x\\mathrm{0F5C4837}$。\n\n最后，我们将这个十六进制结果转换为它的十进制整数值：\n$$ 0x\\mathrm{0F5C4837} = (0 \\times 16^7) + (15 \\times 16^6) + (5 \\times 16^5) + (12 \\times 16^4) + (4 \\times 16^3) + (8 \\times 16^2) + (3 \\times 16^1) + (7 \\times 16^0) $$\n$$ = 15 \\times 16777216 + 5 \\times 1048576 + 12 \\times 65536 + 4 \\times 4096 + 8 \\times 256 + 3 \\times 16 + 7 \\times 1 $$\n$$ = 251658240 + 5242880 + 786432 + 16384 + 2048 + 48 + 7 $$\n$$ = 257706039 $$\n\n$\\mathrm{abs}(x)$ 的值为 $257,706,039$。",
            "answer": "$$ \\boxed{257706039} $$"
        }
    ]
}