{
    "hands_on_practices": [
        {
            "introduction": "At its core, the binary system provides a way to represent information. This first practice challenges you to think like a system designer, determining the minimum number of bits required to encode a given set of symbols . You will see how this fundamental calculation, where the number of patterns $2^b$ must be at least the number of symbols $N$, is influenced by practical hardware constraints like byte-addressable memory, bridging the gap between pure mathematics and real-world computer architecture.",
            "id": "3622814",
            "problem": "A computing system must encode a unified symbol set for a device-independent text and control interface. The symbol set consists of all characters defined by the American Standard Code for Information Interchange (ASCII) and an additional device-specific control set. The American Standard Code for Information Interchange (ASCII) defines $128$ distinct code points. The device-specific control set adds $24$ new, distinct control symbols to this unified symbol set. The system designer mandates a fixed-length binary code for each symbol, where each code word has exactly $b$ bits, and every symbol must be mapped injectively to a unique $b$-bit string.\n\nStarting from the fundamental definition that a fixed-length binary word of length $b$ over an alphabet of two symbols $\\{0,1\\}$ has $2^{b}$ distinct patterns, derive the minimal integer number of bits $b$ required to encode the unified symbol set. In your reasoning, justify the historical use of $7$ versus $8$ bits for text encoding and explain how hardware byte alignment in typical memory systems influences the choice of $b$. Provide the final answer as a single integer. No rounding is required, and no physical units are involved. Express only the minimal number of bits $b$ as your final answer.",
            "solution": "The problem requires the determination of the minimum integer number of bits, $b$, to uniquely encode a unified symbol set. The solution must be derived from fundamental principles of information theory and computer architecture.\n\nFirst, we must establish the total number of distinct symbols that require a unique binary representation. A binary word of length $b$ consists of a sequence of $b$ bits, where each bit can be one of two symbols, typically $\\{0, 1\\}$. The total number of distinct patterns or code words that can be formed with $b$ bits is given by the expression $2^b$. For a fixed-length encoding to be valid, every symbol in the set must be mapped injectively to a unique code word. This requires that the number of available code words is at least equal to the total number of symbols to be encoded. If we denote the total number of symbols by $N$, this condition is formally expressed by the inequality:\n$$2^b \\ge N$$\n\nThe problem specifies that the unified symbol set is composed of two subsets: the American Standard Code for Information Interchange (ASCII) symbol set and a device-specific control set.\n\nThe number of symbols in the ASCII set is given as $N_{ASCII} = 128$.\nThe number of additional, distinct symbols in the device-specific control set is given as $N_{device} = 24$.\n\nThe total number of symbols in the unified set, $N$, is the sum of the symbols in these two disjoint sets:\n$$N = N_{ASCII} + N_{device} = 128 + 24 = 152$$\n\nNow, we must find the minimal integer $b$ that satisfies the inequality $2^b \\ge 152$. We can solve this by testing successive integer powers of $2$:\nFor $b=1$, $2^1 = 2$\nFor $b=2$, $2^2 = 4$\nFor $b=3$, $2^3 = 8$\nFor $b=4$, $2^4 = 16$\nFor $b=5$, $2^5 = 32$\nFor $b=6$, $2^6 = 64$\nFor $b=7$, $2^7 = 128$. This is insufficient, as $128  152$.\nFor $b=8$, $2^8 = 256$. This is sufficient, as $256 \\ge 152$.\n\nThe smallest integer value of $b$ for which the inequality holds is $b=8$.\n\nAlternatively, we can solve the inequality $2^b \\ge N$ by taking the base-$2$ logarithm of both sides:\n$$b \\ge \\log_2(N)$$\nSubstituting $N=152$, we get:\n$$b \\ge \\log_2(152)$$\nWe know that $\\log_2(128) = 7$ and $\\log_2(256) = 8$. Since $128  152  256$, it follows that $7  \\log_2(152)  8$. As $b$ must be an integer, the smallest integer value for $b$ that satisfies this condition is $b=8$. This is equivalent to calculating the ceiling of the logarithm: $b = \\lceil \\log_2(152) \\rceil = 8$.\n\nThe problem also requests a justification for the historical use of $7$ versus $8$ bits for text encoding and the influence of hardware byte alignment.\n\nThe original ASCII standard used $7$ bits, providing $2^7 = 128$ code points. This was sufficient for the uppercase and lowercase English alphabet, numerals, punctuation, and a set of control characters. In systems of that era, data was often transmitted serially, and the $8$-th bit of a byte could be used as a parity bit for error detection, or it was simply set to $0$.\n\nThe transition to using a full $8$ bits for the character code itself, rather than just $7$ bits plus a parity bit, allowed for \"extended ASCII\". This extension provided an additional $128$ code points, for a total of $2^8 = 256$. These extra positions were used to encode symbols not present in the original ASCII, such as foreign language-specific letters (e.g., é, ä, ç), currency symbols, and block graphics characters. This $8$-bit encoding became dominant.\n\nThe influence of hardware byte alignment is a critical factor in system design. Modern computer memory and processors are almost universally designed to operate on data in units of bytes, where a byte is defined as $8$ bits. Memory is byte-addressable, meaning each byte has a unique memory address. Data buses are designed to transfer data in multiples of $8$ bits. Consequently, using a code length that is not a multiple of $8$ is highly inefficient. For example, storing a stream of $7$-bit characters in an $8$-bit byte-addressable memory would either waste one bit per byte or require complex bit-packing and unpacking operations (shifting and masking), which incurs significant computational overhead and complicates hardware and software design.\n\nFor this problem, the minimum required number of bits is mathematically determined to be $8$. This aligns perfectly with the hardware standard of the $8$-bit byte. Even if the symbol set had required, for example, $9$ bits (e.g., if $N=300$), a practical system design would almost certainly allocate $16$ bits (two bytes) per symbol to maintain byte alignment and the associated efficiencies in memory addressing and data handling. Therefore, the choice of $b=8$ is not only mathematically necessary to accommodate the $152$ symbols but is also the most practical and efficient choice from a computer architecture perspective.",
            "answer": "$$\\boxed{8}$$"
        },
        {
            "introduction": "Beyond simply representing numbers, the binary system's structure allows for powerful computational shortcuts. This exercise demonstrates how a seemingly complex operation like multiplication can be synthesized from simpler, faster operations like bit shifts and additions . By decomposing a constant into a minimal signed-digit representation, you will explore a technique that compilers and hardware designers use to create highly efficient code and custom circuitry.",
            "id": "3622837",
            "problem": "A processor datapath implements integer constant multiplication using only shifts and additions/subtractions, without a general-purpose multiplier. Assume $32$-bit two's complement integers, and that operations are performed under the assumption that no overflow occurs. From first principles of the binary number system, any nonnegative integer constant $C$ can be expressed as a sum of powers of two, and multiplying an integer $x$ by a power of two $2^{k}$ is equivalent to an arithmetic left shift of $x$ by $k$ bit positions. To minimize the number of addition/subtraction operations, one may also allow a signed binary decomposition in which each digit $d_{k}$ is in $\\{-1,0,1\\}$, so that $C=\\sum_{k} d_{k} 2^{k}$, which reduces the number of nonzero terms by eliminating runs of adjacent ones.\n\nUsing only these foundational facts about binary expansion and left shifts, derive an addition/subtraction-and-shift implementation for multiplication by the constant $C=2317$ that uses the minimal possible number of nonzero power-of-two terms in a signed binary decomposition. Express your final implementation as a single algebraic expression in terms of $x$ that is a sum and difference of terms of the form $2^{k} x$. Do not factor out $x$ or simplify the expression into a single constant times $x$.\n\nYour final answer must be a single closed-form expression. No rounding is required.",
            "solution": "The problem requires an implementation of multiplication by the constant $C = 2317$ using only bit shifts, additions, and subtractions, while minimizing the number of arithmetic operations. This optimization is achieved by finding a signed-digit representation of the constant with the fewest non-zero digits, a representation known as the Non-Adjacent Form (NAF).\n\n**Step 1: Binary Representation of the Constant**\n\nFirst, we express the constant $C = 2317$ in its standard binary form. This is done by decomposing it into a sum of powers of two:\n$$C = 2048 + 256 + 8 + 4 + 1$$\n$$C = 2^{11} + 2^8 + 2^3 + 2^2 + 2^0$$\nThe corresponding binary representation is $(100100001101)_2$. This representation has 5 non-zero bits, which would imply $5-1=4$ additions for a naive shift-and-add implementation.\n\n**Step 2: Conversion to Non-Adjacent Form (NAF)**\n\nThe NAF minimizes the number of non-zero digits by ensuring no two consecutive digits are non-zero. This is achieved by replacing any run of consecutive '1's. A run of $m$ ones starting at bit position $k$, which represents the value $\\sum_{i=k}^{k+m-1} 2^i$, can be algebraically replaced by the equivalent expression $2^{k+m} - 2^k$.\n\nIn the binary representation of 2317, $(10010000\\mathbf{11}01)_2$, we find a run of two '1's at bit positions 2 and 3. This corresponds to the term $2^3 + 2^2$.\nUsing the substitution rule with $k=2$ and $m=2$:\n$$2^3 + 2^2 = 2^{2+2} - 2^2 = 2^4 - 2^2$$\nWe substitute this simplified term back into the original sum of powers for $C$:\n$$C = 2^{11} + 2^8 + (2^4 - 2^2) + 2^0$$\n$$C = 2^{11} + 2^8 + 2^4 - 2^2 + 2^0$$\nThis is the signed-digit representation of $C$ in NAF. It has coefficients from the set $\\{1, -1, 0\\}$, corresponding to the pattern $(100100010\\bar{1}01)_S$, where $\\bar{1}$ denotes $-1$. This representation also has 5 non-zero terms, meaning it requires $5-1=4$ arithmetic operations (3 additions and 1 subtraction). Although the number of operations did not decrease in this specific case, this procedure is general and guarantees minimality.\n\n**Step 3: Final Algebraic Expression**\n\nMultiplying an integer $x$ by the constant $C$ is equivalent to multiplying $x$ by this sum of signed powers of two. Since multiplication by $2^k$ is equivalent to a left shift of $x$ by $k$ bits, the operation $C \\cdot x$ can be expressed as:\n$$C \\cdot x = (2^{11} + 2^8 + 2^4 - 2^2 + 2^0) \\cdot x$$\n$$C \\cdot x = 2^{11}x + 2^8x + 2^4x - 2^2x + 2^0x$$\nThis expression represents the required computation using only shifts (implicit in the $2^k x$ terms) and additions/subtractions, satisfying all conditions of the problem.",
            "answer": "$$\n\\boxed{2^{11}x + 2^{8}x + 2^{4}x - 2^{2}x + 2^{0}x}\n$$"
        },
        {
            "introduction": "The true power of the two's complement system lies in its elegant algebraic properties, which enable remarkable computational tricks. This final practice guides you through creating a 'branchless' algorithm for the absolute value function, a common operation in many applications . You will learn to use bitwise operations and arithmetic shifts to perform conditional logic without program branches, a key technique for maximizing performance on modern pipelined processors.",
            "id": "3622812",
            "problem": "A Central Processing Unit (CPU) using a two’s complement binary number system and a fixed word size of $w$ bits supports bitwise exclusive OR (XOR), addition, subtraction, and arithmetic right shift. In two’s complement, the numeric value of a $w$-bit vector $x = x_{w-1} x_{w-2} \\dots x_{0}$ is given by $-x_{w-1} 2^{w-1} + \\sum_{i=0}^{w-2} x_i 2^i$, where the Most Significant Bit (MSB) $x_{w-1}$ is the sign bit. An arithmetic right shift replicates $x_{w-1}$ in every vacated position.\n\n- Using only these fundamental definitions and operations, derive a mask $m(x)$ built from the sign bit such that $m(x)$ equals $0$ for non-negative $x$ and equals $-1$ (that is, all bits set to $1$ in two’s complement) for negative $x$.\n- From first principles, derive a branchless closed-form expression that computes the absolute value $\\mathrm{abs}(x)$ using only $\\oplus$, $+$ or $-$, and the mask $m(x)$; justify why it produces the correct result for all representable $x$ except possibly the extreme value $x = -2^{w-1}$.\n- Apply your derived expression in a $w=32$ bit setting to the signed integer $x$ whose two’s complement representation is the hexadecimal $0x\\mathrm{F0A3B7C9}$ and compute $\\mathrm{abs}(x)$. Express the final result as a base-$10$ integer. No rounding is required.",
            "solution": "**Part 1: Derivation of the Mask $m(x)$**\n\nThe problem requires a mask $m(x)$ that is selectively either the integer $0$ or the integer $-1$ based on the sign of $x$. In a two's complement system, the sign of an integer $x$ is determined solely by its most significant bit (MSB), $x_{w-1}$.\n- If $x \\ge 0$, its sign bit is $x_{w-1} = 0$.\n- If $x  0$, its sign bit is $x_{w-1} = 1$.\n\nWe need $m(x)$ to be a bit pattern of all zeros (representing the integer $0$) when $x_{w-1}=0$, and a bit pattern of all ones (representing the integer $-1$) when $x_{w-1}=1$.\n\nThe arithmetic right shift operation is defined to replicate the sign bit. Let's denote an arithmetic right shift of $x$ by $k$ bits as $x \\gg_a k$. When we perform an arithmetic right shift on $x$ by $w-1$ positions, the original $w-1$ least significant bits are shifted out. The MSB, $x_{w-1}$, is replicated to fill all $w-1$ vacated bit positions. The MSB itself remains $x_{w-1}$. Consequently, all $w$ bits of the resulting number become equal to the original sign bit.\n\nLet's analyze the result of the operation $x \\gg_a (w-1)$:\n- If $x \\ge 0$, then $x_{w-1} = 0$. The operation $x \\gg_a (w-1)$ produces a $w$-bit vector of all zeros, which represents the integer $0$.\n- If $x  0$, then $x_{w-1} = 1$. The operation $x \\gg_a (w-1)$ produces a $w$-bit vector of all ones, which represents the integer $-1$ in two's complement.\n\nThis behavior precisely matches the requirements for the mask $m(x)$. Therefore, the mask can be expressed as:\n$$m(x) = x \\gg_a (w-1)$$\n\n**Part 2: Derivation and Justification of $\\mathrm{abs}(x)$**\n\nThe absolute value function is defined as:\n$$ \\mathrm{abs}(x) = \\begin{cases} x  \\text{if } x \\ge 0 \\\\ -x  \\text{if } x  0 \\end{cases} $$\nWe need to construct a single, branchless expression that implements this logic using the allowed operations. In two's complement, the negation of a number $y$, written $-y$, is computed as $(\\sim y) + 1$, where $\\sim y$ is the bitwise NOT of $y$. The bitwise NOT operation can be implemented using XOR, since $y \\oplus (-1)$ performs a bitwise inversion on $y$ (because $-1$ is a bit vector of all ones). Therefore, $-y = (y \\oplus (-1)) + 1$.\n\nLet's propose the following expression for $\\mathrm{abs}(x)$:\n$$ \\mathrm{abs}(x) = (x \\oplus m(x)) - m(x) $$\nWe justify this expression by considering both cases for the sign of $x$.\n\nCase 1: $x \\ge 0$.\nIn this case, $m(x) = 0$. Substituting this into the expression gives:\n$$ (x \\oplus 0) - 0 $$\nThe XOR operation $x \\oplus 0$ results in $x$. The expression simplifies to $x - 0 = x$, which is the correct result for a non-negative number.\n\nCase 2: $x  0$.\nIn this case, $m(x) = -1$. Substituting this into the expression gives:\n$$ (x \\oplus (-1)) - (-1) = (x \\oplus (-1)) + 1 $$\nAs established earlier, the term $x \\oplus (-1)$ is the bitwise NOT of $x$ (i.e., $\\sim x$). The expression thus becomes $(\\sim x) + 1$, which is the standard formula for two's complement negation. The result is $-x$, which is the correct absolute value for a negative number.\n\nThus, the formula $\\mathrm{abs}(x)=(x \\oplus m(x)) - m(x)$ is correct for all values where the result is representable. For the minimum value $x = -2^{w-1}$, its mathematical absolute value is $|-2^{w-1}| = 2^{w-1}$, which is outside the representable range of $[-2^{w-1}, 2^{w-1}-1]$. Applying the formula to $x = -2^{w-1}$ results in an integer overflow, and the operation incorrectly yields $-2^{w-1}$, confirming the problem's specified limitation.\n\n**Part 3: Application for $w=32$ and $x=0x\\mathrm{F0A3B7C9}$**\n\nWe are given $w=32$ and the hexadecimal representation of $x$ as $0x\\mathrm{F0A3B7C9}$.\n\nFirst, we determine the sign of $x$. The MSB of the hexadecimal representation is `F`, which is $1111_2$. The MSB of the $32$-bit integer is therefore $1$, indicating that $x$ is a negative number.\n\nSince $x  0$, its absolute value is $-x$. We compute this using two's complement negation: $\\mathrm{abs}(x) = (\\sim x) + 1$.\n\nLet's perform the operations in hexadecimal:\n- $x = 0x\\mathrm{F0A3B7C9}$\n\n1.  Compute the bitwise NOT: $\\sim x$.\n    $$ \\sim(0x\\mathrm{F0A3B7C9}) = 0x\\mathrm{0F5C4836} $$\n\n2.  Add 1 to the result:\n    $$ 0x\\mathrm{0F5C4836} + 1 = 0x\\mathrm{0F5C4837} $$\n\nThe result, $\\mathrm{abs}(x)$, is represented in hexadecimal as $0x\\mathrm{0F5C4837}$.\n\nFinally, we convert this hexadecimal result to its base-$10$ integer value:\n$$ 0x\\mathrm{0F5C4837} = (15 \\times 16^6) + (5 \\times 16^5) + (12 \\times 16^4) + (4 \\times 16^3) + (8 \\times 16^2) + (3 \\times 16^1) + (7 \\times 16^0) $$\n$$ = 15 \\times 16,777,216 + 5 \\times 1,048,576 + 12 \\times 65,536 + 4 \\times 4,096 + 8 \\times 256 + 3 \\times 16 + 7 \\times 1 $$\n$$ = 251,658,240 + 5,242,880 + 786,432 + 16,384 + 2,048 + 48 + 7 $$\n$$ = 257,706,039 $$\n\nThe value of $\\mathrm{abs}(x)$ is $257,706,039$.",
            "answer": "$$ \\boxed{257706039} $$"
        }
    ]
}