{
    "hands_on_practices": [
        {
            "introduction": "我们对数字的直观理解是基于十进制的，但计算机内部使用二进制浮点表示。这导致了一个常见但重要的问题：许多简单的十进制小数（如$0.2$）在二进制中是无限循环的，因此无法被精确表示。这个练习将引导你亲手剖析这一过程，通过从第一性原理出发，计算$0.2$在单精度和双精度格式下的舍入误差，并分析这些微小误差在后续计算中的传播。通过这个实践，你将深刻理解表示误差的来源及其在数值计算中的重要性。",
            "id": "3648798",
            "problem": "一个程序使用国际电气与电子工程师协会 754 (IEEE 754) 浮点标准，在默认的“向最近取整，偶数优先” (Round to Nearest, Ties to Even) 舍入模式下，处理精确的十进制输入 $x = 0.2$。请同时考虑 binary32 (单精度) 和 binary64 (双精度) 两种格式。你需要分析该精确实数 $x$ 在每种格式下的转换过程，以及随后与精确整数 $1000$（该整数在两种格式中均可无舍入精确表示）的乘法运算。\n\n仅使用以下基础知识：\n- IEEE 754 规格化表示包含一个 1 位符号位、一个 e 位偏置指数和一个 p 位小数部分，其有效精度为 p 个小数位，并带有一个隐含的前导 1。对于 binary32，$p = 23$。对于 binary64，$p = 52$。\n- 对于一个表示为 $(1 + f/2^{p}) \\cdot 2^{e}$ 的规格化数，将 $f$ 改变 1，其值将改变 $2^{e - p}$。这就是在该指数下的“最后一位的单位”(Unit in the Last Place, ULP)。在“向最近取整，偶数优先”模式下，舍入误差的绝对值不超过半个 ULP，即 $2^{e - p - 1}$。\n- 精确十进制数 $x = 0.2$ 等于有理数 $x = \\frac{1}{5}$。\n\n任务：\n1. 确定在 binary32 和 binary64 中用于表示 $x$ 的规格化指数 $e$。从上述定义出发（而非使用现成公式），推导将 $x$ 舍入到每种格式下最近的可表示值所需的整数缩放，并证明转换是向上舍入还是向下舍入。据此，为 binary32 和 binary64 分别生成精确的转换误差，以 2 的幂和有理数常数表示的闭式表达式给出，并带有正确的符号。\n2. 将与 1000 的乘法在相应格式的最终舍入前视为精确运算。使用 ULP 的定义，计算乘积量级（接近 200）下 binary32 和 binary64 的 ULP，并判断每个乘积是舍入到精确的 200 还是其上的下一个可表示值。请从第一性原理证明你的结论。\n3. 最后，将两个舍入后乘积之间的差值，以量级为 200 时的 binary64 ULP 为单位进行度量，表示为一个实数。如果你的分析得出了一个精确值，请精确报告；否则，提供一个数值并将其舍入到四位有效数字。\n\n你的最终答案必须是任务 3 中要求的那个实数。",
            "solution": "该问题要求在 IEEE 754 标准下，对涉及数字 $x=0.2$ 的单精度 (binary32) 和双精度 (binary64) 浮点运算进行详细分析。此分析需从第一性原理出发。该问题提法明确，有科学依据，并包含足够的信息以获得唯一解。\n\n三个任务将依次解决。分析的基础是规格化浮点数的表示形式 $v = \\pm (1+m) \\times 2^e$，其中 $m$ 是有效数的小数部分，与存储的 p 位小数 $f$ 相关，关系为 $m=f/2^p$，$e$ 是无偏指数。\n\n**任务 1：$x=0.2$ 的转换误差**\n\n精确的十进制值为 $x=0.2$，即有理数 $\\frac{1}{5}$。要将其表示为规格化二进制浮点格式，我们必须首先确定二进制指数 $e$。我们需要满足 $1 \\le x \\times 2^{-e}  2$。对于 $x=\\frac{1}{5}$，这给出 $1 \\le \\frac{1}{5} \\times 2^{-e}  2$，即 $5 \\le 2^{-e}  10$。在此范围内的唯一整数次幂的 2 是 $8$，所以 $2^{-e}=8=2^3$，得出指数 $e=-3$。此指数对于 binary32 和 binary64 格式是相同的。\n\n需要由有效数表示的值是 $x \\times 2^{-e} = \\frac{1}{5} \\times 2^3 = \\frac{8}{5} = 1.6$。因此，有效数是 $1.6$，它对应一个隐含的前导位 $1$ 和一个小数部分 $m = 0.6 = \\frac{3}{5}$。要将其存储在具有 p 个小数位的格式中，我们必须用 $f/2^p$ 形式的数来近似 $m$，其中 $f$ 是一个整数。这通过将精确的缩放值 $m \\times 2^p = \\frac{3}{5} \\times 2^p$ 舍入到最近的整数来实现。\n\n对于 **binary32**，精度为 $p=23$。我们必须对值 $\\frac{3}{5} \\times 2^{23}$ 进行舍入。\n$$ \\frac{3}{5} \\times 2^{23} = \\frac{3 \\times 8388608}{5} = \\frac{25165824}{5} = 5033164.8 $$\n舍入模式为“向最近取整，偶数优先”。由于 $5033164.8$ 不是平局情况（即其小数部分不完全是 $0.5$），我们舍入到最近的整数。最近的整数是 $5033165$。因此，转换是向上舍入。存储的小数部分为 $f_{32} = 5033165$。\n在 binary32 中表示的值为 $x_{32} = (1 + \\frac{f_{32}}{2^{23}}) \\times 2^{-3}$。\n转换误差 $\\epsilon_{32}$ 是表示值与精确值之差。我们注意到 $f_{32} = \\frac{3}{5} \\times 2^{23} + 0.2$。\n$$ \\epsilon_{32} = x_{32} - x = \\left(1 + \\frac{\\frac{3}{5} \\times 2^{23} + 0.2}{2^{23}}\\right) \\times 2^{-3} - \\frac{1}{5} $$\n$$ \\epsilon_{32} = \\left(1 + \\frac{3}{5} + \\frac{0.2}{2^{23}}\\right) \\times 2^{-3} - \\frac{1}{5} = \\left(\\frac{8}{5} + \\frac{0.2}{2^{23}}\\right) \\times 2^{-3} - \\frac{1}{5} = \\frac{8}{5} \\times 2^{-3} + \\frac{0.2}{2^{26}} - \\frac{1}{5} $$\n$$ \\epsilon_{32} = \\frac{1}{5} + \\frac{1/5}{2^{26}} - \\frac{1}{5} = \\frac{1}{5 \\cdot 2^{26}} $$\n\n对于 **binary64**，精度为 $p=52$。我们对 $\\frac{3}{5} \\times 2^{52}$ 进行舍入。\n$$ \\frac{3}{5} \\times 2^{52} = 0.6 \\times 4503599627370496 = 2702159776422297.6 $$\n同样，这不是平局情况，因此我们舍入到最近的整数，即 $2702159776422298$。转换向上舍入。存储的小数部分为 $f_{64} = 2702159776422298$。\n表示值为 $x_{64} = (1 + \\frac{f_{64}}{2^{52}}) \\times 2^{-3}$。\n转换误差 $\\epsilon_{64}$ 的求解方法类似。我们使用 $f_{64} = \\frac{3}{5} \\times 2^{52} + 0.4$。\n$$ \\epsilon_{64} = x_{64} - x = \\left(1 + \\frac{\\frac{3}{5} \\times 2^{52} + 0.4}{2^{52}}\\right) \\times 2^{-3} - \\frac{1}{5} $$\n$$ \\epsilon_{64} = \\left(1 + \\frac{3}{5} + \\frac{0.4}{2^{52}}\\right) \\times 2^{-3} - \\frac{1}{5} = \\frac{1}{5} + \\frac{0.4}{2^{55}} - \\frac{1}{5} = \\frac{2/5}{2^{55}} = \\frac{2}{5 \\cdot 2^{55}} $$\n\n**任务 2：乘以 1000 及舍入**\n\n问题指出，与整数 $1000$ 的乘法在最终舍入步骤前是精确的。整数 $1000$ 在两种格式中都可精确表示。我们计算精确乘积 $P_{32} = 1000 \\times x_{32}$ 和 $P_{64} = 1000 \\times x_{64}$，然后将它们舍入到各自的精度。\n\n对于 **binary32**：\n精确乘积为 $P_{32} = 1000 \\times x_{32} = 1000 \\times (\\frac{1}{5} + \\epsilon_{32}) = 200 + 1000 \\times \\frac{1}{5 \\cdot 2^{26}} = 200 + \\frac{200}{2^{26}}$。\n乘积的量级接近 $200$。对于接近 $200$ 的值，其指数由 $2^{e'} \\le 200  2^{e'+1}$ 确定。由于 $2^7=128$ 和 $2^8=256$，指数为 $e'=7$。\n在此量级下，binary32 的最后一位的单位 (ULP) 是 $\\text{ULP}_{32} = 2^{e' - p} = 2^{7-23} = 2^{-16}$。\n舍入取决于超出部分 $\\frac{200}{2^{26}}$ 是大于还是小于半个 ULP，即 $\\frac{1}{2}\\text{ULP}_{32} = 2^{-17}$。\n我们将 $\\frac{200}{2^{26}}$ 与 $2^{-17}$ 进行比较。这等价于比较 $200$ 与 $2^{26} \\times 2^{-17} = 2^9 = 512$。\n由于 $200  512$，我们有 $\\frac{200}{2^{26}}  2^{-17}$。\n精确乘积 $P_{32}$ 比下一个可表示数 $200 + \\text{ULP}_{32}$ 更接近 $200$。因此，它向下舍入到 $200$。最终乘积为 $y_{32} = 200$。\n\n对于 **binary64**：\n精确乘积为 $P_{64} = 1000 \\times x_{64} = 1000 \\times (\\frac{1}{5} + \\epsilon_{64}) = 200 + 1000 \\times \\frac{2}{5 \\cdot 2^{55}} = 200 + \\frac{400}{2^{55}}$。\n量级同样接近 200，所以指数为 $e'=7$。\nbinary64 的 ULP 为 $\\text{ULP}_{64} = 2^{e' - p} = 2^{7-52} = 2^{-45}$。\n半个 ULP 是 $\\frac{1}{2}\\text{ULP}_{64} = 2^{-46}$。\n我们将超出部分 $\\frac{400}{2^{55}}$ 与 $2^{-46}$ 进行比较。这等价于比较 $400$ 与 $2^{55} \\times 2^{-46} = 2^9 = 512$。\n由于 $400  512$，我们有 $\\frac{400}{2^{55}}  2^{-46}$。\n精确乘积 $P_{64}$ 比 $200 + \\text{ULP}_{64}$ 更接近 $200$。因此，它也向下舍入到 $200$。最终乘积为 $y_{64} = 200$。\n\n**任务 3：舍入后乘积之间的差值**\n\n在 binary32 中，舍入后的乘积为 $y_{32} = 200$。\n在 binary64 中，舍入后的乘积为 $y_{64} = 200$。\n这两个值之间的差值为 $|y_{64} - y_{32}| = |200 - 200| = 0$。\n问题要求以量级为 200 时的 binary64 ULP 为单位来度量这个差值。无论使用何种度量单位，0 的差值仍然是 0。\n该差值为 $\\frac{0}{\\text{ULP}_{64}} = 0$。\n最终结果是代表此值的单个实数。",
            "answer": "$$\n\\boxed{0}\n$$"
        },
        {
            "introduction": "理解了表示误差后，我们来探讨计算中可能出现的另一个极端情况：当计算结果的绝对值非常小，以至于小于最小的可表示的规格化数时，会发生什么？IEEE 754标准通过“渐进下溢”机制优雅地处理了这一问题。这个练习将构造一个具体的场景，其中两个数的和是精确的规格化数，而它们的差却下溢为一个非零的非规格化数。通过分析这一过程，你将了解渐进下溢如何避免结果被粗暴地“刷新为零”，从而保留了更多的数值信息。",
            "id": "3648788",
            "problem": "您正在使用 IEEE 754 binary32 格式，其设置包括：向最近偶数舍入（round-to-nearest, ties-to-even），启用渐进下溢，以及默认规则“在舍入后检测微小值（tininess）”。binary32 格式包含一个 $1$ 位的符号位，一个 $8$ 位的偏置指数，以及一个 $23$ 位的尾数部分。一个规格化正值的形式为 $1.f \\times 2^{e}$，其中指数 $e \\in \\{-126, \\ldots, 127\\}$，且指数 $e$ 处的最后一位单位（unit in the last place, ULP）等于 $2^{e-23}$。非规格化正值的形式为 $m \\times 2^{-149}$，其中整数 $m \\in \\{1,2,\\ldots,2^{23}-1\\}$。最小的正规格化数是 $2^{-126}$，最小的正非规格化数是 $2^{-149}$。\n\n您的目标是从第一性原理出发，构建一个可复现的测试，确保一对操作数的和是一个精确的规格化结果，而它们的差则产生一个非零的非规格化结果，然后根据 IEEE 754 规则分析异常标志的行为。\n\n- 通过其精确的实数值定义两个目标 binary32 值：\n  - $x_{\\mathrm{fp}} = \\left(2^{23} + 4\\right)\\,2^{-149}$，\n  - $y_{\\mathrm{fp}} = \\left(2^{23} + 2\\right)\\,2^{-149}$。\n  令 $U = 2^{-149}$ 表示指数为 $-126$ 时的 ULP。\n\n- 输入是实数 $x$ 和 $y$，它们在进行任何算术运算之前首先被舍入为 binary32 格式。在“向最近偶数舍入”模式下，一个实数 $r$ 会舍入为唯一的浮点值 $n\\,U$，其整数索引 $n$ 满足 $r \\in \\left[n - \\tfrac{1}{2},\\, n + \\tfrac{1}{2}\\right]\\,U$，其中中点值会舍入到偶数索引 $n$ 对应的数。\n\n任务：\n- 提供明确的非空实数区间 $I_x$ 和 $I_y$，使得在“向最近偶数舍入”模式下，任何 $x \\in I_x$ 都会舍入为 $x_{\\mathrm{fp}}$，任何 $y \\in I_y$ 都会舍入为 $y_{\\mathrm{fp}}$。用 $U$ 和整数索引表示 $I_x$ 和 $I_y$ 的端点，并论证为何中点值会映射到预期的偶数索引值。\n- 仅使用上述核心 IEEE 754 定义，论证对于任何这样的 $x \\in I_x$ 和 $y \\in I_y$，binary32 加法 $x_{\\mathrm{fp}} \\oplus y_{\\mathrm{fp}}$ 是一个精确的规格化结果，而 binary32 减法 $x_{\\mathrm{fp}} \\ominus y_{\\mathrm{fp}}$ 是一个非零的非规格化结果。然后，确定在“舍入后检测微小值”规则下，每个操作会引发五个 IEEE 754 状态标志（无效操作、除以零、上溢、下溢、不精确）中的哪一个，并解释渐进下溢在此测试中是如何体现的。\n- 最后，计算 $x_{\\mathrm{fp}} \\ominus y_{\\mathrm{fp}}$ 的精确实数值，并以最简的精确 2 的幂次形式表示。\n\n您的最终答案必须是一个不带单位的单一精确表达式。",
            "solution": "在进行解答之前，首先对问题陈述进行验证。\n\n**步骤 1：提取已知条件**\n- 标准：IEEE $754$ binary$32$ 格式。\n- 格式细节：$1$ 位符号位，$8$ 位偏置指数，$23$ 位尾数部分。\n- 舍入模式：向最近偶数舍入。\n- 下溢处理：启用渐进下溢。\n- 微小值检测：在舍入后检测。\n- 规格化正值：$1.f \\times 2^{e}$，指数 $e \\in \\{-126, \\ldots, 127\\}$。\n- 指数 $e$ 处的最后一位单位 (ULP)：$2^{e-23}$。\n- 非规格化正值：$m \\times 2^{-149}$，整数 $m \\in \\{1, 2, \\ldots, 2^{23}-1\\}$。\n- 最小正规格化数：$N_{min} = 2^{-126}$。\n- 最小正非规格化数：$S_{min} = 2^{-149}$。\n- 目标值 $x_{\\mathrm{fp}} = \\left(2^{23} + 4\\right)\\,2^{-149}$。\n- 目标值 $y_{\\mathrm{fp}} = \\left(2^{23} + 2\\right)\\,2^{-149}$。\n- 间距单位定义：$U = 2^{-149}$，即指数为 $-126$ 时的 ULP。\n- 对实数 $r$ 的舍入规则：如果 $r \\in \\left[n - \\tfrac{1}{2}, n + \\tfrac{1}{2}\\right]\\,U$，则 $r$ 舍入为 $n\\,U$，其中中点值舍入到整数索引 $n$ 为偶数的数。\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学依据**：该问题很好地基于 IEEE $754$ 浮点算术标准，这是计算机科学和工程领域的一个基本主题。所有提供的定义都与该标准一致。\n- **适定性与一致性**：问题提供了一套完整的规范。我们来验证其内部一致性。指数 $e=-126$ 处的 ULP 确实是 $2^{-126-23} = 2^{-149}$，与给定的 $U$ 的定义相符。最小规格化数是 $N_{min} = 1.0 \\times 2^{-126} = 2^{23} \\times 2^{-23} \\times 2^{-126} = 2^{23} \\times 2^{-149} = 2^{23}U$。值 $x_{\\mathrm{fp}} = (2^{23}+4)U$ 和 $y_{\\mathrm{fp}}=(2^{23}+2)U$ 略大于 $N_{min}$，并且是指数 $e=-126$ 的 binary$32$ 格式中有效的规格化数。对于恒定间距 $U$ 的区域，“向最近偶数舍入”的舍入规则陈述正确。该问题是自包含的、一致的且适定的。\n- **客观性**：问题以精确、客观和形式化的数学语言陈述。\n\n**步骤 3：结论与行动**\n问题有效。将提供完整解答。\n\n**解答**\n\n问题要求完成三项任务：定义舍入区间，分析两个浮点数的和与差，以及计算差的精确值。\n\n**任务 1：舍入区间**\n\n我们需要找到非空实数区间 $I_x$ 和 $I_y$，使得任何 $x \\in I_x$ 都会舍入为 $x_{\\mathrm{fp}}$，任何 $y \\in I_y$ 都会舍入为 $y_{\\mathrm{fp}}$。相关区域的间距单位给定为 $U=2^{-149}$。\n\n目标值 $x_{\\mathrm{fp}}$ 可以写成 $n_x U$，其中整数索引为 $n_x = 2^{23} + 4$。由于 $2^{23}$ 是偶数，所以 $n_x$ 是偶数。\n目标值 $y_{\\mathrm{fp}}$ 可以写成 $n_y U$，其中整数索引为 $n_y = 2^{23} + 2$。同样地，$n_y$ 是偶数。\n\n根据指定的舍入规则，如果一个实数 $r$ 落在区间 $\\left[\\left(n - \\frac{1}{2}\\right)U, \\left(n + \\frac{1}{2}\\right)U\\right]$ 内，它将舍入为浮点数 $nU$。在端点（中点或“ties”），该值会舍入到索引 $n$ 为偶数的邻近值。\n\n对于 $x_{\\mathrm{fp}}$，索引 $n_x = 2^{23} + 4$ 是偶数。因此，以 $x_{\\mathrm{fp}}$ 为中心的闭区间内的任何实数都将舍入为 $x_{\\mathrm{fp}}$。\n该区间的下界是 $\\left(n_x - \\frac{1}{2}\\right)U$，这是 $(n_x-1)U$ 和 $n_xU$ 之间的中点值。由于 $n_x$ 是偶数，$n_x-1$ 是奇数，所以该中点值舍入为 $n_xU$。\n上界是 $\\left(n_x + \\frac{1}{2}\\right)U$，这是 $n_xU$ 和 $(n_x+1)U$ 之间的中点值。由于 $n_x$ 是偶数，$n_x+1$ 是奇数，所以该中点值舍入为 $n_xU$。\n因此，区间 $I_x$ 包含其端点：\n$$I_x = \\left[\\left(2^{23} + 4 - \\frac{1}{2}\\right)U, \\left(2^{23} + 4 + \\frac{1}{2}\\right)U\\right] = \\left[\\left(2^{23} + \\frac{7}{2}\\right)U, \\left(2^{23} + \\frac{9}{2}\\right)U\\right]$$\n\n对于 $y_{\\mathrm{fp}}$，索引 $n_y = 2^{23} + 2$ 也是偶数。适用相同的逻辑。舍入区间 $I_y$ 是：\n$$I_y = \\left[\\left(2^{23} + 2 - \\frac{1}{2}\\right)U, \\left(2^{23} + 2 + \\frac{1}{2}\\right)U\\right] = \\left[\\left(2^{23} + \\frac{3}{2}\\right)U, \\left(2^{23} + \\frac{5}{2}\\right)U\\right]$$\n两个区间都按要求为非空。\n\n**任务 2：和与差运算的分析**\n\n首先，我们将 $x_{\\mathrm{fp}}$ 和 $y_{\\mathrm{fp}}$ 表示为标准的 binary32 形式。\n$$x_{\\mathrm{fp}} = (2^{23}+4)2^{-149} = 2^{-126} + 4 \\cdot 2^{-149} = 2^{-126} + 2^{-147} = 2^{-126}(1 + 2^{-21})$$\n这是一个规格化数，指数 $e = -126$，有效数（significand）为 $1 + 2^{-21}$。其 $23$ 位的尾数部分在第 $21$ 位上为 $1$。\n\n$$y_{\\mathrm{fp}} = (2^{23}+2)2^{-149} = 2^{-126} + 2 \\cdot 2^{-149} = 2^{-126} + 2^{-148} = 2^{-126}(1 + 2^{-22})$$\n这是一个规格化数，指数 $e = -126$，有效数为 $1 + 2^{-22}$。其 $23$ 位的尾数部分在第 $22$ 位上为 $1$。\n\n**加法：$x_{\\mathrm{fp}} \\oplus y_{\\mathrm{fp}}$**\n指数相等，所以我们对有效数进行相加并重新规格化。\n精确的和 $S$ 是：\n$$ S = x_{\\mathrm{fp}} + y_{\\mathrm{fp}} = \\left( (1+2^{-21}) + (1+2^{-22}) \\right) \\times 2^{-126} = (2 + 2^{-21} + 2^{-22}) \\times 2^{-126} $$\n$$ S = (2 + 2 \\cdot 2^{-22} + 2^{-22}) \\times 2^{-126} = (2 + 3 \\cdot 2^{-22}) \\times 2^{-126} $$\n为了规格化，我们提出因子 $2$：\n$$ S = (1 + 3 \\cdot 2^{-23}) \\times 2 \\times 2^{-126} = (1 + (2+1) \\cdot 2^{-23}) \\times 2^{-125} = (1 + 2^{-22} + 2^{-23}) \\times 2^{-125} $$\n结果的指数 $e = -125$，在规格化范围内。有效数 $1 + 2^{-22} + 2^{-23}$ 可以用 $23$ 个尾数位精确表示（在第 $22$ 和第 $23$ 位上为 $1$）。因此，数学和 $S$ 是一个精确的 binary32 浮点数。\n操作 $x_{\\mathrm{fp}} \\oplus y_{\\mathrm{fp}}$ 无需舍入即可返回此精确值。\n\n*加法标志分析：*\n- **无效操作 (Invalid)、除以零 (Divide-by-zero)、上溢 (Overflow)**：不适用。\n- **不精确 (Inexact)**：结果是精确的，因此不精确标志**不会**被置位。\n- **下溢 (Underflow)**：结果是规格化数，因此下溢标志**不会**被置位。\n加法操作不会置位任何标志。\n\n**减法：$x_{\\mathrm{fp}} \\ominus y_{\\mathrm{fp}}$**\n指数相等，所以我们对有效数进行相减。\n精确的差 $D$ 是：\n$$ D = x_{\\mathrm{fp}} - y_{\\mathrm{fp}} = \\left( (1+2^{-21}) - (1+2^{-22}) \\right) \\times 2^{-126} = (2^{-21} - 2^{-22}) \\times 2^{-126} $$\n$$ D = (2 \\cdot 2^{-22} - 2^{-22}) \\times 2^{-126} = 2^{-22} \\times 2^{-126} = 2^{-148} $$\n现在我们必须将这个精确结果 $D$ 舍入到 binary32 格式。最小的正规格化数是 $N_{min} = 2^{-126}$。由于 $D = 2^{-148}  N_{min}$，其结果如果可表示，则必须是非规格化数。\n非规格化数的形式为 $m \\times 2^{-149}$，其中整数 $m \\in \\{1, \\ldots, 2^{23}-1\\}$。\n我们可以将 $D$ 写成：\n$$ D = 2^{-148} = 2 \\times 2^{-149} $$\n这对应于 $m=2$ 的非规格化形式。由于 $m=2$ 在允许范围内，因此 $D=2 \\times 2^{-149}$ 是一个可以精确表示的非规格化数。\n操作 $x_{\\mathrm{fp}} \\ominus y_{\\mathrm{fp}}$ 无需舍入即可返回此精确值。\n\n*减法标志分析：*\n- **无效操作 (Invalid)、除以零 (Divide-by-zero)、上溢 (Overflow)**：不适用。\n- **不精确 (Inexact)**：数学结果是可精确表示的，因此不精确标志**不会**被置位。\n- **下溢 (Underflow)**：下溢异常表示结果是微小的（tiny）。由于微小值是在舍入后检测的，我们检查最终结果的绝对值是否小于 $N_{min}$。最终结果是 $2^{-148}$，且 $2^{-148}  2^{-126}$。因此，结果是微小的。IEEE 754 标准规定，对于传递给用户的任何微小、非零的结果，都会置位下溢标志。非规格化数的产生是渐进下溢的直接体现。因此，下溢标志被**置位**。\n\n**渐进下溢的体现**：两个相近的规格化数相减导致了高位的显著抵消。精确结果 $2^{-148}$ 小于最小的规格化数。结果没有被刷新为零（flushed to zero），而是表示为非规格化数 $2 \\times 2^{-149}$。这保留了结果中的数值信息，而不是突然降为零，而这正是渐进下溢机制的目的。\n\n**任务 3：差的最终值**\n\n最后一项任务是计算浮点运算 $x_{\\mathrm{fp}} \\ominus y_{\\mathrm{fp}}$ 的精确实数值。如上所述，数学上的差是 $D = 2^{-148}$。该值可以精确地表示为一个 binary32 非规格化数。因此，该运算的计算结果与数学结果相同。\n$x_{\\mathrm{fp}} \\ominus y_{\\mathrm{fp}}$ 的精确实数值是 $2^{-148}$。",
            "answer": "$$\\boxed{2^{-148}}$$"
        },
        {
            "introduction": "渐进下溢是处理微小数值的强大机制，但如果结果小到连非规格化数都无法表示呢？这时结果将舍入为零。然而，IEEE 754标准在这里引入了一个精妙但至关重要的概念：带符号的零（$+0$ 和 $-0$）。这个练习将带你探索一个导致结果下溢为零的场景，并揭示结果的符号是如何被保留的。通过分析带符号的零在后续运算（如除法）中如何导致截然不同的行为（产生$+\\infty$或$-\\infty$），你将认识到这一特性对于编写健壮和正确的数值代码是多么关键。",
            "id": "3648797",
            "problem": "一个处理器根据电气与电子工程师协会（IEEE）754 浮点标准实现算术运算。在此实现中，减法以 binary64 精度（通常称为双精度）执行，然后结果被舍入并以 binary16 精度（通常称为半精度）存储。舍入模式为朝零舍入。\n\n设 $b = 1$ 在 binary64 中被精确表示。设 $a$ 为大于 $1$ 的下一个可表示的 binary64 数，即 $a = \\operatorname{nextUp}_{64}(1)$。考虑以下两个减法运算，它们在 binary64 中精确计算，然后使用朝零舍入模式舍入到 binary16：\n- $r_{1} = \\operatorname{round}_{16}(a - b)$，\n- $r_{2} = \\operatorname{round}_{16}(b - a)$，\n其中 $\\operatorname{round}_{16}(\\cdot)$ 表示使用朝零舍入将精确的实数结果舍入为可表示的 binary16 值。\n\n你只能使用以下 IEEE 754 的基本事实和核心定义：\n- 一个二进制 $p$ 精度尾数对于规格化数有 $p-1$ 个小数位和一个隐含的前导 $1$；在 binary64 中，$p = 53$，因此在 $1$ 处的间距是 $2^{-(p-1)}$。\n- binary16 中最小的正非规格化数的值为 $2^{1-\\beta} \\cdot 2^{-(p_{16}-1)}$，其中 $p_{16} = 11$ 且偏置 $\\beta = 15$。\n- 在朝零舍入模式下，任何量值严格小于最小正非规格化数的非零精确结果都将舍入为带符号零，其符号与精确结果的符号相同。\n- 带符号零会传播其符号位：在朝零舍入模式下，舍入后的零的符号位等于精确结果的符号。\n- 在 IEEE 754 比较中，$+0$ 和 $-0$ 比较结果为相等，而除以带符号零会产生带符号无穷大，其中 $\\frac{1}{+0} = +\\infty$ 和 $\\frac{1}{-0} = -\\infty$。\n\n定义指示函数 $I(\\cdot)$，当其逻辑条件为真时为 $1$，否则为 $0$；定义符号位函数 $\\operatorname{sb}(x)$，当 $x$ 的符号位为 $1$（即为负数，包括 $-0$）时为 $1$，否则为 $0$。考虑以下编码为整数的分支敏感的代码结果\n$$\nE \\;=\\; 100 \\cdot \\operatorname{sb}(r_{1}) \\;+\\; 10 \\cdot I\\!\\big((1/r_{2})  0\\big) \\;+\\; I(r_{1} = r_{2}).\n$$\n\n从上面列出的基本事实出发，证明符号如何传播到 $r_{1}$ 和 $r_{2}$ 中，以及出现在 $E$ 中的比较结果，然后计算 $E$ 的值。你的最终答案必须是一个实数值。该答案无需舍入指令。",
            "solution": "首先将验证问题陈述，以确保其科学上可靠、自洽且定义明确。\n\n### 步骤 1：提取已知条件\n问题提供了以下数据和定义：\n- **算术背景**：IEEE 754 标准，减法以 binary64 精度执行，随后舍入到 binary16 精度。\n- **舍入模式**：朝零舍入。\n- **初始值**：\n    - $b = 1$，在 binary64 中精确表示。\n    - $a = \\operatorname{nextUp}_{64}(1)$，大于 $1$ 的下一个可表示的 binary64 数。\n- **计算值**：\n    - $r_{1} = \\operatorname{round}_{16}(a - b)$\n    - $r_{2} = \\operatorname{round}_{16}(b - a)$\n- **IEEE 754 定义**：\n    - 对于二进制 $p$ 精度格式中的规格化数，尾数有 $p-1$ 个小数位和一个隐含的前导 $1$。\n    - 对于 binary64，精度 $p = 53$。在 $1$ 处的间距（末位单位，ulp）是 $2^{-(p-1)}$。\n    - 对于 binary16，精度 $p_{16} = 11$ 且偏置 $\\beta = 15$。\n    - binary16 中最小的正非规格化数是 $2^{1-\\beta} \\cdot 2^{-(p_{16}-1)}$。\n    - **舍入规则**：对于朝零舍入，任何量值严格小于最小正非规格化数的非零精确结果都将舍入为带符号零，其符号与精确结果的符号相同。\n    - **带符号零传播**：在朝零舍入模式下，舍入后的零的符号位等于精确结果的符号。\n    - **比较**：$+0$ 和 $-0$ 比较结果为相等。\n    - **除以零**：$\\frac{1}{+0} = +\\infty$ 和 $\\frac{1}{-0} = -\\infty$。\n- **辅助函数**：\n    - 指示函数 $I(\\cdot)$ 当其条件为真时为 $1$，否则为 $0$。\n    - 符号位函数 $\\operatorname{sb}(x)$ 当 $x$ 的符号位为 $1$（即为负数，包括 $-0$）时为 $1$，否则为 $0$。\n- **待求值的表达式**：\n    - $E \\;=\\; 100 \\cdot \\operatorname{sb}(r_{1}) \\;+\\; 10 \\cdot I\\!\\big((1/r_{2})  0\\big) \\;+\\; I(r_{1} = r_{2})$。\n\n### 步骤 2：使用提取的已知条件进行验证\n根据指定标准对问题进行评估。\n- **科学上可靠**：该问题完全基于 IEEE 754 浮点标准的正式定义和属性，这是计算机组成和体系结构的基石。所有提供的事实都是该标准的正确方面。\n- **定义明确**：问题定义清晰。输入（$a$，$b$）、操作（减法、舍入）和规则（舍入模式、特殊值的属性）都得到了精确规定，从而可以得出 $E$ 的唯一、可确定的结果。\n- **客观性**：语言正式且无歧义。`round_16`、`sb` 和 `I` 的定义是明确的。\n该问题没有任何科学上的不健全、不完整或含糊之处。在其指定的领域内，这是一个形式化的、可解决的问题。\n\n### 步骤 3：结论与行动\n问题是**有效的**。现在将推导出一个完整的解决方案。\n\n### 解题推导\n\n解决方案需要计算 $r_1$ 和 $r_2$ 的值，然后用它们来计算表达式 $E$ 的值。\n\n**1. 确定减法的精确值**\n\n值 $b=1$ 是 $2$ 的幂，在 binary64 中可以精确表示。其表示为 $1.0 \\times 2^0$。\n值 $a = \\operatorname{nextUp}_{64}(1)$ 是大于 $1$ 的最小可表示 binary64 数。在 $1$ 附近的可表示数之间的间隙是末位单位（ulp）。问题指出，对于精度为 $p$ 的二进制格式，在 $1$ 处的间距是 $2^{-(p-1)}$。对于 binary64，$p=53$。\n因此，间距是 $2^{-(53-1)} = 2^{-52}$。\n这个量是 binary64 的机器 epsilon，$\\epsilon_{64}$。\n所以，$a = 1 + 2^{-52}$。\n\n第一次减法 $a-b$ 的精确结果是：\n$$ x_1 = a - b = (1 + 2^{-52}) - 1 = 2^{-52} $$\n精确结果是一个小的正数。\n\n第二次减法 $b-a$ 的精确结果是：\n$$ x_2 = b - a = 1 - (1 + 2^{-52}) = -2^{-52} $$\n精确结果是一个小的负数。\n\n**2. 确定舍入行为**\n\n结果 $x_1$ 和 $x_2$ 在 binary64 中计算，然后使用朝零舍入模式舍入到 binary16。问题指出，如果精确结果的量值严格小于最小的正非规格化数，它将舍入为带符号零。\n\n首先，我们必须计算 binary16 中最小的正非规格化数的值，我们将其表示为 $s_{min,16}$。根据提供的公式，其中 $p_{16} = 11$ 且偏置 $\\beta = 15$：\n$$ s_{min,16} = 2^{1-\\beta} \\cdot 2^{-(p_{16}-1)} = 2^{1-15} \\cdot 2^{-(11-1)} = 2^{-14} \\cdot 2^{-10} = 2^{-24} $$\n\n现在，我们将 $x_1$ 和 $x_2$ 的量值与 $s_{min,16}$ 进行比较：\n$$ |x_1| = |2^{-52}| = 2^{-52} $$\n$$ |x_2| = |-2^{-52}| = 2^{-52} $$\n因为 $52 > 24$，所以 $2^{-52}  2^{-24}$。因此，$x_1$ 和 $x_2$ 的量值都严格小于 $s_{min,16}$。\n\n根据给定的朝零舍入规则，$x_1$ 和 $x_2$ 都将发生下溢并被舍入为带符号零。符号从精确结果中保留。\n\n对于 $r_1$：精确结果是 $x_1 = 2^{-52}$，为正数。\n$$ r_1 = \\operatorname{round}_{16}(2^{-52}) = +0 $$\n\n对于 $r_2$：精确结果是 $x_2 = -2^{-52}$，为负数。\n$$ r_2 = \\operatorname{round}_{16}(-2^{-52}) = -0 $$\n\n**3. 计算 E 的表达式**\n\nE 的表达式为 $100 \\cdot \\operatorname{sb}(r_{1}) \\;+\\; 10 \\cdot I\\!\\big((1/r_{2})  0\\big) \\;+\\; I(r_{1} = r_{2})$。我们逐项计算。\n\n- **第 1 项：$100 \\cdot \\operatorname{sb}(r_{1})$**\n函数 $\\operatorname{sb}(x)$ 在 $x$ 的符号位为 $1$（负数）时为 $1$，否则为 $0$。我们有 $r_1 = +0$。$+0$ 的符号位是 $0$。\n因此，$\\operatorname{sb}(r_{1}) = \\operatorname{sb}(+0) = 0$。\n第一项的值是 $100 \\cdot 0 = 0$。\n\n- **第 2 项：$10 \\cdot I\\!\\big((1/r_{2})  0\\big)$**\n我们有 $r_2 = -0$。问题提供了除以带符号零的规则：$\\frac{1}{-0} = -\\infty$。\n指示函数内部的条件是 $(1/r_2)  0$，即 $-\\infty  0$。这个不等式是成立的。\n因为条件为真，所以指示函数 $I(\\cdot)$ 的值为 $1$。\n第二项的值是 $10 \\cdot 1 = 10$。\n\n- **第 3 项：$I(r_{1} = r_{2})$**\n我们需要计算比较 $r_1 = r_2$。我们有 $r_1 = +0$ 和 $r_2 = -0$。\n问题指出，在 IEEE 754 比较中，$+0$ 和 $-0$ 比较结果为相等。所以，条件 $r_1 = r_2$ 是真的。\n因为条件为真，所以指示函数 $I(\\cdot)$ 的值为 $1$。\n第三项的值是 $1$。\n\n**4. 计算 E 的最终值**\n\n将三项的值相加：\n$$ E = 0 + 10 + 1 = 11 $$\n整数表达式 $E$ 的最终值是 $11$。",
            "answer": "$$\n\\boxed{11}\n$$"
        }
    ]
}