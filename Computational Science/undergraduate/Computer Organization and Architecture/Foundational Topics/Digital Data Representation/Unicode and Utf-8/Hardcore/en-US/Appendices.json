{
    "hands_on_practices": [
        {
            "introduction": "Before we can optimize, we must first ensure correctness. This initial practice challenges you to build a UTF-8 validator from the ground up, using only fundamental bitwise operations. By creating bit masks to identify lead and continuation bytes and reconstructing code points, you will gain a deep, practical understanding of how this ubiquitous encoding scheme works at the lowest level . This exercise is a foundational skill for any programmer working close to the hardware, where data is seen not as text, but as a stream of bytes.",
            "id": "3622809",
            "problem": "You are asked to design and implement a binary validator for Unicode Transformation Format-8 (UTF-8). The validator must rely on first principles of the binary number system, using binary positional representation and bitwise operations to classify bytes and to reconstruct code points. A byte consists of $8$ binary digits (bits), ordered with weights $2^7, 2^6, \\dots, 2^0$. A bit mask is a binary number used with bitwise logical operations to select specific subsets of bits; for example, the bitwise AND operation preserves a bit only where both operands have a $1$ in that position.\n\nUTF-8 encodes Unicode scalar values into sequences of one to four bytes. A leading byte encodes the sequence length by its most significant bit pattern, and continuation bytes use a fixed pattern. The validator must use binary masks to distinguish leading bytes from continuation bytes, and must reconstruct code points to detect invalid and overlong encodings. The foundational facts you may assume are:\n\n- The binary positional representation of integers and the properties of bitwise operations, including bitwise AND, bitwise OR, and bit shifting.\n- UTF-8 byte structure, described qualitatively by most significant bit patterns:\n  - Single-byte character: leading byte pattern $0xxxxxxx$.\n  - Two-byte sequence: leading byte pattern $110xxxxx$, followed by one continuation byte.\n  - Three-byte sequence: leading byte pattern $1110xxxx$, followed by two continuation bytes.\n  - Four-byte sequence: leading byte pattern $11110xxx$, followed by three continuation bytes.\n  - Continuation byte pattern $10xxxxxx$.\n- A valid reconstructed code point must satisfy $0 \\leq \\text{code point} \\leq 0x10FFFF$ and must not lie in the Unicode surrogate range $[0xD800, 0xDFFF]$.\n- A sequence must not be overlong: a sequence of $n$ bytes must not encode a value smaller than the minimal value representable by $n$ bytes, namely $0x80$ for $n=2$, $0x800$ for $n=3$, and $0x10000$ for $n=4$.\n\nYour program must:\n\n- For each test case, treat the data as a byte array and return $1$ if the entire array is a valid UTF-8 sequence and $0$ otherwise.\n- Derive and use binary masks that can identify continuation bytes and classify leading bytes into their sequence lengths.\n- Reconstruct the code point from the sequence using bit extraction and concatenation and verify all constraints from the fundamental base stated above.\n- Reject any stray continuation byte not preceded by an appropriate leading byte, any incomplete multibyte sequence, any $5$-byte or longer lead pattern, any overlong encoding, any surrogate code point, and any code point greater than $0x10FFFF$.\n\nTest suite to validate different facets of the solution:\n\n- Case $1$: ASCII string bytes $\\{0x48,0x65,0x6C,0x6C,0x6F\\}$.\n- Case $2$: Two-byte valid character $\\{0xC3,0xB1\\}$ (Latin small letter enye).\n- Case $3$: Three-byte valid character $\\{0xE2,0x82,0xAC\\}$ (Euro sign).\n- Case $4$: Four-byte valid character $\\{0xF0,0x90,0x8D,0x88\\}$ (Gothic letter hwair, code point $U+10348$).\n- Case $5$: Overlong encoding of $U+0000$: $\\{0xC0,0x80\\}$.\n- Case $6$: Surrogate code point encoded: $\\{0xED,0xA0,0x80\\}$ (represents $U+D800$).\n- Case $7$: Stray continuation byte: $\\{0x80\\}$.\n- Case $8$: Incomplete three-byte sequence: $\\{0xE2,0x82\\}$.\n- Case $9$: Largest valid code point $U+10FFFF$: $\\{0xF4,0x8F,0xBF,0xBF\\}$.\n- Case $10$: Code point beyond $U+10FFFF$: $\\{0xF4,0x90,0x80,0x80\\}$.\n- Case $11$: Invalid five-byte leading pattern: $\\{0xF8,0x80,0x80,0x80,0x80\\}$.\n- Case $12$: ASCII followed by stray continuation byte: $\\{0x41,0x80\\}$.\n- Case $13$: Minimal valid two-byte value $U+0080$: $\\{0xC2,0x80\\}$.\n- Case $14$: Minimal valid three-byte value $U+0800$: $\\{0xE0,0xA0,0x80\\}$.\n- Case $15$: Minimal valid four-byte value $U+10000$: $\\{0xF0,0x90,0x80,0x80\\}$.\n\nFinal output format:\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test cases above (e.g., $\\left[\\text{result}_1,\\text{result}_2,\\dots,\\text{result}_{15}\\right]$). Each result must be an integer $0$ or $1$ on that single line.",
            "solution": "The problem statement is subjected to validation before a solution is attempted.\n\n### Step 1: Extract Givens\n- **Domain**: Binary validator for Unicode Transformation Format-8 (UTF-8).\n- **Core Principles**: The validator must be based on the binary positional representation of numbers and bitwise operations.\n- **Byte Definition**: A byte consists of $8$ bits, with weights from $2^7$ (most significant bit, MSB) to $2^0$ (least significant bit, LSB).\n- **Bit Mask Definition**: A bit mask is a binary number used with bitwise logical operations to select specific subsets of bits.\n- **UTF-8 Byte Structures (Qualitative)**:\n    - Single-byte: `$0xxxxxxx$`\n    - Two-byte sequence: `$110xxxxx$` followed by one continuation byte.\n    - Three-byte sequence: `$1110xxxx$` followed by two continuation bytes.\n    - Four-byte sequence: `$11110xxx$` followed by three continuation bytes.\n    - Continuation byte: `$10xxxxxx$`\n- **Validation Constraints**:\n    - A valid reconstructed code point must be in the range $[0, 0x10FFFF]$.\n    - A valid reconstructed code point must not be in the Unicode surrogate range $[0xD800, 0xDFFF]$.\n    - A sequence must not be overlong. Minimal values for multibyte sequences are:\n        - $n=2$ bytes: $0x80$\n        - $n=3$ bytes: $0x800$\n        - $n=4$ bytes: $0x10000$\n- **Program Requirements**:\n    - Input: A byte array for each test case.\n    - Output: Return $1$ if the entire array is a valid UTF-8 sequence, $0$ otherwise.\n    - The program must reject:\n        - Stray continuation bytes.\n        - Incomplete multibyte sequences.\n        - $5$-byte or longer lead patterns.\n        - Overlong encodings.\n        - Surrogate code points.\n        - Code points greater than $0x10FFFF$.\n- **Test Suite**: $15$ specific byte array test cases are provided to be validated.\n- **Final Output Format**: A single line containing a comma-separated list of integer results ($0$ or $1$) enclosed in square brackets, e.g., `[result_1,result_2,...,result_15]`.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is assessed against the established validation criteria.\n\n- **Scientifically Grounded**: The problem is firmly rooted in computer science, specifically in the standard definition of the UTF-8 encoding scheme (RFC 3629). All definitions and constraints (byte structure, code point ranges, surrogate blocks, overlong forms) are factually correct and consistent with established standards.\n- **Well-Posed**: The problem is well-posed. The inputs are clearly defined byte arrays, and the required output is a deterministic boolean classification ($1$ for valid, $0$ for invalid). The rules provided are sufficient and unambiguous, leading to a unique and meaningful solution for any given byte stream.\n- **Objective**: The language is precise and technical. It avoids subjectivity, ambiguity, and opinion. All terms are either standard in computer organization and architecture or are explicitly defined.\n\nThe problem does not exhibit any of the listed invalidity flaws. It is a formal, self-contained, and verifiable problem based on fundamental principles of digital logic and data encoding.\n\n### Step 3: Verdict and Action\nThe problem is deemed **valid**. A solution will be developed based on the provided specifications.\n\n### Solution Derivation\n\nThe design of a UTF-8 validator from first principles requires a systematic, state-based traversal of the input byte stream. Each byte must be classified, and the integrity of the sequence it belongs to must be verified. This process relies on bitwise operations to inspect the binary structure of each byte. An 8-bit byte will be represented as an `unsigned char` in the implementation to prevent sign-extension artifacts during bitwise manipulation.\n\nWe begin by formalizing the byte patterns using binary masks. A bitwise AND operation (``) between a byte and a mask allows us to isolate and test a specific group of bits.\n\n1.  **Byte Classification Using Bitmasks**:\n    The most significant bits of a byte determine its role in a UTF-8 sequence. We can derive masks to identify each type of byte:\n    - **Single-byte (ASCII)**: The pattern is `$0xxxxxxx$`. The most significant bit must be $0$. We test this by masking with `$10000000_2$` (or `$0x80$`). A byte `b` is a single-byte character if `(b  0x80) == 0x00`.\n    - **Continuation Byte**: The pattern is `$10xxxxxx$`. The two most significant bits must be `$10$`. We test this by masking with `$11000000_2$` (or `$0xC0$`) and comparing the result to `$10000000_2$` (or `$0x80$`). A byte `b` is a continuation byte if `(b  0xC0) == 0x80`.\n    - **Two-byte Lead Byte**: The pattern is `$110xxxxx$`. The three most significant bits must be `$110$`. The mask is `$11100000_2$` (or `$0xE0$`), and the expected result is `$11000000_2$` (or `$0xC0$`). The condition is `(b  0xE0) == 0xC0`.\n    - **Three-byte Lead Byte**: The pattern is `$1110xxxx$`. The four most significant bits must be `$1110$`. The mask is `$11110000_2$` (or `$0xF0$`), and the expected result is `$11100000_2$` (or `$0xE0$`). The condition is `(b  0xF0) == 0xE0`.\n    - **Four-byte Lead Byte**: The pattern is `$11110xxx$`. The five most significant bits must be `$11110$`. The mask is `$11111000_2$` (or `$0xF8$`), and the expected result is `$11110000_2$` (or `$0xF0$`). The condition is `(b  0xF8) == 0xF0`.\n    - **Invalid Bytes**: Any byte that does not match one of the above patterns is invalid as a starting byte. This includes stray continuation bytes (already covered) and bytes with patterns like `$11111xxx$` (e.g., `$0xF8$`, `$0xFC$`), which were part of obsolete $5$- and $6$-byte UTF-8 specifications.\n\n2.  **Stateful Processing Algorithm**:\n    The validator will iterate through the byte array. The state at any point is determined by the number of continuation bytes expected.\n    - Let `i` be the index into the byte array of length `L`. The loop proceeds as long as `i  L`.\n    - At index `i`, read the byte `b = data[i]`.\n    - Classify `b` as a lead byte. Based on its type, determine the expected number of subsequent continuation bytes, `n_cont`.\n        - If `(b  0x80) == 0x00`, it's a $1$-byte sequence. `n_cont = 0`. The sequence length is $1$.\n        - If `(b  0xE0) == 0xC0`, it's a $2$-byte sequence. `n_cont = 1`. The sequence length is $2$.\n        - If `(b  0xF0) == 0xE0`, it's a $3$-byte sequence. `n_cont = 2$. The sequence length is $3$.\n        - If `(b  0xF8) == 0xF0`, it's a $4$-byte sequence. `n_cont = 3$. The sequence length is $4$.\n        - Otherwise, the byte `b` is an invalid starting byte (e.g., a stray continuation byte or an invalid pattern like `$0xF8$`). The entire stream is invalid.\n    - Upon identifying a lead byte for a multi-byte sequence of total length `T = n_cont + 1`:\n        - **Check for Incomplete Sequence**: Verify that there are enough bytes remaining in the array. We must have `i + T = L`. If not, the sequence is incomplete and thus invalid.\n        - **Verify Continuation Bytes**: For each of the `n_cont` subsequent bytes `data[i+j]` where `j` is from $1$ to `n_cont`, verify that `(data[i+j]  0xC0) == 0x80`. If any byte fails this test, the sequence is invalid.\n\n3.  **Code Point Reconstruction and Validation**:\n    After confirming the structural integrity of a byte sequence, the Unicode code point must be reconstructed and validated. This involves extracting the payload bits from each byte and concatenating them.\n    - Payload bits are extracted by masking the data-carrying portions of the bytes.\n    - **1-byte sequence (`0xxxxxxx`)**: The code point is the byte value itself. No further validation is needed as its value is less than $0x80$. Code point: `data[i]`.\n    - **2-byte sequence (`110yyyyy 10zzzzzz`)**: The payload is `yyyyyzzzzzz`.\n        - `val1 = data[i]  0x1F` (mask `$00011111_2$`)\n        - `val2 = data[i+1]  0x3F` (mask `$00111111_2$`)\n        - Code point: `(val1  6) | val2`.\n        - Validation: Must not be overlong. The code point must be $\\ge 0x80$.\n    - **3-byte sequence (`1110wwww 10yyyyyy 10zzzzzz`)**: The payload is `wwwwyyyyyyzzzzzz`.\n        - `val1 = data[i]  0x0F` (mask `$00001111_2$`)\n        - `val2 = data[i+1]  0x3F`\n        - `val3 = data[i+2]  0x3F`\n        - Code point: `(val1  12) | (val2  6) | val3`.\n        - Validation: Must not be overlong (code point $\\ge 0x800$). Must not be a surrogate (code point not in range $[0xD800, 0xDFFF]$).\n    - **4-byte sequence (`11110vvv 10wwwwww 10yyyyyy 10zzzzzz`)**: Payload `vvvwwwwwwyyyyyyzzzzzz`.\n        - `val1 = data[i]  0x07` (mask `$00000111_2$`)\n        - `val2 = data[i+1]  0x3F`\n        - `val3 = data[i+2]  0x3F`\n        - `val4 = data[i+3]  0x3F`\n        - Code point: `(val1  18) | (val2  12) | (val3  6) | val4`.\n        - Validation: Must not be overlong (code point $\\ge 0x10000$). Must be within the Unicode range (code point $\\le 0x10FFFF$).\n\n    If any validation check fails, the entire stream is declared invalid. If all checks for a sequence pass, the main index `i` is advanced by the number of bytes in that sequence (`T`), and processing continues from the next byte. If the loop completes successfully, having processed all bytes in the array, the stream is valid.",
            "answer": "```c\n#include stdio.h\n#include stdlib.h\n#include string.h\n#include math.h\n// Unused headers specified in the execution environment.\n// #include complex.h\n// #include threads.h\n// #include stdatomic.h\n\n/**\n * @brief Represents a test case for the UTF-8 validator.\n */\ntypedef struct {\n    const unsigned char* data; /** Pointer to the byte array. */\n    size_t size;               /** Size of the byte array. */\n} TestCase;\n\n/**\n * @brief Validates if a given byte array is a valid UTF-8 sequence.\n * \n * This function iterates through the byte array, validating each UTF-8 character\n * sequence based on its binary structure. It checks for correct lead and continuation\n * bytes, incomplete sequences, overlong encodings, surrogate code points, and\n * out-of-range code points, all using bitwise operations as required.\n *\n * @param data A pointer to the constant byte array to validate.\n * @param length The number of bytes in the array.\n * @return 1 if the data is a valid UTF-8 sequence, 0 otherwise.\n */\nint isValidUtf8(const unsigned char* data, size_t length) {\n    size_t i = 0;\n    while (i  length) {\n        unsigned char lead_byte = data[i];\n        int num_bytes = 0;\n        unsigned int code_point = 0;\n\n        // Determine the number of bytes in the sequence based on the lead byte.\n        if ((lead_byte  0x80) == 0x00) { // 0xxxxxxx (1-byte sequence)\n            num_bytes = 1;\n            code_point = lead_byte;\n        } else if ((lead_byte  0xE0) == 0xC0) { // 110xxxxx (2-byte sequence)\n            num_bytes = 2;\n        } else if ((lead_byte  0xF0) == 0xE0) { // 1110xxxx (3-byte sequence)\n            num_bytes = 3;\n        } else if ((lead_byte  0xF8) == 0xF0) { // 11110xxx (4-byte sequence)\n            num_bytes = 4;\n        } else {\n            // Invalid lead byte pattern (e.g., 10xxxxxx or 11111xxx).\n            return 0;\n        }\n\n        // A 1-byte sequence is always valid by an encoding standpoint.\n        if (num_bytes == 1) {\n            i += 1;\n            continue;\n        }\n\n        // Check for incomplete sequence: not enough bytes left in the array.\n        if (i + num_bytes  length) {\n            return 0;\n        }\n\n        // Verify that subsequent bytes are valid continuation bytes (10xxxxxx).\n        for (int j = 1; j  num_bytes; ++j) {\n            if ((data[i + j]  0xC0) != 0x80) {\n                return 0;\n            }\n        }\n        \n        // Reconstruct the code point from the byte sequence.\n        if (num_bytes == 2) {\n            code_point = ((data[i]  0x1F)  6) | (data[i + 1]  0x3F);\n            // Check for overlong encoding. Must be = 0x80.\n            if (code_point  0x80) return 0;\n        } else if (num_bytes == 3) {\n            code_point = ((data[i]  0x0F)  12) | ((data[i + 1]  0x3F)  6) | (data[i + 2]  0x3F);\n            // Check for overlong encoding. Must be = 0x800.\n            if (code_point  0x800) return 0;\n            // Check for surrogate code points. Must not be in [0xD800, 0xDFFF].\n            if (code_point = 0xD800  code_point = 0xDFFF) return 0;\n        } else if (num_bytes == 4) {\n            code_point = ((data[i]  0x07)  18) | ((data[i + 1]  0x3F)  12) | ((data[i + 2]  0x3F)  6) | (data[i + 3]  0x3F);\n            // Check for overlong encoding. Must be = 0x10000.\n            if (code_point  0x10000) return 0;\n            // Check for code points beyond the Unicode range. Must be = 0x10FFFF.\n            if (code_point  0x10FFFF) return 0;\n        }\n\n        i += num_bytes;\n    }\n    \n    // If the loop completes successfully, all bytes have been processed.\n    return 1;\n}\n\nint main(void) {\n    // Define byte arrays for each test case.\n    const unsigned char tc1_data[] = {0x48, 0x65, 0x6C, 0x6C, 0x6F};\n    const unsigned char tc2_data[] = {0xC3, 0xB1};\n    const unsigned char tc3_data[] = {0xE2, 0x82, 0xAC};\n    const unsigned char tc4_data[] = {0xF0, 0x90, 0x8D, 0x88};\n    const unsigned char tc5_data[] = {0xC0, 0x80};\n    const unsigned char tc6_data[] = {0xED, 0xA0, 0x80};\n    const unsigned char tc7_data[] = {0x80};\n    const unsigned char tc8_data[] = {0xE2, 0x82};\n    const unsigned char tc9_data[] = {0xF4, 0x8F, 0xBF, 0xBF};\n    const unsigned char tc10_data[] = {0xF4, 0x90, 0x80, 0x80};\n    const unsigned char tc11_data[] = {0xF8, 0x80, 0x80, 0x80, 0x80};\n    const unsigned char tc12_data[] = {0x41, 0x80};\n    const unsigned char tc13_data[] = {0xC2, 0x80};\n    const unsigned char tc14_data[] = {0xE0, 0xA0, 0x80};\n    const unsigned char tc15_data[] = {0xF0, 0x90, 0x80, 0x80};\n\n    // Define the test cases from the problem statement.\n    TestCase test_cases[] = {\n        {tc1_data, sizeof(tc1_data)},\n        {tc2_data, sizeof(tc2_data)},\n        {tc3_data, sizeof(tc3_data)},\n        {tc4_data, sizeof(tc4_data)},\n        {tc5_data, sizeof(tc5_data)},\n        {tc6_data, sizeof(tc6_data)},\n        {tc7_data, sizeof(tc7_data)},\n        {tc8_data, sizeof(tc8_data)},\n        {tc9_data, sizeof(tc9_data)},\n        {tc10_data, sizeof(tc10_data)},\n        {tc11_data, sizeof(tc11_data)},\n        {tc12_data, sizeof(tc12_data)},\n        {tc13_data, sizeof(tc13_data)},\n        {tc14_data, sizeof(tc14_data)},\n        {tc15_data, sizeof(tc15_data)},\n    };\n\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    int results[num_cases];\n\n    // Calculate the result for each test case.\n    for (int i = 0; i  num_cases; ++i) {\n        results[i] = isValidUtf8(test_cases[i].data, test_cases[i].size);\n    }\n    \n    // Print the results in the EXACT REQUIRED format before the final return statement.\n    printf(\"[\");\n    for (int i = 0; i  num_cases; ++i) {\n        printf(\"%d\", results[i]);\n        if (i  num_cases - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\\n\");\n\n    return EXIT_SUCCESS;\n}\n```"
        },
        {
            "introduction": "A correct algorithm is only the first step; a high-performance algorithm must be designed with the underlying architecture in mind. The variable-length nature of UTF-8 often leads to data-dependent branches, which can be challenging for a CPU's branch predictor. This exercise  asks you to develop a simple performance model to quantify this effect, calculating the expected cycles per byte for a validation loop based on the data mix and branch predictor accuracy. This is a classic example of architectural analysis, revealing the hidden performance costs in seemingly simple code.",
            "id": "3686860",
            "problem": "A developer is writing a loop to validate and count code points in a mixed-language buffer encoded in Unicode Transformation Format 8-bit (UTF-8). The buffer is of length $n$ bytes and contains a fraction $p$ of bytes that are United States Standard Code for Information Interchange (ASCII), i.e., bytes in the range $0$ through $127$, and a fraction $1-p$ of bytes belonging to multibyte UTF-8 sequences. The loop has a per-byte branch that directs execution to an ASCII fast-path or a multibyte slow-path. The processor is a two-wide superscalar Central Processing Unit (CPU) pipeline. When the branch is correctly predicted, the ASCII fast-path sustains $1$ cycle per byte, and the multibyte slow-path sustains $4$ cycles per byte. The branch predictor exhibits a misprediction rate $m$ on this per-byte branch, and each misprediction incurs a fixed control-hazard recovery cost of $b$ cycles (including pipeline flush and redirection). Assume the following:\n- Bytes are processed sequentially with one branch decision per byte.\n- The per-path costs $1$ and $4$ cycles per byte already reflect the two-wide pipeline’s capabilities for the corresponding steady-state path under correct prediction.\n- Mispredictions are independent across bytes and uniformly distributed at rate $m$ over the $n$ branch decisions.\n- Memory effects and cache misses are negligible, and there are no other bottlenecks.\n\nStarting only from the core facts that UTF-8 encodes ASCII as single-byte sequences and non-ASCII code points as multibyte sequences, and from the definitions of cycles per byte and branch misprediction cost, derive an analytic expression for the expected cycles per byte of this loop over the $n$-byte buffer as a function of $p$, $m$, and $b$. Your final answer must be a single closed-form expression. No rounding is required. Express the result in cycles per byte.",
            "solution": "The problem is valid as it is scientifically grounded in computer architecture principles, well-posed with sufficient information, and objectively stated. It presents a standard performance analysis scenario that can be formalized and solved mathematically.\n\nThe objective is to derive an analytic expression for the expected cycles per byte required to process an $n$-byte buffer. Let this quantity be denoted by $C_{avg}$.\n\nThe total number of cycles to process the buffer, $C_{total}$, is the sum of the cycle costs for each of the $n$ individual bytes. Let $C_i$ be the cycle cost for processing byte $i$. Then $C_{total} = \\sum_{i=1}^{n} C_i$.\nThe expected cycles per byte is the expectation of the total cycles divided by the number of bytes, $n$.\n$$C_{avg} = E\\left[\\frac{C_{total}}{n}\\right] = E\\left[\\frac{1}{n}\\sum_{i=1}^{n} C_i\\right]$$\nBy the linearity of expectation, this can be written as:\n$$C_{avg} = \\frac{1}{n}\\sum_{i=1}^{n} E[C_i]$$\nSince each byte is processed under the same statistical conditions (a fraction $p$ of bytes are ASCII and the misprediction rate $m$ is uniform), the expected cycle cost $E[C_i]$ is the same for all bytes. Let us denote this constant expected value as $E[C_{byte}]$. The expression for $C_{avg}$ simplifies to:\n$$C_{avg} = \\frac{1}{n} \\cdot n \\cdot E[C_{byte}] = E[C_{byte}]$$\nThus, our goal is to determine the expected cycle cost for processing a single, randomly selected byte.\n\nThe cycle cost for a single byte, $C_{byte}$, can be decomposed into two additive parts:\n$1$. The base execution cost, $C_{base}$, which depends on whether the byte is ASCII or part of a multibyte sequence. This is the cost under the assumption of correct branch prediction.\n$2$. The penalty cost, $C_{penalty}$, which is incurred only if the branch predictor mispredicts.\n\nSo, for any given byte, the total cost is $C_{byte} = C_{base} + C_{penalty}$.\nUsing the linearity of expectation again, the expected total cost per byte is the sum of the expected values of its components:\n$$E[C_{byte}] = E[C_{base}] + E[C_{penalty}]$$\nWe will now compute each of these expected values separately.\n\nFirst, we compute the expected base cost, $E[C_{base}]$. The problem states that a fraction $p$ of the bytes are ASCII, and a fraction $1-p$ belong to multibyte sequences.\n- If a byte is ASCII (which occurs with probability $p$), the execution follows the ASCII fast-path, and the base cost is $1$ cycle.\n- If a byte belongs to a multibyte sequence (which occurs with probability $1-p$), the execution follows the multibyte slow-path, and the base cost is $4$ cycles.\n\nThe expected base cost is the weighted average of these two costs, where the weights are their respective probabilities:\n$$E[C_{base}] = p \\cdot 1 + (1-p) \\cdot 4$$\n$$E[C_{base}] = p + 4 - 4p$$\n$$E[C_{base}] = 4 - 3p$$\n\nNext, we compute the expected penalty cost, $E[C_{penalty}]$.\nThe problem states that the branch predictor has a misprediction rate of $m$ and that mispredictions are uniformly distributed over all $n$ branch decisions. This implies that for any given byte, the probability of a branch misprediction is $m$.\n- A branch misprediction occurs with probability $m$. The cost incurred is the penalty of $b$ cycles.\n- The branch is correctly predicted with probability $1-m$, in which case the penalty cost is $0$.\n\nThe expected penalty cost per byte is:\n$$E[C_{penalty}] = m \\cdot b + (1-m) \\cdot 0$$\n$$E[C_{penalty}] = mb$$\n\nFinally, we find the total expected cycles per byte, $C_{avg}$, by summing the expected base cost and the expected penalty cost:\n$$C_{avg} = E[C_{byte}] = E[C_{base}] + E[C_{penalty}]$$\n$$C_{avg} = (4 - 3p) + mb$$\nThis expression represents the expected cycles per byte as a function of the fraction of ASCII bytes $p$, the branch misprediction rate $m$, and the misprediction penalty $b$.",
            "answer": "$$\\boxed{4 - 3p + mb}$$"
        },
        {
            "introduction": "To overcome the performance bottlenecks of serial, branching code, architects often turn to data parallelism. This advanced practice introduces the 'Single Instruction, Multiple Data within a Register' (SWAR) paradigm, a technique to process multiple bytes simultaneously using the wide registers available in modern CPUs. You will design a bit-parallel mask to detect overlong UTF-8 encodings across an entire 64-bit register in a single pass . This exercise showcases how a shift in thinking—from a serial, byte-at-a-time approach to a parallel one—can unlock significant performance gains.",
            "id": "3686815",
            "problem": "A $64$-bit register $X$ holds $8$ consecutive bytes from a Unicode Transformation Format (UTF-8) encoded stream. You are designing a Single Instruction, Multiple Data within a Register (SWAR) detector that flags the starting byte of any multibyte sequence whose numerical code point would be representable with fewer bytes (that is, an overlong encoding). Use the core definitions of UTF-8 structure and the numerical ranges of its canonical encodings as the foundational base.\n\nThe UTF-8 leading byte classes are defined by their high-bit patterns: one-byte sequences have leading byte $0\\mathrm{x}00$ to $0\\mathrm{x}7\\mathrm{F}$; two-byte sequences have leading byte $110xxxxx$; three-byte sequences have leading byte $1110xxxx$; four-byte sequences have leading byte $11110xxx$. Continuation bytes have the high-bit pattern $10xxxxxx$. Overlong encodings are those where the byte-length used exceeds the minimal number necessary to represent the code point value, based on the canonical UTF-8 ranges.\n\nDefine the byte-replication operator $\\mathrm{B}(c) \\equiv \\sum_{i=0}^{7} c \\ll 8i$, which places the constant byte $c$ into all $8$ lanes of a $64$-bit word. Define the per-byte equality mask operator $\\mathrm{eq}_{8}(A,B)$ to produce a $64$-bit result whose byte lanes are $0\\mathrm{x}\\mathrm{FF}$ where the corresponding lanes of $A$ and $B$ are equal and $0\\mathrm{x}00$ otherwise. You may rely on bitwise operations, shifts, and integer arithmetic to realize $\\mathrm{eq}_{8}$, but your final answer must give a closed-form mask expression in terms of $X$, shifts, bitwise operators, and $\\mathrm{B}(\\cdot)$ and $\\mathrm{eq}_{8}(\\cdot,\\cdot)$.\n\nConstruct a bit-parallel mask $M(X)$ that has byte lanes equal to $0\\mathrm{x}\\mathrm{FF}$ exactly at the starting byte of any $2$-byte overlong, $3$-byte overlong, or $4$-byte overlong sequence, and $0\\mathrm{x}00$ for all other lanes. The result must be derivable from the canonical UTF-8 constraints without assuming invalid sequences, except that you may depend on the immediate next byte when needed to determine potential overlongness for $3$-byte and $4$-byte sequences. Express your final mask $M(X)$ as a single closed-form analytic expression. No rounding is required, and no physical units apply.",
            "solution": "The problem is valid as it is scientifically grounded, well-posed, and objective. It poses a practical challenge in high-performance computing that can be solved analytically using the provided definitions.\n\nThe goal is to construct a bit-parallel mask $M(X)$ that identifies the starting byte of any overlong UTF-8 sequence within a $64$-bit register $X$. An overlong sequence uses more bytes than necessary to encode its code point. We must consider $2$-byte, $3$-byte, and $4$-byte sequences. The final mask will be the bitwise OR of the masks for each case:\n$M(X) = M_2(X) \\lor M_3(X) \\lor M_4(X)$\n\nWe will derive each component mask using the provided SWAR operators $\\mathrm{B}(c)$ and $\\mathrm{eq}_8(A, B)$.\n\n**1. Two-Byte Overlong Sequences ($M_2(X)$)**\nA $2$-byte sequence is overlong if it encodes a code point in the range $[U+0000, U+007F]$, which should be encoded as a single byte. This occurs if the leading byte is $0\\mathrm{xC}0$ or $0\\mathrm{xC}1$.\n- A leading byte of $0\\mathrm{xC}0$ (binary $11000000$) followed by a continuation byte in $[0\\mathrm{x}80, 0\\mathrm{xBF}]$ encodes a value in $[U+0000, U+003F]$.\n- A leading byte of $0\\mathrm{xC}1$ (binary $11000001$) followed by a continuation byte in $[0\\mathrm{x}80, 0\\mathrm{xBF}]$ encodes a value in $[U+0040, U+007F]$.\nThus, we need to flag any byte that is equal to $0\\mathrm{xC}0$ or $0\\mathrm{xC}1$. A compact way to test for both is to check if a byte $b$ satisfies $(b \\land 0\\mathrm{xFE}) = 0\\mathrm{xC}0$. This condition is true for $b=0\\mathrm{xC}0$ and $b=0\\mathrm{xC}1$, and false for all other valid $2$-byte lead bytes (which start from $0\\mathrm{xC}2$).\nIn SWAR, this becomes:\n$M_2(X) = \\mathrm{eq}_8(X \\land \\mathrm{B}(0\\mathrm{xFE}), \\mathrm{B}(0\\mathrm{xC}0))$\n\n**2. Three-Byte Overlong Sequences ($M_3(X)$)**\nA $3$-byte sequence is overlong if it encodes a code point in the range $[U+0000, U+07FF]$, which should have been encoded in one or two bytes. This occurs if the leading byte is $0\\mathrm{xE}0$ and the second byte is in the range $[0\\mathrm{x}80, 0\\mathrm{x}9\\mathrm{F}]$.\n- The condition on the first byte $b_1$ is $b_1 = 0\\mathrm{xE}0$. In SWAR: $\\mathrm{eq}_8(X, \\mathrm{B}(0\\mathrm{xE}0))$.\n- The condition on the second byte $b_2$ is $0\\mathrm{x}80 \\le b_2 \\le 0\\mathrm{x}9\\mathrm{F}$. This is equivalent to checking that the top three bits of $b_2$ are $100$, i.e., $(b_2 \\land 0\\mathrm{xE}0) = 0\\mathrm{x}80$.\nTo check this condition for the byte following a potential overlong leader, we look at the next byte lane. We can left-shift the register $X$ by $8$ bits to bring the next byte into the current byte's position. The check becomes: $\\mathrm{eq}_8((X \\ll 8) \\land \\mathrm{B}(0\\mathrm{xE}0), \\mathrm{B}(0\\mathrm{x}80))$.\nThe mask for a $3$-byte overlong sequence requires both conditions to be true for the same starting position, so we bitwise AND the two masks:\n$M_3(X) = \\mathrm{eq}_8(X, \\mathrm{B}(0\\mathrm{xE}0)) \\land \\mathrm{eq}_8((X \\ll 8) \\land \\mathrm{B}(0\\mathrm{xE}0), \\mathrm{B}(0\\mathrm{x}80))$\n\n**3. Four-Byte Overlong Sequences ($M_4(X)$)**\nA $4$-byte sequence is overlong if it encodes a code point in the range $[U+0000, U+FFFF]$, which should have been encoded in one, two, or three bytes. This occurs if the leading byte is $0\\mathrm{xF}0$ and the second byte is in the range $[0\\mathrm{x}80, 0\\mathrm{x}8\\mathrm{F}]$.\n- The condition on the first byte $b_1$ is $b_1 = 0\\mathrm{xF}0$. In SWAR: $\\mathrm{eq}_8(X, \\mathrm{B}(0\\mathrm{xF}0))$.\n- The condition on the second byte $b_2$ is $0\\mathrm{x}80 \\le b_2 \\le 0\\mathrm{x}8\\mathrm{F}$. This is equivalent to checking that the top four bits of $b_2$ are $1000$, i.e., $(b_2 \\land 0\\mathrm{xF}0) = 0\\mathrm{x}80$.\nIn SWAR, using the same shift technique as before, this check becomes: $\\mathrm{eq}_8((X \\ll 8) \\land \\mathrm{B}(0\\mathrm{xF}0), \\mathrm{B}(0\\mathrm{x}80))$.\nThe full mask for a $4$-byte overlong sequence is the AND of these two conditions:\n$M_4(X) = \\mathrm{eq}_8(X, \\mathrm{B}(0\\mathrm{xF}0)) \\land \\mathrm{eq}_8((X \\ll 8) \\land \\mathrm{B}(0\\mathrm{xF}0), \\mathrm{B}(0\\mathrm{x}80))$\n\n**Final Combined Mask**\nCombining the masks for all three cases with a bitwise OR gives the final expression for $M(X)$:\n$M(X) = M_2(X) \\lor M_3(X) \\lor M_4(X)$",
            "answer": "$$\n\\boxed{ \\mathrm{eq}_{8}(X \\land \\mathrm{B}(0\\mathrm{xFE}), \\mathrm{B}(0\\mathrm{xC}0)) \\lor \\left(\\mathrm{eq}_{8}(X, \\mathrm{B}(0\\mathrm{xE}0)) \\land \\mathrm{eq}_{8}((X \\ll 8) \\land \\mathrm{B}(0\\mathrm{xE}0), \\mathrm{B}(0\\mathrm{x}80))\\right) \\lor \\left(\\mathrm{eq}_{8}(X, \\mathrm{B}(0\\mathrm{xF}0)) \\land \\mathrm{eq}_{8}((X \\ll 8) \\land \\mathrm{B}(0\\mathrm{xF}0), \\mathrm{B}(0\\mathrm{x}80))\\right) }\n$$"
        }
    ]
}