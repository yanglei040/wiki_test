{
    "hands_on_practices": [
        {
            "introduction": "Before we can optimize, we must first ensure correctness. This foundational practice  challenges you to build a UTF-8 validator from the ground up, using only the fundamental bitwise operations that a processor itself would use. By manipulating bytes with bitmasks and shifts, you will develop a deep, first-principles understanding of how UTF-8's complex rules for multi-byte sequences, overlong encodings, and invalid code points are enforced at the lowest level of software.",
            "id": "3622809",
            "problem": "You are asked to design and implement a binary validator for Unicode Transformation Format-8 (UTF-8). The validator must rely on first principles of the binary number system, using binary positional representation and bitwise operations to classify bytes and to reconstruct code points. A byte consists of $8$ binary digits (bits), ordered with weights $2^7, 2^6, \\dots, 2^0$. A bit mask is a binary number used with bitwise logical operations to select specific subsets of bits; for example, the bitwise AND operation preserves a bit only where both operands have a $1$ in that position.\n\nUTF-8 encodes Unicode scalar values into sequences of one to four bytes. A leading byte encodes the sequence length by its most significant bit pattern, and continuation bytes use a fixed pattern. The validator must use binary masks to distinguish leading bytes from continuation bytes, and must reconstruct code points to detect invalid and overlong encodings. The foundational facts you may assume are:\n\n- The binary positional representation of integers and the properties of bitwise operations, including bitwise AND, bitwise OR, and bit shifting.\n- UTF-8 byte structure, described qualitatively by most significant bit patterns:\n  - Single-byte character: leading byte pattern $0xxxxxxx$.\n  - Two-byte sequence: leading byte pattern $110xxxxx$, followed by one continuation byte.\n  - Three-byte sequence: leading byte pattern $1110xxxx$, followed by two continuation bytes.\n  - Four-byte sequence: leading byte pattern $11110xxx$, followed by three continuation bytes.\n  - Continuation byte pattern $10xxxxxx$.\n- A valid reconstructed code point must satisfy $0 \\leq \\text{code point} \\leq 0x10FFFF$ and must not lie in the Unicode surrogate range $[0xD800, 0xDFFF]$.\n- A sequence must not be overlong: a sequence of $n$ bytes must not encode a value smaller than the minimal value representable by $n$ bytes, namely $0x80$ for $n=2$, $0x800$ for $n=3$, and $0x10000$ for $n=4$.\n\nYour program must:\n\n- For each test case, treat the data as a byte array and return $1$ if the entire array is a valid UTF-8 sequence and $0$ otherwise.\n- Derive and use binary masks that can identify continuation bytes and classify leading bytes into their sequence lengths.\n- Reconstruct the code point from the sequence using bit extraction and concatenation and verify all constraints from the fundamental base stated above.\n- Reject any stray continuation byte not preceded by an appropriate leading byte, any incomplete multibyte sequence, any $5$-byte or longer lead pattern, any overlong encoding, any surrogate code point, and any code point greater than $0x10FFFF$.\n\nTest suite to validate different facets of the solution:\n\n- Case $1$: ASCII string bytes $\\{0x48,0x65,0x6C,0x6C,0x6F\\}$.\n- Case $2$: Two-byte valid character $\\{0xC3,0xB1\\}$ (Latin small letter enye).\n- Case $3$: Three-byte valid character $\\{0xE2,0x82,0xAC\\}$ (Euro sign).\n- Case $4$: Four-byte valid character $\\{0xF0,0x90,0x8D,0x88\\}$ (Gothic letter hwair, code point $U+10348$).\n- Case $5$: Overlong encoding of $U+0000$: $\\{0xC0,0x80\\}$.\n- Case $6$: Surrogate code point encoded: $\\{0xED,0xA0,0x80\\}$ (represents $U+D800$).\n- Case $7$: Stray continuation byte: $\\{0x80\\}$.\n- Case $8$: Incomplete three-byte sequence: $\\{0xE2,0x82\\}$.\n- Case $9$: Largest valid code point $U+10FFFF$: $\\{0xF4,0x8F,0xBF,0xBF\\}$.\n- Case $10$: Code point beyond $U+10FFFF$: $\\{0xF4,0x90,0x80,0x80\\}$.\n- Case $11$: Invalid five-byte leading pattern: $\\{0xF8,0x80,0x80,0x80,0x80\\}$.\n- Case $12$: ASCII followed by stray continuation byte: $\\{0x41,0x80\\}$.\n- Case $13$: Minimal valid two-byte value $U+0080$: $\\{0xC2,0x80\\}$.\n- Case $14$: Minimal valid three-byte value $U+0800$: $\\{0xE0,0xA0,0x80\\}$.\n- Case $15$: Minimal valid four-byte value $U+10000$: $\\{0xF0,0x90,0x80,0x80\\}$.\n\nFinal output format:\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test cases above (e.g., $\\left[\\text{result}_1,\\text{result}_2,\\dots,\\text{result}_{15}\\right]$). Each result must be an integer $0$ or $1$ on that single line.",
            "solution": "The problem statement is subjected to validation before a solution is attempted.\n\n### Step 1: Extract Givens\n- **Domain**: Binary validator for Unicode Transformation Format-8 (UTF-8).\n- **Core Principles**: The validator must be based on the binary positional representation of numbers and bitwise operations.\n- **Byte Definition**: A byte consists of $8$ bits, with weights from $2^7$ (most significant bit, MSB) to $2^0$ (least significant bit, LSB).\n- **Bit Mask Definition**: A bit mask is a binary number used with bitwise logical operations to select specific subsets of bits.\n- **UTF-8 Byte Structures (Qualitative)**:\n    - Single-byte: $0xxxxxxx$\n    - Two-byte sequence: $110xxxxx$ followed by one continuation byte.\n    - Three-byte sequence: $1110xxxx$ followed by two continuation bytes.\n    - Four-byte sequence: $11110xxx$ followed by three continuation bytes.\n    - Continuation byte: $10xxxxxx$\n- **Validation Constraints**:\n    - A valid reconstructed code point must be in the range $[0, 0x10FFFF]$.\n    - A valid reconstructed code point must not be in the Unicode surrogate range $[0xD800, 0xDFFF]$.\n    - A sequence must not be overlong. Minimal values for multibyte sequences are:\n        - $n=2$ bytes: $0x80$\n        - $n=3$ bytes: $0x800$\n        - $n=4$ bytes: $0x10000$\n- **Program Requirements**:\n    - Input: A byte array for each test case.\n    - Output: Return $1$ if the entire array is a valid UTF-8 sequence, $0$ otherwise.\n    - The program must reject:\n        - Stray continuation bytes.\n        - Incomplete multibyte sequences.\n        - $5$-byte or longer lead patterns.\n        - Overlong encodings.\n        - Surrogate code points.\n        - Code points greater than $0x10FFFF$.\n- **Test Suite**: $15$ specific byte array test cases are provided to be validated.\n- **Final Output Format**: A single line containing a comma-separated list of integer results ($0$ or $1$) enclosed in square brackets, e.g., `[result_1,result_2,...,result_15]`.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is assessed against the established validation criteria.\n\n- **Scientifically Grounded**: The problem is firmly rooted in computer science, specifically in the standard definition of the UTF-8 encoding scheme (RFC 3629). All definitions and constraints (byte structure, code point ranges, surrogate blocks, overlong forms) are factually correct and consistent with established standards.\n- **Well-Posed**: The problem is well-posed. The inputs are clearly defined byte arrays, and the required output is a deterministic boolean classification ($1$ for valid, $0$ for invalid). The rules provided are sufficient and unambiguous, leading to a unique and meaningful solution for any given byte stream.\n- **Objective**: The language is precise and technical. It avoids subjectivity, ambiguity, and opinion. All terms are either standard in computer organization and architecture or are explicitly defined.\n\nThe problem does not exhibit any of the listed invalidity flaws. It is a formal, self-contained, and verifiable problem based on fundamental principles of digital logic and data encoding.\n\n### Step 3: Verdict and Action\nThe problem is deemed **valid**. A solution will be developed based on the provided specifications.\n\n### Solution Derivation\n\nThe design of a UTF-8 validator from first principles requires a systematic, state-based traversal of the input byte stream. Each byte must be classified, and the integrity of the sequence it belongs to must be verified. This process relies on bitwise operations to inspect the binary structure of each byte. An $8$-bit byte will be represented as an `unsigned char` in the implementation to prevent sign-extension artifacts during bitwise manipulation.\n\nWe begin by formalizing the byte patterns using binary masks. A bitwise AND operation (`&`) between a byte and a mask allows us to isolate and test a specific group of bits.\n\n1.  **Byte Classification Using Bitmasks**:\n    The most significant bits of a byte determine its role in a UTF-8 sequence. We can derive masks to identify each type of byte:\n    - **Single-byte (ASCII)**: The pattern is $0xxxxxxx$. The most significant bit must be $0$. We test this by masking with $10000000_2$ (or $0x80$). A byte `b` is a single-byte character if `(b  0x80) == 0x00`.\n    - **Continuation Byte**: The pattern is $10xxxxxx$. The two most significant bits must be $10$. We test this by masking with $11000000_2$ (or $0xC0$) and comparing the result to $10000000_2$ (or $0x80$). A byte `b` is a continuation byte if `(b  0xC0) == 0x80`.\n    - **Two-byte Lead Byte**: The pattern is $110xxxxx$. The three most significant bits must be $110$. The mask is $11100000_2$ (or $0xE0$), and the expected result is $11000000_2$ (or $0xC0$). The condition is `(b  0xE0) == 0xC0`.\n    - **Three-byte Lead Byte**: The pattern is $1110xxxx$. The four most significant bits must be $1110$. The mask is $11110000_2$ (or $0xF0$), and the expected result is $11100000_2$ (or $0xE0$). The condition is `(b  0xF0) == 0xE0`.\n    - **Four-byte Lead Byte**: The pattern is $11110xxx$. The five most significant bits must be $11110$. The mask is $11111000_2$ (or $0xF8$), and the expected result is $11110000_2$ (or $0xF0$). The condition is `(b  0xF8) == 0xF0`.\n    - **Invalid Bytes**: Any byte that does not match one of the above patterns is invalid as a starting byte. This includes stray continuation bytes (already covered) and bytes with patterns like $11111xxx$ (e.g., $0xF8$, $0xFC$), which were part of obsolete $5$- and $6$-byte UTF-8 specifications.\n\n2.  **Stateful Processing Algorithm**:\n    The validator will iterate through the byte array. The state at any point is determined by the number of continuation bytes expected.\n    - Let `i` be the index into the byte array of length `L`. The loop proceeds as long as `i  L`.\n    - At index `i`, read the byte `b = data[i]`.\n    - Classify `b` as a lead byte. Based on its type, determine the expected number of subsequent continuation bytes, `n_cont`.\n        - If `(b  0x80) == 0x00`, it's a $1$-byte sequence. `n_cont = 0`. The sequence length is $1$.\n        - If `(b  0xE0) == 0xC0`, it's a $2$-byte sequence. `n_cont = 1`. The sequence length is $2$.\n        - If `(b  0xF0) == 0xE0`, it's a $3$-byte sequence. `n_cont = 2`. The sequence length is $3$.\n        - If `(b  0xF8) == 0xF0`, it's a $4$-byte sequence. `n_cont = 3`. The sequence length is $4$.\n        - Otherwise, the byte `b` is an invalid starting byte (e.g., a stray continuation byte or an invalid pattern like $0xF8$). The entire stream is invalid.\n    - Upon identifying a lead byte for a multi-byte sequence of total length `T = n_cont + 1`:\n        - **Check for Incomplete Sequence**: Verify that there are enough bytes remaining in the array. We must have `i + T = L`. If not, the sequence is incomplete and thus invalid.\n        - **Verify Continuation Bytes**: For each of the `n_cont` subsequent bytes `data[i+j]` where `j` is from $1$ to `n_cont`, verify that `(data[i+j]  0xC0) == 0x80`. If any byte fails this test, the sequence is invalid.\n\n3.  **Code Point Reconstruction and Validation**:\n    After confirming the structural integrity of a byte sequence, the Unicode code point must be reconstructed and validated. This involves extracting the payload bits from each byte and concatenating them.\n    - Payload bits are extracted by masking the data-carrying portions of the bytes.\n    - **1-byte sequence ($0xxxxxxx$)**: The code point is the byte value itself. No further validation is needed as its value is less than $0x80$. Code point: `data[i]`.\n    - **2-byte sequence ($110yyyyy 10zzzzzz$)**: The payload is `yyyyyzzzzzz`.\n        - `val1 = data[i]  0x1F` (mask $00011111_2$)\n        - `val2 = data[i+1]  0x3F` (mask $00111111_2$)\n        - Code point: `(val1  6) | val2`.\n        - Validation: Must not be overlong. The code point must be $\\ge 0x80$.\n    - **3-byte sequence ($1110wwww 10yyyyyy 10zzzzzz$)**: The payload is `wwwwyyyyyyzzzzzz`.\n        - `val1 = data[i]  0x0F` (mask $00001111_2$)\n        - `val2 = data[i+1]  0x3F`\n        - `val3 = data[i+2]  0x3F`\n        - Code point: `(val1  12) | (val2  6) | val3`.\n        - Validation: Must not be overlong (code point $\\ge 0x800$). Must not be a surrogate (code point not in range $[0xD800, 0xDFFF]$).\n    - **4-byte sequence ($11110vvv 10wwwwww 10yyyyyy 10zzzzzz$)**: Payload `vvvwwwwwwyyyyyyzzzzzz`.\n        - `val1 = data[i]  0x07` (mask $00000111_2$)\n        - `val2 = data[i+1]  0x3F`\n        - `val3 = data[i+2]  0x3F`\n        - `val4 = data[i+3]  0x3F`\n        - Code point: `(val1  18) | (val2  12) | (val3  6) | val4`.\n        - Validation: Must not be overlong (code point $\\ge 0x10000$). Must be within the Unicode range (code point $\\le 0x10FFFF$).\n\n    If any validation check fails, the entire stream is declared invalid. If all checks for a sequence pass, the main index `i` is advanced by the number of bytes in that sequence (`T`), and processing continues from the next byte. If the loop completes successfully, having processed all bytes in the array, the stream is valid.",
            "answer": "```c\n#include stdio.h\n#include stdlib.h\n#include string.h\n#include math.h\n// Unused headers specified in the execution environment.\n// #include complex.h\n// #include threads.h\n// #include stdatomic.h\n\n/**\n * @brief Represents a test case for the UTF-8 validator.\n */\ntypedef struct {\n    const unsigned char* data; /** Pointer to the byte array. */\n    size_t size;               /** Size of the byte array. */\n} TestCase;\n\n/**\n * @brief Validates if a given byte array is a valid UTF-8 sequence.\n * \n * This function iterates through the byte array, validating each UTF-8 character\n * sequence based on its binary structure. It checks for correct lead and continuation\n * bytes, incomplete sequences, overlong encodings, surrogate code points, and\n * out-of-range code points, all using bitwise operations as required.\n *\n * @param data A pointer to the constant byte array to validate.\n * @param length The number of bytes in the array.\n * @return 1 if the data is a valid UTF-8 sequence, 0 otherwise.\n */\nint isValidUtf8(const unsigned char* data, size_t length) {\n    size_t i = 0;\n    while (i  length) {\n        unsigned char lead_byte = data[i];\n        int num_bytes = 0;\n        unsigned int code_point = 0;\n\n        // Determine the number of bytes in the sequence based on the lead byte.\n        if ((lead_byte  0x80) == 0x00) { // 0xxxxxxx (1-byte sequence)\n            num_bytes = 1;\n            code_point = lead_byte;\n        } else if ((lead_byte  0xE0) == 0xC0) { // 110xxxxx (2-byte sequence)\n            num_bytes = 2;\n        } else if ((lead_byte  0xF0) == 0xE0) { // 1110xxxx (3-byte sequence)\n            num_bytes = 3;\n        } else if ((lead_byte  0xF8) == 0xF0) { // 11110xxx (4-byte sequence)\n            num_bytes = 4;\n        } else {\n            // Invalid lead byte pattern (e.g., 10xxxxxx or 11111xxx).\n            return 0;\n        }\n\n        // A 1-byte sequence is always valid by an encoding standpoint.\n        if (num_bytes == 1) {\n            i += 1;\n            continue;\n        }\n\n        // Check for incomplete sequence: not enough bytes left in the array.\n        if (i + num_bytes  length) {\n            return 0;\n        }\n\n        // Verify that subsequent bytes are valid continuation bytes (10xxxxxx).\n        for (int j = 1; j  num_bytes; ++j) {\n            if ((data[i + j]  0xC0) != 0x80) {\n                return 0;\n            }\n        }\n        \n        // Reconstruct the code point from the byte sequence.\n        if (num_bytes == 2) {\n            code_point = ((data[i]  0x1F)  6) | (data[i + 1]  0x3F);\n            // Check for overlong encoding. Must be = 0x80.\n            if (code_point  0x80) return 0;\n        } else if (num_bytes == 3) {\n            code_point = ((data[i]  0x0F)  12) | ((data[i + 1]  0x3F)  6) | (data[i + 2]  0x3F);\n            // Check for overlong encoding. Must be = 0x800.\n            if (code_point  0x800) return 0;\n            // Check for surrogate code points. Must not be in [0xD800, 0xDFFF].\n            if (code_point = 0xD800  code_point = 0xDFFF) return 0;\n        } else if (num_bytes == 4) {\n            code_point = ((data[i]  0x07)  18) | ((data[i + 1]  0x3F)  12) | ((data[i + 2]  0x3F)  6) | (data[i + 3]  0x3F);\n            // Check for overlong encoding. Must be = 0x10000.\n            if (code_point  0x10000) return 0;\n            // Check for code points beyond the Unicode range. Must be = 0x10FFFF.\n            if (code_point  0x10FFFF) return 0;\n        }\n\n        i += num_bytes;\n    }\n    \n    // If the loop completes successfully, all bytes have been processed.\n    return 1;\n}\n\nint main(void) {\n    // Define byte arrays for each test case.\n    const unsigned char tc1_data[] = {0x48, 0x65, 0x6C, 0x6C, 0x6F};\n    const unsigned char tc2_data[] = {0xC3, 0xB1};\n    const unsigned char tc3_data[] = {0xE2, 0x82, 0xAC};\n    const unsigned char tc4_data[] = {0xF0, 0x90, 0x8D, 0x88};\n    const unsigned char tc5_data[] = {0xC0, 0x80};\n    const unsigned char tc6_data[] = {0xED, 0xA0, 0x80};\n    const unsigned char tc7_data[] = {0x80};\n    const unsigned char tc8_data[] = {0xE2, 0x82};\n    const unsigned char tc9_data[] = {0xF4, 0x8F, 0xBF, 0xBF};\n    const unsigned char tc10_data[] = {0xF4, 0x90, 0x80, 0x80};\n    const unsigned char tc11_data[] = {0xF8, 0x80, 0x80, 0x80, 0x80};\n    const unsigned char tc12_data[] = {0x41, 0x80};\n    const unsigned char tc13_data[] = {0xC2, 0x80};\n    const unsigned char tc14_data[] = {0xE0, 0xA0, 0x80};\n    const unsigned char tc15_data[] = {0xF0, 0x90, 0x80, 0x80};\n\n    // Define the test cases from the problem statement.\n    TestCase test_cases[] = {\n        {tc1_data, sizeof(tc1_data)},\n        {tc2_data, sizeof(tc2_data)},\n        {tc3_data, sizeof(tc3_data)},\n        {tc4_data, sizeof(tc4_data)},\n        {tc5_data, sizeof(tc5_data)},\n        {tc6_data, sizeof(tc6_data)},\n        {tc7_data, sizeof(tc7_data)},\n        {tc8_data, sizeof(tc8_data)},\n        {tc9_data, sizeof(tc9_data)},\n        {tc10_data, sizeof(tc10_data)},\n        {tc11_data, sizeof(tc11_data)},\n        {tc12_data, sizeof(tc12_data)},\n        {tc13_data, sizeof(tc13_data)},\n        {tc14_data, sizeof(tc14_data)},\n        {tc15_data, sizeof(tc15_data)},\n    };\n\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    int results[num_cases];\n\n    // Calculate the result for each test case.\n    for (int i = 0; i  num_cases; ++i) {\n        results[i] = isValidUtf8(test_cases[i].data, test_cases[i].size);\n    }\n    \n    // Print the results in the EXACT REQUIRED format before the final return statement.\n    printf(\"[\");\n    for (int i = 0; i  num_cases; ++i) {\n        printf(\"%d\", results[i]);\n        if (i  num_cases - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\\n\");\n\n    return EXIT_SUCCESS;\n}\n```"
        },
        {
            "introduction": "With a correct validator in mind, we now turn our focus to performance. This exercise  explores a critical trade-off in modern superscalar processors: the choice between control flow (conditional branches) and data flow (branchless conditional operations). You will analyze how this architectural decision dramatically impacts performance, learning why a branch-heavy implementation that is fast for predictable data, like ASCII-heavy text, can become a significant bottleneck when faced with the unpredictable byte patterns of mixed-language text.",
            "id": "3686835",
            "problem": "You are implementing a high-throughput validator for the 8-bit Unicode Transformation Format (UTF-8) on a modern x86-64 Central Processing Unit (CPU). The validator must conform to Request for Comments (RFC) $3629$, which restricts valid Unicode scalar values to a maximum code point of $10\\,\\!FFFF_{16}$ and disallows encodings that are longer than necessary (no overlong encodings). The Instruction Set Architecture (ISA) provides both conditional branches and data-movement without branching, such as Conditional Move (CMOV) and condition-code set (SETcc) instructions.\n\nFundamental base and facts:\n- UTF-8 leading byte classes are defined by the high-order bit patterns: $0xxxxxxx$ (single-byte), $110xxxxx$ (two-byte), $1110xxxx$ (three-byte), and $11110xxx$ (four-byte). Patterns corresponding to five- and six-byte encodings ($111110xx$ and $1111110x$) are disallowed under RFC $3629$.\n- The valid leading-byte range for multibyte sequences is constrained by two facts: overlong two-byte headers $0xC0$ and $0xC1$ are invalid, and four-byte headers above $0xF4$ would encode code points beyond $10\\,\\!FFFF_{16}$, hence are invalid. Therefore, for multibyte leaders, the only valid leading-byte range is $[0xC2, 0xF4]$ inclusive.\n- Continuation bytes always have the pattern $10xxxxxx$ (i.e., range $[0x80, 0xBF]$), and single-byte ASCII is $[0x00, 0x7F]$.\n\nYou are considering a simple range check to detect invalid five- and six-byte start patterns and also to catch the invalid two-byte leaders $0xC0$ and $0xC1$. You also need to choose between a control-flow implementation using a conditional branch and a data-flow implementation using CMOV or SETcc operations.\n\nWhich of the following statements are correct?\n\nA. The predicate $p \\equiv (b \\le 0xC1) \\lor (b \\ge 0xF5)$, evaluated only for bytes with $b \\ge 0xC0$ (that is, only for potential multibyte leaders), exactly flags bytes that cannot start any valid multibyte UTF-8 sequence under RFC $3629$.\n\nB. On long inputs dominated by $b  0x80$ bytes, replacing a branch with a Conditional Move (CMOV) to accumulate an error flag generally improves performance because it removes the branch, which would otherwise be often mispredicted.\n\nC. A branchless implementation of $p$ using two compare-and-set operations (SETcc) followed by a bitwise OR introduces no control-flow and thus avoids branch misprediction penalties; on modern out-of-order cores, its throughput is typically superior to a branchy version when $b$ is unpredictable or adversarially distributed.\n\nD. The correct upper bound for valid leading bytes in modern UTF-8 is $0xF7$, so using $b \\ge 0xF8$ to reject longer starters is sufficient in modern UTF-8.",
            "solution": "The problem statement is critically evaluated for validity prior to attempting a solution.\n\n### Step 1: Extract Givens\n-   **Topic**: High-throughput validator for the $8$-bit Unicode Transformation Format (UTF-8).\n-   **Platform**: Modern $\\text{x86-64}$ Central Processing Unit (CPU).\n-   **Standard**: Request for Comments (RFC) $3629$.\n-   **Constraints from RFC $3629$**:\n    -   Maximum Unicode scalar value (code point) is $10\\,\\!FFFF_{16}$.\n    -   Overlong encodings are disallowed.\n    -   Five- and six-byte encodings (starters $111110xx$ and $1111110x$) are disallowed.\n-   **ISA Features**: Conditional branches and branchless data-movement instructions ($\\text{CMOV}$, $\\text{SETcc}$).\n-   **UTF-8 Byte Definitions**:\n    -   Single-byte (ASCII): $0xxxxxxx$, range [$0x00$, $0x7F$].\n    -   Two-byte leader: $110xxxxx$.\n    -   Three-byte leader: $1110xxxx$.\n    -   Four-byte leader: $11110xxx$.\n    -   Continuation byte: $10xxxxxx$, range [$0x80$, $0xBF$].\n-   **Invalid Leader Bytes (deduced from constraints)**:\n    -   Overlong two-byte headers $0xC0$ and $0xC1$ are invalid.\n    -   Four-byte headers above $0xF4$ are invalid.\n-   **Valid Multibyte Leader Range**: [$0xC2$, $0xF4$] inclusive.\n-   **Question**: Evaluate the correctness of four statements regarding a validation predicate and implementation strategies.\n\n### Step 2: Validate Using Extracted Givens\nThe problem statement is analyzed for validity.\n\n-   **Scientifically Grounded**: The problem is based on the official specification for UTF-8 as defined in RFC $3629$. All byte ranges, bit patterns, and constraints (e.g., maximum code point $10\\,\\!FFFF_{16}$, rejection of overlong forms, invalidity of $0xC0, 0xC1, \\ge 0xF5$) are factually correct and consistent with this standard. The description of modern $\\text{x86-64}$ CPU features (branch prediction, $\\text{CMOV}$, $\\text{SETcc}$) is accurate in the context of performance optimization.\n-   **Well-Posed**: The problem presents a clear set of facts and asks for an evaluation of specific, formalizable statements based on these facts. A unique set of correct/incorrect verdicts for the options can be determined.\n-   **Objective**: The language is technical, precise, and free of subjective or ambiguous terminology. \"Modern UTF-8\" is properly contextualized by the explicit reference to RFC $3629$.\n\nThe problem is free from the flaws listed in the validation criteria (e.g., it is not unsound, incomplete, contradictory, or ill-posed). All information provided is consistent and sufficient for a rigorous analysis.\n\n### Step 3: Verdict and Action\nThe problem statement is **valid**. A solution will be derived by analyzing each option.\n\n### Solution Derivation\n\nThe analysis proceeds by evaluating each statement based on the provided facts of UTF-8 encoding (per RFC $3629$) and computer architecture principles.\n\n#### Analysis of Option A\n\nStatement A proposes the predicate $p \\equiv (b \\le 0xC1) \\lor (b \\ge 0xF5)$, to be evaluated for bytes $b$ that are potential multibyte leaders (i.e., $b \\ge 0xC0$), to flag invalid starter bytes.\n\n1.  **Identify Valid Multibyte Leaders**: As stated in the problem, a byte $b$ is a valid multibyte sequence leader under RFC $3629$ if and only if $b \\in [0xC2, 0xF4]$.\n2.  **Identify Invalid Multibyte Leaders**: Consequently, a byte $b$ cannot start a valid multibyte sequence if it falls outside this range. The problem specifies we are only considering bytes where $b \\ge 0xC0$. The full range of byte values is [$0x00$, $0xFF$]. Potential multibyte leaders are in the range [$0xC0$, $0xFF$]. Therefore, an invalid starter byte $b$ must satisfy $b \\in [0xC0, 0xFF]$ and $b \\notin [0xC2, 0xF4]$.\n3.  **Deconstruct the Invalid Range**: The set of invalid leaders is the union of two disjoint sets:\n    -   Bytes below the valid range: $\\{ b \\mid b \\ge 0xC0 \\text{ and } b  0xC2 \\}$. This corresponds to the set $\\{0xC0, 0xC1\\}$. These are invalid because they would form overlong encodings.\n    -   Bytes above the valid range: $\\{ b \\mid b  0xF4 \\}$. This corresponds to the range [$0xF5$, $0xFF$]. Bytes in [$0xF5$, $0xF7$] are invalid because they would encode code points greater than the maximum of $10\\,\\!FFFF_{16}$. Bytes in [$0xF8$, $0xFF$] are invalid because they correspond to the disallowed five- and six-byte sequences.\n4.  **Evaluate the Predicate**: The proposed predicate is $p \\equiv (b \\le 0xC1) \\lor (b \\ge 0xF5)$. We evaluate this under the given condition that $b \\ge 0xC0$.\n    -   The first part, $b \\le 0xC1$, combined with $b \\ge 0xC0$, is true if and only if $b \\in \\{0xC0, 0xC1\\}$.\n    -   The second part, $b \\ge 0xF5$, is disjoint from the first and covers all bytes from $0xF5$ to $0xFF$.\n    -   The logical OR ($\\lor$) of these two conditions gives a predicate that is true for any byte $b$ in the set $\\{0xC0, 0xC1\\} \\cup [0xF5, 0xFF]$.\n5.  **Conclusion**: This set exactly matches the set of bytes that cannot start a valid multibyte UTF-8 sequence, as derived in step 3. The predicate is therefore a correct and exact test for this specific invalidity condition.\n\n**Verdict**: Correct.\n\n#### Analysis of Option B\n\nStatement B claims that for input dominated by ASCII characters ($b  0x80$), replacing a conditional branch with a $\\text{CMOV}$ instruction improves performance because the branch would be \"often mispredicted.\"\n\n1.  **Branch Predictor Behavior**: Modern CPUs employ sophisticated branch prediction hardware. For a data stream where one outcome of a branch is heavily favored, the predictor will quickly learn this pattern.\n2.  **Scenario Analysis**: The scenario is input dominated by bytes with $b  0x80$. A UTF-8 validator would typically have a conditional branch that checks for non-ASCII bytes to handle multibyte logic, e.g., `if (b = 0x80) { ... }`.\n3.  **Prediction Accuracy**: In this scenario, the condition `b = 0x80` would be false for the vast majority of bytes. The branch would be \"not taken\" with very high frequency. The branch predictor will achieve a very high prediction accuracy (near $100\\%$).\n4.  **Cost of Branch vs. $\\text{CMOV}$**: A correctly predicted branch has a very low cost on a modern out-of-order core, often executing in effectively zero cycles as it does not stall the pipeline. A branch misprediction, however, is very costly (e.g., $10-20$ cycles) as it requires flushing the pipeline. The key point is that mispredictions will be rare in this predictable data stream. A $\\text{CMOV}$ instruction, while avoiding the *risk* of a misprediction penalty, is not free. It consumes execution resources and introduces a data dependency on the condition flags from a comparison, which can constrain instruction-level parallelism.\n5.  **Performance Comparison**: Because the branch is highly predictable, the average cost of the branch-based implementation will be very low. The high cost of a misprediction is paid so infrequently that its contribution to the average execution time is minimal. In contrast, the branchless version with $\\text{CMOV}$ has a constant, but non-zero, cost for every byte. For highly predictable branching patterns, the branchy code is typically faster than the branchless equivalent.\n6.  **Conclusion**: The statement's premise that the branch would be \"often mispredicted\" is false for the described scenario. Consequently, its conclusion that a $\\text{CMOV}$ would improve performance is unfounded.\n\n**Verdict**: Incorrect.\n\n#### Analysis of Option C\n\nStatement C argues that a branchless implementation using $\\text{SETcc}$ is superior to a branchy one when the byte value $b$ is unpredictable.\n\n1.  **Branchless Implementation**: The predicate $p \\equiv (b \\le 0xC1) \\lor (b \\ge 0xF5)$ can be implemented without branches using $\\text{SETcc}$ instructions. For example:\n    -   `CMP b, 0xC1`\n    -   `SETLE reg1` (Set `reg1` to $1$ if $b \\le 0xC1$, else $0$)\n    -   `CMP b, 0xF5`\n    -   `SETGE reg2` (Set `reg2` to $1$ if $b \\ge 0xF5$, else $0$)\n    -   `OR reg1, reg2` (The result is $1$ if the predicate is true, $0$ otherwise)\n    This creates a fixed sequence of instructions with no control-flow changes.\n2.  **Scenario Analysis**: The scenario is an \"unpredictable or adversarially distributed\" stream of bytes. In this case, the outcome of a conditional branch `if (predicate(b))` would be random.\n3.  **Branch Prediction Failure**: A branch predictor cannot find a pattern in random data. Its prediction accuracy will be approximately $50\\%$. This means roughly every other branch instruction will cause a costly pipeline flush due to a misprediction. The average execution time per byte for the branchy implementation will be high and variable.\n4.  **Performance of Branchless Code**: The branchless $\\text{SETcc}$ implementation has a constant execution time (latency). It consists of a few simple integer and logical operations. On an out-of-order core, these can be executed with high throughput. Crucially, its performance is independent of the data distribution and does not suffer from misprediction penalties.\n5.  **Conclusion**: When branch prediction is ineffective, the large, fixed penalty of a misprediction dominates performance. The branchless implementation provides a lower and, importantly, more consistent (higher) throughput by trading the unpredictable control hazard for a predictable data dependency. The statement accurately describes this fundamental performance trade-off in modern CPUs.\n\n**Verdict**: Correct.\n\n#### Analysis of Option D\n\nStatement D asserts that the correct upper bound for valid leading bytes is $0xF7$ and that checking for $b \\ge 0xF8$ is a sufficient rejection test.\n\n1.  **Maximum Code Point**: As stated in the problem, RFC $3629$ limits Unicode to the range $U+0000$ to $U+10FFFF$.\n2.  **Encoding of $U+10FFFF$**: A four-byte sequence has the form $11110xxx$ $10yyyyyy$ $10zzzzzz$ $10wwwwww$, encoding a $21$-bit value. As calculated during validation, the code point $U+10FFFF$ ($100001111111111111111_2$) is encoded by the byte sequence $0xF4$ $0x8F$ $0xBF$ $0xBF$.\n3.  **Analysis of Higher Leading Bytes**:\n    -   Any sequence starting with a leader byte of $0xF4$ can encode code points up to $U+10FFFF$. For example, the sequence $0xF4$ $0x80$ $0x80$ $0x80$ encodes $U+100000$.\n    -   Let's find the minimum code point encoded by a sequence starting with $0xF5$ ($11110101_2$). The minimal sequence is $0xF5$ $0x80$ $0x80$ $0x80$. This encodes the value represented by the bits `101` (from $0xF5$) followed by three blocks of `000000`. The resulting $21$-bit value is $101000000000000000000_2$, which is $0x140000$.\n    -   Since $0x140000  0x10FFFF$, any sequence beginning with $0xF5$ is invalid. By extension, any sequence beginning with $0xF6$ or $0xF7$ is also invalid as it would encode an even larger code point.\n4.  **Conclusion on Upper Bound**: The highest valid leading byte for a multibyte sequence is $0xF4$. The statement that the upper bound is $0xF7$ is factually incorrect.\n5.  **Conclusion on Sufficiency of Test**: The statement proposes that checking for $b \\ge 0xF8$ is sufficient to reject \"longer starters\". This test would correctly reject the five- and six-byte starter bytes ($[0xF8, 0xFD]$). However, it is *insufficient* because it fails to reject the invalid four-byte starter bytes $0xF5$, $0xF6$, and $0xF7$. The correct rejection test for bytes above the valid range is $b \\ge 0xF5$.\n\n**Verdict**: Incorrect.",
            "answer": "$$\\boxed{AC}$$"
        },
        {
            "introduction": "To make informed design decisions, architects and performance engineers rely on simple but powerful mathematical models. This final practice  asks you to build such a model, moving from a qualitative understanding of performance to a quantitative prediction. By deriving a closed-form expression for the expected cycles per byte, you will learn to precisely calculate the performance impact of data characteristics, such as the fraction of ASCII characters $p$, and architectural parameters, like the branch misprediction rate $m$ and penalty $b$.",
            "id": "3686860",
            "problem": "A developer is writing a loop to validate and count code points in a mixed-language buffer encoded in Unicode Transformation Format 8-bit (UTF-8). The buffer is of length $n$ bytes and contains a fraction $p$ of bytes that are United States Standard Code for Information Interchange (ASCII), i.e., bytes in the range $0$ through $127$, and a fraction $1-p$ of bytes belonging to multibyte UTF-8 sequences. The loop has a per-byte branch that directs execution to an ASCII fast-path or a multibyte slow-path. The processor is a two-wide superscalar Central Processing Unit (CPU) pipeline. When the branch is correctly predicted, the ASCII fast-path sustains $1$ cycle per byte, and the multibyte slow-path sustains $4$ cycles per byte. The branch predictor exhibits a misprediction rate $m$ on this per-byte branch, and each misprediction incurs a fixed control-hazard recovery cost of $b$ cycles (including pipeline flush and redirection). Assume the following:\n- Bytes are processed sequentially with one branch decision per byte.\n- The per-path costs $1$ and $4$ cycles per byte already reflect the two-wide pipelineâ€™s capabilities for the corresponding steady-state path under correct prediction.\n- Mispredictions are independent across bytes and uniformly distributed at rate $m$ over the $n$ branch decisions.\n- Memory effects and cache misses are negligible, and there are no other bottlenecks.\n\nStarting only from the core facts that UTF-8 encodes ASCII as single-byte sequences and non-ASCII code points as multibyte sequences, and from the definitions of cycles per byte and branch misprediction cost, derive an analytic expression for the expected cycles per byte of this loop over the $n$-byte buffer as a function of $p$, $m$, and $b$. Your final answer must be a single closed-form expression. No rounding is required. Express the result in cycles per byte.",
            "solution": "The problem is valid as it is scientifically grounded in computer architecture principles, well-posed with sufficient information, and objectively stated. It presents a standard performance analysis scenario that can be formalized and solved mathematically.\n\nThe objective is to derive an analytic expression for the expected cycles per byte required to process an $n$-byte buffer. Let this quantity be denoted by $C_{avg}$.\n\nThe total number of cycles to process the buffer, $C_{total}$, is the sum of the cycle costs for each of the $n$ individual bytes. Let $C_i$ be the cycle cost for processing byte $i$. Then $C_{total} = \\sum_{i=1}^{n} C_i$.\nThe expected cycles per byte is the expectation of the total cycles divided by the number of bytes, $n$.\n$$C_{avg} = E\\left[\\frac{C_{total}}{n}\\right] = E\\left[\\frac{1}{n}\\sum_{i=1}^{n} C_i\\right]$$\nBy the linearity of expectation, this can be written as:\n$$C_{avg} = \\frac{1}{n}\\sum_{i=1}^{n} E[C_i]$$\nSince each byte is processed under the same statistical conditions (a fraction $p$ of bytes are ASCII and the misprediction rate $m$ is uniform), the expected cycle cost $E[C_i]$ is the same for all bytes. Let us denote this constant expected value as $E[C_{byte}]$. The expression for $C_{avg}$ simplifies to:\n$$C_{avg} = \\frac{1}{n} \\cdot n \\cdot E[C_{byte}] = E[C_{byte}]$$\nThus, our goal is to determine the expected cycle cost for processing a single, randomly selected byte.\n\nThe cycle cost for a single byte, $C_{byte}$, can be decomposed into two additive parts:\n$1$. The base execution cost, $C_{base}$, which depends on whether the byte is ASCII or part of a multibyte sequence. This is the cost under the assumption of correct branch prediction.\n$2$. The penalty cost, $C_{penalty}$, which is incurred only if the branch predictor mispredicts.\n\nSo, for any given byte, the total cost is $C_{byte} = C_{base} + C_{penalty}$.\nUsing the linearity of expectation again, the expected total cost per byte is the sum of the expected values of its components:\n$$E[C_{byte}] = E[C_{base}] + E[C_{penalty}]$$\nWe will now compute each of these expected values separately.\n\nFirst, we compute the expected base cost, $E[C_{base}]$. The problem states that a fraction $p$ of the bytes are ASCII, and a fraction $1-p$ belong to multibyte sequences.\n- If a byte is ASCII (which occurs with probability $p$), the execution follows the ASCII fast-path, and the base cost is $1$ cycle.\n- If a byte belongs to a multibyte sequence (which occurs with probability $1-p$), the execution follows the multibyte slow-path, and the base cost is $4$ cycles.\n\nThe expected base cost is the weighted average of these two costs, where the weights are their respective probabilities:\n$$E[C_{base}] = p \\cdot 1 + (1-p) \\cdot 4$$\n$$E[C_{base}] = p + 4 - 4p$$\n$$E[C_{base}] = 4 - 3p$$\n\nNext, we compute the expected penalty cost, $E[C_{penalty}]$.\nThe problem states that the branch predictor has a misprediction rate of $m$ and that mispredictions are uniformly distributed over all $n$ branch decisions. This implies that for any given byte, the probability of a branch misprediction is $m$.\n- A branch misprediction occurs with probability $m$. The cost incurred is the penalty of $b$ cycles.\n- The branch is correctly predicted with probability $1-m$, in which case the penalty cost is $0$.\n\nThe expected penalty cost per byte is:\n$$E[C_{penalty}] = m \\cdot b + (1-m) \\cdot 0$$\n$$E[C_{penalty}] = mb$$\n\nFinally, we find the total expected cycles per byte, $C_{avg}$, by summing the expected base cost and the expected penalty cost:\n$$C_{avg} = E[C_{byte}] = E[C_{base}] + E[C_{penalty}]$$\n$$C_{avg} = (4 - 3p) + mb$$\nThis expression represents the expected cycles per byte as a function of the fraction of ASCII bytes $p$, the branch misprediction rate $m$, and the misprediction penalty $b$.",
            "answer": "$$\\boxed{4 - 3p + mb}$$"
        }
    ]
}