{
    "hands_on_practices": [
        {
            "introduction": "理解字节序（endianness）通常感觉很抽象，但它对数据的存储方式有实实在在的影响。这个练习将挑战你扮演一名数字侦探，分析一个数字序列的原始内存转储。通过运用大端和小端字节序的定义，你将能够推断出系统的体系结构并揭示数据中隐藏的规律。",
            "id": "3639638",
            "problem": "一个无符号 $32$ 位整数（$\\texttt{uint32\\_t}$）数组从基地址 $\\texttt{0x2000}$ 开始连续存储在内存中。硬件的字节序是未知的。该数组的元素构成一个等差数列 $\\{a_k\\}$，其中 $a_k = a_0 + k\\,d$，对于 $k \\in \\{0,1,2,3,4\\}$。$a_0$ 和 $d$ 是非负整数，并且在这个范围内不会发生 $32$ 位整数的溢出。公差满足 $0  d  256$，并且在这五个元素之间，从低位字节到高位字节没有进位。\n\n给定从地址 $\\texttt{0x2000}$ 到 $\\texttt{0x2013}$ 的前 $20$ 个字节（五个字）的线性十六进制转储，按地址递增顺序列出。这些字节是：\n$\\texttt{40 30 20 10 50 30 20 10 60 30 20 10 70 30 20 10 80 30 20 10}$。\n\n仅使用字节序的核心定义（在小端模式中，一个字的最低有效字节位于最低地址；在大端模式中，最高有效字节位于最低地址）和等差数列的定义，确定字节序并重构 $a_0$ 和 $d$。请以十进制整数形式报告公差 $d$。无需四舍五入。",
            "solution": "问题要求我们确定一个计算机系统的字节序，并找出存储在内存中的一个等差数列的公差 $d$。\n\n首先，让我们将给定的信息形式化。\n一个包含五个 $32$ 位无符号整数（$\\texttt{uint32\\_t}$）的数组，我们表示为 $\\{a_k\\}_{k=0}^4$，从地址 $\\texttt{0x2000}$ 开始存储在内存中。提供了前 $20$ 个字节的内存转储：\n$\\texttt{40 30 20 10 50 30 20 10 60 30 20 10 70 30 20 10 80 30 20 10}$。\n\n该序列是一个等差数列，定义为 $a_k = a_0 + k\\,d$，其中 $k \\in \\{0, 1, 2, 3, 4\\}$。\n约束条件是：\n1. $a_0$ 和 $d$ 是非负整数。\n2. 公差 $d$ 满足 $0  d  256$。用十六进制表示，即 $0  d  \\texttt{0x100}$。\n3. 当计算 $a_{k+1} = a_k + d$ 时（$k \\in \\{0, 1, 2, 3\\}$），从低位字节到高位字节没有进位。鉴于 $d$ 是一个单字节值，这意味着在每一步中，将 $d$ 加到 $a_k$ 的最低有效字节上所产生的结果不会大于或等于 $256$（即 $\\texttt{0x100}$）。\n\n内存转储对应于五个连续的 $32$ 位字。让我们按字来分割字节流：\n- 字 0 ($a_0$)：地址 $\\texttt{0x2000}-\\texttt{0x2003}$ 处的字节是 $\\texttt{40}, \\texttt{30}, \\texttt{20}, \\texttt{10}$。\n- 字 1 ($a_1$)：地址 $\\texttt{0x2004}-\\texttt{0x2007}$ 处的字节是 $\\texttt{50}, \\texttt{30}, \\texttt{20}, \\texttt{10}$。\n- 字 2 ($a_2$)：地址 $\\texttt{0x2008}-\\texttt{0x200B}$ 处的字节是 $\\texttt{60}, \\texttt{30}, \\texttt{20}, \\texttt{10}$。\n- 字 3 ($a_3$)：地址 $\\texttt{0x200C}-\\texttt{0x200F}$ 处的字节是 $\\texttt{70}, \\texttt{30}, \\texttt{20}, \\texttt{10}$。\n- 字 4 ($a_4$)：地址 $\\texttt{0x2010}-\\texttt{0x2013}$ 处的字节是 $\\texttt{80}, \\texttt{30}, \\texttt{20}, \\texttt{10}$。\n\n我们必须对系统的字节序检验两种假设。\n\n**假设 1：系统是大端模式**\n在大端架构中，多字节字的最高有效字节（MSB）存储在最低的内存地址。字节按从最高有效到最低有效的顺序存储。\n\n让我们在这个假设下构造 $\\{a_k\\}$ 的整数值：\n- $a_0 = \\texttt{0x40302010}$\n- $a_1 = \\texttt{0x50302010}$\n- $a_2 = \\texttt{0x60302010}$\n- $a_3 = \\texttt{0x70302010}$\n- $a_4 = \\texttt{0x80302010}$\n\n现在，我们通过计算连续项之间的差来检查这个序列是否构成等差数列。\n$d = a_1 - a_0 = \\texttt{0x50302010} - \\texttt{0x40302010} = \\texttt{0x10000000}$\n让我们为其他元素验证这个公差：\n$a_2 - a_1 = \\texttt{0x60302010} - \\texttt{0x50302010} = \\texttt{0x10000000}$\n$a_3 - a_2 = \\texttt{0x70302010} - \\texttt{0x60302010} = \\texttt{0x10000000}$\n$a_4 - a_3 = \\texttt{0x80302010} - \\texttt{0x70302010} = \\texttt{0x10000000}$\n该序列确实是一个等差数列，公差为 $d = \\texttt{0x10000000}$。\n\n接下来，我们将这个 $d$ 值与问题的约束条件 $0  d  256$ 进行核对。\n$d$ 的十进制值为 $d = 16^7 = 268,435,456$。\n这个值 $268,435,456$ 不在要求的范围 $(0, 256)$ 内。\n因此，大端模式的假设是错误的。\n\n**假设 2：系统是小端模式**\n在小端架构中，多字节字的最低有效字节（LSB）存储在最低的内存地址。要构成常规书写形式（MSB 在前）的整数，必须按相反的顺序读取内存中的字节。\n\n让我们在这个假设下构造 $\\{a_k\\}$ 的整数值：\n- 对于 $a_0$，字节是 $\\texttt{40}, \\texttt{30}, \\texttt{20}, \\texttt{10}$。将它们反转得到 $\\texttt{10}, \\texttt{20}, \\texttt{30}, \\texttt{40}$。所以，$a_0 = \\texttt{0x10203040}$。\n- 对于 $a_1$，字节是 $\\texttt{50}, \\texttt{30}, \\texttt{20}, \\texttt{10}$。将它们反转得到 $\\texttt{10}, \\texttt{20}, \\texttt{30}, \\texttt{50}$。所以，$a_1 = \\texttt{0x10203050}$。\n- 对所有字遵循此模式：\n  - $a_0 = \\texttt{0x10203040}$\n  - $a_1 = \\texttt{0x10203050}$\n  - $a_2 = \\texttt{0x10203060}$\n  - $a_3 = \\texttt{0x10203070}$\n  - $a_4 = \\texttt{0x10203080}$\n\n现在，我们检查这个序列是否是等差数列。\n$d = a_1 - a_0 = \\texttt{0x10203050} - \\texttt{0x10203040} = \\texttt{0x10}$\n让我们为其他元素验证这个公差：\n$a_2 - a_1 = \\texttt{0x10203060} - \\texttt{0x10203050} = \\texttt{0x10}$\n$a_3 - a_2 = \\texttt{0x10203070} - \\texttt{0x10203060} = \\texttt{0x10}$\n$a_4 - a_3 = \\texttt{0x10203080} - \\texttt{0x10203070} = \\texttt{0x10}$\n该序列是一个等差数列，公差为 $d = \\texttt{0x10}$。\n\n接下来，我们将这个 $d$ 值与问题的约束条件进行核对。\n首先，$0  d  256$。\n$d$ 的十进制值为 $d = 16^1 = 16$。\n条件 $0  16  256$ 得到满足。\n\n其次，我们必须验证“无进位”的约束。这意味着加上 $d$ 不会导致从低位字节到高位字节的进位。\n设 $a_k = B_{k,3}2^{24} + B_{k,2}2^{16} + B_{k,1}2^8 + B_{k,0}$ 是 $a_k$ 的字节表示。\n操作是 $a_{k+1} = a_k + d$。由于 $d = \\texttt{0x10}$ 小于 $\\texttt{0x100}$（或 $256$），除非产生进位，否则加法只影响最低位字节 $B_{k,0}$。约束条件声明没有进位发生。\n- 对于 $k=0$：$a_0 = \\texttt{0x10203040}$。最低有效字节是 $B_{0,0} = \\texttt{0x40}$。\n  $B_{0,0} + d = \\texttt{0x40} + \\texttt{0x10} = \\texttt{0x50}$。由于 $\\texttt{0x50}  \\texttt{0x100}$，没有进位。\n  $a_1 = a_0 + d = \\texttt{0x10203040} + \\texttt{0x10} = \\texttt{0x10203050}$。这与我们计算出的 $a_1$ 值相符。\n- 对于 $k=1$：$a_1 = \\texttt{0x10203050}$。最低有效字节是 $B_{1,0} = \\texttt{0x50}$。\n  $B_{1,0} + d = \\texttt{0x50} + \\texttt{0x10} = \\texttt{0x60}$。由于 $\\texttt{0x60}  \\texttt{0x100}$，没有进位。\n  $a_2 = a_1 + d = \\texttt{0x10203050} + \\texttt{0x10} = \\texttt{0x10203060}$。这与我们计算出的 $a_2$ 值相符。\n- 对于 $k=2$：$a_2 = \\texttt{0x10203060}$。最低有效字节是 $B_{2,0} = \\texttt{0x60}$。\n  $B_{2,0} + d = \\texttt{0x60} + \\texttt{0x10} = \\texttt{0x70}$。由于 $\\texttt{0x70}  \\texttt{0x100}$，没有进位。\n  $a_3 = a_2 + d = \\texttt{0x10203060} + \\texttt{0x10} = \\texttt{0x10203070}$。这与我们计算出的 $a_3$ 值相符。\n- 对于 $k=3$：$a_3 = \\texttt{0x10203070}$。最低有效字节是 $B_{3,0} = \\texttt{0x70}$。\n  $B_{3,0} + d = \\texttt{0x70} + \\texttt{0x10} = \\texttt{0x80}$。由于 $\\texttt{0x80}  \\texttt{0x100}$，没有进位。\n  $a_4 = a_3 + d = \\texttt{0x10203070} + \\texttt{0x10} = \\texttt{0x10203080}$。这与我们计算出的 $a_4$ 值相符。\n\n在小端模式的假设下，所有约束条件都得到满足。\n字节序是小端模式。\n数列的首项是 $a_0 = \\texttt{0x10203040}$。\n公差是 $d = \\texttt{0x10}$，即十进制的 $16$。\n\n问题要求以十进制整数形式给出公差 $d$。\n$d = 16$。",
            "answer": "$$\\boxed{16}$$"
        },
        {
            "introduction": "在网络编程中，确保数据在不同系统间被正确解释是至关重要的，而字节序是常见的错误来源。本练习模拟了一个现实场景，其中开发者误解了字节序转换约定，导致数据损坏。通过追踪特定的测试值在有缺陷的通信管道中的变化，你将学会如何诊断这些微妙但关键的“双重交换”错误。",
            "id": "3639618",
            "problem": "一个低位字节序（little-endian）的主机 $A$ 与一个低位字节序的主机 $B$ 通信，使用一个远程过程调用（RPC）层。该 RPC 层以高位字节序（big-endian）将 $16$ 位字段打包到线路上传输，并在解包时将原始字节从线路复制到主机内存中，不执行任何转换。应用程序的开发人员在发送端错误地在将数据传递给 RPC 打包程序之前应用了主机到网络短整数（Host-To-Network-Short, HTONS）函数，并在接收端在 RPC 解包字节后应用了网络到主机短整数（Network-To-Host-Short, NTOHS）函数。线路协议规定所有 $16$ 位字段都必须采用高位字节序。\n\n你需要设计一种调试方法，使用探测值 $p_{1} = 0x00FF$ 和 $p_{2} = 0xFF00$ 来检测上述双重交换（double-swap）错误的存在。设 $V(p)$ 表示在包含开发人员转换和 RPC 打包/解包程序的整个流程执行后，最终传递到主机 $B$ 上的应用程序的 $16$ 位无符号整数值。定义诊断标量\n$$\nD \\equiv V(p_{1}) - V(p_{2}),\n$$\n将 $V(p_{1})$ 和 $V(p_{2})$ 都解释为无符号 $16$ 位整数，并在主机上执行标准整数算术减法（而不是模 $2^{16}$）。\n\n仅从高位字节序和低位字节序的核心定义以及单字节交换对 $16$ 位值的作用出发，推导该流程中的 $V(p)$，并根据给定的探测值计算诊断标量 $D$ 的数值。将最终的诊断标量 $D$ 表示为一个无符号十进制整数。无需四舍五入。",
            "solution": "用户希望为一个存在字节序相关错误的数据传输流程计算诊断标量 $D$ 的值。\n\n### 步骤 1：提取已知条件\n- **主机字节序**：主机 A 和主机 B 都是低位字节序（little-endian）。\n- **线路协议**：线路协议对 $16$ 位字段使用高位字节序（big-endian）。\n- **RPC 层行为（发送）**：发送端的 RPC 打包程序接收一个 $16$ 位值，并以高位字节序将其打包到线路上。\n- **RPC 层行为（接收）**：接收端的 RPC 解包程序将原始字节从线路直接复制到主机内存中，不进行任何字节序转换。\n- **开发人员错误（发送）**：开发人员的发送代码在将数据传递给 RPC 打包程序*之前*，对数据应用了 `Host-To-Network-Short` (`HTONS`) 函数。\n- **开发人员操作（接收）**：开发人员的接收代码在从 RPC 解包程序接收数据*之后*，对数据应用了 `Network-To-Host-Short` (`NTOHS`) 函数。\n- **探测值**：使用两个 $16$ 位探测值：$p_{1} = 0x00FF$ 和 $p_{2} = 0xFF00$。\n- **函数定义**：$V(p)$ 是最终传递到主机 B 上应用程序的 $16$ 位无符号整数值。\n- **诊断定义**：$D \\equiv V(p_{1}) - V(p_{2})$，其中减法为标准整数算术。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据和客观性**：该问题很好地基于计算机组织与体系结构的原理，特别是网络字节序和主机字节序（endianness）。高位字节序、低位字节序、`HTONS` 和 `NTOHS` 的概念在网络编程中是标准。\n- **问题适定性**：该问题对数据处理流程提供了完整且一致的描述。追踪数据从主机 A 到主机 B 转换所需的所有信息都已提供。这些函数和操作在计算机科学的背景下有明确的定义。\n- **可形式化**：该问题使用精确的术语进行描述，可以进行数学和算法上的形式化。\n- **无缺陷**：该问题没有违反任何科学原理，不是不完整或矛盾的，并且并非微不足道。所描述的 RPC 层行为不寻常但有明确定义，使其成为一个可解的情景。\n\n### 步骤 3：结论与行动\n问题是有效的。将提供详细的解决方案。\n\n### 变换 V(p) 的推导\n\n让我们定义一个通用的 $16$ 位无符号整数 $p$，其最高有效字节（MSB）为 $B_H$，最低有效字节（LSB）为 $B_L$。$p$ 的值由 $p = 256 \\cdot B_H + B_L$ 给出。我们用十六进制表示为 $p = 0x B_H B_L$。\n\n一个**高位字节序**（big-endian）系统将此值存储在内存中，MSB 在较低地址，后跟 LSB：$[B_H, B_L]$。\n一个**低位字节序**（little-endian）系统将 LSB 存储在较低地址，后跟 MSB：$[B_L, B_H]$。\n\n在低位字节序主机上，`HTONS` 和 `NTOHS` 的核心操作是字节交换。让我们定义交换操作符 $S(p)$ 如下：\n$$\nS(p) = S(256 \\cdot B_H + B_L) = 256 \\cdot B_L + B_H\n$$\n在十六进制表示法中，$S(0x B_H B_L) = 0x B_L B_H$。\n\n我们现在追踪值 $p$ 从主机 A 到主机 B 的整个流程。\n\n1.  **从主机 A（低位字节序）开始**：应用程序以 $16$ 位值 $p = 0x B_H B_L$ 开始。\n\n2.  **开发人员调用 `HTONS`**：开发人员错误地对 $p$ 调用了 `HTONS`。由于主机 A 是低位字节序，`HTONS` 执行字节交换。传递给 RPC 层的值是：\n    $$\n    p' = \\text{HTONS}(p) = S(p) = 0x B_L B_H\n    $$\n\n3.  **主机 A 上的 RPC 打包程序**：RPC 层接收到值 $p' = 0x B_L B_H$。它的任务是以高位字节序将此值打包到线路上。对于值 $p'$，其 MSB 是 $B_L$，LSB 是 $B_H$。高位字节序的线路格式要求先发送 MSB，再发送 LSB。因此，在线路上发送的字节序列是：\n    $$\n    \\text{Wire Bytes} = [B_L, B_H]\n    $$\n\n4.  **主机 B 上的 RPC 解包程序**：RPC 解包程序接收到字节流 $[B_L, B_H]$。根据问题描述，它“通过将原始字节从线路复制到主机内存中而不执行任何转换来进行解包”。字节 $B_L$ 被写入内存地址 $m$，字节 $B_H$ 被写入下一个地址 $m+1$。主机 B 的内存现在包含字节序列 $[B_L, B_H]$。\n\n5.  **在主机 B（低位字节序）上的数据解释**：RPC 层将此内存位置的值传递给应用程序。由于主机 B 是低位字节序，其 CPU 将内存序列 $[B_L, B_H]$（LSB 在较低地址，MSB 在较高地址）解释为值：\n    $$\n    p'' = 256 \\cdot B_H + B_L = p\n    $$\n    所以，开发人员的应用程序代码接收到的值（在调用其自己的 `NTOHS` 之前）是原始值 $p$。发送端开发人员的 `HTONS` 调用与 RPC 层行为的组合导致了将 $p$ 未经改变地传输到主机 B 的应用层。\n\n6.  **开发人员调用 `NTOHS`**：主机 B 上的应用程序接收到值 $p'' = p$ 并对其调用 `NTOHS`。由于主机 B 是低位字节序，`NTOHS` 执行字节交换。\n    $$\n    V(p) = \\text{NTOHS}(p'') = \\text{NTOHS}(p) = S(p)\n    $$\n\n因此，整个流程的净效应是一次字节交换：$V(p) = S(p) = 0x B_L B_H$。\n\n### 诊断标量 D 的计算\n\n现在我们将此变换应用于探测值 $p_1$ 和 $p_2$。\n\n对于 $p_{1} = 0x00FF$：\n高位字节是 $B_H = 0x00$，低位字节是 $B_L = 0xFF$。\n在主机 B 上的最终值是：\n$$\nV(p_{1}) = S(0x00FF) = 0xFF00\n$$\n作为一个无符号十进制整数，$V(p_{1}) = 255 \\times 256 + 0 = 65280$。\n\n对于 $p_{2} = 0xFF00$：\n高位字节是 $B_H = 0xFF$，低位字节是 $B_L = 0x00$。\n在主机 B 上的最终值是：\n$$\nV(p_{2}) = S(0xFF00) = 0x00FF\n$$\n作为一个无符号十进制整数，$V(p_{2}) = 0 \\times 256 + 255 = 255$。\n\n最后，我们使用标准整数算术计算诊断标量 $D$：\n$$\nD = V(p_{1}) - V(p_{2}) = 65280 - 255\n$$\n$$\nD = 65025\n$$\n诊断标量 $D$ 的值为 $65025$。这个非零结果成功地检测到了数据编组异常的存在。",
            "answer": "$$\n\\boxed{65025}\n$$"
        },
        {
            "introduction": "同一串字节序列，根据系统的字节序及其数据类型解释，可能代表一个巨大的整数，也可能代表无穷大的概念。这个高级实践探讨了字节顺序和像 IEEE-754 浮点数这样的数据表示标准之间的关键交集。你的任务是设计一个巧妙的测试，能够唯一地识别远程设备的内部工作方式，从而展示一种在复杂系统中确保互操作性的强大技术。",
            "id": "3639653",
            "problem": "一个远程仪器接收按内存地址升序排列的四个字节，并返回一个十进制数值。在内部，该仪器根据四种假说之一来解释接收到的$32$位字：大端无符号整数、小端无符号整数、大端电气和电子工程师协会（IEEE）754标准单精度浮点数，或小端IEEE-754标准单精度浮点数。解释方式是固定的但未知。测量约束如下：当内部解释为浮点数且计算值不是有限实数（例如，$+\\infty$、$-\\infty$或“非数值” (Not-a-Number)）时，仪器返回十进制数$0$；否则，它返回解释结果的精确十进制值。当内部解释为整数时，仪器返回精确的无符号十进制值。\n\n你必须选择由四字节序列组成的测试向量，这些字节模式在组合成一个$32$位字时，能使得四种假说下的输出可被证明是可区分的，且证明过程仅使用字节序和IEEE-754单精度编码的基本定义。请使用以下候选测试向量：\n- $v_1$：字节 $\\{0x7F,\\,0x80,\\,0x00,\\,0x00\\}$ 按地址升序排列，\n- $v_2$：字节 $\\{0x00,\\,0x00,\\,0x00,\\,0x01\\}$ 按地址升序排列。\n\n你可以使用的基本依据：\n- 字节序定义：如果字节 $\\{B_0,\\,B_1,\\,B_2,\\,B_3\\}$ 从最低地址到最高地址排列，则大端$32$位字为 $X_{\\mathrm{BE}} = B_0 \\cdot 2^{24} + B_1 \\cdot 2^{16} + B_2 \\cdot 2^{8} + B_3$，小端$32$位字为 $X_{\\mathrm{LE}} = B_0 + B_1 \\cdot 2^{8} + B_2 \\cdot 2^{16} + B_3 \\cdot 2^{24}$。\n- IEEE-754单精度布局：给定一个$32$位字 $X$，符号位为 $s = (X \\gg 31) \\ 1$，指数场为 $e = (X \\gg 23) \\ 0xFF$，小数场为 $f = X \\ 0x7FFFFF$。其值为：\n  - 如果 $e = 255$ 且 $f = 0$，则为 $(-1)^s \\cdot \\infty$，\n  - 如果 $e = 0$ 且 $f \\neq 0$，则为 $(-1)^s \\cdot 2^{-126} \\cdot \\frac{f}{2^{23}}$ （非规格化数），\n  - 如果 $0  e  255$，则为 $(-1)^s \\cdot 2^{e - 127} \\cdot \\left(1 + \\frac{f}{2^{23}}\\right)$。\n\n根据这些基本依据，推导是仅 $v_1$、仅 $v_2$ 还是两者共同作用才能保证仪器的单个十进制输出能唯一确定四种假说中的哪一种生效。你的推理过程不得使用快捷表格，并且必须说明对于所选的测试向量，考虑到仪器对非有限浮点数的映射规则，四种假说下的输出为何是两两不同的。总结出要保证能从四种假说中进行识别，所需来自 $\\{v_1, v_2\\}$ 的最少不同测试向量数量。以整数形式表达你的最终答案。无需四舍五入。",
            "solution": "问题是有效的。它在科学上基于计算机体系结构的原理，特别是数据表示（字节序和IEEE-754浮点标准）。它的提法很严谨，提供了所有必要的定义和约束，以得出一个唯一的、合乎逻辑的解决方案。问题陈述是客观和完整的。\n\n任务是确定从集合 $\\{v_1, v_2\\}$ 中需要的最少测试向量数量，以唯一确定仪器使用四种假说中的哪一种来解释一个四字节序列。这四种假说是大端无符号整数（BE_UINT）、小端无符号整数（LE_UINT）、大端IEEE-754单精度浮点数（BE_FLOAT）和小端IEEE-754单精度浮点数（LE_FLOAT）。如果对于任何一对不同的假说，集合中至少有一个向量对每个假说产生不同的输出，那么这组测试向量就是充分的。最少数量是这种最小集合的大小。\n\n设四个字节按内存地址升序排列为 $\\{B_0, B_1, B_2, B_3\\}$。问题定义了大端和小端$32$位字为：\n$X_{\\mathrm{BE}} = B_0 \\cdot 2^{24} + B_1 \\cdot 2^{16} + B_2 \\cdot 2^{8} + B_3$\n$X_{\\mathrm{LE}} = B_0 + B_1 \\cdot 2^{8} + B_2 \\cdot 2^{16} + B_3 \\cdot 2^{24}$\n\n我们将通过计算每个测试向量在所有四种假说下的仪器输出来分析它们。\n\n测试向量 $v_1 = \\{0x7F, 0x80, 0x00, 0x00\\}$ 的分析\n\n对于 $v_1$，字节为 $B_0 = 0x7F = 127$，$B_1 = 0x80 = 128$，$B_2 = 0x00 = 0$，$B_3 = 0x00 = 0$。\n\n1.  **假说：大端无符号整数 (BE_UINT)**\n    $32$位字是 $X_{\\mathrm{BE}}$。用十六进制表示，这是通过拼接字节形成的：$X_{\\mathrm{BE}} = 0x7F800000$。\n    其十进制值为 $127 \\cdot 2^{24} + 128 \\cdot 2^{16} + 0 \\cdot 2^8 + 0 \\cdot 2^0 = 2130706432 + 8388608 = 2139095040$。\n    仪器输出为 $2139095040$。\n\n2.  **假说：小端无符号整数 (LE_UINT)**\n    $32$位字是 $X_{\\mathrm{LE}}$。用十六进制表示，这是通过按重要性倒序拼接字节形成的：$X_{\\mathrm{LE}} = 0x0000807F$。\n    其十进制值为 $127 \\cdot 2^0 + 128 \\cdot 2^8 + 0 \\cdot 2^{16} + 0 \\cdot 2^{24} = 127 + 32768 = 32895$。\n    仪器输出为 $32895$。\n\n3.  **假说：大端IEEE-754单精度浮点数 (BE_FLOAT)**\n    $32$位字是 $X = X_{\\mathrm{BE}} = 0x7F800000$。\n    其二进制表示为 `0111 1111 1000 0000 0000 0000 0000 0000`。\n    符号位是 $s = (X \\gg 31) \\ 1 = 0$。\n    指数场是 $e = (X \\gg 23) \\ 0xFF$。其比特位为 `11111111`，所以 $e = 255$。\n    小数场是 $f = X \\ 0x7FFFFF$。其比特位全为 `0`，所以 $f = 0$。\n    根据提供的规则，对于 $e = 255$ 和 $f = 0$，值为 $(-1)^s \\cdot \\infty$。当 $s=0$ 时，值为 $+\\infty$。\n    仪器对非有限值返回 $0$。\n    仪器输出为 $0$。\n\n4.  **假说：小端IEEE-754单精度浮点数 (LE_FLOAT)**\n    $32$位字是 $X = X_{\\mathrm{LE}} = 0x0000807F$。\n    其二进制表示为 `0000 0000 0000 0000 1000 0000 0111 1111`。\n    符号位是 $s = (X \\gg 31) \\ 1 = 0$。\n    指数场是 $e = (X \\gg 23) \\ 0xFF = 0$。\n    小数场是 $f = X \\ 0x7FFFFF = 0x807F = 32895$。\n    根据提供的规则，对于 $e=0$ 和 $f \\neq 0$，这是一个非规格化数。其值为 $(-1)^s \\cdot 2^{-126} \\cdot \\frac{f}{2^{23}}$。\n    当 $s=0$ 和 $f=32895$ 时，值为 $2^{-126} \\cdot \\frac{32895}{2^{23}} = 2^{-126} \\cdot \\frac{32895}{8388608}$。\n    该值是一个有限、正、非零的实数。\n    仪器输出为 $2^{-126} \\cdot \\frac{32895}{8388608}$。\n\n$v_1$ 的输出为：\n-   BE_UINT: $2139095040$\n-   LE_UINT: $32895$\n-   BE_FLOAT: $0$\n-   LE_FLOAT: $2^{-126} \\cdot \\frac{32895}{8388608}$ (一个小的正数)\n\n这四个值在数值上都是不同的。因此，通过发送测试向量 $v_1$ 并观察单个十进制输出，就可以唯一确定四种假说中哪一个是正确的。这意味着仅 $v_1$ 就足够了。因此，所需的最少向量数量最多为 $1$。\n\n为完整起见，我们分析向量 $v_2$。\n\n测试向量 $v_2 = \\{0x00, 0x00, 0x00, 0x01\\}$ 的分析\n\n对于 $v_2$，字节为 $B_0 = 0x00 = 0$，$B_1 = 0x00 = 0$，$B_2 = 0x00 = 0$，$B_3 = 0x01 = 1$。\n\n1.  **假说：大端无符号整数 (BE_UINT)**\n    $32$位字是 $X_{\\mathrm{BE}} = 0x00000001$。\n    其十进制值为 $0 \\cdot 2^{24} + 0 \\cdot 2^{16} + 0 \\cdot 2^8 + 1 \\cdot 2^0 = 1$。\n    仪器输出为 $1$。\n\n2.  **假说：小端无符号整数 (LE_UINT)**\n    $32$位字是 $X_{\\mathrm{LE}} = 0x01000000$。\n    其十进制值为 $0 \\cdot 2^0 + 0 \\cdot 2^8 + 0 \\cdot 2^{16} + 1 \\cdot 2^{24} = 16777216$。\n    仪器输出为 $16777216$。\n\n3.  **假说：大端IEEE-754单精度浮点数 (BE_FLOAT)**\n    $32$位字是 $X = X_{\\mathrm{BE}} = 0x00000001$。\n    符号位是 $s = 0$。\n    指数场是 $e = 0$。\n    小数场是 $f = 1$。\n    对于 $e=0$ 和 $f \\neq 0$，该值为非规格化数：$(-1)^s \\cdot 2^{-126} \\cdot \\frac{f}{2^{23}} = 2^{-126} \\cdot \\frac{1}{2^{23}} = 2^{-149}$。\n    仪器输出为 $2^{-149}$。\n\n4.  **假说：小端IEEE-754单精度浮点数 (LE_FLOAT)**\n    $32$位字是 $X = X_{\\mathrm{LE}} = 0x01000000$。\n    其二进制表示为 `0000 0001 0000 0000 0000 0000 0000 0000`。\n    符号位是 $s = 0$。\n    指数场是 $e = (X \\gg 23) \\ 0xFF = 2$。\n    小数场是 $f = X \\ 0x7FFFFF = 0$。\n    对于 $0  e  255$，该值为规格化数：$(-1)^s \\cdot 2^{e-127} \\cdot (1 + \\frac{f}{2^{23}}) = 2^{2-127} \\cdot (1 + 0) = 2^{-125}$。\n    仪器输出为 $2^{-125}$。\n\n$v_2$ 的输出为：\n-   BE_UINT: $1$\n-   LE_UINT: $16777216$\n-   BE_FLOAT: $2^{-149}$\n-   LE_FLOAT: $2^{-125}$\n\n这四个值 ($1$, $16777216$, $2^{-149}$, 和 $2^{-125}$) 在数值上都是不同的。因此，仅 $v_2$ 也足以区分这四种假说。\n\n由于仅向量 $v_1$ 或仅向量 $v_2$ 都足以唯一识别仪器的解释模式，因此从集合 $\\{v_1, v_2\\}$ 中所需的最少不同测试向量数量是 $1$。",
            "answer": "$$\n\\boxed{1}\n$$"
        }
    ]
}