{
    "hands_on_practices": [
        {
            "introduction": "Understanding endianness begins with being able to interpret raw memory. This first exercise puts you in the role of a systems programmer debugging a memory-related issue. By analyzing a hexadecimal memory dump and using the properties of an arithmetic sequence, you will deduce the system's underlying byte order, a fundamental skill in reverse engineering and low-level diagnostics .",
            "id": "3639638",
            "problem": "An array of unsigned 32-bit integers ($\\texttt{uint32\\_t}$) is stored contiguously in memory starting at base address $\\texttt{0x2000}$. The hardware endianness is unknown. The elements of the array form an arithmetic progression $\\{a_k\\}$ with $a_k = a_0 + k\\,d$ for $k \\in \\{0,1,2,3,4\\}$, where $a_0$ and $d$ are nonnegative integers, and there is no wraparound within $32$ bits on this range. The common difference satisfies $0  d  256$, and there are no carries from lower to higher bytes across these five elements.\n\nYou are given a linear hexdump of the first 20 bytes (five words) at addresses $\\texttt{0x2000}$ through $\\texttt{0x2013}$, listed in order of increasing address. The bytes are:\n$\\texttt{40 30 20 10 50 30 20 10 60 30 20 10 70 30 20 10 80 30 20 10}$.\n\nUsing only the core definition of endianness (in little-endian, the least significant byte of a word resides at the lowest address; in big-endian, the most significant byte resides at the lowest address) and the definition of an arithmetic progression, determine the endianness and reconstruct $a_0$ and $d$. Report the common difference $d$ as a base-$10$ integer. No rounding is required.",
            "solution": "The problem requires us to determine the endianness of a computer system and find the common difference $d$ of an arithmetic progression stored in memory.\n\nFirst, let's formalize the given information.\nAn array of five 32-bit unsigned integers ($\\texttt{uint32\\_t}$), which we denote as $\\{a_k\\}_{k=0}^4$, is stored in memory starting at address $\\texttt{0x2000}$. A memory dump of the first 20 bytes is provided:\n$\\texttt{40 30 20 10 50 30 20 10 60 30 20 10 70 30 20 10 80 30 20 10}$.\n\nThe sequence is an arithmetic progression defined by $a_k = a_0 + k\\,d$ for $k \\in \\{0, 1, 2, 3, 4\\}$.\nThe constraints are:\n1. $a_0$ and $d$ are nonnegative integers.\n2. The common difference $d$ satisfies $0  d  256$. In hexadecimal, this is $0  d  \\texttt{0x100}$.\n3. There are no carries from lower to higher bytes when calculating $a_{k+1} = a_k + d$ for $k \\in \\{0, 1, 2, 3\\}$. Given that $d$ is a single-byte value, this implies that for each step, the addition of $d$ to the least significant byte of $a_k$ does not produce a result greater than or equal to $256$ (i.e., $\\texttt{0x100}$).\n\nThe memory dump corresponds to five consecutive 32-bit words. Let's segment the byte stream by word:\n- Word 0 ($a_0$): bytes at $\\texttt{0x2000}-\\texttt{0x2003}$ are $\\texttt{40}, \\texttt{30}, \\texttt{20}, \\texttt{10}$.\n- Word 1 ($a_1$): bytes at $\\texttt{0x2004}-\\texttt{0x2007}$ are $\\texttt{50}, \\texttt{30}, \\texttt{20}, \\texttt{10}$.\n- Word 2 ($a_2$): bytes at $\\texttt{0x2008}-\\texttt{0x200B}$ are $\\texttt{60}, \\texttt{30}, \\texttt{20}, \\texttt{10}$.\n- Word 3 ($a_3$): bytes at $\\texttt{0x200C}-\\texttt{0x200F}$ are $\\texttt{70}, \\texttt{30}, \\texttt{20}, \\texttt{10}$.\n- Word 4 ($a_4$): bytes at $\\texttt{0x2010}-\\texttt{0x2013}$ are $\\texttt{80}, \\texttt{30}, \\texttt{20}, \\texttt{10}$.\n\nWe must test two hypotheses for the system's endianness.\n\n**Hypothesis 1: The system is Big-Endian**\nIn a big-endian architecture, the most significant byte (MSB) of a multi-byte word is stored at the lowest memory address. The bytes are stored in order from most significant to least significant.\n\nLet's construct the integer values for $\\{a_k\\}$ under this assumption:\n- $a_0 = \\texttt{0x40302010}$\n- $a_1 = \\texttt{0x50302010}$\n- $a_2 = \\texttt{0x60302010}$\n- $a_3 = \\texttt{0x70302010}$\n- $a_4 = \\texttt{0x80302010}$\n\nNow, we check if this sequence forms an arithmetic progression by calculating the difference between consecutive terms.\n$d = a_1 - a_0 = \\texttt{0x50302010} - \\texttt{0x40302010} = \\texttt{0x10000000}$\nLet's verify this common difference for the other elements:\n$a_2 - a_1 = \\texttt{0x60302010} - \\texttt{0x50302010} = \\texttt{0x10000000}$\n$a_3 - a_2 = \\texttt{0x70302010} - \\texttt{0x60302010} = \\texttt{0x10000000}$\n$a_4 - a_3 = \\texttt{0x80302010} - \\texttt{0x70302010} = \\texttt{0x10000000}$\nThe sequence is indeed an arithmetic progression with a common difference $d = \\texttt{0x10000000}$.\n\nNext, we check this value of $d$ against the problem's constraint $0  d  256$.\nThe value of $d$ in base-$10$ is $d = 16^7 = 268,435,456$.\nThis value, $268,435,456$, is not in the required range $(0, 256)$.\nTherefore, the big-endian hypothesis is incorrect.\n\n**Hypothesis 2: The system is Little-Endian**\nIn a little-endian architecture, the least significant byte (LSB) of a multi-byte word is stored at the lowest memory address. To form the integer as it is conventionally written (MSB first), the bytes from memory must be read in reverse order.\n\nLet's construct the integer values for $\\{a_k\\}$ under this assumption:\n- For $a_0$, the bytes are $\\texttt{40}, \\texttt{30}, \\texttt{20}, \\texttt{10}$. Reversing them gives $\\texttt{10}, \\texttt{20}, \\texttt{30}, \\texttt{40}$. So, $a_0 = \\texttt{0x10203040}$.\n- For $a_1$, the bytes are $\\texttt{50}, \\texttt{30}, \\texttt{20}, \\texttt{10}$. Reversing them gives $\\texttt{10}, \\texttt{20}, \\texttt{30}, \\texttt{50}$. So, $a_1 = \\texttt{0x10203050}$.\n- Following this pattern for all words:\n  - $a_0 = \\texttt{0x10203040}$\n  - $a_1 = \\texttt{0x10203050}$\n  - $a_2 = \\texttt{0x10203060}$\n  - $a_3 = \\texttt{0x10203070}$\n  - $a_4 = \\texttt{0x10203080}$\n\nNow, we check if this sequence is an arithmetic progression.\n$d = a_1 - a_0 = \\texttt{0x10203050} - \\texttt{0x10203040} = \\texttt{0x10}$\nLet's verify this common difference for the other elements:\n$a_2 - a_1 = \\texttt{0x10203060} - \\texttt{0x10203050} = \\texttt{0x10}$\n$a_3 - a_2 = \\texttt{0x10203070} - \\texttt{0x10203060} = \\texttt{0x10}$\n$a_4 - a_3 = \\texttt{0x10203080} - \\texttt{0x10203070} = \\texttt{0x10}$\nThe sequence is an arithmetic progression with a common difference $d = \\texttt{0x10}$.\n\nNext, we check this value of $d$ against the problem's constraints.\nFirst, $0  d  256$.\nThe value of $d$ in base-$10$ is $d = 16^1 = 16$.\nThe condition $0  16  256$ is satisfied.\n\nSecond, we must verify the \"no carries\" constraint. This means adding $d$ does not cause a carry from a lower byte to a higher one.\nLet $a_k = B_{k,3}2^{24} + B_{k,2}2^{16} + B_{k,1}2^8 + B_{k,0}$ be the byte representation of $a_k$.\nThe operation is $a_{k+1} = a_k + d$. Since $d = \\texttt{0x10}$ is smaller than $\\texttt{0x100}$ (or $256$), the addition only affects the lowest byte, $B_{k,0}$, unless a carry is generated. The constraint states no carry occurs.\n- For $k=0$: $a_0 = \\texttt{0x10203040}$. The LSB is $B_{0,0} = \\texttt{0x40}$.\n  $B_{0,0} + d = \\texttt{0x40} + \\texttt{0x10} = \\texttt{0x50}$. Since $\\texttt{0x50}  \\texttt{0x100}$, there is no carry.\n  $a_1 = a_0 + d = \\texttt{0x10203040} + \\texttt{0x10} = \\texttt{0x10203050}$. This matches our value for $a_1$.\n- For $k=1$: $a_1 = \\texttt{0x10203050}$. The LSB is $B_{1,0} = \\texttt{0x50}$.\n  $B_{1,0} + d = \\texttt{0x50} + \\texttt{0x10} = \\texttt{0x60}$. Since $\\texttt{0x60}  \\texttt{0x100}$, there is no carry.\n  $a_2 = a_1 + d = \\texttt{0x10203050} + \\texttt{0x10} = \\texttt{0x10203060}$. This matches our value for $a_2$.\n- For $k=2$: $a_2 = \\texttt{0x10203060}$. The LSB is $B_{2,0} = \\texttt{0x60}$.\n  $B_{2,0} + d = \\texttt{0x60} + \\texttt{0x10} = \\texttt{0x70}$. Since $\\texttt{0x70}  \\texttt{0x100}$, there is no carry.\n  $a_3 = a_2 + d = \\texttt{0x10203060} + \\texttt{0x10} = \\texttt{0x10203070}$. This matches our value for $a_3$.\n- For $k=3$: $a_3 = \\texttt{0x10203070}$. The LSB is $B_{3,0} = \\texttt{0x70}$.\n  $B_{3,0} + d = \\texttt{0x70} + \\texttt{0x10} = \\texttt{0x80}$. Since $\\texttt{0x80}  \\texttt{0x100}$, there is no carry.\n  $a_4 = a_3 + d = \\texttt{0x10203070} + \\texttt{0x10} = \\texttt{0x10203080}$. This matches our value for $a_4$.\n\nAll constraints are satisfied under the little-endian hypothesis.\nThe endianness is little-endian.\nThe initial term of the progression is $a_0 = \\texttt{0x10203040}$.\nThe common difference is $d = \\texttt{0x10}$, which is $16$ in base-$10$.\n\nThe problem asks for the common difference $d$ as a base-$10$ integer.\n$d = 16$.",
            "answer": "$$\\boxed{16}$$"
        },
        {
            "introduction": "Endianness bugs often appear in network communication, where data travels between machines that may have different conventions. This problem simulates a classic and confusing \"double-swap\" error, where incorrect byte-order conversions on both the sender and receiver lead to mangled data. By carefully tracing the transformation of test values through the entire pipeline, you will learn to diagnose subtle bugs that arise from interacting software layers .",
            "id": "3639618",
            "problem": "A little-endian host $A$ communicates with a little-endian host $B$ using a Remote Procedure Call (RPC) layer that packs 16-bit fields onto the wire in big-endian order and unpacks by copying the raw bytes from the wire into host memory without performing any conversion. The developer of the application mistakenly applies Host-To-Network-Short (HTONS) on the send side before passing data to the RPC packer and applies Network-To-Host-Short (NTOHS) on the receive side after the RPC has unpacked the bytes. The wire protocol mandates big-endian ordering for all 16-bit fields.\n\nYou are asked to design a debugging approach that uses the probe values $p_{1} = 0x00FF$ and $p_{2} = 0xFF00$ to detect the presence of the double-swap bug described above. Let $V(p)$ denote the $16$-bit unsigned integer value ultimately delivered to the application on host $B$ after the entire pipeline consisting of the developerâ€™s conversions and the RPC packer/unpacker executes. Define the diagnostic scalar\n$$\nD \\equiv V(p_{1}) - V(p_{2}),\n$$\ninterpreting both $V(p_{1})$ and $V(p_{2})$ as unsigned $16$-bit integers and performing subtraction in standard integer arithmetic on the host (not modulo $2^{16}$).\n\nStarting only from the core definitions of big-endian and little-endian byte ordering and the action of a single-byte swap on a $16$-bit value, derive $V(p)$ for this pipeline and compute the diagnostic $D$ numerically for the given probes. Express the final diagnostic $D$ as an unsigned decimal integer. No rounding is required.",
            "solution": "### Derivation of the Transformation V(p)\n\nLet us define a generic $16$-bit unsigned integer $p$ by its most significant byte (MSB), $B_H$, and its least significant byte (LSB), $B_L$. The value of $p$ is given by $p = 256 \\cdot B_H + B_L$. We represent this in hexadecimal as $p = 0x B_H B_L$.\n\nA **big-endian** system stores this value in memory with the MSB at the lower address, followed by the LSB: $[B_H, B_L]$.\nA **little-endian** system stores the LSB at the lower address, followed by the MSB: $[B_L, B_H]$.\n\nThe core operation of `HTONS` and `NTOHS` on a little-endian host is a byte swap. Let's define the swap operator $S(p)$ as:\n$$\nS(p) = S(256 \\cdot B_H + B_L) = 256 \\cdot B_L + B_H\n$$\nIn hexadecimal notation, $S(0x B_H B_L) = 0x B_L B_H$.\n\nWe now trace the value $p$ through the entire pipeline from host A to host B.\n\n1.  **Start at Host A (Little-Endian)**: The application starts with the $16$-bit value $p = 0x B_H B_L$.\n\n2.  **Developer's `HTONS` Call**: The developer mistakenly calls `HTONS` on $p$. Since host A is little-endian, `HTONS` performs a byte swap. The value passed to the RPC layer is:\n    $$\n    p' = \\text{HTONS}(p) = S(p) = 0x B_L B_H\n    $$\n\n3.  **RPC Packer on Host A**: The RPC layer receives the value $p' = 0x B_L B_H$. It is tasked with packing this value onto the wire in big-endian order. For the value $p'$, its MSB is $B_L$ and its LSB is $B_H$. Big-endian wire format requires sending the MSB first, then the LSB. Therefore, the byte sequence sent on the wire is:\n    $$\n    \\text{Wire Bytes} = [B_L, B_H]\n    $$\n\n4.  **RPC Unpacker on Host B**: The RPC unpacker receives the byte stream $[B_L, B_H]$. According to the problem, it \"unpacks by copying the raw bytes from the wire into host memory without performing any conversion.\" The byte $B_L$ is written to a memory address $m$, and the byte $B_H$ is written to the next address $m+1$. The memory on host B now contains the byte sequence $[B_L, B_H]$.\n\n5.  **Data Interpretation on Host B (Little-Endian)**: The RPC layer passes the value from this memory location to the application. Since host B is little-endian, its CPU interprets the memory sequence $[B_L, B_H]$ (LSB at lower address, MSB at higher address) as the value:\n    $$\n    p'' = 256 \\cdot B_H + B_L = p\n    $$\n    So, the value received by the developer's application code (before its own `NTOHS` call) is the original value $p$. The combination of the developer's `HTONS` on the send side and the RPC layer's behavior has resulted in transmitting $p$ unchanged to the application layer on host B.\n\n6.  **Developer's `NTOHS` Call**: The application on host B receives the value $p'' = p$ and calls `NTOHS` on it. Since host B is little-endian, `NTOHS` performs a byte swap.\n    $$\n    V(p) = \\text{NTOHS}(p'') = \\text{NTOHS}(p) = S(p)\n    $$\n\nThus, the net effect of the entire pipeline is a single byte swap: $V(p) = S(p) = 0x B_L B_H$.\n\n### Calculation of the Diagnostic Scalar D\n\nNow we apply this transformation to the probe values $p_1$ and $p_2$.\n\nFor $p_{1} = 0x00FF$:\nThe high byte is $B_H = 0x00$ and the low byte is $B_L = 0xFF$.\nThe final value on host B is:\n$$\nV(p_{1}) = S(0x00FF) = 0xFF00\n$$\nAs an unsigned decimal integer, $V(p_{1}) = 255 \\times 256 + 0 = 65280$.\n\nFor $p_{2} = 0xFF00$:\nThe high byte is $B_H = 0xFF$ and the low byte is $B_L = 0x00$.\nThe final value on host B is:\n$$\nV(p_{2}) = S(0xFF00) = 0x00FF\n$$\nAs an unsigned decimal integer, $V(p_{2}) = 0 \\times 256 + 255 = 255$.\n\nFinally, we compute the diagnostic scalar $D$ using standard integer arithmetic:\n$$\nD = V(p_{1}) - V(p_{2}) = 65280 - 255\n$$\n$$\nD = 65025\n$$\nThe value of the diagnostic scalar $D$ is $65025$. This non-zero result successfully detects the presence of the data marshalling anomaly.",
            "answer": "$$\\boxed{65025}$$"
        },
        {
            "introduction": "The best way to handle endianness issues is to prevent them with robust code and thorough testing. This final practice moves from analysis to synthesis, challenging you to implement a test suite from first principles. By writing code that correctly generates network-byte-order packets and compares them against a common buggy implementation, you will master the practical techniques required to write portable and reliable cross-platform software .",
            "id": "3639632",
            "problem": "You must write a complete, runnable program that constructs tests to detect endianness bugs by emulating host endianness and verifying wire-format compatibility using a known sentinel. Use the following fundamental base: the definition of big-endian and little-endian byte orderings and the convention that Network Byte Order (NBO) is big-endian. Formally, big-endian (BE) places the most significant byte at the lowest address, and little-endian (LE) places the least significant byte at the lowest address.\n\nYour program must implement the following pure, deterministic experiment. For each test case, consider a packet that is the concatenation of a fixed sentinel and one numeric field:\n- The sentinel is the fixed unsigned $32$-bit integer $S = 0x01020304$.\n- The field is an unsigned integer value $v$ of width $w \\in \\{8, 16, 32, 64\\}$ bits.\n\nYou must produce two distinct serializations of the packet:\n- The correct wire-format packet $P_{\\text{correct}}$ which always writes all numeric fields in Network Byte Order (NBO), that is big-endian, regardless of the host. This packet is\n$$\nP_{\\text{correct}} = \\text{BE}(S, 32) \\,\\Vert\\, \\text{BE}(v, w),\n$$\nwhere $\\text{BE}(x, b)$ is the $b/8$-byte big-endian byte sequence of $x$, and $\\Vert$ denotes concatenation.\n- The naive host-order packet $P_{\\text{naive}}(e)$ which simulates a student bug that writes in-memory bytes directly to the wire, assuming host byte order equals wire order. This packet depends on an emulated host endianness $e \\in \\{\\text{LE}, \\text{BE}\\}$ and is\n$$\nP_{\\text{naive}}(e) = \\text{ORD}_e(S, 32) \\,\\Vert\\, \\text{ORD}_e(v, w),\n$$\nwhere $\\text{ORD}_{\\text{BE}}(x, b) = \\text{BE}(x, b)$ and $\\text{ORD}_{\\text{LE}}(x, b)$ is the $b/8$-byte little-endian sequence of $x$.\n\nFor each test case, compute two booleans:\n- $s$: whether the $4$-byte sentinel segment differs between $P_{\\text{naive}}(e)$ and $P_{\\text{correct}}$.\n- $f$: whether the $w/8$-byte field segment differs between $P_{\\text{naive}}(e)$ and $P_{\\text{correct}}$.\n\nAggregate these two booleans into a single integer code\n$$\nc \\;=\\; 2\\cdot s \\;+\\; f,\n$$\nso that $c \\in \\{0,1,2,3\\}$ encodes which parts of the packet would expose the bug under the emulated host:\n- $c = 0$ means no difference (the test would not expose the bug).\n- $c = 1$ means only the field differs.\n- $c = 2$ means only the sentinel differs.\n- $c = 3$ means both differ.\n\nYou must implement the byte extraction purely from first principles using shifts and masks. For any width $w$, the big-endian byte sequence is defined as\n$$\n\\text{BE}(x, w)[i] \\;=\\; \\left\\lfloor \\dfrac{x}{256^{(w/8 - 1 - i)}} \\right\\rfloor \\bmod 256\n\\quad\\text{for}\\quad i = 0, 1, \\dots, (w/8-1),\n$$\nand the little-endian sequence is\n$$\n\\text{LE}(x, w)[i] \\;=\\; \\left\\lfloor \\dfrac{x}{256^{i}} \\right\\rfloor \\bmod 256\n\\quad\\text{for}\\quad i = 0, 1, \\dots, (w/8-1).\n$$\n\nTest Suite. Your program must evaluate the following six test cases in the order listed below. Each test case is a tuple $(e, w, v)$:\n1. $(\\text{LE}, 32, 0x89ABCDEF)$\n2. $(\\text{BE}, 32, 0x89ABCDEF)$\n3. $(\\text{LE}, 8, 0x7F)$\n4. $(\\text{LE}, 64, 0x0000000000000000)$\n5. $(\\text{BE}, 16, 0x1234)$\n6. $(\\text{LE}, 16, 0xFF00)$\n\nOutput Specification. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each element being the integer $c$ for the corresponding test case in order. For example, a valid output format is $[3,0,2]$ for three cases. There must be no extra whitespace.\n\nYour solution must be expressed in terms of the above formal definitions only. No user input is required. All integers are unsigned and, for a given width $w$, values must be interpreted modulo $2^w$.",
            "solution": "The solution to this problem involves simulating the creation of two types of data packets and comparing them to determine if a potential endianness-related bug would be exposed. The core task is to determine whether the byte sequence for a given multi-byte integer value is identical in big-endian and little-endian formats.\n\nThe problem defines the correct wire format, $P_{\\text{correct}}$, as always using Network Byte Order (NBO), which is big-endian ($\\text{BE}$). The packet is a concatenation of a sentinel $S$ and a value $v$:\n$$\nP_{\\text{correct}} = \\text{BE}(S, 32) \\,\\Vert\\, \\text{BE}(v, w)\n$$\nA naive, buggy implementation is simulated by creating a packet $P_{\\text{naive}}(e)$ that writes data directly from memory, thus using the host's native byte order, which we emulate as either little-endian ($\\text{LE}$) or big-endian ($\\text{BE}$).\n$$\nP_{\\text{naive}}(e) = \\text{ORD}_e(S, 32) \\,\\Vert\\, \\text{ORD}_e(v, w)\n$$\nwhere $\\text{ORD}_{\\text{BE}}(x, b) = \\text{BE}(x, b)$ and $\\text{ORD}_{\\text{LE}}(x, b) = \\text{LE}(x, b)$.\n\nA bug is exposed if the byte sequence generated by the naive method differs from the correct NBO sequence. We must check this for the sentinel part ($s$) and the field part ($f$).\n\nThe defining property for this comparison stems from the formal definitions provided for byte extraction:\n- Big-Endian: $\\text{BE}(x, w)[i] \\;=\\; \\left\\lfloor \\dfrac{x}{256^{(w/8 - 1 - i)}} \\right\\rfloor \\bmod 256$, for byte index $i=0, \\dots, (w/8-1)$.\n- Little-Endian: $\\text{LE}(x, w)[i] \\;=\\; \\left\\lfloor \\dfrac{x}{256^{i}} \\right\\rfloor \\bmod 256$, for byte index $i=0, \\dots, (w/8-1)$.\n\nFrom these definitions, we can observe that $\\text{LE}(x, w)[i] = \\text{BE}(x, w)[(w/8 - 1) - i]$. This means the little-endian byte sequence is the exact reverse of the big-endian byte sequence. Therefore, $\\text{BE}(x, w)$ and $\\text{LE}(x, w)$ are identical if and only if the byte sequence is a palindrome (reads the same forwards and backwards).\n\nThe core of our algorithm is a function that determines if the byte sequences differ for a given value $x$, width $w$, and emulated host endianness $e$.\n1. If the emulated host endianness $e$ is big-endian ($\\text{BE}$), its native serialization $\\text{ORD}_{\\text{BE}}(x, w)$ is identical to the correct NBO serialization $\\text{BE}(x, w)$. In this case, there is no difference.\n2. If the emulated host endianness $e$ is little-endian ($\\text{LE}$), we must compare $\\text{BE}(x, w)$ with $\\text{LE}(x, w)$. As established, these differ unless the byte sequence of $x$ is a palindrome.\n   - For a single-byte value ($w=8$), the sequence has only one element, so it is trivially a palindrome. The $\\text{BE}$ and $\\text{LE}$ representations are identical.\n   - For multi-byte values ($w  8$), we check the palindrome property by comparing the $i$-th byte from the start with the $i$-th byte from the end for all $i$ from $0$ up to the midpoint of the sequence. The $i$-th byte from the start is $\\text{BE}(x, w)[i]$, and the $i$-th byte from the end is $\\text{BE}(x, w)[(w/8-1)-i]$, which is equivalent to $\\text{LE}(x, w)[i]$. Using bitwise operations derived from the formal definitions, we compare the byte at shifter position $(w/8 - 1 - i) \\times 8$ with the byte at shifter position $i \\times 8$. If any pair of bytes does not match, the value is not a palindrome, and the sequences differ.\n\nFor each test case $(e, w, v)$, this logic is applied to the sentinel $S = 0x01020304$ and the field value $v$ to compute the boolean flags $s$ and $f$. The fixed sentinel $S$ is not a byte-palindrome, so for any little-endian host, $s$ will be true. The flag $f$ depends on whether the specific value $v$ is a byte-palindrome. Finally, the integer code $c$ is computed using the aggregation formula $c = 2 \\cdot s + f$.",
            "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n#include stdio.h\n#include stdlib.h\n\n// Enum to represent emulated host endianness for clarity.\ntypedef enum {\n    EMULATED_LE,\n    EMULATED_BE\n} EmulatedEndianness;\n\n// A struct to hold the parameters for a single test case.\ntypedef struct {\n    EmulatedEndianness host_endianness;\n    int width;\n    unsigned long long value;\n} TestCase;\n\n/**\n * @brief Determines if the Big-Endian and Little-Endian byte sequences of a value differ.\n * \n * Based on the formal definitions, the LE sequence is the reverse of the BE sequence.\n * They are identical if and only if the byte sequence is a palindrome. This function\n * checks for this palindromic property.\n *\n * @param value The unsigned integer value to check.\n * @param width The bit width of the value (e.g., 8, 16, 32, 64).\n * @param host_is_le An integer flag; 1 if the emulated host is Little-Endian, 0 if Big-Endian.\n * @return Returns 1 if the sequences differ, 0 otherwise.\n */\nint do_sequences_differ(unsigned long long value, int width, int host_is_le) {\n    // If the host is Big-Endian, it matches the Network Byte Order (Big-Endian). No difference.\n    if (!host_is_le) {\n        return 0;\n    }\n\n    int num_bytes = width / 8;\n\n    // For single-byte values, BE and LE representations are identical.\n    if (num_bytes = 1) {\n        return 0;\n    }\n\n    // Host is Little-Endian. The sequences differ unless the value's byte\n    // representation is a palindrome. We check for this property.\n    for (int i = 0; i  num_bytes / 2; ++i) {\n        // Extract the i-th byte from the most-significant end (BE start).\n        // This corresponds to BE(value, width)[i].\n        unsigned char byte_from_start = (value  ((num_bytes - 1 - i) * 8))  0xFF;\n        \n        // Extract the i-th byte from the least-significant end (LE start).\n        // This corresponds to LE(value, width)[i] or BE(value, width)[num_bytes - 1 - i].\n        unsigned char byte_from_end = (value  (i * 8))  0xFF;\n\n        if (byte_from_start != byte_from_end) {\n            // If any pair of bytes does not match, it's not a palindrome.\n            // The BE and LE sequences differ.\n            return 1;\n        }\n    }\n\n    // If the loop completes, all byte pairs matched. It's a palindrome.\n    // The BE and LE sequences are the same.\n    return 0;\n}\n\nint main(void) {\n    // Define the test cases from the problem statement.\n    TestCase test_cases[] = {\n        {EMULATED_LE, 32, 0x89ABCDEF},\n        {EMULATED_BE, 32, 0x89ABCDEF},\n        {EMULATED_LE, 8,  0x7F},\n        {EMULATED_LE, 64, 0x0000000000000000ULL},\n        {EMULATED_BE, 16, 0x1234},\n        {EMULATED_LE, 16, 0xFF00}\n    };\n\n    // Calculate the number of test cases.\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    int results[num_cases];\n\n    // The fixed 32-bit sentinel value.\n    const unsigned int S = 0x01020304;\n\n    // Calculate the result for each test case.\n    for (int i = 0; i  num_cases; ++i) {\n        TestCase tc = test_cases[i];\n        int host_is_le = (tc.host_endianness == EMULATED_LE);\n\n        // s: whether sentinel segment differs.\n        int s = do_sequences_differ(S, 32, host_is_le);\n\n        // f: whether field segment differs.\n        int f = do_sequences_differ(tc.value, tc.width, host_is_le);\n\n        // c = 2*s + f\n        results[i] = 2 * s + f;\n    }\n\n    // Print the results in the EXACT REQUIRED format before the final return statement.\n    printf(\"[\");\n    for (int i = 0; i  num_cases; ++i) {\n        printf(\"%d\", results[i]);\n        if (i  num_cases - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\");\n\n    return EXIT_SUCCESS;\n}\n```"
        }
    ]
}