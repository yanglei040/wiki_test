{
    "hands_on_practices": [
        {
            "introduction": "This practice solidifies the fundamental rules of one's complement representation. By converting numbers between decimal and binary forms for different bit-widths, you'll gain hands-on experience with the sign bit, bitwise inversion for negation, and the system's unique dual-zero property . Mastering these conversions is the first essential skill for working with this number system.",
            "id": "3662341",
            "problem": "A digital system uses the one’s complement representation for signed $n$-bit integers. In one’s complement, positive values are encoded with a leading zero in the Most Significant Bit (MSB) and negative values are encoded by taking the bitwise complement of the positive encoding of the magnitude. There are two distinct encodings for zero, denoted $+0$ and $-0$. Consider the following two tasks that require conversion between decimal and one’s complement across two different word sizes.\n\nTask A (encoding for $n=5$ bits): Encode the decimal values $+7$, $-7$, $+0$, and $-0$ into $5$-bit one’s complement. For each resulting $5$-bit word, interpret the bits as an unsigned binary number to obtain an integer $U$. Let the four unsigned integers be $U_{+7}$, $U_{-7}$, $U_{+0}$, and $U_{-0}$.\n\nTask B (decoding for $n=6$ bits): Decode the following $6$-bit one’s complement words into signed decimal values: $101101$, $010010$, $111111$, and $000000$. Let the decoded decimal values be $D_{101101}$, $D_{010010}$, $D_{111111}$, and $D_{000000}$.\n\nUsing only the foundational definitions of one’s complement representation and without appealing to any memorized shortcut formulas, compute the quantity\n$$\nS = \\left(U_{+7} + U_{-7} + U_{+0} + U_{-0}\\right) + \\left(D_{101101} + D_{010010} + D_{111111} + D_{000000}\\right).\n$$\nProvide $S$ as a single integer. No rounding is required.",
            "solution": "The problem requires the computation of a sum $S$ derived from two tasks involving one's complement representation: an encoding task for a $5$-bit system and a decoding task for a $6$-bit system.\n\nThe problem statement has been validated and is deemed valid. It is scientifically sound, well-posed, and objective. All necessary definitions and data are provided. We proceed with the solution.\n\nThe solution is structured by first completing Task A, then Task B, and finally computing the total sum $S$.\n\n### Task A: Encoding for $n=5$ bits\n\nWe are asked to encode the decimal values $+7$, $-7$, $+0$, and $-0$ into $5$-bit one's complement and then interpret these binary words as unsigned integers.\n\n1.  **Encode $+7$**:\n    The number is positive, so its Most Significant Bit (MSB) must be $0$. The magnitude is $7$, which in binary is $111_2$. To represent $+7$ in a $5$-bit system, we pad the binary representation of the magnitude with leading zeros to a total length of $5$ bits.\n    $$ +7_{10} \\rightarrow 00111_2 $$\n    Interpreting $00111_2$ as an unsigned integer gives $U_{+7}$.\n    $$ U_{+7} = 0 \\cdot 2^4 + 0 \\cdot 2^3 + 1 \\cdot 2^2 + 1 \\cdot 2^1 + 1 \\cdot 2^0 = 0 + 0 + 4 + 2 + 1 = 7 $$\n\n2.  **Encode $-7$**:\n    The one's complement representation of a negative number is the bitwise complement of the representation of its positive magnitude. We take the complement of the binary word for $+7$.\n    $$ \\text{NOT}(00111_2) = 11000_2 $$\n    So, $-7_{10}$ is encoded as $11000_2$. Interpreting this as an unsigned integer gives $U_{-7}$.\n    $$ U_{-7} = 1 \\cdot 2^4 + 1 \\cdot 2^3 + 0 \\cdot 2^2 + 0 \\cdot 2^1 + 0 \\cdot 2^0 = 16 + 8 + 0 + 0 + 0 = 24 $$\n\n3.  **Encode $+0$**:\n    The representation for positive zero ($+0$) is a bit string of all zeros.\n    $$ +0_{10} \\rightarrow 00000_2 $$\n    Interpreting $00000_2$ as an unsigned integer gives $U_{+0}$.\n    $$ U_{+0} = 0 $$\n\n4.  **Encode $-0$**:\n    The representation for negative zero ($-0$) is the bitwise complement of the representation for $+0$.\n    $$ \\text{NOT}(00000_2) = 11111_2 $$\n    Interpreting $11111_2$ as an unsigned integer gives $U_{-0}$.\n    $$ U_{-0} = 1 \\cdot 2^4 + 1 \\cdot 2^3 + 1 \\cdot 2^2 + 1 \\cdot 2^1 + 1 \\cdot 2^0 = 16 + 8 + 4 + 2 + 1 = 31 $$\n\nThe sum for Task A is:\n$$ U_{+7} + U_{-7} + U_{+0} + U_{-0} = 7 + 24 + 0 + 31 = 62 $$\nIt can be observed that for any value $x$, the sum of its unsigned interpretation $U_x$ and the unsigned interpretation of its one's complement negation $U_{-x}$ is $2^n-1$. Here, $n=5$, so $2^5-1=31$. Indeed, $U_{+7} + U_{-7} = 7 + 24 = 31$ and $U_{+0} + U_{-0} = 0 + 31 = 31$. The sum is $31 + 31 = 62$.\n\n### Task B: Decoding for $n=6$ bits\n\nWe are asked to decode four $6$-bit one's complement words into signed decimal values.\n\n1.  **Decode $101101_2$**:\n    The MSB is $1$, so this is a negative number. To find its magnitude, we take the bitwise complement.\n    $$ \\text{NOT}(101101_2) = 010010_2 $$\n    The magnitude is the decimal value of this complemented binary word.\n    $$ 010010_2 = 1 \\cdot 2^4 + 0 \\cdot 2^3 + 0 \\cdot 2^2 + 1 \\cdot 2^1 + 0 \\cdot 2^0 = 16 + 2 = 18 $$\n    Since the number is negative, its value is $-18$.\n    $$ D_{101101} = -18 $$\n\n2.  **Decode $010010_2$**:\n    The MSB is $0$, so this is a positive number. Its value is the direct interpretation of the binary word.\n    $$ 010010_2 = 1 \\cdot 2^4 + 1 \\cdot 2^1 = 16 + 2 = 18 $$\n    The value is $+18$.\n    $$ D_{010010} = 18 $$\n\n3.  **Decode $111111_2$**:\n    The MSB is $1$, so this is a negative number. This specific pattern of all ones represents negative zero ($-0$). To confirm, we take the bitwise complement.\n    $$ \\text{NOT}(111111_2) = 000000_2 $$\n    The magnitude is $0$. Thus, the value is $0$.\n    $$ D_{111111} = 0 $$\n\n4.  **Decode $000000_2$**:\n    The MSB is $0$. This pattern of all zeros represents positive zero ($+0$). Its value is $0$.\n    $$ D_{000000} = 0 $$\n\nThe sum for Task B is:\n$$ D_{101101} + D_{010010} + D_{111111} + D_{000000} = -18 + 18 + 0 + 0 = 0 $$\n\n### Final Calculation\n\nThe total sum $S$ is the sum of the results from Task A and Task B.\n$$ S = \\left(U_{+7} + U_{-7} + U_{+0} + U_{-0}\\right) + \\left(D_{101101} + D_{010010} + D_{111111} + D_{000000}\\right) $$\nSubstituting the computed values:\n$$ S = (62) + (0) = 62 $$\nThe final result is $62$.",
            "answer": "$$\\boxed{62}$$"
        },
        {
            "introduction": "Understanding how arithmetic operations are implemented is a core concept in computer architecture. This exercise challenges you to analyze the procedure for subtraction in one's complement, which reduces the operation to an addition. You will explore the essential \"end-around carry\" mechanism and the special considerations needed for handling zero values, ensuring a deep grasp of the system's arithmetic logic .",
            "id": "3662347",
            "problem": "You are given a fixed word size of $n$ bits and a machine that uses One's Complement (OC) representation for signed integers. The core definitions are as follows: in $n$-bit OC, the representable values are the integers from $-(2^{n-1}-1)$ through $+(2^{n-1}-1)$, and there are two encodings of zero: $+0$ as the all-zero pattern $00\\ldots 0_2$ and $-0$ as the all-one pattern $11\\ldots 1_2$. Negation is implemented by bitwise complement: for any representable value with bit pattern $b$, the bitwise complement $\\overline{b}$ encodes the negation of the value, with the special case that $\\overline{00\\ldots 0_2} = 11\\ldots 1_2$ and vice versa. One's Complement addition is defined as ordinary $n$-bit binary addition with carry-out from the Most Significant Bit (MSB) wrapped around and added back into the Least Significant Bit (LSB) (an “end-around carry”); the resulting all-one pattern $11\\ldots 1_2$ is interpreted as $-0$, which may optionally be normalized to $+0$.\n\nYou are to implement subtraction of two $n$-bit OC operands $x$ and $y$ by a method that reduces subtraction to addition. Consider corner cases, including $y=0$, and the role of end-around carry and zero normalization. Select all options that are correct.\n\nA. A correct OC subtraction procedure for computing $x - y$ on $n$-bit operands is: compute $s \\leftarrow x + \\overline{y}$ using OC addition (i.e., include the end-around carry if one is produced), and if the resulting $n$-bit pattern equals $11\\ldots 1_2$, replace it with $00\\ldots 0_2$. This yields the correct difference whenever $x - y$ is representable in $n$-bit OC.\n\nB. For computing $x - y$ in OC, the end-around carry step can be omitted without affecting correctness; that is, computing the $n$-bit sum $x + \\overline{y}$ with the MSB carry simply discarded still yields the correct result for all $x$ and $y$ in range.\n\nC. In the special case $y=0$, since $\\overline{y} = 11\\ldots 1_2$ (that is, $-0$), OC addition with end-around carry gives $x$ for any $x$, and if $x=0$ the intermediate sum $11\\ldots 1_2$ must be normalized to $00\\ldots 0_2$ to produce the canonical zero.\n\nD. The correct way to compute $x - y$ in OC is to mimic Two’s Complement (TC) subtraction and use $x + \\overline{y} + 1$ (with the $+1$ term), discarding any MSB carry-out; this works for all $x$ and $y$.\n\nE. If the end-around carry step is omitted, a concrete $n=4$ counterexample is $x=0101_2$ and $y=0011_2$. The raw $4$-bit sum $x + \\overline{y}$ is $0001_2$, which represents $+1$, whereas the true mathematical result is $+2$ and the correct OC result with end-around carry would be $0010_2$.\n\nF. If the $-0$ to $+0$ normalization step is omitted, then with $n=4$, $x=0000_2$ and $y=0000_2$, the procedure produces $1111_2$ whose MSB is $1$. A simple sign test based solely on the MSB would incorrectly classify the result as negative, despite the correct mathematical result being $0$; thus normalization is necessary to ensure canonical zero and consistent sign-based predicates.",
            "solution": "The problem statement is subjected to validation before proceeding with a solution.\n\n### Step 1: Extract Givens\n- Word size: $n$ bits.\n- Number system: One's Complement (OC) representation for signed integers.\n- Representable range: Integers from $-(2^{n-1}-1)$ to $+(2^{n-1}-1)$.\n- Zero representations: Two encodings for zero exist.\n  - $+0$ is represented by the all-zero pattern $00\\ldots 0_2$.\n  - $-0$ is represented by the all-one pattern $11\\ldots 1_2$.\n- Negation: Implemented by bitwise complement. For a value with bit pattern $b$, its negation is represented by $\\overline{b}$.\n- One's Complement Addition: Defined as $n$-bit binary addition with an \"end-around carry\" (EAC), where the carry-out from the Most Significant Bit (MSB) is added to the Least Significant Bit (LSB) of the sum.\n- Normalization: The result $11\\ldots 1_2$ (representing $-0$) may be optionally normalized to $00\\ldots 0_2$ (representing $+0$).\n- Task: Analyze methods for computing the subtraction $x - y$ by converting it to an addition problem.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded:** The problem describes the One's Complement number system. All definitions provided—the range, the dual-zero representation, negation by bitwise complement, and addition with end-around carry—are standard and factually correct for this system, which is a fundamental topic in computer organization and architecture.\n- **Well-Posed:** The problem asks to evaluate several proposed algorithms for subtraction based on the given definitions. This is a clear, formalizable question with a definitive answer based on the rules of OC arithmetic.\n- **Objective:** The problem is stated in precise, technical language with no subjective or ambiguous terminology.\n\n### Step 3: Verdict and Action\nThe problem statement is valid. It is scientifically sound, well-posed, and objective. A solution can be derived from the provided definitions.\n\n### Derivation of One's Complement Subtraction\n\nThe subtraction operation $x - y$ is arithmetically equivalent to the addition $x + (-y)$. In the One's Complement system, the representation of the negative of a value $y$ is obtained by taking the bitwise complement of its representation, denoted $\\overline{y}$. Therefore, the subtraction $x - y$ is implemented by performing a One's Complement addition of $x$ and $\\overline{y}$.\n\nLet the $n$-bit patterns for $x$ and $y$ have unsigned integer values $X$ and $Y$, respectively. The unsigned value of $\\overline{Y}$ is $(2^n - 1) - Y$.\nThe operation is to compute the sum $X + \\overline{Y}$ using OC addition. This involves two steps:\n1. Compute the $n+1$-bit sum $S_{temp} = X + ((2^n - 1) - Y)$.\n2. If this sum generates a carry-out (i.e., if $S_{temp} \\geq 2^n$), the carry has a value of $2^n$. The carry bit is $1$. The $n$-bit result is $S_{temp} \\pmod{2^n}$. The end-around carry rule requires adding this carry bit to the LSB. The final result is $(S_{temp} \\pmod{2^n}) + 1$.\n   If there is no carry-out (i.e., $S_{temp}  2^n$), the carry bit is $0$, and the final result is just $S_{temp}$.\n\nThis can be expressed concisely: the final result is $(X + \\overline{Y}) \\pmod{2^n-1}$ if one considers the ring of integers modulo $2^n-1$. More directly:\nResult $S = X + ((2^n - 1) - Y)$.\n- **Case 1: $x \\ge y$ (and thus $X \\ge Y$, assuming non-negative values for simplicity of illustration, though the logic holds generally).**\nThe mathematical difference is non-negative. The sum is $S = (X - Y) + (2^n - 1) = (X-Y-1) + 2^n$.\nThis operation produces a carry-out of $1$. The intermediate $n$-bit sum is $(X-Y-1)$. The end-around carry adds $1$ back, yielding $(X-Y-1)+1 = X-Y$, which is the correct bit pattern for the positive result $x-y$.\n- **Case 2: $x  y$ (and thus $X  Y$).**\nThe mathematical difference is negative. The sum is $S = (X - Y) + (2^n - 1) = (2^n - 1) - (Y - X)$.\nThis value is less than $2^n$, so there is no carry-out. The result is the bit pattern $(2^n-1)-(Y-X)$. This is precisely the OC representation of the negative number $-(y-x) = x-y$.\n\nTherefore, the correct procedure is to compute $x + \\overline{y}$ using addition with end-around carry. A special case arises when the result is $0$, which can be represented as either $+0$ ($00\\ldots 0_2$) or $-0$ ($11\\ldots 1_2$). Normalizing $-0$ to $+0$ is often required for canonical representation.\n\n### Option-by-Option Analysis\n\n**A. A correct OC subtraction procedure for computing $x - y$ on $n$-bit operands is: compute $s \\leftarrow x + \\overline{y}$ using OC addition (i.e., include the end-around carry if one is produced), and if the resulting $n$-bit pattern equals $11\\ldots 1_2$, replace it with $00\\ldots 0_2$. This yields the correct difference whenever $x - y$ is representable in $n$-bit OC.**\nThis option accurately describes the procedure derived above. The subtraction $x-y$ is performed as $x + \\overline{y}$ with end-around carry. For example, if $x=y$, we compute $x + \\overline{x}$. The sum of a number and its bitwise complement is always $11\\ldots 1_2$ ($-0$). The normalization step correctly proposes to convert this to $00\\ldots 0_2$ ($+0$) for a canonical result. This entire procedure is correct.\n**Verdict: Correct.**\n\n**B. For computing $x - y$ in OC, the end-around carry step can be omitted without affecting correctness; that is, computing the $n$-bit sum $x + \\overline{y}$ with the MSB carry simply discarded still yields the correct result for all $x$ and $y$ in range.**\nThis is incorrect. As shown in the derivation (Case 1), when $x-y0$, a carry is generated, and omitting the end-around carry would result in a value that is off by $1$. For instance, for $n=4$, $x=5$ ($0101_2$) and $y=3$ ($0011_2$), $\\overline{y}$ is $1100_2$. The sum $x+\\overline{y}$ is $0101_2 + 1100_2 = (1)0001_2$. Discarding the carry gives $0001_2$ ($+1$), while the correct answer is $5-3=2$. The EAC step corrects this: $0001_2+1 = 0010_2$ ($+2$).\n**Verdict: Incorrect.**\n\n**C. In the special case $y=0$, since $\\overline{y} = 11\\ldots 1_2$ (that is, $-0$), OC addition with end-around carry gives $x$ for any $x$, and if $x=0$ the intermediate sum $11\\ldots 1_2$ must be normalized to $00\\ldots 0_2$ to produce the canonical zero.**\nLet's analyze $x - 0$, which is $x +_{OC} \\overline{0}$. The bit pattern for $0$ is $Y = 00\\ldots 0_2$, so $\\overline{Y} = 11\\ldots 1_2$. Let $X$ be the bit pattern for $x$.\n- If $x \\neq 0$: The sum $X + (11\\ldots 1_2)$ in binary is $X + (2^n-1) = (X-1) + 2^n$. This produces a carry-out of $1$ and an intermediate sum of $X-1$. The EAC adds $1$ back, yielding $(X-1)+1=X$. The result is $x$.\n- If $x = 0$: The bit pattern is $X=00\\ldots 0_2$. The sum is $00\\ldots 0_2 + 11\\ldots 1_2 = 11\\ldots 1_2$. There is no carry-out. The result is $11\\ldots 1_2$ ($-0$). The statement correctly notes that this should be normalized to $00\\ldots 0_2$ to represent the result $0-0=0$ canonically.\nThe statement is entirely accurate.\n**Verdict: Correct.**\n\n**D. The correct way to compute $x - y$ in OC is to mimic Two’s Complement (TC) subtraction and use $x + \\overline{y} + 1$ (with the $+1$ term), discarding any MSB carry-out; this works for all $x$ and $y$.**\nThis statement describes the procedure for Two's Complement subtraction, as the two's complement of $y$ is $\\overline{y}+1$. This method is not generally correct for One's Complement. Let's test with a case where the result is negative. Let $n=4$, $x=2$ ($0010_2$), $y=5$ ($0101_2$). The expected OC result for $-3$ is $1100_2$.\nThe bit pattern for $\\overline{y}$ is $1010_2$. The TC negation is $\\overline{y}+1 = 1011_2$.\nThe sum is $x + (\\overline{y}+1) = 0010_2 + 1011_2 = 1101_2$. There is no carry-out.\nThe result is $1101_2$, which is the OC representation for $-2$. The correct answer is $-3$. The TC method fails.\n**Verdict: Incorrect.**\n\n**E. If the end-around carry step is omitted, a concrete $n=4$ counterexample is $x=0101_2$ and $y=0011_2$. The raw $4$-bit sum $x + \\overline{y}$ is $0001_2$, which represents $+1$, whereas the true mathematical result is $+2$ and the correct OC result with end-around carry would be $0010_2$.**\nThis option provides a specific counterexample to demonstrate the necessity of the EAC.\n- $x = 0101_2$ represents $+5$.\n- $y = 0011_2$ represents $+3$.\n- $\\overline{y} = 1100_2$.\n- Binary sum $x + \\overline{y}$: $0101_2 + 1100_2 = (1)0001_2$.\n- Without EAC, the result is $0001_2$, which represents $+1$. This is incorrect, as $5-3=2$.\n- With EAC, the carry of $1$ is added to the LSB: $0001_2 + 1 = 0010_2$, which represents $+2$. This is correct.\nThe counterexample is valid and correctly reasoned.\n**Verdict: Correct.**\n\n**F. If the $-0$ to $+0$ normalization step is omitted, then with $n=4$, $x=0000_2$ and $y=0000_2$, the procedure produces $1111_2$ whose MSB is $1$. A simple sign test based solely on the MSB would incorrectly classify the result as negative, despite the correct mathematical result being $0$; thus normalization is necessary to ensure canonical zero and consistent sign-based predicates.**\nLet's trace the example: $n=4$, $x=0000_2$ ($+0$), $y=0000_2$ ($+0$).\nThe operation is $x - y$, implemented as $x +_{OC} \\overline{y}$.\n- $\\overline{y} = \\overline{0000_2} = 1111_2$ ($-0$).\n- Binary sum: $0000_2 + 1111_2 = 1111_2$.\n- There is no carry-out, so no EAC is performed.\nThe result is $1111_2$, which is the OC representation for $-0$. Although its mathematical value is zero, its MSB is $1$. In OC, a MSB of $1$ signifies a negative number (or $-0$). A hardware or software predicate checking only the MSB to determine the sign would classify this result as negative. This is misleading since the mathematical result is $0$. Normalizing $1111_2$ to $0000_2$ resolves this ambiguity and ensures that zero has a non-negative sign bit. The reasoning is sound.\n**Verdict: Correct.**",
            "answer": "$$\\boxed{ACEF}$$"
        },
        {
            "introduction": "Moving beyond basic operations, this practice asks you to think like a systems designer by analyzing different algorithms for computing the absolute value. It demonstrates how subtle features of a number system, such as the negative zero ($-0$) representation, have significant implications for software correctness. This exercise will sharpen your ability to reason about algorithms and their edge cases within the constraints of a specific hardware representation .",
            "id": "3662312",
            "problem": "Consider an $n$-bit one's complement representation, with $n \\geq 2$. In this system, each bit vector $x \\in \\{0,1\\}^{n}$ has a Most Significant Bit (MSB) denoted $x_{n-1}$, and two encodings exist for the mathematical value $0$: the all-zero vector $0^{n}$ (denoted $+0$) and the all-one vector $1^{n}$ (denoted $-0$). For any bit vector $x$, let $\\overline{x}$ denote its bitwise complement, and let $m(x) \\triangleq \\sum_{i=0}^{n-1} x_{i} 2^{i}$ denote its unsigned magnitude. The mathematical value map in one's complement is defined as follows: if $x_{n-1} = 0$, then $\\mathrm{val}(x) = m(x)$; if $x_{n-1} = 1$ and $x \\neq 1^{n}$, then $\\mathrm{val}(x) = - m(\\overline{x})$; and if $x = 1^{n}$, then $\\mathrm{val}(x) = 0$. Define the canonical non-negative encoder $\\mathrm{enc}(y)$ for any integer $y$ with $0 \\le y \\le 2^{n-1}-1$ to be the unique $n$-bit vector with MSB $0$ whose unsigned magnitude equals $y$, so in particular $\\mathrm{enc}(0) = 0^{n}$. The absolute value function must produce the canonical non-negative encoding of $|\\mathrm{val}(x)|$.\n\nThree candidate implementations of absolute value on $n$-bit one's complement inputs are given:\n1. $f_{0}(x)$ clears the MSB and leaves all other bits unchanged, i.e., $f_{0}(x)$ is the bit vector whose bits satisfy $(f_{0}(x))_{n-1} = 0$ and $(f_{0}(x))_{i} = x_{i}$ for all $0 \\le i \\le n-2$.\n2. $f_{1}(x)$ is identical to $f_{0}(x)$ except it adds a special-case handling for negative zero: if $x = 1^{n}$, then $f_{1}(x) = 0^{n}$.\n3. $g(x)$ complements all bits if and only if the MSB is $1$, i.e., $g(x) = \\overline{x}$ when $x_{n-1} = 1$, and $g(x) = x$ when $x_{n-1} = 0$.\n\nStarting only from the definitions above and the requirement that a correct absolute value must equal $\\mathrm{enc}(|\\mathrm{val}(x)|)$, analyze each implementation and determine, as a function of $n$, the exact number of inputs $x \\in \\{0,1\\}^{n}$ for which the output equals the canonical encoding $\\mathrm{enc}(|\\mathrm{val}(x)|)$. Denote these cardinalities by $|S_{f_{0}}|$, $|S_{f_{1}}|$, and $|S_{g}|$, where $S_{h} \\triangleq \\{x \\in \\{0,1\\}^{n} \\mid h(x) = \\mathrm{enc}(|\\mathrm{val}(x)|)\\}$ for an implementation $h$. Express your final answer as a single ordered triple. No rounding is required, and no units are involved.",
            "solution": "To find the size of the sets $S_{f_0}$, $S_{f_1}$, and $S_g$, we analyze each function for all possible inputs $x \\in \\{0,1\\}^n$. A natural way to partition the inputs is based on the MSB, $x_{n-1}$.\n\n**Case 1: $x_{n-1} = 0$ (Non-negative numbers)**\n*   There are $2^{n-1}$ such numbers.\n*   For these numbers, $\\mathrm{val}(x) = m(x) \\ge 0$.\n*   Therefore, $|\\mathrm{val}(x)| = m(x)$.\n*   The correct output must be $\\mathrm{enc}(|\\mathrm{val}(x)|) = \\mathrm{enc}(m(x))$.\n*   By definition, `enc(y)` is the $n$-bit vector with MSB $0$ and unsigned magnitude $y$. The input $x$ already has MSB $0$ and its unsigned magnitude is $m(x)$. Thus, $\\mathrm{enc}(m(x)) = x$.\n*   For any $x$ with $x_{n-1}=0$, the correct output is $x$ itself.\n*   Let's check each function for $x$ where $x_{n-1}=0$:\n    *   **`f_0(x)`**: Clears the MSB. Since $x_{n-1}$ is already 0, $f_0(x)$ doesn't change it. All other bits are also unchanged. Therefore, $f_0(x) = x$. This is correct. This holds for all $2^{n-1}$ non-negative inputs.\n    *   **`f_1(x)`**: Since $x_{n-1}=0$, $x$ cannot be $1^n$. So $f_1(x) = f_0(x) = x$. This is also correct for all $2^{n-1}$ non-negative inputs.\n    *   **`g(x)`**: Since $x_{n-1}=0$, $g(x) = x$. This is also correct for all $2^{n-1}$ non-negative inputs.\n*   **Conclusion for non-negative inputs**: All three functions are correct for all $2^{n-1}$ inputs where $x_{n-1}=0$.\n\n**Case 2: $x_{n-1} = 1$ (Negative numbers and negative zero)**\n*   There are $2^{n-1}$ such numbers.\n*   This case splits into two sub-cases: $x=1^n$ (negative zero) and $x \\neq 1^n$ (strictly negative numbers).\n\n**Sub-case 2a: $x \\neq 1^n$ and $x_{n-1}=1$ (Strictly negative numbers)**\n*   There are $2^{n-1}-1$ such numbers.\n*   For these inputs, $\\mathrm{val}(x) = -m(\\overline{x})$.\n*   $|\\mathrm{val}(x)| = |-m(\\overline{x})| = m(\\overline{x})$.\n*   The correct output must be $\\mathrm{enc}(|\\mathrm{val}(x)|) = \\mathrm{enc}(m(\\overline{x}))$.\n*   By definition, $\\mathrm{enc}(m(\\overline{x}))$ is the unique $n$-bit vector with MSB $0$ and unsigned magnitude $m(\\overline{x})$.\n*   Let's look at the bit vector $\\overline{x}$. Its MSB is $0$. Its unsigned magnitude is $m(\\overline{x})$. Therefore, by definition, $\\mathrm{enc}(m(\\overline{x})) = \\overline{x}$.\n*   So, for any strictly negative input $x$, the correct output is $\\overline{x}$.\n*   Let's check each function for these $2^{n-1}-1$ inputs:\n    *   **`f_0(x)`**: The vector $f_0(x)$ is $0x_{n-2}...x_0$. The correct vector $\\overline{x}$ is $0\\overline{x}_{n-2}...\\overline{x}_0$. They are equal only if $x_i = \\overline{x}_i$ for all $i  n-1$, which is impossible. So $f_0(x)$ is never correct for any strictly negative number.\n    *   **`f_1(x)`**: Since $x \\neq 1^n$, $f_1(x) = f_0(x)$. For the same reason, $f_1(x)$ is never correct for any strictly negative number.\n    *   **`g(x)`**: Since $x_{n-1}=1$, $g(x) = \\overline{x}$. As we derived, the correct output is $\\overline{x}$. Therefore, $g(x)$ is correct for all $2^{n-1}-1$ strictly negative numbers.\n\n**Sub-case 2b: $x = 1^n$ (Negative zero)**\n*   This is a single input.\n*   For this input, $\\mathrm{val}(1^n) = 0$. So, $|\\mathrm{val}(1^n)| = 0$.\n*   The correct output must be $\\mathrm{enc}(0)$, which is defined as $0^n$.\n*   Let's check each function for this input:\n    *   **`f_0(1^n)`**: $f_0(x)$ clears the MSB and leaves other bits unchanged. Input $x = 11...1$. Output will be $01...1$. The correct output is $00...0 = 0^n$. This is incorrect for $n \\ge 2$.\n    *   **`f_1(1^n)`**: The definition has a special case for this exact input: if $x=1^n$, then $f_1(x) = 0^n$. This is correct.\n    *   **`g(1^n)`**: Since the MSB of $1^n$ is $1$, $g(1^n) = \\overline{1^n} = 0^n$. This is correct.\n\n**Summary of Correctness Counts**:\n\nLet's tally the results for each function.\n\n*   **For `f_0(x)`**:\n    *   Correct for all $2^{n-1}$ non-negative inputs ($x_{n-1}=0$).\n    *   Incorrect for all $2^{n-1}-1$ strictly negative inputs.\n    *   Incorrect for the negative zero input ($x=1^n$).\n    *   Total correct: $|S_{f_0}| = 2^{n-1}$.\n\n*   **For `f_1(x)`**:\n    *   Correct for all $2^{n-1}$ non-negative inputs ($x_{n-1}=0$).\n    *   Incorrect for all $2^{n-1}-1$ strictly negative inputs.\n    *   Correct for the negative zero input ($x=1^n$).\n    *   Total correct: $|S_{f_1}| = 2^{n-1} + 1$.\n\n*   **For `g(x)`**:\n    *   Correct for all $2^{n-1}$ non-negative inputs ($x_{n-1}=0$).\n    *   Correct for all $2^{n-1}-1$ strictly negative inputs.\n    *   Correct for the negative zero input ($x=1^n$).\n    *   Total correct: $|S_g| = 2^{n-1} + (2^{n-1}-1) + 1 = 2 \\cdot 2^{n-1} = 2^n$.\n\nThe final cardinalities are $|S_{f_0}| = 2^{n-1}$, $|S_{f_1}| = 2^{n-1} + 1$, and $|S_g| = 2^n$.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n2^{n-1}  2^{n-1} + 1  2^{n}\n\\end{pmatrix}\n}\n$$"
        }
    ]
}