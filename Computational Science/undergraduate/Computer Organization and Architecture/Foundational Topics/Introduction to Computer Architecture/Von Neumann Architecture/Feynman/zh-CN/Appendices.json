{
    "hands_on_practices": [
        {
            "introduction": "冯·诺依曼结构的核心性能限制是指令和数据共享同一通道，这通常被称为“冯·诺依曼瓶颈”。第一个练习提供了一个量化模型来理解这一限制。通过分析一个简单的点积运算，你将推导出总执行时间的表达式，清晰地将内存传输所用时间与算术计算所用时间分离开来 。",
            "id": "3688062",
            "problem": "一台单核冯·诺依曼机拥有一个共享数据内存总线，并对两个长度为 $n$ 的数组执行流式点积运算。每个数组元素的大小为 $b$ 字节。该微体系结构是顺序执行的，并施加了以下约束：\n\n- 数组的所有数据访问都通过单一数据内存总线，该总线在流式访问下的峰值带宽为 $BW$ 字节/秒。\n- 加载是阻塞式的，数据传输与算术运算不重叠。也就是说，当内存系统在传输操作数时，算术逻辑单元 (ALU) 无法执行算术运算，反之亦然。\n- 算术核心在标量操作数上每次循环迭代执行一次融合乘加 (FMA) 运算，并且每秒最多可以完成 $R$ 次融合乘加运算。\n- 与流式数据流量相比，指令获取成本和累加结果的最终标量存储成本可以忽略不计。\n\n仅从以下定义出发：(i) 带宽 $BW$ 的单位是字节/秒，(ii) 时间等于功除以速率，以及 (iii) 点积为每个元素执行一次融合乘加 (FMA) 运算并从内存中读取两个操作数，请在上述不重叠约束下，推导出总执行时间 $T$ 关于 $n$、$b$、$BW$ 和 $R$ 的闭式表达式。\n\n然后，使用 $n=5 \\times 10^{7}$，$b=8$ 字节，$BW=25 \\times 10^{9}$ 字节/秒，以及 $R=5 \\times 10^{9}$ 融合乘加/秒，计算该表达式的值。将 $T$ 的最终数值结果四舍五入到四位有效数字，并以秒为单位表示。",
            "solution": "该问题将首先经过严格的验证过程，以确保其科学和逻辑的完整性。\n\n### 步骤 1：提取已知条件\n\n问题陈述中提供了以下数据和约束：\n- **系统架构**: 一台单核冯·诺依曼机，拥有一个共享数据内存总线。\n- **任务**: 对两个长度为 $n$ 的数组执行流式点积运算。\n- **数据大小**: 每个数组元素的大小为 $b$ 字节。\n- **执行模型**: 微体系结构是顺序执行的。\n- **内存访问**: 数组的所有数据访问都通过单一数据内存总线。\n- **内存带宽**: 该总线在流式访问下的峰值带宽为 $BW$ 字节/秒。\n- **执行约束**: 加载是阻塞式的，数据传输与算术运算不重叠。ALU 和内存系统串行操作，而非并行。\n- **算术运算**: 核心在标量操作数上每次循环迭代执行一次融合乘加 (FMA) 运算。\n- **算术吞吐量**: 核心每秒最多可以完成 $R$ 次融合乘加运算。\n- **简化假设**: 指令获取成本和累加结果的最终标量存储成本可以忽略不计。\n- **基本原理**: (i) 带宽 $BW$ 的单位是字节/秒，(ii) 时间等于功除以速率，以及 (iii) 点积为每个元素执行一次 FMA 运算并从内存中读取两个操作数。\n- **用于求值的数值**: $n = 5 \\times 10^7$，$b = 8$ 字节，$BW = 25 \\times 10^9$ 字节/秒，以及 $R = 5 \\times 10^9$ 融合乘加/秒。\n- **最终答案要求**: 将总时间 $T$ 的数值结果四舍五入到四位有效数字。\n\n### 步骤 2：使用提取的已知条件进行验证\n\n根据验证标准对问题陈述进行评估。\n\n- **科学基础**: 该问题在计算机组成和体系结构原理方面有坚实的基础。它为执行内存密集型或计算密集型任务的处理器提供了一个简化但有效的性能模型。内存带宽（$BW$）、算术吞吐量（$R$）和冯·诺依曼瓶颈等概念是该领域的基础。“不重叠”约束是简单顺序执行流水线模型的一个关键特征。\n- **适定性**: 该问题是适定的。目标是推导总执行时间的表达式。“不重叠”规则等约束条件定义清晰，足以确定唯一解。该问题是自包含的，不需要外部信息。\n- **客观性**: 问题陈述使用了精确、客观和技术性的语言，没有歧义或主观性陈述。\n\n该问题没有任何缺陷。它在科学上不是不健全、不完整、矛盾或不适定的。该模型是用于性能分析的标准简化模型，所提供的数值对于现代硬件是现实的。\n\n### 步骤 3：结论与行动\n\n问题陈述有效。将推导完整的解决方案。\n\n### 执行时间的推导\n\n总执行时间 $T$ 由内存操作所花费的时间和算术运算所花费的时间之和决定。关键约束“数据传输与算术运算不重叠”决定了这两个时间分量是相加的。\n$$T = T_{\\text{mem}} + T_{\\text{arith}}$$\n\n我们将根据“时间等于总功除以完成工作的速率”这一原理，分别推导每个分量。\n\n**1. 内存时间 ($T_{\\text{mem}}$)**\n\n- **功**: 必须通过内存总线传输的总数据量。点积运算在两个长度为 $n$ 的数组上进行。问题陈述指出，对于 $n$ 个元素中的每一个，都从内存中读取两个操作数。每个操作数（数组元素）的大小为 $b$ 字节。\n传输的总数据 = (元素数量) $\\times$ (每个元素的操作数) $\\times$ (每个操作数的字节数)。\n$$W_{\\text{mem}} = n \\times 2 \\times b = 2nb \\text{ bytes}$$\n- **速率**: 数据传输的速率是内存带宽，给定为 $BW$ 字节/秒。\n- **时间**: 应用公式 时间 = 功 / 速率：\n$$T_{\\text{mem}} = \\frac{W_{\\text{mem}}}{BW} = \\frac{2nb}{BW}$$\n\n**2. 算术时间 ($T_{\\text{arith}}$)**\n\n- **功**: 浮点运算的总次数。问题明确指出，核心在每次循环迭代中执行一次融合乘加 (FMA) 运算。对于长度为 $n$ 的点积，有 $n$ 次迭代。\n总算术运算次数 = (元素数量) $\\times$ (每个元素的 FMA 次数)。\n$$W_{\\text{arith}} = n \\times 1 = n \\text{ FMAs}$$\n- **速率**: 算术运算的速率是核心的 FMA 吞吐量，给定为 $R$ 次融合乘加/秒。\n- **时间**: 应用公式 时间 = 功 / 速率：\n$$T_{\\text{arith}} = \\frac{W_{\\text{arith}}}{R} = \\frac{n}{R}$$\n\n**3. 总执行时间 ($T$)**\n\n将内存时间和算术时间的表达式结合起来，得到总执行时间 $T$ 的闭式表达式：\n$$T(n, b, BW, R) = T_{\\text{mem}} + T_{\\text{arith}} = \\frac{2nb}{BW} + \\frac{n}{R}$$\n这个表达式可以因式分解以分离出对 $n$ 的依赖：\n$$T(n, b, BW, R) = n \\left( \\frac{2b}{BW} + \\frac{1}{R} \\right)$$\n这就是所要求的总执行时间的闭式表达式。\n\n### 数值计算\n\n现在我们将给定的数值代入推导出的表达式中：\n- $n = 5 \\times 10^7$\n- $b = 8$ 字节\n- $BW = 25 \\times 10^9$ 字节/秒\n- $R = 5 \\times 10^9$ FMA/秒\n\n$$T = (5 \\times 10^7) \\left( \\frac{2 \\times 8}{25 \\times 10^9} + \\frac{1}{5 \\times 10^9} \\right)$$\n为了简化括号内的表达式，我们找到两个分数的公分母，即 $25 \\times 10^9$。\n$$T = (5 \\times 10^7) \\left( \\frac{16}{25 \\times 10^9} + \\frac{5}{25 \\times 10^9} \\right)$$\n$$T = (5 \\times 10^7) \\left( \\frac{16 + 5}{25 \\times 10^9} \\right)$$\n$$T = (5 \\times 10^7) \\left( \\frac{21}{25 \\times 10^9} \\right)$$\n现在，我们进行乘法运算：\n$$T = \\frac{5 \\times 21 \\times 10^7}{25 \\times 10^9}$$\n$$T = \\frac{105 \\times 10^7}{25 \\times 10^9}$$\n将数值部分 ($105 / 25 = 4.2$) 和 10 的幂次部分 ($10^7 / 10^9 = 10^{-2}$) 相除：\n$$T = 4.2 \\times 10^{-2} \\text{ seconds}$$\n$$T = 0.042 \\text{ seconds}$$\n问题要求答案四舍五入到四位有效数字。\n$$T = 0.04200 \\text{ seconds}$$\n用标准科学记数法表示，这是 $4.200 \\times 10^{-2}$ 秒。\n我们来分析每个分量的贡献：\n$T_{\\text{mem}} = \\frac{2 \\times (5 \\times 10^7) \\times 8}{25 \\times 10^9} = \\frac{80 \\times 10^7}{25 \\times 10^9} = \\frac{8 \\times 10^8}{25 \\times 10^9} = 3.2 \\times 10^{-2} \\text{ s} = 0.032 \\text{ s}$。\n$T_{\\text{arith}} = \\frac{5 \\times 10^7}{5 \\times 10^9} = 1 \\times 10^{-2} \\text{ s} = 0.01 \\text{ s}$。\n总时间 $T = 0.032 \\text{ s} + 0.01 \\text{ s} = 0.042 \\text{ s}$。\n计算是一致的。在这种情况下，执行更多地受到内存带宽的限制，而不是算术吞吐量的限制。最终值四舍五入到四位有效数字是 $0.04200$ 秒。",
            "answer": "$$\\boxed{4.200 \\times 10^{-2}}$$"
        },
        {
            "introduction": "理论模型虽然富有洞察力，但一项关键的工程技能是在实际系统中测量性能。本练习模拟了如何使用硬件性能计数器来量化共享内存接口上的压力。你将学习如何将低级别的缓存事件转化为一个高级指标——指令提取流量与数据内存流量的比率，从而为瓶颈提供一个具体的度量值 。",
            "id": "3688132",
            "problem": "一个实现冯·诺依曼（von Neumann）架构的中央处理器（CPU）对指令和数据使用统一的主存储器。进出主存的内存流量是最终的吞吐量瓶颈，因为同一个物理接口必须同时服务于指令提取和数据访问。为了实时监控此共享接口所承受的压力，您需要设计两个字节精确的硬件性能计数器：一个用于指令提取（IF）流量，另一个用于数据内存（MEM）流量，然后用它们来计算一个测量窗口内的瓶颈比率。\n\n假设采用以下广泛使用的一级缓存组织和策略：一个一级指令缓存和一个一级数据缓存，它们的缓存行大小均为 $L$ 字节，数据行采用写回（write-back）策略，并在存储未命中时采用写分配（write-allocate）策略。在这一级，主内存流量的唯一来源是：\n- 指令缓存未命中时的指令缓存行填充，\n- 加载未命中时的数据缓存行填充，\n- 存储写分配时的数据缓存行填充，以及\n- 替换时脏数据缓存行的写回。\n\n每次缓存行填充或写回都在内存接口上传输恰好 $L$ 字节。在某个测量窗口内，一个性能监控单元报告了以下事件计数：\n- 指令缓存行填充次数 $N_{I} = 750$，\n- 因加载未命中导致的数据缓存行填充次数 $N_{DL} = 500$，\n- 因存储写分配导致的数据缓存行填充次数 $N_{DS} = 300$，\n- 脏数据缓存行写回次数 $N_{WB} = 420$，\n并且缓存行大小为 $L = 64$ 字节。\n\n仅从上述架构定义和关于在统一内存接口上引起流量的事件的事实出发，指定计数器更新规则，以在测量窗口期间累积总IF字节数 $B_{IF}$ 和总MEM字节数 $B_{MEM}$。然后，使用定义为同一窗口内指令提取字节数与数据内存字节数之比的 $R$，推导出一个用 $N_{I}$、$N_{DL}$、$N_{DS}$、$N_{WB}$ 和 $L$ 表示的 $R$ 的表达式，并根据所提供的值进行数值计算。将您最终的 $R$ 的数值答案四舍五入到四位有效数字，并以无单位的纯数字形式报告。",
            "solution": "该问题是有效的。这是一个计算机体系结构性能分析中定义明确的问题，基于标准的定义和原理。所有必要的信息都已提供，问题没有矛盾或含糊之处。\n\n目标是为测量指令提取流量和数据内存流量指定硬件计数器更新规则，然后计算这两种流量的比率。该分析基于一组指定的、在冯·诺依曼（von Neumann）架构机器的统一内存接口上引起流量的事件。\n\n设 $B_{IF}$ 为因指令提取产生的内存流量总字节数，设 $B_{MEM}$ 为因数据访问（加载和存储）产生的内存流量总字节数。问题完整地列举了在一级缓存中导致主存流量的事件。每个此类事件都涉及传输一个大小为 $L$ 字节的缓存行。\n\n首先，我们必须将给定的事件分类，确定它们是贡献给 $B_{IF}$ 还是 $B_{MEM}$。\n\n指令提取（IF）流量：\n与指令流相关的唯一流量来源是在指令缓存未命中时从主存填充指令缓存行。问题指出，此类事件有 $N_{I}$ 次。由于每次事件传输 $L$ 字节，因此总的指令提取流量为：\n$$B_{IF} = N_{I} \\times L$$\n\n数据内存（MEM）流量：\n与数据流相关的流量是由在数据缓存中未命中的加载和存储引起的。问题指出了三种对数据内存流量有贡献的不同事件：\n1.  加载未命中时的数据缓存行填充：加载指令在数据缓存中未命中，需要从主存中取回一个缓存行。这类事件的数量是 $N_{DL}$。这会产生 $N_{DL} \\times L$ 字节的内存流量。这是一次从内存读取的操作。\n2.  存储写分配时的数据缓存行填充：存储指令在数据缓存中未命中。“写分配”（write-allocate）策略规定，在执行写操作之前，必须将相应的内存行取入缓存。这类事件的数量是 $N_{DS}$。这会产生 $N_{DS} \\times L$ 字节的内存流量。这也是一次从内存读取的操作。\n3.  脏数据缓存行的写回：数据缓存中一个被修改过（脏）的行被替换出去，以便为新行腾出空间。“写回”（write-back）策略要求将此脏行的内容写回主存。这类事件的数量是 $N_{WB}$。这会产生 $N_{WB} \\times L$ 字节的内存流量。这是一次向内存写入的操作。\n\n总的数据内存流量 $B_{MEM}$ 是这三种事件类型传输的字节数之和：\n$$B_{MEM} = (N_{DL} \\times L) + (N_{DS} \\times L) + (N_{WB} \\times L)$$\n通过提取公因子 $L$，我们得到：\n$$B_{MEM} = (N_{DL} + N_{DS} + N_{WB}) \\times L$$\n\n基于此分析，我们可以指定计数器更新规则。\n\n计数器更新规则：\n-   **$B_{IF}$ 计数器**：用于记录总指令提取字节数的硬件性能计数器 $B_{IF}$，在每次检测到指令缓存行填充事件时，应增加 $L$。在测量窗口结束时，其最终值为 $B_{IF} = N_{I} \\times L$。\n-   **$B_{MEM}$ 计数器**：用于记录总数据内存字节数的硬件性能计数器 $B_{MEM}$，在每次检测到以下任一事件时，应增加 $L$：因加载未命中导致的数据缓存行填充、因存储写分配导致的数据缓存行填充、或脏数据缓存行的写回。在测量窗口结束时，其最终值为 $B_{MEM} = (N_{DL} + N_{DS} + N_{WB}) \\times L$。\n\n$R$ 瓶颈比率的推导：\n问题将比率 $R$ 定义为指令提取字节数与数据内存字节数之比。\n$$R = \\frac{B_{IF}}{B_{MEM}}$$\n代入上面为 $B_{IF}$ 和 $B_{MEM}$ 推导出的表达式：\n$$R = \\frac{N_{I} \\times L}{(N_{DL} + N_{DS} + N_{WB}) \\times L}$$\n缓存行大小 $L$ 作为分子和分母的公因子出现，因此可以消去。这就得出了用事件计数表示的 $R$ 的最终表达式：\n$$R = \\frac{N_{I}}{N_{DL} + N_{DS} + N_{WB}}$$\n值得注意的是，流量的比率等同于内存事务数量的比率，因为每次事务传输相同量的数据，即 $L$ 字节。\n\n数值计算：\n我们已知以下事件计数：\n-   $N_{I} = 750$\n-   $N_{DL} = 500$\n-   $N_{DS} = 300$\n-   $N_{WB} = 420$\n\n$L = 64$ 字节的值对于计算比率 $R$ 并非必需。\n将数值代入 $R$ 的表达式中：\n$$R = \\frac{750}{500 + 300 + 420}$$\n$$R = \\frac{750}{1220}$$\n$$R = \\frac{75}{122}$$\n现在，我们计算其小数值并四舍五入到四位有效数字。\n$$R \\approx 0.614754098...$$\n前四位有效数字是 $6$、$1$、$4$ 和 $7$。第五位有效数字是 $5$，这要求对第四位有效数字进行向上取整。\n$$R \\approx 0.6148$$\n该值表示在测量窗口内，由指令提取产生的内存流量与由数据访问产生的内存流量之比。",
            "answer": "$$\\boxed{0.6148}$$"
        },
        {
            "introduction": "理解和测量瓶颈是第一步，下一步是缓解它。这最后一个练习探讨了一种常见的软件优化技术——创建无分支代码——以减少总线竞争。通过比较一个充满分支的循环与其无分支的等效版本，你将计算出指令提取需求的减少量，从而展示一种在冯·诺依曼机器上提高性能的实用方法 。",
            "id": "3688031",
            "problem": "考虑一台根据冯·诺依曼架构设计的单一共享内存计算机，其中中央处理器（CPU）和内存通过单一共享总线连接。在这种架构中，指令提取和数据访问都通过同一总线，总线需求以传输的字数为单位进行衡量。假设每个周期进行一次总线传输，并且每条指令和每个数据项都恰好占用一个字。没有独立的指令缓存；所有指令提取都使用共享总线。\n\n您正在分析一个逐个元素处理数组的循环。在其原始的分支密集型形式中，每次迭代执行 $k$ 条非分支指令、1 条条件分支，并执行 $d$ 次数据内存传输。由于分支预测不完美，分支预测单元（BPU）以 $m \\in [0,1]$ 的概率错误预测该循环的条件分支。当发生错误预测时，硬件会平均继续沿着错误路径提取 $q$ 个指令字，直到错误预测被解决且流水线被重定向。这些错误路径的指令字通过共享总线传输且不会被重用，因此它们增加了指令提取需求，但没有贡献有效的工作。\n\n您决定将该循环重新设计为无分支版本，以在保留语义的同时减少指令提取需求。该重新设计用一个算术掩码替换了条件分支：为条件计算一个布尔掩码 $b \\in \\{0,1\\}$，并使用 $b$ 来谓词性地应用更新（例如，无条件地计算更新并乘以 $b$，或使用条件传送），从而使控制流不发生分支。假设此转换增加了一条用于掩码计算的非分支指令，移除了分支，并保持数据内存传输不变。因此，每次迭代，无分支版本执行 $k+1$ 条非分支指令，0 个分支，以及 $d$ 次数据内存传输，并且没有错误路径的提取。\n\n为了进行具体评估，取 $k=5$，$d=2$ 和 $q=8$。将循环版本的指令提取总线利用率份额定义为分数\n$$U \\equiv \\frac{\\text{每次迭代传输的指令字数}}{\\text{每次迭代传输的总字数}}。$$\n使用多次迭代的期望值，计算分支密集型循环和无分支循环在指令提取总线利用率份额上的差异，表示为\n$$\\Delta U \\equiv U_{\\text{分支密集型}} - U_{\\text{无分支}}。$$\n请以仅含 $m$ 的单个简化解析表达式的形式提供您的最终答案。不要四舍五入。请以分数或其他不含百分号的封闭形式表达式作答。",
            "solution": "用户希望我解决一个问题。\n\n首先，我将验证问题陈述。\n\n### 第1步：提取已知条件\n- **架构：** 一台冯·诺依曼机器，具有用于指令和数据的单一共享总线。\n- **总线模型：** 每个周期进行一次总线传输，每次传输移动一个字。每条指令和每个数据项都是一个字。不存在指令缓存。\n- **分支密集型循环（每次迭代）：**\n  - 非分支指令：$k$\n  - 条件分支：1\n  - 数据内存传输：$d$\n  - 分支错误预测率：$m \\in [0,1]$\n  - 每次错误预测提取的错误路径指令字数：$q$\n- **无分支循环（每次迭代）：**\n  - 非分支指令：$k+1$\n  - 分支：0\n  - 数据内存传输：$d$\n  - 错误路径提取：0\n- **具体数值：**\n  - $k=5$\n  - $d=2$\n  - $q=8$\n- **度量定义：**\n  - 指令提取的总线利用率份额：$U \\equiv \\frac{\\text{每次迭代传输的指令字数}}{\\text{每次迭代传输的总字数}}$\n- **目标：**\n  - 以仅含 $m$ 的简化解析表达式计算差异 $\\Delta U \\equiv U_{\\text{分支密集型}} - U_{\\text{无分支}}$。\n\n### 第2步：使用提取的已知条件进行验证\n问题陈述在计算机体系结构原理方面具有科学依据，特别是冯·诺依曼模型、性能分析以及与分支错误预测相关的成本。该模型是一个简化（例如，统一的字长，无缓存），但这是教学性能建模中一种标准且有效的方法。该问题是良构的，提供了所有必要的定义和数据（$k, d, q, m$），以得出一个唯一的、有意义的 $\\Delta U$ 解。语言客观而精确。该问题并非无足轻重，因为它需要仔细计算概率性成本。该问题是有效的。\n\n### 第3步：开始求解\n\n求解需要计算分支密集型和无分支型两种循环版本的指令提取总线利用率份额 $U$，然后求出它们的差值 $\\Delta U$。分析应基于每次迭代传输的期望字数。\n\n我们首先分析无分支循环，用下标“无分支”表示。\n每次迭代执行的指令数为 $k+1$。由于每条指令都是一个字，并且必须通过共享总线从内存中提取，所以每次迭代传输的指令字数为：\n$$I_{\\text{无分支}} = k+1$$\n每次迭代的数据内存传输次数为 $d$。所以，传输的数据字数为：\n$$D_{\\text{无分支}} = d$$\n每次迭代在总线上传输的总字数是指令字和数据字之和：\n$$T_{\\text{无分支}} = I_{\\text{无分支}} + D_{\\text{无分支}} = (k+1) + d$$\n因此，无分支循环的指令提取总线利用率份额为：\n$$U_{\\text{无分支}} = \\frac{I_{\\text{无分支}}}{T_{\\text{无分支}}} = \\frac{k+1}{k+1+d}$$\n\n接下来，我们分析分支密集型循环，用下标“分支密集型”表示。此分析必须考虑分支错误预测的概率性。我们计算每次迭代传输的期望字数。\n在正确路径上执行的指令数是 $k$ 条非分支指令加上 1 条分支指令，总共 $k+1$ 条指令。这些指令总是会被提取。\n分支以概率 $m$ 被错误预测，导致从错误路径额外提取 $q$ 个指令字。每次迭代提取的期望错误路径指令字数为 $m \\cdot q$。\n因此，每次迭代传输的期望总指令字数为：\n$$E[I_{\\text{分支密集型}}] = (k+1) + m \\cdot q$$\n数据内存传输不受分支预测影响，保持为常数 $d$。\n$$E[D_{\\text{分支密集型}}] = d$$\n每次迭代在总线上传输的期望总字数是期望指令字和数据字之和：\n$$E[T_{\\text{分支密集型}}] = E[I_{\\text{分支密集型}}] + E[D_{\\text{分支密集型}}] = (k+1) + m \\cdot q + d$$\n分支密集型循环的指令提取总线利用率份额是期望指令字数与期望总字数的比率：\n$$U_{\\text{分支密集型}} = \\frac{E[I_{\\text{分支密集型}}]}{E[T_{\\text{分支密集型}}]} = \\frac{k+1+mq}{k+1+mq+d}$$\n\n现在我们可以计算差值 $\\Delta U = U_{\\text{分支密集型}} - U_{\\text{无分支}}$。\n$$\\Delta U = \\frac{k+1+mq}{k+1+mq+d} - \\frac{k+1}{k+1+d}$$\n问题提供了具体值 $k=5$，$d=2$ 和 $q=8$。将这些代入表达式：\n$$k+1 = 5+1 = 6$$\n$$d = 2$$\n$$mq = m \\cdot 8 = 8m$$\n将这些数值代入 $\\Delta U$ 的方程：\n$$\\Delta U = \\frac{6+8m}{6+8m+2} - \\frac{6}{6+2}$$\n$$\\Delta U = \\frac{6+8m}{8+8m} - \\frac{6}{8}$$\n简化第二项：\n$$\\Delta U = \\frac{6+8m}{8+8m} - \\frac{3}{4}$$\n为了合并这些分数，我们找到一个公分母，即 $8+8m$。\n$$\\Delta U = \\frac{6+8m}{8+8m} - \\frac{3 \\cdot (2+2m)}{4 \\cdot (2+2m)}$$\n$$\\Delta U = \\frac{6+8m}{8+8m} - \\frac{6+6m}{8+8m}$$\n现在，合并分子：\n$$\\Delta U = \\frac{(6+8m) - (6+6m)}{8+8m}$$\n$$\\Delta U = \\frac{6+8m - 6 - 6m}{8+8m}$$\n$$\\Delta U = \\frac{2m}{8+8m}$$\n最后，通过从分子中提取因子 $2$ 和从分母中提取因子 $8$ 来简化分数：\n$$\\Delta U = \\frac{2m}{8(1+m)} = \\frac{m}{4(1+m)}$$\n这就是关于错误预测率 $m$ 的指令提取总线利用率份额差异的最终简化解析表达式。",
            "answer": "$$\\boxed{\\frac{m}{4(1+m)}}$$"
        }
    ]
}