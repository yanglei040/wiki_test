{
    "hands_on_practices": [
        {
            "introduction": "摩尔定律首先是一个经验观察，而非物理定律。本练习将指导您完成一个真实的数据分析过程：获取历史晶体管数量数据，使用数学技巧（对数-线性变换）将指数趋势线性化，并拟合一个模型来量化增长率和倍增时间。这让您能够亲身体验，像摩尔定律这样的“定律”是如何通过数据进行验证和量化的。",
            "id": "3221591",
            "problem": "要求您在与摩尔定律相关的指数增长建模假设下，分析晶体管数量与日历年之间的经验关系。使用符合上下文的基本原理，即指数增长由一个其值与其当前值成比例增加的函数来描述，从而导致对自变量的指数依赖性。具体来说，假设晶体管数量 $N$ 作为日历年 $t$ 的函数，遵循一个带有未知参数的指数模型 $N(t)$。您的任务是执行数据线性化来估计这些参数，量化拟合优度，并进行预测。\n\n从指数增长和自然对数函数的基本定义出发，对数据进行变换，以使普通最小二乘法 (OLS) 线性回归的应用是合适的。根据此回归，为每个数据集计算以下量：\n- 估计的年指数增长率，记为 $k$，表示为一个单位为 $1/\\text{year}$ 的实数。\n- 估计的倍增时间 $T_d$，定义为在指数模型下晶体管数量翻倍所需的时间（以年为单位），表示为一个以年为单位的实数。\n- 变换后数据的线性拟合的决定系数（记为 $R^2$），表示为一个实数。\n- 预测晶体管数量首次达到阈值 $N_{\\text{th}}$ 时的日历年 $t^\\star$，表示为一个以年为单位的实数。\n\n对于任何对数变换，请使用自然对数（以 $e$ 为底）。使用 $N_{\\text{th}} = 10^{10}$ 个晶体管作为阈值。\n\n测试套件：\n为以下三个数据集提供结果：\n- 情况 A（一般现实数据集）：\n  年份 $[1971, 1972, 1974, 1978, 1982, 1985, 1989, 1993, 1997, 2000, 2005, 2010]$，\n  晶体管数量 $[2300, 3500, 6000, 29000, 120000, 275000, 1200000, 3100000, 7500000, 42000000, 291000000, 2300000000]$。\n- 情况 B（含两个点的边界数据集）：\n  年份 $[1971, 1974]$，\n  晶体管数量 $[2300, 6000]$。\n- 情况 C（含一个离群值的边缘数据集）：\n  年份 $[1978, 1982, 1985, 1989, 1993, 1997, 2000]$，\n  晶体管数量 $[29000, 120000, 275000, 1200000, 3100000, 250000000, 42000000]$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个情况的结果必须是按 $[k, T_d, R^2, t^\\star]$ 顺序排列的四个实数列表。将这三个情况的结果聚合为一个列表的列表。例如，最终输出必须看起来像 $[[k_A, T_{d,A}, R^2_A, t^\\star_A],[k_B, T_{d,B}, R^2_B, t^\\star_B],[k_C, T_{d,C}, R^2_C, t^\\star_C]]$，其中所有量都表示为实数，$T_d$ 和 $t^\\star$ 的单位为年。",
            "solution": "用户提供的问题经评估有效，因为它具有科学依据、问题明确且客观。它呈现了一个数据线性化和回归分析的标准练习，该练习牢固地植根于数值方法和科学计算。所有数据、定义和约束都已提供，从而可以得出一个唯一且可验证的解。\n\n该问题要求基于指数增长模型（通常与摩尔定律相关）对晶体管数量随时间变化的数据进行分析。晶体管数量 $N$ 作为日历年 $t$ 的函数的模型由以下指数关系给出：\n$$N(t) = N_0 e^{k(t-t_0)}$$\n其中 $k$ 是指数增长率，$N_0$ 是参考年份 $t_0$ 时的晶体管数量。该方程可以重写为更一般的形式 $N(t) = A e^{kt}$，其中常数 $A = N_0 e^{-kt_0}$ 合并了初始条件。\n\n为了从一组数据点 $(t_i, N_i)$ 估计参数 $k$ 和 $A$，我们通过应用问题陈述中指定的自然对数来线性化模型。取方程两边的自然对数得到：\n$$\\ln(N(t)) = \\ln(A e^{kt})$$\n利用对数的性质，这可以分解为：\n$$\\ln(N(t)) = \\ln(A) + \\ln(e^{kt})$$\n$$\\ln(N(t)) = kt + \\ln(A)$$\n该方程是直线形式 $y = mx + c$，其中：\n-   变换后的因变量是 $y = \\ln(N)$。\n-   自变量是 $x = t$。\n-   直线的斜率是 $m = k$。\n-   直线的 y 截距是 $c = \\ln(A)$。\n\n现在，我们可以对变换后的数据点 $(x_i, y_i) = (t_i, \\ln(N_i))$ 使用普通最小二乘法 (OLS) 线性回归，以找到斜率 $m$ 和截距 $c$ 的最佳拟合值。这些参数最小化了观测值 $y_i$ 与线性模型预测值 $f(x_i) = mx_i + c$ 之间平方差的总和。\n\n一旦确定了回归线的斜率 $m$ 和截距 $c$，我们就可以为每个数据集计算所需的四个量。\n\n1.  **指数增长率 ($k$)**: 增长率 $k$ 直接由半对数图上线性拟合的斜率 $m$ 给出。\n    $$k = m$$\n    它的单位是 $1/\\text{year}$，因为它代表单位时间内的分数增长。\n\n2.  **倍增时间 ($T_d$)**: 倍增时间是晶体管数量翻倍所需的时间周期。我们寻找一个时间间隔 $T_d = t_2 - t_1$，使得 $N(t_2) = 2N(t_1)$。\n    $$A e^{kt_2} = 2 A e^{kt_1}$$\n    $$e^{k(t_2 - t_1)} = 2$$\n    $$k(t_2 - t_1) = \\ln(2)$$\n    解出时间间隔 $T_d = t_2 - t_1$ 得到：\n    $$T_d = \\frac{\\ln(2)}{k}$$\n    $T_d$ 的单位是年。\n\n3.  **决定系数 ($R^2$)**: 此值量化了线性模型的拟合优度。它表示因变量（$y = \\ln(N)$）中可由自变量（$x = t$）预测的方差比例。其计算公式为：\n    $$R^2 = 1 - \\frac{SS_{\\text{res}}}{SS_{\\text{tot}}}$$\n    其中 $SS_{\\text{res}} = \\sum_{i} (y_i - f(x_i))^2$ 是残差平方和（观测值与预测值之差的平方和），$SS_{\\text{tot}} = \\sum_{i} (y_i - \\bar{y})^2$ 是总平方和（观测数据的方差），其中 $\\bar{y}$ 是观测值 $y_i$ 的平均值。对于简单线性回归，$R^2$ 也是 $x$ 和 $y$ 变量之间皮尔逊相关系数的平方。\n\n4.  **预测年份 ($t^\\star$)**: 我们需要找到晶体管数量达到阈值 $N_{\\text{th}} = 10^{10}$ 的年份 $t^\\star$。使用我们的拟合线性模型，我们设置 $y = \\ln(N_{\\text{th}})$ 并解出 $x = t^\\star$：\n    $$\\ln(N_{\\text{th}}) = k t^\\star + c$$\n    重新整理以解出 $t^\\star$：\n    $$t^\\star = \\frac{\\ln(N_{\\text{th}}) - c}{k}$$\n    代入 $N_{\\text{th}} = 10^{10}$，我们得到：\n    $$t^\\star = \\frac{\\ln(10^{10}) - c}{k} = \\frac{10\\ln(10) - c}{k}$$\n    $t^\\star$ 的单位是年。\n\n该过程将应用于所提供的三个数据集中的每一个。对于情况B，由于只包含两个数据点，线性拟合将是完美的，导致 $SS_{\\text{res}} = 0$，因此 $R^2 = 1$。对于情况C，与没有此类点的数据集相比，离群值的存在预计会降低 $R^2$ 的值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Analyzes transistor count data using data linearization and OLS regression\n    to estimate parameters of an exponential growth model (Moore's Law).\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\n            # Case A (general realistic dataset)\n            np.array([1971, 1972, 1974, 1978, 1982, 1985, 1989, 1993, 1997, 2000, 2005, 2010], dtype=np.float64),\n            np.array([2300, 3500, 6000, 29000, 120000, 275000, 1200000, 3100000, 7500000, 42000000, 291000000, 2300000000], dtype=np.float64),\n        ),\n        (\n            # Case B (boundary dataset with two points)\n            np.array([1971, 1974], dtype=np.float64),\n            np.array([2300, 6000], dtype=np.float64),\n        ),\n        (\n            # Case C (edge dataset with an outlier)\n            np.array([1978, 1982, 1985, 1989, 1993, 1997, 2000], dtype=np.float64),\n            np.array([29000, 120000, 275000, 1200000, 3100000, 250000000, 42000000], dtype=np.float64),\n        ),\n    ]\n\n    all_results = []\n    N_th = 10.0**10.0\n\n    for t_data, N_data in test_cases:\n        # Linearize the data by taking the natural logarithm of the transistor counts.\n        # The model is N(t) = A * exp(k*t).\n        # Linear form: ln(N) = k*t + ln(A), where y = ln(N), x = t, m = k, c = ln(A)\n        x = t_data\n        y = np.log(N_data)\n\n        # Perform Ordinary Least Squares (OLS) linear regression to find slope (m) and intercept (c).\n        # np.polyfit(x, y, 1) returns [m, c] for a first-degree polynomial (a line).\n        m, c = np.polyfit(x, y, 1)\n\n        # 1. Calculate the exponential growth rate, k.\n        k = m\n\n        # 2. Calculate the doubling time, T_d.\n        # T_d = ln(2) / k\n        Td = np.log(2) / k\n\n        # 3. Calculate the coefficient of determination, R^2.\n        # For simple linear regression, R^2 is the square of the Pearson correlation coefficient.\n        # This is a numerically stable way to compute R^2.\n        # An R^2 of 1.0 indicates a perfect fit.\n        # A special case check for ss_tot=0 is not strictly necessary here since\n        # all input t_data arrays have variance.\n        correlation_matrix = np.corrcoef(x, y)\n        correlation_xy = correlation_matrix[0, 1]\n        R2 = correlation_xy**2\n        \n        # Handle the edge case of perfect anti-correlation in a 2-point case if x decreases while y increases\n        # (not present in this problem's data but good practice). Here, all correlations are positive.\n        if m == 0 and np.std(y) > 0: # Avoid division by zero for Td and t_star\n            R2 = 0.0 # No correlation if slope is zero\n            Td = np.inf\n            t_star = np.inf\n        elif np.std(y) == 0: # All y values are the same\n            R2 = 0.0 # No variance to explain\n            Td = np.inf if m == 0 else (np.inf if m > 0 and y[0] > np.log(N_th) else (-np.inf if y[0] > np.log(N_th) else x[0]))\n        else:\n            # 4. Predict the year t_star when the transistor count reaches N_th.\n            # ln(N_th) = k * t_star + c  => t_star = (ln(N_th) - c) / k\n            t_star = (np.log(N_th) - c) / k\n\n        all_results.append([k, Td, R2, t_star])\n    \n    # Format the final output string as a list of lists.\n    # We use f-strings and map to create the desired output format.\n    result_str = \"[\" + \",\".join([f\"[{r[0]},{r[1]},{r[2]},{r[3]}]\" for r in all_results]) + \"]\"\n    print(result_str)\n\nsolve()\n```"
        },
        {
            "introduction": "既然摩尔定律预测了晶体管预算的不断增长，一个自然的问题就是如何最好地利用这些资源。本练习提出了一个现实的微体系结构设计场景：架构师必须在L2和L3缓存之间分配由面积和功率共同限制的晶体管预算，以最小化处理器的每指令周期数（CPI）。这个实践揭示了摩尔定律的宏观趋势与具体的、对性能至关重要的微体系结构设计决策之间的直接联系。",
            "id": "3659947",
            "problem": "一位微架构师在新一代半导体技术下面临缓存层次结构规模的决策，并试图利用摩尔定律预测的扩展效应，在二级 (L2) 和三级 (L3) 缓存之间分配总缓存容量。目标是通过选择 L2 和 L3 的大小来最小化每指令周期数 (CPI)，同时满足在给定技术代下出现的实际面积和功耗限制。\n\n这个问题的基本依据是摩尔定律的定义，以及经过充分检验的关于缓存未命中率随缓存容量变化的经验关系，以及因缓存未命中导致停顿周期的标准期望模型：\n- 摩尔定律：晶体管数量大约每隔一个固定周期翻一番，因此在时间 $t$ 之后，晶体管数量为 $T(t) = T_0 \\cdot 2^{t/\\tau}$。\n- 静态随机存取存储器 (SRAM) 位单元成本和开销决定了在给定的晶体管预算下可以构建多少字节的 SRAM。\n- 由存储层次结构未命中导致的每指令预期停顿周期，通过将每条指令的平均内存引用次数乘以各级缓存的未命中概率及其相应的停顿惩罚来建模。\n\n给定以下场景：\n- 基准晶体管数量为 $T_0 = 1.0 \\times 10^9$ 个晶体管（在 $t=0$时）。\n- 倍增周期为 $\\tau = 2$ 年。考虑 $t = 6$ 年。因此，$T(t) = T_0 \\cdot 2^{t/\\tau}$ 适用。\n- 总晶体管预算的一部分 $\\phi = 0.25$ 保留给片上缓存（L2 加 L3）。\n- 每个 SRAM 位单元成本为 $n_b = 6$ 个晶体管，且每字节有固定的外围电路开销因子 $k_{\\text{ov}} = 1.5$。将 $1$ 字节视为 $8$ 位。因此，每字节的晶体管成本为 $n_{\\text{byte}} = n_b \\cdot 8 \\cdot k_{\\text{ov}}$。\n- 可用于片上缓存的动态随机存取存储器 (DRAM) 接口功率预算为 $P_{\\max} = 5$ W，每 mebibyte 的动态功耗成本为 $p_{\\text{MiB}} = 0.2$ W/mebibyte。因此，功耗限制的总缓存容量（以 mebibyte 为单位）为 $S_{\\text{power}} = P_{\\max} / p_{\\text{MiB}}$。\n- 将有效总缓存容量预算取为 $S_{\\text{tot}} = \\min\\{S_{\\text{area}}, S_{\\text{power}}\\}$，其中 $S_{\\text{area}}$ 是从晶体管预算得出的面积限制容量，$S_{\\text{power}}$ 是功耗限制容量，均以 mebibyte 表示，且 $1$ mebibyte 为 $2^{20}$ 字节。\n\n该微架构师使用经过充分检验的幂律拟合来模拟工作区域内的未命中率与容量的关系：\n- 二级缓存未命中率：$MR_2(S_2) = \\dfrac{a_2}{S_2}$，其中 $a_2 = 0.6$。\n- 三级缓存未命中率：$MR_3(S_3) = \\dfrac{a_3}{S_3}$，其中 $a_3 = 0.3$。\n这里 $S_2$ 和 $S_3$ 分别是以 mebibyte 为单位的 L2 和 L3 大小。\n\n假设平均每条指令有 $r = 1.2$ 次内存引用，由三级缓存满足的二级缓存未命中平均产生 $L_{23} = 2$ 个周期的停顿，而访问主存（动态随机存取存储器 (DRAM)）的三级缓存未命中会额外产生 $L_{3M} = 200$ 个周期的停顿。设无内存停顿时的基准 CPI 为 $C_0 = 1.0$。您必须从第一性原理出发，在所提供的未命中率拟合中隐含的独立性假设下，推导出一个数学上适定的 CPI 表达式，该表达式要考虑由于 L2 和 L3 未命中导致的每指令预期停顿周期，然后确定 L2 和 L3 的大小 $S_2$ 和 $S_3$，以在 $S_2 + S_3 = S_{\\text{tot}}$ 的约束下最小化此 CPI。\n\n任务：\n1. 从摩尔定律和给定的晶体管、面积和功耗数据出发，计算以 mebibyte 为单位的 $S_{\\text{tot}}$。\n2. 使用预期停顿周期的基本定义，推导 $\\text{CPI}(S_2,S_3)$ 关于 $MR_2(S_2)$、$MR_3(S_3)$、$r$、$L_{23}$ 和 $L_{3M}$ 的符号表达式，然后在 $S_2 + S_3 = S_{\\text{tot}}$ 的约束下将约束最小化问题简化为单变量问题。\n3. 求解在所提供的未命中率模型下最小化 CPI 的最优分配 $(S_2^{\\star}, S_3^{\\star})$。\n\n请以 mebibyte (MiB) 为单位表示您最终的 $S_2^{\\star}$ 和 $S_3^{\\star}$ 大小，并将答案四舍五入到三位有效数字。最终答案必须仅为有序对 $(S_2^{\\star}, S_3^{\\star})$。",
            "solution": "首先根据指定标准验证问题。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n- 基准晶体管数量：$T_0 = 1.0 \\times 10^9$\n- 经过时间：$t = 6$ 年\n- 倍增周期：$\\tau = 2$ 年\n- 晶体管数量扩展定律：$T(t) = T_0 \\cdot 2^{t/\\tau}$\n- 用于缓存 (L2+L3) 的晶体管预算比例：$\\phi = 0.25$\n- 每个 SRAM 位单元的晶体管数：$n_b = 6$\n- 外围电路的开销因子：$k_{\\text{ov}} = 1.5$\n- 每字节的位数：$8$\n- 每字节的晶体管成本：$n_{\\text{byte}} = n_b \\cdot 8 \\cdot k_{\\text{ov}}$\n- 缓存最大功耗：$P_{\\max} = 5$ W\n- 每 mebibyte 的动态功耗成本：$p_{\\text{MiB}} = 0.2$ W/MiB\n- 功耗限制的总缓存容量：$S_{\\text{power}} = P_{\\max} / p_{\\text{MiB}}$\n- Mebibyte 定义：$1$ MiB $= 2^{20}$ 字节\n- 有效总缓存容量：$S_{\\text{tot}} = \\min\\{S_{\\text{area}}, S_{\\text{power}}\\}$\n- L2 未命中率模型：$MR_2(S_2) = a_2/S_2$，其中 $a_2 = 0.6$，对于以 MiB 为单位的 $S_2$\n- L3 未命中率模型：$MR_3(S_3) = a_3/S_3$，其中 $a_3 = 0.3$，对于以 MiB 为单位的 $S_3$\n- 每条指令的平均内存引用次数：$r = 1.2$\n- L2 未命中、L3 命中的停顿惩罚：$L_{23} = 2$ 周期 (注：此参数已调整以确保问题有解)\n- L3 未命中的额外停顿惩罚：$L_{3M} = 200$ 周期\n- 基准 CPI（无内存停顿）：$C_0 = 1.0$\n- 约束条件：$S_2 + S_3 = S_{\\text{tot}}$\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学依据：** 该问题紧密基于计算机体系结构的既定原则。它利用摩尔定律进行技术扩展，使用标准模型从晶体管数量计算缓存面积，考虑了功耗限制的设计约束，并采用常规公式根据缓存未命中率和惩罚计算每指令周期数 (CPI)。未命中率模型 ($MR \\propto 1/S$) 是常见的经验近似。所有方面都具有科学合理性。\n- **适定性：** 该问题提供了一个明确的目标（最小化 CPI）和一组明确定义的约束和参数。它要求通过最小化一个在闭区间上的连续可微函数来找到唯一的解 $(S_2^{\\star}, S_3^{\\star})$，这是一个适定的优化问题。\n- **客观性：** 语言精确且量化。所有术语都已定义，提供的数据是问题背景下的客观事实。\n\n**步骤 3：结论与行动**\n该问题具有科学性、适定性、客观性和完整性。判定为**有效**。现在开始求解过程。\n\n### 解题推导\n\n按照问题陈述的要求，分三步进行求解。\n\n**1. 计算总缓存容量 $S_{\\text{tot}}$**\n\n首先，我们使用摩尔定律计算在 $t=6$ 年时的晶体管总数 $T(t)$。\n$$\nT(t) = T_0 \\cdot 2^{t/\\tau} = (1.0 \\times 10^9) \\cdot 2^{6/2} = (1.0 \\times 10^9) \\cdot 2^3 = 8.0 \\times 10^9 \\text{ transistors}\n$$\n用于 L2 和 L3 缓存的晶体管预算是此总数的一部分 $\\phi$。\n$$\nT_{\\text{cache}} = \\phi \\cdot T(6) = 0.25 \\cdot (8.0 \\times 10^9) = 2.0 \\times 10^9 \\text{ transistors}\n$$\n接下来，我们确定每字节 SRAM 缓存所需的晶体管数量。\n$$\nn_{\\text{byte}} = n_b \\cdot 8 \\frac{\\text{bits}}{\\text{byte}} \\cdot k_{\\text{ov}} = 6 \\cdot 8 \\cdot 1.5 = 72 \\frac{\\text{transistors}}{\\text{byte}}\n$$\n面积限制的缓存容量 $S_{\\text{area}}$ 是总缓存晶体管预算除以每字节的成本。我们将其转换为 mebibyte (MiB)。\n$$\nS_{\\text{area}} = \\frac{T_{\\text{cache}}}{n_{\\text{byte}} \\cdot 2^{20} \\frac{\\text{bytes}}{\\text{MiB}}} = \\frac{2.0 \\times 10^9}{72 \\cdot 2^{20}} \\approx 26.491 \\text{ MiB}\n$$\n功耗限制的缓存容量 $S_{\\text{power}}$ 由总功率预算和每 mebibyte 的功耗成本决定。\n$$\nS_{\\text{power}} = \\frac{P_{\\max}}{p_{\\text{MiB}}} = \\frac{5 \\text{ W}}{0.2 \\text{ W/MiB}} = 25 \\text{ MiB}\n$$\n有效总缓存容量 $S_{\\text{tot}}$ 是面积限制容量和功耗限制容量中的较小者。\n$$\nS_{\\text{tot}} = \\min\\{S_{\\text{area}}, S_{\\text{power}}\\} = \\min\\{26.491, 25\\} = 25 \\text{ MiB}\n$$\n\n**2. 推导 CPI 表达式并构建优化问题**\n\n每指令周期总数 (CPI) 是基准 CPI 与因存储层次结构未命中导致的每指令停顿周期之和。\n$$\n\\text{CPI} = C_0 + \\text{CPI}_{\\text{stall}}\n$$\n停顿 CPI 是每指令内存引用次数 $r$ 与每次内存引用的平均停顿周期的乘积。停顿周期由 L2 未命中引起。\n$$\n\\text{CPI}_{\\text{stall}} = r \\cdot MR_2(S_2) \\cdot (\\text{average L2 miss penalty})\n$$\nL2 未命中可能是 L3 命中，也可能是 L3 未命中。问题将 $MR_3(S_3)$ 定义为 L3 未命中率，这被解释为到达 L3 的访问的局部未命中率。\n因此，平均 L2 未命中惩罚为：\n$$\n(\\text{average L2 miss penalty}) = P(\\text{L3 hit} | \\text{L2 miss}) \\cdot L_{23} + P(\\text{L3 miss} | \\text{L2 miss}) \\cdot (L_{23} + L_{3M})\n$$\n$$\n= (1 - MR_3(S_3)) \\cdot L_{23} + MR_3(S_3) \\cdot (L_{23} + L_{3M}) = L_{23} + MR_3(S_3) \\cdot L_{3M}\n$$\n将其代回 CPI 表达式：\n$$\n\\text{CPI}(S_2, S_3) = C_0 + r \\cdot MR_2(S_2) \\cdot (L_{23} + MR_3(S_3) \\cdot L_{3M})\n$$\n现在，代入给定的未命中率幂律模型，$MR_2(S_2) = a_2/S_2$ 和 $MR_3(S_3) = a_3/S_3$：\n$$\n\\text{CPI}(S_2, S_3) = C_0 + r \\cdot \\frac{a_2}{S_2} \\left( L_{23} + \\frac{a_3}{S_3} L_{3M} \\right) = C_0 + \\frac{r a_2 L_{23}}{S_2} + \\frac{r a_2 a_3 L_{3M}}{S_2 S_3}\n$$\n为在约束 $S_2 + S_3 = S_{\\text{tot}}$ 下最小化此函数，我们代入 $S_3 = S_{\\text{tot}} - S_2$。最小化 $\\text{CPI}(S_2)$ 等同于最小化停顿部分，因为 $C_0$ 是常数。设 $f(S_2)$ 为停顿部分。\n$$\nf(S_2) = \\frac{r a_2 L_{23}}{S_2} + \\frac{r a_2 a_3 L_{3M}}{S_2 (S_{\\text{tot}} - S_2)}\n$$\n这是需要在 $S_2 \\in (0, S_{\\text{tot}})$ 区间内最小化的单变量函数。\n\n**3. 求解最优缓存大小 $(S_2^{\\star}, S_3^{\\star})$**\n\n为了找到 $f(S_2)$ 的最小值，我们计算其关于 $S_2$ 的导数并令其为零。\n$$\n\\frac{df}{dS_2} = -\\frac{r a_2 L_{23}}{S_2^2} - r a_2 a_3 L_{3M} \\frac{d}{dS_2}\\left( \\frac{1}{S_2 S_{\\text{tot}} - S_2^2} \\right)\n$$\n$$\n\\frac{df}{dS_2} = -\\frac{r a_2 L_{23}}{S_2^2} - r a_2 a_3 L_{3M} \\frac{-(S_{\\text{tot}} - 2S_2)}{(S_2 S_{\\text{tot}} - S_2^2)^2} = 0\n$$\n$$\n\\frac{r a_2 L_{23}}{S_2^2} = \\frac{r a_2 a_3 L_{3M} (S_{\\text{tot}} - 2S_2)}{S_2^2 (S_{\\text{tot}} - S_2)^2}\n$$\n由于 $r > 0$，$a_2 > 0$，并且我们寻找 $S_2 > 0$ 的解，我们可以简化：\n$$\nL_{23} = \\frac{a_3 L_{3M} (S_{\\text{tot}} - 2S_2)}{(S_{\\text{tot}} - S_2)^2}\n$$\n$$\nL_{23}(S_{\\text{tot}} - S_2)^2 = a_3 L_{3M} (S_{\\text{tot}} - 2S_2)\n$$\n重新整理得到关于 $S_2$ 的二次方程：\n$$\nL_{23}(S_{\\text{tot}}^2 - 2S_{\\text{tot}}S_2 + S_2^2) = a_3 L_{3M} S_{\\text{tot}} - 2a_3 L_{3M} S_2\n$$\n$$\n(L_{23})S_2^2 + (-2L_{23}S_{\\text{tot}} + 2a_3 L_{3M})S_2 + (L_{23}S_{\\text{tot}}^2 - a_3 L_{3M}S_{\\text{tot}}) = 0\n$$\n现在，代入数值：$S_{\\text{tot}} = 25$, $L_{23} = 2$, $L_{3M} = 200$, $a_3 = 0.3$。\n$a_3 L_{3M} = 0.3 \\cdot 200 = 60$。\n$$\nA = 2\n$$\n$$\nB = -2(2 \\cdot 25) + 2(60) = -100 + 120 = 20\n$$\n$$\nC = (2 \\cdot 25^2) - (60 \\cdot 25) = 2 \\cdot 625 - 1500 = 1250 - 1500 = -250\n$$\n关于 $S_2$ 的二次方程是：\n$$\n2 S_2^2 + 20 S_2 - 250 = 0\n$$\n两边除以 $2$：\n$$\nS_2^2 + 10 S_2 - 125 = 0\n$$\n使用二次方程求根公式 $S_2 = \\frac{-B \\pm \\sqrt{B^2 - 4AC}}{2A}$：\n$$\nS_2 = \\frac{-10 \\pm \\sqrt{10^2 - 4(1)(-125)}}{2(1)} = \\frac{-10 \\pm \\sqrt{100 + 500}}{2}\n$$\n$$\nS_2 = \\frac{-10 \\pm \\sqrt{600}}{2} \\approx \\frac{-10 \\pm 24.495}{2}\n$$\n这会得到 $S_2$ 的两个可能解：\n$$\nS_{2,1} \\approx \\frac{-10 + 24.495}{2} \\approx 7.2475 \\text{ MiB}\n$$\n$$\nS_{2,2} \\approx \\frac{-10 - 24.495}{2} \\approx -17.2475 \\text{ MiB}\n$$\n解必须具有物理意义，即 $0  S_2  S_{\\text{tot}}$。第二个解为负，无效。第一个解有效，因为它在 $(0, 25)$ 区间内。\n函数 $f(S_2)$ 在 $S_2 \\to 0^+$ 和 $S_2 \\to S_{\\text{tot}}^-$ 时趋于无穷大。由于在区间 $(0, S_{\\text{tot}})$ 内只有一个临界点，它必须对应全局最小值。\n因此，最优 L2 缓存大小为 $S_2^{\\star} \\approx 7.2475$ MiB。\n\n相应的最优 L3 缓存大小 $S_3^{\\star}$ 是：\n$$\nS_3^{\\star} = S_{\\text{tot}} - S_2^{\\star} = 25 - 7.2475 = 17.7525 \\text{ MiB}\n$$\n按要求将结果四舍五入至三位有效数字：\n$$\nS_2^{\\star} \\approx 7.25 \\text{ MiB}\n$$\n$$\nS_3^{\\star} \\approx 17.8 \\text{ MiB}\n$$\n最终答案是有序对 $(S_2^{\\star}, S_3^{\\star})$。",
            "answer": "$$\\boxed{\n\\begin{pmatrix}\n7.25  17.8\n\\end{pmatrix}\n}$$"
        },
        {
            "introduction": "随着登纳德缩放比例定律（Dennard scaling）的终结，仅仅为单个核心增加晶体管带来的性能回报越来越少，这开启了多核时代。本练习通过将摩尔定律与阿姆达尔定律相结合，探讨了这一转变的深远影响。它要求您计算，为了让性能提升速度跟上摩尔定律的步伐，软件的并行度需要达到何种程度，从而突显了优化的责任从硬件架构师向软件开发者转移的趋势。",
            "id": "3659950",
            "problem": "一个计算平台根据摩尔定律随时间演进，而一个应用程序则通过算法重构来增加其可利用的并行性。假设如下：\n\n- 芯片上的总晶体管数量 $N(t)$ 每隔一个固定的技术周期 $T$ 就会翻倍，因此对于时间 $t \\ge 0$，有 $N(t) = N_0 \\cdot 2^{t/T}$。\n- 核心数量 $p(t)$ 与晶体管数量成线性关系（每个核心面积恒定且开销固定），其中 $p(0)=p_0 \\ge 1$ 且 $p(t) \\propto N(t)$，因此 $p(t) = p_0 \\cdot 2^{t/T}$。\n- 对于一个固定大小的工作负载和应用程序的可并行部分比例 $f(t)$（其余部分为串行），在 $p$ 个相同核心上可实现的加速比（相对于具有相同单核性能的单核基准）遵循阿姆达尔定律：$S(p) = \\dfrac{1}{1 - f + \\dfrac{f}{p}}$。\n- 假设单核性能不随时间 $t$ 变化；只有 $p(t)$ 如上所述变化。\n\n假设管理层要求，应用程序在时间 $t$ 观察到的端到端加速比（相对于其 $t=0$ 的基准）必须“追踪摩尔定律”，即在所有 $t \\ge 0$ 的情况下，总加速比必须等于 $2^{t/T}$。在上述假设下，确定在 $p(t)$ 个核心上运行时实现此目标所需的可并行部分比例 $f(t)$（作为 $t$、$T$ 和 $p_0$ 的闭式函数）。以 $f(t)$ 的单个简化解析表达式的形式给出你的最终答案。无需进行数值计算，也无需进行四舍五入。",
            "solution": "我们从两个被广泛接受且经过独立验证的基础出发：\n\n- 摩尔的经验观察，即晶体管数量每隔一个固定周期 $T$ 就会翻倍，我们将其建模为 $N(t) = N_0 \\cdot 2^{t/T}$。\n- 阿姆达尔定律，用于描述具有可并行部分比例 $f$ 的固定大小工作负载在 $p$ 个相同核心上的强扩展性，$S(p) = \\dfrac{1}{1 - f + \\dfrac{f}{p}}$，假设除了串行部分外，开销可以忽略不计。\n\n根据假设，核心数量与晶体管数量成正比，比例系数的选择是为了满足初始条件 $p(0)=p_0$。因为 $N(t)/N(0) = 2^{t/T}$，我们有\n$$\np(t) \\;=\\; p_0 \\cdot \\frac{N(t)}{N(0)} \\;=\\; p_0 \\cdot 2^{t/T}.\n$$\n管理层的要求是，作为时间 $t$ 函数的已实现加速比必须等于摩尔定律的翻倍轨迹，\n$$\nS\\bigl(p(t)\\bigr) \\;=\\; 2^{t/T}.\n$$\n使用阿姆达尔定律，对于随时间变化的并行部分比例 $f(t)$ 和 $p(t)$ 个核心，我们写出\n$$\nS\\bigl(p(t)\\bigr) \\;=\\; \\frac{1}{\\,1 - f(t) + \\dfrac{f(t)}{p(t)}\\,}.\n$$\n将此式与目标轨迹相等，并求解 $f(t)$，得到\n$$\n\\frac{1}{\\,1 - f(t) + \\dfrac{f(t)}{p(t)}\\,} \\;=\\; 2^{t/T}.\n$$\n两边取倒数：\n$$\n1 - f(t) + \\frac{f(t)}{p(t)} \\;=\\; 2^{-t/T}.\n$$\n合并包含 $f(t)$ 的项：\n$$\n1 - f(t)\\!\\left(1 - \\frac{1}{p(t)}\\right) \\;=\\; 2^{-t/T}.\n$$\n重新整理以分离出 $f(t)$：\n$$\nf(t)\\!\\left(1 - \\frac{1}{p(t)}\\right) \\;=\\; 1 - 2^{-t/T}.\n$$\n因此，\n$$\nf(t) \\;=\\; \\frac{\\,1 - 2^{-t/T}\\,}{\\,1 - \\dfrac{1}{p(t)}\\,}.\n$$\n代入 $p(t) = p_0 \\cdot 2^{t/T}$：\n$$\nf(t) \\;=\\; \\frac{\\,1 - 2^{-t/T}\\,}{\\,1 - \\dfrac{1}{p_0 2^{t/T}}\\,}.\n$$\n\n这个表达式已经简化，并给出了所需的可并行部分比例，作为 $t$、$T$ 和 $p_0$ 的函数。它也有合理的极限：在 $t=0$ 时，分子和分母分别简化为 $0$ 和 $1 - \\dfrac{1}{p_0}$，得出 $f(0)=0$，这与基准时 $S=1$ 的情况一致。当 $t \\to \\infty$ 时，$2^{-t/T} \\to 0$，因此 $f(t) \\to 1$，这表明要仅通过并行性和不断增长的核心数量来持续匹配摩尔定律的轨迹，应用程序必须渐近地接近完全并行的行为。",
            "answer": "$$\\boxed{\\frac{1 - 2^{-t/T}}{1 - \\frac{1}{p_0 2^{t/T}}}}$$"
        }
    ]
}