{
    "hands_on_practices": [
        {
            "introduction": "Truth tables are not just for defining functions; they are powerful tools for reasoning about system behavior. This practice explores how a simple truth table is the foundation for Triple Modular Redundancy (TMR), a key technique in designing fault-tolerant systems. By defining a 3-input majority voter, you will see firsthand how logic can be used to mask errors and build reliable hardware from potentially unreliable components .",
            "id": "3686334",
            "problem": "In a fault-tolerant datapath using Triple Modular Redundancy (TMR), three nominally identical modules produce binary outputs $A$, $B$, and $C$ that are combined by a $3$-input majority voter $M(A,B,C)$. By definition, a majority voter outputs $1$ if and only if at least $2$ of its inputs are $1$, and outputs $0$ otherwise. Using only fundamental definitions from Boolean algebra and the method of truth tables (enumerating all input combinations and identifying when the output is $1$), complete the following tasks:\n- Construct the truth table for $M(A,B,C)$ from first principles and from it obtain a minimal sum-of-products Boolean implementation.\n- Analyze the effect on the realized function when input $A$ is stuck-at-$0$ and when input $A$ is stuck-at-$1$ by substituting the constant into your implementation and simplifying using Boolean algebra.\n- Using your results and the definition of TMR, reason whether a single stuck-at fault on one module’s output can be fully masked by the voter when the other two modules are fault-free and identical for all input combinations.\n\nSelect all statements that are correct:\n\nA. The minimal sum-of-products implementation of the majority voter is $M(A,B,C)=(A \\land B) \\lor (B \\land C) \\lor (A \\land C)$.\n\nB. If input $A$ is stuck-at-$0$, the majority voter’s output reduces to $M(0,B,C)=B\\lor C$.\n\nC. If input $A$ is stuck-at-$1$, the majority voter’s output reduces to $M(1,B,C)=B\\lor C$.\n\nD. In TMR, if two modules are fault-free and identical, a single stuck-at fault on the third module is fully masked by the majority voter for all input combinations.\n\nE. The majority voter equals the parity function: $M(A,B,C)=A\\oplus B\\oplus C$.",
            "solution": "The primary task is to analyze a $3$-input majority voter, $M(A,B,C)$, its implementation, its behavior under faults, and its role in Triple Modular Redundancy (TMR). The problem defines the voter's output as $1$ if and only if at least $2$ of its inputs are $1$, and $0$ otherwise.\n\n**Part 1: Truth Table and Minimal Sum-of-Products (SOP) Implementation**\n\nFirst, let us construct the truth table for $M(A,B,C)$ by enumerating all $2^3 = 8$ possible combinations of the binary inputs $A$, $B$, and $C$. The output $M$ is $1$ when the sum of the inputs is greater than or equal to $2$.\n\n| $A$ | $B$ | $C$ | Number of $1$s | $M(A,B,C)$ |\n|---|---|---|---|---|\n| $0$ | $0$ | $0$ | $0$ | $0$ |\n| $0$ | $0$ | $1$ | $1$ | $0$ |\n| $0$ | $1$ | $0$ | $1$ | $0$ |\n| $0$ | $1$ | $1$ | $2$ | $1$ |\n| $1$ | $0$ | $0$ | $1$ | $0$ |\n| $1$ | $0$ | $1$ | $2$ | $1$ |\n| $1$ | $1$ | $0$ | $2$ | $1$ |\n| $1$ | $1$ | $1$ | $3$ | $1$ |\n\nFrom the truth table, the function $M(A,B,C)$ is true for the input combinations (minterms) $(0,1,1)$, $(1,0,1)$, $(1,1,0)$, and $(1,1,1)$. This gives the canonical sum-of-products (SOP) expression:\n$$ M(A,B,C) = (\\overline{A} \\land B \\land C) \\lor (A \\land \\overline{B} \\land C) \\lor (A \\land B \\land \\overline{C}) \\lor (A \\land B \\land C) $$\n\nTo find the minimal SOP expression, we can use Boolean algebra. We can add the term $A \\land B \\land C$ twice more to the expression, since $X \\lor X = X$.\n$$ M(A,B,C) = (\\overline{A} \\land B \\land C) \\lor (A \\land \\overline{B} \\land C) \\lor (A \\land B \\land \\overline{C}) \\lor (A \\land B \\land C) \\lor (A \\land B \\land C) \\lor (A \\land B \\land C) $$\nRearranging the terms to group adjacent minterms:\n$$ M(A,B,C) = ((\\overline{A} \\land B \\land C) \\lor (A \\land B \\land C)) \\lor ((A \\land \\overline{B} \\land C) \\lor (A \\land B \\land C)) \\lor ((A \\land B \\land \\overline{C}) \\lor (A \\land B \\land C)) $$\nFactoring out common terms using the distributive law:\n$$ M(A,B,C) = ((B \\land C) \\land (\\overline{A} \\lor A)) \\lor ((A \\land C) \\land (\\overline{B} \\lor B)) \\lor ((A \\land B) \\land (\\overline{C} \\lor C)) $$\nUsing the identity $X \\lor \\overline{X}=1$:\n$$ M(A,B,C) = ((B \\land C) \\land 1) \\lor ((A \\land C) \\land 1) \\lor ((A \\land B) \\land 1) $$\n$$ M(A,B,C) = (A \\land B) \\lor (B \\land C) \\lor (A \\land C) $$\nThis is the minimal SOP implementation for the $3$-input majority function.\n\n**Part 2: Analysis of Stuck-At Faults**\n\nNext, we analyze the voter's behavior when its input $A$ is stuck.\n\n**Case 1: Input $A$ is stuck-at-$0$.**\nWe substitute $A=0$ into the minimal SOP expression:\n$$ M(0,B,C) = (0 \\land B) \\lor (B \\land C) \\lor (0 \\land C) $$\n$$ M(0,B,C) = 0 \\lor (B \\land C) \\lor 0 $$\n$$ M(0,B,C) = B \\land C $$\nThe output reduces to the logical AND of inputs $B$ and $C$.\n\n**Case 2: Input $A$ is stuck-at-$1$.**\nWe substitute $A=1$ into the minimal SOP expression:\n$$ M(1,B,C) = (1 \\land B) \\lor (B \\land C) \\lor (1 \\land C) $$\n$$ M(1,B,C) = B \\lor (B \\land C) \\lor C $$\nUsing the absorption law of Boolean algebra, $X \\lor (X \\land Y) = X$, we can simplify $B \\lor (B \\land C)$:\n$$ B \\lor (B \\land C) = B $$\nSo the expression becomes:\n$$ M(1,B,C) = (B \\lor (B \\land C)) \\lor C = B \\lor C $$\nThe output reduces to the logical OR of inputs $B$ and $C$.\n\n**Part 3: Fault Masking in TMR**\n\nIn a TMR system, three identical modules produce outputs that are fed into the majority voter. If two modules are fault-free, their outputs will be identical. Let this correct output value be $X$. The third module has a single stuck-at fault, so its output is a constant ($0$ or $1$). We must determine if the voter output, $M$, equals the correct value $X$.\n\nThere are two scenarios for the correct output $X$:\n\n*   **Scenario 1: The correct output is $X=0$.**\n    The two fault-free modules output $0$. The inputs to the voter are $(A,B,C)$, where two of the inputs are $0$.\n    *   If the fault is stuck-at-$0$, the inputs are $(0,0,0)$. $M(0,0,0) = (0 \\land 0) \\lor (0 \\land 0) \\lor (0 \\land 0) = 0$. The output is correct.\n    *   If the fault is stuck-at-$1$, the inputs are $(1,0,0)$ in some permutation. $M(1,0,0) = (1 \\land 0) \\lor (0 \\land 0) \\lor (1 \\land 0) = 0$. The output is correct.\n\n*   **Scenario 2: The correct output is $X=1$.**\n    The two fault-free modules output $1$. The inputs to the voter are $(A,B,C)$, where two of the inputs are $1$.\n    *   If the fault is stuck-at-$0$, the inputs are $(0,1,1)$ in some permutation. $M(0,1,1) = (0 \\land 1) \\lor (1 \\land 1) \\lor (0 \\land 1) = 1$. The output is correct.\n    *   If the fault is stuck-at-$1$, the inputs are $(1,1,1)$. $M(1,1,1) = (1 \\land 1) \\lor (1 \\land 1) \\lor (1 \\land 1) = 1$. The output is correct.\n\nIn all cases where two inputs are correct and one is faulty (stuck-at-$0$ or stuck-at-$1$), the majority voter produces the correct output $X$. Therefore, a single stuck-at fault on one module's output is fully masked.\n\n**Evaluation of Options**\n\n*   **A. The minimal sum-of-products implementation of the majority voter is $M(A,B,C)=(A \\land B) \\lor (B \\land C) \\lor (A \\land C)$.**\n    As derived in Part 1, this statement is accurate.\n    **Verdict: Correct.**\n\n*   **B. If input $A$ is stuck-at-$0$, the majority voter’s output reduces to $M(0,B,C)=B\\lor C$.**\n    As derived in Part 2, when $A$ is stuck-at-$0$, the output reduces to $M(0,B,C)=B \\land C$. This is a logical AND, not a logical OR ($B \\lor C$). For instance, if $B=1$ and $C=0$, $B \\land C=0$ while $B \\lor C = 1$.\n    **Verdict: Incorrect.**\n\n*   **C. If input $A$ is stuck-at-$1$, the majority voter’s output reduces to $M(1,B,C)=B\\lor C$.**\n    As derived in Part 2, when $A$ is stuck-at-$1$, the output reduces to $M(1,B,C)=B \\lor C$.\n    **Verdict: Correct.**\n\n*   **D. In TMR, if two modules are fault-free and identical, a single stuck-at fault on the third module is fully masked by the majority voter for all input combinations.**\n    As demonstrated in Part 3, the output of the majority voter will always match the value of the two identical, correct inputs, effectively masking the single faulty input. This is the fundamental principle of TMR.\n    **Verdict: Correct.**\n\n*   **E. The majority voter equals the parity function: $M(A,B,C)=A\\oplus B\\oplus C$.**\n    The $3$-input XOR (parity) function, $P(A,B,C)=A\\oplus B\\oplus C$, outputs $1$ if an odd number of inputs are $1$. Let's compare its output to the majority voter for the input $(0,1,1)$.\n    *   $M(0,1,1) = (0 \\land 1) \\lor (1 \\land 1) \\lor (0 \\land 1) = 1$ (since two inputs are $1$).\n    *   $P(0,1,1) = 0 \\oplus 1 \\oplus 1 = 1 \\oplus 1 = 0$ (since two, an even number, of inputs are $1$).\n    Since $M(0,1,1) \\neq P(0,1,1)$, the two functions are not equal.\n    **Verdict: Incorrect.**",
            "answer": "$$\\boxed{ACD}$$"
        },
        {
            "introduction": "While standard arithmetic operations are fundamental, many applications require custom behavior. This exercise demonstrates how a truth table can be used to specify non-standard arithmetic, in this case, saturating addition, which is crucial in digital signal processing to prevent wrap-around artifacts. You will construct the complete specification for a 2-bit saturating adder and use it to analyze the circuit's average output, illustrating the power of truth tables in defining and evaluating specialized hardware .",
            "id": "3686422",
            "problem": "Consider fixed-width signed integer arithmetic using two-bit two's complement representation. In two's complement with width $n=2$, the representable integers are $-2$, $-1$, $0$, and $1$, encoded by the bit patterns $10$, $11$, $00$, and $01$, respectively, where the most significant bit is the sign bit. Define saturating addition on these two-bit integers as follows: given inputs $A=a_{1}a_{0}$ and $B=b_{1}b_{0}$, let the mathematical sum be $V(A)+V(B)$, where $V(\\cdot)$ maps a two-bit pattern to its two's complement integer value. The saturating sum $S$ is defined to be the normal sum $V(A)+V(B)$ if $V(A)+V(B)\\in[-2,1]$, the maximum representable integer $+1$ (bit pattern $01$) if $V(A)+V(B)>1$, and the minimum representable integer $-2$ (bit pattern $10$) if $V(A)+V(B)<-2$.\n\nTasks:\n- Construct the complete truth table that maps every input pair $(A,B)$ over all $16$ combinations of two-bit inputs to the saturating sum output $S$, written both as a two-bit pattern and as its two's complement integer value.\n- Assume the inputs $A$ and $B$ are independent and uniformly distributed over the four representable values $\\{-2,-1,0,1\\}$. Using your truth table, compute the exact expected value of the saturating sum $S$ interpreted as a two's complement integer.\n\nExpress the final expected value as a single exact fraction. Do not round.",
            "solution": "The problem asks for two results: first, a complete truth table for two-bit two's complement saturating addition, and second, the expected value of the saturated sum assuming uniformly distributed inputs.\n\nThe two-bit two's complement representation covers the integer range from $-2^{2-1}$ to $2^{2-1}-1$, which is $[-2, 1]$. The problem provides the mapping between the two-bit patterns and their integer values:\n- $00_2 \\rightarrow V(00) = 0$\n- $01_2 \\rightarrow V(01) = 1$\n- $10_2 \\rightarrow V(10) = -2$\n- $11_2 \\rightarrow V(11) = -1$\n\nSaturating addition is defined for two inputs $A$ and $B$. Let $V(A)$ and $V(B)$ be their integer values. The mathematical sum is $Z = V(A) + V(B)$. The saturating sum, $S$, has an integer value $V(S)$ defined as:\n- $V(S) = Z$ if $-2 \\le Z \\le 1$\n- $V(S) = 1$ (maximum representable value) if $Z > 1$\n- $V(S) = -2$ (minimum representable value) if $Z < -2$\n\n**Part 1: Constructing the Truth Table**\n\nWe need to evaluate the saturating sum for all $4 \\times 4 = 16$ possible pairs of inputs for $A=a_1a_0$ and $B=b_1b_0$. The complete truth table is constructed below. The columns show the bit patterns for inputs $A$ and $B$, their corresponding integer values $V(A)$ and $V(B)$, the mathematical sum $Z=V(A)+V(B)$, the resulting integer value of the saturating sum $V(S)$, and the bit pattern for the saturating sum $S$.\n\n$$\n\\begin{array}{|c|c|c|c|c|c|c|}\n\\hline\n\\textbf{A} & \\boldsymbol{V(A)} & \\textbf{B} & \\boldsymbol{V(B)} & \\boldsymbol{Z = V(A)+V(B)} & \\boldsymbol{V(S)} & \\textbf{S} \\\\\n\\hline\n00 & 0 & 00 & 0 & 0 & 0 & 00 \\\\\n00 & 0 & 01 & 1 & 1 & 1 & 01 \\\\\n00 & 0 & 10 & -2 & -2 & -2 & 10 \\\\\n00 & 0 & 11 & -1 & -1 & -1 & 11 \\\\\n\\hline\n01 & 1 & 00 & 0 & 1 & 1 & 01 \\\\\n01 & 1 & 01 & 1 & 2 & 1 & 01 \\\\\n01 & 1 & 10 & -2 & -1 & -1 & 11 \\\\\n01 & 1 & 11 & -1 & 0 & 0 & 00 \\\\\n\\hline\n10 & -2 & 00 & 0 & -2 & -2 & 10 \\\\\n10 & -2 & 01 & 1 & -1 & -1 & 11 \\\\\n10 & -2 & 10 & -2 & -4 & -2 & 10 \\\\\n10 & -2 & 11 & -1 & -3 & -2 & 10 \\\\\n\\hline\n11 & -1 & 00 & 0 & -1 & -1 & 11 \\\\\n11 & -1 & 01 & 1 & 0 & 0 & 00 \\\\\n11 & -1 & 10 & -2 & -3 & -2 & 10 \\\\\n11 & -1 & 11 & -1 & -2 & -2 & 10 \\\\\n\\hline\n\\end{array}\n$$\n\n**Part 2: Calculating the Expected Value**\n\nThe inputs $A$ and $B$ are assumed to be independent and uniformly distributed over the four possible values $\\{-2, -1, 0, 1\\}$. The probability of any specific integer value for $V(A)$ or $V(B)$ is $P = \\frac{1}{4}$.\nSince $A$ and $B$ are independent, the probability of any specific pair of input values $(V(A), V(B))$ is the product of their individual probabilities:\n$$P(V(A)=v_a, V(B)=v_b) = P(V(A)=v_a) \\times P(V(B)=v_b) = \\frac{1}{4} \\times \\frac{1}{4} = \\frac{1}{16}$$\nThis means that each of the $16$ rows in the truth table is equally likely.\n\nThe expected value of the saturating sum, $E[S]$, is the sum of all possible output values $V(S)$ weighted by their probabilities. Since each of the $16$ outcomes has a probability of $\\frac{1}{16}$, the expected value is the arithmetic mean of all $16$ values in the $V(S)$ column of the table.\n\n$$E[S] = \\sum_{i=1}^{16} V(S_i) \\cdot P_i = \\frac{1}{16} \\sum_{i=1}^{16} V(S_i)$$\n\nWe sum the values from the $V(S)$ column:\n$$\n\\sum_{i=1}^{16} V(S_i) = (0+1-2-1) + (1+1-1+0) + (-2-1-2-2) + (-1+0-2-2)\n$$\n$$\n\\sum_{i=1}^{16} V(S_i) = (-2) + (1) + (-7) + (-5) = -13\n$$\n\nAlternatively, we can count the frequency of each output value:\n- The value $V(S)=1$ occurs $3$ times.\n- The value $V(S)=0$ occurs $3$ times.\n- The value $V(S)=-1$ occurs $4$ times.\n- The value $V(S)=-2$ occurs $6$ times.\n(Check: $3+3+4+6 = 16$).\n\nThe sum of the values is:\n$$\n\\sum V(S) = (3 \\times 1) + (3 \\times 0) + (4 \\times -1) + (6 \\times -2) = 3 + 0 - 4 - 12 = -13\n$$\nBoth methods yield the same sum.\nNow, we can compute the expected value:\n$$\nE[S] = \\frac{1}{16} \\sum_{i=1}^{16} V(S_i) = \\frac{-13}{16}\n$$\n\nThe exact expected value of the saturating sum $S$ is $-\\frac{13}{16}$.",
            "answer": "$$\n\\boxed{-\\frac{13}{16}}\n$$"
        },
        {
            "introduction": "In high-performance computing, every saved clock cycle counts. This problem delves into a practical optimization used in processor design: conditionally bypassing a complex operation based on a simple logical check. You will use a truth table to design a detector that determines if two signed numbers have the same sign, and then use this logic to decide whether a full, time-consuming magnitude comparison can be skipped, connecting the abstract concept of a truth table directly to a tangible performance gain .",
            "id": "3686338",
            "problem": "Consider a comparator stage in a processor datapath that must decide, for two signed integers in two’s complement representation, whether to invoke a magnitude comparison of the lower bits or bypass it using only the sign information. Let $A$ and $B$ be two $n$-bit two’s complement integers with Most Significant Bit (MSB) sign bits $A_{msb}$ and $B_{msb}$, respectively. Define the detector to be constructed only from the logical NOT (denoted by the complement operator $'$) and exclusive OR (XOR) operations applied to $A_{msb}$ and $B_{msb}$; exclusive OR (XOR) is the binary operation on bits $x$ and $y$ such that $x \\oplus y = 1$ if and only if $x \\neq y$, and $x \\oplus y = 0$ otherwise. You must:\n- Derive, from first principles of Boolean logic and truth tables, a correct truth table for a signal $SameSign$ that is true exactly when $A$ and $B$ have the same sign, and false otherwise. Use only $A_{msb}$ and $B_{msb}$ as inputs.\n- Using the $SameSign$ truth table, define a gating signal $Bypass$ that disables the magnitude comparison whenever the signs alone suffice to determine the ordering of $A$ and $B$. Assume that when $A$ and $B$ have different signs, the magnitude comparison can be bypassed, because any positive number is greater than any negative number in two’s complement.\nNow assume the sign bits observed over a large workload are independent random variables with $\\mathbb{P}(A_{msb} = 1) = p$ and $\\mathbb{P}(B_{msb} = 1) = q$, where $1$ denotes a negative sign bit in two’s complement and $0$ denotes a non-negative sign. Using your truth table and independence, derive a closed-form analytic expression for the expected fraction of comparisons that will be bypassed. Provide the final answer as a single analytic expression. No rounding is required, and the quantity is dimensionless.",
            "solution": "The solution is developed in three stages as requested by the problem statement.\n\n**1. Truth Table for the `SameSign` Signal**\n\nThe signal $SameSign$ is defined to be true (logical $1$) if and only if the integers $A$ and $B$ have the same sign. In two's complement representation, the Most Significant Bit (MSB) is the sign bit. A value of $0$ for the MSB indicates a non-negative number, while a value of $1$ indicates a negative number. Therefore, $SameSign$ is true if and only if the sign bits $A_{msb}$ and $B_{msb}$ are equal.\n\nWe construct the truth table for $SameSign$ with inputs $A_{msb}$ and $B_{msb}$:\n- If $A_{msb} = 0$ and $B_{msb} = 0$, both numbers are non-negative, so their signs are the same. $SameSign = 1$.\n- If $A_{msb} = 0$ and $B_{msb} = 1$, one number is non-negative and the other is negative, so their signs are different. $SameSign = 0$.\n- If $A_{msb} = 1$ and $B_{msb} = 0$, the signs are different. $SameSign = 0$.\n- If $A_{msb} = 1$ and $B_{msb} = 1$, both numbers are negative, so their signs are the same. $SameSign = 1$.\n\nThe complete truth table is as follows:\n$$\n\\begin{array}{cc|c}\nA_{msb} & B_{msb} & SameSign \\\\\n\\hline\n0 & 0 & 1 \\\\\n0 & 1 & 0 \\\\\n1 & 0 & 0 \\\\\n1 & 1 & 1\n\\end{array}\n$$\nThis truth table corresponds to the logical XNOR (exclusive NOR) operation. As specified, this can be constructed from NOT and XOR, since $x \\text{ XNOR } y = (x \\oplus y)'$. Thus, $SameSign = (A_{msb} \\oplus B_{msb})'$.\n\n**2. Definition of the `Bypass` Signal**\n\nThe problem states that the magnitude comparison is bypassed whenever the signs of $A$ and $B$ are sufficient to determine their ordering. For signed numbers, any non-negative number is greater than any negative number. This occurs precisely when the signs are different. Therefore, the $Bypass$ signal should be true (logical $1$) when the signs of $A$ and $B$ are different, and false (logical $0$) when their signs are the same.\n\nThis condition is the exact logical opposite of the $SameSign$ signal.\n$Bypass = (SameSign)'$.\nSubstituting the expression for $SameSign$:\n$Bypass = ((A_{msb} \\oplus B_{msb})')' = A_{msb} \\oplus B_{msb}$.\n\nThe truth table for the $Bypass$ signal is derived from the condition that it is true if and only if $A_{msb} \\neq B_{msb}$:\n$$\n\\begin{array}{cc|c}\nA_{msb} & B_{msb} & Bypass \\\\\n\\hline\n0 & 0 & 0 \\\\\n0 & 1 & 1 \\\\\n1 & 0 & 1 \\\\\n1 & 1 & 0\n\\end{array}\n$$\nThis truth table confirms that the $Bypass$ signal is equivalent to the exclusive OR (XOR) of the sign bits, $Bypass = A_{msb} \\oplus B_{msb}$.\n\n**3. Expression for the Expected Fraction of Bypassed Comparisons**\n\nThe expected fraction of comparisons that will be bypassed is the expected value of the $Bypass$ signal, denoted $\\mathbb{E}[Bypass]$. The $Bypass$ signal is a binary random variable, taking values in $\\{0, 1\\}$. For such a variable, the expected value is equal to the probability of the variable being $1$:\n$$ \\mathbb{E}[Bypass] = \\mathbb{P}(Bypass = 1) $$\nFrom the truth table for $Bypass$, we see that $Bypass = 1$ under two mutually exclusive conditions:\n1. $A_{msb} = 0$ and $B_{msb} = 1$.\n2. $A_{msb} = 1$ and $B_{msb} = 0$.\n\nTherefore, the probability $\\mathbb{P}(Bypass = 1)$ is the sum of the probabilities of these two disjoint events:\n$$ \\mathbb{P}(Bypass = 1) = \\mathbb{P}(A_{msb} = 0 \\text{ and } B_{msb} = 1) + \\mathbb{P}(A_{msb} = 1 \\text{ and } B_{msb} = 0) $$\nThe problem states that $A_{msb}$ and $B_{msb}$ are independent random variables. Thus, the probability of the joint event is the product of the individual probabilities:\n$$ \\mathbb{P}(Bypass = 1) = \\mathbb{P}(A_{msb} = 0) \\cdot \\mathbb{P}(B_{msb} = 1) + \\mathbb{P}(A_{msb} = 1) \\cdot \\mathbb{P}(B_{msb} = 0) $$\nWe are given the following probabilities:\n$$ \\mathbb{P}(A_{msb} = 1) = p $$\n$$ \\mathbb{P}(B_{msb} = 1) = q $$\nBy the complement rule of probability:\n$$ \\mathbb{P}(A_{msb} = 0) = 1 - \\mathbb{P}(A_{msb} = 1) = 1 - p $$\n$$ \\mathbb{P}(B_{msb} = 0) = 1 - \\mathbb{P}(B_{msb} = 1) = 1 - q $$\nSubstituting these expressions into the equation for $\\mathbb{P}(Bypass = 1)$:\n$$ \\mathbb{P}(Bypass = 1) = (1 - p)q + p(1 - q) $$\nExpanding the terms:\n$$ \\mathbb{P}(Bypass = 1) = q - pq + p - pq $$\nCombining the terms gives the final closed-form expression for the expected fraction of bypassed comparisons:\n$$ \\mathbb{E}[Bypass] = p + q - 2pq $$\nThis expression represents the probability that the two sign bits are different, given their respective probabilities of being negative.",
            "answer": "$$\n\\boxed{p+q-2pq}\n$$"
        }
    ]
}