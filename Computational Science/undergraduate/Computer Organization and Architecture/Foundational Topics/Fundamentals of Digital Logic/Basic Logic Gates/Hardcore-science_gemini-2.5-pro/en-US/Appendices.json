{
    "hands_on_practices": [
        {
            "introduction": "Efficiency is paramount in digital circuit design. This practice hones your ability to simplify a single Boolean function using the Karnaugh map (K-map), a powerful visual method for logic minimization. By deriving minimal Sum-of-Products (SOP) and Product-of-Sums (POS) forms, you will learn to translate a logical specification into an optimized gate-level circuit, directly impacting its cost and performance .",
            "id": "3622497",
            "problem": "Consider the Boolean function $f(A,B,C,D)$, where minterms are indexed by the binary code $ABCD$ with $A$ as the most significant bit. The on-set (where $f=1$) is the set of minterms $\\{4,5,8,9,10,11,12,13,14,15\\}$, the don't-care set is $\\{2,3\\}$, and the off-set (where $f=0$) consists of the remaining minterms. \n\nUsing a 4-variable Karnaugh map (K-map) and the standard adjacency rules, derive a minimal sum-of-products (SOP) and a minimal product-of-sums (POS) form for $f$ that respect the given don't-care conditions.\n\nThen, implement each form under the following gate-level constraints and definitions:\n- Only $2$-input $\\land$ (AND) and $2$-input $\\lor$ (OR) gates and $1$-input $\\lnot$ (NOT) gates are available.\n- Primary inputs are available only in uncomplemented form; any complemented literal $\\lnot X$ must be realized by a separate $\\lnot$ gate applied to $X$.\n- An inverted signal (e.g., $\\lnot C$) may be shared wherever it is used; do not duplicate inverters unnecessarily.\n- Realize the SOP strictly as an $\\lor$ of product terms, where each product term is built as a tree of $2$-input $\\land$ gates; realize the POS strictly as an $\\land$ of sum terms, where each sum term is built as a tree of $2$-input $\\lor$ gates.\n- Gate count is the total number of $\\land$, $\\lor$, and $\\lnot$ gates used.\n- Logic depth is defined as the maximum number of gate stages on any path from a primary input to the output, counting each $\\lnot$ encountered on that path as depth $1$ and each $\\land$ or $\\lor$ as depth $1$. Wires contribute zero depth.\n\nCompute, for each realization (SOP and POS), the total number of $\\land$, $\\lor$, and $\\lnot$ gates and the worst-case logic depth. Finally, report the single quantity\n$$\\Delta \\equiv N_{\\text{gates}}^{\\text{POS}} - N_{\\text{gates}}^{\\text{SOP}},$$\nwhere $N_{\\text{gates}}$ denotes the total number of gates ($\\land+\\lor+\\lnot$). No rounding is necessary; provide an exact integer as your final answer.",
            "solution": "The user wants to find the difference in gate counts between minimal Sum-of-Products (SOP) and Product-of-Sums (POS) realizations of a given Boolean function.\n\n### Step 1: Problem Validation\n\nFirst, I will validate the problem statement.\n\n**1.1. Extract Givens**\n- **Function**: A $4$-variable Boolean function $f(A,B,C,D)$.\n- **Indexing**: Minterms are indexed by the binary code $ABCD$, with $A$ as the most significant bit (MSB).\n- **On-Set (minterms where $f=1$)**: $S_m = \\{4, 5, 8, 9, 10, 11, 12, 13, 14, 15\\}$.\n- **Don't-Care Set**: $S_d = \\{2, 3\\}$.\n- **Off-Set (minterms where $f=0$)**: The remaining minterms from $\\{0, 1, \\dots, 15\\}$.\n- **Task**: Derive minimal SOP and POS forms for $f$ using a $4$-variable Karnaugh map (K-map).\n- **Implementation Constraints**:\n  - Available gates: $2$-input $\\land$ (AND), $2$-input $\\lor$ (OR), $1$-input $\\lnot$ (NOT).\n  - Primary inputs ($A,B,C,D$) are uncomplemented. Complemented literals ($\\lnot X$) require a $\\lnot$ gate.\n  - Inverters can be shared.\n  - SOP realization: An $\\lor$ of product terms. Each product term is a tree of $2$-input $\\land$ gates.\n  - POS realization: An $\\land$ of sum terms. Each sum term is a tree of $2$-input $\\lor$ gates.\n- **Metrics**:\n  - $N_{\\text{gates}}$: Total count of $\\land$, $\\lor$, and $\\lnot$ gates.\n  - Logic depth: Maximum number of gates on any input-to-output path.\n- **Final Goal**: Compute $\\Delta \\equiv N_{\\text{gates}}^{\\text{POS}} - N_{\\text{gates}}^{\\text{SOP}}$.\n\n**1.2. Validate Using Extracted Givens**\n- **Scientific Grounding**: The problem is rooted in fundamental principles of digital logic design, specifically Boolean algebra, K-map minimization, and gate-level implementation. It is a standard, well-established type of problem in computer engineering. The problem is scientifically sound.\n- **Well-Posedness**: The function is fully specified through its on-set, off-set, and don't-care set. The minimization process is standard, leading to a minimal form (which is unique in this case). The constraints for gate-level implementation are precise. The final objective is a clearly defined calculation. The problem is well-posed.\n- **Objectivity**: The problem is stated using formal, objective language without ambiguity or subjective elements.\n\n**1.3. Verdict and Action**\nThe problem is valid. I will proceed to solve it.\n\n### Step 2: K-Map Construction and Minimization\n\nFirst, we determine the off-set. The set of all minterms is $\\{0, 1, ..., 15\\}$.\nThe off-set $S_f$ is $\\{0, 1, ..., 15\\} \\setminus (S_m \\cup S_d) = \\{0, 1, 6, 7\\}$.\n\nWe construct a $4$-variable K-map for $f(A,B,C,D)$. The map is structured with variables $AB$ for rows and $CD$ for columns, both in Gray code order ($00, 01, 11, 10$).\n\nThe K-map is populated as follows:\n- `1` for minterms in the on-set: $\\{4, 5, 8, 9, 10, 11, 12, 13, 14, 15\\}$\n- `X` for minterms in the don't-care set: $\\{2, 3\\}$\n- `0` for minterms in the off-set: $\\{0, 1, 6, 7\\}$\n\nThe resulting K-map is:\n$$\n\\begin{array}{c|c|c|c|c|}\n\\multicolumn{1}{r}{CD} & \\multicolumn{4}{c}{AB} \\\\\n\\multicolumn{1}{r}{} & 00 & 01 & 11 & \\multicolumn{1}{c}{10} \\\\\n\\cline{2-5}\n00 & 0_{0} & 1_{4} & 1_{12} & 1_{8} \\\\\n\\cline{2-5}\n01 & 0_{1} & 1_{5} & 1_{13} & 1_{9} \\\\\n\\cline{2-5}\n11 & X_{3} & 0_{7} & 1_{15} & 1_{11} \\\\\n\\cline{2-5}\n10 & X_{2} & 0_{6} & 1_{14} & 1_{10} \\\\\n\\cline{2-5}\n\\end{array}\n$$\n\n**2.1. Minimal Sum-of-Products (SOP) Form**\nWe group the $1$s, using $X$s as needed, to form the largest possible rectangular groups of sizes that are powers of $2$.\n\n1.  A group of $8$ can be formed by combining the two rightmost columns ($AB=11$ and $AB=10$), which corresponds to all minterms where $A=1$. This group covers minterms $\\{8,9,10,11,12,13,14,15\\}$. The corresponding product term is $A$.\n\n2.  The remaining uncovered $1$s are at minterms $4$ and $5$. We can form a group of $4$ by including the already covered minterms $12$ and $13$. This group covers $\\{4,5,12,13\\}$. This corresponds to $B=1$ and $C=0$. The product term is $B \\land \\lnot C$.\n\nThese two terms cover all minterms in the on-set.  $A$ is an essential prime implicant for minterms like $10, 11, 14, 15$. $B \\land \\lnot C$ is an essential prime implicant for minterms $4$ and $5$. Thus, the minimal SOP expression is unique.\n\n$$f_{SOP}(A,B,C,D) = A \\lor (B \\land \\lnot C)$$\n\n**2.2. Minimal Product-of-Sums (POS) Form**\nTo find the minimal POS form for $f$, we first find the minimal SOP form for its complement, $\\lnot f$, by grouping the $0$s in the K-map, using $X$s as needed.\n\n1.  A group of $4$ can be formed from minterms $\\{0,1\\}$ and don't-cares $\\{2,3\\}$. This corresponds to the region where $A=0$ and $B=0$. The product term is $\\lnot A \\land \\lnot B$. This is an essential prime implicant for $\\lnot f$ as it's the only one covering minterms $0$ and $1$.\n\n2.  Another group of $4$ can be formed from minterms $\\{6,7\\}$ and don't-cares $\\{2,3\\}$. This corresponds to the region where $A=0$ and $C=1$. The product term is $\\lnot A \\land C$. This is an essential prime implicant for $\\lnot f$ covering minterms $6$ and $7$.\n\nThe minimal SOP for $\\lnot f$ is:\n$$\\lnot f(A,B,C,D) = (\\lnot A \\land \\lnot B) \\lor (\\lnot A \\land C)$$\n\nApplying De Morgan's laws to find the POS form for $f$:\n$$f = \\lnot(\\lnot f) = \\lnot((\\lnot A \\land \\lnot B) \\lor (\\lnot A \\land C))$$\n$$f = \\lnot(\\lnot A \\land \\lnot B) \\land \\lnot(\\lnot A \\land C)$$\n$$f = (\\lnot(\\lnot A) \\lor \\lnot(\\lnot B)) \\land (\\lnot(\\lnot A) \\lor \\lnot C)$$\n$$f_{POS}(A,B,C,D) = (A \\lor B) \\land (A \\lor \\lnot C)$$\n\n### Step 3: Gate-Level Implementation Analysis\n\nWe now analyze the gate count and depth for each minimal form based on the given constraints.\n\n**3.1. SOP Realization: $f = A \\lor (B \\land \\lnot C)$**\n- **Literals**: The expression uses literals $A$, $B$, and $\\lnot C$.\n- **NOT Gates**: One $\\lnot$ gate is needed to generate $\\lnot C$ from $C$.\n  $N_{\\lnot}^{\\text{SOP}} = 1$.\n- **AND Gates**: One $2$-input $\\land$ gate is needed for the product term $B \\land \\lnot C$.\n  $N_{\\land}^{\\text{SOP}} = 1$.\n- **OR Gates**: One $2$-input $\\lor$ gate is needed for the final sum $A \\lor (B \\land \\lnot C)$. Note that $A$ is a single-literal term and is fed directly to the $\\lor$ gate.\n  $N_{\\lor}^{\\text{SOP}} = 1$.\n- **Total Gate Count**:\n  $N_{\\text{gates}}^{\\text{SOP}} = N_{\\lnot}^{\\text{SOP}} + N_{\\land}^{\\text{SOP}} + N_{\\lor}^{\\text{SOP}} = 1 + 1 + 1 = 3$.\n- **Logic Depth**: The longest path from an input to the output is for input $C$.\n  Path($C$): $C \\rightarrow \\lnot \\rightarrow \\land \\rightarrow \\lor \\rightarrow f$.\n  The depth is $1 (\\lnot) + 1 (\\land) + 1 (\\lor) = 3$.\n\n**3.2. POS Realization: $f = (A \\lor B) \\land (A \\lor \\lnot C)$**\n- **Literals**: The expression uses literals $A$, $B$, and $\\lnot C$.\n- **NOT Gates**: One $\\lnot$ gate is needed for $\\lnot C$. This is shared.\n  $N_{\\lnot}^{\\text{POS}} = 1$.\n- **OR Gates**: Two $2$-input $\\lor$ gates are needed for the sum terms $(A \\lor B)$ and $(A \\lor \\lnot C)$.\n  $N_{\\lor}^{\\text{POS}} = 2$.\n- **AND Gates**: One $2$-input $\\land$ gate is needed for the final product of the two sum terms.\n  $N_{\\land}^{\\text{POS}} = 1$.\n- **Total Gate Count**:\n  $N_{\\text{gates}}^{\\text{POS}} = N_{\\lnot}^{\\text{POS}} + N_{\\lor}^{\\text{POS}} + N_{\\land}^{\\text{POS}} = 1 + 2 + 1 = 4$.\n- **Logic Depth**: The longest path is again for input $C$.\n  Path($C$): $C \\rightarrow \\lnot \\rightarrow \\lor \\rightarrow \\land \\rightarrow f$.\n  The depth is $1 (\\lnot) + 1 (\\lor) + 1 (\\land) = 3$.\n\n### Step 4: Final Calculation\n\nThe problem asks for the quantity $\\Delta \\equiv N_{\\text{gates}}^{\\text{POS}} - N_{\\text{gates}}^{\\text{SOP}}$.\nUsing the calculated gate counts:\n$$N_{\\text{gates}}^{\\text{SOP}} = 3$$\n$$N_{\\text{gates}}^{\\text{POS}} = 4$$\n$$\\Delta = 4 - 3 = 1$$",
            "answer": "$$\\boxed{1}$$"
        },
        {
            "introduction": "While optimizing individual functions is a good start, greater efficiencies are often found by optimizing a system of functions together. This exercise introduces algebraic factorization as a way to identify and share common logic 'kernels' across multiple outputs. By restructuring the logic to eliminate redundancy, you will quantify the significant savings in both gate count and circuit delay that this system-level approach provides .",
            "id": "3622449",
            "problem": "Consider the control outputs $F_{1}$ and $F_{2}$ in a synchronous datapath, each expressed over primary inputs $p,q,r,s,t$ using the Boolean operators $\\land$ (logical AND), $\\lor$ (logical OR), and $\\lnot$ (logical NOT), as follows:\n$$\nF_{1} \\;=\\; (\\lnot p \\land q \\land r) \\;\\lor\\; (\\lnot p \\land q \\land s), \\quad\nF_{2} \\;=\\; (\\lnot p \\land q \\land r) \\;\\lor\\; (\\lnot p \\land q \\land t).\n$$\nYou will implement these outputs using only $2$-input $\\land$ and $\\lor$ gates and $1$-input $\\lnot$ gates. Fan-out of any signal incurs no gate cost. Define logic depth to be the maximum number of gate levels on any path from a primary input to a given output, counting a $\\lnot$ as one level and counting each $2$-input $\\land$ or $\\lor$ as one level. The baseline implementation constructs $F_{1}$ and $F_{2}$ independently in their given sum-of-products forms, with the following constraint: within a single function, a literal such as $\\lnot p$ may be fanned out without additional gates, but any repeated nonliteral sub-expression (for example, $(\\lnot p \\land q)$) is recomputed separately inside each product term. No sharing occurs across different outputs in the baseline.\n\nUsing Boolean algebra starting from the fundamental laws of associativity, commutativity, and distributivity for $\\land$ and $\\lor$, perform algebraic division to factor out any common kernel and restructure the network so that the shared kernel is computed once and reused to realize both $F_{1}$ and $F_{2}$. Under the same gate and depth model, compute:\n- the total reduction in gate count when moving from the baseline to the factored, shared-kernel implementation, and\n- the reduction in the maximum logic depth across the two outputs.\n\nExpress your final answer as a two-entry row matrix, with the first entry equal to the gate-count reduction and the second entry equal to the reduction in maximum logic depth. No rounding is required.",
            "solution": "The user wants to analyze a logic circuit's implementation, both in a baseline and an optimized form, and compute the reduction in gate count and logic depth.\n\n### Problem Validation\n\nFirst, I will validate the problem statement.\n\n**Step 1: Extract Givens**\n- The control outputs are $F_{1}$ and $F_{2}$.\n- Primary inputs are $p, q, r, s, t$.\n- Boolean operators are $\\land$ (AND), $\\lor$ (OR), and $\\lnot$ (NOT).\n- Logic functions:\n  $$F_{1} \\;=\\; (\\lnot p \\land q \\land r) \\;\\lor\\; (\\lnot p \\land q \\land s)$$\n  $$F_{2} \\;=\\; (\\lnot p \\land q \\land r) \\;\\lor\\; (\\lnot p \\land q \\land t)$$\n- Available gates: $2$-input $\\land$ gates, $2$-input $\\lor$ gates, and $1$-input $\\lnot$ gates.\n- Fan-out of any signal has a cost of $0$ gates.\n- Logic depth is defined as the maximum number of gate levels on any path from a primary input to an output.\n- Baseline implementation constraints:\n  1. $F_1$ and $F_2$ are constructed independently.\n  2. Implementations follow the given sum-of-products form.\n  3. A literal (e.g., $\\lnot p$) can be fanned out within a function.\n  4. Any repeated non-literal sub-expression (e.g., $(\\lnot p \\land q)$) is recomputed for each use within a product term.\n  5. No sharing of logic occurs across the two different outputs ($F_1$ and $F_2$).\n- Optimization task:\n  1. Use Boolean algebra (associativity, commutativity, distributivity) to perform algebraic division.\n  2. Factor out a common kernel.\n  3. Restructure the network to compute the shared kernel once and reuse it for both $F_1$ and $F_2$.\n- Required outputs:\n  1. Total reduction in gate count.\n  2. Reduction in the maximum logic depth across the two outputs.\n\n**Step 2: Validate Using Extracted Givens**\n- **Scientifically Grounded**: The problem is rooted in fundamental principles of digital logic design and Boolean algebra, which are core topics in computer engineering and computer science. The concepts of logic gates, sum-of-products form, logic depth, and factorization are standard.\n- **Well-Posed**: The problem provides explicit Boolean functions, clear definitions for gates and cost metrics (gate count and depth), and specific constraints for both the baseline and optimized implementations. This structure ensures that a unique, stable, and meaningful solution can be derived.\n- **Objective**: The problem is stated using precise mathematical notation and formal language, free of ambiguity or subjective claims.\n\n**Step 3: Verdict and Action**\nThe problem is valid. It is a well-defined and standard exercise in logic synthesis. I will proceed with the solution.\n\n### Solution\n\nThe solution involves analyzing the baseline and optimized implementations to determine their gate counts and logic depths.\n\n**1. Baseline Implementation Analysis**\n\nIn the baseline implementation, $F_1$ and $F_2$ are synthesized independently.\n\n**Analysis of $F_1 = (\\lnot p \\land q \\land r) \\lor (\\lnot p \\land q \\land s)$**:\nThe two product terms are $T_1 = \\lnot p \\land q \\land r$ and $T_2 = \\lnot p \\land q \\land s$.\n- To implement $T_1$, we need to compute a $3$-input AND using $2$-input AND gates. This requires two $\\land$ gates, for example, as $((\\lnot p \\land q) \\land r)$.\n  - One $\\lnot$ gate is needed for $\\lnot p$.\n  - One $\\land$ gate for $(\\lnot p \\land q)$.\n  - A second $\\land$ gate for $((\\lnot p \\land q) \\land r)$.\n- To implement $T_2$, the non-literal sub-expression $(\\lnot p \\land q)$ must be recomputed according to the problem constraints. The literal $\\lnot p$ can be fanned out from the first computation.\n  - One $\\land$ gate for $(\\lnot p \\land q)$ (recomputed).\n  - A second $\\land$ gate for $((\\lnot p \\land q) \\land s)$.\n- Finally, one $\\lor$ gate is needed to combine the two product terms: $F_1 = T_1 \\lor T_2$.\n\nGate count for $F_1$:\n- $\\lnot$ gates: $1$ (for $\\lnot p$)\n- $\\land$ gates: $2$ (for $T_1$) + $2$ (for $T_2$) = $4$\n- $\\lor$ gates: $1$\n- Total gates for $F_1$: $1 + 4 + 1 = 6$.\n\nLogic depth for $F_1$:\nThe logic depth is the longest path from any primary input to the output. We trace the path from input $p$:\n- Level 1: $p \\to \\lnot p$ ($\\lnot$ gate)\n- Level 2: $(\\lnot p, q) \\to (\\lnot p \\land q)$ ($\\land$ gate)\n- Level 3: $((\\lnot p \\land q), r) \\to ((\\lnot p \\land q) \\land r)$ ($\\land$ gate)\n- Level 4: $((\\lnot p \\land q \\land r), (\\lnot p \\land q \\land s)) \\to F_1$ ($\\lor$ gate)\nThe maximum depth for $F_1$ is $4$.\n\n**Analysis of $F_2 = (\\lnot p \\land q \\land r) \\lor (\\lnot p \\land q \\land t)$**:\nThe structure of $F_2$ is identical to $F_1$, with input $t$ replacing $s$. Since no logic is shared between $F_1$ and $F_2$ in the baseline, the gate count and depth for $F_2$ are the same as for $F_1$.\n- Total gates for $F_2$: $6$.\n- Maximum depth for $F_2$: $4$.\n\n**Total for Baseline Implementation**:\n- Total gate count = (gates for $F_1$) + (gates for $F_2$) = $6 + 6 = 12$.\n- Maximum logic depth = $\\max(\\text{depth of } F_1, \\text{depth of } F_2) = \\max(4, 4) = 4$.\n\n**2. Factored (Shared-Kernel) Implementation Analysis**\n\nWe start by applying the distributive law of Boolean algebra, $A \\land B \\lor A \\land C = A \\land (B \\lor C)$, to factor the expressions for $F_1$ and $F_2$.\n- For $F_1$: Let $A = (\\lnot p \\land q)$.\n  $F_1 = (\\lnot p \\land q \\land r) \\lor (\\lnot p \\land q \\land s) = (\\lnot p \\land q) \\land (r \\lor s)$.\n- For $F_2$: Similarly,\n  $F_2 = (\\lnot p \\land q \\land r) \\lor (\\lnot p \\land q \\land t) = (\\lnot p \\land q) \\land (r \\lor t)$.\n\nThe common kernel to be shared is the sub-expression $K = \\lnot p \\land q$. The network is restructured to compute $K$ once and reuse it.\n\n**Implementation of shared network**:\n1. Compute the literal $\\lnot p$:\n   - One $\\lnot$ gate.\n2. Compute the shared kernel $K = \\lnot p \\land q$:\n   - One $\\land$ gate. This signal is fanned out to logic for $F_1$ and $F_2$.\n3. Compute $F_1 = K \\land (r \\lor s)$:\n   - One $\\lor$ gate for $(r \\lor s)$.\n   - One $\\land$ gate to combine $K$ and $(r \\lor s)$.\n4. Compute $F_2 = K \\land (r \\lor t)$:\n   - One $\\lor$ gate for $(r \\lor t)$.\n   - One $\\land$ gate to combine $K$ and $(r \\lor t)$.\n\nGate count for the factored implementation:\n- $\\lnot$ gates: $1$ (for $\\lnot p$)\n- $\\land$ gates: $1$ (for $K$) + $1$ (for $F_1$) + $1$ (for $F_2$) = $3$\n- $\\lor$ gates: $1$ (for $F_1$) + $1$ (for $F_2$) = $2$\n- Total gates for shared implementation: $1 + 3 + 2 = 6$.\n\nLogic depth for the factored implementation:\n- Depth of kernel $K$: The path from $p$ is $p \\to \\lnot p \\to K$. This path has $2$ gate levels.\n- Depth of $F_1 = K \\land (r \\lor s)$: The depth is $\\max(\\text{depth of } K, \\text{depth of } (r \\lor s)) + 1$.\n  - Depth of $(r \\lor s)$ is $1$.\n  - Depth of $F_1$ is $\\max(2, 1) + 1 = 3$.\n- Depth of $F_2 = K \\land (r \\lor t)$: The depth is $\\max(\\text{depth of } K, \\text{depth of } (r \\lor t)) + 1$.\n  - Depth of $(r \\lor t)$ is $1$.\n  - Depth of $F_2$ is $\\max(2, 1) + 1 = 3$.\n\n**Total for Factored Implementation**:\n- Total gate count = $6$.\n- Maximum logic depth = $\\max(\\text{depth of } F_1, \\text{depth of } F_2) = \\max(3, 3) = 3$.\n\n**3. Calculation of Reductions**\n\nWe now compare the baseline and factored implementations.\n\n**Gate Count Reduction**:\n- Baseline gate count: $12$.\n- Factored gate count: $6$.\n- Reduction = (Baseline count) - (Factored count) = $12 - 6 = 6$.\n\n**Maximum Logic Depth Reduction**:\n- Baseline maximum depth: $4$.\n- Factored maximum depth: $3$.\n- Reduction = (Baseline depth) - (Factored depth) = $4 - 3 = 1$.\n\nThe final answer is a two-entry row matrix containing the gate-count reduction and the depth reduction, respectively.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n6 & 1\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "So far, we have treated logic gates as devices that compute functions. Now, we explore how they can be used to store information. This practice guides you through the analysis of an SR latch, a fundamental memory element built by cross-coupling basic gates. By examining how feedback creates stable states, you will learn the core principles of sequential logic and understand why these stateful circuits are the building blocks for registers and computer memory .",
            "id": "3622431",
            "problem": "A Set-Reset (SR) latch is a minimal memory element that can be constructed by cross-coupling two identical gates with feedback. Consider an implementation using only basic logic primitives $\\land$, $\\lor$, and $\\lnot$ in which each gate is an $\\lor$ followed by a $\\lnot$ (that is, a NOT-OR, commonly called NOR). Let the inputs be active-high Set $S$ and Reset $R$, and let the outputs be $Q$ and $\\overline{Q}$, where $\\overline{Q}$ denotes the Boolean complement of $Q$. Assume conventional two-level logic with nonzero but finite propagation delays.\n\nUsing only the fundamental truth-table definitions of $\\lor$ and $\\lnot$, and the notion that feedback means an output at time $t$ can feed an input to affect values at time $t+\\tau$ for some positive propagation delay $\\tau$, determine which option both (i) gives the correct pair of Boolean equations that describe the cross-coupled network built from $\\lor$ followed by $\\lnot$, and (ii) states the correct caveat about why this circuit cannot be modeled as a purely combinational mapping from $\\{S,R\\}$ to $\\{Q,\\overline{Q}\\}$ when $S=R=0$, together with the correct behavior under the input condition $S=R=1$.\n\nChoose the single best option.\n\nA. Equations: $Q=\\lnot\\!\\left(R\\lor\\overline{Q}\\right)$ and $\\overline{Q}=\\lnot\\!\\left(S\\lor Q\\right)$. Caveat and behavior: With $S=R=0$, the system reduces to $Q=\\lnot\\overline{Q}$ and $\\overline{Q}=\\lnot Q$, which admits $2$ stable fixed points $\\{Q,\\overline{Q}\\}\\in\\{(1,0),(0,1)\\}$; thus the output under $S=R=0$ depends on the prior state and the nonzero propagation delay $\\tau$, so the combinational abstraction (instantaneous algebraic elimination of feedback) does not apply. With $S=R=1$, both outputs are forced low, $\\{Q,\\overline{Q}\\}=(0,0)$.\n\nB. Equations: $Q=\\lnot\\!\\left(S\\lor\\overline{Q}\\right)$ and $\\overline{Q}=\\lnot\\!\\left(R\\lor Q\\right)$. Caveat and behavior: With $S=R=0$, the unique stable solution is $\\{Q,\\overline{Q}\\}=(0,0)$; therefore the network is combinational and algebraic substitution yields $Q=\\lnot S$ and $\\overline{Q}=\\lnot R$. With $S=R=1$, the outputs remain unchanged from their previous values.\n\nC. Equations: $Q=\\lnot\\!\\left(R\\land\\overline{Q}\\right)$ and $\\overline{Q}=\\lnot\\!\\left(S\\land Q\\right)$. Caveat and behavior: Because only $\\land$, $\\lor$, and $\\lnot$ are used, the network is combinational; with $S=R=1$, the only stable solution is $\\{Q,\\overline{Q}\\}=(1,1)$; with $S=R=0$, there is no memory and $\\{Q,\\overline{Q}\\}$ is uniquely determined.\n\nD. Equations: $Q=\\lnot\\!\\left(R\\lor\\overline{Q}\\right)$ and $\\overline{Q}=\\lnot\\!\\left(S\\lor Q\\right)$. Caveat and behavior: The combinational abstraction holds if one assumes zero delay $\\tau=0$, so one can substitute to remove feedback and obtain a single-valued Boolean function $Q=f(S,R)$. With $S=R=1$, the circuit necessarily enters indefinite metastability with undefined outputs at all times.",
            "solution": "The problem requires an analysis of a Set-Reset (SR) latch constructed from two cross-coupled NOR gates. A NOR gate with inputs $A$ and $B$ implements the Boolean function $\\lnot(A \\lor B)$. The analysis must be based on first principles, including the effect of propagation delay.\n\n**1. Derivation of the State Equations**\n\nAn SR latch is a sequential circuit with two inputs, Set ($S$) and Reset ($R$), and two outputs, $Q$ and its complement $\\overline{Q}$. The structure consists of two NOR gates cross-coupled, meaning the output of each gate is connected to an input of the other. For an active-high SR latch, the standard configuration is as follows:\n- One NOR gate (let's call it the Q-gate) has inputs $R$ and the output of the other gate, which is $\\overline{Q}$. The output of this gate is $Q$.\n- The other NOR gate (the $\\overline{Q}$-gate) has inputs $S$ and the output of the Q-gate, which is $Q$. The output of this gate is $\\overline{Q}$.\n\nLet's introduce time dependence to model the propagation delay $\\tau > 0$. The outputs at time $t+\\tau$ are functions of the inputs at time $t$.\nThe logical operation of the Q-gate is:\n$$Q(t+\\tau) = \\lnot \\left( R(t) \\lor \\overline{Q}(t) \\right)$$\nThe logical operation of the $\\overline{Q}$-gate is:\n$$\\overline{Q}(t+\\tau) = \\lnot \\left( S(t) \\lor Q(t) \\right)$$\nFor steady-state analysis, we consider the inputs $S$ and $R$ to be constant, and we look for stable fixed points where $Q(t+\\tau) = Q(t) = Q$ and $\\overline{Q}(t+\\tau) = \\overline{Q}(t) = \\overline{Q}$. The steady-state equations are:\n$$Q = \\lnot(R \\lor \\overline{Q})$$\n$$\\overline{Q} = \\lnot(S \\lor Q)$$\nThese are the governing equations for the circuit.\n\n**2. Analysis of Input Conditions**\n\nWe analyze the behavior of the latch for the two critical input combinations mentioned in the problem.\n\n**Case 1: $S=0$, $R=0$ (Memory/Hold State)**\nSubstituting $S=0$ and $R=0$ into the steady-state equations:\n$$Q = \\lnot(0 \\lor \\overline{Q}) = \\lnot\\overline{Q}$$\n$$\\overline{Q} = \\lnot(0 \\lor Q) = \\lnot Q$$\nIf we assume $\\overline{Q}$ is the logical complement of $Q$, then $Q = \\lnot(\\lnot Q) = Q$, which is a tautology. This equation does not determine a unique value for $Q$. This indicates that the output is not determined solely by the current inputs. We must check for stable states.\n- **Possibility 1:** Assume the state is $\\{Q, \\overline{Q}\\} = \\{1, 0\\}$.\n  - First equation: $1 = \\lnot(0 \\lor 0) = \\lnot 0 = 1$. (Consistent)\n  - Second equation: $0 = \\lnot(0 \\lor 1) = \\lnot 1 = 0$. (Consistent)\n  Thus, $\\{Q, \\overline{Q}\\} = \\{1, 0\\}$ is a stable fixed point.\n- **Possibility 2:** Assume the state is $\\{Q, \\overline{Q}\\} = \\{0, 1\\}$.\n  - First equation: $0 = \\lnot(0 \\lor 1) = \\lnot 1 = 0$. (Consistent)\n  - Second equation: $1 = \\lnot(0 \\lor 0) = \\lnot 0 = 1$. (Consistent)\n  Thus, $\\{Q, \\overline{Q}\\} = \\{0, 1\\}$ is also a stable fixed point.\n\nThe existence of two stable states for the same input condition ($S=R=0$) means the circuit exhibits memory. The output depends on its state prior to the inputs becoming $S=R=0$. A purely combinational model, which requires a unique output for each input combination, is therefore inadequate. The non-zero propagation delay $\\tau$ is the physical basis for the system having a \"prior state\" that influences the next state.\n\n**Case 2: $S=1$, $R=1$ (Forbidden State)**\nSubstituting $S=1$ and $R=1$ into the governing equations:\n$$Q = \\lnot(1 \\lor \\overline{Q})$$\n$$\\overline{Q} = \\lnot(1 \\lor Q)$$\nFrom the definition of the $\\lor$ operator, $1 \\lor_X$ is always $1$ for any Boolean value $X$. Therefore:\n$$Q = \\lnot(1) = 0$$\n$$\\overline{Q} = \\lnot(1) = 0$$\nThis input condition forces both outputs to a stable value of $0$. The resulting state is $\\{Q, \\overline{Q}\\} = \\{0, 0\\}$. This is a well-defined state from a circuit-dynamics perspective, but it violates the logical contract that $\\overline{Q}$ is the complement of $Q$.\n\n**3. Evaluation of Options**\n\nNow we evaluate each option against our derived results.\n\n**A. Equations: $Q=\\lnot\\!\\left(R\\lor\\overline{Q}\\right)$ and $\\overline{Q}=\\lnot\\!\\left(S\\lor Q\\right)$. Caveat and behavior: With $S=R=0$, the system reduces to $Q=\\lnot\\overline{Q}$ and $\\overline{Q}=\\lnot Q$, which admits $2$ stable fixed points $\\{Q,\\overline{Q}\\}\\in\\{(1,0),(0,1)\\}$; thus the output under $S=R=0$ depends on the prior state and the nonzero propagation delay $\\tau$, so the combinational abstraction (instantaneous algebraic elimination of feedback) does not apply. With $S=R=1$, both outputs are forced low, $\\{Q,\\overline{Q}\\}=(0,0)$.**\n- **Equations:** The equations $Q=\\lnot(R\\lor\\overline{Q})$ and $\\overline{Q}=\\lnot(S\\lor Q)$ match our derivation for an active-high NOR SR latch. This is correct.\n- **Caveat for $S=R=0$:** The analysis is perfectly aligned with our findings. It correctly identifies the reduced equations, the two stable fixed points, and the consequence for the combinational model, correctly invoking the role of propagation delay. This is correct.\n- **Behavior for $S=R=1$:** The conclusion that $\\{Q,\\overline{Q}\\}=(0,0)$ matches our analysis. This is correct.\n**Verdict: Correct**\n\n**B. Equations: $Q=\\lnot\\!\\left(S\\lor\\overline{Q}\\right)$ and $\\overline{Q}=\\lnot\\!\\left(R\\lor Q\\right)$. Caveat and behavior: With $S=R=0$, the unique stable solution is $\\{Q,\\overline{Q}\\}=(0,0)$; therefore the network is combinational and algebraic substitution yields $Q=\\lnot S$ and $\\overline{Q}=\\lnot R$. With $S=R=1$, the outputs remain unchanged from their previous values.**\n- **Equations:** These equations describe an active-low SR latch $(\\overline{S}\\overline{R}$ latch), not an active-high one as specified by the conventional use of $S$ and $R$. This is incorrect.\n- **Caveat for $S=R=0$:** As shown in our main analysis, this input combination leads to two stable states, not a unique one. The claim that the network is combinational is false. This is incorrect.\n- **Behavior for $S=R=1$:** For these equations, $S=R=1$ would lead to $Q=\\lnot(1 \\lor \\overline{Q})=0$ and $\\overline{Q}=\\lnot(1 \\lor Q)=0$. The output is forced to $\\{0,0\\}$, it does not \"remain unchanged\". This is incorrect.\n**Verdict: Incorrect**\n\n**C. Equations: $Q=\\lnot\\!\\left(R\\land\\overline{Q}\\right)$ and $\\overline{Q}=\\lnot\\!\\left(S\\land Q\\right)$. Caveat and behavior: Because only $\\land$, $\\lor$, and $\\lnot$ are used, the network is combinational; with $S=R=1$, the only stable solution is $\\{Q,\\overline{Q}\\}=(1,1)$; with $S=R=0$, there is no memory and $\\{Q,\\overline{Q}\\}$ is uniquely determined.**\n- **Equations:** These equations use the $\\land$ operator, corresponding to NAND gates ($\\lnot(A \\land B)$), not NOR gates as specified in the problem statement. This is incorrect.\n- **Caveat and behavior:** The premise that using basic primitives makes a network combinational is false; the feedback structure makes it sequential. The subsequent analysis of behavior for this different (NAND latch) circuit is also flawed. The claim about the stable solution for $S=R=1$ is wrong, as is the claim about $S=R=0$.\n**Verdict: Incorrect**\n\n**D. Equations: $Q=\\lnot\\!\\left(R\\lor\\overline{Q}\\right)$ and $\\overline{Q}=\\lnot\\!\\left(S\\lor Q\\right)$. Caveat and behavior: The combinational abstraction holds if one assumes zero delay $\\tau=0$, so one can substitute to remove feedback and obtain a single-valued Boolean function $Q=f(S,R)$. With $S=R=1$, the circuit necessarily enters indefinite metastability with undefined outputs at all times.**\n- **Equations:** The equations are correct.\n- **Caveat:** The claim that a combinational abstraction holds for $\\tau=0$ is false. As shown, for $S=R=0$, the algebraic system $Q = \\lnot \\overline{Q}, \\overline{Q} = \\lnot Q$ yields $Q=Q$, which is indeterminate. It is not a single-valued function. This is incorrect.\n- **Behavior for $S=R=1$:** The claim that the circuit enters \"indefinite metastability\" is false. Our analysis showed it forces a stable, well-defined state of $\\{Q,\\overline{Q}\\}=(0,0)$. Metastability or oscillation can occur when transitioning *out* of a forbidden state, but it is not the behavior *during* the $S=R=1$ input. This is incorrect.\n**Verdict: Incorrect**\n\nBased on the detailed analysis, only option A provides a fully correct description of the circuit's equations and behavior.",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}