{
    "hands_on_practices": [
        {
            "introduction": "Ripple counters are appreciated for their simple construction, but this simplicity comes at a cost: propagation delay. This first exercise focuses on calculating the total worst-case delay, a crucial parameter that determines the counter's maximum speed. By understanding how the delay accumulates across each stage, you will grasp the fundamental timing limitation inherent in all asynchronous sequential circuits.",
            "id": "1955756",
            "problem": "A digital control system relies on a 12-bit asynchronous binary counter, commonly known as a ripple counter, for event sequencing. The counter is constructed by cascading toggle flip-flops, where the output of one flip-flop serves as the clock input for the subsequent one. The manufacturer specifies that each individual flip-flop has a clock-to-output propagation delay of 15 nanoseconds (ns). To ensure the integrity of the system's operations, it is crucial to determine the maximum time the counter takes to settle to a stable value after a clock pulse is applied to its first stage. This duration is known as the total worst-case propagation delay.\n\nCalculate the total worst-case propagation delay for this 12-bit ripple counter. Express your answer in nanoseconds (ns).",
            "solution": "A ripple (asynchronous) counter is formed by cascading toggle flip-flops so that the output of each stage serves as the clock input to the next stage. If each flip-flop has a clock-to-output propagation delay $t_{pd}$, then a change at the first stage must propagate through each subsequent stage sequentially. The worst-case settling time occurs when the change ripples through all $N$ stages (e.g., a transition that causes every flip-flop to toggle).\n\nTherefore, the total worst-case propagation delay is the sum of the per-stage delays:\n$$\nT_{\\text{wc}} = N \\, t_{pd}.\n$$\nFor a $12$-bit ripple counter, $N = 12$, and with each flip-flop having $t_{pd} = 15 \\text{ ns}$,\n$$\nT_{\\text{wc}} = 12 \\times 15 \\text{ ns} = 180 \\text{ ns}.\n$$\nHence, the maximum time for the counter to settle after a clock pulse to the first stage is $180 \\text{ ns}$.",
            "answer": "$$\\boxed{180}$$"
        },
        {
            "introduction": "Beyond simply counting to their maximum value, counters are often required to cycle through a custom number of states. This practice problem transitions from analysis to design, challenging you to create a modulo-9 counter from a standard 4-bit binary counter. You will apply combinational logic to detect a specific state and trigger an asynchronous reset, a fundamental technique in digital systems design for creating truncated count sequences.",
            "id": "1947821",
            "problem": "An asynchronous 4-bit binary ripple counter is constructed using four negative-edge-triggered J-K flip-flops, labeled FF0, FF1, FF2, and FF3. The outputs of these flip-flops are $Q_0, Q_1, Q_2, Q_3$ respectively, where $Q_0$ is the Least Significant Bit (LSB) and $Q_3$ is the Most Significant Bit (MSB). For all flip-flops, the J and K inputs are permanently tied to a logic HIGH voltage. The external clock signal is applied only to the clock input of FF0. The clock input for each subsequent flip-flop (FF1, FF2, FF3) is driven by the output of the preceding one (e.g., the clock for FF1 is connected to the $Q_0$ output). All four flip-flops share a common active-low asynchronous clear input, denoted as `CLR_N`.\n\nTo modify this counter into a modulo-9 counter (i.e., a counter that counts from 0 to 8 and then resets to 0), a combinational logic gate is used to drive the `CLR_N` line. The inputs to this gate are selected from the counter's outputs ($Q_3, Q_2, Q_1, Q_0$). The counter should reset as soon as it attempts to enter the invalid state of decimal 9.\n\nWhich of the following logic gate configurations correctly implements the required reset logic for the modulo-9 counter?\n\nA. A 2-input AND gate with its inputs connected to $Q_3$ and $Q_0$.\n\nB. A 2-input AND gate with its inputs connected to $Q_2$ and $Q_1$.\n\nC. A 2-input NAND gate with its inputs connected to $Q_3$ and $Q_1$.\n\nD. A 2-input NAND gate with its inputs connected to $Q_3$ and $Q_0$.\n\nE. A 2-input NOR gate with its inputs connected to $Q_3$ and $Q_0$.",
            "solution": "The problem requires us to design the reset logic for a 4-bit asynchronous counter to make it a modulo-9 counter.\n\nFirst, let's understand the desired behavior of a modulo-9 counter. It should count through the decimal states 0, 1, 2, 3, 4, 5, 6, 7, and 8. The corresponding binary representations using the outputs $Q_3Q_2Q_1Q_0$ are from `0000` to `1000`. The counter must not be allowed to stay in the state corresponding to decimal 9. When the counter reaches the state for decimal 9, it must be immediately reset to the initial state, which is decimal 0 (`0000`).\n\nThe state that triggers the reset is decimal 9. In binary, this state is represented as $Q_3Q_2Q_1Q_0 = 1001$. This is the first invalid state the counter will attempt to enter after reaching the maximum valid count of 8 (`1000`).\n\nThe problem states that the flip-flops have a common active-low asynchronous clear input, `CLR_N`. An \"active-low\" input means that the reset action (clearing the flip-flop outputs to 0) is triggered when the `CLR_N` line receives a logic `0`. For all other times, the `CLR_N` line must be at logic `1` to allow the counter to operate normally.\n\nTherefore, our task is to design a logic circuit whose output is connected to `CLR_N` and satisfies the following conditions:\n1. The output is logic `0` when the counter state is $Q_3Q_2Q_1Q_0 = 1001$.\n2. The output is logic `1` for all valid counting states from $Q_3Q_2Q_1Q_0 = 0000$ to $Q_3Q_2Q_1Q_0 = 1000$.\n\nLet's analyze the reset state `1001`. In this state, the outputs are $Q_3=1$, $Q_2=0$, $Q_1=0$, and $Q_0=1$. We need to find a simple logic gate that can detect this specific condition. A logic gate's output depends on its inputs. We can use the flip-flop outputs $Q_0, Q_1, Q_2, Q_3$ as inputs to our reset gate.\n\nConsider the condition required to generate a logic `0` for the reset. We are looking for a gate that outputs `0` when the state is `1001`.\nThe most straightforward way to detect a specific combination of inputs being HIGH is to use an AND gate or a NAND gate.\n- An AND gate outputs a `1` only when all its inputs are `1`.\n- A NAND gate outputs a `0` only when all its inputs are `1`.\n\nSince we need a logic `0` to trigger the active-low `CLR_N`, a NAND gate is the natural choice. The inputs to the NAND gate should be all `1`s for the state we want to detect.\nIn the state `1001`, the bits that are `1` are $Q_3$ and $Q_0$. So, if we connect $Q_3$ and $Q_0$ to the inputs of a 2-input NAND gate, the output of the gate will be:\n`Output = NOT (Q3 AND Q0)`\n\nLet's test this logic. When the counter tries to enter state 9 (`1001`), the inputs to the NAND gate will be $Q_3=1$ and $Q_0=1$.\n`Output = NOT (1 AND 1) = NOT(1) = 0`.\nThis logic `0` will activate the `CLR_N` line and reset all flip-flops to `0000`.\n\nNow we must verify that this logic does not cause a premature reset during the valid counting sequence (0 to 8).\nThe condition for reset is $Q_3=1$ AND $Q_0=1$. Let's check the states from 0 to 8:\n- State 0 (`0000`): $Q_3=0, Q_0=0$. Output = NOT(0 AND 0) = 1. No reset.\n- State 1 (`0001`): $Q_3=0, Q_0=1$. Output = NOT(0 AND 1) = 1. No reset.\n- ...\n- State 8 (`1000`): $Q_3=1, Q_0=0$. Output = NOT(1 AND 0) = 1. No reset.\nDuring the entire valid count sequence from 0 to 8, the condition ($Q_3=1$ and $Q_0=1$) is never met simultaneously. The first time it is met is at state 9 (`1001`). Therefore, connecting the `CLR_N` line to the output of a 2-input NAND gate with inputs $Q_3$ and $Q_0$ will correctly implement the modulo-9 counter.\n\nLet's evaluate the given options:\nA. A 2-input AND gate with inputs $Q_3$ and $Q_0$: At state 9, the output would be `1 AND 1 = 1`. This would not trigger an active-low reset.\nB. A 2-input AND gate with inputs $Q_2$ and $Q_1$: This would output 1 at state 6 (`0110`), not what is needed.\nC. A 2-input NAND gate with inputs $Q_3$ and $Q_1$: This would output 0 when $Q_3=1$ and $Q_1=1$. This condition first occurs at state 10 (`1010`). This would create a modulo-10 counter, not a modulo-9 counter.\nD. A 2-input NAND gate with inputs $Q_3$ and $Q_0$: As derived, this is the correct configuration. It detects state 9 (`1001`) and outputs a `0` to trigger the reset.\nE. A 2-input NOR gate with inputs $Q_3$ and $Q_0$: The output is `NOT (Q3 OR Q0)`. This would be `0` if either $Q_3$ or $Q_0$ is `1`. This would cause a reset at state 1 (`0001`), which is incorrect.\n\nThus, the correct configuration is a 2-input NAND gate with its inputs connected to $Q_3$ and $Q_0$.",
            "answer": "$$\\boxed{D}$$"
        },
        {
            "introduction": "The asynchronous reset logic used to create modulo-n counters, while effective in theory, can introduce subtle but critical timing problems in practice. This advanced problem delves into the analysis of logic hazards and reset pulse reliability, which arise from the interplay of propagation delays in the feedback path. By examining the conditions that can cause a reset to fail, you will learn why robust digital design often favors synchronous methods or requires careful timing verification.",
            "id": "3674154",
            "problem": "A $4$-stage ripple (asynchronous) binary counter is built from Toggle Flip-Flops (T-FFs), where the least significant bit (LSB) flip-flop toggles on each rising edge of the system clock, and each subsequent stage toggles on the falling edge of the previous stage’s $Q$ output. All T-FFs share a common Asynchronous Clear (CLR, active-high). The intended function is a modulo-$10$ counter that counts from $0000_2$ to $1001_2$ and then asynchronously clears back to $0000_2$ when the terminal count $1010_2$ is detected.\n\nThe terminal count detect uses a two-level combinational network whose output $R$ drives the shared CLR input:\n- Gate $G_1$ implements $G_1 = Q_3 \\land Q_1$ with a propagation delay of $5\\,\\text{ns}$.\n- Gate $G_2$ implements $G_2 = \\lnot Q_2 \\land \\lnot Q_0$ with a propagation delay of $15\\,\\text{ns}$.\n- Gate $G_3$ implements $R = G_1 \\land G_2$ with a propagation delay of $5\\,\\text{ns}$.\n\nAssume the following device characteristics:\n- Each Flip-Flop (FF) has clock-to-$Q$ propagation delay $t_{FF}$ in the range $[10\\,\\text{ns},\\,20\\,\\text{ns}]$.\n- The CLR-to-$Q$ propagation delay for the asynchronous clear input is $t_{CLR}$ in the range $[8\\,\\text{ns},\\,15\\,\\text{ns}]$.\n- Each FF requires a minimum active-high CLR pulse width $t_{w,CLR,min} = 7\\,\\text{ns}$ for a guaranteed reset.\n\nFundamental principles to use:\n- In a ripple counter, only the LSB toggles directly on the system clock; higher-order bits toggle sequentially in response to edges propagating through lower-order $Q$ outputs, with inter-stage skew set by the relevant $t_{FF}$ values.\n- An asynchronous clear that is derived from a combinational decode of the counter outputs immediately feeds back and forces $Q_3=Q_2=Q_1=Q_0=0$ after its own propagation, so the resulting reset pulse width is bounded by the propagation around this feedback loop.\n- Multi-input combinational networks with reconvergent fanout and unequal path delays can exhibit hazards (spurious short pulses or gaps) whenever input variables do not change simultaneously.\n\nA colleague proposes “speeding up” the reset by OR-ing an additional product term that also asserts $R$ for a neighboring illegal state (creating $R' = T_{10} \\lor T_{adj}$), where the two product terms have different internal path delays, and asks whether this reduces risk.\n\nWhich option is correct about the hazard risk and the reset pulse behavior of this design, including the consequence of adding a second reset term with a different path delay?\n\nA. For the single-minterm decode $R = (Q_3 \\land Q_1) \\land (\\lnot Q_2 \\land \\lnot Q_0)$ as implemented, the minimum high pulse width of $R$ at the $1001_2 \\to 1010_2$ transition is approximately $t_{CLR,min} + d_{G_1} + d_{G_3} = 8\\,\\text{ns} + 5\\,\\text{ns} + 5\\,\\text{ns} = 18\\,\\text{ns}$, which exceeds $t_{w,CLR,min} = 7\\,\\text{ns}$, so all FFs reliably clear. Nonetheless, because this is asynchronous feedback, the design is hazard-prone in principle; robust mitigations include synchronizing the terminal count with a flip-flop (synchronous reset) or stretching $R$ with a pulse generator.\n\nB. Because the decoder is a single product of literals (an AND of required conditions), it cannot generate a runt pulse; the reset high level persists until the next system clock edge, so no hazard analysis is necessary.\n\nC. If two different terminal-count product terms that both assert reset over adjacent illegal states are OR-ed with unequal path delays, a static-$1$ hazard can produce a short low-going glitch on the reset net during the transition between those two decoded states, prematurely deasserting CLR before all FFs are cleared. Adding the consensus term to the sum-of-products or synchronizing the reset eliminates this hazard.\n\nD. Reducing the system clock frequency below $1/\\!\\big(4\\,t_{FF,max} + 20\\,\\text{ns}\\big)$ guarantees that no reset-related hazard can occur in any ripple counter because hazards are purely high-frequency effects and vanish at low clock rates.\n\nSelect all correct options.",
            "solution": "## PROBLEM VALIDATION\n\n### Step 1: Extract Givens\n- **Counter Type**: $4$-stage ripple (asynchronous) binary counter.\n- **Flip-Flop Type**: Toggle Flip-Flops (T-FFs).\n- **Clocking Scheme**:\n    - LSB flip-flop (for $Q_0$) toggles on each rising edge of the system clock.\n    - Each subsequent stage (for $Q_{i+1}$) toggles on the falling edge of the previous stage's output ($Q_i$).\n- **Reset**:\n    - Common Asynchronous Clear (CLR, active-high) for all T-FFs.\n    - Intended function: modulo-$10$ counter ($0000_2$ to $1001_2$).\n    - Reset trigger: State $1010_2$ ($Q_3=1, Q_2=0, Q_1=1, Q_0=0$) is detected, which asynchronously clears the counter to $0000_2$.\n- **Reset Logic Implementation**: A three-gate, two-level combinational network.\n    - Gate $G_1$: $G_1 = Q_3 \\land Q_1$. Propagation delay $d_{G_1} = 5\\,\\text{ns}$.\n    - Gate $G_2$: $G_2 = \\lnot Q_2 \\land \\lnot Q_0$. Propagation delay $d_{G_2} = 15\\,\\text{ns}$.\n    - Gate $G_3$: $R = G_1 \\land G_2$. Propagation delay $d_{G_3} = 5\\,\\text{ns}$. The signal $R$ drives the common CLR input.\n- **Device Characteristics**:\n    - Clock-to-$Q$ propagation delay: $t_{FF} \\in [10\\,\\text{ns}, 20\\,\\text{ns}]$.\n    - Asynchronous Clear-to-$Q$ propagation delay: $t_{CLR} \\in [8\\,\\text{ns}, 15\\,\\text{ns}]$.\n    - Minimum required CLR pulse width: $t_{w,CLR,min} = 7\\,\\text{ns}$.\n- **Proposed Modification**: OR-ing an additional product term ($T_{adj}$) to the reset logic, i.e., $R' = R \\lor T_{adj}$, where $R$ and $T_{adj}$ are product terms with different internal path delays. This is proposed to \"speed up\" the reset.\n\n### Step 2: Validate Using Extracted Givens\nThe problem statement describes a standard, albeit non-robust, method for implementing a truncated-sequence asynchronous counter. All parameters (propagation delays, setup times) are physically realistic. The logic function for the reset correctly decodes the intended terminal state. The question probes the behavior of the asynchronous reset loop and the potential for logic hazards, which are critical and well-understood concepts in digital electronics.\n\n- **Scientifically Grounded**: The problem is grounded in the fundamental principles of digital logic, including ripple counters, asynchronous resets, propagation delays, and combinational logic hazards. All concepts are standard topics in computer organization and digital design.\n- **Well-Posed**: The problem provides sufficient information to analyze the reset pulse width and evaluate the hazard risks. A unique analysis of the described circuit is possible.\n- **Objective**: The language is precise and quantitative. The \"colleague's proposal\" serves as a a specific scenario for evaluating hazard theory.\n\n### Step 3: Verdict and Action\nThe problem is valid. It is a well-defined question in digital logic design concerning timing, asynchronous feedback, and hazard analysis. Proceeding with the solution.\n\n## SOLUTION DERIVATION\n\nThe core of this problem lies in analyzing the timing of the asynchronous reset feedback loop and understanding the conditions that create combinational logic hazards.\n\n### Reset Pulse Width Analysis\nThe counter is designed to reset when it reaches the state $Q_3Q_2Q_1Q_0 = 1010_2$. The reset is asynchronous, meaning it is triggered by the state itself, not by a clock edge. This creates a feedback loop:\n1. The counter enters state $1010_2$.\n2. The combinational decode logic detects this state and its output, $R$, goes from $0$ to $1$.\n3. The active-high $R$ signal is applied to the CLR input of all four flip-flops.\n4. After a delay of $t_{CLR}$, the flip-flop outputs ($Q_3, Q_2, Q_1, Q_0$) are forced to $0$.\n5. With the state now being $0000_2$, the condition for the decode logic is no longer met, and its output $R$ goes from $1$ to $0$.\n6. The CLR signal is de-asserted.\n\nThe time duration for which the reset signal $R$ remains high constitutes the reset pulse. For the reset to be successful, this pulse width, $t_{w,R}$, must be greater than the minimum required clear pulse width, $t_{w,CLR,min}$.\n\nThe pulse width $t_{w,R}$ is the sum of two delays:\na) The time for the flip-flops to clear after $R$ goes high: $t_{CLR}$.\nb) The time for the change in $Q$ outputs (from $1010_2$ to $0000_2$) to propagate through the decode logic and cause $R$ to go low.\n\nLet's calculate the logic delay for de-assertion. The reset logic is $R = G_1 \\land G_2 = (Q_3 \\land Q_1) \\land (\\lnot Q_2 \\land \\lnot Q_0)$.\nWhen the FFs clear, the state becomes $Q_3Q_2Q_1Q_0 = 0000_2$.\n- The inputs to $G_1$ become $Q_3=0, Q_1=0$. The output $G_1$ goes to $0$.\n- The inputs to $G_2$ were $\\lnot Q_2, \\lnot Q_0$ for state $1010_2$, which are $\\lnot 0, \\lnot 0$, so $G_2=1$. After reset to $0000_2$, the inputs are the same, so $G_2$ remains $1$.\n- The final gate is $G_3$ with $R = G_1 \\land G_2$. Since $G_1$ goes to $0$, $R$ goes to $0$.\nThe de-assertion path is thus from the $Q$ outputs changing, through $G_1$, and then through $G_3$. The total logic delay for de-assertion is $d_{G_1} + d_{G_3} = 5\\,\\text{ns} + 5\\,\\text{ns} = 10\\,\\text{ns}$.\n\nThe total reset pulse width is $t_{w,R} = t_{CLR} + (d_{G_1} + d_{G_3})$.\nTo check for reliability, we must consider the worst case, which is the shortest possible pulse. This occurs when all delays take their minimum values.\n$t_{w,R,min} = t_{CLR,min} + (d_{G_1} + d_{G_3}) = 8\\,\\text{ns} + (5\\,\\text{ns} + 5\\,\\text{ns}) = 18\\,\\text{ns}$.\n\n### Hazard Analysis\n- **Original Design**: The reset decoder $R = Q_3 \\land Q_1 \\land \\lnot Q_2 \\land \\lnot Q_0$ is a single 4-input AND gate (conceptually). This is a single product term. Such a circuit is not susceptible to static-1 hazards (where the output should stay $1$ but glitches to $0$). It could theoretically exhibit a static-0 hazard (a spurious $1$ pulse where the output should be $0$) due to unequal path delays from the $Q$ inputs, especially in a ripple counter where inputs change sequentially. However, for a single product term to glitch high, all its inputs must simultaneously be in the \"assert\" state. For the given transitions, an analysis of intermediate states shows no such condition occurs. The design is principally vulnerable because it uses asynchronous feedback, making timing margins critical.\n- **Proposed Modification**: The colleague's proposal is to create a Sum-of-Products (SOP) expression for the reset signal: $R' = P_1 \\lor P_2$, where $P_1$ and $P_2$ have unequal path delays and decode adjacent states. This is the canonical structure for a **static-1 hazard**. If the circuit is meant to transition from one of the decoded states to the other, the output $R'$ should remain high. However, if the gate that turns *off* the first product term ($P_1$) is faster than the gate that turns *on* the second term ($P_2$), the output $R'$ may momentarily go low. This creates a low-going glitch in an otherwise high signal.\n\n## OPTION-BY-OPTION ANALYSIS\n\n**A. For the single-minterm decode $R = (Q_3 \\land Q_1) \\land (\\lnot Q_2 \\land \\lnot Q_0)$ as implemented, the minimum high pulse width of $R$ at the $1001_2 \\to 1010_2$ transition is approximately $t_{CLR,min} + d_{G_1} + d_{G_3} = 8\\,\\text{ns} + 5\\,\\text{ns} + 5\\,\\text{ns} = 18\\,\\text{ns}$, which exceeds $t_{w,CLR,min} = 7\\,\\text{ns}$, so all FFs reliably clear. Nonetheless, because this is asynchronous feedback, the design is hazard-prone in principle; robust mitigations include synchronizing the terminal count with a flip-flop (synchronous reset) or stretching $R$ with a pulse generator.**\n\n- The calculation for the minimum reset pulse width, $t_{w,R,min} = t_{CLR,min} + (d_{G_1} + d_{G_3}) = 8\\,\\text{ns} + 10\\,\\text{ns} = 18\\,\\text{ns}$, is correct as derived above.\n- The conclusion that $18\\,\\text{ns} > t_{w,CLR,min} = 7\\,\\text{ns}$ and therefore the reset should be reliable is also correct.\n- The final statement correctly identifies that asynchronous feedback designs are inherently risky (\"hazard-prone in principle\") and lists standard, robust design alternatives like synchronous resets or pulse stretching. This is a sound piece of engineering advice.\n- **Verdict: Correct.**\n\n**B. Because the decoder is a single product of literals (an AND of required conditions), it cannot generate a runt pulse; the reset high level persists until the next system clock edge, so no hazard analysis is necessary.**\n\n- The statement that \"the reset high level persists until the next system clock edge\" is fundamentally incorrect. The reset is asynchronous. Its duration is determined entirely by the propagation delays around the feedback loop (FF clear time + logic propagation time), as analyzed above. It is not synchronized with the clock in any way. Because this central claim is false, the option is invalid.\n- **Verdict: Incorrect.**\n\n**C. If two different terminal-count product terms that both assert reset over adjacent illegal states are OR-ed with unequal path delays, a static-1 hazard can produce a short low-going glitch on the reset net during the transition between those two decoded states, prematurely deasserting CLR before all FFs are cleared. Adding the consensus term to the sum-of-products or synchronizing the reset eliminates this hazard.**\n\n- This option describes the colleague's proposal. It provides a textbook-perfect and accurate description of a static-1 hazard.\n- **Cause**: An SOP expression ($P_1 \\lor P_2$) with unequal path delays for terms covering adjacent states.\n- **Effect**: A short low-going glitch on the output (the reset signal) during a transition between the states.\n- **Consequence**: The premature de-assertion of the CLR signal, which can lead to an incomplete reset if the glitch is fast enough.\n- **Remedy**: The stated solutions, adding the consensus term (e.g., $AB + A'C$ becomes $AB + A'C + BC$) or using a synchronous design, are the standard methods to mitigate this exact problem.\n- The statement is a correct and relevant analysis of the consequences of the proposed modification mentioned in the problem description.\n- **Verdict: Correct.**\n\n**D. Reducing the system clock frequency below $1/\\!\\big(4\\,t_{FF,max} + 20\\,\\text{ns}\\big)$ guarantees that no reset-related hazard can occur in any ripple counter because hazards are purely high-frequency effects and vanish at low clock rates.**\n\n- The expression in the denominator, $4\\,t_{FF,max} + 20\\,\\text{ns}$, represents the worst-case settling time for the 4-bit ripple counter plus the decoder delay. Running the clock slower than this ensures that the counter state fully settles before the next clock edge arrives.\n- However, this does not eliminate combinational hazards. A hazard is a glitch that occurs *during* a transition, caused by differential path delays within the logic network itself. A slower clock provides more time between transitions but does not change the internal behavior of the logic *during* a transition. The glitch will still occur regardless of the clock frequency.\n- The claim that hazards are \"purely high-frequency effects\" is false. While their impact can be more severe at high frequencies (e.g., a glitch might be mistaken for a valid clock pulse), the underlying race condition that causes the hazard is independent of the system clock's frequency.\n- **Verdict: Incorrect.**",
            "answer": "$$\\boxed{AC}$$"
        }
    ]
}