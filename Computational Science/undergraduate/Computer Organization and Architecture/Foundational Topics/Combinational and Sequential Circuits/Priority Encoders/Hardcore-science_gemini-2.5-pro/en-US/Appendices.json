{
    "hands_on_practices": [
        {
            "introduction": "Understanding the fundamental behavior of a priority encoder is the first step toward mastering its use in digital systems. This exercise provides a direct, hands-on check of this core principle by asking you to determine the output for a specific set of inputs. By working through this problem , you will solidify your understanding of how the encoder identifies the highest-priority active signal and represents it as a binary code.",
            "id": "1954014",
            "problem": "A 4-to-2 priority encoder is a combinational logic circuit that accepts four inputs and produces a two-bit binary output. The encoder is designed to identify the highest-priority active input among its four data inputs, denoted as $I_3$, $I_2$, $I_1$, and $I_0$. For this specific device, the input $I_3$ has the highest priority, followed by $I_2$, then $I_1$, and finally $I_0$ with the lowest priority.\n\nThe encoder has two binary outputs, $Y_1$ and $Y_0$, which represent the binary index of the highest-priority active input (where 'active' means the input is at logic '1'). For example, if $I_2$ were the highest-priority active input, the output $Y_1Y_0$ would be the binary representation of 2, which is '10'. In addition to the encoded output, there is a 'Valid' bit, $V$. The Valid bit $V$ is set to '1' if one or more of the inputs are active, and it is '0' only when all inputs are inactive (logic '0').\n\nGiven an input data vector where $I_3I_2I_1I_0 = 1011$, determine the resulting state of the outputs $V, Y_1,$ and $Y_0$. Select the correct option from the choices below.\n\nA. $V=1, Y_1=0, Y_0=1$\n\nB. $V=1, Y_1=1, Y_0=0$\n\nC. $V=1, Y_1=1, Y_0=1$\n\nD. $V=0, Y_1=1, Y_0=1$\n\nE. $V=1, Y_1=0, Y_0=0$",
            "solution": "A 4-to-2 priority encoder selects the highest-priority asserted input and outputs its index in binary on $(Y_{1},Y_{0})$, with $V$ indicating whether any input is asserted. Using standard Boolean algebra (with $+$ as OR, concatenation or $\\cdot$ as AND, and overline as NOT), the canonical expressions for a 4-to-2 priority encoder with priority $I_{3} \\succ I_{2} \\succ I_{1} \\succ I_{0}$ are:\n$$V = I_{3} + I_{2} + I_{1} + I_{0},$$\n$$Y_{1} = I_{3} + \\overline{I_{3}}I_{2},$$\n$$Y_{0} = I_{3} + \\overline{I_{3}}\\overline{I_{2}}I_{1}.$$\nJustification:\n- $V$ is $1$ if any input is active, hence the OR of all inputs.\n- $Y_{1}$ is $1$ exactly when the selected index is $2$ or $3$, which occurs if $I_{3}=1$ or (if $I_{3}=0$ and) $I_{2}=1$, yielding $I_{3} + \\overline{I_{3}}I_{2}$.\n- $Y_{0}$ is $1$ when the selected index is odd (either $1$ or $3$). Index $3$ occurs if $I_{3}=1$, and index $1$ occurs only when $I_{3}=0$, $I_{2}=0$, and $I_{1}=1$, giving $I_{3} + \\overline{I_{3}}\\overline{I_{2}}I_{1}$.\n\nGiven $I_{3}I_{2}I_{1}I_{0} = 1011$, we have $I_{3}=1$, $I_{2}=0$, $I_{1}=1$, $I_{0}=1$. Substituting:\n$$V = 1 + 0 + 1 + 1 = 1,$$\n$$Y_{1} = 1 + \\overline{1}\\cdot 0 = 1 + 0 \\cdot 0 = 1,$$\n$$Y_{0} = 1 + \\overline{1}\\cdot\\overline{0}\\cdot 1 = 1 + 0 \\cdot 1 \\cdot 1 = 1.$$\nThus the outputs are $V=1$, $Y_{1}=1$, $Y_{0}=1$, which corresponds to option C.",
            "answer": "$$\\boxed{C}$$"
        },
        {
            "introduction": "Digital components like priority encoders are building blocks, rarely used in isolation. This practice  takes you a step further by challenging you to design a secondary logic circuit that interprets the encoder's output. This exercise highlights the importance of treating the encoder's output as a meaningful binary number and using it to make subsequent logical decisions, a common task in system design.",
            "id": "1954013",
            "problem": "An 8-to-3 priority encoder has eight active-high inputs, denoted $I_7, I_6, \\dots, I_0$, and produces a 3-bit binary output code, denoted $Y_2Y_1Y_0$. The encoder operates such that its output represents the binary index of the highest-indexed input that is currently active (at a logic '1' state). For instance, if inputs $I_5$, $I_2$, and $I_1$ are all active, the encoder's output will be $Y_2Y_1Y_0 = 101$ because $I_5$ has the highest index among the active inputs. The problem considers only cases where at least one input is active.\n\nThis 3-bit output from the priority encoder is fed into a secondary combinational logic circuit. This secondary circuit is designed to produce a single-bit output, $F$. The function of this circuit is to assert its output $F$ to '1' if and only if the highest-indexed active input to the priority encoder is one with an odd index (i.e., $I_1, I_3, I_5,$ or $I_7$). Otherwise, the output $F$ is '0'.\n\nDetermine the minimized sum-of-products (SOP) Boolean expression for the output $F$ as a function of the encoder's outputs $Y_2, Y_1,$ and $Y_0$.",
            "solution": "The 8-to-3 priority encoder outputs the binary index $k \\in \\{0,1,\\dots,7\\}$ of the highest-indexed active input. The secondary circuit must output $F=1$ if and only if $k$ is odd, i.e., $k \\in \\{1,3,5,7\\}$. Since the encoderâ€™s outputs $(Y_{2},Y_{1},Y_{0})$ represent $k$ in standard binary, the minterms where $F=1$ are exactly those where $(Y_{2},Y_{1},Y_{0})$ equals $001,011,101,111$.\n\nWriting the canonical sum-of-products from these minterms:\n$$\nF = \\overline{Y_{2}}\\,\\overline{Y_{1}}\\,Y_{0} \\;+\\; \\overline{Y_{2}}\\,Y_{1}\\,Y_{0} \\;+\\; Y_{2}\\,\\overline{Y_{1}}\\,Y_{0} \\;+\\; Y_{2}\\,Y_{1}\\,Y_{0}.\n$$\nFactor out $Y_{0}$:\n$$\nF = Y_{0}\\left(\\overline{Y_{2}}\\,\\overline{Y_{1}} \\;+\\; \\overline{Y_{2}}\\,Y_{1} \\;+\\; Y_{2}\\,\\overline{Y_{1}} \\;+\\; Y_{2}\\,Y_{1}\\right).\n$$\nGroup and simplify using $\\overline{A}+A=1$ and distributivity:\n$$\n\\overline{Y_{2}}\\,\\overline{Y_{1}} + \\overline{Y_{2}}\\,Y_{1} = \\overline{Y_{2}}(\\overline{Y_{1}}+Y_{1}) = \\overline{Y_{2}},\n$$\n$$\nY_{2}\\,\\overline{Y_{1}} + Y_{2}\\,Y_{1} = Y_{2}(\\overline{Y_{1}}+Y_{1}) = Y_{2},\n$$\nso\n$$\nF = Y_{0}\\left(\\overline{Y_{2}} + Y_{2}\\right) = Y_{0}\\cdot 1 = Y_{0}.\n$$\nThus the minimized SOP expression is simply the least significant bit of the encoder output.",
            "answer": "$$\\boxed{Y_{0}}$$"
        },
        {
            "introduction": "Bridging the gap between abstract logic schematics and practical implementation is a key skill in modern digital design. This problem guides you through expressing the function of a priority encoder using a Hardware Description Language (HDL), specifically Verilog . By modeling the priority logic with a concise coding structure, you will see how theoretical concepts are translated into a format ready for synthesis on real hardware.",
            "id": "1943463",
            "problem": "In digital logic design, a priority encoder is a combinational circuit that converts multiple binary inputs into a smaller number of outputs. The output represents the binary-coded index of the highest-priority input that is active.\n\nConsider a 4-to-2 priority encoder module to be implemented in a Hardware Description Language (HDL) like Verilog. The module has the following interface:\n- A 4-bit input vector `d`, where `d[3]` has the highest priority and `d[0]` has the lowest priority.\n- A 2-bit output vector `y`, which should represent the binary index of the highest-priority asserted (logic '1') input.\n- A 1-bit output `v` (for \"valid\"), which should be '1' if any input in `d` is asserted, and '0' otherwise.\n\nIf no inputs are asserted (i.e., `d` is `4'b0000`), the `v` output must be '0', and the `y` output value can be considered a \"don't care\" (conventionally set to '0's).\n\nYour task is to identify the single continuous assignment statement, using nested conditional (ternary) operators (`? :`), that correctly implements the logic for this 4-to-2 priority encoder by assigning the appropriate value to the concatenated vector `{v, y}`.\n\nWhich of the following Verilog statements correctly models the specified priority encoder?\n\nA. `assign {v, y} = d[3] ? 3'b111 : d[2] ? 3'b110 : d[1] ? 3'b101 : d[0] ? 3'b100 : 3'b000;`\n\nB. `assign {v, y} = d[0] ? 3'b100 : d[1] ? 3'b101 : d[2] ? 3'b110 : d[3] ? 3'b111 : 3'b000;`\n\nC. `assign {v, y} = d[3] ? 3'b111 : d[2] ? 3'b110 : d[1] ? 3'b110 : d[0] ? 3'b100 : 3'b000;`\n\nD. `assign {v, y} = d[3] ? 3'b111 : d[2] ? 3'b110 : d[1] ? 3'b101 : d[0] ? 3'b100 : 3'b100;`\n\nE. `assign {v, y} = d[3] ? 3'b111 : d[2] ? 3'b101 : d[1] ? 3'b011 : d[0] ? 3'b001 : 3'b000;`",
            "solution": "The user is asked to find the correct Verilog implementation of a 4-to-2 priority encoder using a single `assign` statement with nested conditional operators. The output of the assignment is the 3-bit concatenated vector `{v, y}`.\n\nFirst, let's establish the truth table for the priority encoder based on the problem description. The inputs are `d[3:0]` and the outputs are `v` and `y[1:0]`. The priority is `d[3] > d[2] > d[1] > d[0]`. We also determine the required 3-bit value for the concatenated vector `{v, y}`. The 'x' in the truth table represents a \"don't care\" condition.\n\n| `d[3]` | `d[2]` | `d[1]` | `d[0]` |  `v`  | `y[1:0]` | `{v, y}` (3-bit value) |\n|:------:|:------:|:------:|:------:|:-----:|:--------:|:----------------------:|\n|   1    |   x    |   x    |   x    |   1   |  `2'b11` |        `3'b111`        |\n|   0    |   1    |   x    |   x    |   1   |  `2'b10` |        `3'b110`        |\n|   0    |   0    |   1    |   x    |   1   |  `2'b01` |        `3'b101`        |\n|   0    |   0    |   0    |   1    |   1   |  `2'b00` |        `3'b100`        |\n|   0    |   0    |   0    |   0    |   0   |  `2'b00` |        `3'b000`        |\n*(Note: For the case where no input is asserted, `y` is a don't care, and is conventionally set to `2'b00`)*\n\nThe nested conditional (ternary) operator `condition ? value_if_true : value_if_false` in Verilog creates a priority structure equivalent to an `if-else if-else` chain. The statement will check conditions in the order they appear.\n\nLet's construct the correct statement based on the truth table and priority rules:\n\n1.  **Check the highest priority input, `d[3]`:** If `d[3]` is '1', the output `{v, y}` must be `3'b111`.\n    The statement begins: `d[3] ? 3'b111 : ...`\n\n2.  **Check the next priority input, `d[2]`:** If `d[3]` is '0', we check `d[2]`. If `d[2]` is '1', the output `{v, y}` must be `3'b110`.\n    This forms the first nesting: `d[3] ? 3'b111 : (d[2] ? 3'b110 : ...)`\n\n3.  **Check `d[1]`:** If both `d[3]` and `d[2]` are '0', we check `d[1]`. If `d[1]` is '1', the output `{v, y}` must be `3'b101`.\n    The nesting continues: `... : (d[2] ? 3'b110 : (d[1] ? 3'b101 : ...))`\n\n4.  **Check the lowest priority input, `d[0]`:** If `d[3]`, `d[2]`, and `d[1]` are all '0', we check `d[0]`. If `d[0]` is '1', the output `{v, y}` must be `3'b100`.\n    The nesting becomes: `... : (d[1] ? 3'b101 : (d[0] ? 3'b100 : ...))`\n\n5.  **Default case:** If all inputs are '0', none of the conditions are met. This is the final `else` case. The output `{v, y}` must be `3'b000`.\n    The full statement is: `assign {v, y} = d[3] ? 3'b111 : d[2] ? 3'b110 : d[1] ? 3'b101 : d[0] ? 3'b100 : 3'b000;`\n\nNow, we evaluate the given options:\n\n*   **A: `assign {v, y} = d[3] ? 3'b111 : d[2] ? 3'b110 : d[1] ? 3'b101 : d[0] ? 3'b100 : 3'b000;`**\n    This statement perfectly matches our derived logic. It correctly implements the priority from `d[3]` down to `d[0]` and produces the correct `{v, y}` values for each case, including the default case. This is the correct answer.\n\n*   **B: `assign {v, y} = d[0] ? 3'b100 : d[1] ? 3'b101 : d[2] ? 3'b110 : d[3] ? 3'b111 : 3'b000;`**\n    This statement reverses the priority order, checking `d[0]` first. It implements a priority encoder where `d[0]` has the highest priority, which contradicts the problem specification.\n\n*   **C: `assign {v, y} = d[3] ? 3'b111 : d[2] ? 3'b110 : d[1] ? 3'b110 : d[0] ? 3'b100 : 3'b000;`**\n    This statement has an error in the output for the `d[1]` case. It outputs `3'b110` when `d[1]` is asserted (and `d[3]`, `d[2]` are not), which corresponds to `{v=1, y=2'b10}`. The correct output should be `{v=1, y=2'b01}` or `3'b101`.\n\n*   **D: `assign {v, y} = d[3] ? 3'b111 : d[2] ? 3'b110 : d[1] ? 3'b101 : d[0] ? 3'b100 : 3'b100;`**\n    This statement has an error in the final `else` (default) case. If no inputs are asserted (`d == 4'b0000`), it assigns `3'b100` to `{v, y}`. This means `v` becomes '1', which is incorrect as the valid bit should be '0' when no inputs are active.\n\n*   **E: `assign {v, y} = d[3] ? 3'b111 : d[2] ? 3'b101 : d[1] ? 3'b011 : d[0] ? 3'b001 : 3'b000;`**\n    This statement appears to be constructed for an assignment to `{y, v}` instead of `{v, y}`. Let's analyze the `d[2]` case: the correct output for `{v, y}` is `3'b110`. This statement provides `3'b101`, which would mean `v=1, y=2'b01`. This corresponds to an index of 1, not 2. However, if the target were `{y, v}`, the value would be `{2'b10, 1'b1}`, which is `3'b101`. This option shows a misunderstanding of the concatenation order specified in the problem.\n\nTherefore, option A is the only one that correctly models the specified 4-to-2 priority encoder logic.",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}