{
    "hands_on_practices": [
        {
            "introduction": "有限状态机（FSM）是序贯逻辑的核心，但其输出行为根据设计（Mealy 型或 Moore 型）的不同而有细微但关键的时序差异。此练习旨在通过设计一个同步串行码型检测器，帮助您深入理解这两种 FSM 结构在输出生成上的根本区别。通过分析 Mealy 型和 Moore 型机器的输出信号相对于最后一个输入位的产生时间，您将掌握序贯电路中状态、输入和输出之间的精确时序关系。",
            "id": "3628036",
            "problem": "一个同步串行模式检测器处理一个单比特输入流，以检测二进制字 $1011$。该检测器以周期 $T$ 进行时钟同步，并在上升沿采样输入。令 $k \\in \\mathbb{Z}$ 作为上升沿的索引。定义周期 $k$ 为上升沿 $k$ 和 $k+1$ 之间的开区间。假设输入是同步的：在周期 $k$ 期间应用的比特表示为 $x[k] \\in \\{0,1\\}$，并且在整个周期 $k$ 内直到下一个上升沿都保持稳定。\n\n考虑两种实现方式：\n\n- Mealy 型有限状态机 (FSM)：其在周期 $k$ 的输出 $z[k]$ 是当前状态 $S[k]$ 和当前输入 $x[k]$ 的函数。\n- Moore 型有限状态机 (FSM)：其在周期 $k$ 的输出 $y[k]$ 仅是当前状态 $S[k]$ 的函数。\n\n在这两种设计中，下一状态由组合逻辑在周期 $k$ 计算得出，是当前状态和当前输入的函数，然后在上升沿 $k+1$ 被寄存：$S[k+1] = f(S[k], x[k])$。该序列检测器允许重叠（例如，在 $10111$ 中有两次检测）。考虑三种输出变体：\n- 原始 Mealy 输出 $z[k]$（未寄存）。\n- 寄存的 Mealy 输出 $z_{r}[k]$，通过将 $z[k-1]$ 送入一个由同一上升沿触发的 D 型触发器 (DFF) 形成，使得 $z_{r}[k]$ 等于在边沿 $k$ 捕获的 $z[k-1]$ 的值。\n- Moore 输出 $y[k]$（作为寄存状态的函数）。\n\n假设输入呈现子序列 $x[n-3]=1$, $x[n-2]=0$, $x[n-1]=1$, $x[n]=1$，且 $x[n-4]=0$，因此在周期 $n-3$ 到 $n$ 期间的四个比特恰好是目标字 $1011$，并且没有更早的匹配跨越这些周期。相对于 $T$，忽略传播延迟，除非它们决定了变化是在一个周期内发生还是在后续周期发生，并假设在此分析中所有逻辑都是无冒险的。\n\n关于检测器输出相对于最后一个比特 $x[n]=1$ 何时首次置位（变为 $1$）的以下时序陈述中，哪一个是正确的？\n\nA. 未寄存的 Mealy 输出 $z[k]$ 可以在周期 $n$ 期间首次置位，而 Moore 输出 $y[k]$ 在周期 $n+1$ 期间首次置位。如果将 $z[k]$ 寄存以形成 $z_{r}[k]$，则 $z_{r}[k]$ 在周期 $n+1$ 期间首次置位。\n\nB. 一个在上升沿采样的同步下游寄存器可以在边沿 $n$ 就观测到未寄存的 Mealy 输出已置位，而 Moore 输出则需要等到边沿 $n+1$。\n\nC. 未寄存的 Mealy 输出和 Moore 输出都可以在周期 $n$ 期间首次置位，因为两者都依赖于周期 $n$ 开始时上升沿之后立即可用的信号。\n\nD. 寄存 Mealy 输出总是相对于最后一个输入比特增加两个完整周期的延迟，所以 $z_{r}[k]$ 在周期 $n+2$ 期间首次置位。",
            "solution": "问题陈述是同步数字逻辑设计领域中一个定义明确的问题，具体涉及 Mealy 和 Moore 型有限状态机 (FSM) 的时序特性。所提供的关于状态机、时钟同步和输入/输出行为的定义是标准的，并与既有理论一致。该问题具有科学依据，定义良好且客观。它包含了推导出唯一且可验证解所需的所有信息。因此，该问题是有效的。\n\n我们将分析三种指定检测器实现的输出置位时序：未寄存的 Mealy FSM、Moore FSM 和寄存的 Mealy FSM。目标是检测序列 $1011$。该序列首次出现的最后一位是 $x[n]=1$，它出现在周期 $n$ 期间。\n\n首先，我们确定状态转换行为。FSM 在周期 $k$ 开始时的状态表示为 $S[k]$。此状态是由周期 $k$ 开始时的上升沿触发的寄存器的输出。状态转换函数为 $S[k+1] = f(S[k], x[k])$，其中 $x[k]$ 是周期 $k$ 期间的输入。\n\n**1. 未寄存的 Mealy FSM**\n\n在 Mealy 型状态机中，输出 $z[k]$ 是当前状态 $S[k]$ 和当前输入 $x[k]$ 的函数，即 $z[k] = g(S[k], x[k])$。由于此输出由组合逻辑生成，其值在周期 $k$ 内，在状态寄存器和输出逻辑本身的传播延迟之后可用。\n\n我们设计一个 FSM 来检测 `$1011$`。状态表示输入流中作为 `$1011$` 前缀的最长后缀。\n- $S_0$：空前缀（复位状态）。\n- $S_1$：匹配前缀 `$1$`。\n- $S_2$：匹配前缀 `$10$`。\n- $S_3$：匹配前缀 `$101$`。\n\n当机器处于状态 $S_3$ 并接收到输入 $1$ 时，就检测到了 `$1011$`。输出逻辑 $g(S,x)$ 仅在 $S=S_3$ 且 $x=1$ 的情况下为 $1$。\n\n让我们跟踪给定输入序列的状态转换：$x[n-4]=0, x[n-3]=1, x[n-2]=0, x[n-1]=1, x[n]=1$。我们假设在此序列之前，FSM 处于状态 $S_0$，这由 $x[n-4]=0$ 保证。\n\n-   **周期 $n-3$**：在上升沿 $n-3$ 时，状态为 $S[n-3]=S_0$。输入为 $x[n-3]=1$。\n    在边沿 $n-2$ 锁存的下一状态是 $S[n-2]=f(S_0,1)=S_1$。\n    此周期内的 Mealy 输出为 $z[n-3]=g(S_0,1)=0$。\n\n-   **周期 $n-2$**：在上升沿 $n-2$ 时，状态为 $S[n-2]=S_1$。输入为 $x[n-2]=0$。\n    在边沿 $n-1$ 锁存的下一状态是 $S[n-1]=f(S_1,0)=S_2$。\n    Mealy 输出为 $z[n-2]=g(S_1,0)=0$。\n\n-   **周期 $n-1$**：在上升沿 $n-1$ 时，状态为 $S[n-1]=S_2$。输入为 $x[n-1]=1$。\n    在边沿 $n$ 锁存的下一状态是 $S[n]=f(S_2,1)=S_3$。\n    Mealy 输出为 $z[n-1]=g(S_2,1)=0$。\n\n-   **周期 $n$**：在上升沿 $n$ 时，状态为 $S[n]=S_3$。输入为 $x[n]=1$。序列 `$1011$` 现在完成。\n    此周期内的 Mealy 输出为 $z[n]=g(S_3,1)=1$。\n    此输出在周期 $n$ 期间置位为 $1$，在状态 $S[n]$ 变为可用且 $g$ 的组合逻辑计算出结果之后。\n\n因此，未寄存的 Mealy 输出 $z[k]$ 在周期 $n$ 期间首次置位。\n\n**2. Moore FSM**\n\n在 Moore 型状态机中，输出 $y[k]$ 仅是当前状态 $S[k]$ 的函数，即 $y[k]=h(S[k])$。输出在整个周期内保持稳定。为了表示检测到一个序列，FSM 必须进入一个其关联输出为 $1$ 的特定状态。\n\n为了检测 `$1011$`，与 Mealy FSM 相比，我们需要一个额外的状态（我们称之为 $S_4$）来表示已接收到完整序列。\n- $S_0, S_1, S_2, S_3$：与上面相同，对于 $i \\in \\{0, 1, 2, 3\\}$，输出 $h(S_i)=0$。\n- $S_4$：匹配序列 `$1011$`。输出 $h(S_4)=1$。\n\n让我们跟踪状态转换：\n- 直到周期 $n$ 的状态进展与 Mealy 机相同：$S[n-3]=S_0$, $S[n-2]=S_1$, $S[n-1]=S_2$, $S[n]=S_3$。\n- **周期 $n$**：在上升沿 $n$ 时，状态为 $S[n]=S_3$。输入为 $x[n]=1$。\n    此周期内的 Moore 输出为 $y[n]=h(S[n]) = h(S_3) = 0$。\n    由 $f(S[n],x[n]) = f(S_3,1)$ 决定的下一状态是检测状态 $S_4$。所以，$S[n+1]=S_4$。此状态在上升沿 $n+1$ 被锁存。\n\n- **周期 $n+1$**：在上升沿 $n+1$ 时，状态变为 $S[n+1]=S_4$。\n    此周期内的 Moore 输出为 $y[n+1]=h(S[n+1]) = h(S_4) = 1$。\n\n因此，Moore 输出 $y[k]$ 在周期 $n+1$ 开始时首次置位。\n\n**3. 寄存的 Mealy 输出**\n\n寄存的 Mealy 输出 $z_r[k]$ 定义为在上升沿 $k$ 时由 D 型触发器捕获的 $z[k-1]$ 的值。这意味着在周期 $k$ 期间 $z_r$ 的值等于周期 $k-1$ 期间 $z$ 的值。所以，$z_r[k] = z[k-1]$。\n\n- 我们发现未寄存的输出 $z[k]$ 对于所有 $k  n$ 均为 $0$，且 $z[n]=1$。\n- 为了找到 $z_r[k]$ 何时首次置位，我们可以评估其在 $n$ 周围周期的值：\n    - 对于周期 $n$，$z_r[n] = z[n-1] = 0$。\n    - 对于周期 $n+1$，$z_r[n+1] = z[n] = 1$。\n\n因此，寄存的 Mealy 输出 $z_r[k]$ 在周期 $n+1$ 期间首次置位。\n\n**结果总结**\n- 未寄存的 Mealy 输出 $z[k]$ 在周期 $n$ 期间首次置位。\n- Moore 输出 $y[k]$ 在周期 $n+1$ 期间首次置位。\n- 寄存的 Mealy 输出 $z_r[k]$ 在周期 $n+1$ 期间首次置位。\n\n现在我们评估给定的选项。\n\n**A. 未寄存的 Mealy 输出 $z[k]$ 可以在周期 $n$ 期间首次置位，而 Moore 输出 $y[k]$ 在周期 $n+1$ 期间首次置位。如果将 $z[k]$ 寄存以形成 $z_{r}[k]$，则 $z_{r}[k]$ 在周期 $n+1$ 期间首次置位。**\n这个陈述与我们为所有三种输出推导出的结果完全匹配。\n**结论：正确。**\n\n**B. 一个在上升沿采样的同步下游寄存器可以在边沿 $n$ 就观测到未寄存的 Mealy 输出已置位，而 Moore 输出则需要等到边沿 $n+1$。**\n未寄存的 Mealy 输出 $z[n]$ 是由 $S[n]$ 和 $x[n]$ 生成的。状态 $S[n]$ 是在上升沿 $n$ 触发的触发器的输出。因此，$S[n]$ 仅在边沿 $n$ *之后* 才有效。因此，$z[n]$ 是在边沿 $n$ *之后*，即在周期 $n$ 期间生成的。对于一个同步寄存器要在边沿 $n$ 采样一个值，该值必须在边沿 $n$ *之前* 的一段建立时间内保持稳定。在那时，Mealy 输出是 $z[n-1]=0$。不可能在边沿 $n$ 采样到 $z[n]$ 的置位值。下游寄存器可以在下一个上升沿，即边沿 $n+1$，采样到 $z[n]=1$。\n**结论：错误。**\n\n**C. 未寄存的 Mealy 输出和 Moore 输出都可以在周期 $n$ 期间首次置位，因为两者都依赖于周期 $n$ 开始时上升沿之后立即可用的信号。**\n这个说法是错误的。如上所述，Moore 输出 $y[k]$ 在周期 $n+1$ 期间首次置位，而不是周期 $n$。Moore 型状态机的定义性特征是其输出仅依赖于寄存状态，这意味着与 Mealy 型状态机相比，表示序列完成的输出变化会延迟一个时钟周期。\n**结论：错误。**\n\n**D. 寄存 Mealy 输出总是相对于最后一个输入比特增加两个完整周期的延迟，所以 $z_{r}[k]$ 在周期 $n+2$ 期间首次置位。**\n最后一个输入比特 $x[n]$ 在周期 $n$ 到达。未寄存的 Mealy 输出 $z[n]$ 在同一周期内置位。如题目所述，使用一个 D 型触发器寄存此输出会增加恰好一个周期的延迟。如我们的分析所示，$z_r[k]$ 在周期 $n+1$ 置位，这是周期 $n$ 之后的一个周期。两个周期的延迟意味着在周期 $n+2$ 置位，这是不正确的。\n**结论：错误。**",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "数字系统经常需要与充满噪声和不确定性的真实物理世界进行交互，例如处理机械按钮的抖动信号。本练习提出了一个经典挑战：如何将一个异步、充满毛刺的输入信号可靠地转换为同步系统可以安全使用的干净信号。通过对比一个简单的组合逻辑滤波器和一个基于计数器的序贯防抖动电路的性能与失效模式，您将认识到为何纯组合逻辑在处理具有时间依赖性的问题时存在局限，以及序贯电路的状态记忆能力如何为系统提供鲁棒性。",
            "id": "3628132",
            "problem": "一个机械式按钮在一个同步系统的逻辑输入端产生一个异步的、易产生毛刺的信号。考虑两种替代的前端设计，用于在信号被系统其余部分使用之前对其进行处理。\n\n设计 C（简易组合逻辑滤波器）：原始按钮信号 $x(t)$ 被馈入一个门电路，该电路计算 $y_{\\mathrm{C}}(t) = x(t) \\land x(t - \\tau_{d})$，其中延迟 $\\tau_{d}$ 由一个包含 $N$ 个相同级联、每级传播延迟为 $t_{p}$ 的反相器链实现，因此 $\\tau_{d} \\approx N t_{p}$。在系统将 $y_{\\mathrm{C}}(t)$ 同步到一个触发器之前，没有时钟控制的存储单元。\n\n设计 S（基于时序计数器的去抖动电路）：原始信号首先通过一个以 $f_{\\mathrm{clk}}$ 频率工作的双触发器同步器，产生一个周期为 $T_{\\mathrm{clk}} = 1/f_{\\mathrm{clk}}$ 的采样序列 $x[n]$。当 $x[n]$ 等于当前候选值时，一个饱和计数器在每个时钟周期加1，并在任何采样值变化时复位为0。只有当计数器达到一个整数阈值 $M$ 时（这需要 $M$ 个连续的相同采样值），去抖动后的输出才会更新为当前采样值。\n\n假设以下情况，这些情况反映了典型但保守的工程模型：\n- 时钟频率为 $f_{\\mathrm{clk}} = 100\\,\\mathrm{MHz}$。\n- 组合延迟链使用 $N = 100$ 个反相器，每个反相器的 $t_{p} = 50\\,\\mathrm{ps}$，因此标称延迟 $\\tau_{d} \\approx 5\\,\\mathrm{ns}$，且 $t_{p}$ 上存在 $\\pm 30\\%$ 的工艺-电压-温度（PVT）变化。\n- 在任何一次按压中，按钮触点从第一个边沿开始到最终稳定为止，会弹跳长达 $T_{b} = 5\\,\\mathrm{ms}$。在此弹跳区间内，波形可能在逻辑低和高之间任意交替，但限制条件是每个连续的恒定电平平台的持续时间在 $t_{\\min} = 20\\,\\mu\\mathrm{s}$ 和 $t_{\\max} = 1\\,\\mathrm{ms}$ 之间。弹跳结束后，信号保持在新状态，直到下一次用户操作。\n\n从基本原理上讲，组合电路的输出仅取决于当前输入和路径延迟，而时序电路的状态通过时钟控制的存储器取决于过去的输入。在触发器上采样一个异步信号，如果违反了建立或保持时间约束，会带来亚稳态的风险。基于计数器的去抖动电路旨在只有在观察到时钟采样中足够的连续一致性之后，才接受一个新的状态。\n\n在所述模型下，以下关于失效模式和保证的陈述中，哪些是正确的？选择所有适用的选项。\n\nA. 对于设计 C，因为 $\\tau_{d} \\approx 5\\,\\mathrm{ns}$ 而每个弹跳平台都满足 $t_{\\min} = 20\\,\\mu\\mathrm{s} \\gg \\tau_{d}$，大多数弹跳平台将作为真实的输出脉冲传播出去，导致单次按压期间产生多个虚假转换。此外，其确切行为对 $\\tau_{d}$ 的 PVT 变化敏感。\n\nB. 对于在 $f_{\\mathrm{clk}} = 100\\,\\mathrm{MHz}$ 频率下运行且 $M = 2{,}000$ 的设计 S，存在符合模型的弹跳模式（例如，两个持续时间均至少为 $20\\,\\mu\\mathrm{s}$ 的交替平台），这会导致去抖动后的输出在单次按压期间翻转超过一次。\n\nC. 在设计 S 的计数器之前有一个合适的双触发器同步器，要保证在所述弹跳模型下每次按压只有一个输出转换，一个充分条件是 $M / f_{\\mathrm{clk}}  t_{\\max}$。如果这个不等式成立，任何采样相位或混叠都不能强制产生过早或多次翻转。\n\nD. 因为设计 C 是无记忆的，它不能在其输出端产生冒险或短脉冲（runt pulse），因此与直接同步原始输入相比，当其输出后续被触发器采样时，可以降低亚稳态的风险。\n\nE. 如果设计 S 被配置为 $M / f_{\\mathrm{clk}} = T_{b}$ 而 $t_{\\max} \\ll T_{b}$，那么在该模型下，弹跳期间过早接受新状态仍然是不可能的。",
            "solution": "该问题要求分析两种不同的电路，一种是组合逻辑电路（设计 C），另一种是时序电路（设计 S），用于对机械按钮信号进行去抖动处理。分析必须基于所提供的电路模型和按钮弹跳特性。\n\n首先，我们总结并推导分析所需的关键参数。\n原始输入信号 $x(t)$ 的弹跳时间最长为 $T_{b} = 5\\,\\mathrm{ms}$。在此弹跳期间，任何稳定平台的持续时间都在 $[t_{\\min}, t_{\\max}]$ 范围内，其中 $t_{\\min} = 20\\,\\mu\\mathrm{s}$ 且 $t_{\\max} = 1\\,\\mathrm{ms}$。\n设计 S 的系统时钟为 $f_{\\mathrm{clk}} = 100\\,\\mathrm{MHz}$，对应的时钟周期为 $T_{\\mathrm{clk}} = 1/f_{\\mathrm{clk}} = 1/(100 \\times 10^6\\,\\mathrm{Hz}) = 10\\,\\mathrm{ns}$。\n\n**设计 C（组合滤波器）分析**\n\n设计 C 实现了逻辑函数 $y_{\\mathrm{C}}(t) = x(t) \\land x(t - \\tau_{d})$。其标称延迟为 $\\tau_{d} = N \\times t_{p} = 100 \\times 50\\,\\mathrm{ps} = 5000\\,\\mathrm{ps} = 5\\,\\mathrm{ns}$。考虑到 $\\pm 30\\%$ 的 PVT 变化，$\\tau_d$ 的范围可以从 $5\\,\\mathrm{ns} \\times (1 - 0.3) = 3.5\\,\\mathrm{ns}$ 到 $5\\,\\mathrm{ns} \\times (1 + 0.3) = 6.5\\,\\mathrm{ns}$。\n\n该电路的行为如下：\n- 为了使输出 $y_{\\mathrm{C}}(t)$ 为高电平（1），$x(t)$ 和 $x(t - \\tau_{d})$ 都必须为高电平。这意味着输入 $x(t)$ 必须已连续保持高电平至少 $\\tau_{d}$ 的时间。\n- 输入 $x(t)$ 的一个上升沿会导致输出 $y_{\\mathrm{C}}(t)$ 在延迟 $\\tau_{d}$ 后出现一个上升沿。\n- 输入 $x(t)$ 的一个下降沿会导致输出 $y_{\\mathrm{C}}(t)$ 立即出现一个下降沿（假设与门的延迟可忽略不计）。\n- 因此，一个持续时间为 $W$ 的高电平输入脉冲会产生一个持续时间为 $W - \\tau_{d}$ 的输出脉冲。\n\n任何弹跳平台的最小持续时间为 $t_{\\min} = 20\\,\\mu\\mathrm{s} = 20{,}000\\,\\mathrm{ns}$。由于 $t_{\\min} \\gg \\tau_{d}$（其中 $\\tau_d \\le 6.5\\,\\mathrm{ns}$），弹跳期间的任何高电平平台都将远长于滤波器延迟 $\\tau_d$。因此，每个高电平平台都会在输出端产生一个相应的高电平脉冲，其持续时间仅比输入平台稍短。这意味着该电路未能滤除弹跳；它仅仅是将它们传播出去，导致单次按钮按压会产生多个虚假的输出转换。\n\n**设计 S（时序去抖动器）分析**\n\n设计 S 对输入进行采样，并需要 $M$ 个连续相同的采样来验证一个新状态。此验证所需的时间为 $T_{\\mathrm{debounce}} = M \\times T_{\\mathrm{clk}} = M / f_{\\mathrm{clk}}$。\n为了正确地对信号进行去抖动，必须设置 $T_{\\mathrm{debounce}}$，使得计数器不会因为弹跳期间的任何瞬态平台而达到其阈值 $M$，但会在信号稳定后达到该阈值。\n弹跳期间可能的最长稳定平台是 $t_{\\max} = 1\\,\\mathrm{ms}$。因此，防止过早接受一个状态的充分条件是，确保所需的稳定时间长于弹跳期间任何可能的稳定时间。这给出了条件 $T_{\\mathrm{debounce}}  t_{\\max}$。\n\n现在我们评估每个陈述。\n\n**A. 对于设计 C，因为 $\\tau_{d} \\approx 5\\,\\mathrm{ns}$ 而每个弹跳平台都满足 $t_{\\min} = 20\\,\\mu\\mathrm{s} \\gg \\tau_{d}$，大多数弹跳平台将作为真实的输出脉冲传播出去，导致单次按压期间产生多个虚假转换。此外，其确切行为对 $\\tau_{d}$ 的 PVT 变化敏感。**\n\n如在设计 C 的分析中所述，任何持续时间为 $W$ 的高电平平台都会被转换为一个持续时间为 $W - \\tau_d$ 的高电平输出脉冲。由于最短的平台持续时间为 $t_{\\min}=20\\,\\mu\\mathrm{s}$，而最大延迟为 $\\tau_{d}=6.5\\,\\mathrm{ns}$，最短的输出脉冲将有 $20\\,\\mu\\mathrm{s} - 6.5\\,\\mathrm{ns}$ 的持续时间，这是相当可观的。该电路不会滤除构成弹跳的平台序列，因此它会产生多个虚假转换。陈述的第一部分是正确的。\n$\\tau_d$ 上的 PVT 变化（从 $3.5\\,\\mathrm{ns}$ 到 $6.5\\,\\mathrm{ns}$）直接影响输出脉冲的持续时间（$W - \\tau_d$）和上升沿的延迟。因此，输出信号的精确时序确实对 PVT 变化敏感。陈述的两部分都是正确的。\n\n结论：**正确**。\n\n**B. 对于在 $f_{\\mathrm{clk}} = 100\\,\\mathrm{MHz}$ 频率下运行且 $M = 2{,}000$ 的设计 S，存在符合模型的弹跳模式（例如，两个持续时间均至少为 $20\\,\\mu\\mathrm{s}$ 的交替平台），这会导致去抖动后的输出在单次按压期间翻转超过一次。**\n\n当 $f_{\\mathrm{clk}} = 100\\,\\mathrm{MHz}$ 且 $M = 2{,}000$ 时，验证一个状态所需的时间是 $T_{\\mathrm{debounce}} = M / f_{\\mathrm{clk}} = 2{,}000 / (100 \\times 10^6\\,\\mathrm{Hz}) = 20 \\times 10^{-6}\\,\\mathrm{s} = 20\\,\\mu\\mathrm{s}$。\n这个去抖动时间等于最小平台持续时间 $t_{\\min} = 20\\,\\mu\\mathrm{s}$。\n考虑一个弹跳模式，其中信号初始为低，然后变为高电平持续 $25\\,\\mu\\mathrm{s}$，再变为低电平持续 $25\\,\\mu\\mathrm{s}$。这个模式与模型是一致的，因为两个平台的持续时间都在 $t_{\\min}$ 和 $t_{\\max}$ 之间。\n1.  当信号变为高电平时，它稳定了 $25\\,\\mu\\mathrm{s}$。由于 $25\\,\\mu\\mathrm{s}  T_{\\mathrm{debounce}} = 20\\,\\mu\\mathrm{s}$，计数器将达到 $M$，去抖动后的输出将切换为高电平。\n2.  当信号接着变为低电平时，计数器复位并开始对稳定的低电平样本进行计数。由于信号保持低电平 $25\\,\\mu\\mathrm{s}  T_{\\mathrm{debounce}}$，计数器将再次达到 $M$，去抖动后的输出将切换回低电平。\n这个序列导致去抖动后的输出在单次按压期间发生两次翻转。因此，该陈述是正确的。\n\n结论：**正确**。\n\n**C. 在设计 S 的计数器之前有一个合适的双触发器同步器，要保证在所述弹跳模型下每次按压只有一个输出转换，一个充分条件是 $M / f_{\\mathrm{clk}}  t_{\\max}$。如果这个不等式成立，任何采样相位或混叠都不能强制产生过早或多次翻转。**\n\n条件是 $T_{\\mathrm{debounce}}  t_{\\max}$。这里，$t_{\\max} = 1\\,\\mathrm{ms}$ 是弹跳期间任何稳定平台可以持续的最长时间。\n如果验证一个状态所需的时间（$T_{\\mathrm{debounce}}$）严格大于弹跳期间可能的最长稳定间隔（$t_{\\max}$），那么在弹跳期间计数器就不可能达到其阈值 $M$。任何连续相同采样的序列都将被信号变化所中断，导致计数器复位。\n一旦弹跳期（持续时间长达 $T_b$）结束，信号就会稳定到其最终状态并无限期地保持。然后计数器将开始计数，在 $T_{\\mathrm{debounce}}$ 之后完成计数到 $M$，并引起去抖动输出的一次、也是最后一次转换。同步器处理了采样异步输入所带来的亚稳态风险，确保了计数器逻辑接收到干净的采样值。因此，这个条件足以保证正确的去抖动。\n\n结论：**正确**。\n\n**D. 因为设计 C 是无记忆的，它不能在其输出端产生冒险或短脉冲（runt pulse），因此与直接同步原始输入相比，当其输出后续被触发器采样时，可以降低亚稳态的风险。**\n\n这个陈述是有缺陷的。其前提“因为设计 C 是无记忆的，它不能产生冒险”是错误的。众所周知，组合逻辑电路容易产生冒险（静态、动态），这是由不同路径延迟引起的虚假输出毛刺。虽然这个特定电路对于单个干净的输入边沿可能不会表现出静态冒险，但关于无记忆电路的一般性论断是错误的。此外，任何实际的逻辑门都有有限的转换速率，如果输入转换非常快，输出可能无法达到完整的逻辑电平，从而产生一个短脉冲（runt pulse）。\n其结论“降低亚稳态的风险”也是不正确的。设计 C 的输出 $y_C(t)$ 仍然是一个异步信号。如选项 A 的分析所示，它包含的转换次数与弹跳输入一样多。亚稳态风险发生在触发器的输入在相对于时钟边沿的建立和保持时间窗口内发生变化时。由于 $y_C(t)$ 有许多与系统时钟异步的边沿，与同步原始信号 $x(t)$ 相比，亚稳态的风险并没有降低。\n\n结论：**不正确**。\n\n**E. 如果设计 S 被配置为 $M / f_{\\mathrm{clk}} = T_{b}$ 而 $t_{\\max} \\ll T_{b}$，那么在该模型下，弹跳期间过早接受新状态仍然是不可能的。**\n\n这个陈述为设计 S 提出了一种特定的配置。去抖动时间被设置为 $T_{\\mathrm{debounce}} = M / f_{\\mathrm{clk}} = T_b = 5\\,\\mathrm{ms}$。\n弹跳模型规定，在弹跳期间（持续时间长达 $T_b$），任何连续平台的持续时间最多为 $t_{\\max} = 1\\,\\mathrm{ms}$。\n为了让去抖动电路接受一个新状态，输入必须稳定 $T_{\\mathrm{debounce}} = 5\\,\\mathrm{ms}$。\n然而，在整个弹跳期间，信号保证每 $t_{\\max} = 1\\,\\mathrm{ms}$ 至少变化一次。因此，在弹跳*期间*的任何时候，信号都不可能稳定所需的 $5\\,\\mathrm{ms}$。\n因此，计数器永远不会达到其阈值 $M$，直到弹跳完全停止并且信号永久稳定。这个配置满足了选项 C 中的充分条件，因为 $T_{\\mathrm{debounce}} = 5\\,\\mathrm{ms}  t_{\\max} = 1\\,\\mathrm{ms}$。因此，过早接受确实是不可能的。\n\n结论：**正确**。",
            "answer": "$$\\boxed{ABCE}$$"
        },
        {
            "introduction": "在数字系统设计中，实现一个计算功能（如平方运算）往往面临着一个根本性的权衡：是采用一个庞大但快速的组合逻辑电路，还是一个紧凑但较慢的序贯迭代电路？本练习将引导您对这两种架构进行量化分析，通过比较基于查找表（LUT）的组合方案和类似 CORDIC 算法的序贯方案来近似计算 $f(x) = x^2$。您将推导它们的误差界限，计算各自的硬件面积和延迟，并最终通过“面积-延迟积”这一关键性能指标来评估不同架构的效率，从而深入理解空间与时间之间的权衡。",
            "id": "3628129",
            "problem": "一个定点数据路径必须对输入 $x \\in [0,1]$ 的实值函数 $f(x) = x^{2}$ 进行近似计算。该计算采用两种备选架构：一种是使用分段线性插值的组合逻辑查找表（LUT），另一种是顺序迭代的类 CORDIC 平方器。用于 $x$ 的定点格式使用 $b = 16$ 个小数位。\n\n架构 C（组合逻辑）：近似域 $[0,1]$ 被划分为 $N$ 个宽度为 $h = 1/N$ 的均匀段。该设计将端点值 $y_{k} = (k/N)^{2}$（其中 $k = 0,1,\\dots,N$）存储在存储器中，并执行分段线性插值：对于 $x \\in [k/N,(k+1)/N]$，它计算 $y \\approx y_{k} + t \\cdot (y_{k+1} - y_{k})$，其中 $t \\in [0,1]$ 是段内的局部小数位置。数据路径使用一个减法器来形成 $(y_{k+1} - y_{k})$，一个乘法器来计算 $t \\cdot (y_{k+1} - y_{k})$，以及一个加法器来形成 $y_{k} + (\\cdot)$。假设此组合路径的延迟为单周期。存储的 $y$ 值的字宽为 $w_{y} = 16$ 位。使用面积成本模型\n- 存储器面积 $A_{\\text{mem}} = c_{\\text{mem}} \\times (N+1) \\times w_{y}$，\n- 加法器/减法器面积 $A_{\\text{add}} = c_{\\text{add}} \\times w_{y}$（每个单元），\n- 乘法器面积 $A_{\\text{mul}} = c_{\\text{mul}} \\times w_{t} \\times w_{y}$，\n其中 $w_{t} = 16$ 位用于 $t$。常数为 $c_{\\text{mem}} = 1$，$c_{\\text{add}} = 2$，$c_{\\text{mul}} = 6$（所有单位均为归一化的等效门单位）。\n\n架构 S（顺序逻辑）：一个类 CORDIC 迭代平方器通过移位-加法操作，每次迭代解析 $x$ 的一个小数位。经过 $k$ 次迭代后，内部表示等于将 $x$ 截断为 $m = k$ 个小数位的值 $\\hat{x}$，输出为 $\\hat{x}^{2}$。硬件由一个 $w_{y}$ 位加法器、两个 $w_{y}$ 位寄存器和控制逻辑组成，控制逻辑的固定面积为 $A_{\\text{ctrl}} = 64$（单位相同）。使用面积成本模型\n- 加法器面积 $A_{\\text{add}} = c_{\\text{add}} \\times w_{y}$，\n- 寄存器面积 $A_{\\text{reg}} = c_{\\text{reg}} \\times w_{y}$（每个寄存器），\n其中 $c_{\\text{add}} = 2$，$c_{\\text{reg}} = 0.5$。顺序延迟为 $k$ 个周期。\n\n从第一性原理出发：\n- 仅使用微积分和分段线性插值的定义，推导架构 C 在 $[0,1]$ 上的最大绝对误差关于 $N$ 的最坏情况界限。\n- 仅使用截断到 $m$ 位的定义和平方的代数恒等式，推导架构 S 在 $k$ 次迭代后的最大绝对误差的最坏情况界限。\n令 $k = 10$。选择最小的正整数 $N$，使得架构 C 在 $[0,1]$ 上的最坏情况最大绝对误差不超过架构 S 的误差。\n\n使用这个 $N$，根据给定的成本模型计算每种架构的面积，计算每种架构的面积-延迟积，然后计算比率\n$$R \\;=\\; \\frac{\\text{(架构 C 的面积-延迟积)}}{\\text{(架构 S 的面积-延迟积)}}.$$\n将最终比率 $R$ 四舍五入到四位有效数字。将最终答案表示为无单位的纯数。",
            "solution": "该问题陈述已经过验证，被确定为数字架构设计与分析领域中一个良构的、有科学依据的问题。它是自洽的、客观的，其解决需要实质性的推理。我们开始进行解答。\n\n该问题要求对两种用于在区间 $x \\in [0,1]$ 上近似函数 $f(x) = x^2$ 的数字架构进行对比分析。我们将首先为每种架构推导最坏情况的近似误差，然后利用这些误差界来确定一个设计参数，最后计算面积-延迟性能指标以进行比较。\n\n**第1部分：架构 C（组合逻辑 LUT）的最坏情况误差**\n\n架构 C 使用分段线性插值来近似 $f(x) = x^2$。域 $[0,1]$ 被划分为 $N$ 个段，每个段的宽度为 $h = 1/N$。对于区间 $[x_k, x_{k+1}]$，其中 $x_k = k/N$，线性近似 $L(x)$ 由以下公式给出：\n$$L(x) = f(x_k) + \\frac{f(x_{k+1}) - f(x_k)}{x_{k+1} - x_k}(x - x_k)$$\n此近似的误差为 $E(x) = f(x) - L(x)$。根据线性插值的标准误差界，对于一个具有连续二阶导数的函数，其误差由以下公式给出：\n$$E(x) = \\frac{f''(\\xi)}{2!}(x - x_k)(x - x_{k+1})$$\n其中某个 $\\xi \\in (x_k, x_{k+1})$。\n\n对于我们的函数 $f(x) = x^2$，其导数为 $f'(x) = 2x$ 和 $f''(x) = 2$。二阶导数是恒定的。因此，误差表达式变为：\n$$E(x) = \\frac{2}{2}(x - x_k)(x - x_{k+1}) = (x-x_k)(x-x_{k+1})$$\n为了找到区间 $[x_k, x_{k+1}]$ 内的最大绝对误差，我们必须找到二次函数 $g(x) = (x-x_k)(x-x_{k+1})$ 的最大幅值。这个二次函数在 $x_k$ 和 $x_{k+1}$ 处有根，其顶点位于区间的中点，即 $x = (x_k + x_{k+1})/2$。\n最大误差的位置是 $x_{mid} = x_k + h/2$。区间内的最大误差幅值为：\n$$|E(x_{mid})| = \\left|\\left(x_k + \\frac{h}{2} - x_k\\right)\\left(x_k + \\frac{h}{2} - x_{k+1}\\right)\\right| = \\left|\\left(\\frac{h}{2}\\right)\\left(x_k + \\frac{h}{2} - (x_k+h)\\right)\\right| = \\left|\\left(\\frac{h}{2}\\right)\\left(-\\frac{h}{2}\\right)\\right| = \\frac{h^2}{4}$$\n由于 $h=1/N$ 且此误差幅值与具体区间 $k$ 无关，因此这是在整个域 $[0,1]$ 上的最坏情况误差。\n架构 C 的最大绝对误差为：\n$$\\epsilon_C = \\frac{1}{4N^2}$$\n\n**第2部分：架构 S（顺序平方器）的最坏情况误差**\n\n架构 S 计算 $\\hat{x}^2$，其中 $\\hat{x}$ 是将 $x$ 截断为 $m$ 个小数位后的值。输入 $x$ 被定义为具有 $b=16$ 个小数位，但误差分析取决于截断到 $m$ 位。\n对于给定的 $x \\in [0,1]$，$\\hat{x}$ 是形如 $\\sum_{i=1}^m d_i 2^{-i}$（其中 $d_i \\in \\{0,1\\}$）且满足 $\\hat{x} \\le x$ 的最大数。这意味着以下关系：\n$$\\hat{x} \\le x  \\hat{x} + 2^{-m}$$\n输出误差为 $\\Delta = x^2 - \\hat{x}^2$。由于 $x \\ge \\hat{x}$，此误差始终为非负。我们想要找到它在所有 $x \\in [0,1]$ 上的最大值。\n$$\\Delta = x^2 - \\hat{x}^2  (\\hat{x} + 2^{-m})^2 - \\hat{x}^2 = \\hat{x}^2 + 2\\hat{x}2^{-m} + (2^{-m})^2 - \\hat{x}^2 = 2\\hat{x}2^{-m} + 2^{-2m}$$\n这个误差上界 $2\\hat{x}2^{-m} + 2^{-2m}$ 是 $\\hat{x}$ 的增函数。为了找到误差的上确界，我们必须考虑 $\\hat{x}$ 可能的最大值。\n当 $x$ 趋近于 $1$ 时，$\\hat{x}$ 趋近于其可能的最大值。对于任何 $x \\in [1-2^{-m}, 1)$，截断值为 $\\hat{x} = \\sum_{i=1}^m 1 \\cdot 2^{-i} = 1 - 2^{-m}$。\n对于固定的 $\\hat{x}$，当 $x$ 趋近其范围的上端，即 $x \\to \\hat{x} + 2^{-m}$ 时，误差 $x^2 - \\hat{x}^2$ 最大化。\n总体最大误差发生在 $x \\to 1$ 时。在这种情况下，$\\hat{x} = 1 - 2^{-m}$。误差为：\n$$\\epsilon_S = \\lim_{x \\to 1^-} (x^2 - \\hat{x}(x)^2) = 1^2 - (1 - 2^{-m})^2 = 1 - (1 - 2 \\cdot 2^{-m} + 2^{-2m}) = 2 \\cdot 2^{-m} - 2^{-2m}$$\n这可以写成：\n$$\\epsilon_S = 2^{-m+1} - 2^{-2m}$$\n\n**第3部分：确定段数 N**\n\n给定顺序架构使用 $k=10$ 次迭代，所以 $m=k=10$。架构 S 的误差为：\n$$\\epsilon_S = 2^{-10+1} - 2^{-2 \\cdot 10} = 2^{-9} - 2^{-20} = \\frac{1}{512} - \\frac{1}{1048576} = \\frac{2^{11}-1}{2^{20}} = \\frac{2047}{1048576}$$\n我们必须找到最小的正整数 $N$，使得架构 C 的误差不超过这个值：\n$$\\epsilon_C \\le \\epsilon_S \\implies \\frac{1}{4N^2} \\le 2^{-9} - 2^{-20}$$\n$$4N^2 \\ge \\frac{1}{2^{-9} - 2^{-20}} \\implies N^2 \\ge \\frac{1}{4(2^{-9} - 2^{-20})} = \\frac{1}{4} \\frac{2^{20}}{2^{11}-1} = \\frac{2^{18}}{2047}$$\n数值上，这等于：\n$$N^2 \\ge \\frac{262144}{2047} \\approx 128.0625...$$\n取平方根：\n$$N \\ge \\sqrt{128.0625...} \\approx 11.316...$$\n由于 $N$ 必须是整数，因此 $N$ 的最小值为 $12$。\n\n**第4部分：计算架构面积和面积-延迟积**\n\n当 $N=12$ 且 $k=10$ 时，我们现在可以使用提供的成本模型和参数来计算每种架构的面积：$w_y = 16$, $w_t=16$, $c_{\\text{mem}}=1$, $c_{\\text{add}}=2$, $c_{\\text{mul}}=6$, $c_{\\text{reg}}=0.5$, $A_{\\text{ctrl}}=64$。\n\n架构 C 的面积（$A_C$）：\n组件包括一个 $(N+1) \\times w_y$ 的存储器、一个加法器、一个减法器和一个乘法器。\n$$A_C = A_{\\text{mem}} + A_{\\text{add}} + A_{\\text{sub}} + A_{\\text{mul}}$$\n$$A_{\\text{mem}} = c_{\\text{mem}} \\times (N+1) \\times w_y = 1 \\times (12+1) \\times 16 = 13 \\times 16 = 208$$\n$$A_{\\text{add}} = c_{\\text{add}} \\times w_y = 2 \\times 16 = 32$$\n$$A_{\\text{sub}} = c_{\\text{add}} \\times w_y = 2 \\times 16 = 32$$\n$$A_{\\text{mul}} = c_{\\text{mul}} \\times w_t \\times w_y = 6 \\times 16 \\times 16 = 1536$$\n$$A_C = 208 + 32 + 32 + 1536 = 1808$$\n延迟为 $L_C = 1$ 个周期。架构 C 的面积-延迟积为：\n$$P_C = A_C \\times L_C = 1808 \\times 1 = 1808$$\n\n架构 S 的面积（$A_S$）：\n组件包括一个加法器、两个寄存器和控制逻辑。\n$$A_S = A_{\\text{add}} + 2 \\times A_{\\text{reg}} + A_{\\text{ctrl}}$$\n$$A_{\\text{add}} = c_{\\text{add}} \\times w_y = 2 \\times 16 = 32$$\n$$A_{\\text{reg}} = c_{\\text{reg}} \\times w_y = 0.5 \\times 16 = 8$$\n$$A_S = 32 + 2 \\times 8 + 64 = 32 + 16 + 64 = 112$$\n延迟为 $L_S = k = 10$ 个周期。架构 S 的面积-延迟积为：\n$$P_S = A_S \\times L_S = 112 \\times 10 = 1120$$\n\n**第5部分：计算比率 R**\n\n最后一步是计算面积-延迟积的比率。\n$$R = \\frac{P_C}{P_S} = \\frac{1808}{1120}$$\n$$R = \\frac{180.8}{112} = \\frac{45.2}{28} = \\frac{11.3}{7} \\approx 1.6142857...$$\n四舍五入到四位有效数字，我们得到 $R = 1.614$。",
            "answer": "$$\\boxed{1.614}$$"
        }
    ]
}