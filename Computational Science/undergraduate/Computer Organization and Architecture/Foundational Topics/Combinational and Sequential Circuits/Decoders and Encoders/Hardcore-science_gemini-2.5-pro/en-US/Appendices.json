{
    "hands_on_practices": [
        {
            "introduction": "A primary function of decoders in a CPU is to interpret instruction fields and parts of data addresses to enforce architectural rules. This first exercise focuses on one such fundamental task: ensuring correct memory alignment. By analyzing how a decoder can check the low-order bits of an effective address, you will connect the abstract logic of a decoder to a crucial aspect of processor pipeline design and exception handling. ",
            "id": "3633922",
            "problem": "A Central Processing Unit (CPU) implements a load/store instruction set with a $5$-stage pipeline consisting of Instruction Fetch (IF), Instruction Decode (ID), Execute (EX), Memory (MEM), and Writeback (WB). Effective addresses are computed in the Execute stage as $EA = R_s + \\text{imm}$, where $EA$ is the effective address, $R_s$ is a base register, and $\\text{imm}$ is a sign-extended immediate. The architecture supports access widths of $2^a$ bytes, with $a \\in \\{0,1,2,3\\}$ corresponding to byte ($1$), halfword ($2$), word ($4$), and doubleword ($8$) accesses. The instruction decoder produces $a$ from the opcode during the Instruction Decode stage. The memory system uses virtual memory with a Translation Lookaside Buffer (TLB), and the processor must raise a precise exception on any misaligned load or store before issuing any memory transaction or modifying architectural state outside the register file. Alignment is defined by the well-tested rule that an access of width $W = 2^a$ bytes must satisfy $EA \\bmod W = 0$.\n\nDesign an address alignment decoder that detects misaligned $2^a$-byte accesses by decoding the lower $a$ bits of $EA$. Based on first principles, determine the minimal boolean condition that must be checked on the lower $a$ bits to detect misalignment, and identify the earliest pipeline stage where placing this decoder guarantees precise exceptions with no memory side effects under the stated pipeline and virtual memory assumptions.\n\nWhich option correctly specifies both the boolean condition and the appropriate pipeline placement?\n\nA. For an access of width $2^a$ bytes, misaligned if any of the lower $a$ bits of $EA$ is $1$. Implement by checking $EA[a-1:0] = 0$ via an $a$-input NOR or equality comparator; place the decoder in Execute (EX), where $EA$ is first available, to squash the subsequent Memory (MEM) stage and raise an exception before any memory transaction.\n\nB. For an access of width $2^a$ bytes, misaligned if any of $EA[a:0]$ is $1$, because the access spans $2^a$ addresses. Place the decoder in Memory (MEM) because the data memory width control is only available there.\n\nC. With virtual memory, misalignment can only be determined after translation because the TLB may alter the lower $a$ bits of the address. Therefore, the decoder must be placed after the TLB in Memory (MEM).\n\nD. Byte accesses ($a=0$) are misaligned on a $64$-bit machine because addresses must be at least $2$-byte aligned; therefore, the decoder should signal misalignment for $a=0$ and place the check in Writeback (WB) to maintain precise exceptions.\n\nE. Detect misalignment by AND-reducing the lower $a$ bits of $EA$ and signaling misalignment when the reduction equals $0$; place the decoder in Instruction Decode (ID) to avoid wasting cycles before Execute (EX).",
            "solution": "We begin from the core definition of alignment: an access of width $W = 2^a$ bytes is aligned if and only if the effective address $EA$ satisfies\n$$EA \\bmod W = 0.$$\nIn binary, this is equivalent to the statement that the lower $a$ bits of $EA$ are all zero. To see why, observe that $W = 2^a$ defines blocks whose addresses share the same higher bits and whose offsets within a block are given by the lower $a$ bits. The remainder $EA \\bmod 2^a$ is exactly the value represented by $EA[a-1:0]$. Therefore,\n$$EA \\bmod 2^a = 0 \\quad \\Longleftrightarrow \\quad EA[a-1:0] = 0.$$\nConsequently, a misaligned access is detected precisely when\n$$EA \\bmod 2^a \\ne 0 \\quad \\Longleftrightarrow \\quad EA[a-1:0] \\ne 0 \\quad \\Longleftrightarrow \\quad \\bigvee_{i=0}^{a-1} EA_i = 1,$$\nwhere $\\bigvee$ denotes logical OR over the lower $a$ bits.\n\nFrom a pipeline perspective, the earliest stage where $EA$ is available is Execute (EX), because $EA = R_s + \\text{imm}$ requires reading $R_s$ (performed in Instruction Decode (ID)) and then performing the addition (performed in Execute (EX)). Although the Instruction Decode (ID) stage knows $a$ from the opcode, it does not know $EA$; hence misalignment cannot be decided there. Placing the misalignment decoder in Execute (EX) allows the control logic to raise a precise exception and squash the Memory (MEM) stage before any memory side effects occur, satisfying the precise exception requirement. With virtual memory, the Translation Lookaside Buffer (TLB) translation preserves the page offset, so the lower bits $EA[a-1:0]$ are unchanged by translation; the alignment check can safely be performed using the virtual $EA$ before translation. Therefore, the minimal and correct condition is $EA[a-1:0] \\ne 0$, implemented by checking $EA[a-1:0] = 0$ via an $a$-input NOR or equality comparator, and the appropriate earliest placement is Execute (EX).\n\nOption-by-option analysis:\n\nA. This option states that a $2^a$-byte access is misaligned if any of the lower $a$ bits of $EA$ is $1$, and suggests implementing the check as $EA[a-1:0] = 0$ via an $a$-input NOR or equality comparator. This matches the derivation: $EA \\bmod 2^a = 0$ if and only if $EA[a-1:0] = 0$, so misalignment occurs when any of those bits is $1$. The placement in Execute (EX) is correct because $EA$ is first available there, allowing the pipeline to squash the Memory (MEM) stage and raise a precise exception before any memory traffic. Verdict: Correct.\n\nB. This option incorrectly includes bit $a$ in the alignment mask, proposing to check $EA[a:0] = 0$. The correct mask for a $2^a$-byte alignment covers exactly the lower $a$ bits, $EA[a-1:0]$. Including bit $a$ would incorrectly reject aligned addresses where $EA[a] = 1$ but $EA[a-1:0] = 0$, which are valid multiples of $2^a$. It also incorrectly asserts that data memory width control is only available in Memory (MEM); the width $a$ is decoded in Instruction Decode (ID), and $EA$ is computed in Execute (EX), so the alignment check can be done in Execute (EX), earlier than Memory (MEM). Verdict: Incorrect.\n\nC. This option claims that the Translation Lookaside Buffer (TLB) may alter the lower $a$ bits, necessitating placement after translation. In standard virtual memory systems, the page offset (the lower bits within the page) is preserved by translation; only the higher bits (the page number) are changed. Therefore, the lower $a$ bits $EA[a-1:0]$ are invariant under translation, and alignment can be checked before the Memory (MEM) stage. Verdict: Incorrect.\n\nD. This option claims that byte accesses ($a=0$) are misaligned on a $64$-bit machine and suggests signaling misalignment for $a=0$, placing the check in Writeback (WB). By definition, for $a=0$ we have $W = 2^0 = 1$, and the condition $EA \\bmod 1 = 0$ is always true for all integers $EA$; byte accesses are always aligned. Furthermore, Writeback (WB) is too late to ensure no memory side effects, because memory would already have been accessed in Memory (MEM). Verdict: Incorrect.\n\nE. This option proposes detecting misalignment by AND-reducing the lower $a$ bits and signaling misalignment when the reduction equals $0$. The correct condition is that misalignment occurs if any of the lower $a$ bits is $1$, i.e., an OR-reduction equals $1$. An AND-reduction equals $1$ only when all bits are $1$, which is not the alignment condition; using an AND-reduction yields the wrong predicate. Additionally, placing the decoder in Instruction Decode (ID) is not feasible because $EA$ is not yet computed in ID. Verdict: Incorrect.",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "Moving from the CPU core to the memory subsystem, decoders are essential for managing parallel resources like memory banks. In this practice, we explore how a simple linear decoder, which selects a memory bank using the low-order address bits, performs under different access patterns. This analysis will reveal how a straightforward decoding scheme can sometimes lead to performance bottlenecks, demonstrating the need for architects to consider the interplay between hardware structure and software behavior. ",
            "id": "3633908",
            "problem": "You are designing a bank-interleaved main memory subsystem for a vector processor. The subsystem uses $B = 2^r$ identical single-ported banks. The low $r$ bits of the physical address feed an $r$-to-$2^r$ binary decoder that produces $2^r$ one-hot bank enable signals; exactly one bank is selected per memory request. The remaining higher address bits select the location within the chosen bank.\n\nIn each cycle, a vector load issues $m$ simultaneous scalar memory requests to addresses $\\{A_j\\}_{j=0}^{m-1}$ with $A_j = A_0 + j \\cdot d$, where $A_0$ is an arbitrary starting address and $d$ is the stride. Assume $A_0 \\bmod B$ is uniformly distributed over $\\{0,1,\\dots,B-1\\}$. A bank conflict is defined as the event that there exist indices $j \\neq k$ such that the corresponding bank indices are equal, i.e., $(A_j \\bmod B) = (A_k \\bmod B)$, so that at least two requests target the same bank in the same cycle.\n\nStarting from the fundamental definition of a binary decoder and the property that the low $r$ bits select one of $2^r$ banks, derive from first principles the probability that at least one conflict occurs within the $m$ concurrent requests for the following two access patterns:\n- Sequential access: $d = 1$.\n- Stride access: $d = s$, for a given positive integer $s$.\n\nExpress your results in closed form as functions of $r$, $m$, and $s$, using only well-defined mathematical operations and functions, and justify any number-theoretic objects you employ.\n\nFinally, evaluate your derived probabilities for the specific parameters $r = 5$, $m = 20$, and $s = 6$, and report the two probabilities as exact numbers. No rounding is required. Your final answer must be the pair of numerical probabilities arranged as a row vector using the LaTeX $\\texttt{pmatrix}$ environment, with the first entry corresponding to sequential access and the second entry corresponding to stride-$s$ access.",
            "solution": "The problem asks for the probability of a bank conflict in a bank-interleaved memory system with $B = 2^r$ banks. The bank index for a given physical address $A$ is determined by the low $r$ bits, which is mathematically equivalent to the operation $A \\bmod B$. We are given a vector load of $m$ simultaneous requests to addresses $A_j = A_0 + j \\cdot d$ for $j \\in \\{0, 1, \\dots, m-1\\}$. A bank conflict occurs if at least two distinct requests, say for indices $j$ and $k$ where $j \\neq k$, map to the same bank.\n\nThe condition for a bank conflict is the existence of indices $j, k \\in \\{0, 1, \\dots, m-1\\}$ with $j \\neq k$ such that:\n$$ A_j \\bmod B = A_k \\bmod B $$\nSubstituting the expressions for the addresses, we get:\n$$ (A_0 + j \\cdot d) \\bmod B = (A_0 + k \\cdot d) \\bmod B $$\nThis equality is equivalent to the congruence:\n$$ A_0 + j \\cdot d \\equiv A_0 + k \\cdot d \\pmod{B} $$\nSubtracting $A_0$ from both sides, we obtain:\n$$ j \\cdot d \\equiv k \\cdot d \\pmod{B} $$\n$$ (j-k) \\cdot d \\equiv 0 \\pmod{B} $$\nWithout loss of generality, let us assume $j > k$. Let $i = j-k$. Since $0 \\le k < j \\le m-1$, the integer $i$ must be in the range $1 \\le i \\le m-1$. Therefore, a conflict occurs if and only if there exists an integer $i \\in \\{1, 2, \\dots, m-1\\}$ such that:\n$$ i \\cdot d \\equiv 0 \\pmod{B} $$\nThis condition depends only on the parameters $m$, $d$, and $B$, and not on the starting address $A_0$. Consequently, for a given configuration $(m, d, B)$, either a conflict is certain to occur for any $A_0$, or it is certain not to occur for any $A_0$. The probability of conflict is therefore either $1$ or $0$. The provided information that $A_0 \\bmod B$ is uniformly distributed is thus inconsequential to the final probability, as the event of a conflict is independent of the specific value of $A_0 \\bmod B$.\n\nWe now analyze the two specified access patterns.\n\nCase 1: Sequential access ($d=1$)\nFor sequential access, the stride $d=1$. The condition for a conflict becomes the existence of an integer $i \\in \\{1, 2, \\dots, m-1\\}$ such that:\n$$ i \\cdot 1 \\equiv 0 \\pmod{B} $$\nThis means that $i$ must be a multiple of $B$. A conflict will occur if and only if the set of possible values for $i$, which is $\\{1, 2, \\dots, m-1\\}$, contains a multiple of $B=2^r$. The smallest positive multiple of $B$ is $B$ itself. A conflict is possible only if $B$ is within the range of $i$, i.e., $B \\le m-1$. This is equivalent to $m-1 \\ge B$, or $m > B$.\nConversely, if $m \\le B$, then for any $i \\in \\{1, 2, \\dots, m-1\\}$, we have $0 < i < m \\le B$. Thus, $i$ cannot be a multiple of $B$. In this case, no conflict can occur.\nThe probability of conflict for sequential access, $P_1$, is therefore:\n$$ P_1 = \\begin{cases} 0 & \\text{if } m \\le B \\\\ 1 & \\text{if } m > B \\end{cases} $$\nSubstituting $B=2^r$, we have:\n$$ P_1 = \\begin{cases} 0 & \\text{if } m \\le 2^r \\\\ 1 & \\text{if } m > 2^r \\end{cases} $$\n\nCase 2: Stride access ($d=s$)\nFor stride access, the stride $d=s$. The condition for a conflict is the existence of an integer $i \\in \\{1, 2, \\dots, m-1\\}$ such that:\n$$ i \\cdot s \\equiv 0 \\pmod{B} $$\nThis is a linear congruence for $i$. From first principles of number theory, we must find the solutions for $i$. Let $g = \\gcd(s, B)$ be the greatest common divisor of the stride $s$ and the number of banks $B$. We can write $s = g \\cdot s'$ and $B = g \\cdot B'$ where $\\gcd(s', B')=1$. The congruence becomes:\n$$ i \\cdot g \\cdot s' \\equiv 0 \\pmod{g \\cdot B'} $$\nDividing the entire relation by $g$, we get an equivalent congruence:\n$$ i \\cdot s' \\equiv 0 \\pmod{B'} $$\nSince $s'$ and $B'$ are coprime ($\\gcd(s', B')=1$), $s'$ has a multiplicative inverse modulo $B'$. Multiplying by this inverse, we find that $i$ must be a multiple of $B'$.\n$$ i \\equiv 0 \\pmod{B'} $$\nRecalling that $B' = B/g = B/\\gcd(s, B)$, the solutions for $i$ are the integer multiples of $B/\\gcd(s, B)$.\nA conflict will occur if and only if the set of possible values for $i$, $\\{1, 2, \\dots, m-1\\}$, contains at least one multiple of $B/\\gcd(s, B)$. The smallest positive multiple is $B/\\gcd(s, B)$ itself. A conflict is therefore guaranteed if this smallest solution lies within the range of $i$, i.e.,\n$$ \\frac{B}{\\gcd(s, B)} \\le m-1 $$\nThis is equivalent to $m-1 \\ge \\frac{B}{\\gcd(s, B)}$, or $m > \\frac{B}{\\gcd(s, B)}$ (since $m$ is an integer).\nConversely, if $m \\le \\frac{B}{\\gcd(s, B)}$, then for any $i \\in \\{1, 2, \\dots, m-1\\}$, we have $0 < i < m \\le \\frac{B}{\\gcd(s, B)}$. Thus, $i$ cannot be a multiple of $\\frac{B}{\\gcd(s, B)}$, and no conflict can occur.\nThe probability of conflict for stride access, $P_s$, is:\n$$ P_s = \\begin{cases} 0 & \\text{if } m \\le \\frac{B}{\\gcd(s, B)} \\\\ 1 & \\text{if } m > \\frac{B}{\\gcd(s, B)} \\end{cases} $$\nSubstituting $B = 2^r$, we have:\n$$ P_s = \\begin{cases} 0 & \\text{if } m \\le \\frac{2^r}{\\gcd(s, 2^r)} \\\\ 1 & \\text{if } m > \\frac{2^r}{\\gcd(s, 2^r)} \\end{cases} $$\n\nFinally, we evaluate these probabilities for the given parameters: $r = 5$, $m = 20$, and $s = 6$.\nThe number of banks is $B = 2^r = 2^5 = 32$.\n\nEvaluation for sequential access ($d=1$):\nWe compare $m=20$ with $B=32$.\nSince $20 \\le 32$, we are in the case $m \\le B$.\nTherefore, the probability of conflict is $P_1 = 0$.\n\nEvaluation for stride access ($d=s=6$):\nWe first compute the greatest common divisor $g = \\gcd(s, B) = \\gcd(6, 32)$.\nThe prime factorization of $6$ is $2^1 \\cdot 3^1$.\nThe prime factorization of $32$ is $2^5$.\nThe greatest common divisor is $2^{\\min(1,5)} = 2^1 = 2$. So, $g=2$.\nNow we compute the threshold value $\\frac{B}{g} = \\frac{32}{2} = 16$.\nWe compare $m=20$ with this threshold.\nSince $20 > 16$, we are in the case $m > \\frac{B}{\\gcd(s, B)}$.\nTherefore, the probability of conflict is $P_s = 1$.\n\nThe two probabilities are $P_1=0$ and $P_s=1$.",
            "answer": "$$ \\boxed{ \\begin{pmatrix} 0 & 1 \\end{pmatrix} } $$"
        },
        {
            "introduction": "Building upon the insights from the previous problem, this final practice demonstrates how a more sophisticated decoding scheme can solve performance issues. Instead of simple linear decoding, we will design and analyze a system that uses an XOR-based hashing function to randomize bank selection before the final decoding step. This exercise illustrates a powerful theme in computer architecture: improving system performance by introducing clever combinational logic to mitigate the weaknesses of simpler designs, and you will get to quantify this improvement directly. ",
            "id": "3633897",
            "problem": "A memory subsystem employs bank interleaving with $B=16$ identical banks to increase parallelism. Physical addresses are considered at the granularity of cache lines of size $64$ bytes, so the address used for bank selection is the cache-line index $A$, represented in binary as $\\{a_7,a_6,a_5,a_4,a_3,a_2,a_1,a_0\\}$ with $a_0$ the least significant bit of the line index. In a conventional linear interleaving scheme, the bank index is the low-order $4$ bits of $A$. To mitigate bank conflicts under structured access patterns, an alternative bank hashing decoder is proposed that maps the bank index to the bitwise exclusive OR (XOR) of two disjoint $4$-bit groups of the row field, specifically the mapping\n$$\nh_3 h_2 h_1 h_0 = (a_7 a_6 a_5 a_4)\\ \\oplus\\ (a_3 a_2 a_1 a_0),\n$$\nwhere $\\oplus$ denotes bitwise exclusive OR and $h_3$ is the most significant bit of the bank index. The bank-select signals are one-hot outputs of a $4$-to-$16$ decoder driven by $h_3 h_2 h_1 h_0$.\n\nTasks:\n- Using only the definitions of decoders and Boolean combinational logic, specify the Boolean equations that the address decoder must implement to realize the hashed bank selection, in terms of the input bits $\\{a_7,\\dots,a_0\\}$ and the one-hot bank-select outputs $\\{S_0,S_1,\\dots,S_{15}\\}$. Your specification should make clear how the exclusive OR (XOR) network feeds the $4$-to-$16$ decoder.\n- Consider a streaming access pattern with stride $s=16$ cache lines, i.e., addresses of the form $A_n = A_0 + n \\cdot s$ for integer $n \\ge 0$. Define a bank conflict for this stream as the event that two consecutive accesses $A_n$ and $A_{n+1}$ map to the same bank. Starting only from the above definitions and standard properties of binary addition and exclusive OR, determine the asymptotic fraction of consecutive pairs that are conflicts for (i) linear interleaving and (ii) the hashed decoder. Then compute the conflict reduction of the hashed decoder relative to linear interleaving, defined as the difference between these two fractions.\n\nReport the conflict reduction as a single real number. No units are required. Do not round; give the exact value.",
            "solution": "The solution is divided into two parts as requested by the problem statement. First, we derive the Boolean equations for the hashed bank selection decoder. Second, we analyze the bank conflict rates for both linear and hashed interleaving schemes under the specified access pattern and compute the relative conflict reduction.\n\n**Part 1: Boolean Equations for the Hashed Bank Decoder**\n\nThe system has $B=16$ memory banks. The bank selection is determined by a $4$-bit bank index. The bank-select signals are the one-hot outputs $\\{S_0, S_1, \\dots, S_{15}\\}$ of a $4$-to-$16$ decoder. This means that for a given $4$-bit input, exactly one output signal $S_k$ is asserted (logic $1$), while all others are de-asserted (logic $0$).\n\nThe input to this decoder is the hashed bank index, a $4$-bit vector denoted as $h_3 h_2 h_1 h_0$. The hashing function is defined in terms of the $8$-bit cache-line index $A = \\{a_7, a_6, a_5, a_4, a_3, a_2, a_1, a_0\\}$ as a bitwise exclusive OR (XOR) of two $4$-bit fields:\n$$\nh_3 h_2 h_1 h_0 = (a_7 a_6 a_5 a_4) \\oplus (a_3 a_2 a_1 a_0)\n$$\nThis gives the individual hash bits:\n- $h_0 = a_4 \\oplus a_0$\n- $h_1 = a_5 \\oplus a_1$\n- $h_2 = a_6 \\oplus a_2$\n- $h_3 = a_7 \\oplus a_3$\n\nThe output $S_k$ of the $4$-to-$16$ decoder is asserted if and only if the decimal value of the input vector $h_3 h_2 h_1 h_0$ is equal to $k$. Let the binary representation of the integer $k$ (where $0 \\le k \\le 15$) be $k_3 k_2 k_1 k_0$. The condition for $S_k$ to be $1$ is that the input bits match the binary representation of $k$. That is, $h_3=k_3$, $h_2=k_2$, $h_1=k_1$, and $h_0=k_0$. This corresponds to the $k$-th minterm of the input variables $h_3, h_2, h_1, h_0$.\n\nThe general Boolean equation for the output $S_k$ can be expressed as a conjunction of terms, one for each input bit:\n$$\nS_k = \\bigwedge_{i=0}^{3} T_i\n$$\nwhere the term $T_i$ represents the condition $h_i = k_i$. This condition can be written using standard Boolean logic. If $k_i=1$, the condition is simply $h_i$. If $k_i=0$, the condition is $\\neg h_i$.\n\nNow, we substitute the definitions for each $h_i$:\n- For $i=0$: $T_0$ is $(a_4 \\oplus a_0)$ if $k_0=1$, and $\\neg(a_4 \\oplus a_0)$ if $k_0=0$.\n- For $i=1$: $T_1$ is $(a_5 \\oplus a_1)$ if $k_1=1$, and $\\neg(a_5 \\oplus a_1)$ if $k_1=0$.\n- For $i=2$: $T_2$ is $(a_6 \\oplus a_2)$ if $k_2=1$, and $\\neg(a_6 \\oplus a_2)$ if $k_2=0$.\n- For $i=3$: $T_3$ is $(a_7 \\oplus a_3)$ if $k_3=1$, and $\\neg(a_7 \\oplus a_3)$ if $k_3=0$.\n\nThe logical negation of an XOR operation, $\\neg(P \\oplus Q)$, is equivalent to the XNOR operation, which is true if and only if $P$ and $Q$ are equal. We denote this as $P \\iff Q$.\n\nThus, the complete specification for the Boolean equations for each output signal $S_k$ (where $k$ is represented by $k_3k_2k_1k_0$) in terms of the address bits $\\{a_7, \\dots, a_0\\}$ is:\n$$\nS_k = \\left[ (a_7 \\oplus a_3)^{k_3} \\right] \\land \\left[ (a_6 \\oplus a_2)^{k_2} \\right] \\land \\left[ (a_5 \\oplus a_1)^{k_1} \\right] \\land \\left[ (a_4 \\oplus a_0)^{k_0} \\right]\n$$\nwhere the notation $X^1$ denotes the expression $X$ and $X^0$ denotes the expression $\\neg X$.\n\n**Part 2: Conflict Analysis and Reduction**\n\nThe problem defines a streaming access pattern with a stride of $s=16$ cache lines. The sequence of cache-line indices is given by $A_n = A_0 + n \\cdot s$, for integer $n \\ge 0$. A bank conflict occurs if two consecutive accesses, $A_n$ and $A_{n+1}$, map to the same bank. We need to find the asymptotic fraction of such conflicts.\n\nThe relationship between consecutive addresses is $A_{n+1} = A_n + s = A_n + 16$.\nIn binary, $16$ is $10000_2$. The bank selection logic uses the 8-bit index $\\{a_7, \\dots, a_0\\}$. Let's analyze the effect of adding $16$ to this 8-bit value. Let the 8-bit index $A$ be decomposed into a high 4-bit part $H = \\{a_7, a_6, a_5, a_4\\}$ and a low 4-bit part $L = \\{a_3, a_2, a_1, a_0\\}$. This allows us to write the integer value of the 8-bit index as $A_v = 2^4 \\cdot H_v + L_v$, where $H_v$ and $L_v$ are the integer values of $H$ and $L$.\n\nThe next address index is $A_{n+1,v} = (A_{n,v} + 16) \\pmod{2^8}$.\n$A_{n+1,v} = (2^4 \\cdot H_{n,v} + L_{n,v} + 2^4) \\pmod{2^8} = (2^4 \\cdot (H_{n,v} + 1) + L_{n,v}) \\pmod{2^8}$.\nThis addition does not affect the low 4-bit part. The high 4-bit part is incremented by $1$.\nSo, for the bit vectors representing these parts:\n- $L_{n+1} = L_n$\n- $H_{n+1} = (H_n + 1) \\pmod{16}$ (where the operation is 4-bit binary addition)\n\n**(i) Linear Interleaving**\n\nIn the conventional linear interleaving scheme, the bank index is the low-order $4$ bits of $A$.\nBank index of $A_n$: $b_{lin}(A_n) = L_n$.\nBank index of $A_{n+1}$: $b_{lin}(A_{n+1}) = L_{n+1}$.\nAs we established, $L_{n+1} = L_n$.\nTherefore, $b_{lin}(A_n) = b_{lin}(A_{n+1})$ for all $n \\ge 0$.\nThis means that for the given stride of $16$, every consecutive access goes to the same bank. A conflict occurs for every single pair of consecutive accesses.\nThe asymptotic fraction of conflicts for linear interleaving is $f_{lin} = 1$.\n\n**(ii) Hashed Decoder**\n\nWith the hashed decoder, the bank index is the bitwise XOR of the high and low parts.\nBank index of $A_n$: $b_{hash}(A_n) = H_n \\oplus L_n$.\nBank index of $A_{n+1}$: $b_{hash}(A_{n+1}) = H_{n+1} \\oplus L_{n+1} = (H_n + 1) \\oplus L_n$.\n\nA conflict occurs if $b_{hash}(A_n) = b_{hash}(A_{n+1})$.\n$$\nH_n \\oplus L_n = (H_n + 1) \\oplus L_n\n$$\nThe exclusive OR operation has a cancellation property: if $X \\oplus Y = Z \\oplus Y$, then $X = Z$. Applying this property, we can XOR both sides of the equation by $L_n$:\n$$\n(H_n \\oplus L_n) \\oplus L_n = ((H_n + 1) \\oplus L_n) \\oplus L_n\n$$\n$$\nH_n \\oplus (L_n \\oplus L_n) = (H_n + 1) \\oplus (L_n \\oplus L_n)\n$$\nSince $L_n \\oplus L_n$ results in a zero vector, this simplifies to:\n$$\nH_n = H_n + 1\n$$\nThis equation states that a 4-bit binary number is equal to itself plus one. This is a contradiction and can never be true for any binary vector $H_n$.\nTherefore, $b_{hash}(A_n) \\neq b_{hash}(A_{n+1})$ for all $n \\ge 0$.\nNo consecutive accesses map to the same bank.\nThe asymptotic fraction of conflicts for the hashed decoder is $f_{hash} = 0$.\n\n**Conflict Reduction**\n\nThe conflict reduction is defined as the difference between the two fractions:\n$$\n\\text{Conflict Reduction} = f_{lin} - f_{hash} = 1 - 0 = 1\n$$\nThe hashed decoder completely eliminates bank conflicts for a streaming access pattern with a stride of $16$.",
            "answer": "$$\\boxed{1}$$"
        }
    ]
}