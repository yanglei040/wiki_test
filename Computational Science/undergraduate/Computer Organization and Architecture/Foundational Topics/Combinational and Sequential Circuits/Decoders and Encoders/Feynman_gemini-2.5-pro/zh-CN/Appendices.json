{
    "hands_on_practices": [
        {
            "introduction": "一个解码器不仅仅是一个抽象的真值表；它是一个由逻辑门构成的物理电路，因此具有传播延迟。这个练习将带你深入了解解码器设计的物理现实，特别是当控制信号（如使能信号）并非完美同步时可能出现的时序“毛刺”（glitch）。通过分析信号延迟和竞争条件，你将学会如何从根本上确保电路的可靠性，这对于任何硬件设计都至关重要 。",
            "id": "3633886",
            "problem": "要求您设计并分析一个用于同步数字系统的 $n$-to-$2^n$ 解码器，该解码器具有两个高电平有效使能端。每个输出都是高电平有效。该解码器由基本逻辑门构建如下：\n\n- 对于每个输入位 $x_j$（其中 $j \\in \\{0,\\dots,n-1\\}$），使用一个反相器生成其两种极性 $x_j$ 和 $\\bar{x}_j$。\n- 对于每个输出索引 $k \\in \\{0,\\dots,2^n-1\\}$（其二进制展开为 $k = k_{n-1}\\dots k_1 k_0$），形成相应的最小项 $M_k = \\bigwedge_{j=0}^{n-1} z_j$，其中如果 $k_j = 1$ 则 $z_j = x_j$，如果 $k_j = 0$ 则 $z_j = \\bar{x}_j$。\n- 最终输出为 $Y_k = E_1 \\land E_2 \\land M_k$，其中 $E_1$ 和 $E_2$ 是两个高电平有效使能信号。$n$ 输入的最小项级和两个使能信号由一个单独的 $(n+2)$ 输入与门组合，其输出直接驱动 $Y_k$。\n\n假设使用以下时序模型进行险象分析：\n\n- 每个逻辑门都表现为惯性延迟模型，具有传播延迟 $t_{\\mathrm{pd}}$ 和污染延迟 $t_{\\mathrm{cd}}$。门输入端宽度严格小于该门污染延迟 $t_{\\mathrm{cd}}$ 的脉冲不会在该门产生任何输出转换。\n- 在感兴趣的时间间隔内，最小项 $M_k$ 稳定在逻辑 $1$，所有其他最小项都处于逻辑 $0$。因此，只有 $Y_k$ 可能因使能时序问题而产生毛刺。\n- 外部使能信号以相反方向近乎同时地翻转，以保持解码器禁用：在时间 $t=0$ 时，$E_1$ 开始一个 $0 \\to 1$ 的转换，$E_2$ 开始一个 $1 \\to 0$ 的转换，但它们的外部时序偏斜在 $|\\Delta t_{\\mathrm{ext}}| \\le \\sigma$ 的范围内是未知的，其中 $\\sigma \\ge 0$ 是一个已知常数。一个正的 $\\Delta t_{\\mathrm{ext}}$ 意味着 $E_2$ 开始其 $1 \\to 0$ 转换的时间晚于 $E_1$ 开始其 $0 \\to 1$ 转换的时间。\n\n设从外部引脚到最终与门输入的使能路径传播延迟分别为：$E_1$ 上 $0 \\to 1$ 转换的 $t_{\\mathrm{pd},1}^{\\uparrow}$ 和 $E_2$ 上 $1 \\to 0$ 转换的 $t_{\\mathrm{pd},2}^{\\downarrow}$。设最终 $(n+2)$ 输入与门的污染延迟为 $t_{\\mathrm{cd,AND}}$。\n\n将内部使能路径偏斜大小定义为 $S \\triangleq \\left|t_{\\mathrm{pd},1}^{\\uparrow} - t_{\\mathrm{pd},2}^{\\downarrow}\\right|$。仅使用上述时序定义和惯性延迟的第一性原理，推导并报告最大允许偏斜大小 $S_{\\max}$ 的单个闭式表达式（作为 $t_{\\mathrm{cd,AND}}$ 和 $\\sigma$ 的函数），该表达式保证当 $E_1$ 和 $E_2$ 如所述近乎同时翻转时，$Y_k$ 上不会出现杂散脉冲。请以闭式解析表达式的形式提供您的最终答案。不需要进行数值计算，也不需要四舍五入。",
            "solution": "该问题是有效的，因为它科学地基于数字逻辑和时序分析的原理，问题陈述清晰、客观，并包含足够的信息来推导出唯一解。\n\n如果在最终 $(n+2)$ 输入与门的输入端条件导致其输出在应保持逻辑 $0$ 时短暂地转换为逻辑 $1$，则输出 $Y_k$ 处可能出现杂散脉冲或毛刺。输出的逻辑函数为 $Y_k = E_1 \\land E_2 \\land M_k$。已知最小项输入 $M_k$ 稳定保持在逻辑 $1$。因此，$Y_k$ 的行为由最终与门输入端所见的表达式 $E_1 \\land E_2$ 决定。我们将这些从外部引脚传播而来的内部信号表示为 $e_1(t)$ 和 $e_2(t)$。输出的逻辑状态由 $y(t) = e_1(t) \\land e_2(t)$ 决定。\n\n系统旨在从一个禁用状态（外部 $(E_1, E_2) = (0,1)$）转换到另一个禁用状态（外部 $(E_1, E_2) = (1,0)$）。在初始和最终状态下，乘积 $E_1 \\land E_2$ 均为 $0$，因此输出 $Y_k$ 应保持为 $0$。如果在转换期间，内部信号瞬时进入状态 $(e_1, e_2) = (1,1)$，则可能发生毛刺。\n\n根据所提供的惯性延迟模型，输入端的脉冲宽度必须大于或等于门的污染延迟 $t_{\\mathrm{cd}}$，才能在输出端引起相应的转换。在我们的情况下，“输入脉冲”是条件 $e_1(t) \\land e_2(t) = 1$ 为真的时间间隔。为保证 $Y_k$ 上不出现杂散脉冲，此间隔的持续时间（我们称之为 $W$）必须严格小于最终与门的污染延迟 $t_{\\mathrm{cd,AND}}$。\n$$W  t_{\\mathrm{cd,AND}}$$\n只有当 $e_1$ 的上升沿在 $e_2$ 的下降沿之前到达与门时，才会发生险象状态 $(e_1, e_2) = (1,1)$。设 $t_{1,s}$ 为外部 $E_1$ 信号开始其 $0 \\to 1$ 转换的时间，而 $t_{2,s}$ 为外部 $E_2$ 信号开始其 $1 \\to 0$ 转换的时间。\n$e_1$ 的上升沿在其目的地（即最终与门）完成的时间为：\n$$t_{e1,\\uparrow} = t_{1,s} + t_{\\mathrm{pd},1}^{\\uparrow}$$\n$e_2$ 的下降沿在同一与门完成的时间为：\n$$t_{e2,\\downarrow} = t_{2,s} + t_{\\mathrm{pd},2}^{\\downarrow}$$\n如果 $t_{e1,\\uparrow}  t_{e2,\\downarrow}$，则会发生重叠。此重叠的持续时间，即潜在引起毛刺的条件的宽度，为：\n$$W = t_{e2,\\downarrow} - t_{e1,\\uparrow}$$\n将到达时间的表达式代入无毛刺条件 $W  t_{\\mathrm{cd,AND}}$ 中：\n$$(t_{2,s} + t_{\\mathrm{pd},2}^{\\downarrow}) - (t_{1,s} + t_{\\mathrm{pd},1}^{\\uparrow})  t_{\\mathrm{cd,AND}}$$\n我们可以通过将外部时序项和内部路径延迟项分组来重新整理此式：\n$$(t_{2,s} - t_{1,s}) + (t_{\\mathrm{pd},2}^{\\downarrow} - t_{\\mathrm{pd},1}^{\\uparrow})  t_{\\mathrm{cd,AND}}$$\n问题将外部时序偏斜定义为 $\\Delta t_{\\mathrm{ext}} = t_{2,s} - t_{1,s}$，将内部使能路径偏斜大小定义为 $S = |t_{\\mathrm{pd},1}^{\\uparrow} - t_{\\mathrm{pd},2}^{\\downarrow}|$。我们定义一个有符号的内部路径偏斜 $s_{\\mathrm{int}} = t_{\\mathrm{pd},1}^{\\uparrow} - t_{\\mathrm{pd},2}^{\\downarrow}$，因此 $S = |s_{\\mathrm{int}}|$。该不等式可以写为：\n$$\\Delta t_{\\mathrm{ext}} - s_{\\mathrm{int}}  t_{\\mathrm{cd,AND}}$$\n为保证无毛刺操作，此不等式必须在问题规范所允许的所有可能条件下都得到满足。外部偏斜的边界为 $|\\Delta t_{\\mathrm{ext}}| \\le \\sigma$，即 $-\\sigma \\le \\Delta t_{\\mathrm{ext}} \\le \\sigma$。内部偏斜大小为 $S$，这意味着其有符号值的边界为 $-S \\le s_{\\mathrm{int}} \\le S$。\n\n为保证不等式成立，我们必须确保左侧的最大可能值小于右侧。当 $\\Delta t_{\\mathrm{ext}}$ 取其最大值且 $s_{\\mathrm{int}}$ 取其最小值时，表达式 $\\Delta t_{\\mathrm{ext}} - s_{\\mathrm{int}}$ 达到最大值。\n$$\\max(\\Delta t_{\\mathrm{ext}}) = \\sigma$$\n$$\\min(s_{\\mathrm{int}}) = -S$$\n将这些最坏情况的值代入不等式，得到给定的内部偏斜大小 $S$ 必须满足的条件：\n$$\\sigma - (-S)  t_{\\mathrm{cd,AND}}$$\n$$\\sigma + S  t_{\\mathrm{cd,AND}}$$\n这个不等式定义了“安全”的内部偏斜大小的范围。为了求出最大允许偏斜大小 $S_{\\max}$，我们解出 $S$：\n$$S  t_{\\mathrm{cd,AND}} - \\sigma$$\n任何严格小于 $t_{\\mathrm{cd,AND}} - \\sigma$ 的偏斜大小 $S$ 都保证是安全的。最大允许值 $S_{\\max}$ 是这个安全值集合的上确界，即不等式的边界。\n$$S_{\\max} = t_{\\mathrm{cd,AND}} - \\sigma$$\n这个表达式是保证不产生杂散脉冲的最大允许偏斜大小。该结果在 $S_{\\max}$ 为非负时具有物理意义，这要求 $t_{\\mathrm{cd,AND}} \\ge \\sigma$。如果 $t_{\\mathrm{cd,AND}}  \\sigma$，即使内部路径完全匹配（$S=0$），也无法保证无毛刺操作，因为仅外部偏斜就足以导致一个比门的滤波能力更宽的险象重叠。",
            "answer": "$$ \\boxed{t_{\\mathrm{cd,AND}} - \\sigma} $$"
        },
        {
            "introduction": "从物理层面的挑战转向解码器在计算机体系结构中的核心应用。现代CPU要求内存访问必须“对齐”，例如，一个4字节的访问其地址必须是4的倍数。这个练习将向你展示如何利用解码器，通过检查地址的低位比特来高效地实现这一规则，并探讨在CPU流水线中何处放置该检查逻辑以保证精确异常的处理 。",
            "id": "3633922",
            "problem": "一个中央处理器（CPU）实现了一个加载/存储指令集，该指令集具有一个 5 级流水线，包括取指（IF）、指令译码（ID）、执行（EX）、访存（MEM）和写回（WB）。有效地址在执行阶段计算，公式为 $EA = R_s + \\text{imm}$，其中 $EA$ 是有效地址，$R_s$ 是一个基址寄存器，$\\text{imm}$ 是一个符号扩展的立即数。该架构支持 $2^a$ 字节的访问宽度，其中 $a \\in \\{0,1,2,3\\}$ 分别对应字节（$1$）、半字（$2$）、字（$4$）和双字（$8$）的访问。指令译码器在指令译码阶段根据操作码产生 $a$。内存系统使用带有转译后备缓冲器（TLB）的虚拟内存，处理器必须在发出任何内存事务或修改寄存器堆之外的体系结构状态之前，对任何未对齐的加载或存储引发一个精确异常。对齐由一个经过充分检验的规则定义：宽度为 $W = 2^a$ 字节的访问必须满足 $EA \\bmod W = 0$。\n\n设计一个地址对齐译码器，通过译码 $EA$ 的低 $a$ 位来检测未对齐的 $2^a$ 字节访问。基于第一性原理，确定为检测未对齐而必须对低 $a$ 位检查的最小布尔条件，并确定在所述的流水线和虚拟内存假设下，将此译码器放置在哪个最早的流水线阶段可以保证产生无内存副作用的精确异常。\n\n哪个选项正确地指明了布尔条件和合适的流水线位置？\n\nA. 对于宽度为 $2^a$ 字节的访问，如果 $EA$ 的低 $a$ 位中有任何一位为 $1$，则为未对齐。通过一个 $a$ 输入的或非门（NOR）或相等比较器检查 $EA[a-1:0] = 0$ 来实现；将译码器放置在执行（EX）阶段，因为 $EA$ 在此阶段首次可用，以便取消后续的访存（MEM）阶段并在任何内存事务之前引发异常。\n\nB. 对于宽度为 $2^a$ 字节的访问，如果 $EA[a:0]$ 中有任何一位为 $1$，则为未对齐，因为访问跨越 $2^a$ 个地址。将译码器放置在访存（MEM）阶段，因为数据内存宽度控制仅在此处可用。\n\nC. 在有虚拟内存的情况下，未对齐只能在地址翻译后确定，因为 TLB 可能会改变地址的低 $a$ 位。因此，译码器必须放置在访存（MEM）阶段的 TLB 之后。\n\nD. 在 $64$ 位机器上，字节访问（$a=0$）是未对齐的，因为地址必须至少是 $2$ 字节对齐的；因此，译码器应为 $a=0$ 发出未对齐信号，并将检查放置在写回（WB）阶段以维持精确异常。\n\nE. 通过对 $EA$ 的低 $a$ 位进行与（AND）归约并在归约结果等于 $0$ 时发出未对齐信号来检测未对齐；将译码器放置在指令译码（ID）阶段，以避免在执行（EX）阶段前浪费周期。",
            "solution": "我们从对齐的核心定义开始：一个宽度为 $W = 2^a$ 字节的访问是对齐的，当且仅当有效地址 $EA$ 满足\n$$EA \\bmod W = 0.$$\n在二进制中，这等价于 $EA$ 的低 $a$ 位全为零的陈述。要理解原因，可以观察到 $W = 2^a$ 定义了一些块，这些块的地址具有相同的高位，而块内偏移量由低 $a$ 位给出。余数 $EA \\bmod 2^a$ 正是由 $EA[a-1:0]$ 表示的值。因此，\n$$EA \\bmod 2^a = 0 \\quad \\Longleftrightarrow \\quad EA[a-1:0] = 0.$$\n因此，当且仅当以下条件成立时，可以精确地检测到未对齐访问：\n$$EA \\bmod 2^a \\ne 0 \\quad \\Longleftrightarrow \\quad EA[a-1:0] \\ne 0 \\quad \\Longleftrightarrow \\quad \\bigvee_{i=0}^{a-1} EA_i = 1,$$\n其中 $\\bigvee$ 表示对低 $a$ 位的逻辑或运算。\n\n从流水线的角度来看，$EA$ 可用的最早阶段是执行（EX）阶段，因为 $EA = R_s + \\text{imm}$ 需要读取 $R_s$（在指令译码（ID）阶段执行）然后进行加法运算（在执行（EX）阶段执行）。虽然指令译码（ID）阶段从操作码中知道 $a$，但它不知道 $EA$；因此无法在该阶段判断是否未对齐。将未对齐译码器放置在执行（EX）阶段，允许控制逻辑在任何内存副作用发生前引发精确异常并取消（squash）访存（MEM）阶段，从而满足精确异常的要求。在有虚拟内存的情况下，转译后备缓冲器（TLB）的翻译会保留页内偏移量，所以低位 $EA[a-1:0]$ 在翻译后保持不变；对齐检查可以安全地在翻译前使用虚拟 $EA$ 进行。因此，最小且正确的条件是 $EA[a-1:0] \\ne 0$，通过一个 $a$ 输入的或非门（NOR）或相等比较器检查 $EA[a-1:0] = 0$ 来实现，而合适的最早放置位置是执行（EX）阶段。\n\n逐项分析选项：\n\nA. 该选项指出，如果 $EA$ 的低 $a$ 位中有任何一位为 1，则宽度为 $2^a$ 字节的访问是未对齐的，并建议通过一个 $a$ 输入的或非门（NOR）或相等比较器检查 $EA[a-1:0] = 0$ 来实现。这与我们的推导相符：$EA \\bmod 2^a = 0$ 当且仅当 $EA[a-1:0] = 0$，所以当这些位中有任何一位为 1 时就会发生未对齐。放置在执行（EX）阶段是正确的，因为 $EA$ 在此阶段首次可用，允许流水线取消（squash）访存（MEM）阶段并在任何内存流量发生前引发精确异常。结论：正确。\n\nB. 该选项错误地将位 $a$ 包含在对齐掩码中，提议检查 $EA[a:0] = 0$。对于 $2^a$ 字节对齐，正确的掩码恰好覆盖低 $a$ 位，即 $EA[a-1:0]$。包含位 $a$ 会错误地拒绝那些 $EA[a] = 1$ 但 $EA[a-1:0] = 0$ 的对齐地址，而这些地址是 $2^a$ 的有效倍数。它还错误地断言数据内存宽度控制仅在访存（MEM）阶段可用；宽度 $a$ 在指令译码（ID）阶段被译码，$EA$ 在执行（EX）阶段计算，因此对齐检查可以在比访存（MEM）更早的执行（EX）阶段完成。结论：不正确。\n\nC. 该选项声称转译后备缓冲器（TLB）可能会改变低 $a$ 位，因此需要将检查放置在地址翻译之后。在标准的虚拟内存系统中，页内偏移量（页面内的低位）在翻译过程中是保留的；只有高位（页号）会被改变。因此，低 $a$ 位 $EA[a-1:0]$ 在翻译下是不变的，对齐检查可以在访存（MEM）阶段之前进行。结论：不正确。\n\nD. 该选项声称在 64 位机器上字节访问（$a=0$）是未对齐的，并建议为 $a=0$ 发出未对齐信号，将检查放置在写回（WB）阶段。根据定义，对于 $a=0$，我们有 $W = 2^0 = 1$，而条件 $EA \\bmod 1 = 0$ 对所有整数 $EA$ 始终为真；字节访问总是对齐的。此外，写回（WB）阶段太晚，无法确保没有内存副作用，因为内存在访存（MEM）阶段已经被访问过了。结论：不正确。\n\nE. 该选项提议通过对 $EA$ 的低 $a$ 位进行与（AND）归约，并在归约结果等于 0 时发出未对齐信号来检测未对齐。正确的条件是，如果低 $a$ 位中有任何一位为 1，即或（OR）归约结果等于 1，则发生未对齐。与（AND）归约结果等于 1 仅当所有位都为 1 时，这不是对齐条件；使用与（AND）归约会产生错误的谓词。此外，将译码器放置在指令译码（ID）阶段是不可行的，因为 $EA$ 在 ID 阶段尚未计算出来。结论：不正确。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "在掌握了地址解码的基础后，让我们来探索一个更高级的应用：如何通过巧妙的解码器设计来优化系统性能。传统的线性内存体（bank）选择方案在处理特定访问模式（如大步幅访问）时，容易产生访存冲突，从而降低性能。本练习将引导你设计并分析一种基于异或（XOR）的哈希解码方案，它能有效“打乱”地址到内存体的映射，从而显著减少冲突，提升内存并行度 。",
            "id": "3633897",
            "problem": "一个内存子系统采用存储体交叉（bank interleaving）技术，拥有 $B=16$ 个相同的存储体以增加并行性。物理地址以大小为 $64$ 字节的缓存行为粒度进行考虑，因此用于存储体选择的地址是缓存行索引 $A$，其二进制表示为 $\\{a_7,a_6,a_5,a_4,a_3,a_2,a_1,a_0\\}$，其中 $a_0$ 是行索引的最低有效位。在传统的线性交叉方案中，存储体索引是 $A$ 的低 $4$ 位。为了缓解结构化访问模式下的存储体冲突，提出了一种替代的存储体哈希解码器，该解码器将存储体索引映射到行字段的两个不相交的 $4$ 位组的按位异或（XOR）结果，具体映射关系为\n$$\nh_3 h_2 h_1 h_0 = (a_7 a_6 a_5 a_4)\\ \\oplus\\ (a_3 a_2 a_1 a_0),\n$$\n其中 $\\oplus$ 表示按位异或，$h_3$ 是存储体索引的最高有效位。存储体选择信号是由 $h_3 h_2 h_1 h_0$ 驱动的 $4$-to-$16$ 解码器的独热（one-hot）输出。\n\n任务：\n- 仅使用解码器和布尔组合逻辑的定义，根据输入位 $\\{a_7,\\dots,a_0\\}$ 和独热存储体选择输出 $\\{S_0,S_1,\\dots,S_{15}\\}$，指定地址解码器为实现哈希存储体选择所必须实现的布尔方程。您的规范应清楚说明异或（XOR）网络如何馈入 $4$-to-$16$ 解码器。\n- 考虑一个步长为 $s=16$ 个缓存行的流式访问模式，即地址形式为 $A_n = A_0 + n \\cdot s$，其中整数 $n \\ge 0$。将此流的存储体冲突定义为两个连续访问 $A_n$ 和 $A_{n+1}$ 映射到同一存储体的事件。仅从上述定义以及二进制加法和异或的标准属性出发，确定 (i) 线性交叉和 (ii) 哈希解码器下，发生冲突的连续访问对的渐近分数。然后计算哈希解码器相对于线性交叉的冲突减少量，定义为这两个分数之差。\n\n将冲突减少量报告为单个实数。无需单位。不要四舍五入；给出精确值。",
            "solution": "问题陈述已经过验证，被认为是合理的。它在科学上基于计算机体系结构的原理，特别是内存系统设计。问题提法恰当，提供了所有必要的定义和数据，可以得出一个唯一的、有意义的解决方案。它是客观的，没有任何非形式化或矛盾的元素。\n\n根据问题陈述的要求，解决方案分为两部分。首先，我们推导哈希存储体选择解码器的布尔方程。其次，我们分析在指定的访问模式下，线性交叉和哈希交叉方案的存储体冲突率，并计算相对冲突减少量。\n\n**第1部分：哈希存储体解码器的布尔方程**\n\n系统有 $B=16$ 个内存存储体。存储体选择由一个 $4$ 位存储体索引确定。存储体选择信号是 $4$-to-$16$ 解码器的独热输出 $\\{S_0, S_1, \\dots, S_{15}\\}$。这意味着对于给定的 $4$ 位输入，只有一个输出信号 $S_k$ 被置为有效（逻辑 $1$），而所有其他信号则被置为无效（逻辑 $0$）。\n\n该解码器的输入是哈希存储体索引，一个表示为 $h_3 h_2 h_1 h_0$ 的 $4$ 位向量。哈希函数根据 $8$ 位缓存行索引 $A = \\{a_7, a_6, a_5, a_4, a_3, a_2, a_1, a_0\\}$ 定义为两个 $4$ 位字段的按位异或（XOR）：\n$$\nh_3 h_2 h_1 h_0 = (a_7 a_6 a_5 a_4) \\oplus (a_3 a_2 a_1 a_0)\n$$\n这给出了各个哈希位：\n- $h_0 = a_4 \\oplus a_0$\n- $h_1 = a_5 \\oplus a_1$\n- $h_2 = a_6 \\oplus a_2$\n- $h_3 = a_7 \\oplus a_3$\n\n$4$-to-$16$ 解码器的输出 $S_k$ 被置为有效，当且仅当输入向量 $h_3 h_2 h_1 h_0$ 的十进制值等于 $k$。设整数 $k$（其中 $0 \\le k \\le 15$）的二进制表示为 $k_3 k_2 k_1 k_0$。$S_k$ 为 $1$ 的条件是输入位与 $k$ 的二进制表示相匹配。即 $h_3=k_3$, $h_2=k_2$, $h_1=k_1$ 且 $h_0=k_0$。这对应于输入变量 $h_3, h_2, h_1, h_0$ 的第 $k$ 个最小项。\n\n输出 $S_k$ 的通用布尔方程可以表示为各项的合取，每个输入位对应一项：\n$$\nS_k = \\bigwedge_{i=0}^{3} T_i\n$$\n其中项 $T_i$ 表示条件 $h_i = k_i$。这个条件可以用标准布尔逻辑写出。如果 $k_i=1$，条件就是 $h_i$。如果 $k_i=0$，条件就是 $\\neg h_i$。\n\n现在，我们代入每个 $h_i$ 的定义：\n- 对于 $i=0$：如果 $k_0=1$，$T_0$ 是 $(a_4 \\oplus a_0)$；如果 $k_0=0$，$T_0$ 是 $\\neg(a_4 \\oplus a_0)$。\n- 对于 $i=1$：如果 $k_1=1$，$T_1$ 是 $(a_5 \\oplus a_1)$；如果 $k_1=0$，$T_1$ 是 $\\neg(a_5 \\oplus a_1)$。\n- 对于 $i=2$：如果 $k_2=1$，$T_2$ 是 $(a_6 \\oplus a_2)$；如果 $k_2=0$，$T_2$ 是 $\\neg(a_6 \\oplus a_2)$。\n- 对于 $i=3$：如果 $k_3=1$，$T_3$ 是 $(a_7 \\oplus a_3)$；如果 $k_3=0$，$T_3$ 是 $\\neg(a_7 \\oplus a_3)$。\n\nXOR 操作的逻辑非，即 $\\neg(P \\oplus Q)$，等价于 XNOR 操作，当且仅当 $P$ 和 $Q$ 相等时为真。我们将其表示为 $P \\iff Q$。\n\n因此，关于地址位 $\\{a_7, \\dots, a_0\\}$ 的每个输出信号 $S_k$（其中 $k$ 由 $k_3k_2k_1k_0$ 表示）的完整布尔方程规范是：\n$$\nS_k = \\left[ (a_7 \\oplus a_3)^{k_3} \\right] \\land \\left[ (a_6 \\oplus a_2)^{k_2} \\right] \\land \\left[ (a_5 \\oplus a_1)^{k_1} \\right] \\land \\left[ (a_4 \\oplus a_0)^{k_0} \\right]\n$$\n其中符号 $X^1$ 表示表达式 $X$，$X^0$ 表示表达式 $\\neg X$。\n\n**第2部分：冲突分析与减少**\n\n问题定义了一个步长为 $s=16$ 个缓存行的流式访问模式。缓存行索引序列由 $A_n = A_0 + n \\cdot s$ 给出，其中整数 $n \\ge 0$。如果两个连续访问 $A_n$ 和 $A_{n+1}$ 映射到同一个存储体，则发生存储体冲突。我们需要找到此类冲突的渐近分数。\n\n连续地址之间的关系是 $A_{n+1} = A_n + s = A_n + 16$。\n在二进制中，$16$ 是 $10000_2$。存储体选择逻辑使用 $8$ 位索引 $\\{a_7, \\dots, a_0\\}$。让我们分析将 $16$ 加到这个 $8$ 位值上的效果。设 $8$ 位索引 $A$ 分解为高 $4$ 位部分 $H = \\{a_7, a_6, a_5, a_4\\}$ 和低 $4$ 位部分 $L = \\{a_3, a_2, a_1, a_0\\}$。这使我们可以将 $8$ 位索引的整数值写为 $A_v = 2^4 \\cdot H_v + L_v$，其中 $H_v$ 和 $L_v$ 是 $H$ 和 $L$ 的整数值。\n\n下一个地址索引是 $A_{n+1,v} = (A_{n,v} + 16) \\pmod{2^8}$。\n$A_{n+1,v} = (2^4 \\cdot H_{n,v} + L_{n,v} + 2^4) \\pmod{2^8} = (2^4 \\cdot (H_{n,v} + 1) + L_{n,v}) \\pmod{2^8}$。\n这个加法不影响低 $4$ 位部分。高 $4$ 位部分增加了 $1$。\n因此，对于表示这些部分的位向量：\n- $L_{n+1} = L_n$\n- $H_{n+1} = (H_n + 1) \\pmod{16}$（其中运算是 $4$ 位二进制加法）\n\n**(i) 线性交叉**\n\n在传统的线性交叉方案中，存储体索引是 $A$ 的低 $4$ 位。\n$A_n$ 的存储体索引：$b_{lin}(A_n) = L_n$。\n$A_{n+1}$ 的存储体索引：$b_{lin}(A_{n+1}) = L_{n+1}$。\n正如我们所确定的，$L_{n+1} = L_n$。\n因此，对于所有 $n \\ge 0$，$b_{lin}(A_n) = b_{lin}(A_{n+1})$。\n这意味着对于给定的 $16$ 步长，每个连续的访问都会进入同一个存储体。每一对连续的访问都会发生冲突。\n线性交叉的冲突渐近分数为 $f_{lin} = 1$。\n\n**(ii) 哈希解码器**\n\n使用哈希解码器，存储体索引是高位部分和低位部分的按位异或。\n$A_n$ 的存储体索引：$b_{hash}(A_n) = H_n \\oplus L_n$。\n$A_{n+1}$ 的存储体索引：$b_{hash}(A_{n+1}) = H_{n+1} \\oplus L_{n+1} = (H_n + 1) \\oplus L_n$。\n\n如果 $b_{hash}(A_n) = b_{hash}(A_{n+1})$，则发生冲突。\n$$\nH_n \\oplus L_n = (H_n + 1) \\oplus L_n\n$$\n异或运算具有消除性质：如果 $X \\oplus Y = Z \\oplus Y$，那么 $X = Z$。应用此性质，我们可以将方程两边与 $L_n$ 进行异或运算：\n$$\n(H_n \\oplus L_n) \\oplus L_n = ((H_n + 1) \\oplus L_n) \\oplus L_n\n$$\n$$\nH_n \\oplus (L_n \\oplus L_n) = (H_n + 1) \\oplus (L_n \\oplus L_n)\n$$\n由于 $L_n \\oplus L_n$ 结果为零向量，这可以简化为：\n$$\nH_n = H_n + 1\n$$\n这个方程表明，一个 $4$ 位二进制数等于它自己加一。这是一个矛盾，对于任何二进制向量 $H_n$ 都不可能成立。\n因此，对于所有 $n \\ge 0$，$b_{hash}(A_n) \\neq b_{hash}(A_{n+1})$。\n没有连续的访问会映射到同一个存储体。\n哈希解码器的冲突渐近分数为 $f_{hash} = 0$。\n\n**冲突减少**\n\n冲突减少量定义为这两个分数之差：\n$$\n\\text{冲突减少} = f_{lin} - f_{hash} = 1 - 0 = 1\n$$\n对于步长为 $16$ 的流式访问模式，哈希解码器完全消除了存储体冲突。",
            "answer": "$$\\boxed{1}$$"
        }
    ]
}