{
    "hands_on_practices": [
        {
            "introduction": "我们从一个因混合使用不同调用约定而产生的经典问题开始。本练习将引导您分析`cdecl`和`stdcall`这两种历史悠久但至关重要的调用约定在发生错配时的后果。通过精确计算栈指针的偏移，您将掌握诊断底层代码中栈损坏问题的核心技能，并深刻理解调用方与被调用方之间关于栈清理责任的契约。",
            "id": "3669604",
            "problem": "一个程序从一个库函数返回后会零星地崩溃。平台是一个32位架构，其栈向下增长，即入栈操作会减少栈指针（SP）的值，而出栈操作会增加它。应用程序二进制接口（ABI）规定，`call` 指令会压入一个 $r$ 字节的返回地址，而返回指令的行为如下：一个普通的 `return` 会弹出 $r$ 字节，而带立即数操作数的返回，写作 $\\mathrm{ret}\\;k$，会弹出 $r$ 字节，然后将栈指针（SP）额外增加 $k$ 字节。\n\n两种相关的调用约定如下：\n- C 声明（cdecl）：调用者压入参数，被调用者使用普通的 `return`，调用者在调用后通过将栈指针（SP）增加参数总大小来清理参数区域。\n- 标准调用（stdcall）：调用者压入参数，被调用者使用 $\\mathrm{ret}\\;k$（其中 $k$ 等于参数总大小）来清理参数区域，而调用者不执行调用后栈清理。\n\n假设一个函数以标准调用（stdcall）语义编译，但被一个以 C 声明（cdecl）语义编译的调用者错误地调用。该函数有 $n$ 个参数，每个大小为 $s$ 字节，并且不是可变参数函数。假设被调用者的序言/尾声除了作为返回的一部分外不调整栈指针（SP），并假设除了 $n$ 个参数外没有引入额外的栈对齐填充。将栈失配定义为\n$$\\Delta SP = SP_{\\text{actual}} - SP_{\\text{correct}}$$,\n该值在调用者采取调用后操作（即，在任何调用者端清理之后）后立即测量，符号约定为：正的 $\\Delta SP$ 表示栈指针（SP）相对于基线在数值上增加了。基线 $SP_{\\text{correct}}$ 是指如果调用者和被调用者为此调用使用了一致的调用约定（即，两者都是 cdecl 或两者都是 stdcall）时，将得到的最终栈指针（SP）。\n\n哪个表达式正确地用 $n$、$s$ 和 $r$ 表示 $\\Delta SP$？\n\nA. $\\Delta SP = 0$\n\nB. $\\Delta SP = +n s$\n\nC. $\\Delta SP = -n s$\n\nD. $\\Delta SP = +n s + r$",
            "solution": "首先，确定在一致的调用约定下，调用序列完成后正确的栈指针 $SP_{\\text{correct}}$。设调用前的栈指针为 $SP_0$。在一致的约定下（无论是`cdecl`还是`stdcall`），调用者和被调用者协同工作，以确保在函数调用返回后，栈指针恢复到其初始值。因此，$SP_{\\text{correct}} = SP_0$。\n\n接下来，分析问题描述的错配情况（`cdecl` 调用者调用 `stdcall` 被调用者）下的实际栈指针 $SP_{\\text{actual}}$。\n1.  **调用者 (`cdecl`) 压入参数**：调用者压入总大小为 $ns$ 字节的参数。由于栈向下增长，$SP$ 变为 $SP_0 - ns$。\n2.  **调用者 `call`**：`call` 指令压入 $r$ 字节的返回地址。$SP$ 变为 $SP_0 - ns - r$。\n3.  **被调用者 (`stdcall`) 返回**：以`stdcall`方式编译的被调用者负责清理栈。它执行一条 `ret ns` 指令，该指令会弹出返回地址（将 $SP$ 增加 $r$），然后将 $SP$ 额外增加 $ns$ 字节以清除参数。此时，$SP$ 变为 $(SP_0 - ns - r) + r + ns = SP_0$。\n4.  **调用者 (`cdecl`) 清理栈**：控制权返回后，`cdecl` 调用者按其约定，认为需要自己清理栈。于是它再次将 $SP$ 增加参数总大小 $ns$。\n    $$SP_{\\text{actual}} = SP_0 + ns$$\n\n最后，计算栈失配 $\\Delta SP$：\n$$ \\Delta SP = SP_{\\text{actual}} - SP_{\\text{correct}} = (SP_0 + ns) - SP_0 = +ns $$\n栈指针的最终值比正确值高 $ns$ 字节。这是因为大小为 $ns$ 的参数区域被清理了两次：一次由 `stdcall` 被调用者清理，另一次由 `cdecl` 调用者清理。\n\n基于此推导，我们评估各个选项：\n*   A. $\\Delta SP = 0$：错误。除非没有参数（$n=0$ 或 $s=0$），否则会因双重清理而产生失配。\n*   B. $\\Delta SP = +ns$：正确。与推导结果相符。\n*   C. $\\Delta SP = -ns$：错误。这对应于参数完全未被清理的情况（例如，`stdcall` 调用者调用 `cdecl` 被调用者）。\n*   D. $\\Delta SP = +ns + r$：错误。返回地址 $r$ 的处理是对称的（`call` 压入，`ret` 弹出），不会导致最终的失配。",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "现代调用约定，例如 System V AMD64 ABI，已经转向以寄存器为中心的数据传递方式。本练习将模拟一个在高级语言中嵌入汇编代码时极易出现的微妙错误：忘记在“clobber list”中声明被修改的寄存器。通过追踪这一疏忽如何导致指针损坏并最终读取错误的数据，您将体会到编译器与程序员之间遵循ABI“契约”对于程序正确性的重要性。",
            "id": "3669576",
            "problem": "考虑 System V AMD64 应用程序二进制接口（System V AMD64 ABI），其中函数的第一个整数或指针参数通过寄存器 $RDI$ 传递，并且寄存器 $RAX$、$RCX$、$RDX$、$RSI$、$RDI$、$R8$、$R9$、$R10$ 和 $R11$ 被指定为调用者保存寄存器。\n\n在GNU编译器套件（GCC）的内联汇编功能中，一个破坏列表（clobber list）声明了汇编块可能修改的寄存器，从而允许编译器通过不假设这些寄存器在汇编块执行后保持不变来保证正确性。\n\n一个函数旨在从一个64位有符号整数数组 $A$ 中加载单个元素 $A[i]$，其中元素的值由下式定义：\n$$\nA[k] = 3k^{2} + 2k + 1.\n$$\n数组 $A$ 的基地址作为其第一个参数传递给函数，因此根据 System V AMD64 ABI，在函数入口处该地址保存在 $RDI$ 中。索引为 $i = 10$。在函数内部，一个内联汇编块执行一条指令，将 $RDI$ 的值增加 $8$（此操作将一个64位元素指针向前移动一个元素），但未能将 $RDI$ 包含在破坏列表中。紧跟在该汇编块之后，编译器基于 $RDI$ 保持不变的错误假设，生成了本应读取 $A[i]$ 的加载指令，并仍然使用 $RDI$ 作为基地址指针。\n\n假设没有恢复或调整 $RDI$ 的中间指令，并且内联汇编的唯一效果是将 $RDI$ 的值增加 $8$。使用调用约定定义和64位整型元素大小的语义，从第一性原理推导实际读取的值，并计算由此产生的数据错误 $E$，其定义为\n$$\nE = \\text{(加载值)} - \\text{(预期值)}.\n$$\n最终答案请表示为精确整数，无需舍入。",
            "solution": "该问题要求计算由于内联汇编中未声明寄存器修改而导致的数据读取错误 $E$。$E$ 定义为加载值与预期值之差。\n\n1.  **计算预期值**\n    函数旨在加载数组 $A$ 的第 $i=10$ 个元素，即 $A[10]$。数组元素的值由公式 $A[k] = 3k^2 + 2k + 1$ 给出。\n    将 $k=10$ 代入公式：\n    $$ \\text{预期值} = A[10] = 3(10)^2 + 2(10) + 1 = 3(100) + 20 + 1 = 321 $$\n    根据 System V AMD64 ABI，数组基地址 $Addr(A)$ 在函数入口处位于 $RDI$ 寄存器。由于元素是64位（8字节）整数，编译器会计算 $A[10]$ 的地址为 $Addr(A) + 10 \\times 8 = Addr(A) + 80$。\n\n2.  **计算实际加载值**\n    在函数执行过程中，一个内联汇编块将 $RDI$ 的值增加了 8，但未在破坏列表中声明此修改。\n    -   初始时，$RDI = Addr(A)$。\n    -   汇编块执行后，$RDI$ 的值变为 $Addr(A) + 8$。\n    编译器不知道 $RDI$ 已被修改，因此它仍然基于 $RDI$ 的（被修改后的）值来计算目标地址。它为索引10计算出80字节的偏移量，并将其加到当前的 $RDI$ 值上。\n    $$ \\text{实际地址} = (\\text{修改后的 } RDI) + (\\text{偏移量}) = (Addr(A) + 8) + 80 = Addr(A) + 88 $$\n    这个地址对应数组的哪个元素？由于元素 $A[k]$ 的地址是 $Addr(A) + k \\times 8$，我们可以解方程 $k \\times 8 = 88$，得到 $k = 11$。\n    因此，程序实际上加载的是 $A[11]$。\n    将 $k=11$ 代入公式：\n    $$ \\text{加载值} = A[11] = 3(11)^2 + 2(11) + 1 = 3(121) + 22 + 1 = 363 + 23 = 386 $$\n\n3.  **计算数据错误**\n    $$ E = \\text{加载值} - \\text{预期值} = 386 - 321 = 65 $$\n\n数据错误为65。",
            "answer": "$$\n\\boxed{65}\n$$"
        },
        {
            "introduction": "除了数据传递，现代ABI还对栈指针的对齐（alignment）提出了严格要求，这对于发挥SIMD等高性能指令集的全部威力至关重要。本练习将带您深入研究 System V AMD64 ABI 的栈对齐规则。您将通过分析函数序言（prologue）中一系列操作对栈指针的影响，计算出可能出现的最大未对齐量，从而更好地理解编译器为保证性能和正确性所做的努力。",
            "id": "3669605",
            "problem": "您正在为 System V AMD64 调用约定的应用程序二进制接口（ABI）设计栈对齐的压力测试。根据该约定的定义，在函数入口处（即在调用者的 call 指令将返回地址推入栈中之后），栈指针（SP）满足 $SP \\equiv 8 \\pmod{16}$。推入一个 $w$ 字节的被调用者保存的寄存器会使 $SP$ 减少 $w$，通过调整栈帧为局部变量分配 $L$ 字节会使 $SP$ 减少 $L$。当且仅当 $SP \\equiv 0 \\pmod{16}$ 时，一个地址被称为是16字节对齐的。\n\n考虑一个函数，它在入口处使用 push 指令保存 $q$ 个被调用者保存的寄存器（每个大小为 $w=8$ 字节），然后为局部变量分配 $L$ 字节。编译器被配置为将局部存储分配大小调整为 $16$ 的倍数，因此 $L \\equiv 0 \\pmod{16}$。在进行嵌套调用之前，您希望最大化相对于16字节对齐的未对齐量，以便对检查代码进行压力测试。将未对齐量定义为余数 $r$，其中 $r \\equiv SP \\pmod{16}$ 且 $0 \\le r \\le 15$；对齐对应于 $r=0$。\n\n仅从这些定义和事实出发，推导最终余数 $r$ 关于 $q$, $w$, $L$ 和入口余数 $r_{0}$ 的表达式，然后将其特化为 $r_{0} = 8$, $w = 8$, 和 $L \\equiv 0 \\pmod{16}$。对于所有非负整数 $q$ 和所有满足 $L \\equiv 0 \\pmod{16}$ 的 $L$，确定在嵌套调用之前最大可能的未对齐量（以字节为单位）。将最终答案表示为一个以字节为单位的数字。无需四舍五入。",
            "solution": "该问题要求推导在 System V AMD64 ABI 下，函数序言操作后栈指针（SP）的最大未对齐量。\n\n1.  **建立SP的通用表达式**\n    设 $SP_{entry}$ 是函数入口处的栈指针。根据 ABI，在 `call` 指令之后，$SP_{entry} \\equiv 8 \\pmod{16}$。我们记初始余数为 $r_0 = 8$。\n    函数序言执行以下操作：\n    -   推入 $q$ 个寄存器，每个大小为 $w$ 字节。这使 SP 减少 $q \\cdot w$。\n    -   为局部变量分配 $L$ 字节。这使 SP 减少 $L$。\n    操作后的最终栈指针 $SP_{final}$ 为：\n    $$ SP_{final} = SP_{entry} - q \\cdot w - L $$\n    我们关心的是最终的余数 $r \\equiv SP_{final} \\pmod{16}$。应用模运算性质：\n    $$ r \\equiv (SP_{entry} \\pmod{16} - (q \\cdot w) \\pmod{16} - L \\pmod{16}) \\pmod{16} $$\n    $$ r \\equiv (r_0 - (q \\cdot w \\pmod{16}) - (L \\pmod{16})) \\pmod{16} $$\n\n2.  **特化表达式**\n    根据问题给定的值：\n    -   $r_0 = 8$\n    -   $w = 8$\n    -   $L \\equiv 0 \\pmod{16}$\n    代入通用表达式：\n    $$ r \\equiv (8 - (q \\cdot 8 \\pmod{16}) - 0) \\pmod{16} $$\n    $$ r \\equiv (8 - (8q \\pmod{16})) \\pmod{16} $$\n\n3.  **分析余数随q的变化**\n    我们需要分析 $8q \\pmod{16}$ 的值，其中 $q$ 是非负整数（寄存器数量）。\n    -   **当 $q$ 为偶数** (包括 $q=0$): 设 $q = 2k$ (其中 $k \\ge 0$ 是整数)。\n        $8q = 8(2k) = 16k$。因此，$8q \\pmod{16} = 0$。\n        代入 $r$ 的表达式：$r \\equiv (8 - 0) \\pmod{16} \\implies r = 8$。\n    -   **当 $q$ 为奇数**: 设 $q = 2k+1$ (其中 $k \\ge 0$ 是整数)。\n        $8q = 8(2k+1) = 16k + 8$。因此，$8q \\pmod{16} = 8$。\n        代入 $r$ 的表达式：$r \\equiv (8 - 8) \\pmod{16} \\implies r = 0$。\n\n4.  **确定最大未对齐量**\n    分析表明，无论 $q$ 和 $L$ 的值如何（在约束条件下），最终的余数 $r$ 只有两种可能：$0$ 和 $8$。\n    未对齐量定义为余数 $r$ 本身。因此，可能的值为 0 字节（表示完全对齐）和 8 字节。\n    最大可能的未对齐量是这两个值的最大值：\n    $$ \\max(\\{0, 8\\}) = 8 $$\n    最大未对齐量为 8 字节。",
            "answer": "$$\n\\boxed{8}\n$$"
        }
    ]
}