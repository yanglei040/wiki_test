{
    "hands_on_practices": [
        {
            "introduction": "A core rule in any calling convention is defining who is responsible for cleaning arguments off the stack: the caller or the callee. A mismatch in this protocol is a classic source of elusive bugs that corrupt the stack, often leading to a crash much later. This first exercise  asks you to trace the stack pointer through a call where a caller using the `cdecl` convention (caller-cleans) invokes a function compiled with `stdcall` (callee-cleans), allowing you to precisely quantify the resulting stack corruption.",
            "id": "3669604",
            "problem": "A program crashes sporadically after returning from a library function. The platform is a $32$-bit architecture with a downward-growing stack, where push operations decrease the Stack Pointer (SP) and pop operations increase it. The Application Binary Interface (ABI) specifies that the call instruction pushes a return address of $r$ bytes, and the return instruction behaves as follows: a plain return pops $r$ bytes, while a return with an immediate operand, written as $\\mathrm{ret}\\;k$, pops $r$ bytes and then increases the Stack Pointer (SP) by an additional $k$ bytes.\n\nTwo calling conventions are relevant:\n- C declaration (cdecl): the caller pushes arguments, the callee uses a plain return, and the caller cleans the argument area after the call by increasing the Stack Pointer (SP) by the total argument size.\n- Standard call (stdcall): the caller pushes arguments, the callee cleans the argument area by using $\\mathrm{ret}\\;k$ with $k$ equal to the total argument size, and the caller performs no post-call stack cleanup.\n\nSuppose a function is compiled with Standard call (stdcall) semantics but is mistakenly invoked by a caller compiled under C declaration (cdecl) semantics. The function has $n$ arguments, each of size $s$ bytes, and it is not variadic. Assume the callee’s prologue/epilogue do not adjust the Stack Pointer (SP) except as part of the return, and assume no stack alignment padding beyond the $n$ arguments is introduced. Define the stack mismatch as\n$$\\Delta SP = SP_{\\text{actual}} - SP_{\\text{correct}},$$\nmeasured immediately after the post-call action taken by the caller (i.e., after any caller-side cleanup), with the sign convention that a positive $\\Delta SP$ indicates that the Stack Pointer (SP) numerically increased relative to the baseline. The baseline $SP_{\\text{correct}}$ is the final Stack Pointer (SP) that would result if the caller and callee used a consistent calling convention (either both cdecl or both stdcall) for this call.\n\nWhich expression correctly gives $\\Delta SP$ in terms of $n$, $s$, and $r$?\n\nA. $\\Delta SP = 0$\n\nB. $\\Delta SP = +n s$\n\nC. $\\Delta SP = -n s$\n\nD. $\\Delta SP = +n s + r$",
            "solution": "To find the stack mismatch $\\Delta SP = SP_{\\text{actual}} - SP_{\\text{correct}}$, we first establish the baseline, $SP_{\\text{correct}}$. For any consistent calling convention, the stack pointer must be restored to its original value after a call. If we let $SP_0$ be the stack pointer value before the call sequence, then $SP_{\\text{correct}} = SP_0$.\n\nNext, we trace the actual stack pointer value, $SP_{\\text{actual}}$, through the mismatched call sequence (`cdecl` caller, `stdcall` callee):\n1.  **Caller Pushes Arguments:** The `cdecl` caller pushes $n$ arguments of size $s$, so the stack pointer becomes $SP_0 - ns$.\n2.  **`call` Instruction:** The `call` instruction pushes the return address (size $r$), so the stack pointer becomes $SP_0 - ns - r$.\n3.  **Callee Returns:** The `stdcall` callee is responsible for cleanup. It executes a `ret ns` instruction. This pops the return address (SP increases by $r$) and then adds $ns$ to SP to clear the arguments. The stack pointer is now $(SP_0 - ns - r) + r + ns = SP_0$.\n4.  **Caller Cleans Stack:** Control returns to the caller. The `cdecl` caller, unaware that the callee already cleaned the stack, performs its own cleanup, adding $ns$ to the stack pointer. The final actual stack pointer is therefore $SP_{\\text{actual}} = SP_0 + ns$.\n\nThe stack mismatch is the difference between the actual and correct final stack pointer values:\n$$\n\\Delta SP = SP_{\\text{actual}} - SP_{\\text{correct}} = (SP_0 + ns) - SP_0 = +ns\n$$\nThe stack was cleaned twice—once by the callee and once by the caller—resulting in the stack pointer being offset by an amount equal to the total size of the arguments. This double-cleanup leads to a stack corruption of size $+ns$.",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "Beyond just cleaning up arguments, modern calling conventions impose strict rules for stack alignment, which are critical for the performance of vectorized instructions. The System V AMD64 ABI, for example, requires the stack to be $16$-byte aligned before a `call` instruction. This thought experiment  challenges you to think like a compiler designer and analyze how a function's own setup code—its prologue—can affect this alignment, potentially breaking the ABI contract for any functions it calls.",
            "id": "3669605",
            "problem": "You are designing a stress test for stack alignment on the Application Binary Interface (ABI) for the System V AMD64 (Advanced Micro Devices $64$-bit) calling convention. By definition of this convention, immediately upon function entry (right after the caller’s call instruction has pushed the return address), the Stack Pointer (SP) satisfies $SP \\equiv 8 \\pmod{16}$. A push of a $w$-byte callee-saved register decreases $SP$ by $w$, and allocating $L$ bytes for local variables by adjusting the stack frame decreases $SP$ by $L$. An address is said to be $16$-byte aligned if and only if $SP \\equiv 0 \\pmod{16}$.\n\nConsider a function that, upon entry, saves $q$ callee-saved registers using push instructions, each of size $w = 8$ bytes, and then allocates $L$ bytes for locals. The compiler is configured to round the local storage allocation to a multiple of $16$, so $L \\equiv 0 \\pmod{16}$. Before making a nested call, you want to maximize the misalignment with respect to $16$-byte alignment in order to stress the checking code. Define the misalignment magnitude as the residue $r$ where $r \\equiv SP \\pmod{16}$ and $0 \\le r \\le 15$; alignment corresponds to $r = 0$.\n\nStarting from these definitions and facts only, derive the expression for the resulting residue $r$ in terms of $q$, $w$, $L$, and the entry residue $r_{0}$, and then specialize to $r_{0} = 8$, $w = 8$, and $L \\equiv 0 \\pmod{16}$. Over all nonnegative integers $q$ and all $L$ satisfying $L \\equiv 0 \\pmod{16}$, determine the maximal possible misalignment magnitude (in bytes) immediately before the nested call. Express the final answer as a single number in bytes. No rounding is required.",
            "solution": "Let $SP_{entry}$ be the value of the stack pointer upon function entry. According to the problem statement, its residue modulo $16$ is $r_0$.\n$$SP_{entry} \\equiv r_0 \\pmod{16}$$\nThe function then performs two types of operations that modify the stack pointer:\n1.  It saves $q$ callee-saved registers, each of size $w$ bytes. Since a `push` operation decreases the stack pointer, the total change due to these pushes is $-q \\cdot w$.\n2.  It allocates $L$ bytes for local variables, which also decreases the stack pointer by $L$.\n\nLet $SP_{final}$ be the value of the stack pointer after these operations, just before a potential nested call. The value of $SP_{final}$ is given by:\n$$SP_{final} = SP_{entry} - q \\cdot w - L$$\nWe are interested in the misalignment magnitude, which is the residue $r$ of $SP_{final}$ modulo $16$. We can find this by applying the modulo operator to the entire equation:\n$$r \\equiv SP_{final} \\pmod{16}$$\n$$r \\equiv (SP_{entry} - q \\cdot w - L) \\pmod{16}$$\nUsing the properties of modular arithmetic, we derive the general expression for $r$:\n$$r \\equiv (r_0 - (q \\cdot w \\pmod{16}) - (L \\pmod{16})) \\pmod{16}$$\nNext, we specialize this expression using the specific values and constraints provided:\n- The entry residue is $r_0 = 8$.\n- The register size is $w = 8$ bytes.\n- The local storage allocation $L$ is a multiple of $16$, so $L \\equiv 0 \\pmod{16}$.\n\nSubstituting these into the general expression for $r$:\n$$r \\equiv (8 - (q \\cdot 8 \\pmod{16}) - 0) \\pmod{16}$$\n$$r \\equiv (8 - (8q \\pmod{16})) \\pmod{16}$$\nNow, we must determine the possible values of $r$ over all non-negative integers $q$. We analyze the term $(8q \\pmod{16})$ based on the parity of $q$.\n\n**Case 1: $q$ is an even non-negative integer.**\nLet $q = 2k$ for some integer $k \\ge 0$. The term $8q$ becomes $8(2k) = 16k$.\nThe residue is $16k \\equiv 0 \\pmod{16}$.\nSubstituting this into our expression for $r$:\n$$r \\equiv (8 - 0) \\pmod{16} \\implies r = 8$$\n\n**Case 2: $q$ is an odd non-negative integer.**\nLet $q = 2k + 1$ for some integer $k \\ge 0$. The term $8q$ becomes $8(2k + 1) = 16k + 8$.\nThe residue is $16k + 8 \\equiv 8 \\pmod{16}$.\nSubstituting this into our expression for $r$:\n$$r \\equiv (8 - 8) \\pmod{16} \\implies r = 0$$\n\nThe analysis shows that for any non-negative integer $q$ and any valid $L$, the final residue $r$ can only take two possible values: $0$ and $8$.\nThe misalignment magnitude is defined as this residue $r$. Therefore, the possible misalignment magnitudes are $0$ bytes (perfect alignment) and $8$ bytes.\n\nThe problem asks for the maximal possible misalignment magnitude. Comparing the possible values, we have:\n$$\\max(\\{0, 8\\}) = 8$$\nThe maximal possible misalignment magnitude is $8$ bytes. This occurs whenever an even number of $8$-byte registers (including zero) are pushed onto the stack.",
            "answer": "$$\n\\boxed{8}\n$$"
        },
        {
            "introduction": "Procedure call conventions extend beyond the stack; they also strictly govern the use of CPU registers. Some registers are for passing arguments, while others must be preserved by the callee or can be freely modified (clobbered). This practice  explores a common pitfall when mixing high-level code with inline assembly: failing to declare which registers the assembly code modifies. You will calculate the precise data error that results when a compiler's assumption about an argument register is violated, demonstrating a subtle but severe type of ABI-related bug.",
            "id": "3669576",
            "problem": "Consider the System V Advanced Micro Devices 64-bit Application Binary Interface (System V AMD64 ABI), in which the first integer or pointer argument to a function is passed in the register $RDI$, and registers $RAX$, $RCX$, $RDX$, $RSI$, $RDI$, $R8$, $R9$, $R10$, and $R11$ are designated as caller-saved registers. In the GNU Compiler Collection (GCC) inline assembly facility, a clobber list declares the registers that the assembly block may modify, allowing the compiler to preserve correctness by not assuming those registers remain unchanged across the assembly block.\n\nA function is intended to load a single element $A[i]$ from an array $A$ of $64$-bit signed integers, where the element values are defined by\n$$\nA[k] = 3k^{2} + 2k + 1.\n$$\nThe base address of $A$ is passed to the function as its first argument, hence it is held in $RDI$ on entry consistent with the System V AMD64 ABI. The index is $i = 10$. Inside the function, an inline assembly block executes an instruction that adds $8$ to $RDI$ (an operation that advances a $64$-bit element pointer by one element) but fails to include $RDI$ in the clobber list. Immediately following this assembly block, the compiler emits the load that is supposed to read $A[i]$, still using $RDI$ as the base pointer under the incorrect assumption that $RDI$ remained unchanged.\n\nAssume there are no intervening instructions that restore or adjust $RDI$ and that the only effect of the inline assembly is the addition of $8$ to $RDI$. Using the calling convention definitions and the semantics of $64$-bit integer element size, derive from first principles what value is actually read and compute the resulting data error $E$, defined as\n$$\nE = \\text{(loaded value)} - \\text{(intended value)}.\n$$\nExpress your final answer as an exact integer with no rounding.",
            "solution": "The problem requires us to compute the error resulting from a software bug related to an inline assembly instruction. The error, $E$, is defined as the difference between the value actually loaded from memory and the value that was intended to be loaded.\n\nFirst, we must determine the intended operation. The function aims to load the element $A[i]$ from an array $A$ of $64$-bit signed integers, where the index is specified as $i = 10$. The value of an element at index $k$ is given by the formula:\n$$\nA[k] = 3k^2 + 2k + 1\n$$\nThe intended value is therefore $A[10]$. Substituting $k=10$ into the formula, we get:\n$$\n\\text{Intended value} = A[10] = 3(10)^2 + 2(10) + 1 = 3(100) + 20 + 1 = 300 + 21 = 321\n$$\nThe memory address of this element would be calculated by the compiler. According to the System V AMD64 ABI, the base address of the array $A$, let's call it $Addr(A)$, is passed in the register $RDI$. Since the elements are $64$-bit integers, each element occupies $8$ bytes. The address of $A[i]$ is given by $Addr(A) + i \\times 8$. For the intended index $i=10$, the target memory address is $Addr(A) + 10 \\times 8 = Addr(A) + 80$.\n\nNext, we analyze the actual operation that occurs due to the programming error. The problem states that an inline assembly block executes an instruction that adds $8$ to the $RDI$ register. However, the programmer failed to list $RDI$ in the clobber list. This means the compiler is unaware that the value in $RDI$ has been modified.\nInitially, upon function entry, $RDI$ holds the base address $Addr(A)$.\nAfter the inline assembly block, the value in $RDI$ is no longer $Addr(A)$, but has been updated to $Addr(A) + 8$.\nThe compiler, assuming $RDI$ is unchanged, proceeds to generate the instruction to load $A[10]$. It calculates the offset for the $10$-th element, which is $10 \\times 8 = 80$ bytes. It then generates a memory access relative to the current value of the $RDI$ register. The effective memory address accessed is therefore:\n$$\n\\text{Actual address} = (\\text{new } RDI \\text{ value}) + (\\text{offset for index } 10) = (Addr(A) + 8) + 80 = Addr(A) + 88\n$$\nNow, we must determine which element of the array resides at this address. The address of an element $A[k]$ is $Addr(A) + k \\times 8$. We can find the index $k$ of the actually loaded element by solving the equation:\n$$\nk \\times 8 = 88\n$$\nThis gives $k = \\frac{88}{8} = 11$. Therefore, the instruction actually loads the element $A[11]$.\n\nWe calculate the value of $A[11]$ using the given formula:\n$$\n\\text{Loaded value} = A[11] = 3(11)^2 + 2(11) + 1 = 3(121) + 22 + 1 = 363 + 23 = 386\n$$\nFinally, we compute the data error $E$ as defined in the problem statement:\n$$\nE = \\text{(loaded value)} - \\text{(intended value)} = A[11] - A[10]\n$$\n$$\nE = 386 - 321 = 65\n$$\nAlternatively, we can express the error as the difference function $\\Delta(k) = A[k+1] - A[k]$.\n$$\n\\Delta(k) = (3(k+1)^2 + 2(k+1) + 1) - (3k^2 + 2k + 1)\n$$\n$$\n\\Delta(k) = (3(k^2 + 2k + 1) + 2k + 2 + 1) - (3k^2 + 2k + 1)\n$$\n$$\n\\Delta(k) = (3k^2 + 6k + 3 + 2k + 3) - (3k^2 + 2k + 1)\n$$\n$$\n\\Delta(k) = (3k^2 + 8k + 6) - (3k^2 + 2k + 1)\n$$\n$$\n\\Delta(k) = 6k + 5\n$$\nThe error $E$ is the difference between the value at the actual index ($k=11$) and the intended index ($k=10$), which corresponds to $\\Delta(10)$.\n$$\nE = A[11] - A[10] = \\Delta(10) = 6(10) + 5 = 65\n$$\nBoth methods yield the same result. The error is $65$.",
            "answer": "$$\n\\boxed{65}\n$$"
        }
    ]
}