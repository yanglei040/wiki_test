{
    "hands_on_practices": [
        {
            "introduction": "要掌握基于栈的参数传递，最基本的一步是理解每次函数调用会消耗多少栈空间。这个练习将引导你从第一性原理出发，为栈帧的构成建立一个量化模型。你将运用此模型来预测一个关键的系统故障——栈溢出，从而为栈内存管理建立起基础直觉。",
            "id": "3664296",
            "problem": "考虑一个用于 $64$ 位精简指令集计算机（RISC）架构的传统基于栈的执行模型，该模型使用向下增长的栈。满足以下条件：\n\n- 字长为 $w = 8$ 字节。\n- 调用约定通过栈按值传递所有参数（不使用寄存器传递参数）。调用者推入参数，然后执行一条 call 指令，该指令推入返回地址。接着，被调用者保存先前的帧指针并为其局部变量分配空间。没有尾调用优化，除了帧指针外没有被调用者保存的寄存器。\n- 在一个线性调用链中，每个函数都向下一个函数传递恰好 $p$ 个参数，每个参数占用一个大小为 $w$ 的字。每个函数还声明恰好 $q$ 个局部变量，每个变量占用一个大小为 $w$ 的字。\n- 机器仅强制 $w$ 字节对齐（没有 $16$ 字节对齐的约束），并且活动记录除了所描述对象所隐含的之外不包含任何填充。\n- 该程序的最大可用栈空间为 $S$ 字节，并且程序开始时，相对于此调用链的起点，栈是空的（忽略任何预先存在的帧，例如运行时入口或主函数）。\n\n你正在分析一个深度嵌套的调用序列 $f_{1} \\to f_{2} \\to \\cdots \\to f_{d}$，其中每个 $f_{i}$ 的行为都相同：它向 $f_{i+1}$ 按值传递恰好 $p$ 个参数，并声明恰好 $q$ 个局部变量。当 $f_{d}$ 在其序言（prologue）完成后执行时，栈包含了已进行的所有调用的所有活动记录和所有调用者推入的参数块。使用以下具体数值：$p = 4$，$q = 6$，$w = 8$ 字节，以及 $S = 512 \\times 1024$ 字节。\n\n从活动记录、参数传递和调用/返回行为的核心定义出发，推导出深度为 $d$ 时的总栈使用量 $U(d)$ 的表达式，并确定发生栈溢出的最小深度 $d^{\\star}$，即 $U(d^{\\star})$ 严格超过 $S$ 的深度。仅报告 $d^{\\star}$ 作为你的最终答案。不需要四舍五入；$d^{\\star}$ 是一个表示栈帧数量的精确整数。",
            "solution": "问题要求在一个类似递归的调用链 $f_{1} \\to f_{2} \\to \\cdots \\to f_{d}$ 中，发生栈溢出的最小调用深度 $d^{\\star}$。为了找到这个值，我们必须首先推导出总栈使用量 $U(d)$ 作为调用深度 $d$ 的函数表达式。\n\n该分析基于一个为 $64$ 位架构指定的基于栈的执行模型，这意味着字长为 $w = 8$ 字节。栈向下增长（从高内存地址到低内存地址）。\n\n首先，我们来确定单次函数调用所消耗的栈空间大小，我们可以称之为栈帧或活动记录的大小。问题概述了函数调用（例如，从调用者 $f_{i-1}$ 到被调用者 $f_i$）的事件序列。\n\n1.  调用者 $f_{i-1}$ 为被调用者 $f_i$ 推入参数。共有 $p$ 个参数，每个参数占用一个大小为 $w$ 的字。消耗的空间为 $p \\times w$。\n2.  调用者执行一条 `call` 指令。此操作将返回地址推入栈中，从而允许 $f_i$ 在完成时返回到 $f_{i-1}$。返回地址是一个单独的指针，在 $64$ 位架构上占用一个字。消耗的空间为 $1 \\times w$。\n3.  被调用者 $f_i$ 以一段序言（prologue）开始其执行。序言的第一步是保存调用者 $f_{i-1}$ 的旧帧指针。这也占用一个字。消耗的空间为 $1 \\times w$。\n4.  接着，被调用者的序言为其自身的局部变量分配空间。该函数声明了 $q$ 个局部变量，每个变量占用一个字。消耗的空间为 $q \\times w$。\n\n问题指出，所有对象（参数、返回地址、保存的帧指针、局部变量）都是字大小的，并且机器强制执行 $w$ 字节对齐。由于每个组件的大小都是 $w$ 的倍数，因此不需要额外的填充来维持对齐。\n\n一个完整的活动记录的总大小，包括传递给函数的参数、控制信息和局部变量，是这些组件大小的总和。我们将一个帧的大小表示为 $S_{\\text{frame}}$。\n$$S_{\\text{frame}} = (\\text{参数}) + (\\text{返回地址}) + (\\text{保存的帧指针}) + (\\text{局部变量})$$\n$$S_{\\text{frame}} = (p \\times w) + (1 \\times w) + (1 \\times w) + (q \\times w)$$\n$$S_{\\text{frame}} = (p + q + 2)w$$\n这是调用链中每次函数调用所消耗的总栈空间量。\n\n问题要求我们找到调用深度为 $d$ 时的总栈使用量 $U(d)$。这意味着我们正在分析函数 $f_d$ 执行时（特别是在其“序言完成后”）的栈状态。在执行的这个时刻，调用链 $f_1 \\to f_2 \\to \\cdots \\to f_d$ 已经发生。因此，所有函数 $f_1, f_2, \\ldots, f_d$ 的完整活动记录都驻留在栈上。问题陈述指出，对于此分析，栈初始为空，所以我们只需要考虑这 $d$ 个帧。\n\n由于每次函数调用都会产生一个大小为 $S_{\\text{frame}}$ 的新栈帧，因此调用深度为 $d$ 的总栈使用量为：\n$$U(d) = d \\times S_{\\text{frame}} = d(p+q+2)w$$\n\n现在，我们代入问题陈述中提供的具体值：\n-   参数数量，$p = 4$。\n-   局部变量数量，$q = 6$。\n-   字长，$w = 8$ 字节。\n-   最大可用栈空间，$S = 512 \\times 1024$ 字节。\n\n首先，我们计算单个帧的大小：\n$$S_{\\text{frame}} = (4 + 6 + 2) \\times 8 = 12 \\times 8 = 96 \\text{ 字节}$$\n因此，深度为 $d$ 时的总栈使用量为：\n$$U(d) = 96d \\text{ 字节}$$\n\n当所需的栈空间 $U(d^{\\star})$ 严格超过可用空间 $S$ 时，栈溢出在最小深度 $d^{\\star}$ 处发生。问题明确将此条件定义为：\n$$U(d^{\\star}) > S$$\n代入我们关于 $U(d)$ 和 $S$ 的表达式：\n$$96d^{\\star} > 512 \\times 1024$$\n\n我们解这个关于 $d^{\\star}$ 的不等式：\n$$d^{\\star} > \\frac{512 \\times 1024}{96}$$\n为了简化分数，我们可以将数字表示为 $2$ 的幂：\n$512 = 2^9$\n$1024 = 2^{10}$\n$96 = 3 \\times 32 = 3 \\times 2^5$\n\n将这些代入不等式中：\n$$d^{\\star} > \\frac{2^9 \\times 2^{10}}{3 \\times 2^5} = \\frac{2^{19}}{3 \\times 2^5} = \\frac{2^{14}}{3}$$\n现在我们计算其数值：\n$$2^{14} = (2^7)^2 = 128^2 = 16384$$\n所以，不等式变为：\n$$d^{\\star} > \\frac{16384}{3}$$\n$$d^{\\star} > 5461.333...$$\n\n因为深度 $d^{\\star}$ 必须是一个表示函数调用次数的整数，我们需要找到严格大于 $5461.333...$ 的最小整数。这个整数是 $5462$。\n\n我们来验证一下。在深度 $d=5461$ 时，使用量为 $U(5461) = 96 \\times 5461 = 524256$ 字节。总空间为 $S = 512 \\times 1024 = 524288$ 字节。由于 $524256 \\le 524288$，此时尚未发生溢出。\n在深度 $d=5462$ 时，帧所需的空间将是 $U(5462) = 96 \\times 5462 = 524352$ 字节。这个值大于 $S = 524288$ 字节，所以 $U(5462) > S$。这意味着系统无法为调用 $f_{5462}$ 完全分配栈帧，将会发生栈溢出。因此，发生溢出的最小深度是 $d^{\\star} = 5462$。",
            "answer": "$$\\boxed{5462}$$"
        },
        {
            "introduction": "在理解了栈空间的“量”之后，我们来探讨其“质”——空间的组织方式。现实世界中的ABI（应用程序二进制接口）为了性能和正确性，施加了严格的规则，例如栈对齐。本练习将呈现一个“侦探故事”，一个看似正确的程序却意外崩溃，你的任务是追踪栈的状态，找出那个虽细微但至关重要的ABI违规行为，从而体会到精确遵守调用惯例的重要性。",
            "id": "3664382",
            "problem": "一个程序是为 x86-64 System V 应用程序二进制接口 (ABI) 手工优化的汇编代码编写的。调用约定保证，在执行 `call` 指令之前，栈指针 `RSP` 会对齐到 $16$ 字节边界。一个 `push` 指令会使 `RSP` 减少 $8$ 字节，并存储一个 $64$ 位的值。`call` 指令会将 $8$ 字节的返回地址压栈，同样使 `RSP` 减少 $8$ 字节。被调用者使用高级向量扩展 (Advanced Vector Extensions, AVX) 的对齐加载指令 `vmovaps` 操作一个 `YMM` 寄存器，该指令要求内存地址是 $32$ 字节对齐的；如果操作数地址不是 $32$ 字节对齐的，`vmovaps` 会引发一个错误。\n\n考虑以下场景。一个调用者函数使用 `push` 在栈上准备了三个参数，然后调用了被调用者 `foo`：\n\n- 调用者（伪汇编）：\n  - `push rdi`  ; 参数 1, 8 字节\n  - `push rsi`  ; 参数 2, 8 字节\n  - `push rdx`  ; 参数 3, 8 字节\n  - `call foo`\n\n- 被调用者 `foo`（伪汇编）：\n  - `push rbp`\n  - `mov rbp, rsp`\n  - `sub rsp, 96`  ; 分配局部变量；$96 = 3 \\cdot 32$\n  - `vmovaps ymm0, [rsp + 32]`  ; 对齐的 32 字节加载到 `YMM0`\n\n在某些运行中，`vmovaps` 在从 `[rsp + 32]` 加载时会出错。请仅使用上述基本规则（ABI 调用前的 $16$ 字节对齐、`push` 和 `call` 对 `RSP` 的影响，以及 AVX 对齐加载的要求），从第一性原理出发进行推理，以追溯未对齐的根源，并确定对齐保证在何处被违反。\n\n哪个选项最准确地指出了违反了对齐保证的步骤，并解释了错误发生的原因？\n\nA. 被调用者的 `sub rsp, 96` 应该减去一个 64 的倍数；使用 96 未能保持 32 字节对齐，并导致了错误。\n\nB. 被调用者使用 `vmovaps` 而不是 `vmovups` 违反了 ABI；无论是否对齐，`vmovaps` 总是有出错的风险，因此指令的选择是根本原因。\n\nC. 调用者压入了奇数个 8 字节参数，并且在调用前未能将 `RSP` 重新对齐到 16 字节边界，这破坏了 ABI 保证，并导致被调用者中的局部缓冲区未对齐。\n\nD. `call` 指令本身无条件地破坏了被调用者中的栈对齐；因此任何从栈进行的对齐加载都是不安全的，该错误不可避免。\n\nE. 操作系统的对齐检查标志导致了对齐异常；栈对齐规则与观察到的 `vmovaps` 错误无关。",
            "solution": "该问题要求根据 x86-64 System V ABI 对栈指针的对齐情况进行分析，以确定在一次对齐内存访问中发生错误的原因。\n\n### 步骤 1：问题验证\n\n第一步是验证问题陈述。\n\n#### 提取的已知条件\n1.  **平台/ABI**：x86-64 System V 应用程序二进制接口 (ABI)。\n2.  **调用前对齐规则**：在 `call` 指令之前，栈指针 `RSP` 对齐到 $16$ 字节边界。\n3.  **`push` 指令语义**：`push` 指令使 `RSP` 减少 $8$ 字节。\n4.  **`call` 指令语义**：`call` 指令将一个 $8$ 字节的返回地址压栈，使 `RSP` 减少 $8$ 字节。\n5.  **AVX 指令要求**：使用 `YMM` 寄存器的 `vmovaps` 指令要求其内存操作数地址是 $32$ 字节对齐的。如果不满足此条件，则会发生错误。\n6.  **调用者代码**：调用者执行 `push rdi`、`push rsi`、`push rdx`，然后 `call foo`。\n7.  **被调用者代码**：被调用者 `foo` 执行 `push rbp`、`mov rbp, rsp`、`sub rsp, 96`，然后 `vmovaps ymm0, [rsp + 32]`。\n8.  **观察**：`vmovaps` 指令在某些运行中会出错。\n9.  **问题**：确定违反了对齐保证的步骤，并解释错误的原因。\n\n#### 验证结论\n- **科学依据充分**：该问题基于 x86-64 架构、System V ABI 和 AVX 指令集要求的公认且准确的原则。所有关于指令语义和对齐的陈述在事实上都是正确的。\n- **定义明确**：该问题提供了足够的信息来追踪栈指针 `RSP` 的状态并确定失败点。可以从逻辑上推导出对齐违规的唯一原因。\n- **客观**：该问题以精确的技术语言陈述，没有主观因素。\n\n问题陈述内部一致、科学合理且定义明确。没有发现任何缺陷。我们可以继续进行解答。\n\n### 步骤 2：解决方案推导\n\n我们将根据提供的规则，通过追踪从调用者到被调用者的执行流程来分析栈指针 `RSP` 的状态。\n\n**对调用者的分析：**\n\nSystem V ABI 对调用者施加了一个契约。所提供的主要规则是，在 `call` 指令之前，`RSP` 必须对齐到 $16$ 字节边界。这意味着此时 `RSP mod 16 = 0`。\n\n让我们分析调用者的行为。调用者通过将三个 $64$ 位参数压入栈中来为调用 `foo` 做准备。\n- `push rdi`：`RSP` 减少 $8$ 字节。\n- `push rsi`：`RSP` 减少 $8$ 字节。\n- `push rdx`：`RSP` 减少 $8$ 字节。\n\n这三个 `push` 指令导致 `RSP` 的总变化为 $3 \\times 8 = 24$ 字节。\n\n一个合规的函数通常在其函数体内为其自身的局部变量以及在为后续调用做准备之前，始终保持一个 $16$ 字节对齐的栈指针。我们假设在调用者开始为 `foo` 推入参数之前，其 `RSP` 是对齐到 $16$ 字节边界的。设这个值为 `RSP_start`，其中对于某个整数 $k$，有 `RSP_start` $= 16k$。\n\n三次 push 操作后，新的栈指针值 `RSP_pre_call` 将是：\n$$RSP_{pre\\_call} = RSP_{start} - 24 = 16k - 24$$\n我们可以分析这个地址的对齐情况：\n$$RSP_{pre\\_call} \\pmod{16} = (16k - 24) \\pmod{16} = (-24) \\pmod{16} = (-16 - 8) \\pmod{16} = -8 \\pmod{16} = 8$$\n因此，在 `call foo` 指令执行前，`RSP` 的值形式为 $16m + 8$。这**没有**对齐到 $16$ 字节边界。\n\n**关于违规的结论**：调用者违反了 ABI 保证。通过压入奇数个（3个）8 字节值，它使得栈相对于所需的 16 字节边界错位了 8 字节。一个合规的调用者应该压入偶数个四字（quadwords）或者添加填充（例如，通过执行 `sub rsp, 8`）来在 `call` 之前恢复 16 字节对齐。所示的调用者代码是有缺陷的。\n\n**对被调用者（`foo`）的分析：**\n\n现在，让我们追踪这个违规对被调用者 `foo` 造成的后果。\n1.  **`call` 之前的状态**：如前所述，`RSP` 未对齐：`RSP_pre_call` $= 16k + 8$。\n2.  **`call foo` 执行**：`call` 指令将 8 字节的返回地址压栈。`foo` 入口处的 `RSP`（记为 `RSP_entry`）变为：\n    $$RSP_{entry} = RSP_{pre\\_call} - 8 = (16k + 8) - 8 = 16k$$\n    由于调用者的错误，被调用者入口处的 `RSP` 出乎意料地是 16 字节对齐的，而 ABI 规定它应该是 $16n + 8$ 的形式。\n\n3.  **被调用者序言**：\n    - `push rbp`：被调用者保存旧的基址指针。`RSP` 变为 $16k - 8$。\n    - `mov rbp, rsp`：新的帧指针 `RBP` 被设置为 $16k - 8$。\n    - `sub rsp, 96`：被调用者为局部变量分配 96 字节。新的 `RSP` 是：\n      $$RSP_{final} = (16k - 8) - 96 = 16k - 104$$\n      让我们分析 `RSP_final` 的对齐情况：\n      $$RSP_{final} = 16k - (6 \\times 16 + 8) = 16(k-6) - 8$$\n      现在栈指针相对于 16 字节边界错位了 8 字节。\n\n4.  **`vmovaps` 指令**：被调用者尝试执行一个 32 字节对齐的加载。\n    - 指令是 `vmovaps ymm0, [rsp + 32]`。\n    - 正在访问的内存地址是 `RSP_final` $+ 32$。\n    - 地址 = $(16(k-6) - 8) + 32 = 16(k-6) + 24$。\n    - 让我们分析此地址相对于所需的 32 字节的对齐情况：\n      地址 $= 16(k-6) + 24 = 16(k-6+1) + 8 = 16(k-5) + 8$。\n    - 一个形式为 $16j+8$ 的地址永远不能被 16 整除，更不用说 32 了。它不是 32 字节对齐的。因此，`vmovaps` 指令将可靠地引发错误。\n\n**与“在某些运行中”的说法相协调**：上述推导表明，如果调用者从一个 16 字节对齐的栈开始，错误是确定性的。“在某些运行中”这个短语暗示了可变性。这可以解释为，如果调用者的栈在调用序列之前*并非*总是 16 字节对齐的（例如，如果调用者本身没有完全合规，或者它自己的栈帧设置有所不同）。如果调用者的栈在三次 push 之前碰巧已经错位了 8 字节（`16k+8`），那么三次 push 会减去 24 字节，得到 `(16k+8) - 24 = 16k-16`，这*是* 16 字节对齐的。在这种情况下，追踪过程会不同，`foo` 中的错误将取决于 `k` 的奇偶性。然而，这种脆弱性和非健壮性的根源在于调用者的代码，它未能在标准、预期的条件下为调用正确准备栈对齐。违规发生在调用者身上。\n\n### 步骤 3：逐项分析选项\n\n**A. 被调用者的 `sub rsp, 96` 应该减去一个 64 的倍数；使用 96 未能保持 32 字节对齐，并导致了错误。**\n- **分析**：值 $96$ 是 $6 \\times 16$，所以它正确地保持了在 `push rbp` 之后（假设是标准的 ABI 入口）重新建立的 16 字节对齐。被调用者没有义务保持 `RSP` 本身的 32 字节对齐，而是要确保其加载地址是对齐的。根本问题在于减法操作*之前*栈帧的对齐，这超出了被调用者的控制范围，并取决于调用者。将 96 更改为另一个 16 的倍数（如 64）也无法解决根本问题。\n- **结论**：**不正确**。\n\n**B. 被调用者使用 `vmovaps` 而不是 `vmovups` 违反了 ABI；无论是否对齐，`vmovaps` 总是有出错的风险，因此指令的选择是根本原因。**\n- **分析**：这在事实上是错误的。`vmovaps` 并非“总是有出错的风险”；它仅在其内存操作数未按要求对齐时才会出错。使用对齐的移动指令是一种有效的优化策略，并不违反 ABI。错误来自于未能满足指令文档中记录的对齐先决条件，而不是选择指令本身。未对齐版本 `vmovups` 可以避免此错误，但通常速度较慢。\n- **结论**：**不正确**。\n\n**C. 调用者压入了奇数个 8 字节参数，并且在调用前未能将 `RSP` 重新对齐到 16 字节边界，这破坏了 ABI 保证，并导致被调用者中的局部缓冲区未对齐。**\n- **分析**：此选项正确地指出了根本性缺陷。调用者压入了 3 个参数，总计 24 字节。从一个 16 字节对齐的栈开始，这导致 `RSP` 在 `call` 之前错位了 8 字节。此行为直接违反了指定的 ABI 保证。如上文推导，这个最初的违规会传播到被调用者的栈帧设置中，导致 `vmovaps` 加载的地址未对齐，从而引发错误。\n- **结论**：**正确**。\n\n**D. `call` 指令本身无条件地破坏了被调用者中的栈对齐；因此任何从栈进行的对齐加载都是不安全的，该错误不可避免。**\n- **分析**：`call` 指令将 `RSP` 从 `16n` 更改为 `16n - 8`（或 `16(n-1)+8`）。这是定义的行为，不是“破坏”对齐。ABI 就是围绕此行为构建的，并且期望被调用者处理它。例如，紧随其后的 `push rbp` 会恢复 16 字节对齐。如果被调用者根据 ABI 规则正确管理其栈帧，那么对齐加载是完全安全的。\n- **结论**：**不正确**。\n\n**E. 操作系统的对齐检查标志导致了对齐异常；栈对齐规则与观察到的 `vmovaps` 错误无关。**\n- **分析**：由未对齐的 `vmovaps` 引起的错误是 CPU 核心自身生成的通用保护故障（#GP）。操作系统级别的 `EFLAGS` 寄存器中的对齐检查（AC）标志控制着对其他旧指令的对齐检查，并非此处的原因。该错误直接且根本上与 CPU 执行 AVX 指令的对齐要求有关，而这又取决于 ABI 的栈对齐规则。\n- **结论**：**不正确**。",
            "answer": "$$\\boxed{C}$$"
        },
        {
            "introduction": "掌握了栈帧大小和正确性的概念后，让我们进一步探索性能维度。ABI规则并非凭空制定，其设计往往深思熟虑地考虑了硬件性能。本练习将深入探讨Windows x64 ABI中的一个特性——“影子空间”，并分析它与CPU缓存的交互。通过计算由此产生的内存流量，你将看到一个高层次的软件约定如何对底层硬件性能产生具体且时而出人意料的影响。",
            "id": "3664388",
            "problem": "考虑 Microsoft Windows x86-64 调用约定所使用的应用程序二进制接口 (ABI)，该 ABI 要求每个调用者在执行调用指令之前，在其栈帧上保留一个 $32$ 字节的“影子空间”（也称为“主目录空间”）。该空间可供被调用者用于溢出四个通过寄存器传递的参数。请分析一个对叶函数进行 $N$ 次调用的紧凑循环。假设关于常见微架构和编译器，存在以下经过充分测试的事实：\n\n- 在每次调用中，被调用者都精确地向影子空间执行四次 $8$ 字节的存储操作（溢出寄存器参数），并且从不重新加载它们。\n- 中央处理器 (CPU) 使用一个写回、写分配的高速缓存层次结构，其一级数据缓存 (L1D) 的容量为 $32$ KiB，行大小为 $64$ 字节，并具有足够的相联度，以确保包含影子空间的缓存行在循环期间绝不会被逐出。\n- 对于此调用点，影子空间完全位于单个 $64$ 字节的缓存行内，并映射到一个在循环体中不被其他访问竞争的集合。\n- 除了这些对影子空间的存储操作外，循环体的工作集不会在 $N$ 次调用期间强制逐出包含影子空间的缓存行。\n\n从这些关于调用约定和缓存行为（存储未命中时进行写分配所有权读取，逐出时进行写回）的基本定义和事实出发，请从第一性原理推导出，在 $N$ 次调用中，L1D 与下一级缓存之间完全因使用 $32$ 字节影子空间而产生的额外数据传输总字节数。然后，计算当 $N = 10^{6}$ 时此量的值，并以字节为单位表示您的最终答案。在最终的方框答案中不要包含任何单位。无需四舍五入。",
            "solution": "用户希望在特定的硬件和 ABI 模型下，确定在一个包含 $N$ 次函数调用的循环中，由影子空间的使用所引起的、在一级数据缓存 (L1D) 与下一级存储之间的数据传输总量。\n\n该问题要求基于给定的缓存架构和程序行为规范进行第一性原理分析。关键规范如下：\n1.  缓存策略：**写回 (write-back)** 和 **写分配 (write-allocate)**。\n2.  L1D 缓存行大小：$64$ 字节。\n3.  影子空间大小：$32$ 字节。\n4.  被调用者操作：每次调用向影子空间执行四次 $8$ 字节的存储。\n5.  硬件保证：$32$ 字节的影子空间包含在单个 $64$ 字节的缓存行内，并且在 $N$ 次调用期间，该缓存行不会从 L1D 缓存中被逐出。\n\n让我们来分析内存操作序列及其导致的缓存行为。\n\n**1. 第一次调用分析 ($n=1$)**\n\n我们从调用者栈帧的冷缓存这一前提开始，这意味着包含影子空间的缓存行最初不在 L1D 中。\n\n- **首次存储操作：** 当被调用者首次向影子空间执行存储操作时，CPU 检测到相应的缓存行不在 L1D 中。此事件是一次**写未命中 (write miss)**。\n\n- **写分配策略：** 指定的 `write-allocate` 策略规定了对写未命中的响应。CPU 必须首先将整个缓存行从下一级存储（例如 L2 缓存）取到 L1D 中，然后才能继续执行写操作。此操作是一次**所有权读取 (Read-For-Ownership, RFO)**，因为缓存正在获取该行并意图修改它。\n  - **入站数据传输：** 这次 RFO 导致一次数据*传入* L1D。传输量为一个缓存行的大小。\n  - 传入传输量 (Transfer$_{in}$) = $64$ 字节。\n\n- **RFO 之后的状态：** 在 $64$ 字节的缓存行加载后，存储操作完成，L1D 中该行的状态变为**已修改 (Modified)**（或“脏”），因为其内容现在与下一级存储不一致。\n\n- **第一次调用中的剩余存储：** 第一次调用中后续的三次 $8$ 字节存储现在都是**写命中 (write hits)**，因为该行已驻留在 L1D 中。根据 `write-back` 策略，这些命中只更新 L1D 内的缓存行，不产生任何到下一级存储的流量。\n\n**2. 后续调用分析 ($n=2, ..., N$)**\n\n- **调用开始时的缓存状态：** 问题提供了一个关键保证：“包含影子空间的缓存行在循环期间绝不会被逐出”。这意味着从第二次 ($n=2$) 到最后一次 ($n=N$) 的每次后续调用，该缓存行都已存在于 L1D 中，并保持 `Modified` 状态。\n\n- **所有存储均为写命中：** 对于这 $N-1$ 次调用中的每一次，所有四次对影子空间的 $8$ 字节存储都是**写命中**。\n\n- **写回策略：** 在写命中时，`write-back` 缓存不与下一级存储通信。它只是在 L1D 内部原地更新数据。因此，这 $N-1$ 次调用产生零额外 L1D 流量。\n\n**3. 循环后行为分析**\n\n- **最终状态：** 在 $N$ 次调用的循环完成后，包含影子空间的缓存行仍然以 `Modified` 状态驻留在 L1D 中。\n\n- **逐出和写回：** 不被逐出的保证仅在循环*期间*适用。最终，这个缓存行将被逐出，可能是在调用函数返回、其栈被清退时，也可能是后续代码需要该缓存资源时。由于该行处于 `Modified` 状态，`write-back` 策略强制要求其内容必须被写回到下一级存储，以确保数据一致性。\n  - **出站数据传输：** 这个写回操作导致一次数据*传出* L1D。传输量同样为一个缓存行的大小。\n  - 传出传输量 (Transfer$_{out}$) = $64$ 字节。\n\n**4. 总数据传输量计算**\n\nL1D 与下一级存储之间传输的总字节数是初始写未命中导致的入站传输与最终写回导致的出站传输之和。\n\n$$ \\text{总传输量} = \\text{传入传输量} + \\text{传出传输量} $$\n$$ \\text{总传输量} = 64 \\text{ 字节 (RFO)} + 64 \\text{ 字节 (写回)} $$\n$$ \\text{总传输量} = 128 \\text{ 字节} $$\n\n这个结果与调用次数 $N$ 无关，只要 $N \\ge 1$。问题给出的 $N = 10^6$ 值旨在强调重复的命中不会产生流量，这是写回缓存处理一个可写的热工作集时的基本属性。仅有的传输发生在初始加载和最终存储该缓存行时。\n\n因此，对于 $N = 10^6$，传输的额外总字节数为 $128$。",
            "answer": "$$\\boxed{128}$$"
        }
    ]
}