{
    "hands_on_practices": [
        {
            "introduction": "许多计算任务都涉及一系列操作。如果将这些操作实现在一个单一、庞大的组合逻辑块中，那么系统的时钟频率将受到这条最长路径延迟的限制。本练习将通过一个具体案例，阐明流水线技术的核心思想：通过插入寄存器，将长路径分割成多个更短的阶段，从而显著提高时钟频率和系统吞吐量，尽管单个操作的完成时间（即延迟）会有所增加。通过这个练习 ，您将巩固对同步时序约束的理解，包括寄存器延迟和时钟偏斜等实际因素。",
            "id": "3628087",
            "problem": "一个同步累加器单元中的数据路径通过级联三个 $64$ 位加法器模块来对四个 $64$ 位操作数求和，这些加法器模块使用互补金属氧化物半导体（CMOS）逻辑实现。在其原始形式中，该设计在输入寄存器和输出寄存器之间是纯组合逻辑：三个加法器通过两个加法器间的互连段串联，加法器之间没有寄存器。您的任务是通过插入中间寄存器将这个长组合逻辑路径重构为一个时序流水线，使得每个加法器位于其自己的流水线阶段。该设备使用具有指定时序特性的上升沿触发D触发器（DFF）。\n\n假设在目标工艺和电压下，测得以下最坏情况延迟和寄存器参数：\n- 每个 $64$ 位加法器的最坏情况传播延迟为 $1.80 \\, \\text{ns}$。\n- 每个加法器间的互连段会产生额外的 $0.20 \\, \\text{ns}$ 的最坏情况传播延迟。\n- 每个D触发器的时钟到Q端延迟为 $0.08 \\, \\text{ns}$，建立时间为 $0.12 \\, \\text{ns}$。\n- 从启动寄存器到捕获寄存器的路径上的最坏情况时钟偏斜为 $0.05 \\, \\text{ns}$。\n- 保持时间约束已通过现有缓冲满足，可以忽略。\n\n您在三个加法器模块之间插入两个中间寄存器，以便重构后的流水线有三个阶段，每个阶段包含一个加法器及其紧随的互连部分。假设重构后每个阶段的互连延迟保持为 $0.20 \\, \\text{ns}$，并且寄存器参数和时钟偏斜适用于每个阶段。\n\n从第一性原理出发，使用组合逻辑与时序逻辑的定义以及同步流水线的时序约束，确定重构后流水线的延迟和吞吐率。报告：\n- 流水线延迟，以周期为单位（周期的整数）。\n- 最大稳态吞吐率，以每秒操作次数为单位，用科学记数法表示。\n\n将吞吐率四舍五入到四位有效数字。吞吐率以每秒操作次数表示。此问题不涉及角度单位。",
            "solution": "该问题要求计算同步数字流水线的延迟和吞吐率。分析从精确定义这两个性能指标以及同步电路的基本时序约束开始。\n\n同步流水线是由多个阶段组成的顺序电路，这些阶段由寄存器（在本例中为D触发器或DFF）分隔。状态转换由全局时钟信号同步。\n\n**1. 流水线延迟**\n\n延迟是单个操作从输入传播到输出，贯穿整个流水线所需的总时间。在一个有 $N$ 个阶段的流水线中，一个操作需要一个时钟周期来被每个阶段处理，并将其结果锁存到后续的寄存器中。因此，该操作的最终结果在 $N$ 个完整的时钟周期后，在最后一个阶段的输出端可用。\n\n问题陈述，通过插入中间寄存器，将原来由三个加法器组成的组合路径重构为一个时序流水线，使得“每个加法器位于其自己的流水线阶段”。这样就创建了一个三阶段的流水线。\n\n设 $N$ 为流水线阶段的数量。\n$$N = 3$$\n因此，以时钟周期测量的延迟 $L$ 等于阶段的数量。\n$$L = N = 3 \\, \\text{cycles}$$\n\n**2. 流水线吞吐率**\n\n吞吐率是流水线在稳态下完成操作的速率。一旦流水线满载（即每个阶段都在处理一个不同的操作），每个时钟的上升沿都会在输出端产生一个新的结果。因此，吞吐率 $\\Theta$ 是最小可能时钟周期 $T_{\\text{min}}$ 的倒数。\n\n$$\\Theta = \\frac{1}{T_{\\text{min}}}$$\n\n最小的时钟周期由流水线中最慢（延迟最长）的阶段的时序约束决定。对于一个从启动寄存器到捕获寄存器的同步路径，时钟周期 $T_{\\text{clk}}$ 必须足够长，以允许数据从启动寄存器的输出传播，经过组合逻辑，并在下一个时钟沿到达之前，在捕获寄存器的输入端稳定至少一个建立时间。这个关系，被称为建立时间约束，由以下不等式给出：\n\n$$T_{\\text{clk}} \\ge t_{\\text{clk-q}} + t_{\\text{comb}} + t_{\\text{setup}} + t_{\\text{skew}}$$\n\n其中：\n- $t_{\\text{clk-q}}$ 是启动寄存器的时钟到Q端延迟。\n- $t_{\\text{comb}}$ 是单个流水线阶段内组合逻辑的最坏情况传播延迟。\n- $t_{\\text{setup}}$ 是捕获寄存器的建立时间要求。\n- $t_{\\text{skew}}$ 是启动寄存器和捕获寄存器之间的最坏情况时钟偏斜。\n\n为了找到最大吞吐率，我们必须计算最小的时钟周期 $T_{\\text{min}}$，这是满足该不等式的 $T_{\\text{clk}}$ 的最小值。\n\n$$T_{\\text{min}} = t_{\\text{clk-q}} + t_{\\text{comb}} + t_{\\text{setup}} + t_{\\text{skew}}$$\n\n首先，我们确定每个阶段的组合延迟 $t_{\\text{comb}}$。问题陈述，重构后的流水线阶段“每个包含一个加法器及其紧随的互连部分”，并且“每个阶段的互连延迟保持为 $0.20 \\, \\text{ns}$”。这为每个阶段建立了一个统一的组合延迟，即加法器延迟和互连延迟之和。\n\n给定的值为：\n- 加法器传播延迟, $t_{\\text{adder}} = 1.80 \\, \\text{ns}$。\n- 互连传播延迟, $t_{\\text{interconnect}} = 0.20 \\, \\text{ns}$。\n\n所以，每个阶段的组合延迟为：\n$$t_{\\text{comb}} = t_{\\text{adder}} + t_{\\text{interconnect}} = 1.80 \\, \\text{ns} + 0.20 \\, \\text{ns} = 2.00 \\, \\text{ns}$$\n\n接下来，我们将所有给定的时序参数代入 $T_{\\text{min}}$ 的方程中：\n- D触发器时钟到Q端延迟, $t_{\\text{clk-q}} = 0.08 \\, \\text{ns}$。\n- D触发器建立时间, $t_{\\text{setup}} = 0.12 \\, \\text{ns}$。\n- 最坏情况时钟偏斜, $t_{\\text{skew}} = 0.05 \\, \\text{ns}$。\n\n$$T_{\\text{min}} = 0.08 \\, \\text{ns} + 2.00 \\, \\text{ns} + 0.12 \\, \\text{ns} + 0.05 \\, \\text{ns}$$\n$$T_{\\text{min}} = 2.25 \\, \\text{ns}$$\n\n这是流水线能够可靠运行的最小的时钟周期。最大稳态吞吐率是该周期的倒数。\n\n$$\\Theta = \\frac{1}{T_{\\text{min}}} = \\frac{1}{2.25 \\, \\text{ns}} = \\frac{1}{2.25 \\times 10^{-9} \\, \\text{s}}$$\n$$\\Theta = \\frac{4}{9} \\times 10^9 \\, \\frac{\\text{operations}}{\\text{s}} \\approx 0.44444... \\times 10^9 \\, \\frac{\\text{operations}}{\\text{s}}$$\n按要求用科学记数法表示并四舍五入到四位有效数字：\n$$\\Theta \\approx 4.444 \\times 10^8 \\, \\frac{\\text{operations}}{\\text{s}}$$\n\n所需的两个量是延迟（以周期为单位）和最大吞吐率（以每秒操作次数为单位）。\n- 延迟：$3$ 周期。\n- 吞吐率：$4.444 \\times 10^8$ 次操作/秒。",
            "answer": "$$\\boxed{\\begin{pmatrix} 3 & 4.444 \\times 10^{8} \\end{pmatrix}}$$"
        },
        {
            "introduction": "在掌握了流水线的基本概念之后，我们来探讨一个经典的微架构权衡问题。更深的流水线通常能支持更高的时钟频率，这似乎意味着更高的性能。然而，它也加大了分支预测错误等事件的代价，因为这些事件需要清空整个流水线。本练习  要求您定量分析两种不同的CPU设计，并理解最优选择如何依赖于工作负载的特性（具体来说是分支预测错误率）。您将学会区分批处理吞吐量和单请求响应时间这两个关键且时常相互冲突的性能指标。",
            "id": "3673527",
            "problem": "一个微架构团队正在比较两种顺序执行中央处理器 (CPU) 设计，这两种设计用于一个延迟敏感型服务，该服务偶尔会以批处理模式运行。设计A使用一个 $20$ 级流水线，时钟频率为 $f_1 = 3.3 \\text{ GHz}$，分支预测错误惩罚为 $P_1 = 20$ 个周期。设计B使用一个 $12$ 级流水线，时钟频率为 $f_2 = 3.0 \\text{ GHz}$，分支预测错误惩罚为 $P_2 = 10$ 个周期。对于两种设计，假设基础开销为每条指令一个周期（无缓存未命中或其他停顿），具有完美的转发机制，并且对于设计 $i \\in \\{1,2\\}$，一次分支预测错误会额外导致 $P_i$ 个周期的停顿。\n\n考虑一个工作负载，其中单个请求由 $L = 100$ 条顺序指令组成，包含一个条件分支，该分支在每个请求中执行一次。分支预测器以概率 $p \\in [0,1]$ 错误预测该分支，且每次请求的预测是独立的。一个大批量由 $T \\gg 1$ 个背靠背执行的独立请求组成；在批处理规模下，请求之间的流水线填充和排空开销可以忽略不计。\n\n仅使用以下基本定义：\n- 吞吐率是单位时间内完成的请求数，等于CPU频率除以大批量稳态下每个请求的期望周期数。\n- 单请求响应时间是完成一个孤立请求的时间，等于该请求的期望周期数除以CPU频率。对于一个在 $D_i$ 级流水线上的孤立请求，需要包括 $D_i - 1$ 个周期的流水线填充开销。\n\n设 $D_1 = 20$ 和 $D_2 = 12$ 分别表示设计A和设计B的流水线深度。请从第一性原理出发，推导设计A的批处理吞吐率严格高于设计B，同时其单请求响应时间也严格长于设计B的条件（作为 $p$ 的函数）。然后，确定使这两个条件同时成立的最小预测错误概率 $p^{\\star} \\in [0,1]$。将你的最终答案 $p^{\\star}$ 表示为最简精确分数。最终答案中不要包含单位。",
            "solution": "问题陈述已经过严格验证，被认为是有效的。它在科学上基于计算机体系结构原理，定义良好，提供了所有必要的参数和定义，并且措辞客观。数据是一致的，该任务可以形式化为一组可解的数学不等式。因此，我们可以着手求解。\n\n问题要求我们找出最小的分支预测错误概率 $p^{\\star}$，使得设计A的批处理吞吐率严格高于设计B，同时其单请求响应时间也严格长于设计B。我们将为每种设计推导这两个性能指标的表达式，建立两个不等式，并求解概率 $p$。\n\n设下标 $i \\in \\{1, 2\\}$ 分别代表设计A和设计B。给定的参数如下：\n- 流水线深度: $D_1 = 20$, $D_2 = 12$\n- 时钟频率: $f_1 = 3.3 \\text{ GHz}$, $f_2 = 3.0 \\text{ GHz}$\n- 分支预测错误惩罚: $P_1 = 20$ 个周期, $P_2 = 10$ 个周期\n- 每个请求的指令数: $L = 100$\n\n首先，我们确定执行单个请求中指令所需的期望周期数。一个请求包含 $L$ 条指令，在基础CPI为1的情况下需要 $L$ 个周期。每个请求有一个分支，以概率 $p$ 发生预测错误。一次预测错误会增加 $P_i$ 个停顿周期。因此，设计 $i$ 执行指令的期望周期数为：\n$$ C_{exec, i} = L + p \\cdot P_i + (1 - p) \\cdot 0 = L + p P_i $$\n\n接下来，我们根据提供的定义对两个所需的性能指标进行建模。\n\n**1. 批处理吞吐率**\n吞吐率 ($Th_i$) 定义为CPU频率除以大批量处理下每个请求的期望周期数。问题陈述中提到，对于大批量处理，流水线填充和排空的影响可以忽略不计。因此，每个请求的周期数就是执行周期数 $C_{exec, i}$。\n$$ Th_i = \\frac{f_i}{C_{exec, i}} = \\frac{f_i}{L + p P_i} $$\n第一个条件是设计A的吞吐率严格高于设计B：\n$$ Th_1 > Th_2 \\implies \\frac{f_1}{L + p P_1} > \\frac{f_2}{L + p P_2} $$\n由于 $L$、$P_i$ 和 $f_i$ 均为正数，且 $p \\ge 0$，所以分母始终为正。我们可以进行交叉相乘而不改变不等号的方向：\n$$ f_1 (L + p P_2) > f_2 (L + p P_1) $$\n$$ f_1 L + p f_1 P_2 > f_2 L + p f_2 P_1 $$\n$$ p (f_1 P_2 - f_2 P_1) > L (f_2 - f_1) $$\n让我们代入给定值： $f_1 = 3.3$, $f_2 = 3.0$, $P_1 = 20$, $P_2 = 10$ 和 $L = 100$。\n$p$ 的系数为 $f_1 P_2 - f_2 P_1 = (3.3)(10) - (3.0)(20) = 33 - 60 = -27$。\n右侧为 $L(f_2 - f_1) = 100(3.0 - 3.3) = 100(-0.3) = -30$。\n不等式变为：\n$$ -27p > -30 $$\n两边同除以 $-27$ 并反转不等号方向，得到：\n$$ p  \\frac{-30}{-27} \\implies p  \\frac{10}{9} $$\n由于预测错误概率 $p$ 定义在区间 $[0, 1]$ 内，条件 $p  \\frac{10}{9}$ 总是成立。因此，对于所有有效的 $p$ 值，设计A的吞吐率都高于设计B。\n\n**2. 单请求响应时间**\n单请求响应时间 ($RT_i$) 是完成一个孤立请求的时间。这包括 $D_i - 1$ 个周期的流水线填充开销。单个请求的总期望周期数 $C_{single, i}$ 为：\n$$ C_{single, i} = C_{exec, i} + (D_i - 1) = L + p P_i + D_i - 1 $$\n那么，设计 $i$ 的响应时间为：\n$$ RT_i = \\frac{C_{single, i}}{f_i} = \\frac{L + p P_i + D_i - 1}{f_i} $$\n第二个条件是设计A的响应时间严格长于设计B：\n$$ RT_1  RT_2 \\implies \\frac{L + p P_1 + D_1 - 1}{f_1}  \\frac{L + p P_2 + D_2 - 1}{f_2} $$\n由于频率是正数，我们可以交叉相乘：\n$$ f_2 (L + p P_1 + D_1 - 1)  f_1 (L + p P_2 + D_2 - 1) $$\n展开并按 $p$ 合并同类项：\n$$ p f_2 P_1 - p f_1 P_2  L(f_1 - f_2) + f_1(D_2 - 1) - f_2(D_1 - 1) $$\n$$ p (f_2 P_1 - f_1 P_2)  L(f_1 - f_2) + f_1(D_2 - 1) - f_2(D_1 - 1) $$\n让我们代入给定值： $D_1 = 20, D_2 = 12$。\n$p$ 的系数是 $f_2 P_1 - f_1 P_2 = (3.0)(20) - (3.3)(10) = 60 - 33 = 27$。\n右侧 (RHS) 是：\n$$ \\text{RHS} = 100(3.3 - 3.0) + 3.3(12 - 1) - 3.0(20 - 1) $$\n$$ \\text{RHS} = 100(0.3) + 3.3(11) - 3.0(19) $$\n$$ \\text{RHS} = 30 + 36.3 - 57 $$\n$$ \\text{RHS} = 66.3 - 57 = 9.3 $$\n不等式变为：\n$$ 27p  9.3 $$\n由于 $p$ 的系数是正数，在除法后不等式方向保持不变：\n$$ p  \\frac{9.3}{27} $$\n为了将其表示为精确分数，我们将 $9.3$ 写成 $\\frac{93}{10}$：\n$$ p  \\frac{93/10}{27} = \\frac{93}{270} $$\n分子和分母都可以被3整除：\n$$ p  \\frac{31}{90} $$\n数字 $31$ 是质数，所以这个分数是最简形式。\n\n**求 $p^{\\star}$**\n我们需要找到最小的概率 $p^{\\star} \\in [0, 1]$，使得两个条件同时成立。\n条件1: $p  \\frac{10}{9}$\n条件2: $p > \\frac{31}{90}$\n这些条件与定义域 $p \\in [0, 1]$ 的交集定义了 $p$ 的解集：\n$$ p \\in \\left(\\frac{31}{90}, 1\\right] $$\n问题要求找到使两个条件都成立的最小概率 $p^{\\star}$。由于不等式是严格的，解集中没有 $p$ 的最小值。因此，问题可以解释为求该集合的下确界（最大下界）。这个边界值是第二个条件从不成立变为成立的转换点。\n这个值就是区间的下界。\n$$ p^{\\star} = \\frac{31}{90} $$\n对于任何严格大于 $p^{\\star}$ (且小于等于 $1$) 的 $p$ 值，两个条件都将满足。",
            "answer": "$$\\boxed{\\frac{31}{90}}$$"
        },
        {
            "introduction": "流水线不仅适用于指令执行，现代处理器也运用同样“重叠操作”的原理来容忍长内存延迟。本练习通过一个思想实验，对比了两种不同的工作负载：一种是具有内在数据依赖性的“指针追逐”任务，另一种是包含大量独立内存加载的任务。通过这个对比 ，您将探索内存级别并行性（Memory-Level Parallelism, MLP）的概念，并理解为何乱序执行对于隐藏内存延迟、提升实际吞吐量至关重要。此练习突显了单个加载的响应时间与通过并行化实现的平均每个加载的摊销时间之间的关键区别。",
            "id": "3673535",
            "problem": "我们使用一个单路超标量乱序核心来研究数据依赖如何影响内存加载的响应时间和吞吐量。在实验期间，以下机器特性是相关的，并可假定为恒定：\n- 该核心最多可以追踪 $M=16$ 个从末级缓存到动态随机存取存储器（DRAM）的未完成缺失（miss），而不会阻塞前端。\n- 加载发射宽度为每个周期 $W_{\\mathrm{ld}}=2$ 次加载。\n- 每次 DRAM 访问的服务时间（延迟）约为 $D=200$ 个周期，从缺失发送到内存控制器到数据返回核心为止。\n- 时钟频率为 $f=3\\,\\mathrm{GHz}$。内存系统带宽足够高，在下面预测的并发水平下，它不是瓶颈。\n- 每次加载传输 $8\\,\\mathrm{B}$。\n\n设计了两个微基准测试来量化响应时间，并展示吞吐量何时以及为何能从增加内存级并行度（MLP）中受益。MLP 定义为在时间上重叠的独立内存操作的数量。\n\n- 依赖型基准测试（指针追逐）：在一个远大于末级缓存的数据区域上构建一个随机排列的单向链表。循环重复地从当前节点加载下一个指针，并将指针推进 $N$ 步，其中 $N$ 很大。因为每个地址只有在前一个加载完成后才能获得，所以存在一个单一的依赖链。\n- 独立型基准测试（多个独立加载）：准备 $K$ 个基地址，指向 $K$ 个独立的数组，这些数组的元素间隔设置使得访问在末级缓存中发生缺失，并映射到不同的存储体（bank）。在每次循环迭代中，向彼此独立的元素发出 $K$ 次加载，并推迟使用它们的值，直到所有 $K$ 次加载都已发出。选择 $K$ 的值，以在不超过硬件限制的情况下，尝试最大化 MLP。\n\n使用基本定义：响应时间是每次操作所经过的时间，吞吐量是单位时间内完成的操作数。假设两个基准测试中的所有访问都在私有缓存中缺失，并由延迟为上述 $D$ 的 DRAM 提供服务，并且重排序缓冲在其他方面不受限制。\n\n关于预期测量结果及其解释，以下哪些陈述是正确的？\n\nA. 在依赖型基准测试中，对于较大的 $N$，除了少量的循环开销外，平均每次加载的周期数趋近于 $D$。\n\nB. 在独立型基准测试中，当 $K \\ge M$ 时，稳态加载吞吐量趋近于每个周期 $M/D$ 次加载，因此以总周期数除以总加载数测得的平均每次加载的周期数趋近于 $D/M$。\n\nC. 将 $K$ 增加到超过 $M$ 会成比例地进一步减少测得的每次加载的周期数，因为更多的独立加载会无限制地增加 MLP。\n\nD. 如果修改依赖型基准测试，插入软件预取指令，尝试提前预取 $P=8$ 个节点，那么在完美预取的情况下，尽管指针链在概念上是依赖的，测得的每次加载的周期数也应接近 $D/M$。\n\nE. 如果独立型基准测试中 $K=8$ 且核心发射宽度为 $W_{\\mathrm{ld}}=2$，则平均每个加载的周期数更接近于 $D/K$（25个周期）而不是 $1/W_{\\mathrm{ld}}$（0.5个周期）。\n\nF. 在独立型基准测试中，如果 $K=256$，则测得的稳态加载吞吐量大约为 $6.4\\,\\mathrm{GB/s}$。\n\nG. 在独立型基准测试中，当 $K=256$ 时，单个加载的响应时间（从发射到数据返回的时间）仍然是 $D=200$ 个周期，但摊销的每次加载周期数（吞吐量的倒数）远低于依赖型基准测试。",
            "solution": "此问题探讨内存级并行（MLP）对内存系统性能的影响，并比较数据依赖和独立加载两种情况。我们将分析每个选项的正确性。\n\n问题的核心是理解延迟（D）、吞吐量（Throughput）和并发度（MLP）之间的关系，这可以通过利特尔定律的变体来描述：\n平均每次加载周期数 (CPL) = $1 / \\text{Throughput} = D / \\text{MLP}$\n系统的性能受到硬件限制：\n1. 最大并发缺失数: $\\text{MLP} \\le M = 16$\n2. 最大加载发射宽度: $\\text{Throughput} \\le W_{\\mathrm{ld}} = 2$ 加载/周期 (等价于 CPL $\\ge 0.5$)\n\n**A. 在依赖型基准测试中，对于较大的 $N$，除了少量的循环开销外，平均每次加载的周期数趋近于 $D$。**\n在指针追逐任务中，下一次加载的地址依赖于当前加载的结果。这种串行依赖性意味着处理器无法重叠执行多次加载。因此，任何时候只有一个内存访问在途，即 MLP = 1。平均每次加载的周期数 (CPL) 为 $D / \\text{MLP} = D / 1 = 200$。该陈述正确。\n\n**B. 在独立型基准测试中，当 $K \\ge M$ 时，稳态加载吞吐量趋近于每个周期 $M/D$ 次加载，因此以总周期数除以总加载数测得的平均每次加载的周期数趋近于 $D/M$。**\n当可用的独立加载数 $K$ 大于或等于硬件能追踪的最大缺失数 $M$ 时，处理器可以使内存并发资源饱和。此时，稳态 MLP 将达到其最大值 $M=16$。吞吐量为 $\\text{MLP}/D = M/D = 16/200 = 0.08$ 加载/周期。平均每次加载的周期数 CPL 是吞吐量的倒数，即 $D/M = 200/16 = 12.5$。该陈述正确。\n\n**C. 将 $K$ 增加到超过 $M$ 会成比例地进一步减少测得的每次加载的周期数，因为更多的独立加载会无限制地增加 MLP。**\n硬件明确限制了最大并发缺失数为 $M=16$。一旦达到这个限制，即使有再多的独立加载可用（$K > M$），处理器也必须暂停发射新的加载，直到一个旧的加载完成。因此，MLP 被限制在 $M$ 以下，吞吐量不会进一步提高，CPL 也不会进一步降低。声称 MLP 可以“无限制地”增加是错误的。该陈述不正确。\n\n**D. 如果修改依赖型基准测试，插入软件预取指令，尝试提前预取 $P=8$ 个节点，那么在完美预取的情况下，尽管指针链在概念上是依赖的，测得的每次加载的周期数也应接近 $D/M$。**\n对于单向链表，下一个节点的地址存储在当前节点中，因此无法通过标准软件预取指令来“超前”预取。这种依赖性是固有的。即使假设有一种特殊的硬件预取器可以实现 $P=8$ 的并行度，那么 CPL 将是 $D/P = 200/8 = 25$。陈述声称 CPL 接近 $D/M = 200/16 = 12.5$，这在数值上不符。该陈述不正确。\n\n**E. 如果独立型基准测试中 $K=8$ 且核心发射宽度为 $W_{\\mathrm{ld}}=2$，则平均每个加载的周期数更接近于 $D/K$（25个周期）而不是 $1/W_{\\mathrm{ld}}$（0.5个周期）。**\n在这种情况下，有 $K=8$ 个独立加载可用，小于硬件限制 $M=16$。因此，最大可达 MLP 为 8。这导致的 CPL 是 $D/K = 200/8 = 25$ 个周期。同时，核心的加载发射宽度为 2，这意味着发射端支持的最小 CPL 是 $1/W_{\\mathrm{ld}} = 0.5$ 个周期。由于实际的 CPL（25）远大于发射端限制（0.5），瓶颈在于内存延迟，而不是发射宽度。因此，测得的 CPL 将接近 25。该陈述正确。\n\n**F. 在独立型基准测试中，如果 $K=256$，则测得的稳态加载吞吐量大约为 $6.4\\,\\mathrm{GB/s}$。**\n当 $K=256$ 时，$K > M$，所以 MLP 被硬件限制在 $M=16$。\n吞吐量（加载/秒）= (加载/周期) $\\times$ 频率 = $(\\text{MLP}/D) \\times f = (16/200) \\times 3 \\times 10^9 = 0.08 \\times 3 \\times 10^9 = 0.24 \\times 10^9$ 次加载/秒。\n数据吞吐量（字节/秒）= (加载/秒) $\\times$ (字节/加载) = $0.24 \\times 10^9 \\times 8 = 1.92 \\times 10^9$ 字节/秒 = $1.92\\,\\mathrm{GB/s}$。\n这个值与陈述中的 $6.4\\,\\mathrm{GB/s}$ 不符。该陈述不正确。\n\n**G. 在独立型基准测试中，当 $K=256$ 时，单个加载的响应时间（从发射到数据返回的时间）仍然是 $D=200$ 个周期，但摊销的每次加载周期数（吞吐量的倒数）远低于依赖型基准测试。**\n这个陈述区分了“响应时间”（延迟）和“摊销时间”（吞吐量的倒数）。单个内存访问的物理延迟仍然是 $D=200$ 个周期。然而，由于并行处理了 $M=16$ 个加载，摊销的每次加载周期数是 $D/M = 12.5$。这个值远低于依赖型基准测试中的 CPL（$D=200$）。该陈述正确。\n\n综上所述，正确的陈述是 A、B、E 和 G。",
            "answer": "$$\\boxed{ABEG}$$"
        }
    ]
}