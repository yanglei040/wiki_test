{
    "hands_on_practices": [
        {
            "introduction": "要想评估处理器性能，首先必须掌握每指令周期数（CPI）的计算方法。平均CPI并非一个固定值，而是由程序执行的指令类型和各类型指令的执行成本共同决定的。本练习将通过一个具体的指令组合案例，引导你计算加权平均CPI，并进一步运用CPU性能公式求解总执行时间，为你后续更复杂的性能分析打下坚实的基础。",
            "id": "3631197",
            "problem": "一个简单的顺序微架构执行三类指令：算术逻辑单元操作（ALU）、加载/存储内存操作（LDST）和控制流分支操作（BR）。在一个长时间的程序运行中，观测到的指令混合比例为 $(\\alpha_{ALU}, \\alpha_{LDST}, \\alpha_{BR}) = (0.5, 0.3, 0.2)$。每类指令的每指令周期数分别为：ALU为$1$，LDST为$3$，BR为$5$。中央处理器（CPU）的时钟频率为 $f = 2.5$ GHz，程序的指令数（IC）为 $5 \\times 10^{8}$ 条指令。\n\n使用将长期平均值与概率加权期望相关联以及将周期速率与时间相关联的第一性原理，确定该程序的平均每指令周期数（CPI）和总执行时间 $T$。将平均CPI表示为纯数字，执行时间以秒为单位。提供精确值（不要四舍五入）。",
            "solution": "该问题被评估为有效，因为它在科学上基于计算机体系结构的原理，问题提出得当并提供了所有必要信息，且其表述是客观的。所提供的数据是自洽且符合实际的。\n\n核心任务是确定中央处理器（CPU）的两个关键性能指标：平均每指令周期数（$CPI_{\\text{avg}}$）和总程序执行时间（$T$）。解决方案是从第一性原理推导出来的。\n\n首先，我们计算程序的平均每指令周期数。平均$CPI$是各类指令$CPI$值的加权平均，权重是各自的指令混合比例。通用公式为：\n$$\nCPI_{\\text{avg}} = \\sum_{i} \\alpha_i \\cdot CPI_i\n$$\n其中 $\\alpha_i$ 是第 $i$ 类指令的比例，而 $CPI_i$ 是该类指令的每指令周期数。\n\n问题提供了以下数据：\n指令混合比例：$(\\alpha_{\\text{ALU}}, \\alpha_{\\text{LDST}}, \\alpha_{\\text{BR}}) = (0.5, 0.3, 0.2)$。\n每类指令的每指令周期数：$CPI_{\\text{ALU}} = 1$，$CPI_{\\text{LDST}} = 3$，以及 $CPI_{\\text{BR}} = 5$。\n\n将这些值代入加权平均公式：\n$$\nCPI_{\\text{avg}} = (\\alpha_{\\text{ALU}} \\cdot CPI_{\\text{ALU}}) + (\\alpha_{\\text{LDST}} \\cdot CPI_{\\text{LDST}}) + (\\alpha_{\\text{BR}} \\cdot CPI_{\\text{BR}})\n$$\n$$\nCPI_{\\text{avg}} = (0.5 \\cdot 1) + (0.3 \\cdot 3) + (0.2 \\cdot 5)\n$$\n对每一项进行乘法运算：\n$$\nCPI_{\\text{avg}} = 0.5 + 0.9 + 1.0\n$$\n将各项相加得到平均$CPI$：\n$$\nCPI_{\\text{avg}} = 2.4\n$$\n这个值代表了对于这个特定的程序和硬件，执行一条指令平均所需的时钟周期数。注意，指令比例的总和为 $\\alpha_{\\text{ALU}} + \\alpha_{\\text{LDST}} + \\alpha_{\\text{BR}} = 0.5 + 0.3 + 0.2 = 1.0$，这是一个完整指令混合的必要条件。\n\n其次，我们计算总执行时间 $T$。执行时间由执行程序所需的总周期数除以时钟频率确定。总周期数是总指令数（Instruction Count, $IC$）与平均每指令周期数（$CPI_{\\text{avg}}$）的乘积。基本的CPU性能公式是：\n$$\nT = \\frac{\\text{Total Cycles}}{\\text{Clock Frequency}} = \\frac{IC \\cdot CPI_{\\text{avg}}}{f}\n$$\n问题提供了以下附加数据：\n指令数：$IC = 5 \\times 10^8$ 条指令。\nCPU时钟频率：$f = 2.5 \\text{ GHz} = 2.5 \\times 10^9 \\text{ cycles per second (Hz)}$。\n\n我们将已知值代入性能公式：\n$$\nT = \\frac{(5 \\times 10^8) \\cdot 2.4}{2.5 \\times 10^9}\n$$\n我们可以通过重新排列各项来简化表达式：\n$$\nT = \\frac{5 \\cdot 2.4}{2.5} \\cdot \\frac{10^8}{10^9}\n$$\n首先，计算数值部分：\n$$\n\\frac{5 \\cdot 2.4}{2.5} = \\frac{12}{2.5} = \\frac{120}{25} = 4.8\n$$\n接着，计算 $10$ 的幂次部分：\n$$\n\\frac{10^8}{10^9} = 10^{8-9} = 10^{-1}\n$$\n将这些结果组合起来，得到总执行时间 $T$：\n$$\nT = 4.8 \\times 10^{-1} = 0.48 \\text{ seconds}\n$$\n或者，我们可以直接计算该分数：\n$$\nT = \\frac{1.2 \\times 10^9}{2.5 \\times 10^9} = \\frac{1.2}{2.5} = 0.48 \\text{ seconds}\n$$\n因此，平均每指令周期数是 $2.4$，总程序执行时间是 $0.48$ 秒。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 2.4 & 0.48 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "现代处理器通过流水线等技术实现了高吞吐率，但分支指令的错误预测会严重破坏流水线的效率，带来显著的性能惩罚。这个练习模拟了一个常见的优化场景：改进分支预测器。通过量化分支预测错误率的降低所带来的CPI变化（$\\Delta \\mathrm{CPI}$）和执行时间节省（$\\Delta T$），你将亲身体会到微体系结构层面的优化是如何直接转化为宏观性能提升的。",
            "id": "3631172",
            "problem": "一个团队正在优化中央处理器（CPU）的分支预测单元。考虑一个在单发射流水线上执行指令数量为 $1.5 \\times 10^{9}$ 条动态指令的程序。条件分支占动态指令流的比例为 $0.20$。优化前，每个条件分支的错误预测概率为 $0.08$；优化后，错误预测概率变为 $0.03$。每个错误预测的分支会产生一个固定的、完全串行化的 $12$ 个时钟周期的开销，且流水线或内存系统的其他方面没有变化。假设优化不会改变指令总数或正确预测和非分支指令的基本每指令周期数，并且开销不与有效工作重叠。\n\n该机器的时钟频率为每秒 $3.2 \\times 10^{9}$ 个周期。仅使用第一性原理，根据每指令周期数和执行时间的定义进行推理，推导出仅由分支错误预测行为改变引起的平均每指令周期数的变化量 $\\Delta \\mathrm{CPI}$，然后计算该程序总执行时间的相应变化量 $\\Delta T$。\n\n将 $\\Delta \\mathrm{CPI}$ 和 $\\Delta T$ 都四舍五入到四位有效数字。以秒为单位表示 $\\Delta T$。以 $\\left(\\Delta \\mathrm{CPI}, \\Delta T\\right)$ 的顺序提供两个数字作为你的最终答案。",
            "solution": "在尝试求解之前，对问题陈述进行验证。\n\n### 步骤 1：提取已知条件\n- 动态指令总数：$I_C = 1.5 \\times 10^{9}$\n- 条件分支的比例：$f_{branch} = 0.20$\n- 优化前的错误预测概率：$P_{mp, before} = 0.08$\n- 优化后的错误预测概率：$P_{mp, after} = 0.03$\n- 错误预测开销：$P_{penalty} = 12$ 个时钟周期\n- 时钟频率：$f_{clk} = 3.2 \\times 10^{9}$ 周期/秒\n- 优化不改变 $I_C$ 或基本每指令周期数 ($\\mathrm{CPI}_{base}$)。\n- 开销是固定的、完全串行化的，并且不与有效工作重叠。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据**：该问题很好地基于计算机体系结构和组织的原理。CPU性能方程以及每指令周期数（CPI）、分支预测和错误预测开销的概念是该领域的标准、基础课题。所提供的值是现实的。\n- **适定性**：该问题是适定的。它提供了所有必要的数据和约束来唯一确定CPI和执行时间的变化。问题是明确的。\n- **客观性**：语言是技术性的、精确的，并且不含主观内容。\n- **完整性和一致性**：该问题是自包含且内部一致的。假设，例如恒定的基本CPI和不重叠的开销，都被清晰地陈述，并用于定义一个可解的模型。\n- **可行性**：所有数值对于现代处理器而言在物理上和技术上都是合理的。\n\n### 步骤 3：结论与行动\n该问题有效。将从第一性原理推导出解决方案。\n\n程序的总执行时间 $T$ 由基本的CPU性能方程确定：\n$$T = I_C \\times \\mathrm{CPI} \\times T_{clk}$$\n其中 $I_C$ 是指令数，$\\mathrm{CPI}$ 是每条指令的平均时钟周期数，而 $T_{clk}$ 是时钟周期。时钟周期是时钟频率 $f_{clk}$ 的倒数，因此 $T_{clk} = 1/f_{clk}$。该方程可以重写为：\n$$T = \\frac{I_C \\times \\mathrm{CPI}}{f_{clk}}$$\n平均CPI是理想（或基本）CPI（$\\mathrm{CPI}_{base}$）与由流水线停頓和其他开销导致的额外CPI分量之和。在这个问题中，唯一变化的开销来源是分支错误预测。总CPI可以表示为：\n$$\\mathrm{CPI} = \\mathrm{CPI}_{base} + \\mathrm{CPI}_{penalty}$$\n开销分量 $\\mathrm{CPI}_{penalty}$ 是由于分支错误预测导致的每条指令的平均开销周期数。它的计算方法是确定总开销周期数，然后除以总指令数 $I_C$。\n\n分支指令的总数是 $I_C \\times f_{branch}$。\n错误预测的分支数是分支总数乘以错误预测概率 $P_{mp}$：\n$$\\text{Number of mispredictions} = I_C \\times f_{branch} \\times P_{mp}$$\n每次错误预测都会产生 $P_{penalty}$ 个周期的开销。总开销周期数为：\n$$\\text{Total penalty cycles} = (\\text{Number of mispredictions}) \\times P_{penalty} = I_C \\times f_{branch} \\times P_{mp} \\times P_{penalty}$$\n因此，此开销对CPI的贡献是：\n$$\\mathrm{CPI}_{penalty} = \\frac{\\text{Total penalty cycles}}{I_C} = \\frac{I_C \\times f_{branch} \\times P_{mp} \\times P_{penalty}}{I_C} = f_{branch} \\times P_{mp} \\times P_{penalty}$$\n问题要求的是由于优化引起的平均每指令周期数的变化量 $\\Delta \\mathrm{CPI}$。这是优化后的CPI与优化前的CPI之间的差值。\n$$\\mathrm{CPI}_{before} = \\mathrm{CPI}_{base} + f_{branch} \\times P_{mp, before} \\times P_{penalty}$$\n$$\\mathrm{CPI}_{after} = \\mathrm{CPI}_{base} + f_{branch} \\times P_{mp, after} \\times P_{penalty}$$\n变化量 $\\Delta \\mathrm{CPI}$ 是：\n$$\\Delta \\mathrm{CPI} = \\mathrm{CPI}_{after} - \\mathrm{CPI}_{before}$$\n$$\\Delta \\mathrm{CPI} = (\\mathrm{CPI}_{base} + f_{branch} \\times P_{mp, after} \\times P_{penalty}) - (\\mathrm{CPI}_{base} + f_{branch} \\times P_{mp, before} \\times P_{penalty})$$\n基本CPI，$\\mathrm{CPI}_{base}$，是恒定的并且被消掉了：\n$$\\Delta \\mathrm{CPI} = f_{branch} \\times P_{penalty} \\times (P_{mp, after} - P_{mp, before})$$\n代入给定值：\n$$\\Delta \\mathrm{CPI} = 0.20 \\times 12 \\times (0.03 - 0.08) = 2.4 \\times (-0.05) = -0.12$$\n问题要求将此值四舍五入到四位有效数字。\n$$\\Delta \\mathrm{CPI} = -0.1200$$\n负号正确地表示CPI的减少，这构成了性能提升。\n\n接下来，我们计算总执行时间的相应变化量 $\\Delta T$。\n$$\\Delta T = T_{after} - T_{before}$$\n使用执行时间公式 $T = (I_C \\times \\mathrm{CPI}) / f_{clk}$：\n$$\\Delta T = \\frac{I_C \\times \\mathrm{CPI}_{after}}{f_{clk}} - \\frac{I_C \\times \\mathrm{CPI}_{before}}{f_{clk}}$$\n将常数项 $I_C$ 和 $f_{clk}$ 提取出来：\n$$\\Delta T = \\frac{I_C}{f_{clk}} (\\mathrm{CPI}_{after} - \\mathrm{CPI}_{before}) = \\frac{I_C}{f_{clk}} \\Delta \\mathrm{CPI}$$\n代入已知值和先前计算的值：\n$$I_C = 1.5 \\times 10^9 \\text{ instructions}$$\n$$f_{clk} = 3.2 \\times 10^9 \\text{ cycles/second}$$\n$$\\Delta \\mathrm{CPI} = -0.12$$\n$$\\Delta T = \\frac{1.5 \\times 10^{9}}{3.2 \\times 10^{9}} \\times (-0.12) = \\frac{1.5}{3.2} \\times (-0.12)$$\n$$\\Delta T = 0.46875 \\times (-0.12) = -0.05625 \\text{ seconds}$$\n这个值正好有四位有效数字，因此不需要进一步的四舍五入。负号表示执行时间的减少。\n\n最终答案是 $\\Delta \\mathrm{CPI} = -0.1200$ 和 $\\Delta T = -0.05625$ 秒。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n-0.1200 & -0.05625\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "性能优化并非总是单向的改进，常常需要在多个相互关联的指标之间进行权衡。例如，通过代码重构或使用更复杂的指令，我们或许能减少总指令数（$IC$），但代价可能是平均每条指令需要更多的时钟周期（$CPI$）来执行。这个练习将带你分析这种典型的性能权衡场景，通过计算最终的性能缩放因子，你将学会如何综合评估不同优化策略的净效应。",
            "id": "3631477",
            "problem": "一个计算密集型应用程序运行在一个单发射顺序处理器上，其时钟周期在所有实验中保持不变。设程序的基准执行指令数 (IC) 为 $IC_{0}$，每指令周期数 (CPI) 为 $CPI_{0}$。一次代码重构使总指令数减少了 $\\Delta$ 的比例（因此新的指令数变为 $(1-\\Delta)IC_{0}$），但平均每指令周期数增加了一个附加量 $\\epsilon$（因此新的每指令周期数变为 $CPI_{0}+\\epsilon$）。假设除了所述的 $\\epsilon$ 变化外，处理器的时钟频率和微架构条件保持不变。\n\n对于一个具体实例，设 $IC_{0}=2.40\\times 10^{9}$，$CPI_{0}=1.20$，$\\Delta=0.18$，且 $\\epsilon=0.25$。确定性能缩放因子 $S$，其定义为基准执行时间与重构后执行时间之比。将最终结果表示为一个纯数（无单位）。将答案四舍五入到四位有效数字。",
            "solution": "分析始于基本的CPU性能方程，该方程将执行时间 ($T_{exec}$) 与指令数 ($IC$)、平均每指令周期数 ($CPI$) 以及时钟周期 ($T_{clk}$) 联系起来：\n$$T_{exec} = IC \\times CPI \\times T_{clk}$$\n时钟周期 $T_{clk}$ 是时钟频率的倒数，并且在本题中被设定为常数。\n\n令下标 $0$ 表示基准执行，下标 $1$ 表示代码重构后的执行。\n\n对于基准情况，执行时间 $T_0$ 由下式给出：\n$$T_0 = IC_0 \\times CPI_0 \\times T_{clk}$$\n此处，$IC_0$ 是初始指令数，$CPI_0$ 是初始平均每指令周期数。\n\n对于重构后的情况，题目说明指令数减少了 $\\Delta$ 的比例，而 CPI 增加了一个附加量 $\\epsilon$。因此，新的指令数 $IC_1$ 和新的 CPI $CPI_1$ 分别为：\n$$IC_1 = IC_0 \\times (1 - \\Delta)$$\n$$CPI_1 = CPI_0 + \\epsilon$$\n那么，重构后程序的执行时间 $T_1$ 为：\n$$T_1 = IC_1 \\times CPI_1 \\times T_{clk}$$\n代入 $IC_1$ 和 $CPI_1$ 的表达式，我们得到：\n$$T_1 = (IC_0 \\times (1 - \\Delta)) \\times (CPI_0 + \\epsilon) \\times T_{clk}$$\n\n性能缩放因子 $S$ 定义为基准执行时间与重构后执行时间之比。$S > 1$ 的值表示加速，而 $S < 1$ 则表示减速。\n$$S = \\frac{T_0}{T_1}$$\n我们将 $T_0$ 和 $T_1$ 的表达式代入此定义：\n$$S = \\frac{IC_0 \\times CPI_0 \\times T_{clk}}{(IC_0 \\times (1 - \\Delta)) \\times (CPI_0 + \\epsilon) \\times T_{clk}}$$\n项 $IC_0$ 和 $T_{clk}$ 同时出现在分子和分母中，因此它们可以被约去。这表明性能缩放因子与初始指令数和时钟速度无关，仅取决于初始 CPI 以及比例/附加变化量。\n$$S = \\frac{CPI_0}{(1 - \\Delta)(CPI_0 + \\epsilon)}$$\n\n现在，我们将给定的数值代入这个符号表达式中：\n$IC_0 = 2.40 \\times 10^9$（注意：计算 $S$ 的最终值不需要此数值）\n$CPI_0 = 1.20$\n$\\Delta = 0.18$\n$\\epsilon = 0.25$\n\n$S$ 的计算如下：\n$$S = \\frac{1.20}{(1 - 0.18) \\times (1.20 + 0.25)}$$\n首先，我们计算分母乘积中的两项：\n$$1 - \\Delta = 1 - 0.18 = 0.82$$\n$$CPI_0 + \\epsilon = 1.20 + 0.25 = 1.45$$\n将这些结果代回 $S$ 的表达式中：\n$$S = \\frac{1.20}{0.82 \\times 1.45}$$\n接下来，计算分母中的乘积：\n$$0.82 \\times 1.45 = 1.189$$\n最后，执行除法以求得 $S$ 的值：\n$$S = \\frac{1.20}{1.189} \\approx 1.0092514718...$$\n\n题目要求将结果四舍五入到四位有效数字。前四位有效数字是 $1$、$0$、$0$ 和 $9$。第五位有效数字是 $2$。由于 $2$ 小于 $5$，我们向下舍入，这意味着第四位有效数字保持不变。\n四舍五入到四位有效数字后，$S$ 的值为 $1.009$。",
            "answer": "$$\\boxed{1.009}$$"
        }
    ]
}