{
    "hands_on_practices": [
        {
            "introduction": "在计算机性能分析中，每条指令的周期数（CPI）是一个核心指标。由于处理器执行不同类型的指令（如算术、内存访问、分支）所需的时间不同，程序的平均 $CPI$ 是这些不同指令 $CPI$ 的加权平均值。本练习将指导您完成一个基础但至关重要的计算：如何根据给定的指令混合比例和各类指令的 $CPI$，计算出程序的平均 $CPI$，并进一步求得总执行时间。",
            "id": "3631197",
            "problem": "一个简单的顺序微架构执行三种指令类别：算术逻辑单元操作 (ALU)、加载/存储内存操作 (LDST) 和控制流分支操作 (BR)。在一个长时间运行的程序中，观察到的指令混合比例为 $(\\alpha_{ALU}, \\alpha_{LDST}, \\alpha_{BR}) = (0.5, 0.3, 0.2)$。每类指令的每指令周期数分别为 ALU 是 $1$，LDST 是 $3$，BR 是 $5$。中央处理器 (CPU) 的时钟频率为 $f = 2.5$ GHz，程序的指令数 (IC) 为 $5 \\times 10^{8}$ 条指令。\n\n使用将长期平均值与概率加权期望相关联以及将周期速率与时间相关联的第一性原理，确定该程序的平均每指令周期数 (CPI) 和总执行时间 $T$。将平均 CPI 表示为一个纯数，执行时间以秒为单位。提供精确值（不进行四舍五入）。",
            "solution": "该问题被评估为有效，因为它在科学上基于计算机体系结构的原理，问题提出得当，提供了所有必要信息，并且其表述是客观的。所提供的数据是自洽且符合实际的。\n\n核心任务是确定中央处理器 (CPU) 的两个关键性能指标：平均每指令周期数 ($CPI_{\\text{avg}}$) 和总程序执行时间 ($T$)。解决方案源于第一性原理。\n\n首先，我们计算该程序的平均每指令周期数。平均 $CPI$ 是每个指令类别的 $CPI$ 值的加权平均，其中权重是各自的指令混合比例。通用公式为：\n$$\nCPI_{\\text{avg}} = \\sum_{i} \\alpha_i \\cdot CPI_i\n$$\n其中 $\\alpha_i$ 是类别 $i$ 的指令比例，而 $CPI_i$ 是该类别的每指令周期数。\n\n问题提供了以下数据：\n指令混合比例：$(\\alpha_{\\text{ALU}}, \\alpha_{\\text{LDST}}, \\alpha_{\\text{BR}}) = (0.5, 0.3, 0.2)$。\n每类指令的每指令周期数：$CPI_{\\text{ALU}} = 1$，$CPI_{\\text{LDST}} = 3$，以及 $CPI_{\\text{BR}} = 5$。\n\n将这些值代入加权平均公式中：\n$$\nCPI_{\\text{avg}} = (\\alpha_{\\text{ALU}} \\cdot CPI_{\\text{ALU}}) + (\\alpha_{\\text{LDST}} \\cdot CPI_{\\text{LDST}}) + (\\alpha_{\\text{BR}} \\cdot CPI_{\\text{BR}})\n$$\n$$\nCPI_{\\text{avg}} = (0.5 \\cdot 1) + (0.3 \\cdot 3) + (0.2 \\cdot 5)\n$$\n对每一项进行乘法运算：\n$$\nCPI_{\\text{avg}} = 0.5 + 0.9 + 1.0\n$$\n将各项相加得出平均 $CPI$：\n$$\nCPI_{\\text{avg}} = 2.4\n$$\n这个值表示对于这个特定的程序和硬件，执行一条指令所需的平均时钟周期数。注意，比例之和为 $\\alpha_{\\text{ALU}} + \\alpha_{\\text{LDST}} + \\alpha_{\\text{BR}} = 0.5 + 0.3 + 0.2 = 1.0$，这是一个完整指令混合的必要条件。\n\n其次，我们计算总执行时间 $T$。执行时间由执行程序所需的总周期数除以时钟频率决定。总周期数是总指令数 (Instruction Count, $IC$) 与平均每指令周期数 ($CPI_{\\text{avg}}$) 的乘积。基本的 CPU 性能方程为：\n$$\nT = \\frac{\\text{Total Cycles}}{\\text{Clock Frequency}} = \\frac{IC \\cdot CPI_{\\text{avg}}}{f}\n$$\n问题提供了以下附加数据：\n指令数：$IC = 5 \\times 10^8$ 条指令。\nCPU 时钟频率：$f = 2.5 \\text{ GHz} = 2.5 \\times 10^9 \\text{ 周期/秒 (Hz)}$。\n\n我们将已知值代入性能方程：\n$$\nT = \\frac{(5 \\times 10^8) \\cdot 2.4}{2.5 \\times 10^9}\n$$\n我们可以通过重新排列各项来简化表达式：\n$$\nT = \\frac{5 \\cdot 2.4}{2.5} \\cdot \\frac{10^8}{10^9}\n$$\n首先，计算数值部分：\n$$\n\\frac{5 \\cdot 2.4}{2.5} = \\frac{12}{2.5} = \\frac{120}{25} = 4.8\n$$\n接下来，计算 $10$ 的幂次部分：\n$$\n\\frac{10^8}{10^9} = 10^{8-9} = 10^{-1}\n$$\n结合这些结果得出总执行时间 $T$：\n$$\nT = 4.8 \\times 10^{-1} = 0.48 \\text{ seconds}\n$$\n或者，我们可以直接计算分数：\n$$\nT = \\frac{1.2 \\times 10^9}{2.5 \\times 10^9} = \\frac{1.2}{2.5} = 0.48 \\text{ seconds}\n$$\n因此，平均每指令周期数是 $2.4$，总程序执行时间是 $0.48$ 秒。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 2.4  0.48 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "现代处理器采用分支预测等复杂技术来减少流水线停顿，从而提升性能。然而，当预测失败时，会引入显著的惩罚周期，直接影响 $CPI$。本练习通过一个优化分支预测器的假设场景，向您展示如何量化一项微体系结构改进所带来的性能增益，将更低的预测错误率直接与 $CPI$ 的降低和执行时间的缩短联系起来。",
            "id": "3631172",
            "problem": "一个团队正在优化中央处理器（CPU）的分支预测单元。考虑一个在单发射流水线上执行 $1.5 \\times 10^{9}$ 条动态指令的程序。条件分支占动态指令流的比例为 $0.20$。在优化前，每个条件分支的错误预测概率为 $0.08$；优化后，错误预测概率变为 $0.03$。每次分支预测错误会产生固定的、完全串行化的 $12$ 个时钟周期的惩罚，流水线或内存系统的其他方面均不改变。假设该优化不改变指令数或正确预测和非分支指令的基础每指令周期数，并且惩罚与有效工作不重叠。\n\n该机器的时钟频率为每秒 $3.2 \\times 10^{9}$ 个周期。仅使用第一性原理，从每指令周期数和执行时间的定义出发，推导仅因分支预测错误行为改变而导致的平均每指令周期数的变化量 $\\Delta \\mathrm{CPI}$，然后计算该程序总执行时间的相应变化量 $\\Delta T$。\n\n将 $\\Delta \\mathrm{CPI}$ 和 $\\Delta T$ 的结果均四舍五入到四位有效数字。以秒为单位表示 $\\Delta T$。以 $\\left(\\Delta \\mathrm{CPI}, \\Delta T\\right)$ 的顺序提供你的最终答案，答案为两个数字。",
            "solution": "在尝试求解之前，对问题陈述进行验证。\n\n### 第1步：提取给定条件\n- 总动态指令数：$I_C = 1.5 \\times 10^{9}$\n- 条件分支的比例：$f_{branch} = 0.20$\n- 优化前的错误预测概率：$P_{mp, before} = 0.08$\n- 优化后的错误预测概率：$P_{mp, after} = 0.03$\n- 错误预测惩罚：$P_{penalty} = 12$ 个时钟周期\n- 时钟频率：$f_{clk} = 3.2 \\times 10^{9}$ 周期/秒\n- 该优化不改变 $I_C$ 或基础每指令周期数（$\\mathrm{CPI}_{base}$）。\n- 惩罚是固定的、完全串行化的，并且不与有效工作重叠。\n\n### 第2步：使用提取的条件进行验证\n- **科学依据**：该问题很好地基于计算机体系结构和组织的原理。CPU 性能方程以及每指令周期数（CPI）、分支预测和错误预测惩罚等概念是该领域的标准基础课题。所提供的值是现实的。\n- **适定性**：该问题是适定的。它提供了所有必要的数据和约束，以唯一地确定 CPI 和执行时间的变化。问题是明确的。\n- **客观性**：语言是技术性的、精确的，并且没有主观内容。\n- **完整性和一致性**：该问题是自包含且内部一致的。诸如恒定的基础 CPI 和不重叠的惩罚等假设被明确陈述，并用于定义一个可解的模型。\n- **可行性**：所有数值对于现代处理器而言在物理上和技术上都是合理的。\n\n### 第3步：结论和行动\n问题有效。将从第一性原理推导解决方案。\n\n一个程序的总执行时间 $T$ 由基本的 CPU 性能方程确定：\n$$T = I_C \\times \\mathrm{CPI} \\times T_{clk}$$\n其中 $I_C$ 是指令数，$\\mathrm{CPI}$ 是平均每条指令的时钟周期数，$T_{clk}$ 是时钟周期。时钟周期是时钟频率 $f_{clk}$ 的倒数，所以 $T_{clk} = 1/f_{clk}$。该方程可以改写为：\n$$T = \\frac{I_C \\times \\mathrm{CPI}}{f_{clk}}$$\n平均 CPI 是理想或基础 CPI（$\\mathrm{CPI}_{base}$）与由流水线停顿和其他惩罚导致的额外 CPI 分量之和。在这个问题中，唯一变化的惩罚来源是分支预测错误。总 CPI 可以表示为：\n$$\\mathrm{CPI} = \\mathrm{CPI}_{base} + \\mathrm{CPI}_{penalty}$$\n惩罚分量 $\\mathrm{CPI}_{penalty}$ 是由于分支预测错误导致的平均每条指令的惩罚周期数。它通过确定总惩罚周期数并除以总指令数 $I_C$ 来计算。\n\n分支指令的总数是 $I_C \\times f_{branch}$。\n错误预测的分支数量是分支总数乘以错误预测概率 $P_{mp}$：\n$$\\text{Number of mispredictions} = I_C \\times f_{branch} \\times P_{mp}$$\n每次错误预测会产生 $P_{penalty}$ 个周期的惩罚。总惩罚周期数为：\n$$\\text{Total penalty cycles} = (\\text{Number of mispredictions}) \\times P_{penalty} = I_C \\times f_{branch} \\times P_{mp} \\times P_{penalty}$$\n因此，该惩罚对 CPI 的贡献是：\n$$\\mathrm{CPI}_{penalty} = \\frac{\\text{Total penalty cycles}}{I_C} = \\frac{I_C \\times f_{branch} \\times P_{mp} \\times P_{penalty}}{I_C} = f_{branch} \\times P_{mp} \\times P_{penalty}$$\n问题要求计算由于优化导致的平均每指令周期数的变化量 $\\Delta \\mathrm{CPI}$。这是优化后的 CPI 与优化前的 CPI 之间的差值。\n$$\\mathrm{CPI}_{before} = \\mathrm{CPI}_{base} + f_{branch} \\times P_{mp, before} \\times P_{penalty}$$\n$$\\mathrm{CPI}_{after} = \\mathrm{CPI}_{base} + f_{branch} \\times P_{mp, after} \\times P_{penalty}$$\n变化量 $\\Delta \\mathrm{CPI}$ 为：\n$$\\Delta \\mathrm{CPI} = \\mathrm{CPI}_{after} - \\mathrm{CPI}_{before}$$\n$$\\Delta \\mathrm{CPI} = (\\mathrm{CPI}_{base} + f_{branch} \\times P_{mp, after} \\times P_{penalty}) - (\\mathrm{CPI}_{base} + f_{branch} \\times P_{mp, before} \\times P_{penalty})$$\n基础 CPI，$\\mathrm{CPI}_{base}$，是常数，因此被抵消：\n$$\\Delta \\mathrm{CPI} = f_{branch} \\times P_{penalty} \\times (P_{mp, after} - P_{mp, before})$$\n代入给定值：\n$$\\Delta \\mathrm{CPI} = 0.20 \\times 12 \\times (0.03 - 0.08) = 2.4 \\times (-0.05) = -0.12$$\n问题要求将此值四舍五入到四位有效数字。\n$$\\Delta \\mathrm{CPI} = -0.1200$$\n负号正确地表示 CPI 的减少，这构成了性能的提升。\n\n接下来，我们计算总执行时间的相应变化量 $\\Delta T$。\n$$\\Delta T = T_{after} - T_{before}$$\n使用执行时间公式 $T = (I_C \\times \\mathrm{CPI}) / f_{clk}$：\n$$\\Delta T = \\frac{I_C \\times \\mathrm{CPI}_{after}}{f_{clk}} - \\frac{I_C \\times \\mathrm{CPI}_{before}}{f_{clk}}$$\n将常数项 $I_C$ 和 $f_{clk}$ 提取出来：\n$$\\Delta T = \\frac{I_C}{f_{clk}} (\\mathrm{CPI}_{after} - \\mathrm{CPI}_{before}) = \\frac{I_C}{f_{clk}} \\Delta \\mathrm{CPI}$$\n代入已知和先前计算的值：\n$$I_C = 1.5 \\times 10^9 \\text{ instructions}$$\n$$f_{clk} = 3.2 \\times 10^9 \\text{ cycles/second}$$\n$$\\Delta \\mathrm{CPI} = -0.12$$\n$$\\Delta T = \\frac{1.5 \\times 10^{9}}{3.2 \\times 10^{9}} \\times (-0.12) = \\frac{1.5}{3.2} \\times (-0.12)$$\n$$\\Delta T = 0.46875 \\times (-0.12) = -0.05625 \\text{ seconds}$$\n该值恰好有四位有效数字，因此无需进一步四舍五入。负号表示执行时间的减少。\n\n最终答案是 $\\Delta \\mathrm{CPI} = -0.1200$ 和 $\\Delta T = -0.05625$ 秒。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n-0.1200  -0.05625\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "软件和硬件的协同优化是提升计算性能的关键，但这其中充满了权衡。一个看似有益的改动，如减少程序的总指令数，可能伴随着平均指令复杂度（即 $CPI$）的增加。本练习探讨了这种经典的性能权衡问题，要求您分析代码重构在降低指令数的同时增加 $CPI$ 的情况下，对程序整体执行时间产生的净效应，从而学会更全面地评估优化策略的有效性。",
            "id": "3631477",
            "problem": "一个计算密集型应用程序运行在一个单发射顺序处理器上，其时钟周期在所有实验中保持不变。设程序的基准执行的指令数 (IC) 为 $IC_{0}$，每条指令的周期数 (CPI) 为 $CPI_{0}$。一次代码重构将总指令数减少了分数 $\\Delta$（因此新的指令数变为 $(1-\\Delta)IC_{0}$），但平均每条指令的周期数增加了一个附加量 $\\epsilon$（因此新的每条指令的周期数变为 $CPI_{0}+\\epsilon$）。假设处理器的时钟频率和除所述 $\\epsilon$ 变化之外的微架构条件保持不变。\n\n对于一个具体实例，取 $IC_{0}=2.40\\times 10^{9}$，$CPI_{0}=1.20$，$\\Delta=0.18$ 和 $\\epsilon=0.25$。确定性能缩放因子 $S$，其定义为基准执行时间与重构后执行时间之比。将您的最终结果表示为一个纯数（无单位）。将您的答案四舍五入到四位有效数字。",
            "solution": "分析始于基本的 CPU 性能方程，该方程将执行时间 ($T_{exec}$) 与指令数 ($IC$)、平均每条指令的周期数 ($CPI$) 和时钟周期 ($T_{clk}$) 相关联：\n$$T_{exec} = IC \\times CPI \\times T_{clk}$$\n时钟周期 $T_{clk}$ 是时钟频率的倒数，并且在本问题中被设定为常数。\n\n设下标 $0$ 表示基准执行，下标 $1$ 表示代码重构后的执行。\n\n对于基准情况，执行时间 $T_0$ 由下式给出：\n$$T_0 = IC_0 \\times CPI_0 \\times T_{clk}$$\n在这里，$IC_0$ 是初始指令数，$CPI_0$ 是初始平均每条指令的周期数。\n\n对于重构后的情况，问题指出指令数减少了分数 $\\Delta$，而 CPI 增加了一个附加量 $\\epsilon$。因此，新的指令数 $IC_1$ 和新的 CPI $CPI_1$ 分别为：\n$$IC_1 = IC_0 \\times (1 - \\Delta)$$\n$$CPI_1 = CPI_0 + \\epsilon$$\n重构后程序的执行时间 $T_1$ 则为：\n$$T_1 = IC_1 \\times CPI_1 \\times T_{clk}$$\n代入 $IC_1$ 和 $CPI_1$ 的表达式，我们得到：\n$$T_1 = (IC_0 \\times (1 - \\Delta)) \\times (CPI_0 + \\epsilon) \\times T_{clk}$$\n\n性能缩放因子 $S$ 定义为基准执行时间与重构后执行时间之比。$S > 1$ 的值表示加速，而 $S < 1$ 则表示减速。\n$$S = \\frac{T_0}{T_1}$$\n我们将 $T_0$ 和 $T_1$ 的表达式代入此定义：\n$$S = \\frac{IC_0 \\times CPI_0 \\times T_{clk}}{(IC_0 \\times (1 - \\Delta)) \\times (CPI_0 + \\epsilon) \\times T_{clk}}$$\n项 $IC_0$ 和 $T_{clk}$ 同时出现在分子和分母中，因此它们可以被约掉。这表明性能缩放因子与初始指令数和时钟速度无关，仅取决于初始 CPI 以及分数/附加的变化量。\n$$S = \\frac{CPI_0}{(1 - \\Delta)(CPI_0 + \\epsilon)}$$\n\n现在，我们将给定的数值代入这个符号表达式中：\n$IC_0 = 2.40 \\times 10^9$（注意：计算 $S$ 的最终值不需要此数值）\n$CPI_0 = 1.20$\n$\\Delta = 0.18$\n$\\epsilon = 0.25$\n\n$S$ 的计算如下：\n$$S = \\frac{1.20}{(1 - 0.18) \\times (1.20 + 0.25)}$$\n首先，我们计算分母乘积中的两项：\n$$1 - \\Delta = 1 - 0.18 = 0.82$$\n$$CPI_0 + \\epsilon = 1.20 + 0.25 = 1.45$$\n将这些结果代回 $S$ 的表达式中：\n$$S = \\frac{1.20}{0.82 \\times 1.45}$$\n接下来，计算分母中的乘积：\n$$0.82 \\times 1.45 = 1.189$$\n最后，执行除法以求得 $S$ 的值：\n$$S = \\frac{1.20}{1.189} \\approx 1.0092514718...$$\n\n题目要求结果四舍五入到四位有效数字。前四位有效数字是 $1$、$0$、$0$ 和 $9$。第五位有效数字是 $2$。因为 $2$ 小于 $5$，我们向下舍入，这意味着第四位有效数字保持不变。\n将 $S$ 的值四舍五入到四位有效数字后为 $1.009$。",
            "answer": "$$\\boxed{1.009}$$"
        }
    ]
}