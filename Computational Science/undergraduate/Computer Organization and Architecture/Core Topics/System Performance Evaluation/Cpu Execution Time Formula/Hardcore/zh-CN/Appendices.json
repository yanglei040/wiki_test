{
    "hands_on_practices": [
        {
            "introduction": "CPU性能优化并非总是直截了当的。这个练习将带你探讨一个核心的权衡关系：指令数（$IC$）与每指令周期数（$CPI$）之间的平衡。通过分析一个假设的编译器优化场景——用更快的乘法指令替换慢速的除法指令，但代价是增加额外的辅助指令——你将学会如何量化这种优化对总体执行时间的净影响，从而深入理解CPU时间公式中各组成部分是如何相互作用的。",
            "id": "3631100",
            "problem": "一个程序运行在单核中央处理器（CPU）上，由于微架构延迟，其流水线对不同指令类别的周期数不同。在进行任何转换之前，动态指令混合如下：算术除法指令占已执行指令的$5\\%$，每条指令占用$12$个周期；算术乘法指令占已执行指令的$10\\%$，每条指令占用$4$个周期；加、减和逻辑指令占已执行指令的$35\\%$，每条指令占用$1$个周期；加载和存储指令占已执行指令的$35\\%$，每条指令占用$2$个周期；控制转移（分支）指令占已执行指令的$15\\%$，每条指令占用$3$个周期。一次保持语义的代码转换将每个算术除法操作替换为与预计算的倒数相乘的等效操作，从而将那$5\\%$的指令从$12$个周期变为$4$个周期。该转换还引入了额外的开销，形式为增加了相当于原始指令数$2\\%$的额外加法指令，每条指令占用$1$个周期。假设时钟频率不变，且转换不改变周期时间。\n\n请仅使用执行周期和时间的基本定义，确定总执行时间的净变化，以乘法因子$T_{\\text{new}}/T_{\\text{old}}$的形式表示。将您的答案四舍五入到四位有效数字。由于所求量为无量纲量，因此不需要单位。",
            "solution": "我们使用的基本定义是：(1) 总执行时间$T$等于总时钟周期数与时钟周期时间的乘积，以及(2) 总时钟周期数等于所有已执行指令的每条指令所用周期数之和。等效地，如果$IC$表示动态指令总数（IC），$\\overline{CPI}$表示每指令平均周期数（CPI），则总周期数等于$IC \\times \\overline{CPI}$，且$T = IC \\times \\overline{CPI} \\times t_{c}$，其中$t_{c}$是周期时间。在$t_{c}$相同的情况下比较两个版本时，执行时间之比等于总周期数之比。\n\n设原始指令数为$N$。原始的指令类别计数如下：\n- 除法指令：$0.05N$，每条$12$个周期，贡献$0.05N \\times 12 = 0.60N$个周期，\n- 乘法指令：$0.10N$，每条$4$个周期，贡献$0.10N \\times 4 = 0.40N$个周期，\n- 加法/逻辑指令：$0.35N$，每条$1$个周期，贡献$0.35N \\times 1 = 0.35N$个周期，\n- 内存（加载/存储）指令：$0.35N$，每条$2$个周期，贡献$0.35N \\times 2 = 0.70N$个周期，\n- 分支指令：$0.15N$，每条$3$个周期，贡献$0.15N \\times 3 = 0.45N$个周期。\n\n因此，原始总周期数为\n$$\n\\text{cycles}_{\\text{old}} = (0.60 + 0.40 + 0.35 + 0.70 + 0.45)N = 2.50N,\n$$\n所以原始的平均$CPI$为\n$$\n\\overline{CPI}_{\\text{old}} = \\frac{\\text{cycles}_{\\text{old}}}{N} = 2.50.\n$$\n\n转换后，所有除法指令被替换为占用$4$个周期的乘法指令，因此除法指令贡献为$0$。乘法指令数从$0.10N$增加到$0.15N$，其贡献为$0.15N \\times 4 = 0.60N$个周期。该转换还增加了$0.02N$条额外的加法指令，每条占用$1$个周期，使加法/逻辑指令数从$0.35N$增加到$0.37N$，贡献了$0.37N \\times 1 = 0.37N$个周期。内存和分支指令数保持为$0.35N$和$0.15N$，分别贡献$0.35N \\times 2 = 0.70N$和$0.15N \\times 3 = 0.45N$个周期。因此，新的总周期数为\n$$\n\\text{cycles}_{\\text{new}} = (0.60 + 0.37 + 0.70 + 0.45)N = 2.12N.\n$$\n\n新的指令数为$N_{\\text{new}} = 1.02N$，所以新的平均$CPI$为\n$$\n\\overline{CPI}_{\\text{new}} = \\frac{\\text{cycles}_{\\text{new}}}{N_{\\text{new}}} = \\frac{2.12N}{1.02N} = \\frac{2.12}{1.02} \\approx 2.078.\n$$\n\n执行时间的净变化，以乘法因子表示为\n$$\n\\frac{T_{\\text{new}}}{T_{\\text{old}}} = \\frac{\\text{cycles}_{\\text{new}}}{\\text{cycles}_{\\text{old}}} = \\frac{2.12N}{2.50N} = \\frac{2.12}{2.50} = 0.848.\n$$\n\n四舍五入到四位有效数字得到$0.8480$。",
            "answer": "$$\\boxed{0.8480}$$"
        },
        {
            "introduction": "在真实的计算场景中，平均$CPI$并不是一个单一的固定值，它深受内存系统性能的影响。本练习将CPU性能分析从理想模型推向现实，通过一个网络服务器处理请求的案例，让你亲手拆解$CPI$的构成：基础$CPI$与由缓存和TLB（转译后备缓冲器）未命中引起的“停顿”$CPI$。你将计算并比较“冷”启动和“热”状态下的性能差异，从而直观地理解内存层次结构对应用程序延迟的关键作用。",
            "id": "3631109",
            "problem": "一个Web服务器运行在一个中央处理器 (CPU) 上，其时钟频率为 $f = 3.2 \\times 10^{9} \\text{ cycles/s}$。对于单个HTTP请求的应用逻辑，动态指令数为 $IC = 2.5 \\times 10^{6}$ 条指令。基本每指令周期数（所有存储层次结构都命中的情况下）为 $\\mathrm{CPI}_{\\mathrm{base}} = 0.8$。内存停顿来自指令缓存 (I-cache)、数据缓存 (D-cache) 以及用于指令提取 (iTLB) 和数据访问 (dTLB) 的转译后备缓冲器 (TLB)。假设如下：\n- 每条指令从I-cache中提取一条指令。\n- 每条指令的平均数据内存引用次数为 $m_{d} = 0.35$。\n- 未命中惩罚（以周期为单位）为：I-cache $= 30$，D-cache $= 40$，TLB（iTLB和dTLB）$= 100$。\n- 在冷连接（无重用）下，未命中率为：每条指令的I-cache未命中率 $r_{I,\\mathrm{cold}} = 0.004$，每次数据引用的D-cache未命中率 $r_{D,\\mathrm{cold}} = 0.02$，每条指令的iTLB未命中率 $r_{i,\\mathrm{cold}} = 0.0002$，每次数据引用的dTLB未命中率 $r_{d,\\mathrm{cold}} = 0.0005$。\n- 在热状态（有重用）下，未命中率为：每条指令的I-cache未命中率 $r_{I,\\mathrm{warm}} = 0.0005$，每次数据引用的D-cache未命中率 $r_{D,\\mathrm{warm}} = 0.003$，每条指令的iTLB未命中率 $r_{i,\\mathrm{warm}} = 0.00005$，每次数据引用的dTLB未命中率 $r_{d,\\mathrm{warm}} = 0.0001$。\n\n最初，服务器不使用HTTP持久连接 (keep-alive)，因此每个请求都经历冷行为。然后服务器启用keep-alive，每个连接平均承载 $k = 8$ 个请求：每个连接的第一个请求是冷的，随后的每个请求都是热的。假设来自I-cache、D-cache、iTLB和dTLB的停顿惩罚是可加的且没有重叠，$\\mathrm{CPI}_{\\mathrm{base}}$ 和惩罚不变，并且每个请求的指令数 $IC$ 不因keep-alive而改变。\n\n仅使用周期、时间和平均每指令周期数的核心定义，计算每个请求的CPU执行时间的平均减少量，定义为\n$$\\Delta T = T_{\\mathrm{no\\ KA}} - T_{\\mathrm{with\\ KA}},$$\n其中 $T_{\\mathrm{no\\ KA}}$ 是每个请求都是冷请求时的每个请求的CPU时间，而 $T_{\\mathrm{with\\ KA}}$ 是每个连接有一个冷请求和 $k-1$ 个热请求时的平均每个请求的CPU时间。将您的最终答案以微秒表示，并四舍五入到四位有效数字。",
            "solution": "问题要求计算启用HTTP持久连接 (keep-alive) 时，每个请求的CPU执行时间的平均减少量。支配CPU执行时间的基本关系由CPU性能方程给出：\n$$T_{CPU} = \\frac{N_{cycles}}{f}$$\n其中 $T_{CPU}$ 是执行时间（秒），$N_{cycles}$ 是CPU总周期数，$f$ 是时钟频率（周期/秒）。总周期数可以表示为指令数 ($IC$) 和平均每指令周期数 ($\\mathrm{CPI}$) 的乘积：\n$$N_{cycles} = IC \\times \\mathrm{CPI}$$\n结合这些，单个请求的执行时间为：\n$$T = \\frac{IC \\times \\mathrm{CPI}}{f}$$\n总 $\\mathrm{CPI}$ 是基本 $\\mathrm{CPI}$（假设没有内存停顿）和由各种停顿源贡献的额外 $\\mathrm{CPI}$ 的总和。问题指出，来自I-cache、D-cache、iTLB和dTLB的停顿是可加的。\n$$\\mathrm{CPI}_{total} = \\mathrm{CPI}_{\\mathrm{base}} + \\mathrm{CPI}_{\\mathrm{stalls}}$$\n$$\\mathrm{CPI}_{\\mathrm{stalls}} = \\mathrm{CPI}_{I} + \\mathrm{CPI}_{D} + \\mathrm{CPI}_{iTLB} + \\mathrm{CPI}_{dTLB}$$\n每个组件的停顿CPI是该类型每条指令的内存访问次数、该访问类型的未命中率以及相应的未命中惩罚（以周期为单位）的乘积。\n\n1.  **每条指令的指令缓存 (I-cache) 停顿**：每条指令需要一次提取。\n    $$\\mathrm{CPI}_{I} = (\\text{每条指令的未命中数}) \\times (\\text{未命中惩罚}) = r_{I} \\times P_{I}$$\n2.  **每条指令的数据缓存 (D-cache) 停顿**：每条指令有 $m_d$ 次数据引用。\n    $$\\mathrm{CPI}_{D} = (\\text{每条指令的数据引用数}) \\times (\\text{每次引用的未命中率}) \\times (\\text{未命中惩罚}) = m_{d} \\times r_{D} \\times P_{D}$$\n3.  **每条指令的指令TLB (iTLB) 停顿**：每次指令提取都是一次需要翻译的内存访问。\n    $$\\mathrm{CPI}_{iTLB} = (\\text{每条指令的指令提取数}) \\times (\\text{每次提取的未命中率}) \\times (\\text{未命中惩罚}) = 1 \\times r_{i} \\times P_{T} = r_{i} \\times P_{T}$$\n4.  **每条指令的数据TLB (dTLB) 停顿**：每次数据引用都是一次需要翻译的内存访问。\n    $$\\mathrm{CPI}_{dTLB} = (\\text{每条指令的数据引用数}) \\times (\\text{每次引用的未命中率}) \\times (\\text{未命中惩罚}) = m_{d} \\times r_{d} \\times P_{T}$$\n\n结合这些，总 $\\mathrm{CPI}$ 的通用表达式为：\n$$\\mathrm{CPI} = \\mathrm{CPI}_{\\mathrm{base}} + r_{I}P_{I} + m_{d}r_{D}P_{D} + r_{i}P_{T} + m_{d}r_{d}P_{T}$$\n\n我们已知以下参数：\n- $\\mathrm{CPI}_{\\mathrm{base}} = 0.8$\n- $m_{d} = 0.35$\n- $P_{I} = 30$ 周期\n- $P_{D} = 40$ 周期\n- $P_{T} = 100$ 周期\n\n首先，我们使用冷未命中率计算冷请求的 $\\mathrm{CPI}$，即 $\\mathrm{CPI}_{\\mathrm{cold}}$：\n$r_{I,\\mathrm{cold}} = 0.004$, $r_{D,\\mathrm{cold}} = 0.02$, $r_{i,\\mathrm{cold}} = 0.0002$, $r_{d,\\mathrm{cold}} = 0.0005$。\n$$\\mathrm{CPI}_{\\mathrm{cold}} = 0.8 + (0.004)(30) + (0.35)(0.02)(40) + (0.0002)(100) + (0.35)(0.0005)(100)$$\n$$\\mathrm{CPI}_{\\mathrm{cold}} = 0.8 + 0.12 + 0.28 + 0.02 + 0.0175 = 1.2375$$\n\n接下来，我们使用热未命中率计算热请求的 $\\mathrm{CPI}$，即 $\\mathrm{CPI}_{\\mathrm{warm}}$：\n$r_{I,\\mathrm{warm}} = 0.0005$, $r_{D,\\mathrm{warm}} = 0.003$, $r_{i,\\mathrm{warm}} = 0.00005$, $r_{d,\\mathrm{warm}} = 0.0001$。\n$$\\mathrm{CPI}_{\\mathrm{warm}} = 0.8 + (0.0005)(30) + (0.35)(0.003)(40) + (0.00005)(100) + (0.35)(0.0001)(100)$$\n$$\\mathrm{CPI}_{\\mathrm{warm}} = 0.8 + 0.015 + 0.042 + 0.005 + 0.0035 = 0.8655$$\n\n现在我们可以确定两种情况下的执行时间。\n**情况1：无Keep-Alive ($T_{\\mathrm{no\\ KA}}$)**\n在这种情况下，每个请求都是冷请求。每个请求的CPU时间为：\n$$T_{\\mathrm{no\\ KA}} = \\frac{IC \\times \\mathrm{CPI}_{\\mathrm{cold}}}{f}$$\n\n**情况2：有Keep-Alive ($T_{\\mathrm{with\\ KA}}$)**\n在这种情况下，一个连接包含 $k=8$ 个请求：一个冷请求和 $k-1=7$ 个热请求。一个连接的总周期数为：\n$$N_{cycles, conn} = (IC \\times \\mathrm{CPI}_{\\mathrm{cold}}) \\times 1 + (IC \\times \\mathrm{CPI}_{\\mathrm{warm}}) \\times (k-1)$$\n每个请求的平均CPU时间 $T_{\\mathrm{with\\ KA}}$ 是连接的总时间除以请求数 $k$：\n$$T_{\\mathrm{with\\ KA}} = \\frac{N_{cycles, conn}}{k \\times f} = \\frac{IC \\times (\\mathrm{CPI}_{\\mathrm{cold}} + (k-1)\\mathrm{CPI}_{\\mathrm{warm}})}{k \\times f}$$\n\n问题要求计算每个请求的CPU执行时间的平均减少量 $\\Delta T$：\n$$\\Delta T = T_{\\mathrm{no\\ KA}} - T_{\\mathrm{with\\ KA}}$$\n代入时间的表达式：\n$$\\Delta T = \\frac{IC \\times \\mathrm{CPI}_{\\mathrm{cold}}}{f} - \\frac{IC \\times (\\mathrm{CPI}_{\\mathrm{cold}} + (k-1)\\mathrm{CPI}_{\\mathrm{warm}})}{k \\times f}$$\n我们可以提出公因子 $\\frac{IC}{f}$：\n$$\\Delta T = \\frac{IC}{f} \\left( \\mathrm{CPI}_{\\mathrm{cold}} - \\frac{\\mathrm{CPI}_{\\mathrm{cold}} + (k-1)\\mathrm{CPI}_{\\mathrm{warm}}}{k} \\right)$$\n将括号内的项通分，分母为 $k$：\n$$\\Delta T = \\frac{IC}{f} \\left( \\frac{k\\mathrm{CPI}_{\\mathrm{cold}} - (\\mathrm{CPI}_{\\mathrm{cold}} + (k-1)\\mathrm{CPI}_{\\mathrm{warm}})}{k} \\right)$$\n$$\\Delta T = \\frac{IC}{f} \\left( \\frac{(k-1)\\mathrm{CPI}_{\\mathrm{cold}} - (k-1)\\mathrm{CPI}_{\\mathrm{warm}}}{k} \\right)$$\n简化后得到：\n$$\\Delta T = \\frac{IC \\times (k-1)}{f \\times k} \\left(\\mathrm{CPI}_{\\mathrm{cold}} - \\mathrm{CPI}_{\\mathrm{warm}}\\right)$$\n这个表达式表示在 $k-1$ 个热请求中节省的总时间，分摊到连接中的所有 $k$ 个请求上。\n\n现在，我们将已知值代入这个最终表达式：\n$IC = 2.5 \\times 10^{6}$\n$f = 3.2 \\times 10^{9}$\n$k = 8$\n$\\mathrm{CPI}_{\\mathrm{cold}} = 1.2375$\n$\\mathrm{CPI}_{\\mathrm{warm}} = 0.8655$\n$$\\Delta T = \\frac{(2.5 \\times 10^{6}) \\times (8-1)}{(3.2 \\times 10^{9}) \\times 8} \\left(1.2375 - 0.8655\\right)$$\n$$\\Delta T = \\frac{2.5 \\times 10^{6} \\times 7}{25.6 \\times 10^{9}} \\left(0.372\\right)$$\n$$\\Delta T = \\frac{17.5 \\times 10^{6}}{25.6 \\times 10^{9}} \\times 0.372$$\n$$\\Delta T \\approx (0.68359375 \\times 10^{-3}) \\times 0.372$$\n$$\\Delta T \\approx 0.000254296875 \\text{ s}$$\n问题要求答案以微秒 ($\\mu\\mathrm{s}$) 为单位，其中 $1 \\text{ s} = 10^{6} \\mu\\mathrm{s}$。\n$$\\Delta T \\approx 0.000254296875 \\times 10^{6} \\mu\\mathrm{s} = 254.296875 \\mu\\mathrm{s}$$\n四舍五入到四位有效数字，我们得到：\n$$\\Delta T \\approx 254.3 \\mu\\mathrm{s}$$",
            "answer": "$$\n\\boxed{254.3}\n$$"
        },
        {
            "introduction": "在现代计算中，“最佳”性能的定义已经超越了单纯的速度。对于从移动设备到大型数据中心的各种应用而言，能效变得至关重要。这个练习将引导你将优化目标从最小化执行时间（$T$）转向最小化能耗与延迟的乘积（$EDP$）。通过分析动态电压与频率调节（DVFS）技术，你将探索如何在给定的运行频率范围内，找到平衡速度与能耗的最佳工作点，并理解为何最快的运行速度不一定总是最高效的选择。",
            "id": "3631106",
            "problem": "一个单线程程序在一个支持动态电压和频率缩放 (DVFS) 的中央处理器 (CPU) 上执行。在支持的 DVFS 范围内，程序的每条指令周期数 (CPI) 不随频率变化，且程序执行固定的指令数。该 CPU 的动态功耗占主导地位，并遵循一个与时钟频率 $f$ 相关的实测缩放定律：在该设计的安全工作区域内，平均功耗满足 $P \\propto f^{\\gamma}$，其中 $\\gamma = 3$。对于这个固定程序，执行时间 $T$ 由周期数乘以时钟周期决定。处理器允许时钟频率 $f$ 在闭区间 $[1.2, 3.6]$ GHz 内的任意位置设置。\n\n将运行一次程序的能耗-延迟积 (EDP) 定义为 $EDP = E \\cdot T$，其中 $E$ 是运行期间消耗的总能量，$T$ 是执行时间。假设运行期间为稳态平均功耗，漏电可忽略不计，并且与给定功耗定律一致的电压缩放已经内含在经验观察到的指数 $\\gamma$ 中。\n\n仅使用执行时间和能量的基本定义以及所述的缩放定律，确定在允许区间内的哪个单一工作频率 $f$ 可以最小化该程序的 $EDP$。用 GHz 表示您的最终答案，并四舍五入到三位有效数字。",
            "solution": "问题要求确定在指定范围内的工作频率 $f$，以最小化在具有动态电压和频率缩放 (DVFS) 的 CPU 上运行的程序的能耗-延迟积 (EDP)。\n\n首先，我们必须将定义为 $EDP = E \\cdot T$ 的能耗-延迟积表示为时钟频率 $f$ 的函数。这需要找到执行时间 $T$ 和总消耗能量 $E$ 关于 $f$ 的表达式。\n\n一个程序的执行时间 $T$ 由执行该程序所需的总周期数除以时钟频率给出。\n$$T = \\frac{\\text{Number of Cycles}}{\\text{Clock Frequency}}$$\n总周期数是指令数 ($IC$) 和平均每指令周期数 ($CPI$) 的乘积。问题陈述，对于该程序，无论工作频率如何，$IC$ 和 $CPI$ 都是恒定的。我们用 $N_c = IC \\cdot CPI$ 表示恒定的总周期数。\n因此，执行时间 $T$ 作为频率 $f$ 的函数是：\n$$T(f) = \\frac{N_c}{f}$$\n这表明执行时间与时钟频率成反比，$T \\propto f^{-1}$。\n\n接下来，我们确定总消耗能量 $E$。能量是功耗对时间的积分。假设在执行时间 $T$ 内的平均功耗为稳态值 $P$，则能量就是它们的乘积：\n$$E = P \\cdot T$$\n问题陈述，平均功耗 $P$ 随频率 $f$ 按 $P \\propto f^{\\gamma}$ 的规律缩放，指数 $\\gamma = 3$。我们可以用一个比例常数 $k_P$ 来表示这种关系：\n$$P(f) = k_P f^{\\gamma} = k_P f^{3}$$\n其中 $k_P$ 是一个正常数，取决于电路设计和程序活动的具体情况。\n\n现在我们可以通过代入 $P(f)$ 和 $T(f)$ 的表达式，将能量 $E$ 写成频率 $f$ 的函数：\n$$E(f) = P(f) \\cdot T(f) = (k_P f^{3}) \\cdot \\left(\\frac{N_c}{f}\\right) = k_P N_c f^{2}$$\n这表明能耗与时钟频率的平方成正比，$E \\propto f^{2}$。\n\n有了 $E(f)$ 和 $T(f)$ 的表达式，我们现在可以将能耗-延迟积 $EDP$ 写成 $f$ 的函数：\n$$EDP(f) = E(f) \\cdot T(f)$$\n代入导出的函数：\n$$EDP(f) = (k_P N_c f^{2}) \\cdot \\left(\\frac{N_c}{f}\\right) = k_P N_c^2 f$$\n我们定义一个新常数 $K = k_P N_c^2$。由于 $k_P > 0$ 且 $N_c > 0$，常数 $K$ 也是正的。表达式简化为：\n$$EDP(f) = K f$$\n能耗-延迟积与时钟频率 $f$ 成正比。\n\n任务是找到在允许的闭区间 $[1.2, 3.6]$ GHz 内最小化 $EDP(f)$ 的频率 $f$。函数 $EDP(f) = K f$ 是一个关于 $f$ 的单调递增函数，其斜率 $K$ 为正。一个在闭区间上的单调递增函数在其区间的下限处达到最小值。\n\n给定的频率 $f$ 区间是 $[1.2, 3.6]$ GHz。\n因此，最小化 $EDP$ 的频率是该范围内的最低可能频率：\n$$f_{optimal} = f_{min} = 1.2 \\, \\text{GHz}$$\n问题要求答案四舍五入到三位有效数字。值 $1.2$ GHz，用三位有效数字表示为 $1.20$ GHz。",
            "answer": "$$\\boxed{1.20}$$"
        }
    ]
}