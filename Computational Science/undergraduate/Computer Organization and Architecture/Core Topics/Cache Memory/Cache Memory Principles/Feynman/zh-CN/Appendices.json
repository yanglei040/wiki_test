{
    "hands_on_practices": [
        {
            "introduction": "要真正理解高速缓存的工作原理，第一步是学会如何将内存地址“解码”。这个练习将指导你完成这一基本功：根据给定的高速缓存配置（总容量、块大小、相联度），精确计算出物理地址中用于标签($t$)、索引($i$)和块偏移($o$)的位数。掌握这项技能是分析任何高速缓存行为的基础，它揭示了硬件如何利用地址的各个部分来快速定位数据 。",
            "id": "3635260",
            "problem": "一个字节可寻址的处理器使用$32$位物理地址和一个物理索引、物理标记的数据缓存。该缓存的总数据容量为$32\\,\\mathrm{KiB}$，并使用大小为$64\\,\\mathrm{B}$的块。该缓存是$4$路组相联的。在推算容量时，忽略所有元数据开销（如有效位、脏位或替换状态）。\n\n仅从以下基本定义出发：一个物理地址被划分为一个$t$位的标记字段、一个用于选择组的$i$位的索引字段，以及一个用于选择块内字节的$o$位的块内偏移字段；组相联性将缓存组织成多个组，每个组包含固定数量的块。请确定该缓存的标记大小$t$、索引大小$i$、块内偏移大小$o$以及组数$S$的值。\n\n请以有序四元组 $\\left(t,\\, i,\\, o,\\, S\\right)$ 的形式提供您的最终答案。无需四舍五入，最终答案中不应包含单位。",
            "solution": "该问题在计算机组成与体系结构领域内定义明确且具有科学依据。所有必要的参数都已提供，且没有矛盾之处。我们可以进行形式化推导。\n\n该问题要求确定一个组相联缓存的四个参数：标记大小$t$、索引大小$i$、块内偏移大小$o$和组数$S$。解决方案源自于支配缓存存储器组织的基本原理。一个物理地址被划分为三个字段：标记、索引和块内偏移。\n\n给定的物理地址总大小为$32$位。这给出了主要关系式：\n$$t + i + o = 32$$\n\n我们将按逻辑顺序确定参数$o$、$i$、$S$以及最后的$t$。\n\n首先，我们确定块内偏移大小$o$。处理器是字节可寻址的，一个缓存块包含多个字节。块内偏移是地址中用于选择块内特定字节的部分。偏移所需的位数$o$由块大小$B$决定。\n给定的块大小为$B = 64\\,\\mathrm{B}$。为了唯一地寻址$64$个字节，我们需要的位数$o$应满足$2^o = 64$。\n$$o = \\log_{2}(64) = \\log_{2}(2^{6}) = 6$$\n因此，块内偏移字段长$6$位。\n\n接下来，我们确定组数$S$。缓存的总数据容量$C$为$32\\,\\mathrm{KiB}$，相联度$k$为$4$路。我们必须首先将缓存容量转换为字节。利用$1\\,\\mathrm{KiB} = 2^{10}\\,\\mathrm{B} = 1024\\,\\mathrm{B}$这一事实：\n$$C = 32\\,\\mathrm{KiB} = 32 \\times 2^{10}\\,\\mathrm{B} = 2^{5} \\times 2^{10}\\,\\mathrm{B} = 2^{15}\\,\\mathrm{B}$$\n缓存中的总块数$N_{blocks}$是总容量除以块大小：\n$$N_{blocks} = \\frac{C}{B} = \\frac{2^{15}\\,\\mathrm{B}}{64\\,\\mathrm{B}} = \\frac{2^{15}}{2^{6}} = 2^{15-6} = 2^{9} = 512$$\n所以，该缓存总共包含$512$个块。\n在一个$k$路组相联缓存中，这些块被组织成多个组，每个组包含$k$个块。组数$S$是总块数除以相联度$k$。\n$$S = \\frac{N_{blocks}}{k} = \\frac{512}{4} = \\frac{2^{9}}{2^{2}} = 2^{9-2} = 2^{7} = 128$$\n该缓存有$128$个组。\n\n现在我们可以确定索引大小$i$。地址的索引字段用于选择一个内存块映射到$S$个组中的哪一个。索引所需的位数$i$由组的数量决定。\n$$i = \\log_{2}(S) = \\log_{2}(128) = \\log_{2}(2^{7}) = 7$$\n因此，索引字段长$7$位。\n\n最后，我们确定标记大小$t$。物理地址的剩余位构成标记。我们使用关于物理地址划分的初始关系式：\n$$t + i + o = 32$$\n代入我们已经求出的$i$和$o$的值：\n$$t + 7 + 6 = 32$$\n$$t + 13 = 32$$\n$$t = 32 - 13 = 19$$\n标记字段长$19$位。\n\n总之，计算出的缓存参数为：\n- 标记大小，$t = 19$位。\n- 索引大小，$i = 7$位。\n- 块内偏移大小，$o = 6$位。\n- 组数，$S = 128$。\n\n最终答案要求为有序四元组 $(t, i, o, S)$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n19  & 7 & 6 & 128\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在了解了地址如何静态映射到缓存之后，下一步是观察高速缓存在一系列访问下的动态行为。本练习通过一个精心设计的访问序列，让你手动模拟并对比两种不同替换策略（最近最少使用LRU和随机RAND）下的缓存命中与缺失情况。通过这个过程，你将直觀地感受到，即使硬件配置完全相同，一个“聪明”的替换算法也能显著影响缓存性能，这對於编写高效能的软件至关重要 。",
            "id": "3635229",
            "problem": "考虑一个32位系统上的缓存，其配置为2路组相联缓存，共有 $S=2$ 个组（每组 $E=2$ 行），块大小为 $B=64$ 字节。内存地址 $a$ 的组索引由基本映射规则 $i=\\left\\lfloor \\frac{a}{B} \\right\\rfloor \\bmod S$ 定义，标记是 $\\left\\lfloor \\frac{a}{B} \\right\\rfloor$ 剩余的高位比特。假设缓存为冷启动（初始为空），未命中时采用写分配策略，且仅发生读操作。精确定义替换策略如下：最近最少使用（LRU）策略总是驱逐其所在组内最长时间未被使用的行；随机替换（RAND）策略在需要驱逐时，在组内的 $E$ 行中进行均匀选择。为保证可复现性，当RAND策略需要驱逐时，使用以下确定性规则替代随机性：对于踪迹中遇到的第 $k$ 次驱逐，提供一个固定的抛硬币结果 $c_{k} \\in \\{H,T\\}$，其中 $H$ 表示驱逐最近最少使用（LRU）的行， $T$ 表示驱逐最近最多使用（MRU）的行。\n\n给你以下地址踪迹（以字节为单位）：\n$$[\\,0,\\;128,\\;256,\\;0,\\;128,\\;0,\\;128,\\;0,\\;128,\\;256,\\;0,\\;128\\,]$$\n以及RAND策略按遇到的驱逐顺序对应的抛硬币结果：\n$$[\\,T,\\;T,\\;T,\\;T,\\;T,\\;T,\\;H,\\;H\\,].$$\n\n任务：\n- 仅使用上述组相联缓存和替换策略的基本定义，确定在LRU策略下的未命中总数 $M_{\\text{LRU}}$，以及在具有固定结果的RAND策略下的未命中总数 $M_{\\text{rand}}$。\n- 对于每次冲突（当目标组已满时发生的访问未命中），明确指出在LRU和RAND策略下哪个块被驱逐。\n- 将你的最终答案表示为单一标量差值 $M_{\\text{rand}} - M_{\\text{LRU}}$。无需四舍五入，也无需单位。",
            "solution": "问题陈述已经过验证，被认为是合理的。这是一个在计算机组成与体系结构领域中的良构问题，包含了获得唯一解所需的所有必要参数、定义和数据。其设置遵循了缓存操作的既定原则。\n\n问题的核心是针对给定的内存地址踪迹，模拟一个2路组相联缓存在两种不同替换策略下的行为：最近最少使用（LRU）和随机（RAND）的一个确定性变体。\n\n首先，我们必须分析缓存的结构和内存地址映射。\n该系统有32位地址。\n缓存参数如下：\n- 组数, $S = 2$。\n- 相联度（每组的行数）, $E = 2$。\n- 块大小, $B = 64$ 字节。\n\n块偏移所需的比特数是 $\\log_2(B) = \\log_2(64) = 6$ 比特。\n组索引所需的比特数是 $\\log_2(S) = \\log_2(2) = 1$ 比特。\n剩余的比特用于标记：$32 - 6 - 1 = 25$ 比特。\n\n字节地址 $a$ 的组索引 $i$ 由 $i = \\lfloor \\frac{a}{B} \\rfloor \\bmod S$ 给出。\n标记 $t$ 是块地址 $\\lfloor \\frac{a}{B} \\rfloor$ 的高位部分，具体为 $t = \\left\\lfloor \\frac{\\lfloor a/B \\rfloor}{S} \\right\\rfloor = \\left\\lfloor \\frac{a}{B \\times S} \\right\\rfloor$。\n当 $B=64$ 且 $S=2$ 时，公式为：\n- 组索引: $i = \\lfloor \\frac{a}{64} \\rfloor \\bmod 2$。\n- 标记: $t = \\lfloor \\frac{a}{128} \\rfloor$。\n\n让我们计算踪迹中唯一地址 $[\\,0, 128, 256\\,]$ 的组索引和标记。\n- 对于地址 $a=0$：\n  - 块地址: $\\lfloor 0/64 \\rfloor = 0$。\n  - 组索引: $0 \\bmod 2 = 0$。\n  - 标记: $\\lfloor 0/128 \\rfloor = 0$。我们将其表示为 $t_0$。\n- 对于地址 $a=128$：\n  - 块地址: $\\lfloor 128/64 \\rfloor = 2$。\n  - 组索引: $2 \\bmod 2 = 0$。\n  - 标记: $\\lfloor 128/128 \\rfloor = 1$。我们将其表示为 $t_1$。\n- 对于地址 $a=256$：\n  - 块地址: $\\lfloor 256/64 \\rfloor = 4$。\n  - 组索引: $4 \\bmod 2 = 0$。\n  - 标记: $\\lfloor 256/128 \\rfloor = 2$。我们将其表示为 $t_2$。\n\n所有三个唯一的内存块都映射到组0。在整个模拟过程中，组1将保持为空。我们只需要跟踪拥有 $E=2$ 行的组0的状态。用标记表示的地址踪迹为：$[\\,t_0, t_1, t_2, t_0, t_1, t_0, t_1, t_0, t_1, t_2, t_0, t_1\\,]$。\n\n**第1部分：LRU替换策略模拟**\n\n我们跟踪组0的内容及其使用的近期程度。状态表示为一个有序列表 `[MRU, LRU]`。缓存初始为空。\n\n1.  **访问 $0$ ($t_0$):** 未命中（强制性）。组0未满。\n    - 组0状态: $[t_0]$。未命中数: $1$。\n2.  **访问 $128$ ($t_1$):** 未命中（强制性）。组0未满。\n    - 组0状态: $[t_1, t_0]$。未命中数: $2$。\n3.  **访问 $256$ ($t_2$):** 未命中（冲突性）。组0已满。LRU驱逐LRU块，即 $t_0$。\n    - 被驱逐: $t_0$。\n    - 组0状态: $[t_2, t_1]$。未命中数: $3$。\n4.  **访问 $0$ ($t_0$):** 未命中（冲突性）。组0已满。LRU驱逐 $t_1$。\n    - 被驱逐: $t_1$。\n    - 组0状态: $[t_0, t_2]$。未命中数: $4$。\n5.  **访问 $128$ ($t_1$):** 未命中（冲突性）。组0已满。LRU驱逐 $t_2$。\n    - 被驱逐: $t_2$。\n    - 组0状态: $[t_1, t_0]$。未命中数: $5$。\n6.  **访问 $0$ ($t_0$):** 命中。$t_0$ 在缓存中。它成为MRU。\n    - 组0状态: $[t_0, t_1]$。未命中数: $5$。\n7.  **访问 $128$ ($t_1$):** 命中。$t_1$ 在缓存中。它成为MRU。\n    - 组0状态: $[t_1, t_0]$。未命中数: $5$。\n8.  **访问 $0$ ($t_0$):** 命中。$t_0$ 在缓存中。它成为MRU。\n    - 组0状态: $[t_0, t_1]$。未命中数: $5$。\n9.  **访问 $128$ ($t_1$):** 命中。$t_1$ 在缓存中。它成为MRU。\n    - 组0状态: $[t_1, t_0]$。未命中数: $5$。\n10. **访问 $256$ ($t_2$):** 未命中（冲突性）。组0已满。LRU驱逐 $t_0$。\n    - 被驱逐: $t_0$。\n    - 组0状态: $[t_2, t_1]$。未命中数: $6$。\n11. **访问 $0$ ($t_0$):** 未命中（冲突性）。组0已满。LRU驱逐 $t_1$。\n    - 被驱逐: $t_1$。\n    - 组0状态: $[t_0, t_2]$。未命中数: $7$。\n12. **访问 $128$ ($t_1$):** 未命中（冲突性）。组0已满。LRU驱逐 $t_2$。\n    - 被驱逐: $t_2$。\n    - 组0状态: $[t_1, t_0]$。未命中数: $8$。\n\nLRU策略的总未命中数是 $M_{\\text{LRU}} = 8$。\n\n**第2部分：RAND替换策略模拟（使用确定性替代规则）**\n\n抛硬币结果为 $[\\,T, T, T, T, T, T, H, H\\,]$。$T$ 表示驱逐MRU，$H$ 表示驱逐LRU。我们维护一个驱逐计数器 $k$。\n\n1.  **访问 $0$ ($t_0$):** 未命中（强制性）。\n    - 组0状态: $[t_0]$。未命中数: $1$。\n2.  **访问 $128$ ($t_1$):** 未命中（强制性）。\n    - 组0状态: $[t_1, t_0]$。未命中数: $2$。\n3.  **访问 $256$ ($t_2$):** 未命中（冲突性）。第 $k=1$ 次驱逐。硬币结果为 $T$。驱逐MRU，即 $t_1$。\n    - 被驱逐: $t_1$。\n    - 组0状态: $[t_2, t_0]$。未命中数: $3$。\n4.  **访问 $0$ ($t_0$):** 命中。$t_0$ 在缓存中。它成为MRU。\n    - 组0状态: $[t_0, t_2]$。未命中数: $3$。\n5.  **访问 $128$ ($t_1$):** 未命中（冲突性）。第 $k=2$ 次驱逐。硬币结果为 $T$。驱逐MRU，即 $t_0$。\n    - 被驱逐: $t_0$。\n    - 组0状态: $[t_1, t_2]$。未命中数: $4$。\n6.  **访问 $0$ ($t_0$):** 未命中（冲突性）。第 $k=3$ 次驱逐。硬币结果为 $T$。驱逐MRU，即 $t_1$。\n    - 被驱逐: $t_1$。\n    - 组0状态: $[t_0, t_2]$。未命中数: $5$。\n7.  **访问 $128$ ($t_1$):** 未命中（冲突性）。第 $k=4$ 次驱逐。硬币结果为 $T$。驱逐MRU，即 $t_0$。\n    - 被驱逐: $t_0$。\n    - 组0状态: $[t_1, t_2]$。未命中数: $6$。\n8.  **访问 $0$ ($t_0$):** 未命中（冲突性）。第 $k=5$ 次驱逐。硬币结果为 $T$。驱逐MRU，即 $t_1$。\n    - 被驱逐: $t_1$。\n    - 组0状态: $[t_0, t_2]$。未命中数: $7$。\n9.  **访问 $128$ ($t_1$):** 未命中（冲突性）。第 $k=6$ 次驱逐。硬币结果为 $T$。驱逐MRU，即 $t_0$。\n    - 被驱逐: $t_0$。\n    - 组0状态: $[t_1, t_2]$。未命中数: $8$。\n10. **访问 $256$ ($t_2$):** 命中。$t_2$ 在缓存中。它成为MRU。\n    - 组0状态: $[t_2, t_1]$。未命中数: $8$。\n11. **访问 $0$ ($t_0$):** 未命中（冲突性）。第 $k=7$ 次驱逐。硬币结果为 $H$。驱逐LRU，即 $t_1$。\n    - 被驱逐: $t_1$。\n    - 组0状态: $[t_0, t_2]$。未命中数: $9$。\n12. **访问 $128$ ($t_1$):** 未命中（冲突性）。第 $k=8$ 次驱逐。硬币结果为 $H$。驱逐LRU，即 $t_2$。\n    - 被驱逐: $t_2$。\n    - 组0状态: $[t_1, t_0]$。未命中数: $10$。\n\nRAND策略的总未命中数是 $M_{\\text{rand}} = 10$。\n\n每次冲突被驱逐块的摘要：\n- **LRU策略：**\n  - 访问 $3$ ($t_2$): 驱逐 $t_0$\n  - 访问 $4$ ($t_0$): 驱逐 $t_1$\n  - 访问 $5$ ($t_1$): 驱逐 $t_2$\n  - 访问 $10$ ($t_2$): 驱逐 $t_0$\n  - 访问 $11$ ($t_0$): 驱逐 $t_1$\n  - 访问 $12$ ($t_1$): 驱逐 $t_2$\n- **RAND策略：**\n  - 访问 $3$ ($t_2$): 驱逐 $t_1$ (MRU)\n  - 访问 $5$ ($t_1$): 驱逐 $t_0$ (MRU)\n  - 访问 $6$ ($t_0$): 驱逐 $t_1$ (MRU)\n  - 访问 $7$ ($t_1$): 驱逐 $t_0$ (MRU)\n  - 访问 $8$ ($t_0$): 驱逐 $t_1$ (MRU)\n  - 访问 $9$ ($t_1$): 驱逐 $t_0$ (MRU)\n  - 访问 $11$ ($t_0$): 驱逐 $t_1$ (LRU)\n  - 访问 $12$ ($t_1$): 驱逐 $t_2$ (LRU)\n\n最后，我们计算所需的未命中数差值。\n差值 = $M_{\\text{rand}} - M_{\\text{LRU}} = 10 - 8 = 2$。",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "这个练习将挑战你从“分析者”转变为“设计者”，是检验你是否深度掌握缓存原理的试金石。你不再是被动地分析给定的地址序列，而是需要主动构建一个能导致最差性能的场景——缓存抖动 (cache thrashing)。通过计算能够确保每次访问都导致冲突缺失的内存访问步长 ($\\Delta$)，你将对缓存冲突的产生原因以及软件访问模式与硬件结构之间的相互作用有更深刻的理解 。",
            "id": "3625030",
            "problem": "一个物理索引、物理标记的数据缓存具有相联度 $A=2$、组数 $S=256$ 和块大小 $B=64$ 字节。其替换策略为最近最少使用（LRU）。你需要构建一个循环指针追逐（circular pointer-chasing）工作负载，在初始的强制填充（compulsory fills）之后，该工作负载在此缓存下维持等于 $1$ 的未命中率。假设每个节点由一个大小为 $w$ 字节的机器指针组成，并且对于所有节点，该指针都存储在其缓存块内的相同字偏移（word offset）处。还假设指针追逐过程会重复跟随下一指针字段以循环遍历这些节点。假设物理地址空间足够大，标记位（tag bits）可用且没有混叠（aliasing）约束。\n\n仅从组索引（set indexing）和块偏移（block offset）的核心定义出发，完成以下任务：\n\n1.  推导此缓存的地址分解，将其分解为块偏移位、组索引位和标记位。\n2.  设计一个由 $K=3$ 个节点地址 $\\{a_0,a_1,a_2\\}$ 组成的循环，其重复遍历在 LRU 策略下，对每次访问都会产生稳态未命中（steady-state miss），并解释为什么这个结果是由相联度和替换策略决定的。\n3.  为了使构造独立于特定的基地址对齐方式，确定最小正字节步长 $\\Delta$，使得如果将节点放置在地址 $a_i = a_0 + i\\,\\Delta$ 处（指针存储在每个块内的相同字偏移处），那么无论 $a_0$ 的值如何，所有节点都映射到相同的组和相同的块偏移。\n\n最终答案仅报告最小步长 $\\Delta$（以字节为单位）。无需四舍五入。最终答案以字节表示。",
            "solution": "该问题要求推导一个最小内存步长 $\\Delta$，该步长能保证一个指针追逐工作负载产生特定的缓存冲突模式，且与基地址无关。解决方案按规定分三个阶段进行：地址分解、冲突诱发访问模式分析以及步长 $\\Delta$ 的推导。\n\n给定的缓存参数如下：\n- 相联度：$A=2$\n- 组数：$S=256$\n- 块大小：$B=64$ 字节\n- 替换策略：最近最少使用（LRU）\n\n**1. 地址分解**\n\n在物理索引、物理标记（PIPT）的缓存中，一个物理地址被划分为三个连续的字段：标记（tag）、组索引（set index）和块偏移（block offset）。这些字段的大小由缓存的几何结构决定。\n\n块偏移字段包含地址的低位比特，用于标识缓存块内的特定字节。块偏移位数 $b$ 由块大小 $B$ 决定。\n$$b = \\log_2(B) = \\log_2(64) = \\log_2(2^6) = 6 \\text{ bits}$$\n因此，对于物理地址 `addr`，块偏移为 `addr mod B`，对应于地址的比特位 $[5:0]$。\n\n组索引字段包含紧邻块偏移位的高位比特。它用于选择内存块可能驻留在缓存中的特定组。组索引位数 $s$ 由组数 $S$ 决定。\n$$s = \\log_2(S) = \\log_2(256) = \\log_2(2^8) = 8 \\text{ bits}$$\n物理地址 `addr` 的组索引计算为 $\\lfloor \\text{addr} / B \\rfloor \\pmod S$。这对应于地址的比特位 $[13:6]$，因为 $s+b-1 = 8+6-1=13$。\n\n标记字段由物理地址所有剩余的高位比特组成。这些比特与数据块一起存储在缓存中，用于验证命中，区分可能映射到同一组的不同内存块。标记位数是 $t = P - s - b$，其中 $P$ 是物理地址的总位数。\n\n**2. 持续未命中的工作负载设计**\n\n通过一个系统性地在缓存块再次被访问之前就将其驱逐的工作负载，可以实现 $1$（即 $100\\%$）的稳态未命中率。这种现象被称为缓存颠簸（cache thrashing）或冲突未命中（conflict misses），它发生在并发访问的、映射到同一缓存组的内存位置数量超过该组的相联度时。\n\n问题指定了组相联度为 $A=2$ 以及一个由 $K=3$ 个不同节点地址 $\\{a_0, a_1, a_2\\}$ 组成的循环。要使此工作负载引起颠簸，所有三个地址必须映射到同一个缓存组。设该组为 $J$。替换策略是 LRU。访问序列是一个循环遍历：$a_0, a_1, a_2, a_0, a_1, a_2, \\dots$。\n\n让我们在初始的强制性未命中之后，追踪组 $J$ 的状态：\n1.  **访问 $a_0$：**未命中。加载包含 $a_0$ 的块。组 $J$：$\\{ \\text{block}(a_0) \\}$。LRU 顺序：$\\text{block}(a_0)$ 是最近使用的。\n2.  **访问 $a_1$：**未命中。加载包含 $a_1$ 的块。组 $J$：$\\{ \\text{block}(a_0), \\text{block}(a_1) \\}$。LRU 顺序：$\\text{block}(a_1)$、$\\text{block}(a_0)$。\n3.  **访问 $a_2$：**未命中。加载包含 $a_2$ 的块。组 $J$ 已满。最近最少使用的块 $\\text{block}(a_0)$ 被驱逐。组 $J$：$\\{ \\text{block}(a_2), \\text{block}(a_1) \\}$。LRU 顺序：$\\text{block}(a_2)$、$\\text{block}(a_1)$。\n4.  **访问 $a_0$：**未命中。$\\text{block}(a_0)$ 刚刚被驱逐。现在驱逐最近最少使用的块 $\\text{block}(a_1)$，为 $\\text{block}(a_0)$ 腾出空间。组 $J$：$\\{ \\text{block}(a_2), \\text{block}(a_0) \\}$。LRU 顺序：$\\text{block}(a_0)$、$\\text{block}(a_2)$。\n5.  **访问 $a_1$：**未命中。$\\text{block}(a_1)$ 刚刚被驱逐。驱逐最近最少使用的块 $\\text{block}(a_2)$。组 $J$：$\\{ \\text{block}(a_1), \\text{block}(a_0) \\}$。LRU 顺序：$\\text{block}(a_1)$、$\\text{block}(a_0)$。\n\n该模式无限重复。每次访问都是未命中，因为所需的块总是在两步之前被驱逐的那个。发生这种情况的原因是，竞争该组的地址数量（$K=3$）大于该组的容量（$A=2$）。\n\n**3. 最小步长推导**\n\n我们需要找到最小的正字节步长 $\\Delta$，使得对于任何基地址 $a_0$，地址 $a_i = a_0 + i\\,\\Delta$ 都满足两个属性：\n(i) 所有 $a_i$ 具有相同的块偏移。\n(ii) 所有 $a_i$ 映射到相同的组索引。\n\n让我们将这些条件形式化。对于任何整数 $i \\ge 0$ 和任何地址 $a_0$：\n\n**条件 (i)：相同的块偏移**\n地址 `addr` 的块偏移是 `addr mod B`。我们要求：\n$$(a_0 + i\\,\\Delta) \\pmod B = a_0 \\pmod B$$\n根据模运算的性质，这等价于：\n$$(i\\,\\Delta) \\pmod B = 0$$\n这个条件必须在与 $a_0$ 无关的情况下成立。为了使其在最小的非平凡情况 $i=1$ 下成立，我们必须有 $\\Delta \\pmod B = 0$。这意味着 $\\Delta$ 必须是块大小 $B$ 的整数倍。设 $\\Delta = k \\cdot B$，其中 $k$ 为某个正整数。如果 $\\Delta$ 是 $B$ 的倍数，那么对于任何整数 $i$，$i\\,\\Delta$ 也是 $B$ 的倍数，因此这个条件对所有 $i$ 都满足。\n\n**条件 (ii)：相同的组索引**\n地址 `addr` 的组索引是 $\\lfloor \\text{addr} / B \\rfloor \\pmod S$。我们要求：\n$$\\left\\lfloor \\frac{a_0 + i\\,\\Delta}{B} \\right\\rfloor \\pmod S = \\left\\lfloor \\frac{a_0}{B} \\right\\rfloor \\pmod S$$\n将条件 (i) 中的 $\\Delta = k \\cdot B$ 代入：\n$$\\left\\lfloor \\frac{a_0 + i \\cdot k \\cdot B}{B} \\right\\rfloor \\pmod S = \\left\\lfloor \\frac{a_0}{B} \\right\\rfloor \\pmod S$$\n简化下取整函数内部的表达式：\n$$\\left\\lfloor \\frac{a_0}{B} + i \\cdot k \\right\\rfloor \\pmod S = \\left\\lfloor \\frac{a_0}{B} \\right\\rfloor \\pmod S$$\n由于 $i \\cdot k$ 是一个整数，我们可以使用整数 $n$ 的属性 $\\lfloor x+n \\rfloor = \\lfloor x \\rfloor + n$：\n$$\\left( \\left\\lfloor \\frac{a_0}{B} \\right\\rfloor + i \\cdot k \\right) \\pmod S = \\left\\lfloor \\frac{a_0}{B} \\right\\rfloor \\pmod S$$\n这个等式成立当且仅当 $(i \\cdot k) \\pmod S = 0$。这个条件也必须独立于 $a_0$ 成立。在我们的构造中，我们有一个由 $K=3$ 个节点组成的循环，所以我们需要这个条件对 $i=1, 2$ 成立。\n对于 $i=1$：$k \\pmod S = 0$。这意味着 $k$ 必须是 $S$ 的倍数。\n对于 $i=2$：$(2k) \\pmod S = 0$。如果 $k$ 是 $S$ 的倍数，这个条件会自动满足。\n因此，对 $k$ 的约束是它必须是 $S$ 的倍数。\n\n我们寻求最小的正步长 $\\Delta$。这对应于找到满足条件的最小正整数 $k$。是 $S$ 的倍数的最小正整数是 $S$ 本身。\n$$k_{min} = S$$\n因此，最小步长 $\\Delta$ 是：\n$$\\Delta = k_{min} \\cdot B = S \\cdot B$$\n使用给定的值：\n$$S = 256$$\n$$B = 64$$\n$$\\Delta = 256 \\times 64 = 16384$$\n保证所有节点 $a_i = a_0 + i\\,\\Delta$ 映射到相同的组并具有相同的块偏移，且与 $a_0$ 的选择无关的最小正步长是 $16384$ 字节。",
            "answer": "$$\n\\boxed{16384}\n$$"
        }
    ]
}