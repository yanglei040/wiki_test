{
    "hands_on_practices": [
        {
            "introduction": "理解高速缓存工作原理的第一步是掌握物理地址如何被分解为标签、索引和块偏移。这个过程直接由缓存的几何结构（总容量、块大小和相联度）决定。通过这个练习，你将亲手计算这些关键参数，从而将抽象的缓存规范转化为具体的硬件实现蓝图。",
            "id": "3635260",
            "problem": "一个字节可寻址的处理器使用 $32$ 位物理地址和一个物理索引、物理标记的数据缓存。该缓存的总数据容量为 $32\\,\\mathrm{KiB}$，并使用大小为 $64\\,\\mathrm{B}$ 的块。该缓存是 $4$ 路组相联的。在考虑容量时，忽略所有元数据开销（如有效位、脏位或替换状态）。\n\n仅从物理地址被划分为一个 $t$ 位的标记字段、一个选择组的 $i$ 位索引字段和一个选择块内字节的 $o$ 位块偏移字段的基本定义出发，以及组相联将缓存组织成多个组，每个组包含固定数量的块，确定此缓存的标记大小 $t$、索引大小 $i$、块偏移大小 $o$ 以及组数 $S$ 的值。\n\n请以有序四元组 $\\left(t,\\, i,\\, o,\\, S\\right)$ 的形式给出您的最终答案。最终答案无需四舍五入，也不应包含单位。",
            "solution": "该问题在计算机组成与体系结构领域内表述清晰且具有科学依据。所有必要的参数都已提供，且没有矛盾之处。我们可以进行形式化的推导。\n\n该问题要求确定一个组相联缓存的四个参数：标记大小 $t$、索引大小 $i$、块偏移大小 $o$ 以及组数 $S$。解决方案源自于支配缓存存储器组织的基本原理。一个物理地址被划分为三个字段：标记、索引和块偏移。\n\n物理地址的总大小给定为 $32$ 位。这给出了主要关系式：\n$$t + i + o = 32$$\n\n我们将按逻辑顺序确定参数 $o$、$i$、$S$ 以及最后的 $t$。\n\n首先，我们确定块偏移大小 $o$。处理器是字节可寻址的，一个缓存块包含多个字节。块偏移是地址中用于选择块内特定字节的部分。偏移所需的位数 $o$ 由块大小 $B$ 决定。\n给定的块大小为 $B = 64\\,\\mathrm{B}$。要唯一地寻址 $64$ 个字节，我们需要的位数 $o$ 满足 $2^o = 64$。\n$$o = \\log_{2}(64) = \\log_{2}(2^{6}) = 6$$\n因此，块偏移字段长 $6$ 位。\n\n接下来，我们确定组数 $S$。缓存的总数据容量 $C$ 给定为 $32\\,\\mathrm{KiB}$，相联度 $k$ 给定为 $4$ 路。我们必须首先将缓存容量转换为字节。利用 $1\\,\\mathrm{KiB} = 2^{10}\\,\\mathrm{B} = 1024\\,\\mathrm{B}$ 这一事实：\n$$C = 32\\,\\mathrm{KiB} = 32 \\times 2^{10}\\,\\mathrm{B} = 2^{5} \\times 2^{10}\\,\\mathrm{B} = 2^{15}\\,\\mathrm{B}$$\n缓存中的总块数 $N_{blocks}$ 是总容量除以块大小：\n$$N_{blocks} = \\frac{C}{B} = \\frac{2^{15}\\,\\mathrm{B}}{64\\,\\mathrm{B}} = \\frac{2^{15}}{2^{6}} = 2^{15-6} = 2^{9} = 512$$\n所以，该缓存总共包含 $512$ 个块。\n在一个 $k$ 路组相联缓存中，这些块被组织成多个组，每个组包含 $k$ 个块。组数 $S$ 是总块数除以相联度 $k$。\n$$S = \\frac{N_{blocks}}{k} = \\frac{512}{4} = \\frac{2^{9}}{2^{2}} = 2^{9-2} = 2^{7} = 128$$\n该缓存有 $128$ 个组。\n\n现在我们可以确定索引大小 $i$。地址的索引字段用于选择一个内存块映射到 $S$ 个组中的哪一个。索引所需的位数 $i$ 由组数决定。\n$$i = \\log_{2}(S) = \\log_{2}(128) = \\log_{2}(2^{7}) = 7$$\n因此，索引字段长 $7$ 位。\n\n最后，我们确定标记大小 $t$。物理地址的剩余位构成了标记。我们使用物理地址划分的初始关系式：\n$$t + i + o = 32$$\n代入我们已经求出的 $i$ 和 $o$ 的值：\n$$t + 7 + 6 = 32$$\n$$t + 13 = 32$$\n$$t = 32 - 13 = 19$$\n标记字段长 $19$ 位。\n\n总而言之，计算出的缓存参数为：\n- 标记大小，$t = 19$ 位。\n- 索引大小，$i = 7$ 位。\n- 块偏移大小，$o = 6$ 位。\n- 组数，$S = 128$。\n\n最终答案要求以有序四元组 $(t, i, o, S)$ 的形式给出。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n19  7  6  128\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "缓存的设计选择会直接影响性能，直接映射缓存虽然简单，但容易出现“缓存抖动”（thrashing）现象。本练习将引导你构建一个导致最大化冲突的访问模式，并量化其对平均内存访问时间（AMAT）的影响，让你深刻体会到地址映射策略与系统性能之间的密切联系。",
            "id": "3625110",
            "problem": "一台字节寻址的机器使用单级直接映射缓存，其相联度 $A=1$，组数 $S=64$，块大小 $B=64$ 字节。缓存初始为空。考虑对对齐块的只读访问。您将分析一个特意设计的、周期为2的对抗性访问模式，该模式会使此缓存发生最大程度的颠簸。\n\n任务：\n1) 构造两个不同的块对齐地址 $x$ 和 $y$，使得重复交替访问 $x,y,x,y,\\dots$ 在此直接映射缓存中产生最大程度的颠簸。请通过以下方式证明您的选择是合理的：使用将块地址 $\\lfloor \\text{addr}/B \\rfloor$ 分解为组索引（在 $\\{0,\\dots,S-1\\}$ 内）和标记的标准方法，为 $x$ 和 $y$ 显式计算组索引和标记，并证明这两个块映射到同一组但具有不同的标记。\n\n2) 从空缓存开始，根据第一性原理，论证交替访问序列 $x,y,x,y,\\dots$ 的稳态缺失率必然是多少。\n\n3) 给定缓存命中时间 $t_{h}=0.85$ 纳秒和缺失代价 $t_{m}=73.6$ 纳秒（定义为发生缺失时在命中时间之外的额外延迟），计算稳态下交替访问序列的平均内存访问时间 (AMAT)。以纳秒为单位表示您最终的 AMAT，并将答案四舍五入到四位有效数字。\n\n您最终提交的答案必须是按上述要求计算出的 AMAT 的单一数值。所有的中间推理过程，包括您为所选的 $x$ 和 $y$ 提供的映射合理性证明，都应在您的演算过程中展示出来。",
            "solution": "首先验证问题，以确保其是自洽的、有科学依据且良构的。\n\n**步骤1：提取已知条件**\n- 机器寻址：字节寻址\n- 缓存级别：单级\n- 缓存映射：直接映射（相联度 $A=1$）\n- 缓存组数：$S=64$\n- 块大小：$B=64$ 字节\n- 初始缓存状态：空\n- 访问特性：只读，对齐块\n- 访问序列：重复交替访问 $x, y, x, y, \\dots$\n- 目标：最大化颠簸\n- 缓存命中时间：$t_h=0.85$ 纳秒\n- 缓存缺失代价：$t_m=73.6$ 纳秒（定义为命中时间之外的额外延迟）\n\n**步骤2：使用提取的已知条件进行验证**\n该问题具有科学依据，因为它涉及计算机体系结构的基本原理，特别是缓存组织和性能评估。给定的参数（$S=64$，$B=64$ 字节，$A=1$）对于一个简单的缓存模型是标准且现实的。所使用的术语，如“字节寻址”、“直接映射”、“块大小”、“缺失代价”和“AMAT”，都是精确和标准的。该问题是良构的；它要求构造一个示例来演示一种特定行为（颠簸），并计算一个由此产生的性能指标（AMAT），为此提供了所有必要的数据。“缺失代价”被明确定义为*额外*时间，消除了歧义。该问题是客观、完整的，并且不包含任何矛盾或不符合科学原理的前提。\n\n**结论：**问题有效。\n\n**解题过程**\n\n按照题目要求，分析过程分为三个部分。\n\n**第1部分：为实现最大颠簸构造地址**\n\n一个内存地址被划分为三个字段：标记、组索引和块内偏移。我们首先确定每个字段的位数。\n该机器是字节寻址的。\n块大小为 $B=64$ 字节。块内偏移的位数为 $\\log_2(B) = \\log_2(64) = 6$ 位。\n组数为 $S=64$。组索引的位数为 $\\log_2(S) = \\log_2(64) = 6$ 位。\n地址中余下的高位构成了标记。\n\n一个地址 `addr` 通过以下组索引公式映射到缓存中的一个组：\n$$ \\text{Set Index} = \\left\\lfloor \\frac{\\text{addr}}{B} \\right\\rfloor \\pmod S $$\n标记计算如下：\n$$ \\text{Tag} = \\left\\lfloor \\frac{\\left\\lfloor \\frac{\\text{addr}}{B} \\right\\rfloor}{S} \\right\\rfloor = \\left\\lfloor \\frac{\\text{addr}}{B \\times S} \\right\\rfloor $$\n项 $\\lfloor \\text{addr}/B \\rfloor$ 是块地址。\n\n对于直接映射缓存，在交替访问模式 $x,y,x,y,\\dots$ 下，当与地址 $x$ 和 $y$ 对应的内存块映射到同一个缓存组但又是不同的块（即具有不同的标记）时，会发生最大程度的颠簸。这确保了每次访问都会驱逐下一次访问所需要的块。\n\n问题指出访问的是对齐的块。如果一个地址 `addr` 是块大小 $B$ 的倍数，那么它就是块对齐的。这意味着 $\\text{addr} \\pmod B = 0$。\n\n我们需要找到两个不同的块对齐地址 $x$ 和 $y$，使得：\n1. $\\text{SetIndex}(x) = \\text{SetIndex}(y)$\n2. $\\text{Tag}(x) \\neq \\text{Tag}(y)$\n\n我们任意选择一个组索引，例如，第1组。\n我们需要 $\\lfloor x/B \\rfloor \\pmod S = 1$ 并且 $\\lfloor y/B \\rfloor \\pmod S = 1$。\n\n让我们构造地址 $x$。我们选择映射到第1组的最简单的块地址，即块地址1。\n令 $\\lfloor x/B \\rfloor = 1$。由于 $x$ 必须是块对齐的，我们得到 $x = 1 \\times B = 1 \\times 64 = 64$。\n对于 $x=64$：\n- 块地址：$\\lfloor 64/64 \\rfloor = 1$。\n- 组索引：$1 \\pmod{64} = 1$。\n- 标记：$\\lfloor 1/64 \\rfloor = 0$。\n\n现在，我们构造地址 $y$。我们需要另一个也映射到第1组但具有不同标记的块地址。这意味着块地址必须是 $k \\cdot S + 1$ 的形式，其中 $k$ 是某个整数，并且标记 $\\lfloor (k \\cdot S + 1)/S \\rfloor = k$ 与 $x$ 的标记 $0$ 不同。\n我们选择最简单的非零整数 $k$，即 $k=1$。\n新的块地址是 $1 \\cdot S + 1 = 1 \\cdot 64 + 1 = 65$。\n令 $\\lfloor y/B \\rfloor = 65$。由于 $y$ 必须是块对齐的，我们得到 $y = 65 \\times B = 65 \\times 64 = 4160$。\n对于 $y=4160$：\n- 块地址：$\\lfloor 4160/64 \\rfloor = 65$。\n- 组索引：$65 \\pmod{64} = 1$。\n- 标记：$\\lfloor 65/64 \\rfloor = 1$。\n\n所选的地址是 $x=64$ 和 $y=4160$。两者都是块对齐的。它们都映射到组索引1。它们的标记（0和1）不同。因此，它们满足了引起最大颠簸的所有条件。\n\n**第2部分：稳态缺失率**\n\n我们从一个空缓存开始分析访问序列 $x,y,x,y,\\dots$。\n1. 访问 $x$：缓存为空。这是一次强制性缺失。包含地址 $x$ 的块从内存中取出并放入第1组。存储在第1组中的标记是 $\\text{Tag}(x)$。\n2. 访问 $y$：处理器请求地址 $y$。硬件检查第1组。存储在第1组中的标记是 $\\text{Tag}(x)$，与 $\\text{Tag}(y)$ 不匹配。这是一次冲突缺失。$x$ 的块被驱逐，$y$ 的块被取来并放入第1组。标记更新为 $\\text{Tag}(y)$。\n3. 访问 $x$：处理器请求地址 $x$。硬件检查第1组。现在存储的标记是 $\\text{Tag}(y)$，与 $\\text{Tag}(x)$ 不匹配。这是另一次冲突缺失。$y$ 的块被驱逐，并被 $x$ 的块替换。\n4. 访问 $y$：这次访问将再次是冲突缺失，驱逐 $x$ 的块。\n\n在第一次访问之后就达到了稳态。在这种状态下，随后的每一次访问都会导致冲突缺失。当前访问所需的块永远不会是缓存中存在的那个，因为它已被紧邻的前一次访问所驱逐。\n因此，在稳态下，每次访问都是一次缺失。\n缺失率是缺失次数与总访问次数的比率。在稳态下，这个比率是 $1/1$。\n$$ \\text{Miss Rate} = 1 $$\n\n**第3部分：平均内存访问时间 (AMAT)**\n\n平均内存访问时间 (AMAT) 是命中时间和缺失时间的加权平均值。通用公式是：\n$$ \\text{AMAT} = (\\text{Hit Rate} \\times \\text{Time}_\\text{hit}) + (\\text{Miss Rate} \\times \\text{Time}_\\text{miss}) $$\n问题将缺失代价 ($t_m$) 定义为发生缺失时，在命中时间 ($t_h$) 之外所需的*额外*时间。\n因此，$\\text{Time}_\\text{hit} = t_h$。\n并且 $\\text{Time}_\\text{miss} = t_h + t_m$。\n\n将这些代入 AMAT 公式：\n$$ \\text{AMAT} = ((1 - \\text{Miss Rate}) \\times t_h) + (\\text{Miss Rate} \\times (t_h + t_m)) $$\n简化这个表达式：\n$$ \\text{AMAT} = t_h - (\\text{Miss Rate} \\times t_h) + (\\text{Miss Rate} \\times t_h) + (\\text{Miss Rate} \\times t_m) $$\n$$ \\text{AMAT} = t_h + (\\text{Miss Rate} \\times t_m) $$\n\n我们已知以下值：\n- 命中时间 $t_h = 0.85$ 纳秒。\n- 缺失代价 $t_m = 73.6$ 纳秒。\n- 从第2部分可知，稳态缺失率为 $1$。\n\n将这些值代入推导出的公式：\n$$ \\text{AMAT} = 0.85 + (1 \\times 73.6) $$\n$$ \\text{AMAT} = 0.85 + 73.6 $$\n$$ \\text{AMAT} = 74.45 \\text{ ns} $$\n\n问题要求答案四舍五入到四位有效数字。计算出的值 $74.45$ 已经恰好是四位有效数字。",
            "answer": "$$\\boxed{74.45}$$"
        },
        {
            "introduction": "为了缓解直接映射缓存的冲突问题，我们引入了组相联缓存，但这又带来了新的设计抉择：当一个缓存组已满时，应替换哪一个块？本练习将通过一个精心设计的地址序列，让你模拟并比较最近最少使用（LRU）策略和随机替换策略的行为。通过这个对比，你将看到不同的替换策略如何影响命中率，从而理解其在缓存设计中的重要性。",
            "id": "3635229",
            "problem": "考虑一个 $32$ 位系统上的缓存，配置为一个 $2$ 路组相联缓存，有 $S=2$ 个组（每组 $E=2$ 行），块大小为 $B=64$ 字节。内存地址 $a$ 的组索引由基本映射规则 $i=\\left\\lfloor \\frac{a}{B} \\right\\rfloor \\bmod S$ 定义，标签是 $\\left\\lfloor \\frac{a}{B} \\right\\rfloor$ 的剩余高位。假设冷启动（缓存初始为空）、未命中时写分配，并且只有读操作发生。精确定义替换策略：最近最少使用（LRU）总是驱逐其组内最长时间未被使用的块所在的行；随机替换（RAND）在需要驱逐时，在组内的 $E$ 行中均匀选择。为了可复现性，当 RAND 必须驱逐时，使用以下确定性的随机性替代方案：对于跟踪中遇到的第 $k$ 次驱逐，提供一个固定的硬币抛掷结果 $c_{k} \\in \\{H,T\\}$，其中 $H$ 表示驱逐最近最少使用（LRU）的行，而 $T$ 表示驱逐最近最多使用（MRU）的行。\n\n给定以下地址跟踪（以字节为单位）：\n$$[\\,0,\\;128,\\;256,\\;0,\\;128,\\;0,\\;128,\\;0,\\;128,\\;256,\\;0,\\;128\\,]$$\n以及RAND策略按驱逐顺序对应的硬币抛掷结果：\n$$[\\,T,\\;T,\\;T,\\;T,\\;T,\\;T,\\;H,\\;H\\,].$$\n\n任务：\n- 仅使用上述组相联缓存和替换策略的基本定义，确定在LRU策略下的总未命中次数 $M_{\\text{LRU}}$，以及在使用固定结果的RAND策略下的总未命中次数 $M_{\\text{rand}}$。\n- 对于每次冲突（当目标组已满时发生的访问未命中），准确指出在LRU和RAND策略下哪个块被驱逐。\n- 将你的最终答案表示为单个标量差值 $M_{\\text{rand}} - M_{\\text{LRU}}$。无需四舍五入，也无需单位。",
            "solution": "问题陈述已经过验证，是合理的。这是一个在计算机组成和体系结构领域中定义明确的问题，包含了唯一解所需的所有必要参数、定义和数据。该设置遵循了缓存存储器操作的既定原则。\n\n问题的核心是模拟一个 $2$ 路组相联缓存在两种不同的替换策略下（最近最少使用（LRU）和一个确定性的随机（RAND）变体）对给定内存地址跟踪的行为。\n\n首先，我们必须分析缓存的几何结构和内存地址映射。\n系统使用 $32$ 位地址。\n缓存参数如下：\n- 组数，$S = 2$。\n- 相联度（每组的行数），$E = 2$。\n- 块大小，$B = 64$ 字节。\n\n块内偏移所需的位数是 $\\log_2(B) = \\log_2(64) = 6$ 位。\n组索引所需的位数是 $\\log_2(S) = \\log_2(2) = 1$ 位。\n剩余的位数用于标签：$32 - 6 - 1 = 25$ 位。\n\n字节地址 $a$ 的组索引 $i$ 由 $i = \\lfloor \\frac{a}{B} \\rfloor \\bmod S$ 给出。\n标签 $t$ 是块地址 $\\lfloor \\frac{a}{B} \\rfloor$ 的高位部分，具体来说是 $t = \\left\\lfloor \\frac{\\lfloor a/B \\rfloor}{S} \\right\\rfloor = \\left\\lfloor \\frac{a}{B \\times S} \\right\\rfloor$。\n当 $B=64$ 和 $S=2$ 时，公式为：\n- 组索引: $i = \\lfloor \\frac{a}{64} \\rfloor \\bmod 2$。\n- 标签: $t = \\lfloor \\frac{a}{128} \\rfloor$。\n\n我们来计算跟踪中唯一地址 $[\\,0, 128, 256\\,]$ 的组索引和标签。\n- 对于地址 $a=0$：\n  - 块地址: $\\lfloor 0/64 \\rfloor = 0$。\n  - 组索引: $0 \\bmod 2 = 0$。\n  - 标签: $\\lfloor 0/128 \\rfloor = 0$。我们将其表示为 $t_0$。\n- 对于地址 $a=128$：\n  - 块地址: $\\lfloor 128/64 \\rfloor = 2$。\n  - 组索引: $2 \\bmod 2 = 0$。\n  - 标签: $\\lfloor 128/128 \\rfloor = 1$。我们将其表示为 $t_1$。\n- 对于地址 $a=256$：\n  - 块地址: $\\lfloor 256/64 \\rfloor = 4$。\n  - 组索引: $4 \\bmod 2 = 0$。\n  - 标签: $\\lfloor 256/128 \\rfloor = 2$。我们将其表示为 $t_2$。\n\n所有三个唯一的内存块都映射到组 $0$。组 $1$ 在整个模拟过程中将保持为空。我们只需要跟踪组 $0$ 的状态，它有 $E=2$ 行。以标签表示的地址跟踪是：$[\\,t_0, t_1, t_2, t_0, t_1, t_0, t_1, t_0, t_1, t_2, t_0, t_1\\,]$。\n\n**第1部分：LRU替换策略模拟**\n\n我们跟踪组 $0$ 的内容及其最近使用情况。状态表示为一个有序列表 `[MRU, LRU]`。缓存初始为空。\n\n1.  **访问 $0$ ($t_0$):** 未命中（强制性）。组 $0$ 未满。\n    - 组 $0$ 状态: $[t_0]$。未命中次数: $1$。\n2.  **访问 $128$ ($t_1$):** 未命中（强制性）。组 $0$ 未满。\n    - 组 $0$ 状态: $[t_1, t_0]$。未命中次数: $2$。\n3.  **访问 $256$ ($t_2$):** 未命中（冲突）。组 $0$ 已满。LRU驱逐LRU块，即 $t_0$。\n    - 被驱逐: $t_0$。\n    - 组 $0$ 状态: $[t_2, t_1]$。未命中次数: $3$。\n4.  **访问 $0$ ($t_0$):** 未命中（冲突）。组 $0$ 已满。LRU驱逐 $t_1$。\n    - 被驱逐: $t_1$。\n    - 组 $0$ 状态: $[t_0, t_2]$。未命中次数: $4$。\n5.  **访问 $128$ ($t_1$):** 未命中（冲突）。组 $0$ 已满。LRU驱逐 $t_2$。\n    - 被驱逐: $t_2$。\n    - 组 $0$ 状态: $[t_1, t_0]$。未命中次数: $5$。\n6.  **访问 $0$ ($t_0$):** 命中。$t_0$ 在缓存中。它成为MRU。\n    - 组 $0$ 状态: $[t_0, t_1]$。未命中次数: $5$。\n7.  **访问 $128$ ($t_1$):** 命中。$t_1$ 在缓存中。它成为MRU。\n    - 组 $0$ 状态: $[t_1, t_0]$。未命中次数: $5$。\n8.  **访问 $0$ ($t_0$):** 命中。$t_0$ 在缓存中。它成为MRU。\n    - 组 $0$ 状态: $[t_0, t_1]$。未命中次数: $5$。\n9.  **访问 $128$ ($t_1$):** 命中。$t_1$ 在缓存中。它成为MRU。\n    - 组 $0$ 状态: $[t_1, t_0]$。未命中次数: $5$。\n10. **访问 $256$ ($t_2$):** 未命中（冲突）。组 $0$ 已满。LRU驱逐 $t_0$。\n    - 被驱逐: $t_0$。\n    - 组 $0$ 状态: $[t_2, t_1]$。未命中次数: $6$。\n11. **访问 $0$ ($t_0$):** 未命中（冲突）。组 $0$ 已满。LRU驱逐 $t_1$。\n    - 被驱逐: $t_1$。\n    - 组 $0$ 状态: $[t_0, t_2]$。未命中次数: $7$。\n12. **访问 $128$ ($t_1$):** 未命中（冲突）。组 $0$ 已满。LRU驱逐 $t_2$。\n    - 被驱逐: $t_2$。\n    - 组 $0$ 状态: $[t_1, t_0]$。未命中次数: $8$。\n\nLRU策略的总未命中次数为 $M_{\\text{LRU}} = 8$。\n\n**第2部分：RAND替换策略模拟（使用确定性替代方案）**\n\n硬币抛掷结果为 $[\\,T, T, T, T, T, T, H, H\\,]$。$T$ 表示驱逐MRU， $H$ 表示驱逐LRU。我们维护一个驱逐计数器 $k$。\n\n1.  **访问 $0$ ($t_0$):** 未命中（强制性）。\n    - 组 $0$ 状态: $[t_0]$。未命中次数: $1$。\n2.  **访问 $128$ ($t_1$):** 未命中（强制性）。\n    - 组 $0$ 状态: $[t_1, t_0]$。未命中次数: $2$。\n3.  **访问 $256$ ($t_2$):** 未命中（冲突）。第 $k=1$ 次驱逐。硬币结果为 $T$。驱逐MRU，即 $t_1$。\n    - 被驱逐: $t_1$。\n    - 组 $0$ 状态: $[t_2, t_0]$。未命中次数: $3$。\n4.  **访问 $0$ ($t_0$):** 命中。$t_0$ 在缓存中。它成为MRU。\n    - 组 $0$ 状态: $[t_0, t_2]$。未命中次数: $3$。\n5.  **访问 $128$ ($t_1$):** 未命中（冲突）。第 $k=2$ 次驱逐。硬币结果为 $T$。驱逐MRU，即 $t_0$。\n    - 被驱逐: $t_0$。\n    - 组 $0$ 状态: $[t_1, t_2]$。未命中次数: $4$。\n6.  **访问 $0$ ($t_0$):** 未命中（冲突）。第 $k=3$ 次驱逐。硬币结果为 $T$。驱逐MRU，即 $t_1$。\n    - 被驱逐: $t_1$。\n    - 组 $0$ 状态: $[t_0, t_2]$。未命中次数: $5$。\n7.  **访问 $128$ ($t_1$):** 未命中（冲突）。第 $k=4$ 次驱逐。硬币结果为 $T$。驱逐MRU，即 $t_0$。\n    - 被驱逐: $t_0$。\n    - 组 $0$ 状态: $[t_1, t_2]$。未命中次数: $6$。\n8.  **访问 $0$ ($t_0$):** 未命中（冲突）。第 $k=5$ 次驱逐。硬币结果为 $T$。驱逐MRU，即 $t_1$。\n    - 被驱逐: $t_1$。\n    - 组 $0$ 状态: $[t_0, t_2]$。未命中次数: $7$。\n9.  **访问 $128$ ($t_1$):** 未命中（冲突）。第 $k=6$ 次驱逐。硬币结果为 $T$。驱逐MRU，即 $t_0$。\n    - 被驱逐: $t_0$。\n    - 组 $0$ 状态: $[t_1, t_2]$。未命中次数: $8$。\n10. **访问 $256$ ($t_2$):** 命中。$t_2$ 在缓存中。它成为MRU。\n    - 组 $0$ 状态: $[t_2, t_1]$。未命中次数: $8$。\n11. **访问 $0$ ($t_0$):** 未命中（冲突）。第 $k=7$ 次驱逐。硬币结果为 $H$。驱逐LRU，即 $t_1$。\n    - 被驱逐: $t_1$。\n    - 组 $0$ 状态: $[t_0, t_2]$。未命中次数: $9$。\n12. **访问 $128$ ($t_1$):** 未命中（冲突）。第 $k=8$ 次驱逐。硬币结果为 $H$。驱逐LRU，即 $t_2$。\n    - 被驱逐: $t_2$。\n    - 组 $0$ 状态: $[t_1, t_0]$。未命中次数: $10$。\n\nRAND策略的总未命中次数为 $M_{\\text{rand}} = 10$。\n\n每次冲突时被驱逐块的摘要：\n- **LRU策略：**\n  - 访问 $3$ ($t_2$): 驱逐 $t_0$\n  - 访问 $4$ ($t_0$): 驱逐 $t_1$\n  - 访问 $5$ ($t_1$): 驱逐 $t_2$\n  - 访问 $10$ ($t_2$): 驱逐 $t_0$\n  - 访问 $11$ ($t_0$): 驱逐 $t_1$\n  - 访问 $12$ ($t_1$): 驱逐 $t_2$\n- **RAND策略：**\n  - 访问 $3$ ($t_2$): 驱逐 $t_1$ (MRU)\n  - 访问 $5$ ($t_1$): 驱逐 $t_0$ (MRU)\n  - 访问 $6$ ($t_0$): 驱逐 $t_1$ (MRU)\n  - 访问 $7$ ($t_1$): 驱逐 $t_0$ (MRU)\n  - 访问 $8$ ($t_0$): 驱逐 $t_1$ (MRU)\n  - 访问 $9$ ($t_1$): 驱逐 $t_0$ (MRU)\n  - 访问 $11$ ($t_0$): 驱逐 $t_1$ (LRU)\n  - 访问 $12$ ($t_1$): 驱逐 $t_2$ (LRU)\n\n最后，我们计算所需的未命中次数之差。\n差值 = $M_{\\text{rand}} - M_{\\text{LRU}} = 10 - 8 = 2$。",
            "answer": "$$\\boxed{2}$$"
        }
    ]
}