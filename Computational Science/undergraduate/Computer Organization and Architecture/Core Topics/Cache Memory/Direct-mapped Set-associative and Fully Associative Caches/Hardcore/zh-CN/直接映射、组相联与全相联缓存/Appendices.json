{
    "hands_on_practices": [
        {
            "introduction": "本练习旨在从零开始建立你的理解。我们将分离出两种关键缓存策略——写直通（write-through）和不按写分配（no write-allocate）——的影响，观察它们如何在独立于块大小等其他因素的情况下，决定缓存的行为和内存流量。这项实践将帮助你清晰地掌握控制缓存操作的基本定义。",
            "id": "3635228",
            "problem": "一个中央处理器（CPU）执行流式存储，将 $N$ 字节写入主存。CPU 按严格递增的顺序向连续地址 $A_0, A_0 + 1, \\ldots, A_0 + N - 1$ 发出逐字节的存储指令。存储层次结构包含一个单级直接映射缓存，其块大小为 $B$ 字节。该缓存使用写直通策略和不按写分配策略。缓存初始为空，没有其他内存操作（此流之外没有加载和存储操作），主存也处于空闲状态。假设缓存和内存没有会改变事件逻辑计数的延迟约束。\n\n仅从以下标准定义出发：(i) 写直通缓存将每次存储都转发到主存，以及 (ii) 不按写分配策略在存储未命中时不会将缓存块装入缓存。请推导出由该流式存储引起的写入主存的总次数和缓存未命中的总次数，并将它们表示为 $N$ 和 $B$ 的函数。\n\n请将你的最终答案表示为一个行矩阵，其中第一个条目等于写入主存的总次数，第二个条目等于缓存未命中的总次数。最终表达式无需四舍五入，也无需单位。",
            "solution": "对问题陈述进行分析后，我们确认其是有效的。它在科学上基于计算机体系结构的原理，问题设定良好，有足够的信息得出唯一解，且语言客观。因此，我们可以进行形式化推导。\n\n问题要求两个量：写入主存的总次数和缓存未命中的总次数。我们将推导这两个量作为写入的总字节数 $N$ 和缓存块大小 $B$ 的函数。\n\n**1. 写入主存的总次数**\n\n缓存被定义为采用**写直通**（write-through）策略。写直通缓存的基本定义是，CPU 发出的每一次存储操作都会立即传播到下一级存储层次结构，在本例中即为主存。无论存储操作导致缓存命中还是缓存未命中，此操作都会发生。\n\n问题指明，CPU通过逐字节发出存储指令来执行 $N$ 字节的流式存储。这对应于总共 $N$ 次独立的存储操作。由于写直通策略，这 $N$ 次存储操作中的每一次都会被转发到主存，因此写入主存的总次数恰好是 $N$。\n\n该结论仅取决于写直通策略和存储操作的次数。它与所有其他缓存参数无关，例如块大小 $B$、映射函数（直接映射）、分配策略以及缓存的初始状态。\n\n写入主存总次数 = $N$。\n\n**2. 缓存未命中的总次数**\n\n要确定缓存未命中的次数，我们必须分析存储操作和缓存策略之间的相互作用。相关策略是**写直通**（write-through）和**不按写分配**（no write-allocate）。缓存的初始状态为空。\n\n让我们考虑对连续地址 $A_0, A_0 + 1, \\ldots, A_0 + N - 1$ 的存储操作序列。\n\n第一次存储是到地址 $A_0$。由于缓存初始为空，不可能存在包含地址 $A_0$ 的块。因此，这第一次存储操作是**缓存未命中**（cache miss）。\n\n缓存使用**不按写分配**（no write-allocate）策略（也称为写不分配，write-no-allocate）。该策略的定义是，在发生存储未命中时，数据被写入下一级存储器（由写直通策略决定），但相应的内存块**不会**被取入并装入缓存。\n\n因此，在第一次对 $A_0$ 的存储导致未命中后，缓存仍然是空的。\n\n现在，考虑第二次存储，其目标地址是 $A_0 + 1$。由于缓存状态未被前一次存储改变，对于正在访问的数据而言，它实际上仍然是空的。因此，对 $A_0 + 1$ 的存储也是一次**缓存未命中**。同样，由于不按写分配策略，该地址对应的块不会被带入缓存。\n\n这个模式在流中的每一次存储操作中都会重复。对于任何到地址 $A_k = A_0 + k$（其中 $0 \\le k  N$）的存储，都会检查缓存。由于不按写分配策略阻止了因这一系列存储未命中而将任何块装入缓存，所以缓存中将不会包含地址 $A_k$ 的块。因此，每一次存储操作都将导致一次缓存未命中。\n\n由于 CPU 总共发出 $N$ 次存储操作，并且每一次都导致缓存未命中，所以缓存未命中的总次数是 $N$。\n\n与写入主存的次数类似，这个结果也与缓存块大小 $B$ 和直接映射组织方式无关，因为针对存储操作的不按写分配策略阻止了缓存状态发生任何可能为这一特定工作负载产生命中的变化。\n\n缓存未命中总次数 = $N$。\n\n结合这两个结果，我们得出写入主存的总次数是 $N$，缓存未命中的总次数也是 $N$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\nN  N\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "缓存设计涉及关键的权衡。本练习将探讨其中最基本的一个：在容量固定的情况下，我们应该构建一个拥有更多组（可能减少地址映射相距较远的冲突）的缓存，还是一个拥有更高相联度/路数（减少映射到同一组的地址冲突）的缓存？通过分析特定的内存访问模式，你将建立起关于缓存结构如何与程序行为相互作用以决定性能的直觉。",
            "id": "3635157",
            "problem": "一个数据缓存由以下参数描述：组数 $S$、相联度（路数）$E$、块大小 $B$ 字节以及物理地址宽度 $A$ 位。采用标准的组索引、标记比较结构，每个内存地址被划分为 $\\log_2 B$ 位的偏移量、$\\log_2 S$ 位的索引和 $A - \\log_2 S - \\log_2 B$ 位的标记。缓存行的总数为 $L = S \\cdot E$。替换策略为最近最少使用（LRU），定义为当向一个已满的组中插入新行时，驱逐该组内最近最少被引用的行。\n\n考虑两个总容量和块大小相同的缓存：缓存$\\mathcal{X}$有 $S$ 个组和 $E$ 路相联；缓存$\\mathcal{Y}$有 $2S$ 个组和 $E/2$ 路相联。两者都使用相同的块大小 $B$ 和相同的 LRU 策略。对于任意内存地址 $a$，定义块号 $n(a) = \\left\\lfloor \\dfrac{a}{B} \\right\\rfloor$，以及组索引映射：缓存$\\mathcal{X}$为 $i_{\\mathcal{X}}(a) = n(a) \\bmod S$，缓存$\\mathcal{Y}$为 $i_{\\mathcal{Y}}(a) = n(a) \\bmod (2S)$。\n\n你的任务是确定，在总行数不变的情况下，将 $S$ 加倍同时将 $E$ 减半会如何改变地址到组的映射和冲突行为，并找出哪些具体的工作负载能从更多的组或更多的路中受益。选择下面所有正确的陈述。\n\nA. 在缓存$\\mathcal{Y}$中，总行数相对于缓存$\\mathcal{X}$保持不变；索引字段增加 1 位，标记字段减少 1 位。\n\nB. 考虑一个交错访问流，它重复访问地址为 $a, a + S \\cdot B, a + 2S \\cdot B, \\dots$ 的块（对于某个基地址 $a$），但分为两个子流：偶数倍数 $a + 2p \\cdot S \\cdot B$ 和奇数倍数 $a + (2p+1) \\cdot S \\cdot B$，并以轮询方式交错。在缓存$\\mathcal{X}$中，两个子流都映射到同一个组；而在缓存$\\mathcal{Y}$中，偶数子流映射到组 $i$，奇数子流映射到组 $i + S$（模 $2S$），从而将每组的最大竞争从 $g_0 + g_1$ 减少到至多 $\\max\\{g_0, g_1\\}$，其中 $g_0$ 和 $g_1$ 分别是偶数和奇数子流携带的不同活动块的数量。因此，当 $g_0 \\le E/2$，$g_1 \\le E/2$，但 $g_0 + g_1 > E$ 时，缓存$\\mathcal{Y}$避免了困扰缓存$\\mathcal{X}$的冲突未命中。\n\nC. 考虑一个对 $k$ 个块的轮询访问流，这些块的地址为 $a, a + 2S \\cdot B, a + 4S \\cdot B, \\dots$，因此所有块在两个缓存中都映射到同一个组。如果 $E/2  k \\le E$，缓存$\\mathcal{X}$在一个组中容纳所有 $k$ 个块而没有冲突未命中（预热后），而缓存$\\mathcal{Y}$由于相联度不足而出现重复的冲突未命中。因此，这种工作负载从更多的路而不是更多的组中受益。\n\nD. 将 $S$ 加倍会使标记字段增加 1 位，索引字段减少 1 位；因此，缓存$\\mathcal{Y}$的标记比缓存$\\mathcal{X}$的更大。\n\nE. 对于任何步长为 $S \\cdot B$ 的交错访问流，缓存$\\mathcal{X}$和缓存$\\mathcal{Y}$都将所有引用映射到同一个组；因此，增加 $S$ 不会改变此类流的冲突模式。\n\n选择所有正确的选项。",
            "solution": "我们先来分解一下验证过程。\n\n### 第 1 步：提取已知条件\n\n-   缓存参数：组数 $S$、相联度（路数）$E$、块大小 $B$ 字节、物理地址宽度 $A$ 位。\n-   缓存行总数：$L = S \\cdot E$。\n-   地址划分：\n    -   偏移量：$\\log_2 B$ 位。\n    -   索引：$\\log_2 S$ 位。\n    -   标记：$A - \\log_2 S - \\log_2 B$ 位。\n-   替换策略：LRU (最近最少使用)。\n-   缓存$\\mathcal{X}$：$S$ 组，$E$ 路相联，块大小 $B$。总容量 $C_{\\mathcal{X}} = S \\cdot E \\cdot B$。\n-   缓存$\\mathcal{Y}$：$2S$ 组，$E/2$ 路相联，块大小 $B$。总容量 $C_{\\mathcal{Y}} = (2S) \\cdot (E/2) \\cdot B = S \\cdot E \\cdot B$。\n-   块号定义：$n(a) = \\lfloor a/B \\rfloor$。\n-   组索引映射：\n    -   缓存$\\mathcal{X}$：$i_{\\mathcal{X}}(a) = n(a) \\bmod S$。\n    -   缓存$\\mathcal{Y}$：$i_{\\mathcal{Y}}(a) = n(a) \\bmod (2S)$。\n-   问题要求确定将 $S$ 加倍和将 $E$ 减半如何影响地址映射和冲突行为，并找出哪些工作负载能从每种配置中受益。\n\n### 第 2 步：使用提取的已知条件进行验证\n\n1.  **科学上是否成立？** 是。问题描述了计算机体系结构和组织中的标准缓存组织概念（组、路、相联度、块大小、地址划分）。组索引映射的定义（$n(a) \\pmod{\\text{NumSets}}$）对于组相联缓存是标准的。LRU 是一种标准的替换策略。整个设置都牢固地建立在公认的计算机科学原理之上。\n\n2.  **问题是否定义良好？** 是。定义很清晰。缓存$\\mathcal{X}$和缓存$\\mathcal{Y}$的参数已明确给出。它们之间的关系也很清楚。问题要求基于这些定义评估几个陈述。可以对每个陈述进行独特而有意义的分析。\n\n3.  **是否客观？** 是。语言精确且技术性强。没有主观或基于观点的断言。\n\n4.  **缺陷清单：**\n    -   **科学/事实不健全：** 否。该模型是标准的缓存模型。\n    -   **不可形式化/不相关：** 否。问题完全可以形式化，并且与缓存组织的主题直接相关。\n    -   **不完整/矛盾：** 否。问题陈述两个缓存具有相同的总容量（$C = S \\cdot E \\cdot B$）和块大小（$B$）。\n        -   缓存$\\mathcal{X}$：$S$ 组，$E$ 路相联。\n        -   缓存$\\mathcal{Y}$：$S' = 2S$ 组，$E' = E/2$ 路相联。\n        -   $\\mathcal{X}$ 的容量是 $S \\cdot E \\cdot B$。\n        -   $\\mathcal{Y}$ 的容量是 $S' \\cdot E' \\cdot B = (2S) \\cdot (E/2) \\cdot B = S \\cdot E \\cdot B$。容量确实相同。\n        -   $\\mathcal{X}$ 中的总行数是 $L_{\\mathcal{X}} = S \\cdot E$。\n        -   $\\mathcal{Y}$ 中的总行数是 $L_{\\mathcal{Y}} = (2S) \\cdot (E/2) = S \\cdot E$。总行数也相同。\n        -   地址划分规则是标准的。问题描述是自洽的，并提供了分析陈述所需的所有必要信息。\n\n    -   **不切实际/不可行：** 否。这些是常见的缓存配置。参数关系（组数加倍，路数减半）是标准的设计权衡探索。\n\n    -   **提问不当/结构不良：** 否。问题是具体的，可以通过应用定义来回答。\n\n    -   **伪深刻/琐碎/同义反复：** 否。问题需要仔细分析地址映射如何变化，以及这种变化如何与特定的内存访问模式相互作用。这是计算机体系结构课程中常见的非平凡推理任务。\n\n    -   **超出科学可验证范围：** 否。结果可以通过计算和逻辑推导来验证。\n\n### 第 3 步：结论与行动\n\n此问题是 **有效的**。我将继续进行解答和逐项分析。\n\n---\n### 解题推导\n\n**分析两种缓存的地址划分。**\n\n设物理地址宽度为 $A$。一个地址被划分为（标记，索引，偏移量）。\n块大小为 $B$。偏移量位数为 $o = \\log_2 B$。\n块号为 $n(a) = \\lfloor a/B \\rfloor$。这对应于除去偏移量位的地址位。所以，$n(a) = a \\gg o$。\n\n**缓存$\\mathcal{X}$：**\n-   组数：$S_{\\mathcal{X}} = S$。\n-   索引位数：$i_{\\mathcal{X}} = \\log_2 S$。\n-   组索引由块号计算得出：$n(a) \\bmod S$。这对应于块号 $n(a)$ 的低 $i_{\\mathcal{X}}$ 位。\n-   标记位数：$t_{\\mathcal{X}} = A - i_{\\mathcal{X}} - o = A - \\log_2 S - \\log_2 B$。\n-   行数：$L_{\\mathcal{X}} = S \\cdot E$。\n\n**缓存$\\mathcal{Y}$：**\n-   组数：$S_{\\mathcal{Y}} = 2S$。\n-   索引位数：$i_{\\mathcal{Y}} = \\log_2(2S) = \\log_2 2 + \\log_2 S = 1 + \\log_2 S$。\n-   组索引由块号计算得出：$n(a) \\bmod (2S)$。这对应于块号 $n(a)$ 的低 $i_{\\mathcal{Y}}$ 位。\n-   标记位数：$t_{\\mathcal{Y}} = A - i_{\\mathcal{Y}} - o = A - (1 + \\log_2 S) - \\log_2 B = A - \\log_2 S - \\log_2 B - 1$。\n-   行数：$L_{\\mathcal{Y}} = (2S) \\cdot (E/2) = S \\cdot E$。\n\n**比较总结：**\n-   $S_{\\mathcal{Y}} = 2S_{\\mathcal{X}}$\n-   $E_{\\mathcal{Y}} = E_{\\mathcal{X}}/2$\n-   $L_{\\mathcal{Y}} = L_{\\mathcal{X}}$ (总行数相同)\n-   $i_{\\mathcal{Y}} = i_{\\mathcal{X}} + 1$ (索引字段宽 1 位)\n-   $t_{\\mathcal{Y}} = t_{\\mathcal{X}} - 1$ (标记字段窄 1 位)\n\n现在，我将评估每个选项。\n\n---\n### 选项 A 分析\n\n A. 在缓存$\\mathcal{Y}$中，总行数相对于缓存$\\mathcal{X}$保持不变；索引字段增加 1 位，标记字段减少 1 位。\n\n-   **总行数：**\n    -   缓存$\\mathcal{X}$有 $L_{\\mathcal{X}} = S \\cdot E$ 行。\n    -   缓存$\\mathcal{Y}$有 $L_{\\mathcal{Y}} = (2S) \\cdot (E/2) = S \\cdot E$ 行。\n    -   因此，$L_{\\mathcal{X}} = L_{\\mathcal{Y}}$。总行数不变。这部分是正确的。\n\n-   **索引和标记字段：**\n    -   缓存$\\mathcal{X}$的组数是 $S$，需要 $i_{\\mathcal{X}} = \\log_2 S$ 个索引位。\n    -   缓存$\\mathcal{Y}$的组数是 $2S$，需要 $i_{\\mathcal{Y}} = \\log_2(2S) = \\log_2 S + 1 = i_{\\mathcal{X}} + 1$ 个索引位。\n    -   索引字段增加了 1 位。这部分是正确的。\n    -   索引和标记的总位数是 $A - \\log_2 B$。由于索引字段增加了 1 位，标记字段必须减少 1 位以保持总和不变。\n    -   明确地说，$\\mathcal{X}$ 的标记位数是 $t_{\\mathcal{X}} = A - i_{\\mathcal{X}} - \\log_2 B$。\n    -   $\\mathcal{Y}$ 的标记位数是 $t_{\\mathcal{Y}} = A - i_{\\mathcal{Y}} - \\log_2 B = A - (i_{\\mathcal{X}} + 1) - \\log_2 B = t_{\\mathcal{X}} - 1$。\n    -   标记字段减少了 1 位。这部分是正确的。\n\n-   **选项 A 的结论**：该陈述与我们的推导完全一致。**正确**。\n\n---\n### 选项 B 分析\n\n B. 考虑一个交错访问流，它重复访问地址为 $a, a + S \\cdot B, a + 2S \\cdot B, \\dots$ 的块（对于某个基地址 $a$），但分为两个子流：偶数倍数 $a + 2p \\cdot S \\cdot B$ 和奇数倍数 $a + (2p+1) \\cdot S \\cdot B$，并以轮询方式交错。在缓存$\\mathcal{X}$中，两个子流都映射到同一个组；而在缓存$\\mathcal{Y}$中，偶数子流映射到组 $i$，奇数子流映射到组 $i + S$（模 $2S$），从而将每组的最大竞争从 $g_0 + g_1$ 减少到至多 $\\max\\{g_0, g_1\\}$，其中 $g_0$ 和 $g_1$ 分别是偶数和奇数子流携带的不同活动块的数量。因此，当 $g_0 \\le E/2$，$g_1 \\le E/2$，但 $g_0 + g_1 > E$ 时，缓存$\\mathcal{Y}$避免了困扰缓存$\\mathcal{X}$的冲突未命中。\n\n我们来分析地址 $a_k = a + k \\cdot S \\cdot B$ 的组映射。块号为 $n(a_k) = \\lfloor (a + k \\cdot S \\cdot B) / B \\rfloor = n(a) + kS$。\n\n-   **在缓存$\\mathcal{X}$中的映射：** 组索引为 $i_{\\mathcal{X}}(a_k) = n(a_k) \\bmod S = (n(a) + kS) \\bmod S = n(a) \\bmod S$。此流中的所有块，无论 $k$ 为何值，都映射到同一个组。因此，偶数（$k=2p$）和奇数（$k=2p+1$）子流都映射到这一个组。\n\n-   **在缓存$\\mathcal{Y}$中的映射：** 组索引为 $i_{\\mathcal{Y}}(a_k) = n(a_k) \\bmod (2S) = (n(a) + kS) \\bmod (2S)$。\n    -   对于偶数子流，$k=2p$：$i_{\\mathcal{Y}}(a_{2p}) = (n(a) + 2pS) \\bmod (2S) = n(a) \\bmod (2S)$。设此组为 $i$。\n    -   对于奇数子流，$k=2p+1$：$i_{\\mathcal{Y}}(a_{2p+1}) = (n(a) + (2p+1)S) \\bmod (2S) = (n(a) + S) \\bmod (2S)$。此组为 $i+S$（模 $2S$）。\n    -   由于对于任何正整数 $S$，$S \\not\\equiv 0 \\pmod{2S}$，这两个组索引是不同的。缓存$\\mathcal{Y}$有效地将交错流分离到两个不同的组中。\n\n-   **竞争分析：**\n    -   在缓存$\\mathcal{X}$中，来自偶数子流的 $g_0$ 个活动块和来自奇数子流的 $g_1$ 个活动块都在一个组的 $E$ 路中竞争。竞争块的总数为 $g_0 + g_1$。\n    -   在缓存$\\mathcal{Y}$中，$g_0$ 个块映射到一个组，$g_1$ 个块映射到另一个组。$\\mathcal{Y}$中的每个组有 $E/2$ 路。第一个组中的竞争在 $g_0$ 个块之间，第二个组中的竞争在 $g_1$ 个块之间。每组的最大竞争为 $\\max\\{g_0, g_1\\}$。\n\n-   **场景分析：** 给定 $g_0 \\le E/2$, $g_1 \\le E/2$, 且 $g_0 + g_1 > E$。\n    -   在缓存$\\mathcal{X}$中，$g_0 + g_1 > E$。块的数量超过了组的相联度，导致冲突未命中。\n    -   在缓存$\\mathcal{Y}$中，第一个组容纳 $g_0$ 个块。因为 $g_0 \\le E/2$（该组的相联度），这些块可以容纳。第二个组容纳 $g_1$ 个块。因为 $g_1 \\le E/2$，这些块也可以容纳。缓存$\\mathcal{Y}$避免了冲突未命中。\n\n-   **选项 B 的结论**：该陈述对一个工作负载进行了正确而深刻的分析，在该负载下，拥有更多组（缓存$\\mathcal{Y}$）相比拥有更多路（缓存$\\mathcal{X}$）能减少冲突未命中。**正确**。\n\n---\n### 选项 C 分析\n\n C. 考虑一个对 $k$ 个块的轮询访问流，这些块的地址为 $a, a + 2S \\cdot B, a + 4S \\cdot B, \\dots$，因此所有块在两个缓存中都映射到同一个组。如果 $E/2  k \\le E$，缓存$\\mathcal{X}$在一个组中容纳所有 $k$ 个块而没有冲突未命中（预热后），而缓存$\\mathcal{Y}$由于相联度不足而出现重复的冲突未命中。因此，这种工作负载从更多的路而不是更多的组中受益。\n\n我们来分析地址 $a_p = a + p \\cdot (2S) \\cdot B$ 的组映射。块号为 $n(a_p) = n(a) + p(2S)$。\n\n-   **在缓存$\\mathcal{X}$中的映射：** 组索引为 $i_{\\mathcal{X}}(a_p) = n(a_p) \\bmod S = (n(a) + p(2S)) \\bmod S$。由于 $p(2S)$ 是 $S$ 的倍数，这简化为 $n(a) \\bmod S$。所有 $k$ 个块都映射到同一个组。\n\n-   **在缓存$\\mathcal{Y}$中的映射：** 组索引为 $i_{\\mathcal{Y}}(a_p) = n(a_p) \\bmod (2S) = (n(a) + p(2S)) \\bmod (2S)$。由于 $p(2S)$ 是 $2S$ 的倍数，这简化为 $n(a) \\bmod (2S)$。所有 $k$ 个块都映射到同一个组。\n-   “所有块在两个缓存中都映射到同一个组”的前提是正确的。\n\n-   **竞争分析：** 工作负载是对 $k$ 个这样的块进行轮询访问，其中 $E/2  k \\le E$。\n    -   在缓存$\\mathcal{X}$中，这 $k$ 个块在其共享组的 $E$ 路中竞争。由于 $k \\le E$，有足够的路来同时存储所有 $k$ 个块。在预热阶段之后，所有访问都将命中。\n    -   在缓存$\\mathcal{Y}$中，这 $k$ 个块在其共享组的 $E/2$ 路中竞争。由于 $k > E/2$，块的数量超过了组的相联度。一旦加载了超过 $E/2$ 个块，每次新的访问都将驱逐一个先前加载的块（由于轮询模式和 LRU 策略），导致重复的冲突未命中。\n\n-   **结论：** 这种工作负载在缓存$\\mathcal{X}$上表现良好，但在缓存$\\mathcal{Y}$上表现不佳，这表明在某些场景下，更高的相联度比更多的组更有利。\n\n-   **选项 C 的结论**：该陈述准确描述了一个受益于更高相联度的工作负载，为选项 B 提供了一个正确的反例。**正确**。\n\n---\n### 选项 D 分析\n\n D. 将 $S$ 加倍会使标记字段增加 1 位，索引字段减少 1 位；因此，缓存$\\mathcal{Y}$的标记比缓存$\\mathcal{X}$的更大。\n\n这个陈述与我们最初的分析相矛盾。\n-   组数从 $S$ 增加到 $2S$。索引所需的位数从 $\\log_2 S$ 变为 $\\log_2(2S) = \\log_2 S + 1$。索引字段*增加*了 1 位，而不是减少。\n-   地址总位数是固定的（$A$）。偏移量位数也是固定的（$\\log_2 B$）。剩余的位用于标记和索引：$t+i = A - \\log_2 B$。如果索引位 $i$ 增加 1，标记位 $t$ 必须减少 1。所以标记字段*减少*了 1 位，而不是增加。\n-   “缓存$\\mathcal{Y}$的标记比缓存$\\mathcal{X}$的更大”的结论也是错误的；它的标记更小。\n\n-   **选项 D 的结论**：该陈述在每个方面都是错误的。**不正确**。\n\n---\n### 选项 E 分析\n\n E. 对于任何步长为 $S \\cdot B$ 的交错访问流，缓存$\\mathcal{X}$和缓存$\\mathcal{Y}$都将所有引用映射到同一个组；因此，增加 $S$ 不会改变此类流的冲突模式。\n\n这个陈述对步长为 $S \\cdot B$ 的访问流的映射做出了断言。正如在选项 B 中分析的，地址是 $a, a+S \\cdot B, a+2S \\cdot B, \\dots$。\n-   在缓存$\\mathcal{X}$中，所有这些地址都映射到一个单一的组，$n(a) \\bmod S$。\n-   在缓存$\\mathcal{Y}$中，这些地址在两个组之间交替映射：$n(a) \\bmod (2S)$ 和 $(n(a)+S) \\bmod (2S)$。\n-   “缓存$\\mathcal{X}$和缓存$\\mathcal{Y}$都将所有引用映射到同一个组”这个前提是错误的。它对 $\\mathcal{X}$ 成立，但对 $\\mathcal{Y}$ 不成立。\n-   因为前提是错误的，所以“因此，增加 $S$ 不会改变此类流的冲突模式”的结论不成立，也是错误的。正如选项 B 所证明的，将映射从一个组更改为两个组可以显著改变并改善冲突模式。\n\n-   **选项 E 的结论**：该陈述基于一个错误的前提，并得出了一个不正确的结论。**不正确**。",
            "answer": "$$\\boxed{ABC}$$"
        },
        {
            "introduction": "更低的未命中率总是更好吗？这个反直觉的练习将证明答案是“不”。我们将分析一个场景，其中直接映射缓存（具有更高的未命中率）凭借其更快的命中时间，性能可以超越组相联缓存（具有更低的未命中率）。通过计算平均访存时间（AMAT），你将学会如何综合权衡命中时间、未命中率和未命中惩罚，从而做出整体性的性能判断。",
            "id": "3635202",
            "problem": "一个单处理器系统使用一级（L1）数据缓存，并对四个固定的内存地址发出一个序列的内存引用。这些地址被构造成在特定的直接映射配置下发生冲突。考虑两种总容量和块（行）大小相同的L1缓存组织结构：\n- 缓存A：直接映射。\n- 缓存B：$4$-路组相联。\n\n两种缓存的总容量均为 $64$ 字节，块大小均为 $16$ 字节。假设缓存初始为空，并且 $4$-路缓存中的替换策略使用最近最少使用（LRU）。处理器执行以下重复的内存访问轨迹，总共进行 $100$ 次访问：\n$$\n\\text{轨迹：} a_0, a_1, a_2, a_3, a_0, a_1, a_2, a_3, \\ldots \\text{（重复这个4元素模式25次）}\n$$\n其中四个地址是\n$$\na_0 = 0,\\quad a_1 = 64,\\quad a_2 = 128,\\quad a_3 = 192 \\text{ 字节。}\n$$\n使用标准的块地址映射规则：块号为 $b = \\left\\lfloor \\frac{a}{16} \\right\\rfloor$，对于 $S$ 个组的直接映射缓存，其索引为 $i = b \\bmod S$。在 $4$-路组相联缓存中，组的数量为 $\\frac{C/B}{4}$，其中 $C$ 是总容量， $B$ 是块大小。假设直接映射缓存有 $S = \\frac{64/16}{1} = 4$ 个组，而 $4$-路缓存有 $1$ 个组。\n\n假设直接映射缓存的命中时间为 $t_{\\mathrm{DM}} = 1$ 个周期，而 $4$-路缓存的命中时间为 $t_{4\\mathrm{W}} = 3$ 个周期。在发生未命中时，缓存行由下一级存储器在 $t_{\\mathrm{mem}}$ 个周期内提供服务，您可以将此视为两个缓存共有的单个参数。\n\n平均内存访问时间（AMAT）定义为每次内存访问的期望时间，由命中和未命中及其各自的服务时间产生。仅使用此定义和上述映射规则：\n- 确定在 $100$ 次访问的轨迹中，缓存A和缓存B的未命中次数，并将其转换为未命中率。\n- 推导缓存A和缓存B的AMAT作为 $t_{\\mathrm{mem}}$ 的函数。\n- 求解交叉点值 $t_{\\mathrm{mem}}^{\\star}$（以周期为单位），在该值下两个AMAT相等。这个值界定了一个区域，在该区域内当 $t_{\\mathrm{mem}}  t_{\\mathrm{mem}}^{\\star}$ 时，直接映射缓存的较低命中时间优势超过了其较高的未命中率。\n\n以周期为单位表示 $t_{\\mathrm{mem}}^{\\star}$ 的最终答案。无需四舍五入；请提供精确值。",
            "solution": "我们从缓存映射和平均内存访问时间（AMAT）的核心定义开始。对于块大小为 $B$ 的地址 $a$，其块号为 $b = \\left\\lfloor \\frac{a}{B} \\right\\rfloor$。对于一个有 $S$ 个组的直接映射缓存，组索引为 $i = b \\bmod S$。对于一个总容量为 $C$ 且块大小为 $B$ 的 $4$-路组相联缓存，组的数量为 $\\frac{C/B}{4}$，并且组内的替换策略使用最近最少使用（LRU）。\n\n给定 $C = 64$ 字节和 $B = 16$ 字节，总行数为 $\\frac{C}{B} = \\frac{64}{16} = 4$。因此：\n- 直接映射缓存有 $S = 4$ 个组，每个组有 $1$ 路。\n- $4$-路缓存有 $\\frac{4}{4} = 1$ 个组，该组有 $4$ 路。\n\n计算这四个地址的块号：\n$$\nb_0 = \\left\\lfloor \\frac{0}{16} \\right\\rfloor = 0,\\quad\nb_1 = \\left\\lfloor \\frac{64}{16} \\right\\rfloor = 4,\\quad\nb_2 = \\left\\lfloor \\frac{128}{16} \\right\\rfloor = 8,\\quad\nb_3 = \\left\\lfloor \\frac{192}{16} \\right\\rfloor = 12.\n$$\n对于直接映射缓存，组索引为\n$$\ni_0 = 0 \\bmod 4 = 0,\\quad\ni_1 = 4 \\bmod 4 = 0,\\quad\ni_2 = 8 \\bmod 4 = 0,\\quad\ni_3 = 12 \\bmod 4 = 0.\n$$\n因此，在直接映射缓存中，所有四个块都映射到同一个组 $i = 0$。在 $4$-路组相联缓存中，只有一个包含 $4$ 路的组，因此所有四个块可以无冲突地同时驻留。\n\n现在分析由重复序列 $a_0, a_1, a_2, a_3$ 组成的、重复 $25$ 次的 $100$ 次访问轨迹。\n\n直接映射缓存的行为：\n- 缓存开始时为空。前四次访问是强制性未命中。\n- 因为所有四个块都映射到同一个单路组，所以每次访问都会驱逐该组中前一个块。\n- 由于序列从不连续访问同一个块，因此没有命中：每次访问都在组 $0$ 中找到错误的标签并发生未命中。\n因此，在 $100$ 次访问中，未命中次数为 $100$，未命中率为\n$$\n\\mathrm{MR}_{\\mathrm{DM}} = \\frac{100}{100} = 1.\n$$\n\n$4$-路组相联缓存的行为：\n- 缓存开始时为空。前四次访问 $a_0, a_1, a_2, a_3$ 是强制性未命中，并填满了单个组的四路。\n- 此后，重复的模式 $a_0, a_1, a_2, a_3$ 在缓存中命中，因为所有四个块都已驻留，并且没有引用其他不同的块。\n因此，在 $100$ 次访问中，未命中次数为 $4$，命中次数为 $96$，得出\n$$\n\\mathrm{MR}_{4\\mathrm{W}} = \\frac{4}{100} = 0.04.\n$$\n\n根据概念定义，平均内存访问时间（AMAT）是每次访问的期望时间，它结合了命中时间和期望的未命中服务时间。已知命中时间为 $t_{\\mathrm{DM}} = 1$ 个周期和 $t_{4\\mathrm{W}} = 3$ 个周期，以及两个缓存共有的未命中服务时间 $t_{\\mathrm{mem}}$ 个周期，我们写出：\n$$\n\\mathrm{AMAT}_{\\mathrm{DM}}(t_{\\mathrm{mem}}) = t_{\\mathrm{DM}} + \\mathrm{MR}_{\\mathrm{DM}} \\cdot t_{\\mathrm{mem}} = 1 + 1 \\cdot t_{\\mathrm{mem}} = 1 + t_{\\mathrm{mem}},\n$$\n$$\n\\mathrm{AMAT}_{4\\mathrm{W}}(t_{\\mathrm{mem}}) = t_{4\\mathrm{W}} + \\mathrm{MR}_{4\\mathrm{W}} \\cdot t_{\\mathrm{mem}} = 3 + 0.04 \\cdot t_{\\mathrm{mem}}.\n$$\n\n为了找到两个AMAT相等的交叉点 $t_{\\mathrm{mem}}^{\\star}$，求解\n$$\n1 + t_{\\mathrm{mem}}^{\\star} = 3 + 0.04\\, t_{\\mathrm{mem}}^{\\star}.\n$$\n重新整理：\n$$\nt_{\\mathrm{mem}}^{\\star} - 0.04\\, t_{\\mathrm{mem}}^{\\star} = 3 - 1 \\quad \\Rightarrow \\quad 0.96\\, t_{\\mathrm{mem}}^{\\star} = 2,\n$$\n所以\n$$\nt_{\\mathrm{mem}}^{\\star} = \\frac{2}{0.96} = \\frac{2}{\\frac{24}{25}} = 2 \\cdot \\frac{25}{24} = \\frac{25}{12}.\n$$\n\n因此，对于 $t_{\\mathrm{mem}}  \\frac{25}{12}$ 个周期，直接映射缓存的较低命中时间优势超过了其较高的未命中率，从而产生比 $4$-路缓存更低的AMAT；对于 $t_{\\mathrm{mem}} > \\frac{25}{12}$ 个周期，$4$-路缓存的较低未命中率尽管其命中时间较长但占据主导地位。所要求的以周期为单位的交叉点值是精确有理数 $\\frac{25}{12}$。",
            "answer": "$$\\boxed{\\frac{25}{12}}$$"
        }
    ]
}