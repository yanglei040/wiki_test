{
    "hands_on_practices": [
        {
            "introduction": "本练习将介绍最直接的冲突未命中形式。我们将分析一个特制的内存访问模式，该模式刻意让多个内存块在同一个缓存组内争夺空间。通过解决这个问题，您将对缓存的相联度如何限制一个组能容纳的竞争块数量，以及这如何导致冲突未命中，建立起基础的理解。",
            "id": "3625340",
            "problem": "一个物理索引、物理标签的一级数据缓存有 $S$ 个组，块大小为 $B$ 字节，关联度为 $A$ 路，采用最近最少使用 (LRU) 替换策略。缓存初始为空。考虑一个微基准测试，在 $T$ 次迭代中，每次迭代按顺序执行以下 $3$ 次加载操作：从地址 $o$ 加载，然后从地址 $o + S \\cdot B$ 加载，再从地址 $o + 2 S \\cdot B$ 加载。假设 $o$ 是 $B$ 的一个非负整数倍，因此这些地址中的每一个都指向一个不同块的起始位置。没有其他内存引用，没有预取，并忽略转译后备缓冲器 (TLB) 的影响。缓存总容量为 $C = S \\cdot A \\cdot B$ 字节。\n\n使用组相联缓存中组索引的基本定义和标准的未命中分类法——其中强制性未命中是对一个块的首次引用，容量未命中是在一个具有相同总容量 $C$ 和 LRU 策略的全相联缓存中同样会发生的未命中，而冲突未命中是既非强制性也非容量性的任何未命中——回答以下问题，以推理此微基准测试的未命中行为：\n\n(1) 判断三个地址 $o$、$o + S \\cdot B$ 和 $o + 2 S \\cdot B$ 是否映射到同一个缓存组，并从基本原理出发证明你的结论。\n\n(2) 对于 $A = 2$ 和 $T = 10^{4}$ 次迭代，从空缓存开始，推导在整个运行过程中的冲突未命中总数。根据标准的未命中分类法精确地对所有未命中进行分类。\n\n(3) 在保持 $S$ 和 $B$ 固定的情况下，改变 $A$，确定能够消除此微基准测试在初始强制性未命中之后所有冲突未命中的最小关联度 $A_{\\min}$，并根据 LRU 下的替换动态来证明你的答案。\n\n提供所有推理步骤。对于你的最终数值答案，仅报告 $A_{\\min}$ 的值，作为一个没有单位的数字。",
            "solution": "所提出的问题是计算机体系结构中一个明确定义的练习，具体涉及缓存性能的分析。它以缓存存储器组织、操作和未命中分类的既定原则为科学依据。问题陈述是自包含的、客观的且内部一致的，提供了推导出唯一解所需的所有参数和定义（$S$、$A$、$B$、$T$、访问模式和未命中分类法）。因此，该问题被认为是有效的，我们可以进行形式化的求解。\n\n解决方案需要解决三个不同的部分。我们将按顺序进行。\n\n(1) 判断这三个地址是否映射到同一个缓存组。\n\n内存地址的组索引由其块地址确定。对于一个块大小为 $B$ 字节、有 $S$ 个组的物理索引缓存，物理地址 $\\alpha$ 的组索引 $i$ 由以下公式给出：\n$$\ni = \\left\\lfloor \\frac{\\alpha}{B} \\right\\rfloor \\pmod S\n$$\n其中 $\\lfloor \\frac{\\alpha}{B} \\rfloor$ 是块地址。我们已知基地址 $o$ 是块大小 $B$ 的一个非负整数倍。这使我们可以写成 $o = k \\cdot B$，其中 $k$ 是某个非负整数。\n\n让我们计算访问模式中三个地址各自的组索引。\n\n地址1: $\\alpha_1 = o$。\n块地址为 $\\lfloor \\frac{o}{B} \\rfloor = \\lfloor \\frac{k \\cdot B}{B} \\rfloor = k$。\n组索引为 $i_1 = k \\pmod S$。\n\n地址2: $\\alpha_2 = o + S \\cdot B$。\n块地址为 $\\lfloor \\frac{o + S \\cdot B}{B} \\rfloor = \\lfloor \\frac{k \\cdot B + S \\cdot B}{B} \\rfloor = \\lfloor k + S \\rfloor = k + S$。\n组索引为 $i_2 = (k + S) \\pmod S$。使用模运算的性质 $(a+b) \\pmod n = ((a \\pmod n) + (b \\pmod n)) \\pmod n$，我们得到：\n$$\ni_2 = (k \\pmod S + S \\pmod S) \\pmod S = (k \\pmod S + 0) \\pmod S = k \\pmod S\n$$\n\n地址3: $\\alpha_3 = o + 2 S \\cdot B$。\n块地址为 $\\lfloor \\frac{o + 2 S \\cdot B}{B} \\rfloor = \\lfloor \\frac{k \\cdot B + 2 S \\cdot B}{B} \\rfloor = \\lfloor k + 2S \\rfloor = k + 2S$。\n组索引为 $i_3 = (k + 2S) \\pmod S$。应用相同的模运算性质：\n$$\ni_3 = (k \\pmod S + 2S \\pmod S) \\pmod S = (k \\pmod S + 0) \\pmod S = k \\pmod S\n$$\n由于 $i_1 = i_2 = i_3 = k \\pmod S$，所有三个地址都精确地映射到同一个缓存组。我们将这三个地址对应的不同块表示为 $BLK_0$、$BLK_1$ 和 $BLK_2$。\n\n(2) 对于 $A = 2$ 和 $T = 10^{4}$，推导冲突未命中的总数。\n\n缓存初始为空。我们追踪参数 $A=2$ 时的访问情况。从第 (1) 部分可知，所有 $3$ 个块 ($BLK_0, BLK_1, BLK_2$) 竞争同一个 $2$ 路组。替换策略是 LRU。\n\n迭代 $1$ (当 $t=0$ 时):\n- 从地址 $o$ 加载 ($BLK_0$): **未命中**。这是对 $BLK_0$ 的首次引用。该组为空。$BLK_0$ 被加载。组状态: $\\{BLK_0\\}$。这是一次**强制性未命中**。\n- 从地址 $o + S \\cdot B$ 加载 ($BLK_1$): **未命中**。这是对 $BLK_1$ 的首次引用。该组中有一个空路。$BLK_1$ 被加载。组状态: $\\{BLK_0, BLK_1\\}$。LRU 顺序: $BLK_0$ 是最近最少使用的 (LRU)，$BLK_1$ 是最近最多使用的 (MRU)。这是一次**强制性未命中**。\n- 从地址 $o + 2 S \\cdot B$ 加载 ($BLK_2$): **未命中**。这是对 $BLK_2$ 的首次引用。该组已满。最近最少使用的块 $BLK_0$ 被替换出去。$BLK_2$ 被加载。组状态: $\\{BLK_1, BLK_2\\}$。LRU 顺序: $BLK_1$ 是 LRU，$BLK_2$ 是 MRU。这是一次**强制性未命中**。\n\n在第一次迭代结束时，共有 $3$ 次未命中，全部是强制性未命中。\n\n迭代 $2$ (当 $t=1$ 时):\n该组包含 $\\{BLK_1, BLK_2\\}$，其中 $BLK_1$ 是 LRU。\n- 从地址 $o$ 加载 ($BLK_0$): **未命中**。$BLK_0$ 不在组中。LRU 块 $BLK_1$ 被替换出去。$BLK_0$ 被加载。组状态: $\\{BLK_2, BLK_0\\}$。LRU 顺序: $BLK_2$ 是 LRU，$BLK_0$ 是 MRU。\n- 从地址 $o + S \\cdot B$ 加载 ($BLK_1$): **未命中**。$BLK_1$ 不在组中。LRU 块 $BLK_2$ 被替换出去。$BLK_1$ 被加载。组状态: $\\{BLK_0, BLK_1\\}$。LRU 顺序: $BLK_0$ 是 LRU，$BLK_1$ 是 MRU。\n- 从地址 $o + 2 S \\cdot B$ 加载 ($BLK_2$): **未命中**。$BLK_2$ 不在组中。LRU 块 $BLK_0$ 被替换出去。$BLK_2$ 被加载。组状态: $\\{BLK_1, BLK_2\\}$。LRU 顺序: $BLK_1$ 是 LRU，$BLK_2$ 是 MRU。\n\n第二次迭代结束时组的状态与第一次迭代结束时的状态相同。因此，每次迭代 $3$ 次未命中的模式将在从 $t=1$ 到 $t=T-1$ 的所有后续迭代中重复。\n\n现在，我们必须对这些未命中进行分类。它们不是强制性未命中，因为所有块在第一次迭代中都已被访问过。为了区分容量未命中和冲突未命中，我们分析一个具有相同容量 $C = S \\cdot A \\cdot B = 2SB$ 的全相联缓存。该缓存可以容纳的块数为 $C/B = 2S$。我们的微基准测试的工作集仅包含 $3$ 个不同的块。假设 $S \\ge 2$（这对于组相联缓存是典型情况），则缓存容量（以块为单位）为 $2S \\ge 4$。由于工作集大小（$3$ 个块）小于缓存容量（$2S$ 个块），一个全相联缓存将在初始强制性未命中之后容纳所有 $3$ 个块。因此，在全相联缓存中将不会有更多的未命中。\n我们在 $2$ 路组相联缓存的第 $2$ 次到第 $T$ 次迭代中观察到的未命中不是强制性的，并且在等效的全相联缓存中不会发生。根据定义，这些都是**冲突未命中**。\n\n冲突未命中的总数是每次迭代的未命中次数（第一次之后）乘以这样的迭代次数。\n- 每次迭代的冲突未命中次数（对于 $t \\ge 1$）: $3$。\n- 发生冲突未命中的迭代次数: $T - 1 = 10^4 - 1 = 9999$。\n- 冲突未命中总数 = $3 \\times (T - 1) = 3 \\times 9999 = 29997$。\n(注意: 如果 $S=1$，容量为 $2$ 个块。$3$ 个块的工作集将无法容纳，所有非强制性未命中都将是容量未命中。然而，问题的结构，特别是要求 $A_{\\min}$ 来消除冲突未命中，暗示了这样一个场景：工作集可以放入缓存，但受限于关联度，即 $3 \\le C/B$，这使得 $S \\ge 2$ 的假设是隐含的。)\n\n(3) 确定消除所有冲突未命中的最小关联度 $A_{\\min}$。\n\n冲突未命中的发生是因为映射到单个组的活动块数量超过了该组的关联度 $A$。在这个微基准测试中，我们已经确定，恰好有 $3$ 个不同的块（$BLK_0$、$BLK_1$、$BLK_2$）映射到同一个组并被重复访问。\n\n为了在初始强制性阶段之后消除所有冲突未命中，缓存组必须足够大以同时容纳所有这些竞争的块。由于有 $3$ 个这样的块，关联度 $A$ 必须至少为 $3$。\n让我们在 $A=3$ 的情况下验证这一点：\n- 迭代 1：对 $BLK_0$、$BLK_1$ 和 $BLK_2$ 中每一个的首次访问都会导致一次强制性未命中。在迭代结束时，该组容纳了所有三个块：$\\{BLK_0, BLK_1, BLK_2\\}$。\n- 迭代 2 及以后：访问模式是加载 $BLK_0$，加载 $BLK_1$，加载 $BLK_2$。由于所有三个块都已驻留在该组中（其容量为 $3$），这些加载中的每一次都将导致一次**命中**。每次命中都会更新 LRU 状态，但不会有块被替换出去。\n\n因此，当关联度 $A=3$ 时，唯一发生的未命中是最初的 $3$ 次强制性未命中。所有的冲突未命中都被消除了。任何低于 $3$ 的关联度（即 $A=1$ 或 $A=2$）都不足以容纳所有 $3$ 个块，从而导致替换和随后的冲突未命中，如第 (2) 部分所示。\n因此，消除所有冲突未命中的最小关联度是 $A_{\\min} = 3$。",
            "answer": "$$\n\\boxed{3}\n$$"
        },
        {
            "introduction": "在基础之上，本实践将探讨数据布局和访问步长如何导致冲突未命中，即使是在访问不同数据结构时。我们将研究一个直接映射缓存的场景，其中三个独立的数组在内存中的布局方式使得它们的元素总是在相同的缓存组中发生碰撞。此问题揭示了软件层面的内存模式与硬件层面的缓存性能之间的关键联系，说明了看似无关的数据如何相互干扰。",
            "id": "3625419",
            "problem": "考虑一个直接映射缓存，其拥有 $S=64$ 个组，块大小为 $B$ 字节。对于字节地址为 $x$ 的内存块，其组索引定义为 $i=\\left\\lfloor \\frac{x}{B} \\right\\rfloor \\bmod S$。三个数组 $A$、$B$ 和 $C$ 在主存中的布局方式使得它们的基块地址模 $S$ 同余；等价地，如果 $a_{0}$、$b_{0}$ 和 $c_{0}$ 分别表示 $A$、$B$ 和 $C$ 的基块号，则有 $a_{0} \\equiv b_{0} \\equiv c_{0} \\pmod{S}$。你将以 $s=3B$ 字节的步长访问每个数组，即每个数组中连续访问的块号以 $3$ 为增量。\n\n定义一个关于 $t$ 的两遍循环，其中 $t$ 的取值范围从 $0$ 到 $63$（含）。在每一遍中，对于每个 $t$，按固定顺序发出三个内存访问请求：首先是块号为 $a_{0}+3t$ 的 $A$ 数组块，然后是块号为 $b_{0}+3t$ 的 $B$ 数组块，最后是块号为 $c_{0}+3t$ 的 $C$ 数组块。假设缓存在第一遍开始时为空。\n\n仅使用直接映射索引的核心定义 $i=\\left\\lfloor \\frac{x}{B} \\right\\rfloor \\bmod S$ 和标准的未命中分类（强制性未命中指首次引用一个从未被调入缓存的块时发生的未命中；容量未命中指即使在最佳替换策略下缓存也无法容纳工作集时发生的未命中；冲突未命中指在组相联或直接映射缓存中，多个块映射到同一个组时发生的未命中），完成以下任务：\n\n- 推导由步长 $s=3B$ 和基块同余条件 $a_{0} \\equiv b_{0} \\equiv c_{0} \\pmod{64}$ 引起的冲突模式，解释每一步访问了哪些组，以及这三个数组是否在组内发生冲突。\n- 基于该模式，对第一遍中的所有未命中进行分类。\n- 然后，假设访问顺序和地址不变，对第二遍中的所有未命中进行分类，并确定其中有多少是冲突未命中。\n\n请提供在第二遍循环（$t=0,1,\\dots,63$）中发生的冲突未命中总数作为你的最终答案。答案必须是一个实数值，无需四舍五入。",
            "solution": "该问题要求分析在一个直接映射缓存中，特定内存访问模式下两遍循环的缓存未命中情况。我们将首先验证问题陈述，然后进行系统性求解。\n\n### 步骤 1：提取已知条件\n- 缓存架构：直接映射\n- 组数：$S = 64$\n- 块大小：$B$ 字节\n- 组索引函数：$i = \\left\\lfloor \\frac{x}{B} \\right\\rfloor \\bmod S$，其中 $k = \\left\\lfloor \\frac{x}{B} \\right\\rfloor$ 是内存块号。因此，$i = k \\bmod S$。\n- 数组：$A$、$B$、$C$。\n- 基块号：$a_0$、$b_0$、$c_0$。\n- 基块同余：$a_0 \\equiv b_0 \\equiv c_0 \\pmod{S}$，即 $a_0 \\equiv b_0 \\equiv c_0 \\pmod{64}$。\n- 访问步长：$s = 3B$ 字节，对应块号步长为 $3$。\n- 循环结构：关于 $t$ 的两遍循环，其中 $t$ 的取值范围从 $0$ 到 $63$。\n- 每次迭代 $t$ 的访问顺序：\n  1. 访问数组 $A$ 中块号为 $k_A(t) = a_0 + 3t$ 的块。\n  2. 访问数组 $B$ 中块号为 $k_B(t) = b_0 + 3t$ 的块。\n  3. 访问数组 $C$ 中块号为 $k_C(t) = c_0 + 3t$ 的块。\n- 初始条件：缓存在第一遍开始时为空。\n- 任务：确定第二遍中的冲突未命中总数。\n\n### 步骤 2：使用已知条件进行验证\n该问题在科学上基于计算机体系结构和缓存行为的原理。这是一个适定问题，提供了所有必要的参数（$S$、访问模式、初始条件）以确定唯一的数值答案。语言客观而精确。前提条件是一致的，所要求的任务可以通过基于所提供定义的逻辑推导来解决。没有矛盾、歧义或不切实际的假设。该问题被认为是**有效的**。\n\n### 步骤 3：求解过程推导\n\n#### 冲突模式分析\n内存访问的组索引由其块号对组数 $S=64$ 取模决定。我们来确定在一次迭代 $t$ 中，每次访问的组索引。\n\n在步骤 $t$，数组 $A$ 的块号为 $k_A(t) = a_0 + 3t$。对应的组索引为：\n$$i_A(t) = k_A(t) \\bmod S = (a_0 + 3t) \\bmod 64$$\n\n同理，对于数组 $B$ 和 $C$：\n$$i_B(t) = k_B(t) \\bmod S = (b_0 + 3t) \\bmod 64$$\n$$i_C(t) = k_C(t) \\bmod S = (c_0 + 3t) \\bmod 64$$\n\n我们已知基块地址模 $64$ 同余：$a_0 \\equiv b_0 \\equiv c_0 \\pmod{64}$。设这个公共余数为 $r$。即，$a_0 \\bmod 64 = b_0 \\bmod 64 = c_0 \\bmod 64 = r$。\n利用模运算的性质，我们可以简化组索引的表达式：\n$$i_A(t) = (a_0 \\bmod 64 + 3t \\bmod 64) \\bmod 64 = (r + 3t) \\bmod 64$$\n$$i_B(t) = (b_0 \\bmod 64 + 3t \\bmod 64) \\bmod 64 = (r + 3t) \\bmod 64$$\n$$i_C(t) = (c_0 \\bmod 64 + 3t \\bmod 64) \\bmod 64 = (r + 3t) \\bmod 64$$\n\n这个结果至关重要：对于任何给定的迭代 $t$，所有三次内存访问——对块 $k_A(t)$、$k_B(t)$ 和 $k_C(t)$ 的访问——都映射到完全相同的组索引 $i(t) = (r + 3t) \\bmod 64$。由于缓存是直接映射的，每个组只有一个缓存行。因此，这三次访问将竞争同一个缓存行，导致在每次迭代 $t$ 中发生替换。\n\n接下来，我们分析当 $t$ 从 $0$ 变化到 $63$ 时，所访问的组索引序列。索引序列为 $i(t) = (r + 3t) \\bmod 64$。访问过的组索引集合为 $\\{ (r + 3t) \\bmod 64 \\mid t=0, 1, \\dots, 63 \\}$。当且仅当步长 $3$ 与组数 $64$ 互质时，该序列将恰好访问从 $0$ 到 $63$ 的每个组一次。我们计算最大公约数：$\\gcd(3, 64) = 1$，因为 $3$ 的质因数只有 $\\{3\\}$，而 $64=2^6$ 的质因数只有 $\\{2\\}$。\n因为 $\\gcd(3, 64) = 1$，所以函数 $f(t) = 3t \\bmod 64$ 是 $\\{0, 1, \\dots, 63\\}$ 的一个排列。这意味着在一整遍循环（$t=0, \\dots, 63$）中，64 个组中的每一个都被精确访问一次。因此，在同一遍循环内，来自不同迭代 $t_1 \\neq t_2$ 的访问不会相互干扰。\n\n#### 第一遍分析（$t=0, \\dots, 63$）\n缓存初始为空。我们分析在迭代 $t$ 中发生的事件。\n1.  **访问 $k_A(t)$**：这是该块首次被引用。对应的组 $i(t)$ 是空的。这导致一次**强制性未命中**。块 $k_A(t)$ 被加载到组 $i(t)$ 的缓存行中。\n2.  **访问 $k_B(t)$**：这是该块首次被引用。它映射到同一个组 $i(t)$，该组当前存有块 $k_A(t)$。由于 $k_B(t) \\ne k_A(t)$（它们属于不同的数组），这次访问导致未命中。因为这是对 $k_B(t)$ 的首次访问，所以这是一次**强制性未命中**。块 $k_A(t)$ 被替换，块 $k_B(t)$ 被加载。\n3.  **访问 $k_C(t)$**：这是该块首次被引用。它映射到组 $i(t)$，该组现在存有 $k_B(t)$。这导致一次未命中，同样也是一次**强制性未命中**。块 $k_B(t)$ 被替换，块 $k_C(t)$ 被加载。\n\n这个模式对于从 $0$ 到 $63$ 的每次迭代 $t$ 都会重复。在每次迭代中，有 $3$ 次内存访问，且全部都是强制性未命中。\n第一遍的总访问次数：$64 \\text{ 次迭代} \\times 3 \\text{ 次访问/迭代} = 192$。\n第一遍的总未命中次数：$64 \\times 3 = 192$ 次未命中，全部为强制性未命中。\n\n在第一遍结束时，缓存已满。对于每个迭代 $t \\in \\{0, \\dots, 63\\}$，加载到组 $i(t)$ 的最后一个块是 $k_C(t)$。因此，在第二遍开始时，每个缓存组 $j \\in \\{0, \\dots, 63\\}$ 都包含块 $k_C(t_j)$，其中 $t_j$ 是 $\\{0, \\dots, 63\\}$ 中满足 $i(t_j) = j$ 的唯一 $t$ 值。\n\n#### 第二遍分析（$t=0, \\dots, 63$）\n在第二遍的迭代 $t$ 开始时，第一遍访问的所有块（$192$ 个）都已被引用过，因此第二遍中发生的任何未命中都不是强制性未命中。为了区分容量性未命中和冲突性未命中，我们必须使用标准定义，即考虑一个具有相同总容量、采用理想替换策略（如 LRU）的全相联缓存。\n\n- **缓存容量**：该直接映射缓存有 $S=64$ 个组，每个组有 1 个块。因此，总容量为 $64$ 个块。\n- **工作集大小**：在一遍完整的循环中（$t$ 从 0 到 63），程序访问了 $64 \\times 3 = 192$ 个不同的块（$k_A(t)$, $k_B(t)$, $k_C(t)$ for all $t$）。\n\n由于程序的工作集（192 个块）远大于缓存的总容量（64 个块），即使是理想的全相联缓存也无法容纳所有数据。在第二遍访问开始时，全相联缓存最多只能容纳最近访问的 64 个块。当程序开始重新访问第一遍开头访问过的块时（例如 $k_A(0)$），这些块早已被后续的访问所替换，因此在全相联缓存中也会发生未命中。\n\n根据定义，如果一次非强制性未命中在一个具有相同容量的全相联缓存中仍然会发生，那么它就是一次**容量性未命中**。在本案例中，第二遍中发生的所有未命中都符合此定义。因为工作集大小超过了缓存容量，这些块被逐出是由于空间不足，而非特定的地址映射冲突。\n\n因此，在第二遍循环中，每次访问都会导致一次容量性未命中。\n- 每次迭代的容量性未命中次数：$3$。\n- 第二遍的总容量性未命中次数：$64 \\times 3 = 192$。\n- 第二遍中的**冲突未命中**总数是 **0**。",
            "answer": "$$\\boxed{0}$$"
        },
        {
            "introduction": "最后的这项练习将我们的知识应用到一个科学计算的真实场景中：处理一个大型矩阵。我们将找出一个“病态的”访问步长，它会导致大量内存块映射到单一的缓存组，通过缓存颠簸（thrashing）现象引发严重的性能下降。这项实践通过一个实例清晰地展示了，即使一个数据集足够小，可以完全装入缓存，糟糕的访问模式也可能因单个过载组内的冲突而导致性能崩溃，从而巩固了冲突未命中和容量未命中之间的区别。",
            "id": "3625437",
            "problem": "考虑一个中央处理器 (CPU)，其一级数据缓存的参数如下：总容量为 $128\\ \\mathrm{KiB}$，2-路组相联，缓存行大小为 $64\\ \\mathrm{B}$。假设缓存使用标准的组索引规则，即缓存组索引是块号对组数取模，其中块号是地址除以缓存行大小的整数部分。矩阵 $A$ 的维度为 $N \\times M$，其中 $N = 512$，$M = 8192$，按行主序存储，且 $A$ 的每个元素都是一个大小为 $8\\ \\mathrm{B}$ 的双精度浮点值。$A$ 的基地址是 $A_0$，它按 $64\\ \\mathrm{B}$ 边界对齐。\n\n一个内核程序连续两次执行以下访问模式：对于从 $0$ 到 $N-1$ 的每个行索引 $i$，它读取 $A[i,0]$ 和 $A[i,k]$，其中 $k$ 是一个正整数。假设在这两次遍历之间没有其他内存访问，也没有预取。你可以假设使用一种确定性替换策略，如最近最少使用 (LRU) 或任何其他常用策略；下面所要求的结论不应依赖于超出相联度限制的具体策略。\n\n从缓存块号、组索引以及缓存未命中分为强制性、容量性和冲突性的标准分类的定义出发，推导使对于每一行 $i$，两个元素 $A[i,0]$ 和 $A[i,k]$ 映射到同一缓存组的条件 $k$。使用这个条件来选择满足它的最小正整数 $k$。你的推导过程必须明确使用 $M$ 是 $8$ 的倍数以及 $A_0$ 按 $64\\ \\mathrm{B}$ 对齐这两个事实。\n\n此外，解释为什么在这种 $k$ 的选择下，第二次遍历中观察到的未命中被归类为冲突未命中，即使所访问的两列的总唯一数据足迹（以缓存行计）可以容纳在缓存容量之内。你不需要计算未命中次数；分类的推理必须从基本定义开始。\n\n确保对于所有 $i$，$A[i,0]$ 和 $A[i,k]$ 位于同一缓存组中的最小正整数 $k$ 是多少？请提供 $k$ 的精确整数值。无需四舍五入。",
            "solution": "问题要求找到一个特定的列索引步长 $k$，该步长会导致一种特定的缓存映射行为，然后对由此产生的缓存未命中进行分类。解决过程分三个阶段进行：首先，计算相关的缓存架构参数；其次，推导关于 $k$ 的条件并找到其最小正整数值；第三，基于标准定义分析缓存未命中。\n\n首先，我们必须根据给定信息确定缓存架构的关键参数。\n缓存容量为 $C = 128~\\text{KiB} = 128 \\times 2^{10}~\\text{B} = 2^7 \\times 2^{10}~\\text{B} = 2^{17}~\\text{B}$。\n缓存行大小（或块大小）为 $L = 64~\\text{B} = 2^6~\\text{B}$。\n相联度为 $W = 2$-路。\n缓存行的总数是 $N_{lines} = \\frac{C}{L} = \\frac{2^{17}}{2^6} = 2^{11} = 2048$。\n缓存中的组数是 $S = \\frac{N_{lines}}{W} = \\frac{2048}{2} = 1024 = 2^{10}$。\n\n内存地址到缓存组的映射由其块号决定。块号定义为 $\\text{BlockNumber} = \\lfloor \\frac{\\text{Address}}{L} \\rfloor$。组索引则由下式给出 $\\text{SetIndex} = \\text{BlockNumber} \\pmod S$。\n\n接下来，我们形式化地表示被访问元素的内存地址。矩阵 $A$ 的维度为 $N \\times M$，其中 $N=512$，$M=8192$。它按行主序存储，每个元素的大小为 $E = 8~\\text{B}$。元素 $A[i,j]$ 的地址由以下公式给出：\n$$ \\text{Addr}(A[i,j]) = A_0 + (i \\cdot M + j) \\cdot E $$\n其中 $A_0$ 是矩阵的基地址。\n\n问题要求对于任意行 $i$，元素 $A[i,0]$ 和 $A[i,k]$ 映射到同一个缓存组。这意味着它们的块号必须在模组数 $S$ 的意义下同余。\n设 $B(i,j)$ 为 $A[i,j]$ 地址的块号。条件是：\n$$ B(i,0) \\pmod S = B(i,k) \\pmod S \\quad \\forall i \\in [0, N-1] $$\n这等价于说，它们的块号之差必须是 $S$ 的倍数：\n$$ (B(i,k) - B(i,0)) \\pmod S = 0 $$\n让我们来计算块号。\n$B(i,0) = \\left\\lfloor \\frac{\\text{Addr}(A[i,0])}{L} \\right\\rfloor = \\left\\lfloor \\frac{A_0 + i \\cdot M \\cdot E}{L} \\right\\rfloor$\n$B(i,k) = \\left\\lfloor \\frac{\\text{Addr}(A[i,k])}{L} \\right\\rfloor = \\left\\lfloor \\frac{A_0 + (i \\cdot M + k) \\cdot E}{L} \\right\\rfloor = \\left\\lfloor \\frac{A_0 + i \\cdot M \\cdot E + k \\cdot E}{L} \\right\\rfloor$\n\n问题指出基地址 $A_0$ 按 $64~\\text{B}$ 边界对齐，这意味着 $A_0$ 是 $L=64$ 的倍数。设 $A_0 = q_0 L$，其中 $q_0$ 为某个整数。\n我们还必须检查矩阵一行所占的字节数：$M \\cdot E = 8192 \\cdot 8 = 2^{13} \\cdot 2^3 = 2^{16}~\\text{B}$。由于 $L=64=2^6~\\text{B}$，一行的字节数是行大小的整数倍：$\\frac{M \\cdot E}{L} = \\frac{2^{16}}{2^6} = 2^{10} = 1024$。这意味着每一行的起始地址，$\\text{Addr}(A[i,0]) = A_0 + i \\cdot M \\cdot E$，都是 $L$ 的倍数。这个事实是 $A_0$ 对齐和矩阵维度的直接结果。问题中提到 $M$ 是 $8$ 的倍数，这意味着每个缓存行可容纳的元素数量 $L/E = 64/8 = 8$ 能够整除列数 $M=8192$，导致一行恰好跨越 $8192/8 = 1024$ 个缓存行。\n\n由于 $\\frac{A_0 + i \\cdot M \\cdot E}{L}$ 是一个整数，因此可以去掉计算 $B(i,0)$ 时的向下取整函数：\n$$ B(i,0) = \\frac{A_0}{L} + i \\cdot \\frac{M \\cdot E}{L} $$\n对于 $B(i,k)$，我们可以使用整数 $n$ 的属性 $\\lfloor x+n \\rfloor = \\lfloor x \\rfloor + n$：\n$$ B(i,k) = \\left\\lfloor \\left(\\frac{A_0}{L} + i \\cdot \\frac{M \\cdot E}{L}\\right) + \\frac{k \\cdot E}{L} \\right\\rfloor = B(i,0) + \\left\\lfloor \\frac{k \\cdot E}{L} \\right\\rfloor $$\n因此，块号之差为：\n$$ B(i,k) - B(i,0) = \\left\\lfloor \\frac{k \\cdot E}{L} \\right\\rfloor $$\n这个差值与行索引 $i$ 无关，所以如果条件对一个 $i$ 成立，那么它对所有 $i$ 都成立。条件 $(B(i,k) - B(i,0)) \\pmod S = 0$ 变为：\n$$ \\left\\lfloor \\frac{k \\cdot E}{L} \\right\\rfloor \\pmod S = 0 $$\n这意味着 $\\lfloor \\frac{k \\cdot E}{L} \\rfloor$ 必须是 $S$ 的整数倍。设其为 $m \\cdot S$，其中 $m$ 为某个整数。为了找到最小的正整数 $k$，我们应该选择最小的正整数倍，即 $m=1$ 的情况。\n$$ \\left\\lfloor \\frac{k \\cdot E}{L} \\right\\rfloor = S $$\n代入数值 $E=8$，$L=64$ 和 $S=1024$：\n$$ \\left\\lfloor \\frac{k \\cdot 8}{64} \\right\\rfloor = 1024 \\implies \\left\\lfloor \\frac{k}{8} \\right\\rfloor = 1024 $$\n根据向下取整函数的定义，该不等式成立：\n$$ 1024 \\le \\frac{k}{8}  1025 $$\n两边乘以 $8$：\n$$ 8192 \\le k  8200 $$\n满足此条件的最小正整数 $k$ 是 $k=8192$。\n\n最后，我们必须解释为什么对于 $k=8192$ 这个选择，第二次遍历中的未命中被归类为冲突未命中。\n访问模式涉及矩阵的两列，第 $0$ 列和第 $k=8192$ 列。行数为 $N=512$。因此，程序访问 $A[i,0]$ 和 $A[i,k]$，其中 $i \\in [0, 511]$。\n被访问的唯一缓存块集合是那些包含所有 $i$ 的 $A[i,0]$ 和 $A[i,k]$ 的块。$A[i,0]$ 和 $A[i,k]$ 之间的地址差是 $k \\cdot E = 8192 \\cdot 8 = 65536$ 字节，即 $65536/64=1024$ 个缓存块。所以 $A[i,0]$ 和 $A[i,k]$ 位于不同的块中。访问的唯一块的总数是 $2 \\times N = 2 \\times 512 = 1024$。\n这个工作集所占的内存足迹是 $1024~\\text{块} \\times 64~\\frac{\\text{B}}{\\text{块}} = 65536~\\text{B} = 64~\\text{KiB}$。\n总缓存容量是 $128~\\text{KiB}$。由于工作集大小（$64~\\text{KiB}$）小于缓存容量，第二次遍历中观察到的未命中不可能是容量未命中。根据定义，容量未命中是指在相同容量的全相联缓存中仍会发生的未命中。在这样的缓存中，所有 $1024$ 个块都能装下，因此第二次遍历不会有任何未命中。\n\n让我们来分析组映射。包含 $A[i,j]$ 的块的组索引是 $I(i,j) = B(i,j) \\pmod S$。\n$A[i,0]$ 的组索引是：\n$$ I(i,0) = \\left(\\frac{A_0}{L} + i \\cdot \\frac{M \\cdot E}{L}\\right) \\pmod S $$\n代入 $\\frac{M \\cdot E}{L} = 1024 = S$：\n$$ I(i,0) = \\left(\\frac{A_0}{L} + i \\cdot S\\right) \\pmod S = \\frac{A_0}{L} \\pmod S $$\n$A[i,k]$ 的组索引是：\n$$ I(i,k) = \\left(B(i,0) + \\left\\lfloor \\frac{k \\cdot E}{L} \\right\\rfloor \\right) \\pmod S = \\left(B(i,0) + S\\right) \\pmod S = B(i,0) \\pmod S = I(i,0) $$\n关键在于，不仅对于给定的 $i$，$A[i,0]$ 和 $A[i,k]$ 映射到同一个组，而且对于所有 $i \\in [0, 511]$，所有被访问的块都映射到完全相同的组 $s_{conflict} = \\frac{A_0}{L} \\pmod S$。\n缓存是 $2$-路组相联的 ($W=2$)，这意味着这个组 $s_{conflict}$ 一次只能容纳 $2$ 个块。然而，程序试图访问 $1024$ 个不同的块，而这些块都映射到这同一个组。\n在第一次遍历期间，随着循环的迭代，它会将新的块对 ($B(i,0), B(i,k)$) 带入组 $s_{conflict}$，导致先前迭代的块被驱逐。例如，当访问 $A[1,0]$ 和 $A[1,k]$ 时，$A[0,0]$ 和 $A[0,k]$ 的块会被驱逐（假设使用类似 LRU 的策略）。在第一次遍历结束时，只有最后一次迭代的块，$B(511,0)$ 和 $B(511,k)$，保留在缓存中。第一次遍历的未命中都是强制性未命中，因为这 $1024$ 个块中的每一个都是首次被访问。\n\n在第二次遍历中，访问序列被重复。当再次访问 $A[0,0]$ 时，它的块不在缓存中，因为它在第一次遍历中被驱逐了。这导致了一次未命中。这次未命中不是强制性未命中，因为该块之前被访问过。它也不是容量未命中，因为整个工作集可以装入缓存。因此，根据定义，它必须是冲突未命中。发生这种未命中的原因是，工作集中的大量块正在竞争单个缓存组中有限的槽位（$2$个），这是我们选择的 $k$ 所造成的病态映射的直接后果。这个推理适用于第二次遍历中的每一次访问，所有这些访问都将是冲突未命中。",
            "answer": "$$\\boxed{8192}$$"
        }
    ]
}