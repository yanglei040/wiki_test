{
    "hands_on_practices": [
        {
            "introduction": "选择合适的缓存块大小涉及到一个基本的权衡。本练习将挑战你通过建立一个基于处理器每指令周期数（$CPI$）的总体性能模型来找到最佳点。通过分析一个混合工作负载的程序，你将学习如何用数学方法确定最佳块大小，以平衡改进空间局部性的好处与更高未命中惩罚的成本。",
            "id": "3624223",
            "problem": "一个单发射顺序执行处理器执行一个大型程序，该程序由两个具有不同内存访问模式的内核组成。在没有内存停顿的情况下，处理器的基础每指令周期数 (CPI) 为 $CPI_{0}=1.00$ 个周期/指令。一级缓存（Level-1 (L1)）的未命中会使流水线停顿，其服务时间由固定的片外延迟加上与缓存块（行）大小成正比的传输时间组成。\n\n假设以下经过充分检验的事实和定义：\n- 每指令周期数 (CPI) 是总周期数除以已退役指令的数量。\n- 总周期数等于基础执行周期数和停顿周期数之和。\n- 对于一次缓存未命中的内存访问，未命中服务时间是到第一个响应的固定延迟与传输整个块的线性时间之和。用 $L$ 表示固定延迟（单位：周期），用 $B$ 表示块大小（单位：字节），用 $W$ 表示持续内存带宽（单位：字节/周期），因此未命中服务时间为 $L + B/W$ 周期。\n- 如果一个内核每条指令发出 $r$ 次内存引用，并且每次引用的未命中概率为 $m(B)$（一个无单位的分数），那么该内核贡献的每条指令的预期停顿周期数等于 $r \\, m(B)$ 乘以未命中服务时间。\n\n该程序由两个内核按指令数混合组成：\n- 内核 $\\mathcal{A}$ (流式): 占已退役指令的比例 $f_{\\mathcal{A}}=0.6$；内存引用强度 $r_{\\mathcal{A}}=0.6$ 次引用/指令；经验性未命中率拟合公式 $m_{\\mathcal{A}}(B)=\\frac{8}{B}+0.01$，在 $B \\in [16,256]$ 字节范围内有效。\n- 内核 $\\mathcal{B}$ (跨步/类随机): 占已退役指令的比例 $f_{\\mathcal{B}}=0.4$；内存引用强度 $r_{\\mathcal{B}}=0.3$ 次引用/指令；经验性未命中率拟合公式 $m_{\\mathcal{B}}(B)=\\frac{4}{B}+0.3$，在 $B \\in [16,256]$ 字节范围内有效。\n\n片外固定延迟为 $L=50$ 周期，持续带宽为 $W=8$ 字节/周期。假设未命中会序列化执行（未命中开销无重叠），并且经验性未命中率拟合公式已经包含了对于所考虑的 $B$ 值，所有强制性、容量性和冲突性未命中的影响。\n\n仅使用上述基本定义，推导出该程序混合体的总 CPI 作为 $B$ 的函数，并确定在连续范围 $[16,256]$ 内使 CPI 最小化的缓存块大小 $B$（单位：字节）。仅报告最优的 $B$ 值，并忽略任何关于块大小必须是2的幂的硬件限制。最终答案以字节表示，四舍五入到四位有效数字。",
            "solution": "该问题经验证具有科学依据、提法明确、客观、完整且可验证。它代表了计算机体系结构中的一个标准优化问题。我现在将进行正式推导。\n\n处理器的总每指令周期数，表示为 $CPI$，是基础 CPI $CPI_{0}$ 与因内存访问导致的每指令停顿周期数之和。\n$$\nCPI = CPI_{0} + \\text{StallCyclesPerInstruction}_{\\text{total}}\n$$\n基础 CPI 已知为 $CPI_{0} = 1.00$。总的每指令停顿周期数是每个内核贡献的停顿周期的加权平均值，其中权重是属于每个内核的指令比例。\n$$\n\\text{StallCyclesPerInstruction}_{\\text{total}} = f_{\\mathcal{A}} \\cdot (\\text{Stalls per instruction})_{\\mathcal{A}} + f_{\\mathcal{B}} \\cdot (\\text{Stalls per instruction})_{\\mathcal{B}}\n$$\n根据问题定义，给定内核的每指令停顿周期数是其每指令内存引用次数 ($r$)、每次引用的未命中率 ($m(B)$) 以及未命中服务时间的乘积。未命中服务时间为固定延迟 $L$ 和传输时间 $B/W$ 之和。\n$$\n\\text{Miss Service Time} = L + \\frac{B}{W}\n$$\n因此，内核 $\\mathcal{A}$ 和内核 $\\mathcal{B}$ 的每指令停顿周期数分别为：\n$$\n(\\text{Stalls per instruction})_{\\mathcal{A}} = r_{\\mathcal{A}} \\cdot m_{\\mathcal{A}}(B) \\cdot \\left( L + \\frac{B}{W} \\right)\n$$\n$$\n(\\text{Stalls per instruction})_{\\mathcal{B}} = r_{\\mathcal{B}} \\cdot m_{\\mathcal{B}}(B) \\cdot \\left( L + \\frac{B}{W} \\right)\n$$\n将这些代入总停顿周期的表达式中：\n$$\n\\text{StallCyclesPerInstruction}_{\\text{total}} = \\left[ f_{\\mathcal{A}} r_{\\mathcal{A}} m_{\\mathcal{A}}(B) + f_{\\mathcal{B}} r_{\\mathcal{B}} m_{\\mathcal{B}}(B) \\right] \\cdot \\left( L + \\frac{B}{W} \\right)\n$$\n我们将程序混合体的有效每指令未命中率 $M(B)$ 定义为方括号中的项：\n$$\nM(B) = f_{\\mathcal{A}} r_{\\mathcal{A}} m_{\\mathcal{A}}(B) + f_{\\mathcal{B}} r_{\\mathcal{B}} m_{\\mathcal{B}}(B)\n$$\n那么，总 $CPI$作为块大小 $B$ 的函数为：\n$$\nCPI(B) = CPI_{0} + M(B) \\cdot \\left( L + \\frac{B}{W} \\right)\n$$\n我们已知以下值：\n- $CPI_{0} = 1.00$\n- $L=50$ 周期\n- $W=8$ 字节/周期\n- 对于内核 $\\mathcal{A}$：$f_{\\mathcal{A}}=0.6$, $r_{\\mathcal{A}}=0.6$, $m_{\\mathcal{A}}(B) = \\frac{8}{B} + 0.01$\n- 对于内核 $\\mathcal{B}$：$f_{\\mathcal{B}}=0.4$, $r_{\\mathcal{B}}=0.3$, $m_{\\mathcal{B}}(B) = \\frac{4}{B} + 0.3$\n\n首先，我们计算乘积 $f_{\\mathcal{A}} r_{\\mathcal{A}}$ 和 $f_{\\mathcal{B}} r_{\\mathcal{B}}$：\n$$\nf_{\\mathcal{A}} r_{\\mathcal{A}} = 0.6 \\times 0.6 = 0.36\n$$\n$$\nf_{\\mathcal{B}} r_{\\mathcal{B}} = 0.4 \\times 0.3 = 0.12\n$$\n现在，将这些代入 $M(B)$ 的表达式中：\n$$\nM(B) = 0.36 \\left( \\frac{8}{B} + 0.01 \\right) + 0.12 \\left( \\frac{4}{B} + 0.3 \\right)\n$$\n展开并合并同类项：\n$$\nM(B) = \\frac{0.36 \\times 8}{B} + 0.36 \\times 0.01 + \\frac{0.12 \\times 4}{B} + 0.12 \\times 0.3\n$$\n$$\nM(B) = \\frac{2.88}{B} + 0.0036 + \\frac{0.48}{B} + 0.036\n$$\n$$\nM(B) = \\frac{2.88 + 0.48}{B} + (0.0036 + 0.036) = \\frac{3.36}{B} + 0.0396\n$$\n现在，我们可以写出 $CPI(B)$ 的完整表达式：\n$$\nCPI(B) = 1.00 + \\left( \\frac{3.36}{B} + 0.0396 \\right) \\cdot \\left( 50 + \\frac{B}{8} \\right)\n$$\n为了找到最小值，我们必须首先展开这个表达式：\n$$\nCPI(B) = 1.00 + \\left( \\frac{3.36}{B} \\cdot 50 + \\frac{3.36}{B} \\cdot \\frac{B}{8} + 0.0396 \\cdot 50 + 0.0396 \\cdot \\frac{B}{8} \\right)\n$$\n$$\nCPI(B) = 1.00 + \\left( \\frac{168}{B} + \\frac{3.36}{8} + 1.98 + \\frac{0.0396}{8} B \\right)\n$$\n计算常数项：\n$$\n\\frac{3.36}{8} = 0.42\n$$\n$$\n\\frac{0.0396}{8} = 0.00495\n$$\n所以 $CPI(B)$ 的表达式变为：\n$$\nCPI(B) = 1.00 + \\frac{168}{B} + 0.42 + 1.98 + 0.00495 B\n$$\n合并所有常数项：\n$$\nCPI(B) = (1.00 + 0.42 + 1.98) + \\frac{168}{B} + 0.00495 B\n$$\n$$\nCPI(B) = 3.40 + \\frac{168}{B} + 0.00495 B\n$$\n为了找到使 $CPI(B)$ 最小化的块大小 $B$，我们计算 $CPI(B)$ 关于 $B$ 的导数，并令其等于零。\n$$\n\\frac{d}{dB} CPI(B) = \\frac{d}{dB} \\left( 3.40 + 168 B^{-1} + 0.00495 B \\right)\n$$\n$$\n\\frac{d}{dB} CPI(B) = 0 - 168 B^{-2} + 0.00495 = -\\frac{168}{B^2} + 0.00495\n$$\n令导数等于零以找到临界点：\n$$\n-\\frac{168}{B^2} + 0.00495 = 0\n$$\n$$\n\\frac{168}{B^2} = 0.00495\n$$\n$$\nB^2 = \\frac{168}{0.00495} \\approx 33939.39\n$$\n求解 $B$：\n$$\nB = \\sqrt{\\frac{168}{0.00495}}\n$$\n$$\nB \\approx 184.226474 \\text{ 字节}\n$$\n为确认这是一个最小值，我们检验二阶导数：\n$$\n\\frac{d^2}{dB^2} CPI(B) = \\frac{d}{dB} \\left( -168 B^{-2} + 0.00495 \\right) = (-2)(-168) B^{-3} = \\frac{336}{B^3}\n$$\n由于块大小 $B$ 必须为正，二阶导数 $\\frac{336}{B^3}$ 恒为正。这证实了函数 $CPI(B)$ 是凸函数，且该临界点对应于全局最小值。\n\n计算出的最优值 $B \\approx 184.226$ 字节在指定的有效范围 $B \\in [16, 256]$ 内。题目要求结果四舍五入到四位有效数字。\n$$\nB = 184.2 \\text{ 字节}\n$$",
            "answer": "$$\\boxed{184.2}$$"
        },
        {
            "introduction": "除了总体未命中率，缓存块大小和数据在内存中的布局之间的相互作用可能导致性能下降的冲突未命中。本练习深入探讨了缓存索引别名问题，要求你分析不同的块大小如何影响两个并发访问的数组的映射。掌握这一点将使你深入理解内存布局对性能的重要性，其关键性不亚于算法设计。",
            "id": "3624208",
            "problem": "考虑一个计算机系统中的单级直接映射缓存，其容量为 $C = 64 \\times 1024$ 字节。缓存块（行）大小 $B$ 必须从集合 $\\{128, 256, 512\\}$ 字节中选择。主内存中存储着两个大数组 $X$ 和 $Y$。每个数组都包含双精度浮点元素，因此元素大小为 $e = 8$ 字节。$X$ 的基地址是 $a_0$，它与每个候选的 $B$ 对齐（即，对于任何选择的 $B$，都有 $a_0 \\equiv 0 \\pmod{B}$）。$Y$ 的基地址是 $a_0 + d$，其中 $d = 65{,}400$ 字节。程序以锁步方式顺序遍历这两个数组：在迭代 $i \\in \\{0,1,2,\\dots\\}$ 中，它访问 $X[i]$，然后访问 $Y[i]$。\n\n使用直接映射缓存的缓存索引的标准定义：对于内存地址 $A$，块号为 $b(A) = \\left\\lfloor \\frac{A}{B} \\right\\rfloor$，缓存组索引为 $s(A) = b(A) \\bmod N_s$，其中 $N_s = \\frac{C}{B}$ 是组的数量。如果两次访问映射到同一组，即 $s(A_1) = s(A_2)$，则称它们在索引上发生别名。\n\n仅从这些定义和给定参数出发：\n- 推导一个闭式表达式，表示在一个由块偏移的模运算引起的完整周期内，$X[i]$ 和 $Y[i]$ 在索引上发生别名的长期迭代比例，该表达式是 $d$ 和 $B$ 的函数。您的表达式必须用 $d$、$B$、$C$ 和 $e$ 来表示，并且可以使用向下取整函数、最大公约数 $\\gcd(\\cdot,\\cdot)$ 和模同余。令此比例表示为 $\\alpha(d,B)$。\n- 使用您的表达式，对三个候选的 $B$ 值计算 $\\alpha(d,B)$，并确定对于给定的 $d$，能最小化索引别名（从而最小化冲突未命中）的 $B$ 值。如果出现平局，选择最小的 $B$。\n- 以字节为单位表示最优的 $B$。无需四舍五入。最终答案必须以一个两元素的行矩阵形式给出，第一个元素等于最优的 $B$，第二个元素等于您推导的 $\\alpha(d,B)$ 的通用闭式表达式。",
            "solution": "此问题被评估为有效，因为它自成体系，科学上基于计算机体系结构原理，且问题陈述清晰。我们可以进行形式化的求解。\n\n问题的核心是确定何时对数组 $X$ 的一次内存访问和对数组 $Y$ 的一次内存访问会映射到相同的缓存组索引。我们给定一个直接映射缓存。数组 $X$ 的第 $i$ 个元素的地址是 $A_X(i) = a_0 + i \\cdot e$，数组 $Y$ 的是 $A_Y(i) = a_0 + d + i \\cdot e$。\n\n根据所提供的定义，内存地址 $A$ 的缓存组索引 $s$ 由 $s(A) = \\lfloor A / B \\rfloor \\bmod N_s$ 给出，其中 $B$ 是缓存块大小，$N_s = C/B$ 是缓存中的组数。如果 $s(A_1) = s(A_2)$，则对地址 $A_1$ 和 $A_2$ 的两次访问在索引上发生别名。这等价于它们的块号满足以下条件：\n$$\n\\lfloor A_1/B \\rfloor \\equiv \\lfloor A_2/B \\rfloor \\pmod{N_s}\n$$\n对于给定的访问模式，如果在迭代 $i$ 时发生别名，则：\n$$\n\\lfloor \\frac{a_0 + i \\cdot e}{B} \\rfloor \\equiv \\lfloor \\frac{a_0 + d + i \\cdot e}{B} \\rfloor \\pmod{N_s}\n$$\n基地址 $a_0$ 与每个候选的块大小 $B$ 对齐，意味着 $a_0$ 是 $B$ 的倍数。我们可以写成 $a_0 = k \\cdot B$，其中 $k$ 是某个整数。将此代入同余关系式中得到：\n$$\n\\lfloor \\frac{k \\cdot B + i \\cdot e}{B} \\rfloor \\equiv \\lfloor \\frac{k \\cdot B + d + i \\cdot e}{B} \\rfloor \\pmod{N_s}\n$$\n$$\nk + \\lfloor \\frac{i \\cdot e}{B} \\rfloor \\equiv k + \\lfloor \\frac{d + i \\cdot e}{B} \\rfloor \\pmod{N_s}\n$$\n从两边减去 $k$，别名条件简化为：\n$$\n\\lfloor \\frac{i \\cdot e}{B} \\rfloor \\equiv \\lfloor \\frac{d + i \\cdot e}{B} \\rfloor \\pmod{N_s}\n$$\n我们来分析 $\\lfloor (d + i \\cdot e) / B \\rfloor$ 这一项。我们可以将 $d$ 相对于 $B$ 分解为 $d = q_d B + r_d$，其中商为 $q_d = \\lfloor d/B \\rfloor$，余数为 $r_d = d \\bmod B$，且 $0 \\le r_d  B$。类似地，令 $i \\cdot e = q_{ie} B + r_{ie}$，其中 $q_{ie} = \\lfloor (i \\cdot e)/B \\rfloor$ 且 $r_{ie} = (i \\cdot e) \\bmod B$。\n将这些代入同余式中：\n$$\nq_{ie} \\equiv \\lfloor \\frac{(q_d B + r_d) + (q_{ie} B + r_{ie})}{B} \\rfloor \\pmod{N_s}\n$$\n$$\nq_{ie} \\equiv q_d + q_{ie} + \\lfloor \\frac{r_d + r_{ie}}{B} \\rfloor \\pmod{N_s}\n$$\n这简化为迭代 $i$ 的基本别名条件：\n$$\n0 \\equiv \\lfloor \\frac{d}{B} \\rfloor + \\left\\lfloor \\frac{(d \\bmod B) + ((i \\cdot e) \\bmod B)}{B} \\right\\rfloor \\pmod{C/B}\n$$\n令 $\\Delta(i) = \\lfloor ((d \\bmod B) + ((i \\cdot e) \\bmod B)) / B \\rfloor$。由于 $0 \\le d \\bmod B  B$ 且 $0 \\le (i \\cdot e) \\bmod B  B$，分子中的和在 $[0, 2B-2]$ 范围内。因此，$\\Delta(i)$ 只能取值 $0$ 或 $1$。\n别名条件变为 $ \\lfloor d/B \\rfloor + \\Delta(i) \\equiv 0 \\pmod{C/B} $。\n\n$\\Delta(i)$ 的值通过 $(i \\cdot e) \\bmod B$ 这一项依赖于 $i$。这个序列是周期性的。周期长度 $P$ 是满足 $P \\cdot e \\equiv 0 \\pmod B$ 的最小正整数。它由 $P = B / \\gcd(e, B)$ 给出。令 $g = \\gcd(e, B)$。在一个周期的迭代 $i \\in \\{0, 1, \\dots, P-1\\}$ 中，$(i \\cdot e) \\bmod B$ 的值恰好是范围 $[0, B-1]$ 内 $g$ 的 $P$ 个不同倍数，即 $\\{0, g, 2g, \\dots, (P-1)g\\}$。\n\n我们分析这样一个周期内的别名条件。对于同余式 $ \\lfloor d/B \\rfloor + \\Delta(i) \\equiv 0 \\pmod{C/B} $，根据 $\\Delta(i)$ 的值会出现两种不同的情况：\n\\begin{enumerate}\n    \\item 情况 $\\Delta(i)=0$：条件是 $\\lfloor d/B \\rfloor \\equiv 0 \\pmod{C/B}$。这在 $(d \\bmod B) + ((i \\cdot e) \\bmod B)  B$ 时发生。\n    \\item 情况 $\\Delta(i)=1$：条件是 $\\lfloor d/B \\rfloor + 1 \\equiv 0 \\pmod{C/B}$。这在 $(d \\bmod B) + ((i \\cdot e) \\bmod B) \\ge B$ 时发生。\n\\end{enumerate}\n由于对于所有候选的 $B$ 值，$C/B > 1$，所以这两个关于 $\\lfloor d/B \\rfloor$ 的条件是互斥的。\n\n让我们找出在一个周期 $P$ 内，使得 $\\Delta(i)=0$ 和 $\\Delta(i)=1$ 的迭代次数。令 $r_d = d \\bmod B$。\n当 $(i \\cdot e) \\bmod B \\ge B - r_d$ 时，$\\Delta(i)=1$。$(i \\cdot e) \\bmod B$ 的值是 $g=\\gcd(e,B)$ 的倍数。这类值的数量 $N_{\\Delta=1}$ 是区间 $[B-r_d, B-1]$ 内 $g$ 的倍数的个数。这个计数由 $\\lfloor (B-1)/g \\rfloor - \\lceil (B-r_d)/g \\rceil + 1 = (P-1) - \\lceil (B-r_d)/g \\rceil + 1 = P - \\lceil (B-r_d)/g \\rceil$ 给出。\n$\\Delta(i)=0$ 的迭代次数 $N_{\\Delta=0}$ 是 $P - N_{\\Delta=1} = \\lceil (B-r_d)/g \\rceil = \\lceil (B-(d \\bmod B))/\\gcd(e,B) \\rceil$。\n\n长期来看，发生别名的迭代比例 $\\alpha(d,B)$ 是一个周期内发生别名的迭代次数除以周期长度 $P$。\n\\begin{itemize}\n    \\item 如果 $\\lfloor d/B \\rfloor \\equiv 0 \\pmod{C/B}$，则仅在 $\\Delta(i)=0$ 时发生别名。该比例为 $\\alpha(d,B) = N_{\\Delta=0} / P$。\n    \\item 如果 $\\lfloor d/B \\rfloor + 1 \\equiv 0 \\pmod{C/B}$，则仅在 $\\Delta(i)=1$ 时发生别名。该比例为 $\\alpha(d,B) = N_{\\Delta=1} / P = (P-N_{\\Delta=0})/P = 1 - N_{\\Delta=0}/P$。\n    \\item 否则，不发生别名，$\\alpha(d,B) = 0$。\n\\end{itemize}\n这得出了 $\\alpha(d,B)$ 的以下分段表达式。为遵循允许使用的函数，我们将 $\\lceil x \\rceil$ 替换为 $-\\lfloor -x \\rfloor$：\n令 $N_0(d,B) = -\\lfloor -\\frac{B - (d \\bmod B)}{\\gcd(e,B)} \\rfloor$。\n$\\alpha(d,B) = \\begin{cases} \\frac{N_0(d,B)}{B/\\gcd(e,B)}   \\text{若 } \\lfloor d/B \\rfloor \\equiv 0 \\pmod{C/B} \\\\ 1 - \\frac{N_0(d,B)}{B/\\gcd(e,B)}   \\text{若 } \\lfloor d/B \\rfloor + 1 \\equiv 0 \\pmod{C/B} \\\\ 0   \\text{其他情况} \\end{cases}$\n\n现在，我们针对给定参数 $d = 65400$，$C = 64 \\times 1024 = 65536$ 和 $e = 8$ 计算此表达式的值。\n\n\\textbf{情况 1：$B=128$ 字节}\n\\begin{itemize}\n    \\item $\\gcd(e,B) = \\gcd(8, 128) = 8$。\n    \\item $N_s = C/B = 65536 / 128 = 512$。\n    \\item $\\lfloor d/B \\rfloor = \\lfloor 65400 / 128 \\rfloor = \\lfloor 510.9375 \\rfloor = 510$。\n    \\item 我们检查 $\\lfloor d/B \\rfloor = 510$ 和 $N_s=512$ 的同余条件：\n    $510 \\not\\equiv 0 \\pmod{512}$ 且 $510+1 = 511 \\not\\equiv 0 \\pmod{512}$。\n    \\item 由于两个条件都不满足，$\\alpha(65400, 128) = 0$。\n\\end{itemize}\n\n\\textbf{情况 2：$B=256$ 字节}\n\\begin{itemize}\n    \\item $\\gcd(e,B) = \\gcd(8, 256) = 8$。\n    \\item $N_s = C/B = 65536 / 256 = 256$。\n    \\item $\\lfloor d/B \\rfloor = \\lfloor 65400 / 256 \\rfloor = \\lfloor 255.46875 \\rfloor = 255$。\n    \\item 我们检查 $\\lfloor d/B \\rfloor = 255$ 和 $N_s=256$ 的同余条件：\n    $255 \\not\\equiv 0 \\pmod{256}$，但 $255+1 = 256 \\equiv 0 \\pmod{256}$。\n    \\item 这是我们公式的第二种情况。我们计算 $N_0(d,B)$：\n    $d \\bmod B = 65400 \\bmod 256 = 120$。\n    $N_0(65400,256) = \\lceil \\frac{256-120}{8} \\rceil = \\lceil \\frac{136}{8} \\rceil = \\lceil 17 \\rceil = 17$。\n    周期为 $P = B/g = 256/8 = 32$。\n    $\\alpha(65400, 256) = 1 - \\frac{17}{32} = \\frac{15}{32}$。\n\\end{itemize}\n\n\\textbf{情况 3：$B=512$ 字节}\n\\begin{itemize}\n    \\item $\\gcd(e,B) = \\gcd(8, 512) = 8$。\n    \\item $N_s = C/B = 65536 / 512 = 128$。\n    \\item $\\lfloor d/B \\rfloor = \\lfloor 65400 / 512 \\rfloor = \\lfloor 127.734375 \\rfloor = 127$。\n    \\item 我们检查 $\\lfloor d/B \\rfloor = 127$ 和 $N_s=128$ 的同余条件：\n    $127 \\not\\equiv 0 \\pmod{128}$，但 $127+1 = 128 \\equiv 0 \\pmod{128}$。\n    \\item 这也是第二种情况。我们计算 $N_0(d,B)$：\n    $d \\bmod B = 65400 \\bmod 512 = 376$。\n    $N_0(65400,512) = \\lceil \\frac{512-376}{8} \\rceil = \\lceil \\frac{136}{8} \\rceil = \\lceil 17 \\rceil = 17$。\n    周期为 $P = B/g = 512/8 = 64$。\n    $\\alpha(65400, 512) = 1 - \\frac{17}{64} = \\frac{47}{64}$。\n\\end{itemize}\n\n比较别名比例：\n\\begin{itemize}\n    \\item $\\alpha(d, 128) = 0$\n    \\item $\\alpha(d, 256) = 15/32 = 0.46875$\n    \\item $\\alpha(d, 512) = 47/64 \\approx 0.734375$\n\\end{itemize}\n最小别名比例为 $0$，这是在块大小 $B=128$ 字节时实现的。因此，最优块大小为 $128$。\n\n最终答案需要最优的 $B$ 值以及 $\\alpha(d,B)$ 的通用闭式表达式。\n使用仅允许的函数，通用表达式为：\n$$\n\\alpha(d,B) =\n\\begin{cases}\n\\frac{-\\lfloor -\\frac{B - (d \\bmod B)}{\\gcd(e,B)} \\rfloor}{B/\\gcd(e,B)}   \\text{若 } \\lfloor d/B \\rfloor \\equiv 0 \\pmod{C/B} \\\\\n1 - \\frac{-\\lfloor -\\frac{B - (d \\bmod B)}{\\gcd(e,B)} \\rfloor}{B/\\gcd(e,B)}   \\text{若 } \\lfloor d/B \\rfloor + 1 \\equiv 0 \\pmod{C/B} \\\\\n0   \\text{其他情况}\n\\end{cases}\n$$",
            "answer": "$$\\boxed{\\pmatrix{128  \\begin{cases} \\frac{-\\lfloor -\\frac{B - (d \\bmod B)}{\\gcd(e,B)} \\rfloor}{B/\\gcd(e,B)}  \\text{若 } \\lfloor d/B \\rfloor \\equiv 0 \\pmod{C/B} \\\\ 1 - \\frac{-\\lfloor -\\frac{B - (d \\bmod B)}{\\gcd(e,B)} \\rfloor}{B/\\gcd(e,B)}  \\text{若 } \\lfloor d/B \\rfloor + 1 \\equiv 0 \\pmod{C/B} \\\\ 0  \\text{其他情况} \\end{cases} }}$$"
        },
        {
            "introduction": "缓存块大小的影响延伸到了并发编程领域，其中最显著的就是伪共享（false sharing）现象。本问题通过让你分析一个常见的生产者-消费者数据结构来探讨这种关键的硬件-软件交互。你将运用概率推理来量化伪共享的频率，并计算为防止它所需的开销，从而突显出缓存感知数据结构设计的重要性。",
            "id": "3624217",
            "problem": "一个软件系统在主内存中以连续字节数组（环形缓冲区）的形式实现了一个单生产者单消费者（SPSC）队列。消息是可变大小的，并在缓冲区中背靠背地打包，没有显式的对齐或填充。处理器的-数据缓存使用大小为 $B$ 字节的固定大小缓存行。每个缓存行包含的地址，其除以 $B$ 的整数除法结果得到相同的商；如果两个对象的任何字节位于同一个大小为 $B$ 的区间内，则它们共享一个缓存行。\n\n假设以下科学上真实的条件：\n- 缓冲区的起始地址模 $B$ 是均匀随机的，即，它与最近的较低缓存行边界的位移在 $\\{0, 1, \\dots, B-1\\}$ 上均匀分布，并且与消息大小无关。这模拟了典型的分配器可变性，并确保缓冲区基址没有固定地与缓存行对齐。\n- 队列足够大，因此对于局部缓存行交互的目的，可以忽略环绕效应。\n- 消息大小 $S_i$（以字节为单位）与此基址位移无关，并且可以是任意正整数；它们的分布或任何特定值都未向您透露。消息打包时没有任何填充：消息 $i+1$ 的起始位置紧随消息 $i$ 的末尾。\n\n将在边界 $i$ 发生的“伪共享事件”定义为：消息 $i$ 和 $i+1$ 占据至少一个公共缓存行，因此消息 $i$ 的末尾和消息 $i+1$ 的开头位于同一缓存行中。考虑以下几点：\n\n1. 仅使用缓存行和地址上的模运算的核心定义，推导预期的伪共享频率 $f(B)$，定义为消息共享缓存行的边界的预期比例，表示为仅关于 $B$ 的函数。您的推导应从以下定义开始：两个连续消息当且仅当第一个消息的结束位置不在缓存行边界上时，才共享一个缓存行。\n\n2. 提出一种行感知填充方案，通过在每个消息后插入所需的最少填充字节数来消除消息间的行共享，以使下一个消息在下一个缓存行边界开始。设 $p_i$ 为此方案下每个边界的填充字节数，并假设消息末端位移模 $B$ 的均匀性条件与上述相同。推导出每个边界的精确预期填充量 $\\mathbb{E}[p_i]$，作为 $B$ 的解析函数。\n\n将您的最终答案表示为一个行矩阵，其第一个条目是 $f(B)$ 的精确表达式（作为小数是无量纲的），第二个条目是 $\\mathbb{E}[p_i]$（以字节为单位）的精确表达式。无需四舍五入；提供以 $B$ 表示的精确表达式。以字节表示填充量。",
            "solution": "该问题陈述已经过验证，被认为是科学上可靠、定义明确、客观且内部一致的。它提出了一个在计算机系统性能分析领域中可解的问题。\n\n**第1部分：预期伪共享频率 $f(B)$ 的推导**\n\n设 $B$ 为缓存行的大小（以字节为单位），其中 $B$ 是一个正整数。缓存行被定义为大小为 $B$ 的连续内存块，对齐到 $B$ 的倍数的地址。地址 $A$ 属于由商 $\\lfloor A/B \\rfloor$ 标识的缓存行。\n\n如果消息 $i$ 的末尾和消息 $i+1$ 的开头位于同一缓存行中，则在消息 $i$ 和消息 $i+1$ 之间的边界上发生伪共享事件。设 $A_i$ 是消息 $i$ 的最后一个字节的地址。消息 $i+1$ 的第一个字节位于地址 $A_i+1$。伪共享的条件是包含 $A_i$ 的缓存行与包含 $A_i+1$ 的缓存行相同。这在数学上表示为：\n$$\n\\lfloor \\frac{A_i}{B} \\rfloor = \\lfloor \\frac{A_i+1}{B} \\rfloor\n$$\n这个等式成立当且仅当 $A_i+1$ 不是 $B$ 的倍数。用模运算的术语来说，这等价于：\n$$\n(A_i+1) \\pmod B \\neq 0\n$$\n这与以下表达式相同：\n$$\nA_i \\pmod B \\neq B-1\n$$\n这证实了问题的起始前提：伪共享发生当且仅当第一个消息的结束位置不在缓存行边界上（即，不是缓存行的最后一个字节）。\n\n设 $d_i = A_i \\pmod B$ 为消息 $i$ 的末尾相对于其缓存行起始位置的位移。变量 $d_i$ 可以取集合 $\\{0, 1, \\dots, B-1\\}$ 中的任何整数值。\n\n问题陈述指出，缓冲区的起始地址（我们称之为 $A_{start}$）模 $B$ 是均匀随机的。这意味着其位移 $d_{start} = A_{start} \\pmod B$ 是在 $\\{0, 1, \\dots, B-1\\}$ 上的离散均匀随机变量。消息 $i$ 末尾的地址可以写为：\n$$\nA_i = A_{start} + \\left( \\sum_{j=1}^{i} S_j \\right) - 1\n$$\n其中 $S_j$ 是消息 $j$ 的大小。对此取模 $B$，我们得到：\n$$\nd_i = A_i \\pmod B = \\left( (A_{start} \\pmod B) + \\left( \\left( \\sum_{j=1}^{i} S_j \\right) - 1 \\right) \\right) \\pmod B\n$$\n设 $X = A_{start} \\pmod B$。$X$ 在 $\\{0, 1, \\dots, B-1\\}$ 上均匀分布。设 $Y_i = \\left( \\left( \\sum_{j=1}^{i} S_j \\right) - 1 \\right) \\pmod B$。问题陈述指出，消息大小 $S_j$ 与缓冲区的基址位移无关。因此，随机变量 $Y_i$ 与 $X$ 无关。位移 $d_i$ 由 $d_i = (X + Y_i) \\pmod B$ 给出。\n\n概率论中的一个基本结果指出，一个在 $\\{0, 1, \\dots, N-1\\}$ 上的离散均匀随机变量与任何独立的整数值随机变量的和（模 $N$）也是一个在 $\\{0, 1, \\dots, N-1\\}$ 上的离散均匀随机变量。在我们的例子中，$N=B$。因此，$d_i$ 在集合 $\\{0, 1, \\dots, B-1\\}$ 上均匀分布。$d_i$ 取该集合中任何特定值 $k$ 的概率是：\n$$\nP(d_i = k) = \\frac{1}{B} \\quad \\text{for } k \\in \\{0, 1, \\dots, B-1\\}\n$$\n伪共享频率 $f(B)$ 是在任意边界上发生伪共享事件的概率。该事件在 $d_i \\neq B-1$ 时发生。我们可以通过1减去其互补事件 $d_i = B-1$ 的概率来计算这个概率：\n$$\nf(B) = P(d_i \\neq B-1) = 1 - P(d_i = B-1)\n$$\n使用 $d_i$ 的均匀分布：\n$$\nf(B) = 1 - \\frac{1}{B} = \\frac{B-1}{B}\n$$\n\n**第2部分：每个边界的预期填充量 $\\mathbb{E}[p_i]$ 的推导**\n\n所提出的填充方案在消息 $i$ 之后插入最少数量的填充字节 $p_i \\ge 0$，以使消息 $i+1$ 在下一个缓存行边界开始。\n\n消息 $i$ 的末尾位于地址 $A_i$。消息 $i+1$ 的存储空间在填充之后开始。消息 $i+1$ 的起始地址将是 $A_{start, i+1} = A_i + 1 + p_i$。条件是该地址必须是 $B$ 的倍数，即新缓存行的开始。\n$$\n(A_i + 1 + p_i) \\pmod B = 0\n$$\n我们使用位移 $d_i = A_i \\pmod B$。方程变为：\n$$\n(d_i + 1 + p_i) \\pmod B = 0\n$$\n由于 $d_i \\in \\{0, 1, \\dots, B-1\\}$ 且 $p_i \\ge 0$，满足此同余式的最小非负 $p_i$ 将使括号内的项等于 $B$。\n$$\nd_i + 1 + p_i = B\n$$\n求解 $p_i$，我们得到给定-位移 $d_i$ 所需的填充字节数：\n$$\np_i = B - 1 - d_i\n$$\n这个函数正确地将位移 $d_i$ 映射到所需的填充量。例如，如果 $d_i=B-1$（消息在行的最后一个字节结束），则需要 $p_i = B - 1 - (B-1) = 0$ 字节的填充。如果 $d_i=0$（消息在行的第一个字节结束），则需要 $p_i = B - 1 - 0 = B-1$ 字节来填充该行的剩余部分。\n\n我们需要找到预期的填充量 $\\mathbb{E}[p_i]$。我们使用期望的线性性质：\n$$\n\\mathbb{E}[p_i] = \\mathbb{E}[B - 1 - d_i] = \\mathbb{E}[B] - \\mathbb{E}[1] - \\mathbb{E}[d_i] = B - 1 - \\mathbb{E}[d_i]\n$$\n问题陈述要求对消息末端假设相同的均匀性条件，这在第1部分中已经推导过。位移 $d_i$ 是在 $\\{0, 1, \\dots, B-1\\}$ 上的离散均匀随机变量。这样一个变量的期望是：\n$$\n\\mathbb{E}[d_i] = \\sum_{k=0}^{B-1} k \\cdot P(d_i=k) = \\sum_{k=0}^{B-1} k \\cdot \\frac{1}{B} = \\frac{1}{B} \\sum_{k=0}^{B-1} k\n$$\n前 $B-1$ 个非负整数的和由公式 $\\frac{(B-1)B}{2}$ 给出。\n$$\n\\mathbb{E}[d_i] = \\frac{1}{B} \\left( \\frac{(B-1)B}{2} \\right) = \\frac{B-1}{2}\n$$\n将此结果代回 $\\mathbb{E}[p_i]$ 的表达式中：\n$$\n\\mathbb{E}[p_i] = B - 1 - \\frac{B-1}{2} = (B - 1) \\left( 1 - \\frac{1}{2} \\right) = \\frac{B-1}{2}\n$$\n每个边界的预期填充量是 $\\frac{B-1}{2}$ 字节。\n\n最终答案要求一个包含 $f(B)$ 和 $\\mathbb{E}[p_i]$ 的行矩阵。\n第一个条目是 $f(B) = \\frac{B-1}{B}$。\n第二个条目是 $\\mathbb{E}[p_i] = \\frac{B-1}{2}$。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{B-1}{B}  \\frac{B-1}{2} \\end{pmatrix}}\n$$"
        }
    ]
}