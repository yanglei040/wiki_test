{
    "hands_on_practices": [
        {
            "introduction": "本练习旨在阐明一个基本概念：在写操作缺乏空间局部性的情况下，选择较大的缓存块（cache block）会带来何种代价。我们将通过一个具体的计算，来量化在“写分配”（write-allocate）策略下，因访存模式与块大小不匹配而导致的带宽浪费，从而为理解缓存块大小的权衡提供一个直观的起点。",
            "id": "3624214",
            "problem": "一个程序对驻留在主存中的一个大数组执行稀疏存储。每次存储操作都会将 $w$ 字节（一个 $32$ 位字）写入一个地址，该地址在一个非常大的区域内均匀随机选择，以至于相对于缓存容量，时间和空间局部性可以忽略不计。处理器使用写分配、写回的缓存层次结构。在存储未命中时，内存系统会发出一个针对整个大小为 $B$ 字节的缓存块的获取所有权读取（RFO）请求。在缓存块被逐出之前，该程序从不读取被取回的块中的任何其他字节，也不会对同一块执行任何额外的存储操作。\n\n假设一级数据缓存的缓存行大小为 $B = 64$ 字节，并且每次存储写入 $w = 4$ 字节。仅使用缓存块和写分配行为的核心定义，计算每次存储未命中传输的字节中无用字节的比例（以小数表示，不要使用百分号），这些无用字节是指由 RFO 获取但从未被程序使用的字节。将您的答案四舍五入到 $4$ 位有效数字。",
            "solution": "该问题已经过验证，被确定为具有科学依据、问题明确且客观。它提出了一个计算机体系结构中的标准场景，用于分析在空间局部性差的条件下的缓存性能。所有必要的数据和约束条件都已提供。\n\n问题要求计算在存储未命中期间传输的字节中“无用”字节的比例。在采用写分配缓存策略的处理器中，存储未命中会触发一个获取所有权读取（RFO）请求。该请求将包含目标内存地址的整个缓存块（也称为缓存行）从主存取回到缓存中。只有当该块存在于缓存中之后，存储操作才能完成。\n\n设 $B$ 为缓存块的大小（以字节为单位）。问题指出，一级数据缓存的缓存行大小为 $B = 64$ 字节。\n设 $w$ 为单次存储操作写入的数据大小（以字节为单位）。问题指出，每次存储写入一个 $32$ 位的字，相当于 $w = \\frac{32}{8} = 4$ 字节。\n\n每次存储未命中时从主存传输到缓存的总字节数等于完整的缓存块大小 $B$。我们将此数量表示为 $N_{total}$。\n$$N_{total} = B$$\n\n问题指明了被取回数据的访问模式和使用情况：\n$1$. 存储操作将 $w$ 字节写入块内的特定地址。这些是唯一被程序修改的字节。\n$2$. 问题明确指出：“在缓存块被逐出之前，该程序从不读取被取回的块中的任何其他字节，也不会对同一块执行任何额外的存储操作。”\n\n这组条件精确地定义了哪些字节是“已使用”的。已使用的字节是作为存储操作目标的 $w$ 个字节。我们将已使用的字节数表示为 $N_{used}$。\n$$N_{used} = w$$\n\n“无用”字节是那些作为缓存块的一部分被传输，但既未被程序读取也未被写入的字节。无用字节的数量，记为 $N_{useless}$，是传输的总字节数与已使用字节数之差。\n$$N_{useless} = N_{total} - N_{used} = B - w$$\n\n所求的量是传输的字节中无用字节的比例。设此比例为 $F_{useless}$。\n$$F_{useless} = \\frac{N_{useless}}{N_{total}}$$\n代入 $N_{useless}$ 和 $N_{total}$ 的表达式：\n$$F_{useless} = \\frac{B - w}{B} = 1 - \\frac{w}{B}$$\n\n现在，我们代入问题陈述中提供的数值：\n$B = 64$ 字节\n$w = 4$ 字节\n\n$$F_{useless} = \\frac{64 - 4}{64} = \\frac{60}{64}$$\n\n为了将此分数表示为小数，我们进行除法运算：\n$$\\frac{60}{64} = \\frac{15 \\times 4}{16 \\times 4} = \\frac{15}{16}$$\n$$F_{useless} = 0.9375$$\n\n问题要求答案四舍五入到 $4$ 位有效数字。计算出的值 $0.9375$ 已经恰好包含四位有效数字（$9$、$3$、$7$、$5$）。因此，无需进一步四舍五入。\n每次存储未命中传输的字节中无用字节的比例为 $0.9375$。这种低效率是空间局部性差的工作负载的典型特征，在这种情况下，获取整个缓存块除了服务于当前的内存访问之外，几乎不提供任何额外的好处。",
            "answer": "$$\\boxed{0.9375}$$"
        },
        {
            "introduction": "这个实践将我们的视角从单个内存访问提升到对软件数据结构性能的影响。我们将探讨一个在并发编程中至关重要的问题——伪共享（false sharing），即逻辑上不相关的数据因位于同一缓存块而引发不必要的缓存一致性开销。通过本练习，你将运用概率论的工具来量化伪共享发生的频率，并设计一种填充策略以消除这种性能瓶颈。",
            "id": "3624217",
            "problem": "一个软件系统在主内存中以连续字节数组（环形缓冲区）的形式实现了一个单生产者单消费者（SPSC）队列。消息是可变大小的，并在缓冲区中背靠背地紧密排列，没有显式的对齐或填充。处理器的数据缓存使用大小为 $B$ 字节的固定大小缓存行。每个缓存行包含的地址除以 $B$ 的整数部分得到相同的商；如果两个对象的任何字节位于同一个这样的 $B$ 大小的区间内，则它们共享一个缓存行。\n\n假设存在以下科学上真实的条件：\n- 缓冲区的起始地址模 $B$ 均匀随机，即它与最近的较低缓存行边界的位移在 $\\{0, 1, \\dots, B-1\\}$ 上均匀分布，且与消息大小无关。这模拟了典型分配器的可变性，并确保缓冲区基址与缓存行之间没有固定的对齐关系。\n- 队列足够大，因此对于局部缓存行交互的分析，可以忽略回绕效应。\n- 消息大小 $S_i$（以字节为单位）与此基址位移无关，可以是任意正整数；它们的分佈或任何特定值均未向您透露。消息紧密排列，没有任何填充：消息 $i+1$ 的起始位置紧随消息 $i$ 的结束位置。\n\n将在边界 $i$ 处发生“伪共享事件”定义为：如果消息 $i$ 和消息 $i+1$ 占据至少一个共同的缓存行，从而使得消息 $i$ 的末尾和消息 $i+1$ 的开头位于同一个缓存行内。请考虑以下问题：\n\n1. 仅使用缓存行和地址模运算的核心定义，推导期望伪共享频率 $f(B)$，该频率定义为消息共享缓存行的边界所占的期望分数，表示为仅关于 $B$ 的函数。您的推导应从以下定义开始：两个连续消息共享一个缓存行，当且仅当第一条消息的结束位置不在缓存行边界上。\n\n2. 提出一种缓存行感知的填充方案，通过在每条消息后插入所需的最少填充字节数，以消除消息间的缓存行共享，使得下一条消息在下一个缓存行边界处开始。设 $p_i$ 为此方案下每个边界的填充字节数，并假设消息末端模 $B$ 的位移与上述均匀性条件相同。推导每个边界的精确期望填充量 $\\mathbb{E}[p_i]$，作为关于 $B$ 的解析函数。\n\n将您的最终答案表示为一个行矩阵，其第一个元素是 $f(B)$ 的精确表达式（作为无量纲的小数），第二个元素是 $\\mathbb{E}[p_i]$ 的精确表达式（以字节为单位）。不需要四舍五入；请提供以 $B$ 表示的精确表达式。填充量以字节表示。",
            "solution": "问题陈述已经过验证，被认为是科学上合理、定义明确、客观且内部一致的。它提出了一个在计算机系统性能分析领域中可解的问题。\n\n**第一部分：期望伪共享频率 $f(B)$ 的推导**\n\n设 $B$ 为缓存行的大小（以字节为单位），其中 $B$ 是一个正整数。缓存行被定义为大小为 $B$ 字节并对齐到 $B$ 的倍数地址的连续内存块。地址 $A$ 属于由商 $\\lfloor A/B \\rfloor$ 标识的缓存行。\n\n在消息 $i$ 和消息 $i+1$ 之间的边界上发生伪共享事件，是指消息 $i$ 的末尾和消息 $i+1$ 的开头位于同一个缓存行内。设 $A_i$ 为消息 $i$ 最后一个字节的地址。消息 $i+1$ 的第一个字节位于地址 $A_i+1$。伪共享的条件是包含 $A_i$ 的缓存行与包含 $A_i+1$ 的缓存行相同。这在数学上表示为：\n$$\n\\lfloor \\frac{A_i}{B} \\rfloor = \\lfloor \\frac{A_i+1}{B} \\rfloor\n$$\n这个等式成立的充要条件是 $A_i+1$ 不是 $B$ 的倍数。用模运算来说，这等价于：\n$$\n(A_i+1) \\pmod B \\neq 0\n$$\n这与以下表达式相同：\n$$\nA_i \\pmod B \\neq B-1\n$$\n这证实了问题的初始前提：伪共享发生当且仅当第一条消息的结束位置不在缓存行边界上（即，不是缓存行的最后一个字节）。\n\n设 $d_i = A_i \\pmod B$ 为消息 $i$ 末尾相对于其所在缓存行起始位置的位移。变量 $d_i$ 可以取集合 $\\{0, 1, \\dots, B-1\\}$ 中的任何整数值。\n\n问题陈述指出，缓冲区的起始地址（我们称之为 $A_{start}$）是模 $B$ 均匀随机的。这意味着它的位移 $d_{start} = A_{start} \\pmod B$ 是在 $\\{0, 1, \\dots, B-1\\}$ 上的一个离散均匀随机变量。消息 $i$ 末尾的地址可以写为：\n$$\nA_i = A_{start} + \\left( \\sum_{j=1}^{i} S_j \\right) - 1\n$$\n其中 $S_j$ 是消息 $j$ 的大小。对此取模 $B$，我们得到：\n$$\nd_i = A_i \\pmod B = \\left( (A_{start} \\pmod B) + \\left( \\left( \\sum_{j=1}^{i} S_j \\right) - 1 \\right) \\right) \\pmod B\n$$\n设 $X = A_{start} \\pmod B$。$X$ 在 $\\{0, 1, \\dots, B-1\\}$ 上均匀分布。设 $Y_i = \\left( \\left( \\sum_{j=1}^{i} S_j \\right) - 1 \\right) \\pmod B$。问题陈述指出消息大小 $S_j$ 与缓冲区的基址位移无关。因此，随机变量 $Y_i$ 与 $X$ 无关。位移 $d_i$ 由 $d_i = (X + Y_i) \\pmod B$ 给出。\n\n概率论中的一个基本结论指出，一个在 $\\{0, 1, \\dots, N-1\\}$ 上的离散均匀随机变量与任何独立的整值随机变量的和（模 $N$）也是一个在 $\\{0, 1, \\dots, N-1\\}$ 上的离散均匀随机变量。在我们的例子中，$N=B$。因此，$d_i$ 在集合 $\\{0, 1, \\dots, B-1\\}$ 上均匀分布。$d_i$ 取该集合中任意特定值 $k$ 的概率是：\n$$\nP(d_i = k) = \\frac{1}{B} \\quad \\text{for } k \\in \\{0, 1, \\dots, B-1\\}\n$$\n伪共享频率 $f(B)$ 是在任意边界上发生伪共享事件的概率。该事件在 $d_i \\neq B-1$ 时发生。我们可以通过从 1 中减去其互补事件 $d_i = B-1$ 的概率来计算这个概率：\n$$\nf(B) = P(d_i \\neq B-1) = 1 - P(d_i = B-1)\n$$\n利用 $d_i$ 的均匀分布：\n$$\nf(B) = 1 - \\frac{1}{B} = \\frac{B-1}{B}\n$$\n\n**第二部分：每个边界的期望填充量 $\\mathbb{E}[p_i]$ 的推导**\n\n所提出的填充方案在消息 $i$ 之后插入最少数量的填充字节 $p_i \\ge 0$，以使消息 $i+1$ 在下一个缓存行边界处开始。\n\n消息 $i$ 的末尾位于地址 $A_i$。消息 $i+1$ 的存储空间在填充之后开始。消息 $i+1$ 的起始地址将是 $A_{start, i+1} = A_i + 1 + p_i$。条件是该地址必须是 $B$ 的倍数，即新缓存行的开始。\n$$\n(A_i + 1 + p_i) \\pmod B = 0\n$$\n让我们使用位移 $d_i = A_i \\pmod B$。方程变为：\n$$\n(d_i + 1 + p_i) \\pmod B = 0\n$$\n由于 $d_i \\in \\{0, 1, \\dots, B-1\\}$ 且 $p_i \\ge 0$，满足此同余式的最小非负 $p_i$ 会使括号内的项等于 $B$。\n$$\nd_i + 1 + p_i = B\n$$\n解出 $p_i$，我们得到对于给定位移 $d_i$ 所需的填充字节数：\n$$\np_i = B - 1 - d_i\n$$\n该函数正确地将位移 $d_i$ 映射到所需的填充量。例如，如果 $d_i=B-1$（消息在行的最后一个字节结束），则需要 $p_i = B - 1 - (B-1) = 0$ 字节的填充。如果 $d_i=0$（消息在行的第一个字节结束），则需要 $p_i = B - 1 - 0 = B-1$ 字节来填充该行的剩余部分。\n\n我们需要找到期望填充量 $\\mathbb{E}[p_i]$。我们使用期望的线性性质：\n$$\n\\mathbb{E}[p_i] = \\mathbb{E}[B - 1 - d_i] = \\mathbb{E}[B] - \\mathbb{E}[1] - \\mathbb{E}[d_i] = B - 1 - \\mathbb{E}[d_i]\n$$\n问题陈述要求对消息末端假设相同的均匀性条件，这我们在第一部分已经推导过。位移 $d_i$ 是在 $\\{0, 1, \\dots, B-1\\}$ 上的一个离散均匀随机变量。这种变量的期望是：\n$$\n\\mathbb{E}[d_i] = \\sum_{k=0}^{B-1} k \\cdot P(d_i=k) = \\sum_{k=0}^{B-1} k \\cdot \\frac{1}{B} = \\frac{1}{B} \\sum_{k=0}^{B-1} k\n$$\n前 $B-1$ 个非负整数的和由公式 $\\frac{(B-1)B}{2}$ 给出。\n$$\n\\mathbb{E}[d_i] = \\frac{1}{B} \\left( \\frac{(B-1)B}{2} \\right) = \\frac{B-1}{2}\n$$\n将此结果代回 $\\mathbb{E}[p_i]$ 的表达式中：\n$$\n\\mathbb{E}[p_i] = B - 1 - \\frac{B-1}{2} = (B - 1) \\left( 1 - \\frac{1}{2} \\right) = \\frac{B-1}{2}\n$$\n每个边界的期望填充量是 $\\frac{B-1}{2}$ 字节。\n\n最终答案要求一个包含 $f(B)$ 和 $\\mathbb{E}[p_i]$ 的行矩阵。\n第一个元素是 $f(B) = \\frac{B-1}{B}$。\n第二个元素是 $\\mathbb{E}[p_i] = \\frac{B-1}{2}$。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{B-1}{B} & \\frac{B-1}{2} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "最后的这个综合性练习将挑战你对系统整体性能的把握能力。在一个执行混合工作负载的真实场景中，最优的缓存块大小是一个需要权衡的动态决策，它取决于利用空间局部性的增益与增加未命中惩罚的代价之间的平衡。你将构建一个完整的$CPI$（每指令周期数）模型，并运用微积分方法找到能使系统性能最大化的最佳缓存块大小，这正是计算机系统结构设计者在实践中解决核心问题的方式。",
            "id": "3624223",
            "problem": "一个单发射顺序执行处理器执行一个大型程序，该程序由两个具有不同内存访问模式的内核组成。在没有内存停顿的情况下，处理器的基础每指令周期数（CPI）为 $CPI_{0}=1.00$ 个周期/指令。一级缓存（Level-1 (L1)）的未命中会使流水线停顿，其服务时间由固定的片外延迟加上与缓存块（行）大小成正比的传输时间组成。\n\n假设以下经过充分检验的事实和定义：\n- 每指令周期数（CPI）是总周期数除以已退役指令的数量。\n- 总周期数等于基础执行周期数和停顿周期数之和。\n- 对于在缓存中未命中的内存访问，未命中服务时间是到第一个响应的固定延迟与整个块的线性传输时间之和。将固定延迟表示为 $L$（单位为周期），块大小表示为 $B$（单位为字节），持续内存带宽表示为 $W$（单位为字节/周期），因此未命中服务时间为 $L + B/W$ 个周期。\n- 如果一个内核每条指令发出 $r$ 次内存引用，并且每次引用的未命中概率为 $m(B)$（一个无单位的分数），那么该内核贡献的每条指令的预期停顿周期数等于 $r \\, m(B)$ 乘以未命中服务时间。\n\n该程序由两种内核按指令数混合组成：\n- 内核 $\\mathcal{A}$（流式）：占已退役指令的比例 $f_{\\mathcal{A}}=0.6$；内存引用强度 $r_{\\mathcal{A}}=0.6$ 次引用/指令；经验性未命中率拟合为 $m_{\\mathcal{A}}(B)=\\frac{8}{B}+0.01$，在 $B \\in [16,256]$ 字节范围内有效。\n- 内核 $\\mathcal{B}$（跨步/类随机）：占已退役指令的比例 $f_{\\mathcal{B}}=0.4$；内存引用强度 $r_{\\mathcal{B}}=0.3$ 次引用/指令；经验性未命中率拟合为 $m_{\\mathcal{B}}(B)=\\frac{4}{B}+0.3$，在 $B \\in [16,256]$ 字节范围内有效。\n\n片外固定延迟为 $L=50$ 个周期，持续带宽为 $W=8$ 字节/周期。假设未命中会序列化执行（未命中惩罚没有重叠），并且经验性未命中率拟合已经包含了在所考虑的 $B$ 值下，所有强制性、容量性和冲突性行为的影响。\n\n仅使用上述基本定义，推导出该程序混合的整体CPI作为 $B$ 的函数，并确定在连续范围 $[16,256]$ 内使CPI最小化的缓存块大小 $B$（单位为字节）。只报告最优的 $B$ 值，并忽略任何关于块大小必须是2的幂的硬件约束。以字节为单位表达最终答案，并四舍五入到四位有效数字。",
            "solution": "该问题被验证为具有科学依据、定义明确、客观、完整且可验证。它代表了计算机体系结构中的一个标准优化问题。我现在将进行正式推导。\n\n处理器的整体每指令周期数（表示为 $CPI$）是基础CPI（$CPI_{0}$）与由内存访问引起的每指令停顿周期数之和。\n$$\nCPI = CPI_{0} + \\text{StallCyclesPerInstruction}_{\\text{total}}\n$$\n给定基础CPI为 $CPI_{0} = 1.00$。总的每指令停顿周期数是每个内核贡献的停顿周期的加权平均值，其中权重是属于每个内核的指令的比例。\n$$\n\\text{StallCyclesPerInstruction}_{\\text{total}} = f_{\\mathcal{A}} \\cdot (\\text{Stalls per instruction})_{\\mathcal{A}} + f_{\\mathcal{B}} \\cdot (\\text{Stalls per instruction})_{\\mathcal{B}}\n$$\n根据问题定义，给定内核的每指令停顿周期数是其每指令内存引用次数（$r$）、每次引用的未命中率（$m(B)$）和未命中服务时间的乘积。未命中服务时间由固定延迟 $L$ 和传输时间 $B/W$ 之和给出。\n$$\n\\text{Miss Service Time} = L + \\frac{B}{W}\n$$\n因此，内核 $\\mathcal{A}$ 和内核 $\\mathcal{B}$ 的每指令停顿周期数分别为：\n$$\n(\\text{Stalls per instruction})_{\\mathcal{A}} = r_{\\mathcal{A}} \\cdot m_{\\mathcal{A}}(B) \\cdot \\left( L + \\frac{B}{W} \\right)\n$$\n$$\n(\\text{Stalls per instruction})_{\\mathcal{B}} = r_{\\mathcal{B}} \\cdot m_{\\mathcal{B}}(B) \\cdot \\left( L + \\frac{B}{W} \\right)\n$$\n将这些代入总停顿周期的表达式中：\n$$\n\\text{StallCyclesPerInstruction}_{\\text{total}} = \\left[ f_{\\mathcal{A}} r_{\\mathcal{A}} m_{\\mathcal{A}}(B) + f_{\\mathcal{B}} r_{\\mathcal{B}} m_{\\mathcal{B}}(B) \\right] \\cdot \\left( L + \\frac{B}{W} \\right)\n$$\n让我们将程序混合的有效每指令未命中率 $M(B)$ 定义为方括号中的项：\n$$\nM(B) = f_{\\mathcal{A}} r_{\\mathcal{A}} m_{\\mathcal{A}}(B) + f_{\\mathcal{B}} r_{\\mathcal{B}} m_{\\mathcal{B}}(B)\n$$\n那么，整体 $CPI$ 作为块大小 $B$ 的函数为：\n$$\nCPI(B) = CPI_{0} + M(B) \\cdot \\left( L + \\frac{B}{W} \\right)\n$$\n我们已知以下值：\n- $CPI_{0} = 1.00$\n- $L=50$ 周期\n- $W=8$ 字节/周期\n- 对于内核 $\\mathcal{A}$：$f_{\\mathcal{A}}=0.6$, $r_{\\mathcal{A}}=0.6$, $m_{\\mathcal{A}}(B) = \\frac{8}{B} + 0.01$\n- 对于内核 $\\mathcal{B}$：$f_{\\mathcal{B}}=0.4$, $r_{\\mathcal{B}}=0.3$, $m_{\\mathcal{B}}(B) = \\frac{4}{B} + 0.3$\n\n首先，我们计算乘积 $f_{\\mathcal{A}} r_{\\mathcal{A}}$ 和 $f_{\\mathcal{B}} r_{\\mathcal{B}}$：\n$$\nf_{\\mathcal{A}} r_{\\mathcal{A}} = 0.6 \\times 0.6 = 0.36\n$$\n$$\nf_{\\mathcal{B}} r_{\\mathcal{B}} = 0.4 \\times 0.3 = 0.12\n$$\n现在，将这些代入 $M(B)$ 的表达式中：\n$$\nM(B) = 0.36 \\left( \\frac{8}{B} + 0.01 \\right) + 0.12 \\left( \\frac{4}{B} + 0.3 \\right)\n$$\n展开并合并各项：\n$$\nM(B) = \\frac{0.36 \\times 8}{B} + 0.36 \\times 0.01 + \\frac{0.12 \\times 4}{B} + 0.12 \\times 0.3\n$$\n$$\nM(B) = \\frac{2.88}{B} + 0.0036 + \\frac{0.48}{B} + 0.036\n$$\n$$\nM(B) = \\frac{2.88 + 0.48}{B} + (0.0036 + 0.036) = \\frac{3.36}{B} + 0.0396\n$$\n现在，我们可以写出 $CPI(B)$ 的完整表达式：\n$$\nCPI(B) = 1.00 + \\left( \\frac{3.36}{B} + 0.0396 \\right) \\cdot \\left( 50 + \\frac{B}{8} \\right)\n$$\n为了找到最小值，我们必须首先展开这个表达式：\n$$\nCPI(B) = 1.00 + \\left( \\frac{3.36}{B} \\cdot 50 + \\frac{3.36}{B} \\cdot \\frac{B}{8} + 0.0396 \\cdot 50 + 0.0396 \\cdot \\frac{B}{8} \\right)\n$$\n$$\nCPI(B) = 1.00 + \\left( \\frac{168}{B} + \\frac{3.36}{8} + 1.98 + \\frac{0.0396}{8} B \\right)\n$$\n计算常数项：\n$$\n\\frac{3.36}{8} = 0.42\n$$\n$$\n\\frac{0.0396}{8} = 0.00495\n$$\n因此 $CPI(B)$ 的表达式变为：\n$$\nCPI(B) = 1.00 + \\frac{168}{B} + 0.42 + 1.98 + 0.00495 B\n$$\n合并所有常数项：\n$$\nCPI(B) = (1.00 + 0.42 + 1.98) + \\frac{168}{B} + 0.00495 B\n$$\n$$\nCPI(B) = 3.40 + \\frac{168}{B} + 0.00495 B\n$$\n为了找到使 $CPI(B)$ 最小化的块大小 $B$，我们计算 $CPI(B)$ 对 $B$ 的导数，并将其设为零。\n$$\n\\frac{d}{dB} CPI(B) = \\frac{d}{dB} \\left( 3.40 + 168 B^{-1} + 0.00495 B \\right)\n$$\n$$\n\\frac{d}{dB} CPI(B) = 0 - 168 B^{-2} + 0.00495 = -\\frac{168}{B^2} + 0.00495\n$$\n将导数设为零以找到临界点：\n$$\n-\\frac{168}{B^2} + 0.00495 = 0\n$$\n$$\n\\frac{168}{B^2} = 0.00495\n$$\n$$\nB^2 = \\frac{168}{0.00495} \\approx 33939.39\n$$\n求解 $B$：\n$$\nB = \\sqrt{\\frac{168}{0.00495}}\n$$\n$$\nB \\approx 184.226474 \\text{ 字节}\n$$\n为了确认这是一个最小值，我们检查二阶导数：\n$$\n\\frac{d^2}{dB^2} CPI(B) = \\frac{d}{dB} \\left( -168 B^{-2} + 0.00495 \\right) = (-2)(-168) B^{-3} = \\frac{336}{B^3}\n$$\n由于块大小 $B$ 必须为正，二阶导数 $\\frac{336}{B^3}$ 总是正的。这证实了函数 $CPI(B)$ 是凸函数，并且该临界点对应一个全局最小值。\n\n计算出的最优值 $B \\approx 184.226$ 字节在指定的有效范围 $B \\in [16, 256]$ 内。问题要求结果四舍五入到四位有效数字。\n$$\nB = 184.2 \\text{ 字节}\n$$",
            "answer": "$$\\boxed{184.2}$$"
        }
    ]
}