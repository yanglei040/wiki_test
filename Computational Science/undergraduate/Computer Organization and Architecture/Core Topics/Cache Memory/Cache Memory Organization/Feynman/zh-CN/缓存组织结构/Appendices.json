{
    "hands_on_practices": [
        {
            "introduction": "本练习旨在揭示缓存中最基本的性能陷阱：冲突未命中（conflict miss）。通过亲手构造一个会导致直接映射缓存发生最大程度“抖动”（thrashing）的访问序列，您将具体理解地址映射如何导致缓存资源的竞争。这个练习对于建立缓存友好型编程重要性的直觉至关重要。",
            "id": "3625110",
            "problem": "一台字节寻址的机器使用单级直接映射缓存，其相联度 $A=1$，组数 $S=64$，块大小 $B=64$ 字节。缓存初始为空。考虑对齐块的只读访问。您将分析一个特意设计的、周期为2的对抗性访问模式，该模式会使此缓存产生最大程度的颠簸。\n\n任务：\n1) 构造两个不同的块对齐地址 $x$ 和 $y$，使得重复交替访问 $x,y,x,y,\\dots$ 在此直接映射缓存中产生最大程度的颠簸。请通过以下方式证明您的选择：使用将 $\\lfloor \\text{addr}/B \\rfloor$ 分解为 $\\{0,\\dots,S-1\\}$ 中的组索引和标记的标准方法，显式计算 $x$ 和 $y$ 各自的组索引和标记，并证明这两个块映射到同一组但具有不同的标记。\n\n2) 从空缓存开始，根据基本原理论证交替访问序列 $x,y,x,y,\\dots$ 的稳态未命中率必定是多少。\n\n3) 已知缓存命中时间为 $t_{h}=0.85$ 纳秒，未命中惩罚为 $t_{m}=73.6$ 纳秒（定义为发生未命中时在命中时间之外的额外延迟），计算该交替访问序列在稳态下的平均内存访问时间 (AMAT)。请以纳秒为单位表示最终的AMAT，并将答案四舍五入至四位有效数字。\n\n您最终提交的答案必须是按上述要求给出的 AMAT 的单个数值。所有中间推理过程，包括为您选择的 $x$ 和 $y$ 所做的映射合理性证明，都应在您的演算过程中展示。",
            "solution": "首先验证问题，以确保其内容自洽、有科学依据且定义明确。\n\n**第1步：提取已知条件**\n- 机器寻址方式：字节寻址\n- 缓存级别：单级\n- 缓存映射方式：直接映射 (相联度 $A=1$)\n- 缓存组数：$S=64$\n- 块大小：$B=64$ 字节\n- 初始缓存状态：空\n- 访问特性：只读，对齐块\n- 访问序列：重复交替访问 $x, y, x, y, \\dots$\n- 目标：最大化颠簸\n- 缓存命中时间：$t_h=0.85$ 纳秒\n- 缓存未命中惩罚：$t_m=73.6$ 纳秒 (定义为命中时间之外的额外延迟)\n\n**第2步：使用提取的已知条件进行验证**\n该问题具有科学依据，因为它涉及计算机体系结构的基本原理，特别是缓存组织和性能评估。给定的参数（$S=64$，$B=64$ 字节，$A=1$）对于一个简单的缓存模型是标准且现实的。所使用的术语，如“字节寻址”、“直接映射”、“块大小”、“未命中惩罚”和“AMAT”，都是精确和标准的。该问题定义明确；它要求构造一个示例来演示特定行为（颠簸），并计算由此产生的性能指标（AMAT），为此提供了所有必要的数据。“未命中惩罚”被明确定义为*额外*时间，消除了歧义。该问题客观、完整，不包含任何矛盾或不科学的前提。\n\n**结论：**该问题有效。\n\n**解题过程**\n\n按照题目要求，分析过程分三部分进行。\n\n**第1部分：构造用于最大化颠簸的地址**\n\n内存地址被划分为三个字段：标记、组索引和块内偏移。我们首先确定每个字段的位数。\n该机器是字节寻址的。\n块大小为 $B=64$ 字节。块内偏移的位数为 $\\log_2(B) = \\log_2(64) = 6$ 位。\n组数为 $S=64$。组索引的位数为 $\\log_2(S) = \\log_2(64) = 6$ 位。\n地址中余下的高位比特构成标记。\n\n地址 `addr` 通过以下组索引公式映射到缓存组：\n$$ \\text{Set Index} = \\left\\lfloor \\frac{\\text{addr}}{B} \\right\\rfloor \\pmod S $$\n标记计算如下：\n$$ \\text{Tag} = \\left\\lfloor \\frac{\\left\\lfloor \\frac{\\text{addr}}{B} \\right\\rfloor}{S} \\right\\rfloor = \\left\\lfloor \\frac{\\text{addr}}{B \\times S} \\right\\rfloor $$\n项 $\\lfloor \\text{addr}/B \\rfloor$ 是块地址。\n\n对于直接映射缓存，在交替访问模式 $x,y,x,y,\\dots$ 下，当与地址 $x$ 和 $y$ 对应的内存块映射到同一个缓存组但却是不同的块（即具有不同的标记）时，会发生最大程度的颠簸。这确保了每次访问都会驱逐下一次访问所需的块。\n\n问题说明访问的是对齐的块。如果地址 `addr` 是块大小 $B$ 的倍数，则该地址是块对齐的。这意味着 $\\text{addr} \\pmod B = 0$。\n\n我们需要找到两个不同的块对齐地址 $x$ 和 $y$，使得：\n1. $\\text{SetIndex}(x) = \\text{SetIndex}(y)$\n2. $\\text{Tag}(x) \\neq \\text{Tag}(y)$\n\n我们任意选择一个组索引，例如组 $1$。\n我们需要 $\\lfloor x/B \\rfloor \\pmod S = 1$ 且 $\\lfloor y/B \\rfloor \\pmod S = 1$。\n\n我们来构造地址 $x$。我们选择映射到组 $1$ 的最简单的块地址，即块地址 $1$。\n设 $\\lfloor x/B \\rfloor = 1$。由于 $x$ 必须是块对齐的，我们有 $x = 1 \\times B = 1 \\times 64 = 64$。\n对于 $x=64$：\n- 块地址：$\\lfloor 64/64 \\rfloor = 1$。\n- 组索引：$1 \\pmod{64} = 1$。\n- 标记：$\\lfloor 1/64 \\rfloor = 0$。\n\n现在，我们来构造地址 $y$。我们需要另一个同样映射到组 $1$ 但具有不同标记的块地址。这意味着块地址必须是 $k \\cdot S + 1$ 的形式（其中 $k$ 为某个整数），并且其标记 $\\lfloor (k \\cdot S + 1)/S \\rfloor = k$ 与 $x$ 的标记 $0$ 不同。\n我们选择最简单的非零整数 $k$，即 $k=1$。\n新的块地址是 $1 \\cdot S + 1 = 1 \\cdot 64 + 1 = 65$。\n设 $\\lfloor y/B \\rfloor = 65$。由于 $y$ 必须是块对齐的，我们有 $y = 65 \\times B = 65 \\times 64 = 4160$。\n对于 $y=4160$：\n- 块地址：$\\lfloor 4160/64 \\rfloor = 65$。\n- 组索引：$65 \\pmod{64} = 1$。\n- 标记：$\\lfloor 65/64 \\rfloor = 1$。\n\n所选地址为 $x=64$ 和 $y=4160$。两者都是块对齐的。它们都映射到组索引 $1$。它们的标记 $0$ 和 $1$ 是不同的。因此，它们满足了导致最大化颠簸的所有条件。\n\n**第2部分：稳态未命中率**\n\n我们从一个空缓存开始分析访问序列 $x,y,x,y,\\dots$。\n1. 访问 $x$：缓存为空。这是一次强制性未命中。包含地址 $x$ 的块从内存中取出并放入组 $1$。存储在组 $1$ 中的标记是 $\\text{Tag}(x)$。\n2. 访问 $y$：处理器请求地址 $y$。硬件检查组 $1$。存储在组 $1$ 中的标记是 $\\text{Tag}(x)$，与 $\\text{Tag}(y)$ 不匹配。这是一次冲突未命中。$x$ 的块被驱逐，而 $y$ 的块被取出并放入组 $1$。标记更新为 $\\text{Tag}(y)$。\n3. 访问 $x$：处理器请求地址 $x$。硬件检查组 $1$。此时存储的标记是 $\\text{Tag}(y)$，与 $\\text{Tag}(x)$ 不匹配。这是另一次冲突未命中。$y$ 的块被驱逐，并被 $x$ 的块替换。\n4. 访问 $y$：这次访问将再次是冲突未命中，驱逐 $x$ 的块。\n\n在第一次访问之后达到稳态。在这种状态下，随后的每次访问都会导致冲突未命中。当前访问所需的块永远不会是缓存中存在的那个，因为它已被紧邻的前一次访问所驱逐。\n因此，在稳态下，每次访问都是一次未命中。未命中率是未命中次数与总访问次数的比率。在稳态下，这个比率是 $1/1$。\n$$ \\text{Miss Rate} = 1 $$\n\n**第3部分：平均内存访问时间 (AMAT)**\n\n平均内存访问时间 (AMAT) 是命中时间和未命中时间的加权平均值。通用公式为：\n$$ \\text{AMAT} = (\\text{Hit Rate} \\times \\text{Time}_\\text{hit}) + (\\text{Miss Rate} \\times \\text{Time}_\\text{miss}) $$\n问题将未命中惩罚 ($t_m$) 定义为在发生未命中时，超出命中时间 ($t_h$) 所需的*额外*时间。\n所以，$\\text{Time}_\\text{hit} = t_h$。\n且 $\\text{Time}_\\text{miss} = t_h + t_m$。\n\n将这些代入 AMAT 公式：\n$$ \\text{AMAT} = ((1 - \\text{Miss Rate}) \\times t_h) + (\\text{Miss Rate} \\times (t_h + t_m)) $$\n简化此表达式：\n$$ \\text{AMAT} = t_h - (\\text{Miss Rate} \\times t_h) + (\\text{Miss Rate} \\times t_h) + (\\text{Miss Rate} \\times t_m) $$\n$$ \\text{AMAT} = t_h + (\\text{Miss Rate} \\times t_m) $$\n\n我们已知以下数值：\n- 命中时间 $t_h = 0.85$ ns。\n- 未命中惩罚 $t_m = 73.6$ ns。\n- 根据第2部分，稳态未命中率为 $1$。\n\n将这些值代入推导出的公式：\n$$ \\text{AMAT} = 0.85 + (1 \\times 73.6) $$\n$$ \\text{AMAT} = 0.85 + 73.6 $$\n$$ \\text{AMAT} = 74.45 \\text{ ns} $$\n\n问题要求答案四舍五入到四位有效数字。计算出的值 $74.45$ 恰好有四位有效数字。",
            "answer": "$$\\boxed{74.45}$$"
        },
        {
            "introduction": "在上一个练习的基础上，本练习将探讨一种常见的、用于缓解冲突未命中的硬件解决方案：受害者缓存（Victim Cache）。您将分析这个小型的全相联缓冲区如何“拯救”近期被逐出的数据块，从而将代价高昂的冲突未命中转变为速度快得多的交换操作。这个问题展示了现代处理器架构中的一个实用设计权衡。",
            "id": "3624576",
            "problem": "一个片上两级存储系统的组织方式如下：一级数据缓存的容量为 $4 \\times 2^{10}$ 字节，块大小为 $2^{6}$ 字节，关联度 $E=2$（两路组相联）。该缓存在每个组内使用最近最少使用 (LRU) 替换策略。设组数为 $S$，组索引为紧邻块偏移位之上的那些位。一个大小为 $2$ 个块的小型牺牲缓存 (Victim Cache, VC) 位于一级缓存和主存之间；它是全相联的，并使用命中时交换 (swap-on-hit) 策略：当一级缓存未命中但在 VC 命中时，VC 中的块与将要被驱逐的一级缓存块进行交换，而无需访问主存。\n\n考虑三个字地址 $a_0=0x00000000$，$a_1=0x00000800$ 和 $a_2=0x00001000$。定义一个长度为 $N=300$ 的访问序列 $\\mathcal{T}$，它从冷状态（一级缓存和牺牲缓存初始均为空）开始，精确重复循环模式 $(a_0,a_1,a_2)$ 共 $100$ 次。所有加载操作都在其块内对齐，并使用指定的块大小。\n\n仅使用组相联映射、冲突未命中和时间局部性的基本定义，完成以下任务：\n1. 确定 $S$ 的值，并证明 $a_0$、$a_1$ 和 $a_2$ 映射到一级缓存中的同一个组。\n2. 解释为何在 LRU 策略下，该访问序列对关联度为 $E=2$ 的一级缓存会产生最坏情况的自冲突。\n3. 从交换和再引用间隔的角度，解释大小为 2 的牺牲缓存是在何种时间模式下解决了自冲突问题。\n4. 给定以下每次内存操作的访问时间模型：\n   - 一级缓存命中时间 $t_1=1$ 个周期，\n   - 一级缓存未命中但在牺牲缓存中命中的情况总共耗时 $t_v=6$ 个周期，\n   - 一级缓存和牺牲缓存均未命中而访问主存的情况总共耗时 $t_m=100$ 个周期，\n计算对于访问序列 $\\mathcal{T}$，在使用大小为 2 的牺牲缓存的配置下，平均内存访问时间 (AMAT)，单位为周期/次访问。\n\n将最终的 AMAT 四舍五入到四位有效数字，并以周期/次访问表示（在最终的方框答案中不要包含任何单位符号）。",
            "solution": "该问题经验证是自包含的、有科学依据且表述清晰的。缓存分析所需的所有必要参数均已提供，并且该场景是计算机体系结构中的一个标准练习。\n\n解答按题目要求的四个部分呈现。\n\n首先，我们确定一级缓存中的组数 $S$，并验证给定地址的映射关系。\n缓存容量为 $C_1 = 4 \\times 2^{10} = 2^{12}$ 字节。\n块大小为 $B = 2^6$ 字节。\n关联度为 $E = 2$。\n组数 $S$ 由公式 $S = \\frac{C_1}{B \\times E}$ 给出。\n代入给定值：\n$$S = \\frac{2^{12} \\text{ 字节}}{2^6 \\text{ 字节/块} \\times 2 \\text{ 块/组}} = \\frac{2^{12}}{2^7} = 2^5 = 32$$\n一个地址被划分为标记、组索引和块偏移。每个部分的位数确定如下：\n块偏移位的数量 $b$ 为 $b = \\log_2(B) = \\log_2(2^6) = 6$。这些是地址的最低有效位（第 $0$ 到 $5$ 位）。\n组索引位的数量 $s$ 为 $s = \\log_2(S) = \\log_2(32) = 5$。题目说明这些位紧邻块偏移位之上，因此它们是第 $6$ 到 $10$ 位。\n剩余的高位构成了标记。\n现在我们来检查地址 $a_0$、$a_1$ 和 $a_2$。我们需要检查第 $6$ 到 $10$ 位以找出它们的组索引。\n对于 $a_0 = 0x00000000$：\n其二进制表示为 $...0000 \\, 00000 \\, 000000$。第 $6$ 到 $10$ 位（组索引）全为 $0$。因此，$a_0$ 映射到组 $0$。\n对于 $a_1 = 0x00000800$：\n$0x800 = 2048 = 2^{11}$。其二进制表示为 $...0001000 \\, 00000 \\, 000000$。第 $11$ 位为 $1$，但第 $6$ 到 $10$ 位全为 $0$。因此，$a_1$ 也映射到组 $0$。\n对于 $a_2 = 0x00001000$：\n$0x1000 = 4096 = 2^{12}$。其二进制表示为 $...0010000 \\, 00000 \\, 000000$。第 $12$ 位为 $1$，但第 $6$ 到 $10$ 位全为 $0$。因此，$a_2$ 也映射到组 $0$。\n所有三个地址 $a_0$、$a_1$ 和 $a_2$ 都映射到相同的组索引（$0$），但具有不同的标记，这使它们成为该组的一个冲突组。\n\n其次，我们解释为什么访问序列 $\\mathcal{T}$ 仅对一级缓存会产生最坏情况的自冲突。\n该组的关联度为 $E=2$，意味着它在任何时候只能容纳两个不同的块。访问序列循环访问三个地址 $(a_0, a_1, a_2)$，而这三个地址都映射到同一个组。替换策略是 LRU（最近最少使用）。\n设 $B_0, B_1, B_2$ 是分别对应于地址 $a_0, a_1, a_2$ 的缓存块。\n1. 访问 $a_0$：未命中。$B_0$ 被加载到组中。组 0 的缓存状态：$\\{B_0\\}$。\n2. 访问 $a_1$：未命中。$B_1$ 被加载。缓存状态：$\\{B_0, B_1\\}$。LRU 顺序为 $(B_1, B_0)$，其中 $B_1$ 是最近使用的。\n3. 访问 $a_2$：未命中。该组已满。根据 LRU 策略，最近最少使用的块 $B_0$ 被驱逐。$B_2$ 被加载。缓存状态：$\\{B_1, B_2\\}$。LRU 顺序：$(B_2, B_1)$。\n4. 访问 $a_0$：未命中。块 $B_0$ 在上一步刚被驱逐。此时的 LRU 块是 $B_1$，因此它被驱逐。$B_0$ 被加载。缓存状态：$\\{B_0, B_2\\}$。LRU 顺序：$(B_0, B_2)$。\n这种事件序列，即一次访问请求的块恰好被冲突组中的前一次访问所驱逐，被称为抖动 (thrashing)。在最初的强制性未命中之后，每一次后续访问都会导致冲突未命中。命中率为 $0\\%$。这是最坏的情况，因为缓存对于这种访问模式下的时间局部性没有提供任何好处。冲突地址的数量（$3$）超过了该组的关联度（$2$）。\n\n第三，我们解释大小为 2 的牺牲缓存 (VC) 如何解决这个冲突。\nVC 是一个小型全相联缓存，用于保存从 L1 缓存中最近被驱逐的块。在 L1 未命中时，会检查 VC。如果该块在 VC 中（即“VC 命中”），它将与从 L1 缓存中被驱逐的块进行交换。这比访问主存快得多。\n让我们用 L1 缓存和 VC 来追踪访问模式。两者初始都为空。\n1. 访问 $a_0$：L1 未命中，VC 未命中。从主存中获取 $B_0$。L1 组 0：$\\{B_0\\}$。VC：$\\{\\}$。\n2. 访问 $a_1$：L1 未命中，VC 未命中。从主存中获取 $B_1$。L1 组 0：$\\{B_0, B_1\\}$。VC：$\\{\\}$。\n3. 访问 $a_2$：L1 未命中，VC 未命中。L1 组 0 必须驱逐其 LRU 块 $B_0$。$B_0$ 被移至 VC。从主存获取 $B_2$ 并放入 L1。L1 组 0：$\\{B_1, B_2\\}$。VC：$\\{B_0\\}$。\n此时，由三个块 $\\{B_0, B_1, B_2\\}$ 组成的工作集被包含在 L1+VC 系统中。\n4. 访问 $a_0$：L1 未命中。但是，$B_0$ 存在于 VC 中（VC 命中）。触发了命中时交换策略。L1 组 0 中的 LRU 块是 $B_1$。来自 VC 的 $B_0$ 与来自 L1 的 $B_1$ 进行交换。L1 组 0：$\\{B_0, B_2\\}$。VC：$\\{B_1\\}$。无需访问主存。\n5. 访问 $a_1$：L1 未命中。$B_1$ 在 VC 中（VC 命中）。L1 中的 LRU 块是 $B_2$。交换 $B_1$ 和 $B_2$。L1 组 0：$\\{B_0, B_1\\}$。VC：$\\{B_2\\}$。\n6. 访问 $a_2$：L1 未命中。$B_2$ 在 VC 中（VC 命中）。L1 中的 LRU 块是 $B_0$。交换 $B_2$ 和 $B_0$。L1 组 0：$\\{B_1, B_2\\}$。VC：$\\{B_0\\}$。\n这个模式在余下的访问序列中不断重复。在最初三次强制性未命中之后，每一次后续访问都会导致 L1 未命中但 VC 命中。对于这个冲突组，有效关联度变为 L1 组关联度加上 VC 大小，即 $2+2=4$。由于冲突组的大小（$3$）小于有效关联度（$4$），所有三个块都可以保留在 L1-VC 系统内，从而消除了到主存的冲突未命中。其时间模式是，任何块的再引用间隔为 3 次访问。仅靠 L1 缓存（关联度为 2）无法处理这种情况，但 L1+VC 系统（有效关联度为 4）可以。\n\n第四，我们计算平均内存访问时间 (AMAT)。\n访问序列 $\\mathcal{T}$ 中的总访问次数为 $N = 300$。\n访问成本如下：\nL1 命中时间：$t_1 = 1$ 个周期。\nL1 未命中、VC 命中时间：$t_v = 6$ 个周期。\nL1 未命中、VC 未命中（主存）时间：$t_m = 100$ 个周期。\n\n基于第三部分的访问序列分析：\n- 前三次访问（$a_0, a_1, a_2$）是 L1 未命中和 VC 未命中（强制性未命中），因为两个缓存都是从冷状态开始的。\n- 主存访问次数为 $N_{mem} = 3$。每次的成本是 $t_m$。\n- 随后的 $N - 3 = 300 - 3 = 297$ 次访问都是 L1 未命中，然后是 VC 命中。\n- VC 命中次数为 $N_{vc\\_hit} = 297$。每次的成本是 $t_v$。\n- 在此访问序列中没有 L1 命中。L1 命中次数为 $N_{hit} = 0$。\n\n所有访问的总时间是每种访问类型成本的总和：\n$$ \\text{总时间} = (N_{hit} \\times t_1) + (N_{vc\\_hit} \\times t_v) + (N_{mem} \\times t_m) $$\n$$ \\text{总时间} = (0 \\times 1) + (297 \\times 6) + (3 \\times 100) $$\n$$ \\text{总时间} = 0 + 1782 + 300 = 2082 \\text{ 周期} $$\n平均内存访问时间 (AMAT) 是总时间除以总访问次数：\n$$ \\text{AMAT} = \\frac{\\text{总时间}}{N} = \\frac{2082}{300} $$\n$$ \\text{AMAT} = 6.94 \\text{ 周期/次访问} $$\n题目要求将答案四舍五入到四位有效数字。\n$$ \\text{AMAT} = 6.940 \\text{ 周期/次访问} $$",
            "answer": "$$\\boxed{6.940}$$"
        },
        {
            "introduction": "增加相联度是减少冲突未命中的主要方法，但替换策略本身也存在微妙之处。本练习挑战您追踪一种广泛使用的近似算法——二叉树伪LRU（PLRU）——的行为，并观察其逐出决策在特定情况下如何偏离真正的最近最少使用（LRU）策略。这将揭示真实世界的硬件实现通常需要在性能和实现复杂度之间做出权衡。",
            "id": "3624666",
            "problem": "考虑一个采用二叉树伪最近最少使用 (PLRU) 替换算法的 $E=8$ 路组相联高速缓存中的单个缓存组。这八个路 (way) 由深度为 $3$ 的完全二叉树的叶子 $\\{0,1,2,3,4,5,6,7\\}$ 索引。每个内部节点存储一个替换位，该位指示其两个子树中的哪一个被认为是最近较少使用的。设内部节点标记为 $b_{0},b_{1},b_{2},b_{3},b_{4},b_{5},b_{6}$ 如下：$b_{0}$ 是根节点；$b_{1}$ 是 $b_{0}$ 的左子节点，覆盖叶子 $\\{0,1,2,3\\}$；$b_{2}$ 是 $b_{0}$ 的右子节点，覆盖叶子 $\\{4,5,6,7\\}$；$b_{3}$ 覆盖 $\\{0,1\\}$；$b_{4}$ 覆盖 $\\{2,3\\}$；$b_{5}$ 覆盖 $\\{4,5\\}$；$b_{6}$ 覆盖 $\\{6,7\\}$。位值为 $0$ 表示左子树（或左叶子）被标记为最近较少使用；位值为 $1$ 表示右子树（或右叶子）被标记为最近较少使用。每次缓存命中叶子 $i$ 时，从根到叶子 $i$ 的路径上的每个位都会被更新，以指向刚访问路径的兄弟子树（或兄弟叶子），从而将访问的叶子标记为相对于其兄弟而言是最近最多使用的。在替换时，通过从 $b_{0}$ 开始并根据每个位指示的子节点向下遍历（总是选择当前标记为最近较少使用的子树）直到到达一个叶子来选择牺牲叶子；然后，所选路径上的替换位被翻转以指向相反的子节点。\n\n假设该组最初由一系列强制性未命中填充，这些未命中按顺序将不同的块装入路 $\\{0,1,2,3,4,5,6,7\\}$ 中，每次装入对于 PLRU 状态更新的行为都像一次缓存命中。在这次初始填充之后，执行该组内的以下缓存命中访问轨迹：按顺序访问路 $0$，然后是 $1$，然后是 $2$，然后是 $3$，然后是 $4$，然后是 $5$。紧随此轨迹之后，一个新的块 $X$ 映射到同一个组并导致一次未命中，需要驱逐一个牺牲者。\n\n仅使用上面给出的真正最近最少使用 (LRU) 的核心定义和二叉树 PLRU 更新及牺牲者选择规则，确定二叉树 PLRU 将为块 $X$ 驱逐的 Way 的索引（从 $0$ 到 $7$）。在你的推理中，解释内部位状态在访问轨迹期间如何演变，以及为什么在这种情况下 PLRU 的选择与真正的 LRU 不同。将你的最终答案表示为一个不带单位的单个整数索引。",
            "solution": "该问题要求我们确定在一个 $E=8$ 路组相联高速缓存中，由二叉树伪最近最少使用 (PLRU) 替换算法选择的牺牲路。我们必须首先确定在初始填充序列和随后的访问轨迹之后 PLRU 位的状态，然后应用牺牲者选择规则。我们还被要求将此结果与真正的最近最少使用 (LRU) 策略的结果进行比较。\n\n首先，让我们形式化二叉树的结构和 PLRU 状态。该缓存组有 $E=8$ 个路，索引为 $\\{0, 1, 2, 3, 4, 5, 6, 7\\}$。PLRU 逻辑使用一个深度为 $3$ 的完全二叉树，有 $7$ 个内部节点，每个节点存储一个位。PLRU 的状态由这些位的向量表示：$S = (b_0, b_1, b_2, b_3, b_4, b_5, b_6)$。\n树结构如下：\n- $b_0$ 是根节点。\n- 其左子节点是 $b_1$（覆盖叶子 $\\{0,1,2,3\\}$），右子节点是 $b_2$（覆盖叶子 $\\{4,5,6,7\\}$）。\n- $b_1$ 的子节点是 $b_3$（覆盖 $\\{0,1\\}$）和 $b_4$（覆盖 $\\{2,3\\}$）。\n- $b_2$ 的子节点是 $b_5$（覆盖 $\\{4,5\\}$）和 $b_6$（覆盖 $\\{6,7\\}$）。\n- $b_3, b_4, b_5, b_6$ 的叶子节点分别是路 $\\{0,1\\}, \\{2,3\\}, \\{4,5\\}, \\{6,7\\}$。\n\n位值为 $0$ 表示左子节点/子树是最近较少使用的，位值为 $1$ 表示右子节点/子树是最近较少使用的。\n\n从根到每个叶子的路径由一系列左 (L) 或右 (R) 分支组成：\n- 路 0: L, L, L (通过 $b_0, b_1, b_3$ 的路径)\n- 路 1: L, L, R (通过 $b_0, b_1, b_3$ 的路径)\n- 路 2: L, R, L (通过 $b_0, b_1, b_4$ 的路径)\n- 路 3: L, R, R (通过 $b_0, b_1, b_4$ 的路径)\n- 路 4: R, L, L (通过 $b_0, b_2, b_5$ 的路径)\n- 路 5: R, L, R (通过 $b_0, b_2, b_5$ 的路径)\n- 路 6: R, R, L (通过 $b_0, b_2, b_6$ 的路径)\n- 路 7: R, R, R (通过 $b_0, b_2, b_6$ 的路径)\n\n当缓存命中一个路时，从根到该路路径上的所有位都会被更新，以指向所采取路径的兄弟节点。例如，如果访问一个路的路径经过一个节点的左子节点，该节点的位将被设置为 $1$（指向右子节点，表示其现在是最近较少使用的）。\n\n我们首先确定初始填充序列 $\\{0,1,2,3,4,5,6,7\\}$ 之后的位状态。我们假设初始状态下所有位都为 $0$，因此 $S_{initial} = (0,0,0,0,0,0,0)$。我们追踪每次访问的效果，其行为类似于一次缓存命中。\n\n1.  **初始填充序列 $\\{0,1,2,3,4,5,6,7\\}$**：\n    - 设状态为 $S = (b_0, b_1, b_2, b_3, b_4, b_5, b_6)$。从 $S = (0,0,0,0,0,0,0)$ 开始。\n    - 访问 0 (L,L,L)：位 $b_0, b_1, b_3$ 在路径上。它们被更新以指向其右兄弟。$b_0 \\to 1, b_1 \\to 1, b_3 \\to 1$。$S = (1,1,0,1,0,0,0)$。\n    - 访问 1 (L,L,R)：位 $b_0, b_1, b_3$ 在路径上。$b_0 \\to 1, b_1 \\to 1$。$b_3$ 被更新以指向左边。$b_3 \\to 0$。$S = (1,1,0,0,0,0,0)$。\n    - 访问 2 (L,R,L)：位 $b_0, b_1, b_4$ 在路径上。$b_0 \\to 1$。$b_1$ 指向左边。$b_1 \\to 0$。$b_4$ 指向右边。$b_4 \\to 1$。$S = (1,0,0,0,1,0,0)$。\n    - 访问 3 (L,R,R)：位 $b_0, b_1, b_4$ 在路径上。$b_0 \\to 1, b_1 \\to 0, b_4 \\to 0$。$S = (1,0,0,0,0,0,0)$。\n    - 访问 4 (R,L,L)：位 $b_0, b_2, b_5$ 在路径上。$b_0 \\to 0, b_2 \\to 1, b_5 \\to 1$。$S = (0,0,1,0,0,1,0)$。\n    - 访问 5 (R,L,R)：位 $b_0, b_2, b_5$ 在路径上。$b_0 \\to 0, b_2 \\to 1, b_5 \\to 0$。$S = (0,0,1,0,0,0,0)$。\n    - 访问 6 (R,R,L)：位 $b_0, b_2, b_6$ 在路径上。$b_0 \\to 0, b_2 \\to 0, b_6 \\to 1$。$S = (0,0,0,0,0,0,1)$。\n    - 访问 7 (R,R,R)：位 $b_0, b_2, b_6$ 在路径上。$b_0 \\to 0, b_2 \\to 0, b_6 \\to 0$。$S = (0,0,0,0,0,0,0)$。\n    初始填充序列之后的状态，我们记为 $S_{fill}$，是 $(0,0,0,0,0,0,0)$。\n\n2.  **命中访问轨迹 $\\{0,1,2,3,4,5\\}$**：\n    - 从 $S_{fill} = (0,0,0,0,0,0,0)$ 开始。\n    - 访问 0 (L,L,L)：$b_0 \\to 1, b_1 \\to 1, b_3 \\to 1$。$S = (1,1,0,1,0,0,0)$。\n    - 访问 1 (L,L,R)：$b_0 \\to 1, b_1 \\to 1, b_3 \\to 0$。$S = (1,1,0,0,0,0,0)$。\n    - 访问 2 (L,R,L)：$b_0 \\to 1, b_1 \\to 0, b_4 \\to 1$。$S = (1,0,0,0,1,0,0)$。\n    - 访问 3 (L,R,R)：$b_0 \\to 1, b_1 \\to 0, b_4 \\to 0$。$S = (1,0,0,0,0,0,0)$。\n    - 访问 4 (R,L,L)：$b_0 \\to 0, b_2 \\to 1, b_5 \\to 1$。$S = (0,0,1,0,0,1,0)$。\n    - 访问 5 (R,L,R)：$b_0 \\to 0, b_2 \\to 1, b_5 \\to 0$。$S = (0,0,1,0,0,0,0)$。\n\n    在未命中发生之前，PLRU 位的最终状态是 $S_{final} = (0,0,1,0,0,0,0)$。\n\n3.  **为块 X 选择牺牲者**：\n    发生未命中时，通过从根开始遍历树，遵循每个位指示的方向（$0$ 表示向左，$1$ 表示向右）来找到牺牲者。\n    - 从根节点 $b_0$ 开始，其值为 $0$。选择左子树（由 $b_1$ 管理）。\n    - 在节点 $b_1$ 处，其值为 $0$。选择左子树（由 $b_3$ 管理）。\n    - 在节点 $b_3$ 处，其值为 $0$。选择左叶子。\n    - $b_3$ 的左叶子是路 $0$。\n    因此，PLRU 算法将驱逐路 $0$ 中的块。\n\n4.  **与真正 LRU 的比较及差异解释**：\n    为了找到真正的 LRU 牺牲者，我们跟踪所有路的新近度。对一个路的访问使其成为最近最多使用 (MRU) 的。最近最少使用 (LRU) 的是最长时间未被访问的路。\n    - 在初始填充序列 $\\{0,1,2,3,4,5,6,7\\}$ 之后，从 MRU 到 LRU 的新近度顺序是 $\\{7,6,5,4,3,2,1,0\\}$。真正的 LRU 路是 $0$。\n    - 现在我们应用命中轨迹 $\\{0,1,2,3,4,5\\}$。我们可以将状态表示为一个有序列表（栈），MRU 在头部。\n    - 初始栈: $[7,6,5,4,3,2,1,0]$\n    - 访问 0: $[0,7,6,5,4,3,2,1]$\n    - 访问 1: $[1,0,7,6,5,4,3,2]$\n    - 访问 2: $[2,1,0,7,6,5,4,3]$\n    - 访问 3: $[3,2,1,0,7,6,5,4]$\n    - 访问 4: $[4,3,2,1,0,7,6,5]$\n    - 访问 5: $[5,4,3,2,1,0,7,6]$\n    在轨迹之后，最近最少使用的路在列表的末尾，即路 $6$。因此，真正的 LRU 策略会驱逐路 $6$。\n\n    PLRU 的牺牲者是路 $0$，而真正的 LRU 牺牲者是路 $6$。这两种策略产生了分歧。这种分歧的原因在于二叉树 PLRU 算法的本质。它不维护所有路之间新近度的完全排序。相反，一次访问只更新少数几个位，这些位编码了子树内的部分排序。\n    - 访问序列 $\\{0,1,2,3,4,5\\}$ 使得路 $6$ 和 $7$ 在全局意义上成为两个最近最少使用的路。\n    - 然而，最后的访问，$4$ 和 $5$，是针对根的右子树（包含路 $\\{4,5,6,7\\}$）。这使得根位 $b_0$ 被设置为 $0$，表示整个左子树（路 $\\{0,1,2,3\\}$）现在被认为是“最近较少使用的那一半”。\n    - 因此，牺牲者选择过程立即被限制在左子树内进行搜索。它永远不会考虑从右子树中驱逐任何路，包括真正的 LRU 路 $6$，因为整个右子树已被标记为最近较多使用的。\n    - 然后，PLRU 算法继续在“LRU 一半”$\\{0,1,2,3\\}$ 中寻找“最 LRU”的元素。基于先前的访问模式 $\\{0,1,2,3\\}$，它正确地将路 $0$ 识别为该子组内的 LRU 块。这种现象，即单次访问可以“保护”一个位于同一子树中的真正旧块不被驱逐，是这种 PLRU 实现的一个众所周知的局限性。\n\nPLRU 将驱逐的 Way 的索引是 $0$。",
            "answer": "$$\\boxed{0}$$"
        }
    ]
}