{
    "hands_on_practices": [
        {
            "introduction": "在最简单的缓存组织结构——直接映射缓存中，“冲突未命中”是一个核心概念。特定的访问模式可能导致一种最坏情况，即“缓存颠簸”（thrashing），此时缓存会不断地驱逐和重新加载数据，使得其性能优势荡然无存。本练习将引导你构建这样一个病态的访问模式，并使用“平均内存访问时间”（AMAT）来量化其对性能的灾难性影响，从而让你对缓存友好型编程的重要性建立基础认知。",
            "id": "3625110",
            "problem": "一台字节寻址的机器使用单级直接映射缓存，其相联度 $A=1$，组数 $S=64$，块大小 $B=64$ 字节。缓存初始为空。考虑对对齐块的只读访问。您将分析一种特意设计的、具有2周期性的对抗性访问模式，该模式会对此缓存造成最大程度的颠簸。\n\n任务：\n1) 构造两个不同的块对齐地址 $x$ 和 $y$，使得重复交替访问 $x,y,x,y,\\dots$ 在此直接映射缓存中产生最大程度的颠簸。通过使用将 $\\lfloor \\text{addr}/B \\rfloor$ 分解为 $\\{0,\\dots,S-1\\}$ 中的组索引和标记的标准方法，明确计算出 $x$ 和 $y$ 各自的组索引和标记，并证明这两个块映射到同一组但具有不同的标记，来论证您的选择。\n\n2) 从空缓存开始，根据第一性原理论证交替访问序列 $x,y,x,y,\\dots$ 的稳态缺失率必须是多少。\n\n3) 给定缓存命中时间 $t_{h}=0.85$ 纳秒和缺失代价 $t_{m}=73.6$ 纳秒（定义为发生缺失时超出命中时间的额外延迟），计算稳态下交替访问序列的平均内存访问时间（AMAT）。以纳秒为单位表示您的最终AMAT，并将答案四舍五入到四位有效数字。\n\n您最终提交的答案必须是上述指定的AMAT的单个数值。所有中间推理，包括您选择的 $x$ 和 $y$ 的映射论证，都应在您的解题步骤中展示。",
            "solution": "首先验证问题以确保其自洽、有科学依据且是良构的。\n\n**步骤1：提取已知条件**\n- 机器寻址：字节寻址\n- 缓存级别：单级\n- 缓存映射：直接映射（相联度 $A=1$）\n- 缓存组数：$S=64$\n- 块大小：$B=64$ 字节\n- 初始缓存状态：空\n- 访问特性：只读，对齐块\n- 访问序列：重复交替访问 $x, y, x, y, \\dots$\n- 目标：最大颠簸\n- 缓存命中时间：$t_h=0.85$ 纳秒\n- 缓存缺失代价：$t_m=73.6$ 纳秒（定义为超出命中时间的额外延迟）\n\n**步骤2：使用提取的已知条件进行验证**\n该问题具有科学依据，因为它涉及计算机体系结构的基本原理，特别是缓存存储器的组织和性能评估。给定的参数（$S=64$， $B=64$ 字节，$A=1$）对于一个简单的缓存模型来说是标准且符合实际的。所使用的术语，如“字节寻址”、“直接映射”、“块大小”、“缺失代价”和“AMAT”，都是精确和标准的。这个问题是良构的；它要求构造一个展示特定行为（颠簸）的例子，并计算由此产生的性能指标（AMAT），为此提供了所有必要的数据。将“缺失代价”定义为*额外*时间的做法得到了明确说明，从而消除了歧义。该问题是客观、完整的，不包含任何矛盾或不科学的前提。\n\n**结论：** 该问题有效。\n\n**解法**\n\n按照题目要求，分析分三部分进行。\n\n**第一部分：构造用于最大颠簸的地址**\n\n一个内存地址被划分为三个字段：标记、组索引和块内偏移。我们首先确定每个字段的位数。\n该机器是字节寻址的。\n块大小为 $B=64$ 字节。块内偏移的位数为 $\\log_2(B) = \\log_2(64) = 6$ 位。\n组数为 $S=64$。组索引的位数为 $\\log_2(S) = \\log_2(64) = 6$ 位。\n地址中余下的高位构成了标记。\n\n地址 `addr` 通过组索引的公式映射到缓存组：\n$$ \\text{Set Index} = \\left\\lfloor \\frac{\\text{addr}}{B} \\right\\rfloor \\pmod S $$\n标记的计算公式为：\n$$ \\text{Tag} = \\left\\lfloor \\frac{\\left\\lfloor \\frac{\\text{addr}}{B} \\right\\rfloor}{S} \\right\\rfloor = \\left\\lfloor \\frac{\\text{addr}}{B \\times S} \\right\\rfloor $$\n项 $\\lfloor \\text{addr}/B \\rfloor$ 是块地址。\n\n对于直接映射缓存，在交替访问模式 $x,y,x,y,\\dots$ 下，当对应于地址 $x$ 和 $y$ 的内存块映射到同一个缓存组但却是不同的块（即具有不同的标记）时，会发生最大程度的颠簸。这确保了每次访问都会替换掉下一次访问所需要的块。\n\n问题陈述了访问是对齐的块。如果一个地址 `addr` 是块大小 $B$ 的倍数，那么它就是块对齐的。这意味着 $\\text{addr} \\pmod B = 0$。\n\n我们需要找到两个不同的块对齐地址 $x$ 和 $y$，使得：\n1. $\\text{SetIndex}(x) = \\text{SetIndex}(y)$\n2. $\\text{Tag}(x) \\neq \\text{Tag}(y)$\n\n我们任意选择一个组索引，例如，组 1。\n我们需要 $\\lfloor x/B \\rfloor \\pmod S = 1$ 和 $\\lfloor y/B \\rfloor \\pmod S = 1$。\n\n我们来构造地址 $x$。我们选择映射到组 1 的最简单的块地址，即块地址 1。\n令 $\\lfloor x/B \\rfloor = 1$。由于 $x$ 必须是块对齐的，我们得到 $x = 1 \\times B = 1 \\times 64 = 64$。\n对于 $x=64$：\n- 块地址：$\\lfloor 64/64 \\rfloor = 1$。\n- 组索引：$1 \\pmod{64} = 1$。\n- 标记：$\\lfloor 1/64 \\rfloor = 0$。\n\n现在，我们来构造地址 $y$。我们需要另一个同样映射到组 1 但具有不同标记的块地址。这意味着块地址必须是 $k \\cdot S + 1$ 的形式（对于某个整数 $k$），其中标记 $\\lfloor (k \\cdot S + 1)/S \\rfloor = k$ 与 $x$ 的标记 0 不同。\n我们选择最简单的非零整数 $k$，即 $k=1$。\n新的块地址是 $1 \\cdot S + 1 = 1 \\cdot 64 + 1 = 65$。\n令 $\\lfloor y/B \\rfloor = 65$。由于 $y$ 必须是块对齐的，我们得到 $y = 65 \\times B = 65 \\times 64 = 4160$。\n对于 $y=4160$：\n- 块地址：$\\lfloor 4160/64 \\rfloor = 65$。\n- 组索引：$65 \\pmod{64} = 1$。\n- 标记：$\\lfloor 65/64 \\rfloor = 1$。\n\n选择的地址是 $x=64$ 和 $y=4160$。两者都是块对齐的。它们都映射到组索引 1。它们的标记（分别为 0 和 1）是不同的。因此，它们满足了引起最大颠簸的所有条件。\n\n**第二部分：稳态缺失率**\n\n我们从一个空缓存开始分析访问序列 $x,y,x,y,\\dots$。\n1. 访问 $x$：缓存为空。这是一次强制性缺失。包含地址 $x$ 的块从内存中取回并放入组 1。存储在组 1 中的标记是 $\\text{Tag}(x)$。\n2. 访问 $y$：处理器请求地址 $y$。硬件检查组 1。存储在组 1 中的标记是 $\\text{Tag}(x)$，与 $\\text{Tag}(y)$ 不匹配。这是一次冲突缺失。$x$ 的块被替换，而 $y$ 的块被取回并放入组 1。标记更新为 $\\text{Tag}(y)$。\n3. 访问 $x$：处理器请求地址 $x$。硬件检查组 1。现在存储的标记是 $\\text{Tag}(y)$，与 $\\text{Tag}(x)$ 不匹配。这是另一次冲突缺失。$y$ 的块被替换，并由 $x$ 的块取代。\n4. 访问 $y$：这次访问将再次成为一次冲突缺失，替换掉 $x$ 的块。\n\n在第一次访问之后就达到了稳态。在此状态下，随后的每一次访问都会导致一次冲突缺失。当前访问所需的块永远不是缓存中存在的那个，因为它被紧邻的前一次访问所替换掉了。\n因此，在稳态下，每次访问都是一次缺失。\n缺失率是缺失次数与总访问次数的比率。在稳态下，这个比率是 $1/1$。\n$$ \\text{Miss Rate} = 1 $$\n\n**第三部分：平均内存访问时间（AMAT）**\n\n平均内存访问时间（AMAT）是命中时间和缺失时间的加权平均值。通用公式是：\n$$ \\text{AMAT} = (\\text{Hit Rate} \\times \\text{Time}_\\text{hit}) + (\\text{Miss Rate} \\times \\text{Time}_\\text{miss}) $$\n问题将缺失代价（$t_m$）定义为发生缺失时在命中时间（$t_h$）之外所需的*额外*时间。\n所以，$\\text{Time}_\\text{hit} = t_h$。\n而 $\\text{Time}_\\text{miss} = t_h + t_m$。\n\n将这些代入 AMAT 公式：\n$$ \\text{AMAT} = ((1 - \\text{Miss Rate}) \\times t_h) + (\\text{Miss Rate} \\times (t_h + t_m)) $$\n简化这个表达式：\n$$ \\text{AMAT} = t_h - (\\text{Miss Rate} \\times t_h) + (\\text{Miss Rate} \\times t_h) + (\\text{Miss Rate} \\times t_m) $$\n$$ \\text{AMAT} = t_h + (\\text{Miss Rate} \\times t_m) $$\n\n我们已知以下数值：\n- 命中时间 $t_h = 0.85$ 纳秒。\n- 缺失代价 $t_m = 73.6$ 纳秒。\n- 根据第二部分，稳态缺失率为 $1$。\n\n将这些值代入推导出的公式：\n$$ \\text{AMAT} = 0.85 + (1 \\times 73.6) $$\n$$ \\text{AMAT} = 0.85 + 73.6 $$\n$$ \\text{AMAT} = 74.45 \\text{ ns} $$\n\n问题要求答案四舍五入到四位有效数字。计算出的值 $74.45$ 已经恰好是四位有效数字。",
            "answer": "$$\\boxed{74.45}$$"
        },
        {
            "introduction": "在“冲突未命中”概念的基础上，本练习将探讨如何通过组相联和“受害者缓存”（victim cache）等架构设计来解决缓存颠簸问题。你将分析一个在组相联缓存中仍会导致冲突的内存访问模式，然后观察一个受害者缓存如何通过为被驱逐的块提供一个小型二级缓冲区来“治愈”这个问题。这个练习突出了缓存设计中的权衡，并展示了硬件创新如何通过利用时间局部性来提高性能。",
            "id": "3624576",
            "problem": "一个两级片上内存系统由一个一级数据缓存和一个主存组成。该一级数据缓存的容量为 $4 \\times 2^{10}$ 字节，块大小为 $2^{6}$ 字节，相联度为 $E=2$（二路组相联）。缓存在每个组内使用最近最少使用 (LRU) 替换策略。设组的数量为 $S$，组索引是紧邻块偏移位之上的位。一个大小为 $2$ 个块的小型受害者缓存 (Victim Cache, VC) 位于一级缓存和主存之间；它是全相联的，并使用命中时交换策略：对于在一级缓存未命中但在VC中命中的情况，VC块与将要被替换出的一级缓存块进行交换，而无需访问主存。\n\n考虑三个字地址：\n$a_0=0x00000000$，$a_1=0x00000800$，和 $a_2=0x00001000$。定义一个长度为 $N=300$ 的访问轨迹 $\\mathcal{T}$，它从冷状态（一级缓存和受害者缓存初始都为空）开始，精确地重复循环模式 $(a_0,a_1,a_2)$ 100次。所有加载操作都在其块内对齐，并使用指定的块大小。\n\n仅使用组相联映射、冲突未命中和时间局部性的基本定义，完成以下任务：\n1. 确定 $S$ 的值，并证明 $a_0$、$a_1$ 和 $a_2$ 映射到一级缓存中的同一个组。\n2. 解释为什么在 LRU 策略下，此轨迹对于一级缓存（$E=2$）会产生最差情况的自身冲突。\n3. 从交换和重引用间隔的角度，解释大小为 $2$ 的受害者缓存是在何种时间模式下解决了这种自身冲突。\n4. 给定以下每次内存操作的访问时间模型：\n   - 一级缓存命中时间 $t_1=1$ 个周期，\n   - 一级缓存未命中但在受害者缓存中命中的总成本为 $t_v=6$ 个周期，\n   - 一级缓存和受害者缓存均未命中而访问主存的总成本为 $t_m=100$ 个周期，\n计算在使用大小为 $2$ 的受害者缓存的配置下，对于轨迹 $\\mathcal{T}$ 的平均内存访问时间 (AMAT)，单位为周期/访问。\n\n将最终的 AMAT 四舍五入到四位有效数字，并以周期/访问表示（在最终的方框答案中不要包含任何单位符号）。",
            "solution": "该问题经验证是自洽的、有科学依据且提法得当的。所有用于缓存分析的必要参数都已提供，并且该场景是计算机体系结构中的一个标准练习。\n\n解决方案按问题陈述的要求分为四个部分。\n\n首先，我们确定一级缓存中的组数 $S$，并验证给定地址的映射。\n缓存容量为 $C_1 = 4 \\times 2^{10} = 2^{12}$ 字节。\n块大小为 $B = 2^6$ 字节。\n相联度为 $E = 2$。\n组数 $S$ 由公式 $S = \\frac{C_1}{B \\times E}$ 给出。\n代入给定值：\n$$S = \\frac{2^{12} \\text{ 字节}}{2^6 \\text{ 字节/块} \\times 2 \\text{ 块/组}} = \\frac{2^{12}}{2^7} = 2^5 = 32$$\n地址被划分为标记、组索引和块偏移。每个部分的位数确定如下：\n块偏移的位数 $b$ 为 $b = \\log_2(B) = \\log_2(2^6) = 6$。这些是地址的最低有效位（第 $0$ 到 $5$ 位）。\n组索引的位数 $s$ 为 $s = \\log_2(S) = \\log_2(32) = 5$。问题陈述中指出这些位紧邻块偏移位之上，所以它们是第 $6$ 到 $10$ 位。\n余下的高位构成标记。\n现在我们检查地址 $a_0$、$a_1$ 和 $a_2$。我们需要检查第 $6$ 到 $10$ 位来找到它们的组索引。\n对于 $a_0 = 0x00000000$：\n其二进制表示为 $...0000 \\, 00000 \\, 000000$。从第 $6$ 位到第 $10$ 位（组索引）均为 $0$。因此，$a_0$ 映射到组 $0$。\n对于 $a_1 = 0x00000800$：\n$0x800 = 2048 = 2^{11}$。其二进制表示为 $...0001000 \\, 00000 \\, 000000$。第 $11$ 位是 $1$，但第 $6$ 位到第 $10$ 位均为 $0$。因此，$a_1$ 也映射到组 $0$。\n对于 $a_2 = 0x00001000$：\n$0x1000 = 4096 = 2^{12}$。其二进制表示为 $...0010000 \\, 00000 \\, 000000$。第 $12$ 位是 $1$，但第 $6$ 位到第 $10$ 位均为 $0$。因此，$a_2$ 也映射到组 $0$。\n所有三个地址 $a_0$、$a_1$ 和 $a_2$ 都映射到同一个组索引（$0$），但具有不同的标记，使它们成为该组的一个冲突组。\n\n其次，我们解释为什么对于单独的一级缓存，轨迹 $\\mathcal{T}$ 会产生最差情况的自身冲突。\n该组的相联度为 $E=2$，意味着它在任何时候只能容纳两个不同的块。该轨迹循环访问三个地址 $(a_0, a_1, a_2)$，它们都映射到同一个组。替换策略是 LRU（最近最少使用）。\n设 $B_0, B_1, B_2$ 是对应于地址 $a_0, a_1, a_2$ 的缓存块。\n1. 访问 $a_0$：未命中。$B_0$ 被加载到组中。组 $0$ 的缓存状态：$\\{B_0\\}$。\n2. 访问 $a_1$：未命中。$B_1$ 被加载。缓存状态：$\\{B_0, B_1\\}$。LRU 顺序为 $(B_1, B_0)$，$B_1$ 是最近使用的。\n3. 访问 $a_2$：未命中。组已满。根据 LRU 策略，最近最少使用的块 $B_0$ 被替换出去。$B_2$ 被加载。缓存状态：$\\{B_1, B_2\\}$。LRU 顺序为 $(B_2, B_1)$。\n4. 访问 $a_0$：未命中。块 $B_0$ 在上一步刚刚被替换出去。现在的 LRU 块是 $B_1$，所以它被替换出去。$B_0$ 被加载。缓存状态：$\\{B_0, B_2\\}$。LRU 顺序为 $(B_0, B_2)$。\n这种事件序列，即一次访问请求的块恰好被冲突组中的前一次访问替换出去，被称为抖动（thrashing）。在最初的强制性未命中之后，每次后续访问都会导致冲突未命中。命中率为 $0\\%$。这是最坏的情况，因为缓存在这种访问模式下没有为时间局部性提供任何好处。冲突地址的数量（$3$）超过了组的相联度（$2$）。\n\n第三，我们解释大小为2的受害者缓存（VC）如何解决这种冲突。\nVC是一个小型的全相联缓存，用于存放最近从L1缓存中替换出来的块。当L1未命中时，会检查VC。如果块在VC中（即“VC命中”），它将与从L1缓存中被替换出的块进行交换。这比访问主存快得多。\n让我们用L1缓存和VC来追踪访问模式。两者初始都为空。\n1. 访问 $a_0$：L1未命中，VC未命中。从主存中获取 $B_0$。L1组 $0$：$\\{B_0\\}$。VC：$\\{\\}$。\n2. 访问 $a_1$：L1未命中，VC未命中。从主存中获取 $B_1$。L1组 $0$：$\\{B_0, B_1\\}$。VC：$\\{\\}$。\n3. 访问 $a_2$：L1未命中，VC未命中。L1组 $0$ 必须替换其LRU块 $B_0$。$B_0$ 被移到VC中。$B_2$ 从主存中获取并放入L1。L1组 $0$：$\\{B_1, B_2\\}$。VC：$\\{B_0\\}$。\n此时，三个块的工作集 $\\{B_0, B_1, B_2\\}$ 被包含在L1+VC系统中。\n4. 访问 $a_0$：L1未命中。然而，$B_0$ 存在于VC中（VC命中）。命中时交换策略被触发。L1组 $0$ 中的LRU块是 $B_1$。来自VC的 $B_0$ 与来自L1的 $B_1$ 进行交换。L1组 $0$：$\\{B_0, B_2\\}$。VC：$\\{B_1\\}$。无需访问主存。\n5. 访问 $a_1$：L1未命中。$B_1$ 在VC中（VC命中）。L1中的LRU块是 $B_2$。交换 $B_1$ 和 $B_2$。L1组 $0$：$\\{B_0, B_1\\}$。VC：$\\{B_2\\}$。\n6. 访问 $a_2$：L1未命中。$B_2$ 在VC中（VC命中）。L1中的LRU块是 $B_0$。交换 $B_2$ 和 $B_0$。L1组 $0$：$\\{B_1, B_2\\}$。VC：$\\{B_0\\}$。\n此模式在轨迹的其余部分重复。在最初三次强制性未命中之后，每次后续访问都会导致L1未命中，但VC命中。这个冲突组的有效相联度变成L1组相联度加上VC的大小，即 $2+2=4$。由于冲突组的大小（$3$）小于有效相联度（$4$），所有三个块都可以保留在L1-VC系统中，从而消除了到主存的冲突未命中。时间模式是任何块的重引用间隔为3次访问。单独的L1缓存（相联度为2）无法处理这种情况，但L1+VC系统（有效相联度为4）可以。\n\n第四，我们计算平均内存访问时间（AMAT）。\n轨迹 $\\mathcal{T}$ 中的总访问次数为 $N = 300$。\n访问成本如下所示：\nL1命中时间：$t_1 = 1$ 个周期。\nL1未命中、VC命中时间：$t_v = 6$ 个周期。\nL1未命中、VC未命中（主存）时间：$t_m = 100$ 个周期。\n\n根据第三部分的轨迹分析：\n- 前三次访问（$a_0, a_1, a_2$）是L1未命中和VC未命中（强制性未命中），因为两个缓存都是从冷状态开始的。\n- 主存访问次数为 $N_{mem} = 3$。每次成本为 $t_m$。\n- 后续的 $N - 3 = 300 - 3 = 297$ 次访问都是L1未命中后跟VC命中。\n- VC命中次数为 $N_{vc\\_hit} = 297$。每次成本为 $t_v$。\n- 在此轨迹中没有L1命中。L1命中次数为 $N_{hit} = 0$。\n\n所有访问的总时间是每种访问类型成本的总和：\n$$ \\text{总时间} = (N_{hit} \\times t_1) + (N_{vc\\_hit} \\times t_v) + (N_{mem} \\times t_m) $$\n$$ \\text{总时间} = (0 \\times 1) + (297 \\times 6) + (3 \\times 100) $$\n$$ \\text{总时间} = 0 + 1782 + 300 = 2082 \\text{ 周期} $$\n平均内存访问时间（AMAT）是总时间除以总访问次数：\n$$ \\text{AMAT} = \\frac{\\text{总时间}}{N} = \\frac{2082}{300} $$\n$$ \\text{AMAT} = 6.94 \\text{ 周期/访问} $$\n问题要求答案四舍五入到四位有效数字。\n$$ \\text{AMAT} = 6.940 \\text{ 周期/访问} $$",
            "answer": "$$\\boxed{6.940}$$"
        },
        {
            "introduction": "要想真正内化缓存的工作原理，没有什么比亲手构建一个缓存模拟器更好的方法了。这个编程练习将挑战你从零开始实现一个缓存模拟器。通过将地址映射、组选择和替换策略等抽象规则转化为具体的代码，你将对前述练习中分析的机制获得深刻而实际的理解。这种动手实践能够巩固知识，并填补理论与真实计算机系统之间的鸿沟。",
            "id": "3624604",
            "problem": "你需要设计并实现一个完整的程序，该程序模拟一个缓存，并量化在两个由固定字节距离分隔的数组之间交替访问所产生的影响。其目的是展示直接映射缓存中最坏情况下的冲突行为，以及在最近最少使用（Least Recently Used）替换策略下，二路组相联缓存如何缓解这种情况。程序必须使用 C 语言编写，并遵循在别处定义的执行环境。\n\n该问题的基本原理是计算机组成与体系结构中使用的缓存组织和地址映射的标准定义：\n\n- 一个缓存被组织成 $S$ 个组，每个组有 $E$ 行（相联度为 $E$），每行的块大小为 $B$ 字节。总容量为 $C = S \\cdot E \\cdot B$ 字节。\n- 对于一个字节地址 $a$，行号为 $L = \\left\\lfloor \\dfrac{a}{B} \\right\\rfloor$。组索引为 $i = L \\bmod S$，标记为 $t = \\left\\lfloor \\dfrac{L}{S} \\right\\rfloor$。\n- 直接映射缓存是 $E=1$ 的特殊情况。二路组相联缓存的 $E=2$。\n- 在最近最少使用（LRU）策略下，当一个满的组发生未命中时，最近访问最少的行将被替换。\n\n你将模拟在两个等长数组 $A$ 和 $B$ 之间的交替访问。这两个数组在概念上被放置在内存中，基地址分别为 $b_A = 0$ 和 $b_B = \\Delta$，其中 $\\Delta$ 是字节间隔。每个数组在每个组中恰好包含一个块，这意味着程序将对所有 $s \\in \\{0, 1, \\dots, S-1\\}$，在地址 $b_A + s \\cdot B$ 和 $b_B + s \\cdot B$ 处生成访问。对于每个组索引 $s$，你将执行 $T$ 次 $A(s), B(s), A(s), B(s), \\dots$ 模式的切换，每组总共进行 $2T$ 次访问。在所有组中，总访问次数为 $2 T S$。选择此访问模式是为了暴露当两个数组映射到同一组时，直接映射缓存的最坏抖动情况，并展示二路组相联如何在初始强制性填充后保留两个缓存行。\n\n你的程序必须实现一个由 $C$、$B$、$E$ 和 $\\Delta$ 参数化的通用缓存模拟器，并且必须计算定义为总未命中次数除以总访问次数的未命中率。所有内存单位均为字节；未命中率是一个无单位的小数。\n\n测试套件：\n为以下四个测试用例实现并运行模拟器。对于每个用例，$S$ 由 $S = \\dfrac{C}{E \\cdot B}$ 隐式确定，$T$ 是每组的切换次数。\n\n1. $C = 4096$ 字节, $B = 64$ 字节, $E = 1$, $\\Delta = C$, $T = 8$。此用例展示了当两个数组相隔一个缓存容量时，直接映射缓存的最坏抖动情况，这导致它们映射到相同的组。\n2. $C = 4096$ 字节, $B = 64$ 字节, $E = 2$, $\\Delta = C$, $T = 8$。此用例展示了在相同间隔下，二路组相联的行为，预期在最近最少使用策略下，初始填充后每个组都能保留两个缓存行。\n3. $C = 4096$ 字节, $B = 64$ 字节, $E = 2$, $\\Delta = \\dfrac{C}{2}$, $T = 8$。此用例将间距修改为缓存容量的一半，并再次测试 $E = 2$ 时二路组相联的行为。\n4. $C = 2048$ 字节, $B = 128$ 字节, $E = 2$, $\\Delta = C$, $T = 1$。此用例作为一个边界条件，其中由于单次切换，在二路组相联缓存中只观察到强制性未命中。\n\n最终输出格式：\n你的程序应生成一行输出，其中包含四个测试用例的未命中率，格式为逗号分隔的列表，并用方括号括起来，例如 $[r_1,r_2,r_3,r_4]$，其中每个 $r_i$ 是一个十进制数。将每个未命中率表示为小数点后有六位数字的十进制数。\n\n不从标准输入读取任何输入；所有参数都在程序中硬编码。输出必须严格遵守指定格式，且只有一行。",
            "solution": "问题陈述已经过验证，并被认为是合理的。它科学地基于计算机体系结构的原理，特别是缓存组织和性能分析。该问题定义明确，为确定性模拟提供了所有必要的参数（$C$、$B$、$E$、$\\Delta$、$T$）和定义。访问模式是人为构造的，但它服务于一个有效的教学目的，即展示最坏情况下的缓存冲突行为以及如何通过相联度来缓解它。该问题是完整的、一致的，并且可以形式化为一个计算模型。\n\n解决方案涉及创建一个缓存模拟器，该模拟器可以模拟具有任意容量（$C$）、块大小（$B$）和相联度（$E$）参数的缓存行为。该模拟将处理一个特定的内存访问序列，并计算由此产生的未命中率。\n\n首先，我们定义必要的数据结构来模拟缓存。缓存行是存储的基本单位。每个 `CacheLine` 必须跟踪三个信息：\n1. 一个 `valid` 位，一个整数标志（$1$ 表示有效，$0$ 表示无效），指示该行是否持有有意义的数据。\n2. 一个 `tag`，一个无符号整数，它与组索引一起唯一地标识存储在该行中的内存块。\n3. 一个 `lru_counter`，一个无符号整数，用于实现最近最少使用（LRU）替换策略。该计数器存储对该行的最后一次访问的时间戳。\n\n缓存本身被组织成一个组的数组，其中每个组是缓存行的数组。缓存可以表示为一个二维数组 `Cache[S][E]`，其中 $S$ 是组的数量，$E$ 是相联度（每组的行数）。组的数量 $S$ 通过关系式 $S = \\dfrac{C}{E \\cdot B}$ 从主要参数推导出来。\n\n模拟的核心是 `access` 过程，它确定一次内存访问是命中还是未命中。对于给定的字节地址 $a$，我们首先将其分解为三个部分：标记、组索引和块偏移。问题提供了行号 $L = \\left\\lfloor \\dfrac{a}{B} \\right\\rfloor$、组索引 $i = L \\bmod S$ 和标记 $t = \\left\\lfloor \\dfrac{L}{S} \\right\\rfloor$ 的公式。\n\n`access` 算法的步骤如下：\n1. 根据内存地址 $a$ 计算组索引 $i$ 和标记 $t$。\n2. 在相应的组 `Cache[i]` 中搜索一个有效且标记匹配的行。\n3. 如果找到这样的行，则访问为 **HIT** (命中)。该行的 `lru_counter` 更新为当前的全局时间戳，该时间戳是在每次内存访问时递增的单调递增整数。\n4. 如果没有找到匹配的行，则访问为 **MISS** (未命中)。总未命中次数增加。必须选择一行进行替换。\n    a. 首先，我们在组内搜索一个无效行。如果存在，就选择它。这对应于一次强制性未命中。\n    b. 如果组中所有行都有效，则执行 LRU 策略。我们找到具有最小 `lru_counter` 的行，表示它是最近最少使用的。选择该行进行淘汰。这对应于一次冲突或容量未命中。\n    c. 更新所选的行：将其 `valid` 位置为 $1$，`tag` 设置为新的标记 $t$，并将其 `lru_counter` 更新为当前的全局时间戳。\n\n主程序为四个测试用例中的每一个执行一次模拟。对于每个用例，它将：\n1. 根据给定的 $C$、$E$ 和 $B$ 计算 $S$。\n2. 动态分配并初始化缓存数据结构。所有 `valid` 位初始都设置为 $0$。\n3. 初始化 `miss_count` 和 `access_count` 为 $0$。`access_count` 也作为全局 LRU 时间戳。\n4. 执行指定的访问模式。一个嵌套循环遍历从 $0$ 到 $S-1$ 的每个组索引 $s$，并为每个 $s$ 执行 $T$ 次切换。在每次切换中，模拟两次内存访问：\n    a. 对数组 $A$ 在地址 $a_A = s \\cdot B$ 处的一次访问。\n    b. 对数组 $B$ 在地址 $a_B = \\Delta + s \\cdot B$ 处的一次访问。\n5. 在所有访问模拟完成后，最终的未命中率计算为 $\\dfrac{\\text{总未命中次数}}{\\text{总访问次数}}$。总访问次数为 $2 \\cdot T \\cdot S$。\n6. 释放为缓存分配的内存以防止内存泄漏。\n\n对测试用例的理论分析证实了预期的行为：\n- **用例 1**：$C=4096$, $B=64$, $E=1$, $\\Delta=C$, $T=8$。这里，$S=64$。对于任何组 $s$，地址 $a_A(s) = s \\cdot 64$ 和 $a_B(s) = 4096 + s \\cdot 64$ 映射到相同的组索引 $s$，但具有不同的标记（分别为 $0$ 和 $1$）。由于 $E=1$，每次对 $A$ 的访问都会淘汰 $B$ 的数据，反之亦然。这是典型的抖动。每次访问都是一次未命中。未命中率为 $1.0$。\n- **用例 2**：$C=4096$, $B=64$, $E=2$, $\\Delta=C$, $T=8$。这里，$S=32$。地址 $a_A(s)$ 和 $a_B(s)$ 映射到相同的组 $s$ 但具有不同的标记（$0$ 和 $2$）。由于 $E=2$，对 $A(s)$ 的第一次访问是强制性未命中，对 $B(s)$ 的第一次访问也是强制性未命中。现在两个行都驻留在组中。该组所有后续的 $2T-2 = 14$ 次访问都是命中。总未命中数 = $2 \\cdot S$。总访问数 = $2 \\cdot T \\cdot S$。未命中率 = $\\dfrac{2S}{2TS} = \\dfrac{1}{T} = \\dfrac{1}{8} = 0.125$。\n- **用例 3**：$C=4096$, $B=64$, $E=2$, $\\Delta=C/2$, $T=8$。这里，$S=32$。地址映射到相同的组 $s$ 但具有不同的标记（$0$ 和 $1$）。逻辑与用例 2 相同。未命中率 = $\\dfrac{1}{T} = 0.125$。\n- **用例 4**：$C=2048$, $B=128$, $E=2$, $\\Delta=C$, $T=1$。这里，$S=8$。由于 $T=1$，对于每个组 $s$，我们只对 $A(s)$ 执行一次访问，对 $B(s)$ 执行一次访问。两者都是强制性未命中。总未命中数 = $2 \\cdot S$。总访问数 = $2 \\cdot T \\cdot S = 2 \\cdot 1 \\cdot S$。未命中率 = $\\dfrac{2S}{2S} = 1.0$。\n\n实现将反映此逻辑来计算所需的未命中率。",
            "answer": "[1.000000, 0.125000, 0.125000, 1.000000]"
        }
    ]
}