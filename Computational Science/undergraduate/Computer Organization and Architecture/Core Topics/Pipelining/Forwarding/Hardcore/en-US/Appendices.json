{
    "hands_on_practices": [
        {
            "introduction": "To truly appreciate the power of forwarding, it is essential to compare a pipeline's performance with and without it. This exercise challenges you to do just that by analyzing a short code sequence on two different processor models. By calculating the execution schedule for each, you will gain a concrete understanding of how forwarding bridges the time gap between when a result is produced and when it is needed, thereby eliminating costly stall cycles . This hands-on comparison vividly illustrates the 'before and after' scenario that motivated the development of forwarding hardware.",
            "id": "3643888",
            "problem": "A five-stage pipelined processor with in-order issue executes stages $\\mathrm{IF}$, $\\mathrm{ID}$, $\\mathrm{EX}$, $\\mathrm{MEM}$, and $\\mathrm{WB}$ in that order, one stage per cycle. Register file writes occur in the first half of the $\\mathrm{WB}$ cycle and register file reads occur in the second half of the $\\mathrm{ID}$ cycle. There is a single $\\mathrm{EX}$ unit, so at most one instruction can occupy $\\mathrm{EX}$ in any given cycle. Consider the following program fragment, where $\\mathrm{add}$ and $\\mathrm{sub}$ are integer arithmetic operations that produce results in $\\mathrm{EX}$, and $\\mathrm{lw}$ is a load that computes an effective address in $\\mathrm{EX}$, reads memory in $\\mathrm{MEM}$, and writes the loaded value in $\\mathrm{WB}$:\n$I_1$: $\\mathrm{add}\\ r_1,\\ r_2,\\ r_3$ \n$I_2$: $\\mathrm{sub}\\ r_4,\\ r_1,\\ r_5$\n$I_3$: $\\mathrm{lw}\\ r_6,\\ 0(r_1)$\n$I_4$: $\\mathrm{add}\\ r_7,\\ r_6,\\ r_8$\n$I_5$: $\\mathrm{add}\\ r_1,\\ r_7,\\ r_9$\n$I_6$: $\\mathrm{add}\\ r_{10},\\ r_1,\\ r_{11}$\n$I_7$: $\\mathrm{lw}\\ r_{12},\\ 8(r_{10})$\n$I_8$: $\\mathrm{add}\\ r_{13},\\ r_{12},\\ r_{14}$\nAssume two machine variants:\n- Variant $\\mathcal{F}$ has full forwarding (bypassing) from $\\mathrm{EX}/\\mathrm{MEM}$ and $\\mathrm{MEM}/\\mathrm{WB}$ pipeline registers to the $\\mathrm{ID}/\\mathrm{EX}$ stage inputs.\n- Variant $\\mathcal{N}$ has no forwarding; consumers can only obtain produced values by reading the register file.\n\nModel instruction interactions as a directed acyclic graph whose vertices are the instructions $\\{I_1,\\dots,I_8\\}$ and whose edges are true data dependences ($\\mathrm{RAW}$) with pipeline-distance constraints determined only by stage timing and whether forwarding is available. Under this model, define the earliest possible cycle an instruction $I_i$ can start $\\mathrm{EX}$, denoted $E_i$, by an as-soon-as-possible topological schedule that enforces:\n- program-order in-order issue (each $I_i$ must start $\\mathrm{EX}$ no earlier than one cycle after $I_{i-1}$ starts $\\mathrm{EX}$),\n- baseline pipeline flow (absent hazards, $I_i$ would start $\\mathrm{EX}$ in cycle $i+2$),\n- the data-dependence edge constraints implied by the pipeline (derive these constraints from the given stage semantics; do not assume any formula beyond stage timing).\n\nCompute the sequences $\\{E_i^{\\mathcal{F}}\\}_{i=1}^{8}$ and $\\{E_i^{\\mathcal{N}}\\}_{i=1}^{8}$ for variants $\\mathcal{F}$ and $\\mathcal{N}$, respectively, and then compute the scalar difference $\\Delta \\equiv E_8^{\\mathcal{N}} - E_8^{\\mathcal{F}}$. Provide the value of $\\Delta$ as a single real number. No rounding is required.",
            "solution": "The problem requires the analysis of a five-stage pipelined processor executing a given sequence of instructions under two different configurations: one with full forwarding ($\\mathcal{F}$) and one with no forwarding ($\\mathcal{N}$). The goal is to determine the cycle at which the final instruction, $I_8$, starts its execution ($\\mathrm{EX}$) stage in each variant, and then to compute the difference.\n\nThe earliest cycle an instruction $I_i$ can begin its $\\mathrm{EX}$ stage, denoted $E_i$, is determined by an as-soon-as-possible (ASAP) schedule. This schedule must satisfy constraints imposed by the in-order issue nature of the pipeline and any true data dependences (Read-After-Write, or $\\mathrm{RAW}$).\n\nThe scheduling for $I_i$ is governed by the following recurrence relation for $i  1$:\n$$E_i = \\max(E_{i-1} + 1, \\{\\text{data dependence constraints for } I_i\\})$$\nThe term $E_{i-1} + 1$ enforces the structural hazard constraint due to the single $\\mathrm{EX}$ unit and in-order issue. The data dependence constraints arise from $\\mathrm{RAW}$ hazards, where $I_i$ needs a result produced by a preceding instruction $I_k$ (where $ki$). The base case is determined by the baseline pipeline flow: instruction $I_1$ is fetched at cycle $1$, decoded at cycle $2$, and starts execution at cycle $3$. Thus, $E_1 = 3$.\n\nFirst, we identify the $\\mathrm{RAW}$ data dependences in the given program fragment:\n- $I_1: \\mathrm{add}\\ r_1, r_2, r_3$\n- $I_2: \\mathrm{sub}\\ r_4, r_1, r_5$ depends on $I_1$ for register $r_1$. ($I_1 \\rightarrow I_2$)\n- $I_3: \\mathrm{lw}\\ r_6, 0(r_1)$ depends on $I_1$ for register $r_1$. ($I_1 \\rightarrow I_3$)\n- $I_4: \\mathrm{add}\\ r_7, r_6, r_8$ depends on $I_3$ for register $r_6$. ($I_3 \\rightarrow I_4$)\n- $I_5: \\mathrm{add}\\ r_1, r_7, r_9$ depends on $I_4$ for register $r_7$. ($I_4 \\rightarrow I_5$)\n- $I_6: \\mathrm{add}\\ r_{10}, r_1, r_{11}$ depends on $I_5$ for register $r_1$. ($I_5 \\rightarrow I_6$)\n- $I_7: \\mathrm{lw}\\ r_{12}, 8(r_{10})$ depends on $I_6$ for register $r_{10}$. ($I_6 \\rightarrow I_7$)\n- $I_8: \\mathrm{add}\\ r_{13}, r_{12}, r_{14}$ depends on $I_7$ for register $r_{12}$. ($I_7 \\rightarrow I_8$)\n\nNext, we derive the specific data dependence constraints for each variant. Let a producer instruction $I_k$ start its $\\mathrm{EX}$ stage at cycle $E_k$. A consumer instruction $I_i$ needs the result for its $\\mathrm{EX}$ stage, which starts at cycle $E_i$.\n\n**Variant $\\mathcal{N}$ (No Forwarding):**\nIn this variant, a result must be written to the register file before a subsequent instruction can read it.\n- An arithmetic instruction (`add`, `sub`) computes its result in the $\\mathrm{EX}$ stage (cycle $E_k$) and writes it back in the $\\mathrm{WB}$ stage (cycle $E_k+2$).\n- A load instruction (`lw`) computes its address in $\\mathrm{EX}$ (cycle $E_k$), reads memory in $\\mathrm{MEM}$ (cycle $E_k+1$), and writes the value back in the $\\mathrm{WB}$ stage (cycle $E_k+2$).\nFor both instruction types, the result is written to the register file during the first half of cycle $E_k+2$. The consumer instruction $I_i$ reads its source operands during the second half of its $\\mathrm{ID}$ stage, which occurs in cycle $E_i-1$. To ensure the correct value is read, the read must not occur in a cycle before the write. Therefore, the ID stage of $I_i$ must not be earlier than the WB stage of $I_k$:\n$$E_i - 1 \\ge E_k + 2 \\implies E_i \\ge E_k + 3$$\nThis constraint applies to all $\\mathrm{RAW}$ dependences in variant $\\mathcal{N}$.\n\n**Variant $\\mathcal{F}$ (Full Forwarding):**\nIn this variant, results can be bypassed from the end of the $\\mathrm{EX}$ or $\\mathrm{MEM}$ stages to the beginning of the $\\mathrm{EX}$ stage for a subsequent instruction.\n- **ALU-to-ALU Dependence:** If the producer $I_k$ is an arithmetic instruction, its result is available at the end of its $\\mathrm{EX}$ stage, i.e., at the end of cycle $E_k$. This value can be forwarded from the $\\mathrm{EX}/\\mathrm{MEM}$ pipeline register to the $\\mathrm{EX}$ stage input for $I_i$ in the next cycle. Thus, $I_i$ can begin execution in cycle $E_k+1$. The constraint is:\n$$E_i \\ge E_k + 1$$\n- **Load-to-Use Dependence:** If the producer $I_k$ is a `lw` instruction, its result is available from memory at the end of its $\\mathrm{MEM}$ stage, i.e., at the end of cycle $E_k+1$. This value can be forwarded from the $\\mathrm{MEM}/\\mathrm{WB}$ pipeline register to the $\\mathrm{EX}$ stage input for $I_i$ in the next cycle. Thus, $I_i$ can begin execution in cycle $E_k+2$. The constraint is:\n$$E_i \\ge E_k + 2$$\n\nNow we can compute the sequences $\\{E_i^{\\mathcal{F}}\\}_{i=1}^{8}$ and $\\{E_i^{\\mathcal{N}}\\}_{i=1}^{8}$.\n\n**Calculation for Variant $\\mathcal{F}$ (Full Forwarding):**\nThe recurrence is $E_i^\\mathcal{F} = \\max(E_{i-1}^\\mathcal{F} + 1, \\text{data dep terms})$.\n- $E_1^\\mathcal{F} = 3$.\n- $I_1 \\rightarrow I_2$ (`add` producer): $E_2^\\mathcal{F} = \\max(E_1^\\mathcal{F}+1, E_1^\\mathcal{F}+1) = \\max(3+1, 3+1) = 4$.\n- $I_1 \\rightarrow I_3$ (`add` producer): $E_3^\\mathcal{F} = \\max(E_2^\\mathcal{F}+1, E_1^\\mathcal{F}+1) = \\max(4+1, 3+1) = 5$.\n- $I_3 \\rightarrow I_4$ (`lw` producer): $E_4^\\mathcal{F} = \\max(E_3^\\mathcal{F}+1, E_3^\\mathcal{F}+2) = \\max(5+1, 5+2) = 7$.\n- $I_4 \\rightarrow I_5$ (`add` producer): $E_5^\\mathcal{F} = \\max(E_4^\\mathcal{F}+1, E_4^\\mathcal{F}+1) = \\max(7+1, 7+1) = 8$.\n- $I_5 \\rightarrow I_6$ (`add` producer): $E_6^\\mathcal{F} = \\max(E_5^\\mathcal{F}+1, E_5^\\mathcal{F}+1) = \\max(8+1, 8+1) = 9$.\n- $I_6 \\rightarrow I_7$ (`add` producer): $E_7^\\mathcal{F} = \\max(E_6^\\mathcal{F}+1, E_6^\\mathcal{F}+1) = \\max(9+1, 9+1) = 10$.\n- $I_7 \\rightarrow I_8$ (`lw` producer): $E_8^\\mathcal{F} = \\max(E_7^\\mathcal{F}+1, E_7^\\mathcal{F}+2) = \\max(10+1, 10+2) = 12$.\nThe sequence is $\\{E_i^\\mathcal{F}\\} = \\{3, 4, 5, 7, 8, 9, 10, 12\\}$. So, $E_8^\\mathcal{F}=12$.\n\n**Calculation for Variant $\\mathcal{N}$ (No Forwarding):**\nThe recurrence is $E_i^\\mathcal{N} = \\max(E_{i-1}^\\mathcal{N} + 1, \\text{data dep terms})$.\n- $E_1^\\mathcal{N} = 3$.\n- $I_1 \\rightarrow I_2$: $E_2^\\mathcal{N} = \\max(E_1^\\mathcal{N}+1, E_1^\\mathcal{N}+3) = \\max(3+1, 3+3) = 6$.\n- $I_1 \\rightarrow I_3$: $E_3^\\mathcal{N} = \\max(E_2^\\mathcal{N}+1, E_1^\\mathcal{N}+3) = \\max(6+1, 3+3) = 7$.\n- $I_3 \\rightarrow I_4$: $E_4^\\mathcal{N} = \\max(E_3^\\mathcal{N}+1, E_3^\\mathcal{N}+3) = \\max(7+1, 7+3) = 10$.\n- $I_4 \\rightarrow I_5$: $E_5^\\mathcal{N} = \\max(E_4^\\mathcal{N}+1, E_4^\\mathcal{N}+3) = \\max(10+1, 10+3) = 13$.\n- $I_5 \\rightarrow I_6$: $E_6^\\mathcal{N} = \\max(E_5^\\mathcal{N}+1, E_5^\\mathcal{N}+3) = \\max(13+1, 13+3) = 16$.\n- $I_6 \\rightarrow I_7$: $E_7^\\mathcal{N} = \\max(E_6^\\mathcal{N}+1, E_6^\\mathcal{N}+3) = \\max(16+1, 16+3) = 19$.\n- $I_7 \\rightarrow I_8$: $E_8^\\mathcal{N} = \\max(E_7^\\mathcal{N}+1, E_7^\\mathcal{N}+3) = \\max(19+1, 19+3) = 22$.\nThe sequence is $\\{E_i^\\mathcal{N}\\} = \\{3, 6, 7, 10, 13, 16, 19, 22\\}$. So, $E_8^\\mathcal{N}=22$.\n\n**Final Calculation:**\nThe problem asks for the scalar difference $\\Delta \\equiv E_8^{\\mathcal{N}} - E_8^{\\mathcal{F}}$.\nUsing the values computed above:\n$$ \\Delta = 22 - 12 = 10 $$\nThe difference in the start cycle of the $\\mathrm{EX}$ stage for instruction $I_8$ between the two variants is $10$.",
            "answer": "$$\\boxed{10}$$"
        },
        {
            "introduction": "While forwarding effectively handles most data hazards, it meets its limit in the classic \"load-use\" scenario, where an instruction immediately uses a value loaded from memory. This practice moves beyond analysis and into design, asking you to create the minimal hardware logic required to detect and stall the pipeline for this specific case . By formulating the Boolean predicate for the hazard detector, you will see how pipeline control logic is built from fundamental principles, ensuring program correctness when forwarding alone is not enough.",
            "id": "3643923",
            "problem": "A scalar, in-order, five-stage pipeline implements the following stages: instruction fetch ($\\mathrm{IF}$), instruction decode and register read ($\\mathrm{ID}$), execute ($\\mathrm{EX}$), memory access ($\\mathrm{MEM}$), and write-back ($\\mathrm{WB}$). The register file is read in $\\mathrm{ID}$ and written in $\\mathrm{WB}$. The machine forwards results from the pipeline registers at the boundaries $\\mathrm{EX}/\\mathrm{MEM}$ and $\\mathrm{MEM}/\\mathrm{WB}$ to the operand multiplexers feeding $\\mathrm{EX}$. The memory access in $\\mathrm{MEM}$ is a single-cycle ideal cache access, so a load produces its data at the end of $\\mathrm{MEM}$. There are no structural hazards. The instruction set architecture provides register-register arithmetic instructions, loads, stores, and conditional branches. Branches are resolved in $\\mathrm{EX}$ and are perfectly predicted, so there are no control stalls.\n\nYou will propose a minimal hazard detector that only stalls on load-use hazards, argue why forwarding plus this detector ensures correctness for all read-after-write data hazards in this pipeline, and then quantify the clock cycles per instruction (CPI) on a specified synthetic workload.\n\nAssumptions and nomenclature:\n- The pipeline registers are denoted $R_{\\mathrm{IF/ID}}$, $R_{\\mathrm{ID/EX}}$, $R_{\\mathrm{EX/MEM}}$, and $R_{\\mathrm{MEM/WB}}$.\n- For any instruction $I$ residing in a pipeline register $R$, the fields $R.\\mathrm{rs}$ and $R.\\mathrm{rt}$ denote the identifier of the first and second source registers read in $\\mathrm{ID}$ (when applicable), and $R.\\mathrm{dest}$ denotes the destination register written in $\\mathrm{WB}$ (when applicable). The control bit $R.\\mathrm{MemRead}$ is asserted if and only if $I$ is a load.\n- The register with index $0$ is hardwired to zero and is never written; comparisons to register $0$ should be handled in your logic so that false dependencies do not cause stalls.\n- When a stall is requested in cycle $t$, the program counter and $R_{\\mathrm{IF/ID}}$ are held, and a bubble (a $\\mathrm{NOP}$) is injected into $R_{\\mathrm{ID/EX}}$ for cycle $t+1$.\n\nTasks:\n1) From the preceding definitions and the semantics of the five-stage pipeline, derive a minimal combinational predicate $H$ over fields of $R_{\\mathrm{IF/ID}}$ and $R_{\\mathrm{ID/EX}}$ that is true if and only if a one-cycle stall must be inserted to avoid a read-after-write timing violation in $\\mathrm{EX}$ of the next cycle. Express $H$ symbolically in terms of equality, logical conjunction, disjunction, and negation over the named fields.\n\n2) Using only the pipeline timing assumptions stated above and the existence of forwarding from $R_{\\mathrm{EX/MEM}}$ and $R_{\\mathrm{MEM/WB}}$ to the $\\mathrm{EX}$ operand inputs, argue that with $H$ as the only source of stalls, all read-after-write data hazards are correctly handled. Your argument should consider producer instructions that are arithmetic (producing results at the end of $\\mathrm{EX}$) and loads (producing results at the end of $\\mathrm{MEM}$), and should explain why no other stalls are needed beyond those signaled by $H$.\n\n3) Consider a long synthetic instruction stream in which the static instruction mix is: arithmetic instructions fraction $f_{\\mathrm{A}} = 0.44$, loads fraction $f_{\\mathrm{L}} = 0.28$, stores fraction $f_{\\mathrm{S}} = 0.18$, and branches fraction $f_{\\mathrm{B}} = 0.10$. Assume the following independence model for data dependences: conditioned on an instruction at position $i$ being a load that writes a nonzero register, the instruction at position $i+1$ reads that same destination register as one of its sources with probability $p = 0.35$, independently of everything else. If it does, that constitutes a load-use case as defined in your $H$; otherwise, it does not. There are no other sources of stalls.\n\nBased on the minimal stall policy in parts $1$ and $2$, compute the expected steady-state $\\mathrm{CPI}$ of this pipeline on this workload. Round your answer to four significant figures. State only a single numerical value with no units.",
            "solution": "The problem presents a classic five-stage pipelined processor model and asks for the derivation of hazard detection logic, an argument for its correctness, and a performance calculation in terms of Clock Cycles Per Instruction ($\\mathrm{CPI}$). The problem is well-defined, internally consistent, and grounded in the fundamental principles of computer architecture. It will be addressed in three parts as requested.\n\n### 1. Derivation of the Hazard Detection Predicate $H$\n\nA data hazard requiring a stall occurs when the result of an instruction is not available when a subsequent instruction needs it, and the data cannot be supplied by the forwarding hardware. We must identify the specific timing case where this occurs.\n\nThe pipeline has forwarding from the output registers of the $\\mathrm{EX}$ and $\\mathrm{MEM}$ stages, namely $R_{\\mathrm{EX/MEM}}$ and $R_{\\mathrm{MEM/WB}}$, to the inputs of the $\\mathrm{EX}$ stage.\n- An arithmetic instruction computes its result in the $\\mathrm{EX}$ stage. This result is available in $R_{\\mathrm{EX/MEM}}$ at the end of the $\\mathrm{EX}$ stage, in time to be forwarded to the next instruction entering its $\\mathrm{EX}$ stage.\n- A load instruction fetches data from memory in the $\\mathrm{MEM}$ stage. This data is available in $R_{\\mathrm{MEM/WB}}$ only at the end of the $\\mathrm{MEM}$ stage.\n\nLet's consider a load instruction, $I_1$, followed immediately by an instruction, $I_2$, that uses the loaded data.\n- At cycle $t$, let $I_1$ be in the $\\mathrm{EX}$ stage and $I_2$ be in the $\\mathrm{ID}$ stage. The hardware in the $\\mathrm{ID}$ stage must decide whether to stall or proceed.\n- If the pipeline does not stall, then in cycle $t+1$, $I_1$ moves to the $\\mathrm{MEM}$ stage and $I_2$ moves to the $\\mathrm{EX}$ stage.\n- $I_2$ requires its source operands at the beginning of its $\\mathrm{EX}$ stage (i.e., at the start of cycle $t+1$).\n- However, $I_1$ will only have its data available from memory at the end of its $\\mathrm{MEM}$ stage (i.e., at the end of cycle $t+1$).\n- The data is thus not available for $I_2$ at the start of its $\\mathrm{EX}$ stage. The forwarding paths from $R_{\\mathrm{EX/MEM}}$ and $R_{\\mathrm{MEM/WB}}$ are of no help, as the required data has not yet been latched into either of these registers. This is a load-use RAW (Read-After-Write) hazard.\n\nTo resolve this, a one-cycle stall is necessary. When the hazard is detected in cycle $t$, a bubble is injected into the $\\mathrm{EX}$ stage for cycle $t+1$, and instruction $I_2$ is held in the $\\mathrm{ID}$ stage.\n- Cycle $t$: $I_1$ is in $\\mathrm{EX}$, $I_2$ is in $\\mathrm{ID}$. Hazard is detected.\n- Cycle $t+1$: $I_1$ moves to $\\mathrm{MEM}$. $I_2$ remains in $\\mathrm{ID}$. A $\\mathrm{NOP}$ (bubble) enters $\\mathrm{EX}$.\n- Cycle $t+2$: $I_1$ moves to $\\mathrm{WB}$. $I_2$ moves to $\\mathrm{EX}$. At the start of this cycle, the result of the load is in the pipeline register $R_{\\mathrm{MEM/WB}}$. The forwarding path from $R_{\\mathrm{MEM/WB}}$ can now correctly supply the operand to the $\\mathrm{EX}$ stage for $I_2$.\n\nThe hazard detection logic must identify this precise scenario. The logic resides in the $\\mathrm{ID}$ stage and operates on the contents of the pipeline registers that represent the instruction in $\\mathrm{EX}$ ($R_{\\mathrm{ID/EX}}$) and the instruction in $\\mathrm{ID}$ ($R_{\\mathrm{IF/ID}}$). The predicate $H$ for stalling is true if and only if all of the following conditions are met:\n1. The instruction in the $\\mathrm{EX}$ stage is a load. This is true if its `MemRead` control signal is asserted: $R_{\\mathrm{ID/EX}}.\\mathrm{MemRead}$.\n2. The destination register of the load instruction is one of the source registers for the instruction in the $\\mathrm{ID}$ stage. This is true if $(R_{\\mathrm{ID/EX}}.\\mathrm{dest} = R_{\\mathrm{IF/ID}}.\\mathrm{rs}) \\lor (R_{\\mathrm{ID/EX}}.\\mathrm{dest} = R_{\\mathrm{IF/ID}}.\\mathrm{rt})$.\n3. The dependency is not on the hardwired zero register, which can be read but never written. This means the destination register of the load cannot be register $0$: $R_{\\mathrm{ID/EX}}.\\mathrm{dest} \\neq 0$, which can be expressed as $\\neg(R_{\\mathrm{ID/EX}}.\\mathrm{dest} = 0)$.\n\nCombining these conditions, the minimal combinational predicate $H$ is:\n$$H = (R_{\\mathrm{ID/EX}}.\\mathrm{MemRead}) \\land \\neg(R_{\\mathrm{ID/EX}}.\\mathrm{dest} = 0) \\land ((R_{\\mathrm{ID/EX}}.\\mathrm{dest} = R_{\\mathrm{IF/ID}}.\\mathrm{rs}) \\lor (R_{\\mathrm{ID/EX}}.\\mathrm{dest} = R_{\\mathrm{IF/ID}}.\\mathrm{rt}))$$\n\n### 2. Argument for Correctness\n\nWe must demonstrate that the combination of the specified forwarding paths and the stall logic $H$ correctly resolves all possible RAW data hazards. We can classify hazards by the type of producer instruction and the distance to the consumer instruction.\n\n**Case A: The producer is an arithmetic instruction.**\nThe result is available at the end of the $\\mathrm{EX}$ stage in the $R_{\\mathrm{EX/MEM}}$ register.\n- **Consumer is the next instruction ($i+1$):** When the consumer instruction is in its $\\mathrm{EX}$ stage, the producer is in its $\\mathrm{MEM}$ stage. The producer's result is in $R_{\\mathrm{EX/MEM}}$ and can be forwarded to the consumer's $\\mathrm{EX}$ stage input. No stall is needed.\n- **Consumer is instruction $i+2$:** When the consumer is in its $\\mathrm{EX}$ stage, the producer is in its $\\mathrm{WB}$ stage. The producer's result is in $R_{\\mathrm{MEM/WB}}$ and can be forwarded to the consumer's $\\mathrm{EX}$ stage input. No stall is needed.\n- **Consumer is instruction $i+3$ or later:** The producer is past its $\\mathrm{WB}$ stage. The result has been written to the register file. The consumer reads the correct value from the register file during its $\\mathrm{ID}$ stage (due to write-before-read register file semantics, where the write half-cycle of $\\mathrm{WB}$ precedes the read half-cycle of $\\mathrm{ID}$). No stall is needed.\nConclusion for Case A: All RAW hazards from arithmetic instructions are resolved by the forwarding logic without stalls.\n\n**Case B: The producer is a load instruction.**\nThe result is available at the end of the $\\mathrm{MEM}$ stage in the $R_{\\mathrm{MEM/WB}}$ register.\n- **Consumer is the next instruction ($i+1$):** This is the load-use hazard detailed in Part 1. The result is needed by the consumer at the beginning of its $\\mathrm{EX}$ stage, but the producer only furnishes it at the end of its $\\mathrm{MEM}$ stage. Forwarding is not possible in time. The predicate $H$ is specifically designed to detect this case (load in $\\mathrm{EX}$, dependent consumer in $\\mathrm{ID}$) and correctly triggers a one-cycle stall. After the stall, the dependency is equivalent to the `load-use at i+2` case, which is handled by forwarding.\n- **Consumer is instruction $i+2$:** When the consumer is in its $\\mathrm{EX}$ stage, the producer is in its $\\mathrm{WB}$ stage. The loaded data is in $R_{\\mathrm{MEM/WB}}$ and can be forwarded to the consumer's $\\mathrm{EX}$ stage input. The predicate $H$ does not fire, as the instruction in the $\\mathrm{EX}$ stage (instruction $i+1$) is not the producer load instruction. The lack of a stall is correct.\n- **Consumer is instruction $i+3$ or later:** The result has been written to the register file and is read directly by the consumer. No stall is needed.\nConclusion for Case B: The only RAW hazard involving a load that is not resolved by forwarding is the immediate load-use case. This specific case is detected by $H$ and resolved by a one-cycle stall. All other cases are handled by forwarding or normal register file operation.\n\nSince all possible RAW hazards originating from both arithmetic and load instructions are handled correctly by either the forwarding hardware or the minimal stall logic $H$, the pipeline's data hazard handling is correct.\n\n### 3. CPI Calculation\n\nThe Clock Cycles Per Instruction ($\\mathrm{CPI}$) is the total number of clock cycles divided by the total number of instructions. In an ideal pipeline with no hazards, the $\\mathrm{CPI}$ is $1$. Stalls increase the $\\mathrm{CPI}$. The formula for $\\mathrm{CPI}$ is:\n$$ \\mathrm{CPI} = \\mathrm{CPI}_{\\text{ideal}} + \\frac{\\text{Total Stall Cycles}}{\\text{Total Instructions}} $$\nGiven $\\mathrm{CPI}_{\\text{ideal}} = 1$, we can write:\n$$ \\mathrm{CPI} = 1 + (\\text{stall frequency}) \\times (\\text{stall penalty}) $$\nFrom the analysis above, stalls only occur for a load-use hazard. The problem specifies a one-cycle stall, so the stall penalty is $1$ cycle per occurrence.\n\nWe need to calculate the stall frequency, which is the probability that any given instruction sequence triggers a stall. A stall is triggered if an instruction is a load AND the immediately following instruction uses its result.\n- The fraction of instructions that are loads is given as $f_{\\mathrm{L}} = 0.28$.\n- The probability that the instruction immediately following a load has a dependency on it is given as $p = 0.35$. This dependence is what is detected by the hazard logic $H$.\n\nThe frequency of stall events per instruction in the stream is the product of the probability of an instruction being a load and the conditional probability of the next instruction causing a load-use hazard.\n$$ \\text{Stall Frequency} = f_{\\mathrm{L}} \\times p $$\nThe number of stall cycles per instruction is this frequency multiplied by the penalty of $1$ cycle.\n$$ \\frac{\\text{Total Stall Cycles}}{\\text{Total Instructions}} = f_{\\mathrm{L}} \\times p \\times 1 = f_{\\mathrm{L}} \\times p $$\nSubstituting this into the $\\mathrm{CPI}$ formula:\n$$ \\mathrm{CPI} = 1 + f_{\\mathrm{L}} \\times p $$\nUsing the provided values $f_{\\mathrm{L}} = 0.28$ and $p = 0.35$:\n$$ \\mathrm{CPI} = 1 + (0.28 \\times 0.35) $$\n$$ \\mathrm{CPI} = 1 + 0.098 $$\n$$ \\mathrm{CPI} = 1.098 $$\nThe problem asks for the answer to be rounded to four significant figures. The value $1.098$ has exactly four significant figures.",
            "answer": "$$\n\\boxed{1.098}\n$$"
        },
        {
            "introduction": "High-level pipeline diagrams often simplify the forwarding network, but in reality, it is a physical resource with its own limitations. This final practice explores a subtle bottleneck: a limited number of bypass paths to the execution stage's inputs. You will analyze a specific instruction pattern designed to saturate this resource, revealing a scenario where stalls are required even for simple arithmetic operations . This exercise emphasizes that peak performance depends not just on the presence of forwarding, but on the specific capabilities of its implementation.",
            "id": "3643887",
            "problem": "A five-stage in-order scalar pipeline is used for integer instructions. The stages are Instruction Fetch (IF), Instruction Decode (ID), Execute (EX), Memory (MEM), and Write Back (WB). The following microarchitectural facts hold and should be treated as the foundational base for your reasoning:\n\n- For register-register arithmetic instructions, the result is produced at the end of the EX stage and is latched into the EX/MEM pipeline register. The forwarding network can source this result to the EX stage operand input of a younger instruction from any of the EX/MEM or MEM/WB pipeline registers in subsequent cycles.\n- The register file write occurs in the first half of the WB cycle, and register file reads occur in the second half of the ID cycle. Therefore, a value written in WB during cycle $t$ is readable from the register file by any instruction in ID during the same cycle $t$.\n- The forwarding network has a single bypass bus feeding the EX stage. Consequently, at most one of the two EX operand ports may select a forwarded value in any given cycle; the other operand must be sourced from the register file in that cycle.\n\nConsider the following test pattern consisting of $n$ consecutive dependent instructions, each targeting the same architectural register:\n- For $k \\in \\{1,2,\\dots,n\\}$, instruction $I_k$ is of the form $R_1 \\leftarrow R_1 + R_1$.\n\nAssume ideal branch prediction and instruction cache behavior so that fetch and decode are never starved unless structural or data hazards force stalls. You may assume single-issue ($1$ instruction per cycle maximum into IF) and that no other instructions are interleaved.\n\nUsing only the facts above, determine whether, for this specific pattern, the forwarding network becomes the bottleneck (in the sense that it is exercised at its maximum per-cycle capacity for operands needed to avoid read-after-write hazards) and compute the maximum depth $n_{\\max}$ of this dependency chain that can be placed consecutively (back-to-back) without any stall cycles inserted by the pipeline.\n\nState your final answer as the value of $n_{\\max}$. No rounding is required, and no units are involved.",
            "solution": "The problem asks for an analysis of a specific instruction sequence on a given $5$-stage pipelined processor architecture to determine if the forwarding network is a bottleneck and to find the maximum number of such instructions that can execute without stalls.\n\nLet the five pipeline stages be Instruction Fetch (IF), Instruction Decode (ID), Execute (EX), Memory (MEM), and Write Back (WB). The pipeline is in-order and single-issue. We consider a sequence of $n$ instructions, $I_1, I_2, \\dots, I_n$, where each instruction $I_k$ for $k \\in \\{1, 2, \\dots, n\\}$ is of the form $R_1 \\leftarrow R_1 + R_1$. This creates a true data dependency (Read-After-Write, or RAW hazard) between each consecutive pair of instructions $(I_{k-1}, I_k)$, as $I_k$ reads register $R_1$ which is written by $I_{k-1}$.\n\nLet us trace the execution of the first two instructions, $I_1$ and $I_2$, on a cycle-by-cycle basis. We denote cycle $j$ as $C_j$.\n\n- **Instruction $I_1$: $R_1 \\leftarrow R_1 + R_1$**\n  - $C_1$: $I_1$ is in the IF stage.\n  - $C_2$: $I_1$ is in the ID stage. It reads the initial value of $R_1$ from the register file.\n  - $C_3$: $I_1$ is in the EX stage. It computes the sum. The result is produced at the end of this cycle.\n  - $C_4$: $I_1$ is in the MEM stage. Its result is latched in the EX/MEM pipeline register.\n  - $C_5$: $I_1$ is in the WB stage. Its result moves to the MEM/WB pipeline register and is written back to the architectural register $R_1$ in the first half of this cycle.\n\n- **Instruction $I_2$: $R_1 \\leftarrow R_1 + R_1$**\n  - $C_2$: $I_2$ is in the IF stage.\n  - $C_3$: $I_2$ is in the ID stage. The hazard detection unit recognizes that $I_2$ needs the result of $I_1$, which is currently being computed in the EX stage.\n  - $C_4$: In a pipeline without stalls, $I_2$ would now enter the EX stage. For this to happen correctly, $I_2$ must be provided with the result of $I_1$ for its source operands. The instruction $I_2$ requires the new value of $R_1$ for *both* of its source operands.\n  - At the beginning of $C_4$, the result of $I_1$ is available in the EX/MEM pipeline register. The forwarding network can deliver this value to the EX stage for use by $I_2$.\n  - Now we must consider the critical constraint: \"at most one of the two EX operand ports may select a forwarded value in any given cycle; the other operand must be sourced from the register file in that cycle.\"\n  - Since $I_2$ requires the same forwarded value for both of its operand ports, and the hardware can only supply a forwarded value to one port, this condition cannot be met. The other operand would have to be read from the register file, but the register file will not be updated with $I_1$'s result until the WB stage of $I_1$ (cycle $C_5$). Sourcing the second operand from the register file in $C_3$ (during $I_2$'s ID stage) would provide a stale value, leading to an incorrect computation.\n  - Therefore, the forwarding path from EX/MEM to EX is insufficient to resolve the hazard for this specific instruction. This directly demonstrates that the forwarding network is the bottleneck; its limitation is the direct cause of the pipeline's inability to proceed at one instruction per cycle.\n\nTo maintain correctness, the pipeline must stall. $I_2$ must wait until the required value is available through a mechanism that does not violate the hardware constraints. The only other path for the data is through the register file itself.\n\nLet's analyze the stall behavior:\n- $I_2$ is in the ID stage in $C_3$. The hazard is detected. The control logic determines that forwarding cannot resolve the hazard.\n- The pipeline stalls $I_2$ in the ID stage. This means a bubble (a no-op) is inserted into the EX stage in $C_4$.\n- $C_4$: $I_1$ is in MEM. A bubble is in EX. $I_2$ remains in ID.\n- In $C_5$, $I_1$ reaches the WB stage. The result of $I_1$ is written into $R_1$ in the first half of $C_5$. According to the problem statement, this value is then available to be read by an instruction in the ID stage in the second half of the same cycle, $C_5$.\n- $I_2$ has been stalled and is still in the ID stage in $C_5$. In the second half of $C_5$, it can now read the correct, updated value of $R_1$ from the register file for both of its source operands.\n- $C_6$: Having successfully obtained its operands from the register file at the end of $C_5$, $I_2$ can now proceed to its EX stage.\n\nThe execution timeline with stalls is as follows:\n- $I_1$: IF($C_1$), ID($C_2$), EX($C_3$), MEM($C_4$), WB($C_5$)\n- $I_2$: IF($C_2$), ID($C_3$), stall($C_4$), stall($C_5$), EX($C_6$), MEM($C_7$), WB($C_8$)\n\nThis demonstrates that a sequence of two dependent instructions of the form $R_1 \\leftarrow R_1 + R_1$ cannot execute without stalls. A $2$-cycle stall is introduced for $I_2$. This logic applies to any pair of consecutive instructions $(I_{k-1}, I_k)$ in the chain.\n\nThe question asks for the maximum depth $n_{\\max}$ of the dependency chain that can be placed consecutively without *any* stall cycles.\n- For $n \\ge 2$, a stall will occur between instructions $I_1$ and $I_2$.\n- For $n = 1$, the chain consists of only a single instruction, $I_1$. There are no subsequent dependent instructions in the chain, so no stalls related to this dependency chain can occur. The instruction $I_1$ will complete its execution without being stalled by any other instruction in the sequence $\\{I_k\\}$.\n\nThus, the maximum length of the chain that can execute without any stall cycles is $1$.",
            "answer": "$$\\boxed{1}$$"
        }
    ]
}