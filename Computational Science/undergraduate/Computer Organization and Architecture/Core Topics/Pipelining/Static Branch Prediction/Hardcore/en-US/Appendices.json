{
    "hands_on_practices": [
        {
            "introduction": "Loops are one of the most fundamental control structures in programming, making the branches that control them a key target for prediction. This exercise provides a quantitative framework for evaluating the performance of the common Backward-Taken, Forward-Not-Taken (BTFNT) heuristic in a typical loop that also contains a forward-branching error check. By calculating core metrics like prediction accuracy and Cycles Per Instruction ($CPI$), you will build a concrete understanding of how a predictor's choices translate into measurable performance impacts. ",
            "id": "3680985",
            "problem": "A simple microbenchmark executes a loop and includes two conditional branches per iteration: a backward loop back-edge branch and a forward error-check branch. Two static predictors are considered: Backward Taken, Forward Not Taken (BTFNT) and an always-not-taken predictor. Assume the following and treat all expectations over the stated probabilities as exact for the purpose of analysis.\n\n- The loop runs for exactly $L$ iterations. The loop back-edge is a backward branch that is taken on the first $L-1$ iterations and not taken once on loop exit.\n- In each iteration, before the back-edge, the code executes a forward error-check branch that is taken independently with probability $p$ and not taken with probability $1-p$. When this error-check branch is taken, exactly $H$ additional instructions are executed in that iteration; when it is not taken, no additional instructions from this error-handling block are executed.\n- Each iteration executes exactly $B$ non-branch instructions in the loop body (excluding the two branch instructions and any error-handling instructions), plus the two branch instructions themselves (the forward error-check and the backward back-edge).\n- The processor is an in-order pipeline with an ideal base cost of $1$ cycle per instruction in the absence of control hazards. On any branch misprediction, the pipeline incurs an additional fixed misprediction penalty of $M$ cycles. There are no other stalls or cache effects.\n\nUse the fundamental definitions that (i) prediction accuracy $A$ is the ratio of correctly predicted branch outcomes to total dynamic branch outcomes, and (ii) cycles per instruction (CPI) is total cycles divided by total retired instructions, with total cycles equal to base instruction cycles plus misprediction penalties.\n\nGiven parameters $L=200$, $p=0.03$, $H=6$, $B=18$, and $M=3$:\n\n1. Derive expressions for the combined prediction accuracy $A$ across all dynamic branch outcomes under BTFNT and under the always-not-taken predictor, and then evaluate them for the given parameters.\n2. Derive expressions for the expected CPI under BTFNT and under the always-not-taken predictor, and then evaluate them for the given parameters.\n3. Finally, report the CPI improvement $\\Delta = \\text{CPI}_{\\text{always-not}} - \\text{CPI}_{\\text{BTFNT}}$ as a decimal, rounded to four significant figures. Do not include any units in your final numeric answer.",
            "solution": "The problem is well-posed, scientifically grounded in the principles of computer architecture, and provides a complete and consistent set of parameters for analysis. It is therefore deemed valid. We proceed with the solution by first deriving general expressions for the quantities of interest and then substituting the given numerical values.\n\nThe provided parameters are:\n- Loop iterations: $L = 200$\n- Probability of forward branch taken: $p = 0.03$\n- Error handling instructions: $H = 6$\n- Base instructions in loop body: $B = 18$\n- Misprediction penalty: $M = 3$ cycles\n\nFirst, we determine quantities that are independent of the branch prediction strategy.\nThe loop executes $L$ times. In each iteration, there are two branch instructions: one forward error-check branch and one backward loop back-edge branch.\nThe total number of dynamic branch instructions is:\n$$ I_{\\text{branches}} = 2L $$\n\nThe total number of retired instructions, $I_{\\text{total}}$, consists of the base instructions executed in every loop iteration plus the additional instructions executed when the error-check branch is taken. The base instructions per iteration are $B$ non-branch instructions plus the $2$ branch instructions, totaling $B+2$. The error-check branch is taken with probability $p$, adding $H$ instructions. Therefore, the expected total number of retired instructions, $E[I_{\\text{total}}]$, is:\n$$ E[I_{\\text{total}}] = L(B+2) + LpH = L(B+2+pH) $$\nFor the given parameters:\n$$ E[I_{\\text{total}}] = 200(18+2+(0.03)(6)) = 200(20+0.18) = 200(20.18) = 4036 $$\n\n1.  **Prediction Accuracy ($A$)**\n\nAccuracy is the ratio of correctly predicted branches to the total number of dynamic branches.\n\n**a) BTFNT (Backward Taken, Forward Not Taken) Predictor**\nThe policy is to predict all backward branches as 'taken' and all forward branches as 'not taken'.\n-   **Forward Branches**: There are $L$ dynamic forward branches. They are predicted 'not taken'. They are actually taken with probability $p$. The expected number of correct predictions is the number of times the branch is not taken: $L(1-p)$.\n-   **Backward Branches**: There are $L$ dynamic backward branches. They are predicted 'taken'. The loop back-edge is taken for the first $L-1$ iterations and not taken on the final exit. Thus, there are $L-1$ correct predictions.\n\nThe total expected number of correct predictions for the BTFNT scheme, $C_{\\text{BTFNT}}$, is:\n$$ E[C_{\\text{BTFNT}}] = L(1-p) + (L-1) = 2L - Lp - 1 $$\nThe accuracy, $A_{\\text{BTFNT}}$, is:\n$$ A_{\\text{BTFNT}} = \\frac{E[C_{\\text{BTFNT}}]}{2L} = \\frac{2L - Lp - 1}{2L} $$\nNumerically:\n$$ A_{\\text{BTFNT}} = \\frac{2(200) - 200(0.03) - 1}{2(200)} = \\frac{400 - 6 - 1}{400} = \\frac{393}{400} = 0.9825 $$\n\n**b) Always-Not-Taken Predictor**\nThe policy is to predict all branches as 'not taken'.\n-   **Forward Branches**: There are $L$ dynamic forward branches. They are predicted 'not taken'. The number of correct predictions is the same as for BTFNT: $L(1-p)$.\n-   **Backward Branches**: There are $L$ dynamic backward branches. They are predicted 'not taken'. The branch is actually not taken only once, on loop exit. Thus, there is only $1$ correct prediction.\n\nThe total expected number of correct predictions for the always-not-taken scheme, $C_{\\text{always-not}}$, is:\n$$ E[C_{\\text{always-not}}] = L(1-p) + 1 $$\nThe accuracy, $A_{\\text{always-not}}$, is:\n$$ A_{\\text{always-not}} = \\frac{E[C_{\\text{always-not}}]}{2L} = \\frac{L(1-p) + 1}{2L} $$\nNumerically:\n$$ A_{\\text{always-not}} = \\frac{200(1-0.03) + 1}{2(200)} = \\frac{200(0.97) + 1}{400} = \\frac{194 + 1}{400} = \\frac{195}{400} = 0.4875 $$\n\n2.  **Cycles Per Instruction (CPI)**\n\nThe CPI is a ratio of total cycles to total retired instructions. Total cycles are the sum of base cycles (one per instruction) and penalty cycles from mispredictions.\n$$ \\text{CPI} = \\frac{E[I_{\\text{total}}] \\times 1 + E[\\text{Mispredictions}] \\times M}{E[I_{\\text{total}}]} = 1 + \\frac{E[\\text{Mispredictions}] \\times M}{E[I_{\\text{total}}]} $$\nFirst, we find the expected number of mispredictions for each policy. A misprediction is the complement of a correct prediction. $E[\\text{Mispredictions}] = I_{\\text{branches}} - E[\\text{Correct}]$.\n\n**a) CPI for BTFNT**\nThe expected number of mispredictions, $E[\\text{Misc}_{\\text{BTFNT}}]$, is:\n-   **Forward Branches**: Mispredicted when taken. Expected count: $Lp$.\n-   **Backward Branches**: Mispredicted when not taken. Count: $1$ (on loop exit).\n$$ E[\\text{Misc}_{\\text{BTFNT}}] = Lp + 1 $$\nThe CPI expression is:\n$$ \\text{CPI}_{\\text{BTFNT}} = 1 + \\frac{(Lp + 1)M}{L(B+2+pH)} $$\nNumerically:\n$$ E[\\text{Misc}_{\\text{BTFNT}}] = 200(0.03) + 1 = 6 + 1 = 7 $$\n$$ \\text{CPI}_{\\text{BTFNT}} = 1 + \\frac{7 \\times 3}{4036} = 1 + \\frac{21}{4036} = \\frac{4036+21}{4036} = \\frac{4057}{4036} \\approx 1.005203 $$\n\n**b) CPI for Always-Not-Taken**\nThe expected number of mispredictions, $E[\\text{Misc}_{\\text{always-not}}]$, is:\n-   **Forward Branches**: Mispredicted when taken. Expected count: $Lp$.\n-   **Backward Branches**: Mispredicted when taken. Count: $L-1$.\n$$ E[\\text{Misc}_{\\text{always-not}}] = Lp + (L-1) $$\nThe CPI expression is:\n$$ \\text{CPI}_{\\text{always-not}} = 1 + \\frac{(Lp + L - 1)M}{L(B+2+pH)} $$\nNumerically:\n$$ E[\\text{Misc}_{\\text{always-not}}] = 200(0.03) + (200 - 1) = 6 + 199 = 205 $$\n$$ \\text{CPI}_{\\text{always-not}} = 1 + \\frac{205 \\times 3}{4036} = 1 + \\frac{615}{4036} = \\frac{4036+615}{4036} = \\frac{4651}{4036} \\approx 1.152379 $$\n\n3.  **CPI Improvement ($\\Delta$)**\n\nThe CPI improvement is defined as $\\Delta = \\text{CPI}_{\\text{always-not}} - \\text{CPI}_{\\text{BTFNT}}$.\nUsing the derived expressions:\n$$ \\Delta = \\left(1 + \\frac{(Lp + L - 1)M}{E[I_{\\text{total}}]}\\right) - \\left(1 + \\frac{(Lp + 1)M}{E[I_{\\text{total}}]}\\right) $$\n$$ \\Delta = \\frac{M}{E[I_{\\text{total}}]} \\left( (Lp + L - 1) - (Lp + 1) \\right) $$\n$$ \\Delta = \\frac{M(L - 2)}{E[I_{\\text{total}}]} = \\frac{M(L - 2)}{L(B+2+pH)} $$\nNow we substitute the numerical values:\n$$ \\Delta = \\frac{3(200 - 2)}{4036} = \\frac{3(198)}{4036} = \\frac{594}{4036} $$\nEvaluating this fraction and rounding to four significant figures:\n$$ \\Delta \\approx 0.14717542... \\approx 0.1472 $$\nThis result can also be found by subtracting the numerical CPI values:\n$$ \\Delta = \\frac{4651}{4036} - \\frac{4057}{4036} = \\frac{4651 - 4057}{4036} = \\frac{594}{4036} \\approx 0.1472 $$",
            "answer": "$$ \\boxed{0.1472} $$"
        },
        {
            "introduction": "While the BTFNT heuristic is effective for common code patterns, it is essential to understand its limitations. This problem uses a thought experiment involving rarely-executed error handling code to probe a specific weakness in this static prediction rule. By carefully tracing the control flow and applying the BTFNT logic, you will see how certain program structures can cause systematic and predictable mispredictions, revealing the boundaries of this simple heuristic's effectiveness. ",
            "id": "3680956",
            "problem": "A processor uses static branch prediction with the rule Backward Taken, Forward Not Taken (BTFNT). Under BTFNT, any conditional branch whose target lies at a lower program counter address than the branch itself is predicted taken, and any conditional branch whose target lies at a higher program counter address is predicted not taken. A misprediction occurs when the actual branch outcome differs from the static prediction.\n\nConsider a program that, on each complete execution, performs a single forward conditional branch testing an error condition. If the error condition holds, control transfers to an error-handling loop; otherwise, control flows directly to normal completion. The control flow can be described as follows:\n- From the main path, a conditional forward branch tests an error predicate that is true with probability $p \\in [0,1]$. If true, control jumps forward to the entry of an error-handling loop; if false, control continues to termination.\n- The error-handling loop is structured with a single backward conditional branch at its bottom that jumps back to the top of the loop when the error condition remains unresolved. Once entered, the loop iterates a finite, positive number of times $N \\geq 1$ and exits only when the backward branch evaluates not taken at the final iteration.\n\nAssume that across $T$ independent full program executions, the error predicate at the forward branch is independently true with probability $p$ on each execution. No other branches execute. Starting from the base definitions above and without invoking any pre-derived formulas about misprediction counts, reason about the dynamic outcomes the BTFNT predictor will correctly and incorrectly predict along this control flow. Then, compute the expected total number of mispredictions over the $T$ executions, as a closed-form expression in terms of $p$ and $T$.\n\nProvide your final answer as a single analytic expression in terms of $p$ and $T$. Do not use a percentage sign; interpret $p$ as a decimal in $[0,1]$. No rounding is required.",
            "solution": "The problem statement is first subjected to validation.\n\n**Step 1: Extract Givens**\n- Processor uses a static branch prediction rule: Backward Taken, Forward Not Taken (BTFNT).\n- BTFNT definition: A conditional branch is predicted taken if its target's program counter (PC) address is lower than the branch's PC address (backward branch). It is predicted not taken if its target's PC address is higher (forward branch).\n- A program executes a single forward conditional branch.\n- This forward branch tests an error predicate.\n- The error predicate is true with probability $p \\in [0,1]$.\n- If the predicate is true (branch taken), control jumps forward to an error-handling loop.\n- If the predicate is false (branch not taken), control continues to program termination.\n- The error-handling loop contains a single backward conditional branch at its end.\n- When entered, the loop iterates a finite, positive number of times, $N \\geq 1$.\n- The backward branch is taken for the first $N-1$ iterations and not taken on the final, $N$-th iteration, causing the loop to exit.\n- The program is executed $T$ independent times.\n- The goal is to compute the expected total number of mispredictions over $T$ executions as a closed-form expression in terms of $p$ and $T$.\n\n**Step 2: Validate Using Extracted Givens**\n- **Scientifically Grounded:** The problem is firmly rooted in the principles of computer architecture, specifically processor design and performance analysis. Static branch prediction schemes like BTFNT are standard introductory topics, and modeling program behavior with probabilities to analyze performance is a common and valid technique.\n- **Well-Posed:** The problem is well-posed. The prediction rule is defined unambiguously. The control flow is described completely for all cases. The probabilistic nature of the branch outcome is specified. The question asks for a mathematically calculable quantity, the expected value, based on the provided parameters. The fact that the loop iterates $N \\geq 1$ times is sufficient to determine the number of mispredictions within the loop, without needing the specific value of $N$.\n- **Objective:** The problem is stated in precise, objective language without ambiguity or subjective claims.\n\n**Step 3: Verdict and Action**\nThe problem is valid as it is scientifically sound, self-contained, and well-posed. A rigorous solution can be derived from the provided information. We proceed with the solution.\n\nThe objective is to find the expected total number of mispredictions over $T$ independent program executions. Let $M_{total}$ be the total number of mispredictions. By the linearity of expectation, if all executions are independent and identically distributed, the total expected number of mispredictions is $T$ times the expected number of mispredictions in a single execution.\n$$E[M_{total}] = E\\left[ \\sum_{i=1}^{T} M_i \\right] = \\sum_{i=1}^{T} E[M_i] = T \\cdot E[M]$$\nwhere $M_i$ is the number of mispredictions in the $i$-th execution and $E[M]$ is the expected number of mispredictions in any single execution. We must now calculate $E[M]$.\n\nA single execution path is determined by the outcome of the initial forward conditional branch. We analyze the mispredictions in each of the two possible scenarios.\n\n**Scenario 1: The error predicate is false.**\nThis event occurs with probability $1-p$.\n- **Forward Branch Analysis:**\n    - The branch is a **forward** branch.\n    - Under the BTFNT rule, the prediction is **Not Taken**.\n    - The actual outcome is **Not Taken** because the predicate is false.\n    - The prediction matches the outcome. The number of mispredictions for this branch is $0$.\n- **Loop Analysis:**\n    - Since the forward branch is not taken, control flow does not enter the error-handling loop.\n    - The backward branch within the loop is never executed.\n    - The number of mispredictions from the loop is $0$.\n- **Total Mispredictions in Scenario 1:** The total number of mispredictions in this scenario is $0 + 0 = 0$.\n\n**Scenario 2: The error predicate is true.**\nThis event occurs with probability $p$.\n- **Forward Branch Analysis:**\n    - The branch is a **forward** branch.\n    - The BTFNT prediction is **Not Taken**.\n    - The actual outcome is **Taken** because the predicate is true, transferring control to the loop.\n    - The prediction does not match the outcome. This constitutes a **misprediction**. The number of mispredictions for this branch is $1$.\n- **Loop Analysis:**\n    - Control enters the error-handling loop. The loop contains a single **backward** conditional branch that is executed $N$ times, where $N \\geq 1$.\n    - For a backward branch, the BTFNT prediction is always **Taken**.\n    - The actual outcome of this branch is 'Taken' for the first $N-1$ iterations to continue the loop, and 'Not Taken' on the final, $N$-th iteration to exit the loop.\n    - For the first $N-1$ iterations: Prediction = Taken, Actual = Taken. This results in $N-1$ correct predictions.\n    - For the $N$-th iteration: Prediction = Taken, Actual = Not Taken. This results in $1$ **misprediction**.\n    - The total number of mispredictions from the loop, given that it is entered, is exactly $1$.\n- **Total Mispredictions in Scenario 2:** The total number of mispredictions is the sum from the forward branch and the loop: $1 + 1 = 2$.\n\nNow, we can calculate the expected number of mispredictions for a single execution, $E[M]$, using the law of total expectation. The value of $M$ is a random variable which takes the value $0$ with probability $1-p$ and the value $2$ with probability $p$.\n$$E[M] = (0 \\times P(\\text{Scenario 1})) + (2 \\times P(\\text{Scenario 2}))$$\n$$E[M] = 0 \\cdot (1-p) + 2 \\cdot p = 2p$$\n\nFinally, we compute the expected total number of mispredictions over $T$ independent executions.\n$$E[M_{total}] = T \\cdot E[M] = T \\cdot (2p) = 2pT$$\nThis expression is the expected total number of mispredictions in terms of $p$ and $T$.",
            "answer": "$$\\boxed{2pT}$$"
        },
        {
            "introduction": "Processor performance is not determined by hardware alone; it is the result of a complex interplay with software design. This exercise explores this critical relationship by analyzing the architectural consequences of a common software refactoring choice: function inlining. You will quantify how this code transformation can inadvertently create a \"pessimal\" case for a BTFNT predictor, leading to a significant drop in performance and underscoring the need for architects and programmers to be mutually aware of each other's assumptions. ",
            "id": "3680954",
            "problem": "A single-issue scalar core uses a static predictor that implements the Backward Taken, Forward Not Taken (BTFNT) policy. The base cycles per instruction (CPI) without control hazards is $CPI_{0} = 1$. The penalty for a branch misprediction is a pipeline flush that costs $P = 8$ cycles. In a hot loop, the conditional branch density is $f_{b} = 0.20$ branches per instruction. Under the original, out-of-line error handling organization, the conditional branches encountered in the loop are distributed and behave as follows:\n- A fraction $p_{\\text{loop}} = 0.50$ are backward loop-closing branches whose actual taken probability is $t_{\\text{loop}} = 0.90$.\n- A fraction $p_{\\text{err}} = 0.30$ are forward branches to out-of-line error handling sites whose actual taken probability is $t_{\\text{err,orig}} = 0.02$.\n- The remaining fraction $p_{\\text{other}} = 0.20$ are other forward branches with actual taken probability $t_{\\text{other}} = 0.40$.\n\nA refactoring inlines the error handling into the hot path by placing a short error-handling block inline and guarding it with a forward conditional branch that skips over this block in the common case (no error). The frequency of error checks and all other branch behaviors remain unchanged, except that the inlined forward error-guard branch is now taken with probability $t_{\\text{err,new}} = 0.98$ (to skip the unlikely error block). The static predictor remains BTFNT.\n\nStarting only from the definitions of BTFNT and expected-value reasoning for prediction accuracy and cycles per instruction, and without invoking any pre-derived performance formulas, determine:\n- The drop in BTFNT prediction accuracy, $A_{\\text{drop}}$, defined as $A_{\\text{drop}} = A_{\\text{orig}} - A_{\\text{new}}$, where $A$ denotes overall prediction accuracy across all conditional branches.\n- The corresponding change in cycles per instruction, $\\Delta CPI = CPI_{\\text{new}} - CPI_{\\text{orig}}$, where $CPI$ includes the impact of mispredictions.\n\nExpress $A_{\\text{drop}}$ as a pure decimal (not a percentage) and $\\Delta CPI$ in cycles per instruction. Round both quantities to four significant figures.",
            "solution": "The Backward Taken, Forward Not Taken (BTFNT) policy predicts any backward branch as taken and any forward branch as not taken. For any branch class with actual taken probability $t$, BTFNT accuracy is:\n- For a backward branch: predict taken, so accuracy is $t$ (correct when actually taken).\n- For a forward branch: predict not taken, so accuracy is $1 - t$ (correct when actually not taken).\n\nOverall prediction accuracy across heterogeneous branch classes is the expected value of per-branch accuracy weighted by the fraction of branches in each class. Let $A_{\\text{orig}}$ denote the original (pre-inlining) accuracy and $A_{\\text{new}}$ the post-inlining accuracy.\n\nCompute $A_{\\text{orig}}$ by summing the contributions:\n- Backward loop branches: fraction $p_{\\text{loop}} = 0.50$, accuracy $t_{\\text{loop}} = 0.90$, contribution $0.50 \\times 0.90 = 0.45$.\n- Forward error branches (out-of-line): fraction $p_{\\text{err}} = 0.30$, forward prediction not taken; accuracy $1 - t_{\\text{err,orig}} = 1 - 0.02 = 0.98$, contribution $0.30 \\times 0.98 = 0.294$.\n- Other forward branches: fraction $p_{\\text{other}} = 0.20$, forward prediction not taken; accuracy $1 - t_{\\text{other}} = 1 - 0.40 = 0.60$, contribution $0.20 \\times 0.60 = 0.12$.\n\nTherefore,\n$$\nA_{\\text{orig}} = 0.45 + 0.294 + 0.12 = 0.864.\n$$\n\nAfter inlining, the only change is in the behavior of the error-related forward branches: they remain forward but are now taken with probability $t_{\\text{err,new}} = 0.98$ (since the common-case branch skips over the inlined unlikely error block). Under BTFNT, a forward branch is predicted not taken, so the accuracy on this class becomes $1 - t_{\\text{err,new}} = 1 - 0.98 = 0.02$. The other classes are unchanged.\n\nThus,\n- Backward loop branches: contribution unchanged, $0.50 \\times 0.90 = 0.45$.\n- Forward error branches (inlined): contribution $0.30 \\times 0.02 = 0.006$.\n- Other forward branches: contribution unchanged, $0.20 \\times 0.60 = 0.12$.\n\nTherefore,\n$$\nA_{\\text{new}} = 0.45 + 0.006 + 0.12 = 0.576.\n$$\n\nThe accuracy drop is\n$$\nA_{\\text{drop}} = A_{\\text{orig}} - A_{\\text{new}} = 0.864 - 0.576 = 0.288.\n$$\n\nNext, compute the change in cycles per instruction. By definition, total cycles per instruction can be decomposed as the base term plus the expected extra cycles from branch mispredictions. Let $CPI_{0} = 1$ be the base cycles per instruction without control hazards, $f_{b} = 0.20$ the branch frequency in branches per instruction, and $P = 8$ the misprediction penalty in cycles. The misprediction rate per branch is $1 - A$. Hence, the expected extra cycles per instruction due to mispredictions is $f_{b} \\times P \\times (1 - A)$.\n\nOriginal:\n$$\nCPI_{\\text{orig}} = CPI_{0} + f_{b} \\times P \\times (1 - A_{\\text{orig}}) = 1 + 0.20 \\times 8 \\times (1 - 0.864).\n$$\nCompute the term $1 - A_{\\text{orig}}$:\n$$\n1 - A_{\\text{orig}} = 1 - 0.864 = 0.136.\n$$\nThen\n$$\nCPI_{\\text{orig}} = 1 + 0.20 \\times 8 \\times 0.136 = 1 + 8 \\times 0.0272 = 1 + 0.2176 = 1.2176.\n$$\n\nNew:\n$$\nCPI_{\\text{new}} = CPI_{0} + f_{b} \\times P \\times (1 - A_{\\text{new}}) = 1 + 0.20 \\times 8 \\times (1 - 0.576).\n$$\nCompute the term $1 - A_{\\text{new}}$:\n$$\n1 - A_{\\text{new}} = 1 - 0.576 = 0.424.\n$$\nThen\n$$\nCPI_{\\text{new}} = 1 + 0.20 \\times 8 \\times 0.424 = 1 + 8 \\times 0.0848 = 1 + 0.6784 = 1.6784.\n$$\n\nTherefore, the change in cycles per instruction is\n$$\n\\Delta CPI = CPI_{\\text{new}} - CPI_{\\text{orig}} = 1.6784 - 1.2176 = 0.4608.\n$$\n\nRounding both quantities to four significant figures yields:\n$$\nA_{\\text{drop}} = 0.2880, \\quad \\Delta CPI = 0.4608.\n$$",
            "answer": "$$\\boxed{\\begin{pmatrix}0.2880  0.4608\\end{pmatrix}}$$"
        }
    ]
}