{
    "hands_on_practices": [
        {
            "introduction": "理想的流水线能够将指令执行时间缩短至单个周期的水平，但现实世界中的数据依赖性会阻止我们达到这一目标。此练习将引导您从第一性原理出发，为数据冒险（data hazards）造成的性能损失建立一个基本模型。您将学习如何将单个指令发生停顿的微观概率（$p_d$）与处理器的宏观性能指标（如每指令周期数 $CPI$ 和加速比 $S$）联系起来 ()。",
            "id": "3666173",
            "problem": "一个标量、顺序处理器实现了一个具有操作数前推（也称为旁路）的 $s$ 级平衡流水线。每个阶段的延迟为 $t$，因此流水线时钟周期为 $t$。不存在结构冒险和控制冒险。可能会发生数据冒险：在一个包含 $N$ 条指令的长循环中，对于每条动态指令，存在一个独立的概率 $p_d$，即写后读依赖不能被前推完全覆盖，并将在相关指令可以发射前导致恰好一个停顿周期。\n\n仅使用平均性能指标和极限的基本定义，完成以下任务：\n\n- 从基本原理出发，推导流水线处理器的预期每指令周期数 (CPI)，用 $p_d$ 表示。\n- 以一个非流水线基线作为参照，该基线是同一数据通路的多周期实现，它在 $s$ 个持续时间为 $t$ 的周期内完成每条指令（即其 CPI 为 $s$，周期时间为 $t$），计算当 $N \\to \\infty$ 时，该循环在非流水线机器上与在流水线机器上的总执行时间之比所定义的加速比 $S$。\n\n将最终的加速比 $S$ 表示为包含 $s$ 和 $p_d$ 的闭式解析表达式。仅报告加速比 $S$ 作为最终答案。无需四舍五入。",
            "solution": "该问题被评估为有效。它在科学上基于计算机体系结构的原理，问题提出得当，信息充分且一致，并且陈述客观。该问题要求从基本原理出发推导处理器性能指标，这是该领域一个标准的、可形式化的任务。\n\n按照要求，分析分两部分进行：首先，推导流水线处理器的预期每指令周期数 (CPI)；其次，计算加速比 $S$。\n\n首先，我们推导流水线处理器的预期 CPI，记为 $CPI_{pipe}$。CPI 定义为执行一条指令所需的平均时钟周期数。它可以表示为理想流水线的 CPI 与每条指令的平均停顿周期数之和。\n$$\nCPI_{pipe} = CPI_{ideal} + CPI_{stalls}\n$$\n对于在稳态下运行的理想标量流水线（鉴于问题中 $N \\to \\infty$ 的长循环条件，这是一个有效的假设），每个时钟周期完成一条指令。因此，理想 CPI 为 $1$。\n$$\nCPI_{ideal} = 1\n$$\n问题指出，性能下降的唯一来源是导致停顿的数据冒险。对于任何给定的指令，有 $p_d$ 的概率会导致恰好一个停顿周期。其他指令导致零个停顿周期。停顿对 CPI 的贡献，$CPI_{stalls}$，是每条指令的预期停顿周期数。这是通过将停顿事件的概率乘以每次停顿的周期数来计算的。\n$$\nCPI_{stalls} = (\\text{Probability of stall}) \\times (\\text{Stall cycles per event})\n$$\n给定停顿概率为 $p_d$，持续时间为 $1$ 个周期，我们有：\n$$\nCPI_{stalls} = p_d \\times 1 = p_d\n$$\n结合这些结果，流水线处理器的预期 CPI 为：\n$$\nCPI_{pipe} = CPI_{ideal} + CPI_{stalls} = 1 + p_d\n$$\n接下来，我们计算加速比 $S$。加速比定义为非流水线基线机器的总执行时间与流水线机器的总执行时间之比。\n$$\nS = \\frac{T_{unpipelined}}{T_{pipelined}}\n$$\n一个包含 $N$ 条指令的程序的总执行时间 ($T$) 由通用性能方程给出：\n$$\nT = N \\times CPI \\times \\tau\n$$\n其中 $N$ 是指令数，CPI 是每指令周期数，$\\tau$ 是时钟周期时间。我们考虑 $N \\to \\infty$ 的极限情况，这使我们可以忽略填充和排空流水线的瞬态效应，因为与随 $N$ 线性增长的项相比，这些常数项变得可以忽略不计。\n\n对于非流水线基线机器：\n指令数为 $N$。\nCPI 给定为 $s$，所以 $CPI_{unpipe} = s$。\n周期时间给定为 $t$，所以 $\\tau_{unpipe} = t$。\n因此，执行时间为：\n$$\nT_{unpipelined} = N \\times CPI_{unpipe} \\times \\tau_{unpipe} = N \\times s \\times t\n$$\n\n对于流水线机器：\n指令数为 $N$。\nCPI 在上面被推导为 $CPI_{pipe} = 1 + p_d$。\n周期时间给定为 $t$，所以 $\\tau_{pipe} = t$。\n因此，执行时间为：\n$$\nT_{pipelined} = N \\times CPI_{pipe} \\times \\tau_{pipe} = N \\times (1 + p_d) \\times t\n$$\n\n现在，我们可以通过将这些执行时间表达式代入加速比公式来计算加速比 $S$：\n$$\nS = \\frac{T_{unpipelined}}{T_{pipelined}} = \\frac{N \\times s \\times t}{N \\times (1 + p_d) \\times t}\n$$\n指令数 $N$ 和时钟周期时间 $t$ 的项在分子和分母中被抵消。这就得出了加速比的最终表达式：\n$$\nS = \\frac{s}{1 + p_d}\n$$\n该表达式将加速比表示为流水线级数 $s$ 和数据冒险停顿概率 $p_d$ 的函数。流水线的理想加速比为 $s$，这是在没有停顿（$p_d = 0$）时实现的。分母中的项 $1 + p_d$ 表示由停顿引起的性能惩罚因子。",
            "answer": "$$\n\\boxed{\\frac{s}{1 + p_d}}\n$$"
        },
        {
            "introduction": "除了数据冒险，控制冒险（control hazards）是限制流水线性能的另一个主要因素，它主要由分支预测失败引起。这个练习旨在量化分支预测错误对吞吐量的影响，并引入弹性（elasticity）这一分析工具来评估优化方向。通过这个练习，您将能深入理解在降低预测错误率（$m$）与减少预测惩罚（$P$）这两种设计权衡之间，何者能带来更大的性能收益 ()。",
            "id": "3666158",
            "problem": "一个单发射、顺序流水线在没有冒险的情况下每个周期执行一条指令，因此其理想的每指令周期数（CPI）为 $1$，理想的每周期指令数（IPC）也为 $1$。考虑由条件分支引起的控制冒险。分支预测错误的模型如下：对于每条完成的指令，都以概率 $m$ 独立地发生一次分支预测错误，该错误会导致 $P$ 个额外周期的停顿。假设这些停顿在不同的预测错误之间不会重叠，并且不会改变正确预测的分支或非分支指令的基本成本。设 $m \\in (0,1)$ 且 $P \\in \\mathbb{N}$，$P \\ge 1$。\n\n仅使用期望值、每指令周期数和每周期指令数（IPC）的定义，完成以下任务：\n\n- 推导以 $m$ 和 $P$ 表示的期望每指令周期数，然后推导由此产生的 IPC。\n- 通过表示相对于理想情况的吞吐率比，将推导出的 IPC 与理想 IPC $1$ 进行比较。\n- 为了分析改善预测错误率与惩罚的边际效益，定义 IPC 相对于变量 $x$ 的弹性为 $E_{x} \\triangleq \\left(\\frac{\\partial \\text{IPC}}{\\partial x}\\right)\\left(\\frac{x}{\\text{IPC}}\\right)$。计算 IPC 相对于 $m$ 和 $P$ 的弹性大小之比，即 $\\left|\\frac{E_{m}}{E_{P}}\\right|$，并将其简化为一个实数。\n\n最终答案只提供 $\\left|\\frac{E_{m}}{E_{P}}\\right|$ 的值。无需四舍五入，最终值也无需单位。",
            "solution": "首先根据指定标准验证问题陈述。\n\n### 第 1 步：提取已知条件\n- 一个单发射、顺序流水线的理想每指令周期数（CPI）为 $1$，理想每周期指令数（IPC）也为 $1$。\n- 对于每条完成的指令，发生一次分支预测错误的独立概率为 $m$。\n- 一次分支预测错误导致 $P$ 个额外周期的停顿。\n- 预测错误造成的停顿不重叠。\n- 正确预测的分支或非分支指令的基本成本为 $1$ 个周期。\n- $m \\in (0,1)$。\n- $P \\in \\mathbb{N}$ 且 $P \\ge 1$。\n- IPC 相对于变量 $x$ 的弹性定义为 $E_{x} \\triangleq \\left(\\frac{\\partial \\text{IPC}}{\\partial x}\\right)\\left(\\frac{x}{\\text{IPC}}\\right)$。\n- 目标是计算 $\\left|\\frac{E_{m}}{E_{P}}\\right|$。\n\n### 第 2 步：使用提取的已知条件进行验证\n根据提供的标准对问题进行评估：\n- **科学性**：该问题使用一个标准的简化模型来分析由控制冒险（分支预测错误）引起的流水线性能下降。CPI、IPC、预测错误率（$m$）和预测错误惩罚（$P$）等概念是计算机体系结构中的基本概念。该概率模型是性能分析中常用且有效的抽象。\n- **适定性**：该问题提供了所有必要的信息和定义。变量 $m$ 和 $P$ 及其定义域都已明确。事件（预测错误）与其成本（停頓周期）之间的关系已清楚说明。目标是基于所提供的弹性定义进行精确的数学计算。可以推导出唯一、稳定且有意义的解。\n- **客观性**：该问题使用工程和应用数学中常见的精确、正式且无偏见的语言进行陈述。\n\n该问题不存在说明中列出的任何缺陷（例如，科学上不合理、不完整、模棱两可）。这是计算机组成与体系结构领域一个定义明确的问题。\n\n### 第 3 步：结论与行动\n该问题有效。将提供完整的解答。\n\n### 解答推导\n解答过程首先推导期望的每指令周期数（CPI），然后推导每周期指令数（IPC），最后计算所需的弹性比率。\n\n设 $C$ 为执行单条指令所需周期数的随机变量。根据问题陈述，如果没有发生预测错误，一条指令在 $1$ 个周期内完成；如果发生预测错误，则在 $1+P$ 个周期内完成。预测错误的概率为 $m$。\n\n$C$ 的概率分布为：\n- $P(C=1) = 1-m$（无预测错误）\n- $P(C=1+P) = m$（预测错误）\n\n期望的每指令周期数，记为 $\\text{CPI}_{\\text{actual}}$，是 $C$ 的期望值：\n$$\n\\text{CPI}_{\\text{actual}} = E[C] = (1) \\cdot P(C=1) + (1+P) \\cdot P(C=1+P)\n$$\n$$\n\\text{CPI}_{\\text{actual}} = (1)(1-m) + (1+P)(m)\n$$\n$$\n\\text{CPI}_{\\text{actual}} = 1 - m + m + mP\n$$\n$$\n\\text{CPI}_{\\text{actual}} = 1 + mP\n$$\n\n每周期指令数（IPC）是 CPI 的倒数。\n$$\n\\text{IPC} = \\frac{1}{\\text{CPI}_{\\text{actual}}} = \\frac{1}{1+mP}\n$$\n\n相对于理想 IPC $1$ 的吞吐率比为：\n$$\n\\frac{\\text{IPC}_{\\text{actual}}}{\\text{IPC}_{\\text{ideal}}} = \\frac{\\frac{1}{1+mP}}{1} = \\frac{1}{1+mP}\n$$\n\n接下来，我们计算 IPC 相对于 $m$ 和 $P$ 的弹性。弹性的定义是 $E_{x} = \\left(\\frac{\\partial \\text{IPC}}{\\partial x}\\right)\\left(\\frac{x}{\\text{IPC}}\\right)$。我们的函数是 $\\text{IPC}(m, P) = (1+mP)^{-1}$。\n\n首先，我们计算相对于 $m$ 的弹性 $E_m$。我们需要 IPC 相对于 $m$ 的偏导数：\n$$\n\\frac{\\partial \\text{IPC}}{\\partial m} = \\frac{\\partial}{\\partial m} (1+mP)^{-1}\n$$\n使用链式法则，我们得到：\n$$\n\\frac{\\partial \\text{IPC}}{\\partial m} = -1 \\cdot (1+mP)^{-2} \\cdot \\frac{\\partial}{\\partial m}(1+mP) = -1 \\cdot (1+mP)^{-2} \\cdot P = \\frac{-P}{(1+mP)^2}\n$$\n现在，我们应用弹性公式：\n$$\nE_m = \\left(\\frac{\\partial \\text{IPC}}{\\partial m}\\right)\\left(\\frac{m}{\\text{IPC}}\\right) = \\left(\\frac{-P}{(1+mP)^2}\\right) \\left(\\frac{m}{\\frac{1}{1+mP}}\\right)\n$$\n$$\nE_m = \\left(\\frac{-P}{(1+mP)^2}\\right) \\cdot m(1+mP) = \\frac{-mP(1+mP)}{(1+mP)^2}\n$$\n$$\nE_m = \\frac{-mP}{1+mP}\n$$\n\n接下来，我们计算相对于 $P$ 的弹性 $E_P$。我们需要 IPC 相对于 $P$ 的偏导数：\n$$\n\\frac{\\partial \\text{IPC}}{\\partial P} = \\frac{\\partial}{\\partial P} (1+mP)^{-1}\n$$\n使用链式法则：\n$$\n\\frac{\\partial \\text{IPC}}{\\partial P} = -1 \\cdot (1+mP)^{-2} \\cdot \\frac{\\partial}{\\partial P}(1+mP) = -1 \\cdot (1+mP)^{-2} \\cdot m = \\frac{-m}{(1+mP)^2}\n$$\n现在，我们应用弹性公式：\n$$\nE_P = \\left(\\frac{\\partial \\text{IPC}}{\\partial P}\\right)\\left(\\frac{P}{\\text{IPC}}\\right) = \\left(\\frac{-m}{(1+mP)^2}\\right) \\left(\\frac{P}{\\frac{1}{1+mP}}\\right)\n$$\n$$\nE_P = \\left(\\frac-m}{(1+mP)^2}\\right) \\cdot P(1+mP) = \\frac{-mP(1+mP)}{(1+mP)^2}\n$$\n$$\nE_P = \\frac{-mP}{1+mP}\n$$\n\n我们发现 $E_m$ 和 $E_P$ 是相同的：\n$$\nE_m = E_P = \\frac{-mP}{1+mP}\n$$\n\n最后一步是计算它们大小的比值。由于 $m \\in (0,1)$ 且 $P \\ge 1$，表达式 $\\frac{-mP}{1+mP}$ 是良定义且非零的。\n$$\n\\left|\\frac{E_{m}}{E_{P}}\\right| = \\left|\\frac{\\frac{-mP}{1+mP}}{\\frac{-mP}{1+mP}}\\right|\n$$\n由于分子和分母相同且非零，它们的比值为 $1$。\n$$\n\\left|\\frac{E_{m}}{E_{P}}\\right| = |1| = 1\n$$\n这个结果表明，在此模型中，对于给定的预测错误率（$m$）的百分比变化，IPC 的百分比变化在大小上等于对于相同的预测错误惩罚（$P$）的百分比变化，IPC 的百分比变化。",
            "answer": "$$\\boxed{1}$$"
        },
        {
            "introduction": "在分析了数据和控制冒险带来的问题之后，现在让我们转向一个主动的解决方案。本练习将您置于编译器的角色，面对一个经典的5级RISC流水线和一个常见的“加载-使用”代码模式。您的任务是通过指令重排序来完全消除由数据依赖性引起的停顿，这充分展示了理解硬件细节对于软件优化的巨大价值，是连接理论与实践的桥梁 ()。",
            "id": "3666138",
            "problem": "一个 $5$ 级精简指令集计算机 (RISC) 流水线按顺序实现以下阶段：指令获取 (IF)、指令解码和寄存器读取 (ID)、执行或地址计算 (EX)、内存访问 (MEM) 以及写回 (WB)。该处理器是单发射和顺序执行的。每个流水线阶段恰好占用 $1$ 个周期。数据路径支持从 EX/MEM 和 MEM/WB 流水线寄存器到 EX 的完全转发 (也称旁路)，并且冒险检测仅在为保持正确性所必需时才插入停顿。所有数据内存访问都是缓存命中，并在 MEM 阶段用 $1$ 个周期完成。不存在结构冒险和控制冒险。加载指令产生的值仅在其 MEM 阶段完成后才可用于转发；因此，紧跟在加载指令后的相关算术指令需要恰好 $1$ 个停顿周期，而在加载指令与其相关的算术指令之间放置至少 $1$ 条无关指令则可以消除该停顿。\n\n考虑一个线性基本块，它由 $M$ 次重复的交替加载和使用模式组成，其中 $M \\ge 2$，且各对之间没有依赖关系。对于每个 $i \\in \\{1,2,\\dots,M\\}$，该对指令为：\n- 加载：$\\mathrm{LD}\\ r_i \\leftarrow \\mathrm{Mem}[a_i]$，\n- 使用：$\\mathrm{ADD}\\ u_i \\leftarrow r_i + c_i$，\n其中，对于不同的 $i$，$r_i$ 和 $u_i$ 均不相同，所有地址 $a_i$ 均不相同，并且每个 $c_i$ 独立于所有的 $r_j$。编译器可以任意重排指令，只要对于每个 $i$，使用 $r_i$ 的 $\\mathrm{ADD}$ 指令出现在其相应的 $\\mathrm{LD}$ 指令之后。\n\n从每指令周期数 (CPI) 的定义和单发射 $k$ 级流水线的基本行为出发，推导当使用最优软件调度和完全转发时，该代码块可实现的最小平均 CPI。您的推导必须明确考虑流水线填充和排空效应。请将您的最终答案表示为仅含 $M$ 的单个闭式表达式。不需要四舍五入，CPI 是无单位的。",
            "solution": "问题要求计算在特定的 $5$ 级 RISC 流水线上，给定代码块可实现的最小平均每指令周期数 (CPI)。\n\n平均 CPI 的定义是总执行周期数除以总指令数。\n$$\n\\text{CPI} = \\frac{\\text{总周期数}}{\\text{总指令数}}\n$$\n该代码块由 $M$ 对加载 ($\\mathrm{LD}$) 和相关的加法 ($\\mathrm{ADD}$) 指令组成。因此，总指令数 $N_{\\text{instr}}$ 为 $2M$。\n$$\nN_{\\text{instr}} = 2M\n$$\n为了找到最小 CPI，我们必须找到执行这 $2M$ 条指令所需的最少总周期数。这可以通过找到一个能最大限度减少流水线停顿的最优指令调度来实现。\n\n该流水线有 $k=5$ 个阶段：IF、ID、EX、MEM、WB。每个阶段占用 $1$ 个周期。流水线是单发射和顺序的。支持完全转发。关键的性能约束是加载指令与其结果使用指令之间的数据冒险。问题指出，加载指令的值仅在其 MEM 阶段完成后才可用于转发。算术指令（如 $\\mathrm{ADD}$）在其 EX 阶段需要其操作数。\n\n让我们分析一下没有任何调度的一对加载-使用指令的时序：\n$\\mathrm{LD}\\ r_i, \\dots$\n$\\mathrm{ADD}\\ u_i, r_i, \\dots$\n\n假设 $\\mathrm{LD}$ 指令在周期 $t$ 进入 IF 阶段。\n- 周期 $t$：$\\mathrm{LD}$ 在 IF 阶段\n- 周期 $t+1$：$\\mathrm{LD}$ 在 ID 阶段，$\\mathrm{ADD}$ 在 IF 阶段\n- 周期 $t+2$：$\\mathrm{LD}$ 在 EX 阶段，$\\mathrm{ADD}$ 在 ID 阶段\n- 周期 $t+3$：$\\mathrm{LD}$ 在 MEM 阶段，$\\mathrm{ADD}$ 在 EX 阶段\n\n在周期 $t+3$ 开始时，$\\mathrm{ADD}$ 指令处于其 EX 阶段，需要寄存器 $r_i$ 的值。$\\mathrm{LD}$ 指令处于其 MEM 阶段，并只会在周期 $t+3$ 结束时产生这个值。该值被写入 MEM/WB 流水线寄存器，并在周期 $t+4$ 开始时可用于转发。因此，存在数据冒险。冒险检测逻辑必须将 $\\mathrm{ADD}$ 指令在流水线中停顿一个周期。\n\n带停顿的正确执行过程：\n- 周期 $t+3$：$\\mathrm{LD}$ 在 MEM 阶段，$\\mathrm{ADD}$ 被停顿 (保持在 ID 阶段)。\n- 周期 $t+4$：$\\mathrm{LD}$ 在 WB 阶段，$\\mathrm{ADD}$ 进入 EX 阶段。$r_i$ 的值从现已填充的 MEM/WB 寄存器转发到 EX 阶段。\n这证实了问题陈述，即紧跟在加载指令后的相关指令需要 $1$ 个周期的停顿。\n\n问题还指出，在加载指令和其相关的使​​用指令之间放置至少 $1$ 条无关指令可以消除此停顿。编译器可以重排指令，唯一的约束是对于每个配对 $i$，$\\mathrm{LD}_i$ 必须在其相应的 $\\mathrm{ADD}_i$ 之前。\n\n为了最小化总周期数，我们必须找到一个能消除所有这类停顿的调度。一个最优策略是重排指令，以最大化每个 $\\mathrm{LD}_i$ 与其相关的 $\\mathrm{ADD}_i$ 之间的距离。由于所有加载指令彼此独立（它们写入不同的寄存器 $r_i$），并且所有加法指令也彼此独立（它们写入不同的寄存器 $u_i$），一个有效且高效的调度是先将所有加载指令分组在一起，然后是所有的加法指令。\n\n提出的最优调度是：\n$L_1, L_2, \\dots, L_M, A_1, A_2, \\dots, A_M$\n其中 $L_i$ 表示 $\\mathrm{LD}\\ r_i \\leftarrow \\mathrm{Mem}[a_i]$，$A_i$ 表示 $\\mathrm{ADD}\\ u_i \\leftarrow r_i + c_i$。\n\n让我们验证对于 $M \\ge 2$ 的情况，该调度是无停顿的。在此序列中，前 $M$ 条加载指令之间没有数据依赖关系，因此它们可以背靠背地发射而无需停顿。后续的加法指令可能依赖于加载指令。考虑第 $i$ 条加法指令 $A_i$。它是序列中的第 $(M+i)$ 条指令。它依赖于第 $i$ 条加载指令 $L_i$ 的结果。\n\n- 指令 $L_i$ 在周期 $i$ 进入流水线。它的值在其 MEM 阶段结束时产生，这发生在周期 $i + (4-1) = i+3$。结果从周期 $i+4$ 开始可用于转发。\n- 指令 $A_i$ 在周期 $M+i$ 进入流水线。它在周期 $(M+i) + (3-1) = M+i+2$ 到达其 EX 阶段。\n\n为了让 $A_i$ 无停顿地执行，其 EX 阶段的开始时间不能早于 $L_i$ 的结果可用于转发的时间。这给出了条件：\n$$\nA_i \\text{ 的 EX 阶段开始时间} \\ge L_i \\text{ 的结果可用时的周期开始时间}\n$$\n$$\nM + i + 2 \\ge i + 4\n$$\n$$\nM \\ge 2\n$$\n题目规定 $M \\ge 2$。因此，对于所有的配对 $(L_i, A_i)$，这个条件都满足。这证明了所提出的先执行所有加载指令再执行所有加法指令的调度是完全无停顿的。\n\n既然我们找到了一个零停顿的调度，这就代表了最小的执行时间。对于一个由 $N_{\\text{instr}}$ 条指令组成的序列，在一个 $k$ 级流水线上无停顿地执行，其总周期数由填充流水线所需的周期数和发射剩余指令所需的周期数之和给出。第一条指令需要 $k$ 个周期完成。随后的 $N_{\\text{instr}}-1$ 条指令以每周期一条的速率完成。\n$$\n\\text{总周期数} = k + (N_{\\text{instr}} - 1) = k - 1 + N_{\\text{instr}}\n$$\n对于本题，流水线深度 $k=5$，总指令数 $N_{\\text{instr}} = 2M$。\n代入这些值，最小总周期数为：\n$$\n\\text{总周期数}_{\\text{min}} = (5 - 1) + 2M = 4 + 2M\n$$\n现在我们可以根据定义计算最小平均 CPI：\n$$\n\\text{CPI}_{\\text{min}} = \\frac{\\text{总周期数}_{\\text{min}}}{N_{\\text{instr}}} = \\frac{4 + 2M}{2M}\n$$\n简化该表达式可得：\n$$\n\\text{CPI}_{\\text{min}} = \\frac{4}{2M} + \\frac{2M}{2M} = \\frac{2}{M} + 1\n$$\n这就是以 $M$ 表示的最小平均 CPI 的最终闭式表达式。",
            "answer": "$$\n\\boxed{1 + \\frac{2}{M}}\n$$"
        }
    ]
}