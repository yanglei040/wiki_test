{
    "hands_on_practices": [
        {
            "introduction": "Understanding pipeline stalls begins with quantifying the delay needed for a single data dependency. This exercise guides you through deriving a general formula for the number of stall cycles based on the concept of execution latency, $L$. By analyzing a simple 'triangular' dependency pattern (), you will establish the fundamental relationship between required latency and inserted stalls, a cornerstone of pipeline performance analysis.",
            "id": "3647186",
            "problem": "Consider an in-order, single-issue Reduced Instruction Set Computer (RISC) pipeline with $5$ classic stages: Instruction Fetch (IF), Instruction Decode and Register Read (ID), Execute (EX), Memory (MEM), and Write Back (WB). Each stage takes $1$ cycle, register operands are read in the ID stage, and results are written to the register file in the WB stage. A hazard detection unit enforces Read After Write (RAW) safety by stalling in the ID stage whenever an operand needed by the instruction at ID will not be available by the time that instruction would start EX. When a stall is asserted in ID, younger instructions behind it in the pipeline do not advance. There are no structural hazards and no control hazards.\n\nAssume the bypass (forwarding) network is fully capable of forwarding values from earlier producers to later consumers except that there is no forwarding path from instruction $I_2$ to instruction $I_3$ in the specific scenario described below. Let $L_x$ and $L_y$ be defined as follows (each measured in cycles as an EX-to-EX separation):\n\n- $L_x$ is the minimum separation (in cycles) required between the start of $I_1$'s EX stage and the start of $I_2$'s EX stage so that operand $x$ produced by $I_1$ is available to $I_2$ in its EX stage inputs via the existing forwarding paths between $I_1$ and $I_2$.\n- $L_y$ is the minimum separation (in cycles) required between the start of $I_2$'s EX stage and the start of $I_3$'s EX stage so that operand $y$ produced by $I_2$ is available to $I_3$ without relying on any forwarding from $I_2$ (i.e., $I_3$ must obtain $y$ from the register file; the hazard detection unit must ensure this by stalling as needed).\n\nNow consider the following three-instruction triangular dependency pattern:\n- $I_1$: produces $x$ into destination register $rd$,\n- $I_2$: reads $x$ and produces $y$,\n- $I_3$: reads $y$.\n\nAssume that, absent data hazards, the machine issues one instruction per cycle such that, by default, starts of EX for consecutive instructions are separated by $1$ cycle. The hazard detection unit inserts the minimum number of stall cycles necessary to preserve correctness, and instructions issue as early as correctness allows.\n\nDerive a closed-form analytic expression for the total number of stall cycles inserted across this three-instruction sequence as a function of $L_x$ and $L_y$. Express your final answer as a single closed-form expression in terms of $L_x$ and $L_y$. No numerical evaluation is required and no rounding applies.",
            "solution": "The problem statement provides a well-defined scenario within the canonical model of a 5-stage RISC pipeline. All parameters and constraints are scientifically grounded in the principles of computer organization and architecture, and the problem is self-contained, consistent, and objective. Therefore, the problem is deemed valid and a formal solution can be constructed.\n\nThe core task is to determine the total number of stall cycles inserted by the hazard detection unit for a specific three-instruction sequence with two sequential Read-After-Write (RAW) data dependencies. A stall cycle is a single-cycle bubble inserted into the pipeline to resolve a hazard. For an in-order pipeline, a stall occurs when an instruction in the Instruction Decode (ID) stage cannot advance to the Execute (EX) stage.\n\nLet us analyze the timing of the pipeline. In an ideal instruction flow without hazards, each instruction advances one stage per cycle. Instructions $I_1$, $I_2$, and $I_3$ would enter the EX stage in three consecutive cycles. This establishes a default EX-to-EX separation of $1$ cycle between consecutive instructions.\n\nA data hazard between a producer instruction $I_p$ and a consumer instruction $I_c$ is characterized by a required latency, $L$, which represents the minimum number of cycles that must separate the start of $I_p$'s EX stage and the start of $I_c$'s EX stage for the data to be correctly available.\n\nThe number of stall cycles, $S$, required for a single dependency is the number of additional cycles the consumer instruction must be held in its ID stage beyond the default flow. The actual separation must be at least $L$, while the default separation is $1$. The relationship is:\n$$1 + S \\ge L$$\nSince the hazard detection unit inserts the *minimum* number of stalls, we have $1 + S = L$, or $S = L-1$. However, if the required latency $L$ is less than or equal to the default separation of $1$ cycle ($L \\le 1$), no stall is necessary. Therefore, the number of stall cycles for a single dependency with latency $L$ is:\n$$S = \\max(0, L-1)$$\n\nWe now apply this principle to the two dependencies in the sequence.\n\nFirst dependency: $I_1 \\to I_2$\n- $I_1$ produces operand $x$.\n- $I_2$ consumes operand $x$.\n- The required EX-to-EX separation is given as $L_x$.\nThe number of stall cycles, $S_{12}$, inserted while $I_2$ is in the ID stage to wait for $I_1$ is:\n$$S_{12} = \\max(0, L_x - 1)$$\nThese $S_{12}$ stall cycles delay not only $I_2$ but also the subsequent instruction $I_3$, which is held in the Instruction Fetch (IF) stage during this time.\n\nSecond dependency: $I_2 \\to I_3$\n- $I_2$ produces operand $y$.\n- $I_3$ consumes operand $y$.\n- The required EX-to-EX separation is given as $L_y$. This latency accounts for the fact that $I_3$ must retrieve the value from the register file, as there is no forwarding path from $I_2$ to $I_3$.\nAfter the $S_{12}$ stalls for the first dependency are complete, $I_2$ advances to its EX stage, and $I_3$ advances to its ID stage. At this point, the hazard detection unit evaluates the $I_2 \\to I_3$ dependency. The number of stall cycles, $S_{23}$, inserted while $I_3$ is in the ID stage to wait for $I_2$ is:\n$$S_{23} = \\max(0, L_y - 1)$$\n\nThe total number of stall cycles, $S_{total}$, is the sum of the stall cycles introduced for each hazard. Because the pipeline is in-order, the stalls are additive. The stall for the first dependency ($S_{12}$) must be fully served, which delays the arrival of $I_3$ at the ID stage. Once $I_3$ is at the ID stage, the stall for the second dependency ($S_{23}$) is then served.\n\nLet's trace the start times of the EX stages to confirm this.\nLet the EX stage for $I_1$ start at an arbitrary cycle $T$.\n$$EX_{start}(I_1) = T$$\nThe EX stage for $I_2$ must start at least $L_x$ cycles after $I_1$'s EX stage starts. Due to the pipeline structure, it also starts at least $1$ cycle after $I_1$'s EX stage. Thus:\n$$EX_{start}(I_2) = EX_{start}(I_1) + \\max(1, L_x) = T + \\max(1, L_x)$$\nSimilarly, the EX stage for $I_3$ must start at least $L_y$ cycles after $I_2$'s EX stage starts:\n$$EX_{start}(I_3) = EX_{start}(I_2) + \\max(1, L_y) = T + \\max(1, L_x) + \\max(1, L_y)$$\n\nThe total number of cycles elapsed from the start of $I_1$'s EX stage to the start of $I_3$'s EX stage is:\n$$\\Delta T = EX_{start}(I_3) - EX_{start}(I_1) = \\max(1, L_x) + \\max(1, L_y)$$\nIn an ideal pipeline with no hazards, this interval would be $2$ cycles ($I_1$ at $T$, $I_2$ at $T+1$, $I_3$ at $T+2$). The total number of stall cycles inserted is the difference between the actual interval and the ideal interval:\n$$S_{total} = \\Delta T - 2 = (\\max(1, L_x) + \\max(1, L_y)) - 2$$\nUsing the identity $\\max(a, b) = a + \\max(0, b-a)$, we can write $\\max(1, L) = 1 + \\max(0, L-1)$. Substituting this into the expression for $S_{total}$:\n$$S_{total} = (1 + \\max(0, L_x-1)) + (1 + \\max(0, L_y-1)) - 2$$\n$$S_{total} = 2 + \\max(0, L_x-1) + \\max(0, L_y-1) - 2$$\n$$S_{total} = \\max(0, L_x-1) + \\max(0, L_y-1)$$\n\nThis confirms that the total number of stall cycles is the sum of the stalls required for each individual dependency in the chain.\n\nThe final closed-form analytic expression for the total number of stall cycles as a function of $L_x$ and $L_y$ is the sum of the stalls generated by each of the two sequential dependencies.",
            "answer": "$$\\boxed{\\max(0, L_x - 1) + \\max(0, L_y - 1)}$$"
        },
        {
            "introduction": "From the general theory of stalls, we now move to a practical implementation for a common and critical case: the load-use hazard. This practice requires you to design the specific Boolean logic that a Hazard Detection Unit uses to identify this hazard in a classic 5-stage pipeline (). You will then apply your logic by tracing a code sequence, solidifying your understanding of how hardware detects and resolves dependencies in real-time.",
            "id": "3647216",
            "problem": "Consider a classic five-stage in-order, single-issue pipeline with the stages Instruction Fetch (IF), Instruction Decode and Register Fetch (ID), Execute (EX), Memory Access (MEM), and Write-back (WB). The processor implements full bypass (forwarding) paths for arithmetic logic unit outputs so that an arithmetic result produced at the end of the Execute stage can be forwarded to the next instruction’s Execute stage without introducing a stall. Loads read data from memory in the Memory Access stage and write the value to the destination register in the Write-back stage. Define the load-use latency $L$ as the number of cycles between the start of the producer instruction’s Execute stage and the earliest cycle the loaded value can be presented to a consumer instruction’s Execute stage input via forwarding; assume $L=2$ for loads in this pipeline.\n\nA hazard detection unit must assert a stall signal when the instruction in the Instruction Decode and Register Fetch stage reads either source register $rs$ or source register $rt$ that is equal to the destination register $rd$ of the instruction in the Execute stage, provided that the instruction in the Execute stage is a load. The zero register $r0$ is architecturally hard-wired to zero and writes to $r0$ have no effect; the hazard detection unit should ignore $r0$ as a destination.\n\nUsing only well-tested pipeline facts about when results become available and the definition of the load-use latency $L$, do the following:\n\n1. Derive a minimal Boolean expression for the stall signal in terms of the signals $EX_{\\text{isLoad}}$, $EX_{rd}$, $ID_{rs}$, and $ID_{rt}$, including the $r0$ special case. Your expression must be purely combinational with respect to the current cycle pipeline register contents (no counters or timers).\n\n2. Then, starting from an empty pipeline, estimate the total number of stall cycles that will be inserted when executing the following contiguous sequence of three dependent instructions, under the assumptions above and with full forwarding for arithmetic logic unit results:\n   - `LW r1, 0(r2)`\n   - `LW r3, 0(r1)`\n   - `ADD r4, r3, r5`\n\nProduce the final answer as a single real-valued number equal to the total stall cycles inserted for the three-instruction sequence. No rounding is required. No units are required in the final answer.",
            "solution": "The problem is evaluated as valid, as it is scientifically grounded in the principles of computer architecture, well-posed, and internally consistent. We can therefore proceed with a solution.\n\nThe problem is divided into two parts. First, we derive the Boolean expression for the stall signal. Second, we calculate the total number of stall cycles for a given instruction sequence.\n\n**Part 1: Derivation of the Boolean Stall Signal Expression**\n\nThe problem specifies the conditions under which the hazard detection unit must assert a stall signal. A stall is required if the instruction in the Instruction Decode (ID) stage has a source register dependency on a load instruction currently in the Execute (EX) stage. Let us formalize these conditions.\n\nThe givens for the logic expression are:\n- $EX_{\\text{isLoad}}$: A signal that is true ($1$) if the instruction in the EX stage is a load.\n- $EX_{rd}$: The destination register index for the instruction in the EX stage.\n- $ID_{rs}$: The first source register index for the instruction in the ID stage.\n- $ID_{rt}$: The second source register index for the instruction in the ID stage.\n\nThe conditions for a stall are:\n1. The instruction in the EX stage is a load instruction. This corresponds to the condition $EX_{\\text{isLoad}} = 1$.\n2. The destination register of the load instruction in the EX stage is not the zero register, $r0$. The register $r0$ corresponds to index $0$. Thus, this condition is $EX_{rd} \\neq 0$.\n3. The instruction in the ID stage uses the result of the load. This means that at least one of its source registers ($ID_{rs}$ or $ID_{rt}$) is the same as the destination register ($EX_{rd}$) of the load instruction in the EX stage. This is expressed as $(ID_{rs} = EX_{rd}) \\lor (ID_{rt} = EX_{rd})$.\n\nCombining these three conditions with a logical AND operation gives the complete expression for the stall signal, which we denote as $S$. A stall occurs if and only if all three conditions are met.\n\nTherefore, the minimal Boolean expression for the stall signal $S$ is:\n$$S = EX_{\\text{isLoad}} \\land (EX_{rd} \\neq 0) \\land ((ID_{rs} = EX_{rd}) \\lor (ID_{rt} = EX_{rd}))$$\nThis expression is minimal because it directly represents the necessary and sufficient conditions described in the problem statement, with no redundant terms.\n\n**Part 2: Calculation of Total Stall Cycles**\n\nWe are asked to calculate the total stall cycles for the following sequence of instructions:\n- `I1: LW r1, 0(r2)`\n- `I2: LW r3, 0(r1)`\n- `I3: ADD r4, r3, r5`\n\nThe pipeline has full forwarding for ALU results, meaning an ALU-ALU dependency incurs $0$ stalls. The problem defines a load-use latency $L=2$. The number of stall cycles for a load-use dependency is given by $L-1$. In this case, $L-1 = 2-1 = 1$ stall cycle. We can verify this by tracing the pipeline's execution.\n\nLet's analyze the dependencies between the instructions.\n\n**Dependency 1: $I1 \\rightarrow I2$**\n- $I1$ is `LW r1, 0(r2)`, which writes to register $r1$.\n- $I2$ is `LW r3, 0(r1)`, which reads register $r1$ to calculate its memory address.\nThis is a classic load-use data hazard. We trace the pipeline to see when the hazard is detected and a stall is inserted.\n\n| Cycle | I1: LW r1,... | I2: LW r3, 0(r1) | I3: ADD r4, r3,... | Comment |\n|---:|:---|:---|:---|:---|\n| $1$ | IF | | | $I1$ is fetched. |\n| $2$ | ID | IF | | $I2$ is fetched. |\n| $3$ | EX | ID | IF | $I3$ is fetched. Hazard detected: $I2$ needs $r1$, which $I1$ will produce. |\n| $4$ | MEM | ID (stall) | IF (stall) | $I1$ (a load) is in EX, its dest is $r1$. $I2$ is in ID, one of its sources is $r1$. A stall is asserted. A bubble is inserted. |\n| $5$ | WB | EX | ID | Stall ends. $I1$'s result is forwarded from the MEM/WB register to $I2$'s EX stage. |\n\nAt cycle $3$, $I1$ is in the EX stage and $I2$ is in the ID stage. The hazard detection logic applies:\n- $EX_{\\text{isLoad}}$ is true for $I1$.\n- $EX_{rd}$ is $r1$ (which is not $r0$).\n- $ID_{rs}$ for $I2$ is $r1$.\nThe condition $(ID_{rs} = EX_{rd})$ is true.\nTherefore, the stall signal $S$ is asserted. This introduces a $1$-cycle stall. The pipeline inserts a bubble, so $I2$ remains in the ID stage for cycle $4$, and $I1$ proceeds to the MEM stage.\n\n**Dependency 2: $I2 \\rightarrow I3$**\n- $I2$ is `LW r3, 0(r1)`, which writes to register $r3$.\n- $I3$ is `ADD r4, r3, r5`, which reads register $r3$ for the addition.\nThis is another load-use data hazard. We continue the pipeline trace from where we left off.\n\n| Cycle | I1: LW r1,... | I2: LW r3, 0(r1) | I3: ADD r4, r3,... | Comment |\n|---:|:---|:---|:---|:---|\n| $5$ | WB | EX | ID | Hazard detected: $I3$ needs $r3$, which $I2$ will produce. |\n| $6$ | | MEM | ID (stall) | $I2$ (a load) is in EX, its dest is $r3$. $I3$ is in ID, one of its sources is $r3$. A stall is asserted. A bubble is inserted. |\n| $7$ | | WB | EX | Stall ends. $I2$'s result is forwarded from the MEM/WB register to $I3$'s EX stage. |\n| $8$ | | | MEM | $I3$ continues. |\n| $9$ | | | WB | $I3$ completes. |\n\nAt cycle $5$, $I2$ is in the EX stage and $I3$ is in the ID stage. The hazard detection logic is triggered again:\n- $EX_{\\text{isLoad}}$ is true for $I2$.\n- $EX_{rd}$ is $r3$ (which is not $r0$).\n- $ID_{rs}$ for $I3$ is $r3$.\nThe condition $(ID_{rs} = EX_{rd})$ is true.\nThe stall signal $S$ is asserted, causing a second $1$-cycle stall.\n\nThe total number of stall cycles is the sum of the stalls from each detected hazard.\n- The dependency $I1 \\rightarrow I2$ causes $1$ stall cycle.\n- The dependency $I2 \\rightarrow I3$ causes $1$ stall cycle.\n\nTotal stall cycles = $1 + 1 = 2$.",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "Real-world code can present complex dependency scenarios that challenge a simple hazard detector. This exercise explores a crucial corner case where multiple in-flight instructions write to the same register before a consumer reads it (). Your task is to determine the correct policy the Hazard Detection Unit must follow, forcing you to reason about how pipelines maintain program order by prioritizing the most recent data producer.",
            "id": "3647243",
            "problem": "Consider a single-issue, in-order, five-stage pipeline with the stages Instruction Fetch (IF), Instruction Decode and Register Fetch (ID), Execute (EX), Memory Access (MEM), and Write Back (WB). The machine implements full forwarding (also called bypassing) from producing stages to the EX stage of younger instructions in later cycles. The following fundamental facts hold:\n\n- A source operand is needed by the EX stage at the beginning of the cycle in which the EX stage executes.\n- An arithmetic or logic producer computes its result in the EX stage and the value is available for forwarding at the end of that EX cycle.\n- A load producer obtains its data at the end of the MEM cycle, and that value is available for forwarding only in the next cycle’s EX stage of a younger instruction.\n- Register file writes occur in the WB stage, and reads occur in the ID stage; in-order completion guarantees program-order visibility of writes with no write-after-write hazards in the register file.\n\nA Hazard Detection Unit (HDU) in the ID stage decides whether to stall the instruction currently in ID to avoid a read-after-write (RAW) hazard based on comparing the ID-stage instruction’s source registers against destination registers of older in-flight instructions ahead in the pipeline. When multiple older in-flight instructions will write the same destination register $rd$, only the most recent (youngest) producer in program order will determine the correct value that the consumer must receive.\n\nAssume the instruction sequence:\n- $I_1$: `LW r_d, 0(r_a)`\n- $I_2$: `LW r_d, 8(r_a)`\n- $I_3$: `ADD r_t, r_d, r_b`\n\nAll three instructions are consecutive in program order. At the cycle when $I_3$ is first in $ID$, the pipeline stages contain:\n- $I_1$ in $MEM$,\n- $I_2$ in $EX$,\n- $I_3$ in $ID$.\n\nAssume that forwarding from $MEM$ and $WB$ to a later cycle’s $EX$ is implemented, but values produced at the end of a stage cannot be used by another instruction’s $EX$ at the beginning of that same cycle.\n\nWhich policy should the HDU apply to correctly prevent hazards and to prioritize multiple matches on $rd$ for the scenario above?\n\nA. Stall $I_3$ until $I_1$ completes because $I_1$ is the earliest matching producer of $r_d$. Prioritize the oldest matching $rd$ in flight to be safe.\n\nB. Stall $I_3$ based only on $I_2$ because it is the most recent matching producer of $r_d$. Prioritize the youngest matching $rd$ (closest in program order), and insert exactly $1$ cycle of stall so that $I_3$’s $EX$ occurs after $I_2$’s $MEM$ data becomes forwardable.\n\nC. Stall $I_3$ until both $I_1$ and $I_2$ have written back to the register file to guarantee the latest value in $ID$. When multiple producers to the same $rd$ exist, require both to complete before allowing the consumer to proceed.\n\nD. Do not stall $I_3$ because forwarding from $MEM$ allows $I_3$ to receive $r_d$ in the same cycle that $I_2$ is in $MEM$. Prioritize any available matching $rd$ and rely on same-cycle forwarding to avoid stalls.",
            "solution": "The problem statement is first validated for scientific soundness, consistency, and completeness.\n\n### Step 1: Extract Givens\n\n- Pipeline architecture: single-issue, in-order, $5$-stage pipeline with stages Instruction Fetch (IF), Instruction Decode and Register Fetch (ID), Execute (EX), Memory Access (MEM), and Write Back (WB).\n- Forwarding: Full forwarding from producing stages to the EX stage of younger instructions.\n- Operand timing: A source operand is needed by the EX stage at the beginning of the cycle.\n- ALU producer timing: An arithmetic/logic producer computes its result in the EX stage, and the value is available for forwarding at the end of that EX cycle.\n- Load producer timing: A load producer obtains its data at the end of the MEM cycle, and that value is available for forwarding only in the next cycle’s EX stage of a younger instruction.\n- Register file timing: Writes occur in the WB stage; reads occur in the ID stage.\n- Hazard handling: A Hazard Detection Unit (HDU) in the ID stage stalls the current instruction in ID to avoid read-after-write (RAW) hazards.\n- Multiple producer rule: For multiple older instructions writing to the same destination register $r_d$, the consumer must use the value from the most recent (youngest) producer.\n- Instruction sequence:\n    - $I_1$: `LW r_d, 0(r_a)`\n    - $I_2$: `LW r_d, 8(r_a)`\n    - $I_3$: `ADD r_t, r_d, r_b`\n- Pipeline state snapshot: At the cycle when $I_3$ is first in ID, $I_1$ is in MEM, $I_2$ is in EX, and $I_3$ is in ID.\n- Forwarding constraint: Values produced at the end of a stage cannot be used by another instruction’s EX at the beginning of that same cycle.\n\n### Step 2: Validate Using Extracted Givens\n\nThe problem statement is scientifically grounded and well-posed. It describes a canonical $5$-stage RISC pipeline, a classic model in computer organization and architecture. All the provided rules—data forwarding paths, hazard detection, and instruction timing—are standard and internally consistent. The scenario presented is a textbook example of a load-use data hazard, complicated by an output dependency, which is a common and practical problem in pipeline design. The problem is specified with sufficient detail and clarity to allow for a unique, logical solution. The given pipeline state is consistent with the behavior of an in-order pipeline executing the given instruction sequence. The language is objective and unambiguous. The problem does not violate any fundamental principles and is not incomplete or contradictory.\n\n### Step 3: Verdict and Action\n\nThe problem statement is **valid**. A solution will be derived.\n\n### Principle-Based Derivation\n\nThe core task of the Hazard Detection Unit (HDU) is to ensure correct execution by enforcing data dependencies. We must analyze the dependencies for the given instruction sequence and apply the pipeline timing rules.\n\n1.  **Data Dependency Analysis**:\n    The instruction `I_3: ADD r_t, r_d, r_b` uses register $r_d$ as a source operand. Two preceding instructions, $I_1$ and $I_2$, write to this same register $r_d$. This creates a Read-After-Write (RAW) hazard. The problem specifies the rule for resolving such multiple-producer scenarios: \"only the most recent (youngest) producer in program order will determine the correct value that the consumer must receive.\" In the sequence $I_1$, $I_2$, $I_3$, the youngest producer of $r_d$ relative to the consumer $I_3$ is $I_2$. Therefore, $I_3$ has a true data dependency on $I_2$. The result of $I_1$ is overwritten by $I_2$ before $I_3$ executes, so the HDU must enforce the dependency $I_2 \\rightarrow I_3$ and can ignore the dependency $I_1 \\rightarrow I_3$. The HDU's logic must be based on stalling for $I_2$.\n\n2.  **Pipeline Timing and Stall Calculation**:\n    Let us denote the cycle where the given pipeline state occurs as cycle $k$.\n    - **State at cycle $k$**:\n        - $I_1$ (LW): MEM\n        - $I_2$ (LW): EX\n        - $I_3$ (ADD): ID\n    The HDU in the ID stage detects that $I_3$ reads $r_d$ and that $I_2$, which is in the EX stage, writes to $r_d$. Since $I_2$ is a load instruction (LW), the specific timing for load-use hazards applies.\n\n    To determine if a stall is needed, we trace the pipeline's progression if no stall were inserted.\n    - **At the start of cycle $k+1$ (no stall)**:\n        - $I_2$ advances to the MEM stage.\n        - $I_3$ advances to the EX stage.\n        - Per the problem rules, $I_3$ requires the value of $r_d$ at the *beginning* of its EX stage, i.e., at the beginning of cycle $k+1$.\n    - **Data availability from $I_2$**:\n        - $I_2$ is a load instruction. Its data is fetched from memory during its MEM stage (cycle $k+1$).\n        - Per the rules, the \"load producer obtains its data at the end of the MEM cycle.\" Thus, the value for $r_d$ from $I_2$ is available only at the *end* of cycle $k+1$.\n\n    There is a conflict: $I_3$ needs the value at the beginning of cycle $k+1$, but $I_2$ provides it at the end of cycle $k+1$. This is a classic load-use hazard. The forwarding hardware cannot resolve this without a stall, as explicitly stated: \"values produced at the end of a stage cannot be used by another instruction’s EX at the beginning of that same cycle.\"\n\n    Therefore, the HDU must stall $I_3$. Let's determine the required stall duration. A $1$-cycle stall is the standard solution. Let's verify this.\n    - **At cycle $k$**: HDU detects the hazard and stalls the pipeline for $1$ cycle. This means $I_3$ is held in ID, and a bubble (no-op) is injected into the EX stage.\n    - **State at cycle $k+1$ (with $1$ stall cycle)**:\n        - $I_1$ advances to WB.\n        - $I_2$ advances to MEM.\n        - $I_3$ remains in ID.\n        - A bubble enters the EX stage.\n    - **State at cycle $k+2$**: The stall is complete, and the pipeline advances normally.\n        - $I_2$ advances to WB.\n        - $I_3$ advances to EX.\n        - The bubble advances to MEM.\n    - **Data availability for $I_3$ in cycle $k+2$**:\n        - $I_3$ needs the value of $r_d$ at the beginning of its EX stage (cycle $k+2$).\n        - The value from $I_2$ became available at the end of its MEM stage (end of cycle $k+1$).\n        - The rule states: \"value is available for forwarding only in the next cycle’s EX stage\". The cycle after $I_2$'s MEM stage (cycle $k+1$) is cycle $k+2$. The MEM-to-EX forwarding path can thus supply the value from the end of cycle $k+1$ to the beginning of cycle $k+2$.\n\n    With exactly $1$ stall cycle, the execution is correct. The HDU's policy must be to prioritize the youngest producer ($I_2$) and insert a $1$-cycle stall.\n\n### Option-by-Option Analysis\n\n**A. Stall $I_3$ until $I_1$ completes because $I_1$ is the earliest matching producer of $r_d$. Prioritize the oldest matching $rd$ in flight to be safe.**\nThis policy is incorrect. It violates the fundamental requirement for sequential consistency, which is explicitly stated in the problem: \"only the most recent (youngest) producer in program order will determine the correct value\". Prioritizing the oldest producer, $I_1$, would cause $I_3$ to receive the wrong value for $r_d$ (the one loaded by $I_1$, which should have been overwritten by $I_2$).\n**Verdict: Incorrect.**\n\n**B. Stall $I_3$ based only on $I_2$ because it is the most recent matching producer of $r_d$. Prioritize the youngest matching $rd$ (closest in program order), and insert exactly $1$ cycle of stall so that $I_3$’s $EX$ occurs after $I_2$’s $MEM$ data becomes forwardable.**\nThis policy aligns perfectly with our derivation.\n1.  It correctly identifies the dependency on the most recent producer, $I_2$.\n2.  It correctly determines that a stall is necessary to resolve the load-use hazard.\n3.  It correctly calculates the stall duration as exactly $1$ cycle.\n4.  The reason given—allowing $I_3$'s EX stage to be delayed until $I_2$'s data from the MEM stage is available for forwarding—is the precise logic for resolving a load-use hazard in this type of pipeline.\n**Verdict: Correct.**\n\n**C. Stall $I_3$ until both $I_1$ and $I_2$ have written back to the register file to guarantee the latest value in $ID$. When multiple producers to the same $rd$ exist, require both to complete before allowing the consumer to proceed.**\nThis policy is grossly inefficient and incorrect. It describes a pipeline without any data forwarding, where consumers must wait for producers to complete the WB stage. The problem explicitly states that \"full forwarding\" is implemented. Waiting for both producers is also wrong; only the value from $I_2$ is needed. This policy would introduce many unnecessary stall cycles and defeats the purpose of a pipelined architecture with forwarding.\n**Verdict: Incorrect.**\n\n**D. Do not stall $I_3$ because forwarding from $MEM$ allows $I_3$ to receive $r_d$ in the same cycle that $I_2$ is in $MEM$. Prioritize any available matching $rd$ and rely on same-cycle forwarding to avoid stalls.**\nThis policy is incorrect because it misunderstands the timing of data availability. As shown in the derivation, if $I_2$ is in MEM during cycle $k+1$, its data is available only at the end of that cycle. If $I_3$ were to proceed without a stall, it would be in its EX stage during cycle $k+1$ and require the data at the beginning of that cycle. This \"same-cycle\" forwarding is not possible and is explicitly prohibited by the problem's constraint: \"values produced at the end of a stage cannot be used by another instruction’s EX at the beginning of that same cycle.\" A stall is absolutely necessary. Furthermore, prioritizing \"any available\" producer is incorrect; it must be the youngest one for correctness.\n**Verdict: Incorrect.**",
            "answer": "$$\\boxed{B}$$"
        }
    ]
}