{
    "hands_on_practices": [
        {
            "introduction": "To begin, let's quantify the fundamental performance cost of data hazards and the principal benefit of result forwarding. This practice challenges you to analyze a \"pathological\" instruction stream where every instruction depends on the one immediately preceding it. By deriving a formula for the total stall cycles in this worst-case scenario, both with and without forwarding, you will gain a concrete, mathematical understanding of why hazard detection and forwarding are indispensable features of modern processors.",
            "id": "3647250",
            "problem": "Consider an in-order, five-stage pipeline consisting of Instruction Fetch (IF), Instruction Decode and register-read (ID), Execute (EX), Memory access (MEM), and Write Back (WB). The pipeline includes a Hazard Detection Unit (HDU) that stalls the front end to prevent read-after-write data hazards. Assume each stage takes exactly one clock cycle, and there are no control hazards and no structural hazards. Assume all instructions in this problem are arithmetic-logical instructions that read a single source register and write a single destination register.\n\nYou are given a parameter called the producer-to-consumer data latency, denoted by $L \\in \\mathbb{Z}_{\\ge 1}$. Interpret $L$ as the number of clock cycles that a consumer instruction must be delayed, relative to the immediately preceding producer instruction on which it depends, in order to observe the correct value when there is no result forwarding (i.e., the consumer can only see values after they are written back to the register file). With full single-cycle result forwarding (also called bypassing), the consumer can capture the producer’s result one pipeline stage earlier than the register-file write-back path would allow, reducing the required delay by exactly $1$ cycle per producer-consumer pair.\n\nConstruct a pathologically dependent instruction stream of length $N \\in \\mathbb{Z}_{\\ge 1}$ with dependency distance $1$ as follows. Let the sequence be $\\{I_{1}, I_{2}, \\ldots, I_{N}\\}$, where for a fixed architectural register $R$ and some pure function $g$, each instruction has the form\n$I_{k}: R \\leftarrow g(R)$\nso that for every $k \\in \\{1,2,\\ldots,N-1\\}$, instruction $I_{k+1}$ is a consumer of the value produced by $I_{k}$ and is immediately adjacent in program order (dependency distance $1$).\n\nStarting from the core definitions of pipeline staging and read-after-write ordering, derive closed-form expressions for:\n1) the total number of stall cycles inserted by the Hazard Detection Unit over the entire stream when there is no forwarding,\n2) the total number of stall cycles inserted by the Hazard Detection Unit over the entire stream when full single-cycle forwarding is available, and\n3) the absolute reduction in total stall cycles afforded by forwarding.\n\nExpress your final answer as a single row vector $\\big[T_{\\text{no fwd}}, T_{\\text{fwd}}, \\Delta\\big]$ in terms of $N$ and $L$. No numerical approximation is required; provide a closed-form analytical expression.",
            "solution": "We begin from fundamental definitions relevant to pipelined execution and data hazards:\n- A read-after-write (RAW) hazard occurs when an instruction (the consumer) needs to read an operand that is produced by an earlier instruction (the producer) that has not yet made its result available at the consumer’s point of use.\n- In an in-order pipeline, the Hazard Detection Unit (HDU) enforces correct ordering by stalling the consumer until the producer’s value is available at the consumer’s operand input.\n- With no forwarding, the consumer can only observe a value once it has been written back to the register file. With forwarding, the consumer can capture the producer’s result directly from a pipeline register one stage earlier than write-back, removing one cycle from the producer-to-consumer wait.\n\nBy construction, the instruction stream $\\{I_{1}, I_{2}, \\ldots, I_{N}\\}$ is a dependency chain with dependency distance $1$: for every $k \\in \\{1,\\ldots,N-1\\}$, instruction $I_{k+1}$ consumes the value produced by $I_{k}$. Let us denote by $L \\in \\mathbb{Z}_{\\ge 1}$ the given producer-to-consumer data latency in the absence of forwarding. By the definition stated in the problem, this $L$ is the number of cycles that the HDU must delay each consumer so that its read in the Instruction Decode (ID) stage and subsequent Execute (EX) stage observes the correct value through the register-file path, when forwarding is not available.\n\nWe now reason about the total stalls introduced by the HDU over the entire stream.\n\n1) No forwarding. Because each pair $\\big(I_{k}, I_{k+1}\\big)$ has dependency distance $1$, the consumer $I_{k+1}$ would, absent hazards, enter its ID stage one cycle after $I_{k}$. However, by the meaning of $L$ in this pipeline configuration without forwarding, the HDU must delay $I_{k+1}$ by exactly $L$ cycles to align the consumer’s operand read with the cycle in which the producer’s value is available via the register file. Therefore, for each adjacent producer-consumer pair, the HDU inserts $L$ stall cycles.\n\nThere are exactly $N-1$ such adjacent dependent pairs in the chain of $N$ instructions, because $I_{1}$ has no predecessor in the sequence and every subsequent instruction depends on its immediate predecessor. Since the stalls needed for each pair occur at distinct points in time as the pipeline progresses through the chain, the total number of stall cycles is the sum over all pairs:\n$$\nT_{\\text{no fwd}} \\;=\\; L \\cdot (N - 1).\n$$\n\n2) Full single-cycle forwarding. With full single-cycle forwarding, the consumer can capture the producer’s result one pipeline stage earlier than when relying on the register-file write-back path. This removes exactly one cycle from the required wait per producer-consumer pair. Hence, for each adjacent dependent pair, the required stall decreases from $L$ to $L - 1$. Summing over the $N-1$ pairs yields\n$$\nT_{\\text{fwd}} \\;=\\; (L - 1) \\cdot (N - 1).\n$$\n\n3) Absolute reduction. The absolute reduction in total stall cycles due to forwarding is the difference between the totals without and with forwarding:\n$$\n\\Delta \\;=\\; T_{\\text{no fwd}} - T_{\\text{fwd}} \\;=\\; \\big[L \\cdot (N - 1)\\big] - \\big[(L - 1) \\cdot (N - 1)\\big] \\;=\\; (N - 1).\n$$\n\nThus, the closed-form expressions in terms of $N$ and $L$ are\n$$\nT_{\\text{no fwd}} = L(N-1), \\quad T_{\\text{fwd}} = (L-1)(N-1), \\quad \\Delta = (N-1).\n$$\n\nWe present the final answer as a single row vector as requested.",
            "answer": "$$\n\\boxed{\\begin{pmatrix} L(N-1) & (L-1)(N-1) & (N-1) \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "Having established the high-level impact of stalls, we now move from abstract latencies to practical hardware design. The \"load-use\" hazard is a classic and critical case where simple forwarding is insufficient to prevent a stall. This exercise asks you to design the specific Boolean logic a hazard detection unit would use to identify this situation and then trace a short code sequence to see your logic in action, solidifying your grasp of how pipeline control hardware operates.",
            "id": "3647216",
            "problem": "Consider a classic five-stage in-order, single-issue pipeline with the stages Instruction Fetch (IF), Instruction Decode and Register Fetch (ID), Execute (EX), Memory Access (MEM), and Write-back (WB). The processor implements full bypass (forwarding) paths for arithmetic logic unit outputs so that an arithmetic result produced at the end of the Execute stage can be forwarded to the next instruction’s Execute stage without introducing a stall. Loads read data from memory in the Memory Access stage and write the value to the destination register in the Write-back stage. Define the load-use latency $L$ as the number of cycles between the start of the producer instruction’s Execute stage and the earliest cycle the loaded value can be presented to a consumer instruction’s Execute stage input via forwarding; assume $L=2$ for loads in this pipeline.\n\nA hazard detection unit must assert a stall signal when the instruction in the Instruction Decode and Register Fetch stage reads either source register $rs$ or source register $rt$ that is equal to the destination register $rd$ of the instruction in the Execute stage, provided that the instruction in the Execute stage is a load. The zero register `r0` is architecturally hard-wired to zero and writes to `r0` have no effect; the hazard detection unit should ignore `r0` as a destination.\n\nUsing only well-tested pipeline facts about when results become available and the definition of the load-use latency $L$, do the following:\n\n1. Derive a minimal Boolean expression for the stall signal in terms of the signals `EX_isLoad`, `EX_rd`, `ID_rs`, and `ID_rt`, including the `r0` special case. Your expression must be purely combinational with respect to the current cycle pipeline register contents (no counters or timers).\n\n2. Then, starting from an empty pipeline, estimate the total number of stall cycles that will be inserted when executing the following contiguous sequence of three dependent instructions, under the assumptions above and with full forwarding for arithmetic logic unit results:\n   - $I1$: $\\mathrm{LW}\\ r1,\\ 0(r2)$\n   - $I2$: $\\mathrm{LW}\\ r3,\\ 0(r1)$\n   - $I3$: $\\mathrm{ADD}\\ r4,\\ r3,\\ r5$\n\nProduce the final answer as a single real-valued number equal to the total stall cycles inserted for the three-instruction sequence. No rounding is required. No units are required in the final answer.",
            "solution": "The problem is evaluated as valid, as it is scientifically grounded in the principles of computer architecture, well-posed, and internally consistent. We can therefore proceed with a solution.\n\nThe problem is divided into two parts. First, we derive the Boolean expression for the stall signal. Second, we calculate the total number of stall cycles for a given instruction sequence.\n\n**Part 1: Derivation of the Boolean Stall Signal Expression**\n\nThe problem specifies the conditions under which the hazard detection unit must assert a stall signal. A stall is required if the instruction in the Instruction Decode (ID) stage has a source register dependency on a load instruction currently in the Execute (EX) stage. Let us formalize these conditions.\n\nThe givens for the logic expression are:\n- `EX_isLoad`: A signal that is true ($1$) if the instruction in the EX stage is a load.\n- `EX_rd`: The destination register index for the instruction in the EX stage.\n- `ID_rs`: The first source register index for the instruction in the ID stage.\n- `ID_rt`: The second source register index for the instruction in the ID stage.\n\nThe conditions for a stall are:\n1. The instruction in the EX stage is a load instruction. This corresponds to the condition `EX_isLoad` = 1.\n2. The destination register of the load instruction in the EX stage is not the zero register, `r0`. The register `r0` corresponds to index $0$. Thus, this condition is `EX_rd` $\\neq$ 0.\n3. The instruction in the ID stage uses the result of the load. This means that at least one of its source registers (`ID_rs` or `ID_rt`) is the same as the destination register (`EX_rd`) of the load instruction in the EX stage. This is expressed as (`ID_rs` = `EX_rd`) $\\lor$ (`ID_rt` = `EX_rd`).\n\nCombining these three conditions with a logical AND operation gives the complete expression for the stall signal, which we denote as $S$. A stall occurs if and only if all three conditions are met.\n\nTherefore, the minimal Boolean expression for the stall signal $S$ is:\n$$S = \\text{EX\\_isLoad} \\land (\\text{EX\\_rd} \\neq 0) \\land ((\\text{ID\\_rs} = \\text{EX\\_rd}) \\lor (\\text{ID\\_rt} = \\text{EX\\_rd}))$$\nThis expression is minimal because it directly represents the necessary and sufficient conditions described in the problem statement, with no redundant terms.\n\n**Part 2: Calculation of Total Stall Cycles**\n\nWe are asked to calculate the total stall cycles for the following sequence of instructions:\n- $I1: \\mathrm{LW}\\ r1, 0(r2)$\n- $I2: \\mathrm{LW}\\ r3, 0(r1)$\n- $I3: \\mathrm{ADD}\\ r4, r3, r5$\n\nThe pipeline has full forwarding for ALU results, meaning an ALU-ALU dependency incurs $0$ stalls. The problem defines a load-use latency $L=2$. The number of stall cycles for a load-use dependency is given by $L-1$. In this case, $L-1 = 2-1 = 1$ stall cycle. We can verify this by tracing the pipeline's execution.\n\nLet's analyze the dependencies between the instructions.\n\n**Dependency 1: $I1 \\rightarrow I2$**\n- $I1$ is $\\mathrm{LW}\\ r1, 0(r2)$, which writes to register $r1$.\n- $I2$ is $\\mathrm{LW}\\ r3, 0(r1)$, which reads register $r1$ to calculate its memory address.\nThis is a classic load-use data hazard. We trace the pipeline to see when the hazard is detected and a stall is inserted.\n\n| Cycle | $I1: \\mathrm{LW}\\ r1,..$ | $I2: \\mathrm{LW}\\ r3, 0(r1)$ | $I3: \\mathrm{ADD}\\ r4, r3,..$ | Comment |\n|---:|:---|:---|:---|:---|\n| $1$ | IF | | | $I1$ is fetched. |\n| $2$ | ID | IF | | $I2$ is fetched. |\n| $3$ | EX | ID | IF | $I3$ is fetched. Hazard detected: $I2$ needs $r1$, which $I1$ will produce. |\n| $4$ | MEM | ID (stall) | IF (stall) | $I1$ (a load) is in EX, its dest is $r1$. $I2$ is in ID, one of its sources is $r1$. A stall is asserted. A bubble is inserted. |\n| $5$ | WB | EX | ID | Stall ends. $I1$'s result is forwarded from the MEM/WB register to $I2$'s EX stage. |\n\nAt cycle $3$, $I1$ is in the EX stage and $I2$ is in the ID stage. The hazard detection logic applies:\n- `EX_isLoad` is true for $I1$.\n- `EX_rd` is $r1$ (which is not `r0`).\n- `ID_rs` for $I2$ is $r1$.\nThe condition (`ID_rs` = `EX_rd`) is true.\nTherefore, the stall signal $S$ is asserted. This introduces a $1$-cycle stall. The pipeline inserts a bubble, so $I2$ remains in the ID stage for cycle $4$, and $I1$ proceeds to the MEM stage.\n\n**Dependency 2: $I2 \\rightarrow I3$**\n- $I2$ is $\\mathrm{LW}\\ r3, 0(r1)$, which writes to register $r3$.\n- $I3$ is $\\mathrm{ADD}\\ r4, r3, r5$, which reads register $r3$ for the addition.\nThis is another load-use data hazard. We continue the pipeline trace from where we left off.\n\n| Cycle | $I1: \\mathrm{LW}\\ r1,..$ | $I2: \\mathrm{LW}\\ r3, 0(r1)$ | $I3: \\mathrm{ADD}\\ r4, r3,..$ | Comment |\n|---:|:---|:---|:---|:---|\n| $5$ | WB | EX | ID | Hazard detected: $I3$ needs $r3$, which $I2$ will produce. |\n| $6$ | | MEM | ID (stall) | $I2$ (a load) is in EX, its dest is $r3$. $I3$ is in ID, one of its sources is $r3$. A stall is asserted. A bubble is inserted. |\n| $7$ | | WB | EX | Stall ends. $I2$'s result is forwarded from the MEM/WB register to $I3$'s EX stage. |\n| $8$ | | | MEM | $I3$ continues. |\n| $9$ | | | WB | $I3$ completes. |\n\nAt cycle $5$, $I2$ is in the EX stage and $I3$ is in the ID stage. The hazard detection logic is triggered again:\n- `EX_isLoad` is true for $I2$.\n- `EX_rd` is $r3$ (which is not `r0`).\n- `ID_rs` for $I3$ is $r3$.\nThe condition (`ID_rs` = `EX_rd`) is true.\nThe stall signal $S$ is asserted, causing a second $1$-cycle stall.\n\nThe total number of stall cycles is the sum of the stalls from each detected hazard.\n- The dependency $I1 \\rightarrow I2$ causes $1$ stall cycle.\n- The dependency $I2 \\rightarrow I3$ causes $1$ stall cycle.\n\nTotal stall cycles = $1 + 1 = 2$.",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "Building on the previous exercises, this final practice encourages a more general and analytical approach to pipeline performance. Instead of using fixed latencies, you will work with symbolic latencies to derive a universal formula for calculating stalls in a sequence of dependent instructions. By analyzing a \"triangular\" dependency pattern with a partially disabled forwarding path, you will develop a flexible model for predicting how different instruction latencies and pipeline features interact to determine overall execution time.",
            "id": "3647186",
            "problem": "Consider an in-order, single-issue Reduced Instruction Set Computer (RISC) pipeline with $5$ classic stages: Instruction Fetch (IF), Instruction Decode and Register Read (ID), Execute (EX), Memory (MEM), and Write Back (WB). Each stage takes $1$ cycle, register operands are read in the ID stage, and results are written to the register file in the WB stage. A hazard detection unit enforces Read After Write (RAW) safety by stalling in the ID stage whenever an operand needed by the instruction at ID will not be available by the time that instruction would start EX. When a stall is asserted in ID, younger instructions behind it in the pipeline do not advance. There are no structural hazards and no control hazards.\n\nAssume the bypass (forwarding) network is fully capable of forwarding values from earlier producers to later consumers except that there is no forwarding path from instruction $I_2$ to instruction $I_3$ in the specific scenario described below. Let $L_x$ and $L_y$ be defined as follows (each measured in cycles as an EX-to-EX separation):\n\n- $L_x$ is the minimum separation (in cycles) required between the start of $I_1$'s EX stage and the start of $I_2$'s EX stage so that operand $x$ produced by $I_1$ is available to $I_2$ in its EX stage inputs via the existing forwarding paths between $I_1$ and $I_2$.\n- $L_y$ is the minimum separation (in cycles) required between the start of $I_2$'s EX stage and the start of $I_3$'s EX stage so that operand $y$ produced by $I_2$ is available to $I_3$ without relying on any forwarding from $I_2$ (i.e., $I_3$ must obtain $y$ from the register file; the hazard detection unit must ensure this by stalling as needed).\n\nNow consider the following three-instruction triangular dependency pattern:\n- $I_1$: produces $x$ into destination register $rd$,\n- $I_2$: reads $x$ and produces $y$,\n- $I_3$: reads $y$.\n\nAssume that, absent data hazards, the machine issues one instruction per cycle such that, by default, starts of EX for consecutive instructions are separated by $1$ cycle. The hazard detection unit inserts the minimum number of stall cycles necessary to preserve correctness, and instructions issue as early as correctness allows.\n\nDerive a closed-form analytic expression for the total number of stall cycles inserted across this three-instruction sequence as a function of $L_x$ and $L_y$. Express your final answer as a single closed-form expression in terms of $L_x$ and $L_y$. No numerical evaluation is required and no rounding applies.",
            "solution": "The problem statement provides a well-defined scenario within the canonical model of a 5-stage RISC pipeline. All parameters and constraints are scientifically grounded in the principles of computer organization and architecture, and the problem is self-contained, consistent, and objective. Therefore, the problem is deemed valid and a formal solution can be constructed.\n\nThe core task is to determine the total number of stall cycles inserted by the hazard detection unit for a specific three-instruction sequence with two sequential Read-After-Write (RAW) data dependencies. A stall cycle is a single-cycle bubble inserted into the pipeline to resolve a hazard. For an in-order pipeline, a stall occurs when an instruction in the Instruction Decode (ID) stage cannot advance to the Execute (EX) stage.\n\nLet us analyze the timing of the pipeline. In an ideal instruction flow without hazards, each instruction advances one stage per cycle. Instructions $I_1$, $I_2$, and $I_3$ would enter the EX stage in three consecutive cycles. This establishes a default EX-to-EX separation of $1$ cycle between consecutive instructions.\n\nA data hazard between a producer instruction $I_p$ and a consumer instruction $I_c$ is characterized by a required latency, $L$, which represents the minimum number of cycles that must separate the start of $I_p$'s EX stage and the start of $I_c$'s EX stage for the data to be correctly available.\n\nThe number of stall cycles, $S$, required for a single dependency is the number of additional cycles the consumer instruction must be held in its ID stage beyond the default flow. The actual separation must be at least $L$, while the default separation is $1$. The relationship is:\n$$1 + S \\ge L$$\nSince the hazard detection unit inserts the *minimum* number of stalls, we have $1 + S = L$, or $S = L-1$. However, if the required latency $L$ is less than or equal to the default separation of $1$ cycle ($L \\le 1$), no stall is necessary. Therefore, the number of stall cycles for a single dependency with latency $L$ is:\n$$S = \\max(0, L-1)$$\n\nWe now apply this principle to the two dependencies in the sequence.\n\nFirst dependency: $I_1 \\to I_2$\n- $I_1$ produces operand $x$.\n- $I_2$ consumes operand $x$.\n- The required EX-to-EX separation is given as $L_x$.\nThe number of stall cycles, $S_{12}$, inserted while $I_2$ is in the ID stage to wait for $I_1$ is:\n$$S_{12} = \\max(0, L_x - 1)$$\nThese $S_{12}$ stall cycles delay not only $I_2$ but also the subsequent instruction $I_3$, which is held in the Instruction Fetch (IF) stage during this time.\n\nSecond dependency: $I_2 \\to I_3$\n- $I_2$ produces operand $y$.\n- $I_3$ consumes operand $y$.\n- The required EX-to-EX separation is given as $L_y$. This latency accounts for the fact that $I_3$ must retrieve the value from the register file, as there is no forwarding path from $I_2$ to $I_3$.\nAfter the $S_{12}$ stalls for the first dependency are complete, $I_2$ advances to its EX stage, and $I_3$ advances to its ID stage. At this point, the hazard detection unit evaluates the $I_2 \\to I_3$ dependency. The number of stall cycles, $S_{23}$, inserted while $I_3$ is in the ID stage to wait for $I_2$ is:\n$$S_{23} = \\max(0, L_y - 1)$$\n\nThe total number of stall cycles, $S_{total}$, is the sum of the stall cycles introduced for each hazard. Because the pipeline is in-order, the stalls are additive. The stall for the first dependency ($S_{12}$) must be fully served, which delays the arrival of $I_3$ at the ID stage. Once $I_3$ is at the ID stage, the stall for the second dependency ($S_{23}$) is then served.\n\nLet's trace the start times of the EX stages to confirm this.\nLet the EX stage for $I_1$ start at an arbitrary cycle $T$.\n$$EX_{start}(I_1) = T$$\nThe EX stage for $I_2$ must start at least $L_x$ cycles after $I_1$'s EX stage starts. Due to the pipeline structure, it also starts at least $1$ cycle after $I_1$'s EX stage. Thus:\n$$EX_{start}(I_2) = EX_{start}(I_1) + \\max(1, L_x) = T + \\max(1, L_x)$$\nSimilarly, the EX stage for $I_3$ must start at least $L_y$ cycles after $I_2$'s EX stage starts:\n$$EX_{start}(I_3) = EX_{start}(I_2) + \\max(1, L_y) = T + \\max(1, L_x) + \\max(1, L_y)$$\n\nThe total number of cycles elapsed from the start of $I_1$'s EX stage to the start of $I_3$'s EX stage is:\n$$\\Delta T = EX_{start}(I_3) - EX_{start}(I_1) = \\max(1, L_x) + \\max(1, L_y)$$\nIn an ideal pipeline with no hazards, this interval would be $2$ cycles ($I_1$ at $T$, $I_2$ at $T+1$, $I_3$ at $T+2$). The total number of stall cycles inserted is the difference between the actual interval and the ideal interval:\n$$S_{total} = \\Delta T - 2 = (\\max(1, L_x) + \\max(1, L_y)) - 2$$\nUsing the identity $\\max(a, b) = a + \\max(0, b-a)$, we can write $\\max(1, L) = 1 + \\max(0, L-1)$. Substituting this into the expression for $S_{total}$:\n$$S_{total} = (1 + \\max(0, L_x-1)) + (1 + \\max(0, L_y-1)) - 2$$\n$$S_{total} = 2 + \\max(0, L_x-1) + \\max(0, L_y-1) - 2$$\n$$S_{total} = \\max(0, L_x-1) + \\max(0, L_y-1)$$\n\nThis confirms that the total number of stall cycles is the sum of the stalls required for each individual dependency in the chain.\n\nThe final closed-form analytic expression for the total number of stall cycles as a function of $L_x$ and $L_y$ is the sum of the stalls generated by each of the two sequential dependencies.",
            "answer": "$$\\boxed{\\max(0, L_x - 1) + \\max(0, L_y - 1)}$$"
        }
    ]
}