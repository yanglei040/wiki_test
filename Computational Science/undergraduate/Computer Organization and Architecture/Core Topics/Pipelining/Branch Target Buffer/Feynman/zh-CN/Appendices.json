{
    "hands_on_practices": [
        {
            "introduction": "分支目标缓冲器（BTB）的核心价值在于通过减少控制冒险来提升处理器性能。本练习将理论与实践相结合，引导你构建一个量化模型，用以精确衡量BTB的效率（即命中率）如何直接转化为关键性能指标——每周期指令数（$IPC$）。通过推导和计算，你将掌握使用一阶性能模型来评估微体系结构特性的基本方法，从而深刻理解BTB对流水线前端的重要性。",
            "id": "3623981",
            "problem": "一个乱序执行核心使用分支目标缓冲器 (BTB) 在基本块边界处提供预测的取指重定向。设每周期指令数 (IPC) 定义为 $IPC = I/C$，其中 $I$ 是退役指令的数量，$C$ 是经过的时钟周期数。假设以下模型和参数：\n- 每个基本块平均包含 $L$ 条指令。\n- 在每个基本块边界处会进行一次 BTB 查找，当发生未命中时，会在流水线取指流被正确重定向前，引入一个 $P$ 个周期的前端取指停顿。\n- BTB 命中率为 $h$，因此每个边界的未命中概率为 $1 - h$。\n- 在完美 BTB 覆盖（没有由 BTB 引起的停顿）情况下，核心的 IPC 为 $IPC_{0}$。\n- 敏感度因子 $f_{b}$ 量化了前端取指气泡转化为吞吐量损失的强度：在小停顿条件下，IPC 的分数下降与每条指令的预期停顿周期数成正比，并按 $f_{b}$ 进行缩放。\n\n从 $IPC$ 的定义和由基本块边界处的 BTB 未命中引起的每条指令的预期停顿周期出发，使用一阶（小停顿）近似，推导出一个关于 $IPC_{0}$、$f_{b}$、$h$、$P$ 和 $L$ 的解析表达式 $IPC(h)$。然后，对于\n- $IPC_{0} = 2.4$，\n- $f_{b} = 0.35$，\n- $P = 3$，\n- $L = 7$，\n计算当 $h \\in \\{0.60, 0.85, 0.95\\}$ 时 $IPC(h)$ 的值。将每个计算结果四舍五入到四位有效数字。使用 $\\text{pmatrix}$ 环境，将最终的三个数值结果以单行矩阵的形式给出。",
            "solution": "题目要求推导每周期指令数 ($IPC$) 作为分支目标缓冲器 (BTB) 命中率 $h$ 的函数的解析表达式，然后为一组给定的参数计算其值。推导过程必须遵循一阶、小停顿的近似方法。\n\n首先，我们形式化性能模型的各个组成部分。\n基准性能由 $IPC_0$ 给出，代表在没有 BTB 引起的停顿的理想情况下的每周期指令数。\n\nBTB 未命中会引入前端停顿。在每个基本块的边界处会进行一次 BTB 查找。平均基本块长度为 $L$ 条指令，那么在执行 $I$ 条指令期间遇到的基本块边界数为 $I/L$。\n\nBTB 命中率为 $h$，因此未命中概率为 $1-h$。每次未命中会产生 $P$ 个周期的前端停顿惩罚。在前端引入的原始停顿周期总数为：\n$$ C_{\\text{stall, raw}} = \\left(\\frac{I}{L}\\right) (1 - h) \\times P = \\frac{I \\cdot P \\cdot (1 - h)}{L} $$\n敏感度因子 $f_b$ 模拟了并非所有前端停顿都会直接转化为后端停顿。导致总执行时间增加的有效停顿周期数 $C_{\\text{stall, eff}}$ 按此因子进行缩放：\n$$ C_{\\text{stall, eff}} = f_b \\cdot C_{\\text{stall, raw}} = f_b \\frac{I \\cdot P \\cdot (1 - h)}{L} $$\n每条指令的有效停顿周期数，$SPI_{\\text{eff}}$，为：\n$$ SPI_{\\text{eff}} = \\frac{C_{\\text{stall, eff}}}{I} = \\frac{f_b P (1 - h)}{L} $$\n题目指明使用“一阶（小停顿）近似”，并指出“IPC 的分数下降与每条指令的预期停顿周期数成正比”。这引导我们使用线性模型。假设比例常数为 1，这是此类一阶模型的标准做法，IPC 的分数下降为：\n$$ \\frac{IPC_0 - IPC(h)}{IPC_0} = SPI_{\\text{eff}} = \\frac{f_b P (1 - h)}{L} $$\n求解 $IPC(h)$:\n$$ 1 - \\frac{IPC(h)}{IPC_0} = \\frac{f_b P (1 - h)}{L} $$\n$$ \\frac{IPC(h)}{IPC_0} = 1 - \\frac{f_b P (1 - h)}{L} $$\n$$ IPC(h) = IPC_0 \\left( 1 - \\frac{f_b P (1 - h)}{L} \\right) $$\n这个线性模型就是所要求的解析表达式。\n\n现在，我们代入给定的数值：\n$IPC_{0} = 2.4$\n$f_{b} = 0.35$\n$P = 3$\n$L = 7$\n\n$IPC(h)$ 的具体表达式是：\n$$ IPC(h) = 2.4 \\left( 1 - \\frac{0.35 \\times 3 \\times (1 - h)}{7} \\right) $$\n$$ IPC(h) = 2.4 \\left( 1 - \\frac{1.05}{7} (1 - h) \\right) $$\n$$ IPC(h) = 2.4 \\left( 1 - 0.15 (1 - h) \\right) $$\n\n我们计算当 $h \\in \\{0.60, 0.85, 0.95\\}$ 时 $IPC(h)$ 的值，并四舍五入到四位有效数字。\n\n对于 $h = 0.60$:\n$$ IPC(0.60) = 2.4 \\left( 1 - 0.15 (1 - 0.60) \\right) = 2.4 \\left( 1 - 0.15 (0.40) \\right) = 2.4 \\left( 1 - 0.06 \\right) = 2.4 \\times 0.94 = 2.256 $$\n\n对于 $h = 0.85$:\n$$ IPC(0.85) = 2.4 \\left( 1 - 0.15 (1 - 0.85) \\right) = 2.4 \\left( 1 - 0.15 (0.15) \\right) = 2.4 \\left( 1 - 0.0225 \\right) = 2.4 \\times 0.9775 = 2.346 $$\n\n对于 $h = 0.95$:\n$$ IPC(0.95) = 2.4 \\left( 1 - 0.15 (1 - 0.95) \\right) = 2.4 \\left( 1 - 0.15 (0.05) \\right) = 2.4 \\left( 1 - 0.0075 \\right) = 2.4 \\times 0.9925 = 2.382 $$\n\n计算出的值，四舍五入到四位有效数字后，分别为 $2.256$、$2.346$ 和 $2.382$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n2.256 & 2.346 & 2.382\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "理解了BTB为何重要之后，下一步是探索如何优化其设计。由于BTB的容量是有限的，计算机体系结构师必须在“存储什么”上做出明智的权衡。本练习构建了一个真实的决策场景：我们应该用宝贵的BTB条目来缓存总是跳转的静态无条件跳转指令，还是将这些空间留给数量更多、行为更复杂的条件分支，以期提高它们的命中率？通过分析不同设计策略的预期周期成本，你将锻炼在资源受限下进行性能优化的核心架构思维。",
            "id": "3624008",
            "problem": "一个处理器前端使用分支目标缓冲器（BTB）来为控制转移指令提供下一个取指地址。在深流水线中，分支重定向延迟为 $L$ 个周期，这意味着如果前端在发生跳转的控制转移时沿着顺序路径取指，并且目标没有被提早知道，那么流水线会产生 $L$ 个停顿周期，以将取指重定向到正确的目标。\n\n考虑静态无条件跳转（总是跳转）和条件分支（可能被预测为跳转或不跳转）。由于控制冒险，每条提交指令的预期停顿周期会增加每指令周期数（CPI）。假设以下经过充分检验的事实和定义：\n- 某一类事件对每条指令的预期停顿贡献等于该事件的每指令频率乘以每个事件的平均停顿。\n- BTB 命中可以提早得到目标地址，从而避免 $L$ 周期的重定向惩罚；对于发生跳转的转移指令，BTB 未命中会产生 $L$ 个停顿周期。\n- 对于条件分支，只有当分支被预测为跳转时才需要 BTB；当预测为不跳转时，在分支解析之前，跳转路径上不会使用目标地址，因此 BTB 命中或未命中不会改变初始的取指路径。对于预测为跳转且实际发生跳转的分支，BTB 未命中会产生 $L$ 个周期。\n\n您正在比较两种策略：\n- 策略 $\\mathcal{I}$：在 BTB 中存储静态无条件跳转的条目。\n- 策略 $\\mathcal{E}$：将静态无条件跳转排除在 BTB 之外，并依赖顺序取指直到重定向。\n\n假设对于特定的工作负载和微架构，有以下参数：\n- 分支重定向延迟 $L = 9$ 周期。\n- 无条件跳转的动态频率 $f_{u} = 0.05$ 每指令。\n- 条件分支的动态频率 $f_{c} = 0.20$ 每指令。\n- 给定一个条件分支，预测器输出“跳转”的概率为 $r_{t|c} = 0.60$。\n- 给定一个预测为跳转的条件分支，它实际发生跳转的概率为 $p_{\\mathrm{corr}|t} = 0.95$。\n- 在策略 $\\mathcal{I}$ 下，无条件跳转的 BTB 命中率为 $h_{u} = 0.90$。\n- 在策略 $\\mathcal{I}$ 下，预测为跳转的条件分支的 BTB 命中率为 $h_{c} = 0.92$。\n- 在策略 $\\mathcal{E}$ 下，释放 BTB 容量使预测为跳转的条件分支的命中率增加到 $h_{c}' = 0.97$。\n- 在策略 $\\mathcal{E}$ 下，无条件跳转没有 BTB 条目，因此其有效 BTB 命中率为 $0$。\n\n从已陈述的预期停顿贡献的定义出发，首先推导出一个符号表达式，表示使用策略 $\\mathcal{I}$ 替代策略 $\\mathcal{E}$ 时的净 CPI 减少量 $\\Delta \\mathrm{CPI}$，该表达式是 $L$、$f_{u}$、$h_{u}$、$f_{c}$、$r_{t|c}$、$p_{\\mathrm{corr}|t}$、$h_{c}$ 和 $h_{c}'$ 的函数。然后使用给定参数对此表达式进行数值计算。将最终答案表示为代表 $\\Delta \\mathrm{CPI}$ 的单个实数（无量纲）。将您的答案四舍五入到四位有效数字。",
            "solution": "问题要求计算从策略 $\\mathcal{E}$ 转换到策略 $\\mathcal{I}$ 时的净 CPI 减少量 $\\Delta \\mathrm{CPI}$。这个减少量是两种策略下由控制冒险贡献的每指令停顿周期之差：\n$$ \\Delta \\mathrm{CPI} = \\mathrm{CPI}_{\\mathrm{stall}, \\mathcal{E}} - \\mathrm{CPI}_{\\mathrm{stall}, \\mathcal{I}} $$\n给定一类事件的停顿贡献是该事件的每指令频率与每个事件的停顿惩罚的乘积。对于未被 BTB 正确预测的、发生跳转的控制转移，其停顿惩罚为 $L$ 个周期。\n\n我们来分析每种策略的停顿贡献。停顿发生在发生跳转的控制转移中，由于 BTB 未命中，前端进行了顺序取指。\n\n**1. 策略 $\\mathcal{E}$ 下的停顿 CPI（排除无条件跳转）**\n在此策略下，无条件跳转不存储在 BTB 中，因此其有效命中率为 $0$。预测为跳转的条件分支使用 BTB，其命中率为 $h_{c}'$。\n- **来自无条件跳转的停顿 ($\\mathrm{CPI}_{u, \\mathcal{E}}$):**\n  无条件跳转总是会发生。由于它们不在 BTB 中，每次出现都会导致 BTB 未命中，产生 $L$ 个周期的惩罚。\n  $$ \\mathrm{CPI}_{u, \\mathcal{E}} = f_{u} \\times (\\text{miss rate}) \\times L = f_{u} \\times (1-0) \\times L = f_{u} L $$\n- **来自条件分支的停顿 ($\\mathrm{CPI}_{c, \\mathcal{E}}$):**\n  只有当分支被预测为跳转、实际发生跳转并且在 BTB 中未命中时，才会产生停顿惩罚。\n  $$ \\mathrm{CPI}_{c, \\mathcal{E}} = (f_c r_{t|c} p_{\\mathrm{corr}|t}) \\times (1 - h_{c}') \\times L $$\n策略 $\\mathcal{E}$ 的总停顿 CPI 是这些贡献的总和：\n$$ \\mathrm{CPI}_{\\mathrm{stall}, \\mathcal{E}} = f_{u} L + f_c r_{t|c} p_{\\mathrm{corr}|t} (1 - h_{c}') L $$\n\n**2. 策略 $\\mathcal{I}$ 下的停顿 CPI（包含无条件跳转）**\n在此策略下，无条件跳转和预测为跳转的条件分支都使用 BTB。命中率分别为 $h_u$ 和 $h_c$。\n- **来自无条件跳转的停顿 ($\\mathrm{CPI}_{u, \\mathcal{I}}$):**\n  无条件跳转总是会发生。只有在 BTB 未命中时才会发生停顿。未命中率为 $(1 - h_u)$。\n  $$ \\mathrm{CPI}_{u, \\mathcal{I}} = f_{u} \\times (1 - h_{u}) \\times L $$\n- **来自条件分支的停顿 ($\\mathrm{CPI}_{c, \\mathcal{I}}$):**\n  逻辑与策略 $\\mathcal{E}$ 相同，但命中率为 $h_c$。未命中率为 $(1 - h_c)$。\n  $$ \\mathrm{CPI}_{c, \\mathcal{I}} = (f_c r_{t|c} p_{\\mathrm{corr}|t}) \\times (1 - h_{c}) \\times L $$\n策略 $\\mathcal{I}$ 的总停顿 CPI 为：\n$$ \\mathrm{CPI}_{\\mathrm{stall}, \\mathcal{I}} = f_{u} (1 - h_{u}) L + f_c r_{t|c} p_{\\mathrm{corr}|t} (1 - h_{c}) L $$\n\n**3. $\\Delta \\mathrm{CPI}$ 的符号表达式**\n现在我们计算差值 $\\Delta \\mathrm{CPI} = \\mathrm{CPI}_{\\mathrm{stall}, \\mathcal{E}} - \\mathrm{CPI}_{\\mathrm{stall}, \\mathcal{I}}$。\n$$ \\Delta \\mathrm{CPI} = [f_{u} L + f_c r_{t|c} p_{\\mathrm{corr}|t} (1 - h_{c}') L] - [f_{u} (1 - h_{u}) L + f_c r_{t|c} p_{\\mathrm{corr}|t} (1 - h_{c}) L] $$\n按指令类型对各项进行分组：\n$$ \\Delta \\mathrm{CPI} = [f_{u} L - f_{u} (1 - h_{u}) L] + [f_c r_{t|c} p_{\\mathrm{corr}|t} (1 - h_{c}') L - f_c r_{t|c} p_{\\mathrm{corr}|t} (1 - h_{c}) L] $$\n简化每个分组。对于无条件跳转部分，收益为：\n$$ f_{u} L - f_{u} L + f_{u} h_{u} L = f_{u} h_{u} L $$\n对于条件分支部分，影响为：\n$$ f_c r_{t|c} p_{\\mathrm{corr}|t} L [(1 - h_{c}') - (1 - h_{c})] = f_c r_{t|c} p_{\\mathrm{corr}|t} L (h_{c} - h_{c}') $$\n将两部分结合起来，得到 $\\Delta \\mathrm{CPI}$ 的符号表达式：\n$$ \\Delta \\mathrm{CPI} = f_{u} h_{u} L + f_c r_{t|c} p_{\\mathrm{corr}|t} (h_c - h_c') L = L [f_{u} h_{u} + f_c r_{t|c} p_{\\mathrm{corr}|t} (h_c - h_c')] $$\n\n**4. 数值计算**\n将给定的参数值代入符号表达式：\n- $L = 9$\n- $f_{u} = 0.05$\n- $f_{c} = 0.20$\n- $r_{t|c} = 0.60$\n- $p_{\\mathrm{corr}|t} = 0.95$\n- $h_{u} = 0.90$\n- $h_{c} = 0.92$\n- $h_{c}' = 0.97$\n\n$$ \\Delta \\mathrm{CPI} = 9 \\times [ (0.05 \\times 0.90) + (0.20 \\times 0.60 \\times 0.95) \\times (0.92 - 0.97) ] $$\n计算方括号内的项。\n$$ \\Delta \\mathrm{CPI} = 9 \\times [ 0.045 + (0.114) \\times (-0.05) ] $$\n$$ \\Delta \\mathrm{CPI} = 9 \\times [ 0.045 - 0.0057 ] $$\n$$ \\Delta \\mathrm{CPI} = 9 \\times 0.0393 = 0.3537 $$\n结果四舍五入到四位有效数字为 $0.3537$。正值表示策略 $\\mathcal{I}$ 导致了更低的总停顿 CPI，因此对于给定的参数，它是更好的策略。",
            "answer": "$$\\boxed{0.3537}$$"
        },
        {
            "introduction": "分支预测的难题并非仅靠BTB就能完全解决，它需要与其他体系结构组件协同工作。本练习将带你从静态的分析模型转向动态的仿真实现，探索BTB与返回地址栈（Return Address Stack, RAS）之间至关重要的协作关系。通过亲手编写一个模拟器，你将具体地观察到这两个组件如何处理函数调用与返回，并理解RAS的局限性（如溢出）如何对BTB产生压力。这项动手编程任务揭示了简单分析模型可能忽略的、复杂的系统级动态行为。",
            "id": "3623939",
            "problem": "您需要构建并分析一个简化的、逻辑上忠实的模拟程序，该程序模拟嵌套过程调用和返回期间，分支目标缓冲器 (Branch Target Buffer, BTB) 和返回地址栈 (Return Address Stack, RAS) 之间的交互。其基础是流水线处理器中的标准控制冒险行为：函数调用会压入一个返回地址，处理器在随后的返回操作中需要预测该地址；而在可能的情况下，返回操作会使用返回地址栈 (RAS) 进行预测。分支目标缓冲器 (BTB) 按指令地址缓存分支目标以辅助预测。在本问题中，仅当 RAS 无法提供正确的返回地址时，BTB 才被用于返回指令。\n\n您必须实现一个程序，模拟调用和返回序列。每个调用事件提供一个函数标识符和调用点的返回地址。每个返回事件提供一个函数标识符，并指明该函数发生了一次返回。基准真相行为是实际调用栈的后进先出 (Last-In-First-Out) 特性。该模拟使用以下规则：\n\n- 对于一个返回地址为 $a$ 的函数调用，将 $a$ 压入无限大的“实际栈”。同时，当且仅当当前 RAS 大小严格小于其容量 $R$ 时，才将 $a$ 压入 RAS；如果 RAS 已达到容量 $R$，则忽略此次压栈操作（这模拟了 RAS 溢出而不回绕的情况）。\n- 对于函数标识符为 $f$ 的函数返回，从实际栈中弹出栈顶地址 $a$。如果 RAS 非空且其栈顶元素等于 $a$，则返回预测由 RAS 处理，并弹出 RAS 的栈顶元素。否则，为避免传播状态不同步，RAS 将被清空（设置为空），且返回预测由以函数标识符 $f$ 为键的 BTB 处理。\n- BTB 的容量为 $N$ 个条目，按函数标识符存储键，并使用最近最少使用 (Least Recently Used, LRU) 替换策略。每当一个返回不由 RAS 处理时，就发生一次 BTB“使用”。如果函数标识符 $f$ 存在于 BTB 中，则为 BTB 命中，其条目变为最近使用的条目。如果 $f$ 不存在，则插入一个关于 $f$ 的条目；若 BTB 已满，则在插入前驱逐最近最少使用的条目。每次此类替换计为一次驱逐。在本问题中，定义“BTB 压力”为由返回操作引起的 BTB 插入所导致的总驱逐次数。\n\n您的程序必须为每个测试用例计算：\n- 由 BTB 处理的返回次数，记为 $b$。\n- 由 RAS 处理的返回次数，记为 $r$。\n- 因返回操作导致的 BTB 总驱逐次数，记为 $e$。\n- 最优 RAS 容量 $R^\\star$，它是在从 $0$ 到追踪记录中观察到的最大调用嵌套深度的所有整数 $R$ 范围内，使 BTB 压力 $e$ 最小化的值；如果多个 $R$ 值达到了相同的最小 $e$ 值，则选择其中最小的 $R$。\n\n所有计数都必须是精确的整数。不涉及物理单位。\n\n按照描述实现 BTB，使其具有精确的 LRU 行为，并仅由函数标识符作为键。遵守在返回期间发生任何不匹配时清空 RAS 的规则。\n\n测试套件。使用给定的参数模拟以下追踪记录：\n\n- 测试用例 1（具有中等嵌套的正常路径）：\n  - 参数：$R=2, N=2$。\n  - 追踪记录 $\\mathcal{T}_1$：调用函数 $1$，返回地址为 $100$；调用函数 $2$，返回地址为 $200$；从函数 $2$ 返回；调用函数 $3$，返回地址为 $300$；调用函数 $2$，返回地址为 $400$；从函数 $2$ 返回；从函数 $3$ 返回；从函数 $1$ 返回。\n\n- 测试用例 2（深度嵌套和小容量 BTB 的边界情况）：\n  - 参数：$R=2, N=1$。\n  - 追踪记录 $\\mathcal{T}_2$：调用函数 $1$，返回地址为 $10$；调用函数 $2$，返回地址为 $11$；调用函数 $3$，返回地址为 $12$；调用函数 $4$，返回地址为 $13$；调用函数 $5$，返回地址为 $14$；从函数 $5$ 返回；从函数 $4$ 返回；从函数 $3$ 返回；从函数 $2$ 返回；从函数 $1$ 返回。\n\n- 测试用例 3（显示 BTB 处理来自单个函数的重复返回的边缘情况）：\n  - 参数：$R=2, N=1$。\n  - 追踪记录 $\\mathcal{T}_3$：调用函数 $6$，返回地址为 $21$；调用函数 $6$，返回地址为 $22$；调用函数 $6$，返回地址为 $23$；调用函数 $6$，返回地址为 $24$；从函数 $6$ 返回；从函数 $6$ 返回；从函数 $6$ 返回；从函数 $6$ 返回。\n\n最终输出格式。您的程序应生成单行输出，其中包含所有测试用例的结果列表，每个测试用例的结果表示为列表 $[b,r,e,R^\\star]$，全部输出为一个包含在方括号内的逗号分隔列表。例如：\n\"[[b_1,r_1,e_1,R^\\star_1],[b_2,r_2,e_2,R^\\star_2],[b_3,r_3,e_3,R^\\star_3]]\"。",
            "solution": "该问题要求模拟RAS和BTB的交互，并对三个测试用例计算指定的性能指标 $(b, r, e)$ 和最优RAS容量 $R^\\star$。\n\n**核心模拟逻辑**\n1.  **调用 (Call)**: 实际栈（AS）总是压入返回地址。RAS仅在容量未满时压入。\n2.  **返回 (Return)**: 从AS弹出真实返回地址。若RAS非空且其栈顶与真实地址匹配，则为RAS命中（$r++$），RAS弹出。否则，为RAS未命中：RAS被清空，BTB被访问（$b++$）。\n3.  **BTB访问**: 若函数ID在BTB中，则为命中，更新为最近使用。若不在，则为未命中，插入该ID。若BTB已满，则驱逐最近最少使用的条目（$e++$）后再插入。\n\n**最优 $R^\\star$ 的计算**\n对于每个测试用例，我们首先确定其最大调用深度 $D_{max}$。然后，对每个整数 $R \\in [0, D_{max}]$ 运行模拟，记录驱逐次数 $e$。$R^\\star$ 是使 $e$ 最小的最小 $R$ 值。\n\n---\n**测试用例 1: ($R=2, N=2$)**\n- **追踪与模拟**: 追踪记录为 C(1,100), C(2,200), R(2), C(3,300), C(2,400), R(2), R(3), R(1)。最大调用深度为3。\n    - C(1,100), C(2,200): AS=[100,200], RAS=[100,200]。\n    - R(2): 真实地址=200，RAS匹配。$r=1$。AS=[100], RAS=[100]。\n    - C(3,300): AS=[100,300], RAS=[100,300]。\n    - C(2,400): AS=[100,300,400], RAS=[100,300] (RAS已满)。\n    - R(2): 真实地址=400，RAS不匹配。$b=1$。RAS清空。BTB插入2: BTB={2(MRU)}。\n    - R(3): 真实地址=300，RAS空。$b=2$。BTB插入3: BTB={3(MRU), 2}。\n    - R(1): 真实地址=100，RAS空。$b=3$。BTB已满，驱逐2，插入1。$e=1$。BTB={1(MRU), 3}。\n- **结果 ($R=2, N=2$)**: $b=3, r=1, e=1$。\n- **计算 $R^\\star$ ($N=2, D_{max}=3$)**:\n    - $R=0: e=1$。\n    - $R=1: e=1$。\n    - $R=2: e=1$。\n    - $R=3: e=0$ (所有返回都由RAS处理)。\n- $e$的最小值为0，在$R=3$时首次达到。因此 **$R^\\star = 3$**。\n- **最终结果 1**: `[3, 1, 1, 3]`\n\n---\n**测试用例 2: ($R=2, N=1$)**\n- **追踪与模拟**: 5次连续调用，最大调用深度为5。5次调用后, AS=[10,11,12,13,14], RAS=[10,11]。\n    - R(5): 真实地址=14, RAS不匹配。$b=1$。RAS清空。BTB插入5: BTB={5}。\n    - R(4): 真实地址=13, RAS空。$b=2$。BTB驱逐5, 插入4。$e=1$。BTB={4}。\n    - R(3): 真实地址=12, RAS空。$b=3$。BTB驱逐4, 插入3。$e=2$。BTB={3}。\n    - R(2): 真实地址=11, RAS空。$b=4$。BTB驱逐3, 插入2。$e=3$。BTB={2}。\n    - R(1): 真实地址=10, RAS空。$b=5$。BTB驱逐2, 插入1。$e=4$。BTB={1}。\n- **结果 ($R=2, N=1$)**: $b=5, r=0, e=4$。\n- **计算 $R^\\star$ ($N=1, D_{max}=5$)**: 对于简单的LIFO调用序列，大小为$R$的RAS能处理最后$R$个返回。BTB需要处理前$D_{max}-R$个返回。由于每个函数ID都不同，容量为1的BTB会为每个BTB处理的返回(除了第一个)驱逐一次。驱逐次数 $e = \\max(0, (D_{max}-R)-1)$。\n    - $R=0: e=4$。 $R=1: e=3$。 $R=2: e=2$。 $R=3: e=1$。 $R=4: e=0$。 $R=5: e=0$。\n- $e$的最小值为0，在$R=4$时首次达到。因此 **$R^\\star = 4$**。\n- **最终结果 2**: `[5, 0, 4, 4]`\n\n---\n**测试用例 3: ($R=2, N=1$)**\n- **追踪与模拟**: 4次对同一函数6的调用，最大调用深度为4。4次调用后, AS=[21,22,23,24], RAS=[21,22]。\n    - R(6): 真实地址=24, RAS不匹配。$b=1$。RAS清空。BTB插入6: BTB={6}, $e=0$。\n    - R(6): 真实地址=23, RAS空。$b=2$。BTB命中6, 无驱逐。\n    - R(6): 真实地址=22, RAS空。$b=3$。BTB命中6, 无驱逐。\n    - R(6): 真实地址=21, RAS空。$b=4$。BTB命中6, 无驱逐。\n- **结果 ($R=2, N=1$)**: $b=4, r=0, e=0$。\n- **计算 $R^\\star$ ($N=1, D_{max}=4$)**: 由于所有BTB访问都针对同一个函数ID(6)，BTB最多只会在第一次未命中时插入一次，之后都是命中。因此，对于任何$R$值，驱逐次数 $e$ 总是0。\n- $e$的最小值为0。使 $e$ 最小的最小 $R$ 值是 **$R^\\star = 0$**。\n- **最终结果 3**: `[4, 0, 0, 0]`\n\n---\n**汇总**\n- 测试用例 1: [3, 1, 1, 3]\n- 测试用例 2: [5, 0, 4, 4]\n- 测试用例 3: [4, 0, 0, 0]",
            "answer": "$$\\boxed{\\text{[[3, 1, 1, 3], [5, 0, 4, 4], [4, 0, 0, 0]]}}$$"
        }
    ]
}