{
    "hands_on_practices": [
        {
            "introduction": "Understanding control hazards begins with quantifying their cost. This foundational exercise explores the performance penalty of a single branch misprediction in a classic 5-stage RISC pipeline. By analyzing a simple loop with a static, always-taken predictor, you will determine the exact number of cycles lost when the processor incorrectly speculates the path of execution, providing a clear illustration of why control hazards are a critical performance bottleneck.",
            "id": "3630214",
            "problem": "A single-issue, five-stage Reduced Instruction Set Computer (RISC) pipeline executes instructions in the stages Instruction Fetch (IF), Instruction Decode (ID), Execute (EX), Memory (MEM), and Write Back (WB). Control dependence is handled using a static branch predictor that always predicts branches as taken. A Branch Target Buffer (BTB) supplies the predicted-taken target address in IF, so when the prediction is correct, instruction fetch proceeds from the target without stalls. The branch condition is resolved in EX, and upon a misprediction, all younger instructions in the pipeline are flushed, and fetch is redirected to the correct path on the next cycle. There are no architectural branch delay slots, no early target or condition resolution before EX, and no other structural or data hazards.\n\nConsider a tight loop whose body ends with a single conditional backward branch that forms the loop back edge. The loop executes for $n \\geq 1$ iterations, so that the branch outcome is taken for the first $n-1$ iterations and not taken on the $n$-th iteration to exit the loop. Under the always-taken predictor described above, the only misprediction arises on the final iteration when the branch is actually not taken. Assume there are no other branches inside the loop body.\n\nUsing only the above fundamentals about pipeline staging and branch handling, determine the total control-hazard penalty, in cycles, paid per completed loop (that is, across the full $n$ iterations). Express your answer as a single exact integer number of cycles, and use cycles as the unit for interpretation (do not include units in your final boxed answer). No rounding is required.",
            "solution": "The problem is first validated to ensure it is self-contained, scientifically grounded, and well-posed.\n\n### Step 1: Extract Givens\n- **Pipeline Structure**: A single-issue, five-stage RISC pipeline with stages: Instruction Fetch (IF), Instruction Decode (ID), Execute (EX), Memory (MEM), and Write Back (WB).\n- **Branch Handling**:\n    - **Predictor**: Static branch predictor that always predicts branches as taken.\n    - **Branch Target Buffer (BTB)**: Supplies the predicted-taken target address in the IF stage.\n    - **Correct Prediction**: When a 'taken' prediction is correct, there are no stalls.\n    - **Resolution**: The branch condition is resolved in the EX stage.\n    - **Misprediction**: On a misprediction, all younger instructions are flushed, and fetch is redirected on the next cycle.\n- **Exclusions**: No architectural branch delay slots, no early resolution before the EX stage, and no other structural or data hazards.\n- **Scenario**: A tight loop that executes for $n \\geq 1$ iterations.\n- **Loop Branch**: A single conditional backward branch at the end of the loop body.\n- **Branch Outcomes**:\n    - The branch is 'taken' for the first $n-1$ iterations.\n    - The branch is 'not taken' on the $n$-th (final) iteration.\n- **Objective**: Determine the total control-hazard penalty, in cycles, for one complete execution of the loop (i.e., across all $n$ iterations).\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem describes a classic 5-stage RISC pipeline, a standard pedagogical model in computer organization and architecture. The concepts of static branch prediction, BTB functionality, pipeline flushing, and branch resolution in the EX stage are fundamental and factually sound principles.\n- **Well-Posed**: The problem is clearly defined. It provides all necessary parameters of the pipeline and branch handling mechanism to calculate a specific, unique numerical value for the penalty.\n- **Objective**: The problem is stated using precise, standard terminology from the field of computer architecture, free from any subjectivity or ambiguity.\n\n### Step 3: Verdict and Action\nThe problem is valid as it is scientifically sound, well-posed, objective, and self-contained. A definitive solution can be derived from the given information.\n\n### Solution Derivation\n\nThe total control-hazard penalty for the entire loop is the sum of the penalties incurred at each branch instance. The loop contains one branch, which is executed $n$ times. We must analyze the penalty for each of these $n$ executions.\n\nThe branch predictor is a static 'always-taken' predictor. We evaluate its performance for the two types of branch outcomes.\n\n1.  **First $n-1$ Iterations (Correctly Predicted Branches)**\n    For the first $n-1$ iterations, the backward branch is taken to continue the loop.\n    - **Prediction**: Always-Taken.\n    - **Actual Outcome**: Taken.\n    - **Result**: The prediction is correct.\n    The problem statement specifies that \"when the prediction is correct, instruction fetch proceeds from the target without stalls.\" This means the penalty for each of these correct predictions is $0$ cycles.\n    The total penalty for the first $n-1$ iterations is $(n-1) \\times 0 = 0$ cycles.\n\n2.  **The $n$-th Iteration (Mispredicted Branch)**\n    On the final iteration, the branch is not taken to exit the loop.\n    - **Prediction**: Always-Taken.\n    - **Actual Outcome**: Not-Taken.\n    - **Result**: The prediction is incorrect, causing a misprediction. A penalty is incurred.\n\nTo calculate the misprediction penalty, we must analyze the state of the pipeline. The branch instruction's outcome is determined in the EX stage. The EX stage is the 3rd stage of the 5-stage pipeline.\n\nLet the branch instruction be $B$.\n- **Cycle $t$**: $B$ is in the IF stage. The predictor identifies it as a branch and predicts 'taken'. The Branch Target Buffer (BTB) supplies the target address, and the Program Counter (PC) is updated to this target address.\n- **Cycle $t+1$**: $B$ moves to the ID stage. The first instruction from the (wrongly) predicted target path, let's call it $I_1$, enters the IF stage.\n- **Cycle $t+2$**: $B$ moves to the EX stage. $I_1$ moves to the ID stage. The second instruction from the wrong path, $I_2$, enters the IF stage. At the end of this cycle, the EX unit resolves the branch and discovers it was not taken. The prediction was wrong.\n\nAt the moment the misprediction is detected (end of cycle $t+2$), the following younger, speculatively executed instructions are in the pipeline and must be flushed:\n- Instruction $I_1$ in the ID stage.\n- Instruction $I_2$ in the IF stage.\n\nThese two instructions are discarded. The CPU time spent fetching and decoding them is wasted. The problem states that fetch is redirected to the correct path on the next cycle, which is cycle $t+3$. In cycle $t+3$, the pipeline will fetch the correct instruction that sequentially follows the branch, $B+1$.\n\nThe penalty is the number of cycles lost due to fetching and processing instructions on the wrong path. The number of such instructions corresponds to the number of pipeline stages before the stage where the branch is resolved.\n- Branch resolution stage: EX (stage $3$).\n- Preceding stages: IF (stage $1$) and ID (stage $2$).\nThere are $2$ stages before the EX stage. Therefore, $2$ instructions are wrongly fetched and must be flushed. This results in a pipeline bubble of $2$ cycles.\n\nThe penalty for the single misprediction is $2$ cycles.\n\n**Total Penalty Calculation**\n\nThe total penalty for the entire loop execution is the sum of penalties from all $n$ branch executions.\n$$ \\text{Total Penalty} = \\left( (n-1) \\times \\text{Penalty}_{\\text{correct prediction}} \\right) + \\left( 1 \\times \\text{Penalty}_{\\text{misprediction}} \\right) $$\nSubstituting the calculated values:\n$$ \\text{Total Penalty} = \\left( (n-1) \\times 0 \\right) + \\left( 1 \\times 2 \\right) $$\n$$ \\text{Total Penalty} = 0 + 2 = 2 $$\nThe total control-hazard penalty paid per completed loop is $2$ cycles, regardless of the number of iterations $n$ (for $n \\geq 1$).",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "While static predictors are simple, modern processors employ dynamic branch predictors that learn from a program's history. This practice delves into the mechanics of a common dynamic predictor: the 2-bit saturating counter. By tracing the predictor's state transitions in response to a repeating branch pattern, you will gain insight into how these predictors adapt and why they are not infallible, leading to a deeper understanding of their steady-state behavior and misprediction characteristics .",
            "id": "3630181",
            "problem": "A pipelined processor employs a bimodal $2$-bit saturating counter branch predictor with a single predictor entry dedicated to a single static branch. The predictor has $4$ states labeled $0$, $1$, $2$, and $3$. It predicts taken for states $2$ and $3$, and predicts not-taken for states $0$ and $1$. On each branch outcome, the state increments by $1$ on a taken outcome and decrements by $1$ on a not-taken outcome, saturating at $3$ and $0$ respectively. The initial predictor state is arbitrary. Consider a repeating outcome pattern for this branch that consists of $(k-2)$ consecutive taken outcomes followed by $2$ consecutive not-taken outcomes, repeating with period $k$, where $k \\ge 2$. Let $m(k)$ denote the steady-state mispredict rate, defined as the total number of mispredictions in one period divided by the period length $k$, once the predictor has reached its periodic behavior under this repeating sequence. Derive $m(k)$ as a function of $k$ and present your final answer as a single closed-form analytical expression. No rounding is required. The answer is dimensionless.",
            "solution": "The problem asks for the steady-state mispredict rate, $m(k)$, of a specific $2$-bit bimodal branch predictor for a repeating branch outcome pattern. The analysis requires determining the periodic behavior of the predictor's state and counting the number of mispredictions within that period.\n\nFirst, let us formalize the model of the $2$-bit saturating counter.\nThe state of the predictor, $S$, can be one of four values: $S \\in \\{0, 1, 2, 3\\}$.\nThe prediction rule is as follows:\n- If $S \\in \\{0, 1\\}$, predict 'Not-Taken' (NT).\n- If $S \\in \\{2, 3\\}$, predict 'Taken' (T).\n\nThe state transition rule, given a current state $S$ and a branch outcome $O$, results in a new state $S'$:\n- If the outcome $O$ is 'Taken' (T), the new state is $S' = \\min(S+1, 3)$.\n- If the outcome $O$ is 'Not-Taken' (NT), the new state is $S' = \\max(S-1, 0)$.\n\nA misprediction occurs when the predicted outcome does not match the actual outcome $O$.\n\nThe branch outcome pattern is a sequence of period $k \\ge 2$, consisting of $(k-2)$ consecutive 'Taken' outcomes followed by $2$ consecutive 'Not-Taken' outcomes. The pattern is $(\\underbrace{\\text{T}, \\text{T}, \\dots, \\text{T}}_{k-2 \\text{ times}}, \\text{NT}, \\text{NT})$.\n\nWe are interested in the steady-state mispredict rate, $m(k)$, which is the number of mispredictions in one period of the stable cycle, divided by the period $k$. To find this, we must first identify the repeating cycle of states the predictor enters. Let $S_0$ be the state at the beginning of a period in the steady state. After $k$ branches, the state must return to $S_0$. Let's denote the state after the $i$-th branch in the period as $S_i$. The steady-state condition is $S_k = S_0$. We analyze the problem by considering different cases for the value of $k$.\n\n### Case 1: $k=2$\nThe pattern has a period of $k=2$. It consists of $(2-2)=0$ 'Taken' outcomes and $2$ 'Not-Taken' outcomes. The pattern is (NT, NT).\nThis sequence of outcomes will drive the counter state towards $0$. Let's assume the system has reached a steady state, which must be $S_0=0$.\n- Start at $S_0=0$. The prediction is NT. The first outcome is NT. This is a **correct** prediction. The new state is $S_1 = \\max(0-1, 0) = 0$.\n- The state is $S_1=0$. The prediction is NT. The second outcome is NT. This is a **correct** prediction. The new state is $S_2 = \\max(0-1, 0) = 0$.\nThe final state is $S_2=0$, which is equal to the starting state $S_0=0$. Thus, the steady-state cycle is a constant state $S=0$.\nThe number of mispredictions in this period is $0$.\nThe mispredict rate is $m(2) = \\frac{0}{2} = 0$.\n\n### Case 2: $k=3$\nThe pattern has a period of $k=3$. It consists of $(3-2)=1$ 'Taken' outcome and $2$ 'Not-Taken' outcomes. The pattern is (T, NT, NT).\nThe pattern has more NTs than Ts, which suggests the steady-state will be in a low-valued state. Let's test for a steady-state cycle starting at $S_0=0$.\n- Start at $S_0=0$. The prediction is NT. The first outcome is T. This is a **misprediction**. The new state is $S_1 = \\min(0+1, 3) = 1$.\n- The state is $S_1=1$. The prediction is NT. The second outcome is NT. This is a **correct** prediction. The new state is $S_2 = \\max(1-1, 0) = 0$.\n- The state is $S_2=0$. The prediction is NT. The third outcome is NT. This is a **correct** prediction. The new state is $S_3 = \\max(0-1, 0) = 0$.\nThe final state is $S_3=0$, which equals the starting state $S_0=0$. This is a stable cycle.\nThe number of mispredictions in this period is $1$.\nThe mispredict rate is $m(3) = \\frac{1}{3}$.\n\n### Case 3: $k \\ge 4$\nThe pattern has a period of $k$, consisting of $(k-2)$ 'Taken' outcomes and $2$ 'Not-Taken' outcomes.\nLet's find the steady-state starting state $S_0$. The state after one period, $S_k$, is a function of $S_0$ and $k$. After the $(k-2)$ 'Taken' branches, the state becomes $S' = \\min(S_0 + k - 2, 3)$. After the subsequent $2$ 'Not-Taken' branches, the final state is $S_k = \\max(S' - 2, 0) = \\max(\\min(S_0 + k - 2, 3) - 2, 0)$.\nFor a steady state, we must have $S_k = S_0$.\nLet's assume the counter saturates during the 'Taken' sequence, i.e., $S_0 + k - 2 \\ge 3$, which means $S_0 \\ge 5-k$. If this holds, then $S' = 3$. The equation for $S_0$ becomes $S_0 = \\max(3-2, 0) = 1$.\nThis solution $S_0=1$ is self-consistent if it satisfies the assumption $S_0 \\ge 5-k$. Substituting $S_0=1$, we get $1 \\ge 5-k$, which simplifies to $k \\ge 4$.\nThus, for all $k \\ge 4$, there exists a steady-state cycle that begins with the state $S_0=1$. (For $k=4$, another cycle starting at $S_0=0$ also exists, but both yield the same misprediction count of $3$).\nLet's trace the execution for one period starting from $S_0=1$ for $k \\ge 4$:\n- The first outcome is T. The state is $S_0=1$ (predict NT). This is a **misprediction**. The new state is $S_1 = \\min(1+1, 3) = 2$.\n- The second outcome is T. The state is $S_1=2$ (predict T). This is a **correct** prediction. The new state is $S_2 = \\min(2+1, 3) = 3$.\n- For the subsequent $(k-2)-2 = k-4$ 'Taken' outcomes, the state remains $S=3$ (predict T). These are all **correct** predictions. After all $(k-2)$ 'Taken' outcomes, the state is $S_{k-2}=3$.\n- The $(k-1)$-th outcome is NT. The state is $S_{k-2}=3$ (predict T). This is a **misprediction**. The new state is $S_{k-1} = \\max(3-1, 0) = 2$.\n- The $k$-th outcome is NT. The state is $S_{k-1}=2$ (predict T). This is a **misprediction**. The new state is $S_k = \\max(2-1, 0) = 1$.\nThe final state is $S_k=1$, which equals the starting state $S_0=1$. This confirms the stable cycle.\nThe total number of mispredictions in one period is the sum of mispredictions from each step: $1 + 0 + 1 + 1 = 3$.\nThe mispredict rate for $k \\ge 4$ is $m(k) = \\frac{3}{k}$.\n\n### Summary of Results\nCombining the results from all cases, the steady-state mispredict rate $m(k)$ is a piecewise function of $k$:\n- For $k=2$, $m(2) = 0$.\n- For $k=3$, $m(3) = \\frac{1}{3}$.\n- For $k \\ge 4$, $m(k) = \\frac{3}{k}$.\n\nThis can be expressed as a single analytical expression using a piecewise definition.\n$$\nm(k) = \\begin{cases} 0 & \\text{if } k=2 \\\\ \\frac{1}{k} & \\text{if } k=3 \\\\ \\frac{3}{k} & \\text{if } k \\ge 4 \\end{cases}\n$$\nNote that for $k=3$, the expression $1/k$ yields $1/3$, as required.",
            "answer": "$$\n\\boxed{\n\\begin{cases} 0 & k=2 \\\\ \\frac{1}{k} & k=3 \\\\ \\frac{3}{k} & k \\ge 4 \\end{cases}\n}\n$$"
        },
        {
            "introduction": "In realistic scenarios, control hazards interact with other pipeline features like data forwarding. This problem synthesizes these concepts by asking you to analyze the performance of a complete loop, moving beyond just calculating penalties to determining the overall Cycles Per Instruction (CPI). By accounting for both data dependencies resolved by forwarding and the probabilistic nature of branch outcomes, you will develop a model for the loop's true performance, connecting abstract hazard costs to a crucial, holistic metric of processor efficiency .",
            "id": "3643933",
            "problem": "Consider a classic $5$-stage integer pipeline with stages Instruction Fetch (IF), Instruction Decode and Register Read (ID), Execute (EX), Memory Access (MEM), and Write Back (WB). The pipeline is single-issue, has perfect instruction and data caches (no cache misses), and implements full data forwarding (bypassing) to the Execute stage. Forwarding supplies results from the EX/MEM and MEM/WB pipeline registers into the EX stage inputs of dependent instructions and into the EX stage comparator for branches. Loads produce their result in the MEM stage; however, the code below contains no loads. Assume no structural hazards.\n\nA conditional branch is resolved in the EX stage. When the branch is taken, the front-end loses $\\beta$ bubble cycles due to control hazard handling; when the branch is not taken, no bubble cycles are incurred. Assume that the long-run fraction of iterations in which the branch is taken is $p$, where $0 \\leq p \\leq 1$.\n\nAnalyze the following tight loop, which updates register $R2$ and uses $R2$ immediately in the subsequent instruction:\n\nLOOP:\n    ADD R2, R2, R3\n    SUB R4, R2, R5\n    ADD R1, R1, R11\n    BNE R1, R12, LOOP\n\nAssume the branch at the end loops until a termination condition that depends on $R1$, so the branch is taken for a fraction $p$ of dynamic executions and not taken otherwise.\n\nStarting from the fundamental definitions of pipeline stages and hazard handling, trace the forwarding decisions for the data dependences in one steady-state loop iteration and determine whether any stall cycles are required. Then, derive a closed-form symbolic expression for the steady-state Cycles Per Instruction (CPI) of this loop as a function of the taken-branch fraction $p$ and the taken-branch penalty $\\beta$. Express your final answer as a single analytic expression. The CPI is dimensionless; no units are required.",
            "solution": "The problem statement is critically evaluated for validity before proceeding to a solution.\n\n### Step 1: Extract Givens\n- Pipeline: $5$-stage (Instruction Fetch (IF), Instruction Decode (ID), Execute (EX), Memory Access (MEM), Write Back (WB)).\n- Microarchitecture: single-issue, full data forwarding from EX/MEM and MEM/WB registers to the EX stage inputs and EX stage comparator.\n- Caches: perfect instruction and data caches (no cache misses).\n- Hazards: No structural hazards. Loads are not present in the code.\n- Control Flow: A conditional branch (`BNE`) is resolved in the EX stage.\n- Branch Penalty: A taken branch incurs a penalty of $\\beta$ bubble cycles. A not-taken branch incurs $0$ bubble cycles.\n- Branch Behavior: The branch is taken with a long-run fraction (probability) of $p$, where $0 \\leq p \\leq 1$.\n- Code Sequence (Loop):\n  1. `ADD R2, R2, R3`\n  2. `SUB R4, R2, R5`\n  3. `ADD R1, R1, R11`\n  4. `BNE R1, R12, LOOP`\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded, describing a standard RISC pipeline model commonly used in computer architecture education and analysis. The concepts of data forwarding, control hazards, and Cycles Per Instruction (CPI) are well-defined. The problem is well-posed, providing all necessary parameters ($\\beta$, $p$) and a clear code segment to derive a unique symbolic expression for CPI. The language is objective and precise. The givens are internally consistent and do not violate any fundamental principles of computer organization. The specified forwarding paths are sufficient to handle the data dependencies present in the code, which will be demonstrated in the solution. The problem is not trivial, as it requires careful analysis of both data and control hazards.\n\n### Step 3: Verdict and Action\nThe problem is deemed **valid**. A full solution will be derived.\n\n### Solution Derivation\nThe objective is to derive a closed-form symbolic expression for the steady-state Cycles Per Instruction (CPI) of the provided loop. This requires analyzing both data and control hazards.\n\nLet the four instructions in the loop be denoted as follows:\n- $I_1$: `ADD R2, R2, R3`\n- $I_2$: `SUB R4, R2, R5`\n- $I_3$: `ADD R1, R1, R11`\n- $I_4$: `BNE R1, R12, LOOP`\n\n**1. Data Hazard Analysis**\n\nWe identify the Read-After-Write (RAW) data dependencies in the code:\n- **Dependency on $R2$**: $I_1$ writes to register $R2$, and $I_2$ reads from $R2$.\n- **Dependency on $R1$**: $I_3$ writes to register $R1$, and $I_4$ reads from $R1$ for the branch comparison.\n\nLet's trace the pipeline execution to determine if these dependencies cause stalls. A stall is required if the result of a producer instruction is not available when the consumer instruction needs it.\n\n*Analysis of the $I_1 \\rightarrow I_2$ dependency:*\nInstruction $I_1$ (ADD) computes its result in the EX stage. This result is available for forwarding at the end of the clock cycle where $I_1$ is in its EX stage. Instruction $I_2$ (SUB) requires the value of $R2$ as an input to the ALU at the beginning of its EX stage.\nConsider the pipeline timing diagram for a single iteration without any stalls:\n- Cycle $k$: $I_1$ is in EX stage.\n- Cycle $k+1$: $I_1$ is in MEM stage, $I_2$ is in EX stage.\n\nAt cycle $k+1$, the result of $I_1$ is present in the EX/MEM pipeline register. The problem states that the pipeline has \"full data forwarding... from the EX/MEM... pipeline registers into the EX stage inputs\". Therefore, the result of $I_1$ can be forwarded directly to the ALU input for $I_2$ in cycle $k+1$. No stall is necessary to resolve this dependency.\n\n*Analysis of the $I_3 \\rightarrow I_4$ dependency:*\nInstruction $I_3$ (ADD) computes its result for $R1$ in its EX stage. Instruction $I_4$ (BNE) needs this value of $R1$ in its EX stage to perform the comparison.\nConsider the pipeline timing for these instructions:\n- Cycle $m$: $I_3$ is in EX stage.\n- Cycle $m+1$: $I_3$ is in MEM stage, $I_4$ is in EX stage.\n\nSimilar to the first case, at cycle $m+1$, the new value of $R1$ from $I_3$ is available in the EX/MEM pipeline register. The problem specifies that forwarding is available \"into the EX stage comparator for branches\". Thus, the new value of $R1$ can be forwarded to the comparator logic in the EX stage for $I_4$. No stall is necessary for this dependency either.\n\nConclusion on data hazards: Due to the specified full forwarding hardware, no stall cycles are incurred because of data dependencies within the loop body.\n\n**2. Control Hazard and CPI Calculation**\n\nThe CPI is defined as the total number of cycles divided by the total number of instructions. For a steady-state loop, we can calculate this as the average number of cycles per loop iteration divided by the number of instructions per iteration.\n\nThe number of instructions per iteration, $N_{instr}$, is $4$.\n\nIn the absence of any hazards, a single-issue pipeline has an ideal CPI of $1$. In such a scenario, one loop iteration would complete in $4$ cycles in the steady state. However, the `BNE` instruction ($I_4$) introduces a potential control hazard.\n\nThe branch outcome is determined in the EX stage of $I_4$. We must consider two cases:\n\n*Case A: Branch is not taken*\nThis occurs with a probability of $(1-p)$. The pipeline is assumed to predict that the branch is not taken (a common static prediction scheme), so it continues fetching instructions sequentially. When $I_4$ is resolved in its EX stage and found to be not taken, the instructions already fetched are the correct ones. The problem states that in this case, $0$ bubble cycles are incurred.\nThe number of cycles for this iteration is simply the number of instructions: $C_{not\\_taken} = 4$.\n\n*Case B: Branch is taken*\nThis occurs with a probability of $p$. When $I_4$ is in its EX stage, the pipeline discovers that the branch is taken. At this point, the instructions for the next iteration have been fetched from the wrong path (sequentially). These instructions must be flushed from the pipeline, and fetching must restart at the branch target (`LOOP`). The problem specifies this costs $\\beta$ bubble cycles.\nThe number of cycles for this iteration is the number of instructions plus the penalty: $C_{taken} = 4 + \\beta$.\n\n*Average Cycles per Iteration*\nThe average number of cycles per loop iteration, $\\bar{C}_{iter}$, is the weighted average of the cycles in each case:\n$$ \\bar{C}_{iter} = C_{not\\_taken} \\cdot (1-p) + C_{taken} \\cdot p $$\n$$ \\bar{C}_{iter} = 4 \\cdot (1-p) + (4 + \\beta) \\cdot p $$\n$$ \\bar{C}_{iter} = 4 - 4p + 4p + \\beta p $$\n$$ \\bar{C}_{iter} = 4 + \\beta p $$\n\n*Final CPI Calculation*\nThe steady-state CPI is the average cycles per iteration divided by the number of instructions per iteration:\n$$ \\text{CPI} = \\frac{\\bar{C}_{iter}}{N_{instr}} $$\n$$ \\text{CPI} = \\frac{4 + \\beta p}{4} $$\n$$ \\text{CPI} = 1 + \\frac{\\beta p}{4} $$\n\nThis expression represents the steady-state CPI as a function of the taken-branch fraction $p$ and the taken-branch penalty $\\beta$. The base CPI is $1$, and the additional term $\\frac{\\beta p}{4}$ represents the performance penalty due to control hazards, averaged over all instructions in the loop.",
            "answer": "$$\\boxed{1 + \\frac{\\beta p}{4}}$$"
        }
    ]
}