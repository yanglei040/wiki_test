{
    "hands_on_practices": [
        {
            "introduction": "To effectively mitigate control hazards, we must first understand how to quantify their impact. This foundational exercise guides you through calculating the misprediction penalty for a simple static predictor in a classic five-stage RISC pipeline. By tracing the flow of instructions after a mispredicted branch, you will see precisely why and how many cycles are lost, establishing the baseline cost that more advanced techniques aim to reduce. ",
            "id": "3630214",
            "problem": "A single-issue, five-stage Reduced Instruction Set Computer (RISC) pipeline executes instructions in the stages Instruction Fetch (IF), Instruction Decode (ID), Execute (EX), Memory (MEM), and Write Back (WB). Control dependence is handled using a static branch predictor that always predicts branches as taken. A Branch Target Buffer (BTB) supplies the predicted-taken target address in IF, so when the prediction is correct, instruction fetch proceeds from the target without stalls. The branch condition is resolved in EX, and upon a misprediction, all younger instructions in the pipeline are flushed, and fetch is redirected to the correct path on the next cycle. There are no architectural branch delay slots, no early target or condition resolution before EX, and no other structural or data hazards.\n\nConsider a tight loop whose body ends with a single conditional backward branch that forms the loop back edge. The loop executes for $n \\geq 1$ iterations, so that the branch outcome is taken for the first $n-1$ iterations and not taken on the $n$-th iteration to exit the loop. Under the always-taken predictor described above, the only misprediction arises on the final iteration when the branch is actually not taken. Assume there are no other branches inside the loop body.\n\nUsing only the above fundamentals about pipeline staging and branch handling, determine the total control-hazard penalty, in cycles, paid per completed loop (that is, across the full $n$ iterations). Express your answer as a single exact integer number of cycles, and use cycles as the unit for interpretation (do not include units in your final boxed answer). No rounding is required.",
            "solution": "The problem is first validated to ensure it is self-contained, scientifically grounded, and well-posed.\n\n### Step 1: Extract Givens\n- **Pipeline Structure**: A single-issue, five-stage RISC pipeline with stages: Instruction Fetch (IF), Instruction Decode (ID), Execute (EX), Memory (MEM), and Write Back (WB).\n- **Branch Handling**:\n    - **Predictor**: Static branch predictor that always predicts branches as taken.\n    - **Branch Target Buffer (BTB)**: Supplies the predicted-taken target address in the IF stage.\n    - **Correct Prediction**: When a 'taken' prediction is correct, there are no stalls.\n    - **Resolution**: The branch condition is resolved in the EX stage.\n    - **Misprediction**: On a misprediction, all younger instructions are flushed, and fetch is redirected on the next cycle.\n- **Exclusions**: No architectural branch delay slots, no early resolution before the EX stage, and no other structural or data hazards.\n- **Scenario**: A tight loop that executes for $n \\geq 1$ iterations.\n- **Loop Branch**: A single conditional backward branch at the end of the loop body.\n- **Branch Outcomes**:\n    - The branch is 'taken' for the first $n-1$ iterations.\n    - The branch is 'not taken' on the $n$-th (final) iteration.\n- **Objective**: Determine the total control-hazard penalty, in cycles, for one complete execution of the loop (i.e., across all $n$ iterations).\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem describes a classic 5-stage RISC pipeline, a standard pedagogical model in computer organization and architecture. The concepts of static branch prediction, BTB functionality, pipeline flushing, and branch resolution in the EX stage are fundamental and factually sound principles.\n- **Well-Posed**: The problem is clearly defined. It provides all necessary parameters of the pipeline and branch handling mechanism to calculate a specific, unique numerical value for the penalty.\n- **Objective**: The problem is stated using precise, standard terminology from the field of computer architecture, free from any subjectivity or ambiguity.\n\n### Step 3: Verdict and Action\nThe problem is valid as it is scientifically sound, well-posed, objective, and self-contained. A definitive solution can be derived from the given information.\n\n### Solution Derivation\n\nThe total control-hazard penalty for the entire loop is the sum of the penalties incurred at each branch instance. The loop contains one branch, which is executed $n$ times. We must analyze the penalty for each of these $n$ executions.\n\nThe branch predictor is a static 'always-taken' predictor. We evaluate its performance for the two types of branch outcomes.\n\n1.  **First $n-1$ Iterations (Correctly Predicted Branches)**\n    For the first $n-1$ iterations, the backward branch is taken to continue the loop.\n    - **Prediction**: Always-Taken.\n    - **Actual Outcome**: Taken.\n    - **Result**: The prediction is correct.\n    The problem statement specifies that \"when the prediction is correct, instruction fetch proceeds from the target without stalls.\" This means the penalty for each of these correct predictions is $0$ cycles.\n    The total penalty for the first $n-1$ iterations is $(n-1) \\times 0 = 0$ cycles.\n\n2.  **The $n$-th Iteration (Mispredicted Branch)**\n    On the final iteration, the branch is not taken to exit the loop.\n    - **Prediction**: Always-Taken.\n    - **Actual Outcome**: Not-Taken.\n    - **Result**: The prediction is incorrect, causing a misprediction. A penalty is incurred.\n\nTo calculate the misprediction penalty, we must analyze the state of the pipeline. The branch instruction's outcome is determined in the EX stage. The EX stage is the 3rd stage of the 5-stage pipeline.\n\nLet the branch instruction be $B$.\n- **Cycle $t$**: $B$ is in the IF stage. The predictor identifies it as a branch and predicts 'taken'. The Branch Target Buffer (BTB) supplies the target address, and the Program Counter (PC) is updated to this target address.\n- **Cycle $t+1$**: $B$ moves to the ID stage. The first instruction from the (wrongly) predicted target path, let's call it $I_1$, enters the IF stage.\n- **Cycle $t+2$**: $B$ moves to the EX stage. $I_1$ moves to the ID stage. The second instruction from the wrong path, $I_2$, enters the IF stage. At the end of this cycle, the EX unit resolves the branch and discovers it was not taken. The prediction was wrong.\n\nAt the moment the misprediction is detected (end of cycle $t+2$), the following younger, speculatively executed instructions are in the pipeline and must be flushed:\n- Instruction $I_1$ in the ID stage.\n- Instruction $I_2$ in the IF stage.\n\nThese two instructions are discarded. The CPU time spent fetching and decoding them is wasted. The problem states that fetch is redirected to the correct path on the next cycle, which is cycle $t+3$. In cycle $t+3$, the pipeline will fetch the correct instruction that sequentially follows the branch, $B+1$.\n\nThe penalty is the number of cycles lost due to fetching and processing instructions on the wrong path. The number of such instructions corresponds to the number of pipeline stages before the stage where the branch is resolved.\n- Branch resolution stage: EX (stage $3$).\n- Preceding stages: IF (stage $1$) and ID (stage $2$).\nThere are $2$ stages before the EX stage. Therefore, $2$ instructions are wrongly fetched and must be flushed. This results in a pipeline bubble of $2$ cycles.\n\nThe penalty for the single misprediction is $2$ cycles.\n\n**Total Penalty Calculation**\n\nThe total penalty for the entire loop execution is the sum of penalties from all $n$ branch executions.\n$$ \\text{Total Penalty} = \\left( (n-1) \\times \\text{Penalty}_{\\text{correct prediction}} \\right) + \\left( 1 \\times \\text{Penalty}_{\\text{misprediction}} \\right) $$\nSubstituting the calculated values:\n$$ \\text{Total Penalty} = \\left( (n-1) \\times 0 \\right) + \\left( 1 \\times 2 \\right) $$\n$$ \\text{Total Penalty} = 0 + 2 = 2 $$\nThe total control-hazard penalty paid per completed loop is $2$ cycles, regardless of the number of iterations $n$ (for $n \\geq 1$).",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "While static predictors are simple, modern processors rely on dynamic predictors that adapt to a program's behavior. This practice delves into the mechanics of a common 2-bit saturating counter, challenging you to model its state transitions in response to a repeating branch pattern. Analyzing its steady-state behavior will build your intuition for how a predictor's performance is intrinsically linked to the history of branch outcomes. ",
            "id": "3630181",
            "problem": "A pipelined processor employs a bimodal $2$-bit saturating counter branch predictor with a single predictor entry dedicated to a single static branch. The predictor has $4$ states labeled $0$, $1$, $2$, and $3$. It predicts taken for states $2$ and $3$, and predicts not-taken for states $0$ and $1$. On each branch outcome, the state increments by $1$ on a taken outcome and decrements by $1$ on a not-taken outcome, saturating at $3$ and $0$ respectively. The initial predictor state is arbitrary. Consider a repeating outcome pattern for this branch that consists of $(k-2)$ consecutive taken outcomes followed by $2$ consecutive not-taken outcomes, repeating with period $k$, where $k \\ge 2$. Let $m(k)$ denote the steady-state mispredict rate, calculated as the number of mispredictions in one full period of the predictor's stable cycle divided by the period length, $k$. Derive $m(k)$ as a function of $k$ and present your final answer as a single closed-form analytical expression. No rounding is required. The answer is dimensionless.",
            "solution": "The problem asks for the steady-state mispredict rate, $m(k)$, of a specific $2$-bit bimodal branch predictor for a repeating branch outcome pattern. The analysis requires determining the periodic behavior of the predictor's state and counting the number of mispredictions within that period.\n\nFirst, let us formalize the model of the $2$-bit saturating counter.\nThe state of the predictor, $S$, can be one of four values: $S \\in \\{0, 1, 2, 3\\}$.\nThe prediction rule is as follows:\n- If $S \\in \\{0, 1\\}$, predict 'Not-Taken' (NT).\n- If $S \\in \\{2, 3\\}$, predict 'Taken' (T).\n\nThe state transition rule, given a current state $S$ and a branch outcome $O$, results in a new state $S'$:\n- If the outcome $O$ is 'Taken' (T), the new state is $S' = \\min(S+1, 3)$.\n- If the outcome $O$ is 'Not-Taken' (NT), the new state is $S' = \\max(S-1, 0)$.\n\nA misprediction occurs when the predicted outcome does not match the actual outcome $O$.\n\nThe branch outcome pattern is a sequence of period $k \\ge 2$, consisting of $(k-2)$ consecutive 'Taken' outcomes followed by $2$ consecutive 'Not-Taken' outcomes. The pattern is $(\\underbrace{\\text{T}, \\text{T}, \\dots, \\text{T}}_{k-2 \\text{ times}}, \\text{NT}, \\text{NT})$.\n\nWe are interested in the steady-state mispredict rate, $m(k)$, which is the number of mispredictions in one period of the stable cycle, divided by the period $k$. To find this, we must first identify the repeating cycle of states the predictor enters. Let $S_0$ be the state at the beginning of a period in the steady state. After $k$ branches, the state must return to $S_0$. Let's denote the state after the $i$-th branch in the period as $S_i$. The steady-state condition is $S_k = S_0$. We analyze the problem by considering different cases for the value of $k$.\n\n### Case 1: $k=2$\nThe pattern has a period of $k=2$. It consists of $(2-2)=0$ 'Taken' outcomes and $2$ 'Not-Taken' outcomes. The pattern is (NT, NT).\nThis sequence of outcomes will drive the counter state towards $0$. Let's assume the system has reached a steady state, which must be $S_0=0$.\n- Start at $S_0=0$. The prediction is NT. The first outcome is NT. This is a **correct** prediction. The new state is $S_1 = \\max(0-1, 0) = 0$.\n- The state is $S_1=0$. The prediction is NT. The second outcome is NT. This is a **correct** prediction. The new state is $S_2 = \\max(0-1, 0) = 0$.\nThe final state is $S_2=0$, which is equal to the starting state $S_0=0$. Thus, the steady-state cycle is a constant state $S=0$.\nThe number of mispredictions in this period is $0$.\nThe mispredict rate is $m(2) = \\frac{0}{2} = 0$.\n\n### Case 2: $k=3$\nThe pattern has a period of $k=3$. It consists of $(3-2)=1$ 'Taken' outcome and $2$ 'Not-Taken' outcomes. The pattern is (T, NT, NT).\nThe pattern has more NTs than Ts, which suggests the steady-state will be in a low-valued state. Let's test for a steady-state cycle starting at $S_0=0$.\n- Start at $S_0=0$. The prediction is NT. The first outcome is T. This is a **misprediction**. The new state is $S_1 = \\min(0+1, 3) = 1$.\n- The state is $S_1=1$. The prediction is NT. The second outcome is NT. This is a **correct** prediction. The new state is $S_2 = \\max(1-1, 0) = 0$.\n- The state is $S_2=0$. The prediction is NT. The third outcome is NT. This is a **correct** prediction. The new state is $S_3 = \\max(0-1, 0) = 0$.\nThe final state is $S_3=0$, which equals the starting state $S_0=0$. This is a stable cycle.\nThe number of mispredictions in this period is $1$.\nThe mispredict rate is $m(3) = \\frac{1}{3}$.\n\n### Case 3: $k \\ge 4$\nThe pattern has a period of $k$, consisting of $(k-2)$ 'Taken' outcomes and $2$ 'Not-Taken' outcomes.\nLet's find the steady-state starting state $S_0$. The state after one period, $S_k$, is a function of $S_0$ and $k$. After the $(k-2)$ 'Taken' branches, the state becomes $S' = \\min(S_0 + k - 2, 3)$. After the subsequent $2$ 'Not-Taken' branches, the final state is $S_k = \\max(S' - 2, 0) = \\max(\\min(S_0 + k - 2, 3) - 2, 0)$.\nFor a steady state, we must have $S_k = S_0$.\nLet's assume the counter saturates during the 'Taken' sequence, i.e., $S_0 + k - 2 \\ge 3$, which means $S_0 \\ge 5-k$. If this holds, then $S' = 3$. The equation for $S_0$ becomes $S_0 = \\max(3-2, 0) = 1$.\nThis solution $S_0=1$ is self-consistent if it satisfies the assumption $S_0 \\ge 5-k$. Substituting $S_0=1$, we get $1 \\ge 5-k$, which simplifies to $k \\ge 4$.\nThus, for all $k \\ge 4$, there exists a steady-state cycle that begins with the state $S_0=1$. (For $k=4$, another cycle starting at $S_0=0$ also exists, but both yield the same misprediction count of $3$).\nLet's trace the execution for one period starting from $S_0=1$ for $k \\ge 4$:\n- The first outcome is T. The state is $S_0=1$ (predict NT). This is a **misprediction**. The new state is $S_1 = \\min(1+1, 3) = 2$.\n- The second outcome is T. The state is $S_1=2$ (predict T). This is a **correct** prediction. The new state is $S_2 = \\min(2+1, 3) = 3$.\n- For the subsequent $(k-2)-2 = k-4$ 'Taken' outcomes, the state remains $S=3$ (predict T). These are all **correct** predictions. After all $(k-2)$ 'Taken' outcomes, the state is $S_{k-2}=3$.\n- The $(k-1)$-th outcome is NT. The state is $S_{k-2}=3$ (predict T). This is a **misprediction**. The new state is $S_{k-1} = \\max(3-1, 0) = 2$.\n- The $k$-th outcome is NT. The state is $S_{k-1}=2$ (predict T). This is a **misprediction**. The new state is $S_k = \\max(2-1, 0) = 1$.\nThe final state is $S_k=1$, which equals the starting state $S_0=1$. This confirms the stable cycle.\nThe total number of mispredictions in one period is the sum of mispredictions from each step: $1 + 0 + 1 + 1 = 3$.\nThe mispredict rate for $k \\ge 4$ is $m(k) = \\frac{3}{k}$.\n\n### Summary of Results\nCombining the results from all cases, the steady-state mispredict rate $m(k)$ is a piecewise function of $k$:\n- For $k=2$, $m(2) = 0$.\n- For $k=3$, $m(3) = \\frac{1}{3}$.\n- For $k \\ge 4$, $m(k) = \\frac{3}{k}$.\n\nThis can be expressed as a single analytical expression using a piecewise definition.\n$$\nm(k) = \\begin{cases} 0 & \\text{if } k=2 \\\\ \\frac{1}{k} & \\text{if } k=3 \\\\ \\frac{3}{k} & \\text{if } k \\ge 4 \\end{cases}\n$$\nNote that for $k=3$, the expression $1/k$ yields $1/3$, as required.",
            "answer": "$$\n\\boxed{\n\\begin{cases} 0 & k=2 \\\\ \\frac{1}{k} & k=3 \\\\ \\frac{3}{k} & k \\ge 4 \\end{cases}\n}\n$$"
        },
        {
            "introduction": "Solving control hazards often involves complex engineering trade-offs, as there is no single best solution for all scenarios. This problem compares two powerful techniques for handling conditional logic: dynamic branch prediction and predication (if-conversion). By deriving the performance crossover point, you will learn to model and weigh competing factors, such as misprediction penalties versus the overhead of executing extra instructions and increased register pressure. ",
            "id": "3630253",
            "problem": "A scalar, in-order, five-stage pipeline with stages Fetch, Decode, Execute, Memory, and Writeback is used to run an if-else block. A conditional branch resolves in the Execute stage and, when mispredicted, incurs a pipeline flush penalty of $b$ cycles. The dynamic branch predictor has a steady-state accuracy of $a$, so the misprediction probability is $1-a$. Assume single-issue execution with no structural hazards and that each non-memory instruction takes $1$ cycle in the absence of stalls.\n\nConsider a short if-else block with a \"then\" path of $L_{t}$ arithmetic or logic instructions and an \"else\" path of $L_{f}$ arithmetic or logic instructions. The conditional evaluation itself requires one compare instruction. Under dynamic branch prediction, one branch instruction is also executed. Under predication (if-conversion), the compare instruction sets a predicate and the branch is eliminated; the predicated form executes both the \"then\" and \"else\" path instructions.\n\nIf-conversion increases live ranges and requires $r$ additional registers beyond the baseline allocator capacity. These $r$ registers are spilled in the predicated version, each causing one store before the block and one load after the block. Assume each spill memory operation hits in the Level-1 data cache (L1) and incurs an effective cost of $c$ cycles, inclusive of any stall and pipeline effects. The baseline branched version does not require these additional $r$ registers and therefore has no spill cost.\n\nUsing first principles of expected execution time for control flow under dynamic prediction and predication, and the above architectural model, derive an analytic expression for the branch-taken probability threshold $p^{\\star}$ at which the predicated version has equal expected cycle count to the dynamically predicted branched version. Your expression must be in closed form as a function of $L_{t}$, $L_{f}$, $a$, $b$, $c$, and $r$. You may assume $L_{t} \\neq L_{f}$. Express your final answer as a single analytical expression with no units. Do not round your answer.",
            "solution": "The problem statement is evaluated to be valid. It is scientifically grounded in the principles of computer architecture, specifically performance analysis of control flow mechanisms. It is well-posed, objective, self-contained, and devoid of contradictions or ambiguities. All necessary parameters for the derivation are provided symbolically.\n\nThe objective is to derive an analytical expression for the branch-taken probability threshold, denoted as $p^{\\star}$, at which the expected execution cycle count of a dynamically predicted branched implementation equals that of a predicated (if-converted) implementation.\n\nLet $E_B$ be the expected cycle count for the branched version and $E_P$ be the cycle count for the predicated version. The threshold $p^{\\star}$ is the value of the branch-taken probability $p$ for which $E_B = E_P$.\n\nFirst, we determine the cycle count for the predicated version, $E_P$.\nIn the predicated version, the branch instruction is eliminated. All instructions from both the 'then' and 'else' paths are fetched and executed, with their results committed or squashed based on the predicate value.\nThe total number of instructions executed within the block is:\n- $1$ compare instruction.\n- $L_t$ instructions from the 'then' path.\n- $L_f$ instructions from the 'else' path.\nSince each non-memory instruction takes $1$ cycle, the cycle count for these instructions is $1 + L_t + L_f$.\n\nAdditionally, the predicated version requires $r$ additional registers, which are spilled to memory. Each spill consists of one store instruction before the block and one load instruction after the block. The total number of memory operations due to spilling is $2r$. Each of these memory operations incurs an effective cost of $c$ cycles.\nThe total cost from register spilling is therefore $2rc$.\n\nThe total cycle count for the predicated version is the sum of the instruction execution cycles and the spill cost:\n$$E_P = (1 + L_t + L_f) + 2rc$$\n\nNext, we determine the expected cycle count for the dynamically predicted branched version, $E_B$. This cost depends on the branch-taken probability $p$ and the branch predictor's accuracy $a$.\nThe code block in this version consists of:\n- $1$ compare instruction.\n- Instructions from either the 'then' or 'else' path.\n- $1$ branch instruction.\n\nIf the branch is taken (probability $p$), $L_t$ instructions are executed. The total instructions in this path are $1 + L_t + 1 = L_t + 2$.\nIf the branch is not taken (probability $1-p$), $L_f$ instructions are executed. The total instructions in this path are $1 + L_f + 1 = L_f + 2$.\n\nThe expected number of instructions executed is the weighted average over these two outcomes:\n$$E[\\text{instructions}] = p(L_t + 2) + (1-p)(L_f + 2)$$\nExpanding and simplifying this expression:\n$$E[\\text{instructions}] = pL_t + 2p + L_f + 2 - pL_f - 2p = p(L_t - L_f) + L_f + 2$$\n\nIn addition to instruction execution, we must account for the pipeline stall penalty from branch mispredictions. The problem states the predictor has an accuracy of $a$, so the misprediction probability is $1-a$. A misprediction incurs a penalty of $b$ cycles. The penalty is applied regardless of whether the branch was taken or not-taken, as long as the prediction was incorrect.\nThe expected cycle penalty from misprediction is the probability of misprediction multiplied by the penalty:\n$$E[\\text{penalty}] = (1-a)b$$\n\nThe total expected cycle count for the branched version is the sum of the expected instruction cycles and the expected penalty:\n$$E_B = E[\\text{instructions}] + E[\\text{penalty}] = p(L_t - L_f) + L_f + 2 + b(1-a)$$\n\nTo find the threshold probability $p^{\\star}$, we set the costs equal: $E_B = E_P$ at $p = p^{\\star}$.\n$$p^{\\star}(L_t - L_f) + L_f + 2 + b(1-a) = 1 + L_t + L_f + 2rc$$\n\nNow, we solve for $p^{\\star}$. We begin by isolating the term containing $p^{\\star}$.\n$$p^{\\star}(L_t - L_f) = (1 + L_t + L_f + 2rc) - (L_f + 2 + b(1-a))$$\nWe can cancel the $L_f$ terms from both sides of the parenthesis content:\n$$p^{\\star}(L_t - L_f) = 1 + L_t + 2rc - 2 - b(1-a)$$\n$$p^{\\star}(L_t - L_f) = L_t - 1 + 2rc - b(1-a)$$\n\nThe problem states that $L_t \\neq L_f$, which ensures that $(L_t - L_f) \\neq 0$. Therefore, we can divide by $(L_t - L_f)$ to find the final expression for $p^{\\star}$:\n$$p^{\\star} = \\frac{L_t - 1 + 2rc - b(1-a)}{L_t - L_f}$$\n\nThis is the analytic expression for the branch-taken probability threshold at which the performance of the two control flow strategies is identical.",
            "answer": "$$\\boxed{\\frac{L_t - 1 + 2rc - b(1-a)}{L_t - L_f}}$$"
        }
    ]
}