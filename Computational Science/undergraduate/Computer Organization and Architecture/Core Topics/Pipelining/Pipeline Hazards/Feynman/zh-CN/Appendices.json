{
    "hands_on_practices": [
        {
            "introduction": "解决流水线冒险并不仅仅是硬件设计师的任务，它常常需要软件和硬件的协同。这个练习将引导您探索控制冒险以及编译器优化与微体系结构之间的强大互动 。通过分析一个由于深度递归而导致返回地址栈（$RAS$）溢出的场景，您将了解到像尾调用优化这样的编译器技术如何能直接解决硬件瓶颈，从而显著减少控制冒险带来的性能损失。",
            "id": "3664987",
            "problem": "考虑一个单发射、按序流水线，它包含以下$6$个阶段：取指令（IF，阶段$1$）、指令译码（ID，阶段$2$）、寄存器读取（RR，阶段$3$）、执行（EX，阶段$4$）、访存（MEM，阶段$5$）和写回（WB，阶段$6$）。包括函数返回在内的控制转移，在返回指令到达执行（EX）阶段时被确定。此时，如果预测的下一程序计数器不正确，所有在更早阶段的更年轻的指令都将被冲刷。\n\n一个动态预测器使用一个容量为$C$个条目的返回地址栈（RAS）。RAS在函数调用时存储返回地址，并在返回时提供这些地址。假设：\n- 每个阶段恰好占用$1$个周期。\n- 一次预测错误的返回会导致在返回指令被确定时，冲刷所有更早的流水线阶段。\n- 该递归在主要计算之后是自尾递归的，因此每次调用都会对自身执行一次尾调用，直到满足基本情况。\n- 除了返回指令之外的所有非返回的控制转移都被完美预测。\n\n一个编译器未对某个特定的递归函数执行尾调用优化，该函数的最大递归深度达到$D = 50$层（包括基本情况）。微架构提供了一个容量为$C = 16$的RAS。当递归回溯时，超出RAS容量的返回会因为早前的溢出而弹出错误的地址，从而导致预测错误。\n\n请仅从流水线冒险（由未确定的分支目标引起的控制冒险）、流水线阶段时序以及返回地址栈（RAS）在溢出情况下的行为这些核心定义出发，推导在基准（无尾调用优化）情况下，由于返回预测错误导致的总停顿惩罚（以周期为单位）。然后，提出一种尾调用优化方案，将递归尾调用转换为一个等效的循环，从而消除递归调用链中每次调用产生的返回。在这种优化下，假设在循环结束时只有一个最终的返回，并且RAS永远不会溢出。\n\n计算与基准递归场景相比，通过尾调用优化净消除的停顿周期数。将您的最终答案表示为周期的精确整数值。无需四舍五入，最终答案框内也无需报告物理单位。",
            "solution": "我们从流水线冒险和预测器行为的基本概念开始：\n\n- 当下一程序计数器未能及早确定时，就会出现控制冒险，导致流水线可能沿着错误的路径取指。如果预测错误，必须冲刷掉在更早阶段的错误路径上已获取的指令，这会产生停顿周期。\n- 在一个包含从$1$到$6$编号的阶段的$6$级流水线中，如果一个控制转移在阶段$k$被确定，那么在确定时刻，有$k-1$个更早的阶段（阶段$1$到$k-1$）可能持有错误路径上的指令。在一个每阶段耗时一周期的简单按序流水线中，冲刷这些指令并重定向取指会产生$k-1$个周期的惩罚。\n- 返回地址栈（RAS）在调用时压入返回地址，并在匹配的返回时弹出该地址。如果递归深度$D$超过RAS容量$C$，那么超出容量$C$的压栈操作将覆盖或替换掉较旧的条目，因此最早的$D-C$次返回将弹出错误的地址。每一次这样的错误弹出都构成一次预测错误的返回。\n\n我们将这些原则应用于给定的流水线和递归过程：\n\n1. 在给定的流水线中，返回指令在执行（EX）阶段被确定，即阶段$k = 4$（IF是$1$，ID是$2$，RR是$3$，EX是$4$）。因此，一次预测错误的返回会产生如下的停顿惩罚：\n   $$ p = k - 1 = 4 - 1 = 3 \\text{ 周期}. $$\n\n2. 递归深度达到$D = 50$，而RAS容量为$C = 16$。在溢出情况下，回溯期间将弹出错误地址的返回次数为：\n   $$ N_{\\text{mispred}} = D - C = 50 - 16 = 34. $$\n\n3. 每次预测错误的返回都会产生$p = 3$个周期的惩罚。因此，在基准（无尾调用优化）场景中，由返回预测错误导致的总停顿惩罚为：\n   $$ S_{\\text{baseline}} = N_{\\text{mispred}} \\cdot p = 34 \\cdot 3 = 102. $$\n\n现在我们考虑尾调用优化：\n\n- 尾调用优化重写了自尾调用，使得函数不再为尾调用压入新的调用帧；相反，它变成了一个迭代直到满足基本情况的循环。这消除了递归链中每次调用产生的返回，从而消除了本会引起RAS溢出和预测错误的一系列返回操作。\n- 在优化下，循环结束后只有一个最终的返回。由于只有$1$次返回，而RAS容量为$C = 16$，因此不会发生溢出，RAS弹出的地址是正确的。根据假设，非返回的控制转移被完美预测，并且我们视最终的返回也被RAS正确处理。因此，优化后因返回预测错误产生的停顿惩罚为：\n  $$ S_{\\text{optimized}} = 0. $$\n\n通过尾调用优化，相对于基准情况，净消除的停顿周期数为：\n$$ \\Delta S = S_{\\text{baseline}} - S_{\\text{optimized}} = 102 - 0 = 102. $$\n\n因此，节省的确切整数周期数为$102$。",
            "answer": "$$\\boxed{102}$$"
        },
        {
            "introduction": "流水线设计的精髓在于细节。本练习将带您深入到冒险检测单元这一核心部件的设计层面，挑战您像微体系结构设计师一样思考 。您将首先构建一个由子字操作（subword operations）引起的“伪冒险”（false hazard）场景，然后进一步推导和量化实现一个更精确的、基于字节掩码的依赖性检测逻辑所需的硬件复杂度，从而体会到处理器设计中性能与成本之间的权衡。",
            "id": "3665019",
            "problem": "一台具有 $64$ 位通用寄存器的标量机支持子字操作，这些操作可以读取或写入寄存器内大小为 $1$、$2$、$4$ 或 $8$ 字节的连续且自然对齐的字段。该流水线目前使用一种简单的写后读（RAW）依赖检查规则：一条读取寄存器 $r$ 的较新指令被认为与任何写入寄存器 $r$ 的正在执行的较旧指令存在 RAW 依赖，无论实际读写的是哪个子字字段。\n\nA 部分（概念设置）：构建一个双指令序列，在意图层面（命名访问了哪些子字字段）表达，该序列在上述简单规则下会触发 RAW 假阳性，但由于写入和读取的子字不相交，因此没有真正的数据依赖。你可以假设有一条通用的算术指令，它只读取源寄存器的高 $32$ 位；以及一条字节写指令，它只写入目标寄存器的最低 $8$ 位。\n\nB 部分（推导与计算）：为了在不错过真正冒险的情况下消除此类假阳性，你重新设计了冒险检测单元以跟踪逐字节掩码。对于每条将写入某个目标寄存器 $d_{j}$ 的正在执行的较旧指令 $j$，你存储：\n- 一个寄存器标识符，以及\n- 一个 $8$ 位写掩码 $W_{j}$，其中位 $k \\in \\{0,\\dots,7\\}$ 表示 $d_{j}$ 的第 $k$ 个字节是否将被写入。\n\n对于新译码指令的每个源操作数 $i$，你获得：\n- 一个寄存器标识符 $r_{i}$，以及\n- 一个 $8$ 位读掩码 $R_{i}$，其中位 $k$ 表示 $r_{i}$ 的第 $k$ 个字节是否将被读取。\n\n源操作数 $i$ 和较旧指令 $j$ 之间存在真正的 RAW，当且仅当 $r_{i} = d_{j}$ 且访问的字节交集非空，即当且仅当按位交集 $W_{j} \\wedge R_{i}$ 至少有一个 $1$ 位。\n\n请你量化在译码阶段为一条新译码指令评估 RAW 冒险时，每周期所需的基于掩码的最小依赖跟踪复杂性，以位级操作的数量来衡量，并遵循以下约束：\n- 与 RAW 检查相关的正在执行的较旧的写指令最多有 $f$ 条。\n- 新指令最多有 $r$ 个源操作数。\n- 冒险单元必须在一个周期内计算所有成对的掩码重叠 $W_{j} \\wedge R_{i}$，无需时间复用（即，所有需要的按位与操作都在该周期内执行）。\n- 你只需计算用于形成这些成对的重叠向量的 $1$ 位与操作的数量（忽略寄存器标识符的相等性比较和用于测试非空性的任何或-规约的成本）。\n\n从第一性原理出发，推导所需最小 $1$ 位与操作数量的封闭形式表达式，该表达式是 $r$、$f$ 和每个寄存器的字节数 $b$ 的函数。然后，使用 $r = 3$、$f = 24$ 和 $b = 8$ 对此表达式求值。以一个数字表示最终答案。不需要单位，也无需四舍五入。",
            "solution": "**A 部分：概念上的 RAW 假阳性冒险**\n\n当硬件在一个实际上不存在数据依赖的场景中检测到依赖关系时，就会发生写后读（RAW）假阳性冒险，这会导致不必要的流水线停顿。在涉及子字操作时，仅在整个寄存器级别检查依赖的简单规则很容易出现此类错误。\n\n让我们构建一个由两条指令组成的序列，一条是较旧的指令 $I_1$，另一条是较新的指令 $I_2$，它们都操作同一个 $64$ 位寄存器，我们称之为 $R_A$。一个 $64$ 位寄存器由 $8$ 个字节组成，我们可以将它们从字节 $0$（最低有效）到字节 $7$（最高有效）进行索引。\n\n1.  **较旧的指令, $I_1$**：根据题目描述，这是一条字节写指令。它向寄存器 $R_A$ 写入一个值，但只修改最低的字节。\n    - **操作**：写入寄存器 $R_A$ 的字节 $0$（位 $7$ 到位 $0$）。\n    - **写入的字节**：$\\{0\\}$\n\n2.  **较新的指令, $I_2$**：根据题目描述，这是一条算术指令。它使用寄存器 $R_A$ 作为源操作数，但只需要存储在高 $32$ 位中的值。\n    - **操作**：读取高 $32$ 位，这对应于寄存器 $R_A$ 的高 $4$ 个字节。\n    - **读取的字节**：$\\{4, 5, 6, 7\\}$\n\n**依赖性分析：**\n\n- **简单规则的应用**：冒险检测单元看到 $I_1$ 写入寄存器 $R_A$，而后续指令 $I_2$ 从寄存器 $R_A$ 读取。根据其简单规则，它标记一个 RAW 依赖。这迫使流水线停顿 $I_2$ 直到 $I_1$ 完成其写回阶段。\n\n- **真实依赖性分析**：只有当 $I_1$ 的执行影响 $I_2$ 的结果时，才存在真正的数据依赖。在本例中，$I_1$ 写入的字节集是 $\\{0\\}$，$I_2$ 读取的字节集是 $\\{4, 5, 6, 7\\}$。这两个集合的交集为空：$\\{0\\} \\cap \\{4, 5, 6, 7\\} = \\emptyset$。因此，$I_2$ 读取的值完全独立于 $I_1$ 执行的写操作。简单检测器标记的 RAW 冒险是一个**假阳性**，导致的停顿是不必要的性能损失。\n\n**B 部分：硬件复杂度的推导与计算**\n\n重新设计的冒险检测单元旨在通过使用位掩码在字节级别跟踪依赖关系来消除这些假阳性。我们需要推导出一个表达式，表示每周期执行这种更精确检查所需的总 $1$ 位与操作数。\n\n设 $N$ 为 $1$ 位与操作的总数。\n给定的参数如下：\n- $r$：新译码指令的源操作数的最大数量。\n- $f$：正在执行的、写入寄存器的较旧指令的最大数量。\n- $b$：每个寄存器的字节数，也即读写掩码的长度。\n\n对于一个给定的源操作数 $i$ 和一条较旧的写指令 $j$，只有当寄存器标识符匹配且它们的字节掩码的按位与 ($W_j \\wedge R_i$) 非零时，才存在真正的 RAW 冒险。我们只计算形成所有成对重叠向量 $W_j \\wedge R_i$ 所需的 $1$ 位与操作的数量。\n\n1.  **每对操作数的计算**：对于由一个源操作数 $i$ 和一个较旧写指令 $j$ 组成的单对，我们需要计算它们掩码的按位与，$W_j \\wedge R_i$。由于每个掩码都是一个 $b$ 位向量，计算它们的按位与需要执行 $b$ 个独立的 $1$ 位与操作。\n\n2.  **配对总数**：硬件必须对新指令的每个源操作数与每条较旧的写指令进行并行检查。\n    - 源操作数数量 = $r$。\n    - 较旧的写指令数量 = $f$。\n    - 需要检查的配对总数是 $r \\times f$。\n\n3.  **总操作数**：$1$ 位与操作的总数 $N$ 是配对总数乘以每对所需的 $1$ 位与操作数。\n    $$ N = (\\text{配对总数}) \\times (\\text{每对的操作数}) $$\n    代入表达式：\n    $$ N = (r \\times f) \\times b $$\n    因此，封闭形式表达式为：\n    $$ N = rfb $$\n\n**特定参数的求值**：\n使用给定的值来评估此表达式：\n- $r = 3$\n- $f = 24$\n- $b = 8$ （对于 $64$ 位寄存器，即 $64/8 = 8$ 字节）\n\n将这些值代入表达式：\n$$ N = 3 \\times 24 \\times 8 $$\n$$ N = 72 \\times 8 $$\n$$ N = 576 $$\n因此，在一个周期内并行计算所有必要的重叠掩码，最少需要 $576$ 个 $1$ 位与操作。",
            "answer": "$$\\boxed{576}$$"
        }
    ]
}