{
    "hands_on_practices": [
        {
            "introduction": "为了掌握数据冒险的核心概念，我们首先从一个经典的五级流水线模型开始。这个练习旨在通过量化分析来揭示“写后读”（RAW）数据冒险所带来的性能损失，以及通过硬件转发技术所能获得的显著改进。通过计算在有和没有转发两种情况下的停顿周期，你将对停顿和旁路的基本原理建立起坚实的理解 。",
            "id": "3632040",
            "problem": "考虑一个具有五个阶段的顺序流水线：取指令 (IF)、指令译码和寄存器读取 (ID)、执行 (EX)、访存 (MEM) 和写回 (WB)。该机器每个时钟周期最多取一条并发射一条指令，并使用集中式冒险检测。对于此流水线，假设以下基本行为：\n- 每个阶段恰好占用一个时钟周期。\n- 所有指令状态更新均按程序顺序进行。\n- 寄存器文件是多端口的，因此可以在指令译码阶段读取两个操作数，并在写回阶段写入一个结果，而不会产生结构冲突。\n- 在同一个时钟周期内，写回阶段的寄存器写入先于指令译码阶段的任何寄存器读取完成。\n- 没有缓存或内存停顿，对于算术和逻辑指令，访存阶段只是直接通过而没有延迟。\n- 考虑两种情况：一种是没有任何结果转发，另一种是具有完全转发，即将算术和逻辑结果从执行阶段末尾和访存阶段末尾转发到后续周期中相关指令的执行阶段开始处。\n\n使用流水线执行中数据冒险的核心定义：当一条指令需要一个由先前指令产生的操作数，而该操作数在消耗点尚不可用时，就会发生写后读 (RAW) 冒险。在上述假设下，对于算术和逻辑指令，这种顺序流水线中不会出现读后写 (WAR) 冒险和写后写 (WAW) 冒险。\n\n考虑以下指令序列：\n- $I_1$: `ADD R1, R2, R3`，它将其结果写入 $R_1$。\n- $I_2$: `SUB R4, R1, R5`，它读取 $R_1$ 作为源操作数。\n\n从这些原则和假设出发，通过推导生产者结果何时可用以及消费者操作数在顺序流水线中何时需要的时间点，确定冒险检测单元为了保持 $I_1$ 和 $I_2$ 之间关于 $R_1$ 的单一 RAW 相关的正确性而必须插入的最少停顿周期数：\n- 首先，在如上所述的算术和逻辑结果完全转发的情况下。\n- 其次，在完全没有转发的情况下。\n\n以周期为单位，将您的最终答案报告为一对数 $\\left(x, y\\right)$，其中 $x$ 是有转发时的 RAW 停顿计数，而 $y$ 是没有转发时的 RAW 停顿计数。无需四舍五入。",
            "solution": "该问题已经过验证，并被确定为计算机体系结构领域中一个定义明确、有科学依据的问题。它为分析经典五级流水线中的数据冒险提供了一套完整且一致的假设。\n\n该问题要求在两种不同的硬件场景下，即有完全转发和无转发，解决两条指令之间的写后读 (RAW) 数据冒险所需的最少停顿周期数。流水线有五个阶段：取指令 ($\\mathrm{IF}$)、指令译码和寄存器读取 ($\\mathrm{ID}$)、执行 ($\\mathrm{EX}$)、访存 ($\\mathrm{MEM}$) 和写回 ($\\mathrm{WB}$)。每个阶段需要一个时钟周期。\n\n所考虑的指令序列是：\n- $I_1$: `ADD R1, R2, R3`\n- $I_2$: `SUB R4, R1, R5`\n\n在这里，指令 $I_1$ 是生产者，因为它将其结果写入寄存器 $R_1$。指令 $I_2$ 是消费者，因为它读取寄存器 $R_1$ 作为源操作数。这在 $I_1$ 和 $I_2$ 之间产生了关于寄存器 $R_1$ 的 RAW 数据相关。\n\n我们来分析这两条指令在顺序流水线中的执行过程，假设 $I_1$ 在周期 $1$ 被取指。由于每个周期发射一条指令，$I_2$ 在周期 $2$ 被取指。\n\n无停顿执行的流水线时序图如下所示：\n- 时钟周期 $1$：$I_1$ 处于 $\\mathrm{IF}$ 阶段。\n- 时钟周期 $2$：$I_1$ 处于 $\\mathrm{ID}$ 阶段，$I_2$ 处于 $\\mathrm{IF}$ 阶段。\n- 时钟周期 $3$：$I_1$ 处于 $\\mathrm{EX}$ 阶段，$I_2$ 处于 $\\mathrm{ID}$ 阶段。\n- 时钟周期 $4$：$I_1$ 处于 $\\mathrm{MEM}$ 阶段，$I_2$ 处于 $\\mathrm{EX}$ 阶段。\n- 时钟周期 $5$：$I_1$ 处于 $\\mathrm{WB}$ 阶段，$I_2$ 处于 $\\mathrm{MEM}$ 阶段。\n- 时钟周期 $6$：$I_2$ 处于 $\\mathrm{WB}$ 阶段。\n\nRAW 冒险之所以发生，是因为 $I_2$ 在其 $\\mathrm{EX}$ 阶段需要 $R_1$ 的值，但在无停顿序列中，$I_1$ 尚未将此值写回寄存器文件。我们必须在每种情况下分析 $R_1$ 的值何时由 $I_1$ 产生，以及何时被 $I_2$ 需要。\n\n**情况 1：完全转发**\n\n在这种情况下，有转发路径可将结果直接从较晚的流水线阶段移动到较早的阶段，从而绕过寄存器文件。问题指定了从 $\\mathrm{EX}$ 阶段末尾和 $\\mathrm{MEM}$ 阶段末尾到 $\\mathrm{EX}$ 阶段开始的转发路径。\n\n1.  **值的产生**：对于算术指令 $I_1$ ($\\mathrm{ADD}$)，$R_1$ 的结果在 $\\mathrm{EX}$ 阶段计算。该结果在周期 $3$ 结束时在 $\\mathrm{EX/MEM}$ 流水线寄存器中可用。\n2.  **值的消耗**：消费者指令 $I_2$ ($\\mathrm{SUB}$) 需要 $R_1$ 的值作为其 ALU 的输入。此值在其 $\\mathrm{EX}$ 阶段的开始处需要，在没有停顿的情况下，这发生在周期 $4$ 的开始。\n3.  **冒险解决**：转发逻辑可以在周期 $3$ 结束时从 $\\mathrm{EX/MEM}$ 流水线寄存器中获取 $I_1$ 的结果，并将其转发到周期 $4$ 开始时 $I_2$ 的 ALU 输入端。这就是“$\\mathrm{EX}$-到-$\\mathrm{EX}$”转发路径。数据刚好在 $I_2$ 需要执行时到达，无需延迟。\n\n由于数据在需要时恰好可用，因此不需要停顿。\n有转发时的停顿周期数 $x$ 为 $0$。\n\n此情况下的流水线图：\n时钟周期 | $1$ | $2$ | $3$ | $4$ | $5$ | $6$\n------------|---|---|---|---|---|---\n$I_1$: ADD  | $\\mathrm{IF}$ | $\\mathrm{ID}$ | $\\mathrm{EX}$ | $\\mathrm{MEM}$ | $\\mathrm{WB}$ |\n$I_2$: SUB  | | $\\mathrm{IF}$ | $\\mathrm{ID}$ | $\\mathrm{EX}$ | $\\mathrm{MEM}$ | $\\mathrm{WB}$\n（在周期 $4$，$I_1$ 的 $\\mathrm{EX}$ 阶段的结果被转发到 $I_2$ 的 $\\mathrm{EX}$ 阶段。）\n\n**情况 2：无转发**\n\n在没有转发的情况下，一个结果只有在生产者的 $\\mathrm{WB}$ 阶段被写入寄存器文件后，才能被后续指令使用。\n\n1.  **值的产生**：指令 $I_1$ 在周期 $5$ 到达其 $\\mathrm{WB}$ 阶段。它在此周期内将 $R_1$ 的新值写入寄存器文件。\n2.  **值的消耗**：指令 $I_2$ 需要读取 $R_1$ 的值。这个读取操作发生在其 $\\mathrm{ID}$ 阶段。\n3.  **冒险解决**：$\\mathrm{ID}$ 阶段的冒险检测单元将在周期 $3$ 检测到 $I_2$ 依赖于 $R_1$，而 $R_1$ 正由 $I_1$ 计算。由于没有转发，$I_2$ 必须停顿，直到 $I_1$ 完成其 $\\mathrm{WB}$ 阶段。问题规定，在同一个时钟周期内，$\\mathrm{WB}$ 阶段的寄存器写入先于 $\\mathrm{ID}$ 阶段的寄存器读取完成。这通常被称为“分阶段”或“写优先”的寄存器文件。此规则允许一条指令在其 $\\mathrm{ID}$ 阶段读取一个值，而该值是在同一个时钟周期内由前一条指令在其 $\\mathrm{WB}$ 阶段写入的。\n\n    因此，$I_2$ 最早可以在周期 $5$ 完成其 $\\mathrm{ID}$ 阶段，此时 $I_1$ 处于其 $\\mathrm{WB}$ 阶段。\n    - 在周期 $3$，$I_2$ 处于其 $\\mathrm{ID}$ 阶段并检测到冒险。它必须停顿。\n    - 在周期 $4$，$I_1$ 进入 $\\mathrm{MEM}$ 阶段。$I_2$ 被停顿，流水线中插入一个气泡。这是 $1$ 个停顿周期。\n    - 在周期 $5$，$I_1$ 进入 $\\mathrm{WB}$ 阶段。$I_2$ 仍被停顿。在此周期内，$I_1$ 写入 $R_1$，现在 $I_2$ 可以正确读取它。流水线中插入了另一个气泡。这是第 $2$ 个停顿周期。\n    - 在周期 $6$，$I_2$ 现在可以进入其 $\\mathrm{EX}$ 阶段。\n\n指令 $I_2$ 通常会在周期 $4$ 进入其 $\\mathrm{EX}$ 阶段。由于冒险，它在周期 $6$ 才进入其 $\\mathrm{EX}$ 阶段。总延迟为 $6-4=2$ 个周期。因此，需要 $2$ 个停顿周期。\n\n此情况下的流水线图：\n时钟周期 | $1$ | $2$ | $3$ | $4$ | $5$ | $6$ | $7$ | $8$\n------------|---|---|---|---|---|---|---|---\n$I_1$: ADD  | $\\mathrm{IF}$ | $\\mathrm{ID}$ | $\\mathrm{EX}$ | $\\mathrm{MEM}$ | $\\mathrm{WB}$ | | |\n$I_2$: SUB  | | $\\mathrm{IF}$ | $\\mathrm{ID}$ | 停顿 | 停顿 | $\\mathrm{EX}$ | $\\mathrm{MEM}$ | $\\mathrm{WB}$\n\n没有转发时的停顿周期数 $y$ 为 $2$。\n\n最终答案是序对 $(x, y)$，表示有转发和无转发时的停顿计数。\n- 有转发时的停顿数，$x = 0$。\n- 无转发时的停顿数，$y = 2$。\n该序对为 $(0, 2)$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix} 0  2 \\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在掌握了基础的转发机制后，让我们通过引入多周期执行单元来探讨一个更符合实际的场景。这个练习将引导你分析指令延迟和转发路径的具体设计（例如，从执行阶段转发与从写回阶段转发）如何产生更复杂的时序挑战。解决这个问题将深化你对转发逻辑如何适应不同流水线结构的理解，并揭示不同硬件设计选择对性能的直接影响 。",
            "id": "3632084",
            "problem": "考虑一个单发射、顺序执行的五级标量流水线，包含指令提取 (IF)、指令译码/寄存器读取 (ID)、执行 (EX)、访存 (MEM) 和写回 (WB) 五个阶段。该流水线在以下物理上可实现的时序语义下运行：\n- 每个阶段恰好占用 $1$ 个完整周期，但多周期功能单元会占用一个阶段直至其完整延迟结束。\n- 级间传输和体系结构寄存器写入发生在一个周期结束时的时钟沿。\n- 寄存器文件读取发生在 ID 阶段的开始；在周期 $t$ 结束时于 WB 阶段写入的值，从周期 $t+1$ 开始的读取操作即可见（没有半周期写后读技巧）。\n- 当存在旁路（转发）路径时，它将在周期 $t$ 结束时计算出的生产者值，在周期 $t+1$ 开始时传递给消费者的 EX 输入。\n\n给定连续的两条指令：\n- $I_1$：一条算术指令，它写入体系结构寄存器 $R_1$，在 EX 阶段使用一个延迟为 $3$ 个周期的多周期算术单元，然后经过 MEM（$1$ 个周期，功能上未使用）和 WB（$1$ 个周期）。\n- $I_2$：一条算术指令，它读取 $R_1$ 作为源操作数。\n\n假设没有冒险，$I_1$ 将在周期 $1$ 处于 IF 阶段，周期 $2$ 处于 ID 阶段，周期 $3$ 到 $5$ 处于 EX 阶段，周期 $6$ 处于 MEM 阶段，周期 $7$ 处于 WB 阶段。假设 $I_2$ 是下一条顺序指令；在没有冒险的情况下，它将在周期 $2$ 处于 IF 阶段，周期 $3$ 处于 ID 阶段，周期 $4$ 处于 EX 阶段，周期 $5$ 处于 MEM 阶段，周期 $6$ 处于 WB 阶段。\n\n仅使用数据冒险和流水线时序的核心定义，确定在哪两种微体系结构配置下，$I_2$ 可以合法进入 EX 阶段的最早周期，以满足其对 $R_1$ 的写后读依赖：\n- 情况 A：存在一条 EX 阶段旁路路径，将 $I_1$ 的 EX 结果转发到 $I_2$ 的 EX 输入。\n- 情况 B：不存在 EX 阶段旁路，但存在一条 WB 阶段旁路，将 $I_1$ 的 WB 输出转发到 $I_2$ 的 EX 输入。\n\n你的答案必须是表示这两个周期索引的行向量 $\\left(c_{\\mathrm{EX}}, c_{\\mathrm{WB}}\\right)$，其中 $c_{\\mathrm{EX}}$ 是情况 A 中 $I_2$ 进入 EX 阶段的最早周期，$c_{\\mathrm{WB}}$ 是情况 B 中的最早周期。请提供精确整数，无需四舍五入。请从写后读 (RAW)、读后写 (WAR) 和写后写 (WAW) 冒险的定义以及所述的流水线时序语义开始解释你的推理过程，并说明每条旁路路径的存在与否如何改变对 $I_2$ 的 RAW 冒险的解决方案。",
            "solution": "该问题陈述已经过验证，被认为是合理、适定且在计算机组成与体系结构原理方面有科学依据的。它为流水线模型提供了一套完整且一致的规则，从而可以对数据冒险进行确定性分析。\n\n本问题集中于一种称为写后读 (RAW) 冒险的数据依赖。数据冒险根据两条指令 $I_i$（在程序顺序中先出现）和 $I_j$（在 $I_i$ 之后出现）对共享存储位置（例如，寄存器）的读 ($R$) 和写 ($W$) 操作的顺序，分为三种类型：\n1.  **RAW (写后读):** $I_j$ 试图在 $I_i$ 写入某个位置之前读取它 ($I_i: \\dots \\rightarrow W(x)$, $I_j: \\dots \\rightarrow R(x)$)。这是一种真数据依赖。\n2.  **WAR (读后写):** $I_j$ 试图在 $I_i$ 从某个位置读取之前写入它 ($I_i: \\dots \\rightarrow R(x)$, $I_j: \\dots \\rightarrow W(x)$)。这是一种反依赖。\n3.  **WAW (写后写):** $I_j$ 试图在 $I_i$ 写入某个位置之前写入它 ($I_i: \\dots \\rightarrow W(x)$, $I_j: \\dots \\rightarrow W(x)$)。这是一种输出依赖。\n\n在本问题中，指令 $I_1$ 写入寄存器 $R_1$，而指令 $I_2$ 随后从寄存器 $R_1$ 读取。这构成了一个经典的 RAW 依赖。如果流水线结构允许 $I_2$ 在 $I_1$ 完成新值写入之前进入其执行阶段并读取 $R_1$ 的值，就会发生冒险。为确保正确性，流水线必须强制执行程序顺序语义，即 $I_2$ 必须接收由 $I_1$ 产生的值。这通过停顿 $I_2$ 直到所需数据通过寄存器文件或旁路/转发路径可用为止来实现。\n\n首先，我们确定生产者指令 $I_1$ 的时间线。\n- $I_1$ 在周期 $1$ 处于 IF 阶段。\n- $I_1$ 在周期 $2$ 处于 ID 阶段。\n- $I_1$ 在周期 $3、4、5$ 处于其多周期 EX 阶段。算术结果在最后一个 EX 周期结束时计算完成并可用在流水线锁存器上，即**周期 $5$ 的结束**。\n- $I_1$ 在周期 $6$ 处于 MEM 阶段。来自 EX 的结果通过此阶段。\n- $I_1$ 在周期 $7$ 处于 WB 阶段。结果在**周期 $7$ 的结束**写回到体系结构寄存器文件 ($R_1$)。\n\n接下来，我们分析消费者指令 $I_2$。\n- $I_2$ 在周期 $2$ 被提取（IF 阶段）。\n- $I_2$ 在周期 $3$ 进入 ID 阶段。在此阶段，控制逻辑检测到 $I_2$ 需要读取 $R_1$，而 $R_1$ 是当前正在流水线中执行的前一条指令 $I_1$ 的目的寄存器。检测到一个 RAW 冒险。\n- $I_2$ 在其自己的 EX 阶段开始时需要 $R_1$ 的值。问题在于找到 $I_2$ 的 EX 阶段可以开始的最早周期数，这要求来自 $I_1$ 的值在其输入端可用。\n\n我们现在针对指定的两种微体系结构配置进行求解。\n\n**情况 A：存在一条 EX 阶段旁路路径。**\n这条路径通常称为 EX-to-EX 转发，它将生产者 EX 阶段结束时的结果路由到消费者 EX 阶段的输入。\n1.  如上所述，$I_1$ 的执行结果在其 EX 阶段结束时可用，该阶段在**周期 $5$ 的结束**时完成。\n2.  问题陈述指出，在周期 $t$ 结束时转发的值，在周期 $t+1$ 开始时在消费者的 EX 输入端可用。这里，$t=5$。\n3.  因此，由 $I_1$ 计算的值可以在**周期 $6$ 的开始**时被转发到 $I_2$ 的 EX 阶段的输入端。\n4.  这意味着 $I_2$ 可以合法进入其 EX 阶段的最早周期是周期 $6$。为实现这一点，流水线控制器必须在周期 $3、4、5$ 将 $I_2$ 停顿在 ID 阶段。在周期 $6$ 的开始，$I_2$ 可以从 ID 进入 EX，恰好及时接收到转发的值以供执行。\n因此，情况 A 的最早 EX 进入周期是 $c_{\\mathrm{EX}} = 6$。\n\n此情况下的流水线图为：\nI1: IF(1) ID(2) EX(3) EX(4) EX(5) MEM(6) WB(7)\nI2:      IF(2) ID(3) 停顿(4) 停顿(5) EX(6)  MEM(7) WB(8)\n\n**情况 B：不存在 EX 阶段旁路，但存在 WB 阶段旁路。**\n在此配置中，$I_1$ 的结果无法直接从 EX 阶段转发。该值必须在流水线中进一步传播，直到到达一个有可用旁路路径的点。问题指定该点是 WB 阶段。\n1.  $I_1$ 在周期 $5$ 结束时计算出的结果通过 MEM 阶段（周期 $6$），并在周期 $7$ 开始时到达 WB 阶段。\n2.  指令 $I_1$ 在周期 $7$ 处于其 WB 阶段。该值在此阶段可用于转发。根据时序语义，该值从此阶段的输出锁存器在**周期 $7$ 的结束**时可用。\n3.  使用指定的转发规则，当 $t=7$ 时，来自 $I_1$ 的 WB 阶段的值将在**周期 $t+1 = 8$ 的开始**时传递到 $I_2$ 的 EX 阶段的输入端。\n4.  因此，$I_2$ 可以合法进入其 EX 阶段的最早周期是周期 $8$。为了实现这一点，与情况 A 相比，流水线必须将 $I_2$ 在其 ID 阶段停顿更多的周期。它总共将被停顿 $5$ 个周期：$3、4、5、6$ 和 $7$。在周期 $8$ 的开始，它可以进入 EX 阶段。\n因此，情况 B 的最早 EX 进入周期是 $c_{\\mathrm{WB}} = 8$。\n\n此情况下的流水线图为：\nI1: IF(1) ID(2) EX(3) EX(4) EX(5) MEM(6) WB(7)\nI2:      IF(2) ID(3) 停顿(4) 停顿(5) 停顿(6) 停顿(7) EX(8) MEM(9) WB(10)\n\n这比等待 MEM-to-EX 转发（这将允许在周期 $7$ 进入 EX）的停顿时间更长，但它也比等待寄存器文件写入完成要快一个周期。如果没有 WB-to-EX 旁路，$I_2$ 将不得不等待值被写入寄存器文件（周期 $7$ 结束），然后在它自己的 ID 阶段读取它（要求 ID 发生在周期 $8$ 或更晚），这会将其 EX 阶段推迟到不早于周期 $9$ 开始。与该场景相比，WB-to-EX 旁路节省了一个周期。\n\n最终答案是两个周期索引组成的行向量 $(c_{\\mathrm{EX}}, c_{\\mathrm{WB}})$。\n$c_{\\mathrm{EX}} = 6$\n$c_{\\mathrm{WB}} = 8$",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n6  8\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "解决数据冒险并不仅限于硬件层面，编译器的角色同样至关重要。本练习将视角从硬件转向软件，将指令间的依赖关系抽象为一个有向无环图（DAG），并要求你找出最优的执行调度方案。这项任务的本质是识别并计算图中的“关键路径”，它直接决定了任务并行执行的最短时间，从而揭示了编译器如何通过指令调度来最大化指令级并行度，与处理器硬件协同工作 。",
            "id": "3632060",
            "problem": "编译器执行指令调度，以在满足数据冒险约束的条件下，最大化指令级并行（ILP）。考虑一个程序片段，其真数据依赖（写后读，RAW）由一个有向无环图（DAG）表示。每个节点 $I_i$ 代表一条产生单个结果的指令，并标有以周期为单位的延迟 $l_i$。一条边 $(I_u \\rightarrow I_v)$ 表示 $I_v$ 读取由 $I_u$ 产生的值，因此 $I_v$ 必须等到该值产生后才能读取。假设以下基本事实和定义：\n- 当一条指令在产生其操作数的早期指令写入该值之前读取该操作数时，就会发生写后读（RAW）冒险。\n- 真依赖构成的DAG定义了指令开始时间上的一个偏序关系：如果存在一条边 $(I_u \\rightarrow I_v)$，那么 $I_v$ 的开始时间不能早于 $I_u$ 的结果可用的时间。\n- 每条指令 $I_i$ 有一个延迟 $l_i$，其结果在 $I_i$ 开始后 $l_i$ 个周期变得可用。\n- 该机器是理想化的，具有无限的功能单元和发射宽度（无结构冒险）、完美的转发和完美的寄存器重命名，因此不存在读后写（WAR）或写后写（WAW）冒险。唯一的约束是由DAG编码的RAW依赖。\n- 时间以周期为单位计量，最早的指令可以在时间 $t=0$ 开始。如果 $I_i$ 在时间 $t$ 开始，其结果在时间 $t + l_i$ 可用。\n\n该DAG有9个节点 $I_1,\\dots,I_9$，其延迟如下：\n- $l_1 = 3$, $l_2 = 1$, $l_3 = 4$, $l_4 = 1$, $l_5 = 3$, $l_6 = 1$, $l_7 = 4$, $l_8 = 1$, $l_9 = 1$。\n\n有向边（RAW依赖）如下：\n- $(I_1 \\rightarrow I_2)$,\n- $(I_2 \\rightarrow I_3)$, $(I_2 \\rightarrow I_4)$,\n- $(I_4 \\rightarrow I_6)$, $(I_4 \\rightarrow I_7)$,\n- $(I_5 \\rightarrow I_6)$,\n- $(I_3 \\rightarrow I_8)$, $(I_7 \\rightarrow I_8)$,\n- $(I_5 \\rightarrow I_9)$, $(I_8 \\rightarrow I_9)$。\n\n在这些假设下，调度指令以最大化ILP，同时确保没有调度时间违反RAW约束。将调度长度定义为所有指令都已产生其结果的最早可能完成时间（以周期为单位）。计算这个最小调度长度。请用一个表示周期的整数来表达你的最终答案。无需四舍五入。",
            "solution": "问题要求计算一组指令的最小调度长度，这些指令仅受写后读（RAW）数据依赖的约束。这些依赖关系由一个有向无环图（DAG）表示，其中一条边 $(I_u \\rightarrow I_v)$ 意味着指令 $I_v$ 需要指令 $I_u$ 的结果。\n\n设 $S_i$ 为指令 $I_i$ 的开始时间， $l_i$ 为其延迟。$I_i$ 的结果在其完成时间 $C_i$ 变得可用。鉴于一条在时间 $t$ 开始且延迟为 $l$ 的指令在时间 $t+l$ 完成，我们有：\n$$C_i = S_i + l_i$$\n\n一个RAW依赖 $(I_u \\rightarrow I_v)$ 意味着 $I_v$ 必须等到 $I_u$ 的结果可用后才能开始。因此，$I_v$ 的开始时间必须大于或等于 $I_u$ 的完成时间：\n$$S_v \\ge C_u$$\n\n为了实现最小的调度长度，我们必须在每条指令可能的最早开始时间进行调度。指令 $I_i$ 的最早开始时间由其所有前驱指令的完成时间决定。设 $P(I_i)$ 为所有满足存在边 $(I_u \\rightarrow I_i)$ 的指令 $I_u$ 的集合。$I_i$ 的最早开始时间，记作 $S_i^*$，由下式给出：\n$$S_i^* = \\max_{I_u \\in P(I_i)} \\{C_u^*\\}$$\n其中 $C_u^*$ 是前驱指令 $I_u$ 的最早完成时间。如果一条指令 $I_i$ 没有前驱（即它是DAG的根节点），它可以在时间 $t=0$ 开始，所以 $S_i^* = 0$。\n\n那么，$I_i$ 的最早完成时间是：\n$$C_i^* = S_i^* + l_i$$\n\n总调度长度定义为所有指令都已完成的时间。这对应于所有最早完成时间的最大值：\n$$\\text{Schedule Length} = \\max_i \\{C_i^*\\}$$\n\n我们可以通过按照DAG的拓扑顺序处理指令来计算每条指令的最早完成时间。\n\n给定的延迟如下：\n$l_1 = 3, l_2 = 1, l_3 = 4, l_4 = 1, l_5 = 3, l_6 = 1, l_7 = 4, l_8 = 1, l_9 = 1$。\n\n给定的依赖关系如下：\n$(I_1 \\rightarrow I_2)$, $(I_2 \\rightarrow I_3)$, $(I_2 \\rightarrow I_4)$, $(I_4 \\rightarrow I_6)$, $(I_4 \\rightarrow I_7)$, $(I_5 \\rightarrow I_6)$, $(I_3 \\rightarrow I_8)$, $(I_7 \\rightarrow I_8)$, $(I_5 \\rightarrow I_9)$, $(I_8 \\rightarrow I_9)$。\n\n我们为每条指令 $I_i$ 计算其最早完成时间 $C_i^*$：\n\n1.  指令 $I_1$ 和 $I_5$ 没有前驱（它们是DAG的根节点）。它们的最早开始时间是 $0$。\n    $S_1^* = 0 \\implies C_1^* = S_1^* + l_1 = 0 + 3 = 3$\n    $S_5^* = 0 \\implies C_5^* = S_5^* + l_5 = 0 + 3 = 3$\n\n2.  指令 $I_2$ 仅依赖于 $I_1$。\n    $S_2^* = C_1^* = 3 \\implies C_2^* = S_2^* + l_2 = 3 + 1 = 4$\n\n3.  指令 $I_3$ 仅依赖于 $I_2$。\n    $S_3^* = C_2^* = 4 \\implies C_3^* = S_3^* + l_3 = 4 + 4 = 8$\n\n4.  指令 $I_4$ 仅依赖于 $I_2$。\n    $S_4^* = C_2^* = 4 \\implies C_4^* = S_4^* + l_4 = 4 + 1 = 5$\n\n5.  指令 $I_7$ 仅依赖于 $I_4$。\n    $S_7^* = C_4^* = 5 \\implies C_7^* = S_7^* + l_7 = 5 + 4 = 9$\n\n6.  指令 $I_6$ 依赖于 $I_4$ 和 $I_5$。\n    $S_6^* = \\max(C_4^*, C_5^*) = \\max(5, 3) = 5 \\implies C_6^* = S_6^* + l_6 = 5 + 1 = 6$\n\n7.  指令 $I_8$ 依赖于 $I_3$ 和 $I_7$。\n    $S_8^* = \\max(C_3^*, C_7^*) = \\max(8, 9) = 9 \\implies C_8^* = S_8^* + l_8 = 9 + 1 = 10$\n\n8.  指令 $I_9$ 依赖于 $I_5$ 和 $I_8$。\n    $S_9^* = \\max(C_5^*, C_8^*) = \\max(3, 10) = 10 \\implies C_9^* = S_9^* + l_9 = 10 + 1 = 11$\n\n所有指令的最早完成时间如下：\n$C_1^* = 3$\n$C_2^* = 4$\n$C_3^* = 8$\n$C_4^* = 5$\n$C_5^* = 3$\n$C_6^* = 6$\n$C_7^* = 9$\n$C_8^* = 10$\n$C_9^* = 11$\n\n最小调度长度是这些完成时间的最大值。\n$$\\text{Schedule Length} = \\max(3, 4, 8, 5, 3, 6, 9, 10, 11) = 11$$\n\n这对应于依赖图中的关键路径长度。其中一条关键路径是 $I_1 \\rightarrow I_2 \\rightarrow I_4 \\rightarrow I_7 \\rightarrow I_8 \\rightarrow I_9$。\n- $I_1$ 在 $t=0$ 开始，在 $t=3$ 完成。\n- $I_2$ 在 $t=3$ 开始，在 $t=4$ 完成。\n- $I_4$ 在 $t=4$ 开始，在 $t=5$ 完成。\n- $I_7$ 在 $t=5$ 开始，在 $t=9$ 完成。\n- $I_8$ 在 $t=9$ 开始，在 $t=10$ 完成。\n- $I_9$ 在 $t=10$ 开始，在 $t=11$ 完成。\n最后一条指令在时间点 $11$ 完成，因此最小调度长度为 $11$ 个周期。",
            "answer": "$$\n\\boxed{11}\n$$"
        }
    ]
}