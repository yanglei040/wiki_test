{
    "hands_on_practices": [
        {
            "introduction": "Understanding addressing modes goes beyond just knowing the formulas; it involves analyzing their capabilities and limitations. This first exercise challenges you to work backward from a desired outcome. Given a specific target memory address, you will determine the displacement required for a base-plus-index addressing mode to reach it, and then calculate the minimum number of bits needed to encode that displacement, a critical consideration in instruction set design. ",
            "id": "3618990",
            "problem": "A load instruction in a certain Instruction Set Architecture (ISA) uses a base-plus-index-with-displacement addressing mode. By definition, the effective address (EA) produced by this mode is the integer sum of the contents of two general-purpose registers and a sign-extended immediate displacement, that is, the effective address equals the sum of the value in register $R1$, the value in register $R2$, and an immediate displacement $disp$ that is encoded in two’s complement with width $w$ bits and sign-extended to the machine word size prior to addition. All quantities denote byte addresses and are treated as signed integers only for the purpose of displacement encoding. The two’s complement range for a $w$-bit signed integer is $\\left[-2^{w-1},\\,2^{w-1}-1\\right]$.\n\nUsing only these definitions and facts, address the following in order:\n- Derive the necessary and sufficient condition on the displacement $disp$ such that the instruction’s effective address equals a given absolute target address $C$. Express your condition entirely in terms of $R1$, $R2$, and $C$, and do not assume any particular $w$ yet.\n- Specialize your condition to the two’s complement representability constraint for a $w$-bit displacement.\n- Now instantiate the symbols with the concrete values $R1 = 0x0000000010000100$, $R2 = 0x0000000000000200$, and $C = 0x0000000010008901$. Determine the minimal integer $w$ such that the displacement can be encoded in two’s complement and the instruction can exactly reach the target address $C$ using this addressing mode.\n\nYour final answer must be the minimal integer number of bits $w$ required. No rounding is needed and no units are required for the answer.",
            "solution": "The problem is first validated to ensure it is scientifically grounded, well-posed, and objective.\n\n### Step 1: Extract Givens\n- **Addressing Mode**: Base-plus-index-with-displacement.\n- **Effective Address (EA) Formula**: The effective address, $EA$, is the sum of the value in register $R1$, the value in register $R2$, and a sign-extended immediate displacement $disp$. $EA = R1 + R2 + disp$.\n- **Displacement Encoding**: $disp$ is encoded as a $w$-bit two's complement integer. Prior to addition, it is sign-extended to the machine word size.\n- **Two's Complement Range**: The range for a $w$-bit signed integer is given as $\\left[-2^{w-1}, 2^{w-1}-1\\right]$.\n- **Target Address**: A given absolute target address, $C$.\n- **Concrete Values**:\n  - $R1 = 0x0000000010000100$\n  - $R2 = 0x0000000000000200$\n  - $C = 0x0000000010008901$\n- **Objective**: Find the minimal integer value of $w$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is set within the standard framework of computer organization and architecture. The definitions of the addressing mode, effective address calculation, and two's complement representation are all standard and factually correct. The problem is self-contained, providing all necessary definitions and data to arrive at a unique solution. The language is precise and objective. There are no scientific flaws, ambiguities, or contradictions.\n\n### Step 3: Verdict and Action\nThe problem is deemed **valid**. A solution will be derived.\n\n### Solution Derivation\n\nThe solution proceeds by addressing the three tasks specified in the problem statement in order.\n\n**1. Derive the necessary and sufficient condition on the displacement $disp$.**\n\nThe effective address ($EA$) is defined as the sum of the contents of two registers, $R1$ and $R2$, and an immediate displacement, $disp$.\n$$EA = R1 + R2 + disp$$\nThe problem requires that the effective address equals a specific target address, $C$.\n$$EA = C$$\nEquating the two expressions for $EA$ gives the following relationship:\n$$C = R1 + R2 + disp$$\nTo find the necessary and sufficient condition on $disp$, we solve this equation for $disp$. This yields the required displacement value that allows the instruction to reach the target address $C$.\n$$disp = C - (R1 + R2)$$\nThis equation is the condition on $disp$ expressed purely in terms of $R1$, $R2$, and $C$.\n\n**2. Specialize the condition to the two’s complement representability constraint.**\n\nThe displacement $disp$ must be representable as a $w$-bit two's complement integer. The problem provides the valid range for such an integer as:\n$$-2^{w-1} \\le disp \\le 2^{w-1} - 1$$\nSubstituting the expression for $disp$ from the first part, we obtain the specialized condition that incorporates the representability constraint:\n$$-2^{w-1} \\le C - (R1 + R2) \\le 2^{w-1} - 1$$\nThis inequality must be satisfied for the displacement to be encodable with a width of $w$ bits.\n\n**3. Determine the minimal integer $w$ for the given concrete values.**\n\nFirst, we calculate the required numerical value for the displacement $disp$ using the provided hexadecimal values for $R1$, $R2$, and $C$. The addresses are treated as unsigned integers for the arithmetic operations.\n$$R1 = 0x10000100$$\n$$R2 = 0x00000200$$\n$$C = 0x10008901$$\nWe first compute the sum of the register contents:\n$$R1 + R2 = 0x10000100 + 0x00000200 = 0x10000300$$\nNext, we calculate the displacement $disp$:\n$$disp = C - (R1 + R2) = 0x10008901 - 0x10000300 = 0x8601$$\nTo find the minimum number of bits $w$, we convert the hexadecimal displacement $0x8601$ to its decimal equivalent:\n$$disp = 8 \\times 16^3 + 6 \\times 16^2 + 0 \\times 16^1 + 1 \\times 16^0$$\n$$disp = 8 \\times 4096 + 6 \\times 256 + 0 + 1$$\n$$disp = 32768 + 1536 + 1 = 34305$$\nNow we must find the minimal integer $w$ such that $disp = 34305$ satisfies the two's complement range condition:\n$$-2^{w-1} \\le 34305 \\le 2^{w-1} - 1$$\nSince $disp$ is a positive number, the left-hand inequality, $-2^{w-1} \\le 34305$, is satisfied for any $w \\ge 2$. The determining constraint is the right-hand inequality:\n$$34305 \\le 2^{w-1} - 1$$\nRearranging the inequality gives:\n$$34306 \\le 2^{w-1}$$\nTo find the minimum integer $w$ that satisfies this, we can examine powers of $2$:\n$$2^{14} = 16384$$\n$$2^{15} = 32768$$\n$$2^{16} = 65536$$\nWe require $2^{w-1}$ to be greater than or equal to $34306$. From the values above, $2^{15}$ is too small, but $2^{16}$ is sufficient. Therefore, the minimum integer value for the exponent $w-1$ must be $16$.\n$$w-1 \\ge 16$$\nThis implies that the minimum integer value for $w$ is:\n$$w = 16 + 1 = 17$$\nTo verify, for $w=17$, the range is $[-2^{16}, 2^{16}-1]$, which is $[-65536, 65535]$. The value $34305$ lies within this range. For $w=16$, the range would be $[-2^{15}, 2^{15}-1]$, which is $[-32768, 32767]$. The value $34305$ is outside this range. Thus, the minimal integer number of bits required is $17$.",
            "answer": "$$\\boxed{17}$$"
        },
        {
            "introduction": "The correctness of an addressing calculation often hinges on subtle details of data representation. This practice explores one of the most common and classic bugs in low-level programming: the incorrect handling of signed displacements. You will analyze the difference between sign-extending and zero-extending a displacement value and identify the exact conditions under which this bug leads to a predictable error, reinforcing your understanding of two's complement arithmetic. ",
            "id": "3618965",
            "problem": "A processor uses base-plus-displacement addressing for memory operands. In this mode, the Effective Address (EA) is computed as $EA = R5 + \\text{disp}$, where $R5$ is a general-purpose base register and $\\text{disp}$ is an immediate displacement field contained in the instruction encoding. The architecture specifies that $\\text{disp}$ is a $k$-bit two's complement value that must be sign-extended to the machine word size before being added to $R5$. Assume a machine word size of $32$ bits and byte-addressable memory. A buggy implementation erroneously zero-extends $\\text{disp}$ to $32$ bits instead of sign-extending it.\n\nStarting from the core definitions of base-plus-displacement addressing and two's complement sign extension, analyze the effect of this bug. In particular, determine in which scenarios the incorrect zero-extension causes the computed $EA$ to differ from the correct $EA$ by exactly $2^k$ bytes. For each option, treat $\\texttt{0x...}$ as the literal bit pattern of the $k$-bit displacement field, and assume arithmetic is performed modulo $2^{32}$ as usual for $32$-bit addresses.\n\nSelect all options that produce an off-by-$2^k$ bug (that is, the incorrect $EA$ equals the correct $EA$ plus $2^k$).\n\nA. $k = 12$, $R5 = \\texttt{0x1000}$, $\\text{disp} = \\texttt{0x800}$\n\nB. $k = 12$, $R5 = \\texttt{0x1000}$, $\\text{disp} = \\texttt{0x7FF}$\n\nC. $k = 12$, $R5 = \\texttt{0x2000}$, $\\text{disp} = \\texttt{0xF20}$\n\nD. $k = 10$, $R5 = \\texttt{0xFF00}$, $\\text{disp} = \\texttt{0x120}$\n\nE. $k = 16$, $R5 = \\texttt{0x0000}$, $\\text{disp} = \\texttt{0x8000}$",
            "solution": "The problem statement is validated as scientifically grounded, well-posed, and objective. It is based on standard principles of computer architecture, including addressing modes and two's complement arithmetic. The setup is self-contained and free of contradictions, allowing for a rigorous, formal analysis.\n\nThe core of the problem lies in the difference between correct sign-extension and incorrect zero-extension of a $k$-bit two's complement displacement, $\\text{disp}$. We are asked to find when this bug causes the computed Effective Address ($EA$) to be off by exactly $2^k$.\n\nLet $\\text{disp}_k$ represent the $k$-bit displacement field. Let its unsigned integer value be $D_k$. The machine word size is $32$ bits.\n\nThe correct Effective Address, $EA_{\\text{correct}}$, is calculated by sign-extending $\\text{disp}_k$ to $32$ bits and adding it to the base register $R5$.\n$EA_{\\text{correct}} = R5 + \\text{sign_extend}(\\text{disp}_k)$\n\nThe buggy Effective Address, $EA_{\\text{buggy}}$, is calculated by zero-extending $\\text{disp}_k$ to $32$ bits.\n$EA_{\\text{buggy}} = R5 + \\text{zero_extend}(\\text{disp}_k)$\n\nLet's analyze the value of the extended displacement in both cases.\nThe value of a $32$-bit number obtained by zero-extending $\\text{disp}_k$ is simply its unsigned value, $D_k$.\nValue of $\\text{zero_extend}(\\text{disp}_k) = D_k$.\n\nThe value of a $32$-bit number obtained by sign-extending $\\text{disp}_k$ depends on its most significant bit (MSB), which is bit $k-1$.\nCase 1: The MSB of $\\text{disp}_k$ is $0$. This indicates a non-negative number.\nSign extension pads the upper $32-k$ bits with $0$s. This is identical to zero extension.\nValue of $\\text{sign_extend}(\\text{disp}_k) = D_k$.\n\nCase 2: The MSB of $\\text{disp}_k$ is $1$. This indicates a negative number in two's complement representation.\nThe value of a $k$-bit two's complement number with its MSB set is $D_k - 2^k$. Sign extension must preserve this value.\nTo sign-extend, the upper $32-k$ bits are padded with $1$s. The resulting $32$-bit pattern has an unsigned value of $D_k + \\sum_{i=k}^{31} 2^i = D_k + (2^{32}-2^k)$.\nAs a $32$-bit two's complement number, its value is $(D_k + 2^{32}-2^k) - 2^{32} = D_k - 2^k$.\nSo, Value of $\\text{sign_extend}(\\text{disp}_k) = D_k - 2^k$.\n\nWe need to find the scenarios where the incorrect $EA$ equals the correct $EA$ plus $2^k$.\n$EA_{\\text{buggy}} = EA_{\\text{correct}} + 2^k$\n$(R5 + \\text{Value}(\\text{zero_extend}(\\text{disp}_k))) = (R5 + \\text{Value}(\\text{sign_extend}(\\text{disp}_k))) + 2^k$\n\nSubtracting $R5$ from both sides, the condition simplifies to:\n$\\text{Value}(\\text{zero_extend}(\\text{disp}_k)) = \\text{Value}(\\text{sign_extend}(\\text{disp}_k)) + 2^k$\n\nLet's check this condition for our two cases:\nCase 1 (MSB of $\\text{disp}_k$ is $0$):\n$D_k = D_k + 2^k$, which simplifies to $0 = 2^k$. This is false for any $k > 0$.\n\nCase 2 (MSB of $\\text{disp}_k$ is $1$):\n$D_k = (D_k - 2^k) + 2^k$, which simplifies to $D_k = D_k$. This is always true.\n\nTherefore, the bug causes an off-by-$2^k$ error if and only if the most significant bit of the $k$-bit displacement field, $\\text{disp}_k$, is $1$. The value of the base register $R5$ is irrelevant to this condition. We now analyze each option based on this principle.\n\n**A. $k = 12$, $R5 = \\texttt{0x1000}$, $\\text{disp} = \\texttt{0x800}$**\nThe displacement is a $k=12$-bit field. The value is $\\text{disp} = \\texttt{0x800}$.\nIn binary, $\\texttt{0x800}$ is $1000\\ 0000\\ 0000_2$.\nThis is a $12$-bit pattern. The most significant bit (bit $11$) is $1$.\nBased on our derivation, this scenario will produce the specified error.\nTo verify:\n- Correct value (sign-extended): $\\text{disp}$ represents the value $2^{11}$ in a $12$-bit field, which is interpreted as $2^{11} - 2^{12} = 2048 - 4096 = -2048$.\n- Buggy value (zero-extended): $\\text{disp}$ is interpreted as the unsigned value $2048$.\n- Difference: $2048 - (-2048) = 4096$.\n- This difference is equal to $2^k = 2^{12} = 4096$.\nVerdict: **Correct**.\n\n**B. $k = 12$, $R5 = \\texttt{0x1000}$, $\\text{disp} = \\texttt{0x7FF}$**\nThe displacement is a $k=12$-bit field. The value is $\\text{disp} = \\texttt{0x7FF}$.\nIn binary, $\\texttt{0x7FF}$ is $0111\\ 1111\\ 1111_2$.\nThis is a $12$-bit pattern. The most significant bit (bit $11$) is $0$.\nBased on our derivation, the bug will result in a difference of $0$, not $2^{12}$. Sign extension and zero extension produce the same result.\nVerdict: **Incorrect**.\n\n**C. $k = 12$, $R5 = \\texttt{0x2000}$, $\\text{disp} = \\texttt{0xF20}$**\nThe displacement is a $k=12$-bit field. The value is $\\text{disp} = \\texttt{0xF20}$.\nIn binary, $\\texttt{0xF20}$ is $1111\\ 0010\\ 0000_2$.\nThis is a $12$-bit pattern. The most significant bit (bit $11$) is $1$.\nBased on our derivation, this scenario will produce the specified error.\nTo verify:\n- Unsigned value $D_{12} = \\texttt{0xF20} = 3872$.\n- Correct value (sign-extended): $3872 - 2^{12} = 3872 - 4096 = -224$.\n- Buggy value (zero-extended): $3872$.\n- Difference: $3872 - (-224) = 4096$.\n- This difference is equal to $2^k = 2^{12} = 4096$.\nVerdict: **Correct**.\n\n**D. $k = 10$, $R5 = \\texttt{0xFF00}$, $\\text{disp} = \\texttt{0x120}$**\nThe displacement is a $k=10$-bit field. The problem states to treat $\\texttt{0x120}$ as the \"literal bit pattern of the $k$-bit displacement field\".\nThe hexadecimal literal $\\texttt{0x120}$ corresponds to the $12$-bit pattern $0001\\ 0010\\ 0000_2$.\nA $10$-bit field cannot contain a $12$-bit literal pattern. The premise of this option is contradictory and describes an impossible scenario. As this scenario cannot exist, it cannot be an instance where the bug produces the specified error.\nVerdict: **Incorrect**.\n\n**E. $k = 16$, $R5 = \\texttt{0x0000}$, $\\text{disp} = \\texttt{0x8000}$**\nThe displacement is a $k=16$-bit field. The value is $\\text{disp} = \\texttt{0x8000}$.\nIn binary, $\\texttt{0x8000}$ is $1000\\ 0000\\ 0000\\ 0000_2$.\nThis is a $16$-bit pattern. The most significant bit (bit $15$) is $1$.\nBased on our derivation, this scenario will produce the specified error.\nTo verify:\n- Unsigned value $D_{16} = \\texttt{0x8000} = 32768$.\n- Correct value (sign-extended): $32768 - 2^{16} = 32768 - 65536 = -32768$.\n- Buggy value (zero-extended): $32768$.\n- Difference: $32768 - (-32768) = 65536$.\n- This difference is equal to $2^k = 2^{16} = 65536$.\nVerdict: **Correct**.",
            "answer": "$$\\boxed{ACE}$$"
        },
        {
            "introduction": "Finally, let's see how addressing modes are put to work in a practical programming scenario. This exercise demonstrates the power of the auto-increment addressing mode for efficiently processing sequential data, such as a null-terminated string. By tracing and comparing a byte-by-byte scan with a more aggressive word-by-word scan, you will gain insight into how addressing modes directly influence algorithm implementation and performance. ",
            "id": "3619064",
            "problem": "An Instruction Set Architecture (ISA) provides an auto-increment addressing mode, denoted by placing the base register inside parentheses followed by a plus, and a size suffix indicating operand size. The effective address (EA) is defined as the value used to access memory for the operand; in auto-increment mode, the memory operand at $EA$ is accessed, and then the base register is incremented by the operand size in bytes. The machine is byte-addressable and uses a $4$-byte word. Size-suffixed operations apply to the low-order portion of a register of the specified size. Assume little-endian representation for multi-byte loads so that the byte at address $A$ maps to the low-order byte of the destination register on a word load from $A$.\n\nConsider a null-terminated string in memory beginning at address $B = 0x4000$. The memory contents at and after $B$ are:\n- At $0x4000$: byte $0x41$ (ASCII ‘A’)\n- At $0x4001$: byte $0x42$ (ASCII ‘B’)\n- At $0x4002$: byte $0x43$ (ASCII ‘C’)\n- At $0x4003$: byte $0x00$ (null terminator)\n- At $0x4004$: byte $0x5E$\n- At $0x4005$: byte $0x99$\n- At $0x4006$: byte $0x77$\n- At $0x4007$: byte $0x88$\n- At $0x4008$: byte $0x00$\n- At $0x4009$: byte $0x11$\n\nTwo loops attempt to scan until the null terminator is found. The base register $R_0$ is initialized to $B$. The loops are:\n\n- Byte loop $S_b$:\n  - Loop body: LD.B ($R_0$)+, $R_1$; CMP.B $R_1$, #$0$; BNE back_to_loop\n  - Semantics: LD.B uses $EA = R_0$, loads one byte, then updates $R_0 \\leftarrow R_0 + 1$.\n\n- Word loop $S_w$:\n  - Loop body: LD.W ($R_0$)+, $R_2$; CMP.B $R_2$, #$0$; BNE back_to_loop\n  - Semantics: LD.W uses $EA = R_0$, loads four bytes into $R_2$ with the byte at $EA$ in the low-order byte of $R_2$, then updates $R_0 \\leftarrow R_0 + 4$. CMP.B compares only the low-order byte of $R_2$ to $0$.\n\nWhich option correctly describes, for these specific memory contents and initial $R_0 = 0x4000$, the sequence of $EA$ values used by each loop until it exits and the final value of $R_0$ upon exit?\n\nA. $S_b$: $EA$ sequence $0x4000, 0x4001, 0x4002, 0x4003$; final $R_0 = 0x4004$. $S_w$: $EA$ sequence $0x4000, 0x4004, 0x4008$; final $R_0 = 0x400C$.\n\nB. $S_b$: $EA$ sequence $0x4001, 0x4002, 0x4003$; final $R_0 = 0x4003$. $S_w$: $EA$ sequence $0x4004, 0x4008$; final $R_0 = 0x4008$.\n\nC. $S_b$: $EA$ sequence $0x4000, 0x4001, 0x4002, 0x4003$; final $R_0 = 0x4004$. $S_w$: $EA$ sequence $0x4000, 0x4002, 0x4004$; final $R_0 = 0x4006$.\n\nD. $S_b$: $EA$ sequence $0x4000, 0x4001, 0x4002$; final $R_0 = 0x4003$. $S_w$: $EA$ sequence $0x4000$; final $R_0 = 0x4004$, because the presence of any zero byte in the word causes immediate exit.",
            "solution": "The problem statement has been critically validated and found to be valid. It is scientifically grounded in the principles of computer organization and architecture, well-posed with a unique and determinable solution, and expressed in objective, unambiguous language. All necessary information, including initial memory state, register values, and precise instruction semantics, is provided. The problem is a standard exercise in tracing program execution on a hypothetical but realistic processor architecture.\n\nWe will proceed by simulating the execution of each loop, tracking the relevant register values and memory accesses at each step.\n\n### Analysis of the Byte Loop ($S_b$)\n\nThe byte loop's body is: `LD.B ($R_0$)+, $R_1$; CMP.B $R_1$, #0; BNE back_to_loop`. The initial state is $R_0 = 0x4000$.\n\n- **Iteration 1:**\n  - `LD.B ($R_0$)+, $R_1$`: The effective address ($EA$) is the current value of $R_0$, which is $0x4000$. A single byte is loaded from memory address $0x4000$. The value is $0x41$ (ASCII 'A'). This value is placed in the low-order byte of $R_1$. After the load, $R_0$ is incremented by the operand size, which is $1$ byte.\n    - $EA_1 = 0x4000$\n    - $R_1 \\leftarrow 0x...0041$\n    - $R_0 \\leftarrow 0x4000 + 1 = 0x4001$\n  - `CMP.B $R_1$, #0`: The low-order byte of $R_1$ ($0x41$) is compared to $0$. They are not equal.\n  - `BNE back_to_loop`: The condition (Not Equal) is true, so the branch is taken.\n\n- **Iteration 2:**\n  - `LD.B ($R_0$)+, $R_1$`: The $EA$ is the current value of $R_0$, $0x4001$. The byte at this address, $0x42$, is loaded into $R_1$. $R_0$ is incremented.\n    - $EA_2 = 0x4001$\n    - $R_1 \\leftarrow 0x...0042$\n    - $R_0 \\leftarrow 0x4001 + 1 = 0x4002$\n  - `CMP.B $R_1$, #0`: Compares $0x42$ with $0$. They are not equal.\n  - `BNE back_to_loop`: The branch is taken.\n\n- **Iteration 3:**\n  - `LD.B ($R_0$)+, $R_1$`: The $EA$ is $0x4002$. The byte at this address, $0x43$, is loaded into $R_1$. $R_0$ is incremented.\n    - $EA_3 = 0x4002$\n    - $R_1 \\leftarrow 0x...0043$\n    - $R_0 \\leftarrow 0x4002 + 1 = 0x4003$\n  - `CMP.B $R_1$, #0`: Compares $0x43$ with $0$. They are not equal.\n  - `BNE back_to_loop`: The branch is taken.\n\n- **Iteration 4:**\n  - `LD.B ($R_0$)+, $R_1$`: The $EA$ is $0x4003$. The byte at this address, the null terminator $0x00$, is loaded into $R_1$. $R_0$ is incremented.\n    - $EA_4 = 0x4003$\n    - $R_1 \\leftarrow 0x...0000$\n    - $R_0 \\leftarrow 0x4003 + 1 = 0x4004$\n  - `CMP.B $R_1$, #0`: Compares $0x00$ with $0$. They are equal.\n  - `BNE back_to_loop`: The condition (Not Equal) is false, so the branch is not taken. The loop terminates.\n\n**Summary for $S_b$:**\n- The sequence of effective addresses used is: $0x4000, 0x4001, 0x4002, 0x4003$.\n- The final value of $R_0$ upon loop exit is $0x4004$.\n\n### Analysis of the Word Loop ($S_w$)\n\nThe word loop's body is: `LD.W ($R_0$)+, $R_2$; CMP.B $R_2$, #0; BNE back_to_loop`. The word size is $4$ bytes. The initial state is $R_0 = 0x4000$.\n\n- **Iteration 1:**\n  - `LD.W ($R_0$)+, $R_2$`: The $EA$ is $0x4000$. A $4$-byte word is loaded from memory starting at address $0x4000$. The bytes at addresses $0x4000, 0x4001, 0x4002, 0x4003$ are $0x41, 0x42, 0x43, 0x00$, respectively. Due to the little-endian representation, the byte at the lowest address ($0x4000$) maps to the low-order byte of the register. Thus, the $4$-byte word loaded into $R_2$ is $0x00434241$. After the load, $R_0$ is incremented by the word size, $4$ bytes.\n    - $EA_1 = 0x4000$\n    - $R_2 \\leftarrow 0x00434241$\n    - $R_0 \\leftarrow 0x4000 + 4 = 0x4004$\n  - `CMP.B $R_2$, #0`: This compares only the low-order byte of $R_2$ to $0$. The low-order byte of $R_2$ is $0x41$. This is not equal to $0$.\n  - `BNE back_to_loop`: The condition is true, so the branch is taken.\n\n- **Iteration 2:**\n  - `LD.W ($R_0$)+, $R_2$`: The $EA$ is $0x4004$. A $4$-byte word is loaded from memory starting at address $0x4004$. The bytes at addresses $0x4004, 0x4005, 0x4006, 0x4007$ are $0x5E, 0x99, 0x77, 0x88$. The $4$-byte word loaded into $R_2$ (little-endian) is $0x8877995E$. $R_0$ is incremented.\n    - $EA_2 = 0x4004$\n    - $R_2 \\leftarrow 0x8877995E$\n    - $R_0 \\leftarrow 0x4004 + 4 = 0x4008$\n  - `CMP.B $R_2$, #0`: The low-order byte of $R_2$, which is $0x5E$, is compared to $0$. They are not equal.\n  - `BNE back_to_loop`: The branch is taken.\n\n- **Iteration 3:**\n  - `LD.W ($R_0$)+, $R_2$`: The $EA$ is $0x4008$. A $4$-byte word is loaded from memory starting at address $0x4008$. The bytes at addresses $0x4008, 0x4009, ...$ are $0x00, 0x11, ...$. The byte at $0x4008$, which is $0x00$, becomes the low-order byte of $R_2$. The full word is $0x...1100$. $R_0$ is incremented.\n    - $EA_3 = 0x4008$\n    - $R_2 \\leftarrow$ a value whose low-order byte is $0x00$.\n    - $R_0 \\leftarrow 0x4008 + 4 = 0x400C$\n  - `CMP.B $R_2$, #0`: The low-order byte of $R_2$, which is $0x00$, is compared to $0$. They are equal.\n  - `BNE back_to_loop`: The condition is false, so the branch is not taken. The loop terminates.\n\n**Summary for $S_w$:**\n- The sequence of effective addresses used is: $0x4000, 0x4004, 0x4008$.\n- The final value of $R_0$ upon loop exit is $0x400C$.\n\n### Option Evaluation\n\n- **Option A:** $S_b$: $EA$ sequence $0x4000, 0x4001, 0x4002, 0x4003$; final $R_0 = 0x4004$. $S_w$: $EA$ sequence $0x4000, 0x4004, 0x4008$; final $R_0 = 0x400C$.\n  - This option matches our derived results for both $S_b$ and $S_w$.\n  - **Verdict: Correct**\n\n- **Option B:** $S_b$: $EA$ sequence $0x4001, 0x4002, 0x4003$; final $R_0 = 0x4003$. $S_w$: $EA$ sequence $0x4004, 0x4008$; final $R_0 = 0x4008$.\n  - For $S_b$, the $EA$ sequence is incorrect; it must start with the initial value of $R_0$, which is $0x4000$. The final $R_0$ is incorrect; it should be $0x4004$.\n  - For $S_w$, the $EA$ sequence is similarly incorrect, missing the initial access at $0x4000$. The final $R_0$ is incorrect; it should be $0x400C$.\n  - **Verdict: Incorrect**\n\n- **Option C:** $S_b$: $EA$ sequence $0x4000, 0x4001, 0x4002, 0x4003$; final $R_0 = 0x4004$. $S_w$: $EA$ sequence $0x4000, 0x4002, 0x4004$; final $R_0 = 0x4006$.\n  - The description for $S_b$ is correct.\n  - For $S_w$, the $EA$ sequence is incorrect. The auto-increment is by the operand size (word, $4$ bytes), so the addresses should increment by $4$ ($0x4000, 0x4004, ...$), not by $2$. The final $R_0$ value is also incorrect as a result.\n  - **Verdict: Incorrect**\n\n- **Option D:** $S_b$: $EA$ sequence $0x4000, 0x4001, 0x4002$; final $R_0 = 0x4003$. $S_w$: $EA$ sequence $0x4000$; final $R_0 = 0x4004$, because the presence of any zero byte in the word causes immediate exit.\n  - For $S_b$, the $EA$ sequence is incomplete; it fails to include the access at $0x4003$ which finds the null terminator. The final $R_0$ is incorrect because the final increment is not accounted for.\n  - For $S_w$, the reasoning is flawed. The problem explicitly states that `CMP.B` compares *only the low-order byte* of $R_2$. The first word loaded ($0x00434241$) contains a zero byte, but its low-order byte is $0x41$. Therefore, the loop does not exit after the first iteration.\n  - **Verdict: Incorrect**",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}