{
    "hands_on_practices": [
        {
            "introduction": "为了改变执行流程，处理器需要知道跳转到哪里。大多数架构不使用绝对地址，而是采用一种更高效的方法：程序计数器（$PC$）相对寻址，即指定一个相对于当前指令的目标地址。这个实践问题  将让你像汇编器一样，亲自计算出分支指令所需的精确偏移量，并需要考虑指令大小和处理器程序计数器（$PC$）更新规则等架构细节。",
            "id": "3629897",
            "problem": "一个计算机系统实现了一种类 MIPS 的指令集架构 (ISA)，其中每条指令的大小为 $4$ 字节，条件分支使用一个 $16$ 位有符号偏移量字段，该字段以指令为单位进行解释。硬件计算分支目标地址的公式为 $PC + 4 + (\\text{offset} \\ll 2)$，其中 $PC$ 是指向分支指令的程序计数器 (PC)，$+4$ 反映了在加上偏移量之前 PC 会先前进 $+4$，并且在形成目标地址时，$\\text{offset}$ 会被符号扩展到 $32$ 位并乘以 $4$。\n\n一个可重定位目标文件包含一个代码段 (text)，其中记录了汇编器标签相对于该段的字节偏移量。在加载时，操作系统加载器将整个文本段映射到一个绝对基地址 $B_{\\text{text}}$，并且还会应用一个进程范围的加载偏置 $\\Delta$，因此文本段在内存中的绝对基地址为 $\\tilde{B} = B_{\\text{text}} + \\Delta$。文本段中所有标签的地址都通过将其段内相对偏移量加上 $\\tilde{B}$ 来进行重定位。\n\n考虑以下具体实例：\n- 映射后文本段的绝对基地址为 $\\tilde{B} = B_{\\text{text}} + \\Delta$，其中 $B_{\\text{text}} = 0x0001\\,8000$ 且 $\\Delta = 0x0000\\,4000$。\n- 一条分支指令在段内相对偏移量 $o_b = 0x0000\\,012C$ 处被汇编，其目标汇编器标签名为 $\\text{target}$，位于段内相对偏移量 $o_t = 0x0000\\,00D8$ 处。\n\n计算要放入 $16$ 位分支偏移量字段中的确切有符号整数值，以便在重定位并使用架构的 $+4$ PC 偏置后，该分支能够到达 $\\text{target}$。请将最终答案表示为单个整数。不需要四舍五入，答案中也不应包含单位。",
            "solution": "题目指定了类 MIPS 的分支语义：硬件计算分支目标地址的方式如下\n$$\nA_{\\text{branch-target}} = PC + 4 + (\\text{offset} \\ll 2).\n$$\n这里，$\\text{offset}$ 是指令中的 $16$ 位有符号立即数，它会被符号扩展到 $32$ 位，然后左移 $2$ 位相当于乘以 $4$，因为指令是 $4$ 字节。\n\n我们已知重定位的细节。文本段被放置在一个由以下公式定义的绝对基地址 $\\tilde{B}$ 处\n$$\n\\tilde{B} = B_{\\text{text}} + \\Delta,\n$$\n其中 $B_{\\text{text}} = 0x0001\\,8000$ 且 $\\Delta = 0x0000\\,4000$。因此，绝对基地址 $\\tilde{B}$ 为\n$$\n\\tilde{B} = 0x0001\\,8000 + 0x0000\\,4000 = 0x0001\\,C000.\n$$\n然而，对于同一重定位段内的 PC 相对分支，计算偏移量时绝对基地址会相互抵消。我们将明确地展示这一点。\n\n设 $o_b$ 为分支指令的段内相对字节偏移量，$o_t$ 为目标标签的段内相对字节偏移量。它们的绝对地址是\n$$\nA_b = \\tilde{B} + o_b,\\quad A_t = \\tilde{B} + o_t.\n$$\n因为 PC 指向分支指令，所以分支计算中使用的 PC 是 $PC = A_b$。硬件首先加上 $+4$ 的偏置，因此\n$$\nPC + 4 = A_b + 4 = \\tilde{B} + o_b + 4.\n$$\n我们需要分支跳转到 $A_t$。将硬件计算的目标地址设为等于 $A_t$ 可得\n$$\nA_t = (PC + 4) + (\\text{offset} \\ll 2) = (\\tilde{B} + o_b + 4) + (\\text{offset} \\cdot 4).\n$$\n求解 $\\text{offset}$：\n$$\n\\text{offset} \\cdot 4 = A_t - (\\tilde{B} + o_b + 4) = (\\tilde{B} + o_t) - (\\tilde{B} + o_b + 4) = o_t - (o_b + 4),\n$$\n所以\n$$\n\\text{offset} = \\frac{o_t - (o_b + 4)}{4}.\n$$\n正如预期的那样，重定位基地址 $\\tilde{B}$ 被消掉了，只剩下由 $+4$ 偏置调整后的段内相对偏移量之差。\n\n现在代入给定的偏移量，$o_b = 0x0000\\,012C$ 和 $o_t = 0x0000\\,00D8$。转换为十进制进行计算：\n$$\no_b = 0x012C = 300,\\quad o_t = 0x00D8 = 216.\n$$\n计算 $o_t - (o_b + 4)$：\n$$\no_t - (o_b + 4) = 216 - (300 + 4) = 216 - 304 = -88.\n$$\n除以 $4$ 得到以指令为单位的偏移量：\n$$\n\\text{offset} = \\frac{-88}{4} = -22.\n$$\n检查是否在 $16$ 位有符号立即数的范围内：$-22$ 在 $[-32768, 32767]$ 之间，因此可以表示而不会溢出。这就是要编码到分支偏移量字段中的确切整数。",
            "answer": "$$\\boxed{-22}$$"
        },
        {
            "introduction": "在现代流水线处理器中，一次错误的转向——即分支预测失误——可能会代价高昂，导致流水线被清空并浪费大量时钟周期。为了避免这种情况，CPU 使用分支预测器在分支指令执行前猜测其走向。这个练习  将让你比较一个简单的1位预测器和一个更复杂的2位预测器的性能，并揭示它们的效率如何根据程序的行为模式发生巨大变化。",
            "id": "3629826",
            "problem": "中央处理器 (CPU) 中的一个静态条件分支控制着一个循环的后向边。在这样的循环中，分支结果在连续固定次数的迭代中为“跳转”，然后有一次为“不跳转”以退出循环，之后循环重复。考虑两个代码区域，它们都使用这同一个静态分支，但具有不同的“跳转”偏向。“跳转”偏向定义为长期来看结果为“跳转”的比例。\n\n- 循环 A 的跳转偏向为 $p_{A} = 0.9$。\n- 循环 B 的跳转偏向为 $p_{B} = 0.5$。\n\n假设分支预测器是局部动态的，使用以下两种之一：\n- 一个 $1$-bit 内存预测器，它预测下一个结果与此静态分支的最近一次结果相同，或\n- 一个具有四种状态的 $2$-bit 饱和计数器预测器，其中在高两位状态下预测为“跳转”，在低两位状态下预测为“不跳转”，状态转换在结果为“跳转”时递增，在结果为“不跳转”时递減，且不会超出范围。\n\n假设测量窗口在跳转偏向状态预热后开始：对于此分支的第一个被测量的结果，$1$-bit 预测器最初预测为“跳转”，而 $2$-bit 预测器最初处于最强的“跳转”状态。仅使用循环分支的基本语义（除最后一次迭代外，每次迭代都跳转）和上述定义，从基本原理出发，推导每个预测器在每个循环上每 $1000$ 个分支结果中的预期错误预测数。将最终结果以单行矩阵的形式给出，顺序为 $(M_{1\\text{-bit},\\,A},\\,M_{2\\text{-bit},\\,A},\\,M_{1\\text{-bit},\\,B},\\,M_{2\\text{-bit},\\,B})$，其中 $M_{\\cdot}$ 表示在 $1000$ 个结果中计数的错误预测数。无需四舍五入，并报告原始计数，不带任何单位。",
            "solution": "该问题是有效的，因为它科学地基于计算机体系结构原理，特别是分支预测，并且问题是良构的，具有唯一的可推导解。所有术语都有形式化定义，数据也是一致的。\n\n问题的核心是确定两种类型的分支预测器在两种不同循环上的预期错误预测数。分析分两个阶段进行：首先，根据给定的跳转偏向，描述每个循环的分支结果模式；其次，在这些模式上模拟每个预测器的行为，以找出错误预测率。\n\n**1. 循环分支模式的推导**\n\n问题陈述了一个静态条件分支控制循环的后向边。这意味着一个重复的结果模式：分支在固定数量的迭代（比如 $N$ 次）中为“跳转”，然后有一次为“不跳转”以退出循环。因此，循环分支结果的一个完整周期由 $N$ 次“跳转”分支和 $1$ 次“不跳转”分支组成。一个周期内的分支总数为 $N+1$。\n\n跳转偏向 $p$ 定义为長期來看结果为“跳转”的比例。对于这种循环结构，偏向由一个周期内“跳转”分支数与分支总数的比率给出：\n$$p = \\frac{N}{N+1}$$\n我们可以根据 $p$ 解出 $N$：\n$$p(N+1) = N$$\n$$pN + p = N$$\n$$p = N - pN = N(1-p)$$\n$$N = \\frac{p}{1-p}$$\n\n使用这个公式，我们可以确定每个循环的 $N$ 值。\n\n*   **循环 A**：跳转偏向为 $p_A = 0.9$。连续跳转分支的数量 $N_A$ 是：\n    $$N_A = \\frac{p_A}{1-p_A} = \\frac{0.9}{1-0.9} = \\frac{0.9}{0.1} = 9$$\n    因此，循环 A 的分支模式是一个周期，包含 $9$ 个“跳转”结果 (T) 和 $1$ 个“不跳转”结果 (NT)。周期长度为 $N_A + 1 = 10$ 个分支。\n\n*   **循环 B**：跳转偏向为 $p_B = 0.5$。连续跳转分支的数量 $N_B$ 是：\n    $$N_B = \\frac{p_B}{1-p_B} = \\frac{0.5}{1-0.5} = \\frac{0.5}{0.5} = 1$$\n    因此，循环 B 的分支模式是一个周期，包含 $1$ 个“跳转”结果 (T) 和 $1$ 个“不跳转”结果 (NT)。周期长度为 $N_B + 1 = 2$ 个分支。\n\n**2. 预测器性能分析**\n\n我们现在分析每个预测器在每个循环模式下的稳态性能，以确定每 $1000$ 个结果中的预期错误预测数。术语“预期数量”意味着使用长期错误预测率。\n\n**情况 1：1-bit 预测器**\n\n该预测器使用 1 位历史记录，预测下一个结果将与最近一次的结果相同。\n\n*   **对于循环 A (9 次 T, 1 次 NT)**：重复的结果序列是 T, T, T, T, T, T, T, T, T, NT。\n    让我们追踪一个稳态周期。前一个周期最后一个分支的结果是 NT。因此，进入新周期时预测器的状态是‘预测不跳转’。\n    1.  分支 1 (结果 T)：预测为 NT。**错误预测**。预测器状态更新为‘跳转’。\n    2.  分支 2-9 (结果 T)：预测为 T。所有 $8$ 次都正确。状态保持为‘跳转’。\n    3.  分支 10 (结果 NT)：预测为 T。**错误预测**。预测器状态更新为‘不跳转’。\n    在每个包含 $10$ 个分支的周期中，有 $2$ 次错误预测。\n    错误预测率为 $\\frac{2}{10} = 0.2$。\n    每 $1000$ 个结果的预期错误预测数为 $M_{1\\text{-bit},\\,A} = 1000 \\times 0.2 = 200$。\n\n*   **对于循环 B (1 次 T, 1 次 NT)**：重复的结果序列是 T, NT。\n    让我们追踪一个稳态周期。在前一个 NT 之后，进入该周期时预测器的状态是‘预测不跳转’。\n    1.  分支 1 (结果 T)：预测为 NT。**错误预测**。状态更新为‘跳转’。\n    2.  分支 2 (结果 NT)：预测为 T。**错误预测**。状态更新为‘不跳转’。\n    每个分支都被错误预测。在每个包含 $2$ 个分支的周期中，有 $2$ 次错误预测。\n    错误预测率为 $\\frac{2}{2} = 1.0$。\n    每 $1000$ 个结果的预期错误预测数为 $M_{1\\text{-bit},\\,B} = 1000 \\times 1.0 = 1000$。\n\n**情况 2：2-bit 饱和计数器预测器**\n\n该预测器使用一个 4 状态计数器：{3: 强跳转, 2: 弱跳转, 1: 弱不跳转, 0: 强不跳转}。它在状态 3 和 2 时预测‘跳转’，在状态 1 和 0 时预测‘不跳转’。对于“跳转”结果，计数器递增（在 3 处饱和）；对于“不跳转”结果，计数器递减（在 0 处饱和）。初始状态给定为状态 3。\n\n*   **对于循环 A (9 次 T, 1 次 NT)**：\n    1.  分支 1-9 (结果 T)：初始状态为 3。预测为 T。这是正确的。对于这 $9$ 个“跳转”分支中的每一个，计数器试图递增，但已在 3 处饱和。对所有 $9$ 个分支的预测都是正确的。\n    2.  分支 10 (结果 NT)：状态为 3。预测为 T。**错误预测**。状态递减到 2。\n    下一个周期开始时，预测器处于状态 2。\n    3.  下一个周期的分支 1 (结果 T)：状态为 2。预测为 T。这是正确的。状态递增到 3。\n    预测器迅速返回到强跳转状态。在每个包含 $10$ 个分支的周期中，只有那一个“不跳转”分支被错误预测。\n    错误预测率为 $\\frac{1}{10} = 0.1$。\n    每 $1000$ 个结果的预期错误预测数为 $M_{2\\text{-bit},\\,A} = 1000 \\times 0.1 = 100$。\n\n*   **对于循环 B (1 次 T, 1 次 NT)**：\n    1.  分支 1 (结果 T)：初始状态为 3。预测为 T。这是正确的。状态保持为 3 (饱和)。\n    2.  分支 2 (结果 NT)：状态为 3。预测为 T。**错误预测**。状态递减到 2。\n    下一个周期开始时，预测器处于状态 2。\n    3.  下一个周期的分支 1 (结果 T)：状态为 2。预测为 T。这是正确的。状态递增到 3。\n    4.  下一个周期的分支 2 (结果 NT)：状态为 3。预测为 T。**错误预测**。状态递减到 2。\n    在稳态下，预测器的状态在 3 和 2 之间交替。由于这两个状态都预测‘跳转’，所以预测总是 T。结果序列交替出现 T, NT。因此，每个 T 分支都被正确预测，而每个 NT 分支都被错误预测。\n    在每个包含 $2$ 个分支的周期中，有 $1$ 次错误预测。\n    错误预测率为 $\\frac{1}{2} = 0.5$。\n    每 $1000$ 个结果的预期错误预测数为 $M_{2\\text{-bit},\\,B} = 1000 \\times 0.5 = 500$。\n\n**结果总结**\n\n计算出的每种情况下每 $1000$ 个结果的错误预测数如下：\n*   $M_{1\\text{-bit},\\,A} = 200$\n*   $M_{2\\text{-bit},\\,A} = 100$\n*   $M_{1\\text{-bit},\\,B} = 1000$\n*   $M_{2\\text{-bit},\\,B} = 500$\n\n这些结果需要以单行矩阵的形式提供。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n200  100  1000  500\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "控制流不仅关乎性能，更关键的是要确保正确性。当处理浮点运算时，这一点尤其具有挑战性，因为像“非数值”（Not-a-Number, NaN）这样的特殊值会根据 IEEE $754$ 标准产生意想不到的结果。这个难题  要求你挑选出正确的条件分支序列来实现一个比较操作，该操作即使在出现无序（unordered）情况时也能正确处理，这是编写健壮底层代码的一项关键技能。",
            "id": "3629890",
            "problem": "一个处理器实现了一条浮点比较指令，该指令会写入条件码，后续的条件分支会读取这些条件码。现要求您判断几段分支序列的正确性，其中比较操作可能会遇到非数值 (NaN) 值。所需的高层语义与 C 语言在电气和电子工程师协会 (IEEE) $754$ 标准二进制浮点数下的语义相同：对于诸如 $\\leq$ 的关系运算符，如果任一操作数为 NaN（比较是无序的），则结果为假。\n\n基本原理和定义：\n- 根据 IEEE $754$ 标准，如果两个操作数都不是 NaN，则比较称为有序比较；如果至少有一个操作数是 NaN，则比较称为无序比较。对于诸如 $$、$\\leq$、$>$、$\\geq$ 的关系运算符，有序比较下关系成立则结果为真，无序比较则为假；对于相等运算符 $==$，无序比较结果为假；对于不等运算符 $\\neq$，无序比较结果为真。\n- 处理器的指令 $\\text{FCMP.S}\\;R_{x},R_{y}$ 比较 $R_{x}$ 和 $R_{y}$ 中的单精度浮点值，并设置三个条件码标志位：零标志位 $Z$、进位标志位 $C$ 和奇偶标志位 $P$，其含义与众所周知的约定一致：\n  - 如果 $R_{x}  R_{y}$：$C=1$, $Z=0$, $P=0$。\n  - 如果 $R_{x} = R_{y}$：$C=0$, $Z=1$, $P=0$。\n  - 如果 $R_{x} > R_{y}$：$C=0$, $Z=0$, $P=0$。\n  - 如果无序（至少一个操作数是 NaN）：$C=1$, $Z=1$, $P=1$。\n- 条件分支按如下方式解释标志位：\n  - $\\text{JBE}\\;L$：如果小于或等于则跳转，即如果 $(C=1)\\lor(Z=1)$。\n  - $\\text{JA}\\;L$：如果大于则跳转，即如果 $(C=0)\\land(Z=0)$。\n  - $\\text{JP}\\;L$：如果为奇偶则跳转，即如果 $P=1$（无序）。\n  - $\\text{JNP}\\;L$：如果非奇偶则跳转，即如果 $P=0$（有序）。\n  - $\\text{JE}\\;L$：如果相等则跳转，即如果 $Z=1$。\n  - $\\text{JNE}\\;L$：如果不相等则跳转，即如果 $Z=0$。\n\n目标：\n为 C 风格的条件语句“如果 $(R_{x} \\leq R_{y})$ 则转到标签 $L_{\\text{true}}$ 否则转到标签 $L_{\\text{false}}$”实现控制流，并遵循 IEEE $754$ 规则，即无序比较的结果为假。假设代码序列总是以 $\\text{FCMP.S}\\;R_{x},R_{y}$ 开始，并且允许使用一条无条件跳转到剩余标签的指令。选择下面所有能为所有情况（包括任一输入为 NaN 的情况）正确实现所需控制流的选项。\n\n考虑以下候选序列（每个序列都紧跟在 $\\text{FCMP.S}\\;R_{x},R_{y}$ 之后）：\n- A.\n  - $\\text{JBE}\\;L_{\\text{true}}$\n  - $\\text{JMP}\\;L_{\\text{false}}$\n- B.\n  - $\\text{JP}\\;L_{\\text{false}}$\n  - $\\text{JBE}\\;L_{\\text{true}}$\n  - $\\text{JMP}\\;L_{\\text{false}}$\n- C.\n  - $\\text{JNP}\\;L_{\\text{ordered}}$\n  - $\\text{JMP}\\;L_{\\text{false}}$\n  - $L_{\\text{ordered}}$:\n  - $\\text{JBE}\\;L_{\\text{true}}$\n  - $\\text{JMP}\\;L_{\\text{false}}$\n- D.\n  - $\\text{JA}\\;L_{\\text{false}}$\n  - $\\text{JP}\\;L_{\\text{false}}$\n  - $\\text{JMP}\\;L_{\\text{true}}$\n\n选择所有正确的选项。干扰项反映了关于在浮点比较后直接使用“小于或等于”分支指令以及未能明确排除无序情况的常见误解。",
            "solution": "### 问题验证\n\n本节在进行求解之前验证问题陈述的有效性。\n\n#### 第一步：提取已知信息\n\n问题提供了以下定义和条件：\n\n*   **目标：** 为 C 语言风格的条件语句“如果 ($R_{x} \\leq R_{y}$) 则转到标签 $L_{\\text{true}}$ 否则转到标签 $L_{\\text{false}}$”实现控制流。\n*   **IEEE 754 语义：** 对于像 $\\leq$ 这样的 C 风格关系运算符，如果任一操作数为非数值 (NaN)，则结果为 `false`。这被称为 `unordered`（无序）比较。\n*   **比较指令：** $\\text{FCMP.S}\\;R_{x},R_{y}$ 比较两个单精度浮点寄存器 $R_{x}$ 和 $R_{y}$，并设置三个条件码标志位：零 ($Z$)、进位 ($C$) 和奇偶 ($P$)。\n*   **$\\text{FCMP.S}\\;R_{x},R_{y}$ 后的标志位设置：**\n    *   如果 $R_{x}  R_{y}$：$C=1$, $Z=0$, $P=0$。\n    *   如果 $R_{x} = R_{y}$：$C=0$, $Z=1$, $P=0$。\n    *   如果 $R_{x} > R_{y}$：$C=0$, $Z=0$, $P=0$。\n    *   如果无序（至少一个操作数是 NaN）：$C=1$, $Z=1$, $P=1$。\n*   **条件分支指令：** 问题定义了几个基于标志位值的跳转指令的行为：\n    *   $\\text{JBE}\\;L$：如果小于或等于则跳转，在 $(C=1)\\lor(Z=1)$ 时执行。\n    *   $\\text{JA}\\;L$：如果大于则跳转，在 $(C=0)\\land(Z=0)$ 时执行。\n    *   $\\text{JP}\\;L$：如果为奇偶则跳转，在 $P=1$ 时执行。\n    *   $\\text{JNP}\\;L$：如果非奇偶则跳转，在 $P=0$ 时执行。\n    *   $\\text{JE}\\;L$：如果相等则跳转，在 $Z=1$ 时执行。\n    *   $\\text{JNE}\\;L$：如果不相等则跳转，在 $Z=0$ 时执行。\n*   **假设：** 每个候选代码序列都紧跟在 $\\text{FCMP.S}\\;R_{x},R_{y}$ 指令之后。允许使用无条件跳转指令 $\\text{JMP}$。\n\n#### 第二步：使用提取的已知信息进行验证\n\n1.  **科学性：** 该问题牢固地基于计算机组织与体系结构中的标准概念，即 IEEE $754$ 浮点标准和条件码与条件分支的使用。特定的标志位设置 ($C, Z, P$) 是一个合理且一致的模型，其原理与真实世界的指令集架构（例如 x86 FPU 或 ARM VFP）中的设置相似。该问题在科学和技术上是合理的。\n2.  **良构性：** 问题提供了清晰明确的目标、一套完整的用于管理指令和标志位行为的规则，以及一组有限的测试用例（比较的四种结果）。这使得对每个提出的代码序列进行确定性评估成为可能。\n3.  **客观性：** 问题陈述使用精确、客观和技术性的语言表达。在指令或结果的定义中没有主观因素或模糊之处。\n4.  **完整性和一致性：** 信息充分且自洽。为浮点比较的所有可能结果（$, =, >, \\text{无序}$）都定义了标志位设置。每个条件跳转的逻辑都已明确提供。没有矛盾之处。\n\n#### 第三步：结论与行动\n\n问题陈述是**有效的**。这是一个定义明确、具有科学依据的计算机体系结构问题。可以继续进行求解过程。\n\n### 求解推导\n\n目标是为 `if ($R_{x} \\leq R_{y}$) then goto $L_{\\text{true}}$ else goto $L_{\\text{false}}$` 实现逻辑。根据指定的 IEEE $754$ 语义，条件 ($R_{x} \\leq R_{y}$) 仅在比较是有序且关系成立时为真。如果比较是无序的（即涉及 NaN）或 $R_{x} > R_{y}$，则为假。\n\n我们可以根据 $\\text{FCMP.S}\\;R_{x},R_{y}$ 的结果总结所需的控制流：\n\n| 比较结果 | 标志位 ($C, Z, P$) | 期望目标 |\n| :---------------- | :------------------ | :------------- |\n| $R_x  R_y$       | $C=1, Z=0, P=0$     | $L_{\\text{true}}$     |\n| $R_x = R_y$       | $C=0, Z=1, P=0$     | $L_{\\text{true}}$     |\n| $R_x > R_y$       | $C=0, Z=0, P=0$     | $L_{\\text{false}}$    |\n| 无序 (NaN)   | $C=1, Z=1, P=1$     | $L_{\\text{false}}$    |\n\n任务是根据此表评估每个提议的指令序列。\n\n### 逐项分析\n\n#### 选项 A\n序列：\n```\nJBE  L_{\\text{true}}\nJMP  L_{\\text{false}}\n```\n$\\text{JBE}$ 指令在 $(C=1) \\lor (Z=1)$ 时跳转。\n*   **情况 $R_{x}  R_{y}$ ($C=1, Z=0$)：** 条件 $(1=1) \\lor (0=1)$ 为真。代码跳转到 $L_{\\text{true}}$。**正确。**\n*   **情况 $R_{x} = R_{y}$ ($C=0, Z=1$)：** 条件 $(0=1) \\lor (1=1)$ 为真。代码跳转到 $L_{\\text{true}}$。**正确。**\n*   **情况 $R_{x} > R_{y}$ ($C=0, Z=0$)：** 条件 $(0=1) \\lor (0=1)$ 为假。代码向下执行到 $\\text{JMP}\\;L_{\\text{false}}$。**正确。**\n*   **情况 无序 ($C=1, Z=1$)：** 条件 $(1=1) \\lor (1=1)$ 为真。代码跳转到 $L_{\\text{true}}$。这是**不正确的**，因为期望的结果是跳转到 $L_{\\text{false}}$。\n\n**A 的结论：** **不正确**。该序列未能正确处理无序 (NaN) 情况，这是将浮点比较映射到整数风格分支时常见的错误。\n\n#### 选项 B\n序列：\n```\nJP   L_{\\text{false}}\nJBE  L_{\\text{true}}\nJMP  L_{\\text{false}}\n```\n$\\text{JP}$ 指令在 $P=1$ 时跳转，这专门针对无序情况。\n*   **情况 无序 ($P=1$)：** 条件 $P=1$ 为真。代码跳转到 $L_{\\text{false}}$。**正确。**\n*   对于所有其他情况（$R_{x}  R_{y}$、$R_{x} = R_{y}$、$R_{x} > R_{y}$），$P=0$，因此 $\\text{JP}$ 不会跳转。控制流继续到 $\\text{JBE}$ 指令。\n*   **情况 $R_{x}  R_{y}$ ($C=1, Z=0$)：** $\\text{JBE}$ 条件 $(1=1) \\lor (0=1)$ 为真。代码跳转到 $L_{\\text{true}}$。**正确。**\n*   **情况 $R_{x} = R_{y}$ ($C=0, Z=1$)：** $\\text{JBE}$ 条件 $(0=1) \\lor (1=1)$ 为真。代码跳转到 $L_{\\text{true}}$。**正确。**\n*   **情况 $R_{x} > R_{y}$ ($C=0, Z=0$)：** $\\text{JBE}$ 条件 $(0=1) \\lor (0=1)$ 为假。代码向下执行到 $\\text{JMP}\\;L_{\\text{false}}$。**正确。**\n\n**B 的结论：** **正确**。该序列通过首先明确检查无序条件并进行分支，正确处理了所有四种情况。\n\n#### 选项 C\n序列：\n```\nJNP  L_{\\text{ordered}}\nJMP  L_{\\text{false}}\nL_{\\text{ordered}}:\nJBE  L_{\\text{true}}\nJMP  L_{\\text{false}}\n```\n$\\text{JNP}$ 指令在 $P=0$ 时跳转，这针对所有有序情况。\n*   **情况 无序 ($P=1$)：** 条件 $P=0$ 为假。$\\text{JNP}$ 不会跳转。代码向下执行到 $\\text{JMP}\\;L_{\\text{false}}$。**正确。**\n*   对于所有其他情况（$R_{x}  R_{y}$、$R_{x} = R_{y}$、$R_{x} > R_{y}$），$P=0$，因此 $\\text{JNP}$ 会跳转，控制权转移到标签 $L_{\\text{ordered}}$。\n*   在 $L_{\\text{ordered}}$ 处，我们有序列 `JBE L_true; JMP L_false`，我们之前在选项 A 中已经为有序情况分析过它。\n    *   **情况 $R_{x}  R_{y}$ ($C=1, Z=0$)：** $\\text{JBE}$ 跳转。跳转到 $L_{\\text{true}}$。**正确。**\n    *   **情况 $R_{x} = R_{y}$ ($C=0, Z=1$)：** $\\text{JBE}$ 跳转。跳转到 $L_{\\text{true}}$。**正确。**\n    *   **情况 $R_{x} > R_{y}$ ($C=0, Z=0$)：** $\\text{JBE}$ 不跳转。向下执行到 $\\text{JMP}\\;L_{\\text{false}}$。**正确。**\n\n**C 的结论：** **正确**。该序列在逻辑上等同于选项 B。它明确地将有序情况的逻辑与无序情况分离开来。\n\n#### 选项 D\n序列：\n```\nJA   L_{\\text{false}}\nJP   L_{\\text{false}}\nJMP  L_{\\text{true}}\n```\n该序列使用了一种不同的策略：它识别所有应导致 `false` 结果的条件并跳转到 $L_{\\text{false}}$，让 `true` 结果向下执行到一条到 $L_{\\text{true}}$ 的无条件跳转。\n条件在 ($R_{x} > R_{y}$) 和 (无序) 时应为假。\n*   **情况 $R_{x} > R_{y}$ ($C=0, Z=0, P=0$)：** $\\text{JA}$ 指令检查是否 $(C=0) \\land (Z=0)$。此处，$(0=0) \\land (0=0)$ 为真。代码跳转到 $L_{\\text{false}}$。**正确。**\n*   **情况 无序 ($C=1, Z=1, P=1$)：** $\\text{JA}$ 条件 $(1=0) \\land (1=0)$ 为假。$\\text{JA}$ 不跳转。控制流继续到 $\\text{JP}$。$\\text{JP}$ 条件 $P=1$ 为真。代码跳转到 $L_{\\text{false}}$。**正确。**\n*   **情况 $R_{x}  R_{y}$ ($C=1, Z=0, P=0$)：** $\\text{JA}$ 条件 $(1=0) \\land (0=0)$ 为假。代码向下执行。$\\text{JP}$ 条件 $P=1$ 为假。代码向下执行到 $\\text{JMP}\\;L_{\\text{true}}$。**正确。**\n*   **情况 $R_{x} = R_{y}$ ($C=0, Z=1, P=0$)：** $\\text{JA}$ 条件 $(0=0) \\land (1=0)$ 为假。代码向下执行。$\\text{JP}$ 条件 $P=1$ 为假。代码向下执行到 $\\text{JMP}\\;L_{\\text{true}}$。**正确。**\n\n**D 的结论：** **正确**。该序列通过过滤掉假条件并默认跳转到真，正确地实现了逻辑。",
            "answer": "$$\\boxed{BCD}$$"
        }
    ]
}