{
    "hands_on_practices": [
        {
            "introduction": "The most effective way to understand how a machine executes instructions is to build a simplified model of one yourself. This exercise guides you through creating a basic CPU interpreter that decodes and executes R-type, I-type, and J-type instructions from first principles. By implementing the logic for parsing instruction bits and manipulating a simulated register file and program counter , you will gain a concrete understanding of how abstract instruction formats translate into tangible computational steps and directly observe the critical importance of details like sign extension.",
            "id": "3649792",
            "problem": "You are to implement a self-contained interpreter for a reduced, MIPS-like instruction set, focusing on Instruction Set Architecture (ISA) instruction formats: Register-type (R-type), Immediate-type (I-type), and Jump-type (J-type). The interpreter must decode and execute a small set of operations and intentionally include a specific bug: omit sign extension for the I-type immediate field. You must then use unit tests to observe the effect of this bug on arithmetic and control flow.\n\nFundamental base and core definitions:\n- Two's complement integers: A signed $n$-bit two's complement integer represents values in the range $[-2^{n-1}, 2^{n-1}-1]$. Sign extension from $n$ bits to $m$ bits ($m > n$) replicates the most significant bit (the sign bit) of the $n$-bit representation into the upper $m-n$ bits.\n- R-type instruction format ($32$ bits): Bits $[31:26]$ are the opcode, bits $[25:21]$ are the source register $rs$, bits $[20:16]$ are the source register $rt$, bits $[15:11]$ are the destination register $rd$, bits $[10:6]$ are the shift amount $shamt$, and bits $[5:0]$ are the function field $funct$. We limit to opcode $0$ and use $funct=32$ for addition.\n- I-type instruction format ($32$ bits): Bits $[31:26]$ are the opcode, bits $[25:21]$ are $rs$, bits $[20:16]$ are $rt$, and bits $[15:0]$ are the immediate. Proper arithmetic requires that the $16$-bit immediate be sign-extended to $32$ bits before use.\n- J-type instruction format ($32$ bits): Bits $[31:26]$ are the opcode and bits $[25:0]$ are the target address component. The Program Counter (PC) update uses $$\\mathrm{PC} \\leftarrow (\\mathrm{PC} \\ \\& \\ 0xF0000000) \\ \\vert \\ (\\text{target} \\ll 2),$$ where $\\ll$ denotes left-shift and `&`, `|` denote bitwise AND and OR, respectively.\n- Program Counter (PC) model: The PC starts at $0$, each instruction is $4$ bytes, and the normal sequential update is $\\mathrm{PC} \\leftarrow \\mathrm{PC} + 4$ unless modified by branch or jump.\n\nSupported operations to implement:\n- R-type add: $rd \\leftarrow rs + rt$ for $funct = 32$ and $opcode = 0$.\n- I-type add immediate: $rt \\leftarrow rs + \\text{imm}$ for $opcode = 8$ (Add Immediate). Correct behavior requires sign extension of the $16$-bit immediate to $32$ bits.\n- I-type branch if equal: For $opcode = 4$, if $rs = rt$ then $$\\mathrm{PC} \\leftarrow \\mathrm{PC} + 4 + (\\text{sign-extended immediate} \\times 4),$$ else $$\\mathrm{PC} \\leftarrow \\mathrm{PC} + 4.$$\n- J-type jump: For $opcode = 2$, use the J-type PC update above.\n\nBug to include:\n- In the buggy interpreter, omit sign extension for the I-type immediate by treating the $16$-bit immediate as a zero-extended $32$-bit value. This affects both arithmetic (Add Immediate) and control flow (Branch if Equal).\n\nAlgorithmic requirements:\n- Decode fields using bit masks and shifts derived from the format definitions. For example, $rs = (\\text{word} \\gg 21) \\ \\& \\ 0x1F$, $rt = (\\text{word} \\gg 16) \\ \\& \\ 0x1F$, $rd = (\\text{word} \\gg 11) \\ \\& \\ 0x1F$, $funct = \\text{word} \\ \\& \\ 0x3F$, and $opcode = (\\text{word} \\gg 26) \\ \\& \\ 0x3F$.\n- Implement two interpreters: a correct one with proper sign extension and a buggy one omitting sign extension.\n- Registers: Use $32$ general-purpose registers initialized to $0$. Ignore memory operations; the program is a pure register and control flow simulator.\n- Halting rule: Halt when $\\mathrm{PC}/4$ is outside the instruction array bounds or a safety step limit is reached.\n\nTest suite and coverage:\nUse the following four programs (each is an array of $32$-bit instructions). All registers start at $0$; $\\mathrm{PC}$ starts at $0$. For each program, report the final value of register $r1$ under both the buggy interpreter and the correct interpreter.\n\n- Test case $1$ (happy path, positive immediate and R-type add):\n  1. I-type: addi $r1, r0, 5$ with $opcode = 8$, $rs = 0$, $rt = 1$, $\\text{imm} = 5$.\n  2. R-type: add $r2, r1, r1$ with $opcode = 0$, $rs = 1$, $rt = 1$, $rd = 2$, $shamt = 0$, $funct = 32$.\n  Expected behavior: Both interpreters produce the same final $r1 = 5$.\n\n- Test case $2$ (negative immediate, arithmetic error with missing sign extension):\n  1. I-type: addi $r1, r0, -1$ with $opcode = 8$, $rs = 0$, $rt = 1$, $\\text{imm}$ encoded as $0xFFFF$ (the two's complement of $-1$ in $16$ bits).\n  Expected behavior: Correct interpreter yields $r1 = -1$; buggy interpreter yields $r1 = 65535$.\n\n- Test case $3$ (control flow with negative branch offset, loop termination):\n  Program with indices $0$ to $4$:\n  0. I-type: addi $r1, r0, 3$.\n  1. I-type: addi $r1, r1, -1$.\n  2. I-type: beq $r1, r0, \\text{Lend}$ where $\\text{Lend}$ is instruction index $4$, so the branch immediate is $+1$ (since $4 - (2+1) = 1$).\n  3. I-type: beq $r0, r0, \\text{Lloop}$ where $\\text{Lloop}$ is instruction index $1$, so the branch immediate is $-3$ (since $1 - (3+1) = -3$), always taken unless the previous branch to $\\text{Lend}$ was taken.\n  4. R-type: add $r2, r1, r0$ (copy $r1$ to $r2$).\n  Expected behavior: Correct interpreter decrements $r1$ until zero and reaches $\\text{Lend}$; final $r1 = 0$. Buggy interpreter misinterprets the negative offset as a large positive, jumps out of bounds early, and leaves $r1$ incorrect and nonzero.\n\n- Test case $4$ (J-type jump unaffected by sign extension):\n  Program with indices $0$ to $3$:\n  0. I-type: addi $r1, r0, 1$.\n  1. J-type: j to instruction index $3$.\n  2. I-type: addi $r1, r1, 5$ (this instruction is skipped).\n  3. R-type: add $r2, r1, r0$.\n  Expected behavior: Both interpreters produce final $r1 = 1$.\n\nFinal output specification:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain the final value of $r1$ for each test case, first using the buggy interpreter, then using the correct interpreter, in order of the test cases described above. That is, the output format is\n$$[\\text{buggy}_1,\\text{correct}_1,\\text{buggy}_2,\\text{correct}_2,\\text{buggy}_3,\\text{correct}_3,\\text{buggy}_4,\\text{correct}_4].$$\nAll results are integers; no physical units or angles are involved.\n\nNote: All decoding and execution must follow the ISA definitions above. Do not use shortcut formulas beyond the fundamental definitions of two's complement, bit masking, and PC update rules. Ensure scientific realism and consistency in the execution semantics.",
            "solution": "We begin with the two's complement representation and sign extension principle. A signed $n$-bit two's complement integer uses the most significant bit (MSB) as the sign bit. For a $16$-bit immediate $\\text{imm}$, the sign bit is bit $15$. To sign-extend to $32$ bits, if bit $15$ is $1$, we fill the upper $16$ bits with ones; if bit $15$ is $0$, we fill them with zeros. Formally, if $\\text{imm}$ denotes the $16$-bit field interpreted as an unsigned value,\n$$\n\\text{sign\\_extend}_{16\\rightarrow 32}(\\text{imm}) = \n\\begin{cases}\n\\text{imm} & \\text{if } (\\text{imm} \\ \\&amp; \\ 0x8000) = 0,\\\\\n\\text{imm} \\ \\vert \\ 0xFFFF0000 & \\text{otherwise}.\n\\end{cases}\n$$\nThis ensures that a negative $16$-bit value (for example, $0xFFFF$ which represents $-1$ in $16$-bit two's complement) becomes $0xFFFFFFFF$ in $32$ bits, which represents $-1$ in $32$-bit two's complement. The buggy interpreter, by contrast, uses\n$$\n\\text{zero\\_extend}_{16\\rightarrow 32}(\\text{imm}) = \\text{imm} \\ \\&amp; \\ 0x0000FFFF,\n$$\nwhich wrongly interprets negative $16$-bit immediates as large positive $32$-bit values.\n\nInstruction decoding is defined by the formats:\n- For a $32$-bit word $w$, the opcode is $((w \\gg 26) \\ \\&amp; \\ 0x3F)$. For R-type, where opcode $=0$, we extract $rs = ((w \\gg 21) \\ \\&amp; \\ 0x1F)$, $rt = ((w \\gg 16) \\ \\&amp; \\ 0x1F)$, $rd = ((w \\gg 11) \\ \\&amp; \\ 0x1F)$, $shamt = ((w \\gg 6) \\ \\&amp; \\ 0x1F)$, and $funct = (w \\ \\&amp; \\ 0x3F)$. For I-type, we extract $rs$, $rt$, and $\\text{imm} = (w \\ \\&amp; \\ 0xFFFF)$. For J-type, we extract the target as $(w \\ \\&amp; \\ 0x03FFFFFF)$.\n- The Program Counter (PC) starts at $0$ bytes. For sequential execution, $\\mathrm{PC} \\leftarrow \\mathrm{PC} + 4$. For branch if equal (BEQ) with opcode $4$, when $rs = rt$ the new PC is \n$$\n\\mathrm{PC} \\leftarrow \\mathrm{PC} + 4 + (\\text{sign-extended immediate} \\times 4),\n$$\nwhere the multiplication by $4$ accounts for byte addressing (the immediate encodes an offset in instruction words). For jump (J) with opcode $2$, the new PC is \n$$\n\\mathrm{PC} \\leftarrow (\\mathrm{PC} \\ \\&amp; \\ 0xF0000000) \\ \\vert \\ (\\text{target} \\ll 2).\n$$\n\nWe implement two interpreters:\n- Correct interpreter: uses $\\text{sign\\_extend}_{16\\rightarrow 32}$ for I-type immediate arithmetic and branch offsets.\n- Buggy interpreter: uses $\\text{zero\\_extend}_{16\\rightarrow 32}$ for I-type immediate arithmetic and branch offsets.\n\nWe now specify encoding for the test suite using helper functions consistent with the ISA:\n- R-type encode: \n$$\n\\text{encode\\_R}(rs, rt, rd, shamt, funct) = (0 \\ll 26) \\ \\vert \\ (rs \\ll 21) \\ \\vert \\ (rt \\ll 16) \\ \\vert \\ (rd \\ll 11) \\ \\vert \\ (shamt \\ll 6) \\ \\vert \\ funct.\n$$\n- I-type encode: \n$$\n\\text{encode\\_I}(opcode, rs, rt, \\text{imm}) = (opcode \\ll 26) \\ \\vert \\ (rs \\ll 21) \\ \\vert \\ (rt \\ll 16) \\ \\vert \\ (\\text{imm} \\ \\&amp; \\ 0xFFFF).\n$$\n- J-type encode: \n$$\n\\text{encode\\_J}(opcode, \\text{target}) = (opcode \\ll 26) \\ \\vert \\ (\\text{target} \\ \\&amp; \\ 0x03FFFFFF).\n$$\nWhen we specify jump to instruction index $k$, we use $\\text{target} = k$, which sets $\\mathrm{PC}$ to $4k$ since the jump hardware performs a left shift by $2$ bits.\n\nExpected outcomes reasoning:\n- Test case $1$: addi $r1, r0, 5$ followed by add $r2, r1, r1$. Immediate $5$ has bit $15 = 0$, so sign extension equals zero extension; both interpreters compute $r1 = 5$ at the end.\n- Test case $2$: addi $r1, r0, -1$. The $16$-bit encoding is $0xFFFF$. Correct interpreter sign-extends to $0xFFFFFFFF$ ($-1$), yielding $r1 = -1$. Buggy interpreter zero-extends to $0x0000FFFF$ ($65535$), yielding $r1 = 65535$.\n- Test case $3$: The loop:\n  - Index $0$: $r1 \\leftarrow 3$.\n  - Index $1$: $r1 \\leftarrow r1 + (-1)$; correct: $r1$ decrements, buggy: adds $65535$.\n  - Index $2$: beq $r1, r0, \\text{Lend}$ with immediate $+1$; correct: only taken when $r1 = 0$; buggy: condition likely false on first iteration.\n  - Index $3$: beq $r0, r0, \\text{Lloop}$ with immediate $-3$; correct: always taken back to index $1$ (negative offset handled properly). Buggy: immediate treated as $65533$, so the branch jumps far forward out of bounds, halting prematurely with an incorrect large $r1$ value.\n  - Index $4$: Lend copies $r1$ to $r2$; however final reporting uses $r1$, which is $0$ in the correct run and large in the buggy run.\n- Test case $4$: addi $r1, r0, 1$, then jump to index $3$ to skip the addi $+5$ at index $2$, then R-type add to move $r1$ into $r2$. J-type does not involve sign extension; both interpreters agree: final $r1 = 1$.\n\nThus, the aggregated output is the list of final $r1$ values: \n$$[\\text{buggy}_1,\\text{correct}_1,\\text{buggy}_2,\\text{correct}_2,\\text{buggy}_3,\\text{correct}_3,\\text{buggy}_4,\\text{correct}_4],$$\nwhich, by the above reasoning, will contain integers showing equality where the bug is not observable (tests $1$ and $4$) and differences where sign extension matters (tests $2$ and $3$).\n\nThe implementation follows these principles, decodes fields via bit masks and shifts, applies correct or buggy immediate handling as specified, and halts on out-of-range $\\mathrm{PC}$ or a safety step bound to ensure termination.",
            "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n// #include <complex.h>\n// #include <threads.h>\n// #include <stdatomic.h>\n\n// Minimal opcodes and funct codes for our subset\nenum {\n    OPCODE_RTYPE = 0x00,\n    OPCODE_ADDI  = 0x08,\n    OPCODE_BEQ   = 0x04,\n    OPCODE_J     = 0x02\n};\n\nenum {\n    FUNCT_ADD = 0x20\n};\n\n// Helper to encode instructions (R/I/J formats)\nstatic unsigned int encode_R(unsigned int rs, unsigned int rt, unsigned int rd, unsigned int shamt, unsigned int funct) {\n    return (OPCODE_RTYPE << 26)\n         | ((rs & 0x1Fu) << 21)\n         | ((rt & 0x1Fu) << 16)\n         | ((rd & 0x1Fu) << 11)\n         | ((shamt & 0x1Fu) << 6)\n         | (funct & 0x3Fu);\n}\n\nstatic unsigned int encode_I(unsigned int opcode, unsigned int rs, unsigned int rt, int imm) {\n    unsigned int uimm = (unsigned int)imm & 0xFFFFu;\n    return (opcode << 26)\n         | ((rs & 0x1Fu) << 21)\n         | ((rt & 0x1Fu) << 16)\n         | (uimm & 0xFFFFu);\n}\n\nstatic unsigned int encode_J(unsigned int opcode, unsigned int target) {\n    return (opcode << 26) | (target & 0x03FFFFFFu);\n}\n\n// Sign-extend a 16-bit immediate to 32-bit int\nstatic int sign_extend16(unsigned int imm16) {\n    if (imm16 & 0x8000u) {\n        return (int)(imm16 | 0xFFFF0000u);\n    } else {\n        return (int)(imm16 & 0x0000FFFFu);\n    }\n}\n\n// Zero-extend a 16-bit immediate to 32-bit int (buggy behavior)\nstatic int zero_extend16(unsigned int imm16) {\n    return (int)(imm16 & 0x0000FFFFu);\n}\n\n// Run the interpreter on a program; bug_flag=1 omits sign extension; bug_flag=0 is correct\nstatic int run_interpreter(const unsigned int *prog, int prog_len, int bug_flag) {\n    int regs[32];\n    for (int i = 0; i < 32; ++i) regs[i] = 0;\n\n    unsigned int pc = 0;\n    int steps = 0;\n    const int max_steps = 100000; // generous to avoid accidental infinite loops\n\n    while ((pc >> 2) < (unsigned int)prog_len && steps < max_steps) {\n        unsigned int inst = prog[pc >> 2];\n        unsigned int opcode = (inst >> 26) & 0x3Fu;\n\n        if (opcode == OPCODE_RTYPE) {\n            unsigned int rs = (inst >> 21) & 0x1Fu;\n            unsigned int rt = (inst >> 16) & 0x1Fu;\n            unsigned int rd = (inst >> 11) & 0x1Fu;\n            unsigned int shamt = (inst >> 6) & 0x1Fu;\n            unsigned int funct = inst & 0x3Fu;\n            (void)shamt; // not used in this subset\n\n            if (funct == FUNCT_ADD) {\n                // Signed add (wrap-around same as C's int addition)\n                regs[rd] = regs[rs] + regs[rt];\n                pc += 4;\n            } else {\n                // Unknown funct: advance to avoid hang\n                pc += 4;\n            }\n        } else if (opcode == OPCODE_ADDI) {\n            unsigned int rs = (inst >> 21) & 0x1Fu;\n            unsigned int rt = (inst >> 16) & 0x1Fu;\n            unsigned int imm16 = inst & 0xFFFFu;\n            int imm32 = bug_flag ? zero_extend16(imm16) : sign_extend16(imm16);\n            regs[rt] = regs[rs] + imm32;\n            pc += 4;\n        } else if (opcode == OPCODE_BEQ) {\n            unsigned int rs = (inst >> 21) & 0x1Fu;\n            unsigned int rt = (inst >> 16) & 0x1Fu;\n            unsigned int imm16 = inst & 0xFFFFu;\n            int offset = bug_flag ? zero_extend16(imm16) : sign_extend16(imm16);\n            if (regs[rs] == regs[rt]) {\n                // PC <- PC + 4 + offset*4 ; use multiplication to avoid undefined shift on negative\n                int delta = offset * 4;\n                pc = pc + 4 + (unsigned int)delta;\n            } else {\n                pc += 4;\n            }\n        } else if (opcode == OPCODE_J) {\n            unsigned int target = inst & 0x03FFFFFFu;\n            pc = (pc & 0xF0000000u) | (target << 2);\n        } else {\n            // Unknown opcode: advance to avoid hang\n            pc += 4;\n        }\n\n        ++steps;\n    }\n\n    // Return final value of r1 as specified\n    return regs[1];\n}\n\nint main(void) {\n    // Define Test Case 1\n    unsigned int prog1[] = {\n        encode_I(OPCODE_ADDI, 0, 1, 5),               // addi r1, r0, 5\n        encode_R(1, 1, 2, 0, FUNCT_ADD)               // add r2, r1, r1\n    };\n    int len1 = (int)(sizeof(prog1) / sizeof(prog1[0]));\n\n    // Define Test Case 2\n    unsigned int prog2[] = {\n        encode_I(OPCODE_ADDI, 0, 1, -1)               // addi r1, r0, -1 (0xFFFF)\n    };\n    int len2 = (int)(sizeof(prog2) / sizeof(prog2[0]));\n\n    // Define Test Case 3\n    // Indices: 0..4\n    unsigned int prog3[] = {\n        encode_I(OPCODE_ADDI, 0, 1, 3),               // 0: addi r1, r0, 3\n        encode_I(OPCODE_ADDI, 1, 1, -1),              // 1: addi r1, r1, -1\n        encode_I(OPCODE_BEQ,  1, 0, 1),               // 2: beq r1, r0, Lend (index 4): offset = 4-(2+1)=1\n        encode_I(OPCODE_BEQ,  0, 0, -3),              // 3: beq r0, r0, Lloop (index 1): offset = 1-(3+1)=-3\n        encode_R(1, 0, 2, 0, FUNCT_ADD)               // 4: add r2, r1, r0\n    };\n    int len3 = (int)(sizeof(prog3) / sizeof(prog3[0]));\n\n    // Define Test Case 4\n    // Indices: 0..3\n    unsigned int prog4[] = {\n        encode_I(OPCODE_ADDI, 0, 1, 1),               // 0: addi r1, r0, 1\n        encode_J(OPCODE_J, 3),                        // 1: j to index 3\n        encode_I(OPCODE_ADDI, 1, 1, 5),               // 2: addi r1, r1, 5 (skipped)\n        encode_R(1, 0, 2, 0, FUNCT_ADD)               // 3: add r2, r1, r0\n    };\n    int len4 = (int)(sizeof(prog4) / sizeof(prog4[0]));\n\n    // Run buggy and correct interpreters for each test\n    int buggy1   = run_interpreter(prog1, len1, 1);\n    int correct1 = run_interpreter(prog1, len1, 0);\n\n    int buggy2   = run_interpreter(prog2, len2, 1);\n    int correct2 = run_interpreter(prog2, len2, 0);\n\n    int buggy3   = run_interpreter(prog3, len3, 1);\n    int correct3 = run_interpreter(prog3, len3, 0);\n\n    int buggy4   = run_interpreter(prog4, len4, 1);\n    int correct4 = run_interpreter(prog4, len4, 0);\n\n    // Print the results in the EXACT REQUIRED format before the final return statement\n    printf(\"[%d,%d,%d,%d,%d,%d,%d,%d]\\n\",\n           buggy1, correct1, buggy2, correct2, buggy3, correct3, buggy4, correct4);\n\n    return EXIT_SUCCESS;\n}\n```"
        },
        {
            "introduction": "Once we understand how instructions are supposed to be executed, we can explore what happens when things go wrong, such as with a bug in an assembler or compiler. This practice challenges you to diagnose the architectural consequences of incorrectly encoding an R-type instruction by swapping its two source register fields, $rs$ and $rt$. This thought experiment highlights the crucial difference between commutative operations like addition ($v_s + v_t = v_t + v_s$) and non-commutative ones like subtraction ($v_s - v_t \\neq v_t - v_s$). Analyzing this scenario  will deepen your appreciation for the strict relationship between an instruction's binary format and its precise arithmetic behavior, including the subtle rules of two’s complement overflow.",
            "id": "3649778",
            "problem": "A reduced MIPS-like Instruction Set Architecture (ISA) uses the classic R-type instruction format with fields of fixed widths: an opcode of $6$ bits (which is $0$ for all R-type instructions), followed by source register fields $rs$ and $rt$ of $5$ bits each, a destination register field $rd$ of $5$ bits, a shift amount of $5$ bits, and a function code of $6$ bits that selects the Arithmetic Logic Unit (ALU) operation. The semantics of R-type integer arithmetic are as follows, for two’s complement (base-$2$) signed integers of width $32$ bits:\n- add: write $R_d \\leftarrow R_s + R_t$ and raise a signed overflow exception if the exact mathematical sum is not representable in $32$-bit two’s complement; if an overflow exception is raised, the architectural write to $R_d$ does not occur.\n- sub: write $R_d \\leftarrow R_s - R_t$ and raise a signed overflow exception if the exact mathematical difference is not representable in $32$-bit two’s complement; if an overflow exception is raised, the architectural write to $R_d$ does not occur.\n\nSuppose an assembler bug encodes a programmer’s intended R-type instruction by swapping the $rs$ and $rt$ fields in the machine code. That is, if the programmer wrote an instruction using the source registers logically denoted $R_s$ and $R_t$, the hardware actually executes the same operation but with the two source register fields interchanged. Assume there are no memory side effects and no microarchitectural hazards that would distinguish the two source operands other than their values; only the architectural semantics and overflow behavior described above matter.\n\nUsing only the core definitions of the R-type format and signed two’s complement arithmetic, decide which of the following claims about the architectural effects are true. Select all that apply.\n\nA) For an add instruction, swapping $rs$ and $rt$ leaves both the value written to $R_d$ and the occurrence or non-occurrence of a signed overflow exception unchanged for all operand values.\n\nB) For a sub instruction, swapping $rs$ and $rt$ always preserves the occurrence or non-occurrence of a signed overflow exception for all operand values, even though the computed value (if written) may differ.\n\nC) If $R_s = R_t$, then swapping $rs$ and $rt$ is unobservable for both add and sub: the same value is written to $R_d$ and the same overflow behavior occurs.\n\nD) For a sub instruction, whenever neither the intended execution nor the swapped-$rs$/$rt$ execution raises an overflow exception, the value written to $R_d$ by the swapped-$rs$/$rt$ execution equals the two’s complement negation of the value that would have been written by the intended execution.\n\nE) There exist operand values $R_s$ and $R_t$ for sub such that the intended execution raises a signed overflow exception while the swapped-$rs$/$rt$ execution does not, and there also exist operand values for which the swapped-$rs$/$rt$ execution raises an exception while the intended execution does not.",
            "solution": "The user wants me to validate and solve a problem concerning the architectural effects of swapping source register fields in a MIPS-like R-type instruction.\n\n### Step 1: Validation of the Problem Statement\n\nI will first extract the given information and then validate the problem statement for correctness and solvability.\n\n#### Extraction of Givens\n*   **ISA:** A reduced MIPS-like Instruction Set Architecture.\n*   **Integer Representation:** $32$-bit two's complement signed integers. The range of representable integers is from $T_{min} = -2^{31}$ to $T_{max} = 2^{31}-1$.\n*   **Instruction Format:** R-type with fixed-width fields: opcode ($6$ bits), $rs$ ($5$ bits), $rt$ ($5$ bits), $rd$ ($5$ bits), shamt ($5$ bits), funct ($6$ bits). Opcode for all R-type instructions is $0$.\n*   **Instruction Semantics (`add`):** For an instruction `add rd, rs, rt`, the hardware computes $R_s + R_t$.\n    *   If the exact mathematical sum is representable in a $32$-bit two's complement integer, the result is written to register $R_d$.\n    *   If the sum is not representable (signed overflow), a signed overflow exception is raised, and the write to $R_d$ does not occur.\n*   **Instruction Semantics (`sub`):** For an instruction `sub rd, rs, rt`, the hardware computes $R_s - R_t$.\n    *   If the exact mathematical difference is representable, the result is written to register $R_d$.\n    *   If the difference is not representable (signed overflow), a signed overflow exception is raised, and the write to $R_d$ does not occur.\n*   **The Bug:** An assembler bug swaps the $rs$ and $rt$ fields. If a programmer intends to execute `op rd, rs, rt`, the machine actually executes the operation as if it were `op rd, rt, rs`.\n*   **Assumptions:** No memory side effects or microarchitectural hazards distinguish the two source operands other than their values.\n\n#### Validation\n1.  **Scientific Grounding:** The problem is firmly grounded in the fundamental principles of computer organization and architecture. The MIPS R-type format, two's complement arithmetic, and the concepts of signed overflow are all standard topics in this field. The premises are factually sound.\n2.  **Well-Posed:** The problem is well-posed. The initial state (programmer's intent), the transformation (assembler bug), and the system's behavior (CPU semantics) are all clearly defined. The questions asked are specific and have unique, derivable answers based on the provided definitions.\n3.  **Objectivity:** The problem statement is expressed in precise, objective, technical language, free from ambiguity or subjective claims.\n4.  **Completeness and Consistency:** The problem is self-contained. It provides all necessary information, such as the data width ($32$ bits), number system (two's complement), and the exact semantics of the `add` and `sub` operations, including overflow behavior. There are no contradictions.\n5.  **Plausibility:** An assembler bug is a realistic scenario in software development. The described behavior is a direct consequence of the specified hardware semantics.\n\n#### Verdict\nThe problem statement is **valid**. It is a well-defined problem in computer arithmetic and architecture that can be solved through logical deduction from the given principles. I will now proceed with the solution.\n\n### Step 2: Derivation of Solution and Option Analysis\n\nLet $v_s$ be the value in the register specified by the $rs$ field and $v_t$ be the value in the register specified by the $rt$ field. Both $v_s$ and $v_t$ are $32$-bit two's complement integers.\n\nThe intended operation for `add` is to compute $v_s + v_t$. The swapped operation computes $v_t + v_s$.\nThe intended operation for `sub` is to compute $v_s - v_t$. The swapped operation computes $v_t - v_s$.\n\nA signed overflow occurs if the mathematical result of the operation falls outside the representable range $[-2^{31}, 2^{31}-1]$.\n\n#### Analysis of Option A\n\n**A) For an add instruction, swapping $rs$ and $rt$ leaves both the value written to $R_d$ and the occurrence or non-occurrence of a signed overflow exception unchanged for all operand values.**\n\n1.  **Value Written:** The `add` operation computes the sum of the source operands. Integer addition is commutative, meaning for any two integers $v_s$ and $v_t$, the mathematical sum $v_s + v_t$ is identical to $v_t + v_s$. Therefore, if the operation does not overflow, the same value will be computed and written to $R_d$ in both the intended and the swapped execution.\n2.  **Overflow Behavior:** A signed overflow occurs if the mathematical sum is outside the representable range. Since $v_s + v_t = v_t + v_s$, if one sum is outside the range, the other must also be outside the range. Conversely, if one is within the range, the other must also be. For example, an overflow for addition occurs if and only if the two operands have the same sign and the result has the opposite sign. This condition is symmetric with respect to the operands $v_s$ and $v_t$. Thus, an overflow will occur for the intended operation if and only if it occurs for the swapped operation.\n\nConclusion: Swapping the source registers for an `add` instruction has no observable architectural effect. The claim is true.\n\n**Verdict on A: Correct**\n\n#### Analysis of Option B\n\n**B) For a sub instruction, swapping $rs$ and $rt$ always preserves the occurrence or non-occurrence of a signed overflow exception for all operand values, even though the computed value (if written) may differ.**\n\nThis claim states that `overflow(v_s - v_t)` occurs if and only if `overflow(v_t - v_s)` occurs, for all $v_s, v_t$. Let's test this with a counterexample.\n\nLet $N=32$. The range of representable signed integers is $[-2^{31}, 2^{31}-1]$.\nLet $T_{max} = 2^{31}-1$ and $T_{min} = -2^{31}$.\n\nConsider the operand values $v_s = T_{max}$ and $v_t = -1$.\n*   **Intended execution:** Compute $v_s - v_t = (2^{31}-1) - (-1) = 2^{31}-1+1 = 2^{31}$. This value is greater than $T_{max}$, so it is not representable. A signed overflow exception is raised.\n*   **Swapped execution:** Compute $v_t - v_s = (-1) - (2^{31}-1) = -1 - 2^{31} + 1 = -2^{31}$. This value is exactly $T_{min}$, which is representable. No overflow exception is raised.\n\nIn this case, the intended execution overflows while the swapped execution does not. This is a direct counterexample to the claim that overflow behavior is always preserved.\n\n**Verdict on B: Incorrect**\n\n#### Analysis of Option C\n\n**C) If $R_s = R_t$, then swapping $rs$ and $rt$ is unobservable for both add and sub: the same value is written to $R_d$ and the same overflow behavior occurs.**\n\nLet the value in both registers be $v$, so $v_s = v_t = v$.\n\n1.  **`add` instruction:**\n    *   Intended execution: compute $v+v = 2v$.\n    *   Swapped execution: compute $v+v = 2v$.\n    The operations are identical. Thus, the computed value and the overflow behavior must be identical.\n\n2.  **`sub` instruction:**\n    *   Intended execution: compute $v-v = 0$.\n    *   Swapped execution: compute $v-v = 0$.\n    The result is always $0$, which is always representable in two's complement. No overflow can ever occur in either case. The value written to $R_d$ is always $0$. The operations are identical.\n\nSince for both `add` and `sub`, the intended and swapped executions are identical when $v_s = v_t$, the architectural effects are indistinguishable. The claim is true.\n\n**Verdict on C: Correct**\n\n#### Analysis of Option D\n\n**D) For a sub instruction, whenever neither the intended execution nor the swapped-$rs$/$rt$ execution raises an overflow exception, the value written to $R_d$ by the swapped-$rs$/$rt$ execution equals the two’s complement negation of the value that would have been written by the intended execution.**\n\nLet $Z_1$ be the value written by the intended execution, and $Z_2$ be the value written by the swapped execution. The premise is that both $v_s - v_t$ and $v_t - v_s$ are representable.\n*   $Z_1 = v_s - v_t$\n*   $Z_2 = v_t - v_s$\n\nMathematically, it is clear that $Z_2 = -(v_s - v_t) = -Z_1$. The question is whether this holds true for two's complement representation and negation.\n\nThe two's complement negation of an integer $X$ is defined as the value $Y$ such that $X+Y=0$. This is typically computed as bitwise NOT of $X$, plus $1$ (i.e., $\\sim X + 1$). This operation correctly yields $-X$ for all representable integers $X$ except for the most negative number, $T_{min} = -2^{31}$. The negation of $T_{min}$ is $-(-2^{31}) = 2^{31}$, which is not representable. In practice, the two's complement negation operation on $T_{min}$ yields $T_{min}$ itself, and on many architectures, this also signals an overflow.\n\nLet's examine if $Z_1$ could be $T_{min}$ under the premise of the option.\nSuppose the intended execution produces $Z_1 = v_s - v_t = T_{min}$. This operation itself does not overflow.\nNow consider the swapped execution, which would compute $Z_2 = v_t - v_s = -(v_s-v_t) = -T_{min} = 2^{31}$.\nThe value $2^{31}$ is not representable, so the swapped execution $v_t - v_s$ would cause an overflow.\n\nHowever, the premise of the option is \"whenever **neither** the intended execution nor the swapped-$rs$/$rt$ execution raises an overflow exception\". This explicitly excludes the case where $Z_1 = T_{min}$, because if $Z_1 = T_{min}$, then $Z_2$ would overflow. Therefore, under the given premise, $Z_1$ cannot be $T_{min}$.\n\nFor any $Z_1 \\neq T_{min}$ that is representable, its negation $-Z_1$ is also representable. Since we have established a mathematical identity $Z_2 = -Z_1$, and both $Z_1$ and $Z_2$ are representable, the value computed in the swapped case is indeed the two's complement negation of the value from the intended case.\n\n**Verdict on D: Correct**\n\n#### Analysis of Option E\n\n**E) There exist operand values $R_s$ and $R_t$ for sub such that the intended execution raises a signed overflow exception while the swapped-$rs$/$rt$ execution does not, and there also exist operand values for which the swapped-$rs$/$rt$ execution raises an exception while the intended execution does not.**\n\nThis claim consists of two parts.\n1.  **Part 1:** Find $(v_s, v_t)$ such that `overflow(v_s - v_t)` is true and `overflow(v_t - v_s)` is false.\n    The counterexample used to disprove option B serves perfectly here. Let $v_s = T_{max} = 2^{31}-1$ and $v_t = -1$.\n    *   Intended: $v_s - v_t = (2^{31}-1) - (-1) = 2^{31}$. This **overflows**.\n    *   Swapped: $v_t - v_s = (-1) - (2^{31}-1) = -2^{31}$. This is $T_{min}$ and **does not overflow**.\n    So, Part 1 is true.\n\n2.  **Part 2:** Find $(v'_s, v'_t)$ such that `overflow(v'_s - v'_t)` is false and `overflow(v'_t - v'_s)` is true.\n    We can simply swap the roles of $v_s$ and $v_t$ from Part 1. Let $v'_s = -1$ and $v'_t = T_{max} = 2^{31}-1$.\n    *   Intended: $v'_s - v'_t = (-1) - (2^{31}-1) = -2^{31}$. This is $T_{min}$ and **does not overflow**.\n    *   Swapped: $v'_t - v'_s = (2^{31}-1) - (-1) = 2^{31}$. This **overflows**.\n    So, Part 2 is also true.\n\nSince both parts of the claim are true, the entire statement is true.\n\n**Verdict on E: Correct**\n\n### Summary of Correct Options\n\nMy analysis shows that options A, C, D, and E are correct statements.",
            "answer": "$$\\boxed{ACDE}$$"
        },
        {
            "introduction": "In real-world computing, ensuring that data and instructions are transmitted and stored without corruption is a fundamental challenge. This final practice integrates your knowledge of instruction decoding with practical error detection and integrity verification. You will act as a system debugger, analyzing a sequence of transmitted machine instructions—one of which has been corrupted by a single-bit error—and using a parity bit to identify the faulty instruction. After correcting the error by re-encoding the intended instruction, you will compute a checksum over the entire sequence to verify its integrity, bringing together your knowledge of R, I, and J formats with the foundational concepts of building reliable systems .",
            "id": "3649814",
            "problem": "A Reduced Instruction Set Computer (RISC) pipeline receives a three-instruction sequence intended to be encoded in the standard $32$-bit MIPS instruction formats: register-type (R-type), immediate-type (I-type), and jump-type (J-type). The canonical MIPS32 encodings are defined as follows: R-type uses fields $\\text{opcode}[31{:}26]$, $rs[25{:}21]$, $rt[20{:}16]$, $rd[15{:}11]$, $\\text{shamt}[10{:}6]$, $\\text{funct}[5{:}0]$; I-type uses $\\text{opcode}[31{:}26]$, $rs[25{:}21]$, $rt[20{:}16]$, $\\text{imm}[15{:}0]$; J-type uses $\\text{opcode}[31{:}26]$, $\\text{target}[25{:}0]$. The parity mechanism appends, for each $32$-bit word, a single even-parity bit (value chosen so the total number of $1$ bits across the $32$ data bits plus the parity bit is even). A $16$-bit one’s complement checksum over a sequence of $32$-bit words is defined by partitioning each $32$-bit word into its upper and lower $16$-bit halves (upper half first), summing all halves using one’s complement addition (end-around carry), and then taking the one’s complement of the final $16$-bit sum.\n\nThe intended assembly sequence is:\n$1)$ R-type: $\\text{add } t3, t1, t2$,\n$2)$ I-type: $\\text{addi } t0, t0, -3$,\n$3)$ J-type: $\\text{j } \\text{target}$ with encoded target field equal to $0x0123456$ (note: the actual jump address at runtime depends on the Program Counter (PC), but only the encoded target field is relevant here).\n\nAt the receiver, the following three $32$-bit hexadecimal words are observed, each accompanied by its transmitted even-parity bit computed at the sender over the original $32$ data bits:\n$W_1 = 0x012A5820$ with parity $p_1 = 0$,\n$W_2 = 0xA108FFFD$ with parity $p_2 = 0$,\n$W_3 = 0x08123456$ with parity $p_3 = 0$.\n\nExactly one of the three words has suffered a single-bit flip in transit.\n\nTasks:\n$1)$ Decode each received word into its format (R/I/J) and reconstruct its fields. For R-type, identify $rs$, $rt$, and $rd$. For I-type, identify $rs$, $rt$, and the $16$-bit immediate. For J-type, identify the $26$-bit target field.\n$2)$ Using the parity bits and the definition of even parity, determine which one word contains a single-bit error.\n$3)$ Using the stated intended assembly for that word, reconstruct the correct $32$-bit encoding and identify the flipped bit position as a zero-based index where bit $0$ is the least significant bit.\n$4)$ Compute the $16$-bit one’s complement checksum over the corrected three-word sequence, treating each $32$-bit word as two $16$-bit halves in big-endian order (upper half first). Express the checksum as an unsigned decimal integer. Provide only this checksum as your final answer. No rounding is required, and no units are to be included.",
            "solution": "The problem statement is evaluated to be valid. It is scientifically grounded in the principles of computer architecture, specifically MIPS instruction set encoding, parity-based error detection, and one's complement checksum calculation. The problem is well-posed, providing all necessary data and constraints for a unique and verifiable solution.\n\nThe solution proceeds in four stages:\n1.  Determination of the correct $32$-bit machine code for each intended instruction.\n2.  Identification of the corrupted word by applying the principles of even-parity checking to the received data.\n3.  Correction of the identified word and localization of the single-bit error.\n4.  Calculation of the $16$-bit one's complement checksum over the corrected three-word sequence.\n\nFirst, we determine the correct $32$-bit encoding for each of the three specified assembly instructions. Standard MIPS32 register assignments and instruction formats are used. The relevant registers are: `$t0 = 8$, `$t1 = 9$, `$t2 = 10$, and `$t3 = 11$.\n\nInstruction 1: R-type, $\\text{add } t3, t1, t2$\nThis instruction uses the R-type format. The opcode for all R-type instructions is $0$, and the specific function is identified by the `funct` field. For the `add` operation, the `funct` code is $0x20$ (which is $32$ in decimal, or $100000_2$). The registers are mapped as $rs \\leftarrow t1$ ($\\$9$), $rt \\leftarrow t2$ ($\\$10$), and $rd \\leftarrow t3$ ($\\$11$). The shift amount (`shamt`) is $0$ for non-shift operations.\n- $\\text{opcode}[31:26] = 000000_2$\n- $rs[25:21] = 9 = 01001_2$\n- $rt[20:16] = 10 = 01010_2$\n- $rd[15:11] = 11 = 01011_2$\n- $\\text{shamt}[10:6] = 0 = 00000_2$\n- $\\text{funct}[5:0] = 0x20 = 100000_2$\nAssembling these fields yields the binary word:\n$000000\\ 01001\\ 01010\\ 01011\\ 00000\\ 100000_2$\nGrouping into $4$-bit nibbles for hexadecimal conversion:\n$0000\\ 0001\\ 0010\\ 1010\\ 0101\\ 1000\\ 0010\\ 0000_2 = 0x012A5820$.\nLet this correct word be $C_1$. So, $C_1 = 0x012A5820$.\n\nInstruction 2: I-type, $\\text{addi } t0, t0, -3$\nThis instruction adds an immediate value to a register. The opcode for `addi` is $0x8$ ($001000_2$). The registers are $rs \\leftarrow t0$ ($\\$8$) and $rt \\leftarrow t0$ ($\\$8$). The immediate value is $-3$, which in $16$-bit two's complement representation is $0xFFFD$.\n- $\\text{opcode}[31:26] = 0x8 = 001000_2$\n- $rs[25:21] = 8 = 01000_2$\n- $rt[20:16] = 8 = 01000_2$\n- $\\text{imm}[15:0] = -3 = 0xFFFD = 1111111111111101_2$\nAssembling these fields:\n$001000\\ 01000\\ 01000\\ 1111111111111101_2$\nIn hexadecimal:\n$0010\\ 0001\\ 0000\\ 1000\\ 1111\\ 1111\\ 1111\\ 1101_2 = 0x2108FFFD$.\nLet this correct word be $C_2$. So, $C_2 = 0x2108FFFD$.\n\nInstruction 3: J-type, $\\text{j } \\text{target}$ with encoded target field $0x0123456$\nThis is an unconditional jump instruction. The opcode for `j` is $0x2$ ($000010_2$). The remaining $26$ bits form the target address field.\n- $\\text{opcode}[31:26] = 0x2 = 000010_2$\n- $\\text{target}[25:0] = 0x0123456 = 00000100100011010001010110_2$\nAssembling these fields:\n$000010\\ 00000100100011010001010110_2$\nIn hexadecimal:\n$0000\\ 1000\\ 0001\\ 0010\\ 0011\\ 0100\\ 0101\\ 0110_2 = 0x08123456$.\nLet this correct word be $C_3$. So, $C_3 = 0x08123456$.\n\nNext, we use the property of even parity to identify the word with the single-bit error. For even parity, the sum of the number of $1$-bits in the data word (its population count, or popcount) and the parity bit must be an even number. A single-bit flip in the data word will change its popcount from even to odd or vice-versa, causing the parity check to fail.\nThe received words and their parity bits are:\n$W_1 = 0x012A5820$ with $p_1 = 0$\n$W_2 = 0xA108FFFD$ with $p_2 = 0$\n$W_3 = 0x08123456$ with $p_3 = 0$\n\nLet's calculate the popcount for each received word:\n- For $W_1 = 0x012A5820 = 00000001001010100101100000100000_2$:\nThe number of $1$s is $1+1+1+1+1+1+1+1 = 8$.\n$\\text{popcount}(W_1) = 8$. This is an even number.\nParity check: $\\text{popcount}(W_1) + p_1 = 8 + 0 = 8$ (even). The parity check passes. This indicates $W_1$ is likely error-free. Note that $W_1 = C_1$.\n\n- For $W_2 = 0xA108FFFD = 10100001000010001111111111111101_2$:\nThe number of $1$s is $(1+1)+(1)+(1)+(4+4+4)+(1+1+1) = 19$.\n$\\text{popcount}(W_2) = 19$. This is an odd number.\nParity check: $\\text{popcount}(W_2) + p_2 = 19 + 0 = 19$ (odd). The parity check fails. This indicates $W_2$ is the word with the error.\n\n- For $W_3 = 0x08123456 = 00001000000100100011010001010110_2$:\nThe number of $1$s is $1+1+1+1+1+1+1+1+1+1 = 10$.\n$\\text{popcount}(W_3) = 10$. This is an even number.\nParity check: $\\text{popcount}(W_3) + p_3 = 10 + 0 = 10$ (even). The parity check passes. This indicates $W_3$ is likely error-free. Note that $W_3 = C_3$.\n\nThe analysis confirms that $W_2$ is the corrupted word. To identify the flipped bit, we compare the received word $W_2$ with the correct encoding $C_2$:\n$W_2 = 0xA108FFFD = 10100001000010001111111111111101_2$\n$C_2 = 0x2108FFFD = 00100001000010001111111111111101_2$\nThe difference is in the most significant nibble: $0xA$ ($1010_2$) versus $0x2$ ($0010_2$). The bit that differs is the most significant bit (MSB) of the $32$-bit word, which is bit position $31$ (using zero-based indexing). This bit was flipped from $0$ to $1$ during transmission. Thus we have completed the first three tasks. The corrected sequence of words is $(C_1, C_2, C_3)$.\n\nFinally, we compute the $16$-bit one's complement checksum over the corrected three-word sequence:\n$C_1 = 0x012A5820$\n$C_2 = 0x2108FFFD$\n$C_3 = 0x08123456$\n\nEach $32$-bit word is split into two $16$-bit halves (upper, lower). We sum these six $16$-bit values using one's complement addition, where any carry out of the MSB is added back to the least significant bit (LSB), a technique known as end-around carry.\nThe six $16$-bit halves are:\n$H_1 = 0x012A$\n$L_1 = 0x5820$\n$H_2 = 0x2108$\n$L_2 = 0xFFFD$\n$H_3 = 0x0812$\n$L_3 = 0x3456$\n\nLet's perform the summation:\nSum = $0x012A + 0x5820 + 0x2108 + 0xFFFD + 0x0812 + 0x3456$\n$0x012A + 0x5820 = 0x594A$\n$0x594A + 0x2108 = 0x7A52$\n$0x7A52 + 0xFFFD = 0x17A4F$. This sum has a carry-out bit. We add the carry back: $0x7A4F + 0x1 = 0x7A50$.\n$0x7A50 + 0x0812 = 0x8262$\n$0x8262 + 0x3456 = 0xB6B8$\n\nThe final $16$-bit sum is $S = 0xB6B8$.\nThe checksum is the one's complement of this sum, which is calculated as $0xFFFF - S$.\nChecksum = $0xFFFF - 0xB6B8 = 0x4947$.\n\nThe problem requires the answer as an unsigned decimal integer. We convert the hexadecimal checksum to decimal:\nChecksum = $4 \\times 16^3 + 9 \\times 16^2 + 4 \\times 16^1 + 7 \\times 16^0$\nChecksum = $4 \\times 4096 + 9 \\times 256 + 4 \\times 16 + 7 \\times 1$\nChecksum = $16384 + 2304 + 64 + 7$\nChecksum = $18759$.",
            "answer": "$$\n\\boxed{18759}\n$$"
        }
    ]
}