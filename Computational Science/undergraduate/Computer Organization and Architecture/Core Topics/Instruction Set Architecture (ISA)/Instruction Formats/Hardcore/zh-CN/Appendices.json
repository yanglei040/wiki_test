{
    "hands_on_practices": [
        {
            "introduction": "这个练习将带你进入一个接近真实世界的场景，在其中，数据在传输过程中可能会出错。你将不仅需要解码R型、I型和J型指令，还需要利用奇偶校验位来定位错误，并最终计算校验和来验证数据的完整性。这项综合性练习旨在锻炼你处理位级数据和理解指令集与错误控制机制如何协同工作的能力 。",
            "id": "3649814",
            "problem": "一个精简指令集计算机 (RISC) 流水线接收一个三指令序列，该序列旨在被编码为标准的32位 MIPS 指令格式：寄存器类型 (R型)、立即数类型 (I型) 和跳转类型 (J型)。经典的 MIPS32 编码定义如下：R型使用字段 $\\text{opcode}[31:26]$、$rs[25:21]$、$rt[20:16]$、$rd[15:11]$、$\\text{shamt}[10:6]$、$\\text{funct}[5:0]$；I型使用 $\\text{opcode}[31:26]$、$rs[25:21]$、$rt[20:16]$、$\\text{imm}[15:0]$；J型使用 $\\text{opcode}[31:26]$、$\\text{target}[25:0]$。奇偶校验机制为每个32位字附加一个偶校验位（其值的选择是为了使32个数据位和该校验位中 $1$ 的总数为偶数）。一个针对32位字序列的16位反码校验和的定义如下：将每个32位字划分为其高16位和低16位两半（高位在前），使用反码加法（循环进位）将所有半字相加，然后取最终16位和的反码。\n\n预期的汇编序列是：\n$1)$ R型：$\\text{add } t3, t1, t2$，\n$2)$ I型：$\\text{addi } t0, t0, -3$，\n$3)$ J型：$\\text{j } \\text{target}$，其编码的目标字段等于 $0x0123456$（注意：运行时的实际跳转地址取决于程序计数器 (PC)，但这里只关心编码的目标字段）。\n\n在接收端，观察到以下三个32位十六进制字，每个字都附有其由发送端根据原始32个数据位计算得出的偶校验位：\n$W_1 = 0x012A5820$，校验位 $p_1 = 0$，\n$W_2 = 0xA108FFFD$，校验位 $p_2 = 0$，\n$W_3 = 0x08123456$，校验位 $p_3 = 0$。\n\n在传输过程中，三个字中恰好有一个发生了一位翻转。\n\n任务：\n$1)$ 将每个接收到的字解码为其格式 (R/I/J) 并重构其字段。对于 R型，识别 $rs$、$rt$ 和 $rd$。对于 I型，识别 $rs$、$rt$ 和16位立即数。对于 J型，识别26位目标字段。\n$2)$ 使用校验位和偶校验的定义，确定哪一个字包含一位错误。\n$3)$ 使用该字对应的预期汇编指令，重构正确的32位编码，并将翻转的位的位置识别为一个从零开始的索引，其中位 $0$ 是最低有效位。\n$4)$ 计算修正后的三字序列的16位反码校验和，将每个32位字视为两个按大端序排列的16位半字（高位在前）。将校验和表示为一个无符号十进制整数。只提供该校验和作为您的最终答案。不需要四舍五入，也不需要包含单位。",
            "solution": "题目陈述经评估是有效的。它在科学上基于计算机体系结构的原理，特别是 MIPS 指令集编码、基于奇偶校验的错误检测和反码校验和计算。该问题提法明确，为一个唯一且可验证的解提供了所有必要的数据和约束。\n\n解答过程分四个阶段进行：\n1.  确定每条预期指令的正确32位机器码。\n2.  通过将偶校验原则应用于接收到的数据，识别出损坏的字。\n3.  修正已识别的字并定位单位错误。\n4.  计算修正后的三字序列的16位反码校验和。\n\n首先，我们确定三条指定汇编指令中每一条的正确32位编码。使用标准的 MIPS32 寄存器分配和指令格式。相关寄存器是：`$t0 = 8`、`$t1 = 9`、`$t2 = 10` 和 `$t3 = 11`。\n\n指令 1：R型，$\\text{add } t3, t1, t2$\n该指令使用 R型格式。所有 R型指令的操作码 (opcode) 均为 $0$，具体功能由 `funct` 字段标识。对于 `add` 操作，`funct` 代码是 $0x20$（十进制为 $32$，或 $100000_2$）。寄存器映射为 $rs \\leftarrow t1$ ($\\$9$)、$rt \\leftarrow t2$ ($\\$10$) 和 $rd \\leftarrow t3$ ($\\$11$)。对于非移位操作，移位量 (`shamt`) 为 $0$。\n- $\\text{opcode}[31:26] = 000000_2$\n- $rs[25:21] = 9 = 01001_2$\n- $rt[20:16] = 10 = 01010_2$\n- $rd[15:11] = 11 = 01011_2$\n- $\\text{shamt}[10:6] = 0 = 00000_2$\n- $\\text{funct}[5:0] = 0x20 = 100000_2$\n将这些字段组合起来，得到二进制字：\n$000000\\ 01001\\ 01010\\ 01011\\ 00000\\ 100000_2$\n分组为 $4$ 位半字节以进行十六进制转换：\n$0000\\ 0001\\ 0010\\ 1010\\ 0101\\ 1000\\ 0010\\ 0000_2 = 0x012A5820$。\n设这个正确的字为 $C_1$。因此，$C_1 = 0x012A5820$。\n\n指令 2：I型，$\\text{addi } t0, t0, -3$\n该指令将一个立即数加到一个寄存器上。`addi` 的操作码是 $0x8$ ($001000_2$)。寄存器为 $rs \\leftarrow t0$ ($\\$8$) 和 $rt \\leftarrow t0$ ($\\$8$)。立即数值为 $-3$，其16位二进制补码表示为 $0xFFFD$。\n- $\\text{opcode}[31:26] = 0x8 = 001000_2$\n- $rs[25:21] = 8 = 01000_2$\n- $rt[20:16] = 8 = 01000_2$\n- $\\text{imm}[15:0] = -3 = 0xFFFD = 1111111111111101_2$\n组合这些字段：\n$001000\\ 01000\\ 01000\\ 1111111111111101_2$\n十六进制表示为：\n$0010\\ 0001\\ 0000\\ 1000\\ 1111\\ 1111\\ 1111\\ 1101_2 = 0x2108FFFD$。\n设这个正确的字为 $C_2$。因此，$C_2 = 0x2108FFFD$。\n\n指令 3：J型，$\\text{j } \\text{target}$，编码的目标字段为 $0x0123456$\n这是一条无条件跳转指令。`j` 的操作码是 $0x2$ ($000010_2$)。剩下的26位构成了目标地址字段。\n- $\\text{opcode}[31:26] = 0x2 = 000010_2$\n- $\\text{target}[25:0] = 0x0123456 = 00000100100011010001010110_2$\n组合这些字段：\n$000010\\ 00000100100011010001010110_2$\n十六进制表示为：\n$0000\\ 1000\\ 0001\\ 0010\\ 0011\\ 0100\\ 0101\\ 0110_2 = 0x08123456$。\n设这个正确的字为 $C_3$。因此，$C_3 = 0x08123456$。\n\n接下来，我们利用偶校验的性质来识别带有一位错误的字。对于偶校验，数据字中 $1$ 的位数（其 population count，或 popcount）与校验位之和必须是偶数。数据字中的一位翻转会将其 popcount 从偶数变为奇数，或从奇数变为偶数，从而导致奇偶校验失败。\n接收到的字及其校验位是：\n$W_1 = 0x012A5820$，校验位 $p_1 = 0$\n$W_2 = 0xA108FFFD$，校验位 $p_2 = 0$\n$W_3 = 0x08123456$，校验位 $p_3 = 0$\n\n我们来计算每个接收到的字的 popcount：\n- 对于 $W_1 = 0x012A5820 = 00000001001010100101100000100000_2$：\n$1$ 的数量是 $1+1+1+1+1+1+1+1 = 8$。\n$\\text{popcount}(W_1) = 8$。这是一个偶数。\n奇偶校验：$\\text{popcount}(W_1) + p_1 = 8 + 0 = 8$（偶数）。校验通过。这表明 $W_1$ 很可能没有错误。注意 $W_1 = C_1$。\n\n- 对于 $W_2 = 0xA108FFFD = 10100001000010001111111111111101_2$：\n$1$ 的数量是 $(1+1)+(1)+(1)+(4+4+4)+(1+1+1) = 19$。\n$\\text{popcount}(W_2) = 19$。这是一个奇数。\n奇偶校验：$\\text{popcount}(W_2) + p_2 = 19 + 0 = 19$（奇数）。校验失败。这表明 $W_2$ 是有错误的字。\n\n- 对于 $W_3 = 0x08123456 = 00001000000100100011010001010110_2$：\n$1$ 的数量是 $1+1+1+1+1+1+1+1+1+1 = 10$。\n$\\text{popcount}(W_3) = 10$。这是一个偶数。\n奇偶校验：$\\text{popcount}(W_3) + p_3 = 10 + 0 = 10$（偶数）。校验通过。这表明 $W_3$ 很可能没有错误。注意 $W_3 = C_3$。\n\n分析证实 $W_2$ 是损坏的字。为了识别翻转的位，我们将接收到的字 $W_2$ 与正确的编码 $C_2$ 进行比较：\n$W_2 = 0xA108FFFD = 10100001000010001111111111111101_2$\n$C_2 = 0x2108FFFD = 00100001000010001111111111111101_2$\n通过对这两个值进行异或（XOR）操作，我们可以找到差异：$W_2 \\oplus C_2 = 0x80000000$。这表示在位位置 $31$（最高有效位）上发生了单比特翻转。这个位在传输过程中从 $0$ 翻转为 $1$。至此，我们完成了前三个任务。修正后的字序列是 $(C_1, C_2, C_3)$。\n\n最后，我们计算修正后的三字序列的16位反码校验和：\n$C_1 = 0x012A5820$\n$C_2 = 0x2108FFFD$\n$C_3 = 0x08123456$\n\n每个32位字被分成两个16位的半字（高位、低位）。我们使用反码加法对这六个16位值求和，其中任何从最高有效位 (MSB) 产生的进位都会被加回到最低有效位 (LSB)，这种技术被称为循环进位。\n这六个16位半字是：\n$H_1 = 0x012A$\n$L_1 = 0x5820$\n$H_2 = 0x2108$\n$L_2 = 0xFFFD$\n$H_3 = 0x0812$\n$L_3 = 0x3456$\n\n我们来执行加法运算：\nSum = $0x012A + 0x5820 + 0x2108 + 0xFFFD + 0x0812 + 0x3456$\n$0x012A + 0x5820 = 0x594A$\n$0x594A + 0x2108 = 0x7A52$\n$0x7A52 + 0xFFFD = 0x17A4F$。这个和产生了一个进位位。我们将进位加回去：$0x7A4F + 0x1 = 0x7A50$。\n$0x7A50 + 0x0812 = 0x8262$\n$0x8262 + 0x3456 = 0xB6B8$\n\n最终的16位和是 $S = 0xB6B8$。\n校验和是这个和的反码，计算方式为 $0xFFFF - S$。\nChecksum = $0xFFFF - 0xB6B8 = 0x4947$。\n\n题目要求答案为无符号十进制整数。我们将十六进制的校验和转换为十进制：\nChecksum = $4 \\times 16^3 + 9 \\times 16^2 + 4 \\times 16^1 + 7 \\times 16^0$\nChecksum = $4 \\times 4096 + 9 \\times 256 + 4 \\times 16 + 7 \\times 1$\nChecksum = $16384 + 2304 + 64 + 7$\nChecksum = $18759$。",
            "answer": "$$\n\\boxed{18759}\n$$"
        },
        {
            "introduction": "I型指令中的地址计算是处理器的一项核心功能，但这其中隐藏着一些关于数值表示的精妙之处。本练习聚焦于一个关键细节：当一个有符号的立即数偏移量与一个无符号的基地址相加时，如何精确判断其计算结果是否会超出架构定义的有效地址范围。通过分析这种边界情况，你将能更深刻地理解二进制补码运算以及在底层编程中避免地址错误的关 。",
            "id": "3649744",
            "problem": "考虑一个采用加载-存储（load–store）架构的系统，其地址空间为32位，存储指令使用立即数类型（Immediate-type）格式。该指令包含一个基址寄存器 $r_s$ 和一个16位的二进制补码立即数字段。基址寄存器 $r_s$ 被解释为一个无符号的32位地址。这个16位的立即数被解释为一个有符号整数 $d$，其范围为 $[-2^{15}, 2^{15}-1]$。存储操作所使用的有效地址是通过在32位地址空间内，根据二进制补码偏移语义将 $r_s$ 和 $d$ 组合而成的。该地址空间在模 $2^{32}$ 加法下是封闭的。\n\n在此系统中，当且仅当数学和 $r_s + d$ 超出规范的无符号32位范围 $[0, 2^{32}-1]$ 时，内存子系统会引发地址异常，无论硬件加法器执行的模 $2^{32}$ 回绕（wrap-around）如何。请你分析边界情况（corner cases），并提出一个检查谓词（check predicate），微架构的算术逻辑单元（ALU）可以在发出内存访问之前使用该谓词来标记此类异常有效地址。你的检查必须从第一性原理出发进行论证：二进制补码表示法、$d$ 的有符号范围，以及 $r_s$ 和地址的无符号范围。\n\n设基址寄存器包含 $r_s = \\mathrm{0xFFFF8008}$。使用上述定义，且不借助任何现成的公式，确定在 $d \\in [-2^{15}, 2^{15}-1]$ 范围内，有多少个不同的16位立即数值 $d$ 会使得数学和 $r_s + d$ 落在 $[0, 2^{32}-1]$ 范围之外（即，在模 $2^{32}$ 算术中需要回绕）。你的最终答案必须是一个精确的十进制整数。不需要四舍五入。",
            "solution": "该问题要求我们确定，当一个16位有符号立即数 $d$ 与一个给定的32位无符号基址寄存器地址 $r_s$ 相加时，有多少个不同的 $d$ 值会导致地址异常。异常的定义是：当且仅当理想的数学和 $r_s + d$ 落在有效的无符号32位地址范围 $[0, 2^{32}-1]$ 之外时发生。\n\n首先，我们将给定的信息形式化。\n基址寄存器值为 $r_s = \\mathrm{0xFFFF8008}_{16}$。作为一个无符号32位整数，其值在 $[0, 2^{32}-1]$ 范围内。\n立即数 $d$ 是一个16位二进制补码表示的有符号整数。因此，其范围是 $[-2^{15}, 2^{15}-1]$，等价于 $[-32768, 32767]$。\n有效地址范围是整数集合 $\\{A \\mid 0 \\le A \\le 2^{32}-1 \\}$。如果数学和 $S = r_s + d$ 满足 $S  0$ 或 $S > 2^{32}-1$，则发生地址异常。\n\n让我们分别分析这两种情况。这一分析构成了对微架构检查谓词的论证。\n\n情况1：下溢（Underflow） ($r_s + d  0$)\n此条件可改写为 $d  -r_s$。\n由于 $r_s$ 被指定为一个无符号32位整数，其值为非负数 ($r_s \\ge 0$)。给定的具体值 $r_s = \\mathrm{0xFFFF8008}_{16}$ 显然是正数。\n要使和 $r_s+d$ 为负， $d$ 必须为负数。 $d$ 的范围是 $[-32768, 32767]$。 $d$ 能取到的最小负值为 $d_{min} = -32768$。\n我们来计算 $r_s$ 的值。十六进制值 $\\mathrm{0xFFFF8008}_{16}$ 表示一个大的正整数。我们可以用相对于 $2^{32}-1$ 的形式来表示它。$r_s$ 的按位取反是 $\\sim r_s = \\mathrm{0x00007FF7}_{16}$。我们知道，对于任何无符号32位数 $x$，有 $x + (\\sim x) = 2^{32}-1$。\n因此，$r_s = (2^{32}-1) - (\\sim r_s)$。\n我们来计算 $\\sim r_s$ 的十进制值：\n$\\mathrm{0x00007FF7}_{16} = 7 \\cdot 16^3 + 15 \\cdot 16^2 + 15 \\cdot 16^1 + 7 \\cdot 16^0 = 7 \\cdot 4096 + 15 \\cdot 256 + 240 + 7 = 28672 + 3840 + 247 = 32759$。\n所以，$r_s = (2^{32}-1) - 32759 = 2^{32} - 32760$。\n下溢条件是 $d  -r_s = -(2^{32} - 32760) = 32760 - 2^{32}$。\n$d$ 范围内的最小值为 $-32768$。\n我们必须检查是否有任何在其范围内的 $d$ 满足 $d  32760 - 2^{32}$。\n由于 $2^{32}$ 是一个非常大的数 ($4294967296$)，值 $32760 - 2^{32}$ 是一个绝对值非常大的负数。\n具体来说，$32760 - 2^{32} = -4294934536$。\n条件变为 $d  -4294934536$。\n$d$ 能取到的最小负值为 $-32768$。由于 $-32768 > -4294934536$，因此在 $d$ 的允许范围内，没有任何值可以导致下溢。\n导致下溢的 $d$ 值的数量为 $0$。\n用于下溢的微架构谓词是：`if (d  0 and r_s  -d)`，标记异常。这里，$-d$ 是数学上的负数，等价于 $|d|$。对于任何 $d  0$，我们有 $-d \\le 32768$。由于 $r_s = 2^{32} - 32760$ 远大于 $32768$，这个条件永远不会满足。\n\n情况2：上溢（Overflow） ($r_s + d > 2^{32}-1$)\n此条件可改写为 $d > (2^{32}-1) - r_s$。\n如果 $d \\le 0$，那么 $r_s + d \\le r_s$。由于 $r_s \\le 2^{32}-1$，对于非正数的 $d$ 不可能发生上溢。因此，我们只需要考虑 $d > 0$。\n用于上溢的微架构谓词是：`if (d > 0 and r_s > (2^32 - 1) - d)`，标记异常。\n让我们将此谓词应用于给定的问题值。我们代入 $r_s$ 的表达式：\n$d > (2^{32}-1) - ( (2^{32}-1) - 32759 )$。\n$d > (2^{32}-1) - (2^{32}-1) + 32759$。\n$d > 32759$。\n现在我们需要找到满足此不等式且同时在 $d$ 的允许范围 $[-32768, 32767]$ 内的整数 $d$ 的数量。\n将条件 $d > 32759$ 与 $d$ 的范围约束相结合，我们得到复合不等式：\n$32759  d \\le 32767$。\n满足此条件的整数 $d$ 是 $\\{32760, 32761, 32762, 32763, 32764, 32765, 32766, 32767\\}$。\n为了求出这个集合中值的数量，我们计算：\n值的数量 = (最后一个值) - (第一个值) + $1$。\n值的数量 = $32767 - 32760 + 1 = 7 + 1 = 8$。\n所以，有 $8$ 个不同的 $d$ 值会导致上溢异常。\n\n总数：\n$d$ 的异常值总数是下溢和上溢情况计数的总和。\n总数 = (下溢值的数量) + (上溢值的数量) = $0 + 8 = 8$。\n\n因此，恰好有 $8$ 个立即数值会使得数学和 $r_s + d$ 落在规范的无符号32位范围之外。",
            "answer": "$$\\boxed{8}$$"
        },
        {
            "introduction": "将理论知识付诸实践是检验学习成果的最佳方式。这项顶点练习要求你从零开始，构建一个能够解析和执行R型、I型和J型指令的微型模拟器。通过亲手实现这个系统，并特意引入一个关于符号扩展的常见错误，你将直观地看到一个看似微小的实现细节如何对程序算术逻辑和控制流产生巨大影响 。",
            "id": "3649792",
            "problem": "您需要为一个简化的、类似 MIPS 的指令集实现一个自包含的解释器，重点关注指令集架构 (ISA) 的指令格式：寄存器类型 (R-type)、立即数类型 (I-type) 和跳转类型 (J-type)。该解释器必须能够解码并执行一小组操作，并故意引入一个特定的错误：省略对 I-type 立即数字段的符号扩展。然后，您必须使用单元测试来观察此错误对算术和控制流造成的影响。\n\n基本和核心定义：\n- 二进制补码整数：一个有符号的n-bit二进制补码整数表示范围在 $[-2^{n-1}, 2^{n-1}-1]$ 内的值。从n位到m位（$m > n$）的符号扩展会将n-bit表示的最高有效位（符号位）复制到高位的 $m-n$ 位中。\n- R-type 指令格式 (32位)：位 $[31:26]$ 是操作码 (opcode)，位 $[25:21]$ 是源寄存器 $rs$，位 $[20:16]$ 是源寄存器 $rt$，位 $[15:11]$ 是目标寄存器 $rd$，位 $[10:6]$ 是位移量 $shamt$，位 $[5:0]$ 是功能字段 $funct$。我们限制操作码为 $0$，并使用 $funct=32$ 表示加法。\n- I-type 指令格式 (32位)：位 $[31:26]$ 是操作码，位 $[25:21]$ 是 $rs$，位 $[20:16]$ 是 $rt$，位 $[15:0]$ 是立即数。正确的算术运算要求在使用前将16-bit的立即数符号扩展到32位。\n- J-type 指令格式 (32位)：位 $[31:26]$ 是操作码，位 $[25:0]$ 是目标地址部分。程序计数器 (PC) 的更新使用 $$\\mathrm{PC} \\leftarrow (\\mathrm{PC} \\ \\ \\ 0xF0000000) \\ | \\ (\\text{target} \\ll 2),$$ 其中 $\\ll$ 表示左移，$\\$ 和 $|$ 分别表示按位与和按位或。\n- 程序计数器 (PC) 模型：PC 从 $0$ 开始，每条指令为 $4$ 字节，正常的顺序更新是 $\\mathrm{PC} \\leftarrow \\mathrm{PC} + 4$，除非被分支或跳转指令修改。\n\n需要实现的受支持操作：\n- R-type 加法：当 $funct = 32$ 且 $opcode = 0$ 时，执行 $rd \\leftarrow rs + rt$。\n- I-type 立即数加法：当 $opcode = 8$ (Add Immediate) 时，执行 $rt \\leftarrow rs + \\text{imm}$。正确的行为要求将16-bit立即数符号扩展到32位。\n- I-type 相等则分支：当 $opcode = 4$ 时，如果 $rs = rt$，则 $$\\mathrm{PC} \\leftarrow \\mathrm{PC} + 4 + (\\text{sign-extended immediate} \\times 4),$$ 否则 $$\\mathrm{PC} \\leftarrow \\mathrm{PC} + 4.$$\n- J-type 跳转：当 $opcode = 2$ 时，使用上述 J-type PC 更新规则。\n\n要包含的错误：\n- 在有错误的解释器中，通过将16-bit立即数视为零扩展的32-bit值来省略 I-type 立即数的符号扩展。这将影响算术运算 (Add Immediate) 和控制流 (Branch if Equal)。\n\n算法要求：\n- 使用位掩码和位移操作来解码字段，这些操作源自格式定义。例如，`rs = (word >> 21)  0x1F`，`rt = (word >> 16)  0x1F`，`rd = (word >> 11)  0x1F`，`funct = word  0x3F`，`opcode = (word >> 26)  0x3F`。\n- 实现两个解释器：一个进行正确符号扩展的正确解释器，和一个省略符号扩展的错误解释器。\n- 寄存器：使用32个初始化为 $0$ 的通用寄存器。忽略内存操作；该程序是一个纯粹的寄存器和控制流模拟器。\n- 暂停规则：当 $\\mathrm{PC}/4$ 超出指令数组边界或达到安全步数限制时暂停。\n\n测试套件和覆盖范围：\n使用以下四个程序（每个都是一个32-bit指令的数组）。所有寄存器初始值为 $0$；$\\mathrm{PC}$ 从 $0$ 开始。对于每个程序，报告在错误解释器和正确解释器下寄存器 $r1$ 的最终值。\n\n- 测试用例 $1$ (正常路径，正立即数和 R-type 加法)：\n  1. I-type: addi $r1, r0, 5$，其中 $opcode = 8$, $rs = 0$, $rt = 1$, $\\text{imm} = 5$。\n  2. R-type: add $r2, r1, r1$，其中 $opcode = 0$, $rs = 1$, $rt = 1$, $rd = 2$, $shamt = 0$, $funct = 32$。\n  预期行为：两个解释器都会产生相同的最终值 $r1 = 5$。\n\n- 测试用例 $2$ (负立即数，缺少符号扩展导致的算术错误)：\n  1. I-type: addi $r1, r0, -1$，其中 $opcode = 8$, $rs = 0$, $rt = 1$, $\\text{imm}$ 编码为 $0xFFFF$（$-1$ 在16位二进制补码中的表示）。\n  预期行为：正确解释器得出 $r1 = -1$；错误解释器得出 $r1 = 65535$。\n\n- 测试用例 $3$ (带有负分支偏移的控制流，循环终止)：\n  程序索引从 $0$ 到 $4$：\n  0. I-type: addi $r1, r0, 3$。\n  1. I-type: addi $r1, r1, -1$。\n  2. I-type: beq $r1, r0, \\text{Lend}$，其中 $\\text{Lend}$ 是指令索引 $4$，所以分支立即数为 $+1$（因为 $4 - (2+1) = 1$）。\n  3. I-type: beq $r0, r0, \\text{Lloop}$，其中 $\\text{Lloop}$ 是指令索引 $1$，所以分支立即数为 $-3$（因为 $1 - (3+1) = -3$），此分支总是会执行，除非之前到 $\\text{Lend}$ 的分支已执行。\n  4. R-type: add $r2, r1, r0$ (将 $r1$ 复制到 $r2$)。\n  预期行为：正确解释器将 $r1$ 递减直到为零并到达 $\\text{Lend}$；最终 $r1 = 0$。错误解释器会错误地将负偏移解释为一个大的正偏移，提前跳转到越界地址，并留下一个不正确的非零 $r1$ 值。\n\n- 测试用例 $4$ (J-type 跳转不受符号扩展影响)：\n  程序索引从 $0$ 到 $3$：\n  0. I-type: addi $r1, r0, 1$。\n  1. J-type: j 跳转到指令索引 $3$。\n  2. I-type: addi $r1, r1, 5$ (此指令被跳过)。\n  3. R-type: add $r2, r1, r0$。\n  预期行为：两个解释器都会产生最终值 $r1 = 1$。\n\n最终输出规范：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按上述测试用例的顺序，包含每个测试用例的 $r1$ 最终值，先是使用错误解释器的结果，然后是使用正确解释器的结果。即，输出格式为\n$$[\\text{buggy}_1,\\text{correct}_1,\\text{buggy}_2,\\text{correct}_2,\\text{buggy}_3,\\text{correct}_3,\\text{buggy}_4,\\text{correct}_4].$$\n所有结果都是整数；不涉及物理单位或角度。\n\n注意：所有解码和执行都必须遵循上述 ISA 定义。除了二进制补码、位掩码和 PC 更新规则的基本定义外，不要使用快捷公式。确保执行语义的科学真实性和一致性。",
            "solution": "我们从二进制补码表示和符号扩展原理开始。一个有符号的n-bit二进制补码整数使用最高有效位 (MSB) 作为符号位。对于一个16-bit的立即数 $\\text{imm}$，符号位是第 $15$ 位。要符号扩展到32位，如果第 $15$ 位是 $1$，我们用 $1$ 填充高 $16$ 位；如果第 $15$ 位是 $0$，则用 $0$ 填充它们。形式上，如果 $\\text{imm}$ 表示解释为无符号值的16-bit字段，\n$$\n\\text{sign\\_extend}_{16\\rightarrow 32}(\\text{imm}) = \n\\begin{cases}\n\\text{imm}  \\text{if } (\\text{imm} \\ \\ \\ 0x8000) == 0,\\\\\n\\text{imm} \\ | \\ 0xFFFF0000  \\text{otherwise}.\n\\end{cases}\n$$\n这确保了一个负的16-bit值（例如，在16-bit二进制补码中表示 $-1$ 的 $0xFFFF$）在32位中变为 $0xFFFFFFFF$（在32-bit二进制补码中表示 $-1$）。相比之下，有错误的解释器使用\n$$\n\\text{zero\\_extend}_{16\\rightarrow 32}(\\text{imm}) = \\text{imm} \\ \\ \\ 0x0000FFFF,\n$$\n这会错误地将负的16-bit立即数解释为大的正32-bit值。\n\n指令解码由格式定义：\n- 对于一个32-bit的字 $w$，操作码是 `((w >> 26)  0x3F)`。对于 R-type，其中 opcode $=0$，我们提取 $rs = ((w >> 21) \\ \\ \\ 0x1F)$，$rt = ((w >> 16) \\ \\ \\ 0x1F)$，$rd = ((w >> 11) \\ \\ \\ 0x1F)$，$shamt = ((w >> 6) \\ \\ \\ 0x1F)$ 和 $funct = (w \\ \\ \\ 0x3F)$。对于 I-type，我们提取 $rs$、$rt$ 和 $\\text{imm} = (w \\ \\ \\ 0xFFFF)$。对于 J-type，我们提取目标地址为 $(w \\ \\ \\ 0x03FFFFFF)$。\n- 程序计数器 (PC) 从 $0$ 字节开始。对于顺序执行，$\\mathrm{PC} \\leftarrow \\mathrm{PC} + 4$。对于相等则分支 (BEQ) 且操作码为 $4$，当 $rs = rt$ 时，新的 PC 是 \n$$\n\\mathrm{PC} \\leftarrow \\mathrm{PC} + 4 + (\\text{sign-extended immediate} \\times 4),\n$$\n其中乘以 $4$ 是为了字节寻址（立即数编码的是指令字的偏移量）。对于跳转 (J) 且操作码为 $2$，新的 PC 是 \n$$\n\\mathrm{PC} \\leftarrow (\\mathrm{PC} \\ \\ \\ 0xF0000000) \\ | \\ (\\text{target} \\ll 2).\n$$\n\n我们实现两个解释器：\n- 正确解释器：对 I-type 立即数算术和分支偏移使用 $\\text{sign\\_extend}_{16\\rightarrow 32}$。\n- 错误解释器：对 I-type 立即数算术和分支偏移使用 $\\text{zero\\_extend}_{16\\rightarrow 32}$。\n\n我们现在使用与 ISA 一致的辅助函数来指定测试套件的编码：\n- R-type 编码：\n$$\n\\text{encode\\_R}(rs, rt, rd, shamt, funct) = (0 \\ll 26) \\ | \\ (rs \\ll 21) \\ | \\ (rt \\ll 16) \\ | \\ (rd \\ll 11) \\ | \\ (shamt \\ll 6) \\ | \\ funct.\n$$\n- I-type 编码：\n$$\n\\text{encode\\_I}(opcode, rs, rt, \\text{imm}) = (opcode \\ll 26) \\ | \\ (rs \\ll 21) \\ | \\ (rt \\ll 16) \\ | \\ (\\text{imm} \\ \\ \\ 0xFFFF).\n$$\n- J-type 编码：\n$$\n\\text{encode\\_J}(opcode, \\text{target}) = (opcode \\ll 26) \\ | \\ (\\text{target} \\ \\ \\ 0x03FFFFFF).\n$$\n当我们指定跳转到指令索引 $k$ 时，我们使用 $\\text{target} = k$，这将 $\\mathrm{PC}$ 设置为 $4k$，因为跳转硬件执行了 $2$ 位的左移。\n\n预期结果推理：\n- 测试用例 $1$：`addi r1, r0, 5` 后跟 `add r2, r1, r1`。立即数 $5$ 的第 $15$ 位为 $0$，因此符号扩展等同于零扩展；两个解释器最终都计算出 $r1 = 5$。\n- 测试用例 $2$：`addi r1, r0, -1`。16-bit编码是 $0xFFFF$。正确解释器将其符号扩展为 $0xFFFFFFFF$ ($-1$)，得到 $r1 = -1$。错误解释器将其零扩展为 $0x0000FFFF$ ($65535$)，得到 $r1 = 65535$。\n- 测试用例 $3$：循环：\n  - 索引 $0$：`addi r1, r0, 3`，`r1` 变为 $3$。\n  - 索引 $1$：`addi r1, r1, -1`。对于正确解释器，`r1` 递减。对于错误解释器，`r1 = r1 + 65535`。\n  - 索引 $2$：`beq r1, r0, Lend`。\n  - 索引 $3$：`beq r0, r0, Lloop`，立即数为 $-3$。正确解释器总是跳转回索引 $1$。错误解释器将 $-3$（$0xFFFD$）解释为 $65533$，PC 将变为 `12 + 4 + (65533 * 4) = 262148`，这会超出程序边界并暂停。\n  - 正确执行：$r1$ 依次为 $3, 2, 1, 0$。当 $r1=0$ 时，索引2的分支被采用，跳转到索引4，程序暂停。最终 $r1=0$。\n  - 错误执行：在第一次迭代中，`PC=0`: `r1` = 3。`PC=4`: `r1` = 3 + 65535 = 65538。`PC=8`: `r1` != 0，不分支。`PC=12`: 无条件分支到越界地址，暂停。最终 `r1=65538`。\n- 测试用例 $4$：`addi r1, r0, 1`，然后跳转到索引 $3$ 以跳过索引 $2$ 处的 `addi +5`。J-type 不涉及符号扩展；两个解释器结果一致：最终 $r1 = 1$。\n\n因此，聚合输出是最终 $r1$ 值的列表：\n$$[\\text{buggy}_1,\\text{correct}_1,\\text{buggy}_2,\\text{correct}_2,\\text{buggy}_3,\\text{correct}_3,\\text{buggy}_4,\\text{correct}_4],$$\n根据以上推理，该列表将是 $[5, 5, 65535, -1, 65538, 0, 1, 1]$。\n\n实现遵循这些原则，通过位掩码和位移解码字段，按规定应用正确或错误的立即数处理，并在 $\\mathrm{PC}$ 超出范围或达到安全步数限制时暂停以确保终止。",
            "answer": "$$[5, 5, 65535, -1, 65538, 0, 1, 1]$$"
        }
    ]
}