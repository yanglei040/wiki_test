{
    "hands_on_practices": [
        {
            "introduction": "基址加偏移量寻址是访问数组等数据结构中元素的基础。本练习将引导你从第一性原理出发，为二维数组推导寻址公式，然后将此理论计算与实际性能考量相结合，即数组维度和元素大小如何与缓存行交互，从而影响内存访问效率。",
            "id": "3622182",
            "problem": "一个维度为 $M \\times N$ 的二维数组 $A$ 以行主序存储在主存中，其中每个元素占用 $w$ 字节。该数组的基地址（即 $A[0][0]$ 的地址）为 $B$ 字节（从零地址算起）。内存系统使用高速缓存，其缓存行大小为 $L$ 字节。你可以假设 $B$ 与缓存行边界对齐。考虑以下两种仅在元素宽度上有所不同的场景：\n- 场景 $\\mathrm{S1}$：$M$ 和 $N$ 固定为 $M=128$，$N=96$，元素宽度为 $w_{1}=4$ 字节，缓存行大小为 $L=64$ 字节。基地址为 $B=2^{28}$ 字节。\n- 场景 $\\mathrm{S2}$：与场景 $\\mathrm{S1}$ 相同，只是元素宽度为 $w_{2}=8$ 字节。\n\n从以下基本定义出发：(i) 行主序布局将一行的连续元素连续地存储在内存中，并且各行之间没有间隙地相继排列；(ii) 基址加偏移量寻址方式通过基地址加上从第一个元素算起的字节偏移量来形成有效地址。仅以这些定义为出发点，完成以下任务：\n\n1. 推导 $A[i][j]$ 的有效地址（以字节为单位）$\\mathrm{EA}(i,j)$ 的表达式，该表达式是关于 $B$、$i$、$j$、$N$ 和 $w$ 的函数。\n2. 使用你推导出的表达式，计算在场景 $\\mathrm{S1}$ 下元素 $A[i_{0}][j_{0}]$（其中 $i_{0}=37$，$j_{0}=58$）的数值有效地址（以字节为单位）。\n3. 对于一个固定的行索引 $i_{0}$，考虑一种流式访问模式，即从冷缓存开始，对 $j=0,1,\\dots,N-1$ 读取 $A[i_{0}][j]$，并假设除了强制性缓存行填充外，没有冲突或容量效应。从基本原理出发，确定在场景 $\\mathrm{S1}$ 和场景 $\\mathrm{S2}$ 中，读取这一行需要获取多少个不同的缓存行，并解释 $N$、$w$、$L$ 和基址对齐如何决定这个数量。\n4. 设 $r$ 为场景 $\\mathrm{S2}$ 中每行强制性缓存行填充次数与场景 $\\mathrm{S1}$ 中该次数的比率。明确计算 $r$。\n\n提供 $r$ 作为你的最终答案。无需四舍五入。如果你计算了中间地址，请以字节表示，但你的最终答案必须是无单位的单个数字 $r$。",
            "solution": "该问题提法明确，具有科学依据，并为给出完整解答提供了所有必要信息。我们按顺序处理这四个要求的部分。\n\n### 第 1 部分：有效地址表达式的推导\n\n问题指定了两个可作为起点的基本定义。\n(i) 行主序布局将数组的一行中的连续元素在内存中连续存储，并且整行依次排列。\n(ii) 基址加偏移量寻址方式通过基地址和字节偏移量之和来计算内存位置的有效地址。\n\n设二维数组为 $A$，有 $M$ 行和 $N$ 列，索引从 $0$ 开始。设 $A[i][j]$ 表示第 $i$ 行第 $j$ 列的元素，其中 $0 \\le i  M$ 且 $0 \\le j  N$。基地址 $B$ 是第一个元素 $A[0][0]$ 的内存地址。每个元素占用 $w$ 字节。\n\n要找到任意元素 $A[i][j]$ 的地址，我们必须计算它相对于基地址 $B$ 的字节偏移量。在行主序中，要到达第 $i$ 行的开头，我们必须首先遍历前面的所有 $i$ 行（从第 $0$ 行到第 $i-1$ 行）。这些行中的每一行都包含 $N$ 个元素。因此，第 $i$ 行之前的元素数量为 $i \\times N$。\n\n在第 $i$ 行内部，元素 $A[i][j]$ 之前有 $j$ 个其他元素（从第 $0$ 列到第 $j-1$ 列）。\n\n因此，在内存中位于 $A[i][j]$ 之前的元素总数是前面各行中的元素与当前行中元素的总和：$(i \\cdot N) + j$。\n\n由于每个元素的大小为 $w$ 字节，所以从数组起始位置算起的总字节偏移量是前面元素总数乘以每个元素的大小。\n$$ \\text{字节偏移量} = (i \\cdot N + j) \\cdot w $$\n\n根据基址加偏移量寻址的原理，有效地址 $\\mathrm{EA}(i,j)$ 是基地址 $B$ 与此字节偏移量之和。\n$$ \\mathrm{EA}(i,j) = B + (iN + j)w $$\n此表达式提供了元素 $A[i][j]$ 的有效地址（以字节为单位），作为 $B$、$i$、$j$、$N$ 和 $w$ 的函数。\n\n### 第 2 部分：场景 S1 的数值有效地址\n\n对于场景 $\\mathrm{S1}$，我们有以下给定值：\n基地址 $B = 2^{28}$ 字节。\n列数 $N = 96$。\n元素宽度 $w_1 = 4$ 字节。\n特定元素是 $A[i_0][j_0]$，其中 $i_0 = 37$，$j_0 = 58$。\n\n使用推导出的 $\\mathrm{EA}(i,j)$ 公式：\n$$ \\mathrm{EA}(i_0, j_0) = B + (i_0 N + j_0) w_1 $$\n代入场景 $\\mathrm{S1}$ 的数值：\n$$ \\mathrm{EA}(37, 58) = 2^{28} + (37 \\cdot 96 + 58) \\cdot 4 $$\n首先，我们计算括号内的项：\n$$ 37 \\cdot 96 = 3552 $$\n$$ 3552 + 58 = 3610 $$\n现在，我们乘以元素宽度并加上基地址：\n$$ \\mathrm{EA}(37, 58) = 2^{28} + (3610) \\cdot 4 $$\n$$ \\mathrm{EA}(37, 58) = 2^{28} + 14440 $$\n$2^{28}$ 的值是 $268,435,456$。\n$$ \\mathrm{EA}(37, 58) = 268,435,456 + 14440 = 268,449,896 $$\n所以，$A[37][58]$ 的数值有效地址是 $268,449,896$ 字节。\n\n### 第 3 部分：缓存行获取次数\n\n对于顺序内存访问，强制性缓存行获取的次数取决于访问的起始地址相对于缓存行边界的位置以及访问的总字节数。问题指出，高速缓存初始为冷状态，并且没有其他缓存效应（冲突/容量未命中），因此每次首次访问缓存行都会导致一次强制性未命中和一次获取。\n\n数组的单一行 $i_0$ 被读取，从 $A[i_0][0]$ 到 $A[i_0][N-1]$。\n一行中的总字节数为 $N \\cdot w$。\n缓存行大小为 $L$。\n第 $i_0$ 行的起始地址是 $\\mathrm{EA}(i_0, 0) = B + i_0 N w$。\n问题指出基地址 $B$ 与缓存行边界对齐，这意味着 $B$ 是 $L$ 的整数倍，即 $B \\pmod{L} = 0$。\n\n因此，第 $i_0$ 行起始地址的对齐情况取决于 $(i_0 N w) \\pmod{L}$ 这一项。如果该项为 $0$，则该行恰好从一个缓存行边界开始，这会简化计算。\n\n**场景 S1：**\n- $N = 96$，$w_1 = 4$ 字节，$L = 64$ 字节。\n每行的总字节数为 $N \\cdot w_1 = 96 \\cdot 4 = 384$ 字节。\n我们来检查一行的大小相对于缓存行大小：\n$$ \\frac{N w_1}{L} = \\frac{384}{64} = 6 $$\n这表明一整行的字节大小恰好是 $6$ 个缓存行。\n由于基地址 $B$ 与一个 $L$ 字节的边界对齐，并且每一行的大小（$N w_1$）是 $L$ 的整数倍，因此*每一*行 $i$ 的起始地址也必须与缓存行边界对齐。\n$$ \\mathrm{EA}(i, 0) \\pmod{L} = (B + i N w_1) \\pmod{L} = (B \\pmod{L} + (i \\cdot 6L) \\pmod{L}) \\pmod{L} = (0 + 0) \\pmod{L} = 0 $$\n因为访问从缓存行边界开始，并且跨越的恰好是整数个缓存行，所以获取的缓存行数量 $C_1$ 就是总行大小（以字节为单位）除以缓存行大小。\n$$ C_1 = \\frac{N w_1}{L} = \\frac{384}{64} = 6 $$\n因此，在场景 $\\mathrm{S1}$ 中，读取一行需要获取 $6$ 个不同的缓存行。\n\n**场景 S2：**\n- $N = 96$，$w_2 = 8$ 字节，$L = 64$ 字节。\n每行的总字节数为 $N \\cdot w_2 = 96 \\cdot 8 = 768$ 字节。\n我们来检查这一行的大小相对于缓存行大小：\n$$ \\frac{N w_2}{L} = \\frac{768}{64} = 12 $$\n与场景 $\\mathrm{S1}$ 类似，一整行的字节大小是缓存行大小的整数倍。出于同样的原因，任何一行 $i$ 的起始地址都与缓存行边界对齐。\n因此，获取的缓存行数量 $C_2$ 是：\n$$ C_2 = \\frac{N w_2}{L} = \\frac{768}{64} = 12 $$\n在场景 $\\mathrm{S2}$ 中，读取一行需要获取 $12$ 个不同的缓存行。\n\n### 第 4 部分：比率 r 的计算\n\n比率 $r$ 定义为场景 $\\mathrm{S2}$ 中每行强制性缓存行填充次数除以场景 $\\mathrm{S1}$ 中的次数。\n$$ r = \\frac{C_2}{C_1} $$\n使用第 3 部分计算出的值：\n$$ r = \\frac{12}{6} = 2 $$\n或者，我们可以在代入数值之前用符号表示该比率：\n$$ r = \\frac{N w_2 / L}{N w_1 / L} = \\frac{w_2}{w_1} $$\n给定 $w_2 = 8$ 字节和 $w_1 = 4$ 字节：\n$$ r = \\frac{8}{4} = 2 $$\n强制性缓存行填充的比率为 $2$。",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "在上一个问题介绍了缓存之后，本实践将聚焦于一个常见的性能陷阱：跨越缓存行边界的内存访问。通过精确计算内存地址和周期成本，你将具体理解为什么数据对齐对于高性能代码至关重要，将一个抽象概念转化为可量化的性能损失。",
            "id": "3622073",
            "problem": "一个64位处理器为加载指令实现基址加偏移量寻址。该处理器使用一级（L1）数据缓存，此缓存采用物理索引、物理标记，缓存行大小为$64$字节。缓存行与$64$的整数倍地址对齐，因此一个缓存行的起始地址用$L$表示，并覆盖半开区间$\\left[L, L+64\\right)$。考虑内存中的一个结构体数组。对于该数组中的某个元素$s$，编译器已将$s$的基地址放入一个通用寄存器中，并且对$s$内部一个$16$字节字段的加载使用了一条采用基址加偏移量寻址模式的加载指令。\n\n假设以下具体场景：\n- 结构体实例$s$的基地址是$\\texttt{0x10004000} + 52$。设$L = \\texttt{0x10004000}$，这是一个与$64$字节缓存行边界对齐的地址。因此，$s$的地址是$L + 52$。\n- 被加载的字段从$s$的起始位置开始，字节偏移量为$8$，其宽度为$w = 16$字节。加载指令使用该偏移量，通过基址加偏移量的方式计算出有效地址$EA$来寻址该字段。\n- 在冷启动条件下，内存系统的行为如下：当一级（L1）数据缓存发生未命中时，该请求在二级（L2）和三级（L3）缓存中也同样未命中，每次从主存中读取一个独立的$64$字节缓存行需要$180$个周期才能完成。忽略任何重叠或流水线操作；将每次行填充视为一个$180$周期的附加成本。不计算L1命中时的处理器核心执行延迟；只计算由未命中引起的底层内存流量所产生的周期。\n\n任务：\n1. 使用给定的基地址和偏移量，计算$16$字节字段加载的有效地址$EA$。\n2. 判断从$EA$开始的$16$字节加载是完全包含在缓存行$\\left[L, L+64\\right)$内，还是跨入了下一个缓存行。如果跨行，请确定这次加载所触及的在$\\left[L, L+64\\right)$和$\\left[L+64, L+128\\right)$中的确切字节范围。\n3. 在所述的冷启动未命中行为下，确定这次加载触发了多少次从主存进行的独立的$64$字节行填充，并将其与同等宽度的加载完全包含在单个缓存行内所触发的次数进行比较。\n4. 相对于不跨越缓存行边界的同等宽度加载，这次加载仅因跨越缓存行边界而产生的额外内存周期数是多少？请以单个整数周期数的形式提供最终答案。无需四舍五入。单位是周期；请勿在最终的数值答案中包含单位。",
            "solution": "首先对问题进行验证，以确保其科学上合理、内容自洽且定义明确。\n\n### 步骤 1：提取已知条件\n- 处理器架构：$64$位\n- 寻址模式：基址加偏移量\n- L1数据缓存行大小：$64$字节\n- 缓存行对齐：起始地址$L$是$64$的整数倍。一个缓存行覆盖区间$[L, L+64)$。\n- 结构体$s$的基地址：设$L = \\texttt{0x10004000}$，这是一个$64$字节对齐的地址。$s$的地址是$L + 52$。\n- $s$内的字段偏移量：$8$字节。\n- 字段宽度（加载宽度）：$w = 16$字节。\n- 内存系统行为：冷启动。L1、L2和L3缓存未命中导致从主存读取。\n- 主存延迟：每次独立的$64$字节行填充为$180$个周期。此成本是累加的，不可重叠。\n- 成本核算：忽略L1命中延迟；只计算由未命中引起的底层内存流量所产生的周期。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据：** 该问题描述了计算机体系结构中的一个典型场景，涉及内存层次结构，特别是跨越缓存行边界的非对齐内存访问所带来的性能影响。所有概念——基址加偏移量寻址、缓存行、未命中惩罚——都是基础概念且表述正确。\n- **良构性：** 该问题为每个任务提供了计算唯一答案所需的所有数值和约束条件。问题是明确的。\n- **客观性：** 该问题使用精确、技术性的语言陈述，不含主观性。\n\n### 步骤 3：结论与行动\n该问题被判定为**有效**。这是一个计算机组成与体系结构领域的标准且良构的问题。可以继续进行求解。\n\n### 解题推导\n\n通过完成问题陈述中列出的四个任务来求解。\n\n**任务 1：计算有效地址 $EA$**\n\n有效地址（$EA$）是加载操作开始的内存位置。它使用基址加偏移量寻址模式计算。\n基地址是结构体实例$s$的起始地址。\n$$ \\text{Base Address} = \\text{Address of } s $$\n问题陈述$s$的地址是$L + 52$，其中$L = \\texttt{0x10004000}$。\n$$ \\text{Base Address} = L + 52 $$\n偏移量是从结构体$s$的起始位置到被加载字段起始位置的字节距离。给定值为$8$字节。\n$$ \\text{Offset} = 8 $$\n有效地址是基地址和偏移量之和。\n$$ EA = \\text{Base Address} + \\text{Offset} $$\n$$ EA = (L + 52) + 8 = L + 60 $$\n在数值上，这对应于地址$\\texttt{0x10004000} + 60$，即$\\texttt{0x1000403C}$。\n\n**任务 2：判断加载是否跨越缓存行边界**\n\n一个缓存行是一个$64$字节的内存块，与$64$字节边界对齐。我们关注的第一个缓存行从地址$L$开始，覆盖字节地址的半开区间$[L, L+64)$。下一个连续的缓存行从$L+64$开始，覆盖区间$[L+64, L+128)$。\n\n加载操作针对一个宽度为$w=16$字节的字段，起始有效地址为$EA = L+60$。因此，该加载访问内存区间内的所有字节：\n$$ [EA, EA+w) = [L+60, L+60+16) = [L+60, L+76) $$\n为了判断这次访问是否跨越边界，我们将此区间与缓存行的区间进行比较。\n第一个缓存行是$[L, L+64)$。\n第二个缓存行是$[L+64, L+128)$。\n\n访问从$L+60$开始，由于$L \\le L+60  L+64$，该地址在第一个缓存行内。\n访问在$L+76$之前结束。结束地址$L+75$在第二个缓存行内，因为$L+64 \\le L+75  L+128$。\n由于访问的起始在一条缓存行，而结束在另一条缓存行，因此这个$16$字节的加载在地址$L+64$处**跨越了缓存行边界**。\n\n这次加载触及的确切字节范围是：\n- 在第一个缓存行$[L, L+64)$中：加载操作访问从其起始地址$L+60$到行边界的字节，即区间$[L+60, L+64)$。这构成了$64 - 60 = 4$个字节。\n- 在第二个缓存行$[L+64, L+128)$中：加载操作访问从行边界$L+64$到其结束位置的字节，即区间$[L+64, L+76)$。这构成了$76 - 64 = 12$个字节。\n访问的总字节数是$4 + 12 = 16$，这与字段宽度$w$正确匹配。\n\n**任务 3：确定独立的行填充次数**\n\n问题指定了冷启动条件，意味着所需数据不在任何级别的缓存中。对一个地址的内存访问将导致缓存未命中，从而触发从主存中获取包含该地址的整个$64$字节缓存行。\n该加载操作需要来自两个不同缓存行的数据：\n1. 包含地址$L+60$的缓存行。这是从地址$L$开始的缓存行（因为$L = \\lfloor (L+60)/64 \\rfloor \\times 64$）。\n2. 包含地址$L+64$的缓存行。这是从地址$L+64$开始的缓存行。\n\n因为加载操作跨越了两个不同的缓存行，并且缓存是冷的，所以它将产生两次独立的缓存未命中。每次未命中都将触发一次从主存进行的独立的$64$字节行填充。因此，这条加载指令触发了**$2$**次独立的行填充。\n\n作为比较，如果一个相同宽度（$16$字节）的加载完全包含在单个缓存行内（例如，如果它从像$L+0$或$L+32$这样的地址开始），它将只触及一个$64$字节对齐块内的地址。在冷启动条件下，这将只导致**$1$**次缓存未命中，因此只触发**$1$**次行填充。\n\n**任务 4：计算额外的内存周期数**\n\n从主存进行单次行填充的开销给定为$180$个周期。\n跨边界加载的总内存延迟是所有触发的行填充延迟的总和。\n$$ \\text{Total Cycles}_{\\text{crossing}} = (\\text{Number of line fills}) \\times (\\text{Cycles per fill}) $$\n$$ \\text{Total Cycles}_{\\text{crossing}} = 2 \\times 180 \\text{ cycles} = 360 \\text{ cycles} $$\n一个假设的、相同宽度的非跨越（对齐）加载的总内存延迟将是：\n$$ \\text{Total Cycles}_{\\text{aligned}} = 1 \\times 180 \\text{ cycles} = 180 \\text{ cycles} $$\n完全由跨越缓存行边界引起的额外内存周期数是这两种情况之间的差值。\n$$ \\text{Extra Cycles} = \\text{Total Cycles}_{\\text{crossing}} - \\text{Total Cycles}_{\\text{aligned}} $$\n$$ \\text{Extra Cycles} = 360 - 180 = 180 $$\n换一种说法，与对齐的情况相比，跨边界事件导致了一次额外的行填充。这一次额外行填充的成本是$180$个周期。\n因此，额外的内存周期数是$180$。",
            "answer": "$$\\boxed{180}$$"
        },
        {
            "introduction": "现在，我们将基址加偏移量寻址的应用从静态数据结构转移到函数执行的动态上下文中，其中帧指针（$FP$）充当访问参数和局部变量的稳定基址。本练习旨在揭示编译器为函数调用管理内存的机制，你需要仔细应用ABI（应用程序二进制接口）规则、对齐和偏移量计算，从而深入了解支撑高级编程语言的底层机制。",
            "id": "3622117",
            "problem": "一台 $64$ 位机器使用向下增长的栈和基址加偏移量寻址方式，其中有效地址 (EA) 由基址寄存器加上一个有符号位移计算得出。应用程序二进制接口 (ABI) 规定了以下规则。在调用前，调用者将栈指针与 $16$ 字节的倍数对齐。在函数入口，硬件会压入一个大小为 $8$ 字节的返回地址。然后，被调用者的序言通过压栈来保存先前的帧指针（大小为 $8$ 字节），并将新的帧指针设置为当前的栈指针，因此在保存旧的帧指针后有 $FP = SP$。此后，被调用者通过减去一个必须是 $16$ 字节倍数的帧大小来为局部变量分配空间，以保持 $SP$ 在整个函数体中 $16$ 字节对齐。\n\n假设所有函数参数都由调用者在栈上传递，从右到左压栈。调用者以自然对齐方式布置参数：$4$ 字节的整数对齐到地址模 $4$ 为 $0$ 的位置，$8$ 字节的指针和 $8$ 字节的浮点数（双精度）对齐到地址模 $8$ 为 $0$ 的位置，大小为 $32$ 字节的向量对齐到地址模 $16$ 为 $0$ 的位置。调用者根据需要在参数之间插入填充以满足被调用者视角下每个参数的对齐要求，并且还会插入任何必要的整体填充，以确保在调用指令之前，栈指针与 $16$ 字节的倍数对齐。在被调用者内部，保存的帧指针位于地址 $FP + 0$，返回地址位于 $FP + 8$。\n\n考虑一个签名为 $f(\\text{double } p_1, \\text{int } p_2, \\text{void* } p_3)$ 的函数，它按此顺序声明了两个局部变量：一个大小为 $8$ 字节、对齐为 $8$ 字节的临时变量 $\\texttt{t}$，以及一个大小为 $32$ 字节、对齐为 $16$ 字节的向量 $\\texttt{v}$。局部变量按声明顺序从高地址到低地址（即从 $FP - 1$ 向下）分配，将每个变量放置在满足其对齐要求的下一个地址上，并插入对齐所需的任何填充。使用形式为 $EA = FP + d$ 的基址加偏移量寻址方式，其中正数 $d$ 用于访问参数，负数 $d$ 用于访问局部变量，请确定：\n\n- 常量 $k$，使得参数 $p_2$ 的有效地址为 $EA = FP + (+k)$。\n- 常量 $m$，使得局部变量 $\\texttt{v}$ 的基址的有效地址为 $EA = FP + (-m)$。\n\n以字节为单位，将 $k$ 和 $m$ 表示为精确整数。无需四舍五入。您的最终答案必须是按顺序 $k, m$ 排列在一个单行矩阵中的两个常量。",
            "solution": "该问题是有效的，因为它科学地基于计算机体系结构的原理，特别是栈帧布局和寻址模式。它问题明确、客观且内部一致，提供了推导内存布局所需的所有信息。\n\n解决方案需要确定一个参数和一个局部变量相对于帧指针（$FP$）的偏移量。这涉及根据所提供的应用程序二进制接口（ABI）规则，一步步地构建栈帧。\n\n首先，我们确定由调用者准备的栈上参数的布局。函数签名为 $f(\\text{double } p_1, \\text{int } p_2, \\text{void* } p_3)$。参数以从右到左的顺序被压入栈中。栈向下增长（朝向更低的地址）。在 `call` 指令执行前，栈指针（$SP$）必须与一个 $16$ 字节的边界对齐。我们将这个栈指针值表示为 $SP_{pre-call}$。参数被放置在高于或等于 $SP_{pre-call}$ 的地址上。\n\n1.  **参数布局（由调用者完成）：**\n    调用者依次压入 $p_3$、$p_2$、$p_1$。我们确定它们相对于 $SP_{pre-call}$ 的位置，确保每个参数的自然对齐。\n    -   参数 $p_1$ 是一个 `double`（大小 $8$ 字节，对齐 $8$ 字节）。它是最后一个被压入栈的，所以它位于参数块的顶部。它的基址将是 $SP_{pre-call}$。ABI 规则规定 $SP_{pre-call}$ 与 $16$ 字节边界对齐，因此 $SP_{pre-call} \\equiv 0 \\pmod{16}$。这个地址也是 $8$ 的倍数，所以 $p_1$ 的对齐要求得到满足。$p_1$ 占据内存范围 $[SP_{pre-call}, SP_{pre-call} + 7]$。\n    -   参数 $p_2$ 是一个 `int`（大小 $4$ 字节，对齐 $4$ 字节）。它在 $p_1$ 之前被压入栈，因此位于更高的地址。下一个可用地址是 $SP_{pre-call} + 8$。由于 $SP_{pre-call}$ 是 $16$ 的倍数，所以 $SP_{pre-call} + 8$ 是 $8$ 的倍数，因此也是 $4$ 的倍数。$p_2$ 的对齐要求得到满足。$p_2$ 占据内存范围 $[SP_{pre-call} + 8, SP_{pre-call} + 11]$。\n    -   参数 $p_3$ 是一个 `void*`（大小 $8$ 字节，对齐 $8$ 字节）。它在 $p_2$ 之前被压入栈。下一个可用地址是 $SP_{pre-call} + 12$。这个地址不是 $8$ 的倍数。为了满足对齐要求，调用者必须插入填充。下一个是 $8$ 的倍数的更高地址是 $SP_{pre-call} + 16$。因此，在 $[SP_{pre-call} + 12, SP_{pre-call} + 15]$ 处插入了 $4$ 字节的填充。$p_3$ 被放置在地址 $SP_{pre-call} + 16$。它占据内存范围 $[SP_{pre-call} + 16, SP_{pre-call} + 23]$。\n\n参数的栈布局，从低地址到高地址依次是：$p_1$、$p_2$、填充、$p_3$。\n\n2.  **帧指针设置（由被调用者完成）：**\n    -   当 $SP = SP_{pre-call}$ 时执行 `call` 指令。它将 $8$ 字节的返回地址压入栈中。栈指针变为 $SP = SP_{pre-call} - 8$。\n    -   被调用者的序言首先通过压栈来保存旧的帧指针。这又占用了 $8$ 字节。栈指针变为 $SP = (SP_{pre-call} - 8) - 8 = SP_{pre-call} - 16$。\n    -   然后被调用者将新的帧指针设置为当前的栈指针：$FP = SP = SP_{pre-call} - 16$。\n    -   由此，我们建立了新帧指针和调用前栈指针之间的关键关系：$SP_{pre-call} = FP + 16$。\n    -   作为检查，保存的帧指针位于地址 $FP$，返回地址位于 $FP+8$。这与问题描述相符。\n\n3.  **确定参数 $p_2$ 的偏移量 $k$：**\n    $p_2$ 的地址是 $EA(p_2) = SP_{pre-call} + 8$。\n    代入 $SP_{pre-call}$ 的表达式：\n    $$EA(p_2) = (FP + 16) + 8 = FP + 24$$\n    问题陈述为 $EA(p_2) = FP + k$。因此，$k = 24$。\n\n4.  **局部变量布局（由被调用者完成）：**\n    局部变量在栈上帧指针下方（地址小于 $FP$）分配。它们按声明顺序分配：`t`，然后是 `v`。分配从高地址到低地址进行，从紧邻 $FP$ 下方开始。我们知道 $FP$ 是 $16$ 的倍数，因为 $FP = SP_{pre-call} - 16$ 并且 $SP_{pre-call}$ 是 $16$ 的倍数。\n\n    -   局部变量 `t`（大小 $8$ 字节，对齐 $8$ 字节）：\n        `t` 的区域从满足其对齐要求的 $FP$ 下方的最高可能地址开始。基址 $A_t$ 必须是 $8$ 的倍数。内存块是 $[A_t, A_t+7]$，并且它必须完全在 $FP$ 以下，所以 $A_t+7  FP$，这意味着 $A_t \\le FP-8$。由于 $FP$ 是 $16$ 的倍数，$FP-8$ 是 $8$ 的倍数。$A_t$ 的最高地址（最接近 $FP$）选择是 $FP-8$。因此，`t` 被分配在 $EA(t) = FP - 8$。它占据 $[FP-8, FP-1]$。\n\n    -   局部变量 `v`（大小 $32$ 字节，对齐 $16$ 字节）：\n        `v` 必须分配在 `t` 的下方。可用的内存地址小于 $FP-8$。`v` 的基址 $A_v$ 必须是 $16$ 的倍数。内存块是 $[A_v, A_v+31]$，并且它必须完全在 `t` 的区域下方，所以 $A_v+31  FP-8$，简化为 $A_v \\le FP-40$。\n        我们需要找到小于或等于 $FP-40$ 的最大的 $16$ 的倍数。由于 $FP$ 是 $16$ 的倍数，设 $FP = 16N$（其中 $N$ 为某个整数）。我们需要 $A_v \\le 16N - 40$。$FP$ 下方的 $16$ 的倍数是 $FP-16$、$FP-32$、$FP-48$ 等。\n        -   $FP-16 \\le FP-40$ 吗？不是。\n        -   $FP-32 \\le FP-40$ 吗？不是。\n        -   $FP-48 \\le FP-40$ 吗？是的。\n        因此，`v` 的最高可能的对齐基址是 $FP-48$。\n        所以，`v` 被分配在 $EA(v) = FP - 48$。\n\n5.  **确定局部变量 `v` 的偏移量 $m$：**\n    `v` 的基址是 $EA(v) = FP - 48$。\n    问题陈述为 $EA(v) = FP + (-m) = FP - m$。因此，$m = 48$。\n\n6.  **最终 ABI 一致性检查：**\n    为局部变量分配的总空间从 `v` 的基址（$FP-48$）延伸到 `t` 的顶部（$FP-1$）。需要从 SP 中减去的总大小是从 $FP$ 向下到新的 $SP$，新的 $SP$ 将位于整个局部变量区域的基址。新的 $SP$ 将是 $FP-48$。减去的量是 $48$ 字节。ABI 要求此帧大小是 $16$ 的倍数。由于 $48 = 3 \\times 16$，此条件得到满足。新的栈指针 $SP_{new} = FP - 48$ 也是 $16$ 字节对齐的，因为 $FP$ 是。所有规则都得到了一致的满足。\n\n值为 $k=24$ 和 $m=48$。",
            "answer": "$$\\boxed{\\begin{pmatrix} 24  48 \\end{pmatrix}}$$"
        }
    ]
}