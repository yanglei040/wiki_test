{
    "hands_on_practices": [
        {
            "introduction": "Designing an Instruction Set Architecture (ISA) is an exercise in balancing competing needs within a fixed bit budget. This practice explores the fundamental trade-off between operand complexity and the size of the instruction set itself. By defining a hypothetical instruction format, you will calculate the available opcode space, providing a tangible understanding of how decisions about register counts and immediate sizes directly constrain the number of unique operations a processor can support .",
            "id": "3650922",
            "problem": "You are designing an Instruction Set Architecture (ISA) for arithmetic instructions. All arithmetic operations must use a three-address form: a destination register and two source operands. The machine has a fixed instruction length of $32$ bits, and a uniform register width of $w$ bits per register. The ISA must support $R$ architectural registers. The arithmetic class must encode both the register-register and register-immediate variants within the same fixed-width format, where the immediate is $k$ bits wide and is available when selected. The encoding you propose must contain, within the $32$-bit instruction word, fields for the destination register, two source registers, a $k$-bit immediate field, and a one-bit selector that specifies whether the second source operand is the register field or the immediate field. The remainder of the instruction word is the opcode field, which identifies the specific arithmetic operation.\n\nStarting from the foundational facts about binary representations and information capacity, and using only those facts and core definitions, derive the analytic expression for the maximum number of distinct opcode values that can be supported by this encoding in terms of $R$ and $k$. Assume the register identifiers are uniformly encoded and the immediate width $k$ satisfies $k \\leq w$ so that it is meaningful to use as an operand. Express your final answer as a single closed-form expression in terms of $R$ and $k$. No rounding is required, and no units are involved.",
            "solution": "The problem requires us to find the maximum number of distinct opcodes that can be supported by a specific instruction encoding. The foundational principle is that a field of $n$ bits has the information capacity to represent $2^n$ distinct values. The total number of bits in an instruction is fixed at $32$. The number of bits available for the opcode field is determined by subtracting the number of bits consumed by all other specified fields from the total instruction length.\n\nFirst, we determine the number of bits required to specify a register. The machine has $R$ architectural registers. To uniquely identify one of these $R$ registers using a uniform binary encoding, we need a number of bits, let's call it $b_{reg}$, equal to the smallest integer that is not less than $\\log_2(R)$. This is mathematically expressed using the ceiling function:\n$$b_{reg} = \\lceil \\log_2(R) \\rceil$$\nFor example, if $R=32$, then $\\log_2(32) = 5$, so $b_{reg}=5$ bits are needed. If $R=30$, $\\log_2(30) \\approx 4.91$, so we would need $\\lceil 4.91 \\rceil = 5$ bits.\n\nThe instruction format is a three-address form and must contain fields for one destination register and two source registers. Therefore, the total number of bits allocated to specifying registers is:\n$$B_{registers} = 3 \\times b_{reg} = 3 \\lceil \\log_2(R) \\rceil$$\n\nNext, the problem states that the instruction format must also contain a dedicated field for a k-bit immediate value and a 1-bit selector field. The number of bits for these fields are:\n$$B_{immediate} = k$$\n$$B_{selector} = 1$$\n\nThe problem explicitly states that the instruction word contains fields for the destination register, two source registers, the k-bit immediate, and the selector. This means we sum the bit-widths of all these separate fields to find the total number of bits consumed by non-opcode information. Let $B_{non-opcode}$ be this total.\n$$B_{non-opcode} = B_{registers} + B_{immediate} + B_{selector}$$\n$$B_{non-opcode} = 3 \\lceil \\log_2(R) \\rceil + k + 1$$\n\nThe total length of the instruction is given as $32$ bits. The portion of the instruction word not used by the fields above is designated as the opcode field. Let the number of bits in the opcode field be $B_{opcode}$. This is calculated as:\n$$B_{opcode} = 32 - B_{non-opcode}$$\nSubstituting the expression for $B_{non-opcode}$:\n$$B_{opcode} = 32 - (3 \\lceil \\log_2(R) \\rceil + k + 1)$$\n$$B_{opcode} = 31 - k - 3 \\lceil \\log_2(R) \\rceil$$\n\nFinally, the maximum number of distinct opcode values, let's call this $N_{opcodes}$, that can be encoded in the $B_{opcode}$-bit field is $2$ raised to the power of $B_{opcode}$:\n$$N_{opcodes} = 2^{B_{opcode}}$$\n$$N_{opcodes} = 2^{31 - k - 3 \\lceil \\log_2(R) \\rceil}$$\n\nThis expression gives the maximum number of distinct operations that can be specified for the arithmetic instruction class as a function of the number of registers $R$ and the immediate field width $k$. The constraint $k \\le w$ ensures that the immediate value is compatible with the datapath width but does not alter the derivation for the instruction encoding itself. The variable $w$ does not appear in the final expression, as the problem is one of information capacity within the instruction word, not datapath functionality.",
            "answer": "$$\\boxed{2^{31 - k - 3 \\lceil \\log_2(R) \\rceil}}$$"
        },
        {
            "introduction": "After understanding the high-level trade-offs in opcode space, the next step is to master the concrete process of instruction encoding. This exercise tasks you with translating a symbolic instruction, complete with register names and immediate values, into its final 32-bit binary representation according to a detailed specification . Engaging with this process demystifies how assembly language maps to machine code and reinforces key concepts like bit-field manipulation and two's complement representation.",
            "id": "3650981",
            "problem": "You are designing a new complex addressing instruction type for a hypothetical fixed-width machine model in computer organization and architecture. The instruction, called FADDR (fused address), computes an effective address according to the semantics\n$$\n\\text{addr} \\leftarrow \\text{base} + \\text{index} \\times \\text{scale} + \\text{offset}.\n$$\nAssume a $32$-bit fixed-length encoding with the following field layout from most significant bit to least significant bit:\n- Bits $[31:26]$: opcode (unsigned, $6$ bits).\n- Bits $[25:23]$: destination register $\\text{rd}$ (unsigned, $3$ bits).\n- Bits $[22:20]$: base register $\\text{rb}$ (unsigned, $3$ bits).\n- Bits $[19:17]$: index register $\\text{ri}$ (unsigned, $3$ bits).\n- Bits $[16:15]$: scale code $\\text{sc}$ (unsigned, $2$ bits).\n- Bits $[14:0]$: offset immediate $\\text{off}$ (signed two’s-complement, $15$ bits).\n\nUse the following architectural conventions and encodings:\n- General-purpose registers are $\\text{R}0, \\text{R}1, \\dots, \\text{R}7$, encoded by their index in binary (for example, $\\text{R}3$ encodes as $011$).\n- The FADDR instruction’s opcode is the unsigned $6$-bit value $100101_2$.\n- The scale factor is restricted to $\\{1, 2, 4, 8\\}$ and encoded by the $2$-bit scale code $\\text{sc}$ according to the mapping $\\{1 \\mapsto 00_2,\\; 2 \\mapsto 01_2,\\; 4 \\mapsto 10_2,\\; 8 \\mapsto 11_2\\}$.\n- The concatenation of fields into the $32$-bit word is interpreted as an unsigned integer in base two (big-endian bit numbering as specified above).\n\nFor a single FADDR instruction instance with $\\text{rd} = \\text{R}3$, $\\text{rb} = \\text{R}5$, $\\text{ri} = \\text{R}2$, and $\\text{off} = 20$, compute the $32$-bit unsigned integer encoding for each scale value in $\\{1, 2, 4, 8\\}$.\n\nState any assumptions you make about two’s-complement representation and justify them from first principles. Express your final encodings as unsigned decimal integers, in the order of scales $1, 2, 4, 8$. No rounding is required, and no units are to be included in the answer.",
            "solution": "The task is to assemble a 32-bit binary word by concatenating the binary representations of its constituent fields, as defined in the problem statement, and then to interpret this binary word as an unsigned integer. The bit fields are arranged from most significant bit (MSB) to least significant bit (LSB) as follows:\n- `opcode`: Bits $[31:26]$ (6 bits)\n- `rd`: Bits $[25:23]$ (3 bits)\n- `rb`: Bits $[22:20]$ (3 bits)\n- `ri`: Bits $[19:17]$ (3 bits)\n- `sc`: Bits $[16:15]$ (2 bits)\n- `off`: Bits $[14:0]$ (15 bits)\n\nWe will first determine the binary encoding for each field based on the provided data.\n\n**1. Field Encodings**\n\n*   **Opcode field (`opcode`)**: The problem specifies the opcode for the `FADDR` instruction is the unsigned 6-bit value $100101_2$.\n    $$ \\text{opcode} = 100101_2 $$\n\n*   **Destination Register field (`rd`)**: The destination register is `R3`. General-purpose registers `R0` through `R7` are encoded by their index. Thus, `R3` corresponds to the integer $3$. The 3-bit unsigned binary representation of $3$ is $011_2$.\n    $$ \\text{rd} = 011_2 $$\n\n*   **Base Register field (`rb`)**: The base register is `R5`. The index is $5$, which has a 3-bit unsigned binary representation of $101_2$.\n    $$ \\text{rb} = 101_2 $$\n\n*   **Index Register field (`ri`)**: The index register is `R2`. The index is $2$, which has a 3-bit unsigned binary representation of $010_2$.\n    $$ \\text{ri} = 010_2 $$\n\n*   **Offset Immediate field (`off`)**: The offset is given as the decimal value $20$. This must be converted to a 15-bit signed two's-complement representation.\n    As requested, we justify the representation from first principles. An $N$-bit two's-complement system represents integers in the range $[-2^{N-1}, 2^{N-1}-1]$. For a non-negative integer $x$ where $0 \\le x < 2^{N-1}$, its representation is its standard binary equivalent, zero-padded to $N$ bits.\n    In this case, $N=15$, so the range is $[-2^{14}, 2^{14}-1]$, which is $[-16384, 16383]$. The value `off` $= 20$ is a non-negative integer within this range.\n    The standard binary representation of $20$ is $10100_2$ (since $20 = 16 + 4 = 1 \\cdot 2^4 + 0 \\cdot 2^3 + 1 \\cdot 2^2 + 0 \\cdot 2^1 + 0 \\cdot 2^0$).\n    Padding this to $15$ bits with leading zeros gives:\n    $$ \\text{off} = 00000000010100_2 $$\n\n*   **Scale Code field (`sc`)**: This 2-bit field's value depends on the scale factor, which takes on the four values $\\{1, 2, 4, 8\\}$. The mappings are provided:\n    - For `scale` $= 1$, `sc` $= 00_2$.\n    - For `scale` $= 2$, `sc` $= 01_2$.\n    - For `scale` $= 4$, `sc` $= 10_2$.\n    - For `scale` $= 8$, `sc` $= 11_2$.\n\n**2. Assembling the Instruction Word**\n\nThe 32-bit instruction word is formed by concatenating these fields:\n$$ \\text{Instruction} = \\text{opcode} \\,|\\, \\text{rd} \\,|\\, \\text{rb} \\,|\\, \\text{ri} \\,|\\, \\text{sc} \\,|\\, \\text{off} $$\nThe problem states that this concatenated word is interpreted as an unsigned integer. This value, $V$, can be calculated using the formula:\n$$ V = (\\text{opcode_val} \\times 2^{26}) + (\\text{rd_val} \\times 2^{23}) + (\\text{rb_val} \\times 2^{20}) + (\\text{ri_val} \\times 2^{17}) + (\\text{sc_val} \\times 2^{15}) + \\text{off_val} $$\nwhere `_val` denotes the decimal value of the corresponding binary field.\n\nThe decimal values for the fixed fields are:\n- $\\text{opcode_val} = 100101_2 = 37_{10}$\n- $\\text{rd_val} = 011_2 = 3_{10}$\n- $\\text{rb_val} = 101_2 = 5_{10}$\n- $\\text{ri_val} = 010_2 = 2_{10}$\n- $\\text{off_val} = 20_{10}$\n\nLet's compute the part of the value that is constant across all four cases, let's call it $V_{\\text{base}}$:\n$$ V_{\\text{base}} = (\\text{opcode_val} \\times 2^{26}) + (\\text{rd_val} \\times 2^{23}) + (\\text{rb_val} \\times 2^{20}) + (\\text{ri_val} \\times 2^{17}) + \\text{off_val} $$\n$$ V_{\\text{base}} = (37 \\times 67108864) + (3 \\times 8388608) + (5 \\times 1048576) + (2 \\times 131072) + 20 $$\n$$ V_{\\text{base}} = 2483027968 + 25165824 + 5242880 + 262144 + 20 $$\n$$ V_{\\text{base}} = 2513698836 $$\nThe total value for each instruction is $V = V_{\\text{base}} + (\\text{sc_val} \\times 2^{15})$. Since the `sc` field is at bit positions $[16:15]$, its value is multiplied by $2^{15} = 32768$.\n\nNow we compute the final encoding for each scale value.\n\n*   **Case 1: `scale` = 1**\n    The scale code is `sc` $= 00_2$, so $\\text{sc_val} = 0$.\n    $$ V_1 = V_{\\text{base}} + (0 \\times 32768) = 2513698836 $$\n    The binary word is: $100101 \\,|\\, 011 \\,|\\, 101 \\,|\\, 010 \\,|\\, 00 \\,|\\, 00000000010100_2$.\n\n*   **Case 2: `scale` = 2**\n    The scale code is `sc` $= 01_2$, so $\\text{sc_val} = 1$.\n    $$ V_2 = V_{\\text{base}} + (1 \\times 32768) = 2513698836 + 32768 = 2513731604 $$\n    The binary word is: $100101 \\,|\\, 011 \\,|\\, 101 \\,|\\, 010 \\,|\\, 01 \\,|\\, 00000000010100_2$.\n\n*   **Case 3: `scale` = 4**\n    The scale code is `sc` $= 10_2$, so $\\text{sc_val} = 2$.\n    $$ V_4 = V_{\\text{base}} + (2 \\times 32768) = 2513698836 + 65536 = 2513764372 $$\n    The binary word is: $100101 \\,|\\, 011 \\,|\\, 101 \\,|\\, 010 \\,|\\, 10 \\,|\\, 00000000010100_2$.\n\n*   **Case 4: `scale` = 8**\n    The scale code is `sc` $= 11_2$, so $\\text{sc_val} = 3$.\n    $$ V_8 = V_{\\text{base}} + (3 \\times 32768) = 2513698836 + 98304 = 2513797140 $$\n    The binary word is: $100101 \\,|\\, 011 \\,|\\, 101 \\,|\\, 010 \\,|\\, 11 \\,|\\, 00000000010100_2$.\n\nThe four resulting unsigned decimal integer encodings, in order of scales $1, 2, 4, 8$, are $2513698836$, $2513731604$, $2513764372$, and $2513797140$.",
            "answer": "$$ \\boxed{ \\begin{pmatrix} 2513698836 & 2513731604 & 2513764372 & 2513797140 \\end{pmatrix} } $$"
        },
        {
            "introduction": "An instruction's design extends beyond its encoding; it deeply influences how it executes within a processor's pipeline, impacting overall performance. This practice examines the pipeline dynamics of an integer-to-floating-point conversion instruction, forcing you to analyze potential data and structural hazards . By considering interactions with control registers and shared hardware resources, you will learn why architects must anticipate and manage pipeline stalls to build efficient processors.",
            "id": "3650909",
            "problem": "A Reduced Instruction Set Computer (RISC)-like processor implements an integer-to-floating-point conversion instruction type that must support rounding mode selection and operate correctly in a classic five-stage pipeline: Instruction Fetch (IF), Instruction Decode (ID), Execute (EX), Memory (MEM), Write Back (WB). The processor has a single, shared Floating-Point Unit (FPU) that performs floating-point operations and conversions. The conversion of a signed $32$-bit integer to a binary $32$-bit floating-point value follows the Institute of Electrical and Electronics Engineers (IEEE) $754$ semantics, including rounding and exception flagging. The instruction under design is named $I2F.RM$, with operands $f_{d}$ (destination floating-point register) and $r_{s}$ (source integer register), and a $3$-bit rounding-mode field $RM$ encoded in the instruction.\n\nAssume the following foundational facts and definitions:\n- The Institute of Electrical and Electronics Engineers (IEEE) $754$ rounding modes include: round to nearest, ties to even; round toward zero; round toward positive infinity; round toward negative infinity; and possibly round to nearest, ties away from zero. Rounding determines how an exact real result is mapped to a finite-precision representable number. Conversion from a signed $32$-bit integer to a binary $32$-bit floating-point number is always within representable range, but may be inexact if the integer magnitude exceeds the exact-integer range of the floating-point format. Inexact conversion sets the inexact flag in the Floating-Point Control and Status Register (FCSR).\n- The Floating-Point Control and Status Register ($FCSR$) contains a field $FCSR.RM$ that holds the current dynamic rounding mode and sticky exception flags. The system provides an instruction $WCSR$ that writes $FCSR$; such a write takes architectural effect when it reaches the Write Back stage.\n- Register operands (including special control registers like $FCSR$) are read during Instruction Decode to generate control signals for Execute. There are no bypass paths from later pipeline stages back to Instruction Decode for $FCSR$ writes. The $I2F.RM$ instruction will read $FCSR.RM$ only if needed to determine the rounding mode for its operation.\n- The FPU is a shared structural resource used by floating-point operations and by $I2F.RM$. The integer-to-floating-point conversion occupies the Execute stage for $2$ cycles. If the FPU is busy when $I2F.RM$ reaches Execute, the pipeline must stall in Execute until the FPU becomes available. Exception flags resulting from the operation are written into $FCSR$ at Write Back.\n\nDesign goal: define the semantics of $I2F.RM$ so that the rounding mode is either taken from the per-instruction $RM$ field or, if so indicated, taken dynamically from $FCSR.RM$, and characterize precisely where pipeline stalls must occur due to data and structural hazards under the above assumptions.\n\nWhich option correctly specifies the semantics of $I2F.RM$ and the resulting stall behavior?\n\nA. $I2F.RM\\ f_{d}, r_{s}, RM$ converts the signed integer in $r_{s}$ to a binary $32$-bit floating-point value in $f_{d}$. If $RM \\neq 111$, the instruction uses the rounding mode encoded by $RM$ and does not read $FCSR.RM$. If $RM = 111$, the instruction reads $FCSR.RM$ during Instruction Decode and uses that mode. A preceding $WCSR$ that modifies $FCSR.RM$ creates a read-after-write hazard because $WCSR$ takes effect at Write Back and there is no bypass to Instruction Decode; therefore, $I2F.RM$ must stall until the earlier $WCSR$ reaches Write Back when $RM = 111$. The conversion occupies the Execute stage for $2$ cycles and stalls there if the FPU is busy. Any inexact exception is recorded by setting the inexact flag in $FCSR$ at Write Back.\n\nB. $I2F.RM\\ f_{d}, r_{s}, RM$ always reads $FCSR.RM$ and logically combines it with the encoded $RM$ at the Memory stage; if both specify a mode, the dynamic $FCSR.RM$ takes precedence. Because the combination occurs at Memory, a preceding $WCSR$ never creates a hazard for $I2F.RM$, and the pipeline may forward the $FCSR$ value from Execute to Memory. The conversion does not use the FPU and therefore never stalls in Execute.\n\nC. $I2F.RM\\ f_{d}, r_{s}, RM$ uses the encoded $RM$ only as a hint; the actual rounding mode is selected in Execute by reading $FCSR.RM$ after any preceding $WCSR$ is decoded. Since rounding mode is a control property, the pipeline must flush all earlier stages on any $WCSR$ to guarantee precise control, eliminating data hazards. Because the flush enforces ordering, $I2F.RM$ experiences no stalls due to $FCSR$ access and never waits for the FPU, as conversion is assumed single-cycle.\n\nD. $I2F.RM\\ f_{d}, r_{s}, RM$ always uses the encoded $RM$ to select a rounding mode, but the current $FCSR.RM$ overrides it if different, with the override determined at Instruction Decode and possibly re-evaluated at Write Back. If a preceding $WCSR$ writes a new rounding mode, the conversion for an in-flight $I2F.RM$ is recomputed at Memory using the new mode, so no stalls are necessary. Large-magnitude integers may overflow to infinity on conversion; such overflow is detected at Memory and raises an exception there, possibly stalling Memory for flag updates.",
            "solution": "To determine the correct option, we must analyze the instruction's behavior within the specified five-stage pipeline, considering potential data and structural hazards based on the given architectural constraints.\n\n1.  **Rounding Mode Selection**: The design goal is to allow the rounding mode to be specified either by the instruction's 3-bit $RM$ field or by the dynamic $FCSR.RM$ register. A logical design pattern is to use most of the $RM$ codes for direct specification and reserve one special code (e.g., $111_2$) to signify \"use the mode from $FCSR.RM$\". This satisfies the design goal. When the special code is used, the instruction must read $FCSR.RM$, creating a data dependency.\n\n2.  **Data Hazard Analysis (RAW on $FCSR$)**: A Read-After-Write (RAW) data hazard occurs if an instruction reads a register before a preceding instruction has finished writing to it. Consider the sequence:\n    1.  `WCSR ...` (writes to $FCSR$)\n    2.  `I2F.RM ..., RM=[sentinel]` (reads from $FCSR.RM$)\n    The `I2F.RM` instruction reads registers in its ID stage. The `WCSR` instruction writes to the architectural $FCSR$ register in its WB stage. The problem explicitly states there are \"no bypass paths from later pipeline stages back to Instruction Decode for $FCSR$ writes\". Therefore, to get the correct, updated value, the `I2F.RM` instruction must stall in its ID stage until the `WCSR` instruction has completed its WB stage.\n\n3.  **Structural Hazard Analysis (on FPU)**: The problem states there is a \"single, shared Floating-Point Unit (FPU)\" and `I2F.RM` occupies it for $2$ cycles. A structural hazard occurs if two instructions need the same hardware resource (the FPU) in the same clock cycle. If a preceding instruction is using the FPU when `I2F.RM` reaches the EX stage, `I2F.RM` must stall in the EX stage until the FPU is free.\n\n4.  **Exception Flagging**: The problem states that exception flags are written to the $FCSR$ at the WB stage. This is standard practice for maintaining precise exceptions, ensuring that architectural state is updated in program order.\n\n### Option-by-Option Analysis\n\n**A. $I2F.RM\\ f_{d}, r_{s}, RM$ converts the signed integer in $r_{s}$ to a binary $32$-bit floating-point value in $f_{d}$. If $RM \\neq 111$, the instruction uses the rounding mode encoded by $RM$ and does not read $FCSR.RM$. If $RM = 111$, the instruction reads $FCSR.RM$ during Instruction Decode and uses that mode. A preceding $WCSR$ that modifies $FCSR.RM$ creates a read-after-write hazard because $WCSR$ takes effect at Write Back and there is no bypass to Instruction Decode; therefore, $I2F.RM$ must stall until the earlier $WCSR$ reaches Write Back when $RM = 111$. The conversion occupies the Execute stage for $2$ cycles and stalls there if the FPU is busy. Any inexact exception is recorded by setting the inexact flag in $FCSR$ at Write Back.**\n- This option correctly describes the dual-source rounding mode selection. It correctly identifies the RAW hazard on $FCSR$, the resulting stall due to the lack of bypass, the structural hazard on the FPU, and the standard exception-flagging mechanism. All parts of this option are consistent with the problem givens and standard pipeline design principles. **This option is correct.**\n\n**B. $I2F.RM\\ f_{d}, r_{s}, RM$ always reads $FCSR.RM$ and logically combines it with the encoded $RM$ at the Memory stage; if both specify a mode, the dynamic $FCSR.RM$ takes precedence. Because the combination occurs at Memory, a preceding $WCSR$ never creates a hazard for $I2F.RM$, and the pipeline may forward the $FCSR$ value from Execute to Memory. The conversion does not use the FPU and therefore never stalls in Execute.**\n- This option is flawed. The conversion occurs in the EX stage, so the rounding mode must be known then, not in the MEM stage. It also contradicts the explicit statement that the conversion *does* use the FPU and is subject to structural hazards.\n\n**C. $I2F.RM\\ f_{d}, r_{s}, RM$ uses the encoded $RM$ only as a hint; the actual rounding mode is selected in Execute by reading $FCSR.RM$ after any preceding $WCSR$ is decoded. Since rounding mode is a control property, the pipeline must flush all earlier stages on any $WCSR$ to guarantee precise control, eliminating data hazards. Because the flush enforces ordering, $I2F.RM$ experiences no stalls due to $FCSR$ access and never waits for the FPU, as conversion is assumed single-cycle.**\n- This option contains multiple contradictions with the givens. It incorrectly assumes a single-cycle conversion and no FPU stalls. A pipeline flush for every `WCSR` is an extremely inefficient implementation, and the problem asks to characterize stalls.\n\n**D. $I2F.RM\\ f_{d}, r_{s}, RM$ always uses the encoded $RM$ to select a rounding mode, but the current $FCSR.RM$ overrides it if different, with the override determined at Instruction Decode and possibly re-evaluated at Write Back. If a preceding $WCSR$ writes a new rounding mode, the conversion for an in-flight $I2F.RM$ is recomputed at Memory using the new mode, so no stalls are necessary. Large-magnitude integers may overflow to infinity on conversion; such overflow is detected at Memory and raises an exception there, possibly stalling Memory for flag updates.**\n- This option is incorrect. The re-computation logic is architecturally unsound without a second conversion unit in the MEM stage. Crucially, the statement \"Large-magnitude integers may overflow to infinity on conversion\" is factually wrong for a signed $32$-bit integer to a binary $32$-bit float conversion.",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}