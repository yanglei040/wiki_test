{
    "hands_on_practices": [
        {
            "introduction": "At the heart of a processor's Arithmetic Logic Unit (ALU), complex operations are often constructed from simpler, faster primitives. This practice demystifies integer multiplication by revealing its fundamental connection to the binary representation of numbers. You will implement a squaring algorithm using only shift and add operations, providing a clear window into how hardware can perform multiplication without a dedicated multiplier circuit. ",
            "id": "3620502",
            "problem": "Consider a non-negative integer $x$ represented in fixed-width binary as $w$ bits with $0 \\le x  2^w$. In the standard binary expansion, $x$ can be written as $x = \\sum_{i=0}^{w-1} b_i \\cdot 2^i$ where each coefficient $b_i \\in \\{0,1\\}$ is the bit at position $i$. The logical left shift by $i$ bits, written as $x \\ll i$, corresponds to multiplying $x$ by $2^i$ when the result is representable in the destination type. Using only integer addition and bitwise operations, derive an algorithm from these base definitions that computes the square $x^2$ as a sum of selected shifted copies of $x$ determined by its set bits. Then implement this algorithm in a program that avoids the multiplication operator for the squaring computation. To ensure the arithmetic stays within representable ranges during accumulation, use an accumulator of width $2w$ bits to hold $x^2$.\n\nYour program must:\n- Treat $x$ as an unsigned integer with $w = 32$.\n- Compute $x^2$ by summing $x \\ll i$ only for those indices $i$ where the bit $b_i$ in $x$ is $1$; do not use the multiplication operator for this computation.\n- Validate the computed $x^2$ against a reference $x \\cdot x$ computed in a $2w$-bit unsigned integer type.\n- Produce, for each test case, a boolean result $r \\in \\{0,1\\}$ where $r = 1$ if the validation passes and $r = 0$ otherwise.\n\nTest Suite:\nUse the following $10$ values of $x$ (each fits in $32$ bits) to exercise sparse and dense bit patterns, boundary cases, and mixed patterns:\n- Sparse and boundary cases: $x = 0$, $x = 1$, $x = 2^{31}$, $x = 2^{16} + 1$.\n- Dense cases: $x = 2^{32} - 1$, $x = 2^{32} - 2$, $x = 2^{31} - 1$.\n- Mixed patterns: $x = 305419896$, $x = 2863311530$, $x = 1431655765$.\n\nFormally, the test values are:\n- $x_1 = 0$\n- $x_2 = 1$\n- $x_3 = 2^{31}$\n- $x_4 = 2^{16} + 1$\n- $x_5 = 2^{32} - 1$\n- $x_6 = 2^{32} - 2$\n- $x_7 = 2^{31} - 1$\n- $x_8 = 305419896$\n- $x_9 = 2863311530$\n- $x_{10} = 1431655765$\n\nFinal Output Format:\nYour program should produce a single line of output containing the $10$ boolean validation results in order, as a comma-separated list enclosed in square brackets (e.g., \"[r1,r2,r3,r4,r5,r6,r7,r8,r9,r10]\"). Each $r_k$ must be either $0$ or $1$.",
            "solution": "The problem requires the computation of the square of a non-negative integer, $x^2$, using only integer addition and bitwise operations, based on the binary representation of $x$. The fundamental principle is to express multiplication as a series of shifts and additions, a method commonly known as the \"shift-and-add\" algorithm.\n\nLet the integer $x$ be represented by $w$ bits, where $0 \\le x  2^w$. Its standard binary expansion is given by:\n$$x = \\sum_{i=0}^{w-1} b_i \\cdot 2^i$$\nwhere each coefficient $b_i \\in \\{0,1\\}$ represents the bit at position $i$.\n\nThe square of $x$, denoted $x^2$, is the product of $x$ with itself. We can substitute the binary expansion for one of the factors:\n$$x^2 = x \\cdot x = x \\cdot \\left(\\sum_{i=0}^{w-1} b_i \\cdot 2^i\\right)$$\n\nBy applying the distributive property of multiplication over addition, we expand the expression:\n$$x^2 = \\sum_{i=0}^{w-1} (x \\cdot b_i \\cdot 2^i)$$\n\nSince each bit $b_i$ can only be $0$ or $1$, the term $x \\cdot b_i \\cdot 2^i$ simplifies. If $b_i=0$, the term is $0$. If $b_i=1$, the term is $x \\cdot 2^i$. Consequently, the summation only needs to include terms for which the bit $b_i$ is $1$:\n$$x^2 = \\sum_{i \\text{ such that } b_i=1} (x \\cdot 2^i)$$\n\nThis mathematical formula provides the basis for our algorithm. In binary computer arithmetic, multiplying an integer by a power of two, $2^i$, is computationally equivalent to a logical left shift operation by $i$ positions, denoted as $x \\ll i$. This allows us to translate the formula directly into a sequence of computer instructions.\n\nThe algorithm to compute $x^2$ is as follows:\n1. Initialize an accumulator with a width of $2w$ bits to $0$. This width ensures that the sum does not overflow, as the maximum product of two $w$-bit numbers requires up to $2w$ bits. For $w=32$, a $64$-bit accumulator is used.\n2. Iterate through each bit position $i$ of the number $x$, from $i=0$ to $w-1$.\n3. For each position $i$, test if the bit $b_i$ is set to $1$. This can be done using a bitwise AND operation after a right shift: `(x >> i)  1`.\n4. If $b_i$ is $1$, compute the value of $x$ logically left-shifted by $i$ positions ($x \\ll i$). To prevent intermediate overflow during the shift itself, $x$ must be promoted to the $2w$-bit type of the accumulator before the shift operation.\n5. Add the result of the shift operation to the accumulator.\n6. After iterating through all $w$ bit positions, the accumulator will contain the final result, $x^2$.\n\nThis algorithm computes the square without using a multiplication operator, relying solely on bitwise shifts, bitwise ANDs, and additions, as required by the problem statement. The validation step involves comparing this result with the one obtained from a direct multiplication, using $64$-bit integer arithmetic for both computations to ensure correctness.",
            "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n#include stdio.h\n#include stdlib.h\n\n// A struct to hold the parameters for a single test case.\n// For this problem, the parameter is a single 32-bit unsigned integer x.\n// We use 'unsigned int' with the assumption it is 32 bits, a common standard.\ntypedef struct {\n    unsigned int x;\n} TestCase;\n\n/**\n * @brief Computes the square of a 32-bit unsigned integer using a shift-and-add algorithm.\n *\n * This function calculates x*x by summing shifted copies of x based on its set bits,\n * avoiding the use of the multiplication operator.\n *\n * @param x The 32-bit unsigned integer to be squared.\n * @return The 64-bit unsigned integer result of the squaring operation.\n */\nunsigned long long compute_square_shift_add(unsigned int x) {\n    // Use a 64-bit accumulator (2w bits) to prevent overflow.\n    unsigned long long accumulator = 0ULL;\n\n    // Iterate through all 32 bits of the input number x.\n    for (int i = 0; i  32; ++i) {\n        // Check if the i-th bit of x is 1.\n        if ((x  i)  1) {\n            // If the bit is set, add (x  i) to the accumulator.\n            // x is cast to 64 bits before the shift to ensure the shifted value\n            // does not overflow a 32-bit register before being added.\n            accumulator += (unsigned long long)x  i;\n        }\n    }\n    return accumulator;\n}\n\nint main(void) {\n    // Define the test cases from the problem statement. The 'U' suffix ensures\n    // the literals are treated as unsigned integers.\n    TestCase test_cases[] = {\n        {0U},           // x1 = 0\n        {1U},           // x2 = 1\n        {2147483648U},  // x3 = 2^31\n        {65537U},       // x4 = 2^16 + 1\n        {4294967295U},  // x5 = 2^32 - 1\n        {4294967294U},  // x6 = 2^32 - 2\n        {2147483647U},  // x7 = 2^31 - 1\n        {305419896U},   // x8\n        {2863311530U},  // x9\n        {1431655765U}   // x10\n    };\n\n    // Calculate the number of test cases.\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    int results[num_cases];\n\n    // Calculate the result for each test case.\n    for (int i = 0; i  num_cases; ++i) {\n        unsigned int x = test_cases[i].x;\n\n        // Compute the square using the required shift-and-add algorithm.\n        unsigned long long calculated_square = compute_square_shift_add(x);\n\n        // Compute the reference square using the built-in multiplication operator.\n        // Both operands are cast to 64-bit to ensure the multiplication is done\n        // in 64-bit arithmetic, matching the accumulator's width.\n        unsigned long long reference_square = (unsigned long long)x * x;\n\n        // Validate that the custom algorithm's result matches the reference.\n        // The result is 1 if they match (pass), and 0 otherwise (fail).\n        results[i] = (calculated_square == reference_square);\n    }\n\n    // Print the results in the EXACT REQUIRED format before the final return statement.\n    printf(\"[\");\n    for (int i = 0; i  num_cases; ++i) {\n        printf(\"%d\", results[i]);\n        if (i  num_cases - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\");\n\n    return EXIT_SUCCESS;\n}\n```"
        },
        {
            "introduction": "Instruction Set Architectures (ISAs) vary; some are rich with features, while others are minimal. This exercise tackles a scenario where a crucial instruction, the arithmetic right shift, is missing. You will derive a method to emulate its sign-preserving behavior using only logical shifts and bitwise operations, constructing a conditional mask that correctly handles sign extension for any signed integer.  This builds a deeper appreciation for how instruction sets can be synthesized from a core set of logical primitives.",
            "id": "3620381",
            "problem": "A $w$-bit two's complement machine lacks an arithmetic right shift instruction but supports a logical right shift, bitwise conjunction and disjunction, and two's complement negation, all operating modulo $2^{w}$ with results truncated to $w$ bits. Consider emulating an arithmetic right shift by $k$ positions using only these operations on a value $x$ via the expression\n$$\nY(x,k,w) \\;=\\; \\left(x \\gg_{\\mathrm{logic}} k\\right) \\;\\lor\\; \\left(\\,-\\left(\\left(x \\gg_{\\mathrm{logic}} (w-1)\\right) \\land 1\\right)\\; \\ll\\; (w-k)\\right),\n$$\nwhere $x$ is a $w$-bit word interpreted in two's complement, $\\gg_{\\mathrm{logic}}$ denotes logical right shift (zero fill), $\\ll$ denotes left shift (zero fill), $\\land$ denotes bitwise conjunction, $\\lor$ denotes bitwise disjunction, and unary $-$ denotes two's complement negation modulo $2^{w}$.\n\nUsing only fundamental definitions of two's complement representation, logical and arithmetic shifts, and bitwise operations, do the following:\n- Derive and justify from first principles that the term\n$$\nM(x,k,w) \\;=\\; \\left(\\,-\\left(\\left(x \\gg_{\\mathrm{logic}} (w-1)\\right) \\land 1\\right)\\right) \\ll (w-k)\n$$\nis a $w$-bit mask that equals $0$ when the sign bit of $x$ is $0$, and equals a mask of $k$ ones in the most significant $k$ bit positions when the sign bit of $x$ is $1$.\n- Conclude that $Y(x,k,w)$ equals the result of an arithmetic right shift of $x$ by $k$ positions for any $w$-bit two's complement input $x$ and integer $k$ with $0 \\le k  w$.\n\nThen, for a concrete instance with $w = 16$, $x$ equal to the two's complement encoding of $-10000$, and $k = 5$, compute the signed decimal value produced by $Y(x,k,w)$. Express your final result as a signed decimal integer.",
            "solution": "### Solution Derivation\n\nWe begin by stating the fundamental definitions required for the proof.\nA $w$-bit integer $x$, represented by the bit string $x_{w-1}x_{w-2}...x_0$, has the value $V(x) = -x_{w-1}2^{w-1} + \\sum_{i=0}^{w-2} x_i 2^i$ in two's complement. The bit $x_{w-1}$ is the sign bit; $x_{w-1}=0$ for non-negative numbers and $x_{w-1}=1$ for negative numbers.\n\nAn **arithmetic right shift** by $k$ positions, denoted $x \\gg_{\\mathrm{arith}} k$, shifts all bits to the right by $k$ positions. The $k$ most significant bits (MSBs) are filled with copies of the original sign bit, $x_{w-1}$. This operation is equivalent to integer division by $2^k$, rounding towards negative infinity: $\\lfloor V(x) / 2^k \\rfloor$.\n\nA **logical right shift** by $k$ positions, denoted $x \\gg_{\\mathrm{logic}} k$, also shifts all bits right by $k$ positions, but the $k$ MSBs are always filled with $0$.\n\nThe goal is to show that $Y(x,k,w) = (x \\gg_{\\mathrm{logic}} k) \\lor M(x,k,w)$ correctly emulates $x \\gg_{\\mathrm{arith}} k$. The term $x \\gg_{\\mathrm{logic}} k$ performs a shift that introduces zeros into the MSBs. The mask $M(x,k,w)$ is intended to correct these MSBs, changing them to $1$s if and only if the original number $x$ was negative.\n\n**Part 1: Analysis of the Mask Term $M(x,k,w)$**\n\nThe mask is defined as $M(x,k,w) = \\left(\\,-\\left(\\left(x \\gg_{\\mathrm{logic}} (w-1)\\right) \\land 1\\right)\\right) \\ll (w-k)$. Let's analyze this expression from the inside out.\n\n1.  **Isolating the sign bit:** The term $\\left(x \\gg_{\\mathrm{logic}} (w-1)\\right)$ shifts the $w$-bit word $x$ by $w-1$ positions to the right, with zero-filling. This moves the original sign bit, $x_{w-1}$, to the least significant bit (LSB) position (bit $0$). All other $w-1$ bits become $0$. The resulting $w$-bit word is $00...0x_{w-1}$.\n\n2.  **Converting to an integer $0$ or $1$:** The bitwise conjunction `... $\\land$ 1` is performed. The value $1$ as a $w$-bit word is $00...01$. The operation $(00...0x_{w-1}) \\land (00...01)$ results in the word $00...01$ if $x_{w-1}=1$, and the word $00...00$ if $x_{w-1}=0$. We can denote the integer value of this result as $S$, where $S=x_{w-1}$.\n\n3.  **Two's Complement Negation:** The expression now becomes $-S$.\n    - **Case A: $x$ is non-negative.** The sign bit $x_{w-1}=0$, so $S=0$. The two's complement of $0$ is $0$. The resulting $w$-bit word is a sequence of all zeros: $00...0$.\n    - **Case B: $x$ is negative.** The sign bit $x_{w-1}=1$, so $S=1$. The two's complement of $1$ (represented as $00...01$) is found by inverting the bits ($11...10$) and adding $1$, which gives $11...11$. This is the $w$-bit representation of $-1$.\n\n4.  **Final Left Shift:** The result from the previous step is shifted left by $(w-k)$ positions: `... $\\ll (w-k)$`.\n    - **Case A (from above):** If the word is all zeros, shifting it left by any amount results in a word of all zeros. Thus, if $x$ is non-negative, $M(x,k,w)$ is the all-zero word.\n    - **Case B (from above):** If the word is all ones ($11...11$), shifting it left by $(w-k)$ positions causes the rightmost $(w-k)$ bits to be filled with zeros. The $k$ most significant bits are filled by the bits that were originally at positions $w-1, w-2, ..., k$. Since all bits of the source word are $1$, these $k$ MSBs all become $1$. The resulting mask is a word with its $k$ most significant bits equal to $1$ and its remaining $w-k$ bits equal to $0$.\n\nThis completes the derivation. $M(x,k,w)$ is a $w$-bit word that is $0$ if the sign bit of $x$ is $0$, and is a mask with $k$ ones in the MSB positions if the sign bit of $x$ is $1$.\n\n**Part 2: Proving Equivalence to Arithmetic Right Shift**\n\nNow we analyze $Y(x,k,w) = (x \\gg_{\\mathrm{logic}} k) \\lor M(x,k,w)$.\n\n- **Case 1: $x$ is non-negative.** The sign bit $x_{w-1}=0$.\n    - An arithmetic right shift $x \\gg_{\\mathrm{arith}} k$ would fill the $k$ MSBs with $0$.\n    - A logical right shift $x \\gg_{\\mathrm{logic}} k$ also fills the $k$ MSBs with $0$.\n    - As shown above, for non-negative $x$, the mask $M(x,k,w)$ is the all-zero word.\n    - Therefore, $Y(x,k,w) = (x \\gg_{\\mathrm{logic}} k) \\lor (\\text{all-zero word}) = (x \\gg_{\\mathrm{logic}} k)$.\n    - In this case, $Y(x,k,w)$ is identical to $x \\gg_{\\mathrm{arith}} k$.\n\n- **Case 2: $x$ is negative.** The sign bit $x_{w-1}=1$.\n    - An arithmetic right shift $x \\gg_{\\mathrm{arith}} k$ would shift the bits of $x$ right by $k$ and fill the $k$ MSBs with $1$.\n    - The term $x \\gg_{\\mathrm{logic}} k$ shifts the bits right but fills the $k$ MSBs with $0$.\n    - As shown above, for negative $x$, the mask $M(x,k,w)$ has its $k$ MSBs set to $1$ and its $w-k$ LSBs set to $0$.\n    - Let's perform the bitwise OR operation:\n        - For the $k$ most significant bit positions: The bits from $(x \\gg_{\\mathrm{logic}} k)$ are $0$. The bits from $M(x,k,w)$ are $1$. The result of the OR is $1$.\n        - For the $w-k$ least significant bit positions: The bits from $(x \\gg_{\\mathrm{logic}} k)$ contain the shifted content of $x$. The bits from $M(x,k,w)$ are $0$. The result of the OR preserves the bits from $(x \\gg_{\\mathrm{logic}} k)$.\n    - The final result has its $k$ MSBs set to $1$ and its $w-k$ LSBs correctly set from the shifted bits of $x$. This is exactly the definition of an arithmetic right shift for a negative number.\n    - In this case as well, $Y(x,k,w)$ is identical to $x \\gg_{\\mathrm{arith}} k$.\n\nSince the identity holds for both non-negative and negative numbers, we conclude that $Y(x,k,w)$ is a valid emulation of an arithmetic right shift of $x$ by $k$ positions for any $w$-bit input $x$ and $0 \\le k  w$.\n\n**Part 3: Concrete Calculation**\n\nWe are given $w=16$, $k=5$, and the input value is $-10000$. We need to compute the signed decimal value of $Y(x,k,w)$.\nFrom our proof, we know that this is equivalent to an arithmetic right shift, which corresponds to floor division.\n$$ Y(x,k,w) = \\left\\lfloor \\frac{-10000}{2^k} \\right\\rfloor $$\nWith $k=5$, we have $2^5 = 32$.\n$$ \\text{Value} = \\left\\lfloor \\frac{-10000}{32} \\right\\rfloor = \\lfloor -312.5 \\rfloor = -313 $$\nThe signed decimal value produced is $-313$.\n\nTo verify with bit-level operations:\n1.  The 16-bit representation of $10000$ is `0010 0111 0001 0000`.\n2.  The two's complement for $x = -10000$ is found by inverting the bits and adding 1:\n    - Invert: `1101 1000 1110 1111`\n    - Add 1: `1101 1000 1111 0000`\n3.  Perform an arithmetic right shift by $k=5$ on this pattern. This shifts the bits right by 5 and fills the 5 new MSBs with the original sign bit (1):\n    - Original: `1101 1000 1111 0000`\n    - Shifted: `1111 1110 1100 0111`\n4.  To find the decimal value of this negative number, we find its magnitude by taking the two's complement:\n    - Invert: `0000 0001 0011 1000`\n    - Add 1: `0000 0001 0011 1001`\n5.  Convert the magnitude to decimal: $2^8 + 2^5 + 2^4 + 2^3 + 2^0 = 256 + 32 + 16 + 8 + 1 = 313$.\nThe value of the result is therefore $-313$. The bit-level verification confirms the result.",
            "answer": "$$\\boxed{-313}$$"
        },
        {
            "introduction": "A common programming task, calculating the average of two integers, hides a subtle but critical pitfall: overflow. The seemingly simple expression $(a + b) / 2$ can produce incorrect results for large inputs, a bug that has plagued countless systems. This practice challenges you to move beyond the naive approach and use your knowledge of bitwise identities to derive an elegant, overflow-free solution, demonstrating how a command of low-level instructions is essential for writing robust and efficient code. ",
            "id": "3620404",
            "problem": "You are asked to reason about and implement the floor of the average of two signed integers at the machine-instruction level using only arithmetic and logical instructions. The underlying machine model is a two's-complement, fixed-width arithmetic unit of width $w = 32$ bits, with the following semantics:\n\n- Two's-complement representation uses bit $31$ as the sign bit and represents integers in the range $[-2^{31}, 2^{31}-1]$.\n- Addition, subtraction, and all bitwise operations operate modulo $2^{32}$ on the bit patterns. That is, adding two $32$-bit values discards carries beyond bit $31$.\n- The right shift of a signed value is the arithmetic right shift (that is, sign-extending), and the right shift of an unsigned value is the logical right shift (that is, zero-filling).\n- Bitwise logical operators operate independently on each bit position.\n\nFoundational facts to assume as a starting point:\n\n- Binary addition decomposes into sum bits without carry and carry bits: for all bit patterns representing integers, $a + b = (a \\oplus b) + 2 \\cdot (a \\land b)$, where $\\oplus$ is bitwise exclusive-or and $\\land$ is bitwise and. This identity holds in the ring of integers; it describes how carries propagate in addition.\n- Arithmetic right shift by $1$ bit on a two's-complement value is equivalent to floor division by $2$: for any $x$ representable in $32$-bit two's complement, $\\operatorname{ashr}(x, 1)$ equals $\\left\\lfloor x / 2 \\right\\rfloor$.\n\nYour tasks:\n\n1) Define the function that attempts to compute the floor of the average of two signed $32$-bit integers $a$ and $b$ by first adding then shifting right by one, namely, compute $\\left\\lfloor (a + b) / 2 \\right\\rfloor$ by evaluating $(a + b)$ in $32$-bit two's-complement arithmetic and then applying an arithmetic right shift by $1$. Analyze and demonstrate cases where this approach fails due to wrap-around overflow in $(a + b)$.\n\n2) Derive, starting from the identity $a + b = (a \\oplus b) + 2 \\cdot (a \\land b)$ and from the semantics of arithmetic right shift as floor division by $2$, an expression built only from the operators $\\land$, $\\oplus$, integer addition, and arithmetic right shift by $1$ that computes $\\left\\lfloor (a + b) / 2 \\right\\rfloor$ for all $a, b$ in $[-2^{31}, 2^{31}-1]$, without ever overflowing when intermediate results are confined to $32$ bits. Justify why this expression cannot overflow under the stated model.\n\n3) Implement the following three functions under the above $w = 32$-bit two's-complement model, without invoking any behavior that is undefined in the C programming language:\n- A \"naive\" floor average $\\mathrm{avg\\_naive}(a, b)$ that returns the result of first performing $32$-bit modular addition of $a$ and $b$, then applying an arithmetic right shift by $1$.\n- A \"corrected\" floor average $\\mathrm{avg\\_correct}(a, b)$ that uses only $\\land$, $\\oplus$, integer addition, and arithmetic right shift by $1$ on $32$-bit values to compute $\\left\\lfloor (a + b) / 2 \\right\\rfloor$ without overflow, as derived in part $2$.\n- A \"reference\" floor average $\\mathrm{avg\\_ref}(a, b)$ that computes the true mathematical value $\\left\\lfloor (a + b) / 2 \\right\\rfloor$ using a wider integer type that provably cannot overflow for the inputs in $[-2^{31}, 2^{31}-1]$.\n\nImportant implementation requirements for correctness and portability:\n- You must simulate $32$-bit two's-complement arithmetic explicitly. In particular, do not rely on C signed overflow or on the implementation-defined behavior of right-shifting negative signed integers. Use masking to $32$ bits and explicit sign extension to implement arithmetic right shift.\n- Treat all intermediate $32$-bit values as bit patterns modulo $2^{32}$ and convert to signed integers only at the final step of each function that returns a signed result.\n\nTest suite:\nYour program must compute the following six test cases, each a pair $(a, b)$ of signed $32$-bit integers:\n- Case $1$: $(a, b) = (5, 2)$.\n- Case $2$: $(a, b) = (2{,}147{,}483{,}647, 2{,}147{,}483{,}647)$.\n- Case $3$: $(a, b) = (-2{,}147{,}483{,}648, -2{,}147{,}483{,}648)$.\n- Case $4$: $(a, b) = (2{,}147{,}483{,}647, -2{,}147{,}483{,}648)$.\n- Case $5$: $(a, b) = (2{,}147{,}483{,}647, 2{,}147{,}483{,}646)$.\n- Case $6$: $(a, b) = (-7, -2)$.\n\nFor each case, compute:\n- $N = \\mathrm{avg\\_naive}(a, b)$,\n- $C = \\mathrm{avg\\_correct}(a, b)$,\n- $R = \\mathrm{avg\\_ref}(a, b)$,\n- $n\\_ok$, which equals $1$ if $N = R$ and equals $0$ otherwise,\n- $c\\_ok$, which equals $1$ if $C = R$ and equals $0$ otherwise.\n\nFinal output format:\nYour program should produce a single line of output containing a list of six sublists, one per test case in the same order as above. Each sublist must be the five-tuple $[N,C,R,n\\_ok,c\\_ok]$ with all entries as base-$10$ integers and no spaces. The entire output should be formatted exactly as a single bracketed, comma-separated list of these sublists, for example, $[[\\cdots],[\\cdots],\\ldots]$.",
            "solution": "The problem requires an analysis and implementation of methods to compute the floor of the average of two signed $32$-bit integers, $\\lfloor (a + b) / 2 \\rfloor$, within a constrained two's-complement machine model. The model has a width of $w=32$ bits, uses modular arithmetic for addition, and defines arithmetic right shift, $\\operatorname{ashr}(x, 1)$, as being equivalent to $\\lfloor x / 2 \\rfloor$.\n\n### 1. Analysis of the Naive Approach\n\nThe naive approach computes $\\lfloor (a + b) / 2 \\rfloor$ by first calculating the sum $a+b$ using the machine's native $32$-bit addition and then performing an arithmetic right shift by $1$. Let the machine addition of $a$ and $b$ be denoted by $a +_{32} b$. The computation is thus $\\operatorname{ashr}(a +_{32} b, 1)$.\n\nThe fundamental flaw in this approach is overflow during the initial addition. The mathematical sum $a+b$ can exceed the representational range of a $32$-bit signed integer, which is $[-2^{31}, 2^{31}-1]$. In two's-complement arithmetic, such an overflow causes the result to \"wrap around,\" producing a value that is congruent to the true sum modulo $2^{32}$ but has a different magnitude and possibly a different sign.\n\nWe demonstrate this failure with two examples:\n\n**Case 1: Positive Overflow**\nLet $a = 2^{31}-1$ and $b = 2^{31}-1$.\nThe true mathematical sum is $S = (2^{31}-1) + (2^{31}-1) = 2^{32}-2$.\nThe correct average is $\\lfloor S/2 \\rfloor = \\lfloor (2^{32}-2)/2 \\rfloor = 2^{31}-1$.\nIn the $32$-bit machine model, the sum $a +_{32} b$ is computed as:\n$(2^{31}-1) + (2^{31}-1) \\equiv (2^{32}-2) \\pmod{2^{32}} \\equiv -2$.\nThe bit pattern for $2^{31}-1$ is `0x7FFFFFFF`. The sum `0x7FFFFFFF + 0x7FFFFFFF` results in `0xFFFFFFFE`, which is the two's-complement representation of $-2$.\nThe naive method then computes $\\operatorname{ashr}(-2, 1) = \\lfloor -2/2 \\rfloor = -1$.\nThe result, $-1$, is drastically different from the correct value of $2^{31}-1$.\n\n**Case 2: Negative Overflow**\nLet $a = -2^{31}$ and $b = -2^{31}$.\nThe true mathematical sum is $S = (-2^{31}) + (-2^{31}) = -2^{32}$.\nThe correct average is $\\lfloor S/2 \\rfloor = \\lfloor -2^{32}/2 \\rfloor = -2^{31}$.\nIn the $32$-bit machine model, the sum $a +_{32} b$ is computed as:\n$(-2^{31}) + (-2^{31}) \\equiv (-2^{32}) \\pmod{2^{32}} \\equiv 0$.\nThe bit pattern for $-2^{31}$ is `0x80000000`. The sum `0x80000000 + 0x80000000` results in `0x100000000`. Since the carry-out from bit $31$ is discarded in $32$-bit arithmetic, the result is `0x00000000`, which represents $0$.\nThe naive method then computes $\\operatorname{ashr}(0, 1) = \\lfloor 0/2 \\rfloor = 0$.\nThis result, $0$, is incorrect; the true average is $-2^{31}$.\n\nThese cases demonstrate that the naive approach is unreliable due to intermediate overflow in the addition operation.\n\n### 2. Derivation of a Correct, Overflow-Free Expression\n\nTo derive a robust expression, we start from the provided foundational fact relating integer addition to bitwise operations:\n$$a + b = (a \\oplus b) + 2 \\cdot (a \\land b)$$\nwhere $\\oplus$ is bitwise XOR and $\\land$ is bitwise AND. This identity holds for integers of arbitrary size.\n\nOur goal is to compute $\\lfloor (a+b)/2 \\rfloor$. We substitute the identity into this expression:\n$$ \\left\\lfloor \\frac{a+b}{2} \\right\\rfloor = \\left\\lfloor \\frac{(a \\oplus b) + 2 \\cdot (a \\land b)}{2} \\right\\rfloor $$\nWe can distribute the division inside the floor function:\n$$ \\left\\lfloor \\frac{a+b}{2} \\right\\rfloor = \\left\\lfloor \\frac{a \\oplus b}{2} + \\frac{2 \\cdot (a \\land b)}{2} \\right\\rfloor = \\left\\lfloor \\frac{a \\oplus b}{2} + (a \\land b) \\right\\rfloor $$\nSince $(a \\land b)$ results in an integer value, we can use the property $\\lfloor z+k \\rfloor = \\lfloor z \\rfloor + k$ for any real $z$ and integer $k$:\n$$ \\left\\lfloor \\frac{a+b}{2} \\right\\rfloor = \\left\\lfloor \\frac{a \\oplus b}{2} \\right\\rfloor + (a \\land b) $$\nThe problem states that for any $32$-bit two's-complement integer $x$, the operation $\\operatorname{ashr}(x, 1)$ is equivalent to $\\lfloor x/2 \\rfloor$. Applying this to the term $\\lfloor (a \\oplus b)/2 \\rfloor$, we arrive at the final expression:\n$$ \\left\\lfloor \\frac{a+b}{2} \\right\\rfloor = \\operatorname{ashr}(a \\oplus b, 1) + (a \\land b) $$\nThis expression is composed solely of the allowed operators.\n\n**Justification for Absence of Overflow:**\nWe must now prove that evaluating this expression using $32$-bit modular arithmetic does not cause overflow in the final addition step. Let $T_1 = \\operatorname{ashr}(a \\oplus b, 1)$ and $T_2 = a \\land b$. We analyze the signs of the operands $T_1$ and $T_2$ in the sum $T_1 + T_2$. Overflow in two's-complement addition can only occur when adding two numbers of the same sign, and the result has the opposite sign.\n\n- **Case A: $a$ and $b$ have the same sign.**\n  The sign bits of $a$ and $b$ are identical ($a_{31} = b_{31}$).\n  - The sign bit of $(a \\oplus b)$ is $a_{31} \\oplus b_{31} = 0$. Thus, $(a \\oplus b)$ is a non-negative integer. Its arithmetic right shift, $T_1 = \\operatorname{ashr}(a \\oplus b, 1)$, is also non-negative.\n  - The sign bit of $(a \\land b)$ is $a_{31} \\land b_{31} = a_{31}$. Thus, $T_2 = a \\land b$ has the same sign as $a$ and $b$.\n  - If $a, b \\ge 0$, then $T_1 \\ge 0$ and $T_2 \\ge 0$. The true average must also be non-negative and is representable in $32$ bits. The sum $T_1 + T_2$ cannot overflow. For instance, if $a=b=2^{31}-1$, $T_1=\\operatorname{ashr}(0,1)=0$ and $T_2=2^{31}-1$. The sum is $2^{31}-1$, which is correct and does not overflow.\n  - If $a, b  0$, then $T_1 \\ge 0$ and $T_2  0$. We are adding a non-negative number to a negative number. This sum is guaranteed to lie between the two operands and thus can never overflow.\n\n- **Case B: $a$ and $b$ have different signs.**\n  The sign bits of $a$ and $b$ are different ($a_{31} \\neq b_{31}$).\n  - The sign bit of $(a \\oplus b)$ is $a_{31} \\oplus b_{31} = 1$. Thus, $(a \\oplus b)$ is a negative integer. Its arithmetic right shift, $T_1 = \\operatorname{ashr}(a \\oplus b, 1)$, is also negative.\n  - The sign bit of $(a \\land b)$ is $a_{31} \\land b_{31} = 0$. Thus, $T_2 = a \\land b$ is a non-negative integer.\n  - We are again adding a negative number ($T_1$) to a non-negative number ($T_2$). As in Case A, this operation cannot overflow.\n\nIn all possible cases, the operands of the final addition do not both have the same sign (unless one is zero), which is the necessary condition for overflow. Therefore, the expression $\\operatorname{ashr}(a \\oplus b, 1) + (a \\land b)$ can be computed using $32$-bit modular arithmetic without any risk of intermediate overflow.\n\n### 3. Implementation Plan\n\nThe problem requires implementing three functions in C, adhering to a strict simulation of the $32$-bit two's-complement model and avoiding C language's undefined or implementation-defined behaviors for signed integers. We will assume `int` is a $32$-bit type and `long long` is a $64$-bit type, a standard configuration.\n\n- **`avg_ref(a, b)`**: This reference function will cast the inputs $a$ and $b$ to a wider type, `long long`, which is guaranteed to hold their sum without overflow. The floor of the average is then computed using the arithmetic right shift operator `>>` on the `long long` sum. Under the C23 standard, right-shifting a signed integer is guaranteed to be an arithmetic shift, yielding $\\lfloor (a+b)/2 \\rfloor$.\n\n- **`ashr_s32_by_1(x)`**: To comply with the explicit simulation requirement, a helper function will be created to perform the arithmetic right shift by $1$. It will convert the signed input to an `unsigned int` to perform a logical right shift (which is well-defined), and then manually restore the sign bit if the original number was negative.\n\n- **`avg_naive(a, b)`**: This function will simulate the flawed approach. It will use `unsigned int` to perform the modular addition of $a$ and $b$. The resulting bit pattern will be reinterpreted as a signed `int` and passed to our `ashr_s32_by_1` helper function.\n\n- **`avg_correct(a, b)`**: This function will implement the derived overflow-free formula. It will use `unsigned int` types to perform the bitwise `` and `^` operations and the final `+` operation, thereby ensuring all arithmetic is modular. The intermediate result of the `^` operation will be cast to a signed `int` solely for the call to the `ashr_s32_by_1` function, as the `ashr` operation is defined on signed values.",
            "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n#include stdio.h\n#include stdlib.h\n\n// This program assumes that 'int' is a 32-bit two's-complement integer\n// and 'long long' is a 64-bit two's-complement integer. This is a common\n// configuration for modern systems.\n\n/**\n * @brief Performs a portable arithmetic right shift by 1 on a 32-bit signed integer.\n * @param x The 32-bit signed integer to shift.\n * @return The result of ashr(x, 1), equivalent to floor(x / 2).\n *\n * This function avoids the implementation-defined behavior of right-shifting\n * negative signed integers in pre-C23 standards by explicitly simulating\n * sign extension on an unsigned type.\n */\nint ashr_s32_by_1(int x) {\n    // Reinterpret the bits of x as an unsigned integer to use logical shift.\n    unsigned int u_x = (unsigned int)x;\n    \n    // The C standard guarantees that right-shifting an unsigned type is a logical shift.\n    unsigned int shifted = u_x  1;\n    \n    // If the original number was negative (its sign bit was 1), we must\n    // manually set the sign bit of the shifted result to 1.\n    if (x  0) {\n        shifted |= 0x80000000;\n    }\n    \n    // Reinterpret the resulting bit pattern as a signed integer.\n    return (int)shifted;\n}\n\n/**\n * @brief Naive computation of floor((a+b)/2) via (a+b)1, subject to overflow.\n * @param a The first signed 32-bit integer.\n * @param b The second signed 32-bit integer.\n * @return The result of the naive computation.\n */\nint avg_naive(int a, int b) {\n    // Simulate 32-bit modular addition by using unsigned integers, for which\n    // addition is guaranteed to be modular.\n    unsigned int u_a = (unsigned int)a;\n    unsigned int u_b = (unsigned int)b;\n    unsigned int u_sum = u_a + u_b;\n    \n    // Reinterpret the resulting bit pattern as a signed integer. This value\n    // may be incorrect if the true sum overflowed.\n    int s_sum = (int)u_sum;\n    \n    // Perform an arithmetic right shift on the (potentially overflowed) sum.\n    return ashr_s32_by_1(s_sum);\n}\n\n/**\n * @brief Correctly computes floor((a+b)/2) without overflow.\n * @param a The first signed 32-bit integer.\n * @param b The second signed 32-bit integer.\n * @return The correct floor of the average, computed without overflow.\n *\n * This function uses the identity floor((a+b)/2) = (ab) + ashr(a^b, 1).\n */\nint avg_correct(int a, int b) {\n    // Reinterpret inputs as bit patterns (unsigned) for bitwise operations.\n    unsigned int u_a = (unsigned int)a;\n    unsigned int u_b = (unsigned int)b;\n    \n    // T1 = a  b. This is computed as a bit pattern.\n    unsigned int u_t1 = u_a  u_b;\n    \n    // Intermediate for T2: a ^ b\n    unsigned int u_xor_res = u_a ^ u_b;\n    \n    // T2 = ashr(a ^ b, 1). To perform ashr, we treat the pattern as signed.\n    int s_xor_res = (int)u_xor_res;\n    int s_t2 = ashr_s32_by_1(s_xor_res);\n    // Convert back to a bit pattern for the final addition.\n    unsigned int u_t2 = (unsigned int)s_t2;\n    \n    // Final sum: T1 + T2, performed using modular arithmetic, which is overflow-free.\n    unsigned int u_result = u_t1 + u_t2;\n    \n    // Reinterpret the final bit pattern as a signed integer.\n    return (int)u_result;\n}\n\n/**\n * @brief Reference computation of floor((a+b)/2) using a wider integer type.\n * @param a The first signed 32-bit integer.\n * @param b The second signed 32-bit integer.\n * @return The mathematically correct floor of the average.\n */\nint avg_ref(int a, int b) {\n    // Use a wider type (long long, guaranteed to be at least 64 bits)\n    // to hold the sum without any risk of overflow.\n    long long sum_ll = (long long)a + (long long)b;\n    \n    // Compute floor(sum_ll / 2). The C23 standard guarantees that right-shifting\n    // a signed integer is an arithmetic shift, equivalent to floor division by 2.\n    long long avg_ll = sum_ll  1;\n    \n    // The result is guaranteed to fit within a 32-bit integer.\n    return (int)avg_ll;\n}\n\n\n// A struct to hold the parameters for a single test case.\ntypedef struct {\n    int a;\n    int b;\n} TestCase;\n\nint main(void) {\n    // Define the test cases from the problem statement.\n    // The value -2147483648 is written as (-2147483647 - 1) to avoid\n    // issues with integer literal parsing in older C standards.\n    TestCase test_cases[] = {\n        {5, 2},\n        {2147483647, 2147483647},\n        {(-2147483647 - 1), (-2147483647 - 1)},\n        {2147483647, (-2147483647 - 1)},\n        {2147483647, 2147483646},\n        {-7, -2}\n    };\n\n    // Calculate the number of test cases.\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    \n    printf(\"[\");\n    for (int i = 0; i  num_cases; ++i) {\n        int a = test_cases[i].a;\n        int b = test_cases[i].b;\n\n        // Compute results from the three functions\n        int N = avg_naive(a, b);\n        int C = avg_correct(a, b);\n        int R = avg_ref(a, b);\n        \n        // Check for correctness\n        int n_ok = (N == R);\n        int c_ok = (C == R);\n\n        printf(\"[%d,%d,%d,%d,%d]\", N, C, R, n_ok, c_ok);\n        if (i  num_cases - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\\n\");\n\n    return EXIT_SUCCESS;\n}\n```"
        }
    ]
}