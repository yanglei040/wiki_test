{
    "hands_on_practices": [
        {
            "introduction": "这第一个练习为理解指令集架构（ISA）的差异提供了一个具体的起点。通过计算同一个算术表达式在四种经典ISA类型下的代码大小，你将亲身体验指令复杂性与代码密度之间的权衡。这项练习  将帮助你理解为什么在不同应用中会选择不同的设计，例如在内存资源稀缺的嵌入式系统中。",
            "id": "3653344",
            "problem": "要求您评估在四种经典的指令集架构（ISA）类别下，计算表达式 $E = \\big((x+y)\\cdot(z-w)\\big)/(u+v)$ 的代码密度。其中，变量 $x$, $y$, $z$, $w$, $u$, $v$ 存储在内存中的不同地址，最终结果 $E$ 必须存储到指定的内存位置 $r$。在每种ISA的操作数模型下，请仅使用能正确计算 $E$ 的最小指令序列，并使用下面指定的指令编码计算每个序列的总代码大小（以比特为单位）。然后，报告一个单一值：四种ISA类别中最大和最小总代码大小之间的差值（以比特为单位）。\n\n基本假设和编码模型，基于指令集架构（ISA）类别和指令编码字段的核心定义：\n\n- 定义：\n  - 堆栈机使用零地址算术；操作数默认为后进先出（LIFO）堆栈的顶部元素。\n  - 累加器机有一个单一的隐式累加器寄存器，参与所有算术运算。\n  - 寄存器-内存机允许在通用寄存器与另一个寄存器或内存操作数之间进行算术运算。\n  - 加载-存储机（精简指令集）只允许在寄存器之间进行算术运算；所有内存访问都通过显式的加载和存储指令进行。\n\n- 内存地址：\n  - 所有内存操作数地址都是绝对地址，并编码在 $16$ 位字段中。\n  - 没有立即数字面量；只有内存和寄存器操作数可用。\n\n- 所需算术运算：\n  - 加法、减法、乘法和除法在每个ISA类别中都可用，并具有自然的语义。对于减法和除法，顺序是由每种ISA的操作数模型决定的左操作数减去或除以右操作数。\n\n- 指令编码：\n  1. 堆栈ISA：\n     - 零操作数算术指令（ADD, SUB, MUL, DIV）编码为 $8$ 位。\n     - 带有内存操作数的PUSH和POP指令各有 $8$ 位的操作码和一个 $16$ 位的地址操作数，总共每个 $24$ 位。\n     - 算术语义：ADD弹出 $S_{-1}$ 和 $S_{0}$ 并压入 $S_{-1}+S_{0}$；SUB压入 $S_{-1}-S_{0}$；DIV压入 $S_{-1}/S_{0}$；MUL压入 $S_{-1}\\cdot S_{0}$。\n  2. 累加器ISA：\n     - 使用隐式累加器 $A$ 的单地址指令：LOAD $A,\\,[\\text{addr}]$, STORE $[\\text{addr}],\\,A$, 以及算术运算 A := A op $M[\\text{addr}]$ (ADD, SUB, MUL, DIV)。\n     - 所有这些指令都用一个 $8$ 位的操作码加上一个 $16$ 位的地址进行编码，总共每个 $24$ 位。\n  3. 寄存器-内存ISA：\n     - 有 $16$ 个通用寄存器，每个寄存器都用一个 $4$ 位的字段进行编码。\n     - 寄存器-寄存器算术运算（例如，ADD $R_d,R_s$; SUB; MUL; DIV）每条指令 $16$ 位。\n     - 形式为 op $R,\\,[\\text{addr}]$ 或 STORE $[\\text{addr}],\\,R$ 的寄存器-内存算术运算和加载/存储指令每条编码为 $32$ 位（以容纳一个 $8$ 位的操作码、一个 $4$ 位的寄存器字段、一个 $16$ 位的地址，以及为了对齐到完整字节数的填充）。\n  4. 加载-存储ISA：\n     - 有 $16$ 个通用寄存器，每个寄存器都用一个 $4$ 位的字段进行编码。\n     - 所有指令都是 $32$ 位长。\n     - 算术运算仅为寄存器-寄存器（在适用情况下为三操作数形式），内存仅通过带有绝对 $16$ 位地址的显式LOAD和STORE指令访问。\n\n- 初始条件：\n  - 没有任何寄存器包含有用的初始值。\n  - 表达式必须精确计算为 $E = \\big((x+y)\\cdot(z-w)\\big)/(u+v)$ 并存储到内存位置 $r$。\n  - 不允许使用超出ISA模型所述的微操作或隐式临时变量。\n\n任务：\n- 对于每个ISA类别，根据给定的模型，确定一个计算 $E$ 并将其存储到 $r$ 的最短正确指令序列。\n- 使用上述编码，计算每个序列的总代码大小（以比特为单位）。\n- 设 $S_{\\min}$ 为四个总和中的最小值，$S_{\\max}$ 为最大值。计算 $S_{\\max}-S_{\\min}$。\n- 将最终的差值表示为一个以比特为单位的实数。在最终的方框答案中不要包含任何单位。",
            "solution": "该问题要求分析在四种经典的指令集架构（ISA）类别中——堆栈、累加器、寄存器-内存和加载-存储——计算表达式 $E = \\big((x+y)\\cdot(z-w)\\big)/(u+v)$ 的代码密度。对于每个类别，我们必须设计一个最小的指令序列，根据提供的编码方案计算其总大小（以比特为单位），并最终确定所获得的最大和最小代码大小之间的差值。\n\n首先，该问题经过验证，被认为是定义明确且科学合理的。这是一个关于ISA设计权衡的计算机体系结构标准问题。指令编码模型是各自类别的简化但一致的表示。关于累加器架构是否可用临时内存位置的一个小歧义，通过一个标准且必要的假设得以解决，即假设这些位置是可用的；没有它们，表达式将无法计算，问题也将是病态的。所有其他规范都清晰且足以进行下一步。\n\n表达式 $E = \\frac{(x+y)(z-w)}{u+v}$ 的求值可以分解为以下步骤：\n$1$. 计算 $T_a = (x+y)$。\n$2$. 计算 $T_b = (z-w)$。\n$3$. 计算 $T_c = T_a \\cdot T_b$。\n$4$. 计算 $T_d = (u+v)$。\n$5$. 计算 $E = T_c / T_d$。\n这总共需要五个算术运算：两个加法，一个减法，一个乘法和一个除法。所有六个变量（$x, y, z, w, u, v$）都必须从内存中取出，最终结果 $E$ 必须存回内存位置 $r$。\n\n我们现在依次分析每种ISA类别。\n\n**1. 堆栈ISA**\n基于堆栈的机器使用后进先出的堆栈来存放操作数。算术运算隐式地对堆栈顶部的元素进行操作。表达式求值自然地遵循其逆波兰表示法（RPN）形式：`x y + z w - * u v + /`。\n\n最小指令序列是：\n1. `PUSH [x]`  ; 将 $x$ 的值压入堆栈。\n2. `PUSH [y]`  ; 将 $y$ 的值压入堆栈。堆栈： $[x, y]$。\n3. `ADD`        ; 弹出 $x, y$ 并压入 $(x+y)$。堆栈： $[x+y]$。\n4. `PUSH [z]`  ; 将 $z$ 的值压入堆栈。堆栈： $[x+y, z]$。\n5. `PUSH [w]`  ; 将 $w$ 的值压入堆栈。堆栈： $[x+y, z, w]$。\n6. `SUB`        ; 弹出 $z, w$ 并压入 $(z-w)$。堆栈： $[x+y, z-w]$。\n7. `MUL`        ; 弹出 $(x+y), (z-w)$ 并压入它们的积。堆栈： $[(x+y)(z-w)]$。\n8. `PUSH [u]`  ; 将 $u$ 的值压入堆栈。堆栈： $[(x+y)(z-w), u]$。\n9. `PUSH [v]`  ; 将 $v$ 的值压入堆栈。堆栈： $[(x+y)(z-w), u, v]$。\n10. `ADD`       ; 弹出 $u, v$ 并压入 $(u+v)$。堆栈： $[(x+y)(z-w), u+v]$。\n11. `DIV`       ; 弹出积与和，并压入商。堆栈： $[E]$。\n12. `POP [r]`   ; 弹出结果并存入地址为 $r$ 的内存位置。\n\n该序列需要 $6$ 个 `PUSH` 操作、$1$ 个 `POP` 操作和 $5$ 个算术操作。\n\n代码大小计算：\n- PUSH 和 POP 指令被指定为每个 $24$ 位（$8$ 位操作码 + $16$ 位地址）。共有 $7$ 个此类指令。总大小：$7 \\times 24 = 168$ 比特。\n- 零操作数算术指令每个 $8$ 位。共有 $5$ 个此类指令（两个 `ADD`，一个 `SUB`，一个 `MUL`，一个 `DIV`）。总大小：$5 \\times 8 = 40$ 比特。\n- 堆栈ISA的总代码大小：$S_{stack} = 168 + 40 = 208$ 比特。\n\n**2. 累加器ISA**\n累加器架构使用一个单一的隐式寄存器，即累加器（$A$），用于所有算术运算。运算通常采用 $A \\leftarrow A \\text{ op } M[\\text{addr}]$ 的形式。由于只有一个寄存器，中间结果必须存储在临时内存位置。我们将其表示为 `temp1`、`temp2`。\n\n为了最小化指令数量，一个正确的序列是先计算除数或乘法中对顺序不敏感的部分，以避免不必要的加载/存储。对于除法 $A/B$，我们需要先计算 $B$ 并存储它，然后计算 $A$ 并将其保留在累加器中，最后执行除法。\n\n最小指令序列是：\n1. `LOAD [u]`      ; $A \\leftarrow M[u]$\n2. `ADD [v]`       ; $A \\leftarrow (u+v)$ (计算除数)\n3. `STORE [temp1]` ; $M[\\text{temp1}] \\leftarrow (u+v)$ (存储除数)\n4. `LOAD [x]`      ; $A \\leftarrow M[x]$\n5. `ADD [y]`       ; $A \\leftarrow (x+y)$\n6. `STORE [temp2]` ; $M[\\text{temp2}] \\leftarrow (x+y)$ (存储分子的第一部分)\n7. `LOAD [z]`      ; $A \\leftarrow M[z]$\n8. `SUB [w]`       ; $A \\leftarrow (z-w)$ (计算分子的第二部分)\n9. `MUL [temp2]`    ; $A \\leftarrow A \\cdot M[\\text{temp2}] = (z-w)(x+y)$ (计算分子)\n10. `DIV [temp1]`   ; $A \\leftarrow A / M[\\text{temp1}] = E$ (计算最终结果)\n11. `STORE [r]`     ; $M[r] \\leftarrow A$ (存储结果)\n\n这个包含 $11$ 条指令的序列是最小的。所有指令都是单地址格式。\n\n代码大小计算：\n- 每条指令有一个 $8$ 位的操作码和一个 $16$ 位的地址，总共 $24$ 位。\n- 序列中有 $11$ 条指令。\n- 累加器ISA的总代码大小：$S_{acc} = 11 \\times 24 = 264$ 比特。\n\n**3. 寄存器-内存ISA**\n该ISA允许在两个寄存器之间或一个寄存器与一个内存位置之间进行算术运算。有 $16$ 个寄存器。使用寄存器存储临时值比使用内存更高效。\n\n最小指令序列是：\n1. `LOAD R1, [x]`   ; $R_1 \\leftarrow M[x]$\n2. `ADD R1, [y]`    ; $R_1 \\leftarrow R_1 + M[y] = (x+y)$\n3. `LOAD R2, [z]`   ; $R_2 \\leftarrow M[z]$\n4. `SUB R2, [w]`    ; $R_2 \\leftarrow R_2 - M[w] = (z-w)$\n5. `MUL R1, R2`     ; $R_1 \\leftarrow R_1 \\cdot R_2 = (x+y)(z-w)$\n6. `LOAD R3, [u]`   ; $R_3 \\leftarrow M[u]$\n7. `ADD R3, [v]`    ; $R_3 \\leftarrow R_3 + M[v] = (u+v)$\n8. `DIV R1, R3`     ; $R_1 \\leftarrow R_1 / R_3 = E$\n9. `STORE [r], R1`  ; $M[r] \\leftarrow R_1$\n\n这个序列使用了 $3$ 个寄存器，并且是最小的。\n\n代码大小计算：\n- 寄存器-内存操作（LOAD, STORE, 带有内存操作数的 ADD/SUB）每个 $32$ 位。共有 $7$ 个此类指令。总大小：$7 \\times 32 = 224$ 比特。\n- 寄存器-寄存器算术运算（MUL, DIV）每个 $16$ 位。共有 $2$ 个此类指令。总大小：$2 \\times 16 = 32$ 比特。\n- 寄存器-内存ISA的总代码大小：$S_{regmem} = 224 + 32 = 256$ 比特。\n\n**4. 加载-存储ISA**\n在加载-存储（或RISC风格）架构中，算术运算只能对位于寄存器中的操作数执行。内存完全通过 `LOAD` 和 `STORE` 指令进行访问。我们假设算术指令采用三操作数格式（例如，`ADD Rd, Rs1, Rs2`）。\n\n最小指令序列是：\n1. `LOAD R1, [x]`    ; 从内存加载所有需要的操作数。\n2. `LOAD R2, [y]`\n3. `LOAD R3, [z]`\n4. `LOAD R4, [w]`\n5. `LOAD R5, [u]`\n6. `LOAD R6, [v]`\n7. `ADD R7, R1, R2`  ; $R_7 \\leftarrow (x+y)$\n8. `SUB R8, R3, R4`  ; $R_8 \\leftarrow (z-w)$\n9. `MUL R7, R7, R8`  ; $R_7 \\leftarrow R_7 \\cdot R_8 = (x+y)(z-w)$ (复用 R7)\n10. `ADD R8, R5, R6` ; $R_8 \\leftarrow (u+v)$ (复用 R8)\n11. `DIV R7, R7, R8` ; $R_7 \\leftarrow R_7 / R_8 = E$\n12. `STORE [r], R7` ; 存储最终结果。\n\n这个序列需要 $6$ 条 `LOAD` 指令、$5$ 条算术指令和 $1$ 条 `STORE` 指令，总共 $12$ 条指令。\n\n代码大小计算：\n- 所有指令都被指定为 $32$ 位长。\n- 序列中有 $12$ 条指令。\n- 加载-存储ISA的总代码大小：$S_{loadstore} = 12 \\times 32 = 384$ 比特。\n\n**总结与最终计算**\n我们已经计算出每个ISA类别的最小代码大小：\n- $S_{stack} = 208$ 比特\n- $S_{acc} = 264$ 比特\n- $S_{regmem} = 256$ 比特\n- $S_{loadstore} = 384$ 比特\n\n最小的代码大小是 $S_{\\min} = S_{stack} = 208$ 比特。\n最大的代码大小是 $S_{\\max} = S_{loadstore} = 384$ 比特。\n\n问题要求计算最大和最小总代码大小之间的差值。\n$S_{\\max} - S_{\\min} = 384 - 208 = 176$ 比特。",
            "answer": "$$\\boxed{176}$$"
        },
        {
            "introduction": "在宏观比较的基础上，这个问题聚焦于评估表达式树这一基本任务。你将推导基于堆栈的ISA的关键性能指标（入栈和出栈次数），并将其与加载-存储型ISA的主要资源约束（寄存器数量）进行比较。这项分析  揭示了这些架构固有的算法特性，并为著名的Sethi-Ullman编译器优化算法提供了量化依据。",
            "id": "3653331",
            "problem": "一个平衡二元表达式树是一个有限无环图，其中每个内部节点恰好有两个子节点（二元运算符），每个叶节点持有一个操作数，并且任何节点的左右子树的高度差最多为一。设该树有 $n$ 个叶节点（操作数）。考虑在一个栈指令集架构（ISA）上对该表达式求值，其中指令要么将一个操作数压入栈中，要么应用一个二元运算符，该运算符从栈中弹出两个操作数，然后将结果值压回栈中。假设求值顺序使得最终结果留在栈顶，除了操作数加载和运算符执行所必需的压栈和弹栈操作外，没有额外的压栈或弹栈操作，并假设没有副作用，也没有公共子表达式复用。\n\n作为比较，考虑在一个加载-存储寄存器ISA（指令集架构）上仅使用寄存器进行求值，目标是最小化寄存器溢出。寄存器溢出是指因寄存器不足而必须保存到内存的任何临时值。在没有任何溢出的情况下对表达式树求值所需的最小寄存器数量等于该树的Strahler数（也称为Sethi–Ullman数）。一个叶节点需要一个寄存器；一个内部节点需要的寄存器数量是其子节点需求数量的最大值，但若两个子节点需求数量相同，则在该最大值上再加一。\n\n从上述定义和“树的边数等于节点数减一”这一通用性质出发，推导以下各项关于 $n$ 的闭式表达式：\n- 执行的总压栈次数，\n- 执行的总弹栈次数，\n- 在无溢出的情况下对平衡二元表达式树求值所需的最小寄存器数量。\n\n将你的最终答案表示为三个关于 $n$ 的闭式表达式。无需取整。",
            "solution": "设表达式树为一个有 $n$ 个叶节点的正则二叉树（每个内部节点恰好有两个子节点）。用 $m$ 表示内部节点的数量。\n\n步骤1：利用图的基本性质建立 $m$ 和 $n$ 之间的关系。\n一个有 $N$ 个总节点的树恰好有 $N-1$ 条边。在一个正则二叉树中，每个内部节点为其两个子节点贡献恰好 $2$ 条出边，所以总边数为 $2m$。总节点数为 $m + n$（内部节点加叶节点）。令两个表示边数的表达式相等，可得\n$$\n2m = (m + n) - 1 \\quad \\Rightarrow \\quad m = n - 1.\n$$\n\n步骤2：计算在栈ISA上的压栈次数。\n根据求值模型的定义：\n- 每个叶节点操作数被精确地压入栈一次，贡献 $n$ 次压栈。\n- 每个内部节点处的二元运算符通过弹栈消耗两个操作数，然后产生一个结果并将其压回栈中。因此，每个内部节点贡献 $1$ 次压栈。\n由于有 $m = n - 1$ 个内部节点，运算符结果的压栈贡献了 $n - 1$ 次压栈。\n因此，总压栈次数为\n$$\nn + (n - 1) = 2n - 1.\n$$\n\n步骤3：计算在栈ISA上的弹栈次数。\n每个内部节点应用一个必须弹出两个操作数的二元运算符。假设在最后没有额外的弹栈操作，因为最终结果保留在栈上。因此，总弹栈次数为\n$$\n2m = 2(n - 1) = 2n - 2.\n$$\n\n步骤4：计算平衡二元表达式树所需的最小寄存器数。\n我们使用从寄存器需求的第一性原理推导出的Strahler数特征：\n- 一个叶节点需要 $1$ 个寄存器（用于存放其值）。\n- 对于一个内部节点，其左右子树分别需要 $i$ 和 $j$ 个寄存器，则该节点所需的最小寄存器数为：\n  - 若 $i \\neq j$，则为 $\\max(i, j)$，因为可以先用 $\\max(i, j)$ 个寄存器计算较大的子树，将其单个结果保存在 $1$ 个寄存器中，然后在相同的预算内计算较小的子树，而无需额外的寄存器；\n  - 若 $i = j$，则为 $i + 1$，因为将一个子树计算为单个结果会占用 $1$ 个寄存器，而此时计算另一个子树需要并发地使用 $i$ 个寄存器；因此需要 $i + 1$ 个寄存器以避免溢出。\n这个递推关系就是Strahler/Sethi–Ullman标号法。\n\n对于一个有 $n$ 个叶节点的平衡二叉树，令 $R(n)$ 表示所需的最小寄存器数。我们断言\n$$\nR(n) = \\left\\lfloor \\log_{2}(n) \\right\\rfloor + 1.\n$$\n我们对此的证明如下。\n\n首先，对于一个有 $n = 2^{k}$ 个叶节点的完美二叉树，每一层都组合了需要相同寄存器数量的子树，因此在每个内部层级，标号增加 $1$。叶节点的标号为 $1$，并且有 $k$ 个内部层级，所以根节点需要 $k + 1$ 个寄存器：\n$$\nR(2^{k}) = k + 1 = \\log_{2}(2^{k}) + 1.\n$$\n\n其次，对于具有 $2^{k}  n  2^{k+1}$ 个叶节点的平衡树，根节点的两个子树分别有大约 $n/2$ 个叶节点。由于 $2^{k-1}  n/2  2^k$，每个子树最多需要 $k$ 个寄存器。更准确地说，将 $n$ 个叶节点平衡地划分为 $\\lfloor n/2 \\rfloor$ 和 $\\lceil n/2 \\rceil$ 可以确保只要 $n  2^{k+1}$，至少有一侧的叶节点数少于 $2^{k}$。因此，在根节点处，一个子树的寄存器标号可能是 $k+1$ (如果其叶节点数 $\\ge 2^k$)，而另一个子树的标号则小于或等于 $k+1$。对于平衡树，$2^k \\le n  2^{k+1}$，子树的叶节点数在 $2^{k-1}$ 和 $2^k$ 之间。因此它们的寄存器需求将是 $k$ 或 $k+1$。根据Sethi-Ullman规则，根节点的寄存器需求将是 $\\max(k, k+1) = k+1$ 或 $k+1+1=k+2$（如果两个子树的需求都是 $k+1$）。对于平衡树，当 $n  2^{k+1}$ 时，两个子树的叶节点数不会同时大于或等于 $2^k$，因此它们的需求不会都是 $k+1$。所以对于 $2^{k} \\leq n \\leq 2^{k+1} - 1$，\n$$\nR(n) = k + 1 = \\left\\lfloor \\log_{2}(n) \\right\\rfloor + 1.\n$$\n\n因此，在无溢出的情况下对一个有 $n$ 个叶节点的平衡二元表达式树求值所需的最小寄存器数为 $\\left\\lfloor \\log_{2}(n) \\right\\rfloor + 1$。\n\n步骤5：整理表达式。\n- 总压栈次数：$2n - 1$。\n- 总弹栈次数：$2n - 2$。\n- 最小寄存器数：$\\left\\lfloor \\log_{2}(n) \\right\\rfloor + 1$。\n\n这些是关于 $n$ 的闭式表达式。",
            "answer": "$$\\boxed{\\begin{pmatrix}2n - 1  2n - 2  \\left\\lfloor \\log_{2}(n) \\right\\rfloor + 1\\end{pmatrix}}$$"
        },
        {
            "introduction": "现实世界的程序不仅仅是线性的算术运算，控制流占据了主导地位。最后一个练习  探讨了堆栈和加载-存储架构如何处理一个简单的条件语句 `if $x \\lt y$ then ... else ...`。通过分析最小指令序列，你将发现一些微妙但重要的设计选择，例如破坏性与非破坏性操作，并了解它们如何影响实现程序逻辑的代码效率和复杂性。",
            "id": "3653385",
            "problem": "一个高级语言的实现目标：如果 $x  y$ 则 ... 否则 ... (问题描述不完整)",
            "solution": "此问题的陈述不完整。它提供了一个条件 `if x  y`，但没有指定 `then` 和 `else` 子句中要执行的具体操作。由于缺少这些关键信息，无法构建一个确切的指令序列，也无法进行关于指令数量或性能的比较分析。因此，该问题无法解答。",
            "answer": "$$\\boxed{\\text{无法解答}}$$"
        }
    ]
}