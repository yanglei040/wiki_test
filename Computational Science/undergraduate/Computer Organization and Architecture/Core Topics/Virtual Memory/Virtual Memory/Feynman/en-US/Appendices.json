{
    "hands_on_practices": [
        {
            "introduction": "The performance of a CPU is heavily dependent on its cache, but virtual memory adds a layer of translation that can complicate cache design. This first exercise delves into the interaction between a Virtually Indexed, Physically Tagged (VIPT) cache and the virtual memory system, focusing on the \"synonym problem\". You will derive the minimum page size required to prevent correctness issues, a crucial calculation that processor architects must perform. ",
            "id": "3687877",
            "problem": "A processor implements a Level 1 (L1) data cache that is Virtually Indexed, Physically Tagged (VIPT). The virtual memory system divides virtual addresses into a virtual page number and a page offset, with a fixed page size $S$ bytes. The cache has a line size of $L$ bytes, and it uses $i$ bits from the virtual address to select a cache set (the cache index). The cache tag is checked after a Translation Lookaside Buffer (TLB) translation to the physical address. Synonyms (also called aliases) occur when two distinct virtual addresses map to the same physical address. If the index bits depend on virtual address bits outside the page offset, two synonyms may index different sets, leading to duplicate cache lines for the same physical block and incoherence.\n\nStarting only from the following fundamental definitions and facts:\n- A virtual address is composed of a virtual page number and a page offset; the page offset has $\\log_{2}(S)$ bits if the page size is $S$ bytes.\n- A cache line size of $L$ bytes implies a block offset of $\\log_{2}(L)$ bits.\n- In a VIPT cache, the set index is taken from the virtual address prior to TLB translation, while the tag is checked against the physical address after translation.\n\nDerive the constraint that ensures VIPT avoids synonym-induced set aliasing by requiring the set index bits to be entirely within the page offset. Then, express the smallest page size $S$ that guarantees this property as a single closed-form expression in terms of $i$ and $L$. Provide the expression only; do not include explanatory text in your final answer. No rounding is required. Express $S$ in bytes.",
            "solution": "The problem requires the derivation of a constraint on the page size $S$ to prevent synonym-induced set aliasing in a Virtually Indexed, Physically Tagged (VIPT) cache. This constraint is then used to find the minimum required page size.\n\nLet us begin by formalizing the structure of a virtual address and how it is used for cache indexing.\n\nA virtual address is partitioned into a virtual page number and a page offset. The page size is given as $S$ bytes. The number of bits required to address every byte within a page is the page offset. The number of bits in the page offset is therefore $\\log_{2}(S)$. These are the least significant bits of the virtual address.\n\nVirtual Address:\n$$\n\\underbrace{\\text{Virtual Page Number (VPN)}}_{\\text{...}} | \\underbrace{\\text{Page Offset}}_{\\log_{2}(S) \\text{ bits}}\n$$\n\nFor cache access, the low-order bits of the address are used to identify the byte within a cache line (block offset) and to select the cache set (set index).\nThe cache line size is given as $L$ bytes. The number of bits required for the block offset is $\\log_{2}(L)$. These are the least significant bits of the address from the cache's perspective.\nThe number of bits used for the set index is given as $i$. In a standard VIPT cache architecture, these index bits are located immediately above the block offset bits in the virtual address.\n\nVirtual Address partitioning for Cache Indexing:\n$$\n\\underbrace{\\text{Virtual Tag}}_{\\text{...}} | \\underbrace{\\text{Set Index}}_{i \\text{ bits}} | \\underbrace{\\text{Block Offset}}_{\\log_{2}(L) \\text{ bits}}\n$$\n\nThe total number of bits encompassing both the set index and the block offset is $i + \\log_{2}(L)$. These are the lowest $i + \\log_{2}(L)$ bits of the virtual address.\n\nThe core of the synonym problem in VIPT caches is that two or more different virtual addresses (synonyms) can map to the same physical address. If the cache index is derived from bits in the Virtual Page Number (VPN), these synonyms could map to different cache sets. This would allow the same block of physical memory to exist in multiple cache locations simultaneously, leading to data inconsistency.\n\nThe problem states that to avoid this, \"the set index bits must be entirely within the page offset\". The fundamental reason for this constraint is that the page offset is the only part of a virtual address that is invariant during virtual-to-physical address translation. For a virtual address $(VPN_A, \\text{offset})$, translating to a physical address $(PFN_A, \\text{offset})$, the offset bits remain unchanged.\n\nIf the set index is computed using only bits from the page offset, then any two virtual addresses that are synonyms (e.g., $(VPN_A, \\text{offset})$ and $(VPN_B, \\text{offset})$ mapping to the same physical address $(PFN_C, \\text{offset})$) will necessarily have the same page offset and thus compute the same cache set index. This ensures that a given physical block maps to exactly one cache set, resolving the aliasing issue.\n\nThe requirement that the set index bits lie entirely within the page offset bits means that all bits used for indexing must be part of the page offset. Since the block offset bits are below the index bits, this implies that the combined block of bits for both the block offset and the set index must be contained within the block of bits for the page offset.\n\nThe block offset and set index together occupy the lowest $i + \\log_{2}(L)$ bits of the virtual address.\nThe page offset occupies the lowest $\\log_{2}(S)$ bits of the virtual address.\n\nFor the former group of bits to be entirely contained within the latter, the total number of bits in the first group must be less than or equal to the total number of bits in the second group. This gives us the following inequality:\n$$\ni + \\log_{2}(L) \\le \\log_{2}(S)\n$$\nThis is the formal constraint that must be satisfied.\n\nThe problem asks for the smallest page size $S$ that guarantees this property. The smallest value for $S$ will occur at the boundary condition of this inequality, where the number of page offset bits is just large enough to contain the index and block offset bits.\n$$\n\\log_{2}(S) = i + \\log_{2}(L)\n$$\nTo solve for $S$, we can exponentiate both sides of the equation with base $2$:\n$$\n2^{\\log_{2}(S)} = 2^{(i + \\log_{2}(L))}\n$$\nUsing the properties of exponents and logarithms, $a^{\\log_a(b)} = b$ and $a^{m+n} = a^m a^n$:\n$$\nS = 2^i \\cdot 2^{\\log_{2}(L)}\n$$\n$$\nS = 2^i L\n$$\nThis expression gives the minimum page size $S$ in bytes that ensures the cache index is derived solely from the page offset, thereby preventing synonym-induced aliasing in the VIPT cache.\n\nAn alternative way to see this is that the total data space addressable by the index and offset bits is $2^{i} \\times L$ bytes. This is the product of the number of cache sets ($2^i$) and the line size ($L$). To ensure the index is determined only by the page offset, this entire addressable space must fit within a single page. This directly leads to the condition $2^i L \\le S$. The minimum value for $S$ is therefore $2^i L$.",
            "answer": "$$\\boxed{2^{i} L}$$"
        },
        {
            "introduction": "Virtual memory's power comes at a cost: the page tables that manage address translation consume precious physical memory. For applications that use memory sparsely, an inefficient page table structure can waste significant resources. This problem puts you in the role of a system designer, tasked with calculating the absolute minimum memory required for a hierarchical page table, a fundamental exercise in optimizing system overhead. ",
            "id": "3687865",
            "problem": "A computer system implements a multi-level hierarchical page table for its virtual memory. Let the virtual address space size be $V$ bytes, and the page size be $P$ bytes. Assume $V = 2^{a}$ and $P = 2^{p}$ so that the number of page-index bits is $a - p$. The multi-level page table uses $L$ levels with index bit-widths $\\{b_{1}, b_{2}, \\dots, b_{L}\\}$ such that $\\sum_{i=1}^{L} b_{i} = a - p$. Define $B_{i} = 2^{b_{i}}$ as the number of entries in a level-$i$ page table. Each page table entry size at level $i$ is $E_{i}$ bytes, and a level-$i$ page table node is stored as a contiguous block containing $B_{i}$ entries, so the memory occupied by a single level-$i$ table node is $T_{i} = B_{i} E_{i}$ bytes. The Central Processing Unit (CPU) allocates page-table nodes on demand; only the nodes necessary to map allocated pages are instantiated.\n\nConsider mapping a huge sparse region of virtual size $V$ in which only $m$ distinct pages are allocated, with $m \\geq 1$ and $m \\leq V / P$. You may arrange the $m$ allocated page numbers within the region to minimize page-table memory consumption (for example, by clustering them so they share common prefixes in the multi-level index). Assume the root (level-$1$) page table must exist if any mapping exists.\n\nStarting from the fundamental definitions of virtual memory translation and hierarchical indexing, derive a closed-form analytic expression for the minimal total page-table memory $M_{\\min}$, in bytes, required to map these $m$ pages with this $L$-level on-demand scheme, as a function of $m$, $L$, $\\{B_{i}\\}_{i=1}^{L}$, and $\\{T_{i}\\}_{i=1}^{L}$. Express your final answer in bytes. No numerical approximation or rounding is required.",
            "solution": "Let $M_{\\min}$ be the minimal total memory in bytes required for the page tables. This memory is the sum of the sizes of all allocated page table nodes across all $L$ levels. Let $N_i$ be the minimum number of level-$i$ page table nodes required to map the $m$ pages. The total memory is given by:\n$$M_{\\min} = \\sum_{i=1}^{L} N_i T_i$$\nOur goal is to find a closed-form expression for each $N_i$.\n\nThe key to minimizing the number of page table nodes is to cluster the $m$ allocated virtual pages. By making their virtual page numbers contiguous, they will share the maximum number of parent page table nodes in the upper levels of the hierarchy.\n\nWe can determine the number of required nodes, $N_i$, by reasoning from the lowest level of the page table hierarchy (level $L$) upwards to the root (level $1$).\n\n**Level $L$:**\nThe page table entries (PTEs) at level $L$ directly map the virtual pages to physical frames. A single level-$L$ page table node contains $B_L$ entries. To map $m$ distinct pages, while minimizing the number of level-$L$ tables, we must pack the mappings as densely as possible. This requires a minimum of:\n$$N_L = \\left\\lceil \\frac{m}{B_L} \\right\\rceil$$\nlevel-$L$ tables. The ceiling function, $\\lceil \\cdot \\rceil$, is used because even a single page mapping requires the allocation of a full table node.\n\n**Level $L-1$:**\nEach of the $N_L$ allocated level-$L$ tables must be pointed to by an entry in a level-$(L-1)$ table. A single level-$(L-1)$ table has $B_{L-1}$ entries and can therefore point to $B_{L-1}$ distinct level-$L$ tables. To minimize the number of level-$(L-1)$ tables, we must cluster the pointers to the $N_L$ tables. This requires:\n$$N_{L-1} = \\left\\lceil \\frac{N_L}{B_{L-1}} \\right\\rceil$$\nlevel-$(L-1)$ tables.\n\n**General Recurrence for $N_i$:**\nThis logic extends recursively up the hierarchy. The number of level-$i$ tables, $N_i$, required to point to the necessary $N_{i+1}$ tables at level-$(i+1)$ is given by:\n$$N_i = \\left\\lceil \\frac{N_{i+1}}{B_i} \\right\\rceil \\quad \\text{for } i = 1, 2, \\dots, L-1$$\n\n**Closed-Form Expression for $N_i$:**\nWe can unroll this recurrence relation to obtain a non-recursive, closed-form expression for each $N_i$ as a function of $m$. We use the mathematical property of the ceiling function that for positive integers $k_1, k_2$, $\\lceil \\lceil x / k_1 \\rceil / k_2 \\rceil = \\lceil x / (k_1 k_2) \\rceil$.\n\nStarting with $N_L$:\n$$N_L = \\left\\lceil \\frac{m}{B_L} \\right\\rceil$$\nNow for $N_{L-1}$:\n$$N_{L-1} = \\left\\lceil \\frac{N_L}{B_{L-1}} \\right\\rceil = \\left\\lceil \\frac{\\left\\lceil \\frac{m}{B_L} \\right\\rceil}{B_{L-1}} \\right\\rceil = \\left\\lceil \\frac{m}{B_{L-1} B_L} \\right\\rceil$$\nContinuing this substitution for $N_{L-2}$:\n$$N_{L-2} = \\left\\lceil \\frac{N_{L-1}}{B_{L-2}} \\right\\rceil = \\left\\lceil \\frac{\\left\\lceil \\frac{m}{B_{L-1} B_L} \\right\\rceil}{B_{L-2}} \\right\\rceil = \\left\\lceil \\frac{m}{B_{L-2} B_{L-1} B_L} \\right\\rceil$$\nThe general pattern for the number of tables at any level $i \\in \\{1, \\dots, L\\}$ is:\n$$N_i = \\left\\lceil \\frac{m}{\\prod_{j=i}^{L} B_j} \\right\\rceil$$\nLet's verify this formula for the root table at level $i=1$. The denominator is $\\prod_{j=1}^{L} B_j$. From the problem givens, $B_j = 2^{b_j}$, so the product is $\\prod_{j=1}^{L} 2^{b_j} = 2^{\\sum_{j=1}^{L} b_j}$. We are also given $\\sum_{j=1}^{L} b_j = a - p$. Thus, the product is $2^{a-p} = V/P$, which is the total number of pages in the virtual address space.\nSo, for the root table:\n$$N_1 = \\left\\lceil \\frac{m}{\\prod_{j=1}^{L} B_j} \\right\\rceil = \\left\\lceil \\frac{m}{V/P} \\right\\rceil$$\nGiven the constraint $1 \\leq m \\leq V/P$, it follows that $0 < m/(V/P) \\leq 1$. Applying the ceiling function, we find $N_1=1$. This confirms that exactly one root page table is required, which is consistent with the problem statement that \"the root (level-$1$) page table must exist if any mapping exists\" (since $m \\ge 1$).\n\n**Total Minimal Memory:**\nFinally, we substitute the closed-form expression for $N_i$ into the equation for the total memory $M_{\\min}$:\n$$M_{\\min} = \\sum_{i=1}^{L} N_i T_i = \\sum_{i=1}^{L} T_i \\left\\lceil \\frac{m}{\\prod_{j=i}^{L} B_j} \\right\\rceil$$\nThis expression represents the minimal total memory in bytes required to map $m$ pages, assuming they can be arranged optimally to maximize sharing of page table nodes. It is a function of the specified variables $m$, $L$, $\\{B_i\\}_{i=1}^{L}$, and $\\{T_i\\}_{i=1}^{L}$.",
            "answer": "$$\\boxed{\\sum_{i=1}^{L} T_i \\left\\lceil \\frac{m}{\\prod_{j=i}^{L} B_j} \\right\\rceil}$$"
        },
        {
            "introduction": "When a program accesses a virtual address not present in physical memory, a page fault occurs, triggering a complex sequence of events with a significant performance penalty. Understanding the cost of these faults is vital for performance engineering and system tuning. In this final practice, you'll act as a performance analyst, using microbenchmark data to dissect the service time of a page fault into its CPU execution and I/O components, revealing the dramatic difference between a minor and a major fault. ",
            "id": "3687783",
            "problem": "A system implements demand-paged Virtual Memory where a page fault occurs when a process accesses a virtual page that is not currently mapped to a physical frame. A minor page fault is serviced entirely in-memory (for example, by establishing page table state from existing cached data) and a major page fault requires Input/Output (I/O) to fetch the page contents from a backing store. Consider a microbenchmark that isolates the page fault handler on a single core and measures the page fault service time using the Time Stamp Counter (TSC). The processor is configured to run at a fixed frequency of $3.6 \\times 10^{9}$ \\text{Hz} by disabling dynamic frequency scaling. The backing store is a Non-Volatile Memory Express (NVMe) drive. The microbenchmark uses two workloads: one that reliably produces minor faults and one that reliably produces major faults. Average service times per fault are recorded as $t_{\\mathrm{min}} = 3.6 \\times 10^{-6}$ \\text{s} for the minor-fault workload and $t_{\\mathrm{maj}} = 4.23 \\times 10^{-4}$ \\text{s} for the major-fault workload. Using the Performance Monitoring Unit (PMU), the average Cycles Per Instruction (CPI) for the page fault handler’s kernel code path (up to the point where storage I/O would be initiated) is measured as $c = 1.2$.\n\nAssume the following model rooted in standard definitions:\n- The page fault handler executes a fixed instruction path of length $h$ (retired instructions) on both minor and major faults before any I/O is needed.\n- The wall-clock time contribution attributable to storage for a major fault, including queuing and transfer, but excluding the handler’s CPU execution, is $x$.\n\nUse the fundamental relationships between instructions, cycles, and time to estimate the handler path length $h$ and the I/O contribution $x$. Report $h$ as a pure count of instructions (a unitless number), and express $x$ in milliseconds. Round your answers to four significant figures.",
            "solution": "The core principle governing the execution time on the processor is the CPU performance equation, which relates execution time to the number of instructions, the average cycles per instruction, and the processor's clock frequency. The relationship is:\n$$\nT_{\\text{CPU}} = I \\times c \\times T_{\\text{cycle}} = \\frac{I \\times c}{f}\n$$\nwhere $T_{\\text{CPU}}$ is the CPU execution time, $I$ is the number of instructions executed, $c$ is the average Cycles Per Instruction (CPI), and $f$ is the processor clock frequency.\n\nThe problem defines a model for two types of page faults. We are asked to find the handler instruction path length, denoted by $h$, and the storage I/O time contribution, denoted by $x$.\n\nFirst, we analyze the minor page fault. The problem states that a minor fault is serviced entirely in-memory. Therefore, its total service time, $t_{\\mathrm{min}}$, consists only of the CPU time required to execute the $h$ instructions of the page fault handler. Applying the performance equation:\n$$\nt_{\\mathrm{min}} = \\frac{h \\times c}{f}\n$$\nWe can rearrange this equation to solve for the handler path length, $h$:\n$$\nh = \\frac{t_{\\mathrm{min}} \\times f}{c}\n$$\nThe problem provides the following values:\nProcessor frequency, $f = 3.6 \\times 10^{9} \\text{ Hz}$.\nAverage minor fault service time, $t_{\\mathrm{min}} = 3.6 \\times 10^{-6} \\text{ s}$.\nAverage CPI for the handler code, $c = 1.2$.\n\nSubstituting these values into the equation for $h$:\n$$\nh = \\frac{(3.6 \\times 10^{-6}) \\times (3.6 \\times 10^{9})}{1.2} = \\frac{12.96 \\times 10^{3}}{1.2} = 10.8 \\times 10^{3} = 10800\n$$\nThe result for $h$ is a pure count of instructions. The problem requires the answer to be rounded to four significant figures. To represent $10800$ with four significant figures, we write it in scientific notation as $1.080 \\times 10^{4}$.\n\nNext, we analyze the major page fault. According to the problem's model, the total service time for a major fault, $t_{\\mathrm{maj}}$, is the sum of two components: the CPU execution time for the same handler path of length $h$, and the wall-clock time $x$ attributable to storage I/O. The CPU time component is identical to the total time for a minor fault, $t_{\\mathrm{min}}$.\n$$\nt_{\\mathrm{maj}} = (\\text{CPU time}) + (\\text{I/O time}) = t_{\\mathrm{min}} + x\n$$\nWe can rearrange this equation to solve for the I/O contribution, $x$:\n$$\nx = t_{\\mathrm{maj}} - t_{\\mathrm{min}}\n$$\nThe problem provides the average major fault service time as $t_{\\mathrm{maj}} = 4.23 \\times 10^{-4} \\text{ s}$. Substituting the known values for $t_{\\mathrm{maj}}$ and $t_{\\mathrm{min}}$:\n$$\nx = (4.23 \\times 10^{-4}) - (3.6 \\times 10^{-6})\n$$\nTo perform the subtraction, we express both terms with the same power of $10$:\n$$\nx = (423 \\times 10^{-6}) - (3.6 \\times 10^{-6}) = (423 - 3.6) \\times 10^{-6} = 419.4 \\times 10^{-6} \\text{ s}\n$$\nThis can be written as $x = 4.194 \\times 10^{-4} \\text{ s}$. The problem requires the value of $x$ to be expressed in milliseconds (ms). We use the conversion factor $1 \\text{ s} = 1000 \\text{ ms} = 10^{3} \\text{ ms}$:\n$$\nx = (4.194 \\times 10^{-4} \\text{ s}) \\times (10^{3} \\text{ ms/s}) = 4.194 \\times 10^{-1} \\text{ ms} = 0.4194 \\text{ ms}\n$$\nThis result is already given to four significant figures as required.\n\nThus, the handler path length is $h = 1.080 \\times 10^{4}$ instructions, and the I/O contribution is $x = 0.4194$ ms.",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 1.080 \\times 10^{4} & 0.4194 \\end{pmatrix}}\n$$"
        }
    ]
}