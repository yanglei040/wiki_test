{
    "hands_on_practices": [
        {
            "introduction": "虚拟内存最显著的特征之一是页错误（page fault），但并非所有页错误都是一样的。本练习将带你区分“次要”和“主要”页错误的性能影响。通过一个微基准测试场景，你将运用基本的CPU性能公式，将页错误处理时间分解为纯软件执行开销和存储I/O开销，这是系统性能分析中的一项关键技能。",
            "id": "3687783",
            "problem": "一个系统实现了请求分页虚拟内存（demand-paged Virtual Memory），当一个进程访问当前未映射到物理帧的虚拟页时，会发生页面错误（page fault）。次要页面错误（minor page fault）完全在内存中处理（例如，通过从现有缓存数据建立页表状态），而主要页面错误（major page fault）需要输入/输出（I/O）从后备存储中获取页面内容。考虑一个微基准测试（microbenchmark），它在单个核心上隔离页面错误处理程序，并使用时间戳计数器（Time Stamp Counter, TSC）来测量页面错误服务时间。通过禁用动态频率缩放，处理器被配置为以 $3.6 \\times 10^{9}$ \\text{Hz} 的固定频率运行。后备存储是一个非易失性内存主机控制器接口（Non-Volatile Memory Express, NVMe）驱动器。该微基准测试使用两种工作负载：一种可靠地产生次要错误，另一种可靠地产生主要错误。对于次要错误工作负载，每个错误的平均服务时间记录为 $t_{\\mathrm{min}} = 3.6 \\times 10^{-6}$ \\text{s}；对于主要错误工作负载，记录为 $t_{\\mathrm{maj}} = 4.23 \\times 10^{-4}$ \\text{s}。使用性能监控单元（Performance Monitoring Unit, PMU），测量出页面错误处理程序的内核代码路径（直到发起存储 I/O 的点）的平均每指令周期数（Cycles Per Instruction, CPI）为 $c = 1.2$。\n\n假设以下模型基于标准定义：\n- 在需要任何 I/O 之前，页面错误处理程序在次要和主要错误上都执行一个长度为 $h$（已退役指令数）的固定指令路径。\n- 对于主要错误，归因于存储的墙上时钟时间（wall-clock time）贡献（包括排队和传输，但不包括处理程序的 CPU 执行时间）为 $x$。\n\n使用指令、周期和时间之间的基本关系来估计处理程序路径长度 $h$ 和 I/O 贡献 $x$。将 $h$ 报告为纯指令计数（一个无单位的数字），并将 $x$ 以毫秒表示。将您的答案四舍五入到四位有效数字。",
            "solution": "问题陈述经核实具有科学依据、内容完整且定义明确。它展示了计算机体系结构和操作系统中一个标准的性能分析场景，使用了合理的数值和一个清晰定义的模型。因此，我们可以进行正式求解。\n\n控制处理器执行时间的核心原理是 CPU 性能方程，它将执行时间与指令数、平均每指令周期数以及处理器的时钟频率联系起来。该关系式为：\n$$\nT_{\\text{CPU}} = I \\times c \\times T_{\\text{cycle}} = \\frac{I \\times c}{f}\n$$\n其中 $T_{\\text{CPU}}$ 是 CPU 执行时间，$I$ 是执行的指令数，$c$ 是平均每指令周期数（CPI），$f$ 是处理器时钟频率。\n\n问题为两种类型的页面错误定义了一个模型。我们被要求找出处理程序指令路径长度（用 $h$ 表示）和存储 I/O 时间贡献（用 $x$ 表示）。\n\n首先，我们分析次要页面错误。问题指出，次要错误完全在内存中处理。因此，其总服务时间 $t_{\\mathrm{min}}$ 仅包含执行页面错误处理程序的 $h$ 条指令所需的 CPU 时间。应用性能方程：\n$$\nt_{\\mathrm{min}} = \\frac{h \\times c}{f}\n$$\n我们可以重新排列这个方程来求解处理程序路径长度 $h$：\n$$\nh = \\frac{t_{\\mathrm{min}} \\times f}{c}\n$$\n问题提供了以下数值：\n处理器频率，$f = 3.6 \\times 10^{9} \\text{ Hz}$。\n次要错误的平均服务时间，$t_{\\mathrm{min}} = 3.6 \\times 10^{-6} \\text{ s}$。\n处理程序代码的平均 CPI，$c = 1.2$。\n\n将这些值代入 $h$ 的方程中：\n$$\nh = \\frac{(3.6 \\times 10^{-6}) \\times (3.6 \\times 10^{9})}{1.2} = \\frac{12.96 \\times 10^{3}}{1.2} = 10.8 \\times 10^{3} = 10800\n$$\n$h$ 的结果是纯指令计数。问题要求答案四舍五入到四位有效数字。为了用四位有效数字表示 $10800$，我们将其写成科学记数法 $1.080 \\times 10^{4}$。\n\n接下来，我们分析主要页面错误。根据问题的模型，主要错误的总服务时间 $t_{\\mathrm{maj}}$ 是两个组成部分之和：执行相同长度为 $h$ 的处理程序路径所需的 CPU 执行时间，以及归因于存储 I/O 的墙上时钟时间 $x$。CPU 时间部分与处理一个次要错误的总时间 $t_{\\mathrm{min}}$ 相同。\n$$\nt_{\\mathrm{maj}} = (\\text{CPU 时间}) + (\\text{I/O 时间}) = t_{\\mathrm{min}} + x\n$$\n我们可以重新排列这个方程来求解 I/O 贡献 $x$：\n$$\nx = t_{\\mathrm{maj}} - t_{\\mathrm{min}}\n$$\n问题提供的平均主要错误服务时间为 $t_{\\mathrm{maj}} = 4.23 \\times 10^{-4} \\text{ s}$。将 $t_{\\mathrm{maj}}$ 和 $t_{\\mathrm{min}}$ 的已知值代入：\n$$\nx = (4.23 \\times 10^{-4}) - (3.6 \\times 10^{-6})\n$$\n为了进行减法运算，我们将两项表示为相同的 $10$ 的幂次方：\n$$\nx = (423 \\times 10^{-6}) - (3.6 \\times 10^{-6}) = (423 - 3.6) \\times 10^{-6} = 419.4 \\times 10^{-6} \\text{ s}\n$$\n这可以写成 $x = 4.194 \\times 10^{-4} \\text{ s}$。问题要求将 $x$ 的值以毫秒（ms）表示。我们使用转换因子 $1 \\text{ s} = 1000 \\text{ ms} = 10^{3} \\text{ ms}$：\n$$\nx = (4.194 \\times 10^{-4} \\text{ s}) \\times (10^{3} \\text{ ms/s}) = 4.194 \\times 10^{-1} \\text{ ms} = 0.4194 \\text{ ms}\n$$\n这个结果已经按要求给出了四位有效数字。\n\n因此，处理程序路径长度为 $h = 1.080 \\times 10^{4}$ 条指令，I/O 贡献为 $x = 0.4194$ ms。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 1.080 \\times 10^{4} & 0.4194 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "在分析了页错误的代价之后，让我们亲手实现一个能够触发这类错误的系统。内存保护是虚拟内存的核心功能之一，本练习将指导你构建一个虚拟内存沙盒的模拟器。你将通过设置“哨兵页”（guard pages）和动态调整访问权限来捕捉内存访问错误，从而直观地体验操作系统是如何强制实施内存安全的。",
            "id": "3687808",
            "problem": "您需要为一个学生分配器构建一个精确的虚拟内存沙箱模拟器，该分配器使用哨兵页来检测缓冲区溢出，并带有一个故障注入机制，该机制能在运行时翻转访问权限并对段错误进行计数。该模拟器必须纯粹在软件中使用基于页面的模型运行，并强制执行以下规范。\n\n1. 使用的基本原则和定义：\n   - 虚拟内存概念上被划分为大小相等的页面。设页面大小为 $p$ 字节。内存是由 $N$ 个页面组成的序列，索引从 $0$ 到 $N-1$。一个 $B$ 字节的分配请求向上取整以占据 $r$ 个页面，其中 $r = \\lceil B / p \\rceil$。\n   - 哨兵页是放置在已分配区域旁边且没有访问权限的页面。它们应能检测到任何越界访问。当一个进程访问了当前页面保护状态所不允许的地址时，就会发生一个典型的虚拟内存故障，例如段错误（SIGSEGV）。\n   - 在此模拟器中，段错误被作为事件计数。没有实际的信号处理；相反，每次非法访问都会使一个计数器递增。对于每个内存操作，如果该操作的任何字节位于没有足够权限的页面上，则该操作将被记录一次违规，并且该访问被视为原子性失败（没有部分成功）。\n\n2. 模拟器模型：\n   - 为区域精确分配 $r$ 个连续页面，并带有一个左哨兵页和一个右哨兵页。分配的区域从页面索引 $s$ 开始，跨越页面 $s, s+1, \\dots, s+r-1$。左哨兵页是页面 $s-1$，右哨兵页是页面 $s+r$。保证 $N \\ge s + r + 1$ 且 $s \\ge 1$，因此两个哨兵页都在界限内存在。所有区域页面初始时都具有读写权限；两个哨兵页始终无访问权限，且不能通过权限翻转来更改。\n   - 模拟器处理一系列操作。每个操作都是一次读取或写入，带有相对于虚拟地址 $0$ 处区域基址的字节偏移量和长度。偏移量在区域内是基于 $0$ 的。对于偏移量为 $x$ 且长度为 $\\ell$ 的操作：\n     - 如果 $\\ell = 0$，则该操作为空操作，无论 $x$ 为何值，都不会导致违规。\n     - 否则，该操作会触及从 $x$到 $x + \\ell - 1$ 的每个字节。触及的虚拟页面集合为\n       $$\\left\\{ \\left\\lfloor \\frac{x}{p} \\right\\rfloor, \\left\\lfloor \\frac{x+1}{p} \\right\\rfloor, \\dots, \\left\\lfloor \\frac{x+\\ell-1}{p} \\right\\rfloor \\right\\}.$$\n       如果任何触及的页面索引 $k$ 满足 $k  0$ 或 $k \\ge r$，则访问与哨兵页重叠并导致违规。否则，对于每个触及的区域页面 $k$：\n       - 读取操作要求页面的权限至少为只读。\n       - 写入操作要求页面的权限为读写。\n       如果任何页面不满足要求，该操作将导致一次违规。\n   - 故障注入（权限翻转）被建模为在执行特定操作之前，对特定区域页面的权限进行的瞬时更改。一次翻转指定一个操作索引 $t$（基于 $0$ 的操作列表索引）、一个区域页面索引 $i$（$0 \\le i \\le r-1$）以及该页面的新权限（$\\text{NOACCESS}$、$\\text{READONLY}$ 或 $\\text{READWRITE}$）。翻转在检查相应操作之前应用。在同一次操作前可能会发生多次翻转；按任意顺序应用所有翻转（如果对同一页面发生多次翻转，它们是可交换的，输入集中针对该 $t$ 和 $i$ 的最后一个规范会生效）。\n   - 每个失败的操作会使违规计数器增加 $1$。单个操作即使涉及多个无效页面，计数器增加也不会超过 $1$。\n\n3. 程序要求：\n   - 您的程序必须精确实现上述模拟器。\n   - 它必须在没有任何输入的情况下运行，并产生单行输出，格式如下：方括号内包含一个逗号分隔的整数列表，按顺序代表每个给定测试用例的违规计数，例如，“[v1,v2,v3]”。\n   - 所有数值计算必须使用整数算术精确进行，页面计算必须使用定义的向下取整和向上取整函数：$r = \\lceil B / p \\rceil = \\left\\lfloor \\frac{B + p - 1}{p} \\right\\rfloor$ 以及对于任何字节地址 $a$，$k = \\left\\lfloor \\frac{a}{p} \\right\\rfloor$。\n\n4. 测试套件：\n   对于每个测试用例，请严格按照指定的参数和序列进行。区域基址始终位于虚拟地址 $0$ 处，意味着偏移量 $0$ 表示页面 $s$ 的第一个字节。\n\n   - 测试用例 A（正常路径，包含溢出和运行时权限翻转）：\n     - $N = 8$, $p = 1024$, $B = 1500$, $r = \\lceil 1500/1024 \\rceil = 2$, $s = 1$。\n     - 区域页面的初始权限：均为读写。\n     - 操作（按顺序，基于 $0$ 的索引）：\n       1. 在偏移量 $x = 500$ 处读取，长度 $\\ell = 100$。\n       2. 在偏移量 $x = 900$ 处写入，长度 $\\ell = 200$。\n       3. 在偏移量 $x = 100$ 处写入，长度 $\\ell = 1$。\n       4. 在偏移量 $x = 2047$ 处读取，长度 $\\ell = 1$。\n       5. 在偏移量 $x = 2048$ 处读取，长度 $\\ell = 1$。\n       6. 在偏移量 $x = 1900$ 处写入，长度 $\\ell = 200$。\n     - 翻转：\n       - 在操作 $t = 2$ 之前，将区域页面 $i = 0$ 设置为只读。\n\n   - 测试用例 B（跨页面边缘的边界条件）：\n     - $N = 6$, $p = 4096$, $B = 8192$, $r = \\lceil 8192/4096 \\rceil = 2$, $s = 1$。\n     - 区域页面的初始权限：均为读写。\n     - 操作：\n       1. 在 $x = 4095$ 处读取, $\\ell = 1$。\n       2. 在 $x = 4096$ 处写入, $\\ell = 1$。\n       3. 在 $x = 8191$ 处读取, $\\ell = 1$。\n       4. 在 $x = 8190$ 处写入, $\\ell = 2$。\n       5. 在 $x = 8180$ 处写入, $\\ell = 100$。\n     - 翻转：\n       - 在操作 $t = 1$ 之前，将区域页面 $i = 1$ 设置为只读。\n\n   - 测试用例 C（多重翻转，包含撤销和恢复）：\n     - $N = 16$, $p = 1024$, $B = 4096$, $r = \\lceil 4096/1024 \\rceil = 4$, $s = 1$。\n     - 区域页面的初始权限：均为读写。\n     - 操作：\n       1. 在 $x = 3000$ 处读取, $\\ell = 50$。\n       2. 在 $x = 3072$ 处写入, $\\ell = 50$。\n       3. 在 $x = 2500$ 处读取, $\\ell = 100$。\n       4. 在 $x = 4095$ 处写入, $\\ell = 2$。\n       5. 在 $x = 2600$ 处写入, $\\ell = 10$。\n       6. 在 $x = 1023$ 处读取, $\\ell = 2$。\n       7. 在 $x = 1500$ 处写入, $\\ell = 10$。\n     - 翻转：\n       - 在 $t = 2$ 之前，将页面 $i = 2$ 设置为无访问权限。\n       - 在 $t = 4$ 之前，将页面 $i = 2$ 设置为读写。\n       - 在 $t = 6$ 之前，将页面 $i = 1$ 设置为只读。\n\n   - 测试用例 D（零长度操作和后期翻转）：\n     - $N = 5$, $p = 512$, $B = 700$, $r = \\lceil 700/512 \\rceil = 2$, $s = 1$。\n     - 区域页面的初始权限：均为读写。\n     - 操作：\n       1. 在 $x = 0$ 处读取, $\\ell = 0$。\n       2. 在 $x = 511$ 处写入, $\\ell = 1$。\n       3. 在 $x = 1024$ 处读取, $\\ell = 0$。\n       4. 在 $x = 1023$ 处写入, $\\ell = 2$。\n       5. 在 $x = 10$ 处读取, $\\ell = 1$。\n       6. 在 $x = 100$ 处读取, $\\ell = 10$。\n       7. 在 $x = 300$ 处写入, $\\ell = 0$。\n     - 翻转：\n       - 在 $t = 5$ 之前，将页面 $i = 0$ 设置为无访问权限。\n\n5. 要求的最终输出格式：\n   - 您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须包含四个整数，分别对应测试用例A、B、C和D的违规计数，顺序如下，例如，“[vA,vB,vC,vD]”。",
            "solution": "问题陈述为虚拟内存沙箱模拟器提供了详细的规范。验证其前提是必要的第一步。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n\n- **内存模型**：虚拟内存被划分为 $N$ 个大小为 $p$ 字节的页面，索引范围为 $0$ 到 $N-1$。一次 $B$ 字节的分配占用 $r$ 个页面，其中 $r = \\lceil B / p \\rceil$。\n- **分配布局**：一次 $r$ 个页面的分配从页面索引 $s$ 开始。分配的区域跨越页面 $s, s+1, \\dots, s+r-1$。页面 $s-1$ 是左哨兵页，页面 $s+r$ 是右哨兵页。保证 $N \\ge s + r + 1$ 和 $s \\ge 1$。\n- **权限**：区域页面初始为读写。哨兵页始终为无访问权限。权限可以是$\\text{NOACCESS}$、$\\text{READONLY}$或$\\text{READWRITE}$。\n- **操作**：一个操作是读取或写入，由相对于区域基址的字节偏移量 $x$ 和长度 $\\ell$ 指定。\n- **违规条件**：每个操作如果出现以下任一情况，则记录一次违规：\n    1. 操作长度 $\\ell > 0$ 且访问的字节映射到页面索引 $k$ 满足 $k  0$ 或 $k \\ge r$。这构成了对哨兵页区域的访问（或更普遍地说，超出了分配的区域）。触及的相对于区域的页面索引集合是 $\\left\\{ \\left\\lfloor \\frac{x}{p} \\right\\rfloor, \\dots, \\left\\lfloor \\frac{x+\\ell-1}{p} \\right\\rfloor \\right\\}$。\n    2. 读取操作（$\\ell > 0$）试图访问一个权限不是至少为$\\text{READONLY}$的页面。\n    3. 写入操作（$\\ell > 0$）试图访问一个权限不是$\\text{READWRITE}$的页面。\n- **特殊情况**：长度 $\\ell = 0$ 的操作是空操作，永远不会引起违规。单个操作最多引起一次违规。\n- **故障注入（翻转）**：翻转会在执行特定操作 $t$（0-based）之前，将区域页面 $i$（$0 \\le i \\le r-1$）的权限更改为新状态。\n- **计算规则**：$r = \\left\\lfloor \\frac{B + p - 1}{p} \\right\\rfloor$ 且区域内字节地址 $a$ 的页面索引为 $k = \\left\\lfloor \\frac{a}{p} \\right\\rfloor$。\n- **测试用例**：提供了四个具体的测试用例（A、B、C、D），包含了所有必要的参数（$N, p, B, s$、操作和翻转）。\n\n**步骤2：使用提取的已知条件进行验证**\n\n根据验证标准对问题进行审查。\n\n- **科学性**：该问题描述了一个简化但概念上合理的模型，涵盖了分页虚拟内存、内存保护（保护位）和段错误（SIGSEGV）。哨兵页是内存分配器中用于检测缓冲区溢出的一种标准技术（类似金丝雀值）。该模型是对现实世界计算机体系结构原理的有效抽象。\n- **适定性**：问题定义明确。计算页面数量、识别触及页面、检查权限和计算故障的规则是明确且无歧义的。测试用例的所有参数都已提供，确保每个案例都有唯一、确定性的结果（违规次数）。例如，单个操作最多使违规计数器增加1的规则解决了单个操作内可能发生多个故障的模糊性。\n- **客观性**：问题以客观、技术性的语言表述。术语如‘页面’、‘偏移量’、‘权限’和‘违规’在模拟的上下文中都有明确的定义。\n\n该问题没有表现出任何使之无效的缺陷：\n1. **科学或事实上的不健全**：该模型是一个有效的、简化的抽象，并未违反原则。\n2. **非形式化或不相关**：该模型是纯形式化的，与计算机组成和体系结构直接相关。\n3. **不完整或矛盾的设置**：所有必要的数据都已提供。规则内部一致。\n4. **不切实际或不可行**：模拟参数是抽象的，不必与物理系统相对应。它们在数学上是一致的。\n5. **不适定或结构不良**：问题的结构旨在产生唯一、可计算的解决方案。\n6. **伪深刻、琐碎或同义反复**：该问题需要仔细、逐步的模拟，并非 trivial。它测试了对所定义内存模型的清晰理解。\n7. **超出科学可验证性**：结果可以通过算法推导，并根据指定规则通过手工跟踪模拟进行验证。\n\n**步骤3：结论与行动**\n\n此问题是**有效的**。将提供一个解决方案。\n\n### 解决方案\n\n模拟将通过建模已分配内存页面的状态并顺序处理每个操作来进行。设权限以数字表示：$\\text{NOACCESS} = 0$，$\\text{READONLY} = 1$，$\\text{READWRITE} = 2$。如果页面的权限级别大于或等于所需的权限级别（其中读取需要 $1$，写入需要 $2$），则访问有效。\n\n一个大小为 $r$ 的数组 `perms` 将存储区域页面的权限。对于每个操作，我们首先应用任何指定的权限翻转。然后，我们确定该操作触及的页面范围。如果此范围包含 $[0, r-1]$ 之外的页面，或者区域内任何被触及的页面没有足够的权限，则发生违规。\n\n#### 测试用例 A 的分析\n\n- 参数：$p=1024$, $B=1500$。\n- 区域页面：$r = \\lceil 1500 / 1024 \\rceil = \\lfloor (1500 + 1024 - 1)/1024 \\rfloor = \\lfloor 2523/1024 \\rfloor = 2$。区域由页面 $0$ 和 $1$ 组成。\n- 初始状态：`perms[0] = READWRITE (2)`，`perms[1] = READWRITE (2)`。违规计数 $V=0$。\n\n1.  **操作 $0$ ($t=0$)：读取, $x=500, \\ell=100$。**\n    - 无翻转。字节范围：$[500, 599]$。\n    - 触及页面：从 $\\lfloor 500/1024 \\rfloor = 0$ 到 $\\lfloor 599/1024 \\rfloor = 0$。页面集：$\\{0\\}$。\n    - 页面 $0$ 在区域 $[0, 2)$ 内。正常。\n    - 页面 $0$ 的权限为 $\\text{READWRITE} \\ge \\text{READONLY}$。正常。无违规。$V=0$。\n2.  **操作 $1$ ($t=1$)：写入, $x=900, \\ell=200$。**\n    - 无翻转。字节范围：$[900, 1099]$。\n    - 触及页面：从 $\\lfloor 900/1024 \\rfloor = 0$ 到 $\\lfloor 1099/1024 \\rfloor = 1$。页面集：$\\{0, 1\\}$。\n    - 页面 $0, 1$ 在区域内。正常。\n    - 页面 $0, 1$ 的权限为 $\\text{READWRITE} \\ge \\text{READWRITE}$。正常。无违规。$V=0$。\n3.  **操作 $2$ ($t=2$)：写入, $x=100, \\ell=1$。**\n    - **翻转**：在操作2之前，将区域页面 $i=0$ 设置为 $\\text{READONLY}$。状态：`perms[0] = READONLY (1)`，`perms[1] = READWRITE (2)`。\n    - 字节范围：$[100, 100]$。触及页面：$\\{0\\}$。\n    - 页面 $0$ 在区域内。正常。\n    - 页面 $0$ 的权限为 $\\text{READONLY}$，但写入需要 $\\text{READWRITE}$。由于 $1  2$，这是**违规**。$V=1$。\n4.  **操作 $3$ ($t=3$)：读取, $x=2047, \\ell=1$。**\n    - 无翻转。字节范围：$[2047, 2047]$。触及页面：$\\{\\lfloor 2047/1024 \\rfloor\\} = \\{1\\}$。\n    - 页面 $1$ 在区域内。正常。\n    - 页面 $1$ 的权限为 $\\text{READWRITE} \\ge \\text{READONLY}$。正常。无违规。$V=1$。\n5.  **操作 $4$ ($t=4$)：读取, $x=2048, \\ell=1$。**\n    - 无翻转。字节范围：$[2048, 2048]$。触及页面：$\\{\\lfloor 2048/1024 \\rfloor\\} = \\{2\\}$。\n    - 页面 $2$ 不在区域 $[0, 2)$ 内，触及右哨兵页区域。**违规**。$V=2$。\n6.  **操作 $5$ ($t=5$)：写入, $x=1900, \\ell=200$。**\n    - 无翻转。字节范围：$[1900, 2099]$。\n    - 触及页面：从 $\\lfloor 1900/1024 \\rfloor = 1$到 $\\lfloor 2099/1024 \\rfloor = 2$。页面集：$\\{1, 2\\}$。\n    - 页面 $2$ 不在区域 $[0, 2)$ 内，触及右哨兵页区域。**违规**。$V=3$。\n\n- 用例 A 的最终违规计数：**3**。\n\n#### 测试用例 B 的分析\n\n- 参数：$p=4096$, $B=8192$。\n- 区域页面：$r = \\lceil 8192 / 4096 \\rceil = 2$。区域由页面 $0$ 和 $1$ 组成。\n- 初始状态：`perms[0] = READWRITE (2)`，`perms[1] = READWRITE (2)`。$V=0$。\n\n1.  **操作 $0$ ($t=0$)：读取, $x=4095, \\ell=1$。** 无违规。$V=0$。\n2.  **操作 $1$ ($t=1$)：写入, $x=4096, \\ell=1$。**\n    - **翻转**：在操作1之前，将页面 $i=1$ 设置为 $\\text{READONLY}$。状态：`perms[0] = READWRITE (2)`，`perms[1] = READONLY (1)`。\n    - 触及页面 $\\{1\\}$。页面 $1$ 的权限为 $\\text{READONLY}$，但写入需要 $\\text{READWRITE}$。**违规**。$V=1$。\n3.  **操作 $2$ ($t=2$)：读取, $x=8191, \\ell=1$。** 触及页面 $\\{1\\}$。权限为 $\\text{READONLY} \\ge \\text{READONLY}$。正常。无违规。$V=1$。\n4.  **操作 $3$ ($t=3$)：写入, $x=8190, \\ell=2$。** 触及页面 $\\{1\\}$。页面 $1$ 的权限为 $\\text{READONLY}$，但写入需要 $\\text{READWRITE}$。**违规**。$V=2$。\n5.  **操作 $4$ ($t=4$)：写入, $x=8180, \\ell=100$。** 字节范围 $[8180, 8279]$。触及页面 $\\{\\lfloor 8180/4096 \\rfloor, \\dots, \\lfloor 8279/4096 \\rfloor\\} = \\{1, 2\\}$。页面 $2$ 越界。**违规**。$V=3$。\n\n- 用例 B 的最终违规计数：**3**。\n\n#### 测试用例 C 的分析\n\n- 参数：$p=1024$, $B=4096$。\n- 区域页面：$r = \\lceil 4096 / 1024 \\rceil = 4$。区域由页面 $0, 1, 2, 3$ 组成。\n- 初始状态：`perms[0..3] = READWRITE (2)`。$V=0$。\n\n1.  **操作 $0$ ($t=0$)：读取, $x=3000, \\ell=50$。** 触及页面 $\\{2\\}$。正常。$V=0$。\n2.  **操作 $1$ ($t=1$)：写入, $x=3072, \\ell=50$。** 触及页面 $\\{3\\}$。正常。$V=0$。\n3.  **操作 $2$ ($t=2$)：读取, $x=2500, \\ell=100$。**\n    - **翻转**：在操作2之前，将页面 $i=2$ 设置为 $\\text{NOACCESS}$。状态：`perms[2] = NOACCESS (0)`。\n    - 触及页面 $\\{2\\}$。权限为 $\\text{NOACCESS}$，但读取需要 $\\text{READONLY}$。**违规**。$V=1$。\n4.  **操作 $3$ ($t=3$)：写入, $x=4095, \\ell=2$。** 字节范围 $[4095, 4096]$。触及页面 $\\{3, 4\\}$。页面 $4$ 越界。**违规**。$V=2$。\n5.  **操作 $4$ ($t=4$)：写入, $x=2600, \\ell=10$。**\n    - **翻转**：在操作4之前，将页面 $i=2$ 设置为 $\\text{READWRITE}$。状态：`perms[2] = READWRITE (2)`。\n    - 触及页面 $\\{2\\}$。权限现在是 $\\text{READWRITE}$。正常。无违规。$V=2$。\n6.  **操作 $5$ ($t=5$)：读取, $x=1023, \\ell=2$。** 触及页面 $\\{0, 1\\}$。正常。$V=2$。\n7.  **操作 $6$ ($t=6$)：写入, $x=1500, \\ell=10$。**\n    - **翻转**：在操作6之前，将页面 $i=1$ 设置为 $\\text{READONLY}$。状态：`perms[1] = READONLY (1)`。\n    - 触及页面 $\\{1\\}$。权限为 $\\text{READONLY}$，但写入需要 $\\text{READWRITE}$。**违规**。$V=3$。\n\n- 用例 C 的最终违规计数：**3**。\n\n#### 测试用例 D 的分析\n\n- 参数：$p=512$, $B=700$。\n- 区域页面：$r = \\lceil 700 / 512 \\rceil = 2$。区域由页面 $0, 1$ 组成。\n- 初始状态：`perms[0] = READWRITE (2)`，`perms[1] = READWRITE (2)`。$V=0$。\n\n1.  **操作 $0$ ($t=0$)：读取, $x=0, \\ell=0$。** 长度为 $0$，空操作。无违规。$V=0$。\n2.  **操作 $1$ ($t=1$)：写入, $x=511, \\ell=1$。** 触及页面 $\\{0\\}$。正常。$V=0$。\n3.  **操作 $2$ ($t=2$)：读取, $x=1024, \\ell=0$。** 长度为 $0$，空操作。无违规。$V=0$。\n4.  **操作 $3$ ($t=3$)：写入, $x=1023, \\ell=2$。** 字节范围 $[1023, 1024]$。区域大小为 $2 \\times 512 = 1024$ 字节。最大偏移量是 $1023$。触及页面 $\\{1, 2\\}$。页面 $2$ 越界。**违规**。$V=1$。\n5.  **操作 $4$ ($t=4$)：读取, $x=10, \\ell=1$。** 触及页面 $\\{0\\}$。正常。$V=1$。\n6.  **操作 $5$ ($t=5$)：读取, $x=100, \\ell=10$。**\n    - **翻转**：在操作5之前，将页面 $i=0$ 设置为 $\\text{NOACCESS}$。状态：`perms[0] = NOACCESS (0)`。\n    - 触及页面 $\\{0\\}$。权限为 $\\text{NOACCESS}$，但读取需要 $\\text{READONLY}$。**违规**。$V=2$。\n7.  **操作 $6$ ($t=6$)：写入, $x=300, \\ell=0$。** 长度为 $0$，空操作。无违规。$V=2$。\n\n- 用例 D 的最终违规计数：**2**。\n\n最终结果总结：[3, 3, 3, 2]。",
            "answer": "[3,3,3,2]"
        },
        {
            "introduction": "虚拟内存并非孤立存在，它必须与缓存等其他关键硬件协同工作。本练习将探讨虚拟地址对“虚实映射缓存”（Virtually Indexed, Physically Tagged, VIPT Caches）带来的挑战，特别是“别名”（aliasing）问题。通过推导页面大小与缓存结构之间的设计约束，你将理解为了确保系统正确性，硬件设计者必须遵循的基本原则。",
            "id": "3687877",
            "problem": "一个处理器实现了一个一级（L1）数据缓存，该缓存是虚拟索引、物理标记（VIPT）的。虚拟内存系统将虚拟地址划分为虚拟页号和页内偏移量，页面大小固定为 $S$ 字节。该缓存的缓存行大小为 $L$ 字节，并使用虚拟地址中的 $i$ 位来选择缓存组（即缓存索引）。缓存标记在通过转译后备缓冲器（TLB）转换为物理地址后进行检查。当两个不同的虚拟地址映射到同一个物理地址时，就会出现同义词（也称为别名）问题。如果索引位依赖于页内偏移量之外的虚拟地址位，那么两个同义词可能会索引到不同的组，导致同一物理块存在重复的缓存行，从而引发不一致性。\n\n仅从以下基本定义和事实出发：\n- 虚拟地址由虚拟页号和页内偏移量组成；如果页面大小为 $S$ 字节，则页内偏移量有 $\\log_{2}(S)$ 位。\n- 缓存行大小为 $L$ 字节意味着块内偏移量有 $\\log_{2}(L)$ 位。\n- 在VIPT缓存中，组索引在TLB转换之前从虚拟地址中提取，而标记在转换后与物理地址进行比较检查。\n\n推导出一个约束条件，通过要求组索引位完全位于页内偏移量之内，来确保VIPT缓存避免由同义词引起的组别名问题。然后，将保证此属性的最小页面大小 $S$ 表示为关于 $i$ 和 $L$ 的单个封闭形式表达式。仅提供表达式；最终答案中不要包含解释性文字。无需四舍五入。以字节为单位表示 $S$。",
            "solution": "该问题要求推导对页面大小 $S$ 的一个约束条件，以防止在虚拟索引、物理标记（VIPT）缓存中由同义词引起的组别名问题。然后利用这个约束条件来找到所需的最小页面大小。\n\n让我们首先形式化虚拟地址的结构以及它如何用于缓存索引。\n\n一个虚拟地址被划分为虚拟页号和页内偏移量。页面大小为 $S$ 字节。在页面内寻址每个字节所需的位数就是页内偏移量。因此，页内偏移量的位数为 $\\log_{2}(S)$。这些是虚拟地址的最低有效位。\n\n虚拟地址：\n$$\n\\underbrace{\\text{Virtual Page Number (VPN)}}_{\\text{...}} | \\underbrace{\\text{Page Offset}}_{\\log_{2}(S) \\text{ bits}}\n$$\n\n对于缓存访问，地址的低位比特用于识别缓存行内的字节（块内偏移量）和选择缓存组（组索引）。\n缓存行大小为 $L$ 字节。块内偏移量所需的位数为 $\\log_{2}(L)$。从缓存的角度来看，这些是地址的最低有效位。\n用于组索引的位数为 $i$。在标准的VIPT缓存架构中，这些索引位位于虚拟地址中紧邻块内偏移位之上的位置。\n\n用于缓存索引的虚拟地址划分：\n$$\n\\underbrace{\\text{Virtual Tag}}_{\\text{...}} | \\underbrace{\\text{Set Index}}_{i \\text{ bits}} | \\underbrace{\\text{Block Offset}}_{\\log_{2}(L) \\text{ bits}}\n$$\n\n包含组索引和块内偏移量的总位数为 $i + \\log_{2}(L)$。这些是虚拟地址的最低 $i + \\log_{2}(L)$ 位。\n\nVIPT缓存中同义词问题的核心在于，两个或多个不同的虚拟地址（同义词）可以映射到同一个物理地址。如果缓存索引是根据虚拟页号（VPN）中的位派生出来的，那么这些同义词可能会映射到不同的缓存组。这将允许同一物理内存块同时存在于多个缓存位置，从而导致数据不一致。\n\n问题指出，为避免这种情况，“组索引位必须完全位于页内偏移量之内”。这个约束的根本原因在于，页内偏移量是虚拟地址在虚拟到物理地址转换过程中唯一不变的部分。对于一个虚拟地址 $(VPN_A, \\text{offset})$，当它转换为物理地址 $(PFN_A, \\text{offset})$ 时，偏移量位保持不变。\n\n如果组索引仅使用页内偏移量的位来计算，那么任何两个互为同义词的虚拟地址（例如，映射到同一物理地址 $(PFN_C, \\text{offset})$ 的 $(VPN_A, \\text{offset})$ 和 $(VPN_B, \\text{offset})$）必然具有相同的页内偏移量，因此会计算出相同的缓存组索引。这确保了给定的物理块只映射到一个缓存组，从而解决了别名问题。\n\n“组索引位完全位于页内偏移位之内”的要求意味着所有用于索引的位都必须是页内偏移量的一部分。由于块内偏移位位于索引位之下，这意味着块内偏移和组索引的组合位块必须被包含在页内偏移的位块之内。\n\n块内偏移和组索引共同占据了虚拟地址的最低 $i + \\log_{2}(L)$ 位。\n页内偏移占据了虚拟地址的最低 $\\log_{2}(S)$ 位。\n\n为了使前一组位完全包含在后一组位之内，第一组的总位数必须小于或等于第二组的总位数。这给了我们以下不等式：\n$$\ni + \\log_{2}(L) \\le \\log_{2}(S)\n$$\n这就是必须满足的形式化约束条件。\n\n问题要求保证此属性的最小页面大小 $S$。当不等式处于边界条件时，$S$ 的值最小，此时页内偏移量的位数刚好足够包含索引位和块内偏移位。\n$$\n\\log_{2}(S) = i + \\log_{2}(L)\n$$\n为了解出 $S$，我们可以对等式两边取以2为底的指数：\n$$\n2^{\\log_{2}(S)} = 2^{(i + \\log_{2}(L))}\n$$\n利用指数和对数的性质，$a^{\\log_a(b)} = b$ 和 $a^{m+n} = a^m a^n$：\n$$\nS = 2^i \\cdot 2^{\\log_{2}(L)}\n$$\n$$\nS = 2^i L\n$$\n该表达式给出了以字节为单位的最小页面大小 $S$，它能确保缓存索引完全从页内偏移量派生，从而防止VIPT缓存中由同义词引起的别名问题。\n\n另一种理解方式是，由索引和偏移位可寻址的总数据空间为 $2^{i} \\times L$ 字节。这是缓存组数（$2^i$）和缓存行大小（$L$）的乘积。为确保索引仅由页内偏移量决定，这个整个可寻址空间必须能容纳在一个页面内。这直接导出了条件 $2^i L \\le S$。因此，$S$ 的最小值为 $2^i L$。",
            "answer": "$$\\boxed{2^{i} L}$$"
        }
    ]
}