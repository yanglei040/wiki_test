{
    "hands_on_practices": [
        {
            "introduction": "要真正掌握页面置换算法，亲手模拟它们的行为至关重要。本练习将引导你对比两种里程碑式的算法：理论上完美的“最优”（OPT）算法和实践中广泛应用的“最近最少使用”（LRU）算法。通过在同一个引用序列上执行这两种策略，你将直观地理解基于历史预测（LRU）与拥有完美未来视野（OPT）之间的性能差距，并为评估其他所有实际算法建立一个黄金标准。",
            "id": "3663525",
            "problem": "考虑一个具有固定数量物理帧的虚拟内存系统，一个单一进程生成一个页面引用串。该系统使用请求分页，每次访问时，如果引用的页面不在任何物理帧中，就会发生页面错误。当需要替换时，系统可以使用不同的页面替换策略，其核心定义如下。\n\n使用的基本定义：\n- 页面引用串是一个有序的页号序列，表示为 $R = (r_{1}, r_{2}, \\dots, r_{N})$，其中 $N$ 是序列的长度，每个 $r_{i}$ 是一个页面的正整数标签。\n- 物理内存有 $F$ 个帧，每个帧可以容纳一个页面。\n- 每当引用的页面 $r_{i}$ 在引用时不存在于 $F$ 个帧中的任何一个时，就会发生页面错误。\n- 最近最少使用 (LRU) 替换，全称为 Least Recently Used (LRU)，淘汰当前驻留页面中，其最近一次过去使用（在引用串中向后看）时间距离现在最远的页面。\n- 最佳页面替换 (OPT) 淘汰其下一次使用（在引用串中向前看）时间在最遥远的未来，或者永远不会再被使用的页面。为使该过程在下一次使用距离出现平局时明确定义，当两个或多个页面的最远下一次使用距离相等时，淘汰数值标签最小的页面。\n\n给定 $F = 3$ 个帧和页面引用串\n$$\nR = (2, 3, 2, 1, 5, 2, 4, 1, 2, 3, 7, 2, 6, 1, 2, 5, 3, 2, 4, 1).\n$$\n\n任务：\n1. 对 $R$ 逐步执行最佳页面替换 (OPT) 策略，使用 $F = 3$ 个帧，在每次替换时计算当前驻留的每个页面的下一次使用时间，并根据上述平局打破规则相应地选择被淘汰的页面。\n2. 对 $R$ 逐步执行最近最少使用 (LRU) 策略，使用 $F = 3$ 个帧，根据过去使用的最近情况选择被淘汰的页面。\n3. 设 $P_{\\text{OPT}}$ 为 OPT 策略下的总页面错误数， $P_{\\text{LRU}}$ 为 LRU 策略下的总页面错误数。计算差值\n$$\n\\Delta = P_{\\text{LRU}} - P_{\\text{OPT}}.\n$$\n\n提供 $\\Delta$ 的单一数值作为最终答案。无需四舍五入。无物理单位适用。",
            "solution": "该问题是有效的。这是一个计算机体系结构和操作系统领域的标准、定义明确的问题，涉及页面替换算法的分析。问题陈述提供了所有必要信息：帧数 $F$、页面引用串 $R$，以及对最佳 (OPT) 和最近最少使用 (LRU) 算法的明确定义，包括针对 OPT 的特定平局打破规则。该问题具有科学依据、自成体系且客观。\n\n任务是计算差值 $\\Delta = P_{\\text{LRU}} - P_{\\text{OPT}}$，其中 $P_{\\text{LRU}}$ 和 $P_{\\text{OPT}}$ 分别是 LRU 和 OPT 算法在给定 $F=3$ 个帧和引用串 $R = (2, 3, 2, 1, 5, 2, 4, 1, 2, 3, 7, 2, 6, 1, 2, 5, 3, 2, 4, 1)$ 的情况下的总页面错误数。\n\n我们将逐步模拟每种算法以找出总页面错误数。\n\n### 最佳 (OPT) 页面替换模拟\nOPT 算法淘汰在最长时间内不会被使用的页面。如果多个页面的最远未来使用时间相同（包括永远不再使用），则通过淘汰数值标签最小的页面来打破平局。物理内存有 $F=3$ 个帧。\n\n让我们跟踪执行过程：\n$R = (2, 3, 2, 1, 5, 2, 4, 1, 2, 3, 7, 2, 6, 1, 2, 5, 3, 2, 4, 1)$\n\n-   $t=1$：引用 $2$。帧：$\\{2\\}$。页面错误 (1)。\n-   $t=2$：引用 $3$。帧：$\\{2, 3\\}$。页面错误 (2)。\n-   $t=3$：引用 $2$。帧：$\\{2, 3\\}$。命中。\n-   $t=4$：引用 $1$。帧：$\\{1, 2, 3\\}$。页面错误 (3)。\n-   $t=5$：引用 $5$。帧：$\\{1, 2, 3\\}$。页面错误 (4)。帧已满。\n    -   未来使用：$1$ 在 $t=8$，$2$ 在 $t=6$，$3$ 在 $t=10$。\n    -   最远的是 $3$。淘汰页：$3$。帧：$\\{1, 2, 5\\}$。\n-   $t=6$：引用 $2$。帧：$\\{1, 2, 5\\}$。命中。\n-   $t=7$：引用 $4$。帧：$\\{1, 2, 5\\}$。页面错误 (5)。\n    -   未来使用：$1$ 在 $t=8$，$2$ 在 $t=9$，$5$ 在 $t=16$。\n    -   最远的是 $5$。淘汰页：$5$。帧：$\\{1, 2, 4\\}$。\n-   $t=8$：引用 $1$。帧：$\\{1, 2, 4\\}$。命中。\n-   $t=9$：引用 $2$。帧：$\\{1, 2, 4\\}$。命中。\n-   $t=10$：引用 $3$。帧：$\\{1, 2, 4\\}$。页面错误 (6)。\n    -   未来使用：$1$ 在 $t=14$，$2$ 在 $t=12$，$4$ 在 $t=19$。\n    -   最远的是 $4$。淘汰页：$4$。帧：$\\{1, 2, 3\\}$。\n-   $t=11$：引用 $7$。帧：$\\{1, 2, 3\\}$。页面错误 (7)。\n    -   未来使用：$1$ 在 $t=14$，$2$ 在 $t=12$，$3$ 在 $t=17$。\n    -   最远的是 $3$。淘汰页：$3$。帧：$\\{1, 2, 7\\}$。\n-   $t=12$：引用 $2$。帧：$\\{1, 2, 7\\}$。命中。\n-   $t=13$：引用 $6$。帧：$\\{1, 2, 7\\}$。页面错误 (8)。\n    -   未来使用：$1$ 在 $t=14$，$2$ 在 $t=15$，$7$ 永远不再使用。\n    -   最远的是 $7$。淘汰页：$7$。帧：$\\{1, 2, 6\\}$。\n-   $t=14$：引用 $1$。帧：$\\{1, 2, 6\\}$。命中。\n-   $t=15$：引用 $2$。帧：$\\{1, 2, 6\\}$。命中。\n-   $t=16$：引用 $5$。帧：$\\{1, 2, 6\\}$。页面错误 (9)。\n    -   未来使用：$1$ 在 $t=20$，$2$ 在 $t=18$，$6$ 永远不再使用。\n    -   最远的是 $6$。淘汰页：$6$。帧：$\\{1, 2, 5\\}$。\n-   $t=17$：引用 $3$。帧：$\\{1, 2, 5\\}$。页面错误 (10)。\n    -   未来使用：$1$ 在 $t=20$，$2$ 在 $t=18$，$5$ 永远不再使用。\n    -   最远的是 $5$。淘汰页：$5$。帧：$\\{1, 2, 3\\}$。\n-   $t=18$：引用 $2$。帧：$\\{1, 2, 3\\}$。命中。\n-   $t=19$：引用 $4$。帧：$\\{1, 2, 3\\}$。页面错误 (11)。\n    -   未来使用：$1$ 在 $t=20$，$2$ 永远不再使用，$3$ 永远不再使用。\n    -   在 $2$ 和 $3$ 之间出现平局（两者都永远不再使用）。平局打破规则：淘汰标签最小的页面。\n    -   淘汰页：$2$。帧：$\\{1, 3, 4\\}$。\n-   $t=20$：引用 $1$。帧：$\\{1, 3, 4\\}$。命中。\n\nOPT 算法的总页面错误数为 $P_{\\text{OPT}} = 11$。\n\n### 最近最少使用 (LRU) 页面替换模拟\nLRU 算法淘汰过去最长时间未被使用的页面。我们可以使用一个最近使用列表来跟踪，其中最近最少使用的页面在列表头部，最近最多使用的页面在列表尾部。\n\n-   $t=1$：引用 $2$。帧：$\\{2\\}$。最近使用情况：$(2)$。页面错误 (1)。\n-   $t=2$：引用 $3$。帧：$\\{2, 3\\}$。最近使用情况：$(2, 3)$。页面错误 (2)。\n-   $t=3$：引用 $2$。帧：$\\{2, 3\\}$。命中。最近使用情况：$(3, 2)$。\n-   $t=4$：引用 $1$。帧：$\\{1, 2, 3\\}$。最近使用情况：$(3, 2, 1)$。页面错误 (3)。\n-   $t=5$：引用 $5$。帧：$\\{1, 2, 3\\}$。页面错误 (4)。\n    -   LRU 页面是 $3$。淘汰页：$3$。帧：$\\{1, 2, 5\\}$。最近使用情况：$(2, 1, 5)$。\n-   $t=6$：引用 $2$。帧：$\\{1, 2, 5\\}$。命中。最近使用情况：$(1, 5, 2)$。\n-   $t=7$：引用 $4$。帧：$\\{1, 2, 5\\}$。页面错误 (5)。\n    -   LRU 页面是 $1$。淘汰页：$1$。帧：$\\{2, 4, 5\\}$。最近使用情况：$(5, 2, 4)$。\n-   $t=8$：引用 $1$。帧：$\\{2, 4, 5\\}$。页面错误 (6)。\n    -   LRU 页面是 $5$。淘汰页：$5$。帧：$\\{1, 2, 4\\}$。最近使用情况：$(2, 4, 1)$。\n-   $t=9$：引用 $2$。帧：$\\{1, 2, 4\\}$。命中。最近使用情况：$(4, 1, 2)$。\n-   $t=10$：引用 $3$。帧：$\\{1, 2, 4\\}$。页面错误 (7)。\n    -   LRU 页面是 $4$。淘汰页：$4$。帧：$\\{1, 2, 3\\}$。最近使用情况：$(1, 2, 3)$。\n-   $t=11$：引用 $7$。帧：$\\{1, 2, 3\\}$。页面错误 (8)。\n    -   LRU 页面是 $1$。淘汰页：$1$。帧：$\\{2, 3, 7\\}$。最近使用情况：$(2, 3, 7)$。\n-   $t=12$：引用 $2$。帧：$\\{2, 3, 7\\}$。命中。最近使用情况：$(3, 7, 2)$。\n-   $t=13$：引用 $6$。帧：$\\{2, 3, 7\\}$。页面错误 (9)。\n    -   LRU 页面是 $3$。淘汰页：$3$。帧：$\\{2, 6, 7\\}$。最近使用情况：$(7, 2, 6)$。\n-   $t=14$：引用 $1$。帧：$\\{2, 6, 7\\}$。页面错误 (10)。\n    -   LRU 页面是 $7$。淘汰页：$7$。帧：$\\{1, 2, 6\\}$。最近使用情况：$(2, 6, 1)$。\n-   $t=15$：引用 $2$。帧：$\\{1, 2, 6\\}$。命中。最近使用情况：$(6, 1, 2)$。\n-   $t=16$：引用 $5$。帧：$\\{1, 2, 6\\}$。页面错误 (11)。\n    -   LRU 页面是 $6$。淘汰页：$6$。帧：$\\{1, 2, 5\\}$。最近使用情况：$(1, 2, 5)$。\n-   $t=17$：引用 $3$。帧：$\\{1, 2, 5\\}$。页面错误 (12)。\n    -   LRU 页面是 $1$。淘汰页：$1$。帧：$\\{2, 3, 5\\}$。最近使用情况：$(2, 5, 3)$。\n-   $t=18$：引用 $2$。帧：$\\{2, 3, 5\\}$。命中。最近使用情况：$(5, 3, 2)$。\n-   $t=19$：引用 $4$。帧：$\\{2, 3, 5\\}$。页面错误 (13)。\n    -   LRU 页面是 $5$。淘汰页：$5$。帧：$\\{2, 3, 4\\}$。最近使用情况：$(3, 2, 4)$。\n-   $t=20$：引用 $1$。帧：$\\{2, 3, 4\\}$。页面错误 (14)。\n    -   LRU 页面是 $3$。淘汰页：$3$。帧：$\\{1, 2, 4\\}$。最近使用情况：$(2, 4, 1)$。\n\nLRU 算法的总页面错误数为 $P_{\\text{LRU}} = 14$。\n\n### 最终计算\n问题要求计算差值 $\\Delta = P_{\\text{LRU}} - P_{\\text{OPT}}$。\n代入计算出的值：\n$$\n\\Delta = 14 - 11 = 3\n$$\n页面错误数的差值为 $3$。",
            "answer": "$$\n\\boxed{3}\n$$"
        },
        {
            "introduction": "虽然LRU算法性能优越，但其硬件实现成本高昂，因此在实际系统中，我们通常采用其近似算法，例如“时钟”（Clock）或“二次机会”算法。本练习将让你在一个特意设计的、会导致“内存抖动”（thrashing）的页面引用序列上，模拟并比较LRU和时钟算法。这不仅能帮助你掌握时钟算法的运作机制，还能让你深入理解在何种极端条件下，近似算法与理想算法的性能表现会趋于一致。",
            "id": "3663508",
            "problem": "考虑一个虚拟内存系统，该系统有 $N$ 个物理页框，初始为空。一个进程生成一个由 $k$ 个热页和 $m$ 个冷页组成的循环内存引用串。热页表示为 $H_1, H_2, \\dots, H_k$，冷页表示为 $C_1, C_2, \\dots, C_m$。引用串的单个周期由热页块紧跟着冷页块按顺序组成。然后该周期重复。具体来说，设 $k=3$，$m=4$，$N=4$，并考虑以下引用串的整整 $2$ 个完整周期：\n$$H_1, H_2, H_3, C_1, C_2, C_3, C_4, H_1, H_2, H_3, C_1, C_2, C_3, C_4.$$\n使用以下基本定义和规则：\n- 当被引用的页面当前不在任何 $N$ 个页框中时，发生页面错误（page fault）。\n- 最近最少使用（LRU）算法在发生错误时，会置换出所有驻留页面中最近一次引用时间最旧的那个页面；在命中时，它会将该页面的最近引用时间更新为当前时间。\n- 二次机会时钟（Clock）算法将 $N$ 个页框排列成一个固定的循环顺序，并用一个时钟指针指向当前的候选页框。每个页框都有一个引用位，当该页框中的页面被命中时，引用位被设置为 $1$。发生错误时，该算法从指针处开始扫描页框：如果页框的引用位为 $1$，则将其重置为 $0$ 并前移指针；如果引用位为 $0$，则置换该页框中的页面，将引发错误的页面插入该页框，并将其引用位设置为 $1$，然后将指针前移到下一个页框并停止。初始时，指针指向页框 $1$，所有页框为空，引用位为 $0$，空页框被视为可立即置换（引用位为 $0$）。\n仅根据这些定义，不使用任何快捷公式，确定 LRU 和 Clock 两种算法在指定的 $14$ 个引用的字符串上产生的确切页面错误数，然后计算差值 $F_{\\mathrm{LRU}} - F_{\\mathrm{Clock}}$，其中 $F_{\\mathrm{LRU}}$ 和 $F_{\\mathrm{Clock}}$ 分别表示 LRU 和 Clock 算法下的总页面错误数。为 $F_{\\mathrm{LRU}} - F_{\\mathrm{Clock}}$ 提供一个单一的精确整数。无需四舍五入，也无需单位。",
            "solution": "所述问题在形式上是合理的、自洽的，并且科学地基于计算机体系结构和操作系统的原理。所有必要的参数和定义都已提供且一致。因此，该问题是有效的，可以确定一个解。\n\n目标是使用最近最少使用（LRU）和二次机会时钟（Clock）页面置换算法，计算给定内存引用串的总页面错误数之差 $F_{\\mathrm{LRU}} - F_{\\mathrm{Clock}}$。\n\n提供的参数如下：\n- 物理页框数量：$N=4$。\n- “热”页数量：$k=3$ ($H_1, H_2, H_3$)。\n- “冷”页数量：$m=4$ ($C_1, C_2, C_3, C_4$)。\n- 总引用串由两个完整周期组成：$S = (H_1, H_2, H_3, C_1, C_2, C_3, C_4, H_1, H_2, H_3, C_1, C_2, C_3, C_4)$。\n该引用串的长度为 $14$ 个引用。一个周期内的唯一页面集合是 $\\{H_1, H_2, H_3, C_1, C_2, C_3, C_4\\}$，其大小为 $k+m = 3+4=7$。\n\n**最近最少使用（LRU）算法分析**\n\nLRU 算法替换掉最长时间未被使用的页面。我们使用 $N=4$ 个初始为空的页框来模拟该算法。\n\n1.  **引用 $1$ 到 $4$**：前 $4$ 个引用是针对不同的页面（$H_1, H_2, H_3, C_1$）。由于页框初始为空，这些都是强制性页面错误。\n    -   引用 $1$ 访问 $H_1$ 后：页框包含 $\\{H_1\\}$。\n    -   引用 $2$ 访问 $H_2$ 后：页框包含 $\\{H_1, H_2\\}$。\n    -   引用 $3$ 访问 $H_3$ 后：页框包含 $\\{H_1, H_2, H_3\\}$。\n    -   引用 $4$ 访问 $C_1$ 后：页框包含 $\\{H_1, H_2, H_3, C_1\\}$。此时页框已满。\n    此时，已发生 $4$ 次页面错误。最近使用顺序为 $C_1$（最近）、$H_3$、$H_2$、$H_1$（最不近）。\n\n2.  **后续引用**：考虑 $7$ 个唯一页面集合中的任何页面 $P$。引用串是一个严格的周期序列，周期为 $7$。当页面 $P$ 下一次被引用时，期间将有 $6$ 个其他不同的页面被引用（$P_1, P_2, \\dots, P_7, P_1, \\dots$）。\n    对于 LRU，一个页面只有在它是 $N$ 个最近被访问的页面之一时才会保留在内存中。如果一个页面 $P$ 被访问，然后在 $P$ 再次被访问之前有 $N$ 个或更多其他不同的页面被访问，那么 $P$ 保证会被置换出去。\n    在这个问题中，$N=4$。对任何给定页面的两次连续访问之间，有 $6$ 个不同的引用。因为 $6 \\ge N$，所以每个被引用的页面在它再次被引用时，都已经被从页框中置换出去了。\n\n    让我们为第 $5$ 次引用 $C_2$ 来验证这一点：\n    -   页框包含 $\\{H_1, H_2, H_3, C_1\\}$。LRU 页面是 $H_1$。\n    -   对 $C_2$ 的引用是页面错误。$H_1$ 被置换。页框现在包含 $\\{H_2, H_3, C_1, C_2\\}$。这是第 $5$ 次错误。\n    这个逻辑对之后的每次访问都成立。例如，下一次引用是 $C_3$。现在的 LRU 页面是 $H_2$。$H_2$ 被置换。这是第 $6$ 次错误。这种模式，即所谓的“颠簸”（thrashing），在整个引用串中持续存在。\n\n因此，这 $14$ 次引用中的每一次都会导致页面错误。\nLRU 的总页面错误数为 $F_{\\mathrm{LRU}} = 14$。\n\n**二次机会时钟（Clock）算法分析**\n\nClock 算法为每个页框使用一个引用位来近似 LRU。我们用 $N=4$ 个页框来模拟该算法，所有页框初始为空，引用位为 $0$，时钟指针指向页框 $1$。\n\n1.  **引用 $1$ 到 $4$**：这些是强制性错误，它们会填满页框。\n    -   引用 $1$ ($H_1$)：错误。将 $H_1$ 放入页框 $1$。将其引用位置为 $1$。指针前进到页框 $2$。状态：$F_1(H_1,1)$。\n    -   引用 $2$ ($H_2$)：错误。将 $H_2$ 放入页框 $2$。将其引用位置为 $1$。指针前进到页框 $3$。状态：$F_1(H_1,1), F_2(H_2,1)$。\n    -   引用 $3$ ($H_3$)：错误。将 $H_3$ 放入页框 $3$。将其引用位置为 $1$。指针前进到页框 $4$。状态：$F_1(H_1,1), F_2(H_2,1), F_3(H_3,1)$。\n    -   引用 $4$ ($C_1$)：错误。将 $C_1$ 放入页框 $4$。将其引用位置为 $1$。指针前进到页框 $1$。状态：$F_1(H_1,1), F_2(H_2,1), F_3(H_3,1), F_4(C_1,1)$。\n    此时，已发生 $4$ 次页面错误。所有引用位均为 $1$。\n\n2.  **后续引用**：考虑第 $5$ 次对 $C_2$ 的引用。\n    -   这是一次错误。指针位于页框 $1$。\n    -   算法扫描寻找一个牺牲页框（引用位为 $0$ 的页框）。\n    -   扫描 $F_1(H_1,1)$：引用位为 $1$。将其置为 $0$。指针前进到 $F_2$。\n    -   扫描 $F_2(H_2,1)$：引用位为 $1$。将其置为 $0$。指针前进到 $F_3$。\n    -   扫描 $F_3(H_3,1)$：引用位为 $1$。将其置为 $0$。指针前进到 $F_4$。\n    -   扫描 $F_4(C_1,1)$：引用位为 $1$。将其置为 $0$。指针前进到 $F_1$。\n    -   指针已经转了一整圈。现在所有引用位都为 $0$。指针回到 $F_1$。\n    -   扫描 $F_1(H_1,0)$：引用位为 $0$。这就是牺牲页。置换 $H_1$。将 $C_2$ 放入 $F_1$，将其引用位置为 $1$。指针前进到 $F_2$。\n    这是第 $5$ 次错误。被置换的页面是 $H_1$，即第一个被调入的页面。\n\n在这种特定的访问模式（顺序扫描页面，且唯一页面数大于页框数）下，从算法的角度来看，所有驻留页面的最近引用情况是相同的（在发生错误之前，所有引用位都是 $1$）。时钟指针扫过一遍，通过清除每个页面的引用位来给予其“二次机会”，然后在第二遍扫描时，按页面加载的顺序替换它们。这种行为与先进先出（FIFO）算法完全相同。\n\n与 LRU 一样，FIFO 算法在这种情况下也会在每次访问时发生错误。中间间隔的不同页面数（$6$）大于页框数（$4$），因此当任何页面再次被请求时，它都已经被置换出去了。\n\n因此，在 Clock 算法下，这 $14$ 次引用中的每一次也都会导致页面错误。\nClock 的总页面错误数为 $F_{\\mathrm{Clock}} = 14$。\n\n**最终计算**\n\nLRU 和 Clock 的页面错误数之差为：\n$$F_{\\mathrm{LRU}} - F_{\\mathrm{Clock}} = 14 - 14 = 0$$",
            "answer": "$$\\boxed{0}$$"
        },
        {
            "introduction": "标准算法并非万能药，它们在某些特定的访问模式下会表现不佳。例如，LRU算法就很容易受到短暂的、大规模页面扫描的“污染”，导致核心工作集的页面被错误地换出。这个高级练习将引导你分析这一弱点，并让你亲手实现一个带有“热点集保护”功能的改进版LRU算法，通过这种方式，你将学会如何诊断标准算法的局限性，并设计出更智能、更具鲁棒性的策略来优化系统性能。",
            "id": "3663470",
            "problem": "一个虚拟内存系统使用一个拥有 $F=5$ 个页帧的主存，并服务于一个进程，该进程的引用串被构造成用以暴露最近最少使用（LRU）算法在短扫描下的脆弱性。以下引用按顺序发生：\n- 一个稳定的工作集 $W=\\{1,2,3,4\\}$ 以序列 $(1,2,3,4)$ 的形式被访问，重复 $3$ 个完整周期，产生 $12$ 次引用。\n- 随后是对 $4$ 个不同的、不再重用的页面 $(5,6,7,8)$ 的一次短扫描，每个页面恰好被引用一次。\n- 工作集 $W$ 的访问恢复，再进行 $2$ 个完整周期，产生另外 $8$ 次引用。\n\n假设所有页帧初始为空。将缺页率定义为总缺页次数与总引用次数的比率。\n\n考虑两种策略：\n1. 标准最近最少使用（LRU）算法，该算法置换掉最近一次引用时间最久远的页面。\n2. 一种过滤LRU算法，它应用了一个窗口大小为 $w=12$ 的滑动窗口热点集保护器：对于时间 $t$ 的每次引用，将热点集 $H(t)$ 定义为在紧邻的前 $w$ 次引用中出现至少两次的页面集合。在时间 $t$ 发生缺页时，从当前持有不在 $H(t)$ 中的页面的页帧中，通过LRU选择牺牲页；如果所有驻留页都在 $H(t)$ 中，则选择全局的LRU页。处理完缺页后，当且仅当新加载的页面属于 $H(t)$ 时，它才被视为受保护的，其中 $H(t)$ 是根据时间 $t$ 之前的 $w$ 次引用计算得出的。\n\n仅从缺页、LRU新近度排序和所述的基于窗口的保护规则的基本定义出发，推导两种策略在指定引用串上的缺页次数。然后，计算过滤LRU相对于标准LRU所实现的缺页率下降值。请用一个精确分数表示最终答案，无需四舍五入。",
            "solution": "本题要求在给定的引用串上，分析两种页面置换算法：标准最近最少使用（LRU）算法和一种自定义的过滤LRU算法。我们必须首先验证问题陈述的有效性。问题提供了所有必要的参数：页帧数量 $F=5$，一个完整且明确的引用串，内存的初始状态（所有页帧为空），以及两种算法的明确、可形式化的规则。该问题在计算机体系结构领域具有科学依据，问题设定良好且客观。因此，该问题是有效的，我们可以着手求解。\n\n总引用串由三部分构成。\n1.  工作集 $W=\\{1,2,3,4\\}$ 以周期 $(1,2,3,4)$ 的形式访问，重复 $3$ 次，得到序列 $(1,2,3,4,1,2,3,4,1,2,3,4)$。这总共有 $12$ 次引用。\n2.  对 $4$ 个新页面 $(5,6,7,8)$ 的一次扫描。这有 $4$ 次引用。\n3.  工作集 $W$ 以周期 $(1,2,3,4)$ 的形式访问，重复 $2$ 次，得到 $(1,2,3,4,1,2,3,4)$。这有 $8$ 次引用。\n\n因此，完整的引用串 $S$ 是 $(1,2,3,4,1,2,3,4,1,2,3,4,5,6,7,8,1,2,3,4,1,2,3,4)$。\n总引用次数为 $N_{ref} = 12 + 4 + 8 = 24$。\n可用页帧的数量为 $F=5$。\n\n### 1. 标准最近最少使用（LRU）算法分析\n\n使用LRU算法时，发生缺页中断时，最长时间未被使用的页面将被置换出去。我们追踪这 $24$ 次引用过程中 $5$ 个页帧的状态。当引用的页面不在内存中时，发生缺页。初始时，所有页帧都是空的。\n\n-   **引用 1-4: (1, 2, 3, 4)**\n    这些都是强制性未命中（compulsory miss），因为页帧初始为空。\n    -   引用 1 (1)：缺页。内存：$\\{1\\}$。缺页计数：$1$。\n    -   引用 2 (2)：缺页。内存：$\\{1, 2\\}$。缺页计数：$2$。\n    -   引用 3 (3)：缺页。内存：$\\{1, 2, 3\\}$。缺页计数：$3$。\n    -   引用 4 (4)：缺页。内存：$\\{1, 2, 3, 4\\}$。缺页计数：$4$。\n    此时，新近度排序为 $(4, 3, 2, 1)$（从最新到最旧）。\n\n-   **引用 5-12: (1, 2, 3, 4, 1, 2, 3, 4)**\n    所有页面 $\\{1, 2, 3, 4\\}$ 都在内存中。这 $8$ 次引用都是命中。缺页计数保持为 $4$。\n\n-   **引用 13: (5)**\n    页面 $5$ 不在内存中。这是一次缺页。内存中包含 $\\{1, 2, 3, 4\\}$ 并且有一个空页帧。页面 $5$ 被加载到空页帧中。\n    -   引用 13 (5)：缺页。内存：$\\{1, 2, 3, 4, 5\\}$。缺页计数：$5$。\n    新近度排序现在是 $(5, 4, 3, 2, 1)$。\n\n-   **引用 14-16: (6, 7, 8)**\n    这些引用导致缺页，并且由于内存已满，它们会触发置换。LRU页面是牺牲页。\n    -   引用 14 (6)：缺页。LRU页面是 $1$。置换 $1$，加载 $6$。内存：$\\{2, 3, 4, 5, 6\\}$。缺页计数：$6$。新近度：$(6, 5, 4, 3, 2)$。\n    -   引用 15 (7)：缺页。LRU页面是 $2$。置换 $2$，加载 $7$。内存：$\\{3, 4, 5, 6, 7\\}$。缺页计数：$7$。新近度：$(7, 6, 5, 4, 3)$。\n    -   引用 16 (8)：缺页。LRU页面是 $3$。置换 $3$，加载 $8$。内存：$\\{4, 5, 6, 7, 8\\}$。缺页计数：$8$。新近度：$(8, 7, 6, 5, 4)$。\n    短扫描现在已经从原始工作集中置换出页面 $1, 2, 3$。\n\n-   **引用 17-20: (1, 2, 3, 4)**\n    工作集的引用恢复，但这些页面已经被置换出去了。\n    -   引用 17 (1)：缺页。LRU页面是 $4$。置换 $4$，加载 $1$。内存：$\\{1, 5, 6, 7, 8\\}$。缺页计数：$9$。新近度：$(1, 8, 7, 6, 5)$。\n    -   引用 18 (2)：缺页。LRU页面是 $5$。置換 $5$，加载 $2$。内存：$\\{1, 2, 6, 7, 8\\}$。缺页计数：$10$。新近度：$(2, 1, 8, 7, 6)$。\n    -   引用 19 (3)：缺页。LRU页面是 $6$。置換 $6$，加载 $3$。内存：$\\{1, 2, 3, 7, 8\\}$。缺页计数：$11$。新近度：$(3, 2, 1, 8, 7)$。\n    -   引用 20 (4)：缺页。LRU页面是 $7$。置換 $7$，加载 $4$。内存：$\\{1, 2, 3, 4, 8\\}$。缺页计数：$12$。新近度：$(4, 3, 2, 1, 8)$。\n\n-   **引用 21-24: (1, 2, 3, 4)**\n    工作集页面 $\\{1, 2, 3, 4\\}$ 现在已回到内存中。这 $4$ 次引用都是命中。缺页计数保持为 $12$。\n\n标准LRU策略的总缺页次数为 $N_{faults, LRU} = 12$。\n缺页率为 $R_{LRU} = \\frac{N_{faults, LRU}}{N_{ref}} = \\frac{12}{24} = \\frac{1}{2}$。\n\n### 2. 过滤LRU算法分析\n\n该策略使用大小为 $w=12$ 的滑动窗口来定义一个热点集 $H(t)$，该集合包含在时间 $t$ 之前的 $w$ 次引用中至少被引用两次的页面。发生缺页时，牺牲页是在不在 $H(t)$ 中的驻留页面里，最近最少被使用的那个页面。\n\n-   **引用 1-12: (1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4)**\n    -   对于引用 $1$ 到 $4$，我们有 $4$ 次强制性未命中。内存：$\\{1,2,3,4\\}$。缺页计数：$4$。\n    -   对于引用 $5$ 到 $12$，这些页面都在内存中，所以都是命中。\n    -   在此阶段，$H(t)$ 随时间演变。当 $t \\le 5$ 时，没有页面被引用两次，因此 $H(t)=\\emptyset$。当 $t \\ge 9$ 时，窗口包含 $(1,2,3,4)$ 的两个完整周期，因此 $H(t)=\\{1,2,3,4\\}$。\n    -   在此阶段结束时（引用12之后），缺页计数为 $4$。\n\n-   **引用 13: (5)**\n    -   时间 $t=13$。之前的 $w=12$ 次引用是 $(1,2,3,4,1,2,3,4,1,2,3,4)$。$\\{1,2,3,4\\}$ 中的每个页面都被引用了 $3$ 次。所以，$H(13)=\\{1,2,3,4\\}$。\n    -   页面 $5$ 不在内存中（内存包含 $\\{1,2,3,4\\}$）。这是一次缺页。\n    -   有一个空页帧，所以页面 $5$ 被加载而无需置换。\n    -   内存：$\\{1,2,3,4,5\\}$。缺页计数：$4+1=5$。\n\n-   **引用 14: (6)**\n    -   时间 $t=14$。窗口是 $S_{2:13} = (2,3,4,1,2,3,4,1,2,3,4,5)$。页面 $\\{1,2,3,4\\}$ 的频率 $\\ge 2$。所以，$H(14)=\\{1,2,3,4\\}$。\n    -   页面 $6$ 不在内存中。这是一次缺页。内存已满。\n    -   驻留页面集为 $P=\\{1,2,3,4,5\\}$。\n    -   受保护的驻留页面集为 $P \\cap H(14) = \\{1,2,3,4\\}$。\n    -   可置换的页面集为 $P \\setminus H(14) = \\{5\\}$。\n    -   牺牲页必须是页面 $5$。置换 $5$，加载 $6$。\n    -   内存：$\\{1,2,3,4,6\\}$。缺页计数：$5+1=6$。\n\n-   **引用 15: (7)**\n    -   时间 $t=15$。窗口是 $S_{3:14} = (3,4,1,2,3,4,1,2,3,4,5,6)$。$H(15)=\\{1,2,3,4\\}$。\n    -   页面 $7$ 不在内存中。缺页。\n    -   驻留页面 $P=\\{1,2,3,4,6\\}$。受保护页面 $P \\cap H(15)=\\{1,2,3,4\\}$。\n    -   可置换页面 $P \\setminus H(15)=\\{6\\}$。牺牲页是 $6$。\n    -   置换 $6$，加载 $7$。内存：$\\{1,2,3,4,7\\}$。缺页计数：$6+1=7$。\n\n-   **引用 16: (8)**\n    -   时间 $t=16$。窗口是 $S_{4:15} = (4,1,2,3,4,1,2,3,4,5,6,7)$。$\\{1,2,3,4\\}$ 中的每个页面至少出现两次。$H(16)=\\{1,2,3,4\\}$。\n    -   页面 $8$ 不在内存中。缺页。\n    -   驻留页面 $P=\\{1,2,3,4,7\\}$。受保护页面 $P \\cap H(16)=\\{1,2,3,4\\}$。\n    -   可置换页面 $P \\setminus H(16)=\\{7\\}$。牺牲页是 $7$。\n    -   置换 $7$，加载 $8$。内存：$\\{1,2,3,4,8\\}$。缺页计数：$7+1=8$。\n    此时，工作集页面 $\\{1,2,3,4\\}$ 仍然驻留在内存中，受到热点集过滤器的保护。扫描页面 $\\{5,6,7\\}$ 被依次加载和置换。\n\n-   **引用 17-24: (1, 2, 3, 4, 1, 2, 3, 4)**\n    -   内存状态为 $\\{1,2,3,4,8\\}$。\n    -   此序列中的所有引用都指向页面 $\\{1,2,3,4\\}$。由于这些页面都驻留在内存中，所有 $8$ 次引用都是命中。\n    -   在此阶段，热点集 $H(t)$ 将继续包含 $\\{1,2,3,4\\}$，因为这些页面在滑动窗口内被持续频繁引用。\n    -   缺页计数不再增加。\n\n过滤LRU策略的总缺页次数为 $N_{faults, FIL-LRU} = 8$。\n缺页率为 $R_{FIL-LRU} = \\frac{N_{faults, FIL-LRU}}{N_{ref}} = \\frac{8}{24} = \\frac{1}{3}$。\n\n### 3. 缺页率的下降\n\n问题要求计算过滤LRU相对于标准LRU所实现的缺页率下降值。这个值是差值 $\\Delta R = R_{LRU} - R_{FIL-LRU}$。\n\n$R_{LRU} = \\frac{1}{2}$\n$R_{FIL-LRU} = \\frac{1}{3}$\n\n$\\Delta R = \\frac{1}{2} - \\frac{1}{3} = \\frac{3}{6} - \\frac{2}{6} = \\frac{1}{6}$。\n\n过滤LRU策略将缺页率降低了 $\\frac{1}{6}$。",
            "answer": "$$\\boxed{\\frac{1}{6}}$$"
        }
    ]
}