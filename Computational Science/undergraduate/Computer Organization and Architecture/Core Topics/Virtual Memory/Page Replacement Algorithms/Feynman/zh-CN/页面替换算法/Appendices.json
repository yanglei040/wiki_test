{
    "hands_on_practices": [
        {
            "introduction": "页面置换算法的性能评估是操作系统设计的关键一环。通过将广泛应用的近期最少使用（LRU）算法与理论上无法实现的最佳（OPT）算法进行比较，我们可以为实际算法的效率建立一个性能基准。这个练习将指导你逐步模拟这两种算法，从而直观地理解它们决策机制的差异及其对缺页次数的最终影响 。",
            "id": "3663525",
            "problem": "考虑一个虚拟内存系统，其物理帧数量固定，且有一个单进程生成页面引用串。该系统使用请求分页，每次访问时，如果被引用的页面不在任何物理帧中，就会发生页面错误。当需要替换时，系统可以使用不同的页面替换策略，其核心定义如下。\n\n使用的基本定义：\n- 页面引用串是一个有序的页号序列，记为 $R = (r_{1}, r_{2}, \\dots, r_{N})$，其中 $N$ 是序列的长度，每个 $r_{i}$ 是一个表示页面的正整数标签。\n- 物理内存有 $F$ 个帧，每个帧可以容纳一个页面。\n- 当被引用的页面 $r_{i}$ 在引用时不在 $F$ 个帧中的任何一个时，就会发生页面错误。\n- 最近最少使用（LRU）替换算法，全称为 Least Recently Used (LRU)，会淘汰掉当前驻留页面中，其最近一次使用（在引用串中向后看）距离现在最远的那个页面。\n- 最优页面替换（OPT）算法会淘汰掉其下一次使用（在引用串中向前看）发生在最遥远未来的页面，或者不再被使用的页面。为了在下次使用距离出现平局时使过程明确，当两个或多个页面的最远下次使用距离相等时，淘汰数值标签最小的那个页面。\n\n给定 $F = 3$ 个帧和页面引用串\n$$\nR = (2, 3, 2, 1, 5, 2, 4, 1, 2, 3, 7, 2, 6, 1, 2, 5, 3, 2, 4, 1).\n$$\n\n任务：\n1. 对引用串 $R$ 和 $F = 3$ 的情况，逐步执行最优页面替换（OPT）策略，在每次替换时计算当前驻留的每个页面的下次使用时间，并根据上述平局打破规则选择被淘汰的页面。\n2. 对引用串 $R$ 和 $F = 3$ 的情况，逐步执行最近最少使用（LRU）策略，根据过去使用的就近程度选择被淘汰的页面。\n3. 设 $P_{\\text{OPT}}$ 为 OPT 策略下的总页面错误数，$P_{\\text{LRU}}$ 为 LRU 策略下的总页面错误数。计算差值\n$$\n\\Delta = P_{\\text{LRU}} - P_{\\text{OPT}}.\n$$\n\n提供 $\\Delta$ 的单一数值作为最终答案。无需四舍五入。没有物理单位。",
            "solution": "该问题是有效的。这是一个计算机体系结构和操作系统领域的标准、定义明确的问题，涉及页面替换算法的分析。问题陈述提供了所有必要信息：帧数 $F$、页面引用串 $R$，以及对最优（OPT）和最近最少使用（LRU）算法的明确定义，包括 OPT 的特定平局打破规则。该问题具有科学依据，是自包含且客观的。\n\n任务是计算差值 $\\Delta = P_{\\text{LRU}} - P_{\\text{OPT}}$，其中 $P_{\\text{LRU}}$ 和 $P_{\\text{OPT}}$ 分别是 LRU 和 OPT 算法在给定 $F=3$ 个帧和引用串 $R = (2, 3, 2, 1, 5, 2, 4, 1, 2, 3, 7, 2, 6, 1, 2, 5, 3, 2, 4, 1)$ 的情况下的总页面错误数。\n\n我们将逐步模拟每种算法以找出总页面错误数。\n\n### 最优（OPT）页面替换模拟\nOPT 算法淘汰在最长时间内不会被使用的页面。如果多个页面具有相同的最远未来使用时间（包括永不再次使用），则通过淘汰数值标签最小的页面来打破平局。物理内存有 $F=3$ 个帧。\n\n让我们追踪执行过程：\n$R = (2, 3, 2, 1, 5, 2, 4, 1, 2, 3, 7, 2, 6, 1, 2, 5, 3, 2, 4, 1)$\n\n-   $t=1$: 引用 $2$。帧: $\\{2\\}$。页面错误 (1)。\n-   $t=2$: 引用 $3$。帧: $\\{2, 3\\}$。页面错误 (2)。\n-   $t=3$: 引用 $2$。帧: $\\{2, 3\\}$。命中。\n-   $t=4$: 引用 $1$。帧: $\\{1, 2, 3\\}$。页面错误 (3)。\n-   $t=5$: 引用 $5$。帧: $\\{1, 2, 3\\}$。页面错误 (4)。帧已满。\n    -   未来使用：$1$ 在 $t=8$，$2$ 在 $t=6$，$3$ 在 $t=10$。\n    -   最远的是 $3$。淘汰页面: $3$。帧: $\\{1, 2, 5\\}$。\n-   $t=6$: 引用 $2$。帧: $\\{1, 2, 5\\}$。命中。\n-   $t=7$: 引用 $4$。帧: $\\{1, 2, 5\\}$。页面错误 (5)。\n    -   未来使用：$1$ 在 $t=8$，$2$ 在 $t=9$，$5$ 在 $t=16$。\n    -   最远的是 $5$。淘汰页面: $5$。帧: $\\{1, 2, 4\\}$。\n-   $t=8$: 引用 $1$。帧: $\\{1, 2, 4\\}$。命中。\n-   $t=9$: 引用 $2$。帧: $\\{1, 2, 4\\}$。命中。\n-   $t=10$: 引用 $3$。帧: $\\{1, 2, 4\\}$。页面错误 (6)。\n    -   未来使用：$1$ 在 $t=14$，$2$ 在 $t=12$，$4$ 在 $t=19$。\n    -   最远的是 $4$。淘汰页面: $4$。帧: $\\{1, 2, 3\\}$。\n-   $t=11$: 引用 $7$。帧: $\\{1, 2, 3\\}$。页面错误 (7)。\n    -   未来使用：$1$ 在 $t=14$，$2$ 在 $t=12$，$3$ 在 $t=17$。\n    -   最远的是 $3$。淘汰页面: $3$。帧: $\\{1, 2, 7\\}$。\n-   $t=12$: 引用 $2$。帧: $\\{1, 2, 7\\}$。命中。\n-   $t=13$: 引用 $6$。帧: $\\{1, 2, 7\\}$。页面错误 (8)。\n    -   未来使用：$1$ 在 $t=14$，$2$ 在 $t=15$，$7$ 永不再次使用。\n    -   最远的是 $7$。淘汰页面: $7$。帧: $\\{1, 2, 6\\}$。\n-   $t=14$: 引用 $1$。帧: $\\{1, 2, 6\\}$。命中。\n-   $t=15$: 引用 $2$。帧: $\\{1, 2, 6\\}$。命中。\n-   $t=16$: 引用 $5$。帧: $\\{1, 2, 6\\}$。页面错误 (9)。\n    -   未来使用：$1$ 在 $t=20$，$2$ 在 $t=18$，$6$ 永不再次使用。\n    -   最远的是 $6$。淘汰页面: $6$。帧: $\\{1, 2, 5\\}$。\n-   $t=17$: 引用 $3$。帧: $\\{1, 2, 5\\}$。页面错误 (10)。\n    -   未来使用：$1$ 在 $t=20$，$2$ 在 $t=18$，$5$ 永不再次使用。\n    -   最远的是 $5$。淘汰页面: $5$。帧: $\\{1, 2, 3\\}$。\n-   $t=18$: 引用 $2$。帧: $\\{1, 2, 3\\}$。命中。\n-   $t=19$: 引用 $4$。帧: $\\{1, 2, 3\\}$。页面错误 (11)。\n    -   未来使用：$1$ 在 $t=20$，$2$ 永不再次使用，$3$ 永不再次使用。\n    -   $2$ 和 $3$ 之间出现平局（都永不再次使用）。平局打破规则：淘汰数值标签最小的页面。\n    -   淘汰页面: $2$。帧: $\\{1, 3, 4\\}$。\n-   $t=20$: 引用 $1$。帧: $\\{1, 3, 4\\}$。命中。\n\nOPT 算法的总页面错误数为 $P_{\\text{OPT}} = 11$。\n\n### 最近最少使用（LRU）页面替换模拟\nLRU 算法淘汰过去最长时间未被使用的页面。我们可以使用一个新近度列表来追踪这一点，其中最近最少使用的页面在列表头部，最近最多使用的页面在列表尾部。\n\n-   $t=1$: 引用 $2$。帧: $\\{2\\}$。新近度: $(2)$。页面错误 (1)。\n-   $t=2$: 引用 $3$。帧: $\\{2, 3\\}$。新近度: $(2, 3)$。页面错误 (2)。\n-   $t=3$: 引用 $2$。帧: $\\{2, 3\\}$。命中。新近度: $(3, 2)$。\n-   $t=4$: 引用 $1$。帧: $\\{1, 2, 3\\}$。新近度: $(3, 2, 1)$。页面错误 (3)。\n-   $t=5$: 引用 $5$。帧: $\\{1, 2, 3\\}$。页面错误 (4)。\n    -   LRU 页面是 $3$。淘汰页面: $3$。帧: $\\{1, 2, 5\\}$。新近度: $(2, 1, 5)$。\n-   $t=6$: 引用 $2$。帧: $\\{1, 2, 5\\}$。命中。新近度: $(1, 5, 2)$。\n-   $t=7$: 引用 $4$。帧: $\\{1, 2, 5\\}$。页面错误 (5)。\n    -   LRU 页面是 $1$。淘汰页面: $1$。帧: $\\{2, 4, 5\\}$。新近度: $(5, 2, 4)$。\n-   $t=8$: 引用 $1$。帧: $\\{2, 4, 5\\}$。页面错误 (6)。\n    -   LRU 页面是 $5$。淘汰页面: $5$。帧: $\\{1, 2, 4\\}$。新近度: $(2, 4, 1)$。\n-   $t=9$: 引用 $2$。帧: $\\{1, 2, 4\\}$。命中。新近度: $(4, 1, 2)$。\n-   $t=10$: 引用 $3$。帧: $\\{1, 2, 4\\}$。页面错误 (7)。\n    -   LRU 页面是 $4$。淘汰页面: $4$。帧: $\\{1, 2, 3\\}$。新近度: $(1, 2, 3)$。\n-   $t=11$: 引用 $7$。帧: $\\{1, 2, 3\\}$。页面错误 (8)。\n    -   LRU 页面是 $1$。淘汰页面: $1$。帧: $\\{2, 3, 7\\}$。新近度: $(2, 3, 7)$。\n-   $t=12$: 引用 $2$。帧: $\\{2, 3, 7\\}$。命中。新近度: $(3, 7, 2)$。\n-   $t=13$: 引用 $6$。帧: $\\{2, 3, 7\\}$。页面错误 (9)。\n    -   LRU 页面是 $3$。淘汰页面: $3$。帧: $\\{2, 6, 7\\}$。新近度: $(7, 2, 6)$。\n-   $t=14$: 引用 $1$。帧: $\\{2, 6, 7\\}$。页面错误 (10)。\n    -   LRU 页面是 $7$。淘汰页面: $7$。帧: $\\{1, 2, 6\\}$。新近度: $(2, 6, 1)$。\n-   $t=15$: 引用 $2$。帧: $\\{1, 2, 6\\}$。命中。新近度: $(6, 1, 2)$。\n-   $t=16$: 引用 $5$。帧: $\\{1, 2, 6\\}$。页面错误 (11)。\n    -   LRU 页面是 $6$。淘汰页面: $6$。帧: $\\{1, 2, 5\\}$。新近度: $(1, 2, 5)$。\n-   $t=17$: 引用 $3$。帧: $\\{1, 2, 5\\}$。页面错误 (12)。\n    -   LRU 页面是 $1$。淘汰页面: $1$。帧: $\\{2, 3, 5\\}$。新近度: $(2, 5, 3)$。\n-   $t=18$: 引用 $2$。帧: $\\{2, 3, 5\\}$。命中。新近度: $(5, 3, 2)$。\n-   $t=19$: 引用 $4$。帧: $\\{2, 3, 5\\}$。页面错误 (13)。\n    -   LRU 页面是 $5$。淘汰页面: $5$。帧: $\\{2, 3, 4\\}$。新近度: $(3, 2, 4)$。\n-   $t=20$: 引用 $1$。帧: $\\{2, 3, 4\\}$。页面错误 (14)。\n    -   LRU 页面是 $3$。淘汰页面: $3$。帧: $\\{1, 2, 4\\}$。新近度: $(2, 4, 1)$。\n\nLRU 算法的总页面错误数为 $P_{\\text{LRU}} = 14$。\n\n### 最终计算\n问题要求计算差值 $\\Delta = P_{\\text{LRU}} - P_{\\text{OPT}}$。\n代入计算出的值：\n$$\n\\Delta = 14 - 11 = 3\n$$\n页面错误数的差值为 $3$。",
            "answer": "$$\n\\boxed{3}\n$$"
        },
        {
            "introduction": "虽然LRU算法性能优越，但其硬件实现成本高昂，因此实际系统中常采用其近似算法，如二次机会时钟（Clock）算法。本练习将通过一个特定的循环引用序列，让你探究LRU及其近似算法在可能导致“颠簸”（thrashing）的极端负载下的行为。通过这个模拟，你将深入了解不同算法在何种条件下会表现出相似的低效率，并体会算法设计中的性能与实现复杂性之间的权衡 。",
            "id": "3663508",
            "problem": "考虑一个虚拟内存系统，它有 $N$ 个物理页框，初始为空。一个进程生成一个由 $k$ 个热页和 $m$ 个冷页组成的周期性内存引用字符串。热页表示为 $H_1, H_2, \\dots, H_k$，冷页表示为 $C_1, C_2, \\dots, C_m$。引用字符串的单个周期由热页块紧接着冷页块按顺序组成。然后该周期重复。具体来说，取 $k=3$，$m=4$，$N=4$，并恰好考虑以下引用字符串的 $2$ 个完整周期：\n$$H_1, H_2, H_3, C_1, C_2, C_3, C_4, H_1, H_2, H_3, C_1, C_2, C_3, C_4.$$\n使用以下基本定义和规则：\n- 当被引用的页面当前不在 $N$ 个页框中的任何一个时，就会发生缺页中断。\n- 最近最少使用 (LRU) 算法：在发生缺页中断时，置换出所有驻留页面中最近引用时间最早的那个页面；在命中时，它将该页面的最近性更新为当前时间。\n- 二次机会时钟算法（Clock）将 $N$ 个页框排列成一个固定的循环顺序，并带有一个指向当前候选页框的时钟指针。每个页框都有一个引用位，该页框中的页面被命中时，其引用位被设置为 $1$。发生缺页中断时，算法从指针处开始扫描页框：如果页框的引用位为 $1$，则将其重置为 $0$ 并推进指针；如果引用位为 $0$，则置换该页框中的页面，将导致中断的页面插入该页框并将其引用位设置为 $1$，然后将指针推进到下一个页框并停止。最初，指针指向页框 $1$，所有页框都为空，引用位为 $0$，并且空页框被视为可立即置换（引用位为 $0$）。\n仅从这些定义出发，不使用任何快捷公式，确定 LRU 和 Clock 算法在指定的 $14$ 个引用的字符串上产生的缺页中断的确切数量，然后计算差值 $F_{\\mathrm{LRU}} - F_{\\mathrm{Clock}}$，其中 $F_{\\mathrm{LRU}}$ 和 $F_{\\mathrm{Clock}}$ 分别表示 LRU 和 Clock 下的总中断次数。为 $F_{\\mathrm{LRU}} - F_{\\mathrm{Clock}}$ 提供一个单一的精确整数。无需四舍五入，也无需单位。",
            "solution": "所述问题在形式上是健全的、自洽的，并且科学地基于计算机体系结构和操作系统的原理。所有必要的参数和定义都已提供且一致。因此，该问题是有效的，可以确定一个解。\n\n目标是使用最近最少使用（LRU）和二次机会时钟（Clock）页面置换算法，计算给定内存引用字符串下总缺页中断次数的差值 $F_{\\mathrm{LRU}} - F_{\\mathrm{Clock}}$。\n\n提供的参数如下：\n- 物理页框数量：$N=4$。\n- “热”页数量：$k=3$ ($H_1, H_2, H_3$) 。\n- “冷”页数量：$m=4$ ($C_1, C_2, C_3, C_4$) 。\n- 总引用字符串由两个完整周期组成：$S = (H_1, H_2, H_3, C_1, C_2, C_3, C_4, H_1, H_2, H_3, C_1, C_2, C_3, C_4)$。\n该字符串的长度为 $14$ 次引用。一个周期内的唯一页面集合是 $\\{H_1, H_2, H_3, C_1, C_2, C_3, C_4\\}$，其大小为 $k+m = 3+4=7$。\n\n**最近最少使用 (LRU) 算法分析**\n\nLRU 算法置换最长时间未被使用的页面。我们用 $N=4$ 个初始为空的页框来模拟该算法。\n\n1.  **引用 $1$ 至 $4$**：前 $4$ 次引用是针对不同的页面（$H_1, H_2, H_3, C_1$）。由于页框最初是空的，这些都是强制性缺页中断。\n    -   引用 $1$（$H_1$）后：页框包含 $\\{H_1\\}$。\n    -   引用 $2$（$H_2$）后：页框包含 $\\{H_1, H_2\\}$。\n    -   引用 $3$（$H_3$）后：页框包含 $\\{H_1, H_2, H_3\\}$。\n    -   引用 $4$（$C_1$）后：页框包含 $\\{H_1, H_2, H_3, C_1\\}$。页框现已满。\n    此时，已发生 $4$ 次缺页中断。最近性顺序为 $C_1$ (最近)、$H_3$、$H_2$、$H_1$ (最不近)。\n\n2.  **后续引用**：考虑唯一页面集合中 $7$ 个页面里的任意页面 $P$。引用字符串是一个周期为 $7$ 的严格周期序列。当 $P$ 下一次被引用时，在此期间将有 $6$ 个其他不同的页面被引用（$P_1, P_2, \\dots, P_7, P_1, \\dots$）。\n    对于 LRU，一个页面只有当它是 $N$ 个最近访问的页面之一时才会留在内存中。如果一个页面 $P$ 被访问，然后在 $P$ 再次被访问之前有 $N$ 个或更多其他不同的页面被访问，那么 $P$ 保证会被置换出去。\n    在这个问题中，$N=4$。对任何给定页面的两次连续访问之间，中间的不同引用数量为 $6$。由于 $6 \\ge N$，每个被引用的页面在它再次被引用时，都已经被从页框中置换出去了。\n\n    让我们对第 $5$ 次引用 $C_2$ 进行验证：\n    -   页框包含 $\\{H_1, H_2, H_3, C_1\\}$。LRU 页面是 $H_1$。\n    -   对 $C_2$ 的引用是一次缺页中断。$H_1$ 被置换。页框现在包含 $\\{H_2, H_3, C_1, C_2\\}$。这是第 $5$ 次中断。\n    这个逻辑对每次后续访问都成立。例如，下一次引用是 $C_3$。现在的 LRU 页面是 $H_2$。$H_2$ 被置换。这是第 $6$ 次中断。这种模式，被称为抖动，在整个字符串中持续存在。\n\n因此，$14$ 次引用中的每一次都会导致缺页中断。\nLRU 的总缺页中断次数为 $F_{\\mathrm{LRU}} = 14$。\n\n**二次机会时钟 (Clock) 算法分析**\n\nClock 算法为每个页框使用一个引用位来近似 LRU。我们用 $N=4$ 个页框来模拟该算法，所有页框初始为空，引用位为 $0$，时钟指针指向页框 $1$。\n\n1.  **引用 $1$ 至 $4$**：这些是强制性缺页中断，会填满页框。\n    -   引用 $1$ ($H_1$)：缺页中断。将 $H_1$ 放入页框 $1$。将其引用位置为 $1$。指针前进到页框 $2$。状态：$F_1(H_1,1)$。\n    -   引用 $2$ ($H_2$)：缺页中断。将 $H_2$ 放入页框 $2$。将其引用位置为 $1$。指针前进到页框 $3$。状态：$F_1(H_1,1), F_2(H_2,1)$。\n    -   引用 $3$ ($H_3$)：缺页中断。将 $H_3$ 放入页框 $3$。将其引用位置为 $1$。指针前进到页框 $4$。状态：$F_1(H_1,1), F_2(H_2,1), F_3(H_3,1)$。\n    -   引用 $4$ ($C_1$)：缺页中断。将 $C_1$ 放入页框 $4$。将其引用位置为 $1$。指针前进到页框 $1$。状态：$F_1(H_1,1), F_2(H_2,1), F_3(H_3,1), F_4(C_1,1)$。\n    此时，已发生 $4$ 次缺页中断。所有引用位都为 $1$。\n\n2.  **后续引用**：考虑第 $5$ 次引用 $C_2$。\n    -   这是一次缺页中断。指针在页框 $1$ 处。\n    -   算法扫描寻找一个牺牲页框（一个引用位为 $0$ 的页框）。\n    -   扫描 $F_1(H_1,1)$：引用位为 $1$。将位设置为 $0$。指针前进到 $F_2$。\n    -   扫描 $F_2(H_2,1)$：引用位为 $1$。将位设置为 $0$。指针前进到 $F_3$。\n    -   扫描 $F_3(H_3,1)$：引用位为 $1$。将位设置为 $0$。指针前进到 $F_4$。\n    -   扫描 $F_4(C_1,1)$：引用位为 $1$。将位设置为 $0$。指针前进到 $F_1$。\n    -   指针走了一整圈。现在所有引用位都为 $0$。指针回到 $F_1$。\n    -   扫描 $F_1(H_1,0)$：引用位为 $0$。这是牺牲页。置换 $H_1$。将 $C_2$ 放入 $F_1$，将其引用位置为 $1$。指针前进到 $F_2$。\n    这是第 $5$ 次缺页中断。被置换的页面是 $H_1$，即第一个被调入的页面。\n\n在这种特定的访问模式下（其中唯一页面数量大于页框数量的页面顺序扫描），从算法的角度来看，所有驻留页面的最近性都是相等的（在发生缺页中断之前所有引用位都为 $1$）。时钟指针扫过所有页框，通过清除其引用位给每个页面一次“二次机会”，然后在第二遍扫描时，按照页面被加载的顺序进行置换。这种行为与先进先出（FIFO）算法完全相同。\n\n就像 LRU 一样，FIFO 算法在这种情况下也会在每次访问时都发生缺页中断。中间不同的页面数量（$6$）大于页框数量（$4$），因此当任何页面再次被请求时，它早已被置换出去了。\n\n因此，在 Clock 算法下，$14$ 次引用中的每一次也都会导致缺页中断。\nClock 的总缺页中断次数为 $F_{\\mathrm{Clock}} = 14$。\n\n**最终计算**\n\nLRU 和 Clock 的缺页中断次数之差为：\n$$F_{\\mathrm{LRU}} - F_{\\mathrm{Clock}} = 14 - 14 = 0$$",
            "answer": "$$\\boxed{0}$$"
        },
        {
            "introduction": "任何单一的页面置换算法都存在其固有的弱点，例如LRU算法对大规模的顺序扫描非常敏感。这个练习将引导你超越标准算法的应用，进入算法设计的领域，通过引入一个基于滑动窗口的“热点集”保护机制来改进LRU算法。通过对比原始LRU和改进后算法的缺页率，你将学会如何分析并优化算法以适应特定的工作负载模式，这是高级系统设计中的一项核心技能 。",
            "id": "3663470",
            "problem": "一个虚拟内存系统使用一个包含 $F=5$ 个页框的主存，并服务于一个进程，该进程的引用串被构造用来暴露最近最少使用（LRU）算法在短暂扫描面前的脆弱性。以下引用按顺序发生：\n- 一个稳定的工作集 $W=\\{1,2,3,4\\}$ 以序列 $(1,2,3,4)$ 的形式被访问，重复 $3$ 个完整周期，产生 $12$ 次引用。\n- 随后是对 $4$ 个不同的、永不重用的页 $(5,6,7,8)$ 的短暂扫描，每个页仅被引用一次。\n- 工作集 $W$ 的访问恢复，再进行 $2$ 个完整周期，产生另外 $8$ 次引用。\n\n假设所有页框最初都是空的。将缺页率定义为总缺页次数与总引用次数的比率。\n\n考虑两种策略：\n1. 标准的最近最少使用（LRU）算法，该算法逐出最近一次引用时间最久远的页。\n2. 一种过滤式 LRU 算法，它应用一个窗口大小为 $w=12$ 的滑动窗口热点集保护器：对于在时间 $t$ 的每次引用，将热点集 $H(t)$ 定义为在紧邻的前 $w$ 个引用中出现至少两次的页的集合。在时间 $t$ 发生缺页时，从当前持有不在 $H(t)$ 中的页的页框中，按 LRU 规则选择一个牺牲页；如果每个驻留页都在 $H(t)$ 中，则选择全局的 LRU 页。在处理完缺页后，新加载的页当且仅当它属于 $H(t)$ 时才被视为受保护的，其中 $H(t)$ 是根据时间 $t$ 之前的 $w$ 个引用计算得出的。\n\n仅从缺页、LRU 最近使用次序和所述的基于窗口的保护规则的基本定义出发，推导两种策略在指定引用串上的缺页次数。然后计算过滤式 LRU 相对于标准 LRU 所实现的缺页率降低值。将您的最终答案表示为单个精确分数，无需四舍五入。",
            "solution": "该问题要求在指定的引用串上分析两种页面替换算法：标准的最近最少使用（LRU）算法和一种自定义的过滤式 LRU 算法。我们必须首先验证问题的陈述。该问题提供了所有必要的参数：页框数量 $F=5$，一个完整且明确的引用串，内存的初始状态（所有页框为空），以及两种算法的明确、可形式化的规则。该问题在计算机体系结构领域具有科学依据，问题陈述清晰且客观。因此，该问题是有效的，我们可以继续进行求解。\n\n总引用串由三个部分构成。\n1.  工作集 $W=\\{1,2,3,4\\}$ 以周期 $(1,2,3,4)$ 的形式访问，重复 $3$ 次，得到序列 $(1,2,3,4,1,2,3,4,1,2,3,4)$。这总共有 $12$ 次引用。\n2.  对 $4$ 个新页 $(5,6,7,8)$ 的扫描。这有 $4$ 次引用。\n3.  工作集 $W$ 以周期 $(1,2,3,4)$ 的形式访问，重复 $2$ 次，得到 $(1,2,3,4,1,2,3,4)$。这有 $8$ 次引用。\n\n因此，完整的引用串 $S$ 是 $(1,2,3,4,1,2,3,4,1,2,3,4,5,6,7,8,1,2,3,4,1,2,3,4)$。\n总引用次数为 $N_{\\text{ref}} = 12 + 4 + 8 = 24$。\n可用的页框数量为 $F=5$。\n\n### 1. 标准最近最少使用（LRU）算法分析\n\n对于 LRU 算法，当发生缺页时，未使用时间最长的页被逐出。我们追踪这 $5$ 个页框在 $24$ 次引用过程中的状态。当被引用的页不在内存中时，就会发生缺页。最初，所有页框都是空的。\n\n-   **引用 1-4: (1, 2, 3, 4)**\n    这些都是强制性缺页，因为页框最初是空的。\n    -   引用 1 (1)：缺页。内存：$\\{1\\}$。缺页计数：$1$。\n    -   引用 2 (2)：缺页。内存：$\\{1, 2\\}$。缺页计数：$2$。\n    -   引用 3 (3)：缺页。内存：$\\{1, 2, 3\\}$。缺页计数：$3$。\n    -   引用 4 (4)：缺页。内存：$\\{1, 2, 3, 4\\}$。缺页计数：$4$。\n    此时，最近使用次序为 $(4, 3, 2, 1)$，从最近到最远。\n\n-   **引用 5-12: (1, 2, 3, 4, 1, 2, 3, 4)**\n    所有页 $\\{1, 2, 3, 4\\}$ 都在内存中。这 $8$ 次引用都是命中。缺页计数保持为 $4$。\n\n-   **引用 13: (5)**\n    页 $5$ 不在内存中。这是一次缺页。内存中包含 $\\{1, 2, 3, 4\\}$ 并且有一个空页框。页 $5$ 被加载到空页框中。\n    -   引用 13 (5)：缺页。内存：$\\{1, 2, 3, 4, 5\\}$。缺页计数：$5$。\n    最近使用次序现在是 $(5, 4, 3, 2, 1)$。\n\n-   **引用 14-16: (6, 7, 8)**\n    这些引用导致缺页，并且由于内存已满，它们会触发替换。LRU 页是牺牲页。\n    -   引用 14 (6)：缺页。LRU 页是 $1$。逐出 $1$，加载 $6$。内存：$\\{2, 3, 4, 5, 6\\}$。缺页计数：$6$。最近次序：$(6, 5, 4, 3, 2)$。\n    -   引用 15 (7)：缺页。LRU 页是 $2$。逐出 $2$，加载 $7$。内存：$\\{3, 4, 5, 6, 7\\}$。缺页计数：$7$。最近次序：$(7, 6, 5, 4, 3)$。\n    -   引用 16 (8)：缺页。LRU 页是 $3$。逐出 $3$，加载 $8$。内存：$\\{4, 5, 6, 7, 8\\}$。缺页计数：$8$。最近次序：$(8, 7, 6, 5, 4)$。\n    短暂扫描现在已经从原始工作集中逐出了页 $1, 2, 3$。\n\n-   **引用 17-20: (1, 2, 3, 4)**\n    工作集的引用恢复，但这些页已经被逐出。\n    -   引用 17 (1)：缺页。LRU 页是 $4$。逐出 $4$，加载 $1$。内存：$\\{1, 5, 6, 7, 8\\}$。缺页计数：$9$。最近次序：$(1, 8, 7, 6, 5)$。\n    -   引用 18 (2)：缺页。LRU 页是 $5$。逐出 $5$，加载 $2$。内存：$\\{1, 2, 6, 7, 8\\}$。缺页计数：$10$。最近次序：$(2, 1, 8, 7, 6)$。\n    -   引用 19 (3)：缺页。LRU 页是 $6$。逐出 $6$，加载 $3$。内存：$\\{1, 2, 3, 7, 8\\}$。缺页计数：$11$。最近次序：$(3, 2, 1, 8, 7)$。\n    -   引用 20 (4)：缺页。LRU 页是 $7$。逐出 $7$，加载 $4$。内存：$\\{1, 2, 3, 4, 8\\}$。缺页计数：$12$。最近次序：$(4, 3, 2, 1, 8)$。\n\n-   **引用 21-24: (1, 2, 3, 4)**\n    工作集页 $\\{1, 2, 3, 4\\}$ 现在已回到内存中。这 $4$ 次引用都是命中。缺页计数保持为 $12$。\n\n标准 LRU 策略的总缺页次数为 $N_{\\text{faults, LRU}} = 12$。\n缺页率为 $R_{\\text{LRU}} = \\frac{N_{\\text{faults, LRU}}}{N_{\\text{ref}}} = \\frac{12}{24} = \\frac{1}{2}$。\n\n### 2. 过滤式 LRU 算法分析\n\n该策略使用大小为 $w=12$ 的滑动窗口来定义一个热点集 $H(t)$，其中包含在时间 $t$ 之前的 $w$ 个引用中被引用至少两次的页。发生缺页时，牺牲页是在不在 $H(t)$ 中的驻留页里最近最少使用的那个页。\n\n-   **引用 1-12: (1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4)**\n    -   对于引用 $1$ 到 $4$，我们有 $4$ 次强制性缺页。内存：$\\{1,2,3,4\\}$。缺页计数：$4$。\n    -   对于引用 $5$ 到 $12$，这些页在内存中，所以都是命中。\n    -   在此阶段，热点集 $H(t)$ 会演变。对于 $t \\le 5$，没有页被引用两次，所以 $H(t)=\\emptyset$。对于 $t \\ge 9$，窗口包含 $(1,2,3,4)$ 的两个完整周期，所以 $H(t)=\\{1,2,3,4\\}$。\n    -   在此阶段结束时（引用 12 之后），缺页计数为 $4$。\n\n-   **引用 13: (5)**\n    -   时间 $t=13$。之前的 $w=12$ 个引用是 $(1,2,3,4,1,2,3,4,1,2,3,4)$。$\\{1,2,3,4\\}$ 中的每个页都被引用了 $3$ 次。所以，$H(13)=\\{1,2,3,4\\}$。\n    -   页 $5$ 不在内存中（内存包含 $\\{1,2,3,4\\}$）。这是一次缺页。\n    -   有一个空页框，所以页 $5$ 被加载而无需替换。\n    -   内存：$\\{1,2,3,4,5\\}$。缺页计数：$4+1=5$。\n\n-   **引用 14: (6)**\n    -   时间 $t=14$。窗口是 $S_{2:13} = (2,3,4,1,2,3,4,1,2,3,4,5)$。页 $\\{1,2,3,4\\}$ 的频率 $\\ge 2$。所以，$H(14)=\\{1,2,3,4\\}$。\n    -   页 $6$ 不在内存中。这是一次缺页。内存已满。\n    -   驻留页集合为 $P=\\{1,2,3,4,5\\}$。\n    -   受保护的驻留页集合为 $P \\cap H(14) = \\{1,2,3,4\\}$。\n    -   可逐出的页集合为 $P \\setminus H(14) = \\{5\\}$。\n    -   牺牲页必须是页 $5$。逐出 $5$，加载 $6$。\n    -   内存：$\\{1,2,3,4,6\\}$。缺页计数：$5+1=6$。\n\n-   **引用 15: (7)**\n    -   时间 $t=15$。窗口是 $S_{3:14} = (3,4,1,2,3,4,1,2,3,4,5,6)$。$H(15)=\\{1,2,3,4\\}$。\n    -   页 $7$ 不在内存中。缺页。\n    -   驻留页 $P=\\{1,2,3,4,6\\}$。受保护的页 $P \\cap H(15)=\\{1,2,3,4\\}$。\n    -   可逐出的页 $P \\setminus H(15)=\\{6\\}$。牺牲页是 $6$。\n    -   逐出 $6$，加载 $7$。内存：$\\{1,2,3,4,7\\}$。缺页计数：$6+1=7$。\n\n-   **引用 16: (8)**\n    -   时间 $t=16$。窗口是 $S_{4:15} = (4,1,2,3,4,1,2,3,4,5,6,7)$。$\\{1,2,3,4\\}$ 中的每个页都出现至少两次。$H(16)=\\{1,2,3,4\\}$。\n    -   页 $8$ 不在内存中。缺页。\n    -   驻留页 $P=\\{1,2,3,4,7\\}$。受保护的页 $P \\cap H(16)=\\{1,2,3,4\\}$。\n    -   可逐出的页 $P \\setminus H(16)=\\{7\\}$。牺牲页是 $7$。\n    -   逐出 $7$，加载 $8$。内存：$\\{1,2,3,4,8\\}$。缺页计数：$7+1=8$。\n    此时，工作集页 $\\{1,2,3,4\\}$ 仍然驻留在内存中，受到热点集过滤器的保护。扫描页 $\\{5,6,7\\}$ 被依次加载和逐出。\n\n-   **引用 17-24: (1, 2, 3, 4, 1, 2, 3, 4)**\n    -   内存状态为 $\\{1,2,3,4,8\\}$。\n    -   此序列中的所有引用都是对页 $\\{1,2,3,4\\}$ 的。由于这些页都驻留在内存中，所有 $8$ 次引用都是命中。\n    -   在此阶段，热点集 $H(t)$ 将继续包含 $\\{1,2,3,4\\}$，因为这些页在滑动窗口内持续被频繁引用。\n    -   缺页计数没有增加。\n\n过滤式 LRU 策略的总缺页次数为 $N_{\\text{faults, FIL-LRU}} = 8$。\n缺页率为 $R_{\\text{FIL-LRU}} = \\frac{N_{\\text{faults, FIL-LRU}}}{N_{\\text{ref}}} = \\frac{8}{24} = \\frac{1}{3}$。\n\n### 3. 缺页率的降低\n\n问题要求计算过滤式 LRU 相对于标准 LRU 所实现的缺页率降低值。这即是差值 $\\Delta R = R_{\\text{LRU}} - R_{\\text{FIL-LRU}}$。\n\n$R_{\\text{LRU}} = \\frac{1}{2}$\n$R_{\\text{FIL-LRU}} = \\frac{1}{3}$\n\n$$\n\\Delta R = \\frac{1}{2} - \\frac{1}{3} = \\frac{3}{6} - \\frac{2}{6} = \\frac{1}{6}\n$$\n\n过滤式 LRU 策略将缺页率降低了 $\\frac{1}{6}$。",
            "answer": "$$\\boxed{\\frac{1}{6}}$$"
        }
    ]
}