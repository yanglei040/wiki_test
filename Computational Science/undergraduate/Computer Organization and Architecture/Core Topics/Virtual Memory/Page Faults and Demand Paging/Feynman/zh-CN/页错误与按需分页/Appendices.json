{
    "hands_on_practices": [
        {
            "introduction": "页错误是实现按需调页的代价，但这个代价究竟有多大？有效访问时间（EAT）模型为我们提供了一个量化页错误对系统性能影响的强大工具。通过这个练习，你将推导并运用EAT公式，计算在给定的性能目标下，系统所能容忍的最大页错误率。这不仅是一次计算，更是对虚拟内存系统中性能与开销之间核心权衡的深刻理解。",
            "id": "3663138",
            "problem": "一个计算机系统在其虚拟内存子系统中实现了请求分页。考虑一个正在运行的进程进行单次内存访问。该次访问的页面要么驻留在主存中，访问在主存内完成；要么该次访问触发一次缺页中断，必须由操作系统和后备存储在完成前进行处理。假设以下条件成立：\n\n- 一次访问触发缺页中断的概率为 $p$（对于所有访问是恒定且独立的）。\n- 如果访问未触发缺页中断，完成该访问所需时间为 $t_{m}$。\n- 如果访问触发了缺页中断，从访问开始到完成所需的时间（包括操作系统处理、后备存储传输和指令重启）为 $t_{pf}$。\n- 多次访问的平均完成时间，称为有效访问时间（EAT），用 $L$ 表示。\n\n工程师要求平均性能达到目标有效访问时间 $L = 300 \\,\\mathrm{ns}$。该系统的主存访问时间为 $t_{m} = 100 \\,\\mathrm{ns}$，测得的缺页中断服务时间为 $t_{pf} = 5.0 \\,\\mathrm{ms}$。\n\n从伯努利试验结果的期望值定义和上述场景约束出发，推导出一个关联 $L$、$t_{m}$、$t_{pf}$ 和 $p$ 的表达式。然后，用 $L$、$t_{m}$ 和 $t_{pf}$ 符号化地求解 $p$，并根据给定参数计算 $p$ 的数值。最后，确定使推导出的 $p$ 可行（即 $0 \\leq p \\leq 1$）的 $L$ 的界限，并定性地解释结果。将 $p$ 的数值表示为无单位的小数，并将答案四舍五入到四位有效数字。",
            "solution": "问题陈述已经过评估，被认为是有效的。它在科学上基于计算机体系结构和概率论的原理，问题提出得当，目标明确，并且内部一致。我们可以继续进行解答。\n\n该问题要求推导有效访问时间 ($L$) 的表达式，求解缺页概率 ($p$) 的符号解，计算给定参数下 $p$ 的数值，并分析 $L$ 的可行界限。\n\n首先，我们推导有效访问时间 $L$ 的表达式。一次内存访问是一个随机事件，有两种可能的结果：\n1.  访问未触发缺页中断。这种情况发生的概率为 $1-p$。完成访问的时间是主存访问时间 $t_m$。\n2.  访问触发了缺页中断。这种情况发生的概率为 $p$。处理中断并完成访问的时间是 $t_{pf}$。\n\n有效访问时间 ($L$) 定义为一次内存访问时间的期望值。对于离散随机变量，期望值是每个结果的值与其发生概率的乘积之和。因此，$L$ 由下式给出：\n$$L = (1-p) \\cdot t_m + p \\cdot t_{pf}$$\n\n这个方程关联了 $L$、$t_m$、$t_{pf}$ 和 $p$ 这四个量。\n\n接下来，我们对该表达式进行符号化求解以得到 $p$。我们对推导出的方程进行代数运算：\n$$L = t_m - p \\cdot t_m + p \\cdot t_{pf}$$\n为了分离 $p$，我们重新排列各项：\n$$L - t_m = p \\cdot (t_{pf} - t_m)$$\n假设 $t_{pf} \\neq t_m$（这是一个物理上的必然，因为处理一次缺页中断比一次内存访问慢几个数量级，所以 $t_{pf} > t_m$），我们可以用 $(t_{pf} - t_m)$ 进行除法运算：\n$$p = \\frac{L - t_m}{t_{pf} - t_m}$$\n这就是缺页概率 $p$ 的符号表达式。\n\n现在，我们使用给定的参数计算 $p$ 的数值：\n- 目标有效访问时间，$L = 300 \\,\\mathrm{ns}$\n- 主存访问时间，$t_m = 100 \\,\\mathrm{ns}$\n- 缺页中断服务时间，$t_{pf} = 5.0 \\,\\mathrm{ms}$\n\n在代入这些值之前，我们必须确保它们的单位一致。我们将所有时间转换为纳秒 ($ns$)，注意 $1 \\,\\mathrm{ms} = 10^6 \\,\\mathrm{ns}$。\n$$t_{pf} = 5.0 \\,\\mathrm{ms} = 5.0 \\times 10^6 \\,\\mathrm{ns}$$\n将数值代入 $p$ 的表达式：\n$$p = \\frac{300\\,\\mathrm{ns} - 100\\,\\mathrm{ns}}{5.0 \\times 10^6\\,\\mathrm{ns} - 100\\,\\mathrm{ns}}$$\n$$p = \\frac{200}{4999900}$$\n$$p = \\frac{2}{49999}$$\n其小数值为：\n$$p \\approx 0.0000400008...$$\n题目要求四舍五入到四位有效数字。第一位有效数字是 $4$。接下来的三位有效数字是 $0$、$0$ 和 $0$。第五位有效数字是 $0$，所以我们不进位。\n$$p \\approx 0.00004000$$\n\n最后，我们确定使推导出的概率 $p$ 可行的 $L$ 的界限。一个概率必须位于范围 $0 \\leq p \\leq 1$ 内。使用我们的 $p$ 的符号表达式：\n$$0 \\leq \\frac{L - t_m}{t_{pf} - t_m} \\leq 1$$\n如前所述，$t_{pf} > t_m$，所以分母 $(t_{pf} - t_m)$ 是一个正数。我们可以用这个项乘以整个不等式，而不用改变不等号的方向。\n\n下界由 $0 \\leq \\frac{L - t_m}{t_{pf} - t_m}$ 得出：\n$$0 \\leq L - t_m$$\n$$t_m \\leq L$$\n\n上界由 $\\frac{L - t_m}{t_{pf} - t_m} \\leq 1$ 得出：\n$$L - t_m \\leq t_{pf} - t_m$$\n$$L \\leq t_{pf}$$\n\n结合这些结果，有效访问时间 $L$ 的可行范围是：\n$$t_m \\leq L \\leq t_{pf}$$\n\n定性地看，这个结果是完全符合逻辑的。有效访问时间 $L$ 是最快可能访问时间 ($t_m$) 和最慢可能访问时间 ($t_{pf}$) 的加权平均值。根据定义，一组数值的平均值不能小于该组中的最小值，也不能大于最大值。\n- 如果 $L = t_m$，系统达到最快的可能性能。这只可能在从不发生缺页中断时发生，对应于 $p = \\frac{t_m - t_m}{t_{pf} - t_m} = 0$。\n- 如果 $L = t_{pf}$，系统表现出最慢的可能性能。这发生在每次内存访问都导致缺页中断时，对应于 $p = \\frac{t_{pf} - t_m}{t_{pf} - t_m} = 1$。\n任何在此范围 $[t_m, t_{pf}]$ 之外的 $L$ 都将意味着 $p$ 的值小于 $0$ 或大于 $1$，这对于概率来说在物理上和数学上都是不可能的。\n对于给定的参数，界限是 $100\\,\\mathrm{ns} \\leq L \\leq 5.0 \\times 10^6\\,\\mathrm{ns}$。目标 $L = 300\\,\\mathrm{ns}$ 在此有效范围内。",
            "answer": "$$\\boxed{0.00004000}$$"
        },
        {
            "introduction": "在有效访问时间模型中，页错误服务时间（$t_{pf}$）是一个关键参数，但其并非一个固定值。当内存已满时，发生页错误需要先“逐出”一个现有页面，而逐出的开销取决于该页面是否被修改过（即是否为“脏”页）。此练习将引导你探讨“脏位”的概念，并计算在给定脏页比例下，页面逐出的期望时间。这将让你更深入地理解构成页错误服务总时间的各个组成部分及其概率特性。",
            "id": "3663206",
            "problem": "一个计算机系统在内存压力下使用请求分页和写回式高速缓存。当一个页框必须被换出时，操作系统（OS）会检查该页是否为脏页。假设以下建模基于请求分页和写回策略的标准定义：\n\n- 一个页面在被换出时为脏页的长期比例为 $w$。\n- 如果页面是脏页，它必须通过一个能维持恒定顺序带宽 $B$ 的页换出数据通路写回后备存储。\n- 如果页面是干净的，则不会执行写回后备存储的操作，并且与数据传输时间相比，任何元数据开销都可以忽略不计。\n- 页面大小为 $S$ 字节。\n- 忽略排队和固定延迟效应；将脏页换出的传输时间视为以带宽 $B$ 传输 $S$ 字节所需的时间。\n\n从伯努利结果（脏页与干净页）的期望值定义出发，推导每次换出的期望时间，并计算当 $w = 0.37$，$S = 16\\,\\mathrm{KiB}$ 和 $B = 800\\,\\mathrm{MiB/s}$ 时的具体值。以微秒表示最终时间，并将答案四舍五入到四位有效数字。",
            "solution": "首先验证问题以确保其科学性、良构性和客观性。问题陈述描述了一个请求分页内存系统中页面换出的简化但标准的模型。脏页、写回、后备存储、页面大小和I/O带宽等概念都是基础性的，并且在计算机体系结构的背景下被正确使用。所提供的参数值在物理上是合理的。目标陈述得很明确：推导期望换出时间的表达式，并在给定条件下计算其数值。因此，该问题被认为是有效的。\n\n解答过程首先推导期望换出时间的符号表达式，然后代入给定的数值。\n\n设 $T$ 为表示单次页面换出所需时间的随机变量。问题指明了换出的两种可能结果，取决于页面是脏页还是干净页。\n\n1.  **页面是脏页**：此事件发生的概率为 $w$。如果页面是脏页，它必须被写回后备存储。此操作所需的时间 $T_{dirty}$ 是以恒定带宽 $B$ 传输大小为 $S$ 的页面数据所需的时间。排队和延迟效应被明确忽略。因此，\n    $$T_{dirty} = \\frac{S}{B}$$\n2.  **页面是干净的**：此事件发生的概率为 $1 - w$。如果页面是干净的，则不执行写回后备存储的操作，并且任何相关的开销都被认为可以忽略不计。因此，在这种情况下所花费的时间 $T_{clean}$ 为零。\n    $$T_{clean} = 0$$\n\n离散随机变量的期望值是每个结果的值乘以其发生概率的总和。将此定义应用于换出时间 $T$，我们得到期望换出时间 $E[T]$：\n$$E[T] = T_{dirty} \\cdot P(\\text{page is dirty}) + T_{clean} \\cdot P(\\text{page is clean})$$\n代入时间和概率的表达式：\n$$E[T] = \\left(\\frac{S}{B}\\right) \\cdot w + (0) \\cdot (1 - w)$$\n这可以简化为每次换出的期望时间的符号表达式：\n$$E[T] = w \\frac{S}{B}$$\n\n现在，我们将提供的数值代入此表达式：\n-   脏页的长期比例，$w = 0.37$\n-   页面大小，$S = 16\\,\\mathrm{KiB}$\n-   后备存储带宽，$B = 800\\,\\mathrm{MiB/s}$\n\n在进行计算之前，我们必须将单位转换为一致的基准。我们将使用字节作为大小单位，字节/秒作为带宽单位。请注意，KiB (kibibyte) 和 MiB (mebibyte) 是二进制前缀：\n-   $1\\,\\mathrm{KiB} = 2^{10}\\,\\text{bytes} = 1024\\,\\text{bytes}$\n-   $1\\,\\mathrm{MiB} = 2^{20}\\,\\text{bytes} = 1048576\\,\\text{bytes}$\n\n因此，以基本单位表示的给定参数为：\n-   $S = 16 \\times 2^{10}\\,\\text{bytes}$\n-   $B = 800 \\times 2^{20}\\,\\text{bytes/s}$\n\n将这些值代入 $E[T]$ 的表达式中：\n$$E[T] = 0.37 \\times \\frac{16 \\times 2^{10}\\,\\text{bytes}}{800 \\times 2^{20}\\,\\text{bytes/s}}$$\n结果的单位是秒 (s)。我们可以简化表达式：\n$$E[T] = 0.37 \\times \\frac{16}{800 \\times 2^{10}}\\,\\text{s}$$\n$$E[T] = 0.37 \\times \\frac{16}{800 \\times 1024}\\,\\text{s}$$\n$$E[T] = 0.37 \\times \\frac{16}{819200}\\,\\text{s}$$\n$$E[T] = 0.37 \\times \\frac{1}{51200}\\,\\text{s}$$\n$$E[T] = \\frac{0.37}{51200}\\,\\text{s} \\approx 7.2265625 \\times 10^{-6}\\,\\text{s}$$\n\n问题要求最终答案以微秒（$\\mu$s）表示。由于 $1\\,\\text{s} = 10^6\\,\\mu$s：\n$$E[T] = (7.2265625 \\times 10^{-6}) \\times 10^6\\,\\mu\\text{s}$$\n$$E[T] = 7.2265625\\,\\mu\\text{s}$$\n\n最后，问题要求将答案四舍五入到四位有效数字。前四位有效数字是 $7, 2, 2, 6$。第五位数字是 $5$，这要求对前一位数字进行进位。\n$$E[T] \\approx 7.227\\,\\mu\\text{s}$$",
            "answer": "$$\\boxed{7.227}$$"
        },
        {
            "introduction": "我们已经知道，系统性能对页错误率（$p$）极为敏感，但究竟是什么决定了$p$的大小呢？答案是页替换算法。不同的算法在选择“牺牲”哪个页面时采用不同策略，从而直接影响页错误的发生频率。这个终极实践练习将挑战你从零开始实现两种经典的页替换算法：理论最优的“最近最少使用”（LRU）算法及其实际近似的“老化”（Aging）算法。通过编写代码模拟并比较它们的性能，你将获得关于算法机制如何直接影响系统性能的、最直观和深入的动手经验。",
            "id": "3663131",
            "problem": "你需要编写一个完整的程序，模拟在两种页面置换策略下，针对一个给定的有限虚拟页面引用序列的请求分页过程：（i）最近最少使用（LRU）策略和（ii）通过定期将引用位采样至各页面计数器来近似LRU的老化策略。任务是为每个测试用例计算在每种策略下的总缺页次数，并将结果汇总到单行输出中。\n\n本问题的基本前提包括以下公认事实和定义：\n- 当一个进程引用一个未驻留在任何物理帧中的虚拟页面时，就会发生缺页；操作系统随后会将所引用的页面加载到一个帧中，如果所有帧都已满，则可能会淘汰另一个页面。替换决策不改变缺页的定义，缺页源于引用发生时内存中缺少被引用的页面。\n- 请求分页仅在页面被引用时才将其加载到内存中。\n- 最近最少使用（LRU）策略会淘汰其最近一次使用时间距离当前最远的驻留页面。\n- LRU的老化近似策略为每个驻留页面维护一个 $w$ 位的无符号计数器和一个单位的引用位。一个我们称为纪元（epoch）并用 $\\epsilon$ 表示的周期性事件，在处理完恰好 $E$ 次引用后（即每处理完一组 $E$ 次引用后）发生。在每个纪元结束时，每个驻留页面都会更新其计数器并清除其引用位。这种方法通过指数级衰减计数器同时注入最新的引用信息来近似计算近期性。\n\n你的程序必须按照以下方式从头开始实现这两种策略。\n\n两种策略的共享设置：\n- 物理内存有 $F \\ge 1$ 个帧。\n- 引用字符串是一个非负整数的有限序列，每个整数代表一个虚拟页号。\n- 在时间 $t=1$ 时（第一次引用之前），所有帧都是空的。所有未在内存中的页面的相关数据结构（如计数器和引用位）都初始化为 $0$。\n- 每处理一次引用，已处理引用计数加 $1$，该计数用于确定老化策略的纪元边界。\n\nLRU策略：\n- 在时间 $t$ 引用页面 $p$ 时：\n  - 如果 $p$ 是驻留页面，将其最后使用时间更新为 $t$（命中）。\n  - 如果 $p$ 不是驻留页面（缺页）：\n    - 如果有空闲帧，将 $p$ 加载到其中，并将其最后使用时间记录为 $t$。\n    - 否则，淘汰最后使用时间最小的驻留页面（即最近最少使用的页面）。如果存在平局，淘汰页号最小的页面。然后加载 $p$ 并将其最后使用时间设置为 $t$。\n  - 当且仅当 $p$ 在引用时刻不是驻留页面时，计为一次缺页。\n\n老化策略：\n- 参数：纪元长度 $E \\in \\mathbb{N}$ 和计数器宽度 $w \\in \\mathbb{N}$，其中 $w \\ge 1$。\n- 为每个驻留页面维护：\n  - 一个单位的引用位 $r \\in \\{0,1\\}$。\n  - 一个 $w$ 位的无符号计数器 $c \\in \\{0,1,\\dots,2^w-1\\}$。\n- 在时间 $t$ 引用页面 $p$ 时：\n  - 如果 $p$ 是驻留页面，为 $p$ 设置 $r \\leftarrow 1$（命中）。\n  - 如果 $p$ 不是驻留页面（缺页）：\n    - 如果有空闲帧，将 $p$ 加载到其中，并设置 $c \\leftarrow 0$ 和 $r \\leftarrow 1$。\n    - 否则，通过最小化 $c$ 来在驻留页面中选择一个牺牲者；如果有多个页面的 $c$ 值同为最小，则选择页号最小的那个。淘汰选中的牺牲者，然后加载 $p$ 并设置 $c \\leftarrow 0$ 和 $r \\leftarrow 1$。\n  - 处理完引用后（包括任何淘汰和加载操作），如果已处理引用计数是 $E$ 的倍数，则一个纪元结束，并对每个驻留页面独立应用以下更新：\n    - 令 $\\text{msb} = 2^{w-1}$。将 $c$ 替换为 $c' = \\left\\lfloor \\frac{c}{2} \\right\\rfloor + r \\cdot \\text{msb}$（这是一个逻辑右移一位并将 $r$ 插入最高有效位的操作），然后设置 $r \\leftarrow 0$。只有驻留页面会被更新。\n- 当且仅当 $p$ 在引用时刻不是驻留页面时，计为一次缺页。请注意事件顺序：针对当前引用的替换决策是使用当前的 $c$ 和 $r$ 值在纪元更新之前做出的；如果当前引用完成了一个纪元（即已处理的引用总数成为 $E$ 的倍数），则更新操作会在该引用被完全处理之后执行。\n\n忠实地实现这两种策略，并使用指定的平局打破规则以确保确定性。\n\n测试套件：\n你的程序必须计算以下四个测试用例在两种策略下的缺页次数。在每个案例中，页面按引用顺序列出，从时间 $t=1$ 到时间 $t=N$。\n1. 案例A（通用混合局部性）：\n   - 帧数 $F=3$，纪元长度 $E=4$，计数器宽度 $w=8$。\n   - 引用字符串 $\\langle 0,1,2,3,2,1,0,3,2,1,0,3 \\rangle$。\n2. 案例B（细粒度采样近似LRU）：\n   - 帧数 $F=2$，纪元长度 $E=1$，计数器宽度 $w=8$。\n   - 引用字符串 $\\langle 1,2,1,2,1,2,3 \\rangle$。\n3. 案例C（非常粗糙的采样，长纪元）：\n   - 帧数 $F=3$，纪元长度 $E=100$，计数器宽度 $w=8$。\n   - 引用字符串 $\\langle 1,2,3,4,1,2,3,4 \\rangle$。\n4. 案例D（单帧边界条件）：\n   - 帧数 $F=1$，纪元长度 $E=3$，计数器宽度 $w=8$。\n   - 引用字符串 $\\langle 1,2,3,4,1,2,3,4 \\rangle$。\n\n要求的最终输出格式：\n- 你的程序应生成单行输出，其中包含一个逗号分隔的配对列表，并用方括号括起来。每个配对本身是一个方括号列表 $[x,y]$，其中 $x$ 是老化策略下的总缺页次数， $y$ 是LRU策略下的总缺页次数，顺序与上述测试用例相同。\n- 例如，输出必须具有确切的形状 \"[[a1,b1],[a2,b2],[a3,b3],[a4,b4]]\"，不含空格，也不含任何附加文本。\n\n所有涉及的数字都是纯计数；没有物理单位。不涉及角度。不涉及分数或百分比。唯一有效的输出是整数，最终结果必须遵循上述格式规则。",
            "solution": "该问题要求模拟两种页面置换算法——最近最少使用（LRU）和一种基于老化的近似算法——以确定在一组给定的内存引用字符串下发生的缺页次数。问题定义明确，对状态初始化、命中/缺页处理、淘汰和决胜规则都有明确规定，从而确保了确定性和可验证的结果。\n\n### 算法实现逻辑\n\n#### 1. 最近最少使用（LRU）策略\n为了实现LRU，我们需要跟踪每个驻留页面最后一次被访问的时间。一个简单的方法是使用一个单调递增的时间戳（例如，引用序列的索引）。\n- **数据结构**：一个大小为 F 的数组或哈希表来表示物理帧，其中每个条目存储页号和其最后使用的时间戳。\n- **命中**：当引用的页面在内存中时，更新其时间戳。\n- **缺页**：\n    - 如果有空闲帧，将新页面加载到空闲帧中，并记录当前时间戳。\n    - 如果没有空闲帧，则遍历所有驻留页面，找到时间戳最小（即最旧）的页面作为牺牲者。如果存在平局，则选择页号最小的页面。用新页面替换牺牲者，并更新其时间戳。\n\n#### 2. 老化策略（LRU近似）\n该策略使用一个计数器来近似LRU，而无需存储精确的时间戳。\n- **数据结构**：为每个物理帧存储页号、一个 w 位计数器和一个引用位。\n- **命中**：当引用的页面在内存中时，将其引用位置为 1。\n- **缺页**：\n    - 如果有空闲帧，加载新页面，将其计数器初始化为 0，引用位置为 1。\n    - 如果没有空闲帧，则遍历所有驻留页面，找到计数器值最小的页面作为牺牲者。如果存在平局，则选择页号最小的页面。用新页面替换牺牲者，新页面的计数器初始化为 0，引用位置为 1。\n- **纪元更新**：每处理 E 次引用后，对所有驻留页面执行更新。每个页面的计数器逻辑右移一位，其当前的引用位被移入计数器的最高有效位 (MSB)，然后引用位清零。\n\n### 模拟结果\n\n根据上述规则对四个测试用例进行精确模拟，我们得到以下缺页次数：\n\n- **案例 A (F=3, E=4, w=8):**\n  - 老化算法: 7 次缺页\n  - LRU 算法: 10 次缺页\n  - 在这个混合局部性的场景中，老化算法的表现优于理论上的 LRU。\n\n- **案例 B (F=2, E=1, w=8):**\n  - 老化算法: 3 次缺页\n  - LRU 算法: 3 次缺页\n  - 当纪元长度为1时，老化算法非常频繁地更新计数器，使其行为与 LRU 非常接近。\n\n- **案例 C (F=3, E=100, w=8):**\n  - 老化算法: 7 次缺页\n  - LRU 算法: 8 次缺页\n  - 由于纪元长度远大于引用序列长度，老化算法的纪元更新从未触发。淘汰决策仅基于初始的零计数器和平局规则（最低页号），其行为类似于先进先出（FIFO）。\n\n- **案例 D (F=1, E=3, w=8):**\n  - 老化算法: 8 次缺页\n  - LRU 算法: 8 次缺页\n  - 当只有一个可用帧时，任何对不同页面的引用都会导致缺页，因此所有置换算法的行为都完全相同。\n\n将这些结果汇总成要求的格式，我们得到最终答案。",
            "answer": "[[7,10],[3,3],[7,8],[8,8]]"
        }
    ]
}