{
    "hands_on_practices": [
        {
            "introduction": "理论知识只有通过实践才能转化为深刻的理解。要真正掌握按需分页，我们首先需要量化其性能影响。此练习将指导您使用“有效访问时间”（Effective Access Time, EAT）模型，这是一个基础而强大的工具，用于分析页错误率如何显著影响整体内存系统性能。通过这个计算，您将亲身体会到，即使是极低的页错误率，也可能导致系统性能发生数量级的变化，从而理解为何优化页错误至关重要。",
            "id": "3663138",
            "problem": "一个计算机系统在其虚拟内存子系统中实现了请求分页。考虑一个正在运行的进程进行的一次内存引用。被引用的页面要么是驻留的，引用在主存中完成；要么引用会触发页面错误，必须由操作系统和后备存储在完成前进行服务。假设以下条件成立：\n\n- 一次引用触发页面错误的概率为 $p$（在所有引用中为常数且相互独立）。\n- 如果引用没有触发页面错误，完成引用的时间为 $t_{m}$。\n- 如果引用触发了页面错误，从引用开始到完成的时间（包括操作系统处理、后备存储传输和指令重启）为 $t_{pf}$。\n- 多次引用的平均完成时间，称为有效访问时间（Effective Access Time, EAT），用 $L$ 表示。\n\n工程师要求平均性能达到目标有效访问时间 $L = 300 \\,\\mathrm{ns}$。系统的主存访问时间为 $t_{m} = 100 \\,\\mathrm{ns}$，测得的页面错误服务时间为 $t_{pf} = 5.0 \\,\\mathrm{ms}$。\n\n从伯努利（Bernoulli）结果的期望值定义和上述场景约束出发，推导出一个关联 $L$、$t_{m}$、$t_{pf}$ 和 $p$ 的表达式。然后用 $L$、$t_{m}$ 和 $t_{pf}$ 符号化地求解 $p$，并根据给定参数计算 $p$ 的数值。最后，确定使推导出的 $p$ 可行（即 $0 \\leq p \\leq 1$）的 $L$ 的边界，并定性地解释结果。将 $p$ 的数值表示为无单位的小数，并将答案四舍五入到四位有效数字。",
            "solution": "问题陈述经评估有效。它在科学上基于计算机体系结构和概率论的原理，问题提出得当，目标明确，且内部一致。我们可以开始求解。\n\n问题要求推导有效访问时间（$L$）的表达式，页面错误概率（$p$）的符号解，根据给定参数计算 $p$ 的数值，并分析 $L$ 的可行边界。\n\n首先，我们推导有效访问时间 $L$ 的表达式。一次内存引用是一个随机事件，有两种可能的结果：\n1.  引用不触发页面错误。这种情况发生的概率为 $1-p$。完成引用的时间是主存访问时间 $t_m$。\n2.  引用触发页面错误。这种情况发生的概率为 $p$。服务错误并完成引用的时间为 $t_{pf}$。\n\n有效访问时间（$L$）被定义为一次内存引用时间的期望值。对于一个离散随机变量，期望值是每个结果的值乘以其发生概率的总和。因此，$L$ 由下式给出：\n$$L = (1-p) \\cdot t_m + p \\cdot t_{pf}$$\n\n这个方程关联了 $L$、$t_m$、$t_{pf}$ 和 $p$ 这四个量。\n\n接下来，我们对该表达式进行符号化求解以得到 $p$。我们对推导出的方程进行代数运算：\n$$L = t_m - p \\cdot t_m + p \\cdot t_{pf}$$\n为了分离出 $p$，我们重新整理各项：\n$$L - t_m = p \\cdot (t_{pf} - t_m)$$\n假设 $t_{pf} \\neq t_m$（这是一个物理上的必然，因为服务页面错误比内存访问慢几个数量级，所以 $t_{pf} > t_m$），我们可以两边同除以 $(t_{pf} - t_m)$：\n$$p = \\frac{L - t_m}{t_{pf} - t_m}$$\n这就是页面错误概率 $p$ 的符号表达式。\n\n现在，我们使用给定的参数计算 $p$ 的数值：\n- 目标有效访问时间，$L = 300 \\,\\mathrm{ns}$\n- 主存访问时间，$t_m = 100 \\,\\mathrm{ns}$\n- 页面错误服务时间，$t_{pf} = 5.0 \\,\\mathrm{ms}$\n\n在代入这些值之前，我们必须确保它们的单位一致。我们将所有时间转换为纳秒（ns），注意 $1 \\,\\mathrm{ms} = 10^6 \\,\\mathrm{ns}$。\n$$t_{pf} = 5.0 \\,\\mathrm{ms} = 5.0 \\times 10^6 \\,\\mathrm{ns}$$\n将数值代入 $p$ 的表达式中：\n$$p = \\frac{300\\,\\mathrm{ns} - 100\\,\\mathrm{ns}}{5.0 \\times 10^6\\,\\mathrm{ns} - 100\\,\\mathrm{ns}}$$\n$$p = \\frac{200}{4999900}$$\n$$p = \\frac{2}{49999}$$\n作为小数值，其结果是：\n$$p \\approx 0.0000400008...$$\n问题要求四舍五入到四位有效数字。第一位有效数字是 $4$。接下来的三位有效数字是 $0$、$0$ 和 $0$。第五位有效数字是 $0$，所以我们不进行进位。\n$$p \\approx 0.00004000$$\n\n最后，我们确定使推导出的概率 $p$ 可行的 $L$ 的边界。概率值必须在 $0 \\leq p \\leq 1$ 的范围内。使用我们为 $p$ 推导的符号表达式：\n$$0 \\leq \\frac{L - t_m}{t_{pf} - t_m} \\leq 1$$\n如前所述，$t_{pf} > t_m$，所以分母 $(t_{pf} - t_m)$ 是一个正数。我们可以用这个项乘以不等式两边，而不用改变不等号的方向。\n\n下界由 $0 \\leq \\frac{L - t_m}{t_{pf} - t_m}$ 得出：\n$$0 \\leq L - t_m$$\n$$t_m \\leq L$$\n\n上界由 $\\frac{L - t_m}{t_{pf} - t_m} \\leq 1$ 得出：\n$$L - t_m \\leq t_{pf} - t_m$$\n$$L \\leq t_{pf}$$\n\n综合这些结果，有效访问时间 $L$ 的可行范围是：\n$$t_m \\leq L \\leq t_{pf}$$\n\n从定性上看，这个结果是完全合乎逻辑的。有效访问时间 $L$ 是最快可能访问时间（$t_m$）和最慢可能访问时间（$t_{pf}$）的加权平均值。根据定义，一组数值的平均值不可能小于该组中的最小值，也不可能大于最大值。\n- 如果 $L = t_m$，系统达到最快的性能。这只可能在页面错误从不发生时出现，对应于 $p = \\frac{t_m - t_m}{t_{pf} - t_m} = 0$。\n- 如果 $L = t_{pf}$，系统表现出最慢的性能。这发生在每次内存引用都导致页面错误时，对应于 $p = \\frac{t_{pf} - t_m}{t_{pf} - t_m} = 1$。\n任何在此范围 $[t_m, t_{pf}]$ 之外的 $L$ 都将意味着 $p$ 的值小于0或大于1，这对于概率来说在物理上和数学上都是不可能的。\n对于给定的参数，边界为 $100\\,\\mathrm{ns} \\leq L \\leq 5.0 \\times 10^6\\,\\mathrm{ns}$。目标值 $L = 300\\,\\mathrm{ns}$ 在此有效范围内。",
            "answer": "$$\\boxed{0.00004000}$$"
        },
        {
            "introduction": "在上一个练习中，我们将页错误服务时间（$t_{pf}$）视为一个单一值。然而在现实中，这个时间是可变的，一个关键因素是需要被置换的页面是否为“脏”页（dirty page）。此练习将带您深入页错误处理的一个重要环节——页面置换成本。您将通过一个基于概率的简单模型，计算考虑了脏页写回磁盘开销的平均置换时间，从而更精确地理解构成页错误服务时间的关键组成部分。",
            "id": "3663206",
            "problem": "一个计算机系统在内存压力下使用带有写回缓存的请求分页机制。当一个页框必须被换出时，操作系统 (OS) 会检查该页是否是脏页。假设以下建模基于请求分页和写回策略的标准定义：\n\n- 在换出时，页为脏页的长期比例为 $w$。\n- 如果页是脏的，它必须通过一个能维持恒定顺序带宽 $B$ 的页换出数据路径写回到后备存储。\n- 如果页是干净的，则不执行写回到后备存储的操作，并且任何元数据开销与数据传输时间相比都可以忽略不计。\n- 页面大小为 $S$ 字节。\n- 忽略排队和固定延迟效应；将脏页换出的传输时间视为以带宽 $B$ 传输 $S$ 字节所需的时间。\n\n从伯努利试验结果（脏页与干净页）的期望值定义出发，推导出每次换出的期望时间，并计算当 $w = 0.37$，$S = 16\\,\\mathrm{KiB}$ 和 $B = 800\\,\\mathrm{MiB/s}$ 时的具体数值。将最终时间以微秒表示，并将答案四舍五入到四位有效数字。",
            "solution": "首先验证问题以确保其具有科学依据、提法恰当且客观。问题陈述描述了一个请求分页内存系统中页面换出的简化但标准的模型。脏页、写回、后备存储、页面大小和I/O带宽等概念都是计算机体系结构背景下的基本概念，并且在此处被正确使用。所提供的参数值在物理上是合理的。目标被清晰地陈述：推导期望换出时间的表达式，并在给定条件下计算其数值。因此，该问题被认为是有效的。\n\n解题过程首先推导期望换出时间的符号表达式，然后代入给定的数值。\n\n设 $T$ 为单次页面换出所需时间的随机变量。问题指明了页面换出的两种可能结果，取决于页面是脏的还是干净的。\n\n1.  **页是脏的**：此事件以给定的概率 $w$ 发生。如果页是脏的，它必须被写回到后备存储。此操作所需的时间 $T_{dirty}$ 是以恒定带宽 $B$ 传输大小为 $S$ 的页面数据所需的时间。排队和延迟效应被明确忽略。因此，\n    $$T_{dirty} = \\frac{S}{B}$$\n2.  **页是干净的**：此事件以概率 $1 - w$ 发生。如果页是干净的，则不执行写回到后备存储的操作，并且任何相关的开销都被视为可以忽略不计。因此，在这种情况下所花费的时间 $T_{clean}$ 为零。\n    $$T_{clean} = 0$$\n\n离散随机变量的期望值是每个可能结果的值与其发生概率的乘积之和。将此定义应用于换出时间 $T$，我们得到期望换出时间 $E[T]$：\n$$E[T] = T_{dirty} \\cdot P(\\text{page is dirty}) + T_{clean} \\cdot P(\\text{page is clean})$$\n代入时间和概率的表达式：\n$$E[T] = \\left(\\frac{S}{B}\\right) \\cdot w + (0) \\cdot (1 - w)$$\n这可以化简为每次换出期望时间的符号表达式：\n$$E[T] = w \\frac{S}{B}$$\n\n现在，我们将提供的数值代入此表达式：\n-   脏页的长期比例, $w = 0.37$\n-   页面大小, $S = 16\\,\\mathrm{KiB}$\n-   后备存储带宽, $B = 800\\,\\mathrm{MiB/s}$\n\n在进行计算之前，我们必须将单位转换为一致的基准。我们将使用字节作为大小的单位，字节/秒作为带宽的单位。注意 KiB (kibibyte) 和 MiB (mebibyte) 是二进制前缀：\n-   $1\\,\\mathrm{KiB} = 2^{10}\\,\\text{bytes} = 1024\\,\\text{bytes}$\n-   $1\\,\\mathrm{MiB} = 2^{20}\\,\\text{bytes} = 1048576\\,\\text{bytes}$\n\n因此，以基准单位表示的给定参数为：\n-   $S = 16 \\times 2^{10}\\,\\text{bytes}$\n-   $B = 800 \\times 2^{20}\\,\\text{bytes/s}$\n\n将这些值代入 $E[T]$ 的表达式中：\n$$E[T] = 0.37 \\times \\frac{16 \\times 2^{10}\\,\\text{bytes}}{800 \\times 2^{20}\\,\\text{bytes/s}}$$\n结果的单位是秒 (s)。我们可以化简该表达式：\n$$E[T] = 0.37 \\times \\frac{16}{800 \\times 2^{10}}\\,\\text{s}$$\n$$E[T] = 0.37 \\times \\frac{16}{800 \\times 1024}\\,\\text{s}$$\n$$E[T] = 0.37 \\times \\frac{16}{819200}\\,\\text{s}$$\n$$E[T] = 0.37 \\times \\frac{1}{51200}\\,\\text{s}$$\n$$E[T] = \\frac{0.37}{51200}\\,\\text{s} \\approx 7.2265625 \\times 10^{-6}\\,\\text{s}$$\n\n问题要求最终答案以微秒 ($\\mu$s) 表示。由于 $1\\,\\text{s} = 10^6\\,\\mu$s：\n$$E[T] = (7.2265625 \\times 10^{-6}) \\times 10^6\\,\\mu\\text{s}$$\n$$E[T] = 7.2265625\\,\\mu\\text{s}$$\n\n最后，问题要求将答案四舍五入到四位有效数字。前四位有效数字是 $7, 2, 2, 6$。第五位数字是 $5$，因此需要将前一位数字向上取整。\n$$E[T] \\approx 7.227\\,\\mu\\text{s}$$",
            "answer": "$$\\boxed{7.227}$$"
        },
        {
            "introduction": "我们已经分析了页错误的性能代价，现在是时候探索如何主动控制和减少它们了。页错误发生的频率在很大程度上取决于操作系统所采用的页面置换算法。这个编程练习提供了一个绝佳的动手实践机会，您将亲手实现并比较两种经典的置换策略：理想化的最近最少使用（LRU）算法和一种更实用的近似算法（老化算法）。通过模拟和比较它们在相同访问序列下的表现，您将直观地理解算法设计如何直接影响系统效率，并体会到理论与实践之间的权衡。",
            "id": "3663131",
            "problem": "你需要编写一个完整的程序，模拟在两种页面置换策略下，给定一个有限的虚拟页面引用序列的需求分页过程：(i) 最近最少使用 (LRU) 策略和 (ii) 通过定期采样引用位到每页计数器来近似 LRU 的老化策略。任务是为每个测试用例计算每种策略下的总缺页次数，并将结果汇总到单行输出中。\n\n本问题的基本依据包括以下公认的事实和定义：\n- 当一个进程引用一个不在任何物理帧中的虚拟页面时，就会发生缺页；操作系统随后会将引用的页面加载到一个帧中，如果所有帧都已满，可能会换出另一个页面。置换决策不改变缺页的定义，缺页是在引用时内存中缺少被引用页面的结果。\n- 需求分页仅在页面被引用时才将其加载到内存中。\n- 最近最少使用 (LRU) 策略会换出其最近一次使用时间距离现在最远的驻留页面。\n- LRU 的老化近似算法为每个驻留页面维护一个 $w$ 位的无符号计数器和一个单位的引用位。一个我们称为“时期”（epoch）并用 $\\epsilon$ 表示的周期性事件，在处理完恰好 $E$ 次引用后发生（即每处理完一个包含 $E$ 次引用的块）。在每个时期结束时，每个驻留页面会更新其计数器并清除其引用位。这通过指数衰减计数器同时注入最新的引用信息来近似新近度。\n\n你的程序必须从零开始按如下方式实现这两种策略。\n\n两种策略的共享设置：\n- 物理内存有 $F \\ge 1$ 个帧。\n- 引用字符串是一个非负整数的有限序列，每个整数都是一个虚拟页码。\n- 在时间 $t=1$ 时（第一次引用之前），所有帧都是空的。对于不在内存中的页面，所有每页数据结构（如计数器和引用位）都初始化为 $0$。\n- 每次处理引用都会使已处理引用计数加 $1$，该计数用于确定老化策略的时期边界。\n\nLRU 策略：\n- 在时间 $t$ 引用页面 $p$ 时：\n  - 如果 $p$ 是驻留页面，将其最后使用时间更新为 $t$（命中）。\n  - 如果 $p$ 不是驻留页面（缺页）：\n    - 如果有空闲帧，将 $p$ 加载到其中，并将其最后使用时间记录为 $t$。\n    - 否则，换出具有最小“最后使用时间”的驻留页面（即最近最少使用的页面）。如果出现平局，则换出页码最小的页面。然后加载 $p$ 并将其最后使用时间设置为 $t$。\n  - 仅当 $p$ 在引用时刻不是驻留页面时，才计为一次缺页。\n\n老化策略：\n- 参数：时期长度 $E \\in \\mathbb{N}$ 和计数器宽度 $w \\in \\mathbb{N}$，其中 $w \\ge 1$。\n- 为每个驻留页面维护：\n  - 一个单位的引用位 $r \\in \\{0,1\\}$。\n  - 一个 $w$ 位的无符号计数器 $c \\in \\{0,1,\\dots,2^w-1\\}$。\n- 在时间 $t$ 引用页面 $p$ 时：\n  - 如果 $p$ 是驻留页面，为 $p$ 设置 $r \\leftarrow 1$（命中）。\n  - 如果 $p$ 不是驻留页面（缺页）：\n    - 如果有空闲帧，将 $p$ 加载到其中，并设置 $c \\leftarrow 0$ 和 $r \\leftarrow 1$。\n    - 否则，在驻留页面中通过最小化 $c$ 来选择一个牺牲页面；如果多个页面的 $c$ 值同为最小，则选择页码最小的那个。换出所选的牺牲页面，然后加载 $p$ 并设置 $c \\leftarrow 0$ 和 $r \\leftarrow 1$。\n  - 在处理完引用（包括任何换出和加载）后，如果已处理引用总数是 $E$ 的倍数，则时期结束，并对每个驻留页面独立应用以下更新：\n    - 设 $\\text{msb} = 2^{w-1}$。将 $c$ 替换为 $c' = \\left\\lfloor \\frac{c}{2} \\right\\rfloor + r \\cdot \\text{msb}$（这是一个逻辑右移一位并将 $r$ 插入最高有效位的操作），然后设置 $r \\leftarrow 0$。只有驻留页面会被更新。\n- 仅当 $p$ 在引用时刻不是驻留页面时，才计为一次缺页。请仔细注意事件顺序：当前引用的置换决策是在时期更新前使用当前的 $c$ 和 $r$ 值做出的；如果当前引用完成了一个时期（即已处理引用总数成为 $E$ 的倍数），则更新操作在此引用被完全处理后执行。\n\n忠实地实现这两种策略，并使用指定的决胜规则以确保确定性。\n\n测试套件：\n你的程序必须为以下四个测试用例计算两种策略下的缺页次数。在每个用例中，页面按从时间 $t=1$ 到时间 $t=N$ 的引用顺序列出。\n1. 用例 A (一般混合局部性):\n   - 帧数 $F=3$，时期长度 $E=4$，计数器宽度 $w=8$。\n   - 引用字符串 $\\langle 0,1,2,3,2,1,0,3,2,1,0,3 \\rangle$。\n2. 用例 B (近似 LRU 的细粒度采样):\n   - 帧数 $F=2$，时期长度 $E=1$，计数器宽度 $w=8$。\n   - 引用字符串 $\\langle 1,2,1,2,1,2,3 \\rangle$。\n3. 用例 C (非常粗糙的采样，长时期):\n   - 帧数 $F=3$，时期长度 $E=100$，计数器宽度 $w=8$。\n   - 引用字符串 $\\langle 1,2,3,4,1,2,3,4 \\rangle$。\n4. 用例 D (单帧边界条件):\n   - 帧数 $F=1$，时期长度 $E=3$，计数器宽度 $w=8$。\n   - 引用字符串 $\\langle 1,2,3,4,1,2,3,4 \\rangle$。\n\n要求的最终输出格式：\n- 你的程序应产生单行输出，包含一个逗号分隔的配对列表，用方括号括起来，其中每个配对本身是一个方括号列表 $[x,y]$，$x$ 等于老化策略下的总缺页次数，$y$ 等于 LRU 策略下的总缺页次数，顺序与上述测试用例相同。\n- 例如，输出必须具有确切的格式 \"[[a1,b1],[a2,b2],[a3,b3],[a4,b4]]\"，不含空格也无额外文本。\n\n所有涉及的数字都是纯计数；没有物理单位。不涉及角度。不涉及分数或百分比。唯一有效的输出是整数，并且最终结果必须遵循上述格式规则。",
            "solution": "该问题要求对两种页面置换算法——最近最少使用（LRU）和老化算法（Aging）——进行模拟，以计算在四个不同测试用例下的总缺页次数。我们将严格遵循问题中定义的规则，包括帧数、时期长度、引用位/计数器行为以及决胜规则（当多个页面成为牺牲候选时，选择页码最小的那个）。\n\n对每个测试用例，我们初始化一个包含 F 个空帧的物理内存，然后按顺序处理引用字符串，追踪两种算法的缺页情况。\n\n**用例 A: F=3, E=4, 引用串 <0,1,2,3,2,1,0,3,2,1,0,3>**\n- **LRU**: 引用序列导致了10次缺页。当内存满时，总是置换最近最少使用的页面。例如，在引用`3`时，`0`被换出；在引用`0`时，`3`被换出，以此类推。\n- **老化算法**: 模拟显示共发生7次缺页。计数器更新在第4、8、12次引用后发生。例如，在第7次引用`0`时，页面`1`的计数器最低，被换出。这与LRU的选择不同，最终导致了更少的缺页。\n\n**用例 B: F=2, E=1, 引用串 <1,2,1,2,1,2,3>**\n- **LRU**: 前两次引用`1`和`2`导致缺页。后续对`1`和`2`的引用均为命中。最后引用`3`时置换页面`1`（因`2`刚被引用），总计3次缺页。\n- **老化算法**: 由于时期长度E=1，每次引用后计数器都会更新。这种高频采样使得老化算法的行为非常接近LRU，同样产生3次缺页。\n\n**用例 C: F=3, E=100, 引用串 <1,2,3,4,1,2,3,4>**\n- **LRU**: 引用序列`1,2,3`填满帧。引用`4`换出`1`。引用`1`换出`2`。引用`2`换出`3`。引用`3`换出`4`。引用`4`换出`1`。总计8次缺页。\n- **老化算法**: 由于时期长度E=100远大于引用串长度8，计数器在整个模拟过程中永远不会更新。所有页面的计数器始终为0。因此，置换决策完全依赖于决胜规则（最小页码），这使得算法表现得像先进先出（FIFO）的一个变体。这种策略下，`3`和`4`的引用是命中，总共产生7次缺页。\n\n**用例 D: F=1, E=3, 引用串 <1,2,3,4,1,2,3,4>**\n- **LRU**: 只有一个帧，每次引用一个与当前驻留页面不同的页面时都会发生缺页。总计8次缺页。\n- **老化算法**: 同样，只有一个帧时，除了第一次引用，每次引用不同的页面都必须置换当前页面，导致8次缺页。算法细节（如时期更新）在此边界条件下不影响结果。\n\n总结所有用例的结果，我们得到以下缺页次数对（格式为[老化算法, LRU]）：\n- 用例 A: [7, 10]\n- 用例 B: [3, 3]\n- 用例 C: [7, 8]\n- 用例 D: [8, 8]",
            "answer": "[[7,10],[3,3],[7,8],[8,8]]"
        }
    ]
}