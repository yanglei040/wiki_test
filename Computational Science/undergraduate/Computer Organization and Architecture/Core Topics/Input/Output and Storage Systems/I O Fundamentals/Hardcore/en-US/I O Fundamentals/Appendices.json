{
    "hands_on_practices": [
        {
            "introduction": "Deciding between Programmed I/O (PIO) and Direct Memory Access (DMA) is a foundational choice in I/O system design. This practice guides you through a classic break-even analysis to determine the block size at which DMA's fixed setup cost becomes more efficient than PIO's per-word transfer overhead . Mastering this calculation is key to selecting the right data transfer mechanism based on the expected workload.",
            "id": "3648466",
            "problem": "A processor communicates with an Advanced Technology Attachment (ATA) disk using either Programmed Input/Output (PIO) or Direct Memory Access (DMA). In Programmed Input/Output (PIO), the central processing unit (CPU) actively transfers each data word, incurring a per-word overhead of $c_{pio}$ CPU cycles. In Direct Memory Access (DMA), a DMA controller moves data autonomously after a one-time setup performed by the CPU, incurring a fixed setup overhead of $c_{setup}$ CPU cycles, with no additional per-word CPU cycles during the transfer. Assume the CPU clock period is $T_{clk}$, and that the device-to-memory bus transfer time for moving the data block is identical for both PIO and DMA and depends only on the block size $S$ in words, not on the method; thus, this bus transfer time can be treated as a common term when comparing total transfer times.\n\nUsing only first principles of time and cycle counting, namely that elapsed CPU time is the product of the number of cycles and the CPU clock period, derive the smallest integer block size $S^{*}$ (measured in words) such that the total transfer time with DMA is strictly less than the total transfer time with PIO. Express your final answer as a closed-form analytic expression in terms of $c_{setup}$ and $c_{pio}$. No rounding is required. State your answer for $S^{*}$ in words.",
            "solution": "The problem requires the derivation of the smallest integer block size, denoted as $S^{*}$, for which a data transfer using Direct Memory Access (DMA) is strictly faster than using Programmed Input/Output (PIO). The criterion for comparison is the total transfer time.\n\nLet $S$ be the block size in words. The givens are:\n- $c_{pio}$: Per-word CPU overhead for PIO, in cycles.\n- $c_{setup}$: Fixed CPU setup overhead for DMA, in cycles.\n- $T_{clk}$: The CPU clock period.\n\nThe problem states that \"elapsed CPU time is the product of the number of cycles and the CPU clock period\". We can use this principle to model the time costs associated with the CPU for both PIO and DMA. The problem also specifies that the bus transfer time is identical for both methods, so it will cancel out when we compare the total times.\n\nLet's define the total time for a PIO transfer, $T_{total, PIO}$, and a DMA transfer, $T_{total, DMA}$. These times consist of the CPU time overhead and the bus data transfer time. Let $T_{bus}(S)$ be the time to transfer a block of size $S$ over the bus.\n\nFor a PIO transfer of a block of size $S$ words, the CPU is involved in transferring each word. The total number of CPU cycles consumed is the product of the block size and the per-word cycle overhead.\n$$ N_{cycles, PIO} = S \\cdot c_{pio} $$\nThe corresponding CPU time for PIO, $T_{CPU, PIO}$, is:\n$$ T_{CPU, PIO} = N_{cycles, PIO} \\cdot T_{clk} = (S \\cdot c_{pio}) \\cdot T_{clk} $$\nThe total time for the PIO transfer is therefore:\n$$ T_{total, PIO} = T_{CPU, PIO} + T_{bus}(S) = (S \\cdot c_{pio}) \\cdot T_{clk} + T_{bus}(S) $$\n\nFor a DMA transfer of a block of size $S$ words, the CPU only performs an initial setup. After this, the DMA controller manages the transfer, and the CPU is free to perform other tasks. The number of CPU cycles consumed is a fixed setup cost, independent of the block size.\n$$ N_{cycles, DMA} = c_{setup} $$\nThe corresponding CPU time for DMA, $T_{CPU, DMA}$, is:\n$$ T_{CPU, DMA} = N_{cycles, DMA} \\cdot T_{clk} = c_{setup} \\cdot T_{clk} $$\nThe total time for the DMA transfer is:\n$$ T_{total, DMA} = T_{CPU, DMA} + T_{bus}(S) = c_{setup} \\cdot T_{clk} + T_{bus}(S) $$\n\nWe are seeking the condition where the DMA transfer is strictly faster than the PIO transfer. This translates to the inequality:\n$$ T_{total, DMA}  T_{total, PIO} $$\nSubstituting the expressions for the total times:\n$$ c_{setup} \\cdot T_{clk} + T_{bus}(S)  (S \\cdot c_{pio}) \\cdot T_{clk} + T_{bus}(S) $$\nThe bus transfer time $T_{bus}(S)$ is a common term on both sides of the inequality and can be canceled.\n$$ c_{setup} \\cdot T_{clk}  (S \\cdot c_{pio}) \\cdot T_{clk} $$\nSince the CPU clock period $T_{clk}$ is a physical time duration, it must be a positive value ($T_{clk} > 0$). We can divide both sides of the inequality by $T_{clk}$ without changing its direction.\n$$ c_{setup}  S \\cdot c_{pio} $$\nTo solve for $S$, we must consider the value of $c_{pio}$. The term $c_{pio}$ represents the per-word overhead in CPU cycles. For the problem to be physically meaningful and for there to be a crossover point where DMA becomes advantageous, this overhead must be positive ($c_{pio} > 0$). If $c_{pio}$ were zero or negative, PIO would always be at least as fast as DMA (assuming a non-negative setup cost $c_{setup}$). Assuming $c_{pio} > 0$, we can divide by it to isolate $S$:\n$$ \\frac{c_{setup}}{c_{pio}}  S $$\nOr, written with $S$ on the left side:\n$$ S > \\frac{c_{setup}}{c_{pio}} $$\nThe problem asks for the smallest integer block size, $S^{*}$, that satisfies this condition. Let $R = \\frac{c_{setup}}{c_{pio}}$. The condition is $S > R$. The set of integers $S$ that satisfy this is $\\{ k \\in \\mathbb{Z} \\mid k > R \\}$. The smallest integer in this set is the integer that immediately follows the value of $R$. This can be formally expressed using the floor function, which gives the greatest integer less than or equal to its argument. The smallest integer greater than $R$ is $\\lfloor R \\rfloor + 1$.\nFor instance, if $R = 15.3$, the condition is $S > 15.3$. The smallest integer $S$ is $16$, which is $\\lfloor 15.3 \\rfloor + 1 = 15 + 1$. If $R$ is an integer, say $R = 15$, the condition is $S > 15$. The smallest integer $S$ is again $16$, which is $\\lfloor 15 \\rfloor + 1 = 15 + 1$.\nTherefore, the smallest integer block size $S^{*}$ is given by:\n$$ S^{*} = \\left\\lfloor \\frac{c_{setup}}{c_{pio}} \\right\\rfloor + 1 $$\nThis expression provides the breakeven point in terms of block size, measured in words. For any block size $S \\ge S^{*}$, the DMA method will have a lower or equal CPU time cost. Since the problem demands strictly less time, $S^{*}$ is the first integer value for which this condition holds.",
            "answer": "$$\n\\boxed{\\left\\lfloor \\frac{c_{setup}}{c_{pio}} \\right\\rfloor + 1}\n$$"
        },
        {
            "introduction": "Once DMA is chosen for large data transfers, the next step is to optimize its performance. This exercise explores how to maximize DMA throughput by selecting an optimal burst size, a crucial parameter that balances transfer efficiency against system responsiveness . You will learn to navigate real-world constraints, such as maximum allowable CPU stalls and bus granularity, to achieve the best possible performance.",
            "id": "3648441",
            "problem": "A system-on-chip employs Direct Memory Access (DMA) to move data from main memory to a device over a shared system bus. The DMA controller issues repeated bursts, each consisting of three phases in order: a bus arbitration phase of duration $\\ell$, a fixed controller overhead phase of duration $o$, and a data movement phase of duration equal to the total bytes moved $b$ divided by the bus transfer rate $\\rho$. The Central Processing Unit (CPU) can access the bus only when the DMA is not occupying it; consequently, the CPU is stalled while the DMA holds the bus, which occurs during the overhead and data movement phases. The bus arbitration phase does not stall the CPU.\n\nAssume the system operates in steady state with back-to-back DMA bursts. Use the following values:\n- Arbitration latency $\\ell = 1$ microsecond,\n- Per-burst overhead $o = 2$ microseconds,\n- Bus transfer rate $\\rho = 1600$ bytes per microsecond,\n- Maximum allowable CPU stall per burst $L_{\\text{stall}} = 20$ microseconds,\n- Bus beat granularity $s = 64$ bytes (each burst size must be an integer multiple of $s$).\n\nStarting from the definitions of throughput and the stall constraint articulated above, determine the burst size $b$ (in bytes) that maximizes the steady-state DMA throughput subject to the requirement that the maximum CPU stall per burst is less than or equal to $L_{\\text{stall}}$. Your answer must be a single number and must be expressed in bytes. No rounding by significant figures is required; adhere exactly to the bus granularity $s$.",
            "solution": "The objective is to find the burst size $b$ that maximizes the steady-state DMA throughput, $\\Theta$, subject to the given constraints. Throughput is the amount of data transferred per unit of time. For a steady state of back-to-back bursts, the total time for one cycle is the duration of a single burst, $T_{burst}$.\n\nThe duration of one burst is the sum of its three phases: arbitration time ($\\ell$), overhead time ($o$), and data movement time ($b/\\rho$).\n$$ T_{burst} = \\ell + o + \\frac{b}{\\rho} $$\n\nThe steady-state throughput $\\Theta(b)$ as a function of the burst size $b$ is the data transferred per burst divided by the time per burst:\n$$ \\Theta(b) = \\frac{b}{T_{burst}} = \\frac{b}{\\ell + o + \\frac{b}{\\rho}} $$\n\nTo maximize throughput, we analyze this function. Rewriting it as $\\Theta(b) = \\frac{b \\rho}{(\\ell + o)\\rho + b}$, we can see that the derivative with respect to $b$ is $\\frac{d\\Theta}{db} = \\frac{(\\ell + o)\\rho^2}{((\\ell + o)\\rho + b)^2}$. Since all parameters are positive, this derivative is always positive. This proves that throughput $\\Theta(b)$ is a monotonically increasing function of the burst size $b$. Therefore, to maximize throughput, we must choose the largest possible value for $b$ that satisfies all constraints.\n\nThere are two constraints on $b$. First, the CPU stall per burst must not exceed $L_{\\text{stall}}$. The CPU is stalled during the overhead and data movement phases, so the total stall time is $T_{stall} = o + \\frac{b}{\\rho}$. The constraint is:\n$$ o + \\frac{b}{\\rho} \\le L_{\\text{stall}} $$\nSolving for $b$ gives the upper bound: $b \\le \\rho (L_{\\text{stall}} - o)$.\n\nSecond, the burst size $b$ must be an integer multiple of the bus beat granularity $s=64$ bytes.\n\nTo find the optimal burst size, $b_{opt}$, we find the largest integer multiple of $s$ that is less than or equal to the maximum value derived from the stall constraint. We substitute the given numerical values: $\\rho = 1600$ bytes/$\\mu$s, $L_{\\text{stall}} = 20$ $\\mu$s, and $o = 2$ $\\mu$s.\n\nThe maximum allowed burst size is:\n$$ b_{max\\_limit} = 1600 \\frac{\\text{bytes}}{\\mu s} \\times (20 \\mu s - 2 \\mu s) = 1600 \\frac{\\text{bytes}}{\\mu s} \\times 18 \\mu s = 28800 \\text{ bytes} $$\nSo, we must have $b \\le 28800$ bytes.\n\nNow we apply the granularity constraint. We need the largest multiple of $s = 64$ bytes that is less than or equal to $28800$ bytes.\n$$ \\frac{28800}{64} = 450 $$\nSince the result is an integer, the maximum allowed size is already a valid multiple of the granularity. The optimal burst size is therefore $28800$ bytes.",
            "answer": "$$\\boxed{28800}$$"
        },
        {
            "introduction": "Real-world systems rarely have just one active I/O device; more often, multiple components compete for shared resources. This practice challenges you to analyze the performance of Programmed I/O in the presence of a Direct Memory Access (DMA) engine that creates bus contention . By modeling the impact of this contention, you will gain a deeper understanding of how system-level interactions affect I/O throughput.",
            "id": "3648418",
            "problem": "A Central Processing Unit (CPU) running at clock frequency $f$ executes a tight Programmed Input/Output (PIO) loop that transfers $w$ bytes per iteration to an I/O-mapped device. In the absence of any contention, each loop iteration requires $c$ CPU cycles from start to end. Of these $c$ cycles, exactly $b$ cycles must drive the shared memoryâ€“I/O bus, while the remaining $c - b$ cycles use only internal CPU resources and do not require the bus. The system also contains a Direct Memory Access (DMA) engine that arbitrates fairly for the same bus and occupies it for a long-run fraction $r$ of wall-clock time, with $0 \\leq r  1$. Arbitration is instantaneous and exclusive, so when the DMA engine is using the bus, CPU bus cycles stall until the bus becomes available. Assume no caches, no interrupts, and no other sources of stalls. All bus and CPU timing are synchronous with the CPU clock for the purposes of this model.\n\nStarting only from the fundamental definitions that throughput equals data divided by time, that the CPU clock period is $1/f$, and that a long-run time fraction $r$ of bus unavailability linearly reduces the effective rate at which bus cycles can be executed by the CPU to a fraction $1 - r$ of the raw clock rate, derive a closed-form expression for the steady-state sustainable PIO throughput $B$ in bytes per second as a function of $f$, $c$, $w$, $b$, and $r$. Then evaluate $B$ numerically for\n- $f = 2.4 \\times 10^{9}$ Hz,\n- $c = 40$ cycles per transfer,\n- $b = 12$ bus cycles per transfer,\n- $w = 4$ bytes per transfer,\n- $r = 0.25$.\n\nExpress the final throughput in mebibytes per second (MiB/s), using $1 \\text{ MiB} = 2^{20}$ bytes. Round your answer to four significant figures.",
            "solution": "The steady-state throughput, $B$, is defined as the amount of data transferred per unit of time. For a single iteration of the PIO loop, this is given by:\n$$B = \\frac{w}{T_{iter}}$$\nwhere $w$ is the number of bytes transferred in one iteration and $T_{iter}$ is the total time taken for one iteration.\n\nThe total time for one iteration, $T_{iter}$, is the sum of the time spent on internal CPU-only operations and the time spent on operations requiring the shared bus. The CPU clock period is $T_{clk} = 1/f$.\n\nThe time for internal (non-bus) cycles, which are unaffected by DMA contention, is:\n$$T_{internal} = (c - b) \\times T_{clk} = \\frac{c - b}{f}$$\nThe bus is occupied by DMA for a fraction $r$ of the time, so the effective clock rate for the CPU's bus cycles is $f_{eff} = f(1 - r)$. The time to complete one bus cycle is, on average, $1/f_{eff}$. The total time for the $b$ bus-dependent cycles is:\n$$T_{bus} = b \\times \\frac{1}{f(1 - r)} = \\frac{b}{f(1 - r)}$$\nThe total time for one loop iteration is the sum of these two components:\n$$T_{iter} = T_{internal} + T_{bus} = \\frac{c - b}{f} + \\frac{b}{f(1 - r)}$$\nCombining these terms over a common denominator gives:\n$$T_{iter} = \\frac{(c - b)(1 - r) + b}{f(1 - r)} = \\frac{c(1 - r) + br}{f(1 - r)}$$\nSubstituting this into the throughput equation yields the closed-form expression:\n$$B = \\frac{w}{T_{iter}} = \\frac{w f (1 - r)}{c(1 - r) + br}$$\nNow, we substitute the given numerical values: $f = 2.4 \\times 10^{9}$ Hz, $c = 40$, $b = 12$, $w = 4$ bytes, and $r = 0.25$.\n$$B = \\frac{4 \\times (2.4 \\times 10^{9}) \\times (1 - 0.25)}{40 \\times (1 - 0.25) + 12 \\times 0.25} = \\frac{4 \\times (2.4 \\times 10^{9}) \\times 0.75}{40 \\times 0.75 + 3} = \\frac{7.2 \\times 10^{9}}{30 + 3} = \\frac{7.2 \\times 10^{9}}{33} \\text{ bytes/s}$$\n$$B \\approx 218,181,818.18 \\text{ bytes/s}$$\nFinally, we convert this result to mebibytes per second (MiB/s), using $1 \\text{ MiB} = 2^{20} \\text{ bytes} = 1,048,576$ bytes, and round to four significant figures:\n$$B_{\\text{MiB/s}} = \\frac{218,181,818.18}{1,048,576} \\approx 208.07374 \\text{ MiB/s}$$\nRounding to four significant figures gives $208.1$ MiB/s.",
            "answer": "$$\\boxed{208.1}$$"
        }
    ]
}