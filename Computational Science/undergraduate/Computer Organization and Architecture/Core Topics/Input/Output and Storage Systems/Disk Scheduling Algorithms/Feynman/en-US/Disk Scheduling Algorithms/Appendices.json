{
    "hands_on_practices": [
        {
            "introduction": "We begin with a foundational exercise to build your computational skills. This practice  presents a concrete set of disk requests and asks you to trace the behavior of six primary scheduling algorithms: FCFS, SSTF, SCAN, LOOK, C-SCAN, and C-LOOK. By calculating key performance metrics like total head movement and average response time, you will gain a direct, quantitative understanding of the trade-offs each algorithm makes between raw efficiency and fairness.",
            "id": "3635884",
            "problem": "A magnetic hard disk has cylinders indexed from $0$ to $199$. The disk head starts at cylinder $75$ at time $t=0$ with initial sweep direction toward increasing cylinder numbers. Eight read requests arrive simultaneously at $t=0$ with the following cylinder numbers, listed in the order they are presented to the operating system: $40$, $150$, $10$, $90$, $15$, $180$, $60$, $20$. Consider six disk scheduling algorithms: First-Come, First-Served (FCFS), Shortest Seek Time First (SSTF), SCAN, LOOK, Circular SCAN (C-SCAN), and Circular LOOK (C-LOOK). Assume that:\n- All requests arrive at $t=0$ (so response time equals completion time).\n- Seek time is modeled linearly as $t_{\\text{seek}}(d)=\\alpha+\\beta d$, where $d$ is the absolute cylinder distance moved, with $\\alpha=0.2\\,\\mathrm{ms}$ and $\\beta=0.01\\,\\mathrm{ms}/\\text{cylinder}$.\n- The average rotational latency is half a rotation. The disk rotates at $7200$ revolutions per minute, so the mean rotational latency is $T_{\\text{rot}}=\\frac{1}{2}\\times\\frac{60\\times 1000}{7200}\\,\\mathrm{ms}=\\frac{25}{6}\\,\\mathrm{ms}$.\n- Each request transfers a single sector with constant transfer time $T_{\\text{xfer}}=0.5\\,\\mathrm{ms}$.\n- Therefore, the service time for a request that follows a head movement of distance $d$ is $t(d)=\\alpha+\\beta d+T_{\\text{rot}}+T_{\\text{xfer}}=\\frac{73}{15}+\\frac{d}{100}\\,\\mathrm{ms}$.\n- For SCAN and C-SCAN, the head continues to the physical end ($0$ or $199$) before reversing (SCAN) or wrapping (C-SCAN) if no request lies further in the current sweep direction; any such repositioning movement that does not immediately serve a request consumes time modeled purely as $\\beta d$ with no $\\alpha$, no rotation, and no transfer.\n- For LOOK and C-LOOK, the head reverses or wraps only at the last request in the current direction (no travel to the physical end), so there is no repositioning movement beyond the last requested cylinder.\n- Ties in SSTF are broken by choosing the lower-numbered cylinder; for SCAN and C-SCAN, the initial direction is toward increasing cylinder numbers; for LOOK and C-LOOK, the initial sweep is also toward increasing cylinder numbers.\n\nTasks:\n1. For each algorithm (FCFS, SSTF, SCAN, LOOK, C-SCAN, C-LOOK), determine the exact service order given the starting position and rules above.\n2. For each algorithm, compute the total head movement in cylinders (include all movement, including any SCAN or C-SCAN repositioning).\n3. For each algorithm, compute the average response time (mean of the completion times of the eight requests) using the service time model $t(d)=\\frac{73}{15}+\\frac{d}{100}$ and including any repositioning time where applicable.\n4. Interpret the differences in total head movement and average response time among the algorithms in terms of locality and fairness.\n\nFinally, define the summary metric $R$ to be the ratio of the maximum total head movement to the minimum total head movement across these six algorithms. Compute $R$. Round your final value of $R$ to four significant figures. Report the final value of $R$ with no units.",
            "solution": "The problem is a well-posed and self-contained exercise in analyzing disk scheduling algorithms, a standard topic in computer organization and operating systems. All necessary data, models, and constraints are provided and are scientifically and mathematically sound. Therefore, a complete solution can be derived.\n\nThe givens are:\n- Cylinder range: $[0, 199]$.\n- Initial head position: $C_{\\text{start}}=75$.\n- Initial time: $t=0$.\n- Initial direction of sweep: toward increasing cylinder numbers.\n- Request queue (simultaneous arrival at $t=0$): a set of $N=8$ requests for cylinders $\\{10, 15, 20, 40, 60, 90, 150, 180\\}$.\n- The order of arrival for FCFS is: $40, 150, 10, 90, 15, 180, 60, 20$.\n- The service time for a request following a head movement of distance $d$ is $t(d) = T_{\\text{const}} + \\beta d$, where the constant time component is $T_{\\text{const}} = \\alpha + T_{\\text{rot}} + T_{\\text{xfer}} = \\frac{73}{15}\\,\\mathrm{ms}$ and the seek time coefficient is $\\beta = 0.01\\,\\mathrm{ms}/\\text{cylinder} = \\frac{1}{100}\\,\\mathrm{ms}/\\text{cylinder}$.\n- The repositioning time for SCAN and C-SCAN is modeled as $t_{\\text{repo}}(d) = \\beta d = \\frac{d}{100}\\,\\mathrm{ms}$.\n\nSince all requests arrive at $t=0$, the response time for a request is equal to its completion time. The average response time is the mean of the completion times for all $N=8$ requests. Let $S = (c_1, c_2, \\dots, c_8)$ be the service order of cylinders for a given algorithm. The head starts at $c_0=75$. The distance moved for the $i$-th request is $d_i = |c_i - c_{i-1}|$. The service time for the $i$-th request is $T_i$. The completion time for the $i$-th request is $C_i = \\sum_{j=1}^{i} T_j$.\n\nWe analyze each of the six algorithms.\n\n**1. First-Come, First-Served (FCFS)**\nThe requests are serviced in the order they arrived.\n- Service Order: $40, 150, 10, 90, 15, 180, 60, 20$.\n- Movement Path: $75 \\to 40 \\to 150 \\to 10 \\to 90 \\to 15 \\to 180 \\to 60 \\to 20$.\n- Head Movements ($d_i$): $d_1=|40-75|=35$, $d_2=|150-40|=110$, $d_3=|10-150|=140$, $d_4=|90-10|=80$, $d_5=|15-90|=75$, $d_6=|180-15|=165$, $d_7=|60-180|=120$, $d_8=|20-60|=40$.\n- Total Head Movement: $\\sum d_i = 35+110+140+80+75+165+120+40 = 765$ cylinders.\n- Average Response Time: The sum of completion times is $\\sum_{i=1}^{8} C_i = \\sum_{i=1}^{8} (8-i+1) T_i$.\n  $T_i = \\frac{73}{15} + \\frac{d_i}{100}$.\n  $\\sum C_i = \\frac{73}{15}\\sum_{i=1}^{8}(8-i+1) + \\frac{1}{100}\\sum_{i=1}^{8}(8-i+1)d_i$. The first sum is $\\frac{8 \\times 9}{2} = 36$.\n  $\\sum(8-i+1)d_i = 8(35)+7(110)+6(140)+5(80)+4(75)+3(165)+2(120)+1(40) = 3365$.\n  $\\sum C_i = \\frac{73}{15}(36) + \\frac{3365}{100} = 175.2 + 33.65 = 208.85\\,\\mathrm{ms}$.\n  Average Response Time = $\\frac{208.85}{8} = 26.10625\\,\\mathrm{ms}$.\n\n**2. Shortest Seek Time First (SSTF)**\nThe request with the minimum seek distance from the current head position is selected next.\n- Head at $75$. Distances to $60$ and $90$ are both $15$. Tie-breaking rule selects the lower cylinder, $60$.\n- Path: $75 \\to 60 \\to 40 \\to 20 \\to 15 \\to 10 \\to 90 \\to 150 \\to 180$.\n- Service Order: $60, 40, 20, 15, 10, 90, 150, 180$.\n- Head Movements ($d_i$): $15, 20, 20, 5, 5, 80, 60, 30$.\n- Total Head Movement: $\\sum d_i = 15+20+20+5+5+80+60+30 = 235$ cylinders.\n- Average Response Time:\n  $\\sum(8-i+1)d_i = 8(15)+7(20)+6(20)+5(5)+4(5)+3(80)+2(60)+1(30) = 815$.\n  $\\sum C_i = \\frac{73}{15}(36) + \\frac{815}{100} = 175.2 + 8.15 = 183.35\\,\\mathrm{ms}$.\n  Average Response Time = $\\frac{183.35}{8} = 22.91875\\,\\mathrm{ms}$.\n\n**3. SCAN (Elevator Algorithm)**\nThe head sweeps back and forth across the disk.\n- Start at $75$, direction is increasing.\n- Service Order: $90, 150, 180$. Then moves to end $199$, reverses, and services $60, 40, 20, 15, 10$.\n- Total Movement Path: $75 \\to 199 \\to 10$.\n- Total Head Movement: $(199-75) + (199-10) = 124 + 189 = 313$ cylinders.\n- Average Response Time:\n  - $C_{90}: t(15)$.\n  - $C_{150}: C_{90} + t(60)$.\n  - $C_{180}: C_{150} + t(30)$.\n  - After servicing $180$, head moves to $199$. $d_{\\text{repo1}}=19$. Time taken is $t_{\\text{repo1}} = \\frac{19}{100} = 0.19\\,\\mathrm{ms}$.\n  - Time upon arrival at $199$ is $C_{180} + t_{\\text{repo1}}$.\n  - The next service is for cylinder $60$. The head moves from $199$ to $60$, a distance of $d_4=139$.\n  - $C_{60}: (C_{180} + t_{\\text{repo1}}) + t(139)$.\n  - Subsequent services: $C_{40} = C_{60}+t(20)$, $C_{20}=C_{40}+t(20)$, $C_{15}=C_{20}+t(5)$, $C_{10}=C_{15}+t(5)$.\n  - Summing the individual completion times:\n  $\\sum C_i = (T_0+0.15) + (2T_0+0.75) + (3T_0+1.05) + (4T_0+2.63) + (5T_0+2.83) + (6T_0+3.03) + (7T_0+3.08) + (8T_0+3.13) = 36T_0 + 16.65$. (Where $T_0=\\frac{73}{15}$)\n  $\\sum C_i = 175.2 + 16.65 = 191.85\\,\\mathrm{ms}$.\n  Average Response Time = $\\frac{191.85}{8} = 23.98125\\,\\mathrm{ms}$.\n\n**4. LOOK**\nSimilar to SCAN, but the head reverses direction at the last request in the current direction.\n- Service Order: $90, 150, 180$. Reverses at $180$, then services $60, 40, 20, 15, 10$.\n- Total Movement Path: $75 \\to 180 \\to 10$.\n- Total Head Movement: $(180-75) + (180-10) = 105 + 170 = 275$ cylinders.\n- Average Response Time: No repositioning time. After servicing $180$, the next service is for $60$. The travel distance is $|60-180|=120$.\n  - $C_{90}: t(15)$, $C_{150}: C_{90}+t(60)$, $C_{180}: C_{150}+t(30)$.\n  - $C_{60}: C_{180}+t(120)$.\n  - Summing completion times:\n  $\\sum C_i = (T_0+0.15) + (2T_0+0.75) + (3T_0+1.05) + (4T_0+2.25) + (5T_0+2.45) + (6T_0+2.65) + (7T_0+2.70) + (8T_0+2.75) = 36T_0 + 14.75$.\n  $\\sum C_i = 175.2 + 14.75 = 189.95\\,\\mathrm{ms}$.\n  Average Response Time = $\\frac{189.95}{8} = 23.74375\\,\\mathrm{ms}$.\n\n**5. Circular SCAN (C-SCAN)**\nThe head sweeps in one direction only. After reaching the end, it returns to the start and sweeps again.\n- Start at $75$, direction increasing.\n- Service Order: $90, 150, 180$. Move to end $199$, wrap to $0$, then service $10, 15, 20, 40, 60$.\n- Total Movement Path: $75 \\to 199$ (services), $199 \\to 0$ (reposition), $0 \\to 60$ (services).\n- Total Head Movement: $(199-75) + (199-0) + (60-0) = 124 + 199 + 60 = 383$ cylinders.\n- Average Response Time:\n  - Repositioning moves are from $180 \\to 199$ ($d=19$) and $199 \\to 0$ ($d=199$). Total reposition distance is $218$.\n  - Total repositioning time is $t_{\\text{repo}} = \\frac{218}{100} = 2.18\\,\\mathrm{ms}$.\n  - The logic is similar to SCAN.\n  - Summing completion times:\n  $\\sum C_i = (T_0+0.15) + (2T_0+0.75) + (3T_0+1.05) + (4T_0+3.33) + (5T_0+3.38) + (6T_0+3.43) + (7T_0+3.63) + (8T_0+3.83) = 36T_0 + 19.55$.\n  $\\sum C_i = 175.2 + 19.55 = 194.75\\,\\mathrm{ms}$.\n  Average Response Time = $\\frac{194.75}{8} = 24.34375\\,\\mathrm{ms}$.\n\n**6. Circular LOOK (C-LOOK)**\nSimilar to C-SCAN, but the head wraps from the last request to the first request of the next cycle.\n- Service Order: $90, 150, 180$. Then wraps to $10$ and services $10, 15, 20, 40, 60$.\n- Head movements are all part of service seeks. Path: $75 \\to 90 \\to \\dots \\to 180 \\to 10 \\to \\dots \\to 60$.\n- Head Movements ($d_i$): $15, 60, 30, |10-180|=170, 5, 5, 20, 20$.\n- Total Head Movement: $15+60+30+170+5+5+20+20 = 325$ cylinders.\n- Average Response Time:\n  $\\sum(8-i+1)d_i = 8(15)+7(60)+6(30)+5(170)+4(5)+3(5)+2(20)+1(20) = 1665$.\n  $\\sum C_i = \\frac{73}{15}(36) + \\frac{1665}{100} = 175.2 + 16.65 = 191.85\\,\\mathrm{ms}$.\n  Average Response Time = $\\frac{191.85}{8} = 23.98125\\,\\mathrm{ms}$.\n\n**Summary of Results**\n\n| Algorithm | Total Head Movement | Avg. Response Time (ms) |\n|-----------|--------------------:|------------------------:|\n| FCFS      | $765$               | $26.10625$              |\n| SSTF      | $235$               | $22.91875$              |\n| SCAN      | $313$               | $23.98125$              |\n| LOOK      | $275$               | $23.74375$              |\n| C-SCAN    | $383$               | $24.34375$              |\n| C-LOOK    | $325$               | $23.98125$              |\n\n**Interpretation**\n- **Locality and Head Movement**: SSTF minimizes total head movement ($235$ cylinders) by exploiting spatial locality, always choosing the nearest request. FCFS performs the worst ($765$ cylinders) as it ignores locality entirely. The SCAN/LOOK variants fall in between. LOOK ($275$) and C-LOOK ($325$) outperform their SCAN ($313$) and C-SCAN ($383$) counterparts by avoiding unnecessary travel to the physical ends of the disk.\n- **Fairness and Response Time**: FCFS is definitionally fair in terms of preventing starvation but has the highest average response time due to its inefficiency. SSTF provides the lowest average response time, maximizing throughput, but can lead to starvation for distant requests (a fairness issue not apparent in this static batch). The SCAN/LOOK family offers a compromise. C-SCAN and C-LOOK generally provide more uniform wait times than SCAN and LOOK, as requests only ever wait for one sweep direction. In this specific case, LOOK provides the best response time among the sweep-based algorithms, and the average response times for SCAN and C-LOOK happen to be identical due to the specific combination of request locations and timings.\n\n**Final Metric Calculation**\nThe summary metric $R$ is the ratio of the maximum to the minimum total head movement.\n- Maximum total head movement, $H_{\\text{max}} = 765$ (from FCFS).\n- Minimum total head movement, $H_{\\text{min}} = 235$ (from SSTF).\n\nThe ratio is:\n$$R = \\frac{H_{\\text{max}}}{H_{\\text{min}}} = \\frac{765}{235} = \\frac{153}{47}$$\nNumerically, this is:\n$$R \\approx 3.25531914...$$\nRounding to four significant figures, we get $R = 3.255$.",
            "answer": "$$ \\boxed{3.255} $$"
        },
        {
            "introduction": "True understanding extends beyond rote calculation to predicting how algorithms respond to changing conditions. This exercise  challenges you to think analytically by modifying a request queue to deliberately create a scenario where the sweep-based SCAN and LOOK algorithms outperform FCFS and SSTF. This hands-on analysis sharpens your intuition about the geometric path efficiencies that underpin different scheduling strategies.",
            "id": "3635792",
            "problem": "Consider a single rotating magnetic disk with tracks indexed by integers from $0$ through $9$ inclusive. The disk head initially resides at track $H=5$ and is moving in the increasing-track direction. A batch of input/output requests arrives and is queued in First-Come, First-Served order as the finite sequence $Q=\\langle 3,4,7,9\\rangle$. Assume the seek-time cost model in which the total head movement is the sum of absolute differences in track indices between consecutive serviced requests (including the initial movement from $H$ to the first serviced request), and that processing terminates once all requests in the given batch have been serviced. \n\nUse the following algorithmic definitions grounded in the disk head movement model:\n- First-Come, First-Served (FCFS): service requests strictly in their arrival order $Q$.\n- Shortest Seek Time First (SSTF): at each step, select the pending request whose track index is closest (in absolute difference) to the current head position, breaking ties by choosing the lower track index.\n- SCAN (elevator): the head continues in its current direction to the extreme track in that direction (here $9$), servicing any requests it encounters on the way, then reverses direction and continues to the opposite extreme track (here $0$), servicing any remaining requests encountered on the way.\n- LOOK: similar to SCAN, except the head only travels as far as the furthest outstanding request in the current direction before reversing, and does not continue to an extreme track absent a request.\n\nTasks:\n1. Starting from $H=5$, determine for each algorithm (FCFS, SSTF, SCAN, LOOK) the exact service order over $Q=\\langle 3,4,7,9\\rangle$ and compute the corresponding total head movement (expressed in tracks). Provide the service sequences and head-movement totals based only on the above definitions and the seek-time cost model.\n2. Now append one additional request at an integer track $x$ to the end of the arrival sequence, yielding $Q'=\\langle 3,4,7,9,x\\rangle$, where $x\\in\\{0,1,\\ldots,9\\}\\setminus\\{3,4,7,9\\}$. Using the same initial head position $H=5$ and initial direction, determine the smallest numerical value of $x$ such that, when $Q'$ is scheduled, both SCAN and LOOK yield strictly smaller total head movement than both FCFS and SSTF. Report that smallest such $x$ as your final answer. All head-movement quantities should be expressed in tracks. No rounding is required.",
            "solution": "The problem presents a classical disk scheduling scenario and is divided into two parts. The first part requires the calculation of total head movement for four standard algorithms (FCFS, SSTF, SCAN, LOOK) for a given request queue. The second part asks for the smallest integer track request $x$ to be appended to the queue, which makes the SCAN and LOOK algorithms strictly more efficient than both FCFS and SSTF in terms of total head movement.\n\nThe problem is well-posed. The disk parameters (tracks $0$ to $9$), initial head position ($H=5$), initial head direction (increasing), request queue ($Q=\\langle 3,4,7,9\\rangle$), and cost model (total seek distance) are all clearly defined. The algorithms are described by their standard definitions, including a tie-breaking rule for SSTF. The domain for the unknown request $x$ is explicitly specified as $x\\in\\{0,1,\\ldots,9\\}\\setminus\\{3,4,7,9\\}$.\n\n### Part 1: Analysis with Queue $Q = \\langle 3, 4, 7, 9 \\rangle$\n\nThe initial state is head at track $H=5$, moving toward higher track numbers. The request set is $\\{3, 4, 7, 9\\}$.\n\n**1. First-Come, First-Served (FCFS)**\nThe requests are serviced in the order they appear in the queue: $\\langle 3, 4, 7, 9 \\rangle$.\nThe head moves along the path $5 \\to 3 \\to 4 \\to 7 \\to 9$.\nTotal head movement is the sum of the absolute differences:\n$$ M_{FCFS} = |3-5| + |4-3| + |7-4| + |9-7| = 2 + 1 + 3 + 2 = 8 $$\nThe service order is $\\langle 3, 4, 7, 9 \\rangle$ and the total movement is $8$ tracks.\n\n**2. Shortest Seek Time First (SSTF)**\nAt each step, the request closest to the current head position is serviced.\n- Initial position: $H=5$. Requests: $\\{3, 4, 7, 9\\}$. Distances: $|3-5|=2$, $|4-5|=1$, $|7-5|=2$, $|9-5|=4$. The closest is track $4$.\n- Current position: $4$. Remaining requests: $\\{3, 7, 9\\}$. Distances: $|3-4|=1$, $|7-4|=3$, $|9-4|=5$. The closest is track $3$.\n- Current position: $3$. Remaining requests: $\\{7, 9\\}$. Distances: $|7-3|=4$, $|9-3|=6$. The closest is track $7$.\n- Current position: $7$. Remaining request: $\\{9\\}$. Service track $9$.\nThe service order is $\\langle 4, 3, 7, 9 \\rangle$. The head moves along the path $5 \\to 4 \\to 3 \\to 7 \\to 9$.\nTotal head movement is:\n$$ M_{SSTF} = |4-5| + |3-4| + |7-3| + |9-7| = 1 + 1 + 4 + 2 = 8 $$\nThe service order is $\\langle 4, 3, 7, 9 \\rangle$ and the total movement is $8$ tracks.\n\n**3. SCAN (Elevator Algorithm)**\nThe head starts at $H=5$ and moves in the increasing direction towards the extreme track, $9$. It services requests on the way.\n- Movement towards track $9$: Services requests $7$ and $9$.\n- At track $9$, the head reverses direction and moves towards the other extreme, track $0$. It services remaining requests on its way.\n- Movement towards track $0$: Services requests $4$ and $3$.\nThe service order is $\\langle 7, 9, 4, 3 \\rangle$. The head moves along the path $5 \\to 7 \\to 9 \\to 4 \\to 3$.\nTotal head movement is:\n$$ M_{SCAN} = |7-5| + |9-7| + |4-9| + |3-4| = 2 + 2 + 5 + 1 = 10 $$\nThe service order is $\\langle 7, 9, 4, 3 \\rangle$ and the total movement is $10$ tracks.\n\n**4. LOOK**\nThis algorithm is similar to SCAN, but the head only travels as far as the last request in each direction.\n- Initial direction is increasing. The furthest request in this direction is at track $9$. The head moves from $5$ to $9$, servicing $7$ and $9$.\n- At track $9$, the head reverses. The furthest remaining request is at track $3$. The head moves from $9$ to $3$, servicing $4$ and $3$.\nFor this specific queue, the outermost request ($9$) is also the extreme track, so LOOK behaves identically to SCAN.\nThe service order is $\\langle 7, 9, 4, 3 \\rangle$. The head path is $5 \\to 7 \\to 9 \\to 4 \\to 3$.\nTotal head movement is:\n$$ M_{LOOK} = |7-5| + |9-7| + |4-9| + |3-4| = 2 + 2 + 5 + 1 = 10 $$\nThe service order is $\\langle 7, 9, 4, 3 \\rangle$ and the total movement is $10$ tracks.\n\n### Part 2: Finding the Smallest Value of $x$\n\nWe are given a new queue $Q'=\\langle 3,4,7,9,x\\rangle$, where $x \\in \\{0,1,2,5,6,8\\}$. We must find the smallest $x$ such that the total head movement for SCAN and LOOK, denoted $M_{SCAN}(x)$ and $M_{LOOK}(x)$, are both strictly smaller than the movements for FCFS and SSTF, denoted $M_{FCFS}(x)$ and $M_{SSTF}(x)$. The conditions are:\n1. $M_{SCAN}(x) < M_{FCFS}(x)$\n2. $M_{SCAN}(x) < M_{SSTF}(x)$\n3. $M_{LOOK}(x) < M_{FCFS}(x)$\n4. $M_{LOOK}(x) < M_{SSTF}(x)$\n\nWe test the possible values of $x$ in increasing order, starting with the smallest, $x=0$.\n\n**Analysis for $x=0$**\nThe request set becomes $\\{0, 3, 4, 7, 9\\}$. The initial state remains $H=5$, moving in the increasing direction.\n\n**1. FCFS with $x=0$**\nThe service order is $\\langle 3, 4, 7, 9, 0 \\rangle$. The head moves on path $5 \\to 3 \\to 4 \\to 7 \\to 9 \\to 0$.\n$$ M_{FCFS}(0) = |3-5| + |4-3| + |7-4| + |9-7| + |0-9| = 2 + 1 + 3 + 2 + 9 = 17 $$\n\n**2. SSTF with $x=0$**\nThe request set is $\\{0, 3, 4, 7, 9\\}$.\n- Start at $H=5$: Closest request is $4$ (distance $1$). Move $5 \\to 4$.\n- At $4$: Remaining $\\{0, 3, 7, 9\\}$. Closest is $3$ (distance $1$). Move $4 \\to 3$.\n- At $3$: Remaining $\\{0, 7, 9\\}$. Closest is $0$ (distance $3$). Move $3 \\to 0$.\n- At $0$: Remaining $\\{7, 9\\}$. Closest is $7$ (distance $7$). Move $0 \\to 7$.\n- At $7$: Remaining $\\{9\\}$. Service $9$. Move $7 \\to 9$.\nThe path is $5 \\to 4 \\to 3 \\to 0 \\to 7 \\to 9$.\n$$ M_{SSTF}(0) = |4-5| + |3-4| + |0-3| + |7-0| + |9-7| = 1 + 1 + 3 + 7 + 2 = 14 $$\n\n**3. SCAN with $x=0$**\nThe head moves from $H=5$ towards track $9$, servicing $7$ and $9$. Then it reverses at track $9$ and moves towards track $0$, servicing $4, 3, 0$.\nThe path is $5 \\to 7 \\to 9 \\to 4 \\to 3 \\to 0$.\n$$ M_{SCAN}(0) = |7-5| + |9-7| + |4-9| + |3-4| + |0-3| = 2 + 2 + 5 + 1 + 3 = 13 $$\n\n**4. LOOK with $x=0$**\nThe head moves from $H=5$ towards the furthest request in the increasing direction, which is $9$. It services $7$ and $9$. At $9$, it reverses. The furthest remaining request is $0$. The head moves towards $0$, servicing $4, 3, 0$. The path and behavior are identical to SCAN for this request set.\n$$ M_{LOOK}(0) = 13 $$\n\n**Verification for $x=0$**\nWe check the conditions with the calculated movements:\n- $M_{FCFS}(0) = 17$\n- $M_{SSTF}(0) = 14$\n- $M_{SCAN}(0) = 13$\n- $M_{LOOK}(0) = 13$\n\n1. Is $M_{SCAN}(0) < M_{FCFS}(0)$? $13 < 17$. True.\n2. Is $M_{SCAN}(0) < M_{SSTF}(0)$? $13 < 14$. True.\n3. Is $M_{LOOK}(0) < M_{FCFS}(0)$? $13 < 17$. True.\n4. Is $M_{LOOK}(0) < M_{SSTF}(0)$? $13 < 14$. True.\n\nAll four conditions are satisfied for $x=0$. Since $x=0$ is the smallest value in the set of possible choices for $x$, it is the smallest numerical value of $x$ that fulfills the problem's requirements. No further investigation of larger values of $x$ is necessary.",
            "answer": "$$ \\boxed{0} $$"
        },
        {
            "introduction": "In realistic systems, average-case performance is not the only important metric; guaranteeing fairness and preventing starvation are equally critical. This final practice  explores the failure mode of indefinite blocking, where a request may be postponed forever. By analyzing a hypothetical scenario with a skewed, heavy-tailed workload, you will discover how a seemingly minor difference between the LOOK and SCAN policies can lead to profoundly different fairness guarantees, especially when the expected number of incoming requests diverges.",
            "id": "3649182",
            "problem": "Consider a single-platter mechanical disk with cylinders indexed by $0,1,2,\\dots,R$, a constant head velocity $v>0$, and a per-request service overhead $t_s>0$ that is independent of cylinder index. Two scheduling policies are used by the disk controller: the \"elevator\" sweep policy SCAN and the \"lazy-elevator\" policy LOOK. By definition, SCAN moves the head monotonically in one direction until it reaches the physical end ($0$ or $R$), then reverses and repeats; LOOK moves the head monotonically in one direction until there are no pending requests further in that direction (it reverses at the last outstanding request without visiting the physical end if no request lies beyond).\n\nA workload exhibits spatial skew and temporal burstiness as follows. Requests are partitioned into two spatial regions: an \"interior\" region $\\mathcal{I}=\\{0,1,\\dots,L\\}$ and an \"outer\" region $\\mathcal{O}=\\{L+1,\\dots,R\\}$, where $0<L<R$. Requests directed to $\\mathcal{I}$ arrive in bursts whose sizes $B$ (the number of consecutive interior requests that become pending before the next attempt to move the head outward past $L$) are independent and identically distributed according to a Pareto heavy-tailed distribution with shape parameter $\\alpha>0$ and scale $b_0\\ge 1$, i.e., for $b\\ge b_0$, $\\mathbb{P}(B\\ge b)=\\left(\\frac{b_0}{b}\\right)^{\\alpha}$; requests directed to $\\mathcal{O}$ are rare but do occur and, once present, remain pending until serviced. Assume that when the head is moving, newly arriving requests in the current direction are incorporated on the fly (i.e., the frontier of the current pass is dynamic), consistent with typical LOOK and SCAN implementations that opportunistically service arrivals ahead of the head.\n\nUsing the standard operating systems definition that \"starvation (indefinite blocking)\" occurs if a pending request can have an unbounded waiting time with non-zero probability under a scheduling policy, reason from the above definitions and the stated workload model to compare SCAN and LOOK. In particular, analyze whether the presence of heavy-tailed interior bursts (governed by $\\alpha$) can cause starvation of outer-region requests under LOOK, and whether SCAN mitigates or eliminates this risk. Your analysis should start from the formal properties of SCAN and LOOK, the geometry of head movement, and the basic facts about Pareto heavy tails (e.g., the finiteness of $\\mathbb{E}[B]$ as a function of $\\alpha$), and should derive bounds or divergence properties for waiting times without assuming any unstated shortcuts.\n\nWhich statement is most accurate?\n\nA. Under LOOK with interior burst sizes $B$ having a Pareto tail with shape parameter $\\alpha\\le 1$, an outer-region request can experience starvation in the sense of an unbounded expected waiting time, whereas SCAN’s commitment to reach the physical ends yields a deterministic bound on waiting time proportional to a sweep, independent of $\\alpha$.\n\nB. Under SCAN, outer-region requests are more prone to starvation than under LOOK when $\\alpha\\le 1$, because SCAN reverses at the last outstanding request and can oscillate within the interior hot spot without visiting the physical ends.\n\nC. For any $\\alpha>0$, both LOOK and SCAN guarantee bounded waiting time for every request, because the head is always moving and opportunistically incorporates new arrivals ahead.\n\nD. Increasing $\\alpha$ (making the tail lighter) monotonically increases the probability of starvation under LOOK, since fewer extreme bursts leave the head trapped near $L$ more frequently.",
            "solution": "The user wants me to analyze a disk scheduling problem, validate its premises, and then determine the most accurate statement among the given options.\n\n### Step 1: Extract Givens\n\n- **Disk Geometry and Mechanics:**\n    - A single-platter mechanical disk.\n    - Cylinders are indexed by $0, 1, 2, \\dots, R$.\n    - The head has a constant velocity $v > 0$.\n    - There is a per-request service overhead $t_s > 0$, independent of the cylinder index.\n\n- **Scheduling Policies:**\n    - **SCAN (\"elevator\"):** The head moves monotonically in one direction until it reaches a physical end (cylinder $0$ or $R$), then reverses direction and repeats.\n    - **LOOK (\"lazy-elevator\"):** The head moves monotonically in one direction until there are no more pending requests in that direction. It then reverses at the location of the last serviced request, without necessarily visiting the physical end.\n\n- **Workload Model:**\n    - **Spatial Skew:**\n        - Interior region: $\\mathcal{I} = \\{0, 1, \\dots, L\\}$, with $0 < L < R$.\n        - Outer region: $\\mathcal{O} = \\{L+1, \\dots, R\\}$.\n    - **Temporal Burstiness:**\n        - Requests for the interior region $\\mathcal{I}$ arrive in bursts.\n        - The size of a burst, $B$, is the number of consecutive interior requests that become pending.\n        - Burst sizes $B$ are independent and identically distributed (i.i.d.).\n        - The distribution of $B$ is a Pareto heavy-tailed distribution with shape parameter $\\alpha > 0$ and scale parameter $b_0 \\ge 1$.\n        - The tail probability is given by $\\mathbb{P}(B \\ge b) = \\left(\\frac{b_0}{b}\\right)^{\\alpha}$ for $b \\ge b_0$.\n    - **Outer Region Requests:** Requests for the outer region $\\mathcal{O}$ are rare but can occur and remain pending until serviced.\n    - **Dynamic Servicing:** Newly arriving requests that are in the head's current direction of travel are incorporated \"on the fly\".\n\n- **Core Question:**\n    - The problem asks to analyze and compare SCAN and LOOK in the context of starvation, defined as a pending request having an unbounded waiting time with non-zero probability.\n    - The analysis should focus on whether heavy-tailed interior bursts (governed by $\\alpha$) can cause starvation of outer-region requests under LOOK, and how SCAN affects this risk.\n\n### Step 2: Validate Using Extracted Givens\n\nThe problem statement describes a classic scenario in operating systems and queuing theory, used to analyze the performance of disk scheduling algorithms under non-uniform workloads.\n\n1.  **Scientifically Grounded:** The concepts of SCAN and LOOK policies, disk arm movement, and starvation are standard and well-defined in computer science and operating systems. The use of a Pareto distribution to model heavy-tailed bursty arrivals is a standard and realistic technique in performance modeling. The properties of the Pareto distribution, particularly the condition for the finiteness of its mean, are established mathematical facts. The setup is scientifically and mathematically sound.\n\n2.  **Well-Posed:** The problem provides clear definitions for both scheduling algorithms and the workload. The question is specific: compare the two policies with respect to starvation for a particular class of requests under a specified workload. The provided information is sufficient to perform a qualitative, rigorous analysis and reach a definite conclusion.\n\n3.  **Objective:** The problem is stated in precise, formal language. It defines its terms (SCAN, LOOK, starvation) and provides a mathematical model for the workload. There are no subjective or ambiguous statements.\n\nThe problem statement is valid. It presents a well-defined, scientifically grounded problem that can be analyzed from first principles.\n\n### Step 3: Proceed to Solution\n\n#### Analysis of the Workload\n\nThe workload's key feature is the burst size $B$ following a Pareto distribution. A critical property of the Pareto distribution is the condition for the finiteness of its moments. The expected value, $\\mathbb{E}[B]$, is given by the integral of its survival function:\n$$ \\mathbb{E}[B] = \\int_0^\\infty \\mathbb{P}(B \\ge b) db $$\nFor the given distribution, defined for $b \\ge b_0$:\n$$ \\mathbb{E}[B] = \\int_{b_0}^\\infty \\left(\\frac{b_0}{b}\\right)^{\\alpha} db = b_0^{\\alpha} \\int_{b_0}^\\infty b^{-\\alpha} db $$\nThis integral converges if and only if the exponent $-\\alpha < -1$, which requires $\\alpha > 1$. If $\\alpha > 1$, the expected value is finite: $\\mathbb{E}[B] = \\frac{\\alpha b_0}{\\alpha - 1}$. However, if $\\alpha \\le 1$, the integral diverges, and $\\mathbb{E}[B] = \\infty$.\n\nAn infinite expected burst size implies that the average number of requests arriving in the interior region per burst event is infinite. This will have profound consequences for any scheduling policy whose behavior depends on the queue state.\n\n#### Analysis of the SCAN Policy\n\nThe SCAN policy's movement is determined by the disk's physical geometry, not the distribution of requests. The head is mandated to sweep from one end to the other, e.g., from cylinder $0$ to $R$, and then back from $R$ to $0$.\n\nConsider a request for a cylinder $c_{out} \\in \\mathcal{O}$. Let this request arrive at time $t_0$. We want to find an upper bound on its waiting time. The worst-case scenario is that the request arrives just as the head passes cylinder $c_{out}$ moving away from it. For instance, the head is at $c_{out}$ moving towards $R$. The head will complete its sweep to $R$, reverse, sweep all the way to $0$, reverse again, and then finally travel towards $c_{out}$ to service the request.\n\nThe maximum distance the head must travel to guarantee service is less than two full traversals of the disk platter, i.e., a distance of $2R$. The time for this travel is $2R/v$. Along the way, the head services requests, adding an overhead of $t_s$ for each. The maximum number of distinct cylinders is $R+1$, so even if every cylinder had a pending request, the total service overhead during this period is bounded by $(R+1)t_s$.\n\nThe total maximum waiting time, $W_{SCAN}^{max}$, is therefore bounded:\n$$ W_{SCAN}^{max} \\le \\frac{2R}{v} + (\\text{requests serviced}) \\times t_s $$\nEven with a bursty arrival process, the number of requests that can be serviced in this bounded time interval is finite. The key is that the head's path is fixed. It is not delayed indefinitely by new arrivals because its travel endpoints ($0$ and $R$) are fixed. Consequently, any pending request is guaranteed to be serviced within a deterministically bounded time.\n\nConclusion for SCAN: Starvation is impossible under SCAN, regardless of the value of $\\alpha$.\n\n#### Analysis of the LOOK Policy\n\nThe LOOK policy's movement is adaptive; it depends on the locations of currently pending requests. The head reverses direction only when there are no more pending requests ahead of it in its current direction of motion.\n\nConsider a request pending at cylinder $c_{out} \\in \\mathcal{O}$. For this request to be serviced, the head must eventually move past cylinder $L$ towards $R$.\n\nNow, let's analyze the head's behavior when trapped by the interior workload. The problem states that requests arrive in bursts of size $B$ in the region $\\mathcal{I}=\\{0,1,\\dots,L\\}$. The head sweeps back and forth within $\\mathcal{I}$, servicing these requests. The \"opportunistic\" servicing of new arrivals means that if the head is sweeping outward (towards $L$) and a new burst of requests arrives in $\\mathcal{I}$, the frontier of its sweep may be extended, but it remains within $\\mathcal{I}$.\n\nThe crucial scenario is when $\\alpha \\le 1$. In this case, $\\mathbb{E}[B] = \\infty$. This means the average number of requests that need to be serviced in the interior region is infinite. The head is servicing a queue of requests in $\\mathcal{I}$. If the arrival rate of work (proportional to $\\mathbb{E}[B]$) is infinite, the queue of work for the interior region will grow without bound.\n\nThe LOOK algorithm confines the head's movement to the region where there are pending requests. If there is a perpetually growing queue of requests within $\\mathcal{I}$, the head will be constantly busy sweeping back and forth between the innermost and outermost pending requests, both of which are within $\\mathcal{I}$. It will never find a moment where the set of pending requests in $\\mathcal{I}$ is empty, or even just clear in the outward direction, to allow it to \"look\" further out and see the request at $c_{out}$. The time required to clear the (infinitely growing) backlog in $\\mathcal{I}$ is infinite.\n\nTherefore, the waiting time for the request at $c_{out}$ can be unbounded. More formally, the expected waiting time for the request at $c_{out}$ is infinite because the expected time to clear the queue ahead of it (the entire workload in $\\mathcal{I}$) is infinite. This meets the definition of starvation.\n\nConclusion for LOOK: If $\\alpha \\le 1$, a request in the outer region $\\mathcal{O}$ can be starved. If $\\alpha > 1$, $\\mathbb{E}[B]$ is finite, the interior workload is manageable in expectation, and the head will eventually be able to service the outer region, preventing starvation.\n\n### Option-by-Option Analysis\n\n**A. Under LOOK with interior burst sizes B having a Pareto tail with shape parameter α ≤ 1, an outer-region request can experience starvation in the sense of an unbounded expected waiting time, whereas SCAN’s commitment to reach the physical ends yields a deterministic bound on waiting time proportional to a sweep, independent of α.**\n\nThis statement accurately summarizes the derived conclusions.\n- It correctly identifies the condition $\\alpha \\le 1$ as the regime where LOOK fails, leading to starvation (unbounded expected waiting time) due to the infinite mean burst size.\n- It correctly identifies that SCAN's geometric sweep pattern provides a deterministic bound on waiting time, making it immune to this form of workload-induced starvation, regardless of $\\alpha$.\n\n**Verdict: Correct.**\n\n**B. Under SCAN, outer-region requests are more prone to starvation than under LOOK when α ≤ 1, because SCAN reverses at the last outstanding request and can oscillate within the interior hot spot without visiting the physical ends.**\n\nThis statement is fundamentally flawed. It incorrectly describes the SCAN algorithm. The behavior described—reversing at the last outstanding request and oscillating within a hot spot—is the characteristic behavior of LOOK, not SCAN. SCAN, by definition, always travels to the physical ends ($0$ and $R$). Therefore, the premise of the statement is false.\n\n**Verdict: Incorrect.**\n\n**C. For any α > 0, both LOOK and SCAN guarantee bounded waiting time for every request, because the head is always moving and opportunistically incorporates new arrivals ahead.**\n\nThis statement is incorrect because it fails to account for the behavior of LOOK under a heavy-tailed workload. As shown in the analysis, for $\\alpha \\le 1$, LOOK does *not* guarantee a bounded waiting time. The fact that the head is \"always moving\" is not sufficient to prevent starvation if its movements are confined to a region with an infinite workload. The statement is true for SCAN but false for LOOK, making the overall statement false.\n\n**Verdict: Incorrect.**\n\n**D. Increasing α (making the tail lighter) monotonically increases the probability of starvation under LOOK, since fewer extreme bursts leave the head trapped near L more frequently.**\n\nThis statement misrepresents the effect of the parameter $\\alpha$. Increasing $\\alpha$ makes the tail of the Pareto distribution *lighter*, meaning that extremely large bursts become less probable. This *reduces* the expected burst size (making it finite for $\\alpha > 1$). A smaller workload in the interior region *decreases* the time the head is trapped, thereby *decreasing* the risk of starvation. The statement claims the opposite, that increasing $\\alpha$ *increases* the starvation risk. This is incorrect.\n\n**Verdict: Incorrect.**",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}