{
    "hands_on_practices": [
        {
            "introduction": "现代DRAM（如DDR4）为了提升并行度，将存储体（bank）分组成多个bank group。访问不同bank group中的bank通常比连续访问同一bank group中的bank要快，这体现在列地址选通延迟（$t_{\\text{CCD}}$）的两种不同取值上：$t_{\\text{CCD\\_S}}$（短延迟）和 $t_{\\text{CCD\\_L}}$（长延迟）。这个练习将通过一个具体的地址映射方案，让你亲手计算不同访存模式下的吞吐量差异，从而深刻理解数据布局对内存性能的直接影响。",
            "id": "3637036",
            "problem": "一个处理器向一个第四代双倍数据速率同步动态随机存取存储器 (DDR4 SDRAM) 的单通道发出一串持续的读列命令。该通道宽度为 $64$ 位，数据速率为 DDR4-$2400$，这意味着命令时钟频率为 $f_{\\text{CK}} = 1200 \\times 10^{6}\\ \\text{s}^{-1}$。该设备使用突发长度 (BL) $8$，所有请求都是行命中，无需行激活或预充电；忽略总线转向以及除了列到列延迟 (CCD) 之外的任何时序。\n\n该 DDR4 设备有 $4$ 个存储体组。内存控制器通过在缓存行粒度上进行低位交错，将物理地址 $A$ 映射到存储体组索引 $g(A)$，使得\n$$\ng(A) = \\left(\\left\\lfloor \\frac{A}{64}\\right\\rfloor \\bmod 4\\right),\n$$\n其中 $64$ 表示以字节为单位的缓存行大小。考虑两种针对地址 $A_{0}, A_{1}, A_{2}, \\dots$ 的顺序访问模式：\n- 模式 $\\mathcal{S}$，步长为 $S = 256\\ \\text{B}$，即 $A_{k+1} = A_{k} + S$，这使得 $g(A_{k})$ 在连续命令之间保持不变。\n- 模式 $\\mathcal{S}^{\\star}$，步长为 $S^{\\star} = 64\\ \\text{B}$，即 $A_{k+1} = A_{k} + S^{\\star}$，这导致在 $4$ 个存储体组之间进行轮询交替。\n\n在 DDR4 中，连续列命令之间的最小间隔取决于这些命令是针对同一个存储体组还是不同的存储体组。令 $t_{\\text{CCD\\_L}}$ 表示较长的 CCD (相同存储体组)，$t_{\\text{CCD\\_S}}$ 表示较短的 CCD (不同存储体组)。假设 $t_{\\text{CCD\\_L}} = 5$ 个时钟周期，$t_{\\text{CCD\\_S}} = 4$ 个时钟周期。\n\n从第一性原理出发，将持续吞吐量与每条命令传输的数据量以及由 $t_{\\text{CCD}}$ 决定的最小命令间隔联系起来，确定模式 $\\mathcal{S}$ 相对于模式 $\\mathcal{S}^{\\star}$ 的分数吞吐量下降。将下降定义为\n$$\n\\Delta = \\frac{T_{\\mathcal{S}^{\\star}} - T_{\\mathcal{S}}}{T_{\\mathcal{S}^{\\star}}},\n$$\n其中 $T_{\\mathcal{S}}$ 和 $T_{\\mathcal{S}^{\\star}}$ 分别是在模式 $\\mathcal{S}$ 和 $\\mathcal{S}^{\\star}$ 下的持续吞吐量。将最终答案表示为一个无单位的小数，并四舍五入到四位有效数字。",
            "solution": "用户要求我解决一个关于 DDR4 内存吞吐量的问题。\n\n### 第一步：提取已知条件\n- **DRAM 类型**：第四代双倍数据速率同步动态随机存取存储器 (DDR4 SDRAM)。\n- **通道宽度**：$64$ 位（$8$ 字节）。\n- **数据速率**：DDR4-$2400$。\n- **命令时钟频率**：$f_{\\text{CK}} = 1200 \\times 10^{6}\\ \\text{s}^{-1}$（$1200\\ \\text{MHz}$）。\n- **突发长度**：$BL = 8$。\n- **访问条件**：持续的读列命令流，所有请求都是行命中。行激活、预充电、总线转向和其他时序均忽略不计。\n- **存储体组织**：$4$ 个存储体组。\n- **存储体组映射**：$g(A) = \\left(\\left\\lfloor \\frac{A}{64}\\right\\rfloor \\bmod 4\\right)$，对于物理地址 $A$。缓存行大小为 $64\\ \\text{B}$。\n- **访问模式 $\\mathcal{S}$**：顺序访问，步长 $S = 256\\ \\text{B}$。此模式使连续命令的存储体组索引 $g(A_k)$ 保持不变。\n- **访问模式 $\\mathcal{S}^{\\star}$**：顺序访问，步长 $S^{\\star} = 64\\ \\text{B}$。此模式导致在 $4$ 个存储体组之间进行轮询访问。\n- **时序参数**：\n  - 列到列延迟（相同存储体组）：$t_{\\text{CCD\\_L}} = 5$ 个时钟周期。\n  - 列到列延迟（不同存储体组）：$t_{\\text{CCD\\_S}} = 4$ 个时钟周期。\n- **目标**：计算分数吞吐量下降 $\\Delta = \\frac{T_{\\mathcal{S}^{\\star}} - T_{\\mathcal{S}}}{T_{\\mathcal{S}^{\\star}}}$，其中 $T_{\\mathcal{S}}$ 和 $T_{\\mathcal{S}^{\\star}}$ 分别是模式 $\\mathcal{S}$ 和 $\\mathcal{S}^{\\star}$ 下的持续吞吐量。结果应为一个无单位的小数，并四舍五入到四位有效数字。\n\n### 第二步：使用提取的已知条件进行验证\n该问题在科学上基于计算机内存系统的原理，特别是 DDR4 的架构和时序。所提供的参数，如数据速率、时钟频率、存储体组结构和时序值（$t_{\\text{CCD\\_L}}$, $t_{\\text{CCD\\_S}}$），是符合实际且与行业标准一致的。存储体组映射函数定义明确。我们来验证一下访问模式的行为。\n对于模式 $\\mathcal{S}$，步长 $S=256\\ \\text{B}$：\n第 $k$ 次访问的地址是 $A_k$。下一次访问的地址是 $A_{k+1} = A_k + 256$。\n存储体组索引是 $g(A_{k+1}) = \\left(\\left\\lfloor \\frac{A_k + 256}{64}\\right\\rfloor \\bmod 4\\right) = \\left(\\left\\lfloor \\frac{A_k}{64} + 4\\right\\rfloor \\bmod 4\\right) = \\left(\\left(\\left\\lfloor \\frac{A_k}{64}\\right\\rfloor + 4\\right) \\bmod 4\\right) = \\left(\\left\\lfloor \\frac{A_k}{64}\\right\\rfloor \\bmod 4\\right) = g(A_k)$。\n这证实了连续访问确实针对同一个存储体组。\n\n对于模式 $\\mathcal{S}^{\\star}$，步长 $S^{\\star}=64\\ \\text{B}$：\n下一次访问的地址是 $A_{k+1} = A_k + 64$。\n存储体组索引是 $g(A_{k+1}) = \\left(\\left\\lfloor \\frac{A_k + 64}{64}\\right\\rfloor \\bmod 4\\right) = \\left(\\left\\lfloor \\frac{A_k}{64} + 1\\right\\rfloor \\bmod 4\\right) = \\left(\\left(\\left\\lfloor \\frac{A_k}{64}\\right\\rfloor + 1\\right) \\bmod 4\\right)$。\n这证实了连续访问确实以轮询方式交替访问下一个存储体组。\n\n该问题陈述清晰、目标明确，并包含了基于所提供模型推导出唯一解所需的所有信息。没有矛盾、歧义或事实错误。\n\n### 第三步：结论与行动\n问题有效。我将继续进行解答。\n\n### 解题过程\n持续吞吐量 $T$ 定义为单位时间内传输的数据量。对于连续的命令流，这可以表示为每条命令传输的数据量与每条命令所用时间的比值。\n$$\nT = \\frac{\\text{每命令数据量}}{\\text{每命令时间}}\n$$\n\n首先，我们确定单条读列命令传输的数据量。通道宽度为 $64$ 位，等于 $8$ 字节。单条命令会启动一次突发长度为 $BL=8$ 的传输。这意味着将执行 $8$ 次传输，每次传输的数据量等于通道宽度。\n$$\nD_{\\text{cmd}} = (\\text{通道宽度}) \\times (\\text{突发长度}) = (8\\ \\text{字节}) \\times 8 = 64\\ \\text{字节}\n$$\n这个数据量对应于典型的缓存行大小，与问题的地址映射函数一致。\n\n接下来，我们确定每种访问模式下每条命令所需的时间。问题指明，两条连续列命令之间的最小时间由列到列延迟 $t_{\\text{CCD}}$ 决定。该时间以时钟周期为单位。一个时钟周期的持续时间是 $T_{\\text{CK}} = 1/f_{\\text{CK}}$。因此，连续命令之间的时间间隔是 $\\tau = t_{\\text{CCD}} \\times T_{\\text{CK}}$。\n\n现在吞吐量可以写成：\n$$\nT = \\frac{D_{\\text{cmd}}}{\\tau} = \\frac{D_{\\text{cmd}}}{t_{\\text{CCD}} \\cdot T_{\\text{CK}}} = \\frac{D_{\\text{cmd}} \\cdot f_{\\text{CK}}}{t_{\\text{CCD}}}\n$$\n此方程表明，对于给定的内存系统，持续吞吐量与适用的列到列延迟 $t_{\\text{CCD}}$ 成反比。\n\n对于访问模式 $\\mathcal{S}$，连续的命令被发送到同一个存储体组。因此，起决定作用的时序参数是较长的列到列延迟 $t_{\\text{CCD\\_L}}$。\n$$\nt_{\\text{CCD}}(\\mathcal{S}) = t_{\\text{CCD\\_L}} = 5\\ \\text{个时钟周期}\n$$\n模式 $\\mathcal{S}$ 的吞吐量为：\n$$\nT_{\\mathcal{S}} = \\frac{D_{\\text{cmd}} \\cdot f_{\\text{CK}}}{t_{\\text{CCD\\_L}}}\n$$\n\n对于访问模式 $\\mathcal{S}^{\\star}$，由于存储体组交错，连续的命令被发送到不同的存储体组。起决定作用的时序参数是较短的列到列延迟 $t_{\\text{CCD\\_S}}$。\n$$\nt_{\\text{CCD}}(\\mathcal{S}^{\\star}) = t_{\\text{CCD\\_S}} = 4\\ \\text{个时钟周期}\n$$\n模式 $\\mathcal{S}^{\\star}$ 的吞吐量为：\n$$\nT_{\\mathcal{S}^{\\star}} = \\frac{D_{\\text{cmd}} \\cdot f_{\\text{CK}}}{t_{\\text{CCD\\_S}}}\n$$\n\n题目要求我们计算模式 $\\mathcal{S}$ 相对于模式 $\\mathcal{S}^{\\star}$ 的分数吞吐量下降，定义为：\n$$\n\\Delta = \\frac{T_{\\mathcal{S}^{\\star}} - T_{\\mathcal{S}}}{T_{\\mathcal{S}^{\\star}}} = 1 - \\frac{T_{\\mathcal{S}}}{T_{\\mathcal{S}^{\\star}}}\n$$\n代入 $T_{\\mathcal{S}}$ 和 $T_{\\mathcal{S}^{\\star}}$ 的表达式：\n$$\n\\frac{T_{\\mathcal{S}}}{T_{\\mathcal{S}^{\\star}}} = \\frac{\\frac{D_{\\text{cmd}} \\cdot f_{\\text{CK}}}{t_{\\text{CCD\\_L}}}}{\\frac{D_{\\text{cmd}} \\cdot f_{\\text{CK}}}{t_{\\text{CCD\\_S}}}} = \\frac{t_{\\text{CCD\\_S}}}{t_{\\text{CCD\\_L}}}\n$$\n$D_{\\text{cmd}}$ 和 $f_{\\text{CK}}$ 项相互抵消，简化了 $\\Delta$ 的表达式：\n$$\n\\Delta = 1 - \\frac{t_{\\text{CCD\\_S}}}{t_{\\text{CCD\\_L}}}\n$$\n现在，我们代入时序参数的具体数值：$t_{\\text{CCD\\_L}} = 5$ 个时钟周期，$t_{\\text{CCD\\_S}} = 4$ 个时钟周期。\n$$\n\\Delta = 1 - \\frac{4}{5} = 1 - 0.8 = 0.2\n$$\n题目要求答案是一个无单位的小数，并四舍五入到四位有效数字。\n$$\n\\Delta = 0.2000\n$$\n这个结果表明，当访问模式未能利用存储体组交错，导致所有访问都强制发送到同一个存储体组，从而在命令之间产生更长的 $t_{\\text{CCD\\_L}}$ 延迟时，吞吐量会下降 $20\\%$。",
            "answer": "$$\n\\boxed{0.2000}\n$$"
        },
        {
            "introduction": "内存控制器在处理读写请求流时，面临着一个经典的性能权衡问题。为了摊销读写切换带来的总线空闲开销（$t_{\\text{RTW}}$ 和 $t_{\\text{WTR}}$），控制器通常会批量处理写请求，但这又可能导致读请求的等待时间变长。本练习要求你在保证最坏情况下读请求延迟不超过一个给定阈值的前提下，找到最优的写操作批处理大小，让你体验在相互制约的性能指标（吞吐量与延迟）之间进行优化的过程。",
            "id": "3637027",
            "problem": "一个用于动态随机存取存储器（DRAM）并采用双倍数据速率（DDR）信号传输的内存控制器使用一个简单的策略：只要有任何挂起的读取请求，它就服务于读取；当它切换到写入时，它会执行一个固定大小的写入批次，该批次包含恰好 $B_{w}$ 个连续的写入操作，然后才切换回读取。将总线方向从读取切换到写入会产生 $t_{\\text{RTW}}$ 个空闲总线周期的读到写转换时间，而从写入切换到读取会产生 $t_{\\text{WTR}}$ 个空闲总线周期的写到读转换时间。每次写入占用数据总线恰好 $t_{\\text{BURST}}$ 个周期。一个读取请求一旦开始被服务，从发出命令到返回第一个数据需要 $t_{R}$ 个周期。将总线视为瓶颈资源，并假设控制器一旦开始一个写入批次就不会抢占它。\n\n定义“损失周期”为仅因方向转换而导致没有传输任何有用的写入或读取数据的总线周期总数。对于包含大量写入的长数据流，批处理写入可以将这些损失周期摊销到整个批次中。\n\n给定：\n- $t_{\\text{RTW}} = 6$ 个周期，\n- $t_{\\text{WTR}} = 4$ 个周期，\n- $t_{\\text{BURST}} = 4$ 个周期，\n- $t_{R} = 14$ 个周期，\n- 最大允许读取尾延迟 $L_{\\max} = 100$ 个周期，定义为从读取请求到达至返回第一个数据的最大时间，以总线周期为单位测量。\n\n假设最坏情况的读取尾延迟发生在读取请求相对于写入批次在一个最不利的时刻到达。选择一个整数写入批次大小 $B_{w}$，使其在最小化因方向转换造成的总损失周期的同时，保证最坏情况的读取尾延迟不超过 $L_{\\max}$。将最优的 $B_{w}$ 报告为单个整数。无需四舍五入，因为 $B_{w}$ 是一个计数。",
            "solution": "用户希望我解决以下问题。\n一个用于动态随机存取存储器（DRAM）并采用双倍数据速率（DDR）信号传输的内存控制器使用一个简单的策略：只要有任何挂起的读取请求，它就服务于读取；当它切换到写入时，它会执行一个固定大小的写入批次，该批次包含恰好 $B_{w}$ 个连续的写入操作，然后才切换回读取。将总线方向从读取切换到写入会产生 $t_{\\text{RTW}}$ 个空闲总线周期的读到写转换时间，而从写入切换到读取会产生 $t_{\\text{WTR}}$ 个空闲总线周期的写到读转换时间。每次写入占用数据总线恰好 $t_{\\text{BURST}}$ 个周期。一个读取请求一旦开始被服务，从发出命令到返回第一个数据需要 $t_{R}$ 个周期。将总线视为瓶颈资源，并假设控制器一旦开始一个写入批次就不会抢占它。\n\n定义“损失周期”为仅因方向转换而导致没有传输任何有用的写入或读取数据的总线周期总数。对于包含大量写入的长数据流，批处理写入可以将这些损失周期摊销到整个批次中。\n\n给定：\n- $t_{\\text{RTW}} = 6$ 个周期，\n- $t_{\\text{WTR}} = 4$ 个周期，\n- $t_{\\text{BURST}} = 4$ 个周期，\n- $t_{R} = 14$ 个周期，\n- 最大允许读取尾延迟 $L_{\\max} = 100$ 个周期，定义为从读取请求到达至返回第一个数据的最大时间，以总线周期为单位测量。\n\n假设最坏情况的读取尾延迟发生在读取请求相对于写入批次在一个最不利的时刻到达。选择一个整数写入批次大小 $B_{w}$，使其在最小化因方向转换造成的总损失周期的同时，保证最坏情况的读取尾延迟不超过 $L_{\\max}$。将最优的 $B_{w}$ 报告为单个整数。无需四舍五入，因为 $B_{w}$ 是一个计数。\n首先验证问题的正确性和可解性。\n\n**步骤1：提取给定信息**\n- 写入批次大小：$B_{w}$ (整数，待确定)。\n- 读到写转换时间：$t_{\\text{RTW}} = 6$ 个周期。\n- 写到读转换时间：$t_{\\text{WTR}} = 4$ 个周期。\n- 写入突发持续时间：$t_{\\text{BURST}} = 4$ 个周期。\n- 读取服务时间（从发出到第一个数据）：$t_{R} = 14$ 个周期。\n- 最大允许读取尾延迟：$L_{\\max} = 100$ 个周期。\n- 策略：读取优先，但写入批次不可抢占。\n\n**步骤2：使用提取的给定信息进行验证**\n这个问题在科学上是合理的，模拟了DRAM内存控制器中一个标准的性能权衡。参数是现实的，术语是计算机体系结构中的标准术语。目标是在另一个指标（性能，通过读取延迟）的约束下，优化一个指标（效率，通过最小化损失周期）。\n\n目标是最小化“损失周期”，即转换开销 $t_{\\text{RTW}}$ 和 $t_{\\text{WTR}}$。对于一个完整的写入批处理事务（从读取切换、执行写入、再切换回读取），总耗时为 $t_{\\text{RTW}} + (B_w \\cdot t_{\\text{BURST}}) + t_{\\text{WTR}}$。因转换而损失的时间比例为 $\\frac{t_{\\text{RTW}} + t_{\\text{WTR}}}{t_{\\text{RTW}} + (B_w \\cdot t_{\\text{BURST}}) + t_{\\text{WTR}}}$。最小化这个比例等同于最大化分母，即最大化写入批次大小 $B_w$。因此，该问题是一个优化问题：在延迟约束下，最大化整数 $B_w$。\n\n约束条件是最坏情况读取尾延迟不得超过 $L_{\\max}$。该问题有清晰的结构来确定最坏情况延迟，并且是良构的。不存在矛盾或信息缺失。\n\n**步骤3：结论与行动**\n问题是有效的。将提供详细的解决方案。\n\n该问题要求找到最优的整数写入批次大小 $B_{w}$，在满足最大读取延迟约束的同时，最小化损失周期。由总线转换引起的损失周期 $t_{\\text{RTW}}$ 和 $t_{\\text{WTR}}$ 对于每个写入批次都是固定的。为了最小化其影响，这些固定成本必须摊销到尽可能多的写入操作上。因此，最小化损失周期的比例等同于最大化写入批次大小 $B_w$。所以，问题就变成了找到遵守读取延迟约束的 $B_w$ 的最大整数值。\n\n约束由最大允许读取尾延迟 $L_{\\max} = 100$ 个周期给出。我们必须首先构建一个关于 $B_w$ 的最坏情况读取尾延迟 $L_{\\text{worst}}$ 的表达式。读取请求的最坏情况发生在它于最不合时宜的时刻到达。鉴于控制器的策略（读取优先，但写入批次不可抢占），读取请求到达的最坏时机是控制器刚完成一系列读取服务并决定开始一个写入批次之后。\n\n让我们追踪这个在时间 $t_{arrival}$ 到达的不幸的读取请求的时间线：\n1. 内存控制器决定从服务读取切换到写入。此时，我们的读取请求到达。由于控制器已经决定进行切换，该读取请求必须等待。产生的第一个延迟是读到写转换时间 $t_{\\text{RTW}}$。\n2. 转换之后，控制器执行整个包含 $B_w$ 次写入的批次。由于每次写入需要 $t_{\\text{BURST}}$ 个周期，此阶段总共持续 $B_w \\cdot t_{\\text{BURST}}$ 个周期。\n3. 批次中的最后一次写入完成后，控制器必须将总线方向切换回读取，以服务挂起的读取请求。这会产生写到读转换时间 $t_{\\text{WTR}}$。\n4. 此时，总线已准备好接受读取命令。一直在等待的读取请求现在被发送到DRAM。从命令发出的那一刻起，需要 $t_{R}$ 个周期才能返回第一份数据。\n\n这个最坏情况读取的总延迟是所有这些时间分量的总和。我们可以将最坏情况延迟 $L_{\\text{worst}}$ 表示为：\n$$L_{\\text{worst}} = t_{\\text{RTW}} + (B_w \\cdot t_{\\text{BURST}}) + t_{\\text{WTR}} + t_{R}$$\n\n问题规定此延迟不得超过最大允许延迟 $L_{\\max}$。这给了我们主要的控制不等式：\n$$L_{\\text{worst}} \\le L_{\\max}$$\n$$t_{\\text{RTW}} + (B_w \\cdot t_{\\text{BURST}}) + t_{\\text{WTR}} + t_{R} \\le L_{\\max}$$\n\n为了找到 $B_w$ 的最大可能值，我们对这个不等式求解 $B_w$：\n$$(B_w \\cdot t_{\\text{BURST}}) \\le L_{\\max} - t_{\\text{RTW}} - t_{\\text{WTR}} - t_{R}$$\n$$B_w \\le \\frac{L_{\\max} - t_{\\text{RTW}} - t_{\\text{WTR}} - t_{R}}{t_{\\text{BURST}}}$$\n\n现在，我们将给定的数值代入不等式：\n- $L_{\\max} = 100$\n- $t_{\\text{RTW}} = 6$\n- $t_{\\text{WTR}} = 4$\n- $t_{\\text{BURST}} = 4$\n- $t_{R} = 14$\n\n$$B_w \\le \\frac{100 - 6 - 4 - 14}{4}$$\n$$B_w \\le \\frac{100 - (6 + 4 + 14)}{4}$$\n$$B_w \\le \\frac{100 - 24}{4}$$\n$$B_w \\le \\frac{76}{4}$$\n$$B_w \\le 19$$\n\n由于 $B_w$ 必须是整数，且我们的目标是最大化 $B_w$ 以实现转换成本的最佳摊销，我们选择满足此条件的最大整数值。$B_w$ 的最大整数值为 $19$。\n这意味着写入批次大小最大可为 $19$。为了最小化转换的相对成本，最优选择是 $B_w = 19$。任何更大的值都会违反延迟约束。例如，如果 $B_w=20$，延迟将是 $6 + (20 \\cdot 4) + 4 + 14 = 6+80+4+14 = 104$ 个周期，这超过了 $L_{\\max} = 100$。\n\n因此，最优的写入批次大小为 $19$。",
            "answer": "$$\n\\boxed{19}\n$$"
        },
        {
            "introduction": "DRAM需要周期性地进行刷新（refresh）操作以维持数据不丢失，但刷新会暂时占用存储体，使其无法响应读写请求，从而影响性能。这个练习模拟了一个高带宽数据流与DRAM刷新操作发生冲突的场景。通过对比将数据流集中在单个bank和将其分散到多个bank两种策略的性能，你将定量分析利用bank级并行来隐藏刷新延迟、提升有效带宽的有效性。",
            "id": "3637083",
            "problem": "一个单列 (single rank) 的第四代双倍数据速率同步动态随机存取存储器 (DDR4 SDRAM) 被一个流式直接内存访问 (DMA) 引擎使用，该引擎连续发出长时间、背靠背的读取传输。请考虑以下事实和约束：\n\n- 内存总线宽度为 $64$ 位，数据传输速率为每秒 $2.4 \\times 10^{9}$ 次，因此每次传输携带 $8$ 字节的数据。\n- 该设备使用Per-Bank刷新（一次刷新一个bank）。每个bank必须在每个 $t_{\\text{REFI}} = 7.8 \\times 10^{-6}\\,\\text{s}$ 的时间间隔内刷新一次，而Per-Bank刷新命令会占用该bank $t_{\\text{RFCpb}} = 260 \\times 10^{-9}\\,\\text{s}$ 的时间。\n- DMA引擎的应用层传输粒度是每次突发 $64\\,\\text{KiB}$。默认情况下，所有 $64\\,\\text{KiB}$ 都放在单个bank中，并作为单个连续突发进行读取。\n- 一种提议的缓解措施是将每个 $64\\,\\text{KiB}$ 的突发分成两个相等的 $32\\,\\text{KiB}$ 子突发，将一个 $32\\,\\text{KiB}$ 的子突发放在bank 0中，另一个 $32\\,\\text{KiB}$ 的子突发放在bank 1中。内存控制器总是调度子突发，以使任何子突发都不会与其目标bank的Per-Bank刷新窗口重叠。对于连续的读取子突发，在bank之间切换需要一个读-读 bank间距，等于在 $1.2 \\times 10^{9}\\,\\text{Hz}$ 命令时钟下 $t_{\\text{CCD(L)}} = 5$ 个命令周期，在此期间数据总线处于空闲状态。假设没有其他时间开销限制稳态流。\n- 假设只要有bank可用，控制器就能保持数据总线持续繁忙（也就是说，流在其他方面是受带宽限制的）。同时，假设Per-Bank刷新是串行化的，因此在任何时候最多只有一个bank处于刷新状态。\n\n仅使用以下定义：(i) 动态随机存取存储器 (DRAM) 刷新使目标bank在每个 $t_{\\text{REFI}}$ 周期内有 $t_{\\text{RFC}}$ 的时间无法为命令提供服务，(ii) 持续带宽等于每单位时间移动的数据量，以及 (iii) 任何总线无法传输数据的时间间隔都会使持续带宽降低，降低的幅度与总线空闲时间的比例成正比。请计算该缓解措施相对于基线所实现的持续带宽的乘性改进。具体来说，设 $R_{\\text{base}}$ 表示整个 $64\\,\\text{KiB}$ 突发位于单个bank时的持续带宽，设 $R_{\\text{mit}}$ 表示按所述方式将突发拆分到两个bank时的持续带宽。计算比率 $R_{\\text{mit}} / R_{\\text{base}}$。\n\n请将您的最终答案表示为一个无单位的小数，并四舍五入到四位有效数字。",
            "solution": "本题要求计算持续带宽的乘性改进，定义为比率 $R_{\\text{mit}} / R_{\\text{base}}$，其中 $R_{\\text{base}}$ 是基线内存访问模式的持续带宽，而 $R_{\\text{mit}}$ 是缓解后模式的持续带宽。\n\n问题提供了一个关键定义：“任何总线无法传输数据的时间间隔都会使持续带宽降低，降低的幅度与总线空闲时间的比例成正比。”设 $B_{\\text{peak}}$ 表示内存总线的理论峰值带宽。设 $f_{\\text{idle}}$ 为总线空闲时间的比例。持续带宽 $R$ 可以表示为：\n$$R = B_{\\text{peak}} (1 - f_{\\text{idle}})$$\n因此，我们需要计算的比率是：\n$$\\frac{R_{\\text{mit}}}{R_{\\text{base}}} = \\frac{B_{\\text{peak}} (1 - f_{\\text{idle, mit}})}{B_{\\text{peak}} (1 - f_{\\text{idle, base}})} = \\frac{1 - f_{\\text{idle, mit}}}{1 - f_{\\text{idle, base}}}$$\n我们的任务简化为计算基线 ($f_{\\text{idle, base}}$) 和缓解 ($f_{\\text{idle, mit}}$) 两种场景下的总线空闲时间比例。\n\n首先，我们分析基线场景。在这种情况下，一个由 $64\\,\\text{KiB}$ 突发组成的连续数据流指向单个内存bank。总线空闲的唯一来源是周期性的Per-Bank刷新命令，这会使目标bank不可用。问题指出，每个bank必须在每个 $t_{\\text{REFI}} = 7.8 \\times 10^{-6}\\,\\text{s}$ 的时间间隔内刷新一次，刷新持续时间为 $t_{\\text{RFCpb}} = 260 \\times 10^{-9}\\,\\text{s}$。由于整个数据流依赖于这一个bank，因此每当该bank刷新时，总线将被迫空闲。总线空闲时间的比例是刷新时间与刷新间隔的比值。\n$$f_{\\text{idle, base}} = \\frac{t_{\\text{RFCpb}}}{t_{\\text{REFI}}}$$\n代入给定值：\n$$f_{\\text{idle, base}} = \\frac{260 \\times 10^{-9}\\,\\text{s}}{7.8 \\times 10^{-6}\\,\\text{s}} = \\frac{260}{7800} = \\frac{26}{780} = \\frac{1}{30}$$\n\n接下来，我们分析缓解场景。每个 $64\\,\\text{KiB}$ 的突发被分成两个 $32\\,\\text{KiB}$ 的子突发，分别放置在bank 0和bank 1中。控制器交错访问这些bank。问题指出，控制器会调度子突发以避免刷新窗口。由于Per-Bank刷新是串行化的（一次最多只有一个bank刷新），当bank 0在刷新时，控制器可以访问bank 1，反之亦然。因此，Per-Bank刷新不再导致数据总线空闲。\n然而，引入了一个新的空闲来源：在bank之间切换时所需的读-读 bank间距 $t_{\\text{CCD(L)}}$。在此期间，总线是空闲的。每次传输 $32\\,\\text{KiB}$ 子突发后都会发生这种切换。\n空闲时间的比例是空闲切换时间与一个周期的总时间（传输 + 切换）的比值。\n$$f_{\\text{idle, mit}} = \\frac{T_{\\text{idle, switch}}}{T_{\\text{transfer, sub}} + T_{\\text{idle, switch}}}$$\n我们必须计算这两个时间分量，$T_{\\text{idle, switch}}$ 和 $T_{\\text{transfer, sub}}$。\n\n切换的空闲时间给定为 $t_{\\text{CCD(L)}} = 5$ 个命令周期。命令时钟频率为 $f_{\\text{CMD}} = 1.2 \\times 10^9\\,\\text{Hz}$。\n$$T_{\\text{idle, switch}} = \\frac{t_{\\text{CCD(L)}}}{f_{\\text{CMD}}} = \\frac{5}{1.2 \\times 10^9\\,\\text{s}^{-1}} = \\frac{5}{1.2} \\times 10^{-9}\\,\\text{s} = \\frac{25}{6} \\times 10^{-9}\\,\\text{s}$$\n\n传输一个子突发所需的时间取决于子突发的大小和峰值总线带宽。\n子突发大小为 $32\\,\\text{KiB} = 32 \\times 2^{10}\\,\\text{bytes} = 32768\\,\\text{bytes}$。\n峰值带宽 $B_{\\text{peak}}$ 是数据速率和总线宽度的乘积。总线宽度为 $64\\,\\text{bits}$（$8\\,\\text{bytes}$），运行速率为每秒 $2.4 \\times 10^9$ 次传输。\n$$B_{\\text{peak}} = (2.4 \\times 10^9\\,\\text{s}^{-1}) \\times (8\\,\\text{bytes}) = 19.2 \\times 10^9\\,\\text{bytes/s}$$\n传输一个子突发的时间是：\n$$T_{\\text{transfer, sub}} = \\frac{32768\\,\\text{bytes}}{19.2 \\times 10^9\\,\\text{bytes/s}} = \\frac{32768}{19.2} \\times 10^{-9}\\,\\text{s} = \\frac{5120}{3} \\times 10^{-9}\\,\\text{s}$$\n\n现在我们可以计算 $f_{\\text{idle, mit}}$：\n$$f_{\\text{idle, mit}} = \\frac{\\frac{25}{6} \\times 10^{-9}\\,\\text{s}}{\\frac{5120}{3} \\times 10^{-9}\\,\\text{s} + \\frac{25}{6} \\times 10^{-9}\\,\\text{s}} = \\frac{\\frac{25}{6}}{\\frac{10240}{6} + \\frac{25}{6}} = \\frac{25}{10240 + 25} = \\frac{25}{10265} = \\frac{5}{2053}$$\n\n最后，我们计算所需的比率：\n$$\\frac{R_{\\text{mit}}}{R_{\\text{base}}} = \\frac{1 - f_{\\text{idle, mit}}}{1 - f_{\\text{idle, base}}} = \\frac{1 - \\frac{5}{2053}}{1 - \\frac{1}{30}}$$\n$$\\frac{R_{\\text{mit}}}{R_{\\text{base}}} = \\frac{\\frac{2053 - 5}{2053}}{\\frac{30 - 1}{30}} = \\frac{\\frac{2048}{2053}}{\\frac{29}{30}} = \\frac{2048}{2053} \\times \\frac{30}{29} = \\frac{61440}{59537}$$\n进行除法运算以获得一个小数：\n$$\\frac{61440}{59537} \\approx 1.03196348$$\n根据问题陈述的要求，将结果四舍五入到四位有效数字，得到 $1.032$。这表示乘性改进约为 $3.2\\%$。",
            "answer": "$$\\boxed{1.032}$$"
        }
    ]
}