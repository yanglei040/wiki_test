{
    "hands_on_practices": [
        {
            "introduction": "To truly understand error detection, we must first bridge the gap between abstract theory and concrete implementation. This practice guides you through the process of designing a parity generator circuit from the ground up, using only universal NAND gates. By constructing an XOR subcircuit and assembling it into a larger structure, you will gain hands-on experience in combinational logic design and see how a fundamental concept like parity translates into physical hardware .",
            "id": "3640130",
            "problem": "A memory subsystem uses an even-parity bit to detect single-bit errors on each transmitted data word. For a data word of length $n$, the even-parity bit $p$ is defined by the modulo-$2$ sum $p = d_1 \\oplus d_2 \\oplus \\cdots \\oplus d_n$, where $\\oplus$ denotes the exclusive-or (XOR) of Boolean variables and $d_i \\in \\{0,1\\}$. You are to design a combinational logic parity generator using only $2$-input NAND gates, assuming unlimited fan-out and that only uncomplemented primary inputs $d_i$ are available.\n\nStarting only from the Boolean-algebra definitions of NAND and XOR and standard identities, carry out the following steps:\n\n- Construct a $2$-input XOR subcircuit using only $2$-input NAND gates, and justify its correctness by algebraic manipulation of Boolean expressions.\n- Use a balanced binary reduction tree of identical $2$-input XOR subcircuits to implement $p = d_1 \\oplus \\cdots \\oplus d_n$.\n- Derive the exact total number $G(n)$ of $2$-input NAND gates required by the entire parity generator as a function of $n$.\n\nFor context and comparison (do not include this in the requested final value), also state in your reasoning how the NAND-only gate count compares to a baseline that uses $2$-input XOR gates as primitives in the same balanced tree (counting each XOR primitive as one gate).\n\nProvide your final answer as the single closed-form expression $G(n)$ in terms of $n$. No numerical approximation or rounding is required.",
            "solution": "The problem asks for the derivation of the total number of $2$-input NAND gates, $G(n)$, required to build an $n$-bit even-parity generator. The design is constrained to use only $2$-input NAND gates, with uncomplemented primary inputs, and must be structured as a balanced binary reduction tree of identical $2$-input XOR subcircuits.\n\nThe derivation will proceed in three steps as requested by the problem statement. First, we will construct a $2$-input XOR subcircuit using only $2$-input NAND gates and prove its correctness. Second, we will analyze the structure of the balanced binary tree to determine the number of such XOR subcircuits required. Finally, we will combine these results to derive the total gate count $G(n)$.\n\n**Step 1: Construction of a $2$-Input XOR Subcircuit from $2$-Input NAND Gates**\n\nLet the inputs to the XOR function be $A$ and $B$. The Boolean expression for XOR is:\n$$A \\oplus B = A'B + AB'$$\nThe Boolean expression for a $2$-input NAND gate is:\n$$A \\uparrow B = (A \\cdot B)' = A' + B'$$\nwhere we use the operator $\\uparrow$ to denote the NAND operation.\n\nWe must construct a circuit equivalent to $A \\oplus B$ using only the $\\uparrow$ operator. While several implementations exist, a well-known and efficient circuit uses four $2$-input NAND gates. Its structure is given by the following Boolean expression:\n$$F = (A \\uparrow (A \\uparrow B)) \\uparrow (B \\uparrow (A \\uparrow B))$$\n\nTo justify the correctness of this construction, we will algebraically manipulate this expression to show it is equivalent to $A \\oplus B$. Let's define an intermediate signal $G_1 = A \\uparrow B$. The expression for the output $F$ becomes:\n$$F = (A \\uparrow G_1) \\uparrow (B \\uparrow G_1)$$\nExpanding this using the definition of the NAND operation:\n$$F = ( (A \\uparrow G_1) \\cdot (B \\uparrow G_1) )'$$\n$$F = ( (A \\cdot G_1)' \\cdot (B \\cdot G_1)' )'$$\nApplying De Morgan's Law, which states that $(X' \\cdot Y')' = X + Y$, we can simplify this expression. Let $X = A \\cdot G_1$ and $Y = B \\cdot G_1$.\n$$F = (A \\cdot G_1) + (B \\cdot G_1)$$\nUsing the distributive law, we can factor out $G_1$:\n$$F = (A+B) \\cdot G_1$$\nNow, we substitute the expression for $G_1 = A \\uparrow B = (A \\cdot B)'$:\n$$F = (A+B) \\cdot (A \\cdot B)'$$\nApplying De Morgan's Law to $(A \\cdot B)'$ gives $A' + B'$:\n$$F = (A+B) \\cdot (A' + B')$$\nWe expand this expression using the distributive law:\n$$F = A \\cdot (A' + B') + B \\cdot (A' + B')$$\n$$F = (A \\cdot A') + (A \\cdot B') + (B \\cdot A') + (B \\cdot B')$$\nAccording to the axioms of Boolean algebra, $X \\cdot X' = 0$. Therefore, $A \\cdot A' = 0$ and $B \\cdot B' = 0$. The expression simplifies to:\n$$F = 0 + A \\cdot B' + A' \\cdot B + 0$$\n$$F = A'B + AB'$$\nThis final expression is the definition of the exclusive-or function, $A \\oplus B$. Thus, the circuit built from four $2$-input NAND gates correctly implements a $2$-input XOR function. The number of gates required for one such subcircuit is $4$. The problem's constraint that only uncomplemented inputs are available is satisfied, as this design takes inputs $A$ and $B$ directly.\n\n**Step 2: Analysis of the Balanced Binary Reduction Tree**\n\nThe parity bit $p$ is defined as the XOR sum of $n$ data bits:\n$$p = d_1 \\oplus d_2 \\oplus \\cdots \\oplus d_n$$\nThe XOR operation is associative, meaning $(A \\oplus B) \\oplus C = A \\oplus (B \\oplus C)$. This allows us to compute the $n$-input XOR sum by cascading $2$-input XOR operations in a tree structure. A balanced binary reduction tree is specified to minimize the propagation delay.\n\nTo compute the XOR sum of $n$ inputs using $2$-input gates, we require a total of $n-1$ such gates. We can demonstrate this by induction. Let $N_{\\text{XOR}}(n)$ be the number of $2$-input XOR subcircuits required for $n$ inputs.\n- For $n=2$, we need $1$ subcircuit, so $N_{\\text{XOR}}(2) = 1 = 2-1$.\n- For $n=3$, we compute $(d_1 \\oplus d_2) \\oplus d_3$, which requires $2$ subcircuits. So $N_{\\text{XOR}}(3) = 2 = 3-1$.\n- For a general $n$, a balanced tree structure partitions the $n$ inputs into two groups of size $\\lceil n/2 \\rceil$ and $\\lfloor n/2 \\rfloor$. The XOR sums of these two groups are computed recursively, and their results are combined with one final XOR gate. The recurrence relation is:\n$$N_{\\text{XOR}}(n) = N_{\\text{XOR}}(\\lceil n/2 \\rceil) + N_{\\text{XOR}}(\\lfloor n/2 \\rfloor) + 1$$\nwith the base case $N_{\\text{XOR}}(1) = 0$.\nAssuming the inductive hypothesis $N_{\\text{XOR}}(k) = k-1$ for all $k < n$:\n$$N_{\\text{XOR}}(n) = (\\lceil n/2 \\rceil - 1) + (\\lfloor n/2 \\rfloor - 1) + 1$$\n$$N_{\\text{XOR}}(n) = \\lceil n/2 \\rceil + \\lfloor n/2 \\rfloor - 1$$\nFor any integer $n$, the identity $\\lceil n/2 \\rceil + \\lfloor n/2 \\rfloor = n$ holds. Therefore:\n$$N_{\\text{XOR}}(n) = n - 1$$\nThis proves that a total of $n-1$ identical $2$-input XOR subcircuits are needed to implement the $n$-bit parity generator.\n\n**Step 3: Derivation of the Total NAND Gate Count $G(n)$**\n\nWe have established the following:\n1.  Each $2$-input XOR subcircuit is implemented using $4$ two-input NAND gates.\n2.  The entire $n$-bit parity generator requires $n-1$ of these identical XOR subcircuits, arranged in a balanced tree.\n\nEach XOR subcircuit in the tree receives as its inputs either the primary inputs $d_i$ or the uncomplemented outputs from a preceding level of XOR subcircuits. Since each subcircuit is a self-contained module, there are no opportunities for gate sharing between them.\n\nThe total number of $2$-input NAND gates, $G(n)$, is therefore the product of the number of XOR subcircuits and the number of NAND gates per subcircuit:\n$$G(n) = (\\text{Number of XOR subcircuits}) \\times (\\text{NAND gates per XOR subcircuit})$$\n$$G(n) = (n-1) \\times 4$$\n$$G(n) = 4(n-1)$$\n\nFor context and comparison, as requested, a baseline design using primitive $2$-input XOR gates would require $n-1$ gates in total. Our NAND-only implementation requires $4(n-1)$ gates, which is a factor of $4$ larger. This factor directly reflects the gate complexity of synthesizing an XOR function from a NAND-only logic family under the given constraints.\n\nThe final derived expression for the total number of $2$-input NAND gates for an $n$-bit parity generator is $G(n) = 4(n-1)$.",
            "answer": "$$\\boxed{4(n-1)}$$"
        },
        {
            "introduction": "While parity is effective at catching single-bit errors, its primary limitation is its inability to detect an even number of bit flips. This thought experiment models a realistic physical scenario where such errors are not just possible, but expected due to crosstalk between adjacent wires on a circuit board. By calculating the probability of an undetected error under this model, you will explore the practical limitations of simple parity and understand why more robust codes are often necessary .",
            "id": "3640110",
            "problem": "A parallel data bus with $32$ data wires and one parity wire implements even parity error detection, meaning the parity generator sets the parity bit so that the total number of logical ones across the $33$ transmitted bits is even. The receiver recomputes parity on the received data and compares to the received parity bit to detect discrepancies. Each data transmission is one word ($32$ data bits plus one parity bit) sent simultaneously over physically adjacent microstrip traces on a printed circuit board. Because the traces are long and closely spaced, capacitive coupling induces crosstalk between adjacent wires.\n\nModel the physical error mechanisms during a single word transmission as follows:\n- Independent single-wire bit flips occur due to random noise with probability $p$ per wire per transmission, and these events are independent across wires.\n- In addition, for each physically adjacent wire pair, a coupled two-wire simultaneous flip (both wires invert together) occurs with probability $q$ per adjacent pair per transmission, independent across pairs and independent of single-wire flips.\n\nAssume a linear physical arrangement of the $33$ wires: $D_0, D_1, \\ldots, D_{31}, P$, where $D_i$ are data wires and $P$ is the parity wire. In this arrangement, there are $32$ adjacent pairs: $(D_0,D_1), (D_1,D_2), \\ldots, (D_{30},D_{31}), (D_{31},P)$. For this case study, take $p = 1.2 \\times 10^{-6}$ and $q = 3.0 \\times 10^{-8}$.\n\nStarting from the definition of even parity and the axioms of elementary probability, and using a rare-event approximation that neglects all terms of order $p^{2}$, $pq$, and $q^{2}$ (i.e., assume at most one error event occurs per transmission), derive and compute the probability that an error occurs but is not detected by the parity check. Express your final probability as a decimal in scientific notation and round your answer to four significant figures.",
            "solution": "The problem asks for the probability that an error occurs but is not detected by the even parity check. An even parity check detects an error if and only if the number of flipped bits is odd. Consequently, an error is undetected if and only if a non-zero, even number of bits are flipped.\n\nThe problem specifies two types of error events for a single word transmission:\n1.  A single-wire bit flip, occurring with probability $p$ for each of the $N_{wires} = 33$ wires.\n2.  A coupled two-wire simultaneous flip on an adjacent pair, occurring with probability $q$ for each of the $N_{pairs} = 32$ adjacent pairs.\n\nThe problem requires a rare-event approximation, where all terms of order $p^2$, $pq$, and $q^2$ are neglected. This is equivalent to assuming that at most one error event (of either type) occurs during a single transmission.\n\nLet's analyze the consequences of each type of event under this approximation:\n- **Case 1: A single-wire bit flip occurs.**\nIn this event, exactly one bit is flipped. Since $1$ is an odd number, the parity of the bit string changes (from even to odd). Therefore, this error will always be detected by the parity check. The probability of this event, which leads to a detected error, is not relevant to the final calculation of *undetected* errors.\n\n- **Case 2: A coupled two-wire simultaneous flip occurs.**\nIn this event, exactly two bits are flipped. Since $2$ is an even number, the parity of the bit string remains unchanged. An even number of '1's becomes another even number of '1's. For example, if two '0's flip to '1's, the count of '1's increases by $2$. If two '1's flip to '0's, the count decreases by $2$. If a '0' and a '1' flip, the count is unchanged. In all sub-cases, the parity of the count of '1's is invariant. Therefore, such an error will always be undetected by the parity check.\n\nGiven the approximation that at most one error event occurs, the only way for an undetected error to happen is through a single coupled two-wire flip. The problem thus reduces to calculating the probability that at least one such event occurs.\n\nLet $C_i$ be the event of a coupled flip on the $i$-th adjacent pair, for $i \\in \\{1, 2, \\ldots, 32\\}$. The probability of each such event is given as $P(C_i) = q$. We are interested in the probability of the union of these events, $P_{undetected} = P(C_1 \\cup C_2 \\cup \\ldots \\cup C_{32})$.\n\nUsing the principle of inclusion-exclusion, the probability of the union of events is:\n$$ P(\\cup_{i=1}^{32} C_i) = \\sum_{i} P(C_i) - \\sum_{i<j} P(C_i \\cap C_j) + \\sum_{i<j<k} P(C_i \\cap C_j \\cap C_k) - \\ldots $$\nThe problem states that coupled flips are independent across pairs. Therefore, $P(C_i \\cap C_j) = P(C_i)P(C_j) = q^2$, and so on for higher-order intersections. Substituting this into the inclusion-exclusion formula:\n$$ P_{undetected} = \\binom{32}{1}q - \\binom{32}{2}q^2 + \\binom{32}{3}q^3 - \\ldots $$\nThe problem explicitly instructs us to neglect terms of order $q^2$ and higher. This means we only need to consider the first term of this series.\n$$ P_{undetected} \\approx \\binom{32}{1}q = 32q $$\nThis is the probability that exactly one coupled two-wire flip occurs.\n\nNow, we can substitute the given numerical values.\nThe number of adjacent pairs is $N_{pairs} = 32$.\nThe probability of a coupled flip per pair is $q = 3.0 \\times 10^{-8}$.\n\nThe probability of an undetected error is:\n$$ P_{undetected} \\approx 32 \\times q = 32 \\times (3.0 \\times 10^{-8}) $$\n$$ P_{undetected} \\approx 96.0 \\times 10^{-8} $$\nTo express this in standard scientific notation, we adjust the coefficient to be between $1$ and $10$.\n$$ P_{undetected} \\approx 9.6 \\times 10^{-7} $$\nThe problem requires the answer to be rounded to four significant figures.\n$$ P_{undetected} \\approx 9.600 \\times 10^{-7} $$\nThe probability $p$ for single-wire flips is irrelevant to this specific question, as single-bit errors are always detected by a parity check.",
            "answer": "$$\\boxed{9.600 \\times 10^{-7}}$$"
        },
        {
            "introduction": "Detecting an error is a critical first step, but what happens next? A robust system must have a plan to recover from the error and resume correct operation, and this recovery process has a direct impact on performance. This exercise puts you in the role of a microarchitect, tasking you with designing a recovery routine for a cache parity error and quantifying its effect on the processor's overall throughput, connecting low-level error handling to high-level system metrics .",
            "id": "3640136",
            "problem": "A Central Processing Unit (CPU) implements odd-parity error detection on each Level-1 Data Cache (L1 DC) line. When a parity error is detected during a data read, control transfers to a microcode routine. Using only core definitions and well-tested facts about performance metrics and expectation, propose a scientifically realistic microcode service sequence for the parity error and derive its throughput impact. The following conditions are guaranteed:\n\n- A data cache access triggers a parity check over a parity bit stored alongside the cache line; the check detects any single-bit error.\n- Upon detection on a read, microcode must prevent architecturally visible corruption, recover a clean line from a lower level, and resume execution by replaying the faulting instruction.\n- The pipeline supports flushing and replay, and the cache hierarchy has a Level-2 (L2) cache and main memory.\n\nFor your sequence, assume the following cycle costs for each phase of servicing the parity error:\n\n- Pipeline flush cost is $F = 15$ cycles.\n- Line refill is an average over sources: with probability $q = 0.9$ the line is supplied by the L2 cache with latency $\\ell_2 = 12$ cycles; with probability $1 - q = 0.1$ it must be fetched from main memory with latency $\\ell_m = 200$ cycles.\n- Exception logging and state management in microcode costs $E = 40$ cycles.\n- Replay of the faulting instruction costs $X = 4$ cycles.\n\nAssume a baseline Cycles Per Instruction (CPI) of $CPI_0 = 1.2$ in steady state at a fixed clock frequency, and that an instruction accesses the data cache with probability $p = 0.35$ (at most one data access per instruction for this estimate). Let $r$ denote the parity error rate per data cache access, where $0 \\le r \\ll 1$. Use the definition $\\text{Instructions Per Cycle (IPC)} = \\frac{\\text{instructions}}{\\text{cycles}}$ and $\\text{Cycles Per Instruction (CPI)} = \\frac{\\text{cycles}}{\\text{instruction}}$, with $IPC = \\frac{1}{CPI}$ at fixed frequency, and the linearity of expectation for per-instruction overhead.\n\nTasks:\n\n- Propose a logically ordered microcode routine that flushes the pipeline, refills the line, performs exception handling, and replays the instruction, in a way that prevents propagation of corrupted data and preserves architectural state.\n- Using the given cycle costs and the above definitions, derive a closed-form expression for the normalized throughput $T(r)$, defined as the ratio of the effective $IPC$ under parity errors to the baseline $IPC$ without errors, as a function of $r$ only. Express your final answer as a single analytic expression in $r$.\n\nNo rounding is required. Do not include any units in the final expression.",
            "solution": "The problem is first validated to be scientifically grounded, well-posed, objective, and complete. All conditions for a valid problem are met, allowing for a complete solution to be derived.\n\nThe solution proceeds in two parts as requested: first, proposing a logical microcode service sequence for the parity error, and second, deriving the normalized throughput as a function of the error rate $r$.\n\n**Part 1: Microcode Service Sequence**\n\nUpon detection of a parity error during a data read from the Level-$1$ Data Cache (L1 DC), the microcode must orchestrate a recovery sequence that meets three primary objectives: preventing the propagation of corrupted data, recovering a correct copy of the data, and resuming normal execution. A logically sound and minimal sequence of operations is as follows:\n\n1.  **Pipeline Flush**: Immediately upon error detection, the processor pipeline must be flushed. This action discards the faulting instruction and any subsequent, speculatively executed instructions. This is a critical first step to prevent the corrupted data, which was read from the cache, from being written to an architectural register or otherwise affecting the processor's architectural state. The cost for this is given as $F = 15$ cycles.\n\n2.  **Exception Logging and State Management**: After halting speculative execution, the microcode routine takes control. It must log the occurrence of the parity error, typically in machine-check registers. This provides diagnostic information for system reliability analysis. This phase also includes any necessary state management to prepare for data recovery. The cost for this is given as $E = 40$ cycles.\n\n3.  **Cache Line Refill**: The microcode invalidates the L1 DC line containing the corrupted data. It then initiates a read request to the next level of the memory hierarchy to fetch a clean copy of the line. This request is serviced by either the Level-$2$ (L2) cache or main memory. The system stalls while waiting for the data to be returned and written into the L1 DC. This operation ensures data integrity is restored. The latency is probabilistic.\n\n4.  **Instruction Replay**: Once the correct data is available in the L1 DC, the microcode transfers control back to the program by re-initiating the instruction that originally caused the fault. Since the pipeline was flushed, this instruction is re-fetched and begins execution anew. This time, the data cache access will succeed with the correct data. The cost associated with the replay mechanism is given as $X = 4$ cycles.\n\nThe total cycle penalty for servicing a single parity error, denoted $C_{\\text{penalty}}$, is the sum of the costs of these sequential phases. The latency for the line refill phase is an average value, $\\bar{\\ell}$, that must be calculated.\n\n**Part 2: Derivation of Normalized Throughput $T(r)$**\n\nThe derivation proceeds by first calculating the total cycle penalty per error, then determining its impact on the effective Cycles Per Instruction (CPI), and finally expressing the normalized throughput.\n\nFirst, we calculate the average line refill latency, $\\bar{\\ell}$, using the law of total expectation with the given probabilities and latencies.\nThe line is supplied by the L2 cache with probability $q = 0.9$ and latency $\\ell_2 = 12$ cycles.\nThe line is supplied by main memory with probability $1 - q = 0.1$ and latency $\\ell_m = 200$ cycles.\n$$\n\\bar{\\ell} = q \\cdot \\ell_2 + (1 - q) \\cdot \\ell_m\n$$\nSubstituting the given values:\n$$\n\\bar{\\ell} = (0.9)(12) + (0.1)(200) = 10.8 + 20 = 30.8 \\text{ cycles}\n$$\nThe total penalty in cycles for one parity error event, $C_{\\text{penalty}}$, is the sum of the costs of the sequential recovery phases:\n$$\nC_{\\text{penalty}} = F + E + \\bar{\\ell} + X\n$$\nSubstituting the known values:\n$$\nC_{\\text{penalty}} = 15 + 40 + 30.8 + 4 = 89.8 \\text{ cycles}\n$$\nNext, we determine the effective CPI, denoted $CPI_{\\text{eff}}$. The baseline CPI without errors is $CPI_0 = 1.2$. The effective CPI is the baseline CPI plus the average overhead in cycles per instruction caused by parity errors.\n\nAn instruction incurs this penalty only if it accesses the data cache and a parity error occurs on that access.\nThe probability that a given instruction accesses the data cache is $p = 0.35$.\nThe probability of a parity error per data cache access is $r$.\nAssuming these events are independent, the probability that any given instruction triggers a parity error is the product $p \\cdot r$.\n\nThe expected overhead in cycles per instruction is the total penalty for an error multiplied by the probability of an error occurring per instruction:\n$$\n\\text{Overhead}_{\\text{cycles/instruction}} = C_{\\text{penalty}} \\cdot (p \\cdot r)\n$$\nThe effective CPI is then:\n$$\nCPI_{\\text{eff}}(r) = CPI_0 + \\text{Overhead}_{\\text{cycles/instruction}} = CPI_0 + C_{\\text{penalty}} \\cdot p \\cdot r\n$$\nThe normalized throughput $T(r)$ is defined as the ratio of the effective Instructions Per Cycle ($IPC_{\\text{eff}}$) to the baseline IPC ($IPC_0$). Using the relation $IPC = \\frac{1}{CPI}$:\n$$\nT(r) = \\frac{IPC_{\\text{eff}}}{IPC_0} = \\frac{1/CPI_{\\text{eff}}(r)}{1/CPI_0} = \\frac{CPI_0}{CPI_{\\text{eff}}(r)}\n$$\nSubstituting the expression for $CPI_{\\text{eff}}(r)$:\n$$\nT(r) = \\frac{CPI_0}{CPI_0 + C_{\\text{penalty}} \\cdot p \\cdot r}\n$$\nThis expression can be rearranged to isolate the dependency on $r$:\n$$\nT(r) = \\frac{1}{1 + \\left(\\frac{C_{\\text{penalty}} \\cdot p}{CPI_0}\\right) r}\n$$\nNow, we substitute the numerical values into the coefficient of $r$:\n$CPI_0 = 1.2 = \\frac{6}{5}$\n$p = 0.35 = \\frac{7}{20}$\n$C_{\\text{penalty}} = 89.8 = \\frac{898}{10} = \\frac{449}{5}$\nThe coefficient is:\n$$\n\\frac{C_{\\text{penalty}} \\cdot p}{CPI_0} = \\frac{\\left(\\frac{449}{5}\\right) \\cdot \\left(\\frac{7}{20}\\right)}{\\frac{6}{5}} = \\frac{449 \\cdot 7}{5 \\cdot 20} \\cdot \\frac{5}{6} = \\frac{449 \\cdot 7}{20 \\cdot 6} = \\frac{3143}{120}\n$$\nThus, the final closed-form expression for the normalized throughput $T(r)$ is:\n$$\nT(r) = \\frac{1}{1 + \\frac{3143}{120} r}\n$$",
            "answer": "$$\n\\boxed{\\frac{1}{1 + \\frac{3143}{120} r}}\n$$"
        }
    ]
}