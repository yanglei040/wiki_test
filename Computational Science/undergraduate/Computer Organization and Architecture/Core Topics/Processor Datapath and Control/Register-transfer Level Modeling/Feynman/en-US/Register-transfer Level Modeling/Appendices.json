{
    "hands_on_practices": [
        {
            "introduction": "This first exercise focuses on a fundamental building block in digital systems: the bus arbiter. You will model and compare two classic arbitration policies, fixed-priority and round-robin, to understand their profound impact on system fairness and performance. This practice is essential for learning how to implement stateful control logic and analyze critical behaviors like resource starvation through cycle-accurate simulation .",
            "id": "3672585",
            "problem": "Design and implement a cycle-accurate simulation, at the level of Register-Transfer Level (RTL) semantics, of a shared bus arbiter serving $M$ requesters under two arbitration policies: round-robin and fixed priority. The arbiter operates synchronously with a single global clock. At each clock cycle $t \\in \\{0,1,2,\\dots,T-1\\}$, each requester $i \\in \\{0,1,\\dots,M-1\\}$ presents a binary request signal $r_i[t] \\in \\{0,1\\}$. The arbiter produces a one-hot grant vector $g[t] = (g_0[t],g_1[t],\\dots,g_{M-1}[t])$ with $g_i[t] \\in \\{0,1\\}$ and $\\sum_{i=0}^{M-1} g_i[t] \\le 1$ for each cycle $t$. If no request is asserted in a cycle, then $\\sum_{i=0}^{M-1} g_i[t] = 0$.\n\nThe system follows synchronous RTL semantics: combinational logic derives $g[t]$ from $r[t]$ and any architectural register state at time $t$, and sequential registers are updated on the active clock edge, producing state for time $t+1$.\n\nTwo arbitration policies must be modeled:\n\n- Fixed Priority (FP): A static strict priority order is assumed, where lower index implies higher priority. Given $r[t]$, the FP arbiter chooses the least index $i$ such that $r_i[t]=1$ and sets $g_i[t]=1$ and $g_j[t]=0$ for all $j \\ne i$. If no such $i$ exists, then $g[t]=\\mathbf{0}$.\n\n- Round-Robin (RR): A pointer register $p[t] \\in \\{0,1,\\dots,M-1\\}$ encodes the next requester to check first. Given $r[t]$ and $p[t]$, the RR arbiter scans in the cyclic order $p[t], p[t]+1 \\bmod M, \\dots, p[t]+M-1 \\bmod M$, chooses the first index $i$ with $r_i[t]=1$, and sets $g_i[t]=1$ and $g_j[t]=0$ for all $j \\ne i$. If at least one grant occurs at time $t$ to index $i$, then $p[t+1] = (i+1) \\bmod M$. If no grant occurs, then $p[t+1] = p[t]$. Initialize $p[0]=0$.\n\nTraffic model (burst requests): Each requester $i$ generates periodic bursts characterized by three nonnegative integers $(L_i,G_i,S_i)$ with the following semantics. If $L_i=0$, then $r_i[t]=0$ for all $t$. Otherwise, define the period $P_i=L_i+G_i$. For all $t \\ge 0$,\n$$\nr_i[t] = \\begin{cases}\n1, & \\text{if } t \\ge S_i \\text{ and } \\left( (t - S_i) \\bmod P_i \\right) < L_i, \\\\\n0, & \\text{otherwise}.\n\\end{cases}\n$$\nThis models bursts of length $L_i$ cycles separated by gaps of $G_i$ cycles, starting at cycle $S_i$. If $G_i=0$ and $L_i>0$, then requester $i$ is continuously requesting for all $t \\ge S_i$.\n\nMetrics to compute for each arbitration policy over the horizon of $T$ cycles:\n\n- Per requester grant count: $C_i = \\sum_{t=0}^{T-1} g_i[t]$ for each $i$.\n\n- Per requester maximum wait (in cycles): For each $i$, define the per-cycle waiting counter $w_i[t]$ as the length of the current run of consecutive cycles up to and including cycle $t$ during which $r_i[t']=1$ and $g_i[t']=0$ for all $t'$ in that run. Reset this counter to $0$ whenever either $r_i[t]=0$ or $g_i[t]=1$. Define $W_i = \\max_{t \\in \\{0,\\dots,T-1\\}} w_i[t]$.\n\n- Starvation indicator per requester: For each $i$, define $R_i = \\sum_{t=0}^{T-1} r_i[t]$ and $S_i^\\star = \\begin{cases}1,& \\text{if } R_i > 0 \\text{ and } C_i = 0,\\\\ 0,& \\text{otherwise.}\\end{cases}$\n\nAggregate the following per-policy metrics to report:\n\n- Starved requester count: $S^\\text{count} = \\sum_{i=0}^{M-1} S_i^\\star$.\n\n- Maximum wait across all requesters: $W^\\text{max} = \\max_{i \\in \\{0,\\dots,M-1\\}} W_i$.\n\nImplement a complete, runnable program that, for each test case below, simulates both arbitration policies over $T$ cycles using the burst request model, and produces the following result per test case:\n\n- For round-robin: a list $[\\,[C_0,\\dots,C_{M-1}],\\, W^\\text{max},\\, S^\\text{count}\\,]$.\n\n- For fixed priority: a list $[\\,[C_0,\\dots,C_{M-1}],\\, W^\\text{max},\\, S^\\text{count}\\,]$.\n\nThe final program output must be a single line containing the results for all test cases as a comma-separated list enclosed in square brackets, where each test case is represented as a two-element list $[ \\text{RR\\_metrics}, \\text{FP\\_metrics} ]$ in the order given below. No other text should be printed.\n\nTest suite (three cases):\n\n- Case A (balanced staggered bursts):\n  - $M=4$, $T=24$.\n  - Requester $0$: $(L_0,G_0,S_0)=(3,5,0)$.\n  - Requester $1$: $(L_1,G_1,S_1)=(3,5,2)$.\n  - Requester $2$: $(L_2,G_2,S_2)=(3,5,4)$.\n  - Requester $3$: $(L_3,G_3,S_3)=(3,5,6)$.\n\n- Case B (always-on high-priority competitor):\n  - $M=3$, $T=30$.\n  - Requester $0$: $(L_0,G_0,S_0)=(30,0,0)$.\n  - Requester $1$: $(L_1,G_1,S_1)=(2,4,0)$.\n  - Requester $2$: $(L_2,G_2,S_2)=(2,4,2)$.\n\n- Case C (no requests):\n  - $M=5$, $T=10$.\n  - For all $i \\in \\{0,1,2,3,4\\}$: $(L_i,G_i,S_i)=(0,1,0)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the exact structure:\n$[ [\\text{RR\\_A},\\text{FP\\_A}], [\\text{RR\\_B},\\text{FP\\_B}], [\\text{RR\\_C},\\text{FP\\_C}] ]$\nwhere each $\\text{RR\\_X}$ and $\\text{FP\\_X}$ is itself a list of the form $[[C_0,\\dots,C_{M-1}],W^\\text{max},S^\\text{count}]$. All numeric values must be integers. No spaces are required; if you include spaces, they will be ignored by the autograder, but it is recommended to omit spaces.",
            "solution": "The problem requires the design and implementation of a cycle-accurate Register-Transfer Level (RTL) simulation of a shared bus arbiter. The simulation must model a system with $M$ requesters over a time horizon of $T$ cycles, under two distinct arbitration policies: Fixed Priority (FP) and Round-Robin (RR).\n\nThe simulation adheres to synchronous RTL semantics, where system behavior is defined on discrete clock cycles $t=0, 1, \\dots, T-1$. The process for each cycle $t$ can be decomposed into two main phases, mirroring the behavior of a physical digital circuit: evaluation of combinational logic and updating of sequential state.\n\nFirst, the combinational logic is evaluated. This logic produces outputs that are functions of the current cycle's inputs and state.\nThe primary inputs to the arbiter are the request signals from each requester $i$, denoted by $r_i[t]$. These are generated according to the specified burst traffic model, which is a function of parameters $(L_i, G_i, S_i)$:\n$$\nr_i[t] = \\begin{cases}\n1, & \\text{if } L_i > 0, t \\ge S_i \\text{ and } \\left( (t - S_i) \\bmod (L_i+G_i) \\right) < L_i \\\\\n0, & \\text{otherwise}\n\\end{cases}\n$$\nThis formula deterministically computes the request vector $r[t] = (r_0[t], \\dots, r_{M-1}[t])$ for each cycle $t$.\n\nGiven the request vector $r[t]$ and any relevant state from the beginning of the cycle, the arbiter's combinational logic computes the one-hot grant vector $g[t] = (g_0[t], \\dots, g_{M-1}[t])$. The logic depends on the arbitration policy:\n\n1.  **Fixed Priority (FP)**: This policy is stateless. The grant logic is a pure combinational function of $r[t]$. It prioritizes requesters by their index, with smaller indices having higher priority. The grant $g_i[t]$ is set to $1$ for the smallest index $i$ for which $r_i[t]=1$. If no requests are active ($\\sum r_i[t] = 0$), then all grants are $0$.\n    $$g_i[t] = \\begin{cases} 1, & \\text{if } r_i[t]=1 \\text{ and } r_j[t]=0 \\text{ for all } j < i \\\\ 0, & \\text{otherwise} \\end{cases}$$\n\n2.  **Round-Robin (RR)**: This policy requires architectural state, specifically a pointer register $p[t]$ that stores the index of the requester to be checked first. The grant logic is a combinational function of $r[t]$ and $p[t]$. The arbiter searches for an active request starting from index $p[t]$ and wrapping around cyclically. The first active requester found, say $k$, receives the grant ($g_k[t]=1$).\n    The search sequence is $p[t], (p[t]+1)\\bmod M, \\dots, (p[t]+M-1)\\bmod M$.\n\nOnce the grant vector $g[t]$ is determined for the cycle, the required performance metrics are updated. These calculations can be viewed as monitoring logic.\n\n-   **Grant Count ($C_i$)**: For each requester $i$ that receives a grant ($g_i[t]=1$), its total grant count $C_i$ is incremented. $C_i = \\sum_{t=0}^{T-1} g_i[t]$.\n-   **Wait Time ($w_i[t]$ and $W_i$)**: A per-requester waiting counter $w_i[t]$ tracks consecutive cycles of unserved requests. Its value is updated based on $r_i[t]$ and $g_i[t]$:\n    $$w_i[t] = \\begin{cases} w_i[t-1] + 1, & \\text{if } r_i[t]=1 \\text{ and } g_i[t]=0 \\\\ 0, & \\text{if } r_i[t]=0 \\text{ or } g_i[t]=1 \\end{cases}$$\n    with the initial condition $w_i[-1]=0$. The maximum wait time for requester $i$, $W_i$, is the maximum value $w_i[t]$ attains over the simulation horizon: $W_i = \\max_{0 \\le t < T} w_i[t]$.\n\nSecond, at the end of the cycle (conceptually, on the active clock edge), the sequential state registers are updated to their values for the next cycle, $t+1$.\n\n-   **For the FP policy**, there is no state, so no update is needed.\n-   **For the RR policy**, the pointer register $p$ is updated. If a grant was issued to requester $k$ in cycle $t$, the pointer moves to the next position: $p[t+1] = (k+1) \\bmod M$. If no grant was issued, the pointer remains unchanged: $p[t+1] = p[t]$. The initial state is $p[0]=0$.\n\nThis entire process is repeated for $t$ from $0$ to $T-1$. After the simulation loop completes, the final aggregate metrics are calculated:\n-   **Starvation Indicator ($S_i^\\star$) and Count ($S^\\text{count}$)**: A requester $i$ is considered starved if it made at least one request ($R_i = \\sum_{t=0}^{T-1} r_i[t] > 0$) but received no grants ($C_i = 0$). The total count is $S^\\text{count} = \\sum_{i=0}^{M-1} S_i^\\star$.\n-   **Maximum Wait Across Requesters ($W^\\text{max}$)**: This is the maximum of all per-requester maximum wait times: $W^\\text{max} = \\max_{i=0}^{M-1} W_i$.\n\nThe implementation will consist of a main simulation function encapsulating this logic, which is called for each test case and for each of the two arbitration policies. The results are then collected and printed in the specified format.",
            "answer": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n// Enum to define the arbitration policy\ntypedef enum {\n    ROUND_ROBIN,\n    FIXED_PRIORITY\n} Policy;\n\n// Struct to hold requester traffic parameters\ntypedef struct {\n    int L; // Burst length\n    int G; // Gap length\n    int S; // Start cycle\n} RequesterParams;\n\n// Struct to hold the parameters for a single test case\ntypedef struct {\n    int M; // Number of requesters\n    int T; // Number of cycles\n    RequesterParams* requesters; // Array of requester parameters\n} TestCase;\n\n// Struct to hold the results of a single simulation run\ntypedef struct {\n    int* grant_counts;\n    int max_wait_overall;\n    int starved_count;\n} SimResult;\n\n// Function to run a single simulation\nSimResult run_simulation(const TestCase* tc, Policy policy) {\n    int M = tc->M;\n    int T = tc->T;\n\n    // Allocate memory for metrics and state variables\n    int* requests = (int*)calloc(M, sizeof(int));\n    int* grants = (int*)calloc(M, sizeof(int));\n    \n    int* total_requests = (int*)calloc(M, sizeof(int));\n    int* grant_counts = (int*)calloc(M, sizeof(int));\n    int* current_waits = (int*)calloc(M, sizeof(int));\n    int* max_waits = (int*)calloc(M, sizeof(int));\n\n    int rr_pointer = 0; // State for Round-Robin arbiter\n\n    // Main simulation loop over T cycles\n    for (int t = 0; t < T; ++t) {\n        // Step 1: Generate request signals for the current cycle t\n        for (int i = 0; i < M; ++i) {\n            RequesterParams p = tc->requesters[i];\n            if (p.L == 0 || t < p.S) {\n                requests[i] = 0;\n            } else {\n                int period = p.L + p.G;\n                if ((t - p.S) % period < p.L) {\n                    requests[i] = 1;\n                } else {\n                    requests[i] = 0;\n                }\n            }\n        }\n        \n        for (int i=0; i < M; ++i) {\n            if (requests[i] == 1) {\n                total_requests[i]++;\n            }\n        }\n\n        // Step 2: Apply arbitration logic to determine grants\n        for (int i = 0; i < M; ++i) grants[i] = 0;\n        int grant_issued = 0;\n        int grant_idx = -1;\n\n        if (policy == FIXED_PRIORITY) {\n            for (int i = 0; i < M; ++i) {\n                if (requests[i] == 1) {\n                    grants[i] = 1;\n                    grant_issued = 1;\n                    grant_idx = i;\n                    break; \n                }\n            }\n        } else { // ROUND_ROBIN\n            for (int k = 0; k < M; ++k) {\n                int i = (rr_pointer + k) % M;\n                if (requests[i] == 1) {\n                    grants[i] = 1;\n                    grant_issued = 1;\n                    grant_idx = i;\n                    break;\n                }\n            }\n        }\n\n        // Step 3: Update metrics based on requests and grants\n        for (int i = 0; i < M; ++i) {\n            if (grants[i] == 1) {\n                grant_counts[i]++;\n                current_waits[i] = 0;\n            } else if (requests[i] == 1) {\n                current_waits[i]++;\n            } else {\n                current_waits[i] = 0;\n            }\n            if (current_waits[i] > max_waits[i]) {\n                max_waits[i] = current_waits[i];\n            }\n        }\n\n        // Step 4: Update state for the next cycle\n        if (policy == ROUND_ROBIN) {\n            if (grant_issued) {\n                rr_pointer = (grant_idx + 1) % M;\n            }\n        }\n    }\n\n    // Step 5: Compute aggregate metrics after simulation\n    int max_wait_overall = 0;\n    for (int i = 0; i < M; ++i) {\n        if (max_waits[i] > max_wait_overall) {\n            max_wait_overall = max_waits[i];\n        }\n    }\n\n    int starved_count = 0;\n    for (int i = 0; i < M; ++i) {\n        if (total_requests[i] > 0 && grant_counts[i] == 0) {\n            starved_count++;\n        }\n    }\n    \n    // Free temporary memory\n    free(requests);\n    free(grants);\n    free(total_requests);\n    free(current_waits);\n    free(max_waits);\n    \n    // Prepare result struct\n    SimResult result;\n    result.grant_counts = grant_counts;\n    result.max_wait_overall = max_wait_overall;\n    result.starved_count = starved_count;\n    \n    return result;\n}\n\n// Helper to print a single result block in the required format\nvoid print_result(SimResult res, int M) {\n    printf(\"[[\");\n    for (int i = 0; i < M; ++i) {\n        printf(\"%d\", res.grant_counts[i]);\n        if (i < M - 1) printf(\",\");\n    }\n    printf(\"],%d,%d]\", res.max_wait_overall, res.starved_count);\n}\n\nint main(void) {\n    // Define test cases\n    RequesterParams r_A[] = {{3, 5, 0}, {3, 5, 2}, {3, 5, 4}, {3, 5, 6}};\n    RequesterParams r_B[] = {{30, 0, 0}, {2, 4, 0}, {2, 4, 2}};\n    RequesterParams r_C[] = {{0, 1, 0}, {0, 1, 0}, {0, 1, 0}, {0, 1, 0}, {0, 1, 0}};\n\n    TestCase test_cases[] = {\n        {4, 24, r_A},\n        {3, 30, r_B},\n        {5, 10, r_C}\n    };\n\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    \n    printf(\"[\");\n    for (int i = 0; i < num_cases; ++i) {\n        SimResult rr_res = run_simulation(&test_cases[i], ROUND_ROBIN);\n        SimResult fp_res = run_simulation(&test_cases[i], FIXED_PRIORITY);\n        \n        printf(\"[\");\n        print_result(rr_res, test_cases[i].M);\n        printf(\",\");\n        print_result(fp_res, test_cases[i].M);\n        printf(\"]\");\n        \n        if (i < num_cases - 1) {\n            printf(\",\");\n        }\n\n        free(rr_res.grant_counts);\n        free(fp_res.grant_counts);\n    }\n    printf(\"]\");\n\n    return EXIT_SUCCESS;\n}\n```"
        },
        {
            "introduction": "Building on the concept of control logic, this practice advances to modeling an industry-standard bus protocol interface. You will design a Finite State Machine (FSM) for a simplified AXI-Lite slave, implementing the crucial ready/valid handshake mechanism to manage data and address transactions. Mastering this exercise  provides invaluable experience in translating a protocol's timing diagram and rules into a correct and robust RTL implementation, a core skill for any digital designer.",
            "id": "3672621",
            "problem": "Design a discrete-time Register-Transfer Level (RTL) simulation of an Advanced eXtensible Interface (AXI)-Lite style slave that implements the ready/valid channels through a control Finite State Machine (FSM) derived by a formal timing diagram semantics. The purpose is to demonstrate the correct protocol ordering using a principled RTL model.\n\nFundamental base and definitions to start from:\n- A clocked RTL system models signals sampled at discrete times. Let the discrete time index be $t \\in \\mathbb{N}$, advancing by one for every clock tick.\n- The AXI-Lite channels follow ready/valid handshakes. For a channel with master-side valid $m\\_{\\mathrm{valid}}(t)$ and slave-side ready $s\\_{\\mathrm{ready}}(t)$, the handshake event $h(t)$ occurs when $h(t) = m\\_{\\mathrm{valid}}(t) \\land s\\_{\\mathrm{ready}}(t)$ at the same time $t$.\n- Payload stability constraint: if $m\\_{\\mathrm{valid}}(t) = 1$ and no handshake has yet occurred, then the payload must remain stable. That is, for a payload $p(t)$, for all $t$ during $m\\_{\\mathrm{valid}}(t) = 1$ until handshake, $p(t) = p(t-1)$ must hold.\n- Protocol ordering in AXI-Lite:\n  - Write transaction requires accepting the write address on the AW channel and write data on the W channel. The write response on the B channel cannot be asserted until both AW and W handshakes have occurred. A response is delivered with $s\\_{\\mathrm{bvalid}}(t) = 1$ and handshakes when $m\\_{\\mathrm{bready}}(t) = 1$.\n  - Read transaction requires accepting the read address on the AR channel, after which the read data on the R channel can be asserted. A response is delivered with $s\\_{\\mathrm{rvalid}}(t) = 1$ and handshakes when $m\\_{\\mathrm{rready}}(t) = 1$.\n- A single-outstanding-transaction constraint is imposed for simplicity: the slave must ensure at most one transaction is in-flight. Therefore, when a write is pending, the read address channel is not ready, and vice versa.\n\nYour program must simulate a slave RTL FSM that obeys the above semantics for a fixed memory-mapped register bank and detect master-side violations of the AXI-Lite stability rule. The simulation is purely logical and has no physical time units; advances are in discrete cycles $t$, and there are no physical units required in the answer.\n\nMemory model:\n- There are $4$ registers, each $32$-bit wide, addressed by byte addresses in the set $\\{0,4,8,12\\}$. Let the index be $i = \\frac{\\mathrm{addr}}{4}$ with $i \\in \\{0,1,2,3\\}$. All registers are initialized to $0$.\n\nChannels and signals per cycle $t$:\n- Master inputs:\n  - Write address (AW): $m\\_{\\mathrm{awvalid}}(t)$, $m\\_{\\mathrm{awaddr}}(t)$.\n  - Write data (W): $m\\_{\\mathrm{wvalid}}(t)$, $m\\_{\\mathrm{wdata}}(t)$.\n  - Write response readiness (B): $m\\_{\\mathrm{bready}}(t)$.\n  - Read address (AR): $m\\_{\\mathrm{arvalid}}(t)$, $m\\_{\\mathrm{araddr}}(t)$.\n  - Read response readiness (R): $m\\_{\\mathrm{rready}}(t)$.\n- Slave outputs to be simulated:\n  - $s\\_{\\mathrm{awready}}(t)$, $s\\_{\\mathrm{wready}}(t)$, $s\\_{\\mathrm{bvalid}}(t)$, $s\\_{\\mathrm{arready}}(t)$, $s\\_{\\mathrm{rvalid}}(t)$, and $s\\_{\\mathrm{rdata}}(t)$.\n\nSlave FSM requirements:\n- The slave must assert $s\\_{\\mathrm{awready}}(t) = 1$ when it can accept a new write address, and $s\\_{\\mathrm{wready}}(t) = 1$ when it can accept new write data, provided no read is active and no write response is pending.\n- Once both AW and W handshakes have occurred for a transaction, the slave shall assert $s\\_{\\mathrm{bvalid}}(t)$ starting at the next cycle and keep it asserted until a handshake occurs with $m\\_{\\mathrm{bready}}(t) = 1$. The write to memory is committed when the slave first asserts $s\\_{\\mathrm{bvalid}}(t) = 1$.\n- The slave must assert $s\\_{\\mathrm{arready}}(t) = 1$ when it can accept a new read address, provided no write is active or pending.\n- Once AR handshake has occurred, the slave shall assert $s\\_{\\mathrm{rvalid}}(t)$ starting at the next cycle and keep it asserted until a handshake occurs with $m\\_{\\mathrm{rready}}(t) = 1$. The response payload $s\\_{\\mathrm{rdata}}(t)$ must remain stable while $s\\_{\\mathrm{rvalid}}(t) = 1$ and the handshake has not occurred.\n\nViolation detection:\n- The program must count a violation when any master payload on AW, W, or AR changes value while the corresponding $m\\_{\\mathrm{valid}}(t) = 1$ and handshake has not yet occurred.\n- The program may also count a violation if a valid signal is deasserted ($0$) before handshake while previously asserted ($1$), but the provided test suite avoids this case except where explicitly implied.\n\nOutputs:\n- For each test case, output a list $[w, r, v, c]$ where:\n  - $w$ is the integer number of completed write transactions.\n  - $r$ is the integer number of completed read transactions.\n  - $v$ is the integer count of detected stability violations.\n  - $c$ is an integer checksum equal to the sum of all final memory register values plus the sum of all delivered read data values.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each test case result enclosed in its own square-bracketed list, for example, $[[w\\_1,r\\_1,v\\_1,c\\_1],[w\\_2,r\\_2,v\\_2,c\\_2],\\dots]$.\n\nTest suite:\n- Test Case $1$ ($T = 10$ cycles). Signals per cycle $t = 0,\\dots,9$:\n  - $m\\_{\\mathrm{awvalid}}$: $[0,1,0,0,0,0,0,0,0,0]$\n  - $m\\_{\\mathrm{awaddr}}$: $[0,0,0,0,0,0,0,0,0,0]$ with the only meaningful address at $t=1$ equal to $0$.\n  - $m\\_{\\mathrm{wvalid}}$: $[0,1,0,0,0,0,0,0,0,0]$\n  - $m\\_{\\mathrm{wdata}}$: $[0,42,0,0,0,0,0,0,0,0]$\n  - $m\\_{\\mathrm{bready}}$: $[0,0,1,0,0,0,0,0,0,0]$\n  - $m\\_{\\mathrm{arvalid}}$: $[0,0,0,1,0,0,0,0,0,0]$\n  - $m\\_{\\mathrm{araddr}}$: $[0,0,0,0,0,0,0,0,0,0]$ with the only meaningful address at $t=3$ equal to $0$.\n  - $m\\_{\\mathrm{rready}}$: $[0,0,0,0,1,0,0,0,0,0]$\n- Test Case $2$ ($T = 14$ cycles). Signals per cycle $t = 0,\\dots,13$:\n  - $m\\_{\\mathrm{awvalid}}$: $[0,1,0,0,0,0,0,0,0,0,0,0,0,0]$\n  - $m\\_{\\mathrm{awaddr}}$: $[0,8,0,0,0,0,0,0,0,0,0,0,0,0]$\n  - $m\\_{\\mathrm{wvalid}}$: $[0,0,0,0,1,0,0,0,0,0,0,0,0,0]$\n  - $m\\_{\\mathrm{wdata}}$: $[0,0,0,0,99,0,0,0,0,0,0,0,0,0]$\n  - $m\\_{\\mathrm{bready}}$: $[0,0,0,0,0,0,0,0,1,0,0,0,0,0]$\n  - $m\\_{\\mathrm{arvalid}}$: $[0,0,0,0,0,0,0,0,0,1,0,0,0,0]$\n  - $m\\_{\\mathrm{araddr}}$: $[0,0,0,0,0,0,0,0,0,8,0,0,0,0]$\n  - $m\\_{\\mathrm{rready}}$: $[0,0,0,0,0,0,0,0,0,0,0,0,1,0]$\n- Test Case $3$ ($T = 10$ cycles). Signals per cycle $t = 0,\\dots,9$:\n  - $m\\_{\\mathrm{awvalid}}$: $[0,0,0,0,0,0,0,0,0,0]$\n  - $m\\_{\\mathrm{awaddr}}$: $[0,0,0,0,0,0,0,0,0,0]$\n  - $m\\_{\\mathrm{wvalid}}$: $[0,0,0,0,0,0,0,0,0,0]$\n  - $m\\_{\\mathrm{wdata}}$: $[0,0,0,0,0,0,0,0,0,0]$\n  - $m\\_{\\mathrm{bready}}$: $[1,1,1,1,1,1,1,1,1,1]$\n  - $m\\_{\\mathrm{arvalid}}$: $[0,0,0,0,0,1,0,0,0,0]$\n  - $m\\_{\\mathrm{araddr}}$: $[0,0,0,0,0,12,0,0,0,0]$\n  - $m\\_{\\mathrm{rready}}$: $[1,1,1,1,1,1,1,1,1,1]$\n- Test Case $4$ ($T = 12$ cycles). Signals per cycle $t = 0,\\dots,11$:\n  - $m\\_{\\mathrm{awvalid}}$: $[1,0,0,0,0,0,0,0,0,0,0,0]$\n  - $m\\_{\\mathrm{awaddr}}$: $[0,0,0,0,0,0,0,0,0,0,0,0]$\n  - $m\\_{\\mathrm{wvalid}}$: $[0,0,1,0,0,0,0,0,0,0,0,0]$\n  - $m\\_{\\mathrm{wdata}}$: $[0,0,7,0,0,0,0,0,0,0,0,0]$\n  - $m\\_{\\mathrm{bready}}$: $[0,0,0,0,1,0,0,0,0,0,0,0]$\n  - $m\\_{\\mathrm{arvalid}}$: $[0,1,1,1,1,1,0,0,0,0,0,0]$\n  - $m\\_{\\mathrm{araddr}}$: $[0,0,4,4,4,4,0,0,0,0,0,0]$\n  - $m\\_{\\mathrm{rready}}$: $[0,0,0,0,0,0,1,0,0,0,0,0]$\n\nFinal output format:\n- Your program should produce a single line of output containing a nested list of the per-test-case results in the format $[[w\\_1,r\\_1,v\\_1,c\\_1],[w\\_2,r\\_2,v\\_2,c\\_2],[w\\_3,r\\_3,v\\_3,c\\_3],[w\\_4,r\\_4,v\\_4,c\\_4]]$.",
            "solution": "The solution is a cycle-accurate RTL simulation of the AXI-Lite slave. The core of the slave is a Finite State Machine (FSM) that controls the protocol flow. The simulation proceeds in discrete time steps, or clock cycles, $t$.\n\n#### FSM State Definition\nTo correctly manage the AXI-Lite protocol ordering and the single-outstanding-transaction constraint, the FSM is designed with the following states:\n-   `S_IDLE`: The initial state. No transaction is active. The slave is ready to accept a new write address (AW channel), new write data (W channel), or a new read address (AR channel). Thus, $s\\_{\\mathrm{awready}}$, $s\\_{\\mathrm{wready}}$, and $s\\_{\\mathrm{arready}}$ are asserted.\n-   `S_GOT_AW`: The slave has accepted a write address (AW handshake occurred) and is now waiting for the corresponding write data (W channel). It asserts $s\\_{\\mathrm{wready}}=1$ but deasserts ready signals for any new transaction.\n-   `S_GOT_W`: The slave has accepted write data (W handshake occurred) and is now waiting for the write address (AW channel). It asserts $s\\_{\\mathrm{awready}}=1$. This state handles cases where write data arrives before the address.\n-   `S_WRITE_RESP`: Both AW and W handshakes for a write transaction have occurred. The slave commits the write to its internal register file upon entering this state. It asserts $s\\_{\\mathrm{bvalid}}=1$ and waits for the master to accept the response ($m\\_{\\mathrm{bready}}=1$).\n-   `S_READ_RESP`: The slave has accepted a read address (AR handshake occurred). Upon entering this state, it fetches the data from the specified register. It asserts $s\\_{\\mathrm{rvalid}}=1$ and drives the fetched data on $s\\_{\\mathrm{rdata}}$, waiting for the master to accept it ($m\\_{\\mathrm{rready}}=1$).\n\n#### Simulation Loop\nThe simulation progresses cycle by cycle. For each cycle $t$, the following actions are performed in an order that mimics synchronous digital logic:\n1.  **State-Entry Actions**: At the beginning of a cycle, actions triggered by a state transition from the previous cycle are executed. Specifically, upon entering `S_WRITE_RESP`, the write operation is committed to the internal register array. Upon entering `S_READ_RESP`, the read data is fetched.\n2.  **Combinational Logic**: The slave's output signals for the current cycle $t$ ($s\\_{\\mathrm{awready}}$, $s\\_{\\mathrm{wready}}$, etc.) are determined based on the FSM's current state (`fsm_state(t)`).\n3.  **Handshake Calculation**: The handshake signals ($h\\_{\\mathrm{aw}}(t)$, $h\\_{\\mathrm{w}}(t)$, etc.) are calculated as the logical AND of the master's valid signal and the slave's ready signal for each channel.\n4.  **Violation Detection**: The master's payload stability is checked. A violation is counted if a payload on the AW, W, or AR channel changes from its value in cycle $t-1$ to $t$, given that the respective valid signal was asserted in both cycles and no handshake occurred at $t-1$.\n5.  **Sequential Logic (Next-State Calculation)**: The FSM's state for the next cycle, `fsm_state(t+1)`, is determined based on the current state `fsm_state(t)` and the handshake signals computed at $t$. Internal slave registers (e.g., for staging address and data) are also updated based on handshakes.\n6.  **Clock Edge**: All state elements (the FSM state, staged data values, and registers for violation checking) are updated to their newly computed \"next-state\" values, preparing for cycle $t+1$.\n\n#### Checksum Calculation\nThe final checksum $c$ is computed as specified: it is the sum of all data values delivered during completed read transactions plus the sum of the final values in all four memory-mapped registers after the simulation concludes.\n\nThis principled, state-based design ensures that the simulation correctly models the behavior of a synchronous digital circuit and adheres to all protocol rules specified in the problem.",
            "answer": "```c\n#include stdio.h\n#include stdlib.h\n#include string.h\n#include math.h\n\n// Define constants for clarity\n#define NUM_REGS 4\n#define MAX_CYCLES 14\n\n// FSM states for the AXI-Lite slave\ntypedef enum {\n    S_IDLE,\n    S_GOT_AW,\n    S_GOT_W,\n    S_WRITE_RESP,\n    S_READ_RESP\n} FsmState;\n\n// Structure for the master's input signals for a single test case\ntypedef struct {\n    int T; // Total simulation cycles\n    int m_awvalid[MAX_CYCLES];\n    unsigned int m_awaddr[MAX_CYCLES];\n    int m_wvalid[MAX_CYCLES];\n    unsigned int m_wdata[MAX_CYCLES];\n    int m_bready[MAX_CYCLES];\n    int m_arvalid[MAX_CYCLES];\n    unsigned int m_araddr[MAX_CYCLES];\n    int m_rready[MAX_CYCLES];\n} TestCase;\n\n// Function to run the simulation for a single test case\nvoid run_simulation(const TestCase* tc, long long int* result) {\n    // Slave's internal state\n    FsmState fsm_state = S_IDLE;\n    unsigned int regs[NUM_REGS] = {0};\n    unsigned int staged_awaddr = 0;\n    unsigned int staged_wdata = 0;\n    unsigned int staged_araddr = 0;\n    unsigned int read_data_out = 0;\n\n    // Output metric counters\n    long long int writes = 0;\n    long long int reads = 0;\n    long long int violations = 0;\n    long long int checksum = 0;\n\n    // Previous cycle state for violation checking and state-entry actions\n    FsmState fsm_state_prev = S_IDLE;\n    int m_awvalid_prev = 0, s_awready_prev = 0;\n    unsigned int m_awaddr_prev = 0;\n    int m_wvalid_prev = 0, s_wready_prev = 0;\n    unsigned int m_wdata_prev = 0;\n    int m_arvalid_prev = 0, s_arready_prev = 0;\n    unsigned int m_araddr_prev = 0;\n\n    for (int t = 0; t  tc-T; ++t) {\n        // --- STATE-ENTRY ACTIONS (based on transition from t-1 to t) ---\n        // Commit write to memory upon entering WRITE_RESP state\n        if (fsm_state == S_WRITE_RESP  fsm_state_prev != S_WRITE_RESP) {\n            if (staged_awaddr / 4  NUM_REGS) {\n                regs[staged_awaddr / 4] = staged_wdata;\n            }\n        }\n        // Fetch read data upon entering READ_RESP state\n        if (fsm_state == S_READ_RESP  fsm_state_prev != S_READ_RESP) {\n            if (staged_araddr / 4  NUM_REGS) {\n                read_data_out = regs[staged_araddr / 4];\n            } else {\n                read_data_out = 0; // Read from invalid address returns 0\n            }\n        }\n\n        // --- COMBINATIONAL LOGIC (outputs at time t) ---\n        int s_awready = (fsm_state == S_IDLE || fsm_state == S_GOT_W);\n        int s_wready = (fsm_state == S_IDLE || fsm_state == S_GOT_AW);\n        int s_arready = (fsm_state == S_IDLE);\n        int s_bvalid = (fsm_state == S_WRITE_RESP);\n        int s_rvalid = (fsm_state == S_READ_RESP);\n        unsigned int s_rdata = (fsm_state == S_READ_RESP) ? read_data_out : 0;\n        \n        // --- HANDSHAKES (at time t) ---\n        int h_aw = tc-m_awvalid[t]  s_awready;\n        int h_w = tc-m_wvalid[t]  s_wready;\n        int h_b = s_bvalid  tc-m_bready[t];\n        int h_ar = tc-m_arvalid[t]  s_arready;\n        int h_r = s_rvalid  tc-m_rready[t];\n\n        // --- VIOLATION DETECTION (at time t) ---\n        // AXI payload stability check\n        int aw_handshake_prev = m_awvalid_prev  s_awready_prev;\n        if (tc-m_awvalid[t]  m_awvalid_prev  !aw_handshake_prev  (tc-m_awaddr[t] != m_awaddr_prev)) {\n            violations++;\n        }\n        int w_handshake_prev = m_wvalid_prev  s_wready_prev;\n        if (tc-m_wvalid[t]  m_wvalid_prev  !w_handshake_prev  (tc-m_wdata[t] != m_wdata_prev)) {\n            violations++;\n        }\n        int ar_handshake_prev = m_arvalid_prev  s_arready_prev;\n        if (tc-m_arvalid[t]  m_arvalid_prev  !ar_handshake_prev  (tc-m_araddr[t] != m_araddr_prev)) {\n            violations++;\n        }\n\n        // --- SEQUENTIAL LOGIC (next state calculation for t+1) ---\n        FsmState next_fsm_state = fsm_state;\n        switch (fsm_state) {\n            case S_IDLE:\n                if (h_ar) { next_fsm_state = S_READ_RESP; }\n                else if (h_aw  h_w) { next_fsm_state = S_WRITE_RESP; }\n                else if (h_aw) { next_fsm_state = S_GOT_AW; }\n                else if (h_w) { next_fsm_state = S_GOT_W; }\n                break;\n            case S_GOT_AW:\n                if (h_w) { next_fsm_state = S_WRITE_RESP; }\n                break;\n            case S_GOT_W:\n                if (h_aw) { next_fsm_state = S_WRITE_RESP; }\n                break;\n            case S_WRITE_RESP:\n                if (h_b) { next_fsm_state = S_IDLE; }\n                break;\n            case S_READ_RESP:\n                if (h_r) { next_fsm_state = S_IDLE; }\n                break;\n        }\n\n        if (h_aw) { staged_awaddr = tc-m_awaddr[t]; }\n        if (h_w) { staged_wdata = tc-m_wdata[t]; }\n        if (h_ar) { staged_araddr = tc-m_araddr[t]; }\n\n        if (h_b) { writes++; }\n        if (h_r) { reads++; checksum += s_rdata; }\n        \n        // --- CLOCK EDGE (update state for next cycle) ---\n        fsm_state_prev = fsm_state;\n        fsm_state = next_fsm_state;\n        \n        m_awvalid_prev = tc-m_awvalid[t]; m_awaddr_prev = tc-m_awaddr[t]; s_awready_prev = s_awready;\n        m_wvalid_prev = tc-m_wvalid[t]; m_wdata_prev = tc-m_wdata[t]; s_wready_prev = s_wready;\n        m_arvalid_prev = tc-m_arvalid[t]; m_araddr_prev = tc-m_araddr[t]; s_arready_prev = s_arready;\n    }\n\n    // --- FINAL CHECKSUM CALCULATION ---\n    for (int i = 0; i  NUM_REGS; ++i) {\n        checksum += regs[i];\n    }\n    \n    result[0] = writes;\n    result[1] = reads;\n    result[2] = violations;\n    result[3] = checksum;\n}\n\n\nint main(void) {\n    TestCase test_cases[] = {\n        {\n            .T = 10,\n            .m_awvalid = {[1]=1}, .m_awaddr = {[1]=0},\n            .m_wvalid = {[1]=1}, .m_wdata = {[1]=42},\n            .m_bready = {[2]=1},\n            .m_arvalid = {[3]=1}, .m_araddr = {[3]=0},\n            .m_rready = {[4]=1},\n        },\n        {\n            .T = 14,\n            .m_awvalid = {[1]=1}, .m_awaddr = {[1]=8},\n            .m_wvalid = {[4]=1}, .m_wdata = {[4]=99},\n            .m_bready = {[8]=1},\n            .m_arvalid = {[9]=1}, .m_araddr = {[9]=8},\n            .m_rready = {[12]=1},\n        },\n        {\n            .T = 10,\n            .m_awvalid = {0}, .m_awaddr = {0},\n            .m_wvalid = {0}, .m_wdata = {0},\n            .m_bready = {1,1,1,1,1,1,1,1,1,1},\n            .m_arvalid = {[5]=1}, .m_araddr = {[5]=12},\n            .m_rready = {1,1,1,1,1,1,1,1,1,1},\n        },\n        {\n            .T = 12,\n            .m_awvalid = {[0]=1}, .m_awaddr = {[0]=0},\n            .m_wvalid = {[2]=1}, .m_wdata = {[2]=7},\n            .m_bready = {[4]=1},\n            .m_arvalid = {[1]=1,[2]=1,[3]=1,[4]=1,[5]=1},\n            .m_araddr = {[2]=4,[3]=4,[4]=4,[5]=4},\n            .m_rready = {[6]=1},\n        },\n    };\n\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    long long int results[num_cases][4];\n\n    for (int i = 0; i  num_cases; ++i) {\n        run_simulation(test_cases[i], results[i]);\n    }\n\n    printf(\"[\");\n    for (int i = 0; i  num_cases; ++i) {\n        printf(\"[%lld,%lld,%lld,%lld]\", results[i][0], results[i][1], results[i][2], results[i][3]);\n        if (i  num_cases - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\");\n\n    return EXIT_SUCCESS;\n}\n```"
        },
        {
            "introduction": "This final practice integrates data path and control logic into a more complex subsystem, challenging you to model a shared, pipelined computational resource. You will simulate a system where two instruction streams compete for a single multiplier, managed by operand latches and a round-robin scheduler. This exercise  deepens your understanding of RTL by requiring you to model the precise, ordered sequence of events within a single clock cycle and measure overall system performance through metrics like makespan.",
            "id": "3672626",
            "problem": "You are to implement a cycle-accurate Register-Transfer Level (RTL) simulator of a shared, pipelined multiplier with operand latches and round-robin scheduling across two independent instruction streams. The model must begin from the foundational definition of a synchronous digital system: at discrete clock cycles, all registers (state) update on the active clock edge, and combinational logic may be treated as instantaneous between edges. You must faithfully model the following three-stage per-cycle sequencing in the given order, which is the canonical abstraction of synchronous RTL behavior:\n\n- Completion stage: at clock cycle $c$, any result previously issued to the multiplier whose completion time equals $c$ becomes available and is committed.\n- Issue stage: at clock cycle $c$, the scheduler may issue at most one latched operation to the multiplier input if any latch is full.\n- Latch stage: at clock cycle $c$, each stream may capture its next ready operation into its operand latch if the latch is empty and the operation’s operands are ready by time $c$.\n\nSystem components and rules:\n\n- Two independent instruction streams, indexed by $s \\in \\{0,1\\}$. Stream $s$ contains a finite sequence of multiply operations. Operation $k$ in stream $s$ has an operand-ready time $r_{s,k}$ (a nonnegative integer clock cycle) and integer operands $a_{s,k}$ and $b_{s,k}$. The operation computes the product $y_{s,k} = a_{s,k} \\times b_{s,k}$.\n- Each stream $s$ has a single-entry operand latch. When empty, and if the next operation’s operands are ready at cycle $c$ (i.e., $r_{s,k} \\le c$), the latch captures that operation during the latch stage. While full, it cannot capture another operation.\n- There is exactly one pipelined multiplier resource with fixed latency $L \\ge 1$ cycles and initiation interval $1$ operation per cycle. An issued operation at cycle $c$ completes at cycle $c + L$.\n- Scheduling control is round-robin with a mutable preference bit $p \\in \\{0,1\\}$ indicating which stream has priority when both latches are full. In the issue stage at cycle $c$:\n    - If neither latch is full, no issue occurs.\n    - If exactly one latch is full, that operation is issued.\n    - If both latches are full, the operation from stream $p$ is issued.\n  If an issue occurs, the chosen latch becomes empty immediately and the preference bit toggles, i.e., $p \\leftarrow 1 - p$. If no issue occurs, $p$ is unchanged.\n- Cycle semantics: At each cycle $c \\in \\mathbb{Z}_{\\ge 0}$, apply the completion stage, then the issue stage, then the latch stage, then advance to $c+1$. Terminate when all operations from both streams have completed. If a stream has no operations, its “last completion cycle” is defined to be $-1$. If no operations exist at all, the overall makespan is defined to be $-1$.\n\nYour program must:\n\n- Implement the above RTL semantics exactly, starting from $c = 0$, with the multiplier latency $L$ and initial preference $p(0)$ specified by each test case.\n- For each test case, produce:\n    1. The makespan $M$, defined as $\\max$ completion cycle over all operations, or $-1$ if there are no operations.\n    2. The last completion cycle for stream $0$, denoted $C_0$, or $-1$ if stream $0$ has no operations.\n    3. The last completion cycle for stream $1$, denoted $C_1$, or $-1$ if stream $1$ has no operations.\n    4. The time-ordered list of multiplier results $[y_{i}]$ in strictly increasing completion-time order. Because $L \\ge 1$ and the initiation interval is $1$, at most one result completes per cycle, so the list order is unambiguous.\n\nFundamental base to use:\n\n- Synchronous RTL state evolution: all state changes occur on clock edges in a well-defined order. Treat the three stages (completion, issue, latch) as ordered combinational computations whose effects are captured by registers at the end of the cycle.\n- Resource constraint: the multiplier accepts at most one operation per cycle and produces the result after $L$ cycles.\n- Arbitration policy: round-robin with a preference bit that toggles only on successful issue.\n\nTest suite to implement and run in your program (these are the only inputs; no user input is allowed):\n\n- Test case $1$ (happy path, interleaved readiness):\n    - Latency $L = 3$, initial preference $p(0) = 0$.\n    - Stream $0$: readiness times $\\langle 0, 1, 4 \\rangle$, operands $\\langle (2, 3), (5, 7), (2, 11) \\rangle$.\n    - Stream $1$: readiness times $\\langle 0, 2, 4 \\rangle$, operands $\\langle (4, 4), (9, 1), (3, 3) \\rangle$.\n- Test case $2$ (heavy contention, simultaneous readiness, different initial preference):\n    - Latency $L = 2$, initial preference $p(0) = 1$.\n    - Stream $0$: readiness times $\\langle 0, 0, 0 \\rangle$, operands $\\langle (1, 10), (2, 10), (3, 10) \\rangle$.\n    - Stream $1$: readiness times $\\langle 0, 0 \\rangle$, operands $\\langle (4, 10), (5, 10) \\rangle$.\n- Test case $3$ (one stream empty, idle gaps):\n    - Latency $L = 4$, initial preference $p(0) = 0$.\n    - Stream $0$: no operations.\n    - Stream $1$: readiness times $\\langle 3, 9 \\rangle$, operands $\\langle (7, 7), (2, 8) \\rangle$.\n- Test case $4$ (minimum latency $L = 1$, short sequences):\n    - Latency $L = 1$, initial preference $p(0) = 0$.\n    - Stream $0$: readiness times $\\langle 0, 1 \\rangle$, operands $\\langle (6, 6), (1, 2) \\rangle$.\n    - Stream $1$: readiness times $\\langle 0 \\rangle$, operands $\\langle (3, 7) \\rangle$.\n\nOutput specification:\n\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a list of the form $[M,C_0,C_1,[y_0,y_1,\\dots]]$. For example, a line with two test cases might look like $[[M_1,C_{0,1},C_{1,1},[y^{(1)}_0,\\dots]],[M_2,C_{0,2},C_{1,2},[y^{(2)}_0,\\dots]]]$.\n- All numeric outputs must be base-$10$ integers. There are no physical units to report.\n\nYour task is to write a complete, self-contained program that implements the described RTL model and prints the single required output line for the four specified test cases. No input should be read from standard input. The program must be deterministic given the specification above.",
            "solution": "The problem requires the implementation of a cycle-accurate Register-Transfer Level (RTL) model of a digital system. The system comprises two independent instruction streams competing for a single, shared, pipelined multiplier. The simulation must adhere to the fundamental principles of synchronous digital logic, where the system state evolves at discrete clock cycle boundaries.\n\nAt its core, a synchronous RTL model consists of state-holding elements (registers) and combinational logic that computes the next state. The state of our system at the beginning of any clock cycle $c \\in \\mathbb{Z}_{\\ge 0}$ is defined by the following components:\n1.  The status of the operand latch for each stream $s \\in \\{0,1\\}$: whether it is full or empty, and its contents if full.\n2.  The set of operations currently in-flight within the multiplier pipeline, along with their scheduled completion cycles.\n3.  The index of the next operation to be considered from each instruction stream.\n4.  The current value of the round-robin preference bit, $p$.\n\nThe state transition, from cycle $c$ to cycle $c+1$, is governed by a sequence of three combinational logic stages, executed in a fixed order:\n1.  **Completion Stage**: Updates the system state based on operations finishing their execution.\n2.  **Issue Stage**: Determines which new operation, if any, enters the pipeline.\n3.  **Latch Stage**: Fetches the next ready operation from a stream into its local buffer.\n\nThe simulation algorithm proceeds by iterating through clock cycles, starting from $c=0$, and applying this three-stage sequence until all operations across both streams have been issued, processed, and their results committed.\n\nLet's formalize the state and the per-cycle logic.\n\n**System State Variables:**\n-   $c$: The current clock cycle, an integer initialized to $0$.\n-   $p$: The scheduler preference bit, $p \\in \\{0,1\\}$, initialized as per the test case.\n-   For each stream $s \\in \\{0,1\\}$:\n    -   $L_s$: A boolean-like state indicating if the latch for stream $s$ is full ($1$) or empty ($0$).\n    -   $O_s$: A tuple $(a, b)$ holding the operands of the operation in latch $s$, if $L_s=1$.\n    -   $k_s$: An integer index pointing to the next operation in the instruction sequence for stream $s$.\n-   $\\Pi$: A set of pending completions, where each element is a tuple $(t_{comp}, y, s_{orig})$ representing a result $y$ from original stream $s_{orig}$ that will complete at cycle $t_{comp}$.\n\n**Simulation Algorithm:**\nThe simulation terminates when the total count of completed operations equals the total number of initial operations.\n\n**Initialization:**\n1.  Set $c \\leftarrow 0$.\n2.  Initialize $p$ to its starting value from the test case.\n3.  For each stream $s \\in \\{0,1\\}$: initialize $L_s \\leftarrow 0$ and $k_s \\leftarrow 0$.\n4.  Initialize the set of pending completions $\\Pi \\leftarrow \\emptyset$.\n5.  Initialize result metrics: makespan $M \\leftarrow -1$, last completion cycles $C_0 \\leftarrow -1$ and $C_1 \\leftarrow -1$.\n6.  Initialize an ordered list for final results, $Y \\leftarrow []$.\n7.  Handle the edge case: if both streams are empty, set $M$, $C_0$, $C_1$ to $-1$ and terminate.\n\n**Main Simulation Loop (while not all operations are complete):**\n\nAt the beginning of each cycle $c$, the following actions are performed in strict sequence:\n\n**1. Completion Stage:**\nThe logic checks for any operation whose execution is finishing in the current cycle.\n-   Iterate through all pending completions $(t_{comp}, y, s_{orig}) \\in \\Pi$.\n-   If $t_{comp} = c$:\n    -   The result $y$ is now available. Append $y$ to the global, time-ordered results list $Y$.\n    -   Update the last completion cycle for the originating stream: $C_{s_{orig}} \\leftarrow c$.\n    -   Increment the count of completed operations for stream $s_{orig}$.\n    -   Remove $(t_{comp}, y, s_{orig})$ from the set $\\Pi$.\n    -   Since the multiplier initiation interval is $1$, at most one operation can complete per cycle.\n\n**2. Issue Stage:**\nThe scheduler decides whether to issue an operation from a full latch into the multiplier pipeline.\n-   Let $L_0$ and $L_1$ be the latch-full status for streams $0$ and $1$, respectively.\n-   An issue is possible only if $L_0=1$ or $L_1=1$.\n-   Determine the stream to issue from, $s_{issue}$:\n    -   If $L_0=1$ and $L_1=0$, then $s_{issue} \\leftarrow 0$.\n    -   If $L_0=0$ and $L_1=1$, then $s_{issue} \\leftarrow 1$.\n    -   If $L_0=1$ and $L_1=1$, then $s_{issue} \\leftarrow p$.\n    -   Otherwise, no issue occurs.\n-   If an issue occurs for stream $s_{issue}$:\n    -   Let the latched operation be $O_{s_{issue}} = (a, b)$.\n    -   The result is $y = a \\times b$.\n    -   The completion time is $t_{comp} = c + L$, where $L$ is the multiplier latency.\n    -   Add the new pending completion $(t_{comp}, y, s_{issue})$ to the set $\\Pi$.\n    -   The latch for the issued stream is now free: $L_{s_{issue}} \\leftarrow 0$.\n    -   The preference bit is toggled: $p \\leftarrow 1 - p$.\n-   If no issue occurs, $p$ remains unchanged.\n\n**3. Latch Stage:**\nEach stream attempts to load its next available operation into its operand latch, provided the latch is empty. This stage is evaluated independently for each stream.\n-   For each stream $s \\in \\{0,1\\}$:\n    -   Check if the latch is empty: $L_s = 0$.\n    -   Check if the stream has more operations: $k_s$ is less than the total number of operations for stream $s$.\n    -   Let the next operation be the $k_s$-th one, with ready time $r_{s,k_s}$ and operands $(a_{s,k_s}, b_{s,k_s})$.\n    -   Check if the operation is ready: $r_{s,k_s} \\le c$.\n    -   If all three conditions are met (latch empty, more ops, op ready):\n        -   Load the operation into the latch: $O_s \\leftarrow (a_{s,k_s}, b_{s,k_s})$.\n        -   Mark the latch as full: $L_s \\leftarrow 1$.\n        -   Advance the stream's operation pointer: $k_s \\leftarrow k_s + 1$.\n\nAfter all three stages are complete, the clock cycle advances: $c \\leftarrow c+1$. The loop continues until the total number of completed operations matches the total number of operations from both streams.\n\n**Finalization:**\nOnce the simulation loop terminates, the makespan $M$ is calculated as $\\max(C_0, C_1)$. The collected values $M$, $C_0$, $C_1$, and the ordered list of results $Y$ constitute the output for the test case. This entire process is repeated for each test case defined in the problem.",
            "answer": "```c\n#include stdio.h\n#include stdlib.h\n#include string.h\n#include math.h\n\n// Note: Per problem spec, bool is not available from stdbool.h.\n// Using int as a boolean (0 for false, 1 for true).\n\ntypedef struct {\n    int ready_time;\n    long long a;\n    long long b;\n} Operation;\n\ntypedef struct {\n    const Operation* ops;\n    size_t num_ops;\n} StreamData;\n\ntypedef struct {\n    int latency;\n    int initial_p;\n    StreamData s0_data;\n    StreamData s1_data;\n} TestCase;\n\ntypedef struct {\n    int completion_cycle;\n    long long result;\n    int original_stream_idx;\n} PendingCompletion;\n\ntypedef struct {\n    long long makespan;\n    long long c0;\n    long long c1;\n    long long* results_y;\n    size_t num_y;\n} TestResult;\n\n// Function to run a single simulation\nTestResult run_simulation(const TestCase* tc) {\n    long long total_ops = tc-s0_data.num_ops + tc-s1_data.num_ops;\n    TestResult res = {-1, -1, -1, NULL, 0};\n\n    if (total_ops == 0) {\n        if (tc-s0_data.num_ops == 0) res.c0 = -1;\n        if (tc-s1_data.num_ops == 0) res.c1 = -1;\n        res.makespan = -1;\n        return res;\n    }\n\n    // State Variables\n    int current_cycle = 0;\n    int preference_bit = tc-initial_p;\n\n    // Stream-specific state\n    int latch_full[2] = {0, 0};\n    Operation latch_op[2];\n    size_t next_op_idx[2] = {0, 0};\n    long long ops_completed_count[2] = {0, 0};\n    \n    // Pipeline modeling\n    PendingCompletion* pipeline = NULL;\n    size_t pipeline_size = 0;\n    size_t pipeline_capacity = 0;\n    \n    long long total_completed_ops = 0;\n\n    res.c0 = (tc-s0_data.num_ops  0) ? -2 : -1; // Use -2 to distinguish \"not yet completed\" from \"no ops\"\n    res.c1 = (tc-s1_data.num_ops  0) ? -2 : -1;\n\n    while (total_completed_ops  total_ops) {\n        // 1. Completion Stage\n        size_t write_idx = 0;\n        for (size_t i = 0; i  pipeline_size; ++i) {\n            if (pipeline[i].completion_cycle == current_cycle) {\n                // Operation completes\n                total_completed_ops++;\n                ops_completed_count[pipeline[i].original_stream_idx]++;\n                if (pipeline[i].original_stream_idx == 0) {\n                    res.c0 = current_cycle;\n                } else {\n                    res.c1 = current_cycle;\n                }\n\n                // Add to results\n                res.results_y = realloc(res.results_y, (res.num_y + 1) * sizeof(long long));\n                res.results_y[res.num_y++] = pipeline[i].result;\n            } else {\n                // Keep this pending completion\n                if (write_idx != i) {\n                    pipeline[write_idx] = pipeline[i];\n                }\n                write_idx++;\n            }\n        }\n        pipeline_size = write_idx;\n\n        // 2. Issue Stage\n        int s_issue = -1;\n        if (latch_full[0]  !latch_full[1]) {\n            s_issue = 0;\n        } else if (!latch_full[0]  latch_full[1]) {\n            s_issue = 1;\n        } else if (latch_full[0]  latch_full[1]) {\n            s_issue = preference_bit;\n        }\n        \n        if (s_issue != -1) {\n            if (pipeline_size == pipeline_capacity) {\n                pipeline_capacity = (pipeline_capacity == 0) ? 4 : pipeline_capacity * 2;\n                pipeline = realloc(pipeline, pipeline_capacity * sizeof(PendingCompletion));\n            }\n            pipeline[pipeline_size].completion_cycle = current_cycle + tc-latency;\n            pipeline[pipeline_size].result = latch_op[s_issue].a * latch_op[s_issue].b;\n            pipeline[pipeline_size].original_stream_idx = s_issue;\n            pipeline_size++;\n            \n            latch_full[s_issue] = 0;\n            preference_bit = 1 - preference_bit;\n        }\n\n        // 3. Latch Stage\n        for (int s = 0; s  2; ++s) {\n            const StreamData* current_stream_data = (s == 0) ? tc-s0_data : tc-s1_data;\n            if (!latch_full[s]  next_op_idx[s]  current_stream_data-num_ops) {\n                if (current_stream_data-ops[next_op_idx[s]].ready_time = current_cycle) {\n                    latch_op[s] = current_stream_data-ops[next_op_idx[s]];\n                    latch_full[s] = 1;\n                    next_op_idx[s]++;\n                }\n            }\n        }\n\n        current_cycle++;\n    }\n\n    if (res.c0 == -2) res.c0 = -1; // Correct for streams that had ops but none completed (impossible here but good practice)\n    if (res.c1 == -2) res.c1 = -1;\n\n    res.makespan = (res.c0  res.c1) ? res.c0 : res.c1;\n    if (total_ops == 0) res.makespan = -1;\n    \n    free(pipeline);\n    return res;\n}\n\nint main(void) {\n    // Test Case 1 Data\n    const Operation tc1_s0_ops[] = {{0, 2, 3}, {1, 5, 7}, {4, 2, 11}};\n    const Operation tc1_s1_ops[] = {{0, 4, 4}, {2, 9, 1}, {4, 3, 3}};\n    \n    // Test Case 2 Data\n    const Operation tc2_s0_ops[] = {{0, 1, 10}, {0, 2, 10}, {0, 3, 10}};\n    const Operation tc2_s1_ops[] = {{0, 4, 10}, {0, 5, 10}};\n\n    // Test Case 3 Data\n    const Operation tc3_s1_ops[] = {{3, 7, 7}, {9, 2, 8}};\n    \n    // Test Case 4 Data\n    const Operation tc4_s0_ops[] = {{0, 6, 6}, {1, 1, 2}};\n    const Operation tc4_s1_ops[] = {{0, 3, 7}};\n\n    TestCase test_cases[] = {\n        {3, 0, {tc1_s0_ops, 3}, {tc1_s1_ops, 3}},\n        {2, 1, {tc2_s0_ops, 3}, {tc2_s1_ops, 2}},\n        {4, 0, {NULL, 0},       {tc3_s1_ops, 2}},\n        {1, 0, {tc4_s0_ops, 2}, {tc4_s1_ops, 1}}\n    };\n\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    TestResult all_results[num_cases];\n\n    for (int i = 0; i  num_cases; ++i) {\n        all_results[i] = run_simulation(test_cases[i]);\n    }\n\n    printf(\"[\");\n    for (int i = 0; i  num_cases; ++i) {\n        printf(\"[%lld,%lld,%lld,[\", all_results[i].makespan, all_results[i].c0, all_results[i].c1);\n        for (size_t j = 0; j  all_results[i].num_y; ++j) {\n            printf(\"%lld\", all_results[i].results_y[j]);\n            if (j  all_results[i].num_y - 1) {\n                printf(\",\");\n            }\n        }\n        printf(\"]]\");\n        if (i  num_cases - 1) {\n            printf(\",\");\n        }\n        free(all_results[i].results_y);\n    }\n    printf(\"]\");\n    printf(\"\\n\");\n\n    return EXIT_SUCCESS;\n}\n```"
        }
    ]
}