{
    "hands_on_practices": [
        {
            "introduction": "本练习将聚焦于总线仲裁器的设计，这是任何包含共享资源的系统中的基本组件。你将实现并比较两种经典的仲裁策略——固定优先级和轮询——来理解它们对系统性能和公平性的深远影响。这项练习对于培养控制逻辑如何决定资源分配，以及如何可能导致“饥饿”等现象的直觉至关重要()。",
            "id": "3672585",
            "problem": "设计并实现一个在寄存器传输级 (RTL) 语义层面上的周期级精确仿真，该仿真模拟一个为 $M$ 个请求者服务的共享总线仲裁器，并采用两种仲裁策略：轮询和固定优先级。该仲裁器与单一全局时钟同步运行。在每个时钟周期 $t \\in \\{0,1,2,\\dots,T-1\\}$，每个请求者 $i \\in \\{0,1,\\dots,M-1\\}$ 都会提供一个二进制请求信号 $r_i[t] \\in \\{0,1\\}$。仲裁器会生成一个独热 (one-hot) 授权向量 $g[t] = (g_0[t],g_1[t],\\dots,g_{M-1}[t])$，其中对于每个周期 $t$，满足 $g_i[t] \\in \\{0,1\\}$ 且 $\\sum_{i=0}^{M-1} g_i[t] \\le 1$。如果在一个周期内没有请求被断言，则 $\\sum_{i=0}^{M-1} g_i[t] = 0$。\n\n该系统遵循同步 RTL 语义：组合逻辑根据时间 $t$ 的 $r[t]$ 和任何架构寄存器状态导出 $g[t]$，而时序寄存器在时钟有效沿更新，为时间 $t+1$ 生成状态。\n\n必须对两种仲裁策略进行建模：\n\n- 固定优先级 (FP)：假设存在一个静态的严格优先级顺序，其中较小的索引意味着较高的优先级。给定 $r[t]$，FP 仲裁器选择满足 $r_i[t]=1$ 的最小索引 $i$，并设置 $g_i[t]=1$ 和对于所有 $j \\ne i$ 设置 $g_j[t]=0$。如果不存在这样的 $i$，则 $g[t]=\\mathbf{0}$。\n\n- 轮询 (RR)：一个指针寄存器 $p[t] \\in \\{0,1,\\dots,M-1\\}$ 编码了下一个要首先检查的请求者。给定 $r[t]$ 和 $p[t]$，RR 仲裁器按循环顺序 $p[t], p[t]+1 \\bmod M, \\dots, p[t]+M-1 \\bmod M$ 进行扫描，选择第一个满足 $r_i[t]=1$ 的索引 $i$，并设置 $g_i[t]=1$ 和对于所有 $j \\ne i$ 设置 $g_j[t]=0$。如果在时间 $t$ 至少发生了一次对索引 $i$ 的授权，则 $p[t+1] = (i+1) \\bmod M$。如果没有发生授权，则 $p[t+1] = p[t]$。初始化 $p[0]=0$。\n\n流量模型 (突发请求)：每个请求者 $i$ 会生成由三个非负整数 $(L_i,G_i,S_i)$ 表征的周期性突发，其语义如下。如果 $L_i=0$，则对于所有 $t$ 都有 $r_i[t]=0$。否则，定义周期 $P_i=L_i+G_i$。对于所有 $t \\ge 0$，\n$$\nr_i[t] = \\begin{cases}\n1,  \\text{if } t \\ge S_i \\text{ and } \\left( (t - S_i) \\bmod P_i \\right)  L_i, \\\\\n0,  \\text{otherwise}.\n\\end{cases}\n$$\n这模拟了从周期 $S_i$ 开始，长度为 $L_i$ 个周期的突发，由长度为 $G_i$ 个周期的间隙分隔。如果 $G_i=0$ 且 $L_i0$，则请求者 $i$ 在所有 $t \\ge S_i$ 的时间内持续请求。\n\n在 $T$ 个周期的范围内，需要为每个仲裁策略计算以下指标：\n\n- 每个请求者的授权计数：对于每个 $i$，$C_i = \\sum_{t=0}^{T-1} g_i[t]$。\n\n- 每个请求者的最大等待时间 (以周期为单位)：对于每个 $i$，将逐周期等待计数器 $w_i[t]$ 定义为截至并包括周期 $t$ 的当前连续周期序列的长度，在此序列中的所有 $t'$ 都满足 $r_i[t']=1$ 和 $g_i[t']=0$。每当 $r_i[t]=0$ 或 $g_i[t]=1$ 时，此计数器重置为 $0$。定义 $W_i = \\max_{t \\in \\{0,\\dots,T-1\\}} w_i[t]$。\n\n- 每个请求者的饥饿指示符：对于每个 $i$，定义 $R_i = \\sum_{t=0}^{T-1} r_i[t]$ 和 $S_i^\\star = \\begin{cases}1, \\text{if } R_i  0 \\text{ and } C_i = 0,\\\\ 0, \\text{otherwise.}\\end{cases}$\n\n汇总报告以下各项策略指标：\n\n- 饥饿请求者计数：$S^\\text{count} = \\sum_{i=0}^{M-1} S_i^\\star$。\n\n- 所有请求者中的最大等待时间：$W^\\text{max} = \\max_{i \\in \\{0,\\dots,M-1\\}} W_i$。\n\n实现一个完整的、可运行的程序，该程序针对下面的每个测试用例，使用突发请求模型对两种仲裁策略在 $T$ 个周期内进行仿真，并为每个测试用例生成以下结果：\n\n- 对于轮询：一个列表 $[\\,[C_0,\\dots,C_{M-1}],\\, W^\\text{max},\\, S^\\text{count}\\,]$。\n\n- 对于固定优先级：一个列表 $[\\,[C_0,\\dots,C_{M-1}],\\, W^\\text{max},\\, S^\\text{count}\\,]$。\n\n最终的程序输出必须是单行，包含所有测试用例的结果，格式为方括号内以逗号分隔的列表，其中每个测试用例表示为一个双元素列表 $[ \\text{RR\\_metrics}, \\text{FP\\_metrics} ]$，顺序如下所示。不应打印任何其他文本。\n\n测试套件 (三个案例)：\n\n- 案例 A (平衡的交错突发)：\n  - $M=4$, $T=24$。\n  - 请求者 $0$：$(L_0,G_0,S_0)=(3,5,0)$。\n  - 请求者 $1$：$(L_1,G_1,S_1)=(3,5,2)$。\n  - 请求者 $2$：$(L_2,G_2,S_2)=(3,5,4)$。\n  - 请求者 $3$：$(L_3,G_3,S_3)=(3,5,6)$。\n\n- 案例 B (始终开启的高优先级竞争者)：\n  - $M=3$, $T=30$。\n  - 请求者 $0$：$(L_0,G_0,S_0)=(30,0,0)$。\n  - 请求者 $1$：$(L_1,G_1,S_1)=(2,4,0)$。\n  - 请求者 $2$：$(L_2,G_2,S_2)=(2,4,2)$。\n\n- 案例 C (无请求)：\n  - $M=5$, $T=10$。\n  - 对于所有 $i \\in \\{0,1,2,3,4\\}$：$(L_i,G_i,S_i)=(0,1,0)$。\n\n您的程序应生成单行输出，其中包含按以下确切结构以逗号分隔列表形式的结果，并用方括号括起来：\n$[ [\\text{RR\\_A},\\text{FP\\_A}], [\\text{RR\\_B},\\text{FP\\_B}], [\\text{RR\\_C},\\text{FP\\_C}] ]$\n其中每个 $\\text{RR\\_X}$ 和 $\\text{FP\\_X}$ 本身都是 $[[C_0,\\dots,C_{M-1}],W^\\text{max},S^\\text{count}]$ 形式的列表。所有数值必须是整数。不需要空格；如果您包含空格，自动评分器会忽略它们，但建议省略空格。",
            "solution": "该问题要求设计并实现一个共享总线仲裁器的周期级精确寄存器传输级 (RTL) 仿真。该仿真必须在两种不同的仲裁策略下（固定优先级 (FP) 和轮询 (RR)），对一个拥有 $M$ 个请求者、时间跨度为 $T$ 个周期的系统进行建模。\n\n仿真遵循同步 RTL 语义，其中系统行为在离散的时钟周期 $t=0, 1, \\dots, T-1$ 上定义。每个周期 $t$ 的过程可以分解为两个主要阶段，这反映了物理数字电路的行为：组合逻辑的求值和时序状态的更新。\n\n首先，对组合逻辑进行求值。该逻辑产生的输出是当前周期的输入和状态的函数。\n仲裁器的主要输入是来自每个请求者 $i$ 的请求信号，表示为 $r_i[t]$。这些信号根据指定的突发流量模型生成，该模型是参数 $(L_i, G_i, S_i)$ 的函数：\n$$\nr_i[t] = \\begin{cases}\n1,  \\text{if } L_i  0, t \\ge S_i \\text{ and } \\left( (t - S_i) \\bmod (L_i+G_i) \\right)  L_i \\\\\n0,  \\text{otherwise}\n\\end{cases}\n$$\n这个公式确定性地计算每个周期 $t$ 的请求向量 $r[t] = (r_0[t], \\dots, r_{M-1}[t])$。\n\n给定请求向量 $r[t]$ 和周期开始时的任何相关状态，仲裁器的组合逻辑计算出独热 (one-hot) 授权向量 $g[t] = (g_0[t], \\dots, g_{M-1}[t])$。该逻辑取决于仲裁策略：\n\n1.  **固定优先级 (FP)**：此策略是无状态的。授权逻辑是 $r[t]$ 的纯组合函数。它通过索引对请求者进行优先级排序，较小的索引具有较高的优先级。对于满足 $r_i[t]=1$ 的最小索引 $i$，授权 $g_i[t]$ 被设为 $1$。如果没有活动的请求（$\\sum r_i[t] = 0$），则所有授权都为 $0$。\n    $$g_i[t] = \\begin{cases} 1,  \\text{if } r_i[t]=1 \\text{ and } r_j[t]=0 \\text{ for all } j  i \\\\ 0,  \\text{otherwise} \\end{cases}$$\n\n2.  **轮询 (RR)**：此策略需要架构状态，具体来说是一个指针寄存器 $p[t]$，用于存储要首先检查的请求者的索引。授权逻辑是 $r[t]$ 和 $p[t]$ 的组合函数。仲裁器从索引 $p[t]$ 开始搜索活动请求，并循环回绕。找到的第一个活动请求者（假设为 $k$）获得授权（$g_k[t]=1$）。\n    搜索序列为 $p[t], (p[t]+1)\\bmod M, \\dots, (p[t]+M-1)\\bmod M$。\n\n一旦确定了该周期的授权向量 $g[t]$，就会更新所需的性能指标。这些计算可以被看作是监控逻辑。\n\n-   **授权计数 ($C_i$)**：对于每个获得授权的请求者 $i$（$g_i[t]=1$），其总授权计数 $C_i$ 会递增。$C_i = \\sum_{t=0}^{T-1} g_i[t]$。\n-   **等待时间 ($w_i[t]$ 和 $W_i$)**：每个请求者的等待计数器 $w_i[t]$ 跟踪未被服务的连续请求周期。其值根据 $r_i[t]$ 和 $g_i[t]$ 进行更新：\n    $$w_i[t] = \\begin{cases} w_i[t-1] + 1,  \\text{if } r_i[t]=1 \\text{ and } g_i[t]=0 \\\\ 0,  \\text{if } r_i[t]=0 \\text{ or } g_i[t]=1 \\end{cases}$$\n    初始条件为 $w_i[-1]=0$。请求者 $i$ 的最大等待时间 $W_i$ 是 $w_i[t]$ 在仿真期间达到的最大值：$W_i = \\max_{0 \\le t  T} w_i[t]$。\n\n其次，在周期结束时（概念上，在时钟有效沿），时序状态寄存器被更新为下一周期 $t+1$ 的值。\n\n-   **对于 FP 策略**，没有状态，因此无需更新。\n-   **对于 RR 策略**，指针寄存器 $p$ 会被更新。如果在周期 $t$ 中向请求者 $k$ 发出了授权，指针会移动到下一个位置：$p[t+1] = (k+1) \\bmod M$。如果没有发出授权，指针保持不变：$p[t+1] = p[t]$。初始状态为 $p[0]=0$。\n\n整个过程对 $t$ 从 $0$ 到 $T-1$ 重复。仿真循环完成后，计算最终的聚合指标：\n-   **饥饿指示符 ($S_i^\\star$) 和计数 ($S^\\text{count}$)**：如果请求者 $i$ 至少发出了一次请求（$R_i = \\sum_{t=0}^{T-1} r_i[t]  0$）但没有收到任何授权（$C_i = 0$），则认为该请求者处于饥饿状态。总计数为 $S^\\text{count} = \\sum_{i=0}^{M-1} S_i^\\star$。\n-   **所有请求者中的最大等待时间 ($W^\\text{max}$)**：这是所有请求者最大等待时间中的最大值：$W^\\text{max} = \\max_{i=0}^{M-1} W_i$。\n\n实现将包含一个封装此逻辑的主仿真函数，该函数会为每个测试用例和两种仲裁策略中的每一种被调用。然后收集结果并以指定格式打印。",
            "answer": "```c\n#include\n```"
        },
        {
            "introduction": "这个练习从简单的控制逻辑进阶到一个执行多周期算法的单元设计：带符号的恢复型除法器。更重要的是，它通过引入时序分析，在抽象的寄存器传输级（RTL）模型和物理现实之间架起了一座桥梁。通过计算设计是否满足建立时间（setup time）和保持时间（hold time）的约束，你将学习到逻辑延迟和时钟速度之间根本性的内在联系，这是任何硬件设计师的必备关键技能()。",
            "id": "3672629",
            "problem": "设计一个完整、可运行的程序，该程序模拟一个由有限状态机（FSM）控制的寄存器传输级（RTL）有符号恢复除法单元，并在通过插入中间寄存器来分割长组合路径时执行时序可行性检查。对于每个测试用例，该程序必须计算有符号商、有符号余数、在 FSM 调度下的总周期数，以及在给定的时钟和器件参数下设计是否满足建立时间和保持时间约束。所有算术运算均采用二进制补码，并且所有时序值必须以纳秒（ns）为单位处理。\n\n使用以下基本基础和定义，并在同步数字设计的范畴内进行表达和解释：\n1. 使用字宽为 $W$ 的二进制补码表示有符号整数。\n2. 恢复除法算法使用按位迭代，该迭代由 FSM 微操作控制，通过算术右移或左移以及减法-恢复决策来更新部分余数和商。\n3. 同步时序约束由寄存器到寄存器的路径决定，其中每个寄存器都有时钟到Q端时间、建立时间和保持时间，并且寄存器之间的组合逻辑具有传播延迟。\n4. 时钟偏斜是启动寄存器和捕获寄存器时钟到达时间之间的一个确定性偏移，并被视为一个已知参数。\n\n您的程序必须实现以下建模假设和计算：\n- 有符号恢复除法的建模假设：\n  - 操作数为 $N$（被除数）和 $D$（除数），每个都限制在 $W$ 位二进制补码范围内。\n  - 检测到除以零的情况；该单元将商设置为 $0$，余数设置为 $N$，并且 FSM 中止迭代。\n  - 对于 $D \\neq 0$，FSM 对绝对值执行恢复除法，并在最后应用符号校正：商的符号为 $\\operatorname{sgn}(N)\\cdot\\operatorname{sgn}(D)$，余数的符号为 $\\operatorname{sgn}(N)$。\n- FSM 周期核算：\n  - FSM 使用一个周期进行初始化，对于流水线深度为 $K \\in \\{1,2\\}$ 的主迭代，每位使用 $K$ 个周期，并使用一个周期进行最终符号校正。因此，对于 $D \\neq 0$，总周期为 $K\\cdot W + 2$。对于 $D = 0$，FSM 在单个周期内检测到该情况，并且不执行后续周期。\n- 用于时序分析的组合数据路径划分：\n  - 每次迭代的数据路径包含一个延迟为 $d_{sh,\\max}$ 和 $d_{sh,\\min}$ 的移位器/多路复用器模块，一个延迟为 $d_{sub,\\max}$ 和 $d_{sub,\\min}$ 的减法器/比较器模块，以及一个延迟为 $d_{add,\\max}$ 和 $d_{add,\\min}$ 的加回模块。\n  - 当 $K = 1$ 时，这三个模块在一个周期内形成单个寄存器到寄存器的路径。当 $K = 2$ 时，通过插入一个中间寄存器来分割该路径，使得阶段 1 包含移位器和减法器，阶段 2 包含加回模块。\n  - 符号校正阶段是一个独立的寄存器到寄存器路径，其延迟为 $d_{sign,\\max}$ 和 $d_{sign,\\min}$。\n- 时序约束检查：\n  - 程序必须确定每个活动的寄存器到寄存器阶段是否满足建立和保持约束。这些检查必须基于同步时序中经过充分检验的准则：\n    - 对于建立时间，必须将启动寄存器的最大时钟到Q端延迟、最大组合延迟、捕获寄存器的建立时间以及时钟偏斜组合起来，以对照时钟周期检查可行性。\n    - 对于保持时间，必须将启动寄存器的最小时钟到Q端延迟、最小组合延迟、捕获寄存器的保持时间以及时钟偏斜组合起来，以防止过早的数据捕获违规。\n  - 整体建立时间可行性为真，当且仅当对于给定的 $K$，FSM 所使用的设计中所有阶段都满足建立时间约束。整体保持时间可行性为真，当且仅当设计中所有阶段都满足保持时间约束。\n- 单位：\n  - 所有时序参数和时钟周期值都必须以纳秒为单位进行解释。不允许使用其他单位。\n\n您的程序应生成单行输出，其中包含结果，形式为每个测试用例结果包的逗号分隔列表，每个包的格式为 [q,r,cycles,setup_ok,hold_ok]，其中 $q$ 和 $r$ 为有符号整数，$cycles$ 为整数，$setup\\_ok$ 和 $hold\\_ok$ 为用 $0$ 或 $1$ 表示的布尔值。\n\n测试套件：\n使用以下四个测试用例，涵盖一般行为、流水线分割可行性、除以零处理以及一个故意的保持时间压力案例。所有时序参数均以纳秒为单位。\n\n1. 案例 A：\n   - $W = 8$， $N = -73$， $D = 9$， $K = 1$\n   - $T_{clk} = 2.0$\n   - $T_{cq,\\max} = 0.08$， $T_{cq,\\min} = 0.05$\n   - $T_{setup} = 0.07$， $T_{hold} = 0.04$， $D_{skew} = 0.02$\n   - $d_{sh,\\max} = 0.30$， $d_{sh,\\min} = 0.10$\n   - $d_{sub,\\max} = 0.50$， $d_{sub,\\min} = 0.20$\n   - $d_{add,\\max} = 0.40$， $d_{add,\\min} = 0.15$\n   - $d_{sign,\\max} = 0.20$， $d_{sign,\\min} = 0.10$\n2. 案例 B：\n   - $W = 16$， $N = 32767$， $D = -1$， $K = 2$\n   - $T_{clk} = 1.0$\n   - $T_{cq,\\max} = 0.10$， $T_{cq,\\min} = 0.06$\n   - $T_{setup} = 0.08$， $T_{hold} = 0.05$， $D_{skew} = 0.02$\n   - $d_{sh,\\max} = 0.35$， $d_{sh,\\min} = 0.12$\n   - $d_{sub,\\max} = 0.55$， $d_{sub,\\min} = 0.25$\n   - $d_{add,\\max} = 0.45$， $d_{add,\\min} = 0.18$\n   - $d_{sign,\\max} = 0.25$， $d_{sign,\\min} = 0.12$\n3. 案例 C：\n   - $W = 12$， $N = -2048$， $D = 0$， $K = 1$\n   - $T_{clk} = 1.5$\n   - $T_{cq,\\max} = 0.08$， $T_{cq,\\min} = 0.05$\n   - $T_{setup} = 0.07$， $T_{hold} = 0.04$， $D_{skew} = 0.02$\n   - $d_{sh,\\max} = 0.32$， $d_{sh,\\min} = 0.11$\n   - $d_{sub,\\max} = 0.50$， $d_{sub,\\min} = 0.22$\n   - $d_{add,\\max} = 0.42$， $d_{add,\\min} = 0.16$\n   - $d_{sign,\\max} = 0.20$， $d_{sign,\\min} = 0.10$\n4. 案例 D：\n   - $W = 4$， $N = 7$， $D = 2$， $K = 2$\n   - $T_{clk} = 5.0$\n   - $T_{cq,\\max} = 0.10$， $T_{cq,\\min} = 0.01$\n   - $T_{setup} = 0.08$， $T_{hold} = 0.30$， $D_{skew} = 0.02$\n   - $d_{sh,\\max} = 0.20$， $d_{sh,\\min} = 0.02$\n   - $d_{sub,\\max} = 0.30$， $d_{sub,\\min} = 0.03$\n   - $d_{add,\\max} = 0.25$， $d_{add,\\min} = 0.04$\n   - $d_{sign,\\max} = 0.15$， $d_{sign,\\min} = 0.05$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，其中每个测试用例的结果本身是一个方括号括起来的逗号分隔列表，顺序为 $[q,r,cycles,setup\\_ok,hold\\_ok]$。例如：\"[[q1,r1,c1,s1,h1],[q2,r2,c2,s2,h2],[q3,r3,c3,s3,h3],[q4,r4,c4,s4,h4]]\"。",
            "solution": "用户提供的问题是有效的，因为它在计算机体系结构和数字逻辑设计领域内具有科学依据、自成体系且定义明确。它要求实现标准的恢复除法算法并应用基本的同步时序分析原理。为获得一个唯一、可验证的解决方案，所有必要的参数和定义都已提供。\n\n解决此问题的方法论包括三个主要部分：建模有符号恢复除法算法，核算有限状态机（FSM）的控制流和周期数，以及基于标准同步设计约束执行严格的时序可行性分析。\n\n首先，实现有符号恢复除法。问题规定，应先对被除数 $N$ 和除数 $D$ 的绝对值执行除法，然后进行符号校正步骤。商 $Q$ 的符号由 $N$ 和 $D$ 符号的异或运算决定，即 $\\operatorname{sgn}(Q) = \\operatorname{sgn}(N) \\oplus \\operatorname{sgn}(D)$。余数 $R$ 的符号与被除数 $N$ 的符号相同，即 $\\operatorname{sgn}(R) = \\operatorname{sgn}(N)$。这确保了对于二进制补码算术，除法恒等式 $N = D \\cdot Q + R$ 成立，其中 $0 \\le |R|  |D|$。除以零的情况（$D=0$）作为特殊条件处理，此时商设为 $0$，余数设为被除数 $N$ 的值。\n\n针对无符号操作数的恢复除法算法的核心是一个迭代过程。对于一个 $W$ 位的被除数和除数，该算法执行 $W$ 次迭代。使用一个概念上的双倍宽度寄存器 $[A,Q]$，其中 $A$ 是累加器（初值为 $0$），$Q$ 存放被除数。在每一步中，寄存器对 $[A,Q]$ 左移一位。执行从累加器 $A$ 中减去除数的尝试性减法。如果结果非负，则减法成功，并将 $Q$ 的最低有效位设置为 $1$。如果结果为负，则减法不成功，将除数加回到 $A$ 中以恢复其先前的值，并将 $Q$ 的最低有效位设置为 $0$。经过 $W$ 次迭代后，$Q$ 中存放商，$A$ 中存放余数。\n\n其次，计算基于 FSM 的周期数。对于非零除数，总周期数按定义包括三个阶段：$1$ 个周期用于初始化，$K \\cdot W$ 个周期用于主迭代除法过程（其中 $K$ 是迭代阶段的流水线深度），以及 $1$ 个周期用于最终符号校正，总计为 $K \\cdot W + 2$ 个周期。对于零除数，FSM 在一个周期内检测到该情况并中止。\n\n第三，进行详细的时序分析，以验证设计在给定的时钟周期 $T_{clk}$ 下是否满足其性能和可靠性目标。这包括检查由 FSM 操作决定的所有活动寄存器到寄存器路径的建立时间和保持时间约束。\n建立时间约束确保数据在下一个有效时钟沿之前足够早地到达捕获寄存器的输入端。其控制不等式为：\n$$T_{clk} \\ge T_{cq,\\max} + T_{comb,\\max} + T_{setup} + D_{skew}$$\n其中 $T_{cq,\\max}$ 是启动寄存器的最大时钟到Q端延迟，$T_{comb,\\max}$ 是组合逻辑路径的最大延迟，$T_{setup}$ 是捕获寄存器的建立时间，$D_{skew}$ 是时钟偏斜，为悲观估计，假定其会减少有效时钟周期。\n\n保持时间约束确保数据在有效时钟沿到达后在捕获寄存器的输入端保持稳定足够长的时间。其控制不等式为：\n$$T_{cq,\\min} + T_{comb,\\min} \\ge T_{hold} + D_{skew}$$\n其中 $T_{cq,\\min}$ 是最小时钟到Q端延迟，$T_{comb,\\min}$ 是最小组合逻辑延迟，$T_{hold}$ 是捕获寄存器的保持时间，$D_{skew}$ 再次为悲观估计，假定其会使保持条件更难满足。\n\n组合路径的结构取决于流水线深度 $K$：\n-   对于 $K=1$，整个迭代逻辑（移位器、减法器、加回器）形成一个单一的组合路径，其延迟为 $T_{comb,\\max} = d_{sh,\\max} + d_{sub,\\max} + d_{add,\\max}$ 和 $T_{comb,\\min} = d_{sh,\\min} + d_{sub,\\min} + d_{add,\\min}$。\n-   对于 $K=2$，路径被一个中间寄存器分成两个阶段。阶段 1（移位器 + 减法器）的延迟为 $T_{comb1,\\max} = d_{sh,\\max} + d_{sub,\\max}$（以及相应的最小延迟）。阶段 2（加回器）的延迟为 $T_{comb2,\\max} = d_{add,\\max}$。两个阶段都必须独立满足建立和保持约束。\n\n此外，独立的符号校正逻辑形成其自己的寄存器到寄存器路径，延迟为 $d_{sign,\\max}$ 和 $d_{sign,\\min}$。根据问题描述，当且仅当给定操作中 *FSM 使用的* 所有阶段都满足其建立时间约束时，整个设计的建立时间才被认为是可行的（`setup_ok` = $1$）。相同的逻辑适用于保持时间可行性（`hold_ok`）。这意味着对于除以零的操作，其中迭代和符号校正阶段被 FSM 旁路，它们的时序约束不被考虑在该特定操作的判定中。\n\n例如，在测试案例 B 中，当 $W=16$, $N=32767$, $D=-1$, $K=2$ 时，除法在 $2 \\cdot 16 + 2 = 34$ 个周期内得出 $Q=-32767$ 和 $R=0$。对于 $T_{clk}=1.0\\text{ ns}$ 的时序分析：\n-   流水线阶段 1（移位器 + 减法器）：\n    -   $T_{comb1,\\max} = 0.35 + 0.55 = 0.90\\text{ ns}$。\n    -   建立时间检查：$T_{cq,\\max} + T_{comb1,\\max} + T_{setup} + D_{skew} = 0.10 + 0.90 + 0.08 + 0.02 = 1.10\\text{ ns}$。由于 $T_{clk}  1.10\\text{ ns}$，该阶段的建立时间约束被违反。\n-   流水线阶段 2（加回器）：\n    -   $T_{comb2,\\max} = 0.45\\text{ ns}$。\n    -   建立时间检查：$T_{cq,\\max} + T_{comb2,\\max} + T_{setup} + D_{skew} = 0.10 + 0.45 + 0.08 + 0.02 = 0.65\\text{ ns}$。由于 $T_{clk} \\ge 0.65\\text{ ns}$，该阶段通过建立时间检查。\n-   符号校正阶段通过建立时间检查，并且所有阶段都通过各自的保持时间检查。\n因为阶段 1 的建立时间约束失败，所以此案例的整体 `setup_ok` 为 $0$（假），即使与非流水线（$K=1$）版本相比，流水线技术帮助减少了关键路径延迟。完整的实现会为所有四个测试用例计算这些值。",
            "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n#include\n```"
        },
        {
            "introduction": "在前面概念的基础上，这最后一个练习将涉及一个更复杂系统的设计：一个为两个独立指令流服务的共享流水线乘法器。这个任务要求你综合运用流水线、带锁存器的数据缓冲以及动态调度等概念，来管理数据流和资源竞争。完成这个仿真将使你亲身体验到现代处理器执行单元是如何被构建以最大化吞吐量的()。",
            "id": "3672626",
            "problem": "您需要实现一个周期精确的寄存器传输级（RTL）模拟器，用于模拟一个共享流水线乘法器。该乘法器带有操作数锁存器，并对两个独立的指令流进行轮询调度。该模型必须从同步数字系统的基本定义开始：在离散的时钟周期，所有寄存器（状态）在有效时钟沿更新，而组合逻辑可以被视为在时钟沿之间瞬时完成。您必须按照给定顺序忠实地模拟以下每个周期的三阶段序列，这是同步RTL行为的典型抽象：\n\n- 完成阶段：在时钟周期 $c$，之前发射到乘法器且完成时间等于 $c$ 的任何结果都将变为可用并被提交。\n- 发射阶段：在时钟周期 $c$，如果任何锁存器已满，调度器最多可以向乘法器输入端发射一个已锁存的操作。\n- 锁存阶段：在时钟周期 $c$，如果操作数锁存器为空，并且操作的操作数在时间 $c$ 或之前就绪，则每个流都可以在锁存阶段将其下一个就绪操作捕获到其操作数锁存器中。\n\n系统组件和规则：\n\n- 两个独立的指令流，索引为 $s \\in \\{0,1\\}$。流 $s$ 包含一系列有限的乘法操作。流 $s$ 中的第 $k$ 个操作有一个操作数就绪时间 $r_{s,k}$（一个非负整数时钟周期）和整数操作数 $a_{s,k}$ 和 $b_{s,k}$。该操作计算乘积 $y_{s,k} = a_{s,k} \\times b_{s,k}$。\n- 每个流 $s$ 都有一个单条目操作数锁存器。当该锁存器为空，且下一个操作的操作数在周期 $c$ 时就绪（即 $r_{s,k} \\le c$），该锁存器会在锁存阶段捕获该操作。当锁存器满时，它不能捕获另一个操作。\n- 恰好有一个流水线乘法器资源，其延迟固定为 $L \\ge 1$ 个周期，启动间隔为每个周期1个操作。在周期 $c$ 发射的操作将在周期 $c + L$ 完成。\n- 调度控制是轮询调度，带有一个可变的偏好位 $p \\in \\{0,1\\}$，用于指示当两个锁存器都满时哪个流具有优先权。在周期 $c$ 的发射阶段：\n    - 如果两个锁存器都为空，则不发射。\n    - 如果只有一个锁存器满，则发射该操作。\n    - 如果两个锁存器都满，则发射来自流 $p$ 的操作。\n  如果发生发射，被选中的锁存器立即变为空，并且偏好位会翻转，即 $p \\leftarrow 1 - p$。如果没有发生发射，则 $p$ 保持不变。\n- 周期语义：在每个周期 $c \\in \\mathbb{Z}_{\\ge 0}$，依次应用完成阶段、发射阶段、然后是锁存阶段，之后进入 $c+1$。当两个流的所有操作都已完成时终止。如果一个流没有操作，其“最后完成周期”定义为-1。如果根本没有任何操作，则总的制造期（makespan）定义为-1。\n\n您的程序必须：\n\n- 从 $c = 0$ 开始，完全按照上述RTL语义实现，每个测试用例会指定乘法器延迟 $L$ 和初始偏好 $p(0)$。\n- 为每个测试用例生成：\n    1. 制造期 $M$，定义为所有操作中的最大完成周期，如果没有操作则为-1。\n    2. 流0的最后完成周期，记为 $C_0$，如果流0没有操作则为-1。\n    3. 流1的最后完成周期，记为 $C_1$，如果流1没有操作则为-1。\n    4. 按时间排序的乘法器结果列表 $[y_{i}]$，严格按完成时间递增的顺序排列。因为 $L \\ge 1$ 且启动间隔为1，每个周期最多只有一个结果完成，所以列表顺序是无歧义的。\n\n要使用的基本原理：\n\n- 同步RTL状态演化：所有状态变化都在时钟沿以明确定义的顺序发生。将三个阶段（完成、发射、锁存）视为有序的组合计算，其效果在周期结束时被寄存器捕获。\n- 资源约束：乘法器每个周期最多接受一个操作，并在 $L$ 个周期后产生结果。\n- 仲裁策略：带偏好位的轮询调度，该偏好位仅在成功发射时翻转。\n\n在您的程序中实现并运行的测试套件（这些是唯一的输入；不允许用户输入）：\n\n- 测试用例1（顺利路径，交错就绪）：\n    - 延迟 $L = 3$，初始偏好 $p(0) = 0$。\n    - 流0：就绪时间 $\\langle 0, 1, 4 \\rangle$，操作数 $\\langle (2, 3), (5, 7), (2, 11) \\rangle$。\n    - 流1：就绪时间 $\\langle 0, 2, 4 \\rangle$，操作数 $\\langle (4, 4), (9, 1), (3, 3) \\rangle$。\n- 测试用例2（重度竞争，同时就绪，不同初始偏好）：\n    - 延迟 $L = 2$，初始偏好 $p(0) = 1$。\n    - 流0：就绪时间 $\\langle 0, 0, 0 \\rangle$，操作数 $\\langle (1, 10), (2, 10), (3, 10) \\rangle$。\n    - 流1：就绪时间 $\\langle 0, 0 \\rangle$，操作数 $\\langle (4, 10), (5, 10) \\rangle$。\n- 测试用例3（一个流为空，空闲间隙）：\n    - 延迟 $L = 4$，初始偏好 $p(0) = 0$。\n    - 流0：无操作。\n    - 流1：就绪时间 $\\langle 3, 9 \\rangle$，操作数 $\\langle (7, 7), (2, 8) \\rangle$。\n- 测试用例4（最小延迟 $L = 1$，短序列）：\n    - 延迟 $L = 1$，初始偏好 $p(0) = 0$。\n    - 流0：就绪时间 $\\langle 0, 1 \\rangle$，操作数 $\\langle (6, 6), (1, 2) \\rangle$。\n    - 流1：就绪时间 $\\langle 0 \\rangle$，操作数 $\\langle (3, 7) \\rangle$。\n\n输出规范：\n\n- 您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个测试用例贡献一个形式为 $[M,C_0,C_1,[y_0,y_1,\\dots]]$ 的列表。例如，包含两个测试用例的一行可能看起来像 $[[M_1,C_{0,1},C_{1,1},[y^{(1)}_0,\\dots]],[M_2,C_{0,2},C_{1,2},[y^{(2)}_0,\\dots]]]$。\n- 所有数值输出必须是十进制整数。没有需要报告的物理单位。\n\n您的任务是编写一个完整的、自包含的程序，该程序实现所描述的RTL模型，并为四个指定的测试用例打印所需的单行输出。不应从标准输入读取任何输入。给定上述规范，程序必须是确定性的。",
            "solution": "该问题要求实现一个数字系统的周期精确的寄存器传输级（RTL）模型。该系统包含两个独立的指令流，它们竞争一个单一的、共享的流水线乘法器。模拟必须遵循同步数字逻辑的基本原则，即系统状态在离散的时钟周期边界演化。\n\n从核心上讲，一个同步RTL模型由状态保持元件（寄存器）和计算下一状态的组合逻辑组成。在任何时钟周期 $c \\in \\mathbb{Z}_{\\ge 0}$开始时，我们系统的状态由以下组件定义：\n1.  每个流 $s \\in \\{0,1\\}$ 的操作数锁存器的状态：是满还是空，如果满则包含其内容。\n2.  当前在乘法器流水线中正在处理的操作集合，以及它们的预定完成周期。\n3.  每个指令流中下一个要考虑的操作的索引。\n4.  轮询调度偏好位 $p$ 的当前值。\n\n从周期 $c$ 到周期 $c+1$ 的状态转换由一个按固定顺序执行的三个组合逻辑阶段序列控制：\n1.  **完成阶段**：根据执行完成的操作更新系统状态。\n2.  **发射阶段**：决定哪个新操作（如果有的话）进入流水线。\n3.  **锁存阶段**：将流中下一个就绪的操作取入其本地缓冲区。\n\n模拟算法通过从 $c=0$ 开始迭代时钟周期来进行，并应用这个三阶段序列，直到两个流的所有操作都已发射、处理并提交其结果。\n\n让我们将状态和每周期逻辑形式化。\n\n**系统状态变量：**\n-   $c$：当前时钟周期，一个初始化为 $0$ 的整数。\n-   $p$：调度器偏好位，$p \\in \\{0,1\\}$，根据测试用例进行初始化。\n-   对于每个流 $s \\in \\{0,1\\}$：\n    -   $L_s$：一个类布尔值的状态，指示流 $s$ 的锁存器是满 ($1$) 还是空 ($0$)。\n    -   $O_s$：一个元组 $(a, b)$，如果 $L_s=1$，则持有锁存器 $s$ 中操作的操作数。\n    -   $k_s$：一个整数索引，指向流 $s$ 指令序列中的下一个操作。\n-   $\\Pi$：一个待完成操作的集合，其中每个元素是一个元组 $(t_{comp}, y, s_{orig})$，表示来自原始流 $s_{orig}$ 的结果 $y$ 将在周期 $t_{comp}$ 完成。\n\n**模拟算法：**\n当已完成操作的总数等于初始操作的总数时，模拟终止。\n\n**初始化：**\n1.  设置 $c \\leftarrow 0$。\n2.  将 $p$ 初始化为测试用例给定的起始值。\n3.  对于每个流 $s \\in \\{0,1\\}$：初始化 $L_s \\leftarrow 0$ 和 $k_s \\leftarrow 0$。\n4.  初始化待完成操作集合 $\\Pi \\leftarrow \\emptyset$。\n5.  初始化结果指标：制造期 $M \\leftarrow -1$，最后完成周期 $C_0 \\leftarrow -1$ 和 $C_1 \\leftarrow -1$。\n6.  初始化一个用于存放最终结果的有序列表，$Y \\leftarrow []$。\n7.  处理边缘情况：如果两个流都为空，将 $M$、$C_0$、$C_1$ 设置为-1并终止。\n\n**主模拟循环（当并非所有操作都完成时）：**\n\n在每个周期 $c$ 的开始，按严格顺序执行以下操作：\n\n**1. 完成阶段：**\n逻辑检查是否有任何操作在本周期完成执行。\n-   遍历所有待完成操作 $(t_{comp}, y, s_{orig}) \\in \\Pi$。\n-   如果 $t_{comp} = c$：\n    -   结果 $y$ 现在可用。将 $y$ 附加到全局的、按时间排序的结果列表 $Y$ 中。\n    -   更新源流的最后完成周期：$C_{s_{orig}} \\leftarrow c$。\n    -   增加流 $s_{orig}$ 的已完成操作计数。\n    -   从集合 $\\Pi$ 中移除 $(t_{comp}, y, s_{orig})$。\n    -   由于乘法器的启动间隔为1，每个周期最多只能有一个操作完成。\n\n**2. 发射阶段：**\n调度器决定是否将一个已满锁存器中的操作发射到乘法器流水线。\n-   设 $L_0$ 和 $L_1$ 分别是流0和流1的锁存器满状态。\n-   仅当 $L_0=1$ 或 $L_1=1$ 时才可能发射。\n-   确定要从中发射的流，$s_{issue}$：\n    -   如果 $L_0=1$ 且 $L_1=0$，则 $s_{issue} \\leftarrow 0$。\n    -   如果 $L_0=0$ 且 $L_1=1$，则 $s_{issue} \\leftarrow 1$。\n    -   如果 $L_0=1$ 且 $L_1=1$，则 $s_{issue} \\leftarrow p$。\n    -   否则，不发生发射。\n-   如果流 $s_{issue}$ 发生发射：\n    -   设锁存的操作为 $O_{s_{issue}} = (a, b)$。\n    -   结果为 $y = a \\times b$。\n    -   完成时间为 $t_{comp} = c + L$，其中 $L$ 是乘法器延迟。\n    -   将新的待完成操作 $(t_{comp}, y, s_{issue})$ 添加到集合 $\\Pi$ 中。\n    -   已发射流的锁存器现在空闲：$L_{s_{issue}} \\leftarrow 0$。\n    -   偏好位翻转：$p \\leftarrow 1 - p$。\n-   如果没有发生发射，则 $p$ 保持不变。\n\n**3. 锁存阶段：**\n每个流尝试将其下一个可用的操作加载到其操作数锁存器中，前提是锁存器为空。此阶段对每个流独立评估。\n-   对于每个流 $s \\in \\{0,1\\}$：\n    -   检查锁存器是否为空：$L_s = 0$。\n    -   检查流是否还有更多操作：$k_s$ 小于流 $s$ 的总操作数。\n    -   设下一个操作是第 $k_s$ 个，其就绪时间为 $r_{s,k_s}$，操作数为 $(a_{s,k_s}, b_{s,k_s})$。\n    -   检查操作是否就绪：$r_{s,k_s} \\le c$。\n    -   如果所有三个条件都满足（锁存器空、有更多操作、操作就绪）：\n        -   将操作加载到锁存器中：$O_s \\leftarrow (a_{s,k_s}, b_{s,k_s})$。\n        -   将锁存器标记为满：$L_s \\leftarrow 1$。\n        -   推进流的操作指针：$k_s \\leftarrow k_s + 1$。\n\n在所有三个阶段都完成后，时钟周期前进：$c \\leftarrow c+1$。循环继续，直到已完成操作的总数与两个流的总操作数相匹配。\n\n**最终处理：**\n模拟循环终止后，制造期 $M$ 计算为 $\\max(C_0, C_1)$。收集到的值 $M$、$C_0$、$C_1$ 以及有序结果列表 $Y$ 构成了该测试用例的输出。对问题中定义的每个测试用例重复此整个过程。",
            "answer": "```c\n#include\n```"
        }
    ]
}