{
    "hands_on_practices": [
        {
            "introduction": "本练习将指导你构建一个总线仲裁器，这是数字系统中多个设备共享单一资源时的基本组件。你将实现并比较两种经典的仲裁策略——固定优先级和轮询法——以理解它们对系统性能和公平性的影响。通过这项实践，你将获得对资源竞争进行建模，并评估延迟和饥饿等关键指标的动手经验 。",
            "id": "3672585",
            "problem": "设计并实现一个共享总线仲裁器的周期精确仿真 (cycle-accurate simulation)，该仿真需达到寄存器传输级 (RTL) 语义级别。该仲裁器为 $M$ 个请求者服务，并支持两种仲裁策略：轮询 (round-robin) 和固定优先级 (fixed priority)。仲裁器与一个单一的全局时钟同步运行。在每个时钟周期 $t \\in \\{0,1,2,\\dots,T-1\\}$，每个请求者 $i \\in \\{0,1,\\dots,M-1\\}$ 都会发出一个二进制请求信号 $r_i[t] \\in \\{0,1\\}$。仲裁器为每个周期 $t$ 生成一个独热 (one-hot) 授权向量 $g[t] = (g_0[t],g_1[t],\\dots,g_{M-1}[t])$，其中 $g_i[t] \\in \\{0,1\\}$ 且 $\\sum_{i=0}^{M-1} g_i[t] \\le 1$。如果在一个周期内没有请求被断言 (asserted)，则 $\\sum_{i=0}^{M-1} g_i[t] = 0$。\n\n系统遵循同步 RTL 语义：组合逻辑根据时间 $t$ 的 $r[t]$ 和任何架构寄存器状态来推导出 $g[t]$，而时序寄存器在有效时钟沿更新，为时间 $t+1$ 产生状态。\n\n必须对两种仲裁策略进行建模：\n\n- 固定优先级 (Fixed Priority, FP)：假设存在一个静态的严格优先级顺序，其中较小的索引意味着较高的优先级。给定 $r[t]$，FP 仲裁器选择满足 $r_i[t]=1$ 的最小索引 $i$，并设置 $g_i[t]=1$ 及对所有 $j \\ne i$ 设置 $g_j[t]=0$。如果不存在这样的 $i$，则 $g[t]=\\mathbf{0}$。\n\n- 轮询 (Round-Robin, RR)：一个指针寄存器 $p[t] \\in \\{0,1,\\dots,M-1\\}$ 编码了下一个要首先检查的请求者。给定 $r[t]$ 和 $p[t]$，RR 仲裁器按循环顺序 $p[t], p[t]+1 \\bmod M, \\dots, p[t]+M-1 \\bmod M$ 进行扫描，选择第一个满足 $r_i[t]=1$ 的索引 $i$，并设置 $g_i[t]=1$ 及对所有 $j \\ne i$ 设置 $g_j[t]=0$。如果在时间 $t$ 至少发生一次对索引 $i$ 的授权，则 $p[t+1] = (i+1) \\bmod M$。如果没有发生授权，则 $p[t+1] = p[t]$。初始化 $p[0]=0$。\n\n流量模型（突发请求）：每个请求者 $i$ 生成周期性的突发请求，其特征由三个非负整数 $(L_i,G_i,S_i)$ 描述，语义如下。如果 $L_i=0$，则对所有 $t$ 都有 $r_i[t]=0$。否则，定义周期 $P_i=L_i+G_i$。对于所有 $t \\ge 0$，\n$$\nr_i[t] = \\begin{cases}\n1,  \\text{if } t \\ge S_i \\text{ and } \\left( (t - S_i) \\bmod P_i \\right)  L_i, \\\\\n0,  \\text{otherwise}.\n\\end{cases}\n$$\n这模拟了长度为 $L_i$ 个周期的突发请求，其间有长度为 $G_i$ 个周期的间隙，从周期 $S_i$ 开始。如果 $G_i=0$ 且 $L_i0$，则请求者 $i$ 在所有 $t \\ge S_i$ 的时间内持续请求。\n\n要为每种仲裁策略在 $T$ 个周期的范围内计算的指标：\n\n- 每个请求者的授权计数：$C_i = \\sum_{t=0}^{T-1} g_i[t]$，对每个 $i$。\n\n- 每个请求者的最大等待时间（以周期为单位）：对每个 $i$，定义逐周期等待计数器 $w_i[t]$ 为截至并包括周期 $t$ 的当前连续周期运行的长度，在此期间对该运行中的所有 $t'$ 都有 $r_i[t']=1$ 和 $g_i[t']=0$。每当 $r_i[t]=0$ 或 $g_i[t]=1$ 时，此计数器重置为 $0$。定义 $W_i = \\max_{t \\in \\{0,\\dots,T-1\\}} w_i[t]$。\n\n- 每个请求者的饿死指示器：对每个 $i$，定义 $R_i = \\sum_{t=0}^{T-1} r_i[t]$ 和 $S_i^\\star = \\begin{cases}1, \\text{if } R_i  0 \\text{ and } C_i = 0,\\\\ 0, \\text{otherwise.}\\end{cases}$\n\n汇总以下每个策略的指标进行报告：\n\n- 饿死请求者计数：$S^\\text{count} = \\sum_{i=0}^{M-1} S_i^\\star$。\n\n- 所有请求者中的最大等待时间：$W^\\text{max} = \\max_{i \\in \\{0,\\dots,M-1\\}} W_i$。\n\n实现一个完整的、可运行的程序，对于下面的每个测试案例，使用突发请求模型在 $T$ 个周期内模拟两种仲裁策略，并为每个测试案例生成以下结果：\n\n- 对于轮询策略：一个列表 $[\\,[C_0,\\dots,C_{M-1}],\\, W^\\text{max},\\, S^\\text{count}\\,]$。\n\n- 对于固定优先级策略：一个列表 $[\\,[C_0,\\dots,C_{M-1}],\\, W^\\text{max},\\, S^\\text{count}\\,]$。\n\n最终程序输出必须是单行，包含所有测试案例的结果，形式为方括号括起来的逗号分隔列表，其中每个测试案例表示为一个双元素列表 $[ \\text{RR\\_metrics}, \\text{FP\\_metrics} ]$，顺序如下。不应打印其他文本。\n\n测试套件（三个案例）：\n\n- 案例 A (平衡交错突发)：\n  - $M=4$, $T=24$。\n  - 请求者 $0$：$(L_0,G_0,S_0)=(3,5,0)$。\n  - 请求者 $1$：$(L_1,G_1,S_1)=(3,5,2)$。\n  - 请求者 $2$：$(L_2,G_2,S_2)=(3,5,4)$。\n  - 请求者 $3$：$(L_3,G_3,S_3)=(3,5,6)$。\n\n- 案例 B (始终在线的高优先级竞争者)：\n  - $M=3$, $T=30$。\n  - 请求者 $0$：$(L_0,G_0,S_0)=(30,0,0)$。\n  - 请求者 $1$：$(L_1,G_1,S_1)=(2,4,0)$。\n  - 请求者 $2$：$(L_2,G_2,S_2)=(2,4,2)$。\n\n- 案例 C (无请求)：\n  - $M=5$, $T=10$。\n  - 对所有 $i \\in \\{0,1,2,3,4\\}$：$(L_i,G_i,S_i)=(0,1,0)$。\n\n您的程序应生成单行输出，包含所有结果，格式为方括号括起来的逗号分隔列表，结构完全如下：\n$[ [\\text{RR\\_A},\\text{FP\\_A}], [\\text{RR\\_B},\\text{FP\\_B}], [\\text{RR\\_C},\\text{FP\\_C}] ]$\n其中每个 $\\text{RR\\_X}$ 和 $\\text{FP\\_X}$ 本身都是一个形式为 $[[C_0,\\dots,C_{M-1}],W^\\text{max},S^\\text{count}]$ 的列表。所有数值必须是整数。不需要空格；如果您包含空格，自动评分器会忽略它们，但建议省略空格。",
            "solution": "该问题要求设计并实现一个共享总线仲裁器的周期精确寄存器传输级 (RTL) 仿真。该仿真必须在 $T$ 个周期的仿真时长内，对一个包含 $M$ 个请求者的系统进行建模，并采用两种不同的仲裁策略：固定优先级 (FP) 和轮询 (RR)。\n\n仿真遵循同步 RTL 语义，其中系统行为在离散的时钟周期 $t=0, 1, \\dots, T-1$ 上定义。每个周期 $t$ 的过程可以分解为两个主要阶段，这反映了物理数字电路的行为：组合逻辑的求值和时序状态的更新。\n\n首先，对组合逻辑进行求值。该逻辑产生的输出是当前周期输入和状态的函数。\n仲裁器的主要输入是来自每个请求者 $i$ 的请求信号，表示为 $r_i[t]$。这些信号根据指定的突发流量模型生成，该模型是参数 $(L_i, G_i, S_i)$ 的函数：\n$$\nr_i[t] = \\begin{cases}\n1,  \\text{if } L_i  0, t \\ge S_i \\text{ and } \\left( (t - S_i) \\bmod (L_i+G_i) \\right)  L_i \\\\\n0,  \\text{otherwise}\n\\end{cases}\n$$\n此公式确定性地计算每个周期 $t$ 的请求向量 $r[t] = (r_0[t], \\dots, r_{M-1}[t])$。\n\n给定请求向量 $r[t]$ 和周期开始时的任何相关状态，仲裁器的组合逻辑计算独热 (one-hot) 授权向量 $g[t] = (g_0[t], \\dots, g_{M-1}[t])$。该逻辑取决于仲裁策略：\n\n1.  **固定优先级 (FP)**：此策略是无状态的。授权逻辑是 $r[t]$ 的纯组合函数。它按请求者的索引排定优先级，索引越小，优先级越高。对于满足 $r_i[t]=1$ 的最小索引 $i$，授权 $g_i[t]$ 被设为 $1$。如果没有活动的请求（$\\sum r_i[t] = 0$），则所有授权均为 $0$。\n    $$g_i[t] = \\begin{cases} 1,  \\text{if } r_i[t]=1 \\text{ and } r_j[t]=0 \\text{ for all } j  i \\\\ 0,  \\text{otherwise} \\end{cases}$$\n\n2.  **轮询 (RR)**：此策略需要架构状态，具体来说是一个指针寄存器 $p[t]$，用于存储首先要检查的请求者的索引。授权逻辑是 $r[t]$ 和 $p[t]$ 的组合函数。仲裁器从索引 $p[t]$ 开始，循环地搜索活动请求。找到的第一个活动请求者（比如 $k$）将获得授权（$g_k[t]=1$）。\n    搜索序列为 $p[t], (p[t]+1)\\bmod M, \\dots, (p[t]+M-1)\\bmod M$。\n\n一旦确定了该周期的授权向量 $g[t]$，就会更新所需的性能指标。这些计算可以看作是监控逻辑。\n\n-   **授权计数 ($C_i$)**：对于每个获得授权的请求者 $i$ ($g_i[t]=1$)，其总授权计数 $C_i$ 增加。$C_i = \\sum_{t=0}^{T-1} g_i[t]$。\n-   **等待时间 ($w_i[t]$ 和 $W_i$)**：每个请求者的等待计数器 $w_i[t]$ 跟踪连续未被服务的请求周期。其值根据 $r_i[t]$ 和 $g_i[t]$ 更新：\n    $$w_i[t] = \\begin{cases} w_i[t-1] + 1,  \\text{if } r_i[t]=1 \\text{ and } g_i[t]=0 \\\\ 0,  \\text{if } r_i[t]=0 \\text{ or } g_i[t]=1 \\end{cases}$$\n    初始条件为 $w_i[-1]=0$。请求者 $i$ 的最大等待时间 $W_i$ 是 $w_i[t]$ 在整个仿真期间达到的最大值：$W_i = \\max_{0 \\le t  T} w_i[t]$。\n\n其次，在周期结束时（概念上，在有效时钟沿），时序状态寄存器会更新为下一个周期 $t+1$ 的值。\n\n-   **对于 FP 策略**，没有状态，因此无需更新。\n-   **对于 RR 策略**，指针寄存器 $p$ 会被更新。如果在周期 $t$ 中向请求者 $k$ 发出了授权，指针会移到下一个位置：$p[t+1] = (k+1) \\bmod M$。如果没有发出授权，指针保持不变：$p[t+1] = p[t]$。初始状态为 $p[0]=0$。\n\n整个过程从 $t=0$ 到 $T-1$ 重复进行。仿真循环完成后，计算最终的聚合指标：\n-   **饿死指示器 ($S_i^\\star$) 和计数 ($S^\\text{count}$)**：如果一个请求者 $i$ 发出了至少一个请求（$R_i = \\sum_{t=0}^{T-1} r_i[t]  0$）但没有收到任何授权（$C_i = 0$），则认为该请求者处于饿死状态。总计数为 $S^\\text{count} = \\sum_{i=0}^{M-1} S_i^\\star$。\n-   **所有请求者中的最大等待时间 ($W^\\text{max}$)**：这是所有请求者最大等待时间中的最大值：$W^\\text{max} = \\max_{i=0}^{M-1} W_i$。\n\n实现将包含一个封装了此逻辑的主仿真函数，该函数将为每个测试案例和两种仲裁策略分别调用。然后，收集结果并按指定格式打印。",
            "answer": "```c\n/* 由于生成错误，此解决方案的代码不可用。 */\n```"
        },
        {
            "introduction": "在资源共享概念的基础上，本实践通过让你设计一个 AXI-Lite 从设备接口来聚焦于通信协议。你将开发一个有限状态机（FSM）来管理“就绪/有效”（ready/valid）握手协议，这是现代总线协议的基石。这项练习对于理解不同数字组件如何可靠地交换数据并遵守标准化通信规则至关重要 。",
            "id": "3672621",
            "problem": "设计一个离散时间寄存器传输级 (RTL) 仿真，该仿真模拟一个高级可扩展接口 (AXI)-Lite 风格的从设备 (slave)，此从设备通过一个由形式化时序图语义推导出的控制有限状态机 (FSM) 来实现 ready/valid 通道。其目的是使用一个有原则的 RTL 模型来演示正确的协议顺序。\n\n作为起点的基本基础和定义：\n- 一个时钟同步的 RTL 系统对离散时间点采样的信号进行建模。设离散时间索引为 $t \\in \\mathbb{N}$，每个时钟节拍前进一。\n- AXI-Lite 通道遵循 ready/valid 握手协议。对于一个具有主设备侧 valid信号 $m\\_{\\mathrm{valid}}(t)$ 和从设备侧 ready 信号 $s\\_{\\mathrm{ready}}(t)$ 的通道，握手事件 $h(t)$ 在同一时间 $t$ 发生，当 $h(t) = m\\_{\\mathrm{valid}}(t) \\land s\\_{\\mathrm{ready}}(t)$ 时。\n- 有效载荷稳定性约束：如果 $m\\_{\\mathrm{valid}}(t) = 1$ 且尚未发生握手，则有效载荷必须保持稳定。也就是说，对于一个有效载荷 $p(t)$，在 $m\\_{\\mathrm{valid}}(t) = 1$ 期间直到握手发生的所有时间 $t$，必须满足 $p(t) = p(t-1)$。\n- AXI-Lite 中的协议顺序：\n  - 写事务要求在 AW 通道上接收写地址，在 W 通道上接收写数据。在 AW 和 W 握手都发生之前，不能在 B 通道上断言写响应。当 $s\\_{\\mathrm{bvalid}}(t) = 1$ 并且 $m\\_{\\mathrm{bready}}(t) = 1$ 时，响应被传递并完成握手。\n  - 读事务要求在 AR 通道上接收读地址，之后可以在 R 通道上断言读数据。当 $s\\_{\\mathrm{rvalid}}(t) = 1$ 并且 $m\\_{\\mathrm{rready}}(t) = 1$ 时，响应被传递并完成握手。\n- 为简单起见，施加了单笔未完成事务约束：从设备必须确保最多只有一笔事务在进行中。因此，当一笔写操作待处理时，读地址通道不处于 ready 状态，反之亦然。\n\n您的程序必须为一个固定的内存映射寄存器组仿真一个从设备 RTL FSM，该 FSM 遵循上述语义，并检测主设备侧对 AXI-Lite 稳定性规则的违反。该仿真是纯逻辑的，没有物理时间单位；时间以离散周期 $t$ 推进，答案中不需要物理单位。\n\n内存模型：\n- 有 $4$ 个寄存器，每个 $32$ 位宽，通过集合 $\\{0,4,8,12\\}$ 中的字节地址进行寻址。设索引为 $i = \\frac{\\mathrm{addr}}{4}$，其中 $i \\in \\{0,1,2,3\\}$。所有寄存器初始化为 $0$。\n\n每个周期 $t$ 的通道和信号：\n- 主设备输入：\n  - 写地址 (AW): $m\\_{\\mathrm{awvalid}}(t)$, $m\\_{\\mathrm{awaddr}}(t)$。\n  - 写数据 (W): $m\\_{\\mathrm{wvalid}}(t)$, $m\\_{\\mathrm{wdata}}(t)$。\n  - 写响应就绪 (B): $m\\_{\\mathrm{bready}}(t)$。\n  - 读地址 (AR): $m\\_{\\mathrm{arvalid}}(t)$, $m\\_{\\mathrm{araddr}}(t)$。\n  - 读响应就绪 (R): $m\\_{\\mathrm{rready}}(t)$。\n- 需要仿真的从设备输出：\n  - $s\\_{\\mathrm{awready}}(t)$, $s\\_{\\mathrm{wready}}(t)$, $s\\_{\\mathrm{bvalid}}(t)$, $s\\_{\\mathrm{arready}}(t)$, $s\\_{\\mathrm{rvalid}}(t)$ 和 $s\\_{\\mathrm{rdata}}(t)$。\n\n从设备 FSM 要求：\n- 当从设备可以接受新的写地址时，必须断言 $s\\_{\\mathrm{awready}}(t) = 1$；当它可以接受新的写数据时，必须断言 $s\\_{\\mathrm{wready}}(t) = 1$，前提是没有读操作处于活动状态且没有写响应待处理。\n- 一旦某笔事务的 AW 和 W 握手都已发生，从设备应从下一个周期开始断言 $s\\_{\\mathrm{bvalid}}(t)$，并保持其断言状态，直到与 $m\\_{\\mathrm{bready}}(t) = 1$ 发生握手。当从设备首次断言 $s\\_{\\mathrm{bvalid}}(t) = 1$ 时，写操作被提交到内存。\n- 当从设备可以接受新的读地址时，必须断言 $s\\_{\\mathrm{arready}}(t) = 1$，前提是没有写操作处于活动或待处理状态。\n- 一旦 AR 握手发生，从设备应从下一个周期开始断言 $s\\_{\\mathrm{rvalid}}(t)$，并保持其断言状态，直到与 $m\\_{\\mathrm{rready}}(t) = 1$ 发生握手。在 $s\\_{\\mathrm{rvalid}}(t) = 1$ 且握手尚未发生期间，响应有效载荷 $s\\_{\\mathrm{rdata}}(t)$ 必须保持稳定。\n\n违规检测：\n- 当 AW、W 或 AR 上的任何主设备有效载荷在对应的 $m\\_{\\mathrm{valid}}(t) = 1$ 且握手尚未发生的情况下改变其值时，程序必须计为一次违规。\n- 如果一个 valid 信号在握手前被撤销断言（变为 $0$），而之前是断言状态（为 $1$），程序也可以计为一次违规，但所提供的测试套件除了明确暗示的情况外，避免了这种情况。\n\n输出：\n- 对于每个测试用例，输出一个列表 $[w, r, v, c]$，其中：\n  - $w$ 是已完成的写事务的整数数量。\n  - $r$ 是已完成的读事务的整数数量。\n  - $v$ 是检测到的稳定性违规的整数计数。\n  - $c$ 是一个整数校验和，等于所有最终内存寄存器值的总和加上所有已传递的读数据值的总和。\n\n您的程序应生成单行输出，其中包含一个以逗号分隔的列表，该列表包含在方括号中，每个测试用例的结果都包含在各自的方括号列表中，例如 $[[w\\_1,r\\_1,v\\_1,c\\_1],[w\\_2,r\\_2,v\\_2,c\\_2],\\dots]$。\n\n测试套件：\n- 测试用例 1 ($T = 10$ 个周期)。每个周期 $t = 0,\\dots,9$ 的信号：\n  - $m\\_{\\mathrm{awvalid}}$: $[0,1,0,0,0,0,0,0,0,0]$\n  - $m\\_{\\mathrm{awaddr}}$: $[0,0,0,0,0,0,0,0,0,0]$ 其中唯一有意义的地址在 $t=1$ 时等于 $0$。\n  - $m\\_{\\mathrm{wvalid}}$: $[0,1,0,0,0,0,0,0,0,0]$\n  - $m\\_{\\mathrm{wdata}}$: $[0,42,0,0,0,0,0,0,0,0]$\n  - $m\\_{\\mathrm{bready}}$: $[0,0,1,0,0,0,0,0,0,0]$\n  - $m\\_{\\mathrm{arvalid}}$: $[0,0,0,1,0,0,0,0,0,0]$\n  - $m\\_{\\mathrm{araddr}}$: $[0,0,0,0,0,0,0,0,0,0]$ 其中唯一有意义的地址在 $t=3$ 时等于 $0$。\n  - $m\\_{\\mathrm{rready}}$: $[0,0,0,0,1,0,0,0,0,0]$\n- 测试用例 2 ($T = 14$ 个周期)。每个周期 $t = 0,\\dots,13$ 的信号：\n  - $m\\_{\\mathrm{awvalid}}$: $[0,1,0,0,0,0,0,0,0,0,0,0,0,0]$\n  - $m\\_{\\mathrm{awaddr}}$: $[0,8,0,0,0,0,0,0,0,0,0,0,0,0]$\n  - $m\\_{\\mathrm{wvalid}}$: $[0,0,0,0,1,0,0,0,0,0,0,0,0,0]$\n  - $m\\_{\\mathrm{wdata}}$: $[0,0,0,0,99,0,0,0,0,0,0,0,0,0]$\n  - $m\\_{\\mathrm{bready}}$: $[0,0,0,0,0,0,0,0,1,0,0,0,0,0]$\n  - $m\\_{\\mathrm{arvalid}}$: $[0,0,0,0,0,0,0,0,0,1,0,0,0,0]$\n  - $m\\_{\\mathrm{araddr}}$: $[0,0,0,0,0,0,0,0,0,8,0,0,0,0]$\n  - $m\\_{\\mathrm{rready}}$: $[0,0,0,0,0,0,0,0,0,0,0,0,1,0]$\n- 测试用例 3 ($T = 10$ 个周期)。每个周期 $t = 0,\\dots,9$ 的信号：\n  - $m\\_{\\mathrm{awvalid}}$: $[0,0,0,0,0,0,0,0,0,0]$\n  - $m\\_{\\mathrm{awaddr}}$: $[0,0,0,0,0,0,0,0,0,0]$\n  - $m\\_{\\mathrm{wvalid}}$: $[0,0,0,0,0,0,0,0,0,0]$\n  - $m\\_{\\mathrm{wdata}}$: $[0,0,0,0,0,0,0,0,0,0]$\n  - $m\\_{\\mathrm{bready}}$: $[1,1,1,1,1,1,1,1,1,1]$\n  - $m\\_{\\mathrm{arvalid}}$: $[0,0,0,0,0,1,0,0,0,0]$\n  - $m\\_{\\mathrm{araddr}}$: $[0,0,0,0,0,12,0,0,0,0]$\n  - $m\\_{\\mathrm{rready}}$: $[1,1,1,1,1,1,1,1,1,1]$\n- 测试用例 4 ($T = 12$ 个周期)。每个周期 $t = 0,\\dots,11$ 的信号：\n  - $m\\_{\\mathrm{awvalid}}$: $[1,0,0,0,0,0,0,0,0,0,0,0]$\n  - $m\\_{\\mathrm{awaddr}}$: $[0,0,0,0,0,0,0,0,0,0,0,0]$\n  - $m\\_{\\mathrm{wvalid}}$: $[0,0,1,0,0,0,0,0,0,0,0,0]$\n  - $m\\_{\\mathrm{wdata}}$: $[0,0,7,0,0,0,0,0,0,0,0,0]$\n  - $m\\_{\\mathrm{bready}}$: $[0,0,0,0,1,0,0,0,0,0,0,0]$\n  - $m\\_{\\mathrm{arvalid}}$: $[0,1,1,1,1,1,0,0,0,0,0,0]$\n  - $m\\_{\\mathrm{araddr}}$: $[0,0,4,4,4,4,0,0,0,0,0,0]$\n  - $m\\_{\\mathrm{rready}}$: $[0,0,0,0,0,0,1,0,0,0,0,0]$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个嵌套列表，列表内容为每个测试用例的结果，格式为 $[[w\\_1,r\\_1,v\\_1,c\\_1],[w\\_2,r\\_2,v\\_2,c\\_2],[w\\_3,r\\_3,v\\_3,c\\_3],[w\\_4,r\\_4,v\\_4,c\\_4]]$。",
            "solution": "用户提供的问题陈述是数字逻辑设计中一个明确定义的练习，具体来说是寄存器传输级 (RTL) 有限状态机 (FSM) 的建模和仿真。它要求仿真一个简化的 AXI-Lite 从设备接口，遵守指定的协议规则并检测主设备侧的协议违规。\n\n### 步骤 1：提取已知条件\n-   **系统**：离散时间时钟同步 RTL 系统，时间索引 $t \\in \\mathbb{N}$。\n-   **握手**：$h(t) = m\\_{\\mathrm{valid}}(t) \\land s\\_{\\mathrm{ready}}(t)$。\n-   **稳定性规则**：若 $m\\_{\\mathrm{valid}}(t) = 1$ 且无握手，则有效载荷 $p(t)$ 必须等于 $p(t-1)$。\n-   **写协议**：AW 握手和 W 握手必须在 B 通道响应 ($s\\_{\\mathrm{bvalid}}(t)=1$) 可以被断言之前发生。\n-   **读协议**：AR 握手必须在 R 通道响应 ($s\\_{\\mathrm{rvalid}}(t)=1$) 可以被断言之前发生。\n-   **约束**：由从设备强制执行单笔未完成事务；如果一个事务处于活动状态，新事务的 ready 信号将被撤销断言。\n-   **内存**：$4$ 个寄存器，每个 $32$ 位，位于字节地址 $\\{0, 4, 8, 12\\}$，全部初始化为 $0$。索引 $i = \\mathrm{addr}/4$。\n-   **主设备输入**：$m\\_{\\mathrm{awvalid}}$, $m\\_{\\mathrm{awaddr}}$, $m\\_{\\mathrm{wvalid}}$, $m\\_{\\mathrm{wdata}}$, $m\\_{\\mathrm{bready}}$, $m\\_{\\mathrm{arvalid}}$, $m\\_{\\mathrm{araddr}}$, $m\\_{\\mathrm{rready}}$ 的时间序列数据。\n-   **从设备输出**：$s\\_{\\mathrm{awready}}$, $s\\_{\\mathrm{wready}}$, $s\\_{\\mathrm{bvalid}}$, $s\\_{\\mathrm{arready}}$, $s\\_{\\mathrm{rvalid}}$, $s\\_{\\mathrm{rdata}}$ 的时间序列数据。\n-   **FSM 行为**：基于事务状态断言 ready 和 valid 信号的具体规则。写操作在首次断言 $s\\_{\\mathrm{bvalid}}(t)$ 时提交到内存。读数据在接受读地址时获取。\n-   **违规检测**：计算主设备有效载荷在其 valid 信号被断言且未发生握手时值发生变化的实例次数。\n-   **输出格式**：对于每个测试用例，必须生成一个列表 $[w, r, v, c]$，其中 $w$ 是完成的写操作数， $r$ 是完成的读操作数， $v$ 是稳定性违规数， $c$ 是一个校验和。\n-   **测试套件**：提供了四个测试用例，包含在规定周期数内的特定输入信号轨迹。\n\n### 步骤 2：使用提取的已知条件进行验证\n-   **科学依据**：该问题牢固地植根于数字逻辑设计、计算机体系结构和总线协议 (AXI) 的原理。它是该领域一个标准且实际的问题。\n-   **问题定义明确**：该问题为从设备 FSM 提供了一套确定性的规则和固定的输入激励。所需的输出被清晰且无歧义地定义。可以推导出一个唯一的、稳定的解决方案。\n-   **客观性**：语言精确且技术性强，没有主观性。\n-   **不完整性/矛盾**：规则是自洽的，足以构建一个确定性的仿真。单笔未完成事务规则简化了 FSM 设计，并与其他规则保持一致。协议顺序与 AXI 规范的一个简化子集相匹配。\n\n### 步骤 3：结论与行动\n问题是有效的。这是一个定义明确、有科学依据的 RTL 建模练习。\n\n### 基于原则的设计与解决方案\n该解决方案是对 AXI-Lite 从设备进行周期精确的 RTL 仿真。从设备的核心是一个控制协议流程的有限状态机 (FSM)。仿真以离散的时间步长（或时钟周期）$t$ 进行。\n\n#### FSM 状态定义\n为了正确管理 AXI-Lite 协议顺序和单笔未完成事务约束，FSM 设计有以下状态：\n-   `S_IDLE`: 初始状态。没有事务处于活动状态。从设备准备好接受新的写地址（AW 通道）、新的写数据（W 通道）或新的读地址（AR 通道）。因此，$s\\_{\\mathrm{awready}}$、$s\\_{\\mathrm{wready}}$ 和 $s\\_{\\mathrm{arready}}$ 被断言。\n-   `S_GOT_AW`: 从设备已接受一个写地址（发生 AW 握手），现在正在等待相应的写数据（W 通道）。它断言 $s\\_{\\mathrm{wready}}=1$，但对任何新事务撤销 ready 信号的断言。\n-   `S_GOT_W`: 从设备已接受写数据（发生 W 握手），现在正在等待写地址（AW 通道）。它断言 $s\\_{\\mathrm{awready}}=1$。此状态处理写数据在地址之前到达的情况。\n-   `S_WRITE_RESP`: 写事务的 AW 和 W 握手均已发生。进入此状态时，从设备将其内部寄存器文件中的写操作提交。它断言 $s\\_{\\mathrm{bvalid}}=1$ 并等待主设备接受响应 ($m\\_{\\mathrm{bready}}=1$）。\n-   `S_READ_RESP`: 从设备已接受一个读地址（发生 AR 握手）。进入此状态时，它从指定的寄存器中获取数据。它断言 $s\\_{\\mathrm{rvalid}}=1$ 并在 $s\\_{\\mathrm{rdata}}$ 上驱动获取的数据，等待主设备接受它 ($m\\_{\\mathrm{rready}}=1$）。\n\n#### 仿真循环\n仿真逐周期进行。对于每个周期 $t$，按模拟同步数字逻辑的顺序执行以下操作：\n1.  **状态进入动作**：在一个周期的开始，执行由前一个周期的状态转换触发的动作。具体来说，进入 `S_WRITE_RESP` 时，写操作被提交到内部寄存器阵列。进入 `S_READ_RESP` 时，获取读数据。\n2.  **组合逻辑**：从设备在当前周期 $t$ 的输出信号（$s\\_{\\mathrm{awready}}$、$s\\_{\\mathrm{wready}}$ 等）基于 FSM 的当前状态 (`fsm_state(t)`) 确定。\n3.  **握手计算**：握手信号（$h\\_{\\mathrm{aw}}(t)$、$h\\_{\\mathrm{w}}(t)$ 等）通过对每个通道的主设备 valid 信号和从设备 ready 信号进行逻辑与运算来计算。\n4.  **违规检测**：检查主设备的有效载荷稳定性。如果在周期 $t-1$ 到 $t$ 之间，AW、W 或 AR 通道上的有效载荷值发生变化，且相应 valid 信号在两个周期中都被断言，并且在 $t-1$ 时没有发生握手，则计为一次违规。\n5.  **时序逻辑（下一状态计算）**：FSM 的下一周期状态 `fsm_state(t+1)` 是根据当前状态 `fsm_state(t)` 和在 $t$ 时刻计算出的握手信号来确定的。内部从设备寄存器（例如，用于暂存地址和数据）也根据握手进行更新。\n6.  **时钟边沿**：所有状态元件（FSM 状态、暂存的数据值以及用于违规检查的寄存器）都更新为其新计算的“下一状态”值，为周期 $t+1$ 做准备。\n\n#### 校验和计算\n最终校验和 $c$ 按规定计算：它是所有已完成读事务期间传递的数据值的总和，加上仿真结束后所有四个内存映射寄存器中最终值的总和。\n\n这种基于原则、基于状态的设计确保了仿真能正确地模拟同步数字电路的行为，并遵守问题中指定的所有协议规则。",
            "answer": "```c\n/* 由于生成错误，此解决方案的代码不可用。 */\n```"
        },
        {
            "introduction": "最后的这项实践将你从逻辑建模带向连接逻辑与物理现实的桥梁，通过实现一个有符号除法单元来完成。你不仅要为一个复杂的算术算法设计数据路径和控制状态机，还要分析其时序性能。通过计算设计是否满足建立时间（setup time）和保持时间（hold time）约束，你将学习到逻辑RTL描述如何受到硬件物理特性的制约，这是任何真实世界数字设计中的一个关键考量 。",
            "id": "3672629",
            "problem": "设计一个完整、可运行的程序，该程序模拟一个由有限状态机 (FSM) 控制的寄存器传输级 (RTL) 有符号恢复型除法单元，并在通过插入中间寄存器来分割长组合路径时执行时序可行性检查。程序必须为每个测试用例计算有符号商、有符号余数、FSM 调度下的总周期数，以及设计是否满足给定\n时钟和器件参数下的建立时间和保持时间约束。所有算术运算均采用二进制补码形式，所有时序值都必须以纳秒 (ns) 为单位。\n\n在同步数字设计的范围内，使用以下基本依据和定义：\n1. 使用字宽为 $W$ 的二进制补码表示有符号整数。\n2. 恢复型除法算法采用逐位迭代，通过 FSM 微操作控制的算术右移或左移以及减法-恢复决策来更新部分余数和商。\n3. 同步时序约束由寄存器到寄存器的路径决定，其中每个寄存器都有时钟到Q端时间、建立时间和保持时间，寄存器之间的组合逻辑具有传播延迟。\n4. 时钟偏斜是启动寄存器和捕获寄存器时钟到达时间之间的确定性偏移，并被视为一个已知参数。\n\n你的程序必须实现以下建模假设和计算：\n- 有符号恢复型除法的建模假设：\n  - 操作数是 $N$（被除数）和 $D$（除数），每个都限制在 $W$ 位二进制补码范围内。\n  - 检测到除以零的情况；单元将商设置为 $0$，余数设置为 $N$，FSM 中止迭代。\n  - 对于 $D \\neq 0$ 的情况，FSM 对绝对值执行恢复型除法，并在末尾进行符号校正：商的符号为 $\\operatorname{sgn}(N)\\cdot\\operatorname{sgn}(D)$，余数的符号为 $\\operatorname{sgn}(N)$。\n- FSM 周期计算：\n  - FSM 使用一个周期进行初始化，对于流水线深度为 $K \\in \\{1,2\\}$ 的主迭代，每位使用 $K$ 个周期，以及一个周期用于最终的符号校正。因此，对于 $D \\neq 0$，总周期为 $K\\cdot W + 2$。对于 $D = 0$，FSM 在一个周期内检测到该情况，并且不执行更多周期。\n- 用于时序分析的组合数据路径划分：\n  - 每次迭代的数据路径包含一个移位器/多路复用器模块（延迟为 $d_{sh,\\max}$ 和 $d_{sh,\\min}$）、一个减法器/比较器模块（延迟为 $d_{sub,\\max}$ 和 $d_{sub,\\min}$）和一个加回模块（延迟为 $d_{add,\\max}$ 和 $d_{add,\\min}$）。\n  - 当 $K = 1$ 时，这三个模块在一个周期内形成一个单一的寄存器到寄存器路径。当 $K = 2$ 时，通过插入一个中间寄存器将路径分割开，使得第 1 级包含移位器加减法器，第 2 级包含加回模块。\n  - 符号校正阶段是一个独立的寄存器到寄存器路径，其延迟为 $d_{sign,\\max}$ 和 $d_{sign,\\min}$。\n- 时序约束检查：\n  - 程序必须确定每个活动的寄存器到寄存器阶段是否满足建立和保持约束。这些检查必须基于同步时序的成熟理论：\n    - 对于建立时间，必须将启动寄存器的最大时钟到Q端延迟、最大组合延迟、捕获寄存器的建立时间以及时钟偏斜结合起来，以检查相对于时钟周期的可行性。\n    - 对于保持时间，必须将启动寄存器的最小时钟到Q端延迟、最小组合延迟、捕获寄存器的保持时间以及时钟偏斜结合起来，以防止过早的数据捕获违规。\n  - 整体建立时间可行性为真，当且仅当对于给定的 $K$，FSM 所使用的设计中所有阶段都满足建立约束。整体保持时间可行性为真，当且仅当设计中所有阶段都满足保持约束。\n- 单位：\n  - 所有时序参数和时钟周期值都必须解释为纳秒。不允许使用其他单位。\n\n你的程序应生成单行输出，其中包含一个逗号分隔的列表，列表中的每个元素是每个测试用例的结果包，格式为 [q,r,cycles,setup_ok,hold_ok]。其中，$q$ 和 $r$ 为有符号整数，$cycles$ 为整数，$setup\\_ok$ 和 $hold\\_ok$ 为布尔值，用 $0$ 或 $1$ 表示。\n\n测试套件：\n使用以下四个测试用例，涵盖一般行为、流水线分割可行性、除零处理和刻意的保持时间压力情况。所有时序参数均以纳秒为单位。\n\n1. 情况 A：\n   - $W = 8$, $N = -73$, $D = 9$, $K = 1$\n   - $T_{clk} = 2.0$\n   - $T_{cq,\\max} = 0.08$, $T_{cq,\\min} = 0.05$\n   - $T_{setup} = 0.07$, $T_{hold} = 0.04$, $D_{skew} = 0.02$\n   - $d_{sh,\\max} = 0.30$, $d_{sh,\\min} = 0.10$\n   - $d_{sub,\\max} = 0.50$, $d_{sub,\\min} = 0.20$\n   - $d_{add,\\max} = 0.40$, $d_{add,\\min} = 0.15$\n   - $d_{sign,\\max} = 0.20$, $d_{sign,\\min} = 0.10$\n2. 情况 B：\n   - $W = 16$, $N = 32767$, $D = -1$, $K = 2$\n   - $T_{clk} = 1.0$\n   - $T_{cq,\\max} = 0.10$, $T_{cq,\\min} = 0.06$\n   - $T_{setup} = 0.08$, $T_{hold} = 0.05$, $D_{skew} = 0.02$\n   - $d_{sh,\\max} = 0.35$, $d_{sh,\\min} = 0.12$\n   - $d_{sub,\\max} = 0.55$, $d_{sub,\\min} = 0.25$\n   - $d_{add,\\max} = 0.45$, $d_{add,\\min} = 0.18$\n   - $d_{sign,\\max} = 0.25$, $d_{sign,\\min} = 0.12$\n3. 情况 C：\n   - $W = 12$, $N = -2048$, $D = 0$, $K = 1$\n   - $T_{clk} = 1.5$\n   - $T_{cq,\\max} = 0.08$, $T_{cq,\\min} = 0.05$\n   - $T_{setup} = 0.07$, $T_{hold} = 0.04$, $D_{skew} = 0.02$\n   - $d_{sh,\\max} = 0.32$, $d_{sh,\\min} = 0.11$\n   - $d_{sub,\\max} = 0.50$, $d_{sub,\\min} = 0.22$\n   - $d_{add,\\max} = 0.42$, $d_{add,\\min} = 0.16$\n   - $d_{sign,\\max} = 0.20$, $d_{sign,\\min} = 0.10$\n4. 情况 D：\n   - $W = 4$, $N = 7$, $D = 2$, $K = 2$\n   - $T_{clk} = 5.0$\n   - $T_{cq,\\max} = 0.10$, $T_{cq,\\min} = 0.01$\n   - $T_{setup} = 0.08$, $T_{hold} = 0.30$, $D_{skew} = 0.02$\n   - $d_{sh,\\max} = 0.20$, $d_{sh,\\min} = 0.02$\n   - $d_{sub,\\max} = 0.30$, $d_{sub,\\min} = 0.03$\n   - $d_{add,\\max} = 0.25$, $d_{add,\\min} = 0.04$\n   - $d_{sign,\\max} = 0.15$, $d_{sign,\\min} = 0.05$\n\n最终输出格式：\n你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表，每个测试用例的结果本身也是一个方括号括起来的逗号分隔列表，顺序为 $[q,r,cycles,setup\\_ok,hold\\_ok]$。例如：\"[[q1,r1,c1,s1,h1],[q2,r2,c2,s2,h2],[q3,r3,c3,s3,h3],[q4,r4,c4,s4,h4]]\"。",
            "solution": "用户提供的问题是有效的，因为它在计算机体系结构和数字逻辑设计领域具有科学依据、内容完整且定义明确。它要求实现标准的恢复型除法算法，并应用基本的同步时序分析原理。所有用于获得唯一、可验证解的必要参数和定义都已提供。\n\n解决此问题的方法论包含三个主要部分：对有符号恢复型除法算法进行建模，计算有限状态机 (FSM) 的控制流和周期数，以及基于标准同步设计约束执行严格的时序可行性分析。\n\n首先，实现有符号恢复型除法。问题规定，除法应在被除数 $N$ 和除数 $D$ 的绝对值上执行，然后进行符号校正步骤。商 $Q$ 的符号由 $N$ 和 $D$ 符号的异或运算决定，即 $\\operatorname{sgn}(Q) = \\operatorname{sgn}(N) \\oplus \\operatorname{sgn}(D)$。余数 $R$ 的符号与被除数 $N$ 的符号相同，即 $\\operatorname{sgn}(R) = \\operatorname{sgn}(N)$。这确保了对于二进制补码算术，除法恒等式 $N = D \\cdot Q + R$ 成立，其中 $0 \\le |R|  |D|$。除数为零（$D=0$）的情况作为特殊条件处理，此时商设为 $0$，余数设为被除数 $N$ 的值。\n\n对于无符号操作数，恢复型除法算法的核心是一个迭代过程。对于一个 $W$ 位的被除数和除数，算法执行 $W$ 次迭代。使用一个双倍宽度的寄存器，概念上表示为 $[A,Q]$，其中 $A$ 是累加器（初始为 $0$），$Q$ 存放被除数。在每个步骤中，寄存器对 $[A,Q]$ 左移一位。然后从累加器 $A$ 中尝试减去除数。如果结果非负，则减法成功，$Q$ 的最低有效位被置为 $1$。如果结果为负，则减法不成功，将除数加回到 $A$ 中以恢复其先前的值，并且 $Q$ 的最低有效位置为 $0$。经过 $W$ 次迭代后，$Q$ 中保存商，$A$ 中保存余数。\n\n其次，计算基于 FSM 的周期数。对于非零除数，总周期数包括三个阶段：$1$ 个初始化周期，主迭代除法过程的 $K \\cdot W$ 个周期（其中 $K$ 是迭代阶段的流水线深度），以及 $1$ 个最终符号校正周期，总计 $K \\cdot W + 2$ 个周期。对于零除数，FSM 在一个周期内检测到该情况并中止。\n\n第三，进行详细的时序分析，以验证设计是否满足给定钟周期 $T_{clk}$ 下的性能和可靠性目标。这包括检查由 FSM 操作决定的所有活动寄存器到寄存器路径的建立时间和保持时间约束。\n建立时间约束确保数据在下一个有效时钟沿到来之前足够早地到达捕获寄存器的输入端。其控制不等式为：\n$$T_{clk} \\ge T_{cq,\\max} + T_{comb,\\max} + T_{setup} + D_{skew}$$\n其中 $T_{cq,\\max}$ 是启动寄存器的最大时钟到Q端延迟，$T_{comb,\\max}$ 是组合逻辑路径的最大延迟，$T_{setup}$ 是捕获寄存器的建立时间，$D_{skew}$ 是时钟偏斜，在最坏情况下，它会缩短有效时钟周期。\n\n保持时间约束确保数据在有效时钟沿到达后，在捕获寄存器的输入端保持足够长的稳定时间。其控制不等式为：\n$$T_{cq,\\min} + T_{comb,\\min} \\ge T_{hold} + D_{skew}$$\n其中 $T_{cq,\\min}$ 是最小时钟到Q端延迟，$T_{comb,\\min}$ 是最小组合逻辑延迟，$T_{hold}$ 是捕获寄存器的保持时间，$D_{skew}$ 同样在最坏情况下被假定为使保持条件更难满足。\n\n组合路径的结构取决于流水线深度 $K$：\n-   对于 $K=1$，整个迭代逻辑（移位器、减法器、加回器）形成一个单一的组合路径，其延迟为 $T_{comb,\\max} = d_{sh,\\max} + d_{sub,\\max} + d_{add,\\max}$ 和 $T_{comb,\\min} = d_{sh,\\min} + d_{sub,\\min} + d_{add,\\min}$。\n-   对于 $K=2$，路径被一个中间寄存器分成两个阶段。第 1 阶段（移位器 + 减法器）的延迟为 $T_{comb1,\\max} = d_{sh,\\max} + d_{sub,\\max}$（以及相应的最小延迟）。第 2 阶段（加回器）的延迟为 $T_{comb2,\\max} = d_{add,\\max}$。两个阶段都必须独立满足建立和保持约束。\n\n此外，独立的符号校正逻辑形成其自己的寄存器到寄存器路径，延迟为 $d_{sign,\\max}$ 和 $d_{sign,\\min}$。根据问题描述，当且仅当给定操作中 *FSM 使用的* 所有阶段都满足其建立约束时，整体设计的建立时间才被认为是可行的（`setup_ok` = $1$）。同样的逻辑适用于保持时间可行性（`hold_ok`）。这意味着对于除零操作，由于迭代和符号校正阶段被 FSM 绕过，它们的时序约束不计入该特定操作的最终判定。\n\n例如，在测试用例 B 中，当 $W=16$, $N=32767$, $D=-1$, $K=2$ 时，除法在 $2 \\cdot 16 + 2 = 34$ 个周期内得出 $Q=-32767$ 和 $R=0$。对于 $T_{clk}=1.0\\text{ ns}$ 的时序分析：\n-   流水线第 1 阶段（移位器 + 减法器）：\n    -   $T_{comb1,\\max} = 0.35 + 0.55 = 0.90\\text{ ns}$。\n    -   建立时间检查：$T_{cq,\\max} + T_{comb1,\\max} + T_{setup} + D_{skew} = 0.10 + 0.90 + 0.08 + 0.02 = 1.10\\text{ ns}$。由于 $T_{clk}  1.10\\text{ ns}$，该阶段违反了建立时间约束。\n-   流水线第 2 阶段（加回器）：\n    -   $T_{comb2,\\max} = 0.45\\text{ ns}$。\n    -   建立时间检查：$T_{cq,\\max} + T_{comb2,\\max} + T_{setup} + D_{skew} = 0.10 + 0.45 + 0.08 + 0.02 = 0.65\\text{ ns}$。由于 $T_{clk} \\ge 0.65\\text{ ns}$，该阶段通过了建立时间检查。\n-   符号校正阶段通过了建立时间检查，所有阶段都通过了各自的保持时间检查。\n由于第 1 阶段的建立时间约束失败，因此该案例的整体 `setup_ok` 为 $0$（假），尽管与非流水线（$K=1$）版本相比，流水线技术帮助减少了关键路径延迟。完整的实现会为所有四个测试用例计算这些值。",
            "answer": "```c\n/* 由于生成错误，此解决方案的代码不可用。 */\n```"
        }
    ]
}