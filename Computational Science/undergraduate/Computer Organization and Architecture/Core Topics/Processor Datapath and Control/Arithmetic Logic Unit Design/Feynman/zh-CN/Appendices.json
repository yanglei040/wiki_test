{
    "hands_on_practices": [
        {
            "introduction": "算术逻辑单元（ALU）的核心是其执行算术运算的能力。第一个练习将通过一个基本但至关重要的例子，巩固使用二进制补码进行减法的基本技术，这是现代处理器普遍采用的方法。亲手完成这个计算过程，是理解硬件如何执行这些操作的第一步 ()。",
            "id": "1914971",
            "problem": "一位工程师正在调试一个4位嵌入式控制器原型的算术逻辑单元 (ALU)。该 ALU 设计使用补码方法来实现减法。具体来说，为了计算 $A - B$，ALU 会计算减数 $B$ 的补码，并将其加到被减数 $A$ 上。所有数字都使用固定宽度的4位补码格式表示。\n\n运行一个测试用例来评估涉及两个负数的运算：$-3 - (-6)$。在此操作成功完成后，ALU 的输出寄存器中应该出现的最终4位二进制字符串是什么？\n\nA. `0011`\n\nB. `1000`\n\nC. `1010`\n\nD. `1101`\n\nE. `1001`",
            "solution": "我们在固定宽度的4位补码环境下进行计算，其可表示的范围是从 $-8$ 到 $+7$。该运算为 $A - B$，其中 $A=-3$ 且 $B=-6$，实现为 $A + (\\text{two’s complement of }B)$。\n\n首先，对操作数进行编码：\n- $+3$ 是 $0011_{2}$，因此 $-3$ 是通过将所有位取反再加 $1$ 得到的：$0011_{2} \\to 1100_{2} \\to 1101_{2}$。所以 $A=-3$ 是 $1101_{2}$。\n- $+6$ 是 $0110_{2}$，因此 $-6$ 是 $0110_{2} \\to 1001_{2} \\to 1010_{2}$。所以 $B=-6$ 是 $1010_{2}$。\n\n为了计算 $A - B$，我们求出减数 $B$ 的补码，然后加到 $A$ 上：\n- $B=1010_{2}$ 的补码：将其各位取反得到 $0101_{2}$，再加 $1$ 得到 $0110_{2}$。\n\n现在加到 $A$ 上：\n$$1101_{2} + 0110_{2} = 1\\,0011_{2}.$$\n在4位补码运算中，最高有效位的进位被丢弃，剩下\n$$0011_{2},$$\n它代表 $3$，与 $-3 - (-6) = 3$ 的结果一致。\n\n因此，正确的4位输出是 0011，对应选项 A。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "在掌握了基本算术之后，我们需要认识到，真实的ALU必须高效地实现多种操作。这个实践将我们带入逻辑设计的领域，挑战你实现一个“条件取反”功能，同时最小化处理延迟。这个问题演示了工程师如何在不同的电路实现方案之间进行权衡，以达到最佳性能，这是计算机体系结构中的一项核心任务 ()。",
            "id": "3620734",
            "problem": "一个算术逻辑单元（ALU）对 $n$ 位二进制补码整数进行操作，必须实现一个条件取反操作，该操作根据单位谓词 $p \\in \\{0,1\\}$ 输出 $A$ 或 $-A$。该 ALU 使用一个延迟为 $t_{\\text{adder}} = 300\\,\\text{ps}$ 的超前进位加法器级。可用的基本组件及其延迟为：按位异或门（XOR）的延迟 $t_{\\text{xor}} = 40\\,\\text{ps}$，按位反相器的延迟 $t_{\\text{inv}} = 30\\,\\text{ps}$，以及 $2$选$1$多路复用器（MUX）的延迟 $t_{\\text{mux}} = 60\\,\\text{ps}$。不能引入额外的流水线级；实现必须是纯组合逻辑，并且必须复用现有的加法器级。目标是在保证对所有 $A$ 和 $p$ 的两个值都能产生正确结果的同时，最小化相对于现有加法路径的最坏情况附加延迟。\n\n哪个选项在实现正确性的同时，相对于加法器基线最小化了最坏情况下的附加延迟？\n\nA. 将 $A$ 的每一位通过一个由 $p$ 控制的按位异或门，形成 $A' = A \\oplus p$，将 $A'$ 送入现有加法器，另一个操作数接 $0$，并将加法器的进位输入设置为 $p$。使用加法器的和作为最终输出，不使用输出级多路复用器。\n\nB. 通过按位反相器对 $A$ 进行反相，并使用现有加法器加 $1$，来构建一个并行的取反路径。同时，用原始的 $A$ 旁路加法器。在输出端，使用一个由 $p$ 控制的多路复用器在旁路的 $A$ 和计算出的负值之间进行选择。\n\nC. 在加法器前放置一个按位输入多路复用器，在 $p$ 的控制下，选择 $A$ 或其按位反码 $\\overline{A}$ 作为加法器输入。将另一个加法器操作数接 $0$，并将加法器的进位输入设置为 $p$。使用加法器的和作为最终输出。\n\nD. 完全避免按位反相：将 $A$ 直接送入加法器，另一个操作数接 $0$，并将进位输入设置为 $p$。使用加法器的和作为最终输出，并声称仅靠进位输入就足以实现条件取反。",
            "solution": "### 问题验证\n\n#### 步骤1：提取已知条件\n- ALU 对 $n$ 位二进制补码整数进行操作。\n- 需要实现的操作是条件取反：如果谓词 $p=0$，输出为 $A$；如果 $p=1$，输出为 $-A$。谓词 $p \\in \\{0, 1\\}$。\n- ALU 有一个现有的超前进位加法器级，延迟为 $t_{\\text{adder}} = 300\\,\\text{ps}$。\n- 可用的基本组件及其延迟：\n  - 按位异或门（XOR）：$t_{\\text{xor}} = 40\\,\\text{ps}$。\n  - 按位反相器（INV）：$t_{\\text{inv}} = 30\\,\\text{ps}$。\n  - $2$选$1$多路复用器（MUX）：$t_{\\text{mux}} = 60\\,\\text{ps}$。\n- 约束条件：\n  - 实现必须是纯组合逻辑。\n  - 不能引入额外的流水线级。\n  - 必须复用现有的加法器级。\n- 目标：在确保对所有输入 $A$ 和 $p$ 的值都正确的同时，最小化相对于现有加法路径的最坏情况附加延迟。\n\n#### 步骤2：使用提取的已知条件进行验证\n1.  **科学依据**：该问题设置在数字逻辑设计和计算机体系结构的背景下，特别是 ALU 设计。它利用了标准的二进制补码表示法来表示有符号整数，以及标准的逻辑门（XOR、INV、MUX）和加法器。使用这些组件实现条件取反是该领域的一个基本课题。其原理是科学合理的。\n2.  **定义明确**：问题定义清晰。它提供了一个明确的目标（最小化附加延迟）、一系列约束条件（组合逻辑、复用加法器、无新流水线级）以及具体的组件延迟。这允许对不同的实现策略进行定量比较。可以在选项中确定唯一的最佳解决方案。\n3.  **客观性**：问题使用电气工程和计算机科学中常见的精确技术语言进行陈述。没有主观或模糊的术语。\n\n#### 步骤3：结论与行动\n问题陈述是**有效的**。它具有科学依据，定义明确且客观，提出了一个标准的工程权衡分析问题。我现在将通过分析每个选项来解决这个问题。\n\n### 求解过程\n\n核心任务是实现一个函数 $f(A, p)$，使得：\n- 如果 $p=0$，输出为 $A$。\n- 如果 $p=1$，输出为 $-A$。\n\n在一个 $n$ 位二进制补码系统中，一个数 $A$ 的负数，记作 $-A$，是通过对其进行按位取反（反相）再加 $1$ 来计算的：\n$$ -A = \\overline{A} + 1 $$\n这个操作必须使用提供的组件和现有的加法器来实现。目标是找到具有最低最坏情况延迟的正确实现。加法器路径的基线延迟为 $t_{\\text{adder}} = 300\\,\\text{ps}$。任何额外的逻辑都会增加这个基线延迟。\n\n我们来分析每个选项。\n\n#### 选项 A\n- **实现方式**：加法器的输入是 $A' = A \\oplus p$。这是一个按位操作，其中每一位 $A_i$ 与单位比特 $p$ 进行异或。加法器的另一个操作数设置为整数 $0$，加法器的进位输入设置为 $p$。最终输出是加法器的和。\n- **正确性分析**：\n  - 如果 $p=0$：操作变为 $(A \\oplus 0) + 0$，进位输入为 $0$。因为 $A \\oplus 0 = A$，所以结果是 $A+0 = A$。这是正确的。\n  - 如果 $p=1$：操作变为 $(A \\oplus 1) + 0$，进位输入为 $1$。按位操作 $A \\oplus 1$ 等同于按位取反 $\\overline{A}$。因此，加法器计算 $\\overline{A} + 0 + 1$，即 $\\overline{A} + 1$。这是二进制补码中 $-A$ 的定义。这是正确的。\n- **延迟分析**：加法器的输入必须在它开始操作前稳定。操作数 $A'$ 是由一组异或门生成的。生成 $A'$ 的延迟是 $t_{\\text{xor}}$。另一个操作数（$0$）和进位输入（$p$）是主输入，假定在时间 $0$ 就绪。关键路径是通过异或门，然后是加法器。\n  $$ \\text{总延迟 (A)} = t_{\\text{xor}} + t_{\\text{adder}} = 40\\,\\text{ps} + 300\\,\\text{ps} = 340\\,\\text{ps} $$\n- **结论**：**正确**。附加延迟为 $40\\,\\text{ps}$。\n\n#### 选项 B\n- **实现方式**：使用两条并行的计算路径。一条路径旁路加法器，将 $A$ 直接送到输出多路复用器的输入端。另一条路径计算 $-A$，方法是先将 $A$ 反相（得到 $\\overline{A}$），然后使用加法器计算 $\\overline{A} + 1$（通过将 $\\overline{A}$ 和 $0$ 送到加法器输入端，并设置进位输入为 $1$）。由 $p$ 控制的输出多路复用器在 $A$ 和 $-A$ 之间进行选择。\n- **正确性分析**：\n  - 如果 $p=0$：多路复用器选择旁路的输入，即 $A$。这是正确的。\n  - 如果 $p=1$：多路复用器选择加法器路径的输出。加法器计算 $\\overline{A}+1$，即 $-A$。这是正确的。\n- **延迟分析**：最终输出来自多路复用器。其延迟是在其输入稳定后增加的。关键路径是耗时最长的那条。\n  - $A$ 到多路复用器输入的路径：假定延迟可忽略不计。\n  - $-A$ 到多路复用器输入的路径：这涉及到反相器和加法器。加法器的输入 $\\overline{A}$ 在 $t_{\\text{inv}}$ 后就绪。然后加法器的输出在另外的 $t_{\\text{adder}}$ 后就绪。所以 $-A$ 信号在时间 $t_{\\text{inv}} + t_{\\text{adder}}$ 到达多路复用器。\n  - 最终输出在多路复用器延迟后就绪。最坏情况路径决定了延迟。\n  $$ \\text{总延迟 (B)} = t_{\\text{inv}} + t_{\\text{adder}} + t_{\\text{mux}} = 30\\,\\text{ps} + 300\\,\\text{ps} + 60\\,\\text{ps} = 390\\,\\text{ps} $$\n- **结论**：**正确**。附加延迟为 $t_{\\text{inv}} + t_{\\text{mux}} = 90\\,\\text{ps}$。\n\n#### 选项 C\n- **实现方式**：在加法器前放置一组输入多路复用器。在 $p$ 的控制下，每个多路复用器为位 $A_i$ 选择 $A_i$ 或其反码 $\\overline{A_i}$。多路复用器的输出被送入加法器的一个操作数。另一个加法器操作数是 $0$，进位输入设置为 $p$。\n- **正确性分析**：\n  - 如果 $p=0$：多路复用器选择 $A$。加法器进位输入为 $0$。加法器计算 $A + 0 + 0 = A$。这是正确的。\n  - 如果 $p=1$：多路复用器选择 $\\overline{A}$。加法器进位输入为 $1$。加法器计算 $\\overline{A} + 0 + 1 = \\overline{A} + 1$，即 $-A$。这是正确的。\n- **延迟分析**：信号必须通过加法器前的逻辑。多路复用器的输入是 $A$（在时间 $0$ 就绪）和 $\\overline{A}$。$\\overline{A}$ 在反相器延迟 $t_{\\text{inv}}$ 后就绪。然后多路复用器的输出在额外的 $t_{\\text{mux}}$ 后稳定。这个多路复用器的输出是加法器的输入。\n  $$ \\text{加法器前延迟} = t_{\\text{inv}} + t_{\\text{mux}} = 30\\,\\text{ps} + 60\\,\\text{ps} = 90\\,\\text{ps} $$\n  总延迟是加法器前逻辑延迟和加法器延迟之和。\n  $$ \\text{总延迟 (C)} = (t_{\\text{inv}} + t_{\\text{mux}}) + t_{\\text{adder}} = 90\\,\\text{ps} + 300\\,\\text{ps} = 390\\,\\text{ps} $$\n- **结论**：**正确**。附加延迟为 $t_{\\text{inv}} + t_{\\text{mux}} = 90\\,\\text{ps}$。\n\n#### 选项 D\n- **实现方式**：$A$ 直接送入加法器的一个操作数。另一个操作数是 $0$。进位输入设置为 $p$。输出是加法器的和。\n- **正确性分析**：加法器计算 $A + 0 + p = A+p$。\n  - 如果 $p=0$：结果是 $A+0 = A$。这是正确的。\n  - 如果 $p=1$：结果是 $A+1$。这不是 $-A$。对于几乎所有的 $A$ 值，$A+1 \\neq \\overline{A}+1$。例如，如果 $A=1$，那么 $A+1=2$，但 $-A=-1$。\n- **结论**：**不正确**。该逻辑没有正确计算负值。\n\n### 比较与结论\n\n我们根据三个正确选项（A、B 和 C）的最坏情况延迟来比较它们，这等同于最小化附加延迟。\n\n- **延迟(A)**：$340\\,\\text{ps}$ (附加延迟: $40\\,\\text{ps}$)\n- **延迟(B)**：$390\\,\\text{ps}$ (附加延迟: $90\\,\\text{ps}$)\n- **延迟(C)**：$390\\,\\text{ps}$ (附加延迟: $90\\,\\text{ps}$)\n\n选项 A 中描述的实现具有最低的总延迟，因此相对于加法器基线具有最小的附加延迟。它通过利用异或门的一个巧妙特性来执行条件反相，这比其他正确选项所需的 INV+MUX 组合要快。\n\n因此，选项 A 是最优选择。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "ALU的工作不仅是计算出结果，还必须通过状态标志准确地报告结果的性质。最后一个练习聚焦于无符号进位（$C$ 标志）和有符号溢出（$V$ 标志）这两个关键概念之间的区别，要求你设计一个特定的测试用例来将两者分离开。理解如何构造输入以操控并正确解读这些标志，对于编写正确的底层代码和设计稳健的CPU控制逻辑至关重要 ()。",
            "id": "3620758",
            "problem": "一个算术逻辑单元（ALU）对 $n$ 位操作数执行定宽二进制补码加法。在宽度为 $n$ 的二进制补码表示法中，可表示的整数范围是 $[-2^{n-1}, 2^{n-1}-1]$，并且二进制加法是模 $2^{n}$ 运算。该ALU为操作数 $A$ 和 $B$ 的加法生成两个状态标志：\n- 进位标志 $C$ 是在执行模 $2^{n}$ 加法时，$n$ 位加法器的最高有效位（位索引 $n-1$）产生的进位输出。\n- 有符号溢出标志 $V$ 被设置，当且仅当二进制补码和在解释为有符号整数时无法用 $n$ 位表示；等价地，$V$ 被设置的精确条件是，当两个符号相同的操作数相加，得到的结果的符号与操作数的符号不同。\n\n考虑一个正在进行单元测试的 $n=8$ 的ALU。您的任务是设计一个单一的定向单元测试，通过触发有符号溢出标志 $V$ 但不触发进位标志 $C$ 来隔离有符号溢出行为。为了消除歧义并确保唯一性，将第二个操作数固定为 $B=1$，并将第一个操作数限制为非负整数 $A \\in [0, 2^{7}-1]$。\n\n请确定满足以下条件的最小的 $A$（十进制）：在 $8$ 位二进制补码中将 $A$ 和 $B$ 相加会产生 $V=1$ 和 $C=0$。请用一个十进制整数表示您的答案。",
            "solution": "问题要求在指定范围内找到最小的非负整数 $A$，使其在 $8$ 位二进制补码ALU中与固定操作数 $B$ 相加后，有符号溢出标志（$V$）和进位标志（$C$）达到特定状态。\n\n首先，我们根据所提供的信息将问题的参数和约束形式化。\nALU对 $n$ 位操作数进行操作，其中 $n=8$。\n算术是二进制补码。对于 $n=8$，可表示的整数范围是 $[-2^{8-1}, 2^{8-1}-1]$，即 $[-128, 127]$。\n二进制加法是模 $2^8 = 256$ 运算。\n第二个操作数是固定的：$B=1$。\n第一个操作数 $A$ 被限制在非负整数范围内：$A \\in [0, 2^{7}-1]$，简化为 $A \\in [0, 127]$。\n加法 $A+B$ 的期望结果是，有符号溢出标志被设置（$V=1$）而进位标志不被设置（$C=0$）。\n\n我们现在将分别分析每个标志的条件。\n\n**有符号溢出标志的条件（$V=1$）**\n\n问题陈述，有符号溢出标志 $V$ 被设置，当且仅当“两个符号相同的操作数相加，得到的结果的符号与操作数的符号不同”。\n操作数 $A$ 在范围 $[0, 127]$ 内。其值为非负数，所以它的符号位（最高有效位 MSB，位于位置 $n-1=7$）是 $0$。\n操作数 $B=1$ 也是正数，所以它的符号位是 $0$。\n因此，我们是在将两个正数相加。要发生有符号溢出（$V=1$），结果的符号位必须是 $1$，意味着结果是一个负数。\n在 $n$ 位二进制补码系统中，两个正数 $A$ 和 $B$ 的和发生溢出，当且仅当它们的数学和大于可表示的最大正数，即 $2^{n-1}-1$。\n对于 $n=8$，最大正数值是 $2^{7}-1 = 127$。\n因此，溢出的条件是 $A + B > 127$。\n代入给定的值 $B=1$，我们得到：\n$$A + 1 > 127$$\n$$A > 126$$\n\n**进位标志的条件（$C=0$）**\n\n进位标志 $C$ 被定义为 $n$ 位加法器最高有效位（位 $n-1=7$）的进位输出。这等同于说，如果将操作数视为无符号整数，它们的和大于或等于 $2^n$，则 $C=1$。反之，如果无符号和小于 $2^n$，则 $C=0$。\n操作数 $A$ 在范围 $[0, 127]$ 内，所以它的有符号表示与其无符号表示相同。\n操作数 $B=1$ 也是正数，所以它的有符号和无符号表示是相同的。\n设 $A_{unsigned}$ 和 $B_{unsigned}$ 是 $A$ 和 $B$ 位模式的无符号解释。那么 $A_{unsigned} = A$ 且 $B_{unsigned} = B = 1$。\n进位标志为 $0$ 的条件是：\n$$A_{unsigned} + B_{unsigned}  2^n$$\n对于 $n=8$，这变成：\n$$A + 1  256$$\n$$A  255$$\n\n**综合条件**\n\n我们需要找到满足以下所有三个条件的最小整数 $A$：\n1.  $A \\in [0, 127]$（来自问题对 $A$ 的约束）\n2.  $A > 126$（来自 $V=1$ 的条件）\n3.  $A  255$（来自 $C=0$ 的条件）\n\n结合前两个条件，$A \\in [0, 127]$ 和 $A > 126$， $A$ 唯一可能的整数值是 $127$。\n我们必须检查 $A=127$ 是否也满足第三个条件：$127  255$。这是成立的。\n因此，在指定范围内能产生所需标志组合的唯一的 $A$ 值是 $A=127$。由于它是唯一的解，所以它自然是最小的。\n\n**验证**\n\n让我们验证 $A=127$ 和 $B=1$ 的结果。\n在 $8$ 位二进制中：\n$A = 127_{10} = 01111111_2$\n$B = 1_{10} = 00000001_2$\n\n执行二进制加法：\n$$\n\\begin{array}{@{}c@{\\,}c@{}c@{}c@{}c@{}c@{}c@{}c@{}c}\n   0  1  1  1  1  1  1  1 \\\\\n+   0  0  0  0  0  0  0  1 \\\\\n\\hline\n   1  0  0  0  0  0  0  0 \\\\\n\\end{array}\n$$\n$8$ 位结果是 $10000000_2$。\n\n让我们检查此操作的标志：\n- **进位标志 ($C$)**：无符号值的和是 $127 + 1 = 128$。由于 $128  256$，和没有超过 $8$ 位无符号整数的容量。最高有效位（位 $7$）没有进位输出。因此，$C=0$。这符合要求。\n- **有符号溢出标志 ($V$)**：我们将两个正数相加（$A=127$，符号位为 $0$；$B=1$，符号位为 $0$）。结果是 $10000000_2$。在二进制补码中，这表示值 $-128_{10}$，是一个负数（符号位为 $1$）。由于结果的符号与操作数的符号不同，发生了有符号溢出。因此，$V=1$。这符合要求。\n\n值 $A=127$ 满足两个条件（$V=1$ 和 $C=0$），并且是允许范围内最小的此类整数。",
            "answer": "$$\\boxed{127}$$"
        }
    ]
}