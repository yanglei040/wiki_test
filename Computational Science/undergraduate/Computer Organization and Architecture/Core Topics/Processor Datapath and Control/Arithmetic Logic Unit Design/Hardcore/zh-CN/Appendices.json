{
    "hands_on_practices": [
        {
            "introduction": "现代ALU的一个设计精髓在于硬件复用。与其为减法设计一套独立的电路，工程师们巧妙地利用加法器来完成减法运算。这个过程的核心是二进制补码表示法，它使得 $A - B$ 的运算可以转化为 $A$ 与 $B$ 的补码相加。本练习  将带你亲手实践这一基本过程，加深对ALU如何高效执行减法操作的理解。",
            "id": "1914971",
            "problem": "一位工程师正在调试一个4位嵌入式控制器原型的算术逻辑单元 (ALU)。该 ALU 设计使用二补数法来实现减法运算。具体来说，为了计算 $A - B$，ALU 会计算减数 $B$ 的二补数，并将其与被减数 $A$ 相加。所有数字都使用固定宽度的4位二补数格式表示。\n\n运行一个测试用例来评估一个涉及两个负数的运算：$-3 - (-6)$。在该操作成功完成后，ALU 的输出寄存器中应该出现的最终4位二进制字符串是什么？\n\nA. `0011`\n\nB. `1000`\n\nC. `1010`\n\nD. `1101`\n\nE. `1001`",
            "solution": "我们在固定宽度的4位二补数系统中进行计算，其可表示范围是从 $-8$ 到 $+7$。运算为 $A - B$，其中 $A=-3$ 且 $B=-6$，其实现方式为 $A + (\\text{two’s complement of }B)$。\n\n首先，对操作数进行编码：\n- $+3$ 是 $0011_{2}$，所以 $-3$ 是通过将所有位取反再加 $1$ 得到的：$0011_{2} \\to 1100_{2} \\to 1101_{2}$。因此 $A=-3$ 是 $1101_{2}$。\n- $+6$ 是 $0110_{2}$，所以 $-6$ 是 $0110_{2} \\to 1001_{2} \\to 1010_{2}$。因此 $B=-6$ 是 $1010_{2}$。\n\n为了计算 $A - B$，求减数 $B$ 的二补数并与 $A$ 相加：\n- $B=1010_{2}$ 的二补数：取反得到 $0101_{2}$，再加 $1$ 得到 $0110_{2}$。\n\n现在与 $A$ 相加：\n$$1101_{2} + 0110_{2} = 1\\,0011_{2}.$$\n在4位二补数运算中，最高有效位的进位被丢弃，剩下\n$$0011_{2},$$\n其表示的数是 $3$，与 $-3 - (-6) = 3$ 的结果一致。\n\n因此，正确的4位输出是 `0011`，对应于选项 A。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "在掌握了基本运算原理后，真正的工程挑战在于如何高效地实现它们。本练习模拟了一个真实的ALU设计场景：实现一个“条件取反”操作。你需要像硬件工程师一样思考，在多种逻辑门电路方案中进行权衡，选择延迟最低的设计 ，这有助于你理解性能优化在数字逻辑设计中的重要性。",
            "id": "3620734",
            "problem": "一个算术逻辑单元（ALU）对 $n$ 位二进制补码整数进行操作，必须实现一个条件取反操作，该操作根据单位谓词 $p \\in \\{0,1\\}$ 输出 $A$ 或 $-A$。该ALU使用一个延迟为 $t_{\\text{adder}} = 300\\,\\text{ps}$ 的超前进位加法器阶段。可用的基本元件及其延迟为：逐位异或（XOR）门的延迟为 $t_{\\text{xor}} = 40\\,\\text{ps}$，逐位反相器的延迟为 $t_{\\text{inv}} = 30\\,\\text{ps}$，一个 $2$选$1$多路复用器（MUX）的延迟为 $t_{\\text{mux}} = 60\\,\\text{ps}$。不得引入额外的流水线阶段；实现必须是纯组合逻辑，并复用现有的加法器阶段。目标是在保证对所有 $A$ 和 $p$ 的两种取值都产生正确结果的同时，最小化相对于现有加法路径的最坏情况附加延迟。\n\n哪个选项在实现正确性的同时，相对于加法器基线，最小化了最坏情况下的附加延迟？\n\nA. 将 $A$ 的每一位通过一个由 $p$ 控制的逐位XOR门，形成 $A' = A \\oplus p$。将 $A'$ 送入现有加法器，另一个操作数固定为 $0$，并将加法器的进位输入设置为 $p$。使用加法器的和作为最终输出，不使用输出级MUX。\n\nB. 通过使用逐位反相器对 $A$ 取反并使用现有加法器加 $1$ 来构建一个并行的取反路径。同时，用原始的 $A$ 旁路加法器。在输出端，使用一个由 $p$ 控制的MUX在旁路的 $A$ 和计算出的取反结果之间进行选择。\n\nC. 在加法器前放置一个逐位输入MUX，在 $p$ 的控制下，选择 $A$ 或其按位取反 $\\overline{A}$ 作为加法器输入。将另一个加法器操作数固定为 $0$，并将加法器的进位输入设置为 $p$。使用加法器的和作为最终输出。\n\nD. 完全避免按位取反：将 $A$ 直接送入加法器，另一个操作数固定为 $0$，并将进位输入设置为 $p$。使用加法器的和作为最终输出，并声称仅靠进位输入就足以实现条件取反。",
            "solution": "### 问题验证\n\n#### 步骤1：提取已知条件\n- ALU对 $n$ 位二进制补码整数进行操作。\n- 需要实现的操作是条件取反：如果谓词 $p=0$，输出为 $A$；如果 $p=1$，输出为 $-A$。谓词 $p \\in \\{0, 1\\}$。\n- ALU有一个现有的超前进位加法器阶段，延迟为 $t_{\\text{adder}} = 300\\,\\text{ps}$。\n- 可用基本元件及其延迟：\n  - 逐位异或（XOR）：$t_{\\text{xor}} = 40\\,\\text{ps}$。\n  - 逐位反相器（INV）：$t_{\\text{inv}} = 30\\,\\text{ps}$。\n  - $2$选$1$多路复用器（MUX）：$t_{\\text{mux}} = 60\\,\\text{ps}$。\n- 约束条件：\n  - 实现必须是纯组合逻辑。\n  - 不得引入额外的流水线阶段。\n  - 必须复用现有的加法器阶段。\n- 目标：在保证对所有输入 $A$ 和 $p$ 的值都正确的同时，最小化相对于现有加法路径的最坏情况附加延迟。\n\n#### 步骤2：使用提取的已知条件进行验证\n1.  **科学性**：该问题设置在数字逻辑设计和计算机体系结构的背景下，特别是ALU设计。它利用了标准的二进制补码表示法来表示有符号整数，以及标准的逻辑门（XOR、INV、MUX）和一个加法器。使用这些元件实现条件取反是该领域的一个基本课题。其原理是科学合理的。\n2.  **适定性**：问题定义明确。它提供了一个清晰的目标（最小化附加延迟）、一组约束条件（组合逻辑、复用加法器、无新流水线阶段）和具体的元件延迟。这使得可以对不同的实现策略进行定量比较。可以从选项中确定一个唯一的最优解。\n3.  **客观性**：问题使用了电气工程和计算机科学中常见的精确技术语言陈述。没有主观或模糊的术语。\n\n#### 步骤3：结论和行动\n问题陈述是**有效的**。它具有科学性、适定性和客观性，提出了一个标准的工程权衡分析问题。我现在将通过分析每个选项来解决这个问题。\n\n### 解题推导\n\n核心任务是实现一个函数 $f(A, p)$，使得：\n- 如果 $p=0$，输出为 $A$。\n- 如果 $p=1$，输出为 $-A$。\n\n在一个 $n$ 位二进制补码系统中，一个数 $A$ 的负数（表示为 $-A$）是通过对其按位取补（反相）然后加 $1$ 来计算的：\n$$ -A = \\overline{A} + 1 $$\n这个操作必须使用所提供的元件和现有的加法器来实现。目标是找到具有最低最坏情况延迟的正确实现。加法器路径的基线延迟是 $t_{\\text{adder}} = 300\\,\\text{ps}$。任何额外的逻辑都会增加这个基线延迟。\n\n我们来分析每个选项。\n\n#### 选项A\n- **实现**：加法器的输入是 $A' = A \\oplus p$。这是一个按位操作，其中每一位 $A_i$ 都与单位比特 $p$ 进行异或。加法器的另一个操作数设置为整数 $0$，加法器的进位输入设置为 $p$。最终输出是加法器的和。\n- **正确性分析**：\n  - 如果 $p=0$：操作变为 $(A \\oplus 0) + 0$，进位输入为 $0$。因为 $A \\oplus 0 = A$，所以结果是 $A+0 = A$。这是正确的。\n  - 如果 $p=1$：操作变为 $(A \\oplus 1) + 0$，进位输入为 $1$。按位操作 $A \\oplus 1$ 等效于按位取反 $\\overline{A}$。因此，加法器计算 $\\overline{A} + 0 + 1$，即 $\\overline{A} + 1$。这是二进制补码中 $-A$ 的定义。这是正确的。\n- **延迟分析**：加法器的输入必须在它开始工作前稳定。操作数 $A'$ 由一组XOR门生成。生成 $A'$ 的延迟是 $t_{\\text{xor}}$。另一个操作数（$0$）和进位输入（$p$）是主输入，假定在时间 $0$ 就绪。关键路径是经过XOR门，然后是加法器。\n  $$ \\text{总延迟 (A)} = t_{\\text{xor}} + t_{\\text{adder}} = 40\\,\\text{ps} + 300\\,\\text{ps} = 340\\,\\text{ps} $$\n- **结论**：**正确**。附加延迟为 $40\\,\\text{ps}$。\n\n#### 选项B\n- **实现**：使用两条并行的计算路径。一条路径旁路加法器，将 $A$ 直接送到输出MUX的输入端。另一条路径计算 $-A$，方法是先将 $A$ 反相（得到 $\\overline{A}$），然后用加法器计算 $\\overline{A} + 1$（通过将 $\\overline{A}$ 和 $0$ 送到加法器输入端，并将进位输入设为 $1$）。由 $p$ 控制的输出MUX在 $A$ 和 $-A$ 之间进行选择。\n- **正确性分析**：\n  - 如果 $p=0$：MUX选择旁路的输入，即 $A$。这是正确的。\n  - 如果 $p=1$：MUX选择加法器路径的输出。加法器计算 $\\overline{A}+1$，即 $-A$。这是正确的。\n- **延迟分析**：最终输出来自MUX。其延迟是在其输入稳定后增加的。关键路径是耗时最长的那条路径。\n  - $A$ 到MUX输入的路径：假定延迟可忽略不计。\n  - $-A$ 到MUX输入的路径：这涉及到反相器和加法器。加法器的输入 $\\overline{A}$ 在 $t_{\\text{inv}}$ 之后就绪。然后加法器的输出在另一个 $t_{\\text{adder}}$ 之后就绪。所以 $-A$ 信号在时间 $t_{\\text{inv}} + t_{\\text{adder}}$ 到达MUX。\n  - 最终输出在MUX延迟之后就绪。最坏情况路径决定了延迟。\n  $$ \\text{总延迟 (B)} = t_{\\text{inv}} + t_{\\text{adder}} + t_{\\text{mux}} = 30\\,\\text{ps} + 300\\,\\text{ps} + 60\\,\\text{ps} = 390\\,\\text{ps} $$\n- **结论**：**正确**。附加延迟为 $t_{\\text{inv}} + t_{\\text{mux}} = 90\\,\\text{ps}$。\n\n#### 选项C\n- **实现**：在加法器前放置一组输入MUX。在 $p$ 的控制下，每个MUX为位 $A_i$ 选择 $A_i$ 或其反相 $\\overline{A_i}$。MUX的输出被送到加法的一个操作数。另一个加法器操作数为 $0$，进位输入设置为 $p$。\n- **正确性分析**：\n  - 如果 $p=0$：MUX选择 $A$。加法器进位输入为 $0$。加法器计算 $A + 0 + 0 = A$。这是正确的。\n  - 如果 $p=1$：MUX选择 $\\overline{A}$。加法器进位输入为 $1$。加法器计算 $\\overline{A} + 0 + 1 = \\overline{A} + 1$，即 $-A$。这是正确的。\n- **延迟分析**：信号必须通过加法器前的逻辑。MUX的输入是 $A$（在时间 $0$ 就绪）和 $\\overline{A}$。$\\overline{A}$ 在反相器延迟 $t_{\\text{inv}}$ 后就绪。然后MUX的输出在额外的 $t_{\\text{mux}}$ 后稳定。这个MUX的输出是加法器的输入。\n  $$ \\text{加法器前延迟} = t_{\\text{inv}} + t_{\\text{mux}} = 30\\,\\text{ps} + 60\\,\\text{ps} = 90\\,\\text{ps} $$\n  总延迟是加法器前逻辑延迟和加法器延迟之和。\n  $$ \\text{总延迟 (C)} = (t_{\\text{inv}} + t_{\\text{mux}}) + t_{\\text{adder}} = 90\\,\\text{ps} + 300\\,\\text{ps} = 390\\,\\text{ps} $$\n- **结论**：**正确**。附加延迟为 $t_{\\text{inv}} + t_{\\text{mux}} = 90\\,\\text{ps}$。\n\n#### 选项D\n- **实现**：将 $A$ 直接送入一个加法器操作数。另一个操作数是 $0$。进位输入设置为 $p$。输出是加法器的和。\n- **正确性分析**：加法器计算 $A + 0 + p = A+p$。\n  - 如果 $p=0$：结果是 $A+0 = A$。这是正确的。\n  - 如果 $p=1$：结果是 $A+1$。这不是 $-A$。对于几乎所有的 $A$ 值，$A+1 \\neq \\overline{A}+1$。例如，如果 $A=1$，那么 $A+1=2$，但是 $-A=-1$。\n- **结论**：**不正确**。该逻辑没有正确计算负数。\n\n### 比较与结论\n\n我们根据最坏情况延迟比较三个正确的选项（A、B和C），这等同于最小化附加延迟。\n\n- **延迟(A)**: $340\\,\\text{ps}$ (附加延迟: $40\\,\\text{ps}$)\n- **延迟(B)**: $390\\,\\text{ps}$ (附加延迟: $90\\,\\text{ps}$)\n- **延迟(C)**: $390\\,\\text{ps}$ (附加延迟: $90\\,\\text{ps}$)\n\n选项A中描述的实现具有最低的总延迟，因此相对于加法器基线具有最小的附加延迟。它通过利用XOR门的一个巧妙特性来执行条件反相，这比其他正确选项所需的INV+MUX组合要快。\n\n因此，选项A是最佳选择。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "一个稳健的ALU设计不仅要处理常规计算，还必须能正确应对边界情况。本练习将探讨二进制补码算术中一个著名的边界情况：对可表示的最小负数进行取反。通过分析这个特殊操作  的最终结果和相关的状态标志位（如溢出位 $V$ 和进位位 $C$），你将深刻体会到状态标志在指示运算有效性方面所扮演的关键角色。",
            "id": "3620785",
            "problem": "考虑一个算术逻辑单元 (ALU)，它对固定宽度的 $n$ 位补码整数进行操作。可表示的范围是 $[-2^{n-1},\\,2^{n-1}-1]$。该 ALU 使用其 $n$ 位加法器通过减法来实现取反操作：\n- 取反操作通过补码加法计算 $R = 0 - A$，结果被截断为低 $n$ 位（即模 $2^n$）。\n- 标志位的定义如下：\n  - 零标志位 $Z$：当且仅当 $R=0$ 时，$Z=1$；否则 $Z=0$。\n  - 负标志位 $N$：$N$ 等于 $R$ 的最高有效位 (MSB)。\n  - 溢出标志位 $V$：当且仅当真实的带符号结果无法用 $n$ 位补码表示时（即发生有符号溢出），$V=1$；否则 $V=0$。\n  - 进位标志位 $C$：$C$ 等于用于形成 $R$ 的 $n$ 位加法器从最高有效位产生的进位输出。\n\n设输入为 $A=-2^{n-1}$，其 $n$ 位补码位模式为 1 后跟 $n-1$ 个零。\n\n对于应用于此输入的取反操作，哪个选项正确地指出了 $n$ 位结果 $R$ 和标志位结果 $(N,Z,V,C)$？\n\nA. 结果等于 $A$（相同的 $n$ 位模式），且 $N=1, Z=0, V=1, C=0$。\n\nB. 结果等于 $A$（相同的 $n$ 位模式），且 $N=1, Z=0, V=0, C=1$。\n\nC. 结果等于 $0$，且 $N=0, Z=1, V=1, C=0$。\n\nD. 结果饱和到 $2^{n-1}-1$，且 $N=0, Z=0, V=1, C=1$。",
            "solution": "该问题要求分析在 $n$ 位补码系统中对最小负数执行取反操作。操作定义为 $R = 0 - A$，使用一个 $n$ 位加法器计算，并对状态标志位 $N, Z, V, C$ 有特定定义。\n\n### 问题陈述验证\n\n首先，我将验证问题陈述。\n\n**步骤 1：提取已知条件**\n-   系统使用 $n$ 位补码整数。\n-   可表示范围是 $[-2^{n-1}, 2^{n-1}-1]$。\n-   操作是取反，计算为 $R = 0 - A$。\n-   计算使用一个 $n$ 位加法器来执行补码加法，结果被截断为 $n$ 位（模 $2^n$）。\n-   标志位定义：\n    -   如果 $R=0$，则 $Z=1$；否则 $Z=0$。\n    -   $N$ 是 $R$ 的最高有效位。\n    -   如果真实的带符号结果不可表示，则 $V=1$；否则 $V=0$。\n    -   $C$ 是用于形成 $R$ 的加法器从最高有效位产生的进位输出。\n-   输入操作数是 $A = -2^{n-1}$。\n-   $A$ 的位模式为 1 后跟 $n-1$ 个零，即 $100...0_2$。\n\n**步骤 2：使用提取的已知条件进行验证**\n-   **科学严谨性：** 该问题牢固地基于数字逻辑和计算机算术的原理。补码表示法、其范围、通过加法实现的取反操作以及标准状态标志位（$N, Z, V, C$）的定义在计算机体系结构中都是标准且符合事实的。对最小负数取反的特殊情况是测试这种理解的经典且有效的场景。\n-   **适定性：** 该问题是适定的。所有需要的信息，包括输入值、算术操作、计算方法和精确的标志位定义，都已提供。这允许为输出 $R$ 和标志位推导出唯一且明确的结果。\n-   **客观性：** 该问题以客观、技术性的语言陈述，没有歧义或主观性。\n\n**步骤 3：结论与行动**\n问题陈述是科学严谨、适定、客观且自洽的。因此，它是**有效的**。我将继续推导解答。\n\n### 解答推导\n\n要执行的操作是对 $A = -2^{n-1}$ 取反。\n\n**1. 输入和操作的位表示**\n输入 $A$ 是最小的 $n$ 位负数，$A = -2^{n-1}$。其补码表示是一个 $n$ 位的二进制数，最高有效位 (MSB) 为 1，所有其他位为 0。\n$$A_{bits} = 1\\underbrace{00...0}_{n-1 \\text{ zeros}}$$\n取反操作是 $R = 0 - A$。在补码算术中，减法通过加上减数的补码来执行。所以，$R$ 的计算方式为：\n$$R = 0 + (-A)$$\n其中 $-A$ 表示 $A$ 的补码。\n\n**2. 结果 $R$ 的计算**\n首先，我们求 $A$ 的补码。过程是所有位取反（反码）然后加 1。\n-   $A$ 的位模式是 $A_{bits} = 100...0_2$。\n-   反码（各位取反）是 $\\text{NOT}(A_{bits}) = 011...1_2$。\n-   将反码加 1：\n$$\n\\begin{array}{@{}c@{\\,}c}\n   0\\underbrace{11...1}_{n-1 \\text{ ones}} \\\\\n+  0\\underbrace{00...1}_{n-2 \\text{ zeros}} \\\\\n\\hline\n   1\\underbrace{00...0}_{n-1 \\text{ zeros}}\n\\end{array}\n$$\n此操作的结果是 $100...0_2$。因此，$A = -2^{n-1}$ 的补码与 $A$ 本身的位模式相同。\n现在，ALU 执行加法 $R = 0 + (-A)$。0 的位模式是 $000...0_2$。\n$$\n\\begin{array}{@{}c@{\\,}c}\n   000...0 \\\\\n+  100...0 \\\\\n\\hline\n   100...0\n\\end{array}\n$$\n得到的 $R$ 的 $n$ 位模式是 $R_{bits} = 100...0_2$。这与输入 $A$ 的位模式相同。\n\n**3. 标志位的确定**\n我们现在根据操作和结果确定标志位 $N, Z, V, C$ 的值。\n\n-   **零标志位 ($Z$)**：当且仅当结果 $R$ 为 0 时，$Z$ 标志位为 1。得到的结果位模式是 $R_{bits} = 100...0_2$，它不是 $000...0_2$（对于 $n \\ge 1$）。因此，$Z=0$。\n\n-   **负标志位 ($N$)**：$N$ 标志位等于结果 $R$ 的最高有效位。$R_{bits} = 100...0_2$ 的最高有效位是 1。因此，$N=1$。\n\n-   **溢出标志位 ($V$)**：如果真实的带符号结果无法表示，$V$ 标志位为 1。该操作是 A 的取反。\n    -   输入值：$A = -2^{n-1}$。\n    -   真实数学结果：$-A = -(-2^{n-1}) = +2^{n-1}$。\n    -   $n$ 位补码的可表示范围是 $[-2^{n-1}, 2^{n-1}-1]$。\n    -   值 $+2^{n-1}$ 大于可表示的最大正数 $2^{n-1}-1$。\n    -   由于真实结果超出了可表示范围，发生了有符号溢出。因此，$V=1$。\n\n-   **进位标志位 ($C$)**：$C$ 标志位定义为加法器最高有效位的进位输出。减法 $X-Y$ 通过加法器实现为 $X + (\\text{NOT } Y) + 1$。这里，$X=0$ 且 $Y=A$。加法器计算 $0 + (\\text{NOT } A) + 1$，这等价于 $(\\text{NOT } A) + 1$。\n    -   加法器的输入是 $X' = \\text{NOT } A = 011...1_2$ 和 $Y' = 1$（表示为 $00...1_2$），或者更直接地说，加法器计算 $X' = 011...1_2$ 且初始进位为 1。\n    -   让我们追踪进位（从右边的第 0 位到左边的第 $n-1$ 位）：\n        -   第 0 位：$(\\text{NOT } A)_0 + 1 = 1+1=0$，进位输出 $c_1=1$。\n        -   第 1 位：$(\\text{NOT } A)_1 + 0 + c_1 = 1+0+1=0$，进位输出 $c_2=1$。\n        -   ...\n        -   第 $n-2$ 位：$(\\text{NOT } A)_{n-2} + 0 + c_{n-2} = 1+0+1=0$，进位输出 $c_{n-1}=1$。\n        -   第 $n-1$ 位 (MSB)：$(\\text{NOT } A)_{n-1} + 0 + c_{n-1} = 0+0+1=1$，最终的进位输出 $C=0$。\n    -   最高有效位阶段的进位输出是 0。因此，$C=0$。\n\n**结果总结**\n-   结果 $R$：位模式为 $100...0_2$，与输入 $A$ 相同。\n-   标志位结果 $(N, Z, V, C)$: $(1, 0, 1, 0)$。\n\n### 逐项分析选项\n\n-   **A. 结果等于 $A$（相同的 $n$ 位模式），且 $N=1, Z=0, V=1, C=0$。**\n    -   `结果等于 A`: 正确。结果位模式是 $100...0_2$。\n    -   `N=1`: 正确。结果的最高有效位是 1。\n    -   `Z=0`: 正确。结果不为零。\n    -   `V=1`: 正确。真实结果 $+2^{n-1}$ 不可表示。\n    -   `C=0`: 正确。加法器最高有效位的进位输出是 0。\n    -   此选项的所有部分都与推导一致。该选项是**正确的**。\n\n-   **B. 结果等于 $A$（相同的 $n$ 位模式），且 $N=1, Z=0, V=0, C=1$。**\n    -   `结果等于 A`: 正确。\n    -   `N=1`, `Z=0`: 正确。\n    -   `V=0`: 不正确。发生了溢出。\n    -   `C=1`: 不正确。进位输出是 0。\n    -   该选项是**不正确的**。\n\n-   **C. 结果等于 $0$，且 $N=0, Z=1, V=1, C=0$。**\n    -   `结果等于 0`: 不正确。结果位模式是 $100...0_2$。\n    -   `N=0`, `Z=1`: 不正确，这些由不正确的结果推导而来。\n    -   `V=1`, `C=0`: 这两项是正确的，但关于结果的主要陈述是错误的。\n    -   该选项是**不正确的**。\n\n-   **D. 结果饱和到 $2^{n-1}-1$，且 $N=0, Z=0, V=1, C=1$。**\n    -   `结果饱和`: 不正确。问题指定了标准的补码行为，即模运算（回绕），而非饱和运算。结果回绕到 $-2^{n-1}$。\n    -   `到 2^(n-1)-1`: 不正确。\n    -   `N=0`, `C=1`: 不正确。\n    -   此选项描述了一种不同类型的算术，是**不正确的**。",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}