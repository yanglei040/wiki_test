{
    "hands_on_practices": [
        {
            "introduction": "The ability to perform subtraction is a fundamental requirement for any Arithmetic Logic Unit (ALU). This is elegantly achieved not by building a separate subtractor circuit, but by reusing the adder with a clever trick: two's complement arithmetic. This exercise  provides a direct, hands-on test of this core principle, challenging you to manually execute the binary operation $A - B$ as the ALU would—by computing $A + (-B)$. Mastering this process is the first step toward understanding how all signed arithmetic is handled in hardware.",
            "id": "1914971",
            "problem": "An engineer is debugging the Arithmetic Logic Unit (ALU) of a prototype 4-bit embedded controller. The ALU design implements subtraction using the 2's complement method. Specifically, to compute $A - B$, the ALU calculates the 2's complement of the subtrahend $B$ and adds it to the minuend $A$. All numbers are represented using a fixed-width 4-bit 2's complement format.\n\nA test case is run to evaluate the operation involving two negative numbers: $-3 - (-6)$. What is the final 4-bit binary string that should be present in the ALU's output register after this operation is successfully completed?\n\nA. `0011`\n\nB. `1000`\n\nC. `1010`\n\nD. `1101`\n\nE. `1001`",
            "solution": "We work in fixed-width 4-bit two’s complement, whose representable range is from $-8$ to $+7$. The operation is $A - B$ with $A=-3$ and $B=-6$, implemented as $A + (\\text{two’s complement of }B)$.\n\nFirst, encode the operands:\n- $+3$ is $0011_{2}$, so $-3$ is obtained by inverting all bits and adding $1$: $0011_{2} \\to 1100_{2} \\to 1101_{2}$. Thus $A=-3$ is $1101_{2}$.\n- $+6$ is $0110_{2}$, so $-6$ is $0110_{2} \\to 1001_{2} \\to 1010_{2}$. Thus $B=-6$ is $1010_{2}$.\n\nTo compute $A - B$, form the two’s complement of the subtrahend $B$ and add to $A$:\n- Two’s complement of $B=1010_{2}$: invert to $0101_{2}$ and add $1$ to get $0110_{2}$.\n\nNow add to $A$:\n$$1101_{2} + 0110_{2} = 1\\,0011_{2}.$$\nIn 4-bit two’s complement arithmetic, the carry out of the most significant bit is discarded, leaving\n$$0011_{2},$$\nwhich represents $3$, consistent with $-3 - (-6) = 3$.\n\nTherefore, the correct 4-bit output is $0011$, which corresponds to option A.",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "Beyond basic addition and subtraction, a versatile ALU must support a variety of logical and conditional operations. This practice  moves from simple calculation to the realm of digital design, where correctness must be balanced with performance. You will be challenged to implement a conditional negate function, exploring how to cleverly combine logic gates with an existing adder to achieve the goal while minimizing operational delay.",
            "id": "3620734",
            "problem": "An Arithmetic Logic Unit (ALU) operating on $n$-bit two’s complement integers must implement a conditional negate operation that outputs either $A$ or $-A$ depending on a single-bit predicate $p \\in \\{0,1\\}$. The ALU uses a carry-lookahead adder stage with delay $t_{\\text{adder}} = 300\\,\\text{ps}$. Available primitive components have delays $t_{\\text{xor}} = 40\\,\\text{ps}$ for a per-bit Exclusive-OR (XOR), $t_{\\text{inv}} = 30\\,\\text{ps}$ for a per-bit inverter, and $t_{\\text{mux}} = 60\\,\\text{ps}$ for a $2$-to-$1$ Multiplexer (MUX). No additional pipeline stage may be introduced; the implementation must be purely combinational and reuse the existing adder stage. The objective is to minimize the worst-case added latency relative to the existing addition path, while producing correct results for all $A$ and both values of $p$.\n\nWhich option achieves correctness and minimizes the worst-case added latency relative to the adder baseline?\n\nA. Drive each bit of $A$ through a per-bit XOR controlled by $p$ to form $A' = A \\oplus p$, feed $A'$ into the existing adder with the other operand tied to $0$, and set the adder’s carry-in to $p$. Use the adder’s sum as the final output with no output-stage MUX.\n\nB. Build a parallel negate path by inverting $A$ with per-bit inverters and adding $1$ using the existing adder. In parallel, bypass the adder with the original $A$. At the output, use a MUX controlled by $p$ to select between the bypassed $A$ and the computed negation.\n\nC. Place a per-bit input MUX before the adder to select, under control of $p$, either $A$ or its bitwise inversion $\\overline{A}$ as the adder input. Tie the other adder operand to $0$ and set the adder’s carry-in equal to $p$. Use the adder’s sum as the final output.\n\nD. Avoid bitwise inversion altogether: feed $A$ directly into the adder with the other operand tied to $0$ and set the carry-in equal to $p$. Use the adder’s sum as the final output, claiming the carry-in suffices to realize conditional negation.",
            "solution": "### Problem Validation\n\n#### Step 1: Extract Givens\n- The ALU operates on $n$-bit two’s complement integers.\n- The operation to be implemented is a conditional negate: output is $A$ if a predicate $p=0$, and $-A$ if $p=1$. The predicate $p \\in \\{0, 1\\}$.\n- The ALU has an existing carry-lookahead adder stage with delay $t_{\\text{adder}} = 300\\,\\text{ps}$.\n- Available primitive components and their delays:\n  - Per-bit Exclusive-OR (XOR): $t_{\\text{xor}} = 40\\,\\text{ps}$.\n  - Per-bit inverter (INV): $t_{\\text{inv}} = 30\\,\\text{ps}$.\n  - $2$-to-$1$ Multiplexer (MUX): $t_{\\text{mux}} = 60\\,\\text{ps}$.\n- Constraints:\n  - The implementation must be purely combinational.\n  - No additional pipeline stage may be introduced.\n  - The existing adder stage must be reused.\n- Objective: Minimize the worst-case added latency relative to the existing addition path, while ensuring correctness for all inputs $A$ and values of $p$.\n\n#### Step 2: Validate Using Extracted Givens\n1.  **Scientifically Grounded**: The problem is set in the context of digital logic design and computer architecture, specifically ALU design. It utilizes the standard two's complement representation for signed integers and standard logic gates (XOR, INV, MUX) and an adder. The concept of conditional negation using these components is a fundamental topic in this field. The principles are scientifically sound.\n2.  **Well-Posed**: The problem is well-defined. It provides a clear objective (minimize added latency), a set of constraints (combinational, reuse adder, no new pipeline stages), and specific component delays. This allows for a quantitative comparison of different implementation strategies. A unique optimal solution among the choices can be determined.\n3.  **Objective**: The problem is stated using precise, technical language common in electrical engineering and computer science. There is no subjective or ambiguous terminology.\n\n#### Step 3: Verdict and Action\nThe problem statement is **valid**. It is scientifically grounded, well-posed, and objective, presenting a standard engineering trade-off analysis problem. I will now proceed to solve the problem by analyzing each option.\n\n### Solution Derivation\n\nThe core task is to implement a function $f(A, p)$ such that:\n- If $p=0$, the output is $A$.\n- If $p=1$, the output is $-A$.\n\nIn an $n$-bit two's complement system, the negation of a number $A$, denoted $-A$, is calculated by taking its bitwise complement (inversion) and adding $1$:\n$$ -A = \\overline{A} + 1 $$\nThis operation must be implemented using the provided components and the existing adder. The goal is to find the correct implementation with the lowest worst-case latency. The baseline latency of the adder path is $t_{\\text{adder}} = 300\\,\\text{ps}$. Any additional logic will add to this baseline.\n\nLet's analyze each option.\n\n#### Option A\n- **Implementation**: The input to the adder is $A' = A \\oplus p$. This is a bitwise operation where each bit $A_i$ is XORed with the single bit $p$. The adder's other operand is set to the integer $0$, and the adder's carry-in is set to $p$. The final output is the sum from the adder.\n- **Correctness Analysis**:\n  - If $p=0$: The operation becomes $(A \\oplus 0) + 0$ with carry-in $0$. Since $A \\oplus 0 = A$, the result is $A+0 = A$. This is correct.\n  - If $p=1$: The operation becomes $(A \\oplus 1) + 0$ with carry-in $1$. The bitwise operation $A \\oplus 1$ is equivalent to bitwise inversion, $\\overline{A}$. So, the adder computes $\\overline{A} + 0 + 1$, which is $\\overline{A} + 1$. This is the definition of $-A$ in two's complement. This is correct.\n- **Latency Analysis**: The inputs to the adder must be stable before it can operate. The operand $A'$ is generated by a bank of XOR gates. The delay to generate $A'$ is $t_{\\text{xor}}$. The other operand ($0$) and the carry-in ($p$) are primary inputs, assumed to be ready at time $0$. The critical path is through the XOR gates and then the adder.\n  $$ \\text{Total Latency (A)} = t_{\\text{xor}} + t_{\\text{adder}} = 40\\,\\text{ps} + 300\\,\\text{ps} = 340\\,\\text{ps} $$\n- **Verdict**: **Correct**. The added latency is $40\\,\\text{ps}$.\n\n#### Option B\n- **Implementation**: Two parallel computation paths are used. One path bypasses the adder, sending $A$ directly to the input of an output MUX. The other path computes $-A$ by first inverting $A$ (to get $\\overline{A}$) and then using the adder to compute $\\overline{A} + 1$ (by feeding $\\overline{A}$ and $0$ to the adder inputs and setting carry-in to $1$). The output MUX, controlled by $p$, selects between $A$ and $-A$.\n- **Correctness Analysis**:\n  - If $p=0$: The MUX selects the bypassed input, which is $A$. This is correct.\n  - If $p=1$: The MUX selects the output of the adder path. The adder computes $\\overline{A}+1$, which is $-A$. This is correct.\n- **Latency Analysis**: The final output is from the MUX. Its delay is added after its inputs are stable. The critical path is the one that takes the longest.\n  - Path for $A$ to MUX input: Assumed negligible.\n  - Path for $-A$ to MUX input: This involves the inverter and the adder. The input to the adder, $\\overline{A}$, is ready after $t_{\\text{inv}}$. The adder's output is then ready after another $t_{\\text{adder}}$. So, the $-A$ signal arrives at the MUX at time $t_{\\text{inv}} + t_{\\text{adder}}$.\n  - The final output is ready after the MUX delay. The worst-case path determines the latency.\n  $$ \\text{Total Latency (B)} = t_{\\text{inv}} + t_{\\text{adder}} + t_{\\text{mux}} = 30\\,\\text{ps} + 300\\,\\text{ps} + 60\\,\\text{ps} = 390\\,\\text{ps} $$\n- **Verdict**: **Correct**. The added latency is $t_{\\text{inv}} + t_{\\text{mux}} = 90\\,\\text{ps}$.\n\n#### Option C\n- **Implementation**: A bank of input MUXes is placed before the adder. Controlled by $p$, each MUX selects for bit $A_i$ either $A_i$ or its inversion $\\overline{A_i}$. The MUX output is fed into one operand of the adder. The other adder operand is $0$, and the carry-in is set to $p$.\n- **Correctness Analysis**:\n  - If $p=0$: The MUX selects $A$. The adder carry-in is $0$. The adder computes $A + 0 + 0 = A$. This is correct.\n  - If $p=1$: The MUX selects $\\overline{A}$. The adder carry-in is $1$. The adder computes $\\overline{A} + 0 + 1 = \\overline{A} + 1$, which is $-A$. This is correct.\n- **Latency Analysis**: The signals must propagate through the pre-adder logic. The inputs to the MUXes are $A$ (ready at time $0$) and $\\overline{A}$. $\\overline{A}$ is ready after the inverter delay, $t_{\\text{inv}}$. The MUX output is then stable after an additional $t_{\\text{mux}}$. This MUX output is the input to the adder.\n  $$ \\text{Pre-adder Latency} = t_{\\text{inv}} + t_{\\text{mux}} = 30\\,\\text{ps} + 60\\,\\text{ps} = 90\\,\\text{ps} $$\n  The total latency is the sum of the pre-adder logic delay and the adder delay.\n  $$ \\text{Total Latency (C)} = (t_{\\text{inv}} + t_{\\text{mux}}) + t_{\\text{adder}} = 90\\,\\text{ps} + 300\\,\\text{ps} = 390\\,\\text{ps} $$\n- **Verdict**: **Correct**. The added latency is $t_{\\text{inv}} + t_{\\text{mux}} = 90\\,\\text{ps}$.\n\n#### Option D\n- **Implementation**: $A$ is fed directly into one adder operand. The other operand is $0$. The carry-in is set to $p$. The output is the sum from the adder.\n- **Correctness Analysis**: The adder computes $A + 0 + p = A+p$.\n  - If $p=0$: The result is $A+0 = A$. This is correct.\n  - If $p=1$: The result is $A+1$. This is not $-A$. For almost all values of $A$, $A+1 \\neq \\overline{A}+1$. For example, if $A=1$, then $A+1=2$, but $-A=-1$.\n- **Verdict**: **Incorrect**. The logic does not correctly compute the negation.\n\n### Comparison and Conclusion\n\nWe compare the three correct options (A, B, and C) based on their worst-case latency, which is equivalent to minimizing the added latency.\n\n- **Latency(A)**: $340\\,\\text{ps}$ (Added latency: $40\\,\\text{ps}$)\n- **Latency(B)**: $390\\,\\text{ps}$ (Added latency: $90\\,\\text{ps}$)\n- **Latency(C)**: $390\\,\\text{ps}$ (Added latency: $90\\,\\text{ps}$)\n\nThe implementation described in Option A has the lowest total latency and therefore the minimum added latency relative to the adder baseline. It achieves this by using a clever property of the XOR gate to perform a conditional inversion, which is faster than the INV+MUX combination required by the other correct options.\n\nTherefore, Option A is the optimal choice.",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "An ALU's job isn't complete once it computes a sum; it must also report on the nature of that result through status flags. This final exercise  focuses on the crucial, yet often misunderstood, difference between the signed overflow flag ($V$) and the unsigned carry flag ($C$). Rather than simply calculating flags from given inputs, you are tasked with the more insightful challenge of designing a specific test case that isolates overflow from carry, proving a deep mastery of their distinct triggers and meanings.",
            "id": "3620758",
            "problem": "An Arithmetic Logic Unit (ALU) implements fixed-width two's complement addition on $n$-bit operands. In two's complement with width $n$, the representable integer range is $[-2^{n-1}, 2^{n-1}-1]$, and binary addition is performed modulo $2^{n}$. The ALU produces two status flags for addition of operands $A$ and $B$:\n- The carry flag $C$ is the carry-out from the most significant bit position (bit index $n-1$) of the $n$-bit adder when performing addition modulo $2^{n}$.\n- The signed overflow flag $V$ is set if and only if the two's complement sum cannot be represented in $n$ bits when interpreted as a signed integer; equivalently, $V$ is set precisely when adding two operands with the same sign yields a result whose sign differs from the operands' sign.\n\nConsider an ALU with $n=8$ that is being unit-tested. You are tasked with designing a single directed unit test that isolates signed overflow behavior by toggling the signed overflow flag $V$ without toggling the carry flag $C$. To eliminate ambiguity and enforce uniqueness, fix the second operand to be $B=1$ and restrict the first operand to be a nonnegative integer $A \\in [0, 2^{7}-1]$.\n\nDetermine the smallest such $A$ (in base ten) for which adding $A$ and $B$ in $8$-bit two's complement produces $V=1$ and $C=0$. Express your answer as a base-$10$ integer.",
            "solution": "The problem requires finding the smallest non-negative integer $A$ in a specified range such that its addition with a fixed operand $B$ in an $8$-bit two's complement ALU results in a specific state for the signed overflow flag ($V$) and the carry flag ($C$).\n\nFirst, we formalize the problem's parameters and constraints based on the provided information.\nThe ALU operates on $n$-bit operands, where $n=8$.\nThe arithmetic is two's complement. The representable integer range for $n=8$ is $[-2^{8-1}, 2^{8-1}-1]$, which is $[-128, 127]$.\nBinary addition is performed modulo $2^8 = 256$.\nThe second operand is fixed: $B=1$.\nThe first operand, $A$, is restricted to the range of non-negative integers: $A \\in [0, 2^{7}-1]$, which simplifies to $A \\in [0, 127]$.\nThe desired outcome of the addition $A+B$ is that the signed overflow flag is set ($V=1$) and the carry flag is not set ($C=0$).\n\nWe will now analyze the conditions for each flag separately.\n\n**Condition for the Signed Overflow Flag ($V=1$)**\n\nThe problem states that the signed overflow flag $V$ is set if and only if \"adding two operands with the same sign yields a result whose sign differs from the operands' sign\".\nThe operand $A$ is in the range $[0, 127]$. Its value is non-negative, so its sign bit (the most significant bit, MSB, at position $n-1=7$) is $0$.\nThe operand $B=1$ is also positive, so its sign bit is $0$.\nThus, we are adding two positive numbers. For signed overflow to occur ($V=1$), the result must have a sign bit of $1$, meaning the result is a negative number.\nIn an $n$-bit two's complement system, the sum of two positive numbers $A$ and $B$ overflows if and only if their mathematical sum is greater than the largest representable positive number, which is $2^{n-1}-1$.\nFor $n=8$, the maximum positive value is $2^{7}-1 = 127$.\nThe condition for overflow is therefore $A + B > 127$.\nSubstituting the given value $B=1$, we get:\n$$A + 1 > 127$$\n$$A > 126$$\n\n**Condition for the Carry Flag ($C=0$)**\n\nThe carry flag $C$ is defined as the carry-out from the MSB position (bit $n-1=7$) of the $n$-bit adder. This is equivalent to stating that $C=1$ if the sum of the operands, treated as unsigned integers, is greater than or equal to $2^n$. Conversely, $C=0$ if the unsigned sum is less than $2^n$.\nThe operand $A$ is in the range $[0, 127]$, so its signed representation is identical to its unsigned representation.\nThe operand $B=1$ is also positive, so its signed and unsigned representations are the same.\nLet $A_{unsigned}$ and $B_{unsigned}$ be the unsigned interpretations of the bit patterns for $A$ and $B$. Then $A_{unsigned} = A$ and $B_{unsigned} = B = 1$.\nThe condition for the carry flag to be $0$ is:\n$$A_{unsigned} + B_{unsigned}  2^n$$\nFor $n=8$, this becomes:\n$$A + 1  2^8$$\n$$A + 1  256$$\n$$A  255$$\n\n**Synthesizing the Conditions**\n\nWe need to find the smallest integer $A$ that satisfies all three of the following conditions:\n1.  $A \\in [0, 127]$ (from the problem's constraint on $A$)\n2.  $A > 126$ (from the $V=1$ condition)\n3.  $A  255$ (from the $C=0$ condition)\n\nCombining the first two conditions, $A \\in [0, 127]$ and $A > 126$, the only possible integer value for $A$ is $127$.\nWe must check if $A=127$ also satisfies the third condition: $127  255$. This is true.\nTherefore, the only value for $A$ in the specified range that produces the desired flag combination is $A=127$. Since it is the only solution, it is trivially the smallest.\n\n**Verification**\n\nLet's verify the result for $A=127$ and $B=1$.\nIn $8$-bit binary:\n$A = 127_{10} = 01111111_2$\n$B = 1_{10} = 00000001_2$\n\nPerforming the binary addition:\n$$\n\\begin{array}{@{}c@{\\,}c@{}c@{}c@{}c@{}c@{}c@{}c@{}c}\n   0  1  1  1  1  1  1  1 \\\\\n+   0  0  0  0  0  0  0  1 \\\\\n\\hline\n   1  0  0  0  0  0  0  0 \\\\\n\\end{array}\n$$\nThe $8$-bit result is $10000000_2$.\n\nLet's check the flags for this operation:\n- **Carry Flag ($C$)**: The sum of the unsigned values is $127 + 1 = 128$. Since $128  256$, the sum does not exceed the capacity of an $8$-bit unsigned integer. There is no carry-out from the MSB (bit $7$). Thus, $C=0$. This matches the requirement.\n- **Signed Overflow Flag ($V$)**: We added two positive numbers ($A=127$, sign bit $0$; $B=1$, sign bit $0$). The result is $10000000_2$. In two's complement, this represents the value $-128_{10}$, which is a negative number (sign bit $1$). Since the sign of the result is different from the signs of the operands, a signed overflow has occurred. Thus, $V=1$. This matches the requirement.\n\nThe value $A=127$ satisfies both conditions ($V=1$ and $C=0$) and is the smallest such integer within the allowed range.",
            "answer": "$$\\boxed{127}$$"
        }
    ]
}