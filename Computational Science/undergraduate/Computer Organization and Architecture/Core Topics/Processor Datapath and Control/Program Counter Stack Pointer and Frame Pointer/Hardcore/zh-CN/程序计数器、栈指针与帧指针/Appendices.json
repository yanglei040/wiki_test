{
    "hands_on_practices": [
        {
            "introduction": "理论知识只有通过实践才能真正内化。要理解程序执行的底层机制，最坚实的第一步就是弄清楚单个函数调用的“工作空间”——栈帧——是如何组织的。这个练习将带你扮演编译器的角色，为一个函数精确地规划其栈帧内存布局。你需要根据变量大小、对齐要求以及ABI（应用程序二进制接口）的规则，计算出局部变量、保存的寄存器以及必要的填充数据在栈上的精确位置，从而深刻理解帧指针（$FP$）作为栈帧稳定基石的关键作用。",
            "id": "3670174",
            "problem": "一个 $64$ 位 RISC 函数在一个应用二进制接口 (ABI) 下执行，该接口强制执行以下规则：栈指针 (SP) 在函数调用边界处始终是 $16$ 字节对齐的；栈向较低地址方向增长；每个使用帧指针 (FP) 的函数在其序言中保存旧的帧指针和返回地址 (RA)，并在其尾声中恢复它们。假设函数序言首先将旧的 FP 和 RA 作为两个连续的 $8$ 字节字（总共 $16$ 字节）压入栈中，然后将 FP 设置为更新后的 SP，之后才从 SP 中减去用于局部变量和溢出数据的额外空间。该函数使用 $3$ 个具有自然对齐的标量局部变量：大小为 $8$ 字节（对齐 $8$）的变量 $x$ ，大小为 $4$ 字节（对齐 $4$）的变量 $y$ ，以及大小为 $1$ 字节（对齐 $1$）的变量 $z$ 。编译器按 $x$、$y$、$z$ 的顺序将局部变量直接布局在 FP 下方，通过在需要时在每个变量紧前方插入最小的填充来满足其对齐要求。布局完局部变量后，栈帧可能会在最后一个局部变量下方包含尾部填充，以确保最终的 SP 保持 $16$ 字节对齐。\n\n现在假设该函数额外使用 $m=3$ 个被调用者保存的向量寄存器 (VRs)，每个寄存器宽度为 $128$ 位，这些寄存器必须溢出到栈上并从栈中恢复。每个溢出的 VR 必须存储在 $16$ 字节对齐的地址上。编译器将 VR 溢出区域放置在标量局部变量区域下方，在标量局部变量区域和 VR 溢出区域之间插入最小的填充，以满足 VR 溢出区域起始地址的 $16$ 字节对齐要求，同时保持最终 SP 仍为 $16$ 字节对齐的不变性。FP 的值在序言中建立后不再改变。\n\n仅使用上述规则以及关于对齐和栈帧布局的基本原理，确定：\n- 与没有 VR 溢出的原始帧相比，仅因添加 VR 溢出区域而消耗的额外栈空间（以字节为单位）；\n- 仅因添加 VR 溢出区域而需要的任何额外对齐填充的大小（以字节为单位）；\n- 并证明标量局部变量 $x$、$y$ 和 $z$ 相对于帧指针 (FP) 的起始偏移量因添加 VR 溢出区域而保持不变。\n\n提供扩展后的总栈帧大小作为你的最终数值答案，以字节为单位，从函数入口的 SP 计算到序言中最深的 SP（即，包括保存的 FP 和 RA、标量局部变量、任何必要的填充以及 VR 溢出区域）。以字节为单位表示最终答案。无需四舍五入。",
            "solution": "问题陈述经确认为具有科学依据、良构且客观。它提供了一套完整且一致的规则，这些规则基于计算机体系结构和编译器生成的应用二进制接口（ABI）的既定原则。所有术语都得到了明确定义，且约束条件导向一个唯一的、可验证的解。因此，我们可以开始分析。\n\n令 $SP_{entry}$ 为函数被调用时栈指针 (SP) 的值。根据 ABI，$SP_{entry}$ 是 $16$ 字节对齐的，意味着 $SP_{entry} \\equiv 0 \\pmod{16}$。栈向较低的内存地址增长。\n\n**序言与帧指针设置**\n函数序言首先将旧的帧指针 (FP) 和返回地址 (RA) 保存到栈上。在一个 $64$ 位架构上，两者都是 $8$ 字节，总计 $16$ 字节。SP 被更新为 $SP_{prologue} = SP_{entry} - 16$。由于 $SP_{entry}$ 和 $16$ 都是 $16$ 的倍数，所以 $SP_{prologue}$ 也是 $16$ 字节对齐的。问题陈述指出，新的帧指针随后被设置为这个更新后的 SP 值：$FP = SP_{prologue}$。因此，此函数帧的新 $FP$ 是一个 $16$ 字节对齐的地址。\n\n**标量局部变量的布局与偏移量不变的证明**\nFP 作为访问局部变量的稳定参考。问题指定标量局部变量按 $x$、$y$、$z$ 的顺序直接布局在 FP 下方。这些变量相对于 FP 的位置仅取决于它们的大小、对齐约束和指定的顺序。在“标量局部变量区域下方”添加一个后续的内存区域（VR 溢出区域）不会改变标量局部变量相对于 FP 的布局。因此，我们可以确定它们的偏移量，无论有无 VR 溢出区域，这些偏移量都将是相同的。\n\n让我们计算标量局部变量所需的空间。我们使用相对于 FP 的偏移量。地址为 $FP+O$ 的变量的偏移量为 $O$。由于栈向下增长，偏移量将为负数。\n\n1.  **变量 $x$**：大小 $8$ 字节，对齐 $8$ 字节。第一个可用的偏移量是 $-1$。为满足 $8$ 字节对齐，其起始地址 $FP+O_x$ 必须是 $8$ 的倍数。由于 $FP$ 是 $16$ 字节对齐的（因此也是 $8$ 字节对齐的），偏移量 $O_x$ 必须是 $8$ 的倍数。能够容纳一个 $8$ 字节变量的最接近的此类偏移量是 $O_x = -8$。变量 $x$ 占据地址范围 $[FP-8, FP-1]$。使用的最低地址是 $FP-8$。\n\n2.  **变量 $y$**：大小 $4$ 字节，对齐 $4$ 字节。它被放置在 $x$ 之后。$x$ 使用的最低地址是 $FP-8$。变量 $y$ 必须从一个地址 $FP+O_y \\le FP-8$ 开始。其地址必须是 $4$ 字节对齐的。由于 $FP$ 是 $4$ 字节对齐的， $O_y$ 必须是 $4$ 的倍数。我们将其紧凑地放置在 $x$ 之后，因此其偏移量为 $O_y = O_x - (\\text{size of } y) = -8 - 4 = -12$。由于 $-12$ 是 $4$ 的倍数， $x$ 和 $y$ 之间不需要填充。变量 $y$ 占据 $[FP-12, FP-9]$。使用的最低地址是 $FP-12$。\n\n3.  **变量 $z$**：大小 $1$ 字节，对齐 $1$ 字节。它被放置在 $y$ 之后。其偏移量为 $O_z = O_y - (\\text{size of } z) = -12 - 1 = -13$。任何地址都是 $1$ 字节对齐的，所以不需要填充。变量 $z$ 占据地址为 $FP-13$ 的字节。\n\n因此，标量局部变量相对于 FP 的起始偏移量为 $O_x = -8$，$O_y = -12$ 和 $O_z = -13$。这些偏移量与是否添加 VR 溢出区域无关。标量数据消耗的总连续空间为 $8+4+1=13$ 字节，占据了从 $FP-1$ 到 $FP-13$ 的内存。\n\n**原始帧分析（无 VR 溢出）**\n局部变量所需的总空间为 $13$ 字节。分配此空间后，必须调整 SP 以确保其保持 $16$ 字节对齐。FP下方的局部变量分配区域的总大小，我们称之为 $S_{locals}$，必须是 $16$ 的倍数。我们必须找到大于或等于 $13$ 的最小的 $16$ 的倍数。这个值是 $16$ 字节。\n$S_{locals} = 16$ 字节。\n这个空间由用于标量变量（$x, y, z$）的 $13$ 字节和为对齐最终 SP 而设的 $16 - 13 = 3$ 字节的尾部填充组成。\n总栈帧大小是保存的寄存器空间和局部变量区域空间之和：\n总栈帧大小（无 VR）= 16 字节（保存的 FP/RA） + 16 字节（局部变量区域）= 32 字节。\n\n**扩展帧分析（有 VR 溢出）**\n布局过程以相同的方式开始，即 $13$ 字节的标量局部变量区域。在该区域下方，分配 VR 溢出区域。\n\n1.  **区域间对齐**：VR 溢出区域必须从一个 $16$ 字节对齐的地址开始。标量区域占据的偏移量低至 $-13$。因此，VR 溢出区域必须从一个偏移量 $O_{VR\\_start} \\le -13$ 开始，该偏移量是 $16$ 的倍数（因为 $FP$ 是 $16$ 的倍数）。这样的最大倍数是 $-16$。这意味着 VR 区域从地址 $FP-16$ 开始。从 $FP-14$ 到 $FP-15$ 的空间未使用。这构成了 $16 - 13 = 3$ 字节的区域间填充。\n\n2.  **VR 溢出数据**：有 $m=3$ 个向量寄存器，每个宽度为 $128$ 位（$16$ 字节）。总数据大小为 $3 \\times 16 = 48$ 字节。这些数据从偏移量 $-16$ 开始放置。\n\n3.  **FP 下方的总分配空间**：FP 下方所需的总空间是标量数据、区域间填充和 VR 溢出数据之和。\n$S_{total} = 13 \\text{ bytes (scalars)} + 3 \\text{ bytes (padding)} + 48 \\text{ bytes (VRs)} = 64 \\text{ bytes.}$\n\n4.  **最终 SP 对齐**：FP 下方分配的总空间为 $64$ 字节。由于 $64$ 是 $16$ 的倍数，最终的 SP 将是 $FP - 64$。由于 $FP$ 是 $16$ 字节对齐的，这个最终的 SP 也是 $16$ 字节对齐的。不需要额外的尾部填充。\n\n扩展后的总栈帧大小是保存的寄存器空间和 FP 下方分配的总区域之和：\n总栈帧大小（有 VR）= 16 字节（保存的 FP/RA） + 64 字节（局部变量/溢出区域）= 80 字节。\n\n**回答次要问题**\n- 消耗的额外栈空间是总栈帧大小的差值：$80 - 32 = 48$ 字节。\n- 原始帧中的填充量为 $3$ 字节（尾部）。扩展帧中的填充量为 $3$ 字节（区域间）。因此，额外对齐填充的大小为 $3 - 3 = 0$ 字节。填充只是被重新定位了。\n- 如前所示，$x$、$y$ 和 $z$ 相对于 FP 的偏移量保持不变。\n\n最后一个问题要求的是扩展后的总栈帧大小（以字节为单位）。这个值是 $80$ 字节。",
            "answer": "$$\\boxed{80}$$"
        },
        {
            "introduction": "在掌握了单个栈帧的静态布局之后，我们将更进一步，探索函数调用过程中的动态交互。函数调用并非简单的指令跳转，而是一个由调用者（caller）和被调用者（callee）共同遵守的严谨协议，即ABI。这个练习将聚焦于ABI中一个至关重要但又常常被忽略的规则：栈对齐。你将需要像编译器一样，在函数调用前精心准备栈空间，通过精确计算来放置函数参数，并添加适当的填充字节，以确保在控制权转移到被调用函数的那一刻，栈指针（$SP$）满足严格的对齐要求。",
            "id": "3670258",
            "problem": "考虑一个$64$位架构，其栈向下增长，并采用一种调用约定，其中所有函数参数都通过栈传递。栈指针（$SP$）指向栈顶。`call` 指令会将程序计数器（PC）更新为被调用者的入口点，并且作为控制权转移的一部分，会自动将返回地址压入栈中，使 $SP$ 减少一个固定的宽度 $w$。帧指针（FP）被调用者和被调用者双方用来界定栈帧，但在检查下面所述的对齐要求之前，被调用者的序言代码不会执行。\n\n应用二进制接口（ABI）要求，在控制权到达被调用者时（即 `call` 指令压入返回地址后），栈指针必须满足同余关系 $SP \\equiv 0 \\pmod{16}$。\n\n调用者必须按如下方式准备栈上的参数区域。给定一个有序的参数列表 $\\{(a_i, A_i)\\}_{i=1}^{n}$，其中 $a_i$ 是大小（以字节为单位），$A_i$ 是要求的对齐方式（以字节为单位），调用者以从右到左的顺序放置参数（即，首先放置参数 $n$，然后是 $n-1$，依此类推）。对于每个参数 $i$，在存储它之前，调用者通过减去一个最小的非负填充量 $\\delta_i$ 来将当前的 $SP$ 向下对齐到最近的能被 $A_i$ 整除的地址，使得 $\\left(SP - \\delta_i\\right) \\equiv 0 \\pmod{A_i}$。然后它减去 $a_i$ 为参数预留空间并存储该参数。在 `call` 指令之前，调用者可以插入一个大小为 $P$ 字节的额外填充，以帮助满足被调用者入口的对齐要求。\n\n假设存在以下具体情况：\n- 返回地址的宽度为 $w = 8$ 字节。\n- 在开始放置参数时，调用者的栈指针满足 $SP \\equiv 10 \\pmod{16}$。\n- 共有 $n=4$ 个参数，其大小和对齐方式如下：\n  - 参数 $1$：$(a_1, A_1) = (8, 8)$，\n  - 参数 $2$：$(a_2, A_2) = (8, 8)$，\n  - 参数 $3$：$(a_3, A_3) = (12, 4)$，\n  - 参数 $4$：$(a_4, A_4) = (16, 16)$。\n- 参数按从右到左的顺序放置：$4, 3, 2, 1$。\n\n计算调用者在执行 `call` 指令前必须立即插入的最小非负填充 $P$（以字节为单位），以使得在被调用者入口处，栈指针满足 $SP \\equiv 0 \\pmod{16}$。请将你的最终答案以字节为单位表示为一个单独的数字。不需要四舍五入。",
            "solution": "相关的基本原则如下：\n- 程序计数器（PC）决定下一个要执行的指令；`call` 指令将 PC 设置为被调用者的地址，同时安排一个返回地址，以便在控制权返回时使用。\n- 栈指针（$SP$）标识当前的栈顶；在向下增长的栈上，压入数据会使 $SP$ 的值减小。\n- 帧指针（FP）为栈帧布局提供了一个稳定的参考点，但任何被调用者的序言代码操作都在所需的入口对齐检查之后发生。\n- ABI 对齐规则要求在被调用者入口处（即 `call` 指令压入返回地址后），$SP \\equiv 0 \\pmod{16}$。\n\n我们完全使用关于 $SP$ 同余的模运算来为调用者的栈准备过程建模。设初始栈指针的余数为 $r_0$，使得 $SP \\equiv r_0 \\pmod{16}$，其中 $r_0 = 10$。调用者按从右到左的顺序为每个参数 $i$ 执行两次调整：\n1. 向下对齐到 $A_i$：减去最小的 $\\delta_i$，使得 $\\left(SP - \\delta_i\\right) \\equiv 0 \\pmod{A_i}$。\n2. 为参数预留 $a_i$ 字节：减去 $a_i$。\n\n我们将通过这些步骤跟踪 $SP \\pmod{16}$ 的值。\n\n参数 $4$ 的步骤：$(a_4, A_4) = (16, 16)$，从 $SP \\equiv 10 \\pmod{16}$ 开始。\n- 对齐到 $A_4 = 16$：我们需要 $\\delta_4$ 使得 $\\left(10 - \\delta_4\\right) \\equiv 0 \\pmod{16}$ 且 $0 \\leq \\delta_4  16$。最小的选择是 $\\delta_4 = 10$。对齐后，$SP \\equiv 0 \\pmod{16}$。\n- 预留 $a_4 = 16$：减去 $16$ 保持余数不变，$SP \\equiv 0 \\pmod{16}$。\n\n参数 $3$ 的步骤：$(a_3, A_3) = (12, 4)$，此时 $SP \\equiv 0 \\pmod{16}$。\n- 对齐到 $A_3 = 4$：因为此时 $SP \\equiv 0 \\pmod{4}$ 已经成立，所以 $\\delta_3 = 0$。\n- 预留 $a_3 = 12$：$SP$ 变化了 $-12$，所以 $SP \\equiv -12 \\equiv 4 \\pmod{16}$。\n\n参数 $2$ 的步骤：$(a_2, A_2) = (8, 8)$，此时 $SP \\equiv 4 \\pmod{16}$。\n- 对齐到 $A_2 = 8$：我们需要 $\\delta_2$ 使得 $\\left(4 - \\delta_2\\right) \\equiv 0 \\pmod{8}$ 且 $0 \\leq \\delta_2  8$。最小的选择是 $\\delta_2 = 4$。对齐后，$SP \\equiv 0 \\pmod{16}$（并且 $SP \\equiv 0 \\pmod{8}$）。\n- 预留 $a_2 = 8$：减去 $8$ 得到 $SP \\equiv -8 \\equiv 8 \\pmod{16}$。\n\n参数 $1$ 的步骤：$(a_1, A_1) = (8, 8)$，此时 $SP \\equiv 8 \\pmod{16}$。\n- 对齐到 $A_1 = 8$：此时 $SP \\equiv 0 \\pmod{8}$ 已经成立，所以 $\\delta_1 = 0$。\n- 预留 $a_1 = 8$：减去 $8$ 得到 $SP \\equiv 8 - 8 \\equiv 0 \\pmod{16}$。\n\n因此，在 `call` 指令之前（以及在任何额外的调用前填充之前），栈指针满足\n$$\nSP_{\\text{pre-call}} \\equiv 0 \\pmod{16}.\n$$\n\n`call` 指令压入宽度为 $w=8$ 字节的返回地址，所以在被调用者入口处，\n$$\nSP_{\\text{entry}} \\equiv SP_{\\text{pre-call}} - w \\equiv 0 - 8 \\equiv 8 \\pmod{16}.\n$$\n这违反了 ABI 关于被调用者入口处 $SP \\equiv 0 \\pmod{16}$ 的要求。为了纠正这一点，调用者可以在执行 `call` 指令前立即插入 $P$ 字节的调用前填充。有了这个填充，被调用者入口处的余数变为\n$$\nSP_{\\text{entry}} \\equiv SP_{\\text{pre-call}} - P - w \\equiv 0 - P - 8 \\equiv -\\left(P + 8\\right) \\pmod{16}.\n$$\n我们要求 $SP_{\\text{entry}} \\equiv 0 \\pmod{16}$，所以\n$$\n-\\left(P + 8\\right) \\equiv 0 \\pmod{16}\n\\quad\\Longleftrightarrow\\quad\nP + 8 \\equiv 0 \\pmod{16}.\n$$\n这个同余方程的解为 $P \\equiv 8 \\pmod{16}$。最小的非负 $P$ 是\n$$\nP = 8.\n$$\n\n因此，调用者必须在 `call` 指令前立即插入 $8$ 字节的填充，以确保在被调用者入口处 $SP \\equiv 0 \\pmod{16}$。",
            "answer": "$$\\boxed{8}$$"
        },
        {
            "introduction": "经过对栈帧静态布局和动态调用规则的分析，现在是时候将所有知识融会贯通，进行终极实践了。在这个练习中，你将不再仅仅是分析规则，而是要亲手实现这些规则，构建一个迷你的CPU模拟器。这个模拟器需要能够从第一性原理出发，完整地模拟程序计数器（$PC$）、栈指针（$SP$）和帧指针（$FP$）在程序执行过程中的协作。通过实现函数调用、返回甚至尾调用优化（tail call optimization）等关键操作，你将对程序执行的底层脉络有一个无可比拟的深刻理解。",
            "id": "3670254",
            "problem": "设计并实现一个自包含的教学模拟器，该模拟器模拟程序计数器（PC）、栈指针（SP）和帧指针（FP），并使用这些模型来演示尾调用如何保持栈深度不变。该模拟器必须基于计算机组成和体系结构的基本原理从头构建。其基本基础包括以下广泛接受的定义，模拟器必须将这些定义予以操作化实现：程序计数器（PC）指向下一条待执行指令的地址；栈指针（SP）指向当前调用栈的栈顶；帧指针（FP）指向当前活动记录（栈帧）的基地址。模拟器必须实现一个最小指令集，其中函数调用、返回和尾调用的行为有明确定义，并且必须生成一个数值化的追踪摘要，以可视化 $PC$ 的推进和 $SP$ 的变化。\n\n您的模拟器必须模拟一个具有以下属性和语义的简化版机器：\n- 指令内存是一个由非负整数索引的数组，$PC$ 是该内存的一个整数索引。\n- 调用栈被建模为一系列活动记录（帧）。每个帧包含一个保存的返回地址（一个整数 $PC$）、一个保存的帧指针（一个整数 $FP$）、一个函数标识符（一个整数）和若干局部变量槽（一个整数 $L$）。\n- 栈向下增长，因此压入一个帧会使 $SP$ 减少 $2 + L$（用于保存返回地址、保存帧指针和局部变量），而弹出一个帧会使 $SP$ 增加 $2 + L$。\n- 函数调用为被调用者压入一个新帧，并通过将 $PC$ 设置为被调用者的入口点来转移控制权。\n- 返回操作弹出当前帧，将 $FP$ 和 $PC$ 恢复为保存的值，并在调用者的下一条指令处恢复执行。\n- 尾调用将被调用者的函数标识符和局部布局替换当前帧的相应内容，重用已保存的返回地址和帧指针（不进行新的压栈操作），通过将 $PC$ 设置为被调用者的入口点来转移控制权，并保持栈深度不变。对于一个正确的尾调用，其步骤导致的 $SP$ 净变化为 $0$，即 $\\Delta SP = 0$。\n\n允许的指令集必须为：\n- $OP\\_NOP$: 无操作；将 $PC$ 增加 $1$。\n- $OP\\_CALL\\ x$: 调用标识符为 $x$ 的函数；压入一个大小为被调用者局部变量大小 $L\\_x$ 的帧，将 $PC$ 设置为被调用者的入口，并将 $FP$ 设置为新帧的基地址。\n- $OP\\_RET$: 从当前函数返回；弹出栈帧，恢复 $FP$，并将 $PC$ 设置为保存的返回地址。如果栈变空，则执行停止。\n- $OP\\_TAILCALL\\ x$: 尾调用函数 $x$；通过用被调用者的函数标识符和局部布局替换当前帧的相应内容来重用当前帧，将 $PC$ 设置为被调用者的入口，并且不修改 $SP$。\n- $OP\\_SETR\\ n$: 将通用计数寄存器 $R$ 设置为整数 $n$；将 $PC$ 增加 $1$。\n- $OP\\_DECJNZ\\ t$: 将 $R$ 减 $1$；如果 $R  0$，则将 $PC$ 设置为目标地址 $t$；否则将 $PC$ 增加 $1$。\n\n初始化与测量：\n- 模拟开始时，为指定的 \"main\" 函数压入一个初始帧，其局部变量大小为 $L\\_{main}$，初始 $SP$ 值为 $1000$。当最后的 $OP\\_RET$ 指令弹出最后一个帧时，初始帧保存的返回地址必须被视为一个哨兵值，用以标志执行停止。\n- 每执行一条指令，记录当前的 $PC$ 是否已被访问，以计算所见到的不同 $PC$ 值的数量。\n- 在执行期间跟踪 $SP$ 的最小值，以计算最大栈深度，公式为 $SP\\_{initial} - \\min(SP)$。\n- 跟踪每个 $OP\\_TAILCALL$ 步骤是否保持 $\\Delta SP = 0$，并生成一个布尔值，指示所有观察到的尾调用是否都是正确的（即，每个尾调用的 $\\Delta SP = 0$）。\n\n测试套件：\n在模拟器中提供四个独立的测试程序，每个程序都有自己的函数表（将函数标识符映射到入口点和局部变量大小）和指令内存。对于每个测试用例，“main”函数的标识符必须为 $0$，初始 $SP$ 必须为 $1000$。\n\n- 测试用例 1 (帧大小相等的正确尾调用)：\n  函数和局部变量大小：$L\\_{main} = 1$, $L\\_f = 3$, $L\\_g = 3$。\n  入口：$entry(main) = 0$, $entry(f) = 10$, $entry(g) = 20$。\n  指令内存：\n  - 地址 $0$：$OP\\_CALL\\ 1$；地址 $1$：$OP\\_RET$。\n  - 地址 $10$：$OP\\_NOP$；地址 $11$：$OP\\_TAILCALL\\ 2$。\n  - 地址 $20$：$OP\\_NOP$；地址 $21$：$OP\\_RET$。\n  预期展示的属性：从 $f$ 到 $g$ 的尾调用具有 $\\Delta SP = 0$。\n\n- 测试用例 2 (通过计数器实现的有界深度非尾递归)：\n  函数和局部变量大小：$L\\_{main} = 1$, $L\\_r = 2$。\n  入口：$entry(main) = 0$, $entry(r) = 10$。\n  指令内存：\n  - 地址 $0$：$OP\\_SETR\\ 3$；地址 $1$：$OP\\_CALL\\ 3$；地址 $2$：$OP\\_RET$。\n  - 地址 $10$：$OP\\_DECJNZ\\ 12$；地址 $11$：$OP\\_RET$；地址 $12$：$OP\\_CALL\\ 3$；地址 $13$：$OP\\_RET$。\n  预期展示的属性：嵌套调用增加栈深度；没有发生尾调用。\n\n- 测试用例 3 (尾递归)：\n  函数和局部变量大小：$L\\_{main} = 1$, $L\\_t = 1$。\n  入口：$entry(main) = 0$, $entry(t) = 20$。\n  指令内存：\n  - 地址 $0$：$OP\\_SETR\\ 4$；地址 $1$：$OP\\_CALL\\ 4$；地址 $2$：$OP\\_RET$。\n  - 地址 $20$：$OP\\_DECJNZ\\ 22$；地址 $21$：$OP\\_RET$；地址 $22$：$OP\\_TAILCALL\\ 4$。\n  预期展示的属性：每次尾调用都保持 $\\Delta SP = 0$；在递归步骤中栈深度保持不变。\n\n- 测试用例 4 (零局部变量的正确尾调用)：\n  函数和局部变量大小：$L\\_{main} = 0$, $L\\_z = 0$, $L\\_y = 0$。\n  入口：$entry(main) = 0$, $entry(z) = 30$, $entry(y) = 40$。\n  指令内存：\n  - 地址 $0$：$OP\\_CALL\\ 5$；地址 $1$：$OP\\_RET$。\n  - 地址 $30$：$OP\\_TAILCALL\\ 6$。\n  - 地址 $40$：$OP\\_RET$。\n  预期展示的属性：使用零局部变量帧的尾调用显然能保持栈深度不变，且 $\\Delta SP = 0$。\n\n对于每个测试用例，模拟器必须计算并输出以下四元组：\n- 执行的指令总步数（整数）。\n- 最大栈深度，计算公式为 $SP\\_{initial} - \\min(SP)$（整数）。\n- 布尔值，指示是否观察到的每个尾调用都满足 $\\Delta SP = 0$（使用 $1$ 表示真，$0$ 表示假）。\n- 执行期间访问过的不同 $PC$ 值的数量（整数）。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例按上述顺序贡献其自己的子列表。例如，最终输出必须类似于 $[[a\\_1,b\\_1,c\\_1,d\\_1],[a\\_2,b\\_2,c\\_2,d\\_2],[a\\_3,b\\_3,c\\_3,d\\_3],[a\\_4,b\\_4,c\\_4,d\\_4]]$，只包含整数和布尔值。不得打印任何额外文本。",
            "solution": "问题陈述被评估为有效的，尽管存在一些特定的模糊之处，需要严谨而明确的解释才能构建一个良构的模拟模型。\n\n主要的模糊之处在于，指定的栈帧内容与函数调用时指定的栈指针（$SP$）变化之间存在矛盾。\n\n规范 A 指出：“每个帧包含一个保存的返回地址（一个整数 $PC$）、一个保存的帧指针（一个整数 $FP$）、一个函数标识符（一个整数）和若干局部变量槽（一个整数 $L$）。” 这意味着，如果函数标识符被存储而 $L$ 是派生出来的，那么一个帧在栈上的存储空间必须能容纳至少 $3+L$ 个整数值；如果两者都存储，则需要 $4+L$ 个。\n规范 B 指出：“压入一个帧会使 $SP$ 减少 $2 + L$（用于保存返回地址、保存帧指针和局部变量）”。这将帧在栈上的大小限制为恰好 $2+L$ 个整数值。\n\n这两条规范是相互矛盾的。为了解决这个问题并创建一个确定性模型，我们采纳以下解释：规范 B 是一个规定性规则，用于管理机器的栈内存操作。规范 A 是一个描述性规则，描述了与一个栈帧在概念上关联的全部信息。因此，那些无法放入 $2+L$ 个栈上槽位的信息——即`函数标识符`及其对应的`局部变量大小 L`——必须作为主栈内存之外的元数据进行管理。我们的模拟器通过其唯一的帧指针（$FP$）值将此元数据与一个帧关联起来。这种方法解决了这个矛盾，同时遵守了所有指令的指定行为，特别是正确尾调用保持栈不变的特性（其中 $\\Delta SP = 0$）。\n\n其次，测试用例描述中存在一个较小的模糊之处，即它们使用了符号化的函数名（例如 $f$、$g$、$r$），而指令集使用的是整数标识符（例如 $OP\\_CALL\\ 1$）。我们根据每个测试用例的上下文建立直接映射；例如，在测试用例 1 中，函数 $f$ 被赋予标识符 $1$，函数 $g$ 被赋予标识符 $2$。\n\n基于此形式化解释，我们定义了模拟器的设计。\n\n**系统模型**\n\n模拟的机器状态由一组寄存器和内存区域定义：\n1.  **寄存器**:\n    -   程序计数器 ($PC$): 指令内存的一个整数索引。\n    -   栈指针 ($SP$): 指向栈内存中栈顶的一个整数索引。栈向低地址方向增长。\n    -   帧指针 ($FP$): 指向当前活动记录（栈帧）内固定参考点的一个整数索引。\n    -   通用计数器 ($R$): 用于循环控制的一个整数寄存器。\n2.  **内存**:\n    -   指令内存: 一个指令数组，由 $PC$ 索引。\n    -   栈内存: 一个单独的整数数组。使用 $SP=1000$ 的初始值。\n3.  **帧元数据**:\n    -   为解决上述矛盾，我们维护一个活动帧表。此表中的每个条目将一个帧的基地址 ($FP$) 映射到其概念上的元数据：其函数标识符和局部变量槽的数量 ($L$)。\n\n**栈帧约定**\n\n函数调用会将一个新帧压入栈中。对于一个拥有 $L$ 个局部变量的函数，其帧在栈内存中占用 $2+L$ 个字。相对于新的 $FP$，其布局如下：\n-   `stack[FP + 1]`: 保存的返回地址（调用者的 $PC+1$）。\n-   `stack[FP]`: 保存的帧指针（调用者的 $FP$）。\n-   `stack[FP - 1]` 到 `stack[FP - L]`：$L$ 个用于局部变量的槽位。\n\n函数调用时，$SP$ 会更新以指向新帧的顶部，地址为 $FP - L$。因此，栈指针的变化是 $\\Delta SP = (FP - L) - (FP_{old} + 2) = (SP_{old} - (2+L) - L) - (SP_{old} - L_{old}) \\dots$ 一个更直接的定义是，新的 $SP$ 为 $SP_{old} - (2+L)$。新的 $FP$ 被设置为 $SP_{new} + L$。\n\n**指令语义**\n模拟器在一个循环中执行指令，根据以下形式化定义修改机器状态：\n\n-   $OP\\_NOP$: $PC \\leftarrow PC + 1$。\n-   $OP\\_SETR\\ n$: $R \\leftarrow n$; $PC \\leftarrow PC + 1$。\n-   $OP\\_DECJNZ\\ t$: $R \\leftarrow R - 1$。如果 $R  0$，则 $PC \\leftarrow t$。否则，$PC \\leftarrow PC + 1$。\n-   $OP\\_CALL\\ x$: 设被调用函数为 $x$，其局部变量数为 $L_x$，入口点为 $entry_x$。\n    1.  $frame\\_size \\leftarrow 2 + L_x$。\n    2.  $SP_{new} \\leftarrow SP - frame\\_size$。\n    3.  $FP_{new} \\leftarrow SP_{new} + L_x$。\n    4.  `stack[FP_new + 1]` $\\leftarrow PC + 1$（保存返回地址）。\n    5.  `stack[FP_new]` $\\leftarrow FP$（保存旧的帧指针）。\n    6.  $SP \\leftarrow SP_{new}$。\n    7.  $FP \\leftarrow FP_{new}$。\n    8.  为新帧注册元数据：`metadata(FP) \\leftarrow \\{id: x, L: L_x\\}`。\n    9.  $PC \\leftarrow entry_x$。\n-   $OP\\_RET$: 设当前函数有 $L_{curr}$ 个局部变量，从 `metadata(FP)` 中检索。\n    1.  如果 `stack[FP + 1]` 是哨兵停止地址，则终止模拟。\n    2.  $frame\\_size \\leftarrow 2 + L_{curr}$。\n    3.  $PC_{restored} \\leftarrow$ `stack[FP + 1]`。\n    4.  $FP_{restored} \\leftarrow$ `stack[FP]`。\n    5.  $SP \\leftarrow SP + frame\\_size$。\n    6.  $FP \\leftarrow FP_{restored}$。\n    7.  $PC \\leftarrow PC_{restored}$。\n    8.  为弹出的帧注销元数据。\n-   $OP\\_TAILCALL\\ x$: 设被调用函数为 $x$，其局部变量数为 $L_x$，入口点为 $entry_x$。当前函数的局部变量数 $L_{curr}$ 从 `metadata(FP)` 中检索。问题保证所有测试用例中 $L_{curr} = L_x$。\n    1.  $SP_{before} \\leftarrow SP$。\n    2.  更新帧元数据：`metadata(FP) \\leftarrow \\{id: x, L: L_x\\}`。\n    3.  $PC \\leftarrow entry_x$。\n    4.  验证 $\\Delta SP = SP - SP_{before} = 0$。\n\n**模拟与测量**\n对于每个测试用例，模拟器通过为 `main` 函数（标识符 0）压入一个带有哨兵返回地址（`-1`）和哨兵帧指针的帧来初始化。模拟过程会从指定的内存布局中获取并执行指令，直到 `main` 函数的哨兵返回被执行。\n\n在模拟期间，跟踪以下指标：\n-   **总步数**：为每个执行的指令递增的计数器。\n-   **最大栈深度**：计算为 $SP_{initial} - SP_{min}$，其中 $SP_{initial}=1000$，$SP_{min}$ 是在执行期间观察到的 $SP$ 的最小值。\n-   **正确的尾调用**：一个布尔标志，初始化为真（$1$），如果任何 $OP\\_TAILCALL$ 指令导致 $SP$ 的非零变化，则设置为假（$0$）。如果没有发生尾调用，则保持为真。\n-   **访问过的不同 PC**：一个布尔数组充当集合，用于记录执行期间遇到的每个唯一的 $PC$ 值。最终计数是该集合的基数。\n\n最终输出是一个包含四元组的列表，每个测试用例对应一个元组，其中包含这些计算出的指标。",
            "answer": "[[6,8,1,6],[11,15,1,7],[11,6,1,6],[4,4,1,4]]"
        }
    ]
}