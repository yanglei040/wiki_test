{
    "hands_on_practices": [
        {
            "introduction": "要理解微操作，我们首先需要思考如何通过控制信号来指挥数据在处理器内部的流动。本练习将带您设计一组最精简的控制信号，用于在一个双总线数据路径上执行一次基本的算术加法 。通过这个实践，您将掌握如何根据数据路径的结构来确定必需的控制位，并理解二进制编码在节约控制逻辑方面的重要性，为设计更复杂的控制单元打下基础。",
            "id": "3659195",
            "problem": "一个数字处理器数据通路采用两条内部源总线（记为 $A$ 和 $B$）为算术逻辑单元（ALU）的输入提供数据，以及一条由 ALU 结果驱动的单一写回总线 $C$。寄存器堆（RF）包含 $16$ 个通用寄存器，有两个独立的读端口（一个连接到总线 $A$，一个连接到总线 $B$），以及一个连接到总线 $C$ 的写端口。每个读端口通过一个二进制编码的多路复用器（MUX）进行选择，该多路复用器从 $16$ 个寄存器输出中选择一个。ALU 实现 $8$ 种不同的操作，其中之一是加法。控制选择是经过编码的，而非独热码（one-hot）；不要引入冗余或功能上重复的控制线。假设除了 MUX 选择和单个寄存器写使能信号所隐含的之外，总线 $A$、$B$ 或 $C$ 没有单独的使能线。寄存器堆的读取发生在时钟周期的前半部分，ALU 在后半部分及时产生其输出，对目标寄存器的写回发生在周期结束时。\n\n从微操作作为由二进制信号控制的寄存器传输行为的公认定义出发，并基于“通过二进制编码从 $N$ 个备选项中选择一个需要 $\\lceil \\log_{2}(N) \\rceil$ 个控制位”这一事实，设计在该数据通路上执行微操作 $R_{d} \\leftarrow R_{a} + R_{b}$ 所需的最小控制信号集。定性地枚举各信号的作用，然后推导出在所述约束条件下完成此操作必须驱动的独立二进制控制信号的最小总数。\n\n此外，编写一个微操作时序表，该时序表能利用总线 $A$ 和 $B$ 之间的并行性，且无资源冲突。尽管该时序表是您推导过程的一部分，但您的最终数值答案应仅为最小控制信号的数量。\n\n将您的最终答案表示为单个整数。无需四舍五入。",
            "solution": "该问题陈述已经过验证，被认为是科学上合理、定义明确且完整的。它描述了计算机组成与体系结构中的一个标准数据通路配置，而任务是对数字控制设计基本原理的直接应用。\n\n目标是确定执行微操作 $R_{d} \\leftarrow R_{a} + R_{b}$ 所需的二进制控制信号的最小数量。此操作涉及三个必须被控制的主要阶段：从寄存器堆读取源操作数，在 ALU 中执行加法，以及将结果写回到目标寄存器。我们将根据提供的规范，分析每个阶段的控制需求。\n\n问题指明控制信号是二进制编码的，这意味着要从 $N$ 个备选项中选择一个，我们需要一个宽度为 $\\lceil \\log_{2}(N) \\rceil$ 位的控制字段。\n\n1.  **寄存器堆读取控制：**\n    该操作需要同时读取两个源寄存器，$R_a$ 和 $R_b$。寄存器堆 (RF) 有 $16$ 个通用寄存器和两个独立的读端口，一个为总线 $A$ 提供数据，另一个为总线 $B$ 提供数据。\n    *   为了给第一个读端口（总线 $A$）选择寄存器 $R_{a}$，一个多路复用器必须从 $16$ 个可用寄存器中选择一个。此选择所需的控制位数，我们可以称之为 ``A_Select``，是：\n        $$N_{A\\_Select} = \\lceil \\log_{2}(16) \\rceil = 4 \\text{ bits}$$\n    *   类似地，为了给第二个独立读端口（总线 $B$）选择寄存器 $R_{b}$，另一个多路复用器必须从同样的 $16$ 个寄存器中选择一个。此选择的控制位数 ``B_Select``，是：\n        $$N_{B\\_Select} = \\lceil \\log_{2}(16) \\rceil = 4 \\text{ bits}$$\n    这两组控制信号必须是不同的，以便允许同时读取任意两个寄存器。\n\n2.  **ALU 操作控制：**\n    来自总线 $A$ 和总线 $B$ 的值被送入算术逻辑单元 (ALU)。必须指令 ALU 执行加法操作。问题陈述 ALU 可以执行 $8$ 种不同的操作。\n    *   为了从 $8$ 种可能的 ALU 操作中选择一种，需要一个二进制编码的控制信号 ``ALU_Select``。该信号的位数是：\n        $$N_{ALU\\_Select} = \\lceil \\log_{2}(8) \\rceil = 3 \\text{ bits}$$\n    对于特定的微操作 $R_{d} \\leftarrow R_{a} + R_{b}$，这 $3$ 位将被设置为对应于加法的唯一二进制代码。\n\n3.  **寄存器堆写入控制：**\n    来自 ALU 的结果被放置在总线 $C$ 上，并且必须写回到寄存器堆中的目标寄存器 $R_d$。这需要两个不同的控制动作：选择目标寄存器和使能写操作。\n    *   为了从 $16$ 个可用寄存器中选择目标寄存器 $R_{d}$，必须向 RF 的写端口提供一个写地址。这个目标选择信号 ``Dest_Select`` 的位数是：\n        $$N_{Dest\\_Select} = \\lceil \\log_{2}(16) \\rceil = 4 \\text{ bits}$$\n        这组控制信号必须独立于读选择信号，以支持目标寄存器与两个源寄存器都不同的操作（例如，$R_{3} \\leftarrow R_{1} + R_{2}$）。\n    *   需要一个控制信号来实际使能写操作。问题指明了一个“单个寄存器写使能”。这是一个单位二进制信号，我们可以称之为 ``Reg_Write``。它被置为有效（例如，设置为 $1$），以允许总线 $C$ 上的数据在适当的时钟边沿存入所选的目标寄存器。对于不向 RF 写入的操作（如比较操作），它被置为无效（例如，设置为 $0$）。该信号的位数是：\n        $$N_{Reg\\_Write} = 1 \\text{ bit}$$\n\n综合这些需求，最小控制信号集由上述识别出的不同控制字段组成。二进制控制信号的总数 $N_{total}$ 是每个字段所需位数的总和：\n\n$$N_{total} = N_{A\\_Select} + N_{B\\_Select} + N_{ALU\\_Select} + N_{Dest\\_Select} + N_{Reg\\_Write}$$\n$$N_{total} = 4 + 4 + 3 + 4 + 1$$\n$$N_{total} = 16$$\n\n利用两个读端口并行性的微操作时序，在单个时钟周期内发生，如下所示：\n*   **时间间隔 1（例如，周期的前半部分）：** 源寄存器被同时读取。控制信号 ``A_Select`` 和 ``B_Select`` 分别被设置为 $R_a$ 和 $R_b$ 的地址。\n    -   `Bus A - RF[address=a]`\n    -   `Bus B - RF[address=b]`\n*   **时间间隔 2（例如，周期的后半部分）：** ALU 对来自总线的值执行指定的操作。``ALU_Select`` 信号被设置为加法代码。计算结果并使其在总线 $C$ 上可用。\n    -   `Bus C - (Bus A) + (Bus B)`\n*   **时间间隔 3（例如，在周期结束的时钟边沿）：** 结果被写回到目标寄存器。``Dest_Select`` 信号被设置为 $R_d$ 的地址，并且 ``Reg_Write`` 信号被置为有效。\n    -   `RF[address=d] - Bus C`\n\n控制单元中为指定此类微操作而必须提供的不同控制信号的总数是 $16$。",
            "answer": "$$ \\boxed{16} $$"
        },
        {
            "introduction": "掌握了如何为单步操作定义控制信号后，下一步是学习如何编排一系列微操作来完成更复杂的计算任务。本练习要求您在一个资源有限的数据路径上，为一个涉及三个操作数和两种不同运算的表达式设计执行序列 。这个过程模拟了微程序员的日常工作：将复杂的指令分解为多个时钟周期内的基本步骤，并有效管理临时寄存器等宝贵资源，以确保数据流的正确性和高效性。",
            "id": "3659246",
            "problem": "一个同步数据路径包含一个支持两读一写的寄存器堆和一个按位算术逻辑单元（ALU）。寄存器堆在寄存器 $R_0, R_1, \\dots$ 中存储 $w$ 位字，并在每个周期提供两个独立的读端口和一个写端口。在每个时钟周期，最多将一个 $w$ 位 ALU 操作应用于其两个输入。所有微操作遵循标准的寄存器传输级（RTL）语义：读操作观察周期的前一个状态；写操作在有效时钟沿提交，并且仅在后续周期中可见。ALU 支持按位异或和按位与这两种二元运算，分别表示为 $\\oplus$ 和 $\\land$。ALU 的一个操作数（$B$ 输入）可以在操作前由一个单位信号控制进行取反，从而对该操作数实现 $\\neg(\\cdot)$ 运算。ALU 的输出可以在时钟沿锁存到一个 $w$ 位的临时输出寄存器 $Z$ 中，并且在后续周期中，$Z$ 可以通过输入多路复用器被选为 ALU 的一个输入。除了 $Z$ 之外，没有其他可用的临时存储。控制信号包括：\n- ``RA`` 和 ``RB``：寄存器堆两个读端口的读地址，\n- ``WD``：寄存器堆写地址，\n- ``WE``：寄存器堆写使能，\n- ``ALU_OP`` $\\in$ {`XOR`, `AND`}：ALU 操作选择器，\n- ``INV_B`` $\\in \\{0,1\\}$：ALU $B$ 输入的取反使能，\n- ``A_SEL`` $\\in$ {`RF_A`, `Z`} 和 ``B_SEL`` $\\in$ {`RF_B`, `Z`}：ALU 输入源选择器，\n- ``Z_EN``：$Z$ 的锁存使能。\n\n设计一个正确的微操作序列来计算表达式\n$$\nR_d \\leftarrow \\bigl(R_a \\oplus R_b\\bigr) \\land \\neg R_c\n$$\n对于任意的寄存器索引 $a$、$b$、$c$ 和 $d$（不一定互不相同），并使用上述数据路径所允许的最小临时存储。逐项列出每个周期的控制信号 ``RA``、``RB``、``WD``、``WE``、``ALU_OP``、``INV_B``、``A_SEL``、``B_SEL`` 和 ``Z_EN`` 的值。根据寄存器传输语义的基本约束和 ALU 的功能能力，证明你的调度方案的最小性。\n\n将最终答案表示为完成计算所需的最小时钟周期数。无需四舍五入。仅报告此数字作为最终答案。",
            "solution": "我们从同步系统中寄存器传输级（RTL）微操作的核心定义开始。在一个时钟周期内：\n- 寄存器堆可以通过其由 ``RA`` 和 ``RB`` 寻址的读端口提供两个源操作数。\n- ALU 可对其两个输入执行最多一个由 ``ALU_OP`` 选择的操作。\n- 在操作之前，$B$ 输入可以由 ``INV_B`` 控制选择性地取反。\n- 如果 `WE=1`，寄存器堆可以在 ``WD`` 处写入一个目标寄存器，该操作在时钟沿提交，并在下一周期可见。\n- 如果 `Z_EN=1`，ALU 的输出可以被捕获到临时输出寄存器 $Z$ 中，并且在后续周期中，$Z$ 可以通过 ``A_SEL`` 或 ``B_SEL`` 被选为 ALU 的输入。\n\n目标计算是\n$$\nR_d \\leftarrow \\bigl(R_a \\oplus R_b\\bigr) \\land \\neg R_c.\n$$\n该表达式涉及应用于三个操作数（$R_a$、$R_b$、$R_c$）的两种不同按位运算（$\\oplus$ 和 $\\land$），并且存在依赖关系：$R_a \\oplus R_b$ 的结果必须作为与 $\\neg R_c$ 进行与运算的一个输入。在所述约束下，ALU 是二元的，并且每个周期仅执行一个操作。因此，任何正确的调度都必须分配至少两个周期：一个周期用于生成 $\\bigl(R_a \\oplus R_b\\bigr)$，另一个周期用于将该中间结果与 $\\neg R_c$ 进行与运算。在单个周期内完成计算是不可能的，因为：\n- ALU 只有两个输入，因此无法同时直接组合三个独立的操作数 $R_a$、$R_b$ 和 $R_c$。\n- ALU 每个周期只能执行一个操作，这排除了在单个周期内并行计算 $\\oplus$ 和 $\\land$ 的可能性。\n\n因此，根据功能约束，确定了 $2$ 个周期的下限。\n\n接下来，我们构建一个调度方案，该方案在实现此下限的同时使用最少的临时存储。如果我们在此处使用 $R_c$ 之前将中间结果 $\\bigl(R_a \\oplus R_b\\bigr)$ 写入寄存器堆中的任何寄存器，当 $d=c$ 时（因为目标寄存器等于一个源寄存器），我们可能会危险地覆盖 $R_c$。为了避免 $a$、$b$、$c$ 和 $d$ 之间的任何寄存器别名依赖，我们使用唯一可用的临时输出寄存器 $Z$ 来跨周期保存中间结果，并将任何寄存器堆写入操作推迟到最后一个周期。这只使用了允许的最小临时存储 ($Z$)。\n\n一个正确的两周期调度如下：\n\n- 周期 1（计算中间结果 $\\bigl(R_a \\oplus R_b\\bigr)$ 并将其锁存到 $Z$ 中）：\n  - ``RA`` = $a$\n  - ``RB`` = $b$\n  - ``A_SEL`` = `RF_A`（ALU $A$ 输入源自 ``RA`` 寻址的寄存器堆读端口）\n  - ``B_SEL`` = `RF_B`（ALU $B$ 输入源自 ``RB`` 寻址的寄存器堆读端口）\n  - ``ALU_OP`` = `XOR`\n  - ``INV_B`` = 0（不对 $R_b$ 进行取反以进行异或运算）\n  - ``Z_EN`` = 1（将 ALU 输出捕获到 $Z$ 中）\n  - ``WE`` = 0（此周期不写入寄存器堆）\n  - ``WD`` 是无关项 (don't care, DNC)\n\n  在此周期结束时，$Z \\leftarrow R_a \\oplus R_b$。\n\n- 周期 2（计算 $\\bigl(R_a \\oplus R_b\\bigr) \\land \\neg R_c$ 并将其写入 $R_d$）：\n  - ``RA`` 是 DNC（此周期 ALU $A$ 输入不来自寄存器堆）\n  - ``RB`` = $c$\n  - ``A_SEL`` = `Z`（ALU $A$ 输入源自 $Z$，其中保存了 $R_a \\oplus R_b$）\n  - ``B_SEL`` = `RF_B`（ALU $B$ 输入源自 ``RB`` 寻址的寄存器堆读端口）\n  - ``ALU_OP`` = `AND`\n  - ``INV_B`` = 1（对 $B$ 输入取反，以便 ALU 形成 $Z \\land \\neg R_c$）\n  - ``Z_EN`` = 0（如果我们将结果写入寄存器堆，则无需将其锁存在 $Z$ 中）\n  - ``WE`` = 1（使能寄存器堆写）\n  - ``WD`` = $d$（将 ALU 输出写入 $R_d$）\n\n  在此周期结束时，$R_d \\leftarrow Z \\land \\neg R_c = \\bigl(R_a \\oplus R_b\\bigr) \\land \\neg R_c$。\n\n正确性源于功能组合：周期 1 计算出周期 2 所需的精确中间结果，周期 2 将其与取反后的 $R_c$ 进行按位与运算。该调度对 $a$、$b$、$c$ 和 $d$ 之间的任何别名都是稳健的，因为在周期 1 中没有写入寄存器堆，因此即使在 $d=c$ 的情况下，也没有源操作数在使用前被覆盖。\n\n最小性论证：我们已经证明，由于 ALU 的二元输入和单操作约束，一个周期是不够的。上述调度在 $2$ 个周期内完成，达到了下限。因此，所需的最少周期数为 $2$。\n\n因此，使用的最小临时存储是单个 $w$ 位 $Z$ 寄存器，最小周期计数为 $2$。",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "最后，我们将把前面学到的微操作和控制信号知识应用到实现一个真实的计算机指令中。这个练习模拟了为一种新的索引寻址模式设计执行阶段的微操作序列 。通过这个任务，您将把抽象的算术逻辑单元（ALU）操作、寄存器读写和内存访问等微观活动，与指令集架构（ISA）中定义的高层指令行为联系起来，深刻理解CPU是如何通过一系列精心编排的底层动作来执行程序的。",
            "id": "3659239",
            "problem": "一个微程序控制的中央处理器实现了一种新的索引寻址模式，该模式由架构规范定义如下：给定一个源寄存器 $R_{s}$、一个目标寄存器 $R_{d}$ 以及嵌入在当前指令中的一个有符号位移字段 $\\mathrm{disp}$，指令语义为 $R_{d} \\leftarrow M[R_{s} + \\mathrm{disp}]$，其中 $M[\\cdot]$ 表示有效地址处的内存。数据通路包含一个通用寄存器文件、一个算术逻辑单元（ALU）、一个内存地址寄存器（MAR）、一个内存数据寄存器（MDR）以及一个保存当前指令的指令寄存器（IR）。位移 $\\mathrm{disp}$ 从 ``IR`` 的一个固定字段中获取，并在使用前进行符号扩展。当内存读取控制信号被置为有效时，内存接口会根据 ``MAR`` 提供的有效地址将数据读入 ``MDR``。ALU 有两个输入多路复用器，可以在同一个微周期内由任意来源驱动，这些来源包括寄存器文件读端口、立即数（如符号扩展后的位移）以及内部寄存器。假设 ALU 可以在一个微周期内完成 $+$ 计算，并且内存读取请求也能在一个微周期内完成。该控制单元采用水平微码：每条微指令直接驱动 $k$ 条布尔控制线，这些控制线分别用于将源数据门控到内部总线或 ALU 输入、选择 ALU 功能以及置位寄存器加载和内存控制信号。微序列器使用微指令中包含的下一地址字段来选择下一条微指令的地址，并支持两种定序模式：顺序执行到下一个微地址（fall-through），或无条件跳转到微指令中编码的显式目标地址。控制存储器总共包含 $M$ 条微指令。你可以假设加载 ``IR`` 的取指和译码阶段已经完成，你的重点仅在于索引寻址模式的执行。\n\n任务：\n- 概述一个实现此索引寻址模式执行的最小微操作序列，并为每个微操作，使用诸如 ``MAR_load``、``MDR_load``、``MemRead``、寄存器文件读/写使能和选择、ALU 功能选择以及多路复用器选择等常规名称，列出必须由微指令驱动以实现该操作的基本控制信号。如果根据给定的数据通路假设是合理的，可以将数据通路在一个微周期内可以并发执行的操作组合在一起。\n- 基于给定的微序列器模型，推导控制存储器中一条微指令的最小宽度 $W$（以比特为单位）作为 $k$ 和 $M$ 的函数的解析表达式，明确指出直接控制线和支持顺序执行或无条件跳转所需的下一地址控制的贡献。用一个关于 $k$ 和 $M$ 的封闭形式表达式来表示你的最终答案。不需要数值。",
            "solution": "该问题被评估为有效，因为它科学地基于计算机体系结构的原理，问题明确、客观且内部一致。它提出了一个在微程序控制器设计中标准的、可解决的问题。\n\n该问题包括两个任务：首先，定义执行特定索引寻址模式指令的微操作序列及相关的控制信号；其次，推导微指令宽度的表达式。\n\n**任务1：微操作和控制信号**\n\n需要实现的指令是 $R_{d} \\leftarrow M[R_{s} + \\mathrm{disp}]$。该操作可以分解为三个基本的、顺序的步骤：\n$1$. 通过将源寄存器 $R_{s}$ 的内容与符号扩展后的位移 $\\mathrm{disp}$ 相加，计算有效内存地址。\n$2$. 使用此有效地址从内存中读取一个值。\n$3$. 将从内存中读取的值写入目标寄存器 $R_{d}$。\n\n根据所描述的数据通路能力，ALU 和内存访问都可以在一个微周期内完成，因此需要一个由三个微操作组成的最小序列。这些步骤是数据相关的，无法进一步压缩。\n\n**微周期1：有效地址计算**\n第一个微操作计算有效地址并将其加载到内存地址寄存器 (`MAR`) 中。根据数据通路的规定，ALU 可以在同一个周期内从寄存器文件 ($R_s$) 获取一个操作数，并从指令寄存器的符号扩展位移字段 ($\\mathrm{disp}$) 获取另一个操作数。\n\n-   **微操作：** $MAR \\leftarrow R_{s} + \\mathrm{disp}$\n-   **基本控制信号：**\n    -   寄存器文件控制：读取寄存器 $R_{s}$ 内容的信号。一个示例信号是 ``RegReadEnable``。从 ``IR`` 获取的 $R_s$ 地址必须提供给寄存器文件的读地址端口。\n    -   ALU 输入多路复用器选择：将寄存器文件的输出路由到一个 ALU 输入端口，并将来自 ``IR`` 的符号扩展位移路由到另一个 ALU 输入端口的信号。\n    -   ALU 功能选择：配置 ALU 执行加法操作的信号，例如 ``ALU_OP`` 设置为 `'ADD'`。\n    -   MAR 加载使能：将 ALU 的输出加载到 `MAR` 的信号，例如 ``MAR_load``。\n\n**微周期2：内存读取**\n当有效地址位于 `MAR` 中时，可以启动内存读取操作。问题陈述该操作在一个微周期内完成，数据在该周期结束时可在内存数据寄存器 (`MDR`) 中获取。\n\n-   **微操作：** $MDR \\leftarrow M[MAR]$\n-   **基本控制信号：**\n    -   内存读取控制：命令内存系统使用 `MAR` 中的地址执行读取操作的信号，例如 ``MemRead``。\n    -   MDR 加载使能：将来自内存数据总线的数据锁存到 `MDR` 的信号，例如 ``MDR_load``。该信号在内存读取完成的周期内保持有效。\n\n**微周期3：寄存器写回**\n最后一步是将数据从 `MDR` 传输到寄存器文件中的目标寄存器 $R_{d}$。\n\n-   **微操作：** $R_{d} \\leftarrow MDR$\n-   **基本控制信号：**\n    -   寄存器文件写使能：使能对寄存器文件进行写操作的信号，例如 ``RegWriteEnable``。\n    -   寄存器文件写地址选择：从 ``IR`` 获取的目标寄存器 $R_{d}$ 的地址必须提供给寄存器文件的写地址端口。\n    -   写回多路复用器选择：选择 `MDR` 作为要写入寄存器文件的数据源的信号。\n\n这个三周期序列是最小的，因为存在固有的数据依赖：内存读取必须在地址计算完成后才能开始，而寄存器写回必须在从内存中检索到数据后才能开始。\n\n**任务2：微指令宽度推导**\n\n一条微指令的宽度 $W$ 是其组成字段宽度的总和。问题描述了一种水平微码格式，它有两个主要部分：一个用于直接控制信号的字段和一个用于微定序的字段。\n\n$1$. **控制信号字段：** 问题陈述微指令“直接驱动 $k$ 条布尔控制线”。这是水平格式的特点，其中每个比特对应一个特定的控制信号（例如，`MAR_load`、`MemRead`）。因此，该字段的宽度正好是 $k$ 比特。\n\n$2$. **定序字段：** 微序列器支持两种模式：顺序执行（执行流转到地址为 $\\mu PC+1$ 的下一条微指令）和无条件跳转（执行流转到当前微指令中指定的新地址）。为了实现这一点，定序字段必须包含两条信息：\n    -   **模式选择：** 需要一个比特来区分这两种模式。编码两个不同选择所需的最少位数是 1 个比特。例如，$0$ 可以表示顺序执行，$1$ 可以表示无条件跳转。这需要 $1$ 比特。\n    -   **下一地址：** 对于无条件跳转模式，必须提供一个显式目标地址。控制存储器总共包含 $M$ 条微指令。为了唯一地寻址这 $M$ 个位置中的任何一个（从地址 $0$ 到 $M-1$），最少需要 $\\lceil \\log_{2}(M) \\rceil$ 个比特。该字段保存跳转的目标地址。\n\n定序字段的总宽度是模式选择位和下一地址字段的位数之和，即 $1 + \\lceil \\log_{2}(M) \\rceil$。\n\n**总微指令宽度 (W)：**\n总宽度 $W$ 是控制信号字段和定序字段的宽度之和。\n$$W = (\\text{控制字段宽度}) + (\\text{定序字段宽度})$$\n$$W = k + 1 + \\lceil \\log_{2}(M) \\rceil$$\n因此，一条微指令的最小宽度由表达式 $W = k + 1 + \\lceil \\log_{2}(M) \\rceil$ 给出。",
            "answer": "$$\\boxed{k + \\lceil \\log_{2}(M) \\rceil + 1}$$"
        }
    ]
}