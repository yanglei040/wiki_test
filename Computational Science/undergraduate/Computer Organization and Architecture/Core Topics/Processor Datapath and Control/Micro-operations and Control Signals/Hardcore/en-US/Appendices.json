{
    "hands_on_practices": [
        {
            "introduction": "The journey from a high-level instruction to hardware execution begins with the control unit generating the right signals at the right time. This first practice provides a foundational exercise in datapath control, where we will determine the precise set of binary signals needed to orchestrate a simple arithmetic operation . By analyzing the requirements for selecting registers, choosing an ALU function, and enabling a write-back, you will gain a concrete understanding of how abstract commands are translated into the language of the hardware.",
            "id": "3659195",
            "problem": "A digital processor datapath employs two internal source buses, denoted $A$ and $B$, feeding the inputs of an Arithmetic Logic Unit (ALU), and a single write-back bus $C$ driven by the ALU result. The register file (RF) contains $16$ general-purpose registers, has two independent read ports (one connected to bus $A$ and one to bus $B$), and one write port connected to bus $C$. Each read port is selected through a binary-encoded Multiplexer (MUX) that chooses one out of $16$ register outputs. The ALU implements $8$ distinct operations, one of which is addition. Control choices are encoded rather than one-hot; do not introduce redundant or functionally duplicative control lines. Assume there are no separate enable lines for buses $A$, $B$, or $C$ beyond those implied by the MUX selects and a single register write-enable. The register file read occurs during the first half of a clock cycle, the ALU produces its output in time for the second half, and the write-back to the destination register occurs at the end of the cycle.\n\nStarting from accepted definitions of micro-operations as register-transfer actions controlled by binary signals and the fact that selecting among $N$ alternatives by binary encoding requires $\\lceil \\log_{2}(N) \\rceil$ control bits, design the minimal set of control signals necessary to execute the micro-operation $R_{d} \\leftarrow R_{a} + R_{b}$ on this datapath. Enumerate the signal roles qualitatively, then derive the minimal total number of distinct binary control signals that must be driven to accomplish this operation under the stated constraints.\n\nAdditionally, write a micro-operation schedule that exploits parallelism across buses $A$ and $B$ with no resource conflicts. Although the schedule is part of your derivation, your final numerical answer should only be the count of minimal control signals.\n\nExpress your final answer as a single integer. No rounding is required.",
            "solution": "The problem statement has been validated and is deemed to be scientifically sound, well-posed, and complete. It describes a standard datapath configuration from computer organization and architecture, and the task is a direct application of fundamental principles of digital control design.\n\nThe objective is to determine the minimal number of binary control signals required to execute the micro-operation $R_{d} \\leftarrow R_{a} + R_{b}$. This operation involves three main stages that must be controlled: reading the source operands from the register file, performing the addition in the ALU, and writing the result back to the destination register. We will analyze the control requirements for each stage based on the provided specifications.\n\nThe problem specifies that control signals are binary encoded, meaning that to select one of $N$ alternatives, we require a control field of width $\\lceil \\log_{2}(N) \\rceil$ bits.\n\n1.  **Register File Read Control:**\n    The operation requires reading two source registers, $R_a$ and $R_b$, concurrently. The register file (RF) has $16$ general-purpose registers and two independent read ports, one feeding bus $A$ and the other feeding bus $B$.\n    *   To select the register $R_{a}$ for the first read port (bus $A$), a multiplexer must choose one out of the $16$ available registers. The number of control bits needed for this selection, which we can call `A_Select`, is:\n        $$N_{A\\_Select} = \\lceil \\log_{2}(16) \\rceil = 4 \\text{ bits}$$\n    *   Similarly, to select the register $R_{b}$ for the second independent read port (bus $B$), another multiplexer must choose one out of the same $16$ registers. The number of control bits for this selection, `B_Select`, is:\n        $$N_{B\\_Select} = \\lceil \\log_{2}(16) \\rceil = 4 \\text{ bits}$$\n    These two sets of control signals must be distinct to allow for any two arbitrary registers to be read simultaneously.\n\n2.  **ALU Operation Control:**\n    The values from bus $A$ and bus $B$ are fed into the Arithmetic Logic Unit (ALU). The ALU must be instructed to perform the addition operation. The problem states that the ALU can perform $8$ distinct operations.\n    *   To select one out of the $8$ possible ALU operations, a binary-encoded control signal, `ALU_Select`, is required. The number of bits for this signal is:\n        $$N_{ALU\\_Select} = \\lceil \\log_{2}(8) \\rceil = 3 \\text{ bits}$$\n    For the specific micro-operation $R_{d} \\leftarrow R_{a} + R_{b}$, these $3$ bits would be set to the unique binary code that corresponds to addition.\n\n3.  **Register File Write Control:**\n    The result from the ALU is placed on bus $C$ and must be written back to the destination register, $R_d$, in the register file. This requires two distinct control actions: selecting the destination register and enabling the write operation.\n    *   To select the destination register $R_{d}$ from the $16$ available registers, a write address must be provided to the RF's write port. The number of bits for this destination selection signal, `Dest_Select`, is:\n        $$N_{Dest\\_Select} = \\lceil \\log_{2}(16) \\rceil = 4 \\text{ bits}$$\n        This set of control signals must be independent of the read-select signals to support operations where the destination register is different from both source registers (e.g., $R_{3} \\leftarrow R_{1} + R_{2}$).\n    *   A control signal is needed to actually enable the write operation. The problem specifies a \"single register write-enable\". This is a single binary signal, which we can call `Reg_Write`. It is asserted (e.g., set to $1$) to permit the data on bus $C$ to be stored into the selected destination register at the appropriate clock edge. It is de-asserted (e.g., set to $0$) for operations that do not write to the RF (like a compare operation). The number of bits for this signal is:\n        $$N_{Reg\\_Write} = 1 \\text{ bit}$$\n\nCombining these requirements, the minimal set of control signals comprises the distinct control fields identified above. The total number of binary control signals, $N_{total}$, is the sum of the bits required for each field:\n\n$$N_{total} = N_{A\\_Select} + N_{B\\_Select} + N_{ALU\\_Select} + N_{Dest\\_Select} + N_{Reg\\_Write}$$\n$$N_{total} = 4 + 4 + 3 + 4 + 1$$\n$$N_{total} = 16$$\n\nThe micro-operation schedule, exploiting the parallelism of the two read ports, occurs within a single clock cycle as follows:\n*   **Time interval 1 (e.g., first half of cycle):** The source registers are read concurrently. The control signals `A_Select` and `B_Select` are set to the addresses of $R_a$ and $R_b$, respectively.\n    -   Bus $A \\leftarrow \\text{RF}[\\text{address}=a]$\n    -   Bus $B \\leftarrow \\text{RF}[\\text{address}=b]$\n*   **Time interval 2 (e.g., second half of cycle):** The ALU performs the specified operation on the values from the buses. The `ALU_Select` signal is set to the code for addition. The result is computed and becomes available on bus $C$.\n    -   Bus $C \\leftarrow (\\text{Bus } A) + (\\text{Bus } B)$\n*   **Time interval 3 (e.g., at the end of the cycle clock edge):** The result is written back to the destination register. The `Dest_Select` signal is set to the address of $R_d$, and the `Reg_Write` signal is asserted.\n    -   $\\text{RF}[\\text{address}=d] \\leftarrow \\text{Bus } C$\n\nThe total number of distinct control signals that must be available in the control unit to specify this class of micro-operation is $16$.",
            "answer": "$$ \\boxed{16} $$"
        },
        {
            "introduction": "Not all instructions can be executed in a single pass through the ALU. This exercise demonstrates how to tackle more complex computations by breaking them down into a sequence of simpler micro-operations executed over multiple clock cycles . You will learn how to manage data dependencies and utilize temporary storage to hold intermediate results, a fundamental technique for implementing complex instruction sets on hardware with limited resources.",
            "id": "3659246",
            "problem": "A synchronous data path comprises a two-read one-write register file and a bitwise Arithmetic Logic Unit (ALU). The register file holds $w$-bit words in registers $R_0, R_1, \\dots$, and provides two independent read ports and one write port per cycle. In each clock cycle, at most one $w$-bit ALU operation is applied to its two inputs. All micro-operations follow standard Register Transfer Level (RTL) semantics: reads observe the pre-state of the cycle; writes commit at the active clock edge and become visible only in the subsequent cycle. The ALU supports the binary operations bitwise exclusive-or and bitwise conjunction, denoted $\\oplus$ and $\\land$, respectively. One operand of the ALU (the $B$ input) may be complemented prior to the operation under control of a single-bit signal, effecting $\\neg(\\cdot)$ on that operand. The ALU output may be latched into a single $w$-bit temporary output register $Z$ at the clock edge and, in a subsequent cycle, $Z$ may be selected as one of the ALU inputs via input multiplexers. No other temporary storage beyond $Z$ is available. Control signals are:\n- $\\text{RA}$ and $\\text{RB}$: register file read addresses for the two read ports,\n- $\\text{WD}$: register file write address,\n- $\\text{WE}$: register file write enable,\n- $\\text{ALU\\_OP} \\in \\{\\text{XOR}, \\text{AND}\\}$: ALU operation selector,\n- $\\text{INV}_B \\in \\{0,1\\}$: complement-enable for the ALU $B$ input,\n- $\\text{A\\_SEL} \\in \\{\\text{RF\\_A}, Z\\}$ and $\\text{B\\_SEL} \\in \\{\\text{RF\\_B}, Z\\}$: ALU input source selectors,\n- $Z\\_\\text{EN}$: latch enable for $Z$.\n\nDesign a correct micro-operation sequence to compute the expression\n$$\nR_d \\leftarrow \\bigl(R_a \\oplus R_b\\bigr) \\land \\neg R_c\n$$\nfor arbitrary register indices $a$, $b$, $c$, and $d$ (not necessarily distinct), using the minimal temporary storage permitted by the data path described above. Itemize, for each cycle, the values of the control signals $\\text{RA}$, $\\text{RB}$, $\\text{WD}$, $\\text{WE}$, $\\text{ALU\\_OP}$, $\\text{INV}_B$, $\\text{A\\_SEL}$, $\\text{B\\_SEL}$, and $Z\\_\\text{EN}$. Justify the minimality of your schedule in terms of the fundamental constraints of the register-transfer semantics and the ALU’s functional capabilities.\n\nExpress the final answer as the minimal number of clock cycles required to complete the computation. No rounding is necessary. Report only this number as your final answer.",
            "solution": "We begin from the core definitions of Register Transfer Level (RTL) micro-operations in a synchronous system. In one clock cycle:\n- The register file can present two source operands via its read ports addressed by $\\text{RA}$ and $\\text{RB}$.\n- The ALU can carry out at most one operation, selected by $\\text{ALU\\_OP}$, on its two inputs.\n- The $B$ input can optionally be complemented under $\\text{INV}_B$ before the operation.\n- The register file can write one destination register at $\\text{WD}$ if $\\text{WE}=1$, which commits at the clock edge and is visible in the next cycle.\n- The ALU output may be captured into the temporary output register $Z$ if $Z\\_\\text{EN}=1$, and $Z$ can be selected as an ALU input in later cycles via $\\text{A\\_SEL}$ or $\\text{B\\_SEL}$.\n\nThe target computation is\n$$\nR_d \\leftarrow \\bigl(R_a \\oplus R_b\\bigr) \\land \\neg R_c.\n$$\nThis expression involves two distinct bitwise operations ($\\oplus$ and $\\land$) applied to three operands ($R_a$, $R_b$, $R_c$), with a dependency: the result of $R_a \\oplus R_b$ must be available as one input to the conjunction with $\\neg R_c$. Under the stated constraints, the ALU is binary and performs exactly one operation per cycle. Therefore, any correct schedule must allocate at least two cycles: one cycle to produce $\\bigl(R_a \\oplus R_b\\bigr)$ and another cycle to conjoin that intermediate with $\\neg R_c$. It is impossible to complete the computation in a single cycle because:\n- The ALU has only two inputs, so it cannot directly combine three independent operands $R_a$, $R_b$, and $R_c$ simultaneously.\n- The ALU can perform only one operation per cycle, precluding computing $\\oplus$ and $\\land$ in parallel within a single cycle.\n\nHence, a lower bound of $2$ cycles is established by the functional constraints.\n\nNext, we construct a schedule that achieves this lower bound while using minimal temporary storage. If we were to write the intermediate $\\bigl(R_a \\oplus R_b\\bigr)$ into any register in the register file before using $R_c$, we could hazardously clobber $R_c$ when $d=c$ (since the destination equals a source). To avoid any dependency on register aliasing among $a$, $b$, $c$, and $d$, we use the single available temporary output register $Z$ to hold the intermediate result across cycles, and defer any register file write until the final cycle. This uses only the permitted minimal temporary storage ($Z$).\n\nA correct two-cycle schedule is:\n\n- Cycle $1$ (compute the intermediate $\\bigl(R_a \\oplus R_b\\bigr)$ and latch it in $Z$):\n  - $\\text{RA} = a$\n  - $\\text{RB} = b$\n  - $\\text{A\\_SEL} = \\text{RF\\_A}$ (ALU $A$ input sourced from the register file read port addressed by $\\text{RA}$)\n  - $\\text{B\\_SEL} = \\text{RF\\_B}$ (ALU $B$ input sourced from the register file read port addressed by $\\text{RB}$)\n  - $\\text{ALU\\_OP} = \\text{XOR}$\n  - $\\text{INV}_B = 0$ (no complement on $R_b$ for XOR)\n  - $Z\\_\\text{EN} = 1$ (capture the ALU output into $Z$)\n  - $\\text{WE} = 0$ (do not write the register file in this cycle)\n  - The value of $\\text{WD}$ is a do-not-care value.\n\n  At the end of this cycle, $Z$ holds $Z \\leftarrow R_a \\oplus R_b$.\n\n- Cycle $2$ (compute $\\bigl(R_a \\oplus R_b\\bigr) \\land \\neg R_c$ and write it to $R_d$):\n  - $\\text{RA}$ is a do-not-care value (as the ALU $A$ input is sourced from $Z$, not the register file).\n  - $\\text{RB} = c$\n  - $\\text{A\\_SEL} = Z$ (ALU $A$ input sourced from $Z$, which holds $R_a \\oplus R_b$)\n  - $\\text{B\\_SEL} = \\text{RF\\_B}$ (ALU $B$ input sourced from the register file read port addressed by $\\text{RB}$)\n  - $\\text{ALU\\_OP} = \\text{AND}$\n  - $\\text{INV}_B = 1$ (complement the $B$ input so the ALU forms $Z \\land \\neg R_c$)\n  - $Z\\_\\text{EN} = 0$ (no need to latch the result in $Z$ if we are writing it to the register file)\n  - $\\text{WE} = 1$ (enable register file write)\n  - $\\text{WD} = d$ (write the ALU output to $R_d$)\n\n  At the end of this cycle, $R_d \\leftarrow Z \\land \\neg R_c = \\bigl(R_a \\oplus R_b\\bigr) \\land \\neg R_c$.\n\nCorrectness follows from functional composition: cycle $1$ computes the exact intermediate needed for cycle $2$, and cycle $2$ applies the bitwise conjunction with the complemented $R_c$. The schedule is robust to any aliasing among $a$, $b$, $c$, and $d$ because the register file is not written in cycle $1$, so no source operand is clobbered prior to its use, even when $d=c$.\n\nMinimality argument: We have shown that one cycle is insufficient due to the ALU’s binary input and single-operation constraint. The above schedule completes in $2$ cycles, meeting the lower bound. Therefore, the minimal number of cycles required is $2$.\n\nThus, the minimal temporary storage used is the single $w$-bit $Z$ register, and the minimal cycle count is $2$.",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "While correctness is paramount, the efficiency of a micro-program directly impacts processor performance. This final practice moves from single instruction execution to optimizing a complete routine: a memory-to-memory copy . The challenge is to design a minimal micro-operation loop that leverages hardware parallelism, such as dual-ported memory, to pipeline the read and write operations and achieve maximum throughput.",
            "id": "3659136",
            "problem": "A microprogrammed control unit must implement a memory copy of $N$ consecutive words from a source pointer register $RS$ to a destination pointer register $RD$, with auto-increment of both pointers after each use. The machine provides the following resources and semantics.\n\n- Memory is dual-ported: one read port and one write port. Each port has its own Memory Address Register (MAR) and Memory Data Register (MDR). Denote the read-port registers as $MAR\\_{RD}$ and $MDR\\_{R}$, and the write-port registers as $MAR\\_{WR}$ and $MDR\\_{W}$. The memory read control signal $MEM\\_{RD}$ starts a read using $MAR\\_{RD}$; the data appears in $MDR\\_{R}$ at the end of that microcycle. The memory write control signal $MEM\\_{WR}$ commits a write in the same microcycle using the address in $MAR\\_{WR}$ and the data in $MDR\\_{W}$. The two ports are independent and may be used concurrently in the same microcycle provided their addresses are stable for that cycle.\n- The control field $MAR\\_{SRC}$ selects which pointer register drives which memory address register:\n  - Asserting $MAR\\_{SRC}(RS \\rightarrow MAR\\_{RD})$ loads $MAR\\_{RD}$ from $RS$ for the read port in the current microcycle.\n  - Asserting $MAR\\_{SRC}(RD \\rightarrow MAR\\_{WR})$ loads $MAR\\_{WR}$ from $RD$ for the write port in the current microcycle.\n  - Both selections may be asserted together in the same microcycle without conflict.\n- Auto-increment of pointers uses dedicated incrementers. Asserting $INC\\_{RS}$ causes $RS$ to increment by one word at the end of the microcycle, and asserting $INC\\_{RD}$ causes $RD$ to increment by one word at the end of the microcycle. These increments do not consume the internal bus and can be co-issued with other non-conflicting micro-operations.\n- A dedicated internal path allows $MDR\\_{W} \\leftarrow MDR\\_{R}$ in any microcycle via a control signal $MDR\\_{XFER}$; this transfer completes within the same microcycle and does not conflict with $MEM\\_{RD}$ or $MEM\\_{WR}$.\n- Each microinstruction (one microcycle) may assert any subset of the above control signals concurrently, subject to the stated resource constraints. Microprogram next-address selection is embedded in the microinstruction and does not consume additional microcycles; assume $N \\geq 1$ and that $RS$ and $RD$ are preloaded with the initial source and destination addresses.\n\nStarting from these definitions of micro-operations and their timing, determine the minimal total number of executed microinstructions required to copy exactly $N$ words from $RS$ to $RD$. Express your final answer as a closed-form function of $N$. No rounding is needed; provide an exact expression with no units.",
            "solution": "The objective is to find the minimal number of microinstructions to copy $N$ words by leveraging the parallelism of the dual-ported memory and other hardware resources. This can be achieved by creating a pipelined micro-program.\n\n**1. Analysis of Operations and Dependencies:**\nA single word copy requires a sequence of operations: a read from the source memory location, a data transfer, and a write to the destination memory location, along with pointer increments.\n\n*   **Read Operation:** A read is initiated with `MEM_RD`. The data becomes available in `MDR_R` at the *end* of the microcycle in which the read is initiated.\n*   **Write Operation:** A write is initiated with `MEM_WR`. This requires the destination address in `MAR_WR` and the data in `MDR_W`. The data can be moved from `MDR_R` to `MDR_W` using `MDR_XFER` within the same cycle.\n\nThe crucial dependency arises from the read timing: data read in microcycle $T$ is not available for transfer and writing until the beginning of microcycle $T+1$. This establishes a natural two-stage pipeline for each word:\n*   **Stage 1 (S1):** Read the word from the source memory.\n*   **Stage 2 (S2):** Write the word to the destination memory.\n\n**2. Designing the Pipelined Micro-program:**\nThe key to efficiency is to overlap the execution of these stages for different words. While the hardware is writing word `i` (Stage 2), it can simultaneously be reading word `i+1` (Stage 1), since the read and write ports are independent. The micro-program can be structured into three parts: a prologue to fill the pipeline, a main loop for steady-state operation, and an epilogue to drain the pipeline.\n\n*   **Microcycle 1 (Prologue):**\n    This cycle performs the first read operation (S1 for word 1).\n    - `MAR_SRC(RS -> MAR_RD)`: Load the source address of the first word.\n    - `MEM_RD`: Initiate the read.\n    - `INC_RS`: Increment the source pointer for the next read. `RS` will point to the second word's source address at the start of the next cycle.\n    At the end of this cycle, the first word's data is latched into `MDR_R`. This takes **1** microinstruction.\n\n*   **Microcycles 2 through N (Main Loop):**\n    This loop executes `N-1` times (for $i=2, \\dots, N$). In each microcycle, we perform two tasks concurrently: write word `i-1` (S2) and read word `i` (S1).\n    - **Write word `i-1`:** The data for this word is available in `MDR_R` from the previous cycle.\n        - `MAR_SRC(RD -> MAR_WR)`: Load the destination address for word `i-1`.\n        - `MDR_XFER`: Transfer the data from `MDR_R` to `MDR_W`.\n        - `MEM_WR`: Write the data to the destination.\n        - `INC_RD`: Increment the destination pointer for the next write.\n    - **Read word `i`:**\n        - `MAR_SRC(RS -> MAR_RD)`: Load the source address for word `i`.\n        - `MEM_RD`: Initiate the read.\n        - `INC_RS`: Increment the source pointer for the next read.\n    All these micro-operations can be issued in a single microinstruction due to the non-conflicting nature of the hardware. This loop runs for **N-1** microinstructions.\n\n*   **Microcycle N+1 (Epilogue):**\n    After cycle `N`, the last word (word `N`) has been read into `MDR_R`, but it has not been written to memory. This final cycle is required to drain the pipeline by performing the final write (S2 for word `N`).\n    - `MAR_SRC(RD -> MAR_WR)`: Load the destination address for word `N`.\n    - `MDR_XFER`: Transfer the data from `MDR_R` to `MDR_W`.\n    - `MEM_WR`: Write the final word.\n    - `INC_RD`: Increment the destination pointer for the final time.\n    This takes **1** microinstruction.\n\n**3. Calculating Total Microinstructions:**\nThe total number of executed microinstructions is the sum of the instructions from each phase:\n- Prologue: 1 microinstruction.\n- Main Loop: `N-1` microinstructions.\n- Epilogue: 1 microinstruction.\n\nTotal Microinstructions = $1 + (N-1) + 1 = N+1$.\n\nThis two-stage pipeline achieves a throughput of one word copied per microcycle during its steady state. The total number of microcycles, and thus microinstructions, is $N+1$.",
            "answer": "$$\\boxed{N+1}$$"
        }
    ]
}