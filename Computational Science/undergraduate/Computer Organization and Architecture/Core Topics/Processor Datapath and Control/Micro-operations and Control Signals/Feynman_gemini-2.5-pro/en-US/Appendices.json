{
    "hands_on_practices": [
        {
            "introduction": "To truly understand how a CPU executes instructions, we must start with the fundamentals of the datapath. This first practice invites you to design the control signals for a basic arithmetic operation, $R_d \\leftarrow R_a + R_b$. By determining the minimal number of bits needed to select registers and ALU functions, you will gain a concrete understanding of how a control unit directs the flow of data through the processor for even the simplest command .",
            "id": "3659195",
            "problem": "A digital processor datapath employs two internal source buses, denoted $A$ and $B$, feeding the inputs of an Arithmetic Logic Unit (ALU), and a single write-back bus $C$ driven by the ALU result. The register file (RF) contains $16$ general-purpose registers, has two independent read ports (one connected to bus $A$ and one to bus $B$), and one write port connected to bus $C$. Each read port is selected through a binary-encoded Multiplexer (MUX) that chooses one out of $16$ register outputs. The ALU implements $8$ distinct operations, one of which is addition. Control choices are encoded rather than one-hot; do not introduce redundant or functionally duplicative control lines. Assume there are no separate enable lines for buses $A$, $B$, or $C$ beyond those implied by the MUX selects and a single register write-enable. The register file read occurs during the first half of a clock cycle, the ALU produces its output in time for the second half, and the write-back to the destination register occurs at the end of the cycle.\n\nStarting from accepted definitions of micro-operations as register-transfer actions controlled by binary signals and the fact that selecting among $N$ alternatives by binary encoding requires $\\lceil \\log_{2}(N) \\rceil$ control bits, design the minimal set of control signals necessary to execute the micro-operation $R_{d} \\leftarrow R_{a} + R_{b}$ on this datapath. Enumerate the signal roles qualitatively, then derive the minimal total number of distinct binary control signals that must be driven to accomplish this operation under the stated constraints.\n\nAdditionally, write a micro-operation schedule that exploits parallelism across buses $A$ and $B$ with no resource conflicts. Although the schedule is part of your derivation, your final numerical answer should only be the count of minimal control signals.\n\nExpress your final answer as a single integer. No rounding is required.",
            "solution": "The problem statement has been validated and is deemed to be scientifically sound, well-posed, and complete. It describes a standard datapath configuration from computer organization and architecture, and the task is a direct application of fundamental principles of digital control design.\n\nThe objective is to determine the minimal number of binary control signals required to execute the micro-operation $R_{d} \\leftarrow R_{a} + R_{b}$. This operation involves three main stages that must be controlled: reading the source operands from the register file, performing the addition in the ALU, and writing the result back to the destination register. We will analyze the control requirements for each stage based on the provided specifications.\n\nThe problem specifies that control signals are binary encoded, meaning that to select one of $N$ alternatives, we require a control field of width $\\lceil \\log_{2}(N) \\rceil$ bits.\n\n1.  **Register File Read Control:**\n    The operation requires reading two source registers, $R_a$ and $R_b$, concurrently. The register file (RF) has $16$ general-purpose registers and two independent read ports, one feeding bus $A$ and the other feeding bus $B$.\n    *   To select the register $R_{a}$ for the first read port (bus $A$), a multiplexer must choose one out of the $16$ available registers. The number of control bits needed for this selection, which we can call `A_Select`, is:\n        $$N_{A\\_Select} = \\lceil \\log_{2}(16) \\rceil = 4 \\text{ bits}$$\n    *   Similarly, to select the register $R_{b}$ for the second independent read port (bus $B$), another multiplexer must choose one out of the same $16$ registers. The number of control bits for this selection, `B_Select`, is:\n        $$N_{B\\_Select} = \\lceil \\log_{2}(16) \\rceil = 4 \\text{ bits}$$\n    These two sets of control signals must be distinct to allow for any two arbitrary registers to be read simultaneously.\n\n2.  **ALU Operation Control:**\n    The values from bus $A$ and bus $B$ are fed into the Arithmetic Logic Unit (ALU). The ALU must be instructed to perform the addition operation. The problem states that the ALU can perform $8$ distinct operations.\n    *   To select one out of the $8$ possible ALU operations, a binary-encoded control signal, `ALU_Select`, is required. The number of bits for this signal is:\n        $$N_{ALU\\_Select} = \\lceil \\log_{2}(8) \\rceil = 3 \\text{ bits}$$\n    For the specific micro-operation $R_{d} \\leftarrow R_{a} + R_{b}$, these $3$ bits would be set to the unique binary code that corresponds to addition.\n\n3.  **Register File Write Control:**\n    The result from the ALU is placed on bus $C$ and must be written back to the destination register, $R_d$, in the register file. This requires two distinct control actions: selecting the destination register and enabling the write operation.\n    *   To select the destination register $R_{d}$ from the $16$ available registers, a write address must be provided to the RF's write port. The number of bits for this destination selection signal, `Dest_Select`, is:\n        $$N_{Dest\\_Select} = \\lceil \\log_{2}(16) \\rceil = 4 \\text{ bits}$$\n        This set of control signals must be independent of the read-select signals to support operations where the destination register is different from both source registers (e.g., $R_{3} \\leftarrow R_{1} + R_{2}$).\n    *   A control signal is needed to actually enable the write operation. The problem specifies a \"single register write-enable\". This is a single binary signal, which we can call `Reg_Write`. It is asserted (e.g., set to $1$) to permit the data on bus $C$ to be stored into the selected destination register at the appropriate clock edge. It is de-asserted (e.g., set to $0$) for operations that do not write to the RF (like a compare operation). The number of bits for this signal is:\n        $$N_{Reg\\_Write} = 1 \\text{ bit}$$\n\nCombining these requirements, the minimal set of control signals comprises the distinct control fields identified above. The total number of binary control signals, $N_{total}$, is the sum of the bits required for each field:\n\n$$N_{total} = N_{A\\_Select} + N_{B\\_Select} + N_{ALU\\_Select} + N_{Dest\\_Select} + N_{Reg\\_Write}$$\n$$N_{total} = 4 + 4 + 3 + 4 + 1$$\n$$N_{total} = 16$$\n\nThe micro-operation schedule, exploiting the parallelism of the two read ports, occurs within a single clock cycle as follows:\n*   **Time interval 1 (e.g., first half of cycle):** The source registers are read concurrently. The control signals `A_Select` and `B_Select` are set to the addresses of $R_a$ and $R_b$, respectively.\n    -   Bus $A \\leftarrow \\text{RF}[\\text{address}=a]$\n    -   Bus $B \\leftarrow \\text{RF}[\\text{address}=b]$\n*   **Time interval 2 (e.g., second half of cycle):** The ALU performs the specified operation on the values from the buses. The `ALU_Select` signal is set to the code for addition. The result is computed and becomes available on bus $C$.\n    -   Bus $C \\leftarrow (\\text{Bus } A) + (\\text{Bus } B)$\n*   **Time interval 3 (e.g., at the end of the cycle clock edge):** The result is written back to the destination register. The `Dest_Select` signal is set to the address of $R_d$, and the `Reg_Write` signal is asserted.\n    -   $\\text{RF}[\\text{address}=d] \\leftarrow \\text{Bus } C$\n\nThe total number of distinct control signals that must be available in the control unit to specify this class of micro-operation is $16$.",
            "answer": "$$ \\boxed{16} $$"
        },
        {
            "introduction": "Building on the control of single operations, we now explore how to execute more complex expressions that require multiple steps. This exercise challenges you to sequence the computation of $(R_a \\oplus R_b) \\land \\neg R_c$, which cannot be done in a single clock cycle with a standard binary ALU. You will learn the critical role of temporary registers for storing intermediate results and appreciate how careful scheduling of micro-operations is essential for implementing compound logic .",
            "id": "3659246",
            "problem": "A synchronous data path comprises a two-read one-write register file and a bitwise Arithmetic Logic Unit (ALU). The register file holds $w$-bit words in registers $R_0, R_1, \\dots$, and provides two independent read ports and one write port per cycle. In each clock cycle, at most one $w$-bit ALU operation is applied to its two inputs. All micro-operations follow standard Register Transfer Level (RTL) semantics: reads observe the pre-state of the cycle; writes commit at the active clock edge and become visible only in the subsequent cycle. The ALU supports the binary operations bitwise exclusive-or and bitwise conjunction, denoted $\\oplus$ and $\\land$, respectively. One operand of the ALU (the $B$ input) may be complemented prior to the operation under control of a single-bit signal, effecting $\\neg(\\cdot)$ on that operand. The ALU output may be latched into a single $w$-bit temporary output register $Z$ at the clock edge and, in a subsequent cycle, $Z$ may be selected as one of the ALU inputs via input multiplexers. No other temporary storage beyond $Z$ is available. Control signals are:\n- $\\text{RA}$ and $\\text{RB}$: register file read addresses for the two read ports,\n- $\\text{WD}$: register file write address,\n- $\\text{WE}$: register file write enable,\n- $\\text{ALU\\_OP} \\in \\{\\text{XOR}, \\text{AND}\\}$: ALU operation selector,\n- $\\text{INV}_B \\in \\{0,1\\}$: complement-enable for the ALU $B$ input,\n- $\\text{A\\_SEL} \\in \\{\\text{RF\\_A}, Z\\}$ and $\\text{B\\_SEL} \\in \\{\\text{RF\\_B}, Z\\}$: ALU input source selectors,\n- $Z\\_\\text{EN}$: latch enable for $Z$.\n\nDesign a correct micro-operation sequence to compute the expression\n$$\nR_d \\leftarrow \\bigl(R_a \\oplus R_b\\bigr) \\land \\neg R_c\n$$\nfor arbitrary register indices $a$, $b$, $c$, and $d$ (not necessarily distinct), using the minimal temporary storage permitted by the data path described above. Itemize, for each cycle, the values of the control signals $\\text{RA}$, $\\text{RB}$, $\\text{WD}$, $\\text{WE}$, $\\text{ALU\\_OP}$, $\\text{INV}_B$, $\\text{A\\_SEL}$, $\\text{B\\_SEL}$, and $Z\\_\\text{EN}$. Justify the minimality of your schedule in terms of the fundamental constraints of the register-transfer semantics and the ALU’s functional capabilities.\n\nExpress the final answer as the minimal number of clock cycles required to complete the computation. No rounding is necessary. Report only this number as your final answer.",
            "solution": "We begin from the core definitions of Register Transfer Level (RTL) micro-operations in a synchronous system. In one clock cycle:\n- The register file can present two source operands via its read ports addressed by $\\text{RA}$ and $\\text{RB}$.\n- The ALU can carry out at most one operation, selected by $\\text{ALU\\_OP}$, on its two inputs.\n- The $B$ input can optionally be complemented under $\\text{INV}_B$ before the operation.\n- The register file can write one destination register at $\\text{WD}$ if $\\text{WE}=1$, which commits at the clock edge and is visible in the next cycle.\n- The ALU output may be captured into the temporary output register $Z$ if $Z\\_\\text{EN}=1$, and $Z$ can be selected as an ALU input in later cycles via $\\text{A\\_SEL}$ or $\\text{B\\_SEL}$.\n\nThe target computation is\n$$\nR_d \\leftarrow \\bigl(R_a \\oplus R_b\\bigr) \\land \\neg R_c.\n$$\nThis expression involves two distinct bitwise operations ($\\oplus$ and $\\land$) applied to three operands ($R_a$, $R_b$, $R_c$), with a dependency: the result of $R_a \\oplus R_b$ must be available as one input to the conjunction with $\\neg R_c$. Under the stated constraints, the ALU is binary and performs exactly one operation per cycle. Therefore, any correct schedule must allocate at least two cycles: one cycle to produce $\\bigl(R_a \\oplus R_b\\bigr)$ and another cycle to conjoin that intermediate with $\\neg R_c$. It is impossible to complete the computation in a single cycle because:\n- The ALU has only two inputs, so it cannot directly combine three independent operands $R_a$, $R_b$, and $R_c$ simultaneously.\n- The ALU can perform only one operation per cycle, precluding computing $\\oplus$ and $\\land$ in parallel within a single cycle.\n\nHence, a lower bound of $2$ cycles is established by the functional constraints.\n\nNext, we construct a schedule that achieves this lower bound while using minimal temporary storage. If we were to write the intermediate $\\bigl(R_a \\oplus R_b\\bigr)$ into any register in the register file before using $R_c$, we could hazardously clobber $R_c$ when $d=c$ (since the destination equals a source). To avoid any dependency on register aliasing among $a$, $b$, $c$, and $d$, we use the single available temporary output register $Z$ to hold the intermediate result across cycles, and defer any register file write until the final cycle. This uses only the permitted minimal temporary storage ($Z$).\n\nA correct two-cycle schedule is:\n\n- Cycle $1$ (compute the intermediate $\\bigl(R_a \\oplus R_b\\bigr)$ and latch it in $Z$):\n  - $\\text{RA} = a$\n  - $\\text{RB} = b$\n  - $\\text{A\\_SEL} = \\text{RF\\_A}$ (ALU $A$ input sourced from the register file read port addressed by $\\text{RA}$)\n  - $\\text{B\\_SEL} = \\text{RF\\_B}$ (ALU $B$ input sourced from the register file read port addressed by $\\text{RB}$)\n  - $\\text{ALU\\_OP} = \\text{XOR}$\n  - $\\text{INV}_B = 0$ (no complement on $R_b$ for XOR)\n  - $Z\\_\\text{EN} = 1$ (capture the ALU output into $Z$)\n  - $\\text{WE} = 0$ (do not write the register file in this cycle)\n  - $\\text{WD}$ is do not care (do not care (DNC))\n\n  At the end of this cycle, $Z$ holds $Z \\leftarrow R_a \\oplus R_b$.\n\n- Cycle $2$ (compute $\\bigl(R_a \\oplus R_b\\bigr) \\land \\neg R_c$ and write it to $R_d$):\n  - $\\text{RA}$ is DNC (ALU $A$ input will not be taken from the register file in this cycle)\n  - $\\text{RB} = c$\n  - $\\text{A\\_SEL} = Z$ (ALU $A$ input sourced from $Z$, which holds $R_a \\oplus R_b$)\n  - $\\text{B\\_SEL} = \\text{RF\\_B}$ (ALU $B$ input sourced from the register file read port addressed by $\\text{RB}$)\n  - $\\text{ALU\\_OP} = \\text{AND}$\n  - $\\text{INV}_B = 1$ (complement the $B$ input so the ALU forms $Z \\land \\neg R_c$)\n  - $Z\\_\\text{EN} = 0$ (no need to latch the result in $Z$ if we are writing it to the register file)\n  - $\\text{WE} = 1$ (enable register file write)\n  - $\\text{WD} = d$ (write the ALU output to $R_d$)\n\n  At the end of this cycle, $R_d \\leftarrow Z \\land \\neg R_c = \\bigl(R_a \\oplus R_b\\bigr) \\land \\neg R_c$.\n\nCorrectness follows from functional composition: cycle $1$ computes the exact intermediate needed for cycle $2$, and cycle $2$ applies the bitwise conjunction with the complemented $R_c$. The schedule is robust to any aliasing among $a$, $b$, $c$, and $d$ because the register file is not written in cycle $1$, so no source operand is clobbered prior to its use, even when $d=c$.\n\nMinimality argument: We have shown that one cycle is insufficient due to the ALU’s binary input and single-operation constraint. The above schedule completes in $2$ cycles, meeting the lower bound. Therefore, the minimal number of cycles required is $2$.\n\nThus, the minimal temporary storage used is the single $w$-bit $Z$ register, and the minimal cycle count is $2$.",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "Our final practice synthesizes these concepts to implement a complete, realistic processor instruction: an indexed memory load, $R_d \\leftarrow M[R_s + \\text{disp}]$. This task requires you to orchestrate a sequence of micro-operations involving address calculation, memory interaction, and register write-back, which are the building blocks of modern computing. This exercise will solidify your understanding of how high-level instructions are translated into a precise, multi-step hardware-level process .",
            "id": "3659239",
            "problem": "A microprogrammed central processing unit implements a new indexed addressing mode defined by the architectural specification as follows: given a source register $R_{s}$, a destination register $R_{d}$, and a signed displacement field $\\mathrm{disp}$ embedded in the current instruction, the instruction semantics are $R_{d} \\leftarrow M[R_{s} + \\mathrm{disp}]$, where $M[\\cdot]$ denotes memory at the effective address. The datapath contains a general-purpose register file, an Arithmetic Logic Unit (ALU), a Memory Address Register (MAR), a Memory Data Register (MDR), and an Instruction Register (IR) holding the current instruction. The displacement $\\mathrm{disp}$ is taken from a fixed field of $IR$ and is sign-extended before use. The memory interface reads into $MDR$ when a memory-read control signal is asserted, with the effective address provided by $MAR$. The ALU has two input multiplexers that can be driven in the same microcycle from arbitrary sources among register file read ports, immediate constants such as the sign-extended displacement, and internal registers. Assume that the ALU can compute $+$ in one microcycle and that memory read completes within one microcycle when requested. The control unit is horizontal microcoded: each microinstruction directly drives $k$ boolean control lines that respectively gate sources onto internal buses or ALU inputs, select ALU functions, and assert register-load and memory-control signals. The micro-sequencer uses a next-address field contained in the microinstruction to select the next microinstruction address, and it supports two sequencing modes: fall-through to the next sequential microaddress or an unconditional jump to an explicit target address encoded in the microinstruction. The control store contains $M$ microinstructions in total. You may assume that the fetch and decode phases that load $IR$ have already completed, and your focus is only on the execution of the indexed addressing mode.\n\nTasks:\n- Outline a minimal sequence of micro-operations that implements the execution of this indexed addressing mode, and for each micro-operation, name the essential control signal assertions that must be driven by the microinstruction to realize it, using conventional names like $MAR\\_{\\mathrm{load}}$, $MDR\\_{\\mathrm{load}}$, $MemRead$, register file read/write enables and selects, ALU function selects, and multiplexer selects. It is acceptable to combine actions that the datapath can perform concurrently within one microcycle when justified by the given datapath assumptions.\n- Based on the given micro-sequencer model, derive an analytic expression for the minimal width $W$ (in bits) of one microinstruction in the control store as a function of $k$ and $M$, making explicit the contribution of the direct control lines and the next-address control needed to support either fall-through or an unconditional jump. Express your final answer as a single closed-form expression in terms of $k$ and $M$. No numerical value is required.",
            "solution": "The problem is evaluated as valid, as it is scientifically grounded in the principles of computer architecture, well-posed, objective, and internally consistent. It presents a standard, solvable problem in the design of a microprogrammed control unit.\n\nThe problem consists of two tasks: first, to define the sequence of micro-operations and associated control signals to execute a specific indexed addressing mode instruction, and second, to derive an expression for the width of a microinstruction.\n\n**Task 1: Micro-operations and Control Signals**\n\nThe instruction to be implemented is $R_{d} \\leftarrow M[R_{s} + \\mathrm{disp}]$. This operation can be decomposed into three fundamental, sequential steps:\n$1$. Calculate the effective memory address by adding the contents of the source register $R_{s}$ and the sign-extended displacement $\\mathrm{disp}$.\n$2$. Use this effective address to read a value from memory.\n$3$. Write the value read from memory into the destination register $R_{d}$.\n\nBased on the datapath capabilities described, where the ALU and memory access each complete within a single microcycle, a minimal sequence of three micro-operations is required. These steps are data-dependent and cannot be further compressed.\n\n**Microcycle 1: Effective Address Calculation**\nThe first micro-operation calculates the effective address and loads it into the Memory Address Register ($MAR$). The datapath is specified to allow the ALU to take one operand from the register file ($R_s$) and another from the instruction register's sign-extended displacement field ($\\mathrm{disp}$) within the same cycle.\n\n-   **Micro-operation:** $MAR \\leftarrow R_{s} + \\mathrm{disp}$\n-   **Essential Control Signals:**\n    -   Register File Control: Signals to read the contents of register $R_{s}$. An example signal is `RegReadEnable`. The address of $R_s$, sourced from the $IR$, must be supplied to the register file's read address port.\n    -   ALU Input Multiplexer Selects: Signals to route the output of the register file to one ALU input port and the sign-extended displacement from the $IR$ to the other ALU input port.\n    -   ALU Function Select: A signal to configure the ALU to perform addition, e.g., `ALU_OP = ADD`.\n    -   MAR Load Enable: A signal to load the output of the ALU into the $MAR$, e.g., `MAR_{load}`.\n\n**Microcycle 2: Memory Read**\nWith the effective address in the $MAR$, the memory read operation can be initiated. The problem states this completes in one microcycle, with the data being available in the Memory Data Register ($MDR$) at the end of the cycle.\n\n-   **Micro-operation:** $MDR \\leftarrow M[MAR]$\n-   **Essential Control Signals:**\n    -   Memory Read Control: A signal to command the memory system to perform a read operation using the address in the $MAR$, e.g., `MemRead`.\n    -   MDR Load Enable: A signal to latch the data from the memory data bus into the $MDR$, e.g., `MDR_{load}`. This signal is asserted for the duration of the cycle in which the memory read completes.\n\n**Microcycle 3: Register Write-back**\nThe final step is to transfer the data from the $MDR$ to the destination register $R_{d}$ in the register file.\n\n-   **Micro-operation:** $R_{d} \\leftarrow MDR$\n-   **Essential Control Signals:**\n    -   Register File Write Enable: A signal to enable the write operation on the register file, e.g., `RegWriteEnable`.\n    -   Register File Write Address Select: The address of the destination register $R_{d}$, sourced from the $IR$, must be supplied to the register file's write address port.\n    -   Write-back Multiplexer Select: A signal to select the $MDR$ as the data source to be written into the register file.\n\nThis three-cycle sequence is minimal because of the inherent data dependencies: the memory read cannot begin until the address calculation is complete, and the register write-back cannot begin until the data has been retrieved from memory.\n\n**Task 2: Microinstruction Width Derivation**\n\nThe width, $W$, of a single microinstruction is the sum of the widths of its constituent fields. The problem describes a horizontal microcode format with two main parts: a field for direct control signals and a field for micro-sequencing.\n\n$1$. **Control Signal Field:** The problem states that the microinstruction \"directly drives $k$ boolean control lines.\" This is characteristic of a horizontal format where each bit corresponds to a specific control signal (e.g., $MAR_{load}$, $MemRead$). Therefore, the width of this field is exactly $k$ bits.\n\n$2$. **Sequencing Field:** The micro-sequencer supports two modes: fall-through (execution proceeds to the next microinstruction at address $\\mu PC+1$) and unconditional jump (execution proceeds to a new address specified in the current microinstruction). To implement this, the sequencing field must contain two pieces of information:\n    -   **Mode Selection:** A bit is needed to distinguish between the two modes. A single bit is the minimum required to encode two distinct choices. For example, $0$ could signify fall-through and $1$ could signify an unconditional jump. This requires $1$ bit.\n    -   **Next Address:** For the unconditional jump mode, an explicit target address must be provided. The control store contains $M$ microinstructions in total. To uniquely address any one of these $M$ locations (from addresses $0$ to $M-1$), a minimum of $\\lceil \\log_{2}(M) \\rceil$ bits are required. This field holds the target address for a jump.\n\nThe total width of the sequencing field is the sum of the bits for mode selection and the next address field, which is $1 + \\lceil \\log_{2}(M) \\rceil$.\n\n**Total Microinstruction Width (W):**\nThe total width $W$ is the sum of the widths of the control signal field and the sequencing field.\n$$W = (\\text{Width of control field}) + (\\text{Width of sequencing field})$$\n$$W = k + \\left(1 + \\lceil \\log_{2}(M) \\rceil\\right)$$\nThus, the minimal width of one microinstruction is given by the expression $W = k + 1 + \\lceil \\log_{2}(M) \\rceil$.",
            "answer": "$$\\boxed{k + \\lceil \\log_{2}(M) \\rceil + 1}$$"
        }
    ]
}