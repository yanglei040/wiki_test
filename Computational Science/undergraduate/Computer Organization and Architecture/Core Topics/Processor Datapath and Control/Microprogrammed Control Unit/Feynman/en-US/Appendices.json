{
    "hands_on_practices": [
        {
            "introduction": "Microprogrammed control operates by executing sequences of micro-instructions, and a fundamental task is implementing control flow constructs like loops. This exercise explores the mechanics of a common loop control micro-instruction, connecting a hardware resource (a $c$-bit counter) to its functional capability (maximum loop iterations) and performance cost (average overhead from branch penalties). By analyzing this primitive, you gain a concrete understanding of how low-level control and timing affect the execution of high-level programming structures. ",
            "id": "3659426",
            "problem": "A microprogrammed control unit (MCU) implements a single-cycle loop primitive called decrement-and-branch-if-not-zero, denoted as DBNZ. The MCU has a dedicated loop counter register of width $c$ bits that stores an unsigned integer. The DBNZ microinstruction has the following semantics when executed at the bottom of a loop: it decrements the loop counter by $1$, writes the result back to the same $c$-bit register, and transfers control to a specified target microaddress if and only if the post-decrement value is not equal to $0$; otherwise, control falls through to the next sequential microaddress. The MCU executes one microinstruction per microcycle in the steady state (one microcycle per microinstruction). A taken microbranch, where the next microaddress is not the sequential successor, incurs a fixed branch penalty of $p$ extra microcycles due to control-store pipeline refill. A fall-through (sequential successor) incurs no branch penalty. Assume $p \\ge 0$ is an integer, and that the DBNZ microinstruction itself always occupies exactly $1$ microcycle. The loop body consists of a sequence of microinstructions that do not affect the loop counter and does not contain any branches other than the loop back-edge controlled by DBNZ.\n\nThe loop counter is initialized by microcode to some nonzero value $N$ and then the loop executes until DBNZ falls through. Use only fundamental definitions about $c$-bit unsigned representation and the stated execution semantics to derive the following quantities:\n\n1) The maximum number of loop iterations supported by the loop primitive as a function of $c$.\n\n2) The average loop-control overhead per iteration, measured in microcycles and defined as the total microcycles spent on the DBNZ microinstruction and any associated branch penalties over the entire loop execution, divided by the total number of iterations, in the specific case where the loop counter is initialized to its maximal representable nonzero value.\n\nExpress your final answer as two closed-form expressions in terms of $c$ and $p$, with no units. Do not provide intermediate steps in the final answer. No numerical rounding is required.",
            "solution": "The problem statement is subjected to validation before proceeding to a solution.\n\n### Step 1: Extract Givens\n- A microprogrammed control unit (MCU) has a decrement-and-branch-if-not-zero (DBNZ) microinstruction.\n- There is a dedicated loop counter register of width $c$ bits storing an unsigned integer.\n- DBNZ semantics:\n    1. Decrement loop counter by $1$.\n    2. Write result back to the register.\n    3. If post-decrement value is not $0$, transfer control to a target microaddress (taken branch).\n    4. If post-decrement value is $0$, control falls through to the next sequential microaddress.\n- One microinstruction executes in one microcycle.\n- A taken microbranch incurs a penalty of $p$ extra microcycles.\n- A fall-through incurs no branch penalty ($0$ extra microcycles).\n- The DBNZ microinstruction itself takes $1$ microcycle.\n- $p$ is an integer, $p \\ge 0$.\n- The loop counter is initialized to a nonzero value $N$.\n- The loop executes until DBNZ falls through.\n- The loop body contains no other branches.\n- Required quantities:\n    1. Maximum number of loop iterations as a function of $c$.\n    2. Average loop-control overhead per iteration (defined as total microcycles for DBNZ and penalties divided by total iterations) when the counter is initialized to its maximal representable nonzero value, as a function of $c$ and $p$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is evaluated against the validation criteria.\n\n- **Scientifically Grounded**: The problem is grounded in the fundamental principles of computer organization and architecture. The concepts of microprogrammed control, instruction semantics, loop counters, branch penalties, and unsigned integer arithmetic are standard and well-established in the field.\n- **Well-Posed**: The problem is well-posed. The givens are sufficient and consistent, and the required quantities are clearly defined, leading to a unique and meaningful solution derivable through logical deduction.\n- **Objective**: The problem is stated using precise, objective language common to the field of computer engineering. It is free of subjective or ambiguous claims.\n- **Other Flaws**: The problem does not exhibit any of the listed flaws such as being incomplete, contradictory, unrealistic, ill-structured, or trivial.\n\n### Step 3: Verdict and Action\nThe problem is deemed **valid**. A reasoned solution will be formulated.\n\n### Solution Derivation\n\nThis problem requires an analysis of a loop control mechanism within a microprogrammed control unit. We derive the two requested quantities based on the specified semantics of the DBNZ instruction and the properties of unsigned integer representation.\n\n**1) Maximum Number of Loop Iterations**\n\nThe loop counter is a $c$-bit unsigned integer register. The range of values such a register can store is from $0$ to $2^c - 1$. The total number of representable values is $2^c$.\n\nThe DBNZ instruction's behavior is key. A loop controlled by DBNZ will execute as long as the branch condition (post-decrement value is not equal to $0$) is met. The loop terminates when the condition is false, i.e., when the post-decrement value is $0$. This occurs when the value in the counter is $1$ just before the DBNZ instruction is executed. The decrement operation changes the value to $0$, causing a fall-through.\n\nLet the loop counter be initialized to a nonzero value $N$. The loop will proceed as follows:\n- **Iteration 1**: The loop body executes. At the end, DBNZ is executed. The counter value was $N$, is decremented to $N-1$. If $N > 1$, then $N-1 \\neq 0$, and the branch is taken.\n- **Iteration 2**: The loop body executes. At the end, DBNZ is executed. The counter value was $N-1$, is decremented to $N-2$. If $N > 2$, then $N-2 \\neq 0$, and the branch is taken.\n- ...\n- **Iteration $N-1$**: The loop body executes. At the end, DBNZ is executed. The counter value was $2$, is decremented to $1$. Since $1 \\neq 0$, the branch is taken.\n- **Iteration $N$**: The loop body executes. At the end, DBNZ is executed. The counter value was $1$, is decremented to $0$. Since the post-decrement value is $0$, the branch is not taken (fall-through), and the loop terminates.\n\nFrom this sequence, it is clear that if the loop counter is initialized to a value $N$, the loop body is executed exactly $N$ times. The number of iterations is therefore equal to the initial value $N$ of the counter.\n\nTo find the maximum number of loop iterations, we must find the maximum valid initial value for the counter. The problem states the counter is initialized to a *nonzero* value. The maximum value that can be stored in a $c$-bit unsigned register is $2^c - 1$. This value is nonzero for any $c \\ge 1$. Therefore, the maximum number of loop iterations corresponds to setting the initial counter value $N$ to its maximum, $N_{max}$.\n\nMaximum number of iterations = $N_{max} = 2^c - 1$.\n\n**2) Average Loop-Control Overhead Per Iteration**\n\nThis part of the problem concerns the specific case where the loop counter is initialized to its maximal representable nonzero value, which we found to be $N = 2^c - 1$. The total number of iterations is thus $N = 2^c - 1$.\n\nThe loop-control overhead is defined as the total microcycles spent on the DBNZ microinstruction and any associated branch penalties. The average overhead per iteration is this total cost divided by the total number of iterations.\n\nThe DBNZ instruction is executed once per iteration, for a total of $N$ executions. We must sum the costs of these $N$ executions.\n- The base cost of one DBNZ microinstruction is $1$ microcycle.\n- A taken branch adds a penalty of $p$ microcycles, for a total cost of $1+p$ for that execution.\n- A fall-through adds no penalty, for a total cost of $1+0=1$ for that execution.\n\nAs established in the analysis for part 1, a loop running for $N$ iterations involves $N-1$ taken branches and $1$ final fall-through.\n- Number of taken branches = $N - 1$.\n- Number of fall-throughs = $1$.\n\nThe total microcycle cost for loop control, $C_{total}$, is the sum of the costs of all DBNZ executions:\n$$C_{total} = (\\text{Number of taken branches} \\times \\text{Cost per taken branch}) + (\\text{Number of fall-throughs} \\times \\text{Cost per fall-through})$$\n$$C_{total} = (N - 1)(1 + p) + (1)(1)$$\n\nThe average loop-control overhead per iteration, $O_{avg}$, is this total cost divided by the total number of iterations, $N$.\n$$O_{avg} = \\frac{C_{total}}{N} = \\frac{(N - 1)(1 + p) + 1}{N}$$\n\nWe can simplify this expression:\n$$O_{avg} = \\frac{N(1+p) - (1+p) + 1}{N} = \\frac{N(1+p) - p}{N} = 1 + p - \\frac{p}{N}$$\n\nNow, we substitute the specific value of $N$ for this case, which is $N = 2^c - 1$.\n$$O_{avg} = 1 + p - \\frac{p}{2^c - 1}$$\n\nThis is the final closed-form expression for the average overhead per iteration in terms of $c$ and $p$.\n\nThe final answer requires both expressions.\n1. Maximum number of iterations: $2^c - 1$.\n2. Average loop-control overhead per iteration: $1 + p - \\frac{p}{2^c - 1}$.",
            "answer": "$$ \\boxed{ \\begin{pmatrix} 2^c - 1 & 1 + p - \\frac{p}{2^c - 1} \\end{pmatrix} } $$"
        },
        {
            "introduction": "After understanding individual micro-instructions, the next logical step is to design the memory that stores them: the control store. This exercise challenges you to translate the control requirements of a hypothetical Instruction Set Architecture (ISA) into a physical hardware structure. You will determine the control store's dimensions—its width based on the number of datapath control signals and its depth from the total micro-instructions needed to implement the entire ISA—providing a tangible sense of the trade-offs in control unit design. ",
            "id": "3660292",
            "problem": "You are asked to design a microprogrammed control store for a multi-cycle processor datapath implementing a $32$-instruction Instruction Set Architecture (ISA). The microcode encoding must ensure one-hot control for all multiplexer selections and explicit single-bit strobes for loads and writes. Use the following scientifically grounded base assumptions about microprogrammed control and multi-cycle datapaths: a microinstruction is a fixed-width word whose bits directly gate control signals; one-hot encoding for a $k$-way selector uses $k$ distinct control lines such that exactly one is asserted to choose a source; and the control store depth equals the number of distinct microinstructions required to implement the instruction sequences under the chosen microcode organization.\n\nThe datapath has these control points, each of which must be represented in the microinstruction under a one-hot or strobe convention as specified:\n\n- Memory address source selector $\\mathrm{IorD}$: $2$ options $\\{ \\mathrm{PC}, \\mathrm{ALUOut} \\}$, encoded one-hot with $2$ lines.\n- Arithmetic Logic Unit (ALU) input A selector $\\mathrm{ALUSrcA}$: $2$ options $\\{ \\mathrm{PC}, \\mathrm{A} \\}$, encoded one-hot with $2$ lines.\n- Arithmetic Logic Unit (ALU) input B selector $\\mathrm{ALUSrcB}$: $4$ options $\\{ \\mathrm{B}, \\mathrm{const}\\ 4, \\mathrm{Imm}, \\mathrm{Imm}\\ll 2 \\}$, encoded one-hot with $4$ lines.\n- Program Counter source selector $\\mathrm{PCSource}$: $3$ options $\\{ \\mathrm{ALUResult}, \\mathrm{ALUOut}, \\mathrm{JumpAddr} \\}$, encoded one-hot with $3$ lines.\n- Register destination selector $\\mathrm{RegDst}$: $3$ options $\\{ rt, rd, r_{31} \\}$, encoded one-hot with $3$ lines.\n- Register write-back data selector $\\mathrm{MemtoReg}$: $3$ options $\\{ \\mathrm{ALUResult}, \\mathrm{MDR}, \\mathrm{PC}+4 \\}$, encoded one-hot with $3$ lines.\n- ALU operation control $\\mathrm{ALUOp}$: $8$ one-hot lines for the implemented ALU functions.\n- Immediate extension selector $\\mathrm{ExtOp}$: $2$ options $\\{ \\mathrm{sign\\ extend}, \\mathrm{zero\\ extend} \\}$, encoded one-hot with $2$ lines.\n- Single-bit strobes: $\\mathrm{IRWrite}$, $\\mathrm{PCWrite}$, $\\mathrm{PCWriteCond}$, $\\mathrm{MemRead}$, $\\mathrm{MemWrite}$, $\\mathrm{RegWrite}$, $\\mathrm{MDRWrite}$, $\\mathrm{AWrite}$, $\\mathrm{BWrite}$, $\\mathrm{ALUOutWrite}$, each a single control bit, totaling $10$ bits.\n\nAssume a simple microprogram organization in which each instruction has its own microsequence that includes its fetch and decode steps (no subroutine sharing or compression). The ISA is partitioned into classes with the following counts and cycle requirements per instruction:\n\n- $10$ register-type ALU instructions: $4$ cycles each.\n- $6$ immediate-type ALU instructions: $3$ cycles each.\n- $5$ load instructions: $5$ cycles each.\n- $3$ store instructions: $4$ cycles each.\n- $4$ conditional branch instructions: $3$ cycles each.\n- $3$ jump instructions (no link): $2$ cycles each.\n- $1$ jump-and-link instruction: $3$ cycles.\n\nTasks:\n\n1. Propose a concrete microinstruction format consistent with the above control points and one-hot requirements by listing the fields and their bit widths.\n2. Using first principles of microprogrammed control, determine the control store width (in bits) and the control store depth (in microinstructions).\n3. Compute the total number of bits stored in the control store as the product of the width and the depth.\n\nExpress the final total control store size as a single number of bits. No rounding is required. The final answer must be a single real-valued number. State any symbols inside $...$ and ensure every number appears in LaTeX. Do not include units inside the boxed final answer; however, interpret the value as bits.",
            "solution": "The problem statement is subjected to validation before a solution is attempted.\n\n### Step 1: Extract Givens\n-   Instruction Set Architecture (ISA) size: $32$ instructions.\n-   Control signal encoding: one-hot for all multiplexer selections, single-bit strobes for loads and writes.\n-   Microprogram organization: Each instruction has its own microsequence, including fetch and decode. No subroutine sharing or compression.\n-   Control store depth is the total number of distinct microinstructions.\n-   Control Points and Encoding:\n    -   $\\mathrm{IorD}$ (Memory address selector): $2$ options, one-hot ($2$ bits).\n    -   $\\mathrm{ALUSrcA}$ (ALU input A selector): $2$ options, one-hot ($2$ bits).\n    -   $\\mathrm{ALUSrcB}$ (ALU input B selector): $4$ options, one-hot ($4$ bits).\n    -   $\\mathrm{PCSource}$ (PC source selector): $3$ options, one-hot ($3$ bits).\n    -   $\\mathrm{RegDst}$ (Register destination selector): $3$ options, one-hot ($3$ bits).\n    -   $\\mathrm{MemtoReg}$ (Register write-back data selector): $3$ options, one-hot ($3$ bits).\n    -   $\\mathrm{ALUOp}$ (ALU operation control): $8$ one-hot lines ($8$ bits).\n    -   $\\mathrm{ExtOp}$ (Immediate extension selector): $2$ options, one-hot ($2$ bits).\n    -   Strobes: $\\mathrm{IRWrite}$, $\\mathrm{PCWrite}$, $\\mathrm{PCWriteCond}$, $\\mathrm{MemRead}$, $\\mathrm{MemWrite}$, $\\mathrm{RegWrite}$, $\\mathrm{MDRWrite}$, $\\mathrm{AWrite}$, $\\mathrm{BWrite}$, $\\mathrm{ALUOutWrite}$. A total of $10$ single-bit strobes ($10$ bits).\n-   ISA Partition and Cycle Counts:\n    -   $10$ register-type ALU instructions at $4$ cycles each.\n    -   $6$ immediate-type ALU instructions at $3$ cycles each.\n    -   $5$ load instructions at $5$ cycles each.\n    -   $3$ store instructions at $4$ cycles each.\n    -   $4$ conditional branch instructions at $3$ cycles each.\n    -   $3$ jump instructions at $2$ cycles each.\n    -   $1$ jump-and-link instruction at $3$ cycles.\n-   The sum of instructions is $10 + 6 + 5 + 3 + 4 + 3 + 1 = 32$, which is consistent with the stated ISA size.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is evaluated against the validation criteria.\n-   **Scientifically Grounded**: The problem is a standard exercise in computer organization and architecture, dealing with the design of a microprogrammed control unit for a multi-cycle datapath. All concepts, such as one-hot encoding, control stores, and multi-cycle execution, are fundamental to the field. The setup is scientifically and technically sound.\n-   **Well-Posed**: The problem provides a complete and consistent set of specifications to uniquely determine the width, depth, and total size of the control store. The tasks are clearly defined, and a unique solution can be derived from the givens.\n-   **Objective**: The problem is stated in precise, technical language, free of subjectivity or ambiguity. The encoding schemes and datapath components are explicitly defined.\n-   **Completeness**: All necessary information is provided. The number of options for each multiplexer, the encoding scheme, the list of all control signals, and the instruction breakdown with cycle counts are all explicitly given. The problem does not require any external information or unstated assumptions, apart from the ones explicitly provided as the basis for the design. The assumption of \"no sharing\" of microcode sequences, while a simplification, is clearly stated and makes the problem tractable.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. It is a well-defined, self-contained, and scientifically sound problem in computer architecture. The solution process can proceed.\n\n### Solution Derivation\n\nThe solution is derived by addressing the three tasks in order: calculating the microinstruction width, the control store depth, and finally, their product.\n\n**Task 1 & 2: Control Store Width and Depth**\n\nFirst, the width of the control store, which is equivalent to the width of a single microinstruction, is determined. The problem specifies that the microinstruction word's bits directly gate the datapath control signals. The total width is the sum of bits required for each control field.\n\n-   $\\mathrm{IorD}$ (2-way MUX, one-hot): $2$ bits\n-   $\\mathrm{ALUSrcA}$ (2-way MUX, one-hot): $2$ bits\n-   $\\mathrm{ALUSrcB}$ (4-way MUX, one-hot): $4$ bits\n-   $\\mathrm{PCSource}$ (3-way MUX, one-hot): $3$ bits\n-   $\\mathrm{RegDst}$ (3-way MUX, one-hot): $3$ bits\n-   $\\mathrm{MemtoReg}$ (3-way MUX, one-hot): $3$ bits\n-   $\\mathrm{ALUOp}$ (8 functions, one-hot): $8$ bits\n-   $\\mathrm{ExtOp}$ (2-way MUX, one-hot): $2$ bits\n-   Strobes ($10$ individual signals): $10 \\times 1 = 10$ bits\n\nThe total width, $W$, of a microinstruction is the sum of these bit-widths:\n$$W = 2 + 2 + 4 + 3 + 3 + 3 + 8 + 2 + 10 = 37 \\text{ bits}$$\n\nNext, the depth of the control store is determined. The depth is the total number of unique microinstructions. The problem specifies a \"simple microprogram organization in which each instruction has its own microsequence that includes its fetch and decode steps (no subroutine sharing or compression).\" This means the total number of states (microinstructions) is the sum of the cycle counts for every instruction in the ISA.\n\n-   Register-type ALU instructions: $10 \\text{ instructions} \\times 4 \\text{ cycles/instruction} = 40$ microinstructions.\n-   Immediate-type ALU instructions: $6 \\text{ instructions} \\times 3 \\text{ cycles/instruction} = 18$ microinstructions.\n-   Load instructions: $5 \\text{ instructions} \\times 5 \\text{ cycles/instruction} = 25$ microinstructions.\n-   Store instructions: $3 \\text{ instructions} \\times 4 \\text{ cycles/instruction} = 12$ microinstructions.\n-   Conditional branch instructions: $4 \\text{ instructions} \\times 3 \\text{ cycles/instruction} = 12$ microinstructions.\n-   Jump instructions: $3 \\text{ instructions} \\times 2 \\text{ cycles/instruction} = 6$ microinstructions.\n-   Jump-and-link instruction: $1 \\text{ instruction} \\times 3 \\text{ cycles/instruction} = 3$ microinstructions.\n\nThe total depth, $D$, of the control store is the sum of these microinstruction counts:\n$$D = 40 + 18 + 25 + 12 + 12 + 6 + 3 = 116 \\text{ microinstructions}$$\n\n**Task 3: Total Control Store Size**\n\nThe total number of bits in the control store is the product of its width ($W$) and depth ($D$).\n\n$$ \\text{Total Size} = W \\times D $$\n$$ \\text{Total Size} = 37 \\text{ bits} \\times 116 $$\n$$ \\text{Total Size} = 4292 \\text{ bits} $$\n\nThus, the control store requires a total of $4292$ bits.\nThe microinstruction format consists of fields for `IorD` ($2$ bits), `ALUSrcA` ($2$ bits), `ALUSrcB` ($4$ bits), `PCSource` ($3$ bits), `RegDst` ($3$ bits), `MemtoReg` ($3$ bits), `ALUOp` ($8$ bits), `ExtOp` ($2$ bits), and $10$ strobe bits, totaling a width of $37$ bits. The control store depth is $116$ microinstructions. The total size is the product of these two values.",
            "answer": "$$ \\boxed{4292} $$"
        },
        {
            "introduction": "A key advantage of microprogrammed control over hardwired logic is its flexibility, allowing processor behavior to be modified without changing the underlying hardware. This problem puts you in the role of a microcode engineer tasked with implementing a delayed branch, a feature not originally supported by the datapath design. By analyzing the performance impact of two different microcode-only strategies using Cycles Per Instruction (CPI), you will see firsthand how microprogramming enables processors to adapt and evolve. ",
            "id": "3659432",
            "problem": "A microprogrammed control unit governs a classical $5$-stage pipeline (Instruction Fetch, Instruction Decode, Execute, Memory, Write Back). In the current microcode (which implements branches without a delay slot), conditional branches are resolved in the Execute stage; when a branch is taken, the next two younger instructions residing in the Instruction Fetch and Instruction Decode stages are flushed, incurring a branch penalty of $2$ wasted cycles per taken branch. There is no branch prediction, and a not-taken branch incurs zero penalty. The base (hazard-free) Cycles Per Instruction (CPI) is $1$.\n\nA software requirement mandates support for a single delayed branch slot: the instruction immediately following a branch must always execute, regardless of whether the branch is taken or not. Hardware cannot be modified; only the microcode may be changed. You must choose a microcode workaround that preserves correctness and minimizes the expected CPI:\n\n- Strategy $\\mathrm{S1}$ (deferral): In the branch microcode, suppress the program counter redirection and pipeline flush for just long enough to allow the next sequential instruction to proceed and complete as the required delay slot. This requires asserting a microcoded interlock that adds $1$ extra cycle only when the branch is taken; there is no added cost when the branch is not taken.\n- Strategy $\\mathrm{S2}$ (replay): Retain the original taken-branch flush behavior and then microcode a slot-replay subroutine that re-injects and executes the flushed delay-slot instruction. This subroutine adds $3$ extra cycles only when the branch is taken; there is no added cost when the branch is not taken.\n\nAssume the following instruction mix and branch behavior are representative of the workload:\n- The dynamic fraction of branch instructions is $f_{b} = 0.18$.\n- The conditional branch taken probability is $p_{t} = 0.55$.\n\nUsing only fundamental definitions (e.g., the definition of Cycles Per Instruction (CPI) as average cycles per retired instruction and the notion that penalties add expected cycles weighted by their event probabilities), select the minimal-cost microcode workaround, derive the resulting new CPI, and then compute the net CPI change\n$$\\Delta \\mathrm{CPI} = \\mathrm{CPI}_{\\text{new}} - \\mathrm{CPI}_{\\text{old}}.$$\nRound your final numerical answer for $\\Delta \\mathrm{CPI}$ to four significant figures and express it as a pure number (unitless).",
            "solution": "The problem requires an analysis of pipeline performance, measured in Cycles Per Instruction (CPI), under three different microcode implementations for a $5$-stage pipeline: an original configuration and two proposed workarounds (S1 and S2) to support a delayed branch instruction. The goal is to select the superior workaround and quantify the resulting change in CPI.\n\nThe total CPI of a pipelined processor can be expressed as the sum of a base CPI (assuming no hazards or stalls) and the additional cycles per instruction contributed by various pipeline penalties. The general formula is:\n$$\n\\mathrm{CPI} = \\mathrm{CPI}_{\\text{base}} + \\sum_{i} (\\text{Penalty}_{i} \\times \\text{Frequency}_{i})\n$$\nwhere $\\text{Penalty}_{i}$ is the number of wasted cycles for event $i$, and $\\text{Frequency}_{i}$ is the probability of event $i$ occurring per instruction.\n\nThe givens for this problem are:\n- Base (hazard-free) CPI: $\\mathrm{CPI}_{\\text{base}} = 1$.\n- Dynamic fraction of branch instructions: $f_{b} = 0.18$.\n- Conditional branch taken probability: $p_{t} = 0.55$.\n\nFirst, we calculate the CPI for the original system, denoted as $\\mathrm{CPI}_{\\text{old}}$. In this system, there is no branch prediction, and conditional branches are resolved in the Execute stage. A taken branch incurs a penalty of $2$ cycles by flushing the instructions in the Instruction Fetch (IF) and Instruction Decode (ID) stages. A not-taken branch has a penalty of $0$ cycles.\n\nThe only source of penalty is a taken branch. The frequency of a taken branch per instruction is the product of the fraction of instructions that are branches and the probability that a branch is taken: $f_b \\times p_{t}$.\n$$\n\\mathrm{Frequency}_{\\text{taken branch}} = f_{b} \\times p_{t} = 0.18 \\times 0.55 = 0.099\n$$\nThe CPI for the original system is therefore:\n$$\n\\mathrm{CPI}_{\\text{old}} = \\mathrm{CPI}_{\\text{base}} + (\\text{Penalty for taken branch}) \\times (\\text{Frequency of taken branch})\n$$\n$$\n\\mathrm{CPI}_{\\text{old}} = 1 + 2 \\times (f_{b} p_{t}) = 1 + 2 \\times (0.099) = 1 + 0.198 = 1.198\n$$\n\nNext, we analyze the two proposed strategies for implementing a single delayed branch slot. The instruction in the delay slot (the one immediately following the branch) must always execute. We must select the strategy that minimizes the expected CPI.\n\nStrategy S1 (deferral): This strategy introduces a microcoded interlock that adds $1$ extra cycle only when the branch is taken. The penalty for a not-taken branch is $0$.\nThe CPI for Strategy S1 is:\n$$\n\\mathrm{CPI}_{\\text{S1}} = \\mathrm{CPI}_{\\text{base}} + (\\text{Penalty}_{\\text{S1, taken}}) \\times (f_{b} p_{t})\n$$\n$$\n\\mathrm{CPI}_{\\text{S1}} = 1 + 1 \\times (f_{b} p_{t}) = 1 + 1 \\times (0.099) = 1.099\n$$\n\nStrategy S2 (replay): This strategy retains the original flush but uses a subroutine to re-execute the flushed delay-slot instruction. This process adds $3$ extra cycles only when the branch is taken. The penalty for a not-taken branch is $0$.\nThe CPI for Strategy S2 is:\n$$\n\\mathrm{CPI}_{\\text{S2}} = \\mathrm{CPI}_{\\text{base}} + (\\text{Penalty}_{\\text{S2, taken}}) \\times (f_{b} p_{t})\n$$\n$$\n\\mathrm{CPI}_{\\text{S2}} = 1 + 3 \\times (f_{b} p_{t}) = 1 + 3 \\times (0.099) = 1 + 0.297 = 1.297\n$$\n\nTo select the minimal-cost microcode workaround, we compare the resulting CPI values:\n$$\n\\mathrm{CPI}_{\\text{S1}} = 1.099\n$$\n$$\n\\mathrm{CPI}_{\\text{S2}} = 1.297\n$$\nSince $1.099 < 1.297$, Strategy S1 yields a lower expected CPI. Therefore, S1 is the optimal choice. The new CPI for the system will be $\\mathrm{CPI}_{\\text{new}} = \\mathrm{CPI}_{\\text{S1}} = 1.099$.\n\nFinally, we compute the net CPI change, $\\Delta \\mathrm{CPI}$, which is defined as the difference between the new CPI and the old CPI.\n$$\n\\Delta \\mathrm{CPI} = \\mathrm{CPI}_{\\text{new}} - \\mathrm{CPI}_{\\text{old}}\n$$\nSubstituting the derived values:\n$$\n\\Delta \\mathrm{CPI} = \\mathrm{CPI}_{\\text{S1}} - \\mathrm{CPI}_{\\text{old}} = 1.099 - 1.198 = -0.099\n$$\nSymbolically, the change can be expressed as:\n$$\n\\Delta \\mathrm{CPI} = (1 + 1 \\cdot f_{b} p_{t}) - (1 + 2 \\cdot f_{b} p_{t}) = -f_{b} p_{t}\n$$\nThe problem requires the final numerical answer to be rounded to four significant figures. The calculated value is $-0.099$. To express this with four significant figures, we add two trailing zeros.\n$$\n\\Delta \\mathrm{CPI} = -0.09900\n$$",
            "answer": "$$\n\\boxed{-0.09900}\n$$"
        }
    ]
}