{
    "hands_on_practices": [
        {
            "introduction": "A processor's ability to execute multiple instructions per cycle is fundamentally limited by the bandwidth of its register file. The register file must provide enough parallel read and write \"ports\" to service the operand demands of concurrently issued instructions. This exercise challenges you to think like an architect by quantifying these port requirements based on instruction type and issue width. You will analyze the trade-off between hardware cost (port count) and scheduling flexibility, discovering how intelligent instruction scheduling can reduce hardware complexity without sacrificing performance .",
            "id": "3672090",
            "problem": "A processor has a centralized Register File (RF) with $P_r$ read ports and $P_w$ write ports. The RF is accessed in a single operand fetch stage per instruction: all source registers for an issued instruction are read concurrently in that stage, and results are written in a single writeback stage. Assume fixed-latency functional units so that any instruction that writes its destination register performs that writeback exactly $1$ cycle after it is issued. The core can be configured as either single-issue (issue width $1$) or dual-issue (issue width $2$).\n\nConsider an instruction set comprising two classes:\n- Arithmetic Logic Unit (ALU) register-register operations, denoted class $\\mathcal{A}$, each reading $2$ source registers and writing $1$ destination register.\n- Load operations, denoted class $\\mathcal{L}$, each reading $1$ base register and writing $1$ destination register (assume address formation uses a base register plus an immediate and that memory hits in the smallest cache, so writeback happens at fixed latency $1$).\n\nThe code fragment to be executed contains exactly $4$ instances of $\\mathcal{A}$ and exactly $4$ instances of $\\mathcal{L}$, with no data dependencies that would prohibit arbitrary reordering between classes (ignore control hazards; all branches are resolved and not present in this fragment). The processor may issue at most $2$ instructions per cycle in dual-issue mode and at most $1$ instruction per cycle in single-issue mode.\n\nUsing only the core definitions of RF ports and the per-instruction operand counts given above, and treating port demands as the maximum concurrent RF accesses per cycle required to guarantee progress without stalling:\n1. Derive the minimal RF port requirements $(P_r, P_w)$ for the single-issue core under worst-case per-cycle demands.\n2. Derive the minimal RF port requirements $(P_r, P_w)$ for the dual-issue core if the two issued instructions in a cycle are unconstrained in class (i.e., any pair from $\\{\\mathcal{A}, \\mathcal{L}\\}$ may be issued together).\n3. Propose a dual-issue scheduling policy for this fragment that reduces the needed RF ports by $1$ compared to the unconstrained dual-issue case while still issuing $2$ instructions per cycle, and compute the resulting minimal total number of RF ports $P_r + P_w$ under that policy.\n\nExpress the final answer as a single integer equal to the minimal $P_r + P_w$ under your proposed schedule. No rounding is required and no physical units apply.",
            "solution": "The problem asks for the minimal Register File (RF) port requirements for a processor under different issue-width configurations and scheduling policies. The port requirements are defined by the maximum number of concurrent RF accesses needed in any single cycle to guarantee execution without stalls. The analysis is divided into three parts.\n\nLet $R(\\mathcal{I})$ be the number of source registers read by an instruction of class $\\mathcal{I}$, and $W(\\mathcal{I})$ be the number of destination registers written by an instruction of class $\\mathcal{I}$.\nFrom the problem statement:\n- For class $\\mathcal{A}$ (ALU): $R(\\mathcal{A}) = 2$, $W(\\mathcal{A}) = 1$.\n- For class $\\mathcal{L}$ (Load): $R(\\mathcal{L}) = 1$, $W(\\mathcal{L}) = 1$.\n\nThe processor pipeline has a key timing characteristic: an instruction issued in cycle $t$ reads its source operands in cycle $t$ and writes its result in cycle $t+1$.\nThe minimal number of read ports, $P_r$, is the maximum number of registers read in any single cycle. This is determined by the instructions being *issued*.\nThe minimal number of write ports, $P_w$, is the maximum number of registers written in any single cycle. This is determined by the instructions *writing back*, which were issued in the previous cycle.\n\nPart 1: Single-issue core\nA single-issue core can issue at most $1$ instruction per cycle.\nTo find the worst-case read port requirement, we must consider the instruction class that reads the most registers.\n- Issuing an $\\mathcal{A}$ instruction requires $R(\\mathcal{A}) = 2$ read ports.\n- Issuing an $\\mathcal{L}$ instruction requires $R(\\mathcal{L}) = 1$ read port.\nThe maximum demand for read ports in any issue cycle is $\\max(R(\\mathcal{A}), R(\\mathcal{L})) = \\max(2, 1) = 2$.\nTherefore, the minimal number of read ports is $P_r = 2$.\n\nTo find the write port requirement, we consider the writeback stage. Since at most $1$ instruction is issued per cycle, at most $1$ instruction will be in its writeback stage in any subsequent cycle. Both instruction classes write to $1$ register.\nThe maximum demand for write ports in any writeback cycle is thus $1$.\nTherefore, the minimal number of write ports is $P_w = 1$.\nFor the single-issue core, the minimal port requirement is $(P_r, P_w) = (2, 1)$.\n\nPart 2: Dual-issue core (unconstrained)\nA dual-issue core can issue up to $2$ instructions per cycle. With unconstrained scheduling, any pair of instructions may be issued concurrently.\nTo find the worst-case read port requirement, we must consider the pair of instructions that, when issued together, demands the most reads. The possible pairs are $(\\mathcal{A}, \\mathcal{A})$, $(\\mathcal{A}, \\mathcal{L})$, and $(\\mathcal{L}, \\mathcal{L})$.\n- Issuing $(\\mathcal{A}, \\mathcal{A})$: Total read ports = $R(\\mathcal{A}) + R(\\mathcal{A}) = 2 + 2 = 4$.\n- Issuing $(\\mathcal{A}, \\mathcal{L})$: Total read ports = $R(\\mathcal{A}) + R(\\mathcal{L}) = 2 + 1 = 3$.\n- Issuing $(\\mathcal{L}, \\mathcal{L})$: Total read ports = $R(\\mathcal{L}) + R(\\mathcal{L}) = 1 + 1 = 2$.\nThe maximum demand for read ports is driven by issuing two $\\mathcal{A}$ instructions, requiring $4$ read ports.\nTherefore, the minimal number of read ports is $P_r = 4$.\n\nFor the write port requirement, since up to $2$ instructions can be issued in cycle $t$, both will attempt to write back their results in cycle $t+1$. Each instruction writes to $1$ register.\nThe maximum demand for write ports is thus $1 + 1 = 2$.\nTherefore, the minimal number of write ports is $P_w = 2$.\nFor the unconstrained dual-issue core, the minimal port requirement is $(P_r, P_w) = (4, 2)$. The total number of ports is $P_r + P_w = 4 + 2 = 6$.\n\nPart 3: Dual-issue core (constrained policy)\nThe goal is to propose a dual-issue scheduling policy that reduces the total number of RF ports by $1$ compared to the unconstrained case (i.e., from $6$ to $5$), while still issuing $2$ instructions per cycle for the given code fragment (which contains $4$ instances of $\\mathcal{A}$ and $4$ of $\\mathcal{L}$).\n\nThe unconstrained requirement is $(P_r, P_w) = (4, 2)$. To reduce the total port count to $5$, we must reduce either $P_r$ or $P_w$.\n- Reducing $P_w$ to $1$: This would imply that at most one instruction can be in the writeback stage in any cycle. Since writeback in cycle $t+1$ corresponds to issue in cycle $t$, this would limit the processor to issuing only $1$ instruction per cycle, violating the condition of maintaining a dual-issue rate. Thus, $P_w$ must remain $2$.\n- Reducing $P_r$ to $3$: The peak demand of $P_r = 4$ occurs only when two $\\mathcal{A}$ instructions are issued in the same cycle. If we disallow this specific pairing, the maximum read port demand will be lower.\n\nProposed Scheduling Policy: In any given cycle, the processor may issue at most one instruction of class $\\mathcal{A}$.\nThis policy disallows the $(\\mathcal{A}, \\mathcal{A})$ issue pair. We must verify that this policy can still sustain an issue rate of $2$ for the given code fragment, which consists of $4$ $\\mathcal{A}$ instructions and $4$ $\\mathcal{L}$ instructions. We can schedule the execution over $4$ cycles by pairing one $\\mathcal{A}$ with one $\\mathcal{L}$ in each cycle:\n- Cycle 1: Issue $(\\mathcal{A}_1, \\mathcal{L}_1)$\n- Cycle 2: Issue $(\\mathcal{A}_2, \\mathcal{L}_2)$\n- Cycle 3: Issue $(\\mathcal{A}_3, \\mathcal{L}_3)$\n- Cycle 4: Issue $(\\mathcal{A}_4, \\mathcal{L}_4)$\nThis schedule successfully completes the fragment in $4$ cycles, maintaining an average issue rate of $2$ instructions per cycle. The policy is therefore valid and effective.\n\nNow, we compute the minimal port requirements under this new constrained policy.\nThe allowed issue pairs generating maximum demand are $(\\mathcal{A}, \\mathcal{L})$ and $(\\mathcal{L}, \\mathcal{L})$.\n- Issuing $(\\mathcal{A}, \\mathcal{L})$: Total read ports = $R(\\mathcal{A}) + R(\\mathcal{L}) = 2 + 1 = 3$.\n- Issuing $(\\mathcal{L}, \\mathcal{L})$: Total read ports = $R(\\mathcal{L}) + R(\\mathcal{L}) = 1 + 1 = 2$.\nThe new maximum demand for read ports is $3$.\nTherefore, the minimal number of read ports under this policy is $P_r = 3$.\n\nThe write port requirement is unchanged because we are still issuing $2$ instructions per cycle, which will lead to $2$ concurrent writebacks in the next cycle.\nTherefore, the minimal number of write ports remains $P_w = 2$.\n\nThe minimal port requirement under the proposed policy is $(P_r, P_w) = (3, 2)$.\nThe total number of RF ports required is $P_r + P_w = 3 + 2 = 5$.\nThis is a reduction of $1$ port from the unconstrained case's total of $6$, satisfying the problem's conditions. The minimal total number of RF ports under the proposed schedule is $5$.",
            "answer": "$$\\boxed{5}$$"
        },
        {
            "introduction": "Once the necessary number of ports is established, the next critical challenge is ensuring the register file is fast enough to keep up with the processor's clock speed, as RF access time can be a limiting factor in pipeline design. This practice explores a sophisticated technique to mitigate this bottleneck: an RF that performs writes in the first half of a clock cycle and reads in the second half, allowing a dependent instruction to use a result in the same cycle it is produced. By working through this problem , you will perform a detailed timing analysis, grappling with real-world complexities like clock distortion and setup times to determine the maximum allowable RF access delay.",
            "id": "3672114",
            "problem": "A synchronous pipeline uses a single-cycle Register File (RF) to enable back-to-back Read-After-Write (RAW) dependent operations without bypassing. The RF is organized to perform the write operation during the first half of each clock cycle and the read operation during the second half of the same clock cycle. Assume a $50\\%$ duty-cycle clock subject to duty-cycle distortion and clock uncertainty. The write data is launched from a writeback pipeline register at the rising edge, and the read data is captured by the decode stage input register at the next rising edge.\n\nUse the following parameters:\n- Clock period $T_{\\text{clk}} = 1.2\\,\\text{ns}$.\n- Worst-case duty-cycle distortion magnitude $\\varepsilon = 0.08\\,\\text{ns}$, such that the shorter half-cycle duration is $T_{\\text{clk}}/2 - \\varepsilon$.\n- Aggregate clock uncertainty (skew plus jitter) $u = 0.03\\,\\text{ns}$, to be subtracted from any half-cycle budget.\n- Guard time at the half-cycle boundary to avoid sampling during write completion $\\gamma = 0.015\\,\\text{ns}$.\n- Clock-to-$Q$ delay of the writeback register $t_{\\text{cq}} = 0.07\\,\\text{ns}$.\n- Non-RF write-path driver and peripheral delay before the RF array $t_{\\text{wdrv}} = 0.04\\,\\text{ns}$.\n- Non-RF read-path driver and peripheral delay after the RF array $t_{\\text{rdrv}} = 0.05\\,\\text{ns}$.\n- Setup time of the decode-stage input register $t_{\\text{setup}} = 0.04\\,\\text{ns}$.\n\nAssume the intrinsic RF access time $t_{\\text{RF}}$ is symmetric for write and read and defined as the time from stable inputs (address and data for write, address for read) at the RF array boundary to the corresponding stable effect (cell written or read data valid at the RF boundary).\n\nStarting only from the fundamental synchronous timing definitions for setup constraints and the notion that any timing budget must use the worst-case half-cycle (the shorter half due to duty-cycle distortion) minus uncertainty and guard time, derive the maximum allowable $t_{\\text{RF}}$ that guarantees a dependent instruction can read a value written earlier in the same cycle (write in the first half, read in the second half) without forwarding. Express your final answer as a real number in picoseconds, and round your answer to three significant figures.",
            "solution": "The problem requires the determination of the maximum allowable intrinsic Register File (RF) access time, denoted as $t_{\\text{RF}}$, for a synchronous pipeline with a specialized RF organization. This organization permits a dependent instruction to read a value in the second half of a clock cycle that was written in the first half of the same cycle, thereby obviating the need for data forwarding logic to resolve a Read-After-Write (RAW) hazard.\n\nThe analysis hinges on satisfying the setup timing constraints for two distinct paths, both of which are constrained by the half-cycle timing budget: the write path in the first half-cycle and the read path in the second half-cycle. The problem provides an explicit methodology for calculating the timing budget.\n\nFirst, we define the available timing budget for an operation that must complete within a single half-cycle. The total clock period is $T_{\\text{clk}} = 1.2\\,\\text{ns}$. The nominal duration of a half-cycle is $T_{\\text{clk}}/2 = 0.6\\,\\text{ns}$. However, the clock is subject to duty-cycle distortion of magnitude $\\varepsilon = 0.08\\,\\text{ns}$. This means the duration of a half-cycle can vary. The worst-case (shortest) half-cycle duration is given by:\n$$T_{\\text{short}} = \\frac{T_{\\text{clk}}}{2} - \\varepsilon$$\nThe problem explicitly states that \"any timing budget must use the worst-case half-cycle (the shorter half due to duty-cycle distortion) minus uncertainty and guard time\". The aggregate clock uncertainty is $u = 0.03\\,\\text{ns}$, and the guard time is $\\gamma = 0.015\\,\\text{ns}$. Therefore, the effective timing budget, $T_{\\text{budget}}$, for any path that must execute within a half-cycle is:\n$$T_{\\text{budget}} = T_{\\text{short}} - u - \\gamma = \\left(\\frac{T_{\\text{clk}}}{2} - \\varepsilon\\right) - u - \\gamma$$\nSubstituting the given values:\n$$T_{\\text{budget}} = \\left(\\frac{1.2\\,\\text{ns}}{2} - 0.08\\,\\text{ns}\\right) - 0.03\\,\\text{ns} - 0.015\\,\\text{ns}$$\n$$T_{\\text{budget}} = (0.6 - 0.08)\\,\\text{ns} - 0.03\\,\\text{ns} - 0.015\\,\\text{ns}$$\n$$T_{\\text{budget}} = 0.52\\,\\text{ns} - 0.03\\,\\text{ns} - 0.015\\,\\text{ns} = 0.475\\,\\text{ns}$$\nThis budget represents the maximum time available for a signal to propagate and be correctly processed within one half-cycle under worst-case conditions. We now apply this budget to constrain the write and read paths.\n\n**1. Write Path Constraint**\nThe write operation occurs in the first half of the clock cycle. The data is launched from a writeback pipeline register at a rising clock edge. The total delay for the write path, $T_{\\text{write}}$, consists of the clock-to-Q delay of this register ($t_{\\text{cq}}$), the delay through non-RF write-path logic ($t_{\\text{wdrv}}$), and the intrinsic RF write time ($t_{\\text{RF}}$). This entire operation must complete within the calculated budget.\n$$T_{\\text{write}} = t_{\\text{cq}} + t_{\\text{wdrv}} + t_{\\text{RF}}$$\nThe timing constraint is:\n$$T_{\\text{write}} \\le T_{\\text{budget}}$$\n$$t_{\\text{cq}} + t_{\\text{wdrv}} + t_{\\text{RF}} \\le T_{\\text{budget}}$$\nWe can solve this inequality for an upper bound on $t_{\\text{RF}}$:\n$$t_{\\text{RF}} \\le T_{\\text{budget}} - t_{\\text{cq}} - t_{\\text{wdrv}}$$\nSubstituting the numerical values:\n$$t_{\\text{RF}} \\le 0.475\\,\\text{ns} - 0.07\\,\\text{ns} - 0.04\\,\\text{ns}$$\n$$t_{\\text{RF}} \\le 0.475\\,\\text{ns} - 0.11\\,\\text{ns}$$\n$$t_{\\text{RF}} \\le 0.365\\,\\text{ns}$$\n\n**2. Read Path Constraint**\nThe read operation occurs in the second half of the clock cycle. The data is read from the RF and must be captured by the decode-stage input register at the next rising clock edge. The read path delay, $T_{\\text{read}}$, is the sum of the intrinsic RF read time ($t_{\\text{RF}}$) and the delay through non-RF read-path logic ($t_{\\text{rdrv}}$). For a successful capture, the data must be stable at the register's input for at least the setup time, $t_{\\text{setup}}$, before the capturing clock edge arrives. Therefore, the sum of the read path delay and the setup time must be within the timing budget.\n$$T_{\\text{read}} = t_{\\text{RF}} + t_{\\text{rdrv}}$$\nThe timing constraint is:\n$$T_{\\text{read}} + t_{\\text{setup}} \\le T_{\\text{budget}}$$\n$$t_{\\text{RF}} + t_{\\text{rdrv}} + t_{\\text{setup}} \\le T_{\\text{budget}}$$\nSolving for the upper bound on $t_{\\text{RF}}$ from this constraint:\n$$t_{\\text{RF}} \\le T_{\\text{budget}} - t_{\\text{rdrv}} - t_{\\text{setup}}$$\nSubstituting the numerical values:\n$$t_{\\text{RF}} \\le 0.475\\,\\text{ns} - 0.05\\,\\text{ns} - 0.04\\,\\text{ns}$$\n$$t_{\\text{RF}} \\le 0.475\\,\\text{ns} - 0.09\\,\\text{ns}$$\n$$t_{\\text{RF}} \\le 0.385\\,\\text{ns}$$\n\n**3. Final Determination of Maximum $t_{\\text{RF}}$**\nThe intrinsic RF access time $t_{\\text{RF}}$ is assumed to be the same for both write and read operations. For the RF to function correctly, $t_{\\text{RF}}$ must satisfy both the write-path and read-path constraints simultaneously.\n$$t_{\\text{RF}} \\le 0.365\\,\\text{ns} \\quad (\\text{from write path})$$\n$$t_{\\text{RF}} \\le 0.385\\,\\text{ns} \\quad (\\text{from read path})$$\nThe maximum value of $t_{\\text{RF}}$ that satisfies both conditions is the minimum of the two upper bounds. The write path is the more restrictive one.\n$$t_{\\text{RF,max}} = \\min(0.365\\,\\text{ns}, 0.385\\,\\text{ns}) = 0.365\\,\\text{ns}$$\nThe problem asks for the answer to be expressed in picoseconds ($ps$) and rounded to three significant figures.\n$$t_{\\text{RF,max}} = 0.365 \\times 10^{-9}\\,\\text{s} = 365 \\times 10^{-12}\\,\\text{s} = 365\\,\\text{ps}$$\nThe value $365$ has three significant figures, so no further rounding is needed.",
            "answer": "$$ \\boxed{365} $$"
        },
        {
            "introduction": "Modern out-of-order processors use a large Physical Register File (PRF) to enable register renaming and break false data dependencies, but this PRF is a finite resource that must be managed carefully. This problem introduces a powerful optimization: speculatively reclaiming a physical register before its value is architecturally confirmed to be \"dead.\" Through this exercise , you will use probability theory to model and quantify the trade-off, calculating the expected performance penalty of a misprediction and gaining insight into how architects manage risk in speculative microarchitectures.",
            "id": "3672059",
            "problem": "A superscalar out-of-order central processing unit (CPU) implements register renaming with a physical register file. To increase effective free-list availability, the microarchitecture uses a speculative liveness predictor that may recycle a physical register bound to a logical register’s previous mapping before the previous value is architecturally proven dead. The predictor operates at the rename stage: when an instruction that defines a destination logical register arrives, the old physical register for that logical register becomes a candidate for speculative recycling. The microarchitecture recycles a candidate immediately only when the predictor declares the old value as dead.\n\nAssume the following stationary statistics over a long dynamic execution window and independence across instructions:\n- A fraction $f$ of dynamic instructions produce a destination and therefore create a speculative recycling candidate.\n- The base rate that a candidate old value is actually dead at prediction time is $p_{\\text{dead}}$.\n- The liveness predictor has true positive rate (TPR) and false positive rate (FPR), defined as $\\text{TPR} = \\mathbb{P}(\\text{predict dead} \\mid \\text{actually dead})$ and $\\text{FPR} = \\mathbb{P}(\\text{predict dead} \\mid \\text{actually live})$.\n- If a recycled value is later demanded by a consumer (i.e., the predictor was wrong and the recycled value was actually live), the machine detects the violation at read time and initiates a full rollback that costs $R$ cycles of lost work. Otherwise, there is no rollback cost associated with the recycling event.\n\nYour task is to start from the definitions of conditional probability and Bayes’ theorem to:\n1) Derive the probability that a speculative recycling action results in a violation, i.e., $\\mathbb{P}(\\text{actually live} \\mid \\text{predict dead})$.\n2) Use this to compute the expected rollback cycles per $N$ retired instructions, where $N = 10^{6}$.\n\nUse the following parameter values: $f = 0.55$, $p_{\\text{dead}} = 0.65$, $\\text{TPR} = 0.92$, $\\text{FPR} = 0.06$, $R = 18$, and $N = 10^{6}$. Express your final result as the expected rollback cycles per $10^{6}$ retired instructions. Round your final answer to four significant figures.",
            "solution": "Let us define the following events for a speculative recycling candidate:\n- $L$: The old register value is actually live.\n- $D$: The old register value is actually dead. This is the complement of $L$.\n- $P_D$: The predictor predicts that the old register value is dead.\n- $P_L$: The predictor predicts that the old register value is live. This is the complement of $P_D$.\n\nFrom the problem statement, we are given the following probabilities and parameters:\n- The fraction of instructions creating a candidate: $f = 0.55$.\n- The base rate that a candidate is actually dead: $p_{\\text{dead}} = \\mathbb{P}(D) = 0.65$.\n- The true positive rate: $\\text{TPR} = \\mathbb{P}(P_D \\mid D) = 0.92$. A \"positive\" case is an actually dead register, and \"true positive\" means predicting it as dead.\n- The false positive rate: $\\text{FPR} = \\mathbb{P}(P_D \\mid L) = 0.06$. A \"negative\" case is an actually live register, and \"false positive\" means incorrectly predicting it as dead.\n- The rollback cost: $R = 18$ cycles.\n- The total number of instructions: $N = 10^6$.\n\nThe probability that a candidate is actually live is the complement of it being dead:\n$$ \\mathbb{P}(L) = 1 - \\mathbb{P}(D) = 1 - p_{\\text{dead}} $$\n\n### Part 1: Derivation of the Violation Probability\n\nThe first task is to derive the probability that a speculative recycling action results in a violation. A recycling action occurs when the predictor declares a candidate as dead (event $P_D$). A violation occurs if this prediction was wrong, meaning the value was actually live (event $L$). Therefore, we must find the conditional probability $\\mathbb{P}(L \\mid P_D)$.\n\nWe apply Bayes' theorem:\n$$ \\mathbb{P}(L \\mid P_D) = \\frac{\\mathbb{P}(P_D \\mid L) \\mathbb{P}(L)}{\\mathbb{P}(P_D)} $$\n\nTo use this formula, we first need to find the total probability of the predictor declaring a candidate dead, $\\mathbb{P}(P_D)$. We can find this using the law of total probability, conditioning on whether the register is actually live or dead:\n$$ \\mathbb{P}(P_D) = \\mathbb{P}(P_D \\mid L) \\mathbb{P}(L) + \\mathbb{P}(P_D \\mid D) \\mathbb{P}(D) $$\n\nSubstituting the given definitions and derived probabilities:\n$$ \\mathbb{P}(P_D) = \\text{FPR} \\cdot (1 - p_{\\text{dead}}) + \\text{TPR} \\cdot p_{\\text{dead}} $$\n\nNow, we can substitute this expression back into Bayes' theorem:\n$$ \\mathbb{P}(L \\mid P_D) = \\frac{\\mathbb{P}(P_D \\mid L) \\mathbb{P}(L)}{\\mathbb{P}(P_D \\mid L) \\mathbb{P}(L) + \\mathbb{P}(P_D \\mid D) \\mathbb{P}(D)} $$\n$$ \\mathbb{P}(L \\mid P_D) = \\frac{\\text{FPR} \\cdot (1 - p_{\\text{dead}})}{\\text{FPR} \\cdot (1 - p_{\\text{dead}}) + \\text{TPR} \\cdot p_{\\text{dead}}} $$\nThis is the symbolic expression for the probability of a violation, given that a speculative recycling action has been taken.\n\n### Part 2: Calculation of Expected Rollback Cycles\n\nThe second task is to compute the expected rollback cycles per $N$ retired instructions. Let this be $E[C_N]$. A rollback occurs and costs $R$ cycles only if a sequence of three conditions is met for a given instruction:\n1. The instruction creates a speculative recycling candidate.\n2. The candidate corresponds to an old register value that is actually live.\n3. The predictor incorrectly predicts this live value as dead.\n\nLet's calculate the expected number of such rollback events over $N$ instructions.\nThe total number of instructions is $N$.\nThe expected number of instructions that create a recycling candidate is:\n$$ E[N_{\\text{cand}}] = N \\cdot f $$\nAmong these candidates, the expected number that are actually live is:\n$$ E[N_{\\text{live}}] = E[N_{\\text{cand}}] \\cdot \\mathbb{P}(L) = N \\cdot f \\cdot (1 - p_{\\text{dead}}) $$\nA rollback is triggered for one of these live candidates if the predictor makes a false positive prediction (predicts dead). The probability of this is $\\text{FPR} = \\mathbb{P}(P_D \\mid L)$.\nSo, the expected number of rollbacks over $N$ instructions is:\n$$ E[N_{\\text{rollback}}] = E[N_{\\text{live}}] \\cdot \\text{FPR} = N \\cdot f \\cdot (1 - p_{\\text{dead}}) \\cdot \\text{FPR} $$\nEach rollback incurs a cost of $R$ cycles. The total expected rollback cost over $N$ instructions is the expected number of rollbacks multiplied by the cost per rollback:\n$$ E[C_N] = E[N_{\\text{rollback}}] \\cdot R = N \\cdot f \\cdot (1 - p_{\\text{dead}}) \\cdot \\text{FPR} \\cdot R $$\n\nNow, we substitute the given numerical values into this expression:\n- $N = 10^6$\n- $f = 0.55$\n- $p_{\\text{dead}} = 0.65$\n- $\\text{FPR} = 0.06$\n- $R = 18$\n\n$$ E[C_{10^6}] = 10^6 \\cdot 0.55 \\cdot (1 - 0.65) \\cdot 0.06 \\cdot 18 $$\n$$ E[C_{10^6}] = 10^6 \\cdot 0.55 \\cdot 0.35 \\cdot 0.06 \\cdot 18 $$\nLet's compute the product of the terms:\n$$ 0.55 \\cdot 0.35 = 0.1925 $$\n$$ 0.1925 \\cdot 0.06 = 0.01155 $$\n$$ 0.01155 \\cdot 18 = 0.2079 $$\nSo, the total expected cost is:\n$$ E[C_{10^6}] = 10^6 \\cdot 0.2079 = 207900 $$\nThe problem asks for the answer to be rounded to four significant figures. The number $207900$ can be written in scientific notation as $2.079 \\times 10^5$, which already contains four significant figures.",
            "answer": "$$\n\\boxed{2.079 \\times 10^5}\n$$"
        }
    ]
}