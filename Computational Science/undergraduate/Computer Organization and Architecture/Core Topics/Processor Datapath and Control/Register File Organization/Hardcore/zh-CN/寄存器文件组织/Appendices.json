{
    "hands_on_practices": [
        {
            "introduction": "寄存器堆的设计是处理器核心设计的基石之一。这个练习将带你探讨一个核心权衡：为了支持更高水平的指令级并行（ILP），我们需要多少读写端口？通过分析不同指令组合下的最坏情况，你将学会如何确定寄存器堆的端口需求，并探索如何通过巧妙的指令调度策略来优化硬件成本。",
            "id": "3672090",
            "problem": "一个处理器拥有一个中央寄存器堆（RF），该寄存器堆有 $P_r$ 个读端口和 $P_w$ 个写端口。每条指令在单一的操作数读取阶段访问寄存器堆：一条已发射指令的所有源寄存器在该阶段被并发读取，其结果在单一的写回阶段被写入。假设功能单元是固定延迟的，因此任何写入其目的寄存器的指令都会在发射后恰好 $1$ 个周期执行写回操作。该核心可以配置为单发射（发射宽度为 $1$）或双发射（发射宽度为 $2$）。\n\n考虑一个包含两类指令的指令集：\n- 算术逻辑单元（ALU）的寄存器-寄存器操作，记为 $\\mathcal{A}$ 类，每条指令读取 $2$ 个源寄存器并写入 $1$ 个目的寄存器。\n- 加载操作，记为 $\\mathcal{L}$ 类，每条指令读取 $1$ 个基址寄存器并写入 $1$ 个目的寄存器（假设地址由基址寄存器加立即数形成，并且内存在最小的缓存中命中，因此写回操作的固定延迟为 $1$）。\n\n待执行的代码片段恰好包含 $4$ 个 $\\mathcal{A}$ 类实例和 $4$ 个 $\\mathcal{L}$ 类实例，且不存在会禁止类间任意重排序的数据相关（忽略控制冒险；所有分支都已解决且不在此片段中）。在双发射模式下，处理器每周期最多可发射 $2$ 条指令；在单发射模式下，每周期最多可发射 $1$ 条指令。\n\n仅使用寄存器堆端口的核心定义和上述给出的每指令操作数计数，并将端口需求视为保证无停顿执行所需的每周期最大并发寄存器堆访问次数：\n1. 推导在最坏情况下的每周期需求下，单发射核心的最小寄存器堆端口需求 $(P_r, P_w)$。\n2. 如果在一个周期内发射的两条指令在类别上不受约束（即，来自 $\\{\\mathcal{A}, \\mathcal{L}\\}$ 的任何一对指令都可以一起发射），推导双发射核心的最小寄存器堆端口需求 $(P_r, P_w)$。\n3. 为此代码片段提出一种双发射调度策略，该策略与不受约束的双发射情况相比，所需寄存器堆端口数减少 $1$ 个，同时仍能每周期发射 $2$ 条指令，并计算该策略下所需的最小总端口数 $P_r + P_w$。\n\n将最终答案表示为一个整数，等于您提出的调度策略下的最小 $P_r + P_w$ 值。无需四舍五入，也无物理单位。",
            "solution": "问题要求计算在不同发射宽度配置和调度策略下，处理器所需的最小寄存器堆（RF）端口数。端口需求由保证无停顿执行时，任何单周期内所需的最大并发寄存器堆访问次数定义。分析分为三个部分。\n\n设 $R(\\mathcal{I})$ 为 $\\mathcal{I}$ 类指令读取的源寄存器数量， $W(\\mathcal{I})$ 为 $\\mathcal{I}$ 类指令写入的目的寄存器数量。\n根据题目描述：\n- 对于 $\\mathcal{A}$ 类（ALU）：$R(\\mathcal{A}) = 2$, $W(\\mathcal{A}) = 1$。\n- 对于 $\\mathcal{L}$ 类（加载）：$R(\\mathcal{L}) = 1$, $W(\\mathcal{L}) = 1$。\n\n处理器流水线有一个关键的时序特征：在周期 $t$ 发射的指令在周期 $t$ 读取其源操作数，并在周期 $t+1$ 写回其结果。\n最小读端口数 $P_r$ 是任何单周期内读取寄存器的最大数量。这由正在*发射*的指令决定。\n最小写端口数 $P_w$ 是任何单周期内写入寄存器的最大数量。这由正在*写回*的指令决定，这些指令是在前一个周期发射的。\n\n第一部分：单发射核心\n单发射核心每周期最多可以发射 $1$ 条指令。\n为了找到最坏情况下的读端口需求，我们必须考虑读取寄存器最多的指令类别。\n- 发射一条 $\\mathcal{A}$ 类指令需要 $R(\\mathcal{A}) = 2$ 个读端口。\n- 发射一条 $\\mathcal{L}$ 类指令需要 $R(\\mathcal{L}) = 1$ 个读端口。\n在任何发射周期中，对读端口的最大需求为 $\\max(R(\\mathcal{A}), R(\\mathcal{L})) = \\max(2, 1) = 2$。\n因此，最小读端口数为 $P_r = 2$。\n\n为了找到写端口需求，我们考虑写回阶段。由于每周期最多发射 $1$ 条指令，因此在任何后续周期中，最多有 $1$ 条指令处于其写回阶段。两种指令类别都写入 $1$ 个寄存器。\n因此，在任何写回周期中，对写端口的最大需求为 $1$。\n因此，最小写端口数为 $P_w = 1$。\n对于单发射核心，最小端口需求为 $(P_r, P_w) = (2, 1)$。\n\n第二部分：双发射核心（不受约束）\n双发射核心每周期最多可以发射 $2$ 条指令。在不受约束的调度下，任何一对指令都可以并发发射。\n为了找到最坏情况下的读端口需求，我们必须考虑同时发射时需要最多读取操作的指令对。可能的指令对是 $(\\mathcal{A}, \\mathcal{A})$, $(\\mathcal{A}, \\mathcal{L})$ 和 $(\\mathcal{L}, \\mathcal{L})$。\n- 发射 $(\\mathcal{A}, \\mathcal{A})$：总读端口数 = $R(\\mathcal{A}) + R(\\mathcal{A}) = 2 + 2 = 4$。\n- 发射 $(\\mathcal{A}, \\mathcal{L})$：总读端口数 = $R(\\mathcal{A}) + R(\\mathcal{L}) = 2 + 1 = 3$。\n- 发射 $(\\mathcal{L}, \\mathcal{L})$：总读端口数 = $R(\\mathcal{L}) + R(\\mathcal{L}) = 1 + 1 = 2$。\n读端口的最大需求是由发射两条 $\\mathcal{A}$ 指令驱动的，需要 $4$ 个读端口。\n因此，最小读端口数为 $P_r = 4$。\n\n对于写端口需求，由于在周期 $t$ 最多可以发射 $2$ 条指令，这两条指令都将尝试在周期 $t+1$ 写回其结果。每条指令写入 $1$ 个寄存器。\n因此，对写端口的最大需求为 $1 + 1 = 2$。\n因此，最小写端口数为 $P_w = 2$。\n对于不受约束的双发射核心，最小端口需求为 $(P_r, P_w) = (4, 2)$。总端口数为 $P_r + P_w = 4 + 2 = 6$。\n\n第三部分：双发射核心（受约束的策略）\n目标是提出一种双发射调度策略，与不受约束的情况相比，该策略能将寄存器堆总端口数减少 $1$（即从 $6$ 减少到 $5$），同时对于给定的代码片段（包含 $4$ 个 $\\mathcal{A}$ 实例和 $4$ 个 $\\mathcal{L}$ 实例）仍然能保持每周期发射 $2$ 条指令。\n\n不受约束的需求为 $(P_r, P_w) = (4, 2)$。要将总端口数减少到 $5$，我们必须减少 $P_r$ 或 $P_w$。\n- 将 $P_w$ 减少到 $1$：这意味着在任何周期中，最多只能有一条指令处于写回阶段。由于周期 $t+1$ 的写回对应于周期 $t$ 的发射，这将限制处理器每周期只能发射 $1$ 条指令，违反了保持双发射率的条件。因此，$P_w$ 必须保持为 $2$。\n- 将 $P_r$ 减少到 $3$：$P_r = 4$ 的峰值需求仅在同一周期发射两条 $\\mathcal{A}$ 指令时发生。如果我们禁止这种特定的配对，最大读端口需求将会降低。\n\n提议的调度策略：在任何给定的周期内，处理器最多可以发射一条 $\\mathcal{A}$ 类的指令。\n此策略禁止了 $(\\mathcal{A}, \\mathcal{A})$ 发射对。我们必须验证此策略对于给定的代码片段（由 $4$ 条 $\\mathcal{A}$ 指令和 $4$ 条 $\\mathcal{L}$ 指令组成）仍然可以维持 $2$ 的发射率。我们可以通过在每个周期将一条 $\\mathcal{A}$ 与一条 $\\mathcal{L}$ 配对，将执行安排在 $4$ 个周期内完成：\n- 周期 1: 发射 $(\\mathcal{A}_1, \\mathcal{L}_1)$\n- 周期 2: 发射 $(\\mathcal{A}_2, \\mathcal{L}_2)$\n- 周期 3: 发射 $(\\mathcal{A}_3, \\mathcal{L}_3)$\n- 周期 4: 发射 $(\\mathcal{A}_4, \\mathcal{L}_4)$\n这个调度在 $4$ 个周期内成功完成了该片段，保持了每周期 $2$ 条指令的平均发射率。因此，该策略是有效且可行的。\n\n现在，我们计算在这种新的受约束策略下的最小端口需求。\n产生最大需求的允许发射对是 $(\\mathcal{A}, \\mathcal{L})$ 和 $(\\mathcal{L}, \\mathcal{L})$。\n- 发射 $(\\mathcal{A}, \\mathcal{L})$：总读端口数 = $R(\\mathcal{A}) + R(\\mathcal{L}) = 2 + 1 = 3$。\n- 发射 $(\\mathcal{L}, \\mathcal{L})$：总读端口数 = $R(\\mathcal{L}) + R(\\mathcal{L}) = 1 + 1 = 2$。\n新的最大读端口需求为 $3$。\n因此，在此策略下的最小读端口数为 $P_r = 3$。\n\n写端口需求不变，因为我们仍然每周期发射 $2$ 条指令，这将在下一个周期导致 $2$ 次并发写回。\n因此，最小写端口数仍为 $P_w = 2$。\n\n在提议的策略下，最小端口需求为 $(P_r, P_w) = (3, 2)$。\n所需的寄存器堆总端口数为 $P_r + P_w = 3 + 2 = 5$。\n这比不受约束情况下的总端口数 $6$ 减少了 $1$ 个，满足了题目的条件。在提议的调度下，最小总寄存器堆端口数为 $5$。",
            "answer": "$$\\boxed{5}$$"
        },
        {
            "introduction": "确定了端口数量后，我们必须确保寄存器堆的速度能跟上处理器的时钟频率。本练习将深入探讨同步电路的时序细节，让你在一个专门为解决数据冒险而设计的寄存器堆上，应用严格的时序分析。你将计算在考虑了时钟失真和不确定性等现实因素后，寄存器堆所允许的最大访问时间$t_{\\text{RF}}$，从而深刻理解物理约束如何影响微体系结构设计。",
            "id": "3672114",
            "problem": "一个同步流水线使用单周期寄存器文件 (RF) 来实现背靠背的写后读 (RAW) 相关操作，而无需旁路。该 RF 的组织方式是在每个时钟周期的前半部分执行写操作，在同一时钟周期的后半部分执行读操作。假设一个占空比为 $50\\%$ 的时钟，该时钟存在占空比失真和时钟不确定性。写入数据在上升沿从写回流水线寄存器发出，读出数据在下一个上升沿被译码级输入寄存器捕获。\n\n使用以下参数：\n- 时钟周期 $T_{\\text{clk}} = 1.2\\,\\text{ns}$。\n- 最坏情况下的占空比失真幅度 $\\varepsilon = 0.08\\,\\text{ns}$，使得较短半周期的持续时间为 $T_{\\text{clk}}/2 - \\varepsilon$。\n- 总时钟不确定性（偏移加抖动）$u = 0.03\\,\\text{ns}$，需从任何半周期预算中减去。\n- 半周期边界处的保护时间 $\\gamma = 0.015\\,\\text{ns}$，以避免在写操作完成期间进行采样。\n- 写回寄存器的时钟到Q延迟 $t_{\\text{cq}} = 0.07\\,\\text{ns}$。\n- RF阵列前的非RF写路径驱动器和外设延迟 $t_{\\text{wdrv}} = 0.04\\,\\text{ns}$。\n- RF阵列后的非RF读路径驱动器和外设延迟 $t_{\\text{rdrv}} = 0.05\\,\\text{ns}$。\n- 译码级输入寄存器的建立时间 $t_{\\text{setup}} = 0.04\\,\\text{ns}$。\n\n假设固有RF访问时间 $t_{\\text{RF}}$ 对于写和读是对称的，并定义为从RF阵列边界处的稳定输入（写操作的地址和数据，读操作的地址）到相应的稳定效应（单元被写入或读出数据在RF边界处有效）的时间。\n\n仅从建立约束的基本同步时序定义以及任何时序预算都必须使用最坏情况的半周期（由于占空比失真而导致的较短半周期）减去不确定性和保护时间这一概念出发，推导出最大允许的 $t_{\\text{RF}}$，以保证相关指令可以在同一周期内（前半周期写，后半周期读）读取先前写入的值而无需转发。请用皮秒为单位的实数表示最终答案，并将答案四舍五入到三位有效数字。",
            "solution": "该问题要求确定一个具有特殊RF组织结构的同步流水线所允许的最大固有寄存器文件(RF)访问时间，记为 $t_{\\text{RF}}$。这种组织结构允许相关指令在时钟周期的后半部分读取同一周期前半部分写入的值，从而避免了为解决写后读(RAW)冒险而需要数据转发逻辑。\n\n分析的关键在于满足两条不同路径的建立时序约束，这两条路径都受到半周期时序预算的限制：前半周期的写路径和后半周期的读路径。问题提供了一种计算时序预算的明确方法。\n\n首先，我们定义一个必须在单个半周期内完成的操作的可用时序预算。总时钟周期为 $T_{\\text{clk}} = 1.2\\,\\text{ns}$。半周期的标称持续时间为 $T_{\\text{clk}}/2 = 0.6\\,\\text{ns}$。然而，时钟受到幅度为 $\\varepsilon = 0.08\\,\\text{ns}$ 的占空比失真的影响。这意味着半周期的持续时间可能会变化。最坏情况（最短）的半周期持续时间由下式给出：\n$$T_{\\text{short}} = \\frac{T_{\\text{clk}}}{2} - \\varepsilon$$\n问题明确指出，“任何时序预算都必须使用最坏情况的半周期（由于占空比失真而导致的较短半周期）减去不确定性和保护时间”。总时钟不确定性为 $u = 0.03\\,\\text{ns}$，保护时间为 $\\gamma = 0.015\\,\\text{ns}$。因此，任何必须在半周期内执行的路径的有效时序预算 $T_{\\text{budget}}$ 为：\n$$T_{\\text{budget}} = T_{\\text{short}} - u - \\gamma = \\left(\\frac{T_{\\text{clk}}}{2} - \\varepsilon\\right) - u - \\gamma$$\n代入给定值：\n$$T_{\\text{budget}} = \\left(\\frac{1.2\\,\\text{ns}}{2} - 0.08\\,\\text{ns}\\right) - 0.03\\,\\text{ns} - 0.015\\,\\text{ns}$$\n$$T_{\\text{budget}} = (0.6 - 0.08)\\,\\text{ns} - 0.03\\,\\text{ns} - 0.015\\,\\text{ns}$$\n$$T_{\\text{budget}} = 0.52\\,\\text{ns} - 0.03\\,\\text{ns} - 0.015\\,\\text{ns} = 0.475\\,\\text{ns}$$\n该预算表示在最坏情况下，信号在一个半周期内传播并被正确处理的最大可用时间。我们现在应用此预算来约束写路径和读路径。\n\n**1. 写路径约束**\n写操作发生在时钟周期的前半部分。数据在时钟上升沿从写回流水线寄存器发出。写路径的总延迟 $T_{\\text{write}}$ 包括该寄存器的时钟到Q延迟 ($t_{\\text{cq}}$)、通过非RF写路径逻辑的延迟 ($t_{\\text{wdrv}}$)以及固有RF写时间 ($t_{\\text{RF}}$)。这整个操作必须在计算出的预算内完成。\n$$T_{\\text{write}} = t_{\\text{cq}} + t_{\\text{wdrv}} + t_{\\text{RF}}$$\n时序约束为：\n$$T_{\\text{write}} \\le T_{\\text{budget}}$$\n$$t_{\\text{cq}} + t_{\\text{wdrv}} + t_{\\text{RF}} \\le T_{\\text{budget}}$$\n我们可以解这个不等式，得到 $t_{\\text{RF}}$ 的一个上界：\n$$t_{\\text{RF}} \\le T_{\\text{budget}} - t_{\\text{cq}} - t_{\\text{wdrv}}$$\n代入数值：\n$$t_{\\text{RF}} \\le 0.475\\,\\text{ns} - 0.07\\,\\text{ns} - 0.04\\,\\text{ns}$$\n$$t_{\\text{RF}} \\le 0.475\\,\\text{ns} - 0.11\\,\\text{ns}$$\n$$t_{\\text{RF}} \\le 0.365\\,\\text{ns}$$\n\n**2. 读路径约束**\n读操作发生在时钟周期的后半部分。数据从RF中读出，并且必须在下一个时钟上升沿被译码级输入寄存器捕获。读路径延迟 $T_{\\text{read}}$ 是固有RF读时间 ($t_{\\text{RF}}$) 和通过非RF读路径逻辑的延迟 ($t_{\\text{rdrv}}$) 之和。为了成功捕获，数据必须在捕获时钟沿到达之前，在寄存器输入端稳定至少一个建立时间 $t_{\\text{setup}}$。因此，读路径延迟与建立时间之和必须在时序预算之内。\n$$T_{\\text{read}} = t_{\\text{RF}} + t_{\\text{rdrv}}$$\n时序约束为：\n$$T_{\\text{read}} + t_{\\text{setup}} \\le T_{\\text{budget}}$$\n$$t_{\\text{RF}} + t_{\\text{rdrv}} + t_{\\text{setup}} \\le T_{\\text{budget}}$$\n从这个约束中求解 $t_{\\text{RF}}$ 的上界：\n$$t_{\\text{RF}} \\le T_{\\text{budget}} - t_{\\text{rdrv}} - t_{\\text{setup}}$$\n代入数值：\n$$t_{\\text{RF}} \\le 0.475\\,\\text{ns} - 0.05\\,\\text{ns} - 0.04\\,\\text{ns}$$\n$$t_{\\text{RF}} \\le 0.475\\,\\text{ns} - 0.09\\,\\text{ns}$$\n$$t_{\\text{RF}} \\le 0.385\\,\\text{ns}$$\n\n**3. 最终确定最大 $t_{\\text{RF}}$**\n假设固有RF访问时间 $t_{\\text{RF}}$ 对写操作和读操作是相同的。为了使RF正常工作，$t_{\\text{RF}}$ 必须同时满足写路径和读路径的约束。\n$$t_{\\text{RF}} \\le 0.365\\,\\text{ns} \\quad (\\text{来自写路径})$$\n$$t_{\\text{RF}} \\le 0.385\\,\\text{ns} \\quad (\\text{来自读路径})$$\n满足这两个条件的最大 $t_{\\text{RF}}$ 值是两个上界中的最小值。写路径是更具限制性的一个。\n$$t_{\\text{RF,max}} = \\min(0.365\\,\\text{ns}, 0.385\\,\\text{ns}) = 0.365\\,\\text{ns}$$\n问题要求答案以皮秒 ($ps$) 为单位表示，并四舍五入到三位有效数字。\n$$t_{\\text{RF,max}} = 0.365 \\times 10^{-9}\\,\\text{s} = 365 \\times 10^{-12}\\,\\text{s} = 365\\,\\text{ps}$$\n值 $365$ 有三位有效数字，因此无需进一步四舍五入。",
            "answer": "$$ \\boxed{365} $$"
        },
        {
            "introduction": "在现代乱序执行处理器中，有效的物理寄存器管理至关重要。这个练习将向你介绍一种前沿的优化技术：基于预测器推测性地回收物理寄存器，以提高其利用率。你将运用概率论（特别是贝叶斯定理）来量化这种激进优化策略的风险（预测错误导致的回滚开销）与回报，体验微体系结构设计如何与性能概率模型相结合。",
            "id": "3672059",
            "problem": "一个超标量乱序中央处理器 (CPU) 通过物理寄存器文件实现寄存器重命名。为了提高空闲列表的有效可用性，该微架构使用了一个推测性活跃度预测器，该预测器可以在一个物理寄存器绑定的前一个值在架构上被证明无效之前，就回收该物理寄存器。该预测器在重命名阶段工作：当一条定义了目标逻辑寄存器的指令到达时，该逻辑寄存器对应的旧物理寄存器就成为一个推测性回收的候选者。只有当预测器声明旧值为无效时，微架构才会立即回收一个候选寄存器。\n\n假设在一个长的动态执行窗口中，以下统计数据是平稳的，并且指令之间相互独立：\n- 动态指令中的一部分（比例为 $f$）会产生一个目标寄存器，从而创建一个推测性回收候选者。\n- 在预测时，一个候选的旧值实际上是无效的基本比率为 $p_{\\text{dead}}$。\n- 活跃度预测器具有真阳性率 (TPR) 和假阳性率 (FPR)，定义为 $\\text{TPR} = \\mathbb{P}(\\text{预测为无效} \\mid \\text{实际上无效})$ 和 $\\text{FPR} = \\mathbb{P}(\\text{预测为无效} \\mid \\text{实际上有效})$。\n- 如果一个被回收的值后来被一个消费者指令需要（即预测器出错，被回收的值实际上是有效的），机器会在读取时检测到该冲突，并启动一次完全回滚，代价是损失 $R$ 个周期的工作。否则，与回收事件相关的回滚代价为零。\n\n你的任务是从条件概率和贝叶斯定理的定义出发，完成以下任务：\n1) 推导一次推测性回收操作导致冲突的概率，即 $\\mathbb{P}(\\text{实际上有效} \\mid \\text{预测为无效})$。\n2) 使用此概率计算每 $N$ 条已退役指令的期望回滚周期数，其中 $N = 10^{6}$。\n\n使用以下参数值：$f = 0.55$，$p_{\\text{dead}} = 0.65$，$\\text{TPR} = 0.92$，$\\text{FPR} = 0.06$，$R = 18$，以及 $N = 10^{6}$。将你的最终结果表示为每 $10^{6}$ 条已退役指令的期望回滚周期数。将最终答案四舍五入到四位有效数字。",
            "solution": "对于一个推测性回收候选者，让我们定义以下事件：\n- $L$：旧寄存器值实际上是有效的（live）。\n- $D$：旧寄存器值实际上是无效的（dead）。这是 $L$ 的补事件。\n- $P_D$：预测器预测旧寄存器值为无效。\n- $P_L$：预测器预测旧寄存器值为有效。这是 $P_D$ 的补事件。\n\n根据问题陈述，我们有以下给定的概率和参数：\n- 创建候选者的指令比例：$f = 0.55$。\n- 候选者实际上是无效的基本比率：$p_{\\text{dead}} = \\mathbb{P}(D) = 0.65$。\n- 真阳性率：$\\text{TPR} = \\mathbb{P}(P_D \\mid D) = 0.92$。“阳性”情况指寄存器实际上是无效的，“真阳性”意味着将其预测为无效。\n- 假阳性率：$\\text{FPR} = \\mathbb{P}(P_D \\mid L) = 0.06$。“阴性”情况指寄存器实际上是有效的，“假阳性”意味着错误地将其预测为无效。\n- 回滚代价：$R = 18$ 个周期。\n- 总指令数：$N = 10^6$。\n\n一个候选者实际上是有效的概率是其为无效的补事件：\n$$ \\mathbb{P}(L) = 1 - \\mathbb{P}(D) = 1 - p_{\\text{dead}} $$\n\n### 第1部分：推导冲突概率\n\n第一项任务是推导一次推测性回收操作导致冲突的概率。当预测器将一个候选者声明为无效（事件 $P_D$）时，回收操作就会发生。如果这个预测是错误的，即该值实际上是有效的（事件 $L$），则会发生冲突。因此，我们必须求条件概率 $\\mathbb{P}(L \\mid P_D)$。\n\n我们应用贝叶斯定理：\n$$ \\mathbb{P}(L \\mid P_D) = \\frac{\\mathbb{P}(P_D \\mid L) \\mathbb{P}(L)}{\\mathbb{P}(P_D)} $$\n\n要使用此公式，我们首先需要求出预测器将候选者声明为无效的总概率 $\\mathbb{P}(P_D)$。我们可以使用全概率定律，以寄存器实际上是有效还是无效为条件来求得：\n$$ \\mathbb{P}(P_D) = \\mathbb{P}(P_D \\mid L) \\mathbb{P}(L) + \\mathbb{P}(P_D \\mid D) \\mathbb{P}(D) $$\n\n代入给定的定义和推导出的概率：\n$$ \\mathbb{P}(P_D) = \\text{FPR} \\cdot (1 - p_{\\text{dead}}) + \\text{TPR} \\cdot p_{\\text{dead}} $$\n\n现在，我们可以将此表达式代回贝叶斯定理：\n$$ \\mathbb{P}(L \\mid P_D) = \\frac{\\mathbb{P}(P_D \\mid L) \\mathbb{P}(L)}{\\mathbb{P}(P_D \\mid L) \\mathbb{P}(L) + \\mathbb{P}(P_D \\mid D) \\mathbb{P}(D)} $$\n$$ \\mathbb{P}(L \\mid P_D) = \\frac{\\text{FPR} \\cdot (1 - p_{\\text{dead}})}{\\text{FPR} \\cdot (1 - p_{\\text{dead}}) + \\text{TPR} \\cdot p_{\\text{dead}}} $$\n这是在采取了推测性回收操作的情况下，发生冲突的概率的符号表达式。\n\n### 第2部分：计算期望回滚周期\n\n第二项任务是计算每 $N$ 条已退役指令的期望回滚周期数。设其为 $E[C_N]$。当且仅当对于一条给定指令，满足以下三个条件序列时，才会发生一次代价为 $R$ 个周期的回滚：\n1. 该指令创建了一个推测性回收候选者。\n2. 该候选者对应的旧寄存器值实际上是有效的。\n3. 预测器错误地将此有效值预测为无效。\n\n让我们计算在 $N$ 条指令中此类回滚事件的期望数量。\n总指令数为 $N$。\n创建回收候选者的指令的期望数量是：\n$$ E[N_{\\text{cand}}] = N \\cdot f $$\n在这些候选者中，实际上是有效的期望数量是：\n$$ E[N_{\\text{live}}] = E[N_{\\text{cand}}] \\cdot \\mathbb{P}(L) = N \\cdot f \\cdot (1 - p_{\\text{dead}}) $$\n如果预测器做出假阳性预测（预测为无效），则会为这些有效候选者之一触发一次回滚。此事件的概率是 $\\text{FPR} = \\mathbb{P}(P_D \\mid L)$。\n因此，在 $N$ 条指令中期望的回滚次数是：\n$$ E[N_{\\text{rollback}}] = E[N_{\\text{live}}] \\cdot \\text{FPR} = N \\cdot f \\cdot (1 - p_{\\text{dead}}) \\cdot \\text{FPR} $$\n每次回滚产生 $R$ 个周期的代价。在 $N$ 条指令中，总的期望回滚代价是期望回滚次数乘以每次回滚的代价：\n$$ E[C_N] = E[N_{\\text{rollback}}] \\cdot R = N \\cdot f \\cdot (1 - p_{\\text{dead}}) \\cdot \\text{FPR} \\cdot R $$\n\n现在，我们将给定的数值代入此表达式：\n- $N = 10^6$\n- $f = 0.55$\n- $p_{\\text{dead}} = 0.65$\n- $\\text{FPR} = 0.06$\n- $R = 18$\n\n$$ E[C_{10^6}] = 10^6 \\cdot 0.55 \\cdot (1 - 0.65) \\cdot 0.06 \\cdot 18 $$\n$$ E[C_{10^6}] = 10^6 \\cdot 0.55 \\cdot 0.35 \\cdot 0.06 \\cdot 18 $$\n让我们计算这些项的乘积：\n$$ 0.55 \\cdot 0.35 = 0.1925 $$\n$$ 0.1925 \\cdot 0.06 = 0.01155 $$\n$$ 0.01155 \\cdot 18 = 0.2079 $$\n因此，总的期望代价是：\n$$ E[C_{10^6}] = 10^6 \\cdot 0.2079 = 207900 $$\n问题要求将答案四舍五入到四位有效数字。数字 $207900$ 可以用科学记数法写成 $2.079 \\times 10^5$，这已经包含了四位有效数字。",
            "answer": "$$\n\\boxed{2.079 \\times 10^5}\n$$"
        }
    ]
}