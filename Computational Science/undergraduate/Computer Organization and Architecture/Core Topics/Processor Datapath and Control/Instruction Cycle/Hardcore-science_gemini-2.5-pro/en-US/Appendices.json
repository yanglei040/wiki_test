{
    "hands_on_practices": [
        {
            "introduction": "This practice connects the abstract concept of the \"decode\" stage to its physical reality in digital logic. You will act as a logic designer, taking a set of instruction opcodes and using Boolean algebra to create a minimal, efficient circuit for a control signal. This exercise is vital for understanding how the efficiency of this combinational logic directly constrains the processor's maximum clock speed, linking high-level architecture to low-level gate delays.",
            "id": "3649528",
            "problem": "You are analyzing the decode stage in the instruction cycle (fetch-decode-execute) of a single-cycle datapath. The Instruction Register (IR) holds a $4$-bit opcode $\\left(i_3,i_2,i_1,i_0\\right)$ that feeds combinational decode logic to generate control signals for the Arithmetic Logic Unit (ALU) and memory interface. The goal is to minimize the Boolean decode for a primary control signal and quantify the resulting improvement in the clock critical path.\n\nFundamental bases for this problem:\n- Boolean algebra (associativity, distributivity, De Morgan’s laws) and canonical forms such as Sum of Products.\n- Combinational logic gate delay composition: propagation delay accumulates along the serial path from a register output through combinational gates to the next register’s input setup, while parallel fan-in does not add serial delay beyond the latest-arriving input to a gate.\n- The maximum clock frequency equals the reciprocal of the longest register-to-register propagation time along the critical path.\n\nAssume the following opcode-to-control mapping for the RegWrite control signal $C_{RW}$, which enables destination register write during execute:\n- $C_{RW}=1$ for opcodes $\\{0001,0010,0100,1000,1001\\}$.\n- $C_{RW}=0$ otherwise.\n\nUse Boolean minimization to derive a minimal Sum of Products expression for $C_{RW}$ in terms of the IR bits $\\left(i_3,i_2,i_1,i_0\\right)$, starting from first principles in Boolean algebra. Then, implement the minimized expression using AND-OR logic with input inversions for complemented literals. Assume the following realistic gate delays:\n- Inverter delay $t_{\\mathrm{INV}}=0.03~\\mathrm{ns}$.\n- Three-input AND delay $t_{\\mathrm{AND3}}=0.07~\\mathrm{ns}$.\n- Four-input AND delay $t_{\\mathrm{AND4}}=0.09~\\mathrm{ns}$.\n- Four-input OR delay $t_{\\mathrm{OR4}}=0.09~\\mathrm{ns}$.\n\nThe decode output $C_{RW}$ drives a $4$-to-$1$ ALU operation Multiplexer (MUX) with delay $t_{\\mathrm{MUX4}}=0.12~\\mathrm{ns}$, then the ALU with delay $t_{\\mathrm{ALU}}=0.41~\\mathrm{ns}$, and finally the destination register, which has setup time $t_{\\mathrm{setup}}=0.07~\\mathrm{ns}$. The Instruction Register has clock-to-$Q$ delay $t_{CQ}=0.08~\\mathrm{ns}$.\n\nFor context, the pre-minimization implementation used a $16$-line decoder with delay $t_{\\mathrm{DEC16}}=0.25~\\mathrm{ns}$ followed by a $5$-input OR gate with delay $t_{\\mathrm{OR5}}=0.13~\\mathrm{ns}$ to realize $C_{RW}$ as a sum of minterms; all other downstream delays are unchanged.\n\nTasks:\n1. Starting from the Boolean algebra definition of the Sum of Products form, derive a minimized expression for $C_{RW}$.\n2. Using the provided gate delays, compute the post-minimization register-to-register critical path time dominated by the control path from the IR through the decode, the ALU operation MUX, the ALU, and into the destination register.\n3. From this, compute the new maximum clock frequency. Round your final numeric result to four significant figures and express the frequency in $\\mathrm{MHz}$.\n\nYour final answer must be a single real-valued number representing the maximum clock frequency after minimization, with the unit implied by the problem statement instructions.",
            "solution": "We begin from Boolean algebra fundamentals. Let the opcode bits be $\\left(i_3,i_2,i_1,i_0\\right)$, with each $i_k \\in \\{0,1\\}$, and let the RegWrite control be $C_{RW}$. By definition of Sum of Products, the canonical expression that is $1$ for the specified opcodes is the logical sum of minterms corresponding to those rows in which $C_{RW}=1$.\n\nThe specified set is $\\{0001,0010,0100,1000,1001\\}$. Writing minterms (where a complemented literal denotes $\\neg i_k$ and an uncomplemented literal denotes $i_k$):\n- For $0001$: $\\neg i_3 \\land \\neg i_2 \\land \\neg i_1 \\land i_0$.\n- For $0010$: $\\neg i_3 \\land \\neg i_2 \\land i_1 \\land \\neg i_0$.\n- For $0100$: $\\neg i_3 \\land i_2 \\land \\neg i_1 \\land \\neg i_0$.\n- For $1000$: $i_3 \\land \\neg i_2 \\land \\neg i_1 \\land \\neg i_0$.\n- For $1001$: $i_3 \\land \\neg i_2 \\land \\neg i_1 \\land i_0$.\n\nThe canonical Sum of Products is therefore\n$$\nC_{RW} = (\\neg i_3 \\land \\neg i_2 \\land \\neg i_1 \\land i_0)\\ \\lor\\ (\\neg i_3 \\land \\neg i_2 \\land i_1 \\land \\neg i_0)\\ \\lor\\ (\\neg i_3 \\land i_2 \\land \\neg i_1 \\land \\neg i_0)\\ \\lor\\ (i_3 \\land \\neg i_2 \\land \\neg i_1 \\land \\neg i_0)\\ \\lor\\ (i_3 \\land \\neg i_2 \\land \\neg i_1 \\land i_0).\n$$\n\nWe minimize using adjacency on a Karnaugh map or direct Boolean factoring. Observe that the last two minterms, $1000$ and $1001$, differ only in $i_0$. Grouping them yields the implicant\n$$\ni_3 \\land \\neg i_2 \\land \\neg i_1,\n$$\nwhich covers both $1000$ and $1001$. The remaining three minterms $\\{0001,0010,0100\\}$ are pairwise non-adjacent on the $\\left(i_3,i_2,i_1,i_0\\right)$ map and cannot be combined without including undesired states (there are no specified \"do-not-care\" entries). Hence the minimal Sum of Products is\n$$\nC_{RW} = (i_3 \\land \\neg i_2 \\land \\neg i_1)\\ \\lor\\ (\\neg i_3 \\land \\neg i_2 \\land \\neg i_1 \\land i_0)\\ \\lor\\ (\\neg i_3 \\land \\neg i_2 \\land i_1 \\land \\neg i_0)\\ \\lor\\ (\\neg i_3 \\land i_2 \\land \\neg i_1 \\land \\neg i_0).\n$$\n\nWe now implement $C_{RW}$ using AND-OR logic with input inversions for complemented literals. The four product terms consist of one three-input AND and three four-input ANDs feeding a four-input OR. Given propagation delay composition for combinational gates, the decode path delay is governed by the latest-arriving input to the OR gate, which originates from the slowest product term. For each product term, the slowest arrival at its AND input occurs on a complemented literal path due to the inverter; the direct literals are faster. Therefore, the worst-case decode path time is\n$$\nt_{\\mathrm{decode}} = t_{\\mathrm{INV}} + t_{\\mathrm{AND4}} + t_{\\mathrm{OR4}}.\n$$\nWe choose the four-input term as the worst case because $t_{\\mathrm{AND4}} > t_{\\mathrm{AND3}}$.\n\nSubstituting the given values:\n$$\nt_{\\mathrm{decode}} = 0.03\\ \\mathrm{ns} + 0.09\\ \\mathrm{ns} + 0.09\\ \\mathrm{ns} = 0.21\\ \\mathrm{ns}.\n$$\n\nThe full register-to-register critical path along the control-to-execute path includes the Instruction Register clock-to-$Q$ delay, the decode network, the ALU operation Multiplexer delay, the ALU delay, and the destination register setup time:\n$$\nt_{\\mathrm{path}} = t_{CQ} + t_{\\mathrm{decode}} + t_{\\mathrm{MUX4}} + t_{\\mathrm{ALU}} + t_{\\mathrm{setup}}.\n$$\nSubstituting numeric values:\n$$\nt_{\\mathrm{path}} = 0.08\\ \\mathrm{ns} + 0.21\\ \\mathrm{ns} + 0.12\\ \\mathrm{ns} + 0.41\\ \\mathrm{ns} + 0.07\\ \\mathrm{ns} = 0.89\\ \\mathrm{ns}.\n$$\n\nThe maximum clock frequency is the reciprocal of the critical path time. Converting to $\\mathrm{MHz}$ using $1\\ \\mathrm{ns}^{-1} = 10^3\\ \\mathrm{MHz}$:\n$$\nf_{\\max} = \\frac{10^3}{t_{\\mathrm{path}}\\ \\mathrm{(ns)}} = \\frac{10^3}{0.89} \\ \\mathrm{MHz} \\approx 1123.5955056179776\\ \\mathrm{MHz}.\n$$\nRounded to four significant figures, this is\n$$\n1124\\ \\mathrm{MHz}.\n$$\n\nFor discussion of clock critical path reduction: the pre-minimization decode used a $16$-line decoder and a $5$-input OR, yielding\n$$\nt_{\\mathrm{decode,pre}} = t_{\\mathrm{DEC16}} + t_{\\mathrm{OR5}} = 0.25\\ \\mathrm{ns} + 0.13\\ \\mathrm{ns} = 0.38\\ \\mathrm{ns},\n$$\nand thus\n$$\nt_{\\mathrm{path,pre}} = 0.08\\ \\mathrm{ns} + 0.38\\ \\mathrm{ns} + 0.12\\ \\mathrm{ns} + 0.41\\ \\mathrm{ns} + 0.07\\ \\mathrm{ns} = 1.06\\ \\mathrm{ns},\n$$\nwith\n$$\nf_{\\max,\\mathrm{pre}} = \\frac{10^3}{1.06} \\ \\mathrm{MHz} \\approx 943.396226\\ \\mathrm{MHz}.\n$$\nMinimization reduces the decode fan-in and gate depth, lowering the decode contribution from $0.38\\ \\mathrm{ns}$ to $0.21\\ \\mathrm{ns}$, and improving $f_{\\max}$ from approximately $943.4\\ \\mathrm{MHz}$ to approximately $1124\\ \\mathrm{MHz}$. The final requested numeric result is the post-minimization maximum clock frequency.",
            "answer": "$$\\boxed{1124}$$"
        },
        {
            "introduction": "Pipelining is the heart of modern processor performance, but its complexities can only be truly grasped by seeing it in action. This exercise asks you to perform a manual, cycle-by-cycle simulation of a short program running on a classic five-stage pipeline. By tracking the state of registers and pipeline stages, you will gain an intuitive understanding of data forwarding, load-use hazards, and the control penalties from branch instructions.",
            "id": "3649602",
            "problem": "A toy Reduced Instruction Set Computer (RISC) uses a classic five-stage instruction pipeline implementing the fetch-decode-execute paradigm with stages: Instruction Fetch (IF), Instruction Decode/Register Read (ID), Execute/Address Calculation (EX), Memory Access (MEM), and Register Write-Back (WB). The processor has the following properties and rules:\n\n- The Program Counter (PC) holds a byte address and increments by $4$ on sequential fetch.\n- The Instruction Register (IR) refers to the instruction latched at the ID stage in a given cycle.\n- The register file has $32$ integer registers. Register $R0$ is hardwired to $0$.\n- One instruction issues per cycle when not stalled.\n- Forwarding is available from EX/MEM and MEM/WB pipeline registers to the EX stage inputs, eliminating all arithmetic data hazards except the load-use hazard.\n- A load-use hazard occurs when an instruction in ID needs a register that is the destination of a load currently in EX or MEM; in this case, the hazard unit inserts exactly one bubble (a no-operation in EX) and stalls IF and ID for one cycle. After the stall, forwarding supplies the needed value.\n- Branches are resolved in the EX stage. There is no branch prediction; the pipeline always fetches the fall-through path. On a taken branch, the instructions in IF and ID at the moment of branch resolution are flushed (converted to bubbles), and the PC is redirected to the target starting in the next cycle. The branch itself does not write a register.\n- The instruction memory and data memory each respond in one cycle; there are no cache misses.\n- All arithmetic and logical operations complete in the EX stage with a single-cycle latency.\n\nThe instruction set includes the following operations with their semantics:\n- Load Word: $\\text{LW } R_d, \\text{offset}(R_s)$ loads the $32$-bit word from memory at address $R[R_s] + \\text{offset}$ into register $R_d$ in WB.\n- Add: $\\text{ADD } R_d, R_s, R_t$ writes $R_d \\leftarrow R[R_s] + R[R_t]$ in WB.\n- Subtract: $\\text{SUB } R_d, R_s, R_t$ writes $R_d \\leftarrow R[R_s] - R[R_t]$ in WB.\n- Bitwise Or: $\\text{OR } R_d, R_s, R_t$ writes $R_d \\leftarrow R[R_s] \\,|\\, R[R_t]$ in WB.\n- Branch if Equal: $\\text{BEQ } R_s, R_t, \\text{imm}$ compares $R[R_s]$ and $R[R_t]$; if equal, the next PC becomes $\\text{PC} + 4 + 4 \\times \\text{imm}$; otherwise, it remains $\\text{PC} + 4$.\n\nConsider the following program beginning at byte address $\\text{PC} = 0$ (each instruction is $4$ bytes):\n- At address $0$: $\\text{LW } R1, 0(R0)$\n- At address $4$: $\\text{ADD } R2, R1, R0$\n- At address $8$: $\\text{SUB } R3, R2, R1$\n- At address $12$: $\\text{BEQ } R3, R0, +1$\n- At address $16$: $\\text{ADD } R4, R4, R1$\n- At address $20$: $\\text{OR } R5, R2, R3$\n\nInitial architectural state at cycle $1$ (before any pipeline activity):\n- Registers: $R0 = 0$ (hardwired), $R4 = 7$, and all other general-purpose registers are $0$.\n- Memory: the $32$-bit word at byte address $0$ equals $5$; other memory locations are irrelevant.\n\nTask:\n- Manually step through the program cycle by cycle under the five-stage pipeline with the rules above. For each cycle, log:\n  - The PC value used in IF for that cycle, as a byte address.\n  - The IR content in ID for that cycle (write the mnemonic and operands of the instruction in ID, or indicate a bubble if none).\n  - The architectural register state after WB in that cycle for the registers $R1$, $R2$, $R3$, $R4$, $R5$.\n- Explain precisely where and why any stalls or flushes occur, referring to the fetch-decode-execute flow and the hazard rules.\n\nAnswer specification:\n- After completing the manual step-through and explanations, report the total number of cycles elapsed from the first fetch (cycle $1$) through and including the cycle in which the last committed instruction of the program completes its WB stage. Provide only this total as your final numeric answer. No rounding is needed. Do not include any units in your final numeric answer.",
            "solution": "We begin from the definitions of the instruction cycle and the five-stage pipeline rules: each instruction progresses through IF, ID (where the Instruction Register holds the current instruction), EX (where arithmetic or address computation and branch condition evaluation occur), MEM (for loads and stores), and WB (where register writes occur). With full forwarding except for the load-use hazard, arithmetic dependencies are resolved without stalls, but a use of a load result by the immediately following instruction requires exactly one stall. Branches are resolved in EX with no prediction; if taken, the instructions in IF and ID at that moment are flushed, incurring a two-instruction penalty.\n\nWe label the instructions for reference:\n- $I_1$: $\\text{LW } R1, 0(R0)$ at address $0$.\n- $I_2$: $\\text{ADD } R2, R1, R0$ at address $4$.\n- $I_3$: $\\text{SUB } R3, R2, R1$ at address $8$.\n- $I_4$: $\\text{BEQ } R3, R0, +1$ at address $12$.\n- $I_5$: $\\text{ADD } R4, R4, R1$ at address $16$.\n- $I_6$: $\\text{OR } R5, R2, R3$ at address $20$.\n\nInitial state before cycle $1$:\n- Registers: $R0 = 0$, $R1 = 0$, $R2 = 0$, $R3 = 0$, $R4 = 7$, $R5 = 0$.\n- Memory: $\\text{Mem}[0] = 5$.\n\nWe simulate cycle by cycle, tracking three items per cycle: PC in IF, IR in ID, and register state after WB.\n\nCycle $1$:\n- IF: fetches $I_1$ at $\\text{PC} = 0$; next sequential PC becomes $4$.\n- ID: empty (pipeline fill).\n- EX/MEM/WB: empty.\n- IR in ID: $\\varnothing$.\n- WB effect: none.\n- Registers after WB: $R1 = 0$, $R2 = 0$, $R3 = 0$, $R4 = 7$, $R5 = 0$.\n\nCycle $2$:\n- IF: fetches $I_2$ at $\\text{PC} = 4$; next PC becomes $8$.\n- ID: $I_1$; reads $R0 = 0$ for address calculation later.\n- EX/MEM/WB: empty.\n- IR in ID: $I_1$ is in ID.\n- WB effect: none.\n- Registers after WB: $R1 = 0$, $R2 = 0$, $R3 = 0$, $R4 = 7$, $R5 = 0$.\n\nCycle $3$:\n- IF: fetches $I_3$ at $\\text{PC} = 8$; next PC becomes $12$.\n- ID: $I_2$; $I_2$ needs $R1$ and $R0$.\n- EX: $I_1$ computes effective address $R[R0] + 0 = 0$.\n- MEM/WB: empty.\n- IR in ID: $I_2$.\n- WB effect: none.\n- Registers after WB: $R1 = 0$, $R2 = 0$, $R3 = 0$, $R4 = 7$, $R5 = 0$.\n\nCycle $4$:\n- Hazard analysis: $I_2$ in ID needs $R1$ which is the destination of $I_1$ (a load) currently in MEM this cycle. This is a classic load-use hazard. By rule, one bubble is inserted in EX and IF/ID are stalled for one cycle.\n- IF: stalled; PC remains $\\text{PC} = 8$ and the fetched $I_3$ is held.\n- ID: $I_2$ remains in ID (stalled).\n- EX: bubble (no instruction).\n- MEM: $I_1$ performs the memory read from address $0$.\n- WB: empty.\n- IR in ID: $I_2$ (stalled).\n- WB effect: none.\n- Registers after WB: $R1 = 0$, $R2 = 0$, $R3 = 0$, $R4 = 7$, $R5 = 0$.\n- Explanation of stall: The load result from $I_1$ is not available for $I_2$’s EX stage in this cycle; forwarding cannot supply it until after MEM completes. The pipeline therefore holds $I_2$ in ID and inserts a bubble in EX.\n\nCycle $5$:\n- IF: fetches $I_4$ at $\\text{PC} = 12$ (the previously held $I_3$ advances to ID).\n- ID: $I_3$; reads $R2$ and $R1$.\n- EX: $I_2$ executes using forwarded $R1 = 5$ (available after the load completes MEM in cycle $4$ and is written in WB in this cycle or forwarded via MEM/WB), and $R0 = 0$; computes $R2 = 5 + 0 = 5$.\n- MEM: empty for $I_2$ (ALU instruction passes through).\n- WB: $I_1$ writes back $R1 \\leftarrow \\text{Mem}[0] = 5$.\n- IR in ID: $I_3$.\n- WB effect: $R1 \\leftarrow 5$.\n- Registers after WB: $R1 = 5$, $R2 = 0$, $R3 = 0$, $R4 = 7$, $R5 = 0$.\n\nCycle $6$:\n- IF: fetches $I_5$ at $\\text{PC} = 16$.\n- ID: $I_4$.\n- EX: $I_3$ executes with operands $R2$ and $R1$. With forwarding, $R2 = 5$ is forwarded from $I_2$’s EX/MEM pipeline register (computed in cycle $5$), and $R1 = 5$ is already in the register file from $I_1$’s WB in cycle $5$. Computes $R3 = 5 - 5 = 0$.\n- MEM: $I_2$ in MEM (ALU op passes through).\n- WB: empty.\n- IR in ID: $I_4$.\n- WB effect: none in this cycle.\n- Registers after WB: $R1 = 5$, $R2 = 0$, $R3 = 0$, $R4 = 7$, $R5 = 0$.\n\nCycle $7$:\n- IF: fetches $I_6$ at $\\text{PC} = 20$.\n- ID: $I_5$ (this instruction will be subject to branch control hazard).\n- EX: $I_4$ evaluates branch condition. It needs $R3$ and $R0$; $R3 = 0$ is forwarded from $I_3$’s EX/MEM register (computed in cycle $6$), and $R0 = 0$. Condition is equal, so the branch is taken; branch target is $\\text{PC}_{I_4} + 4 + 4 \\times 1 = 12 + 4 + 4 = 20$.\n- MEM: $I_3$ in MEM (ALU op passes).\n- WB: $I_2$ writes back $R2 \\leftarrow 5$.\n- IR in ID: $I_5$.\n- WB effect: $R2 \\leftarrow 5$.\n- Registers after WB: $R1 = 5$, $R2 = 5$, $R3 = 0$, $R4 = 7$, $R5 = 0$.\n- Explanation of branch flush: Because the branch resolves as taken in EX, the instructions currently in IF ($I_6$ at address $20$) and ID ($I_5$ at address $16$) are on the mis-speculated fall-through path. Both are flushed at the end of this cycle, incurring a two-instruction control hazard penalty. The PC is redirected to $20$ for the next cycle’s fetch.\n\nCycle $8$:\n- IF: fetches from the branch target $\\text{PC} = 20$, i.e., $I_6$.\n- ID: bubble (flushed $I_5$).\n- EX: bubble (the flushed bubble from ID advances).\n- MEM: $I_4$ in MEM (branch occupies stages but writes no register).\n- WB: $I_3$ writes back $R3 \\leftarrow 0$.\n- IR in ID: $\\varnothing$ (bubble).\n- WB effect: $R3 \\leftarrow 0$ (no change in value but architectural write occurs).\n- Registers after WB: $R1 = 5$, $R2 = 5$, $R3 = 0$, $R4 = 7$, $R5 = 0$.\n\nCycle $9$:\n- IF: fetches next sequential $\\text{PC} = 24$ (content irrelevant; the program’s last committed instruction is $I_6$).\n- ID: $I_6$.\n- EX: bubble.\n- MEM: bubble.\n- WB: $I_4$ (branch) in WB does not write.\n- IR in ID: $I_6$.\n- WB effect: none.\n- Registers after WB: $R1 = 5$, $R2 = 5$, $R3 = 0$, $R4 = 7$, $R5 = 0$.\n\nCycle $10$:\n- IF: fetches $\\text{PC} = 28$ (irrelevant).\n- ID: bubble (as $I_6$ moves to EX).\n- EX: $I_6$ executes: computes $R5 = R2 \\,|\\, R3 = 5 \\,|\\, 0 = 5$.\n- MEM: bubble.\n- WB: bubble.\n- IR in ID: $\\varnothing$ (bubble).\n- WB effect: none.\n- Registers after WB: $R1 = 5$, $R2 = 5$, $R3 = 0$, $R4 = 7$, $R5 = 0$.\n\nCycle $11$:\n- IF: fetches $\\text{PC} = 32$ (irrelevant).\n- ID: bubble.\n- EX: bubble.\n- MEM: $I_6$.\n- WB: bubble.\n- IR in ID: $\\varnothing$.\n- WB effect: none.\n- Registers after WB: $R1 = 5$, $R2 = 5$, $R3 = 0$, $R4 = 7$, $R5 = 0$.\n\nCycle $12$:\n- IF: fetches $\\text{PC} = 36$ (irrelevant).\n- ID: bubble.\n- EX: bubble.\n- MEM: bubble.\n- WB: $I_6$ writes back $R5 \\leftarrow 5$.\n- IR in ID: $\\varnothing$.\n- WB effect: $R5 \\leftarrow 5$.\n- Registers after WB: $R1 = 5$, $R2 = 5$, $R3 = 0$, $R4 = 7$, $R5 = 5$.\n\nStalls and flushes explained:\n- The single load-use stall occurs in cycle $4$ because $I_2$ depends on the result of $I_1$ and the loaded data is not available for EX until after $I_1$ completes MEM. The hazard unit inserts one bubble in EX and holds IF/ID, as reflected by the repeated $\\text{PC} = 8$ and $I_2$ remaining in ID in cycle $4$.\n- The taken branch in $I_4$ is resolved in EX in cycle $7$, flushing the instructions in IF and ID ($I_6$ and $I_5$) and redirecting the PC to the target ($20$). This creates two bubbles that appear in ID and EX in cycle $8$, and the pipeline refetches $I_6$ from the correct target.\n\nFinal committed instruction and total cycles:\n- The last committed instruction is $I_6$ at address $20$, which completes its WB stage in cycle $12$.\n- Counting from the initial fetch in cycle $1$ through the completion of WB for $I_6$, the total number of cycles is $12$.\n\nTherefore, the required total cycle count is $12$.",
            "answer": "$$\\boxed{12}$$"
        },
        {
            "introduction": "While simulating a few instructions provides deep insight, architects must evaluate performance over millions of instructions. This practice moves from the micro-level view of individual stalls to a macro-level statistical analysis of pipeline efficiency using the Cycles Per Instruction ($CPI$) metric. You will learn to quantify the performance impact of structural, data, and control hazards, deriving the overall $CPI$ from a given workload's characteristics.",
            "id": "3649545",
            "problem": "A single-issue, five-stage pipeline implements the instruction cycle with instruction fetch, decode, execute, memory access, and register writeback. In the absence of hazards and resource conflicts, the machine sustains an ideal throughput of one instruction per cycle. A stall cycle is defined as a cycle in which no new instruction begins fetch, so the Program Counter (PC) remains unchanged; the PC increments by $4$ bytes only when an instruction fetch starts.\n\nConsider a workload of $N=200{,}000$ dynamic instructions with the following statistically steady composition and behavior:\n- The fraction of memory-accessing instructions is $f_{\\text{mem}}$, consisting of loads with fraction $f_{\\text{ld}}=0.25$ and stores with fraction $f_{\\text{st}}=0.10$; assume a unified, single-ported memory that cannot serve an instruction fetch and a data access in the same cycle, so when a load or store reaches the memory stage the processor must insert a single stall cycle to avoid conflict.\n- The fraction of immediately dependent instruction pairs (where the next instruction consumes a value produced by the previous instruction) is $p_{\\text{dep}}=0.20$. Among these dependent pairs, the fraction that are load-use pairs is $p_{\\text{lu}}=0.50$. Due to latency beyond what forwarding can hide, a fraction $p_{\\text{unres}}=0.80$ of these load-use pairs require insertion of $2$ stall cycles to satisfy the data dependency.\n- The fraction of branch instructions is $f_{\\text{br}}=0.20$. The branch predictor exhibits a misprediction probability $p_{\\text{misp}}=0.10$, and each misprediction triggers a pipeline flush that costs $3$ stall cycles before the correct next PC is fetched.\n\nUsing the core definitions that Cycles Per Instruction (CPI) is the average number of cycles per retired instruction and that each stall adds cycles in which the PC does not advance, derive from first principles the expected average stall cycles per instruction contributed by structural, data, and control effects for this workload. Then compute the expected total number of cycles needed to retire all $N$ instructions.\n\nProvide your final answer as a single real number representing the expected total cycles. No rounding is required.",
            "solution": "The problem is validated as scientifically grounded, well-posed, and objective. It is a standard problem in computer architecture concerning pipeline performance analysis. All data and conditions provided are sufficient and consistent for deriving a unique solution.\n\nThe total number of cycles, $C$, required to execute a program is the product of the number of dynamic instructions, $N$, and the average Cycles Per Instruction, $CPI$.\n$$C = N \\times CPI$$\nThe $CPI$ can be decomposed into an ideal component and a stall component. For a single-issue pipeline without hazards, one instruction completes per cycle, making the ideal $CPI$ equal to $1$. Any deviation from this ideal performance is due to stall cycles introduced by various hazards.\n$$CPI = CPI_{\\text{ideal}} + CPI_{\\text{stall}}$$\nwhere $CPI_{\\text{ideal}} = 1$. The term $CPI_{\\text{stall}}$ represents the average number of stall cycles incurred per instruction. This can be calculated by summing the contributions from all sources of stalls. The problem describes three types of hazards: structural, data, and control. Let $S_{\\text{struct}}$, $S_{\\text{data}}$, and $S_{\\text{control}}$ be the average stall cycles per instruction contributed by each type of hazard, respectively.\n$$CPI_{\\text{stall}} = S_{\\text{struct}} + S_{\\text{data}} + S_{\\text{control}}$$\nOur primary task is to derive these three components from first principles based on the provided workload characteristics.\n\n**1. Structural Hazard Stalls ($S_{\\text{struct}}$)**\n\nThe structural hazard arises from the single-ported memory, which cannot service an instruction fetch and a data access (load or store) in the same cycle. When an instruction performing a memory access reaches the memory (MEM) stage of the $5$-stage pipeline, a stall must be inserted to prevent conflict with the fetch of a subsequent instruction.\nThe frequency of this event is determined by the fraction of instructions that perform a memory access. These are the load and store instructions.\n- Fraction of load instructions: $f_{\\text{ld}} = 0.25$\n- Fraction of store instructions: $f_{\\text{st}} = 0.10$\nThe total fraction of memory-accessing instructions is $f_{\\text{mem}} = f_{\\text{ld}} + f_{\\text{st}}$.\nEach occurrence of this hazard costs $1$ stall cycle.\nThe average number of stall cycles per instruction due to this structural hazard is the product of the frequency of memory-access instructions and the stall cost per occurrence.\n$$S_{\\text{struct}} = (f_{\\text{ld}} + f_{\\text{st}}) \\times 1 = (0.25 + 0.10) \\times 1 = 0.35$$\n\n**2. Data Hazard Stalls ($S_{\\text{data}}$)**\n\nData hazards cause stalls when a dependency cannot be resolved by the pipeline's forwarding logic in time. The problem specifies a cascade of conditions for a data hazard stall to occur.\n- The fraction of instruction pairs that are immediately dependent is $p_{\\text{dep}} = 0.20$. This means the probability that an instruction depends on the result of the immediately preceding instruction is $0.20$.\n- Among these dependent pairs, the fraction that are load-use pairs (where the consumer instruction uses a value loaded from memory by the producer instruction) is $p_{\\text{lu}} = 0.50$.\n- Among these load-use pairs, a fraction $p_{\\text{unres}} = 0.80$ cannot be resolved by forwarding and require stalls.\nThe probability that any given instruction will trigger a data hazard stall is the product of these probabilities, as they form a sequence of conditional events. Let this probability be $P(\\text{data stall})$.\n$$P(\\text{data stall}) = p_{\\text{dep}} \\times p_{\\text{lu}} \\times p_{\\text{unres}}$$\nEach occurrence of such an unresolved load-use dependency costs $2$ stall cycles.\nThe average number of stall cycles per instruction due to data hazards is the product of the probability of the event and its cost.\n$$S_{\\text{data}} = P(\\text{data stall}) \\times 2 = (p_{\\text{dep}} \\times p_{\\text{lu}} \\times p_{\\text{unres}}) \\times 2$$\nSubstituting the given values:\n$$S_{\\text{data}} = (0.20 \\times 0.50 \\times 0.80) \\times 2 = (0.10 \\times 0.80) \\times 2 = 0.08 \\times 2 = 0.16$$\n\n**3. Control Hazard Stalls ($S_{\\text{control}}$)**\n\nControl hazards arise from branch mispredictions. When a branch is mispredicted, the instructions that were speculatively fetched from the wrong path must be flushed from the pipeline, and the pipeline must be refilled from the correct target address. This process incurs stall cycles.\n- The fraction of all instructions that are branches is $f_{\\text{br}} = 0.20$.\n- The probability that a branch is mispredicted is $p_{\\text{misp}} = 0.10$.\nThe probability that any given instruction is a mispredicted branch is the product of the fraction of branches and the misprediction probability. Let this be $P(\\text{control stall})$.\n$$P(\\text{control stall}) = f_{\\text{br}} \\times p_{\\text{misp}}$$\nEach misprediction costs $3$ stall cycles.\nThe average number of stall cycles per instruction due to control hazards is the product of the probability of a mispredicted branch and the associated penalty.\n$$S_{\\text{control}} = P(\\text{control stall}) \\times 3 = (f_{\\text{br}} \\times p_{\\text{misp}}) \\times 3$$\nSubstituting the given values:\n$$S_{\\text{control}} = (0.20 \\times 0.10) \\times 3 = 0.02 \\times 3 = 0.06$$\n\n**4. Total Cycles Calculation**\n\nNow we can compute the total $CPI_{\\text{stall}}$ by summing the contributions from each hazard type.\n$$CPI_{\\text{stall}} = S_{\\text{struct}} + S_{\\text{data}} + S_{\\text{control}} = 0.35 + 0.16 + 0.06 = 0.57$$\nThe total CPI for the processor on this workload is:\n$$CPI = CPI_{\\text{ideal}} + CPI_{\\text{stall}} = 1 + 0.57 = 1.57$$\nFinally, we can calculate the expected total number of cycles, $C$, to execute the entire workload of $N = 200,000$ instructions.\n$$C = N \\times CPI = 200,000 \\times 1.57$$\n$$C = 314,000$$\nThus, the expected total number of cycles to retire all $N$ instructions is $314,000$.",
            "answer": "$$\\boxed{314000}$$"
        }
    ]
}