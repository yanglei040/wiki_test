{
    "hands_on_practices": [
        {
            "introduction": "To begin, it's essential to understand how a barrel shifter operates at the fundamental level of bits and logic gates. This first practice invites you to trace the data flow through a simple 4-bit logical right shifter, which is constructed from multiplexers. By manually determining the output for a given input and shift amount, you will build a concrete intuition for how control signals direct the movement of data within the circuit .",
            "id": "1908624",
            "problem": "A 4-bit logical right barrel shifter is a combinational logic circuit that shifts a 4-bit input word to the right by a specified number of bit positions. The number of positions to shift is determined by a 2-bit control input.\n\nThe shifter takes a 4-bit data input word, $A = A_3A_2A_1A_0$, where $A_3$ is the most significant bit (MSB). It also takes a 2-bit control word, $S = S_1S_0$. The unsigned binary integer value of $S$ dictates the shift amount, which can be 0, 1, 2, or 3 positions. The circuit produces a 4-bit output word, $Y = Y_3Y_2Y_1Y_0$.\n\nThis particular shifter performs a \"logical\" right shift, meaning that as bits are shifted to the right, zeros are filled in from the MSB side. Any bits shifted out from the least significant bit (LSB) side are discarded.\n\nThe circuit is implemented using four 4-to-1 multiplexers (MUX), one for each output bit $Y_i$. A 4-to-1 MUX has four data inputs, denoted $I_0, I_1, I_2, I_3$, and two select lines. The output of the MUX is equal to the data input $I_k$, where $k$ is the unsigned integer value represented by the two select lines. In this barrel shifter design, the control bits $S_1$ and $S_0$ are connected to the select lines of all four multiplexers.\n\nGiven an input data word $A = 1011_2$ and a control word $S = 10_2$, determine the resulting 4-bit output word $Y$. Express your answer as a 4-digit binary string (e.g., 1010).",
            "solution": "A logical right shift by $k$ positions maps each output bit as\n$$\nY_{i}=\\begin{cases}\nA_{i+k}, & i+k\\leq 3,\\\\\n0, & i+k>3.\n\\end{cases}\n$$\nThe control word is $S=10_{2}$, so the shift amount is $k=2$. The input is $A=A_{3}A_{2}A_{1}A_{0}=1011$, hence $A_{3}=1$, $A_{2}=0$, $A_{1}=1$, $A_{0}=1$.\n\nEvaluate each output bit:\n- For $i=3$: $3+2>3$, so $Y_{3}=0$.\n- For $i=2$: $2+2>3$, so $Y_{2}=0$.\n- For $i=1$: $1+2=3\\leq 3$, so $Y_{1}=A_{3}=1$.\n- For $i=0$: $0+2=2\\leq 3$, so $Y_{0}=A_{2}=0$.\n\nThus the output word is $Y=0010$.\n\nEquivalently via the 4-to-1 MUX view: with $S=10_{2}$ each MUX selects its $I_{2}$ input, and for $Y_{i}$ this input is $A_{i+2}$ when $i+2\\leq 3$, else $0$, yielding the same result $0010$.",
            "answer": "$$\\boxed{0010}$$"
        },
        {
            "introduction": "After grasping the gate-level concept, the next step is to describe this behavior in a way that can be synthesized into actual hardware. This exercise challenges you to implement a 16-bit logical left shifter using VHDL, a standard hardware description language. You will need to select the correct code that not only performs the shift operation accurately but also adheres to the principles of designing purely combinational logic .",
            "id": "1976122",
            "problem": "You are tasked with designing a digital circuit using Very High-Speed Integrated Circuit Hardware Description Language (VHDL). The circuit must function as a 16-bit logical left barrel shifter.\n\nThe entity for this circuit is defined as follows:\n```vhdl\nentity barrel_shifter is\n  port (\n    data_in   : in  std_logic_vector(15 downto 0);\n    shift_amt : in  std_logic_vector(3 downto 0);\n    data_out  : out std_logic_vector(15 downto 0)\n  );\nend entity barrel_shifter;\n```\nThe circuit's behavior must adhere to these specifications:\n1.  The 16-bit output `data_out` should be the result of a logical left shift operation on the 16-bit input `data_in`.\n2.  The number of positions to shift is determined by the 4-bit input `shift_amt`, which can represent an integer value from 0 to 15.\n3.  In a logical left shift, the bits shifted out from the most significant bit (MSB) position are discarded, and the least significant bit (LSB) positions are filled with '0's.\n4.  The implementation must be purely combinational, realized within a single VHDL process.\n5.  The core logic within the process must use a `CASE` statement that switches based on the value of `shift_amt`.\n\nThe standard VHDL libraries `ieee.std_logic_1164.all` and `ieee.numeric_std.all` are assumed to be included.\n\nWhich of the following VHDL architectures correctly implements the specified 16-bit logical left barrel shifter?\n\nA.\n```vhdl\narchitecture Behavioral_A of barrel_shifter is\nbegin\n  process(data_in)\n  begin\n    case to_integer(unsigned(shift_amt)) is\n      when 0      => data_out <= data_in;\n      when 1      => data_out <= data_in(14 downto 0) & '0';\n      when 2      => data_out <= data_in(13 downto 0) & \"00\";\n      -- ... cases for 3 through 14 ...\n      when 15     => data_out <= data_in(0) & \"000000000000000\";\n      when others => data_out <= (others => 'X');\n    end case;\n  end process;\nend architecture Behavioral_A;\n```\n\nB.\n```vhdl\narchitecture Behavioral_B of barrel_shifter is\nbegin\n  process(data_in, shift_amt)\n  begin\n    case to_integer(unsigned(shift_amt)) is\n      when 0      => data_out <= data_in;\n      when 1      => data_out <= data_in(15 downto 1) & '0';\n      when 2      => data_out <= data_in(15 downto 2) & \"00\";\n      -- ... cases for 3 through 14 ...\n      when 15     => data_out <= data_in(15) & \"000000000000000\";\n      when others => data_out <= (others => 'X');\n    end case;\n  end process;\nend architecture Behavioral_B;\n```\n\nC.\n```vhdl\narchitecture Behavioral_C of barrel_shifter is\nbegin\n  process(data_in, shift_amt)\n  begin\n    case to_integer(unsigned(shift_amt)) is\n      when 0      => data_out <= data_in;\n      when 1      => data_out <= data_in(14 downto 0) & '0';\n      when 2      => data_out <= data_in(13 downto 0) & \"00\";\n      -- ... cases for 3 through 14 ...\n      when 15     => data_out <= data_in(0) & \"000000000000000\";\n      when others => data_out <= (others => 'X');\n    end case;\n  end process;\nend architecture Behavioral_C;\n```\n\nD.\n```vhdl\narchitecture Behavioral_D of barrel_shifter is\nbegin\n  process(data_in, shift_amt)\n    variable temp_data : std_logic_vector(15 downto 0);\n  begin\n    temp_data := data_in;\n    for i in 0 to to_integer(unsigned(shift_amt)) - 1 loop\n      temp_data := temp_data(14 downto 0) & '0';\n    end loop;\n    data_out <= temp_data;\n  end process;\nend architecture Behavioral_D;\n```",
            "solution": "We require a 16-bit logical left barrel shifter with the following properties:\n- The output is a logical left shift of the 16-bit input by an amount specified by a 4-bit control that encodes integers from 0 to 15.\n- Logical left shift discards bits shifted out of the MSB and fills the vacated LSB positions with '0'.\n- The implementation must be purely combinational, realized in a single process, and must use a CASE statement on the shift amount.\n\nAnalyze each option against these requirements:\n\n- Option A uses a CASE statement whose shift expressions are consistent with logical left shift, for example, for a shift of 1 it uses data_in(14 downto 0) & '0' and for 15 it uses data_in(0) & 15 zeros, which is correct because a shift by 15 moves bit 0 to the MSB and zeros fill the rest. However, the process sensitivity list includes only data_in and omits shift_amt. This violates the purely combinational requirement because changes in shift_amt would not trigger the process, leading to incorrect behavior in simulation and violating the stated specification for a combinational process.\n\n- Option B includes both data_in and shift_amt in the sensitivity list, satisfying the combinational process requirement. However, its shift operation is incorrect. For example, for a shift of 1 it uses data_in(15 downto 1) & '0', which assigns data_out(15 downto 1) := data_in(15 downto 1) and data_out(0) := '0'. This does not perform a left shift; instead, it simply zeroes the LSB while leaving the upper bits unchanged. The correct left shift by 1 requires data_out(15) := data_in(14), which is not achieved by this slice. Therefore, Option B is functionally incorrect.\n\n- Option C includes both data_in and shift_amt in the sensitivity list, satisfying the combinational process requirement. It uses a CASE statement with correct left-shift concatenations. For a shift of 1, it uses data_in(14 downto 0) & '0'; for a shift of 2, data_in(13 downto 0) & \"00\"; and for a shift of 15, data_in(0) & \"000000000000000\". These match the logical left shift semantics where higher-order bits come from lower-indexed input bits, and lower-order bits are filled with zeros. Thus, Option C correctly implements the required behavior with the mandated CASE statement.\n\n- Option D performs iterative shifting in a for loop using a variable, which is functionally correct for a left shift by any amount between 0 and 15. However, the requirement explicitly mandates that the core logic within the process must use a CASE statement that switches based on shift_amt. Option D does not use a CASE statement; therefore, it does not meet the specified implementation requirement.\n\nConsequently, only Option C satisfies all of the stated specifications.",
            "answer": "$$\\boxed{C}$$"
        },
        {
            "introduction": "Real-world processors require shifters that can perform a variety of operations beyond a simple logical shift. This final practice explores the design principles behind a versatile, or \"universal,\" shifter that can handle rotations and arithmetic shifts. By analyzing the relationships between these operations, you will discover how a single, efficient hardware unit can be cleverly designed to support multiple instruction types, a key aspect of modern computer architecture .",
            "id": "3621848",
            "problem": "An $n$-bit barrel shifter is built as a logarithmic-stage multiplexer network that can perform rotate-right by any amount $k$ with $0 \\leq k  n$. A rotate-right by $k$ maps each output bit position $i$ to the input bit at position $(i + k) \\bmod n$, whereas a rotate-left by $k$ maps each output bit position $i$ to the input bit at position $(i - k) \\bmod n$. The control field presented to the barrel shifter is an encoded shift amount of $\\lceil \\log_2 n \\rceil$ bits. You wish to support rotate-left using the existing rotate-right hardware by transforming the requested amount $k$ into $k' = (n - k) \\bmod n$, and also to determine whether arithmetic right shifts can be realized by reusing the same network. Arithmetic Shift Right (ASR) is defined as a right shift that fills vacated most significant bit positions with the original sign bit (the most significant bit of the input), while Logical Shift Right (LSR) fills vacated positions with zeros. Consider the following statements about control encoding and hardware reuse.\n\nWhich statements are correct?\n\nA. For all $n$ and all $k$ with $0 \\leq k  n$, rotate-left by $k$ is equivalent to rotate-right by $k' = (n - k) \\bmod n$, because the index mapping $i \\mapsto (i - k) \\bmod n$ equals $i \\mapsto (i + k') \\bmod n$.\n\nB. To support both rotate-left and rotate-right using the same rotate-right hardware, the control field must be widened from $\\lceil \\log_2 n \\rceil$ bits to $\\lceil \\log_2 n \\rceil + 1$ bits to encode direction; there is no alternative that avoids adding any control bits.\n\nC. A rotate-only barrel shifter that is a pure permutation network cannot realize Arithmetic Shift Right (ASR) by simply reinterpreting rotation control, because ASR requires inserting copies of the sign bit into multiple vacated positions, which is not a permutation of the input bits.\n\nD. If the network is augmented with an additional selectable source that replicates the sign bit onto $n$ lines and a mode control that chooses between wrap-around (for rotate), zero-fill (for logical shifts), and sign-fill (for ASR), the same multiplexer stage structure can implement rotate-right, rotate-left, Logical Shift Right (LSR), and Arithmetic Shift Right (ASR) without changing the number of stages.\n\nE. In two’s complement arithmetic, Arithmetic Shift Left by $1$ differs from Logical Shift Left by $1$ because it must insert the previous sign bit into the least significant bit; therefore, it requires sign-aware hardware distinct from logical left shift.",
            "solution": "The validity of the problem statement shall be examined first.\n\n### Step 1: Extract Givens\n- The system is an $n$-bit barrel shifter implemented as a logarithmic-stage multiplexer network.\n- It performs rotate-right by an amount $k$, where $0 \\le k  n$.\n- The mapping for rotate-right by $k$ is: output bit $i$ is sourced from input bit $(i + k) \\pmod n$.\n- The mapping for rotate-left by $k$ is: output bit $i$ is sourced from input bit $(i - k) \\pmod n$.\n- The barrel shifter's control field is an encoded shift amount of $\\lceil \\log_2 n \\rceil$ bits.\n- A proposed method to support rotate-left is to use the rotate-right hardware with a transformed amount $k' = (n - k) \\pmod n$.\n- The problem involves analyzing the feasibility of implementing Arithmetic Shift Right (ASR) using the same network.\n- ASR definition: a right shift filling vacated most significant bit positions with the original sign bit.\n- Logical Shift Right (LSR) definition: a right shift filling vacated positions with zeros.\n- The task is to evaluate the correctness of five given statements.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded:** The problem statement is based on standard, well-established concepts in computer organization and architecture, specifically digital logic design for shifters. The definitions of rotation, logical shifts, and arithmetic shifts are standard. The logarithmic multiplexer network is a canonical implementation of a barrel shifter. The use of modulo arithmetic is mathematically correct. The problem is scientifically sound.\n- **Well-Posed:** The problem provides clear definitions and a specific set of statements to evaluate. For each statement, a definite conclusion of correct or incorrect can be derived based on the provided information and fundamental principles of digital design.\n- **Objective:** The language is technical, precise, and free of any subjective or ambiguous terminology.\n\n### Step 3: Verdict and Action\nThe problem statement is valid. It is a well-defined question in the field of computer architecture. I will now proceed with a detailed analysis of each statement.\n\n---\n\n### Analysis of the Statements\n\n**Statement A:** For all $n$ and all $k$ with $0 \\leq k  n$, rotate-left by $k$ is equivalent to rotate-right by $k' = (n - k) \\bmod n$, because the index mapping $i \\mapsto (i - k) \\bmod n$ equals $i \\mapsto (i + k') \\bmod n$.\n\nLet's verify the equivalence of the index mappings.\nThe mapping for a rotate-left by $k$ sends the input bit at index `src` to the output bit at index `dst`, where `src` $= (i - k) \\pmod n$ for an output position $i$.\nThe mapping for a rotate-right by $k'$ sends the input bit at index `src` to the output bit at index `dst`, where `src` $= (i + k') \\pmod n$ for an output position $i$.\nWe are given $k' = (n - k) \\pmod n$.\nSubstituting this into the rotate-right mapping gives the source index as:\n$$ (i + ((n - k) \\pmod n)) \\pmod n $$\nGiven that $0 \\leq k  n$:\n- If $k=0$, then $k' = (n-0) \\pmod n = 0$. The mapping is $(i+0) \\pmod n = i$, which is a no-op, same as rotate-left by $0$.\n- If $0  k  n$, then $0  n-k  n$, so $(n-k) \\pmod n = n-k$. Thus, $k' = n-k$.\nThe source index mapping becomes $(i + n - k) \\pmod n$.\nUsing the property of modular arithmetic that $(a+b) \\pmod n = ((a \\pmod n) + (b \\pmod n)) \\pmod n$, we can simplify:\n$$ ((i - k) + n) \\pmod n $$\nSince adding a multiple of the modulus does not change the result, $(x+n) \\pmod n = x \\pmod n$. Therefore:\n$$ ((i - k) + n) \\pmod n = (i - k) \\pmod n $$\nThis is precisely the index mapping for a rotate-left by $k$. The equivalence holds for all $n$ and $k$ in the specified range.\nThe statement is **Correct**.\n\n**Statement B:** To support both rotate-left and rotate-right using the same rotate-right hardware, the control field must be widened from $\\lceil \\log_2 n \\rceil$ bits to $\\lceil \\log_2 n \\rceil + 1$ bits to encode direction; there is no alternative that avoids adding any control bits.\n\nThis statement makes an absolute claim: \"there is no alternative\". Such claims are often false in engineering because alternative encoding schemes can exist.\nThe number of distinct rotation operations on an $n$-bit word is $n$ (the elements of the cyclic group $Z_n$). The number of control patterns available with a $\\lceil \\log_2 n \\rceil$-bit control field is $N_{ctrl} = 2^{\\lceil \\log_2 n \\rceil}$. By definition of the ceiling function, we have $n \\le N_{ctrl}  2n$.\nIf $n$ is a power of two, say $n=2^m$, then $\\lceil \\log_2 n \\rceil = m$ and $N_{ctrl} = 2^m = n$. In this case, all control patterns are used to specify the $n$ distinct right-rotation amounts ($0$ to $n-1$). To add a user-friendly \"direction\" choice, one would need an external control bit and pre-shifter logic to compute the correct rotate-right amount. The total control information supplied to the shifting unit would be $1+m$ bits.\nHowever, if $n$ is *not* a power of two, then $N_{ctrl}  n$. This means there are $N_{ctrl} - n$ unused or redundant control patterns. For example, if $n=12$, $\\lceil \\log_2 12 \\rceil = 4$, providing $2^4 = 16$ control patterns. The rotate-right operation only requires $12$ of these (for shifts by $0, \\ldots, 11$). The remaining $4$ control patterns ($12, 13, 14, 15$) are unused.\nAn \"alternative\" would be to assign these unused patterns to represent some of the desired left-rotation operations. For example, control code $12$ could be defined to mean \"rotate-left by $1$\". This would be an alternative that avoids adding a control bit to the shifter's interface. While this particular alternative may not be able to cover all $n$ left rotations, its existence is sufficient to falsify the claim that \"there is no alternative\". Thus, the statement is too strong and therefore false.\nThe statement is **Incorrect**.\n\n**Statement C:** A rotate-only barrel shifter that is a pure permutation network cannot realize Arithmetic Shift Right (ASR) by simply reinterpreting rotation control, because ASR requires inserting copies of the sign bit into multiple vacated positions, which is not a permutation of the input bits.\n\nA permutation network is a network where there is a one-to-one mapping between inputs and outputs. For an $n$-bit shifter, each of the $n$ output bits is connected to exactly one of the $n$ input bits, and each input bit is connected to exactly one output bit. A rotation is a cyclic permutation, so a rotate-only shifter is a permutation network.\nArithmetic Shift Right (ASR) by a positive amount $k$ on an input word $I = (I_{n-1}, \\ldots, I_0)$ produces an output $O = (O_{n-1}, \\ldots, O_0)$. The low-order $n-k$ bits are shifted versions of the high-order input bits: $O_i = I_{i+k}$ for $0 \\le i  n-k$. The high-order $k$ bits are filled with copies of the sign bit $I_{n-1}$: $O_i = I_{n-1}$ for $n-k \\le i  n$.\nIf $k  1$, then multiple output bits (e.g., $O_{n-1}$ and $O_{n-2}$) receive their value from the same single input bit ($I_{n-1}$). This is a one-to-many mapping. Concurrently, the low-order $k$ input bits ($I_{k-1}, \\ldots, I_0$) are not connected to any output; they are shifted out. This is a many-to-one and some-to-none mapping, which is fundamentally not a permutation.\nSince the physical structure of a rotate-only shifter implements only permutations, no amount of reinterpreting its control signals can change its structure to perform a non-permutation operation like ASR.\nThe statement is **Correct**.\n\n**Statement D:** If the network is augmented with an additional selectable source that replicates the sign bit onto $n$ lines and a mode control that chooses between wrap-around (for rotate), zero-fill (for logical shifts), and sign-fill (for ASR), the same multiplexer stage structure can implement rotate-right, rotate-left, Logical Shift Right (LSR), and Arithmetic Shift Right (ASR) without changing the number of stages.\n\nThis describes a standard architecture for a universal shifter. A logarithmic barrel shifter consists of $\\lceil \\log_2 n \\rceil$ stages of $n$ 2-to-1 multiplexers. Each stage $j$ performs a conditional shift by $2^j$.\nThe difference between rotation, logical shifts, and arithmetic shifts lies in the source of the \"fill\" bits that enter the word during a shift.\n- Rotation: fill bits are the bits shifted out from the other end (wrap-around).\n- LSR: fill bits are zeros.\n- ASR: fill bits are copies of the sign bit.\nA versatile shifter can be constructed by adding multiplexers at the input of the core shifting network. For each bit line entering the shifter stages, a multiplexer selects the appropriate source based on the operation mode (rotate, LSR, ASR). For a right shifter, this logic primarily affects the inputs to the most significant bits that could be vacated.\nFor example, one common design (a funnel shifter) creates an extended $2n-1$-bit input word. For a right shift, the extended word is $(F_{n-1}, \\ldots, F_1, I_{n-1}, \\ldots, I_0)$, where $F_i$ are the fill bits and $I_i$ are the input data bits. The logarithmic MUX network then simply selects an $n$-bit window from this extended word. The fill bits $F_i$ can be chosen by a mode control: for rotation, they are copies of the high-order bits of $I$; for LSR, they are $0$; for ASR, they are copies of the sign bit $I_{n-1}$.\nIn such a design, the core MUX network that performs the variable-amount shift remains unchanged. Its structure and number of stages ($\\lceil \\log_2 n \\rceil$) are preserved. The new functionality is provided by adding a selectable \"fill generation\" logic block before the main shifter. Rotate-left can be handled by the rotate-right functionality as established in statement A. Therefore, the statement accurately describes a feasible and standard design approach.\nThe statement is **Correct**.\n\n**Statement E:** In two’s complement arithmetic, Arithmetic Shift Left by $1$ differs from Logical Shift Left by $1$ because it must insert the previous sign bit into the least significant bit; therefore, it requires sign-aware hardware distinct from logical left shift.\n\nThis statement provides an incorrect definition for Arithmetic Shift Left (ASL). In the vast majority of computer architectures (including x86, ARM, RISC-V), Arithmetic Shift Left and Logical Shift Left are identical operations. Both shift all bits to the left by the specified amount and fill the vacated least significant bit(s) with zero(s).\nFor a two's complement number, this operation is equivalent to multiplication by $2$. Let a number be $X$. Then $2X$ must be an even number. In a binary representation, a number is even if and only if its least significant bit (LSB) is $0$. Therefore, to correctly implement multiplication by $2$ via a left shift, the new LSB must be $0$. Inserting the previous sign bit would violate this fundamental mathematical property (e.g., if the sign bit was $1$, the result would be odd, which is incorrect).\nSince ASL and LSL are defined as the same operation, they do not require distinct hardware. The premise of the statement is factually wrong.\nThe statement is **Incorrect**.\n\n### Summary of Correct Statements\n- Statement A is correct.\n- Statement B is incorrect.\n- Statement C is correct.\n- Statement D is correct.\n- Statement E is incorrect.\n\nThe correct statements are A, C, and D.",
            "answer": "$$\\boxed{ACD}$$"
        }
    ]
}