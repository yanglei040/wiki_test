{
    "hands_on_practices": [
        {
            "introduction": "Beyond manipulating individual bits, bitwise operations are powerful tools for performing \"data surgery\" on entire words. This exercise demonstrates how to reorganize larger chunks of data, such as bytes, within a 32-bit register. By combining bitwise masks to isolate specific segments of data and shifts to reposition them, we can efficiently implement complex permutations, such as swapping the upper and lower 16-bit half-words—a common task in network programming and graphics for handling endianness differences. This practice builds foundational skills in low-level data manipulation, showing how high-level concepts like rotation can be synthesized from fundamental operations .",
            "id": "3623175",
            "problem": "Let a $32$-bit unsigned word $x$ be viewed as an ordered four-byte tuple $[b_3\\,b_2\\,b_1\\,b_0]$, where $b_0$ is the least significant byte and $b_3$ is the most significant byte. In standard byte-indexing consistent with little-endian bit numbering, $b_0$ occupies bit positions $[0,7]$, $b_1$ occupies bit positions $[8,15]$, $b_2$ occupies bit positions $[16,23]$, and $b_3$ occupies bit positions $[24,31]$. The objective is to reconstruct the word into the byte order $[b_1\\,b_0\\,b_3\\,b_2]$ using only fundamental bit-level operations that are implementable on typical general-purpose processors: bitwise AND ($\\$), bitwise OR ($|$), left shift ($\\ll$), right shift ($\\gg$), and masking with $(2^{32}-1)$. No built-in \"rotate\" instruction or external library routine may be used. All intermediate steps must treat values modulo $2^{32}$ by masking with $(2^{32}-1)$ to respect the $32$-bit word width.\n\nStarting point definitions and facts you may rely on:\n- A \"byte\" is $8$ bits. A \"word\" here is $32$ bits.\n- Bitwise AND ($\\$), bitwise OR ($|$), left shift ($\\ll$), and right shift ($\\gg$) act on the binary representation of integers; when applied to unsigned integers, right shift is logically defined with zero fill.\n- Masking with $(2^{32}-1)$ limits a value to its least significant $32$ bits.\n- A rotation of a fixed-width word cyclically moves bits so that those shifted out on one end re-enter on the other end; you may use this concept for reasoning, but the reconstruction must be implemented using shifts and masks only.\n\nConstruct a program that, for a collection of given $32$-bit unsigned words, computes the reconstructed word whose bytes are arranged as $[b_1\\,b_0\\,b_3\\,b_2]$. The program must implement the reconstruction entirely with bitwise shifts, masks, and combinations as described. The program must not read any input; it must produce output for the following test suite of parameter values, each interpreted modulo $2^{32}$:\n- $x = 0x\\text{AABBCCDD}$\n- $x = 0x\\text{12345678}$\n- $x = 0x\\text{00000000}$\n- $x = 0x\\text{FFFFFFFF}$\n- $x = 0x\\text{80000001}$\n- $x = 0x\\text{00FF00FF}$\n\nDesign for coverage:\n- Include a case where all bytes are distinct to test general correctness.\n- Include all-zero and all-one words to test boundary conditions.\n- Include cases where single high-order or low-order bits affect cross-byte movement.\n- Include a case with symmetric half-words to test invariance under the transformation when appropriate.\n\nYour program should produce a single line of output containing the reconstructed $32$-bit words, each expressed as an unsigned decimal integer, aggregated into a comma-separated list enclosed in square brackets (for example, $[r_1,r_2,\\dots,r_n]$). No additional text or formatting may be printed.",
            "solution": "The problem statement is evaluated for validity as a mandatory first step.\n\n### Step 1: Extract Givens\n- A $32$-bit unsigned word $x$ is represented as a four-byte tuple $[b_3, b_2, b_1, b_0]$, where $b_0$ is the least significant byte and $b_3$ is the most significant.\n- Byte positions are defined by bit indices: $b_0$ is bits $[0,7]$, $b_1$ is bits $[8,15]$, $b_2$ is bits $[16,23]$, and $b_3$ is bits $[24,31]$.\n- The objective is to rearrange the bytes of $x$ to form a new word $y$ with the byte order $[b_1, b_0, b_3, b_2]$.\n- Permitted operations are bitwise AND ($\\$), bitwise OR ($|$), left shift ($\\ll$), and logical right shift ($\\gg$).\n- Intermediate values must be confined to a $32$-bit width, equivalent to performing operations modulo $2^{32}$ by masking with $(2^{32}-1)$.\n- A \"byte\" is $8$ bits; a \"word\" is $32$ bits.\n- Built-in rotate instructions or any external libraries for this purpose are forbidden.\n- The program must process a fixed test suite of $32$-bit unsigned words: $0x\\text{AABBCCDD}$, $0x\\text{12345678}$, $0x\\text{00000000}$, $0x\\text{FFFFFFFF}$, $0x\\text{80000001}$, and $0x\\text{00FF00FF}$.\n- The output must be a single line containing the reconstructed words as unsigned decimal integers, formatted as a comma-separated list enclosed in square brackets.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded (Critical)**: The problem is fundamentally sound. It is based on the principles of digital logic and computer architecture, specifically the binary representation of integers and their manipulation using standard bitwise operations. These concepts are cornerstones of computer science.\n- **Well-Posed**: The problem is well-posed. It provides a clear initial state ($x$), a precisely defined final state (the target byte ordering), and an explicit set of allowed transformations. The constraints are sufficient to construct a unique and deterministic solution.\n- **Objective (Critical)**: The problem is stated in precise, objective, and formal language. All terms like \"byte,\" \"word,\" \"bit position,\" and the bitwise operations themselves have standard, unambiguous definitions in the context of computer science.\n- **Other Flaws**: The problem does not exhibit any other flaws. It is not incomplete, contradictory, unrealistic, ill-posed, or trivial. The task is a standard exercise in low-level data manipulation, often related to tasks like endianness conversion.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A solution will be constructed.\n\n### Principle-Based Solution\nThe objective is to transform a $32$-bit unsigned word $x$, which has the byte structure $[b_3, b_2, b_1, b_0]$, into a new word $y$ with the byte structure $[b_1, b_0, b_3, b_2]$. The notation $[b_3, b_2, b_1, b_0]$ signifies that $b_3$ is the most significant byte and $b_0$ is the least significant byte.\n\nThe transformation can be decomposed into four steps:\n1.  Isolate each of the four bytes ($b_3, b_2, b_1, b_0$) from the original word $x$.\n2.  Shift each isolated byte to its new position in the target word $y$.\n3.  Combine the four shifted results using the bitwise OR operation.\n4.  Ensure all operations respect the $32$-bit word size, conforming to arithmetic modulo $2^{32}$.\n\nLet the original word be $x$. The target word $y$ will have its bytes arranged as follows:\n- The original byte $b_1$ moves to the most significant byte position, bits $[24,31]$.\n- The original byte $b_0$ moves to the second most significant byte position, bits $[16,23]$.\n- The original byte $b_3$ moves to the second least significant byte position, bits $[8,15]$.\n- The original byte $b_2$ moves to the least significant byte position, bits $[0,7]$.\n\nThis transformation is equivalent to swapping the two $16$-bit half-words of the $32$-bit word. Let the lower half-word of $x$ be $H_L = [b_1, b_0]$ and the upper half-word be $H_U = [b_3, b_2]$. The target word $y$ will have the structure $[H_L, H_U]$.\n\nWe can construct the solution by first isolating these two half-words and then repositioning them.\n\n1.  **Isolate the lower $16$-bit half-word ($H_L = [b_1, b_0]$)**: This half-word occupies bits $[0,15]$. We can isolate it by performing a bitwise AND with a mask that has ones in the lower $16$ bits and zeros elsewhere. This mask is $0x0000\\text{FFFF}$.\n    $$ x_L = x \\;\\\\; 0x0000\\text{FFFF} $$\n    This operation results in a word where the upper $16$ bits are zero, and the lower $16$ bits contain $[b_1, b_0]$.\n\n2.  **Move the lower half-word to the upper position**: To move $H_L$ to the upper $16$ bits of the target word (bits $[16,31]$), we must perform a left shift by $16$ positions.\n    $$ y_{upper} = x_L \\ll 16 = (x \\;\\\\; 0x0000\\text{FFFF}) \\ll 16 $$\n\n3.  **Isolate the upper $16$-bit half-word ($H_U = [b_3, b_2]$)**: This half-word occupies bits $[16,31]$. There are two equivalent ways to isolate its value into the lower $16$ bits of a temporary word.\n    a) We can mask it first with $0x\\text{FFFF}0000$ and then right-shift by $16$.\n    b) Since we are operating on unsigned integers, a logical right shift by $16$ will move bits $[16,31]$ to positions $[0,15]$ and automatically fill the newly vacated upper bits with zeros. This is more direct.\n    $$ x_U = x \\gg 16 $$\n    This operation yields a word where the lower $16$ bits contain $[b_3, b_2]$ and the upper $16$ bits are zero. This is a direct extraction of the upper half-word's value into the lower position.\n\n4.  **Combine the repositioned half-words**: The final result $y$ is obtained by the bitwise OR of the two components. The upper part $y_{upper}$ already has its lower $16$ bits as zero, and the lower part $x_U$ has its upper $16$ bits as zero. Their bitwise OR will therefore combine them without interference.\n    $$ y = y_{upper} \\;\\lor\\; x_U $$\n    Substituting the expressions:\n    $$ y = ((x \\;\\\\; 0x0000\\text{FFFF}) \\ll 16) \\;\\lor\\; (x \\gg 16) $$\nThis expression correctly reconstructs the word into the byte order $[b_1, b_0, b_3, b_2]$ using only the permitted operations. The operations on `unsigned int` in C automatically respect the $32$-bit word boundary (assuming standard `int` size), satisfying the requirement to operate modulo $2^{32}$. This algorithm effectively performs a $16$-bit rotation on a $32$-bit word without using a dedicated rotate instruction, which is consistent with the problem's conceptual framing.",
            "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n#include stdio.h\n#include stdlib.h\n#include string.h // Not used, but included per problem format.\n#include math.h   // Not used, but included per problem format.\n// #include complex.h // Not used.\n// #include threads.h // Not used.\n// #include stdatomic.h // Not used.\n\n// A struct to hold the parameters for a single test case.\n// Using unsigned int which is typically 32 bits on most modern systems.\ntypedef struct {\n    unsigned int x;\n    const char* label;\n} TestCase;\n\n// Function to perform the byte reordering.\n// Implements y = ((x  0x0000FFFF)  16) | (x  16)\nunsigned int reorder_bytes(unsigned int x) {\n    // Isolate the lower 16 bits ([b1,b0]), shift them to the upper 16 bits.\n    unsigned int lower_half_to_upper = (x  0x0000FFFFU)  16;\n    \n    // Isolate the upper 16 bits ([b3,b2]) by shifting them to the lower 16 bits.\n    // For unsigned integers, right shift is a logical shift (zero-fill).\n    unsigned int upper_half_to_lower = x  16;\n\n    // Combine the two repositioned half-words.\n    return lower_half_to_upper | upper_half_to_lower;\n}\n\nint main(void) {\n    // Define the test cases from the problem statement.\n    // The problem asks for coverage of various scenarios.\n    TestCase test_cases[] = {\n        {0xAABBCCDD, \"General case\"},\n        {0x12345678, \"Distinct bytes\"},\n        {0x00000000, \"All-zero word\"},\n        {0xFFFFFFFF, \"All-one word\"},\n        {0x80000001, \"High/low bits\"},\n        {0x00FF00FF, \"Symmetric half-words\"}\n    };\n\n    // Calculate the number of test cases.\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    unsigned int results[num_cases];\n\n    // Calculate the result for each test case.\n    for (int i = 0; i  num_cases; ++i) {\n        results[i] = reorder_bytes(test_cases[i].x);\n    }\n\n    // Print the results in the EXACT REQUIRED format before the final return statement.\n    // The output must be a single line: [r1,r2,...,rn]\n    printf(\"[\");\n    for (int i = 0; i  num_cases; ++i) {\n        // Print the unsigned decimal representation.\n        printf(\"%u\", results[i]);\n        if (i  num_cases - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\");\n\n    return EXIT_SUCCESS;\n}\n```"
        },
        {
            "introduction": "While shifting provides a fast way to multiply or divide by powers of two, the default behavior of an arithmetic right shift is not always what's needed for numerical accuracy. An arithmetic right shift on a signed integer performs division that rounds towards negative infinity (flooring). This practice explores how to achieve a more desirable outcome—rounding to the nearest integer—by adding a carefully chosen \"bias\" to the number before the shift operation. Deriving this bias from first principles illuminates the deep connection between bitwise operations and the subtleties of fixed-point arithmetic, a critical skill for writing accurate, high-performance code in domains like digital signal processing and embedded systems .",
            "id": "3623075",
            "problem": "You are given signed integers interpreted in two's complement, and you must implement fixed-point scaling by a power of two using bitwise operations. Assume an arithmetic right shift that replicates the sign bit and is semantically equivalent to division by $2^n$ with rounding toward negative infinity (flooring division) for negative values. Let $x \\in \\mathbb{Z}$ be a signed integer and $n \\in \\mathbb{Z}_{\\ge 0}$ be a non-negative integer less than the machine word size.\n\nFundamental base and definitions to use:\n- Two's complement representation of signed integers and arithmetic right shift: For any $x \\in \\mathbb{Z}$ and any $n \\in \\mathbb{Z}_{\\ge 0}$ that does not exceed the word size minus one, an arithmetic right shift by $n$ bits yields\n$$\n\\mathrm{ASR}_n(x) = \\left\\lfloor \\frac{x}{2^n} \\right\\rfloor,\n$$\nwhere $\\lfloor \\cdot \\rfloor$ denotes the floor function.\n- Euclidean division by a power of two: For any $x \\in \\mathbb{Z}$ and any $n \\in \\mathbb{Z}_{\\ge 0}$, there exist unique $q \\in \\mathbb{Z}$ and $r \\in \\{0,1,\\dots,2^n-1\\}$ such that\n$$\nx = q \\cdot 2^n + r \\quad \\text{and} \\quad q = \\left\\lfloor \\frac{x}{2^n} \\right\\rfloor.\n$$\n- Rounding-to-nearest with ties away from zero: For any real $y \\in \\mathbb{R}$, define $\\mathrm{RN}(y)$ as the nearest integer to $y$, breaking ties by choosing the integer with larger magnitude, i.e., if $y = k + \\tfrac{1}{2}$ for some $k \\in \\mathbb{Z}$, then $\\mathrm{RN}(y) = k + 1$ if $y \\ge 0$ and $\\mathrm{RN}(y) = k$ if $y  0$.\n\nYour tasks:\n1. Starting from the definitions above, derive a method to compute truncation by powers of two using arithmetic right shift, namely $\\mathrm{TRUNC}_n(x) = \\mathrm{ASR}_n(x)$.\n2. Derive, from first principles, a sign-dependent bias $b(x,n) \\in \\mathbb{Z}$ that depends only on $\\mathrm{sign}(x)$ and $n$, such that adding this bias before arithmetic right shift implements rounding-to-nearest with ties away from zero:\n$$\n\\mathrm{ROUND}_n(x) = \\mathrm{ASR}_n\\!\\big(x + b(x,n)\\big) = \\mathrm{RN}\\!\\left(\\frac{x}{2^n}\\right).\n$$\nYou must derive the explicit form of $b(x,n)$ without assuming it; use only the fundamental definitions above and reason about the Euclidean remainder $r$ and quotient $q$ to determine the minimal constant bias that guarantees correctness for all $x$ with a fixed $n$. Handle the boundary case $n=0$ explicitly.\n\nImplementation requirements:\n- Implement two functions in your program logic:\n  - Truncation by $2^{-n}$ using arithmetic right shift to compute $\\mathrm{TRUNC}_n(x)$.\n  - Rounding-to-nearest (ties away from zero) by adding the sign-dependent bias before arithmetic right shift to compute $\\mathrm{ROUND}_n(x)$.\n- Avoid arithmetic overflow when computing $x + b(x,n)$ by using sufficiently wide intermediate precision.\n\nTest suite:\nYour program must evaluate the following test cases, each given as a pair $(x,n)$:\n- $(x,n) = (\\,\\;12345,\\, 3\\,)$\n- $(x,n) = (\\,\\;12345,\\, 2\\,)$\n- $(x,n) = (\\,\\;7,\\, 1\\,)$\n- $(x,n) = (\\, -9,\\, 3\\,)$\n- $(x,n) = (\\, -4,\\, 3\\,)$\n- $(x,n) = (\\,-33,\\, 5\\,)$\n- $(x,n) = (\\,-42,\\, 0\\,)$\n- $(x,n) = (\\,2^{30},\\, 5\\,)$\n- $(x,n) = (\\,-2^{31},\\, 31\\,)$\n- $(x,n) = (\\,2^{31}-1,\\, 31\\,)$\n\nOutput specification:\n- For each test case, compute two integers: the truncation result $\\mathrm{TRUNC}_n(x)$ and the rounding result $\\mathrm{ROUND}_n(x)$.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case must be represented as a two-element list $[t,r]$, where $t$ is $\\mathrm{TRUNC}_n(x)$ and $r$ is $\\mathrm{ROUND}_n(x)$, in the same order as the test suite. For example:\n\"[ [t1,r1],[t2,r2],... ]\"",
            "solution": "The problem statement is valid. It presents a well-defined task in the domain of computer arithmetic, grounded in formal mathematical definitions of number representation and rounding, and is internally consistent. I will now proceed with the derivation and solution.\n\nThe core of the problem is to implement two types of fixed-point scaling (division by a power of two, $2^n$) for a signed integer $x$: one that floors the result and another that rounds it to the nearest integer. Both must be implemented using bitwise operations, specifically the arithmetic right shift.\n\nLet $x \\in \\mathbb{Z}$ be a signed integer and $n \\in \\mathbb{Z}_{\\ge 0}$ be the non-negative integer shift amount. The problem defines the arithmetic right shift by $n$ bits, $\\mathrm{ASR}_n(x)$, as performing flooring division:\n$$\n\\mathrm{ASR}_n(x) = \\left\\lfloor \\frac{x}{2^n} \\right\\rfloor\n$$\nThis identity is the foundation of our derivations. In the C language, the right shift operator `` on signed integer types is specified to be an arithmetic shift in the C23 standard, and this behavior is a de facto standard on virtually all modern two's complement architectures.\n\n### Task 1: Derivation of the Truncation Method\n\nThe problem asks for a method to compute $\\mathrm{TRUNC}_n(x)$ and provides the definition to be used:\n$$\n\\mathrm{TRUNC}_n(x) = \\mathrm{ASR}_n(x)\n$$\nThis is a direct definition. By substituting the given identity for $\\mathrm{ASR}_n(x)$, we immediately have:\n$$\n\\mathrm{TRUNC}_n(x) = \\left\\lfloor \\frac{x}{2^n} \\right\\rfloor\n$$\nThis means that for the purposes of this problem, \"truncation\" is defined as flooring division. It is important to note that this is different from the more common definition of truncation as rounding towards zero (e.g., as implemented by C's integer division). For non-negative $x$, flooring and truncating towards zero are identical. For negative $x$ that are not integer multiples of $2^n$, they differ. For example, $\\lfloor -5/2 \\rfloor = \\lfloor -2.5 \\rfloor = -3$, while truncation towards zero of $-2.5$ yields $-2$.\n\nBased on the problem's definition, the implementation of $\\mathrm{TRUNC}_n(x)$ is simply a direct application of the arithmetic right shift operator. For a variable `x` and shift amount `n`, this is `x  n`.\n\n### Task 2: Derivation of the Rounding Bias\n\nThe second task is to derive an integer bias $b(x,n)$ such that adding this bias to $x$ before the arithmetic right shift implements rounding to the nearest integer, with ties rounded away from zero. The target relation is:\n$$\n\\mathrm{ROUND}_n(x) = \\mathrm{ASR}_n\\!\\big(x + b(x,n)\\big) = \\mathrm{RN}\\!\\left(\\frac{x}{2^n}\\right)\n$$\nSubstituting the definition of $\\mathrm{ASR}_n$, we need to find $b(x,n)$ that satisfies:\n$$\n\\left\\lfloor \\frac{x + b(x,n)}{2^n} \\right\\rfloor = \\mathrm{RN}\\!\\left(\\frac{x}{2^n}\\right)\n$$\nTo solve for $b(x,n)$, we analyze the behavior based on the sign of $x$ and the value of $n$. We utilize the Euclidean division of $x$ by $2^n$: there exist unique integers $q$ and $r$ such that $x = q \\cdot 2^n + r$ with $q = \\lfloor x/2^n \\rfloor$ and $0 \\le r  2^n$. The equation becomes:\n$$\n\\left\\lfloor \\frac{q \\cdot 2^n + r + b(x,n)}{2^n} \\right\\rfloor = q + \\left\\lfloor \\frac{r + b(x,n)}{2^n} \\right\\rfloor = \\mathrm{RN}\\!\\left(q + \\frac{r}{2^n}\\right)\n$$\n\n**Case 1: $n=0$**\nIf $n=0$, we are dividing by $2^0 = 1$. The division $x/1 = x$ is already an integer.\nThe rounding function gives $\\mathrm{RN}(x) = x$.\nThe shift operation is $\\mathrm{ASR}_0(x+b) = \\lfloor (x+b)/1 \\rfloor = x+b$.\nTo satisfy $x+b = x$, the bias $b(x,0)$ must be $0$.\n\n**Case 2: $n0$ and $x \\ge 0$**\nFor a non-negative real number $y$, rounding to the nearest integer with ties away from zero (up) is equivalent to $\\lfloor y + 1/2 \\rfloor$.\nLet $y = x/2^n$. We require:\n$$\n\\left\\lfloor \\frac{x}{2^n} + \\frac{b(x,n)}{2^n} \\right\\rfloor = \\left\\lfloor \\frac{x}{2^n} + \\frac{1}{2} \\right\\rfloor\n$$\nAn obvious choice for the bias is one that makes $b(x,n)/2^n = 1/2$. This gives an integer bias $b(x,n) = 2^n/2 = 2^{n-1}$. Since $n0$, $n-1 \\ge 0$, so $2^{n-1}$ is an integer.\nLet's verify this choice. The target is $\\mathrm{RN}(q + r/2^n)$. For $x \\ge 0$, this is $q$ if $r/2^n  1/2$ (i.e., $r  2^{n-1}$), and $q+1$ if $r/2^n \\ge 1/2$ (i.e., $r \\ge 2^{n-1}$).\nWith $b=2^{n-1}$, we compute $q + \\lfloor (r + 2^{n-1}) / 2^n \\rfloor$.\n- If $r  2^{n-1}$, then $r + 2^{n-1}  2^n$, so $\\lfloor (r + 2^{n-1}) / 2^n \\rfloor = 0$. The result is $q$. This is correct.\n- If $r \\ge 2^{n-1}$, then $2^n \\le r + 2^{n-1}  2^n + 2^{n-1}$. Thus, $1 \\le (r + 2^{n-1}) / 2^n  1.5$. The floor is $1$. The result is $q+1$. This is also correct.\nSo, for $x \\ge 0$ and $n  0$, the bias is $b(x,n) = 2^{n-1}$.\n\n**Case 3: $n0$ and $x  0$**\nFor a negative real number $y$, the rounding rule for ties is away from zero. A tie occurs when $y = k + 1/2$ for some integer $k$. The problem states that $\\mathrm{RN}(y) = k$ in this case (i.e., rounded toward negative infinity).\nLet's analyze $\\mathrm{RN}(q + r/2^n)$ for $x  0$ (so $q0$):\n- If the fractional part $r/2^n$ is greater than $1/2$ (i.e., $r  2^{n-1}$), the number is closer to $q+1$. So $\\mathrm{RN}(y) = q+1$.\n- If the fractional part $r/2^n$ is less than or equal to $1/2$ (i.e., $r \\le 2^{n-1}$), the number is closer to or equidistant to $q$. Due to the tie-breaking rule, $\\mathrm{RN}(y) = q$.\nWe need to find a bias $b$ such that $q + \\lfloor (r+b)/2^n \\rfloor$ matches this behavior. This means we require $\\lfloor (r+b)/2^n \\rfloor$ to be $0$ when $r \\le 2^{n-1}$ and $1$ when $r  2^{n-1}$.\nLet's test the integer bias $b = 2^{n-1} - 1$.\n- If $r \\le 2^{n-1}$, then $r+b \\le 2^{n-1} + (2^{n-1}-1) = 2^n-1$. So, $(r+b)/2^n  1$, and $\\lfloor (r+b)/2^n \\rfloor = 0$. This is correct.\n- If $r  2^{n-1}$, then $r \\ge 2^{n-1}+1$ since $r$ is an integer. Then $r+b \\ge (2^{n-1}+1) + (2^{n-1}-1) = 2^n$. So $(r+b)/2^n \\ge 1$, and $\\lfloor (r+b)/2^n \\rfloor = 1$. This is correct.\nThus, for $x  0$ and $n  0$, the bias is $b(x,n) = 2^{n-1} - 1$.\n\n**Summary of the Bias Term $b(x,n)$**\nCombining all cases, the sign-dependent bias is:\n$$\nb(x,n) = \n\\begin{cases}\n0  \\text{if } n=0 \\\\\n2^{n-1}  \\text{if } n0 \\text{ and } x \\ge 0 \\\\\n2^{n-1}-1  \\text{if } n0 \\text{ and } x  0\n\\end{cases}\n$$\nFor implementation, computing the bias requires care. The term $2^{n-1}$ can be calculated using a bitwise left shift `1LL  (n-1)` (using a 64-bit literal `1LL` to avoid overflow if `n-1` is large). The sum $x + b(x,n)$ could potentially overflow if $x$ is a large integer and a standard 32-bit integer type is used. To satisfy the prompt's requirement to \"use sufficiently wide intermediate precision,\" the calculation should be performed using a 64-bit integer type (`long long` in C).",
            "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n#include stdio.h\n#include stdlib.h\n#include string.h\n#include math.h\n// #include complex.h\n// #include threads.h\n// #include stdatomic.h\n\n// A struct to hold the parameters for a single test case.\ntypedef struct {\n    long long x; // Use long long for x to handle the full range of test values like -2^31.\n    int n;\n} TestCase;\n\nint main(void) {\n    // Define the test cases from the problem statement.\n    TestCase test_cases[] = {\n        {12345LL, 3},\n        {12345LL, 2},\n        {7LL, 1},\n        {-9LL, 3},\n        {-4LL, 3},\n        {-33LL, 5},\n        {-42LL, 0},\n        {1073741824LL, 5},    // 2^30\n        {-2147483648LL, 31},  // -2^31 (INT_MIN for 32-bit)\n        {2147483647LL, 31}    // 2^31 - 1 (INT_MAX for 32-bit)\n    };\n\n    // Calculate the number of test cases.\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    long long trunc_results[num_cases];\n    long long round_results[num_cases];\n\n    // Calculate the result for each test case.\n    for (int i = 0; i  num_cases; ++i) {\n        long long x = test_cases[i].x;\n        int n = test_cases[i].n;\n\n        // Task 1: Truncation (Flooring Division) via Arithmetic Right Shift\n        // The C standard (C23) guarantees that right-shifting a signed integer performs\n        // an arithmetic shift, which is equivalent to flooring division.\n        trunc_results[i] = x  n;\n\n        // Task 2: Rounding to Nearest (Ties Away from Zero)\n        long long bias = 0;\n        if (n  0) {\n            // Calculate the base part of the bias, 2^(n-1), using a 64-bit shift\n            // to prevent overflow for large n.\n            long long power_of_2_n_minus_1 = 1LL  (n - 1);\n            if (x = 0) {\n                // Bias for non-negative numbers\n                bias = power_of_2_n_minus_1;\n            } else {\n                // Bias for negative numbers\n                bias = power_of_2_n_minus_1 - 1;\n            }\n        }\n        \n        // Add bias and then perform arithmetic right shift.\n        // The sum (x + bias) is performed using 64-bit arithmetic to prevent overflow.\n        round_results[i] = (x + bias)  n;\n    }\n\n    // Print the results in the EXACT REQUIRED format before the final return statement.\n    // The output must be a single line \"[ [t1,r1],[t2,r2],... ]\".\n    printf(\"[\");\n    for (int i = 0; i  num_cases; ++i) {\n        printf(\"[%lld,%lld]\", trunc_results[i], round_results[i]);\n        if (i  num_cases - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\");\n\n    return EXIT_SUCCESS;\n}\n```"
        },
        {
            "introduction": "In modern high-performance processors, conditional branches can introduce significant performance penalties due to pipeline stalls from mispredicted branches. This exercise introduces a classic \"bit-twiddling\" technique to compute the absolute value of a number without using any conditional logic. You will learn to create a dynamic \"sign mask\" by arithmetically shifting a number by its width minus one bit, a trick that leverages the properties of two's complement representation. This mask, which is all zeros for non-negative numbers and all ones for negative numbers, can then be used in a purely arithmetic expression to conditionally negate the input, providing a fast, branchless alternative to traditional `if-else` structures .",
            "id": "3623138",
            "problem": "Consider a signed integer represented in two's complement on $w$ bits, where $w \\in \\mathbb{Z}$ and $w \\ge 2$. In two's complement, the representable set is $\\{x \\in \\mathbb{Z} \\mid -2^{w-1} \\le x \\le 2^{w-1} - 1\\}$, the most negative value is $-2^{w-1}$, and the most positive value is $2^{w-1} - 1$. An arithmetic right shift replicates the sign bit, and a bitwise Exclusive OR (XOR) flips bits where its mask has $1$s.\n\nStarting from the fundamental base:\n- The definition of two's complement encoding on $w$ bits and its wrap-around modulo $2^w$.\n- The semantics of Arithmetic Right Shift (ARS) by $k$ bits on a signed two's complement value: it divides by $2^k$ with truncation toward negative infinity and replicates the sign bit.\n- The semantics of bitwise operations: Exclusive OR (XOR), bitwise NOT, subtraction, and masking.\n- The equivalence between two's complement negation and bitwise operations on fixed width: for a $w$-bit value $x$ with $x \\ne -2^{w-1}$, negation satisfies $-x \\equiv \\big(\\lnot x\\big) + 1 \\pmod{2^w}$, and for $x = -2^{w-1}$, $\\big(\\lnot x\\big) + 1 \\equiv x \\pmod{2^w}$.\n\nTask:\n1. Design a branchless algorithm that, on $w$-bit two's complement integers, computes the absolute value using only arithmetic right shift, XOR, subtraction, and masking under $w$-bit semantics. Your design must not employ conditional branches at the point of the absolute value computation. Start from the definitions above and derive why such an algorithm can be constructed, what mask is produced by an arithmetic right shift of $w-1$ bits, and why combining XOR and subtraction with that mask yields the desired transformation.\n2. Prove, from the two's complement and ARS semantics, that the algorithm returns $x$ when $x \\ge 0$, returns $-x$ when $x  -2^{w-1}$, and returns $-2^{w-1}$ when $x = -2^{w-1}$. Your proof must explicitly handle the edge case $x = -2^{w-1}$ by reasoning about the bit pattern and wrap-around modulo $2^w$.\n3. Implement the derived algorithm in a complete program and verify its correctness on the following test suite. For each test case, compare the branchless result to the mathematically defined $w$-bit absolute value function\n$$\n\\operatorname{abs}_w(x) =\n\\begin{cases}\nx,  x \\ge 0, \\\\\n-x,  x  -2^{w-1}, \\\\\n-2^{w-1},  x = -2^{w-1},\n\\end{cases}\n$$\nand report a Boolean indicating equality as an integer $1$ for true or $0$ for false.\n\nUse the test suite consisting of $(w, x)$ pairs:\n- $(8, 42)$,\n- $(8, -42)$,\n- $(8, 127)$,\n- $(8, -127)$,\n- $(8, 0)$,\n- $\\big(8, -2^{7}\\big)$,\n- $(16, 12345)$,\n- $(16, -12345)$,\n- $\\big(16, -2^{15}\\big)$,\n- $\\big(16, 2^{15} - 1\\big)$,\n- $\\big(32, -2^{31}\\big)$,\n- $\\big(32, -2^{31} + 1\\big)$,\n- $\\big(32, 2^{31} - 1\\big)$,\n- $(32, 1)$,\n- $(32, -1)$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is the integer $1$ if the branchless algorithm equals $\\operatorname{abs}_w(x)$ for the corresponding test case, and $0$ otherwise (for example, $[1,0,1]$). No units or angles are involved, and all values must be expressed as plain integers.",
            "solution": "The problem of computing the absolute value of a signed integer without using conditional branches is a classic exercise in a field known as \"bit-twiddling.\" The solution leverages the properties of two's complement arithmetic and the behavior of specific bitwise and arithmetic machine instructions. The following analysis will formally derive and prove the correctness of such an algorithm.\n\n### Step 1: Algorithmic Design and Derivation\n\nThe task is to compute $\\operatorname{abs}_w(x)$ for a $w$-bit two's complement integer $x$. The function is defined as:\n$$\n\\operatorname{abs}_w(x) =\n\\begin{cases}\nx,  \\text{if } x \\ge 0 \\\\\n-x,  \\text{if } x  0 \\text{ and } x  -2^{w-1} \\\\\n-2^{w-1},  \\text{if } x = -2^{w-1}\n\\end{cases}\n$$\nThe core challenge is to implement the conditional logic ($x \\ge 0$ vs. $x  0$) using only the permitted operations: arithmetic right shift (ARS), XOR, subtraction, and masking.\n\nLet's represent the desired outcome as a single expression. We seek a transformation $f(x)$ such that $f(x) = x$ if $x$ is non-negative and $f(x) = -x$ if $x$ is negative (with special handling for the most negative number, $-2^{w-1}$).\n\nIn two's complement, negation is performed by bitwise NOT followed by addition of $1$. That is, $-x \\equiv (\\lnot x) + 1 \\pmod{2^w}$.\nOur goal is thus to compute:\n$$\ny = \\begin{cases}\nx,  \\text{if } x \\ge 0 \\\\\n(\\lnot x) + 1,  \\text{if } x  0\n\\end{cases}\n$$\nWe can construct a mask that depends on the sign of $x$. The sign of a $w$-bit two's complement integer is determined by its most significant bit (MSB), bit $w-1$. If bit $w-1$ is $0$, the number is non-negative ($x \\ge 0$). If bit $w-1$ is $1$, the number is negative ($x  0$).\n\nThe Arithmetic Right Shift (ARS) operation is ideally suited for creating such a mask. An ARS by $k$ bits, denoted $\\text{ARS}(x, k)$, shifts the bits of $x$ to the right by $k$ positions, filling the newly vacated MSBs with copies of the original MSB (the sign bit).\n\nLet us define a mask $m$ by shifting $x$ arithmetically to the right by $w-1$ positions:\n$$\nm = \\text{ARS}(x, w-1)\n$$\n\n- If $x \\ge 0$, its sign bit is $0$. The ARS operation will fill all $w$ bits of $m$ with $0$. Thus, $m$ becomes a word of all zeros, which represents the integer $0$.\n- If $x  0$, its sign bit is $1$. The ARS operation will fill all $w$ bits of $m$ with $1$. Thus, $m$ becomes a word of all ones, which represents the integer $-1$ in two's complement.\n\nSo, we have a mask $m$ which is $0$ for $x \\ge 0$ and $-1$ for $x  0$. Let's examine the expression $(x \\oplus m) - m$, where $\\oplus$ denotes bitwise XOR.\n\n- **Case $x \\ge 0$**: Here, $m=0$. The expression becomes $(x \\oplus 0) - 0$. Since $x \\oplus 0 = x$, the result is $x$. This is the correct outcome.\n- **Case $x  0$**: Here, $m=-1$ (a bit pattern of all ones). The expression becomes $(x \\oplus -1) - (-1)$. The operation $x \\oplus -1$ is equivalent to a bitwise NOT, $\\lnot x$. The expression simplifies to $(\\lnot x) - (-1)$, which is $(\\lnot x) + 1$. This is the two's complement formula for negation, $-x$.\n\nThis suggests the following branchless algorithm:\n1. Generate a mask $m$ from the sign of $x$: $m = \\text{ARS}(x, w-1)$.\n2. Compute the result: $y = (x \\oplus m) - m$.\n\nThis algorithm appears to correctly compute the absolute value. The next step is to provide a rigorous proof, including the specified edge case.\n\n### Step 2: Proof of Correctness\n\nLet $x$ be a $w$-bit two's complement integer. The algorithm computes $y = (x \\oplus m) - m$, where $m = \\text{ARS}(x, w-1)$. We will prove its correctness for all three cases specified by the $\\operatorname{abs}_w(x)$ function definition.\n\n**Case 1: $x \\ge 0$**\nIf $x \\ge 0$, its two's complement representation has the most significant bit (MSB), at position $w-1$, equal to $0$. The operation $m = \\text{ARS}(x, w-1)$ shifts $x$ right by $w-1$ positions while replicating the sign bit. Since the sign bit is $0$, the resulting $w$-bit integer $m$ consists of all zeros. The integer value of $m$ is therefore $0$.\nThe algorithm computes:\n$$y = (x \\oplus 0) - 0$$\nThe bitwise XOR operation with $0$ is an identity transformation, so $x \\oplus 0 = x$.\nThe expression simplifies to:\n$$y = x - 0 = x$$\nThis matches the required output $\\operatorname{abs}_w(x) = x$ for $x \\ge 0$.\n\n**Case 2: $x  0$ and $x  -2^{w-1}$**\nIf $x  0$, its MSB is $1$. The operation $m = \\text{ARS}(x, w-1)$ replicates this sign bit throughout all $w$ positions of the result. The bit pattern of $m$ is thus $11...1_2$. In $w$-bit two's complement, this pattern represents the integer $-1$.\nThe algorithm computes:\n$$y = (x \\oplus (-1)) - (-1)$$\nA bitwise XOR with $-1$ (all ones) is equivalent to a bitwise NOT operation, $\\lnot$. So, $x \\oplus (-1) = \\lnot x$.\nThe expression becomes:\n$$y = (\\lnot x) - (-1) = (\\lnot x) + 1$$\nAccording to the properties of two's complement arithmetic, for any value $x$ except the most negative one ($-2^{w-1}$), its negation $-x$ is computed as $(\\lnot x) + 1$. Since this case explicitly excludes $x = -2^{w-1}$, the result is $y = -x$.\nThis matches the required output $\\operatorname{abs}_w(x) = -x$ for $x  -2^{w-1}$.\n\n**Case 3: $x = -2^{w-1}$**\nThis is the unique edge case where the standard negation formula $-x = (\\lnot x) + 1$ does not produce a value within the representable range (as $-(-2^{w-1}) = 2^{w-1}$, which is out of bounds). We must analyze the behavior of the algorithm at the bit level under $w$-bit wrap-around semantics.\nThe two's complement representation of $x = -2^{w-1}$ is the bit pattern $100...0_2$.\nThe MSB is $1$, so as in Case 2, the mask is $m = \\text{ARS}(x, w-1) = -1$ (all ones, $11...1_2$).\nThe algorithm computes $y = (x \\oplus m) - m = (\\lnot x) + 1$.\nLet's apply the bitwise operations to the pattern of $x = -2^{w-1}$:\n- $x = 100...0_2$\n- $\\lnot x = \\lnot(100...0_2) = 011...1_2$. This bit pattern represents the integer $2^{w-1}-1$.\n- $(\\lnot x) + 1$: We add $1$ to the bit pattern $011...1_2$.\n$$\n\\begin{array}{@{}c@{\\,}c@{}l}\n  011...11 _2 \\\\\n+  000...01 _2 \\\\\n\\hline\n  100...00 _2\n\\end{array}\n$$\nThe resulting bit pattern is $100...0_2$. This is the exact same bit pattern as the original input, $x = -2^{w-1}$. Therefore, the integer result of the computation is $y = -2^{w-1}$.\nThis matches the required output $\\operatorname{abs}_w(x) = -2^{w-1}$ for $x = -2^{w-1}$. The algorithm correctly handles this edge case due to the wrap-around nature of fixed-width integer arithmetic.\n\nThe proof is complete. The algorithm $y = (x \\oplus \\text{ARS}(x, w-1)) - \\text{ARS}(x, w-1)$ is correct for all $w$-bit two's complement integers according to the specified $\\operatorname{abs}_w(x)$ function.",
            "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n#include stdio.h\n#include stdlib.h\n#include string.h\n#include math.h\n// #include complex.h\n// #include threads.h\n// #include stdatomic.h\n\n// A struct to hold the parameters for a single test case.\ntypedef struct {\n    int w;\n    long long x;\n} TestCase;\n\nint main(void) {\n    // Define the test cases from the problem statement.\n    // Use long long literals (LL) for 64-bit constants to avoid overflow during initialization.\n    TestCase test_cases[] = {\n        {8, 42},\n        {8, -42},\n        {8, 127},\n        {8, -127},\n        {8, 0},\n        {8, -(1LL  7)},              // -128\n        {16, 12345},\n        {16, -12345},\n        {16, -(1LL  15)},             // -32768\n        {16, (1LL  15) - 1},          // 32767\n        {32, -(1LL  31)},             // -2147483648\n        {32, -(1LL  31) + 1},         // -2147483647\n        {32, (1LL  31) - 1},          // 2147483647\n        {32, 1},\n        {32, -1}\n    };\n\n    // Calculate the number of test cases.\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    int results[num_cases];\n\n    // Calculate the result for each test case.\n    for (int i = 0; i  num_cases; ++i) {\n        int w = test_cases[i].w;\n        long long x = test_cases[i].x;\n\n        long long branchless_res = 0;\n        long long expected_res = 0;\n\n        // Note: The C23 standard guarantees that right-shifting a negative signed integer\n        // is an arithmetic shift. It also defines the behavior of signed integer\n        // overflow as wrap-around for two's complement systems.\n        // We use standard types 'signed char', 'short', 'int' for w=8, 16, 32 respectively.\n        \n        switch (w) {\n            case 8: {\n                signed char v = (signed char)x;\n                signed char mask = v  (w - 1);\n                // The subtraction can overflow (`-128 - (-1) = -127`), but C23's\n                // wrap-around behavior for signed integers correctly handles the math.\n                signed char abs_v = (v ^ mask) - mask;\n                branchless_res = (long long)abs_v;\n                break;\n            }\n            case 16: {\n                short v = (short)x;\n                short mask = v  (w - 1);\n                short abs_v = (v ^ mask) - mask;\n                branchless_res = (long long)abs_v;\n                break;\n            }\n            case 32: {\n                int v = (int)x;\n                int mask = v  (w - 1);\n                int abs_v = (v ^ mask) - mask;\n                branchless_res = (long long)abs_v;\n                break;\n            }\n        }\n        \n        // Calculate the expected result based on the problem's abs_w definition.\n        long long min_val = -(1LL  (w - 1));\n        if (x = 0) {\n            expected_res = x;\n        } else { // x  0\n            if (x  min_val) {\n                expected_res = -x;\n            } else { // x == min_val\n                expected_res = min_val;\n            }\n        }\n\n        results[i] = (branchless_res == expected_res);\n    }\n\n    // Print the results in the EXACT REQUIRED format.\n    printf(\"[\");\n    for (int i = 0; i  num_cases; ++i) {\n        printf(\"%d\", results[i]);\n        if (i  num_cases - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\");\n\n    return EXIT_SUCCESS;\n}\n```"
        }
    ]
}