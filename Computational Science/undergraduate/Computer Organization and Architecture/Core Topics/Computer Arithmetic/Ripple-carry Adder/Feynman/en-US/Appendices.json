{
    "hands_on_practices": [
        {
            "introduction": "The foundation of any digital arithmetic circuit lies in its underlying Boolean logic. This practice guides you to build an adder from first principles, starting with the logic for a single-bit full adder and then chaining these units to create a multi-bit ripple-carry structure. By writing a program to simulate and exhaustively test the design against standard arithmetic, you will gain concrete, hands-on verification of the theory. ",
            "id": "3674448",
            "problem": "You are given the task of validating the single-bit stage logic that underlies a ripple-carry adder and then using it to implement and verify multi-bit addition. Work from first principles of binary arithmetic and Boolean algebra, without assuming any specific circuit formulas a priori. The core facts to use are: binary addition of three one-bit operands $A$, $B$, and $C$ yields a two-bit result $(C',S)$ such that $A+B+C = 2C' + S$ with $S \\in \\{0,1\\}$ and $C' \\in \\{0,1\\}$, and Boolean algebra operates over $\\{0,1\\}$ with the operations logical conjunction, logical disjunction, and logical negation, together with Exclusive OR (XOR).\n\nStarting from these facts:\n- Derive the correct single-bit addition rules that map $(A,B,C)$ to $(S,C')$.\n- Chain the single-bit stage to construct a $w$-bit ripple-carry adder by feeding the carry-out $C'$ of position $i$ as the carry-in $C$ to position $i+1$, beginning with an initial carry-in $C_0$.\n- Establish an algorithm that tests the correctness of the ripple-carry adder by exhaustively enumerating input pairs $(A,B)$ over their full ranges for specified bit widths and checking equality to standard integer addition.\n\nYour program must:\n1. Exhaustively validate the single-bit stage by enumerating all $2^3$ input triples $(A,B,C) \\in \\{0,1\\}^3$ and confirming the stage’s outputs $(S,C')$ match the arithmetic constraints for all combinations. Produce a boolean result for this test.\n2. Validate a multi-bit ripple-carry adder for the following test suite. For each test case, enumerate exactly $2^n$ input pairs $(A,B)$, where $A \\in \\{0,\\dots,2^w-1\\}$, $B \\in \\{0,\\dots,2^w-1\\}$, and the exponent $n$ is chosen to equal $2w$ so that all pairs are tested. For each pair, compare the adder’s computed $(\\text{sum bits}, \\text{final carry})$ to the standard arithmetic result $A+B+C_0$, where the sum bits are the lower $w$ bits and the final carry is the bit beyond position $w-1$. Produce one boolean result per test case indicating whether all pairs matched.\n\nTest suite specifications to implement and check:\n- Single-bit stage verification over all $2^3$ triples $(A,B,C)$.\n- Ripple-carry tests over pairs $(A,B)$ with specified bit widths $w$, initial carry-in $C_0$, and exponent $n$:\n  1. $w=0$, $C_0=0$, $n=0$.\n  2. $w=1$, $C_0=0$, $n=2$.\n  3. $w=4$, $C_0=0$, $n=8$.\n  4. $w=8$, $C_0=0$, $n=16$.\n  5. $w=5$, $C_0=1$, $n=10$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_0,r_1,r_2,r_3,r_4,r_5]$), where each $r_i$ is $1$ for pass (true) or $0$ for fail (false). No physical units or angle units are involved in this problem; all quantities are dimensionless binary integers.",
            "solution": "The problem as stated is valid, scientifically grounded, and well-posed. It requires the derivation and verification of a digital logic circuit, the ripple-carry adder, from the first principles of binary arithmetic and Boolean algebra.\n\nThe solution proceeds in three stages: first, the derivation of the logic for a single-bit full adder; second, the design of a multi-bit ripple-carry adder by cascading these single-bit stages; and third, the implementation of an exhaustive verification algorithm to test the design against standard arithmetic for a given suite of test cases.\n\n### Step 1: Derivation of the Single-Bit Full Adder Logic\n\nThe fundamental operation is the addition of three single-bit operands, $A$, $B$, and a carry-in $C_{in}$, to produce a two-bit result. This result is composed of a sum bit, $S$, and a carry-out bit, $C_{out}$. The governing arithmetic relationship is given by:\n$$\nA + B + C_{in} = 2C_{out} + S\n$$\nwhere $A, B, C_{in}, S, C_{out} \\in \\{0, 1\\}$. The term $2C_{out}$ signifies that the carry-out bit has a place value of $2^1$, while the sum bit $S$ has a place value of $2^0$.\n\nTo derive the Boolean logic for $S$ and $C_{out}$ as functions of $A$, $B$, and $C_{in}$, we construct a truth table by enumerating all $2^3=8$ possible input combinations and calculating the corresponding arithmetic sum.\n\n| $A$ | $B$ | $C_{in}$ | Integer Sum ($A+B+C_{in}$) | Binary Result ($C_{out}S$) | $C_{out}$ | $S$ |\n|:---:|:---:|:--------:|:--------------------------:|:--------------------------:|:---------:|:---:|\n| $0$ | $0$ | $0$      | $0$                        | $00$                       | $0$       | $0$ |\n| $0$ | $0$ | $1$      | $1$                        | $01$                       | $0$       | $1$ |\n| $0$ | $1$ | $0$      | $1$                        | $01$                       | $0$       | $1$ |\n| $0$ | $1$ | $1$      | $2$                        | $10$                       | $1$       | $0$ |\n| $1$ | $0$ | $0$      | $1$                        | $01$                       | $0$       | $1$ |\n| $1$ | $0$ | $1$      | $2$                        | $10$                       | $1$       | $0$ |\n| $1$ | $1$ | $0$      | $2$                        | $10$                       | $1$       | $0$ |\n| $1$ | $1$ | $1$      | $3$                        | $11$                       | $1$       | $1$ |\n\nFrom the truth table, we derive the Boolean expressions for $S$ and $C_{out}$.\n\n**Sum Bit ($S$)**: The output $S$ is $1$ if and only if an odd number of inputs ($A, B, C_{in}$) are $1$. This corresponds to the exclusive-OR (XOR) operation.\n$$\nS = A \\oplus B \\oplus C_{in}\n$$\n\n**Carry-Out Bit ($C_{out}$)**: The output $C_{out}$ is $1$ if and only if two or more of the inputs are $1$. This is the majority function, which can be expressed in sum-of-products form as:\n$$\nC_{out} = (A \\land B) \\lor (A \\land C_{in}) \\lor (B \\land C_{in})\n$$\nThese two equations define the complete logic of a single-bit full adder.\n\n### Step 2: Construction of a $w$-bit Ripple-Carry Adder\n\nA $w$-bit adder is constructed by cascading $w$ single-bit full adder stages. For each bit position $i \\in \\{0, 1, \\dots, w-1\\}$, a full adder processes the input bits $A_i$ and $B_i$ from the two numbers being added, along with the carry-out $C_i$ from the previous stage, $i-1$. It generates a sum bit $S_i$ for the current position and a new carry-out $C_{i+1}$ that \"ripples\" to the next stage.\n\nThe process is defined as:\n- An initial carry-in, $C_0$, is supplied to the first stage (position $i=0$).\n- For each stage $i$ from $0$ to $w-1$:\n  $$\n  S_i = A_i \\oplus B_i \\oplus C_i\n  $$\n  $$\n  C_{i+1} = (A_i \\land B_i) \\lor (A_i \\land C_i) \\lor (B_i \\land C_i)\n  $$\n- The final sum is the $w$-bit number formed by the bits $S_{w-1}S_{w-2}\\dots S_0$.\n- The final carry-out from the last stage, $C_w$, indicates an overflow if the sum cannot be represented within $w$ bits.\n\n### Step 3: Algorithm for Verification\n\nThe verification process is divided into two main parts.\n\n**Part 1: Single-Bit Stage Verification**:\nThis algorithm exhaustively validates the implemented full adder logic.\n1. Iterate through all $2^3=8$ combinations of inputs $(A, B, C_{in}) \\in \\{0, 1\\}^3$.\n2. For each combination, compute the arithmetic sum: $Z = A + B + C_{in}$.\n3. Determine the expected outputs arithmetically: $S_{expected} = Z \\pmod 2$ and $C_{out, expected} = \\lfloor Z / 2 \\rfloor$.\n4. Compute the outputs using the Boolean formulas: $S_{actual} = A \\oplus B \\oplus C_{in}$ and $C_{out, actual} = (A \\land B) \\lor (A \\land C_{in}) \\lor (B \\land C_{in})$.\n5. If $S_{actual} \\neq S_{expected}$ or $C_{out, actual} \\neq C_{out, expected}$ for any combination, the test fails (result is $0$).\n6. If all $8$ combinations match, the stage is validated (result is $1$).\n\n**Part 2: Multi-Bit Adder Verification**:\nThis algorithm tests the correctness of the complete $w$-bit ripple-carry adder.\n1. For a given bit width $w$ and initial carry-in $C_0$, the inputs $A$ and $B$ range from $0$ to $2^w - 1$.\n2. Iterate through all $(2^w) \\times (2^w) = 2^{2w}$ pairs of $(A, B)$.\n3. For each pair:\n    a. Compute the reference result using standard integer arithmetic: $Z_{ref} = A + B + C_0$.\n    b. Extract the expected $w$-bit sum and final carry: $S_{ref} = Z_{ref} \\pmod{2^w}$ and $C_{final, ref} = \\lfloor Z_{ref} / 2^w \\rfloor$.\n    c. Compute the result using the implemented $w$-bit ripple-carry adder, which applies the logic from Step 2. Let the outputs be $S_{rca}$ and $C_{final, rca}$.\n    d. If $S_{rca} \\neq S_{ref}$ or $C_{final, rca} \\neq C_{final, ref}$, the test fails for this configuration.\n4. If a mismatch is found for any pair $(A,B)$, the entire test for that $(w, C_0)$ configuration fails (result is $0$). Otherwise, if all pairs match, it passes (result is $1$).\n\nThe special case of $w=0$ implies inputs $A=0$ and $B=0$. The ripple-carry adder has no stages; its $0$-bit sum is $0$, and its final carry-out is simply the initial carry-in $C_0$. This correctly matches the arithmetic sum $0 + 0 + C_0 = C_0$.\nThe implementation in the final answer will precisely follow these verification algorithms.",
            "answer": "```c\n#include stdio.h\n#include stdlib.h\n#include string.h\n#include math.h\n// #include complex.h\n// #include threads.h\n// #include stdatomic.h\n\n// A struct to hold the result of a single-bit full adder.\ntypedef struct {\n    int sum_bit;\n    int carry_out;\n} FullAdderResult;\n\n// A single-bit full adder implementing the derived Boolean logic.\n// It computes the sum and carry-out for three 1-bit inputs.\nFullAdderResult full_adder(int A, int B, int C_in) {\n    FullAdderResult res;\n    // Sum bit S = A XOR B XOR C_in\n    res.sum_bit = A ^ B ^ C_in;\n    // Carry-out bit C_out = (A AND B) OR (A AND C_in) OR (B AND C_in)\n    res.carry_out = (A  B) | (A  C_in) | (B  C_in);\n    return res;\n}\n\n// Exhaustively validates the single-bit full adder stage by comparing its\n// output to the results of standard binary arithmetic for all 2^3 inputs.\nint validate_single_bit_stage() {\n    for (int A = 0; A = 1; ++A) {\n        for (int B = 0; B = 1; ++B) {\n            for (int C_in = 0; C_in = 1; ++C_in) {\n                // Calculate expected result using integer arithmetic.\n                int arithmetic_sum = A + B + C_in;\n                int expected_S = arithmetic_sum % 2;\n                int expected_C_out = arithmetic_sum / 2;\n\n                // Get actual result from the logic-based full adder.\n                FullAdderResult rca_res = full_adder(A, B, C_in);\n\n                // Compare and fail on mismatch.\n                if (rca_res.sum_bit != expected_S || rca_res.carry_out != expected_C_out) {\n                    return 0; // Failure\n                }\n            }\n        }\n    }\n    return 1; // Success\n}\n\n// Simulates a w-bit ripple-carry adder by chaining single-bit full adders.\nvoid ripple_carry_adder(int w, unsigned long long A, unsigned long long B, int C_in,\n                        unsigned long long *sum_result, int *carry_out) {\n    *sum_result = 0;\n    int current_carry = C_in;\n\n    for (int i = 0; i  w; ++i) {\n        int bit_A = (A  i)  1;\n        int bit_B = (B  i)  1;\n\n        FullAdderResult stage_res = full_adder(bit_A, bit_B, current_carry);\n        \n        // Set the i-th bit of the sum result.\n        if (stage_res.sum_bit) {\n            *sum_result |= (1ULL  i);\n        }\n\n        // Ripple the carry to the next stage.\n        current_carry = stage_res.carry_out;\n    }\n    \n    *carry_out = current_carry;\n}\n\n// Exhaustively validates a w-bit ripple-carry adder against standard arithmetic\n// for all possible pairs of w-bit inputs.\nint validate_multi_bit_adder(int w, int C_0) {\n    unsigned long long max_val_exclusive = (w  0) ? (1ULL  w) : 1;\n\n    for (unsigned long long A = 0; A  max_val_exclusive; ++A) {\n        for (unsigned long long B = 0; B  max_val_exclusive; ++B) {\n            // Calculate expected result using standard integer arithmetic.\n            unsigned long long arithmetic_sum = A + B + C_0;\n            \n            unsigned long long expected_sum_bits;\n            int expected_carry;\n\n            if (w  0) {\n                expected_sum_bits = arithmetic_sum  ((1ULL  w) - 1);\n                expected_carry = (arithmetic_sum = (1ULL  w));\n            } else { // Handle w == 0 as a special case.\n                expected_sum_bits = 0;\n                expected_carry = C_0;\n            }\n\n            // Get actual result from the ripple-carry adder simulation.\n            unsigned long long rca_sum;\n            int rca_carry;\n            ripple_carry_adder(w, A, B, C_0, rca_sum, rca_carry);\n\n            // Compare and fail on mismatch.\n            if (rca_sum != expected_sum_bits || rca_carry != expected_carry) {\n                return 0; // Failure\n            }\n        }\n    }\n    return 1; // Success\n}\n\nint main(void) {\n    // Define the test cases from the problem statement.\n    typedef struct {\n        int w;\n        int C_0;\n    } TestCase;\n    \n    TestCase test_cases[] = {\n        {0, 0},\n        {1, 0},\n        {4, 0},\n        {8, 0},\n        {5, 1},\n    };\n    int num_multi_bit_tests = sizeof(test_cases) / sizeof(test_cases[0]);\n    int num_total_results = 1 + num_multi_bit_tests;\n    int results[num_total_results];\n\n    // Run Test 0: Single-bit stage validation.\n    results[0] = validate_single_bit_stage();\n\n    // Run multi-bit adder validation for each test case.\n    for (int i = 0; i  num_multi_bit_tests; ++i) {\n        results[i + 1] = validate_multi_bit_adder(test_cases[i].w, test_cases[i].C_0);\n    }\n    \n    // Print the results in the EXACT REQUIRED format before the final return statement\n    printf(\"[%d,%d,%d,%d,%d,%d]\", \n           results[0], results[1], results[2], results[3], results[4], results[5]);\n\n    return EXIT_SUCCESS;\n}\n```"
        },
        {
            "introduction": "A functionally correct design is only the first step; its performance in the real world is equally critical. This exercise moves from logical correctness to timing analysis, focusing on the primary drawback of the ripple-carry adder: its speed. You will derive the worst-case delay caused by the sequential 'rippling' of the carry signal and apply this model to determine if the adder can meet the demands of a high-speed clock. ",
            "id": "3674498",
            "problem": "A synchronous datapath implements unsigned addition of two $n$-bit operands using a ripple-carry adder constructed from identical full adders in complementary metal-oxide-semiconductor (CMOS). Each full adder has a carry-in to carry-out propagation delay denoted by $t_{c}$, and all stages are matched so that the per-stage carry delay is the same. In worst-case operation, the incoming carry at the least significant bit ripples through every stage before determining the most significant bit’s result. Assume edge-triggered registers at the adder input and output, and neglect register clock-to-$Q$ delay, setup time, and clock skew for this calculation so that the clock period must be at least the combinational adder delay. Using first principles of synchronous timing and combinational path delays, derive the end-to-end worst-case delay $t_{\\mathrm{RCA}}$ of the $n$-bit ripple-carry adder in terms of $n$ and $t_{c}$.\n\nGiven $n=8$, $t_{c}=200\\,\\mathrm{ps}$, and a target clock frequency $f_{\\mathrm{clk}}=1\\,\\mathrm{GHz}$ (gigahertz), compute the numerical value of $t_{\\mathrm{RCA}}$, decide whether the clock target is feasible under the stated assumptions, and determine the maximum allowable per-stage carry delay $t_{c}$ that would just meet the $1\\,\\mathrm{GHz}$ target.\n\nDefine a feasibility flag $\\phi$ as $\\phi=1$ if the target clock is feasible and $\\phi=0$ otherwise. Express $t_{\\mathrm{RCA}}$ in $\\mathrm{ns}$ (nanoseconds) and the required $t_{c}$ in $\\mathrm{ps}$ (picoseconds). Round all reported numerical values to three significant figures. Your final answer must be a row matrix $\\left(t_{\\mathrm{RCA}},\\,\\phi,\\,t_{c,\\mathrm{req}}\\right)$ containing the three requested quantities in the specified units.",
            "solution": "The problem requires the derivation and calculation of timing parameters for an $n$-bit ripple-carry adder (RCA). First, a validation of the problem statement is performed.\n\n**Problem Validation**\n\n**Step 1: Extract Givens**\n-   Architecture: A synchronous datapath with an $n$-bit ripple-carry adder for unsigned addition.\n-   Components: Identical full adders (FAs) in CMOS.\n-   Delay Parameter: Per-stage carry-in to carry-out propagation delay is $t_{c}$.\n-   Assumptions: All stages are matched; register clock-to-Q delay, setup time, and clock skew are neglected.\n-   Timing Constraint: The clock period $T_{\\mathrm{clk}}$ must be at least the combinational adder delay, $t_{\\mathrm{RCA}}$.\n-   Task 1: Derive the worst-case delay $t_{\\mathrm{RCA}}$ in terms of $n$ and $t_{c}$.\n-   Numerical Values: $n=8$, $t_{c}=200\\,\\mathrm{ps}$, target clock frequency $f_{\\mathrm{clk}}=1\\,\\mathrm{GHz}$.\n-   Task 2: Compute the numerical value of $t_{\\mathrm{RCA}}$ in nanoseconds (ns).\n-   Task 3: Determine feasibility, represented by a flag $\\phi$ ($\\phi=1$ for feasible, $\\phi=0$ for not feasible).\n-   Task 4: Compute the maximum allowable per-stage carry delay, $t_{c,\\mathrm{req}}$, in picoseconds (ps), to meet the target frequency.\n-   Formatting: Report numerical values to three significant figures; final answer as a row matrix $(t_{\\mathrm{RCA}},\\,\\phi,\\,t_{c,\\mathrm{req}})$.\n\n**Step 2: Validate Using Extracted Givens**\n-   **Scientific Grounding**: The problem is grounded in the fundamental principles of digital logic design and computer architecture. The model of a ripple-carry adder and its worst-case timing analysis based on carry propagation is a standard and correct concept.\n-   **Well-Posedness**: The problem is well-posed. It provides sufficient information ($n$, $t_c$, $f_{\\mathrm{clk}}$) and simplifying assumptions (neglecting register delays) to derive a unique and meaningful solution for the requested quantities.\n-   **Objectivity**: The problem is stated in precise, objective, and standard technical language, free from ambiguity or subjective claims.\n-   **Consistency and Completeness**: The givens are self-consistent and complete for the tasks required. No contradictions or missing essential data are identified.\n-   **Realism**: The specified values for component delay ($200\\,\\mathrm{ps}$) and clock frequency ($1\\,\\mathrm{GHz}$) are realistic in the context of CMOS technology, making the problem physically plausible.\n\n**Step 3: Verdict and Action**\nThe problem is deemed **valid** as it is scientifically sound, well-posed, and complete. A full solution will be provided.\n\n**Solution Derivation**\n\nAn $n$-bit ripple-carry adder is constructed by cascading $n$ full adders. Let the full adders be indexed from $i=0$ for the least significant bit (LSB) to $i=n-1$ for the most significant bit (MSB). Each full adder, $\\mathrm{FA}_i$, takes three inputs, the operand bits $A_i$ and $B_i$, and a carry-in $C_i$. It produces two outputs, a sum bit $S_i$ and a carry-out $C_{i+1}$. The carry-out of one stage serves as the carry-in for the next stage, i.e., $C_{i+1}$ from $\\mathrm{FA}_i$ is the input $C_{i+1}$ to $\\mathrm{FA}_{i+1}$.\n\nThe worst-case delay of a combinational circuit is determined by its longest signal path, also known as the critical path. For a ripple-carry adder, the critical path occurs when a carry signal must propagate through the maximum number of stages. This happens when the carry-out of each stage, $C_{i+1}$, depends on its carry-in, $C_i$. For example, when adding $A = 0...01$ and $B = 1...11$ (with $C_0=0$), a carry is generated at stage $0$ and ripples through every subsequent stage.\n\nThe problem states that the carry-in to carry-out propagation delay for each full adder is $t_c$. We assume all inputs ($A_i$, $B_i$) and the initial carry-in ($C_0$) are available simultaneously at time $t=0$, following a clock edge at the input registers.\n\nThe timing of the carry propagation is as follows:\n-   The carry-out of the first stage, $C_1$, is generated by $\\mathrm{FA}_0$. The time for this signal to become stable is determined by the delay through $\\mathrm{FA}_0$. This delay is given as $t_c$. Thus, $C_1$ is stable at time $t_1 = t_c$.\n-   The second stage, $\\mathrm{FA}_1$, cannot compute its final carry-out, $C_2$, until its carry-in, $C_1$, is stable. Once $C_1$ is stable at time $t_1$, it takes another period of $t_c$ for the signal to propagate through $\\mathrm{FA}_1$. Thus, $C_2$ is stable at time $t_2 = t_1 + t_c = 2t_c$.\n-   Generalizing this, the carry-out of stage $i$, $C_{i+1}$, becomes stable at time $t_{i+1} = (i+1)t_c$.\n\nThe end-to-end worst-case delay of the adder, $t_{\\mathrm{RCA}}$, corresponds to the time when all output bits are guaranteed to be stable. The final outputs of the $n$-bit adder are the sum bits $S_0, S_1, ..., S_{n-1}$ and the final carry-out $C_n$. The sum bit $S_i$ depends on inputs $A_i, B_i, C_i$. The stability of $S_{n-1}$ depends on the stability of $C_{n-1}$, and the stability of $C_n$ depends on the stability of $C_{n-1}$. The signal $C_{n-1}$ becomes stable at time $(n-1)t_c$. The signal $C_n$ becomes stable after one more stage delay, at time $n \\times t_c$. The delay to calculate $S_{n-1}$ from a stable $C_{n-1}$ is typically on the same order as $t_c$. However, the path to $C_n$ involves one more full adder stage in the carry chain than the path to $S_{n-1}$'s carry dependency. Therefore, the critical path is the propagation of the carry from the LSB to the final carry-out $C_n$.\n\nThe total delay is the sum of the carry propagation delays through all $n$ stages.\n$$t_{\\mathrm{RCA}} = n \\times t_c$$\n\nThis derivation uses first principles of path delay analysis in a cascaded logic structure, as requested.\n\n**Numerical Calculations**\n\n1.  **Compute $t_{\\mathrm{RCA}}$**:\n    Given $n=8$ and $t_c = 200\\,\\mathrm{ps}$.\n    $$t_{\\mathrm{RCA}} = 8 \\times 200\\,\\mathrm{ps} = 1600\\,\\mathrm{ps}$$\n    Converting to nanoseconds ($1\\,\\mathrm{ns} = 1000\\,\\mathrm{ps}$):\n    $$t_{\\mathrm{RCA}} = 1600\\,\\mathrm{ps} \\times \\frac{1\\,\\mathrm{ns}}{1000\\,\\mathrm{ps}} = 1.6\\,\\mathrm{ns}$$\n    Rounding to three significant figures, $t_{\\mathrm{RCA}} = 1.60\\,\\mathrm{ns}$.\n\n2.  **Determine Feasibility ($\\phi$)**:\n    The system is synchronous. The problem states that the clock period, $T_{\\mathrm{clk}}$, must be greater than or equal to the total combinational delay, $t_{\\mathrm{RCA}}$.\n    $$T_{\\mathrm{clk}} \\ge t_{\\mathrm{RCA}}$$\n    The target clock frequency is $f_{\\mathrm{clk}} = 1\\,\\mathrm{GHz}$. The corresponding clock period is:\n    $$T_{\\mathrm{clk,target}} = \\frac{1}{f_{\\mathrm{clk}}} = \\frac{1}{1 \\times 10^9\\,\\mathrm{Hz}} = 1 \\times 10^{-9}\\,\\mathrm{s} = 1\\,\\mathrm{ns}$$\n    We must check if $T_{\\mathrm{clk,target}} \\ge t_{\\mathrm{RCA}}$:\n    $$1\\,\\mathrm{ns} \\ge 1.60\\,\\mathrm{ns}$$\n    This inequality is false. The required combinational delay ($1.60\\,\\mathrm{ns}$) exceeds the available clock period ($1\\,\\mathrm{ns}$). Therefore, the design is not feasible at the target clock frequency.\n    The feasibility flag is $\\phi = 0$.\n\n3.  **Determine Required Per-Stage Delay ($t_{c,\\mathrm{req}}$)**:\n    To just meet the $1\\,\\mathrm{GHz}$ target, the maximum allowable adder delay must be equal to the clock period.\n    $$t_{\\mathrm{RCA,max}} = T_{\\mathrm{clk,target}} = 1\\,\\mathrm{ns}$$\n    Using the formula for the adder delay, we solve for the maximum per-stage carry delay, $t_{c,\\mathrm{req}}$, that satisfies this condition.\n    $$n \\times t_{c,\\mathrm{req}} = t_{\\mathrm{RCA,max}}$$\n    $$t_{c,\\mathrm{req}} = \\frac{t_{\\mathrm{RCA,max}}}{n} = \\frac{1\\,\\mathrm{ns}}{8}$$\n    Converting the period to picoseconds for the requested output unit: $1\\,\\mathrm{ns} = 1000\\,\\mathrm{ps}$.\n    $$t_{c,\\mathrm{req}} = \\frac{1000\\,\\mathrm{ps}}{8} = 125\\,\\mathrm{ps}$$\n    This value has three significant figures, so no rounding is needed.\n\n**Final Answer Assembly**\nThe requested quantities are:\n-   $t_{\\mathrm{RCA}} = 1.60\\,\\mathrm{ns}$\n-   $\\phi = 0$\n-   $t_{c,\\mathrm{req}} = 125\\,\\mathrm{ps}$\n\nThese are assembled into the specified row matrix: $(1.60,\\,0,\\,125)$.",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 1.60  0  125 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "Having quantified the performance bottleneck of the basic ripple-carry adder, a natural engineering question arises: how can we design a faster one? This advanced practice introduces the carry-select principle, a clever technique that employs parallelism to break the long carry chain that limits performance. You will develop a timing model for this improved architecture and use optimization techniques to determine the ideal design trade-off, a common task in high-performance circuit design. ",
            "id": "3674502",
            "problem": "Consider an $n$-bit adder implemented using the carry-select principle: the $n$ operand bits are partitioned into equal-sized blocks of $b$ bits each, and within every $b$-bit block, two candidate results are computed in parallel assuming the incoming carry is $0$ and $1$, respectively. At each block boundary, a multiplexer (MUX) selects the correct precomputed result once the true carry from the preceding block becomes known. Assume the following first-order timing model based on core definitions from digital logic:\n- A $b$-bit ripple-carry computation within a block is composed of $b$ serial full-adder carry-propagation stages, each with worst-case carry-propagation delay $t_c$ from carry-in to carry-out.\n- A two-input multiplexer incurs an input-to-output delay $t_{mux}$.\n- Wire delays, loading imbalances, and non-critical sum-path delays are negligible compared to the stated delays, and selection control signals for all multiplexers propagate serially across blocks in the critical path.\n\nAssume $n$ is divisible by $b$ so that there are exactly $n/b$ blocks. Treat $b$ as a positive real variable when performing optimization, even though it is an integer in implementation.\n\nUsing only the foregoing assumptions and reasoning from the block-level structure of the critical path from the global carry-in to the most significant sum bit, derive a first-order expression for the worst-case delay $T(b)$ as a function of $n$, $b$, $t_c$, and $t_{mux}$ by counting the serial ripple-carry stages and the serial multiplexer stages on that path. Then, determine the value $b^{\\star}$ that minimizes $T(b)$ over positive real $b$.\n\nProvide your final answer as a single closed-form expression for $b^{\\star}$ in terms of $n$, $t_c$, and $t_{mux}$. Do not include units in your final expression. If you introduce any intermediate variables, eliminate them from the final expression. No numerical evaluation is required.",
            "solution": "The problem statement will first be validated against the specified criteria.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n\nThe explicit information provided in the problem statement is as follows:\n- The adder is an $n$-bit carry-select adder.\n- The $n$ bits are partitioned into equal-sized blocks of $b$ bits each.\n- The number of blocks is $k = n/b$, where $n$ is divisible by $b$.\n- Within each block, two results are computed in parallel, corresponding to a carry-in of $0$ and $1$.\n- The worst-case delay for the carry to propagate through a $b$-bit ripple-carry adder block is modeled as $b \\cdot t_c$.\n- The delay of a two-input multiplexer (MUX) is $t_{mux}$.\n- Selection control signals for multiplexers propagate serially across the blocks, forming a critical path component.\n- The worst-case delay $T(b)$ is defined by the critical path from the global carry-in to the most significant sum bit.\n- For the purpose of optimization, $b$ is to be treated as a positive real variable.\n\n**Step 2: Validate Using Extracted Givens**\n\nThe problem is evaluated based on the validation criteria:\n- **Scientifically Grounded:** The problem describes a carry-select adder, a well-established architecture in digital logic and computer arithmetic. The first-order timing model, while simplified, is a standard and valid approach for high-level performance analysis. All concepts are firmly rooted in electrical engineering and computer science.\n- **Well-Posed:** The problem is clearly defined. It asks for the derivation of a delay expression $T(b)$ and the value of $b$ that minimizes this function. The provided parameters ($n$, $t_c$, $t_{mux}$) are sufficient to formulate and solve the problem. A unique, meaningful solution is obtainable.\n- **Objective:** The problem is stated in precise, technical language, free from subjectivity or ambiguity.\n\nThe problem does not exhibit any of the invalidity flaws. It is not scientifically unsound, non-formalizable, incomplete, unrealistic, ill-posed, trivial, or outside the scope of scientific verifiability.\n\n**Step 3: Verdict and Action**\n\nThe problem is **valid**. A solution will be derived.\n\n### Solution Derivation\n\nThe goal is to find an expression for the worst-case delay, $T(b)$, of the $n$-bit carry-select adder and then to find the block size, $b^{\\star}$, that minimizes this delay. The total number of blocks is $k = n/b$. The blocks are indexed from $0$ to $k-1$.\n\nThe critical path determines the worst-case delay. As specified, this path runs from the global carry-in ($C_{in,0}$) to the most significant sum bit ($S_{n-1}$). Let's analyze the sequential stages of this path.\n\n1.  **Stage 1: Carry-out from the first block (Block 0).**\n    The first block (bits $0$ to $b-1$) takes the inputs for its bit-slice and the global carry-in, $C_{in,0}$. It computes the sum bits and the carry-out, $C_b$, using a $b$-bit ripple-carry structure. According to the problem, the time required for a carry to ripple through all $b$ stages of this block is $b \\cdot t_c$. The computations for all other blocks (Blocks $1$ to $k-1$) for both carry-in cases ($0$ and $1$) occur in parallel with this, so their internal ripple delays do not add to the serial critical path. The critical path begins with the computation in the first block.\n    The carry-out of Block 0, $C_b$, is available at time $T_1 = b \\cdot t_c$.\n\n2.  **Stage 2: Serial propagation of the carry signal through inter-block multiplexers.**\n    The carry-out from Block $i-1$, denoted $C_{ib}$, serves as the select signal for the multiplexers in Block $i$. These multiplexers choose between the pre-computed results (sum bits and carry-out) for that block. The problem states that this selection propagates serially.\n    - The carry-out of Block 0, $C_b$, becomes the carry-in for Block 1. It arrives at the MUX for Block 1's carry-out at time $b \\cdot t_c$. The MUX then takes $t_{mux}$ to select the correct carry-out for Block 1, which is $C_{2b}$. Thus, $C_{2b}$ is available at time $b \\cdot t_c + t_{mux}$.\n    - This new carry, $C_{2b}$, is the select signal for Block 2's MUX. The carry-out of Block 2, $C_{3b}$, is available at time $(b \\cdot t_c + t_{mux}) + t_{mux} = b \\cdot t_c + 2 t_{mux}$.\n    - This forms a chain. The carry-in to the final block, Block $k-1$, is the carry-out from Block $k-2$, which is $C_{(k-1)b}$. This signal must pass through the initial ripple-carry stage of Block 0 and then a series of $k-2$ multiplexers (one for each of Blocks $1, 2, \\dots, k-2$).\n    - The time for the carry-in to the final block, $C_{(k-1)b}$, to become available is $T_2 = b \\cdot t_c + (k-2) \\cdot t_{mux}$.\n\n3.  **Stage 3: Final sum bit generation in the last block (Block k-1).**\n    The most significant sum bit, $S_{n-1}$, is part of the final block, Block $k-1$. The results for this block, including $S_{n-1}$, have been pre-computed for both cases of its carry-in ($0$ and $1$). The true carry-in, $C_{(k-1)b}$, arrives at time $T_2$. This signal is used as the select line for the MUX that chooses the correct pre-computed value of $S_{n-1}$. This final selection process adds one more MUX delay.\n    The delay for this final selection is $t_{mux}$.\n\nThe total worst-case delay $T(b)$ is the sum of the delays of these three sequential stages:\n$$T(b) = T_2 + t_{mux} = \\left(b \\cdot t_c + (k-2) \\cdot t_{mux}\\right) + t_{mux}$$\n$$T(b) = b \\cdot t_c + (k-1) \\cdot t_{mux}$$\nSubstituting $k = n/b$ gives the delay as a function of $b$:\n$$T(b) = b \\cdot t_c + \\left(\\frac{n}{b} - 1\\right) \\cdot t_{mux}$$\n\n### Optimization of Block Size\n\nTo find the block size $b^{\\star}$ that minimizes $T(b)$, we treat $b$ as a positive real variable and use calculus. We differentiate $T(b)$ with respect to $b$ and set the result to zero.\n$$T(b) = b t_c + \\frac{n t_{mux}}{b} - t_{mux}$$\nThe derivative of $T(b)$ with respect to $b$ is:\n$$\\frac{dT}{db} = \\frac{d}{db} \\left(b t_c + n t_{mux} b^{-1} - t_{mux}\\right)$$\n$$\\frac{dT}{db} = t_c - n t_{mux} b^{-2} = t_c - \\frac{n t_{mux}}{b^2}$$\nSetting the derivative to zero to find the critical point(s):\n$$t_c - \\frac{n t_{mux}}{b^2} = 0$$\n$$t_c = \\frac{n t_{mux}}{b^2}$$\nSolving for $b^2$:\n$$b^2 = \\frac{n t_{mux}}{t_c}$$\nSince $b$ must be a positive quantity (representing a block size), we take the positive square root:\n$$b = \\sqrt{\\frac{n t_{mux}}{t_c}}$$\nTo confirm that this value of $b$ corresponds to a minimum, we examine the second derivative of $T(b)$:\n$$\\frac{d^2T}{db^2} = \\frac{d}{db} \\left(t_c - n t_{mux} b^{-2}\\right) = -n t_{mux} (-2 b^{-3}) = \\frac{2 n t_{mux}}{b^3}$$\nSince $n$, $t_{mux}$, and $b$ are all positive physical quantities, the second derivative $\\frac{d^2T}{db^2}$ is always positive. This indicates that the function $T(b)$ is concave up, and the critical point we found corresponds to a global minimum.\n\nThus, the optimal block size $b^{\\star}$ that minimizes the worst-case delay is:\n$$b^{\\star} = \\sqrt{\\frac{n t_{mux}}{t_c}}$$",
            "answer": "$$\\boxed{\\sqrt{\\frac{n t_{mux}}{t_c}}}$$"
        }
    ]
}