{
    "hands_on_practices": [
        {
            "introduction": "To build faster multipliers, we must efficiently sum many partial products in parallel. The core of this process is the reduction of a \"bit heap\" using a tree of compressors. This exercise guides you through deriving a fundamental formula to calculate the exact number of $3:2$ compressors (full adders) needed to reduce any given bit heap, allowing you to quantify the hardware cost of a multiplier's reduction stage. By applying this formula to the bit heaps generated by a standard array multiplier versus one using Booth recoding , you will gain a concrete understanding of how algorithmic choices directly impact hardware complexity.",
            "id": "3652024",
            "problem": "Consider unsigned integer multiplication implemented at the bit level. A $3:2$ compressor (functionally identical to a full adder) takes three single-bit inputs of the same weight $2^{i}$ and produces two single-bit outputs: a sum bit at weight $2^{i}$ and a carry bit at weight $2^{i+1}$. A bit heap is described by its column height profile $\\{H_{i}\\}$, where $H_{i}$ is the number of one-bit signals initially present in column $i$ (weight $2^{i}$) before any compression. The goal of Wallace-style column compression is to reduce every column to at most two bits, using only $3:2$ compressors, with carries propagating to higher-weight columns.\n\nStarting from the core definitions of bit addition and $3:2$ compression, derive a formula that gives, for a general column height profile $\\{H_{i}\\}$, the minimal number of $3:2$ compressors required in each column (and hence in total) to reduce every column to at most two bits. Your derivation must account for carries generated by compression in lower-weight columns that enter higher-weight columns.\n\nThen apply your formula to the following two scientifically realistic column height profiles for $8$-bit by $8$-bit multiplication:\n\n- Array multiplier (schoolbook partial products): for $i = 0,1,\\dots,14$, \n$$\nH_{i}^{\\text{array}} = \n\\begin{cases}\ni+1, & 0 \\leq i \\leq 7, \\\\\n15 - i, & 8 \\leq i \\leq 14,\n\\end{cases}\n$$\nwhich explicitly is\n$$\n\\{H_{i}^{\\text{array}}\\}_{i=0}^{14} = \\{1,2,3,4,5,6,7,8,7,6,5,4,3,2,1\\}.\n$$\n\n- Radix-$4$ Booth recoding (no sign-correction bits present, four partial-product rows shifted by $0,2,4,6$): for $i = 0,1,\\dots,14$, the profile is\n$$\n\\{H_{i}^{\\text{Booth}}\\}_{i=0}^{14} = \\{1,1,2,2,3,3,4,4,3,3,2,2,1,1,0\\}.\n$$\n\nCompute the minimal number of $3:2$ compressors required for each profile and report the difference (array minus Booth) as a single real-valued number. No rounding is required. Express your final answer as a pure number without units.",
            "solution": "The problem asks for a derivation of a formula for the number of $3:2$ compressors required to reduce a bit heap, and then to apply this formula to two specific examples.\n\n### Part 1: Derivation of the General Formula\n\nA $3:2$ compressor, also known as a full adder, is a fundamental component in parallel multipliers. It takes three one-bit inputs of the same arithmetic weight, say $2^i$, and produces two one-bit outputs: a sum bit of weight $2^i$ and a carry bit of weight $2^{i+1}$. This operation can be represented as: $3$ bits at column $i \\rightarrow 1$ bit at column $i$ and $1$ bit at column $i+1$.\n\nLet's analyze the reduction of a single column $i$ with an initial height of $h$ bits. The goal is to reduce this height to at most $2$ using $3:2$ compressors. Each compressor reduces the number of bits in the current column by $3-1 = 2$. The reduction may require multiple stages.\n\nLet $h_0 = h$ be the initial height of the column.\nIn the first stage of reduction, we can apply $k_1 = \\lfloor h_0/3 \\rfloor$ compressors. These compressors consume $3k_1$ bits from the column.\nThe outputs are:\n1. $k_1$ sum bits, which remain in the current column $i$.\n2. $k_1$ carry bits, which are passed to the next higher-weight column, $i+1$.\n\nThe number of bits in column $i$ that were not processed by any compressor is $h_0 \\pmod 3$.\nTherefore, the new height of column $i$, after one stage of compression, is the sum of the sum bits produced and the unprocessed bits:\n$$h_1 = k_1 + (h_0 \\pmod 3) = \\lfloor \\frac{h_0}{3} \\rfloor + (h_0 \\pmod 3)$$\nIf $h_1 > 2$, this new set of $h_1$ bits must be further compressed. This process is repeated. Let $h_j$ be the height of the column at stage $j$. The reduction proceeds as:\n$$h_{j+1} = \\lfloor \\frac{h_j}{3} \\rfloor + (h_j \\pmod 3)$$\nThis continues until a stage $m$ is reached where $h_m \\le 2$.\n\nThe total number of compressors used in this column is the sum of the compressors used in each stage: $N_{\\text{comp}}(h) = \\sum_{j=0}^{m-1} k_{j+1} = \\sum_{j=0}^{m-1} \\lfloor h_j/3 \\rfloor$.\nSimilarly, the total number of carry bits generated and passed to the next column is $C_{\\text{out}}(h) = \\sum_{j=0}^{m-1} k_{j+1}$.\nThus, for a single column of initial height $h$, the number of compressors required, $N_{\\text{comp}}(h)$, is equal to the number of carries it generates, $C_{\\text{out}}(h)$.\n\nLet's define a function $f(h)$ that represents this quantity, $N_{\\text{comp}}(h) = C_{\\text{out}}(h)$.\nBased on the staged reduction, we can write a recursive formula for $f(h)$:\n- If $h \\le 2$, no compressors are needed, so $f(h) = 0$.\n- If $h > 2$, we use $\\lfloor h/3 \\rfloor$ compressors in the first stage, and the problem reduces to compressing a column of height $h' = \\lfloor h/3 \\rfloor + (h \\pmod 3)$. So, $f(h) = \\lfloor h/3 \\rfloor + f(\\lfloor h/3 \\rfloor + (h \\pmod 3))$.\n\nThis recursive formula allows us to calculate the number of compressors for any given column height.\n\nNow, consider a general bit heap profile $\\{H_i\\}$. The compression of columns is not independent due to the propagation of carries. The process must be performed sequentially from the least significant column ($i=0$) upwards.\n\nLet $N_i$ be the number of compressors used in column $i$, and let $C_i$ be the number of carries generated in column $i$ and passed to column $i+1$. As established, $N_i = C_i$.\nLet $H_i$ be the initial height of column $i$ from the problem statement.\nLet $H'_i$ be the total height of column $i$ before compression, which includes carries from the previous column.\nWe start with $C_{-1} = 0$.\n\nFor each column $i=0, 1, 2, \\dots$:\n1. The total height to be compressed is $H'_i = H_i + C_{i-1}$.\n2. The number of compressors required for this column is $N_i = f(H'_i)$.\n3. The number of carries passed to the next column is $C_i = N_i$.\n\nThis leads to the following recurrence relation for the number of compressors $N_i$ in each column $i$:\n$$N_i = f(H_i + N_{i-1}), \\quad \\text{with } N_{-1}=0$$\nwhere $f(h)$ is the recursive function defined previously. The total number of $3:2$ compressors for the entire bit heap is the sum over all columns:\n$$N_{\\text{total}} = \\sum_i N_i$$\nThis constitutes the general formula and procedure.\n\n### Part 2: Application to Specific Profiles\n\nFirst, we pre-compute the values of $f(h)$ for relevant heights $h$.\n$f(0)=0, f(1)=0, f(2)=0$\n$f(3) = \\lfloor 3/3 \\rfloor + f(1) = 1+0=1$\n$f(4) = \\lfloor 4/3 \\rfloor + f(2) = 1+0=1$\n$f(5) = \\lfloor 5/3 \\rfloor + f(3) = 1+1=2$\n$f(6) = \\lfloor 6/3 \\rfloor + f(2) = 2+0=2$\n$f(7) = \\lfloor 7/3 \\rfloor + f(3) = 2+1=3$\n$f(8) = \\lfloor 8/3 \\rfloor + f(4) = 2+1=3$\n$f(9) = \\lfloor 9/3 \\rfloor + f(3) = 3+1=4$\n$f(10) = \\lfloor 10/3 \\rfloor + f(4) = 3+1=4$\n$f(11) = \\lfloor 11/3 \\rfloor + f(5) = 3+2=5$\n$f(12) = \\lfloor 12/3 \\rfloor + f(4) = 4+1=5$\n$f(13) = \\lfloor 13/3 \\rfloor + f(5) = 4+2=6$\n\n**Profile 1: Array Multiplier**\nThe initial profile is $\\{H_{i}^{\\text{array}}\\}_{i=0}^{14} = \\{1,2,3,4,5,6,7,8,7,6,5,4,3,2,1\\}$.\nWe compute $N_i^{\\text{array}} = C_i^{\\text{array}} = f(H_i^{\\text{array}} + C_{i-1}^{\\text{array}})$ with $C_{-1}^{\\text{array}} = 0$.\n\n$i=0: H'_0 = 1+0=1 \\implies N_0^{\\text{array}} = f(1)=0$. $C_0=0$.\n$i=1: H'_1 = 2+0=2 \\implies N_1^{\\text{array}} = f(2)=0$. $C_1=0$.\n$i=2: H'_2 = 3+0=3 \\implies N_2^{\\text{array}} = f(3)=1$. $C_2=1$.\n$i=3: H'_3 = 4+1=5 \\implies N_3^{\\text{array}} = f(5)=2$. $C_3=2$.\n$i=4: H'_4 = 5+2=7 \\implies N_4^{\\text{array}} = f(7)=3$. $C_4=3$.\n$i=5: H'_5 = 6+3=9 \\implies N_5^{\\text{array}} = f(9)=4$. $C_5=4$.\n$i=6: H'_6 = 7+4=11 \\implies N_6^{\\text{array}} = f(11)=5$. $C_6=5$.\n$i=7: H'_7 = 8+5=13 \\implies N_7^{\\text{array}} = f(13)=6$. $C_7=6$.\n$i=8: H'_8 = 7+6=13 \\implies N_8^{\\text{array}} = f(13)=6$. $C_8=6$.\n$i=9: H'_9 = 6+6=12 \\implies N_9^{\\text{array}} = f(12)=5$. $C_9=5$.\n$i=10: H'_{10} = 5+5=10 \\implies N_{10}^{\\text{array}} = f(10)=4$. $C_{10}=4$.\n$i=11: H'_{11} = 4+4=8 \\implies N_{11}^{\\text{array}} = f(8)=3$. $C_{11}=3$.\n$i=12: H'_{12} = 3+3=6 \\implies N_{12}^{\\text{array}} = f(6)=2$. $C_{12}=2$.\n$i=13: H'_{13} = 2+2=4 \\implies N_{13}^{\\text{array}} = f(4)=1$. $C_{13}=1$.\n$i=14: H'_{14} = 1+1=2 \\implies N_{14}^{\\text{array}} = f(2)=0$. $C_{14}=0$.\n\nTotal compressors for array multiplier:\n$$N_{\\text{total}}^{\\text{array}} = 0+0+1+2+3+4+5+6+6+5+4+3+2+1+0 = 42$$\n\n**Profile 2: Radix-4 Booth Recoding**\nThe initial profile is $\\{H_{i}^{\\text{Booth}}\\}_{i=0}^{14} = \\{1,1,2,2,3,3,4,4,3,3,2,2,1,1,0\\}$.\nWe compute $N_i^{\\text{Booth}} = C_i^{\\text{Booth}} = f(H_i^{\\text{Booth}} + C_{i-1}^{\\text{Booth}})$ with $C_{-1}^{\\text{Booth}} = 0$.\n\n$i=0: H'_0 = 1+0=1 \\implies N_0^{\\text{Booth}} = f(1)=0$. $C_0=0$.\n$i=1: H'_1 = 1+0=1 \\implies N_1^{\\text{Booth}} = f(1)=0$. $C_1=0$.\n$i=2: H'_2 = 2+0=2 \\implies N_2^{\\text{Booth}} = f(2)=0$. $C_2=0$.\n$i=3: H'_3 = 2+0=2 \\implies N_3^{\\text{Booth}} = f(2)=0$. $C_3=0$.\n$i=4: H'_4 = 3+0=3 \\implies N_4^{\\text{Booth}} = f(3)=1$. $C_4=1$.\n$i=5: H'_5 = 3+1=4 \\implies N_5^{\\text{Booth}} = f(4)=1$. $C_5=1$.\n$i=6: H'_6 = 4+1=5 \\implies N_6^{\\text{Booth}} = f(5)=2$. $C_6=2$.\n$i=7: H'_7 = 4+2=6 \\implies N_7^{\\text{Booth}} = f(6)=2$. $C_7=2$.\n$i=8: H'_8 = 3+2=5 \\implies N_8^{\\text{Booth}} = f(5)=2$. $C_8=2$.\n$i=9: H'_9 = 3+2=5 \\implies N_9^{\\text{Booth}} = f(5)=2$. $C_9=2$.\n$i=10: H'_{10} = 2+2=4 \\implies N_{10}^{\\text{Booth}} = f(4)=1$. $C_{10}=1$.\n$i=11: H'_{11} = 2+1=3 \\implies N_{11}^{\\text{Booth}} = f(3)=1$. $C_{11}=1$.\n$i=12: H'_{12} = 1+1=2 \\implies N_{12}^{\\text{Booth}} = f(2)=0$. $C_{12}=0$.\n$i=13: H'_{13} = 1+0=1 \\implies N_{13}^{\\text{Booth}} = f(1)=0$. $C_{13}=0$.\n$i=14: H'_{14} = 0+0=0 \\implies N_{14}^{\\text{Booth}} = f(0)=0$. $C_{14}=0$.\n\nTotal compressors for Booth-recoded multiplier:\n$$N_{\\text{total}}^{\\text{Booth}} = 0+0+0+0+1+1+2+2+2+2+1+1+0+0+0 = 12$$\n\n### Part 3: Final Calculation\n\nThe problem asks for the difference in the number of compressors, which is:\n$$N_{\\text{total}}^{\\text{array}} - N_{\\text{total}}^{\\text{Booth}} = 42 - 12 = 30$$\nThe Booth-recoded multiplier requires $30$ fewer $3:2$ compressors than the array multiplier for this $8$-bit by $8$-bit case. This illustrates a primary advantage of Booth's algorithm: it reduces the number of partial products, leading to a smaller and faster reduction tree.",
            "answer": "$$\\boxed{30}$$"
        },
        {
            "introduction": "Radix-2 Booth recoding is a powerful technique for reducing the number of partial products by encoding runs of identical bits in the multiplier. This practice explores a compelling special case: multiplication by a negative power of two ($a = -2^k$). By working through the recoding process for this specific multiplicand , you will discover how the algorithm elegantly reduces the entire operation to a single shift and negation. This provides a clear illustration of Booth's efficiency and allows you to quantify the substantial latency improvement over a conventional array multiplier.",
            "id": "3652051",
            "problem": "An $N$-bit signed integer multiplier in two’s complement arithmetic multiplies a multiplicand $a$ by a multiplier $b$ by forming partial products and summing them. In radix-$2$ Booth recoding, contiguous runs of $1$ bits in the multiplicand are replaced by signed digits to reduce the number of nonzero partial products, which are then shifted versions of the multiplier with possible subtraction to account for negative digits. Consider the special case where the multiplicand is $a=-2^{k}$ with $0 \\leq k \\leq N-2$, and the multiplier $b$ is an arbitrary $N$-bit two’s complement integer.\n\nStarting only from the definitions of two’s complement representation and the radix-$2$ Booth recoding procedure, do the following:\n\n1. Derive, step by step, the Booth signed-digit sequence for $a=-2^{k}$ and show that the product $p=a \\cdot b$ reduces to a single negative shifted partial product. Explicitly identify the sign and the shift amount in terms of $k$, and express $p$ in terms of $b$ and $k$.\n\n2. To quantify latency, adopt a unit-delay logic-depth model where each idealized logic level contributes the same delay. For a canonical regular $N \\times N$ array multiplier (no carry-lookahead or carry-save compression; carries ripple along the array’s diagonals), argue from first principles about carries and sums that the critical path logic depth can be modeled as $2N+1$ levels from partial-product generation through the final carry-out. For the specialized datapath tailored to the $a=-2^{k}$ case that bypasses partial-product accumulation and instead computes $p$ by first shifting $b$ left by $k$ and then forming the two’s complement negation, assume the following components:\n- A $N$-bit Barrel Shifter (BS) built as $\\lceil \\log_{2}(N) \\rceil$ cascaded stages of $2:1$ multiplexers, contributing $\\lceil \\log_{2}(N) \\rceil$ logic levels of depth.\n- Bitwise inversion for the one’s-complement step of negation contributing $1$ logic level of depth.\n- A Parallel Prefix Adder (PPA) used as an incrementer to add $1$ in the two’s complement negation, with logic depth $\\lceil \\log_{2}(N) \\rceil$.\n\nUsing these assumptions, write the total critical-path logic depth for the array multiplier, and for the specialized datapath for $a=-2^{k}$, both as functions of $N$.\n\n3. Define the improvement factor $\\mathcal{I}(N)$ as the ratio of the array multiplier’s critical-path depth to that of the specialized datapath:\n$$\n\\mathcal{I}(N) \\equiv \\frac{\\text{array depth}}{\\text{specialized depth}}.\n$$\nEvaluate $\\mathcal{I}(32)$ exactly. Report your final answer as a single real number. No rounding is required, and no units are to be used in the final answer.",
            "solution": "This problem is divided into three parts. We will address each part sequentially, starting from the fundamental principles of two's complement arithmetic and digital logic design.\n\n### Part 1: Booth Recoding and Product Simplification\n\nThe first part of the problem asks for a derivation of the radix-$2$ Booth recoding for the multiplicand $a = -2^k$ and to show that the product $p = a \\cdot b$ simplifies to a single shifted partial product.\n\n**Step 1: Two's Complement Representation of $a = -2^k$**\n\nAn $N$-bit two's complement integer is represented by a bit vector $(a_{N-1}, a_{N-2}, \\dots, a_0)$. Its value is given by $-a_{N-1}2^{N-1} + \\sum_{i=0}^{N-2} a_i 2^i$. We need to find the bit vector corresponding to the value $-2^k$, for $0 \\leq k \\leq N-2$.\n\nLet's propose the bit representation where $a_i = 0$ for $i < k$ and $a_i=1$ for $i \\geq k$.\nThe bit string is $\\underbrace{11\\dots1}_{N-k \\text{ bits}} \\underbrace{00\\dots0}_{k \\text{ bits}}$.\n\nLet's verify the value of this representation:\nThe most significant bit is $a_{N-1}=1$. The other non-zero bits are $a_i=1$ for $k \\leq i \\leq N-2$.\nThe value is:\n$$ V = -1 \\cdot 2^{N-1} + \\sum_{i=k}^{N-2} 1 \\cdot 2^i $$\nThe summation is a geometric series:\n$$ \\sum_{i=k}^{N-2} 2^i = 2^k + 2^{k+1} + \\dots + 2^{N-2} = 2^k(1+2+\\dots+2^{N-2-k}) = 2^k \\left( \\frac{2^{N-1-k}-1}{2-1} \\right) = 2^k(2^{N-1-k}-1) = 2^{N-1} - 2^k $$\nSubstituting this back into the value expression:\n$$ V = -2^{N-1} + (2^{N-1} - 2^k) = -2^k $$\nThis confirms that the $N$-bit two's complement representation of $a = -2^k$ (for $k < N-1$) is a sequence of $1$s from bit position $N-1$ down to $k$, and $0$s for all bit positions less than $k$.\n\n**Step 2: Radix-2 Booth Recoding**\n\nThe radix-$2$ Booth recoding algorithm generates a signed-digit sequence $y = (y_{N-1}, \\dots, y_0)$ from the two's complement number $a = (a_{N-1}, \\dots, a_0)$. The digits are calculated as $y_i = a_{i-1} - a_i$, where $a_{-1}$ is implicitly defined as $0$. The value of $a$ is then represented as $\\sum_{i=0}^{N-1} y_i 2^i$.\n\nLet's apply this to the bit string for $a=-2^k$:\n- $a_i = 0$ for $i < k$.\n- $a_i = 1$ for $i \\geq k$.\n- $a_{-1} = 0$.\n\nWe compute the Booth digits $y_i$:\n- For $i < k$: We have $a_i = 0$ and $a_{i-1}=0$ (since $i-1 < k$). Thus, $y_i = a_{i-1} - a_i = 0 - 0 = 0$.\n- For $i = k$: We have $a_k = 1$ and $a_{k-1}=0$. Thus, $y_k = a_{k-1} - a_k = 0 - 1 = -1$.\n- For $i > k$: We have $a_i = 1$ and $a_{i-1}=1$ (since $i-1 \\geq k$). Thus, $y_i = a_{i-1} - a_i = 1 - 1 = 0$.\n\nThe resulting Booth signed-digit sequence is composed of all zeros, except for a single digit $y_k = -1$.\n\n**Step 3: Product Calculation**\n\nThe product $p = a \\cdot b$ is computed by summing the shifted partial products, where the $i$-th partial product is $y_i \\cdot b \\cdot 2^i$.\n$$ p = \\left( \\sum_{i=0}^{N-1} y_i 2^i \\right) \\cdot b = \\sum_{i=0}^{N-1} (y_i \\cdot b \\cdot 2^i) $$\nSince the only non-zero Booth digit is $y_k = -1$, the summation collapses to a single term:\n$$ p = y_k \\cdot b \\cdot 2^k = (-1) \\cdot b \\cdot 2^k = -(b \\cdot 2^k) $$\nThis result shows that the product $p=a \\cdot b$ is indeed a single partial product. This partial product is formed by shifting the multiplier $b$ left by $k$ positions and then taking its arithmetic negation.\n- The sign is negative.\n- The shift amount is $k$.\n- The expression for $p$ is $p = -(b \\cdot 2^k)$.\n\n### Part 2: Latency (Logic Depth) Analysis\n\nThis part requires modeling the critical-path logic depth for two multiplier implementations.\n\n**Canonical Array Multiplier**\n\nThe problem provides a model for the critical-path logic depth of a regular $N \\times N$ array multiplier as $2N+1$ levels. We are asked to argue for this model from first principles. A standard array multiplier consists of an array of AND gates to form bit-products, followed by an array of adders to sum these partial products.\n\nA plausible, simplified unit-delay model that results in this depth is as follows:\n1.  **Partial Product Generation**: The $N^2$ bit-products $a_i b_j$ are formed by $N^2$ AND gates operating in parallel. This step constitutes a single logic level. Depth: $1$.\n2.  **Carry-Save Adder Array**: The $N$ partial products are summed. In a ripple-style array, the critical path involves a signal propagating \"vertically\" through the array, passing through one adder per row. There are $N-1$ rows of adders required to reduce $N$ partial products to two vectors (a sum vector and a carry vector). This contributes $N-1$ logic levels. Depth: $N-1$.\n3.  **Final Vector-Merging Adder**: The final sum and carry vectors are added using a final-stage adder. For a ripple-carry adder (RCA) implementation handling the $N$ most significant bits of the product, the critical path is the carry propagation chain. This carry signal must ripple through $N$ bit-positions. This contributes $N$ logic levels. Depth: $N$.\n4.  **Final Carry-Out Logic**: The final carry-out of the $2N$-bit product, which determines the most significant product bit in some cases, often requires one final gate after the last carry has propagated through the final adder. This adds one more level to the critical path. Depth: $1$.\n\nSumming these contributions, the total critical-path logic depth is:\n$$ D_{\\text{array}}(N) = 1 + (N-1) + N + 1 = 2N+1 $$\nThis justifies the given model.\n\n**Specialized Datapath for $a = -2^k$**\n\nFrom Part 1, the product is $p = -(b \\cdot 2^k)$. This operation can be implemented with a specialized datapath consisting of a shifter and negation logic. The problem specifies the logic depth of each component. The operations are performed sequentially, so we sum their depths.\n\n1.  **Shift**: The multiplier $b$ is shifted left by $k$ positions. This is performed by an $N$-bit Barrel Shifter (BS), which has a specified depth of $\\lceil \\log_2(N) \\rceil$.\n2.  **Negation**: The shifted result is negated using two's complement. This is a two-step process:\n    a.  **One's Complement**: Bitwise inversion of the shifted result. This contributes $1$ logic level.\n    b.  **Increment**: Add $1$ to the inverted result. This is performed by a Parallel Prefix Adder (PPA) used as an incrementer, which has a specified depth of $\\lceil \\log_2(N) \\rceil$.\n\nThe total critical-path logic depth for the specialized datapath is the sum of these sequential stages:\n$$ D_{\\text{specialized}}(N) = D_{\\text{BS}} + D_{\\text{invert}} + D_{\\text{PPA}} = \\lceil \\log_2(N) \\rceil + 1 + \\lceil \\log_2(N) \\rceil = 2 \\lceil \\log_2(N) \\rceil + 1 $$\nSo, the two logic-depth functions are:\n- $D_{\\text{array}}(N) = 2N+1$\n- $D_{\\text{specialized}}(N) = 2 \\lceil \\log_2(N) \\rceil + 1$\n\n### Part 3: Improvement Factor Calculation\n\nThe improvement factor $\\mathcal{I}(N)$ is defined as the ratio of the two depths:\n$$ \\mathcal{I}(N) = \\frac{D_{\\text{array}}(N)}{D_{\\text{specialized}}(N)} = \\frac{2N+1}{2 \\lceil \\log_2(N) \\rceil + 1} $$\nWe are asked to evaluate this for $N=32$.\n\nFirst, we calculate the logic depth for each architecture with $N=32$.\nFor the array multiplier:\n$$ D_{\\text{array}}(32) = 2(32) + 1 = 64 + 1 = 65 $$\nFor the specialized datapath, we need $\\lceil \\log_2(32) \\rceil$. Since $32 = 2^5$, $\\log_2(32) = 5$, which is an integer. Thus, $\\lceil \\log_2(32) \\rceil = 5$.\n$$ D_{\\text{specialized}}(32) = 2 \\lceil \\log_2(32) \\rceil + 1 = 2(5) + 1 = 10 + 1 = 11 $$\nNow, we can compute the improvement factor $\\mathcal{I}(32)$:\n$$ \\mathcal{I}(32) = \\frac{D_{\\text{array}}(32)}{D_{\\text{specialized}}(32)} = \\frac{65}{11} $$\nThe problem asks for an exact real number. The fraction $\\frac{65}{11}$ is the exact representation.",
            "answer": "$$\\boxed{\\frac{65}{11}}$$"
        },
        {
            "introduction": "Translating an algorithm into a high-performance circuit requires navigating the physical constraints of timing and logic depth. This exercise places you in the role of a hardware architect tasked with designing a deeply pipelined 64-bit multiplier capable of operating at a multi-gigahertz clock frequency. Using a realistic timing model based on standard-cell delays , you will determine the minimum number of pipeline stages required by carefully partitioning the Booth recoder, Wallace reduction tree, and final parallel-prefix adder. This practice bridges the gap between algorithmic theory and the practical engineering trade-offs essential for modern processor design.",
            "id": "3652039",
            "problem": "You are designing a signed $N=64$ fixed-width integer multiplier using radix-$4$ Booth recoding, a Wallace-style tree of $3:2$ compressors, and a final carry-propagate adder (CPA) implemented as a parallel-prefix adder. The multiplier will be deeply pipelined with registers inserted only at stage boundaries that coincide with whole operations: Booth recoding and partial product selection, individual compressor levels in the reduction tree, and prefix levels inside the CPA. The target maximum clock frequency is $f_{\\max}=2~\\mathrm{GHz}$.\n\nUse the following realistic standard-cell timing model in a mature nanoscale complementary metal–oxide–semiconductor (CMOS) library:\n- Fanout-of-$4$ inverter delay $t_{\\mathrm{FO4}}=35~\\mathrm{ps}$.\n- Two-input gates $\\mathrm{AND2}$ or $\\mathrm{OR2}$: $1.0\\,t_{\\mathrm{FO4}}$.\n- Two-input $\\mathrm{XOR2}$: $2.0\\,t_{\\mathrm{FO4}}$.\n- Two-to-one multiplexer $\\mathrm{MUX2}$: $2.0\\,t_{\\mathrm{FO4}}$.\n- One full-adder based $3:2$ compressor level delay (sum/carry) including local interconnect: $2.6\\,t_{\\mathrm{FO4}}$.\n- Pipeline register (flip-flop) timing overhead per stage, including clock-to-$Q$, setup time, and local clock skew: $t_{\\mathrm{reg}}=80~\\mathrm{ps}$.\n\nArchitectural assumptions:\n- Radix-$4$ Booth recoding is applied to the $64$-bit multiplier operand, yielding $M=\\lceil N/2\\rceil$ partial-product rows aligned by wiring shifts. The Booth recoder and partial-product selection network per bit are realized by a decoder and a small multiplexer network that select from $\\{0,\\pm X,\\pm 2X\\}$, where $X$ is the multiplicand. Model the end-to-end delay of the complete recoding and partial-product generation block as $D_{\\mathrm{BR}}=7\\,t_{\\mathrm{FO4}}$.\n- The partial products are reduced by a Wallace tree of $3:2$ compressors and occasional $2:2$ compressors until only two rows remain. Model the height reduction per level as a factor of approximately $3/2$, and count the number of compressor levels $L$ required to reduce $M$ rows to $2$ rows by iterating the height reduction.\n- The CPA is a Kogge–Stone parallel-prefix adder with $\\lceil \\log_{2}(N)\\rceil$ prefix levels. Model each prefix level as $2.0\\,t_{\\mathrm{FO4}}$, the precompute generate/propagate formation as $1.0\\,t_{\\mathrm{FO4}}$, and the final sum $\\mathrm{XOR}$ as $2.0\\,t_{\\mathrm{FO4}}$. Ignore long-wire penalties beyond the given per-level delays.\n\nFundamental timing rule: the per-stage clock period must satisfy $T_{\\mathrm{clk}} \\ge t_{\\mathrm{reg}} + t_{\\mathrm{logic}}$, where $t_{\\mathrm{logic}}$ is the worst-case combinational delay within that stage. The target period is $T_{\\mathrm{clk}}=1/f_{\\max}$.\n\nTask:\n- Determine the minimum total number of pipeline stages required to meet $f_{\\max}=2~\\mathrm{GHz}$.\n- In your reasoning, explicitly compute $L$ for the Wallace tree and justify how many compressor levels can be grouped into one pipeline stage under the timing constraint. Also justify how many pipeline stages are needed inside the CPA.\n- You must assign which stage or stages are used for Booth recoding and partial-product selection, which for compressor levels, and which for the CPA, ensuring every stage meets the timing constraint.\n\nExpress your final answer as a single integer equal to the minimum number of pipeline stages. No rounding is required. Do not include any units in your final answer.",
            "solution": "The problem requires determining the minimum number of pipeline stages for a $64$-bit signed integer multiplier to operate at a maximum clock frequency of $f_{\\max}=2~\\mathrm{GHz}$. The design comprises three main parts: Booth recoding and partial product generation, a Wallace tree for partial product reduction, and a Kogge-Stone adder for the final summation. The solution involves calculating the delay of each part and partitioning them into pipeline stages such that the combinational logic delay in any stage does not exceed the maximum allowed value.\n\nFirst, we establish the fundamental timing constraints. The target maximum clock frequency is $f_{\\max}=2~\\mathrm{GHz}$, which corresponds to a minimum clock period of:\n$$T_{\\mathrm{clk}} = \\frac{1}{f_{\\max}} = \\frac{1}{2 \\times 10^9~\\mathrm{Hz}} = 0.5~\\mathrm{ns} = 500~\\mathrm{ps}$$\nThe timing rule for each pipeline stage is given by $T_{\\mathrm{clk}} \\ge t_{\\mathrm{reg}} + t_{\\mathrm{logic}}$. The pipeline register overhead is $t_{\\mathrm{reg}}=80~\\mathrm{ps}$. Therefore, the maximum allowable combinational logic delay within any single pipeline stage is:\n$$t_{\\mathrm{logic,max}} = T_{\\mathrm{clk}} - t_{\\mathrm{reg}} = 500~\\mathrm{ps} - 80~\\mathrm{ps} = 420~\\mathrm{ps}$$\nThe problem provides a standard-cell timing model based on the fanout-of-$4$ inverter delay, $t_{\\mathrm{FO4}} = 35~\\mathrm{ps}$. We can express the maximum logic delay in terms of this unit:\n$$t_{\\mathrm{logic,max}} = \\frac{420~\\mathrm{ps}}{35~\\mathrm{ps}/t_{\\mathrm{FO4}}} = 12~t_{\\mathrm{FO4}}$$\n\nNow, we analyze each part of the multiplier design to determine the number of stages required.\n\n1. Booth Recoding and Partial Product Generation\nThe problem states that the end-to-end delay of the radix-$4$ Booth recoder and partial product selection network is modeled as $D_{\\mathrm{BR}} = 7~t_{\\mathrm{FO4}}$. In absolute time, this delay is:\n$$D_{\\mathrm{BR}} = 7 \\times 35~\\mathrm{ps} = 245~\\mathrm{ps}$$\nSince this delay is less than the maximum allowable logic delay ($245~\\mathrm{ps} < 420~\\mathrm{ps}$), this entire block can be implemented within a single pipeline stage.\nNumber of stages for Booth recoding = $1$.\n\n2. Wallace Tree Reduction\nThe multiplier operand has a width of $N=64$ bits. With radix-$4$ Booth recoding, the number of partial products to be summed is given as $M = \\lceil N/2 \\rceil = \\lceil 64/2 \\rceil = 32$. The Wallace tree reduces these $32$ rows to $2$ rows using $3:2$ compressors. We must calculate the number of compressor levels, $L$, required for this reduction. Let $H_k$ be the number of rows after level $k$, with $H_0=32$. The number of rows is reduced at each level according to the formula $H_{k+1} = 2 \\cdot \\lfloor H_k/3 \\rfloor + (H_k \\pmod 3)$.\n- $H_0 = 32$\n- $H_1 = 2 \\cdot \\lfloor 32/3 \\rfloor + (32 \\pmod 3) = 2 \\cdot 10 + 2 = 22$\n- $H_2 = 2 \\cdot \\lfloor 22/3 \\rfloor + (22 \\pmod 3) = 2 \\cdot 7 + 1 = 15$\n- $H_3 = 2 \\cdot \\lfloor 15/3 \\rfloor + (15 \\pmod 3) = 2 \\cdot 5 + 0 = 10$\n- $H_4 = 2 \\cdot \\lfloor 10/3 \\rfloor + (10 \\pmod 3) = 2 \\cdot 3 + 1 = 7$\n- $H_5 = 2 \\cdot \\lfloor 7/3 \\rfloor + (7 \\pmod 3) = 2 \\cdot 2 + 1 = 5$\n- $H_6 = 2 \\cdot \\lfloor 5/3 \\rfloor + (5 \\pmod 3) = 2 \\cdot 1 + 2 = 4$\n- $H_7 = 2 \\cdot \\lfloor 4/3 \\rfloor + (4 \\pmod 3) = 2 \\cdot 1 + 1 = 3$\n- $H_8 = 2 \\cdot \\lfloor 3/3 \\rfloor + (3 \\pmod 3) = 2 \\cdot 1 + 0 = 2$\nThe reduction requires $L=8$ levels of compressors.\n\nThe delay of a single $3:2$ compressor level is given as $t_{\\mathrm{comp}} = 2.6~t_{\\mathrm{FO4}}$. In absolute time:\n$$t_{\\mathrm{comp}} = 2.6 \\times 35~\\mathrm{ps} = 91~\\mathrm{ps}$$\nTo minimize pipeline stages, we group as many compressor levels as possible into a single stage. The maximum number of levels per stage is:\n$$\\text{Levels per stage} = \\left\\lfloor \\frac{t_{\\mathrm{logic,max}}}{t_{\\mathrm{comp}}} \\right\\rfloor = \\left\\lfloor \\frac{420~\\mathrm{ps}}{91~\\mathrm{ps}} \\right\\rfloor = \\lfloor 4.615... \\rfloor = 4$$\nWith a total of $L=8$ levels and a maximum of $4$ levels per stage, the minimum number of stages for the Wallace tree is:\n$$\\text{Number of stages for Wallace tree} = \\left\\lceil \\frac{L}{4} \\right\\rceil = \\left\\lceil \\frac{8}{4} \\right\\rceil = 2$$\nThese two stages would comprise levels $1-4$ and levels $5-8$ of the compressor tree, respectively. The delay of each of these stages is $4 \\times 91~\\mathrm{ps} = 364~\\mathrm{ps}$, which is within the $420~\\mathrm{ps}$ budget.\n\n3. Final Carry-Propagate Adder (CPA)\nThe final adder is a $64$-bit Kogge-Stone parallel-prefix adder. Its operation can be broken down into three logical parts with specified delays:\n- Pre-computation of generate/propagate signals: $t_{\\mathrm{pre}} = 1.0~t_{\\mathrm{FO4}} = 35~\\mathrm{ps}$.\n- Prefix tree computation: The number of levels for $N=64$ is $\\lceil \\log_{2}(N) \\rceil = \\lceil \\log_{2}(64) \\rceil = 6$. The delay per level is $t_{\\mathrm{prefix}} = 2.0~t_{\\mathrm{FO4}} = 70~\\mathrm{ps}$.\n- Final sum XOR: $t_{\\mathrm{sum}} = 2.0~t_{\\mathrm{FO4}} = 70~\\mathrm{ps}$.\n\nThe problem allows inserting pipeline registers between these distinct operations (pre-computation, each prefix level, final sum). We must group these operations into the minimum number of stages. We apply a greedy approach to fill each stage's delay budget.\n- Stage CPA-1: Start with pre-computation ($35~\\mathrm{ps}$). We can add prefix levels.\n  - Delay with $k$ prefix levels: $t_{\\mathrm{pre}} + k \\cdot t_{\\mathrm{prefix}} = 35 + k \\cdot 70$.\n  - For $k=5$, the delay is $35 + 5 \\cdot 70 = 35 + 350 = 385~\\mathrm{ps}$. This is $\\le 420~\\mathrm{ps}$.\n  - For $k=6$, the delay is $35 + 6 \\cdot 70 = 35 + 420 = 455~\\mathrm{ps}$, which exceeds the budget.\n  - So, the first CPA stage can contain the pre-computation block and $5$ prefix levels. The delay is $385~\\mathrm{ps}$.\n- Stage CPA-2: The remaining logic consists of $1$ prefix level and the final sum XOR.\n  - The delay is $t_{\\mathrm{prefix}} + t_{\\mathrm{sum}} = 70~\\mathrm{ps} + 70~\\mathrm{ps} = 140~\\mathrm{ps}$.\n  - This is well within the $420~\\mathrm{ps}$ budget.\nThus, the CPA requires a minimum of $2$ pipeline stages.\n\nTotal Pipeline Stages\nTo find the total minimum number of pipeline stages for the entire multiplier, we sum the stages required for each part:\n$$N_{\\mathrm{stages}} = (\\text{Stages for Booth}) + (\\text{Stages for Wallace tree}) + (\\text{Stages for CPA})$$\n$$N_{\\mathrm{stages}} = 1 + 2 + 2 = 5$$\nThe final architecture consists of $5$ pipeline stages:\n- Stage $1$: Booth Recoding and Partial Product Generation (delay $245~\\mathrm{ps}$).\n- Stage $2$: Wallace Tree Compressor Levels $1-4$ (delay $364~\\mathrm{ps}$).\n- Stage $3$: Wallace Tree Compressor Levels $5-8$ (delay $364~\\mathrm{ps}$).\n- Stage $4$: CPA Pre-computation and Prefix Levels $1-5$ (delay $385~\\mathrm{ps}$).\n- Stage $5$: CPA Prefix Level $6$ and Final Sum (delay $140~\\mathrm{ps}$).\n\nAll stages satisfy the timing constraint $t_{\\mathrm{logic}} \\le 420~\\mathrm{ps}$. Therefore, the minimum total number of pipeline stages is $5$.",
            "answer": "$$\\boxed{5}$$"
        }
    ]
}