{
    "hands_on_practices": [
        {
            "introduction": "整数溢出并不仅仅是一个理论概念，它在实际编程中有着实实在在的影响。本练习将通过一个经典的计算任务——阶乘，来帮助你直观感受固定大小的整型数据类型的局限性。通过从第一性原理出发，你将确定一个32位有符号整数所能表示的最大阶乘值，从而深刻理解在处理快速增长的数值序列时，预先考虑数据范围的重要性。",
            "id": "3651585",
            "problem": "在一门系统编程课程中，一个软件例程被实现用于计算阶乘 $n!$，该例程使用补码表示法的32位有符号整数类型。在补码中，一个w位有符号整数的范围是从 $-2^{w-1}$ 到 $2^{w-1}-1$。该例程按顺序累积乘积 $1 \\cdot 2 \\cdot 3 \\cdots n$，并将其存储在一个32位有符号整数变量中。如果真实数学结果的大小超出了可表示范围，硬件会引发溢出条件。\n\n从阶乘 $n!$（对于 $n \\in \\mathbb{N}$）的形式化定义以及32位有符号补码整数的可表示范围出发，请从第一性原理进行推理，以确定最大的整数 $n$，使得用这种类型计算 $n!$ 不会发生溢出。你的推导必须证明为何任何更大的 $n$ 都必然会导致溢出，且不能依赖未经证明的快捷公式。\n\n此外，请基于单调函数和保序变换的基本性质，解释如何设计一个有数学原理支持的预检查，以便在对大的 $n$ 执行乘法之前检测即将发生的溢出，并简要说明在这种情况下何时有必要切换到任意精度（大整数）算术。无需提供代码；重点在于推理和数学论证。\n\n只需报告最大的 $n$ 作为最终答案。无需四舍五入，也不涉及单位。",
            "solution": "该问题要求确定最大的整数 $n$，使其阶乘 $n!$ 可以在使用补码表示的32位有符号整数变量中存储而不会导致溢出。\n\n首先，我们确定可表示值的范围。问题陈述，对于一个 $w$ 位的补码有符号整数，其范围是 $[ -2^{w-1}, 2^{w-1}-1 ]$。对于本问题，位宽 $w$ 为 $32$。因此，一个32位有符号整数的范围是 $[ -2^{32-1}, 2^{32-1}-1 ]$，简化后为 $[ -2^{31}, 2^{31}-1 ]$。\n\n可表示的最大正整数，我们称之为 $V_{max}$，是 $2^{31}-1$。为了找到其数值，我们可以计算 $2^{31}$：\n$$ 2^{31} = 2 \\cdot 2^{30} = 2 \\cdot (2^{10})^{3} = 2 \\cdot (1024)^{3} = 2 \\cdot 1,073,741,824 = 2,147,483,648 $$\n因此，最大值为 $V_{max} = 2,147,483,648 - 1 = 2,147,483,647$。\n\n阶乘函数 $n!$ 对非负整数 $n$ 定义为所有小于等于 $n$ 的正整数的乘积：\n$$ n! = \\prod_{k=1}^{n} k $$\n对于任何 $n \\ge 0$，$n!$ 的值都是非负的。因此，为避免溢出，计算出的 $n!$ 值不得超过 $V_{max}$。该条件是 $n! \\le 2^{31}-1$。\n\n我们现在将从 $n=1$ 开始，为递增的 $n$ 计算 $n!$ 的值，并将其与 $V_{max}$ 进行比较。\n$1! = 1$\n$2! = 2$\n$3! = 6$\n$4! = 24$\n$5! = 120$\n$6! = 720$\n$7! = 5,040$\n$8! = 40,320$\n$9! = 362,880$\n$10! = 3,628,800$\n$11! = 10! \\cdot 11 = 3,628,800 \\cdot 11 = 39,916,800$\n$12! = 11! \\cdot 12 = 39,916,800 \\cdot 12 = 479,001,600$\n\n我们检查 $12!$ 是否在可表示范围内：\n$479,001,600 \\le 2,147,483,647$。这个不等式成立。因此，$12!$ 可以被正确计算和存储。\n\n接下来，我们计算 $n=13$ 时的值：\n$13! = 12! \\cdot 13 = 479,001,600 \\cdot 13 = 6,227,020,800$\n\n我们检查 $13!$ 是否在可表示范围内：\n$6,227,020,800 \\le 2,147,483,647$。这个不等式不成立。因此，计算 $13!$ 会产生一个太大而无法存储的值，从而导致溢出。\n\n为了证明 $n=12$ 是满足条件的最大整数，我们必须证明对于任何大于12的整数 $m$，$m!$ 同样会导致溢出。这依赖于阶乘函数的单调性。函数 $f(n) = n!$ 对于 $n \\ge 1$ 是严格单调递增的。这可以通过考虑连续项的比率来证明：对于 $n \\ge 1$，有 $(n+1)! = (n+1) \\cdot n!$。因为 $n+1  1$，所以 $(n+1)!  n!$。由于阶乘函数是严格递增的，并且我们已经确定 $13!  V_{max}$，所以对于任何整数 $m  13$，必有 $m! = m \\cdot (m-1) \\cdots 14 \\cdot 13!  13!$。既然 $13!$ 已经超过了 $V_{max}$，那么对于 $m \\ge 13$ 的任何阶乘 $m!$ 也将超过 $V_{max}$。因此，在32位有符号整数中计算 $n!$ 而不发生溢出的最大整数 $n$ 是 12。\n\n关于设计一个用于检测即将发生的溢出的预检查，让我们考虑 $n!$ 的迭代计算。在第 $k$ 步（$k$ 从 $2$ 到 $n$），我们通过将前一个乘积 $(k-1)!$ 乘以 $k$ 来计算新的乘积。设 $P_{k-1} = (k-1)!$。在计算 $P_k = P_{k-1} \\cdot k$ 之前，我们必须检查此操作是否会溢出。如果 $P_{k-1} \\cdot k  V_{max}$，就会发生溢出。\n执行乘法来检查这个条件是自相矛盾的，因为乘法本身就是我们想要在溢出时避免的操作。相反，我们可以重新整理这个不等式。对于正整数 $k$，函数 $g(x) = x/k$ 是一个严格递增函数，这意味着它是一个保序变换。将此变换应用于不等式不会改变其方向。因此，对于 $k0$，条件 $P_{k-1} \\cdot k  V_{max}$ 在数学上等价于 $P_{k-1}  V_{max}/k$。\n这个检查在计算上是安全的。在第 $k$ 步开始时，$P_{k-1}$ 的值已知是有效的并被正确存储。该检查涉及一个除法（对于整数可以执行整数除法）和一个比较，两者都是安全的操作。如果检查 $P_{k-1}  V_{max}/k$ 为真，则溢出即将发生，不应执行乘法。\n\n最后，当问题域要求对大小超过固定大小硬件整数类型限制的数进行精确整数计算时，任意精度（大整数）算术就变得必要了。阶乘函数 $n!$ 是超指数级增长的。如上所示，$13!$ 会使32位整数溢出。类似地，可以证明 $21!$ 会使64位有符号整数（其最大值为 $2^{63}-1 \\approx 9.22 \\times 10^{18}$）溢出。对于密码学、数论或符号计算等领域中需要计算较大数的精确阶乘（例如 $100!$）的应用，固定精度算术在根本上是不够的。这类应用必须使用软件库，这些库使用动态数据结构（如数字数组）来表示数字，并提供相应的算术运算算法，其数字大小仅受可用内存限制，而不受固定位宽的限制。",
            "answer": "$$ \\boxed{12} $$"
        },
        {
            "introduction": "当算术运算的结果超出可表示范围时，处理器并非毫无反应，而是通过设置特定的状态标志位来发出信号。本练习要求你构建一个测试平台，系统地观察在二进制补码减法运算中，进位标志位（CF）与溢出标志位（OF）是如何随着操作数的变化而改变状态的。通过亲自实现并分析这些标志位的行为模式，你将深入理解CPU在硬件层面处理算术异常的核心机制。",
            "id": "3651567",
            "problem": "你需要实现一个完整、可运行的程序，为具有固定字宽 $w$ 的二进制补码算术构建一个减法测试平台。该测试平台在保持 $b$ 固定的同时，将被减数 $a$ 在一个连续的带符号值集合上以步长 $1$（按带符号顺序）进行扫描，并记录当 $a$ 递增 $1$ 时，进位标志（CF）和溢出标志（OF）各自状态改变的位置。\n\n基本基础和必要语义：\n- 在固定宽度为 $w$ 的补码中，算术运算是模 $2^w$ 进行的。减法 $a - b$ 定义为 $a$ 与 $b$ 的补码进行补码加法，然后进行模 $2^w$ 约减。\n- 减法的进位标志（CF）定义为在无符号解释下，$w$ 位减法中从最高有效位借出的位。\n- 减法的溢出标志（OF）由带符号补码语义定义：它指示 $w$ 位结果（解释为 $[-2^{w-1}, 2^{w-1} - 1]$ 范围内的带符号补码整数）是否未能表示带符号操作数的真实数学差值。\n\n你的程序必须：\n1. 对于每个测试用例，将 $a$ 和 $b$ 解释为 $w$ 位补码整数，即在适当的情况下对输入和输出值使用模 $2^w$ 的表示，并执行所有模 $2^w$ 的算术运算。\n2. 对于每个测试用例，按带符号顺序以步长 $1$ 扫描从 $a_{\\mathrm{low}}$ 到 $a_{\\mathrm{high}}$（含）的 $a$，并计算每次操作 $a - b$ 的 CF 和 OF。\n3. 将标志 $F \\in \\{\\mathrm{CF}, \\mathrm{OF}\\}$ 的一个转换点定义为带符号值 $k$，使得 $F$ 在 $a = k$ 处的值与其在前一个带符号值 $a = k - 1$ 处的值不同（两者均在扫描区间内）。\n4. 对于每个测试用例，记录两个带符号整数列表：所有 CF 转换点的列表和所有 OF 转换点的列表，每个都表示为发生转换时对应的带符号 $a$ 值。\n\n约束和建模要求：\n- 所有计算必须严格使用 $w$ 位补码语义进行，与机器的原生整数宽度无关。你必须通过与 $2^w - 1$ 进行掩码操作，将中间值和最终值显式地约减为模 $2^w$。\n- 除了这些补码算术中减法的 CF 和 OF 标准定义外，不要假设任何特定于体系结构的特性。\n\n要实现的测试套件：\n- 情况 1：$w = 8$，$b = 1$，$a \\in [-4, 4]$。\n- 情况 2：$w = 8$，$b = 0$，$a \\in [-4, 4]$。\n- 情况 3：$w = 8$，$b = -128$，$a \\in [-4, 4]$。\n- 情况 4：$w = 8$，$b = -1$，$a \\in [-4, 4]$。\n- 情况 5：$w = 8$，$b = -1$，$a \\in [124, 127]$。\n\n输出规范：\n- 你的程序应生成一行输出，包含用方括号括起来的逗号分隔列表形式的结果。\n- 对于每个测试用例，输出一个双元素列表：第一个元素是 CF 转换点（带符号 $a$ 值）的列表，第二个元素是 OF 转换点（带符号 $a$ 值）的列表。\n- 将每个测试用例的双元素列表按照上面列出的顺序聚合到一个单一的外层列表中。\n- 最终输出必须不含空格，并且 $a$ 值只能使用十进制整数。例如，一个包含两个测试用例的输出可能看起来像 $[[[0,1],[]],[[2],[3]]]$。\n\n此问题不需要物理单位、角度单位或百分比。答案仅为整数。程序必须是自包含的，且不得读取任何输入。",
            "solution": "该问题要求实现一个测试平台，以在一系列补码减法运算中识别进位标志（CF）和溢出标志（OF）的转换点。被减数 $a$ 在指定范围内扫描，而减数 $b$ 保持固定。算术运算在固定字宽 $w$ 下进行。\n\n一个严谨的解决方案需要对底层的算术原理和标志定义进行精确的形式化。\n\n**1. 补码算术**\n\n在一个 $w$ 位补码系统中，带符号范围 $[-2^{w-1}, 2^{w-1} - 1]$ 内的整数 $x$ 由一个 $w$ 位无符号整数表示，我们将其记为位模式 $X$。该映射定义为 $X = x \\pmod{2^w}$。所有算术运算都以模 $2^w$ 进行。对于此问题，给定 $w=8$，因此带符号范围是 $[-128, 127]$，算术运算以模 $2^8 = 256$ 进行。\n\n减法 $s = a - b$ 是通过将 $b$ 的补码加到 $a$ 上来计算的。$b$ 的补码是 $(\\neg B) + 1$，其中 $B$ 是 $b$ 的位模式，$\\neg$ 表示按位取反。因此，结果的位模式 $S$ 计算如下：\n$$S = (A + (\\neg B + 1)) \\pmod{2^w}$$\n这等价于对位模式进行无符号减法：\n$$S = (A - B) \\pmod{2^w}$$\n在我们的实现中，我们可以使用标准整数类型，并应用 $2^w - 1$ 的位掩码来确保所有结果都被正确截断为 $w$ 位。对于 $w=8$，此掩码为 $0\\text{xFF}$。\n\n**2. 减法进位标志（CF）的定义**\n\n问题将进位标志（CF）定义为在无符号减法过程中从最高有效位（MSB）位置的借位。当 $A$ 和 $B$ 都被视为无符号整数时，当且仅当 $A$ 小于 $B$ 时，减法 $A - B$ 才需要借位。\n因此，进位标志的逻辑是：\n$$\\text{CF} = \\begin{cases} 1  \\text{if } A   B \\\\ 0  \\text{if } A \\ge B \\end{cases}$$\n其中 $A$ 和 $B$ 分别是带符号整数 $a$ 和 $b$ 的 $w$ 位无符号表示。\n\n**3. 减法溢出标志（OF）的定义**\n\n溢出标志（OF）指示带符号运算的结果无法在 $w$ 位补码范围内表示。对于减法 $s = a - b$，只有当操作数 $a$ 和 $b$ 符号不同时才可能发生溢出。\n- 如果 $a$ 是正数而 $b$ 是负数，它们的差 $a-b$ 是一个大的正数。如果这个真实结果超过 $2^{w-1}-1$，则发生溢出。\n- 如果 $a$ 是负数而 $b$ 是正数，它们的差 $a-b$ 是一个大的负数。如果这个真实结果小于 $-2^{w-1}$，则发生溢出。\n\n设 $s(x)$ 是整数 $x$ 的 $w$ 位表示的符号位（MSB）。对于非负数，符号位为 $0$，对于负数，符号位为 $1$。设 $s_{computed}$ 是减法 $w$ 位结果的符号。当且仅当操作数的符号不同，且结果的符号与被减数 $a$ 的符号不同时，发生溢出。\n$$\\text{OF} = 1 \\iff (s(a) \\neq s(b)) \\land (s(s_{computed}) \\neq s(a))$$\n这可以使用位运算高效地实现。设 $A$、$B$ 和 $S$ 分别是 $a$、$b$ 和计算结果 $s$ 的 $w$ 位模式。符号位是第 $(w-1)$ 位。\n$$\\text{OF} = \\left(\\frac{A \\oplus B}{2^{w-1}}\\right) \\land \\left(\\frac{A \\oplus S}{2^{w-1}}\\right)$$\n其中 $\\oplus$ 是按位异或运算符，除法是整数除法（等效于右移）。当且仅当 $(A, B)$ 的 MSB 不同且 $(A, S)$ 的 MSB 不同时，此表达式的值为 $1$。\n\n**4. 检测转换的算法**\n\n标志的转换点是扫描范围中的一个值 $k$，在该点标志的状态与其在 $k-1$ 时的状态发生变化。问题规定 $k$ 和 $k-1$ 都必须位于扫描区间 $[a_{\\mathrm{low}}, a_{\\mathrm{high}}]$ 内。这意味着第一个可能的转换点是 $k = a_{\\mathrm{low}} + 1$。\n\n对于给定的测试用例（$w, b, a_{\\mathrm{low}}, a_{\\mathrm{high}}$），算法如下：\n1. 为 CF 和 OF 转换点初始化空列表。\n2. 从带符号整数 $b$ 确定减数 $B$ 的位模式。\n3. 计算标志的初始状态。为操作 $(a_{\\mathrm{low}} - b)$ 计算 $\\text{CF}_{\\text{prev}}$ 和 $\\text{OF}_{\\text{prev}}$。\n4. 使用带符号整数 $a$ 从 $a_{\\mathrm{low}} + 1$ 迭代到 $a_{\\mathrm{high}}$（含）。这个循环变量 $a$ 代表潜在的转换点 $k$。\n5. 在循环内部，对于每个 $a$ 值：\n    a. 确定被减数 $A$ 的位模式。\n    b. 为操作 $(a - b)$ 计算当前标志 $\\text{CF}_{\\text{curr}}$ 和 $\\text{OF}_{\\text{curr}}$。\n    c. 如果 $\\text{CF}_{\\text{curr}} \\neq \\text{CF}_{\\text{prev}}$，则将 $a$ 记录为 CF 转换点。\n    d. 如果 $\\text{OF}_{\\text{curr}} \\neq \\text{OF}_{\\text{prev}}$，则将 $a$ 记录为 OF 转换点。\n    e. 更新前一个标志状态：$\\text{CF}_{\\text{prev}} = \\text{CF}_{\\text{curr}}$ 和 $\\text{OF}_{\\text{prev}} = \\text{OF}_{\\text{curr}}$。\n6. 循环完成后，收集到的列表包含给定测试用例的所有转换点。\n7. 对所有测试用例重复此过程，并按规定格式化输出。\n\n此过程正确地识别了扫描范围内每个标志值与前一个整数处的值不同的点，满足了所有问题要求。",
            "answer": "[[[0,1],[]],[[],[]],[[0],[0]],[[-1,0],[]],[[],[127]]]"
        },
        {
            "introduction": "硬件层面的算术行为（如补码环绕）是确定且可预测的，但在高级编程语言（如C语言）中，有符号整数溢出却被定义为“未定义行为”，这给编译器留下了优化的空间，同时也带来了安全隐患。本练习旨在弥合硬件与软件之间的这道鸿沟，你将通过编写代码，在不触发未定义行为的前提下，精确模拟32位整数运算的硬件行为。通过对比环绕、饱和及真实数学结果，你将清晰地辨析不同层级上处理溢出的差异，并理解其在软件开发中的重要意义。",
            "id": "3651582",
            "problem": "你的任务是编写一个完整的、可运行的程序，在不调用任何未定义行为的情况下，分析 C 语言编译器所假定的有符号溢出行为与典型的二进制补码硬件所执行的实际模运算之间的差异。对于一组给定的整数算术测试用例，你的程序必须为每个用例计算四个量，这些量可以清晰地归因有符号溢出、无符号回绕以及硬件状态标志行为之间的区别。\n\n使用以下基本原理：\n- 带符号 $w$ 位整数的二进制补码表示将无符号值 $u \\in [0,2^w-1]$ 映射到有符号值 $s \\in [-2^{w-1},2^{w-1}-1]$，规则为：若 $u  2^{w-1}$，则 $s = u$；否则 $s = u - 2^w$。\n- 对于机器级的 $w$ 位字无符号算术，加法和乘法均按模 $2^w$ 执行。\n- 对于 $w$ 位字的二进制补码有符号算术，数学上正确的和或积可能会超出可表示的有符号范围 $[-2^{w-1},2^{w-1}-1]$。硬件的模运算结果仍然存在，但该结果的有符号解释在可表示范围之外不等于真实的数学值。概念上的有符号溢出事件对应于真实数学值落在 $[-2^{w-1},2^{w-1}-1]$ 之外的情况。\n- 在机器层面，如果真实的无符号和至少为 $2^w$，则无符号加法会产生一个进位输出。对于乘法，当且仅当真实的无符号积至少为 $2^w$ 时，$2w$ 位乘积的高 $w$ 位非零。\n\n使用固定的 $w=32$ 位宽度。你绝不能依赖 C 语言原生的有符号溢出，因为这是未定义行为。相反，应通过使用更宽的精确域和显式的模 $2^{32}$ 映射来模拟 $32$ 位算术，从而根据上述原则推导出所有结果。\n\n对于每个测试用例，给定：\n- 一个操作选择器，属于 $\\{ \\text{add}, \\text{mul} \\}$。\n- 两个有符号操作数 $a, b \\in [-2^{31},2^{31}-1]$，它们应被解释为 $32$ 位二进制补码整数。\n\n对于每个测试用例，按此确切顺序计算并输出以下四个值：\n1) 二进制补码回绕结果：真实的无符号 $32$ 位模运算结果（模 $2^{32}$ 加法或模 $2^{32}$ 乘法）的低 $32$ 位的有符号解释。\n2) 饱和结果：真实的数学结果被钳位到区间 $[-2^{31},2^{31}-1]$ 内。\n3) 有符号溢出指示器：如果真实的数学结果在 $[-2^{31},2^{31}-1]$ 之外，则为 $1$，否则为 $0$。\n4) 无符号溢出指示器：\n   - 对于加法：进位输出位，视为 $\\{0,1\\}$ 中的整数。\n   - 对于乘法：$64$ 位乘积的高 $32$ 位是否非零，视为 $\\{0,1\\}$ 中的整数。\n\n仅使用上述定义，从第一性原理推导这些值。特别要避免任何对 C 语言原生类型实现定义的宽度的依赖。相反，通过在严格更大的精确整数空间中工作，并应用显式的模 $2^{32}$ 掩码和二进制补码映射来模拟 $32$ 位算术。\n\n测试套件：\n- 加法用例：\n  1) add 操作，$a=1000$，$b=2000$。\n  2) add 操作，$a=2147483647$，$b=1$。\n  3) add 操作，$a=-2147483648$，$b=-1$。\n  4) add 操作，$a=1073741824$，$b=1073741824$。\n  5) add 操作，$a=-2147483648$，$b=2147483647$。\n- 乘法用例：\n  6) mul 操作，$a=46340$，$b=46340$。\n  7) mul 操作，$a=46341$，$b=46341$。\n  8) mul 操作，$a=2147483647$，$b=2$。\n  9) mul 操作，$a=-2147483648$，$b=2$。\n  10) mul 操作，$a=-2147483648$，$b=-1$。\n\n你的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的结果应按上述测试套件的顺序排列，每个测试用例的四个整数连续列出。因此，该行必须恰好包含 $40$ 个整数。不允许有任何其他输出。本问题不涉及物理单位。角度不适用。将所有指示器值表示为普通整数 $0$ 或 $1$。",
            "solution": "问题要求分析 $32$ 位整数算术，特别是要区分运算的真实数学结果与硬件实现二进制补码算术时产生的回绕行为结果。一个关键约束是避免调用 C 语言中的未定义行为，这种行为在有符号整数溢出时发生。解决方案必须从问题陈述中提供的二进制补码算术的第一性原理推导出来。\n\n核心策略是使用更宽的整数类型执行所有计算，该类型可以表示所有中间和最终结果而不会溢出。鉴于任务操作的是 $w=32$ 位整数，标准的 C `long long` 和 `unsigned long long` 类型（C23 标准保证其至少为 $64$ 位宽）可作为合适的“更宽的精确域”。\n\n设两个有符号 $32$ 位输入操作数为 $a$ 和 $b$，其中 $a, b \\in [-2^{31}, 2^{31}-1]$。\n\n首先，我们必须确定 $a$ 和 $b$ 的无符号 $32$ 位整数表示（即位模式），我们将其表示为 $u_a$ 和 $u_b$。问题定义了从无符号值 $u$ 到有符号值 $s$ 的映射。我们需要其逆映射。在二进制补码中，一个有符号整数 $s$ 对应一个无符号整数 $u$，使得 $u \\equiv s \\pmod{2^w}$。对于 $w=32$：\n- 若 $s \\ge 0$，则 $u = s$。\n- 若 $s  0$，则 $u = s + 2^{32}$。\n在 C 语言中，对于一个有符号值 `s_val`，可以通过将其强制转换为 `unsigned long long` 并应用一个 $32$ 位掩码来模拟此转换：`(unsigned long long)s_val  0xFFFFFFFFULL`。这样可以得到无符号值 $u_a$ 和 $u_b$，它们是底层机器级无符号算术的操作数。\n\n在确定了 $a$、$b$、$u_a$ 和 $u_b$ 之后，我们就可以计算四个输出所需的量。\n\n1.  **真实数学结果 ($T$)**：这是在纯数学中执行运算的结果，不受固定位宽的限制。我们使用 $64$ 位有符号整数计算它，以确保结果是精确的，即使它超出了 $32$ 位范围。\n    $$ T_{add} = (\\text{long long})a + (\\text{long long})b $$\n    $$ T_{mul} = (\\text{long long})a \\times (\\text{long long})b $$\n\n2.  **真实无符号结果 ($U_{64}$)**：这是将运算应用于无符号表示 $u_a$ 和 $u_b$ 的结果。对于乘法，这需要一个 $2w = 64$ 位的结果才能精确。\n    $$ U_{64, add} = (\\text{unsigned long long})u_a + (\\text{unsigned long long})u_b $$\n    $$ U_{64, mul} = (\\text{unsigned long long})u_a \\times (\\text{unsigned long long})u_b $$\n\n从这两个精确结果 $T$ 和 $U_{64}$，我们可以推导出指定的四个输出值。设 $S_{min} = -2^{31}$ 且 $S_{max} = 2^{31}-1$。\n\n**输出 1：二进制补码回绕结果**\n这是真实无符号结果的低 $32$ 位的有符号解释。一个 $w$ 位运算的机器级结果是 $U_{64} \\pmod {2^w}$。设这个 $32$ 位无符号模式为 $u_{res} = U_{64} \\pmod {2^{32}}$。我们应用问题中提供的二进制补码解释规则：\n- 若 $u_{res}  2^{31}$，则有符号结果为 $u_{res}$。\n- 若 $u_{res} \\ge 2^{31}$，则有符号结果为 $u_{res} - 2^{32}$。\n\n**输出 2：饱和结果**\n这是真实数学结果 $T$ 被钳位到可表示的有符号 $32$ 位范围 $[S_{min}, S_{max}]$。\n$$ \\text{Saturating Result} = \\begin{cases} S_{max}  \\text{if } T  S_{max} \\\\ S_{min}  \\text{if } T  S_{min} \\\\ T  \\text{otherwise} \\end{cases} $$\n\n**输出 3：有符号溢出指示器**\n如果真实数学结果 $T$ 落在可表示的有符号 $32$ 位范围之外，则此指示器为 $1$，否则为 $0$。\n$$ \\text{Signed-Overflow} = (T  S_{min} \\lor T > S_{max}) ? 1 : 0 $$\n\n**输出 4：无符号溢出指示器**\n此指示器的定义取决于运算。\n- 对于加法，如果真实的无符号和 $U_{64, add}$ 大于或等于 $2^{32}$（对应于最高有效位的进位输出），则为 $1$。\n  $$ \\text{Unsigned-Overflow}_{add} = (U_{64, add} \\ge 2^{32}) ? 1 : 0 $$\n- 对于乘法，如果 $64$ 位乘积 $U_{64, mul}$ 的高 $32$ 位非零，则为 $1$。这等价于乘积大于或等于 $2^{32}$。\n  $$ \\text{Unsigned-Overflow}_{mul} = (U_{64, mul} \\gg 32 \\neq 0) ? 1 : 0 $$\n\n这种系统化的方法，即使用更宽的数据类型来模拟算术，然后应用指定的定义，可以正确计算所有所需的值，而无需依赖任何实现定义的或未定义的行为。该逻辑为每个测试用例实现，以生成最终输出。",
            "answer": "[3000,3000,0,0,-2147483648,2147483647,1,0,2147483647,-2147483648,1,1,-2147483648,2147483647,1,0,-1,-1,0,1,2147483600,2147483647,0,0,-2147483647,2147483647,1,0,-2,2147483647,1,1,0,-2147483648,1,1,-2147483648,2147483647,1,1]"
        }
    ]
}