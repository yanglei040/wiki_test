{
    "hands_on_practices": [
        {
            "introduction": "理论知识需要通过实践来巩固。第一个练习将让你直面数据类型的存储极限。我们将使用一个增长极快的数学函数——阶乘，来精确地找出标准32位有符号整数能够表示的最大阶乘值。这个计算过程不仅能帮助你理解溢出的根本原因，即有限的存储空间无法容纳无限增长的数值，还能让你对计算机处理数值的尺度限制建立起直观的认识 。",
            "id": "3651585",
            "problem": "在系统编程课程中，一个软件例程被实现用于计算阶乘 $n!$，它使用一个基于补码表示法的 $32$ 位有符号整型。在补码中，一个有符号的 $w$ 位整数的范围是从 $-2^{w-1}$ 到 $2^{w-1}-1$。该例程按顺序累积乘积 $1 \\cdot 2 \\cdot 3 \\cdots n$，并将其存储在单个 $32$ 位有符号整型变量中。如果真实数学结果的绝对值超出了可表示的范围，硬件会引发溢出条件。\n\n从 $n \\in \\mathbb{N}$ 的阶乘 $n!$ 的正式定义以及 $32$ 位有符号补码整数的可表示范围出发，请从第一性原理进行推理，以确定使得用此类型计算 $n!$ 不会发生溢出的最大整数 $n$。你的推导过程必须证明为何任何更大的 $n$ 必然导致溢出，且不依赖未经证明的简便公式。\n\n此外，请基于单调函数和保序变换的基本性质，解释如何设计一个有数学原理支持的预检查，以便在对大的 $n$ 执行乘法之前检测即将发生的溢出，并简要说明在这种情况下何时需要切换到任意精度（大整数）算术。不要提供代码；重点在于推理和数学证明。\n\n报告最大的 $n$ 作为你的最终答案。无需四舍五入，也不涉及单位。",
            "solution": "该问题要求确定最大的整数 $n$，使其阶乘 $n!$ 可以在使用补码表示的 $32$ 位有符号整型变量中存储而不导致溢出。\n\n首先，我们确定可表示值的范围。根据题目陈述，对于一个 $w$ 位补码有符号整数，其范围是 $[ -2^{w-1}, 2^{w-1}-1 ]$。对于本题，位宽 $w$ 为 $32$。因此，一个 $32$ 位有符号整数的范围是 $[ -2^{31}, 2^{31}-1 ]$，简化后为 $[ -2^{31}, 2^{31}-1 ]$。\n\n可表示的最大正整数，我们称之为 $V_{max}$，是 $2^{31}-1$。为了求其数值，我们可以计算 $2^{31}$：\n$$ 2^{31} = 2 \\cdot 2^{30} = 2 \\cdot (2^{10})^{3} = 2 \\cdot (1024)^{3} \\approx 2 \\cdot 1.074 \\times 10^9 = 2.148 \\times 10^9 $$\n$2^{31} = 2,147,483,648$。\n因此，最大值为 $V_{max} = 2,147,483,648 - 1 = 2,147,483,647$。\n\n阶乘函数 $n!$ 对非负整数 $n$ 定义为所有小于等于 $n$ 的正整数的乘积：\n$$ n! = \\prod_{k=1}^{n} k $$\n对于任何 $n \\ge 0$，$n!$ 的值都是非负的。因此，为避免溢出，计算出的 $n!$ 的值必须不超过 $V_{max}$。条件是 $n! \\le 2,147,483,647$。\n\n现在我们从 $n=1$ 开始，为递增的 $n$ 计算 $n!$ 的值，并将其与 $V_{max}$ 进行比较。\n$1! = 1$\n$2! = 2$\n$3! = 6$\n$4! = 24$\n$5! = 120$\n$6! = 720$\n$7! = 5,040$\n$8! = 40,320$\n$9! = 362,880$\n$10! = 3,628,800$\n$11! = 10! \\cdot 11 = 3,628,800 \\cdot 11 = 39,916,800$\n$12! = 11! \\cdot 12 = 39,916,800 \\cdot 12 = 479,001,600$\n\n我们检查 $12!$ 是否在可表示范围内：\n$479,001,600 \\le 2,147,483,647$。这个不等式成立。因此，$12!$ 可以被正确计算和存储。\n\n接下来，我们计算 $n=13$ 时的值：\n$13! = 12! \\cdot 13 = 479,001,600 \\cdot 13 = 6,227,020,800$\n\n我们检查 $13!$ 是否在可表示范围内：\n$6,227,020,800 \\le 2,147,483,647$。这个不等式不成立。因此，计算 $13!$ 会产生一个大到无法存储的值，从而导致溢出。\n\n为了证明 $n=12$ 是满足条件的最大整数，我们必须证明对于任何整数 $m > 12$，$m!$ 也会导致溢出。这依赖于阶乘函数的单调性。函数 $f(n) = n!$ 对于 $n \\ge 1$ 是严格单调递增的。这可以通过考虑连续项的比率来证明：对于 $n \\ge 1$，$(n+1)! = (n+1) \\cdot n!$。因为 $n+1 > 1$，可得 $(n+1)! > n!$。\n因为阶乘函数是严格递增的，并且我们已经确定 $13! > V_{max}$，所以必然对于任何整数 $m \\ge 13$，有 $m! = m \\cdot (m-1) \\cdots 14 \\cdot 13! > 13!$。既然 $13!$ 已经超过了 $V_{max}$，那么对于 $m \\ge 13$ 的任何阶乘 $m!$ 也将超过 $V_{max}$。\n因此，能够在一个 $32$ 位有符号整数中计算而不会溢出的最大整数 $n$ 是 $12$。\n\n关于设计一个预检查来检测即将发生的溢出，我们考虑 $n!$ 的迭代计算。在第 $k$ 步（其中 $k$ 从 $2$ 到 $n$），我们通过将前一个乘积 $(k-1)!$ 乘以 $k$ 来计算新的乘积。设 $P_{k-1} = (k-1)!$。在计算 $P_k = P_{k-1} \\cdot k$ 之前，我们必须检查此操作是否会溢出。如果 $P_{k-1} \\cdot k > V_{max}$，就会发生溢出。\n为了检查这个条件而执行乘法是弄巧成拙的，因为如果乘法会溢出，它本身就是我们想要避免的操作。相反，我们可以重新整理这个不等式。对于一个正整数 $k$，函数 $g(x) = x/k$ 是一个严格递增函数，这意味着它是一个保序变换。对不等式应用此变换不会改变其方向。因此，对于 $k>0$，条件 $P_{k-1} \\cdot k > V_{max}$ 在数学上等价于 $P_{k-1} > V_{max}/k$。\n这个检查在计算上是安全的。在第 $k$ 步开始时，值 $P_{k-1}$ 已知是有效的并且被正确存储。该检查涉及一个除法（对于整数可以执行整除）和一个比较，两者都是安全的操作。如果检查 $P_{k-1} > V_{max}/k$ 为真，则溢出即将发生，不应执行该乘法。\n\n最后，当问题域要求对量级超过固定大小硬件整型限制的数进行精确整数计算时，任意精度（大整数）算术就变得必要。阶乘函数 $n!$ 呈超指数增长。如前所示，$13!$ 会使一个 $32$ 位整数溢出。类似地，可以证明 $21!$ 会使一个 $64$ 位有符号整数溢出（其最大值为 $2^{63}-1 \\approx 9.22 \\times 10^{18}$）。对于密码学、数论或符号计算等领域中需要对较大数（例如 $100!$）进行精确阶乘计算的应用，固定精度算术从根本上说是不足的。这类应用必须使用软件库，这些库使用动态数据结构（如数字数组）来表示数字，并提供相应的算术运算算法，其数字的大小仅受可用内存限制，而非固定的位宽。",
            "answer": "$$ \\boxed{12} $$"
        },
        {
            "introduction": "理解了溢出何时发生后，下一个关键问题是：溢出发生时，计算机会做什么？这个问题的答案并不简单，尤其是在高级编程语言（如C语言）和底层硬件之间存在差异时。本练习将通过编写代码，深入探究硬件的模运算回绕（wraparound）行为与C语言标准中“未定义行为”（Undefined Behavior）之间的重要区别。掌握这一区别对于编写安全、可靠的系统级代码至关重要 。",
            "id": "3651582",
            "problem": "您的任务是编写一个完整的、可运行的程序，该程序在任何情况下都不会调用未定义行为，用于分析 C 编程语言中编译器假定的有符号溢出行为与典型的二补数硬件执行的实际模运算之间的差异。您的程序必须为一组给定的整数算术测试用例，计算出每个用例的四个量，以便清楚地区分有符号溢出、无符号回绕以及硬件状态标志的行为。\n\n使用以下基本原理：\n- 有符号 $w$ 位整数的二补数表示法将无符号值 $u \\in [0,2^w-1]$ 映射到有符号值 $s \\in [-2^{w-1},2^{w-1}-1]$，规则为：若 $u  2^{w-1}$，则 $s = u$；否则 $s = u - 2^w$。\n- 对于 $w$ 位字长的机器级无符号算术，加法和乘法均以 $2^w$ 为模执行。\n- 对于 $w$ 位字长的二补数有符号算术，数学上正确的和或积可能会超出可表示的有符号范围 $[-2^{w-1},2^{w-1}-1]$。硬件的模运算结果仍然存在，但该结果的有符号解释在可表示范围之外不等于真实的数学值。概念上的有符号溢出事件对应于真实的数学值位于 $[-2^{w-1},2^{w-1}-1]$ 之外。\n- 在机器级别，如果真实的无符号和至少为 $2^w$，则无符号加法会产生一个进位输出。对于乘法，当且仅当真实的无符号积至少为 $2^w$ 时，$2w$ 位乘积的高 $w$ 位非零。\n\n请使用固定的 $w=32$ 位宽进行操作。您绝不能依赖 C 的原生有符号溢出，因为这是未定义行为。相反，您应通过使用更宽的精确域和显式的模 $2^{32}$ 映射来模拟 $32$ 位算术，并从上述原理推导出所有结果。\n\n对于每个测试用例，您将获得：\n- 一个操作选择器，来自 $\\{ \\text{add}, \\text{mul} \\}$。\n- 两个有符号操作数 $a,b \\in [-2^{31},2^{31}-1]$，它们应被解释为 $32$ 位二补数整数。\n\n对于每个测试用例，请按此确切顺序计算并输出以下四个值：\n1) 二补数回绕结果：真实的无符号 $32$ 位模运算结果（模 $2^{32}$ 加法或模 $2^{32}$ 乘法）的低 $32$ 位的有符号解释。\n2) 饱和结果：将真实的数学结果钳位到区间 $[-2^{31},2^{31}-1]$ 内。\n3) 有符号溢出指示符：如果真实的数学结果在 $[-2^{31},2^{31}-1]$ 范围之外，则为 $1$，否则为 $0$。\n4) 无符号溢出指示符：\n   - 对于加法：进位输出位，视为 $\\{0,1\\}$ 中的整数。\n   - 对于乘法：$64$ 位乘积的高 $32$ 位是否非零，视为 $\\{0,1\\}$ 中的整数。\n\n请仅使用上述定义，从第一性原理推导出这些值。特别要避免任何对 C 原生类型实现定义宽度的依赖。相反，应通过在更宽的严格精确整数空间中工作，并应用显式的模 $2^{32}$ 掩码和二补数映射来模拟 $32$ 位算术。\n\n测试套件：\n- 加法用例：\n  1) add，其中 $a=1000$，$b=2000$。\n  2) add，其中 $a=2147483647$，$b=1$。\n  3) add，其中 $a=-2147483648$，$b=-1$。\n  4) add，其中 $a=1073741824$，$b=1073741824$。\n  5) add，其中 $a=-2147483648$，$b=2147483647$。\n- 乘法用例：\n  6) mul，其中 $a=46340$，$b=46340$。\n  7) mul，其中 $a=46341$，$b=46341$。\n  8) mul，其中 $a=2147483647$，$b=2$。\n  9) mul，其中 $a=-2147483648$，$b=2$。\n  10) mul，其中 $a=-2147483648$，$b=-1$。\n\n您的程序必须生成单行输出，其中包含一个由方括号括起来的逗号分隔列表，列表内容为上述测试用例所隐含顺序的结果，每个测试用例的四个整数连续排列。因此，该行必须恰好包含 $40$ 个整数。不允许有其他输出。本问题不涉及物理单位。角度不适用。将所有指示符值表示为纯整数 $0$ 或 $1$。",
            "solution": "解决此问题的核心策略是使用更宽的整数类型（保证至少为64位）执行所有计算，以确保可以表示所有中间和最终的数学结果而不会溢出，从而避免C语言中的未定义行为。\n\n首先，对于给定的32位有符号输入$a$和$b$，我们需要确定它们对应的32位无符号位模式$u_a$和$u_b$。根据补码定义，有符号值$s$对应的无符号值$u$满足$u \\equiv s \\pmod{2^{32}}$。这可以通过将有符号值转换为无符号长整型并应用32位掩码来实现，从而得到$u_a$和$u_b$。\n\n有了$a, b, u_a, u_b$后，我们可以计算出所需的四个量：\n\n1.  **真实数学结果 ($T$)**：使用64位有符号整数进行计算，以确保结果精确，即使它超出了32位范围。\n    - $T_{add} = (\\text{long long})a + (\\text{long long})b$\n    - $T_{mul} = (\\text{long long})a \\times (\\text{long long})b$\n\n2.  **真实无符号结果 ($U_{64}$)**：将运算应用于无符号表示$u_a$和$u_b$，同样使用64位无符号整数以保证精确。\n    - $U_{64, add} = (\\text{unsigned long long})u_a + (\\text{unsigned long long})u_b$\n    - $U_{64, mul} = (\\text{unsigned long long})u_a \\times (\\text{unsigned long long})u_b$\n\n基于精确的$T$和$U_{64}$，我们可以推导出四个输出值。设32位有符号整数的最小值为 $S_{min} = -2^{31}$，最大值为 $S_{max} = 2^{31}-1$。\n\n**输出 1：二补数回绕结果**\n这是机器级运算的结果，即真实无符号结果的低32位 ($u_{res} = U_{64} \\pmod{2^{32}}$)，然后按照补码规则解释为有符号数。\n- 如果 $u_{res}  2^{31}$，有符号结果为 $u_{res}$。\n- 如果 $u_{res} \\ge 2^{31}$，有符号结果为 $u_{res} - 2^{32}$。\n\n**输出 2：饱和结果**\n将真实数学结果$T$钳位到可表示的32位有符号范围$[S_{min}, S_{max}]$内。\n- 如果 $T > S_{max}$，结果为 $S_{max}$。\n- 如果 $T  S_{min}$，结果为 $S_{min}$。\n- 否则，结果为 $T$。\n\n**输出 3：有符号溢出指示符**\n如果真实数学结果$T$超出了可表示的32位有符号范围，则为1，否则为0。\n- $(T  S_{min} \\lor T > S_{max}) ? 1 : 0$\n\n**输出 4：无符号溢出指示符**\n此指示符的定义取决于操作：\n- 对于加法，如果真实无符号和$U_{64, add} \\ge 2^{32}$，则为1（表示有进位），否则为0。\n- 对于乘法，如果64位乘积$U_{64, mul}$的高32位非零（即$U_{64, mul} \\ge 2^{32}$），则为1，否则为0。\n\n这种系统化的方法可以正确计算所有所需的值，而无需依赖任何实现定义或未定义的行为。该逻辑将依次应用于每个测试用例，以生成最终输出。",
            "answer": "```\n[3000, 3000, 0, 0, -2147483648, 2147483647, 1, 0, 2147483647, -2147483648, 1, 1, -2147483648, 2147483647, 1, 0, -1, -1, 0, 0, 2147395600, 2147395600, 0, 0, -2147479015, 2147483647, 1, 0, -2, 2147483647, 1, 0, 0, -2147483648, 1, 1, -2147483648, 2147483647, 1, 1]\n```"
        },
        {
            "introduction": "在检测和观察溢出之后，我们将更进一步，学习如何主动地设计系统来防止溢出。这个练习将挑战你像硬件工程师一样思考，通过第一性原理推导出需要多少额外的“保护位”（guard bits），才能确保一系列加法操作绝对不会导致累加器溢出。这个原理在数字信号处理（DSP）和高性能计算等领域中是设计可靠累加器的基石 。",
            "id": "3651590",
            "problem": "数字信号路径中的一个定点累加器被实现为一个无符号定宽寄存器，该寄存器恰好可以容纳 $n$ 位。每个输入采样是一个 $n$ 位的无符号整数。该累加器从 $0$ 开始，每个时钟周期将一个相同的输入累加到自身。累加过程使用标准的模 $2^n$ 算术运算，并带有一个溢出标志位。当且仅当任何周期中的真实数学和超出了可表示范围 $\\{0,1,\\dots,2^{n}-1\\}$ 时，该溢出标志位被置位。\n\n要求您从基本原理出发，推导在对多个 $n$ 位量求和时的最坏情况溢出，以及为确保在累加 $k$ 个采样期间不发生溢出所需增加的“保护位”数量。\n\n引导您推理的任务如下：\n\n1) 仅使用 $n$ 位无符号数范围的定义和上述溢出的定义，确定最小的正整数 $k_{\\min}(n)$，该整数具有以下“必然溢出”的性质：对于任意固定的非零 $n$ 位无符号值 $x$，从 $0$ 开始，将 $k_{\\min}(n)$ 个相同的 $x$ 值累加到一个 $n$ 位累加器中的过程，必定在第 $k_{\\min}(n)$ 次加法时或之前发生溢出。\n\n2) 现在假设累加器的宽度可以增加 $g$ 个保护位，使得累加器可以容纳 $n+g$ 位，而每个输入采样仍为 $n$ 位。请从基本原理出发，以闭式形式确定 $k$ 的最小整数函数 $g(k)$，使得对于任何 $k$ 个 $n$ 位无符号输入序列（不一定相同），从 $0$ 开始累加到一个 $(n+g)$ 位累加器中都不会发生溢出。\n\n请以最简形式给出 $g(k)$ 的单一闭式表达式作为最终答案。不需要四舍五入，也不涉及单位。",
            "solution": "该问题要求求解与定点累加器溢出相关的两个量。首先，我们将分析对相同输入求和的情景，以找到一个保证溢出的点。其次，我们将确定在对任意数量的输入求和时，为防止溢出所需的保护位数。\n\n**第一部分：保证溢出所需的最小加法次数**\n\n一个 $n$ 位无符号整数寄存器可以表示集合 $\\{0, 1, 2, \\dots, 2^n-1\\}$ 中的值。当真实数学和大于或等于 $2^n$ 时，发生溢出。\n\n我们正在对一个固定的非零 $n$ 位无符号值 $x$ 的 $k$ 个相同副本进行求和。$x$ 的值在范围 $\\{1, 2, \\dots, 2^n-1\\}$ 内。从 $0$ 开始，将 $x$ 加到累加器中 $j$ 次后，真实和为 $S_j = j \\cdot x$。如果在第 $k_{\\min}(n)$ 次加法或之前发生溢出，则存在一个整数 $j$（$1 \\le j \\le k_{\\min}(n)$），使得 $S_j \\ge 2^n$。\n\n问题要求的是对*每一个*可能的非零 $x$ 选择，都能保证此性质的最小整数 $k_{\\min}(n)$。为了找到这样一个“最坏情况”的界限，我们必须考虑最不容易导致溢出的输入 $x$。当 $x$ 最小时，和 $S_j = j \\cdot x$ 增长得最慢。最小的非零 $n$ 位无符号整数是 $x=1$。如果我们能找到一个对 $x=1$ 保证溢出的 $k_{\\min}(n)$，那么它也同样能保证对任何 $x > 1$ 的情况溢出，因为 $j \\cdot x \\ge j \\cdot 1$。\n\n对于 $x=1$，第 $j$ 次加法后的真实和是 $S_j=j$。第一次发生溢出是在和达到 $2^n$ 时，这恰好发生在第 $j=2^n$ 次加法时。因此，对于 $x=1$，需要恰好 $2^n$ 次加法才能引起第一次溢出。\n\n要*保证*对任何非零 $x$ 都发生溢出，我们必须有 $k_{\\min}(n) \\ge 2^n$。我们来检验 $k_{\\min}(n) = 2^n$ 是否足够。我们需要证明对于任何 $x \\in \\{1, 2, \\dots, 2^n-1\\}$，在第 $2^n$ 步或之前必定发生溢出。即证明存在一个 $j \\in \\{1, 2, \\dots, 2^n\\}$ 使得 $j \\cdot x \\ge 2^n$。假设不发生溢出，则对于所有 $j \\le 2^n$，都有 $j \\cdot x  2^n$。这也必须对 $j=2^n$ 成立，得到不等式 $2^n \\cdot x  2^n$。由于 $x$ 是一个正整数（$x \\ge 1$），这意味着 $x  1$，这与 $x \\ge 1$ 的前提相矛盾。因此，溢出必定会在某个 $j \\le 2^n$ 时发生。具有此性质的最小整数是 $k_{\\min}(n)=2^n$。\n\n**第二部分：防止溢出所需的保护位数**\n\n现在我们要对 $k$ 个可能不同的 $n$ 位无符号输入 $x_1, x_2, \\dots, x_k$ 求和。累加器被加宽到 $n+g$ 位，可表示范围为 $\\{0, 1, \\dots, 2^{n+g}-1\\}$。\n\n为了防止溢出，真实和 $S_k = \\sum_{i=1}^k x_i$ 绝不能超过累加器的最大可表示值。\n$$ S_k \\le 2^{n+g} - 1 $$\n为保证这一点，我们必须针对最坏情况进行设计，即和 $S_k$ 达到最大值 $S_{max}$ 的情况。当每个输入 $x_i$ 都取其最大可能值 $2^n-1$ 时，和达到最大。\n$$ S_{max} = \\sum_{i=1}^k (2^n - 1) = k(2^n - 1) $$\n因此，防止溢出的条件是找到满足以下条件的最小整数 $g$：\n$$ k(2^n - 1) \\le 2^{n+g} - 1 $$\n我们可以使用一个更严格但更易于处理的条件来简化分析：和 $S_k$ 必须小于第一个不可表示的整数 $2^{n+g}$。\n$$ S_{max}  2^{n+g} \\implies k(2^n - 1)  2^{n+g} $$\n由于 $k(2^n-1)  k \\cdot 2^n$，如果我们能确保 $k \\cdot 2^n \\le 2^{n+g}$，那么溢出就肯定不会发生。\n$$ k \\cdot 2^n \\le 2^{n+g} $$\n$$ k \\le \\frac{2^{n+g}}{2^n} = 2^g $$\n我们必须找到满足 $k \\le 2^g$ 的最小整数 $g$。对两边取以 $2$ 为底的对数（假设 $k \\ge 1$）：\n$$ \\log_2(k) \\le g $$\n由于 $g$ 必须是整数，满足此条件的最小整数 $g$ 是 $\\log_2(k)$ 的向上取整。\n$$ g(k) = \\lceil \\log_2(k) \\rceil $$\n这个结果与 $n$ 无关，满足了问题的要求。例如，累加 $k=8$ 个 $n$ 位数，最大和约为 $8 \\cdot 2^n = 2^3 \\cdot 2^n = 2^{n+3}$，因此需要 $g=3$ 个保护位。我们的公式给出 $g(8) = \\lceil\\log_2(8)\\rceil = 3$，与直觉相符。\n\n所要求的最终答案是 $g(k)$ 的单一闭式表达式。",
            "answer": "$$ \\boxed{\\lceil \\log_2(k) \\rceil} $$"
        }
    ]
}