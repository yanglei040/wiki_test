{
    "hands_on_practices": [
        {
            "introduction": "浮点算术的一个典型特征是，我们所熟知的许多实数算术定律（如结合律）并不总是成立。这个练习将探讨一个经典的例子：表达式 $(0.1 + 0.2) - 0.3$。通过从第一性原理出发，计算这个表达式在 `binary64` 格式下的值 ，你将亲身体验到十进制小数在二进制表示下的固有误差，以及这种误差如何通过一系列运算累积并导致令人惊讶的结果。",
            "id": "3641928",
            "problem": "一个处理器实现了电气和电子工程师协会 (IEEE) 754 binary64（双精度）浮点格式，采用向最接近的值舍入，若相等则舍入到偶数（round-to-nearest, ties-to-even）的规则。在这种格式中，每个规格化的有限数值都表示为\n$$\n(-1)^{s} \\times (1.f)_{2} \\times 2^{E},\n$$\n其中 $s \\in \\{0,1\\}$ 是符号位，$f$ 是一个 $52$ 位的小数部分（隐藏的前导 $1$ 构成一个 $53$ 位的有效数），$E = e_{\\mathrm{bias}} - 1023$，其中 $e_{\\mathrm{bias}}$ 是存储的 $11$ 位偏置指数。“向最接近的值舍入，若相等则舍入到偶数”的规则会选择在 $\\mathbb{R}$ 中最接近的可表示值，如果恰好位于两个可表示值的中间，则选择有效数为偶数的那个。\n\n十进制常数 $0.1$，$0.2$ 和 $0.3$ 首先各自根据此舍入规则被转换为最接近的 binary64 值，然后表达式 $(0.1 + 0.2) - 0.3$ 按此顺序求值，加法后进行一次舍入，减法后进行一次舍入，两次都遵循相同的规则。\n\n仅使用上述定义以及关于二进制规格化和舍入的基本原理，确定硬件在 binary64 格式和“向最接近的值舍入，若相等则舍入到偶数”的规则下，为 $(0.1 + 0.2) - 0.3$ 生成的确切实数值。将你的最终答案表示为一个精确的 2 的幂（不要用小数近似）。",
            "solution": "解题的原理是首先将每个十进制常数转换为其最接近的 IEEE 754 binary64 表示，然后按顺序执行指定的算术运算，并在每一步应用舍入规则。binary64 格式使用一个 $53$ 位的有效数（一个隐含的前导位和 $52$ 个显式的小数位）。通过将有效数视为 $53$ 位整数，可以精确地分析算术运算。\n\n一个规格化的浮点数表示为 $v = (-1)^s \\times M \\times 2^E$，其中 $M$ 是满足 $1 \\le M  2$ 的有效数，$E$ 是指数。有效数 $M$ 使用 $52$ 位来存储其小数部分，这意味着它可以写成 $M = K \\cdot 2^{-52}$ 的形式，其中 $K$ 是一个满足 $2^{52} \\le K  2^{53}$ 的整数。因此，该数的值可以表示为 $v = (-1)^s \\times K \\times 2^{E-52}$。我们将为每个值确定整数有效数 $K$ 和有效指数。舍入规则是“向最接近的值舍入，若相等则舍入到偶数”。\n\n\\textbf{步骤 1：将十进制常数转换为 binary64}\n\n\\textbf{转换 $0.1$：}\n我们希望将 $0.1$ 表示为 $M \\times 2^E$ 的形式，其中 $1 \\le M  2$。指数 $E$ 通过 $E = \\lfloor \\log_2(0.1) \\rfloor = \\lfloor -3.3219... \\rfloor = -4$ 求得。\n理想的有效数是 $M_{0.1, \\text{ideal}} = 0.1 \\times 2^4 = 1.6$。\n为了找到对应的 $53$ 位整数有效数 $K$，我们乘以 $2^{52}$。\n$K_{0.1, \\text{ideal}} = 1.6 \\times 2^{52} = \\frac{8}{5} \\times 2^{52} = \\frac{2^3 \\times 2^{52}}{5} = \\frac{2^{55}}{5}$。\n$2^{55} = 36028797018963968$。\n$K_{0.1, \\text{ideal}} = \\frac{36028797018963968}{5} = 7205759403792793.6$。\n这个值不是整数。我们必须将其舍入到最接近的 $53$ 位整数。候选值是 $K_a = 7205759403792793$ 和 $K_b = 7205759403792794$。由于 $0.6$ 大于 $0.5$，我们向上舍入。\n整数有效数是 $K_{0.1} = 7205759403792794$。\n$0.1$ 的 binary64 表示，我们称之为 $X_{0.1}$，是：\n$X_{0.1} = (K_{0.1} \\cdot 2^{-52}) \\times 2^{-4} = 7205759403792794 \\times 2^{-56}$。\n\n\\textbf{转换 $0.2$：}\n我们将 $0.2$ 表示为 $M \\times 2^E$。指数是 $E = \\lfloor \\log_2(0.2) \\rfloor = \\lfloor -2.3219... \\rfloor = -3$。\n理想的有效数是 $M_{0.2, \\text{ideal}} = 0.2 \\times 2^3 = 1.6$。\n这与 $0.1$ 的理想有效数相同。因此，它会舍入到相同的整数有效数。\n$K_{0.2} = 7205759403792794$。\n$0.2$ 的 binary64 表示，记为 $X_{0.2}$，是：\n$X_{0.2} = (K_{0.2} \\cdot 2^{-52}) \\times 2^{-3} = 7205759403792794 \\times 2^{-55}$。\n\n\\textbf{转换 $0.3$：}\n我们将 $0.3$ 表示为 $M \\times 2^E$。指数是 $E = \\lfloor \\log_2(0.3) \\rfloor = \\lfloor -1.7369... \\rfloor = -2$。\n理想的有效数是 $M_{0.3, \\text{ideal}} = 0.3 \\times 2^2 = 1.2$。\n理想的整数有效数是 $K_{0.3, \\text{ideal}} = 1.2 \\times 2^{52} = \\frac{6}{5} \\times 2^{52} = \\frac{3 \\times 2^{53}}{5}$。\n$2^{53} = 9007199254740992$。\n$K_{0.3, \\text{ideal}} = \\frac{3 \\times 9007199254740992}{5} = \\frac{27021597764222976}{5} = 5404319552844595.2$。\n这个值不是整数。我们必须将其舍入到最接近的整数。候选值是 $K_c = 5404319552844595$ 和 $K_d = 5404319552844596$。由于 $0.2$ 小于 $0.5$，我们向下舍入。\n整数有效数是 $K_{0.3} = 5404319552844595$。\n$0.3$ 的 binary64 表示，记为 $X_{0.3}$，是：\n$X_{0.3} = (K_{0.3} \\cdot 2^{-52}) \\times 2^{-2} = 5404319552844595 \\times 2^{-54}$。\n\n\\textbf{步骤 2：计算和 $(X_{0.1} + X_{0.2})$}\n要将 $X_{0.1}$ 和 $X_{0.2}$ 相加，我们必须首先对齐它们的指数。我们使用较小的指数 $-56$。\n$X_{0.1} = 7205759403792794 \\times 2^{-56}$\n$X_{0.2} = 7205759403792794 \\times 2^{-55} = (2 \\times 7205759403792794) \\times 2^{-56} = 14411518807585588 \\times 2^{-56}$。\n精确的和 $S_{\\text{exact}}$ 是：\n$S_{\\text{exact}} = (7205759403792794 + 14411518807585588) \\times 2^{-56} = 21617278211378382 \\times 2^{-56}$。\n得到的整数有效数 $21617278211378382$ 是一个 $55$ 位整数（因为 $2^{54}  21617...  2^{55}$）。为了规格化，我们必须用一个 $53$ 位的整数有效数来表示这个结果。这需要调整指数。\n$S_{\\text{exact}} = (21617278211378382 \\cdot 2^{-2}) \\times 2^{-54} = 5404319552844595.5 \\times 2^{-54}$。\n待舍入的值由指数为 $-54$ 的整数有效数 $5404319552844595.5$ 表示。这个值恰好位于两个可表示值的中间，这两个值的整数有效数分别是 $K_e = 5404319552844595$ 和 $K_f = 5404319552844596$。\n根据“若相等则舍入到偶数”的规则，我们必须选择有效数为偶数的那个。$K_e$ 是奇数，$K_f$ 是偶数。因此，我们选择 $K_f$。\n舍入后的和 $X_{0.1+0.2}$ 是：\n$X_{0.1+0.2} = 5404319552844596 \\times 2^{-54}$。\n\n\\textbf{步骤 3：计算减法 $(X_{0.1+0.2} - X_{0.3})$}\n我们现在用加法的结果减去存储的 $0.3$ 的值。\n$X_{0.1+0.2} = 5404319552844596 \\times 2^{-54}$\n$X_{0.3} = 5404319552844595 \\times 2^{-54}$\n指数已经对齐。可以直接对整数有效数进行减法运算。\n$D = (5404319552844596 - 5404319552844595) \\times 2^{-54}$\n$D = 1 \\times 2^{-54} = 2^{-54}$。\n减法的结果是精确值 $2^{-54}$。这个值必须以 binary64 格式存储，这可能需要一次最终的舍入。然而，$2^{-54}$ 是一个可以精确表示的规格化 binary64 数。它可以写成 $1.0 \\times 2^{-54}$。这里，有效数是 $M=1.0$（这对应于整数有效数 $K=2^{52}$，其指数为 $E-52 = -54-52 = -106$），而指数是 $E = -54$。该指数在规格化数的有效范围（$-1022$ 到 $1023$）之内。由于该值可以精确表示，因此不进行舍入。\n\n因此，硬件产生的最终值恰好是 $2^{-54}$。",
            "answer": "$$\\boxed{2^{-54}}$$"
        },
        {
            "introduction": "在处理数量级差异巨大的数字时，浮点运算会引入一种被称为“大数吃小数”或“淹没”（swamping）的现象，导致精度严重损失。本练习通过分析看似无害的表达式 $(a+b)-a$ 来揭示这一陷阱 。你将推导该表达式的计算结果何时等于 $b$，并利用一个具体的数值例子，理解为什么当一个小数与一个大数相加时，其信息可能会完全丢失。",
            "id": "3641990",
            "problem": "一位软件工程师编写了一个数值核心，该核心遵循电气和电子工程师协会 (IEEE) 的浮点算术标准 (IEEE 754) 的 binary32 (单精度) 格式，并使用“舍入到最近，偶数优先”的舍入模式。令 $\\operatorname{fl}(\\cdot)$ 表示在此格式下单个运算的浮点结果。考虑计算量\n$$\ny \\;=\\; \\operatorname{fl}\\!\\left(\\,\\operatorname{fl}(a + b)\\;-\\;a\\,\\right),\n$$\n这反映了一种计算残差的天真代码模式。该工程师注意到，在实数算术中 $((a+b)-a)=b$，但在浮点算术中这个恒等式可能不成立。\n\n在以下模型中进行分析：\n- 一个规格化的 binary32 数具有形式 $x = (-1)^{s}\\,(1.f)_2\\,2^{E-127}$，其中 $s \\in \\{0,1\\}$，$f$ 是一个 23 位的尾数部分，$E \\in \\{1,2,\\dots,254\\}$ 是偏置指数。精度为 $p=24$ 个有效位 (包括隐含的前导 $1$ 位)。\n- 对于一个无偏指数为 $e$ 的规格化数值 $x$，“末位单位 (ULP)” 定义为 $\\operatorname{ulp}(x)=2^{e-(p-1)}$。\n- 对于 $\\circ \\in \\{+,-,\\times,\\div\\}$，单次正确舍入的运算 $\\operatorname{fl}(x \\circ y)$ 返回与精确结果最接近的唯一浮点数，当出现平局时，选择有效数位为偶数的那个。\n\n任务：\n1. 从这些定义出发，用 $a$、$b$ 和单次加法的舍入误差来推导 $y$ 的表达式。仅使用上述定义和浮点加法中指数对齐的基本性质。得出一个在该模型下 $y=b$ 成立的充要条件，该条件用 $a+b$ 在 binary32 中的精确可表示性来表达。\n2. 将你的结论特化到以下情况：$a$ 是一个规格化数，$b$ 与 $a$ 同号且满足 $|b| \\ll |a|$。使用 $\\operatorname{ulp}(a)$ 表达你的条件，并结合浮点加法器的指数对齐步骤来解释其含义。\n3. 现在取 $a=10^8$ 和 $b=1$，将它们解释为 binary32 计算的实数输入，并精确计算 $y=\\operatorname{fl}(\\operatorname{fl}(a+b)-a)$ 的 binary32 值。你的最终答案必须是一个实数。最终答案无需舍入。",
            "solution": "我们从 IEEE 754 binary32（单精度）的核心定义和正确舍入算术的语义开始。一个规格化的浮点数具有形式 $x = (-1)^{s}\\,(1.f)_2\\,2^{E-127}$，有效位数为 $p=24$。对于一个无偏指数为 $e$ 的规格化数 $x$，“末位单位 (ULP)” 为 $\\operatorname{ulp}(x)=2^{e-(p-1)}=2^{e-23}$，这是由 $e$ 定义的二进制指数区间（binade）内连续浮点数之间的间距。\n\n步骤 1：通过单次加法和减法的舍入误差来表示 $y$。\n\n我们用 $s = a+b$ 表示精确的实数和。根据“舍入到最近，偶数优先”的正确舍入规则，存在一个舍入误差 $\\delta$ 使得\n$$\n\\operatorname{fl}(a+b) \\;=\\; s + \\delta \\;=\\; a + b + \\delta,\n$$\n满足约束 $|\\delta| \\le \\tfrac{1}{2}\\,\\operatorname{ulp}(s)$。当 $|b|\\ll |a|$ 且 $a$ 是规格化数时，$s$ 的二进制指数区间通常与 $a$ 的一致（指数不会溢出到下一个区间），因此 $|\\delta| \\le \\tfrac{1}{2}\\,\\operatorname{ulp}(a)$。\n\n计算量为\n$$\ny \\;=\\; \\operatorname{fl}\\!\\left(\\operatorname{fl}(a+b) - a\\right) \\;=\\; \\operatorname{fl}\\!\\left((a+b+\\delta)-a\\right) \\;=\\; \\operatorname{fl}\\!\\left(b+\\delta\\right).\n$$\n现在我们使用浮点算术中减法的一个著名精确性性质，即当两个浮点数之比在 2 倍范围之内时。具体来说，根据 Sterbenz 引理（一个可从指数对齐和规格化推导出的标准结果），如果 $x$ 和 $y$ 是浮点数且满足 $\\tfrac{1}{2}\\le \\tfrac{x}{y}\\le 2$，那么 $x-y$ 在相同格式下是精确可表示的。在我们的设定中，$\\operatorname{fl}(a+b)$ 和 $a$ 都是浮点数，并且当 $|b|\\ll|a|$ 时，它们之比在 2 倍范围之内，所以减法 $\\operatorname{fl}(a+b)-a$ 是精确的。因此，\n$$\ny \\;=\\; \\left(\\operatorname{fl}(a+b)\\right)-a \\;=\\; (a+b+\\delta)-a \\;=\\; b+\\delta.\n$$\n由此可见，$y=b$ 当且仅当 $\\delta=0$，也就是说，当且仅当 $\\operatorname{fl}(a+b)=a+b$（即和在 binary32 中无舍入地精确可表示）。这建立了一个充要条件：\n$$\ny=b \\quad\\Longleftrightarrow\\quad a+b \\text{ 在 binary32 中是精确可表示的}。\n$$\n\n步骤 2：使用 $\\operatorname{ulp}(a)$ 和指数对齐进行特化分析。\n\n在二进制加法器中，为了计算 $a+b$，需要通过将具有较小无偏指数的操作数的有效数位向右移动 $d$ 个比特位来进行对齐，其中 $d$ 是指数差。如果 $|b|\\ll |a|$ 且 $a$ 和 $b$ 同号，那么在对齐后，$b$ 对和的贡献在 $a$ 的尺度上实际上被量化到了 $\\operatorname{ulp}(a)$ 的网格上。具体来说，当加法后 $a$ 仍保持在同一个二进制指数区间内时，我们有\n$$\n\\operatorname{ulp}(a)=2^{e-23}, \\quad \\text{其中 } e=\\lfloor \\log_{2}|a| \\rfloor,\n$$\n和 $a+b$ 是精确可表示的，当且仅当 $b$ 是 $\\operatorname{ulp}(a)$ 的整数倍，并且加法不会导致指数重新规格化为 $e+1$。等价地，舍入误差 $\\delta$ 为零，当且仅当 $b \\in \\operatorname{ulp}(a)\\,\\mathbb{Z}$ 并且 $a+b$ 保持在无偏指数为 $e$ 的二进制指数区间内。直观上，这说明等式 $y=b$ 成立的条件是，$b$ 正好“缩放”到由 $a$ 附近可表示数的间距定义的局部网格上；如果 $b$ 不在该网格上，指数对齐和舍入操作将导致一个非零的 $\\delta$，从而 $y\\ne b$。\n\n步骤 3：计算 $a=10^8$ 和 $b=1$ 的情况。\n\n我们现在为 $a=10^8$ 和 $b=1$ 在 binary32 格式下计算 $y=\\operatorname{fl}(\\operatorname{fl}(a+b)-a)$。\n\n首先，确定 $a$ 的无偏指数 $e$：\n$$\n2^{26} \\;=\\; 67{,}108{,}864 \\;\\;\\;\\; 10^{8} \\;\\;\\;\\; 134{,}217{,}728 \\;=\\; 2^{27},\n$$\n所以 $e=\\lfloor \\log_{2}(10^{8}) \\rfloor = 26$。因此，$a$ 处的局部间距为\n$$\n\\operatorname{ulp}(a) \\;=\\; 2^{e-23} \\;=\\; 2^{3} \\;=\\; 8.\n$$\n因为 $|b|=1  \\frac{1}{2}\\operatorname{ulp}(a)=4$，所以正确舍入的和满足\n$$\n\\operatorname{fl}(a+b) \\;=\\; a \\quad\\text{(舍入到最近，偶数优先)}。\n$$\n因此，加法上的舍入误差是 $\\delta = -b = -1$，并且减法是精确的（如上所述），得到\n$$\ny \\;=\\; \\operatorname{fl}\\!\\left(\\operatorname{fl}(a+b)-a\\right) \\;=\\; (a+b+\\delta)-a \\;=\\; (a+1-1)-a \\;=\\; 0.\n$$\n因此，在 binary32 中计算出的值 $y$ 精确地为 $0$。这展示了一个反例，其中 $((a+b)-a)$ 不等于 $b$，除非 $b$ 缩放到 $\\operatorname{ulp}(a)$ 的网格上（这里 $\\operatorname{ulp}(a)=8$，而 $b=1$ 不是 $8$ 的整数倍）。",
            "answer": "$$\\boxed{0}$$"
        },
        {
            "introduction": "将一个数学公式直接翻译成代码，并不总能得到最准确或最稳健的结果，尤其是在科学和工程计算中。这个练习以计算直角三角形斜边为例，对比了两种算法的数值稳定性 。通过分析“朴素”的平方和开根号方法与一种经过缩放的补偿方法，你将看到算法设计上的选择如何帮助我们避免中间步骤的溢出和精度损失问题。",
            "id": "3642006",
            "problem": "一个系统实现了电气和电子工程师协会 (IEEE) $754$ binary$32$ 浮点格式，采用“四舍六入五成双”(round to nearest, ties to even)的舍入模式，并在每次算术运算（包括乘法、加法、除法和平方根）后进行舍入。binary$32$ 格式有 $1$ 个符号位、$8$ 个指数位（偏置为 $127$）和 $23$ 个小数位；有效数精度为 $p=24$ 位。考虑使用两种算法计算斜边 $h=\\sqrt{x^{2}+y^{2}}$，其中 $x=10^{8}$ 且 $y=1$：\n\n(i) 朴素平方和法：计算 $x^{2}$，然后计算 $x^{2}+y^{2}$，最后计算 $\\sqrt{x^{2}+y^{2}}$，每步运算都舍入到 binary$32$ 格式。\n\n(ii) 补偿缩放法：令 $r=\\max(|x|,|y|)$ 和 $s=\\min(|x|,|y|)$，然后计算 $r\\cdot\\sqrt{1+(s/r)^{2}}$，每步运算都舍入到 binary$32$ 格式。\n\n仅根据上述 IEEE $754$ binary$32$ 的结构和舍入规则，分析每一步的舍入情况，以确定两种算法返回的最终 binary$32$ 结果，并将其与精确实数 $h=\\sqrt{10^{16}+1}$ 进行比较。通过此分析，确定计算出的斜边（在本例中两种方法的结果相同）相对于精确实数值的相对误差，该误差定义为 $\\displaystyle \\frac{|h_{\\mathrm{comp}}-h|}{h}$，其中 $h_{\\mathrm{comp}}$ 是任一方法返回的浮点结果。将你的最终答案表示为一个实数，并四舍五入到四位有效数字。",
            "solution": "用户要求分析两种使用 IEEE $754$ binary$32$ 浮点算术计算斜边 $h=\\sqrt{x^{2}+y^{2}}$（其中 $x=10^{8}$，$y=1$）的算法。分析必须确定每种算法的计算结果以及与精确值相比的相对误差。\n\nIEEE $754$ binary$32$ 格式使用 $1$ 个符号位、$8$ 个指数位（偏置为 $127$）和 $23$ 个显式小数位。有效数精度为 $p=24$ 位（1个隐含位 + 23个小数位）。舍入模式为“四舍六入五成双”。\n\n首先，我们将输入 $x=10^{8}$ 和 $y=1$ 表示为 binary$32$ 格式。\n数字 $y=1$ 精确地为 $1.0 \\times 2^{0}$。它可以被完美表示。$\\hat{y} = 1$。\n数字 $x=10^{8}$ 需要进行转换。\n$x = 100,000,000$。其指数为 $E = \\lfloor \\log_2(10^8) \\rfloor = 26$。\n为了表示 $10^8$，我们对其进行规格化：$10^8 = m \\times 2^{26}$，其中 $m = 10^8 / 2^{26}$。\n$x = (101111101011110000100000000)_2$。这需要 $27$ 位来表示为一个整数。为了规格化，我们将其写为：\n$x = 1.011111010111100001_2 \\times 2^{26}$。此有效数的长度为 $19$ 位。由于 $19  24$，$x=10^8$ 在 binary$32$ 格式中是精确可表示的。存储的值为 $\\hat{x} = 10^8$。其有效数为 $1.01111101011110000100000_2$，存储的指数为 $26+127 = 153$。\n\n令 $fl(\\cdot)$ 表示带舍入的浮点运算。\n\n### 算法 (i)：朴素平方和法 $h_{\\mathrm{comp1}} = fl(\\sqrt{fl(fl(\\hat{x}^2) + fl(\\hat{y}^2))})$\n\n1.  **计算 $fl(\\hat{x}^2)$**：\n    我们计算 $\\hat{x}^2 = (10^8)^2 = 10^{16}$。这个精确值必须舍入到 binary$32$ 格式。\n    $10^{16}$ 的指数是 $E = \\lfloor \\log_2(10^{16}) \\rfloor = 53$。\n    精确的有效数是 $m = 10^{16} / 2^{53} \\approx 1.109335529$。\n    用二进制表示，$m \\approx 1.00011011101101100100111101..._2$。\n    要以 $p=24$ 位的精度存储，我们必须进行舍入。前 $24$ 位是 $1.00011011101101100100111_2$。下一位（保护位）是 $1$。保护位后面的位不全为零。因此，我们向上舍入。\n    截断的有效数：$1.00011011101101100100111_2$。\n    加上 $2^{-23}$：$1.00011011101101100100111_2 + 0.00000000000000000000001_2 = 1.00011011101101100101000_2$。\n    我们称舍入后的有效数为 $m_{x^2}$。$fl(\\hat{x}^2)$ 的值为 $m_{x^2} \\times 2^{53}$。\n    未规格化的有效数的整数表示为 $(100011011101101100101000)_2 = (8DD698)_{16} = 9295512$。\n    所以 $fl(\\hat{x}^2) = 9295512 \\times 2^{53 - 23} = 9295512 \\times 2^{30} = 10000000216535040$。\n\n2.  **计算 $fl(fl(\\hat{x}^2) + fl(\\hat{y}^2))$**：\n    $fl(\\hat{y}^2)=fl(1^2)=1$。我们需要计算 $fl(10000000216535040 + 1)$。\n    第一个数的指数是 $53$。第二个数 $1$ 的指数是 $0$。\n    为了执行加法，必须对齐指数。较小数 ($1$) 的有效数必须向右移动指数差的位数，即 $53$ 位。\n    $1.0 \\times 2^0 = 0.\\underbrace{00...0}_{52}1 \\times 2^{53}$。\n    $1$ 的有效数向右移动得太远，以至于完全丢失了，因为 binary$32$ 只保持 $24$ 位的精度。加法对较大数的有效数没有影响。这种现象被称为“淹没”(swamping)。\n    $fl(fl(\\hat{x}^2) + 1) = fl(\\hat{x}^2) = 10000000216535040$。\n\n3.  **计算 $h_{\\mathrm{comp1}} = fl(\\sqrt{10000000216535040})$**：\n    精确的平方根是 $\\sqrt{10000000216535040} \\approx 100000001.082675$。\n    我们必须将这个值舍入到最接近的 binary$32$ 数。\n    该数约等于 $10^8$，所以其指数为 $26$。对于这个数量级的数，末位单位 (Unit in the Last Place, ULP) 是 $2^{E - (p-1)} = 2^{26-23} = 2^3=8$。\n    在 $10^8$ 附近的可表示数为 $8$ 的倍数，例如 $100,000,000$ 和 $100,000,008$。\n    值 $100000001.082675$ 位于这两个数之间。它们的中点是 $100,000,004$。\n    由于 $100000001.082675  100000004$，它被向下舍入到最接近的可表示数。\n    $h_{\\mathrm{comp1}} = 100,000,000 = 10^8$。\n\n### 算法 (ii)：补偿缩放法 $h_{\\mathrm{comp2}} = fl(\\hat{r} \\cdot fl(\\sqrt{fl(1 + fl(fl(\\hat{s}/\\hat{r})^2))})))$\n\n1.  **确定 $r$ 和 $s$**：\n    $r=\\max(|x|,|y|) = 10^8$，且 $s=\\min(|x|,|y|) = 1$。存储的值是精确的：$\\hat{r}=10^8$, $\\hat{s}=1$。\n\n2.  **计算 $fl(\\hat{s}/\\hat{r})$**：\n    即 $fl(1/10^8) = fl(10^{-8})$。这是一个非常小的数。\n\n3.  **计算 $fl(fl(\\hat{s}/\\hat{r})^2)$**：\n    这将得到一个约等于 $(10^{-8})^2 = 10^{-16}$ 的数。其指数将在 $\\lfloor\\log_2(10^{-16})\\rfloor = -54$ 左右。\n\n4.  **计算 $fl(1 + fl(fl(\\hat{s}/\\hat{r})^2))$**：\n    我们将 $1$（指数为 $0$）与一个非常小的数（指数约为 $-54$）相加。指数差约为 $54$，远大于 $24$ 位的有效数精度。与算法 (i) 中一样，发生了淹没。较小的数在为了加法而进行的对齐过程中完全丢失。\n    $fl(1 + (\\text{一个 } 10^{-16} \\text{ 数量级的数})) = 1$。\n\n5.  **计算 $fl(\\sqrt{...})$**：\n    $fl(\\sqrt{1}) = 1$。这是精确的。\n\n6.  **计算 $h_{\\mathrm{comp2}} = fl(\\hat{r} \\cdot 1)$**：\n    $h_{\\mathrm{comp2}} = fl(10^8 \\cdot 1) = 10^8$。这个乘法是精确的。\n\n两种算法都得出相同的计算结果：$h_{\\mathrm{comp}} = 10^8$。\n\n### 相对误差计算\n\n相对误差定义为 $\\frac{|h_{\\mathrm{comp}}-h|}{h}$，其中 $h_{\\mathrm{comp}} = 10^8$，$h=\\sqrt{10^{16}+1}$。\n\n$h = \\sqrt{10^{16}+1} = 10^8 \\sqrt{1+10^{-16}}$。\n对于小的 $\\epsilon$，使用近似公式 $\\sqrt{1+\\epsilon} \\approx 1+\\epsilon/2$：\n$h \\approx 10^8(1+\\frac{1}{2}10^{-16}) = 10^8 + 0.5 \\times 10^{-8}$。\n绝对误差是 $|h_{\\mathrm{comp}}-h| = |10^8 - h|$。为避免精度损失，我们使用共轭表达式：\n$h-h_{\\mathrm{comp}} = \\sqrt{10^{16}+1}-10^8 = (\\sqrt{10^{16}+1}-10^8) \\frac{\\sqrt{10^{16}+1}+10^8}{\\sqrt{10^{16}+1}+10^8} = \\frac{(10^{16}+1)-10^{16}}{\\sqrt{10^{16}+1}+10^8} = \\frac{1}{\\sqrt{10^{16}+1}+10^8}$。\n\n相对误差是 $\\frac{|h_{\\mathrm{comp}}-h|}{h} = \\frac{h-h_{\\mathrm{comp}}}{h} = \\frac{1}{h(\\sqrt{10^{16}+1}+10^8)}$。\n由于 $h = \\sqrt{10^{16}+1} \\approx 10^8$，我们可以近似计算相对误差：\n相对误差 $\\approx \\frac{1}{10^8(10^8+10^8)} = \\frac{1}{10^8(2 \\cdot 10^8)} = \\frac{1}{2 \\cdot 10^{16}} = 0.5 \\times 10^{-16} = 5 \\times 10^{-17}$。\n\n题目要求答案四舍五入到四位有效数字。\n$5 \\times 10^{-17} = 5.000 \\times 10^{-17}$。",
            "answer": "$$\\boxed{5.000 \\times 10^{-17}}$$"
        }
    ]
}