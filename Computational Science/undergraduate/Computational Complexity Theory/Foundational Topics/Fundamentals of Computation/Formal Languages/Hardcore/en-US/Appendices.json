{
    "hands_on_practices": [
        {
            "introduction": "Translating abstract language descriptions, such as regular expressions, into concrete computational models is a foundational skill in computer science. This exercise challenges you to construct a Nondeterministic Finite Automaton (NFA) for a given regular language. More than a mechanical application of rules, this problem encourages you to first analyze and simplify the language itself, a crucial step in designing efficient and elegant solutions in automata theory .",
            "id": "1424597",
            "problem": "In the theory of computation, a Nondeterministic Finite Automaton (NFA) is formally defined by a 5-tuple $(Q, \\Sigma, \\delta, q_0, F)$, where $Q$ is a finite set of states, $\\Sigma$ is a finite alphabet of symbols, $\\delta: Q \\times (\\Sigma \\cup \\{\\epsilon\\}) \\to \\mathcal{P}(Q)$ is the transition function (where $\\mathcal{P}(Q)$ is the power set of $Q$), $q_0 \\in Q$ is the start state, and $F \\subseteq Q$ is the set of accept (or final) states.\n\nConsider the language $L$ over the alphabet $\\Sigma = \\{a, b\\}$ defined by the following regular expression:\n$$ (a^*b \\cup b^*a)^+ $$\nWhat is the minimum number of states required for an NFA to accept the language $L$?\n\nA. 1\n\nB. 2\n\nC. 3\n\nD. 4\n\nE. 5",
            "solution": "We analyze the regular expression $R = a^{*}b \\cup b^{*}a$ and the language $L = R^{+}$ over $\\Sigma = \\{a, b\\}$.\n\nFirst, observe that $a \\in R$ because $b^{*}a$ with zero $b$’s yields $a$, and $b \\in R$ because $a^{*}b$ with zero $a$’s yields $b$. Hence $\\{a, b\\} \\subseteq R$. Since $L = R^{+}$ is the set of all finite concatenations of elements of $R$, every non-empty string over $\\{a, b\\}$ is a concatenation of $a$’s and $b$’s, each of which is in $R$. Therefore,\n$$\n\\{a, b\\}^{+} \\subseteq L.\n$$\nConversely, every string in $L = R^{+}$ is a concatenation of blocks each of which has length at least $1$, so $L \\subseteq \\{a, b\\}^{+}$. Thus,\n$$\nL = \\{a, b\\}^{+}.\n$$\n\nWe now determine the minimal number of NFA states for $L = \\Sigma^{+}$.\n\nLower bound: No 1-state NFA can recognize $\\Sigma^{+}$ without accepting $\\epsilon$. If the unique state is accepting, then $\\epsilon$ is accepted; if it is rejecting, then no non-empty string can be accepted because all computations end in the same rejecting state. Epsilon-transitions do not help with a single state because acceptance of $\\epsilon$ depends solely on whether the start state is accepting. Hence at least $2$ states are necessary.\n\nUpper bound (constructive): A $2$-state NFA suffices. Let $Q = \\{q_{0}, q_{1}\\}$ with start state $q_{0}$ and accepting set $F = \\{q_{1}\\}$. Define transitions\n$$\n\\delta(q_{0}, a) = \\{q_{1}\\}, \\quad \\delta(q_{0}, b) = \\{q_{1}\\}, \\quad \\delta(q_{1}, a) = \\{q_{1}\\}, \\quad \\delta(q_{1}, b) = \\{q_{1}\\}.\n$$\nThen the automaton accepts exactly $\\Sigma^{+}$. Therefore the minimal number of states for an NFA is $2$.\n\nAmong the options, this corresponds to B.",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "As we move beyond regular languages, we encounter patterns that require memory, such as the language of palindromes. This problem  serves as a classic introduction to Pushdown Automata (PDAs), the machines that recognize context-free languages. You will practice implementing the concept of a stack to remember the first half of a string and match it against the second, gaining hands-on experience with the power of non-determinism in handling strings of both even and odd lengths.",
            "id": "1424576",
            "problem": "Consider the language $L$ of all palindromes over the alphabet $\\Sigma = \\{a, b\\}$. A palindrome is a string that reads the same forwards and backwards. Formally, $L = \\{w \\in \\{a,b\\}^* \\mid w = w^R\\}$, where $w^R$ denotes the reverse of string $w$.\n\nA non-deterministic Pushdown Automaton (PDA), denoted $M$, is being designed to accept this language $L$. The PDA is defined by the tuple $M = (Q, \\Sigma, \\Gamma, \\delta, q_0, Z_0, F)$, with the following components:\n- States $Q = \\{q_0, q_1, q_2\\}$\n- Input alphabet $\\Sigma = \\{a, b\\}$\n- Stack alphabet $\\Gamma = \\{a, b, Z_0\\}$, where $Z_0$ is the initial stack symbol.\n- Start state $q_0$\n- Set of final states $F = \\{q_2\\}$\n\nThe intended logic of the PDA is as follows:\n1. In state $q_0$, read the first half of the input string and push corresponding symbols onto the stack.\n2. Non-deterministically guess the middle of the string and transition to state $q_1$. This transition may or may not consume an input symbol, to account for both even and odd length palindromes.\n3. In state $q_1$, read the second half of the input string, matching each symbol with the symbol at the top of the stack and popping it.\n4. If the entire input string has been read and the stack contains only the initial symbol $Z_0$, transition to the final state $q_2$.\n\nSome of the transition rules, $\\delta$, are already defined. The transitions are written in the format $\\delta(\\text{current\\_state}, \\text{input\\_symbol}, \\text{stack\\_top}) = \\{(\\text{next\\_state}, \\text{string\\_to\\_push})\\}$.\n- **Pushing Rules (in state $q_0$):**\n    - $\\delta(q_0, a, X) = \\{(q_0, aX)\\}$ for any stack symbol $X \\in \\Gamma$\n    - $\\delta(q_0, b, X) = \\{(q_0, bX)\\}$ for any stack symbol $X \\in \\Gamma$\n- **Acceptance Rule:**\n    - $\\delta(q_1, \\epsilon, Z_0) = \\{(q_2, Z_0)\\}$\n\nYour task is to identify the correct set of additional transition rules required to complete the PDA so that it correctly accepts the language $L$. Which of the following sets of rules correctly represents the \"middle-guess\" and \"popping\" phases? Note that $\\epsilon$ denotes the empty string.\n\nA.\n- $\\delta(q_0, a, a) = \\{(q_1, \\epsilon)\\}$\n- $\\delta(q_0, b, b) = \\{(q_1, \\epsilon)\\}$\n- $\\delta(q_1, a, a) = \\{(q_1, \\epsilon)\\}$\n- $\\delta(q_1, b, b) = \\{(q_1, \\epsilon)\\}$\n\nB.\n- $\\delta(q_0, \\epsilon, X) = \\{(q_1, X)\\}$ for any $X \\in \\Gamma$\n- $\\delta(q_1, a, a) = \\{(q_1, \\epsilon)\\}$\n- $\\delta(q_1, b, b) = \\{(q_1, \\epsilon)\\}$\n\nC.\n- $\\delta(q_0, \\epsilon, X) = \\{(q_1, X)\\}$ for any $X \\in \\Gamma$\n- $\\delta(q_0, a, X) = \\{(q_1, X)\\}$ for any $X \\in \\Gamma$\n- $\\delta(q_0, b, X) = \\{(q_1, X)\\}$ for any $X \\in \\Gamma$\n- $\\delta(q_1, a, a) = \\{(q_1, \\epsilon)\\}$\n- $\\delta(q_1, b, b) = \\{(q_1, \\epsilon)\\}$\n\nD.\n- $\\delta(q_0, \\epsilon, X) = \\{(q_1, X)\\}$ for any $X \\in \\Gamma$\n- $\\delta(q_0, a, X) = \\{(q_1, X)\\}$ for any $X \\in \\Gamma$\n- $\\delta(q_0, b, X) = \\{(q_1, X)\\}$ for any $X \\in \\Gamma$\n- $\\delta(q_1, a, b) = \\{(q_1, \\epsilon)\\}$\n- $\\delta(q_1, b, a) = \\{(q_1, \\epsilon)\\}$",
            "solution": "The goal is to construct a Pushdown Automaton (PDA) that recognizes the language of palindromes $L = \\{w \\mid w=w^R\\}$ over $\\Sigma=\\{a,b\\}$. The PDA must correctly handle palindromes of both even and odd lengths, as well as the empty string.\n\nThe given structure of the PDA uses three states: $q_0$ for the pushing phase, $q_1$ for the popping phase, and $q_2$ as the final (accept) state.\n\nLet's analyze the necessary logic step-by-step:\n\n1.  **Pushing Phase:** The PDA starts in state $q_0$. For the first half of the input string $w$, it should read the symbols and push them onto the stack. This creates a reversed record of the first half. The provided rules $\\delta(q_0, a, X) = \\{(q_0, aX)\\}$ and $\\delta(q_0, b, X) = \\{(q_0, bX)\\}$ for any $X \\in \\Gamma$ correctly implement this. For an input symbol $c$, it is pushed on top of whatever is already on the stack ($X$), resulting in the stack content becoming $cX$.\n\n2.  **Guessing the Middle:** This is the crucial non-deterministic step. The PDA must guess when it has reached the middle of the string.\n    *   **Even-length palindromes:** For a string like `abba`, the middle occurs between the two `b`'s. After reading `ab`, the stack contains `baZ_0` (from bottom to top). The PDA must transition from the pushing state ($q_0$) to the popping state ($q_1$) without consuming any input symbol. The rule for this is $\\delta(q_0, \\epsilon, X) = \\{(q_1, X)\\}$ for any stack symbol $X$. This rule leaves the stack unchanged and moves to state $q_1$ to begin the matching phase.\n    *   **Odd-length palindromes:** For a string like `aba`, the middle is the symbol `b`. After reading `a`, the stack contains `aZ_0`. The PDA needs to read the middle symbol `b` but *not* perform any stack operation, as this central character does not have a counterpart. Then it must transition to state $q_1$. The rules for this are $\\delta(q_0, a, X) = \\{(q_1, X)\\}$ and $\\delta(q_0, b, X) = \\{(q_1, X)\\}$ for any symbol $X$ on the stack. These rules consume one input symbol (the middle one) but leave the stack as it is, before moving to the popping state $q_1$.\n\n3.  **Popping Phase:** Once in state $q_1$, the PDA reads the second half of the string. For each input symbol it reads, it must match the symbol on top of the stack. If they match, the stack symbol is popped. For example, if the input is `a` and the top of the stack is `a`, the machine should pop `a` and remain in state $q_1$. The required rules are $\\delta(q_1, a, a) = \\{(q_1, \\epsilon)\\}$ and $\\delta(q_1, b, b) = \\{(q_1, \\epsilon)\\}$. The $\\epsilon$ in the output signifies that nothing is pushed back onto the stack, effectively a pop operation.\n\n4.  **Acceptance:** After the entire string has been read, if the machine successfully matched all symbols in the second half, the stack should contain only the initial symbol $Z_0$. The given acceptance rule $\\delta(q_1, \\epsilon, Z_0) = \\{(q_2, Z_0)\\}$ allows the machine to transition to the final state $q_2$ at this point, thereby accepting the string. The empty string is also a palindrome. The machine can handle this by starting in $q_0$ and immediately taking the $\\epsilon$-transition $\\delta(q_0, \\epsilon, Z_0) = \\{(q_1, Z_0)\\}$ to get to $q_1$, and then taking the acceptance transition $\\delta(q_1, \\epsilon, Z_0) = \\{(q_2, Z_0)\\}$ to accept.\n\nNow, let's evaluate the given options:\n\n*   **Option A:** The rules $\\delta(q_0, a, a) = \\{(q_1, \\epsilon)\\}$ and $\\delta(q_0, b, b) = \\{(q_1, \\epsilon)\\}$ are incorrect for the \"middle-guess\". They imply that to transition to state $q_1$, the machine must read an input symbol that matches the top of the stack and pop it. This is not the logic for pushing the first half of a string before matching the second half.\n\n*   **Option B:** This option only includes the rule $\\delta(q_0, \\epsilon, X) = \\{(q_1, X)\\}$ for the middle guess. This correctly handles even-length palindromes but provides no way to handle the middle character of odd-length palindromes. An odd-length palindrome like `aba` would be rejected because the PDA would have no defined transition for reading the middle `b`.\n\n*   **Option C:** This option provides the complete set of rules needed for both the middle-guess and the popping phase.\n    *   $\\delta(q_0, \\epsilon, X) = \\{(q_1, X)\\}$ handles the even-length case.\n    *   $\\delta(q_0, a, X) = \\{(q_1, X)\\}$ and $\\delta(q_0, b, X) = \\{(q_1, X)\\}$ handle the odd-length case by consuming the middle symbol without altering the stack.\n    *   $\\delta(q_1, a, a) = \\{(q_1, \\epsilon)\\}$ and $\\delta(q_1, b, b) = \\{(q_1, \\epsilon)\\}$ correctly implement the matching and popping for the second half of the string.\n    This set of rules is correct.\n\n*   **Option D:** This option has the correct rules for guessing the middle, but its popping rules are wrong. The rule $\\delta(q_1, a, b) = \\{(q_1, \\epsilon)\\}$ means \"if the input is `a`, pop `b`\". This would not match a palindrome. For the palindrome `aba`, after pushing `a` and reading the central `b`, the stack contains `aZ_0`. The next input is `a`. This rule set provides no transition for $(q_1, a, a)$, so the machine would get stuck and reject.\n\nTherefore, the only correct and complete set of rules is provided in Option C.",
            "answer": "$$\\boxed{C}$$"
        },
        {
            "introduction": "While context-free grammars (CFGs) can be written in many forms, standardizing them is essential for many important algorithms and theoretical proofs, such as parsing with the CYK algorithm. This practice focuses on converting a given CFG into Chomsky Normal Form (CNF), a widely used standard where production rules are restricted to simple binary or terminal forms. By following a systematic, multi-step procedure involving the elimination of $\\epsilon$-productions and unit productions, you will develop a key procedural skill in formal language theory .",
            "id": "1424566",
            "problem": "A context-free grammar (CFG) is a formal grammar in which every production rule is of the form $V \\rightarrow w$, where $V$ is a single non-terminal symbol, and $w$ is a string of terminals and/or non-terminals.\n\nA CFG is in Chomsky Normal Form (CNF) if every production rule is in one of the following forms:\n1. $A \\rightarrow BC$, where $A, B, C$ are non-terminal symbols.\n2. $A \\rightarrow a$, where $A$ is a non-terminal symbol and $a$ is a terminal symbol.\nAdditionally, if the empty string $\\epsilon$ is in the language, the rule $S \\rightarrow \\epsilon$ is allowed, where $S$ is the start symbol, provided that $S$ does not appear on the right-hand side of any rule.\n\nConsider the following context-free grammar $G$ with the set of non-terminal symbols $V = \\{S, A, B\\}$, the set of terminal symbols $\\Sigma = \\{a, b\\}$, and $S$ as the start symbol. The production rules $P$ are given as:\n$S \\rightarrow aSA$\n$A \\rightarrow bB$\n$B \\rightarrow S \\mid \\epsilon$\n\nYour task is to convert the grammar $G$ into an equivalent grammar $G'$ in Chomsky Normal Form. From the options below, select the one that correctly represents the set of production rules for $G'$. In the options, $S'$ is the new start symbol, and any other new non-terminal symbols are denoted by $V_x$ or $X_y$.\n\nA.\n$S' \\rightarrow V_a X_1$\n$S \\rightarrow V_a X_1$\n$A \\rightarrow V_b B$\n$B \\rightarrow V_a X_1$\n$X_1 \\rightarrow S A$\n$V_a \\rightarrow a$\n$V_b \\rightarrow b$\n\nB.\n$S' \\rightarrow V_a X_1$\n$S \\rightarrow V_a X_1$\n$A \\rightarrow V_b B$\n$A \\rightarrow b$\n$B \\rightarrow S$\n$B \\rightarrow V_a X_1$\n$X_1 \\rightarrow S A$\n$V_a \\rightarrow a$\n$V_b \\rightarrow b$\n\nC.\n$S' \\rightarrow V_a X_1$\n$S \\rightarrow V_a X_1$\n$A \\rightarrow V_b B$\n$A \\rightarrow b$\n$B \\rightarrow V_a X_1$\n$X_1 \\rightarrow S A$\n$V_a \\rightarrow a$\n$V_b \\rightarrow b$\n\nD.\n$S \\rightarrow V_a X_1$\n$A \\rightarrow V_b B$\n$A \\rightarrow b$\n$B \\rightarrow V_a X_1$\n$X_1 \\rightarrow S A$\n$V_a \\rightarrow a$\n$V_b \\rightarrow b$\n\nE.\n$S' \\rightarrow V_a S A$\n$S \\rightarrow V_a S A$\n$A \\rightarrow V_b B$\n$A \\rightarrow b$\n$B \\rightarrow V_a S A$\n$V_a \\rightarrow a$\n$V_b \\rightarrow b$",
            "solution": "We start from the given grammar with nonterminals $V=\\{S,A,B\\}$, terminals $\\Sigma=\\{a,b\\}$, start symbol $S$, and productions\n$$\nS \\to aSA,\\quad A \\to bB,\\quad B \\to S \\mid \\epsilon.\n$$\n\nStep 1: Identify nullable nonterminals. Since $B \\to \\epsilon$, $B$ is nullable. Because $A \\to bB$, $A$ can derive $b$ but not $\\epsilon$, so $A$ is not nullable. Also $S$ is not nullable because its rule $S \\to aSA$ contains the terminal $a$ and no nullable-only right-hand side.\n\nStep 2: Eliminate $\\epsilon$-productions. Remove $B \\to \\epsilon$ and add the variant of any production containing $B$ with $B$ omitted. The only such production is $A \\to bB$, which yields an additional $A \\to b$. Thus, after $\\epsilon$-elimination we have\n$$\nS \\to aSA,\\quad A \\to bB \\mid b,\\quad B \\to S.\n$$\n\nStep 3: Eliminate unit productions. The only unit production is $B \\to S$. Replace it by $B$ adopting the productions of $S$, namely $B \\to aSA$, and remove $B \\to S$. We get\n$$\nS \\to aSA,\\quad A \\to bB \\mid b,\\quad B \\to aSA.\n$$\n\nStep 4: Prepare for Chomsky Normal Form by isolating terminals in long right-hand sides and binarizing. Introduce new nonterminals for terminals that appear in right-hand sides of length greater than $1$:\n$$\nV_{a} \\to a,\\quad V_{b} \\to b.\n$$\nReplace terminals in long right-hand sides and binarize any right-hand sides of length greater than $2$ by introducing a new variable $X_{1}$ with\n$$\nX_{1} \\to SA.\n$$\nThen transform\n$$\nS \\to aSA \\Rightarrow S \\to V_{a}SA \\Rightarrow S \\to V_{a}X_{1},\n$$\n$$\nB \\to aSA \\Rightarrow B \\to V_{a}SA \\Rightarrow B \\to V_{a}X_{1},\n$$\nand\n$$\nA \\to bB \\Rightarrow A \\to V_{b}B,\\quad A \\to b\\ \\text{(keep as terminal rule)}.\n$$\n\nStep 5: Introduce a new start symbol $S'$ that does not appear on any right-hand side. To avoid the unit production $S' \\to S$, define $S'$ to mirror $S$’s production directly:\n$$\nS' \\to V_{a}X_{1}.\n$$\n\nCollecting all productions in CNF, we obtain\n$$\nS' \\to V_{a}X_{1},\\quad S \\to V_{a}X_{1},\\quad A \\to V_{b}B \\mid b,\\quad B \\to V_{a}X_{1},\\quad X_{1} \\to SA,\\quad V_{a} \\to a,\\quad V_{b} \\to b,\n$$\nwhich matches option C.\n\nWhy the other options are invalid:\n- A omits $A \\to b$, which is required after eliminating $B \\to \\epsilon$, thus changing the language.\n- B retains the unit production $B \\to S$, which is not allowed in CNF.\n- D lacks the new start symbol $S'$ as specified in the options’ description.\n- E contains right-hand sides of length $3$ (e.g., $S' \\to V_{a}SA$), violating CNF’s binary form requirement.\n\nTherefore, the correct choice is C.",
            "answer": "$$\\boxed{C}$$"
        }
    ]
}