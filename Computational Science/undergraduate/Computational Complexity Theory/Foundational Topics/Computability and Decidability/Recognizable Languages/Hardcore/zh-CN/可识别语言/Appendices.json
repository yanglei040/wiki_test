{
    "hands_on_practices": [
        {
            "introduction": "这个练习将聚焦于“可识别语言”的核心定义。我们将通过分析一个具体语言的例子，评估图灵机可以采用的不同策略，从而确定哪一种策略正确地实现了“识别”过程。这有助于我们精确理解图灵机在处理不属于语言的字符串时的行为，并将其与“判定”过程区分开来。",
            "id": "1442190",
            "problem": "在计算理论中，形式语言是定义在有限字母表上的一组字符串。如果存在一台图灵机 (TM) 能够识别属于某个语言的字符串，那么该语言被称为*可识别的*。具体来说，如果对于任意给定的输入字符串 $w$，一台 TM 满足以下条件，则它识别语言 $L$：\n1. 如果 $w$ 属于 $L$，TM 停机并进入 `accept` 状态。\n2. 如果 $w$ 不属于 $L$，TM 要么停机并进入 `reject` 状态，要么永远运行（永不停机）。\n\n考虑字母表 $\\Sigma = \\{a\\}$ 上的语言 $L$，它被定义为所有长度为完全平方数的 'a' 字符串的集合。形式上，即 $L = \\{ a^k \\mid k = n^2 \\text{ for some integer } n \\ge 0 \\}$。这包括空字符串，因为当 $k=0$ 时，有 $0^2=0$。\n\n下面是为处理输入字符串 $w=a^k$ 而设计的图灵机的四种不同策略。哪种策略正确描述了一台能识别语言 $L$ 的 TM？\n\nA. TM 分阶段运行。在阶段 $n$（其中 $n=0, 1, 2, 3, \\dots$），TM 计算值 $s = n^2$。然后，它将输入字符串的长度 $k$ 与 $s$ 进行比较。如果 $k=s$，TM 停机并接受。如果 $k \\ne s$，它进入下一个阶段 $n+1$。\n\nB. TM 分阶段运行。在阶段 $n$（其中 $n=0, 1, 2, 3, \\dots$），TM 计算值 $s = n^2$。然后，它将输入字符串的长度 $k$ 与 $s$ 进行比较。如果 $s > k$，TM 判断 $k$ 不可能是完全平方数，于是停机并拒绝。如果 $s = k$，TM 进入一个特殊设计的无限循环。如果 $s  k$，它进入下一个阶段 $n+1$。\n\nC. TM 的状态机中硬编码了一个大的固定整数 $M$（例如 $M=1,000,000$）。对于所有从 $0$ 到 $M$ 的 $n$，TM 生成并测试每个完全平方数 $s=n^2$。如果输入字符串的长度 $k$ 与其中任何一个平方数匹配，TM 停机并接受。如果在检查完直到 $M^2$ 的所有平方数后仍未找到匹配项，TM 停机并拒绝。\n\nD. TM 非确定性地猜测一个整数 $m$，使得 $1 \\le m^2  k$，其中 $k$ 是输入字符串的长度。然后它检查余数 $k - m^2$ 是否也是一个完全平方数（包括 0）。如果它找到了一个满足此条件的 $m$，则停机并接受。如果在所有可能的非确定性路径上都找不到这样的 $m$，则机器拒绝。",
            "solution": "我们使用定义：一台图灵机 (TM) 识别一个语言 $L$，如果对于任意输入 $w$，当 $w \\in L$ 时，它停机并接受；当 $w \\notin L$ 时，它要么停机并拒绝，要么永远运行。这里的语言是一元平方数语言 $L = \\{ a^{k} \\mid \\exists n \\ge 0 \\text{ with } k = n^{2} \\}$。\n\n分析每个策略：\n\n- 选项 A：在阶段 $n = 0,1,2,\\dots$，计算 $s = n^{2}$ 并与 $k$ 比较。如果 $k = s$，停机并接受；否则继续。如果 $k \\in L$，则存在一个 $n$ 使得 $k = n^{2}$，因此机器将在该阶段停机并接受（对于 $k=0$ 的情况，包括 $n=0$）。如果 $k \\notin L$，则对于所有的 $n$ 都有 $k \\ne n^{2}$，所以机器永不停机（永远运行）。这满足了识别器的条件：精确地接受属于语言的成员；对于非成员，允许永不停机。因此，A 是一个正确的识别器。\n\n- 选项 B：在阶段 $n$，计算 $s = n^{2}$。如果 $s > k$，停机并拒绝；如果 $s = k$，进入无限循环；否则继续。对于 $k \\in L$，存在一个 $n$ 使得 $s = k$，但此时机器会进入循环而不会接受，这违反了必须接受语言成员的要求。因此 B 不是 $L$ 的识别器。\n\n- 选项 C：仅测试直到一个固定上限 $M^{2}$ 的 $n^{2}$。如果 $k$ 与某个被测试的平方数匹配，则接受；否则拒绝。对于任何 $k = n^{2} > M^{2}$，即使 $k \\in L$，机器也会停机并拒绝，这违反了识别的定义。因此 C 不是 $L$ 的识别器。\n\n- 选项 D：非确定性地猜测一个 $m$ 满足 $1 \\le m^{2}  k$，并且如果 $k - m^{2}$ 是一个完全平方数（包括 $0$）就接受。一个正确的识别器必须接受所有的 $k = n^{2}$。然而，对于许多平方数（例如 $k=4$ 或 $k=9$），不存在满足 $1 \\le m^{2}  k$ 且 $k - m^{2}$ 是完全平方数的 $m$；唯一的分解是 $k = n^{2} + 0^{2}$，但 $m = n$ 被条件 $m^{2}  k$ 所禁止。因此，该机器无法接受 $L$ 的所有成员。因此 D 不是 $L$ 的识别器。\n\n结论：只有 A 正确地识别了 $L$。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "在掌握了基本定义之后，这个练习将通过一个实际的类比，探讨计算理论中最基本的一个结论。我们将分析一个与程序执行相关的语言（$L_{ACCEPT}$），并证明虽然我们可以为其构建一个识别器，但为其构建一个判定器却是不可能的。这个练习阐明了“可识别”与“可判定”之间的关键区别，并揭示了为什么有些问题是“半可解”的。",
            "id": "1442181",
            "problem": "在计算理论中，我们通过研究抽象机能处理的语言来分析其计算能力。*语言*是某个字母表上字符串的集合。如果存在一个算法（图灵机），它对每个输入字符串都会停机，并正确判断该字符串是否属于该语言，那么这个语言就称为*可判定的*。如果存在一个算法，当输入字符串在该语言中时，它会停机并接受；但当字符串不在该语言中时，它可能会停机并拒绝，或无限循环，那么这个语言就称为*可识别的*。每个可判定的语言也都是可识别的，但反之不一定成立。\n\n考虑一个构建“通用程序验证器”的假想项目。我们将程序及其输入建模为字符串。设一个编码后的程序表示为 $P$，其输入表示为 $I$。我们将程序-输入对表示为单个字符串 $\\langle P, I \\rangle$。\n\n让我们定义与此验证器相关的两个特定语言：\n\n1.  $L_{SYNTAX}$：所有字符串 $\\langle P, I \\rangle$ 的语言，其中字符串 $P$ 代表一个根据特定编程语言语法是语法上有效的程序，而 $I$ 是该程序的有效输入。我们可以假设编译器总能解析字符串 $\\langle P, I \\rangle$，并在有限时间内明确确定其语法是否正确。\n\n2.  $L_{ACCEPT}$：所有字符串 $\\langle P, I \\rangle$ 的语言，使得 $P$ 是一个语法上有效的程序，$I$ 是一个有效输入，并且程序 $P$ 以输入 $I$ 执行时，最终会停机并进入“接受”状态。\n\n根据这些定义和可计算性理论的基本原理，下列哪个陈述准确地描述了 $L_{SYNTAX}$ 和 $L_{ACCEPT}$ 的关系和性质？\n\nA. $L_{ACCEPT}$ 是可判定的，因为它是可判定语言 $L_{SYNTAX}$ 的一个子集。\n\nB. $L_{ACCEPT}$ 不是一个可判定的语言，并且它不是 $L_{SYNTAX}$ 的子集。\n\nC. $L_{ACCEPT}$ 是 $L_{SYNTAX}$ 的一个真子集，并且虽然 $L_{SYNTAX}$ 是可判定的，但 $L_{ACCEPT}$ 是可识别的但不可判定。\n\nD. $L_{SYNTAX}$ 和 $L_{ACCEPT}$ 都是可识别的，但都不是可判定的。\n\nE. $L_{ACCEPT}$ 不是一个可识别的语言。",
            "solution": "我们首先用可计算性理论的术语重申相关定义。如果存在一台图灵机，它对每个输入都会停机并正确判定其成员资格，那么这个语言就是可判定的。如果存在一台图灵机，它对语言中的成员会停机并接受，而对非成员则拒绝或无限循环，那么这个语言就是可识别的。\n\n考虑 $L_{SYNTAX} = \\{\\langle P, I \\rangle : P \\text{ 是一个语法上有效的程序且 } I \\text{ 是 } P \\text{ 的一个有效输入}\\}$。根据假设，存在一个编译器或解析器，可以在有限时间内确定给定的 $\\langle P, I \\rangle$ 语法是否正确。因此，存在一个 $L_{SYNTAX}$ 的判定器，它对所有输入都会停机，并且只接受那些在 $L_{SYNTAX}$ 中的字符串。因此 $L_{SYNTAX}$ 是可判定的。因为每个可判定的语言都是可识别的，所以 $L_{SYNTAX}$ 也是可识别的。\n\n现在考虑 $L_{ACCEPT} = \\{\\langle P, I \\rangle : P \\text{ 语法有效, } I \\text{ 是有效输入, 且 } P \\text{ 在输入 } I \\text{ 上停机并接受}\\}$。根据其定义，如果 $\\langle P, I \\rangle \\in L_{ACCEPT}$，那么 $P$ 语法有效且 $I$ 是一个有效输入。因此我们有集合论上的蕴涵关系\n$$\n\\langle P, I \\rangle \\in L_{ACCEPT} \\implies \\langle P, I \\rangle \\in L_{SYNTAX},\n$$\n这就得出了子集关系\n$$\nL_{ACCEPT} \\subseteq L_{SYNTAX}.\n$$\n此外，这个包含关系是真包含，因为存在语法上有效的程序和输入，程序对其不接受（它可能拒绝或无限循环），所以这些对属于 $L_{SYNTAX}$ 但不属于 $L_{ACCEPT}$。因此\n$$\nL_{ACCEPT} \\subset L_{SYNTAX}.\n$$\n\n接下来，我们分析 $L_{ACCEPT}$ 的可识别性和可判定性。为了证明其可识别性，定义一台图灵机 $U$，它在输入 $\\langle P, I \\rangle$ 上模拟 $P$ 在 $I$ 上的执行：如果模拟在任何时候进入接受状态，$U$ 就接受。如果 $P$ 拒绝或无限循环，$U$ 也可能相应地拒绝或无限循环。这正是一个 $L_{ACCEPT}$ 的识别器，所以 $L_{ACCEPT}$ 是可识别的。\n\n为了证明 $L_{ACCEPT}$ 不是可判定的，我们将停机问题归约到它。令 $HALT = \\{\\langle P, I \\rangle : P \\text{ 在输入 } I \\text{ 上停机}\\}$。假设，为了引出矛盾，存在一个 $L_{ACCEPT}$ 的判定器 $D$。给定 $HALT$ 的一个任意实例 $\\langle P, I \\rangle$，构造一个新程序 $P^{\\dagger}$，它对任何输入 $x$ 都模拟 $P$ 在 $I$ 上的执行，并且如果模拟停机（无论 $P$ 是接受还是拒绝），$P^{\\dagger}$ 就进入接受状态。形式上，$P^{\\dagger}$ 忽略 $x$ 并执行：模拟 $P$ 在 $I$ 上的执行；一旦 $P$ 停机，就接受。这个构造是有效的，并产生一个带有有效输入的语法上有效的程序。于是，对于 $P^{\\dagger}$ 的任何固定的有效输入 $x$，我们有\n$$\n\\langle P, I \\rangle \\in HALT \\iff \\langle P^{\\dagger}, x \\rangle \\in L_{ACCEPT}\n$$\n如果 $D$ 能判定 $L_{ACCEPT}$，我们就可以通过将 $\\langle P, I \\rangle$ 映射到 $\\langle P^{\\dagger}, x \\rangle$ 并运行 $D$ 来判定 $HALT$，但这与已知的 $HALT$ 的不可判定性相矛盾。因此 $L_{ACCEPT}$ 是不可判定的。\n\n综合这些事实：\n- $L_{SYNTAX}$ 是可判定的（因此也是可识别的）。\n- $L_{ACCEPT}$ 是 $L_{SYNTAX}$ 的一个真子集，是可识别的，但不是可判定的。\n\n在给出的选项中，这与选项 C 的描述完全一致。",
            "answer": "$$\\boxed{C}$$"
        },
        {
            "introduction": "一个语言类的强大之处通常体现在其闭包性质上。最后的这个练习将挑战我们去判断可识别语言类是否在“右商”运算下是封闭的。解决这个问题的关键在于设计一种构造性方法（例如，通过“鸽尾”技术），从已有的识别器来构建一个新的识别器，这展示了理论计算机科学中一种强大的证明技巧。",
            "id": "1442152",
            "problem": "在形式语言理论中，一个语言 $L$ 被定义为在某个有限字母表 $\\Sigma$ 上的字符串集合。如果存在一台图灵机 (TM)，对于任何输入字符串 $w$，当且仅当 $w \\in L$ 时，该图灵机停机并接受，那么语言 $L$ 就被称为**可识别的**。对于不属于 $L$ 的字符串，该图灵机可能停机并拒绝，也可能无限循环。已知可识别语言类在某些运算（如并集、交集和连接）下是封闭的。\n\n考虑**右商**运算。对于同一字母表 $\\Sigma$ 上的两个语言 $L_1$ 和 $L_2$，它们的右商，记作 $L_1/L_2$，被定义为如下语言：\n$$L_1/L_2 = \\{x \\in \\Sigma^* \\mid \\text{there exists a string } y \\in L_2 \\text{ such that the concatenation } xy \\in L_1\\}$$\n\n你的任务是确定可识别语言类在右商运算下的封闭性。\n\n下列哪个陈述是正确的？\n\nA. 任意两个可识别语言 $L_1$ 和 $L_2$ 的右商 $L_1/L_2$ 总是可识别的。\n\nB. 右商 $L_1/L_2$ 是可识别的，当且仅当 $L_2$ 是一个可判定语言（即，存在一台能对所有输入停机的图灵机来判定 $L_2$）。\n\nC. 右商 $L_1/L_2$ 是可识别的，当且仅当 $L_1$ 和 $L_2$ 都是可判定语言。\n\nD. 右商 $L_1/L_2$ 不一定是可识别的。存在可识别语言 $L_1$ 和 $L_2$，使得它们的右商 $L_1/L_2$ 不是一个可识别语言。",
            "solution": "给定两个可识别语言 $L_{1}, L_{2} \\subseteq \\Sigma^{*}$，以及分别识别它们的图灵机 $M_{1}$ 和 $M_{2}$，即对于 $i \\in \\{1,2\\}$，$M_{i}$ 仅对 $L_{i}$ 中的字符串停机并接受，而对于不在 $L_{i}$ 中的字符串，它可能拒绝或无限循环。\n\n我们必须确定右商\n$$\nL_{1}/L_{2}=\\{x \\in \\Sigma^{*} \\mid \\exists y \\in \\Sigma^{*} \\text{ such that } y \\in L_{2} \\text{ and } xy \\in L_{1}\\}\n$$\n是否是可识别的，以及在什么条件下是可识别的。\n\n从 $L_{1}$ 和 $L_{2}$ 的识别器构造 $L_{1}/L_{2}$ 的识别器：\n定义一台图灵机 $M$，它在输入 $x \\in \\Sigma^{*}$ 上，对所有 $y \\in \\Sigma^{*}$ 执行交叉搜索，并并行模拟 $M_{2}$ 在输入 $y$ 上的运行以及 $M_{1}$ 在输入连接串 $xy$ 上的运行，具体如下。\n\n图灵机 $M$ 在输入 $x$ 上的算法：\n1. 对于 $t=1,2,3,\\dots$，执行：\n   - 按照一个固定的有效顺序（例如，长度字典序），枚举 $\\Sigma^{*}$ 的前 $t$ 个字符串 $y_{1},\\dots,y_{t}$。\n   - 对于每个 $j \\in \\{1,\\dots,t\\}$，模拟 $M_{2}$ 在输入 $y_{j}$ 上运行 $t$ 步，并模拟 $M_{1}$ 在输入 $xy_{j}$ 上运行 $t$ 步。\n   - 如果对于某个 $j \\in \\{1,\\dots,t\\}$，两个模拟都在已执行的步数内进入了它们的接受状态，则接受 $x$。\n\n正确性：\n- 可靠性 (Soundness)：如果 $M$ 接受 $x$，那么存在某个 $y_{j}$ 使得 $M_{2}$ 接受 $y_{j}$ 且 $M_{1}$ 接受 $xy_{j}$，因此 $y_{j} \\in L_{2}$ 且 $xy_{j} \\in L_{1}$。根据定义，所以 $x \\in L_{1}/L_{2}$。\n- 完备性 (Completeness)：假设 $x \\in L_{1}/L_{2}$。那么存在 $y \\in \\Sigma^{*}$ 使得 $y \\in L_{2}$ 且 $xy \\in L_{1}$。设 $s_{2}$ 是 $M_{2}$ 接受 $y$ 所需的有限步数，$s_{1}$ 是 $M_{1}$ 接受 $xy$ 所需的有限步数。选择一个足够大的 $t \\ge \\max\\{s_{1},s_{2}\\}$，使得 $y$ 在 $y_{1},\\dots,y_{t}$ 之中，并且 $t$ 步的模拟足以覆盖这两个接受过程。那么在阶段 $t$，$M$ 将检测到两个模拟都已接受，并会接受 $x$。因此，如果 $x \\in L_{1}/L_{2}$，$M$ 会停机并接受 $x$。\n\n如果 $x \\notin L_{1}/L_{2}$，那么对于每一个 $y \\in \\Sigma^{*}$，在 $M_{2}$ 对 $y$ 的运行或 $M_{1}$ 对 $xy$ 的运行中，至少有一个不接受；因此 $M$ 永远不会找到见证接受的配对，可能会永远运行下去，这对于一个识别器是允许的。因此，$M$ 识别 $L_{1}/L_{2}$。\n\n这个构造仅用到了 $L_{1}$ 和 $L_{2}$ 是可识别的（即 $M_{1}$ 和 $M_{2}$ 的存在性）以及标准的交叉法原理来实现存在性搜索。对 $L_{2}$ 的可判定性没有要求。\n\n对选项的推论：\n- A 是正确的：对于任意可识别语言 $L_{1}$ 和 $L_{2}$，根据上述构造，右商 $L_{1}/L_{2}$ 是可识别的。\n- B 是错误的：$L_{1}/L_{2}$ 的可识别性不要求 $L_{2}$ 是可判定的；$L_{2}$ 的可识别性就足够了。\n- C 是错误的：不需要 $L_{1}$ 和 $L_{2}$ 都是可判定的；两者都是可识别的就足够了。\n- D 是错误的：该构造表明，对于可识别的 $L_{1}$ 和 $L_{2}$，不存在反例。\n\n因此，正确的陈述是 A。",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}