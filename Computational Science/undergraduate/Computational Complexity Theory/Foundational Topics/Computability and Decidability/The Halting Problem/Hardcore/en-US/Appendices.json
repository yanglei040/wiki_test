{
    "hands_on_practices": [
        {
            "introduction": "The proof of the Halting Problem's undecidability is famously built on a technique called diagonalization, which reveals a self-referential paradox. This thought experiment () allows you to explore this powerful idea in a concrete, hands-on way. By constructing a hypothetical \"adversarial\" machine and analyzing its behavior, you will uncover the logical contradiction that lies at the very heart of computability theory.",
            "id": "1457066",
            "problem": "In the study of computability theory, we often analyze the behavior of hypothetical computing machines, known as Turing Machines. For this problem, consider a set of Turing Machines, denoted $M_1, M_2, M_3, \\dots$. Each machine can be uniquely described by a finite string of symbols, denoted $\\langle M_i \\rangle$. We can feed the description of one machine, say $\\langle M_j \\rangle$, as the input to another machine, $M_i$. The result of this computation, denoted $M_i(\\langle M_j \\rangle)$, is that the machine $M_i$ either eventually halts (`HALT`) or runs forever (`LOOP`).\n\nThe behavior of the first three such machines on the first three inputs is summarized in the table below:\n\n| | Input $\\langle M_1 \\rangle$ | Input $\\langle M_2 \\rangle$ | Input $\\langle M_3 \\rangle$ |\n| :--- | :--- | :--- | :--- |\n| **Machine $M_1$** | `LOOP` | `HALT` | `HALT` |\n| **Machine $M_2$** | `HALT` | `LOOP` | `HALT` |\n| **Machine $M_3$** | `LOOP` | `LOOP` | `LOOP` |\n\nFor example, the entry in the second row and third column indicates that machine $M_2$ when given the input string $\\langle M_3 \\rangle$ will eventually halt: $M_2(\\langle M_3 \\rangle) \\to \\text{`HALT`}$. The entry in the first row and first column indicates that $M_1(\\langle M_1 \\rangle) \\to \\text{`LOOP`}$.\n\nNow, let's define a new Turing Machine, called the \"Diagonal Machine\" $D$. The behavior of $D$ is defined for *any* machine description $\\langle M_i \\rangle$ as input:\n1.  Upon receiving an input $\\langle M_i \\rangle$, machine $D$ first determines the result of running machine $M_i$ on its own description, $M_i(\\langle M_i \\rangle)$. This is equivalent to looking at the diagonal entries of the (infinitely large version of the) table above.\n2.  If the result of $M_i(\\langle M_i \\rangle)$ is `HALT`, then machine $D$ is defined to enter an infinite `LOOP`.\n3.  If the result of $M_i(\\langle M_i \\rangle)$ is `LOOP`, then machine $D$ is defined to `HALT`.\n\nIn essence, $D$ is constructed to behave oppositely to the diagonal entries. Since $D$ is a Turing Machine, it must also have its own string description, $\\langle D \\rangle$.\n\nWhat is the resulting behavior of the machine $D$ when it is run with its own description, $\\langle D \\rangle$, as input?\n\nA. $D$ on input $\\langle D \\rangle$ will HALT.\n\nB. $D$ on input $\\langle D \\rangle$ will LOOP.\n\nC. The behavior is undefined because $D$ is not one of the machines in the original table ($M_1, M_2, M_3$).\n\nD. The machine $D$ as described is self-contradictory and thus cannot be constructed.",
            "solution": "We are given a countable list of Turing machines $\\{M_{1},M_{2},\\dots\\}$ with encodings $\\langle M_{i}\\rangle$, and a definition of a machine $D$ that, on input $\\langle M_{i}\\rangle$, first determines the outcome of $M_{i}(\\langle M_{i}\\rangle)$ and then does the opposite: if $M_{i}(\\langle M_{i}\\rangle)$ halts then $D$ loops, and if $M_{i}(\\langle M_{i}\\rangle)$ loops then $D$ halts.\n\nFormally, for each $i$,\n$$\nD(\\langle M_{i}\\rangle)=\\text{HALT} \\iff M_{i}(\\langle M_{i}\\rangle)=\\text{LOOP},\n$$\nand equivalently,\n$$\nD(\\langle M_{i}\\rangle)=\\text{LOOP} \\iff M_{i}(\\langle M_{i}\\rangle)=\\text{HALT}.\n$$\n\nSince $D$ is a Turing machine, it has an encoding $\\langle D\\rangle$. Substituting $M_{i}=D$ yields the self-application condition\n$$\nD(\\langle D\\rangle)=\\text{HALT} \\iff D(\\langle D\\rangle)=\\text{LOOP}.\n$$\nThis equivalence cannot be satisfied by any outcome in the two-valued setting: assuming $D(\\langle D\\rangle)=\\text{HALT}$ forces $D(\\langle D\\rangle)=\\text{LOOP}$, and assuming $D(\\langle D\\rangle)=\\text{LOOP}$ forces $D(\\langle D\\rangle)=\\text{HALT}$. Hence no consistent behavior can be assigned to $D$ on input $\\langle D\\rangle$.\n\nTherefore, the specification of $D$ presupposes the ability to decide $M_{i}(\\langle M_{i}\\rangle)$ for arbitrary $i$, which leads to a contradiction when applied to $i$ such that $M_{i}=D$. In standard computability theory, this shows that such a $D$ cannot be constructed as a Turing machine. The correct choice is that the described $D$ is self-contradictory and cannot be constructed.",
            "answer": "$$\\boxed{D}$$"
        },
        {
            "introduction": "While diagonalization provides the initial spark of contradiction, the workhorse of undecidability proofs is the method of reduction. This exercise () puts you in the designer's seat, tasking you with constructing a Turing Machine for a specific purpose within a proof. Mastering this construction is key to demonstrating that if one could solve a new problem, they could impossibly solve the known-to-be-undecidable Acceptance Problem, $A_{TM}$.",
            "id": "1457092",
            "problem": "In theoretical computer science, a key result is the undecidability of the Acceptance Problem for Turing Machines. Let a Turing Machine (TM) be a formal model of computation, analogous to a computer program. The language corresponding to the Acceptance Problem is denoted as $A_{TM} = \\{ \\langle M, w \\rangle \\mid M \\text{ is a TM that accepts the input string } w \\}$. It is a foundational theorem that no algorithm exists that can decide for all pairs $\\langle M, w \\rangle$ whether $M$ accepts $w$. In other words, $A_{TM}$ is an undecidable language.\n\nNow, consider a related but seemingly simpler problem. Let's define the language $HALT_{\\epsilon} = \\{ \\langle M \\rangle \\mid M \\text{ is a TM that halts on the empty input string } \\epsilon \\}$. A computer scientist conjectures that $HALT_{\\epsilon}$ is also undecidable. To investigate this, she attempts to show that if a hypothetical algorithm existed that could decide $HALT_{\\epsilon}$, it could be used as a subroutine to build an algorithm that decides the impossible problem $A_{TM}$, leading to a contradiction.\n\nThe strategy is as follows: to decide if a given TM $M$ accepts a string $w$ (i.e., to solve an instance $\\langle M, w \\rangle$ of $A_{TM}$), we first construct a new TM, let's call it $M_{construct}$. The behavior of $M_{construct}$ is specifically engineered based on $M$ and $w$. Then, we feed the description of $M_{construct}$ to our hypothetical decider for $HALT_{\\epsilon}$. The output of this decider (whether $M_{construct}$ halts on $\\epsilon$ or not) should tell us definitively whether $M$ accepts $w$.\n\nWhich of the following correctly describes the necessary behavior of the machine $M_{construct}$ when it is run on the empty string $\\epsilon$, such that this strategy successfully proves that $HALT_{\\epsilon}$ is undecidable?\n\nA. On input $\\epsilon$, $M_{construct}$ simulates $M$ on input $w$. If the simulation shows that $M$ accepts $w$, $M_{construct}$ halts. If the simulation shows that $M$ rejects $w$, $M_{construct}$ enters an infinite loop.\n\nB. On input $\\epsilon$, $M_{construct}$ simulates $M$ on input $w$. If the simulation shows that $M$ halts on $w$ (for any reason, accepting or rejecting), $M_{construct}$ halts. Otherwise, it enters an infinite loop.\n\nC. On input $\\epsilon$, $M_{construct}$ simulates $M$ on the empty string $\\epsilon$. If the simulation shows that $M$ accepts $\\epsilon$, $M_{construct}$ halts. If the simulation shows that $M$ rejects $\\epsilon$, $M_{construct}$ enters an infinite loop.\n\nD. On input $\\epsilon$, $M_{construct}$ simulates $M$ on input $w$. If the simulation shows that $M$ accepts $w$, $M_{construct}$ enters an infinite loop. If the simulation shows that $M$ rejects $w$, $M_{construct}$ halts.\n\nE. On input $\\epsilon$, $M_{construct}$ simulates $M$ on input $w$. It is designed to enter an accept state if and only if $M$ accepts $w$.",
            "solution": "We aim to show that a hypothetical decider for $HALT_{\\epsilon}=\\{\\langle M\\rangle\\mid M\\text{ halts on }\\epsilon\\}$ could be used to decide $A_{TM}=\\{\\langle M,w\\rangle\\mid M\\text{ accepts }w\\}$. This requires a computable transformation $f$ that maps any pair $\\langle M,w\\rangle$ to a machine $\\langle M_{construct}\\rangle$ such that the following equivalence holds:\n$$\n\\langle M,w\\rangle\\in A_{TM}\\iff \\langle M_{construct}\\rangle\\in HALT_{\\epsilon}.\n$$\nIf such $f$ exists, then given a decider for $HALT_{\\epsilon}$ we could decide $A_{TM}$ by applying $f$ and running the decider on $\\langle M_{construct}\\rangle$. Since $A_{TM}$ is undecidable, this would imply $HALT_{\\epsilon}$ is undecidable.\n\nTherefore, $M_{construct}$ must be defined so that it halts on input $\\epsilon$ if and only if $M$ accepts $w$. A correct construction is:\n- On input $\\epsilon$, simulate $M$ on input $w$.\n- If the simulation shows that $M$ accepts $w$, then halt (e.g., accept).\n- If the simulation shows that $M$ rejects $w$, then loop forever.\n- If $M$ does not halt on $w$, the simulation never finishes, so $M_{construct}$ also does not halt.\n\nThis ensures the exact equivalence\n$$\n\\langle M,w\\rangle\\in A_{TM}\\iff M\\text{ accepts }w\\iff M_{construct}\\text{ halts on }\\epsilon\\iff \\langle M_{construct}\\rangle\\in HALT_{\\epsilon}.\n$$\nThus a decider for $HALT_{\\epsilon}$ would decide $A_{TM}$ via the mapping $\\langle M,w\\rangle\\mapsto \\langle M_{construct}\\rangle$, which is a contradiction. Hence $HALT_{\\epsilon}$ is undecidable.\n\nAmong the options:\n- A matches the required construction precisely.\n- B makes halting on $\\epsilon$ correspond to $M$ halting on $w$ for any reason, which reduces to the general halting problem rather than acceptance; it does not decide $A_{TM}$ as required by the strategy.\n- C simulates $M$ on $\\epsilon$ instead of $w$, breaking the needed correspondence to the given instance $\\langle M,w\\rangle$.\n- D makes halting on $\\epsilon$ correspond to $M$ rejecting $w$, which does not decide $A_{TM}$ as stated.\n- E is ambiguous: entering an accept state implies halting, but it does not preclude also halting by rejection when $M$ rejects $w$, so it does not guarantee the required iff condition for halting versus acceptance.\n\nTherefore, the correct description is A.",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "The power of reduction proofs lies in their precise logical structure, and a common pitfall is reversing the direction of the implication. This exercise () presents a flawed proof and asks you to act as a reviewer, pinpointing the exact error in the student's reasoning. Correctly diagnosing this mistake is crucial for building sound and valid arguments about the undecidability of computational problems.",
            "id": "1457073",
            "problem": "A student in a theory of computation course, Alice, is tasked with proving that a particular language, `TOTAL_TM`, is undecidable. The language is defined as `TOTAL_TM` = $\\{ \\langle M \\rangle \\mid M \\text{ is a Turing Machine (TM) that halts on all possible input strings} \\}$.\n\nAlice knows that the standard halting problem, $A_{TM} = \\{ \\langle M, w \\rangle \\mid M \\text{ is a TM that halts on input } w \\}$, is a famous undecidable language.\n\nTo prove her claim, she correctly constructs a computable function $f$ that transforms any instance $\\langle M \\rangle$ of `TOTAL_TM` into an instance $\\langle M', w' \\rangle = f(\\langle M \\rangle)$ of $A_{TM}$, such that $\\langle M \\rangle \\in \\text{`TOTAL_TM`}$ if and only if $\\langle M', w' \\rangle \\in A_{TM}$. This establishes a mapping reduction from `TOTAL_TM` to $A_{TM}$ (denoted as $\\text{`TOTAL_TM`} \\le_m A_{TM}$).\n\nAlice then concludes her proof: \"Since I have shown that `TOTAL_TM` is reducible to $A_{TM}$, and we know that $A_{TM}$ is undecidable, it logically follows that `TOTAL_TM` must also be undecidable.\"\n\nWhich of the following statements best explains the fundamental flaw in Alice's reasoning?\n\nA. To prove a language $P$ is undecidable via reduction, one must reduce a known undecidable language $U$ *to* $P$ (i.e., show $U \\le_m P$), not the other way around. Alice's reduction direction is incorrect for her stated purpose.\n\nB. The language `TOTAL_TM` is not Turing-recognizable, whereas $A_{TM}$ is. A mapping reduction is only valid between languages that are in the same class of recognizability (i.e., both are recognizable or both are not).\n\nC. Alice's argument is circular. In order to construct the computable function $f$, she must have implicitly assumed a method for deciding `TOTAL_TM`, which contradicts the claim she is trying to prove.\n\nD. The reduction is invalid because `TOTAL_TM` is known to be a \"harder\" problem than $A_{TM}$. It is a foundational theorem of computability theory that one cannot reduce a computationally harder problem to an easier one.\n\nE. Any reduction from a language that takes a single encoding $\\langle M \\rangle$ as input to a language that takes a pair $\\langle M, w \\rangle$ as input is inherently flawed because it requires manufacturing information (the string $w$) that was not present in the original input.",
            "solution": "We are given the language $\\text{TOTAL\\_TM} = \\{ \\langle M \\rangle \\mid M \\text{ halts on all inputs} \\}$ and the halting problem $A_{TM} = \\{ \\langle M, w \\rangle \\mid M \\text{ halts on } w \\}$, where $A_{TM}$ is known to be undecidable. Alice shows a mapping reduction $\\text{TOTAL\\_TM} \\le_{m} A_{TM}$ and concludes that $\\text{TOTAL\\_TM}$ is undecidable.\n\nRecall the definition: For languages $A$ and $B$, $A \\le_{m} B$ means there exists a total computable function $f$ such that for all strings $x$, \n$$x \\in A \\iff f(x) \\in B.$$\n\nKey property of mapping reductions:\n- If $A \\le_{m} B$ and $B$ is decidable, then $A$ is decidable. Proof: Given a decider for $B$, decide $A$ on input $x$ by computing $f(x)$ and running the decider for $B$; accept iff it accepts. \n- The contrapositive of this statement is: If $A$ is undecidable and $A \\le_{m} B$, then $B$ is undecidable.\n\nTherefore, to prove that a target language $P$ is undecidable by reduction, one must reduce a known undecidable language $U$ to $P$, that is, show $U \\le_{m} P$. Then, if $P$ were decidable, $U$ would be decidable, contradicting the known undecidability of $U$.\n\nAlice instead showed $\\text{TOTAL\\_TM} \\le_{m} A_{TM}$. From the fundamental property above, this implication only yields:\n$$\\text{If } A_{TM} \\text{ were decidable, then } \\text{TOTAL\\_TM} \\text{ would be decidable.}$$\nBut since $A_{TM}$ is undecidable, this conditional tells us nothing about the decidability of $\\text{TOTAL\\_TM}$. Hence Alice’s conclusion does not follow.\n\nA concrete illustration that such a reduction direction does not prove undecidability: Let $L$ be any decidable language. Let $D$ be its decider. Define a computable $f$ that, on input $x$, runs $D(x)$ and outputs a fixed pair $\\langle M_{halt}, w_{halt} \\rangle \\in A_{TM}$ if $D$ accepts, and a fixed pair $\\langle M_{loop}, w_{loop} \\rangle \\notin A_{TM}$ if $D$ rejects. Then $x \\in L \\iff f(x) \\in A_{TM}$, so $L \\le_{m} A_{TM}$, yet $L$ is decidable. Thus, showing $P \\le_{m} A_{TM}$ does not establish that $P$ is undecidable.\n\nTherefore, the fundamental flaw is the direction of the reduction. This corresponds to option A. The other options are incorrect because: mapping reductions do not require equal recognizability status (B is false), constructing $f$ does not assume a decider for $\\text{TOTAL\\_TM}$ (C is false), the “harder to easier” phrasing is not the formal criterion at play (D is misleading), and producing pairs from singles is standard via computable padding or hardcoding (E is false).",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}