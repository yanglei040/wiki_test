{
    "hands_on_practices": [
        {
            "introduction": "证明一个问题不可判定，归约法是我们的核心工具。其精髓在于构建一台新的图灵机 $M'$，其行为与原问题 $\\langle M, w \\rangle$ 的答案精确挂钩。这次的练习  将带你深入理解归约的逻辑核心：我们必须确保 $M'$ 仅在且仅在 $M$ 接受 $w$ 时，才表现出某种特定行为。这要求我们巧妙地设计 $M'$ 的模拟过程，以避免在不应触发条件时意外触发。",
            "id": "1468757",
            "problem": "在计算理论中，证明一个语言不可判定的标准技术是将其从一个已知的不可判定语言进行归约。考虑语言 $A_{TM} = \\{ \\langle M, w \\rangle \\mid M \\text{ 是一台接受输入字符串 } w \\text{ 的图灵机 (TM)} \\}$。$A_{TM}$是不可判定的，这是一个基础性结论。\n\n一位计算机科学家想要证明以下我们称之为 $L_{REP\\_SYM}$ 的语言也是不可判定的：\n$L_{REP\\_SYM} = \\{ \\langle M \\rangle \\mid M \\text{ 是一台图灵机，当其在空输入字符串 } \\epsilon \\text{ 上运行时，最终会在其带上连续两次写入相同的非空白符号} \\}$。\n\n为此，她计划将 $A_{TM}$ 归约到 $L_{REP\\_SYM}$。这需要一个过程，该过程接受 $A_{TM}$ 问题的任意实例 $\\langle M, w \\rangle$，并构造一个 $L_{REP\\_SYM}$ 问题的实例 $\\langle M' \\rangle$，使得：\n$M$ 接受 $w$ 当且仅当 $M'$ 在空字符串 $\\epsilon$ 上运行时，连续两次写入相同的非空白符号。\n\n以下是构造机器 $M'$ 的四种不同提议。这些提议中，哪一个能够通过从 $A_{TM}$ 进行归约来正确地证明 $L_{REP\\_SYM}$ 的不可判定性？\n\nA. 在输入 $\\epsilon$ 上，机器 $M'$ 模拟机器 $M$ 在输入 $w$ 上的执行。如果模拟显示 $M$ 停机并接受 $w$，则 $M'$ 进入一个特殊的状态序列，使其连续写入符号 '1' 两次然后停机。\n\nB. 在输入 $\\epsilon$ 上，机器 $M'$ 检查机器 $M$ 的编码 $\\langle M \\rangle$。如果字符串 $\\langle M \\rangle$ 包含任何连续重复两次的字符，$M'$ 就连续写入符号 '1' 两次并停机。否则，$M'$ 立即停机而不写入任何内容。\n\nC. 在输入 $\\epsilon$ 上，机器 $M'$ 模拟机器 $M$ 在输入 $w$ 上的执行。对于 $M$ 的带字母表中的任何符号 $\\sigma$，$M'$ 在其自己的字母表中使用两个新符号 $\\sigma_A$ 和 $\\sigma_B$。当模拟 $M$ 写入 $\\sigma$ 时，$M'$ 交替写入 $\\sigma_A$ 和 $\\sigma_B$ 以确保在此阶段没有非空白符号被重复。如果 $M$ 在 $w$ 上的模拟停机并接受，$M'$ 接着连续写入一个新的特殊符号 'x' 两次并停机。\n\nD. 在输入 $\\epsilon$ 上，机器 $M'$ 将字符串 $w$ 写入其带上。然后它在 $M$ 的描述上运行一个通用图灵机模拟器，以 $w$ 作为带输入。如果模拟因任何原因（接受或拒绝）停机，$M'$ 就连续写入符号 '1' 两次。如果模拟循环，$M'$ 也循环。",
            "solution": "我们必须提供一个从 $A_{TM}$ 到 $L_{REP\\_SYM}$ 的可计算映射归约 $f$，使得对于每个输入 $\\langle M,w \\rangle$，构造出的机器 $M' = f(\\langle M,w \\rangle)$ 满足\n$$\n\\langle M,w \\rangle \\in A_{TM} \\iff \\langle M' \\rangle \\in L_{REP\\_SYM}\n$$\n即，$M$ 接受 $w$ 当且仅当在 $\\epsilon$ 上启动时，$M'$ 最终在其带上连续两次写入相同的非空白符号。关键在于，构造必须确保除非 $M$ 接受 $w$，否则 $M'$ 不会意外地满足“连续两次”写入的条件。\n\n评估每个提议：\n\nA. 这个 $M'$ 模拟 $M$ 在 $w$ 上的运行，如果发现 $M$ 停机并接受，它就连续写入两次 '1' 并停机。正向蕴含成立：如果 $M$ 接受 $w$，那么 $M'$ 确实会写入重复的符号。然而，反向蕴含可能不成立，因为在模拟阶段，$M'$ 本身可能连续两次写入相同的非空白符号，即使 $M$ 从未接受。例如，假设 $M$ 是这样一台机器：它在任何输入上执行两个连续的相同非空白符号的写入步骤（比如在两个连续的转移中写入 '1'），然后拒绝。那么 $M$ 不接受 $w$，但 $M'$ 在模拟过程中会产生“连续两次相同的写入”。因此\n$$\n\\langle M,w \\rangle \\notin A_{TM} \\quad \\text{but} \\quad \\langle M' \\rangle \\in L_{REP\\_SYM}\n$$\n违反了所要求的等价性。所以A不是一个正确的归约。\n\nB. 这个 $M'$ 检查 $\\langle M \\rangle$ 并在其编码中查找相邻的重复字符；如果找到，它就写入两次 '1' 并停机，否则立即停机。这种行为仅取决于 $\\langle M \\rangle$ 的语法形式，而忽略了 $w$ 以及 $M$ 是否接受 $w$ 的语义问题。因此，可能存在具有相同编码属性（或简单的重命名）但接受行为不同的 $\\langle M,w \\rangle$ 和 $\\langle N,u \\rangle$，所以等价性\n$$\n\\langle M,w \\rangle \\in A_{TM} \\iff \\langle M' \\rangle \\in L_{REP\\_SYM}\n$$\n无法保证。因此B不是一个正确的归约。\n\nC. 这个 $M'$ 模拟 $M$ 在 $w$ 上的运行，但对于 $M$ 的每个带符号 $\\sigma$，$M'$ 在其自己的字母表中使用两个不同的符号 $\\sigma_{A}$ 和 $\\sigma_{B}$，并且在 $M$ 每次写入 $\\sigma$ 时交替使用它们。这确保了在模拟阶段，$M'$ 绝不会在连续的写入步骤中写入相同的非空白符号：如果在模拟运行中的两次连续写入是相同的基础符号 $\\sigma$，那么 $M'$ 会写入 $\\sigma_{A}$ 然后是 $\\sigma_{B}$（或反之），这两个是不同的；如果基础符号不同，那么写入的符号本来就不同。模拟之后，当且仅当 $M$ 停机并接受 $w$ 时，$M'$ 才会连续写入一个新的特殊符号 $x$ 两次并停机。因此：\n- 如果 $M$ 接受 $w$，那么 $M'$ 最终会连续写入两次 $x$，所以 $\\langle M' \\rangle \\in L_{REP\\_SYM}$。\n- 如果 $M$ 不接受 $w$（拒绝或循环），那么 $M'$ 永远不会进入接受后阶段，并且根据交替写入机制的构造，在模拟期间也永远不会连续两次写入相同的非空白符号。因此 $\\langle M' \\rangle \\notin L_{REP\\_SYM}$。\n因此\n$$\n\\langle M,w \\rangle \\in A_{TM} \\iff \\langle M' \\rangle \\in L_{REP\\_SYM}\n$$\n且该映射是可计算的。所以C是一个正确的归约，它确立了 $L_{REP\\_SYM}$ 的不可判定性。\n\nD. 这个 $M'$ 首先将 $w$ 写入其带上，然后模拟 $M$ 在 $w$ 上的运行，如果模拟因任何原因停机，就写入 '1' '1'。这里有两个明显的失败点：(i) 在写入输入 $w$ 时，如果 $w$ 包含任何相邻的相同符号，$M'$ 将立即连续两次写入相同的非空白符号，这与 $M$ 的行为无关；(ii) 即使忽略这一点，触发条件是 $M$ 是否停机（接受或拒绝），而不是 $M$ 是否接受，因此它归约到的是停机问题，而不是 $A_{TM}$。在任何一种情况下，与接受的等价性都失败了，所以D不是一个正确的归约。\n\n结论：只有提议C实现了一个从 $A_{TM}$ 到 $L_{REP\\_SYM}$ 的有效的多一归约。",
            "answer": "$$\\boxed{C}$$"
        },
        {
            "introduction": "在构建归约时，一个常见的挑战是如何在模拟原机器的过程中，防止新机器意外满足目标属性。一个强大的技巧是“隔离”该属性，即在模拟阶段创造一个绝不会出现该属性的环境。这个练习  完美地展示了这一思想，它通过使用特殊的边界标记，确保带内容在模拟过程中永远不会形成回文串。只有当模拟成功结束后，才刻意构造出目标回文串，从而建立起清晰的“当且仅当”的逻辑联系。",
            "id": "1468753",
            "problem": "在可计算性理论的研究中，图灵机（TM）的一个格局（configuration）由其当前状态、带上内容以及读写头的位置定义。带上内容是指带上的符号串。如果一个字符串正读和反读相同（例如，\"racecar\"），则它是一个回文串。\n\n考虑以下语言，我们称之为 `PAL_CONF`：\n语言 `PAL_CONF` 由所有序对 `⟨M, w⟩` 组成，其中 `M` 是一台图灵机的描述，`w` 是一个输入字符串，使得当 `M` 在输入 `w` 上运行时，它最终会达到一个格局，在该格局下，其带上连续的非空白符号串是一个非空回文串。\n\n下列哪个陈述正确地分类了语言 `PAL_CONF`？\n\nA. 语言 `PAL_CONF` 是可判定的。\nB. 语言 `PAL_CONF` 是不可判定的，但它是图灵可识别的。\nC. 语言 `PAL_CONF` 是不可判定的且不是图灵可识别的。\nD. `PAL_CONF` 的分类取决于用于图灵机的具体编码方式。",
            "solution": "我们将该语言形式化为\n$$\n\\mathrm{PAL\\_CONF}=\\{\\langle M,w\\rangle \\mid \\text{在 } w \\text{ 上运行 } M \\text{ 最终会达到一个格局，其连续的非空白带串是一个非空回文串}\\}.\n$$\n\n首先，我们证明 $\\mathrm{PAL\\_CONF}$ 是图灵可识别的。给定一个输入 $\\langle M,w\\rangle$，构造一个识别器 $R$，它一步一步地模拟 $M$ 在 $w$ 上的运行。在每个模拟步骤之后，$R$ 通过定位最左边和最右边的非空白符号，并提取它们之间的连续块来计算当前的带上内容串 $s$。然后 $R$ 检查是否有 $|s|\\geq 1$ 以及 $s$ 是否等于其反向字符串。如果两个条件都成立，$R$ 接受；否则，它继续模拟。如果 $\\langle M,w\\rangle\\in\\mathrm{PAL\\_CONF}$，那么在某个有限的时间点，模拟的运行会呈现出这样的格局，并且 $R$ 会接受。如果不是，则 $R$ 永远不会接受。因此 $\\mathrm{PAL\\_CONF}$ 是图灵可识别的。\n\n其次，我们通过从停机问题进行映射归约来证明 $\\mathrm{PAL\\_CONF}$ 是不可判定的\n$$\nH=\\{\\langle M,w\\rangle \\mid M \\text{ 在 } w \\text{ 上停机}\\}.\n$$\n给定任意 $\\langle M,w\\rangle$，我们可计算地生成一个序对 $\\langle M',x\\rangle$（我们选择 $x$ 为一个固定字符串，例如空字符串），使得 $M'$ 在输入 $x$ 上达到一个具有非空回文带块的格局当且仅当 $M$ 在 $w$ 上停机。\n\n$M'$ 的构造：\n- $M'$ 使用一个带字母表，其中包括空白符号 $\\sqcup$、两个不同的边界标记 $L$ 和 $R$，以及一个符号 $A$，其中 $A\\neq\\sqcup$, $A\\neq L$, $A\\neq R$。\n- 在输入 $x$ 上，$M'$ 初始化其带，使其恰好包含字符串 $L\\,w\\,R$，没有其他非空白符号，并将其读写头定位在 $w$ 的第一个符号上（如果 $w$ 是空的，则读写头定位在 $L$ 和 $R$ 之间）。\n- $M'$ 接着模拟 $M$ 在输入 $w$ 上的运行，只使用严格在 $L$ 和 $R$ 标记之间的单元格作为模拟带。如果模拟的读写头要移动到当前边界之外，$M'$ 会将相应的边界标记向外移动一个单元格，保持不变量，即 $L$ 始终是最左边的非空白符号，$R$ 始终是最右边的非空白符号，且 $L\\neq R$。在任何这样的边界调整期间，$M'$ 确保当前最右边的非空白符号总是 $R$（最左边的总是 $L$），因此整个非空白块继续以 $L$ 开始并以 $R$ 结束。\n- 如果模拟的 $M$ 在 $w$ 上停机，$M'$ 就进入一个特殊阶段：它擦除整个非空白块，并在带上准确写入双符号字符串 $A A$，从而产生一个其连续非空白块为非空回文串 $A A$ 的格局。\n\n归约的正确性：\n- 如果 $M$ 在 $w$ 上停机，那么 $M'$ 最终会进入特殊阶段，并产生一个带上内容为 $A A$ 的格局，这是一个非空回文串。因此 $\\langle M',x\\rangle\\in\\mathrm{PAL\\_CONF}$。\n- 如果 $M$ 不在 $w$ 上停机，那么 $M'$ 永远不会退出模拟阶段。根据构造，在每一步中，最左边的非空白符号是 $L$，最右边的非空白符号是 $R$，且 $L\\neq R$。因此，在任何时候，连续的非空白块都不是回文串。因此 $\\langle M',x\\rangle\\notin\\mathrm{PAL\\_CONF}$。\n\n因此我们有一个可计算的映射 $f$，满足 $f(\\langle M,w\\rangle)=\\langle M',x\\rangle$，使得\n$$\n\\langle M,w\\rangle\\in H \\iff f(\\langle M,w\\rangle)\\in \\mathrm{PAL\\_CONF}.\n$$\n因此 $H\\leq_{m}\\mathrm{PAL\\_CONF}$。因为 $H$ 是不可判定的，所以 $\\mathrm{PAL\\_CONF}$ 也是不可判定的。结合上面的识别器，$\\mathrm{PAL\\_CONF}$ 是不可判定的，但图灵可识别。\n\n因此，正确的分类是选项 B。",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "归约法的威力远不止于证明图灵机的属性是不可判定的。它是一座桥梁，能将一个领域的不可判定性传递到另一个看似无关的领域。在这个进阶练习  中，我们将离开图灵机的直接世界，转而探讨形式语言的奥秘。你将学习如何从另一个著名的不可判定问题——波斯特对应问题 (Post's Correspondence Problem, PCP) 出发，通过精巧的编码和文法构造，证明一个关于上下文无关文法 (CFG) 的问题也是不可判定的。",
            "id": "1468756",
            "problem": "在合成生物学领域，工程师们设计人工基因回路。这类回路其一的一个简化输出模型由一个上下文无关文法（CFG）$G$ 描述，该文法建立在字母表 $\\Sigma = \\{A, C, T, G\\}$ 之上，代表四种核苷酸碱基。一项关键的分析任务是确定该回路是否可能产生一种特定的、具有生物学意义的非编码序列，称为“稳定的三方重复序列”，其抽象形式为 $A^n C^n G^n$，其中 $n \\ge 1$ 为某个整数。一个能检查这种可能性的通用算法将具有不可估量的价值。\n\n你的任务是确定这样一种通用算法在理论上是否可能存在。将此问题构建为一个判定问题：“ACG交集问题”旨在判定对于字母表 $\\{A, C, G\\}$ 上的任意输入CFG $G$，其语言 $L(G)$ 是否与语言 $L_{ACG} = \\{A^n C^n G^n \\mid n \\ge 1\\}$ 存在非空交集。\n\n该问题的语言形式化表述为：\n$$ L_{INTER} = \\{ \\langle G \\rangle \\mid G \\text{ 是 } \\{A, C, G\\} \\text{ 上的CFG且 } L(G) \\cap \\{A^n C^n G^n \\mid n \\ge 1\\} \\neq \\emptyset \\} $$\n你的任务是证明ACG交集问题是不可判定的。你必须通过从已知的不可判定问题——波斯特对应问题（PCP）——进行完整归约来完成此证明。\n\n为清楚起见，一个PCP实例是一组“多米诺骨牌” $P = \\{ [t_1/b_1], [t_2/b_2], \\dots, [t_k/b_k] \\}$，其中 $t_i$（顶部）和 $b_i$（底部）是某个字母表 $\\Sigma_P$ 上的非空字符串。一个PCP实例的解是一个索引序列 $i_1, i_2, \\dots, i_m$（$m \\ge 1$），使得顶部字符串的串联与底部字符串的串联相匹配：$t_{i_1}t_{i_2}\\dots t_{i_m} = b_{i_1}b_{i_2}\\dots b_{i_m}$。\n\n你的证明应从一个任意的PCP实例 $P$ 出发，显式地构造一个CFG $G_P$，并证明 $L(G_P) \\cap \\{A^n C^n G^n \\mid n \\ge 1\\} \\neq \\emptyset$ 当且仅当 $P$ 有解。由于PCP是不可判定的，这将证明ACG交集问题也是不可判定的。你必须以多项选择题的形式，提供关于ACG交集问题可判定性的最终结论。\n\n下列哪个陈述是正确的？\nA. ACG交集问题是可判定的。\nB. ACG交集问题是不可判定的。\nC. ACG交集问题是可判定的，当且仅当P=NP。\nD. ACG交集问题是非平凡的，但其可判定性是一个开放问题。",
            "solution": "**结论：** ACG交集问题是不可判定的。\n\n**证明概要：**\n该结论是通过从一个著名的不可判定问题——波斯特对应问题（PCP）——进行归约来证明的。\n\n对于任何一个PCP实例，都可以机械地构造出一个特定的上下文无关文法（CFG），我们称之为 $G_P$。这个构造过程非常精巧，其核心在于将PCP的匹配要求编码到 $G_P$ 的语言结构中。\n\n构造完成的 $G_P$ 具有以下关键属性：\n$$ L(G_P) \\cap \\{A^n C^n G^n \\mid n \\ge 1\\} \\neq \\emptyset \\quad \\Longleftrightarrow \\quad \\text{PCP 实例 } P \\text{ 有解} $$\n\n这个等价关系意味着，一个能够判断ACG交集是否非空的算法，可以直接用来判断任意PCP实例是否有解。由于PCP是不可判定的，这意味着这样的算法不可能存在。因此，ACG交集问题本身也是不可判定的。\n\n虽然完整的文法构造细节超出了本解答的范围，但它是形式语言理论中的一个标准结果，展示了不可判定性如何从一个问题域（PCP）传递到另一个问题域（CFL的属性）。\n\n因此，正确选项是B。",
            "answer": "$$\\boxed{B}$$"
        }
    ]
}