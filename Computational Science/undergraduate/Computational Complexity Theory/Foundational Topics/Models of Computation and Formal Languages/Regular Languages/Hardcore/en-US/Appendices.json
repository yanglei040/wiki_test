{
    "hands_on_practices": [
        {
            "introduction": "Building a theoretical machine from a mathematical rule is a cornerstone of computer science. This first exercise challenges you to translate a concept from number theory—divisibility—into the language of a Deterministic Finite Automaton (DFA). You will discover how the finite states of a DFA can serve as a memory to track the remainder of a binary number as it's being read, providing a tangible link between abstract machines and concrete computation .",
            "id": "1444116",
            "problem": "In the theory of computation, a language is a set of strings over a given alphabet. Consider the alphabet $\\Sigma = \\{0, 1\\}$. We can interpret any non-empty binary string $w = b_k b_{k-1} \\dots b_1 b_0$ (where each $b_i \\in \\{0, 1\\}$) as a positive integer $N(w)$ using the standard base-2 representation:\n$$N(w) = \\sum_{i=0}^{k} b_i \\cdot 2^i$$\nFor example, the string \"101\" represents the number $1\\cdot2^2 + 0\\cdot2^1 + 1\\cdot2^0 = 4 + 0 + 1 = 5$.\n\nLet $L$ be the language consisting of all non-empty binary strings $w$ such that the integer $N(w)$ they represent satisfies the condition $N(w) \\equiv 2 \\pmod{3}$. For instance, the string \"10\" is in $L$ because it represents the number 2, and $2 \\equiv 2 \\pmod{3}$. The string \"101\" is also in $L$ because it represents the number 5, and $5 \\equiv 2 \\pmod{3}$. The string \"11\" is not in $L$ because it represents 3, and $3 \\equiv 0 \\pmod{3}$. The empty string is not in $L$.\n\nWhat is the minimum number of states required for a Deterministic Finite Automaton (DFA) that accepts the language $L$?",
            "solution": "To solve this problem, we need to find the number of states in the minimal Deterministic Finite Automaton (DFA) for the language $L$. The language $L$ consists of binary strings $w$ representing a number $N(w)$ such that $N(w) \\equiv 2 \\pmod{3}$.\n\nA DFA processes a string from left to right. To determine if a string is in $L$, the DFA must effectively calculate the value of the number represented by the string modulo 3. The states of our DFA can represent the running value of the number modulo 3. Since there are three possible remainders when dividing by 3 (0, 1, and 2), we can design a DFA with three states, let's call them $q_0, q_1, q_2$. State $q_i$ will correspond to the set of strings processed so far that represent a number congruent to $i \\pmod{3}$.\n\nLet's define the components of the DFA:\nStates $Q = \\{q_0, q_1, q_2\\}$.\nAlphabet $\\Sigma = \\{0, 1\\}$.\nStart-State: The process begins before any characters are read. This corresponds to the empty string, which we can consider as representing the number 0. Since $0 \\equiv 0 \\pmod{3}$, the start state must be $q_0$.\n\nTransition Function $\\delta$: Let's analyze how the value of the number (modulo 3) changes as we append a bit. Suppose we have already processed a string $w$ which represents the number $N(w)$, and the DFA is in state $q_i$, meaning $N(w) \\equiv i \\pmod{3}$.\nIf we read a '0', the new string is $w0$. Its value is $N(w0) = 2 \\cdot N(w) + 0$. Modulo 3, this is $N(w0) \\equiv 2 \\cdot N(w) \\pmod{3}$. If $N(w) \\equiv i \\pmod{3}$, then $N(w0) \\equiv 2i \\pmod{3}$.\nIf we read a '1', the new string is $w1$. Its value is $N(w1) = 2 \\cdot N(w) + 1$. Modulo 3, this is $N(w1) \\equiv 2 \\cdot N(w) + 1 \\pmod{3}$. If $N(w) \\equiv i \\pmod{3}$, then $N(w1) \\equiv 2i + 1 \\pmod{3}$.\n\nUsing these rules, we can define the transitions:\n- State $q_0$ ($i=0$):\n  - On input '0': the new state is $q_{(2 \\cdot 0) \\pmod{3}} = q_0$. So, $\\delta(q_0, 0) = q_0$.\n  - On input '1': the new state is $q_{(2 \\cdot 0 + 1) \\pmod{3}} = q_1$. So, $\\delta(q_0, 1) = q_1$.\n- State $q_1$ ($i=1$):\n  - On input '0': the new state is $q_{(2 \\cdot 1) \\pmod{3}} = q_2$. So, $\\delta(q_1, 0) = q_2$.\n  - On input '1': the new state is $q_{(2 \\cdot 1 + 1) \\pmod{3}} = q_0$. So, $\\delta(q_1, 1) = q_0$.\n- State $q_2$ ($i=2$):\n  - On input '0': the new state is $q_{(2 \\cdot 2) \\pmod{3}} = q_{4 \\pmod{3}} = q_1$. So, $\\delta(q_2, 0) = q_1$.\n  - On input '1': the new state is $q_{(2 \\cdot 2 + 1) \\pmod{3}} = q_{5 \\pmod{3}} = q_2$. So, $\\delta(q_2, 1) = q_2$.\n\nAccepting States $F$: The language $L$ accepts strings $w$ where $N(w) \\equiv 2 \\pmod{3}$. Therefore, the only accepting state is $q_2$. So, $F = \\{q_2\\}$.\n\nThe problem statement specifies that the empty string is not in $L$. Our start state is $q_0$, which is not an accepting state. Thus, the empty string is rejected, which is correct.\n\nWe have constructed a 3-state DFA. Now we must confirm that it is minimal. A DFA is minimal if all its states are reachable from the start state and all pairs of states are distinguishable.\n\n1.  Reachability:\n    - $q_0$ is the start state, so it's reachable.\n    - $q_1$ is reachable from $q_0$ on input \"1\".\n    - $q_2$ is reachable from $q_0$ on input \"10\" ($\\delta(q_0, 1) = q_1$, $\\delta(q_1, 0) = q_2$).\n    All three states are reachable.\n\n2.  Distinguishability: Two states are distinguishable if there is a string that leads one to an accepting state and the other to a non-accepting state.\n    - $q_0$ and $q_2$: $q_2$ is an accepting state while $q_0$ is not. They are distinguishable by the empty string.\n    - $q_1$ and $q_2$: $q_2$ is an accepting state while $q_1$ is not. They are distinguishable by the empty string.\n    - $q_0$ and $q_1$: From $q_0$, the input \"0\" leads to $q_0$ (non-accepting). From $q_1$, the input \"0\" leads to $q_2$ (accepting). Thus, $q_0$ and $q_1$ are distinguishable.\n\nSince all three states are reachable and pairwise distinguishable, the DFA we constructed is minimal. The minimal number of states required is 3.\nThis result is also predicted by the Myhill-Nerode theorem, which states that the number of states in a minimal DFA for a language is equal to the number of equivalence classes of the Nerode relation. For this language, the equivalence classes correspond to the three possible remainders modulo 3.",
            "answer": "$$\\boxed{3}$$"
        },
        {
            "introduction": "While DFAs are powerful, they have fundamental limitations. This practice introduces the Pumping Lemma, a critical tool for proving that a language is *not* regular. By working through the classic example of a language based on prime numbers, you will learn how to construct a formal proof by contradiction and gain intuition for why languages requiring \"unbounded memory\" cannot be recognized by finite state machines .",
            "id": "1444112",
            "problem": "An analyst is studying a communication protocol where valid signals are strings over a single-character alphabet, $\\Sigma = \\{s\\}$. The language of valid signals, denoted by $L$, is defined as the set of all strings $s^k$ where the length $k$ is a prime number. Formally, $L = \\{ s^k \\mid k \\text{ is a prime number} \\}$.\n\nThe analyst hypothesizes that $L$ is not a regular language. To demonstrate this, they decide to use the Pumping Lemma for regular languages. The lemma states that for any regular language, there exists a pumping length $p$ such that any string $w \\in L$ with $|w| \\ge p$ can be decomposed into three parts, $w=xyz$, satisfying three conditions:\n1. $|y| \\ge 1$\n2. $|xy| \\le p$\n3. For all non-negative integers $i$, the string $xy^iz$ is also in $L$.\n\nThe analyst assumes, for the sake of contradiction, that $L$ is regular and has a pumping length of $p=8$. They select the string $w = s^{13}$, which is in $L$ since 13 is a prime number and its length, 13, is greater than the assumed pumping length $p=8$. Based on the Pumping Lemma, $w$ can be decomposed as $xyz$ where $|xy| \\le 8$ and $|y| \\ge 1$. Let the length of the substring $y$ be denoted by $j$.\n\nWhich of the following choices for the pumping integer $i$ guarantees that the resulting string $xy^iz$ is *not* in the language $L$, for *any* possible valid decomposition of $w$ (i.e., for any integer $j$ such that $1 \\le j \\le 8$)?\n\nA. $i=0$\n\nB. $i=2$\n\nC. $i=12$\n\nD. $i=13$\n\nE. $i=14$",
            "solution": "Assume for contradiction that $L$ is regular with pumping length $p=8$. Choose $w=s^{13}\\in L$ with $|w|=13\\ge 8$. By the Pumping Lemma, $w$ can be decomposed as $w=xyz$ with $|y|\\ge 1$ and $|xy|\\le 8$. Over the unary alphabet, write\n$$\nx=s^{a},\\quad y=s^{j},\\quad z=s^{13-a-j},\n$$\nwhere $a\\ge 0$, $j\\ge 1$, and $a+j\\le 8$. For any pumping exponent $i\\ge 0$, the pumped string $xy^{i}z$ has length\n$$\n|xy^{i}z|=|x|+i|y|+|z|=a+ij+(13-a-j)=13+(i-1)j.\n$$\nA pumped string $xy^{i}z$ is in $L$ if and only if $13+(i-1)j$ is prime. We need an $i$ such that for every valid decomposition (equivalently, for every $j$ with $1\\le j\\le 8$, since choosing $a=8-j$ ensures $|xy|\\le 8$), the number $13+(i-1)j$ is not prime.\n\nCheck each option:\n- $i=0$: $13+(0-1)j=13-j$. For $j=2,6,8$, we get $11,7,5$, which are prime. Not guaranteed.\n- $i=2$: $13+(2-1)j=13+j$. For $j=4,6$, we get $17,19$, which are prime. Not guaranteed.\n- $i=12$: $13+(12-1)j=13+11j$. For $j=6,8$, we get $79,101$, which are prime. Not guaranteed.\n- $i=13$: $13+(13-1)j=13+12j$. For $j=2,4,5,7,8$, we get $37,61,73,97,109$, which are prime. Not guaranteed.\n- $i=14$: $13+(14-1)j=13+13j=13(1+j)$. For all $j\\ge 1$, this is a multiple of $13$ greater than $13$, hence composite, so $xy^{14}z\\notin L$ for every valid decomposition.\n\nTherefore, the choice $i=14$ guarantees $xy^{i}z\\notin L$ for any valid decomposition.",
            "answer": "$$\\boxed{E}$$"
        },
        {
            "introduction": "This final practice moves from analyzing individual languages to building algorithms that reason about them. Using a practical scenario from software verification, you will learn how to combine the closure properties of regular languages—specifically complement and intersection—to solve the language inclusion problem ($L_1 \\subseteq L_2$). This exercise demonstrates how theoretical constructs provide a powerful and decidable framework for answering complex questions about computational systems .",
            "id": "1444096",
            "problem": "A software engineering team at a cybersecurity firm is tasked with verifying the behavior of a new, highly-optimized firewall module. The firewall's rules for identifying malicious network packets are modeled by a Deterministic Finite Automaton (DFA). Let $\\Sigma$ be the alphabet of all possible bytes in a packet header.\n\nThe company has a trusted, legacy firewall whose behavior is well-understood. The set of all packet headers it correctly identifies as malicious is a regular language $L(M_{legacy})$, where $M_{legacy}$ is a DFA. The new, optimized firewall implements a different set of rules, represented by another DFA, $M_{new}$, which accepts the language $L(M_{new})$.\n\nA critical requirement for deployment is \"no false negatives.\" That is, any packet header identified as malicious by the new firewall must also be identified as malicious by the trusted legacy firewall. Formally, this requires that the language accepted by the new firewall is a subset of the language accepted by the legacy firewall, i.e., $L(M_{new}) \\subseteq L(M_{legacy})$.\n\nYour task is to identify the correct algorithmic procedure to decide if this inclusion property holds for any two given DFAs, $M_{new}$ and $M_{legacy}$. The procedure must be composed of standard, decidable operations on finite automata.\n\nWhich of the following describes a correct and complete algorithm to decide if $L(M_{new}) \\subseteq L(M_{legacy})$?\n\nA. Construct a DFA $M_{A}$ for the language $\\overline{L(M_{legacy})} \\cap L(M_{new})$. Then, check if $L(M_{A})$ is empty. The inclusion holds if and only if $L(M_{A})$ is empty.\n\nB. Construct a DFA $M_{B}$ for the language $L(M_{legacy}) \\cap L(M_{new})$. Then, check if $L(M_{B})$ is empty. The inclusion holds if and only if $L(M_{B})$ is empty.\n\nC. For every string $w$ in the infinite set $L(M_{new})$, simulate both DFAs to check if $w$ is also in $L(M_{legacy})$. The inclusion holds if this is true for all such strings $w$.\n\nD. Construct a DFA $M_{D}$ for the language $\\overline{L(M_{new})} \\cap L(M_{legacy})$. Then, check if $L(M_{D})$ is empty. The inclusion holds if and only if $L(M_{D})$ is empty.\n\nE. Construct a DFA $M_{E}$ for the language $L(M_{legacy}) \\cup L(M_{new})$. Then, check if this new automaton is equivalent to $M_{new}$ by comparing their state diagrams. The inclusion holds if and only if they are equivalent.",
            "solution": "We must decide whether $L(M_{new}) \\subseteq L(M_{legacy})$. By a standard set-theoretic equivalence, for any languages $A$ and $B$ over the same alphabet,\n$$\nA \\subseteq B \\iff A \\cap \\overline{B} = \\varnothing.\n$$\nApplying this with $A = L(M_{new})$ and $B = L(M_{legacy})$, we obtain\n$$\nL(M_{new}) \\subseteq L(M_{legacy}) \\iff L(M_{new}) \\cap \\overline{L(M_{legacy})} = \\varnothing.\n$$\n\nDFAs are closed under complement and intersection, and the corresponding constructions are effective:\n- Complement: Given a complete DFA $M_{legacy} = (Q_{\\ell}, \\Sigma, \\delta_{\\ell}, q_{0,\\ell}, F_{\\ell})$, its complement DFA is $M_{\\ell}^{c} = (Q_{\\ell}, \\Sigma, \\delta_{\\ell}, q_{0,\\ell}, Q_{\\ell} \\setminus F_{\\ell})$, which recognizes $\\Sigma^{*} \\setminus L(M_{legacy})$. If $M_{legacy}$ is not complete, first add a sink state to make it total.\n- Intersection: Given $M_{new} = (Q_{n}, \\Sigma, \\delta_{n}, q_{0,n}, F_{n})$ and $M_{\\ell}^{c}$ as above, construct the product DFA\n$$\nM_{A} = \\left(Q_{n} \\times Q_{\\ell}, \\Sigma, \\delta, (q_{0,n}, q_{0,\\ell}), F_{n} \\times (Q_{\\ell} \\setminus F_{\\ell})\\right),\n$$\nwhere $\\delta\\left((q_{n}, q_{\\ell}), a\\right) = \\left(\\delta_{n}(q_{n}, a), \\delta_{\\ell}(q_{\\ell}, a)\\right)$ for all $a \\in \\Sigma$. Then $L(M_{A}) = L(M_{new}) \\cap \\overline{L(M_{legacy})}$.\n\nEmptiness of a DFA language is decidable: $L(M)$ is empty if and only if no accepting state is reachable from the start state. This is checked by a graph reachability search on the finite transition graph of $M$.\n\nTherefore, the algorithm is:\n1. Construct $M_{\\ell}^{c}$, the complement of $M_{legacy}$.\n2. Construct the product DFA $M_{A}$ recognizing $L(M_{new}) \\cap \\overline{L(M_{legacy})}$.\n3. Decide if $L(M_{A})$ is empty via reachability. If empty, inclusion holds; otherwise, a reachable accepting state (and corresponding word) is a counterexample to inclusion.\n\nThis procedure exactly matches option A. The other options are incorrect for the following reasons:\n- B checks $L(M_{legacy}) \\cap L(M_{new})$ for emptiness, which tests disjointness, not inclusion.\n- C requires checking all strings in an infinite set and does not yield a general decision procedure that halts in all cases.\n- D checks emptiness of $\\overline{L(M_{new})} \\cap L(M_{legacy})$, which is equivalent to $L(M_{legacy}) \\subseteq L(M_{new})$, the reverse inclusion.\n- E tests whether $L(M_{legacy}) \\cup L(M_{new}) = L(M_{new})$, which is also equivalent to $L(M_{legacy}) \\subseteq L(M_{new})$, the reverse inclusion, and “comparing state diagrams” is not, in general, a correct equivalence test without a formal method such as product construction or minimization and is unnecessary here.",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}