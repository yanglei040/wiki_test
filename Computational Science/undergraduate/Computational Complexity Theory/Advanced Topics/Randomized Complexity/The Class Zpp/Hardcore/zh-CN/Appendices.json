{
    "hands_on_practices": [
        {
            "introduction": "ZPP 中的“P”代表“多项式时间”，但这指的是*期望*运行时间，而非最坏情况下的运行时间。本练习提供了一个具体的计算模型，通过将单次尝试的成功概率与每次尝试的运行时间相结合，来计算这一期望时间，从而理解算法如何实现期望多项式时间。",
            "id": "1455251",
            "problem": "复杂度类 ZPP（零错误概率多项式时间）包含的是这样一类判定问题：它们可由一个概率算法解决，该算法总是返回正确答案，并且其期望运行时间是输入规模的多项式。这类算法也被称为拉斯维加斯算法。\n\n考虑一个随机算法 `Searcher`，它被设计用于解决一个输入规模为 $n$ 的特定判定问题。该算法具有以下特点：\n1.  该算法从不产生错误答案。它要么返回正确的“是”或“否”的解，要么报告“失败”。\n2.  `Searcher` 的单次运行，无论成功与否，都在 $T(n) = c n^{\\alpha}$ 的时间内完成，其中 $c$ 和 $\\alpha$ 是给定的正实数常数。\n3.  对于一个规模为 $n$ 的给定输入，`Searcher` 单次运行成功的概率（即返回“是”或“否”）为 $p(n) = n^{-\\beta}$，其中 $\\beta$ 是一个给定的正实数常数。\n\n为了保证得到一个解，我们构建一个新的主算法 `MasterSolver`，它在同一个输入上重复执行 `Searcher`，直到获得一个“是”或“否”的答案。请确定 `MasterSolver` 的期望总运行时间，将其表示为参数 $c$、$\\alpha$、$\\beta$ 和输入规模 $n$ 的函数。请用一个单一的闭式解析表达式来表示你的答案。",
            "solution": "设 $p(n)=n^{-\\beta}$ 表示 `Searcher` 在输入规模为 $n$ 时单次独立运行的成功概率，设 $T(n)=c n^{\\alpha}$ 表示每次运行的确定性时间。当 `MasterSolver` 重复 `Searcher` 时，设 $K$ 为首次成功所需的运行次数。\n\n由于每次运行以概率 $p(n)$ 成功，且失败会导致重复，因此 $K$ 服从参数为 $p(n)$ 的几何分布：\n$$\n\\Pr(K=k)=(1-p(n))^{k-1}p(n), \\quad k\\in\\{1,2,\\ldots\\}.\n$$\n参数为 $p(n)$ 的几何随机变量的期望是\n$$\n\\mathbb{E}[K]=\\sum_{k=1}^{\\infty}k(1-p(n))^{k-1}p(n)=\\frac{1}{p(n)}.\n$$\n总运行时间为 $S=K\\,T(n)$，因为 $K$ 次运行中的每一次都确定性地消耗时间 $T(n)$。因此\n$$\n\\mathbb{E}[S]=\\mathbb{E}[K\\,T(n)]=T(n)\\,\\mathbb{E}[K]=c n^{\\alpha}\\cdot\\frac{1}{p(n)}.\n$$\n代入 $p(n)=n^{-\\beta}$ 得\n$$\n\\mathbb{E}[S]=c n^{\\alpha}\\cdot n^{\\beta}=c\\,n^{\\alpha+\\beta}.\n$$\n因此，`MasterSolver` 的期望总运行时间为 $c\\,n^{\\alpha+\\beta}$。",
            "answer": "$$\\boxed{c\\,n^{\\alpha+\\beta}}$$"
        },
        {
            "introduction": "ZPP 算法最关键的特性是其可靠性——它从不给出错误答案。本练习展示了一种常见的概率算法（具有单边错误），并要求你解释为什么尽管它具有概率性，却不满足 ZPP 严格的“零错误”标准。",
            "id": "1455254",
            "problem": "一位系统工程师开发了一种新的概率算法 `NetCheck`，用于确定一个计算机网络是否完全连通。网络被表示为一个图，其中计算机是顶点，直接链路是边。`NetCheck` 相对于网络中的顶点数量，其运行时间是多项式的。该算法经过了广泛测试，得到以下一致的结果：\n\n1.  如果输入的网络图是连通的，`NetCheck` 总是输出“CONNECTED”。\n2.  如果输入的网络图是不连通的，`NetCheck` 以 $1/3$ 的概率输出“CONNECTED”，以 $2/3$ 的概率输出“DISCONNECTED”。\n\n复杂度类零错误概率多项式时间 (ZPP) 是为判定问题定义的。如果存在一个概率算法，它允许以至多 $1/2$ 的概率返回“FAIL”回答（即“我不知道”），但在返回“YES”或“NO”回答时必须总是正确的，那么一个问题就属于 ZPP。此外，一个 ZPP 算法的期望运行时间必须是输入大小的多项式。\n\n根据 `NetCheck` 的行为和 ZPP 算法的定义，以下哪个陈述最准确地解释了为什么由 `NetCheck` 算法判定的网络连通性问题不属于 ZPP 类？\n\nA. 该算法对于不连通网络的错误概率（$1/3$）不小于或等于一个任意小的常数。\n\nB. 该算法只表现出单边错误，而一个 ZPP 算法必须能够在“YES”和“NO”两种实例上都可能出错。\n\nC. 该算法可能产生不正确的“YES”或“NO”回答，这对于 ZPP 算法是禁止的。\n\nD. 该算法的运行时间只是平均情况下是多项式的，而不是最坏情况。\n\nE. 该算法从不返回“FAIL”回答，而这是任何非确定性 ZPP 算法所要求的可能输出之一。",
            "solution": "我们将该判定问题形式化为语言成员资格问题：设 $L$ 是连通图的集合，其中对于 $x \\in L$，正确的输出是“YES”，对于 $x \\notin L$，正确的输出是“NO”。\n\n根据规定，概率算法 NetCheck 满足：\n- 对于所有 $x \\in L$（连通图），它以概率 $1$ 输出 YES，以概率 $0$ 输出 NO。\n- 对于所有 $x \\notin L$（不连通图），它以概率 $\\frac{1}{3}$ 输出 YES，以概率 $\\frac{2}{3}$ 输出 NO。\n\n一个用于判定问题的 ZPP 算法必须满足零错误属性：它可以输出一个特殊符号（称之为 FAIL），但每当它输出 YES 或 NO 时，该回答必须是正确的。形式上，设 $A$ 是一个 ZPP 算法，对于每个输入 $x$，我们有：\n- $\\Pr[A(x) = \\text{FAIL}] \\leq \\frac{1}{2}$，\n- 当且仅当 $x \\in L$ 时，$\\Pr[A(x) = \\text{YES} \\mid A(x) \\neq \\text{FAIL}] = 1$，\n- 当且仅当 $x \\notin L$ 时，$\\Pr[A(x) = \\text{NO} \\mid A(x) \\neq \\text{FAIL}] = 1$，\n并且期望运行时间是输入大小的多项式。\n\nNetCheck 违反了零错误要求，因为存在 $x \\notin L$，使得它以正概率 $\\frac{1}{3}$ 输出 YES。也就是说，NetCheck 会在 NO 实例上产生不正确的 YES。因此，无论其运行时间如何，NetCheck 都不是一个 ZPP 算法。\n\n我们现在评估这些选项：\n- A 是不正确的，因为 ZPP 要求在 YES/NO 输出上零错误，而不仅仅是一个小的错误概率；此外，通过重复来减少错误与 ZPP 的零错误标准无关。\n- B 是不正确的，因为 ZPP 不要求双边错误；它要求在确定性回答上零错误。\n- C 是正确的：NetCheck 可以输出一个不正确的 YES（并且从不输出 FAIL），这对于 ZPP 算法是禁止的。\n- D 是不正确的，因为 ZPP 要求期望多项式时间，而不是最坏情况多项式时间；NetCheck 的时间限制在这里不是问题。\n- E 是不正确的，因为 ZPP 算法被允许返回 FAIL，但不是必须的；只要没有错误，缺少 FAIL 并不排除 ZPP，而 NetCheck 并非没有错误。\n\n因此，最准确的原因是 NetCheck 可能产生不正确的 YES 或 NO 回答，这违反了 ZPP 的零错误要求。",
            "answer": "$$\\boxed{C}$$"
        },
        {
            "introduction": "在理解了 ZPP 的定义和核心属性之后，下一步是建设性地使用它们。本练习要求你利用现有的 ZPP 算法作为组件，为连接语言 (language concatenation) 这一组合问题设计一个新的 ZPP 算法，这展示了该复杂度类的一个关键闭包性质。",
            "id": "1455255",
            "problem": "在计算复杂性理论中，ZPP类（代表零错误概率多项式时间）表示那些可以通过一种概率算法解决的问题，该算法总是正确的，并且在期望多项式时间内运行。用于判定问题的ZPP算法可以输出“是”、“否”或“未知”（通常表示为“?”）。它具有两个关键特性：\n1.  它从不返回不正确的答案（即，如果真实答案是“是”，它从不输出“否”，反之亦然）。\n2.  对于任何给定的输入，它返回“未知”的概率最多为 $1/2$。\n\n考虑在同一字母表上的两种语言 $L_1$ 和 $L_2$。您拥有两个ZPP算法 $A_1$ 和 $A_2$，它们分别判定 $L_1$ 和 $L_2$ 的成员资格。对于长度为 $k$ 的输入，$A_1$ 的期望运行时间由 $T_1(k) = C_1 k^{a_1}$ 给出，$A_2$ 的期望运行时间由 $T_2(k) = C_2 k^{a_2}$ 给出。这里，$C_1, C_2, a_1,$ 和 $a_2$ 是给定的正常数。\n\n您的任务是设计一个新的ZPP算法 $A_{cat}$，用于判定连接语言 $L_{cat} = L_1 L_2 = \\{uv \\mid u \\in L_1 \\text{ and } v \\in L_2\\}$ 的成员资格。确定您的算法 $A_{cat}$ 在处理长度为 $n$ 的输入字符串时，其最坏情况下期望运行时间的最紧多项式上界。为了简化最终推导，您可以将任何形式为 $\\sum_{i=0}^{n} g(i)$ 的和近似为积分 $\\int_0^n g(x) dx$。用 $n, C_1, C_2, a_1$ 和 $a_2$ 将您的答案表示为符号表达式。",
            "solution": "给定用于 $L_1$ 和 $L_2$ 的 ZPP 算法 $A_1$ 和 $A_2$，其期望运行时间分别为 $T_1(k)=C_1 k^{a_1}$ 和 $T_2(k)=C_2 k^{a_2}$。这些算法总是返回正确的答案（“是”或“否”），其运行时间的期望值是多项式的。\n\n按如下方式设计 $A_{cat}$。对于长度为 $n$ 的输入 $x$，算法将遍历所有可能的分割点 $i \\in \\{0, 1, \\dots, n\\}$，将 $x$ 分割为前缀 $u = x[1..i]$ 和后缀 $v = x[i+1..n]$。对于每个分割 $i$：\n- 在 $u$ 上运行 $A_1$。\n- 在 $v$ 上运行 $A_2$。\n- 如果 $A_1$ 对 $u$ 返回“是” 并且 $A_2$ 对 $v$ 返回“是”，那么算法 $A_{cat}$ 返回“是”并终止。\n\n如果遍历完所有 $n+1$ 个分割点都没有找到这样一对 $(u, v)$，则算法 $A_{cat}$ 返回“否”。\n\n该算法是零错误的，因为 $A_1$ 和 $A_2$ 都是零错误的，并且我们只在两个子问题都明确为“是”时才接受。\n\n我们现在来界定最坏情况下的期望运行时间。最坏情况发生在输入 $x$ 不属于 $L_{cat}$ 时，因为此时算法必须检查所有 $n+1$ 个分割点。对于一个固定的分割 $i$，运行 $A_1$ 的期望时间是 $T_1(i) = C_1 i^{a_1}$，运行 $A_2$ 的期望时间是 $T_2(n-i) = C_2 (n-i)^{a_2}$。由于期望的线性性，检查一个分割的总期望时间是两者的和。\n\n对所有 $i \\in \\{0, 1, \\dots, n\\}$ 求和，得到 $A_{cat}$ 的总期望运行时间 $T_{cat}(n)$：\n$$\n\\mathbb{E}[T_{cat}(n)] = \\sum_{i=0}^{n} (\\mathbb{E}[\\text{Time for } A_1(i)] + \\mathbb{E}[\\text{Time for } A_2(n-i)]) = \\sum_{i=0}^{n} (C_1 i^{a_1} + C_2 (n-i)^{a_2})\n$$\n$$\n\\mathbb{E}[T_{cat}(n)] = C_1 \\sum_{i=0}^{n} i^{a_1} + C_2 \\sum_{i=0}^{n} (n-i)^{a_2}\n$$\n为了得到最紧的多项式上界，并根据允许的近似方法，我们用相应的积分来近似每个和。令 $j=n-i$，第二个和变为 $C_2 \\sum_{j=0}^{n} j^{a_2}$。\n$$\n\\sum_{i=0}^{n} i^{a} \\approx \\int_{0}^{n} x^{a}\\,dx = \\frac{n^{a+1}}{a+1}\n$$\n将此应用于两个和，得出：\n$$\n\\mathbb{E}[T_{cat}(n)] \\approx \\frac{C_1}{a_1+1} n^{a_1+1} + \\frac{C_2}{a_2+1} n^{a_2+1}\n$$\n因此，$A_{cat}$ 的最坏情况期望运行时间的最紧多项式上界（忽略低阶项）是这两个主导项的和。",
            "answer": "$$\\boxed{\\frac{C_{1}}{a_{1}+1}\\,n^{a_{1}+1}+\\frac{C_{2}}{a_{2}+1}\\,n^{a_{2}+1}}$$"
        }
    ]
}