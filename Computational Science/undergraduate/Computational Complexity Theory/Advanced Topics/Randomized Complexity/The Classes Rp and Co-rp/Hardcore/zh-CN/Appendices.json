{
    "hands_on_practices": [
        {
            "introduction": "在计算复杂性理论中，理解复杂性类在标准语言运算（如并集、交集和连接）下的行为至关重要。这个练习将探讨随机多项式时间（RP）类的一个基本闭包性质。通过构建一个新的概率算法来判定两种语言的并集，你将亲身体验如何组合现有的随机算法，并验证其是否仍然满足 RP 类的严格定义，特别是单侧错误的要求 。",
            "id": "1455470",
            "problem": "在计算复杂性理论领域，复杂性类 RP（代表随机多项式时间，Randomized Polynomial Time）刻画了可由具有单边错误的概率图灵机解决的判定问题。如果存在一个概率多项式时间图灵机 $M$，使得对于任何输入字符串 $x$，满足以下条件，那么语言 $L$ 就属于 RP：\n1. 如果 $x$ 属于语言 $L$，则 $M$ 输出 1 (接受) 的概率至少为 $1/2$。（$x \\in L \\implies P(M(x) = 1) \\ge 1/2$）\n2. 如果 $x$ 不属于语言 $L$，则 $M$ 输出 1 (接受) 的概率恰好为 0。（$x \\notin L \\implies P(M(x) = 1) = 0$）\n\n考虑一家设计微芯片的公司。他们开发了两种独立的概率性测试算法 $A_1$ 和 $A_2$，用于检测不同类型的制造缺陷。设 $L_1$ 是所有具有“类型1”缺陷的芯片集合，$L_2$ 是所有具有“类型2”缺陷的芯片集合。这两种测试算法都对应于 RP 机，这意味着语言 $L_1$ 和 $L_2$ 都属于复杂性类 RP。\n\n如果一个芯片有类型1缺陷，或类型2缺陷，或两者兼有，则被认为是“全局性缺陷”。设 $L_{union}$ 是所有全局性缺陷芯片的语言，因此 $L_{union} = L_1 \\cup L_2$。\n\n为了创建一个统一的测试，一位工程师提出了一个新算法 $A_{union}$。在接收到一个用于测试的芯片 $x$ 时，$A_{union}$ 的操作如下：\n- 首先，对 $x$ 运行算法 $A_1$。\n- 如果 $A_1$ 输出 1，则 $A_{union}$ 立即输出 1 并停止。\n- 如果 $A_1$ 输出 0，则 $A_{union}$ 继续对 $x$ 运行算法 $A_2$，并输出 $A_2$ 的结果。\n\n基于这种构造，以下关于语言 $L_{union}$ 的陈述中，哪一个是永远正确的？\n\nA. $L_{union}$ 保证属于 RP。\n\nB. $L_{union}$ 不保证属于 RP，但保证属于 co-RP。\n\nC. $L_{union}$ 的分类取决于 $L_1$ 和 $L_2$ 的具体属性；它不保证属于 RP。\n\nD. $L_{union}$ 保证属于 P（多项式时间）。\n\nE. $L_{union}$ 保证属于 BPP（有界错误概率多项式时间），但不一定属于 RP。",
            "solution": "我们已知两个语言 $L_{1},L_{2}$ 属于 RP。根据定义，存在概率多项式时间算法 $A_{1},A_{2}$，使得对于所有输入 $x$：\n- 如果 $x \\in L_{i}$，则 $\\Pr(A_{i}(x)=1) \\ge \\frac{1}{2}$。\n- 如果 $x \\notin L_{i}$，则 $\\Pr(A_{i}(x)=1)=0$。\n提出的统一算法 $A_{\\text{union}}$ 首先运行 $A_{1}$，如果 $A_{1}$ 接受则立即接受；否则运行 $A_{2}$ 并输出其结果。我们根据 RP 的定义来分析其运行时间和正确性。\n\n多项式时间：设对于长度为 $n$ 的输入，运行时间分别为 $T_{1}(n)$ 和 $T_{2}(n)$，两者都是多项式的。那么运行时间 $T_{\\text{union}}(n)$ 满足\n$$\nT_{\\text{union}}(n) \\le T_{1}(n) + T_{2}(n),\n$$\n这是多项式的；因此 $A_{\\text{union}}$ 在概率多项式时间内运行。\n\n单边错误（对于否定实例的可靠性）：如果 $x \\notin L_{1} \\cup L_{2}$，那么 $x \\notin L_{1}$ 并且 $x \\notin L_{2}$，所以\n$$\n\\Pr(A_{1}(x)=1)=0 \\quad \\text{and} \\quad \\Pr(A_{2}(x)=1)=0.\n$$\n因此 $A_{\\text{union}}$ 接受的概率为\n$$\n\\Pr(A_{\\text{union}}(x)=1) = 0 + \\Pr(A_{1}(x)=0)\\cdot 0 = 0,\n$$\n所以没有假阳性。\n\n对于肯定实例的接受概率：如果 $x \\in L_{1} \\cup L_{2}$，我们分情况讨论。\n- 如果 $x \\in L_{1} \\setminus L_{2}$，那么 $\\Pr(A_{1}(x)=1) \\ge \\frac{1}{2}$，所以 $A_{\\text{union}}$ 以至少 $\\frac{1}{2}$ 的概率接受，无需运行 $A_{2}$。\n- 如果 $x \\in L_{2} \\setminus L_{1}$，那么 $\\Pr(A_{1}(x)=1)=0$（因为 $x \\notin L_{1}$），因此 $A_{\\text{union}}$ 运行 $A_{2}$ 并以概率\n$$\n\\Pr(A_{\\text{union}}(x)=1)=\\Pr(A_{2}(x)=1)\\ge \\frac{1}{2}\n$$\n接受。\n- 如果 $x \\in L_{1} \\cap L_{2}$，那么 $\\Pr(A_{1}(x)=1) \\ge \\frac{1}{2}$，所以 $A_{\\text{union}}$ 以至少 $\\frac{1}{2}$ 的概率接受。\n\n在所有 $x \\in L_{1} \\cup L_{2}$ 的情况下，我们都有 $\\Pr(A_{\\text{union}}(x)=1) \\ge \\frac{1}{2}$。结合对否定实例的零接受概率和多项式时间，这满足了 RP 的定义。因此 $L_{\\text{union}} \\in \\text{RP}$，并且陈述 A 永远是正确的。其他选项作为一般性保证是不必要的或错误的。\n\n因此，正确选项是 A。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "RP 类的标准定义要求“是”实例的接受概率至少为 $1/2$。这个常数看起来是任意的，那么它是否是该类定义的核心所在呢？这个练习通过引入一个接受概率仅为多项式倒数（即 $1/p(n)$）的“弱”RP 类来挑战这一观念。通过证明这个看似更弱的类实际上等同于 RP，你将掌握随机算法中一个极其强大的技术：概率放大（probability amplification）。",
            "id": "1455479",
            "problem": "在计算复杂性理论中，一个语言（language）是某个字母表（alphabet）上的一组字符串。复杂性类 RP（随机多项式时间）是使用概率多项式时间图灵机（Probabilistic Polynomial-Time Machine, PPTM）定义的。如果存在一个 PPTM（我们称之为 $M$），其运行时间是输入长度 $|x|$ 的多项式，并且满足以下两个条件，那么我们就说语言 $L$ 属于 RP：\n1. 对于语言 $L$ 中的任意字符串 $x$（即 $x \\in L$），机器 $M$ 接受的概率至少为 $1/2$。用符号表示为 $\\Pr[M(x) \\text{ 接受}] \\ge 1/2$。\n2. 对于不在语言 $L$ 中的任意字符串 $x$（即 $x \\notin L$），机器 $M$ 总是拒绝。用符号表示为 $\\Pr[M(x) \\text{ 接受}] = 0$。\n\n现在，考虑一个新的复杂性类，我们称之为 $\\text{WEAK-RP}$。如果存在一个 PPTM（我们称之为 $M'$）和一个多项式 $p(n)$，使得对于任何长度为 $n = |x|$ 的输入字符串 $x$ 满足以下条件，那么语言 $L$ 就属于 $\\text{WEAK-RP}$：\n1. 如果 $x \\in L$，那么 $\\Pr[M'(x) \\text{ 接受}] \\ge 1/p(n)$。\n2. 如果 $x \\notin L$，那么 $\\Pr[M'(x) \\text{ 接受}] = 0$。\n\n复杂性类 RP 和 $\\text{WEAK-RP}$ 之间是什么关系？\n\nA. $\\text{WEAK-RP}$ 是 RP 的真子集（即 $\\text{WEAK-RP} \\subset \\text{RP}$ 且 $\\text{WEAK-RP} \\neq \\text{RP}$）。\n\nB. $\\text{WEAK-RP}$ 是 RP 的真超集（即 $\\text{RP} \\subset \\text{WEAK-RP}$ 且 $\\text{RP} \\neq \\text{WEAK-RP}$）。\n\nC. $\\text{WEAK-RP}$ 等于 RP（即 $\\text{WEAK-RP} = \\text{RP}$）。\n\nD. $\\text{WEAK-RP}$ 和 RP 是不可比的（即两者都不是对方的子集）。\n\nE. $\\text{WEAK-RP}$ 中的每个语言都是不可判定的，而 RP 包含一些可判定的语言。",
            "solution": "我们首先重述其定义属性。RP 包含这样一些语言，对于这些语言，存在一个概率多项式时间图灵机，它对每个 $x \\in L$ 以至少 $1/2$ 的概率接受，且从不接受 $x \\notin L$。而 $\\text{WEAK-RP}$ 类将对 $x \\in L$ 的接受概率放宽到至少为 $1/p(n)$，其中 $p(n)$ 是某个多项式（仅依赖于输入长度 $n = |x|$），同时仍然要求对 $x \\notin L$ 的接受概率为零。\n\n步骤1（RP 包含于 WEAK-RP）：设 $L \\in \\text{RP}$，其见证机为 $M$，满足对于 $x \\in L$ 有 $\\Pr[M(x)\\text{ 接受}] \\ge 1/2$，对于 $x \\notin L$ 有 $0$。选择常数多项式 $p(n) = 2$。那么 $1/2 \\ge 1/p(n)$，所以 $M$ 也见证了 $L \\in \\text{WEAK-RP}$。因此 $\\text{RP} \\subseteq \\text{WEAK-RP}$。\n\n步骤2（通过放大证明 WEAK-RP 包含于 RP）：设 $L \\in \\text{WEAK-RP}$，其见证机为 $M'$，多项式为 $p(n)$，使得对于所有长度为 $n=|x|$ 的 $x$，\n- 如果 $x \\in L$，则 $\\Pr[M'(x)\\text{ 接受}] \\ge 1/p(n)$，\n- 如果 $x \\notin L$，则 $\\Pr[M'(x)\\text{ 接受}] = 0$。\n不失一般性，定义 $q(n) = \\max\\{1, \\lceil p(n) \\rceil\\}$，这样 $q(n)$ 就是一个整数多项式且 $q(n) \\ge 1$。那么对于 $x \\in L$，我们仍然有 $\\Pr[M'(x)\\text{ 接受}] \\ge 1/q(n)$，因为 $1/q(n) \\le 1/p(n)$。\n\n构建一个新的概率多项式时间图灵机 $M$，它在输入长度为 $n$ 的 $x$ 上，对 $x$ 执行 $k(n) = \\lceil q(n)\\ln 2 \\rceil$ 次独立的 $M'$ 运行，并且当且仅当至少有一次运行接受时，它才接受。每次运行使用独立的随机位，因此各次运行是独立的。\n\n- 如果 $x \\notin L$，则每次运行接受的概率为 $0$，所以 $M$ 接受的概率为 $0$。因此，单边错误条件得以保持。\n\n- 如果 $x \\in L$，设 $\\alpha(n) = \\Pr[M'(x)\\text{ 接受}]$，则 $\\alpha(n) \\ge 1/q(n)$。根据独立性，\n$$\n\\Pr[M(x)\\text{ 接受}] \\;=\\; 1 - \\Pr[\\text{所有 }k(n)\\text{ 次运行都拒绝}]\n\\;=\\; 1 - (1 - \\alpha(n))^{k(n)}.\n$$\n使用 $\\alpha(n) \\ge 1/q(n)$ 以及当 $t \\in [0,1]$ 时函数 $t \\mapsto (1-t)^{k}$ 的单调性，我们得到\n$$\n\\Pr[M(x)\\text{ 接受}] \\;\\ge\\; 1 - \\left(1 - \\frac{1}{q(n)}\\right)^{k(n)} \\;\\ge\\; 1 - \\left(1 - \\frac{1}{q(n)}\\right)^{q(n)\\ln 2}.\n$$\n为了给后一项定界，对 $z \\in (0,1)$ 使用不等式 $\\ln(1 - z) \\le -z$ 可得\n$$\n\\left(1 - \\frac{1}{q(n)}\\right)^{q(n)\\ln 2}\n= \\exp\\!\\left(q(n)\\ln 2 \\cdot \\ln\\!\\left(1 - \\frac{1}{q(n)}\\right)\\right)\n\\le \\exp\\!\\left(q(n)\\ln 2 \\cdot \\left(-\\frac{1}{q(n)}\\right)\\right)\n= \\exp(-\\ln 2) = \\frac{1}{2}.\n$$\n因此，\n$$\n\\Pr[M(x)\\text{ 接受}] \\;\\ge\\; 1 - \\frac{1}{2} \\;=\\; \\frac{1}{2}.\n$$\n机器 $M$ 的运行时间是 $n$ 的多项式，因为它执行 $k(n) = \\lceil q(n)\\ln 2 \\rceil$ 次独立的 PPTM 运行，而 $k(n)$ 是 $n$ 的多项式。因此，$M$ 见证了 $L \\in \\text{RP}$。\n\n结合步骤1和步骤2，我们得到 $\\text{WEAK-RP} = \\text{RP}$。\n\n因此，正确选项是 C。",
            "answer": "$$\\boxed{C}$$"
        },
        {
            "introduction": "复杂性类并非孤立存在，它们通过归约（reduction）相互关联。这个练习探讨了当一个确定性多项式时间算法（P 类）使用一个 RP 语言作为预言机（oracle）时会发生什么。你需要分析当预言机的单侧随机错误在多次查询中累积时，最终算法的错误特性，并量化需要多少次重复才能将总体错误率控制在特定阈值之下。这项实践不仅连接了 RP 和 BPP（有界错误概率多项式时间）这两个重要的随机复杂性类，还锻炼了对概率误差进行严谨分析的能力 。",
            "id": "1455492",
            "problem": "一台预言图灵机 $M$ 被设计用于判定语言 $L_1$。对于任意长度为 $n$ 的输入 $x$，机器 $M$ 保证在多项式时间内停机，并对语言 $L_2$ 的预言机进行至多 $Q(n) = 2n$ 次调用。\n\n语言 $L_2$ 属于复杂度类随机多项式时间 (RP)。这意味着存在一个概率算法 $A_2$，它在多项式时间内运行，并且对于任何输入字符串 $y$：\n- 如果 $y \\in L_2$，则 $A_2(y)$ 接受的概率至少为 $1/2$。\n- 如果 $y \\notin L_2$，则 $A_2(y)$ 接受的概率恰好为 $0$。\n\n我们构造一个新的概率算法 $A_1$ 来判定 $L_1$，该算法不使用预言机。我们通过运行机器 $M$ 并模拟其预言机调用来实现这一点。当 $M$ 向预言机查询字符串 $y$ 时，我们的模拟过程会对 $y$ 运行算法 $A_2$ 进行 $k$ 次独立试验。如果这 $k$ 次试验中至少有一次结果为接受，则模拟向 $M$ 提供答案“是”；否则，提供答案“否”。\n\n考虑一个用于 $L_1$ 的输入 $x$，其长度为 $n=10$。为保证我们的算法 $A_1$ 对输入 $x$ 产生错误答案的总体概率至多为 $1/24$，$k$ 的最小整数值是多少？",
            "solution": "机器 $M$ 最多进行 $Q(n)=2n$ 次预言机调用，因此对于 $n=10$，最多有 $Q(10)=20$ 次调用。\n\n用于 $L_2$ 的算法 $A_2$ 具有单边错误：对于 $y \\in L_2$，单次试验接受的概率至少为 $1/2$，而对于 $y \\notin L_2$，它从不接受。当模拟对输入 $y$ 的预言机调用时，我们运行 $k$ 次独立试验，只要有任何一次试验接受，就回答“是”。因此，对于 $y \\in L_2$，模拟器错误地回答“否”的概率至多为\n$$\n(1-\\tfrac{1}{2})^{k} = 2^{-k},\n$$\n而对于 $y \\notin L_2$，错误概率为 $0$。\n\n令 $E_i$ 为第 $i$ 次模拟的预言机回答是错误的事件。那么对于每次可能的查询，$\\Pr[E_{i}] \\le 2^{-k}$。根据对至多 $Q(10)=20$ 次查询使用联合界，任何一次模拟的预言机回答是错误的概率至多为\n$$\n\\sum_{i=1}^{20} \\Pr[E_{i}] \\le 20 \\cdot 2^{-k}.\n$$\n由于在给定正确的预言机回答时，$M$ 能正确判定 $L_1$，因此 $A_1$ 的总体错误概率至多为 $20 \\cdot 2^{-k}$。为确保此概率至多为 $\\frac{1}{24}$，我们需要\n$$\n20 \\cdot 2^{-k} \\le \\frac{1}{24} \\quad \\Longleftrightarrow \\quad 2^{-k} \\le \\frac{1}{480} \\quad \\Longleftrightarrow \\quad k \\ge \\log_{2}(480).\n$$\n因为 $2^8=256$ 且 $2^9=512$，我们有 $\\log_2(480) \\approx 8.9$，所以满足该不等式的最小整数 $k$ 是 $k=9$。",
            "answer": "$$\\boxed{9}$$"
        }
    ]
}