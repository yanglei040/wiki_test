{
    "hands_on_practices": [
        {
            "introduction": "Understanding how complexity classes behave under standard operations like union is fundamental to mapping the landscape of computation. This practice explores whether the class $RP$ is closed under union, a key structural property. By analyzing a proposed algorithm for combining two separate $RP$ tests , you'll gain hands-on experience in constructing and verifying probabilistic polynomial-time machines.",
            "id": "1455470",
            "problem": "In the field of computational complexity theory, the class RP, which stands for Randomized Polynomial Time, characterizes decision problems solvable by a probabilistic Turing machine with one-sided error. A language $L$ is in RP if there exists a probabilistic, polynomial-time Turing machine $M$ such that for any input string $x$:\n1. If $x$ is in the language $L$, then the probability that $M$ outputs 1 (accepts) is at least $1/2$ ($x \\in L \\implies \\Pr(M(x) = 1) \\ge 1/2$).\n2. If $x$ is not in the language $L$, then the probability that $M$ outputs 1 (accepts) is exactly 0 ($x \\notin L \\implies \\Pr(M(x) = 1) = 0$).\n\nConsider a company that designs microchips. They have developed two separate probabilistic testing algorithms, $A_1$ and $A_2$, to detect different types of manufacturing flaws. Let $L_1$ be the set of all chips with a \"type-1\" flaw, and $L_2$ be the set of all chips with a \"type-2\" flaw. Both testing algorithms correspond to RP machines, meaning the languages $L_1$ and $L_2$ are both in the complexity class RP.\n\nA chip is considered \"globally defective\" if it has a type-1 flaw, or a type-2 flaw, or both. Let $L_{union}$ be the language of all globally defective chips, so $L_{union} = L_1 \\cup L_2$.\n\nTo create a unified test, an engineer proposes a new algorithm, $A_{union}$. On receiving a chip $x$ for testing, $A_{union}$ operates as follows:\n- First, run the algorithm $A_1$ on $x$.\n- If $A_1$ outputs 1, then $A_{union}$ immediately outputs 1 and halts.\n- If $A_1$ outputs 0, then $A_{union}$ proceeds to run algorithm $A_2$ on $x$ and outputs the result of $A_2$.\n\nBased on this construction, which of the following statements about the language $L_{union}$ is always true?\n\nA. $L_{union}$ is guaranteed to be in RP.\n\nB. $L_{union}$ is not guaranteed to be in RP, but it is guaranteed to be in co-RP.\n\nC. The classification of $L_{union}$ depends on the specific properties of $L_1$ and $L_2$; it is not guaranteed to be in RP.\n\nD. $L_{union}$ is guaranteed to be in P (Polynomial Time).\n\nE. $L_{union}$ is guaranteed to be in BPP (Bounded-error Probabilistic Polynomial Time), but not necessarily in RP.",
            "solution": "We are given two languages $L_{1},L_{2}$ in RP. By definition, there exist probabilistic polynomial-time algorithms $A_{1},A_{2}$ such that for all inputs $x$:\n- If $x \\in L_{i}$, then $\\Pr(A_{i}(x)=1) \\ge \\frac{1}{2}$.\n- If $x \\notin L_{i}$, then $\\Pr(A_{i}(x)=1)=0$.\nThe proposed unified algorithm $A_{\\text{union}}$ runs $A_{1}$ first and accepts immediately if $A_{1}$ accepts; otherwise it runs $A_{2}$ and outputs its result. We analyze the running time and correctness relative to the RP definition.\n\nPolynomial time: Let the running times be $T_{1}(n)$ and $T_{2}(n)$ for inputs of length $n$, both polynomial. Then the running time $T_{\\text{union}}(n)$ satisfies\n$$\nT_{\\text{union}}(n) \\le T_{1}(n) + T_{2}(n),\n$$\nwhich is polynomial; hence $A_{\\text{union}}$ runs in probabilistic polynomial time.\n\nOne-sided error (soundness on negatives): If $x \\notin L_{1} \\cup L_{2}$, then $x \\notin L_{1}$ and $x \\notin L_{2}$, so\n$$\n\\Pr(A_{1}(x)=1)=0 \\quad \\text{and} \\quad \\Pr(A_{2}(x)=1)=0.\n$$\nTherefore $A_{\\text{union}}$ accepts with probability\n$$\n\\Pr(A_{\\text{union}}(x)=1) = 0 + \\Pr(A_{1}(x)=0)\\cdot 0 = 0,\n$$\nso there are no false positives.\n\nAcceptance probability on positives: If $x \\in L_{1} \\cup L_{2}$, we consider cases.\n- If $x \\in L_{1} \\setminus L_{2}$, then $\\Pr(A_{1}(x)=1) \\ge \\frac{1}{2}$, so $A_{\\text{union}}$ accepts with probability at least $\\frac{1}{2}$ without needing $A_{2}$.\n- If $x \\in L_{2} \\setminus L_{1}$, then $\\Pr(A_{1}(x)=1)=0$ (since $x \\notin L_{1}$), hence $A_{\\text{union}}$ runs $A_{2}$ and accepts with probability\n$$\n\\Pr(A_{\\text{union}}(x)=1)=\\Pr(A_{2}(x)=1)\\ge \\frac{1}{2}.\n$$\n- If $x \\in L_{1} \\cap L_{2}$, then $\\Pr(A_{1}(x)=1) \\ge \\frac{1}{2}$, so $A_{\\text{union}}$ accepts with probability at least $\\frac{1}{2}$.\n\nIn all cases with $x \\in L_{1} \\cup L_{2}$, we have $\\Pr(A_{\\text{union}}(x)=1) \\ge \\frac{1}{2}$. Combined with the zero acceptance probability on negatives and polynomial time, this meets the RP definition. Therefore $L_{\\text{union}} \\in \\text{RP}$, and statement A is always true. The other options are unnecessary or false as general guarantees.\n\nThus, the correct choice is A.",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "The definition of $RP$ specifies an acceptance probability of at least $\\frac{1}{2}$ for strings in the language. But is this constant crucial, or could it be something else? This thought experiment  challenges you to explore what happens when this probability is relaxed to be just $1/p(n)$ for some polynomial $p$. You will discover the powerful technique of probability amplification, revealing that the definition of $RP$ is far more robust than it might first appear.",
            "id": "1455479",
            "problem": "In computational complexity theory, a language is a set of strings over some alphabet. The complexity class RP (Randomized Polynomial time) is defined using a Probabilistic Polynomial-Time Machine (PPTM). A language $L$ is said to be in RP if there exists a PPTM, let's call it $M$, that runs in time polynomial in the input length $|x|$ and satisfies the following two conditions:\n1. For any string $x$ that is in the language $L$ (i.e., $x \\in L$), the machine $M$ accepts with a probability of at least $1/2$. Symbolically, $\\Pr[M(x) \\text{ accepts}] \\ge 1/2$.\n2. For any string $x$ that is not in the language $L$ (i.e., $x \\notin L$), the machine $M$ always rejects. Symbolically, $\\Pr[M(x) \\text{ accepts}] = 0$.\n\nNow, consider a new complexity class, which we will call $\\text{WEAK-RP}$. A language $L$ is in $\\text{WEAK-RP}$ if there exists a PPTM, let's call it $M'$, and a polynomial $p(n)$ such that for any input string $x$ of length $n = |x|$:\n1. If $x \\in L$, then $\\Pr[M'(x) \\text{ accepts}] \\ge 1/p(n)$.\n2. If $x \\notin L$, then $\\Pr[M'(x) \\text{ accepts}] = 0$.\n\nWhat is the relationship between the complexity classes RP and $\\text{WEAK-RP}$?\n\nA. $\\text{WEAK-RP}$ is a proper subset of RP (i.e., $\\text{WEAK-RP} \\subset \\text{RP}$ and $\\text{WEAK-RP} \\neq \\text{RP}$).\n\nB. $\\text{WEAK-RP}$ is a proper superset of RP (i.e., $\\text{RP} \\subset \\text{WEAK-RP}$ and $\\text{RP} \\neq \\text{WEAK-RP}$).\n\nC. $\\text{WEAK-RP}$ is equal to RP (i.e., $\\text{WEAK-RP} = \\text{RP}$).\n\nD. $\\text{WEAK-RP}$ and RP are incomparable (i.e., neither is a subset of the other).\n\nE. Every language in $\\text{WEAK-RP}$ is undecidable, whereas RP contains some decidable languages.",
            "solution": "We first restate the defining properties. RP consists of languages for which there exists a probabilistic polynomial-time machine that accepts every $x \\in L$ with probability at least $1/2$ and never accepts $x \\notin L$. The class $\\text{WEAK-RP}$ relaxes the acceptance probability on $x \\in L$ to be at least $1/p(n)$ for some polynomial $p(n)$ (depending only on the input length $n = |x|$), while still requiring zero acceptance probability on $x \\notin L$.\n\nStep 1 (RP is contained in WEAK-RP): Let $L \\in \\text{RP}$ with witness machine $M$ satisfying $\\Pr[M(x)\\text{ accepts}] \\ge 1/2$ for $x \\in L$ and $0$ for $x \\notin L$. Choose the constant polynomial $p(n) = 2$. Then $1/2 \\ge 1/p(n)$, so $M$ also witnesses that $L \\in \\text{WEAK-RP}$. Hence $\\text{RP} \\subseteq \\text{WEAK-RP}$.\n\nStep 2 (WEAK-RP is contained in RP via amplification): Let $L \\in \\text{WEAK-RP}$ with witness machine $M'$ and polynomial $p(n)$ such that for all $x$ with $n = |x|$,\n- if $x \\in L$ then $\\Pr[M'(x)\\text{ accepts}] \\ge 1/p(n)$,\n- if $x \\notin L$ then $\\Pr[M'(x)\\text{ accepts}] = 0$.\nWithout loss of generality, define $q(n) = \\max\\{1, \\lceil p(n) \\rceil\\}$ so that $q(n)$ is an integer polynomial and $q(n) \\ge 1$. Then for $x \\in L$ we still have $\\Pr[M'(x)\\text{ accepts}] \\ge 1/q(n)$ since $1/q(n) \\le 1/p(n)$.\n\nConstruct a new probabilistic polynomial-time machine $M$ that, on input $x$ of length $n$, performs $k(n) = \\lceil q(n)\\ln 2 \\rceil$ independent runs of $M'$ on $x$ and accepts if and only if at least one run accepts. This uses independent random bits across runs, so the runs are independent.\n\n- If $x \\notin L$, then each run accepts with probability $0$, so the probability that $M$ accepts is $0$. Thus the one-sided error condition is preserved.\n\n- If $x \\in L$, let $\\alpha(n) = \\Pr[M'(x)\\text{ accepts}]$, so $\\alpha(n) \\ge 1/q(n)$. By independence,\n$$\n\\Pr[M(x)\\text{ accepts}] \\;=\\; 1 - \\Pr[\\text{all }k(n)\\text{ runs reject}]\n\\;=\\; 1 - (1 - \\alpha(n))^{k(n)}.\n$$\nUsing $\\alpha(n) \\ge 1/q(n)$ and the monotonicity of $t \\mapsto (1-t)^{k}$ for $t \\in [0,1]$, we get\n$$\n\\Pr[M(x)\\text{ accepts}] \\;\\ge\\; 1 - \\left(1 - \\frac{1}{q(n)}\\right)^{k(n)} \\;\\ge\\; 1 - \\left(1 - \\frac{1}{q(n)}\\right)^{q(n)\\ln 2}.\n$$\nTo bound the latter term, use the inequality $\\ln(1 - z) \\le -z$ for $z \\in (0,1)$ to obtain\n$$\n\\left(1 - \\frac{1}{q(n)}\\right)^{q(n)\\ln 2}\n= \\exp\\!\\left(q(n)\\ln 2 \\cdot \\ln\\!\\left(1 - \\frac{1}{q(n)}\\right)\\right)\n\\le \\exp\\!\\left(q(n)\\ln 2 \\cdot \\left(-\\frac{1}{q(n)}\\right)\\right)\n= \\exp(-\\ln 2) = \\frac{1}{2}.\n$$\nTherefore,\n$$\n\\Pr[M(x)\\text{ accepts}] \\;\\ge\\; 1 - \\frac{1}{2} \\;=\\; \\frac{1}{2}.\n$$\nMachine $M$ runs in time polynomial in $n$ because it performs $k(n) = \\lceil q(n)\\ln 2 \\rceil$ independent executions of a PPTM with $k(n)$ polynomial in $n$. Thus $M$ witnesses that $L \\in \\text{RP}$.\n\nCombining Step 1 and Step 2 gives $\\text{WEAK-RP} = \\text{RP}$.\n\nHence the correct choice is C.",
            "answer": "$$\\boxed{C}$$"
        },
        {
            "introduction": "Algorithms often solve problems by calling subroutines, a concept formalized by oracle machines and reductions. This practical exercise  models a scenario where a problem is solved via a polynomial-time reduction to a language in $RP$. Your goal is to determine how to use the $RP$ algorithm as a probabilistic subroutine and control its error, a process that illustrates how problems reducible to $RP$ belong to the class $BPP$.",
            "id": "1455492",
            "problem": "An oracle Turing Machine $M$ is designed to decide a language $L_1$. On any input $x$ of length $n$, machine $M$ is guaranteed to halt in polynomial time and makes at most $Q(n) = 2n$ calls to an oracle for a language $L_2$.\n\nThe language $L_2$ belongs to the complexity class Randomized Polynomial Time (RP). This means there is a probabilistic algorithm, $A_2$, that runs in polynomial time and for any input string $y$:\n- If $y \\in L_2$, the probability that $A_2(y)$ accepts is at least $1/2$.\n- If $y \\notin L_2$, the probability that $A_2(y)$ accepts is exactly $0$.\n\nWe construct a new probabilistic algorithm, $A_1$, to decide $L_1$ without an oracle. We do this by running the machine $M$ and simulating its oracle calls. When $M$ queries the oracle about a string $y$, our simulation runs the algorithm $A_2$ on $y$ for $k$ independent trials. If at least one of these $k$ trials results in acceptance, the simulation provides the answer 'yes' to $M$; otherwise, it provides the answer 'no'.\n\nConsider an input $x$ for $L_1$ of length $n=10$. What is the minimum integer value of $k$ that guarantees the overall probability of our algorithm $A_1$ producing an incorrect answer for the input $x$ is at most $1/24$?",
            "solution": "Machine $M$ makes at most $Q(n)=2n$ oracle calls, so for $n=10$ there are at most $Q(10)=20$ calls.\n\nAlgorithm $A_{2}$ for $L_{2}$ has one-sided error: for $y \\in L_{2}$, a single trial accepts with probability at least $1/2$, and for $y \\notin L_{2}$ it never accepts. When simulating an oracle call on input $y$, we run $k$ independent trials and answer 'yes' if any trial accepts. Thus, for $y \\in L_{2}$ the probability that the simulator incorrectly answers 'no' is at most\n$$\n(1-\\tfrac{1}{2})^{k} = 2^{-k},\n$$\nwhile for $y \\notin L_{2}$ the error probability is $0$.\n\nLet $E_{i}$ be the event that the $i$-th simulated oracle answer is wrong. Then for each possible query, $\\Pr[E_{i}] \\le 2^{-k}$. By the union bound over at most $Q(10)=20$ queries, the probability that any simulated oracle answer is wrong is at most\n$$\n\\sum_{i=1}^{20} \\Pr[E_{i}] \\le 20 \\cdot 2^{-k}.\n$$\nSince $M$ decides $L_{1}$ correctly given correct oracle answers, the overall error probability of $A_{1}$ is at most $20 \\cdot 2^{-k}$. To ensure this is at most $\\frac{1}{24}$, we require\n$$\n20 \\cdot 2^{-k} \\le \\frac{1}{24} \\quad \\Longleftrightarrow \\quad 2^{-k} \\le \\frac{1}{480} \\quad \\Longleftrightarrow \\quad k \\ge \\log_{2}(480).\n$$\nBecause $2^{8}=256$ and $2^{9}=512$, we have $\\log_{2}(480) \\in (8,9]$, so the minimum integer $k$ satisfying the inequality is $k=9$.",
            "answer": "$$\\boxed{9}$$"
        }
    ]
}