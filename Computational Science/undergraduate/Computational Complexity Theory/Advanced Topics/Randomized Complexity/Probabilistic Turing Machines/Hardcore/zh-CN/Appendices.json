{
    "hands_on_practices": [
        {
            "introduction": "概率算法的力量通常不在于单次运行的准确性，而在于我们“放大”其正确性的能力。这第一个练习提供了一个对 $\\mathrm{BPP}$ 算法放大过程的动手计算，演示了如何通过重复算法并进行多数表决来显著降低错误概率。理解这一点是领会概率计算为何如此强大的基础。",
            "id": "1436863",
            "problem": "在计算复杂性理论领域，如果一个判定问题存在一个算法，对于任意给定的输入，该算法能以至少 $\\frac{2}{3}$ 的概率正确判断输入是否属于该语言，那么该问题就被称为可由有界错误概率多项式时间算法解决。这意味着任何单次运行得到错误答案的概率最多为 $\\frac{1}{3}$。\n\n考虑一个这样的算法，我们称之为 `ALG`，它被用来验证数据记录的完整性。对于任意给定的数据记录，`ALG` 给出正确验证结果的概率恰好为 $\\frac{2}{3}$，这意味着其错误概率恰好为 $\\frac{1}{3}$。为了提高可靠性，一位工程师实施了一种放大策略：将算法 `ALG` 在相同的输入数据记录上独立运行三次，并以三次结果的多数票作为最终答案。\n\n这种多数票机制产生错误答案的概率是多少？请将最终答案表示为最简分数。",
            "solution": "设 $p$ 为算法 `ALG` 单次运行产生错误答案的概率。根据题意，我们有 $p = \\frac{1}{3}$。\n因此，单次运行产生正确答案的概率为 $1 - p = 1 - \\frac{1}{3} = \\frac{2}{3}$。\n\n放大策略包括将算法独立运行三次并取多数票。当且仅当大多数运行产生错误答案时，此过程的最终结果才会是错误的。对于三次运行，这意味着三次中有两次运行是错误的，或者所有三次运行都是错误的。\n\n让我们分析这两种互斥的情况。由于每次运行是独立的，我们可以使用二项分布来建模错误结果的数量。设试验（运行）次数为 $n=3$。\n\n情况1：恰好有两次运行是错误的。\n在三次运行中选择哪两次是错误的方式数由二项式系数 $\\binom{3}{2}$ 给出。任意一个由两次错误运行和一次正确运行组成的特定序列（例如，错误-错误-正确）的概率是 $p \\cdot p \\cdot (1-p) = p^2 (1-p)$。\n所以，恰好有两次错误运行的总概率是：\n$$P(\\text{2 incorrect}) = \\binom{3}{2} p^2 (1-p)$$\n我们知道 $\\binom{3}{2} = \\frac{3!}{2!(3-2)!} = \\frac{3 \\cdot 2 \\cdot 1}{(2 \\cdot 1)(1)} = 3$。\n代入 $p$ 和 $1-p$ 的值：\n$$P(\\text{2 incorrect}) = 3 \\left(\\frac{1}{3}\\right)^2 \\left(\\frac{2}{3}\\right) = 3 \\cdot \\frac{1}{9} \\cdot \\frac{2}{3} = \\frac{6}{27}$$\n\n情况2：所有三次运行都是错误的。\n这种情况发生的方式数为 $\\binom{3}{3} = 1$。这个特定序列（错误-错误-错误）的概率是 $p \\cdot p \\cdot p = p^3$。\n所以，三次运行都错误的总概率是：\n$$P(\\text{3 incorrect}) = \\binom{3}{3} p^3 (1-p)^0 = 1 \\cdot p^3$$\n代入 $p$ 的值：\n$$P(\\text{3 incorrect}) = \\left(\\frac{1}{3}\\right)^3 = \\frac{1}{27}$$\n\n多数票机制出错的总概率是这两种情况的概率之和：\n$$P(\\text{failure}) = P(\\text{2 incorrect}) + P(\\text{3 incorrect})$$\n$$P(\\text{failure}) = \\frac{6}{27} + \\frac{1}{27} = \\frac{7}{27}$$\n\n最终概率为 $\\frac{7}{27}$。由于 7 和 27 互质，这个分数已经是最简形式。",
            "answer": "$$\\boxed{\\frac{7}{27}}$$"
        },
        {
            "introduction": "虽然一些概率算法存在双边错误，但其他算法，如复杂度类 $\\mathrm{RP}$ 中的算法，保证了对某一类答案的绝对正确性。这个问题探讨了针对此类单边错误算法的放大过程，其策略与简单的多数表决不同。你将计算达到期望置信水平所需的最小试验次数，这是算法实际设计中的一项关键技能。",
            "id": "1436854",
            "problem": "一位计算机科学家正在为一个关于语言 $L$ 的判定问题设计算法。该算法使用一台概率图灵机（PTM），这是一种标准图灵机的变体，可以在每一步进行随机选择。这台 PTM 旨在作为一个例子，用于解决一个属于被称为随机多项式时间（RP）的复杂度类中的语言的算法。\n\n对于任意给定的输入字符串 $x$，这台特定的 PTM（记作 $M$）的行为特征如下：\n- 如果字符串 $x$ 属于语言 $L$（即 $x \\in L$），机器 $M$ 保证会停机并输出“接受”。\n- 如果字符串 $x$ 不属于语言 $L$（即 $x \\notin L$），机器 $M$ 将会停机，并以恰好 $1/4$ 的概率错误地输出“接受”。它会以 $3/4$ 的概率正确地停机并输出“拒绝”。\n\n为了提高结果的可靠性，该科学家提出了一个放大算法，记作 $M_k$。这个新算法在同一个输入字符串 $x$ 上执行原始的 PTM $M$ 共 $k$ 次独立试验。$M_k$ 的判定规则定义如下：如果 $k$ 次试验中至少有一次结果为“拒绝”，它将对输入 $x$ 输出“拒绝”；否则，如果所有 $k$ 次试验都得到“接受”的结果，$M_k$ 将输出“接受”。\n\n为了确保放大算法 $M_k$ 错误地接受一个不属于语言 $L$ 的输入的概率严格小于 $1\\%$，必须执行的最小整数试验次数 $k$ 是多少？",
            "solution": "对于一个不属于 $L$ 的输入 $x$，运行一次独立的 $M$，“接受”这个错误事件发生的概率为 $\\frac{1}{4}$。放大算法 $M_{k}$ 仅在所有 $k$ 次独立运行都接受时才接受。根据独立性，当 $x \\notin L$ 时，所有 $k$ 次运行都接受的概率是\n$$\n\\left(\\frac{1}{4}\\right)^{k}.\n$$\n我们要求这个错误概率严格小于 $\\frac{1}{100}$：\n$$\n\\left(\\frac{1}{4}\\right)^{k}  \\frac{1}{100}.\n$$\n等价地，\n$$\n4^{k} > 100.\n$$\n取自然对数，\n$$\nk \\ln 4 > \\ln 100 = 2 \\ln 10,\n$$\n所以\n$$\nk > \\frac{2 \\ln 10}{\\ln 4}.\n$$\n为了找到满足这个严格不等式的最小整数 $k$，我们测试 $k=4$：\n$$\n4^{4} = 256 > 100 \\quad \\Longleftrightarrow \\quad \\left(\\frac{1}{4}\\right)^{4} = \\frac{1}{256}  \\frac{1}{100},\n$$\n所以 $k=4$ 足够。对于 $k=3$，$4^{3} = 64  100$，所以它不足够。因此，最小整数是 $k=4$。",
            "answer": "$$\\boxed{4}$$"
        },
        {
            "introduction": "一个强大的概率算法到底需要多少随机性？这最后一个练习从计算转向了一个深刻的概念性问题，通过探索对复杂度类 $\\mathrm{RP}$ 定义的一个看似微小的改动来展开。通过分析这一改动带来的后果，你将揭示概率计算与非确定性计算之间一个惊人而根本的联系，从而发现有时即使是极微小的成功机会也等同于 $\\mathrm{NP}$ 的计算能力。",
            "id": "1436826",
            "problem": "在计算复杂性理论中，概率图灵机是标准图灵机的一种变体，它可以使用随机性。如果存在一个多项式时间的概率图灵机 $M$，对于任何输入字符串 $x$ 都具有以下性质，则称语言 $L$ 属于复杂性类 **RP**（随机多项式时间）：\n1.  如果 $x$ 属于语言 $L$（一个“是”实例），则 $M$ 输出“接受”的概率至少为 $1/2$。形式上，$x \\in L \\implies \\Pr[M(x) \\text{ accepts}] \\geq 1/2$。\n2.  如果 $x$ 不属于语言 $L$（一个“否”实例），则 $M$ 输出“接受”的概率恰好为 $0$。形式上，$x \\notin L \\implies \\Pr[M(x) \\text{ accepts}] = 0$。\n\n一名计算机科学专业的学生提出了这个类的一个“更弱”的版本，他们称之为 $\\text{RP}_{\\text{weak}}$。其定义与 **RP** 相同，只是对“是”实例的条件有所放宽。具体来说，如果存在一个多项式时间的概率图灵机 $M'$，对于任何输入字符串 $x$ 都满足以下条件，则称语言 $L$ 属于 $\\text{RP}_{\\text{weak}}$：\n1.  如果 $x \\in L$，则 $M'$ 输出“接受”的概率严格大于 $0$。形式上，$x \\in L \\implies \\Pr[M'(x) \\text{ accepts}]  0$。\n2.  如果 $x \\notin L$，则 $M'$ 输出“接受”的概率恰好为 $0$。形式上，$x \\notin L \\implies \\Pr[M'(x) \\text{ accepts}] = 0$。\n\n这个新定义似乎允许那些在“是”实例上成功几率极小但非零的算法存在。问题在于，这一改变是否会显著改变该类的计算能力。以下哪个著名的复杂性类可被证明等价于 $\\text{RP}_{\\text{weak}}$？\n\n回顾 **NP**（非确定性多项式时间）的定义：如果对于每个 $x \\in L$，都存在一个长度为 $x$ 长度的多项式的“证书”或“见证”字符串 $y$，使得一个确定性多项式时间图灵机（“验证机”）可以检查 $y$ 证明了 $x \\in L$，则语言 $L$ 属于 **NP**。对于 $x \\notin L$，不存在这样的证书。\n\nA. `P` (多项式时间)\nB. `RP` (随机多项式时间)\nC. `BPP` (有界错误概率多项式时间)\nD. `NP` (非确定性多项式时间)\nE. `PSPACE` (多项式空间)",
            "solution": "设 $L$ 属于 $\\text{RP}_{\\text{weak}}$，其见证者为一个在多项式时间内运行的概率图灵机 $M'$。根据时间限制，存在一个多项式 $p$，使得对于长度为 $n$ 的输入，$M'$ 最多使用 $p(n)$ 个随机比特。对于任何固定的输入 $x$，$M'$ 的每次执行对应于固定一个随机字符串 $r \\in \\{0,1\\}^{p(|x|)}$，并以该随机性 $r$ 运行 $M'$ 的确定性计算。\n\n第一个包含关系 $\\text{RP}_{\\text{weak}} \\subseteq \\text{NP}$：假设 $x \\in L$。根据定义，$\\Pr[M'(x) \\text{ accepts}]  0$。由于样本空间是有限的，这意味着存在至少一个随机字符串 $r \\in \\{0,1\\}^{p(|x|)}$，使得确定性计算 $M'(x;r)$ 接受。考虑一个非确定性验证机 $V$，它在输入 $(x,r)$ 上模拟 $M'$ 在输入 $x$ 和随机带设置为 $r$ 的情况下的运行，并且当且仅当 $M'$ 接受时它才接受。这个模拟是确定性的，并且运行时间是 $|x|$ 的多项式，因为 $M'$ 本身是多项式时间的，且 $|r| \\leq p(|x|)$。如果 $x \\notin L$，那么根据定义 $\\Pr[M'(x) \\text{ accepts}] = 0$，这意味着对于所有的 $r$，$M'(x;r)$ 都拒绝。因此不存在接受的见证。所以 $L \\in \\text{NP}$。\n\n第二个包含关系 $\\text{NP} \\subseteq \\text{RP}_{\\text{weak}}$：设 $L \\in \\text{NP}$，其验证机 $V$ 的运行时间是 $|x|$ 的多项式。存在一个多项式 $p$，使得对于每个 $x \\in L$，都有一个见证 $y \\in \\{0,1\\}^{p(|x|)}$ 使得 $V(x,y)$ 接受，而对于 $x \\notin L$ 则不存在这样的 $y$。在输入 $x$ 上定义一个概率机器 $M'$ 如下：从 $\\{0,1\\}^{p(|x|)}$ 中均匀随机抽样一个字符串 $y$，确定性地运行 $V(x,y)$，并且当且仅当 $V$ 接受时它才接受。这个 $M'$ 在多项式时间内运行。如果 $x \\in L$，那么存在一个 $y^{\\ast}$ 使得 $V(x,y^{\\ast})$ 接受，所以\n$$\n\\Pr[M'(x) \\text{ accepts}] \\geq \\Pr[y = y^{\\ast}] = 2^{-p(|x|)}  0.\n$$\n如果 $x \\notin L$，那么对于所有的 $y$，$V(x,y)$ 都拒绝，所以\n$$\n\\Pr[M'(x) \\text{ accepts}] = 0.\n$$\n因此 $L \\in \\text{RP}_{\\text{weak}}$。\n\n结合这两个包含关系，我们得到 $\\text{RP}_{\\text{weak}} = \\text{NP}$。因此，可被证明等价于 $\\text{RP}_{\\text{weak}}$ 的类是 `NP`，对应于选项 D。",
            "answer": "$$\\boxed{D}$$"
        }
    ]
}