{
    "hands_on_practices": [
        {
            "introduction": "我们从一个基本问题开始：对于一个给定的布尔函数，实现它所需的最少逻辑门数是多少？这个问题通过一个具体的例子——在单调电路模型中计算与（AND）函数——向我们介绍了下界证明的思路。通过分析每个逻辑门所依赖的输入变量（即其“支撑集”），我们将得出一个精确的下界，并通过一个简单的归纳论证来形式化地证明它。",
            "id": "1414757",
            "problem": "一位硬件设计师正在构建一个定制的超大规模集成 (VLSI) 电路芯片。该芯片的一个核心组件必须计算 $n$ 个不同输入信号 $x_1, x_2, \\ldots, x_n$ 的逻辑合取（即“与”函数）。由于特定的设计约束，该设计师被限制只能使用“单调”逻辑。单调电路是仅由与门和或门构成的电路；它不包含非门。设计师可用的构建模块是扇入数为二的标准门（即，每个门正好接收两个输入）。该电路必须当且仅当所有 $n$ 个输入信号都为 '1' 时输出值 '1'。设计师的目标是最小化用于实现此函数的门的总数，因为这直接影响芯片的成本和功耗。虽然一个简单的与门链提供了一种可能的实现方式，但并不立即清楚这是否是最高效的方式，特别是因为或门也可用，并且输入可以扇出到多个门。确定构建一个计算 $n$ 个变量逻辑与的单调电路所需的双输入门的绝对最小数量。将你的答案表示为 $n$ 的函数。",
            "solution": "我们要使用仅有的双输入单调门（与门和或门）来计算 $f(x_{1},\\ldots,x_{n})=x_{1}\\wedge x_{2}\\wedge\\cdots\\wedge x_{n}$，并且必须最小化门的总数。\n\n对于电路中的每个节点 $v$，我们定义其支撑集 $S(v)\\subseteq\\{x_{1},\\ldots,x_{n}\\}$ 为在节点 $v$ 处计算的布尔函数实际所依赖的输入变量集合；等价地，$S(v)$ 是存在到 $v$ 的有向路径的输入集合。对于一个输入节点 $x_{i}$，我们有 $S(x_{i})=\\{x_{i}\\}$。对于任何双输入单调门 $w=u_{1}\\circ u_{2}$，其中 $\\circ\\in\\{\\wedge,\\vee\\}$，其支撑集满足\n$$\nS(w)=S(u_{1})\\cup S(u_{2}),\n$$\n因为在 $w$ 处的函数依赖于某个变量，当且仅当其至少一个输入依赖于该变量。\n\n令 $d(v)=|S(v)|$ 表示影响 $v$ 的不同输入变量的数量。那么，对于输入有 $d(x_{i})=1$，对于任何门 $w=u_{1}\\circ u_{2}$ 我们有\n$$\nd(w)=|S(u_{1})\\cup S(u_{2})|\\leq d(u_{1})+d(u_{2})。\n$$\n\n令 $g(v)$ 表示节点 $v$ 的传递扇入（子电路）中的门数。对于一个输入，$g(x_{i})=0$。对于一个门 $w=u_{1}\\circ u_{2}$，子电路的门数满足\n$$\ng(w)=g(u_{1})+g(u_{2})+1。\n$$\n我们断言，对于每个节点 $v$，都有\n$$\ng(v)\\geq d(v)-1。\n$$\n我们通过结构归纳法证明这一点。对于一个输入 $x_{i}$，$g(x_{i})=0$ 且 $d(x_{i})=1$，所以 $0\\geq 1-1$ 成立。对于一个门 $w=u_{1}\\circ u_{2}$，\n$$\ng(w)=g(u_{1})+g(u_{2})+1\\geq (d(u_{1})-1)+(d(u_{2})-1)+1=d(u_{1})+d(u_{2})-1\\geq d(w)-1,\n$$\n我们使用了归纳假设和 $d(w)\\leq d(u_{1})+d(u_{2})$。这就证明了该断言。\n\n将此应用于一个计算 $f(x_{1},\\ldots,x_{n})=x_{1}\\wedge\\cdots\\wedge x_{n}$ 的电路的输出节点 $o$。这个函数依赖于所有 $n$ 个输入，所以 $d(o)=n$。因此，\n$$\ng(o)\\geq n-1。\n$$\n这是对于任何计算 $n$ 元与运算的双输入单调电路的一个普适下界。\n\n通过一个由与门构成的二叉树（或链）可以达到 $n-1$ 个门的上界，该结构将 $n$ 个输入两两组合，直到产生单个输出，这恰好使用了 $n-1$ 个与门。或门无法减少这个数量：上述下界对于与门和或门的任何混合都成立，因为它只利用了在双输入单调门下支撑集是其输入的支撑集的并集这一事实。\n\n因此，所需的双输入门的绝对最小数量是 $n-1$。对于 $n=1$ 的情况，结果为 $0$，这也是正确的，因为输出可以被直接连接到 $x_{1}$，不需要任何门。",
            "answer": "$$\\boxed{n-1}$$"
        },
        {
            "introduction": "在了解了简单的门数下界之后，我们将探讨电路的*结构*如何极大地影响其规模。这个练习将为一个精心设计的函数，在析取范式（DNF）和合取范式（CNF）这两种基本表示之间，展示一个指数级的规模差距。这突显了“一个函数拥有小规模电路”并非普适性质，它强烈依赖于所允许的电路类型。",
            "id": "1414726",
            "problem": "在计算复杂性理论中，理解表示一个布尔函数所需的资源是一项基本任务。同一个函数的不同表示形式可能具有迥然不同的规模。考虑一个作用于 $n=m^2$ 个变量的布尔函数，其中 $m$ 是一个大于1的整数。这些变量表示为 $x_{i,j}$（$1 \\le i, j \\le m$），概念上可以排成一个 $m \\times m$ 的网格。\n\n我们定义“列满”函数 $f_m$，当且仅当网格中存在至少一个列 $j$，使得该列中的所有变量都为真（TRUE）时，该函数输出为真（TRUE）。也就是说，当存在一个 $j \\in \\{1, \\dots, m\\}$ 使得对于所有的 $i \\in \\{1, \\dots, m\\}$都有 $x_{i,j}=1$ 时，$f_m(x_{1,1}, \\dots, x_{m,m}) = 1$。否则，$f_m = 0$。\n\n一个布尔函数可以用析取范式（DNF）表示，即“与的或”（例如 $(x_1 \\land x_2) \\lor (x_3 \\land x_4)$）；或者用合取范式（CNF）表示，即“或的与”（例如 $(x_1 \\lor x_2) \\land (x_3 \\lor x_4)$）。DNF表示的大小是它包含的与项的数量。CNF表示的大小是它包含的或子句的数量。\n\n设 $S_{DNF}$ 是函数 $f_m$ 的最小DNF表示的大小，设 $S_{CNF}$ 是 $f_m$ 的最小CNF表示的大小。\n\n求比率 $\\frac{S_{CNF}}{S_{DNF}}$ 作为 $m$ 的函数。",
            "solution": "问题要求“列满”函数 $f_m$ 的最小合取范式（CNF）和最小析取范式（DNF）表示的大小之比。作用于 $n=m^2$ 个变量 $x_{i,j}$（$1 \\le i, j \\le m$）的函数 $f_m$ 被定义为：当且仅当存在一个列 $j$，其中所有变量 $x_{i,j}$ 都为真时，$f_m$ 为真。\n\n**第一步：确定最小DNF表示的大小，$S_{DNF}$。**\n\n函数 $f_m$ 的定义可以直接转换成一个逻辑表达式。条件“列 $j$ 中的所有变量都为真”可以写成与项 $C_j = x_{1,j} \\land x_{2,j} \\land \\dots \\land x_{m,j} = \\bigwedge_{i=1}^{m} x_{i,j}$。\n\n如果存在*至少一个*这样的列，函数 $f_m$ 就为真。这对应于对所有可能的列进行或运算。\n$$f_m = C_1 \\lor C_2 \\lor \\dots \\lor C_m = \\bigvee_{j=1}^{m} C_j = \\bigvee_{j=1}^{m} \\left( \\bigwedge_{i=1}^{m} x_{i,j} \\right)$$\n这个表达式是合取（与）的析取（或），根据定义它是一个DNF。这个DNF的大小，以与项的数量来衡量，是 $m$。\n\n为了证明这是最小析取范式，我们必须论证不存在更小的DNF。$f_m$ 的DNF中的任何项都必须是 $f_m$ 的一个素蕴涵项。如果 $T=1$ 蕴含 $f_m=1$，那么项 $T$ 就是一个蕴涵项。让我们考虑我们的一个项，$C_j = \\bigwedge_{i=1}^{m} x_{i,j}$。如果我们从此项中移除任何一个变量，比如 $x_{k,j}$，我们会得到一个新项 $T' = \\bigwedge_{i=1, i\\neq k}^{m} x_{i,j}$。我们可以构造一个变量赋值，使得 $T'=1$ 但 $f_m=0$。例如，将 $T'$ 中的所有变量设为1，将 $x_{k,j}=0$，并将网格中所有其他变量设为0。在这个赋值下，$T'=1$，但没有一列是全1（列 $j$ 不是，因为 $x_{k,j}=0$，其他列也不是），所以 $f_m=0$。因此，$T'$ 不是 $f_m$ 的蕴涵项。这表明每个项 $C_j$ 都是一个素蕴涵项，因为不能移除任何文字。$f_m$ 的任何有效DNF都必须是覆盖该函数的素蕴涵项之和。因为每个 $C_j$ 覆盖了一组任何其他 $C_k$ 都不覆盖的可满足赋值（例如，只有列 $j$ 全为1的赋值），所以所有 $m$ 个项都是必需的。\n因此，$f_m$ 的最小DNF正是我们写出的那个。其大小为：\n$$S_{DNF} = m$$\n\n**第二步：确定最小CNF表示的大小，$S_{CNF}$。**\n\nCNF是或的与。我们可以通过应用分配律 $(A \\land B) \\lor C = (A \\lor C) \\land (B \\lor C)$ 从我们找到的DNF中推导出CNF。对我们的DNF重复应用此定律等价于一个更一般的规则。\n我们的DNF是 $f_m = C_1 \\lor C_2 \\lor \\dots \\lor C_m$，其中每个 $C_j$ 是文字的合取 $C_j = \\{x_{1,j}, x_{2,j}, \\dots, x_{m,j}\\}$。\n要将其转换为CNF，我们通过从每个项 $C_1, C_2, \\dots, C_m$ 中各挑选一个文字并将它们进行或运算来构成新的子句。得到的CNF中的一个通用子句将具有以下形式：\n$$K = (y_1 \\lor y_2 \\lor \\dots \\lor y_m)$$\n其中 $y_1$ 是来自 $C_1$ 的一个变量，$y_2$ 是来自 $C_2$ 的一个变量，依此类推。\n从项 $C_j$ 中可用的变量是 $\\{x_{1,j}, x_{2,j}, \\dots, x_{m,j}\\}$。对于每个 $y_j$ 都有 $m$ 种选择。\n因此，CNF中的一个子句看起来像这样：\n$$(x_{i_1, 1} \\lor x_{i_2, 2} \\lor \\dots \\lor x_{i_m, m})$$\n其中每个索引 $i_k$ 可以是 $1$ 到 $m$ 之间的任意整数。\n\n为了找到此类子句的总数，我们计算从 $m$ 个列项中各选择一个变量的方法数。\n- 对于第一个项 $C_1$，我们有 $m$ 种变量选择（任何 $x_{i,1}$）。\n- 对于第二个项 $C_2$，我们有 $m$ 种变量选择（任何 $x_{i,2}$）。\n- ...\n- 对于第 $m$ 个项 $C_m$，我们有 $m$ 种变量选择（任何 $x_{i,m}$）。\n\n由于每个项的选择是独立的，不同子句的总数是每个项选择数的乘积：\n$$S_{CNF} = m \\times m \\times \\dots \\times m \\quad (m \\text{ 次})$$\n$$S_{CNF} = m^m$$\n\n为了确认这是最小CNF，可以论证这 $m^m$ 个子句中的每一个都是 $f_m$ 的素蕴含子句。一个蘊含子句是一个被 $f_m$ 所蕴含的子句 $K$，意味着如果 $f_m=1$，那么 $K=1$。这等价于说如果 $K=0$，那么 $f_m=0$。\n考虑一个子句 $K = (x_{i_1, 1} \\lor x_{i_2, 2} \\lor \\dots \\lor x_{i_m, m})$。如果我们设 $K=0$，这意味着我们设 $x_{i_1, 1}=0, x_{i_2, 2}=0, \\dots, x_{i_m, m}=0$。这个赋值确保了对于每个列 $j$，至少有一个变量（即 $x_{i_j, j}$）为0。因此，不可能有任何一列全为1，这意味着 $f_m=0$。所以，$K$ 是一个蕴含子句。它是一个素蕴含子句，因为从中移除任何变量都会破坏这个性质。例如，如果我们移除 $x_{i_1, 1}$，新的子句是 $K'=(x_{i_2, 2} \\lor \\dots \\lor x_{i_m, m})$。我们可以将 $K'$ 中的所有变量都设为0，这使得 $K'=0$。但我们也可以将列1中的所有变量都设为1。这将使得 $f_m=1$。因此，$K'$ 不是一个蕴含子句。\n最小CNF是所有素蕴含子句的合取。我们已经找到了所有 $m^m$ 个。因此，最小CNF的大小是 $m^m$。\n\n**第三步：计算比率。**\n\n现在我们计算比率 $\\frac{S_{CNF}}{S_{DNF}}$。\n$$ \\frac{S_{CNF}}{S_{DNF}} = \\frac{m^m}{m} = m^{m-1} $$\n这个比率展示了对于该函数，最小DNF和最小CNF的大小之间存在指数级的差距，因为指数的底数 $m$ 随着变量数量的增加而增长（$m=\\sqrt{n}$）。",
            "answer": "$$\\boxed{m^{m-1}}$$"
        },
        {
            "introduction": "为了证明更复杂的下界，我们需要更精密的工具。这个问题引入了“平均敏感度”，它衡量当输入位翻转时，函数输出值变化的频繁程度。通过为重要的内积函数（Inner Product function）计算这个值，我们能够从数量上把握其复杂度，这是现代下界技术中的关键第一步。",
            "id": "1414709",
            "problem": "在布尔电路的分析中，布尔函数的一个关键属性是其对输入变化的敏感度。该属性衡量了当单个输入比特翻转时，函数输出翻转的可能性。\n\n设 $f: \\{0,1\\}^n \\to \\{0,1\\}$ 是一个关于 $n$ 个变量的布尔函数。对于一个输入字符串 $z \\in \\{0,1\\}^n$，$f$ 在 $z$ 处的*敏感度*（记作 $s_f(z)$）定义为使得翻转 $z$ 的第 $i$ 个比特会改变 $f$ 的值的输入位置 $i \\in \\{1, 2, \\dots, n\\}$ 的数量。函数 $f$ 的*平均敏感度*（记作 $\\mathbb{E}[s_f]$）是在所有 $2^n$ 个可能输入上敏感度的平均值。\n\n考虑定义在 $n=2m$ 个变量上的*内积*函数 $IP_m$。输入被分为两半，$x = (x_1, \\dots, x_m)$ 和 $y = (y_1, \\dots, y_m)$，因此总的输入字符串是 $(x_1, \\dots, x_m, y_1, \\dots, y_m)$。该函数定义为 $x$ 和 $y$ 的按位与的奇偶性：\n$$IP_m(x, y) = \\bigoplus_{i=1}^{m} (x_i \\land y_i) = (x_1 \\land y_1) \\oplus (x_2 \\land y_2) \\oplus \\dots \\oplus (x_m \\land y_m)$$\n其中 $\\oplus$ 表示异或（XOR）运算，$\\land$ 表示逻辑与（AND）运算。\n\n你的任务是计算内积函数 $IP_m$ 的平均敏感度 $\\mathbb{E}[s_{IP_m}]$。请将你的答案表示为 $m$ 的函数。",
            "solution": "设 $f=IP_{m}$。对于每个 $i \\in \\{1,\\dots,m\\}$，定义 $z_{i}=x_{i} \\land y_{i}$，使得\n$$\nf(x,y)=\\bigoplus_{i=1}^{m} z_{i}.\n$$\n翻转单个输入比特只会影响相应的 $z_{i}$。具体来说：\n- 当且仅当 $y_{i}=1$ 时，翻转 $x_{i}$ 会使 $z_{i}$ 翻转（因为当 $y_{i}=1$ 时 $z_{i}=x_{i}$，而当 $y_{i}=0$ 时 $z_{i}=0$）。\n- 当且仅当 $x_{i}=1$ 时，翻转 $y_{i}$ 会使 $z_{i}$ 翻转。\n\n因为输出是 $z_{i}$ 的异或，翻转任何单个 $z_{i}$ 都会使 $f$ 翻转。因此，在输入 $(x,y)$ 处，对 $x_i$ 的敏感度是1当且仅当 $y_i=1$，对 $y_i$ 的敏感度是1当且仅当 $x_i=1$。总敏感度是这些贡献的总和：\n$$\ns_{f}(x,y)=\\sum_{i=1}^{m} \\mathbf{1}\\{y_{i}=1\\} + \\sum_{i=1}^{m} \\mathbf{1}\\{x_{i}=1\\}=\\sum_{i=1}^{m} y_{i}+\\sum_{i=1}^{m} x_{i}.\n$$\n\n在 $\\{0,1\\}^{2m}$ 上的均匀分布上取平均，并使用期望的线性性质，\n$$\n\\mathbb{E}[s_{f}]=\\sum_{i=1}^{m} \\mathbb{E}[x_{i}] + \\sum_{i=1}^{m} \\mathbb{E}[y_{i}].\n$$\n对于均匀独立的比特，对于每个 $i$ 都有 $\\mathbb{E}[x_{i}]=\\mathbb{E}[y_{i}]=\\frac{1}{2}$，所以\n$$\n\\mathbb{E}[s_{f}]=m \\cdot \\frac{1}{2} + m \\cdot \\frac{1}{2}=m.\n$$\n等价地，将平均敏感度看作影响力的总和，每个 $2m$ 输入比特的影响力都是 $\\frac{1}{2}$（因为 $\\Pr[y_{i}=1]=\\Pr[x_{i}=1]=\\frac{1}{2}$），求和得到 $m$。",
            "answer": "$$\\boxed{m}$$"
        }
    ]
}