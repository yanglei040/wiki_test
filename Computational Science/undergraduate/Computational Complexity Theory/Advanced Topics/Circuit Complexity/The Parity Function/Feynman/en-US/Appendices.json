{
    "hands_on_practices": [
        {
            "introduction": "To truly understand the complexity of a function, we must first determine the minimum amount of information required to compute it. This thought experiment  frames this question as an intuitive 'Parity Puzzle'. By figuring out the winning strategy, you will establish a fundamental lower bound on the computational resources needed for the parity function, a concept known as query complexity.",
            "id": "1460431",
            "problem": "You are playing a game called the 'Parity Puzzle' against a game master. The game master secretly chooses a binary string $B$ of length $n$, where $B = b_1 b_2 \\dots b_n$ and each $b_i$ is either 0 or 1.\n\nYour goal is to determine the parity of the string $B$. The parity of a binary string is defined as 1 if the number of ones in the string is odd, and 0 if the number of ones is even.\n\nTo achieve this, you are allowed to make a specific type of query. In each query, you can choose an index $i$ (where $1 \\le i \\le n$) and ask the game master for the value of the bit $b_i$. The game master will truthfully reveal the value of $b_i$.\n\nWhat is the minimum number of queries you must make to be absolutely certain of the parity of the entire string $B$, regardless of the string the game master has chosen? Express your answer as a function of $n$.",
            "solution": "Let $B = b_{1}b_{2}\\dots b_{n}$ with each $b_{i} \\in \\{0,1\\}$. The parity of $B$ is the XOR of its bits, defined as\n$$\nP(B) = \\bigoplus_{i=1}^{n} b_{i},\n$$\nwhich equals $1$ if the number of ones is odd and $0$ otherwise.\n\nLower bound (necessity of $n$ queries): Consider any deterministic strategy that queries $k<n$ indices, possibly adaptively, and suppose the set of queried indices is $Q \\subset \\{1,\\dots,n\\}$ with $|Q|=k$. After $k$ answers, there remains at least one unqueried index $j \\notin Q$. Let $B$ be any string consistent with the $k$ revealed bits. Construct another string $B'$ that agrees with $B$ on all queried indices and on all unqueried indices except $j$, and at $j$ set $b'_{j} = b_{j} \\oplus 1$. Then\n$$\nP(B') = \\left(\\bigoplus_{i \\in Q} b_{i}\\right) \\oplus \\left(\\bigoplus_{i \\notin Q, i \\neq j} b_{i}\\right) \\oplus b'_{j}\n= \\left(\\bigoplus_{i=1}^{n} b_{i}\\right) \\oplus 1\n= P(B) \\oplus 1.\n$$\nThus, given the same $k$ query answers, both parities $0$ and $1$ are consistent, so one cannot be certain of $P(B)$. Therefore any correct strategy requires at least $n$ queries in the worst case.\n\nUpper bound (sufficiency of $n$ queries): Query all $n$ bits, compute $P(B) = \\bigoplus_{i=1}^{n} b_{i}$ using associativity and commutativity of XOR, and output the result. This uses exactly $n$ queries and is always correct.\n\nBy matching lower and upper bounds, the minimum number of queries required to be certain of the parity is $n$.",
            "answer": "$$\\boxed{n}$$"
        },
        {
            "introduction": "Computing a function's output is one challenge; verifying that a given output is correct is another. This practice  introduces the concept of non-deterministic complexity, which measures the minimum information needed to *certify* an answer. You will discover a surprising and important property of the parity function: proving its value is just as difficult as computing it from scratch.",
            "id": "1460461",
            "problem": "In the field of computational complexity theory, a decision tree is a model of computation where an algorithm queries an input, one bit at a time, to determine the value of a function. The non-deterministic decision tree complexity of a function measures the minimum amount of information required to *certify* the function's output.\n\nConsider a Boolean function $f: \\{0, 1\\}^n \\to \\{0, 1\\}$ that takes an $n$-bit binary string $x = x_1x_2...x_n$ as input.\n\nA **1-certificate** for an input $x$ (where $f(x)=1$) is a partial assignment of values to a subset of the input bits, say at indices $I \\subseteq \\{1, 2, ..., n\\}$, such that any full $n$-bit string $y$ that agrees with the assignment on indices $I$ must satisfy $f(y)=1$. The size of the certificate is $|I|$. The **1-certificate complexity**, denoted $C_1(f)$, is the smallest integer $k$ such that for every input $x$ with $f(x)=1$, there exists a 1-certificate for $x$ of size at most $k$.\n\nSimilarly, a **0-certificate** is defined for inputs where $f(x)=0$, and the **0-certificate complexity** is denoted $C_0(f)$.\n\nThe overall **non-deterministic decision tree complexity** of the function $f$ is given by $N(f) = \\max \\left( C_0(f), C_1(f) \\right)$. This represents the minimum number of bits one must query in the worst case to be able to convince a verifier of the output value, given an oracle that suggests which bits to query.\n\nLet the $n$-bit parity function, $\\text{PARITY}_n: \\{0, 1\\}^n \\to \\{0, 1\\}$, be defined as:\n$$\n\\text{PARITY}_n(x) = \\begin{cases} 1 & \\text{if the number of 1s in } x \\text{ is odd} \\\\ 0 & \\text{if the number of 1s in } x \\text{ is even} \\end{cases}\n$$\nThis is equivalent to the exclusive OR (XOR) of the bits: $\\text{PARITY}_n(x) = x_1 \\oplus x_2 \\oplus \\dots \\oplus x_n$.\n\nDetermine the non-deterministic decision tree complexity, $N(\\text{PARITY}_n)$, for the $n$-bit parity function, where $n \\ge 2$.\n\nA. $1$\n\nB. $\\lfloor \\frac{n}{2} \\rfloor + 1$\n\nC. $n-1$\n\nD. $n$\n\nE. $2^n$",
            "solution": "We use the given definition that the non-deterministic decision tree complexity is $N(f)=\\max\\left(C_{0}(f),C_{1}(f)\\right)$, where $C_{b}(f)$ is the smallest integer $k$ such that every input $x$ with $f(x)=b$ has a $b$-certificate of size at most $k$.\n\nWe first prove a lower bound of $n$ on both $C_{0}(\\text{PARITY}_{n})$ and $C_{1}(\\text{PARITY}_{n})$. Fix any input $x \\in \\{0,1\\}^{n}$ and let $b=\\text{PARITY}_{n}(x) \\in \\{0,1\\}$. Consider any subset $I \\subseteq \\{1,2,\\dots,n\\}$ with $|I| \\leq n-1$. There exists an index $j \\in \\{1,2,\\dots,n\\} \\setminus I$. Define $y \\in \\{0,1\\}^{n}$ by $y_{i}=x_{i}$ for all $i \\neq j$ and $y_{j}=1-x_{j}$. Then $y$ agrees with $x$ on all indices in $I$, but since the parity function flips when a single bit is flipped, we have\n$$\n\\text{PARITY}_{n}(y)=1-\\text{PARITY}_{n}(x)=1-b.\n$$\nThus any partial assignment that fixes only the bits in $I$ cannot force the value $\\text{PARITY}_{n}=b$, because there exists a completion $y$ consistent with that assignment for which the value is $1-b$. Therefore no $b$-certificate for $x$ can have size at most $n-1$. Since $x$ and $b$ were arbitrary, this shows\n$$\nC_{0}(\\text{PARITY}_{n}) \\geq n \\quad \\text{and} \\quad C_{1}(\\text{PARITY}_{n}) \\geq n.\n$$\n\nWe next prove an upper bound of $n$ on both certificate complexities. For any input $x$, the full assignment that fixes all $n$ bits (i.e., $I=\\{1,2,\\dots,n\\}$ with the values given by $x$) is trivially a valid certificate of the correct value, because any string agreeing with $x$ on all $n$ positions is exactly $x$ and hence has the same parity. Therefore,\n$$\nC_{0}(\\text{PARITY}_{n}) \\leq n \\quad \\text{and} \\quad C_{1}(\\text{PARITY}_{n}) \\leq n.\n$$\n\nCombining the lower and upper bounds, we obtain\n$$\nC_{0}(\\text{PARITY}_{n})=C_{1}(\\text{PARITY}_{n})=n,\n$$\nand hence\n$$\nN(\\text{PARITY}_{n})=\\max\\left(C_{0}(\\text{PARITY}_{n}),C_{1}(\\text{PARITY}_{n})\\right)=n.\n$$\n\nTherefore, among the given options, the correct choice is $D$.",
            "answer": "$$\\boxed{D}$$"
        },
        {
            "introduction": "Boolean functions can be analyzed using powerful algebraic tools by representing them as polynomials. This exercise  guides you through the process of finding the unique multilinear polynomial that represents the three-variable parity function. Mastering this technique provides a bridge from the discrete world of bits to the continuous world of real-valued polynomials, unlocking new methods for analyzing computational hardness.",
            "id": "1460441",
            "problem": "In the analysis of Boolean functions, it is often useful to represent them as real-valued polynomials. Consider the three-variable parity function, denoted as $PARITY_3: \\{0,1\\}^3 \\to \\{0,1\\}$. This function returns $1$ if the number of inputs equal to $1$ is odd, and $0$ otherwise. For example, $PARITY_3(1,0,0)=1$ and $PARITY_3(1,1,0)=0$.\n\nA polynomial $P(x_1, x_2, x_3)$ is said to be multilinear if in every term, each variable $x_i$ appears with a power of at most one. There exists a unique real-valued multilinear polynomial that exactly matches the output of the $PARITY_3$ function for all eight possible inputs from the domain $\\{0,1\\}^3$.\n\nFind this unique multilinear polynomial. Express your answer as a polynomial in terms of $x_1$, $x_2$, and $x_3$.",
            "solution": "We seek the unique real multilinear polynomial $P(x_{1},x_{2},x_{3})$ that equals $PARITY_{3}(x_{1},x_{2},x_{3})$ on all inputs in $\\{0,1\\}^{3}$. Any multilinear polynomial in three variables has the form\n$$\nP(x_{1},x_{2},x_{3})=a_{0}+a_{1}x_{1}+a_{2}x_{2}+a_{3}x_{3}+a_{12}x_{1}x_{2}+a_{13}x_{1}x_{3}+a_{23}x_{2}x_{3}+a_{123}x_{1}x_{2}x_{3}.\n$$\nWe determine the coefficients by enforcing $P$ to match $PARITY_{3}$ at each corner of the cube.\n\nUsing $PARITY_{3}(0,0,0)=0$ gives\n$$\nP(0,0,0)=a_{0}=0.\n$$\nUsing $PARITY_{3}(1,0,0)=1$, $PARITY_{3}(0,1,0)=1$, and $PARITY_{3}(0,0,1)=1$ gives\n$$\nP(1,0,0)=a_{0}+a_{1}=1 \\;\\Rightarrow\\; a_{1}=1,\n$$\n$$\nP(0,1,0)=a_{0}+a_{2}=1 \\;\\Rightarrow\\; a_{2}=1,\n$$\n$$\nP(0,0,1)=a_{0}+a_{3}=1 \\;\\Rightarrow\\; a_{3}=1.\n$$\nUsing $PARITY_{3}(1,1,0)=0$, $PARITY_{3}(1,0,1)=0$, and $PARITY_{3}(0,1,1)=0$ gives\n$$\nP(1,1,0)=a_{0}+a_{1}+a_{2}+a_{12}=0 \\;\\Rightarrow\\; 0+1+1+a_{12}=0 \\;\\Rightarrow\\; a_{12}=-2,\n$$\n$$\nP(1,0,1)=a_{0}+a_{1}+a_{3}+a_{13}=0 \\;\\Rightarrow\\; 0+1+1+a_{13}=0 \\;\\Rightarrow\\; a_{13}=-2,\n$$\n$$\nP(0,1,1)=a_{0}+a_{2}+a_{3}+a_{23}=0 \\;\\Rightarrow\\; 0+1+1+a_{23}=0 \\;\\Rightarrow\\; a_{23}=-2.\n$$\nFinally, using $PARITY_{3}(1,1,1)=1$ gives\n$$\nP(1,1,1)=a_{0}+a_{1}+a_{2}+a_{3}+a_{12}+a_{13}+a_{23}+a_{123}=1,\n$$\n$$\n0+1+1+1-2-2-2+a_{123}=1 \\;\\Rightarrow\\; -3+a_{123}=1 \\;\\Rightarrow\\; a_{123}=4.\n$$\nSubstituting all coefficients yields the unique multilinear polynomial\n$$\nP(x_{1},x_{2},x_{3})=x_{1}+x_{2}+x_{3}-2x_{1}x_{2}-2x_{1}x_{3}-2x_{2}x_{3}+4x_{1}x_{2}x_{3}.\n$$",
            "answer": "$$\\boxed{x_{1}+x_{2}+x_{3}-2x_{1}x_{2}-2x_{1}x_{3}-2x_{2}x_{3}+4x_{1}x_{2}x_{3}}$$"
        }
    ]
}