{
    "hands_on_practices": [
        {
            "introduction": "An excellent way to begin our exploration of Oracle Turing Machines (OTMs) is by using one to solve a concrete problem. Imagine you have a \"black box\" that can instantly tell you if any number is prime. This exercise  challenges you to design an algorithm that uses this `PRIME` oracle to determine if a number is a semiprimeâ€”a product of two primes. This practice will help you distinguish between the high-level logic your machine must execute and the complex calculations that can be delegated to the oracle.",
            "id": "1433319",
            "problem": "An oracle Turing machine (OTM) is a standard Turing machine equipped with a special \"oracle\" tape and three special states: `q_query`, `q_yes`, and `q_no`. Whenever the OTM enters `q_query`, the oracle instantaneously performs a computation. If the string currently on the oracle tape belongs to a predefined oracle language $L_{oracle}$, the machine transitions to state `q_yes`; otherwise, it transitions to `q_no`. This query-answer process is considered a single computational step.\n\nConsider an OTM, let's call it $M$, that has access to an oracle for the language `PRIME` = {$k \\mid k$ is a prime number, where $k$ is represented in binary}. The goal of machine $M$ is to decide the language `SEMIPRIME` = {$n \\mid n$ is a semiprime number, where $n$ is represented in binary}. A semiprime is a natural number that is the product of two prime numbers (the two primes are not necessarily distinct).\n\nWhich of the following descriptions accurately represents the high-level algorithm that machine $M$ should implement to correctly decide `SEMIPRIME` for any given integer input $n  1$?\n\nA. Iterate through all integers $i$ from 2 to $n-1$. For each $i$, query the `PRIME` oracle on $i$. If the oracle accepts, check if $i$ divides $n$. If it does, halt and accept. If the loop completes without finding such an $i$, halt and reject.\n\nB. Query the `PRIME` oracle on the input $n$. If the oracle accepts, halt and reject. Otherwise, iterate through all integers $i$ from 2 to $\\lfloor \\sqrt{n} \\rfloor$. For each $i$, if $i$ divides $n$, query the `PRIME` oracle on $i$. If the oracle accepts, halt and accept. If the loop completes with no such factor found, halt and reject.\n\nC. Iterate through all integers $i$ from 2 to $\\lfloor \\sqrt{n} \\rfloor$. For each $i$, check if $i$ divides $n$. If it does, let $j = n/i$. Then, query the `PRIME` oracle on $i$ and query the `PRIME` oracle on $j$. If both queries are accepted, halt and accept. If the loop completes without finding such a pair $(i, j)$, halt and reject.\n\nD. Query the `PRIME` oracle on the input $n$. If the oracle accepts, halt and reject. Otherwise, halt and accept.\n\nE. Iterate through all integers $i$ from 2 to $\\lfloor \\sqrt{n} \\rfloor$. For each $i$, query the `PRIME` oracle on $i$. If the oracle accepts, check if $n$ is divisible by $i$ but not by $i^2$. If so, let $j=n/i$ and query the `PRIME` oracle on $j$. If this second query accepts, halt and accept. If the loop completes, reject.",
            "solution": "We must decide the language SEMIPRIME on input $n1$ using an oracle for PRIME. By definition, $n$ is semiprime if and only if there exist primes $p$ and $q$ such that $n=pq$, allowing $p=q$. Let $p \\leq q$; then $p \\leq \\sqrt{n}$, since if $p\\sqrt{n}$, then $pq  \\sqrt{n}\\cdot \\sqrt{n} = n$, a contradiction. Hence, $n$ is semiprime if and only if there exists an integer $i$ with $2 \\leq i \\leq \\lfloor \\sqrt{n} \\rfloor$, $i \\mid n$, and both $i$ and $j = n/i$ are prime.\n\nUsing a PRIME oracle, the correct high-level algorithm must therefore:\n- Iterate $i$ from $2$ to $\\lfloor \\sqrt{n} \\rfloor$.\n- For each $i$, test divisibility $i \\mid n$. If true, set $j=n/i$.\n- Query the oracle on $i$ and on $j$; accept if and only if both are prime.\n- If no such pair is found, reject.\n\nThis matches option C exactly. The other options are incorrect:\n- A accepts any $n$ having a prime divisor, e.g., $n=12$, where $i=2$ is prime and divides $n$, but $12$ is not semiprime.\n- B accepts composites with at least one small prime factor, e.g., $n=8$ with $i=2$, but $8$ is not semiprime.\n- D accepts any number that is not a prime, thus it incorrectly accepts non-semiprime composites (e.g., 12).\n- E incorrectly excludes prime squares by requiring $i^{2} \\nmid n$, so it rejects $n=9$ where $n=3\\cdot 3$ is semiprime.\n\nTherefore, only option C correctly decides SEMIPRIME using the PRIME oracle.",
            "answer": "$$\\boxed{C}$$"
        },
        {
            "introduction": "After seeing how an oracle can be used as a building block, we turn to a more fundamental question about their power. Does adding an oracle to a Turing machine automatically make it more powerful? This exercise  explores the crucial relationship between the complexity of the oracle language and the resulting complexity class. You will demonstrate that if the oracle itself decides a language in the class $P$, it provides no additional computational power to a polynomial-time machine, leading to the important identity $P^A = P$.",
            "id": "1417476",
            "problem": "In computational complexity theory, an oracle Turing machine (OTM) is an abstract machine used to study decision problems. It is a standard Turing machine with an additional \"oracle\" tape and special states. When the machine enters a special query state, it can obtain the answer to a membership question for a fixed language $A$ (the \"oracle language\") in a single computational step.\n\nLet $P$ and $NP$ be the standard complexity classes of languages decidable in polynomial time by a deterministic and non-deterministic Turing machine, respectively. For a given oracle language $A$, we define $P^A$ as the class of languages decidable by a deterministic OTM in polynomial time with oracle $A$. Similarly, $NP^A$ is the class of languages decidable by a non-deterministic OTM in polynomial time with oracle $A$.\n\nSuppose you are given that the oracle language $A$ is itself a member of the complexity class $P$. Which of the following statements are *always* true under this condition? Select all that apply.\n\nA. $P^A = P$\nB. $NP^A = P^A$\nC. $NP^A = NP$\nD. $P^A$ is the class of all languages $L$ that are polynomial-time many-one reducible to $A$.\nE. $P^A$ is a proper superset of $P$ (i.e., $P \\subset P^A$), because the oracle provides additional computational power.",
            "solution": "We are given that the fixed oracle language satisfies $A \\in P$. We analyze each statement under this condition.\n\nFirst, recall definitions: $P^{A}$ is the class of languages decidable in polynomial time by a deterministic oracle Turing machine with oracle $A$, equivalently the class of languages decidable in polynomial time with polynomially many, adaptive oracle queries to $A$ (i.e., polynomial-time Turing reducible to $A$). Similarly, $NP^{A}$ is the nondeterministic analogue.\n\nStatement A: $P^{A} = P$.\n- Inclusion $P \\subseteq P^{A}$ is trivial, since a deterministic machine can ignore the oracle.\n- For $P^{A} \\subseteq P$, let $L \\in P^{A}$ via some deterministic oracle machine $M^{A}$ that runs in time $q(n)$ on inputs of length $n = |x|$, where $q$ is a polynomial. Each oracle query has length at most $q(n)$ because $M^{A}$ can write at most $q(n)$ symbols in $q(n)$ steps. Since $A \\in P$, there is a deterministic decider for $A$ running in time $p(m)$ on inputs of length $m$, where $p$ is a polynomial. We can simulate $M^{A}$ on input $x$ by computing each oracle answer using the decider for $A$. The total number of queries is at most $q(n)$ (bounded by the step count), and each query answer costs at most $p(q(n))$ time. Therefore, the total simulation time is at most\n$$\nq(n) + q(n) \\cdot p(q(n)),\n$$\nwhich is polynomial in $n$ because a composition and product of polynomials is a polynomial. Hence $L \\in P$, so $P^{A} \\subseteq P$. Therefore, $P^{A} = P$. So A is true.\n\nStatement C: $NP^{A} = NP$.\n- Inclusion $NP \\subseteq NP^{A}$ is trivial, since a nondeterministic machine can ignore the oracle.\n- For $NP^{A} \\subseteq NP$, let $L \\in NP^{A}$ via some nondeterministic oracle machine $N^{A}$ that runs in time $q(n)$ on inputs of length $n$, where $q$ is a polynomial. As above, each oracle query has length at most $q(n)$, and there are at most $q(n)$ queries along any computation branch. Because $A \\in P$ with decider time $p(m)$, we can simulate each oracle answer deterministically in time $p(q(n))$. Replacing each oracle step by this deterministic computation yields a nondeterministic simulation of $N^{A}$ that runs in time at most\n$$\nq(n) + q(n) \\cdot p(q(n)),\n$$\nwhich is polynomial. Thus $L \\in NP$, so $NP^{A} \\subseteq NP$. Therefore, $NP^{A} = NP$. So C is true.\n\nStatement B: $NP^{A} = P^{A}$.\nGiven A and C above, $P^{A} = P$ and $NP^{A} = NP$. If B were always true, it would imply $NP = P$. This equality is not known to hold and certainly is not guaranteed merely by $A \\in P$. Therefore, B is not always true.\n\nStatement D: $P^{A}$ is the class of all languages $L$ that are polynomial-time many-one reducible to $A$.\nBy definition, $P^{A}$ corresponds to polynomial-time Turing reductions, not necessarily many-one reductions. Moreover, since $A \\in P$ we already have $P^{A} = P$. The class of languages polynomial-time many-one reducible to a fixed $A \\in P$ need not equal all of $P$. A concrete counterexample is $A = \\emptyset$. If $L \\leq_{m}^{p} \\emptyset$, then there exists a polynomial-time function $f$ such that $x \\in L$ iff $f(x) \\in \\emptyset$, which implies $L = \\emptyset$. Thus, the set of languages many-one reducible to $\\emptyset$ is just $\\{\\emptyset\\}$, whereas $P^{\\emptyset} = P$. Hence D is false.\n\nStatement E: $P^{A}$ is a proper superset of $P$.\nFrom A, $P^{A} = P$, so it is not a proper superset. Therefore, E is false.\n\nTherefore, the statements that are always true under $A \\in P$ are A and C.",
            "answer": "$$\\boxed{AC}$$"
        },
        {
            "introduction": "Oracle machines are not limited to simple tasks; they are central to understanding how to solve complex search and optimization problems using decision oracles. This practice  presents a powerful scenario where an oracle for the `SAT` problem, a quintessential decision problem, is used iteratively to solve a search problem: finding a minimal set of contradictory clauses in an unsatisfiable formula. This exercise illuminates the important technique of using a decision-problem solver to guide a search for a specific kind of solution.",
            "id": "1433316",
            "problem": "In computational complexity theory, an oracle Turing machine is an abstract machine used to study decision problems. It can be thought of as a standard Turing machine with a \"black box,\" called an oracle, that is able to decide certain problems in a single operation. For this problem, we consider an oracle for the Boolean Satisfiability (SAT) problem. This oracle, denoted $\\mathcal{O}_{SAT}$, takes any Boolean formula in Conjunctive Normal Form (CNF) as input and returns `TRUE` if the formula is satisfiable, and `FALSE` otherwise.\n\nA CNF formula is a conjunction (AND) of one or more clauses, where each clause is a disjunction (OR) of literals (a variable or its negation). An unsatisfiable CNF formula $\\phi$ may contain a smaller subset of its clauses that is itself unsatisfiable. Such a subset is called an unsatisfiable core. A minimal unsatisfiable core is an unsatisfiable core with the property that if any single clause is removed from it, the remaining set of clauses becomes satisfiable.\n\nConsider the following algorithm, `ReduceCore`, which is designed to find a minimal unsatisfiable core of a given unsatisfiable CNF formula $\\phi = \\{C_1, C_2, \\ldots, C_m\\}$. The algorithm relies on the $\\mathcal{O}_{SAT}$ oracle.\n\n**Algorithm: `ReduceCore`**\n1. Initialize a working set of clauses, $S$, to be a copy of the input formula $\\phi$.\n2. Iterate through the clauses of the original formula $\\phi$, $C_1, C_2, \\ldots, C_m$, in their given indexed order.\n3. For each clause $C_i$ from the original formula, form a test set $S_{\\text{test}} = S \\setminus \\{C_i\\}$. Note that $S$ may have been modified by previous steps. The test is to see if $C_i$ is currently in $S$ and if it can be removed.\n4. If $C_i$ is in $S$, query the oracle with $S_{\\text{test}}$. If $\\mathcal{O}_{SAT}(S_{\\text{test}})$ returns `FALSE` (meaning the set is still unsatisfiable without $C_i$), then permanently remove $C_i$ from the working set $S$.\n5. After the iteration is complete, the algorithm returns the final working set $S$.\n\nYou are given the following unsatisfiable CNF formula $\\Phi$ over the variables $\\{a, b, c, d, e\\}$. The formula consists of 9 clauses, indexed as follows:\n- $C_1: (a \\lor b)$\n- $C_2: (a \\lor \\neg b)$\n- $C_3: (\\neg a \\lor c)$\n- $C_4: (\\neg a \\lor \\neg c)$\n- $C_5: (a \\lor d)$\n- $C_6: (\\neg a \\lor \\neg d)$\n- $C_7: (a \\lor c \\lor d)$\n- $C_8: (b \\lor c)$\n- $C_9: (\\neg b \\lor \\neg c \\lor e)$\n\nWhat is the number of clauses in the final set returned by the `ReduceCore` algorithm when executed on the input formula $\\Phi$?",
            "solution": "Initialize $S=\\{C_1, \\ldots, C_9\\}$. The algorithm inspects $C_1, \\ldots, C_9$ in order. For each clause $C_i$ still in $S$, it queries $\\mathcal{O}_{SAT}(S \\setminus \\{C_i\\})$ and removes $C_i$ if and only if the oracle returns `FALSE` (i.e., the reduced set is still unsatisfiable).\n\nTest $C_1$: Consider $S \\setminus \\{C_1\\}=\\{C_2, \\ldots, C_9\\}$. The clauses $C_3$ and $C_4$ together imply $\\neg a$, so one may set $a=\\text{false}$. Then $C_2$ becomes $\\neg b$ (set $b=\\text{false}$); $C_6$ becomes $d$ (set $d=\\text{true}$). The remaining clauses can be satisfied, e.g., with $c=\\text{true}$ and $e=\\text{true}$. Thus $S \\setminus \\{C_1\\}$ is satisfiable, so $\\mathcal{O}_{SAT}$ returns `TRUE` and $C_1$ is kept.\n\nTest $C_2$: Consider $S \\setminus \\{C_2\\}$. Again, $C_3$ and $C_4$ imply $\\neg a$. Setting $a=\\text{false}$, $C_1$ becomes $b$ (set $b=\\text{true}$); $C_6$ becomes $d$ (set $d=\\text{true}$). The remaining clauses can be satisfied. Thus $S \\setminus \\{C_2\\}$ is satisfiable; the oracle returns `TRUE` and $C_2$ is kept.\n\nTest $C_3$: Consider $S \\setminus \\{C_3\\}=\\{C_1, C_2, C_4, C_5, C_6, C_7, C_8, C_9\\}$. We can set $a=\\text{true}$ and $c=\\text{false}$. This satisfies $C_1, C_2, C_4, C_5, C_7$. $C_6$ implies $\\neg d$, so set $d=\\text{false}$. $C_8$ implies $b$, so set $b=\\text{true}$. $C_9$ is satisfied by $\\neg c$. The assignment is consistent. Hence satisfiable; the oracle returns `TRUE` and $C_3$ is kept.\n\nTest $C_4$: Consider $S \\setminus \\{C_4\\}$. Set $a=\\text{true}$ and $c=\\text{true}$. This satisfies $C_1, C_2, C_3, C_5, C_7, C_8$. $C_6$ implies $\\neg d$, so set $d=\\text{false}$. $C_9$ can be satisfied by setting $e=\\text{true}$. Hence satisfiable; the oracle returns `TRUE` and $C_4$ is kept.\n\nTest $C_5$: Consider $S \\setminus \\{C_5\\}$. The pair $C_3$ and $C_4$ forces $a=\\text{false}$. Then $C_1$ becomes $b$ and $C_2$ becomes $\\neg b$, which is a contradiction. Therefore $S \\setminus \\{C_5\\}$ is unsatisfiable; the oracle returns `FALSE` and $C_5$ is removed, so $S := S \\setminus \\{C_5\\}$.\n\nTest $C_6$: Now consider $S \\setminus \\{C_6\\}$ with current $S$ not containing $C_5$. The same reasoning applies: $C_3$ and $C_4$ force $a=\\text{false}$, yielding $b$ and $\\neg b$ from $C_1$ and $C_2$, so the set is unsatisfiable. The oracle returns `FALSE` and $C_6$ is removed.\n\nTest $C_7$: With $C_5$ and $C_6$ already removed, consider $S \\setminus \\{C_7\\}$. Again, $C_3$ and $C_4$ force $a=\\text{false}$, producing $b$ and $\\neg b$ from $C_1$ and $C_2$, so it is unsatisfiable. The oracle returns `FALSE` and $C_7$ is removed.\n\nTest $C_8$: Consider $S \\setminus \\{C_8\\}$. As before, $C_3$ and $C_4$ force $a=\\text{false}$, so $C_1$ and $C_2$ contradict on $b$. Thus it is unsatisfiable; the oracle returns `FALSE` and $C_8$ is removed.\n\nTest $C_9$: Consider $S \\setminus \\{C_9\\}=\\{C_1,C_2,C_3,C_4\\}$. With $C_3$ and $C_4$ forcing $a=\\text{false}$, $C_1$ becomes $b$ and $C_2$ becomes $\\neg b$, yielding a contradiction. Thus it is unsatisfiable; the oracle returns `FALSE` and $C_9$ is removed.\n\nAfter completing the iteration, the final set is $S=\\{C_1, C_2, C_3, C_4\\}$, which has 4 clauses and is an inclusion-minimal unsatisfiable core (removing any one of these four clauses yields a satisfiable set).",
            "answer": "$$\\boxed{4}$$"
        }
    ]
}