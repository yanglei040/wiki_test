{
    "hands_on_practices": [
        {
            "introduction": "要掌握多项式时间层级中的复杂性类，例如 $\\text{coNP}$，最好的方法之一就是通过具体问题来检验其定义。这个练习将带你分析一个关于布尔逻辑蕴含的问题，帮助你理解如何为一个 $\\text{coNP}$ 问题识别其“否定”实例的有效证明（certificate），这是理解该复杂性类的关键一步 。",
            "id": "1417117",
            "problem": "在计算复杂性理论中，问题根据解决它们所需的资源进行分类。**$\\text{coNP}$** 类包含这样一类判定问题：对于这类问题，给定一个合适的证书，其“否定”答案可以被高效地验证。\n\n考虑两个布尔公式之间的逻辑蕴含问题。我们如下定义一个语言 `CNF_IMPLIES`。该问题的输入是一对布尔公式 $\\langle \\phi_1, \\phi_2 \\rangle$，两者都以 3-合取范式 (3-CNF) 的形式给出。一个公式处于 3-CNF，如果它是一些子句的合取（AND），其中每个子句是恰好三个文字的析取（OR）。一个文字是一个变量或其否定。\n\n当且仅当每个满足 $\\phi_1$ 的真值指派也满足 $\\phi_2$ 时，该对 $\\langle \\phi_1, \\phi_2 \\rangle$ 才属于语言 `CNF_IMPLIES`。换句话说，$\\phi_1$ 逻辑上蕴含 $\\phi_2$。\n\n下列哪个陈述为将 `CNF_IMPLIES` 语言归入复杂性类 **$\\text{coNP}$** 提供了有效的论据？\n\nA. 一个“否定”实例（即 $\\phi_1$ 不蕴含 $\\phi_2$）可以在多项式时间内被验证。其证书是一个对变量的真值指派。验证者可以使用这个指派在多项式时间内检查它是否满足 $\\phi_1$ 但不满足 $\\phi_2$。\n\nB. 一个“肯定”实例（即 $\\phi_1$ 蕴含 $\\phi_2$）可以在多项式时间内被验证。其证书是 $\\phi_2$ 的一个满足指派。验证者的工作是确认这个指派也满足 $\\phi_1$。\n\nC. 该问题属于 **$\\text{coNP}$**，因为一个确定性算法可以检查所有可能的变量真值指派。由于存在指数级数量的指派，这个检查需要指数时间，这是 **$\\text{coNP}$** 中问题的特征。\n\nD. 一个“否定”实例可以在多项式时间内被验证。这是通过检查公式 $\\phi_1 \\land \\phi_2$ 是否不可满足来完成的。因为判定一个 3-CNF 公式的不可满足性是一个已知的 **$\\text{coNP}$** 问题，所以这将 `CNF_IMPLIES` 归入 **$\\text{coNP}$**。\n\nE. 一个“否定”实例可以在多项式时间内被验证。其证书是来自 $\\phi_2$ 的一个子句。验证者的任务是检查这个子句是否可以在满足所有 $\\phi_1$ 的同时为假。",
            "solution": "我们回顾 $\\text{coNP}$ 的定义：一个语言 $L$ 属于 $\\text{coNP}$ 当且仅当其补集 $\\overline{L}$ 属于 NP，这可以等价地表述为：存在一个多项式时间的验证者，对于给定的输入 $x$，只要存在一个多项式大小的证书 $y$ 使得该验证者在关于 $|x|$ 的多项式时间内运行并接受 $(x,y)$，就能证明 $x \\notin L$。\n\n我们讨论的语言是\n$$\n\\text{CNF\\_IMPLIES} = \\{ \\langle \\phi_{1}, \\phi_{2} \\rangle \\mid \\text{每个满足 } \\phi_{1} \\text{ 的指派也满足 } \\phi_{2} \\}.\n$$\n根据逻辑，$\\phi_{1}$ 蕴含 $\\phi_{2}$ 当且仅当 $\\phi_{1} \\land \\lnot \\phi_{2}$ 是不可满足的。等价地，\n$$\n\\langle \\phi_{1}, \\phi_{2} \\rangle \\notin \\text{CNF\\_IMPLIES} \\iff \\exists \\text{ 指派 } a \\text{ 使得 } a \\models \\phi_{1} \\text{ 并且 } a \\not\\models \\phi_{2}.\n$$\n因此，一个“否定”实例（即不属于该语言）的自然证书就是这样一个指派 $a$。\n\n为了在多项式时间内验证这个证书，验证者以 $\\langle \\phi_{1}, \\phi_{2} \\rangle$（两个都是 3-CNF 公式）和指派 $a$ 作为输入。验证者通过以下步骤在指派 $a$ 下对 $\\phi_{1}$ 和 $\\phi_{2}$ 求值：\n- 对每个公式中的每个子句，检查其三个文字中是否至少有一个被 $a$ 设为真；每个子句的耗时为 $O(1)$。\n- 对所有子句的结果进行合取，以确定整个公式的真值，这需要与公式大小成线性关系的时间。\n因此，总验证时间是输入大小 $|\\langle \\phi_{1}, \\phi_{2} \\rangle|$ 的多项式，并且证书 $a$ 的大小是变量数量的多项式，因此也是输入大小的多项式。这表明 CNF_IMPLIES 的补集属于 NP，因此 CNF_IMPLIES 属于 $\\text{coNP}$。\n\n现在评估各个选项：\n- A 精确地陈述了上述论证：一个“否定”实例由一个满足 $\\phi_{1}$ 但不满足 $\\phi_{2}$ 的指派来认证，并且这可以在多项式时间内验证。这正确定位了 CNF_IMPLIES 属于 $\\text{coNP}$。\n- B 是不正确的：一个满足 $\\phi_{2}$ 同时也满足 $\\phi_{1}$ 的指派并不能证明所有满足 $\\phi_{1}$ 的指派都满足 $\\phi_{2}$。\n- C 是不正确的：$\\text{coNP}$ 不是由指数时间的确定性检查来定义的；那种定义涉及的是像 $\\text{EXP}$ 这样的时间复杂性类，而不是 $\\text{coNP}$。\n- D 在两点上是错误的：它使用了 $\\phi_{1} \\land \\phi_{2}$ 而不是逻辑上相关的 $\\phi_{1} \\land \\lnot \\phi_{2}$，并且它错误地识别了不可满足性将证明哪一方（“肯定”或“否定”）。事实上，$\\phi_{1} \\implies \\phi_{2}$ 成立当且仅当 $\\phi_{1} \\land \\lnot \\phi_{2}$ 是不可满足的，所以这里的不可满足性将证明一个“肯定”实例，而不是一个“否定”实例。\n- E 的陈述不充分：仅仅指出 $\\phi_{2}$ 的一个子句而不提供一个明确的指派，并不构成一个可验证的证书。除非提供了见证指派，否则验证者无法在多项式时间内确认该子句可以在满足所有 $\\phi_{1}$ 的同时为假。\n\n因此，只有 A 为将 CNF_IMPLIES 归入 $\\text{coNP}$ 提供了有效的论据。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "归约是计算复杂性理论的基石，它允许我们在不同问题之间建立联系。本练习将展示一个经典的归约过程：如何将图同构问题的“反问题”——图非同构问题（一个著名的 $\\text{coNP}$ 问题）——转化为布尔不可满足性问题（$\\text{UNSAT}$）。通过构建一个特定的布尔公式，你将学会如何用逻辑语言来编码图的结构属性。",
            "id": "1417149",
            "problem": "一名计算复杂性课程的学生被赋予设计一个验证系统的任务。该系统需要确定两个给定的简单无向图是否 *非* 同构。该学生可以使用一个强大的计算预言机，该预言机可以在一个时间步内解决不可满足性（UNSAT）问题。UNSAT 问题接受一个布尔公式作为输入，如果没有一组变量的真值赋值能使该公式为真，则返回 `true`，否则返回 `false`。\n\n该学生的任务是创建一个多项式时间算法，该算法接收两个图 $G_1 = (V_1, E_1)$ 和 $G_2 = (V_2, E_2)$，并生成一个单一的布尔公式 $\\Phi$。然后，这个公式 $\\Phi$ 将被输入到 UNSAT 预言机中。如果预言机对 $\\Phi$ 的输出直接对应于 $G_1$ 和 $G_2$ 是否非同构，那么整个系统就正确地解决了图非同构问题。\n\n为简单起见，假设两个图具有相同数量的顶点，即 $|V_1| = |V_2| = n$，并且它们的顶点集都被标记为 $V = \\{1, 2, \\dots, n\\}$。该学生决定对所有 $i, j \\in \\{1, \\dots, n\\}$ 使用布尔变量 $x_{i,j}$，其中 $x_{i,j}$ 为 `true` 的预期含义是 $G_1$ 的顶点 $i$ 映射到 $G_2$ 的顶点 $j$。\n\n以下哪种构造布尔公式 $\\Phi$ 的方案是正确的？\n\nA. $\\Phi$ 是三类子句的合取：\n1. 对于每个 $i \\in V$，子句 $(\\bigvee_{j=1}^{n} x_{i,j})$ 确保 $G_1$ 中的每个顶点至少映射到 $G_2$ 中的一个顶点。\n2. 对于每个 $j \\in V$，子句 $(\\bigvee_{i=1}^{n} x_{i,j})$ 确保 $G_2$ 中的每个顶点都由 $G_1$ 中至少一个顶点映射而来。\n3. 对于所有不同的顶点对 $i, k \\in V_1$ 和所有不同的顶点对 $j, l \\in V_2$，一个子句表示如果 $x_{i,j}$ 和 $x_{k,l}$ 为真，那么 $i,k$ 在 $G_1$ 中的邻接关系必须与 $j,l$ 在 $G_2$ 中的邻接关系相匹配。该子句为 $(\\neg x_{i,j} \\lor \\neg x_{k,l} \\lor ((i,k) \\in E_1 \\leftrightarrow (j,l) \\in E_2))$。\n\nB. $\\Phi$ 是两类子句的合取：\n1. 确保由变量 $x_{i,j}$ 定义的映射是一个有效的排列（即，$G_1$ 中的每个顶点恰好映射到 $G_2$ 中的一个顶点，并且 $G_2$ 中的每个顶点都恰好是 $G_1$ 中一个顶点的像）的子句。\n2. 对于每一对顶点 $i, k \\in V_1$ 且满足 $(i,k) \\in E_1$，以及对于所有顶点对 $j, l \\in V_2$，子句为 $(\\neg x_{i,j} \\lor \\neg x_{k,l} \\lor ((j,l) \\in E_2))$。这确保了边映射到边。\n\nC. $\\Phi$ 是两类子句的合取：\n1. 确保由变量 $x_{i,j}$ 定义的映射是一个有效的排列（即，$G_1$ 中的每个顶点恰好映射到 $G_2$ 中的一个顶点，并且 $G_2$ 中的每个顶点都恰好是 $G_1$ 中一个顶点的像）的子句。\n2. 对于所有不同的顶点对 $i, k \\in V_1$ 和所有不同的顶点对 $j, l \\in V_2$，一个子句表示如果 $x_{i,j}$ 和 $x_{k,l}$ 为真，那么 $i,k$ 在 $G_1$ 中的邻接关系必须与 $j,l$ 在 $G_2$ 中的邻接关系相匹配。该子句为 $(\\neg x_{i,j} \\lor \\neg x_{k,l} \\lor ((i,k) \\in E_1 \\leftrightarrow (j,l) \\in E_2))$。\n\nD. $\\Phi$ 是一个子句的合取，它当且仅当对于任意顶点排列，都至少存在一对顶点的邻接关系不被保持时才被满足。\n\nE. $\\Phi$ 是一个检查边数是否不同的单一子句：$(|E_1| \\neq |E_2|)$。如果边数相同，则 $\\Phi$ 是一个恒为假的公式。",
            "solution": "问题要求我们找到一种从两个图 $G_1$ 和 $G_2$ 构造布尔公式 $\\Phi$ 的正确方法，使得 $\\Phi$ 不可满足当且仅当 $G_1$ 和 $G_2$ 非同构。这是计算复杂性理论中一个经典的归约例子。图非同构问题（GRAPH NON-ISOMORPHISM）属于复杂性类 $\\text{coNP}$。要使用像 $\\text{UNSAT}$ 这样的 $\\text{coNP}$-完全预言机来解决它，我们必须进行多项式时间归约。这意味着我们需要找到一种方法，将图非同构问题的一个实例转换为 $\\text{UNSAT}$ 问题的一个实例。\n\n核心思想是反转条件。我们将构造一个公式 $\\Phi$，它*可满足*当且仅当这两个图*是*同构的。如果存在这样一个可满足的赋值，它就代表了同构本身。因此，如果该公式没有可满足的赋值（即，它是不可满足的），就意味着不存在同构关系，因此这两个图是非同构的。\n\n让我们分析一下构造这样一个公式 $\\Phi$ 的要求。变量 $x_{i,j}$ 表示从 $G_1$ 的顶点到 $G_2$ 的顶点的映射。为了使这个映射成为一个同构，它必须满足两个条件：\n1.  该映射必须是一个双射（一个排列）。\n2.  该映射必须保持邻接和非邻接关系。\n\n让我们根据这些要求来评估每个选项。\n\n**条件 1：映射必须是一个排列。**\n排列是一个双射，意味着它既是单射（injective）又是满射（surjective）。对于由变量 $x_{i,j}$ 定义的映射：\n- **单射（injective）：** $G_1$ 中的每个顶点 $i$ 映射到 $V_2$ 中一个唯一的顶点。同时，$G_1$ 中没有两个顶点映射到 $V_2$ 中同一个顶点。\n- **满射（surjective）：** $V_2$ 中的每个顶点都被 $V_1$ 中的某个顶点映射到。\n由于顶点集的大小相等且有限，单射性等价于满射性，反之亦然。\n\n这些条件可以用布尔子句来表示：\n- 对于每个 $i \\in V_1$，它必须至少映射到一个 $j \\in V_2$：$\\bigvee_{j=1}^{n} x_{i,j}$。\n- 对于每个 $i \\in V_1$，它最多只能映射到一个 $j \\in V_2$：$\\bigwedge_{1 \\le j  k \\le n} (\\neg x_{i,j} \\lor \\neg x_{i,k})$。\n- 对于每个 $j \\in V_2$，它必须由至少一个 $i \\in V_1$ 映射而来：$\\bigvee_{i=1}^{n} x_{i,j}$。\n- 对于每个 $j \\in V_2$，它最多只能由一个 $i \\in V_1$ 映射而来：$\\bigwedge_{1 \\le i  k \\le n} (\\neg x_{k,j} \\lor \\neg x_{i,j})$。\n\n所有这些子句的合取正确地强制映射为一个排列。选项 C 正确地将这组子句称为“确保由变量 $x_{i,j}$ 定义的映射是一个有效的排列”的子句。选项 B 也是如此。然而，选项 A 是不完整的。它只确保了“至少一个”的条件，这允许一个顶点映射到多个顶点，也允许多个顶点映射到一个顶点。这描述的是一个关系，而不是一个函数，更不用说是一个排列了。因此，选项 A 是不正确的。\n\n**条件 2：映射必须保持结构。**\n这意味着对于 $G_1$ 中的任意两个顶点 $i, k$，它们之间有边相连当且仅当它们在 $G_2$ 中对应的像之间有边相连。设映射为 $\\pi$。条件是：$(i,k) \\in E_1 \\iff (\\pi(i), \\pi(k)) \\in E_2$。\n用我们的变量来说，如果 $x_{i,j}$ 为真且 $x_{k,l}$ 为真，这意味着 $\\pi(i)=j$ 且 $\\pi(k)=l$。所以对于所有这样的赋值，我们必须强制要求 $(i,k) \\in E_1 \\iff (j,l) \\in E_2$。这必须对 $G_1$ 中的每一对顶点及其在 $G_2$ 中的像都成立。\n这可以转化为逻辑语句：\n对于所有 $i, k \\in V_1$ 和 $j, l \\in V_2$：$(x_{i,j} \\land x_{k,l}) \\implies ((i,k) \\in E_1 \\iff (j,l) \\in E_2)$。\n使用等价式 $P \\implies Q \\equiv \\neg P \\lor Q$，它变为：\n$\\neg (x_{i,j} \\land x_{k,l}) \\lor ((i,k) \\in E_1 \\iff (j,l) \\in E_2)$，即\n$\\neg x_{i,j} \\lor \\neg x_{k,l} \\lor ((i,k) \\in E_1 \\iff (j,l) \\in E_2)$。\n对于任何给定的图和索引，项 $((i,k) \\in E_1 \\iff (j,l) \\in E_2)$ 是一个常量（其值为真或假）。这个子句正确地捕捉了完整的结构保持要求。\n\n现在我们重新评估各个选项：\n- **选项 A：** 未能满足排列约束。它是不正确的。\n- **选项 B：** 它的结构保持子句是 $(\\neg x_{i,j} \\lor \\neg x_{k,l} \\lor ((j,l) \\in E_2))$。这是从 $(x_{i,j} \\land x_{k,l}) \\implies ((j,l) \\in E_2)$ 推导出来的。它仅对 $(i,k) \\in E_1$ 的顶点对强制执行。这意味着它强制 $G_1$ 中的边必须映射到 $G_2$ 中的边，但没有强制另一个方向：即 $G_1$ 中的非边必须映射到 $G_2$ 中的非边。这个公式检查的是子图同构（或者更准确地说，是同态），而不是完全同构。因此，选项 B 是不正确的。\n- **选项 C：** 这个选项将正确且完整的排列子句集与正确且完整的结构保持子句集结合起来。这两组子句的合取的一个满足赋值，恰好对应于 $G_1$ 和 $G_2$ 之间的一个有效同构。因此，该公式可满足当且仅当两个图是同构的。这意味着该公式不可满足当且仅当两个图*非*同构，这正是问题所要求的。选项 C 是正确的。\n- **选项 D：** 这描述了一个在图非同构时为真的公式。其逻辑结构是“对于所有排列 $\\pi$，存在一对顶点 $(i,k)$ 使得 $(i,k) \\in E_1 \\not\\leftrightarrow (\\pi(i),\\pi(k)) \\in E_2$”。这种 $\\forall \\exists$ 结构对应于复杂性类 $\\Pi_2^p$，而不是 $\\text{coNP}$ ($\\Pi_1^p$)。无法用一个简单的（多项式大小的）命题公式来表达它，并将其输入 SAT/UNSAT 求解器。因此，选项 D 是不正确的。\n- **选项 E：** 检查边数是否相等是同构的一个必要但不充分条件。两个非同构的图可以有相同数量的顶点和边。这是一个简单的检查，未能捕捉到同构问题的复杂性。因此，选项 E 是不正确的。\n\n根据分析，只有选项 C 提供了一种构造 $\\Phi$ 的方法，该方法正确地将图同构问题（GRAPH ISOMORPHISM）归约到可满足性问题（SATISFIABILITY）。",
            "answer": "$$\\boxed{C}$$"
        },
        {
            "introduction": "多项式时间层级通过交替使用存在（$\\exists$）和任意（$\\forall$）量词来定义更高的复杂性层次。$\\Sigma_2^p$ 类中的问题通常具有“$\\exists\\forall$”的结构，可以直观地理解为一个两步游戏。本练习通过一个在图上进行的“支配集规避游戏”，让你亲身体验这种结构，并判断在哪些具体场景下，玩家一存在必胜策略 。",
            "id": "1417140",
            "problem": "在图论中，一个图 $G=(V, E)$ 的**支配集** (dominating set) 是一个顶点子集 $S \\subseteq V$，使得每个不在 $S$ 中的顶点都与 $S$ 中至少一个顶点相邻。\n\n考虑以下在给定图 $G=(V,E)$ 和两个指定的正整数 $k$ 和 $l$ 上进行的双人博弈，称为**支配集逃脱博弈** (Dominating Set Evasion Game)。\n\n1.  **玩家1（逃脱者）**选择一个顶点集 $U \\subseteq V$，使得 $|U|=k$。\n2.  **玩家2（支配者）**接着选择一个顶点集 $D \\subseteq V \\setminus U$，使得 $|D|=l$。\n3.  如果组合集 $S = U \\cup D$ **不是** $G$ 的支配集，则逃脱者获胜。否则，支配者获胜。\n\n如果逃脱者有获胜策略，则给定的实例 $(G, k, l)$ 被定义为语言 `EVADER_WINS` 的一个成员。也就是说，如果存在一个集合 $U$（大小为 $k$），逃脱者可以选择它，使得对于支配者**每一种**可能的集合 $D$（大小为 $l$）的选择，集合 $U \\cup D$ 都不是一个支配集。\n\n给定以下四个实例，哪一个是 `EVADER_WINS` 的成员？\n\nA. $G_A$ 是一个星形图，其顶点集为 $V_A = \\{c, s_1, s_2, s_3\\}$，边集为 $E_A = \\{(c, s_1), (c, s_2), (c, s_3)\\}$。参数为 $k=1, l=1$。\n\nB. $G_B$ 是一个由三条各有3个顶点的路径的不交并组成的图。其顶点集为 $V_B = \\{a_1, a_2, a_3, b_1, b_2, b_3, c_1, c_2, c_3\\}$，边集为 $E_B = \\{(a_1,a_2), (a_2,a_3), (b_1,b_2), (b_2,b_3), (c_1,c_2), (c_2,c_3)\\}$。参数为 $k=1, l=1$。\n\nC. $G_C$ 是一个5个顶点的完全图 $K_5$。参数为 $k=1, l=1$。\n\nD. $G_D$ 是一个6个顶点的圈图 $C_6$。参数为 $k=1, l=1$。",
            "solution": "根据定义，如果图 $G=(V,E)$ 中 $V \\setminus S$ 中的每个顶点在 $S$ 中都至少有一个邻居，则集合 $S \\subseteq V$ 是一个支配集。在 $k=1$ 和 $l=1$ 的博弈中，逃脱者选择 $U=\\{u\\}$，然后支配者选择 $D=\\{v\\} \\subseteq V \\setminus \\{u\\}$。逃脱者获胜的充要条件是，存在一个 $u \\in V$，使得对于每一个 $v \\in V \\setminus \\{u\\}$，集合 $\\{u,v\\}$ 都不是一个支配集。\n\n实例 A：$G_{A}$ 是一个有四个顶点的星形图，中心为 $c$，叶节点为 $s_{1},s_{2},s_{3}$。如果逃脱者选择 $u=c$，那么 $S=\\{c,v\\}$ 包含 $c$，并且由于 $c$ 与所有叶节点相邻，对于任何 $v$，$S$ 都能支配 $V$，所以支配者获胜。如果逃脱者选择一个叶节点，比如说 $u=s_{1}$，那么支配者可以选择 $v=c$，而 $S=\\{s_{1},c\\}$ 是支配集，因为 $c$ 支配了所有叶节点。因此，对于每一个 $u$，都存在一个 $v$ 使得 $\\{u,v\\}$ 是支配集，所以逃脱者没有获胜策略。因此实例 A 不是 `EVADER_WINS` 的成员。\n\n实例 B：$G_{B}$ 是三条各有三个顶点的路径的不交并。在任何图的不交并中，一个支配集必须与每个连通分量相交，因为一个分量中的顶点在另一个分量中没有邻居。因此，$G_{B}$ 中的任何支配集的大小必须至少等于连通分量的数量，即 $3$。这里 $|S|=|U \\cup D|=2$，所以无论 $U$ 和 $D$ 如何选择，$S$ 都不能成为支配集。特别地，存在一个 $U$（实际上是任何 $U$），使得对于所有的 $D$，$U \\cup D$ 都不是支配集。因此实例 B 是 `EVADER_WINS` 的成员。\n\n实例 C：$G_{C}=K_{5}$。在完全图中，任何单个顶点 $u$ 都与所有其他顶点相邻，所以 $\\{u\\}$ 本身就已经支配了 $V$。因此，对于任何 $u$ 和任何 $v \\neq u$，集合 $\\{u,v\\}$ 都是支配集。因此，支配者总是获胜，实例 C 不是 `EVADER_WINS` 的成员。\n\n实例 D：$G_{D}=C_{6}$。将顶点用模 $6$ 的整数标记。对于逃脱者选择的任何 $u=i$，支配者可以选择 $v=i+3$（与 $u$ 的图距离为 $3$ 的顶点）。那么它们的闭邻域满足 $N[u]=\\{i-1,i,i+1\\}$ 和 $N[v]=\\{i+2,i+3,i+4\\}$，因此 $N[u] \\cup N[v]=V$。所以 $\\{u,v\\}$ 是一个支配集。因此，对于每一个 $u$，都存在一个 $v$ 使得 $\\{u,v\\}$ 是支配集，所以逃脱者没有获胜策略。因此实例 D 不是 `EVADER_WINS` 的成员。\n\n因此，在给定的实例中，只有 B 是 `EVADER_WINS` 的成员。",
            "answer": "$$\\boxed{B}$$"
        }
    ]
}