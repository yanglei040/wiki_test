{
    "hands_on_practices": [
        {
            "introduction": "This first exercise goes to the heart of the complexity class $\\text{coNP}$. To show a problem belongs to $\\text{coNP}$, we must demonstrate that a 'no' answer can be verified efficiently given a simple proof, or 'certificate'. This problem  asks you to apply this core definition to a fundamental problem in logic: determining if one Boolean formula logically implies another.",
            "id": "1417117",
            "problem": "In computational complexity theory, problems are classified based on the resources required to solve them. The class **coNP** contains decision problems for which a 'no' answer can be verified efficiently, given a suitable certificate.\n\nConsider the logical implication problem between two Boolean formulas. We define a language `CNF_IMPLIES` as follows. An input to the problem is a pair of Boolean formulas, $\\langle \\phi_1, \\phi_2 \\rangle$, both of which are given in 3-Conjunctive Normal Form (3-CNF). A formula is in 3-CNF if it is a conjunction (AND) of clauses, where each clause is a disjunction (OR) of exactly three literals. A literal is either a variable or its negation.\n\nThe pair $\\langle \\phi_1, \\phi_2 \\rangle$ is in the language `CNF_IMPLIES` if and only if every truth assignment that satisfies $\\phi_1$ also satisfies $\\phi_2$. In other words, $\\phi_1$ logically implies $\\phi_2$.\n\nWhich of the following statements provides a valid argument for placing the `CNF_IMPLIES` language in the complexity class **coNP**?\n\nA. A 'no' instance (where $\\phi_1$ does not imply $\\phi_2$) can be verified in polynomial time. The certificate for this is a truth assignment to the variables. A verifier can use this assignment to check in polynomial time whether it satisfies $\\phi_1$ but falsifies $\\phi_2$.\n\nB. A 'yes' instance (where $\\phi_1$ implies $\\phi_2$) can be verified in polynomial time. The certificate is a satisfying assignment for $\\phi_2$. The verifier's job is to confirm that this assignment also satisfies $\\phi_1$.\n\nC. The problem is in **coNP** because a deterministic algorithm can check every possible truth assignment for the variables. Since there are exponentially many assignments, this check takes exponential time, which is the characteristic of problems in **coNP**.\n\nD. A 'no' instance can be verified in polynomial time. This is done by checking if the formula $\\phi_1 \\land \\phi_2$ is unsatisfiable. Since deciding the unsatisfiability of a 3-CNF formula is a known **coNP** problem, this places `CNF_IMPLIES` in **coNP**.\n\nE. A 'no' instance can be verified in polynomial time. The certificate is one of the clauses from $\\phi_2$. The verifier's task is to check if this clause can be made false while simultaneously satisfying all of $\\phi_1$.",
            "solution": "We recall the definition of coNP: a language $L$ is in coNP if and only if its complement $\\overline{L}$ is in NP, which is equivalently phrased as follows: there exists a polynomial-time verifier that, given an input $x$, accepts $x \\notin L$ whenever there exists a polynomial-size certificate $y$ such that the verifier runs in time polynomial in $|x|$ and accepts $(x,y)$.\n\nThe language in question is\n$$\n\\text{CNF\\_IMPLIES} = \\{ \\langle \\phi_{1}, \\phi_{2} \\rangle \\mid \\text{every assignment that satisfies } \\phi_{1} \\text{ also satisfies } \\phi_{2} \\}.\n$$\nBy logic, $\\phi_{1}$ implies $\\phi_{2}$ if and only if $\\phi_{1} \\land \\lnot \\phi_{2}$ is unsatisfiable. Equivalently,\n$$\n\\langle \\phi_{1}, \\phi_{2} \\rangle \\notin \\text{CNF\\_IMPLIES} \\iff \\exists \\text{ assignment } a \\text{ such that } a \\models \\phi_{1} \\text{ and } a \\not\\models \\phi_{2}.\n$$\nThus, a natural certificate for a 'no' instance (i.e., non-membership) is precisely such an assignment $a$.\n\nTo verify this certificate in polynomial time, a verifier takes as input $\\langle \\phi_{1}, \\phi_{2} \\rangle$ (both 3-CNF formulas) and the assignment $a$. The verifier evaluates $\\phi_{1}$ and $\\phi_{2}$ under $a$ by:\n- For each clause in each formula, check whether at least one of its three literals is set to true by $a$; this is $O(1)$ per clause.\n- Conjoin over all clauses to determine the truth of the whole formula, which takes time linear in the formula size.\nTherefore, the total verification time is polynomial in the input size $|\\langle \\phi_{1}, \\phi_{2} \\rangle|$, and the certificate $a$ is of size polynomial in the number of variables, hence polynomial in the input size. This shows that the complement of CNF_IMPLIES is in NP, and hence CNF_IMPLIES is in coNP.\n\nNow evaluate the options:\n- A precisely states the above argument: a 'no' instance is certified by an assignment that satisfies $\\phi_{1}$ and falsifies $\\phi_{2}$, and this can be verified in polynomial time. This correctly places CNF_IMPLIES in coNP.\n- B is incorrect: a satisfying assignment for $\\phi_{2}$ that also satisfies $\\phi_{1}$ does not certify that every assignment satisfying $\\phi_{1}$ satisfies $\\phi_{2}$.\n- C is incorrect: coNP is not defined by exponential-time deterministic checking; that concerns time complexity classes like EXP, not coNP.\n- D is incorrect on two counts: it uses $\\phi_{1} \\land \\phi_{2}$ instead of the logically relevant $\\phi_{1} \\land \\lnot \\phi_{2}$, and it misidentifies which side ('yes' or 'no') unsatisfiability would certify. In fact, $\\phi_{1} \\implies \\phi_{2}$ holds if and only if $\\phi_{1} \\land \\lnot \\phi_{2}$ is unsatisfiable, so unsatisfiability there would certify a 'yes' instance, not a 'no' instance.\n- E is insufficient as stated: naming a single clause of $\\phi_{2}$ without providing an explicit assignment does not constitute a verifiable certificate. The verifier cannot in polynomial time confirm existentially that the clause can be falsified while satisfying all of $\\phi_{1}$ unless the witnessing assignment is provided.\n\nTherefore, only A provides a valid argument for placing CNF_IMPLIES in coNP.",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "Once we understand a complexity class, we can leverage its complete problems as powerful computational tools. This next practice  demonstrates how to solve one problem by transforming, or \"reducing,\" it into another. You will construct a Boolean formula that is unsatisfiable if and only if two graphs are non-isomorphic, illustrating the practical power of reducing a problem to a known $\\text{coNP}$-complete problem like UNSAT.",
            "id": "1417149",
            "problem": "A student in a computational complexity course is tasked with designing a verification system. The system needs to determine if two given simple, undirected graphs are *not* isomorphic. The student has access to a powerful computational oracle that can solve the UNSATISFIABILITY (UNSAT) problem in a single time step. The UNSAT problem takes a Boolean formula as input and returns `true` if there is no assignment of truth values to its variables that makes the formula true, and `false` otherwise.\n\nThe student's task is to create a polynomial-time algorithm that takes two graphs, $G_1 = (V_1, E_1)$ and $G_2 = (V_2, E_2)$, and produces a single Boolean formula $\\Phi$. This formula $\\Phi$ will then be fed to the UNSAT oracle. The entire system correctly solves the graph non-isomorphism problem if the oracle's output for $\\Phi$ directly corresponds to whether $G_1$ and $G_2$ are non-isomorphic.\n\nAssume for simplicity that both graphs have the same number of vertices, $|V_1| = |V_2| = n$, and their vertex sets are both labeled as $V = \\{1, 2, \\dots, n\\}$. The student decides to use Boolean variables $x_{i,j}$ for all $i, j \\in \\{1, \\dots, n\\}$, where the intended meaning of $x_{i,j}$ being `true` is that vertex $i$ of $G_1$ is mapped to vertex $j$ of $G_2$.\n\nWhich of the following proposals for constructing the Boolean formula $\\Phi$ is correct?\n\nA. $\\Phi$ is a conjunction of three types of clauses:\n1. For each $i \\in V$, the clause $(\\bigvee_{j=1}^{n} x_{i,j})$ to ensure every vertex in $G_1$ maps to at least one vertex in $G_2$.\n2. For each $j \\in V$, the clause $(\\bigvee_{i=1}^{n} x_{i,j})$ to ensure every vertex in $G_2$ is mapped to by at least one from $G_1$.\n3. For all distinct pairs of vertices $i, k \\in V_1$ and all distinct pairs $j, l \\in V_2$, a clause expressing that if $x_{i,j}$ and $x_{k,l}$ are true, then the adjacency of $i,k$ in $G_1$ must match the adjacency of $j,l$ in $G_2$. This is the clause $(\\neg x_{i,j} \\lor \\neg x_{k,l} \\lor ((i,k) \\in E_1 \\leftrightarrow (j,l) \\in E_2))$.\n\nB. $\\Phi$ is a conjunction of two types of clauses:\n1. Clauses ensuring that the mapping defined by the $x_{i,j}$ variables is a valid permutation (i.e., each vertex from $G_1$ maps to exactly one vertex in $G_2$, and each vertex in $G_2$ is the image of exactly one vertex from $G_1$).\n2. For every pair of vertices $i, k \\in V_1$ such that $(i,k) \\in E_1$, and for all pairs $j, l \\in V_2$, the clause $(\\neg x_{i,j} \\lor \\neg x_{k,l} \\lor ((j,l) \\in E_2))$. This ensures that edges are mapped to edges.\n\nC. $\\Phi$ is a conjunction of two types of clauses:\n1. Clauses ensuring that the mapping defined by the $x_{i,j}$ variables is a valid permutation (i.e., each vertex from $G_1$ maps to exactly one vertex in $G_2$, and each vertex in $G_2$ is the image of exactly one vertex from $G_1$).\n2. For all distinct pairs of vertices $i, k \\in V_1$ and all distinct pairs $j, l \\in V_2$, a clause expressing that if $x_{i,j}$ and $x_{k,l}$ are true, then the adjacency of $i,k$ in $G_1$ must match the adjacency of $j,l$ in $G_2$. This is the clause $(\\neg x_{i,j} \\lor \\neg x_{k,l} \\lor ((i,k) \\in E_1 \\leftrightarrow (j,l) \\in E_2))$.\n\nD. $\\Phi$ is a conjunction of clauses that is satisfied if and only if for any permutation of the vertices, there is at least one pair of vertices whose adjacency is not preserved.\n\nE. $\\Phi$ is a single clause checking if the number of edges is different: $(|E_1| \\neq |E_2|)$. If the number of edges is the same, $\\Phi$ is a formula that is always false.",
            "solution": "The problem asks for a correct way to construct a Boolean formula $\\Phi$ from two graphs $G_1$ and $G_2$, such that $\\Phi$ is unsatisfiable if and only if $G_1$ and $G_2$ are not isomorphic. This is a classic example of a reduction in complexity theory. The problem GRAPH NON-ISOMORPHISM is in the complexity class co-NP. To solve it using a co-NP-complete oracle like UNSAT, we must perform a polynomial-time reduction. This means we need to find a way to transform an instance of GRAPH NON-ISOMORPHISM into an instance of UNSAT.\n\nThe core idea is to reverse the condition. We will construct a formula $\\Phi$ that is *satisfiable* if and only if the graphs *are* isomorphic. If such a satisfying assignment exists, it represents the isomorphism itself. Consequently, if the formula has no satisfying assignment (i.e., it is unsatisfiable), it means no isomorphism exists, and the graphs are therefore not isomorphic.\n\nLet's analyze the requirements for such a formula $\\Phi$. The variables $x_{i,j}$ represent a mapping from the vertices of $G_1$ to the vertices of $G_2$. For this mapping to be an isomorphism, it must satisfy two conditions:\n1.  The mapping must be a bijection (a permutation).\n2.  The mapping must preserve adjacency and non-adjacency.\n\nLet's evaluate each option based on these requirements.\n\n**Condition 1: The mapping must be a permutation.**\nA permutation is a bijection, meaning it is both one-to-one (injective) and onto (surjective). For the mapping defined by the $x_{i,j}$ variables:\n- **One-to-one (injective):** Each vertex $i \\in V_1$ maps to a unique vertex in $V_2$. Also, no two vertices in $V_1$ map to the same vertex in $V_2$.\n- **Onto (surjective):** Every vertex in $V_2$ is mapped to by some vertex in $V_1$.\nSince the vertex sets are of equal finite size, injectivity implies surjectivity and vice-versa.\n\nThese conditions can be expressed with Boolean clauses:\n- For each $i \\in V_1$, it must map to at least one $j \\in V_2$: $\\bigvee_{j=1}^{n} x_{i,j}$.\n- For each $i \\in V_1$, it must map to at most one $j \\in V_2$: $\\bigwedge_{1 \\le j  k \\le n} (\\neg x_{i,j} \\lor \\neg x_{i,k})$.\n- For each $j \\in V_2$, it must be mapped to by at least one $i \\in V_1$: $\\bigvee_{i=1}^{n} x_{i,j}$.\n- For each $j \\in V_2$, it must be mapped to by at most one $i \\in V_1$: $\\bigwedge_{1 \\le i  k \\le n} (\\neg x_{k,j} \\lor \\neg x_{i,j})$.\n\nA conjunction of all these clauses correctly enforces that the mapping is a permutation. Option C refers to this set of clauses correctly as \"clauses ensuring that the mapping defined by the $x_{i,j}$ variables is a valid permutation\". Option B does the same. Option A, however, is incomplete. It only ensures the \"at least one\" conditions, which allows one vertex to map to many, and many vertices to map to one. This describes a relation, not a function, let alone a permutation. Therefore, option A is incorrect.\n\n**Condition 2: The mapping must preserve structure.**\nThis means that for any two vertices $i, k$ in $G_1$, they are connected by an edge if and only if their corresponding images in $G_2$ are connected by an edge. Let the mapping be $\\pi$. The condition is: $(i,k) \\in E_1 \\iff (\\pi(i), \\pi(k)) \\in E_2$.\nIn terms of our variables, if $x_{i,j}$ is true and $x_{k,l}$ is true, this means $\\pi(i)=j$ and $\\pi(k)=l$. So for all such assignments, we must enforce that $(i,k) \\in E_1 \\iff (j,l) \\in E_2$. This must hold for every pair of vertices from $G_1$ and their images in $G_2$.\nThis translates to the logical statement:\nFor all $i, k \\in V_1$ and $j, l \\in V_2$: $(x_{i,j} \\land x_{k,l}) \\implies ((i,k) \\in E_1 \\iff (j,l) \\in E_2)$.\nUsing the equivalence $P \\implies Q \\equiv \\neg P \\lor Q$, this becomes:\n$\\neg (x_{i,j} \\land x_{k,l}) \\lor ((i,k) \\in E_1 \\iff (j,l) \\in E_2)$, which is\n$\\neg x_{i,j} \\lor \\neg x_{k,l} \\lor ((i,k) \\in E_1 \\iff (j,l) \\in E_2)$.\nThe term $((i,k) \\in E_1 \\iff (j,l) \\in E_2)$ is a constant (evaluates to true or false) for any given graphs and indices. This clause correctly captures the full structure preservation requirement.\n\nNow let's re-evaluate the options:\n- **Option A:** Fails on the permutation constraint. It is incorrect.\n- **Option B:** Its structure preservation clause is $(\\neg x_{i,j} \\lor \\neg x_{k,l} \\lor ((j,l) \\in E_2))$. This is derived from $(x_{i,j} \\land x_{k,l}) \\implies ((j,l) \\in E_2)$. It is only enforced for pairs $(i,k) \\in E_1$. This means it enforces that edges in $G_1$ must map to edges in $G_2$, but it does not enforce the other direction: that non-edges in $G_1$ must map to non-edges in $G_2$. This formula checks for subgraph isomorphism (or more precisely, a homomorphism), not full isomorphism. Thus, Option B is incorrect.\n- **Option C:** This option combines the correct and complete set of permutation clauses with the correct and complete set of structure-preservation clauses. A satisfying assignment for the conjunction of these two sets of clauses corresponds exactly to a valid isomorphism between $G_1$ and $G_2$. Therefore, the formula is satisfiable if and only if the graphs are isomorphic. This means the formula is unsatisfiable if and only if the graphs are *not* isomorphic, which is exactly what the problem requires. Option C is correct.\n- **Option D:** This describes a formula that would be true if the graphs are non-isomorphic. The logical structure for this is \"for all permutations $\\pi$, there exists a pair $(i,k)$ such that $(i,k) \\in E_1 \\not\\leftrightarrow (\\pi(i),\\pi(k)) \\in E_2$\". This $\\forall \\exists$ structure corresponds to the complexity class $\\Pi_2^P$, not co-NP ($\\Pi_1^P$). It is not possible to express this with a simple (polynomially-sized) propositional formula that we can feed to a SAT/UNSAT solver. Therefore, Option D is incorrect.\n- **Option E:** Checking for an equal number of edges is a necessary but not sufficient condition for isomorphism. Two non-isomorphic graphs can have the same number of vertices and edges. This is a trivial check and fails to capture the complexity of the isomorphism problem. Thus, Option E is incorrect.\n\nBased on the analysis, only Option C provides a construction for $\\Phi$ that correctly reduces GRAPH ISOMORPHISM to SATISFIABILITY.",
            "answer": "$$\\boxed{C}$$"
        },
        {
            "introduction": "The Polynomial Hierarchy extends beyond $\\text{NP}$ and $\\text{coNP}$ into levels defined by alternating quantifiers of existential ($\\exists$) and universal ($\\forall$) form. The class $\\Sigma_2^P$ captures problems with an 'exists-forall' logical structure, which can often be intuitively understood as a two-player game. This exercise  puts you in the role of a player in such a game, providing a hands-on feel for the strategic decision-making that characterizes problems at the second level of the hierarchy.",
            "id": "1417140",
            "problem": "In graph theory, a **dominating set** for a graph $G=(V, E)$ is a subset of vertices $S \\subseteq V$ such that every vertex not in $S$ is adjacent to at least one vertex in $S$.\n\nConsider the following two-player game, called the **Dominating Set Evasion Game**, played on a given graph $G=(V,E)$ with two specified positive integers, $k$ and $l$.\n\n1.  **Player 1 (the Evader)** chooses a set of vertices $U \\subseteq V$ such that $|U|=k$.\n2.  **Player 2 (the Dominator)** then chooses a set of vertices $D \\subseteq V \\setminus U$ such that $|D|=l$.\n3.  The Evader wins if the combined set $S = U \\cup D$ is **not** a dominating set for $G$. Otherwise, the Dominator wins.\n\nA given instance $(G, k, l)$ is defined to be a member of the language `EVADER_WINS` if the Evader has a winning strategy. That is, if there exists a set $U$ (of size $k$) that the Evader can choose such that for **every** possible choice of a set $D$ (of size $l$) by the Dominator, the set $U \\cup D$ is not a dominating set.\n\nGiven the four instances below, which one is a member of `EVADER_WINS`?\n\nA. $G_A$ is a star graph with vertex set $V_A = \\{c, s_1, s_2, s_3\\}$ and edge set $E_A = \\{(c, s_1), (c, s_2), (c, s_3)\\}$. The parameters are $k=1, l=1$.\n\nB. $G_B$ is a graph consisting of the disjoint union of three paths, each with 3 vertices. Its vertex set is $V_B = \\{a_1, a_2, a_3, b_1, b_2, b_3, c_1, c_2, c_3\\}$ and its edge set is $E_B = \\{(a_1,a_2), (a_2,a_3), (b_1,b_2), (b_2,b_3), (c_1,c_2), (c_2,c_3)\\}$. The parameters are $k=1, l=1$.\n\nC. $G_C$ is a complete graph on 5 vertices, $K_5$. The parameters are $k=1, l=1$.\n\nD. $G_D$ is a cycle graph on 6 vertices, $C_6$. The parameters are $k=1, l=1$.",
            "solution": "By definition, a set $S \\subseteq V$ is dominating in $G=(V,E)$ if every vertex in $V \\setminus S$ has at least one neighbor in $S$. In the game with $k=1$ and $l=1$, the Evader picks $U=\\{u\\}$ and then the Dominator picks $D=\\{v\\} \\subseteq V \\setminus \\{u\\}$. The Evader wins exactly if there exists $u \\in V$ such that for every $v \\in V \\setminus \\{u\\}$, the set $\\{u,v\\}$ is not a dominating set.\n\nInstance A: $G_{A}$ is a star on four vertices with center $c$ and leaves $s_{1},s_{2},s_{3}$. If the Evader chooses $u=c$, then $S=\\{c,v\\}$ contains $c$, and since $c$ is adjacent to all leaves, $S$ dominates $V$ for any $v$, so the Dominator wins. If the Evader chooses a leaf, say $u=s_{1}$, then the Dominator can choose $v=c$, and $S=\\{s_{1},c\\}$ is dominating because $c$ dominates all leaves. Thus for every $u$ there exists $v$ such that $\\{u,v\\}$ is dominating, so the Evader does not have a winning strategy. Hence A is not in $\\text{EVADER\\_WINS}$.\n\nInstance B: $G_{B}$ is the disjoint union of three copies of a path on three vertices. In any disjoint union of graphs, a dominating set must intersect every connected component, since vertices in one component have no neighbors in another component. Therefore any dominating set in $G_{B}$ must have size at least the number of components, which is $3$. Here $|S|=|U \\cup D|=2$, so $S$ cannot be a dominating set regardless of $U$ and $D$. In particular, there exists $U$ (indeed, every $U$) such that for all $D$, $U \\cup D$ is not dominating. Hence B is in $\\text{EVADER\\_WINS}$.\n\nInstance C: $G_{C}=K_{5}$. In a complete graph, any single vertex $u$ is adjacent to all other vertices, so $\\{u\\}$ already dominates $V$. Thus for any $u$ and any $v \\neq u$, the set $\\{u,v\\}$ is dominating. Therefore the Dominator always wins, and C is not in $\\text{EVADER\\_WINS}$.\n\nInstance D: $G_{D}=C_{6}$. Label the vertices by integers modulo $6$. For any Evader choice $u=i$, the Dominator can choose $v=i+3$ (the vertex at graph distance $3$ from $u$). Then the closed neighborhoods satisfy $N[u]=\\{i-1,i,i+1\\}$ and $N[v]=\\{i+2,i+3,i+4\\}$, and hence $N[u] \\cup N[v]=V$. Therefore $\\{u,v\\}$ is a dominating set. Consequently, for every $u$ there exists $v$ such that $\\{u,v\\}$ is dominating, so D is not in $\\text{EVADER\\_WINS}$.\n\nTherefore, among the given instances, only B is a member of $\\text{EVADER\\_WINS}$.",
            "answer": "$$\\boxed{B}$$"
        }
    ]
}