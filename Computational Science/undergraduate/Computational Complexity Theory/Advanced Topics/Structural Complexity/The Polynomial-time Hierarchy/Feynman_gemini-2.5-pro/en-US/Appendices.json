{
    "hands_on_practices": [
        {
            "introduction": "To understand a complex structure like the Polynomial-time Hierarchy, it is often best to start at the foundation. This first exercise grounds the most basic level of the hierarchy, $\\Sigma_0^p$, in a tangible and practical scenario: verifying a computer chip's logic circuit. By analyzing this problem, you'll see how the familiar class of problems solvable in polynomial time, $P$, forms the starting point for this entire tower of complexity classes. ",
            "id": "1461573",
            "problem": "In the field of integrated circuit design, a fundamental task is to verify that a designed logic circuit behaves as expected for a given set of inputs. We can model this task as a computational problem called `CHIP-VERIFY`.\n\nA Boolean circuit is described by a collection of gates. Each gate is of type AND, OR, or NOT. The circuit has a set of primary input nodes and a single designated output gate. The connections between gates and inputs are specified, forming a directed acyclic graph.\n\nThe `CHIP-VERIFY` problem is defined as follows: Given a complete description of a Boolean circuit and a specific assignment of Boolean values (0 or 1) to each of its primary input nodes, determine if the circuit's designated output gate evaluates to 1.\n\nIn computational complexity theory, the polynomial-time hierarchy (PH) is a hierarchy of complexity classes that generalizes the classes P, NP, and co-NP. For any integer $k \\ge 0$, the classes $\\Sigma_k^p$ and $\\Pi_k^p$ are defined. A language $L$ is in $\\Sigma_k^p$ if and only if there exists a polynomial-time Turing machine $V$ and a polynomial $q$ such that for any input $x$, we have:\n$$x \\in L \\iff \\exists y_1 \\forall y_2 \\dots Q_k y_k, \\ V(x, y_1, y_2, \\dots, y_k) = 1$$\nwhere each $y_i$ is a string of length at most $q(|x|)$, and the quantifier $Q_k$ is $\\exists$ if $k$ is odd and $\\forall$ if $k$ is even. A language is in $\\Pi_k^p$ if its complement is in $\\Sigma_k^p$. The base of the hierarchy is defined as $\\Sigma_0^p = \\Pi_0^p = P$, the class of problems solvable in polynomial time.\n\nBased on these definitions, what is the lowest complexity class in the polynomial-time hierarchy that is guaranteed to contain the `CHIP-VERIFY` problem?\n\nA. $\\Sigma_0^p$\n\nB. $\\Sigma_1^p$\n\nC. $\\Pi_1^p$\n\nD. $\\Sigma_2^p$\n\nE. The problem is not in the polynomial-time hierarchy.",
            "solution": "We are given a Boolean circuit composed of AND, OR, and NOT gates with a specified assignment to all primary inputs, and we are asked to determine whether the designated output gate evaluates to 1. This is exactly the decision version of the Circuit Value Problem (CVP).\n\nTo decide the output value, compute gate values in a topological order of the circuit's directed acyclic graph:\n1. Initialize the value of each primary input to the given assignment.\n2. For each gate in topological order, compute its Boolean value from the values of its predecessors according to its type (AND, OR, NOT).\n3. Output the value computed at the designated output gate and accept if and only if it is 1.\n\nA topological ordering exists because the circuit graph is acyclic. Each gate is processed once, and each edge is examined a constant number of times, so the running time is linear in the size of the circuit description, hence polynomial in the input length. Therefore, CHIP-VERIFY is solvable in polynomial time, i.e., CHIP-VERIFY is in $P$.\n\nBy the definition of the polynomial-time hierarchy, the base level is $P = \\Sigma_{0}^{p} = \\Pi_{0}^{p}$. Since CHIP-VERIFY is in $P$, the lowest class in the hierarchy that is guaranteed to contain it is $\\Sigma_{0}^{p}$.\n\nTherefore, among the options, the correct choice is A.",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "The power of the Polynomial-time Hierarchy lies in its layered structure, where each new level gains computational power by using the previous level as a \"subroutine\" or oracle. This practice dives into the core mechanism of how the hierarchy is built. By considering a non-deterministic machine equipped with an oracle for the famous SAT problem, you will practice classifying this new model of computation and, in doing so, uncover the definition of the second level of the hierarchy, $\\Sigma_2^p$. ",
            "id": "1461565",
            "problem": "In computational complexity theory, we analyze the resources required to solve computational problems. A non-deterministic polynomial-time Turing machine (NPTM) is a theoretical model of computation that can explore multiple computational paths simultaneously. An oracle Turing machine is an abstract machine used to study decision problems with the help of a subroutine, called an oracle, that can solve a specific problem in a single step.\n\nThe Boolean Satisfiability Problem (SAT) is the problem of determining if there exists an interpretation that satisfies a given Boolean formula.\n\nThe Polynomial-time Hierarchy (PH) is a hierarchy of complexity classes that generalizes the classes P, NP, and co-NP. The levels of the hierarchy, denoted $\\Sigma_k^p$ and $\\Pi_k^p$ for integers $k \\ge 0$, are defined as follows:\n- $\\Sigma_0^p = \\Pi_0^p = P$\n- For $k \\ge 0$:\n  - $\\Sigma_{k+1}^p = \\text{NP}^{\\Sigma_k^p}$, which represents the set of languages decidable by an NPTM in polynomial time with an oracle for any problem complete for $\\Sigma_k^p$.\n  - $\\Pi_{k+1}^p = \\text{co-}\\Sigma_{k+1}^p$\n\nConsider the complexity class consisting of all languages that can be decided by a non-deterministic polynomial-time Turing machine with access to an oracle for the SAT problem. Which of the following classes in the Polynomial-time Hierarchy is equivalent to this class?\n\nA. $\\Sigma_1^p$\n\nB. $\\Pi_1^p$\n\nC. $\\Delta_2^p$\n\nD. $\\Sigma_2^p$\n\nE. $\\Pi_2^p$",
            "solution": "Let $C$ denote the class of all languages decidable by a non-deterministic polynomial-time Turing machine with access to an oracle for SAT. By definition, $C=\\mathrm{NP}^{\\mathrm{SAT}}$.\n\nRecall that SAT is $\\Sigma_{1}^{p}$-complete (NP-complete) under polynomial-time many-one reductions. The Polynomial-time Hierarchy is defined so that\n$$\n\\Sigma_{2}^{p}=\\mathrm{NP}^{\\Sigma_{1}^{p}},\n$$\nthat is, the class of languages decidable by an NPTM in polynomial time with an oracle for any $\\Sigma_{1}^{p}$-complete problem.\n\nFirst, we show $C \\subseteq \\Sigma_{2}^{p}$. Since $\\mathrm{SAT} \\in \\Sigma_{1}^{p}$, any $\\mathrm{NP}$ machine with a SAT oracle is an $\\mathrm{NP}$ machine with an oracle from $\\Sigma_{1}^{p}$, hence\n$$\n\\mathrm{NP}^{\\mathrm{SAT}} \\subseteq \\mathrm{NP}^{\\Sigma_{1}^{p}}=\\Sigma_{2}^{p}.\n$$\n\nNext, we show $\\Sigma_{2}^{p} \\subseteq C$. Let $L \\in \\Sigma_{2}^{p}$. Then $L \\in \\mathrm{NP}^{O}$ for some oracle $O \\in \\Sigma_{1}^{p}$. Because SAT is $\\Sigma_{1}^{p}$-complete, there exists a polynomial-time computable reduction $r$ such that for all $y$, $y \\in O$ if and only if $r(y) \\in \\mathrm{SAT}$. An NPTM that decides $L$ with oracle $O$ can be simulated by an NPTM with oracle SAT by replacing each query $y$ to $O$ by the query $r(y)$ to SAT. This preserves polynomial time, so\n$$\n\\mathrm{NP}^{\\Sigma_{1}^{p}} \\subseteq \\mathrm{NP}^{\\mathrm{SAT}}.\n$$\n\nCombining both inclusions gives\n$$\n\\mathrm{NP}^{\\mathrm{SAT}}=\\Sigma_{2}^{p}.\n$$\n\nTherefore, the class described in the question equals $\\Sigma_{2}^{p}$, which corresponds to option D.",
            "answer": "$$\\boxed{D}$$"
        },
        {
            "introduction": "Complexity classes are typically defined in terms of *decision* problemsâ€”questions with a \"yes\" or \"no\" answer. This exercise explores the profound connection between deciding if a solution exists and actually finding one. Assuming you have access to a magical oracle that can solve a $\\Sigma_k^p$ decision problem, your task is to construct an algorithm that finds a concrete solution, or \"witness,\" demonstrating a powerful and widely-used technique in complexity theory known as self-reducibility. ",
            "id": "1461585",
            "problem": "In computational complexity theory, the Polynomial-Time Hierarchy (PH) is a hierarchy of complexity classes that generalize the classes P, NP, and co-NP. The classes in the hierarchy are denoted $\\Sigma_k^p$, $\\Pi_k^p$, and $\\Delta_k^p$ for $k \\ge 0$.\n\nA canonical way to define these classes is through Quantified Boolean Formulas (QBFs). A QBF has the form $Q_1 \\vec{x}_1 Q_2 \\vec{x}_2 \\dots Q_k \\vec{x}_k \\phi(\\vec{x}_1, \\dots, \\vec{x}_k)$, where each $Q_i$ is a quantifier ($\\forall$ or $\\exists$), each $\\vec{x}_i$ is a block of Boolean variables, and $\\phi$ is a quantifier-free Boolean formula.\n\nThe class $\\Sigma_k^p$ corresponds to the set of problems that can be decided by determining the truth of QBFs with $k$ alternating quantifiers, starting with an existential quantifier. Formally, let $L_k$ be the language of all true QBFs of the form:\n$$ \\exists \\vec{x}_1 \\forall \\vec{x}_2 \\exists \\vec{x}_3 \\dots Q_k \\vec{x}_k \\phi(\\vec{x}_1, \\vec{x}_2, \\dots, \\vec{x}_k) $$\nwhere $\\phi$ is a quantifier-free formula. The problem of deciding membership in $L_k$ is complete for the class $\\Sigma_k^p$.\n\nAssume you are provided with a computational oracle for the language $L_k$ for some fixed integer $k \\ge 1$. This oracle can, in a single step, tell you whether any given formula with the $\\Sigma_k^p$ quantifier structure is true or false.\n\nYou are given a specific formula, $\\Phi$, which is guaranteed to be a true formula in the language $L_k$. The formula is given as:\n$$ \\Phi = \\exists \\vec{x} \\: \\forall \\vec{y}_1 \\: \\exists \\vec{y}_2 \\dots Q_k \\vec{y}_{k-1} \\: \\psi(\\vec{x}, \\vec{y}_1, \\dots, \\vec{y}_{k-1}) $$\nHere, $\\vec{x} = (x_1, x_2, \\dots, x_n)$ is the outermost block of $n$ existentially quantified variables. Since $\\Phi$ is true, there exists at least one satisfying assignment for $\\vec{x}$, called a \"witness\", which makes the rest of the formula true.\n\nYour task is to devise an algorithm that uses the $L_k$ oracle to find one such witness for $\\vec{x}$. Determine the exact number of calls to the $L_k$ oracle your algorithm must make in the worst case. Express your answer as a function of $n$.",
            "solution": "The problem asks for an algorithm to find a satisfying witness for the outermost existential variables of a true $\\Sigma_k^p$ formula, using an oracle that decides the truth of any $\\Sigma_k^p$ formula. We need to find the number of oracle calls required by this algorithm.\n\nThe core principle we will use is self-reducibility. We can construct the witness assignment $\\vec{w} = (w_1, w_2, \\dots, w_n)$ for $\\vec{x}$ one component at a time, from $w_1$ to $w_n$.\n\nLet the given true formula be $\\Phi = \\exists x_1, \\dots, x_n \\, \\Psi(x_1, \\dots, x_n)$, where $\\Psi$ represents the rest of the formula starting with the first universal quantifier, i.e., $\\Psi(\\vec{x}) = \\forall \\vec{y}_1 \\dots \\psi(\\vec{x}, \\dots)$.\n\n**Step 1: Determine the value of $w_1$.**\n\nWe know that a witness exists. This means either a witness starting with $w_1=1$ exists, or a witness starting with $w_1=0$ exists (or both). To determine which value $w_1$ can take, we can test one of the possibilities, say $w_1=1$.\n\nWe construct a new formula, $\\Phi_1$, by fixing $x_1=1$ in the original formula $\\Phi$:\n$$ \\Phi_1 = \\exists x_2, \\dots, x_n \\: \\forall \\vec{y}_1 \\: \\exists \\vec{y}_2 \\dots Q_k \\vec{y}_{k-1} \\: \\psi(1, x_2, \\dots, x_n, \\vec{y}_1, \\dots, \\vec{y}_{k-1}) $$\nThis new formula $\\Phi_1$ asks whether there exists a way to complete the witness, given that the first component is 1. Observe that the quantifier structure of $\\Phi_1$ is still a sequence of $k$ alternating quantifiers starting with an existential quantifier ($\\exists x_2, \\dots x_n$). Therefore, $\\Phi_1$ is a $\\Sigma_k^p$ formula, and we can use our $L_k$ oracle to decide its truth value.\n\nWe make one call to the oracle with the formula $\\Phi_1$.\n- **Case 1: The oracle returns TRUE.** If $\\Phi_1$ is true, it means there exists a witness for $\\vec{x}$ that starts with 1. We can therefore definitively set $w_1=1$. Our problem is now reduced to finding a witness for the remaining variables $(x_2, \\dots, x_n)$ for the true (as confirmed by the oracle) formula $\\Phi_1$.\n- **Case 2: The oracle returns FALSE.** If $\\Phi_1$ is false, it means no witness for $\\vec{x}$ starts with 1. However, we are given that the original formula $\\Phi$ is true, which guarantees that at least one witness exists. If no witness starts with 1, then there must be one that starts with 0. Therefore, we can definitively set $w_1=0$. We do not need to make a second oracle call to confirm this. The problem is now reduced to finding a witness for $(x_2, \\dots, x_n)$ in the formula where $x_1$ is set to 0.\n\nIn either case, we determine the correct value for $w_1$ with exactly one oracle call.\n\n**Step 2: Generalize for $w_i$.**\n\nWe can generalize this procedure. Assume we have already determined the first $i-1$ components of the witness, $(w_1, w_2, \\dots, w_{i-1})$. We now need to find $w_i$.\n\nWe construct a formula $\\Phi_i$ by fixing the first $i-1$ variables to their determined values and setting the $i$-th variable to 1:\n$$ \\Phi_i = \\exists x_{i+1}, \\dots, x_n \\: \\forall \\vec{y}_1 \\dots Q_k \\vec{y}_{k-1} \\: \\psi(w_1, \\dots, w_{i-1}, 1, x_{i+1}, \\dots, x_n, \\vec{y}_1, \\dots) $$\nAgain, $\\Phi_i$ is a $\\Sigma_k^p$ formula, so we can use the oracle.\n- We query the oracle with $\\Phi_i$.\n- If the oracle returns TRUE, we set $w_i=1$.\n- If the oracle returns FALSE, we know a valid completion must exist for the prefix $(w_1, \\dots, w_{i-1})$ (by construction from previous steps). If this completion cannot continue with a 1, it must be able to continue with a 0. So, we set $w_i=0$.\n\nThis process is repeated for each variable $x_i$ from $i=1$ to $n$. For each variable, we construct one new $\\Sigma_k^p$ formula and make exactly one call to the $L_k$ oracle to determine its correct assignment in the witness.\n\n**Step 3: Calculate the total number of oracle calls.**\n\nThe algorithm iterates $n$ times, once for each variable in $\\vec{x}$. In each iteration, it makes exactly one call to the $L_k$ oracle. Therefore, the total number of oracle calls to find the complete witness $\\vec{w}$ is exactly $n$. This holds true in the worst case, as the logic requires one call per variable regardless of the oracle's answers. The construction of each new formula $\\Phi_i$ is polynomial in the size of the original formula $\\Phi$, so the overall algorithm runs in polynomial time with respect to the oracle.\n\nThe total number of oracle calls is equal to the number of variables in the outermost existential block, which is $n$.",
            "answer": "$$\\boxed{n}$$"
        }
    ]
}