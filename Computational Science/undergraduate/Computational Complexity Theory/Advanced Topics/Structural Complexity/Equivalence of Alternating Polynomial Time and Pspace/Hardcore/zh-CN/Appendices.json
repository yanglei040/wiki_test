{
    "hands_on_practices": [
        {
            "introduction": "理论学习的最佳伙伴是动手实践。要真正理解交替式图灵机（ATM），第一步是学会如何“手动执行”它的计算过程。本练习通过一个具体的量化布尔公式（QBF）的求值任务，让你直观地体验ATM的计算树是如何展开的。通过追踪存在分支（$\\exists$）和全称分支（$\\forall$）的决策逻辑，你将掌握ATM接受或拒绝一个输入的根本规则，这是理解其计算能力的基础。",
            "id": "1421929",
            "problem": "交替图灵机 (ATM) 是一种非确定性图灵机，其状态被划分为两个集合：存在状态和全称状态。该模型对于评估量化布尔公式 (QBFs) 特别有用。评估过程可以被可视化为一个计算树。\n\n确定一个格局（树中的一个节点）是否为“接受”的规则如下：\n- 对应于存在量词（例如 $\\exists z$）的格局是接受的，如果其**至少一个**后继格局是接受的。后继格局是通过为变量 $z$ 代入所有可能的值来生成的。\n- 对应于全称量词（例如 $\\forall z$）的格局是接受的，如果其**所有**后继格局都是接受的。\n- 一个叶格局，其中布尔表达式的所有变量都已被赋值，如果表达式求值为真 (1) 则是接受的，如果求值为假 (0) 则是拒绝的。\n\n考虑一个 ATM，其任务是评估以下 QBF，其中变量 $x$ 和 $y$ 可以从集合 $\\{0, 1\\}$ 中取布尔值：\n$$ \\phi = \\exists x \\forall y, (x \\lor y) \\land (\\neg x \\lor \\neg y) $$\n\n根据 ATM 的计算规则，确定 $\\phi$ 评估的最终结果。以下哪个陈述提供了正确的结果和推理？\n\nA. ATM 接受，因为选择 $x=1$ 会导向一个接受状态，因为子公式 $\\forall y, (1 \\lor y) \\land (\\neg 1 \\lor \\neg y)$ 为真。\n\nB. ATM 拒绝，因为对于选择 $x=0$，当 $y=0$ 时的子公式实例，即 $(0 \\lor 0) \\land (\\neg 0 \\lor \\neg 0)$，求值为假，这足以使该分支上对 $y$ 的全称量化失败。\n\nC. ATM 接受，因为选择 $x=0$ 会导向一个接受状态，因为子公式 $\\forall y, (0 \\lor y) \\land (\\neg 0 \\lor \\neg y)$ 为真。\n\nD. ATM 拒绝，因为对于选择 $x=1$，当 $y=1$ 时的子公式实例，即 $(1 \\lor 1) \\land (\\neg 1 \\lor \\neg 1)$，求值为假，这足以使该分支上对 $y$ 的全称量化失败。\n\nE. ATM 拒绝，因为无论是选择 $x=0$ 还是 $x=1$，都不能使对 $y$ 的全称量化导向一个接受状态。",
            "solution": "我们被要求在交替图灵机的接受规则下评估 QBF $\\phi = \\exists x \\forall y,\\,(x \\lor y) \\land (\\neg x \\lor \\neg y)$：一个存在格局是接受的，如果至少有一个后继是接受的；一个全称格局是接受的，当且仅当所有后继都是接受的；一个叶子是接受的，当且仅当完全实例化的布尔表达式求值为 $1$。\n\n首先，分析命题子公式\n$$\nf(x,y) = (x \\lor y) \\land (\\neg x \\lor \\neg y).\n$$\n将 $\\land$ 分配到 $\\lor$ 上：\n$$\n(x \\lor y) \\land (\\neg x \\lor \\neg y) = (x \\land \\neg x) \\lor (x \\land \\neg y) \\lor (y \\land \\neg x) \\lor (y \\land \\neg y).\n$$\n因为 $x \\land \\neg x = 0$ 并且 $y \\land \\neg y = 0$，这可以简化为\n$$\nf(x,y) = (x \\land \\neg y) \\lor (y \\land \\neg x),\n$$\n这在 $x \\neq y$ 时（异或条件）为真。\n\n对 $x$ 的每一种选择评估全称量化：\n- 对于 $x=0$，我们需要评估 $\\forall y\\, f(0,y)$。计算两个实例：\n  - 对于 $y=0$：\n    $$\n    f(0,0) = (0 \\lor 0) \\land (\\neg 0 \\lor \\neg 0) = 0 \\land (1 \\lor 1) = 0 \\land 1 = 0.\n    $$\n  - 对于 $y=1$：\n    $$\n    f(0,1) = (0 \\lor 1) \\land (\\neg 0 \\lor \\neg 1) = 1 \\land (1 \\lor 0) = 1 \\land 1 = 1.\n    $$\n  因为一个全称节点要求所有后继都是接受的，而 $f(0,0)=0$，所以对于 $x=0$，全称量词失败。\n\n- 对于 $x=1$，我们需要评估 $\\forall y\\, f(1,y)$。计算两个实例：\n  - 对于 $y=0$：\n    $$\n    f(1,0) = (1 \\lor 0) \\land (\\neg 1 \\lor \\neg 0) = 1 \\land (0 \\lor 1) = 1 \\land 1 = 1.\n    $$\n  - 对于 $y=1$：\n    $$\n    f(1,1) = (1 \\lor 1) \\land (\\neg 1 \\lor \\neg 1) = 1 \\land (0 \\lor 0) = 1 \\land 0 = 0.\n    $$\n  同样，因为 $f(1,1)=0$，所以对于 $x=1$，全称量词失败。\n\n因此，对于 $x=0$ 和 $x=1$ 这两种选择，对 $y$ 的全称量化都不能产生接受状态。一个存在节点是接受的，当且仅当它的至少一个后继是接受的；在这里，两种对 $x$ 的选择都不能导向接受状态。因此，ATM 拒绝该 QBF。\n\n选项分析：\n- A 和 C 是错误的，因为无论是 $x=1$ 还是 $x=0$ 都不能使全称子公式为真。\n- B 和 D 各自指出了一个特定 $x$ 值的失败的全称分支，但这本身并不足以在外部存在量词下证明整体拒绝。\n- E 正确地指出，两种对 $x$ 的选择都不能产生一个接受的全称子公式；因此 ATM 拒绝。\n\n正确选项是 E。",
            "answer": "$$\\boxed{E}$$"
        },
        {
            "introduction": "在掌握了ATM的基本计算规则后，下一步便是尝试设计一个ATM来解决具体问题。这个练习要求你为正则语言 $L = (01)^*$ 构建一个多项式时间的ATM。这个问题的美妙之处在于，它迫使你思考如何利用ATM的全称状态（universal state）来强制一个全局属性——即字符串中的每一对“01”字符块都必须符合规范。通过这个设计过程，你将学会如何将“对于所有”的逻辑要求转化为ATM的计算步骤。",
            "id": "1421905",
            "problem": "交替图灵机（Alternating Turing Machine, ATM）是一种计算的理论模型，它推广了非确定性图灵机。它的非停机状态被划分为存在状态和全称状态。对于一个处于存在状态的格局，要使其成为接受格局，其后继格局中必须至少有一个能达到接受状态。对于一个处于全称状态的格局，要使其成为接受格局，其所有的后继格局都必须能达到接受状态。如果一台ATM的初始格局是一个接受格局，那么它就接受该输入串。\n\n我们的目标是构建一台多项式时间的ATM，用于判定由重复“01”块构成的所有字符串组成的语言 $L$。也就是说，$L = (01)^* = \\{\\epsilon, 01, 0101, 010101, \\dots \\}$，其中 $\\epsilon$ 表示空串。该ATM对一个长度为 $n$ 的输入串 $w$ 进行操作。为便于标记，非空字符串 $w$ 的字符是1-索引的，即 $w = w_1 w_2 \\dots w_n$。\n\n以下哪个高级描述定义了一台能正确判定语言 $L$ 的ATM？\n\nA. ATM从一个存在状态开始。它存在性地从 $\\{1, 3, 5, \\dots, n-1\\}$ 中选择一个索引 $j$。然后它验证 $w_j = '0'$ 且 $w_{j+1} = '1'$。如果能找到这样的 $j$，机器就接受。\n\nB. ATM首先执行一个确定性检查：如果输入长度 $n$ 是奇数，则拒绝。如果 $n=0$，则接受。如果 $n$ 是一个正偶数，它进入一个全称状态，在该状态下，它全称性地从 $\\{1, 3, 5, \\dots, n-1\\}$ 中选择一个整数 $j$。对于每个 $j$，它验证 $w_j = '0'$ 且 $w_{j+1} = '1'$。如果所有这些检查都通过，机器就接受。\n\nC. ATM从一个全称状态开始。它全称性地从 $\\{1, 2, \\dots, n\\}$ 中选择一个索引 $i$。对于每个选择的 $i$，它验证如果 $i$ 是奇数，则 $w_i = '0'$，如果 $i$ 是偶数，则 $w_i = '1'$。如果所有这些检查都通过，机器就接受。\n\nD. ATM从一个存在状态开始，在该状态下它猜测一个整数 $k>0$。然后它进入一个全称状态，在该状态下，它全称性地选择一个索引 $j \\in \\{1, \\dots, k\\}$。对于每个 $j$，它验证 $w_{2j-1}='0'$ 且 $w_{2j}='1'$。如果对于猜测的 $k$，这些检查都通过，并且输入长度 $n=2k$ 也成立，那么机器就接受。",
            "solution": "我们精确地刻画该语言：一个长度为 $n$ 的输入 $w$ 属于 $L=(01)^{*}$ 当且仅当 $n=0$（此时 $w=\\epsilon$），或者 $n$ 是偶数且对于所有 $j \\in \\{1,\\dots,n/2\\}$，都有 $w_{2j-1}=\\text{'0'}$ 且 $w_{2j}=\\text{'1'}$。形式上，\n$$\nw \\in L \\iff \\left(n=0\\right)\\ \\lor\\ \\left(n \\text{ is even and } \\forall j \\in \\{1,\\dots,n/2\\},\\ w_{2j-1}=\\text{'0'} \\land w_{2j}=\\text{'1'}\\right).\n$$\n一台ATM必须精确地接受满足此条件的 $w$。\n\n选项A不正确：它存在性地验证是否存在一个索引 $j \\in \\{1,3,5,\\dots,n-1\\}$ 使得局部模式为 $w_{j}=\\text{'0'}$，$w_{j+1}=\\text{'1'}$。这会接受那些包含至少一个正确块但整体上不具有 $(01)^{*}$ 形式的字符串。例如，通过选择 $j=1$，$w=\\text{\"0111\"}$ 会被接受，尽管 $w \\notin L$。此外，对于 $n=0$，没有 $j$ 可供选择，因此存在状态不会接受 $\\epsilon \\in L$。\n\n选项B符合形式化条件。它确定性地拒绝奇数长度的 $n$ 并接受 $n=0$。对于偶数 $n>0$，它进入一个全称状态，该状态遍历所有奇数位置 $j \\in \\{1,3,5,\\dots,n-1\\}$，并对每个这样的 $j$ 验证 $w_{j}=\\text{'0'}$ 和 $w_{j+1}=\\text{'1'}$。根据全称状态的语义，当且仅当每一对都正确时才会接受，这等价于 $w \\in (01)^{n/2}$。结合奇偶性和空串的检查，这台ATM可以精确地判定 $L$。每个分支上的时间都是 $n$ 的多项式，因此该ATM在多项式时间内运行。\n\n选项C不正确，因为它缺少任何奇偶性检查，只强制执行了按位置的约束：它全称性地检查奇数索引处为 $\\text{'0'}$，偶数索引处为 $\\text{'1'}$。这会接受像 $w=\\text{\"0\"}$（此时 $n=1$）这样的字符串，它满足局部规则但不在 $L$ 中，因为 $L$ 只包含偶数长度的字符串（除了 $\\epsilon$）。因此它会接受一些不属于 $L$ 的 $w$。\n\n选项D不正确，因为它明确要求猜测 $k>0$，因此不能接受 $\\epsilon$（此时 $n=0$）。由于 $\\epsilon \\in L$，这台ATM未能判定 $L$。\n\n因此，只有选项B正确定义了一台能判定 $L$ 的多项式时间ATM。",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "本章节的核心是证明 $APTIME = PSPACE$。这个练习将带你深入该证明的一个关键部分：$APTIME \\subseteq PSPACE$ 的模拟过程。我们通过一个思想实验来进行探讨：如果用于模拟ATM的确定性算法在内存管理上存在一个特定的缺陷，将会产生什么后果？通过分析这个假设性的“有缺陷的模拟”（`FlawedSim`），你不仅能验证ATM的模拟过程，更能深刻理解标准证明中对空间复杂度的精细控制为何至关重要。这个练习揭示了算法设计细节如何直接影响我们对计算复杂性类的结论。",
            "id": "1421914",
            "problem": "在计算复杂性理论中，不同资源有界计算模型之间的关系是一个核心主题。一项关键结果是，可在交替多项式时间 (AP) 内解决的问题类与可在多项式空间 (PSPACE) 内解决的问题类是等价的。这通常通过证明一个可由多项式时间交替图灵机 (ATM) 判定的语言，可由一台使用多项式大小空间的确定性图灵机判定来得到。\n\n标准证明涉及一个递归算法，该算法对 ATM 的计算树进行深度优先遍历。我们将此算法称为 `StandardSim`。在每个格局处，`StandardSim` 会在下一个可能的格局上递归调用自身。对于一个全称格局，只有当对其所有子格局的递归调用都返回 `accept` 时，它才返回 `accept`；对于一个存在格局，只要至少有一个调用返回 `accept`，它就返回 `accept`。所用空间是多项式的，因为递归深度受 ATM 的多项式运行时间限制，并且每个栈帧保存一个格局，其大小也是多项式的。\n\n现在，考虑一个为相同目的设计的修改版算法 `FlawedSim`。该算法存在一个与内存管理相关的关键实现缺陷：\n\n-   对于一个 **存在** 格局，`FlawedSim` 的行为与 `StandardSim` 类似：它逐一探索子格局，并在继续下一个之前正确回收用于每次递归调用的内存。一旦找到一个接受的子路径，它会执行提前退出，返回 `accept`。\n-   对于一个 **全称** 格局，`FlawedSim` 也逐一探索子格局。然而，由于这个缺陷，为一个子计算路径的整个递归评估所分配的内存，在调用返回后 **不会** 被释放。这部分内存会一直保持分配状态，直到对该全称格局本身及其所有子格局的模拟完成。\n\n假设被模拟的 ATM 在输入大小为 $n$ 时运行时间为 $p(n)$（其中 $p$ 是一个多项式），并且具有大于1的常数分支因子。PSPACE 和指数空间 (EXPSPACE) 类定义如下：\n-   PSPACE = $\\bigcup_{k \\ge 1} \\text{DSPACE}(n^k)$\n-   EXPSPACE = $\\bigcup_{k \\ge 1} \\text{DSPACE}(2^{n^k})$\n\n下列哪个陈述最准确地描述了此缺陷对算法空间需求的影响，以及由此可以得出的复杂性理论结论？\n\nA. 该缺陷不改变渐进空间复杂度。`FlawedSim` 仍然在多项式空间内运行，因此正确证明了 $AP \\subseteq PSPACE$。\nB. 该缺陷导致最坏情况下的空间复杂度变为指数级。模拟仍然是正确的，因此它证明了 $AP \\subseteq EXPSPACE$，但未能建立更紧的界 $AP \\subseteq PSPACE$。\nC. 该缺陷导致最坏情况下的空间复杂度变为双指数级（即形式为 $2^{2^{q(n)}}$，其中 $q$ 是某个多项式）。这为 AP 提供了一个比标准证明弱得多的上界。\nD. 该缺陷导致算法对某些输入进入无限循环，这意味着它不是对 AP 中所有语言的有效判定机。\nE. 空间复杂度仅在计算树完全由全称节点组成时才变为指数级；否则，它仍然是多项式的。",
            "solution": "设输入长度为 $n$。交替图灵机 (ATM) 的运行时间为 $p(n)$，其中 $p$ 是一个多项式，其常数分支因子为 $b>1$。设 $s(n)$ 表示单个格局的大小（以带单元计），它是 $n$ 的多项式。计算树的高度最多为 $p(n)$。\n\n`StandardSim` 执行深度优先搜索，在从存在节点和全称节点的递归调用返回时都会回收空间。因此，其空间使用量受最大递归深度乘以每帧大小的限制：\n$$\nS_{\\text{std}}(n) \\in O\\!\\left(p(n)\\, s(n)\\right),\n$$\n这是多项式的，因此它证明了 $AP \\subseteq PSPACE$。\n\n现在分析 `FlawedSim`。对于存在节点，它像 `StandardSim` 一样回收内存，因此不会发生渐进性爆炸。对于全称节点，由于缺陷，处理每个子树期间分配的峰值空间会被保留，直到整个全称节点（及其所有子节点）处理完毕。\n\n分别定义 $S_{E}(d)$ 和 $S_{U}(d)$ 为处理根节点为存在节点或全称节点的、高度为 $d$ 的子树所需的最大空间。设 $S(d) = \\max\\{S_{E}(d), S_{U}(d)\\}$。对于一个存在节点，由于在处理子节点之间会回收空间，峰值是所有子节点所需空间的最大值加上当前帧的空间：\n$$\nS_{E}(d) \\le S(d-1) + c_{1} s(n),\n$$\n其中 $c_{1}$ 是某个常数。对于一个分支因子为 $b$ 的全称节点，由于探索每个子节点的空间都被保留并在 $b$ 个子节点间累积，我们有\n$$\nS_{U}(d) \\le b\\, S(d-1) + c_{2} s(n),\n$$\n其中 $c_{2}$ 是某个常数。因此，\n$$\nS(d) \\le b\\, S(d-1) + c\\, s(n),\n$$\n其中 $c = \\max\\{c_{1},c_{2}\\}$，基本情况为 $S(0) \\in O(s(n))$。\n\n展开此递推关系可得\n$$\nS(d) \\le b^{d} S(0) + c\\, s(n) \\sum_{i=0}^{d-1} b^{i} \\le \\left(S(0) + \\frac{c}{b-1} s(n)\\right) b^{d} \\in O\\!\\left(s(n)\\, b^{d}\\right).\n$$\n当 $d \\le p(n)$ 时，这得出\n$$\nS(n) \\in O\\!\\left(s(n)\\, b^{p(n)}\\right).\n$$\n由于 $b>1$ 是一个常数且 $s(n)$ 是多项式的，我们有\n$$\nb^{p(n)} = \\exp\\!\\big((\\ln b)\\, p(n)\\big) = 2^{(\\log_{2} b)\\, p(n)} = 2^{\\Theta(p(n))},\n$$\n所以\n$$\nS(n) \\in 2^{\\Theta(p(n))} \\cdot \\operatorname{poly}(n).\n$$\n因为对于某个整数 $k \\ge 1$ 有 $p(n) \\in O(n^{k})$，所以\n$$\nS(n) \\in \\text{DSPACE}\\!\\left(2^{n^{k}}\\right) \\subseteq \\text{EXPSPACE}.\n$$\n\n这不是双指数的，因为 $b^{p(n)}$ 是一个多项式的单指数函数，而不是 $2^{2^{q(n)}}$ 的形式。模拟的逻辑没有改变；只是内存回收有缺陷，所以算法仍然能够正确判定并停机，但可能使用指数级的空间。此外，指数级爆炸并不要求计算树完全由全称节点组成；拥有 $\\Theta(p(n))$ 个全称层级（例如，全称和存在交替出现）就已经会导致 $b^{\\Theta(p(n))}$ 的累积。\n\n因此，该缺陷将最坏情况下的空间复杂度增加到指数级，仅得出较弱的上界 $AP \\subseteq EXPSPACE$，而未能建立 $AP \\subseteq PSPACE$。",
            "answer": "$$\\boxed{B}$$"
        }
    ]
}