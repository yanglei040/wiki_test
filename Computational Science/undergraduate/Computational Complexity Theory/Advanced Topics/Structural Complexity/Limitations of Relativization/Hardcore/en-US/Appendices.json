{
    "hands_on_practices": [
        {
            "introduction": "This first practice introduces the foundational technique of diagonalization, which is essential for constructing oracles. By working through a hypothetical scenario to separate a custom complexity class from the familiar class $\\mathrm{P}$, you will learn the core strategy of how to build an oracle that forces a desired outcome between two computational models . This hands-on thought experiment illuminates the adversarial nature of oracle construction, a cornerstone for understanding the relativization barrier.",
            "id": "1430207",
            "problem": "In computational complexity theory, an oracle Turing machine is a theoretical model of computation used to study the limits of proof techniques. It is an abstract machine with access to an \"oracle,\" which can solve a specific decision problem in a single step. For a given oracle language $A$ (a set of binary strings), $P^A$ denotes the class of decision problems solvable by a deterministic Turing machine in polynomial time with access to the oracle $A$.\n\nLet's define a new complexity class. We define $LOGQ^A$ as the class of languages decidable by a deterministic polynomial-time oracle Turing machine that, for any input of length $n$, is restricted to making at most $O(\\log n)$ queries to the oracle $A$. By definition, any language in $LOGQ^A$ is also in $P^A$, so $LOGQ^A \\subseteq P^A$.\n\nYour task is to explore whether this inclusion is strict. Consider the specific language $L_A$ defined as:\n$$L_A = \\{1^n \\mid A \\text{ contains at least one string of length } \\lfloor \\log_2 n \\rfloor \\}$$\nHere, $1^n$ represents a string of $n$ ones. A deterministic polynomial-time machine can decide if $1^n \\in L_A$ by querying the oracle for all possible strings of length $k = \\lfloor \\log_2 n \\rfloor$. The number of such strings is $2^k \\approx n$, which is a polynomial number of queries. Therefore, we know that for any oracle $A$, the language $L_A$ is in $P^A$.\n\nTo show that $P^A \\neq LOGQ^A$, one must construct an oracle $A$ for which $L_A \\notin LOGQ^A$. This is typically done using a diagonalization argument. Which of the following statements best describes the high-level strategy for constructing such an oracle $A$?\n\nA. Systematically go through an enumeration of all possible $LOGQ$ machines, $M_1, M_2, \\dots$. For each machine $M_i$, find a large input $1^{n_i}$ and simulate $M_i$ on it. Use the fact that $M_i$ can query only a logarithmic number of strings of the relevant length to ensure its final answer for \"Is $1^{n_i} \\in L_A$?\" is wrong, by carefully adding or not adding an un-queried string to $A$.\n\nB. Construct the oracle $A$ to be a language that is complete for a very large complexity class, such as $\\mathrm{PSPACE}$. The inherent computational difficulty of the oracle language itself will be too great for a machine with only a logarithmic number of queries to handle, thus separating the classes.\n\nC. Construct a \"random\" oracle $A$ where each string is included with a probability of 1/2. With high probability, any given $LOGQ$ machine will fail to decide $L_A$ because the information it can gather through a logarithmic number of queries is insufficient to determine if one of the polynomially many relevant strings is in the random oracle.\n\nD. Define the oracle $A$ to be identical to the target language $L_A$. A machine in $P^A$ could then decide membership in $L_A$ for an input $1^n$ with a single query, which a $LOGQ^A$ machine cannot for all languages.\n\nE. For each $LOGQ$ machine $M_i$, find an input $1^{n_i}$ that causes the machine's runtime to exceed its polynomial bound. The oracle $A$ would be constructed to contain information about specific inputs that cause this long runtime, which a $P^A$ machine could then use.",
            "solution": "We restate the setting. For a fixed oracle language $A \\subseteq \\{0,1\\}^*$, $P^A$ is the class of languages decidable by a deterministic polynomial-time oracle Turing machine with unrestricted polynomially many queries to $A$. The subclass $LOGQ^A$ consists of those decided with at most $O(\\log n)$ oracle queries on inputs of length $n$. The language\n$$\nL_A=\\{1^n \\mid \\text{$A$ contains at least one string of length } k=\\lfloor \\log_2 n \\rfloor\\}\n$$\nis in $P^A$ for every $A$, because deciding $1^n \\in L_A$ can be done by querying all strings $x \\in \\{0,1\\}^k$: there are $2^k$ such strings, and since $k=\\lfloor \\log_2 n \\rfloor$, we have $2^k \\leq n$, which is polynomial in $n$.\n\nTo separate $P^A$ from $LOGQ^A$, we need an oracle $A$ such that $L_A \\notin LOGQ^A$. The standard high-level strategy is diagonalization against all $LOGQ$ machines:\n1) Enumerate all deterministic polynomial-time oracle machines that on inputs of length $n$ make at most $c \\log n$ queries for some fixed constant $c$, denoted $(M_1, M_2, \\dots)$.\n2) For stage $i$, pick an $n_i$ so large that the associated $k_i=\\lfloor \\log_2 n_i \\rfloor$ is strictly larger than all previously used lengths, ensuring that decisions about strings of length $k_i$ will not interfere with earlier stages.\n3) Simulate $M_i$ on input $1^{n_i}$, answering adaptively all its at most $q_i \\leq c \\log n_i$ oracle queries. While simulating, ensure that any query of length $k_i$ is answered consistently in a way that leaves many strings of length $k_i$ unqueried and undecided; since there are $2^{k_i} \\geq n_i$ possible strings and only $q_i=O(\\log n_i)$ queries, the set of unqueried strings of length $k_i$ is nonempty and, in fact, overwhelmingly large.\n4) After $M_i$ halts and outputs a decision for whether $1^{n_i} \\in L_A$, fix the membership of strings of length $k_i$ in $A$ to force the opposite truth value. Concretely:\n- If $M_i$ outputs that $1^{n_i} \\notin L_A$, add one unqueried string of length $k_i$ to $A$, making the correct answer “yes.”\n- If $M_i$ outputs that $1^{n_i} \\in L_A$, ensure that no string of length $k_i$ is in $A$, making the correct answer “no.”\n5) Because later stages operate only on strictly larger lengths, they cannot change the truth of $L_A$ on $1^{n_i}$. Thus each $M_i$ is wrong on its designated input, and no $LOGQ^A$ machine decides $L_A$.\n\nThis strategy crucially exploits the information-theoretic gap: for inputs of length $n$, deciding whether “there exists some string of length $k=\\lfloor \\log_2 n \\rfloor$ in $A$” depends on $2^k$ bits of oracle information, while a $LOGQ^A$ machine can only read $O(\\log n)$ of them; we can always adversarially set at least one unqueried string to flip the truth of the existential predicate. Ensuring disjoint lengths across stages guarantees global consistency.\n\nEvaluating the options:\n- A precisely describes this diagonalization: enumerate $LOGQ$ machines, pick large inputs, simulate with at most $O(\\log n)$ queries exposed, and then set an unqueried string’s membership to force an error.\n- B is irrelevant: making $A$ complete for a large class like $\\mathrm{PSPACE}$ does not, by itself, separate $P^A$ from $LOGQ^A$ on this particular language; the obstacle is query scarcity, not inherent hardness of $A$.\n- C appeals to a random-oracle heuristic, but “with high probability” is insufficient to guarantee that no $LOGQ$ machine decides $L_A$ for all inputs; the proof requires an adversarial, stagewise construction guaranteeing failure for each machine on some input, not a probabilistic statement about typical behavior.\n- D is circular or ill-defined, since $L_A$ depends on $A$; setting $A=L_A$ does not yield a coherent or generally separating construction.\n- E is off-target: time bounds are already polynomial; the separation hinges on limiting the number of oracle queries, not causing super-polynomial runtime.\n\nTherefore, the correct high-level strategy is described by option A.",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "The famous Baker-Gill-Solovay theorem reveals the existence of two contradictory worlds: one where $P^A = NP^A$ and another where $P^B \\neq NP^B$. This exercise focuses on constructing the first world by exploring which powerful, well-known languages, when used as oracles, can collapse the polynomial hierarchy, making $P^A$ and $NP^A$ equivalent . Understanding how an oracle's intrinsic computational power can erase the distinction between deterministic and nondeterministic computation is key to appreciating the limits of standard proof techniques.",
            "id": "1430179",
            "problem": "The Baker-Gill-Solovay theorem is a foundational result in computational complexity theory that demonstrates the limitations of relativizing proof techniques. It shows that there exist oracles $A$ and $B$ such that $P^A = NP^A$ and $P^B \\neq NP^B$. This implies that any proof technique that is indifferent to the presence of an oracle (i.e., it \"relativizes\") cannot resolve the $\\mathrm{P}$ versus $\\mathrm{NP}$ problem.\n\nYour task is to explore the construction of an oracle that forces the collapse of the polynomial hierarchy at its first level. An oracle Turing machine is a standard Turing machine equipped with a special query tape and a query state. When the machine enters the query state, the string $q$ on its query tape is checked for membership in a fixed oracle language $A$. This query is considered to take a single computational step. We define $P^A$ as the class of languages decidable by a polynomial-time deterministic oracle Turing machine using oracle $A$, and $NP^A$ as the class of languages decidable by a polynomial-time non-deterministic oracle Turing machine using oracle $A$.\n\nSelect all of the following languages which, if used as an oracle $A$, would cause the relativized complexity classes $P^A$ and $NP^A$ to be equal. You may assume that all languages listed are decidable in exponential time (EXPTIME) and that their respective completeness properties hold under polynomial-time reductions.\n\nA. SAT: The language of all satisfiable Boolean formulas. This language is NP-complete.\n\nB. TQBF: The language of all true quantified Boolean formulas. This language is PSPACE-complete.\n\nC. PATH: The language of all tuples $\\langle G, s, t \\rangle$ where $G$ is a directed graph containing a path from vertex $s$ to vertex $t$. This language is P-complete.\n\nD. ALL_NFA: The language of all Non-deterministic Finite Automata (NFAs) $\\langle M \\rangle$ that accept every string over their input alphabet (i.e., $L(M) = \\Sigma^*$). This language is PSPACE-complete.\n\nE. An EXPTIME-complete language: Any language that is complete for the complexity class EXPTIME.",
            "solution": "We are asked to determine, for each proposed oracle language, whether using it as an oracle $A$ forces $P^A = NP^A$, i.e., collapses the relativized polynomial hierarchy at its first level. We use standard definitions: $P^A$ is deterministic polynomial time with oracle $A$, and $NP^A$ is nondeterministic polynomial time with oracle $A$. We rely on completeness under polynomial-time many-one reductions (as stated), and on standard closure properties.\n\nGeneral principles used:\n1) If $A$ is complete for a class $\\mathcal{C}$ under polynomial-time many-one reductions, then for every $L \\in \\mathcal{C}$ there is a polynomial-time computable reduction $f$ with $x \\in L$ iff $f(x) \\in A$. Hence $L \\in P^A$, so $\\mathcal{C} \\subseteq P^A$.\n2) If $A \\in \\mathcal{C}$ and $\\mathcal{C}$ is closed under polynomial-time Turing reductions, then $P^A \\subseteq \\mathcal{C}$ because a $P^A$ computation can be simulated by a $\\mathcal{C}$-machine answering each oracle query within $\\mathcal{C}$ and composing polynomially many such calls.\n3) For nondeterminism with a $\\mathcal{C}$-oracle where $\\mathcal{C}$ is at least $\\mathrm{PSPACE}$ or $\\mathrm{EXPTIME}$, we use that $\\mathrm{NPSPACE} = \\mathrm{PSPACE}$ (Savitch) and that $\\mathrm{EXPTIME}$ is closed under polynomial-time Turing reductions and can brute-force polynomially many nondeterministic branches without exceeding exponential time. Thus $NP^A \\subseteq \\mathcal{C}$ whenever $A \\in \\mathcal{C}$ with the stated closure.\n\nWe analyze each option.\n\nA. $A = \\mathrm{SAT}$ ($\\mathrm{NP}$-complete).\nBecause $\\mathrm{SAT}$ is $\\mathrm{NP}$-complete, $P^{\\mathrm{SAT}} = P^{\\mathrm{NP}} = \\Delta_2^P$ and $NP^{\\mathrm{SAT}} = NP^{\\mathrm{NP}} = \\Sigma_2^P$. It is not known whether $\\Delta_2^P = \\Sigma_2^P$. Therefore, using $\\mathrm{SAT}$ as the oracle does not provably cause $P^A = NP^A$, and we cannot select this option.\n\nB. $A = \\mathrm{TQBF}$ ($\\mathrm{PSPACE}$-complete).\nFirst, by completeness, for any $L \\in \\mathrm{PSPACE}$ there is a polynomial-time many-one reduction $f$ to $\\mathrm{TQBF}$, so $\\mathrm{PSPACE} \\subseteq P^A$. Next, since $A \\in \\mathrm{PSPACE}$ and $\\mathrm{PSPACE}$ is closed under polynomial-time Turing reductions, any $P^A$ computation can be simulated in $\\mathrm{PSPACE}$, so $P^A \\subseteq \\mathrm{PSPACE}$. Hence\n$$\nP^A = \\mathrm{PSPACE}.\n$$\nMoreover, $P^A \\subseteq NP^A$ implies $\\mathrm{PSPACE} \\subseteq NP^A$. For the reverse inclusion, simulate an $NP^A$ machine in polynomial space by depth-first traversal of its polynomial-depth computation tree while answering each oracle query to $A \\in \\mathrm{PSPACE}$ in polynomial space. Thus $NP^A \\subseteq \\mathrm{PSPACE}$. Therefore\n$$\nNP^A = \\mathrm{PSPACE},\n$$\nand consequently $P^A = NP^A$.\n\nC. $A = \\mathrm{PATH}$ ($\\mathrm{P}$-complete).\nSince $A \\in \\mathrm{P}$, any $P^A$ machine’s oracle queries can be simulated in polynomial time, yielding $P^A = \\mathrm{P}$. Similarly, $NP^A = \\mathrm{NP}$. Therefore $P^A = NP^A$ would imply $\\mathrm{P} = \\mathrm{NP}$, which is unknown. Hence this oracle does not provably cause $P^A = NP^A$, so we do not select this option.\n\nD. $A = \\mathrm{ALL\\_NFA}$ ($\\mathrm{PSPACE}$-complete).\nExactly the same argument as for $\\mathrm{TQBF}$ applies. By completeness and closure, we obtain $P^A = \\mathrm{PSPACE}$ and $NP^A = \\mathrm{PSPACE}$, hence $P^A = NP^A$.\n\nE. $A$ is $\\mathrm{EXPTIME}$-complete.\nBy completeness, for any $L \\in \\mathrm{EXPTIME}$ there is a polynomial-time many-one reduction $f$ to $A$, so $\\mathrm{EXPTIME} \\subseteq P^A$. Conversely, simulate any $P^A$ computation deterministically: each of its polynomially many oracle queries to $A$ can be answered in exponential time on inputs of polynomial length, and the total time remains exponential, so $P^A \\subseteq \\mathrm{EXPTIME}$. Hence\n$$\nP^A = \\mathrm{EXPTIME}.\n$$\nFor $NP^A$, nondeterministic polynomial time with an $\\mathrm{EXPTIME}$ oracle can be simulated deterministically in exponential time by enumerating at most $\\exp(p(n))$ branches, each incurring at most $\\exp(p(n))$ time due to the oracle calls and polynomial work, keeping the total within $\\exp(q(n))$. Therefore $NP^A \\subseteq \\mathrm{EXPTIME}$, and since $P^A = \\mathrm{EXPTIME} \\subseteq NP^A$, we conclude\n$$\nNP^A = \\mathrm{EXPTIME}.\n$$\nThus $P^A = NP^A$.\n\nConclusion:\n- B and D (both $\\mathrm{PSPACE}$-complete oracles) yield $P^A = NP^A = \\mathrm{PSPACE}$.\n- E ($\\mathrm{EXPTIME}$-complete oracle) yields $P^A = NP^A = \\mathrm{EXPTIME}$.\n- A and C do not provably yield $P^A = NP^A$ under current knowledge.\n\nTherefore, the correct selections are B, D, and E.",
            "answer": "$$\\boxed{BDE}$$"
        },
        {
            "introduction": "Moving beyond the classic results, this practice explores a more subtle aspect of the relativization barrier: the difference between \"dense\" and \"sparse\" oracles. A separation between $\\mathrm{P}$ and $\\mathrm{NP}$ using a sparse oracle is considered a much more significant step toward solving the actual $\\mathrm{P}$ versus $\\mathrm{NP}$ problem . By reasoning about why this is the case, you will gain insight into a major direction of modern complexity theory research and the quest for non-relativizing proof methods.",
            "id": "1430234",
            "problem": "In computational complexity theory, an oracle Turing Machine is a theoretical model used to study the limits of proof techniques. An oracle $A$ is a set of strings over a fixed alphabet (e.g., $\\{0,1\\}$), and a machine with access to this oracle can determine membership in $A$ for any given string in a single computation step. We denote the class of decision problems solvable in polynomial time by a deterministic machine with oracle $A$ as $\\mathrm{P}^A$, and by a nondeterministic machine as $\\mathrm{NP}^A$. The relativization barrier, famously demonstrated by the Baker-Gill-Solovay theorem, shows the existence of oracles $O_1$ and $O_2$ such that $\\mathrm{P}^{O_1} = \\mathrm{NP}^{O_1}$ and $\\mathrm{P}^{O_2} \\neq \\mathrm{NP}^{O_2}$. This implies that proof techniques that \"relativize\" (i.e., hold true for any possible oracle) are insufficient to resolve the foundational $\\mathrm{P}$ versus $\\mathrm{NP}$ question.\n\nA major line of research, therefore, attempts to find \"non-relativizing\" proof techniques. One approach is to study how the separation between $\\mathrm{P}^A$ and $\\mathrm{NP}^A$ depends on the properties of the oracle $A$. An oracle $S$ is defined as \"sparse\" if there exists a polynomial $p(n)$ such that for any non-negative integer $n$, the number of strings in $S$ of length up to $n$ is at most $p(n)$. Formally, $|S \\cap \\{0,1\\}^{\\le n}| \\le p(n)$. An oracle that is not sparse is called \"dense\".\n\nIt is widely believed in the field that proving $\\mathrm{P}^S \\neq \\mathrm{NP}^S$ for some sparse oracle $S$ would represent a more significant step towards resolving $\\mathrm{P}$ versus $\\mathrm{NP}$ than the original separating oracle from Baker-Gill-Solovay (which is dense). Which of the following statements provides the best justification for this belief?\n\nA. Sparse oracles are known to exist within the class $\\mathrm{P}$, so any separation using a sparse oracle would directly imply $\\mathrm{P} \\neq \\mathrm{NP}$.\n\nB. Proving a separation with a sparse oracle requires techniques that are inherently non-relativizing, as the very existence of a sparse oracle invalidates the premises of the Baker-Gill-Solovay theorem.\n\nC. The computational power of a nondeterministic machine is greatly enhanced by a dense oracle, as it can easily \"guess\" a witness string that is in the oracle. This advantage is significantly diminished with a sparse oracle, meaning a separation must rely on a more fundamental difference between $\\mathrm{P}$ and $\\mathrm{NP}$.\n\nD. All known real-world computational problems that are in $\\mathrm{NP}$ but suspected to not be in $\\mathrm{P}$ can be modeled using sparse oracles, but not dense oracles.\n\nE. A polynomial-time deterministic machine can generate a complete list of all strings belonging to a sparse oracle up to a given length, effectively neutralizing the oracle's utility for an $\\mathrm{NP}$ machine.",
            "solution": "We first recall the relevant formal definitions. For any oracle $A \\subseteq \\{0,1\\}^*$, $\\mathrm{P}^A$ is the set of decision problems solvable by a deterministic oracle Turing machine in time polynomial in the input length when allowed unit-time membership queries to $A$, and $\\mathrm{NP}^A$ is the analogous class with nondeterminism. The Baker-Gill-Solovay theorem gives oracles $O_1$ and $O_2$ with $\\mathrm{P}^{O_1}=\\mathrm{NP}^{O_1}$ and $\\mathrm{P}^{O_2} \\neq \\mathrm{NP}^{O_2}$, showing that techniques that relativize cannot resolve $\\mathrm{P}$ vs $\\mathrm{NP}$.\n\nAn oracle $S$ is sparse if there exists a polynomial $p$ such that for all $n \\in \\mathbb{N}$,\n$$\n|S \\cap \\{0,1\\}^{\\leq n}| \\leq p(n).\n$$\nBy contrast, a dense oracle typically has exponentially many strings of length at most $n$ in it. For example, the total number of binary strings of length at most $n$ is\n$$\n\\sum_{i=0}^{n} 2^i = 2^{n+1}-1,\n$$\nand a dense oracle may include a constant fraction of these, i.e., $\\Theta(2^n)$ many at length $n$.\n\nWe now analyze each proposed justification:\n\nA. The claim that “sparse oracles are known to exist within $\\mathrm{P}$” is true, but the conclusion “so any separation using a sparse oracle would directly imply $\\mathrm{P} \\neq \\mathrm{NP}$” only follows if the specific separating sparse oracle $S$ also satisfies $S \\in \\mathrm{P}$. The statement does not assert that the separating sparse oracle would be in $\\mathrm{P}$; moreover, the question asks for a justification of why such a result would be a more significant step, not that it would directly imply $\\mathrm{P} \\neq \\mathrm{NP}$. Thus A is not the right justification.\n\nB. Saying that a separation with a sparse oracle “requires techniques that are inherently non-relativizing” is incorrect. A proof that $\\mathrm{P}^S \\neq \\mathrm{NP}^S$ for a particular $S$ is still a relativized statement (it is about computation relative to that $S$), and does not by itself invalidate the relativization phenomenon nor force the use of non-relativizing techniques. Hence B is incorrect.\n\nC. A nondeterministic machine can leverage a dense oracle by existentially branching to guesses that are likely to hit oracle-positive strings, because there are exponentially many opportunities: if at length $n$ there are $\\Theta(2^n)$ oracle-positive strings, nondeterministic branching can take advantage of this abundance to certify membership using short oracle-positive witnesses. In contrast, with a sparse oracle, the number of oracle-positive strings up to length $n$ is bounded by $p(n)$, which is polynomial in $n$, so the nondeterministic machine cannot rely on the “abundance” of oracle-positive strings to gain power; any separation $\\mathrm{P}^S \\neq \\mathrm{NP}^S$ must then hinge on a more intrinsic difference between deterministic and nondeterministic computation rather than on a trivial density effect. This is the core heuristic for why a sparse-oracle separation would be a stronger indication toward resolving $\\mathrm{P}$ vs $\\mathrm{NP}$. Therefore C is the best justification.\n\nD. The assertion about “all known real-world NP problems” being modellable by sparse oracles and not dense ones is unfounded and incorrect; oracle modeling of real-world problems is not constrained in this way. Thus D is false.\n\nE. The property “sparse” bounds the count but says nothing about the decidability or efficient enumerability of membership. In an oracle setting, $S$ can be an arbitrary sparse set (even undecidable), and there is no general polynomial-time deterministic method to list $S \\cap \\{0,1\\}^{\\leq n}$ without oracle access. Hence E is false.\n\nFrom these analyses, option C provides the correct and most cogent justification.",
            "answer": "$$\\boxed{C}$$"
        }
    ]
}