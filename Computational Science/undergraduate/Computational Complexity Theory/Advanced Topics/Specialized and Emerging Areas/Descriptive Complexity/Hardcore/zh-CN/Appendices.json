{
    "hands_on_practices": [
        {
            "introduction": "描述复杂性的核心在于使用逻辑语言精确地刻画计算问题。本练习将从一个基础但重要的图属性——“无三角形”——入手，引导你将一个直观的图论概念转化为严格的一阶逻辑语句。通过这个过程，你将学会如何处理量词和等号，以确保逻辑表达的准确性，这是后续学习更复杂逻辑系统的基础。",
            "id": "1420797",
            "problem": "在与图论密切相关的网络分析领域，我们通常将网络建模为图，并使用形式语言来分析其性质。考虑一个简单的无向网络（一个图），其结构使用一阶逻辑（FO）来描述。论域是网络中所有节点（顶点）的集合。我们有一个二元谓词 $E(x, y)$，如果节点 $x$ 和节点 $y$ 之间存在链接（一条边），则该谓词为真，否则为假。\n\n关系 $E$ 是对称的，这意味着对于任意两个节点 $x$ 和 $y$，$E(x, y)$ 为真当且仅当 $E(y, x)$ 为真。然而，网络可能包含自环，因此关系 $E$ 不一定是非自反的（即，对于某个节点 $v$，$E(v, v)$ 可能为真）。\n\n网络中的“三角形”是指由三个*不同*的节点（比如 $u, v, w$）组成的集合，使得所有节点对之间都存在链接：$E(u, v)$、$E(v, w)$ 和 $E(w, u)$ 都为真。如果一个网络不包含任何这样的三角形，则称其为“无三角形的”。\n\n下列哪个一阶逻辑句子正确地表达了网络是无三角形的这一性质？\n\nA. $\\neg \\exists x \\exists y \\exists z (E(x, y) \\land E(y, z) \\land E(z, x))$\n\nB. $\\forall x \\forall y \\forall z ((E(x, y) \\land E(y, z)) \\to \\neg E(x, z))$\n\nC. $\\forall x \\forall y \\forall z ((E(x, y) \\land E(y, z) \\land E(z, x)) \\to (x=y \\lor x=z \\lor y=z))$\n\nD. $\\forall x \\forall y ((\\exists z (E(x,z) \\land E(z,y))) \\to E(x,y))$",
            "solution": "我们将“无三角形的”形式化为不存在三个不同的节点 $u,v,w$ 且它们之间所有三条边都存在这一情况的否定。在带等词的一阶逻辑中，这表示为：\n$$\n\\neg \\exists u \\exists v \\exists w \\,\\big(u \\neq v \\land v \\neq w \\land w \\neq u \\land E(u,v) \\land E(v,w) \\land E(w,u)\\big).\n$$\n等价地，我们可以用全称量词来陈述：只要 $E(x,y)$、$E(y,z)$ 和 $E(z,x)$ 都成立，那么 $x,y,z$ 中至少有两个必须相等：\n$$\n\\forall x \\forall y \\forall z \\,\\big((E(x,y) \\land E(y,z) \\land E(z,x)) \\to (x=y \\lor x=z \\lor y=z)\\big).\n$$\n现在我们来评估每个选项：\n\nA. $\\neg \\exists x \\exists y \\exists z (E(x, y) \\land E(y, z) \\land E(z, x))$。这禁止了任何满足这三条边的节点三元组（可能包含相等的节点）。因为允许自环，考虑一个包含自环 $E(a,a)$ 和一条边 $E(a,b)$ 的图。那么 $E(a,a) \\land E(a,b) \\land E(b,a)$ 成立，所以选项A会判定该图无效，尽管图中并没有由三个不同节点构成的三角形。因此，A的条件太强，不等价于“无三角形的”。\n\nB. $\\forall x \\forall y \\forall z ((E(x, y) \\land E(y, z)) \\to \\neg E(x, z))$。这个句子断言，任何长度为2的路径都不能被一条边封闭，这在无自环图中确实能表达无三角形的性质。然而，在允许自环的情况下，它的条件比无三角形更严格。例如，如果 $E(x,x)$ 和 $E(x,z)$ 成立，那么取 $y=x$ 就会得到 $E(x,y) \\land E(y,z)$，从而强制 $\\neg E(x,z)$ 成立，这导致了矛盾。因此，任何自环都会禁止任何邻接边，而这是无三角形性质所不要求的。所以，在这种情况下，B不等价于“无三角形的”。\n\nC. $\\forall x \\forall y \\forall z ((E(x, y) \\land E(y, z) \\land E(z, x)) \\to (x=y \\lor x=z \\lor y=z))$。这表示，只要 $x,y,z$ 之间的三条成对的边都存在，那么这三个节点中至少有两个是相等的。这恰好排除了由三个不同节点构成的三角形，同时允许了涉及相等或自环的退化情况。这与在可能存在自环的情况下的预期定义相匹配。因此，C正确地表达了“无三角形的”性质。\n\nD. $\\forall x \\forall y ((\\exists z (E(x,z) \\land E(z,y))) \\to E(x,y))$。这强制要求任何有两个共同邻居的节点都必须相邻，这保证了三角形的存在而不是禁止它们。除了在没有长度为2的路径的平凡情况下，这基本上是无三角形的反面。因此D是不正确的。\n\n所以，正确的句子是C。",
            "answer": "$$\\boxed{C}$$"
        },
        {
            "introduction": "掌握了如何用逻辑描述属性后，下一个关键问题是：一阶逻辑的表达能力极限在哪里？Ehrenfeucht-Fraïssé (EF) 博弈为我们提供了一个强大的工具来探索这个问题，它将逻辑区分能力转化为一个双人游戏。在这个练习中，你将扮演“破坏者”（Spoiler）的角色，主动寻找两个图结构（路径与环）之间的差异，从而直观地理解为何它们在一阶逻辑的特定量词深度下是可区分的。",
            "id": "1420779",
            "problem": "考虑两个简单无向图，$G_1$ 和 $G_2$。\n第一个图 $G_1$ 是一个路径图，其顶点集为 $V_1 = \\{p_1, p_2, p_3\\}$，边集为 $E_1 = \\{\\{p_1, p_2\\}, \\{p_2, p_3\\}\\}$。\n第二个图 $G_2$ 是一个圈图，其顶点集为 $V_2 = \\{c_1, c_2, c_3\\}$，边集为 $E_2 = \\{\\{c_1, c_2\\}, \\{c_2, c_3\\}, \\{c_3, c_1\\}\\}$。\n\n在这两个图上，由两位玩家 Spoiler 和 Duplicator 进行一场 Ehrenfeucht-Fraïssé (EF) 博弈。我们将考虑一个 2 轮的博弈。\n博弈规则如下：\n- 博弈分两轮进行。\n- 在每一轮 $i$（$i=1, 2$）中，Spoiler 从 $G_1$ 或 $G_2$ 中选择一个顶点。\n- Duplicator 必须在另一个图（Spoiler 没有选择的那个图）中选择一个顶点作为回应。\n- 设两轮后从 $G_1$ 中选出的顶点为 $v_1, v_2 \\in V_1$，从 $G_2$ 中选出的相应顶点为 $u_1, u_2 \\in V_2$。\n\n如果所选顶点之间的映射保持了图的结构，则 Duplicator 获胜。也就是说，对于 $G_1$ 中任意一对被选中的顶点，它们之间有边相连当且仅当它们在 $G_2$ 中的对应顶点之间也有边相连。如果游戏结束时此条件不满足，则 Spoiler 获胜。\n\nSpoiler 的目标是选择顶点，使得 Duplicator 无法维持这种结构对应关系。在 Duplicator 的任何回应下，以下哪个 Spoiler 的第一轮走法能保证 Spoiler 在这个 2 轮博弈中获胜？\n\nA. Spoiler 在图 $G_1$ 中选择顶点 $p_2$。\nB. Spoiler 在图 $G_2$ 中选择顶点 $c_2$。\nC. Spoiler 在图 $G_1$ 中选择顶点 $p_1$。\nD. 在 2 轮博弈中，Duplicator 有必胜策略，因此 Spoiler 没有任何第一轮走法能保证获胜。",
            "solution": "我们分析在 $G_{1}$（一个三顶点的路径）和 $G_{2}$（一个 3-圈）之间进行的 2 轮 Ehrenfeucht-Fraïssé 博弈。在标准的图上 EF 博弈中，Duplicator 必须在被选中的顶点之间维持一个部分同构，这要求同时保持相等关系和边关系。形式上，如果在两轮后 Spoiler 选中了 $v_{1},v_{2} \\in V_{1}$，Duplicator 选中了 $u_{1},u_{2} \\in V_{2}$，那么 Duplicator 获胜的条件是，对于所有的 $i,j \\in \\{1,2\\}$，满足：\n$$\nv_{i}=v_{j} \\iff u_{i}=u_{j}, \\quad \\text{and} \\quad E_{1}(v_{i},v_{j}) \\iff E_{2}(u_{i},u_{j}).\n$$\n\n关键的图属性：\n- 在 $G_{1}$ 中，$p_{2}$ 的度为 2，$p_{1},p_{3}$ 的度为 1，且 $E_{1}(p_{1},p_{3})$ 为假。\n- 在 $G_{2}$ 中，任意一对不同的顶点都是相邻的，因此对于不同的 $x,y \\in V_{2}$，$E_{2}(x,y)$ 为真。\n\n我们检查每一个被提议的第一轮走法。\n\nA. Spoiler 在 $G_{1}$ 中选择 $p_{2}$。Duplicator 用 $V_{2}$ 中的任意一个顶点 $c$ 来回应。在第二轮中，任何选择 $v_{2} \\in V_{1} \\setminus \\{p_{2}\\}$ 都满足 $E_{1}(p_{2},v_{2})$ 为真。Duplicator 可以选择 $u_{2} \\in V_{2} \\setminus \\{c\\}$，此时 $E_{2}(c,u_{2})$ 为真，从而保持了顶点的不等性和邻接性。Spoiler 无法在两轮内强制造成违例，所以这个第一轮走法不能保证 Spoiler 获胜。\n\nB. Spoiler 在 $G_{2}$ 中选择 $c_{2}$。Duplicator 可以用 $G_{1}$ 中的 $p_{2}$ 来回应。然后，对于 Spoiler 在第二轮中选择的任何与第一个顶点不同的顶点，在 $G_{2}$ 中的 $c_{2}$ 和在 $G_{1}$ 中的 $p_{2}$ 都与所有其他不同的顶点相邻。Duplicator 可以在回应中匹配邻接性和不等性，因此 Spoiler 无法在两轮内强制造成违例。所以这个第一轮走法不能保证获胜。\n\nC. Spoiler 在 $G_{1}$ 中选择 $p_{1}$。设 Duplicator 用 $V_{2}$ 中的任意顶点 $u_{1}$ 回应。然后 Spoiler 在 $G_{1}$ 中选择 $v_{2}=p_{3} \\neq p_{1}$，此时 $E_{1}(p_{1},p_{3})$ 为假。为了同时保持这两个条件，Duplicator 必须在 $V_{2}$ 中选择一个顶点 $u_{2}$，满足 $u_2 \\neq u_1$ 且 $E_2(u_1, u_2)$ 为假。然而，在 $G_{2}$ 中，任意一对不同的顶点都是相邻的，所以不存在这样的 $u_2$。如果 Duplicator 为了使 $E_2(u_1, u_2)$ 为假而选择 $u_2=u_1$，那么相等关系就无法保持，因为 $v_2 \\neq v_1$ 但 $u_2=u_1$。因此 Duplicator 无法维持部分同构，Spoiler 获胜。因此，这个第一轮走法保证 Spoiler 获胜。\n\nD. 这是错误的，因为选项 C 是一个能让 Spoiler 获胜的第一轮走法。\n\n因此，正确选项是 C。",
            "answer": "$$\\boxed{C}$$"
        },
        {
            "introduction": "我们已经通过EF博弈看到了普通一阶逻辑的局限性，例如它无法在所有图上定义连通性或可达性。为了克服这些限制，我们需要更强大的逻辑，例如不动点逻辑，而Datalog是其一种贴近实践的形式。本练习将指导你使用Datalog编写一个简单的程序来查找图中的所有环，这需要你定义递归的“可达性”关系，从而体会到递归是如何极大地增强逻辑的表达能力的。",
            "id": "1420810",
            "problem": "在计算机网络的分析中，识别循环依赖通常是必要的。考虑一个表示网络的有向图，其中节点是服务器，边表示单向数据链路。该网络结构由单个谓词 `Edge(u, v)` 描述，当且仅当存在从服务器 `u` 到服务器 `v` 的直接数据链路时，该谓词为真。\n\n如果存在一条从某个服务器出发并最终返回到该服务器的、由一个或多个链接组成的路径，则该服务器被认为是“反馈回路”或环路的一部分。你的任务是识别出正确的 Datalog 程序，该程序定义了一个新的谓词 `InCycle(x)`，对于属于至少一个环路的每个服务器 `x`，该谓词为真。\n\n在 Datalog 语法中，`:-` 表示逻辑蕴含（读作“if”），逗号表示逻辑与，变量由大写字母表示（例如，`X`、`Y`、`Z`）。\n\n下列哪个 Datalog 程序能正确识别所有属于环路的服务器？\n\nA.\n`Reaches(X, Y) :- Edge(X, Y).`\n`Reaches(X, Z) :- Reaches(X, Y), Edge(Y, Z).`\n`InCycle(X) :- Reaches(X, X).`\n\nB.\n`InCycle(X) :- Edge(X, X).`\n\nC.\n`Reaches(X, Y) :- Edge(X, Y).`\n`InCycle(X) :- Reaches(X, Y), Reaches(Y, X).`\n\nD.\n`InCycle(X) :- Edge(X, Y), InCycle(Y).`\n\nE.\n`Reaches(X, Y) :- Edge(X, Y).`\n`Reaches(X, Z) :- Reaches(X, Y), Edge(Y, Z).`\n`InCycle(X) :- Reaches(Y, X).`",
            "solution": "题目要求编写一个 Datalog 程序，以找出有向图中所有属于环路的节点。如果存在一条长度为一或更长的从节点 `X` 回到其自身的路径，则节点 `X` 位于一个环路中。让我们分析所需的逻辑，然后评估每个选项。\n\n**环路检测的核心逻辑**\n\n1.  **定义可达性：**首先，我们需要定义任意两个节点之间的路径或“可达性”概念。我们创建一个谓词 `Reaches(A, B)`，如果存在一条从节点 `A` 到节点 `B` 的长度至少为一的路径，则该谓词为真。这是一个经典的传递闭包问题。\n2.  **基本情况：**如果 `X` 和 `Y` 之间存在一条直接边，那么它们之间就存在一条长度为一的路径。在 Datalog 中，这表示为：\n    `Reaches(X, Y) :- Edge(X, Y).`\n3.  **递归步骤：**如果存在一条从 `X`到某个中间节点 `Y` 的路径，并且存在一条从 `Y` 到 `Z` 的直接边，那么就存在一条从 `X` 到 `Z` 的路径。这使我们能够将现有路径延长一条边。在 Datalog 中，这表示为：\n    `Reaches(X, Z) :- Reaches(X, Y), Edge(Y, Z).`\n    这两条规则一起正确地计算了 `Edge` 关系的传递闭包，意味着对于所有 `B` 可从 `A` 到达的节点对 `(A, B)`，`Reaches(A, B)` 都将为真。\n4.  **定义环路成员：**在正确定义了 `Reaches` 谓词后，如果一个节点 `X` 可以到达其自身，那么它就在一个环路中。这是对我们 `Reaches` 谓词的一个简单查询：\n    `InCycle(X) :- Reaches(X, X).`\n\n综合这些步骤，我们得到了完整的程序。现在让我们基于这个逻辑来分析给定的选项。\n\n**选项分析**\n\n*   **选项 A：**\n    `Reaches(X, Y) :- Edge(X, Y).`\n    `Reaches(X, Z) :- Reaches(X, Y), Edge(Y, Z).`\n    `InCycle(X) :- Reaches(X, X).`\n    这个程序与上面推导出的逻辑完全匹配。前两条规则计算了可达性关系（传递闭包），第三条规则正确地识别出，如果一个节点可以到达其自身，则该节点位于环路中。此程序是正确的。\n\n*   **选项 B：**\n    `InCycle(X) :- Edge(X, X).`\n    这个程序只识别具有自环（从节点到其自身的边）的节点。这对应于长度为 1 的环路。它无法找到属于更长环路（例如 `A - B - A`）的节点。因此，它是错误的。\n\n*   **选项 C：**\n    `Reaches(X, Y) :- Edge(X, Y).`\n    `InCycle(X) :- Reaches(X, Y), Reaches(Y, X).`\n    这个程序是有缺陷的，因为 `Reaches` 谓词没有被递归地定义。`Reaches` 的唯一规则是 `Reaches(X, Y) :- Edge(X, Y)`，这意味着 `Reaches` 与 `Edge` 是相同的。将此代入 `InCycle` 规则，得到 `InCycle(X) :- Edge(X, Y), Edge(Y, X)`。这个程序只能找到属于长度恰好为 2 的环路的节点。它会错过长度为 1 和长度为 3 或更长的环路。因此，它是错误的。\n\n*   **选项 D：**\n    `InCycle(X) :- Edge(X, Y), InCycle(Y).`\n    这是一个格式不正确的递归规则。Datalog 的求值工作原理是从已知事实（`Edge` 谓词）开始，并推导出新的事实。这个 `InCycle` 规则要求在右侧有一个 `InCycle` 事实才能在左侧推导出一个新的 `InCycle` 事实。由于没有“基本情况”规则可以仅从 `Edge` 事实中产生第一个 `InCycle` 事实，因此该程序将永远不会为 `InCycle` 产生任何输出。因此，它是错误的。\n\n*   **选项 E：**\n    `Reaches(X, Y) :- Edge(X, Y).`\n    `Reaches(X, Z) :- Reaches(X, Y), Edge(Y, Z).`\n    `InCycle(X) :- Reaches(Y, X).`\n    `Reaches` 谓词的定义是正确的。但是，`InCycle` 的规则在逻辑上是有缺陷的。`InCycle(X) :- Reaches(Y, X)` 表明，如果*任何*节点 `Y` 可以到达节点 `X`，那么节点 `X` 就位于一个环路中。在一个典型的连通图中，这几乎会将每个节点都标记为在环路中，这不符合环路成员的定义。一个节点 `X` 要在环路中，它必须能够到达*它自己*。这个规则没有强制执行这个条件。因此，它是错误的。\n\n根据分析，选项 A 是唯一一个正确定义了可达性，然后用它来识别可以到达自身的节点的程序。",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}