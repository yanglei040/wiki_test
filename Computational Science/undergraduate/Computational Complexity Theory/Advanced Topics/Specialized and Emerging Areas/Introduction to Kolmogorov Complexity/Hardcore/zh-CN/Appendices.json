{
    "hands_on_practices": [
        {
            "introduction": "要真正掌握柯尔莫哥洛夫复杂度的概念，最好的方法就是通过实践来探索其性质。我们从一个基本问题开始：一个简单的、可计算的操作（如数据复制）如何影响一个字符串的复杂度？通过分析一个字符串与其自身拼接后形成的新字符串之间的关系 ，我们可以建立起关于“可计算函数不会显著增加复杂度”这一核心原则的直观理解。",
            "id": "1429018",
            "problem": "在算法信息论（理论计算机科学的一个分支领域）中，我们用一个对象的最短可能描述的长度来量化其复杂度。对于一个有限二进制字符串 $x$，其柯尔莫哥洛夫复杂度（记为 $K(x)$）是相对于一个固定的通用图灵机 $U$ 定义的。它是指当作为输入提供给 $U$ 时，能使 $U$ 输出字符串 $x$ 然后停机的最短程序 $p$ 的长度（以比特为单位）。形式上，$K(x) = \\min\\{|p| : U(p)=x\\}$。虽然 $K(x)$ 的确切值取决于所选择的通用图灵机 $U$，但复杂度理论中的关键关系，如上界和下界，在相差一个加性常数的范围内是成立的。\n\n考虑一个数据处理任务，其中一个二进制字符串 $x$ 与其自身连接形成一个新的字符串 $xx$。这是数据冗余的一个简单模型。我们关心这个新的、更长的字符串的复杂度。\n\n对于任何二进制字符串 $x$，以下哪个不等式表示字符串 $xx$ 的柯尔莫哥洛夫复杂度的最紧一般上界？在这些表达式中，$c$ 表示一个正常数，其值仅取决于通用图灵机 $U$ 的选择，而与字符串 $x$ 或其属性无关。\n\nA. $K(xx) \\le K(x) + c$\n\nB. $K(xx) \\le 2K(x) + c$\n\nC. $K(xx) \\le K(x)^2 + c$\n\nD. $K(xx) \\le K(x) + c \\log_2(|x|)$\n\nE. $K(xx) \\le |x| + c$",
            "solution": "对于任何全可计算函数 $f$，存在一个常数 $c_{f}$（仅取决于 $f$ 和 $U$），使得\n$$\nK(f(x)) \\leq K(x) + c_{f} 。\n$$\n这个标准的上界推导如下：设 $p$ 是 $x$ 的一个最短 $U$-程序，所以 $|p| = K(x)$ 且 $U(p)=x$。我们固定一个常数长度的程序 $r_{f}$，其长度为 $|r_{f}|=c_{f}$。该程序在给定某个程序 $p$ 的描述后，会模拟 $U(p)$ 以获得 $x$，然后计算并输出 $f(x)$。考虑连接后的代码 $r_{f}p$（由于我们使用前缀无关的描述，其格式是正确的），其长度为 $|r_{f}p| = |r_{f}| + |p| = c_{f} + K(x)$，并能使 $U$ 输出 $f(x)$。因此\n$$\nK(f(x)) \\leq |r_{f}p| = K(x) + c_{f} 。\n$$\n\n将此应用于函数 $f(y)=yy$（字符串复制）。由于 $f$ 是全可计算的，因此存在一个常数 $c$，使得\n$$\nK(xx) \\leq K(x) + c 。\n$$\n\n这个界在一个加性常数的范围内是紧的：定义 $g(z)$ 为返回 $z$ 前半部分的函数。那么 $g$ 是全可计算的且 $g(xx)=x$，因此根据相同的推理，存在一个常数 $c'$ 使得\n$$\nK(x) \\leq K(xx) + c' 。\n$$\n因此 $K(xx) \\geq K(x) - c'$。结合上界可知，通常情况下 $K(xx) = K(x) \\pm O(1)$。在给定的选项中，这使得选项 A 成为最紧的一般上界；选项 B、C、D 和 E 则更宽松，因为它们分别比 $K(x)+c$ 多出了一个额外的 $K(x)$ 项、一个二次项、一个增长的 $\\log_{2}(|x|)$ 项，或者将 $K(x)$ 替换为通常远大于它的 $|x|$。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "在理解了对单个字符串的操作后，我们自然会想知道如何关联两个不同字符串的复杂度。这个练习引入了条件柯尔莫哥洛夫复杂度的概念，即在已知一个字符串 $x$ 的情况下生成另一个字符串 $y$ 的最小程序长度。通过一个具体的构造过程 ，我们将推导出柯尔莫哥洛夫复杂度的“链式法则”的一个重要不等式，它构成了算法信息论的基石。",
            "id": "1429002",
            "problem": "在算法信息的理论研究中，一个通用计算系统由一台机器 $U$ 建模，它接受一个程序（一个二进制字符串 $p$）和一个输入（一个二进制字符串 $i$），并产生一个输出字符串 $U(p, i)$。\n\n一个字符串 $s$ 的柯尔莫哥洛夫复杂度，记作 $K(s)$，是在没有输入的情况下产生 $s$ 的最短程序 $p$ 的长度。也就是说，$K(s) = \\min\\{|p| : U(p, \\epsilon) = s\\}$，其中 $\\epsilon$ 是空字符串。\n\n给定字符串 $x$ 的情况下，字符串 $y$ 的条件柯尔莫哥洛夫复杂度，记作 $K(y|x)$，是在给定 $x$ 作为输入时产生 $y$ 的最短程序 $p$ 的长度。也就是说，$K(y|x) = \\min\\{|p| : U(p, x) = y\\}$。\n\n为了组合计算任务，我们引入一种特殊的“序列器”结构。这是一个预定义的程序前缀，我们称之为 $S$，其长度固定为 $|S| = c$。该前缀用于从两个较小的程序 $p_1$ 和 $p_2$ 构建一个较大的程序 $P_{new}$，如下所示：$P_{new} = S \\cdot p_1' \\cdot p_2'$，其中 $\\cdot$ 表示字符串连接。项 $p_1'$ 和 $p_2'$ 是程序 $p_1$ 和 $p_2$ 的自定界编码。对于任何长度为 $n$ 的二进制字符串 $q$，其自定界编码为 $q' = 1^n0q$（$n$ 个 1，后跟一个 0，再后跟 $q$），总长度为 $2n+1$。\n\n复合程序 $P_{new}$ 的行为定义如下：当在没有输入的情况下运行时，它首先在没有输入的情况下执行 $p_1$，生成一个中间字符串 $x_{\\text{int}} = U(p_1, \\epsilon)$。然后它使用 $x_{\\text{int}}$ 作为输入来执行 $p_2$，生成最终输出 $y_{\\text{final}} = U(p_2, x_{\\text{int}})$。\n\n这个序列器结构的存在，为任意两个字符串 $x$ 和 $y$ 建立 $K(y)$ 的一个上界提供了一种方法。这个上界可以表示为 $A \\cdot K(x) + B \\cdot K(y|x) + C \\cdot c + D$ 的形式，其中 $A, B, C, D$ 是整数常数。请确定整数常数 $(A, B, C, D)$ 的值。",
            "solution": "我们给定一台通用机器 $U$、一个长度固定为 $|S|=c$ 的序列器前缀 $S$，以及任何程序 $q$ 的自定界编码 $q'=1^{|q|}0q$（其长度为 $|q'|=2|q|+1$）。对于任意两个字符串 $x$ 和 $y$，令 $p_{1}$ 为在空输入上输出 $x$ 的最短程序，因此 $|p_{1}|=K(x)$ 且 $U(p_{1},\\epsilon)=x$；令 $p_{2}$ 为在输入 $x$ 上输出 $y$ 的最短程序，因此 $|p_{2}|=K(y|x)$ 且 $U(p_{2},x)=y$。\n\n我们构建复合程序：\n$$\nP_{\\text{new}} \\;=\\; S \\cdot p_{1}' \\cdot p_{2}' \\, .\n$$\n根据序列器的指定行为，当 $U$ 在空输入上运行 $P_{\\text{new}}$ 时，它首先在空输入上执行 $p_{1}$ 产生 $x_{\\text{int}}=U(p_{1},\\epsilon)=x$，然后以 $x_{\\text{int}}=x$ 为输入执行 $p_{2}$ 产生 $y_{\\text{final}}=U(p_{2},x)=y$。因此，$U(P_{\\text{new}},\\epsilon)=y$，所以根据柯尔莫哥洛夫复杂度的定义，\n$$\nK(y) \\;\\leq\\; |P_{\\text{new}}| \\, .\n$$\n$P_{\\text{new}}$ 的长度是：\n$$\n|P_{\\text{new}}| \\;=\\; |S| + |p_{1}'| + |p_{2}'| \\;=\\; c + (2|p_{1}|+1) + (2|p_{2}|+1) \\;=\\; c + 2|p_{1}| + 2|p_{2}| + 2 \\, .\n$$\n代入 $|p_{1}|=K(x)$ 和 $|p_{2}|=K(y|x)$ 可得：\n$$\nK(y) \\;\\leq\\; 2K(x) + 2K(y|x) + c + 2 \\, .\n$$\n这符合 $A\\cdot K(x) + B\\cdot K(y|x) + C\\cdot c + D$ 的形式，其中整数常数为：\n$$\nA=2,\\quad B=2,\\quad C=1,\\quad D=2 \\, .\n$$",
            "answer": "$$\\boxed{\\begin{pmatrix}2  2  1  2\\end{pmatrix}}$$"
        },
        {
            "introduction": "现在，让我们应用条件复杂度的概念来区分“结构化”字符串和“随机”字符串。一个高度结构化的字符串，即使很长，其内在信息量也可能很小。这个练习  探讨了形式语言理论中一个经典的例子——由 $n$ 个0后跟 $n$ 个1组成的字符串，并展示了在给定其长度这一微小提示后，其复杂度如何急剧下降。这完美地揭示了柯尔莫哥洛夫复杂度如何精确地量化了模式和可压缩性。",
            "id": "1429003",
            "problem": "在算法信息论中，一个字符串 $s$ 的柯尔莫哥洛夫复杂度，记作 $K(s)$，是能输出 $s$ 的最短计算机程序的长度。这代表了该字符串的极限压缩大小。条件柯尔莫哥洛夫复杂度 $K(s \\mid y)$ 是在给定输入 $y$ 的情况下，能输出 $s$ 的最短程序的长度。对于这些定义，我们假设存在一个固定的、最优的、通用的编程语言（或等价地，一个通用图灵机）。\n\n考虑上下文无关语言 $L = \\{0^n 1^n \\mid n \\ge 1\\}$，它由一个或多个零组成的块后跟等量的一组成的所有字符串构成。\n\n令 $x$ 是一个已知属于语言 $L$ 的字符串。当长度 $|x|$ 任意增大时，对于所有这样的字符串 $x$，以下哪个陈述为其条件柯尔莫哥洛夫复杂度 $K(x \\mid |x|)$ 提供了最紧且最准确的上界？在以下选项中，$c$、$c_1$ 和 $c_2$ 代表正常数，其值与具体字符串 $x$ 无关。\n\nA. $K(x \\mid |x|) \\le c_1 |x|^{1/2} + c_2$\n\nB. $K(x \\mid |x|) \\ge c_1 |x| - c_2$\n\nC. $K(x \\mid |x|) \\le c$\n\nD. $K(x \\mid |x|) \\le c_1 \\log_{2}(|x|) + c_2$",
            "solution": "令 $L=\\{0^{n}1^{n}\\mid n\\ge 1\\}$ 且 $x\\in L$。那么存在一个 $n\\ge 1$ 使得 $x=0^{n}1^{n}$，因此 $|x|=2n$。于是，给定长度 $|x|$，则 $n$ 的值由下式确定：\n$$\nn=\\frac{|x|}{2}.\n$$\n根据相对于一个固定的最优通用机 $U$ 的条件柯尔莫哥洛夫复杂度的定义，我们有：\n$$\nK(x\\mid y)=\\min\\{|p|:\\;U(p,y)=x\\}.\n$$\n考虑以下固定程序 $p$（高层次描述）：对于输入的整数 $m$，计算 $m/2$ 并输出 $0^{m/2}1^{m/2}$。程序 $p$ 的代码与 $m$ 和 $x$ 均无关，因此 $|p|$ 是一个常数。对于任何长度为 $|x|=m$ 的字符串 $x\\in L$，将 $|x|$ 作为输入提供给程序 $p$ 会产生 $x$，即 $U(p,|x|)=x$。因此，\n$$\nK(x\\mid |x|)\\le |p|=c,\n$$\n其中 $c$ 是一个常数，它只依赖于通用机的选择和这个固定程序，而与 $x$ 和 $|x|$ 无关。因此，对于所有 $x\\in L$，$K(x\\mid |x|)$ 存在一个不随 $|x|$ 变化的常数上界。\n\n在给定的选项中，陈述 C 精确地断言了这个常数上界。陈述 A 和 D 提供了随 $|x|$ 增长的更弱（更松）的上界，而陈述 B 是一个下界，而非上界。由于对于每个偶数长度，在 $L$ 中恰好只有一个字符串，这个常数界是渐近紧的，只相差一个由通用机选择所决定的加性常数。\n\n因此，在这些选项中，最紧且最准确的上界是常数界。",
            "answer": "$$\\boxed{C}$$"
        }
    ]
}