{
    "hands_on_practices": [
        {
            "introduction": "在交互式证明系统中，理解证明者（Merlin）的目标至关重要。Merlin 的任务始终是说服验证者（Arthur）接受，但“接受”的含义取决于我们讨论的是 MA 还是 co-MA。这个问题  使用一个经典的图论问题——哈密顿环路，来具体阐释证明一个断言为“是”（属于 MA）与证明其为“否”（属于 co-MA）之间的根本区别。",
            "id": "1452866",
            "problem": "考虑语言 $L_{SI}$，它由所有图的有序对 $(G_1, G_2)$ 组成，其中 $G_1$ 和 $G_2$ 是简单无向图，且 $G_2$ 同构于 $G_1$ 的一个子图。\n\n假设为该语言设计了两个独立的交互式证明系统，两者都包含一个计算能力有限的概率验证者 (Arthur) 和一个全能但不可信的证明者 (Merlin)。设一个具体实例由对 $(H, C)$ 给出，其中 $H$ 是一个有 $n$ 个顶点的图，而 $C$ 是 $n$ 个顶点的圈图 $C_n$。对实例 $(H, C) \\in L_{SI}$ 回答“是”，等价于判断 $H$ 是否有一个哈密顿圈。\n\n系统 1 是为语言 $L_{SI}$ 设计的 MA (Merlin-Arthur) 协议。\n系统 2 是为语言 $L_{SI}$ 设计的 co-MA 协议。\n\n在两个系统中，Merlin 都为实例 $(H, C)$ 向 Arthur 发送一个证明字符串。然后 Arthur 使用该实例和 Merlin 的证明运行其随机多项式时间算法，并决定是接受还是拒绝。\n\n在每个系统中，下列哪个陈述最准确地描述了证明者 Merlin 为 Arthur 构建证明时的主要目标？\n\nA. 在系统 1 中，Merlin 的目标是提供一个证明，以帮助说服 Arthur 相信 $H$ 不存在哈密顿圈。在系统 2 中，Merlin 的目标是提供一个证明，以帮助说服 Arthur 相信 $H$ 确实存在哈密顿圈。\n\nB. 在系统 1 和系统 2 中，Merlin 的目标都是提供一个证明，以帮助说服 Arthur 相信 $H$ 确实存在哈密顿圈。\n\nC. 在系统 1 中，Merlin 的目标是提供一个证明，以帮助说服 Arthur 相信 $H$ 确实存在哈密顿圈。在系统 2 中，Merlin 的目标是提供一个证明，以帮助说服 Arthur 相信 $H$ 不存在哈密顿圈。\n\nD. 在系统 1 和系统 2 中，Merlin 的目标都是提供一个证明，以帮助说服 Arthur 相信 $H$ 不存在哈密顿圈。\n\nE. Merlin 的目标取决于 $H$ 是否真的有哈密顿圈。如果有，他会尝试证明其存在；如果没有，他会尝试证明其不存在，而与系统无关。",
            "solution": "问题要求在两种不同类型的交互式证明系统（MA 和 co-MA）中，针对特定语言 $L_{SI}$ 和实例 $(H, C)$，确定证明者 (Merlin) 的目标。关键在于理解复杂度类 MA 和 co-MA 的定义。\n\n一个 MA 协议由一个证明者 (Merlin) 向一个概率多项式时间验证者 (Arthur) 发送一个证明组成。验证者的决定确定了实例是否属于该语言。\n\n步骤 1：分析 Merlin 在系统 1 (MA 协议) 中的目标。\n对于一个语言 $L$，类 MA (Merlin-Arthur) 的定义如下：\n- **完备性：** 如果一个实例 $x$ 在 $L$ 中 ($x \\in L$)，必须存在一个 Merlin 可以发送的证明 $y$，使得 Arthur 以高概率（例如 $\\ge 2/3$）接受。\n- **可靠性：** 如果一个实例 $x$ 不在 $L$ 中 ($x \\notin L$)，对于 Merlin 发送的任何证明 $y$，Arthur 都必须以低概率（例如 $\\le 1/3$）接受。\n\n在这个框架中，Merlin 的目标始终是让 Arthur 接受。Arthur 的接受被解释为对实例是否属于该语言的“是”回答。\n对于系统 1，该协议是为语言 $L_{SI}$ 设计的。Merlin 想要说服 Arthur 实例 $(H, C)$ 在 $L_{SI}$ 中。如问题所述，$(H, C) \\in L_{SI}$ 等价于陈述“$H$ 有一个哈密顿圈”。\n因此，在系统 1 中，Merlin 的目标是提供一个证明，以帮助说服 Arthur 相信 $H$ 确实有一个哈密顿圈。\n\n步骤 2：分析 Merlin 在系统 2 (co-MA 协议) 中的目标。\n类 co-MA 是其补集在 MA 中的语言类。也就是说，当且仅当 $\\bar{L} \\in \\text{MA}$ 时，有 $L \\in \\text{co-MA}$。\n根据定义，一个语言 $L$ 的 co-MA 协议就是其补集 $\\bar{L}$ 的一个 MA 协议。\n\n对于系统 2，该协议是为 $L_{SI}$ 设计的 co-MA 协议。这意味着它是一个针对语言 $\\bar{L}_{SI}$ 的 MA 协议。语言 $\\bar{L}_{SI}$ 由所有图的对 $(G_1, G_2)$ 组成，其中 $G_2$ *不*同构于 $G_1$ 的一个子图。\n在这个针对 $\\bar{L}_{SI}$ 的 MA 协议中，Merlin 的目标仍然是让 Arthur 接受。然而，此时 Arthur 的接受表示该实例在 $\\bar{L}_{SI}$ 中。\n所以，Merlin 想要说服 Arthur 实例 $(H, C)$ 在 $\\bar{L}_{SI}$ 中。陈述 $(H, C) \\in \\bar{L}_{SI}$ 等价于“$H$ 没有哈密顿圈”。\n因此，在系统 2 中，Merlin 的目标是提供一个证明，以帮助说服 Arthur 相信 $H$ 不存在哈密顿圈。\n\n步骤 3：结合结果并选择正确的选项。\n从步骤 1 可知，在系统 1 (MA) 中，Merlin 的目标是证明 $H$ 有一个哈密顿圈。\n从步骤 2 可知，在系统 2 (co-MA) 中，Merlin 的目标是证明 $H$ 不存在哈密顿圈。\n\n我们来检查给出的选项：\nA. 错误。它颠倒了系统 1 和系统 2 的目标。\nB. 错误。它声称两个系统中的目标相同，都是证明圈的存在性。\nC. 正确。它指出在系统 1 中，目标是证明存在性，而在系统 2 中，目标是证明不存在性。这与我们的分析相符。\nD. 错误。它声称两个系统中的目标相同，都是证明圈的不存在性。\nE. 错误。这个选项误解了 Merlin 的角色。Merlin 的目标是由协议（MA 或 co-MA）固定的，而不是由陈述的实际真假决定的。在任何交互式协议中，Merlin 的目标都是让 Arthur 接受。“接受”的含义在 MA 和 co-MA 协议之间是不同的。\n\n因此，唯一准确描述 Merlin 在两个系统中目标的陈述是 C。",
            "answer": "$$\\boxed{C}$$"
        },
        {
            "introduction": "一个强大的复杂性类的标志是它在基本运算下的闭包性。这个练习  探讨了 MA 类是否对并集运算封闭，这是一个核心的结构性质。通过设计一个正确的协议，你需要仔细评估不同的验证者策略，以确保新协议同时满足 MA 定义中的完备性（completeness）和可靠性（soundness）要求。",
            "id": "1452910",
            "problem": "在计算复杂性理论中，MA 类（Merlin-Arthur 的缩写）代表了可通过一类特殊交互式协议解决的判定问题的集合。该协议涉及一个计算能力有限的概率性验证者（Arthur）和一个全能但不可信的证明者（Merlin）。对于一个语言 $L$ 要属于 MA 类，其协议必须满足两个性质：\n\n1.  **完备性 (Completeness)：** 对于语言中的任何输入串 $x$ ($x \\in L$)，存在一个证明串 $y$，Merlin 可以提供给 Arthur，使得 Arthur 以至少 $2/3$ 的概率接受 $x$。\n2.  **可靠性 (Soundness)：** 对于不在语言中的任何输入串 $x$ ($x \\notin L$)，对于 Merlin 提供的任何证明串 $y$，Arthur 以至多 $1/3$ 的概率接受 $x$。\n\n假设给定两个语言 $L_1$ 和 $L_2$，并且我们知道它们都属于 MA 类。设它们各自的多项式时间验证者分别为 $A_1$ 和 $A_2$。我们希望为这两个语言的并集 $L = L_1 \\cup L_2$ 设计一个新的 MA 协议。在为 $L$ 设计的协议中，Merlin 发送一个形式为 $y = (b, y')$ 的复合证明，其中 $b$ 是一个比特（$b \\in \\{1, 2\\}$），指示 Merlin 声称 $x$ 属于哪个语言（$L_1$ 或 $L_2$），而 $y'$ 是对所声称语言的相应证明。\n\n对于新的验证者 $A$ 来说，以下哪种策略通过满足完备性和可靠性条件，正确地为 $L = L_1 \\cup L_2$ 实现了一个有效的 MA 协议？\n\nA. $A$ 检查比特 $b$。如果 $b=1$，$A$ 执行 $A_1(x, y')$ 并返回其判定结果。如果 $b=2$，$A$ 执行 $A_2(x, y')$ 并返回其判定结果。\nB. $A$ 忽略比特 $b$。它抛掷一枚均匀的硬币，设结果为 $i \\in \\{1,2\\}$。然后它执行 $A_i(x, y')$ 并返回其判定结果。\nC. $A$ 忽略比特 $b$。它同时执行 $A_1(x, y')$ 和 $A_2(x, y')$。当且仅当 $A_1$ 和 $A_2$ 都接受时，它才接受。\nD. $A$ 忽略比特 $b$。它同时执行 $A_1(x, y')$ 和 $A_2(x, y')$。如果 $A_1$ 或 $A_2$ 中至少有一个接受，它就接受。",
            "solution": "为了确定新验证者 $A$ 的正确策略，我们必须分析每个选项，看它是否满足 MA 类语言所要求的完备性和可靠性。目标语言是 $L = L_1 \\cup L_2$。针对 $L_1$ 的验证者 $A_1$ 和针对 $L_2$ 的验证者 $A_2$ 的完备性概率 $\\ge 2/3$，可靠性概率 $\\le 1/3$。\n\n**策略 A 的分析：**\n验证者 $A$ 遵循 Merlin 的指令比特 $b$。\n*   **完备性：** 假设输入串 $x$ 在 $L$ 中，即 $x \\in L_1$ 或 $x \\in L_2$。\n    *   情况 1: $x \\in L_1$。由于 $L_1 \\in \\text{MA}$，存在一个证明 $y_1'$ 使得 $\\Pr[A_1(x, y_1') = \\text{accept}] \\ge 2/3$。一个诚实的 Merlin 想要说服 Arthur，所以他会发送证明 $y = (1, y_1')$。验证者 $A$ 会看到 $b=1$ 并运行 $A_1(x, y_1')$，以 $\\ge 2/3$ 的概率接受。\n    *   情况 2: $x \\in L_2$。类似地，存在一个证明 $y_2'$ 使得 $\\Pr[A_2(x, y_2') = \\text{accept}] \\ge 2/3$。Merlin 会发送 $y = (2, y_2')$。验证者 $A$ 会看到 $b=2$ 并运行 $A_2(x, y_2')$，以 $\\ge 2/3$ 的概率接受。\n    由于对于任何 $x \\in L$，Merlin 都可以提供一个导致接受概率至少为 $2/3$ 的证明，因此完备性条件得到满足。\n*   **可靠性：** 假设输入串 $x$ 不在 $L$ 中，即 $x \\notin L_1$ 并且 $x \\notin L_2$。Merlin 是不可信的，会试图欺骗 Arthur。Merlin 发送某个证明 $y=(b, y')$。\n    *   情况 1: Merlin 选择 $b=1$。验证者 $A$ 运行 $A_1(x, y')$。由于 $x \\notin L_1$，根据 $A_1$ 的可靠性，对于 Merlin 提供的任何证明 $y'$，都有 $\\Pr[A_1(x, y') = \\text{accept}] \\le 1/3$。\n    *   情况 2: Merlin 选择 $b=2$。验证者 $A$ 运行 $A_2(x, y')$。由于 $x \\notin L_2$，根据 $A_2$ 的可靠性，对于 Merlin 提供的任何证明 $y'$，都有 $\\Pr[A_2(x, y') = \\text{accept}] \\le 1/3$。\n    Merlin 必须选择这些选项之一。无论哪种情况，让 Arthur 接受的最大概率都是 $1/3$。因此，对于任何 $x \\notin L$，对于来自 Merlin 的任何证明 $y$，接受概率都 $\\le 1/3$。可靠性条件得到满足。\n**结论：** 策略 A 是一个有效的 MA 协议。\n\n**策略 B 的分析：**\n验证者 $A$ 忽略 $b$ 并随机选择一个验证者。\n*   **完备性：** 假设 $x \\in L_1$ 但 $x \\notin L_2$。一个诚实的 Merlin 会为 $L_1$ 提供有效的证明 $y_1'$（他可以为 $b$ 设置任何比特，因为它被忽略了）。验证者 $A$ 抛掷一枚硬币。\n    *   以 $1/2$ 的概率，$A$ 选择运行 $A_1(x, y_1')$。在这个分支中，接受的概率 $\\ge 2/3$。\n    *   以 $1/2$ 的概率，$A$ 选择运行 $A_2(x, y_1')$。由于 $x \\notin L_2$，无论证明 $y_1'$ 是什么，这个分支中接受的概率都 $\\le 1/3$。\n    总的接受概率是这些独立事件概率的和：\n    $\\Pr[A \\text{ accepts}] = \\frac{1}{2} \\Pr[A_1(x, y_1')=\\text{accept}] + \\frac{1}{2} \\Pr[A_2(x, y_1')=\\text{accept}]$。\n    使用这些界限，这个概率大约为 $\\frac{1}{2} \\cdot \\frac{2}{3} + \\frac{1}{2} \\cdot \\frac{1}{3} = \\frac{1}{3} + \\frac{1}{6} = \\frac{1}{2}$。\n    $1/2$ 的接受概率不满足 $\\ge 2/3$。因此，完备性条件不成立。\n\n**策略 C 的分析：**\n验证者 $A$ 仅当 $A_1$ 和 $A_2$ 都接受时才接受。\n*   **完备性：** 再次假设 $x \\in L_1$ 但 $x \\notin L_2$。Merlin 提供一个证明 $y'$。要被接受， $A_1(x, y')$ 和 $A_2(x, y')$ 都必须接受。然而，由于 $x \\notin L_2$，无论 $y'$ 是什么，$A_2$ 接受的概率最多为 $1/3$。\n    $\\Pr[A_1 \\text{ accepts AND } A_2 \\text{ accepts}] \\le \\Pr[A_2 \\text{ accepts}] \\le 1/3$。\n    $\\le 1/3$ 的接受概率不满足 $\\ge 2/3$。完备性条件不成立。\n\n**策略 D 的分析：**\n验证者 $A$ 如果 $A_1$ 或 $A_2$ 中至少有一个接受，就接受。\n*   **可靠性：** 假设 $x \\notin L_1$ 且 $x \\notin L_2$。恶意的 Merlin 可以设计一个证明 $y'$ 来试图欺骗任何一个验证者。如果 $A_1(x, y')$ 接受或 $A_2(x, y')$ 接受，验证者 $A$ 就会接受。我们使用概率的并集界 (union bound)：\n    $\\Pr[A_1 \\text{ accepts OR } A_2 \\text{ accepts}] \\le \\Pr[A_1 \\text{ accepts}] + \\Pr[A_2 \\text{ accepts}]$。\n    由于 $x \\notin L_1$ 且 $x \\notin L_2$，对于任何证明 $y'$，我们有 $\\Pr[A_1(x, y')=\\text{accept}] \\le 1/3$ 和 $\\Pr[A_2(x, y')=\\text{accept}] \\le 1/3$。\n    因此，$\\Pr[A \\text{ accepts}] \\le 1/3 + 1/3 = 2/3$。\n    对于一个“否”实例，高达 $2/3$ 的接受概率违反了可靠性条件，该条件要求概率最多为 $1/3$。可靠性条件不成立。\n\n只有策略 A 同时满足 MA 协议的完备性和可靠性。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "在前一个练习的基础上，我们从协议的逻辑结构转向其概率分析。这个问题  要求你为一个属于两个 MA 语言交集的输入构建证明，并量化分析组合协议的成功概率。通过计算完备性和可靠性概率如何变化，你将更深入地理解 MA 类所固有的概率特性。",
            "id": "1452890",
            "problem": "一个由语言 $L$ 表示的判定问题，如果存在一个概率多项式时间图灵机 $V$（称为验证者 Arthur）和一个多项式 $p(n)$，对于任意长度为 $n$ 的输入串 $x$ 满足以下条件，则该问题属于复杂度类 Merlin-Arthur (MA)：\n1.  **完备性**：如果 $x \\in L$，则存在一个长度至多为 $p(n)$ 的证明串 $y$（由一个全能但不可信的证明者 Merlin 提供），使得 $V$ 以至少 $2/3$ 的概率接受对 $(x, y)$。\n2.  **可靠性**：如果 $x \\notin L$，对于所有长度至多为 $p(n)$ 的可能证明串 $y$，$V$ 以至多 $1/3$ 的概率接受对 $(x, y)$。\n\n考虑两个语言 $L_1$ 和 $L_2$，它们都属于 MA 类。设它们各自的验证者为 $V_1$ 和 $V_2$，它们满足上述概率的 MA 条件。为了证明它们的交集 $L = L_1 \\cap L_2$ 也属于 MA 类，我们构建一个新的协议。在此协议中，Merlin 提供一个单一的证明串 $y$，该证明串是 $L_1$ 的证明 $y_1$ 和 $L_2$ 的证明 $y_2$ 的串接。新的验证者 $V$ 在收到输入 $x$ 和串接的证明 $y=(y_1, y_2)$ 后，使用独立的随机比特分别运行 $V_1(x,y_1)$ 和 $V_2(x,y_2)$。验证者 $V$ 当且仅当 $V_1$ 和 $V_2$ 都接受时才接受。\n\n令 $P_C$ 为这个针对语言 $L = L_1 \\cap L_2$ 的新协议的最小完备性概率，$P_S$ 为其最大可靠性概率。计算表达式 $9 P_C - 3 P_S$ 的值。",
            "solution": "给定两个 MA 类中的语言，其验证者满足完备性至少为 $2/3$、可靠性至多为 $1/3$。针对 $L=L_{1}\\cap L_{2}$ 的组合协议使用一个串接的证明 $y=(y_{1},y_{2})$，并使用独立的随机比特运行 $V_{1}(x,y_{1})$ 和 $V_{2}(x,y_{2})$，当且仅当两者都接受时才接受。\n\n根据每个语言的完备性条件，对于 $x\\in L$，存在证明 $y_{1}$ 和 $y_{2}$ 使得\n$$\n\\Pr[V_{1}(x,y_{1})\\text{ accepts}] \\ge \\frac{2}{3},\\quad \\Pr[V_{2}(x,y_{2})\\text{ accepts}] \\ge \\frac{2}{3}.\n$$\n由于两次运行使用独立的随机比特，且接受事件依赖于不相交的随机性，因此联合接受概率是两者的乘积：\n$$\n\\Pr[V\\text{ accepts }(x,y)] \\;=\\; \\Pr[V_{1}\\text{ accepts}]\\cdot \\Pr[V_{2}\\text{ accepts}] \\;\\ge\\; \\left(\\frac{2}{3}\\right)\\left(\\frac{2}{3}\\right) \\;=\\; \\frac{4}{9}.\n$$\n因此，组合协议的最小完备性概率为\n$$\nP_{C}=\\frac{4}{9}.\n$$\n\n对于可靠性，取任意 $x\\notin L=L_{1}\\cap L_{2}$。那么 $x\\notin L_{1}$ 或 $x\\notin L_{2}$ 至少有一个成立。假设 $x\\notin L_{1}$。那么对于所有的 $y_{1}$，\n$$\n\\Pr[V_{1}(x,y_{1})\\text{ accepts}] \\le \\frac{1}{3}.\n$$\n对于任意的 $y_{2}$，由于 $V_{1}$ 和 $V_{2}$ 使用的随机比特是独立的，\n$$\n\\Pr[V\\text{ accepts }(x,y)] \\;=\\; \\Pr[V_{1}\\text{ accepts}]\\cdot \\Pr[V_{2}\\text{ accepts}] \\;\\le\\; \\left(\\frac{1}{3}\\right)\\cdot 1 \\;=\\; \\frac{1}{3},\n$$\n因为 $\\Pr[V_{2}\\text{ accepts}] \\le 1$。如果 $x\\notin L_{2}$，同样的界限也成立。因此，组合协议的最大可靠性概率为\n$$\nP_{S}=\\frac{1}{3}.\n$$\n\n最后，计算\n$$\n9P_{C}-3P_{S} \\;=\\; 9\\cdot \\frac{4}{9} \\;-\\; 3\\cdot \\frac{1}{3} \\;=\\; 4-1 \\;=\\; 3.\n$$",
            "answer": "$$\\boxed{3}$$"
        }
    ]
}