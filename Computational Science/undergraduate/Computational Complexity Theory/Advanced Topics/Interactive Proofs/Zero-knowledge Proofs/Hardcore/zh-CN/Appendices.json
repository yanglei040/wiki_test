{
    "hands_on_practices": [
        {
            "introduction": "理论是根基，但真正的理解往往源于实践。本节将通过一系列动手实践，带你深入探索零知识证明的微妙之处。第一个练习是一个基础性诊断。我们将分析一个为图三着色问题设计的、看似合理但存在缺陷的协议。你的任务是仔细审视协议的每一步，并准确判断它违反了零知识证明的哪一个核心属性，从而加深对“零知识”这一概念本质的理解。",
            "id": "1470205",
            "problem": "在密码学和计算复杂性领域，零知识证明（ZKP）是一种方法，通过该方法，一方（证明方）可以向另一方（验证方）证明其知道一个秘密值或信息（“见证”），而无需透露除了“其陈述为真”这一事实之外的任何信息。\n\n考虑一个涉及证明方 Peggy 和验证方 Victor 的场景。他们都可以访问一个公共的无向图 $G = (V, E)$。Peggy 声称她知道该图的一个有效3-着色。一个有效的3-着色是将集合 $\\{\\text{红, 绿, 蓝}\\}$ 中的一种颜色分配给 $V$ 中的每个顶点，使得对于每条边 $(u, v) \\in E$，相连顶点的颜色都不同，即 $C(u) \\neq C(v)$。\n\n为了证明她的声明，Peggy 和 Victor 遵循以下协议：\n1.  Victor 均匀随机地选择一条边 $(u, v) \\in E$，并询问 Peggy 其端点的颜色。\n2.  Peggy 参考她保密的3-着色方案，并向 Victor 揭示颜色对 $(C(u), C(v))$。\n3.  Victor 验证这两种颜色确实来自集合 $\\{\\text{红, 绿, 蓝}\\}$ 并且它们不相同。如果此检查通过，他对 Peggy 的声明更有信心。如果失败，他立即拒绝该声明。\n\n然而，这个协议有一个严重的缺陷，不满足一个协议成为ZKP所需的核心属性之一。下列哪个属性最直接、最根本地被这个协议的设计所违反？\n\nA. **完备性 (Completeness)**：如果证明方的陈述为真，诚实的证明方将总能说服诚实的验证方。\n\nB. **可靠性 (Soundness)**：如果证明方的陈述为假，作弊的证明方将无法说服诚实的验证方（除非以可忽略的概率）。\n\nC. **零知识性 (Zero-Knowledge)**：验证方除了证明方的陈述为真这一事实外，学不到任何新信息。\n\nD. **高效性 (Efficiency)**：协议可以在合理的时间内完成（通常是问题规模的多项式时间）。",
            "solution": "我们对照零知识证明的核心属性，通过精确的逻辑步骤来分析该协议。\n\n1) 属性的定义：\n- 完备性：如果 Peggy 知道一个有效的3-着色，那么对于任何被查询的边 $(u,v) \\in E$，她见证着色所分配的颜色满足 $C(u) \\neq C(v)$，因此 Victor 的检查会通过。\n- 可靠性：如果陈述是假的（即 $G$ 不存在有效的3-着色），那么作弊的证明方应该无法让诚实的验证方接受（除非以可忽略的概率）。\n- 零知识性：验证方除了陈述为真这一事实外，不应学到任何新信息。形式上，应该存在一个模拟器，它可以在不访问见证的情况下生成验证方的视图（其交互记录分布）；等价地，验证方的视图应该是可模拟的，而无需泄露见证信息。\n- 高效性：协议在 $|V|+|E|$ 的多项式时间内运行。\n\n2) 检查完备性：\n- 如果 Peggy 是诚实的，并且拥有一个有效的3-着色 $C:V\\to\\{\\text{红},\\text{绿},\\text{蓝}\\}$，那么对于任何随机选择的边 $(u,v)$，协议会揭示 $(C(u),C(v))$，且 $C(u)\\neq C(v)$。\n- Victor 的检查正是颜色在允许的集合中且不相等，这必然成立，所以这一轮通过。\n- 因此，该协议满足完备性。\n\n3) 检查可靠性：\n- 如果陈述是假的（不存在有效的3-着色），作弊的 Peggy 在此协议中不受任何单一全局着色的承诺约束。对于每个查询的边 $(u,v)$，她可以用 $\\{\\text{红},\\text{绿},\\text{蓝}\\}$ 中任意一对不同的颜色来回应，从而确保 Victor 的检查每次都能通过。\n- 因此，即使陈述为假，验证方也可能以概率1被说服，这违反了可靠性。\n\n4) 检查零知识性：\n- 在每一轮中，Victor 都会学到端点 $(u,v)$ 的实际颜色，即 $(C(u),C(v))$。这些值是见证（着色函数 $C$）的一部分。经过多轮之后，交互记录会累积关于特定顶点的明确见证信息。\n- 这些信息超出了“陈述为真”的范畴，因为它直接揭示了见证的条目。一个无法访问 $C$ 的模拟器无法复现包含证明方所揭示的特定真实值 $(C(u),C(v))$ 的交互记录的精确分布。\n- 因此，该协议泄露了见证信息，不满足零知识性。\n\n5) 检查高效性：\n- 每一轮包括均匀随机地选择一条边并检查两种颜色的不等性，这是多项式时间的。\n\n6) 识别最直接和根本上被违反的属性：\n- 协议中“揭示颜色对 $(C(u),C(v))$”这一明确的设计选择，直接向验证方泄露了见证信息。从构造上看，这是对零知识性的直接违反。\n- 尽管由于缺乏绑定机制（没有承诺），可靠性也不满足，但问题询问的是协议设计中最直接、最根本违反的属性。明确泄露实际颜色是对零知识性要求的直接违反。\n\n结论：最直接和根本上被违反的属性是零知识性。",
            "answer": "$$\\boxed{C}$$"
        },
        {
            "introduction": "接下来，我们将从理论分析转向一次具体的计算攻击。这个练习展示了一个标准的知识证明协议，其中一个微小的实现错误——重用随机数——导致了致命的漏洞。通过亲手计算，你将体验攻击者如何利用这个缺陷来彻底破解证明者本应保密的密钥。这个实践强调了密码学协议在实现层面“差之毫厘，谬以千里”的严苛性。",
            "id": "1470174",
            "problem": "在一个使用零知识证明（ZKP）协议的系统中，证明者 Alice 想要向验证者 Bob 证明她拥有一个秘密整数密钥 $s$。这个秘密是她的公钥 $v$ 模一个合数 $n$ 的平方根，满足 $s^2 \\equiv v \\pmod{n}$。$n$ 和 $v$ 的值是公开的，但 $n$ 的素因子是保密的。\n\n单轮证明协议的流程如下：\n1.  **承诺**：Alice 选择一个秘密随机整数 $r$（其中 $\\text{gcd}(r,n)=1$），计算承诺值 $x \\equiv r^2 \\pmod{n}$，并将其发送给 Bob。\n2.  **挑战**：Bob 发回一个随机挑战比特 $c \\in \\{0, 1\\}$。\n3.  **回应**：Alice 计算一个回应 $y$。如果 $c=0$，她发送 $y=r$。如果 $c=1$，她发送 $y \\equiv rs \\pmod{n}$。\n4.  **验证**：如果 $c=0$，Bob 验证 $y^2 \\equiv x \\pmod{n}$。如果 $c=1$，Bob 验证 $y^2 \\equiv xv \\pmod{n}$。\n\n假设公开值为 $n=3127$ 和 $v=619$。由于一个软件错误，Alice 的认证客户端在与 Bob 的两次连续认证会话中使用了*相同*的承诺值 $x$（因此也使用了相同的随机数 $r$）。\n\n在第一次会话中，Bob 用 $c_1=0$ 进行挑战，Alice 回应 $y_1=500$。\n在第二次会话中，Bob 注意到重复的承诺，巧妙地用 $c_2=1$ 进行挑战。Alice 有问题的客户端回应 $y_2=3095$。\n\n通过利用这个漏洞，Bob 可以推断出 Alice 的秘密密钥 $s$。这个秘密密钥 $s$ 的值是多少？答案必须是一个介于 $0$ 和 $n-1$ 之间（含两端）的整数。",
            "solution": "Alice 在两次会话中重用了相同的承诺 $x \\equiv r^{2} \\pmod{n}$，因此两次回应都对应于相同的 $r$。根据协议：\n- 当 $c_1=0$ 时，Alice 发送了 $y_1=r=500$。\n- 当 $c_2=1$ 时，Alice 发送了 $y_2 \\equiv rs \\pmod{3127}$，其中 $y_2=3095$。\n\n根据协议设计，$\\gcd(r,n)=1$，因此 $r$ 存在模 $n$ 的乘法逆元。于是，\n$$\ns \\equiv y_2 \\cdot r^{-1} \\equiv y_2 \\cdot y_1^{-1} \\pmod{3127}.\n$$\n\n我们首先通过扩展欧几里得算法计算 $y_1^{-1} \\pmod{3127}$。计算 gcd 链：\n$$\n\\begin{align*} 3127 &= 6 \\cdot 500 + 127 \\\\ 500 &= 3 \\cdot 127 + 119 \\\\ 127 &= 1 \\cdot 119 + 8 \\\\ 119 &= 14 \\cdot 8 + 7 \\\\ 8 &= 1 \\cdot 7 + 1 \\\\ 7 &= 7 \\cdot 1 + 0 \\end{align*}\n$$\n所以 $\\gcd(500,3127)=1$。回代得到\n$$\n\\begin{align*} 1 &= 8 - 1 \\cdot 7 \\\\ &= 8 - 1 \\cdot (119 - 14 \\cdot 8) = 15 \\cdot 8 - 1 \\cdot 119 \\\\ &= 15 \\cdot (127 - 1 \\cdot 119) - 1 \\cdot 119 = 15 \\cdot 127 - 16 \\cdot 119 \\\\ &= 15 \\cdot 127 - 16 \\cdot (500 - 3 \\cdot 127) = 63 \\cdot 127 - 16 \\cdot 500 \\\\ &= 63 \\cdot (3127 - 6 \\cdot 500) - 16 \\cdot 500 = 63 \\cdot 3127 - 394 \\cdot 500 \\end{align*}\n$$\n因此\n$$\n-394 \\cdot 500 \\equiv 1 \\pmod{3127} \\implies 500^{-1} \\equiv -394 \\equiv 2733 \\pmod{3127}.\n$$\n\n所以，\n$$\ns \\equiv 3095 \\cdot 2733 \\pmod{3127}.\n$$\n为简化计算，先对因子进行模约简：$3095 \\equiv -32 \\pmod{3127}$ 且 $2733 \\equiv -394 \\pmod{3127}$，所以\n$$\ns \\equiv (-32) \\cdot (-394) = 12608 \\pmod{3127}.\n$$\n现在将 $12608$ 模 $3127$ 进行约简：\n$$\n12608 - 4 \\cdot 3127 = 12608 - 12508 = 100,\n$$\n所以 $s \\equiv 100 \\pmod{3127}$。\n\n用公钥 $v$ 进行验证：\n$$\ns^{2} = 100^{2} = 10000 \\equiv 10000 - 3 \\cdot 3127 = 10000 - 9381 = 619 \\equiv v \\pmod{3127}.\n$$\n因此，推断出的秘密密钥是 $s=100$。",
            "answer": "$$\\boxed{100}$$"
        },
        {
            "introduction": "最后的这个实践将我们的视野从协议的内部数学细节扩展到整个交互系统。我们将分析一个经典的“中间人攻击”场景，一个不掌握秘密的恶意方，通过在诚实的证明者和验证者之间充当中继，成功地冒充证明者。这个思想实验揭示了一个深刻的道理：一个零知识证明协议的安全性不仅取决于其内在逻辑的完美，同样依赖于其运行的通信环境的安全性。",
            "id": "1470165",
            "problem": "在计算复杂性理论中，零知识证明（ZKP）允许证明者（prover）向验证者（verifier）证明一个陈述为真，而除了该陈述的有效性本身之外，不透露任何信息。\n\n考虑图三着色问题。如果可以为图 $G=(V, E)$ 中的每个顶点分配三种颜色（例如，红、绿、蓝）之一，使得没有两个相邻的顶点（由 $E$ 中的一条边连接）共享相同的颜色，那么该图是可三着色的。证明一个大型复杂图是可三着色的是计算上困难的，但验证一个给定的着色方案是容易的。\n\n一个标准的交互式ZKP协议，用于证明者 Peggy 向验证者 Victor 证明她知道一个公开图 $G$ 的有效三着色方案 $c: V \\to \\{\\text{红, 绿, 蓝}\\}$，其过程按轮次进行如下：\n\n1.  **承诺（Commitment）：** Peggy 首先选择三种颜色的一个随机置换 $\\pi$。她将这个置换应用于她的整个着色方案，得到一个新的、打乱后的着色方案 $c' = \\pi \\circ c$。对于每个顶点 $v \\in V$，她使用一个密码学安全的承诺方案对其新颜色 $c'(v)$ 进行承诺，该方案可以被看作是一个函数 `Commit(message, salt)`。她将所有承诺的集合 $\\{C_v\\}_{v \\in V}$（其中 $C_v = \\text{Commit}(c'(v), \\text{salt}_v)$）发送给 Victor。`salt` 是每个承诺唯一的大的随机数。\n\n2.  **挑战（Challenge）：** Victor 随机选择一条边 $(u, w) \\in E$，并要求 Peggy 揭示该边两个顶点的颜色。\n\n3.  **回应（Response）：** Peggy 揭示置换后的颜色 $c'(u)$、$c'(w)$ 以及对应的盐值 $\\text{salt}_u$ 和 $\\text{salt}_w$。\n\n4.  **验证（Verification）：** Victor 检查两个条件：\n    a) 揭示的信息是真实的：$C_u = \\text{Commit}(c'(u), \\text{salt}_u)$ 并且 $C_w = \\text{Commit}(c'(w), \\text{salt}_w)$。\n    b) 该边的着色属性成立：$c'(u) \\neq c'(w)$。\n\n如果两项检查都通过，则该轮成功。协议会重复足够多的轮次，以使作弊的证明者成功的概率变得无穷小。\n\n现在，考虑一个有三方的场景：\n-   **Peggy：** 一位诚实的证明者，她拥有一个大型公开图 $G$ 的有效三着色方案。\n-   **Charlie：** 一位诚实的验证者。\n-   **Mallory：** 一位恶意的参与方，她**不**知道 $G$ 的三着色方案，但希望让 Charlie 相信她知道。\n\nMallory 能够同时参与两个协议会话：一个是作为“证明者”与 Charlie 进行，另一个是作为“验证者”与 Peggy 进行。\n\n以下哪种策略能让 Mallory 成功通过与 Charlie 的每一轮验证，从而在不被发现的情况下，欺骗性地证明她对着色方案的了解？\n\n- **A:** 在与 Peggy 的会话中，Mallory 请求 Peggy 揭示她完整的秘密三着色方案 $c$。然后，Mallory 使用这个被揭示的着色方案，在另一个会话中向 Charlie 诚实地证明她的知识。\n\n- **B:** Mallory 通过为每个顶点发送对随机生成数据的承诺来启动与 Charlie 的会话。当 Charlie 对一条边 $(u,w)$ 发出挑战时，Mallory 无法为她最初的承诺提供有效回应。于是，她随机选择两种不同的颜色，“红色”和“绿色”，并声称它们对应于顶点 $u$ 和 $w$，希望这个猜测能通过验证。\n\n- **C:** Mallory 通过发送她自己的一套承诺 $\\{C'_v\\}_{v \\in V}$ 来启动与 Charlie 的会话。同时，她与 Peggy 启动一个会话。当 Charlie 用一条边 $(u,w)$ 挑战她时，Mallory 将同样的挑战传递给 Peggy。在收到 Peggy 的回应（颜色和盐值）后，Mallory 在她自己对 Charlie 的回应中使用这些颜色。\n\n- **D:** Mallory 与 Peggy 启动一个会话。当 Peggy 发送她的承诺集合 $\\{C_v\\}_{v \\in V}$ 时，Mallory 将这个完全相同的承诺集合作为自己的承诺转发给 Charlie。当 Charlie 用一条边 $(u,w)$ 挑战她时，Mallory 将这个完全相同的挑战转发给 Peggy。当 Peggy 发送她的回应时，Mallory 将那个完全相同的回应转发给 Charlie。\n\n- **E:** Mallory 被动地窃听 Peggy 与其他验证者之间的许多独立的证明会话。她记录下所有的边挑战和相应的被揭示的颜色对。在收集到足够的数据后，她试图重建完整的着色方案 $c$，并在她与 Charlie 的会话中使用它。",
            "solution": "我们使用协议和承诺方案的属性来分析每种提出的策略。所使用的关键密码学属性是：\n- 隐藏性（Hiding）：对于每个 $v \\in V$，如果没有开启值，承诺 $C_v=\\text{Commit}(c'(v),\\text{salt}_v)$ 不会泄露关于 $c'(v)$ 的任何信息。\n- 绑定性（Binding）：在 $C_v$ 被固定后，Peggy（或任何声称 $C_v$ 是自己的人）不能在之后将 $C_v$ 开启为不同的颜色-盐值对。\n- 零知识性（Zero-knowledge）：协议的记录不泄露关于原始着色方案 $c$ 的任何知识，因为颜色在每一轮都通过 $c'=\\pi \\circ c$ 进行随机置换，并且只揭示单个被挑战边的颜色。\n- 抗随机猜测的可靠性（Soundness against random guessing）：如果没有与先前承诺相匹配的有效开启值，证明者无法持续通过验证。\n\n选项A：Mallory 要求 Peggy 揭示完整的着色方案 $c$。Peggy 是一个诚实的证明者，她遵循协议，而协议从不要求完整揭示 $c$。根据零知识性，Peggy 不会泄露 $c$。因此，Mallory 无法通过这种方式获得 $c$。此策略失败。\n\n选项B：Mallory 对随机数据进行承诺，并在收到挑战 $(u,w)$ 后，试图用随机颜色作答。根据绑定性，Mallory 的原始承诺固定了开启值。由于她的随机回复几乎肯定与她的原始承诺不匹配，Victor 的检查 $C_u = \\text{Commit}(c'(u),\\text{salt}_u)$ 和 $C_w = \\text{Commit}(c'(w),\\text{salt}_w)$ 将会失败。即使她试图猜测颜色和盐值，但如果不与先前的承诺匹配，这也是不可行的。这无法通过每一轮。此策略失败。\n\n选项C：Mallory 将她自己的承诺集合 $\\{C'_v\\}$ 发送给 Charlie，但在收到挑战 $(u,w)$ 时，她将该挑战转发给 Peggy，以获取 Peggy 承诺 $\\{C_v\\}$ 的真实开启值。然而，Mallory 的承诺 $C'_v$ 与 Peggy 的 $C_v$ 是独立的，因为它们在看到 Peggy 的开启值之前就已固定，并且使用了不同的盐值和可能不同的置换。根据绑定性，Mallory 无法将 $C'_u,C'_w$ 开启为与 Peggy 的颜色和盐值相匹配的值，除非是巧合，而这在计算上是不可行的。因此，Victor 对 $C'_u,C'_w$ 的身份验证检查会失败。此策略失败。\n\n选项D：Mallory 将 Peggy 的承诺集合 $\\{C_v\\}$ 作为自己的承诺转发给 Charlie。当 Charlie 用边 $(u,w)$ 挑战她时，Mallory 将该挑战转发给 Peggy，然后将 Peggy 的确切回应 $(c'(u),\\text{salt}_u)$ 和 $(c'(w),\\text{salt}_w)$ 转发给 Charlie。Victor 的验证检查：\n1) 真实性：$C_u = \\text{Commit}(c'(u),\\text{salt}_u)$ 和 $C_w = \\text{Commit}(c'(w),\\text{salt}_w)$ 会通过，因为这些是 Peggy 对其承诺的真实开启值，而由于转发，Charlie 相信这些是 Mallory 的。\n2) 正确着色：$c'(u)\\neq c'(w)$ 成立，因为 Peggy 的着色在置换下是有效的。\n由于 Mallory 精确地中继了来自 Peggy 的有效承诺和开启值，与 Charlie 的每一轮验证都将通过。并发性确保了 Mallory 可以在看到 Charlie 的挑战后获得 Peggy 的开启值。这是针对这种普通交互式协议的经典中间人中继攻击，它利用了协议缺乏非延展性（non-malleability）的弱点。此策略成功。\n\n选项E：Mallory 被动窃听 Peggy 与其他验证者之间的许多独立证明会话。她记录了所有的边挑战和相应的揭示颜色对。在收集足够的数据后，她试图重建完整的着色方案 $c$ 并在她与 Charlie 的会话中使用它。由于零知识性和每一轮的随机置换 $\\pi$，被揭示的边颜色是相对于新的置换的，并不会累积成关于 $c$ 的知识。承诺的隐藏性也阻止了学习未开启的颜色。从这些记录中重建 $c$ 在计算上是不可行的，因此 Mallory 之后无法向 Charlie 证明知识。此策略失败。\n\n因此，只有选项 D 能够让 Mallory 通过未经修改地中继 Peggy 的承诺和回应，从而在不被发现的情况下通过与 Charlie 的每一轮验证。",
            "answer": "$$\\boxed{D}$$"
        }
    ]
}