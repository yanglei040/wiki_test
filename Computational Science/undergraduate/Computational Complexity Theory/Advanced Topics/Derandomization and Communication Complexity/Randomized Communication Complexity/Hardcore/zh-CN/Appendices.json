{
    "hands_on_practices": [
        {
            "introduction": "理论是重要的，但真正的理解来自于实践。让我们从一个简单直观的随机化协议开始。这个练习旨在计算两个集合交集大小的奇偶性，它展示了如何分析一个协议的错误概率，并揭示了为何一个看似合理的方法可能存在根本性的局限性。",
            "id": "1440960",
            "problem": "在通信复杂度领域，Alice和Bob两方旨在计算一个函数 $f(x, y)$，其中Alice持有输入 $x$，Bob持有输入 $y$。他们通过根据一个协议交换消息来完成此计算，而协议的成本是交换的比特数。\n\n考虑以下场景。所有项的全集是集合 $U = \\{1, 2, \\dots, n\\}$，其中 $n=128$。Alice有一个子集 $X \\subseteq U$，Bob有一个子集 $Y \\subseteq U$。他们的目标是计算他们交集大小的奇偶性，即确定 $|X \\cap Y|$ 是奇数还是偶数。\n\n他们决定测试一个简单的单向随机化协议，该协议依赖于一个公开共享的随机比特串。\n\n**协议内容：**\n1. 生成一个随机比特串 $r = (r_1, r_2, \\dots, r_n)$ 并提供给Alice和Bob双方。每个比特 $r_i$ 都是从 $\\{0, 1\\}$ 中独立且均匀随机地选择的。\n2. Alice通过计算其集合 $X$ 中索引对应的随机比特之和的奇偶性来计算单个比特 $a$。即 $a = \\left( \\sum_{i \\in X} r_i \\right) \\pmod 2$。\n3. Alice将比特 $a$ 发送给Bob。这是唯一的通信。\n4. Bob接收比特 $a$ 并将其声明为 $|X \\cap Y| \\pmod 2$ 的结果。\n\n这个协议并不完美。如果Bob声明的结果 $a$ 不等于 $|X \\cap Y| \\pmod 2$ 的真实值，则会发生错误。该协议的最大可能错误概率是多少？最大值应取自所有可能的输入集对 $(X, Y)$。\n\n请用精确分数表示你的答案。",
            "solution": "令 $U=\\{1,2,\\dots,n\\}$，其中 $n=128$，并令 $X,Y\\subseteq U$。一个公共随机串 $r=(r_{1},\\dots,r_{n})$ 被抽取，其比特 $r_{i}$ 相互独立，且均勻分布在 $\\{0,1\\}$ 上。Alice计算\n$$\na=\\left(\\sum_{i\\in X}r_{i}\\right)\\bmod 2,\n$$\nBob输出 $a$ 作为对真实值\n$$\nt=\\left|X\\cap Y\\right|\\bmod 2\n$$\n的估计。\n错误事件是 $\\{a\\neq t\\}$。对于固定的 $(X,Y)$，错误概率是基于 $r$ 的随机性计算的。\n\n我们分析 $a$ 的分布。如果 $X=\\emptyset$，那么\n$$\na=\\left(\\sum_{i\\in \\emptyset} r_{i}\\right)\\bmod 2=0\n$$\n是确定性的。在这种情况下，$t=\\left|X\\cap Y\\right|\\bmod 2=\\left|\\emptyset\\right|\\bmod 2=0$，所以\n$$\n\\Pr[a\\neq t]=\\Pr[0\\neq 0]=0.\n$$\n\n如果 $X\\neq\\emptyset$，选择任意 $j\\in X$ 并以 $\\{r_{i}:i\\in X\\setminus\\{j\\}\\}$ 的值为条件。令\n$$\nc=\\left(\\sum_{i\\in X\\setminus\\{j\\}} r_{i}\\right)\\bmod 2,\n$$\n在此条件下 $c$ 是固定的。那么\n$$\na=\\left(r_{j}+ \\sum_{i\\in X\\setminus\\{j\\}} r_{i}\\right)\\bmod 2=(r_{j}+c)\\bmod 2.\n$$\n由于 $r_{j}$ 与该条件独立且在 $\\{0,1\\}$ 上均匀分布，可以得出 $a$ 在 $\\{0,1\\}$ 上均匀分布：\n$$\n\\Pr[a=0]=\\Pr[a=1]=\\frac{1}{2}.\n$$\n因此，对于任何固定的 $t\\in\\{0,1\\}$（特别是 $t=\\left|X\\cap Y\\right|\\bmod 2$），我们有\n$$\n\\Pr[a\\neq t]=\\frac{1}{2}.\n$$\n\n综合这两种情况，当 $X=\\emptyset$ 时，错误概率为 $0$，而当 $X\\neq\\emptyset$ 时，错误概率为 $\\frac{1}{2}$。因此，对所有可能的对 $(X,Y)$ 取最大值，我们得到的最大错误概率为\n$$\n\\max_{X,Y}\\Pr[a\\neq t]=\\frac{1}{2}.\n$$\n$n$ 的值不影响这个结论，只要 $X$ 可以是非空的即可。",
            "answer": "$$\\boxed{\\frac{1}{2}}$$"
        },
        {
            "introduction": "上一个练习提醒我们，并非所有随机化方案都是有效的。现在，让我们来看一个更成功的应用，它利用模运算的威力来创建数字“指纹”。通过这个具体实例，您将计算一个用于测试公因数的协议的通信成本和错误率，从而体验指纹技术在降低通信复杂度方面的强大能力。",
            "id": "1440982",
            "problem": "Alice 和 Bob 正在研究随机化通信协议。他们的任务是确定他们各自的整数 $x$ 和 $y$ 是否共享一个公共质因数。他们设计了以下单向协议，该协议依赖于一个共享的公共随机源：\n\n**协议：公因数测试**\n1.  从小于或等于一个公开已知整数 $M$ 的所有质数集合中，均匀随机地选择一个质数 $p$。\n2.  Alice 计算 $a = x \\pmod p$ 并将 $a$ 的值传输给 Bob。\n3.  Bob 接收 $a$。然后他计算 $b = y \\pmod p$。\n4.  Bob 的输出规则：如果 $a=0$ 且 $b=0$，Bob 输出找到了一个公因数。否则，他输出对于所选的质数 $p$ 没有找到公因数。\n\n该协议被称为具有单边错误。如果协议输出找到了一个公因数，那么这个结果总是正确的（即 $\\text{gcd}(x,y)  1$）。然而，如果 $\\text{gcd}(x,y)  1$，协议仍可能未能找到公因数，从而导致错误。\n\n考虑一个具体场景，其中参数 $M=100$。Alice 的数字是 $x = 177$，Bob 的数字是 $y = 295$。已知这些数字的质因数分解为 $x=3 \\times 59$ 和 $y=5 \\times 59$。\n\n该协议的通信成本是多少（以 Alice 必须发送的比特数衡量），以及对于这对特定的输入 $(x, y)$，其错误概率是多少？错误概率定义为在确实存在公因数的情况下，协议未能找到公因数的概率。\n\nA. 通信成本：6 比特，错误概率：24/25\n\nB. 通信成本：7 比特，错误概率：1/25\n\nC. 通信成本：7 比特，错误概率：24/25\n\nD. 通信成本：8 比特，错误概率：24/25\n\nE. 通信成本：7 比特，错误概率：23/24",
            "solution": "从至多为 $M=100$ 的质数集合中均匀地选择一个质数 $p$。设这个集合为 $\\mathcal{P}$，其大小为 $|\\mathcal{P}|=\\pi(100)$。不大于 $100$ 的质数个数为 $\\pi(100)=25$。\n\n通信成本：Alice 发送 $a=x \\bmod p$，该值位于集合 $\\{0,1,\\dots,p-1\\}$ 中。编码任何此类余数所需的比特数是 $\\lceil \\log_{2} p \\rceil$。协议必须对小于或等于 $100$ 的最大可能质数 $p$（即 $97$）起作用。由于 $2^{6}=64  97 \\le 2^{7}=128$，因此可得\n$$\n\\lceil \\log_{2} 97 \\rceil=7,\n$$\n所以通信成本是 $7$ 比特。\n\n错误概率：协议当且仅当 $a=0$ 且 $b=0$ 时输出“找到”，这等价于 $p \\mid x$ 且 $p \\mid y$，即 $p$ 整除 $\\gcd(x,y)$。给定 $x=3 \\times 59$ 和 $y=5 \\times 59$，我们有 $\\gcd(x,y)=59$。因此，协议仅在 $p=59$ 时成功。由于 $p$ 在 $|\\mathcal{P}|=25$ 的集合 $\\mathcal{P}$ 上是均匀分布的，成功概率为\n$$\n\\frac{1}{25},\n$$\n因此错误概率为\n$$\n1-\\frac{1}{25}=\\frac{24}{25}.\n$$\n\n因此，正确的选项是“通信成本：7 比特，错误概率：$24/25$”。",
            "answer": "$$\\boxed{C}$$"
        },
        {
            "introduction": "指纹技术的可扩展性是其主要优势之一。最后一个练习将此概念应用于一个大规模的计算生物学问题：在两条长DNA序列中寻找共同的子串。您将通过分析一个基于多项式指纹的协议，学习如何在一个巨大的可能性空间中控制错误概率，并计算在最坏情况下所需的通信开销。",
            "id": "1440992",
            "problem": "Alice 和 Bob 正在合作一个大规模的计算生物学项目。Alice 有一个脱氧核糖核酸（DNA）序列 $x$，Bob 有一个 DNA 序列 $y$，两者的长度都为 $n$。这些序列表示为字母表 $\\{A, C, G, T\\}$ 上的字符串。他们想要确定在他们的序列中是否存在一个长度恰好为 $k$ 的公共子串。直接比较需要传输其中一个序列，而这代价高昂。他们决定使用一个随机通信协议，其描述如下。\n\n1.  他们公开约定一个从字母表 $\\{A, C, G, T\\}$ 到整数集合 $\\{0, 1, 2, 3\\}$ 的映射。这将他们的 DNA 序列转换为整数串。\n2.  他们将每个长度为 $k$ 的子串解释为一个整数的 4 进制表示。对于一个子串 $s = s_1 s_2 \\dots s_k$，其中每个 $s_i$ 是对应一个 DNA 碱基的整数，其关联的整数值为 $N(s) = \\sum_{i=1}^k s_i 4^{k-i}$。\n3.  为了处理可能出现的大数，他们还公开约定一个素数 $p$。Alice 为她的 $n-k+1$ 个长度为 $k$ 的子串中的每一个计算一个“指纹”。一个子串 $s$ 的指纹是 $FP(s) = N(s) \\pmod p$。她将这些指纹收集到一个集合 $F_x$ 中。\n4.  Alice 在一条消息中将整个指纹集合 $F_x$ 发送给 Bob。\n5.  Bob 为他自己的子串计算指纹，创建集合 $F_y$。然后他检查交集 $F_x \\cap F_y$ 是否非空。如果非空，他们就断定很可能存在一个长度为 $k$ 的公共子串。如果交集为空，他们就断定不存在公共子串。\n\n这个协议存在单边错误：如果存在公共子串，它总能检测到；但当不存在公共子串时，它可能会报告存在（即假阳性）。假设 $n=1,000,000$ 且 $k=50$。他们希望假阳性的概率最多为 $10^{-6}$。为了达到这个目标，他们从区间 $[M, 2M]$ 内的素数集合中均匀随机地选择一个素数 $p$。已知任何整数 $Z  1$ 的不同素因子的数量严格小于 $\\log_2(Z)$。他们确定，为了满足他们期望的错误界限，必须选择 $M$ 为满足条件的最小的 10 的整数次幂。\n\n你的任务是计算在最坏情况下，Alice 必须发送给 Bob 的总比特数。为了发送她的指纹集合，Alice 逐一传输每个唯一的指纹值。每个指纹所需的比特数由他们可能约定的最大素数决定。将你的最终答案（总比特数）用科学记数法表示，并四舍五入到三位有效数字。",
            "solution": "设 $n=10^{6}$ 且 $k=50$。每个长度为 $k$ 的子串 $s$ 映射到一个整数 $N(s)\\in\\{0,1,\\dots,4^{k}-1\\}$。对于没有公共长度为 $k$ 的子串的字符串 $x$ 和 $y$，出现假阳性的充要条件是存在来自 $x$ 的子串 $s$ 和来自 $y$ 的子串 $t$，使得 $N(s)\\not= N(t)$ 但 $N(s)\\equiv N(t)\\pmod p$，即 $p$ 整除 $Z_{s,t}\\equiv |N(s)-N(t)|$。\n\n设 $L\\equiv n-k+1$ 为每个字符串中长度为 $k$ 的子串的数量；此处\n$$\nL=n-k+1=10^{6}-49=999{,}951.\n$$\n最多有 $L^{2}$ 个有序对 $(s,t)$，对于每个这样的对，$1\\leq Z_{s,t}\\leq 4^{k}-1$。设 $D$ 是所有满足 $Z_{s,t}\\geq 1$ 的 $Z_{s,t}$ 值的集合。如果选择的素数 $p\\in[M,2M]$ 整除了 $D$ 中至少一个 $Z$，则会产生假阳性。\n\n根据给定事实，任何整数 $Z1$ 的不同素因子的数量严格小于 $\\log_{2}(Z)$。因此，整除 $D$ 中至少一个 $Z$ 的不同素数的数量严格小于\n$$\n\\log_{2}\\!\\Big(\\prod_{Z\\in D} Z\\Big)=\\sum_{Z\\in D}\\log_{2}(Z)\\leq |D|\\cdot\\log_{2}(4^{k})=L^{2}\\cdot 2k.\n$$\n因此，在 $[M,2M]$ 中“坏”素数的数量严格小于 $2kL^{2}$。如果 $P(M)$ 表示 $[M,2M]$ 中素数的数量，那么从这些素数中均匀随机选择 $p$ 会得到\n$$\n\\Pr[\\text{false positive}]\\leq \\frac{2kL^{2}}{P(M)}.\n$$\n为确保这个概率最多为 $10^{-6}$，只需满足\n$$\nP(M)\\geq 10^{6}\\cdot 2kL^{2}.\n$$\n当 $k=50$ 且 $L=999{,}951$ 时，\n$$\nL^{2}=(10^{6}-49)^{2}=999{,}902{,}002{,}401,\\qquad 2kL^{2}=100\\cdot 999{,}902{,}002{,}401=99{,}990{,}200{,}240{,}100.\n$$\n因此一个充分条件是\n$$\nP(M)\\geq 10^{6}\\cdot 99{,}990{,}200{,}240{,}100=9.99902002401\\times 10^{19}.\n$$\n\n使用素数定理作为一个保守估计，$[M,2M]$ 中的素数数量满足 $P(M)\\approx \\frac{M}{\\ln M}$；一个保守的下界是 $P(M)\\gtrsim \\frac{M}{\\ln(2M)}$。我们需要选择 $M$ 为满足以下条件的最小的 10 的整数次幂\n$$\n\\frac{M}{\\ln(2M)}\\geq 9.99902002401\\times 10^{19}.\n$$\n测试 $M=10^{21}$：\n$$\n\\frac{10^{21}}{\\ln(2\\times 10^{21})}=\\frac{10^{21}}{\\ln 2+21\\ln 10}\\approx \\frac{10^{21}}{49.047434}\\approx 2.04\\times 10^{19}  9.999\\times 10^{19},\n$$\n所以 $10^{21}$ 是不够的。测试 $M=10^{22}$：\n$$\n\\frac{10^{22}}{\\ln(2\\times 10^{22})}=\\frac{10^{22}}{\\ln 2+22\\ln 10}\\approx \\frac{10^{22}}{51.350019}\\approx 1.95\\times 10^{20}\\geq 9.999\\times 10^{19},\n$$\n所以 $M=10^{22}$ 足够，并且是满足条件的最小的 10 的幂。\n\n每个指纹的比特长度由可能约定的最大素数（最大为 $2M$）决定，因此\n$$\nb=\\left\\lceil \\log_{2}(2M)\\right\\rceil=\\left\\lceil \\log_{2}(2\\times 10^{22})\\right\\rceil\n=\\left\\lceil 1+22\\log_{2}10\\right\\rceil\n=\\left\\lceil 1+22\\cdot \\frac{\\ln 10}{\\ln 2}\\right\\rceil\n=\\left\\lceil 74.082417\\right\\rceil=75.\n$$\n在最坏情况下，由于 $p\\gg L$，所有 $L$ 个指纹对模 $p$ 都是不同的，所以 Alice 发送 $L$ 个指纹。发送的总比特数是\n$$\nT=b\\cdot L=75\\cdot 999{,}951=74{,}996{,}325=7.4996325\\times 10^{7}.\n$$\n用科学记数法表示并四舍五入到三位有效数字，\n$$\nT\\approx 7.50\\times 10^{7}.\n$$",
            "answer": "$$\\boxed{7.50 \\times 10^{7}}$$"
        }
    ]
}