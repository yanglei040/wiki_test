{
    "hands_on_practices": [
        {
            "introduction": "理论是基础，但真正的理解来自于实践。在许多分布式计算场景中，我们希望在不传输所有原始数据的情况下验证系统的一致性。这个问题通过一个假设的传感器网络场景，引导我们思考一个核心问题：通信成本究竟取决于什么？通过解决这个问题 ，你将学会如何将一个看似复杂的问题（比较两个长比特串）简化为更易于处理的核心问题（比较两个整数），并为它建立匹配的上限和下限，从而精确地确定其通信复杂度。",
            "id": "1421146",
            "problem": "两个分布式传感器，我们称之为 Alice 和 Bob，正在监测某个环境参数。在一小时的周期内，每个传感器进行 $n=1000$ 次独立的二进制测量，每个传感器从而得到一个 $n$ 比特的字符串。设 $x$ 为 Alice 持有的字符串，$y$ 为 Bob 持有的字符串。测量中的“1”表示一个感兴趣的事件，而“0”表示没有事件。\n\n为确保他们的计数机制同步，他们需要确定是否检测到了相同总数的事件。他们想要计算函数 $f(x, y)$，其定义为：如果字符串 $x$ 中“1”的数量等于字符串 $y$ 中“1”的数量，则函数值为 $1$，否则为 $0$。\n\nAlice 和 Bob 可以通过一个信道交换比特来进行通信。一个确定性协议是他们为交换信息而遵循的一套预定义规则。对于给定的输入对 $(x, y)$，一旦至少有一方知道了 $f(x,y)$ 的正确值，就认为该协议已经计算出了函数值。对于特定的输入对 $(x, y)$，一个协议的成本是交换的总比特数。函数 $f$ 的确定性通信复杂度是指，在最坏情况的输入对 $(x, y)$ 下，由最高效的协议所能实现的最小可能成本。\n\n对于这个 $n=1000$ 的同步检查函数 $f$，其精确的确定性通信复杂度是多少？请以整数形式给出你的答案。",
            "solution": "设 $n$ 为字符串长度，定义汉明权重 $a=|x|$ 和 $b=|y|$。那么 $a,b \\in \\{0,1,\\dots,n\\}$，所以每个变量都有 $m=n+1$ 个可能的值。该函数为\n$$\nf(x,y)=1 \\;\\;\\Longleftrightarrow\\;\\; a=b.\n$$\n因此，问题简化为在一个包含 $m$ 个元素的域上计算相等性。\n\n上界：Alice 可以在本地计算 $a$，并使用\n$$\nL=\\lceil \\log_{2} m \\rceil=\\lceil \\log_{2} (n+1) \\rceil\n$$\n比特将其二进制编码发送给 Bob，这足以唯一地标识 $m$ 种可能性中的一种。Bob 在本地计算 $b$，并且当且仅当收到的值等于 $b$ 时输出 $1$。因此，存在一个确定性协议，其最坏情况成本为 $L=\\lceil \\log_{2} (n+1) \\rceil$ 比特。\n\n下界：考虑一个由输入字符串对组成的集合 $S$，使得对于集合中的每一对 $(x_i, y_i)$，我们有 $|x_i|=|y_i|=i$ for $i \\in \\{0,1,\\dots,n\\}$。这个集合的大小为 $m=n+1$。对于 $S$ 中的每一对，函数值都为1。对于任意两个不同的对 $(x_i, y_i)$ 和 $(x_j, y_j)$（其中 $i\\neq j$），交叉对 $(x_i, y_j)$ 的函数值为0，因为 $|x_i|=i \\neq j = |y_j|$。因此，$S$ 是一个 1-愚弄集。根据愚弄集下界理论，确定性通信复杂度 $D(f)$ 满足\n$$\nD(f)\\geq \\log_{2} |S|=\\log_{2} (n+1).\n$$\n由于 $D(f)$ 是一个整数，这意味着\n$$\nD(f)\\geq \\lceil \\log_{2} (n+1) \\rceil.\n$$\n结合上界和下界，得出精确值为\n$$\nD(f)=\\lceil \\log_{2} (n+1) \\rceil.\n$$\n对于 $n=1000$，我们有 $m=1001$ 且 $2^{9}=512  1001 \\leq 2^{10}=1024$，因此\n$$\nD(f)=\\lceil \\log_{2} 1001 \\rceil=10.\n$$",
            "answer": "$$\\boxed{10}$$"
        },
        {
            "introduction": "在掌握了基本上下界证明的思路后，我们来挑战一个更精巧的场景。在这个练习中，通信双方需要判断他们在网络中的位置是否相邻。这个问题  的巧妙之处在于，其下界的证明需要我们运用“愚弄集（fooling set）”这一强大的工具。你将通过构造一个特殊的输入集合，来论证任何正确的通信协议都必须为这个集合中的每对输入产生独一无二的通信记录，从而证明一个看似简单的任务也存在一个不可避免的通信成本。",
            "id": "1421116",
            "problem": "Alice和Bob两方面临一个与网络结构相关的计算问题。该网络是一个有10个顶点的循环图，顶点连续标记为0, 1, 2, ..., 9。在这个图中，任何顶点 $i$ 只通过一条边与顶点 $(i-1) \\pmod{10}$ 和顶点 $(i+1) \\pmod{10}$ 相连。\n\nAlice私下里持有一个顶点标签 $x \\in \\{0, 1, ..., 9\\}$，Bob私下里持有一个顶点标签 $y \\in \\{0, 1, ..., 9\\}$。Alice不知道Bob的顶点，Bob也不知道Alice的顶点。他们的目标是确定他们的顶点在图中是否相邻。他们可以遵循一个预先安排好的协议，通过一个信道相互发送比特来进行通信。\n\n在最坏情况的输入场景下，为了保证Alice能得知她的顶点是否与Bob的顶点相邻，他们之间必须交换的绝对最小比特数是多少？\n\nA. 3\n\nB. 4\n\nC. 5\n\nD. 10",
            "solution": "设顶点集为 $V = \\{0, 1, \\dots, 9\\}$。Alice的输入是 $x \\in V$，Bob的输入是 $y \\in V$。他们想要计算函数 $ADJ(x, y)$，其中当顶点 $x$ 和 $y$ 相邻时，$ADJ(x, y) = 1$，否则 $ADJ(x, y) = 0$。根据问题描述，在这个10个顶点的循环图中，相邻意味着 $y = (x+1) \\pmod{10}$ 或 $y = (x-1) \\pmod{10}$。最终结果必须由Alice知晓。\n\n首先，我们确定所需比特数的一个上界。通过构建一个有效的通信协议，可以找到一个上界。\n\n考虑以下协议：\n1. Bob将他的输入顶点 $y$ 发送给Alice。\n2. Alice接收到 $y$。由于她知道自己的输入 $x$，她现在就有了两个输入。\n3. Alice通过检查 $y$ 是否等于 $(x+1) \\pmod{10}$ 或 $(x-1) \\pmod{10}$ 来计算 $ADJ(x, y)$。由于她现在知道了结果，协议就完成了。\n\n让我们分析这个协议所需的比特数。Bob的输入 $y$ 可以是 $\\{0, 1, \\dots, 9\\}$ 中的任意一个值。要编码10种可能性中的一种，最少需要 $\\lceil \\log_2(10) \\rceil$ 个比特。\n$\\log_2(8) = 3$ 且 $\\log_2(16) = 4$，所以 $\\log_2(10)$ 介于3和4之间。因此，$\\lceil \\log_2(10) \\rceil = 4$。\nBob可以向Alice发送他数字 $y$ 的一个4比特二进制表示。这个协议总共需要4比特的通信。这就确定了一个上界：所需的最小比特数最多为4。\n\n接下来，我们确定比特数的一个下界。为了证明4比特是最小值，我们必须证明没有任何使用3个或更少比特的协议可以解决这个问题。我们将使用“愚弄集”论证。任何使用 $k$ 比特通信的确定性协议最多可以有 $2^k$ 个不同的通信记录（即交换的消息序列）。如果两个不同的输入对 $(x_1, y_1)$ 和 $(x_2, y_2)$ 产生了相同的通信记录，那么该协议就无法区分它们。这意味着“交叉”对 $(x_1, y_2)$ 和 $(x_2, y_1)$ 也必须产生相同的通信记录。对于一个正确的协议，这四个输入对都必须产生相同的输出值（这被称为单色矩形）。如果我们能找到一个包含 $M$ 个输入对的集合，在任何有效协议中，这些输入对都必须有不同的通信记录，那么我们就需要至少 $M$ 个不同的通信记录。这意味着 $2^k \\ge M$，或者 $k \\ge \\lceil \\log_2(M) \\rceil$。\n\n让我们构建这样一个对的集合。考虑由10个顶点相邻的输入对组成的集合 $S$：\n$S = \\{ (0,1), (1,2), (2,3), (3,4), (4,5), (5,6), (6,7), (7,8), (8,9), (9,0) \\}$。\n对于集合 $S$ 中的每一对 $(x,y)$，函数值都为 $ADJ(x,y) = 1$。\n\n让我们从 $S$ 中任取两个不同的对：$(x_1, y_1) = (i, (i+1)\\pmod{10})$ 和 $(x_2, y_2) = (j, (j+1)\\pmod{10})$，其中 $i \\neq j$。\n假设，为了引出矛盾，这两个对可以产生相同的通信记录。这将意味着交叉对 $(x_1, y_2) = (i, (j+1)\\pmod{10})$ 和 $(x_2, y_1) = (j, (i+1)\\pmod{10})$ 的函数值也必须为 $ADJ=1$。\n让我们检查这个条件。\n$ADJ(i, (j+1)\\pmod{10}) = 1$ 意味着 $(j+1) \\equiv i \\pm 1 \\pmod{10}$。\n这给出了两种可能性：\n1a) $j+1 \\equiv i+1 \\pmod{10} \\implies j \\equiv i \\pmod{10}$。这是不可能的，因为我们选择了不同的对，$i \\ne j$。\n1b) $j+1 \\equiv i-1 \\pmod{10} \\implies j \\equiv i-2 \\pmod{10}$。\n\n$ADJ(j, (i+1)\\pmod{10}) = 1$ 意味着 $(i+1) \\equiv j \\pm 1 \\pmod{10}$。\n这给出了两种可能性：\n2a) $i+1 \\equiv j+1 \\pmod{10} \\implies i \\equiv j \\pmod{10}$。同样，不可能。\n2b) $i+1 \\equiv j-1 \\pmod{10} \\implies i \\equiv j-2 \\pmod{10}$。\n\n因此，为了让两个交叉对的输出都为1，我们必须同时满足 $j \\equiv i-2 \\pmod{10}$ 和 $i \\equiv j-2 \\pmod{10}$。\n将第一个同余式代入第二个，得到：\n$i \\equiv (i-2) - 2 \\pmod{10}$\n$i \\equiv i-4 \\pmod{10}$\n$0 \\equiv -4 \\pmod{10}$，这意味着 $4 \\equiv 0 \\pmod{10}$。\n这是错误的，因为10不能整除4。\n\n这个矛盾表明，对于我们集合 $S$ 中的任意两个不同对，它们不可能属于同一个值为1的单色矩形。因此，任何正确的协议都必须为 $S$ 中的10个对中的每一个产生一个唯一的通信记录。\n为了有至少10个不同的记录，交换的比特数 $k$ 必须满足 $2^k \\ge 10$。\n满足这个不等式的最小整数 $k$ 是 $k=4$，因为 $2^3=8  10$ 且 $2^4=16 \\ge 10$。\n这就确定了一个下界：最小比特数至少为4。\n\n由于我们找到了4比特的上界和4比特的下界，因此所需的最小比特数恰好是4。\n将此与给定的选项进行比较：\nA. 3 - 不正确，小于下界。\nB. 4 - 正确。\nC. 5 - 不正确，对于一个简单的协议，这是一个有效的比特数，但不是最小值。\nD. 10 - 不正确。\n\n最小比特数是4。",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "前面的练习让你应用了“愚弄集”方法，而这个最终的实践练习则将焦点放在了掌握这项技术本身。你的任务不再是简单地计算通信复杂度，而是要为一个给定的函数构造出规模尽可能大的“愚弄集”。通过完成这个挑战 ，你将深刻理解为什么某些问题在通信上是“困难”的——因为存在一个巨大的输入集合，其中任何两个输入的组合都足以“愚弄”一个不充分的通信协议，迫使通信双方必须交换大量信息才能区分它们。",
            "id": "1421154",
            "problem": "两个独立的计算智能体 Alice 和 Bob，需要合作完成一项計算任务。Alice 接收一个长度为 $n$ 的比特串 $x = x_1x_2...x_n$，Bob 接收一个同样长度为 $n$ 的比特串 $y = y_1y_2...y_n$。他们的目标是确定 $y$ 是否是 $x$ 的按位取反。比特串的按位取反是通过翻转其所有位（将 0 变为 1，1 变为 0）得到的。形式上，他们想要计算一个函数 $f(x, y)$，如果对于所有从 1 到 $n$ 的 $i$ 都有 $y_i = 1 - x_i$，则该函数值为 1，否则为 0。\n\n为了分析这个问题的“难度”，我们感兴趣的是构造一种特殊的集合。考虑一个输入对集合 $S = \\{(x_1, y_1), (x_2, y_2), \\dots, (x_k, y_k)\\}$。如果这个集合满足以下两个标准，则称其为“可区分集”：\n\n1.  **成功标准：** 对于集合 $S$ 中的每一对 $(x_i, y_i)$，函数值必须为 1。即，对于所有的 $i=1, \\dots, k$，都有 $f(x_i, y_i) = 1$。\n2.  **愚弄标准：** 对于集合 $S$ 中的任意两个*不同*的对 $(x_i, y_i)$ 和 $(x_j, y_j)$（其中 $i \\neq j$），“交叉”对 $(x_i, y_j)$ 的函数值必须为 0。即，$f(x_i, y_j) = 0$。\n\n你的任务是确定这样一个可区分集 $S$ 的最大可能大小 $k$。请将你的答案表示为 $n$ 的函数。",
            "solution": "令 $f:\\{0,1\\}^{n}\\times\\{0,1\\}^{n}\\to\\{0,1\\}$ 定义为 $f(x,y)=1$ 当且仅当 $y$ 是 $x$ 的按位取反，即 $y=\\overline{x}$，其中对于所有 $i\\in\\{1,\\dots,n\\}$ 都有 $(\\overline{x})_{i}=1-x_{i}$。\n\n下界（显式构造）：\n考虑集合\n$$\nS^{*}=\\{(x,\\overline{x}) : x\\in\\{0,1\\}^{n}\\}.\n$$\n成功标准：对于 $S^*$ 中的每一個 $(x,\\overline{x})$，根据定义有 $f(x,\\overline{x})=1$。\n愚弄标准：取 $S^*$ 中任意两个不同的对 $(x,\\overline{x})$ 和 $(x',\\overline{x'})$，其中 $x\\neq x'$。那么\n$$\nf(x,\\overline{x'})=1 \\iff \\overline{x'}=\\overline{x} \\iff x'=x,\n$$\n因为 $x\\neq x'$，所以这是不成立的。因此 $f(x,\\overline{x'})=0$。所以 $S^*$ 是一个大小为 $|S^*|=2^{n}$ 的可区分集，这给出了 $k\\geq 2^{n}$。\n\n上界（必要性）：\n令 $S=\\{(x_{i},y_{i})\\}_{i=1}^{k}$ 是任意一个可区分集。根据成功标准，对于每个 $i$ 我们必须有 $y_{i}=\\overline{x_{i}}$。因此，映射 $(x_{i},y_{i})\\mapsto x_{i}$ 在 $S$ 上是单射的，因为如果 $x_{i}=x_{j}$，那么 $y_{i}=\\overline{x_{i}}=\\overline{x_{j}}=y_{j}$，这意味着 $(x_{i},y_{i})=(x_{j},y_{j})$，这与 $i\\neq j$ 时的不同性相矛盾。由于 $x\\in\\{0,1\\}^{n}$ 恰好有 $2^{n}$ 种可能性，因此可得 $k\\leq 2^{n}$。\n\n结合下界和上界，得出最大可能的大小\n$$\nk_{\\max}=2^{n}.\n$$",
            "answer": "$$\\boxed{2^{n}}$$"
        }
    ]
}