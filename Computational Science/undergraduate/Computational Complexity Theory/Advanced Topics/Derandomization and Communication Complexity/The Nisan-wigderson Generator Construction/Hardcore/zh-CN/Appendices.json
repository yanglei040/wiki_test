{
    "hands_on_practices": [
        {
            "introduction": "要真正理解Nisan-Wigderson生成器的构造，最好的方法就是亲自动手计算一次。这个练习将引导你完成一个具体示例，通过给定的种子、布尔函数和索引集，一步步地计算出最终的伪随机输出，从而将抽象的定义转化为切实的计算过程。",
            "id": "1459778",
            "problem": "尼桑-维格德森（Nisan-Wigderson, NW）生成器是一种利用硬布尔函数构造的伪随机生成器。该生成器接收一个短的随机种子，并将其扩展为一个更长的伪随机字符串。\n\n其构造由以下几个部分定义：\n1.  一个长度为 $n$ 的种子字符串 $x$，即 $x \\in \\{0,1\\}^n$。我们将其中的比特表示为 $x = x_1x_2\\dots x_n$。\n2.  一个布尔函数 $f: \\{0,1\\}^k \\to \\{0,1\\}$，其中 $k$ 为某个小于 $n$ 的整数。\n3.  $m$ 个子集的集合 $S_1, S_2, \\dots, S_m$，其中每个子集 $S_i \\subseteq \\{1, 2, \\dots, n\\}$ 的大小为 $|S_i| = k$。\n\n输出字符串的第 $i$ 个比特 $z_i$ 是通过将函数 $f$ 应用于由集合 $S_i$ 索引的种子 $x$ 的比特来计算的。我们将此操作表示为 $z_i = f(x|_{S_i})$，其中 $x|_{S_i}$ 是将每个索引 $j \\in S_i$ 对应的比特 $x_j$ 按升序连接而成的长度为 $k$ 的字符串。最终输出为字符串 $z = z_1z_2\\dots z_m$。\n\n考虑一个具有以下参数的 NW 生成器：\n- 种子长度为 $n=4$。\n- 输出长度为 $m=3$。\n- 种子为 $x = 1101$。\n- 函数 $f: \\{0,1\\}^2 \\to \\{0,1\\}$ 定义为 $f(y_1, y_2) = y_1 \\oplus y_2$，其中 $\\oplus$ 表示按位异或（XOR）操作。\n- 集合为 $S_1 = \\{1, 2\\}$，$S_2 = \\{3, 4\\}$ 和 $S_3 = \\{1, 3\\}$。\n\n计算该生成器在给定种子下产生的 3 比特输出字符串 $z$。",
            "solution": "题目要求我们计算一个特定的尼桑-维格德森（Nisan-Wigderson, NW）生成器的输出字符串。该生成器由一个种子 $x$、一个函数 $f$ 以及一组集合 $S_1, S_2, S_3$ 定义。输出字符串为 $z = z_1z_2z_3$，其中每个比特 $z_i$ 的计算方式为 $z_i = f(x|_{S_i})$。\n\n给定的参数如下：\n- 种子：$x = 1101$。这意味着各个比特为 $x_1=1$, $x_2=1$, $x_3=0$ 和 $x_4=1$。\n- 函数：$f(y_1, y_2) = y_1 \\oplus y_2$。\n- 集合：$S_1 = \\{1, 2\\}$, $S_2 = \\{3, 4\\}$, $S_3 = \\{1, 3\\}$。\n\n我们将逐步计算输出字符串 $z$ 的每个比特。\n\n**第一步：计算第一个输出比特 $z_1$。**\n第一个输出比特由集合 $S_1 = \\{1, 2\\}$ 决定。我们首先提取种子 $x$ 中由 $S_1$ 指定索引的比特。索引为 1 和 2。\n对应的比特是 $x_1=1$ 和 $x_2=1$。\n因此，输入到函数 $f$ 的字符串是 $x|_{S_1} = x_1x_2 = 11$。\n我们将函数 $f$ 应用于这些比特：\n$z_1 = f(1, 1) = 1 \\oplus 1 = 0$。\n\n**第二步：计算第二个输出比特 $z_2$。**\n第二个输出比特由集合 $S_2 = \\{3, 4\\}$ 决定。我们提取种子 $x$ 中索引为 3 和 4 的比特。\n对应的比特是 $x_3=0$ 和 $x_4=1$。\n因此，输入到函数 $f$ 的字符串是 $x|_{S_2} = x_3x_4 = 01$。\n我们将函数 $f$ 应用于这些比特：\n$z_2 = f(0, 1) = 0 \\oplus 1 = 1$。\n\n**第三步：计算第三个输出比特 $z_3$。**\n第三个输出比特由集合 $S_3 = \\{1, 3\\}$ 决定。我们按索引升序提取种子 $x$ 中索引为 1 和 3 的比特。\n对应的比特是 $x_1=1$ 和 $x_3=0$。\n因此，输入到函数 $f$ 的字符串是 $x|_{S_3} = x_1x_3 = 10$。\n我们将函数 $f$ 应用于这些比特：\n$z_3 = f(1, 0) = 1 \\oplus 0 = 1$。\n\n**第四步：构造最终的输出字符串。**\n最终的输出字符串 $z$ 是计算出的比特 $z_1, z_2, z_3$ 的串联。\n$z = z_1z_2z_3 = 011$。\n\n因此，对于给定的种子和参数，该 NW 生成器的输出是字符串 011。",
            "answer": "$$\\boxed{011}$$"
        },
        {
            "introduction": "Nisan-Wigderson生成器的巧妙之处不仅在于使用硬函数，还在于其精巧的组合设计。通过分析一个配置错误的生成器，其中所有索引集都相同，我们可以揭示这个设计的关键作用。这个思想实验可以帮助你直观地理解，为什么索引集之间的小交集对于生成高质量的伪随机比特至关重要。",
            "id": "1459746",
            "problem": "Nisan-Wigderson (NW) 生成器是计算复杂性理论中的一个基本构造，用于从一个平均计算困难的函数创建一个伪随机生成器。该生成器接收一个短的随机种子，并将其扩展为一个对于某一类计算模型而言看起来是随机的更长字符串。\n\n让我们定义一个 NW 生成器的组件：\n1.  一个函数 $f: \\{0,1\\}^k \\to \\{0,1\\}$，它被假设对于某类电路是“困难”的。\n2.  一个长度为 $n$ 的种子 $x$，其中 $x \\in \\{0,1\\}^n$。\n3.  一个组合设计，它是种子比特位索引的 $m$ 个子集的集合：$S_1, S_2, \\dots, S_m \\subseteq \\{1, 2, \\dots, n\\}$，其中每个集合 $S_i$ 的大小为 $k$ (即 $|S_i| = k$)。\n\n生成器产生一个长度为 $m$ 的输出字符串 $y \\in \\{0,1\\}^m$。输出的第 $i$ 位 $y_i$ 是通过将函数 $f$ 应用于由集合 $S_i$ 选择的种子 $x$ 的比特位来计算的。我们将这个比特子序列表示为 $x|_{S_i}$。因此，生成规则是：\n$$ y_i = f(x|_{S_i}) \\text{ for } i = 1, 2, \\dots, m $$\nNW 生成器的安全性和随机性属性关键地依赖于集合 $S_i$ 的组合属性，特别是任意两个不同集合的交集很小。\n\n考虑一个配置错误的 NW 生成器，其中组合设计选择得很差。具体来说，设 $n > k$ 并假设设计中的所有集合都相同。令这个公共集合为 $S = \\{1, 2, \\dots, k\\}$，因此 $S_1 = S_2 = \\dots = S_m = S$。\n\n对于一个随机选择的种子 $x \\in \\{0,1\\}^n$，以下哪个陈述最准确地描述了由这个配置错误的生成器产生的输出字符串 $y \\in \\{0,1\\}^m$？\n\nA. 只要函数 $f$ 足够困难，该生成器仍然可以作为一个有效的伪随机生成器，欺骗任何特定大小的电路。\n\nB. 输出字符串的所有比特位都彼此相同。\n\nC. 对于 $f$ 的任何选择，输出字符串都保证是全零字符串或全一字符串。\n\nD. 输出字符串由 $m$ 个独立且均匀随机的比特组成。\n\nE. 输出比特位高度相关，但它们的确切值从一个比特位到下一个比特位会不可预测地变化。",
            "solution": "我们给定一个配置错误设计的 NW 生成器，其中所有集合都相同：$S_{1}=\\dots=S_{m}=S=\\{1,\\dots,k\\}$。对于任何种子 $x\\in\\{0,1\\}^{n}$，定义 $k$ 比特的限制 $u=x|_{S}\\in\\{0,1\\}^{k}$。根据生成规则，\n$$\ny_{i}=f\\bigl(x|_{S_{i}}\\bigr)=f\\bigl(x|_{S}\\bigr)=f(u)\\quad\\text{for all }i\\in\\{1,\\dots,m\\}.\n$$\n因此，对于任何 $i,j\\in\\{1,\\dots,m\\}$，\n$$\ny_{i}=f(u)=y_{j},\n$$\n所以所有输出比特都是相同的。由于 $f:\\{0,1\\}^{k}\\to\\{0,1\\}$，公共值 $f(u)$ 要么是 $0$ 要么是 $1$，因此输出字符串 $y$ 等于 $0^{m}$ 或 $1^{m}$，具体是哪一个取决于 $x$ 和 $f$。因此，它在任何有意义的层面上都不是一个伪随机生成器：输出比特是完全相关的，并且肯定不是独立的或均匀的。\n\n评估各个选项：\n- A 是错误的，因为输出是退化的（在所有位置上都是常数），所以它不能欺骗合理的电路。\n- B 是正确的：所有比特都相同。\n- C，从字面上看，陈述了对于任何 $f$，输出字符串总是 $0^{m}$ 或 $1^{m}$，对于每个固定的种子 $x$ 来说，情况确实如此。然而，作为一种描述，B 是最准确和最简洁的描述，没有关于对 $x$ 依赖性的模糊性。\n- D 是错误的，因为这些比特既不是独立的，也不是均匀随机的。\n- E 是错误的，因为比特之间没有变化；所有比特都完全相同。\n\n因此，正确选项是 B。",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "NW生成器的安全性基石是其所依赖的布尔函数的“计算困难性”。但这种“困难性”有多稳固呢？这个练习探讨了当我们对硬函数进行一个简单的、公开的线性变换时，生成器的安全性会发生什么变化。通过这个分析，你将更深入地理解密码学中“困难性”的本质，以及它如何转化为可证明的安全性。",
            "id": "1459796",
            "problem": "Nisan-Wigderson (NW) 生成器是计算复杂性理论中的一个基础性构造，它从一个平均情况下难于计算的函数构建一个伪随机生成器。\n\n我们先建立必要的定义。一个函数 $f: \\{0,1\\}^n \\to \\{0,1\\}$ 被称为是 $(S, \\delta)$-难的（hard），如果对于任何最多有 $S$ 个门的布尔电路 $C$，以下不等式成立：\n$$\n\\left| \\Pr_{y \\in_R \\{0,1\\}^n}[C(y) = f(y)] - \\frac{1}{2} \\right| \\le \\delta\n$$\n这里，$y \\in_R \\{0,1\\}^n$ 表示 $y$ 是从所有 $n$-比特字符串的集合中均匀随机选择的。\n\nNW 生成器，记作 $G_f$，使用这样一个函数 $f$ 和一个特定的组合设计，将一个短的随机种子 $x \\in \\{0,1\\}^L$ 扩展成一个更长的伪随机字符串 $G_f(x) \\in \\{0,1\\}^M$。一个关键结果是，如果 $f$ 足够难（即，对于大的 $S$ 和小的 $\\delta$），那么对于任何特定大小的电路，$G_f$ 的输出在计算上都与一个真正的随机字符串无法区分。\n\n现在，考虑一个场景，我们构造一个新的生成器 $G_h$，它使用与 $G_f$ 完全相同的组合设计，但我们将难解函数 $f$ 替换为一个修改后的函数 $h: \\{0,1\\}^n \\to \\{0,1\\}$。这个新函数定义为 $h(y) = f(y \\oplus c)$，其中 $c \\in \\{0,1\\}^n$ 是一个固定的、公开已知的非零常数向量，$\\oplus$ 表示按位异或操作。\n\n假设原始函数 $f$ 足够难，使得 $G_f$ 成为一个能够抵抗所有多项式时间对手的密码学安全伪随机生成器。新生成器 $G_h$ 的安全性与原始生成器 $G_f$ 的安全性相比如何？\n\nA. 生成器 $G_h$ 完全不安全。由于线性变换 `⊕ c` 是公开的，对手可以轻易地将其输出与随机字符串区分开来。\n\nB. $G_h$ 的安全性与 $G_f$ 的完全相同。$h$ 的难度与 $f$ 的难度完全一样。\n\nC. 生成器 $G_h$ 仍然安全，但其可证明的安全性稍弱。它可以保证抵抗的电路类别比 $G_f$ 能抵抗的电路类别略小。\n\nD. $G_h$ 的安全性显著降低（例如，降低了大于2的常数因子）。修改的线性性质使得 $h$ 比 $f$ 更容易近似。\n\nE. $G_h$ 的安全性可证明地强于 $G_f$。常数 $c$ 充当了一个“调整”，增加了底层函数的复杂性，使电路更难计算。",
            "solution": "令 $f:\\{0,1\\}^{n}\\to\\{0,1\\}$ 是 $(S,\\delta)$-难的。定义 $h:\\{0,1\\}^{n}\\to\\{0,1\\}$ 为 $h(y)=f(y\\oplus c)$，其中 $c\\in\\{0,1\\}^{n}$ 是一个固定的非零常数。考虑映射 $\\varphi_{c}:\\{0,1\\}^{n}\\to\\{0,1\\}^{n}$，由 $\\varphi_{c}(y)=y\\oplus c$ 给出。这个映射是一个双射，如果 $y$ 在 $\\{0,1\\}^{n}$ 上是均匀分布的，那么 $z=\\varphi_{c}(y)$ 也是。\n\n从 $h$ 到 $f$ 的难度转移：假设存在一个大小至多为 $S_{h}$ 的电路 $C_{h}$，使得\n$$\n\\left|\\Pr_{y\\in_{R}\\{0,1\\}^{n}}[C_{h}(y)=h(y)]-\\frac{1}{2}\\right|\\geq\\varepsilon.\n$$\n定义电路 $C_{f}$ 为\n$$\nC_{f}(y)\\triangleq C_{h}(y\\oplus c).\n$$\n那么\n$$\n\\Pr_{y}[C_{f}(y)=f(y)]\n=\\Pr_{y}[C_{h}(y\\oplus c)=f(y)]\n=\\Pr_{z}[C_{h}(z)=f(z\\oplus c)]\n=\\Pr_{z}[C_{h}(z)=h(z)].\n$$\n因此 $C_{f}$ 具有相同的优势：\n$$\n\\left|\\Pr_{y}[C_{f}(y)=f(y)]-\\frac{1}{2}\\right|\n=\\left|\\Pr_{z}[C_{h}(z)=h(z)]-\\frac{1}{2}\\right|\n\\geq\\varepsilon.\n$$\n计算 $y\\mapsto y\\oplus c$ 的规模开销至多为 $t=O(n)$ 个门（每个输入位一个异或门），所以 $\\mathrm{size}(C_{f})\\leq S_{h}+t$。因此，如果 $h$ 不是 $(S-t,\\delta)$-难的，那么 $f$ 就不是 $(S,\\delta)$-难的。等价地，从 $f$ 是 $(S,\\delta)$-难的，我们推断出 $h$ 是 $(S-t,\\delta)$-难的。反向（从 $f$ 的电路到 $h$ 的电路）是对称的，并产生相同的 $O(n)$ 加性开销。因此， $f$ 和 $h$ 的难度参数在电路规模上相差一个加性的 $O(n)$ 移位，而优势 $\\delta$ 相同。\n\n对 NW 生成器的影响：标准的 NW 安全性归约指出，如果 $f$ 是 $(S,\\delta)$-难的，并且设计具有适当的参数，那么任何大小至多为 $T$ 的区分器 $D$，如果它能以至少 $\\varepsilon$ 的优势将 $G_{f}$ 与均匀分布区分开来，那么就可以产生一个大小至多为 $\\mathrm{poly}(T)$ 的电路，该电路能在随机输入上以与 $\\varepsilon$ 和 $\\delta$ 相关的优势计算 $f$。用 $h$ 代替 $f$ 运行相同的归约，会产生一个大小至多为 $\\mathrm{poly}(T)$ 且具有可比优势的 $h$ 的预测器；与 $y\\mapsto y\\oplus c$ 复合，可以将其转换为一个对 $f$ 的预测器，其优势相同，但规模上有一个加性的 $O(n)$ 开销。因此，我们能得到与假设的难度相矛盾的区分器 $D$ 的类别，仅仅因为考虑了加性 $O(n)$ 开销的多项式而略微缩小。在渐近意义上，如果 $G_{f}$ 能抵抗所有多项式时间对手，那么 $G_{h}$ 也能，但我们可以证明其安全性的电路规模的精确量化界限，在相应的难度参数上因一个加性的 $O(n)$ 而略微减弱。\n\n因此，通过 $c$ 进行的公开、固定的异或操作既不会使生成器不安全，也不会使其变得更强；它保持了安全性，只是在可证明的参数上有一个微小的、纯技术性的退化，而不是显著的退化，也不是在严格的 $(S,\\delta)$ 计数水平上的完全相同。\n\n因此，正确的选择是 $G_{h}$ 仍然安全，但由于在 $h$ 和 $f$ 之间转换预测器时存在小的加性开销，其可证明的安全性稍弱。",
            "answer": "$$\\boxed{C}$$"
        }
    ]
}