{
    "hands_on_practices": [
        {
            "introduction": "A one-way function must be easy to compute but hard to invert. This first exercise provides a concrete example of a function that meets the first criterion but fails the second. By working through the inversion of a simple bit-shift operation, you will gain a tangible understanding of what makes a function easy to invert and why such operations are unsuitable for cryptographic applications .",
            "id": "1433133",
            "problem": "In the study of computational complexity, a one-way function is a function that is easy to compute on every input but hard to invert on average for a random output. Formally, a function $f$ is a candidate for a one-way function if it can be computed in polynomial time, but no probabilistic polynomial-time algorithm can find a pre-image of $f(x)$ for a non-negligible fraction of inputs $x$.\n\nConsider a function `SHIFT_L(x, k, n)` proposed for a cryptographic application. This function takes an $n$-bit unsigned integer $x$, and performs a cyclic left shift on its binary representation by $k$ positions. For example, if $n=8$ and the input integer has a binary representation of `11010010`, `SHIFT_L` with $k=2$ would produce the binary number `01001011`.\n\nAn analyst is tasked with evaluating this function's suitability as a one-way function. They are given an output integer $y=43$, which was generated by computing $y = \\text{SHIFT\\_L}(x, k, n)$ for some unknown original integer $x$. The parameters used were $n=8$ and $k=3$. To demonstrate that the function is not one-way, the analyst must efficiently find the original integer $x$.\n\nWhat is the value of the original integer $x$?",
            "solution": "We formalize the operation as follows. Let an $n$-bit vector for $x$ be written as $(x_{n-1},\\dots,x_{0})$ with $x_{n-1}$ the most significant bit. Define the cyclic left rotation by $k$ positions, $\\operatorname{LROT}_{n,k}$, by\n$$\n\\operatorname{LROT}_{n,k}(x)_{i} = x_{(i-k)\\bmod n}, \\quad i\\in\\{0,1,\\dots,n-1\\}.\n$$\nThis is a permutation on $\\{0,1\\}^{n}$, hence invertible, with inverse given by the cyclic right rotation by $k$ positions, $\\operatorname{RROT}_{n,k}$:\n$$\n\\operatorname{RROT}_{n,k} = \\operatorname{LROT}_{n,k}^{-1}, \\qquad \\operatorname{RROT}_{n,k}(y)_{i} = y_{(i+k)\\bmod n}.\n$$\nGiven $y=\\operatorname{LROT}_{8,3}(x)$ with $y=43$, we invert by computing $x=\\operatorname{RROT}_{8,3}(y)$.\n\nFirst, write $y$ in 8-bit binary. Since\n$$\n43 = 2^{5} + 2^{3} + 2^{1} + 2^{0},\n$$\nits 8-bit vector (MSB first) is\n$$\ny = (y_{7},y_{6},y_{5},y_{4},y_{3},y_{2},y_{1},y_{0}) = (0,0,1,0,1,0,1,1).\n$$\nApplying the inverse rotation with $n=8$ and $k=3$,\n$$\nx = \\operatorname{RROT}_{8,3}(y) = (y_{2},y_{1},y_{0},y_{7},y_{6},y_{5},y_{4},y_{3}) = (0,1,1,0,0,1,0,1).\n$$\nConvert $x$ back to decimal:\n$$\nx = 0\\cdot 2^{7} + 1\\cdot 2^{6} + 1\\cdot 2^{5} + 0\\cdot 2^{4} + 0\\cdot 2^{3} + 1\\cdot 2^{2} + 0\\cdot 2^{1} + 1\\cdot 2^{0} = 64 + 32 + 4 + 1 = 101.\n$$\nThus the original integer is $x=101$.",
            "answer": "$$\\boxed{101}$$"
        },
        {
            "introduction": "The \"hard to invert\" property is a statement about average-case difficulty, not worst-case. This practice challenges you to analyze a function that is only hard to invert for a negligible fraction of its outputs. This scenario will clarify why a function must be hard to invert on a significant portion of its domain to be considered one-way, as an adversary can achieve high success by simply solving the easy cases .",
            "id": "1433092",
            "problem": "In computational complexity theory, a one-way function is a function that is easy to compute but hard to invert on average. More formally, a function $f: \\{0,1\\}^* \\to \\{0,1\\}^*$ is a one-way function if it satisfies two properties:\n\n1.  **Easy to compute:** There exists a polynomial-time algorithm that computes $f(x)$ for any input $x$.\n2.  **Hard to invert:** For every probabilistic polynomial-time (PPT) algorithm $\\mathcal{A}$, every positive polynomial $p$, and all sufficiently large security parameters $n$, the probability that $\\mathcal{A}$ successfully finds a pre-image for $f(x)$ is negligible. That is,\n    $$ \\Pr_{x \\leftarrow \\{0,1\\}^n, \\text{coins of } \\mathcal{A}} [\\mathcal{A}(f(x)) \\in f^{-1}(f(x))] < \\frac{1}{p(n)} $$\n    where $x$ is chosen uniformly at random from the set of all $n$-bit strings, $\\{0,1\\}^n$. A function of $n$ is considered negligible if it decreases faster than the reciprocal of any polynomial in $n$.\n\nConsider a hypothetical cryptographic function, `QuirkHash`, which maps $n$-bit strings to $n$-bit strings. `QuirkHash` is known to be computable in $O(n^3)$ time. The function has a peculiar property: for a very specific output string, $y_{special} = 1^n$ (a string of $n$ ones), finding any pre-image is computationally infeasible and believed to require exponential time. However, for any output $y \\neq y_{special}$, there exists a public, deterministic polynomial-time algorithm, `EasyInvert`, that can find a pre-image in $O(n^4)$ time.\n\nFurthermore, it is known that the set of inputs $x \\in \\{0,1\\}^n$ that map to the special output, $C_n = \\{x \\in \\{0,1\\}^n \\mid \\text{QuirkHash}(x) = y_{special}\\}$, has a size of $|C_n| = \\lfloor n^2 \\ln(n) \\rfloor$.\n\nAn adversary constructs an algorithm $\\mathcal{A}$ to invert `QuirkHash`. Given an output $y = \\text{QuirkHash}(x)$ (for a randomly chosen $n$-bit input $x$), $\\mathcal{A}$ operates as follows:\n- If $y \\neq y_{special}$, it runs `EasyInvert(y)` and returns the result.\n- If $y = y_{special}$, it gives up and returns 'FAILURE'.\n\nBased on the formal definition of a one-way function, which of the following statements correctly classifies `QuirkHash`?\n\nA. `QuirkHash` is a one-way function because there is at least one output for which it is hard to find a pre-image.\n\nB. `QuirkHash` is a one-way function because the probability of encountering the hard-to-invert case is negligible, meaning the function is hard to invert on average.\n\nC. `QuirkHash` is not a one-way function because there exists a probabilistic polynomial-time algorithm that inverts it with non-negligible probability.\n\nD. `QuirkHash` is not a one-way function because a one-way function must be hard to invert for every possible output in its range.\n\nE. The classification of `QuirkHash` cannot be determined because the hardness of inverting $y_{special}$ is only a belief, not a proven fact.",
            "solution": "We first restate the one-way condition precisely. A function $f:\\{0,1\\}^{*}\\to\\{0,1\\}^{*}$ is one-way if:\n- It is computable in polynomial time.\n- For every probabilistic polynomial-time (PPT) algorithm $\\mathcal{A}$, every positive polynomial $p$, and all sufficiently large $n$, the inversion success probability is negligible, i.e.,\n$$\n\\Pr_{x \\leftarrow \\{0,1\\}^{n},\\,\\text{coins of }\\mathcal{A}}\\left[\\mathcal{A}(f(x)) \\in f^{-1}(f(x))\\right] < \\frac{1}{p(n)}.\n$$\n\nQuirkHash is computable in $O(n^{3})$ time, so it satisfies the easy-to-compute property.\n\nDefine $y_{special} = 1^{n}$ and $C_{n} = \\{x \\in \\{0,1\\}^{n} : \\text{QuirkHash}(x) = y_{special}\\}$ with $|C_{n}| = \\lfloor n^{2}\\ln(n) \\rfloor$. For any $y \\neq y_{special}$ there is a deterministic polynomial-time inverter EasyInvert that finds a preimage in $O(n^{4})$ time.\n\nConsider the PPT algorithm $\\mathcal{A}$ described:\n- On input $y = \\text{QuirkHash}(x)$ for $x \\leftarrow \\{0,1\\}^{n}$ uniformly, if $y \\neq y_{special}$, output EasyInvert$(y)$; otherwise output FAILURE.\nThis $\\mathcal{A}$ runs in polynomial time because EasyInvert runs in $O(n^{4})$ time and the decision $y \\stackrel{?}{=} y_{special}$ is trivial.\n\nCompute its success probability. Since $\\mathcal{A}$ always succeeds when $y \\neq y_{special}$ and always fails when $y = y_{special}$, we have\n$$\n\\Pr\\left[\\mathcal{A}(\\text{QuirkHash}(x)) \\in \\text{QuirkHash}^{-1}(\\text{QuirkHash}(x))\\right]\n= \\Pr\\left[\\text{QuirkHash}(x) \\neq y_{special}\\right]\n= 1 - \\Pr\\left[\\text{QuirkHash}(x) = y_{special}\\right].\n$$\nBecause $x$ is uniform over $\\{0,1\\}^{n}$,\n$$\n\\Pr\\left[\\text{QuirkHash}(x) = y_{special}\\right] = \\frac{|C_{n}|}{2^{n}} = \\frac{\\lfloor n^{2}\\ln(n) \\rfloor}{2^{n}} \\leq \\frac{n^{2}\\ln(n)}{2^{n}}.\n$$\nHence\n$$\n\\Pr\\left[\\mathcal{A}(\\text{QuirkHash}(x)) \\in \\text{QuirkHash}^{-1}(\\text{QuirkHash}(x))\\right]\n\\geq 1 - \\frac{n^{2}\\ln(n)}{2^{n}}.\n$$\n\nWe now show that the failure probability $\\frac{n^{2}\\ln(n)}{2^{n}}$ is negligible. Using the fact that for sufficiently large $n$, $\\ln(n) \\leq n$, we obtain\n$$\n\\frac{n^{2}\\ln(n)}{2^{n}} \\leq \\frac{n^{3}}{2^{n}}\n$$\nfor all sufficiently large $n$. Since $\\lim_{n \\to \\infty} \\frac{n^{k}}{2^{n}} = 0$ for any fixed $k$, it follows that $\\frac{n^{3}}{2^{n}}$ is negligible, and therefore $\\frac{n^{2}\\ln(n)}{2^{n}}$ is negligible as well. Consequently, the success probability satisfies\n$$\n\\Pr\\left[\\mathcal{A}(\\text{QuirkHash}(x)) \\in \\text{QuirkHash}^{-1}(\\text{QuirkHash}(x))\\right]\n= 1 - \\text{negl}(n),\n$$\nwhich is non-negligible. In particular, there exists a positive polynomial $p$ (for example, $p(n) = 2$) such that for all sufficiently large $n$,\n$$\n\\Pr\\left[\\mathcal{A}(\\text{QuirkHash}(x)) \\in \\text{QuirkHash}^{-1}(\\text{QuirkHash}(x))\\right] \\geq \\frac{1}{p(n)}.\n$$\nTherefore, there exists a PPT algorithm that inverts QuirkHash with non-negligible probability. By the formal definition, this violates the hard-to-invert condition required for one-way functions.\n\nEvaluating the options:\n- A is false: hardness for a single output does not suffice for one-wayness.\n- B is false: a negligible fraction of hard instances implies the function is easy to invert on average, not hard.\n- C is true: the described $\\mathcal{A}$ inverts with non-negligible (indeed, overwhelming) probability.\n- D is false: one-wayness is an average-case notion, not a worst-case-for-every-output requirement.\n- E is false: the classification does not depend on proving hardness for $y_{special}$; the existence of the efficient inverter on the overwhelming majority of outputs already certifies that the function is not one-way.\n\nHence the correct classification is C.",
            "answer": "$$\\boxed{C}$$"
        },
        {
            "introduction": "Strong cryptographic security implies that no partial information about an input can be feasibly guessed from its output. This advanced exercise demonstrates how a seemingly minor informational leak—the ability to predict a single property of the input with a slight advantage—can be amplified to completely break a function's one-wayness. You will explore how a small statistical edge can be leveraged to reconstruct a secret input, illustrating the core idea behind the influential Goldreich-Levin theorem .",
            "id": "1433102",
            "problem": "In computational complexity theory, a one-way function (OWF) is a function that is easy to compute but hard to invert. The existence of OWFs is a cornerstone for modern cryptography. Their existence implies $P \\neq NP$, one of the most profound connections between cryptography and computational complexity.\n\nA function $h(x)$ is called a hard-core predicate for a function $f(x)$ if $h(x)$ is easy to compute from $x$, but is computationally difficult to guess from the value of $f(x)$ with a probability significantly better than $1/2$. The Goldreich-Levin theorem shows that any OWF can be modified to have a specific, provably hard-core predicate.\n\nConsider a one-way function $f: \\{0,1\\}^n \\to \\{0,1\\}^m$. Suppose a hypothetical algorithm, `ParityPredictor`, exists that, given a value $y=f(x)$, can guess the parity of the bit-string $x$, which is defined as $P(x) = \\left(\\sum_{i=1}^n x_i\\right) \\pmod 2 = \\langle x, \\mathbf{1} \\rangle$, where $\\mathbf{1}$ is the $n$-bit vector of all ones and $\\langle\\cdot, \\cdot\\rangle$ is the dot product modulo 2. The success probability of this predictor is known to be exactly $p_{\\text{succ}} = \\frac{1}{2} + \\epsilon$ for some $\\epsilon \\in (0, 1/2]$.\n\nIt is a known result that such a predictor for the specific vector $\\mathbf{1}$ can be transformed into a more general `InnerProductPredictor`. This powerful predictor, given $y=f(x)$ and any arbitrary $n$-bit vector $r$, can guess the value of the inner product $\\langle x, r \\rangle = \\left(\\sum_{i=1}^n x_i r_i\\right) \\pmod 2$ with the same success probability, $\\frac{1}{2} + \\epsilon$.\n\nTo find a single bit $x_k$ of the secret input $x$ (where $x_k = \\langle x, e_k \\rangle$ and $e_k$ is the standard basis vector with a 1 in position $k$), the following procedure is executed once:\n1.  A uniformly random $n$-bit vector $r$ is generated.\n2.  The `InnerProductPredictor` is called to produce a guess, let's call it $G_1$, for the true bit $b_1 = \\langle x, r \\rangle$.\n3.  The `InnerProductPredictor` is called again to produce a guess, $G_2$, for the true bit $b_2 = \\langle x, r \\oplus e_k \\rangle$, where $\\oplus$ denotes bitwise XOR.\n4.  The final guess for the bit $x_k$ is calculated as $G_k = G_1 \\oplus G_2$.\n\nAssuming that the two guesses $G_1$ and $G_2$ are statistically independent events, what is the probability that this procedure correctly determines the bit $x_k$? Express your answer as a closed-form analytic expression in terms of $\\epsilon$.",
            "solution": "Let $b_{1}=\\langle x,r\\rangle$ and $b_{2}=\\langle x,r\\oplus e_{k}\\rangle$. Using linearity of the inner product over $\\mathbb{F}_{2}$, we have\n$$\n\\langle x,r\\oplus e_{k}\\rangle=\\langle x,r\\rangle\\oplus\\langle x,e_{k}\\rangle=b_{1}\\oplus x_{k}.\n$$\nHence $x_{k}=b_{1}\\oplus b_{2}$. The procedure outputs $G_{k}=G_{1}\\oplus G_{2}$, so it is correct exactly when\n$$\nG_{1}\\oplus G_{2}=b_{1}\\oplus b_{2}\\quad\\Longleftrightarrow\\quad (G_{1}\\oplus b_{1})=(G_{2}\\oplus b_{2}).\n$$\nThus the output is correct if both individual guesses are correct or both are wrong. Let $p=\\frac{1}{2}+\\epsilon$ be the success probability of each call to the predictor and assume independence of the two guesses as stated. Then the probability of correctly determining $x_{k}$ is\n$$\np^{2}+(1-p)^{2}.\n$$\nSubstituting $p=\\frac{1}{2}+\\epsilon$ and simplifying,\n$$\np^{2}+(1-p)^{2}=\\left(\\frac{1}{2}+\\epsilon\\right)^{2}+\\left(\\frac{1}{2}-\\epsilon\\right)^{2}=\\frac{1}{2}+2\\epsilon^{2}.\n$$\nTherefore, under the independence assumption, the procedure correctly determines $x_{k}$ with probability $\\frac{1}{2}+2\\epsilon^{2}$.",
            "answer": "$$\\boxed{\\frac{1}{2}+2\\epsilon^{2}}$$"
        }
    ]
}