{
    "hands_on_practices": [
        {
            "introduction": "现代密码学的核心挑战之一是在不安全的信道上建立共享密钥。Diffie-Hellman密钥交换协议巧妙地解决了这个问题，其安全性依赖于计算离散对数的难度。本练习将通过一个具体的小规模示例，让你亲手实践该协议的计算过程，从而直观地理解其工作原理以及为何在实际应用中必须使用大素数。",
            "id": "1363092",
            "problem": "在一门学习密码学的计算机科学课上，两名学生 Alice 和 Bob 决定使用迪菲-赫尔曼密钥交换协议来建立一个共享密钥。他们公开约定了一个素数模数 $p=41$ 和一个用作底数的模 $p$ 的原根 $g=7$。\n\nAlice 选择了一个只有她自己知道的秘密整数 $a$。然后她使用公式 $A = g^a \\pmod{p}$ 计算她的公钥 $A$。她通过教室的公共网络传输这个值 $A$。\n\n窃听者 Eve 也在网络上，并截获了公共参数 $p=41$ 和 $g=7$，以及 Alice 的公钥，她观察到其值为 $A=8$。Eve 怀疑，在这次初次尝试中，Alice 从小整数集合 $\\{2, 3, 4\\}$ 中选择了她的秘密密钥 $a$。通过测试这些可能的值，确定 Alice 的秘密密钥 $a$。",
            "solution": "我们已知 $p=41$，$g=7$，以及 Alice 的公钥 $A=8$。迪菲-赫尔曼关系式为 $A \\equiv g^{a} \\pmod{p}$。Eve 怀疑 $a \\in \\{2,3,4\\}$，所以我们通过计算 $7^{a} \\pmod{41}$ 并与 $8$ 进行比较来测试每个候选值。\n\n计算 $a=2$ 的情况：\n$$\n7^{2} = 49 \\equiv 49 - 41 = 8 \\pmod{41}.\n$$\n因此 $7^{2} \\equiv 8 \\pmod{41}$，与 $A$ 相匹配。\n\n为了完整性，我们检查其他候选值。\n\n对于 $a=3$：\n$$\n7^{3} \\equiv 7 \\cdot 7^{2} \\equiv 7 \\cdot 8 = 56 \\equiv 56 - 41 = 15 \\pmod{41} \\neq 8.\n$$\n\n对于 $a=4$：\n$$\n7^{4} \\equiv (7^{2})^{2} \\equiv 8^{2} = 64 \\equiv 64 - 41 = 23 \\pmod{41} \\neq 8.\n$$\n\n因此，在给定集合中满足 $7^{a} \\equiv 8 \\pmod{41}$ 的唯一值是 $a=2$。",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "有了共享密钥后，我们如何安全地加密消息？一个安全的加密方案不应泄露关于明文的任何信息，即使是不同明文之间的关系也不例外，这一性质通常与“语义安全”的概念相关。这个练习将揭示一个常见的陷阱——确定性加密的弱点——它展示了即使密钥未被破解，攻击者也能通过观察密文模式推断出有价值的信息。",
            "id": "1428754",
            "problem": "一家名为“Innovate Inc.”的科技初创公司开发了一种新的通信协议，用于在其服务器之间发送每日状态更新。每日更新总是两种可能的消息之一：$M_{GOOD} = \\text{\"System nominal\"}$ 或 $M_{BAD} = \\text{\"Anomaly detected\"}$。\n\n为了保护这些消息免受竞争对手“Specter Corp.”的窃取，Innovate Inc. 采用了一种对称加密方案，该方案由一对算法 `Enc`（加密）和 `Dec`（解密）定义。这个特定的方案是**确定性的**，这意味着对于给定的密钥 $k$ 和明文消息 $m$，加密函数 `Enc(k, m)` 将始终产生完全相同的密文 $c$。Innovate Inc. 每天使用相同的密钥 $k$ 来加密其每日状态更新。\n\nSpecter Corp. 的一位名叫 Eve 的分析师成功截获了连续两天的加密消息。设 $c_1$ 是第一天的密文，$c_2$ 是第二天的密文。Eve 不知道密钥 $k$，但她知道加密算法的确定性特性，并且知道可能的明文消息集合 $\\{M_{GOOD}, M_{BAD}\\}$。\n\n仅根据她对 $c_1$ 和 $c_2$ 的观察和比较，Eve 能可靠地推断出什么最重要的信息？\n\nA. 第一天的系统状态是否与第二天的相同。\n\nB. 用于加密的密钥 $k$。\n\nC. 第一天消息的具体内容（即，是 $M_{GOOD}$ 还是 $M_{BAD}$）。\n\nD. 第二天消息的具体内容（即，是 $M_{GOOD}$ 还是 $M_{BAD}$）。\n\nE. 没有任何有价值的信息，因为密钥仍然是保密的。\n\nF. 第一天和第二天消息的具体内容。",
            "solution": "该问题探讨了在密钥重用时确定性加密方案的一个基本弱点。让我们一步步分析这个场景。\n\n加密方案由 `Enc(k, m)` 定义，其中 $k$ 是密钥，$m$ 是明文消息。其关键特性是该方案是**确定性的**。这意味着如果使用相同的密钥多次加密相同的消息，你将总是得到相同的密文。\n\n设 $m_1$ 是第一天的明文消息，$m_2$ 是第二天的明文消息。Eve 截获的相应密文是：\n$c_1 = \\text{Enc}(k, m_1)$\n$c_2 = \\text{Enc}(k, m_2)$\n\nEve 的目标是通过比较 $c_1$ 和 $c_2$ 来提取信息。\n\n让我们考虑两种情况：\n\n情况 1：两天的系统状态相同。\n这意味着 $m_1 = m_2$。\n因为加密函数 `Enc` 是确定性的，并且密钥 $k$ 是相同的，所以将 `Enc` 应用于相同的输入 $(k, m_1)$ 和 $(k, m_2)$ 必须产生相同的输出。\n因此，如果 $m_1 = m_2$，那么必然有 $\\text{Enc}(k, m_1) = \\text{Enc}(k, m_2)$，这意味着 $c_1 = c_2$。\n\n情况 2：两天的系统状态不同。\n这意味着 $m_1 \\neq m_2$。\n一个有效的加密方案必须是可逆的（否则解密会产生歧义）。这意味着对于一个固定的密钥 $k$，两个不同的明文必须映射到两个不同的密文。如果对于 $m_1 \\neq m_2$ 有 $\\text{Enc}(k, m_1) = \\text{Enc}(k, m_2)$，那么就不可能知道应该将得到的密文解密为 $m_1$ 还是 $m_2$。\n因此，如果 $m_1 \\neq m_2$，那么必然有 $\\text{Enc}(k, m_1) \\neq \\text{Enc}(k, m_2)$，这意味着 $c_1 \\neq c_2$。\n\n结合这两种情况，我们建立了一个直接的等价关系：\n$m_1 = m_2 \\iff c_1 = c_2$\n\nEve 可以对她截获的两个密文 $c_1$ 和 $c_2$ 进行简单的字符串比较。\n- 如果她发现 $c_1$ 与 $c_2$ 相同，她可以确定地得出结论，明文消息是相同的，即 $m_1 = m_2$。\n- 如果她发现 $c_1$ 与 $c_2$ 不同，她可以确定地得出结论，明文消息是不同的，即 $m_1 \\neq m_2$。\n\n这是一个显著的信息泄露。攻击者无法从密文（除了其长度之外）中学习到任何关于明文的信息，这一特性被称为语义安全性。通过了解到两个明文之间的关系（它们是否相等），这种确定性方案未能为多个消息提供语义安全性。\n\n现在让我们评估给出的选项：\n\nA. **第一天的系统状态是否与第二天的相同。** 这正是我们所展示的 Eve 可以确定的事情。通过检查 $c_1 = c_2$ 是否成立，她可以知道 $m_1 = m_2$ 是否成立。这个陈述是正确的。\n\nB. **用于加密的密钥 $k$。** 问题中没有任何信息能让 Eve 逆转加密过程并找到密钥。确定性本身并不意味着加密算法在密钥恢复方面是薄弱的。这个陈述是不正确的。\n\nC. **第一天消息的具体内容。** 即使 Eve 知道 $m_1=m_2$（因为 $c_1=c_2$），她也不知道两条消息是都是 $M_{GOOD}$ 还是都是 $M_{BAD}$。她只知道它们是相同的。没有密钥 $k$，她无法计算 $m_1 = \\text{Dec}(k, c_1)$。这个陈述是不正确的。\n\nD. **第二天消息的具体内容。** 与 C 的原因相同，这个陈述是不正确的。\n\nE. **没有任何有价值的信息，因为密钥仍然是保密的。** 这是不正确的。Eve 获得了一条有价值的信息：两条消息之间的关系。例如，如果她知道第一天是 \"System nominal\"，并且她在第二天看到了相同的密文，那么她现在就知道第二天也是 \"System nominal\"，即使不知道密钥。信息泄露是真实存在的。\n\nF. **第一天和第二天消息的具体内容。** 这是一个比 C 和 D 更强的断言，并且由于同样的原因也是不正确的。\n\n因此，Eve 能推断出的最重要且最可靠的信息是，这两天的状态是相同还是不同。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "公钥密码学的代表——RSA算法，其基础数学原理简洁而强大。然而，未经适当处理的“教科书式”RSA实现存在严重的安全漏洞，因为它具有乘法同态性。通过这个实践，你将扮演攻击者的角色，利用选择密文攻击来破解一个简化的RSA系统，从而深刻理解为何在实际部署中必须使用密码学填充方案（如OAEP）来确保安全。",
            "id": "1428770",
            "problem": "一家公司使用 Rivest-Shamir-Adleman (RSA) 密码系统的一种简化实现来保护内部通信。这种“教科书式”版本的 RSA 直接加密消息，不使用任何密码学填充方案。该公司的公钥为 $(n, e) = (2537, 13)$。\n\n攻击者 Eve 截获了一条发送给某位经理的加密消息。密文为 $C = 2275$。Eve 的目标是确定原始明文消息，即整数 $M$。\n\nEve 发现公司解密服务器中存在一个漏洞。该服务器会解密提交给它的任何有效密文，并提供相应的明文。然而，作为一项基本安全措施，它被硬编码为拒绝解密特定的密文 $C = 2275$。\n\n为了规避这一点，Eve 采用了一种选择密文攻击。她选择了一个整数乘数 $r=2$。然后，她计算出一个新的、经过修改的密文 $C' = (C \\cdot r^e) \\pmod{n}$。由于 $C' \\neq C$，服务器将处理她的请求。Eve 将 $C'$ 提交给解密服务器，并收到了解密后的消息 $M' = 1706$。\n\n给定服务器的响应 $M'$、Eve 选择的乘数 $r$ 和公钥，请确定原始的秘密消息 $M$。",
            "solution": "该问题描述了针对教科书式 RSA 的选择密文攻击，由于其同态特性，这种 RSA 是易受攻击的。具体来说，RSA 具有乘法同态性。让我们将加密函数表示为 $E(m) = m^e \\pmod{n}$，解密函数表示为 $D(c) = c^d \\pmod{n}$。乘法同态性意味着对于任意两个明文 $m_1$ 和 $m_2$，其密文的乘积在解密后会得到明文的乘积：\n$D(E(m_1) \\cdot E(m_2)) \\equiv m_1 \\cdot m_2 \\pmod{n}$。\n\n在此场景中，攻击者 (Eve) 拥有原始密文 $C = E(M) = M^e \\pmod{n}$。她无法直接从服务器获取 $D(C)$。\n相反，她创建了一个新的密文 $C'$。她选择一个乘数 $r=2$ 并计算其加密结果 $E(r) = r^e \\pmod{n}$。然后她将原始密文与她所选乘数的加密结果相乘，构成新的密文 $C'$：\n$C' \\equiv C \\cdot r^e \\pmod{n}$\n\n这个新密文 $C'$ 被提交到解密服务器。服务器计算并返回 $M'$，即 $C'$ 的解密结果：\n$M' = D(C') = D(C \\cdot r^e)$\n\n利用 RSA 解密的同态特性：\n$M' \\equiv D(C) \\cdot D(r^e) \\pmod{n}$\n\n我们知道 $D(C)$ 是原始消息 $M$，而 $D(r^e)$ 就是 $r$：\n$D(C) = D(E(M)) = M$\n$D(r^e) = D(E(r)) = r$\n\n将这些代入 $M'$ 的表达式中，我们得到原始消息 $M$、返回的消息 $M'$ 和 Eve 的乘数 $r$ 之间的关系：\n$M' \\equiv M \\cdot r \\pmod{n}$\n\n给定值为 $M' = 1706$，$r=2$ 和 $n=2537$。我们的目标是解出 $M$。\n$1706 \\equiv M \\cdot 2 \\pmod{2537}$\n\n为了分离出 $M$，我们需要在同余式两边乘以 $r$ 模 $n$ 的模乘法逆元。也就是说，我们需要找到 $r^{-1}$ 使得 $r \\cdot r^{-1} \\equiv 1 \\pmod{n}$。在本例中，我们需要找到 $2^{-1} \\pmod{2537}$。我们可以使用扩展欧几里得算法来求解方程 $2x + 2537y = 1$。\n\n通过观察，我们可以重新排列最大公约数 (GCD) 的方程：\n$2537 = 1268 \\cdot 2 + 1$\n$1 = 2537 - 1268 \\cdot 2$\n\n对该方程模 2537：\n$1 \\equiv (2537 - 1268 \\cdot 2) \\pmod{2537}$\n$1 \\equiv 0 - 1268 \\cdot 2 \\pmod{2537}$\n$1 \\equiv -1268 \\cdot 2 \\pmod{2537}$\n\n所以，$2$ 的模逆元是 $-1268$。为了找到等价的最小正整数，我们加上模数：\n$r^{-1} \\equiv -1268 + 2537 \\pmod{2537}$\n$r^{-1} \\equiv 1269 \\pmod{2537}$\n\n现在我们可以解出 $M$：\n$M \\equiv M' \\cdot r^{-1} \\pmod{n}$\n$M \\equiv 1706 \\cdot 1269 \\pmod{2537}$\n\n我们执行乘法运算：\n$1706 \\cdot 1269 = 2164914$\n\n最后，我们求这个乘积除以 $n=2537$ 的余数：\n$2164914 \\div 2537 = 853.336...$\n为了求余数，我们可以计算 $2164914 - 853 \\cdot 2537$：\n$853 \\cdot 2537 = 2164061$\n$2164914 - 2164061 = 853$\n\n所以，$M \\equiv 853 \\pmod{2537}$。\n原始的秘密消息是 $M=853$。",
            "answer": "$$\\boxed{853}$$"
        }
    ]
}