{
    "hands_on_practices": [
        {
            "introduction": "我们首先在熟悉的复杂性类 NP 和概率可检查证明 (PCP) 这个新概念之间搭建一座桥梁。这个练习将 NP 问题的标准验证过程建模为一个“朴素”的 PCP 系统，以此来阐明随机性 ($r(n)$) 和查询复杂性 ($q(n)$) 在 PCP 定义中的角色。通过这种方式，我们可以更深刻地理解 PCP 定理的非凡之处——它能用极少的资源完成验证。",
            "id": "1420240",
            "problem": "在计算复杂性理论中，NP 类（代表非确定性多项式时间）包含所有这样的判定问题：其“是”实例拥有一个可以在多项式时间内验证的证据。形式上，一个语言 $L$ 属于 $\\mathrm{NP}$，如果存在一个多项式时间的确定性图灵机 $V$（称为验证机）和一个多项式 $p$，使得对于任何长度为 $n$ 的输入 $x$：\n- 如果 $x \\in L$，存在一个长度为 $|c| \\le p(n)$ 的证据字符串 $c$，使得 $V(x, c)$ 接受。\n- 如果 $x \\notin L$，对于所有长度为 $|c| \\le p(n)$ 的证据 $c$，$V(x, c)$ 拒绝。\n\n另外，我们定义 $\\mathrm{PCP}(r(n), q(n))$ 类，即概率可检验证明（Probabilistically Checkable Proofs）。一个语言 $L$ 属于 $\\mathrm{PCP}(r(n), q(n))$，如果存在一个概率多项式时间验证机 $V$，该验证机可以预言机访问一个证明字符串 $\\pi$。对于一个长度为 $n$ 的输入 $x$，验证机 $V$ 最多使用 $O(r(n))$ 个随机比特，并对证明 $\\pi$ 进行最多 $O(q(n))$ 次非自适应查询。其条件如下：\n- 完备性：如果 $x \\in L$，存在一个证明 $\\pi$，使得 $V^{\\pi}(x)$ 以概率 1 接受。\n- 可靠性：如果 $x \\notin L$，对于所有证明 $\\pi'$，$V^{\\pi'}(x)$ 以最多 $1/2$ 的概率接受。\n\n现在，考虑一个语言 $L \\in \\mathrm{NP}$。我们可以使用 PCP 框架来为标准的 NP 验证过程建模。让我们将 NP 证据 $c$ 视为 PCP 证明 $\\pi$。假设我们构建一个特殊的、“朴素”的 PCP 验证机，对于给定的输入 $x$，它只是简单地模拟原始的 NP 验证机。这个朴素的验证机确定性地读取*整个*证明 $\\pi$（长度最多为 $p(n)$），然后完全按照 NP 验证机 $V$ 的方式决定接受或拒绝。\n\n以下哪个选项正确地描述了这种特定的朴素验证机的随机性和查询复杂度 $(r(n), q(n))$？\n\nA. $r(n) = 0$, $q(n) = p(n)$\n\nB. $r(n) = O(\\log n)$, $q(n) = O(1)$\n\nC. $r(n) = p(n)$, $q(n) = 0$\n\nD. $r(n) = 0$, $q(n) = O(\\log n)$\n\nE. $r(n) = O(\\log p(n))$, $q(n) = O(1)$",
            "solution": "根据 NP 的定义，存在一个确定性多项式时间验证机 $V$ 和一个多项式 $p$，使得对于任何长度为 $n$ 的输入 $x$，一个长度为 $|c| \\le p(n)$ 的证据 $c$ 会使得 $V(x,c)$ 接受，当且仅当 $x \\in L$。为了在 PCP 框架中对此进行建模，我们将证明预言机 $\\pi$ 精确地设为证据 $c$。\n\n考虑所述的朴素 PCP 验证机：对于输入 $x$，它确定性地读取整个证明 $\\pi$ 并模拟 $V(x,\\pi)$。由于该验证机是确定性的，不使用任何随机比特，因此使用的随机比特数为\n$$\nr(n) = 0.\n$$\n在 PCP 模型中，一次查询是访问证明预言机 $\\pi$ 的一个索引。读取长度最多为 $p(n)$ 的整个证明需要查询 $\\pi$ 的每个位置，因此非自适应查询的数量满足\n$$\nq(n) = p(n).\n$$\n这个验证机具有完备性概率 $1$（如果 $x \\in L$，存在 $\\pi$ 使其接受）和可靠性概率 $0$（如果 $x \\notin L$，它对所有 $\\pi$ 都拒绝），这与 PCP 定义中可靠性要求最多为 $\\frac{1}{2}$ 是一致的。\n\n因此，对于随机性和查询复杂度的正确选择是这对值 $(r(n), q(n)) = (0, p(n))$，这对应于选项 A。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "PCP 系统的完备性 (completeness) 和可靠性 (soundness) 的定义精确而微妙，其中量词的使用至关重要。本练习通过构造一个用于验证补语言 $\\bar{L}$ 的新验证器来探讨这些定义的逻辑结构。完成这个练习将帮助你更清晰地理解完备性定义中的存在量词（“存在一个证明”）和可靠性定义中的全称量词（“对于所有证明”）之间的关键区别 ()。",
            "id": "1420190",
            "problem": "在计算复杂性理论的研究中，一个针对语言 $L$ 的概率可检验证明 (Probabilistically Checkable Proof, PCP) 系统提供了一种只需检查证明的少量比特就能以高置信度验证该证明的方法。该系统由一个随机多项式时间验证者 $V$ 定义。\n\n此类验证者的属性由两个参数来刻画，即完备性 $c$ 和可靠性 $s$，它们是介于 0 和 1 之间的概率，且 $c  s$：\n- **完备性**：对于任何属于语言 $L$ 的输入串 $x$（即 $x \\in L$），存在一个证明串 $\\pi$，使得验证者 $V$ 在输入为 $x$ 并可访问证明 $\\pi$ 的情况下运行时，以至少为 $c$ 的概率接受。该概率是基于验证者的内部随机选择计算的。\n- **可靠性**：对于任何不属于语言 $L$ 的输入串 $x$（即 $x \\notin L$），以及对于任何可能的证明串 $\\pi'$，验证者 $V$ 以至多为 $s$ 的概率接受。\n\n现在，考虑一个基于 $V$ 构建的新验证者 $V'$。对于任意给定的输入 $x$ 和证明 $\\pi$，验证者 $V'$ 接受当且仅当 $V$ 拒绝，并且 $V'$ 拒绝当且仅当 $V$ 接受。这个新验证者 $V'$ 可以被看作是补语言 $\\bar{L} = \\{x \\mid x \\notin L\\}$ 的一个验证者。\n\n设 $c'$ 和 $s'$ 分别是新验证者 $V'$ 对于语言 $\\bar{L}$ 的完备性和可靠性参数。下列哪个陈述正确地描述了 $c'$ 和 $s'$？\n\nA. 新的完备性是 $c' = 1-s$，新的可靠性是 $s' = 1-c$。\n\nB. 新的完备性是 $c' = s$，新的可靠性是 $s' = c$。\n\nC. 新的完备性是 $c' = 1-s$，但可靠性 $s'$ 无法根据给定信息确定。\n\nD. 新的完备性是 $c' = 1-c$，但可靠性 $s'$ 无法根据给定信息确定。\n\nE. 完备性 $c'$ 和可靠性 $s'$ 都无法根据给定信息确定。",
            "solution": "设 $V$ 是语言 $L$ 的一个验证者，其完备性为 $c$，可靠性为 $s$。对于任意输入 $x$ 和证明 $\\pi$，定义\n$$\np_{V}(x,\\pi) = \\Pr[V \\text{ accepts } (x,\\pi)],\n$$\n其中概率是基于 $V$ 的内部随机性计算的。定义 $V'$ 接受当且仅当 $V$ 拒绝。那么对于相同的随机性和证明，我们有\n$$\np_{V'}(x,\\pi) = 1 - p_{V}(x,\\pi).\n$$\n\n我们将 $V'$ 作为补语言 $\\bar{L}$ 的验证者进行分析。\n\n$V'$ 对于 $\\bar{L}$ 的完备性：取 $x \\in \\bar{L}$，即 $x \\notin L$。根据 $V$ 的可靠性，对于每一个证明 $\\pi$，\n$$\np_{V}(x,\\pi) \\leq s,\n$$\n因此\n$$\np_{V'}(x,\\pi) = 1 - p_{V}(x,\\pi) \\geq 1 - s.\n$$\n因此，存在一个证明（实际上是每一个证明）使得 $V'$ 以至少 $1 - s$ 的概率接受。因此我们可以取\n$$\nc' = 1 - s.\n$$\n这是从给定参数中可以推导出的最紧的保证下界，因为可能存在某些实例和验证者，对于它们来说，不等式 $p_{V}(x,\\pi) \\leq s$ 对所有证明都成立且为紧的（即取等）。\n\n$V'$ 对于 $\\bar{L}$ 的可靠性：取 $x \\in L$。对于任意证明 $\\pi$，\n$$\np_{V'}(x,\\pi) = 1 - p_{V}(x,\\pi).\n$$\n可靠性要求对所有证明 $\\pi$ 都成立的 $p_{V'}(x,\\pi)$ 的一个上界。$V$ 对于 $x \\in L$ 的完备性仅保证了存在某个证明 $\\pi^{\\ast}$ 使得 $p_{V}(x,\\pi^{\\ast}) \\geq c$，这意味着 $p_{V'}(x,\\pi^{\\ast}) \\leq 1 - c$。然而，这并未对其他证明的 $p_{V}(x,\\pi)$ 施加约束；特别是，可能存在一些证明，其 $p_{V}(x,\\pi)$ 的值任意小，从而使得 $p_{V'}(x,\\pi)$ 的值任意接近于 1。因此，仅从 $c$ 和 $s$ 无法推断出任何严格小于 1 的非平凡通用上界，我们也无法根据给定信息确定一个具体的 $s'$。特别是，我们不能得出 $s' = 1 - c$ 的结论。\n\n因此，正确的陈述是 $c' = 1 - s$，而 $s'$ 无法根据给定信息确定。",
            "answer": "$$\\boxed{C}$$"
        },
        {
            "introduction": "掌握了 PCP 的基本定义后，我们将注意力转向著名的 PCP 定理本身。这个问题描述了一个验证器，其资源使用——对数级别的随机性和常数级别的查询次数——恰好与 PCP 定理中的参数相匹配 ()。通过分析这个验证器，你可以直接应用 PCP 定理，将一个具体的证明系统与复杂性类 NP 联系起来，从而体会该定理在问题分类中的强大威力。",
            "id": "1420205",
            "problem": "在计算复杂性理论的研究中，一个针对语言 $L$ 的概率可检验证明 (PCP) 系统提供了一种方法，用于验证一个证明，该证明表明给定字符串 $x$ 属于 $L$。在此类系统中，验证者是一个概率算法，它可以访问输入字符串 $x$ 和一个独立的证明字符串 $\\pi$。验证者的复杂性由其随机性复杂性 $r(n)$ 和查询复杂性 $q(n)$ 来衡量，其中 $n$ 是输入 $x$ 的大小。函数 $r(n)$ 表示验证者使用的随机比特数，而 $q(n)$ 表示它从证明字符串 $\\pi$ 中读取的比特数。所有拥有具此参数的 PCP 系统的语言所构成的类记为 $\\mathrm{PCP}(r(n), q(n))$。\n\n考虑为一类问题设计的特定类型的 PCP 验证者。对于任意大小为 $n$ 的输入，该验证者按如下方式运行：\n1.  它恰好使用 $\\log_2 n$ 个随机比特。这些比特用于从证明字符串中的 $n$ 个可能的起始位置集合中唯一且均匀地选择一个索引。\n2.  选择起始位置后，验证者从证明字符串中读取一个长度为 $c$ 的比特序列，其中 $c$ 是一个不依赖于 $n$ 的固定的正整数常量。\n3.  然后，验证者仅根据其读取的 $c$ 个比特做出接受或拒绝的决定。\n\n根据著名的 PCP 定理（该定理将此类证明系统与标准复杂性类联系起来），可以由具有上述行为的验证者判定的所有语言的类，等价于以下著名复杂性类中的哪一个？\n\nA. P (多项式时间)\n\nB. NP (非确定性多项式时间)\n\nC. PSPACE (多项式空间)\n\nD. L (对数空间)\n\nE. EXP (指数时间)",
            "solution": "给定一个验证者，对于长度为 $n$ 的输入，它使用恰好 $r(n)=\\log_{2} n$ 个随机比特来从一个证明字符串中的 $n$ 个起始位置中均匀地选择一个，然后读取恰好 $q(n)=c$ 个证明比特（其中 $c$ 是一个不依赖于 $n$ 的固定正常数），并仅根据这 $c$ 个比特来决定接受或拒绝。根据定义，可由这类验证者判定的语言集合是 $\\mathrm{PCP}(\\log_{2} n, c)$。\n\n根据 PCP 定理，存在绝对常数 $c_{0},d_{0}0$ 使得\n$$\n\\mathrm{NP}=\\mathrm{PCP}(d_{0}\\log_{2} n, c_{0})。\n$$\n特别地，有 $\\mathrm{NP}\\subseteq \\mathrm{PCP}(O(\\log n),O(1))$，反之亦然，$\\mathrm{PCP}(O(\\log n),O(1))\\subseteq \\mathrm{NP}$。现在我们将给定的验证者与这些参数进行对齐，并论证两个方向的包含关系，以得出其与 $\\mathrm{NP}$ 相等的结论。\n\n首先，观察到验证者可以使用的可能随机字符串的数量是\n$$\nR(n)=2^{r(n)}=2^{\\log_{2} n}=n。\n$$\n因此，恰好有 $n$ 种随机选择。根据 $\\mathrm{PCP}(r,q)$ 的定义，验证者是多项式时间的，并且它对每次随机选择仅查询 $q(n)=c$ 个比特。\n\n包含关系 $\\mathrm{PCP}(\\log_{2} n,c)\\subseteq \\mathrm{NP}$：设 $L\\in \\mathrm{PCP}(\\log_{2} n,c)$，其完备性为 $a$，可靠性为 $b$，其中 $a,b\\in[0,1]$ 是固定常数，且对于某个固定的 $\\delta0$ 有 $a-b\\geq \\delta$。对于长度为 $n$ 的输入 $x$，考虑一个非确定性算法，它猜测一个证明 $\\pi$，该证明包含所有可能被读取的证明位置。因为验证者从 $n$ 个起始位置中选择一个，并从每个位置读取 $c$ 个比特，所以对于所有随机字符串，被查询位置的总集合大小至多为 $n\\cdot c$。因此，$\\pi$ 中与验证相关的部分长度为 $O(n)$，并且可以在多项式时间内猜测出来。该算法然后确定性地在所有 $R(n)=n$ 个随机字符串上模拟验证者，并计算接受结果的数量。当且仅当这些模拟中至少有 $a\\cdot R(n)$ 次接受时，该算法接受。每次模拟使用的时间是 $n$ 的多项式，并且有 $n$ 次模拟，所以总的确定性验证时间是 $n$ 的多项式。因此，$L$ 的成员性问题可以由一个 $\\mathrm{NP}$ 机判定，从而建立了 $\\mathrm{PCP}(\\log_{2} n,c)\\subseteq \\mathrm{NP}$。\n\n包含关系 $\\mathrm{NP}\\subseteq \\mathrm{PCP}(\\log_{2} n,c')$ (对于某个常数 $c'$) 正是 PCP 定理的内容：$\\mathrm{NP}$ 中的每个语言都有一个使用 $O(\\log n)$ 个随机比特和 $O(1)$ 次查询的多项式时间概率验证者。调整常数因子和对数的底只会使 $d_{0}$ 和 $c_{0}$ 改变常数倍，因此给定的恰好使用 $\\log_{2} n$ 个随机比特和常数次查询的形式是被该定理覆盖的。\n\n结合两个方向的包含关系，由所描述的验证者可判定的语言类恰好是 $\\mathrm{NP}$。在所提供的选项中，这对应于 B。",
            "answer": "$$\\boxed{B}$$"
        }
    ]
}