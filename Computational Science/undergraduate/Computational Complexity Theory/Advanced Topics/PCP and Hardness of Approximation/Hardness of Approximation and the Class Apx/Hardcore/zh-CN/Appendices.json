{
    "hands_on_practices": [
        {
            "introduction": "近似算法的性能通常用其近似比来衡量，而一个问题是否属于 APX 类别，则取决于是否存在一个近似比有常数上界的多项式时间算法。这个练习将帮助你深入理解 APX 类的定义，通过辨析依赖于输入规模 $n$ 的不同性能保证，来确定哪些保证足以证明一个问题是常数因子可近似的。",
            "id": "1426604",
            "problem": "在计算复杂性理论中，许多优化问题是“非确定性多项式时间”（NP）难的，这意味着不大可能存在一个多项式时间算法来找到最优解。对于这类问题，我们通常寻求多项式时间近似算法。\n\n一个用于最小化问题的近似算法，它接受问题的一个实例 $I$，并返回一个代价为 $C(I)$ 的解。该实例的最优解的代价为 $OPT(I)$。该算法对于实例 $I$ 的近似比 $\\rho(I)$ 定义为 $\\rho(I) = \\frac{C(I)}{OPT(I)}$。按照惯例，$\\rho(I) \\ge 1$。\n\n复杂性类 APX（可近似的）包含了所有存在多项式时间近似算法，且其近似比受一个常数限制的 NP 难优化问题。也就是说，存在一个常数 $c > 1$，使得对于所有可能的问题实例 $I$，该算法的近似比 $\\rho(I)$ 满足 $\\rho(I) \\le c$。\n\n一个研究团队正在研究一个新的 NP 难最小化问题。他们开发了几种不同的多项式时间算法。对于每种算法，他们都设法确定了其近似比关于 $n$ 的一个上界函数，其中 $n$ 是表示输入实例大小的参数（例如，图中顶点的数量）。假设 $n \\ge 1$。\n\n以下发现的算法中（由其近似比上界所描述），哪些足以证明该问题属于 APX？选择所有适用的选项。\n\nA. 一个近似比上界为 $3 - \\exp(-n)$ 的算法。\n\nB. 一个近似比上界为 $\\frac{n}{1000} + 1$ 的算法。\n\nC. 一个近似比上界为 $2 + \\sin(n)$ 的算法。\n\nD. 一个近似比上界为 $1 + \\ln(\\ln(n))$ 的算法，其中 $n > e$。\n\nE. 一个近似比上界为 $1.0001$ 的算法。",
            "solution": "我们回顾一下定义：一个最小化问题属于 APX，如果存在一个多项式时间算法和一个常数 $c>1$，使得对于每个输入实例 $I$（等价地，对于每个输入规模参数 $n \\ge 1$），其近似比满足 $\\rho(I) \\le c$。给定一个其近似比上界为函数 $f(n)$ 的算法，只需证明存在一个常数 $c>1$ 使得对于所有 $n \\ge 1$ 都有 $f(n) \\le c$。\n\n分析每个选项：\n\nA. 上界 $f(n) = 3 - \\exp(-n)$。对于所有 $n \\ge 1$，我们有 $0  \\exp(-n) \\le \\exp(-1)$，因此 $3 - \\exp(-n)  3$。所以对于所有 $n \\ge 1$，$f(n) \\le 3$。选择 $c = 3$ 得到对于所有 $n$，$\\rho(I) \\le f(n) \\le 3 = c$，其中 $c>1$。这证明了该问题属于 APX。\n\nB. 上界 $f(n) = \\frac{n}{1000} + 1$。我们有 $\\lim_{n \\to \\infty} f(n) = \\infty$，所以对于任何有限常数 $c$，都存在一个 $n$ 使得 $f(n) > c$。因此，对于所有 $n$ 不存在一个统一的常数上界，这不能证明该问题属于 APX。\n\nC. 上界 $f(n) = 2 + \\sin(n)$。对于所有 $n$，$-1 \\le \\sin(n) \\le 1$，所以 $1 \\le f(n) \\le 3$。因此对于所有 $n$，$f(n) \\le 3$。选择 $c = 3$ 产生了一个常数上界 $c>1$，证明了该问题属于 APX。\n\nD. 上界 $f(n) = 1 + \\ln(\\ln(n))$，其中 $n > e$。由于 $\\lim_{n \\to \\infty} \\ln(\\ln(n)) = \\infty$，$f(n)$ 是无上界的。因此，没有有限常数 $c$ 能作为所有足够大的 $n$ 的 $f(n)$ 的上界，这不能证明该问题属于 APX。\n\nE. 上界 $f(n) = 1.0001$。这是一个不依赖于 $n$ 的常数上界，所以选择 $c = 1.0001$ 得到对于所有 $n$，$\\rho(I) \\le c$，其中 $c>1$，证明了该问题属于 APX。\n\n因此，充分的选项是 A、C 和 E。",
            "answer": "$$\\boxed{ACE}$$"
        },
        {
            "introduction": "理论分析是评估近似算法有效性的核心。本练习将引导你分析一个针对顶点覆盖（Vertex Cover）问题的经典贪心算法，这是近似算法领域一个教科书式的例子。通过推导其近似比的紧密界，你将掌握一种将算法解与最优解相关联的基本分析技巧。",
            "id": "1426648",
            "problem": "在计算复杂性理论中，许多优化问题是NP-hard的，这意味着我们不期望找到一个能在多项式时间内最优地解决这些问题的算法。对于这类问题，我们通常寻求多项式时间的近似算法，以保证其解在最优解的一定因子范围内。\n\n考虑**最小顶点覆盖** (MINIMUM VERTEX COVER) 问题：给定一个无向图 $G = (V, E)$，其中 $V$ 是顶点集，$E$ 是边集，找到一个大小尽可能小的顶点子集 $V' \\subseteq V$，使得 $E$ 中的每条边至少有一个端点在 $V'$ 中。\n\n我们来分析一个解决此问题的简单贪心算法，我们称之为**EDGE-PICKER**：\n1. 初始化顶点覆盖 $C$ 为一个空集。\n2. 当图中仍至少含有一条边时：\n   a. 从图的边集 $E$ 中任选一条边 $(u, v)$。\n   b. 将两个顶点 $u$ 和 $v$ 都加入到覆盖 $C$ 中。\n   c. 从图中移除边 $(u,v)$ 以及所有与 $u$ 或 $v$ 相关联的其他边。\n3. 返回集合 $C$ 作为近似的顶点覆盖。\n\n对于一个最小化问题，算法的**近似比**是指，在所有可能的输入上，该算法产生的解的大小与最优解的大小的比值的最大可能值。一个**紧致**的近似比是指，存在一个输入实例，使得算法的性能恰好达到该比值。\n\n对于最小顶点覆盖问题，EDGE-PICKER算法的紧致近似比是多少？\n\nA. $1.5$\n\nB. $2$\n\nC. $\\log_2(|V|)$，其中 $|V|$ 是图中顶点的数量。\n\nD. $|V|^{1/2}$\n\nE. 该比值不受任何关于 $|V|$ 的函数的限制。",
            "solution": "设 $G=(V,E)$ 为输入图。运行 EDGE-PICKER 算法，并设 $C$ 为返回的集合。设 $M$ 为在执行过程中步骤 2a 所选择的边的集合。\n\n首先，$M$ 是一个匹配（matching）。确实，当一条边 $(u,v)$ 被选中时，步骤 2c 会移除所有与 $u$ 或 $v$ 相关联的边。因此，之后选择的任何边都不能与 $(u,v)$ 共享端点，所以被选中的边是两两不相交的。\n\n此外，$M$ 是图 $G$ 中的一个极大匹配（maximal matching）。算法终止时，残留图中没有任何边；因此，在 $G$ 中不存在两个端点都在 $M$ 的端点集之外的边，否则这样的边将仍然存在且可被选择。因此，在不违反匹配属性的情况下，没有额外的边可以被加入到 $M$ 中。\n\n因为算法将 $M$ 中每条边的两个端点都加入到 $C$ 中，并且 $M$ 中的边是不相交的，所以没有端点被重复添加。因此\n$$\n|C|=2|M|.\n$$\n设 $C^{*}$ 是一个最优顶点覆盖。$M$ 中的每条边都必须被 $C^{*}$ 覆盖，并且由于 $M$ 中的边是不相交的，覆盖它们需要每条边至少有一个不同的端点。因此\n$$\n|C^{*}| \\ge |M|.\n$$\n结合这两个不等式可得\n$$\n|C| = 2|M| \\le 2|C^{*}|,\n$$\n所以近似比至多为 $2$。\n\n为了证明其紧致性，考虑一个星形图，它有一个中心点和 $k$ 个叶节点。一个最优顶点覆盖的大小为 $1$（即中心点）。EDGE-PICKER 算法选择某条边 $(\\text{中心点}, \\text{叶节点})$，将其两个端点都加入覆盖，并移除所有边，返回的 $|C|=2$。因此，比值 $|C|/|C^{*}|=2$。作为另一个例子，在一个由 $k$ 条不相交的边组成的图上，最优解 $|C^{*}|=k$，而 EDGE-PICKER 返回 $2k$，同样得到比值为 $2$。\n\n因此，EDGE-PICKER 算法的紧致近似比是 $2$，对应选项 B。",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "并非所有贪心策略都能为 NP-hard 问题提供良好的性能保证。这个练习通过分析一个针对最大独立集（Maximum Independent Set）问题的简单贪心启发式算法，展示了其局限性。你将学习如何通过构造一个特定的图族作为“最坏情况”实例，来证明该算法的近似比可以任意差，从而理解识别算法性能瓶颈的重要性。",
            "id": "1426630",
            "problem": "在计算复杂性理论中，许多优化问题是 NP-难的，这意味着没有已知的算法可以在多项式时间内找到最优解。对于这类问题，我们通常依赖于多项式时间启发式算法，旨在找到一个“足够好”但不必是最优的解。图上最基本的 NP-难问题之一是最大独立集（Maximum Independent Set, MIS）问题。独立集是图中顶点的一个子集，其中任意两个顶点都不相邻。MIS 问题旨在找到一个可能的最大规模的独立集。\n\n考虑一个针对此问题的简单启发式算法，我们称之为**贪婪选择启发式算法**。该启发式算法工作如下：\n1. 初始化独立集 $S$ 为空集。\n2. 当图中仍有顶点时：\n   a. 从图中任选一个顶点 $v$。\n   b. 将 $v$ 添加到集合 $S$ 中。\n   c. 从图中移除 $v$ 及其所有邻居。\n3. 返回集合 $S$。\n\n该启发式算法找到的解的质量在很大程度上取决于每一步所做的“任意”选择。为了分析其局限性，考虑一个由整数 $k \\ge 2$ 参数化的特定图族 $G_k$。图 $G_k$ 的构造如下：\n- 顶点集由两个不相交的顶点集组成：一个集合 $C = \\{c_1, c_2, \\dots, c_k\\}$ 和一个集合 $U = \\{u_1, u_2, \\dots, u_k\\}$。\n- 边集由两条规则定义：\n    1. $C$ 中的顶点形成一个团；也就是说，$C$ 中每一对不同的顶点 $(c_i, c_j)$ 都由一条边连接。\n    2. 对于每一对索引 $(i, j)$ 其中 $i \\neq j$，都有一条边连接顶点 $c_i \\in C$ 和顶点 $u_j \\in U$。\n\n你的任务是确定贪婪选择启发式算法在这个图族上的性能保证。具体来说，求出比率 $\\frac{\\alpha(G_k)}{|S_{\\text{worst}}|}$，其中 $\\alpha(G_k)$ 是 $G_k$ 中真正的最大独立集的大小，而 $|S_{\\text{worst}}|$ 是贪婪选择启发式算法通过一系列特别“不幸”的选择所能产生的最小可能独立集的大小。\n\n将你的答案表示为 $k$ 的函数。",
            "solution": "我们首先重述 $G_{k}$ 的结构。顶点集为 $V=C \\cup U$，其中 $C=\\{c_{1},\\dots,c_{k}\\}$ 和 $U=\\{u_{1},\\dots,u_{k}\\}$ 不相交。边为：\n1) $C$ 导出一个团，因此每一对不同的 $c_{i},c_{j}$ 都相邻。\n2) 对于 $i \\neq j$，$c_{i}$ 与 $u_{j}$ 相邻。因此，$c_{i}$ 与 $u_{i}$ 不相邻，且 $U$ 内部没有边。\n\n确定 $\\alpha(G_{k})$。由于 $U$ 的顶点之间没有边，集合 $U$ 是一个大小为 $k$ 的独立集，因此\n$$\n\\alpha(G_{k}) \\geq k.\n$$\n设 $S$ 为任意独立集，并记 $a=|S \\cap C|$ 和 $b=|S \\cap U|$。因为 $C$ 是一个团，我们有 $a \\leq 1$。如果 $a=0$，则 $|S|=b \\leq k$。如果 $a=1$，比如说 $c_{i} \\in S$，那么对于每个 $j \\neq i$，$c_{i}$ 都与 $u_{j}$ 相邻，所以对于所有 $j \\neq i$ 都有 $u_{j} \\notin S$，并且只有 $u_{i}$ 可能被包含在 $U$ 中。因此 $b \\leq 1$ 且 $|S|=a+b \\leq 2$。在所有情况下，都有\n$$\n|S| \\leq k.\n$$\n结合下界可得\n$$\n\\alpha(G_{k})=k.\n$$\n\n在最坏情况下分析贪婪选择启发式算法。该启发式算法迭代地选择一个顶点 $v$，将 $v$ 插入 $S$，然后删除 $v$ 及其所有邻居。\n\n考虑一个“不幸”的初始选择 $v=c_{i} \\in C$。$c_{i}$ 的邻居恰好是 $(C \\setminus \\{c_{i}\\}) \\cup (U \\setminus \\{u_{i}\\})$。在移除 $c_{i}$ 及其邻居后，唯一剩下的顶点是 $u_{i}$。下一步（也是最后一步）选择 $u_{i}$，过程终止。因此，在这次运行中，该启发式算法输出一个大小为\n$$\n|S|=2.\n$$\n的独立集。\n或者，如果第一个选择是 $v=u_{j} \\in U$，那么 $u_{j}$ 的邻居恰好是 $\\{c_{i}: i \\neq j\\}$。在移除 $u_{j}$ 和这些邻居后，剩下的顶点是 $c_{j}$ 和所有满足 $\\ell \\neq j$ 的 $u_{\\ell}$。一个对抗性的第二次选择 $v=c_{j}$ 会移除 $c_{j}$ 和所有剩下的满足 $\\ell \\neq j$ 的 $u_{\\ell}$，不留下任何顶点。然后，该启发式算法输出 $S=\\{u_{j},c_{j}\\}$，其大小为\n$$\n|S|=2.\n$$\n在任何一种情况下，启发式算法都不能在单次选择后终止，因为第一次选择至少留下一个不与其相邻的顶点（具体来说，如果 $v=c_{i}$，则留下 $u_{i}$；如果 $v=u_{j}$，则至少留下 $c_{j}$）。因此，该启发式算法在 $G_{k}$ 上能产生的最小可能独立集是\n$$\n|S_{\\text{worst}}|=2.\n$$\n\n因此，所要求的性能比为\n$$\n\\frac{\\alpha(G_{k})}{|S_{\\text{worst}}|}=\\frac{k}{2}.\n$$",
            "answer": "$$\\boxed{\\frac{k}{2}}$$"
        }
    ]
}