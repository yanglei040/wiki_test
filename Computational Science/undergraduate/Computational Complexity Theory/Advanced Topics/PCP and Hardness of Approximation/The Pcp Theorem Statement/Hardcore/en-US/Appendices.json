{
    "hands_on_practices": [
        {
            "introduction": "To grasp the powerful formalism of Probabilistically Checkable Proofs, it's often best to start with a familiar concept. This first practice invites you to characterize the complexity class P, which represents problems solvable in polynomial time, using the PCP framework. By determining the minimum randomness ($r(n)$) and query complexity ($q(n)$) needed to describe P, you will build a foundational intuition for what these parameters mean in the simplest possible computational setting .",
            "id": "1461213",
            "problem": "In computational complexity theory, a language $L$ is said to be in the class PCP($r(n), q(n)$) if there exists a polynomial-time randomized algorithm, called a verifier, which interacts with a proof string $\\pi$ for an input $x$ of size $n = |x|$. The verifier must adhere to the following constraints and properties:\n- It uses at most $r(n)$ random bits.\n- It queries at most $q(n)$ bits from the proof string $\\pi$.\n- **Completeness:** If $x \\in L$, there exists a proof $\\pi$ such that the verifier accepts with probability 1.\n- **Soundness:** If $x \\notin L$, for any proof string $\\pi'$, the verifier accepts with probability at most 1/2.\n\nSeparately, the complexity class P is defined as the set of all languages decidable by a deterministic algorithm in polynomial time.\n\nYour task is to precisely characterize the class P using this Probabilistically Checkable Proof (PCP) formalism. Determine the smallest non-negative integer constants, $c_r$ and $c_q$, for which the constant functions $r(n) = c_r$ and $q(n) = c_q$ satisfy the equality $P = \\mathrm{PCP}(r(n), q(n))$. Provide the values of the constants $c_r$ and $c_q$.",
            "solution": "We claim that $\\mathrm{P}=\\mathrm{PCP}(0,0)$, and that these constants are the smallest non-negative integers satisfying the requirement.\n\nFirst, show $P \\subseteq \\mathrm{PCP}(0,0)$. Let $L \\in P$. Then there exists a deterministic polynomial-time algorithm $A$ that decides $L$. Define a verifier $V$ that, on input $x$, uses $r(n)=0$ random bits and makes $q(n)=0$ queries to the proof (i.e., it ignores the proof entirely), and simply runs $A(x)$ and outputs its decision. Completeness: if $x \\in L$, there exists a proof $\\pi$ (indeed, any $\\pi$) such that $V$ accepts with probability $1$, since $V$ is deterministic and equals $A$. Soundness: if $x \\notin L$, for any proof $\\pi'$, $V$ accepts with probability $0 \\le \\frac{1}{2}$, again because $V$ is deterministic and equals $A$. Hence $L \\in \\mathrm{PCP}(0,0)$, proving $P \\subseteq \\mathrm{PCP}(0,0)$.\n\nSecond, show $\\mathrm{PCP}(0,0) \\subseteq P$. Suppose $L \\in \\mathrm{PCP}(0,0)$. Then there exists a polynomial-time verifier $V$ that uses $0$ random bits and makes $0$ queries to the proof. Therefore, $V$ is a deterministic polynomial-time algorithm whose output depends only on $x$. Define $A(x)$ to be $V(x,\\pi_{0})$ for any fixed $\\pi_{0}$; because $V$ never reads the proof, this is well-defined and computable in polynomial time. By completeness, if $x \\in L$, there exists $\\pi$ such that $V$ accepts, which implies $A(x)=1$. By soundness, if $x \\notin L$, then for any $\\pi'$, the acceptance probability is at most $\\frac{1}{2}$; since $V$ is deterministic, this probability is either $0$ or $1$, hence it must be $0$, so $A(x)=0$. Therefore, $A$ decides $L$ in polynomial time, and $L \\in P$. Hence $\\mathrm{PCP}(0,0) \\subseteq P$.\n\nCombining both inclusions yields $\\mathrm{P}=\\mathrm{PCP}(0,0)$. Since $c_{r}$ and $c_{q}$ are required to be non-negative integers, the smallest such constants achieving this equality are $c_{r}=0$ and $c_{q}=0$.",
            "answer": "$$\\boxed{\\begin{pmatrix}0  0\\end{pmatrix}}$$"
        },
        {
            "introduction": "The celebrated PCP theorem states that $\\mathrm{NP} = \\mathrm{PCP}[O(\\log n), O(1)]$, demonstrating a profound link between nondeterminism, randomness, and proof checking. This thought experiment asks you to explore what would happen in a hypothetical world where NP could be characterized without randomness, as $\\mathrm{NP} = \\mathrm{PCP}[0, O(1)]$. Analyzing this scenario  reveals the critical role that randomness plays, as its absence dramatically alters the power of the verifier and has major implications for the P versus NP problem.",
            "id": "1461194",
            "problem": "In computational complexity theory, the class **P** consists of all decision problems solvable by a deterministic Turing machine in polynomial time. The class **NP** consists of all decision problems for which a \"yes\" instance has a proof that can be verified in polynomial time by a deterministic Turing machine.\n\nThe **PCP theorem** provides an alternative characterization of NP using Probabilistically Checkable Proofs (PCP). A language $L$ is in the class $\\mathrm{PCP}[r(n), q(n)]$ if there exists a probabilistic polynomial-time verifier $V$ that, for any given input string $x$ of length $n$, has the following properties when given access to a proof string $\\pi$:\n1.  The verifier $V$ uses at most $O(r(n))$ random bits.\n2.  The verifier $V$ reads at most $O(q(n))$ bits from the proof $\\pi$.\n3.  **Completeness**: If $x \\in L$, there exists a proof $\\pi$ such that $V$ accepts with probability 1.\n4.  **Soundness**: If $x \\notin L$, for any proof $\\pi$, $V$ accepts with probability at most $1/2$.\n\nNow, consider a hypothetical scenario where a major breakthrough in complexity theory establishes the following equality:\n$$ \\mathrm{NP} = \\mathrm{PCP}[0, O(1)] $$\nThis means that for any language in NP, there exists a verifier that uses zero random bits ($r(n)=0$) and queries only a constant number of bits from the proof ($q(n)=O(1)$).\n\nWhat is the direct and most significant consequence of this hypothetical result for the relationship between the complexity classes P and NP?\n\nA. $P = NP$\n\nB. $P \\neq NP$\n\nC. The result is consistent with either $P = NP$ or $P \\neq NP$, and does not resolve the question.\n\nD. $\\mathrm{NP} = \\mathrm{co-NP}$, but the P versus NP question remains open.\n\nE. Such a result is logically impossible and contradicts the definition of NP.",
            "solution": "We are given the hypothetical statement that $\\mathrm{NP}=\\mathrm{PCP}[0,O(1)]$. By definition of $\\mathrm{PCP}[r(n),q(n)]$, for a language $L$ in this class there is a probabilistic polynomial-time verifier $V$ which uses at most $O(r(n))$ random bits and reads at most $O(q(n))$ bits of a proof string $\\pi$, with completeness $1$ and soundness at most $\\frac{1}{2}$.\n\nStep 1 (Determinism from zero randomness). Since $r(n)=0$, the verifier $V$ uses no random bits, hence is deterministic on input $x$ and oracle access to $\\pi$. Therefore, the acceptance probability (over internal randomness) is either $0$ or $1$ for any fixed $(x,\\pi)$. The soundness condition that if $x\\notin L$ then, for all $\\pi$, $V$ accepts with probability at most $\\frac{1}{2}$ thus implies that if $x\\notin L$, for all $\\pi$, $V$ rejects deterministically (acceptance probability $0$). The completeness condition implies that if $x\\in L$, there exists some $\\pi$ such that $V$ accepts deterministically (acceptance probability $1$).\n\nStep 2 (Constant query bound). Since $q(n)=O(1)$, there exists a constant $K$ (independent of $n$) such that on any input $x$ of length $n$, $V$ makes at most $K$ queries to $\\pi$. These query locations may be adaptively chosen based on $x$ and the answers to previous queries, but the total number of queried bits never exceeds $K$.\n\nStep 3 (Reduction to finitely many deterministic checks). For fixed $x$, the deterministic verifier $V$ induces a decision based only on:\n- the input $x$, and\n- the sequence of at most $K$ answers it receives to its (adaptively chosen) queries.\n\nThus, for each $x$, there exists a set of at most $2^{K}$ possible answer transcripts $a \\in \\{0,1\\}^t$ with $t \\le K$ that could be observed along some adaptive query path. We can equivalently consider all $a \\in \\{0,1\\}^K$ by padding shorter transcripts. Define a deterministic polynomial-time simulation $D(x,a)$ that, given $x$ and a candidate answer vector $a \\in \\{0,1\\}^K$, simulates $V$’s computation on $x$ by:\n- computing each next query location as $V$ would, based on $x$ and the answers provided so far,\n- feeding the next bit from $a$ as the answer,\n- stopping after at most $K$ queries and outputting $V$’s final decision.\n\nThis simulation runs in time polynomial in $|x|$, since $V$ runs in polynomial time and performs at most $K$ steps of oracle interaction, with $K$ constant.\n\nStep 4 (Decision procedure in polynomial time). Consider the nondeterministic condition:\n- If $x\\in L$, completeness guarantees that there exists some proof $\\pi$ making $V$ accept; equivalently, there exists some transcript $a \\in \\{0,1\\}^K$ consistent with $\\pi$ that makes $D(x,a)$ accept. Therefore, there exists $a$ such that $D(x,a)$ accepts.\n- If $x\\notin L$, soundness and determinism imply that for every $\\pi$ (and hence for every possible transcript $a$), $V$ rejects; thus $D(x,a)$ rejects for all $a \\in \\{0,1\\}^K$.\n\nHence, membership in $L$ is equivalent to the truth of the predicate $\\exists a \\in \\{0,1\\}^K: D(x,a)=\\text{accept}$. Since $K$ is a constant, we can decide this by deterministically enumerating all $2^{K}$ assignments $a$ and evaluating $D(x,a)$ for each. The total running time is at most $2^{K}\\cdot \\text{poly}(|x|)$, which is $\\text{poly}(|x|)$ because $2^{K}$ is a constant factor.\n\nTherefore, every language in $\\mathrm{PCP}[0,O(1)]$ is in $\\mathrm{P}$. Given the hypothesis $\\mathrm{NP}=\\mathrm{PCP}[0,O(1)]$, we obtain $\\mathrm{NP}\\subseteq \\mathrm{P}$. Since $P \\subseteq \\mathrm{NP}$ holds trivially, it follows that $\\mathrm{P}=\\mathrm{NP}$.\n\nThus, the direct and most significant consequence of the hypothetical equality $\\mathrm{NP}=\\mathrm{PCP}[0,O(1)]$ is that $\\mathrm{P}=\\mathrm{NP}$.",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "The \"probabilistic\" nature of a PCP verifier implies a non-zero, though small, probability of error when evaluating a proof for a false statement. In practice, we need to be able to make this error arbitrarily small to be confident in the outcome. This exercise  guides you through the essential technique of soundness amplification, showing how to reduce the error probability by repeating the verification procedure, a method fundamental to the application of randomized algorithms and the PCP theorem itself.",
            "id": "1461240",
            "problem": "In the field of theoretical computer science, a Probabilistically Checkable Proof (PCP) system allows a randomized verifier to check a mathematical proof by querying only a small number of bits from it. Consider a specific PCP verifier designed for a particular decision problem. This verifier has the following properties:\n\n1.  **Completeness:** For any true statement, there exists a valid proof such that the verifier always accepts.\n2.  **Soundness:** For any false statement, regardless of the purported proof provided, the verifier will incorrectly accept with a probability of at most $s$, where $s$ is a constant satisfying $0  s  1$.\n\nTo increase confidence and reduce the chance of error, the verifier is run multiple times independently on the same (purportedly false) statement and its alleged proof. A new, independent set of random bits is used for each run. The overall protocol declares the proof \"accepted\" only if *every single run* of the verifier accepts.\n\nYour task is to determine the minimum number of independent trials, denoted by $k$, that must be performed to guarantee that the overall probability of incorrectly accepting a false statement is at most $\\epsilon$, where $\\epsilon$ is a desired error tolerance satisfying $0  \\epsilon  s$.\n\nFind a closed-form expression for the minimum integer value of $k$ in terms of $s$ and $\\epsilon$.",
            "solution": "Let $P(\\text{accept})$ be the probability that a single run of the verifier incorrectly accepts a proof for a false statement. According to the problem's definition of soundness, we have $P(\\text{accept}) \\le s$. To find the minimum number of trials required, we must consider the worst-case scenario, which is when the probability of a single incorrect acceptance is exactly $s$. So, we take $P(\\text{accept}) = s$.\n\nThe protocol involves running the verifier $k$ times independently. The overall protocol accepts a false statement only if all $k$ trials result in an acceptance. Let $A_i$ be the event that the $i$-th trial incorrectly accepts. The event of an overall incorrect acceptance, $A_{\\text{overall}}$, is the intersection of these individual events:\n$$A_{\\text{overall}} = A_1 \\cap A_2 \\cap \\dots \\cap A_k$$\n\nSince each trial is independent, the probability of the intersection of these events is the product of their individual probabilities:\n$$P(A_{\\text{overall}}) = P(A_1) \\times P(A_2) \\times \\dots \\times P(A_k)$$\nIn our worst-case analysis, $P(A_i) = s$ for all $i=1, \\dots, k$. Therefore, the overall probability of incorrectly accepting is:\n$$P(A_{\\text{overall}}) = s \\times s \\times \\dots \\times s \\quad (k \\text{ times}) = s^k$$\n\nThe problem requires that this overall probability of error be at most $\\epsilon$. This gives us the inequality:\n$$s^k \\le \\epsilon$$\n\nTo solve for $k$, we can apply the natural logarithm to both sides of the inequality. Since both $s$ and $\\epsilon$ are positive, the logarithm is well-defined.\n$$\\ln(s^k) \\le \\ln(\\epsilon)$$\nUsing the power rule for logarithms, $\\ln(a^b) = b \\ln(a)$, we get:\n$$k \\ln(s) \\le \\ln(\\epsilon)$$\n\nNow, we need to isolate $k$. We are given that $0  s  1$, which implies that $\\ln(s)$ is a negative number. When we divide an inequality by a negative number, we must reverse the direction of the inequality sign.\n$$k \\ge \\frac{\\ln(\\epsilon)}{\\ln(s)}$$\nThis inequality gives a lower bound for $k$. Since the number of trials $k$ must be an integer, we need to find the smallest integer that satisfies this condition. The smallest integer greater than or equal to a given real number is given by the ceiling function, $\\lceil \\cdot \\rceil$.\n\nTherefore, the minimum integer number of trials required is:\n$$k = \\left\\lceil \\frac{\\ln(\\epsilon)}{\\ln(s)} \\right\\rceil$$\nThis expression can also be written using the change of base formula for logarithms, $\\log_b(a) = \\frac{\\ln(a)}{\\ln(b)}$, as $k = \\lceil \\log_s(\\epsilon) \\rceil$.",
            "answer": "$$\\boxed{\\left\\lceil \\frac{\\ln(\\epsilon)}{\\ln(s)} \\right\\rceil}$$"
        }
    ]
}