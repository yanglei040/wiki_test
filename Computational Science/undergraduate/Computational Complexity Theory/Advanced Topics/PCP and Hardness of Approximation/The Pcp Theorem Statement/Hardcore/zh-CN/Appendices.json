{
    "hands_on_practices": [
        {
            "introduction": "为了理解像 PCP 这样复杂的新概念，一个有效的方法是将其应用于我们已经熟悉的概念上。这个练习将引导我们使用 PCP 的形式化语言来描述众所周知的复杂性类 P 。通过确定 P 所需的随机性复杂度和查询复杂度，我们将为理解更复杂的 NP 的 PCP 特征打下坚实的基础。",
            "id": "1461213",
            "problem": "在计算复杂性理论中，一个语言 $L$ 属于类 PCP($r(n), q(n)$) 是指：存在一个多项式时间随机算法（称为验证者），该算法接收大小为 $n = |x|$ 的输入 $x$，并与一个证明字符串 $\\pi$ 进行交互。该验证者必须遵守以下约束和性质：\n- 它最多使用 $r(n)$ 个随机比特。\n- 它最多查询证明字符串 $\\pi$ 中的 $q(n)$ 个比特。\n- **完备性：**如果 $x \\in L$，存在一个证明 $\\pi$，使得验证者以概率 1 接受。\n- **可靠性：**如果 $x \\notin L$，对于任何证明字符串 $\\pi'$，验证者接受的概率最多为 1/2。\n\n另外，复杂性类 P 被定义为所有可在多项式时间内由确定性算法判定的语言的集合。\n\n你的任务是使用此概率可检查证明 (PCP) 的形式体系来精确地刻画类 P。确定最小的非负整数常数 $c_r$ 和 $c_q$，使得常数函数 $r(n) = c_r$ 和 $q(n) = c_q$ 满足等式 P = PCP($r(n), q(n)$)。给出常数 $c_r$ 和 $c_q$ 的值。",
            "solution": "我们断言 $P=\\mathrm{PCP}(0,0)$，并且这些常数是满足要求的最小非负整数。\n\n首先，证明 $P \\subseteq \\mathrm{PCP}(0,0)$。设 $L \\in P$。那么存在一个判定 $L$ 的确定性多项式时间算法 $A$。定义一个验证者 $V$，它在输入 $x$ 上，使用 $r(n)=0$ 个随机比特并对证明进行 $q(n)=0$ 次查询（即，它完全忽略证明），然后仅运行 $A(x)$ 并输出其判定结果。完备性：如果 $x \\in L$，存在一个证明 $\\pi$（实际上，是任何 $\\pi$），使得 $V$ 以概率 $1$ 接受，因为 $V$ 是确定性的且等同于 $A$。可靠性：如果 $x \\notin L$，对于任何证明 $\\pi'$，$V$ 接受的概率为 $0$，这小于等于 $\\frac{1}{2}$，同样是因为 $V$ 是确定性的且等同于 $A$。因此 $L \\in \\mathrm{PCP}(0,0)$，这证明了 $P \\subseteq \\mathrm{PCP}(0,0)$。\n\n其次，证明 $\\mathrm{PCP}(0,0) \\subseteq P$。假设 $L \\in \\mathrm{PCP}(0,0)$。那么存在一个多项式时间的验证者 $V$，它使用 $0$ 个随机比特并对证明进行 $0$ 次查询。因此，$V$ 是一个确定性多项式时间算法，其输出仅取决于 $x$。对于任何固定的 $\\pi_0$，定义 $A(x)$ 为 $V(x, \\pi_0)$；因为 $V$ 从不读取证明，所以这是良定义的且可在多项式时间内计算。根据完备性，如果 $x \\in L$，存在 $\\pi$ 使得 $V$ 接受，这意味着 $A(x)=1$。根据可靠性，如果 $x \\notin L$，那么对于任何 $\\pi'$，接受概率最多为 $\\frac{1}{2}$；由于 $V$ 是确定性的，这个概率要么是 $0$ 要么是 $1$，因此它必须是 $0$，所以 $A(x)=0$。因此，$A$ 在多项式时间内判定 $L$，并且 $L \\in P$。因此 $\\mathrm{PCP}(0,0) \\subseteq P$。\n\n结合两个包含关系可得 $P=\\mathrm{PCP}(0,0)$。由于 $c_{r}$ 和 $c_{q}$ 被要求为非负整数，实现此等式的最小常数是 $c_{r}=0$ 和 $c_{q}=0$。",
            "answer": "$$\\boxed{\\begin{pmatrix}0  0\\end{pmatrix}}$$"
        },
        {
            "introduction": "在我们了解了 P 的 PCP 特征之后，让我们通过一个思想实验来加深对 PCP 定理中各个参数的理解。这个练习探讨了一个假设情景：如果 NP 中的问题可以被一个不使用随机性、仅做常数次查询的验证者所验证，将会产生什么后果 ？通过分析这个假设，我们可以揭示随机性在真实 PCP 定理中的关键作用，并强调验证者能力与 P 与 NP 问题之间的深刻联系。",
            "id": "1461194",
            "problem": "在计算复杂性理论中，**P** 类包含所有可以由确定性图灵机在多项式时间内解决的判定问题。**NP** 类包含所有其“是”实例的证明可以由确定性图灵机在多项式时间内验证的判定问题。\n\n**PCP 定理**使用概率可检验证明 (PCP) 提供了 NP 的另一种刻画。如果存在一个概率多项式时间验证者 $V$，对于任何长度为 $n$ 的给定输入串 $x$，当它能访问一个证明串 $\\pi$ 时，具有以下性质，那么语言 $L$ 就属于 $\\text{PCP}[r(n), q(n)]$ 类：\n1.  验证者 $V$ 最多使用 $O(r(n))$ 个随机位。\n2.  验证者 $V$ 最多从证明 $\\pi$ 中读取 $O(q(n))$ 位。\n3.  **完备性**：如果 $x \\in L$，则存在一个证明 $\\pi$ 使得 $V$ 以概率 1 接受。\n4.  **可靠性**：如果 $x \\notin L$，对于任何证明 $\\pi$，$V$ 接受的概率最多为 $1/2$。\n\n现在，考虑一个假设情景，其中复杂性理论的一项重大突破确立了以下等式：\n$$ \\text{NP} = \\text{PCP}[0, O(1)] $$\n这意味着对于 NP 中的任何语言，都存在一个使用零个随机位（$r(n)=0$）并且只从证明中查询常数个位（$q(n)=O(1)$）的验证者。\n\n对于复杂性类 P 和 NP 之间的关系，这个假设性结果最直接和最重大的推论是什么？\n\nA. P = NP\n\nB. P $\\neq$ NP\n\nC. 该结果与 P = NP 或 P $\\neq$ NP 均相容，并不能解决这个问题。\n\nD. NP = co-NP，但 P 与 NP 的问题仍然悬而未决。\n\nE. 这样的结果在逻辑上是不可能的，并且与 NP 的定义相矛盾。",
            "solution": "我们得到假设性陈述 $\\text{NP}=\\text{PCP}[0,O(1)]$。根据 $\\text{PCP}[r(n),q(n)]$ 的定义，对于此类中的语言 $L$，存在一个概率多项式时间验证者 $V$，它最多使用 $O(r(n))$ 个随机位，并从证明串 $\\pi$ 中最多读取 $O(q(n))$ 位，其完备性为 $1$，可靠性最多为 $\\frac{1}{2}$。\n\n步骤 1 (从零随机性到确定性)。由于 $r(n)=0$，验证者 $V$ 不使用任何随机位，因此在输入 $x$ 和对 $\\pi$ 的预言机访问上是确定性的。因此，对于任何固定的 $(x,\\pi)$，接受概率（相对于内部随机性）要么是 $0$，要么是 $1$。如果 $x\\notin L$，则对于所有 $\\pi$，$V$ 以最多 $\\frac{1}{2}$ 的概率接受的可靠性条件，意味着如果 $x\\notin L$，对于所有 $\\pi$，$V$ 都确定性地拒绝（接受概率为 $0$）。完备性条件意味着，如果 $x\\in L$，存在某个 $\\pi$ 使得 $V$ 确定性地接受（接受概率为 $1$）。\n\n步骤 2 (常数查询界限)。由于 $q(n)=O(1)$，存在一个常数 $K$（与 $n$ 无关），使得在任何长度为 $n$ 的输入 $x$ 上，$V$ 最多对 $\\pi$ 进行 $K$ 次查询。这些查询位置可以根据 $x$ 和先前查询的答案自适应地选择，但查询的总位数永远不会超过 $K$。\n\n步骤 3 (归约到有限多个确定性检查)。对于固定的 $x$，确定性验证者 $V$ 的判定仅基于：\n- 输入 $x$，以及\n- 它对其（自适应选择的）查询所收到的最多 $K$ 个答案的序列。\n\n因此，对于每个 $x$，存在一组最多 $2^{K}$ 种可能的答案记录 $a\\in\\{0,1\\}^{t}$（其中 $t\\leq K$），这些记录可能在某个自适应查询路径上被观察到。我们可以通过填充较短的记录来等效地考虑所有 $a\\in\\{0,1\\}^{K}$。定义一个确定性多项式时间模拟 $D(x,a)$，给定 $x$ 和一个候选答案向量 $a\\in\\{0,1\\}^{K}$，它通过以下方式模拟 $V$ 在 $x$ 上的计算：\n- 根据 $x$ 和目前为止提供的答案，计算 $V$ 会计算的下一个查询位置，\n- 将来自 $a$ 的下一个位作为答案提供，\n- 最多进行 $K$ 次查询后停止，并输出 $V$ 的最终决定。\n\n此模拟的运行时间是 $|x|$ 的多项式时间，因为 $V$ 在多项式时间内运行，并且最多执行 $K$ 步预言机交互，其中 $K$ 是常数。\n\n步骤 4 (多项式时间内的判定过程)。考虑非确定性条件：\n- 如果 $x\\in L$，完备性保证存在某个证明 $\\pi$ 使得 $V$ 接受；等价地，存在某个与 $\\pi$ 一致的记录 $a\\in\\{0,1\\}^{K}$ 使得 $D(x,a)$ 接受。因此，存在 $a$ 使得 $D(x,a)$ 接受。\n- 如果 $x\\notin L$，可靠性和确定性意味着对于每个 $\\pi$（因此对于每个可能的记录 $a$），$V$ 都会拒绝；因此对于所有 $a\\in\\{0,1\\}^{K}$，$D(x,a)$ 都会拒绝。\n\n因此，$L$ 中的成员资格等价于谓词 $\\exists a\\in\\{0,1\\}^{K}: D(x,a)=\\text{accept}$ 的真值。由于 $K$ 是一个常数，我们可以通过确定性地枚举所有 $2^{K}$ 个赋值 $a$ 并对每个 $a$ 求值 $D(x,a)$ 来判定这一点。总运行时间最多为 $2^{K}\\cdot \\text{poly}(|x|)$，由于 $2^{K}$ 是一个常数因子，所以这也是 $\\text{poly}(|x|)$。\n\n因此，$\\text{PCP}[0,O(1)]$ 中的每个语言都在 $\\text{P}$ 中。根据假设 $\\text{NP}=\\text{PCP}[0,O(1)]$，我们得出 $\\text{NP}\\subseteq \\text{P}$。由于 $\\text{P}\\subseteq \\text{NP}$ 是平凡成立的，因此可以推断出 $\\text{P}=\\text{NP}$。\n\n因此，假设等式 $\\text{NP}=\\text{PCP}[0,O(1)]$ 的最直接和最重大的推论是 $\\text{P}=\\text{NP}$。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "概率可检查证明的一个核心特征是其“可靠性错误”——即错误地接受一个不成立的陈述的概率。最后一个练习将我们的重点转移到这个概率性方面 。我们将探讨如何通过多次独立运行验证者来增强其可信度，这是一种在随机化算法中至关重要的“放大”技术，并计算将错误率降低到任意期望阈值以下所需的试验次数。",
            "id": "1461240",
            "problem": "在理论计算机科学领域，一个概率可检验证明（Probabilistically Checkable Proof, PCP）系统允许一个随机验证者通过仅查询证明中的少量比特来检验一个数学证明。考虑一个为特定决策问题设计的PCP验证者。该验证者具有以下性质：\n\n1.  **完备性 (Completeness)：** 对于任何为真的陈述，存在一个有效的证明，使得验证者总是接受。\n2.  **可靠性 (Soundness)：** 对于任何为假的陈述，无论提供的所谓证明是什么，验证者错误接受的概率至多为 $s$，其中 $s$ 是一个满足 $0  s  1$ 的常数。\n\n为了增加置信度并减少错误概率，验证者会对同一个（据称是假的）陈述及其所谓的证明独立运行多次。每次运行都使用一组新的、独立的随机比特。整体协议仅在*每一次运行*都接受时，才宣布证明“被接受”。\n\n你的任务是确定必须执行的独立试验的最小次数，记为 $k$，以保证错误地接受一个假陈述的总体概率至多为 $\\epsilon$，其中 $\\epsilon$ 是一个满足 $0  \\epsilon  s$ 的期望误差容限。\n\n请找到关于 $s$ 和 $\\epsilon$ 的 $k$ 的最小整数值的封闭形式表达式。",
            "solution": "设 $P(\\text{accept})$ 为单次运行的验证者错误地接受一个假陈述的证明的概率。根据问题对可靠性的定义，我们有 $P(\\text{accept}) \\le s$。为了找到所需的最小试验次数，我们必须考虑最坏情况，即单次错误接受的概率恰好为 $s$。因此，我们取 $P(\\text{accept}) = s$。\n\n该协议涉及独立运行验证者 $k$ 次。整体协议仅在所有 $k$ 次试验都接受时，才接受一个假陈述。设 $A_i$ 为第 $i$ 次试验错误接受的事件。整体错误接受的事件 $A_{\\text{overall}}$ 是这些单个事件的交集：\n$$A_{\\text{overall}} = A_1 \\cap A_2 \\cap \\dots \\cap A_k$$\n\n由于每次试验是独立的，这些事件交集的概率是它们各自概率的乘积：\n$$P(A_{\\text{overall}}) = P(A_1) \\times P(A_2) \\times \\dots \\times P(A_k)$$\n在我们的最坏情况分析中，对于所有的 $i=1, \\dots, k$，都有 $P(A_i) = s$。因此，整体错误接受的概率是：\n$$P(A_{\\text{overall}}) = s \\times s \\times \\dots \\times s \\quad (k \\text{ 次}) = s^k$$\n\n问题要求这个整体错误概率至多为 $\\epsilon$。这给了我们以下不等式：\n$$s^k \\le \\epsilon$$\n\n为了求解 $k$，我们可以对不等式两边取自然对数。由于 $s$ 和 $\\epsilon$ 都是正数，对数是良定义的。\n$$\\ln(s^k) \\le \\ln(\\epsilon)$$\n使用对数的幂法则 $\\ln(a^b) = b \\ln(a)$，我们得到：\n$$k \\ln(s) \\le \\ln(\\epsilon)$$\n\n现在，我们需要分离出 $k$。我们已知 $0  s  1$，这意味着 $\\ln(s)$ 是一个负数。当不等式两边同时除以一个负数时，我们必须反转不等号的方向。\n$$k \\ge \\frac{\\ln(\\epsilon)}{\\ln(s)}$$\n这个不等式给出了 $k$ 的一个下界。由于试验次数 $k$ 必须是一个整数，我们需要找到满足这个条件的最小整数。大于或等于一个给定实数的最小整数由向上取整函数（ceiling function）$\\lceil \\cdot \\rceil$ 给出。\n\n因此，所需的最小整数试验次数是：\n$$k = \\left\\lceil \\frac{\\ln(\\epsilon)}{\\ln(s)} \\right\\rceil$$\n这个表达式也可以使用对数的换底公式 $\\log_b(a) = \\frac{\\ln(a)}{\\ln(b)}$ 写成 $k = \\lceil \\log_s(\\epsilon) \\rceil$。",
            "answer": "$$\\boxed{\\left\\lceil \\frac{\\ln(\\epsilon)}{\\ln(s)} \\right\\rceil}$$"
        }
    ]
}