{
    "hands_on_practices": [
        {
            "introduction": "萨维奇定理的核心是一种巧妙的递归算法。为了真正掌握它，最好的方法就是亲手追踪其执行过程。这个练习将引导你分解一个简单的路径查找问题，通过观察算法如何进行递归调用，来具体感受其“分而治之”的策略 ()。",
            "id": "1446438",
            "problem": "萨维奇定理的构造性证明提供了一种在多项式空间内解决有向图 $G=(V, E)$ 的 st-连通性问题的算法。该算法递归地确定在一个 `start` 节点和一个 `end` 节点之间是否存在一条长度不超过某个最大值的路径。\n\n考虑一个有向图，其节点集为 $V = \\{1, 2, 3, 4, 5\\}$。边被排列成一条简单的直线：$E = \\{(1, 2), (2, 3), (3, 4), (4, 5)\\}$。\n\n我们使用一个递归函数 `REACH(start, end, max_len)`，如果可以从 `start` 通过一条长度至多为 `max_len` 的路径到达 `end`，则该函数返回 `True`，否则返回 `False`。该算法定义如下：\n\n1.  **基本情况**：如果 `max_len` 为 1，当 `start == end` 或边 `(start, end)` 存在于 $E$ 中时，函数返回 `True`。否则，返回 `False`。\n2.  **递归步骤**：如果 `max_len > 1`，函数会按数值递增的顺序（即从 1 到 5）遍历 $V$ 中的所有节点 `mid`。对于每个 `mid`，它进行两次递归调用：`REACH(start, mid, ceil(max_len / 2))` 和 `REACH(mid, end, ceil(max_len / 2))`。如果这两个调用都返回 `True`，函数会立即停止其迭代并返回 `True`。\n3.  **失败情况**：如果遍历所有可能的 `mid` 节点的循环完成，而两个递归调用从未同时返回 `True`，则函数返回 `False`。\n\n现在要求你追踪初始调用 `REACH(1, 5, 4)` 的执行过程。“一对顶层递归调用”指的是在 `REACH(1, 5, 4)` 的执行中，为给定的 `mid` 直接进行的一对调用，即 `(REACH(1, mid, ...), REACH(mid, 5, ...))`。\n\n下列哪个选项正确地列出了在算法找到成功路径且主调用 `REACH(1, 5, 4)` 返回 `True` 之前，所进行的顶层递归调用*对*的序列？\n\nA. `[(REACH(1,1,2), REACH(1,5,2)), (REACH(1,2,2), REACH(2,5,2)), (REACH(1,3,2), REACH(3,5,2))]`\n\nB. `[(REACH(1,3,2), REACH(3,5,2))]`\n\nC. `[(REACH(1,2,1), REACH(2,3,1)), (REACH(3,4,1), REACH(4,5,1))]`\n\nD. `[(REACH(1,1,2), REACH(1,5,2)), (REACH(1,2,2), REACH(2,5,2)), (REACH(1,3,2), REACH(3,5,2)), (REACH(1,4,2), REACH(4,5,2)), (REACH(1,5,2), REACH(5,5,2))]`\n\nE. `[(REACH(1,5,2), REACH(5,5,2)), (REACH(1,4,2), REACH(4,5,2)), (REACH(1,3,2), REACH(3,5,2))]`",
            "solution": "题目要求我们追踪函数 `REACH(start, end, max_len)` 在初始调用 `REACH(1, 5, 4)` 时所进行的一系列顶层递归调用。\n\n初始参数为 `start = 1`，`end = 5`，以及 `max_len = 4`。\n由于 `max_len = 4 > 1`，算法进入递归步骤。子问题的长度将是 `ceil(max_len / 2) = ceil(4 / 2) = 2`。算法将从 1 到 5 遍历 `mid`，并对每个 `mid` 测试调用对 `(REACH(1, mid, 2), REACH(mid, 5, 2))`。一旦找到一个 `mid` 使得两个调用都返回 `True`，过程就会停止。\n\n让我们追踪对 `mid` 的迭代过程：\n\n**1. `mid = 1`：**\n第一对顶层递归调用是 `(REACH(1, 1, 2), REACH(1, 5, 2))`。\n-   `REACH(1, 1, 2)`：为了评估这个调用，算法会为一条长度至多为 2 的路径寻找一个中点 `z`。我们尝试 `z=1`。这个子调用将测试 `REACH(1, 1, 1)` 和 `REACH(1, 1, 1)`。基本情况 `REACH(1,1,1)` 为 `True`，因为 `start == end`。由于两个子调用都为 `True`，`REACH(1, 1, 2)` 返回 `True`。\n-   `REACH(1, 5, 2)`：此调用检查从节点 1 到节点 5 是否存在长度至多为 2 的路径。通过检查图的边 $E = \\{(1, 2), (2, 3), (3, 4), (4, 5)\\}$，从 1 到 5 的最短路径是 $1 \\to 2 \\to 3 \\to 4 \\to 5$，长度为 4。不存在长度为 2 或更短的路径。因此，`REACH(1, 5, 2)` 将返回 `False`。\n由于这对调用中的一个返回了 `False`，算法继续到下一个 `mid`。到目前为止的调用对序列是 `[(REACH(1,1,2), REACH(1,5,2))]`。\n\n**2. `mid = 2`：**\n下一对调用是 `(REACH(1, 2, 2), REACH(2, 5, 2))`。\n-   `REACH(1, 2, 2)`：这会检查从节点 1 到 2 是否存在长度至多为 2 的路径。路径是 $1 \\to 2$，长度为 1。算法会找到这条路径。例如，使用子中点 `z=1`，它会检查 `REACH(1,1,1)` (True) 和 `REACH(1,2,1)` (True，因为边 (1,2) 存在)。因此，`REACH(1, 2, 2)` 返回 `True`。\n-   `REACH(2, 5, 2)`：这会检查从 2 到 5 是否存在长度至多为 2 的路径。最短路径是 $2 \\to 3 \\to 4 \\to 5$，长度为 3。不存在长度为 2 的路径。所以，`REACH(2, 5, 2)` 将返回 `False`。\n同样，这对调用并非都返回 `True`。算法继续执行。现在的调用对序列是 `[(REACH(1,1,2), REACH(1,5,2)), (REACH(1,2,2), REACH(2,5,2))]`。\n\n**3. `mid = 3`：**\n下一对调用是 `(REACH(1, 3, 2), REACH(3, 5, 2))`。\n-   `REACH(1, 3, 2)`：这会检查从 1 到 3 是否存在长度至多为 2 的路径。路径 $1 \\to 2 \\to 3$ 存在且长度为 2。算法会发现这一点。具体来说，当它尝试子中点 `z=2` 时，它会调用 `REACH(1, 2, 1)` (True，边存在) 和 `REACH(2, 3, 1)` (True，边存在)。由于两者都为真，`REACH(1, 3, 2)` 返回 `True`。\n-   `REACH(3, 5, 2)`：这会检查从 3 到 5 是否存在长度至多为 2 的路径。路径 $3 \\to 4 \\to 5$ 存在且长度为 2。算法会发现这一点。具体来说，当它尝试子中点 `z=4` 时，它会调用 `REACH(3, 4, 1)` (True，边存在) 和 `REACH(4, 5, 1)` (True，边存在)。由于两者都为真，`REACH(3, 5, 2)` 返回 `True`。\n\n由于 `REACH(1, 3, 2)` 和 `REACH(3, 5, 2)` 都返回 `True`，`REACH(1, 5, 4)` 主循环中的条件得到满足。函数立即停止迭代并返回 `True`。\n\n直到函数返回 `True` 为止所分析的顶层调用对的总序列是 `mid=1`、`mid=2` 和 `mid=3` 的调用对集合。这个序列是：`[(REACH(1,1,2), REACH(1,5,2)), (REACH(1,2,2), REACH(2,5,2)), (REACH(1,3,2), REACH(3,5,2))]`。\n\n这与选项 A 匹配。\n- 选项 B 不正确，因为它只列出了成功的调用对，忽略了 `mid=1` 和 `mid=2` 时的失败尝试。\n- 选项 C 不正确，因为它列出的是成功情况 (`mid=3`)下的第二层递归调用，而不是顶层调用。\n- 选项 D 不正确，因为它列出了所有可能的中点的调用对，但算法在 `mid=3` 第一次成功后就停止了。\n- 选项 E 不正确，因为算法是按递增顺序遍历 `mid`，而不是递减顺序。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "在理解了算法如何找到一条路径后，一个自然的问题是：它找到的是最好的路径吗？此练习旨在探讨萨维奇算法所发现路径的性质。通过辨析该算法是否保证找到最短路径，你将更深入地理解其搜索机制与传统最短路径算法（如广度优先搜索）的根本区别 ()。",
            "id": "1446443",
            "problem": "在计算复杂性理论中，萨维奇定理证明了任何能被非确定性图灵机（NTM）在多项式空间内解决的问题，也能被确定性图灵机在多项式空间内解决，从而确立了 PSPACE = NPSPACE。\n\n该证明的核心涉及一个确定性算法，用于判定 `ST-REACH` 问题：给定一个有向图（代表 NTM 的格局图）、一个起始顶点 `c_start`、一个结束顶点 `c_end` 以及一个最大路径长度 `N`，确定是否存在一条从 `c_start` 到 `c_end` 的长度至多为 `N` 的路径。\n\n让我们考虑该证明核心的递归过程的一个简化版本。这个函数我们称之为 `CanReach(c_1, c_2, k)`，它用于确定格局 `c_2` 是否可以在至多 $2^k$ 步内从格局 `c_1` 到达。参数 `k` 是一个满足 $2^k \\ge N$ 的整数。\n\n该算法定义如下：\n- **`CanReach(c_1, c_2, k)`:**\n  1. 如果 `k = 0`：若 `c_1` 与 `c_2` 相同，或者根据 NTM 的转移函数，`c_2`可以从 `c_1` 一步到达，则返回 `true`。否则，返回 `false`。\n  2. 如果 `k > 0`：遍历每个可能的中间格局 `c_mid`。对于每个 `c_mid`：\n     a. 如果 `CanReach(c_1, c_mid, k-1)` 返回 `true`，则：\n     b. 如果 `CanReach(c_mid, c_2, k-1)` 也返回 `true`：\n     c. 那么就找到了一条路径。返回 `true`。\n  3. 如果循环结束仍未找到任何这样的 `c_mid`，则返回 `false`。\n\n该算法成功验证其存在的第一个路径，是由第一个使得两个递归调用都成功的中间格局 `c_mid`（按照机器固定的迭代顺序）所隐含定义的，对于所有子问题也依此类推。\n\n这条隐含找到的路径是否保证是格局图中从 `c_start` 到 `c_end` 的最短路径？\n\nA. 是，因为路径长度的递归二分确保了最短路径算法特有的最优子结构。\n\nB. 是，因为该算法是广度优先搜索的一种空间优化实现。\n\nC. 否，因为该算法按固定顺序系统地尝试所有可能的中间格局，第一个导致有效路径的格局不一定位于最短路径上。\n\nD. 否，因为格局图可能包含环，而最短路径算法在有环图上没有明确定义。\n\nE. 这个问题本身不成立，因为该算法只判定路径是否存在，而不能构造或识别任何特定的路径。",
            "solution": "我们将问题设定形式化。设 $G=(V,E)$ 为非确定性图灵机的有向格局图。对于 $c_{1},c_{2} \\in V$ 和整数 $k \\ge 0$，过程 $\\mathrm{CanReach}(c_{1},c_{2},k)$ 返回真，当且仅当在 $G$ 中存在一条从 $c_{1}$ 到 $c_{2}$ 的长度至多为 $2^{k}$ 的路径。将图论距离 $\\mathrm{dist}(u,v)$ 定义为从 $u$ 到 $v$ 的最短路径的长度（如果不存在路径，则 $\\mathrm{dist}(u,v)=\\infty$）。问题在于，由第一个成功的递归中点选择序列所隐含确定的特定路径，是否总是从 $c_{\\mathrm{start}}$ 到 $c_{\\mathrm{end}}$ 的最短路径。\n\n我们分析该算法的行为。基准情形 $k=0$ 测试 $c_{1}=c_{2}$ 或 $(c_{1},c_{2}) \\in E$，即 $\\mathrm{dist}(c_{1},c_{2}) \\le 1$。对于 $k>0$，算法按一个固定顺序遍历 $c_{\\mathrm{mid}} \\in V$，并在找到某个 $c_{\\mathrm{mid}}$ 使得 $\\mathrm{CanReach}(c_{1},c_{\\mathrm{mid}},k-1)$ 和 $\\mathrm{CanReach}(c_{\\mathrm{mid}},c_{2},k-1)$ 均为真时返回 `true`。通过对 $k$ 进行归纳，该判定问题的正确性是成立的：如果过程返回真，则存在一条长度至多为 $2^{k}$ 的路径；如果返回假，则不存在这样的路径。然而，这个正确性标准只关心在长度限制内的存在性，而不关心由中点选择序列所构造的特定路径的长度是否最小。\n\n为了说明找到的第一条路径不一定是最短的，我们构造一个明确的反例。设 $V=\\{s,a,b,t\\}$ 且 $E=\\{(s,t),(s,a),(a,b),(b,t)\\}$。那么通过直接边 $(s,t)$，$\\mathrm{dist}(s,t)=1$，同时还存在一条更长的路径 $s \\to a \\to b \\to t$，长度为 $3$。选择 $k=2$，使得 $2^{k}=4 \\ge 3$。假设遍历中点的固定迭代顺序是 $a,b,s,t$。\n\n考虑 $\\mathrm{CanReach}(s,t,2)$。该过程首先检查 $c_{\\mathrm{mid}}=a$：\n- 它评估 $\\mathrm{CanReach}(s,a,1)$，结果为真，因为存在一条从 $s$ 到 $a$ 的长度至多为 $2$ 的路径（实际上 $(s,a) \\in E$）。具体来说，在 $\\mathrm{CanReach}(s,a,1)$ 内部，选择 $c_{\\mathrm{mid}}=a$ 会得到 $\\mathrm{CanReach}(s,a,0)$ 为真（因为 $(s,a) \\in E$）以及 $\\mathrm{CanReach}(a,a,0)$ 为真（因为 $a=a$）。\n- 然后它评估 $\\mathrm{CanReach}(a,t,1)$，结果也为真，因为存在一条长度为 $2$ 的路径 $a \\to b \\to t$。具体来说，在 $\\mathrm{CanReach}(a,t,1)$ 内部，选择 $c_{\\mathrm{mid}}=b$ 会得到 $\\mathrm{CanReach}(a,b,0)$ 为真（因为 $(a,b) \\in E$）以及 $\\mathrm{CanReach}(b,t,0)$ 为真（因为 $(b,t) \\in E$）。\n\n因此，$\\mathrm{CanReach}(s,t,2)$ 在第一个中点 $a$ 处返回真，通过长度为 $3$ 的路径 $s \\to a \\to b \\to t$ 确立了可达性。注意，存在一条长度为 $1$ 的严格更短的路径 $s \\to t$，该路径也会被算法所验证（例如，通过考虑 $c_{\\mathrm{mid}}=t$ 然后将 $\\mathrm{CanReach}(s,t,1)$ 分裂成两段长度至多为 $1$ 的路径），但由于中点迭代顺序是固定的且与距离无关，算法只要找到任何一个能将路径分割成两条长度至多为 $2^{k-1}$ 的子路径的有效中点，就会立即返回。因此，发现的第一条成功路径不一定是最短的；它只保证长度至多为 $2^{k}$。\n\n这直接驳斥了选项 A（中点迭代顺序没有强制执行由最优子结构驱动的最短路径保证）和选项 B（该算法不是广度优先搜索；它不按距离非递减的顺序探索状态）。选项 D 是不正确的，因为即使在有环图中，最短路径长度也是明确定义的；环的存在不排除最短路径的概念。选项 E 是不正确的，因为尽管萨维奇算法是为判定问题设计的，但递归的中点选择确实隐含地定义了一条特定的路径，并且通过少量的记录工作就可以输出该路径；即使在给定的描述中，路径也由成功的中点隐含地指定了。因此，正确的选项是，找到的第一条路径不保证是最短的，这正是因为算法对中点的固定顺序搜索可能会在找到较短的有效路径之前，先识别出一条较长的有效路径。",
            "answer": "$$\\boxed{C}$$"
        },
        {
            "introduction": "萨维奇定理的原始证明解决的是一个“判定问题”——路径是否存在。然而在实际应用中，我们往往需要找到具体路径。这个高级练习将挑战你扩展该算法，使其不仅能判定可达性，还能在满足严格空间限制的条件下，输出一条有效路径，这充分展示了理论算法在实践中的灵活性和强大功能 ()。",
            "id": "1446393",
            "problem": "在计算复杂性理论领域，萨维奇定理（Savitch's theorem）确立了 NPSPACE = PSPACE 这一深刻结果，其中 NPSPACE 是指可由使用多项式空间的非确定性图灵机解决的问题类，而 PSPACE 则是确定性图灵机的问题类。该定理的构造性证明提供了一个确定性算法，仅使用多对数空间即可解决图可达性问题，这是一个典型的 NPSPACE 完备问题。\n\n考虑一个专门的机器人探索场景。一个自主代理必须在一个大型复杂网络中导航，该网络表示为一个有向图 $G=(V, E)$，其中顶点数为 $|V| = N$。该代理的机载计算机内存严重受限。给定一个起始顶点 $s$ 和一个目标顶点 $t$，标准的萨维奇算法可以确定路径是否*存在*。然而，为了导航，代理还必须生成实际路径。\n\n你的任务是为这个代理设计一个确定性算法。该算法的输入包括顶点数 $N$、起始顶点 $s$ 和目标顶点 $t$。图结构本身通过一个预言机函数 `is_edge(u, v)` 提供，如果存在从 $u$ 到 $v$ 的有向边，该函数返回 true，否则返回 false。\n\n该代理的计算模型包括：\n1.  对输入（$N, s, t$）和 `is_edge` 预言机的只读访问权限。\n2.  一个主要的读/写工作带，其使用量定义了空间复杂度。\n3.  一个独立的、只能写一次的输出带。在此带上，磁头只能向当前单元格写入一个符号并向右移动；它不能擦除或向左移动。\n\n如果存在从 $s$ 到 $t$ 的路径，你的算法必须将代表这样一条简单路径的顶点序列写入只写输出带。如果不存在路径，则输出带应保持为空。\n\n这个寻路算法的工作带空间复杂度的最紧上界是多少？用关于 $N$ 的大O表示法表示。\n\nA. $O(\\log N)$\n\nB. $O((\\log N)^2)$\n\nC. $O(N)$\n\nD. $O(N \\log N)$\n\nE. $O(N^2)$",
            "solution": "给定一个有向图 $G=(V,E)$，其中 $|V|=N$，对 $N,s,t$ 和边预言机 $\\text{is\\_edge}(u,v)$ 具有只读访问权限，一个决定空间复杂度的单读/写工作带，以及一个只写输出带。目标是在存在路径的情况下，确定性地输出一条从 $s$到$t$的简单路径，否则不输出任何内容，并使用最优的工作带空间。\n\n首先，回顾萨维奇关于可达性的递归决策过程。定义谓词：\n$$\n\\text{REACH}(u,v,\\ell) := \\text{“存在一条从 u 到 v 长度至多为 \\ell 的有向路径。”}\n$$\n萨维奇的递归如下：\n- 基本情况：对于 $\\ell=1$，当且仅当 `is_edge(u,v)` 为真或 $u=v$ 时，$\\text{REACH}(u,v,1)$ 为真。\n- 递归情况：对于 $\\ell>1$，令 $\\ell_{1}=\\lfloor \\ell/2 \\rfloor$ 且 $\\ell_{2}=\\lceil \\ell/2 \\rceil$。那么，当且仅当存在一个顶点 $m \\in V$ 使得 $\\text{REACH}(u,m,\\ell_{1})$ 和 $\\text{REACH}(m,v,\\ell_{2})$ 均成立时，$\\text{REACH}(u,v,\\ell)$ 为真。\n该算法使用深度为 $O(\\log \\ell)$ 的递归树来确定性地判定可达性，在每一层上，它存储 $u,v,\\ell$ 和循环变量 $m$，每个变量都可以用 $O(\\log N)$ 比特来保存。因此，判定 $\\text{REACH}(u,v,\\ell)$ 所需的工作带空间为\n$$\nO(\\log \\ell \\cdot \\log N).\n$$\n通过设置 $\\ell=N-1$，我们可以在 $O((\\log N)^{2})$ 空间内判定 $s-t$ 的可达性。\n\n为了输出一条简单路径，我们将生成一条最短的 $s-t$ 路径，这条路径必然是简单的。设 $D$ 表示从 $s$ 到 $t$ 的最短路径距离（以边的数量计），并约定如果 $t$ 不可达，则 $D=\\infty$。我们可以通过评估 $\\text{REACH}(s,t,k)$ 来确定是否有 $D \\leq k$。因此，我们可以通过在 $\\{0,1,\\dots,N-1\\}$ 上对 $k$ 进行二分搜索来精确计算 $D$（当其为有限值时），同时维护两个用于表示下界和上界的 $O(\\log N)$ 比特的计数器，并使用 $\\text{REACH}$ 作为决策子程序。此过程的工作带空间仍然是\n$$\nO((\\log N)^{2}),\n$$\n因为 $\\text{REACH}$ 调用的开销占主导地位。\n\n如果 $\\text{REACH}(s,t,N-1)$ 为 false，我们停止算法，不向输出带写入任何内容。否则 $D \\leq N-1$。我们现在通过贪心前向扩展来构造一条最短路径：\n- 初始化 $u := s$，输出 $u$，并设置剩余距离预算 $d := D$。\n- 对于 $i=1,2,\\dots,D$：\n  - 扫描所有 $v \\in V$（使用一个 $O(\\log N)$ 比特的计数器在 $\\{1,2,\\dots,N\\}$ 上迭代 $v$）。对于第一个满足 $\\text{is\\_edge}(u,v)$ 为 true 且 $\\text{REACH}(v,t,d-1)$ 为 true 的 $v$，将此 $v$ 固定为下一个顶点。\n  - 将 $v$ 输出到只写输出带，设置 $u := v$，并设置 $d := d-1$。\n这个循环保证在每一步都能找到这样一个 $v$，因为根据 $D$ 的定义，$u$ 的某个邻居位于某条最短路径上，且到终点的剩余距离为 $d-1$。经过 $D$ 次迭代后，我们到达了 $t$；打印出的序列长度为 $D$，并且作为一条最短路径，它是简单的。\n\n路径构造的空间分析：\n- 变量 $u$, $v$, $d$ 和循环索引每个需要 $O(\\log N)$ 比特。\n- 每次调用 $\\text{REACH}(\\cdot,\\cdot,\\cdot)$ 使用 $O((\\log N)^{2})$ 的工作带空间，因为递归深度为 $O(\\log N)$，每层需要 $O(\\log N)$ 比特。\n- 总空间是这些中的最大值，即 $O((\\log N)^{2})$。只写输出带的使用不计入工作带空间。\n\n因此，存在一个确定性算法，给定 $N,s,t$ 和 `is_edge` 预言机，可以在存在路径时判定可达性并输出一条简单的 $s-t$ 路径，其使用的工作带空间为\n$$\nO((\\log N)^{2}).\n$$\n在所提供的选项中，这是最紧的上界。\n\n因此，正确选项是 B。",
            "answer": "$$\\boxed{B}$$"
        }
    ]
}