{
    "hands_on_practices": [
        {
            "introduction": "Many verification tasks involve confirming that a system is universally safe—that no matter what choices are made, an undesirable outcome is avoided. This exercise  presents such a scenario in a graph context, where we must verify that all possible data paths are secure. The key to classifying this problem lies in a common strategy for universal properties: we analyze its complement, turning the \"for all\" question into a search for a single counterexample, a task perfectly suited for a nondeterministic algorithm.",
            "id": "1451607",
            "problem": "In computational complexity theory, we analyze the resources required to solve decision problems. Consider the following decision problem, which we will call **UNIVERSAL-SAFENET**.\n\nYou are given a directed acyclic graph (DAG) $G = (V, E)$, which represents a network of one-way data channels between servers. You are also given a starting server $s \\in V$ and a special subset of servers $T \\subseteq V$ that are designated as \"secure terminals\". The problem asks the following question: Is it true that every possible data path starting from server $s$ and continuing as far as possible must end at a secure terminal?\n\nA data path is a sequence of connected servers. A path \"ends\" when it reaches a server with no outgoing channels (a sink in the graph).\n\nFormally, the **UNIVERSAL-SAFENET** problem is:\n**Input:** A tuple $(G, s, T)$ where $G=(V,E)$ is a DAG, $s \\in V$, and $T \\subseteq V$.\n**Question:** Does every maximal path starting at vertex $s$ end in a vertex belonging to the set $T$?\n\nBased on the standard definitions of complexity classes, which of the following statements provides the most accurate and immediate classification for the **UNIVERSAL-SAFENET** problem?\n\nThe complexity classes mentioned are:\n- **L**: Logarithmic space on a deterministic Turing machine.\n- **NL**: Nondeterministic Logarithmic-space.\n- **co-NL**: The class of problems whose complement is in NL.\n- **PSPACE**: Polynomial space on a deterministic Turing machine.\n\nA. **UNIVERSAL-SAFENET** is in **L**, because a log-space machine can deterministically traverse all paths from $s$.\n\nB. The complement of **UNIVERSAL-SAFENET** is in **NL**, which by definition means **UNIVERSAL-SAFENET** is in **co-NL**.\n\nC. **UNIVERSAL-SAFENET** is in **NL**, because a nondeterministic machine can guess a path from $s$ and verify that it ends in a secure terminal from the set $T$.\n\nD. **UNIVERSAL-SAFENET** is **PSPACE**-complete because checking all paths can lead to an exponential number of routes to explore.",
            "solution": "The core of this problem is to classify the **UNIVERSAL-SAFENET** problem by analyzing its structure and relating it to the definitions of complexity classes, particularly **NL** and **co-NL**.\n\n**Step 1: Understand the Problem**\nThe problem **UNIVERSAL-SAFENET** asks a \"for all\" (universal) question: does *every* maximal path from a starting vertex $s$ have a specific property (ending in the set $T$)? The complexity class **NL** is naturally suited for \"exists\" (existential) questions, where a nondeterministic machine can guess a certificate (like a path) and verify it. Universal questions are often characteristic of co-classes.\n\n**Step 2: Define and Analyze the Complement Problem**\nTo determine if **UNIVERSAL-SAFENET** is in **co-NL**, we must analyze its complement, which we can call **NON-UNIVERSAL-SAFENET**.\n- A \"yes\" instance of **UNIVERSAL-SAFENET** means all maximal paths from $s$ end in $T$.\n- A \"no\" instance of **UNIVERSAL-SAFENET** means there is at least one maximal path from $s$ that does *not* end in $T$.\n\nTherefore, the complement problem **NON-UNIVERSAL-SAFENET** is:\n**Question:** Does there *exist* at least one maximal path starting at $s$ that ends in a vertex $v \\notin T$?\n\n**Step 3: Show the Complement Problem is in NL**\nWe now show that **NON-UNIVERSAL-SAFENET** can be solved by a Nondeterministic Turing Machine (NTM) using only logarithmic space. The input size $n$ is proportional to $|V| + |E|$. An algorithm for the NTM is as follows:\n\n1.  Initialize a \"current vertex\" pointer, `curr`, to the start vertex $s$. This pointer requires $O(\\log|V|)$ space to store.\n2.  At each step, if `curr` has outgoing edges, nondeterministically choose one of its neighbors, say $v'$, and update `curr` to $v'$.\n3.  Repeat this process. Since the graph is a Directed Acyclic Graph (DAG), we are guaranteed not to enter a cycle. A path cannot have more than $|V|-1$ edges. A counter can be used to track path length to ensure termination, also using $O(\\log|V|)$ space.\n4.  The process stops when `curr` points to a vertex that is a sink (it has no outgoing edges). Let this sink vertex be $v_{end}$.\n5.  The machine then checks if $v_{end} \\in T$.\n    - If $v_{end} \\notin T$, the machine has successfully found a path that violates the condition of **UNIVERSAL-SAFENET**. In this case, the NTM accepts.\n    - If $v_{end} \\in T$, this particular nondeterministic branch of computation has failed to find a counterexample, so it rejects.\n\nBy the definition of nondeterministic computation, the NTM accepts the input if *any* of its computation branches accept. This happens precisely when there exists a maximal path from $s$ that ends outside $T$. The space used is for storing the current vertex and a counter, which is $O(\\log|V|)$, and therefore $O(\\log n)$. Thus, **NON-UNIVERSAL-SAFENET** is in **NL**.\n\n**Step 4: Conclude the Classification of the Original Problem**\nSince the complement of **UNIVERSAL-SAFENET** is in **NL**, by the very definition of the class **co-NL**, the **UNIVERSAL-SAFENET** problem is in **co-NL**.\n\n**Step 5: Evaluate the Given Options**\n\n*   **A. **UNIVERSAL-SAFENET** is in **L**, because a log-space machine can deterministically traverse all paths from $s$.**\n    This is incorrect. A deterministic machine would need to keep track of which branches of the path it has explored, which generally requires more than logarithmic space (e.g., a stack for a depth-first search).\n\n*   **B. The complement of **UNIVERSAL-SAFENET** is in **NL**, which by definition means **UNIVERSAL-SAFENET** is in **co-NL**.**\n    This is correct. Our analysis in Steps 2-4 demonstrates this exact line of reasoning. This is the most accurate and direct classification based on the problem's universal quantifier structure.\n\n*   **C. **UNIVERSAL-SAFENET** is in **NL**, because a nondeterministic machine can guess a path from $s$ and verify that it ends in a secure terminal from the set $T$.**\n    This is incorrect. This logic would solve the problem \"Does there *exist* a path from $s$ that ends in $T$?\" It does not verify that *all* paths do. Just because one path is \"safe\" does not mean all paths are.\n\n*   **D. **UNIVERSAL-SAFENET** is **PSPACE**-complete because checking all paths can lead to an exponential number of routes to explore.**\n    This is incorrect. While there can be an exponential number of paths, the problem is not that hard. It can be solved in polynomial time on a deterministic machine (e.g., using dynamic programming or graph traversal), so it is in **P**. Since **P** $\\subseteq$ **PSPACE**, it cannot be **PSPACE**-complete unless **P** = **PSPACE**. Furthermore, our analysis shows it is in **co-NL**, which is a much smaller class than **PSPACE**.\n\nTherefore, the reasoning presented in option B is the most faithful and accurate classification based on the problem's definition.",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "Building on the idea of complementary problems, this next practice  explores the boundary of the class co-NL by considering a completeness question. We investigate the problem of ensuring no monochromatic path exists, which is the complement of a natural variation on the canonical `PATH` problem. This exercise demonstrates the definition of co-NL-completeness and illustrates the profound impact of the Immerman-Szelepcsényi theorem, which proves that NL is closed under complementation ($NL = co-NL$).",
            "id": "1451589",
            "problem": "In computational complexity theory, we study the resources required to solve computational problems. Consider a directed graph $G = (V, E)$ where every edge in $E$ is colored either red or blue. A path from a vertex $u$ to a vertex $v$ is called monochromatic if all edges along that path have the same color.\n\nLet's define the decision problem **NO-MONO-PATH**. An instance of this problem is a tuple $\\langle G, s, t \\rangle$, where $G$ is a 2-edge-colored directed graph, and $s, t$ are two vertices in $G$. The problem is to decide if there is **no** monochromatic path from the source vertex $s$ to the target vertex $t$.\n\nFor context, recall the following complexity classes:\n- **L**: The class of decision problems solvable by a deterministic Turing machine using logarithmic space.\n- **NL** (Nondeterministic Logarithmic Space): The class of decision problems solvable by a nondeterministic Turing machine using logarithmic space.\n- **co-NL**: The class of decision problems whose complement is in NL.\n- **P**: The class of decision problems solvable by a deterministic Turing machine in polynomial time.\n\nThe canonical **NL**-complete problem is **ST-CONNECTIVITY** (also known as **PATH**), which asks whether a path exists from a vertex $s$ to a vertex $t$ in a directed graph. A major result in complexity theory is the Immerman–Szelepcsényi theorem, which states that **NL** = **co-NL**.\n\nBased on this information, which of the following statements provides the most complete and accurate classification of the **NO-MONO-PATH** problem?\n\nA. **NO-MONO-PATH** is in **L**.\n\nB. **NO-MONO-PATH** is **NL**-complete.\n\nC. **NO-MONO-PATH** is **co-NL**-complete.\n\nD. **NO-MONO-PATH** is in **P**, but is not known to be in **NL** or **co-NL**.\n\nE. Both B and C are correct.",
            "solution": "We formalize the decision problems. Given a directed graph $G=(V,E)$ with each edge colored red or blue and vertices $s,t \\in V$, define\n- $\\mathrm{MONO\\text{-}PATH} = \\{\\langle G,s,t\\rangle : \\text{there exists a monochromatic path from } s \\text{ to } t\\}$,\n- $\\mathrm{NO\\text{-}MONO\\text{-}PATH} = \\overline{\\mathrm{MONO\\text{-}PATH}}$.\n\nWe classify **MONO-PATH** first.\n1) Membership in **NL**: On input $\\langle G,s,t\\rangle$, a nondeterministic logspace machine can guess one bit $b \\in \\{0,1\\}$ denoting the color (say $b=0$ for red and $b=1$ for blue), and then simulate the standard **NL** algorithm for **ST-CONNECTIVITY** restricted to the subgraph consisting only of edges of the chosen color. This uses $O(\\log |V|)$ space and accepts iff there is a path from $s$ to $t$ using only edges of that color. Since acceptance is by an existential condition over a nondeterministic computation, this shows **MONO-PATH** $\\in \\mathrm{NL}$.\n\n2) **NL**-hardness: Reduce **ST-CONNECTIVITY** to **MONO-PATH** via a logspace many-one reduction $f$ that maps an input graph $\\langle G,s,t\\rangle$ to $\\langle G',s,t\\rangle$, where $G'$ is the same directed graph with every edge colored red. Then $\\langle G,s,t\\rangle \\in \\mathrm{ST\\text{-}CONNECTIVITY}$ if and only if $\\langle G',s,t\\rangle \\in \\mathrm{MONO\\text{-}PATH}$. The mapping is computable in logarithmic space. Hence **MONO-PATH** is **NL**-complete.\n\nWe now classify **NO-MONO-PATH**.\n3) Membership in **co-NL**: Since **MONO-PATH** $\\in \\mathrm{NL}$, its complement **NO-MONO-PATH** is in $\\mathrm{co\\text{-}NL}$ by definition of the class.\n\n4) **co-NL**-hardness: Let $L \\in \\mathrm{NL}$ be arbitrary. By **NL**-completeness of **MONO-PATH**, there exists a logspace many-one reduction $g$ such that for all strings $x$, $x \\in L$ if and only if $g(x) \\in \\mathrm{MONO\\text{-}PATH}$. Taking complements yields $x \\in \\overline{L}$ if and only if $g(x) \\in \\overline{\\mathrm{MONO\\text{-}PATH}} = \\mathrm{NO\\text{-}MONO\\text{-}PATH}$. Thus $\\overline{L} \\leq_{m}^{\\log} \\mathrm{NO\\text{-}MONO\\text{-}PATH}$. Since $\\overline{L}$ ranges over all of $\\mathrm{co\\text{-}NL}$ as $L$ ranges over $\\mathrm{NL}$, **NO-MONO-PATH** is **co-NL**-hard.\n\nFrom 3) and 4), **NO-MONO-PATH** is **co-NL**-complete.\n\nFinally, by the Immerman–Szelepcsényi theorem **NL**=**co-NL**. Under logspace many-one reductions, **co-NL**-completeness and **NL**-completeness coincide when the underlying classes are equal. Therefore **NO-MONO-PATH** is also **NL**-complete. This rules out option A (which would imply **L**=**NL**) and D, and makes both B and C true. The most complete classification is that both B and C hold, i.e., E.",
            "answer": "$$\\boxed{E}$$"
        },
        {
            "introduction": "This final exercise  moves beyond simple definitions to demonstrate how the $NL = co-NL$ theorem serves as a powerful constructive tool in algorithm design. The problem of comparing the number of reachable nodes appears to require counting, a capability not obviously available in logarithmic space. This practice reveals how a clever nondeterministic algorithm can solve this by using the theorem as a subroutine, showcasing the surprising power of nondeterministic log-space computation.",
            "id": "1451560",
            "problem": "In network analysis, it is often necessary to compare the connectivity properties of different network topologies. Consider two communication networks modeled as directed graphs, $G_1 = (V_1, E_1)$ and $G_2 = (V_2, E_2)$. In each network, there is a designated source server, $s_1 \\in V_1$ and $s_2 \\in V_2$, respectively. For a given graph $G$ and a starting vertex $s$, let $R(G, s)$ denote the set of all vertices reachable from $s$ via some path of zero or more edges.\n\nYou are tasked with analyzing a specific decision problem called **UNEQUAL-REACH**. This problem takes as input a tuple $(G_1, G_2, s_1, s_2)$ and decides whether the number of vertices reachable from $s_1$ in $G_1$ is unequal to the number of vertices reachable from $s_2$ in $G_2$. That is, the problem is to decide if $|R(G_1, s_1)| \\neq |R(G_2, s_2)|$.\n\nThe following are standard computational complexity classes:\n- **L**: Logarithmic space on a deterministic Turing machine.\n- **NL**: Logarithmic space on a non-deterministic Turing machine.\n- **co-NL**: The class of problems whose complement is in NL.\n- **P**: Polynomial time on a deterministic Turing machine.\n- **NP**: Polynomial time on a non-deterministic Turing machine.\n\nWhich of the following represents the most specific complexity class (i.e., the smallest class in the hierarchy L, NL, co-NL, P, NP) that is known to contain the **UNEQUAL-REACH** problem?\n\nA. **L**\n\nB. **co-NL**\n\nC. **P**\n\nD. **NP**",
            "solution": "The problem asks for the most specific known complexity class for the **UNEQUAL-REACH** problem. The **UNEQUAL-REACH** problem is the set of instances $(G_1, G_2, s_1, s_2)$ for which $|R(G_1, s_1)| \\neq |R(G_2, s_2)|$.\n\nTo classify **UNEQUAL-REACH**, let's first consider its complement, which we'll call **EQUAL-REACH**.\nThe **EQUAL-REACH** problem is the set of instances $(G_1, G_2, s_1, s_2)$ for which $|R(G_1, s_1)| = |R(G_2, s_2)|$.\nBy definition, if we can show that **EQUAL-REACH** is in the class **NL** (Nondeterministic Logarithmic Space), then **UNEQUAL-REACH** must be in the class **co-NL**.\n\nOur goal is to construct a non-deterministic Turing machine (NTM) that solves **EQUAL-REACH** using only logarithmic space, $O(\\log n)$, where $n$ is the total size of the input graphs.\n\nThe high-level strategy for our NTM is as follows:\n1.  Non-deterministically guess an integer $k$, where $0 \\leq k \\leq \\max(|V_1|, |V_2|)$. This integer $k$ is our guess for the common number of reachable vertices. Storing $k$ requires $O(\\log |V|)$ space, which is within our logarithmic space bound.\n2.  Verify that the number of vertices reachable from $s_1$ in $G_1$ is exactly $k$.\n3.  Verify that the number of vertices reachable from $s_2$ in $G_2$ is exactly $k$.\n4.  If both verifications are successful, the machine accepts. If any verification fails, this non-deterministic path rejects.\n\nThe machine accepts the input if there exists *any* guess for $k$ for which both verification steps succeed. This is only possible if the number of reachable vertices is indeed the same in both graphs.\n\nNow, we must show that the verification step, \"verify that $|R(G, s)| = k$\", can be performed in **NL**. Let's call this subproblem **EXACTLY-k-REACH**. This subproblem can be broken down into two conditions that must both be true:\n(a) The number of reachable vertices is at least $k$, i.e., $|R(G, s)| \\geq k$.\n(b) The number of reachable vertices is at most $k$, i.e., $|R(G, s)| \\leq k$.\n\nLet's analyze the complexity of checking each condition.\n\n**Condition (a): Verifying $|R(G, s)| \\geq k$.**\nThe language is $L_{\\geq k} = \\{ (G, s, k) \\mid |R(G,s)| \\ge k \\}$. An NTM can decide this as follows:\n1.  Non-deterministically guess $k$ distinct vertices from $V$: $v_1, v_2, \\dots, v_k$.\n2.  For each guessed vertex $v_i$ (from $i=1$ to $k$):\n    a. Non-deterministically guess a path from $s$ to $v_i$.\n    b. Verify that the guessed path is valid in $G$.\n3.  If all $k$ vertices are distinct and a valid path is found for each, the machine accepts. Otherwise, it rejects on this path.\n\nThe space required is logarithmic. We need to store counters for loops (up to $k$ and path length, both $\\le |V|$), and the identifiers for the current vertices being checked. All these fit within $O(\\log |V| + \\log |E|)$ space. Thus, verifying $|R(G, s)| \\geq k$ is in **NL**.\n\n**Condition (b): Verifying $|R(G, s)| \\leq k$.**\nThe language is $L_{\\leq k} = \\{ (G, s, k) \\mid |R(G,s)| \\le k \\}$. Consider the complement of this language, $\\overline{L_{\\leq k}}$.\n$\\overline{L_{\\leq k}} = \\{ (G, s, k) \\mid |R(G,s)| > k \\} = \\{ (G, s, k) \\mid |R(G,s)| \\ge k+1 \\}$.\nThis complement is exactly the language $L_{\\geq k+1}$. From our analysis of condition (a), we know that $L_{\\geq k+1}$ is in **NL**.\nTherefore, $L_{\\leq k}$ is in **co-NL**.\n\nThis is where a landmark result in complexity theory, the Immerman-Szelepcsényi theorem, is crucial. The theorem states that **NL** = **co-NL**. This means that any problem in **co-NL** is also in **NL**. Since we've shown that verifying $|R(G, s)| \\leq k$ is in **co-NL**, by this theorem, it must also be in **NL**.\n\n**Conclusion for `EQUAL-REACH`:**\nThe problem of verifying $|R(G, s)| = k$ requires checking that both $|R(G, s)| \\geq k$ (which is in **NL**) and $|R(G, s)| \\leq k$ (which is in **NL** due to **NL**=**co-NL**) hold true. The class **NL** is closed under intersection, meaning if two languages are in **NL**, their intersection is also in **NL**. An NTM can simply run the machine for the first language, and if it accepts, run the machine for the second language. Thus, **EXACTLY-k-REACH** is in **NL**.\n\nSince the verification step of our main algorithm for **EQUAL-REACH** is in **NL**, and the overall algorithm is just a non-deterministic guess of $k$ followed by two such verifications, the entire **EQUAL-REACH** problem is in **NL**.\n\n**Final Classification of `UNEQUAL-REACH`:**\nSince **EQUAL-REACH** is in **NL**, its complement, **UNEQUAL-REACH**, is by definition in **co-NL**.\n\nNow we evaluate the given options:\nA. **L**: It is not known if **UNEQUAL-REACH** is in **L**. Proving this would imply **L**=**NL**, a major unsolved problem in complexity theory. So this is unlikely to be the correct answer for \"known to contain\".\nB. **co-NL**: As proven above, **UNEQUAL-REACH** is in this class.\nC. **P**: The problem is also in **P**. A deterministic polynomial-time algorithm is to run Breadth-First Search (BFS) or Depth-First Search (DFS) from $s_1$ in $G_1$ to count all reachable nodes, do the same for $s_2$ in $G_2$, and then compare the two counts. This takes $O(|V_1|+|E_1| + |V_2|+|E_2|)$ time. Since **co-NL** $\\subseteq$ **P**, this is a correct, but less specific, classification.\nD. **NP**: Since **P** $\\subseteq$ **NP**, this is also a valid, but even less specific, class.\n\nThe question asks for the *most specific* known complexity class. The known hierarchy is **L** $\\subseteq$ **NL** = **co-NL** $\\subseteq$ **P** $\\subseteq$ **NP**. Since we have shown the problem to be in **co-NL**, and **co-NL** is a smaller class than **P** and **NP**, **co-NL** is the most specific class among the correct options (B, C, D).\n\nTherefore, **co-NL** is the tightest classification for **UNEQUAL-REACH** among the choices provided.",
            "answer": "$$\\boxed{B}$$"
        }
    ]
}