{
    "hands_on_practices": [
        {
            "introduction": "To begin, we explore a classic two-player game on a graph. This exercise  is designed to build the fundamental intuition behind PSPACE: while the number of possible game states can be enormous, we can determine a winner using an algorithm whose memory usage remains manageable. Understanding how to analyze the space complexity of this recursive search is a crucial first step in grasping the nature of PSPACE.",
            "id": "1439408",
            "problem": "Two computer science students, Alex and Ben, are analyzing the computational complexity of a two-player game they call the \"Adversarial Path Game\".\n\nThe game is defined by a directed graph $G=(V, E)$, a starting vertex $s \\in V$, and a target vertex $t \\in V$. Player 1 and Player 2 take turns moving a single token, which is initially placed on vertex $s$. On a player's turn, they must move the token from its current vertex $u$ to an adjacent vertex $v$, following an edge $(u,v) \\in E$.\n\nThe rules are as follows:\n1.  Player 1 takes the first turn.\n2.  The first player to move the token onto the target vertex $t$ wins the game immediately.\n3.  If it is a player's turn and the token is on a vertex $u \\neq t$ that has no outgoing edges, that player has no valid moves and loses immediately.\n4.  To ensure the game always terminates, a maximum of $2|V|$ total moves are allowed. If no player has won by the end of the $2|V|$-th move, the game is declared a loss for Player 1 (and thus a win for Player 2).\n\nThe corresponding decision problem, `WINNING-STRATEGY`, asks: Given an instance $(G, s, t)$, does Player 1 have a winning strategy, assuming Player 2 plays optimally to counter them?\n\nAlex proposes an algorithm to solve this. He defines a recursive function, `CanWin(u, k)`, which returns true if the current player to move from vertex `u` can force a win within the next `k` moves. The initial call would be `CanWin(s, 2|V|)`. Alex reasons that since this function may recursively call itself for each of `u`'s neighbors, the total number of computations could be exponential in $|V|$. He concludes that `WINNING-STRATEGY` is in the complexity class EXP (solvable in exponential time).\n\nBen agrees that a recursive solution is the right approach but claims Alex's complexity analysis is incomplete and potentially misleading. Ben suggests that the space requirements of the algorithm are more revealing of the problem's fundamental complexity.\n\nWhich of the following statements provides the most accurate analysis of the computational complexity of the `WINNING-STRATEGY` problem?\n\nA. Alex is correct. The problem is in EXP. The exponential nature of the game tree means the problem cannot be solved in polynomial space, so it is not in PSPACE.\n\nB. Both students are overlooking a key detail. A winning strategy is a sequence of moves for Player 1. This sequence is a certificate of polynomial length that can be verified in polynomial time. Therefore, the problem is in NP.\n\nC. The game is an adversarial search problem that can be solved with a depth-first recursive algorithm. While the time taken by a naive implementation is exponential, the space required is only polynomial because the call stack depth is bounded by the polynomial game length ($2|V|$). Therefore, the problem is in PSPACE.\n\nD. Both students are overthinking the problem. Determining if Player 1 can win is equivalent to checking if a path from $s$ to $t$ exists. This can be solved in polynomial time using an algorithm like Breadth-First Search (BFS), placing the problem in P.\n\nE. Alex's algorithm is flawed because the game can have cycles, leading to infinite recursion. A correct algorithm would need to store all visited states to avoid cycles, which requires exponential space. Therefore, the problem is in EXPSPACE.",
            "solution": "We formalize the decision problem as follows. The game state is given by a pair $(u,k)$ where $u \\in V$ is the current vertex of the token and $k$ is the number of moves remaining, with the initial state $(s,2|V|)$. Players alternate turns; Player 1 moves at even $k$ and Player 2 moves at odd $k$. The game ends immediately when a move lands on $t$. If it is a player's turn at $(u,k)$ with $u \\neq t$ and $\\deg^{+}(u)=0$, that player loses. If no one has won by the time $k$ reaches $0$, this corresponds to Player 1's turn (since $0$ is even), and by rule 4 Player 1 loses.\n\nDefine a recursive predicate $\\text{CanWin}(u,k)$ to mean: the player whose turn it is at state $(u,k)$ can force a win from $(u,k)$. The recursion is:\n- If there exists $(u,v) \\in E$ with $v=t$, then $\\text{CanWin}(u,k)=\\text{true}$ (the current player moves to $t$ and wins immediately).\n- Else, if $\\deg^{+}(u)=0$, then $\\text{CanWin}(u,k)=\\text{false}$ (no legal move for the current player, so they lose).\n- Else, if $k=0$, then since it is Player 1's turn, $\\text{CanWin}(u,0)=\\text{false}$ by rule 4.\n- Otherwise, the current player has a winning move iff there exists a successor $v$ with $(u,v) \\in E$ such that the next player cannot force a win from $(v,k-1)$, i.e.,\n$$\n\\text{CanWin}(u,k)=\\exists v \\in V \\text{ with } (u,v)\\in E \\text{ such that } \\neg \\text{CanWin}(v,k-1).\n$$\n\nThis depth-first recursive evaluation explores the game tree to depth at most $2|V|$ because $k$ decreases by $1$ each move and the initial bound is $2|V|$. Therefore, the recursion depth is bounded by a polynomial in $|V|$.\n\nSpace analysis: a depth-first evaluation keeps only the current call stack of depth at most $2|V|$. Each stack frame needs to store $u$ (an index into $V$), $k$ (an integer bounded by $2|V|$), and iteration state over the outgoing edges of $u$. The space per frame is $O(\\log |V|)$ bits plus control information, hence the total space is\n$$\nO\\left( |V| \\cdot \\log |V| \\right),\n$$\nwhich is polynomial in the input size. Thus the problem is in PSPACE.\n\nTime analysis: the number of recursive calls in the worst case is exponential in $|V|$ because the branching factor is up to $\\max_{u} \\deg^{+}(u)$ and the depth is $2|V|$, so a naive implementation may take time $|V|^{\\Theta(|V|)}$. This shows that while time can be exponential, the space remains polynomial, which is the defining property of membership in PSPACE.\n\nWhy the other options are incorrect:\n- Option A is incorrect because although time may be exponential, the problem is solvable in polynomial space via the depth-first recursion above, so it is in PSPACE.\n- Option B is incorrect because a single polynomial-length sequence of moves does not certify a win against all optimal counter-moves by Player 2; a full winning strategy may require a tree of contingent moves whose size can be exponential.\n- Option D is incorrect because the existence of a path from $s$ to $t$ does not imply Player 1 can force reaching $t$ against an adversary; adversarial choices must be accounted for.\n- Option E is incorrect because the explicit move limit $2|V|$ prevents infinite recursion; no exponential space of visited states is required for correctness, and a depth-first approach uses only polynomial space.\n\nTherefore, the most accurate statement is that the problem is in PSPACE due to the polynomial bound on recursion depth and space usage, as described in Option C.",
            "answer": "$$\\boxed{C}$$"
        },
        {
            "introduction": "Now we move from identifying problems in PSPACE to proving they are PSPACE-complete. This next challenge, a duel involving cellular automata, models the structure of Quantified Boolean Formulas (TQBF), the canonical PSPACE-complete problem. Tackling this problem  will give you hands-on experience with the powerful technique of polynomial-time reduction, the gold standard for establishing a problem's computational hardness.",
            "id": "1439416",
            "problem": "Consider a game called \"Cellular Automaton Duel,\" played by two players, Alice and Bob, on a one-dimensional array of cells. The game is defined by a tuple of parameters: $(N, T, P)$, where $N$ is the number of cells, $T$ is the number of evolution time steps, and $P$ is a target pattern.\n\n**Game Setup and Rules:**\n1.  The game board consists of a one-dimensional array of $N$ cells, indexed $0, 1, \\dots, N-1$. Initially, all cells are in an \"unset\" state.\n2.  Alice and Bob take turns selecting a cell. Alice goes first. On each turn, a player must choose one \"unset\" cell and set its state to either 0 or 1.\n3.  The game proceeds for $N$ turns until all cells have been set, defining the initial configuration (at time $t=0$) of a Cellular Automaton (CA).\n4.  Once the initial configuration is set, the CA evolves for $T$ time steps. The state of cell $i$ at time $t+1$, denoted $s'_{i}$, is determined by the states of its neighbors at time $t$ according to the update rule:\n    $$s'_{i} = (s_{i-1} + s_{i+1}) \\pmod 2$$\n    For the boundary cells, the state of the neighbor outside the array is always considered to be 0. That is, for cell 0, its left neighbor $s_{-1}$ is 0, and for cell $N-1$, its right neighbor $s_{N}$ is 0.\n5.  **Winning Condition:** Alice wins if the final configuration of the cells at time $T$ contains the binary string $P$ as a contiguous sub-pattern. If the pattern is not present, Bob wins.\n\nLet `CA_DUEL` be the decision problem that asks: given an instance $(N, T, P)$, does Alice have a winning strategy, assuming both players play optimally? The values of $N$ and $T$ are positive integers, and $P$ is a non-empty binary string. Assume that the value of $T$ and the length of $P$ are bounded by a polynomial function of $N$.\n\nWhich of the following complexity classes best describes the `CA_DUEL` problem?\n\nA. P (solvable in polynomial time)\nB. NP-complete\nC. co-NP-complete\nD. PSPACE-complete\nE. EXPTIME-complete",
            "solution": "The problem asks for the computational complexity of determining if Alice (the first player) has a winning strategy in the game \"Cellular Automaton Duel\". This is a question about the complexity of a two-player, perfect-information game. The structure of such games often points towards the class PSPACE. We will demonstrate that `CA_DUEL` is PSPACE-complete by showing it is both in PSPACE and PSPACE-hard.\n\n**Part 1: `CA_DUEL` is in PSPACE**\n\nA problem is in PSPACE if it can be decided by a Turing machine using an amount of memory (space) that is polynomial in the size of the input. For `CA_DUEL`, the input size is related to $N$, the number of bits to represent $T$, and the length of $P$. Since $T$ and $|P|$ are polynomially bounded by $N$, the input size is dominated by $N$.\n\nWe can determine the winner of the game using a recursive algorithm that explores the game tree. Let's define a function `CanAliceWin(board, turn_number)`.\n- The `board` argument represents the current state of the $N$ cells, which can be 0, 1, or \"unset\".\n- The `turn_number` argument indicates whose move it is. If `turn_number` is odd (1, 3, ...), it's Alice's turn. If it's even (2, 4, ...), it's Bob's turn.\n\nThe logic of the function is as follows:\n1.  **Base Case:** If `turn_number` > $N$, all cells are set. Simulate the CA for $T$ steps starting from the current `board` configuration. The simulation requires storing the state of $N$ cells and iterating $T$ times. For each step, we compute the next state of all $N$ cells. This takes $O(N)$ space and $O(N \\cdot T)$ time. After $T$ steps, check if the resulting configuration contains the pattern $P$. If it does, return `true`; otherwise, return `false`.\n\n2.  **Recursive Step (Alice's Turn):** If it is Alice's turn, she wins if there *exists* at least one move that leads to a winning position for her. So, iterate through all possible moves for Alice (for each unset cell, try setting it to 0 and to 1). If any of these moves leads to a state where `CanAliceWin(new_board, turn_number + 1)` returns `true`, then Alice can force a win from the current position. The function should return `true`. If all moves lead to states where `CanAliceWin` returns `false`, then Alice cannot win from here, so return `false`.\n\n3.  **Recursive Step (Bob's Turn):** If it is Bob's turn, Alice wins only if she wins *for all* of Bob's possible responses. So, iterate through all of Bob's possible moves. If all of these moves lead to states where `CanAliceWin(new_board, turn_number + 1)` returns `true`, it means Alice wins regardless of Bob's move. The function should return `true`. If there is even one move for Bob that leads to a state where `CanAliceWin` returns `false`, then Bob can choose that move to make Alice lose, so the function should return `false`.\n\nThis recursive structure perfectly models the alternating quantifiers of PSPACE problems: Alice's turns are existential ($\\exists$ a move) and Bob's turns are universal ($\\forall$ moves).\n\nTo analyze the space complexity, note that the maximum recursion depth is $N$. At each level of recursion, we need to store the current board state, which takes $O(N)$ space. The total space for the recursion stack is $N \\times O(N) = O(N^2)$. At the base of the recursion, we need to simulate the CA, which can be done in $O(N)$ space (by only storing the current and next configurations) for $T$ steps. Since $T$ is polynomial in $N$, the time for this simulation is polynomial, but the space remains polynomial. The total space required is polynomial in $N$. Therefore, `CA_DUEL` is in PSPACE.\n\n**Part 2: `CA_DUEL` is PSPACE-hard**\n\nTo prove PSPACE-hardness, we reduce a known PSPACE-complete problem to `CA_DUEL`. The canonical PSPACE-complete problem is the True Quantified Boolean Formula (TQBF) problem.\n\nAn instance of TQBF is a formula of the form $\\Phi = \\exists x_1 \\forall x_2 \\exists x_3 \\dots Q_k x_k \\phi(x_1, \\dots, x_k)$, where $\\phi$ is a Boolean formula (which we can assume to be in 3-Conjunctive Normal Form, or 3-CNF) and $Q_k$ is either $\\exists$ or $\\forall$. The problem is to decide if this fully quantified formula is true.\n\nWe need to construct an instance of `CA_DUEL` $(N, T, P)$ from a TQBF instance $\\Phi$ such that Alice has a winning strategy if and only if $\\Phi$ is true.\n\n**The Reduction:**\n1.  **Mapping Players to Quantifiers:** The game structure naturally maps to the quantifiers. Alice's turns will correspond to the existentially quantified variables ($\\exists x_i$), and Bob's turns will correspond to the universally quantified variables ($\\forall x_j$).\n\n2.  **Mapping Moves to Variable Assignments:** For a TQBF formula with $k$ variables, we will set the number of game cells $N$ to be large enough to embed the logic of the formula $\\phi$. Let's say we dedicate the first $k$ turns of the game to setting the values of the variables $x_1, \\dots, x_k$.\n    - On turn $i$ (from 1 to $k$), the player whose turn it is (Alice if $Q_i = \\exists$, Bob if $Q_i = \\forall$) will choose an unset cell, say cell $c_i$, and set its state. Setting it to 1 corresponds to setting variable $x_i$ to `true`, and setting it to 0 corresponds to setting $x_i$ to `false`. The other $N-k$ cells can be part of a \"scaffolding\" that is set by players in the remaining turns, or we can design the game such that only specific cells are designated for variable assignment. Let's assume the players are forced to pick designated cells $c_1, c_2, \\ldots, c_k$ in order.\n\n3.  **Simulating the Formula $\\phi$ with the CA:** The core of the reduction is to show that the CA evolution can function as a circuit to evaluate the Boolean formula $\\phi$ based on the initial assignments of $x_1, \\dots, x_k$. It is a known result in complexity theory that even simple 1D Cellular Automata (like Rule 110, which is Turing-complete) can be used to simulate arbitrary logic circuits. The specific rule given in the problem, $s'_{i} = (s_{i-1} + s_{i+1}) \\pmod 2$, is also capable of complex computations and can be used to construct logic gates.\n    - We would design the initial configuration (the part of the board beyond the $k$ variable-cells) and the number of steps $T$ such that:\n        - Signals representing the truth values of the variables $x_i$ and their negations $\\neg x_i$ propagate through the CA grid over time, much like signals on wires.\n        - These signals interact at specific locations (\"gadgets\") that are constructed to behave like logical AND, OR, and NOT gates.\n        - The outputs of these gates are then combined to evaluate each clause of the 3-CNF formula $\\phi$.\n        - Finally, the results from all clauses are combined (using AND gates) to produce a single output signal that is 1 if and only if $\\phi$ is true for the given variable assignment.\n    - We set the target pattern $P$ to be \"1\" and designate a specific \"output cell\" at a specific location. We choose the evolution time $T$ to be just long enough for the entire computation to complete and for the final result to appear at this output cell. The construction of this CA circuit is complex but mechanical, and its size ($N$) and required time ($T$) would be polynomial in the size of the original formula $\\phi$.\n\n**Conclusion of Reduction:**\n- Alice's goal is to make the pattern \"1\" appear. She controls the $\\exists$ variables. She has a winning strategy if she can choose values for her variables such that, no matter what values Bob chooses for the $\\forall$ variables, the formula $\\phi$ evaluates to true, causing the pattern \"1\" to appear.\n- This is precisely the condition for the TQBF formula $\\Phi$ to be true.\n- Therefore, Alice has a winning strategy in our constructed `CA_DUEL` instance if and only if the TQBF instance $\\Phi$ is true. This reduction is computable in polynomial time.\n\nSince `CA_DUEL` is in PSPACE and is PSPACE-hard, it is PSPACE-complete. This corresponds to option D. The other options are incorrect because the problem is harder than NP or co-NP due to the alternating player structure, but not as hard as EXPTIME because the game length and simulation time are polynomially bounded.",
            "answer": "$$\\boxed{D}$$"
        },
        {
            "introduction": "PSPACE-completeness extends far beyond abstract games, appearing in critical areas like program verification and network security. This final practice problem  casts you as a software engineer verifying a firewall system modeled by Nondeterministic Finite Automata (NFAs). This scenario demonstrates how questions about the behavior of automata—specifically, whether an NFA accepts all possible strings—are computationally difficult and lie at the heart of PSPACE-completeness.",
            "id": "1439444",
            "problem": "A software engineer is developing a sophisticated firewall system for a high-security data center. The firewall operates on sequences of network packets, where each packet is of a certain type. The set of all possible packet types is denoted by the alphabet $\\Sigma$. The behavior of the firewall is governed by two independent rule-sets, an \"Allow-list\" and a \"Deny-list\". Each rule-set is defined by a pattern-matching engine that can be formally modeled as a Nondeterministic Finite Automaton (NFA).\n\nLet $N_A$ be the NFA representing the Allow-list and $N_D$ be the NFA representing the Deny-list. Both automata operate over the common alphabet $\\Sigma$. A sequence of packets $w \\in \\Sigma^*$ is *allowed* if it is accepted by $N_A$ (i.e., $w \\in L(N_A)$), and it is *denied* if it is accepted by $N_D$ (i.e., $w \\in L(N_D)$).\n\nThe system is defined to be **\"Perfectly Resolved\"** if and only if for every conceivable sequence of packets $w \\in \\Sigma^*$, the sequence is *either* allowed *or* denied, but not both. In other words, every string in $\\Sigma^*$ must belong to exactly one of the languages $L(N_A)$ or $L(N_D)$.\n\nThe engineer needs to create a diagnostic tool to check if a given pair of rule-sets $\\langle N_A, N_D \\rangle$ is Perfectly Resolved. We define the corresponding decision problem as follows:\n`PERFECTLY_RESOLVED` = $\\{ \\langle N_A, N_D \\rangle \\mid \\text{The firewall system specified by NFAs } N_A \\text{ and } N_D \\text{ is Perfectly Resolved} \\}$.\n\nWhat is the computational complexity of the `PERFECTLY_RESOLVED` problem?\n\nA. It is in P.\nB. It is NP-complete.\nC. It is coNP-complete.\nD. It is PSPACE-complete.\nE. It is in EXPTIME but not known to be in PSPACE.\nF. It is undecidable.",
            "solution": "The core of the problem is to determine the complexity class of the `PERFECTLY_RESOLVED` decision problem.\n\nFirst, we must translate the given English description of \"Perfectly Resolved\" into a precise statement in formal language theory. The condition states that for any string $w \\in \\Sigma^*$, it must be either in $L(N_A)$ or in $L(N_D)$, but not in both. This can be broken down into two conditions:\n1.  The union of the two languages must cover all possible strings: $L(N_A) \\cup L(N_D) = \\Sigma^*$.\n2.  The intersection of the two languages must be empty: $L(N_A) \\cap L(N_D) = \\emptyset$.\n\nThese two conditions together are equivalent to stating that the language $L(N_A)$ is the exact complement of the language $L(N_D)$, i.e., $L(N_A) = \\overline{L(N_D)}$. So, the problem `PERFECTLY_RESOLVED` is equivalent to the NFA complementarity problem.\n\nTo determine the complexity of this problem, we will show that it is PSPACE-complete. This requires a two-part proof:\n1.  `PERFECTLY_RESOLVED` is in PSPACE.\n2.  `PERFECTLY_RESOLVED` is PSPACE-hard.\n\n**Part 1: `PERFECTLY_RESOLVED` is in PSPACE**\n\nWe need to show that there exists a Turing machine that decides the problem using only a polynomial amount of space with respect to the input size $|\\langle N_A, N_D \\rangle|$. As established, we need to verify two properties: (a) $L(N_A) \\cap L(N_D) = \\emptyset$ and (b) $L(N_A) \\cup L(N_D) = \\Sigma^*$.\n\n**(a) Checking $L(N_A) \\cap L(N_D) = \\emptyset$:**\nThis subproblem asks if the intersection of two NFA languages is empty. We can use the standard product construction to create an NFA, let's call it $N_{intersect}$, that accepts the language $L(N_A) \\cap L(N_D)$. If $N_A$ has $n_A$ states and $N_D$ has $n_D$ states, $N_{intersect}$ will have $n_A \\times n_D$ states. The problem $L(N_{intersect}) = \\emptyset$ is equivalent to checking if there is no path from the start state of $N_{intersect}$ to any of its final states. This is a reachability problem on a graph with a polynomial number of vertices. Reachability can be solved nondeterministically in logarithmic space (NLOGSPACE) by guessing a path. Since NLOGSPACE $\\subseteq$ PSPACE, this check can be done in polynomial space.\n\n**(b) Checking $L(N_A) \\cup L(N_D) = \\Sigma^*$:**\nThis subproblem asks if the union of two NFA languages is universal. We can construct an NFA, $N_{union}$, that accepts $L(N_A) \\cup L(N_D)$. This can be done by creating a new start state with $\\epsilon$-transitions to the start states of $N_A$ and $N_D$. The resulting NFA, $N_{union}$, has $n_A + n_D + 1$ states. The problem then becomes checking if $L(N_{union}) = \\Sigma^*$. This is the universality problem for NFAs, commonly denoted as `ALL_NFA`.\n\nThe universality problem for NFAs is known to be in PSPACE. To show this, we can consider its complement: the non-universality problem, which asks \"Is $L(N_{union}) \\neq \\Sigma^*$?\". This is equivalent to asking \"Does there exist a string $w$ that is *not* accepted by $N_{union}$?\".\nTo solve this, we can try to find such a string $w$. A deterministic approach would be to convert $N_{union}$ to an equivalent Deterministic Finite Automaton (DFA) using the subset construction. This DFA can have up to $2^{n_A+n_D+1}$ states. We could then check this DFA for a non-accepting state reachable from the start state. However, explicitly constructing this DFA might require exponential space.\n\nInstead, we can use a nondeterministic polynomial-space algorithm. By Savitch's Theorem, NPSPACE = PSPACE. The NPSPACE algorithm for non-universality works as follows:\n- Nondeterministically guess a string $w \\in \\Sigma^*$ symbol by symbol.\n- After guessing each symbol, update the set of possible current states in $N_{union}$. This set can be stored in polynomial space (a bit-vector of length $n_A+n_D+1$).\n- If we ever process a string $w$ such that the resulting set of states contains no final states, we have found a string not in $L(N_{union})$, so we accept.\n- The shortest string not accepted by an $n$-state NFA (if one exists) has length less than $2^n$. We can use a counter (of size polynomial in $n$) to limit the length of the guessed string.\n\nSince the non-universality problem is in NPSPACE, it is in PSPACE. The universality problem (`ALL_NFA`) is the complement of a PSPACE problem, and PSPACE is closed under complement, so `ALL_NFA` is also in PSPACE.\n\nSince both checks (a) and (b) can be performed in polynomial space, a PSPACE machine can run them sequentially to decide `PERFECTLY_RESOLVED`. Thus, `PERFECTLY_RESOLVED` is in PSPACE.\n\n**Part 2: `PERFECTLY_RESOLVED` is PSPACE-hard**\n\nTo prove PSPACE-hardness, we will perform a polynomial-time reduction from a known PSPACE-hard problem. We will use the `ALL_NFA` problem itself, which is known to be PSPACE-complete.\nThe `ALL_NFA` problem is: Given an NFA $N$, is $L(N) = \\Sigma^*$?\n\nLet's construct a reduction from an arbitrary instance of `ALL_NFA` to an instance of `PERFECTLY_RESOLVED`.\nGiven an NFA $N$ over alphabet $\\Sigma$, which is the input to `ALL_NFA`. We must construct a pair of NFAs, $\\langle N_A, N_D \\rangle$, in polynomial time, such that this pair is a 'yes' instance of `PERFECTLY_RESOLVED` if and only if $N$ is a 'yes' instance of `ALL_NFA`.\n\nThe reduction is as follows:\n1.  Set $N_A = N$.\n2.  Construct an NFA $N_D$ that accepts the empty language, $L(N_D) = \\emptyset$. A simple way to do this is to create an NFA with a single state that is the start state but not a final state, and has no transitions. Let's call this automaton $N_{\\emptyset}$.\n\nThis construction takes constant (and thus polynomial) time.\n\nNow, we must show the correctness of the reduction. The instance $\\langle N_A, N_D \\rangle = \\langle N, N_{\\emptyset} \\rangle$ is in `PERFECTLY_RESOLVED` if and only if the following chain of equivalences holds: $L(N_A) = \\overline{L(N_D)} \\iff L(N) = \\overline{L(N_{\\emptyset})} \\iff L(N) = \\Sigma^*$.\n\nThis final condition, $L(N) = \\Sigma^*$, is precisely the condition for the original instance $\\langle N \\rangle$ to be in `ALL_NFA`. Thus, we have a polynomial-time reduction $\\text{ALL\\_NFA} \\le_p \\text{PERFECTLY\\_RESOLVED}$. Since `ALL_NFA` is PSPACE-hard, `PERFECTLY_RESOLVED` must also be PSPACE-hard.\n\n**Conclusion**\n\nWe have shown that `PERFECTLY_RESOLVED` is in PSPACE and that it is PSPACE-hard. Therefore, the `PERFECTLY_RESOLVED` problem is PSPACE-complete. This corresponds to option D.",
            "answer": "$$\\boxed{D}$$"
        }
    ]
}