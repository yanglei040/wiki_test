{
    "hands_on_practices": [
        {
            "introduction": "The Immerman–Szelepcsényi theorem is built upon a clever technique called inductive counting. To master this concept, we will begin with a direct, hands-on calculation. This exercise  asks you to trace the core iterative step of the process in a practical scenario, calculating the growing set of nodes from which a target is reachable.",
            "id": "1458177",
            "problem": "In a large distributed system, a set of $N$ microservices, labeled consecutively from 1 to $N$, interact with each other. These interactions are described by a directed graph $G = (V, E)$, where $V = \\{1, 2, \\dots, N\\}$ represents the services and a directed edge $(u, v) \\in E$ means that service $u$ makes network calls to service $v$.\n\nA critical failure is detected in a specific target service, $t$. The engineering team suspects a bug that could have originated in any service $u$ from which there is a path of service calls to $t$. To identify all potentially faulty services, they employ an analysis based on the principle of inductive counting, which is central to the proof of the Immerman–Szelepcsényi theorem.\n\nLet $B_i(t)$ be the set of services from which service $t$ is reachable by a path of length at most $i$. Let $k_i = |B_i(t)|$ be the number of such services. The team's automated analysis tool has already computed the value of $k_i$ for a few initial steps.\n\nGiven the following system configuration:\n- The total number of services, $N = 8$.\n- The target service where the failure was observed, $t = 8$.\n- The set of all communication pathways (edges) is:\n  $E = \\{(1, 3), (2, 3), (3, 5), (4, 5), (4, 6), (5, 7), (6, 7), (7, 8)\\}$.\n- The known count of services from which $t$ is reachable in at most $i=2$ steps is $k_2 = 4$.\n\nCalculate the number of services from which service $t=8$ is reachable in at most $i=3$ steps. In other words, determine the value of $k_3$.",
            "solution": "We are given a directed graph $G=(V,E)$ with $V=\\{1,2,\\dots,8\\}$, target node $t=8$, and edges $E=\\{(1,3),(2,3),(3,5),(4,5),(4,6),(5,7),(6,7),(7,8)\\}$. For each integer $i\\geq 0$, define $B_{i}(t)$ as the set of nodes from which $t$ is reachable by a directed path of length at most $i$, and let $k_{i}=|B_{i}(t)|$. The inductive step used in inductive counting is:\n$$\nB_{i+1}(t)\\;=\\;B_{i}(t)\\;\\cup\\;\\{\\,u\\in V:\\exists\\,(u,v)\\in E\\text{ with }v\\in B_{i}(t)\\,\\}.\n$$\nWe also use that $B_{0}(t)=\\{t\\}$ (reachability by a path of length $0$ is from $t$ to itself). We verify the given $k_{2}=4$ and then compute $k_{3}$.\n\nFirst, compute $B_{0}(t)$:\n$$\nB_{0}(t)=\\{8\\}.\n$$\n\nNext, compute $B_{1}(t)$ by adding all in-neighbors of $8$:\nthe only edge into $8$ is $(7,8)$, so\n$$\nB_{1}(t)=B_{0}(t)\\cup\\{7\\}=\\{8,7\\},\n\\quad k_{1}=2.\n$$\n\nThen, compute $B_{2}(t)$ by adding all in-neighbors of nodes in $B_{1}(t)$.\nThe in-neighbors of $7$ are $5$ and $6$, and the in-neighbor of $8$ is $7$ which is already included. Hence\n$$\nB_{2}(t)=\\{8,7,5,6\\},\n\\quad k_{2}=4,\n$$\nwhich matches the given value.\n\nNow compute $B_{3}(t)$ by adding all in-neighbors of nodes in $B_{2}(t)$.\nThe in-neighbors are:\n- for $5$: nodes $3$ and $4$ via edges $(3,5)$ and $(4,5)$,\n- for $6$: node $4$ via $(4,6)$,\n- for $7$: nodes $5$ and $6$ via $(5,7)$ and $(6,7)$ (already in $B_{2}(t)$),\n- for $8$: node $7$ via $(7,8)$ (already in $B_{2}(t)$).\nThus the only new additions are $3$ and $4$, giving\n$$\nB_{3}(t)=\\{8,7,5,6,3,4\\},\n\\quad k_{3}=|B_{3}(t)|=6.\n$$\n\nTherefore, the number of services from which $t=8$ is reachable in at most $3$ steps is $k_{3}=6$.",
            "answer": "$$\\boxed{6}$$"
        },
        {
            "introduction": "Inductive counting successfully tracks the size of a growing set of reachable states. However, it is crucial to understand what exactly is being counted. This practice  contrasts a correct state-counting algorithm with a flawed path-counting one to highlight why the method works for set membership but fails for path enumeration, a common point of confusion.",
            "id": "1458156",
            "problem": "An engineer is designing two simple, iterative algorithms to analyze a small communication network. The network is modeled as a directed graph `G` with a set of vertices `V = {A, B, C, D}` and a set of edges `E = {(A, B), (A, C), (B, D), (C, D)}`. The vertex `A` is the designated starting point for all analyses. Let `n=4` be the number of vertices in the graph. The engineer needs you to determine the output of two different algorithms.\n\n**Algorithm 1: `ComputeReachableSetSize`**\n\nThis algorithm correctly calculates the total number of unique vertices reachable from the start vertex `A`. It works by iteratively expanding a set of reachable vertices.\n\n1.  Initialize a set of vertices, `R`, with the starting vertex: `R = {A}`.\n2.  Repeat `n` times:\n    a. Create a temporary set, `N`, containing all vertices `v` for which there exists an edge `(u, v)` in `E`, where `u` is a vertex currently in the set `R`.\n    b. Update the set `R` by taking the union with the temporary set: `R = R \\cup N`.\n3.  The final output of this algorithm is the size (cardinality) of the final set `R`.\n\n**Algorithm 2: `NaivePathAggregator`**\n\nThis algorithm represents a flawed attempt to count paths. It is intended to aggregate counts for paths from `A`, but its logic is bugged. It incorrectly mixes the logic of tracking reachable nodes with path counting.\n\n1.  Initialize a set of \"explored\" vertices, `S = {A}`.\n2.  Initialize a mapping (e.g., a dictionary), `P`, to store counts for each vertex. Set `P[A] = 1` and `P[v] = 0` for all other vertices `v` in `V`.\n3.  Repeat `n` times:\n    a. Create a temporary set of \"newly reached\" vertices, `T`, initialized to be empty.\n    b. For each vertex `u` currently in the set `S`:\n        i. For each edge `(u, v)` in `E` that starts at `u`:\n            - Add the destination vertex `v` to the set `T`.\n            - Increment the path count for `v`: `P[v] = P[v] + 1`.\n    c. Update the set of explored vertices by taking the union: `S = S \\cup T`.\n4.  The final output of this algorithm is the count stored for the vertex `D`, i.e., the value `P[D]`.\n\nYour task is to trace the execution of both algorithms on the given graph `G`. What are the final output values for `ComputeReachableSetSize` and `NaivePathAggregator`, respectively? Present your answer as a row matrix `[Result1, Result2]`, where `Result1` is the output of the first algorithm and `Result2` is the output of the second.",
            "solution": "We are given a directed graph with $V=\\{A,B,C,D\\}$ and $E=\\{(A,B),(A,C),(B,D),(C,D)\\}$, start vertex $A$, and $n=4$ iterations for both algorithms.\n\nFor Algorithm 1 (ComputeReachableSetSize), initialize $R_{0}=\\{A\\}$. At each iteration $i$, compute $N_{i}=\\{v\\mid \\exists u\\in R_{i-1}:(u,v)\\in E\\}$ and then update $R_{i}=R_{i-1}\\cup N_{i}$.\nIteration 1: $R_{0}=\\{A\\}$. From $A$ there are edges to $B$ and $C$, so $N_{1}=\\{B,C\\}$ and $R_{1}=\\{A,B,C\\}$.\nIteration 2: $R_{1}=\\{A,B,C\\}$. From $A$ we get $B,C$, from $B$ we get $D$, from $C$ we get $D$, hence $N_{2}=\\{B,C,D\\}$ and $R_{2}=\\{A,B,C,D\\}$.\nIteration 3: $R_{2}=\\{A,B,C,D\\}$. The outgoing edges from $A,B,C$ again yield $N_{3}=\\{B,C,D\\}$ and $R_{3}=\\{A,B,C,D\\}$.\nIteration 4: the same pattern gives $N_{4}=\\{B,C,D\\}$ and $R_{4}=\\{A,B,C,D\\}$.\nTherefore, the final output is $|R_{4}|=4$.\n\nFor Algorithm 2 (NaivePathAggregator), initialize $S_{0}=\\{A\\}$ and path counts $P_{0}[A]=1$, $P_{0}[B]=0$, $P_{0}[C]=0$, $P_{0}[D]=0$. At each iteration $i$, start with $T_{i}=\\varnothing$, then for each $u\\in S_{i-1}$ and each $(u,v)\\in E$, add $v$ to $T_{i}$ and increment $P[v]$ by $1$, and finally set $S_{i}=S_{i-1}\\cup T_{i}$.\nIteration 1: $S_{0}=\\{A\\}$. Processing $A$ via $(A,B)$ and $(A,C)$ yields $T_{1}=\\{B,C\\}$, $P[B]=1$, $P[C]=1$, $P[D]=0$. Update $S_{1}=\\{A,B,C\\}$.\nIteration 2: $S_{1}=\\{A,B,C\\}$. Processing $A$ adds $1$ to each of $P[B],P[C]$; processing $B$ via $(B,D)$ adds $1$ to $P[D]$; processing $C$ via $(C,D)$ adds another $1$ to $P[D]$. Thus $P[B]=2$, $P[C]=2$, $P[D]=2$, and $T_{2}=\\{B,C,D\\}$, so $S_{2}=\\{A,B,C,D\\}$.\nIteration 3: $S_{2}=\\{A,B,C,D\\}$. Processing $A$ adds $1$ to each of $P[B],P[C]$; processing $B$ adds $1$ to $P[D]$; processing $C$ adds another $1$ to $P[D]$; $D$ has no outgoing edges. Thus $P[B]=3$, $P[C]=3$, $P[D]=4$, with $S_{3}=\\{A,B,C,D\\}$.\nIteration 4: the same updates apply, yielding $P[B]=4$, $P[C]=4$, $P[D]=6$, and $S_{4}=\\{A,B,C,D\\}$.\nTherefore, the final output of Algorithm 2 is $P[D]=6$.\n\nThe required row matrix of results is $\\begin{pmatrix}4  6\\end{pmatrix}$.",
            "answer": "$$\\boxed{\\begin{pmatrix}4  6\\end{pmatrix}}$$"
        },
        {
            "introduction": "Every powerful technique has its limits, and understanding these boundaries is key to true mastery. This final exercise  explores why the inductive counting method cannot be easily adapted to solve problems like UNIQUE-REACHABILITY. By examining this failure case, you will uncover the fundamental requirement of monotonicity that underpins the entire Immerman–Szelepcsényi proof.",
            "id": "1458213",
            "problem": "In computational complexity theory, the Immerman–Szelepcsényi theorem establishes that the class NL (Nondeterministic Logarithmic-space) is closed under complement, meaning NL = co-NL. A cornerstone of this proof is a method called \"inductive counting\" used to show that the complement of the REACHABILITY problem is in NL.\n\nLet $G=(V, E)$ be a directed graph, and let $s, t \\in V$ be two distinct vertices.\nThe REACHABILITY problem asks: Is there at least one path from $s$ to $t$?\nThe complement, NON-REACHABILITY, asks: Are there no paths from $s$ to $t$?\n\nThe inductive counting algorithm for NON-REACHABILITY works by computing $N$, the total number of vertices reachable from $s$. It does this by iteratively computing $N_i$, the number of vertices reachable from $s$ in at most $i$ steps, for $i = 0, 1, \\dots, |V|-1$. The crucial step is computing $N_{i+1}$ using the already computed value of $N_i$. This is possible because the set of reachable vertices is monotonic: any vertex reachable in $\\le i$ steps is also reachable in $\\le i+1$ steps. This monotonicity allows using the count $N_i$ to certify that a nondeterministic search has found all vertices reachable in $\\le i$ steps, which is then used to identify all vertices reachable in $\\le i+1$ steps.\n\nNow, consider a related problem called UNIQUE-REACHABILITY: Is there exactly one simple path from $s$ to $t$?\n\nSuppose one attempts to adapt the inductive counting methodology to solve UNIQUE-REACHABILITY. A natural approach would be to define $U_i$ as the set of vertices $v$ for which there is exactly one simple path from $s$ to $v$ of length at most $i$, and then try to inductively compute the size $|U_i|$.\n\nWhich of the following statements best explains why the core logic of the inductive counting method, as used in the Immerman–Szelepcsényi proof, fails when applied to UNIQUE-REACHABILITY?\n\nA. The property of having a unique path is not monotonic. A vertex with a unique path of length at most $i$ might have multiple paths when considering paths of length up to $i+1$. This loss of monotonicity breaks the certification mechanism of the inductive count.\n\nB. The total number of paths between two vertices can be exponential in the number of vertices. A logarithmic-space counter is insufficient to store the number of paths required for the calculation.\n\nC. The inductive counting method is inherently nondeterministic, whereas determining the exact number of paths (to check if it is one) is a deterministic process that cannot be simulated in NL.\n\nD. The problem UNIQUE-REACHABILITY is known to be US-hard (Unique Satisfiability hard), a class believed to be strictly harder than NL, meaning no NL algorithm could solve it.\n\nE. The algorithm would need to enumerate and compare all paths of a certain length, which requires storing full path descriptions. This exceeds the logarithmic space bound.",
            "solution": "We recall the inductive counting framework used in the Immerman–Szelepcsényi theorem. For REACHABILITY, define $R_{i}=\\{v \\in V : \\text{$v$ is reachable from $s$ by a path of length at most $i$}\\}$. The key property is monotonicity:\n$$\nR_{0} \\subseteq R_{1} \\subseteq \\dots \\subseteq R_{|V|-1}.\n$$\nThis monotonicity implies that once a vertex enters $R_{i}$, it stays in all $R_{j}$ for $j \\geq i$, and hence $|R_{i}|$ is nondecreasing in $i$. The inductive counting method uses this to certify completeness: a nondeterministic procedure can propose the set of vertices reachable within $i$ steps and verify its size against a running count $N_{i}=\\lvert R_{i}\\rvert$, which then allows updating to $N_{i+1}$ by only accounting for newly added vertices. No previously counted vertices ever need to be removed.\n\nFor UNIQUE-REACHABILITY, define\n$$\nU_{i}=\\{v \\in V : \\text{there is exactly one simple path from $s$ to $v$ of length at most $i$}\\}.\n$$\nThe analogous monotonicity fails. Concretely, there exist graphs and indices $i$ with a vertex $v$ such that $v \\in U_{i}$ but $v \\notin U_{i+1}$. For example, consider a graph with paths $s \\to a \\to v$ (length $2$) and $s \\to b \\to c \\to v$ (length $3$). Then for $i=2$, $v$ has exactly one simple path from $s$ of length at most $2$, so $v \\in U_{2}$. For $i=3$, $v$ has two simple paths of length at most $3$, hence $v \\notin U_{3}$. Therefore,\n$$\nU_{i} \\nsubseteq U_{i+1}\n$$\nin general, and the sequence $\\lvert U_{i}\\rvert$ is not guaranteed to be nondecreasing.\n\nBecause elements can leave $U_{i}$ as $i$ increases, the certification mechanism that underlies inductive counting breaks: one cannot maintain a correct inductive tally by only “adding” newly discovered vertices, since some previously counted vertices must be “removed” once longer alternative paths appear. The Immerman–Szelepcsényi method fundamentally relies on monotonic growth of the certified set to validate counts in logarithmic space via nondeterminism. Without monotonicity, the nondeterministic verification that a guessed set is complete (and that the count is correct) cannot be carried out in the same way.\n\nThus the core reason the method fails for UNIQUE-REACHABILITY is precisely the loss of monotonicity of the defining property when increasing the path-length bound. This matches statement A. The other options either cite unrelated resource issues, incorrect claims about determinism versus nondeterminism, unproven separations, or unnecessary enumeration requirements, none of which directly target the failure of the inductive counting logic.",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}