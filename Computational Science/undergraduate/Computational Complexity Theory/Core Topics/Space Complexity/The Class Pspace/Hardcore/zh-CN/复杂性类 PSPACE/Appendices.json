{
    "hands_on_practices": [
        {
            "introduction": "理解任何一个复杂性类的基本方法是检验其闭包性质——也就是说，对该类中的语言应用标准运算后，产生的新语言是否仍然属于该类。第一个实践邀请你从算法角度思考如何证明 PSPACE 在串接运算下是封闭的。通过设计一台空间高效的图灵机，你将练习复用空间的核心技巧，这是解决 PSPACE 中问题的基础技能 。",
            "id": "1454902",
            "problem": "在计算复杂性理论中，一个复杂性类是一组可以在特定资源限制下由某个计算模型解决的问题的集合。PSPACE（多项式空间）类包含所有可以由确定性图灵机在相对于输入大小的多项式空间内解决的判定问题。\n\n设 $L_1$ 和 $L_2$ 是两个语言，分别由确定性图灵机 $M_1$ 和 $M_2$ 在以多项式 $p_1(n)$ 和 $p_2(n)$为界的空间内判定，其中 n 是输入字符串的长度。因此，根据定义，$L_1 \\in \\text{PSPACE}$ 且 $L_2 \\in \\text{PSPACE}$。\n\n这两个语言的串接，记作 $L = L_1 \\circ L_2$，定义为所有可以通过将 $L_1$ 中的字符串 $x$ 与 $L_2$ 中的字符串 $y$ 串接而形成的字符串 $w$ 的集合。即，$L = \\{xy \\mid x \\in L_1 \\text{ and } y \\in L_2\\}$。\n\n我们希望证明 PSPACE 类在串接运算下是封闭的，即如果 $L_1, L_2 \\in \\text{PSPACE}$，那么 $L_1 \\circ L_2 \\in \\text{PSPACE}$。这需要构建一台图灵机 $M$，它仅使用多项式大小的空间来判定 $L_1 \\circ L_2$。\n\n给定一个长度为 n 的输入字符串 w，以下哪个选项描述了一个正确的、高层次的算法，供确定性图灵机 M 在仅使用多项式空间的情况下判定 w 是否属于 L？\n\nA. 机器 M 首先枚举并将其带上存储所有长度不超过 n 的 $L_1$ 中的字符串。然后它枚举并存储所有长度不超过 n 的 $L_2$ 中的字符串。最后，对于每个存储的来自 $L_1$ 的字符串 $x$ 和来自 $L_2$ 的字符串 $y$，它检查它们的串接 $xy$ 是否等于输入 $w$。如果找到匹配项，则接受；否则，拒绝。\n\nB. 机器 M 系统地尝试将输入字符串 w 分割成两个非空部分 $w = xy$ 的所有可能方式。对于每一种分割，M 首先在前缀 x 上模拟机器 $M_1$。如果 $M_1$ 接受，M 清空其工作带，然后在后缀 y 上模拟机器 $M_2$。如果 $M_2$ 也接受，机器 M 停机并接受。如果检查了所有可能的分割，但没有一个导致两个模拟都接受，则 M 停机并拒绝。\n\nC. 机器 M 将输入字符串 w 精确地分成两半，一个前缀 x 和一个后缀 y。然后它使用一个双带图灵机，在第一条带上对 x 模拟 $M_1$，在第二条带上对 y 模拟 $M_2$。如果两个模拟都接受，M 就接受。否则，M 拒绝。\n\nD. 由于语言 $L_1$ 和 $L_2$ 可能是无限的，因此不可能检查所有可能的对 $(x, y)$ 以查看它们的串接是否构成 w。因此，判定 $L_1 \\circ L_2$ 成员资格的问题是不可判定的，并且不存在这样的图灵机 M。",
            "solution": "给定 $L_{1},L_{2} \\in \\text{PSPACE}$，其确定性判定器 $M_{1}$ 和 $M_{2}$ 在长度为 n 的输入上分别使用至多 $p_{1}(n)$ 和 $p_{2}(n)$ 的空间。对于长度为 n 的 $w \\in \\Sigma^{*}$，$w \\in L_{1} \\circ L_{2}$ 当且仅当存在一个索引 $i$（$0 \\leq i \\leq n$），使得前缀 $x = w[1..i] \\in L_{1}$ 且后缀 $y = w[i+1..n] \\in L_{2}$。一个确定性机器 M 可以通过迭代所有分割点 i 并分别在 x 上模拟 $M_{1}$ 和在 y 上模拟 $M_{2}$ 来判定这个问题。\n\n空间分析：定义 $p(n) = \\max\\{p_{1}(n),p_{2}(n)\\}$。对于一个固定的分割点 i，有 $|x| = i \\leq n$ 和 $|y| = n - i \\leq n$，因此模拟过程使用的空间至多为 $p_{1}(i) \\leq p_{1}(n) \\leq p(n)$ 和 $p_{2}(n-i) \\leq p_{2}(n) \\leq p(n)$。由于 M 首先在 x 上模拟 $M_1$，并且仅当 $M_1$ 接受时，才清空其工作带并在 y 上模拟 $M_2$，所以使用的峰值空间至多为 $p(n)$ 加上管理分割和模拟所需的开销。为了将 x 和 y 提供给模拟器，M 可以：\n- 将输入保留在只读带上，并维护一个用于分割索引 i 的计数器，将被模拟机器试图读取超过指定末端的尝试解释为空白；该计数器使用 $O(\\log n)$ 的空间；或者\n- 在每次模拟前将相关的子字符串复制到工作带上，这使用 $O(n)$ 的空间。\n\n在两种情况下，每次分割的总空间都受\n$$\nq(n) = p(n) + O(n)\n$$\n的限制，这是 n 的一个多项式。对所有 $i \\in \\{0,1,\\dots,n\\}$ 的循环是顺序执行的，因此空间不会在迭代之间累积；只有时间可能会爆炸式增长，但这不影响 PSPACE 的成员资格。因此，这个过程在多项式空间内判定了 $L_{1} \\circ L_{2}$，从而证明了 PSPACE 在串接运算下是封闭的。\n\n评估选项：\n- A 存储了所有长度不超过 n 的来自 $L_{1}$ 和 $L_{2}$ 的字符串，这需要关于 n 的指数级空间，所以它不是多项式空间的。\n- B 描述了标准的多项式空间过程：尝试每个分割，在前缀上模拟 $M_1$，如果接受，则清空工作带后在后缀上模拟 $M_2$。如前所述，这最多使用 $q(n)$ 的空间。为了精确覆盖定义 $L_{1} \\circ L_{2} = \\{xy : x \\in L_{1}, y \\in L_{2}\\}$ 的所有情况，也应该包括 $i=0$ 和 $i=n$ 的分割；这是一个简单的调整，不会改变空间界限。\n- C 仅检查了在 $i = \\lfloor n/2 \\rfloor$ 处的分割，这是不够的，因为有效的分解可能在任何 i 处发生。\n- D 是错误的：$L_{1} \\circ L_{2}$ 的成员资格问题可以通过上述算法在多项式空间内判定。\n\n因此，正确的高层次算法是 B。",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "在简单的空间复用基础上，我们现在探索一个更强大的算法范式：分而治之。这个问题提出了一个可达性谜题，可以通过一种反映了萨维奇定理（Savitch's Theorem）逻辑的递归方法来有效解决。通过分析这个递归算法的空间复杂度，你将亲身体会到 PSPACE 如何通过递归地分解问题来解决它们，以及如何在不一次性存储整个搜索空间的情况下遍历它 。",
            "id": "1454887",
            "problem": "考虑一个被称为“$n$位配置锁”的计算系统。在此系统中，一个“配置”是一个$n$位二进制字符串，可以解释为从$0$到$2^n - 1$的整数。该系统以离散的时间步演化。从任何给定的配置$C$，它可以通过两种可能的非确定性操作之一，在单一步骤内转换到一个新的配置$C'$。这些操作是基于配置字符串$C$的整数值$v$定义的：\n\n1.  操作A：新配置的整数值为 $v' = (3v + 1) \\pmod{2^n}$。\n2.  操作B：新配置的整数值为 $v' = (5v + 1) \\pmod{2^n}$。\n\n我们关心的是可达性问题：一个起始配置$C_{start}$能否在恰好$k$步内到达一个目标配置$C_{target}$？\n\n提出了一个名为`CanReach(C_1, C_2, t)`的递归算法来解决这个问题。它确定配置$C_2$是否能在恰好$t$步内从$C_1$到达。该算法的逻辑如下：\n\n-   **基本情况：**如果$t=1$，函数检查是否可以使用操作A或操作B在单一步骤内从$C_1$到达$C_2$。如果存在有效的转换，则返回`True`，否则返回`False`。\n-   **递归步骤：**如果$t > 1$，函数会遍历所有$2^n$个可能的配置作为中间状态`C_mid`。对于每个`C_mid`，它通过进行两次独立的递归调用来检查`C_mid`是否能在$\\lfloor t/2 \\rfloor$步内从$C_1$到达，并且$C_2$是否能在$\\lceil t/2 \\rceil$步内从`C_mid`到达。如果对于任何`C_mid`，两次调用都返回`True`，则函数立即返回`True`。如果循环结束仍未找到这样的`C_mid`，则函数返回`False`。\n\n你的任务是分析这个算法的空间复杂度。初始调用为`CanReach(C_{start}, C_{target}, 2^n)`。假设存储一个$n$位配置需要与$n$成正比的空间，存储整数步数$t$（其大小可达$2^n$）也需要与$n$成正比的空间。递归栈所需的总空间可以用大O表示法写成$O(f(n))$，其中$f(n)$是某个函数。确定这个函数$f(n)$。",
            "solution": "我们分析函数调用树的递归栈空间。每个激活记录（栈帧）必须存储其参数和循环状态：\n- 每个配置参数$C_{1}$和$C_{2}$需要与$n$成正比的空间，即$c_{1} n$和$c_{2} n$，其中$c_{1}, c_{2}$为固定的正常数。\n- 步数$t$最大可达$2^{n}$，需要与$n$成正比的空间，比如$c_{3} n$。\n- 循环遍历所有$2^{n}$个可能的$C_{\\text{mid}}$，但在任何时刻只存储当前的$C_{\\text{mid}}$，这需要与$n$成正比的空间，比如$c_{4} n$。\n- 任何额外的控制或常数大小的状态为$O(1)$，并被包含在一个常数$c_{5}$中。\n\n因此，每个栈帧的空间满足\n$$\ns(n) \\leq (c_{1}+c_{2}+c_{3}+c_{4})\\,n + c_{5} = a\\,n + c_{5}, \n$$\n对于某个常数$a>0$，因此$s(n)=\\Theta(n)$。\n\n接下来，我们确定最大递归深度。令$D(t)$表示输入步数为$t$时的最大深度。基本情况使用一个栈帧，所以$D(1)=1$。对于$t>1$，函数进行两次递归调用，步数分别为$\\lfloor t/2 \\rfloor$和$\\lceil t/2 \\rceil$，但它们是顺序执行的（第二次调用仅在第一次调用返回后才进行）。因此，任何时候的最大栈深度为\n$$\nD(t) = 1 + \\max\\!\\big(D(\\lfloor t/2 \\rfloor),\\, D(\\lceil t/2 \\rceil)\\big) \\leq 1 + D(\\lceil t/2 \\rceil).\n$$\n通过重复减半，经过$m$次这样的步骤后，参数大小至多为$\\lceil t/2^{m} \\rceil$。当此值变为$1$时递归停止，这发生在满足$t \\leq 2^{m}$的最小$m$处，即$m=\\lceil \\log_{2} t \\rceil$。因此\n$$\nD(t) \\leq \\lceil \\log_{2} t \\rceil + 1.\n$$\n\n初始调用的$t=2^{n}$，所以\n$$\nD(2^{n}) \\leq \\lceil \\log_{2}(2^{n}) \\rceil + 1 = n + 1 = \\Theta(n).\n$$\n\n递归栈的总空间是最大深度与每帧空间的乘积：\n$$\nS(n) \\leq D(2^{n}) \\cdot s(n) \\leq (n+1)\\,(a n + c_{5}) = a n^{2} + (a + c_{5}) n + c_{5}.\n$$\n因此$S(n) = O(n^{2})$。由于$S(n)$表示为$O(f(n))$，我们得出结论$f(n) = n^{2}$。",
            "answer": "$$\\boxed{n^{2}}$$"
        },
        {
            "introduction": "多项式空间的能力不仅限于简单的判定问题，还延伸到某些类型的计数问题，而这些问题通常被认为非常困难。最后一个实践通过要求你追踪一个递归算法来深入探讨这一迷人的联系，该算法计算一个 2-CNF 公式模 3 的满足解数量。这个练习展示了如何通过对解空间树进行深度优先搜索——一种经典的 PSPACE 技术——来解决位于判定和计数复杂性交叉点上的问题 。",
            "id": "1454907",
            "problem": "计算复杂性理论中的一个核心问题是计算给定问题的解的数量，这通常用前缀 # 来表示（例如，#SAT）。虽然为 2-合取范式 (2-CNF) 公式找到一个单一的可满足赋值是可以在多项式时间内求解的，但计算所有这类赋值的数量（#2-SAT）是 #P-完全的，因此被认为是难解的。\n\n本问题探讨一个相关的问题：确定可满足赋值的数量对一个小整数（具体为 3）取模的结果。给定一个包含 $n$ 个变量 $\\{x_1, x_2, \\dots, x_n\\}$ 集合的布尔公式。一个文字是一个变量 $x_i$ 或其否定 $\\neg x_i$。一个 2-CNF 公式是多个子句的合取（AND，用 $\\land$ 表示），其中每个子句是最多两个文字的析取（OR，用 $\\lor$ 表示）。一个可满足赋值是将变量映射到 {True, False}，使得整个公式为真的指派。\n\n考虑以下递归算法 `CountMod3(ψ, k, n)`，它计算公式 $\\psi$ 的可满足赋值数量模 3 的值。假设 $\\psi$ 中的变量是 $\\{x_k, x_{k+1}, \\dots, x_n\\}$ 的一个子集。\n\n**算法 `CountMod3(ψ, k, n)`：**\n\n1.  **基准情形（不可满足）：** 如果公式 $\\psi$ 被确定为不可满足，则返回 0。如果一个公式包含一个空子句 `()`，那么它就是不可满足的。空子句可能由替换简化一个单元子句（如 `(x_i)`）为 `(False)` 而产生。\n2.  **基准情形（重言式）：** 如果公式 $\\psi$ 不包含任何子句，那么它对于剩余变量 $\\{x_k, \\dots, x_n\\}$ 的任何赋值都是满足的。此类赋值的数量为 $2^{n-k+1}$。函数应返回 $2^{n-k+1} \\pmod 3$。\n3.  **递归步骤：** 如果两个基准情形都不满足，选择变量 $x_k$：\n    a.  通过代入 $x_k = \\text{False}$ 从 $\\psi$ 构建公式 $\\psi_0$。这包括将所有文字 $x_k$ 的实例替换为 False，并将 $\\neg x_k$ 替换为 True。然后对结果公式进行简化：\n        - 任何包含 True 的子句（例如 `(True ∨ l)`）被移除。\n        - 在任何子句中，任何 False 的实例被移除（例如 `(False ∨ l)` 变为 `(l)`）。\n    b.  递归计算 $c_0 = \\text{CountMod3}(\\psi_0, k+1, n)$。\n    c.  通过代入 $x_k = \\text{True}$ 并以类似的方式进行简化，从 $\\psi$ 构建公式 $\\psi_1$。\n    d.  递归计算 $c_1 = \\text{CountMod3}(\\psi_1, k+1, n)$。\n    e.  返回 $(c_0 + c_1) \\pmod 3$。\n\n给定以下包含 $n=4$ 个变量 $\\{x_1, x_2, x_3, x_4\\}$ 的 2-CNF 公式 $\\phi$：\n$$ \\phi = (\\neg x_1 \\lor x_2) \\land (\\neg x_2 \\lor x_3) \\land (\\neg x_3 \\lor x_4) \\land (\\neg x_4 \\lor \\neg x_1) \\land (x_1 \\lor x_3) $$\n\n确定初始调用 `CountMod3(φ, 1, 4)` 返回的值。",
            "solution": "我们对 $\\phi=(\\neg x_{1}\\lor x_{2})\\land(\\neg x_{2}\\lor x_{3})\\land(\\neg x_{3}\\lor x_{4})\\land(\\neg x_{4}\\lor \\neg x_{1})\\land(x_{1}\\lor x_{3})$ 应用 CountMod3，其中 $(k,n)=(1,4)$。该公式既不是不可满足的，也不是空的，所以我们对 $x_{1}$ 进行分支。\n\n情况 $x_{1}=\\text{False}$：代入 $x_{1}=\\text{False}$，因此 $\\neg x_{1}=\\text{True}$。子句简化如下：\n- $(\\neg x_{1}\\lor x_{2})\\to(\\text{True}\\lor x_{2})$，结果为 $\\text{True}$，被移除。\n- $(\\neg x_{2}\\lor x_{3})$ 不变。\n- $(\\neg x_{3}\\lor x_{4})$ 不变。\n- $(\\neg x_{4}\\lor \\neg x_{1})\\to(\\neg x_{4}\\lor \\text{True})$，结果为 $\\text{True}$，被移除。\n- $(x_{1}\\lor x_{3})\\to(\\text{False}\\lor x_{3})$，成为单元子句 $(x_{3})$。\n因此 $\\psi_{0}=(\\neg x_{2}\\lor x_{3})\\land(\\neg x_{3}\\lor x_{4})\\land(x_{3})$，我们调用 CountMod3$(\\psi_{0},2,4)$ 并对 $x_{2}$ 进行分支。\n\n子情况 $x_{2}=\\text{False}$：在 $\\psi_{0}$ 中，$(\\neg x_{2}\\lor x_{3})\\to(\\text{True}\\lor x_{3})$ 结果为 $\\text{True}$ 并被移除；其余部分保留，得到 $\\psi_{00}=(\\neg x_{3}\\lor x_{4})\\land(x_{3})$。对 $x_3$ 进行分支：\n- $x_{3}=\\text{False}$ 使得单元子句 $(x_{3})$ 变为 $\\text{False}$，即一个空子句，所以该分支不可满足并返回 $0$。\n- $x_{3}=\\text{True}$ 得到 $(\\neg x_{3}\\lor x_{4})\\to(\\text{False}\\lor x_{4})=(x_{4})$ 并移除 $(x_{3})$，所以我们得到 $\\psi_{000}=(x_{4})$。对 $x_{4}$ 进行分支：\n  - $x_{4}=\\text{False}$ 产生一个空子句，返回 $0$。\n  - $x_{4}=\\text{True}$ 移除该子句，不留下任何子句；重言式基准情形返回 $2^{n-(k+1)+1}=2^{4-5+1}=2^{0}=1$ 模 $3$ 的值，即 $1$。\n因此 $x_{2}=\\text{False}$ 子情况贡献了 $0+1=1$。\n\n子情况 $x_{2}=\\text{True}$：$(\\neg x_{2}\\lor x_{3})\\to(\\text{False}\\lor x_{3})=(x_{3})$，所以 $\\psi_{01}=(x_{3})\\land(\\neg x_{3}\\lor x_{4})\\land(x_{3})$。对 $x_3$ 进行分支：\n- $x_{3}=\\text{False}$ 从 $(x_{3})$ 得到一个空子句，返回 $0$。\n- $x_{3}=\\text{True}$ 得到 $(\\neg x_{3}\\lor x_{4})\\to(x_{4})$ 并移除单元子句，得到 $(x_{4})$。对 $x_4$ 进行分支：\n  - $x_{4}=\\text{False}$ 是不可满足的，返回 $0$。\n  - $x_{4}=\\text{True}$ 不产生任何子句，重言式返回 $2^{0}=1$ 模 $3$ 的值，即 $1$。\n因此 $x_{2}=\\text{True}$ 子情况贡献了 $0+1=1$。\n\n所以 $c_{0}=\\text{CountMod3}(\\psi_{0},2,4)=1+1=2$（且 $2\\bmod 3=2$）。\n\n情况 $x_{1}=\\text{True}$：代入 $x_{1}=\\text{True}$，因此 $\\neg x_{1}=\\text{False}$。子句简化如下：\n- $(\\neg x_{1}\\lor x_{2})\\to(\\text{False}\\lor x_{2})=(x_{2})$。\n- $(\\neg x_{2}\\lor x_{3})$ 不变。\n- $(\\neg x_{3}\\lor x_{4})$ 不变。\n- $(\\neg x_{4}\\lor \\neg x_{1})\\to(\\neg x_{4}\\lor \\text{False})=(\\neg x_{4})$。\n- $(x_{1}\\lor x_{3})\\to(\\text{True}\\lor x_{3})$ 结果为 $\\text{True}$，被移除。\n因此 $\\psi_{1}=(x_{2})\\land(\\neg x_{2}\\lor x_{3})\\land(\\neg x_{3}\\lor x_{4})\\land(\\neg x_{4})$，我们调用 CountMod3$(\\psi_{1},2,4)$ 并对 $x_2$ 进行分支。\n\n子情况 $x_{2}=\\text{False}$：单元子句 $(x_2)$ 变为 $\\text{False}$，产生一个空子句；返回 $0$。\n\n子情况 $x_{2}=\\text{True}$：移除 $(x_2)$，并且 $(\\neg x_{2}\\lor x_{3})\\to(\\text{False}\\lor x_{3})=(x_{3})$。我们得到 $\\psi_{11}=(x_{3})\\land(\\neg x_{3}\\lor x_{4})\\land(\\neg x_{4})$。对 $x_3$ 进行分支：\n- $x_{3}=\\text{False}$ 从 $(x_3)$ 得到一个空子句，返回 $0$。\n- $x_{3}=\\text{True}$ 产生 $(\\neg x_{3}\\lor x_{4})\\to(x_{4})$ 并保留 $(\\neg x_{4})$，所以我们有 $(x_{4})\\land(\\neg x_{4})$。对 $x_4$ 进行分支：\n  - $x_{4}=\\text{False}$ 使得 $(x_{4})$ 为假，产生空子句，返回 $0$。\n  - $x_{4}=\\text{True}$ 使得 $(\\neg x_{4})$ 为假，产生空子句，返回 $0$。\n因此这个子情况贡献了 $0$。\n\n所以 $c_{1}=\\text{CountMod3}(\\psi_{1},2,4)=0+0=0$。\n\n最后，CountMod3$(\\phi,1,4)$ 返回 $(c_{0}+c_{1})\\bmod 3=(2+0)\\bmod 3=2$。",
            "answer": "$$\\boxed{2}$$"
        }
    ]
}