{
    "hands_on_practices": [
        {
            "introduction": "许多高级图算法的核心是递归。第一个练习介绍了一种经典的递归路径查找方法，其灵感来源于 Savitch 定理。通过在一个简单的4顶点环形图上追踪其执行过程 ，你将对该算法如何将一个大的路径查找问题分解为更小、更易于管理的子问题有一个具体的理解。",
            "id": "1468448",
            "problem": "考虑一个判断无向图中两个顶点之间是否存在路径的问题，该问题通常被称为 `s-t连通性`。一个用于解决这个问题的著名递归算法，其灵感来源于 Savitch 定理，通过重复搜索中间顶点来运作。设图为 $G = (V, E)$，其中 $V$ 是顶点集，$E$ 是边集。该算法由一个函数 `PATH(u, v, k)` 定义，如果从顶点 `u` 到顶点 `v` 存在一条长度至多为 $k$ 的路径，则该函数返回 `true`，否则返回 `false`。路径的长度是其包含的边的数量。对于本问题，假设 `k` 始终是 2 的幂。\n\n函数 `PATH(u, v, k)` 的定义如下：\n- **基本情况**：如果 $k=1$，当 $u=v$ 或 $(u, v)$ 是 $E$ 中的一条边时，`PATH(u, v, 1)` 返回 `true`。否则，它返回 `false`。\n- **递归步骤**：如果 $k > 1$，函数会遍历所有顶点 $w \\in V$。对于每个 $w$，它进行两次递归调用：`PATH(u, w, k/2)` 和 `PATH(w, v, k/2)`。如果对于任何顶点 $w$，这两个调用都返回 `true`，那么 `PATH(u, v, k)` 会立即返回 `true`。如果循环结束仍未找到这样的 $w$，则函数返回 `false`。\n\n给定一个 4-顶点的环图 $C_4$，其顶点集为 $V = \\{v_1, v_2, v_3, v_4\\}$。边集为 $E = \\{(v_1, v_2), (v_2, v_3), (v_3, v_4), (v_4, v_1)\\}$。\n\n考虑初始调用 $\\text{PATH}(v_1, v_3, 4)$。在该调用的执行过程中，算法将测试 $V$ 中的每个顶点作为潜在的中间顶点 $w$。当 $V$ 中的哪个顶点子集被选为 $w$ 时，$\\text{PATH}(v_1, w, 2)$ 和 $\\text{PATH}(w, v_3, 2)$ 这对递归调用会同时求值为 `true`？\n\nA. $\\{v_2, v_4\\}$\n\nB. $\\{v_1, v_3\\}$\n\nC. $\\{v_2\\}$\n\nD. $\\{v_1, v_2, v_3, v_4\\}$\n\nE. $\\{v_1, v_2, v_4\\}$",
            "solution": "我们已知一个用于无向图 s-t 连通性的递归判定过程。对于 $k=1$，基本情况当且仅当 $u=v$ 或 $(u,v)\\in E$ 时返回 true。对于 $k>1$ 且 $k$ 是 2 的幂，递归步骤当且仅当存在某个 $w\\in V$，使得两个路径长度限制减半的递归调用都返回 true 时，才返回 true。特别地，对于 $k=2$，该定义意味着：\n$$\n\\text{PATH}(u,v,2)\\ \\text{is true} \\iff \\exists\\,x\\in V:\\ \\text{PATH}(u,x,1)\\ \\wedge\\ \\text{PATH}(x,v,1).\n$$\n根据基本情况，$\\text{PATH}(a,b,1)$ 为 true 当且仅当 $a=b$ 或 $(a,b)\\in E$。因此，$\\text{PATH}(u,v,2)$ 为 true 当且仅当存在一个 $x$ 使得 $u=x$ 或 $(u,x)\\in E$ 成立，并且 $x=v$ 或 $(x,v)\\in E$ 成立。这等价于说 $u$ 和 $v$ 之间的图距离至多为 $2$。\n\n该图是 4-环图 $C_{4}$，其顶点集为 $V=\\{v_{1},v_{2},v_{3},v_{4}\\}$，边集为 $E=\\{(v_{1},v_{2}),(v_{2},v_{3}),(v_{3},v_{4}),(v_{4},v_{1})\\}$。从 $v_1$ 出发的距离为：\n- $d(v_{1},v_{1})=0$，\n- $d(v_{1},v_{2})=1$，\n- $d(v_{1},v_{4})=1$，\n- $d(v_{1},v_{3})=2$。\n因此，对于每个 $w\\in V$，$\\text{PATH}(v_{1},w,2)$ 都为 true。\n\n类似地，到达 $v_3$ 的距离为：\n- $d(v_{3},v_{3})=0$，\n- $d(v_{3},v_{2})=1$，\n- $d(v_{3},v_{4})=1$，\n- $d(v_{3},v_{1})=2$。\n因此，对于每个 $w\\in V$，$\\text{PATH}(w,v_{3},2)$ 都为 true。\n\n我们也可以为每个 $w$ 显式地找出满足递归定义的中间顶点：\n- 对于 $w=v_{1}$：$\\text{PATH}(v_{1},v_{1},2)$ 为 true（通过 $x=v_{1}$），并且 $\\text{PATH}(v_{1},v_{3},2)$ 为 true（通过 $x=v_{2}$ (或 $x=v_{4}$)）。\n- 对于 $w=v_{2}$：$\\text{PATH}(v_{1},v_{2},2)$ 为 true（通过 $x=v_{1}$ (或 $x=v_{2}$)），并且 $\\text{PATH}(v_{2},v_{3},2)$ 为 true（通过 $x=v_{2}$ (或 $x=v_{3}$)）。\n- 对于 $w=v_{3}$：$\\text{PATH}(v_{1},v_{3},2)$ 为 true（通过 $x=v_{2}$ (或 $x=v_{4}$)），并且 $\\text{PATH}(v_{3},v_{3},2)$ 为 true（通过 $x=v_{3}$）。\n- 对于 $w=v_{4}$：$\\text{PATH}(v_{1},v_{4},2)$ 为 true（通过 $x=v_{1}$ (或 $x=v_{4}$)），并且 $\\text{PATH}(v_{4},v_{3},2)$ 为 true（通过 $x=v_{4}$ (或 $x=v_{3}$)）。\n\n因此，对于 $\\{v_{1},v_{2},v_{3},v_{4}\\}$ 中的每一个 $w$，$\\text{PATH}(v_{1},w,2)$ 和 $\\text{PATH}(w,v_{3},2)$ 的求值结果都为 true。正确的子集是 $\\{v_{1},v_{2},v_{3},v_{4}\\}$，这对应于选项 D。",
            "answer": "$$\\boxed{D}$$"
        },
        {
            "introduction": "一个算法只有在所有情况下都能正确工作时才是有用的，包括在没有解存在时。这个练习  挑战你将相同的递归路径查找算法应用于一个不连通图。通过分析当起点 $s$ 和终点 $t$ 位于不同连通分量时算法的行为，你将加深对其逻辑完备性的理解，并明白它为何能正确地报告失败。",
            "id": "1468381",
            "problem": "无向图s-t连通性问题旨在判断在一个无向图中，两个顶点 $s$ 和 $t$ 之间是否存在一条路径。这是复杂性理论中的一个基石问题，由 Omer Reingold 证明其可在对数空间（L）内解决，这一证明广为人知。该证明涉及一个递归算法。我们考虑该算法的一个简化概念版本，命名为 `ExplorePath`。\n\n函数 `ExplorePath(u, v, d)` 用于判断在给定图 $G=(V, E)$ 中，顶点 $u$ 和 $v$ 之间是否存在一条长度至多为 $2^d$ 的路径。其逻辑定义如下：\n\n- **基本情况 ($d=0$):** 如果 $u=v$ 或者 $(u, v)$ 是 $E$ 中的一条边，则函数返回 `true`。否则，返回 `false`。\n- **递归步骤 ($d>0$):** 函数遍历顶点集 $V$ 中的每一个顶点 $w$。如果能找到任何一个顶点 $w$ 使得 `ExplorePath(u, w, d-1)` 和 `ExplorePath(w, v, d-1)` *都*返回 `true`，则函数立即停止并返回 `true`。如果遍历完所有可能的顶点 $w$ 后仍未找到这样的顶点，则函数返回 `false`。\n\n现在，考虑一个无向图 $G$，其顶点集包含10个顶点，$V = \\{v_1, v_2, \\ldots, v_{10}\\}$。该顶点集被划分为两个不相交的集合：$C_1 = \\{v_1, v_2, v_3, v_4, v_5\\}$ 和 $C_2 = \\{v_6, v_7, v_8, v_9, v_{10}\\}$。图的边定义如下：在每个集合（$C_1$ 或 $C_2$）内部，顶点构成一个团（即，每个顶点都与同一集合中的所有其他顶点通过边相连）。$C_1$ 中的任何顶点与 $C_2$ 中的任何顶点之间都没有边。\n\n为了确定起始顶点 $s = v_1$ 和目标顶点 $t = v_{10}$ 之间是否存在路径，进行一次初始调用 `ExplorePath(s, t, k)`，其中 $k = \\lceil \\log_2(N) \\rceil$ 且 $N=10$ 是顶点的总数。\n\n对于这个特定的图以及选定的 $s$ 和 $t$，以下哪个陈述准确地描述了该算法执行过程的一个关键方面？\n\nA. 在执行过程中，至少有一次对 `ExplorePath(u, v, 1)` 的调用会返回 `true`，其中 $u \\in C_1$ 且 $v \\in C_2$。\n\nB. 算法终止并返回 `false`，因为对于同一团中的一对不同顶点 $(u, v)$，某次基本情况调用 `ExplorePath(u, v, 0)` 返回了 `false`。\n\nC. 对于在初始调用 `ExplorePath(v_1, v_{10}, k)` 中作为中间点测试的每个顶点 $w$，其对应的两个递归子调用 `ExplorePath(v_1, w, k-1)` 和 `ExplorePath(w, v_{10}, k-1)` 都将返回 `false`。\n\nD. 对于在初始调用 `ExplorePath(v_1, v_{10}, k)` 中作为中间点测试的每个顶点 $w$，其对应的两个递归子调用 `ExplorePath(v_1, w, k-1)` 或 `ExplorePath(w, v_{10}, k-1)` 中，恰好有一个将返回 `true`。\n\nE. 初始调用 `ExplorePath(v_1, v_{10}, k)` 最终返回 `true`。",
            "solution": "该图有两个不相交的团 $C_{1}=\\{v_{1},v_{2},v_{3},v_{4},v_{5}\\}$ 和 $C_{2}=\\{v_{6},v_{7},v_{8},v_{9},v_{10}\\}$，且 $C_{1}$ 和 $C_{2}$ 之间没有边。因此，对于所有 $u \\in C_{1}$ 和 $v \\in C_{2}$，在 $u$ 和 $v$ 之间不存在任何长度的路径。特别地，对于所有 $d \\geq 0$，在任何 $u \\in C_{1}$ 和任何 $v \\in C_{2}$ 之间都不存在长度至多为 $2^{d}$ 的路径。\n\n根据基本情况的定义，对于 $d=0$，$\\,\\text{ExplorePath}(u,v,0)$ 返回 true 当且仅当 $u=v$ 或 $(u,v) \\in E$。由于每个 $C_{i}$ 都是一个团，对于同一团中不同的 $u,v \\in C_{i}$，我们有 $(u,v) \\in E$，因此 $\\text{ExplorePath}(u,v,0)=\\text{true}$。对于 $u \\in C_{1}$ 和 $v \\in C_{2}$，有 $(u,v) \\notin E$，因此 $\\text{ExplorePath}(u,v,0)=\\text{false}$。\n\n我们调用 $\\text{ExplorePath}(v_{1},v_{10},k)$，其中 $k=\\lceil \\log_{2}(N) \\rceil$ 且 $N=10$。在这次初始调用中，算法遍历所有 $w \\in V$，并检查 $\\text{ExplorePath}(v_{1},w,k-1)$ 和 $\\text{ExplorePath}(w,v_{10},k-1)$ 是否都返回 true。\n\n- 如果 $w \\in C_{1}$，那么在团内部 $v_{1}$ 和 $w$ 之间存在一条长度为1的路径，所以 $\\text{ExplorePath}(v_{1},w,k-1)=\\text{true}$ (因为 $1 \\leq 2^{k-1}$)。然而，从任何 $w \\in C_{1}$ 到 $v_{10} \\in C_{2}$ 都不存在任何路径，所以 $\\text{ExplorePath}(w,v_{10},k-1)=\\text{false}$。\n\n- 如果 $w \\in C_{2}$，那么从 $v_{1} \\in C_{1}$ 到 $w \\in C_{2}$ 没有路径，所以 $\\text{ExplorePath}(v_{1},w,k-1)=\\text{false}$，而从 $w$ 到 $v_{10}$ 在 $C_{2}$ 内部存在一条长度至多为1的路径，所以 $\\text{ExplorePath}(w,v_{10},k-1)=\\text{true}$。\n\n- 特殊情况 $w=v_{1}$ 和 $w=v_{10}$ 也符合同样的模式：对于 $w=v_{1}$，$\\text{ExplorePath}(v_{1},v_{1},k-1)=\\text{true}$ 且 $\\text{ExplorePath}(v_{1},v_{10},k-1)=\\text{false}$；对于 $w=v_{10}$，$\\text{ExplorePath}(v_{1},v_{10},k-1)=\\text{false}$ 且 $\\text{ExplorePath}(v_{10},v_{10},k-1)=\\text{true}$。\n\n因此，对于每个 $w \\in V$，两个子调用中恰好一个为 true，另一个为 false：\n$$\n\\forall w \\in V:\\quad \\left(\\text{ExplorePath}(v_{1},w,k-1),\\,\\text{ExplorePath}(w,v_{10},k-1)\\right) \\in \\{(\\text{true},\\text{false}),(\\text{false},\\text{true})\\}.\n$$\n因此，不存在任何 $w$ 使得两个子调用都返回 true，所以初始调用返回 false。这排除了选项 A、B、C 和 E，与选项 D 完全匹配。",
            "answer": "$$\\boxed{D}$$"
        },
        {
            "introduction": "除了判断路径是否存在，理解算法的效率也至关重要。这个练习  将我们的重点从逻辑追踪转移到性能分析。我们将研究一种略有不同的分治递归策略，并计算在特定情况下所需的函数调用总数，这是分析算法时空复杂度的基础步骤。",
            "id": "1468400",
            "problem": "在计算复杂性理论中，Reingold 的一项核心成果表明，无向s-t连通性问题可以在对数空间内解决。该算法很复杂，但其核心包含一种用于寻路的递归分治策略。本题要求你分析这种递归方法在一个特定类型图上的简化版本。\n\n考虑一个有 $N$ 个顶点的简单路径图 $P_N$，顶点依次标记为 $0, 1, 2, \\ldots, N-1$。顶点 $i$ 和顶点 $j$ 之间存在一条边，当且仅当 $|i-j|=1$。\n\n我们定义一个递归函数 `HasPath(u, v, k)`，旨在通过将问题分解为子问题来确定顶点 $u$ 和 $v$ 之间是否存在路径。参数 $k$ 控制递归深度，概念上与所检查的最大路径长度有关。该函数的定义如下：\n\n`HasPath(u, v, k)`:\n1.  **基本情况 ($k=0$)**：如果 $u=v$ 或者顶点 $u$ 和 $v$ 相邻，则函数返回 `true`。否则，返回 `false`。\n2.  **递归步骤 ($k > 0$)**：\n    a. 计算一个潜在的中间顶点 $w = \\lfloor \\frac{u+v}{2} \\rfloor$。\n    b. 它首先调用 `HasPath(u, w, k-1)`。\n    c. 如果此调用返回 `false`，`HasPath(u, v, k)` 会立即返回 `false`，不再进行后续计算。\n    d. 如果调用 `HasPath(u, w, k-1)` 返回 `true`，则函数接着调用 `HasPath(w, v, k-1)`。这第二次调用的返回值成为 `HasPath(u, v, k)` 的最终返回值。\n\n假设我们有一个路径图 $P_N$，其顶点数为 $N = 2^K + 1$，其中 $K$ 是某个正整数。为了检查图的两个端点 $s=0$ 和 $t=N-1$ 之间是否存在路径，我们进行初始调用 `HasPath(0, N-1, K)`。\n\n计算在 `HasPath(0, N-1, K)` 的完整执行过程中，`HasPath` 函数被调用的总次数（包括初始调用）。请用关于 $N$ 的封闭形式解析表达式来表示你的答案。",
            "solution": "令 $P_{N}$ 为顶点集 $\\{0,1,\\ldots,N-1\\}$ 上的路径图，其中 $N=2^{K}+1$。考虑初始调用 $\\text{HasPath}(0,N-1,K)=\\text{HasPath}(0,2^{K},K)$。对于任意整数 $a$ 和 $m\\geq 0$，定义 $T(m)$ 为由 $\\text{HasPath}(a,a+2^{m},m)$ 产生的调用次数，包括初始调用。\n\n断言 1 (结构性质)：对于形式为 $(a,a+2^{m},m)$ 的输入，中间点是精确的：\n$$\nw=\\left\\lfloor\\frac{(a)+(a+2^{m})}{2}\\right\\rfloor=a+2^{m-1}。\n$$\n因此，两个子问题都具有相同的形式，且距离减半：\n$$\n\\text{HasPath}(a,w,m-1)=\\text{HasPath}(a,a+2^{m-1},m-1),\\quad\n\\text{HasPath}(w,a+2^{m},m-1)=\\text{HasPath}(a+2^{m-1},a+2^{m},m-1)。\n$$\n\n断言 2 (正确性与两个子调用的可达性)：对于所有 $m\\geq 0$，$\\text{HasPath}(a,a+2^{m},m)$ 返回真。对 $m$ 进行归纳证明：\n- 基准情况 $m=0$：此时 $| (a+2^{0})-a |=1$，因此根据基本情况，调用返回真。\n- 归纳步骤：假设断言对 $m-1$ 成立。左子调用 $\\text{HasPath}(a,a+2^{m-1},m-1)$ 的距离为 $2^{m-1}$，因此根据归纳假设返回真。所以算法会执行右子调用 $\\text{HasPath}(a+2^{m-1},a+2^{m},m-1)$，根据归纳假设它也返回真。因此，父调用返回真。\n\n因为左子调用总是返回真，所以右子调用总是会被执行。因此 $T(m)$ 满足以下递推关系\n$$\nT(0)=1,\\qquad T(m)=1+T(m-1)+T(m-1)=1+2\\,T(m-1)\\quad\\text{对于 }m\\geq 1,\n$$\n其中，项 $1$ 计算当前调用，两个 $T(m-1)$ 项计算来自左、右子调用的次数。\n\n求解该递推关系。考虑\n$$\nT(m)-2T(m-1)=1.\n$$\n一个特解是 $T_{p}(m)=-1$。齐次解是 $T_{h}(m)=A\\cdot 2^{m}$。使用 $T(0)=1$ 得出 $A\\cdot 2^{0}-1=1$，所以 $A=2$。因此\n$$\nT(m)=2^{m+1}-1.\n$$\n\n对于原始输入，$m=K$ 且 $N-1=2^{K}$，所以\n$$\nT(K)=2^{K+1}-1=2\\cdot 2^{K}-1=2(N-1)-1=2N-3.\n$$\n这计算了所有的调用次数，包括初始调用和所有基本情况的调用。",
            "answer": "$$\\boxed{2N-3}$$"
        }
    ]
}