{
    "hands_on_practices": [
        {
            "introduction": "To appreciate the breakthrough of solving st-connectivity in logarithmic space, we must first understand why common approaches fall short. This exercise asks you to analyze the memory usage of a standard Depth First Search (DFS) algorithm. By pinpointing the sources of its linear space complexity , you will see precisely why a more sophisticated strategy is necessary to achieve the remarkable $O(\\log n)$ space bound.",
            "id": "1468444",
            "problem": "Consider the problem of determining s-t connectivity: given an unweighted, undirected graph $G=(V,E)$ with $n = |V|$ vertices and two specified vertices, $s$ and $t$, the goal is to determine if a path exists between them. A common approach is to implement a recursive Depth First Search (DFS) algorithm. This standard implementation uses auxiliary space for two primary purposes:\n\n1.  An explicit data structure, such as a boolean array or hash set, to keep track of all vertices that have been visited to prevent infinite cycles.\n2.  The system's recursion call stack, which implicitly stores the context of the current search path.\n\nIn computational complexity theory, the class **L** consists of decision problems that can be solved by a deterministic Turing machine using only a logarithmic amount of memory, $O(\\log n)$. A landmark result by Omer Reingold proved that s-t connectivity for undirected graphs is in **L**. This implies that there exists an algorithm for this problem with a logarithmic space bound. However, the standard recursive DFS implementation described above does not meet this bound.\n\nWhat is the tightest worst-case asymptotic bound for the auxiliary space complexity required by this standard recursive DFS implementation on a graph with $n$ vertices?\n\nA. $O(\\log n)$\n\nB. $O(n)$\n\nC. $O(n \\log n)$\n\nD. $O(n+m)$, where $m = |E|$\n\nE. $O(n^{2})$",
            "solution": "We measure auxiliary space as memory used beyond the input graph representation. In the standard recursive DFS for s-t connectivity on an undirected graph with $n$ vertices, there are two auxiliary components:\n\n1) Visited set: A boolean array or hash set marks whether each vertex has been visited to avoid infinite recursion in graphs with cycles. This requires storing one flag per vertex, which is $n$ entries, so the auxiliary space for this structure is $O(n)$.\n\n2) Recursion call stack: In the worst case (e.g., a path graph on $n$ vertices), DFS follows a simple path and reaches recursion depth $n$. Each stack frame stores constant-sized information (such as the current vertex, a loop index or iterator state, and return address), which is $O(1)$ per frame. Therefore, the recursion stack uses $O(n)$ space in the worst case.\n\nSumming the two contributions gives a total auxiliary space of $O(n) + O(n) = O(n)$. This bound is tight: on a path graph, the algorithm indeed uses $\\Theta(n)$ auxiliary space due to both the visited structure and the maximum recursion depth. The input representation (e.g., adjacency lists requiring $O(n+m)$ space) is not counted toward auxiliary space.\n\nHence, the tightest worst-case asymptotic bound is $O(n)$, corresponding to option B.",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "The core of many space-efficient path-finding algorithms lies in a recursive 'divide and conquer' strategy, which repeatedly asks if a path can be broken into two smaller ones via an intermediate vertex. This practice introduces a conceptual version of this method, inspired by the logic of Savitch's theorem. By tracing the algorithm on a simple cycle graph , you will gain a hands-on feel for how it finds a path by systematically exploring all possible midpoints at decreasing scales.",
            "id": "1468448",
            "problem": "Consider the problem of determining if a path exists between two vertices in an undirected graph, a problem often called `st-connectivity`. A well-known recursive algorithm for solving this problem, inspired by Savitch's theorem, operates by repeatedly searching for an intermediate vertex. Let the graph be $G = (V, E)$, where $V$ is the set of vertices and $E$ is the set of edges. The algorithm is defined by a function `PATH(u, v, k)`, which returns `true` if there is a path of length at most $k$ from vertex `u` to vertex `v`, and `false` otherwise. The length of a path is the number of edges it contains. For this problem, assume `k` is always a power of 2.\n\nThe function `PATH(u, v, k)` is defined as follows:\n- **Base Case**: If $k=1$, `PATH(u, v, 1)` returns `true` if $u=v$ or if $(u, v)$ is an edge in $E$. Otherwise, it returns `false`.\n- **Recursive Step**: If $k > 1$, the function iterates through all vertices $w \\in V$. For each $w$, it makes two recursive calls: `PATH(u, w, k/2)` and `PATH(w, v, k/2)`. If both calls return `true` for any vertex $w$, then `PATH(u, v, k)` immediately returns `true`. If the loop finishes without finding such a $w$, the function returns `false`.\n\nYou are given a 4-vertex cycle graph, $C_4$, with the set of vertices $V = \\{v_1, v_2, v_3, v_4\\}$. The set of edges is $E = \\{(v_1, v_2), (v_2, v_3), (v_3, v_4), (v_4, v_1)\\}$.\n\nConsider the initial call `PATH($v_1$, $v_3$, 4)`. In the execution of this call, the algorithm will test each vertex in $V$ as a potential intermediate vertex $w$. For which subset of vertices in $V$, when chosen as $w$, will the pair of recursive calls, `PATH($v_1$, w, 2)` and `PATH(w, $v_3$, 2)`, both evaluate to `true`?\n\nA. $\\{v_2, v_4\\}$\n\nB. $\\{v_1, v_3\\}$\n\nC. $\\{v_2\\}$\n\nD. $\\{v_1, v_2, v_3, v_4\\}$\n\nE. $\\{v_1, v_2, v_4\\}$",
            "solution": "We are given the recursive decision procedure for st-connectivity on an undirected graph. For $k=1$, the base case returns true exactly when $u=v$ or $(u,v)\\in E$. For $k>1$ with $k$ a power of $2$, the recursive step returns true exactly when there exists some $w\\in V$ such that both recursive calls with halved budget return true. In particular, for $k=2$, the definition implies:\n$$\n\\text{PATH}(u,v,2)\\ \\text{is true} \\iff \\exists\\,x\\in V:\\ \\text{PATH}(u,x,1)\\ \\wedge\\ \\text{PATH}(x,v,1).\n$$\nBy the base case, $\\text{PATH}(a,b,1)$ is true iff $a=b$ or $(a,b)\\in E$. Therefore, $\\text{PATH}(u,v,2)$ is true iff there exists an $x$ such that either $u=x$ or $(u,x)\\in E$, and either $x=v$ or $(x,v)\\in E$. This is equivalent to saying that the graph distance between $u$ and $v$ is at most $2$.\n\nThe graph is the $4$-cycle $C_{4}$ with $V=\\{v_{1},v_{2},v_{3},v_{4}\\}$ and $E=\\{(v_{1},v_{2}),(v_{2},v_{3}),(v_{3},v_{4}),(v_{4},v_{1})\\}$. The distances from $v_{1}$ are:\n- $d(v_{1},v_{1})=0$,\n- $d(v_{1},v_{2})=1$,\n- $d(v_{1},v_{4})=1$,\n- $d(v_{1},v_{3})=2$.\nHence, for every $w\\in V$, $\\text{PATH}(v_{1},w,2)$ is true.\n\nSimilarly, the distances to $v_{3}$ are:\n- $d(v_{3},v_{3})=0$,\n- $d(v_{3},v_{2})=1$,\n- $d(v_{3},v_{4})=1$,\n- $d(v_{3},v_{1})=2$.\nThus, for every $w\\in V$, $\\text{PATH}(w,v_{3},2)$ is true.\n\nWe can also witness the required intermediates explicitly for each $w$ to satisfy the recursive definition:\n- For $w=v_{1}$: $\\text{PATH}(v_{1},v_{1},2)$ is true via $x=v_{1}$, and $\\text{PATH}(v_{1},v_{3},2)$ is true via $x=v_{2}$ (or $x=v_{4}$).\n- For $w=v_{2}$: $\\text{PATH}(v_{1},v_{2},2)$ is true via $x=v_{1}$ (or $x=v_{2}$), and $\\text{PATH}(v_{2},v_{3},2)$ is true via $x=v_{2}$ (or $x=v_{3}$).\n- For $w=v_{3}$: $\\text{PATH}(v_{1},v_{3},2)$ is true via $x=v_{2}$ (or $x=v_{4}$), and $\\text{PATH}(v_{3},v_{3},2)$ is true via $x=v_{3}$.\n- For $w=v_{4}$: $\\text{PATH}(v_{1},v_{4},2)$ is true via $x=v_{1}$ (or $x=v_{4}$), and $\\text{PATH}(v_{4},v_{3},2)$ is true via $x=v_{4}$ (or $x=v_{3}$).\n\nTherefore, for every $w\\in\\{v_{1},v_{2},v_{3},v_{4}\\}$, both $\\text{PATH}(v_{1},w,2)$ and $\\text{PATH}(w,v_{3},2)$ evaluate to true. The correct subset is $\\{v_{1},v_{2},v_{3},v_{4}\\}$, which corresponds to option D.",
            "answer": "$$\\boxed{D}$$"
        },
        {
            "introduction": "A robust algorithm must not only find paths where they exist but also correctly report their absence. This exercise challenges you to analyze the behavior of the recursive path-finding algorithm on a graph that is intentionally disconnected . Observing how the search for a 'midpoint' vertex fails at the highest level provides crucial insight into the algorithm's correctness and its ability to respect the boundaries of connected components.",
            "id": "1468381",
            "problem": "The undirected st-connectivity problem asks whether a path exists between two vertices, $s$ and $t$, in an undirected graph. It is a cornerstone problem in complexity theory, famously proven by Omer Reingold to be solvable in Logarithmic Space (**L**). The proof involves a recursive algorithm. Consider a simplified, conceptual version of such an algorithm, named `ExplorePath`.\n\nThe function `ExplorePath(u, v, d)` is designed to determine if a path of length at most $2^d$ exists between vertices $u$ and $v$ in a given graph $G=(V, E)$. Its logic is defined as follows:\n\n- **Base Case ($d=0$):** The function returns `true` if $u=v$ or if $(u, v)$ is an edge in $E$. Otherwise, it returns `false`.\n- **Recursive Step ($d>0$):** The function iterates through every vertex $w$ in the vertex set $V$. If it finds any single vertex $w$ for which *both* `ExplorePath(u, w, d-1)` and `ExplorePath(w, v, d-1)` return `true`, then the function immediately halts and returns `true`. If the loop over all possible vertices $w$ completes without finding such a vertex, the function returns `false`.\n\nNow, consider an undirected graph $G$ with a set of 10 vertices, $V = \\{v_1, v_2, \\ldots, v_{10}\\}$. The vertex set is partitioned into two disjoint sets: $C_1 = \\{v_1, v_2, v_3, v_4, v_5\\}$ and $C_2 = \\{v_6, v_7, v_8, v_9, v_{10}\\}$. The graph's edges are defined such that within each set ($C_1$ or $C_2$), the vertices form a clique (i.e., every vertex is connected by an edge to every other vertex in the same set). There are no edges connecting any vertex in $C_1$ to any vertex in $C_2$.\n\nTo determine if a path exists between a start vertex $s = v_1$ and a target vertex $t = v_{10}$, an initial call is made to `ExplorePath(s, t, k)`, where $k = \\lceil \\log_2(N) \\rceil$ and $N=10$ is the total number of vertices.\n\nWhich of the following statements accurately describes a key aspect of the algorithm's execution for this specific graph and choice of $s$ and $t$?\n\nA. During the execution, at least one call to `ExplorePath(u, v, 1)` will return `true`, where $u \\in C_1$ and $v \\in C_2$.\n\nB. The algorithm terminates and returns `false` because a base case call `ExplorePath(u, v, 0)` returns `false` for a pair of distinct vertices $(u, v)$ that are in the same clique.\n\nC. For every vertex $w$ tested as a midpoint in the initial call `ExplorePath(v_1, v_{10}, k)`, both of the corresponding recursive sub-calls, `ExplorePath(v_1, w, k-1)` and `ExplorePath(w, v_{10}, k-1)`, will return `false`.\n\nD. For every vertex $w$ tested as a midpoint in the initial call `ExplorePath(v_1, v_{10}, k)`, exactly one of the two corresponding recursive sub-calls, `ExplorePath(v_1, w, k-1)` or `ExplorePath(w, v_{10}, k-1)`, will return `true`.\n\nE. The initial call `ExplorePath(v_1, v_{10}, k)` ultimately returns `true`.",
            "solution": "The graph has two disjoint cliques, $C_{1}=\\{v_{1},v_{2},v_{3},v_{4},v_{5}\\}$ and $C_{2}=\\{v_{6},v_{7},v_{8},v_{9},v_{10}\\}$, and no edges between $C_{1}$ and $C_{2}$. Therefore, for all $u \\in C_{1}$ and $v \\in C_{2}$ there is no path of any length between $u$ and $v$. In particular, for all $d \\geq 0$, there is no path of length at most $2^{d}$ between any $u \\in C_{1}$ and any $v \\in C_{2}$.\n\nBy the base case definition, for $d=0$, $\\,\\text{ExplorePath}(u,v,0)$ returns true if and only if $u=v$ or $(u,v) \\in E$. Since each $C_{i}$ is a clique, for distinct $u,v \\in C_{i}$ we have $(u,v) \\in E$, hence $\\text{ExplorePath}(u,v,0)=\\text{true}$ for distinct $u,v$ in the same clique. For $u \\in C_{1}$ and $v \\in C_{2}$, $(u,v) \\notin E$, hence $\\text{ExplorePath}(u,v,0)=\\text{false}$.\n\nWe call $\\text{ExplorePath}(v_{1},v_{10},k)$ with $k=\\lceil \\log_{2}(N) \\rceil$ and $N=10$. In this initial call, the algorithm iterates over all $w \\in V$ and checks whether both $\\text{ExplorePath}(v_{1},w,k-1)$ and $\\text{ExplorePath}(w,v_{10},k-1)$ return true.\n\n- If $w \\in C_{1}$, then there is a path of length $1$ between $v_{1}$ and $w$ inside the clique, so $\\text{ExplorePath}(v_{1},w,k-1)=\\text{true}$ because $1 \\leq 2^{k-1}$. However, there is no path at all from any $w \\in C_{1}$ to $v_{10} \\in C_{2}$, so $\\text{ExplorePath}(w,v_{10},k-1)=\\text{false}$.\n\n- If $w \\in C_{2}$, then there is no path from $v_{1} \\in C_{1}$ to $w \\in C_{2}$, so $\\text{ExplorePath}(v_{1},w,k-1)=\\text{false}$, while there is a path of length at most $1$ from $w$ to $v_{10}$ within $C_{2}$, so $\\text{ExplorePath}(w,v_{10},k-1)=\\text{true}$.\n\n- The special cases $w=v_{1}$ and $w=v_{10}$ fit the same pattern: for $w=v_{1}$, $\\text{ExplorePath}(v_{1},v_{1},k-1)=\\text{true}$ and $\\text{ExplorePath}(v_{1},v_{10},k-1)=\\text{false}$; for $w=v_{10}$, $\\text{ExplorePath}(v_{1},v_{10},k-1)=\\text{false}$ and $\\text{ExplorePath}(v_{10},v_{10},k-1)=\\text{true}$.\n\nHence, for every $w \\in V$, exactly one of the two subcalls is true and the other is false:\n$$\n\\forall w \\in V:\\quad \\left(\\text{ExplorePath}(v_{1},w,k-1),\\,\\text{ExplorePath}(w,v_{10},k-1)\\right) \\in \\{(\\text{true},\\text{false}),(\\text{false},\\text{true})\\}.\n$$\nConsequently, there is no $w$ for which both subcalls return true, so the initial call returns false. This eliminates options A, B, C, and E, and matches option D exactly.",
            "answer": "$$\\boxed{D}$$"
        }
    ]
}