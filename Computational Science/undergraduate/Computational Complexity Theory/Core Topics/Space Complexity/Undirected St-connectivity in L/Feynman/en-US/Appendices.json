{
    "hands_on_practices": [
        {
            "introduction": "Before diving into the sophisticated algorithms that prove undirected s-t connectivity is in L, it is crucial to understand why more familiar methods fall short. This first exercise asks you to analyze the space complexity of a standard recursive Depth First Search (DFS) . By identifying the two main sources of memory usage—the call stack and the \"visited\" set—you will establish a clear baseline and motivate the need for fundamentally different, space-efficient algorithms.",
            "id": "1468444",
            "problem": "Consider the problem of determining s-t connectivity: given an unweighted, undirected graph $G=(V,E)$ with $n = |V|$ vertices and two specified vertices, $s$ and $t$, the goal is to determine if a path exists between them. A common approach is to implement a recursive Depth First Search (DFS) algorithm. This standard implementation uses auxiliary space for two primary purposes:\n\n1.  An explicit data structure, such as a boolean array or hash set, to keep track of all vertices that have been visited to prevent infinite cycles.\n2.  The system's recursion call stack, which implicitly stores the context of the current search path.\n\nIn computational complexity theory, the class L consists of decision problems that can be solved by a deterministic Turing machine using only a logarithmic amount of memory, $O(\\log n)$. A landmark result by Omer Reingold proved that s-t connectivity for undirected graphs is in L. This implies that there exists an algorithm for this problem with a logarithmic space bound. However, the standard recursive DFS implementation described above does not meet this bound.\n\nWhat is the tightest worst-case asymptotic bound for the auxiliary space complexity required by this standard recursive DFS implementation on a graph with $n$ vertices?\n\nA. $O(\\log n)$\n\nB. $O(n)$\n\nC. $O(n \\log n)$\n\nD. $O(n+m)$, where $m = |E|$\n\nE. $O(n^{2})$",
            "solution": "We measure auxiliary space as memory used beyond the input graph representation. In the standard recursive DFS for s-t connectivity on an undirected graph with $n$ vertices, there are two auxiliary components:\n\n1) Visited set: A boolean array or hash set marks whether each vertex has been visited to avoid infinite recursion in graphs with cycles. This requires storing one flag per vertex, which is $n$ entries, so the auxiliary space for this structure is $O(n)$.\n\n2) Recursion call stack: In the worst case (e.g., a path graph on $n$ vertices), DFS follows a simple path and reaches recursion depth $n$. Each stack frame stores constant-sized information (such as the current vertex, a loop index or iterator state, and return address), which is $O(1)$ per frame. Therefore, the recursion stack uses $O(n)$ space in the worst case.\n\nSumming the two contributions gives a total auxiliary space of $O(n) + O(n) = O(n)$. This bound is tight: on a path graph, the algorithm indeed uses $\\Theta(n)$ auxiliary space due to both the visited structure and the maximum recursion depth. The input representation (e.g., adjacency lists requiring $O(n+m)$ space) is not counted toward auxiliary space.\n\nHence, the tightest worst-case asymptotic bound is $O(n)$, corresponding to option B.",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "The key insight behind log-space connectivity algorithms is a powerful recursive strategy that checks for a \"midpoint\" on a potential path. This practice provides a simplified model of such an algorithm, `ExplorePath`, and asks you to trace its behavior on a carefully chosen graph of two disconnected cliques . This exercise is designed to build your intuition for how this divide-and-conquer approach works, particularly in demonstrating how it correctly determines non-connectivity without maintaining a large list of visited nodes.",
            "id": "1468381",
            "problem": "The undirected s-t connectivity problem asks whether a path exists between two vertices, $s$ and $t$, in an undirected graph. It is a cornerstone problem in complexity theory, famously proven by Omer Reingold to be solvable in Logarithmic Space (L). The proof involves a recursive algorithm. Consider a simplified, conceptual version of such an algorithm, named `ExplorePath`.\n\nThe function `ExplorePath(u, v, d)` is designed to determine if a path of length at most $2^d$ exists between vertices $u$ and $v$ in a given graph $G=(V, E)$. Its logic is defined as follows:\n\n- **Base Case ($d=0$):** The function returns `true` if $u=v$ or if $(u, v)$ is an edge in $E$. Otherwise, it returns `false`.\n- **Recursive Step ($d>0$):** The function iterates through every vertex $w$ in the vertex set $V$. If it finds any single vertex $w$ for which *both* `ExplorePath(u, w, d-1)` and `ExplorePath(w, v, d-1)` return `true`, then the function immediately halts and returns `true`. If the loop over all possible vertices $w$ completes without finding such a vertex, the function returns `false`.\n\nNow, consider an undirected graph $G$ with a set of 10 vertices, $V = \\{v_1, v_2, \\ldots, v_{10}\\}$. The vertex set is partitioned into two disjoint sets: $C_1 = \\{v_1, v_2, v_3, v_4, v_5\\}$ and $C_2 = \\{v_6, v_7, v_8, v_9, v_{10}\\}$. The graph's edges are defined such that within each set ($C_1$ or $C_2$), the vertices form a clique (i.e., every vertex is connected by an edge to every other vertex in the same set). There are no edges connecting any vertex in $C_1$ to any vertex in $C_2$.\n\nTo determine if a path exists between a start vertex $s = v_1$ and a target vertex $t = v_{10}$, an initial call is made to `ExplorePath(s, t, k)`, where $k = \\lceil \\log_2(N) \\rceil$ and $N=10$ is the total number of vertices.\n\nWhich of the following statements accurately describes a key aspect of the algorithm's execution for this specific graph and choice of $s$ and $t$?\n\nA. During the execution, at least one call to `ExplorePath(u, v, 1)` will return `true`, where $u \\in C_1$ and $v \\in C_2$.\n\nB. The algorithm terminates and returns `false` because a base case call `ExplorePath(u, v, 0)` returns `false` for a pair of distinct vertices $(u, v)$ that are in the same clique.\n\nC. For every vertex $w$ tested as a midpoint in the initial call `ExplorePath(v_1, v_{10}, k)`, both of the corresponding recursive sub-calls, `ExplorePath(v_1, w, k-1)` and `ExplorePath(w, v_{10}, k-1)`, will return `false`.\n\nD. For every vertex $w$ tested as a midpoint in the initial call `ExplorePath(v_1, v_{10}, k)`, exactly one of the two corresponding recursive sub-calls, `ExplorePath(v_1, w, k-1)` or `ExplorePath(w, v_{10}, k-1)`, will return `true`.\n\nE. The initial call `ExplorePath(v_1, v_{10}, k)` ultimately returns `true`.",
            "solution": "The graph has two disjoint cliques, $C_{1}=\\{v_{1},v_{2},v_{3},v_{4},v_{5}\\}$ and $C_{2}=\\{v_{6},v_{7},v_{8},v_{9},v_{10}\\}$, and no edges between $C_{1}$ and $C_{2}$. Therefore, for all $u \\in C_{1}$ and $v \\in C_{2}$ there is no path of any length between $u$ and $v$. In particular, for all $d \\geq 0$, there is no path of length at most $2^{d}$ between any $u \\in C_{1}$ and any $v \\in C_{2}$.\n\nBy the base case definition, for $d=0$, $\\,\\text{ExplorePath}(u,v,0)$ returns true if and only if $u=v$ or $(u,v) \\in E$. Since each $C_{i}$ is a clique, for distinct $u,v \\in C_{i}$ we have $(u,v) \\in E$, hence $\\text{ExplorePath}(u,v,0)=\\text{true}$ for distinct $u,v$ in the same clique. For $u \\in C_{1}$ and $v \\in C_{2}$, $(u,v) \\notin E$, hence $\\text{ExplorePath}(u,v,0)=\\text{false}$.\n\nWe call $\\text{ExplorePath}(v_{1},v_{10},k)$ with $k=\\lceil \\log_{2}(N) \\rceil$ and $N=10$. In this initial call, the algorithm iterates over all $w \\in V$ and checks whether both $\\text{ExplorePath}(v_{1},w,k-1)$ and $\\text{ExplorePath}(w,v_{10},k-1)$ return true.\n\n- If $w \\in C_{1}$, then there is a path of length $1$ between $v_{1}$ and $w$ inside the clique, so $\\text{ExplorePath}(v_{1},w,k-1)=\\text{true}$ because $1 \\leq 2^{k-1}$. However, there is no path at all from any $w \\in C_{1}$ to $v_{10} \\in C_{2}$, so $\\text{ExplorePath}(w,v_{10},k-1)=\\text{false}$.\n\n- If $w \\in C_{2}$, then there is no path from $v_{1} \\in C_{1}$ to $w \\in C_{2}$, so $\\text{ExplorePath}(v_{1},w,k-1)=\\text{false}$, while there is a path of length at most $1$ from $w$ to $v_{10}$ within $C_{2}$, so $\\text{ExplorePath}(w,v_{10},k-1)=\\text{true}$.\n\n- The special cases $w=v_{1}$ and $w=v_{10}$ fit the same pattern: for $w=v_{1}$, $\\text{ExplorePath}(v_{1},v_{1},k-1)=\\text{true}$ and $\\text{ExplorePath}(v_{1},v_{10},k-1)=\\text{false}$; for $w=v_{10}$, $\\text{ExplorePath}(v_{1},v_{10},k-1)=\\text{false}$ and $\\text{ExplorePath}(v_{10},v_{10},k-1)=\\text{true}$.\n\nHence, for every $w \\in V$, exactly one of the two subcalls is true and the other is false:\n$$\n\\forall w \\in V:\\quad \\left(\\text{ExplorePath}(v_{1},w,k-1),\\,\\text{ExplorePath}(w,v_{10},k-1)\\right) \\in \\{(\\text{true},\\text{false}),(\\text{false},\\text{true})\\}.\n$$\nConsequently, there is no $w$ for which both subcalls return true, so the initial call returns false. This eliminates options A, B, C, and E, and matches option D exactly.",
            "answer": "$$\\boxed{D}$$"
        },
        {
            "introduction": "Having explored the limitations of standard search and the mechanics of recursive pathfinding, you can now apply these principles to a novel problem. This final practice challenges you to determine the complexity class for a related problem: finding a path of length at most $\\lfloor \\log_2 n \\rfloor$ . Solving this requires you to think algorithmically within the strict constraints of logarithmic space, solidifying your understanding of how to design or analyze algorithms for space-bounded complexity classes like L.",
            "id": "1468409",
            "problem": "Consider the following decision problem, which we will call `LOG-PATH`. The input consists of an undirected graph $G = (V, E)$ with $n = |V|$ vertices labeled $1, \\dots, n$, and two distinct vertices $s, t \\in V$. The question is:\n\n**Does there exist a simple path between $s$ and $t$ of length at most $\\lfloor \\log_2 n \\rfloor$?**\n\n(A \"simple path\" is a path that does not repeat any vertices.)\n\nDetermine the computational complexity of the `LOG-PATH` problem. Which of the following statements is correct? Assume standard definitions for complexity classes: L (Logarithmic Space), NL (Nondeterministic Logarithmic Space), P (Polynomial Time), and PSPACE (Polynomial Space).\n\nA. `LOG-PATH` is NL-complete.\n\nB. `LOG-PATH` is in L.\n\nC. `LOG-PATH` is in P, but it is not contained within NL.\n\nD. `LOG-PATH` is PSPACE-complete.\n\nE. The complexity of `LOG-PATH` is proven to be the same as that of the general directed s-t connectivity problem.",
            "solution": "We are given an undirected graph $G=(V,E)$ with $|V|=n$, vertices $s,t \\in V$ distinct, and we ask whether there exists a simple $s$-$t$ path of length at most $k=\\lfloor \\log_{2} n \\rfloor$.\n\nFirst, observe that in an undirected graph, any shortest $s$-$t$ walk can be turned into a simple $s$-$t$ path by iteratively deleting cycles, and this never increases the length. Therefore, the “simple” qualifier is redundant when bounding the length: there exists a simple $s$-$t$ path of length at most $k$ if and only if $\\operatorname{dist}_G(s,t) \\le k$, equivalently, there exists an $s$-$t$ walk of length at most $k$.\n\nWe reduce the problem to undirected $s$-$t$ connectivity on a layered undirected graph. Define the undirected graph\n$$\nH \\;=\\; \\bigl(V \\times \\{0,1,\\dots,k\\},\\, E_{H}\\bigr),\n$$\nwhere for every $i \\in \\{0,1,\\dots,k-1\\}$ and every $\\{u,v\\} \\in E$, we put undirected edges between $(u,i)$ and $(v,i+1)$. Formally,\n$$\nE_{H} \\;=\\; \\bigl\\{\\, \\{(u,i),(v,i+1)\\} \\;\\big|\\; \\{u,v\\} \\in E,\\; 0 \\le i \\le k-1 \\,\\bigr\\}.\n$$\nClaim: There exists an $s$-$t$ walk in $G$ of length exactly $\\ell \\le k$ if and only if there exists a path in $H$ from $(s,0)$ to $(t,\\ell)$. Proof: \n- If there is an $s$-$t$ walk $s=v_{0},v_{1},\\dots,v_{\\ell}=t$ in $G$ of length $\\ell$, then $(v_{0},0),(v_{1},1),\\dots,(v_{\\ell},\\ell)$ is a path in $H$ from $(s,0)$ to $(t,\\ell)$ because each step corresponds to an edge between consecutive layers.\n- Conversely, any path in $H$ from $(s,0)$ to $(t,\\ell)$ must change the layer index by exactly $\\pm 1$ at each step and end at layer $\\ell$, hence it contains at least $\\ell$ forward moves; by removing backtracking cycles one obtains a monotone path that increases the layer by $1$ at each step, yielding an $s$-$t$ walk in $G$ of length exactly $\\ell$. Therefore, existence of any such path in $H$ implies an $s$-$t$ walk of length $\\ell$ in $G$.\n\nConsequently, the original instance is a YES-instance if and only if $(s,0)$ is connected in $H$ to at least one of $(t,0),(t,1),\\dots,(t,k)$. This yields a reduction to at most $k+1$ instances of undirected $s$-$t$ connectivity on $H$.\n\nWe now analyze space complexity. The graph $H$ has $(k+1)n$ vertices, so $\\log\\bigl(|V(H)|\\bigr) = \\log n + \\log(k+1) = O(\\log n)$ since $k=\\lfloor \\log_{2} n \\rfloor$. Given a vertex $(u,i)$ in $H$, its neighbors are exactly $\\{(v,i+1) : \\{u,v\\} \\in E\\}$ when $i<k$ together with $\\{(v,i-1) : \\{u,v\\} \\in E\\}$ when $i>0$. On input $(u,i)$ and a neighbor index, we can enumerate and access these neighbors by scanning the input representation of $G$ using $O(\\log n)$ work space to keep counters and indices. Hence the neighbor function of $H$ is computable in deterministic logarithmic space.\n\nBy Reingold’s theorem, undirected $s$-$t$ connectivity (USTCON) is in $L$. Since $H$ is an undirected graph whose neighbor function is computable in $O(\\log n)$ space and whose size has logarithm $O(\\log n)$, applying the USTCON algorithm to decide whether $(s,0)$ is connected to $(t,\\ell)$ is doable in deterministic logarithmic space for each $\\ell \\in \\{0,1,\\dots,k\\}$. Running these $k+1=O(\\log n)$ checks sequentially reuses the $O(\\log n)$ work tape; time remains polynomial because Reingold’s algorithm runs in polynomial time and we repeat it $O(\\log n)$ times.\n\nTherefore, the language LOG-PATH is in $L$. This rules out NL-completeness unless $L=NL$, rules out containment “in P but not in NL,” rules out PSPACE-completeness, and it is certainly not “the same as” directed $s$-$t$ connectivity (which is NL-complete). The correct choice is that LOG-PATH is in $L$.",
            "answer": "$$\\boxed{B}$$"
        }
    ]
}