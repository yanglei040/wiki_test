{
    "hands_on_practices": [
        {
            "introduction": "Before we can analyze the complexity of the algorithm in Savitch's theorem, we must first quantify the size of the problem it solves. The algorithm searches for a path in a graph where each node represents a configuration of a Nondeterministic Turing Machine (NTM). This exercise guides you through calculating the total number of these distinct configurations, a foundational step that connects the NTM's space bound, $S(n)$, to the size of the search space the simulation must navigate .",
            "id": "1437894",
            "problem": "In the study of computational complexity, understanding the resource usage of abstract machines is fundamental. Consider a single-tape Nondeterministic Turing Machine (NTM). A configuration of such a machine at any point in time is completely described by three components: its current internal state, the entire content written on its work tape, and the current position of its tape head.\n\nLet this NTM have a set of states $Q$ and a tape alphabet $\\Sigma$. The machine is designed to have a space complexity of $f(n) = c \\log_2 n$ for an input of size $n$, where $c$ is a positive real constant. This means that for any input of size $n$, the machine uses at most $f(n)$ cells on its work tape.\n\nDerive a simplified, explicit formula for the maximum number of distinct configurations this NTM can be in. Express your answer as a function of the number of states $|Q|$, the size of the tape alphabet $|\\Sigma|$, the constant $c$, and the input size $n$.",
            "solution": "A configuration is determined by:\n- the current internal state (number of choices: $|Q|$),\n- the entire content on the work tape over the cells that may be used (each of at most $f(n)$ cells can contain any of $|\\Sigma|$ symbols, giving $|\\Sigma|^{f(n)}$ possibilities),\n- the head position on the work tape (at most $f(n)$ choices).\n\nThus, the maximum number of distinct configurations allowed by the space bound is\n$$\nN_{\\max}(n)=|Q|\\cdot f(n)\\cdot |\\Sigma|^{f(n)}.\n$$\nWith $f(n)=c\\log_{2}(n)$, this becomes\n$$\nN_{\\max}(n)=|Q|\\cdot c\\log_{2}(n)\\cdot |\\Sigma|^{c\\log_{2}(n)}.\n$$\nUsing the identity $a^{\\log_{b}(x)}=x^{\\log_{b}(a)}$ with $a=|\\Sigma|$ and $b=2$, we simplify\n$$\n|\\Sigma|^{c\\log_{2}(n)}=n^{c\\log_{2}(|\\Sigma|)}.\n$$\nTherefore, an explicit simplified expression is\n$$\nN_{\\max}(n)=|Q|\\cdot c\\log_{2}(n)\\cdot n^{c\\log_{2}(|\\Sigma|)}.\n$$",
            "answer": "$$\\boxed{|Q|\\cdot c\\log_{2}(n)\\cdot n^{c\\log_{2}(|\\Sigma|)}}$$"
        },
        {
            "introduction": "The core of Savitch's theorem is its elegant, space-efficient recursive algorithm for determining reachability between configurations. To truly grasp this \"divide and conquer\" strategy, it is invaluable to trace its execution on a concrete example. This practice asks you to map out the initial recursive calls of the `REACH` procedure, providing a clear view of how the algorithm breaks a large path-finding problem into smaller, nested subproblems .",
            "id": "1437866",
            "problem": "In computational complexity theory, Savitch's theorem is proven using a recursive algorithm that determines if a configuration $C_{final}$ is reachable from a configuration $C_{initial}$ in a non-deterministic computation. Consider a version of this algorithm, `REACH(C_1, C_2, k)`, which returns `true` if configuration $C_2$ is reachable from $C_1$ in at most $2^k$ steps, and `false` otherwise. The algorithm is defined as follows:\n\n**Algorithm: `REACH(C_1, C_2, k)`**\n1.  If $k=0$, check if $C_1 = C_2$ or if $C_2$ can be reached from $C_1$ in a single computation step. If so, return `true`; otherwise, return `false`.\n2.  If $k > 0$, loop through all possible intermediate configurations $C_{mid}$. For each $C_{mid}$:\n    a. Call `REACH(C_1, C_{mid}, k-1)`.\n    b. Call `REACH(C_{mid}, C_2, k-1)`.\n    c. If both of these recursive calls return `true`, then stop and return `true`.\n3.  If the loop finishes without finding such a $C_{mid}$, return `false`.\n\nSuppose we initiate a check for reachability between a start configuration $C_{start}$ and an accepting configuration $C_{accept}$ within at most 16 steps, using the call `REACH(C_{start}, C_{accept}, 4)`. This initial call is considered Level 0 of the recursion. The recursive calls made directly by a Level 0 call are Level 1 calls. The recursive calls made directly by any Level 1 call are Level 2 calls.\n\nWhich of the following options correctly describes the complete set of generic forms for the recursive calls made at Level 2? In the options below, $C_i$, $C_j$, and $C_k$ represent existentially quantified intermediate configurations at different stages of the search.\n\nA. `REACH(C_{start}, C_i, 2)` and `REACH(C_i, C_{accept}, 2)`\n\nB. `REACH(C_{start}, C_j, 2)`, `REACH(C_j, C_i, 2)`, `REACH(C_i, C_k, 2)`, and `REACH(C_k, C_{accept}, 2)`\n\nC. `REACH(C_{start}, C_i, 3)` and `REACH(C_i, C_{accept}, 3)`\n\nD. `REACH(C_{start}, C_j, 4)` and `REACH(C_j, C_i, 4)`\n\nE. `REACH(C_{start}, C_{accept}, 2)`",
            "solution": "We start from the Level 0 call, which is the initial invocation $REACH(C_{start}, C_{accept}, 4)$. Since $k=4>0$, by the algorithm it loops over all intermediate configurations $C_{i}$ and, for each $C_{i}$, makes two recursive calls with parameter $k-1=3$. Therefore, the Level 1 calls generated by Level 0 are exactly of the form\n$$REACH(C_{start}, C_{i}, 3) \\quad \\text{and} \\quad REACH(C_{i}, C_{accept}, 3).$$\n\nEach Level 1 call itself has $k=3>0$, so it again loops over all intermediate configurations and makes two calls with parameter $k-1=2$. Thus, for a Level 1 call $REACH(C_{start}, C_{i}, 3)$, the Level 2 calls it makes are, for all intermediate $C_{j}$,\n$$REACH(C_{start}, C_{j}, 2) \\quad \\text{and} \\quad REACH(C_{j}, C_{i}, 2).$$\nSimilarly, for a Level 1 call $REACH(C_{i}, C_{accept}, 3)$, the Level 2 calls it makes are, for all intermediate $C_{k}$,\n$$REACH(C_{i}, C_{k}, 2) \\quad \\text{and} \\quad REACH(C_{k}, C_{accept}, 2).$$\n\nCollecting all Level 2 calls produced by the two families of Level 1 calls, the complete set of generic forms at Level 2 is\n$$REACH(C_{start}, C_{j}, 2), \\quad REACH(C_{j}, C_{i}, 2), \\quad REACH(C_{i}, C_{k}, 2), \\quad REACH(C_{k}, C_{accept}, 2),$$\nwhich matches option B.\n\nTo see why the other options are incorrect:\n- Option A lists $REACH(C_{start}, C_{i}, 2)$ and $REACH(C_{i}, C_{accept}, 2)$, but at Level 2 the calls use fresh intermediate configurations $C_{j}$ and $C_{k}$ within each Level 1 branch; the pair in A does not capture the cross-branch structure and is not the complete set.\n- Option C uses $k=3$, which corresponds to Level 1, not Level 2.\n- Option D uses $k=4$, which is the parameter of the Level 0 call, not Level 2.\n- Option E is a single special-case call that could occur only if an intermediate equals $C_{accept}$ or $C_{start}$, but it does not describe the complete set of generic forms.\n\nTherefore, the correct choice is B.",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "Savitch's theorem famously establishes that $\\text{NSPACE}(S(n)) \\subseteq \\text{DSPACE}(S(n)^2)$. But is this quadratic relationship merely an artifact of splitting the computation path in half? This final exercise  challenges you to re-evaluate the space complexity using a modified algorithm that splits the path into three segments, testing your understanding of why the asymptotic result is robust and how logarithmic factors behave in complexity analysis.",
            "id": "1437849",
            "problem": "In computational complexity theory, Savitch's theorem demonstrates that any problem solvable by a Nondeterministic Turing Machine (NTM) using a certain amount of space can also be solved by a Deterministic Turing Machine (DTM) using a quadratically larger amount of space. Specifically, it shows that `NSPACE(S(n)) ⊆ DSPACE(S(n)^2)` for any space-constructible function $S(n) \\ge \\log n$.\n\nThe proof relies on a recursive algorithm to determine if a configuration $c_2$ is reachable from a configuration $c_1$ in the NTM's computation graph. Let the maximum number of configurations of an NTM for an input of size $n$ be $N$. The standard algorithm, let's call it `CAN-REACH(c_start, c_end, k)`, checks for a path of length at most $2^k$ from `c_start` to `c_end`. For $k>0$, it does this by iterating through every possible intermediate configuration $c_{mid}$ and recursively checking for paths from `c_start` to $c_{mid}$ and from $c_{mid}$ to `c_end`, both of length at most $2^{k-1}$. This binary splitting of the path leads to the $O(S(n)^2)$ space complexity result, as the recursion depth is $O(\\log N)$ and storing a configuration requires $O(S(n))$ space, where $\\log N$ is proportional to $S(n)$.\n\nNow, consider a modified recursive algorithm, `TRI-REACH(c_start, c_end, i)`, designed to solve the same reachability problem. This new algorithm checks for a path of length at most $3^i$. For $i>0$, `TRI-REACH` works by iterating through all possible pairs of intermediate configurations, $(c_{mid1}, c_{mid2})$, and recursively verifying the following three sub-problems:\n1. A path exists from $c_{start}$ to $c_{mid1}$ of length at most $3^{i-1}$.\n2. A path exists from $c_{mid1}$ to $c_{mid2}$ of length at most $3^{i-1}$.\n3. A path exists from $c_{mid2}$ to $c_{end}$ of length at most $3^{i-1}$.\n\nIf for some pair $(c_{mid1}, c_{mid2})$ all three recursive checks succeed, the algorithm returns true. Otherwise, it returns false. Assume a DTM uses this `TRI-REACH` algorithm to simulate an NTM that has a space complexity of $S(n)$. What is the space complexity of this simulation, expressed in big-O notation in terms of $S(n)$?",
            "solution": "Let $S(n)$ be the space bound of the NTM and let $N$ be the number of distinct configurations on inputs of size $n$. For a fixed machine, there exists a constant $\\alpha>1$ such that\n$$\nN \\le \\alpha^{S(n)} \\cdot \\operatorname{poly}(n),\n$$\nhence\n$$\n\\log_{2} N = \\Theta(S(n)),\n$$\nusing the assumption $S(n) \\ge \\log_{2} n$.\n\nThe procedure $\\operatorname{TRI-REACH}(c_{\\text{start}},c_{\\text{end}},i)$ decides reachability within paths of length at most $3^{i}$. To cover all possible paths, it suffices to take\n$$\ni^{\\ast}=\\lceil \\log_{3} N \\rceil,\n$$\nso the recursion depth is\n$$\nd = i^{\\ast} = \\Theta(\\log_{3} N) = \\Theta(\\log_{2} N).\n$$\n\nAt any recursion level, the DTM must store:\n- The parameters $c_{\\text{start}}$ and $c_{\\text{end}}$ for that call.\n- The loop variables encoding the current pair $(c_{\\text{mid1}},c_{\\text{mid2}})$.\n- The level parameter $i$.\n\nEach configuration requires $O(S(n))$ space to represent, and storing the loop indices costs $O(\\log_{2} N)=O(S(n))$ bits, which is dominated by storing a constant number of configurations. Therefore the space per recursion level is\n$$\nO(S(n)).\n$$\n\nBecause the recursive subcalls are performed depth-first and sequentially, the total space is the product of per-level space and recursion depth:\n$$\n\\text{Space}(n) = O\\big(S(n) \\cdot \\log_{3} N\\big).\n$$\nUsing $\\log_{3} N = \\frac{\\log_{2} N}{\\log_{2} 3} = \\Theta(\\log_{2} N)$ and $\\log_{2} N = \\Theta(S(n))$, we obtain\n$$\n\\text{Space}(n) = O\\big(S(n) \\cdot S(n)\\big) = O\\big(S(n)^{2}\\big).\n$$\n\nThus, despite splitting paths into three segments and iterating over pairs of intermediate configurations, the asymptotic space complexity remains the same as in Savitch’s original algorithm up to constant factors.",
            "answer": "$$\\boxed{O\\left(S(n)^2\\right)}$$"
        }
    ]
}