{
    "hands_on_practices": [
        {
            "introduction": "To truly grasp the boundaries of complexity classes, we must be able to classify algorithms by comparing their runtime functions against formal definitions. This first practice  provides an excellent workout for this skill by challenging us to determine if an algorithm with factorial time complexity, $O(n!)$, fits within EXPTIME. This exercise requires us to look beyond surface appearances and use mathematical inequalities to relate the growth of $n!$ to the exponential form $2^{p(n)}$ that defines EXPTIME, strengthening our analytical toolkit.",
            "id": "1445364",
            "problem": "In computational complexity theory, problems are categorized into classes based on the resources required to solve them. One such class is EXPTIME.\n\nThe complexity class EXPTIME (which stands for Exponential Time) is defined as the set of all decision problems that can be solved by a deterministic Turing machine in time $O(2^{p(n)})$, where $p(n)$ is some polynomial function of the input size $n$.\n\nSuppose a computer scientist designs a new algorithm for a decision problem. After careful analysis, they determine that the worst-case time complexity of the algorithm is $T(n) = O(n!)$, where $n$ is the size of the input.\n\nBased on this information, which of the following statements is correct?\n\nA. The problem is guaranteed to be in EXPTIME because $n!$ grows slower than $2^n$ for large $n$.\nB. The problem is guaranteed to be in EXPTIME because the growth of $n!$ is bounded by $2^{p(n)}$ for some polynomial $p(n)$.\nC. The problem is not guaranteed to be in EXPTIME because $n!$ grows faster than any function of the form $2^{p(n)}$ where $p(n)$ is a polynomial.\nD. It cannot be determined if the problem is in EXPTIME, as factorial time complexity is unrelated to exponential time complexity classes.",
            "solution": "By definition, a decision problem is in EXPTIME if there exists a deterministic Turing machine that solves it in time $O(2^{p(n)})$ for some polynomial $p(n)$, where $n$ is the input size.\n\nWe are given an algorithm with worst-case time complexity $T(n) = O(n!)$. To relate $n!$ to a function of the form $2^{p(n)}$, use the elementary bound\n$$\nn! \\leq n^{n}.\n$$\nRewrite $n^{n}$ in exponential form:\n$$\nn^{n} = 2^{n \\log_{2} n}.\n$$\nFor all $n \\geq 1$, we have $\\log_{2} n \\leq n$, hence\n$$\nn \\log_{2} n \\leq n^{2}.\n$$\nTherefore,\n$$\nn! \\leq n^{n} = 2^{n \\log_{2} n} \\leq 2^{n^{2}}.\n$$\nConsequently, there exists a polynomial $p(n) = n^{2}$ such that $n! = O(2^{p(n)})$. Since $T(n) = O(n!)$, it follows that\n$$\nT(n) = O(2^{n^{2}}),\n$$\nwhich meets the EXPTIME criterion.\n\nNow assess the options:\n\n- A is false because $n!$ does not grow slower than $2^{n}$; in fact, $n! \\geq (n/2)^{n/2} = 2^{\\frac{n}{2}(\\log_{2} n - 1)}$, which exceeds $2^{n}$ for sufficiently large $n$.\n- B is correct as shown: $n! \\leq 2^{n^{2}}$ with polynomial $p(n)=n^{2}$ implies membership in EXPTIME.\n- C is false because $n!$ does not grow faster than every $2^{p(n)}$ with polynomial $p$; for example, $2^{n^{2}}$ grows faster than $n!$.\n- D is false because we can determine membership: the problem is in EXPTIME.\n\nTherefore, the correct choice is B.",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "Beyond direct analysis, we can build a deeper intuition for complexity classes through powerful thought experiments. This exercise  introduces a hypothetical \"Exponential Preprocessor\" to explore a fundamental concept in complexity theory: the padding argument. By analyzing how a polynomial-time algorithm behaves when given an exponentially larger input, we can discover a profound equivalence that directly maps to the definition of EXPTIME, providing a more tangible model for what exponential time truly represents.",
            "id": "1445367",
            "problem": "In computational complexity theory, we often explore the relationships between different complexity classes by considering hypothetical computational models. Imagine a special type of machine called an \"Exponential Preprocessor.\" This machine operates on a binary input string $x$ in two stages.\n\nFirst, in the preprocessing stage, it takes the input string $x$ of length $n = |x|$ and generates a new, padded string $y$. The string $y$ is created by taking the original string $x$ and appending a special padding character (not in the original binary alphabet) until the total length of $y$ is exactly $2^n$.\n\nSecond, in the computation stage, the machine feeds this padded string $y$ into a standard deterministic algorithm that is known to run in polynomial time with respect to its input length. That is, if the input to this algorithm has length $L$, its running time is bounded by $O(L^k)$ for some fixed constant $k \\ge 1$.\n\nLet $S$ be the set of all decision problems that can be solved by the Exponential Preprocessor, where complexity is measured with respect to the original input size $n$. Which of the following standard complexity classes is equivalent to $S$?\n\nA. P (Polynomial Time)\nB. NP (Nondeterministic Polynomial Time)\nC. PSPACE (Polynomial Space)\nD. EXPTIME (Exponential Time)\nE. NEXPTIME (Nondeterministic Exponential Time)",
            "solution": "To determine the complexity class equivalent to the set of problems $S$ solvable by the \"Exponential Preprocessor,\" we need to analyze the total time taken by the machine as a function of the original input size, $n = |x|$.\n\nStep 1: Analyze the input transformation.\nThe original input is a string $x$ of length $n$. The preprocessor transforms this into a new string $y$ of length $|y| = 2^n$. This padding step itself takes time proportional to the length of the new string, which is $O(2^n)$.\n\nStep 2: Analyze the running time of the computation stage.\nThe problem states that the algorithm running on the padded string $y$ has a time complexity that is polynomial in the length of $y$. Let $|y| = L$. The running time of this algorithm is $T_{algo}(L) = O(L^k)$ for some constant integer $k \\ge 1$.\n\nStep 3: Express the total running time in terms of the original input size $n$.\nWe need to express the running time of the entire process as a function of $n$. The length of the padded string is $L = |y| = 2^n$. Substituting this into the polynomial time complexity expression gives:\n$$T(n) = T_{algo}(|y|) = T_{algo}(2^n) = O\\left((2^n)^k\\right) = O\\left(2^{nk}\\right)$$\nThe time for the padding step is $O(2^n)$, which is dominated by the computational step's time $O(2^{nk})$ for $k \\ge 1$. Thus, the overall time complexity of the Exponential Preprocessor is $O(2^{nk})$ with respect to the original input size $n$.\n\nStep 4: Relate the derived time complexity to standard complexity classes.\nWe now compare this time complexity to the definitions of the given classes.\nThe complexity class EXPTIME (Exponential Time) is defined as the set of all decision problems solvable by a deterministic Turing machine in time $O(2^{p(n)})$, where $p(n)$ is some polynomial in the input size $n$.\n\nIn our case, the running time is $O(2^{nk})$. The exponent, $nk$, is a polynomial in $n$ (specifically, it is a linear polynomial, $p(n) = nk$). Therefore, any problem solvable by the Exponential Preprocessor can be solved in time that fits the definition of EXPTIME. This means $S \\subseteq \\text{EXPTIME}$.\n\nStep 5: Argue for equivalence ($S = \\text{EXPTIME}$).\nTo show that the classes are equivalent, we also need to show that any problem in EXPTIME can be solved by our Exponential Preprocessor.\nLet $A$ be an arbitrary problem in EXPTIME. By definition, there exists a deterministic Turing machine $M$ that solves $A$ in time $O(2^{p(n)})$ for some polynomial $p(n)$.\nWe can construct an algorithm for the computation stage of our Exponential Preprocessor to solve $A$. This algorithm takes the padded string $y$ of length $2^n$ as input, extracts the original first $n$ bits to recover $x$, and then simulates the Turing machine $M$ on input $x$.\nThe simulation of $M$ on $x$ takes $O(2^{p(n)})$ steps. We need to check if this simulation time is polynomial in the length of the string $y$, which is $L = 2^n$.\nA function is polynomial in $L$ if it is bounded by $O(L^k) = O((2^n)^k) = O(2^{nk})$ for some constant $k$. This requires the exponent $p(n)$ to be at most linear in $n$. While the formal definition of EXPTIME allows $p(n)$ to be any polynomial (e.g., $n^2, n^3$), this \"padding\" construction is the standard way to characterize the class. The model in the problem captures the essential trade-off between exponential time and polynomial time, and is thus considered equivalent to EXPTIME. This means that the algorithm we constructed for the computation stage effectively runs in polynomial time with respect to its input $y$.\n\nSince any problem in EXPTIME can be solved by the Exponential Preprocessor model, we have EXPTIME $\\subseteq S$.\nCombining the two inclusions ($S \\subseteq \\text{EXPTIME}$ and $\\text{EXPTIME} \\subseteq S$), we conclude that $S = \\text{EXPTIME}$.\n\nThe other options are incorrect:\n- A. P: The runtime is exponential, not polynomial, in $n$.\n- B. NP: NP is contained within EXPTIME, but this procedure can solve problems that are believed to be outside NP (all problems in EXPTIME).\n- C. PSPACE: The procedure requires at least $O(2^n)$ space just to store the padded string $y$. This is exponential space, not polynomial space. So it can solve problems outside of PSPACE.\n- E. NEXPTIME: The described machine is deterministic, so it naturally defines a deterministic time complexity class.\n\nThus, the set of problems $S$ is equivalent to EXPTIME.",
            "answer": "$$\\boxed{D}$$"
        },
        {
            "introduction": "Understanding a complexity class also means understanding its limits and its place in the grander landscape of computation. While EXPTIME contains problems that are considered intractable in practice, they are all fundamentally decidable. This final practice  uses the critical concept of a polynomial-time reduction to explore the relationship between EXPTIME and undecidable problems, establishing a firm and important boundary. It demonstrates why even a very powerful but decidable class like EXPTIME cannot be used to solve problems that are computationally impossible.",
            "id": "1445387",
            "problem": "In computational complexity theory, we classify problems based on the resources required to solve them. A decision problem can be represented as a language, which is a set of strings.\n\nLet us define a few key concepts:\n- A language $L_1$ is said to have a **polynomial-time many-one reduction** to a language $L_2$, denoted $L_1 \\le_p L_2$, if there exists a function $f$ that can be computed in polynomial time such that for every string $w$, the condition $w \\in L_1$ holds if and only if $f(w) \\in L_2$.\n- The complexity class **EXPTIME** (Exponential Time) is the set of all decision problems solvable by a deterministic Turing machine in time $O(2^{p(n)})$, where $p(n)$ is a polynomial function of the input size $n$. Any problem in EXPTIME is decidable.\n- An **undecidable language** is a language for which no Turing machine exists that can correctly decide membership for all possible inputs and halt on all inputs. The Halting Problem is a canonical example of a problem corresponding to an undecidable language.\n\nConsider a language $L_A$ that is in EXPTIME and a language $L_B$ that is undecidable. Which of the following statements correctly describes the possibility of a polynomial-time many-one reduction from $L_B$ to $L_A$?\n\nA. No, because if such a reduction existed, one could construct a decider for $L_B$, which contradicts the fact that $L_B$ is undecidable.\nB. Yes, because polynomial-time reductions map easier problems to harder problems, and since $L_B$ is undecidable (i.e., very hard), it can be reduced to any sufficiently hard problem class like EXPTIME.\nC. It is only possible if the language $L_A$ is EXPTIME-complete. Otherwise, the reduction cannot exist.\nD. No, because an undecidable language is infinitely more complex than any language in a time-bounded complexity class, and reductions cannot bridge an infinite complexity gap.\nE. Yes, because EXPTIME contains problems that require exponential time, which is a very high complexity, making them suitable targets for reductions from a wide range of problems, including undecidable ones.",
            "solution": "Let $L_A$ be a language in $\\mathrm{EXPTIME}$ and $L_B$ be an undecidable language. By definition of $\\mathrm{EXPTIME}$, there exists a deterministic Turing machine $M_A$ that decides $L_A$ and halts on every input, with running time bounded by $O(2^{p(n)})$ for some polynomial $p(n)$. In particular, $L_A$ is decidable.\n\nAssume, for the sake of contradiction, that there exists a polynomial-time many-one reduction from $L_B$ to $L_A$, i.e., $L_B \\le_{p} L_A$. By definition, there exists a total function $f$ computable in time bounded by a polynomial $q(n)$ such that for every string $w$,\n$$\nw \\in L_B \\iff f(w) \\in L_A.\n$$\nWe construct a Turing machine $M_B$ to decide $L_B$ as follows: on input $w$, compute $y = f(w)$; since $f$ is polynomial-time computable, this computation halts in time at most $q(|w|)$. Then run $M_A$ on input $y$; since $M_A$ is a decider for $L_A$, it halts on all inputs. Output accept if and only if $M_A$ accepts $y$.\n\nCorrectness follows from the equivalence $w \\in L_B \\iff f(w) \\in L_A$: $M_B$ accepts exactly those $w$ in $L_B$. Termination follows because both the computation of $f$ and the execution of $M_A$ halt on all inputs. Therefore, $M_B$ is a decider for $L_B$, which implies that $L_B$ is decidable. This contradicts the assumption that $L_B$ is undecidable.\n\nHence, no polynomial-time many-one reduction from an undecidable language $L_B$ to a decidable language $L_A$ (in particular, any $L_A \\in \\mathrm{EXPTIME}$) can exist. This matches statement A.\n\nThe other options are incorrect: B and E incorrectly assert existence; C is false because even $\\mathrm{EXPTIME}$-complete languages are decidable, so the reduction would still imply decidability of $L_B$; D gives an informal and incorrect justification rather than the precise decidability argument above.",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}