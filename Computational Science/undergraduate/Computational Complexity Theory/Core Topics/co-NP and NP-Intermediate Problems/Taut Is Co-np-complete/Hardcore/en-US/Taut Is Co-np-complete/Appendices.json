{
    "hands_on_practices": [
        {
            "introduction": "The proof that the tautology problem, **TAUT**, is co-NP-complete hinges on a transformation from the known co-NP-complete problem **UNSAT**. This exercise challenges you to discover this fundamental reduction, which relies on the inherent duality between a formula being unsatisfiable and its negation being a tautology . Mastering this link is the essential first step toward grasping the deep structural relationship between satisfiability and tautology in complexity theory.",
            "id": "1449002",
            "problem": "In computational complexity theory, showing that a problem is hard for a certain complexity class often involves a reduction from a known hard problem. A cornerstone of this field is the relationship between the satisfiability problem and the tautology problem.\n\nLet a Boolean formula $\\phi$ be given in 3-Conjunctive Normal Form (3-CNF). A formula is in 3-CNF if it is a conjunction (AND) of clauses, where each clause is a disjunction (OR) of exactly three distinct literals (a variable or its negation).\n\nA Boolean formula is said to be **unsatisfiable** if it evaluates to False for every possible assignment of truth values to its variables. The problem of determining if a 3-CNF formula is unsatisfiable is known as **3-UNSAT**.\nA Boolean formula is called a **tautology** if it evaluates to True for every possible assignment of truth values to its variables. The problem of determining if a formula is a tautology is known as **TAUT**.\n\nYour task is to find a general transformation that constructs a new formula, $\\psi$, from an arbitrary 3-CNF formula, $\\phi$, such that $\\phi$ is unsatisfiable if and only if $\\psi$ is a tautology. Which of the following constructions correctly defines such a $\\psi$?\n\nA. $\\psi = \\phi$\n\nB. $\\psi = \\neg \\phi$\n\nC. Let $\\phi = C_1 \\land C_2 \\land \\dots \\land C_k$, where each $C_i$ is a clause. The new formula is $\\psi = (\\neg C_1) \\land (\\neg C_2) \\land \\dots \\land (\\neg C_k)$.\n\nD. Let $\\phi = C_1 \\land C_2 \\land \\dots \\land C_k$, where each $C_i$ is a clause. The new formula is $\\psi = C_1 \\lor C_2 \\lor \\dots \\lor C_k$.\n\nE. Let $x$ be one of the boolean variables appearing in $\\phi$. The new formula is $\\psi = \\phi \\land (x \\lor \\neg x)$.",
            "solution": "We seek a transformation that, for any given 3-CNF formula $\\phi$, produces a formula $\\psi$ such that $\\phi$ is unsatisfiable if and only if $\\psi$ is a tautology.\n\nLet $\\sigma$ range over all truth assignments to the variables of $\\phi$. Write $\\phi[\\sigma]$ for the truth value of $\\phi$ under $\\sigma$. By definition:\n- $\\phi$ is unsatisfiable if and only if $\\forall \\sigma,\\ \\phi[\\sigma] = \\mathrm{False}$.\n- $\\psi$ is a tautology if and only if $\\forall \\sigma,\\ \\psi[\\sigma] = \\mathrm{True}$.\n\nConsider the transformation $\\psi = \\neg \\phi$. Boolean semantics of negation satisfy, for every $\\sigma$,\n$$(\\neg \\phi)[\\sigma] = \\neg\\big(\\phi[\\sigma]\\big).$$\nTherefore,\n$$\\phi \\text{ unsatisfiable} \\iff \\forall \\sigma,\\ \\phi[\\sigma] = \\mathrm{False} \\iff \\forall \\sigma,\\ \\neg\\big(\\phi[\\sigma]\\big) = \\mathrm{True} \\iff \\forall \\sigma,\\ (\\neg \\phi)[\\sigma] = \\mathrm{True} \\iff \\neg \\phi \\text{ is a tautology}.$$\nThus the correct construction is $\\psi = \\neg \\phi$, which is option B.\n\nTo confirm the other options are incorrect:\n- A: $\\psi = \\phi$ cannot satisfy the biconditional in general, since an unsatisfiable formula is never a tautology.\n- C: If $\\phi = \\bigwedge_{i=1}^{k} C_{i}$, then $\\psi = \\bigwedge_{i=1}^{k} \\neg C_{i} = \\neg\\big(\\bigvee_{i=1}^{k} C_{i}\\big)$ by De Morgan’s law, which is not $\\neg \\phi = \\bigvee_{i=1}^{k} \\neg C_{i}$; hence it does not implement the required equivalence.\n- D: $\\psi = \\bigvee_{i=1}^{k} C_{i}$ does not become a tautology exactly when $\\phi$ is unsatisfiable; unsatisfiability of $\\phi$ does not imply that every assignment makes at least one $C_{i}$ true, which would be required for this disjunction to be a tautology.\n- E: $\\psi = \\phi \\land (x \\lor \\neg x)$ is logically equivalent to $\\phi$ because $x \\lor \\neg x$ is a tautology, so it does not convert an arbitrary $\\phi$ into a tautology exactly when $\\phi$ is unsatisfiable.\n\nTherefore, the only correct transformation among the options is $\\psi = \\neg \\phi$ (option B).",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "A correct proof requires precision, and a common pitfall is to misapply the formal definition of a reduction. This problem presents a seemingly plausible but flawed argument that attempts to prove **TAUT**'s hardness by reducing from **SAT** instead of **UNSAT** . By dissecting the logical error, you will solidify your understanding of what constitutes a valid reduction and appreciate the crucial distinction between proving a problem is NP-hard versus co-NP-hard.",
            "id": "1448966",
            "problem": "In a computational complexity theory class, a student named Alex is trying to prove that the Tautology problem (**TAUT**) is **co-NP-hard**. The **TAUT** problem asks whether a given Boolean formula is a tautology, meaning it is true for every possible assignment of truth values to its variables.\n\nAlex proposes the following argument:\n\n\"Let's show that **TAUT** is **co-NP-hard** by providing a polynomial-time reduction from the Boolean Satisfiability Problem (**SAT**). **SAT** is the problem of determining if there exists an assignment of truth values that makes a given Boolean formula true. It is a well-known **NP-complete** problem.\n\nMy reduction function, $f$, takes a Boolean formula $\\phi$ as input and outputs its negation, $\\neg\\phi$. This function is clearly computable in polynomial time.\n\nNow, consider the relationship: A formula $\\phi$ has a satisfying assignment (i.e., $\\phi \\in \\text{SAT}$) if and only if its negation, $\\neg\\phi$, is a tautology (i.e., $f(\\phi) \\in \\text{TAUT}$). Since I have reduced an **NP-complete** problem (**SAT**) to **TAUT**, this proves that **TAUT** must be at least as hard as the complement of **NP** problems, which means **TAUT** is **co-NP-hard**.\"\n\nWhich of the following statements provides the most accurate evaluation of Alex's argument?\n\nA. Alex's argument is correct. The function $f$ is a valid polynomial-time reduction from **SAT** to **TAUT**, and since **SAT** is **NP-complete**, this proves **TAUT** is **co-NP-hard**.\n\nB. Alex's argument is flawed because the function $f(\\phi) = \\neg \\phi$ takes exponential time to compute, as it requires evaluating all possible truth assignments of the formula.\n\nC. Alex's argument is flawed because **TAUT** is known to be in **P**, so it cannot be **co-NP-hard** (unless **P** = **co-NP**). The reduction itself must therefore be invalid.\n\nD. Alex's argument is flawed because his proposed reduction from **SAT** to **TAUT** would only prove that **TAUT** is **NP-hard**, not **co-NP-hard**. However, the reduction itself is valid.\n\nE. Alex's argument is flawed because the function $f(\\phi) = \\neg \\phi$ is not a reduction from **SAT** to **TAUT**. The core condition of the reduction is not met.",
            "solution": "We recall the definition of a polynomial-time many-one (Karp) reduction. For languages $A$ and $B$, a function $f$ is a reduction from $A$ to $B$ if $f$ is computable in time polynomial in the input size and for all inputs $x$,\n$$\nx \\in A \\Leftrightarrow f(x) \\in B.\n$$\nTo show that a language $B$ is **co-NP-hard** under Karp reductions, one must reduce a **co-NP**-complete language to $B$ (or more generally, every language in **co-NP** reduces to $B$). A standard **co-NP**-complete language is $\\text{UNSAT} = \\overline{\\text{SAT}}$.\n\nLet us specify the problems precisely. For a Boolean formula $\\phi$:\n- $\\phi \\in \\text{SAT} \\Leftrightarrow \\exists a:\\ \\phi(a)=\\text{true}$.\n- $\\psi \\in \\text{TAUT} \\Leftrightarrow \\forall a:\\ \\psi(a)=\\text{true}$.\n- $\\phi \\in \\text{UNSAT} \\Leftrightarrow \\forall a:\\ \\phi(a)=\\text{false}$.\n\nConsider $f(\\phi)=\\neg \\phi$. The function $f$ is computable in polynomial time in the size of $\\phi$ by syntactically negating the formula; no evaluation over assignments is required.\n\nNow analyze the key logical relation that a valid reduction must satisfy. For all $\\phi$ and all assignments $a$,\n$$\n\\phi(a)=\\text{true} \\Rightarrow \\neg \\phi(a)=\\text{false}.\n$$\nTherefore,\n$$\n\\phi \\in \\text{SAT} \\Rightarrow \\neg \\phi \\notin \\text{TAUT}.\n$$\nConversely, if $\\neg \\phi$ is a tautology, then for all $a$, $\\neg \\phi(a)=\\text{true}$, hence for all $a$, $\\phi(a)=\\text{false}$, so\n$$\n\\neg \\phi \\in \\text{TAUT} \\Rightarrow \\phi \\in \\text{UNSAT}.\n$$\nCombining, we obtain the correct equivalence:\n$$\n\\phi \\in \\text{UNSAT} \\Leftrightarrow \\neg \\phi \\in \\text{TAUT}.\n$$\nThus $f(\\phi)=\\neg \\phi$ is a valid Karp reduction from **UNSAT** to **TAUT**, establishing that **TAUT** is **co-NP-hard** (indeed **co-NP**-complete).\n\nAlex, however, claims the incorrect equivalence\n$$\n\\phi \\in \\text{SAT} \\Leftrightarrow \\neg \\phi \\in \\text{TAUT},\n$$\nwhich fails as shown above. The correct relation is\n$$\n\\phi \\in \\text{SAT} \\Leftrightarrow \\neg \\phi \\notin \\text{TAUT}.\n$$\nTherefore, the proposed $f$ is not a valid reduction from **SAT** to **TAUT**, and Alex’s reasoning does not establish **co-NP**-hardness via that route. Additionally, even if one had a valid reduction from **SAT** to **TAUT**, that would at best show **TAUT** is **NP-hard**, not **co-NP-hard**; to prove **co-NP**-hardness one reduces from **co-NP** languages.\n\nEvaluate the options:\n- A is false because the core equivalence is wrong, so $f$ is not a valid reduction from **SAT** to **TAUT**.\n- B is false because $f$ is computable in polynomial time; no exponential-time evaluation is needed.\n- C is false; **TAUT** is not known to be in **P** (it is **co-NP**-complete).\n- D is false because it asserts the reduction is valid; it is not valid due to the failed equivalence.\n- E is correct: $f(\\phi)=\\neg \\phi$ does not satisfy the required condition for a reduction from **SAT** to **TAUT**.\n\nTherefore, the most accurate evaluation is E.",
            "answer": "$$\\boxed{E}$$"
        },
        {
            "introduction": "Beyond proving hardness, it is important to understand the algorithmic power that a **TAUT** solver would grant us. This exercise explores how to leverage a hypothetical oracle for the **TAUT** decision problem to solve the related search problem of finding a falsifying assignment for a non-tautology . By stepping through this search-to-decision reduction, you will gain hands-on experience with a powerful and widely used technique in computational complexity.",
            "id": "1448990",
            "problem": "In computational complexity theory, an oracle for a decision problem is a hypothetical black box that can solve that problem in a single step. Consider an oracle, `IS_TAUT`, which determines if a given Boolean formula is a tautology. A formula is a tautology if it evaluates to True for every possible truth assignment to its variables.\n\nSuppose you are given a Boolean formula $\\phi(x_1, x_2, \\ldots, x_n)$ in $n$ variables, and you know that $\\phi$ is *not* a tautology. This means there exists at least one \"falsifying assignment\"—a specific set of True/False values for the variables—that makes the formula $\\phi$ evaluate to False.\n\nThere exists a standard polynomial-time algorithm that finds one such falsifying assignment, given access to the `IS_TAUT` oracle. This algorithm operates by sequentially determining the truth value for each variable, from $x_1$ to $x_n$. To do this, it constructs new formulas by substituting truth values for variables and queries the oracle to decide which path preserves the possibility of a falsifying assignment.\n\nConsider the specific Boolean formula $\\phi(x_1, x_2, x_3, x_4)$ defined as:\n$$ \\phi = ((\\neg x_1) \\land x_2) \\lor (x_1 \\land (\\neg x_3)) \\lor (x_2 \\implies x_4) $$\nUsing the standard search-to-decision reduction algorithm that determines variable assignments in the order $x_1, x_2, x_3, x_4$, find the specific falsifying assignment that the algorithm outputs for this formula $\\phi$. In this standard algorithm, at each step to determine the value for a variable $x_i$, the algorithm first checks if a falsifying assignment can be found by setting $x_i$ to True.\n\nLet the truth values be represented by 1 for True and 0 for False. The final answer should be a sequence of four numbers representing the truth values for $(x_1, x_2, x_3, x_4)$.",
            "solution": "The goal is to find a falsifying assignment for the given Boolean formula $\\phi$ using an oracle for **TAUT**. A falsifying assignment is a set of truth values for $(x_1, x_2, x_3, x_4)$ that makes $\\phi$ evaluate to False (0). The specified algorithm determines the values for $x_1, x_2, x_3, x_4$ in order. For each variable $x_i$, it first tries setting $x_i=1$ (True). It constructs a new formula by substituting this value and asks the `IS_TAUT` oracle if the resulting formula is a tautology. If the oracle says `False`, it means a falsifying assignment exists with $x_i=1$, so we fix $x_i=1$. If the oracle says `True`, then any falsifying assignment for the original formula must have $x_i=0$, so we fix $x_i=0$.\n\nThe initial formula is $\\phi_0(x_1, x_2, x_3, x_4) = ((\\neg x_1) \\land x_2) \\lor (x_1 \\land (\\neg x_3)) \\lor (x_2 \\implies x_4)$.\nWe can simplify the implication: $x_2 \\implies x_4 \\equiv \\neg x_2 \\lor x_4$.\nSo, $\\phi_0 = ((\\neg x_1) \\land x_2) \\lor (x_1 \\land (\\neg x_3)) \\lor (\\neg x_2 \\lor x_4)$.\n\n**Step 1: Determine the value for $x_1$.**\nLet's try setting $x_1=1$. The new formula, $\\phi_1$, is $\\phi_0$ with $x_1=1$:\n$$ \\phi_1(x_2, x_3, x_4) = ((\\neg 1) \\land x_2) \\lor (1 \\land (\\neg x_3)) \\lor (\\neg x_2 \\lor x_4) $$\n$$ \\phi_1 = (0 \\land x_2) \\lor (\\neg x_3) \\lor (\\neg x_2 \\lor x_4) $$\n$$ \\phi_1 = 0 \\lor (\\neg x_3) \\lor (\\neg x_2) \\lor x_4 $$\n$$ \\phi_1 = \\neg x_2 \\lor \\neg x_3 \\lor x_4 $$\nWe query the oracle: `IS_TAUT`($\\phi_1$)? The formula $\\phi_1$ is not a tautology. For example, if $x_2=1, x_3=1, x_4=0$, then $\\phi_1 = \\neg 1 \\lor \\neg 1 \\lor 0 = 0 \\lor 0 \\lor 0 = 0$. Since a falsifying assignment exists for $\\phi_1$, it is not a tautology.\nThe oracle returns `False`.\nTherefore, the algorithm fixes $b_1 = 1$. Our working formula for the next steps is $\\phi_1$.\n\n**Step 2: Determine the value for $x_2$.**\nOur current formula is $\\phi_1(x_2, x_3, x_4) = \\neg x_2 \\lor \\neg x_3 \\lor x_4$.\nLet's try setting $x_2=1$. The new formula, $\\phi_2$, is $\\phi_1$ with $x_2=1$:\n$$ \\phi_2(x_3, x_4) = \\neg 1 \\lor \\neg x_3 \\lor x_4 $$\n$$ \\phi_2 = 0 \\lor \\neg x_3 \\lor x_4 $$\n$$ \\phi_2 = \\neg x_3 \\lor x_4 $$\nWe query the oracle: `IS_TAUT`($\\phi_2$)? The formula $\\phi_2$ is not a tautology, as it is false for $x_3=1, x_4=0$.\nThe oracle returns `False`.\nTherefore, the algorithm fixes $b_2 = 1$. Our working formula for the next step is $\\phi_2$.\n\n**Step 3: Determine the value for $x_3$.**\nOur current formula is $\\phi_2(x_3, x_4) = \\neg x_3 \\lor x_4$.\nLet's try setting $x_3=1$. The new formula, $\\phi_3$, is $\\phi_2$ with $x_3=1$:\n$$ \\phi_3(x_4) = \\neg 1 \\lor x_4 $$\n$$ \\phi_3 = 0 \\lor x_4 $$\n$$ \\phi_3 = x_4 $$\nWe query the oracle: `IS_TAUT`($\\phi_3$)? The formula $\\phi_3=x_4$ is not a tautology, as it is false for $x_4=0$.\nThe oracle returns `False`.\nTherefore, the algorithm fixes $b_3 = 1$. Our working formula is now $\\phi_3$.\n\n**Step 4: Determine the value for $x_4$.**\nOur current formula is $\\phi_3(x_4) = x_4$.\nLet's try setting $x_4=1$. The new formula, $\\phi_4$, is $\\phi_3$ with $x_4=1$:\n$$ \\phi_4 = 1 $$\nWe query the oracle: `IS_TAUT`($\\phi_4$)? The formula `1` (or True) is always true, so it is a tautology by definition.\nThe oracle returns `True`.\nBecause setting $x_4=1$ resulted in a tautology, any falsifying assignment for $\\phi_3$ must have $x_4 \\neq 1$.\nTherefore, the algorithm fixes $b_4 = 0$.\n\nCombining the results from all steps, the algorithm finds the falsifying assignment $(b_1, b_2, b_3, b_4) = (1, 1, 1, 0)$.\n\nLet's verify this result.\n$\\phi(1, 1, 1, 0) = ((\\neg 1) \\land 1) \\lor (1 \\land (\\neg 1)) \\lor (1 \\implies 0)$\n$= (0 \\land 1) \\lor (1 \\land 0) \\lor 0$\n$= 0 \\lor 0 \\lor 0$\n$= 0$\nThe assignment correctly falsifies the formula.",
            "answer": "$$\\boxed{\\begin{pmatrix} 1 & 1 & 1 & 0 \\end{pmatrix}}$$"
        }
    ]
}