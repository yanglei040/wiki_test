{
    "hands_on_practices": [
        {
            "introduction": "要精确掌握计算复杂性理论，理解其核心定义至关重要。第一个练习旨在巩固你对 NP-中间问题定义的理解，该定义要求一个问题必须同时满足三个条件：(i) 属于 NP，(ii) 不属于 P，(iii) 不是 NP-完全的。通过分析一个看似合理但存在缺陷的论证，你将学会识别证明中的关键缺失环节，从而深化对 NP-中间问题本质的认识 。",
            "id": "1429670",
            "problem": "在计算复杂性理论领域，决策问题根据其内在难度被分为不同的类别。我们来考虑以下标准定义：\n\n-   **P**：可在确定性算法下于多项式时间内解决的决策问题所组成的类。\n-   **NP**：其“是”实例的解（或证书）可以在多项式时间内验证的决策问题所组成的类。\n-   一个问题 $A$ 可**多项式时间归约**到问题 $B$，记作 $A \\le_p B$，如果存在一个可在多项式时间内计算的函数，该函数能将问题 $A$ 的任何实例转换为问题 $B$ 的一个实例，使得两个实例的答案相同。\n-   如果一个问题属于 NP 类，并且 NP 中的所有其他问题都可以多项式时间归约到它，那么该问题是**NP完全**的。布尔可满足性问题 (SAT) 是一个典型的 NP 完全问题。\n-   假设 $P \\neq NP$，如果一个问题属于 NP，但它既不属于 P 也不是 NP 完全的，则该问题被定义为**NP中间**问题。Ladner 定理保证了如果 $P \\neq NP$，这类问题必然存在。\n\n一位计算机科学研究者在研究一个名为 $L$ 的新决策问题时，成功确定了两个关键性质：\n1.  问题 $L$ 属于 NP 类 (即 $L \\in \\text{NP}$)。\n2.  布尔可满足性问题 (SAT) 不能多项式时间归约到 $L$ (即 $\\mathrm{SAT} \\not\\le_p L$)。\n\n基于这两项发现，该研究者声称 $L$ 是一个 NP 中间问题。然而，一位同事指出，这个结论尚不完全成立，因为一个关键条件尚未得到验证。\n\n以下哪个陈述准确地指出了研究者结论中的缺陷？\n\nA. 研究者的发现只有在 $P = NP$ 的情况下才可能成立，而这是一个尚未被证明的重大猜想。\nB. 研究者尚未证明问题 $L$ 不属于 $P$ 类。\nC. 为证明 $L$ 不是 NP 完全的，研究者需要证明 $L \\not\\le_p \\mathrm{SAT}$。\nD. 问题 $L$ 可能属于 $P$，根据定义，这使其成为 NP 完全问题。\nE. 这些发现意味着 $L$ 在 NP 之外，这与第一个已确定的性质相矛盾。",
            "solution": "我们回顾一下定义：假设 $P\\neq NP$，一个语言 $L$ 是 NP 中间的，当且仅当 (i) $L\\in NP$，(ii) $L\\notin P$，并且 (iii) $L$ 不是 $NP$-完全的。研究者已经确定了：(1) $L\\in NP$ 和 (2) $\\mathrm{SAT}\\not\\le_{p} L$。\n\n首先，我们分析 (2) 意味着什么。如果 $L$ 是 $NP$-完全的，那么根据 $NP$-完全性的定义，NP 中的每个语言都可以在多项式时间内归约到 $L$。特别地，由于 $\\mathrm{SAT}$ 是 $NP$-完全的，因此也属于 $NP$，我们应有 $\\mathrm{SAT}\\le_{p} L$。这是其逆否命题：如果 $\\mathrm{SAT}\\not\\le_{p} L$，那么 $L$ 不是 $NP$-完全的。因此，性质 (2) 足以得出 $L$ 不是 $NP$-完全的结论，满足了条件 (iii)。\n\n然而，要得出 $L$ 是 NP 中间的结论，我们还需要验证 $L\\notin P$ (条件 (ii))。研究者没有提供任何论据来确定 $L\\notin P$。在没有排除 $L\\in P$ 的情况下，$L$ 仍然有可能在 $P$ 中；在这种情况下，即使 $\\mathrm{SAT}\\not\\le_{p} L$ 可能成立，$L$ 也不会是 NP 中间问题。因此，缺失的关键条件是证明 $L$ 不在 $P$ 中。\n\n评估选项：\n- A 是不正确的：这些发现并不要求 $P=NP$。\n- B 是正确的：研究者没有证明 $L\\notin P$。\n- C 是不正确的：证明 $L\\not\\le_{p}\\mathrm{SAT}$ 并不是非 $NP$-完全性的标准；相反，$\\mathrm{SAT}\\not\\le_{p} L$ 足以证明 $L$ 不是 $NP$-完全的。\n- D 是不正确的：根据定义，属于 $P$ 并不会使一个问题成为 $NP$-完全问题。\n- E 是不正确的：这些发现并不意味着 $L\\notin NP$。\n\n因此，缺陷在于未能确定 $L\\notin P$。",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "寻找一个确切的 NP-中间问题是计算复杂性理论中的一大挑战，整数分解是目前最著名的候选者。这个练习提供了一个看似更简单的 SAT 变体作为潜在的 NP-中间问题候选项。你的任务是运用多项式时间归约这一核心工具来确定它的真实复杂性，这个过程将揭示为何一个问题的某些“句法”限制，未必会降低其根本的计算难度 。",
            "id": "1429692",
            "problem": "在计算复杂性理论中，NP-中间类（NP-intermediate）被定义为这样一类判定问题：它们属于 NP，但既不属于 P，也不是 $NP$-完备的。NP 是可在多项式时间内验证的问题类，而 P 是可在多项式时间内解决的问题类。Ladner 定理指出，如果 $P$ 不等于 $NP$ ($P \\neq NP$)，那么这个 NP-中间类是非空的。\n\n考虑布尔可满足性问题 (SAT)，它是一个已知的 $NP$-完备问题。假设一个学生提出了以下语言 $L$ 作为 NP-中间问题的一个潜在候选：\n$$ L = \\{ \\phi \\mid \\phi \\text{ is a satisfiable Boolean formula and the length of its standard encoding, } |\\phi|, \\text{ is an even number} \\} $$\n\n假设 $P \\neq NP$，以下哪个陈述提供了最准确和具体的理由，说明为什么语言 $L$ 不是一个用来证明 NP-中间问题存在的合适例子？\n\nA. 语言 $L$ 可以在多项式时间内判定，这意味着 $L$ 属于 $P$ 类。\nB. 语言 $L$ 是 $NP$-完备的。\nC. 语言 $L$ 不属于 $NP$ 类。\nD. 任何 NP-中间问题的存在本身都取决于未经证实的 $P \\neq NP$ 猜想，这使得任何具体例子都纯粹是假设性的。\nE. 具有偶数长度编码的属性是一个“句法”属性，这类属性不能改变其底层“语义”问题（可满足性）的基本复杂性。",
            "solution": "我们分析语言\n$$L=\\{\\phi\\mid \\phi \\text{ is a satisfiable Boolean formula and }|\\phi|\\text{ is even}\\}.$$\n首先，我们证明 $L\\in\\text{NP}$。一个用于 $L$ 的非确定性验证机将 $\\phi$ 的变量的一个真值指派 $a$ 作为证书，并在多项式时间内检查：(i) $a$ 满足 $\\phi$，以及 (ii) $|\\phi|$ 是偶数。这两个检查都是多项式的：在指派 $a$ 下对 $\\phi$ 求值所需时间是 $|\\phi|$ 的多项式，而计算 $|\\phi|$ 的奇偶性是微不足道的。因此 $L\\in\\text{NP}$。\n\n接下来，我们通过给出 $\\mathrm{SAT}$ 和 $L$ 之间的双向多项式时间多一归约来证明 $L$ 是 $NP$-完备的。\n\n归约 $\\mathrm{SAT}\\leq_{p}L$：给定任意布尔公式 $\\psi$，我们构造一个 $f(\\psi)$ 使得当且仅当 $\\psi\\in\\mathrm{SAT}$ 时，$f(\\psi)\\in L$。我们需要 $f(\\psi)$ 是可满足的当且仅当 $\\psi$ 是可满足的，并且其长度总是偶数。令 $\\tau(v)$ 表示一个关于新变量 $v$ 的固定重言式，例如 $\\tau(v)=(v\\lor\\lnot v)$。令 $c_{0}$ 和 $c_{1}$ 为两个重言式部件，其编码具有相反的奇偶性。这可以通过使用不同的变量名来保证，这些变量名的编码长度奇偶性不同（在任何标准编码下，可以选择变量标识符来将编码长度调整一）。具体来说，令 $\\tau_{0}(v_{0})$ 和 $\\tau_{1}(v_{1})$ 为重言式，满足 $|\\tau_{0}(v_{0})|\\equiv 0\\pmod{2}$ 和 $|\\tau_{1}(v_{1})|\\equiv 1\\pmod{2}$。定义\n$$f(\\psi)=\\psi\\land \\tau_{b}(v_{b}),$$\n其中 $b\\in\\{0,1\\}$ 的选择使得 $|f(\\psi)|$ 为偶数；我们可以通过计算 $|\\psi|$ 的奇偶性以及连接词和 $\\tau_{0},\\tau_{1}$ 的固定奇偶性来确定 $b$。这个计算只使用编码长度的奇偶性，并且是多项式时间的。由于 $\\tau_{b}(v_{b})$ 是一个重言式，$f(\\psi)$ 是可满足的当且仅当 $\\psi$ 是可满足的。此外，根据构造， $|f(\\psi)|$ 是偶数。因此，$\\psi\\in\\mathrm{SAT}$ 当且仅当 $f(\\psi)\\in L$，所以 $\\mathrm{SAT}\\leq_{p}L$。\n\n归约 $L\\leq_{p}\\mathrm{SAT}$：定义 $g(\\phi)$ 如下：\n$$\ng(\\phi)=\\begin{cases}\n\\phi,  \\text{if }|\\phi|\\text{ is even},\\\\\n(x\\land \\lnot x),  \\text{if }|\\phi|\\text{ is odd},\n\\end{cases}\n$$\n其中 $x$ 是一个新变量。计算 $|\\phi|$ 模 2 是多项式时间的，并且 $(x\\land \\lnot x)$ 是不可满足的。那么：\n- 如果 $\\phi\\in L$，则 $\\phi$ 是可满足的且 $|\\phi|$ 是偶数，所以 $g(\\phi)=\\phi$ 是可满足的，因此 $g(\\phi)\\in\\mathrm{SAT}$。\n- 如果 $\\phi\\notin L$，那么要么 $\\phi$ 是不可满足的（这种情况下，如果 $|\\phi|$ 是偶数，则 $g(\\phi)=\\phi$；如果 $|\\phi|$ 是奇数，则 $g(\\phi)=(x\\land\\lnot x)$），导致 $g(\\phi)$ 不可满足；要么 $\\phi$ 是可满足的但 $|\\phi|$ 是奇数，这种情况下 $g(\\phi)=(x\\land\\lnot x)$ 是不可满足的。在所有情况下，$\\phi\\notin L$ 都意味着 $g(\\phi)\\notin\\mathrm{SAT}$。\n因此，$\\phi\\in L$ 当且仅当 $g(\\phi)\\in\\mathrm{SAT}$，所以 $L\\leq_{p}\\mathrm{SAT}$。\n\n结合这两个归约，$L$ 是 $NP$-完备的。因此，(假设 $P \\neq NP$) $L$ 作为 NP-中间问题的例子是不合适的最准确和具体的理由是，$L$ 实际上是 $NP$-完备的。在这些选项中，这对应于选项 B。\n\n选项 A 是错误的，除非 $\\mathrm{SAT}\\in P$。选项 C 是错误的，因为我们已经证明 $L\\in\\mathrm{NP}$。选项 D 是关于 Ladner 定理的一个一般性陈述，并未涉及 $L$。选项 E 是一个不精确的启发式说法，并且正如所证明的，句法上的奇偶性限制并没有降低复杂性；相反，通过上述归约，$L$ 仍然是 $NP$-完备的。",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "拉德纳定理的证明不仅是一个存在性证明，它还提供了一套强大的构造性方法，用于构建具有特定性质的复杂性类。这最后一个挑战性练习将带你亲身体验这一构造过程，模拟证明中的“对角化”论证。通过追踪一个精心设计的递归构造，你将见证如何构建出一对“多项式时间不可比较”的语言，这揭示了在 P 和 NP-完全问题之间的广阔地带所存在的精细结构 。",
            "id": "1429718",
            "problem": "本问题探讨了一种受 Ladner 定理证明启发的构造性方法，用于创建两种多项式不可比较的计算复杂语言。\n\n**背景与定义：**\n- 令 SAT 为布尔可满足性问题，一个著名的 NP完全（非确定性多项式时间完全）问题。我们视其所有实例为编码后的二进制字符串。\n- 如果存在一个多项式时间可计算的函数 $f$，使得对于所有字符串 $x$，$x \\in A \\iff f(x) \\in B$ 成立，则称语言 $A$ 可多项式时间归约到语言 $B$，记作 $A \\le_p B$。\n- 如果一个语言 $L \\in \\text{NP}$，但 $L$ 不在 P 中且 $L$ 不是 $NP$-完全的，则称 $L$ 是 NP中间语言。\n- 如果 $L_A \\le_p L_B$ 和 $L_B \\le_p L_A$ 均不成立，则称语言 $L_A$ 和 $L_B$ 是多项式不可比较的。\n- 令 $\\{T_i\\}_{i \\ge 1}$ 是计算多项式时间函数（转换器）的所有图灵机的标准枚举。这些代表了所有潜在的多项式时间归约。\n- 为整数 $n$ 定义函数 $h(n)$ 如下：当 $n \\ge 10$ 时，$h(n) = \\lfloor \\log_{10}(\\log_{10}(n)) \\rfloor$；当 $n  10$ 时，$h(n) = 0$。\n\n**构造过程：**\n我们将在字母表 $\\{0,1\\}$ 上定义两个语言 $L_A$ 和 $L_B$。任何字符串 $x$ 在这些语言中的隶属关系由一个算法确定，该算法根据 $k = h(|x|)$ 分阶段运行。此构造使用两个布尔标志数组 $G_A[j]$ 和 $G_B[j]$（$j \\ge 1$），它们都初始化为 `false`。这些标志用于跟踪某个特定的对角化要求是否已满足。\n\n字符串 $x$ 的隶属关系确定如下：\n1.  令 $n = |x|$ 并计算 $k = h(n)$。如果 $k = 0$，则 $x \\notin L_A$ 且 $x \\notin L_B$。\n2.  如果 $k  0$，算法将一次性定义所有长度为 $n$ 的字符串的隶属关系。令 $z_n = 1^n$ 为此长度的指定“见证”字符串。\n3.  **情况：$k = 2j-1$，其中 $j \\ge 1$ 为某个整数。**（此阶段针对通过 $T_j$ 实现的潜在归约 $L_B \\le_p L_A$。）\n    - 如果标志 $G_B[j]$ 为 `true`，则该要求已满足。对所有长度为 $n$ 的字符串 $x'$：\n        - $x' \\in L_A \\iff x' \\in \\mathrm{SAT}$。\n        - $x' \\in L_B \\iff x' \\in \\mathrm{SAT}$。\n    - 如果标志 $G_B[j]$ 为 `false`，则尝试对角化：\n        - 计算 $y = T_j(z_n)$。假设 $T_j$ 的运行时间以一个已知的多项式 $p_j(n)$为界。如果 $T_j(z_n)$ 在其时间界限内停机且 $h(|y|)  k$，则对角化 `successful`。否则，为 `failed`。\n        - 如果 `successful`：将 $G_B[j]$ 设置为 `true`。通过递归应用此算法来确定 $y$ 在 $L_A$ 中的隶属关系。\n            - 如果 $y \\in L_A$，则对于见证字符串 $z_n$：$z_n \\notin L_B$。\n            - 如果 $y \\notin L_A$，则对于见证字符串 $z_n$：$z_n \\in L_B$。\n            对于所有其他长度为 $n$ 的字符串 $x' \\neq z_n$，其隶属关系为 $x' \\in L_B \\iff x' \\in \\mathrm{SAT}$。在此 `successful` 子情况中，对所有长度为 $n$ 的字符串，$L_A$ 中的隶属关系由 SAT 决定：$x' \\in L_A \\iff x' \\in \\mathrm{SAT}$。\n        - 如果 `failed`：标志 $G_B[j]$ 保持为 `false`。对于所有长度为 $n$ 的字符串 $x'$：\n            - $x' \\in L_A \\iff x' \\in \\mathrm{SAT}$。\n            - $x' \\in L_B \\iff x' \\in \\mathrm{SAT}$。\n4.  **情况：$k = 2j$，其中 $j \\ge 1$ 为某个整数。**（此阶段针对通过 $T_j$ 实现的 $L_A \\le_p L_B$。）此情况与奇数情况对称。\n    - 如果 $G_A[j]$ 为 `true`，则对所有长度为 $n$ 的 $x'$：$x' \\in L_A \\iff x' \\in \\mathrm{SAT}$ 且 $x' \\in L_B \\iff x' \\in \\mathrm{SAT}$。\n    - 如果 $G_A[j]$ 为 `false`，则通过计算 $y = T_j(z_n)$ 尝试对角化：\n        - 如果 `successful` ($h(|y|)  k$)：将 $G_A[j]$ 设置为 `true`。递归确定 $y \\in L_B$。\n            - 如果 $y \\in L_B$，则 $z_n \\notin L_A$。\n            - 如果 $y \\notin L_B$，则 $z_n \\in L_A$。\n            对于长度为 $n$ 的 $x' \\neq z_n$：$x' \\in L_A \\iff x' \\in \\mathrm{SAT}$。在此子情况中，对所有长度为 $n$ 的 $x'$：$x' \\in L_B \\iff x' \\in \\mathrm{SAT}$。\n        - 如果 `failed`：对所有长度为 $n$ 的 $x'$：$x' \\in L_A \\iff x' \\in \\mathrm{SAT}$ 且 $x' \\in L_B \\iff x' \\in \\mathrm{SAT}$。\n\n**问题：**\n假设转换器的枚举如下：\n-   $T_1$ 是恒等转换器：$T_1(z) = z$。\n-   $T_2$ 是常数转换器：对任何输入 $z$，$T_2(z) = 1^{10^{10}}$。\n-   对所有 $j \\ge 3$，$T_j$ 作用于任何长度为 $n$ 且满足 $h(n) \\ge 2j-1$ 的见证字符串 $z_n$ 时，会产生一个输出 $y$，使得 $h(|y|) \\ge h(n)$。\n\n此外，假设对任何整数 $m \\ge 10^{10}$，字符串 $1^m$ 属于 SAT。\n\n考虑字符串 $x_A = 1^{10^{10}}$ 和 $x_B = 1^{10^{1000}}$。定义一个结果向量 $V = (v_A, v_B)$，其中如果 $x_A \\in L_A$ 则 $v_A=1$，否则 $v_A=0$；类似地，如果 $x_B \\in L_B$ 则 $v_B=1$，否则 $v_B=0$。\n\n确定向量 $V$。您的答案应为一个 $1 \\times 2$ 的行矩阵。",
            "solution": "给定 $n \\ge 10$ 时 $h(n) = \\lfloor \\log_{10}(\\log_{10}(n)) \\rfloor$，且所有标志 $G_{A}[j], G_{B}[j]$ 初始为 false。对任意 $m \\ge 10^{10}$，$1^{m} \\in \\mathrm{SAT}$。我们必须确定 $x_{A} = 1^{10^{10}}$ 关于 $L_{A}$ 的 $v_{A}$ 值，以及 $x_{B} = 1^{10^{1000}}$ 关于 $L_{B}$ 的 $v_{B}$ 值。\n\n首先考虑 $x_{A} = 1^{10^{10}}$。令 $n_{A} = |x_{A}| = 10^{10}$ 且 $k_{A} = h(n_{A})$。计算\n$$\nk_{A} = h(10^{10}) = \\left\\lfloor \\log_{10}\\big(\\log_{10}(10^{10})\\big) \\right\\rfloor = \\left\\lfloor \\log_{10}(10) \\right\\rfloor = 1.\n$$\n因此 $k_{A} = 1 = 2 \\cdot 1 - 1$，所以我们处于 $j=1$ 的奇数情况，目标是通过 $T_{1}$ 实现 $L_{B} \\le_{p} L_{A}$。由于 $G_{B}[1]$ 初始为 false，我们尝试通过计算 $y = T_{1}(z_{n_{A}})$ 进行对角化。这里 $z_{n_{A}} = 1^{n_{A}} = 1^{10^{10}}$，并且 $T_{1}$ 是恒等转换器，所以 $y = z_{n_{A}}$ 且 $|y| = n_{A}$。成功条件要求 $h(|y|)  k_{A}$。但是\n$$\nh(|y|) = h(n_{A}) = k_{A} = 1,\n$$\n所以 $h(|y|)  k_{A}$ 不成立。因此对角化失败。根据构造，对于所有长度为 $n_{A}$ 的字符串，我们设置\n$$\nx' \\in L_{A} \\iff x' \\in \\mathrm{SAT}, \\quad x' \\in L_{B} \\iff x' \\in \\mathrm{SAT}.\n$$\n因为 $x_{A} = 1^{10^{10}}$ 并且对于任意 $m \\ge 10^{10}$ 都有 $1^{m} \\in \\mathrm{SAT}$，所以 $x_{A} \\in L_{A}$。因此 $v_{A} = 1$。\n\n接下来考虑 $x_{B} = 1^{10^{1000}}$。令 $n_{B} = |x_{B}| = 10^{1000}$ 且 $k_{B} = h(n_{B})$。计算\n$$\nk_{B} = h(10^{1000}) = \\left\\lfloor \\log_{10}\\big(\\log_{10}(10^{1000})\\big) \\right\\rfloor = \\left\\lfloor \\log_{10}(1000) \\right\\rfloor = 3.\n$$\n因此 $k_{B} = 3 = 2 \\cdot 2 - 1$，是 $j=2$ 的奇数情况，目标是通过 $T_{2}$ 实现 $L_{B} \\le_{p} L_{A}$。初始时 $G_{B}[2]$ 为 false，所以我们尝试对角化：计算 $y = T_{2}(z_{n_{B}})$，其中 $z_{n_{B}} = 1^{n_{B}} = 1^{10^{1000}}$。根据定义，$T_{2}$ 输出常数 $1^{10^{10}}$，所以 $y = 1^{10^{10}}$。成功条件是 $h(|y|)  k_{B}$。我们有\n$$\nh(|y|) = h(10^{10}) = \\left\\lfloor \\log_{10}\\big(\\log_{10}(10^{10})\\big) \\right\\rfloor = \\left\\lfloor \\log_{10}(10) \\right\\rfloor = 1  3 = k_{B},\n$$\n因此对角化成功。将 $G_{B}[2]$ 设置为 true。规则接着要求递归地确定 $y \\in L_{A}$。对于 $y = 1^{10^{10}}$，如上文对 $k=1$ 的情况所示，对角化失败，且长度为 $10^{10}$ 的 $L_{A}$ 与 SAT 一致，所以\n$$\ny \\in L_{A} \\iff y \\in \\mathrm{SAT}.\n$$\n因为 $1^{10^{10}} \\in \\mathrm{SAT}$，我们有 $y \\in L_{A}$。在成功的奇数情况子程序中，如果 $y \\in L_{A}$，那么对于见证字符串 $z_{n_{B}} = 1^{10^{1000}}$，我们设置\n$$\nz_{n_{B}} \\notin L_{B}.\n$$\n因为 $x_{B} = z_{n_{B}}$，所以 $x_{B} \\notin L_{B}$，因此 $v_{B} = 0$。\n\n因此结果向量是行矩阵 $(1,0)$。",
            "answer": "$$\\boxed{\\begin{pmatrix}1  0\\end{pmatrix}}$$"
        }
    ]
}