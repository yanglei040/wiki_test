{
    "hands_on_practices": [
        {
            "introduction": "Understanding the landscape of NP requires a firm grasp of its key definitions. A problem is NP-intermediate only if it satisfies a precise set of criteria: it must be in NP, not be in P, and not be NP-complete. This first practice problem  presents a common scenario where a researcher has partial information and asks you to identify the crucial missing piece of the puzzle, sharpening your understanding of this three-part definition.",
            "id": "1429670",
            "problem": "In the field of computational complexity theory, decision problems are categorized into classes based on their inherent difficulty. Let's consider the following standard definitions:\n\n-   **P**: The class of decision problems that can be solved by a deterministic algorithm in polynomial time.\n-   **NP**: The class of decision problems for which a 'yes' instance has a certificate that can be verified in polynomial time.\n-   A problem $A$ is **polynomial-time reducible** to a problem $B$, denoted $A \\le_p B$, if there exists a function, computable in polynomial time, that transforms any instance of problem $A$ into an instance of problem $B$ such that the answer to both instances is the same.\n-   A problem is **NP-complete** if it is in the class NP, and every other problem in NP is polynomial-time reducible to it. The Boolean Satisfiability Problem (SAT) is a canonical example of an NP-complete problem.\n-   Assuming P $\\neq$ NP, a problem is defined as **NP-intermediate** if it belongs to NP, but it is neither in P nor NP-complete. Ladner's theorem guarantees the existence of such problems if P $\\neq$ NP.\n\nA computer science researcher, investigating a novel decision problem named $L$, has successfully established two key properties:\n1.  The problem $L$ is in the class NP (i.e., $L \\in \\text{NP}$).\n2.  The Boolean Satisfiability Problem cannot be polynomial-time reduced to $L$ (i.e., $\\text{SAT} \\not\\le_p L$).\n\nBased on these two findings, the researcher claims that $L$ is an NP-intermediate problem. However, a colleague points out that this conclusion is not yet fully justified because a crucial condition has not been verified.\n\nWhich of the following statements accurately identifies the flaw in the researcher's conclusion?\n\nA. The researcher's findings are only possible if P = NP, a major unproven conjecture.\nB. The researcher has not demonstrated that the problem $L$ is not in the class P.\nC. To prove $L$ is not NP-complete, the researcher needed to show $L \\not\\le_p \\text{SAT}$.\nD. The problem $L$ could be in P, which by definition makes it NP-complete.\nE. The findings imply that $L$ is outside of NP, contradicting the first established property.",
            "solution": "We recall the definition: assuming $P \\neq NP$, a language $L$ is NP-intermediate if and only if (i) $L \\in \\text{NP}$, (ii) $L \\notin \\text{P}$, and (iii) $L$ is not NP-complete. The researcher has established: (1) $L \\in \\text{NP}$, and (2) $\\text{SAT} \\not\\le_p L$.\n\nFirst, we analyze what (2) implies. If $L$ were NP-complete, then by the definition of NP-completeness, every language in $\\text{NP}$ would reduce to $L$ in polynomial time. In particular, since $\\text{SAT}$ is NP-complete and hence in $\\text{NP}$, we would have $\\text{SAT} \\le_p L$. This is the contrapositive: if $\\text{SAT} \\not\\le_p L$, then $L$ is not NP-complete. Therefore, property (2) is sufficient to conclude that $L$ is not NP-complete, satisfying condition (iii).\n\nHowever, to conclude that $L$ is NP-intermediate, we also need to verify $L \\notin \\text{P}$ (condition (ii)). The researcher has not provided any argument establishing $L \\notin \\text{P}$. Without ruling out $L \\in \\text{P}$, it remains possible that $L$ is in $\\text{P}$; in that case, even though $\\text{SAT} \\not\\le_p L$ might hold, $L$ would not be NP-intermediate. Therefore, the missing crucial condition is the demonstration that $L$ is not in $\\text{P}$.\n\nEvaluating the options:\n- A is incorrect: the findings do not require $P=NP$.\n- B is correct: the researcher has not shown $L \\notin \\text{P}$.\n- C is incorrect: showing $L \\not\\le_p \\text{SAT}$ is not the criterion for non-NP-completeness; instead, $\\text{SAT} \\not\\le_p L$ suffices to show $L$ is not NP-complete.\n- D is incorrect: being in $P$ does not make a problem NP-complete by definition.\n- E is incorrect: the findings do not imply $L \\notin \\text{NP}$.\n\nThus, the flaw is the failure to establish $L \\notin \\text{P}$.",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "It's tempting to think that adding a simple constraint to an NP-complete problem would automatically make it easierâ€”perhaps easy enough to become NP-intermediate. This exercise  explores that intuition by examining a variant of SAT restricted to inputs of even length. Your task is to determine if this seemingly \"padded\" or \"thinned out\" language truly escapes the gravitational pull of NP-completeness.",
            "id": "1429692",
            "problem": "In computational complexity theory, the class NP-intermediate is defined as the set of decision problems that are in NP but are neither in P nor NP-complete. NP is the class of problems verifiable in polynomial time, and P is the class of problems solvable in polynomial time. Ladner's theorem states that if P is not equal to NP (P $\\neq$ NP), then this NP-intermediate class is non-empty.\n\nConsider the Boolean Satisfiability Problem (SAT), which is known to be NP-complete. Let a student propose the following language $L$ as a potential candidate for an NP-intermediate problem:\n$$ L = \\{ \\phi \\mid \\phi \\text{ is a satisfiable Boolean formula and the length of its standard encoding, } |\\phi|, \\text{ is an even number} \\} $$\n\nAssuming that P $\\neq$ NP, which of the following statements provides the most accurate and specific reason why the language $L$ is an unsuitable example for demonstrating the existence of an NP-intermediate problem?\n\nA. The language $L$ is decidable in polynomial time, meaning $L$ belongs to the class P.\nB. The language $L$ is NP-complete.\nC. The language $L$ is not a member of the class NP.\nD. The existence of any NP-intermediate problem is itself conditional on the unproven P $\\neq$ NP conjecture, making any specific example purely hypothetical.\nE. The property of having an even-length encoding is a \"syntactic\" property, and such properties cannot change the fundamental complexity of the underlying \"semantic\" problem (satisfiability).",
            "solution": "We analyze the language\n$$L=\\{\\phi\\mid \\phi \\text{ is a satisfiable Boolean formula and }|\\phi|\\text{ is even}\\}.$$\nFirst, we show $L \\in \\text{NP}$. A nondeterministic verifier for $L$ takes as certificate a truth assignment $a$ to the variables of $\\phi$ and checks in polynomial time that: (i) $a$ satisfies $\\phi$, and (ii) $|\\phi|$ is even. Both checks are polynomial: evaluating $\\phi$ under $a$ takes time polynomial in $|\\phi|$, and computing parity of $|\\phi|$ is trivial. Hence $L \\in \\text{NP}$.\n\nNext, we show that $L$ is NP-complete by giving polynomial-time many-one reductions both ways between $\\text{SAT}$ and $L$.\n\nReduction $\\text{SAT} \\le_p L$: Given any Boolean formula $\\psi$, we construct $f(\\psi)$ such that $\\psi \\in \\text{SAT}$ if and only if $f(\\psi) \\in L$. We need $f(\\psi)$ to be satisfiable if and only if $\\psi$ is satisfiable, and to have even length always. Let $(v \\lor \\lnot v)$ be a fixed tautology over a fresh variable $v$. Let $c_0$ and $c_1$ be two tautology gadgets whose encodings have opposite parity, which can be ensured, for instance, by using different variable names whose encodings differ in length parity (under any standard encoding, variable identifiers can be chosen to adjust encoding length by one). Concretely, let $\\tau_0(v_0)$ and $\\tau_1(v_1)$ be tautologies with $|\\tau_0(v_0)| \\equiv 0 \\pmod{2}$ and $|\\tau_1(v_1)| \\equiv 1 \\pmod{2}$. Define\n$$f(\\psi)=\\psi\\land \\tau_b(v_b),$$\nwhere $b \\in \\{0,1\\}$ is chosen so that $|f(\\psi)|$ is even; we can determine $b$ by computing the parity of $|\\psi|$ and the fixed parities of the connectives and $\\tau_0, \\tau_1$. This computation uses only the encoding length parity and is polynomial time. Since $\\tau_b(v_b)$ is a tautology, $f(\\psi)$ is satisfiable if and only if $\\psi$ is satisfiable. Moreover, by construction $|f(\\psi)|$ is even. Therefore $\\psi \\in \\text{SAT}$ if and only if $f(\\psi) \\in L$, and hence $\\text{SAT} \\le_p L$.\n\nReduction $L \\le_p \\text{SAT}$: Define $g(\\phi)$ by\n$$\ng(\\phi)=\\begin{cases}\n\\phi, & \\text{if }|\\phi|\\text{ is even},\\\\\n(x \\land \\lnot x), & \\text{if }|\\phi|\\text{ is odd},\n\\end{cases}\n$$\nwhere $x$ is a fresh variable. Computing $|\\phi|$ modulo $2$ is polynomial, and $(x \\land \\lnot x)$ is unsatisfiable. Then:\n- If $\\phi \\in L$, $\\phi$ is satisfiable and $|\\phi|$ is even, so $g(\\phi)=\\phi$ is satisfiable, hence $g(\\phi) \\in \\text{SAT}$.\n- If $\\phi \\notin L$, then either $\\phi$ is unsatisfiable (in which case $g(\\phi)=\\phi$ if $|\\phi|$ even, or $g(\\phi)=(x \\land \\lnot x)$ if $|\\phi|$ odd), yielding an unsatisfiable $g(\\phi)$; or $\\phi$ is satisfiable with $|\\phi|$ odd, in which case $g(\\phi)=(x \\land \\lnot x)$ is unsatisfiable. In all cases, $\\phi \\notin L$ implies $g(\\phi) \\notin \\text{SAT}$.\nTherefore $\\phi \\in L$ if and only if $g(\\phi) \\in \\text{SAT}$, so $L \\le_p \\text{SAT}$.\n\nCombining the two reductions, $L$ is NP-complete. Consequently, the most accurate and specific reason that $L$ is unsuitable as an NP-intermediate example (assuming $\\text{P}\\neq\\text{NP}$) is that $L$ is actually NP-complete. Among the options, this corresponds to option B.\n\nOption A is false unless $\\text{SAT}\\in\\text{P}$. Option C is false since we showed $L \\in \\text{NP}$. Option D is a general statement about Ladner's theorem and does not address $L$. Option E is an imprecise heuristic and, as shown, the syntactic parity restriction does not reduce complexity; rather, $L$ remains NP-complete via the above reductions.",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "Ladner's theorem is more than just a statement of existence; its proof provides a concrete recipe, a diagonalization argument, for constructing an NP-intermediate problem. This final exercise  simulates this powerful technique in a controlled setting. By following the steps of the construction algorithm through its initial stages, you will gain firsthand insight into how a language can be meticulously crafted to defeat every polynomial-time algorithm while simultaneously avoiding NP-completeness.",
            "id": "61614",
            "problem": "This problem concerns the construction of an NP-intermediate language, a central theme in the proof of Ladner's theorem. Assume $\\text{P} \\neq \\text{NP}$. Let SAT be a standard NP-complete language over the alphabet $\\Sigma = \\{0, 1\\}$. We will construct a language $L_S$ that is in NP but is neither in P nor NP-complete.\n\nThe language $L_S$ is defined as:\n$$L_S = \\{x \\in \\Sigma^* \\mid x \\in \\text{SAT} \\land \\chi_S(|x|) = 1\\}$$\nwhere $\\chi_S: \\mathbb{N} \\to \\{0,1\\}$ is a characteristic function constructed by the deterministic algorithm described below.\n\nLet $\\{M_i\\}_{i \\ge 1}$ be an effective enumeration of all deterministic polynomial-time Turing machines, where the runtime of machine $M_i$ on an input of length $n$ is bounded by the polynomial $p_i(n) = n^i + i$.\n\nThe construction of $\\chi_S$ proceeds in stages $k=1, 2, 3, \\dots$. The goal at stage $k$ is to ensure that the language $L_S$ is not decided by the machine $M_k$.\n\n**Construction Algorithm for $\\chi_S$:**\n\n1.  **Initialization:** Initialize a function $\\chi_S(n) = 1$ for all $n \\in \\mathbb{N}$. Also, initialize a sequence of witness lengths with $z_0 = 0$.\n\n2.  **Staged Diagonalization:** For each stage $k = 1, 2, 3, \\dots$:\n    a. Find the smallest integer $z_k \\ge z_{k-1} + 1$ that satisfies the condition $p_k(z_k)  2^{\\sqrt{z_k}}$. This $z_k$ will be the \"witness length\" for stage $k$.\n    b. Consider the canonical string of this length, $w_k = 1^{z_k}$.\n    c. Determine if $w_k \\in \\text{SAT}$. Let $s_k=1$ if $w_k \\in \\text{SAT}$, and $s_k=0$ otherwise.\n    d. Simulate the machine $M_k$ on input $w_k$. Let its output be $b_k = M_k(w_k) \\in \\{0,1\\}$.\n    e. To ensure $L(M_k) \\neq L_S$, we want to achieve $M_k(w_k) \\neq (w_k \\in L_S)$. That is, $b_k \\neq (s_k \\land \\chi_S(z_k))$. If this inequality already holds with the current value of $\\chi_S(z_k)$, no change is needed. Otherwise, we must modify $\\chi_S(z_k)$.\n    f. A modification is triggered only if it's necessary and possible. The specific rule is: if $s_k=1$ and $b_k=1$, set $\\chi_S(z_k)=0$. In all other cases, leave $\\chi_S(z_k)$ as its current value (which is 1 unless it was changed in a previous stage, though the choice of $z_k$ prevents this).\n\n**Problem Specifics:**\n\nFor this problem, you are given the following:\n- The Turing machines for the first three stages are:\n    - $M_1(w) = 1$ for all inputs $w$.\n    - $M_2(w) = 1$ if $|w|$ is even, and $0$ otherwise.\n    - $M_3(w) = 1$ if $|w|$ is a perfect square, and $0$ otherwise.\n- For the purpose of this problem, assume that a unary string $1^n$ is in SAT if and only if $n$ is a prime number.\n\nYour task is to determine the state of the function $\\chi_S$ after the completion of the first three stages ($k=1, 2, 3$). Specifically, you must calculate the value of the following sum:\n$$C = \\sum_{n=1}^{1000} (1 - \\chi_S(n))$$\nThis sum effectively counts the number of lengths up to 1000 for which $\\chi_S(n)$ has been set to 0.",
            "solution": "We trace the construction for the first three stages to see which, if any, values of $\\chi_S(n)$ are changed from 1 to 0. A change occurs at stage $k$ for length $z_k$ only if $s_k=1$ (i.e., $1^{z_k} \\in \\text{SAT}$) and $b_k=1$ (i.e., $M_k(1^{z_k})=1$).\n\n1.  **Stage k=1**:\n    -   $p_1(n) = n+1$. The smallest integer $z_1 \\ge 1$ such that $n+1  2^{\\sqrt{n}}$ is $z_1=19$.\n    -   At length $z_1=19$: $1^{19} \\in \\text{SAT}$ (19 is prime), so $s_1=1$. $M_1$ always outputs 1, so $b_1=1$.\n    -   Since $s_1=1$ and $b_1=1$, the condition is met. We set $\\chi_S(19)=0$.\n\n2.  **Stage k=2**:\n    -   $p_2(n) = n^2+2$. The smallest integer $z_2 \\ge 20$ such that $n^2+2  2^{\\sqrt{n}}$ is $z_2=258$.\n    -   At length $z_2=258$: $1^{258} \\notin \\text{SAT}$ (258 is not prime), so $s_2=0$.\n    -   The condition for change requires $s_2=1$, so it is not met. $\\chi_S(258)$ remains 1.\n\n3.  **Stage k=3**:\n    -   $p_3(n) = n^3+3$. The smallest integer $z_3 \\ge 259$ such that $n^3+3  2^{\\sqrt{n}}$ is $z_3=855$.\n    -   At length $z_3=855$: $1^{855} \\notin \\text{SAT}$ (855 is not prime), so $s_3=0$.\n    -   The condition for change requires $s_3=1$, so it is not met. $\\chi_S(855)$ remains 1.\n\nAfter three stages, only $\\chi_S(19)$ has been set to 0. All witness lengths are within the range $[1, 1000]$. The sum $C$ counts how many values of $n \\in [1, 1000]$ have $\\chi_S(n)=0$. This occurs only for $n=19$.\nTherefore, $C = 1$.",
            "answer": "$$\\boxed{1}$$"
        }
    ]
}