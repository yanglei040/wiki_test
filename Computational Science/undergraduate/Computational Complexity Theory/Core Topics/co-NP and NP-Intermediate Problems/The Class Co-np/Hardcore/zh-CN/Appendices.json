{
    "hands_on_practices": [
        {
            "introduction": "本练习探讨了一个关于图论的普遍性问题，需要我们判断是否所有从起点到终点的路径都必须经过一个“禁区”。这类涉及“所有”个体的问题，在计算复杂性理论中是 co-NP 类的典型特征，因为验证“否”的答案（即存在一条未被阻塞的路径）通常比验证“是”的答案更直接。通过这个练习，我们将学习如何识别这种结构，并探索将问题转化为其补问题来分析其复杂性的技巧 。",
            "id": "1451814",
            "problem": "考虑以下我们称之为 `UNIVERSAL-OBSTRUCTION` 的判定问题。\n\n问题的一个实例由一个元组 $\\langle G, s, t, F \\rangle$ 给出，其中：\n- $G=(V, E)$ 是一个有向图，包含一组顶点 $V$ 和一组有向边 $E$。\n- $s \\in V$ 是一个指定的源顶点。\n- $t \\in V$ 是一个指定的汇顶点，其中 $s \\neq t$。\n- $F \\subseteq V$ 是一组“禁止”顶点。\n\n问题是：**从源顶点 $s$ 到汇顶点 $t$ 的每一条路径都必须经过集合 $F$ 中的至少一个顶点，这个陈述是否为真？**\n\n一条路径是一个顶点序列 $(v_0, v_1, \\ldots, v_k)$，满足 $v_0=s$，$v_k=t$，并且对于每个 $i \\in \\{0, \\ldots, k-1\\}$，边 $(v_i, v_{i+1})$ 都在 $E$ 中。如果顶点 $v$ 是序列 $(v_0, v_1, \\ldots, v_k)$ 中的一个顶点，则称路径“经过”顶点 $v$。\n\n分析 `UNIVERSAL-OBSTRUCTION` 问题的计算复杂性。下列关于其复杂性的陈述中，哪些是正确的？选择所有适用的选项。\n\n（在必要时，你可以假设复杂性类 P、NP 和 co-NP 彼此不同，例如 P $\\neq$ NP。）\n\nA. `UNIVERSAL-OBSTRUCTION` 在 P 中。\n\nB. `UNIVERSAL-OBSTRUCTION` 在 NP 中。\n\nC. `UNIVERSAL-OBSTRUCTION` 在 co-NP 中。\n\nD. `UNIVERSAL-OBSTRUCTION` 是 NP-完全的。\n\nE. `UNIVERSAL-OBSTRUCTION` 是 co-NP-完全的。\n\nF. `UNIVERSAL-OBSTRUCTION` 不在 NP 中。\n\nG. `UNIVERSAL-OBSTRUCTION` 不在 co-NP 中。",
            "solution": "为了确定 `UNIVERSAL-OBSTRUCTION` 问题的复杂性，我们将分析其在复杂性类 P、NP 和 co-NP 方面的性质。\n\n首先，我们分析问题的结构。问题询问一个属性（“经过一个禁止顶点”）是否对从 $s$ 到 $t$ 的*每一条*路径都成立。带有这种全称量词（“对于所有...”）的问题通常是 co-NP 类的候选者。\n\n一个判定问题属于 **co-NP** 类，如果它的补问题属于 **NP** 类。我们来定义 `UNIVERSAL-OBSTRUCTION` 的补问题。原始问题询问是否所有的 $s-t$ 路径都被“阻塞”。对这个问题的“否”回答意味着“并非所有路径都被阻塞”是真的。这等价于说*存在至少一条*未被阻塞的 $s-t$ 路径。\n\n我们称这个补问题为 `AVOIDING-PATH`。\n- **实例:** $\\langle G, s, t, F \\rangle$\n- **问题:** 是否存在一条从 $s$ 到 $t$ 的路径，不经过集合 $F$ 中的任何顶点？\n\n现在，我们来确定 `AVOIDING-PATH` 是否在 NP 中。一个问题在 NP 中，如果对于一个“是”的答案，可以在给定一个合适的证书的情况下，在多项式时间内进行验证。\n对于 `AVOIDING-PATH`，一个“是”实例的证书就是路径本身。假设路径为 $p = (v_0, v_1, \\ldots, v_k)$。\n一个多项式时间的验证机可以检查以下几点：\n1.  路径以 $s$ 开始，以 $t$ 结束：检查是否有 $v_0 = s$ 和 $v_k = t$。\n2.  路径在 $G$ 中是有效的：对于每个 $i \\in \\{0, \\ldots, k-1\\}$，检查边 $(v_i, v_{i+1})$ 是否存在于 $E$ 中。\n3.  路径避开了所有禁止顶点：对于路径中的每个顶点 $v_i$，检查 $v_i \\notin F$。\n\n这样一条路径的长度最多为 $|V|$，因此证书的大小是输入大小的多项式。每个验证步骤都可以在多项式时间内完成。因此，`AVOIDING-PATH` 在 NP 中。\n\n由于 `UNIVERSAL-OBSTRUCTION` 的补问题在 NP 中，根据定义，**`UNIVERSAL-OBSTRUCTION` 在 co-NP 中**。这意味着选项 **C** 是正确的。\n\n现在，我们来研究该问题是否属于一个更严格的类，即 P。一个问题在 P 中，如果它能被一个确定性算法在多项式时间内解决。我们重新考虑 `AVOIDING-PATH` 问题。我们可以设计一个直接的算法来解决它。\n\n**`AVOIDING-PATH` 的算法：**\n1.  通过从 $G$ 中移除所有禁止顶点来构建一个新图 $G'$。$G'$ 中的顶点集是 $V' = V \\setminus F$。边集 $E'$ 由所有满足 $u$ 和 $v$ 都在 $V'$ 中的边 $(u,v) \\in E$ 组成。\n2.  `AVOIDING-PATH` 问题现在等价于询问在图 $G'$ 中是否存在一条从 $s$ 到 $t$ 的路径。\n3.  这是一个标准的图可达性问题。在解决它之前，我们必须首先检查 $s$ 或 $t$ 是否被移除。如果 $s \\in F$ 或 $t \\in F$，那么就不可能存在完全由非禁止顶点组成的路径，所以 `AVOIDING-PATH` 的答案是“否”。\n4.  如果 $s \\notin F$ 并且 $t \\notin F$，我们可以从 $s$ 开始，在图 $G'$ 上运行一个图遍历算法，如广度优先搜索（BFS）或深度优先搜索（DFS）。如果搜索到达 $t$，则存在一条避开禁止顶点的路径。如果搜索完成而没有到达 $t$，则不存在这样的路径。\n\n$G'$ 的构建和 BFS/DFS 的执行都花费多项式时间（具体为 $O(|V| + |E|)$）。因此，`AVOIDING-PATH` 在 P 中。\n\nP 类对补运算是封闭的（也就是说，如果一个语言 $L$ 在 P 中，那么它的补 $\\bar{L}$ 也在 P 中）。由于 `AVOIDING-PATH` 在 P 中，它的补问题 **`UNIVERSAL-OBSTRUCTION` 也必须在 P 中**。这意味着选项 **A** 是正确的。\n\n现在我们可以评估所有选项：\n- **A. `UNIVERSAL-OBSTRUCTION` 在 P 中。** 这是**正确的**，因为我们已经为其展示了一个多项式时间算法。\n- **B. `UNIVERSAL-OBSTRUCTION` 在 NP 中。** 这是**正确的**。任何在 P 中的问题也都在 NP 中（P $\\subseteq$ NP）。一个问题的多项式时间判定器也可以作为一个忽略证书的验证器。\n- **C. `UNIVERSAL-OBSTRUCTION` 在 co-NP 中。** 这也是**正确的**。任何在 P 中的问题也都在 co-NP 中（P $\\subseteq$ co-NP）。我们也通过证明其补问题在 NP 中直接证明了这一点。\n- **D. `UNIVERSAL-OBSTRUCTION` 是 NP-完全的。** 这是**不正确的**。一个 P 中的问题只有在 P=NP 的情况下才能是 NP-完全的。问题陈述允许我们假设 P $\\neq$ NP。\n- **E. `UNIVERSAL-OBSTRUCTION` 是 co-NP-完全的。** 这是**不正确的**。一个 P 中的问题只有在 P=co-NP 的情况下才能是 co-NP-完全的。由于 P $\\subseteq$ co-NP，这同样意味着 P=co-NP。根据我们的假设，这是错误的。\n- **F. `UNIVERSAL-OBSTRUCTION` 不在 NP 中。** 这是**不正确的**，因为它在 P 中，因此也在 NP 中。\n- **G. `UNIVERSAL-OBSTRUCTION` 不在 co-NP 中。** 这是**不正确的**，因为它在 P 中，因此也在 co-NP 中。\n\n因此，正确的陈述是 A、B 和 C。",
            "answer": "$$\\boxed{ABC}$$"
        },
        {
            "introduction": "这个练习将我们带入逻辑电路验证的核心，要求我们判断一个以析取范式（DNF）表示的布尔公式是否为重言式。验证一个公式对于“所有”可能的输入都为真，是确保系统功能正确的关键，这个问题自然地引向了 co-NP 类。此问题与著名的布尔可满足性问题（SAT）形成了鲜明对比，是理解 co-NP 完备性的一个绝佳切入点 。",
            "id": "1451848",
            "problem": "你是一家设计定制逻辑电路公司的质量保证团队中的一名初级软件工程师。设计团队以布尔公式的形式提供电路的功能规范。你的任务是编写一个验证程序，检查电路的输出是否*总是*逻辑为真，无论输入如何。这个属性对于安全关键型应用至关重要。\n\n这些公式以析取范式（DNF）的形式提供。以下是对术语的简要回顾：\n- *变量*是一个符号，如 $x_1$，其值可以为真或为假。\n- *文字*是变量（$x_i$）或其否定（$\\neg x_i$）。\n- *项*是一个或多个文字的合取（AND，用 $\\land$ 表示）。例如，$(x_1 \\land \\neg x_2 \\land x_3)$ 是一个项。\n- **析取范式（DNF）**中的公式是一个或多个项的析取（OR，用 $\\lor$ 表示）。例如，$(x_1 \\land \\neg x_2) \\lor (\\neg x_1 \\land x_3)$ 是一个 DNF 公式。\n- *重言式*（或永真式）是一个布尔公式，对于其变量的所有可能真值赋值，其结果都为真。\n\n确定一个任意 DNF 公式是否为重言式的问题被称为 DNF-TAUTOLOGY 问题。为了正确设计你的验证软件并评估其性能限制，你需要了解它的计算复杂性。\n\n在下面的列表中，保证包含 DNF-TAUTOLOGY 问题的最具体（即最小）的著名复杂性类是哪一个？\n\nA. P (多项式时间)\n\nB. NP (非确定性多项式时间)\n\nC. co-NP\n\nD. PSPACE (多项式空间)",
            "solution": "设一个 DNF 公式写作 $F=\\bigvee_{i=1}^{k} T_{i}$，其中每个项 $T_{i}$ 是文字的合取，$T_{i}=\\bigwedge_{j=1}^{m_{i}} \\ell_{ij}$。使用德摩根定律和否定在布尔连接词上的分配律，我们有\n$$\n\\neg F \\;=\\; \\neg\\left(\\bigvee_{i=1}^{k} T_{i}\\right) \\;=\\; \\bigwedge_{i=1}^{k} \\neg T_{i}, \n\\qquad\n\\neg T_{i} \\;=\\; \\neg\\left(\\bigwedge_{j=1}^{m_{i}} \\ell_{ij}\\right) \\;=\\; \\bigvee_{j=1}^{m_{i}} \\neg \\ell_{ij}.\n$$\n因此，$\\neg F$ 是一个恰好有 $k$ 个子句的 CNF 公式，并且 $\\neg F$ 的大小与 $F$ 的大小成线性关系。\n\n$F$ 是一个重言式当且仅当 $\\neg F$ 是不可满足的：\n$$\nF \\text{ is tautological} \\;\\Longleftrightarrow\\; \\forall a,\\; F(a)=\\text{true} \\;\\Longleftrightarrow\\; \\neg\\exists a,\\; \\neg F(a)=\\text{true} \\;\\Longleftrightarrow\\; \\neg F \\text{ is unsatisfiable}.\n$$\n因此，DNF-TAUTOLOGY 与 CNF-UNSAT 是多项式时间多一等价的。由于 CNF-UNSAT 是 co-NP-完备的（因为它是 SAT 的补问题，而 SAT 是 NP-完备的），因此 DNF-TAUTOLOGY 是 co-NP-难的。\n\n它属于 co-NP 是因为其补问题（DNF 非重言式）允许一个多项式时间可验证的证书：一个赋值 $a$ 使得 $F(a)=\\text{false}$。给定 $a$，可以在多项式时间内验证每个项 $T_{i}$ 的计算结果都为假（等价地，对于每个 $i$，在 $T_{i}$ 中都存在一个被 $a$ 置为假的文字），因此 $F(a)=\\text{false}$。\n\n因此 DNF-TAUTOLOGY 是 co-NP-完备的，所以在列出的复杂性类中，保证包含它的最小类是 co-NP。",
            "answer": "$$\\boxed{C}$$"
        },
        {
            "introduction": "此练习展示了计算复杂性理论在关键系统安全验证中的实际应用。我们需要确保一个由多项式方程定义的系统在任何情况下都不会进入“灾难性故障”状态，这要求我们证明一个多项式在某个指定区域内“绝无”整数根。通过分析这个问题，我们可以看到 co-NP 类如何为验证系统“永不”发生特定行为的普遍安全性声明提供了一个严谨的理论框架 。",
            "id": "1451824",
            "problem": "一家软件验证公司正在开发一个工具以确保关键系统的安全性。一个系统的状态由一个包含$n$个整数变量的向量$\\mathbf{x} = (x_1, x_2, \\dots, x_n)$表示。如果某个具有整数系数的多项式$P$满足多项式方程$P(x_1, x_2, \\dots, x_n) = 0$，则认为该系统处于“灾难性故障”状态。\n\n该验证工具需要解决以下我们称之为`SAFE_REGION`的判定问题：\n\n**输入：**\n1. 一个具有整数系数的多元多项式$P(x_1, \\dots, x_n)$，由其项（系数和指数）指定。\n2. 一个由$n$对整数边界$(L_i, U_i)$（对于$i=1, \\dots, n$，其中$L_i \\le U_i$）定义的状态空间超矩形区域。\n\n**问题：** 对于所有满足$L_i \\le x_i \\le U_i$（对所有$i=1, \\dots, n$）的整数状态向量$\\mathbf{x}$，条件$P(\\mathbf{x}) \\neq 0$是否成立？\n\n假设P不等于NP（非确定性多项式时间）且NP不等于co-NP，以下哪个陈述为`SAFE_REGION`问题的计算复杂度提供了最准确和具体的分类？\n\nA. `SAFE_REGION`属于P。\n\nB. `SAFE_REGION`属于NP但不属于P。\n\nC. `SAFE_REGION`属于co-NP但不属于NP。\n\nD. `SAFE_REGION`同时属于NP和co-NP，但不属于P。\n\nE. `SAFE_REGION`是PSPACE-complete的。",
            "solution": "我们给定一个整数系数的多元多项式$P(x_{1},\\dots,x_{n})$和整数边界$L_{i} \\leq U_{i}$（对于$i \\in \\{1,\\dots,n\\}$）。判定问题SAFE_REGION询问是否\n$$\n\\forall \\mathbf{x} \\in \\mathbb{Z}^{n} \\text{ with } L_{i} \\leq x_{i} \\leq U_{i} \\text{ for all } i,\\quad P(\\mathbf{x}) \\neq 0.\n$$\n等价地，其补问题询问是否存在一个方框内的整数点使得$P$为零：\n$$\n\\exists \\mathbf{x} \\in \\mathbb{Z}^{n} \\text{ with } L_{i} \\leq x_{i} \\leq U_{i} \\text{ for all } i \\text{ such that } P(\\mathbf{x}) = 0.\n$$\n\n第1步（co-NP成员性）：SAFE_REGION的补问题，称之为EXISTS_ROOT，有一个自然的证书：一个点$\\mathbf{x} \\in \\mathbb{Z}^{n}$，满足$L_{i} \\leq x_{i} \\leq U_{i}$且$P(\\mathbf{x})=0$。给定这样一个$\\mathbf{x}$，验证过程包括：\n- 检查对所有$i$是否有$L_{i} \\leq x_{i} \\leq U_{i}$，这在输入大小的多项式时间内是直接的，\n- 精确地计算$P(\\mathbf{x})$并测试其是否等于$0$。由于$P$由一个带有整数系数和指数的单项式列表指定，我们可以使用快速幂（重复平方）和整数乘法计算每个单项式$a \\prod_{i=1}^{n} x_{i}^{e_{i}}$，然后将它们相加；与$0$的相等性测试则是一个简单的整数比较。因此，一个声称的根$\\mathbf{x}$可以在输入大小的多项式时间内被验证。因此EXISTS_ROOT属于NP，而SAFE_REGION属于co-NP。\n\n第2步（co-NP-hard）：我们将UNSAT归约到SAFE_REGION。设$F$是一个作用于布尔变量$y_{1},\\dots,y_{n}$的CNF公式，包含子句$C_{1},\\dots,C_{m}$。对每个变量$y_{i}$，引入一个整数变量$x_{i}$并将定义域约束在整数方框$[0,1]^{n}$内，因此唯一的整数点是$\\{0,1\\}^{n}$。对每个文字，定义其多项式编码：\n- 如果文字是$y_{i}$，设$\\ell(x_{i}) = x_{i}$，\n- 如果文字是$\\neg y_{i}$，设$\\ell(x_{i}) = 1 - x_{i}$。\n对于一个包含文字$\\ell_{j1},\\ell_{j2},\\ell_{j3}$的子句$C_{j}$，定义\n$$\nf_{j}(\\mathbf{x}) = \\bigl(1 - \\ell_{j1}(\\mathbf{x})\\bigr)\\bigl(1 - \\ell_{j2}(\\mathbf{x})\\bigr)\\bigl(1 - \\ell_{j3}(\\mathbf{x})\\bigr).\n$$\n对于$\\mathbf{x} \\in \\{0,1\\}^{n}$，$f_{j}(\\mathbf{x}) = 0$当且仅当子句$C_{j}$被赋值$\\mathbf{x}$满足；如果$C_{j}$不被满足，则$f_{j}(\\mathbf{x}) = 1$。定义一个单一的多项式\n$$\nP_{F}(\\mathbf{x}) = \\sum_{j=1}^{m} \\bigl(f_{j}(\\mathbf{x})\\bigr)^{2}.\n$$\n在$\\mathbf{x} \\in \\{0,1\\}^{n}$上，每一项$\\bigl(f_{j}(\\mathbf{x})\\bigr)^{2} \\in \\{0,1\\}$且\n$$\nP_{F}(\\mathbf{x}) = 0 \\quad \\Longleftrightarrow \\quad \\text{对所有 } j \\text{ 都有 } f_{j}(\\mathbf{x}) = 0 \\quad \\Longleftrightarrow \\quad \\text{每个子句都被满足} \\quad \\Longleftrightarrow \\quad F \\text{ 是可满足的}。\n$$\n因此，对于方框$[0,1]^{n}$，\n$$\n\\forall \\mathbf{x} \\in \\{0,1\\}^{n},\\; P_{F}(\\mathbf{x}) \\neq 0 \\quad \\Longleftrightarrow \\quad F \\text{ 是不可满足的}。\n$$\n映射$F \\mapsto (P_{F},[0,1]^{n})$在$F$的大小的多项式时间内是可计算的。因此，UNSAT可归约到SAFE_REGION，所以SAFE_REGION是co-NP-hard的。\n\n第3步（在给定假设下的分类）：根据第1步，SAFE_REGION属于co-NP。根据第2步，SAFE_REGION是co-NP-hard的。因此，SAFE_REGION是co-NP-complete的。在$P \\neq NP$和$NP \\neq co\\text{-}NP$的假设下，一个co-NP-complete问题不属于NP也不属于P。在提供的选项中，最准确和具体的分类是SAFE_REGION属于co-NP但不属于NP。\n\n因此，正确选项是C。",
            "answer": "$$\\boxed{C}$$"
        }
    ]
}