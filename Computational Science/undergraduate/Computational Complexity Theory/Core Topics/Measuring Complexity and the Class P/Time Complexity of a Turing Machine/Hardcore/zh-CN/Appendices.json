{
    "hands_on_practices": [
        {
            "introduction": "我们从一个基础问题开始，它展示了图灵机最直接的计算模式之一：线性扫描。通过分析一个判定输入字符串是否由交替的 0 和 1 组成的图灵机 ，我们将看到，当算法只需要对输入进行一次从头到尾的遍历时，其时间复杂度如何自然地归结为线性时间 $O(n)$。这个练习是理解更复杂算法性能的基石。",
            "id": "1466953",
            "problem": "考虑一台单带图灵机 (TM)，它被设计用来判定语言 $L$，$L$ 是由字母表 $\\Sigma = \\{0, 1\\}$ 上交替的0和1组成的字符串构成的语言。$L$ 中的字符串示例包括空字符串、“0”、“1”、“010” 和 “10101”。一个长度为 $n = |w|$ 的输入字符串 $w$ 被放置在原本为空白的带上。该图灵机开始时，其读写头位于 $w$ 的最左边符号上。如果 $w$ 是空字符串，读写头从一个空白符号 $\\sqcup$ 开始。\n\n该图灵机是确定性的，并根据以下高层描述进行操作：\n\n1.  图灵机从一个起始状态 $q_{start}$ 开始。\n2.  如果读写头下的符号是空白符号 $\\sqcup$，它转移到停机接受状态 $q_{accept}$。这处理了空字符串的情况。\n3.  如果符号是 '0'，它转移到一个状态 $q_{expect\\_1}$，并将其读写头向右移动一个单元格。\n4.  如果符号是 '1'，它转移到一个状态 $q_{expect\\_0}$，并将其读写头向右移动一个单元格。\n5.  当处于状态 $q_{expect\\_1}$ 时：\n    a. 如果读到 '1'，它转移到状态 $q_{expect\\_0}$，并将其读写头向右移动一个单元格。\n    b. 如果读到空白符号 $\\sqcup$，它转移到停机接受状态 $q_{accept}$。\n    c. 如果读到 '0'，它转移到停机拒绝状态 $q_{reject}$。\n6.  当处于状态 $q_{expect\\_0}$ 时：\n    a. 如果读到 '0'，它转移到状态 $q_{expect\\_1}$，并将其读写头向右移动一个单元格。\n    b. 如果读到空白符号 $\\sqcup$，它转移到停机接受状态 $q_{accept}$。\n    c. 如果读到 '1'，它转移到停机拒绝状态 $q_{reject}$。\n7.  一旦图灵机进入 $q_{accept}$ 或 $q_{reject}$，它就会停机。\n\n对于这台图灵机，单个计算步骤包括读取一个符号、改变状态以及移动读写头（或停机）。对于长度为 $n > 0$ 的输入字符串，这台图灵机的最坏情况时间复杂度 $T(n)$ 是多少，用大O表示法表示？\n\nA. $O(1)$\n\nB. $O(\\log n)$\n\nC. $O(n)$\n\nD. $O(n \\log n)$\n\nE. $O(n^2)$",
            "solution": "令 $n$ 表示输入长度，其中 $n>0$。定义 $S(w)$ 为在输入 $w$ 上的计算步数，并将最坏情况时间复杂度定义为 $T(n)=\\max_{|w|=n}S(w)$。\n\n每个计算步骤包括读取当前符号、改变状态，并将读写头向右移动一个单元格（或停机）。给定的转移规则确保图灵机从不向左移动；它严格地从左到右扫描，并在检测到不匹配时或在最后一个输入符号后看到空白符号时停机。\n\n对于任何长度为 $|w|=n$ 的非空输入 $w$：\n- 在位置 $1$，处于状态 $q_{start}$ 时，机器读取 $w_{1}$，转移到 $q_{expect\\_1}$ 或 $q_{expect\\_0}$，并向右移动。这需要 $1$ 步。\n- 对于每个后续位置 $i$（$2 \\leq i \\leq n$），如果直到 $w_{i}$ 的前缀与交替模式一致，机器会读取 $w_{i}$，在 $q_{expect\\_0}$ 和 $q_{expect\\_1}$ 之间转移，并向右移动。每个这样的位置恰好贡献 $1$ 步。如果在位置 $i$ 发生违规，机器会转移到 $q_{reject}$ 并停机，因此在这种情况下 $S(w)=i$。\n- 如果直到位置 $n$ 都没有发生违规，那么在第 $n$ 步之后，读写头位于输入右侧的空白单元格上，机器在 $\\sqcup$ 上再执行最后一步，进入 $q_{accept}$ 并停机。因此，对于一个交替字符串，$S(w)=n+1$。\n\n因此，最坏情况发生在当 $w$ 是一个完美的交替字符串时，得出\n$$\nT(n)=\\max_{|w|=n}S(w)=n+1.\n$$\n因此，用大O表示法，\n$$\nT(n)\\in O(n).\n$$\n在给定的选项中，这对应于选项 C。",
            "answer": "$$\\boxed{C}$$"
        },
        {
            "introduction": "接下来，我们探讨一个更复杂的判定问题：确定一串符号的长度是否为 2 的幂 。与单次扫描不同，解决这个问题需要一种迭代减半的策略，类似于“分治”思想。这个练习揭示了当一个算法需要在每次线性时间的遍历中系统地减小问题规模时，其总时间复杂度是如何演变为 $O(n \\log n)$ 的。",
            "id": "1466990",
            "problem": "考虑一台单带图灵机 (TM)，它判定输入字母表 $\\Sigma = \\{a\\}$ 上的语言 $L = \\{a^n \\mid n = 2^k \\text{ for some integer } k \\ge 0\\}$。其带字母表为 $\\Gamma = \\{a, x, \\sqcup\\}$，其中 $\\sqcup$ 是空白符号。\n\n该图灵机对于长度为 $n$ 的输入字符串，按以下算法运行：\n\n1.  如果带子为空（输入为空字符串，$n=0$），机器停机并拒绝。\n2.  机器从左到右扫描带子。在扫描过程中，它计算符号 `a` 的数量。\n3.  如果 `a` 的数量恰好为一，机器停机并接受。\n4.  如果 `a` 的数量是大于一的奇数，机器停机并拒绝。\n5.  如果 `a` 的数量是大于一的偶数，机器准备进行下一轮处理。它将读写头倒回到最左边的单元格。然后，它开始一次新的从左到右的扫描。在这次新扫描中，它将遇到的每第二个 `a` 用符号 `x` 覆盖以进行标记。\n6.  标记扫描完成后，机器将读写头倒回到最左边的单元格，并返回步骤 2，计算剩余未标记的 `a` 的数量。\n\n该图灵机的时间复杂度是多少，用关于输入长度 $n$ 的大O表示法表示？\n\nA. $O(n)$\n\nB. $O(n \\log n)$\n\nC. $O(n^2)$\n\nD. $O(\\log n)$\n\nE. $O(2^n)$",
            "solution": "设输入长度为 $n$。该机器重复执行多轮处理，每轮包括：\n- 一次在带子已使用部分上的从左到右的计数扫描，这部分长度为 $n$，因为在标记过程中没有引入空白符号（符号只是从 $a$ 变为 $x$），\n- 有条件地将读写头倒回到左端（每次都是一次最多扫描 $n$ 个单元格的从右到左的扫描），\n- 以及，当计数为大于一的偶数时，进行一次从左到右的标记扫描，标记每第二个 $a$（同样扫描最多 $n$ 个单元格），之后再进行一次倒带。\n\n因此，每个完整的减半轮（计数、倒带、标记、倒带）最多花费 $n$ 的一个常数倍时间。单独的计数扫描也最多花费 $n$ 的一个常数倍时间。\n\n设 $v_{2}(n)$ 为满足 $2^{t} \\mid n$ 的最大整数 $t$。每次当计数为大于一的偶数时，未标记的 $a$ 的数量减半，因此在机器达到一个奇数计数（大于一）并拒绝，或达到 $1$ 并接受之前，恰好有 $v_{2}(n)$ 轮标记。因此：\n- 计数扫描发生 $v_{2}(n) + 1$ 次（每轮一次，包括最后的停机轮），\n- 标记扫描发生 $v_{2}(n)$ 次，\n- 倒带发生 $2 v_{2}(n)$ 次（每次导致标记的计数扫描后一次，以及每次标记扫描后一次）。\n\n每次扫描或倒带最多扫描 $n$ 个单元格，因此存在一个常数 $c > 0$ 使得\n$$\nT(n) \\le c\\,n\\,( (v_{2}(n)+1) + v_{2}(n) + 2 v_{2}(n) ) = c\\,n\\,(4 v_{2}(n) + 1).\n$$\n因为 $v_{2}(n) \\le \\lfloor \\log_{2}(n) \\rfloor$，所以\n$$\nT(n) = O\\!\\left(n \\log_{2}(n)\\right).\n$$\n因此，时间复杂度为 $O(n \\log n)$，这对应于选项 B。",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "最后，我们来分析一个看似简单的构造任务：在图灵机上复制一个字符串，将输入 $w$ 变为 $ww$ 。这个问题鲜明地暴露了单带图灵机的一个核心限制：在有限的带上反复来回移动读写头以传递信息的巨大开销。通过这个实践，你将深刻理解为何这类需要在不断增长的工作空间上来回“穿梭”的算法，其时间复杂度会达到二次级别 $O(n^2)$。",
            "id": "1466996",
            "problem": "一台单带图灵机（TM）的任务是复制一个给定的输入字符串。输入是一个长度为 $n$ 的字符串 $w$，由字母表 $\\Sigma = \\{a, b\\}$ 中的符号组成。带字母表为 $\\Gamma = \\{a, b, \\dot{a}, \\dot{b}, \\sqcup\\}$，其中 $\\dot{a}$ 和 $\\dot{b}$ 是 $a$ 和 $b$ 的“标记”版本，而 $\\sqcup$ 是空白符号。\n\n初始时，带上包含 ...$\\sqcup$ w $\\sqcup$...，读写头位于 $w$ 的第一个符号上。图灵机必须在带上包含 ...$\\sqcup$ ww $\\sqcup$... 时停机。读写头的最终位置不重要。\n\n该图灵机执行以下算法：\n1.  **主循环：** 此循环对原始输入字符串 $w$ 中的每个符号重复。对于第 $i$ 次迭代（其中 $i=1, \\dots, n$）：\n    a. 从带的左端开始，读写头向右移动，以找到第一个未标记的符号（即原始字符串的第 $i$ 个符号）。设该符号为 $\\sigma$。它读取 $\\sigma$ 并用其标记版本 $\\dot{\\sigma}$ 替换它。\n    b. 读写头移动到带上所有非空白符号的右端，直到找到第一个空白单元格 $\\sqcup$。\n    c. 读写头在该空白单元格中写入符号 $\\sigma$。\n    d. 读写头一直向左移动，返回到带的第一个单元格，以开始下一次迭代。\n\n2.  **清理阶段：** 主循环完成后，带上包含 $\\dot{w}w$，其中 $\\dot{w}$ 是原始字符串的标记版本。图灵机从带的开头执行最后一次扫描，将 $n$ 个标记符号 $\\dot{\\sigma}$ 中的每一个替换为其原始版本 $\\sigma$。\n\n确定这个完整算法的总体时间复杂度，该复杂度定义为读写头执行的单个步骤（读、写或左/右移动）的总数。用大O表示法将答案表示为输入字符串 $w$ 长度 $n$ 的函数。",
            "solution": "我们计算读写头的基本操作：每次读取、每次写入以及每次单格移动都算作一个步骤。设输入长度为 $n$。在主循环的第 $i$ 次迭代中（$i \\in \\{1,\\dots,n\\}$），在写入副本之前，带上有 $n+(i-1)$ 个非空白符号；在写入第 $i$ 个复制的符号之后，它有 $n+i$ 个非空白符号。\n\n对于第 $i$ 次迭代，我们将成本 $T_{i}$ 分解为与步骤 (a)–(d) 对应的四个部分：\n\n- 步骤 (a)：从左端（第一个符号）到第一个未标记的符号（即第 $i$ 个符号），读写头检查 $i$ 个单元格，向右移动经过前 $i-1$ 个已标记的单元格，并停在第 $i$ 个上。这需要 $i$ 次读取、$(i-1)$ 次右移和 $1$ 次写入以进行标记，因此\n$$\nA_{i} = i + (i-1) + 1 = 2i.\n$$\n\n- 步骤 (b)：从位置 $i$ 到右侧第一个空白格，读写头必须精确地穿过 $n$ 个位置（剩下的 $n-i$ 个原始符号和先前附加的 $i-1$ 个符号，加上移动到空白格的一步）。每次遍历步骤包括一次移动和一次读取，所以\n$$\nB_{i} = n + n = 2n.\n$$\n\n- 步骤 (c)：在空白格中写入符号 $\\sigma$ 是一次写入操作：\n$$\nC_{i} = 1.\n$$\n\n- 步骤 (d)：返回到第一个（最左边）的符号，是通过向左移动直到看到左边的空白格，然后向右移动一次到第一个符号来实现的。在步骤 (c) 之后，有 $n+i$ 个非空白符号。因此，从最右边的非空白符号移动到左边的空白格需要 $(n+i)$ 次左移和 $(n+i)$ 次读取，然后一次右移和一次读取以定位并识别第一个符号。因此\n$$\nD_{i} = (n+i) + (n+i) + 1 + 1 = 2(n+i) + 2.\n$$\n\n将第 $i$ 次迭代的这四个部分的成本相加，得到\n$$\nT_{i} = A_{i} + B_{i} + C_{i} + D_{i} = 2i + 2n + 1 + 2(n+i) + 2 = 4n + 4i + 3.\n$$\n\n因此，主循环的总成本是\n$$\n\\sum_{i=1}^{n} T_{i} = \\sum_{i=1}^{n} \\left(4n + 4i + 3\\right) = 4n^{2} + 4 \\cdot \\frac{n(n+1)}{2} + 3n = 6n^{2} + 5n,\n$$\n即 $O(n^{2})$。\n\n清理阶段：主循环结束后，带上内容为 $\\dot{w}w$，其中 $|\\dot{w}| = n$。最后一次扫描以单次从左到右的方式遍历前 $n$ 个单元格，将每个标记符号替换为其未标记版本。每个单元格需要常数数量的步骤（一次读取、一次写入以及在相邻单元格之间的移动），因此清理成本为 $O(n)$。\n\n结合这两个部分，总时间复杂度为\n$$\nO(n^{2}) + O(n) = O(n^{2}).\n$$\n\n为求完整，还存在一个匹配的下界：每次迭代都必须从靠近左端的位置移动到最右端，然后再返回，穿过一个长度为 $\\Theta(n+i)$ 的带段，因此总移动次数至少是 $\\sum_{i=1}^{n} n = \\Theta(n^{2})$ 的数量级。因此，该算法的运行时间为 $\\Theta(n^{2})$，用大O表示法表示的时间复杂度为 $O(n^{2})$。",
            "answer": "$$\\boxed{O(n^{2})}$$"
        }
    ]
}