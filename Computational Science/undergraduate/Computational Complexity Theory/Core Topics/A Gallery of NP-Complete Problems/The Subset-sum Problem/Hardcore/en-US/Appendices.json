{
    "hands_on_practices": [
        {
            "introduction": "To appreciate why the Subset-Sum problem is considered computationally hard, it's instructive to see why simple, intuitive strategies fall short. This first exercise explores a common \"greedy\" approach—always picking the largest possible number that fits—and demonstrates its failure with a concrete counterexample. Understanding this limitation is the first step toward recognizing the need for more systematic algorithms like dynamic programming. ",
            "id": "1463403",
            "problem": "A computer science student is investigating the Subset-Sum problem, which asks if a non-empty subset of a given set of integers sums to a specific target value. The student implements a greedy algorithm to solve this problem. The algorithm works as follows:\n\n1.  Start with an empty solution subset and the initial target value, $T$.\n2.  From the set of available integers, $S$, select the largest integer that is less than or equal to the remaining target value.\n3.  Add this integer to the solution subset and subtract its value from the remaining target.\n4.  Remove the selected integer from the available set $S$.\n5.  Repeat steps 2-4 until the remaining target value is zero (a solution is found) or no more integers can be selected (the algorithm fails).\n\nThe student tests this algorithm on the set of integers $S = \\{10, 7, 6, 5\\}$ with a target value $T = 12$. The greedy algorithm fails to find a solution. However, a valid subset that sums to $T$ does exist. Which of the following is the correct subset?\n\nA. $\\{10\\}$\n\nB. $\\{7, 6\\}$\n\nC. $\\{7, 5\\}$\n\nD. $\\{5, 6\\}$\n\nE. No such subset exists",
            "solution": "The problem asks us to identify the correct subset of $S = \\{10, 7, 6, 5\\}$ that sums to the target $T = 12$. We are told that a specific greedy algorithm fails to find this solution. Let's first trace the execution of the greedy algorithm to understand why it fails, and then we will check the given options to find the correct solution.\n\nFirst, let's trace the greedy algorithm described.\nThe set of integers is $S = \\{10, 7, 6, 5\\}$ and the target is $T = 12$. The integers in $S$ are already sorted in descending order, which is convenient for the greedy selection process.\n\nStep 1: The current target is 12. The largest integer in $S$ is 10. Since $10 \\le 12$, the algorithm selects 10.\n- The partial solution subset is now $\\{10\\}$.\n- The remaining target value becomes $12 - 10 = 2$.\n- The set of available integers becomes $\\{7, 6, 5\\}$.\n\nStep 2: The current target is 2. The available integers are $\\{7, 6, 5\\}$.\n- The largest available integer is 7. Since $7 > 2$, it cannot be chosen.\n- The next largest available integer is 6. Since $6 > 2$, it cannot be chosen.\n- The next largest available integer is 5. Since $5 > 2$, it cannot be chosen.\n\nStep 3: There are no integers left in the available set that are less than or equal to the remaining target of 2. The algorithm terminates without reducing the target to 0. The greedy approach only found the subset $\\{10\\}$, which sums to 10, not 12. Thus, the greedy algorithm fails, as stated in the problem.\n\nNow, we need to find the correct subset. We can do this by examining the provided multiple-choice options.\n\nA. The subset is $\\{10\\}$. The sum of its elements is 10. This is not equal to the target $T = 12$.\n\nB. The subset is $\\{7, 6\\}$. The sum of its elements is $7 + 6 = 13$. This is not equal to the target $T = 12$.\n\nC. The subset is $\\{7, 5\\}$. The sum of its elements is $7 + 5 = 12$. This is equal to the target $T = 12$. This is a valid solution.\n\nD. The subset is $\\{5, 6\\}$. The sum of its elements is $5 + 6 = 11$. This is not equal to the target $T = 12$.\n\nE. This option claims that no such subset exists. This is false, because we found a valid subset in option C.\n\nTherefore, the correct subset of $S$ that sums to $T=12$ is $\\{7, 5\\}$.",
            "answer": "$$\\boxed{C}$$"
        },
        {
            "introduction": "The classification of the Subset-Sum problem as NP-complete comes with a fascinating subtlety: its standard dynamic programming solution runs in time that is polynomial in the *magnitude* of the target number, but exponential in the *size* of its binary representation. This exercise probes the heart of this \"pseudo-polynomial\" nature through a thought experiment. By considering how the algorithm's complexity changes if numbers are encoded in unary, you will gain a deeper insight into how input representation fundamentally impacts computational efficiency. ",
            "id": "1463375",
            "problem": "The Subset-Sum problem is a classic decision problem in computational complexity theory. It asks whether a non-empty subset of a given set of non-negative integers $S = \\{s_1, s_2, \\dots, s_n\\}$ sums to a given target integer $T$.\n\nA standard approach to solve this problem is using a Dynamic Programming (DP) algorithm. This algorithm constructs a two-dimensional boolean table, `can_sum[i][j]`, where `can_sum[i][j]` is true if and only if a sum of `j` can be formed using a subset of the first `i` integers $\\{s_1, \\dots, s_i\\}$. The table size is $(n+1) \\times (T+1)$, and each entry can be computed in constant time based on previous entries. This results in an overall time complexity of $O(n T)$.\n\nTypically, the input numbers are assumed to be encoded in binary. The size of the input is then the total number of bits required to represent all integers in $S$ and the target $T$. With this binary encoding, the $O(n T)$ runtime is classified as pseudo-polynomial, because the value of $T$ can be exponentially larger than the number of bits used to represent it (which is approximately $\\log_2 T$).\n\nNow, imagine a different scenario where all integers in the set $S$ and the target $T$ are provided using a unary encoding. In a unary system, an integer $k$ is represented by a string of $k$ identical symbols (e.g., the number 5 could be represented as '11111'). Consequently, the size of a unary-encoded input is the sum of the numerical values of all the integers involved.\n\nGiven the same $O(n T)$ Dynamic Programming algorithm, how would you classify its time complexity with respect to the size of this new unary-encoded input?\n\nSelect the most accurate statement from the options below.\n\nA. The algorithm runs in polynomial time, which implies that this version of SUBSET-SUM (with unary input) is in the complexity class P.\n\nB. The algorithm remains pseudo-polynomial because its runtime still depends on the magnitude of the target $T$.\n\nC. The algorithm's runtime becomes exponential in the input size, making it less efficient than with binary encoding.\n\nD. The complexity class of the SUBSET-SUM problem itself changes from NP-complete to P, regardless of the algorithm used.\n\nE. The runtime analysis is not possible because the number of elements $n$ is independent of the unary input size.",
            "solution": "We are given the dynamic programming algorithm for SUBSET-SUM that constructs a table of size $(n+1)\\times(T+1)$ and runs in time $O(nT)$, assuming each table entry is computed in constant time based on previous entries.\n\nWe compare this runtime to the size of the input under unary encoding. Let the input be $S=\\{s_{1},\\dots,s_{n}\\}$ and target $T$. In unary, each $s_{i}$ is represented with length $\\Theta(s_{i})$ and $T$ with length $\\Theta(T)$. Accounting for delimiters or list structure adds an additional $\\Theta(n)$ symbols. Therefore, the total input length $L$ satisfies\n$$\nL=\\Theta\\!\\left(T+\\sum_{i=1}^{n} s_{i}+n\\right).\n$$\nIn particular, this implies the bounds\n$$\nT \\leq c_{1} L,\\quad n \\leq c_{2} L\n$$\nfor suitable positive constants $c_{1}$ and $c_{2}$, since $T$ and $n$ are each dominated by the total length. Thus the algorithm’s time $O(nT)$ can be upper bounded in terms of $L$ as\n$$\nO(nT) \\subseteq O\\!\\left((c_{2}L)(c_{1}L)\\right)=O(L^{2}),\n$$\nwhich is polynomial in the unary input size.\n\nTherefore, with unary encoding, the $O(nT)$ dynamic programming algorithm runs in polynomial time with respect to the input size. Consequently, the unary-encoded version of SUBSET-SUM lies in the class P under this algorithmic analysis. It is no longer merely pseudo-polynomial relative to the unary input size, and there is no basis to claim an exponential blowup.\n\nHence, the most accurate choice is that the algorithm runs in polynomial time, placing this unary-encoded version of SUBSET-SUM in P.",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "While the general Subset-Sum problem is hard, many real-world scenarios present structured instances that can be solved efficiently. A key skill in algorithm design is learning to spot and exploit such structure. This practice problem presents a special case where all numbers in the set are distinct powers of two, revealing a beautiful connection to the binary number system and transforming an NP-complete problem into one solvable in polynomial time. ",
            "id": "1463440",
            "problem": "The SUBSET-SUM problem is a classic question in computer science: given a finite set of integers $S = \\{s_1, s_2, \\dots, s_n\\}$ and a target integer $T$, determine if there exists a non-empty subset of $S$ whose elements sum exactly to $T$. In its general form, SUBSET-SUM is NP-complete, meaning there is no known algorithm that can solve every instance of the problem in time that is polynomial in the input size, and it is considered among the hardest problems in the class NP (Nondeterministic Polynomial time).\n\nConsider a special variant of this problem where the set $S$ contains only distinct, non-negative powers of two. For example, $S$ could be $\\{2^0, 2^2, 2^3, 2^7\\}$, which is $\\{1, 4, 8, 128\\}$.\n\nGiven this specific constraint that all elements in the set $S$ are distinct powers of two, what is the computational complexity of this variant of the SUBSET-SUM problem?\n\nA. It remains NP-complete.\n\nB. It is solvable in polynomial time and is therefore in the complexity class P.\n\nC. It is solvable, but only in exponential time, similar to the general problem's brute-force solution.\n\nD. The problem becomes undecidable.\n\nE. It is solvable in logarithmic time with respect to the input size.",
            "solution": "Let $S=\\{s_{1},\\dots,s_{n}\\}$ with each $s_{j}$ a distinct non-negative power of two. Hence there exist distinct exponents $e_{1},\\dots,e_{n}\\in\\mathbb{N}\\cup\\{0\\}$ such that\n$$\ns_{j}=2^{e_{j}} \\quad \\text{for } j=1,\\dots,n,\n$$\nand we define the exponent set $E=\\{e_{1},\\dots,e_{n}\\}$. For any subset $X\\subseteq S$, the sum of its elements is\n$$\n\\sum_{s\\in X}s=\\sum_{2^{e}\\in X}2^{e}.\n$$\nBecause the exponents in $X$ are distinct, the binary expansion of this sum has $1$-bits exactly at the positions $e$ that appear in $X$. This relies on the uniqueness of binary representation: every non-negative integer has a unique representation\n$$\nT=\\sum_{i\\in B(T)}2^{i},\n$$\nwhere $B(T)$ is the set of bit positions $i$ with the $i$th bit of $T$ equal to $1$. Therefore, for $T\\ge 0$ we have:\n$$\n\\exists\\,X\\subseteq S\\text{ with }\\sum_{s\\in X}s=T \\quad \\Longleftrightarrow \\quad B(T)\\subseteq E.\n$$\nMoreover, since the subset must be non-empty and all $s_{j}\\ge 0$ with at least one $s_{j}>0$, if $T=0$ there is no non-empty subset achieving $T$; if $T<0$ there is no subset at all, because all sums are non-negative. These conditions are checkable in time polynomial in the input size.\n\nAn explicit polynomial-time algorithm is:\n1. If $T<0$, answer NO. If $T=0$, answer NO due to the non-empty requirement.\n2. Compute $E=\\{e:\\,2^{e}\\in S\\}$ by, for each $s_{j}$, extracting its exponent $e_{j}$ (verifiable in time polynomial in the bit-length of $s_{j}$).\n3. Compute $B(T)$ from the binary expansion of $T$.\n4. Check whether $B(T)\\subseteq E$; if yes, answer YES, else NO.\n\nThe running time is $O\\!\\left(\\sum_{j=1}^{n}\\log s_{j}+\\log T\\right)$, which is polynomial in the input size under standard binary encoding. Hence this special case is solvable in polynomial time, so it lies in the class P.\n\nTherefore, among the options, the correct classification is B.",
            "answer": "$$\\boxed{B}$$"
        }
    ]
}