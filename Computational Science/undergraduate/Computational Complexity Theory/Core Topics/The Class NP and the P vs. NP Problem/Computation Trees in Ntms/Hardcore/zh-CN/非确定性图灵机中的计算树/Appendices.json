{
    "hands_on_practices": [
        {
            "introduction": "理解计算树规模的指数级增长是掌握非确定性计算复杂性的第一步。这个练习通过一个简单的思想实验，帮助我们推导出一个计算树在给定深度 $k$ 下可能包含的最大节点数。这个上界为我们后续分析更复杂的场景奠定了基础，并直观地揭示了非确定性计算的巨大潜力。",
            "id": "1417810",
            "problem": "非确定性图灵机（NTM）可以被看作是一种并行探索多个计算路径的理论计算机。对于一个给定的输入，一个NTM所有可能的计算序列集合可以用一棵计算树来表示。这棵树的根节点是初始格局（包括机器的起始状态、带上的输入和初始磁头位置）。树中深度为 $d$ 的节点代表经过 $d$ 个计算步骤后可达的格局。一个节点的子节点是所有根据机器的转移函数可以从该节点在一步之内到达的格局。\n\n考虑一个特定的NTM，其转移函数规定对于任何格局，在下一步中最多可以转换到两种可能的格局。设 $k$ 是一个非负整数，代表计算树中的一个特定深度。\n\n确定在此NTM的计算树中，深度为 $k$ 时可能存在的最大格局数。请用一个关于 $k$ 的闭式解析表达式来表示你的答案。",
            "solution": "设 $N(k)$ 表示计算树中深度为 $k$ 时的最大格局数。转移函数允许从任何格局到下一步最多有两种可能的格局，因此分支因子最多为 $2$。\n\n在根节点（深度为 $0$）处，只有一个格局，所以 $N(0)=1$。从深度为 $d$ 的任何格局出发，在深度为 $d+1$ 处最多有 $2$ 个子节点。因此，在每个节点在每一步都恰好分支成两个子节点的最大化情况下，该序列满足递推关系\n$$\nN(0)=1, \\quad N(k+1)=2\\,N(k).\n$$\n通过迭代求解该递推关系，得到\n$$\nN(k)=2^{k}.\n$$\n或者，通过归纳法：基本情况 $N(0)=1=2^{0}$ 成立。假设 $N(k)=2^{k}$，那么 $N(k+1)\\leq 2\\,N(k)=2\\cdot 2^{k}=2^{k+1}$，当每个节点都有两个子节点时等号成立。因此，深度为 $k$ 时可能存在的最大格局数是 $2^{k}$。",
            "answer": "$$\\boxed{2^{k}}$$"
        },
        {
            "introduction": "理论之后是实践。此练习要求我们为一个特定的非确定性图灵机（NTM）手动追踪其计算过程，并构建出计算树的前几层 。通过具体地描绘出每个计算分支，我们可以亲身体验非确定性选择是如何导致计算路径的分化，从而将抽象的树结构概念变得具体化。",
            "id": "1417864",
            "problem": "考虑一台非确定性图灵机 (NTM)，它被设计用来判定语言 $L = \\{w \\in \\{0,1\\}^* \\mid w \\text{ 包含至少一个 '1'}\\}$。该机器的形式化定义如下：\n*   状态集: $Q = \\{q_0, q_{move}, q_{check}, q_{acc}, q_{rej}\\}$\n*   输入字母表: $\\Sigma = \\{0, 1\\}$\n*   带字母表: $\\Gamma = \\{0, 1, \\sqcup\\}$, 其中 $\\sqcup$ 是空白符号。\n*   初始状态: $q_0$\n*   接受状态: $q_{acc}$\n*   拒绝状态: $q_{rej}$\n*   转移函数 $\\delta$:\n    1.  $\\delta(q_0, c) = \\{(q_{\\text{move}}, c, R)\\}$ 对于任意 $c \\in \\{0, 1\\}$\n    2.  $\\delta(q_{\\text{move}}, c) = \\{(q_{\\text{move}}, c, R), (q_{\\text{check}}, c, S)\\}$ 对于任意 $c \\in \\{0, 1\\}$\n    3.  $\\delta(q_{\\text{move}}, \\sqcup) = \\{(q_{\\text{rej}}, \\sqcup, S)\\}$\n    4.  $\\delta(q_{\\text{check}}, 1) = \\{(q_{\\text{acc}}, 1, S)\\}$\n    5.  $\\delta(q_{\\text{check}}, 0) = \\{(q_{\\text{rej}}, 0, S)\\}$\n\n机器的一个格局 (configuration) 由符号串 $uqv$ 描述，表示当前状态为 $q$，带上内容为字符串 $uv$，且读写头正在扫描 $v$ 的第一个符号。对于输入字符串 $w$，初始格局为 $q_0w$。\n\n一个 NTM 的计算过程可以被可视化为一棵计算树，其中根节点是初始格局（第 0 层），第 $k+1$ 层的节点是从第 $k$ 层的格局经过一步可以达到的所有可能格局。\n\n给定输入字符串 $w = 101$，这台 NTM 在其计算树的第 2 层的所有不同格局的集合是什么？\n\nA. {$1q_{\\text{move}}01$, $1q_{\\text{check}}01$}\n\nB. {$1q_{\\text{move}}01$, $q_{\\text{check}}101$}\n\nC. {$10q_{\\text{move}}1$, $1q_{\\text{check}}01$, $q_{\\text{check}}101$}\n\nD. {$10q_{\\text{move}}1$, $1q_{\\text{check}}01$}\n\nE. {$10q_{\\text{move}}1$, $10q_{\\text{check}}1$, $1q_{\\text{check}}01$}",
            "solution": "我们使用格局表示法 $uqv$，其中带上内容为 $uv$，读写头扫描 $v$ 的第一个符号，当前状态为 $q$。对于输入 $w=101$，初始格局（第 0 层）是 $q_0101$。\n\n从 $q_0$ 读到 $1$，应用规则 1：$\\delta(q_0,1)=\\{(q_{\\text{move}},1,R)\\}$。将 $1$ 写回不变并向右移动，得到第 1 层的格局 $1q_{\\text{move}}01$。\n\n在第 2 层，我们从 $1q_{\\text{move}}01$ 进行扩展。此时，读写头读到 $0$，应用规则 2：$\\delta(q_{\\text{move}},0)=\\{(q_{\\text{move}},0,R),(q_{\\text{check}},0,S)\\}$。\n- 选择 $(q_{\\text{move}},0,R)$ 会写入 $0$，向右移动，并保持在 $q_{\\text{move}}$ 状态，得到 $10q_{\\text{move}}1$。\n- 选择 $(q_{\\text{check}},0,S)$ 会写入 $0$，停在原地，并切换到 $q_{\\text{check}}$ 状态，得到 $1q_{\\text{check}}01$。\n\n在这一层没有其他转移适用（没有读到空白符号，并且从 $q_{\\text{check}}$ 状态进入接受状态需要读到 $1$，而进入 $q_{\\text{check}}$ 状态的这个分支当前读到的符号不是 $1$）。因此，在第 2 层的所有不同格局的集合是 {$10q_{\\text{move}}1$, $1q_{\\text{check}}01$}，这对应于选项 D。",
            "answer": "$$\\boxed{D}$$"
        },
        {
            "introduction": "现在，让我们将目光从树的局部细节扩展到其整体结构。这个练习展示了一个非确定性图灵机如何为长度为 $n$ 的输入生成一个拥有指数级数量计算路径的完整计算树 。通过分析这台机器的行为，我们可以深刻理解输入大小与计算复杂性之间的直接联系，这是理解 NP 等复杂性类的核心。",
            "id": "1417859",
            "problem": "一个特定的非确定性图灵机（NTM），我们称之为 $M$，被定义在一条单向无限带上运行。$M$ 的状态集为 $\\{q_{gen}, q_{rewind}, q_{check\\_first}, q_{check\\_rest}, q_{accept}, q_{reject}\\}$。输入字母表为 $\\{a\\}$，带字母表为 $\\{a, 0, 1, \\_\\}$，其中 $\\_$ 是空白符号。该机器从状态 $q_{gen}$ 开始，其读写头位于输入串的最左边符号上。转移规则定义如下：\n\n1.  **生成：** 如果处于状态 $q_{gen}$ 并且读取到 'a'，$M$ 会非确定性地选择以下两种移动之一：(i) 写入 '0'，向右移动，并保持在 $q_{gen}$ 状态，或者 (ii) 写入 '1'，向右移动，并保持在 $q_{gen}$ 状态。\n2.  **开始验证：** 在状态 $q_{gen}$ 下读取到空白符号 $\\_$ 时，$M$ 写入 $\\_$，将其读写头向左移动一个位置，并转移到状态 $q_{rewind}$。\n3.  **回绕：** 在状态 $q_{rewind}$ 中，只要读到 '0' 或 '1'，$M$ 就会重复地将其读写头向左移动。当一个内部机制检测到读写头已移动到起始单元格（单元格0）的左侧时，它会自动将读写头放回第一个单元格（单元格1）上，并且机器转移到状态 $q_{check\\_first}$。\n4.  **检查第一个符号：** 在状态 $q_{check\\_first}$ 中，如果读写头读取到 '1'，$M$ 向右移动并转移到 $q_{check\\_rest}$。如果读取到 '0'，它会立即转移到停机状态 $q_{reject}$。\n5.  **检查剩余部分：** 在状态 $q_{check\\_rest}$ 中，如果读写头读取到 '0'，$M$ 向右移动并保持在 $q_{check\\_rest}$ 状态。如果读取到 '1'，它会立即转移到停机状态 $q_{reject}$。\n6.  **接受/拒绝：** 如果 $M$ 处于状态 $q_{check\\_rest}$ 并读取到空白符号 $\\_$，它会转移到停机状态 $q_{accept}$。状态 $q_{reject}$ 也是一个停机状态。对于任何未在上面明确定义转移的配置，机器都会转移到 $q_{reject}$。\n\n这个 NTM 在输入串 $w = a^n$ 上运行，该串由符号 'a' 重复 $n$ 次组成，其中 $n$ 是一个正整数。NTM 在此输入上的计算可以表示为一个计算树，其中从根到叶节点（一个停机配置）的每条路径代表一种可能的非确定性选择序列。\n\n确定 NTM $M$ 在输入 $a^n$ 上的计算树中不同路径的总数的公式。请用关于 $n$ 的闭式解析表达式来表示你的答案。",
            "solution": "将计算树理解为仅在机器做出非确定性选择的地方产生分支。在输入为 $a^{n}$ 的情况下，处于状态 $q_{gen}$ 时，读写头从左到右精确地扫描 $n$ 个输入符号中的每一个，并在每个符号处非确定性地选择两种操作之一：写入 $0$ 或写入 $1$，然后向右移动并保持在 $q_{gen}$ 状态。根据乘法法则，在这个生成阶段中，不同的非确定性选择序列的总数为\n$$\n2 \\times 2 \\times \\cdots \\times 2 = 2^{n}.\n$$\n一旦读取到第 $n$ 个符号右侧的空白符 $\\_$，机器便确定性地执行回绕和验证阶段。在 $q_{rewind}$、$q_{check\\_first}$ 和 $q_{check\\_rest}$ 中的转移对于给定的已生成的长度为 $n$ 的二进制串是确定性的，任何未定义的情况都会直接进入停机状态 $q_{reject}$。因此，每个不同的非确定性生成选择序列都精确地决定了一条从根到叶的停机路径（停机于 $q_{accept}$ 或 $q_{reject}$）。因此，不同的从根到叶的计算路径的总数等于长度为 $n$ 的二进制串的数量，即 $2^{n}$。等价地，通过计算在 $n$ 个位置中放置 1 的所有可能方式，我们有\n$$\n\\sum_{k=0}^{n} \\binom{n}{k} = 2^{n}.\n$$\n因此，不同计算路径的总数为 $2^{n}$。",
            "answer": "$$\\boxed{2^{n}}$$"
        }
    ]
}