{
    "hands_on_practices": [
        {
            "introduction": "理解一个复杂性类别的闭包性质，是掌握其结构与能力的关键。正如整数集合在加法和乘法下是封闭的，语言的集合也可以在某些运算（如并集、连接）下保持其复杂性。这个练习  邀请我们探索 NP 类在一些基本语言运算下的行为，包括并集、连接、克林星号和循环移位。通过为这些运算构造新的验证者，你将亲身体验到 NP 类的“健壮性”，并掌握证明其闭包性质的核心技巧。",
            "id": "1415409",
            "problem": "在计算复杂性理论中，复杂性类“非确定性多项式时间”（Nondeterministic Polynomial-time, NP）被定义为这样一类判定问题的集合：对于这类问题的任何一个“是”实例，都存在一个证书，该证书可以被一个确定性图灵机在多项式时间内验证。一个重要的研究领域是理解哪些对语言的操作能够保持该类的成员资格。\n\n设 $\\Sigma$ 是一个有限字母表。对于 $\\Sigma$ 上的任何属于 NP 类的语言 $L, L_1, L_2$，考虑以下生成新语言的操作：\n\n1.  **并集：** $L_1 \\cup L_2 = \\{w \\mid w \\in L_1 \\text{ 或 } w \\in L_2\\}$\n2.  **连接：** $L_1 L_2 = \\{w_1 w_2 \\mid w_1 \\in L_1 \\text{ 且 } w_2 \\in L_2\\}$\n3.  **克林星号：** $L^* = \\bigcup_{i \\ge 0} L^i$，其中 $L^0 = \\{\\epsilon\\}$（只包含空字符串的语言），且对于 $i \\ge 1$，$L^i = L L^{i-1}$。\n4.  **补集：** $\\overline{L} = \\{w \\in \\Sigma^* \\mid w \\notin L\\}$\n5.  **循环移位：** $CYCLE(L) = \\{vu \\mid uv \\in L \\text{ 对于某些字符串 } u, v \\in \\Sigma^*\\}$\n\n下列哪个陈述是正确的？选择所有适用的选项。\n\nA. 语言 $L_1 \\cup L_2$ 总是在 NP 中。\n\nB. 语言 $L_1 L_2$ 总是在 NP 中。\n\nC. 语言 $L^*$ 总是在 NP 中。\n\nD. 语言 $\\overline{L}$ 总是在 NP 中。\n\nE. 语言 $CYCLE(L)$ 总是在 NP 中。",
            "solution": "我们使用 NP 的验证者定义。一个语言 $L \\subseteq \\Sigma^*$ 属于 NP，如果存在一个确定性多项式时间验证者 $V$ 和一个多项式 $p$，使得对于每个 $x \\in \\Sigma^*$，\n$$\nx \\in L \\iff \\exists y \\in \\Sigma^* \\text{ 使得 } |y| \\le p(|x|) \\text{ 且 } V(x, y) = 1.\n$$\n我们将展示 NP 在除了补集之外的每种运算下都是封闭的，因为对补集的闭包性将意味着 $\\mathbf{NP}=\\mathbf{coNP}$，而这一点尚不确定。\n\n对于并集，假设 $L_1, L_2 \\in \\mathbf{NP}$，其验证者分别为 $V_1, V_2$，多项式分别为 $p_1, p_2$。为 $L_1 \\cup L_2$ 定义一个验证者 $V$，它在输入 $(w, b, y)$ 时，首先检查 $b \\in \\{1, 2\\}$，如果 $b=1$ 则运行 $V_1(w, y)$，如果 $b=2$ 则运行 $V_2(w, y)$。如果 $w \\in L_1 \\cup L_2$，那么存在 $b \\in \\{1, 2\\}$ 和一个证书 $y$，其长度 $|y| \\le \\max\\{p_1(|w|), p_2(|w|)\\}$，能使 $V$ 接受。运行时间是 $|w|$ 的多项式，证书长度也是多项式，所以 $L_1 \\cup L_2 \\in \\mathbf{NP}$。因此 A 是正确的。\n\n对于连接，假设 $L_1, L_2 \\in \\mathbf{NP}$，其验证者分别为 $V_1, V_2$，多项式分别为 $p_1, p_2$。对于 $w \\in \\Sigma^*$，$w \\in L_1L_2$ 当且仅当存在字符串 $w_1, w_2$ 使得 $w=w_1w_2$，$w_1 \\in L_1$ 且 $w_2 \\in L_2$。定义一个验证者 $V$，它在输入 $(w, i, y_1, y_2)$ 时，首先将 $w$ 解析为 $w=w_1w_2$，其中 $|w_1|=i$，然后运行 $V_1(w_1, y_1)$ 和 $V_2(w_2, y_2)$，如果两者都接受，则接受。如果 $w \\in L_1L_2$，那么存在一个分割点 $i$ 和证书 $y_1, y_2$，其长度 $|y_1| \\le p_1(|w_1|) \\le p_1(|w|)$ 且 $|y_2| \\le p_2(|w_2|) \\le p_2(|w|)$，能使 $V$ 接受。总证书长度最多为 $|i| + |y_1| + |y_2|$，这是 $|w|$ 的多项式，并且验证过程在 $|w|$ 的多项式时间内运行。因此 $L_1L_2 \\in \\mathbf{NP}$。因此 B 是正确的。\n\n对于克林星号，假设 $L \\in \\mathbf{NP}$，其验证者为 $V$，多项式为 $p$。对于 $w \\in \\Sigma^*$，$w \\in L^*$ 当且仅当存在一个整数 $k \\ge 0$ 和一个划分 $w = w_1 \\dots w_k$，其中每个 $w_i \\in L$（约定 $k=0$ 仅当 $w=\\epsilon$ 时成立）。定义一个验证者，它在输入 $(w, k, i_1, \\dots, i_{k-1}, y_1, \\dots, y_k)$ 时，使用切分位置 $i_1, \\dots, i_{k-1}$ 将 $w$ 解析为 $w_1, \\dots, w_k$，检查 $k \\le |w|+1$（以排除指数级数量的空片段），然后对每个 $i$ 运行 $V(w_i, y_i)$，如果全部接受，则接受。如果 $w \\in L^*$，存在某个划分，其 $k \\le |w|+1$，并且证书 $y_i$ 满足 $|y_i| \\le p(|w_i|)$。设 $p(n) \\le C n^d$，其中 $C, d \\in \\mathbb{N}$ 为某些常数。那么总证书长度最多为\n$$\nO(\\log |w|) + \\sum_{i=1}^{k} p(|w_i|) \\le O(\\log |w|) + C \\sum_{i=1}^{k} |w_i|^d \\le O(\\log |w|) + C |w|^d,\n$$\n因为 $\\sum_{i=1}^{k} |w_i|=|w|$ 并且对于 $d \\ge 1$，有 $\\sum_{i} |w_i|^d \\le (\\sum_{i} |w_i|)^d = |w|^d$。验证者运行 $k \\le |w|+1$ 次对 $V$ 的调用，每次调用都是 $|w|$ 的多项式时间，因此总时间是 $|w|$ 的多项式时间。因此 $L^* \\in \\mathbf{NP}$。因此 C 是正确的。\n\n对于补集，如果对于每个 $L \\in \\mathbf{NP}$ 都有 $\\overline{L} \\in \\mathbf{NP}$，那么 $\\mathbf{NP}=\\mathbf{coNP}$。这个等式是否成立尚不确定。因此，通常不能断言 NP 对补集运算是封闭的。因此 D 是错误的。\n\n对于循环移位，定义 $CYCLE(L) = \\{vu \\mid \\exists u, v \\in \\Sigma^* \\text{ 使得 } uv \\in L\\}$。假设 $L \\in \\mathbf{NP}$，其验证者为 $V$，多项式为 $p$。为 $CYCLE(L)$ 定义一个验证者 $V'$ 如下：在输入 $(x, s, y)$ 时，其中 $x \\in \\Sigma^*$，$s$ 是一个满足 $0 \\le s \\le |x|$ 的分割位置，将 $x$ 写成 $x=vu$，其中 $|v|=s$，构造出 $uv$，然后运行 $V(uv, y)$，如果 $V$ 接受，则接受。如果 $x \\in CYCLE(L)$，那么存在 $u, v$ 使得 $x=vu$ 且 $uv \\in L$，因此存在 $y$ 使得 $|y| \\le p(|uv|) = p(|x|)$ 且 $V(uv,y)=1$。证书长度为 $|s|+|y|$，这是 $|x|$ 的多项式，并且验证过程在多项式时间内运行。因此 $CYCLE(L) \\in \\mathbf{NP}$。因此 E 是正确的。\n\n综合以上，正确的陈述是 A、B、C 和 E。",
            "answer": "$$\\boxed{ABCE}$$"
        },
        {
            "introduction": "在概括性地证明了 NP 对克林星号运算是封闭的之后，让我们通过一个具体的例子来加深理解。这个实践  将抽象的证明过程应用于著名的 NP 完全问题——布尔可满足性问题 (SAT)。你的任务是为语言 $L_{SAT}^*$ 设计一个实际的验证者，该语言由任意多个可满足布尔公式的字符串连接而成。这迫使我们思考验证者证书 (certificate) 的具体结构：如何既能高效地指明原字符串的分割方式，又能同时证明每个子部分确实是可满足的？",
            "id": "1415399",
            "problem": "在计算复杂性理论中，语言 $SAT$ 包含所有编码了可满足布尔公式的字符串。布尔公式使用变量（例如，$x_1, x_2, \\ldots$）、括号以及逻辑连接词，如与（AND, $\\land$）、或（OR, $\\lor$）和非（NOT, $\\neg$）。如果存在一种对其变量赋“真”（TRUE）或“假”（FALSE）值的指派，使得整个公式的计算结果为“真”，那么该公式是可满足的。\n\n一个语言 $L$ 的克林星号（Kleene star），记作 $L^*$，是由 $L$ 中的零个或多个字符串连接而成的所有字符串的集合。空字符串总是 $L^*$ 的成员。\n\n考虑语言 $L_{SAT}^* = (SAT)^*$。一个非空字符串 $w$ 属于 $L_{SAT}^*$ 当且仅当 $w$ 可以被解析为一个或多个字符串的连接 $w = \\phi_1 \\phi_2 \\dots \\phi_k$，其中每个 $\\phi_i$ 都是一个可满足布尔公式的字符串表示。例如，如果 $\\phi_1 = (x_1 \\lor x_2)$ 且 $\\phi_2 = (x_3 \\land \\neg x_3)$，那么 $\\phi_1$ 属于 $SAT$ 而 $\\phi_2$ 不属于。字符串 \"$(x_1 \\lor x_2)$\" 属于 $L_{SAT}^*$，但字符串 \"$(x_1 \\lor x_2)(x_3 \\land \\neg x_3)$\" 不属于，因为第二部分是不可满足的。\n\n如果一个语言 $L$ 存在一个多项式时间验证机，那么它就属于复杂度类 NP。验证机 $V$ 是一个算法，它接受一个输入字符串 $w$ 和一个证据字符串 $c$。该验证机必须满足以下两个属性：\n1.  **完备性**：对于任何字符串 $w \\in L$，必须存在一个证据 $c$，使得 $V(w, c)$ 接受。\n2.  **可靠性**：对于任何字符串 $w \\notin L$，对于所有可能的证据 $c$，$V(w, c)$ 都必须拒绝。\n此外，验证机 $V$ 的运行时间必须是输入字符串长度 $|w|$ 的多项式。这意味着证据的长度 $|c|$ 也必须是 $|w|$ 的多项式。\n\n下列哪个选项正确地描述了语言 $L_{SAT}^*$ 的一个有效的多项式时间验证机？\n\nA. 证据 $c$ 是满足性指派的串联，每个指派对应输入字符串 $w$ 中被认为是一个公式的部分。验证机非确定性地猜测 $w$ 到子公式 $\\phi_1, \\dots, \\phi_k$ 的一个划分，然后使用证据来检查每个 $\\phi_i$ 是否被其对应的指派所满足。\n\nB. 证据 $c$ 由两部分组成：首先，一个整数列表，指定将输入字符串 $w$ 划分为子公式 $\\phi_1, \\dots, \\phi_k$ 的边界；其次，满足性指派 $a_1, \\dots, a_k$ 的串联。验证机首先使用边界信息将 $w$ 解析为子公式。然后，对于每个子公式 $\\phi_i$，它检查来自证据的相应指派 $a_i$ 是否满足它。当且仅当每个子公式在语法上有效且被其指派满足时，验证机才接受。\n\nC. 证据 $c$ 包含一个指定将 $w$ 划分为子公式 $\\phi_1, \\dots, \\phi_k$ 的边界的整数列表，以及一个对 $w$ 中出现的所有变量的单一全局满足性指派。验证机解析 $w$ 并检查这个单一指派是否满足每个子公式 $\\phi_i$。\n\nD. 验证机不需要证据。它的工作方式是尝试将输入字符串 $w$ 划分为子串 $\\phi_1, \\dots, \\phi_k$ 的所有可能方式。对于每种划分，它使用一个 SAT 求解器来检查每个子串 $\\phi_i$ 是否可满足。如果找到这样一种所有子串都可满足的划分，它就接受。\n\nE. 证据 $c$ 是针对其中一个子公式的单一满足性指派。验证机非确定性地猜测 $w$ 到子公式 $\\phi_1, \\dots, \\phi_k$ 的一个划分，并且也非确定性地猜测证据适用于哪个子公式 $\\phi_i$。然后它验证这个单一的 $\\phi_i$ 是否被该证据所满足。如果此检查通过，它就接受。",
            "solution": "为了确定 $L_{SAT}^* = (SAT)^*$ 的正确的多项式时间验证机，我们必须分析问题的结构以及复杂度类 NP 中对验证机的要求。\n\n一个字符串 $w$ 属于 $L_{SAT}^*$ 如果它可以被分解为一系列可满足的公式，$w = \\phi_1 \\phi_2 \\dots \\phi_k$。对于这个语言的验证机，必须在给定一个合适的证据的情况下，在多项式时间内确认两件事：\n1.  $w$ 分解成 $\\phi_1, \\dots, \\phi_k$ 的具体方式。\n2.  这个分解中的每个公式 $\\phi_i$ 都是可满足的。\n\n验证 $L_{SAT}^*$ 成员资格的核心困难源于这两点。\n首先，将一个长度为 $n$ 的字符串 $w$ 划分为子串的方法有 $2^{n-1}$ 种，这是指数级的。一个多项式时间的验证机无法尝试所有可能的划分。因此，关于正确划分的信息必须在证据中提供。\n其次，确定单个布尔公式 $\\phi_i$ 是否可满足是 NP 完全问题 $SAT$。一个多项式时间的验证机无法自行解决这个问题。可满足性的“证明”，即一个满足性指派，必须在证据中为每个公式 $\\phi_i$ 提供。\n\n让我们基于这些见解构建一个正确的验证机，然后评估给定的选项。\n\n**正确的验证机设计：**\n*   **证据 ($c$)**：证据必须提供所有需要的非确定性信息。\n    1.  **划分信息**：一个整数列表，用于指定每个子公式 $\\phi_i$ 的终点。对于一个长度为 $n$ 的字符串 $w$ 和一个划分为 $k$ 个公式的情况，这可以是一个包含 $k-1$ 个索引的列表。该列表的长度最多为 $n-1$，因此其大小是 $n$ 的多项式。\n    2.  **满足性指派**：对于每个子公式 $\\phi_i$，提供一个满足性指派 $a_i$。任何 $\\phi_i$ 中的变量数量最多为 $|\\phi_i| \\le n$。串联起来的指派的总长度 $\\sum |a_i|$ 是 $n$ 的多项式（最多为 $O(n^2)$）。\n    因此，总证据长度是 $|w|$ 的多项式。\n\n*   **验证机算法 ($V(w, c)$)**：\n    1.  解析证据 $c$ 以提取划分索引和指派列表 $(a_1, a_2, \\dots, a_k)$。如果证据格式不正确，则拒绝。\n    2.  使用这些索引将输入字符串 $w$ 划分为子串 $\\phi_1, \\phi_2, \\dots, \\phi_k$。如果索引无效（例如，不按递增顺序、超出边界），则拒绝。\n    3.  从 $i=1$ 到 $k$ 进行迭代：\n        a. 检查子串 $\\phi_i$ 是否是一个语法上格式良好的布尔公式。这可以在 $|\\phi_i|$ 的多项式时间内完成。如果不是，则拒绝。\n        b. 使用指派 $a_i$ 对公式 $\\phi_i$ 求值。这也是一个关于 $|\\phi_i|$ 的多项式时间操作。如果结果为“假”（FALSE），则拒绝。\n    4.  如果循环完成而没有拒绝，这意味着每个子公式在语法上都是有效的，并且被其提供的指派所满足。因此，接受。\n\n*   **复杂度分析**：该验证机的运行时间是解析、划分和循环时间的总和。循环运行 $k$ 次（$k \\le |w|$）。循环内部的工作量是 $|\\phi_i|$ 的多项式。总时间复杂度为 $\\sum_{i=1}^k \\text{poly}(|\\phi_i|)$，这是总长度 $|w| = \\sum |\\phi_i|$ 的多项式。这满足了多项式时间的要求。\n\n现在我们来评估给出的选项：\n\n**A. 证据 $c$ 是满足性指派的串联... 验证机非确定性地猜测一个划分...**\n这是不正确的。一个确定性的多项式时间验证机不能“非确定性地猜测”。验证机是一个确定性算法。非确定性体现在对证据的存在性要求上。如果它是一个确定性验证机，它将不得不尝试所有指数级的划分，这不是多项式时间。\n\n**B. 证据 $c$ 由两部分组成：首先，一个指定边界的整数列表... 其次，满足性指派的串联... 验证机首先使用边界信息来解析... 然后，对于每个子公式 $\\phi_i$，它检查相应的指派 $a_i$ ... 是否满足它。**\n这个选项与我们推导出的正确验证机设计完全匹配。证据既提供了划分信息，也提供了每个公式可满足性的独立证明（即指派）。验证机在多项式时间内确定性地检查这些证明。这正确地描述了一个有效的多项式时间验证机。\n\n**C. 证据 $c$ 包含...一个对 $w$ 中出现的所有变量的单一全局满足性指派。**\n这是不正确的。各个公式 $\\phi_i$ 是独立的。即使不存在可以同时满足所有子公式的单一指派，字符串 $w$ 仍可能属于 $L_{SAT}^*$。例如，考虑 $w = \\phi_1 \\phi_2$，其中 $\\phi_1$ 是 \"$x_1$\"，$\\phi_2$ 是 \"$\\neg x_1$\"。$\\phi_1$ 和 $\\phi_2$ 都属于 $SAT$。因此，$w \\in L_{SAT}^*$。然而，没有单一的对 $x_1$ 的指派能同时满足两者。$\\phi_1$ 需要指派 $\\{x_1=\\text{TRUE}\\}$，而 $\\phi_2$ 需要 $\\{x_1=\\text{FALSE}\\}$。因此，需要分开的指派。\n\n**D. 验证机不需要证据。它的工作方式是尝试每一种可能的划分...**\n这是不正确的。如前所述，对于长度为 $n$ 的字符串，有 $2^{n-1}$ 种可能的划分。尝试所有这些划分将花费指数时间，因此该算法不是一个多项式时间的验证机。此外，对于每个划分，它都需要为每个子公式解决 SAT 问题，而 SAT 本身就是一个 NP 完全问题。\n\n**E. 证据 $c$ 是针对其中一个子公式的单一满足性指派... 然后它验证这个单一的 $\\phi_i$ 是否被满足... 如果此检查通过，它就接受。**\n这是不正确的。$L_{SAT}^*$ 的定义要求划分中的*所有*子公式都必须是可满足的。只验证一个是不够的，并且违反了可靠性属性。例如，如果 $w = \\phi_1\\phi_2$ 其中 $\\phi_1$ 可满足而 $\\phi_2$ 不可满足，这里描述的验证机可能会因为被给予了 $\\phi_1$ 的指派而错误地接受 $w$（它并不在 $L_{SAT}^*$ 中）。\n\n基于此分析，选项 B 是唯一正确描述 $L_{SAT}^*$ 的有效多项式时间验证机的选项。",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "除了基于字符串拼接的运算，NP 类的闭包性质还体现在更抽象的逻辑操作上。这个练习  探讨了 NP 在“投影”（或“存在量化”）运算下的闭包性，这正是 NP 定义的核心——“存在”一个证书。如果我们可以验证关于一对字符串 $(x, y)$ 的某个性质，那么我们是否也能验证对于给定的 $x$，确实“存在”一个满足该性质的 $y$ 呢？通过构造一个新的证书，将存在性证明（即 $y$ 本身）与原始问题的证书 $w$ 巧妙地结合起来，我们将揭示 NP 类这一深刻的结构特性。",
            "id": "1415437",
            "problem": "在计算复杂性理论中，NP 类（非确定性多项式时间）包含的是那些提议的解可以被高效验证的判定问题。形式上，如果存在一个确定性多项式时间图灵机 $V$（称为验证机）和一个多项式 $p(n)$，使得对于字母表 $\\Sigma$ 上的任何字符串 $s \\in \\Sigma^*$，语言 $A$ 属于 NP：\n$s \\in A$ 当且仅当存在一个证书字符串 $c \\in \\Sigma^*$，满足 $|c| \\le p(|s|)$，使得 $V$ 接受对 $(s, c)$。\n\n考虑一个字符串对的语言 $L \\subseteq \\Sigma^* \\times \\Sigma^*$，已知其属于 NP。这意味着存在一个多项式时间验证机 $V_L$ 和一个多项式 $p_L$，使得对于任何字符串对 $(x,y)$：\n$(x,y) \\in L$ 当且仅当存在一个证书 $w$，满足 $|w| \\le p_L(|x|+|y|)$，使得 $V_L$ 接受输入 $((x,y), w)$。\n此外，对于任何 $(x,y) \\in L$，字符串 $y$ 的长度由字符串 $x$ 的长度多项式地界定；也就是说，存在一个多项式 $q$ 使得 $|y| \\le q(|x|)$。\n\n现在，考虑将 $L$ 投影到其第一个分量上，这定义了一个新语言 $L_1$：\n$$L_1 = \\{ x \\in \\Sigma^* \\mid \\exists y \\in \\Sigma^* \\text{ such that } (x,y) \\in L \\}$$\n为了证明 $L_1$ 也属于 NP，必须构造一个新的多项式时间验证机，我们称之为 $V_1$，并为其确定一个合适的证书。以下哪个选项正确地描述了这样一个验证机 $V_1$ 对于输入字符串 $x$ 的构造和操作？\n\nA. $V_1$ 接受输入 $x$ 和一个证书 $w$。它非确定性地猜测一个多项式长度的字符串 $y$，然后在输入 $((x,y), w)$ 上模拟原始验证机 $V_L$。\n\nB. $V_1$ 接受输入 $x$ 和一个由字符串 $y$ 组成的证书。然后它在输入 $((x,y), \\epsilon)$ 上模拟原始验证机 $V_L$，其中 $\\epsilon$ 是空字符串，如果 $V_L$ 接受，则它也接受。\n\nC. $V_1$ 接受输入 $x$ 和一个证书 $c'$，该证书是字符串对 $\\langle y, w \\rangle$ 的编码。$V_1$ 首先解析 $c'$ 以提取 $y$ 和 $w$。然后它在输入 $((x,y), w)$ 上模拟原始验证机 $V_L$，并且当且仅当 $V_L$ 接受时它才接受。\n\nD. 语言 $L_1$ 不一定属于 NP，因为所需的字符串 $y$ 的长度没有界，所以验证机无法在相对于 $x$ 长度的多项式时间内处理它。\n\nE. $V_1$ 接受输入 $x$ 和一个证书 $c'$，该证书是字符串对 $\\langle y, w \\rangle$ 的编码。它首先验证 $y$ 是某个已知的 NP 完全语言的成员并且 $|w| \\le p_L(|x|+|y|)$，然后在输入 $((x,y), w)$ 上模拟 $V_L$。",
            "solution": "给定一个属于 $\\mathbf{NP}$ 的字符串对语言 $L \\subseteq \\Sigma^* \\times \\Sigma^*$。因此，存在一个确定性多项式时间验证机 $V_L$ 和一个多项式 $p_L$，使得对于任何 $(x,y)$，\n$$(x,y) \\in L \\iff \\exists w \\in \\Sigma^* \\text{ with } |w| \\le p_L(|x|+|y|) \\text{ and } V_L(((x,y),w)) \\text{ accepts}.$$\n我们还被告知第二个分量有一个多项式界：存在一个多项式 $q$，使得对于所有 $(x,y) \\in L$，我们有\n$$|y| \\le q(|x|).$$\n定义投影语言\n$$L_1 = \\{ x \\in \\Sigma^* \\mid \\exists y \\in \\Sigma^* \\text{ such that } (x,y) \\in L \\}.$$\n为证明 $L_1 \\in \\mathbf{NP}$，我们必须构造一个确定性多项式时间验证机 $V_1$ 和一个多项式 $p_1$，使得对于任何 $x$，\n$$x \\in L_1 \\iff \\exists c' \\in \\Sigma^* \\text{ with } |c'| \\le p_1(|x|) \\text{ and } V_1((x,c')) \\text{ accepts}.$$\n\n证书和验证机的构造：\n- 令 $x$ 的证书为一个标准的字符串对 $(y,w)$ 的编码 $c' = \\langle y, w \\rangle$。使用任何固定的、多项式时间可解码且长度为多项式有界的配对函数。具体来说，存在一个多项式 $r$，使得对于所有字符串 $y,w$，\n$$|\\langle y, w \\rangle| \\le r(|y| + |w|),$$\n并且将 $\\langle y, w \\rangle$ 解码为 $(y,w)$ 的计算时间是 $|\\langle y, w \\rangle|$ 的多项式时间。\n- 验证机 $V_1$，在输入 $(x,c')$ 上执行：\n  1. 解析 $c'$ 以获得 $(y,w)$。\n  2. 在输入 $((x,y),w)$ 上模拟 $V_L$。\n  3. 当且仅当 $V_L$ 接受时接受。\n\n正确性：\n- 可靠性：如果 $V_1$ 接受 $(x,c')$，那么解析出的 $(y,w)$ 会使 $V_L$ 接受 $((x,y),w)$。因此，$(x,y) \\in L$，所以 $x \\in L_1$。\n- 完备性：如果 $x \\in L_1$，那么存在 $y$ 使得 $(x,y) \\in L$。根据 $L$ 属于 NP 的性质，存在 $w$ 满足 $|w| \\le p_L(|x|+|y|)$ 且 $V_L$ 接受 $((x,y),w)$。那么 $c'=\\langle y,w \\rangle$ 会使 $V_1$ 接受。\n\n多项式证书大小：\n令 $s = |x|$。使用给定的界 $|y| \\le q(s)$ 和验证机的界 $|w| \\le p_L(|x|+|y|)$，我们有\n$$|w| \\le p_L(s + |y|) \\le p_L(s + q(s)).$$\n因此证书长度满足\n$$|c'| = |\\langle y, w \\rangle| \\le r(|y| + |w|) \\le r\\big(q(s) + p_L(s + q(s))\\big).$$\n定义多项式\n$$p_1(n) = r\\big(q(n) + p_L(n + q(n))\\big),$$\n所以 $|c'| \\le p_1(|x|)$。\n\n多项式时间验证：\n将 $c'$ 解析为 $(y,w)$ 的时间是 $|c'|$ 的多项式，因此也是 $|x|$ 的多项式。$V_L$ 的输入大小为 $|(x,y)| + |w| \\le |x| + |y| + |w| \\le s + q(s) + p_L(s + q(s))$，这是 $s$ 的多项式。由于 $V_L$ 在其输入长度的多项式时间内运行，因此 $V_1$ 的总运行时间是 $|x|$ 的多项式。\n\n因此，通过上面构造的验证机 $V_1$，我们得出 $L_1 \\in \\mathbf{NP}$。在这些选项中，这完全对应于选项 C 的描述：证书编码了 $y$ 和 $w$ 两者，$V_1$ 解析它们并在 $((x,y),w)$ 上运行 $V_L$。\n\n为什么其他选项不正确：\n- A：在 NP 验证的定义中，验证机是确定性的；它不能依赖于对 $y$ 的非确定性猜测。相反，$y$ 必须是证书的一部分。\n- B：$L$ 的原始见证 $w$ 可能非空；省略 $w$ 通常会破坏完备性。\n- D：这是错误的，因为给定了多项式界 $|y| \\le q(|x|)$。\n- E：验证 $y$ 是否属于某个 NP 完全语言是无关的，并且通常不知道是否可以在确定性多项式时间内完成（除非 $\\mathbf{P}=\\mathbf{NP}$）；这对于验证在 $L$ 中的成员资格是不必要的。",
            "answer": "$$\\boxed{C}$$"
        }
    ]
}