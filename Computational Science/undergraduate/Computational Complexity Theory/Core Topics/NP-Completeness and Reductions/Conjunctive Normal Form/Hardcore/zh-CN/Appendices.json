{
    "hands_on_practices": [
        {
            "introduction": "要掌握合取范式，最有效的方法是从最简单的情形入手：1-CNF。这个练习将帮助你巩固可满足性的最基本条件——不存在直接的矛盾。在处理更复杂的公式之前，这是至关重要的第一步，它揭示了可满足性问题的核心逻辑。",
            "id": "1418346",
            "problem": "在计算复杂性理论中，如果一个布尔公式是一个或多个子句的合取（AND，用 $\\land$ 表示），并且每个子句是文字的析取（OR，用 $\\lor$ 表示），那么这个公式被称为合取范式（CNF）。一个文字（literal）要么是一个布尔变量（例如，$x_i$），要么是它的否定（例如，$\\neg x_i$）。\n\n这种情况的一个特例是 **1-CNF 公式**，其中每个子句都只包含一个文字。例如，$\\phi = (x_1) \\land (\\neg x_2) \\land (x_3)$ 是一个 1-CNF 公式。\n\n如果存在至少一个真值指派（为每个变量赋上 TRUE 或 FALSE），使得整个公式的求值结果为 TRUE，那么这个公式就称为**可满足的**。如果不存在这样的指派，该公式就是不可满足的。\n\n一名学生被要求创建一个非常高效的算法，来判断给定的 1-CNF 公式是否可满足。他们意识到，由于 1-CNF 的结构简单，必然存在一个判断其可满足性的直接充要条件。\n\n以下哪个条件是任意给定的 1-CNF 公式可满足的充要条件？\n\nA. 公式最多包含一个子句。\n\nB. 对于每个变量 $x$，公式不同时包含子句 $(x)$ 和子句 $(\\neg x)$。\n\nC. 子句的数量严格小于公式中出现的不同变量的数量。\n\nD. 每个变量最多出现在一个子句中。\n\nE. 公式中至少有一个变量只以正文字（例如，$x_i$）或只以负文字（例如，$\\neg x_j$）的形式出现。",
            "solution": "设一个 1-CNF 公式可以写成单元子句的合取形式：\n$$\n\\phi \\;=\\; \\bigwedge_{i=1}^{m} L_{i},\n$$\n其中每个 $L_{i}$ 是一个文字，即对于某个变量 $x$，$L_{i}$ 是 $x$ 或 $\\neg x$。一个真值指派能满足 $\\phi$ 当且仅当每个子句的求值结果都为 TRUE。\n\n我们主张以下条件是可满足性的充要条件：\n对于每个变量 $x$，$\\phi$ 不同时包含 $(x)$ 和 $(\\neg x)$ 作为子句。这正是选项 B。\n\n必要性：假设对于某个变量 $x$，$\\phi$ 同时包含 $(x)$ 和 $(\\neg x)$。如果一个指派设置 $x=\\text{TRUE}$，那么 $(\\neg x)$ 为 FALSE；如果设置 $x=\\text{FALSE}$，那么 $(x)$ 为 FALSE。因此，没有任何指派可以同时使这两个子句为 TRUE，所以 $\\phi$ 是不可满足的。所以，选项 B 中的条件是必要的。\n\n充分性：假设对于每个变量 $x$，$\\phi$ 不同时包含 $(x)$ 和 $(\\neg x)$。定义一个指派 $a$ 如下：\n- 如果 $(x)$ 出现在 $\\phi$ 中，则设置 $a(x)=\\text{TRUE}$。\n- 否则，如果 $(\\neg x)$ 出现在 $\\phi$ 中，则设置 $a(x)=\\text{FALSE}$。\n- 否则（如果 $x$ 未出现），则任意设置 $a(x)$。\n在指派 $a$ 下，根据构造，任何子句 $(x)$ 都为 TRUE，任何子句 $(\\neg x)$ 也都为 TRUE。因此 $\\phi$ 中所有的子句都为 TRUE，所以 $\\phi$ 是可满足的。所以，选项 B 中的条件是充分的。\n\n为了确认没有其他选项是充要条件：\n- A（最多一个子句）不是必要的：例如，$(x_{1}) \\land (x_{2})$ 是可满足的，但有两个子句。\n- C（子句数量严格小于不同变量的数量）不是必要的：$(x)$ 有一个子句和一个变量，所以不等式不成立，但它却是可满足的。",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "理解了可满足性的基本概念后，我们更进一步，来主动构造一个不可满足的公式。这个问题将挑战你像系统设计师一样思考，确定需要多少个最小约束才能确保矛盾的产生。通过这个练习，你将深入理解为何某些逻辑规则的组合必然导致一个无法实现的情形，并学会如何从“覆盖”所有可能性的角度来证明不可满足性。",
            "id": "1418338",
            "problem": "一个系统工程团队正在为一个关键控制系统设计一个简单的容错检查器。该系统依赖于两个独立的二进制组件，其状态由布尔变量 $x_1$ 和 $x_2$ 表示。“真”状态对应于组件正常运行，“假”状态对应于组件发生故障。\n\n该检查器评估一组被称为安全条件的逻辑规则。当且仅当所有安全条件的逻辑合取（AND）对于组件状态的每一种可能组合都为假时，整个系统被宣告为“固有不稳定”。在这种情况下，无论组件的运行状态如何，逻辑上都保证至少有一个安全条件被违反。\n\n每个安全条件必须被表述为恰好两个文字的逻辑析取（OR）。一个文字被定义为一个组件的状态变量（例如 $x_1$）或其否定（例如 $\\neg x_1$）。此外，为确保全面的交叉检查，每个安全条件必须包含一个与第一个组件（$x_1$）相关的文字和一个与第二个组件（$x_2$）相关的文字。例如，像 $(x_1 \\lor \\neg x_2)$ 这样的条件是有效的，但像 $(x_1 \\lor x_1)$ 或 $(x_1)$ 这样的条件是不允许的。\n\n为了最小化实现成本，该团队希望找到构建一个“固有不稳定”系统所需此类安全条件的绝对最小数量。这个最小数量是多少？",
            "solution": "设组件状态为布尔变量 $x_{1},x_{2}\\in\\{0,1\\}$，其中 $1$ 表示真（正常运行），$0$ 表示假（故障）。每个安全条件都是一个形式为 $(\\ell_{1}\\lor \\ell_{2})$ 的子句，其中 $\\ell_{1}\\in\\{x_{1},\\neg x_{1}\\}$ 且 $\\ell_{2}\\in\\{x_{2},\\neg x_{2}\\}$，即恰好一个来自 $x_1$ 族的文字和一个来自 $x_2$ 族的文字。\n\n逻辑原理：析取 $(\\ell_{1}\\lor \\ell_{2})$ 为假，当且仅当两个文字都为假。因此，每个允许的子句仅被 $(x_1, x_2)$ 的一个赋值所证伪：\n- $(x_{1}\\lor x_{2})$ 仅在 $(x_{1},x_{2})=(0,0)$ 时为假。\n- $(x_{1}\\lor \\neg x_{2})$ 仅在 $(x_{1},x_{2})=(0,1)$ 时为假。\n- $(\\neg x_{1}\\lor x_{2})$ 仅在 $(x_{1},x_{2})=(1,0)$ 时为假。\n- $(\\neg x_{1}\\lor \\neg x_{2})$ 仅在 $(x_{1},x_{2})=(1,1)$ 时为假。\n\n令 $A=\\{(0,0),(0,1),(1,0),(1,1)\\}$ 为所有赋值的集合。对于允许形式的任何子句集合 $\\{C_{i}\\}_{i=1}^{m}$，定义 $\\operatorname{forb}(C_{i})\\in A$ 为证伪 $C_{i}$ 的唯一赋值。合取式 $\\bigwedge_{i=1}^{m} C_{i}$ 是不可满足的（对每个赋值都为假），当且仅当对于每个 $(x_{1},x_{2})\\in A$，存在某个 $i$ 使得 $(x_{1},x_{2})=\\operatorname{forb}(C_{i})$，即：\n$$\n\\{\\operatorname{forb}(C_{1}),\\dots,\\operatorname{forb}(C_{m})\\}=A.\n$$\n由于恰好有四个不同的允许子句，并且每个子句禁止 $A$ 的一个不同元素，因此任何 $m$ 个子句的集合最多禁止 $m$ 个不同的赋值。因此，不可满足性的一个必要条件是 $m\\geq 4$。\n\n这个下界是紧的：取所有四个子句\n$$\n(x_{1}\\lor x_{2})\\land(x_{1}\\lor \\neg x_{2})\\land(\\neg x_{1}\\lor x_{2})\\land(\\neg x_{1}\\lor \\neg x_{2})\n$$\n确保对于任何赋值 $(x_{1},x_{2})\\in A$，上面列出的相应子句为假，从而使整个合取式为假。因此，所需安全条件的最小数量为 $4$。",
            "answer": "$$\\boxed{4}$$"
        },
        {
            "introduction": "当我们证明一个公式不可满足时，这意味着什么？在现实世界的问题中，这通常不代表我们放弃，而是去寻找最佳的折中方案。最后一个练习将你引入MAX-SAT问题，这是一个优化挑战，目标是找到一个能满足最多子句的解，它为你架起了一座从纯粹的逻辑理论通往实际问题解决的桥梁。",
            "id": "1418325",
            "problem": "考虑一个定义在三个变量 $x_1, x_2, x_3$ 上的布尔公式 $\\phi$。该公式以合取范式 (CNF) 给出，即子句的合取 (AND)，其中每个子句是文字的析取 (OR)。一个文字是一个变量或其否定 (例如 $x_1$ 或 $\\neg x_1$)。具体来说，$\\phi$ 是一个 3-CNF 公式，意味着每个子句都恰好包含三个不同的文字。\n\n公式 $\\phi$ 是以下八个子句的合取：\n$C_1 = (x_1 \\lor x_2 \\lor x_3)$\n$C_2 = (x_1 \\lor x_2 \\lor \\neg x_3)$\n$C_3 = (x_1 \\lor \\neg x_2 \\lor x_3)$\n$C_4 = (\\neg x_1 \\lor x_2 \\lor x_3)$\n$C_5 = (x_1 \\lor \\neg x_2 \\lor \\neg x_3)$\n$C_6 = (\\neg x_1 \\lor x_2 \\lor \\neg x_3)$\n$C_7 = (\\neg x_1 \\lor \\neg x_2 \\lor x_3)$\n$C_8 = (\\neg x_1 \\lor \\neg x_2 \\lor \\neg x_3)$\n\n这个公式是不可满足的，意味着不存在对变量 $(x_1, x_2, x_3)$ 的真值指派可以使所有八个子句同时为真。你的任务是解决该公式对应的 MAX-3-SAT 问题。确定单个真值指派可以满足的最大子句数 $N_{max}$，并提供一个能达到此最大值的变量 $(x_1, x_2, x_3)$ 的真值指派。在你的答案中，用数字 1 表示布尔值“真”(True)，用数字 0 表示“假”(False)。",
            "solution": "我们使用布尔求值规则：一个子句 $(\\ell_{1} \\lor \\ell_{2} \\lor \\ell_{3})$ 为假，当且仅当在该指派下每个文字都求值为假；否则该子句为真。对于任意指派 $(a_{1},a_{2},a_{3}) \\in \\{0,1\\}^{3}$，定义子句\n$$\nD(a_{1},a_{2},a_{3}) \\equiv \\bigl(\\ell_{1} \\lor \\ell_{2} \\lor \\ell_{3}\\bigr), \\quad \\text{其中 } \\ell_{i} =\n\\begin{cases}\nx_{i},  \\text{若 } a_{i}=0, \\\\\n\\neg x_{i},  \\text{若 } a_{i}=1.\n\\end{cases}\n$$\n在指派 $(x_{1},x_{2},x_{3})=(a_{1},a_{2},a_{3})$ 下，根据构造，每个 $\\ell_{i}$ 的求值结果都为假，因此 $D(a_{1},a_{2},a_{3})$ 为假。反之，任何其他在 $\\{x_{1},x_{2},x_{3}\\}$ 上不等于 $D(a_{1},a_{2},a_{3})$ 的三文字子句必定包含至少一个与该指派一致的文字，因而其值为真，使得整个子句为真。\n\n给定的公式 $\\phi$ 包含了在 $\\{x_{1},x_{2},x_{3}\\}$ 上所有八种可能的、具有不同符号模式的三文字子句，也就是说，对于每个 $(a_{1},a_{2},a_{3}) \\in \\{0,1\\}^{3}$，它都包含了 $D(a_{1},a_{2},a_{3})$。因此，对于任何指派，都恰好有一个子句被证伪，而其余七个子句被满足。因此，可同时满足的子句的最大数量为\n$$\nN_{\\max}=7.\n$$\n一个达到此最大值的指派是 $(x_{1},x_{2},x_{3})=(1,1,1)$。明确验证如下：\n$$\n\\begin{aligned}\nC_1=(1\\lor 1\\lor 1)=1,\\quad C_{2}=(1\\lor 1\\lor 0)=1,\\quad C_{3}=(1\\lor 0\\lor 1)=1,\\quad C_{4}=(0\\lor 1\\lor 1)=1,\\\\\nC_5=(1\\lor 0\\lor 0)=1,\\quad C_{6}=(0\\lor 1\\lor 0)=1,\\quad C_{7}=(0\\lor 0\\lor 1)=1,\\quad C_{8}=(0\\lor 0\\lor 0)=0,\n\\end{aligned}\n$$\n所以恰好有七个子句被满足。",
            "answer": "$$\\boxed{\\begin{pmatrix} 7  1  1  1 \\end{pmatrix}}$$"
        }
    ]
}