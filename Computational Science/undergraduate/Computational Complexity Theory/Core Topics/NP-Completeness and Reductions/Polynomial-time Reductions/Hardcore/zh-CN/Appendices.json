{
    "hands_on_practices": [
        {
            "introduction": "规约不仅是证明问题难度的理论工具，更是一种强大的解决问题的技巧。我们可以将一个看似棘手的问题转化为一个我们已经有高效解法的经典问题。这个将多米诺骨牌密铺问题转化为图论中的完美匹配问题的练习 ，直观地展示了如何通过构建图模型，将一个几何覆盖谜题映射到一个结构清晰的图论问题上，从而利用成熟的算法来求解。",
            "id": "1436237",
            "problem": "一位建筑师正在使用基于网格的系统设计一个房间的平面图。该房间由一个方格网格表示。一些方格被指定为“障碍”方格，无法铺设瓦片，而其余的“可用”方格必须用1x2的矩形瓦片（通常称为多米诺骨牌）完全覆盖。每块多米诺骨牌必须恰好覆盖两个相邻（即共享一条边）的可用方格。\n\n一位计算机科学家的任务是创建一个算法，以确定给定的平面图是否可以被完美地铺满。根据计算复杂性理论，我们知道 `PERFECT MATCHING` 问题可以被高效地（在多项式时间内）解决。`PERFECT MATCHING` 问题的定义如下：给定一个图 $G=(V, E)$，确定是否存在一个边子集 $M \\subseteq E$，使得顶点集 $V$ 中的每个顶点都恰好是 $M$ 中一条边的端点。\n\n你的任务是形式化一个从多米诺骨牌铺砖问题到 `PERFECT MATCHING` 问题的多项式时间归约。对于一个具有可用方格集合 $S$ 的通用网格，以下哪个选项正确描述了图 $G=(V, E)$ 的构造，使得可用方格存在完美铺砖等价于图 $G$ 中存在完美匹配？\n\nA. 令顶点集 $V$ 为所有可用方格的集合 $S$。当且仅当与顶点 $u$ 和 $v$ 对应的方格在网格中相邻时，边集 $E$ 中存在一条边 $(u, v)$。\n\nB. 令顶点集 $V$ 为所有可用方格的集合 $S$。当且仅当与顶点 $u$ 和 $v$ 对应的方格在同一行或同一列时，边集 $E$ 中存在一条边 $(u, v)$。\n\nC. 令顶点集 $V$ 由网格的每一行的一个顶点和每一列的一个顶点组成。当且仅当位于第 $r$ 行和第 $c$ 列的方格是可用方格时，边集 $E$ 中存在一条边 $(r, c)$。\n\nD. 令顶点集 $V$ 为网格上单个多米诺骨牌所有可能的有效放置方式的集合。当且仅当多米诺骨牌的放置方式 $d_1$ 和 $d_2$ 不重叠时，边集 $E$ 中存在一条边 $(d_1, d_2)$。",
            "solution": "我们将多米诺骨牌在具有可用方格集合 $S$ 的网格上的铺砖问题到 PERFECT MATCHING 问题的归约形式化如下。\n\n图的构造：给定一个网格和可用方格的集合 $S$，通过以下方式定义一个图 $G=(V,E)$：\n$$\nV=S,\\qquad E=\\{\\{u,v\\}\\subseteq S:\\ u\\text{ and }v\\text{ are adjacent squares in the grid}\\}.\n$$\n相邻意味着，如果一个方格由整数坐标 $(i,j)$ 索引，那么 $u=(i,j)$ 和 $v=(i',j')$ 相邻当且仅当 $|i-i'|+|j-j'|=1$。这个构造可以在 $|S|$ 的多项式时间内完成，方法是扫描网格，并为每个 $u\\in S$ 添加连接到其至多四个同样位于 $S$ 中的邻居的边。\n\n正确性（铺砖对应于完美匹配）：多米诺骨牌铺砖是将 $S$ 划分成不相交的相邻方格对。图 $G$ 中的完美匹配是一个集合 $M\\subseteq E$，使得 $V$ 中的每个顶点都恰好与 $M$ 中的一条边相关联。\n\n正向：假设存在一个用多米诺骨牌对 $S$ 的完美铺砖 $\\mathcal{T}$。每块多米诺骨牌恰好覆盖两个相邻的可用方格 $\\{u,v\\}$，因此对应于一条边 $\\{u,v\\}\\in E$。定义\n$$\nM=\\{\\{u,v\\}\\in E:\\ \\{u,v\\}\\text{ is the pair covered by some domino in }\\mathcal{T}\\}.\n$$\n因为 $\\mathcal{T}$ 中的瓦片是不相交的，并且覆盖了 $S$ 中的所有方格，所以 $M$ 中的边是不相交的，并且覆盖了 $V=S$ 中的所有顶点。因此，$M$ 是 $G$ 中的一个完美匹配。\n\n反向：假设 $G$ 有一个完美匹配 $M$。$M$ 中的每条边 $\\{u,v\\}$ 都将两个相邻的可用方格配对。由于 $M$ 是完美的， $M$ 的边是不相交的，并且覆盖了 $V=S$ 中的所有顶点。在每个这样的相邻对 $\\{u,v\\}\\in M$ 上放置一个多米诺骨牌；这些多米诺骨牌是不相交的，并且覆盖了 $S$ 的全部，因此定义了一个完美的铺砖。\n\n因此，当且仅当图 $G$ 有一个完美匹配时，该实例存在一个完美的铺砖。该映射可在多项式时间内计算，因此这是一个有效的多项式时间多一归约。\n\n选项验证：\n- 选项 A 与上述构造完全匹配，是正确的。\n- 选项 B 错误地连接了同一行或同一列中的所有方格，包括不相邻的方格，这允许了与有效多米诺骨牌放置不对应的配对；这是不正确的。\n- 选项 C 使用行和列作为顶点，可用方格作为边；其中的完美匹配将使每一行和每一列都恰好匹配一次，这并不能模型化多米诺骨牌的邻接性或对 $S$ 的覆盖；这是不正确的。\n- 选项 D 将顶点设为多米诺骨牌的放置方式，边表示不重叠；完美匹配会配对放置方式，而不是选择一个覆盖 $S$ 的集合。选择一组不重叠放置的正确结构应该是独立集，而不是完美匹配；这是不正确的。\n\n因此，正确的构造由选项 A 给出。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "接下来，我们将注意力转向规约在计算复杂性理论中的核心应用：证明 NP 困难性 (NP-hardness)。其基本思想是将一个已知的 NP 困难问题（例如子集和问题）规约到一个新问题，从而证明新问题也至少与前者一样“难”。这个从子集和问题 (SUBSET-SUM) 到多项选择子集和问题 (MULTIPLE-CHOICE-SUBSET-SUM) 的规约练习  是这一原则的清晰范例，它巧妙地利用“选择或不选择”这一核心思想，构建出两个问题之间的等价关系。",
            "id": "1436216",
            "problem": "在计算复杂性理论中，我们分析计算问题的难度。如果一个问题可以由确定性图灵机在多项式时间内解决，那么它就属于 P 类问题。如果一个问题的提议解可以在多项式时间内被验证，那么它就属于 NP（非确定性多项式时间）类问题。如果任何 NP 类中的问题都可以在多项式时间内归约到它，那么这个问题就是 NP-hard 的。\n\n考虑以下两个判定问题：\n\n1.  **SUBSET-SUM**：给定一个有限整数集合 $S = \\{s_1, s_2, \\dots, s_n\\}$ 和一个目标整数 $T$，是否存在一个子集 $S' \\subseteq S$，使得 $S'$ 中元素的和恰好等于 $T$？`SUBSET-SUM` 问题是已知的 NP-hard 问题。\n\n2.  **MULTIPLE-CHOICE-SUBSET-SUM (MCSS)**：给定一个包含 $k$ 个非空整数列表的集合 $\\mathcal{L} = \\{L_1, L_2, \\dots, L_k\\}$ 和一个目标整数 $T'$，是否可能从每个列表 $L_i$ 中（对于 $i=1, \\dots, k$）恰好选择一个整数 $x_i$，使得 $\\sum_{i=1}^{k} x_i = T'$？\n\n为了证明 `MCSS` 是 NP-hard 的，一名学生提出了一个从 `SUBSET-SUM` 出发的多项式时间归约。该归约通过以下方式从 `SUBSET-SUM` 的一个实例构造出 `MCSS` 的一个实例：\n\n给定由集合 $S = \\{s_1, s_2, \\dots, s_n\\}$ 和目标 $T$ 定义的 `SUBSET-SUM` 实例，构造出的 `MCSS` 实例由一个包含 $n$ 个列表的集合 $\\mathcal{L} = \\{L_1, L_2, \\dots, L_n\\}$ 和一个目标 $T'$ 定义。对于原始集合 $S$ 中的每个整数 $s_i$，创建一个对应的列表 $L_i = \\{s_i, 0\\}$。`MCSS` 实例的目标被设置为 $T' = T$。\n\n以下哪个陈述正确地评估了所提出的这个用于证明 `MCSS` 的 NP-hard 性的归约？\n\nA. 该构造是一个有效的多项式时间归约，正确地证明了 `MCSS` 是 NP-hard 的。\n\nB. 该构造是无效的，因为它只证明了所需逻辑等价性的一个方向；具体来说，它表明如果一个 `SUBSET-SUM` 实例有解，那么构造出的 `MCSS` 实例也有解，但它未能证明其逆命题。\n\nC. 该构造是无效的，因为从 `SUBSET-SUM` 实例到 `MCSS` 实例的转换无法在相对于 `SUBSET-SUM` 输入大小的多项式时间内计算完成。\n\nD. 该构造是无效的，因为要证明一个问题是 NP-hard 的，必须将它归约*到*一个已知的 NP-hard 问题（即 `MCSS` 到 `SUBSET-SUM`），而不是反过来。\n\nE. 该构造是无效的，因为 `MCSS` 问题要求从*每个*列表中选择一个元素，这没有正确地模拟 `SUBSET-SUM` 问题，在 `SUBSET-SUM` 问题中，可以选择任意数量（从零到 $n$）的元素构成子集。",
            "solution": "要证明一个问题 $Q$ 是 NP-hard 的，只需展示一个从已知的 NP-hard 问题 $P$ 到 $Q$ 的多项式时间多一归约。形式上，我们需要一个函数 $f$，它可以在输入大小的多项式时间内计算，使得对于 $P$ 的每个实例 $x$，$x$ 是 $P$ 的一个“是”实例当且仅当 $f(x)$ 是 $Q$ 的一个“是”实例。这个条件确保了 $Q$ 至少和 $P$ 一样难。\n\n在这里，$P$ 是 SUBSET-SUM，$Q$ 是 MCSS。所提出的归约将 SUBSET-SUM 的一个实例 $(S,T)$（其中 $S=\\{s_{1},\\dots,s_{n}\\}$）映射到 MCSS 的一个实例 $(\\mathcal{L},T')$，其中 $\\mathcal{L}=\\{L_{1},\\dots,L_{n}\\}$，$L_{i}=\\{s_{i},0\\}$ 对每个 $i$ 成立，且 $T'=T$。\n\n首先，该映射是可以在多项式时间内计算的：构造 $n$ 个列表，每个列表包含两个整数 $s_{i}$ 和 $0$，并设置 $T'=T$，这需要的时间是 $n$ 和整数输入大小的多项式，因此是 SUBSET-SUM 实例大小的多项式。\n\n其次，归约的正确性由一个双向蕴含关系得出。\n1. 如果 SUBSET-SUM 实例是一个“是”实例，那么存在一个子集 $S'\\subseteq S$ 使得\n$$\n\\sum_{s\\in S'} s \\;=\\; T.\n$$\n为每个 $i$ 定义一个选择 $x_{i}\\in L_{i}$，方法是：如果 $s_{i}\\in S'$ 则设 $x_{i}=s_{i}$，否则设 $x_{i}=0$。这样，从每个列表中恰好选择了一个元素，并且\n$$\n\\sum_{i=1}^{n} x_{i} \\;=\\; \\sum_{s\\in S'} s \\;=\\; T \\;=\\; T',\n$$\n因此构造出的 MCSS 实例是一个“是”实例。\n\n2. 反过来，如果构造出的 MCSS 实例是一个“是”实例，那么存在选择 $x_{i}\\in L_{i}$（对于 $i=1,\\dots,n$）使得\n$$\n\\sum_{i=1}^{n} x_{i} \\;=\\; T'.\n$$\n根据构造，每个 $x_{i}\\in\\{s_{i},0\\}$。定义 $S'=\\{\\,s_{i}\\in S : x_{i}=s_{i}\\,\\}$。那么\n$$\n\\sum_{s\\in S'} s \\;=\\; \\sum_{i=1}^{n} x_{i} \\;=\\; T' \\;=\\; T,\n$$\n所以原始的 SUBSET-SUM 实例是一个“是”实例。\n\n因此，对于每个实例 $(S,T)$，实例 $(\\mathcal{L},T')$ 满足\n$$\n(S,T)\\in \\text{SUBSET-SUM} \\;\\;\\Longleftrightarrow\\;\\; (\\mathcal{L},T')\\in \\text{MCSS}.\n$$\n这建立了一个有效的多项式时间多一归约 $\\text{SUBSET-SUM} \\leq_{p} \\text{MCSS}$。由于 SUBSET-SUM 是 NP-hard 的，所以 MCSS 也是 NP-hard 的。\n\n这直接支持选项 A。选项 B 是错误的，因为该归约证明了双向的等价性。选项 C 是错误的，因为该构造显然是多项式时间的。选项 D 是错误的，因为证明 MCSS 的 NP-hard 性的正确方向是将一个已知的 NP-hard 问题归约到 MCSS，而不是反过来。选项 E 是错误的，因为要求从每个列表中做出选择与 SUBSET-SUM 是一致的，这是通过在每个列表中包含 0 来实现的，它模拟了从子集中排除一个元素的选择。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "为了进一步拓宽视野，我们将探索规约如何连接看似无关的领域。这个练习  就是一个绝佳的例子，它将一个图论中的问题（顶点覆盖）转化为一个关于二进制矩阵的问题（列覆盖）。这展示了计算机科学中抽象的强大力量，揭示了不同问题背后可能存在的相同底层结构，掌握这种能力对于在新的问题场景中识别计算难度至关重要。",
            "id": "1436236",
            "problem": "在计算复杂性理论中，我们使用多项式时间归约来确定问题的相对难度。如果问题 $P_1$ 的任何实例都可以在多项式时间内转换为问题 $P_2$ 的一个实例，并且 $P_2$ 实例的解可以用来解决原始的 $P_1$ 实例，那么问题 $P_1$ 可归约到问题 $P_2$。\n\n考虑以下两个判定问题：\n\n1.  **顶点覆盖 (VERTEX-COVER)**：给定一个无向图 $G=(V, E)$（其中 $V$ 是顶点集，$E$ 是边集）和一个正整数 $k$，是否存在一个顶点子集 $V' \\subseteq V$，其大小 $|V'| \\le k$，使得对于每条边 $(u, v) \\in E$，顶点 $u$ 或 $v$ 中至少有一个在 $V'$ 中？这样的集合 $V'$ 被称为顶点覆盖。\n\n2.  **列覆盖 (COLUMN-COVER)**：给定一个 $m \\times n$ 的二进制矩阵 $M$（只包含0和1）和一个正整数 $k'$，是否存在一个列索引集合 $C'$，其大小 $|C'| \\le k'$，使得 $M$ 中的每一行在 $C'$ 指定的列中至少有一个'1'？\n\n你的任务是确定一个正确的​​多项式时间归约，该归约将 VERTEX-COVER 的任意实例 $(G=(V, E), k)$ 转换为 COLUMN-COVER 的实例 $(M, k')$。设 $|V| = n$ 且 $|E| = m$。顶点索引为 $v_1, \\dots, v_n$，边索引为 $e_1, \\dots, e_m$。\n\n以下哪项描述了正确的转换？\n\nA. 构建一个与图 $G$ 的邻接矩阵相对应的 $n \\times n$ 矩阵 $M$，其中如果顶点 $v_i$ 和顶点 $v_j$ 之间有边，则 $M_{ij}=1$，否则 $M_{ij}=0$。将 COLUMN-COVER 的目标整数设置为 $k'=k$。\n\nB. 构建一个 $m \\times n$ 的矩阵 $M$。对于每条边 $e_i = (v_a, v_b)$，设置矩阵元素 $M_{ia}=1$ 和 $M_{ib}=1$。矩阵中所有其他元素均为0。将 COLUMN-COVER 的目标整数设置为 $k'=n-k$。\n\nC. 构建一个 $n \\times m$ 的矩阵 $M$。对于每条边 $e_j = (v_a, v_b)$，设置矩阵元素 $M_{aj}=1$ 和 $M_{bj}=1$。矩阵中所有其他元素均为0。将 COLUMN-COVER 的目标整数设置为 $k'=k$。\n\nD. 构建一个 $m \\times n$ 的矩阵 $M$。对于每条边 $e_i = (v_a, v_b)$，设置矩阵元素 $M_{ia}=1$ 和 $M_{ib}=1$。矩阵中所有其他元素均为0。将 COLUMN-COVER 的目标整数设置为 $k'=k$。",
            "solution": "目标是找到一个从 VERTEX-COVER 实例 $(G=(V,E), k)$ 到 COLUMN-COVER 实例 $(M, k')$ 的映射，使得 VERTEX-COVER 实例的答案为“是”当且仅当 COLUMN-COVER 实例的答案为“是”。让我们分析一下提出的几种转换方法。\n\n正确的转换由选项D给出。让我们描述这个构造并证明其正确性。\n\n**构造（如选项D所示）：**\n给定 VERTEX-COVER 实例 $(G=(V,E), k)$，其中 $|V|=n$ 且 $|E|=m$。我们如下构造 COLUMN-COVER 实例 $(M, k')$：\n1.  创建一个 $m \\times n$ 的矩阵 $M$。该矩阵的行对应于 $G$ 的边，列对应于 $G$ 的顶点。\n2.  对于矩阵的每个元素 $M_{ij}$（第 $i$ 行，第 $j$ 列），如果边 $e_i$ 与顶点 $v_j$ 关联，则设置 $M_{ij} = 1$。否则，设置 $M_{ij} = 0$。在一个无向图中，一条边 $e_i = (v_a, v_b)$ 与两个顶点 $v_a$ 和 $v_b$ 关联。因此，对于对应于边 $e_i$ 的每一行 $i$，恰好有两列的值为'1'。\n3.  将 COLUMN-COVER 问题的整数设置为 $k' = k$。\n\n这个构造可以在多项式时间内完成。创建一个 $m \\times n$ 的矩阵并遍历所有 $m$ 条边来为每条边设置两个条目需要 $O(m \\cdot n)$ 的时间，这在图表示的大小上是多项式的。\n\n**正确性证明：**\n我们必须证明，$G$ 有一个大小至多为 $k$ 的顶点覆盖，当且仅当 $M$ 有一个大小至多为 $k$ 的列覆盖。\n\n**第一部分：(VERTEX-COVER $\\implies$ COLUMN-COVER)**\n假设在 $G$ 中存在一个顶点覆盖 $V' \\subseteq V$，使得 $|V'| \\le k$。我们需要证明，对于矩阵 $M$ 存在一个列覆盖 $C'$，其大小 $|C'| \\le k$。\n\n让我们通过选取与 $V'$ 中顶点对应的列的索引来构造列集合 $C'$。形式上，$C' = \\{j \\mid v_j \\in V'\\}$。根据这个构造，有 $|C'| = |V'| \\le k$。\n\n现在我们必须证明 $C'$ 是一个有效的列覆盖。考虑矩阵 $M$ 中的任意一行 $i$。该行对应于 $G$ 中的一条边 $e_i = (v_a, v_b)$。由于 $V'$ 是一个顶点覆盖，根据定义，它必须包含 $e_i$ 的至少一个端点。也就是说，$v_a \\in V'$ 或 $v_b \\in V'$（或两者都在）。\n\n- 如果 $v_a \\in V'$，那么列索引 $a$ 就在 $C'$ 中。根据我们对 $M$ 的构造，$M_{ia}$ 的值为1。因此，行 $i$ 被列 $a \\in C'$ “覆盖”。\n- 如果 $v_b \\in V'$，那么列索引 $b$ 就在 $C'$ 中。根据我们对 $M$ 的构造，$M_{ib}$ 的值为1。因此，行 $i$ 被列 $b \\in C'$ “覆盖”。\n\n由于每条边都被 $V'$ 覆盖，所以 $M$ 中的每一行都在与 $V'$ 中某个顶点对应的列中有一个'1'。因此，$C'$ 是 $M$ 的一个大小至多为 $k$ 的有效列覆盖。\n\n**第二部分：(COLUMN-COVER $\\implies$ VERTEX-COVER)**\n假设对于 $M$ 存在一个列覆盖 $C'$，使得 $|C'| \\le k$。我们需要证明，对于 $G$ 存在一个顶点覆盖 $V'$，其大小 $|V'| \\le k$。\n\n让我们通过选取与 $C'$ 中列索引对应的顶点来构造顶点集合 $V'$。形式上，$V' = \\{v_j \\mid j \\in C'\\}$。根据这个构造，有 $|V'| = |C'| \\le k$。\n\n现在我们必须证明 $V'$ 是一个有效的顶点覆盖。考虑 $G$ 中的任意一条边 $e_i = (v_a, v_b)$。这条边对应于矩阵 $M$ 的第 $i$ 行。由于 $C'$ 是一个列覆盖，第 $i$ 行必须在索引属于 $C'$ 的某一列中至少有一个'1'。设这一列为 $j \\in C'$。\n\n所以，对于某个 $j \\in C'$，有 $M_{ij}=1$。根据我们对 $M$ 的构造，$M_{ij}=1$ 意味着边 $e_i$ 与顶点 $v_j$ 关联。根据我们对 $V'$ 的构造，由于 $j \\in C'$，顶点 $v_j$ 在 $V'$ 中。因此，边 $e_i$ 被顶点 $v_j \\in V'$ 覆盖。\n\n由于这对 $E$ 中的任何边都成立，所以集合 $V'$ 是 $G$ 的一个大小至多为 $k$ 的有效顶点覆盖。\n\n**错误选项分析：**\n\n- **选项 A：** 使用 $G$ 的邻接矩阵会将 VERTEX-COVER 映射到另一个不同的问题。在邻接矩阵中，行 $i$ 在列 $j$ 处为1，表示存在边 $(v_i, v_j)$。选择一个大小为 $k$ 的列集合来覆盖所有行，对应于找到一个大小为 $k$ 的顶点集合，使得图中的每个顶点都与该集合中的至少一个顶点相邻。这是支配集 (DOMINATING-SET) 问题的定义，而不是顶点覆盖 (VERTEX-COVER)。\n\n- **选项 B：** 这使用了正确的矩阵构造，但将预算设置为 $k' = n-k$。这是一种通常在将问题归约到其补问题（如将 CLIQUE 归约到 INDEPENDENT-SET）时使用的转换。它在这里不适用，并会导致错误的结果。例如，一个只有一条边的图需要大小为 $k=1$ 的顶点覆盖，但这将被映射到大小为 $n-1$ 的列覆盖，这通常是不等价的。\n\n- **选项 C：** 这颠倒了顶点和边的角色。矩阵是 $n \\times m$ 的，意味着它的行代表顶点，列代表边。选择 $k'$ 列意味着选择边。这种结构不能直接地映射到 VERTEX-COVER 问题。它是正确构造的转置，选择 $k'$ 列（边）来覆盖所有行（顶点）意味着找到一个与每个顶点都关联的边集，这是另一个不同的图问题。",
            "answer": "$$\\boxed{D}$$"
        }
    ]
}