{
    "hands_on_practices": [
        {
            "introduction": "在优化问题中，许多复杂函数可以通过更简单的函数构建而成，其中逐点取最大值是一种常见操作。本练习将探讨一个由二次函数和绝对值函数构成的最大值函数，通过分析其上镜图来加深理解。我们将看到，该函数的上镜图可以被看作是其组分函数上镜图的交集，这种几何视角有助于我们定位函数的不可微点（“扭结”点），并最终找到其最小值。",
            "id": "3125707",
            "problem": "考虑函数 $f:\\mathbb{R}\\to\\mathbb{R}$，其定义为 $f(x)=\\max\\{x^{2},2|x|\\}$。从优化方法的基本定义出发，包括函数上镜图的定义 $\\operatorname{epi} f=\\{(x,t)\\in\\mathbb{R}^{2}\\mid t\\ge f(x)\\}$ 以及函数逐点最大值的定义。利用这些定义，首先将 $\\operatorname{epi} f$ 表示为两个更简单函数的上镜图的交集。然后，通过分析最大值的激活分支，确定所有 $f$ 不可微的点，并解释这些点是如何由于某个分量函数的不可微性或激活分支的切换而产生的。最后，考虑无约束最小化问题 $\\min_{x\\in\\mathbb{R}} f(x)$，并讨论哪些扭折点（kink points）与最优点相关。\n\n你的任务：\n1. 明确地将 $\\operatorname{epi} f$ 推导为两个更简单函数的上镜图的交集，并用集合构建形式写出这个交集。\n2. 找出 $f$ 的所有扭折点（不可微点），并从第一性原理证明你的结论。\n3. 通过讨论 $f$ 在这些点邻域内的行为，说明哪个（些）扭折点与 $f(x)$ 的无约束最小化相关。\n\n答案规格：\n- 提供一个简洁、准确的最终答案，包含扭折点的 $x$ 坐标，按升序排列，并写成单行矩阵的形式。",
            "solution": "该问题是良态的，并且在实分析和优化理论中有坚实的科学基础。所有术语都是标准的且定义明确，问题是自洽的。因此，可以推导出解答。\n\n我们考虑的函数是 $f:\\mathbb{R}\\to\\mathbb{R}$，定义为 $f(x)=\\max\\{x^{2},2|x|\\}$。我们可以将其分解为两个更简单的函数，$f_1(x) = x^2$ 和 $f_2(x) = 2|x|$，使得 $f(x) = \\max\\{f_1(x), f_2(x)\\}$。\n\n**1. 作为交集的上镜图**\n\n根据定义，函数 $g$ 的上镜图是集合 $\\operatorname{epi} g = \\{(x,t) \\mid t \\ge g(x)\\}$。对于函数 $f(x)$，其上镜图是：\n$$ \\operatorname{epi} f = \\{(x,t) \\in \\mathbb{R}^{2} \\mid t \\ge f(x)\\} $$\n代入 $f(x)$ 的定义，我们得到：\n$$ \\operatorname{epi} f = \\{(x,t) \\in \\mathbb{R}^{2} \\mid t \\ge \\max\\{x^{2}, 2|x|\\}\\} $$\n不等式 $t \\ge \\max\\{a,b\\}$ 成立当且仅当 $t \\ge a$ 和 $t \\ge b$。应用此原理，$(x,t)$ 属于 $\\operatorname{epi} f$ 的条件等价于以下两个不等式组成的系统：\n$$ t \\ge x^{2} \\quad \\text{和} \\quad t \\ge 2|x| $$\n满足 $t \\ge x^2$ 的点集正是 $f_1(x)=x^2$ 的上镜图，即 $\\operatorname{epi} f_1 = \\{(x,t) \\in \\mathbb{R}^{2} \\mid t \\ge x^2\\}$。\n满足 $t \\ge 2|x|$ 的点集是 $f_2(x)=2|x|$ 的上镜图，即 $\\operatorname{epi} f_2 = \\{(x,t) \\in \\mathbb{R}^{2} \\mid t \\ge 2|x|\\}$。\n因此，$\\operatorname{epi} f$ 是这两个集合的交集：\n$$ \\operatorname{epi} f = \\operatorname{epi} f_1 \\cap \\operatorname{epi} f_2 $$\n用集合构建符号表示，这个交集可以明确地写为：\n$$ \\operatorname{epi} f = \\{(x,t) \\in \\mathbb{R}^{2} \\mid t \\ge x^{2} \\text{ and } t \\ge 2|x|\\} $$\n\n**2. 扭折点（不可微点）**\n\n$f(x) = \\max\\{f_1(x), f_2(x)\\}$ 的不可微点可能出现在某个分量函数不可微的地方，或者在最大值函数的激活分支切换的地方。\n\n首先，我们分析分量函数的可微性。\n-   $f_1(x) = x^2$ 是一个多项式，在 $\\mathbb{R}$ 上处处可微。其导数为 $f_1'(x) = 2x$。\n-   $f_2(x) = 2|x|$ 在 $x=0$ 处不可微。其左导数为 $\\lim_{h\\to 0^-}\\frac{2|h|-0}{h} = \\lim_{h\\to 0^-}\\frac{-2h}{h} = -2$，右导数为 $\\lim_{h\\to 0^+}\\frac{2|h|-0}{h} = \\lim_{h\\to 0^+}\\frac{2h}{h} = 2$。\n\n激活分支可能切换的点可以通过求解 $f_1(x) = f_2(x)$ 找到：\n$$ x^2 = 2|x| $$\n因为 $x^2 = |x|^2$，方程变为 $|x|^2 - 2|x| = 0$，可因式分解为 $|x|(|x|-2)=0$。解为 $|x|=0$ (即 $x=0$) 和 $|x|=2$ (即 $x=2$ 和 $x=-2$)。\n因此，潜在的扭折点集合为 $\\{-2, 0, 2\\}$。\n\n为了分析在这些点的可微性，我们首先通过确定在这些点定义的区间内哪个函数更大，来将 $f(x)$ 表示为分段形式。\n-   对于 $|x|  2$，我们有 $|x|-2  0$。两边乘以 $|x| \\ge 0$ 得到 $|x|^2 - 2|x| \\le 0$，所以 $x^2 \\le 2|x|$。因此，对于 $x \\in (-2,2)$，$f(x)=2|x|$。\n-   对于 $|x| \\ge 2$，我们有 $|x|-2 \\ge 0$。两边乘以 $|x| > 0$（当$|x|>2$时）或考虑$x=\\pm2$的情况，得到 $|x|^2 - 2|x| \\ge 0$，所以 $x^2 \\ge 2|x|$。因此，对于 $|x| \\ge 2$，$f(x)=x^2$。\n\n这给出了分段定义：\n$$ f(x) = \\begin{cases} x^2,  \\text{if } x \\le -2 \\\\ -2x,  \\text{if } -2  x  0 \\\\ 2x,  \\text{if } 0 \\le x  2 \\\\ x^2,  \\text{if } x \\ge 2 \\end{cases} $$\n现在我们检查每个潜在扭折点的单侧导数：\n-   在 $x=-2$ 处：\n    -   左导数： $\\lim_{x \\to -2^-} f'(x) = \\lim_{x \\to -2^-} (x^2)' = \\lim_{x \\to -2^-} 2x = 2(-2) = -4$。\n    -   右导数： $\\lim_{x \\to -2^+} f'(x) = \\lim_{x \\to -2^+} (-2x)' = -2$。\n    因为 $-4 \\neq -2$，所以 $f$ 在 $x=-2$ 处不可微。\n\n-   在 $x=0$ 处：\n    -   左导数： $\\lim_{x \\to 0^-} f'(x) = \\lim_{x \\to 0^-} (-2x)' = -2$。\n    -   右导数： $\\lim_{x \\to 0^+} f'(x) = \\lim_{x \\to 0^+} (2x)' = 2$。\n    因为 $-2 \\neq 2$，所以 $f$ 在 $x=0$ 处不可微。这是预料之中的，因为在 $x=0$ 的一个邻域内 $f(x) = 2|x|$。\n\n-   在 $x=2$ 处：\n    -   左导数： $\\lim_{x \\to 2^-} f'(x) = \\lim_{x \\to 2^-} (2x)' = 2$。\n    -   右导数： $\\lim_{x \\to 2^+} f'(x) = \\lim_{x \\to 2^+} (x^2)' = \\lim_{x \\to 2^+} 2x = 2(2) = 4$。\n    因为 $2 \\neq 4$，所以 $f$ 在 $x=2$ 处不可微。\n\n$f$ 不可微的所有点的集合是 $\\{-2, 0, 2\\}$。\n\n**3. 扭折点与最小化的相关性**\n\n我们必须解决无约束最小化问题 $\\min_{x\\in\\mathbb{R}} f(x)$。\n函数是 $f(x) = \\max\\{x^2, 2|x|\\}$。由于对所有 $x \\in \\mathbb{R}$ 都有 $x^2 \\ge 0$ 和 $2|x| \\ge 0$，它们的最大值 $f(x)$ 也必须是非负的，即 $f(x) \\ge 0$。\n当且仅当 $x^2=0$ 和 $2|x|=0$ 同时成立时，$f(x)=0$ 才能实现，这唯一地发生在 $x=0$ 处。\n在该点，$f(0) = \\max\\{0^2, 2|0|\\} = 0$。\n由于对所有 $x$ 都有 $f(x) \\ge 0$ 且 $f(0)=0$，所以 $f$ 的全局最小值为 0，在最优点 $x^*=0$ 处取得。\n\n最优点 $x^*=0$ 是扭折点之一。因此，这个扭折点是最小化问题的核心，因为它是解的位置。\n对于像 $f$ 这样的凸函数（作为凸函数的逐点最大值），全局最小值出现在次梯度包含零的点 $x^*$，即 $0 \\in \\partial f(x^*)$。\n-   在 $x=0$ 处，次梯度是由左右导数定义的区间，$\\partial f(0) = [-2, 2]$。因为 $0 \\in [-2, 2]$，所以 $x=0$ 是一个极小点。\n-   在 $x=2$ 处，次梯度是 $\\partial f(2) = [2, 4]$。因为 $0 \\notin [2, 4]$，所以 $x=2$ 不是一个极小点。\n-   在 $x=-2$ 处，次梯度是 $\\partial f(-2) = [-4, -2]$。因为 $0 \\notin [-4, -2]$，所以 $x=-2$ 不是一个极小点。\n\n因此，唯一对应于最优点的扭折点是 $x=0$。扭折点的分析至关重要，因为最小值不是出现在驻点（导数为零的点），而是出现在一个不可微点。\n\n最终答案要求给出所有扭折点的集合。这些点是 $x=-2$，$x=0$ 和 $x=2$。",
            "answer": "$$ \\boxed{\\begin{pmatrix} -2  0  2 \\end{pmatrix}} $$"
        },
        {
            "introduction": "高效求解优化问题的关键在于识别并利用问题中的特殊结构。本练习将演示一种核心技巧：如何将“二次-线性”函数（quadratic-over-linear function）的上镜图约束重新表述为一个标准的几何对象——旋转二阶锥（Rotated Second-Order Cone, RSOC）。这一转化在现代凸优化中至关重要，因为它使得许多非线性问题可以被高效的锥规划求解器处理。",
            "id": "3125693",
            "problem": "设二次-线性函数 $q:\\mathbb{R}^{n}\\times(0,\\infty)\\to\\mathbb{R}$ 定义为 $q(x,\\tau)=\\|x\\|_{2}^{2}/\\tau$，其中 $x\\in\\mathbb{R}^{n}$ 且 $\\tau0$。$q$ 的上镜图是集合 $\\mathrm{epi}(q)=\\{(x,\\tau,t)\\in\\mathbb{R}^{n}\\times(0,\\infty)\\times\\mathbb{R}:\\ t\\geq q(x,\\tau)\\}$。二阶锥 (SOC) 是集合 $\\mathcal{Q}=\\{(y,z)\\in\\mathbb{R}^{n}\\times\\mathbb{R}:\\ \\|y\\|_{2}\\leq z\\}$。旋转二阶锥 (RSOC) 是集合 $\\mathcal{Q}_{r}=\\{(u,v,w)\\in\\mathbb{R}\\times\\mathbb{R}\\times\\mathbb{R}^{n}:\\ u\\geq 0,\\ v\\geq 0,\\ 2uv\\geq\\|w\\|_{2}^{2}\\}$。\n\n仅从这些核心定义出发，通过将 $(x,\\tau,t)$ 适当地线性嵌入到 $\\mathcal{Q}_{r}$ 中，推导上镜图 $\\mathrm{epi}(q)$ 的等价旋转二阶锥表示。然后，对于具体数据 $x=(3,-4,12)\\in\\mathbb{R}^{3}$ 和 $\\tau=7.5$，计算位于所推导的上镜图表示中的 $t$ 的最小值。将最终数值答案四舍五入到四位有效数字。",
            "solution": "用户想让我解决一个问题。\n\n**问题验证**\n\n**步骤 1：提取已知信息**\n-   二次-线性函数定义为 $q:\\mathbb{R}^{n}\\times(0,\\infty)\\to\\mathbb{R}$，其中 $q(x,\\tau)=\\|x\\|_{2}^{2}/\\tau$，$x\\in\\mathbb{R}^{n}$ 且 $\\tau0$。\n-   $q$ 的上镜图是集合 $\\mathrm{epi}(q)=\\{(x,\\tau,t)\\in\\mathbb{R}^{n}\\times(0,\\infty)\\times\\mathbb{R}:\\ t\\geq q(x,\\tau)\\}$。\n-   二阶锥 (SOC) 是集合 $\\mathcal{Q}=\\{(y,z)\\in\\mathbb{R}^{n}\\times\\mathbb{R}:\\ \\|y\\|_{2}\\leq z\\}$。\n-   旋转二阶锥 (RSOC) 是集合 $\\mathcal{Q}_{r}=\\{(u,v,w)\\in\\mathbb{R}\\times\\mathbb{R}\\times\\mathbb{R}^{n}:\\ u\\geq 0,\\ v\\geq 0,\\ 2uv\\geq\\|w\\|_{2}^{2}\\}$。\n-   任务是为 $\\mathrm{epi}(q)$ 推导一个等价的 RSOC 表示，然后用它来计算特定数据 $x=(3,-4,12)\\in\\mathbb{R}^{3}$ 和 $\\tau=7.5$ 的 $t$ 的最小值。\n-   最终数值答案必须四舍五入到四位有效数字。\n\n**步骤 2：使用提取的已知信息进行验证**\n-   **科学依据：** 该问题基于凸优化的标准、公认定义，特别是关于二次-线性函数、其上镜图以及与旋转二阶锥的关系。这些概念是该领域的基础。\n-   **适定性：** 问题陈述清晰。它要求进行标准推导，然后进行计算。上镜图的结构保证了 $t$ 最小值的存在性和唯一性。\n-   **客观性：** 问题以精确的数学语言表述，没有歧义或主观内容。\n\n该问题没有任何无效性缺陷。它在数学上和科学上都是合理的、完整的和适定的。包含 SOC 的定义是多余的，但不会造成冲突或歧义。\n\n**步骤 3：结论与行动**\n问题有效。将提供解答。\n\n**旋转二阶锥表示的推导**\n\n函数 $q(x,\\tau) = \\|x\\|_2^2/\\tau$ 的上镜图由满足以下不等式的点集 $(x,\\tau,t)$ 定义：\n$$t \\geq \\frac{\\|x\\|_2^2}{\\tau}$$\n函数的定义域指定 $\\tau  0$。由于 $\\tau$ 是严格为正的，我们可以在不等式两边同乘以 $\\tau$ 而不改变其方向：\n$$\\tau t \\geq \\|x\\|_2^2$$\n此外，对于上镜图中的任何点，由于 $\\|x\\|_2^2 \\ge 0$ 且 $\\tau  0$，因此 $t \\ge \\|x\\|_2^2/\\tau \\ge 0$，所以 $t$ 总是非负的。\n\n旋转二阶锥 (RSOC) $\\mathcal{Q}_r$ 由满足三个条件的点集 $(u,v,w)$ 定义：\n1. $u \\ge 0$\n2. $v \\ge 0$\n3. $2uv \\ge \\|w\\|_2^2$\n\n我们寻求一个线性嵌入，将变量 $(x, \\tau, t)$ 映射到 $(u, v, w)$，使得条件 $(x, \\tau, t) \\in \\mathrm{epi}(q)$ 等价于 $(u, v, w) \\in \\mathcal{Q}_r$。\n\n让我们比较核心不等式：\n-   上镜图：$\\tau t \\geq \\|x\\|_2^2$\n-   RSOC: $2uv \\geq \\|w\\|_2^2$\n\n直接比较表明，可将 $\\|w\\|_2^2$ 与 $\\|x\\|_2^2$ 等同。实现这一点的最简单线性映射是 $w=x$。\n这给我们留下的任务是将 $2uv$ 与 $\\tau t$ 关联起来。我们需要将 $u$ 和 $v$ 定义为 $\\tau$ 和 $t$ 的线性函数，使得 $2uv = \\tau t$。\n\n一个合适的线性映射是：\n-   $u = \\frac{\\tau}{2}$\n-   $v = t$\n-   $w = x$\n\n让我们验证这个映射对于定义域 $\\tau  0$ 建立了所需的等价关系。\n\n首先，假设 $(x, \\tau, t) \\in \\mathrm{epi}(q)$。这意味着 $\\tau  0$ 且 $t \\ge \\|x\\|_2^2/\\tau$。\n我们检查对应的点 $(u,v,w) = (\\tau/2, t, x)$ 是否在 $\\mathcal{Q}_r$ 中。\n1. $u = \\tau/2$。由于 $\\tau  0$，我们有 $u  0$，这满足 $u \\ge 0$。\n2. $v = t$。由于 $t \\ge \\|x\\|_2^2/\\tau \\ge 0$，我们有 $v \\ge 0$。\n3. 不等式 $\\tau t \\ge \\|x\\|_2^2$ 是直接给出的。我们可以将其重写为 $2(\\tau/2)t \\ge \\|x\\|_2^2$。代入我们对 $u, v, w$ 的定义，这变为 $2uv \\ge \\|w\\|_2^2$。\n因此，如果 $(x, \\tau, t) \\in \\mathrm{epi}(q)$，那么 $(\\tau/2, t, x) \\in \\mathcal{Q}_r$。\n\n其次，假设 $(\\tau/2, t, x) \\in \\mathcal{Q}_r$ 且 $\\tau  0$。属于 $\\mathcal{Q}_r$ 的条件是 $u = \\tau/2 \\ge 0$，$v = t \\ge 0$，以及 $2uv = 2(\\tau/2)t = \\tau t \\ge \\|x\\|_2^2$。\n条件 $\\tau  0$ 由 $q$ 的定义域给出。由于 $\\tau  0$，我们可以将不等式 $\\tau t \\ge \\|x\\|_2^2$ 两边除以 $\\tau$，得到 $t \\ge \\|x\\|_2^2/\\tau$。\n这正是 $(x, \\tau, t)$ 属于 $q$ 的上镜图的定义。\n\n因此，条件 $(x, \\tau, t) \\in \\mathrm{epi}(q)$ 等价于线性变换后的点 $(\\tau/2, t, x)$ 属于旋转二阶锥 $\\mathcal{Q}_r$ 的条件。\n\n**针对特定数据的计算**\n\n我们被给予特定数据 $x = (3, -4, 12) \\in \\mathbb{R}^3$ 和 $\\tau = 7.5$。我们需要找到使点 $(x, \\tau, t)$ 位于上镜图中的 $t$ 的最小值。\n$t$ 的最小值，我们称之为 $t_{\\min}$，出现在点位于上镜图边界上时，即当不等式变为等式时：\n$$t_{\\min} = \\frac{\\|x\\|_2^2}{\\tau}$$\n\n首先，我们计算 $x$ 的欧几里得范数的平方：\n$$\\|x\\|_2^2 = 3^2 + (-4)^2 + 12^2 = 9 + 16 + 144 = 169$$\n\n接下来，我们将这个值和给定的 $\\tau$ 值代入 $t_{\\min}$ 的表达式中：\n$$\\tau = 7.5 = \\frac{15}{2}$$\n$$t_{\\min} = \\frac{169}{7.5} = \\frac{169}{15/2} = \\frac{169 \\times 2}{15} = \\frac{338}{15}$$\n\n为了获得数值，我们进行除法运算：\n$$t_{\\min} = \\frac{338}{15} = 22.53333...$$\n\n问题要求答案四舍五入到四位有效数字。前四位有效数字是 $2$、$2$、$5$ 和 $3$。第五位有效数字是 $3$。由于 $3  5$，我们向下舍入。\n将 $t$ 的最小值四舍五入到四位有效数字是 $22.53$。\n这个计算与使用推导出的 RSOC 表示是一致的。最小的 $t$ 对应于锥的边界 $2uv = \\|w\\|_2^2$，这给出 $2(\\tau/2) t = \\|x\\|_2^2$，即 $\\tau t = \\|x\\|_2^2$，从而得到相同的结果。",
            "answer": "$$\\boxed{22.53}$$"
        },
        {
            "introduction": "上镜图的概念不仅用于理论分析，更是构建强大优化算法的基石。本练习将带领你亲手实现经典的切平面法（Kelley's method），该算法的核心思想便是利用次梯度生成一系列线性“切片”来逐步构造目标函数上镜图的多面体近似。通过将一个复杂的凸优化问题转化为一系列易于求解的线性规划问题，本练习将展示理论概念如何直接转化为实用的计算工具。",
            "id": "3125647",
            "problem": "要求您从基本原理出发，实现一种基于上境图的切平面算法，用于计算凸函数的分段线性下界模型，并使用这些模型在紧凸集上近似求解其最小值。该方法应构造一系列到上境图的支撑超平面，从而得到最优值的单调非递减下界。该算法必须仅依赖于以下核心定义和事实：\n1) 函数的上境图：对于函数 $f : \\mathbb{R}^n \\to \\mathbb{R}$，其上境图为 $\\operatorname{epi}(f) = \\{(x,t) \\in \\mathbb{R}^{n+1} : t \\ge f(x)\\}$。\n2) 凸性与次梯度不等式：如果 $f$ 是凸函数，则对于定义域 $\\operatorname{dom}(f)$ 中的任意点 $x$ 和任意次梯度 $g \\in \\partial f(x)$，不等式 $f(y) \\ge f(x) + g^\\top (y - x)$ 对定义域中所有的 $y$ 都成立。这意味着每个 $(x,g)$ 对都为 $\\operatorname{epi}(f)$ 定义了一个有效的支撑半空间 $t \\ge g^\\top y + \\left(f(x) - g^\\top x\\right)$。\n3) 在半空间的交集和箱式约束下最小化线性目标是一个线性规划问题。\n\n实现以下算法任务：\n- 给定一个凸函数 $f$、一个在任意查询点 $x$ 计算一个次梯度 $g \\in \\partial f(x)$ 的程序，以及一个由给定向量 $\\ell, u \\in \\mathbb{R}^n$ 定义的箱式定义域 $\\mathcal{X} = \\{x \\in \\mathbb{R}^n : \\ell \\le x \\le u \\}$，构建一个迭代切平面方法（通常称为Kelley方法）来最小化辅助的上境图变量 $t$，其约束条件为所有累积的切平面：\n  - 在箱式区域中心点 $x^{(0)} = \\frac{1}{2}(\\ell + u)$ 处以单个切平面进行初始化。计算 $f(x^{(0)})$ 和一个次梯度 $g^{(0)} \\in \\partial f(x^{(0)})$。形成仿射下界函数 $\\phi_0(y) = g^{(0)\\top} y + \\big(f(x^{(0)}) - g^{(0)\\top} x^{(0)}\\big)$。\n  - 在第 $k \\in \\{1,2,\\dots\\}$ 次迭代时，求解以下线性规划问题：\n    最小化 $t$，约束条件为 $t \\ge \\phi_i(x)$ 对所有 $i \\in \\{0,\\dots,k-1\\}$ 成立，且 $\\ell \\le x \\le u$。\n    令最优点为 $(x^{(k)}_{\\text{LP}}, t^{(k)}_{\\text{LP}})$。评估 $f\\big(x^{(k)}_{\\text{LP}}\\big)$ 并计算一个次梯度 $g^{(k)} \\in \\partial f\\big(x^{(k)}_{\\text{LP}}\\big)$。添加新的切平面 $\\phi_k(y) = g^{(k)\\top} y + \\big(f(x^{(k)}_{\\text{LP}}) - g^{(k)\\top} x^{(k)}_{\\text{LP}}\\big)$。维护现任上界 $U^{(k)} = \\min\\{U^{(k-1)}, f(x^{(k)}_{\\text{LP}})\\}$ 并定义下界 $L^{(k)} = t^{(k)}_{\\text{LP}}$。\n  - 使用间隙停止准则：如果 $U^{(k)} - L^{(k)} \\le \\varepsilon$，则终止并返回 $(L^{(k)}, U^{(k)}, U^{(k)} - L^{(k)})$ 以及迭代次数和一个收敛标志。否则继续迭代，直到达到最大迭代次数 $K_{\\max}$。\n\n您的程序必须使用一个线性规划求解器来解决子问题，并实现此方法。上境图模型必须按照所述，由累积的切平面显式构建。\n\n测试套件：\n为以下四个测试用例实现上述算法，每个用例都有其自己的函数、次梯度法则和定义域。\n1) 对称区间上的不可微单变量凸函数：\n   - 维度 $n = 1$。\n   - 定义域边界 $\\ell = [-3]$， $u = [3]$。\n   - 函数 $f(x) = |x_1| + \\tfrac{1}{2} x_1$，其中 $x = (x_1)$。\n   - 次梯度法则：如果 $x_1  0$，使用 $g = [\\tfrac{3}{2}]$；如果 $x_1  0$，使用 $g = [-\\tfrac{1}{2}]$；如果 $x_1 = 0$，使用 $g = [0]$。\n2) 箱式区域上的光滑强凸二次函数：\n   - 维度 $n = 2$。\n   - 定义域边界 $\\ell = [-2,-2]$， $u = [2,2]$。\n   - 函数 $f(x) = x_1^2 + x_2^2 - 2 x_1 + x_2$。\n   - 梯度（也是一个次梯度）：$g(x) = [2 x_1 - 2,\\; 2 x_2 + 1]$。\n3) 箱式区域上的凸分段线性函数（仿射函数族的最大值）：\n   - 维度 $n = 2$。\n   - 定义域边界 $\\ell = [-2,-2]$， $u = [2,2]$。\n   - 函数 $f(x) = \\max\\{ \\langle [1,-1], x \\rangle + 0,\\; \\langle [-2,1], x \\rangle + 1,\\; \\langle [\\tfrac{1}{2}, \\tfrac{1}{2}], x \\rangle - 1 \\}$。\n   - 次梯度法则：选择任意一个最大化函数的系数向量作为次梯度；为确保确定性，如果多个仿射函数值相等，则选择索引最小的那个。\n4) 箱式区域上的光滑凸log-sum-exp函数：\n   - 维度 $n = 2$。\n   - 定义域边界 $\\ell = [-2,-2]$， $u = [2,2]$。\n   - 函数 $f(x) = \\log\\left(\\exp(x_1) + \\exp(x_2)\\right)$。\n   - 梯度（一个次梯度）：$g(x) = \\left[\\dfrac{\\exp(x_1)}{\\exp(x_1) + \\exp(x_2)},\\; \\dfrac{\\exp(x_2)}{\\exp(x_1) + \\exp(x_2)}\\right]$。\n\n算法参数和输出：\n- 所有测试均使用容差 $\\varepsilon = 10^{-5}$ 和最大迭代次数 $K_{\\max} = 100$。\n- 在箱式区域中心点 $x^{(0)} = \\tfrac{1}{2}(\\ell + u)$ 处初始化第一个切平面。\n- 对每个测试用例，返回一个形式为 $[L, U, G, K, C]$ 的列表，其中 $L$ 是最终下界， $U$ 是最终上界（找到的最佳函数值）， $G = U - L$ 是最终最优性间隙， $K$ 是执行的迭代次数（整数）， $C$ 是一个布尔值，表示终止时是否有 $G \\le \\varepsilon$。为保证数值再现性，在输出前将 $L$、 $U$ 和 $G$ 四舍五入到6位小数。\n- 您的程序应产生单行输出，其中包含一个由逗号分隔、无空格、并用方括号括起来的结果列表，即形式为 $[[L_1,U_1,G_1,K_1,C_1],[L_2,U_2,G_2,K_2,C_2],[L_3,U_3,G_3,K_3,C_3],[L_4,U_4,G_4,K_4,C_4]]$。\n\n关于覆盖范围的说明：\n- 这四个测试涵盖了一个在尖点处有极小点的不可微函数、一个有内部极小点的光滑强凸函数、一个上境图为多面体的分段线性凸函数，以及一个极小点位于箱式区域边界上的光滑凸函数。该测试套件检验了切平面生成、线性子问题构建以及基于上境图下界与现任上界之差的停止准则的正确性。",
            "solution": "该问题要求实现Kelley切平面法，用于在紧凑的箱式定义域 $\\mathcal{X} = \\{x \\in \\mathbb{R}^n : \\ell \\le x \\le u \\}$ 上最小化一个凸函数 $f: \\mathbb{R}^n \\to \\mathbb{R}$。该方法基于上镜图公式，并迭代地构建函数的分段线性下界模型。\n\n其核心原理是将原始优化问题 $\\min_{x \\in \\mathcal{X}} f(x)$ 转化为一个涉及函数上镜图的等价问题。$f$ 的上镜图是集合 $\\operatorname{epi}(f) = \\{(x,t) \\in \\mathbb{R}^{n+1} : t \\ge f(x)\\}$。因此，最小化问题等价于在位于定义域 $\\mathcal{X}$ 上方的上镜图部分中找到最低点，可表述为：\n$$\n\\begin{aligned}\n\\text{minimize}  \\quad t \\\\\n\\text{subject to}  \\quad t \\ge f(x) \\\\\n \\quad x \\in \\mathcal{X}\n\\end{aligned}\n$$\n约束 $t \\ge f(x)$ 通常是非线性的，这使得问题难以直接求解。切平面法通过用一组不断演化的线性不等式（即“切平面”）来替换这个单一的非线性约束来解决这个问题。这创建了上镜图的一个多面体外逼近。\n\n对于一个凸函数 $f$，这些切平面的基础是次梯度不等式。在任意点 $x^{(i)} \\in \\operatorname{dom}(f)$，对于任意次梯度 $g^{(i)} \\in \\partial f(x^{(i)})$，我们有以下不等式：\n$$\nf(x) \\ge f(x^{(i)}) + g^{(i)\\top} (x - x^{(i)}) \\quad \\text{for all } x \\in \\operatorname{dom}(f)\n$$\n这个不等式为函数 $f$ 定义了一个全局仿射下估计函数。由于上镜图中的任何点 $(x, t)$ 都必须满足 $t \\ge f(x)$，它也必须满足更弱的线性不等式：\n$$\nt \\ge f(x^{(i)}) + g^{(i)\\top} (x - x^{(i)})\n$$\n这个不等式在边界点 $(x^{(i)}, f(x^{(i)}))$ 处定义了一个对上镜图的支撑半空间。迭代算法过程如下：\n\n1.  **初始化**：算法从一个初始点开始，指定为箱式区域的中心 $x^{(0)} = \\frac{1}{2}(\\ell + u)$。我们评估函数值 $f(x^{(0)})$ 并计算一个次梯度 $g^{(0)} \\in \\partial f(x^{(0)})$。这定义了第一个切平面，$t \\ge f(x^{(0)}) + g^{(0)\\top} (x - x^{(0)})$。最小值的初始最佳上界设置为 $U^{(0)} = f(x^{(0)})$。下界初始化为 $L^{(0)} = -\\infty$。\n\n2.  **迭代求精**：在每次迭代 $k \\in \\{1, 2, \\dots\\}$ 中，我们已经从点 $x^{(0)}, x^{(1)}_{\\text{LP}}, \\dots, x^{(k-1)}_{\\text{LP}}$ 累积了一组切平面。这些切平面定义了一个包含 $f$ 的上镜图的多面体集 $\\mathcal{P}^{(k-1)}$。我们求解以下线性规划（LP）问题，以找到在该多面体逼近与定义域约束的交集上 $t$ 的最小值：\n    $$\n    \\begin{aligned}\n    (x^{(k)}_{\\text{LP}}, t^{(k)}_{\\text{LP}}) = \\quad \\operatorname{argmin}_{x,t}  \\quad t \\\\\n    \\text{subject to}  \\quad t \\ge f(x^{(i)}) + g^{(i)\\top} (x - x^{(i)}), \\quad i=0, \\dots, k-1 \\\\\n     \\quad \\ell \\le x \\le u\n    \\end{aligned}\n    $$\n    此线性规划的目标值 $t^{(k)}_{\\text{LP}}$ 为 $f$ 的真实最小值提供了一个新的下界，因此我们设置 $L^{(k)} = t^{(k)}_{\\text{LP}}$。由于 $\\mathcal{P}^{(k-1)}$ 包含 $\\operatorname{epi}(f)$，$L^{(k)}$ 保证小于或等于真实最小值。随着更多切平面的加入，逼近变得更紧密，下界序列 $\\{L^{(k)}\\}$ 是单调非递减的。\n\n3.  **更新界限并生成新切平面**：LP解的空间分量 $x^{(k)}_{\\text{LP}}$ 是真实最小化点的一个候选。我们在此点评估函数值 $f(x^{(k)}_{\\text{LP}})$，并更新现任（迄今为止最佳的）上界：$U^{(k)} = \\min(U^{(k-1)}, f(x^{(k)}_{\\text{LP}}))$。上界序列 $\\{U^{(k)}\\}$ 是单调非增的。然后，使用次梯度 $g^{(k)} \\in \\partial f(x^{(k)}_{\\text{LP}})$ 在 $x^{(k)}_{\\text{LP}}$ 处生成一个新的切平面。这个新切平面 $t \\ge f(x^{(k)}_{\\text{LP}}) + g^{(k)\\top} (x - x^{(k)}_{\\text{LP}})$ 被添加到集合中用于下一次迭代，从而精化多面体逼近。\n\n4.  **终止**：当上界和下界之间的差距足够小，即 $U^{(k)} - L^{(k)} \\le \\varepsilon$（对于给定的容差 $\\varepsilon$），算法终止。此条件确保现任解 $U^{(k)}$ 是 $\\varepsilon$-最优的。还使用最大迭代次数 $K_{\\max}$ 作为保障措施以确保终止。\n\n该实现使用 `scipy.optimize.linprog` 来解决每次迭代中的LP子问题。LP被构建为具有 $n+1$ 个变量 $(x_1, \\dots, x_n, t)$。目标是最小化 $t$，对应于目标向量 $c = [0, \\dots, 0, 1]^\\top$。每个切平面约束 $t \\ge g^{(i)\\top}x + (f(x^{(i)}) - g^{(i)\\top}x^{(i)})$ 被重写为求解器所需的标准形式 $A_{ub}z \\le b_{ub}$，对于变量向量 $z = [x^\\top, t]^\\top$，这变为 $g^{(i)\\top}x - t \\le g^{(i)\\top}x^{(i)} - f(x^{(i)})$。箱式约束 $\\ell \\le x \\le u$ 直接传递给求解器的 `bounds` 参数。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef cutting_plane_algorithm(f, g_oracle, l, u, eps, K_max):\n    \"\"\"\n    Implements Kelley's cutting-plane method using an epigraph formulation.\n\n    Args:\n        f (callable): The convex objective function.\n        g_oracle (callable): A function providing a subgradient of f.\n        l (np.ndarray): The lower bounds of the box domain.\n        u (np.ndarray): The upper bounds of the box domain.\n        eps (float): The tolerance for the stopping condition (U - L = eps).\n        K_max (int): The maximum number of iterations.\n\n    Returns:\n        list: A list containing [L, U, G, K, C] where L is the final lower bound,\n              U is the final upper bound, G is the optimality gap, K is the number\n              of iterations, and C is the convergence flag.\n    \"\"\"\n    n = len(l)\n    \n    # Initialization (k=0)\n    x_k = 0.5 * (l + u)\n    f_k = f(x_k)\n    g_k = g_oracle(x_k)\n    \n    # Store cuts as tuples of (subgradient, function value, dot_product)\n    # The dot product is pre-calculated for efficiency in building the LP.\n    cuts = [(g_k, f_k, np.dot(g_k, x_k))]\n    \n    # Initial upper bound is the function value at the center. Lower bound is -inf.\n    U = f_k\n    L = -np.inf\n    \n    k_iter = 0\n    converged = False\n    final_gap = U - L\n\n    # Main loop for iterations k = 1, 2, ...\n    for k in range(1, K_max + 1):\n        k_iter = k\n        \n        # --- Construct and solve the Linear Program ---\n        # The variables of the LP are [x_1, ..., x_n, t].\n        c_obj = np.zeros(n + 1)\n        c_obj[n] = 1.0  # Objective: minimize t\n\n        # The constraints are t >= g_i^T x + (f_i - g_i^T x_i),\n        # which can be rewritten as g_i^T x - t = g_i^T x_i - f_i.\n        num_cuts = len(cuts)\n        A_ub = np.zeros((num_cuts, n + 1))\n        b_ub = np.zeros(num_cuts)\n\n        for i in range(num_cuts):\n            g_i, f_i, g_dot_x_i = cuts[i]\n            A_ub[i, :n] = g_i\n            A_ub[i, n] = -1.0\n            b_ub[i] = g_dot_x_i - f_i\n        \n        # Bounds for the variables [x_1, ..., x_n, t]\n        bounds_x = list(zip(l, u))\n        bounds_t = (None, None)\n        all_bounds = bounds_x + [bounds_t]\n        \n        # Solve the LP subproblem using the 'highs' method.\n        res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub, bounds=all_bounds, method='highs')\n        \n        if not res.success:\n            # If the LP solver fails, terminate and report the last valid state.\n            break\n\n        sol = res.x\n        x_lp_k = sol[:n]\n        t_lp_k = sol[n]\n        \n        # --- Update bounds and check for termination ---\n        L = t_lp_k\n        f_at_x_lp_k = f(x_lp_k)\n        U = min(U, f_at_x_lp_k)\n        \n        gap = U - L\n        final_gap = gap\n        if gap = eps:\n            converged = True\n            break\n        \n        # --- Add a new cut for the next iteration ---\n        g_k_new = g_oracle(x_lp_k)\n        cuts.append((g_k_new, f_at_x_lp_k, np.dot(g_k_new, x_lp_k)))\n        \n    return [L, U, final_gap, k_iter, converged]\n\ndef solve():\n    # Define algorithmic parameters\n    eps = 1e-5\n    K_max = 100\n\n    # Test Case 1: Nondifferentiable univariate\n    f1 = lambda x: np.abs(x[0]) + 0.5 * x[0]\n    def g1(x):\n        if x[0] > 0: return np.array([1.5])\n        elif x[0]  0: return np.array([-0.5])\n        else: return np.array([0.0])\n    l1 = np.array([-3.0])\n    u1 = np.array([3.0])\n\n    # Test Case 2: Smooth strongly convex quadratic\n    f2 = lambda x: x[0]**2 + x[1]**2 - 2*x[0] + x[1]\n    g2 = lambda x: np.array([2*x[0] - 2, 2*x[1] + 1])\n    l2 = np.array([-2.0, -2.0])\n    u2 = np.array([2.0, 2.0])\n\n    # Test Case 3: Convex piecewise-linear\n    components3 = [(np.array([1.0, -1.0]), 0.0), \n                   (np.array([-2.0, 1.0]), 1.0), \n                   (np.array([0.5, 0.5]), -1.0)]\n    def f3(x):\n        return np.max([np.dot(c, x) + b for c, b in components3])\n    def g3(x):\n        vals = [np.dot(c, x) + b for c, b in components3]\n        max_idx = np.argmax(vals) # argmax uses the first occurrence in case of a tie\n        return components3[max_idx][0]\n    l3 = np.array([-2.0, -2.0])\n    u3 = np.array([2.0, 2.0])\n\n    # Test Case 4: Smooth convex log-sum-exp\n    def f4(x):\n        return np.log(np.exp(x[0]) + np.exp(x[1]))\n    def g4(x):\n        exps = np.exp(x)\n        return exps / np.sum(exps)\n    l4 = np.array([-2.0, -2.0])\n    u4 = np.array([2.0, 2.0])\n\n    test_cases = [\n        (f1, g1, l1, u1),\n        (f2, g2, l2, u2),\n        (f3, g3, l3, u3),\n        (f4, g4, l4, u4),\n    ]\n\n    all_results = []\n    for f, g, l, u in test_cases:\n        result = cutting_plane_algorithm(f, g, l, u, eps, K_max)\n        all_results.append(result)\n\n    # Format output string exactly as required (list of lists, no spaces)\n    results_str_list = []\n    for res in all_results:\n        L, U, G, K, C = res\n        # Round L, U, G to 6 decimal places and format string representation\n        s = f\"[{round(L, 6):.6f},{round(U, 6):.6f},{round(G, 6):.6f},{K},{str(C).lower()}]\" # Python bool to js/json bool\n        # Realized that the prompt asks for Python Boolean representation, not JS.\n        s = f\"[{round(L, 6):.6f},{round(U, 6):.6f},{round(G, 6):.6f},{K},{C}]\"\n        results_str_list.append(s)\n\n    final_output = f\"[{','.join(results_str_list)}]\"\n    print(final_output)\n\n# The function `solve` is not called here because this block is just a representation\n# of the solution code. The user is expected to run this code.\n# The expected output is a string, but the answer should be the code that generates it.\n```"
        }
    ]
}