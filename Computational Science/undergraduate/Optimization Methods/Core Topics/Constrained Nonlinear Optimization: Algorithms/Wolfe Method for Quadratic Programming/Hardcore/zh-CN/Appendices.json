{
    "hands_on_practices": [
        {
            "introduction": "理解迭代算法的最佳方式莫过于亲手演算一遍。本练习将引导你完成 Wolfe 方法的两次完整迭代，解决一个具体的二次规划问题。通过这个过程，你将掌握计算搜索方向、确定步长以及管理工作集的核心流程，从而为你建立算法如何在可行域的边界上“行走”以寻找最优解的直观理解。",
            "id": "3198849",
            "problem": "考虑一个带箱型约束的二次规划（QP）问题，其目标是最小化二次目标函数。设目标函数为 $f(x) = \\frac{1}{2} x^{\\top} Q x + c^{\\top} x$，其中\n$$\nQ = \\begin{pmatrix}\n2  -1 \\\\\n-1  2\n\\end{pmatrix}, \\quad\nc = \\begin{pmatrix}\n-5 \\\\\n2\n\\end{pmatrix},\n$$\n箱型约束为 $l \\le x \\le u$，其中\n$$\nl = \\begin{pmatrix}\n0 \\\\\n0\n\\end{pmatrix}, \\quad\nu = \\begin{pmatrix}\n1 \\\\\n1\n\\end{pmatrix}.\n$$\n从可行点开始\n$$\nx^{(0)} = \\begin{pmatrix}\n\\frac{1}{5} \\\\\n\\frac{4}{5}\n\\end{pmatrix}.\n$$\n使用Wolfe方法，将工作集 $W$ 中的积极边界视为等式，并从对应于自由变量的列构建零空间基 $Z$，执行以下步骤：\n\n1. 陈述箱型约束下的Karush–Kuhn–Tucker (KKT) 最优性条件，并解释Wolfe的工作集方法如何通过将积极边界视为等式来强制满足这些条件。\n\n2. 在 $x^{(0)}$ 处，根据自由变量列构建初始工作集 $W^{(0)}$ 和零空间基 $Z^{(0)}$。通过求解既约系统计算梯度 $g^{(0)} = Q x^{(0)} + c$ 和Wolfe搜索方向 $p^{(0)}$：\n$$\nZ^{(0)\\top} Q Z^{(0)} d^{(0)} = - Z^{(0)\\top} g^{(0)}, \\quad p^{(0)} = Z^{(0)} d^{(0)}.\n$$\n确定保持关于 $l \\le x \\le u$ 可行性的最大步长 $\\alpha^{(0)}$，识别哪个边界变为积极，并更新至 $x^{(1)} = x^{(0)} + \\alpha^{(0)} p^{(0)}$。\n\n3. 在 $x^{(1)}$ 处，更新工作集 $W^{(1)}$ 以包含刚触及的边界，从剩余的自由变量列构建新的零空间基 $Z^{(1)}$，并由下式计算既约梯度搜索方向 $p^{(1)}$：\n$$\nZ^{(1)\\top} Q Z^{(1)} d^{(1)} = - Z^{(1)\\top} g^{(1)}, \\quad g^{(1)} = Q x^{(1)} + c, \\quad p^{(1)} = Z^{(1)} d^{(1)}.\n$$\n确定到达下一个边界的步长 $\\alpha^{(1)}$，更新至 $x^{(2)} = x^{(1)} + \\alpha^{(1)} p^{(1)}$，并报告观察到的交替触及边界的情况。\n\n4. 在 $x^{(2)}$ 处，验证积极边界上梯度分量的KKT符号条件，并论证该凸QP的最优性。\n\n最后，计算最优目标值 $f(x^{(2)})$ 的精确数值。仅提供此单个数字作为您的最终答案。",
            "solution": "该问题是一个二次规划（QP）练习，涉及在箱型约束下最小化一个凸二次函数。目标函数为 $f(x) = \\frac{1}{2} x^{\\top} Q x + c^{\\top} x$，其中 $x \\in \\mathbb{R}^2$。数据由下式给出：\n$$\nQ = \\begin{pmatrix}\n2  -1 \\\\\n-1  2\n\\end{pmatrix}, \\quad\nc = \\begin{pmatrix}\n-5 \\\\\n2\n\\end{pmatrix}, \\quad\nl = \\begin{pmatrix}\n0 \\\\\n0\n\\end{pmatrix}, \\quad\nu = \\begin{pmatrix}\n1 \\\\\n1\n\\end{pmatrix}.\n$$\n起始点为 $x^{(0)} = \\begin{pmatrix} \\frac{1}{5} \\\\ \\frac{4}{5} \\end{pmatrix}$，该点是可行的，因为 $l \\le x^{(0)} \\le u$。矩阵 $Q$ 是对称正定的（其特征值为1和3），因此该QP是严格凸的，并有唯一的全局最小值。我们将应用Wolfe的积极集法来找到这个最小值。\n\n首先，我们陈述Karush–Kuhn–Tucker (KKT) 最优性条件。问题是 $\\min f(x)$，约束为 $l - x \\le 0$ 和 $x - u \\le 0$。拉格朗日函数为 $\\mathcal{L}(x, \\lambda, \\mu) = f(x) + \\lambda^{\\top}(l-x) + \\mu^{\\top}(x-u)$，其中 $\\lambda \\ge 0$ 和 $\\mu \\ge 0$ 是拉格朗日乘子。KKT条件是：\n1. 平稳性（Stationarity）：$\\nabla f(x) - \\lambda + \\mu = 0$，即 $g(x) = \\lambda - \\mu$，其中 $g(x) = Qx+c$ 是 $f(x)$ 的梯度。\n2. 原始可行性（Primal Feasibility）：$l \\le x \\le u$。\n3. 对偶可行性（Dual Feasibility）：$\\lambda \\ge 0, \\mu \\ge 0$。\n4. 互补松弛性（Complementary Slackness）：对于每个分量 $i$，有 $\\lambda_i(l_i - x_i) = 0$ 和 $\\mu_i(x_i - u_i) = 0$。\n\n这些条件在最优点 $x^*$ 处意味着特定的关系：\n- 如果 $l_i  x_i^*  u_i$，则 $\\lambda_i=\\mu_i=0$，所以 $g_i(x^*) = 0$。\n- 如果 $x_i^* = l_i$，则 $\\mu_i=0$，所以 $g_i(x^*) = \\lambda_i \\ge 0$。\n- 如果 $x_i^* = u_i$，则 $\\lambda_i=0$，所以 $g_i(x^*) = -\\mu_i \\le 0$。\n\nWolfe方法迭代地强制满足这些条件。它维护一个工作集 $W$，其中包含保持在其边界上的变量的索引。这些被视为等式约束。搜索方向 $p$ 在剩余自由变量的子空间中计算。\n搜索方向 $p$ 必须是积极约束的可行方向，意味着对于所有 $i \\in W$，有 $p_i = 0$。向量 $p$ 被划分为对应于固定变量和自由变量的分量。求解自由变量的子问题以找到下降方向。当沿 $p$ 的一步导致新约束变为积极时，该约束的索引被添加到 $W$ 中。如果无法移动（即子问题的解是零向量），则检查拉格朗日乘子（从梯度推断）的符号。如果它们不正确（例如，对于处于下界的变量有 $g_i  0$），则从 $W$ 中移除相应的约束，然后继续该过程。当工作集中的所有变量的梯度分量都满足KKT符号条件，并且自由变量的既约梯度为零时，就达到了最优性。\n\n现在，我们从 $x^{(0)} = \\begin{pmatrix} \\frac{1}{5} \\\\ \\frac{4}{5} \\end{pmatrix}$ 开始执行第一次迭代。\n在 $x^{(0)}$ 处，没有变量在其边界上。工作集为空：$W^{(0)} = \\emptyset$。两个变量都是自由的。跨越自由变量子空间的零空间基 $Z^{(0)}$ 是单位矩阵 $Z^{(0)} = I = \\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix}$。\n在 $x^{(0)}$ 处的梯度为：\n$$\ng^{(0)} = Q x^{(0)} + c = \\begin{pmatrix} 2  -1 \\\\ -1  2 \\end{pmatrix} \\begin{pmatrix} \\frac{1}{5} \\\\ \\frac{4}{5} \\end{pmatrix} + \\begin{pmatrix} -5 \\\\ 2 \\end{pmatrix} = \\begin{pmatrix} \\frac{2}{5} - \\frac{4}{5} \\\\ -\\frac{1}{5} + \\frac{8}{5} \\end{pmatrix} + \\begin{pmatrix} -5 \\\\ 2 \\end{pmatrix} = \\begin{pmatrix} -\\frac{2}{5} \\\\ \\frac{7}{5} \\end{pmatrix} + \\begin{pmatrix} -5 \\\\ 2 \\end{pmatrix} = \\begin{pmatrix} -\\frac{27}{5} \\\\ \\frac{17}{5} \\end{pmatrix}.\n$$\n既约系统为 $Z^{(0)\\top} Q Z^{(0)} d^{(0)} = - Z^{(0)\\top} g^{(0)}$。因为 $Z^{(0)}=I$，所以这是 $Q d^{(0)} = -g^{(0)}$，搜索方向为 $p^{(0)} = Z^{(0)}d^{(0)} = d^{(0)}$。\n$Q$ 的逆矩阵是 $Q^{-1} = \\frac{1}{3} \\begin{pmatrix} 2  1 \\\\ 1  2 \\end{pmatrix}$。\n所以，$p^{(0)} = -Q^{-1}g^{(0)} = -\\frac{1}{3} \\begin{pmatrix} 2  1 \\\\ 1  2 \\end{pmatrix} \\begin{pmatrix} -\\frac{27}{5} \\\\ \\frac{17}{5} \\end{pmatrix} = -\\frac{1}{3} \\begin{pmatrix} -\\frac{54}{5} + \\frac{17}{5} \\\\ -\\frac{27}{5} + \\frac{34}{5} \\end{pmatrix} = -\\frac{1}{3} \\begin{pmatrix} -\\frac{37}{5} \\\\ \\frac{7}{5} \\end{pmatrix} = \\begin{pmatrix} \\frac{37}{15} \\\\ -\\frac{7}{15} \\end{pmatrix}$。\n我们找到最大步长 $\\alpha^{(0)} \\ge 0$，使得 $l \\le x^{(0)} + \\alpha^{(0)} p^{(0)} \\le u$。\n$$\n\\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix} \\le \\begin{pmatrix} \\frac{1}{5} \\\\ \\frac{4}{5} \\end{pmatrix} + \\alpha^{(0)} \\begin{pmatrix} \\frac{37}{15} \\\\ -\\frac{7}{15} \\end{pmatrix} \\le \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}.\n$$\n对于 $x_1$：$\\frac{1}{5} + \\alpha^{(0)} \\frac{37}{15} \\le 1 \\implies \\alpha^{(0)} \\frac{37}{15} \\le \\frac{4}{5} \\implies \\alpha^{(0)} \\le \\frac{4}{5} \\cdot \\frac{15}{37} = \\frac{12}{37}$。\n对于 $x_2$：$0 \\le \\frac{4}{5} - \\alpha^{(0)} \\frac{7}{15} \\implies \\alpha^{(0)} \\frac{7}{15} \\le \\frac{4}{5} \\implies \\alpha^{(0)} \\le \\frac{4}{5} \\cdot \\frac{15}{7} = \\frac{12}{7}$。\n最大可行步长为 $\\alpha^{(0)} = \\min(\\frac{12}{37}, \\frac{12}{7}) = \\frac{12}{37}$。在此步长下，第一个分量 $x_1$ 触及其上界 $1$。\n下一个迭代点是 $x^{(1)} = x^{(0)} + \\alpha^{(0)} p^{(0)}$：\n$$\nx^{(1)} = \\begin{pmatrix} \\frac{1}{5} \\\\ \\frac{4}{5} \\end{pmatrix} + \\frac{12}{37} \\begin{pmatrix} \\frac{37}{15} \\\\ -\\frac{7}{15} \\end{pmatrix} = \\begin{pmatrix} \\frac{1}{5} + \\frac{12}{15} \\\\ \\frac{4}{5} - \\frac{12 \\cdot 7}{37 \\cdot 15} \\end{pmatrix} = \\begin{pmatrix} \\frac{3}{15} + \\frac{12}{15} \\\\ \\frac{4}{5} - \\frac{28}{185} \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ \\frac{148-28}{185} \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ \\frac{120}{185} \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ \\frac{24}{37} \\end{pmatrix}.\n$$\n\n对于第二次迭代，我们处于 $x^{(1)} = \\begin{pmatrix} 1 \\\\ \\frac{24}{37} \\end{pmatrix}$。\n变量 $x_1$ 在其上界，所以我们更新工作集为 $W^{(1)} = \\{1\\}$。自由变量是 $x_2$。零空间基 $Z^{(1)}$ 由一个单独的向量组成，该向量在第一个分量上为零，在第二个分量上为一，对应于自由变量：$Z^{(1)} = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix}$。\n在 $x^{(1)}$ 处的梯度为：\n$$\ng^{(1)} = Q x^{(1)} + c = \\begin{pmatrix} 2  -1 \\\\ -1  2 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ \\frac{24}{37} \\end{pmatrix} + \\begin{pmatrix} -5 \\\\ 2 \\end{pmatrix} = \\begin{pmatrix} 2 - \\frac{24}{37} \\\\ -1 + \\frac{48}{37} \\end{pmatrix} + \\begin{pmatrix} -5 \\\\ 2 \\end{pmatrix} = \\begin{pmatrix} \\frac{50}{37} \\\\ \\frac{11}{37} \\end{pmatrix} + \\begin{pmatrix} -\\frac{185}{37} \\\\ \\frac{74}{37} \\end{pmatrix} = \\begin{pmatrix} -\\frac{135}{37} \\\\ \\frac{85}{37} \\end{pmatrix}.\n$$\n既约系统为 $Z^{(1)\\top} Q Z^{(1)} d^{(1)} = - Z^{(1)\\top} g^{(1)}$。\n$Z^{(1)\\top} Q Z^{(1)} = \\begin{pmatrix} 0  1 \\end{pmatrix} \\begin{pmatrix} 2  -1 \\\\ -1  2 \\end{pmatrix} \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} -1  2 \\end{pmatrix} \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} = 2$。\n$-Z^{(1)\\top} g^{(1)} = -\\begin{pmatrix} 0  1 \\end{pmatrix} \\begin{pmatrix} -\\frac{135}{37} \\\\ \\frac{85}{37} \\end{pmatrix} = -\\frac{85}{37}$。\n所以，$2 d^{(1)} = -\\frac{85}{37}$，这给出 $d^{(1)} = -\\frac{85}{74}$。\n搜索方向为 $p^{(1)} = Z^{(1)} d^{(1)} = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} (-\\frac{85}{74}) = \\begin{pmatrix} 0 \\\\ -\\frac{85}{74} \\end{pmatrix}$。\n我们找到最大步长 $\\alpha^{(1)} \\ge 0$。第一个分量不变。对于第二个分量：\n$$\n0 \\le x_2^{(1)} + \\alpha^{(1)} p_2^{(1)} \\le 1 \\implies 0 \\le \\frac{24}{37} + \\alpha^{(1)} (-\\frac{85}{74}) \\le 1.\n$$\n由于 $p_2^{(1)}  0$，上界没有限制性。下界给出：$\\alpha^{(1)} \\frac{85}{74} \\le \\frac{24}{37} \\implies \\alpha^{(1)} \\le \\frac{24}{37} \\cdot \\frac{74}{85} = \\frac{24 \\cdot 2}{85} = \\frac{48}{85}$。\n最大步长为 $\\alpha^{(1)} = \\frac{48}{85}$。在此步长下，$x_2$ 触及其下界 $0$。更新为：\n$$\nx^{(2)} = x^{(1)} + \\alpha^{(1)} p^{(1)} = \\begin{pmatrix} 1 \\\\ \\frac{24}{37} \\end{pmatrix} + \\frac{48}{85} \\begin{pmatrix} 0 \\\\ -\\frac{85}{74} \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ \\frac{24}{37} - \\frac{48}{74} \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ \\frac{24}{37} - \\frac{24}{37} \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}.\n$$\n该过程展示了交替触及边界的情况：首先，$x_1$ 触及其上界，然后 $x_2$ 触及其下界。\n\n最后，我们在 $x^{(2)} = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}$ 处验证最优性。\n两个变量现在都在边界上：$x_1=1$（上界）和 $x_2=0$（下界）。工作集为 $W^{(2)} = \\{1, 2\\}$，没有自由变量。零空间是平凡的，因此不可能再有移动。我们必须检查KKT符号条件。\n在 $x^{(2)}$ 处的梯度为：\n$$\ng^{(2)} = Q x^{(2)} + c = \\begin{pmatrix} 2  -1 \\\\ -1  2 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} + \\begin{pmatrix} -5 \\\\ 2 \\end{pmatrix} = \\begin{pmatrix} 2 \\\\ -1 \\end{pmatrix} + \\begin{pmatrix} -5 \\\\ 2 \\end{pmatrix} = \\begin{pmatrix} -3 \\\\ 1 \\end{pmatrix}.\n$$\n对于 $x_1 = 1$（在其上界），KKT条件是 $g_1(x^{(2)}) \\le 0$。我们有 $g_1^{(2)}=-3$，满足该条件。\n对于 $x_2 = 0$（在其下界），KKT条件是 $g_2(x^{(2)}) \\ge 0$。我们有 $g_2^{(2)}=1$，满足该条件。\n所有KKT条件都已满足。由于问题是严格凸的，$x^{(2)} = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}$ 是唯一的全局最优解。\n\n最优目标值为 $f(x^{(2)})$：\n$$\nf(x^{(2)}) = \\frac{1}{2} x^{(2)\\top} Q x^{(2)} + c^{\\top} x^{(2)} = \\frac{1}{2} \\begin{pmatrix} 1  0 \\end{pmatrix} \\begin{pmatrix} 2  -1 \\\\ -1  2 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} + \\begin{pmatrix} -5  2 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}\n$$\n$$\nf(x^{(2)}) = \\frac{1}{2} \\begin{pmatrix} 1  0 \\end{pmatrix} \\begin{pmatrix} 2 \\\\ -1 \\end{pmatrix} + (-5) = \\frac{1}{2}(2) - 5 = 1 - 5 = -4.\n$$",
            "answer": "$$\\boxed{-4}$$"
        },
        {
            "introduction": "在掌握了基本流程后，我们需要考虑算法在实践中可能遇到的挑战。有效集方法的一个关键理论基础是，工作集中的约束必须是线性无关的，这保证了子问题的解是良定义的。本练习模拟了一个约束冗余导致工作集矩阵秩亏损的场景。解决这个问题将锻炼你的诊断能力，并加深你对算法背后线性代数要求的理解，特别是约束规范性（constraint qualification）的重要性。",
            "id": "3198856",
            "problem": "考虑在 Wolfe 方法（有效集法）的框架下，求解一个带线性不等式约束的二次规划（QP）问题，该问题旨在最小化一个二次目标函数。目标函数为\n$$\n\\min_{x \\in \\mathbb{R}^{2}} \\;\\; \\frac{1}{2}\\, x^{\\top} H x + c^{\\top} x,\n$$\n其中\n$$\nH = \\begin{pmatrix} 2  0 \\\\ 0  2 \\end{pmatrix}, \\qquad c = \\begin{pmatrix} -4 \\\\ -2 \\end{pmatrix}.\n$$\n不等式约束可以汇总为\n$$\nA x \\ge b, \\quad \\text{其中} \\quad\nA = \\begin{pmatrix}\n1  1 \\\\\n1  -1 \\\\\n2  2\n\\end{pmatrix}, \\qquad\nb = \\begin{pmatrix}\n3 \\\\\n1 \\\\\n6\n\\end{pmatrix}.\n$$\n假设在某次可行迭代 $x^{(k)}$ 处，Wolfe 方法当前使用的有效集为 $W = \\{1,2,3\\}$，因此有效约束矩阵和右侧向量为\n$$\nA_{W} = \\begin{pmatrix}\n1  1 \\\\\n1  -1 \\\\\n2  2\n\\end{pmatrix}, \\qquad b_{W} = \\begin{pmatrix} 3 \\\\ 1 \\\\ 6 \\end{pmatrix}.\n$$\n从秩的基本定义和等式约束子问题的 Karush–Kuhn–Tucker (KKT) 一阶条件出发，完成以下任务：\n\n1. 判断 $A_{W}$ 是否秩亏。如果是，则从 $W$ 中删减约束，直到剩余的有效集满足 $\\operatorname{rank}(A_{W}) = |W|$，并利用行向量之间的线性相关性来解释你的选择。\n\n2. 使用删减后的有效集，构建并求解等式约束的 KKT 系统，以获得相应等式约束子问题的唯一最小化点。\n\n在该最小化点处，目标函数的精确值是多少？请提供精确值，不要四舍五入。",
            "solution": "我们需要分析给定二次规划（QP）问题中 Wolfe 方法的一个特定状态。需要最小化的目标函数为 $f(x) = \\frac{1}{2} x^{\\top} H x + c^{\\top} x$，其中 $x \\in \\mathbb{R}^{2}$，相关矩阵如下：\n$$\nH = \\begin{pmatrix} 2  0 \\\\ 0  2 \\end{pmatrix}, \\qquad c = \\begin{pmatrix} -4 \\\\ -2 \\end{pmatrix}\n$$\n线性不等式约束为 $A x \\ge b$，其中：\n$$\nA = \\begin{pmatrix}\n1  1 \\\\\n1  -1 \\\\\n2  2\n\\end{pmatrix}, \\qquad\nb = \\begin{pmatrix}\n3 \\\\\n1 \\\\\n6\n\\end{pmatrix}\n$$\n在当前迭代点，有效约束集为 $W = \\{1, 2, 3\\}$。相应的有效约束矩阵和右侧向量为：\n$$\nA_{W} = \\begin{pmatrix}\n1  1 \\\\\n1  -1 \\\\\n2  2\n\\end{pmatrix}, \\qquad b_{W} = \\begin{pmatrix} 3 \\\\ 1 \\\\ 6 \\end{pmatrix}\n$$\n有效集中的约束数量为 $|W|=3$。\n\n**第一部分：秩亏性与有效集的删减**\n\n首先，我们必须确定有效约束矩阵 $A_{W}$ 是否是秩亏的。在有效集法的背景下，这通常意味着检查 $A_{W}$ 的行向量是否线性无关。为了使 KKT 子问题良定并拥有唯一的拉格朗日乘子向量，要求有效约束矩阵的行向量是线性无关的。这等价于 $A_W^\\top$ 的列向量线性无关，也意味着有效约束的数量不能超过变量的数量，即 $|W| \\le n$。当 $|W| > n$ 时，行向量必然线性相关。此处，$|W|=3$ 且 $n=2$，因此行向量必然是线性相关的。\n\n将 $A_W$ 的行向量表示为 $r_1, r_2, r_3$：\n$$\nr_1 = \\begin{pmatrix} 1  1 \\end{pmatrix} \\\\\nr_2 = \\begin{pmatrix} 1  -1 \\end{pmatrix} \\\\\nr_3 = \\begin{pmatrix} 2  2 \\end{pmatrix}\n$$\n我们可以观察到这些行向量之间存在线性相关性。具体来说，行向量 $r_3$ 是行向量 $r_1$ 的标量倍：\n$$\nr_3 = 2 \\cdot r_1 \\quad \\text{因为} \\quad \\begin{pmatrix} 2  2 \\end{pmatrix} = 2 \\cdot \\begin{pmatrix} 1  1 \\end{pmatrix}\n$$\n这证实了 $A_W$ 的行向量是线性相关的。$A_W$ 的秩是线性无关行向量的数量。由于 $r_1$ 和 $r_2$ 不平行（即，不是彼此的标量倍），它们是线性无关的。因此，$A_W$ 的秩为 $2$。\n我们有 $\\operatorname{rank}(A_{W}) = 2$ 且 $|W|=3$。条件 $\\operatorname{rank}(A_{W}) = |W|$ 未被满足。\n\n为解决此问题，我们必须通过移除约束来删减有效集 $W$，直到新的有效约束矩阵的行向量线性无关。线性相关关系为 $r_3 - 2r_1 = 0$，这涉及到约束 1 和 3。移除约束 1 或 3 均可打破此特定相关性。我们选择从有效集 $W$ 中移除约束 3。新的、经过删减的有效集为 $W' = \\{1, 2\\}$。\n\n相应的有效约束矩阵和右侧向量为：\n$$\nA_{W'} = \\begin{pmatrix}\n1  1 \\\\\n1  -1\n\\end{pmatrix}, \\qquad b_{W'} = \\begin{pmatrix} 3 \\\\ 1 \\end{pmatrix}\n$$\n这个新有效集中的约束数量为 $|W'| = 2$。$A_{W'}$ 的行向量为 $r_1 = \\begin{pmatrix} 1  1 \\end{pmatrix}$ 和 $r_2 = \\begin{pmatrix} 1  -1 \\end{pmatrix}$。为检查线性无关性，我们计算 $A_{W'}$ 的行列式：\n$$\n\\det(A_{W'}) = (1)(-1) - (1)(1) = -1 - 1 = -2\n$$\n因为 $\\det(A_{W'}) \\neq 0$，所以行向量是线性无关的。因此，$\\operatorname{rank}(A_{W'}) = 2$。\n条件 $\\operatorname{rank}(A_{W'}) = |W'|$ 现已满足，因为 $2=2$。\n\n**第二部分：求解等式约束的 KKT 子问题**\n\n利用删减后的有效集 $W'$，我们现在求解等式约束子问题：\n$$\n\\min_{x \\in \\mathbb{R}^{2}} \\;\\; \\frac{1}{2}\\, x^{\\top} H x + c^{\\top} x \\quad \\text{subject to} \\quad A_{W'} x = b_{W'}\n$$\n此子问题的 Karush–Kuhn–Tucker (KKT) 条件表明，必须存在一个拉格朗日乘子向量 $\\lambda \\in \\mathbb{R}^{2}$，使得：\n$$\n\\nabla_x (\\frac{1}{2}\\, x^{\\top} H x + c^{\\top} x + \\lambda^{\\top} (b_{W'} - A_{W'}x) )= 0\n$$\n$$\nA_{W'} x = b_{W'}\n$$\n第一个条件可以简化为 $H x + c - A_{W'}^{\\top} \\lambda = 0$，或者 $H x + A_{W'}^{\\top} \\lambda = -c$。综合起来，KKT 条件构成一个线性方程组：\n$$\n\\begin{pmatrix} H  A_{W'}^{\\top} \\\\ A_{W'}  0 \\end{pmatrix}\n\\begin{pmatrix} x \\\\ \\lambda \\end{pmatrix}\n=\n\\begin{pmatrix} -c \\\\ b_{W'} \\end{pmatrix}\n$$\n为求得最小化点 $x$，我们只需关注等式约束本身：\n$$\nA_{W'} x = b_{W'} \\implies \\begin{pmatrix} 1  1 \\\\ 1  -1 \\end{pmatrix} \\begin{pmatrix} x_1 \\\\ x_2 \\end{pmatrix} = \\begin{pmatrix} 3 \\\\ 1 \\end{pmatrix}\n$$\n这代表了以下方程组：\n1. $x_1 + x_2 = 3$\n2. $x_1 - x_2 = 1$\n\n将两个方程相加，得到 $2x_1 = 4$，因此 $x_1 = 2$。\n将 $x_1=2$ 代入第一个方程，得到 $2 + x_2 = 3$，因此 $x_2 = 1$。\n该等式约束子问题的唯一最小化点是 $x = \\begin{pmatrix} 2 \\\\ 1 \\end{pmatrix}$。\n\n**最终计算：目标函数值**\n\n最后一步是计算目标函数 $f(x)$ 在该最小化点 $x = \\begin{pmatrix} 2 \\\\ 1 \\end{pmatrix}$ 处的值。\n目标函数为 $f(x) = \\frac{1}{2} x^{\\top} H x + c^{\\top} x$。我们分别计算每一项：\n二次项为：\n$$\n\\frac{1}{2} x^{\\top} H x = \\frac{1}{2} \\begin{pmatrix} 2  1 \\end{pmatrix} \\begin{pmatrix} 2  0 \\\\ 0  2 \\end{pmatrix} \\begin{pmatrix} 2 \\\\ 1 \\end{pmatrix} = \\frac{1}{2} \\begin{pmatrix} 4  2 \\end{pmatrix} \\begin{pmatrix} 2 \\\\ 1 \\end{pmatrix} = \\frac{1}{2} ((4)(2) + (2)(1)) = \\frac{1}{2} (8 + 2) = \\frac{1}{2} (10) = 5\n$$\n线性项为：\n$$\nc^{\\top} x = \\begin{pmatrix} -4  -2 \\end{pmatrix} \\begin{pmatrix} 2 \\\\ 1 \\end{pmatrix} = (-4)(2) + (-2)(1) = -8 - 2 = -10\n$$\n目标函数的总值为这两项之和：\n$$\nf\\left(\\begin{pmatrix} 2 \\\\ 1 \\end{pmatrix}\\right) = 5 + (-10) = -5\n$$\n在该最小化点处，目标函数的精确值为 $-5$。",
            "answer": "$$ \\boxed{-5} $$"
        },
        {
            "introduction": "从纸笔计算到计算机模拟是理解算法行为的关键一步。一个优化算法的效率，例如其在迭代过程中“添加”与“移除”约束的频率，往往与问题可行域的几何结构密切相关。这个高级练习要求你通过编程实现 Wolfe 方法，并设计一个计算实验来探索这种关联。通过分析算法在大量随机问题上的表现，并将其与可行多面体的几何特性（如顶点的平均度）联系起来，你将从算法的使用者转变为其性能的分析者。",
            "id": "3198911",
            "problem": "您被要求设计并实现一个计算实验，以研究沃尔夫方法（Wolfe's method）在处理带线性不等式约束的凸二次规划（QP）问题时的行为，并将有效集过程中观察到的添加/移除事件与可行多面体的组合结构联系起来。该实验必须是完全可复现且自包含的。\n\n该优化问题的模型是如下的凸二次规划（QP）：\n$$\n\\min_{x \\in \\mathbb{R}^n} \\ \\tfrac{1}{2} x^\\top Q x + c^\\top x \\quad \\text{subject to} \\quad A x \\le b,\n$$\n其中 $Q \\in \\mathbb{R}^{n \\times n}$ 是正定矩阵，$c \\in \\mathbb{R}^{n}$，$A \\in \\mathbb{R}^{m \\times n}$，以及 $b \\in \\mathbb{R}^{m}$。在整个实验中，$Q$ 将被生成为正定矩阵以确保严格凸性。\n\n推导的起点必须使用凸二次规划（QP）的卡罗需-库恩-塔克（KKT）最优性条件。该条件表明，如果存在一个拉格朗日乘子向量 $\\lambda^\\star \\in \\mathbb{R}^m$ 满足以下条件，则 $x^\\star$ 是最优解：\n- 原始可行性：$A x^\\star \\le b$，\n- 对偶可行性：$\\lambda^\\star \\ge 0$，\n- 平稳性：$Q x^\\star + c + A^\\top \\lambda^\\star = 0$，\n- 互补松弛性：对于所有 $i$，$\\lambda^\\star_i \\cdot (A_i x^\\star - b_i) = 0$。\n\n沃尔夫方法（有效集方法）通过维护一个工作集 $W$ 来进行，该工作集中的约束被视为等式 $A_W x = b_W$。方法通过求解等式约束的QP子问题，然后在移动会导致违反可行性时添加一个阻塞约束，或在相关拉格朗日乘子变为负数时移除一个约束。在每次迭代中，恰好发生以下两种事件之一：\n- “添加”事件：一个新的约束索引进入 $W$，因为它变为有效（阻塞）状态，\n- “移除”事件：一个约束索引因在满步长情况下出现负的拉格朗日乘子而离开 $W$。\n\n您的程序必须为上述QP类别实现沃尔夫方法，从初始点 $x_0 = 0$ 开始，通过构造 $b$ 来保证该初始点是可行的。对于每个随机生成的QP实例，您必须计算直到终止时的“添加”事件数量和“移除”事件数量。\n\n为了将这种动态与可行集的几何形状联系起来，考虑多面体 $P = \\{ x \\in \\mathbb{R}^n : A x \\le b \\}$。$P$ 中顶点 $v$ 的度定义为与 $v$ 相关联的边的数量。在本实验的计算中，按如下方式近似该度：将注意力限制在由恰好 $n$ 个线性无关约束的交点形成的简单顶点上。一个顶点由一个索引集 $I \\subseteq \\{1,\\dots,m\\}$（其中 $\\lvert I \\rvert = n$）标识，使得 $A_I x = b_I$ 有唯一解 $x$ 并且 $A x \\le b$。如果两个顶点的有效集仅相差一个索引（即它们共享 $n-1$ 个约束），则认为它们是相邻的。一个顶点的度是通过将其有效集 $I$ 中的一个索引与 $\\{1,\\dots,m\\} \\setminus I$ 中的一个索引交换，从而产生一个可行顶点所能形成的不同相邻顶点的数量。$P$ 的平均度定义为通过枚举大小为 $n$ 的所有索引集找到的所有此类顶点的度的算术平均值。\n\n您必须为每个测试用例在多个随机QP实例上运行一个实验，并为每个实例计算添加和移除事件的计数以及相应多面体 $P$ 的平均度。然后，为每个测试用例汇总以下指标：\n- 各实例添加事件数量的均值，\n- 各实例移除事件数量的均值，\n- 各实例 $P$ 的平均度的均值，\n- 每个实例的添加事件比例（定义为当 $\\text{adds} + \\text{drops} > 0$ 时为 $\\text{adds} / (\\text{adds} + \\text{drops})$，否则为 $0$）与每个实例的平均度之间的皮尔逊相关系数。\n\n您的实现必须基于KKT条件和等式约束子问题的结构，而不使用快捷公式。通过构造 $b$ 为 $b = A x_0 + r$（其中 $r$ 的所有元素均为严格正数）来确保 $x_0 = 0$ 的可行性，因此 $A x_0 \\le b$ 成立。将 $Q$ 生成为 $Q = R^\\top R + \\delta I_n$，其中 $\\delta > 0$ 是一个小数，R是随机矩阵，以保证正定性。从零均值正态分布中生成 $c$ 和 $A$。使用适当的容差来确保数值鲁棒性。\n\n您的程序必须实现以下测试套件，其中 $n$ 是维度，$m$ 是约束数量，$K$ 是每个案例的随机QP实例数，$s$ 是随机种子：\n- 案例 1：$n=2$, $m=5$, $K=25$, $s=42$。\n- 案例 2：$n=2$, $m=8$, $K=25$, $s=7$。\n- 案例 3：$n=3$, $m=6$, $K=20$, $s=123$。\n- 案例 4：$n=2$, $m=3$, $K=30$, $s=99$。\n\n对于随机生成，请使用：\n- $Q = R^\\top R + \\delta I_n$，其中 $\\delta = 0.5$，$R$ 的元素从标准正态分布中抽样，\n- $c$ 的元素从标准正态分布中抽样，\n- $A$ 的元素从标准正态分布中抽样，\n- $r$ 的元素从 $[0.5, 1.5]$ 上的均匀分布中独立抽样，因此 $b = r$ 因为 $x_0 = 0$。\n\n使用 $\\varepsilon = 10^{-8}$ 的可行性容差进行等式检测和不等式满足判断，并为每个实例设置 1000 次沃尔夫迭代的上限，以保证实验的终止。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个测试用例贡献一个按上述顺序排列的包含四个浮点数的列表，总输出是这四个测试用例列表的聚合。例如，输出格式必须为以下形式：\n$$\n\\text{\"[[a_1,d_1,g_1,\\rho_1],[a_2,d_2,g_2,\\rho_2],[a_3,d_3,g_3,\\rho_3],[a_4,d_4,g_4,\\rho_4]]\"}\n$$\n其中 $a_i$ 是添加事件的平均数，$d_i$ 是移除事件的平均数，$g_i$ 是平均度，$ \\rho_i $ 是案例 $i$ 的皮尔逊相关系数。\n\n此问题不涉及物理单位。所有角度（如果出现）均以弧度为单位，但不需要任何角度量。百分比必须表示为如上定义的小数；不要使用百分号。",
            "solution": "用户在凸优化领域提供了一个定义明确的计算问题。该问题具有科学依据、自成体系且算法明确。它要求实现用于二次规划的沃尔夫有效集方法，并分析其行为与可行集几何结构之间的关系。\n\n**1. 问题公式化与最优性条件**\n\n该问题涉及以下形式的凸二次规划（QP）：\n$$\n\\min_{x \\in \\mathbb{R}^n} \\ f(x) = \\tfrac{1}{2} x^\\top Q x + c^\\top x \\quad \\text{subject to} \\quad A x \\le b\n$$\n其中 $Q \\in \\mathbb{R}^{n \\times n}$ 是对称正定矩阵，$c \\in \\mathbb{R}^n$，$A \\in \\mathbb{R}^{m \\times n}$，以及 $b \\in \\mathbb{R}^m$。$Q$ 的正定性确保了目标函数 $f(x)$ 是严格凸的，从而保证如果解存在，则解是唯一的。\n\n此问题的解由卡罗需-库恩-塔克（KKT）条件刻画。一个点 $x^\\star$ 是最优解，当且仅当存在一个拉格朗日乘子向量 $\\lambda^\\star \\in \\mathbb{R}^m$ 满足以下条件：\n1.  **原始可行性:** $A x^\\star \\le b$。\n2.  **对偶可行性:** $\\lambda^\\star \\ge 0$。\n3.  **平稳性:** $\\nabla f(x^\\star) + \\sum_{i=1}^m \\lambda^\\star_i \\nabla (A_i x - b_i) = 0$，可简化为 $Q x^\\star + c + A^\\top \\lambda^\\star = 0$。\n4.  **互补松弛性:** 对于每个 $i \\in \\{1, \\dots, m\\}$，$\\lambda^\\star_i (A_i x^\\star - b_i) = 0$。这意味着如果一个约束 $i$ 未激活（即 $A_i x^\\star  b_i$），其对应的乘子必须为零（$\\lambda^\\star_i = 0$）。\n\n**2. 沃尔夫有效集方法**\n\n沃尔夫方法是一种用于求解QP问题的迭代式有效集策略。它从一个可行点 $x_0$ 开始，生成一系列收敛到解 $x^\\star$ 的可行迭代点 $x_k$。在每次迭代 $k$ 中，会维护一个约束索引的“工作集” $W_k$。这些约束被视为等式。\n\n该方法按以下步骤进行：\n令 $x_k$ 为当前迭代点，$W_k$ 为工作集，使得对于所有 $i \\in W_k$，$A_i x_k = b_i$。\n\n**步骤1：求解搜索方向**\n我们寻求一个搜索方向 $p$，它能在保持在由有效约束定义的表面上的同时改进目标函数。下一个迭代点将是 $x_{k+1} = x_k + p$。子问题是：\n$$\n\\min_{p \\in \\mathbb{R}^n} \\ \\tfrac{1}{2} (x_k+p)^\\top Q (x_k+p) + c^\\top (x_k+p) \\quad \\text{subject to} \\quad A_i (x_k+p) = b_i, \\forall i \\in W_k\n$$\n由于对于 $i \\in W_k$，$A_i x_k = b_i$，这简化为找到一个 $p$ 来最小化 $\\tfrac{1}{2} p^\\top Q p + (Qx_k+c)^\\top p$，约束条件为 $A_{W_k} p = 0$。这个等式约束子问题的KKT条件导出了以下线性系统：\n$$\n\\begin{pmatrix}\nQ  A_{W_k}^\\top \\\\\nA_{W_k}  0\n\\end{pmatrix}\n\\begin{pmatrix}\np_k \\\\\n\\lambda_{W_k}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n-(Qx_k+c) \\\\\n0\n\\end{pmatrix}\n$$\n其中 $A_{W_k}$ 是其行向量为工作集 $W_k$ 中约束梯度的矩阵。\n\n**步骤2：检查最优性并更新工作集**\n-   如果系统的解是零搜索方向（$p_k \\approx 0$）：我们处于当前子空间内的最小值点。我们检查从KKT系统获得的拉格朗日乘子 $\\lambda_{W_k}$。\n    -   如果对于所有 $j \\in W_k$，都有 $\\lambda_j \\ge 0$，则原始问题的KKT条件得到满足，$x_k$ 是最优解。算法终止。\n    -   如果存在某个 $\\lambda_j  0$，目标函数可以通过离开约束 $j$ 来进一步减小。我们选择对应于最负乘子的索引 $j$，将其从工作集中移除（$W_{k+1} = W_k \\setminus \\{j\\}$），并以 $x_{k+1} = x_k$ 进入下一次迭代。这是一个 **“移除”事件**。\n\n-   如果解是非零搜索方向（$p_k \\neq 0$）：我们必须找到一个步长 $\\alpha_k$ 来保持原始可行性。\n    -   一个完整的步长是 $\\alpha_k = 1$。但是，我们不能违反任何非有效约束。我们通过检查阻塞约束来计算最大可行步长：\n        $$\n        \\alpha_k = \\min \\left(1, \\min_{i \\notin W_k, A_i p_k > 0} \\frac{b_i - A_i x_k}{A_i p_k} \\right)\n        $$\n    -   下一个迭代点是 $x_{k+1} = x_k + \\alpha_k p_k$。\n    -   如果 $\\alpha_k  1$，一个新的约束变为有效。这个阻塞约束的索引被添加到工作集中（$W_{k+1} = W_k \\cup \\{\\text{blocking index}\\}$）。这是一个 **“添加”事件**。\n    -   如果 $\\alpha_k=1$，则在没有任何新约束变为有效的情况下，采取了完整的步长。工作集保持不变（$W_{k+1} = W_k$）。\n\n算法从 $x_0=0$ 和一个空的工作集 $W_0 = \\emptyset$ 开始。所有比较都使用一个可行性容差 $\\varepsilon = 10^{-8}$。\n\n**3. 多面体几何分析**\n\n可行集 $P = \\{ x \\in \\mathbb{R}^n : A x \\le b \\}$ 是一个凸多面体。该实验将沃尔夫方法的算法路径与此多面体的组合结构联系起来。\n\n-   **顶点识别：** $P$ 的顶点被近似为一个“简单”顶点，即由恰好 $n$ 个线性无关的等式约束的交点形成的点。为了找到所有这样的顶点，我们遍历所有 $n$ 个约束索引的组合 $I \\subseteq \\{1, \\dots, m\\}$。对于每个 $I$，我们构建系统 $A_I x = b_I$。\n    1.  我们检查矩阵 $A_I$ 是否可逆（例如，通过检查其秩是否为 $n$）。\n    2.  如果可逆，我们求解唯一的点 $x_v$。\n    3.  然后，我们通过检查是否对所有约束都满足 $A x_v \\le b$ 来验证 $x_v$ 是否可行。\n    满足这些标准的点被认为是多面体的顶点。\n\n-   **顶点度：** 如果两个顶点 $v_1$（由有效集 $I_1$ 定义）和 $v_2$（由有效集 $I_2$ 定义）由多面体的一条边连接，则它们是相邻的。在计算上，这对应于它们的有效集恰好相差一个索引，即 $|I_1 \\setminus I_2| = 1$ 和 $|I_2 \\setminus I_1| = 1$。一个顶点的度是与它相邻的其他可行顶点的数量。\n\n-   **平均度：** 多面体 $P$ 的平均度计算为所有已识别顶点的度的算术平均值。\n\n**4. 实验设计与度量指标**\n\n实验在几个测试用例上进行，每个用例由参数 $(n, m, K, s)$ 定义。对于每个用例，生成并求解 $K$ 个随机QP实例。\n\n-   **实例生成：** 对于每个测试用例，随机数生成器以 $s$ 为种子。对于 $K$ 个实例中的每一个，我们生成：\n    -   一个随机矩阵 $R \\in \\mathbb{R}^{n \\times n}$，其元素来自标准正态分布。$Q$ 设置为 $Q = R^\\top R + 0.5 I_n$ 以确保其对称和正定。\n    -   一个向量 $c \\in \\mathbb{R}^n$ 和矩阵 $A \\in \\mathbb{R}^{m \\times n}$，其元素来自标准正态分布。\n    -   为确保初始点 $x_0 = 0$ 严格可行，$b$ 被构造为 $b = A x_0 + r = r$，其中 $r \\in \\mathbb{R}^m$ 的元素从 $[0.5, 1.5]$ 上的均匀分布中抽取。\n\n对于每个实例，计算以下内容：\n1.  执行沃尔夫方法期间的“添加”事件数量。\n2.  “移除”事件的数量。\n3.  相应可行多面体 $P$ 的平均度。\n\n最后，对于每个测试用例，将 $K$ 个实例的结果汇总以计算四个度量指标：\n1.  添加事件的平均数。\n2.  移除事件的平均数。\n3.  实例特定平均度的均值。\n4.  每个实例的添加事件比例与每个实例的平均度之间的皮尔逊相关系数。添加比例定义为，如果事件总数大于零，则为 $\\frac{\\text{adds}}{\\text{adds} + \\text{drops}}$，否则为 $0$。\n\n这种实验设置允许对有效集算法所采取的路径与可行区域顶点图的底层连通性之间的关系进行定量研究。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom itertools import combinations\n\ndef solve():\n    \"\"\"\n    Main function to run the computational experiment as specified.\n    It iterates through test cases, generates QP instances, solves them using\n    Wolfe's method, analyzes the corresponding polyhedron geometry, and\n    computes the required aggregate metrics.\n    \"\"\"\n    TOL = 1e-8\n    MAX_ITER = 1000\n    DELTA_Q = 0.5\n\n    def generate_qp_instance(n, m, rng):\n        \"\"\"Generates a random, strictly convex QP instance.\"\"\"\n        R = rng.standard_normal(size=(n, n))\n        Q = R.T @ R + DELTA_Q * np.eye(n)\n        c = rng.standard_normal(size=n)\n        A = rng.standard_normal(size=(m, n))\n        # b = A@x0 + r with x0=0. So b=r.\n        r = rng.uniform(0.5, 1.5, size=m)\n        b = r\n        return Q, c, A, b\n\n    def solve_qp_wolfe(Q, c, A, b, n, m):\n        \"\"\"Solves a QP using Wolfe's active-set method.\"\"\"\n        x = np.zeros(n)\n        W = set()\n        adds = 0\n        drops = 0\n\n        for _ in range(MAX_ITER):\n            g = Q @ x + c\n            W_list = sorted(list(W))\n            num_active = len(W_list)\n\n            p = np.zeros(n)\n            \n            try:\n                if num_active == 0:\n                    p = np.linalg.solve(Q, -g)\n                    lambda_W = np.array([])\n                else:\n                    A_W = A[W_list, :]\n                    kkt_mat_size = n + num_active\n                    kkt_mat = np.zeros((kkt_mat_size, kkt_mat_size))\n                    kkt_mat[:n, :n] = Q\n                    kkt_mat[:n, n:] = A_W.T\n                    kkt_mat[n:, :n] = A_W\n                    \n                    rhs = np.concatenate([-g, np.zeros(num_active)])\n                    sol = np.linalg.solve(kkt_mat, rhs)\n                    p = sol[:n]\n                    lambda_W = sol[n:]\n            except np.linalg.LinAlgError:\n                break # KKT matrix is singular, terminate this instance.\n\n            if np.linalg.norm(p)  TOL:\n                if num_active == 0 or np.all(lambda_W >= -TOL):\n                    break # Optimal solution found\n                else:\n                    j_drop = W_list[np.argmin(lambda_W)]\n                    W.remove(j_drop)\n                    drops += 1\n            else:\n                alpha = 1.0\n                blocking_k = -1\n                \n                A_p = A @ p\n                b_minus_Ax = b - (A @ x)\n\n                for i in range(m):\n                    if i not in W and A_p[i] > TOL:\n                        current_alpha = b_minus_Ax[i] / A_p[i]\n                        if current_alpha  alpha:\n                            alpha = current_alpha\n                            blocking_k = i\n                \n                x += alpha * p\n                \n                if blocking_k != -1: # True if alpha  1\n                    if blocking_k not in W: # Ensure no duplicates\n                        W.add(blocking_k)\n                        adds += 1\n        return adds, drops\n\n    def calculate_average_degree(A, b, n, m):\n        \"\"\"Calculates the average degree of the feasible polyhedron's vertices.\"\"\"\n        indices = list(range(m))\n        feasible_vertices = {}\n\n        for I_tuple in combinations(indices, n):\n            I = list(I_tuple)\n            A_I = A[I, :]\n            b_I = b[I]\n\n            if np.linalg.matrix_rank(A_I)  n:\n                continue\n\n            try:\n                x_v = np.linalg.solve(A_I, b_I)\n            except np.linalg.LinAlgError:\n                continue\n            \n            if np.all((A @ x_v - b) = TOL):\n                feasible_vertices[frozenset(I_tuple)] = x_v\n\n        if not feasible_vertices:\n            return 0.0\n\n        vertex_degrees = []\n        active_sets = list(feasible_vertices.keys())\n        active_sets_set = set(active_sets)\n\n        for I_v in active_sets:\n            degree = 0\n            non_active_indices = set(indices) - I_v\n            \n            for i_rem in I_v:\n                for j_add in non_active_indices:\n                    I_adj = (I_v - {i_rem}) | {j_add}\n                    if I_adj in active_sets_set:\n                        degree += 1\n            vertex_degrees.append(degree)\n            \n        return np.mean(vertex_degrees) if vertex_degrees else 0.0\n\n    def run_experiment(n, m, K, s):\n        \"\"\"Runs a full test case for a given set of parameters.\"\"\"\n        rng = np.random.default_rng(s)\n        \n        instance_adds = []\n        instance_drops = []\n        instance_avg_degrees = []\n        instance_add_proportions = []\n\n        for _ in range(K):\n            Q, c, A, b = generate_qp_instance(n, m, rng)\n            adds, drops = solve_qp_wolfe(Q, c, A, b, n, m)\n            avg_degree = calculate_average_degree(A, b, n, m)\n\n            instance_adds.append(adds)\n            instance_drops.append(drops)\n            instance_avg_degrees.append(avg_degree)\n            \n            total_events = adds + drops\n            add_prop = float(adds) / total_events if total_events > 0 else 0.0\n            instance_add_proportions.append(add_prop)\n        \n        mean_adds = np.mean(instance_adds)\n        mean_drops = np.mean(instance_drops)\n        mean_avg_degree = np.mean(instance_avg_degrees)\n        \n        add_props_arr = np.array(instance_add_proportions)\n        avg_degrees_arr = np.array(instance_avg_degrees)\n\n        correlation = 0.0\n        if K > 1 and np.std(add_props_arr) > TOL and np.std(avg_degrees_arr) > TOL:\n            corr_matrix = np.corrcoef(add_props_arr, avg_degrees_arr)\n            correlation = corr_matrix[0, 1]\n            if np.isnan(correlation):\n                correlation = 0.0\n\n        return [mean_adds, mean_drops, mean_avg_degree, correlation]\n\n    test_cases = [\n        # (n, m, K, s)\n        (2, 5, 25, 42),\n        (2, 8, 25, 7),\n        (3, 6, 20, 123),\n        (2, 3, 30, 99),\n    ]\n\n    all_results = []\n    for n, m, K, s in test_cases:\n        case_results = run_experiment(n, m, K, s)\n        all_results.append(case_results)\n\n    result_strs = [f\"[{','.join(f'{x:.7f}' for x in res)}]\" for res in all_results]\n    print(f\"[[{','.join(result_strs)}]]\")\n\nsolve()\n```"
        }
    ]
}