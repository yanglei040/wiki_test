{
    "hands_on_practices": [
        {
            "introduction": "理解抽象公式的最佳方式是将其应用于一个具体例子。本练习将引导您为一个小规模的4城市旅行商问题写出完整的Miller-Tucker-Zemlin (MTZ) 不等式集 。通过这个过程，您将亲身体验辅助变量 $u_i$ 如何像“顺序标签”一样工作，以防止形成孤立的子回路，从而加深对TSP整数规划模型的理解。",
            "id": "1411103",
            "problem": "对于一个包含 $n$ 个城市（标记为 $V = \\{1, 2, \\dots, n\\}$）的旅行商问题 (TSP)，其整数规划模型通常首先定义二元变量 $x_{ij}$，其中如果路径直接从城市 $i$ 前往城市 $j$，则 $x_{ij} = 1$，否则 $x_{ij} = 0$。基本的分配约束 $\\sum_{i \\in V, i \\neq j} x_{ij} = 1$ (对于所有 $j \\in V$) 和 $\\sum_{j \\in V, j \\neq i} x_{ij} = 1$ (对于所有 $i \\in V$) 确保每个城市都只被进入一次，也只被离开一次。然而，仅有这些约束并不能防止形成不连通的子回路。\n\n为强制形成单一的连通回路，一种常见的方法是 Miller-Tucker-Zemlin (MTZ) 公式。该方法引入了一组辅助连续变量 $u_i$（对于 $i \\in \\{2, 3, \\dots, n\\}$）。对于从指定起点城市1出发并返回的回路，这些 $u_i$ 变量可以解释为城市 $i$ 在访问城市序列中的位置。\n\n考虑一个有4个城市 $V = \\{1, 2, 3, 4\\}$ 的 TSP 问题，其中城市1是起点。辅助变量为 $u_2, u_3, u_4$。以下哪个选项代表了为保证此特定问题形成单一回路所需的完整且正确的 MTZ 约束集？\n\nA.\n$u_2 - u_3 + 3x_{23} \\le 2$\n$u_2 - u_4 + 3x_{24} \\le 2$\n$u_3 - u_2 + 3x_{32} \\le 2$\n$u_3 - u_4 + 3x_{34} \\le 2$\n$u_4 - u_2 + 3x_{42} \\le 2$\n$u_4 - u_3 + 3x_{43} \\le 2$\n且 $1 \\le u_i \\le 3$ 对于 $i \\in \\{2, 3, 4\\}$。\n\nB.\n$u_2 - u_3 + 3x_{23} \\le 2$\n$u_3 - u_4 + 3x_{34} \\le 2$\n$u_4 - u_2 + 3x_{42} \\le 2$\n且 $1 \\le u_i \\le 3$ 对于 $i \\in \\{2, 3, 4\\}$。\n\nC.\n$u_2 - u_3 + 4x_{23} \\le 3$\n$u_2 - u_4 + 4x_{24} \\le 3$\n$u_3 - u_2 + 4x_{32} \\le 3$\n$u_3 - u_4 + 4x_{34} \\le 3$\n$u_4 - u_2 + 4x_{42} \\le 3$\n$u_4 - u_3 + 4x_{43} \\le 3$\n且 $1 \\le u_i \\le 4$ 对于 $i \\in \\{2, 3, 4\\}$。\n\nD.\n$u_2 - u_3 + 3x_{23} \\le 2$\n$u_2 - u_4 + 3x_{24} \\le 2$\n$u_3 - u_2 + 3x_{32} \\le 2$\n$u_3 - u_4 + 3x_{34} \\le 2$\n$u_4 - u_2 + 3x_{42} \\le 2$\n$u_4 - u_3 + 3x_{43} \\le 2$\n且 $1 \\le u_i \\le 4$ 对于 $i \\in \\{1, 2, 3, 4\\}$。\n\nE.\n$u_i - u_j + 3x_{ij} \\le 2$ 对于所有 $i,j \\in \\{1, 2, 3, 4\\}$, $i \\neq j$。\n且 $1 \\le u_i \\le 3$ 对于 $i \\in \\{1, 2, 3, 4\\}$。",
            "solution": "我们回顾一下标准的 Miller-Tucker-Zemlin (MTZ) 子回路消除约束，该约束适用于一个有 $n$ 个城市且指定了起点（城市1）的 TSP 问题。引入连续辅助变量 $u_{i}$ (对于 $i \\in \\{2,3,\\dots,n\\}$)，其界限代表每个非起点城市的访问位置。一种常见且正确的 MTZ 形式是：\n- 界限：对于所有 $i \\in \\{2,3,\\dots,n\\}$，\n$$\n1 \\le u_{i} \\le n-1.\n$$\n- 成对的 MTZ 不等式：对于所有 $i,j \\in \\{2,3,\\dots,n\\}$ 且 $i \\neq j$，\n$$\nu_{i} - u_{j} + (n-1)\\,x_{ij} \\le n-2.\n$$\n\n理由如下：\n- 如果 $x_{ij} = 1$，则 $u_{i} - u_{j} \\le -1$，即 $u_{i} \\le u_{j} - 1$，这强制了沿选定弧的顺序一致性，从而禁止了非起点节点之间形成子回路。\n- 如果 $x_{ij} = 0$，则不等式变为 $u_{i} - u_{j} \\le n-2$，考虑到 $1 \\le u_{i} \\le n-1$ 和 $1 \\le u_{j} \\le n-1$，这个不等式是冗余的，因为可能的最大差值为 $(n-1) - 1 = n-2$。\n\n将其应用于 $n=4$ 且起点为城市1的特例，我们定义 $u_{2}, u_{3}, u_{4}$ 并得到：\n- 界限：\n$$\n1 \\le u_{i} \\le 3 \\quad \\text{for } i \\in \\{2,3,4\\}.\n$$\n- MTZ 不等式，适用于所有有序对 $(i,j)$，其中 $i,j \\in \\{2,3,4\\}$ 且 $i \\neq j$：\n$$\nu_{i} - u_{j} + 3\\,x_{ij} \\le 2.\n$$\n\n枚举这些有序对可得到以下六个不等式：\n$$\nu_{2} - u_{3} + 3x_{23} \\le 2,\\quad\nu_{2} - u_{4} + 3x_{24} \\le 2,\\quad\nu_{3} - u_{2} + 3x_{32} \\le 2,\n$$\n$$\nu_{3} - u_{4} + 3x_{34} \\le 2,\\quad\nu_{4} - u_{2} + 3x_{42} \\le 2,\\quad\nu_{4} - u_{3} + 3x_{43} \\le 2,\n$$\n以及 $1 \\le u_{i} \\le 3$ 对于 $i \\in \\{2,3,4\\}$。\n\n与选项比较：\n- 选项A与推导出的 $n=4$ 的 MTZ 形式完全匹配。\n- 选项B不完整（省略了几个必需的 $(i,j)$ 对）。\n- 选项C使用了备选的系数4和右侧值3，但错误地将 $u_{2},u_{3},u_{4}$ 的上界设为4而不是3，这与标准的位置解释 $1 \\le u_{i} \\le n-1$ 不符。\n- 选项D错误地对 $u_1$（在此变体中不属于 MTZ 变量）设置了界限，并使用了上界4。\n- 选项E错误地将城市1包含在 MTZ 不等式中，并且也对 $u_1$ 进行了界定，这两者都不是针对固定起点的标准 MTZ 构建方法的一部分。\n\n因此，针对此特定问题的完整且正确的约束集由选项A给出。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "为什么仅有度约束不足以定义一个合法的TSP回路？本练习通过一个精心设计的“桥梁”场景，直观地揭示了子回路问题的本质 。您将从一个具象的公路网络出发，计算真实世界的距离作为成本，然后目睹一个仅满足度约束的解如何分裂成两个独立的环路。这个过程将让您深刻体会到Dantzig-Fulkerson-Johnson (DFJ) 割集形式的子回路消除约束 (SECs) 为何是确保路线连通性的关键所在。",
            "id": "3193309",
            "problem": "考虑一个关于 $n=5$ 个城市的对称旅行商问题，其成本由以下带有一座桥的无向道路网络（一个连通的加权图）上的最短路径距离导出。顶点集为 $V=\\{1,2,3,4,5\\}$。边集和长度（单位：公里）如下：\n- 左簇：$\\{(1,2),(2,3),(1,3)\\}$，长度为 $c_{12}=4$，$c_{23}=4$，$c_{13}=7$。\n- 桥：$\\{(3,4)\\}$，长度为 $c_{34}=9$。这是左簇 $\\{1,2,3\\}$ 和右簇 $\\{4,5\\}$ 之间的唯一一条边。\n- 右簇：$\\{(4,5)\\}$，长度为 $c_{45}=5$。\n所有边都是无向的，长度为非负，并且在网络上满足三角不等式。\n\n在 $V$ 上的完全有向图上定义旅行商问题，对于所有 $i\\neq j$，弧成本 $c_{ij}$ 等于道路网络中从 $i$ 到 $j$ 的最短路径距离，且 $c_{ii}=0$。因此，成本 $c_{ij}$ 继承了上述网络所导出的度量。使用标准的有向分配公式，其中二元变量为 $x_{ij}\\in\\{0,1\\}$（对于 $i\\neq j$），并满足度等式约束 $\\sum_{j\\in V\\setminus\\{i\\}}x_{ij}=1$（对于所有 $i\\in V$）和 $\\sum_{i\\in V\\setminus\\{j\\}}x_{ij}=1$（对于所有 $j\\in V$）。初始时，不包含任何子回路消除约束（SEC）。\n\n任务：\n1. 计算由道路网络导出的所有点对之间的最短路径距离 $c_{ij}$。\n2. 展示一个满足度等式约束的可行（但不连通）的解，该解由 $\\{1,2,3\\}$ 上的一个3-环和 $\\{4,5\\}$ 上的一个2-环组成，并计算其在成本 $c_{ij}$ 下的目标值。\n3. 令 $S=\\{1,2,3\\}$。写出针对 $S$ 的有向公式的基于割的子回路消除约束（SEC），并解释为什么任务2中的不连通解违反了这些约束。简要说明为什么这些SEC对于强制实现跨桥的连通性至关重要。\n4. 通过从第一性原理出发，推理回路必须如何跨越桥梁并遍历每个簇，来确定在度量 $c_{ij}$ 下的5城市旅行商问题的最优哈密顿回路长度。你的最终答案必须是一个实数。\n\n以公里为单位表示最终的回路长度。将你的答案四舍五入到四位有效数字。",
            "solution": "问题陈述经检验，具有科学依据、问题明确且客观。这是一个组合优化中的标准问题，结构清晰，信息充分，可得出唯一解。\n\n首先，我们按顺序处理这四个任务。问题的核心是一个关于 $n=5$ 个城市的旅行商问题（TSP），其成本 $c_{ij}$ 定义为给定底层道路网络上的最短路径距离。\n\n**任务1：计算所有点对之间的最短路径距离 $c_{ij}$**\n\n道路网络由两个顶点簇 $A=\\{1,2,3\\}$ 和 $B=\\{4,5\\}$ 组成，通过一条单一的桥边 $(3,4)$ 连接。最短路径距离 $c_{ij}$ 计算如下：\n\n1.  **簇 A ($\\{1,2,3\\}$) 内部的距离：**\n    -   $c_{12}$：直接路径长度为 $4$。不存在更短的路径。所以，$c_{12}=c_{21}=4$。\n    -   $c_{23}$：直接路径长度为 $4$。不存在更短的路径。所以，$c_{23}=c_{32}=4$。\n    -   $c_{13}$：直接路径长度为 $7$。另一条路径 $1 \\to 2 \\to 3$ 的长度为 $c_{12}+c_{23} = 4+4=8$。最短路径是直接路径。所以，$c_{13}=c_{31}=7$。\n\n2.  **簇 B ($\\{4,5\\}$) 内部的距离：**\n    -   $c_{45}$：唯一的路径是长度为 $5$ 的直接边。所以，$c_{45}=c_{54}=5$。\n\n3.  **簇 A 和 B 之间的距离：**\n    从顶点 $i \\in A$ 到顶点 $j \\in B$ 的任何路径都必须经过桥 $(3,4)$。因此，最短路径距离是从 $i$ 到 $3$ 的最短距离、桥的长度以及从 $4$ 到 $j$ 的最短距离之和。\n    通用公式为 $c_{ij} = c_{i3} + c_{34} + c_{4j}$，其中 $i \\in A, j \\in B$。\n    -   $c_{14} = c_{13} + c_{34} = 7 + 9 = 16$。\n    -   $c_{15} = c_{13} + c_{34} + c_{45} = 7 + 9 + 5 = 21$。\n    -   $c_{24} = c_{23} + c_{34} = 4 + 9 = 13$。\n    -   $c_{25} = c_{23} + c_{34} + c_{45} = 4 + 9 + 5 = 18$。\n    -   $c_{34} = 9$（桥本身）。\n    -   $c_{35} = c_{34} + c_{45} = 9 + 5 = 14$。\n    由于底层无向图的对称性，$c_{ji} = c_{ij}$。\n\nTSP的完整对称成本矩阵 $C = (c_{ij})$ 为：\n$$\nC = \\begin{pmatrix}\n0   4  7  16  21 \\\\\n4   0  4  13  18 \\\\\n7   4  0  9   14 \\\\\n16  13  9  0   5 \\\\\n21  18  14  5  0\n\\end{pmatrix}\n$$\n\n**任务2：展示一个可行但不连通的解**\n\n我们被要求找到一个满足分配问题松弛（仅度约束）的可行解，该解由 $\\{1,2,3\\}$ 上的一个3-环和 $\\{4,5\\}$ 上的一个2-环组成。\n-   对于3-环，我们可以选择回路 $1 \\to 2 \\to 3 \\to 1$。对应的二元变量为 $x_{12}=1$，$x_{23}=1$ 和 $x_{31}=1$。此子回路的成本为 $c_{12} + c_{23} + c_{31} = 4 + 4 + 7 = 15$。\n-   对于2-环，回路必须是 $4 \\to 5 \\to 4$。对应的二元变量为 $x_{45}=1$ 和 $x_{54}=1$。此子回路的成本为 $c_{45} + c_{54} = 5 + 5 = 10$。\n\n完整的不连通解由非零变量集合 $\\{x_{12}, x_{23}, x_{31}, x_{45}, x_{54}\\}$ 给出。这组变量满足每个顶点 $i \\in V$ 的度约束：$\\sum_j x_{ij} = 1$ 和 $\\sum_j x_{ji} = 1$。该解的总目标值为子回路成本之和：$15 + 10 = 25$。\n\n**任务3：子回路消除约束（SEC）**\n\n对于有向TSP公式，基于割的SEC规定，对于任意非空真子集 $S \\subset V$，必须至少有一条弧离开 $S$。约束为：\n$$\n\\sum_{i \\in S, j \\in V \\setminus S} x_{ij} \\geq 1\n$$\n对于特定集合 $S=\\{1,2,3\\}$，我们有 $V \\setminus S = \\{4,5\\}$，SEC变为：\n$$\n\\sum_{i \\in \\{1,2,3\\}, j \\in \\{4,5\\}} x_{ij} = x_{14} + x_{15} + x_{24} + x_{25} + x_{34} + x_{35} \\geq 1\n$$\n任务2中的不连通解的非零变量仅对应于端点均在 $S$ 内部（即 $x_{12}, x_{23}, x_{31}$）或均在 $V \\setminus S$ 内部（即 $x_{45}, x_{54}$）的弧。所有表示从 $S$ 跨越到 $V \\setminus S$ 的弧的变量均为零：$x_{14}=x_{15}=x_{24}=x_{25}=x_{34}=x_{35}=0$。\n将这些值代入SEC得到：\n$$\n0 + 0 + 0 + 0 + 0 + 0 = 0\n$$\n由于 $0  1$，该约束被违反。\n\n这些SEC至关重要，因为它们强制实现连通性。集合 $S$ 对应于城市的左簇，该簇仅通过底层网络中的桥与右簇 $V \\setminus S$ 连接。通过要求至少有一条弧从 $S$ 指向 $V \\setminus S$，SEC确保任何有效回路都必须“跨越桥梁”，从而防止解分解为每个簇内的独立、不连通的子回路。\n\n**任务4：确定最优哈密顿回路长度**\n\n在 $V=\\{1,2,3,4,5\\}$ 上的哈密顿回路必须访问每个城市。鉴于城市被划分为簇 $A=\\{1,2,3\\}$ 和 $B=\\{4,5\\}$，任何回路都必须包含一条贯穿 $A$ 中所有城市的路径、一条贯穿 $B$ 中所有城市的路径，以及两条连接这些路径端点的“跨越”弧，以形成一个单一的环。\n\n总回路长度 $L$ 可分解为：\n$L = (\\text{A中的哈密顿路径长度}) + (\\text{B中的哈密顿路径长度}) + (\\text{两条跨越弧的成本})$。\n\n1.  **B 中的路径：** 路径必须连接顶点 $4$ 和 $5$。唯一的此类路径是 $4 \\leftrightarrow 5$，长度为 $c_{45}=5$。端点是 $\\{4,5\\}$。\n\n2.  **A 中的路径：** 我们必须找到一条贯穿 $\\{1,2,3\\}$ 的哈密顿路径的长度。路径的结构有三种可能性（不考虑反向）：\n    -   路径 $1-2-3$：长度 $c_{12} + c_{23} = 4 + 4 = 8$。端点是 $\\{1,3\\}$。\n    -   路径 $2-1-3$：长度 $c_{21} + c_{13} = 4 + 7 = 11$。端点是 $\\{2,3\\}$。\n    -   路径 $1-3-2$：长度 $c_{13} + c_{32} = 7 + 4 = 11$。端点是 $\\{1,2\\}$。\n\n3.  **连接路径：** 我们必须将 $A$ 中所选路径的端点与 $B$ 中路径的端点 $\\{4,5\\}$ 连接起来，以最小化总长度。设 $A$ 中路径的端点为 $\\{u,v\\}$。跨越弧的成本为 $\\min(c_{u4}+c_{v5}, c_{u5}+c_{v4})$。\n\n让我们评估每种情况下的总回路长度：\n\n-   **情况A1（路径 $1-2-3$）：** A中的路径长度为 $8$，端点为 $\\{1,3\\}$。\n    -   跨越成本：$\\min(c_{14}+c_{35}, c_{15}+c_{34}) = \\min(16+14, 21+9) = \\min(30,30) = 30$。\n    -   总回路长度：$8\\ (\\text{A中路径}) + 5\\ (\\text{B中路径}) + 30\\ (\\text{跨越}) = 43$。\n    -   一个示例回路是 $3 \\to 2 \\to 1 \\to 5 \\to 4 \\to 3$，成本为 $c_{32}+c_{21}+c_{15}+c_{54}+c_{43} = 4+4+21+5+9 = 43$。\n\n-   **情况A2（路径 $2-1-3$）：** A中的路径长度为 $11$，端点为 $\\{2,3\\}$。\n    -   跨越成本：$\\min(c_{24}+c_{35}, c_{25}+c_{34}) = \\min(13+14, 18+9) = \\min(27,27) = 27$。\n    -   总回路长度：$11\\ (\\text{A中路径}) + 5\\ (\\text{B中路径}) + 27\\ (\\text{跨越}) = 43$。\n    -   一个示例回路是 $2 \\to 1 \\to 3 \\to 5 \\to 4 \\to 2$，成本为 $c_{21}+c_{13}+c_{35}+c_{54}+c_{42} = 4+7+14+5+13=43$。\n\n-   **情况A3（路径 $1-3-2$）：** A中的路径长度为 $11$，端点为 $\\{1,2\\}$。\n    -   跨越成本：$\\min(c_{14}+c_{25}, c_{15}+c_{24}) = \\min(16+18, 21+13) = \\min(34,34) = 34$。\n    -   总回路长度：$11\\ (\\text{A中路径}) + 5\\ (\\text{B中路径}) + 34\\ (\\text{跨越}) = 50$。\n\n比较所有情况的总长度（$43, 43, 50$），最小长度为 $43$。最优哈密顿回路长度为 $43$ 公里。四舍五入到四位有效数字得到 $43.00$ 公里。",
            "answer": "$$\\boxed{43.00}$$"
        },
        {
            "introduction": "解决了子回路问题后，下一个挑战是如何求解TSP整数规划。虽然直接求解是NP-难的，但我们可以通过求解其线性规划（LP）松弛来获得问题最优解的一个有效下界。本练习将指导您通过编程实践，计算TSP的指派问题松弛下界 ，这是分支定界等精确算法中的核心步骤。通过这个练习，您将把理论模型转化为可计算的工具，体验优化理论在算法设计中的强大威力。",
            "id": "3248052",
            "problem": "您需要使用指派松弛方法，为旅行商问题（TSP）计算一个线性规划下界。考虑一个有 $n$ 个城市的有向 TSP 问题，其成本矩阵为 $C = (c_{ij})$，其中 $c_{ij}$ 是从城市 $i$到城市 $j$的成本。标准的整数规划模型为 $i \\neq j$ 引入决策变量 $x_{ij} \\in \\{0,1\\}$ 且 $x_{ii} = 0$，其目标是在每个城市都有一个出边和一个入边以及满足子回路消除约束的条件下，最小化路径成本。指派线性规划（LP）松弛去掉了整数约束和子回路消除约束，只保留了双随机度约束。形式上，该 LP 松弛为：\n$$\n\\min_{X} \\sum_{i=1}^{n} \\sum_{j=1}^{n} c_{ij}\\, x_{ij}\n$$\n约束条件为\n$$\n\\sum_{j=1}^{n} x_{ij} = 1 \\quad \\text{for all } i \\in \\{1,\\dots,n\\}, \\qquad\n\\sum_{i=1}^{n} x_{ij} = 1 \\quad \\text{for all } j \\in \\{1,\\dots,n\\},\n$$\n且\n$$\n0 \\le x_{ij} \\le 1 \\quad \\text{for all } i,j \\in \\{1,\\dots,n\\}, \\qquad x_{ii} = 0 \\quad \\text{for all } i.\n$$\n该松弛为最优 TSP 路径长度提供了一个下界，因为任何哈密顿回路都是此 LP 的一个可行点。根据 Birkhoff–von Neumann 定理，由双随机约束定义的可行域的极点对应于置换矩阵。因此，求解该 LP 等价于寻找一个最小成本指派（城市到后继者的一对一映射），这可以通过匈牙利方法等算法来解决。\n\n您的任务是实现一个程序，给定几个测试成本矩阵，通过求解每个矩阵的最小成本指派问题来计算 LP 松弛下界。为禁止自环 $x_{ii}$，在对角线元素 $c_{ii}$ 上使用一个巨大的惩罚值 $M = 10^6$；即设置 $c_{ii} = M$ 以在最优指派中强制 $x_{ii} = 0$。\n\n测试套件：\n- 测试用例 1（四个位于单位正方形顶点的城市的对称欧几里得距离）：城市坐标为 $(0,0)$, $(1,0)$, $(1,1)$, $(0,1)$，当 $i \\neq j$ 时，$c_{ij}$ 等于从城市 $i$到 $j$的欧几里得距离，且 $c_{ii} = M$。\n- 测试用例 2（非对称五城市实例）：\n$$\nC =\n\\begin{bmatrix}\nM  3  1  5  9 \\\\\n2  M  6  4  3 \\\\\n7  5  M  2  4 \\\\\n3  1  5  M  2 \\\\\n8  2  6  3  M\n\\end{bmatrix}.\n$$\n- 测试用例 3（非对角线元素相等的三城市实例）：\n$$\nC =\n\\begin{bmatrix}\nM  2  2 \\\\\n2  M  2 \\\\\n2  2  M\n\\end{bmatrix}.\n$$\n- 测试用例 4（两城市边界情况）：\n$$\nC =\n\\begin{bmatrix}\nM  3 \\\\\n5  M\n\\end{bmatrix}.\n$$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个结果都必须是浮点数，四舍五入到三位小数，并按照上面列出的测试用例的顺序排列。例如：\n$$\n[\\text{bound}_{1},\\text{bound}_{2},\\text{bound}_{3},\\text{bound}_{4}]\n$$\n结果不涉及物理单位，也不涉及角度。结果为浮点数，代表了 LP 松弛得到的下界。",
            "solution": "用户在线性规划和组合优化领域提供了一个定义明確的问题。任务是通过求解旅行商问题（TSP）的指派松弛，为给定的几个成本矩阵计算其下界。\n\n### 第 1 步：问题验证\n\n根据既定标准对问题陈述进行严格评估。\n\n**提取的已知条件：**\n- **问题：** 通过求解指派松弛来计算有向 TSP 的下界。\n- **LP 公式（指派松弛）：**\n  $$\n  \\min_{X} \\sum_{i=1}^{n} \\sum_{j=1}^{n} c_{ij}\\, x_{ij}\n  $$\n  约束条件：\n  $$\n  \\sum_{j=1}^{n} x_{ij} = 1 \\quad \\text{for all } i \\in \\{1,\\dots,n\\}\n  $$\n  $$\n  \\sum_{i=1}^{n} x_{ij} = 1 \\quad \\text{for all } j \\in \\{1,\\dots,n\\}\n  $$\n  $$\n  0 \\le x_{ij} \\le 1 \\quad \\text{for all } i,j \\in \\{1,\\dots,n\\}\n  $$\n  $$\n  x_{ii} = 0 \\quad \\text{for all } i\n  $$\n- **方法论：** 问题陈述指出，此 LP 等价于一个最小成本指派问题，可通过匈牙利方法等算法求解。约束 $x_{ii}=0$ 将通过将对角线成本 $c_{ii}$ 设置为一个巨大的惩罚值 $M=10^6$ 来强制实现。\n- **测试用例：**\n  1. 一个 $4 \\times 4$ 的对称成本矩阵，由单位正方形顶点之间的欧几里得距离派生而来，其中 $c_{ii}=M$。\n  2. 一个 $5 \\times 5$ 的非对称成本矩阵。\n  3. 一个 $3 \\times 3$ 的对称成本矩阵。\n  4. 一个 $2 \\times 2$ 的非对称成本矩阵。\n- **输出格式：** 单行输出，包含一个用方括号括起来的、四舍五入到三位小数的浮点数逗号分隔列表。\n\n**验证结果：**\n- **科学依据：** 该问题在科学和数学上是合理的。TSP 的指派松弛是运筹学中的一种标准技术。所提供的公式是作为线性规划的指派问题的正确定义。对 Birkhoff-von Neumann 定理的引用以及与最小成本指派（或二分图中的最小权重完美匹配）的等价性是标准的理论结果。使用惩罚项来禁止自环是一种常见且有效的建模实践。\n- **良定性：** 该问题是良定的。对于任何给定的成本矩阵，指派问题都有一个唯一、稳定且有意义的最优成本。\n- **客观性：** 该问题使用精确的数学语言进行客观陈述，没有歧义或主观论断。\n- **完整性与一致性：** 提供了所有必要的数据（成本矩阵、惩罚值）和定义。问题是自足的，没有矛盾。\n\n**结论：** 该问题是有效的。它是数值优化领域的一个标准计算问题。\n\n### 第 2 步：解决方案设计\n\n核心任务是解决最小成本指派问题。由于执行环境限制禁止使用 `scipy` 等库，因此需要从头开始实现一个合适的算法。匈牙利算法是解决此问题的经典方法，我们将实现该算法。\n\n匈牙利算法作用于成本矩阵，包括以下几个阶段：\n1.  **归约：** 从每行减去其最小值，然后从每列减去其最小值，以在矩阵中创建零项，而不改变最优指派。减去的值的总和构成了总成本的一部分。\n2.  **指派：** 在对应于归约后成本矩阵中零值项的二分图中寻找最大匹配。一种标准方法是使用增广路径，可以通过深度优先搜索（DFS）或广度优先搜索（BFS）找到。\n3.  **最优性检查：** 如果最大匹配的大小等于矩阵维度 $n$，则已在零值项中找到最优指派。总成本是*原始*矩阵中处于最优指派位置的成本之和。\n4.  **矩阵更新：** 如果匹配的大小不为 $n$，则必须更新成本矩阵以创造新的零成本指派机会。这包括：\n    a. 找到覆盖矩阵中所有零所需的最少划线数（水平或垂直）。根据 König's theorem，这个数量等于最大匹配的大小。这组划线可以从增广路径搜索状态中确定。\n    b. 在所有未被任何线条覆盖的元素中，找出最小值 $\\delta$。\n    c. 从所有未被覆盖的元素中减去 $\\delta$，并将其加到所有被两条线覆盖的元素（交叉点）上。\n    d. 使用更新后的矩阵从第 2 步重复。\n\n实现将包括一个主函数来协调这些步骤，以及一个用于基于 DFS 的最大匹配搜索的辅助函数。这个过程保证会终止并找到最优指派。\n\n完整的解决方案将被封装在一个 Python 脚本中，该脚本会设置每个测试用例，调用已实现的匈牙利算法求解器，并按规定格式化输出。\n\n- **测试用例 1：** $4 \\times 4$ 的成本矩阵将根据四个点 $(0,0), (1,0), (1,1), (0,1)$ 之间的欧几里得距离以编程方式生成。对角线将被设置为 $M=10^6$。预期的最小成本为 $4.0$，对应于围绕正方形周边的路径。\n- **测试用例 2：** 将使用提供的 $5 \\times 5$ 非对称矩阵。找到的最小成本指派为 $9$。\n- **测试用例 3：** 将使用 $3 \\times 3$ 矩阵。任何有效的指派都会形成一个总成本为 $2+2+2 = 6$ 的 3-循环。\n- **测试用例 4：** 将使用 $2 \\times 2$ 矩阵。唯一有效的指派是成本为 $3+5=8$ 的 2-循环。\n\n最终代码将计算这些值并以要求的格式呈现它们。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef _dfs_match(u, adj, match, visited_v):\n    \"\"\"\n    A helper depth-first search function to find an augmenting path in a bipartite graph.\n    This is used to find the maximum matching.\n\n    Args:\n        u (int): The current vertex in the first partition (U, representing rows).\n        adj (list[list[int]]): Adjacency list where adj[u] contains neighbors of u in V.\n        match (np.ndarray): An array where match[v] = u if (u, v) is in the current matching.\n        visited_v (np.ndarray): A boolean array tracking visited vertices in the second partition (V, columns) during the current DFS.\n\n    Returns:\n        bool: True if an augmenting path is found, False otherwise.\n    \"\"\"\n    for v in adj[u]:\n        if not visited_v[v]:\n            visited_v[v] = True\n            if match[v] == -1 or _dfs_match(match[v], adj, match, visited_v):\n                match[v] = u\n                return True\n    return False\n\ndef _solve_assignment_problem(cost_matrix):\n    \"\"\"\n    Solves the assignment problem (minimum weight perfect matching in a bipartite graph)\n    using the Hungarian algorithm. This implementation is necessary as external libraries\n    like scipy.optimize.linear_sum_assignment are not permitted.\n\n    Args:\n        cost_matrix (np.ndarray): The n x n cost matrix.\n\n    Returns:\n        float: The total cost of the optimal assignment.\n    \"\"\"\n    n = cost_matrix.shape[0]\n    original_cost_matrix = cost_matrix.copy()\n    cost = cost_matrix.copy()\n\n    # Step 1: Row and column reduction\n    cost -= np.min(cost, axis=1)[:, np.newaxis]\n    cost -= np.min(cost, axis=0)[np.newaxis, :]\n\n    while True:\n        # Step 2: Find a maximum matching in the graph of zero-cost edges.\n        adj = [[] for _ in range(n)]\n        for r in range(n):\n            for c in range(n):\n                if np.isclose(cost[r, c], 0):\n                    adj[r].append(c)\n\n        match = np.full(n, -1, dtype=int)  # match[col] = row\n        match_size = 0\n        for r in range(n):\n            visited_v = np.zeros(n, dtype=bool)\n            if _dfs_match(r, adj, match, visited_v):\n                match_size += 1\n\n        # Step 3: Check for optimality.\n        if match_size == n:\n            assignment_cols = np.arange(n)\n            assignment_rows = match[assignment_cols]\n            total_cost = original_cost_matrix[assignment_rows, assignment_cols].sum()\n            return total_cost\n\n        # Step 4: Update cost matrix if matching is not perfect.\n        # Find minimum line cover using the state of the matching algorithm.\n        matched_rows_mask = np.isin(np.arange(n), match)\n        unmatched_rows = np.where(~matched_rows_mask)[0]\n        \n        reachable_rows = set(unmatched_rows)\n        reachable_cols = set()\n\n        q = list(unmatched_rows)\n        head = 0\n        while head  len(q):\n            u = q[head]\n            head += 1\n            for v in adj[u]:\n                if v not in reachable_cols:\n                    reachable_cols.add(v)\n                    u_partner = match[v]\n                    if u_partner != -1 and u_partner not in reachable_rows:\n                        reachable_rows.add(u_partner)\n                        q.append(u_partner)\n        \n        # Uncovered elements are in reachable rows and unreachable columns.\n        unreachable_cols = set(range(n)) - reachable_cols\n        rows_idx = np.array(list(reachable_rows))\n        cols_idx = np.array(list(unreachable_cols))\n\n        if len(rows_idx) == 0 or len(cols_idx) == 0:\n            # This case implies no uncovered elements, which should not happen\n            # if the matching is not yet of size n. Can indicate an issue\n            # with floating point precision. For this problem's scope, we assume\n            # a non-zero minimum will always be found.\n            continue\n\n        min_val = np.min(cost[np.ix_(rows_idx, cols_idx)])\n\n        # Subtract min_val from all uncovered elements.\n        cost[np.ix_(rows_idx, cols_idx)] -= min_val\n        \n        # Add min_val to all double-covered elements (unreachable rows, reachable cols).\n        unreachable_rows = set(range(n)) - reachable_rows\n        rows_to_add_idx = np.array(list(unreachable_rows))\n        cols_to_add_idx = np.array(list(reachable_cols))\n        \n        if len(rows_to_add_idx) > 0 and len(cols_to_add_idx) > 0:\n            cost[np.ix_(rows_to_add_idx, cols_to_add_idx)] += min_val\n\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, compute the LP relaxation lower bound for each,\n    and print the results in the specified format.\n    \"\"\"\n    M = 1e6\n    \n    # Test Case 1: Symmetric Euclidean distances on a unit square\n    coords = np.array([[0, 0], [1, 0], [1, 1], [0, 1]])\n    n1 = 4\n    c1 = np.zeros((n1, n1))\n    for i in range(n1):\n        for j in range(n1):\n            if i == j:\n                c1[i, j] = M\n            else:\n                c1[i, j] = np.linalg.norm(coords[i] - coords[j])\n    \n    # Test Case 2: Asymmetric 5-city instance\n    c2 = np.array([\n        [M, 3, 1, 5, 9],\n        [2, M, 6, 4, 3],\n        [7, 5, M, 2, 4],\n        [3, 1, 5, M, 2],\n        [8, 2, 6, 3, M]\n    ])\n    \n    # Test Case 3: 3-city instance with ties\n    c3 = np.array([\n        [M, 2, 2],\n        [2, M, 2],\n        [2, 2, M]\n    ])\n    \n    # Test Case 4: 2-city boundary case\n    c4 = np.array([\n        [M, 3],\n        [5, M]\n    ])\n    \n    test_cases = [c1, c2, c3, c4]\n    \n    results = []\n    for cost_matrix in test_cases:\n        bound = _solve_assignment_problem(cost_matrix)\n        results.append(bound)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.3f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}