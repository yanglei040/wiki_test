{
    "hands_on_practices": [
        {
            "introduction": "线性最小二乘法在将数学模型与实验数据拟合方面非常强大。这个练习将带你完成一个典型的工程任务：传感器校准。你将使用正规方程为一组温度和电压测量数据找到最佳拟合线性模型，这个过程是许多科学数据分析任务的核心。",
            "id": "2218047",
            "problem": "一位工程师正在校准一种新型热传感器。传感器的输出电压 $V$ 被假设为环境温度 $T$ 的线性函数。该关系由方程 $V(T) = c_0 + c_1 T$ 建模，其中 $c_0$ 和 $c_1$ 是待确定的校准常数。为求得这些常数，在受控环境中进行了四次测量：\n\n*   在温度为 $T=10$ 摄氏度时，测得电压为 $V=2.6$ 伏特。\n*   在温度为 $T=20$ 摄氏度时，测得电压为 $V=3.4$ 伏特。\n*   在温度为 $T=30$ 摄氏度时，测得电压为 $V=4.7$ 伏特。\n*   在温度为 $T=40$ 摄氏度时，测得电压为 $V=5.4$ 伏特。\n\n参数 $c_0$ 和 $c_1$ 的确定方式是，使得测量电压与线性模型预测电压之差的平方和最小。设得到的最佳拟合直线为 $\\hat{V}(T) = \\hat{c}_0 + \\hat{c}_1 T$。\n\n你的任务是计算残差向量的欧几里得范数，其中残差向量的分量是单个测量电压与这条最佳拟合直线预测的相应电压之间的差值。\n\n最终答案以伏特为单位，并四舍五入到三位有效数字。",
            "solution": "我们将电压建模为温度的线性函数 $V(T)=c_{0}+c_{1}T$，并使用四组测量数据 $(T_{i},V_{i})=(10,2.6),(20,3.4),(30,4.7),(40,5.4)$ 通过最小二乘法确定 $(\\hat{c}_{0},\\hat{c}_{1})$。设设计矩阵为 $X=\\begin{pmatrix}1  & 10 \\\\ 1  & 20 \\\\ 1  & 30 \\\\ 1  & 40\\end{pmatrix}$，观测向量为 $\\boldsymbol{V}=\\begin{pmatrix}2.6 \\\\ 3.4 \\\\ 4.7 \\\\ 5.4\\end{pmatrix}$。最小二乘估计满足\n$$\n\\begin{pmatrix}\\hat{c}_{0} \\\\ \\hat{c}_{1}\\end{pmatrix}=(X^{T}X)^{-1}X^{T}\\boldsymbol{V},\n$$\n等价于正规方程\n$$\n\\begin{pmatrix}n  & \\sum T_{i} \\\\ \\sum T_{i}  & \\sum T_{i}^{2}\\end{pmatrix}\\begin{pmatrix}\\hat{c}_{0} \\\\ \\hat{c}_{1}\\end{pmatrix}=\\begin{pmatrix}\\sum V_{i} \\\\ \\sum T_{i}V_{i}\\end{pmatrix}.\n$$\n计算各项和：$n=4$，$\\sum T_{i}=10+20+30+40=100$，$\\sum T_{i}^{2}=10^{2}+20^{2}+30^{2}+40^{2}=3000$，$\\sum V_{i}=2.6+3.4+4.7+5.4=16.1$，以及 $\\sum T_{i}V_{i}=10\\cdot 2.6+20\\cdot 3.4+30\\cdot 4.7+40\\cdot 5.4=451$。因此我们求解\n$$\n\\begin{pmatrix}4  & 100 \\\\ 100  & 3000\\end{pmatrix}\\begin{pmatrix}\\hat{c}_{0} \\\\ \\hat{c}_{1}\\end{pmatrix}=\\begin{pmatrix}16.1 \\\\ 451\\end{pmatrix}.\n$$\n行列式为 $4\\cdot 3000-100\\cdot 100=2000$，所以\n$$\n\\hat{c}_{0}=\\frac{3000\\cdot 16.1-100\\cdot 451}{2000}=1.6,\\quad \\hat{c}_{1}=\\frac{-100\\cdot 16.1+4\\cdot 451}{2000}=0.097.\n$$\n因此，最佳拟合直线为 $\\hat{V}(T)=1.6+0.097\\,T$。\n\n计算在四个温度下的残差 $r_{i}=V_{i}-\\hat{V}(T_{i})$：\n$$\n\\hat{V}(10)=1.6+0.097\\cdot 10=2.57,\\quad r_{1}=2.6-2.57=0.03,\n$$\n$$\n\\hat{V}(20)=1.6+0.097\\cdot 20=3.54,\\quad r_{2}=3.4-3.54=-0.14,\n$$\n$$\n\\hat{V}(30)=1.6+0.097\\cdot 30=4.51,\\quad r_{3}=4.7-4.51=0.19,\n$$\n$$\n\\hat{V}(40)=1.6+0.097\\cdot 40=5.48,\\quad r_{4}=5.4-5.48=-0.08.\n$$\n残差向量 $\\boldsymbol{r}$ 的欧几里得范数为\n$$\n\\|\\boldsymbol{r}\\|_{2}=\\sqrt{\\sum_{i=1}^{4}r_{i}^{2}}=\\sqrt{(0.03)^{2}+(-0.14)^{2}+(0.19)^{2}+(-0.08)^{2}}=\\sqrt{0.063}.\n$$\n计算平方根并四舍五入到三位有效数字，得到\n$$\n\\|\\boldsymbol{r}\\|_{2}\\approx 0.251.\n$$\n该值的单位是伏特，因为每个残差都是一个电压差。",
            "answer": "$$\\boxed{0.251}$$"
        },
        {
            "introduction": "在掌握了直线拟合之后，我们可以将最小二乘法的应用推广到更高维度。本练习模拟了一个材料科学中的场景，你需要为板材表面的温度分布拟合一个最佳平面模型。通过解决这个问题，你将看到正规方程法如何无缝地从二维扩展到三维，从而处理具有多个自变量的模型。",
            "id": "2218050",
            "problem": "一位材料科学家正在研究一种新开发合金的热性能。他们将一块该材料的矩形板放置在受控环境中，并测量板表面上四个不同位置 $(x, y)$ 的温度 $T$。假设测量所用的长度和温度单位系统是一致的，但未具体说明。该科学家希望找到板上温度分布的最佳线性模型，其形式为 $T(x,y) = c_1 x + c_2 y + c_3$。\n\n收集到的四个数据点 $(x, y, T)$ 如下：\n- (1, 1, 3.5)\n- (2, -1, 1.2)\n- (-1, 2, 4.0)\n- (0, -2, -0.5)\n\n使用线性最小二乘法，确定最佳拟合平面的系数 $c_1, c_2,$ 和 $c_3$。请按此特定顺序提供 $c_1, c_2,$ 和 $c_3$ 的值。您的最终答案应四舍五入到三位有效数字。",
            "solution": "我们寻求模型 $T(x,y)=c_{1}x+c_{2}y+c_{3}$ 对四个数据点 $(x_{i},y_{i},T_{i})$ 的最小二乘拟合。令\n$$\nA=\\begin{pmatrix}\n1  & 1  & 1\\\\\n2  & -1  & 1\\\\\n-1  & 2  & 1\\\\\n0  & -2  & 1\n\\end{pmatrix},\\quad\n\\mathbf{c}=\\begin{pmatrix}c_{1}\\\\ c_{2}\\\\ c_{3}\\end{pmatrix},\\quad\n\\mathbf{b}=\\begin{pmatrix}3.5\\\\ 1.2\\\\ 4.0\\\\ -0.5\\end{pmatrix}.\n$$\n最小二乘解满足正规方程 $A^{\\top}A\\,\\mathbf{c}=A^{\\top}\\mathbf{b}$。计算所需的各分量：\n$$\n\\sum x_{i}=2,\\quad \\sum y_{i}=0,\\quad \\sum x_{i}^{2}=6,\\quad \\sum y_{i}^{2}=10,\\quad \\sum x_{i}y_{i}=-3,\n$$\n$$\n\\sum x_{i}T_{i}=1.9,\\quad \\sum y_{i}T_{i}=11.3,\\quad \\sum T_{i}=8.2.\n$$\n因此\n$$\nA^{\\top}A=\\begin{pmatrix}6  & -3  & 2\\\\ -3  & 10  & 0\\\\ 2  & 0  & 4\\end{pmatrix},\\quad\nA^{\\top}\\mathbf{b}=\\begin{pmatrix}1.9\\\\ 11.3\\\\ 8.2\\end{pmatrix}.\n$$\n这得出了以下线性方程组\n$$\n\\begin{cases}\n6c_{1}-3c_{2}+2c_{3}=1.9,\\\\\n-3c_{1}+10c_{2}=11.3,\\\\\n2c_{1}+4c_{3}=8.2.\n\\end{cases}\n$$\n由第三个方程，$c_{1}+2c_{3}=4.1$，所以 $c_{1}=4.1-2c_{3}$。代入第二个方程得到 $-3(4.1-2c_{3})+10c_{2}=11.3$，简化为 $5c_{2}+3c_{3}=11.8$。将 $c_{1}=4.1-2c_{3}$ 代入第一个方程得到 $3c_{2}+10c_{3}=22.7$。求解方程组\n$$\n\\begin{cases}\n5c_{2}+3c_{3}=11.8,\\\\\n3c_{2}+10c_{3}=22.7\n\\end{cases}\n$$\n解得\n$$\nc_{2}=\\frac{11.8\\cdot 10-3\\cdot 22.7}{41}=\\frac{49.9}{41}=\\frac{499}{410},\\quad\nc_{3}=\\frac{5\\cdot 22.7-3\\cdot 11.8}{41}=\\frac{78.1}{41}=\\frac{781}{410}.\n$$\n然后\n$$\nc_{1}=4.1-2c_{3}=\\frac{41}{10}-2\\cdot\\frac{781}{410}=\\frac{1681-1562}{410}=\\frac{119}{410}.\n$$\n因此，精确的系数为\n$$\nc_{1}=\\frac{119}{410},\\quad c_{2}=\\frac{499}{410},\\quad c_{3}=\\frac{781}{410}.\n$$\n四舍五入到三位有效数字：\n$$\nc_{1}\\approx 0.290,\\quad c_{2}\\approx 1.22,\\quad c_{3}\\approx 1.90.\n$$",
            "answer": "$$\\boxed{\\begin{pmatrix}0.290 & 1.22 & 1.90\\end{pmatrix}}$$"
        },
        {
            "introduction": "虽然正规方程 $A^{\\top} A \\mathbf{x} = A^{\\top} \\mathbf{b}$ 在理论上为最小二乘问题提供了优雅的封闭解，但其在实践中的数值稳定性却是一个必须正视的挑战。本练习是一个动手编程任务，它将引导你亲手实现基于正规方程的求解器，并用它处理一个以病态著称的希尔伯特矩阵。通过将你的结果与更稳健的QR分解法进行对比，你将深刻理解为何直接构建$A^{\\top} A$矩阵会急剧放大计算误差，并认识到在实际科学计算中选择数值稳定算法的至关重要性。",
            "id": "3257364",
            "problem": "实现一个完整的程序，该程序从第一性原理出发，推导并使用正规方程方法求解线性最小二乘问题，并对比其在由 Hilbert 矩阵构建的良态和病态实例上的数值行为。从线性最小二乘的基本公式出发：给定一个矩阵 $A \\in \\mathbb{R}^{m \\times n}$（其中 $m \\ge n$）和一个右端向量 $\\mathbf{b} \\in \\mathbb{R}^m$，为 $\\mathbf{x} \\in \\mathbb{R}^n$ 定义目标函数 $f(\\mathbf{x}) = \\tfrac{1}{2}\\lVert A \\mathbf{x} - \\mathbf{b} \\rVert_2^2$。对 $f(\\mathbf{x})$ 使用微积分求导，以获得最小化点的平稳性条件，并实现一个求解器，该求解器仅使用指定运行时中可用的基本线性代数运算来强制执行此平稳性条件。请勿使用任何黑箱最小二乘例程。然后，实现一个基于正交三角（QR）分解的数值稳定参考求解器，以获得基线解。解释并演示 $A$ 中的病态条件如何降低正规方程方法的性能，特别是在元素由 $H_{ij} = \\tfrac{1}{i + j - 1}$（对于整数 $i \\ge 1, j \\ge 1$）给出的 Hilbert 矩阵上。\n\n请遵循以下要求。\n\n- 推导基础：从 $f(\\mathbf{x}) = \\tfrac{1}{2}\\lVert A \\mathbf{x} - \\mathbf{b} \\rVert_2^2$ 以及 $\\tfrac{1}{2}\\lVert r(\\mathbf{x}) \\rVert_2^2$ 的梯度是 $J(\\mathbf{x})^\\top r(\\mathbf{x})$（其中 $J(\\mathbf{x})$ 是 $r(\\mathbf{x})$ 的雅可比矩阵）这一规则开始。将此规则特化到线性残差 $r(\\mathbf{x}) = A \\mathbf{x} - \\mathbf{b}$，并推导出您的求解器必须满足的平稳性条件。请勿在问题陈述本身中包含任何预先推导的“快捷”公式。\n- 为您的设计提供信息的数值稳定性讨论：在浮点运算中，误差的增长取决于 $A$ 关于 $2$-范数的条件数 $\\kappa_2(A)$。回想一下，构造 $A^\\top A$ 会使 $2$-范数条件数平方，与应用正交变换的基于 QR 的方法相比，这会放大舍入误差。\n- 实现要求：\n  - 实现一个函数，通过上面推导出的正规方程方法求解线性最小二乘问题。使用直接线性求解器求解得到的对称系统，而不是显式求逆。\n  - 实现一个参考求解器，使用瘦 QR 分解 $A = Q R$（其中 $Q \\in \\mathbb{R}^{m \\times n}$ 具有标准正交列，而 $R \\in \\mathbb{R}^{n \\times n}$ 是上三角矩阵），然后求解 $R \\mathbf{x} = Q^\\top \\mathbf{b}$。\n  - 实现一个函数，用于构造一个矩形 Hilbert 矩阵 $H \\in \\mathbb{R}^{m \\times n}$，其元素为 $H_{ij} = \\tfrac{1}{i + j - 1}$。\n  - 对于下面的每个测试用例，通过 $\\mathbf{b} = A \\mathbf{x}_{\\mathrm{true}} + \\varepsilon$ 构建 $\\mathbf{b}$，其中 $\\varepsilon \\in \\mathbb{R}^m$ 是一个固定的、微小的、确定性的扰动，其元素为 $\\varepsilon_i = \\alpha \\cdot (-1)^i$，$\\alpha$ 是一个指定的标量。这确保了一个受控的、非零的残差，以便评估灵敏度。\n- 每个测试用例的误差度量和要求输出：\n  - 对于求解器输出的 $\\mathbf{x}$，计算其前向相对误差为 $e(\\mathbf{x}) = \\dfrac{\\lVert \\mathbf{x} - \\mathbf{x}_{\\mathrm{true}} \\rVert_2}{\\lVert \\mathbf{x}_{\\mathrm{true}} \\rVert_2}$。\n  - 对于每个测试用例，计算比率 $r = \\dfrac{e(\\mathbf{x}_{\\mathrm{NE}})}{e(\\mathbf{x}_{\\mathrm{QR}})}$，其中 $\\mathbf{x}_{\\mathrm{NE}}$ 是正规方程解，$\\mathbf{x}_{\\mathrm{QR}}$ 是基于 QR 的解。\n  - 您的程序必须输出一行，其中包含所有测试用例的这些比率的列表，按顺序排列，格式为用方括号括起来的逗号分隔列表，例如：$[r_1,r_2,r_3,r_4]$。每个 $r_k$ 必须作为浮点数输出。\n\n测试套件。精确实现以下四个测试用例，以检验不同的条件状况和边界情况：\n\n- 测试用例 1（良态，小规模，在微小扰动下一致）：\n  - $A_1 \\in \\mathbb{R}^{3 \\times 2}$，行向量为 $[1,0]$, $[0,1]$, $[1,1]$。\n  - $\\mathbf{x}_{\\mathrm{true},1} = [1,-1]^\\top$。\n  - $\\alpha = 10^{-12}$ 且 $\\varepsilon_i = \\alpha \\cdot (-1)^i$ 对于 $i \\in \\{1,2,3\\}$，因此 $\\mathbf{b}_1 = A_1 \\mathbf{x}_{\\mathrm{true},1} + \\varepsilon$。\n- 测试用例 2（Hilbert 矩阵，中等维度，病态）：\n  - $A_2 = H \\in \\mathbb{R}^{10 \\times 5}$，其中 $H_{ij} = \\tfrac{1}{i + j - 1}$ 对于 $i \\in \\{1,\\dots,10\\}$, $j \\in \\{1,\\dots,5\\}$。\n  - $\\mathbf{x}_{\\mathrm{true},2} \\in \\mathbb{R}^5$，元素为 $\\mathbf{x}_{\\mathrm{true},2} = [1,-1,1,-1,1]^\\top$。\n  - $\\alpha = 10^{-12}$ 且 $\\varepsilon_i = \\alpha \\cdot (-1)^i$ 对于 $i \\in \\{1,\\dots,10\\}$，因此 $\\mathbf{b}_2 = A_2 \\mathbf{x}_{\\mathrm{true},2} + \\varepsilon$。\n- 测试用例 3（Hilbert 矩阵，更大维度，更病态）：\n  - $A_3 = H \\in \\mathbb{R}^{24 \\times 12}$，其中 $H_{ij} = \\tfrac{1}{i + j - 1}$ 对于 $i \\in \\{1,\\dots,24\\}$, $j \\in \\{1,\\dots,12\\}$。\n  - $\\mathbf{x}_{\\mathrm{true},3} \\in \\mathbb{R}^{12}$，其元素为 $\\mathbf{x}_{\\mathrm{true},3}(j) = 1$（如果 $j$ 是奇数）和 $\\mathbf{x}_{\\mathrm{true},3}(j) = -1$（如果 $j$ 是偶数），对于 $j \\in \\{1,\\dots,12\\}$。\n  - $\\alpha = 10^{-12}$ 且 $\\varepsilon_i = \\alpha \\cdot (-1)^i$ 对于 $i \\in \\{1,\\dots,24\\}$，因此 $\\mathbf{b}_3 = A_3 \\mathbf{x}_{\\mathrm{true},3} + \\varepsilon$。\n- 测试用例 4（Hilbert 矩阵，单列的边界情况）：\n  - $A_4 = H \\in \\mathbb{R}^{10 \\times 1}$，其中 $H_{i1} = \\tfrac{1}{i}$ 对于 $i \\in \\{1,\\dots,10\\}$。\n  - $\\mathbf{x}_{\\mathrm{true},4} = [1]$。\n  - $\\alpha = 10^{-12}$ 且 $\\varepsilon_i = \\alpha \\cdot (-1)^i$ 对于 $i \\in \\{1,\\dots,10\\}$，因此 $\\mathbf{b}_4 = A_4 \\mathbf{x}_{\\mathrm{true},4} + \\varepsilon$。\n\n程序输出格式规范：\n\n- 您的程序必须在标准输出上产生仅一行内容，包含列表 $[r_1,r_2,r_3,r_4]$，其中每个 $r_k$ 是为测试用例 $k$ 定义的比率。不要打印任何额外的文本或行。此问题不涉及角度和物理单位，因此不需要单位转换。",
            "solution": "所述问题是有效的。这是一个在数值线性代数领域中定义明确、有科学依据的练习。它自成一体，提供了所有必需的数据、常数和定义。目标清晰，所要求的分析建立在数值分析和矩阵计算的既定原则之上。\n\n任务是求解线性最小二乘问题，即寻找一个向量 $\\mathbf{x} \\in \\mathbb{R}^n$，使得对于给定的矩阵 $A \\in \\mathbb{R}^{m \\times n}$（其中 $m \\ge n$）和向量 $\\mathbf{b} \\in \\mathbb{R}^m$，目标函数 $f(\\mathbf{x}) = \\frac{1}{2}\\lVert A \\mathbf{x} - \\mathbf{b} \\rVert_2^2$ 最小化。我们将从第一性原理推导正规方程，实现一个基于它们的求解器，将其数值稳定性与更稳健的基于 QR 的方法进行对比，并在一系列问题上测试这两种方法，包括病态的 Hilbert 矩阵。\n\n**1. 正规方程的推导**\n\n线性最小二乘问题的解是使目标函数 $f(\\mathbf{x})$ 最小化的向量 $\\mathbf{x}$。由于 $f(\\mathbf{x})$ 是一个可微的凸函数，其最小值点可以通过找到梯度为零的点来获得。问题指定使用向量函数平方范数梯度的一般规则：$g(\\mathbf{x}) = \\frac{1}{2}\\lVert r(\\mathbf{x}) \\rVert_2^2$ 的梯度是 $\\nabla g(\\mathbf{x}) = J(\\mathbf{x})^\\top r(\\mathbf{x})$，其中 $J(\\mathbf{x})$ 是残差函数 $r(\\mathbf{x})$ 的雅可比矩阵。\n\n对于线性最小二乘问题，残差函数为 $r(\\mathbf{x}) = A\\mathbf{x} - \\mathbf{b}$。此函数在 $\\mathbf{x}$ 上是线性的。为了找到它的雅可比矩阵，我们考虑 $\\mathbf{x}$ 中的一个微小扰动 $\\delta \\mathbf{x}$ 如何影响 $r(\\mathbf{x})$：\n$$r(\\mathbf{x} + \\delta \\mathbf{x}) = A(\\mathbf{x} + \\delta \\mathbf{x}) - \\mathbf{b} = (A\\mathbf{x} - \\mathbf{b}) + A \\delta \\mathbf{x} = r(\\mathbf{x}) + A \\delta \\mathbf{x}$$\n雅可比矩阵 $J(\\mathbf{x})$ 是线性逼近 $r(\\mathbf{x})$ 变化的矩阵，即 $r(\\mathbf{x} + \\delta \\mathbf{x}) \\approx r(\\mathbf{x}) + J(\\mathbf{x}) \\delta \\mathbf{x}$。通过直接比较， $r(\\mathbf{x}) = A\\mathbf{x} - \\mathbf{b}$ 的雅可比矩阵是常数矩阵 $J(\\mathbf{x}) = A$。\n\n现在，我们将提供的梯度规则应用于我们的目标函数 $f(\\mathbf{x})$：\n$$\\nabla f(\\mathbf{x}) = J(\\mathbf{x})^\\top r(\\mathbf{x}) = A^\\top (A\\mathbf{x} - \\mathbf{b})$$\n$\\mathbf{x}$ 是最小化点的必要条件是 $\\mathbf{x}$ 处的梯度必须为零向量：\n$$\\nabla f(\\mathbf{x}) = 0$$\n这导致了平稳性条件：\n$$A^\\top (A\\mathbf{x} - \\mathbf{b}) = 0$$\n重新整理此方程，得到**正规方程**组：\n$$A^\\top A \\mathbf{x} = A^\\top \\mathbf{b}$$\n这是一个包含 $n$ 个未知数的 $n$ 个线性方程的方阵系统。矩阵 $C = A^\\top A$ 是对称的。如果 $A$ 的列是线性无关的（即，$A$ 具有满列秩，这对于超定最小二乘问题是典型情况），那么 $A^\\top A$ 也是正定的，因此是可逆的，从而保证了 $\\mathbf{x}$ 的唯一解。\n\n**2. 数值稳定性与求解方法**\n\n**正规方程法：**\n此方法包括两个步骤：\n1.  构造矩阵 $A^\\top A$ 和向量 $A^\\top \\mathbf{b}$。\n2.  求解得到的 $n \\times n$ 线性系统 $(A^\\top A) \\mathbf{x} = (A^\\top \\mathbf{b})$ 以获得 $\\mathbf{x}$。\n\n此方法的主要数值缺点与矩阵 $A^\\top A$ 的条件数有关。矩阵 $M$ 的 $2$-范数条件数，记为 $\\kappa_2(M)$，衡量了系统 $M\\mathbf{y}=d$ 的解对 $M$ 和 $d$ 中扰动的敏感性。对于正规方程，系统的条件数是 $\\kappa_2(A^\\top A)$。可以证明 $\\kappa_2(A^\\top A) = (\\kappa_2(A))^2$。\n\n如果 $A$ 是病态的，即 $\\kappa_2(A)$ 很大，那么 $\\kappa_2(A^\\top A)$ 将会大得多。例如，如果 $\\kappa_2(A) = 10^4$，那么 $\\kappa_2(A^\\top A) = 10^8$。求解具有如此大条件数的系统会导致浮点运算中存在的舍入误差被显著放大，从而使计算出的解 $\\mathbf{x}_{\\mathrm{NE}}$ 远离真正的最小化点。\n\n**QR 分解法：**\n一种数值上更稳定的方法避免了显式构造 $A^\\top A$。这可以通过对 $A$ 进行正交三角 (QR) 分解来实现。对于 $A \\in \\mathbb{R}^{m \\times n}$（其中 $m \\ge n$ 且具有满列秩），我们可以计算一个“瘦”QR 分解：\n$$A = QR$$\n其中 $Q \\in \\mathbb{R}^{m \\times n}$ 具有标准正交列（$Q^\\top Q = I_n$，其中 $I_n$ 是 $n \\times n$ 单位矩阵），而 $R \\in \\mathbb{R}^{n \\times n}$ 是一个对角线元素为正的上三角矩阵。\n\n将此代入目标函数：\n$$\\lVert A\\mathbf{x} - \\mathbf{b} \\rVert_2^2 = \\lVert QR\\mathbf{x} - \\mathbf{b} \\rVert_2^2$$\n我们可以将残差向量 $QR\\mathbf{x} - \\mathbf{b}$ 乘以任何正交矩阵而不改变其 $2$-范数。虽然 $Q$ 不是方阵，但我们可以利用属性 $Q^\\top Q = I_n$。$\\lVert A\\mathbf{x}-\\mathbf{b} \\rVert_2$ 的最小化点 $\\mathbf{x}$ 是正规方程 $A^\\top A \\mathbf{x} = A^\\top \\mathbf{b}$ 的解。代入 $A=QR$：\n$$(QR)^\\top (QR) \\mathbf{x} = (QR)^\\top \\mathbf{b}$$\n$$R^\\top Q^\\top Q R \\mathbf{x} = R^\\top Q^\\top \\mathbf{b}$$\n$$R^\\top I_n R \\mathbf{x} = R^\\top Q^\\top \\mathbf{b}$$\n$$R^\\top R \\mathbf{x} = R^\\top Q^\\top \\mathbf{b}$$\n由于 $R$ 是可逆的（因为 $A$ 具有满秩），$R^\\top$ 也是可逆的。我们可以左乘 $(R^\\top)^{-1}$ 得到：\n$$R\\mathbf{x} = Q^\\top \\mathbf{b}$$\n这是一个关于 $\\mathbf{x}$ 的上三角系统，可以使用回代法高效且准确地求解。该系统的条件数是 $\\kappa_2(R)$。可以证明 $\\kappa_2(R) = \\kappa_2(A)$。因此，QR 方法求解的是一个与原始矩阵 $A$ 具有相同条件数的系统，避免了正规方程中出现的条件数平方效应。这使得当 $A$ 是病态时，QR 方法对舍入误差的鲁棒性显著增强。\n\n**3. 实现与测试策略**\n\n我们将实现三个核心函数：\n- `construct_hilbert(m, n)`：创建一个 $m \\times n$ 的 Hilbert 矩阵 $H$，其元素为 $H_{ij} = 1/(i+j-1)$，使用基于 1 的索引 $i, j$。\n- `solve_normal_equations(A, b)`：通过构造并求解 $A^\\top A \\mathbf{x} = A^\\top \\mathbf{b}$ 来解决最小二乘问题，使用标准的直接求解器如 `numpy.linalg.solve`。\n- `solve_qr(A, b)`：通过计算 $A$ 的瘦 QR 分解并求解 $R\\mathbf{x} = Q^\\top \\mathbf{b}$ 来解决最小二乘问题。将使用 `numpy.linalg.qr` 的 `mode='reduced'` 选项进行分解。\n\n程序将遍历四个指定的测试用例。对于每个用例，它将：\n1.  构造矩阵 $A$（自定义矩阵或 Hilbert 矩阵）。\n2.  定义真解 $\\mathbf{x}_{\\mathrm{true}}$。\n3.  构造右端向量 $\\mathbf{b} = A \\mathbf{x}_{\\mathrm{true}} + \\varepsilon$，其中 $\\varepsilon$ 是一个微小的、确定性的扰动向量。\n4.  使用正规方程法 ($\\mathbf{x}_{\\mathrm{NE}}$) 和 QR 法 ($\\mathbf{x}_{\\mathrm{QR}}$) 计算解。\n5.  计算每个解的前向相对误差：$e(\\mathbf{x}) = \\lVert \\mathbf{x} - \\mathbf{x}_{\\mathrm{true}} \\rVert_2 / \\lVert \\mathbf{x}_{\\mathrm{true}} \\rVert_2$。\n6.  计算这些误差的比率，$r = e(\\mathbf{x}_{\\mathrm{NE}}) / e(\\mathbf{x}_{\\mathrm{QR}})$。\n\n最终输出将是这些比率的列表，它将展示随着 $A$ 的条件数增加，正规方程方法的精度下降情况，尤其是在 Hilbert 矩阵测试用例中。对于良态问题（用例 1）和特殊的单列情况（用例 4），该比率预计接近于 1，表明精度相当。对于病态的 Hilbert 矩阵（用例 2 和 3），该比率预计远大于 1，突显了基于 QR 的方法卓越的数值稳定性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef construct_hilbert(m, n):\n    \"\"\"\n    Constructs an m x n Hilbert matrix.\n    The entry (i, j) is 1 / (i + j - 1), using 1-based indexing.\n    \"\"\"\n    i = np.arange(1, m + 1).reshape(m, 1)\n    j = np.arange(1, n + 1).reshape(1, n)\n    return 1.0 / (i + j - 1)\n\ndef solve_normal_equations(A, b):\n    \"\"\"\n    Solves the linear least squares problem min ||Ax - b||_2\n    using the normal equations A.T*A*x = A.T*b.\n    \"\"\"\n    AtA = A.T @ A\n    Atb = A.T @ b\n    x_ne = np.linalg.solve(AtA, Atb)\n    return x_ne\n\ndef solve_qr(A, b):\n    \"\"\"\n    Solves the linear least squares problem min ||Ax - b||_2\n    using a thin QR factorization A = QR, solving Rx = Q.T*b.\n    \"\"\"\n    Q, R = np.linalg.qr(A, mode='reduced')\n    Qtb = Q.T @ b\n    x_qr = np.linalg.solve(R, Qtb)\n    return x_qr\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and produce the required output.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases_spec = [\n        # Test case 1: well-conditioned, small\n        {\n            'm': 3, 'n': 2, 'alpha': 1e-12,\n            'A_def': lambda m, n: np.array([[1., 0.], [0., 1.], [1., 1.]]),\n            'xtrue_def': lambda n: np.array([1., -1.])\n        },\n        # Test case 2: Hilbert, moderate dimensions, ill-conditioned\n        {\n            'm': 10, 'n': 5, 'alpha': 1e-12,\n            'A_def': construct_hilbert,\n            'xtrue_def': lambda n: np.array([1. if (i % 2) == 0 else -1. for i in range(n)])\n        },\n        # Test case 3: Hilbert, larger dimensions, more ill-conditioned\n        {\n            'm': 24, 'n': 12, 'alpha': 1e-12,\n            'A_def': construct_hilbert,\n            'xtrue_def': lambda n: np.array([1. if (i % 2) == 0 else -1. for i in range(n)])\n        },\n        # Test case 4: Hilbert, edge case with one column\n        {\n            'm': 10, 'n': 1, 'alpha': 1e-12,\n            'A_def': construct_hilbert,\n            'xtrue_def': lambda n: np.array([1.])\n        }\n    ]\n\n    ratios = []\n\n    for case in test_cases_spec:\n        m, n, alpha = case['m'], case['n'], case['alpha']\n        \n        # 1. Construct matrix A\n        A = case['A_def'](m, n)\n        \n        # 2. Construct true solution xtrue\n        xtrue = case['xtrue_def'](n)\n        \n        # 3. Construct the right-hand side b = A*xtrue + epsilon\n        # Perturbation epsilon_i = alpha * (-1)^i for i = 1, ..., m\n        epsilon = alpha * ((-1.0)**np.arange(1, m + 1))\n        b = A @ xtrue + epsilon\n        \n        # 4. Solve using both methods\n        x_ne = solve_normal_equations(A, b)\n        x_qr = solve_qr(A, b)\n        \n        # 5. Compute forward relative errors\n        norm_xtrue = np.linalg.norm(xtrue)\n        \n        err_ne = np.linalg.norm(x_ne - xtrue) / norm_xtrue\n        err_qr = np.linalg.norm(x_qr - xtrue) / norm_xtrue\n        \n        # 6. Compute and store the ratio of errors\n        # Handle the unlikely case of err_qr being zero to avoid division by zero\n        if err_qr == 0.0:\n            if err_ne == 0.0:\n                ratio = 1.0\n            else:\n                ratio = float('inf')\n        else:\n            ratio = err_ne / err_qr\n            \n        ratios.append(ratio)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, ratios))}]\")\n\nsolve()\n```"
        }
    ]
}