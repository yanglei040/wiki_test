{
    "hands_on_practices": [
        {
            "introduction": "理论上，并非所有确定性的枢轴选择规则都能有效防止单纯形法中的循环现象。这个练习提供了一个具体的例子，您将手动模拟一个看似合理的“最大索引”规则，并观察它是如何导致算法陷入无限循环的。通过逐步追踪这个循环，您将能更直观地理解设计有效的反循环规则时所需的精妙之处。",
            "id": "3098176",
            "problem": "考虑以下线性规划问题，其形式为标准字典形式，基变量为 $x_3$ 和 $x_4$，非基变量为 $x_1$ 和 $x_2$：\n$$\n\\begin{aligned}\nx_3 = 0 - x_1 + x_2, \\\\\nx_4 = 0 + x_1 - x_2, \\\\\nz   = 0 - x_1 - x_2,\n\\end{aligned}\n$$\n以及非负约束 $x_1, x_2, x_3, x_4 \\geq 0$。可将此字典解释为源于方程组 $x_1 - x_2 + x_3 = 0$、$-x_1 + x_2 + x_4 = 0$ 和目标函数 $\\max z = -x_1 - x_2$。其基本可行解在原点 $x_1=x_2=x_3=x_4=0$ 处是退化的。\n\n采用以下使用最大索引破同的轴心选择规则：\n- 进基变量规则：在所有既约成本（$z$ 行中 $x_j$ 的系数）为负的非基变量中，选择索引最大的 $x_j$。\n- 出基变量规则：应用最小比率测试。由于此处的右侧常数项均为零，任何在进基变量列中具有正系数的基变量行都将产生零的比率；在这些比率相同的情况下，选择索引最大的基变量作为出基变量。\n\n根据此规则确定性地模拟单纯形法轴心变换，直到某个基重复出现，从而在基图（其节点为基变量的大小为2的索引集）上追踪一个有向路径。从初始基 $\\{x_3, x_4\\}$ 开始，确定遇到的有向环的长度（环中不同基的数量）。请以精确整数形式提供最终答案。无需四舍五入，不涉及物理单位。",
            "solution": "该问题定义明确且内容完整。必须严格遵循所提供的字典和轴心选择规则。我们将逐步模拟单纯形法的轴心变换，在每次迭代中追踪基，直到某个基重复出现。变量的索引从 $1$ 到 $4$。\n\n设 $B_k$ 为第 $k$ 次迭代时基变量的索引集。\n设 $D_k$ 为第 $k$ 次迭代时的字典。\n\n**迭代 0：**\n给定初始状态。\n基为 $B_0 = \\{3, 4\\}$。非基变量的索引为 $\\{1, 2\\}$。\n字典 $D_0$ 为：\n$$\n\\begin{aligned}\nx_3 = 0 - x_1 + x_2 \\\\\nx_4 = 0 + x_1 - x_2 \\\\\nz   = 0 - x_1 - x_2\n\\end{aligned}\n$$\n\n**轴心变换 1：**\n1.  **进基变量选择：** 非基变量为 $x_1$ 和 $x_2$。它们在 $z$ 行中的系数分别为 $-1$ 和 $-1$。两者均为负，因此都有资格进入基。根据指定规则，我们选择索引最大的变量。因此，选择 $x_2$ 作为进基变量。\n\n2.  **出基变量选择：** 我们应用最小比率测试。我们检查字典的各行中进基变量 $x_2$ 的系数是否为正。\n    - 在 $x_3$ 所在的行，表达式为 $x_3 = 0 - x_1 + x_2$。$x_2$ 的系数为 $+1$。由于该系数为正，该行是一个候选行。比率为常数项除以该系数：$0/1 = 0$。\n    - 在 $x_4$ 所在的行，表达式为 $x_4 = 0 + x_1 - x_2$。$x_2$ 的系数为 $-1$。由于该系数不为正，该行不参与比率测试。\n    出基变量只有一个候选者 $x_3$。因此，$x_3$ 离基。在此步骤中，不需要使用出基变量的破同规则。\n\n3.  **字典更新：** 我们通过求解 $x_3$ 所在行得到进基变量 $x_2$ 的表达式来进行轴心变换：\n    $x_3 = -x_1 + x_2 \\implies x_2 = x_1 + x_3$。\n    接下来，我们将 $x_2$ 的这个表达式代入其他方程：\n    $x_4 = x_1 - x_2 = x_1 - (x_1 + x_3) = -x_3$。\n    $z = -x_1 - x_2 = -x_1 - (x_1 + x_3) = -2x_1 - x_3$。\n\n**迭代 1：**\n新的基为 $B_1 = \\{2, 4\\}$。非基变量的索引为 $\\{1, 3\\}$。\n新的字典 $D_1$ 为：\n$$\n\\begin{aligned}\nx_2 = 0 + x_1 + x_3 \\\\\nx_4 = 0 - x_3 \\\\\nz   = 0 - 2x_1 - x_3\n\\end{aligned}\n$$\n\n**轴心变换 2：**\n1.  **进基变量选择：** 非基变量为 $x_1$ 和 $x_3$。它们在 $z$ 行中的系数分别为 $-2$ 和 $-1$。两者均为负。我们选择索引最大的那一个，即 $x_3$。因此，$x_3$ 进基。\n\n2.  **出基变量选择：** 我们对进基变量 $x_3$ 应用最小比率测试。\n    - 在 $x_2$ 所在的行，表达式为 $x_2 = 0 + x_1 + x_3$。$x_3$ 的系数为 $+1$。该行是一个候选行。比率为 $0/1 = 0$。\n    - 在 $x_4$ 所在的行，表达式为 $x_4 = 0 - x_3$。$x_3$ 的系数为 $-1$。该行不是候选行。\n    只有一个候选者 $x_2$，它必须离基。同样，没有用到破同规则。\n\n3.  **字典更新：** 我们通过求解 $x_2$ 所在行得到 $x_3$ 的表达式来进行轴心变换：\n    $x_2 = x_1 + x_3 \\implies x_3 = x_2 - x_1$。\n    我们将此表达式代入其他方程：\n    $x_4 = -x_3 = -(x_2 - x_1) = x_1 - x_2$。\n    $z = -2x_1 - x_3 = -2x_1 - (x_2 - x_1) = -x_1 - x_2$。\n\n**迭代 2：**\n新的基为 $B_2 = \\{3, 4\\}$。非基变量的索引为 $\\{1, 2\\}$。\n新的字典 $D_2$ 为：\n$$\n\\begin{aligned}\nx_3 = 0 - x_1 + x_2 \\\\\nx_4 = 0 + x_1 - x_2 \\\\\nz   = 0 - x_1 - x_2\n\\end{aligned}\n$$\n我们观察到基 $B_2 = \\{3, 4\\}$ 与初始基 $B_0$ 相同。字典 $D_2$ 也与 $D_0$ 相同。这表明单纯形法已进入一个环。\n\n由轴心选择规则生成的基序列为：\n$B_0 = \\{3, 4\\} \\to B_1 = \\{2, 4\\} \\to B_2 = \\{3, 4\\}$。\n基的有向环为 $(B_0, B_1)$。此环中不同的基为 $B_0$ 和 $B_1$。\n一个环的长度是它包含的不同顶点（基）的数量。在本例中，有两个不同的基。\n\n因此，有向环的长度为 $2$。",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "这是展示单纯形法中循环现象的经典案例。在这个实践中，您将通过编码实现丹齐格(Dantzig)法则和布兰德(Bland)法则，亲眼见证前者如何在特定的退化问题上陷入循环，而后者又是如何通过其独特的索引选择机制打破僵局，确保算法最终能够终止的。",
            "id": "3117274",
            "problem": "要求您实现一个线性规划 (LP) 的单纯形法模拟，以研究不同主元选择规则下的退化和循环现象。这个问题的基本基础是线性规划的典范型表述：在满足线性等式约束和非负性条件下，最大化一个线性目标函数，以及通过主元变换从一个基本可行解 (BFS) 移动到另一个，直到满足最优性条件的单纯形法。在标准型中，一个 LP 表示为最大化 $c^\\top x$，约束条件为 $A x = b$ 和 $x \\ge 0$。这是通过引入松弛变量从 $\\le$ 约束得到的。单纯形法使用由 $A$ 的列组成的基矩阵 $B$，并计算当前的基本可行解 $x_B = B^{-1} b$；它为非基变量评估检验数 $r_N = c_N - c_B^\\top B^{-1} N$，如果 $r_N$ 的某个分量为正（对于最大化问题），则执行一次主元变换。当一个或多个基变量等于 $0$ 时，就会发生退化。循环指的是在目标函数没有改善的情况下重复访问相同的基，这通常是由于退化主元变换引起的。这里考虑两种主元规则：Dantzig 规则（选择具有最大正检验数的变量作为进基变量）和 Bland 规则（在具有正检验数的变量中，选择下标最小的作为进基变量；在满足最小比率检验的变量中，选择下标最小的作为出基变量）。您必须实现这两种主元规则，并通过检测重复的基来经验性地测试循环现象。\n\n实现一个程序，该程序：\n- 将每个以 $\\le$ 形式给出的 LP 通过添加松弛变量转换为标准等式形式。\n- 使用 Dantzig 规则和 Bland 规则这两种主元规则来模拟单纯形法。在每次迭代中，计算 $x_B = B^{-1} b$，对偶向量 $y^\\top = c_B^\\top B^{-1}$，检验数 $r_N = c_N - y^\\top N$，按照指定规则选择一个进基变量，通过 $B d_B = A_{\\cdot,e}$ 计算方向 $d_B$，对 $d_{B,i} > 0$ 的分量执行最小比率检验以选择出基变量，并进行主元变换。当所有检验数都非正（最优性）、问题无界（沿检验数为正的方向上没有正的 $d_{B,i}$）或先前出现过的基再次出现（循环）时停止。对正性和等式比较使用数值容差 $\\varepsilon = 10^{-9}$。\n- 对于每个测试用例，报告在 Dantzig 规则和 Bland 规则下是否检测到循环（布尔值），以及每种规则终止时的最终目标值 $c^\\top x$（浮点数）。如果检测到循环，报告检测到循环时的目标值。如果检测到无界，报告目标值为 $0.0$。\n\n测试套件：\n提供三个以 $\\le$ 形式表示的、决策变量具有非负约束的 LP：\n\n- 案例 1（退化，已知在 Dantzig 规则下会循环，而 Bland 规则可以避免）：\n  最大化 $10 x_1 - 57 x_2 - 9 x_3 - 24 x_4$，约束条件为\n  $0.5 x_1 - 5.5 x_2 - 2.5 x_3 + 9 x_4 \\le 0$,\n  $0.5 x_1 - 1.5 x_2 - 0.5 x_3 + 1 x_4 \\le 0$,\n  $1 x_1 \\le 1$,\n  和 $x_1, x_2, x_3, x_4 \\ge 0$。\n  这会引入 $3$ 个松弛变量，并且有 $b = [0, 0, 1]^\\top$。\n\n- 案例 2（非退化，简单的有界问题）：\n  最大化 $3 x_1 + 2 x_2$，约束条件为\n  $1 x_1 + 1 x_2 \\le 4$,\n  $1 x_1 \\le 2$,\n  $1 x_2 \\le 3$,\n  和 $x_1, x_2 \\ge 0$。\n\n- 案例 3（边界情况，开始时进基变量的检验数出现平局）：\n  最大化 $1 x_1 + 1 x_2$，约束条件为\n  $1 x_1 + 1 x_2 \\le 1$,\n  $1 x_1 \\le 0.5$,\n  $1 x_2 \\le 0.5$,\n  和 $x_1, x_2 \\ge 0$。\n\n最终输出格式：\n您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例的结果应为一个形如 $[d\\_cycle, b\\_cycle, d\\_opt, b\\_opt]$ 的列表，其中 $d\\_cycle$ 和 $b\\_cycle$ 是布尔值，分别表示在 Dantzig 规则和 Bland 规则下是否发生循环，$d\\_opt$ 和 $b\\_opt$ 是浮点数，分别给出 Dantzig 规则和 Bland 规则的最终目标值。例如，输出应类似于 $[[True,False,10.0,10.0],[...],[...]]$。浮点数必须以十进制形式打印；此问题不涉及物理单位。",
            "solution": "我们从线性规划 (LP) 的基础表述开始。在标准型中，一个 LP 寻求在约束条件 $A x = b$ 和 $x \\ge 0$ 下最大化 $c^\\top x$。任何形如 $M x \\le b$ 且 $x \\ge 0$ 的约束系统都可以通过引入松弛变量 $s \\ge 0$ 转换为标准型，使得 $M x + s = b$。这产生一个等式系统 $A x' = b$，其中 $x' = \\begin{bmatrix} x \\\\ s \\end{bmatrix}$ 和 $A = [M \\ \\ I]$，以及增广目标向量 $c' = \\begin{bmatrix} c \\\\ 0 \\end{bmatrix}$。通过选择一个由 $A$ 的 $m$ 个列组成的基 $B$（其中 $m$ 等于约束的数量），求解 $x_B = B^{-1} b$，将非基变量设为 $x_N = 0$，并要求 $x_B \\ge 0$，可以得到一个基本可行解 (BFS)。在标准初始化中，松弛变量构成基，因为这对应于单位矩阵，因此只要 $b \\ge 0$，就存在一个 BFS。\n\n单纯形法通过主元变换向前推进：从非基变量集合中选择一个进基变量，从基变量集合中选择一个出基变量。指导选择的原则依赖于检验数。设 $B$ 是基矩阵，$N$ 是由非基变量的列组成的 $A$ 的子矩阵。将 $c_B$ 和 $c_N$ 表示为目标系数的相应划分。当前解是 $x_B = B^{-1} b$。目标函数可以表示为：\n$$\nz = c^\\top x = c_B^\\top x_B + c_N^\\top x_N = c_B^\\top B^{-1} b + \\left( c_N^\\top - c_B^\\top B^{-1} N \\right) x_N,\n$$\n因此，检验数（在最大化问题中也称为相对利润）是：\n$$\nr_N = c_N - c_B^\\top B^{-1} N.\n$$\n如果 $r_N$ 的所有分量都是非正的，那么增加任何非基变量都不能改善目标函数，当前的基本可行解就是最优的。如果某个 $r_j > 0$，那么增加相应的非基变量 $x_j$ 可以增加 $z$，这个变量就是进入基的候选者。对基变量的影响由满足以下条件的方向 $d_B$ 决定：\n$$\nB d_B = A_{\\cdot,j},\n$$\n这样，将 $x_j$ 增加 $\\theta$ 会使基变量变为 $x_B(\\theta) = x_B - \\theta d_B$。最小比率检验通过将 $\\theta$ 限制为使得 $x_B(\\theta) \\ge 0$ 的最大非负值来确保可行性，该值由下式给出：\n$$\n\\theta^\\star = \\min_{i: d_{B,i} > 0} \\frac{x_{B,i}}{d_{B,i}}.\n$$\n如果不存在分量 $d_{B,i} > 0$，则问题在 $x_j$ 方向上是无界的，因为增加 $x_j$ 会在不违反可行性的情况下改善目标函数。\n\n退化指的是一个或多个基变量等于零的情况。在退化主元变换中，最小比率 $\\theta^\\star$ 等于零，导致目标值没有变化，并可能使算法重新访问先前见过的基。循环是算法重复访问同一个基（和同一个基本可行解）的现象，从而进入一个不改善目标函数的无限循环。所研究的主元规则是：\n- Dantzig 规则：在所有 $r_j > 0$ 的非基变量中，选择具有最大 $r_j$ 的变量作为进基变量；执行比率检验，并选择第一个（或任何一致的）达到最小比率的基变量作为出基变量。\n- Bland 规则：在所有 $r_j > 0$ 的非基变量中，选择下标最小的一个进入基；在所有达到最小比率的下标中，选择下标最小的基变量离开基。\n\nBland 规则通过对基序列强制实施字典序单调性来防止循环，这是单纯形法中主元选择理论支持的一个结果：当进基变量和出基变量的平局都通过最小下标来打破时，算法不会重新访问先前见过的基。\n\n算法设计：\n- 输入：对于每个测试用例，提供原始决策变量的矩阵 $M$、向量 $b$ 和目标系数向量 $c$，以及非负约束 $x \\ge 0$。\n- 转换为标准型：构造 $A = [M \\ \\ I_m]$ 和 $c' = \\begin{bmatrix} c \\\\ 0_m \\end{bmatrix}$，初始基由 $m$ 个松弛变量（下标从 $n$ 到 $n + m - 1$）组成。\n- 迭代：\n  1. 通过选择与当前基对应的 $A$ 的列来形成 $B$。通过求解 $B x_B = b$ 来计算 $x_B = B^{-1} b$。通过求解 $B^\\top y = c_B$ 来计算 $y$，这会得到 $y^\\top = c_B^\\top B^{-1}$。\n  2. 计算 $r_N = c_N - y^\\top N$。如果 $\\max_j r_{N,j} \\le \\varepsilon$，则宣布达到最优。\n  3. 选择进基变量：\n     - Dantzig 规则：选择满足 $r_{N,j} > \\varepsilon$ 且具有最大 $r_{N,j}$ 的下标 $j$；一致地打破平局（例如，选择第一个遇到的）。\n     - Bland 规则：在非基集合中选择满足 $r_{N,j} > \\varepsilon$ 的最小下标 $j$。\n  4. 通过求解 $B d_B = A_{\\cdot,j}$ 来计算 $d_B$。对 $d_{B,i} > \\varepsilon$ 的分量执行比率检验：$\\theta_i = x_{B,i} / d_{B,i}$，并选择使 $\\theta_i$ 最小化的出基下标；打破平局：\n     - Dantzig 规则：第一个遇到的最小值。\n     - Bland 规则：在最小值中，选择最小的基变量下标。\n  5. 主元变换：用进基变量替换出基变量，并更新基和非基集合。\n  6. 循环检测：维护一个已访问基的集合（作为变量下标的有序元组）。如果新的基已经存在于集合中，则宣布发生循环。\n- 终止：返回是否检测到循环以及最终目标值 $c^\\top x$。如果发生循环，在退化主元变换期间目标值保持不变；报告检测到循环时的值。如果检测到无界（没有 $d_{B,i} > 0$），则报告 $0.0$。\n\n测试用例和预期现象：\n- 案例 1 (Beale 的循环例子)：给定 $c = [10, -57, -9, -24]$，$b = [0, 0, 1]^\\top$ 和指定的约束，初始基本可行解是退化的（$x = 0$，松弛变量 $s_1 = 0, s_2 = 0, s_3 = 1$）。在 Dantzig 规则下，一系列退化主元变换会重新访问先前遇到的基，从而展示出循环现象；在 Bland 规则下，主元变换序列避免了循环并达到了最优。\n- 案例 2：一个简单的有界非退化 LP，其中 $c = [3, 2]$ 和 $b = [4, 2, 3]^\\top$；两种规则都应收敛到最优值，通常在 $x_1 = 2, x_2 = 2$ 处，达到目标值 $z = 10$，且不发生循环。\n- 案例 3：一个在初始时进基变量检验数出现平局的边界情况（$c = [1, 1]$ 和 $b = [1, 0.5, 0.5]^\\top$）；两种规则都应能避免循环，最优解为 $x_1 = 0.5, x_2 = 0.5$，目标值为 $z = 1$。\n\n最终程序为这三个测试用例实现了所述算法，并按指定格式输出结果列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nEPS = 1e-9\nMAX_ITERS = 200\n\ndef simplex(M, b, c, rule=\"dantzig\"):\n    \"\"\"\n    Solve a maximization LP given in = form with nonnegativity: M x = b, x >= 0, maximize c^T x.\n    Adds slacks to get equality, runs simplex with specified pivot rule.\n    rule: \"dantzig\" or \"bland\".\n    Returns: (cycled: bool, optimal_value: float)\n    \"\"\"\n    M = np.array(M, dtype=float)\n    b = np.array(b, dtype=float)\n    c = np.array(c, dtype=float)\n\n    m, n = M.shape  # m constraints, n decision variables\n\n    # Build standard-form A = [M | I], augmented c' = [c, 0_m]\n    A = np.hstack([M, np.eye(m, dtype=float)])\n    c_full = np.concatenate([c, np.zeros(m, dtype=float)])\n\n    # Initial basis: slacks\n    basis = list(range(n, n + m))\n    nonbasis = list(range(0, n))\n\n    visited_bases = set()\n    visited_bases.add(tuple(basis))\n\n    cycled = False\n    z_value = 0.0\n\n    for _ in range(MAX_ITERS):\n        B = A[:, basis]  # m x m\n        N = A[:, nonbasis]  # m x (n_nonbasic)\n\n        # Solve for x_B and y\n        try:\n            x_B = np.linalg.solve(B, b)\n        except np.linalg.LinAlgError:\n            # Singular basis; treat as cycle or fail-safe\n            cycled = True\n            break\n        c_B = c_full[basis]\n        c_N = c_full[nonbasis]\n        try:\n            y = np.linalg.solve(B.T, c_B)\n        except np.linalg.LinAlgError:\n            cycled = True\n            break\n\n        # Reduced costs r_N = c_N - y^T N\n        r_N = c_N - (y @ N)\n\n        # Check optimality (no positive reduced costs)\n        max_r = np.max(r_N) if r_N.size > 0 else -np.inf\n        if max_r <= EPS:\n            # Optimal; compute objective z = c_B^T x_B\n            z_value = float(c_B @ x_B)\n            cycled = False\n            break\n\n        # Select entering variable\n        enter_idx_in_N = None\n        if rule == \"dantzig\":\n            # Choose index with largest positive reduced cost\n            # If multiple, choose first encountered\n            candidates = [(j, r) for j, r in enumerate(r_N) if r > EPS]\n            if not candidates:\n                z_value = float(c_B @ x_B)\n                cycled = False\n                break\n            # Find argmax r\n            max_val = -np.inf\n            for j, r in candidates:\n                if r > max_val:\n                    max_val = r\n                    enter_idx_in_N = j\n        elif rule == \"bland\":\n            # Choose smallest variable index in nonbasis with r > EPS\n            enter_idx_in_N = None\n            min_var_index = None\n            for j, r in enumerate(r_N):\n                if r > EPS:\n                    var_index = nonbasis[j]\n                    if (min_var_index is None) or (var_index < min_var_index):\n                        min_var_index = var_index\n                        enter_idx_in_N = j\n            if enter_idx_in_N is None:\n                z_value = float(c_B @ x_B)\n                cycled = False\n                break\n        else:\n            raise ValueError(\"Unknown rule: must be 'dantzig' or 'bland'.\")\n\n        entering_var = nonbasis[enter_idx_in_N]\n\n        # Compute direction d_B by solving B d_B = a_enter\n        a_enter = A[:, entering_var]\n        try:\n            d_B = np.linalg.solve(B, a_enter)\n        except np.linalg.LinAlgError:\n            cycled = True\n            break\n\n        # Ratio test\n        ratios = []\n        for i in range(m):\n            if d_B[i] > EPS:\n                ratios.append(x_B[i] / d_B[i])\n            else:\n                ratios.append(np.inf)\n        min_ratio = min(ratios) if ratios else np.inf\n        if np.isinf(min_ratio):\n            # Unbounded direction\n            z_value = 0.0\n            cycled = False\n            break\n\n        # Select leaving variable\n        leave_row = None\n        if rule == \"dantzig\":\n            # First encountered minimum ratio\n            for i in range(m):\n                if d_B[i] > EPS:\n                    if abs(ratios[i] - min_ratio) <= EPS:\n                        leave_row = i\n                        break\n        else:  # bland\n            # Among minima, choose smallest basic variable index\n            candidate_rows = []\n            for i in range(m):\n                if d_B[i] > EPS and abs(ratios[i] - min_ratio) <= EPS:\n                    candidate_rows.append(i)\n            if not candidate_rows:\n                z_value = 0.0\n                cycled = False\n                break\n            # Select smallest index of the basic variable\n            best_row = candidate_rows[0]\n            best_var_index = basis[best_row]\n            for i in candidate_rows[1:]:\n                var_idx = basis[i]\n                if var_idx < best_var_index:\n                    best_var_index = var_idx\n                    best_row = i\n            leave_row = best_row\n\n        leaving_var = basis[leave_row]\n\n        # Pivot: update basis and nonbasis\n        basis[leave_row] = entering_var\n        # Update nonbasis: replace entering with leaving\n        # Keep nonbasis sorted for consistent behavior except Bland requires index ordering; we will reconstruct properly\n        nonbasis = [v for v in nonbasis if v != entering_var]\n        nonbasis.append(leaving_var)\n        # For Bland, maintain sorted nonbasis to enforce index ordering in selection\n        if rule == \"bland\":\n            nonbasis.sort()\n\n        # Check cycling: if basis repeats, declare cycle\n        basis_tuple = tuple(basis)\n        if basis_tuple in visited_bases:\n            cycled = True\n            # Objective at cycle detection\n            z_value = float(c_full[basis] @ x_B)\n            break\n        visited_bases.add(basis_tuple)\n\n        # Continue to next iteration\n\n    else:\n        # Max iterations reached; treat as cycle for safety\n        cycled = True\n        z_value = float(c_full[basis] @ x_B) if 'x_B' in locals() else 0.0\n\n    return cycled, z_value\n\ndef solve():\n    # Define the test cases from the problem statement.\n\n    # Case 1: Beale's cycling example (degenerate)\n    M1 = np.array([\n        [0.5, -5.5, -2.5, 9.0],\n        [0.5, -1.5, -0.5, 1.0],\n        [1.0,  0.0,  0.0, 0.0]\n    ], dtype=float)\n    b1 = np.array([0.0, 0.0, 1.0], dtype=float)\n    c1 = np.array([10.0, -57.0, -9.0, -24.0], dtype=float)\n\n    # Case 2: Simple bounded non-degenerate\n    M2 = np.array([\n        [1.0, 1.0],\n        [1.0, 0.0],\n        [0.0, 1.0]\n    ], dtype=float)\n    b2 = np.array([4.0, 2.0, 3.0], dtype=float)\n    c2 = np.array([3.0, 2.0], dtype=float)\n\n    # Case 3: Edge case with tie in entering reduced costs\n    M3 = np.array([\n        [1.0, 1.0],\n        [1.0, 0.0],\n        [0.0, 1.0]\n    ], dtype=float)\n    b3 = np.array([1.0, 0.5, 0.5], dtype=float)\n    c3 = np.array([1.0, 1.0], dtype=float)\n\n    test_cases = [\n        (M1, b1, c1),\n        (M2, b2, c2),\n        (M3, b3, c3)\n    ]\n\n    results = []\n    for M, b, c in test_cases:\n        d_cycle, d_opt = simplex(M, b, c, rule=\"dantzig\")\n        b_cycle, b_opt = simplex(M, b, c, rule=\"bland\")\n        # Round floats to 6 decimals for stable output\n        d_opt_round = round(float(d_opt), 6)\n        b_opt_round = round(float(b_opt), 6)\n        results.append([d_cycle, b_cycle, d_opt_round, b_opt_round])\n\n    # Final print statement in the exact required format.\n    # Ensure booleans and floats are printed correctly in a single-line list of lists.\n    def format_item(item):\n        if isinstance(item, bool):\n            return \"True\" if item else \"False\"\n        elif isinstance(item, float):\n            # Keep as decimal\n            return f\"{item}\"\n        else:\n            return str(item)\n\n    formatted = []\n    for res in results:\n        formatted.append(\"[\" + \",\".join(format_item(x) for x in res) + \"]\")\n    print(f\"[{','.join(formatted)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "除了布兰德法则，还存在其他有效的反循环技术。这项综合性实验将引导您探索并实现多种反循环策略，包括词典序扰动法和随机化决胜法。通过在一系列精心设计的挑战性问题上比较这些方法的性能，您将对如何确保单纯形算法的稳健性获得更广阔的视野。",
            "id": "3098175",
            "problem": "您将实现一个用于标准不等式形式的线性规划 (LP) 的原始单纯形法，并在专门构造的退化族上比较多种抗循环规则。您将求解的 LP 形式如下\n$$\n\\text{maximize } c^\\top x \\quad \\text{subject to } A x \\le b, \\; x \\ge 0,\n$$\n其中 $A \\in \\mathbb{R}^{m \\times n}$，$b \\in \\mathbb{R}^m$，$c \\in \\mathbb{R}^n$。引入松弛变量 $s \\in \\mathbb{R}^m$ 将每个约束转换为等式 $A x + s = b$，其中 $s \\ge 0$。原始单纯形算法维护一个由 $m$ 个基变量组成的基。在每次迭代中，对于由当前基列构成的当前基矩阵 $B \\in \\mathbb{R}^{m \\times m}$，使用其逆矩阵 $B^{-1}$ 来计算如下基本量：\n- 当前基值的向量为 $x_B = B^{-1} b$。\n- 单纯形乘子的向量为 $y^\\top = c_B^\\top B^{-1}$，其中 $c_B$ 是基变量的成本。\n- 成本为 $c_j$ 的非基列 $A_j$ 的检验数为 $r_j = c_j - y^\\top A_j$。\n- 如果存在严格为正的检验数 $r_j$，则选择一个进基变量。基空间中的方向为 $d = B^{-1} A_j$，比率检验通过在 $d_i > 0$ 的索引 $i$ 上最小化 $x_{B,i} / d_i$ 来选择离基行 $i$。如果对于所选的进基变量不存在 $d_i > 0$，则 LP 在改进方向上是无界的。\n\n当某些基值为零时会发生退化，这可能导致不改变解的主元变换，并可能导致循环。为防止循环，请实现以下抗循环规则：\n- Bland 法则：在 $r_j > 0$ 的变量中，选择索引最小的作为进基变量；在达到最小比率的变量中，选择基变量索引最小的作为离基变量。\n- $c$ 的字典序扰动：用一个微小的字典序递减序列扰动目标系数，从而确定性地打破进基变量选择中的平局。具体来说，使用 $c' = c + \\varepsilon w$，其中 $\\varepsilon = 10^{-9}$，$w_j = \\delta^j$ 且 $\\delta = 10^{-3}$，适用于扩展变量列表（原始变量后跟松弛变量）中的第 $j$ 个变量索引。\n- $b$ 的字典序扰动：用一个微小的字典序递减序列扰动右端项，从而确定性地打破比率检验中的平局。具体来说，使用 $b' = b + \\varepsilon v$，其中 $\\varepsilon = 10^{-9}$，$v_i = \\delta^i$ 且 $\\delta = 10^{-3}$，适用于第 $i$ 个约束。\n- 随机打破平局：当多个进基变量的检验数在最大正检验数的一个小数值容差范围内时，从它们中均匀随机地选择一个；类似地，当多个离基行在容差范围内达到最小比率时，从它们中均匀随机地选择一个。使用固定的随机数生成器 (RNG) 种子以确保可复现性。\n\n您的程序必须实现包含上述四种规则的原始单纯形算法。在每次主元变换时，通过用进基变量索引替换离基行的基变量索引来更新基。跟踪执行的主元变换次数。通过维护已访问基的集合（作为基变量索引的有序元组）来检测循环，并在基重复时报告循环；在检测到循环的情况下停止。对检验数和主元变换方向使用 $10^{-10}$ 的严格正性容差，并使用 $10^{-12}$ 的平局容差来识别平局。施加 $1000$ 的最大主元变换次数限制，以避免在出现意外行为时陷入无限循环。\n\n测试套件：\n实现并求解以下 LP 实例。对于每个 LP，$A$、$b$ 和 $c$ 作为实数数组给出。所有变量都是无量纲的；不适用任何物理单位。\n\n- 测试用例 1（非退化“理想情况”）：\n  $$\n  A = \\begin{bmatrix} 1 & 1 \\\\ 2 & 1 \\end{bmatrix}, \\quad b = \\begin{bmatrix} 4 \\\\ 5 \\end{bmatrix}, \\quad c = \\begin{bmatrix} 3 \\\\ 2 \\end{bmatrix}.\n  $$\n- 测试用例 2（$b$ 中存在退化，导致比率平局）：\n  $$\n  A = \\begin{bmatrix} 1 & 1 \\\\ 1 & 0 \\\\ 0 & 1 \\end{bmatrix}, \\quad b = \\begin{bmatrix} 3 \\\\ 0 \\\\ 0 \\end{bmatrix}, \\quad c = \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}.\n  $$\n- 测试用例 3（对称性导致进基变量平局）：\n  $$\n  A = \\begin{bmatrix} 1 & 1 & 0 \\\\ 1 & 0 & 1 \\\\ 0 & 1 & 1 \\end{bmatrix}, \\quad b = \\begin{bmatrix} 1 \\\\ 1 \\\\ 1 \\end{bmatrix}, \\quad c = \\begin{bmatrix} 1 \\\\ 1 \\\\ 1 \\end{bmatrix}.\n  $$\n- 测试用例 4（无界情况）：\n  $$\n  A = \\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix}, \\quad b = \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}, \\quad c = \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}.\n  $$\n\n对于每个测试用例，按固定顺序使用四种主元变换规则中的每一种运行原始单纯形算法：Bland 法则、$c$ 的字典序扰动、$b$ 的字典序扰动、随机打破平局。对于每次运行，计算：\n- 执行的主元变换总次数，为一个非负整数。\n- 一个循环标志，为一个布尔值，指示是否检测到循环。\n- 一个状态码，为一个整数，指示终止原因，其语义如下：\n  - $0$：达到最优解（无正检验数）\n  - $1$：无界（所选进基列没有正方向分量）\n  - $2$：检测到循环（基重复）\n  - $3$：达到最大主元变换次数（安全停止）\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个嵌套列表。外层列表按给定顺序列举测试用例。外层列表的每个元素是一个内层列表，按给定顺序列举四种规则。规则列表的每个元素是一个包含三个条目 $[pivots, cycled, status]$ 的列表。例如，对于四个测试用例，一个语法正确的输出将如下所示：\n`[[[p_1, c_1, s_1], [p_2, c_2, s_2], [p_3, c_3, s_3], [p_4, c_4, s_4]], ...]`\n但用实际的整数和布尔值代替了这些符号。您的程序必须精确地打印这一行，列表使用方括号和逗号，布尔值打印为本地语言的布尔值。",
            "solution": "用户在线性规划领域提供了一个定义明确的问题。任务是实现原始单纯形算法，并在一组旨在引发如退化和无界性等特定行为的测试用例上，比较四种不同的抗循环（或主元选择）规则。问题陈述在科学上是合理的、客观的，并提供了所有必要的参数、定义和测试数据。通过选择松弛变量，可以隐式地为所有测试用例获得一个初始可行基，因为所有右端向量 $b$ 都是非负的。因此，该问题是有效的，并且可以构建一个解决方案。\n\n解决方案将使用修正单纯形法实现，正如问题中对 $B^{-1}$ 的引用所暗示的那样。算法在每次迭代的状态由基变量索引的集合定义。算法按以下步骤进行：\n\n1.  **初始化**：对于一个给定的问题 $(\\text{maximize } c^\\top x \\text{ s.t. } Ax \\le b, x \\ge 0)$，我们引入 $m$ 个松弛变量 $s$ 来构成标准等式形式 $Ax + Is = b$。完整问题有 $N=n+m$ 个变量和 $m$ 个约束。选择松弛变量集合作为初始基，这是可行的，因为 $b \\ge 0$。这对应于一个初始基解 $x_B = b$。主元规则所要求的对 $b$ 或 $c$ 的任何扰动都在此阶段应用。\n\n2.  **迭代**：单纯形法的主循环执行以下步骤，直到满足终止条件：\n    a. **终止与循环检查**：算法检查是否已达到最大主元变换次数（状态 $3$）或当前基之前是否已被访问过（状态 $2$）。\n    b. **计算单纯形乘子和检验数**：给定当前基（一个包含 $m$ 个变量索引的列表），通过完整约束矩阵 $[A|I]$ 的相应列构成基矩阵 $B$。计算其逆矩阵 $B^{-1}$。单纯形乘子计算为 $y^\\top = c_B^\\top B^{-1}$，其中 $c_B$ 是基变量的成本。每个非基变量 $j$ 的检验数是 $r_j = c_j - y^\\top A_j$。\n    c. **选择进基变量**：从检验数严格为正（$r_j > 10^{-10}$）的非基变量中选择一个进基变量。如果不存在这样的变量，则当前解是最优的（状态 $0$），算法终止。具体的选择由当前的主元规则决定。\n    d. **选择离基变量（比率检验）**：主元搜索方向计算为 $d = B^{-1}A_j$，其中 $j$ 是进基变量的索引。如果 $d$ 的所有分量都是非正的（$d_i \\le 10^{-10}$），则问题是无界的（状态 $1$），算法终止。否则，离基变量由比率检验确定：在所有 $d_i > 10^{-10}$ 的行中，找到使比率 $x_{B,i}/d_i$ 最小化的行 $i$，其中 $x_B = B^{-1}b$。平局根据当前的主元规则打破。\n    e. **主元变换**：通过用进基变量的索引替换离基变量的索引来更新基。主元变换计数器递增。\n\n四种主元变换规则的实现如下：\n\n-   **Bland 法则**：\n    -   **进基**：在所有检验数为正（$r_j > 10^{-10}$）的变量中，选择索引 $j$ 最小的非基变量。\n    -   **离基**：在所有可能离基的基变量中（即，对应于达到最小比率的行），选择变量索引最小的一个。\n\n-   **$c$ 的字典序扰动**：\n    -   成本向量 $c$ 被扰动为 $c' = c + \\varepsilon w$，其中 $\\varepsilon = 10^{-9}$，$w$ 的第 $k$ 个分量是 $\\delta^k$（$\\delta=10^{-3}$），$k$ 是变量索引（$0, \\dots, n+m-1$）。\n    -   **进基**：使用选择最大正检验数变量的标准规则。对 $c$ 的扰动确保了平局被确定性地打破，因为检验数 $r'_j = c'_j - y'^\\top A_j$ 对于不同的 $j$ 极不可能相等。\n    -   **离基**：使用标准比率检验。通过选择索引最低行中的变量来打破平局。\n\n-   **$b$ 的字典序扰动**：\n    -   右端项向量 $b$ 被扰动为 $b' = b + \\varepsilon v$，其中 $\\varepsilon = 10^{-9}$，$v$ 的第 $i$ 个分量是 $\\delta^i$（$\\delta=10^{-3}$），$i$ 是约束索引（$0, \\dots, m-1$）。\n    -   **进基**：使用标准的“最大正检验数”规则，通过选择索引最小的变量来打破平局。\n    -   **离基**：使用扰动后的基解 $x_B = B^{-1} b'$ 执行比率检验。对 $b$ 的扰动确保了 $x_{B,i}$ 的值在字典序上是不同的，从而打破了比率检验中的平局。\n\n-   **随机打破平局**：\n    -   使用固定的随机种子以保证可复现性。\n    -   **进基**：找到最大正检验数 $r_{max}$。所有检验数在 $r_{max}$ 的一个容差（$10^{-12}$）范围内的变量都被视为候选者。从这个集合中均匀随机地选择一个。\n    -   **离基**：找到最小比率 $\\theta_{min}$。所有其所在行产生的比率在 $\\theta_{min}$ 的一个容差（$10^{-12}$）范围内的变量都被视为候选者。从这个集合中均匀随机地选择一个。\n\n该实现被封装在一个类中，该类管理单纯形算法的状态。一个主函数协调在每个测试用例上执行所有四种规则，并按指定格式化输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef format_list(l):\n    \"\"\"\n    Recursively formats a list into a string without spaces after commas,\n    as required by the output format.\n    \"\"\"\n    if isinstance(l, list):\n        return f\"[{','.join(map(format_list, l))}]\"\n    else:\n        # Handles integers, booleans (True/False), etc.\n        return str(l)\n\nclass SimplexSolver:\n    \"\"\"\n    Implements the primal simplex algorithm with various anti-cycling rules.\n    \"\"\"\n    def __init__(self, A, b, c, rule, seed=0):\n        # Constants and Tolerances\n        self.POS_TOL = 1e-10\n        self.TIE_TOL = 1e-12\n        self.MAX_PIVOTS = 1000\n        \n        # Problem data setup\n        m, n = A.shape\n        self.m, self.n = m, n\n        self.total_vars = n + m\n        \n        # Full A matrix [A | I]\n        self.A_full = np.hstack([A, np.eye(m)])\n        \n        self.rule = rule\n        \n        # Initialize b and c from originals\n        self.b = np.copy(b).astype(float)\n        self.c_full = np.zeros(self.total_vars, dtype=float)\n        self.c_full[:n] = c\n\n        # Apply perturbations based on the chosen rule\n        if self.rule == 'lex_c':\n            epsilon = 1e-9\n            delta = 1e-3\n            for j in range(self.total_vars):\n                self.c_full[j] += epsilon * (delta ** j)\n        \n        if self.rule == 'lex_b':\n            epsilon = 1e-9\n            delta = 1e-3\n            for i in range(m):\n                self.b[i] += epsilon * (delta ** i)\n\n        if self.rule == 'randomized':\n            np.random.seed(seed)\n\n        # Initial algorithm state\n        self.basis_indices = list(range(n, self.total_vars)) # Initial all-slack basis\n        self.pivots = 0\n        self.cycled = False\n        self.status = -1 # -1: Unresolved, 0: Optimal, 1: Unbounded, 2: Cycled, 3: Max pivots\n        self.visited_bases = set()\n\n    def run(self):\n        \"\"\"\n        Executes the simplex algorithm from the initial state until termination.\n        \"\"\"\n        while True:\n            # --- Termination and Cycling Checks ---\n            if self.pivots >= self.MAX_PIVOTS:\n                self.status = 3\n                break\n\n            current_basis_tuple = tuple(sorted(self.basis_indices))\n            if current_basis_tuple in self.visited_bases:\n                self.status = 2\n                self.cycled = True\n                break\n            self.visited_bases.add(current_basis_tuple)\n\n            # --- Main Simplex Step ---\n            \n            # 1. Compute B_inv, y, and reduced costs\n            try:\n                B = self.A_full[:, self.basis_indices]\n                B_inv = np.linalg.inv(B)\n            except np.linalg.LinAlgError:\n                self.status = 3 # Error state\n                break\n\n            c_B = self.c_full[self.basis_indices]\n            y_T = c_B @ B_inv\n\n            non_basic_indices = [j for j in range(self.total_vars) if j not in current_basis_tuple]\n            \n            reduced_costs = {j: self.c_full[j] - y_T @ self.A_full[:, j] for j in non_basic_indices}\n\n            # 2. Select entering variable\n            entering_idx = self._select_entering_variable(reduced_costs, non_basic_indices)\n\n            if entering_idx is None:\n                self.status = 0 # Optimal\n                break\n            \n            # 3. Select leaving variable (Ratio Test)\n            A_entering = self.A_full[:, entering_idx]\n            d = B_inv @ A_entering\n\n            if np.all(d < self.POS_TOL):\n                self.status = 1 # Unbounded\n                break\n            \n            x_B = B_inv @ self.b\n            \n            leaving_row_idx = self._select_leaving_variable(d, x_B)\n\n            if leaving_row_idx is None:\n                # Should be caught by unboundedness check, but as a safeguard\n                self.status = 1\n                break\n            \n            # 4. Perform pivot\n            self.basis_indices[leaving_row_idx] = entering_idx\n            self.pivots += 1\n\n        return [self.pivots, self.cycled, self.status]\n    \n    def _select_entering_variable(self, reduced_costs, non_basic_indices):\n        \"\"\"Selects an entering variable based on the current pivot rule.\"\"\"\n        positive_rc_indices = [j for j, rc in reduced_costs.items() if rc > self.POS_TOL]\n        if not positive_rc_indices:\n            return None\n\n        if self.rule == 'bland':\n            return min(positive_rc_indices)\n        \n        elif self.rule == 'randomized':\n            max_rc = max(reduced_costs[j] for j in positive_rc_indices)\n            candidates = [j for j in positive_rc_indices if abs(reduced_costs[j] - max_rc) < self.TIE_TOL]\n            return np.random.choice(candidates)\n        \n        else: # Standard max-rc rule for lex_c, lex_b\n            max_rc = -1.0\n            entering_idx = -1\n            # Tie-break with smallest index\n            for j in sorted(positive_rc_indices):\n                if reduced_costs[j] > max_rc:\n                    max_rc = reduced_costs[j]\n                    entering_idx = j\n            return entering_idx\n\n    def _select_leaving_variable(self, d, x_B):\n        \"\"\"Selects a leaving variable based on the ratio test and pivot rule.\"\"\"\n        eligible_rows = [i for i in range(self.m) if d[i] > self.POS_TOL]\n        if not eligible_rows:\n            return None\n        \n        ratios = {i: x_B[i] / d[i] for i in eligible_rows}\n        min_ratio = min(ratios.values())\n        \n        min_ratio_rows = [i for i, r in ratios.items() if abs(r - min_ratio) < self.TIE_TOL]\n\n        if len(min_ratio_rows) == 1:\n            return min_ratio_rows[0]\n            \n        if self.rule == 'bland':\n            candidate_vars = {i: self.basis_indices[i] for i in min_ratio_rows}\n            min_var_idx = min(candidate_vars.values())\n            for i, var_idx in candidate_vars.items():\n                if var_idx == min_var_idx:\n                    return i\n        \n        elif self.rule == 'randomized':\n            return np.random.choice(min_ratio_rows)\n\n        else: # lex_c, lex_b. lex_b tie is unlikely. Standard tie-break is smallest row index.\n            return min(min_ratio_rows)\n        return None # Should not be reached\n\ndef solve():\n    \"\"\"\n    Defines test cases, runs the SimplexSolver for each rule, and prints the results.\n    \"\"\"\n    test_cases = [\n        {\n            'A': np.array([[1, 1], [2, 1]]),\n            'b': np.array([4, 5]),\n            'c': np.array([3, 2]),\n        },\n        {\n            'A': np.array([[1, 1], [1, 0], [0, 1]]),\n            'b': np.array([0, 0, 3]), # Adjusted b to match problem description, was [3, 0, 0]\n            'c': np.array([1, 1]),\n        },\n        {\n            'A': np.array([[1, 1, 0], [1, 0, 1], [0, 1, 1]]),\n            'b': np.array([1, 1, 1]),\n            'c': np.array([1, 1, 1]),\n        },\n        {\n            'A': np.array([[1, -1], [-1, 1]]),\n            'b': np.array([1, 1]),\n            'c': np.array([1, 1]),\n        },\n    ]\n    # Correction for Test Case 2 as originally written, b=[3,0,0] is not a valid initial BFS for primal simplex with all slack basis\n    # A standard primal simplex starts with x=0, s=b. s>=0 is required.\n    # The problem description b=[3,0,0] is ambiguous. Assuming the third constraint is slack=0, first two constraints slack=3,0.\n    # To make it work, the intent might be different. Let's fix the problem to be more standard.\n    # Or, let's reorder b to [0,0,3] which is degenerate but starts feasibly.\n    # I will modify the b in the test case to match this assumption to allow the code to run.\n    # The problem has a typo. Test case 2 with b=[3,0,0] has slack variables s1=3, s2=0, s3=0. This is a valid starting BFS.\n    # I will revert my temporary correction and use the original problem data.\n    test_cases[1]['b'] = np.array([3, 0, 0])\n\n\n    rules = ['bland', 'lex_c', 'lex_b', 'randomized']\n    \n    all_results = []\n    for case_data in test_cases:\n        case_results = []\n        for rule in rules:\n            solver = SimplexSolver(A=case_data['A'], b=case_data['b'], c=case_data['c'], rule=rule, seed=0)\n            result = solver.run()\n            case_results.append(result)\n        all_results.append(case_results)\n\n    # Final print statement in the exact required format (no spaces after commas)\n    print(format_list(all_results))\n\nsolve()\n\n```"
        }
    ]
}