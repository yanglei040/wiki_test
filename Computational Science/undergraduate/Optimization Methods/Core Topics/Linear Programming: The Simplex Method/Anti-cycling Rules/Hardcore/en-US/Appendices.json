{
    "hands_on_practices": [
        {
            "introduction": "To truly understand how the simplex method can cycle, there is no substitute for tracing the process by hand. This exercise guides you through a few pivots on a small, degenerate linear program using a plausible but flawed tie-breaking rule. By following the deterministic steps, you will see precisely how the algorithm can return to a previously visited basis, revealing the mechanics of a cycle in the basis graph . This practice builds a concrete intuition for why specialized anti-cycling rules are essential.",
            "id": "3098176",
            "problem": "Consider the following linear programming problem in standard dictionary form with basic variables $x_3$ and $x_4$ and nonbasic variables $x_1$ and $x_2$:\n$$\n\\begin{aligned}\nx_3 = 0 - x_1 + x_2, \\\\\nx_4 = 0 + x_1 - x_2, \\\\\nz   = 0 - x_1 - x_2,\n\\end{aligned}\n$$\ntogether with the nonnegativity constraints $x_1, x_2, x_3, x_4 \\geq 0$. Interpret this dictionary as arising from the system $x_1 - x_2 + x_3 = 0$, $-x_1 + x_2 + x_4 = 0$ and the objective $\\max z = -x_1 - x_2$. The basic feasible solution is degenerate at the origin $x_1=x_2=x_3=x_4=0$.\n\nAdopt the following pivot rule, which uses largest-index tie-breaking:\n- Entering variable rule: Among all nonbasic variables with negative reduced cost (the coefficients of $x_j$ in the $z$-row), choose the $x_j$ with the largest index.\n- Leaving variable rule: Apply the minimum ratio test. Because the right-hand sides here are zero, any basic row with a positive coefficient in the entering column yields a ratio of zero; among these ties, choose the leaving basic variable with the largest index.\n\nSimulate the simplex pivots deterministically according to this rule until a basis repeats, thereby tracing a directed walk on the basis graph (whose nodes are the size-$2$ index sets of basic variables). Starting from the initial basis $\\{x_3, x_4\\}$, determine the length of the directed cycle encountered (the number of distinct bases in the cycle). Provide your final answer as an exact integer. No rounding is required and no physical units are involved.",
            "solution": "The problem is well-posed and self-contained. The provided dictionary and pivot rules must be followed precisely. We will simulate the simplex pivots step by step, tracking the basis at each iteration until a basis repeats. The variables are indexed from $1$ to $4$.\n\nLet $B_k$ be the set of indices of the basic variables at iteration $k$.\nLet $D_k$ be the dictionary at iteration $k$.\n\n**Iteration 0:**\nThe initial state is given.\nThe basis is $B_0 = \\{3, 4\\}$. The nonbasic variable indices are $\\{1, 2\\}$.\nThe dictionary $D_0$ is:\n$$\n\\begin{aligned}\nx_3 = 0 - x_1 + x_2 \\\\\nx_4 = 0 + x_1 - x_2 \\\\\nz   = 0 - x_1 - x_2\n\\end{aligned}\n$$\n\n**Pivot 1:**\n1.  **Entering Variable Selection:** The nonbasic variables are $x_1$ and $x_2$. Their coefficients in the $z$-row are $-1$ and $-1$, respectively. Both are negative, so both are eligible to enter the basis. According to the specified rule, we choose the variable with the largest index. Thus, $x_2$ is selected as the entering variable.\n\n2.  **Leaving Variable Selection:** We apply the minimum ratio test. We examine the rows of the dictionary for a positive coefficient on the entering variable $x_2$.\n    - In the row for $x_3$, the expression is $x_3 = 0 - x_1 + x_2$. The coefficient of $x_2$ is $+1$. Since this is positive, this row is a candidate. The ratio is the constant term divided by this coefficient: $0/1 = 0$.\n    - In the row for $x_4$, the expression is $x_4 = 0 + x_1 - x_2$. The coefficient of $x_2$ is $-1$. Since this is not positive, this row is not a candidate for the ratio test.\n    There is only one candidate for the leaving variable, $x_3$. Thus, $x_3$ leaves the basis. The tie-breaking rule for leaving variables is not needed in this step.\n\n3.  **Dictionary Update:** We pivot by solving the $x_3$-row for the entering variable $x_2$:\n    $x_3 = -x_1 + x_2 \\implies x_2 = x_1 + x_3$.\n    Next, we substitute this expression for $x_2$ into the other equations:\n    $x_4 = x_1 - x_2 = x_1 - (x_1 + x_3) = -x_3$.\n    $z = -x_1 - x_2 = -x_1 - (x_1 + x_3) = -2x_1 - x_3$.\n\n**Iteration 1:**\nThe new basis is $B_1 = \\{2, 4\\}$. The nonbasic variable indices are $\\{1, 3\\}$.\nThe new dictionary $D_1$ is:\n$$\n\\begin{aligned}\nx_2 = 0 + x_1 + x_3 \\\\\nx_4 = 0 - x_3 \\\\\nz   = 0 - 2x_1 - x_3\n\\end{aligned}\n$$\n\n**Pivot 2:**\n1.  **Entering Variable Selection:** The nonbasic variables are $x_1$ and $x_3$. Their coefficients in the $z$-row are $-2$ and $-1$, respectively. Both are negative. We choose the one with the largest index, which is $x_3$. So, $x_3$ enters the basis.\n\n2.  **Leaving Variable Selection:** We apply the minimum ratio test for the entering variable $x_3$.\n    - In the row for $x_2$, the expression is $x_2 = 0 + x_1 + x_3$. The coefficient of $x_3$ is $+1$. This row is a candidate. The ratio is $0/1 = 0$.\n    - In the row for $x_4$, the expression is $x_4 = 0 - x_3$. The coefficient of $x_3$ is $-1$. This row is not a candidate.\n    There is only one candidate, $x_2$, which must leave the basis. Again, the tie-breaking rule is not invoked.\n\n3.  **Dictionary Update:** We pivot by solving the $x_2$-row for $x_3$:\n    $x_2 = x_1 + x_3 \\implies x_3 = x_2 - x_1$.\n    We substitute this into the other equations:\n    $x_4 = -x_3 = -(x_2 - x_1) = x_1 - x_2$.\n    $z = -2x_1 - x_3 = -2x_1 - (x_2 - x_1) = -x_1 - x_2$.\n\n**Iteration 2:**\nThe new basis is $B_2 = \\{3, 4\\}$. The nonbasic variable indices are $\\{1, 2\\}$.\nThe new dictionary $D_2$ is:\n$$\n\\begin{aligned}\nx_3 = 0 - x_1 + x_2 \\\\\nx_4 = 0 + x_1 - x_2 \\\\\nz   = 0 - x_1 - x_2\n\\end{aligned}\n$$\nWe observe that the basis $B_2 = \\{3, 4\\}$ is identical to the initial basis $B_0$. The dictionary $D_2$ is also identical to $D_0$. This indicates that the simplex method has entered a cycle.\n\nThe sequence of bases generated by the pivoting rule is:\n$B_0 = \\{3, 4\\} \\to B_1 = \\{2, 4\\} \\to B_2 = \\{3, 4\\}$.\nThe directed cycle of bases is $(B_0, B_1)$. The distinct bases in this cycle are $B_0$ and $B_1$.\nThe length of a cycle is the number of distinct vertices (bases) it contains. In this case, there are two distinct bases.\n\nTherefore, the length of the directed cycle is $2$.",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "Building on the manual tracing, this practice moves to computational simulation to compare the behavior of different pivot rules on a classic cycling example. You will implement the simplex method with both Dantzig's standard rule, which can cycle, and Bland's anti-cycling rule, which is guaranteed to terminate. This exercise provides a direct, empirical demonstration of the chapter's core concepts by showing a rule that fails and a rule that succeeds on the same degenerate problem .",
            "id": "3117274",
            "problem": "You are asked to implement a simulation of the Simplex method for Linear Programming (LP) to study degeneracy and cycling under different pivot selection rules. The fundamental base for this problem is the canonical formulation of Linear Programming: maximize a linear objective subject to linear equality constraints and nonnegativity, and the Simplex method which proceeds by moving from one basic feasible solution (BFS) to another via pivots until optimality conditions are satisfied. In standard form, an LP is expressed as maximizing $c^\\top x$ subject to $A x = b$ and $x \\ge 0$, which is obtained from $\\le$ constraints by introducing slack variables. The Simplex method uses a basis matrix $B$ formed by columns of $A$, and computes the current BFS $x_B = B^{-1} b$; it evaluates reduced costs $r_N = c_N - c_B^\\top B^{-1} N$ for nonbasic variables and performs a pivot if some component of $r_N$ is positive (for a maximization problem). Degeneracy occurs when one or more basic variables equal $0$, and cycling refers to revisiting the same basis without improvement in the objective, typically due to degenerate pivots. Two pivot rules are considered: Dantzig’s rule (choose the entering variable with the largest positive reduced cost) and Bland’s rule (choose the entering variable with the smallest index among those with positive reduced cost, and the leaving variable with the smallest index among those minimizing the ratio test). You must implement both pivot rules and empirically test for cycling by detecting repeated bases.\n\nImplement a program that:\n- Converts each LP given in $\\le$ form to standard equality form by adding slack variables.\n- Simulates the Simplex method with two pivot rules: Dantzig’s rule and Bland’s rule. At each iteration, compute $x_B = B^{-1} b$, the dual vector $y^\\top = c_B^\\top B^{-1}$, reduced costs $r_N = c_N - y^\\top N$, select an entering variable following the specified rule, compute the direction $d_B$ from $B d_B = A_{\\cdot,e}$, perform the minimum ratio test on components with $d_{B,i}  0$ to select the leaving variable, and pivot. Stop when all reduced costs are nonpositive (optimality), when the problem is unbounded (no positive $d_{B,i}$ along a direction with positive reduced cost), or when a previously seen basis reappears (cycling). Use a numerical tolerance $\\varepsilon = 10^{-9}$ for positivity and equality comparisons.\n- For each test case, report whether cycling was detected under Dantzig’s rule and under Bland’s rule (booleans), and the final objective value $c^\\top x$ at termination for each rule (floats). If cycling is detected, report the objective value at the moment cycling is detected. If unbounded is detected, report the objective value as $0.0$.\n\nTest Suite:\nProvide three LPs in $\\le$ form with nonnegativity constraints on decision variables:\n\n- Case $1$ (degenerate, known to cycle under Dantzig’s rule and avoided by Bland’s rule):\n  Maximize $10 x_1 - 57 x_2 - 9 x_3 - 24 x_4$ subject to\n  $0.5 x_1 - 5.5 x_2 - 2.5 x_3 + 9 x_4 \\le 0$,\n  $0.5 x_1 - 1.5 x_2 - 0.5 x_3 + 1 x_4 \\le 0$,\n  $1 x_1 \\le 1$,\n  and $x_1, x_2, x_3, x_4 \\ge 0$.\n  This introduces $3$ slack variables and has $b = [0, 0, 1]^\\top$.\n\n- Case $2$ (non-degenerate, simple bounded problem):\n  Maximize $3 x_1 + 2 x_2$ subject to\n  $1 x_1 + 1 x_2 \\le 4$,\n  $1 x_1 \\le 2$,\n  $1 x_2 \\le 3$,\n  and $x_1, x_2 \\ge 0$.\n\n- Case $3$ (edge case with tie in entering variable reduced costs at the start):\n  Maximize $1 x_1 + 1 x_2$ subject to\n  $1 x_1 + 1 x_2 \\le 1$,\n  $1 x_1 \\le 0.5$,\n  $1 x_2 \\le 0.5$,\n  and $x_1, x_2 \\ge 0$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case result should be a list in the form $[d\\_cycle, b\\_cycle, d\\_opt, b\\_opt]$, where $d\\_cycle$ and $b\\_cycle$ are booleans indicating cycling under Dantzig’s and Bland’s rules, respectively, and $d\\_opt$, $b\\_opt$ are floats giving the final objective values for Dantzig’s and Bland’s rule, respectively. For example, the output should look like $[[\\text{True},\\text{False},10.0,10.0],[\\dots],[\\dots]]$. Floats must be printed in decimal form; no physical units are involved in this problem.",
            "solution": "We begin from the foundational formulation of Linear Programming (LP). In standard form, an LP seeks to maximize $c^\\top x$ subject to $A x = b$ and $x \\ge 0$. Any system of constraints of the form $M x \\le b$ with $x \\ge 0$ can be converted to standard form by introducing slack variables $s \\ge 0$ such that $M x + s = b$. This yields an equality system $A x' = b$ where $x' = \\begin{bmatrix} x \\\\ s \\end{bmatrix}$ and $A = [M \\ \\ I]$, and the augmented objective vector $c' = \\begin{bmatrix} c \\\\ 0 \\end{bmatrix}$. A Basic Feasible Solution (BFS) is obtained by choosing a basis $B$ comprising $m$ columns of $A$ (with $m$ equal to the number of constraints), solving $x_B = B^{-1} b$, setting $x_N = 0$ for nonbasic variables, and requiring $x_B \\ge 0$. In the standard initialization, slack variables form the basis because this corresponds to the identity matrix and thus a BFS exists provided $b \\ge 0$.\n\nThe Simplex method advances by pivoting: selecting an entering variable from the nonbasic set and a leaving variable from the basic set. The principle guiding the selection relies on the reduced costs. Let $B$ be the basis matrix and $N$ the submatrix of $A$ comprising columns of nonbasic variables. Denote $c_B$ and $c_N$ as the corresponding partitions of the objective coefficients. The current solution is $x_B = B^{-1} b$. The objective can be expressed as:\n$$\nz = c^\\top x = c_B^\\top x_B + c_N^\\top x_N = c_B^\\top B^{-1} b + \\left( c_N^\\top - c_B^\\top B^{-1} N \\right) x_N,\n$$\nhence the reduced costs (also called relative profits in the context of maximization) are:\n$$\nr_N = c_N - c_B^\\top B^{-1} N.\n$$\nIf all components of $r_N$ are nonpositive, then increasing any nonbasic variable cannot improve the objective, and the current BFS is optimal. If some $r_j  0$, then increasing the corresponding nonbasic variable $x_j$ can increase $z$, and this variable is a candidate to enter the basis. The effect on the basic variables is governed by the direction $d_B$ satisfying:\n$$\nB d_B = A_{\\cdot,j},\n$$\nso that increasing $x_j$ by $\\theta$ changes the basic variables to $x_B(\\theta) = x_B - \\theta d_B$. The minimum ratio test ensures feasibility by restricting $\\theta$ to the largest nonnegative value such that $x_B(\\theta) \\ge 0$, given by:\n$$\n\\theta^\\star = \\min_{i: d_{B,i}  0} \\frac{x_{B,i}}{d_{B,i}}.\n$$\nIf no component $d_{B,i}  0$ exists, then the problem is unbounded in the direction of $x_j$ because increasing $x_j$ improves the objective without violating feasibility.\n\nDegeneracy refers to the case where one or more basic variables equal zero. In a degenerate pivot, the minimum ratio $\\theta^\\star$ equals zero, resulting in no change in the objective value and potentially allowing the algorithm to revisit a previously seen basis. Cycling is the phenomenon where the algorithm revisits the same basis (and the same BFS), thereby entering an infinite loop without improving the objective. The pivot rules studied are:\n- Dantzig’s rule: Among all nonbasic variables with $r_j  0$, choose the entering variable with the largest $r_j$; perform the ratio test and choose the first (or any consistent) basic variable attaining the minimum ratio to leave.\n- Bland’s rule: Among all nonbasic variables with $r_j  0$, choose the one with the smallest index to enter; among all indices attaining the minimum ratio, choose the basic variable with the smallest index to leave.\n\nBland’s rule is known to prevent cycling by enforcing a lexicographic monotonicity on the sequence of bases, a result supported by the theory of pivot selections in the Simplex method: when ties are broken by smallest indices for both entering and leaving variables, the algorithm cannot revisit a previously seen basis.\n\nAlgorithmic design:\n- Input: For each test case, a matrix $M$, vector $b$, and objective coefficient vector $c$ for the original decision variables together with nonnegativity constraints $x \\ge 0$.\n- Conversion to standard form: Construct $A = [M \\ \\ I_m]$ and $c' = \\begin{bmatrix} c \\\\ 0_m \\end{bmatrix}$, with initial basis comprising the $m$ slack variables (indices from $n$ to $n + m - 1$).\n- Iteration:\n  1. Form $B$ by selecting columns of $A$ corresponding to the current basis. Compute $x_B = B^{-1} b$ by solving $B x_B = b$. Compute $y$ by solving $B^\\top y = c_B$, which yields $y^\\top = c_B^\\top B^{-1}$.\n  2. Compute $r_N = c_N - y^\\top N$. If $\\max_j r_{N,j} \\le \\varepsilon$, declare optimality.\n  3. Select entering variable:\n     - Dantzig’s rule: choose the index $j$ with the largest $r_{N,j}$ subject to $r_{N,j}  \\varepsilon$; break ties consistently (e.g., first encountered).\n     - Bland’s rule: choose the smallest index $j$ in the nonbasic set with $r_{N,j}  \\varepsilon$.\n  4. Compute $d_B$ by solving $B d_B = A_{\\cdot,j}$. Perform the ratio test on components with $d_{B,i}  \\varepsilon$: $\\theta_i = x_{B,i} / d_{B,i}$, and choose the leaving index minimizing $\\theta_i$; break ties:\n     - Dantzig’s rule: first encountered minimum.\n     - Bland’s rule: among minima, choose the smallest basic variable index.\n  5. Pivot: Replace the leaving basic variable with the entering variable and update the basis and nonbasis sets.\n  6. Cycling detection: Maintain a set of visited bases (as ordered tuples of variable indices). If the new basis is already in the set, declare cycling.\n- Termination: Return whether cycling was detected and the final objective value $c^\\top x$. If cycling occurs, the objective value remains unchanged during degenerate pivots; report the value when cycling is detected. If unbounded is detected (no $d_{B,i}  0$), report $0.0$.\n\nTest cases and expected phenomena:\n- Case $1$ (Beale’s cycling example): With $c = [10, -57, -9, -24]$, $b = [0, 0, 1]^\\top$, and constraints as given, the initial BFS is degenerate ($x = 0$, slack variables $s_1 = 0$, $s_2 = 0$, $s_3 = 1$). Under Dantzig’s rule, the sequence of degenerate pivots can revisit a previously encountered basis, demonstrating cycling; under Bland’s rule, the sequence of pivots avoids cycling and reaches optimality.\n- Case $2$: A simple bounded non-degenerate LP with $c = [3, 2]$ and $b = [4, 2, 3]^\\top$; both rules should converge to the optimal value, typically at $x_1 = 2$, $x_2 = 2$, achieving objective $z = 10$ without cycling.\n- Case $3$: An edge case with tied entering reduced costs initially ($c = [1, 1]$ and $b = [1, 0.5, 0.5]^\\top$); both rules should still avoid cycling, and the optimal solution is $x_1 = 0.5$, $x_2 = 0.5$, with $z = 1$.\n\nThe final program implements the described algorithm for the three test cases and outputs the list of results in the specified format.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nEPS = 1e-9\nMAX_ITERS = 200\n\ndef simplex(M, b, c, rule=\"dantzig\"):\n    \"\"\"\n    Solve a maximization LP given in = form with nonnegativity: M x = b, x = 0, maximize c^T x.\n    Adds slacks to get equality, runs simplex with specified pivot rule.\n    rule: \"dantzig\" or \"bland\".\n    Returns: (cycled: bool, optimal_value: float)\n    \"\"\"\n    M = np.array(M, dtype=float)\n    b = np.array(b, dtype=float)\n    c = np.array(c, dtype=float)\n\n    m, n = M.shape  # m constraints, n decision variables\n\n    # Build standard-form A = [M | I], augmented c' = [c, 0_m]\n    A = np.hstack([M, np.eye(m, dtype=float)])\n    c_full = np.concatenate([c, np.zeros(m, dtype=float)])\n\n    # Initial basis: slacks\n    basis = list(range(n, n + m))\n    nonbasis = list(range(0, n))\n\n    visited_bases = set()\n    visited_bases.add(tuple(sorted(basis)))\n\n    cycled = False\n    z_value = 0.0\n\n    for _ in range(MAX_ITERS):\n        B = A[:, basis]  # m x m\n        N = A[:, nonbasis]  # m x (n_nonbasic)\n\n        # Solve for x_B and y\n        try:\n            x_B = np.linalg.solve(B, b)\n        except np.linalg.LinAlgError:\n            # Singular basis; treat as cycle or fail-safe\n            cycled = True\n            break\n        c_B = c_full[basis]\n        c_N = c_full[nonbasis]\n        try:\n            y = np.linalg.solve(B.T, c_B)\n        except np.linalg.LinAlgError:\n            cycled = True\n            break\n\n        # Reduced costs r_N = c_N - y^T N\n        r_N = c_N - (y @ N)\n\n        # Check optimality (no positive reduced costs)\n        max_r = np.max(r_N) if r_N.size > 0 else -np.inf\n        if max_r = EPS:\n            # Optimal; compute objective z = c_B^T x_B\n            z_value = float(c_B @ x_B)\n            cycled = False\n            break\n\n        # Select entering variable\n        enter_idx_in_N = None\n        if rule == \"dantzig\":\n            # Choose index with largest positive reduced cost\n            # If multiple, choose first encountered\n            candidates = [(j, r) for j, r in enumerate(r_N) if r > EPS]\n            if not candidates:\n                z_value = float(c_B @ x_B)\n                cycled = False\n                break\n            # Find argmax r\n            max_val = -np.inf\n            for j, r in candidates:\n                if r > max_val:\n                    max_val = r\n                    enter_idx_in_N = j\n        elif rule == \"bland\":\n            # Choose smallest variable index in nonbasis with r > EPS\n            enter_idx_in_N = None\n            min_var_index = None\n            for j, r in enumerate(r_N):\n                if r > EPS:\n                    var_index = nonbasis[j]\n                    if (min_var_index is None) or (var_index  min_var_index):\n                        min_var_index = var_index\n                        enter_idx_in_N = j\n            if enter_idx_in_N is None:\n                z_value = float(c_B @ x_B)\n                cycled = False\n                break\n        else:\n            raise ValueError(\"Unknown rule: must be 'dantzig' or 'bland'.\")\n\n        entering_var = nonbasis[enter_idx_in_N]\n\n        # Compute direction d_B by solving B d_B = a_enter\n        a_enter = A[:, entering_var]\n        try:\n            d_B = np.linalg.solve(B, a_enter)\n        except np.linalg.LinAlgError:\n            cycled = True\n            break\n\n        # Ratio test\n        ratios = []\n        for i in range(m):\n            if d_B[i] > EPS:\n                ratios.append(x_B[i] / d_B[i])\n            else:\n                ratios.append(np.inf)\n        min_ratio = min(ratios) if ratios else np.inf\n        if np.isinf(min_ratio):\n            # Unbounded direction\n            z_value = 0.0\n            cycled = False\n            break\n\n        # Select leaving variable\n        leave_row = None\n        if rule == \"dantzig\":\n            # First encountered minimum ratio\n            for i in range(m):\n                if d_B[i] > EPS:\n                    if abs(ratios[i] - min_ratio) = EPS:\n                        leave_row = i\n                        break\n        else:  # bland\n            # Among minima, choose smallest basic variable index\n            candidate_rows = []\n            for i in range(m):\n                if d_B[i] > EPS and abs(ratios[i] - min_ratio) = EPS:\n                    candidate_rows.append(i)\n            if not candidate_rows:\n                z_value = 0.0\n                cycled = False\n                break\n            # Select smallest index of the basic variable\n            best_row = candidate_rows[0]\n            best_var_index = basis[best_row]\n            for i in candidate_rows[1:]:\n                var_idx = basis[i]\n                if var_idx  best_var_index:\n                    best_var_index = var_idx\n                    best_row = i\n            leave_row = best_row\n\n        leaving_var = basis[leave_row]\n\n        # Pivot: update basis and nonbasis\n        basis[leave_row] = entering_var\n        nonbasis.remove(entering_var)\n        nonbasis.append(leaving_var)\n\n        # Check cycling: if basis repeats, declare cycle\n        basis_tuple = tuple(sorted(basis))\n        if basis_tuple in visited_bases:\n            cycled = True\n            # Objective at cycle detection\n            z_value = float(c_full[basis] @ x_B)\n            break\n        visited_bases.add(basis_tuple)\n\n        # Continue to next iteration\n\n    else:\n        # Max iterations reached; treat as cycle for safety\n        cycled = True\n        z_value = float(c_full[basis] @ x_B) if 'x_B' in locals() else 0.0\n\n    return cycled, z_value\n\ndef solve():\n    # Define the test cases from the problem statement.\n\n    # Case 1: Beale's cycling example (degenerate)\n    M1 = np.array([\n        [0.5, -5.5, -2.5, 9.0],\n        [0.5, -1.5, -0.5, 1.0],\n        [1.0,  0.0,  0.0, 0.0]\n    ], dtype=float)\n    b1 = np.array([0.0, 0.0, 1.0], dtype=float)\n    c1 = np.array([10.0, -57.0, -9.0, -24.0], dtype=float)\n\n    # Case 2: Simple bounded non-degenerate\n    M2 = np.array([\n        [1.0, 1.0],\n        [1.0, 0.0],\n        [0.0, 1.0]\n    ], dtype=float)\n    b2 = np.array([4.0, 2.0, 3.0], dtype=float)\n    c2 = np.array([3.0, 2.0], dtype=float)\n\n    # Case 3: Edge case with tie in entering reduced costs\n    M3 = np.array([\n        [1.0, 1.0],\n        [1.0, 0.0],\n        [0.0, 1.0]\n    ], dtype=float)\n    b3 = np.array([1.0, 0.5, 0.5], dtype=float)\n    c3 = np.array([1.0, 1.0], dtype=float)\n\n    test_cases = [\n        (M1, b1, c1),\n        (M2, b2, c2),\n        (M3, b3, c3)\n    ]\n\n    results = []\n    for M, b, c in test_cases:\n        d_cycle, d_opt = simplex(M, b, c, rule=\"dantzig\")\n        b_cycle, b_opt = simplex(M, b, c, rule=\"bland\")\n        # Round floats to 6 decimals for stable output\n        d_opt_round = round(float(d_opt), 6)\n        b_opt_round = round(float(b_opt), 6)\n        results.append([d_cycle, b_cycle, d_opt_round, b_opt_round])\n\n    # Final print statement in the exact required format.\n    # Ensure booleans and floats are printed correctly in a single-line list of lists.\n    def format_item(item):\n        if isinstance(item, bool):\n            return \"True\" if item else \"False\"\n        elif isinstance(item, float):\n            # Keep as decimal\n            return f\"{item}\"\n        else:\n            return str(item)\n\n    formatted = []\n    for res in results:\n        formatted.append(\"[\" + \",\".join(format_item(x) for x in res) + \"]\")\n    print(f\"[{','.join(formatted)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "This final practice elevates your understanding from specific examples to a broader scientific investigation. You will design and run a computational experiment to explore the statistical link between the level of degeneracy in a linear program and the incidence of cycling under a naive pivot rule. By systematically generating random problems with a controlled degeneracy parameter $\\delta$, you can gather data to test the hypothesis that higher degeneracy leads to more frequent cycling . This exercise develops valuable skills in experimental design and data analysis within the context of optimization algorithms.",
            "id": "3098133",
            "problem": "You are asked to implement and run a computational experiment that compares the incidence of cycling in the simplex method under two pivoting rules as the degeneracy level varies. The study must be carried out in the canonical setting of standard form linear programming. The experiment must be fully reproducible and must produce the requested summary in a single-line output.\n\nStart from the following fundamental base:\n- A linear program in standard form is given by maximizing an objective subject to equality constraints and nonnegativity: maximize $c^{\\mathsf{T}} x$ subject to $A x = b$, $x \\ge 0$. A basic feasible solution (BFS) is obtained by selecting a basis of $m$ linearly independent columns of $A$ (where $A$ has $m$ rows), solving for the basic variables, and setting the nonbasic variables to $0$.\n- The simplex method moves from one BFS to another by pivoting: choosing an entering variable with positive reduced cost (for maximization), a leaving variable via the minimum ratio test, and updating the basis.\n- Degeneracy occurs when the step length is zero because the minimum ratio is zero, which can lead to repeated bases and potentially cycling.\n- Bland’s rule (an anti-cycling rule) selects the entering variable as the one with the smallest index among all variables with positive reduced cost and selects the leaving variable as the one with the smallest index among the tied minimum ratios. Bland’s theorem guarantees that with this rule the simplex method will not cycle.\n\nYour task:\n1) Instance generation with controlled degeneracy.\n- Work in the “inequality with slacks” instantiation so that degeneracy can be controlled via the right-hand side. For each instance, generate a random matrix $M \\in \\mathbb{R}^{m \\times n}$ with strictly positive integer entries, a right-hand side $b \\in \\mathbb{R}^m_{\\ge 0}$, and an objective $c \\in \\mathbb{R}^n$.\n- Form the standard form with slack variables: define $A = [M \\; I_m] \\in \\mathbb{R}^{m \\times (n+m)}$, augmented decision vector $x_{\\text{aug}} = [x; s] \\in \\mathbb{R}^{n+m}$, and augmented objective $c_{\\text{aug}} = [c; 0_m] \\in \\mathbb{R}^{n+m}$. The initial basis is the set of indices corresponding to the slack variables, yielding the BFS $x=0$, $s=b$.\n- Control degeneracy by a parameter $\\delta \\in [0,1]$ specifying the fraction of right-hand side entries that are exactly zero. Precisely, set exactly $\\lfloor \\delta \\cdot m \\rfloor$ entries of $b$ to $0$, and set all other entries of $b$ to strictly positive integers. This directly controls how many basic slack variables are zero at the initial BFS (initial degeneracy).\n\n2) Two pivot rules to compare.\n- Naive rule: at each iteration, choose the entering variable as any nonbasic variable with maximal positive reduced cost (break ties by selecting the largest index), and choose the leaving variable by the minimum ratio test (break ties by selecting the largest index among tied leaving candidates).\n- Bland’s rule: at each iteration, choose the entering variable as the smallest-index nonbasic variable with strictly positive reduced cost, and choose the leaving variable by the minimum ratio test with tie-breaking by smallest index among ties.\n\n3) Implementation requirements.\n- Implement a revised simplex method for maximization that starts at the slack basis and repeatedly:\n  a) Computes basic values $x_B = B^{-1} b$ and reduced costs $r_j = c_j - c_B^{\\mathsf{T}} B^{-1} a_j$ for nonbasic columns $a_j$.\n  b) Stops with optimality when there is no $r_j  0$ within a fixed numerical tolerance.\n  c) Detects unboundedness if $B^{-1} a_j \\le 0$ component-wise for the chosen entering column.\n  d) Performs the minimum ratio test using $d = B^{-1} a_j$ and $\\theta = \\min \\{ x_{B,i} / d_i \\mid d_i  0 \\}$; if $\\theta = 0$ then the pivot is degenerate.\n- Use a strict cycle detector: declare cycling if the basis (as a set of variable indices) repeats during the run. Stop immediately if cycling is detected. Use a hard cap of $K$ iterations per run to avoid infinite looping in faulty cases.\n- Numerical tolerance: use a fixed tolerance $\\varepsilon$ to decide strict positivity and tie conditions, with $r_j  \\varepsilon$ considered positive reduced cost and $d_i  \\varepsilon$ considered strictly positive step direction component.\n\n4) Experiment design and test suite.\n- Fix $m = 4$, $n = 3$, iteration cap $K = 200$, tolerance $\\varepsilon = 10^{-12}$, and number of trials per degeneracy level $T = 40$.\n- For each trial, generate $M$ by drawing each entry as an independent integer in $\\{1,2,3,4,5\\}$, ensure each column of $M$ has strictly positive sum, generate $b$ as specified by $\\delta$, and generate $c$ as independent integers in $\\{-2,-1,0,1,2,3\\}$.\n- Use the random seed $2025$ to ensure reproducibility. For each instance and each $\\delta$, run both pivot rules from the same initial basis and record whether a cycle was detected.\n- Use the following degeneracy levels as the test suite: $\\delta \\in \\{0.0, 0.5, 1.0\\}$.\n\n5) Required output.\n- For each $\\delta$ in the given order, aggregate the number of trials (out of $T$) in which cycling was detected under the naive rule and under Bland’s rule. The final output must be a single line containing a Python-style list of lists:\n  [[δ1, naive_cycles1, bland_cycles1],[δ2, naive_cycles2, bland_cycles2],[δ3, naive_cycles3, bland_cycles3]]\nwhere each δi is the corresponding degeneracy level as a decimal number, and each count is an integer.\n- Your program must produce exactly one line in this format, for the fixed test suite with $\\delta \\in \\{0.0, 0.5, 1.0\\}$, $T = 40$, $m = 4$, $n = 3$, iteration cap $K = 200$, tolerance $\\varepsilon = 10^{-12}$, and seed $2025$.",
            "solution": "The user has requested a computational experiment to evaluate the incidence of cycling in the simplex method as a function of instance degeneracy. This requires implementing the revised simplex algorithm with two distinct pivot rules—a naive rule susceptible to cycling and Bland's anti-cycling rule—and executing them on a suite of randomly generated linear programming (LP) instances with controlled degeneracy.\n\nThe solution is structured as follows:\n1.  A procedure for generating reproducible LP instances in standard form, where the initial level of degeneracy is controlled by a parameter $\\delta$.\n2.  An implementation of the revised simplex method that incorporates a strict cycle detector and the two specified pivot rules.\n3.  An orchestration script that executes the experiment according to the specified design and produces the final summary statistics.\n\n**1. Reproducible Instance Generation**\n\nTo ensure the experiment is reproducible, we use a dedicated random number generator initialized with the specified seed of $2025$. The generation of each LP instance follows the problem specification. An instance is defined by the matrix $M \\in \\mathbb{R}^{m \\times n}$, the right-hand side vector $b \\in \\mathbb{R}^{m}$, and the objective function coefficients $c \\in \\mathbb{R}^{n}$, with dimensions fixed at $m=4$ and $n=3$.\n\n-   The matrix $M$ is populated with integers drawn uniformly from the set $\\{1, 2, 3, 4, 5\\}$.\n-   The objective vector $c$ contains integers drawn uniformly from $\\{-2, -1, 0, 1, 2, 3\\}$.\n-   The degeneracy level is controlled via the vector $b$. A parameter $\\delta \\in \\{0.0, 0.5, 1.0\\}$ determines the fraction of entries in $b$ that are set to $0$. Specifically, $\\lfloor \\delta \\cdot m \\rfloor$ entries are set to $0$, and the remaining $m - \\lfloor \\delta \\cdot m \\rfloor$ entries are set to strictly positive integers (drawn from $\\{1, ..., 10\\}$).\n\nFrom these components, the standard form LP, to maximize $c_{\\text{aug}}^{\\mathsf{T}} x_{\\text{aug}}$ subject to $A x_{\\text{aug}} = b$ and $x_{\\text{aug}} \\ge 0$, is constructed. The augmented matrix is $A = [M \\; I_m] \\in \\mathbb{R}^{m \\times (n+m)}$, the augmented decision vector is $x_{\\text{aug}} \\in \\mathbb{R}^{n+m}$, and the augmented cost vector is $c_{\\text{aug}} = [c; 0_m] \\in \\mathbb{R}^{n+m}$. The initial basis is chosen to be the set of slack variables, corresponding to the identity matrix $I_m$ in $A$. The initial basic feasible solution (BFS) is $x=0$, $s=b$. The number of zero entries in $b$ directly corresponds to the number of degenerate basic variables in this initial BFS.\n\n**2. Revised Simplex Method Implementation**\n\nA function implementing the revised simplex method is designed to solve these instances. It takes an instance $(A, b, c_{\\text{aug}})$ and a pivot rule as input.\n\n**Core Algorithm and Calculations**\nThe algorithm iterates from one BFS to another. In each iteration, with a given basis matrix $B$ (composed of columns of $A$ indexed by the basic set $B_{\\text{indices}}$), the following quantities are computed:\n-   The inverse of the basis matrix, $B^{-1}$.\n-   The values of the basic variables: $x_B = B^{-1} b$.\n-   The simplex multipliers (dual variables): $y = c_B^{\\mathsf{T}} B^{-1}$, where $c_B$ are the objective coefficients for the basic variables.\n-   The reduced costs for all nonbasic variables $j$: $r_j = c_j - y^{\\mathsf{T}} a_j$.\n\n**Cycle Detection**\nTo strictly detect cycling, the set of indices forming the basis, $B_{\\text{indices}}$, is stored at the beginning of each iteration. A history of all previously visited bases (represented as sorted tuples of indices for canonical representation) is maintained. If the current basis is found in the history, a cycle is detected, and the algorithm terminates. A maximum iteration limit of $K=200$ is also enforced as a safeguard.\n\n**Pivot Rule Implementation**\nThe choice of the entering and leaving variables depends on the selected pivot rule. A numerical tolerance of $\\varepsilon = 10^{-12}$ is used for all floating-point comparisons.\n\n*   **Entering Variable Selection**: A nonbasic variable $j$ is a candidate to enter the basis if its reduced cost $r_j  \\varepsilon$.\n    -   **Naive Rule**: Selects the candidate with the maximal reduced cost. Ties are broken by choosing the variable with the largest index.\n    -   **Bland's Rule**: Selects the candidate with the smallest index.\n\n*   **Leaving Variable Selection**: The leaving variable is determined by the minimum ratio test. First, the search direction $d = B^{-1} a_j$ is computed for the entering variable $j$. The step length is $\\theta = \\min \\{ x_{B,i} / d_i \\mid d_i  \\varepsilon \\}$. If all $d_i \\le \\varepsilon$, the problem is unbounded. Otherwise, the leaving candidates are the basic variables corresponding to the indices $i$ that achieve this minimum ratio $\\theta$.\n    -   **Naive Rule**: If there is a tie for the minimum ratio, the variable with the largest index among the candidates is chosen to leave the basis.\n    -   **Bland's Rule**: If there is a tie, the variable with the smallest index among the candidates is chosen to leave.\n\nA pivot is degenerate if the minimum ratio $\\theta$ is zero (or numerically close, $|\\theta|  \\varepsilon$). This occurs when a basic variable with value $0$ is chosen to leave the basis, resulting in no actual movement in the solution space, which is the mechanism that can lead to cycling.\n\n**3. Experiment Execution**\n\nThe main experimental procedure iterates through the specified degeneracy levels $\\delta \\in \\{0.0, 0.5, 1.0\\}$. For each $\\delta$, it performs $T=40$ trials. In each trial:\n1.  A new LP instance $(M, b, c)$ is generated using the specified parameters and the seeded random number generator.\n2.  The simplex solver is run on this instance using the 'naive' pivot rule. If the solver reports a cycle, a counter for naive rule cycles is incremented.\n3.  The simplex solver is run on the *same* instance using 'Bland's' pivot rule. If a cycle is detected, a counter for Bland's rule cycles is incremented.\n\nAfter all $T=40$ trials for a given $\\delta$ are complete, the results—$[\\delta, \\text{naive\\_cycles}, \\text{bland\\_cycles}]$—are recorded. As guaranteed by Bland's theorem, the count for `bland_cycles` is expected to be $0$ in all cases, serving as a validation of the implementation. The final output is an aggregation of these results for all tested $\\delta$ values, formatted into a single line as a list of lists.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef generate_instance(m, n, delta, rng):\n    \"\"\"\n    Generates a random LP instance (M, b, c) with controlled degeneracy.\n    \"\"\"\n    # Generate M with entries in {1, 2, 3, 4, 5}.\n    # rng.integers(low, high) is exclusive of high.\n    M = rng.integers(1, 6, size=(m, n))\n\n    # Generate c with entries in {-2, -1, 0, 1, 2, 3}.\n    c = rng.integers(-2, 4, size=n)\n\n    # Generate b with a specified fraction 'delta' of zero entries.\n    num_zeros = math.floor(delta * m)\n    \n    # Create an array of positive integers for the non-zero part.\n    b_pos_part = rng.integers(1, 11, size=m - num_zeros)\n    b_zero_part = np.zeros(num_zeros)\n    \n    b = np.concatenate((b_pos_part, b_zero_part))\n    rng.shuffle(b)\n    \n    return M, b.astype(float), c.astype(float)\n\n\ndef simplex_solver(M, b, c, pivot_rule, K, epsilon):\n    \"\"\"\n    Solves a linear program using the revised simplex method.\n    \n    Returns:\n        str: 'optimal', 'unbounded', 'cycle', 'max_iter', or an error string.\n    \"\"\"\n    m, n = M.shape\n    num_vars = n + m\n\n    # Form the augmented system A x_aug = b, max c_aug^T x_aug\n    A = np.hstack([M, np.eye(m)])\n    c_aug = np.concatenate([c, np.zeros(m)])\n\n    # Initial basis: slack variables\n    B_indices = list(range(n, num_vars))\n    \n    basis_history = set()\n\n    for _ in range(K):\n        # 1. Cycle Detection\n        current_basis_key = tuple(sorted(B_indices))\n        if current_basis_key in basis_history:\n            return 'cycle'\n        basis_history.add(current_basis_key)\n\n        # 2. Compute Revised Simplex quantities\n        B = A[:, B_indices]\n        try:\n            B_inv = np.linalg.inv(B)\n        except np.linalg.LinAlgError:\n            return 'singular_basis'\n        \n        c_B = c_aug[B_indices]\n        x_B = B_inv @ b\n        y = c_B @ B_inv\n\n        # 3. Find Entering Variable\n        N_indices = [i for i in range(num_vars) if i not in B_indices]\n        reduced_costs = {j: c_aug[j] - y @ A[:, j] for j in N_indices}\n        \n        candidates = {j: rc for j, rc in reduced_costs.items() if rc > epsilon}\n        if not candidates:\n            return 'optimal'\n\n        # Select entering variable based on pivot rule\n        if pivot_rule == 'naive':\n            max_rc = max(candidates.values())\n            tied_j = [j for j, rc in candidates.items() if abs(rc - max_rc)  epsilon]\n            j_enter = max(tied_j)\n        elif pivot_rule == 'bland':\n            j_enter = min(candidates.keys())\n        else:\n            raise ValueError(\"Invalid pivot rule\")\n\n        # 4. Find Leaving Variable (Minimum Ratio Test)\n        d = B_inv @ A[:, j_enter]\n        if np.all(d  epsilon):\n            return 'unbounded'\n\n        min_ratio = float('inf')\n        # First pass to find the minimum ratio\n        for i in range(m):\n            if d[i] > epsilon:\n                ratio = x_B[i] / d[i]\n                if ratio  min_ratio:\n                    min_ratio = ratio\n        \n        if min_ratio == float('inf'): # Should be caught by unbounded check, but for safety\n             return 'unbounded'\n        \n        # Second pass to find all ties for the minimum ratio\n        leaving_pos_candidates = []\n        for i in range(m):\n            if d[i] > epsilon:\n                 if abs((x_B[i] / d[i]) - min_ratio)  epsilon:\n                    leaving_pos_candidates.append(i)\n\n        if not leaving_pos_candidates:\n             # This can happen in highly degenerate cases, e.g. all x_B[i] are ~0 for d[i]>0\n             # and floating point issues hide the min_ratio=0 case.\n             # We must select a leaving var if d has a positive component.\n             for i in range(m):\n                 if d[i] > epsilon:\n                     leaving_pos_candidates.append(i)\n\n        leaving_var_candidates = [B_indices[i] for i in leaving_pos_candidates]\n\n        # Select leaving variable based on pivot rule\n        if pivot_rule == 'naive':\n            j_leave = max(leaving_var_candidates)\n        elif pivot_rule == 'bland':\n            j_leave = min(leaving_var_candidates)\n\n        # 5. Update Basis\n        leave_pos = B_indices.index(j_leave)\n        B_indices[leave_pos] = j_enter\n\n    return 'max_iter'\n\n\ndef solve():\n    \"\"\"\n    Main function to run the computational experiment and print the final result.\n    \"\"\"\n    # Experiment parameters\n    m, n = 4, 3\n    K = 200\n    epsilon = 1e-12\n    T = 40\n    seed = 2025\n    delta_suite = [0.0, 0.5, 1.0]\n\n    rng = np.random.default_rng(seed)\n\n    experiment_results = []\n    \n    for delta in delta_suite:\n        naive_cycles = 0\n        bland_cycles = 0\n        \n        for _ in range(T):\n            # Generate the same instance for both rules in each trial\n            M, b, c = generate_instance(m, n, delta, rng)\n\n            # Run with Naive Rule\n            result_naive = simplex_solver(M, b, c, 'naive', K, epsilon)\n            if result_naive == 'cycle':\n                naive_cycles += 1\n            \n            # Run with Bland's Rule\n            result_bland = simplex_solver(M, b, c, 'bland', K, epsilon)\n            if result_bland == 'cycle':\n                bland_cycles += 1\n        \n        experiment_results.append([delta, naive_cycles, bland_cycles])\n\n    # Final print statement in the exact required format.\n    # repr() gives the python-style list of lists string format.\n    # .replace(' ', '') removes all whitespace to match the specified format.\n    print(repr(experiment_results).replace(' ', ''))\n\nsolve()\n```"
        }
    ]
}