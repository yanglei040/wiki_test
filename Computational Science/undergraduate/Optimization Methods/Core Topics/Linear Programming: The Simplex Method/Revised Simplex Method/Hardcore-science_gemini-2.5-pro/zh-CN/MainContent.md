## 引言
线性规划是运筹学和[数学优化](@entry_id:165540)领域中一块重要的基石，为资源分配、生产计划和[网络流](@entry_id:268800)等无数现实世界问题提供了强大的建模与求解框架。标准单纯形法作为求解线性规划问题的经典算法，虽然在理论上十分完备，但在处理当今动辄包含成千上万变量的大规模问题时，其依赖于完整单纯形表的计算方式逐渐暴露了效率上的短板。每次迭代中更新庞大的表格会消耗大量的计算资源和时间，这成为了制约其在现代商业求解器中应用的主要瓶颈。

本文旨在解决这一知识鸿沟，深入剖析**修正单纯形法 (Revised Simplex Method)**——一种在计算上更为精炼和高效的实现方式。通过学习本文，读者将不再仅仅满足于单纯形法的理论概念，而是能够理解现代线性规划求解器背后的核心工作原理。

-   在“**原理与机制**”一章中，我们将揭示修正单纯形法如何巧妙地避免操作整个单纯形表，转而通过维护和更新一个尺寸小得多的关键矩阵——基逆矩阵 ($B^{-1}$)——来执行所有必要的计算。我们将详细分解其迭代步骤，并介绍乘积形式基[逆矩阵](@entry_id:140380)（PFI）等高级实现技术。
-   在“**应用与跨学科联系**”一章中，我们将超越算法本身，探讨其丰富的应用价值。您将看到修正单纯形法如何驱动灵敏度分析，为商业决策提供深刻的经济洞察，并了解它如何作为列生成等高级算法的“引擎”，去解决那些传统方法难以企及的超大规模问题。
-   最后，在“**动手实践**”部分，我们提供了一系列精心设计的练习，旨在引导您将理论知识付诸实践，通过具体的计算来巩固对算法每一步的理解，从而真正掌握这一强大的优化工具。

## 原理与机制

在上一章中，我们介绍了[线性规划](@entry_id:138188)的基本概念和标准的单纯形法。虽然单纯形法在理论上是一个强大而优雅的算法，但其基于完整单纯形表的实现方式在求解大规模问题时会遇到计算效率的瓶颈。本章将深入探讨**修正单纯形法 (Revised Simplex Method)**，这是一种在计算上更为高效的实现，也是现代商业线性规划求解器的核心。我们将从其基本原理出发，详细阐述其核心机制，并探讨其在实际应用中的高级实现技术。

### 修正单纯形法的基本思想：效率与规模

标准的单纯形法在每次迭代中都需要更新整个单纯形表。对于一个含有 $m$ 个约束和 $n$ 个原始决策变量的线性规划问题，在加入 $m$ 个松弛或剩余变量后，总变量数达到 $N = n+m$。此时，单纯形表的维度约为 $m \times N$。当变量数量 $n$ 远大于约束数量 $m$ 时（即 $N \gg m$），这张表会变得非常庞大。在每次迭代中，更新表中的每一个元素需要大量的浮点运算，其计算成本与 $mN$ 成正比。

修正单纯形法的核心思想在于，为了执行一次单纯形法的迭代，我们实际上并不需要整个单纯形表的信息。一次迭代的关键决策——选择入基变量和出基变量——仅仅依赖于以下几个关键信息：
1.  非基变量的**判别数 (reduced costs)**，用以确定哪个变量进入基。
2.  对于选定的入基变量，其在当前基下的表示，用以执行**比率测试 (ratio test)** 来确定出基变量。

修正单纯形法巧妙地发现，所有这些必需的信息都可以通过维护一个远比整个单纯形表小得多的矩阵来生成，这个矩阵就是当前基矩阵 $B$ 的[逆矩阵](@entry_id:140380) $B^{-1}$。基矩阵 $B$ 是一个 $m \times m$ 的方阵，因此其[逆矩阵](@entry_id:140380) $B^{-1}$ 也是一个 $m \times m$ 的矩阵。与更新庞大的 $m \times N$ 单纯形表相比，维护和使用这个 $m \times m$ 的[逆矩阵](@entry_id:140380)在计算上要高效得多。

我们可以通过一个简化的[计算成本模型](@entry_id:747607)来量化这种效率优势 。假设标准单纯形法每次迭代的成本为 $C_S = mN$。而修正单纯形法的成本主要包括两个部分：一是涉及 $m \times m$ 基[逆矩阵](@entry_id:140380)的运算（如计算单纯形乘子和更新逆），成本约为 $C_{R,1} = O(m^2)$；二是对所有 $N-m$ 个非基变量进行“定价”以计算其判别数，成本约为 $C_{R,2} = O(m(N-m))$。因此，修正单纯形法的总成本为 $C_R \approx O(m^2 + m(N-m))$。当 $N \gg m$ 时，$m(N-m)$ 是主导项，但即便如此，通过一些实现技巧（例如，并非每次都对所有非基变量定价），$C_R$ 仍然可以显著低于 $C_S$。例如，在一个假设模型中，若 $C_S=mN$ 且 $C_R(\alpha) = 3m^2 + \alpha m(N-m)$，其中 $\alpha$ 为定价效率参数，那么只要 $\alpha  \frac{N - 3m}{N - m}$，修正单纯形法就更具优势。对于 $N \gg m$ 的情况，这个阈值接近 $1$，这意味着即使是朴素的实现也常常更快。

### 修正单纯形法迭代的核心机制

现在让我们来详细分解一次典型的修正单纯形法迭代过程（以最大化问题为例）。在迭代开始时，我们已知当前基变量的集合、对应的基[逆矩阵](@entry_id:140380) $B^{-1}$，以及当前的基本可行解 $x_B = B^{-1}b$。

#### 步骤一：定价——寻找入基变量

“定价” (Pricing) 阶段的目标是检查是否存在一个非基变量，当其值从 $0$ 增加时，能够使[目标函数](@entry_id:267263)值提高。这通过计算每个非基变量 $x_j$ 的判别数 $\bar{c}_j$ 来实现。对于最大化问题，如果存在 $\bar{c}_j > 0$，则意味着增加 $x_j$ 的值是有利的。

为了高效地计算所有非基变量的判别数，我们首先引入一个至关重要的中间向量，称为**单纯形乘子 (simplex multipliers)** 或[对偶变量](@entry_id:143282)，记为行向量 $\pi^T$。其定义为：

$$
\pi^T = c_B^T B^{-1}
$$

其中 $c_B^T$ 是一个行向量，包含了当前所有基变量在目标函数中的系数。这个乘子向量在每次迭代中仅需计算一次。

例如，假设在一个生产[优化问题](@entry_id:266749)中，[目标函数](@entry_id:267263)为 $P = 5x_1 + 8x_2 + 6x_3$，当前基变量为 $\{x_1, x_2\}$，因此 $c_B^T = \begin{pmatrix} 5  8 \end{pmatrix}$。若已求得基[逆矩阵](@entry_id:140380)为 $B^{-1} = \begin{pmatrix} -1/7  3/7 \\ 3/7  -2/7 \end{pmatrix}$，那么单纯形乘子就可以通过矩阵乘法计算得出 ：

$$
\pi^T = \begin{pmatrix} 5  8 \end{pmatrix} \begin{pmatrix} -1/7  3/7 \\ 3/7  -2/7 \end{pmatrix} = \begin{pmatrix} \frac{-5+24}{7}  \frac{15-16}{7} \end{pmatrix} = \begin{pmatrix} 19/7  -1/7 \end{pmatrix}
$$

一旦计算出 $\pi^T$，任意非基变量 $x_j$ 的判别数就可以通过以下公式轻易获得：

$$
\bar{c}_j = c_j - \pi^T A_j
$$

这里，$c_j$ 是 $x_j$ 在目标函数中的系数，而 $A_j$ 是原始约束矩阵 $A$ 中与 $x_j$ 对应的列向量。这个计算仅涉及一个向量[点积](@entry_id:149019)，远比从完整单纯形表中读取判别数高效。例如，在另一个问题中，若 $\pi^T$ 已求出，我们需要计算非基变量 $x_2$ 的判别数，其[目标系数](@entry_id:637435) $c_2=8$，约束列向量为 $A_2 = (1, 2, 1)^T$。假设我们已经计算出 $\pi^T A_2 = 5/2$，则其判别数为 $\bar{c}_2 = 8 - 5/2 = 11/2$ 。

在计算完所有（或部分）非基变量的判别数后，我们通常选择具有最大正判别数的变量作为**入基变量 (entering variable)**。如果没有变量的判别数为正，则说明当前解已达到最优，[算法终止](@entry_id:143996)。

#### 步骤二：比率测试——寻找出基变量

确定了入基变量 $x_q$ 后，我们需要确定哪个当前的基变量必须离开基（其值变为 $0$），以确保新的解仍然满足非负性约束。这个过程就是**比率测试 (ratio test)**。

为此，我们首先需要知道当 $x_q$ 的值从 $0$ 开始增加时，当前的基变量 $x_B$ 是如何变化的。这个关系由一个称为**更新列向量 (updated column vector)** $d$ 的向量给出：

$$
d = B^{-1} A_q
$$

其中 $A_q$ 是入基变量 $x_q$ 对应的约束列。向量 $d$ 的第 $i$ 个分量 $d_i$ 表示当 $x_q$ 增加一个单位时，第 $i$ 个基变量 $(x_B)_i$ 的变化量（实际上是减少量，见后续理论解释部分）。值得一提的是，这个向量 $d$ 正是 $A_q$ 在当前基 $B$ 下的坐标表示，即满足 $A_q = Bd$ 。

获得当前基本[可行解](@entry_id:634783) $x_B = B^{-1} b$ 和更新列向量 $d$ 后，我们执行比率测试。我们寻找最小的非负比率 $\theta$：

$$
\theta = \min \left\{ \frac{(x_B)_i}{d_i} \mid d_i > 0 \right\}
$$

这个 $\theta$ 值是 $x_q$ 能增加到的最大值，超过这个值，第一个基变量就会变为负数。产生这个最小比率的基变量就是**出基变量 (leaving variable)**。

如果所有的 $d_i \le 0$，这意味着我们可以无限增加 $x_q$ 的值而不会导致任何基变量变为负数。在这种情况下，[目标函数](@entry_id:267263)可以无限增长，问题是**无界的 (unbounded)**。

#### 步骤三：主元变换——更新解

最后一步是执行**主元变换 (pivot)**，更新我们的核心数据：基变量集合、$x_B$ 的值以及最重要的 $B^{-1}$。
- 新的基变量集合由旧的集合去掉出基变量、加入入基变量得到。
- 新的基本[可行解](@entry_id:634783)的值更新为：入基变量的值变为 $\theta$，而原有的基变量值更新为 $x'_B = x_B - \theta d$。
- 更新基[逆矩阵](@entry_id:140380) $B^{-1}$ 以反映基的变化。

直接从新的基矩阵 $B_{\text{new}}$ 出发，完全重新计算其逆 $(B_{\text{new}})^{-1}$ 是非常低效的。幸运的是，每次主元变换仅仅是用一个列向量替换基矩阵中的另一个列向量。这种变化可以用一个**[秩一更新](@entry_id:137543) (rank-one update)** 来表示。

从理论上，我们可以利用 **Sherman-Morrison-Woodbury 公式**来推导新的基[逆矩阵](@entry_id:140380)。如果新基 $B_{\text{new}}$ 是通过将旧基 $B$ 的第 $k$ 列 $b_k$ 替换为向量 $a_q$ 得到的，那么 $B_{\text{new}} = B + (a_q - b_k) e_k^T$，其中 $e_k$ 是第 $k$ 个标准单位向量。这正是一个[秩一更新](@entry_id:137543)的形式，其[逆矩阵](@entry_id:140380)可以直接通过公式计算，而无需完全重算 。这个视角为更新基[逆矩阵](@entry_id:140380)提供了坚实的理论基础。

然而，在实践中，一种更灵活、更常用的技术是基逆矩阵的乘积形式。

### 基[逆矩阵](@entry_id:140380)的乘积形式 (PFI)

**基[逆矩阵](@entry_id:140380)的乘积形式 (Product Form of the Inverse, PFI)** 是一种不直接存储 $B^{-1}$ 矩阵，而是将其表示为一系列[初等矩阵](@entry_id:635817)乘积的方法。在经过 $k$ 次迭代后，当前的基[逆矩阵](@entry_id:140380)可以写成：

$$
B_k^{-1} = E_k E_{k-1} \cdots E_1 B_0^{-1}
$$

其中 $B_0$ 是初始基矩阵（通常是单位矩阵 $I$，因此 $B_0^{-1}=I$），而每一个 $E_j$ 都是一个所谓的 **Eta 矩阵 (eta matrix)**。

一个 Eta 矩阵是一个仅有一列与[单位矩阵](@entry_id:156724)不同的矩阵。这一列被称为 **Eta 向量 (eta vector)**。在第 $k$ 次迭代中，如果入基变量是 $x_q$，出基变量是基变量中的第 $r$ 个，那么新的 Eta 矩阵 $E_k$ 就等于一个单位矩阵，但其第 $r$ 列被 Eta 向量 $\eta_k$ 替换。而 $\eta_k$ 的计算与我们之前遇到的更新列向量 $d_k = B_{k-1}^{-1} A_q$ 直接相关。具体地，$\eta_k$ 的第 $r$ 个分量是 $1/d_{k,r}$，而其他分量 $i \ne r$ 是 $-d_{k,i}/d_{k,r}$。

使用 PFI，每次迭代的更新步骤变得极其简单：我们只需计算当次的 Eta 向量，并将其（以稀疏形式）存储起来，PFI 的链条上就增加了一个新的 Eta 矩阵。例如，要计算入基变量 $x_2$ 的更新列向量 $d = B^{-1}A_2$，而 $B^{-1}=E_1$（假设从单位基开始仅迭代了一次），我们只需计算 $d=E_1 A_2$ 即可 。

#### FTRAN 和 BTRAN：基于PFI的高效计算

PFI 的真正威力在于它如何改变了核心计算的执行方式。我们在每次迭代中需要的两个核心乘法运算 $\pi^T = c_B^T B^{-1}$ 和 $d = B^{-1} A_q$ 现在变成了与一串 Eta 矩阵的乘法。

1.  **BTRAN (Backward Transformation)**：用于定价阶段。计算 $\pi^T = c_B^T B^{-1} = c_B^T E_k E_{k-1} \cdots E_1$ 时，最高效的方式是**从左向右**依次进行向量-[矩阵乘法](@entry_id:156035)：
    $$
    \pi^T = (\cdots((c_B^T E_k) E_{k-1})\cdots E_1)
    $$
    这个过程被称为**反向变换 (BTRAN)**，因为它处理 Eta 矩阵的顺序 ($E_k, E_{k-1}, \dots$)与它们生成的顺序相反。这等价于[求解线性方程组](@entry_id:169069) $\pi^T B = c_B^T$ 。

2.  **FTRAN (Forward Transformation)**：用于比率测试阶段。计算 $d = B^{-1} A_q = E_k E_{k-1} \cdots E_1 A_q$ 时，我们**从右向左**依次进行矩阵-向量乘法：
    $$
    d = E_k (E_{k-1} (\cdots (E_1 A_q)\cdots))
    $$
    这个过程被称为**正向变换 (FTRAN)**，因为它处理 Eta 矩阵的顺序 ($E_1, E_2, \dots$)与它们生成的顺序相同。这等价于[求解线性方程组](@entry_id:169069) $Bd = A_q$。

综上所述，修正单纯形法的每一次迭代都由一次 BTRAN（用于定价）和一次 FTRAN（用于比率测试）主导 。

#### PFI的管理：内存与再求逆

PFI 方法在内存使用方面也具有优势，尤其是在迭代初期。存储一个 $m \times m$ 的稠密逆矩阵需要 $m^2$ 个单位的内存。而存储一个 Eta 矩阵，我们只需存储其非单位列（Eta 向量）中的非标准值及其位置，以及该列的索引。如果一个 Eta 向量平均有 $p$ 个这样的元素，则存储一个 Eta 矩阵大约需要 $2p+1$ 个单位的内存。经过 $k$ 次迭代后，PFI 的总内存消耗为 $k(2p+1)$。当 $k$ 较小时，这个值远小于 $m^2$ 。

然而，PFI 并非没有缺点。随着迭代次数 $k$ 的增加，Eta 矩阵链条会越来越长。这不仅增加了内存消耗，更重要的是，每次 FTRAN 和 BTRAN 的计算成本也随之[线性增长](@entry_id:157553)。此外，长链条的连乘会累积[浮点运算误差](@entry_id:637950)，可能导致数值不稳定。

为了解决这个问题，商业求解器会采用一种称为**再求逆 (Reinversion)** 的策略。当 Eta 链条达到一定长度（或经过一定次数的迭代）后，算法会暂停，利用当前基变量的列表 $\{x_{B_1}, \dots, x_{B_m}\}$，从原始数据矩阵 $A$ 中抽取出对应的列，形成当前的基矩阵 $B$。然后，算法会（使用高效的数值方法，如[LU分解](@entry_id:144767)）从头计算一个“全新”的、精确的基逆矩阵 $B^{-1}$。这个新求得的[逆矩阵](@entry_id:140380)可以被视作一个新的起点，或者被分解成一组新的、更短的 Eta 矩阵链。这个过程清除了累积的计算误差，并“重置”了 FTRAN 和 BTRAN 的计算成本，是维持算法长期高效和数值稳定的关键步骤 。

### 几何与理论诠释

修正单纯形法的代数操作背后，有着深刻的几何直观。理解这些联系有助于我们更深入地把握算法的本质。

**单纯形法的移动方向：** 在每次迭代中，选择一个非基变量 $x_j$ 入基，并在保持其他非基变量为 $0$ 的情况下增加其值，这在几何上对应于从当前可行多面体的一个顶点（基本可行解）沿着一条边移动到相邻的另一个顶点。修正单纯形法中构造的移动[方向向量](@entry_id:169562) $p \in \mathbb{R}^n$（其在入基变量 $x_j$ 上的分量为 $1$，在基变量上的分量为 $-d = -B^{-1}A_j$，在其他非基变量上为 $0$）精确地描述了这条边的方向。这个方向 $p$ 满足 $Ap=0$，意味着任何沿该方向的移动都将始终满足[等式约束](@entry_id:175290) $Ax=b$，即它位于约束定义的仿射[子空间](@entry_id:150286)中 。

**判别[数的几何](@entry_id:192990)意义：** 判别数 $\bar{c}_j$ 并非一个凭空构造的代数量。它实际上是[目标函数](@entry_id:267263) $c^T x$ 沿着上述边方向 $p$ 的**方向导数**，即 $\bar{c}_j = c^T p$。对于最小化问题，若 $\bar{c}_j  0$，意味着沿该边的方向移动会导致目标函数值下降，因此这是一个有利的移动方向。定价过程，在几何上，就是在检查从当前顶点出发的每一条边，看哪条边的“坡度”最陡（即目标函数值改善最快）。

**单纯形法不是最速下降法：** 一个常见的误解是认为单纯形法是某种形式的[最速下降法](@entry_id:140448)。这是不正确的。[最速下降](@entry_id:141858)方向是指[目标函数](@entry_id:267263)梯度 $-c$ 在[可行方向](@entry_id:635111)空间（即 $A$ 的[零空间](@entry_id:171336)）上的投影。这个方向通常是一个稠密向量，移动一小步就会离开可行[多面体](@entry_id:637910)的边界，进入某个面的内部。而单纯形法坚持沿着多面体的边移动，其选择边的标准（如最大判别数规则）是为了在每一步获得“单位步长”的最大改善，但这与整体的[最速下降](@entry_id:141858)方向是不同的 。单纯形法的策略是“顶点到顶点”，而非“穿过表面”。

通过本章的学习，我们看到修正单纯形法不仅是对标准单纯形法的一种高效实现，它还揭示了算法背后更深层次的结构。通过聚焦于基[逆矩阵](@entry_id:140380) $B^{-1}$，它将线性代数工具、[计算效率](@entry_id:270255)考量和几何直观紧密地结合在一起，构成了现代[线性规划](@entry_id:138188)求解技术的基础。