{
    "hands_on_practices": [
        {
            "introduction": "全局优化的第一个绊脚石就是局部最优解的存在——它们是那些能“欺骗”简单优化算法的“山谷”。这个练习将通过一个具体例子，让你亲手识别一个拥有非全局局部最小值的函数，从而加深对全局优化问题根本困难的理解。",
            "id": "2176795",
            "problem": "在优化研究中，局部最优与全局最优之间存在一个关键区别。如果对于包含点 $c$ 的某个开区间内的所有 $x$，都有 $f(c) \\leq f(x)$，则函数 $f(x)$ 在点 $c$ 处有局部最小值。如果对于给定定义域内的所有 $x$，都有 $f(d) \\leq f(x)$，则函数在该定义域内的点 $d$ 处有全局最小值。\n\n考虑这样一个任务：寻找一个简单的、非常数的多项式函数 $p(x)$，当在闭区间 $[-5, 5]$ 上进行分析时，它至少拥有一个在该区间上*不是*全局最小值的局部最小值。\n\n下列哪个多项式函数在区间 $[-5, 5]$ 上满足此条件？\n\nA. $p(x) = x^{2} - 10$\n\nB. $p(x) = x^{3} - 12x$\n\nC. $p(x) = 5x + 2$\n\nD. $p(x) = x^{4} - 8x^{2} + 10$\n\nE. $p(x) = -x^{2} - 3x$",
            "solution": "我们被要求在给定的多项式中，找出一个在区间 $[-5,5]$ 上至少有一个局部最小值，且该局部最小值不是该区间上的全局最小值的多项式。根据闭区间法，一个闭区间上的连续函数在临界点（导数为零或不存在的点）和端点处取得其绝对极值。对于多项式，导数处处有定义，所以我们检查临界点（其中 $p'(x)=0$）和端点。为了对局部极值进行分类，我们使用二阶导数检验：如果 $p''(c)>0$，则 $c$ 是一个局部最小值；如果 $p''(c)  0$，则 $c$ 是一个局部最大值。\n\n分析每个选项：\n\n选项 A：$p(x)=x^{2}-10$。那么\n$$\np'(x)=2x,\\quad p''(x)=2.\n$$\n唯一的临界点是 $x=0$，并且由于 $p''(0)=2>0$，$x=0$ 是一个局部最小值。其值为\n$$\np(0)=-10.\n$$\n在端点处，\n$$\np(-5)=25-10=15,\\quad p(5)=25-10=15.\n$$\n因此，在 $[-5,5]$ 上的全局最小值在 $x=0$ 处，值为 $-10$，这也是（唯一的）局部最小值。没有不是全局最小值的局部最小值。此选项不满足条件。\n\n选项 B：$p(x)=x^{3}-12x$。那么\n$$\np'(x)=3x^{2}-12=3(x^{2}-4),\\quad p''(x)=6x.\n$$\n临界点出现在 $x=\\pm 2$。二阶导数检验得出\n$$\np''(-2)=-12  0 \\Rightarrow x=-2 \\text{ 是一个局部最大值},\\quad p''(2)=12>0 \\Rightarrow x=2 \\text{ 是一个局部最小值}。\n$$\n计算 $p$ 在临界点和端点处的值：\n$$\np(2)=8-24=-16,\\quad p(-2)=-8+24=16,\n$$\n$$\np(-5)=-125+60=-65,\\quad p(5)=125-60=65.\n$$\n这些值中最小的是在 $x=-5$ 处的 $-65$，所以在 $[-5,5]$ 上的全局最小值在 $x=-5$ 处，值为 $-65$。点 $x=2$ 是一个局部最小值，其值为 $-16$，这个值严格大于 $-65$，因此它不是全局最小值。因此，这个选项满足条件。\n\n选项 C：$p(x)=5x+2$。那么\n$$\np'(x)=5\\neq 0 \\text{ 对所有 } x \\text{ 成立},\n$$\n所以没有临界点，在区间内部也没有局部最小值。该函数是严格递增的，所以在 $[-5,5]$ 上的最小值出现在 $x=-5$ 处，并且是全局最小值。没有不是全局最小值的局部最小值。此选项不满足条件。\n\n选项 D：$p(x)=x^{4}-8x^{2}+10$。那么\n$$\np'(x)=4x^{3}-16x=4x(x^{2}-4),\\quad p''(x)=12x^{2}-16.\n$$\n临界点是 $x=0,\\pm 2$。二阶导数检验得出\n$$\np''(0)=-16  0 \\Rightarrow x=0 \\text{ 是一个局部最大值},\\quad p''(\\pm 2)=32>0 \\Rightarrow x=\\pm 2 \\text{ 是局部最小值}。\n$$\n计算：\n$$\np(\\pm 2)=16-32+10=-6,\\quad p(0)=10,\n$$\n$$\np(\\pm 5)=625-200+10=435.\n$$\n最小值是在 $x=\\pm 2$ 处的 $-6$，这些也是在 $[-5,5]$ 上的全局最小值。因此，局部最小值就是全局最小值；没有不是全局最小值的局部最小值。此选项不满足条件。\n\n选项 E：$p(x)=-x^{2}-3x$。那么\n$$\np'(x)=-2x-3,\\quad p''(x)=-2  0,\n$$\n所以顶点是一个局部最大值；在区间内部没有局部最小值。在 $[-5,5]$ 上，最小值出现在端点处，并且是全局的。没有不是全局最小值的局部最小值。此选项不满足条件。\n\n因此，唯一一个在 $[-5,5]$ 上至少有一个局部最小值但该值不是全局最小值的选项是选项 B。",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "面对充满局部最优的复杂“地形”，启发式算法提供了一套强大的探索工具。本练习将聚焦于两种著名的种群算法——差分进化（DE）和遗传算法（GA），让你通过一个具体的计算，直观比较它们在“欺骗性”函数上的单步更新机制，这将揭示它们在平衡探索与利用方面的不同策略。",
            "id": "2176751",
            "problem": "一个优化任务旨在寻找一个二维“欺骗性”函数 $f(x, y)$ 的最小值，该函数定义在域 $x, y \\in [-10, 10]$ 上。该函数有一个非常窄且深的全局最小值和一个宽而浅的局部最小值，这对许多优化算法来说都具有挑战性。该函数由下式给出：\n$$f(x, y) = -5 \\exp\\left(-\\frac{(x - 4)^2 + (y - 4)^2}{0.5}\\right) - 2 \\exp\\left(-\\frac{(x + 2)^2 + (y + 2)^2}{10}\\right)$$\n该函数的全局最小值位于点 $\\mathbf{x}_g = (4, 4)$。\n\n我们正在分析两种基于种群的优化算法的行为：差分进化 (Differential Evolution, DE) 算法和实数编码遗传算法 (Genetic Algorithm, GA)。在某一特定代，我们关注种群中一个由向量 $\\mathbf{x}_i = (-2.1, -1.9)$ 表示的特定“目标”个体。我们希望比较每种算法的单步操作如何更新该个体的位置。\n\n对于**差分进化**算法，使用 `DE/rand/1` 策略生成一个试验向量 $\\mathbf{v}_i$，定义为 $\\mathbf{v}_i = \\mathbf{x}_{r1} + F (\\mathbf{x}_{r2} - \\mathbf{x}_{r3})$，其中 $\\mathbf{x}_{r1}, \\mathbf{x}_{r2}, \\mathbf{x}_{r3}$ 是从种群中随机选择的三个不同个体，而 $F$ 是缩放因子。在这个特定的步骤中，选择的个体是：\n- $\\mathbf{x}_{r1} = (-1.8, -2.2)$\n- $\\mathbf{x}_{r2} = (3.9, 4.1)$\n- $\\mathbf{x}_{r3} = (-2.0, -2.3)$\n缩放因子为 $F = 0.8$。\n\n对于**遗传算法**，通过交叉和变异从目标个体 $\\mathbf{x}_i$ 创建一个新的候选个体 $\\mathbf{c}'$。\n- **交叉**：在目标个体 $\\mathbf{x}_i$ 和一个选定的父代 $\\mathbf{x}_p = (-1.9, -2.0)$ 之间执行算术交叉。子代向量 $\\mathbf{c}$ 是一个加权平均：$\\mathbf{c} = \\alpha \\mathbf{x}_i + (1-\\alpha) \\mathbf{x}_p$，权重为 $\\alpha = 0.5$。\n- **变异**：生成的子代向量 $\\mathbf{c}$ 然后通过加上一个变异向量 $\\mathbf{m} = (0.1, -0.2)$ 进行变异。最终的候选个体是 $\\mathbf{c}' = \\mathbf{c} + \\mathbf{m}$。\n\n为了比较这两种更新的探索能力，请计算 DE 试验向量到全局最优点的欧几里得距离与 GA 候选向量到全局最优点的欧几里得距离之比。也就是说，计算 $\\frac{\\|\\mathbf{v}_i - \\mathbf{x}_g\\|}{\\|\\mathbf{c}' - \\mathbf{x}_g\\|}$ 的值。\n\n将最终答案四舍五入至三位有效数字。",
            "solution": "我们需要计算由 DE 和 GA 分别产生的两个更新候选体到全局最优点 $\\mathbf{x}_{g}=(4,4)$ 的欧几里得距离之比。\n\n对于使用 DE/rand/1 策略的差分进化算法，试验向量为\n$$\n\\mathbf{v}_{i}=\\mathbf{x}_{r1}+F\\left(\\mathbf{x}_{r2}-\\mathbf{x}_{r3}\\right),\n$$\n其中 $\\mathbf{x}_{r1}=(-1.8,-2.2)$，$\\mathbf{x}_{r2}=(3.9,4.1)$，$\\mathbf{x}_{r3}=(-2.0,-2.3)$，以及 $F=0.8$。首先计算差值：\n$$\n\\mathbf{x}_{r2}-\\mathbf{x}_{r3}=(3.9-(-2.0),\\,4.1-(-2.3))=(5.9,\\,6.4).\n$$\n按 $F$ 进行缩放：\n$$\nF(\\mathbf{x}_{r2}-\\mathbf{x}_{r3})=0.8\\cdot(5.9,\\,6.4)=(4.72,\\,5.12).\n$$\n加上 $\\mathbf{x}_{r1}$：\n$$\n\\mathbf{v}_{i}=(-1.8,-2.2)+(4.72,5.12)=(2.92,\\,2.92).\n$$\n$\\mathbf{v}_{i}$ 到 $\\mathbf{x}_{g}$ 的欧几里得距离是\n$$\n\\|\\mathbf{v}_{i}-\\mathbf{x}_{g}\\|=\\|(2.92-4,\\,2.92-4)\\|=\\|(-1.08,\\,-1.08)\\|=\\sqrt{(-1.08)^{2}+(-1.08)^{2}}=1.08\\sqrt{2}.\n$$\n\n对于遗传算法，在 $\\mathbf{x}_{i}=(-2.1,-1.9)$ 和 $\\mathbf{x}_{p}=(-1.9,-2.0)$ 之间使用权重 $\\alpha=0.5$ 进行算术交叉得到\n$$\n\\mathbf{c}=\\alpha\\mathbf{x}_{i}+(1-\\alpha)\\mathbf{x}_{p}=0.5(-2.1,-1.9)+0.5(-1.9,-2.0)=(-2.0,\\,-1.95).\n$$\n变异加上 $\\mathbf{m}=(0.1,-0.2)$，得到\n$$\n\\mathbf{c}'=\\mathbf{c}+\\mathbf{m}=(-2.0+0.1,\\,-1.95-0.2)=(-1.9,\\,-2.15).\n$$\n$\\mathbf{c}'$ 到 $\\mathbf{x}_{g}$ 的欧几里得距离是\n$$\n\\|\\mathbf{c}'-\\mathbf{x}_{g}\\|=\\|(-1.9-4,\\,-2.15-4)\\|=\\|(-5.9,\\,-6.15)\\|=\\sqrt{(5.9)^{2}+(6.15)^{2}}=\\sqrt{34.81+37.8225}=\\sqrt{72.6325}.\n$$\n\n因此，所求的比率为\n$$\nR=\\frac{\\|\\mathbf{v}_{i}-\\mathbf{x}_{g}\\|}{\\|\\mathbf{c}'-\\mathbf{x}_{g}\\|}=\\frac{1.08\\sqrt{2}}{\\sqrt{72.6325}}.\n$$\n数值上，\n$$\n1.08\\sqrt{2}\\approx 1.527350647,\\quad \\sqrt{72.6325}\\approx 8.5224703,\\quad R\\approx \\frac{1.527350647}{8.5224703}\\approx 0.179.\n$$\n四舍五入到三位有效数字，该比率为 $0.179$。",
            "answer": "$$\\boxed{0.179}$$"
        },
        {
            "introduction": "虽然启发式算法在寻找高质量解方面很有效，但它们通常无法保证找到的解就是全局最优解。为了获得这种保证，我们需要确定性全局优化方法。这个综合性练习将指导你实现一个完整的分支定界（Branch and Bound）算法，它利用函数的利普希茨（Lipschitz）性质来严格证明解的最优性，是将理论与算法设计融为一体的终极实践。",
            "id": "3133208",
            "problem": "构建一个严谨的、自洽的计算演示，该演示为有界域上的全局优化问题集成了理论和算法设计。在矩形域 $D=[-2,2]\\times[-2,2]$上定义一个多峰函数 $f:\\mathbb{R}^2\\to\\mathbb{R}$，该函数恰好有五个不同的孤立局部最小值点，其中一个是唯一的全局最小值点。使用此函数设计一个分支定界 (BnB) 程序，该程序能够使用一个用户选择的常数 $L$ 通过利普希茨界来证明全局最优性。该程序必须为一套参数值的测试用例生成数值结果，并将结果汇总为指定的输出格式。\n\n使用的基本原理和定义：\n- 如果对于所有 $x,y\\in D$，存在一个常数 $L\\ge 0$ 使得 $|f(x)-f(y)|\\le L\\|x-y\\|_2$ 成立，则称函数 $f:D\\to\\mathbb{R}$ 在 $D$ 上关于欧几里得范数是利普希茨连续的。\n- 在 $D$ 上的有限个利普希茨连续函数集合的最小值函数在 $D$ 上也是利普希茨连续的，其利普希茨常数的上界为这些单个函数常数的最大值。\n- 对于任意矩形 $R\\subset D$，其中心为 $c_R$，半径为 $r_R=\\max_{x\\in R}\\|x-c_R\\|_2$，如果 $f$ 在 $D$ 上是利普希茨常数为 $L$ 的连续函数，那么对于所有 $x\\in R$ 我们有 $f(x)\\ge f(c_R)-L r_R$。当 $L$ 是真实利普希茨常数的上界时，这给出了 $R$ 上的一个有效下界。\n\n按如下方式指定多峰函数。令 $b\\in\\mathbb{R}$ 为一个固定的正曲率参数 $b=0.25$。定义五个中心点\n$$\nm_1=(1.3,1.1),\\quad m_2=(-1.1,1.2),\\quad m_3=(1.6,-0.7),\\quad m_4=(-1.4,-1.3),\\quad m_5=(0.3,-0.2),\n$$\n和五个偏移量\n$$\na_1=0.70,\\quad a_2=0.65,\\quad a_3=0.68,\\quad a_4=0.66,\\quad a_5=0.00.\n$$\n对于 $i\\in\\{1,2,3,4,5\\}$，定义二次势阱\n$$\n\\phi_i(x)=a_i+b\\left\\|x-m_i\\right\\|_2^2,\\quad x\\in D,\n$$\n并设\n$$\nf(x)=\\min_{i=1,\\dots,5}\\,\\phi_i(x).\n$$\n该构造产生恰好五个孤立的局部最小值点，位于中心点 $m_i$ 处，其值为 $f(m_i)=a_i$，其中一个是在 $m_5$ 处的唯一全局最小值点，其值为 $0$。\n\n设计并实现一个基于利普希茨下界的分支定界 (BnB) 方法：\n- 状态空间划分：$D$ 内的矩形 $R=[x_{\\min},x_{\\max}]\\times[y_{\\min},y_{\\max}]$。\n- 节点定界：对于每个矩形 $R$，其中心为 $c_R$，半径为 $r_R=\\sqrt{\\left(\\frac{x_{\\max}-x_{\\min}}{2}\\right)^2+\\left(\\frac{y_{\\max}-y_{\\min}}{2}\\right)^2}$，计算一个下界 $LB(R)=f(c_R)-L r_R$ 并使用 $f(c_R)$ 作为局部上界候选值。\n- 选择规则：展开当前具有最小下界的矩形。\n- 分支规则：沿最长边将所选矩形二等分为两个矩形。\n- incumbent 更新：跟踪 $U=\\min\\{f(c_R)\\ \\text{在所有已评估中心点上}\\}$ 及对应的点。\n- 终止准则：如果对于一个用户选择的容差 $\\varepsilon0$，$U-\\min_R LB(R)\\le\\varepsilon$ 成立，则返回 incumbent 作为 $\\varepsilon$-最优解并宣布已证明；否则继续进行，直到达到用户选择的已处理矩形数量上限。\n\n利用每个 $\\phi_i$ 可微且梯度为 $\\nabla\\phi_i(x)=2b(x-m_i)$ 这一事实，计算 $f$ 在 $D$ 上的一个有效利普希茨常数上界。对于 $x\\in D$，我们有 $\\|\\nabla\\phi_i(x)\\|_2\\le 2b R_i$，其中 $R_i=\\max_{y\\in D}\\|y-m_i\\|_2$ 是从 $m_i$ 到 $D$ 中任意点的最大距离。因此，$\\phi_i$ 在 $D$ 上是利普希茨连续的，其常数 $L_i\\le 2b R_i$。由于 $f=\\min_i \\phi_i$ 是利普希茨连续的，其常数至多为 $\\max_i L_i$，因此一个有效的选择是 $L_{\\text{true}}=\\max_{i} 2bR_i$。算法必须接受一个用户选择的常数 $L$ 并用它来计算界；然而，只有当 $L\\ge L_{\\text{true}}$ 时，证明在逻辑上才有效。\n\n测试套件。对于每个测试用例，输入参数为 $(L,\\varepsilon,N_{\\max})$，其中 $L$ 是用户选择的利普希茨常数，$\\varepsilon$ 是容差，$N_{\\max}$ 是允许的矩形展开最大次数。使用以下测试用例：\n- 用例 1（理想情况）：$L=L_{\\text{true}}$，$\\varepsilon=10^{-3}$，$N_{\\max}=20000$。\n- 用例 2（常数被低估）：$L=0.5\\,L_{\\text{true}}$，$\\varepsilon=10^{-3}$，$N_{\\max}=20000$。\n- 用例 3（过于保守的常数和紧张的预算）：$L=2.0\\,L_{\\text{true}}$，$\\varepsilon=10^{-3}$，$N_{\\max}=500$。\n- 用例 4（理想情况，容差更宽松）：$L=L_{\\text{true}}$，$\\varepsilon=10^{-2}$，$N_{\\max}=5000$。\n\n对于每个测试用例，您的程序必须生成一个包含以下内容的结果三元组：\n- 找到的最佳函数值 $U$，以浮点数表示，\n- 一个布尔值，指示在预算 $N_{\\max}$ 内，是否使用给定的 $L$ 和 $\\varepsilon$ 证明了全局最优性，其中证明必须同时要求 $U-\\min_R LB(R)\\le\\varepsilon$ 和 $L\\ge L_{\\text{true}}$，\n- 实际执行的矩形展开次数，以整数表示。\n\n最终输出格式要求：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果打印为一个无空格的方括号三元组，例如 $[[u_1,\\text{True},n_1],[u_2,\\text{False},n_2],\\dots]$。所有角度都隐含在欧几里得范数中，无需单位说明。不涉及物理单位。所有数值答案都是无单位的实数。代码必须是完整的、自洽的，并且无需任何外部输入即可运行。",
            "solution": "所给问题是计算优化领域中一个适定 (well-posed) 的任务。它要求设计并实现一个分支定界 (BnB) 算法，以寻找并证明一个特殊构造的多峰函数在紧集域上的全局最小值。解决方案首先分析目标函数及其性质，然后详细说明 BnB 算法的组成部分，最后指定计算实现。\n\n待最小化的目标函数为 $f:\\mathbb{R}^2\\to\\mathbb{R}$，定义在域 $D=[-2,2]\\times[-2,2]$ 上，是五个二次势阱的下包络线：\n$$\nf(x) = \\min_{i=1,\\dots,5} \\phi_i(x)\n$$\n其中每个势阱 $\\phi_i(x)$ 定义为\n$$\n\\phi_i(x) = a_i + b\\|x - m_i\\|_2^2.\n$$\n参数包括一个固定的曲率 $b=0.25$，五个不同的中心点 $m_i \\in D$，以及五个非负偏移量 $a_i$。中心点为 $m_1=(1.3,1.1)$、$m_2=(-1.1,1.2)$、$m_3=(1.6,-0.7)$、$m_4=(-1.4,-1.3)$ 和 $m_5=(0.3,-0.2)$。对应的偏移量为 $a_1=0.70$、$a_2=0.65$、$a_3=0.68$、$a_4=0.66$ 和 $a_5=0.00$。通过这种构造，$f(x)$ 在位置 $m_i$ 处呈现五个局部最小值，其值为 $f(m_i) = \\phi_i(m_i) = a_i$。由于 $a_5=0$ 严格小于所有其他 $a_i$，点 $m_5$ 是唯一的全局最小值点，其值为 $f(m_5)=0$。\n\n对于全局优化而言，$f(x)$ 的一个关键性质是其利普希茨连续性。如果对于所有 $x, y \\in D$ 都有 $|g(x) - g(y)| \\le L \\|x-y\\|_2$，则函数 $g$ 在 $D$ 上是利普希茨常数为 $L$ 的连续函数。对于像 $D$ 这样的凸集上的可微函数，利普希茨常数受其梯度范数的上确界所约束，即 $L_g \\le \\sup_{x \\in D} \\|\\nabla g(x)\\|_2$。每个二次势阱 $\\phi_i(x)$ 都是可微的，其梯度为 $\\nabla \\phi_i(x) = 2b(x - m_i)$。其范数为 $\\|\\nabla \\phi_i(x)\\|_2 = 2b\\|x - m_i\\|_2$。该范数在 $x \\in D$ 上的上确界为 $\\phi_i$ 定义了一个有效的利普希茨常数 $L_i$：\n$$\nL_i = \\sup_{x \\in D} 2b\\|x - m_i\\|_2 = 2b \\max_{x \\in D} \\|x - m_i\\|_2.\n$$\n令 $R_i = \\max_{x \\in D} \\|x - m_i\\|_2$。在正方形 $D=[-2,2]\\times[-2,2]$ 中，距离任意内部点 $m_i$ 最远的点必定是 $D$ 的四个角点之一：$(2,2)$、$(2,-2)$、$(-2,2)$ 或 $(-2,-2)$。因此，通过计算 $m_i$ 到这四个角点的距离并取最大值即可找到 $R_i$。由于函数 $f(x)$ 是有限个利普希茨函数 $\\{\\phi_i\\}$ 集合的最小值函数，它本身也是利普希茨连续的。$f(x)$ 的一个有效利普希茨常数是个体常数的最大值，即 $L_{\\text{true}} = \\max_i L_i = \\max_i (2b R_i) = 2b \\max_i R_i$。这个值对于证明解的全局最优性至关重要。\n\n分支定界算法系统地将搜索空间 $D$ 划分成更小的矩形，并计算每个矩形内 $f(x)$ 最小值的下界和上界。\n$1$. **划分方案**：算法以整个域 $D$ 作为根矩形开始。在每一步中，选择一个矩形并沿其最长边进行二等分，创建两个更小的子矩形。这个过程递归地细化了域的划分。\n\n$2$. **定界**：对于任意矩形 $R \\subseteq D$，我们需要找到 $f(x)$ 在 $x \\in R$ 上的下界 $LB(R)$ 和全局最小值 $f^* = \\min_{x \\in D} f(x)$ 的上界 $U$。\n    - 上界 $U$ 是通过在候选点上评估 $f(x)$ 来获得的。任何已处理矩形 $R$ 的中心 $c_R$ 都是一个自然的候选点。incumbent（迄今为止最优的）上界被维护为 $U = \\min\\{f(c_R)\\}$，其中最小值取自所有已评估的中心点。\n    - $R$ 中 $f(x)$ 的一个下界由利普希茨性质推导得出。对于任意 $x \\in R$，我们有 $|f(x) - f(c_R)| \\le L \\|x - c_R\\|_2$。这意味着 $f(x) \\ge f(c_R) - L\\|x - c_R\\|_2$。这个不等式对所有 $x \\in R$ 都成立，因此我们可以通过最小化右侧来获得 $f(x)$ 的下界。当 $\\|x-c_R\\|_2$ 最大化时达到最小值。令 $r_R = \\max_{x \\in R} \\|x - c_R\\|_2$ 为矩形的半径。那么 $f(x)$在 $R$ 上的一个有效下界是：\n        $$\n        LB(R) = f(c_R) - L r_R\n        $$\n        这个界只有在所选常数 $L$ 大于或等于 $f$ 在 $D$ 上的真实利普希茨常数时才有效。对于矩形 $R=[x_{\\min},x_{\\max}]\\times[y_{\\min},y_{\\max}]$，其半径由 $r_R=\\sqrt{\\left(\\frac{x_{\\max}-x_{\\min}}{2}\\right)^2+\\left(\\frac{y_{\\max}-y_{\\min}}{2}\\right)^2}$ 给出。\n\n$3$. **算法流程**：该算法维护一个按其下界排序的活动矩形优先队列。\n    - **初始化**：以域 $D$ 开始，将其放入队列。用 $f(c_D)$ 初始化 incumbent 上界 $U$，其中 $c_D$ 是 $D$ 的中心。\n    - **选择**：在每次迭代中，从队列中选择并移除具有最小下界 $LB(R)$ 的矩形 $R$。这是一种最佳优先搜索策略。\n    - **剪枝**：满足 $LB(R') \\ge U$ 的矩形 $R'$ 可以从队列中被剪枝（丢弃），因为它们不可能包含比当前 incumbent 更好的解。\n    - **分支**：被选中的矩形 $R$ 被二等分为两个子矩形 $R_1$ 和 $R_2$。对于每个子矩形，评估其中心以可能更新 $U$，并计算其下界。如果下界小于 $U$，则将该子矩形添加到优先队列中。\n    - **终止**：当 incumbent 上界 $U$ 与所有活动矩形的最小下界 $\\min_R LB(R)$ 之间的差距小于给定容差 $\\varepsilon$ 时（即 $U - \\min_R LB(R) \\le \\varepsilon$），算法终止。如果达到矩形展开的最大次数 $N_{\\max}$，算法也会终止。\n\n$4$. **证明**：如果终止时满足两个条件，则全局最优性得到證明：（a）算法因满足容差条件 $U - \\min_R LB(R) \\le \\varepsilon$ 而终止，以及（b）用于计算下界的利普希茨常数 $L$ 是有效的，即 $L \\ge L_{\\text{true}}$。如果 $L  L_{\\text{true}}$，则下界不保证有效，算法可能会过早收敛到非全局最小值或无法證明最优性。如果在达到容差之前预算 $N_{\\max}$ 耗尽，则未获得證明。\n\n计算实现将遵循这一逻辑，首先计算理论值 $L_{\\text{true}}$，然后为每个测试用例执行 BnB 算法，最后根据定义的准则确定证明状态。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.spatial.distance import cdist\nimport heapq\n\n# Global definitions for the optimization problem\nB = 0.25\nCENTERS = np.array([\n    [1.3, 1.1], [-1.1, 1.2], [1.6, -0.7], [-1.4, -1.3], [0.3, -0.2]\n])\nOFFSETS = np.array([0.70, 0.65, 0.68, 0.66, 0.00])\nDOMAIN = np.array([-2.0, 2.0, -2.0, 2.0])  # [xmin, xmax, ymin, ymax]\nCORNERS = np.array([[x, y] for x in [-2.0, 2.0] for y in [-2.0, 2.0]])\n\ndef f(x: np.ndarray) - float:\n    \"\"\"\n    Computes the value of the multimodal objective function f(x).\n    x is a 2D point.\n    \"\"\"\n    x = np.atleast_2d(x)\n    # Calculate squared Euclidean distances from x to all centers\n    dist_sq = cdist(x, CENTERS, 'sqeuclidean')\n    # Calculate phi_i(x) for all i\n    phi_values = OFFSETS + B * dist_sq\n    # f(x) is the minimum of phi_i(x)\n    return np.min(phi_values)\n\ndef calculate_l_true() - float:\n    \"\"\"\n    Calculates the theoretically valid Lipschitz constant for f(x) on the domain D.\n    \"\"\"\n    # For each center, find the max distance to any of the 4 corners of the domain\n    max_dists_to_corners = np.max(cdist(CENTERS, CORNERS, 'euclidean'), axis=1)\n    # The true Lipschitz constant is 2*b*max(R_i)\n    l_true = 2 * B * np.max(max_dists_to_corners)\n    return l_true\n\ndef bnb_solve(L: float, epsilon: float, N_max: int, L_true: float):\n    \"\"\"\n    Performs the Branch and Bound optimization.\n\n    Args:\n        L: The user-chosen Lipschitz constant.\n        epsilon: The termination tolerance.\n        N_max: The maximum number of rectangle expansions.\n        L_true: The theoretically valid Lipschitz constant for certification.\n\n    Returns:\n        A tuple (U, certified, expansions) containing:\n        - U: The best function value found.\n        - certified: A boolean indicating if global optimality was certified.\n        - expansions: The number of rectangle expansions performed.\n    \"\"\"\n    # State-space is a priority queue of (lower_bound, tie_breaker, rectangle)\n    pq = []\n    tie_breaker = 0\n\n    # Initial rectangle is the whole domain\n    R0 = (DOMAIN[0], DOMAIN[1], DOMAIN[2], DOMAIN[3])\n    \n    # Initial upper bound from the center of the domain\n    c0 = np.array([(R0[0] + R0[1]) / 2, (R0[2] + R0[3]) / 2])\n    U = f(c0)\n    \n    # Radius and lower bound for the initial rectangle\n    w0, h0 = R0[1] - R0[0], R0[3] - R0[2]\n    r0 = np.sqrt((w0 / 2)**2 + (h0 / 2)**2)\n    lb0 = U - L * r0\n    \n    heapq.heappush(pq, (lb0, tie_breaker, R0))\n    tie_breaker += 1\n    \n    expansions = 0\n    \n    while pq and expansions  N_max:\n        min_lb = pq[0][0]\n        if U - min_lb = epsilon:\n            break\n\n        _, _, R = heapq.heappop(pq)\n        \n        # Pruning based on the updated incumbent U before expanding\n        # Note: popping implies its lb was  U at time of push.\n        # But U might have been updated, so a check can be useful.\n        # However, the main check is the termination condition above.\n        \n        expansions += 1\n        \n        # Branching: bisect the rectangle along its longest side\n        xmin, xmax, ymin, ymax = R\n        width = xmax - xmin\n        height = ymax - ymin\n        \n        if width = height:\n            mid = xmin + width / 2\n            R1, R2 = (xmin, mid, ymin, ymax), (mid, xmax, ymin, ymax)\n        else:\n            mid = ymin + height / 2\n            R1, R2 = (xmin, xmax, ymin, mid), (xmin, xmax, mid, ymax)\n            \n        for child_R in [R1, R2]:\n            # Bounding for each child rectangle\n            c_x = (child_R[0] + child_R[1]) / 2\n            c_y = (child_R[2] + child_R[3]) / 2\n            center = np.array([c_x, c_y])\n            \n            f_center = f(center)\n            if f_center  U:\n                U = f_center\n            \n            w, h = child_R[1] - child_R[0], child_R[3] - child_R[2]\n            radius = np.sqrt((w/2)**2 + (h/2)**2)\n            lb_child = f_center - L * radius\n            \n            if lb_child  U:\n                heapq.heappush(pq, (lb_child, tie_breaker, child_R))\n                tie_breaker += 1\n\n    # Check for certification\n    terminated_by_tol = False\n    if not pq: # All nodes were processed/pruned\n        terminated_by_tol = True\n    elif U - pq[0][0] = epsilon: # Terminated due to tolerance condition\n        terminated_by_tol = True\n        \n    is_certified = terminated_by_tol and (L = L_true)\n\n    return (U, is_certified, expansions)\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    L_true = calculate_l_true()\n    \n    test_cases = [\n        # Case 1 (happy path)\n        (L_true, 1e-3, 20000), \n        # Case 2 (underestimated constant)\n        (0.5 * L_true, 1e-3, 20000), \n        # Case 3 (overly conservative constant and tight budget)\n        (2.0 * L_true, 1e-3, 500), \n        # Case 4 (happy path with looser tolerance)\n        (L_true, 1e-2, 5000),\n    ]\n\n    results_str = []\n    for L, epsilon, N_max in test_cases:\n        U, certified, n_expansions = bnb_solve(L, epsilon, N_max, L_true)\n        # Format each result as a string \"[u,Bool,n]\"\n        results_str.append(f\"[{U},{certified},{n_expansions}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```"
        }
    ]
}