{
    "hands_on_practices": [
        {
            "introduction": "理论虽然为我们提供了性能保证，但在实践中，我们常常寻求用简单的方法找到更好的解。第一个练习将带你实践经典的设施选址问题，你需要实现标准的贪心算法。接着，你将探索一种强大的启发式方法——单次交换局部搜索——来改进贪心解，并分析方案质量提升与额外计算成本之间的权衡。",
            "id": "3189733",
            "problem": "给定一个由子模优化中的设施选址目标产生的一族集合函数。设有限全集表示为 $\\mathcal{V} = \\{0,1,\\dots,n-1\\}$，非负权重矩阵表示为 $W \\in \\mathbb{R}_{\\ge 0}^{n \\times m}$。对于任意子集 $S \\subseteq \\mathcal{V}$，设施选址目标定义为\n$$\nf(S) \\;=\\; \\sum_{j=0}^{m-1} \\max_{i \\in S} W_{i,j},\n$$\n约定 $f(\\varnothing) = 0$。任务是选择一个固定基数为 $k$ 的子集 $S$，使得 $f(S)$ 尽可能大。\n\n基础知识：\n- 一个集合函数 $f: 2^{\\mathcal{V}} \\to \\mathbb{R}$ 称为单调的，如果对于所有 $A \\subseteq B \\subseteq \\mathcal{V}$，我们有 $f(A) \\le f(B)$；称为子模的，如果对于所有 $A \\subseteq B \\subseteq \\mathcal{V}$ 和所有 $x \\in \\mathcal{V} \\setminus B$，我们有 $f(A \\cup \\{x\\}) - f(A) \\ge f(B \\cup \\{x\\}) - f(B)$。\n- 上面定义的设施选址目标 $f$ 是一个著名的单调子模函数。\n\n需要实现的算法：\n- 基数约束下的贪心选择算法：从空集 $S_0 = \\varnothing$ 开始，对于 $t = 1,2,\\dots,k$，添加一个元素 $x_t \\in \\mathcal{V} \\setminus S_{t-1}$，该元素能够最大化边际增益 $f(S_{t-1} \\cup \\{x\\}) - f(S_{t-1})$。使用以下确定性规则打破平局：在所有最大化增益的元素中，选择索引最小的一个。令 $S_{\\mathrm{greedy}}$ 表示最终得到的集合。\n- 单次最佳 1-交换局部改进：给定 $S_{\\mathrm{greedy}}$，考虑所有满足 $a \\in S_{\\mathrm{greedy}}$ 和 $b \\in \\mathcal{V} \\setminus S_{\\mathrm{greedy}}$ 的配对 $(a,b)$。对每个配对，计算 $f(S_{\\mathrm{greedy}} \\setminus \\{a\\} \\cup \\{b\\})$ 的值。令 $(a^\\star,b^\\star)$ 是获得最大值的配对；通过选择字典序最小的配对 $(a,b)$ 来打破平局，即先按 $a$ 的最小值，如果相同则按 $b$ 的最小值。如果这个最大值严格大于 $f(S_{\\mathrm{greedy}})$，则执行一次交换得到 $S_{\\mathrm{swap}} = S_{\\mathrm{greedy}} \\setminus \\{a^\\star\\} \\cup \\{b^\\star\\}$。否则，令 $S_{\\mathrm{swap}} = S_{\\mathrm{greedy}}$。\n\n成本模型：\n- 将 $f$ 的评估视为一次单位成本的预言机调用。每当对一个具体集合计算 $f(\\cdot)$ 时，都计为一次预言机调用。\n- 在贪心算法中，不计算 $f(\\varnothing)$；对于评估的每个候选集 $S \\cup \\{x\\}$，计为一次预言机调用。不要进行冗余的预言机调用；将所选候选集的目标值作为当前集合的值传递到下一次迭代，无需额外的预言机调用。\n- 在单次最佳 1-交换阶段，每个评估的候选交换集恰好计为一次预言机调用。不要在该单次最佳交换尝试之后进行迭代；最多执行一次改进交换。\n\n实证任务：\n- 对于每个测试实例，计算改进量 $\\Delta = f(S_{\\mathrm{swap}}) - f(S_{\\mathrm{greedy}})$ 和乘性预言机成本因子\n$$\n\\varrho \\;=\\; \\frac{E_{\\mathrm{greedy}} + E_{\\mathrm{swap}}}{E_{\\mathrm{greedy}}},\n$$\n其中 $E_{\\mathrm{greedy}}$ 是贪心阶段的预言机调用次数，$E_{\\mathrm{swap}}$ 是单次最佳 1-交换阶段的预言机调用次数。\n- 报告每个测试用例的 $\\Delta$ 和 $\\varrho$。\n\n测试套件：\n- 用例 1：$n = 4$, $m = 6$, $k = 3$，其中\n$$\nW^{(1)} \\;=\\; \\begin{bmatrix}\n5  & 5 & 5 & 5 & 5 & 5 \\\\\n10 & 10 & 0 & 0 & 0 & 0 \\\\\n0 & 0 & 9 & 9 & 0 & 0 \\\\\n0 & 0 & 0 & 0 & 9 & 9\n\\end{bmatrix}.\n$$\n- 用例 2：$n = 4$, $m = 4$, $k = 2$，其中所有行相同，\n$$\nW^{(2)} \\;=\\; \\begin{bmatrix}\n3 & 3 & 3 & 3 \\\\\n3 & 3 & 3 & 3 \\\\\n3 & 3 & 3 & 3 \\\\\n3 & 3 & 3 & 3\n\\end{bmatrix}.\n$$\n- 用例 3：$n = 4$, $m = 5$, $k = 2$，其中\n$$\nW^{(3)} \\;=\\; \\begin{bmatrix}\n5 & 5 & 5 & 5 & 5 \\\\\n10 & 10 & 0 & 0 & 0 \\\\\n0 & 0 & 9 & 9 & 0 \\\\\n0 & 0 & 0 & 0 & 9\n\\end{bmatrix}.\n$$\n\n必需的最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。该列表必须按顺序包含用例 1、用例 2、用例 3 的 $[\\Delta,\\varrho]$ 对，并扁平化为单个列表。具体来说，输出\n$$\n[\\Delta^{(1)},\\varrho^{(1)},\\Delta^{(2)},\\varrho^{(2)},\\Delta^{(3)},\\varrho^{(3)}].\n$$\n- 所有报告的值都必须是实数（浮点数）。不得打印任何其他文本。",
            "solution": "用户想要分析贪心算法和随后的局部搜索改进步骤在设施选址问题上的性能，这是一个在基数约束下最大化单调子模函数的经典例子。\n\n### 步骤 1：问题验证\n\n**1. 提取给定条件**\n\n- **全集**：有限集 $\\mathcal{V} = \\{0, 1, \\dots, n-1\\}$。\n- **权重矩阵**：非负矩阵 $W \\in \\mathbb{R}_{\\ge 0}^{n \\times m}$。\n- **目标函数**：对于任意子集 $S \\subseteq \\mathcal{V}$，设施选址目标为 $f(S) = \\sum_{j=0}^{m-1} \\max_{i \\in S} W_{i,j}$，并约定 $f(\\varnothing) = 0$。\n- **约束**：所选子集 $S$ 必须具有固定的基数 $|S|=k$。\n- **基础知识**：函数 $f$ 被说明为单调且子模的。\n- **贪心算法**：\n    - 从 $S_0 = \\varnothing$ 开始。\n    - 对于 $t=1, \\dots, k$，选择 $x_t \\in \\mathcal{V} \\setminus S_{t-1}$ 以最大化边际增益 $f(S_{t-1} \\cup \\{x\\}) - f(S_{t-1})$。\n    - 打破平局：在所有最大化增益的元素中，选择索引最小的一个。结果集合为 $S_{\\mathrm{greedy}}$。\n- **单次最佳 1-交换算法**：\n    - 给定 $S_{\\mathrm{greedy}}$，考虑所有 $a \\in S_{\\mathrm{greedy}}$ 和 $b \\in \\mathcal{V} \\setminus S_{\\mathrm{greedy}}$ 的配对 $(a,b)$。\n    - 找到使 $f(S_{\\mathrm{greedy}} \\setminus \\{a\\} \\cup \\{b\\})$ 最大化的配对 $(a^\\star, b^\\star)$。\n    - 打破平局：选择字典序最小的配对 $(a,b)$。\n    - 如果 $f(S_{\\mathrm{greedy}} \\setminus \\{a^\\star\\} \\cup \\{b^\\star\\}) > f(S_{\\mathrm{greedy}})$，则令 $S_{\\mathrm{swap}} = S_{\\mathrm{greedy}} \\setminus \\{a^\\star\\} \\cup \\{b^\\star\\}$。\n    - 否则，$S_{\\mathrm{swap}} = S_{\\mathrm{greedy}}$。\n- **成本模型**：\n    - $f(\\cdot)$ 的评估为一次单位成本的预言机调用。\n    - 贪心阶段：不计算 $f(\\varnothing)$。每个候选集 $S \\cup \\{x\\}$ 的评估计为一次调用。$f(S_t)$ 的值从第 $t$ 步中最佳候选的评估中继承。$E_{\\mathrm{greedy}}$ 是总调用次数。\n    - 交换阶段：每个候选交换集的评估计为一次调用。$E_{\\mathrm{swap}}$ 是总调用次数。\n- **实证任务**：\n    - 计算改进量 $\\Delta = f(S_{\\mathrm{swap}}) - f(S_{\\mathrm{greedy}})$。\n    - 计算预言机成本因子 $\\varrho = (E_{\\mathrm{greedy}} + E_{\\mathrm{swap}}) / E_{\\mathrm{greedy}}$。\n- **测试套件**：\n    - 用例 1：$n=4, m=6, k=3$, $W^{(1)} = \\begin{bmatrix} 5 & 5 & 5 & 5 & 5 & 5 \\\\ 10 & 10 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 9 & 9 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & 9 & 9 \\end{bmatrix}$。\n    - 用例 2：$n=4, m=4, k=2$, $W^{(2)} = \\begin{bmatrix} 3 & 3 & 3 & 3 \\\\ 3 & 3 & 3 & 3 \\\\ 3 & 3 & 3 & 3 \\\\ 3 & 3 & 3 & 3 \\end{bmatrix}$。\n    - 用例 3：$n=4, m=5, k=2$, $W^{(3)} = \\begin{bmatrix} 5 & 5 & 5 & 5 & 5 \\\\ 10 & 10 & 0 & 0 & 0 \\\\ 0 & 0 & 9 & 9 & 0 \\\\ 0 & 0 & 0 & 0 & 9 \\end{bmatrix}$。\n- **输出格式**：单行 $[\\Delta^{(1)},\\varrho^{(1)},\\Delta^{(2)},\\varrho^{(2)},\\Delta^{(3)},\\varrho^{(3)}]$。\n\n**2. 使用提取的给定条件进行验证**\n\n问题陈述是在子模优化的标准框架内一个明确定义的算法实现与分析练习。\n- **科学严谨**：问题基于设施选址函数，这是单调子模函数的经典例子。所用算法（贪心和局部搜索）是针对此类问题的标准且被广泛研究的方法。\n- **定义明确**：问题以完整的信息给出。目标函数、算法、约束和打破平局的规则都已精确定义，确保每个测试用例都有唯一、确定性的结果。\n- **客观性**：问题使用形式化的数学语言陈述，没有任何主观或模糊的术语。\n\n**3. 结论与行动**\n\n问题是**有效的**。它自成一体、科学合理且定义明确。我将继续进行完整解答。\n\n### 步骤 2：求解推导\n\n解决方案需要实现设施选址目标函数、贪心选择算法和单次最佳 1-交换局部搜索过程。我们将把这些应用于每个测试用例，并计算所需的指标 $\\Delta$ 和 $\\varrho$。\n\n**目标函数预言机**\n\n对于给定的集合 $S \\subseteq \\mathcal{V}$ 和权重矩阵 $W$，函数 $f(S)$ 为 $f(S) = \\sum_{j=0}^{m-1} \\max_{i \\in S} W_{i,j}$。此函数的预言机将以行索引集合 $S$ 和矩阵 $W$ 作为输入。如果 $S$ 为空，则返回 0。否则，它选择 $W$ 中对应于 $S$ 中索引的行，找到该子矩阵每列的最大值，并返回这些最大值的和。每次调用此预言机都将被计数。\n\n**贪心算法**\n\n贪心算法迭代地构建一个大小为 $k$ 的集合 $S_{\\mathrm{greedy}}$。\n1.  初始化 $S_0 = \\varnothing$ 和 $f(S_0)=0$。\n2.  对于从 $1$ 到 $k$ 的每次迭代 $t$：\n    a.  设 $S_{t-1}$ 是前一次迭代的集合。可用元素集为 $\\mathcal{V} \\setminus S_{t-1}$。\n    b.  对于每个元素 $x \\in \\mathcal{V} \\setminus S_{t-1}$，计算边际增益 $g(x) = f(S_{t-1} \\cup \\{x\\}) - f(S_{t-1})$。这需要 $|\\mathcal{V} \\setminus S_{t-1}| = n - (t-1)$ 次预言机调用。\n    c.  找到最大增益 $g_{\\max} = \\max_{x \\in \\mathcal{V} \\setminus S_{t-1}} g(x)$。\n    d.  确定最大化增益的元素集 $X_{\\max} = \\{x \\in \\mathcal{V} \\setminus S_{t-1} | g(x) = g_{\\max}\\}$。\n    e.  应用打破平局的规则：选择元素 $x_t = \\min(X_{\\max})$。\n    f.  更新集合 $S_t = S_{t-1} \\cup \\{x_t\\}$。值 $f(S_t)$ 从步骤 2b 中的评估中已知，并被继承。\n\n贪心阶段的总预言机调用次数为 $E_{\\mathrm{greedy}} = \\sum_{t=1}^{k} (n - (t-1)) = \\sum_{i=0}^{k-1} (n - i) = nk - \\frac{k(k-1)}{2}$。\n\n**单次最佳 1-交换局部搜索**\n\n获得 $S_{\\mathrm{greedy}}$ 和 $f(S_{\\mathrm{greedy}})$ 后，我们执行一个单步的局部搜索改进。\n1.  确定要交换入的元素集 $B = \\mathcal{V} \\setminus S_{\\mathrm{greedy}}$，以及要交换出的元素集 $A = S_{\\mathrm{greedy}}$。\n2.  对于每个配对 $(a, b)$，其中 $a \\in A$ 且 $b \\in B$，形成一个候选集 $S'_{a,b} = (S_{\\mathrm{greedy}} \\setminus \\{a\\}) \\cup \\{b\\}$。\n3.  对每个配对评估 $f(S'_{a,b})$。这需要 $|A| \\times |B| = k(n-k)$ 次预言机调用。这是 $E_{\\mathrm{swap}}$ 的值。\n4.  找到任何交换所能实现的最大目标值：$f_{\\max} = \\max_{a \\in A, b \\in B} f(S'_{a,b})$。\n5.  如果 $f_{\\max} \\le f(S_{\\mathrm{greedy}})$，则未找到改进。设 $S_{\\mathrm{swap}} = S_{\\mathrm{greedy}}$ 且 $f(S_{\\mathrm{swap}}) = f(S_{\\mathrm{greedy}})$。\n6.  如果 $f_{\\max} > f(S_{\\mathrm{greedy}})$，则存在改进。\n    a.  确定最佳配对的集合：$P_{\\max} = \\{(a,b) | a \\in A, b \\in B, f(S'_{a,b}) = f_{\\max}\\}$。\n    b.  应用打破平局的规则：从 $P_{\\max}$ 中选择字典序最小的配对 $(a^\\star, b^\\star)$。\n    c.  执行交换：$S_{\\mathrm{swap}} = (S_{\\mathrm{greedy}} \\setminus \\{a^\\star\\}) \\cup \\{b^\\star\\}$，并设 $f(S_{\\mathrm{swap}}) = f_{\\max}$。\n\n**测试用例计算**\n\n让我们将此过程应用于每个用例。\n\n**用例 1：** $n=4, k=3$。\n- **贪心阶段**：\n    - $S_0=\\varnothing, f(S_0)=0$。\n    - 迭代 1：候选集 $\\{0,1,2,3\\}$。$f(\\{0\\})=30, f(\\{1\\})=20, f(\\{2\\})=18, f(\\{3\\})=18$。最大增益来自 $x_1=0$。$S_1=\\{0\\}, f(S_1)=30$。调用次数：$4$。\n    - 迭代 2：候选集 $\\{1,2,3\\}$。$f(\\{0,1\\})=40, f(\\{0,2\\})=38, f(\\{0,3\\})=38$。最大增益来自 $x_2=1$。$S_2=\\{0,1\\}, f(S_2)=40$。调用次数：$3$。\n    - 迭代 3：候选集 $\\{2,3\\}$。$f(\\{0,1,2\\})=48, f(\\{0,1,3\\})=48$。最大增益出现平局。最小索引为 $2$。$x_3=2$。$S_3=\\{0,1,2\\}, f(S_3)=48$。调用次数：$2$。\n    - 结果：$S_{\\mathrm{greedy}} = \\{0,1,2\\}$，$f(S_{\\mathrm{greedy}}) = 48$。$E_{\\mathrm{greedy}} = 4+3+2=9$。\n- **交换阶段**：\n    - 对 $a \\in \\{0,1,2\\}, b \\in \\{3\\}$ 进行交换 $(a,b)$。\n    - 评估 $f(\\{1,2,3\\})$（对于 $(a,b)=(0,3)$）：$\\sum \\max(W_{1j},W_{2j},W_{3j}) = 10+10+9+9+9+9=56$。\n    - 评估 $f(\\{0,2,3\\})$（对于 $(a,b)=(1,3)$）：$\\sum \\max(W_{0j},W_{2j},W_{3j}) = 5+5+9+9+9+9=46$。\n    - 评估 $f(\\{0,1,3\\})$（对于 $(a,b)=(2,3)$）：$\\sum \\max(W_{0j},W_{1j},W_{3j}) = 10+10+5+5+9+9=48$。\n    - 最大值为 $56$，来自配对 $(0,3)$。此值 $> 48$。\n    - 结果：$S_{\\mathrm{swap}} = \\{1,2,3\\}$，$f(S_{\\mathrm{swap}}) = 56$。$E_{\\mathrm{swap}}=3$。\n- **指标**：\n    - $\\Delta^{(1)} = 56 - 48 = 8$。\n    - $\\varrho^{(1)} = (9+3)/9 = 12/9 \\approx 1.3333$。\n\n**用例 2：** $n=4, k=2$。$W$ 的所有元素均为 $3$。对于任意 $S \\neq \\varnothing, f(S) = \\sum_{j=0}^3 3 = 12$。\n- **贪心阶段**：\n    - $S_0=\\varnothing, f(S_0)=0$。\n    - 迭代 1：候选集 $\\{0,1,2,3\\}$。$f(\\{0\\})=f(\\{1\\})=f(\\{2\\})=f(\\{3\\})=12$。所有元素增益最大。打破平局：$x_1=0$。$S_1=\\{0\\}, f(S_1)=12$。调用次数：$4$。\n    - 迭代 2：候选集 $\\{1,2,3\\}$。$f(\\{0,1\\})=f(\\{0,2\\})=f(\\{0,3\\})=12$。增益均为 $0$。打破平局：$x_2=1$。$S_2=\\{0,1\\}, f(S_2)=12$。调用次数：$3$。\n    - 结果：$S_{\\mathrm{greedy}} = \\{0,1\\}$，$f(S_{\\mathrm{greedy}}) = 12$。$E_{\\mathrm{greedy}} = 4+3=7$。\n- **交换阶段**：\n    - 对 $a \\in \\{0,1\\}, b \\in \\{2,3\\}$ 进行交换 $(a,b)$。任何交换都会产生一个大小为 $2$ 的集合，因此其函数值为 $12$。\n    - 最大值为 $12$，不严格大于 $f(S_{\\mathrm{greedy}})=12$。不执行交换。\n    - 结果：$S_{\\mathrm{swap}} = S_{\\mathrm{greedy}} = \\{0,1\\}$，$f(S_{\\mathrm{swap}}) = 12$。$E_{\\mathrm{swap}}=k(n-k)=2(4-2)=4$。\n- **指标**：\n    - $\\Delta^{(2)} = 12 - 12 = 0$。\n    - $\\varrho^{(2)} = (7+4)/7 = 11/7 \\approx 1.5714$。\n\n**用例 3：** $n=4, k=2$。\n- **贪心阶段**：\n    - $S_0=\\varnothing, f(S_0)=0$。\n    - 迭代 1：候选集 $\\{0,1,2,3\\}$。$f(\\{0\\})=25, f(\\{1\\})=20, f(\\{2\\})=18, f(\\{3\\})=9$。最大增益来自 $x_1=0$。$S_1=\\{0\\}, f(S_1)=25$。调用次数：$4$。\n    - 迭代 2：候选集 $\\{1,2,3\\}$。$f(\\{0,1\\})=35$（增益 10），$f(\\{0,2\\})=33$（增益 8），$f(\\{0,3\\})=29$（增益 4）。最大增益来自 $x_2=1$。$S_2=\\{0,1\\}, f(S_2)=35$。调用次数：$3$。\n    - 结果：$S_{\\mathrm{greedy}} = \\{0,1\\}$，$f(S_{\\mathrm{greedy}}) = 35$。$E_{\\mathrm{greedy}} = 4+3=7$。\n- **交换阶段**：\n    - 对 $a \\in \\{0,1\\}, b \\in \\{2,3\\}$ 进行交换 $(a,b)$。\n    - 评估 $f(\\{1,2\\})$（对于 $(a,b)=(0,2)$）：$10+10+9+9+0 = 38$。\n    - 评估 $f(\\{1,3\\})$（对于 $(a,b)=(0,3)$）：$10+10+0+0+9=29$。\n    - 评估 $f(\\{0,2\\})$（对于 $(a,b)=(1,2)$）：$5+5+9+9+5 = 33$。\n    - 评估 $f(\\{0,3\\})$（对于 $(a,b)=(1,3)$）：$5+5+5+5+9=29$。\n    - 最大值为 $38$，来自配对 $(0,2)$。此值 $> 35$。\n    - 结果：$S_{\\mathrm{swap}} = \\{1,2\\}$，$f(S_{\\mathrm{swap}}) = 38$。$E_{\\mathrm{swap}}=k(n-k)=2(4-2)=4$。\n- **指标**：\n    - $\\Delta^{(3)} = 38 - 35 = 3$。\n    - $\\varrho^{(3)} = (7+4)/7 = 11/7 \\approx 1.5714$。\n\n最终需报告的结果：\n$[\\Delta^{(1)}, \\varrho^{(1)}, \\Delta^{(2)}, \\varrho^{(2)}, \\Delta^{(3)}, \\varrho^{(3)}] = [8.0, 1.3333..., 0.0, 1.5714..., 3.0, 1.5714...]$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It orchestrates the execution of algorithms on each test case and prints the final result.\n    \"\"\"\n\n    def f_oracle(S, W):\n        \"\"\"\n        Computes the facility location objective function value f(S).\n        This is the core oracle function.\n        \n        Args:\n            S (set): A subset of the ground set {0, ..., n-1}.\n            W (np.ndarray): The weight matrix.\n            \n        Returns:\n            float: The value of f(S).\n        \"\"\"\n        # The convention is f(emptyset) = 0\n        if not S:\n            return 0.0\n        \n        # Select rows corresponding to indices in S\n        s_list = list(S)\n        \n        # Compute max over selected rows (axis=0) for each column\n        # and sum the results.\n        return np.sum(np.max(W[s_list, :], axis=0))\n\n    def run_case(W, k):\n        \"\"\"\n        Runs the greedy and 1-swap algorithms for a single test case.\n        \n        Args:\n            W (np.ndarray): The n x m weight matrix.\n            k (int): The cardinality constraint.\n            \n        Returns:\n            tuple: A pair (delta, rho) containing the improvement and oracle cost factor.\n        \"\"\"\n        n, _ = W.shape\n        V = set(range(n))\n\n        # ---- Greedy Algorithm ----\n        S_current = set()\n        f_current = 0.0\n        E_greedy = 0\n\n        for _ in range(k):\n            candidates = V - S_current\n            \n            # Store gains and resulting f-values for all candidates\n            candidate_evals = {}\n            for x in candidates:\n                S_candidate = S_current | {x}\n                f_val = f_oracle(S_candidate, W)\n                E_greedy += 1\n                gain = f_val - f_current\n                candidate_evals[x] = {'gain': gain, 'f_val': f_val}\n\n            # Find the maximum gain\n            max_gain = -np.inf\n            if candidate_evals:\n                max_gain = max(v['gain'] for v in candidate_evals.values())\n\n            # Find all elements that achieve the maximum gain\n            maximizers = [x for x, v in candidate_evals.items() if v['gain'] == max_gain]\n            \n            # Tie-break by choosing the smallest index\n            best_x = min(maximizers)\n            \n            # Update the set and its function value\n            S_current.add(best_x)\n            f_current = candidate_evals[best_x]['f_val']\n        \n        S_greedy = S_current\n        f_greedy = f_current\n\n        # ---- Single Best 1-Swap Local Improvement ----\n        E_swap = 0\n        S_outside = V - S_greedy\n        \n        # Store results of all possible 1-swaps\n        swap_evals = {}\n        for a in S_greedy:\n            for b in S_outside:\n                S_candidate = (S_greedy - {a}) | {b}\n                f_val = f_oracle(S_candidate, W)\n                E_swap += 1\n                swap_evals[(a, b)] = f_val\n        \n        # Find the maximum function value among all swaps\n        max_f_swap = -np.inf\n        if swap_evals:\n            max_f_swap = max(swap_evals.values())\n\n        S_swap = S_greedy\n        f_swap = f_greedy\n\n        # Check for strict improvement\n        if max_f_swap > f_greedy:\n            # Find all pairs that achieve the maximum value\n            best_pairs = [pair for pair, val in swap_evals.items() if val == max_f_swap]\n            \n            # Tie-break by lexicographically smallest pair (a,b)\n            best_pairs.sort()\n            a_star, b_star = best_pairs[0]\n            \n            S_swap = (S_greedy - {a_star}) | {b_star}\n            f_swap = max_f_swap\n\n        # ---- Compute Metrics ----\n        delta = f_swap - f_greedy\n        \n        if E_greedy == 0:\n             # handle k=0 case, although not in test suite\n            rho = 1.0 if E_swap == 0 else np.inf\n        else:\n            rho = (E_greedy + E_swap) / E_greedy\n\n        return delta, rho\n\n    # --- Test Suite ---\n    test_cases = [\n        # Case 1\n        (\n            np.array([\n                [5, 5, 5, 5, 5, 5],\n                [10, 10, 0, 0, 0, 0],\n                [0, 0, 9, 9, 0, 0],\n                [0, 0, 0, 0, 9, 9]\n            ]),\n            3\n        ),\n        # Case 2\n        (\n            np.array([\n                [3, 3, 3, 3],\n                [3, 3, 3, 3],\n                [3, 3, 3, 3],\n                [3, 3, 3, 3]\n            ]),\n            2\n        ),\n        # Case 3\n        (\n            np.array([\n                [5, 5, 5, 5, 5],\n                [10, 10, 0, 0, 0],\n                [0, 0, 9, 9, 0],\n                [0, 0, 0, 0, 9]\n            ]),\n            2\n        )\n    ]\n    \n    # --- Run and Collect Results ---\n    results_flat = []\n    for W, k in test_cases:\n        delta, rho = run_case(W, k)\n        results_flat.extend([float(delta), float(rho)])\n\n    # --- Print Final Output ---\n    # Format: [d1,r1,d2,r2,d3,r3]\n    result_str = \",\".join(map(str, results_flat))\n    print(f\"[{result_str}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "许多现实世界中的优化问题（如著名的 $k$-中位数问题）并不具有子模性，因而难以求解。一个关键策略是使用一个子模函数作为易于处理的代理（proxy）。这个练习将挑战你首先从理论上证明设施选址函数确实是子模的，然后通过实验来研究这个代理函数在为实际的 $k$-中位数问题寻找优质解方面的有效性。",
            "id": "3189779",
            "problem": "考虑一个有限基集 $V = \\{1,2,\\dots,n\\}$ 和一个距离函数 $d: V \\times V \\to \\mathbb{R}_{\\ge 0}$，该函数满足度量公理：对于所有 $i,j,k \\in V$，$d(i,j) = 0$ 当且仅当 $i=j$，$d(i,j) = d(j,i)$，以及 $d(i,k) \\le d(i,j) + d(j,k)$。对于任意大小为 $|S| = k$ 的选择 $S \\subseteq V$，k-中位代价由集函数 $C(S) = \\sum_{j \\in V} \\min_{i \\in S} d(i,j)$ 定义。\n\n定义一个非负相似度矩阵 $W \\in \\mathbb{R}_{\\ge 0}^{n \\times n}$，其元素 $w_{ij}$ 通过任意固定的非增变换从距离 $d(i,j)$ 得到，该变换将较大的距离映射为较小或相等的相似度，例如，对于选定的半径 $r > 0$，$w_{ij} = \\max(0, r - d(i,j))$。设施选址函数定义为 $f(S) = \\sum_{j \\in V} \\max_{i \\in S} w_{ij}$。\n\n任务 1 (理论)：仅从子模性的核心定义和上述定义出发，证明对于任意非负相似度矩阵 $W$，$f(S)$ 是 $2^V$ 上的一个单调子模函数。使用子模性的收益递减特性：如果对于所有 $A \\subseteq B \\subseteq V$ 和 $x \\in V \\setminus B$，都满足 $f(A \\cup \\{x\\}) - f(A) \\ge f(B \\cup \\{x\\}) - f(B)$，则集函数 $f: 2^V \\to \\mathbb{R}$ 是子模的。同时证明单调性：对于 $A \\subseteq B$，$f(A) \\le f(B)$。\n\n任务 2 (算法与实证)：实现贪心算法，在基数约束 $|S| = k$ 下最大化设施选址函数。该算法应迭代地添加具有最大边际增益 $f(S \\cup \\{x\\}) - f(S)$ 的元素 $x \\in V \\setminus S$，直到 $|S| = k$。使用从欧几里得平面中的点生成的合成度量，将贪心设施选址算法返回的集合 $S$ 的 k-中位代价 $C(S)$ 与通过对所有 $\\binom{n}{k}$ 个子集进行穷举搜索得到的最优 k-中位解进行比较。通过比率 $R = C(S_{\\mathrm{FL}})/C(S_{\\mathrm{OPT}})$ 来凭经验量化近似质量，其中 $S_{\\mathrm{FL}}$ 是贪心设施选址解，$S_{\\mathrm{OPT}}$ 是精确的 k-中位最小化解。不涉及物理单位，也不出现角度，因此不需要单位说明。\n\n测试套件与参数：\n- 在 $\\mathbb{R}^2$ 中使用欧几里得距离，即对于坐标为 $(x_i, y_i)$ 的点，定义 $d(i,j) = \\sqrt{(x_i - x_j)^2 + (y_i - y_j)^2}$。\n- 对于相似度变换，在每种情况下使用 $w_{ij} = \\max(0, r - d(i,j))$ 和指定的 $r$。\n- 提供三个测试用例，涵盖正常路径、边界和边缘情况：\n  1.  用例 A (正常路径)：$n = 12$，两个分离良好的簇，中心分别位于 $(0,0)$ 和 $(5,5)$ 附近，$k = 2$，$r = 3.0$。\n  2.  用例 B (边界情况)：$n = 12$，一个位于 $(0,0)$ 附近的紧凑单簇，$k = 1$，$r = 1.5$。\n  3.  用例 C (边缘情况)：$n = 9$，三个中等分离的簇，中心分别位于 $(0,0)$、$(4,0)$ 和 $(0,4)$ 附近，$k = 3$，$r = 2.0$。\n\n程序要求：\n- 程序必须构建指定的合成点集，计算成对距离矩阵 $d(i,j)$，通过 $w_{ij} = \\max(0, r - d(i,j))$ 构建相似度矩阵 $W$，运行贪心设施选址算法以获得 $S_{\\mathrm{FL}}$，计算 $C(S_{\\mathrm{FL}})$，通过穷举搜索计算精确的最优 k-中位解 $S_{\\mathrm{OPT}}$ 及其 $C(S_{\\mathrm{OPT}})$，然后为每个测试用例计算比率 $R = C(S_{\\mathrm{FL}})/C(S_{\\mathrm{OPT}})$。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[result1,result2,result3]”），每个结果对应相应测试用例的比率 $R$。每个结果必须是浮点数。\n\n实现必须是自包含和确定性的，不需要用户输入、外部文件或网络访问。唯一允许的库是 Python 标准库和指定的数值库。确保合成数据集使用固定的坐标构建，以便结果在多次运行中可复现。",
            "solution": "该问题陈述已经过严格验证，被认为是具有科学依据、适定、客观和完整的。它在子模优化这一成熟领域内提出了一个标准的理论练习和一个受约束的实证任务。这些任务在计算上是可行的，并且参数的规定足以实现一个确定性和可复现的实现。\n\n### **任务 1：理论分析**\n\n任务是证明设施选址函数 $f(S)$ 是单调且子模的。该函数定义在基集 $V = \\{1, 2, \\dots, n\\}$ 的子集上，形式为 $f(S) = \\sum_{j \\in V} \\max_{i \\in S} w_{ij}$，其中 $W$ 是一个非负相似度矩阵，$w_{ij} \\ge 0$。\n\n我们可以将函数 $f(S)$ 表示为更简单函数的和。对于每个元素 $j \\in V$，我们定义一个函数 $g_j(S): 2^V \\to \\mathbb{R}$ 如下：\n$$\ng_j(S) = \\max_{i \\in S} w_{ij}\n$$\n根据这个定义，设施选址函数可以写成：\n$$\nf(S) = \\sum_{j \\in V} g_j(S)\n$$\n单调性和子模性在非负线性组合下是封闭的。因此，如果我们能证明每个函数 $g_j(S)$ 都是单调且子模的，那么 $f(S)$ 也将是单调且子模的，因为它是这些函数的和。按照惯例，非负数空集上的最大值取为 $0$，所以对所有 $j \\in V$ 都有 $g_j(\\emptyset) = 0$，这意味着 $f(\\emptyset) = 0$。\n\n**1. 单调性证明**\n\n如果对于任意子集 $A \\subseteq B \\subseteq V$，都有 $f(A) \\le f(B)$ 成立，则函数 $f$ 是单调的。我们将为每个 $g_j(S)$ 证明这一点。\n\n设 $A \\subseteq B \\subseteq V$。对于任意固定的 $j \\in V$，相似度集合 $\\{w_{ij} \\mid i \\in A\\}$ 是 $\\{w_{ij} \\mid i \\in B\\}$ 的一个子集。一个数集的最大值总是小于或等于其任意超集的最大值。因此，\n$$\n\\max_{i \\in A} w_{ij} \\le \\max_{i \\in B} w_{ij}\n$$\n这等价于 $g_j(A) \\le g_j(B)$。由于这个不等式对所有 $j \\in V$ 都成立，对所有 $j$ 求和会保持该不等式：\n$$\n\\sum_{j \\in V} g_j(A) \\le \\sum_{j \\in V} g_j(B)\n$$\n这直接得出 $f(A) \\le f(B)$，从而证明了设施选址函数 $f(S)$ 是单调的。\n\n**2. 子模性证明**\n\n如果一个函数表现出收益递减的性质，那么它就是子模的。也就是说，对于任意子集 $A \\subseteq B \\subseteq V$ 和任意元素 $x \\in V \\setminus B$，将 $x$ 添加到较小集合 $A$ 的边际增益大于或等于将其添加到较大集合 $B$ 的边际增益：\n$$\nf(A \\cup \\{x\\}) - f(A) \\ge f(B \\cup \\{x\\}) - f(B)\n$$\n同样，我们首先为每个分量函数 $g_j(S)$ 证明这个性质。对于函数 $g_j$，将一个元素 $x \\notin S$ 添加到集合 $S$ 的边际增益是：\n$$\n\\Delta_{g_j}(x | S) = g_j(S \\cup \\{x\\}) - g_j(S) = \\max_{i \\in S \\cup \\{x\\}} w_{ij} - \\max_{i \\in S} w_{ij}\n$$\n利用性质 $\\max(a, b) - b = \\max(0, a-b)$，我们可以将边际增益重写为：\n$$\n\\Delta_{g_j}(x | S) = \\max(w_{xj}, \\max_{i \\in S} w_{ij}) - \\max_{i \\in S} w_{ij} = \\max(0, w_{xj} - \\max_{i \\in S} w_{ij})\n$$\n现在，设 $A \\subseteq B \\subseteq V$ 且 $x \\in V \\setminus B$。根据我们刚刚证明的 $g_j$ 的单调性，我们知道 $g_j(A) \\le g_j(B)$，这意味着：\n$$\n\\max_{i \\in A} w_{ij} \\le \\max_{i \\in B} w_{ij}\n$$\n我们来分析函数 $h(z) = \\max(0, c - z)$，其中 $c$ 是某个常数。该函数关于其参数 $z$ 是非增的。设 $c = w_{xj}$。那么集合 $A$ 和 $B$ 的边际增益可以写成：\n$$\n\\Delta_{g_j}(x | A) = \\max(0, w_{xj} - \\max_{i \\in A} w_{ij})\n$$\n$$\n\\Delta_{g_j}(x | B) = \\max(0, w_{xj} - \\max_{i \\in B} w_{ij})\n$$\n由于 $\\max_{i \\in A} w_{ij} \\le \\max_{i \\in B} w_{ij}$ 且函数 $h(z)$ 是非增的，可以得出：\n$$\n\\max(0, w_{xj} - \\max_{i \\in A} w_{ij}) \\ge \\max(0, w_{xj} - \\max_{i \\in B} w_{ij})\n$$\n这就证明了 $\\Delta_{g_j}(x | A) \\ge \\Delta_{g_j}(x | B)$。因为这对每个 $j \\in V$ 都成立，将所有 $j$ 的边际增益求和可得：\n$$\n\\sum_{j \\in V} \\Delta_{g_j}(x | A) \\ge \\sum_{j \\in V} \\Delta_{g_j}(x | B)\n$$\n认识到 $\\Delta_f(x | S) = \\sum_{j \\in V} \\Delta_{g_j}(x | S)$，我们有 $\\Delta_f(x | A) \\ge \\Delta_f(x | B)$，这正是子模性条件。这就完成了 $f(S)$ 对于任意非负相似度矩阵 $W$ 都是一个单调子模函数的证明。\n\n### **任务 2：算法与实证分析**\n\n实证任务要求将贪心最大化设施选址函数得到的解与k-中位问题的最优解进行比较。\n\n**算法设计**\n\n1.  **贪心设施选址 (FL) 算法**：为了找到在基数约束 $|S|=k$ 下最大化 $f(S)$ 的一个好解 $S_{\\mathrm{FL}}$，我们使用标准的贪心算法。已知该算法为最大化单调子模函数问题提供一个 $(1 - 1/e)$ 近似解。\n    -   初始化解集 $S$ 为空集。\n    -   重复 $k$ 次：\n        -   对于每个尚未在 $S$ 中的元素 $x$，计算边际增益 $\\Delta_f(x|S) = f(S \\cup \\{x\\}) - f(S)$。\n        -   选择提供最大边际增益的元素 $x^*$。\n        -   将 $x^*$ 添加到 $S$ 中。\n    -   最终的集合 $S$ 就是我们的解 $S_{\\mathrm{FL}}$。\n\n2.  **最优 k-中位算法**：为了找到最小化 k-中位代价 $C(S) = \\sum_{j \\in V} \\min_{i \\in S} d(i,j)$ 的真正最优中心集 $S_{\\mathrm{OPT}}$，我们执行穷举搜索。\n    -   生成 $V$ 的所有大小为 $k$ 的可能子集。这样的子集数量为 $\\binom{n}{k}$。\n    -   对于每个子集，计算其 k-中位代价 $C(S)$。\n    -   代价最小的子集即为最优解 $S_{\\mathrm{OPT}}$，其代价为 $C(S_{\\mathrm{OPT}})$。\n\n**实现计划**\n\n实现遵循问题规范。合成数据集使用硬编码坐标构建，以确保可复现性。对于每个测试用例：\n1.  定义 $\\mathbb{R}^2$ 中的一组 $n$ 个点。\n2.  计算成对欧几里得距离矩阵 $D$，其中 $d_{ij} = d(i,j)$。\n3.  使用变换 $w_{ij} = \\max(0, r - d_{ij})$ 计算相似度矩阵 $W$。\n4.  运行贪心算法进行设施选址，得到集合 $S_{\\mathrm{FL}}$。\n5.  使用距离矩阵 $D$ 计算该集合的 k-中位代价 $C(S_{\\mathrm{FL}})$。\n6.  执行穷举搜索以找到最优 k-中位代价 $C(S_{\\mathrm{OPT}})$。\n7.  计算并存储比率 $R = C(S_{\\mathrm{FL}}) / C(S_{\\mathrm{OPT}})$。该比率量化了设施选址代理目标在寻找 k-中位问题好解方面的表现。接近 1.0 的比率表示高质量。\n\n最终程序为三个指定的测试用例实现了此逻辑，并输出结果比率。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.spatial.distance import cdist\nfrom itertools import combinations\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the results.\n    \"\"\"\n    # Define the test cases with fixed coordinates for reproducibility.\n    test_cases = [\n        {\n            \"name\": \"Case A (happy path)\",\n            \"n\": 12, \"k\": 2, \"r\": 3.0,\n            \"points\": np.array([\n                # Cluster 1 (near (0,0))\n                [0.1, 0.2], [-0.3, 0.1], [0.0, -0.4], [0.5, 0.3], [-0.2, -0.2], [0.4, -0.1],\n                # Cluster 2 (near (5,5))\n                [5.1, 5.2], [4.8, 5.3], [5.0, 4.7], [5.5, 5.1], [4.9, 4.8], [5.2, 5.5]\n            ])\n        },\n        {\n            \"name\": \"Case B (boundary case)\",\n            \"n\": 12, \"k\": 1, \"r\": 1.5,\n            \"points\": np.array([\n                # Single compact cluster near (0,0)\n                [0.1, 0.2], [-0.3, 0.1], [0.0, -0.4], [0.5, 0.3], [-0.2, -0.2], [0.4, -0.1],\n                [-0.5, 0.5], [0.6, -0.6], [0.2, 0.7], [-0.1, -0.5], [0.8, 0.0], [-0.6, 0.0]\n            ])\n        },\n        {\n            \"name\": \"Case C (edge case)\",\n            \"n\": 9, \"k\": 3, \"r\": 2.0,\n            \"points\": np.array([\n                # Cluster 1 (near (0,0))\n                [0.1, 0.1], [-0.2, 0.0], [0.0, -0.3],\n                # Cluster 2 (near (4,0))\n                [4.1, 0.2], [3.8, -0.1], [4.0, 0.0],\n                # Cluster 3 (near (0,4))\n                [0.1, 4.1], [-0.1, 3.9], [0.2, 4.3]\n            ])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        ratio = run_case(case)\n        results.append(ratio)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calculate_k_median_cost(S, D):\n    \"\"\"Calculates the k-median cost C(S) for a given set S and distance matrix D.\"\"\"\n    if not S:\n        return np.inf\n    # For each point j, find the minimum distance to a center in S.\n    min_distances = np.min(D[S, :], axis=0)\n    return np.sum(min_distances)\n\ndef run_case(case_params):\n    \"\"\"\n    Runs a single test case: computes S_FL via greedy algorithm, S_OPT via\n    exhaustive search, and returns the ratio of their k-median costs.\n    \"\"\"\n    points = case_params[\"points\"]\n    n = case_params[\"n\"]\n    k = case_params[\"k\"]\n    r = case_params[\"r\"]\n\n    # Compute pairwise Euclidean distance matrix D\n    D = cdist(points, points, 'euclidean')\n\n    # Compute similarity matrix W\n    W = np.maximum(0, r - D)\n\n    # --- Greedy Algorithm for Facility Location ---\n    S_fl = []\n    candidates = list(range(n))\n    # Keep track of the maximum similarity from S_fl to each point j\n    current_max_sim = np.zeros(n)\n\n    for _ in range(k):\n        best_gain = -1.0\n        best_candidate = -1\n        \n        for x in candidates:\n            # Efficiently calculate marginal gain: sum(max(0, w_xj - max_sim_j))\n            gains_vector = np.maximum(0, W[x, :] - current_max_sim)\n            gain = np.sum(gains_vector)\n\n            if gain > best_gain:\n                best_gain = gain\n                best_candidate = x\n\n        if best_candidate != -1:\n            S_fl.append(best_candidate)\n            candidates.remove(best_candidate)\n            # Update the vector of maximum similarities\n            current_max_sim = np.maximum(current_max_sim, W[best_candidate, :])\n\n    # Calculate the k-median cost of the greedy facility location solution\n    C_fl = calculate_k_median_cost(S_fl, D)\n\n    # --- Exhaustive Search for Optimal k-Median ---\n    min_C_opt = np.inf\n    S_opt = None\n\n    for s_candidate_tuple in combinations(range(n), k):\n        s_candidate = list(s_candidate_tuple)\n        c_val = calculate_k_median_cost(s_candidate, D)\n        if c_val  min_C_opt:\n            min_C_opt = c_val\n            S_opt = s_candidate\n    \n    C_opt = min_C_opt\n    \n    # --- Compute the approximation ratio ---\n    if C_opt == 0:\n        # This case should not happen with the given test data,\n        # but as a safeguard, if the optimal cost is 0, the greedy\n        # solution should also be optimal.\n        return 1.0 if C_fl == 0 else np.inf\n        \n    ratio = C_fl / C_opt\n    return ratio\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "子模优化不仅限于单调函数（即增加元素总是有益的）。最后的这个练习将带你进入更复杂的领域：在拟阵约束下的非单调子模最大化问题。通过实现贪心算法和局部搜索启发式两种方法，你将通过动手实验发现它们的性能会如何戏剧性地变化，并学会构建特定的实例来凸显每种方法的优缺点。",
            "id": "3189759",
            "problem": "给定一系列有限组合优化实例，这些实例结合了非单调子模目标和拟阵约束。您的任务是实现并比较一个贪心算法和一个局部搜索算法，并构建特定实例，使其中一个算法优于另一个。所有数学符号、变量、常数和数字都必须按照标准代数意义进行解释。\n\n基本概念：\n- 如果一个集合函数 $f: 2^{V} \\to \\mathbb{R}$ 对于所有 $A \\subseteq B \\subseteq V$ 和所有 $e \\in V \\setminus B$ 都满足收益递减性质 $f(A \\cup \\{e\\}) - f(A) \\ge f(B \\cup \\{e\\}) - f(B)$，则称其为子模函数。\n- 拟阵是一个对 $(V, \\mathcal{I})$，其中 $V$ 是一个有限基集，$\\mathcal{I} \\subseteq 2^{V}$ 是一个非空的独立集集合，满足遗传性和交换性质。划分拟阵是通过将 $V$ 划分为不相交的部分，并对每个部分可选择的元素数量设置上限而产生的。\n\n问题设置：\n- 基集：$V = \\{0,1,2,3\\}$。\n- 划分拟阵：元素通过映射 $g: V \\to \\{0,1\\}$ 分配到不同部分，容量为 $b(0) = 1$ 和 $b(1) = 1$。因此，一个可行集 $S$ 必须对每个部分 $p \\in \\{0,1\\}$ 满足 $\\lvert \\{i \\in S: g(i) = p\\} \\rvert \\le b(p)$。\n- 非单调子模目标：对于一个子集 $S \\subseteq V$，定义\n$$\nf(S) = \\sum_{i \\in S} w_i \\;-\\; \\sum_{\\{i,j\\} \\subseteq S} c_{ij},\n$$\n其中 $w_i \\in \\mathbb{R}$ 是物品权重，$c_{ij} \\in \\mathbb{R}_{\\ge 0}$ 是对称的成对惩罚项，满足 $c_{ij} = c_{ji}$ 和 $c_{ii} = 0$。请注意，第二个和是针对 $i \\ne j$ 的无序对 $\\{i,j\\}$。因为所有 $c_{ij} \\ge 0$，函数 $f$ 是子模的，并且通常是非单调的。\n\n待实现的算法：\n- 贪心算法（最大正边际收益）：初始化 $S \\gets \\emptyset$。重复选择一个元素 $e \\in V \\setminus S$，该元素添加后是可行的（即 $S \\cup \\{e\\} \\in \\mathcal{I}$）并且能最大化边际增益 $\\Delta(e \\mid S) = f(S \\cup \\{e\\}) - f(S)$。通过选择最小索引来打破平局。如果最大边际增益严格为正，则将该元素添加到 $S$ 并继续；否则，停止并返回 $S$。\n- 局部搜索（使用添加/删除/交换的首次改进策略）：初始化 $S \\gets \\emptyset$。重复以下循环，直到找不到改进为止：\n  1. 添加移动：按索引递增顺序扫描 $e \\in V \\setminus S$。如果 $S \\cup \\{e\\} \\in \\mathcal{I}$ 且 $\\Delta(e \\mid S)  0$，则设置 $S \\gets S \\cup \\{e\\}$ 并重启循环。\n  2. 删除移动：按索引递增顺序扫描 $e \\in S$。如果 $f(S \\setminus \\{e\\}) - f(S)  0$，则设置 $S \\gets S \\setminus \\{e\\}$ 并重启循环。\n  3. 交换移动：按索引的字典序扫描对 $(o,i)$，其中 $o \\in S$ 且 $i \\in V \\setminus S$。如果 $(S \\setminus \\{o\\}) \\cup \\{i\\} \\in \\mathcal{I}$ 且 $f((S \\setminus \\{o\\}) \\cup \\{i\\}) - f(S)  0$，则执行交换 $S \\gets (S \\setminus \\{o\\}) \\cup \\{i\\}$ 并重启循环。\n当循环终止时返回 $S$。\n\n测试套件：\n实现这两种算法，并在以下三个实例上评估它们。在所有情况下，都使用上面指定的索引顺序 $0,1,2,3$ 来打破平局和进行扫描。\n\n- 测试用例 1（局部搜索优于贪心算法）：\n  - 分组分配：$g(0) = 0$, $g(1) = 0$, $g(2) = 1$, $g(3) = 1$，容量为 $b(0) = 1$, $b(1) = 1$。\n  - 权重：$(w_0, w_1, w_2, w_3) = (6, 10, 5, 7)$。\n  - 非零惩罚项：$c_{1,2} = 6$, $c_{1,3} = 8$, $c_{0,2} = 2$, $c_{0,3} = 1$。所有其他 $i \\ne j$ 的 $c_{ij} = 0$。\n  - 预期的定性行为：贪心算法因任何添加的边际收益均为非正而停止，只得到一个元素的解；而局部搜索可以通过交换达到一个严格更优的双元素解。\n\n- 测试用例 2（由于首次改进策略陷入困境，贪心算法优于局部搜索）：\n  - 分组分配：$g(0) = 0$, $g(1) = 0$, $g(2) = 1$, $g(3) = 1$，容量为 $b(0) = 1$, $b(1) = 1$。\n  - 权重：$(w_0, w_1, w_2, w_3) = (7, 9, 7, 9)$。\n  - 非零惩罚项：$c_{1,3} = 4$, $c_{0,2} = 4$, $c_{1,2} = 8$, $c_{0,3} = 8$。所有其他 $i \\ne j$ 的 $c_{ij} = 0$。\n  - 预期的定性行为：贪心算法构建了一个高价值的兼容对，而采用首次改进策略的局部搜索锁定在一个低价值的兼容对上，并且无法执行非改进的中间交换，因此陷入困境。\n\n- 测试用例 3（单元素值为非正的边界情况）：\n  - 分组分配：$g(0) = 0$, $g(1) = 0$, $g(2) = 1$, $g(3) = 1$，容量为 $b(0) = 1$, $b(1) = 1$。\n  - 权重：$(w_0, w_1, w_2, w_3) = (-1, -2, -3, -1)$。\n  - 所有 $i \\ne j$ 的惩罚项 $c_{ij} = 0$。\n  - 预期的定性行为：两种算法都返回值为 $0$ 的空集。\n\n所需的计算和输出：\n- 对于每个测试用例 $t \\in \\{1,2,3\\}$，计算 $S_{\\mathrm{greedy}}^{(t)}$ 和 $S_{\\mathrm{LS}}^{(t)}$，然后计算值 $f(S_{\\mathrm{greedy}}^{(t)})$ 和 $f(S_{\\mathrm{LS}}^{(t)})$，最后计算整数差\n$$\nd^{(t)} = f(S_{\\mathrm{LS}}^{(t)}) - f(S_{\\mathrm{greedy}}^{(t)}).\n$$\n- 您的程序应产生单行输出，其中包含三个结果，形式为用方括号括起来的逗号分隔列表（例如，$\\;[d^{(1)},d^{(2)},d^{(3)}]\\;$）。输出必须是整数，不含额外的空格或文本。\n\n不涉及物理单位或角度。所有输出均为纯整数。确保所有算法步骤完全遵守指定的拟阵独立性约束，并使用严格为正的改进移动来推进两种算法。",
            "solution": "该问题要求在一个划分拟阵约束下，对一个非单调子模最大化问题，实现并比较一个贪心算法和一个局部搜索算法。我们必须在三个特定实例上评估这些算法，并计算它们所达成的目标值的差异。\n\n基集是 $V = \\{0, 1, 2, 3\\}$。对于给定的集合 $S \\subseteq V$，目标函数为 $f(S) = \\sum_{i \\in S} w_i - \\sum_{\\{i,j\\} \\subseteq S, i \\ne j} c_{ij}$，其中 $w_i$ 是权重，$c_{ij} \\ge 0$ 是对称的惩罚项。函数 $f$ 是子模的。\n\n约束是一个划分拟阵 $(V, \\mathcal{I})$，由将 $V$ 划分为两个部分 $P_0$ 和 $P_1$ 定义，其容量分别为 $b(0)=1$ 和 $b(1)=1$。一个集合 $S$ 是独立的，即 $S \\in \\mathcal{I}$，如果它从每个部分中最多包含一个元素。对于所有测试用例，划分为 $P_0 = \\{i \\in V \\mid g(i)=0\\} = \\{0, 1\\}$ 和 $P_1 = \\{i \\in V \\mid g(i)=1\\} = \\{2, 3\\}$。\n\n我们现在通过追踪两种算法的执行过程来分析每个测试用例。\n\n### 测试用例 1\n\n**实例参数：**\n- 权重：$(w_0, w_1, w_2, w_3) = (6, 10, 5, 7)$。\n- 非零惩罚项：$c_{1,2} = 6$, $c_{1,3} = 8$, $c_{0,2} = 2$, $c_{0,3} = 1$。\n\n**贪心算法追踪：**\n1.  初始化 $S = \\emptyset$，因此 $f(S) = 0$。\n2.  **第 1 次迭代：** 我们为每个 $e \\in V$ 评估边际增益 $\\Delta(e \\mid \\emptyset) = f(\\{e\\}) - f(\\emptyset) = w_e$：\n    - $\\Delta(0 \\mid \\emptyset) = w_0 = 6$。\n    - $\\Delta(1 \\mid \\emptyset) = w_1 = 10$。\n    - $\\Delta(2 \\mid \\emptyset) = w_2 = 5$。\n    - $\\Delta(3 \\mid \\emptyset) = w_3 = 7$。\n    最大增益为 $10$，对应元素 $e=1$。由于 $10  0$，我们更新 $S \\gets \\{1\\}$。当前值为 $f(\\{1\\}) = 10$。\n3.  **第 2 次迭代：** 当前解为 $S = \\{1\\}$。我们评估可行添加的边际增益。由于 $g(1)=0$，我们只能从部分 $P_1 = \\{2, 3\\}$ 中添加元素。\n    - $\\Delta(2 \\mid \\{1\\}) = f(\\{1,2\\}) - f(\\{1\\}) = (w_1+w_2-c_{1,2}) - w_1 = w_2 - c_{1,2} = 5 - 6 = -1$。\n    - $\\Delta(3 \\mid \\{1\\}) = f(\\{1,3\\}) - f(\\{1\\}) = (w_1+w_3-c_{1,3}) - w_1 = w_3 - c_{1,3} = 7 - 8 = -1$。\n    最大边际增益为 $-1$，不严格为正。算法终止。\n\n最终的贪心解是 $S_{\\mathrm{greedy}}^{(1)} = \\{1\\}$，其值为 $f(S_{\\mathrm{greedy}}^{(1)}) = 10$。\n\n**局部搜索算法追踪：**\n1.  初始化 $S = \\emptyset$。开始循环。\n2.  **第 1 次迭代：** $S = \\emptyset$, $f(S)=0$。\n    - **添加移动：** 扫描 $e \\in \\{0,1,2,3\\}$。对于 $e=0$，$f(\\{0\\}) = 6  f(\\emptyset)$。这是一个有效的首次改进。\n    - 更新 $S \\gets \\{0\\}$。重启循环。\n3.  **第 2 次迭代：** $S = \\{0\\}$, $f(S)=6$。\n    - **添加移动：** 扫描 $e \\in \\{1,2,3\\}$。$e=1$ 不可行（$g(0)=g(1)=0$）。对于 $e=2$，$S \\cup \\{2\\} = \\{0,2\\}$ 可行。$f(\\{0,2\\}) = w_0+w_2-c_{0,2} = 6+5-2=9$。增益为 $9-6=30$。这是一个有效的首次改进。\n    - 更新 $S \\gets \\{0,2\\}$。重启循环。\n4.  **第 3 次迭代：** $S = \\{0,2\\}$, $f(S)=9$。\n    - **添加移动：** 无法添加任何元素。\n    - **删除移动：** 删除 $0$ 得到 $f(\\{2\\})=5 \\ngtr 9$。删除 $2$ 得到 $f(\\{0\\})=6 \\ngtr 9$。没有改进。\n    - **交换移动：** 按字典序扫描对 $(o, i)$，其中 $o \\in \\{0,2\\}$ 且 $i \\in \\{1,3\\}$。\n        - $(0,1)$：交换到 $\\{1,2\\}$。可行（$g(1)=0, g(2)=1$）。$f(\\{1,2\\}) = w_1+w_2-c_{1,2} = 10+5-6=9$。变化量为 $9-9=0$。没有改进。\n        - $(0,3)$：交换到 $\\{2,3\\}$。可行（$g(2)=1, g(3)=1$）。$f(\\{2,3\\}) = w_2+w_3-c_{2,3} = 5+7-0=12$。增益为 $12-9=3  0$。这是一个有效的首次改进。\n    - 更新 $S \\gets \\{2,3\\}$。重启循环。\n5.  **第 4 次迭代：** $S = \\{2,3\\}$, $f(S)=12$。\n    - **添加/删除移动：** 未发现改进。（删除 $2$ 得到 $f(\\{3\\})=7\\ngtr12$；删除 $3$ 得到 $f(\\{2\\})=5\\ngtr12$）。\n    - **交换移动：** 扫描对 $(o,i)$，其中 $o \\in \\{2,3\\}, i \\in \\{0,1\\}$。\n        - $(2,0)$：交换到 $\\{0,3\\}$，可行。$f(\\{0,3\\}) = w_0+w_3-c_{0,3} = 6+7-1=12$。变化量为 $0$。\n        - $(2,1)$：交换到 $\\{1,3\\}$，可行。$f(\\{1,3\\}) = w_1+w_3-c_{1,3} = 10+7-8=9$。变化量为 $9-12 \\ngtr 0$。\n        - $(3,0)$：交换到 $\\{0,2\\}$，可行。$f(\\{0,2\\}) = w_0+w_2-c_{0,2} = 6+5-2=9$。变化量为 $9-12 \\ngtr 0$。\n        - $(3,1)$：交换到 $\\{1,2\\}$，可行。$f(\\{1,2\\}) = w_1+w_2-c_{1,2} = 10+5-6=9$。变化量为 $9-12 \\ngtr 0$。\n    - 未找到改进移动。算法终止。\n\n最终的局部搜索解是 $S_{\\mathrm{LS}}^{(1)} = \\{2,3\\}$，其值为 $f(S_{\\mathrm{LS}}^{(1)}) = 12$。\n差异为 $d^{(1)} = f(S_{\\mathrm{LS}}^{(1)}) - f(S_{\\mathrm{greedy}}^{(1)}) = 12 - 10 = 2$。\n\n### 测试用例 2\n\n**实例参数：**\n- 权重：$(w_0, w_1, w_2, w_3) = (7, 9, 7, 9)$。\n- 非零惩罚项：$c_{1,3} = 4$, $c_{0,2} = 4$, $c_{1,2} = 8$, $c_{0,3} = 8$。\n\n**贪心算法追踪：**\n1.  初始化 $S = \\emptyset$, $f(S) = 0$。\n2.  **第 1 次迭代：** 评估边际增益 $\\Delta(e \\mid \\emptyset) = w_e$：\n    - $\\Delta(0 \\mid \\emptyset) = 7$。\n    - $\\Delta(1 \\mid \\emptyset) = 9$。\n    - $\\Delta(2 \\mid \\emptyset) = 7$。\n    - $\\Delta(3 \\mid \\emptyset) = 9$。\n    最大增益为 $9$，由元素 $1$ 和 $3$ 实现。根据平局打破规则选择最小索引，即 $e=1$。更新 $S \\gets \\{1\\}$，$f(\\{1\\}) = 9$。\n3.  **第 2 次迭代：** 当前解 $S = \\{1\\}$。可行的添加来自 $P_1 = \\{2,3\\}$。\n    - $\\Delta(2 \\mid \\{1\\}) = w_2 - c_{1,2} = 7 - 8 = -1$。\n    - $\\Delta(3 \\mid \\{1\\}) = w_3 - c_{1,3} = 9 - 4 = 5$。\n    最大增益为 $5$，对应元素 $e=3$。由于 $50$，更新 $S \\gets \\{1,3\\}$。值为 $f(\\{1,3\\}) = w_1+w_3-c_{1,3} = 9+9-4=14$。\n4.  **第 3 次迭代：** 当前解 $S=\\{1,3\\}$。无法再添加元素。算法终止。\n\n最终的贪心解是 $S_{\\mathrm{greedy}}^{(2)} = \\{1,3\\}$，其值为 $f(S_{\\mathrm{greedy}}^{(2)}) = 14$。\n\n**局部搜索算法追踪：**\n1.  初始化 $S = \\emptyset$。开始循环。\n2.  **第 1 次迭代：** $S = \\emptyset$, $f(S)=0$。\n    - **添加移动：** 扫描 $e \\in \\{0,1,2,3\\}$。对于 $e=0$，$f(\\{0\\})=7  0$。首次改进。\n    - 更新 $S \\gets \\{0\\}$。重启循环。\n3.  **第 2 次迭代：** $S = \\{0\\}$, $f(S)=7$。\n    - **添加移动：** 扫描 $e \\in \\{1,2,3\\}$。$e=1$ 不可行。对于 $e=2$，$S \\cup \\{2\\}=\\{0,2\\}$ 可行。$f(\\{0,2\\}) = w_0+w_2-c_{0,2} = 7+7-4=10$。增益为 $10-7=30$。首次改进。\n    - 更新 $S \\gets \\{0,2\\}$。重启循环。\n4.  **第 3 次迭代：** $S = \\{0,2\\}$, $f(S)=10$。\n    - **添加/删除移动：** 未发现改进。（删除 $0$ 得到 $f(\\{2\\})=7\\ngtr10$；删除 $2$ 得到 $f(\\{0\\})=7\\ngtr10$）。\n    - **交换移动：** 按字典序扫描对。$S=\\{0,2\\}$, $V \\setminus S = \\{1,3\\}$。\n        - $(0,1)$：交换到 $\\{1,2\\}$。可行。$f(\\{1,2\\}) = w_1+w_2-c_{1,2} = 9+7-8=8$。变化量为 $8-10\\ngtr0$。\n        - $(0,3)$：交换到 $\\{2,3\\}$。不可行（$g(2)=1, g(3)=1$）。\n        - $(2,1)$：交换到 $\\{0,1\\}$。不可行（$g(0)=0, g(1)=0$）。\n        - $(2,3)$：交换到 $\\{0,3\\}$。可行。$f(\\{0,3\\}) = w_0+w_3-c_{0,3} = 7+9-8=8$。变化量为 $8-10\\ngtr0$。\n    - 未找到改进移动。算法终止。\n\n最终的局部搜索解是 $S_{\\mathrm{LS}}^{(2)} = \\{0,2\\}$，其值为 $f(S_{\\mathrm{LS}}^{(2)}) = 10$。\n差异为 $d^{(2)} = f(S_{\\mathrm{LS}}^{(2)}) - f(S_{\\mathrm{greedy}}^{(2)}) = 10 - 14 = -4$。\n\n### 测试用例 3\n\n**实例参数：**\n- 权重：$(w_0, w_1, w_2, w_3) = (-1, -2, -3, -1)$。\n- 非零惩罚项：所有 $c_{ij}=0$。\n\n**贪心算法追踪：**\n1.  初始化 $S = \\emptyset$, $f(S)=0$。\n2.  **第 1 次迭代：** 评估边际增益 $\\Delta(e \\mid \\emptyset) = w_e$：\n    - $\\Delta(0 \\mid \\emptyset) = -1$。\n    - $\\Delta(1 \\mid \\emptyset) = -2$。\n    - $\\Delta(2 \\mid \\emptyset) = -3$。\n    - $\\Delta(3 \\mid \\emptyset) = -1$。\n    最大增益为 $-1$，不严格为正。算法终止。\n\n最终的贪心解是 $S_{\\mathrm{greedy}}^{(3)} = \\emptyset$，其值为 $f(S_{\\mathrm{greedy}}^{(3)}) = 0$。\n\n**局部搜索算法追踪：**\n1.  初始化 $S = \\emptyset$。开始循环。\n2.  **第 1 次迭代：** $S = \\emptyset$, $f(S)=0$。\n    - **添加移动：** 所有单元素集合的值都为负，所以对于所有 $e$ 都有 $f(\\{e\\}) \\ngtr f(\\emptyset)$。没有改进的添加移动。\n    - **删除/交换移动：** 不适用，因为 $S$ 是空的。\n    - 未找到改进移动。算法终止。\n\n最终的局部搜索解是 $S_{\\mathrm{LS}}^{(3)} = \\emptyset$，其值为 $f(S_{\\mathrm{LS}}^{(3)}) = 0$。\n差异为 $d^{(3)} = f(S_{\\mathrm{LS}}^{(3)}) - f(S_{\\mathrm{greedy}}^{(3)}) = 0 - 0 = 0$。\n\n### 差异总结\n\n- $d^{(1)} = 2$\n- $d^{(2)} = -4$\n- $d^{(3)} = 0$",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and compares greedy and local search algorithms for a submodular\n    maximization problem under a partition matroid constraint.\n    \"\"\"\n\n    test_cases = [\n        # Test case 1 (local search > greedy)\n        {\n            \"g\": [0, 0, 1, 1],\n            \"b\": [1, 1],\n            \"w\": [6, 10, 5, 7],\n            \"c_raw\": {(1, 2): 6, (1, 3): 8, (0, 2): 2, (0, 3): 1},\n        },\n        # Test case 2 (greedy > local search)\n        {\n            \"g\": [0, 0, 1, 1],\n            \"b\": [1, 1],\n            \"w\": [7, 9, 7, 9],\n            \"c_raw\": {(1, 3): 4, (0, 2): 4, (1, 2): 8, (0, 3): 8},\n        },\n        # Test case 3 (boundary case)\n        {\n            \"g\": [0, 0, 1, 1],\n            \"b\": [1, 1],\n            \"w\": [-1, -2, -3, -1],\n            \"c_raw\": {},\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        V = set(range(4))\n        w = np.array(case[\"w\"])\n        g = case[\"g\"]\n        b = case[\"b\"]\n        C = np.zeros((4, 4))\n        for (i, j), val in case[\"c_raw\"].items():\n            C[i, j] = C[j, i] = val\n\n        def f(S, w_vec, C_mat):\n            \"\"\"Calculates the objective function f(S).\"\"\"\n            if not S:\n                return 0\n            s_list = list(S)\n            val = np.sum(w_vec[s_list])\n            penalty = 0\n            for i in range(len(s_list)):\n                for j in range(i + 1, len(s_list)):\n                    penalty += C_mat[s_list[i], s_list[j]]\n            return val - penalty\n\n        def is_independent(S, g_map, b_caps):\n            \"\"\"Checks if a set S is independent under the partition matroid.\"\"\"\n            part_counts = [0] * len(b_caps)\n            for e in S:\n                part_idx = g_map[e]\n                part_counts[part_idx] += 1\n            for part_idx, count in enumerate(part_counts):\n                if count > b_caps[part_idx]:\n                    return False\n            return True\n\n        def greedy_algorithm(V_set, w_vec, C_mat, g_map, b_caps):\n            S = set()\n            while True:\n                best_e = -1\n                max_gain = -np.inf\n                \n                # Iterate through candidates sorted by index for tie-breaking\n                candidates = sorted(list(V_set - S))\n                for e in candidates:\n                    S_prime = S | {e}\n                    if is_independent(S_prime, g_map, b_caps):\n                        gain = f(S_prime, w_vec, C_mat) - f(S, w_vec, C_mat)\n                        if gain > max_gain:\n                            max_gain = gain\n                            best_e = e\n                \n                if best_e != -1 and max_gain > 0:\n                    S.add(best_e)\n                else:\n                    break\n            return S\n\n        def local_search_algorithm(V_set, w_vec, C_mat, g_map, b_caps):\n            S = set()\n            while True:\n                current_f_S = f(S, w_vec, C_mat)\n                improved = False\n\n                # 1. Add moves\n                add_candidates = sorted(list(V_set - S))\n                for e in add_candidates:\n                    S_prime = S | {e}\n                    if is_independent(S_prime, g_map, b_caps):\n                        if f(S_prime, w_vec, C_mat) - current_f_S > 0:\n                            S = S_prime\n                            improved = True\n                            break\n                if improved:\n                    continue\n\n                # 2. Delete moves\n                delete_candidates = sorted(list(S))\n                for e in delete_candidates:\n                    S_prime = S - {e}\n                    if f(S_prime, w_vec, C_mat) - current_f_S > 0:\n                        S = S_prime\n                        improved = True\n                        break\n                if improved:\n                    continue\n\n                # 3. Swap moves\n                o_candidates = sorted(list(S))\n                i_candidates = sorted(list(V_set - S))\n                swap_pairs = []\n                for o in o_candidates:\n                    for i in i_candidates:\n                        swap_pairs.append((o, i))\n                \n                for o, i in swap_pairs:\n                    S_prime = (S - {o}) | {i}\n                    if is_independent(S_prime, g_map, b_caps):\n                        if f(S_prime, w_vec, C_mat) - current_f_S > 0:\n                            S = S_prime\n                            improved = True\n                            break\n                if improved:\n                    continue\n\n                # No improvement found in a full pass\n                break\n\n            return S\n\n        S_greedy = greedy_algorithm(V, w, C, g, b)\n        f_greedy = f(S_greedy, w, C)\n        \n        S_ls = local_search_algorithm(V, w, C, g, b)\n        f_ls = f(S_ls, w, C)\n\n        diff = f_ls - f_greedy\n        results.append(int(diff))\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}