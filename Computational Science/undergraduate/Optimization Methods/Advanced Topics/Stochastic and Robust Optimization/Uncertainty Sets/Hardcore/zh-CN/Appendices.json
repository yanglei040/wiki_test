{
    "hands_on_practices": [
        {
            "introduction": "本练习将向您介绍鲁棒优化中的一项基本技术：白化变换 (whitening transformation)。我们将通过  探索如何将一个形如 $(a - \\bar{a})^{\\top} \\Sigma^{-1} (a - \\bar{a}) \\le \\rho^{2}$ 的复杂椭球不确定性集合，转化为一个简单的球体。这一变换过程极大地简化了寻找线性约束 $a^{\\top} x \\le b$ 最坏情况的过程，是推导可处理鲁棒对等问题的关键技能。",
            "id": "3195373",
            "problem": "考虑在存在不确定系数情况下的鲁棒线性不等式。设决策向量为 $x \\in \\mathbb{R}^{n}$，名义系数向量为 $\\bar{a} \\in \\mathbb{R}^{n}$，系数中的不确定性由一个椭球集建模\n$$\n\\mathcal{E} = \\left\\{ a \\in \\mathbb{R}^{n} \\;\\middle|\\; (a - \\bar{a})^{\\top} \\Sigma^{-1} (a - \\bar{a}) \\le \\rho^{2} \\right\\},\n$$\n其中 $\\Sigma \\in \\mathbb{R}^{n \\times n}$ 是对称正定矩阵，$\\rho  0$ 是一个半径参数。鲁棒约束要求对于所有 $a \\in \\mathcal{E}$，不等式 $a^{\\top} x \\le b$ 均成立，其中 $b \\in \\mathbb{R}$ 是给定值。\n\n从椭球不确定集和线性不等式的鲁棒满足性的定义出发，并且仅使用如 Cauchy–Schwarz 不等式等熟知的不等式，推导变量代换 $z = \\Sigma^{-1/2} (a - \\bar{a})$ 如何将椭球集 $\\mathcal{E}$ 变换为白化坐标下的球形（欧几里得球）集。解释该变换如何能够计算 $a^{\\top} x$ 在 $\\mathcal{E}$ 上的最坏情况下的值，从而简化该不等式的鲁棒对应形式。从第一性原理开始，逐步展示推理过程。\n\n然后，实现一个程序，对下述每个测试用例，使用上述白化变换计算 $a^{\\top} x$ 在椭球集 $\\mathcal{E}$ 上的最坏情况下的左侧值，并返回该值。您的实现必须：\n- 使用适用于对称正定矩阵的特征值分解，计算对称矩阵平方根 $\\Sigma^{1/2}$ 及其逆 $\\Sigma^{-1/2}$。\n- 使用白化变量 $z = \\Sigma^{-1/2} (a - \\bar{a})$ 来证明并实现 $a^{\\top} x$ 最坏情况下值的计算。\n- 妥善处理 $x = 0$ 的边界情况。\n- 为了内部验证，还需使用白化空间中的刻画方法，重构至少一个达到所计算上确界的最坏情况下的最大化向量 $a^{\\star} \\in \\mathcal{E}$。此重构是实现的一部分，但无需打印。\n\n对于所有测试用例，将最终输出表示为实数（浮点数），四舍五入到六位小数。您的程序应生成一行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。\n\n使用以下测试套件，它涵盖了一般情况、边界条件、病态协方差和较大半径的情况：\n\n- 测试用例 1 (一般对称正定协方差):\n  - 维度: $n = 3$\n  - $\\bar{a} = [0.8,\\,-1.2,\\,0.5]$\n  - $\\Sigma = \\begin{bmatrix} 3.0  0.5  0.0 \\\\ 0.5  2.0  0.4 \\\\ 0.0  0.4  1.5 \\end{bmatrix}$\n  - $\\rho = 1.0$\n  - $x = [0.5,\\,1.0,\\,-0.5]$\n  - $b = 1.0$\n\n- 测试用例 2 (边界情况 $x = 0$):\n  - 维度: $n = 3$\n  - $\\bar{a} = [2.0,\\,-1.0,\\,0.0]$\n  - $\\Sigma = \\operatorname{diag}(1.0,\\,2.0,\\,3.0)$\n  - $\\rho = 0.75$\n  - $x = [0.0,\\,0.0,\\,0.0]$\n  - $b = 0.0$\n\n- 测试用例 3 (病态协方差，小特征值与 $x$ 对齐):\n  - 维度: $n = 3$\n  - $\\bar{a} = [0.0,\\,0.0,\\,0.0]$\n  - $\\Sigma = \\operatorname{diag}(10^{-6},\\,1.0,\\,2.0)$\n  - $\\rho = 1.0$\n  - $x = [1.0,\\,0.0,\\,0.0]$\n  - $b = 0.001$\n\n- 测试用例 4 (较大半径，非对角协方差):\n  - 维度: $n = 3$\n  - $\\bar{a} = [1.0,\\,0.5,\\,-0.5]$\n  - $\\Sigma = \\begin{bmatrix} 2.5  0.8  0.3 \\\\ 0.8  1.8  0.6 \\\\ 0.3  0.6  1.2 \\end{bmatrix}$\n  - $\\rho = 2.5$\n  - $x = [-0.2,\\,0.7,\\,0.1]$\n  - $b = 0.0$\n\n您的程序应为每个测试用例生成一行输出，其中包含鲁棒最坏情况下的值 $w$，格式需严格如下：\n- 一个形式为 $[w_1,w_2,w_3,w_4]$ 的字符串，其中每个 $w_i$ 都四舍五入到六位小数。",
            "solution": "该问题要求推导线性不等式 $a^{\\top} x \\le b$ 的鲁棒对应形式，其中系数向量 $a$ 是不确定的，并且属于一个椭球集 $\\mathcal{E}$。随后，我们必须为几个具体实例计算表达式 $a^\\top x$ 的最坏情况下的值。\n\n不等式 $a^{\\top} x \\le b$ 的鲁棒对应形式要求该条件对 $a \\in \\mathcal{E}$ 的所有可能实现都成立。这等价于确保 $a^{\\top} x$ 在集合 $\\mathcal{E}$ 上的最大可能值小于或等于 $b$。因此，问题归结为求解以下最大化问题：\n$$\n\\max_{a \\in \\mathcal{E}} a^{\\top} x\n$$\n这个最大值就是不等式在最坏情况下的左侧值。我们用 $w$ 表示这个值。\n\n不确定集定义为：\n$$\n\\mathcal{E} = \\left\\{ a \\in \\mathbb{R}^{n} \\;\\middle|\\; (a - \\bar{a})^{\\top} \\Sigma^{-1} (a - \\bar{a}) \\le \\rho^{2} \\right\\}\n$$\n其中 $\\bar{a}$ 是名义系数向量，$\\Sigma$ 是对称正定 (SPD) 矩阵，$\\rho  0$ 是一个标量半径。\n\n为分析该最大化问题，我们首先将不确定向量 $a$ 表示为其名义值 $\\bar{a}$ 与一个偏差向量 $\\delta = a - \\bar{a}$ 的和。将 $a = \\bar{a} + \\delta$ 代入目标函数 $a^{\\top} x$ 得到：\n$$\na^{\\top} x = (\\bar{a} + \\delta)^{\\top} x = \\bar{a}^{\\top} x + \\delta^{\\top} x\n$$\n定义集合 $\\mathcal{E}$ 的约束可以用 $\\delta$ 重写为：\n$$\n\\delta^{\\top} \\Sigma^{-1} \\delta \\le \\rho^{2}\n$$\n$w$ 的最大化问题现在可以表示为：\n$$\nw = \\max_{\\delta: \\delta^{\\top} \\Sigma^{-1} \\delta \\le \\rho^{2}} (\\bar{a}^{\\top} x + \\delta^{\\top} x)\n$$\n由于 $\\bar{a}^{\\top} x$ 是相对于优化变量 $\\delta$ 的常数项，我们可以将其从最大化中分离出来：\n$$\nw = \\bar{a}^{\\top} x + \\max_{\\delta: \\delta^{\\top} \\Sigma^{-1} \\delta \\le \\rho^{2}} \\delta^{\\top} x\n$$\n我们现在的任务是求解子问题 $\\max_{\\delta} \\delta^{\\top} x$。\n\n问题提示进行变量代换，这是一种称为白化 (whitening) 的标准技术。我们定义白化变量 $z$ 如下：\n$$\nz = \\Sigma^{-1/2} \\delta\n$$\n这里，$\\Sigma^{-1/2}$ 是 $\\Sigma$ 的对称平方根的逆。由于 $\\Sigma$ 是对称正定的，其特征值分解为 $\\Sigma = U D U^{\\top}$，其中 $U$ 是由特征向量构成的正交矩阵，$D$ 是由严格为正的特征值构成的对角矩阵。那么对称平方根为 $\\Sigma^{1/2} = U D^{1/2} U^{\\top}$，其中 $D^{1/2}$ 是由特征值平方根构成的对角矩阵。$\\Sigma^{1/2}$ 也是对称正定的。其逆为 $\\Sigma^{-1/2} = U D^{-1/2} U^{\\top}$。\n\n我们现在将关于 $\\delta$ 的约束变换为关于 $z$ 的约束。\n$$\n\\delta^{\\top} \\Sigma^{-1} \\delta = \\delta^{\\top} (\\Sigma^{-1/2}\\Sigma^{-1/2}) \\delta = (\\Sigma^{-1/2} \\delta)^{\\top} (\\Sigma^{-1/2} \\delta) = z^{\\top} z = \\|z\\|_{2}^{2}\n$$\n因此，约束 $\\delta^{\\top} \\Sigma^{-1} \\delta \\le \\rho^{2}$ 等价于 $z^{\\top} z \\le \\rho^{2}$。该不等式定义了 $z$ 空间中一个以原点为中心、半径为 $\\rho$ 的欧几里得球（一个实心球体）。$a$ 空间中的椭球不确定集被变换为 $z$ 空间中的简单球形集。\n\n接下来，我们将子问题的目标函数 $\\delta^{\\top} x$ 变换到新坐标系下。从 $z = \\Sigma^{-1/2} \\delta$ 可得 $\\delta = \\Sigma^{1/2} z$。将其代入目标函数得到：\n$$\n\\delta^{\\top} x = (\\Sigma^{1/2} z)^{\\top} x = z^{\\top} (\\Sigma^{1/2})^{\\top} x\n$$\n由于 $\\Sigma^{1/2}$ 是对称的，$(\\Sigma^{1/2})^{\\top} = \\Sigma^{1/2}$，因此我们有：\n$$\n\\delta^{\\top} x = z^{\\top} (\\Sigma^{1/2} x)\n$$\n子问题变为：\n$$\n\\max_{z: \\|z\\|_{2} \\le \\rho} z^{\\top} (\\Sigma^{1/2} x)\n$$\n这是最大化向量 $z$（位于半径为 $\\rho$ 的球内）与固定向量 $v = \\Sigma^{1/2} x$ 的点积的问题。根据 Cauchy-Schwarz 不等式，$u^{\\top} v \\le \\|u\\|_{2} \\|v\\|_{2}$。在此处令 $u=z$ 并应用该不等式：\n$$\nz^{\\top} (\\Sigma^{1/2} x) \\le \\|z\\|_{2} \\|\\Sigma^{1/2} x\\|_{2}\n$$\n$\\|z\\|_{2}$ 的最大值为 $\\rho$。因此，该表达式的最大值为 $\\rho \\|\\Sigma^{1/2} x\\|_{2}$。当 $z$ 与 $\\Sigma^{1/2} x$ 共线且同向，并且长度为最大可能值 $\\rho$ 时，达到此最大值。最优的 $z$ 是：\n$$\nz^{\\star} = \\rho \\frac{\\Sigma^{1/2} x}{\\|\\Sigma^{1/2} x\\|_{2}} \\quad (\\text{if } \\Sigma^{1/2} x \\neq 0)\n$$\n如果 $x=0$，那么 $\\Sigma^{1/2}x = 0$，目标函数 $z^\\top 0$ 恒为 $0$。因此最大值为 $0$。\n\n综合结果，最坏情况下的值 $w$ 为：\n$$\nw = \\bar{a}^{\\top} x + \\rho \\|\\Sigma^{1/2} x\\|_{2}\n$$\n此公式即使对于 $x=0$ 也成立，因为此时 $\\|\\Sigma^{1/2} x\\|_{2} = 0$，得到 $w = 0$。\n\n为了计算方便，项 $\\|\\Sigma^{1/2} x\\|_{2}$ 可以更直接地计算，而无需显式地构造 $\\Sigma^{1/2}$。我们注意到：\n$$\n\\|\\Sigma^{1/2} x\\|_{2}^{2} = (\\Sigma^{1/2} x)^{\\top}(\\Sigma^{1/2} x) = x^{\\top}(\\Sigma^{1/2})^{\\top}\\Sigma^{1/2} x = x^{\\top}\\Sigma^{1/2}\\Sigma^{1/2} x = x^{\\top}\\Sigma x\n$$\n因此，$\\|\\Sigma^{1/2} x\\|_{2} = \\sqrt{x^{\\top}\\Sigma x}$。这给出了最坏情况下值的最终、便于计算的公式：\n$$\nw = \\bar{a}^{\\top} x + \\rho \\sqrt{x^{\\top}\\Sigma x}\n$$\n原始不等式 $a^{\\top} x \\le b$ 的鲁棒对应形式是确定性的二阶锥约束：\n$$\n\\bar{a}^{\\top} x + \\rho \\sqrt{x^{\\top}\\Sigma x} \\le b\n$$\n程序实现将使用此最终表达式计算 $w$。根据要求，为了进行内部验证，可以通过将 $z^{\\star}$ 变换回原始空间来重构最坏情况下的系数向量 $a^{\\star}$。如果 $x \\ne 0$：\n$$\n\\delta^{\\star} = \\Sigma^{1/2} z^{\\star} = \\Sigma^{1/2} \\left( \\rho \\frac{\\Sigma^{1/2} x}{\\|\\Sigma^{1/2} x\\|_{2}} \\right) = \\rho \\frac{\\Sigma x}{\\sqrt{x^{\\top}\\Sigma x}}\n$$\n$$\na^{\\star} = \\bar{a} + \\delta^{\\star} = \\bar{a} + \\rho \\frac{\\Sigma x}{\\sqrt{x^{\\top}\\Sigma x}}\n$$\n这表明，当偏差 $\\delta$ 与 $\\Sigma x$ 对齐并被缩放到椭球体的边界上时，出现最坏情况的不确定性。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the worst-case value of a^T*x for a robust linear inequality\n    with ellipsoidal uncertainty.\n    \"\"\"\n    test_cases = [\n        # Test Case 1 (general symmetric positive definite covariance)\n        {\n            \"a_bar\": np.array([0.8, -1.2, 0.5]),\n            \"Sigma\": np.array([[3.0, 0.5, 0.0], [0.5, 2.0, 0.4], [0.0, 0.4, 1.5]]),\n            \"rho\": 1.0,\n            \"x\": np.array([0.5, 1.0, -0.5]),\n        },\n        # Test Case 2 (boundary case x = 0)\n        {\n            \"a_bar\": np.array([2.0, -1.0, 0.0]),\n            \"Sigma\": np.diag([1.0, 2.0, 3.0]),\n            \"rho\": 0.75,\n            \"x\": np.array([0.0, 0.0, 0.0]),\n        },\n        # Test Case 3 (ill-conditioned covariance)\n        {\n            \"a_bar\": np.array([0.0, 0.0, 0.0]),\n            \"Sigma\": np.diag([1e-6, 1.0, 2.0]),\n            \"rho\": 1.0,\n            \"x\": np.array([1.0, 0.0, 0.0]),\n        },\n        # Test Case 4 (larger radius, off-diagonal covariance)\n        {\n            \"a_bar\": np.array([1.0, 0.5, -0.5]),\n            \"Sigma\": np.array([[2.5, 0.8, 0.3], [0.8, 1.8, 0.6], [0.3, 0.6, 1.2]]),\n            \"rho\": 2.5,\n            \"x\": np.array([-0.2, 0.7, 0.1]),\n        }\n    ]\n\n    results = []\n\n    for i, case in enumerate(test_cases):\n        a_bar = case[\"a_bar\"]\n        Sigma = case[\"Sigma\"]\n        rho = case[\"rho\"]\n        x = case[\"x\"]\n\n        # The worst-case value of a^T*x is given by:\n        # w = a_bar^T * x + rho * sqrt(x^T * Sigma * x)\n        \n        # Calculate the nominal part\n        nominal_value = a_bar.T @ x\n\n        # Calculate the uncertainty part. Handle the x=0 case.\n        # If x is the zero vector, then x^T*Sigma*x is 0.\n        if np.all(x == 0):\n            uncertainty_term_value = 0.0\n        else:\n            # The derivation uses a whitening transformation and results in rho * ||Sigma^(1/2) * x||_2.\n            # This is equivalent to rho * sqrt(x^T * Sigma * x), which is more direct to compute.\n            # We follow the derived formula for implementation.\n            quadratic_form_val = x.T @ Sigma @ x\n            uncertainty_term_value = rho * np.sqrt(quadratic_form_val)\n\n        # Total worst-case value\n        worst_case_value = nominal_value + uncertainty_term_value\n        results.append(worst_case_value)\n\n        # ------ Internal Verification (as requested, not for output) ------\n        # Reconstruct the worst-case maximizer a_star to verify the solution.\n        # a_star = a_bar + rho * (Sigma * x) / sqrt(x^T * Sigma * x)\n        \n        # Handle the x=0 case where a_star is not unique.\n        if np.all(x == 0):\n            # Any a in the ellipsoid gives a^T*x = 0. Choose a_star = a_bar.\n            a_star = a_bar\n        else:\n            sqrt_x_Sigma_x = np.sqrt(x.T @ Sigma @ x)\n            # Avoid division by zero, though if x!=0 and Sigma is SPD, this should be > 0.\n            if sqrt_x_Sigma_x > 1e-12:\n                delta_star = rho * (Sigma @ x) / sqrt_x_Sigma_x\n                a_star = a_bar + delta_star\n            else:\n                # This case should not be reached with valid inputs\n                a_star = a_bar\n\n        # Check that a_star achieves the worst-case value\n        achieved_value = a_star.T @ x\n        assert np.isclose(achieved_value, worst_case_value), f\"Case {i+1}: Verification failed for value\"\n\n        # Check that a_star is on the boundary of the ellipsoid\n        if not np.all(x == 0):\n            dev = a_star - a_bar\n            Sigma_inv = np.linalg.inv(Sigma)\n            ellipsoid_val_sq = dev.T @ Sigma_inv @ dev\n            assert np.isclose(ellipsoid_val_sq, rho**2), f\"Case {i+1}: Verification failed for boundary\"\n        # ---------------- End Internal Verification -----------------\n\n    # Format the output string as a comma-separated list of floats rounded to 6 decimal places,\n    # enclosed in square brackets.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "在掌握了分析基本不确定性的方法后，本练习  将挑战一种更复杂的情况：乘性矩阵扰动。您将分析形如 $a^{\\top}(I+E)x \\le b$ 的约束，其中不确定性来自矩阵 $E$。通过运用弗罗贝尼乌斯范数 ($\\|\\cdot\\|_{F}$) 和矩阵空间中的柯西-施瓦茨不等式，您将为该约束推导出紧界，加深对不同范数在构建不确定性模型中作用的理解。",
            "id": "3195324",
            "problem": "考虑一个形式为 $a^{\\top}(I+E)x \\le b$ 的带有乘性矩阵不确定性的仿射约束，其中 $a \\in \\mathbb{R}^{n}$，$x \\in \\mathbb{R}^{n}$，$I \\in \\mathbb{R}^{n \\times n}$ 是单位矩阵，而 $E \\in \\mathbb{R}^{n \\times n}$ 是一个未知的扰动。不确定性集合在矩阵空间中为椭球体，由一个给定半径 $\\rho  0$ 的 Frobenius 范数球 $\\{E \\in \\mathbb{R}^{n \\times n} : \\|E\\|_{F} \\le \\rho\\}$ 建模。仅从 Frobenius 范数、Frobenius 内积和柯西-施瓦茨不等式的定义出发，推导在不确定性集合中所有 $E$ 上 $a^{\\top}(I+E)x$ 的最坏情况上界。然后，如果可能，通过构造或刻画一个能达到该界的 $E$ 来分析此界是否是紧的。\n\n对于数值计算，设 $n=3$，$a = \\begin{pmatrix}2 \\\\ -1 \\\\ 3\\end{pmatrix}$，$x = \\begin{pmatrix}1 \\\\ 2 \\\\ -1\\end{pmatrix}$，以及 $\\rho = 0.5$。计算在所有满足 $\\|E\\|_{F} \\le \\rho$ 的 $E$ 上 $a^{\\top}(I+E)x$ 的最坏情况值。将您的最终数值答案四舍五入到四位有效数字。",
            "solution": "问题要求表达式 $a^{\\top}(I+E)x$ 的最坏情况值，其中扰动矩阵 $E$ 属于一个由 Frobenius 范数球定义的不确定性集合。目标是找到该表达式在所有有效的 $E$ 上的最大值。\n$$\n\\max_{E \\in \\mathbb{R}^{n \\times n} : \\|E\\|_{F} \\le \\rho} a^{\\top}(I+E)x\n$$\n我们可以将表达式展开如下：\n$$\na^{\\top}(I+E)x = a^{\\top}Ix + a^{\\top}Ex = a^{\\top}x + a^{\\top}Ex\n$$\n由于项 $a^{\\top}x$ 相对于矩阵 $E$ 是一个常数，最大化整个表达式等价于最大化项 $a^{\\top}Ex$ 并将结果加到 $a^{\\top}x$ 上。\n$$\n\\max_{\\|E\\|_{F} \\le \\rho} \\left( a^{\\top}x + a^{\\top}Ex \\right) = a^{\\top}x + \\max_{\\|E\\|_{F} \\le \\rho} a^{\\top}Ex\n$$\n我们现在专注于解决子问题 $\\max_{\\|E\\|_{F} \\le \\rho} a^{\\top}Ex$。项 $a^{\\top}Ex$ 是一个标量。我们可以将这个标量表示为 $E$ 与另一个矩阵的 Frobenius 内积。两个矩阵 $A, B \\in \\mathbb{R}^{n \\times n}$ 的 Frobenius 内积定义为 $\\langle A, B \\rangle_F = \\mathrm{tr}(A^{\\top}B) = \\sum_{i=1}^n \\sum_{j=1}^n A_{ij} B_{ij}$。\n\n让我们用分量形式写出项 $a^{\\top}Ex$：\n$$\na^{\\top}Ex = \\sum_{i=1}^n a_i (Ex)_i = \\sum_{i=1}^n a_i \\left( \\sum_{j=1}^n E_{ij}x_j \\right) = \\sum_{i=1}^n \\sum_{j=1}^n E_{ij} (a_i x_j)\n$$\n这个表达式具有 Frobenius 内积的形式。如果我们定义一个矩阵 $M \\in \\mathbb{R}^{n \\times n}$，其元素为 $M_{ij} = a_i x_j$，那么该表达式等价于 $\\langle E, M \\rangle_F$。矩阵 $M$ 是向量 $a$ 和 $x$ 的外积，记作 $M = ax^{\\top}$。\n因此，我们建立了等价关系：\n$$\na^{\\top}Ex = \\langle E, ax^{\\top} \\rangle_F\n$$\n现在我们可以对 Frobenius 内积应用柯西-施瓦茨不等式，该不等式表明 $|\\langle A, B \\rangle_F| \\le \\|A\\|_F \\|B\\|_F$。由此可得：\n$$\na^{\\top}Ex = \\langle E, ax^{\\top} \\rangle_F \\le \\|E\\|_F \\|ax^{\\top}\\|_F\n$$\n问题指明 $E$ 在不确定性集合 $\\{E \\in \\mathbb{R}^{n \\times n} : \\|E\\|_{F} \\le \\rho\\}$ 中，所以我们可以用 $\\rho$ 来约束 $\\|E\\|_F$：\n$$\na^{\\top}Ex \\le \\rho \\|ax^{\\top}\\|_F\n$$\n接下来，我们必须计算矩阵 $ax^{\\top}$ 的 Frobenius 范数。使用定义 $\\|M\\|_F = \\sqrt{\\sum_{i,j} M_{ij}^2}$：\n$$\n\\|ax^{\\top}\\|_F^2 = \\sum_{i=1}^n \\sum_{j=1}^n (a_i x_j)^2 = \\left( \\sum_{i=1}^n a_i^2 \\right) \\left( \\sum_{j=1}^n x_j^2 \\right)\n$$\n括号中的项是向量 $a$ 和 $x$ 的欧几里得范数（或 $L_2$ 范数）的平方。\n$$\n\\sum_{i=1}^n a_i^2 = \\|a\\|_2^2 \\quad \\text{和} \\quad \\sum_{j=1}^n x_j^2 = \\|x\\|_2^2\n$$\n因此，$\\|ax^{\\top}\\|_F^2 = \\|a\\|_2^2 \\|x\\|_2^2$，这意味着 $\\|ax^{\\top}\\|_F = \\|a\\|_2 \\|x\\|_2$。\n\n将此结果代回到我们的不等式中，我们得到 $a^{\\top}Ex$ 的上界：\n$$\na^{\\top}Ex \\le \\rho \\|a\\|_2 \\|x\\|_2\n$$\n因此，完整表达式的最坏情况值受以下界定：\n$$\na^{\\top}(I+E)x \\le a^{\\top}x + \\rho \\|a\\|_2 \\|x\\|_2\n$$\n为确定此界是否是紧的，我们必须检查是否存在一个不确定性集合中的矩阵 $E^*$ 能够达到这个最大值。柯西-施瓦茨不等式中的等号成立，当且仅当两个矩阵共线且指向同一方向。也就是说，$E = k(ax^{\\top})$ 对于某个非负标量 $k \\ge 0$ 成立。\n为了最大化该值，我们应该在不确定性集合的边界上选择一个 $E$，即 $\\|E\\|_F = \\rho$。让我们将最坏情况矩阵 $E^*$ 设为：\n$$\nE^* = k(ax^{\\top})\n$$\n我们通过施加范数约束来找到 $k$：\n$$\n\\|E^*\\|_F = \\|k(ax^{\\top})\\|_F = k \\|ax^{\\top}\\|_F = k \\|a\\|_2 \\|x\\|_2 = \\rho\n$$\n假设 $a$ 和 $x$ 是非零向量，我们可以解出 $k$：\n$$\nk = \\frac{\\rho}{\\|a\\|_2 \\|x\\|_2}\n$$\n由于 $\\rho0$，这个 $k$ 是正的。对应的最坏情况矩阵是：\n$$\nE^* = \\frac{\\rho}{\\|a\\|_2 \\|x\\|_2} ax^{\\top}\n$$\n这个矩阵的范数确实是 $\\|E^*\\|_F = \\rho$，所以它属于不确定性集合。让我们将这个 $E^*$ 代回到表达式 $a^{\\top}Ex$ 中：\n$$\na^{\\top}E^*x = a^{\\top}\\left(\\frac{\\rho}{\\|a\\|_2 \\|x\\|_2} ax^{\\top}\\right)x = \\frac{\\rho}{\\|a\\|_2 \\|x\\|_2} a^{\\top}(a)(x^{\\top}x)\n$$\n由于 $a^{\\top}a = \\|a\\|_2^2$ 和 $x^{\\top}x = \\|x\\|_2^2$，我们得到：\n$$\na^{\\top}E^*x = \\frac{\\rho}{\\|a\\|_2 \\|x\\|_2} (\\|a\\|_2^2) (\\|x\\|_2^2) = \\rho \\|a\\|_2 \\|x\\|_2\n$$\n这证明了上界是可以达到的。该界是紧的，并且 $a^{\\top}(I+E)x$ 的最坏情况值恰好是 $a^{\\top}x + \\rho \\|a\\|_2 \\|x\\|_2$。\n\n现在，我们用给定的数据进行数值计算：\n$n=3$，$a = \\begin{pmatrix} 2 \\\\ -1 \\\\ 3 \\end{pmatrix}$，$x = \\begin{pmatrix} 1 \\\\ 2 \\\\ -1 \\end{pmatrix}$，以及 $\\rho = 0.5$。\n\n首先，我们计算名义值 $a^{\\top}x$：\n$$\na^{\\top}x = (2)(1) + (-1)(2) + (3)(-1) = 2 - 2 - 3 = -3\n$$\n接着，我们计算 $a$ 和 $x$ 的欧几里得范数：\n$$\n\\|a\\|_2 = \\sqrt{2^2 + (-1)^2 + 3^2} = \\sqrt{4 + 1 + 9} = \\sqrt{14}\n$$\n$$\n\\|x\\|_2 = \\sqrt{1^2 + 2^2 + (-1)^2} = \\sqrt{1 + 4 + 1} = \\sqrt{6}\n$$\n现在，我们计算扰动项的最大值，$\\rho \\|a\\|_2 \\|x\\|_2$：\n$$\n\\rho \\|a\\|_2 \\|x\\|_2 = 0.5 \\times \\sqrt{14} \\times \\sqrt{6} = 0.5 \\times \\sqrt{14 \\times 6} = 0.5 \\times \\sqrt{84}\n$$\n化简根式：$\\sqrt{84} = \\sqrt{4 \\times 21} = 2\\sqrt{21}$。\n$$\n\\rho \\|a\\|_2 \\|x\\|_2 = 0.5 \\times 2\\sqrt{21} = \\sqrt{21}\n$$\n整个表达式的最坏情况值是：\n$$\n\\max_{\\|E\\|_{F} \\le \\rho} a^{\\top}(I+E)x = a^{\\top}x + \\rho \\|a\\|_2 \\|x\\|_2 = -3 + \\sqrt{21}\n$$\n为了提供一个数值答案，我们计算该值并四舍五入到四位有效数字。\n$$\n\\sqrt{21} \\approx 4.58257569...\n$$\n$$\n-3 + \\sqrt{21} \\approx -3 + 4.58257569... = 1.58257569...\n$$\n四舍五入到四位有效数字得到 $1.583$。",
            "answer": "$$\\boxed{1.583}$$"
        },
        {
            "introduction": "在本节的最后一个练习中，理论将与实践相结合。在  中，您将实现切平面算法 (cutting-plane algorithm) 来求解一个完整的鲁棒优化问题。通过迭代地求解分离问题 (separation problem)——即找到使 $a^{\\top}x$ 最大的“最坏”系数 $a^{\\star}$——并添加约束 $a^{\\star \\top} x \\le b$，您将构建一个对整个不确定性集合都鲁棒的解。这个编程练习将前面练习的分析工具整合到一个强大的算法框架中。",
            "id": "3195342",
            "problem": "考虑鲁棒线性不等式 $a^{\\top} x \\le b$，此不等式必须对所有属于不确定性集 $\\mathcal{U}$ 的不确定系数向量 $a$ 成立。决策向量为 $x \\in \\mathbb{R}^n$，标量为 $b \\in \\mathbb{R}$。考虑两类不确定性集：\n\n- 椭球型：$\\mathcal{U}_{\\mathrm{ell}} = \\{ a \\in \\mathbb{R}^n \\mid a = a_0 + P u, \\ \\|u\\|_2 \\le 1 \\}$，其中 $a_0 \\in \\mathbb{R}^n$ 且 $P \\in \\mathbb{R}^{n \\times n}$。\n- 多面体型（超立方体像）：$\\mathcal{U}_{\\mathrm{poly}} = \\{ a \\in \\mathbb{R}^n \\mid a = a_0 + G z, \\ \\|z\\|_{\\infty} \\le 1 \\}$，其中 $a_0 \\in \\mathbb{R}^n$ 且 $G \\in \\mathbb{R}^{n \\times m}$。\n\n鲁棒优化方法要求最坏情况值 $\\sup_{a \\in \\mathcal{U}} a^{\\top} x$ 小于 $b$。这个上确界是集合 $\\mathcal{U}$ 在 $x$ 处取值的支撑函数。切割平面法通过迭代添加形如 $a_k^{\\top} x \\le b$ 的线性约束来构造鲁棒约束的有限松弛，其中 $a_k \\in \\mathcal{U}$ 是对于当前 $x$ 的 $a^{\\top} x$ 的最大化子。每次迭代包括：\n1. 求解线性规划（LP）子问题 $\\min c^{\\top} x$，其约束条件为对所有 $i$ 都有 $0 \\le x_i \\le 1$，以及所有累积的切割 $a_k^{\\top} x \\le b$。\n2. 使用线性代数和凸分析中的有效基础不等式（如柯西-施瓦茨不等式和对偶范数的性质），计算当前 $x$ 下 $a^{\\top} x$ 的最大化子 $a^{\\star} \\in \\mathcal{U}$，并检查 $a^{\\star \\top} x \\le b$ 是否在固定容差内成立。\n3. 如果违反，则添加切割 $a^{\\star \\top} x \\le b$ 并重复；否则，终止。\n\n从支撑函数和对偶范数的核心定义出发，仅使用这些基本原理推导椭球型和多面体型不确定性集的最大化子 $a^{\\star}$。然后，完全按照所述实现切割平面法。LP子问题必须在所有 $i$ 满足边界 $0 \\le x_i \\le 1$ 的条件下求解；除了从不确定性累积的切割外，没有其他基本约束。每次运行使用 $\\varepsilon = 10^{-8}$ 的终止容差和最多100次迭代。如果在任何迭代中LP求解器返回不可行状态，则终止并返回当前迭代次数。\n\n测试套件：\n- 案例1（正常路径）：$n=3$，$c = [-1.0,-0.8,-1.2]$，$b=1.0$，$a_0 = [0.6,0.2,0.3]$，$P = \\mathrm{diag}([0.3,0.1,0.2])$，$G = \\mathrm{diag}([0.2,0.15,0.05])$。\n- 案例2（边界条件：零迭代可能性）：$n=4$，$c = [0.5,0.4,0.7,0.6]$，$b=0.2$，$a_0 = [1.0,0.5,0.2,0.1]$，$P = \\mathrm{diag}([0.4,0.3,0.2,0.1])$，$G = \\mathrm{diag}([0.2,0.1,0.05,0.03])$。\n- 案例3（边缘案例：退化不确定性）：$n=3$，$c = [-0.9,-1.1,-0.7]$，$b=0.5$，$a_0 = [0.3,0.2,0.25]$，$P = 0_{3 \\times 3}$（零矩阵），$G = 0_{3 \\times 3}$。\n\n对于每个案例，运行切割平面法两次：一次使用 $\\mathcal{U}_{\\mathrm{poly}}$，一次使用 $\\mathcal{U}_{\\mathrm{ell}}$。记录为满足鲁棒约束所进行的迭代次数（即添加的切割数量）。您的程序应生成一行输出，其中包含这六个迭代次数，格式为用方括号括起来的逗号分隔列表，顺序为 $[\\text{案例1-多面体},\\text{案例1-椭球},\\text{案例2-多面体},\\text{案例2-椭球},\\text{案例3-多面体},\\text{案例3-椭球}]$。本问题不适用任何物理单位、角度单位或百分比格式；所有输出均为整数。",
            "solution": "### 最大化子 $a^{\\star}$ 的推导\n\n切割平面法的核心是在每次迭代中找到“违反最严重”的约束。这对应于找到向量 $a^{\\star} \\in \\mathcal{U}$，它对于给定的决策向量 $x$ 能最大化表达式 $a^{\\top}x$。这个最大值是集合 $\\mathcal{U}$ 在 $x$ 处的支撑函数，记为 $\\sigma_{\\mathcal{U}}(x) = \\sup_{a \\in \\mathcal{U}} a^{\\top}x$。对于所有 $a \\in \\mathcal{U}$ 的鲁棒约束 $a^{\\top}x \\le b$ 等价于单个约束 $\\sigma_{\\mathcal{U}}(x) \\le b$。\n\n#### 1. 椭球型不确定性集 $\\mathcal{U}_{\\mathrm{ell}}$\n对于集合 $\\mathcal{U}_{\\mathrm{ell}} = \\{ a_0 + P u \\mid \\|u\\|_2 \\le 1 \\}$，最大化问题是：\n$$ \\max_{a \\in \\mathcal{U}_{\\mathrm{ell}}} a^{\\top}x = \\max_{\\|u\\|_2 \\le 1} (a_0 + Pu)^{\\top}x $$\n我们可以展开最大化内部的项：\n$$ (a_0 + Pu)^{\\top}x = a_0^{\\top}x + (Pu)^{\\top}x = a_0^{\\top}x + u^{\\top}P^{\\top}x $$\n项 $a_0^{\\top}x$ 相对于 $u$ 是常数。问题简化为在约束 $\\|u\\|_2 \\le 1$ 下最大化 $u^{\\top}(P^{\\top}x)$。\n\n根据柯西-施瓦茨不等式，对于任意两个向量 $v, w \\in \\mathbb{R}^n$，我们有 $|v^{\\top}w| \\le \\|v\\|_2 \\|w\\|_2$。将此应用于 $v=u$ 和 $w=P^{\\top}x$：\n$$ u^{\\top}(P^{\\top}x) \\le \\|u\\|_2 \\|P^{\\top}x\\|_2 $$\n由于 $\\|u\\|_2 \\le 1$，我们有：\n$$ u^{\\top}(P^{\\top}x) \\le \\|P^{\\top}x\\|_2 $$\n$u^{\\top}(P^{\\top}x)$ 的最大值是 $\\|P^{\\top}x\\|_2$。这个最大值在 $u$ 是一个范数为1且与 $P^{\\top}x$ 共线同向的向量时达到。因此，最大化向量 $u^{\\star}$ 是：\n$$ u^{\\star} = \\begin{cases} \\frac{P^{\\top}x}{\\|P^{\\top}x\\|_2}  \\text{if } P^{\\top}x \\neq 0 \\\\ 0  \\text{if } P^{\\top}x = 0 \\end{cases} $$\n然后将 $u^{\\star}$ 代入 $a$ 的定义中，找到最大化子 $a^{\\star}$：\n$$ a^{\\star} = a_0 + Pu^{\\star} = a_0 + P \\frac{P^{\\top}x}{\\|P^{\\top}x\\|_2} $$\n支撑函数的计算结果为 $\\sigma_{\\mathcal{U}_{\\mathrm{ell}}}(x) = a_0^{\\top}x + \\|P^{\\top}x\\|_2$。\n\n#### 2. 多面体型不确定性集 $\\mathcal{U}_{\\mathrm{poly}}$\n对于集合 $\\mathcal{U}_{\\mathrm{poly}} = \\{ a_0 + G z \\mid \\|z\\|_{\\infty} \\le 1 \\}$，其中 $G \\in \\mathbb{R}^{n \\times m}$ 且 $z \\in \\mathbb{R}^m$，最大化问题是：\n$$ \\max_{a \\in \\mathcal{U}_{\\mathrm{poly}}} a^{\\top}x = \\max_{\\|z\\|_{\\infty} \\le 1} (a_0 + Gz)^{\\top}x $$\n展开表达式：\n$$ (a_0 + Gz)^{\\top}x = a_0^{\\top}x + (Gz)^{\\top}x = a_0^{\\top}x + z^{\\top}G^{\\top}x $$\n同样，$a_0^{\\top}x$ 是常数。我们需要在约束 $\\|z\\|_{\\infty} \\le 1$（等价于对所有 $i=1, \\dots, m$ 都有 $-1 \\le z_i \\le 1$）下最大化 $z^{\\top}(G^{\\top}x)$。\n令 $v = G^{\\top}x \\in \\mathbb{R}^m$。需要最大化的表达式是 $z^{\\top}v = \\sum_{i=1}^m z_i v_i$。为了在 $z_i$ 的箱式约束下最大化这个和，我们应该独立地选择每个 $z_i$，使其在 $v_i$ 的方向上具有最大可能值。\n- 如果 $v_i  0$，我们选择 $z_i=1$。\n- 如果 $v_i  0$，我们选择 $z_i=-1$。\n- 如果 $v_i = 0$，任何 $z_i \\in [-1, 1]$ 都会得到 $z_i v_i = 0$，所以我们可以简单地选择 $z_i=0$。\n\n这个逻辑被符号函数 $\\mathrm{sgn}(\\cdot)$ 精确地捕捉。最大化向量 $z^{\\star}$ 是：\n$$ z^{\\star} = \\mathrm{sgn}(G^{\\top}x) $$\n其中符号函数是按元素应用的。最大化子 $a^{\\star}$ 则是：\n$$ a^{\\star} = a_0 + G z^{\\star} = a_0 + G \\, \\mathrm{sgn}(G^{\\top}x) $$\n这个结果也可以通过对偶范数的概念来理解。在 $\\|\\cdot\\|_{\\infty}$ 范数的单位球上，$z^{\\top}v$ 的最大值根据定义是 $v$ 的对偶范数。$\\|\\cdot\\|_{\\infty}$ 范数的对偶范数是 $\\|\\cdot\\|_1$ 范数。因此，$\\sup_{\\|z\\|_{\\infty} \\le 1} z^{\\top}v = \\|v\\|_1 = \\sum_{i=1}^m |v_i|$。支撑函数为 $\\sigma_{\\mathcal{U}_{\\mathrm{poly}}}(x) = a_0^{\\top}x + \\|G^{\\top}x\\|_1$。\n\n### 算法实现\n切割平面法通过迭代循环实现。\n1.  用一个空切割集初始化。设切割数量 `num_cuts` $= 0$。\n2.  开始一个最多运行100次的循环。\n3.  在每次迭代中，求解当前的LP子问题：$\\min c^{\\top}x$，约束条件为箱式约束 $0 \\le x_i \\le 1$ 和 `num_cuts` 个累积切割。这是使用 `scipy.optimize.linprog` 完成的。\n4.  如果LP求解器报告不可行，算法终止，返回 `num_cuts` 的当前值。\n5.  利用LP的最优解 $x$，使用为指定的不确定性集（$\\mathcal{U}_{\\mathrm{ell}}$ 或 $\\mathcal{U}_{\\mathrm{poly}}$）推导出的公式计算相应的最大化子 $a^{\\star}$。\n6.  计算违反量为 $v = a^{\\star\\top}x - b$。\n7.  如果 $v \\le \\varepsilon = 10^{-8}$，则对于当前的 $x$，鲁棒约束得到满足。算法已收敛并终止，返回 `num_cuts`。\n8.  如果 $v  \\varepsilon$，则约束被违反。将新的切割 $a^{\\star\\top}x \\le b$ 添加到约束集中，将 `num_cuts` 增加1，并继续下一次迭代。\n9.  如果循环完成而未收敛，则返回最大迭代次数（100）。\n此过程将应用于每个测试案例的多面体和椭球型不确定性集。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the cutting-plane algorithm.\n    \"\"\"\n\n    def run_cutting_plane(c, b, a_0, M, uncertainty_type, n, epsilon, max_iter):\n        \"\"\"\n        Implements the cutting-plane algorithm for a robust linear inequality.\n\n        Args:\n            c (np.ndarray): Cost vector for the LP objective.\n            b (float): RHS of the robust inequality.\n            a_0 (np.ndarray): Center of the uncertainty set.\n            M (np.ndarray): Shape matrix (P for ellipsoidal, G for polyhedral).\n            uncertainty_type (str): Either 'ell' for ellipsoidal or 'poly' for polyhedral.\n            n (int): Dimension of the decision vector x.\n            epsilon (float): Termination tolerance.\n            max_iter (int): Maximum number of iterations.\n\n        Returns:\n            int: The number of cuts added before termination.\n        \"\"\"\n        A_cuts = np.empty((0, n))\n        b_cuts = np.empty(0)\n        \n        num_cuts = 0\n        while num_cuts  max_iter:\n            # Step 1: Solve the LP subproblem\n            # Bounds are 0 = x_i = 1 for all i\n            res = linprog(c, A_ub=A_cuts, b_ub=b_cuts, bounds=(0, 1), method='highs')\n\n            # Handle infeasible LP subproblem\n            if res.status == 2:  # Status 2 for 'highs' method indicates infeasibility\n                return num_cuts\n            \n            # This case should ideally not be hit with the given problem structure (bounded domain)\n            if not res.success:\n                # Return max_iter to signify failure to solve the subproblem\n                return max_iter\n\n            x = res.x\n            \n            # Step 2: Compute the maximizer a_star (worst-case 'a')\n            if uncertainty_type == 'ell':\n                P = M\n                Pt_x = P.T @ x\n                norm_Pt_x = np.linalg.norm(Pt_x, 2)\n                \n                if norm_Pt_x  1e-12: # Numerical stability for division by zero\n                    u_star = np.zeros(P.shape[1])\n                else:\n                    u_star = Pt_x / norm_Pt_x\n                a_star = a_0 + P @ u_star\n            elif uncertainty_type == 'poly':\n                G = M\n                Gt_x = G.T @ x\n                z_star = np.sign(Gt_x)\n                a_star = a_0 + G @ z_star\n            else:\n                # This case should not be reached with valid inputs\n                raise ValueError(\"Invalid uncertainty type specified.\")\n\n            # Step 3: Check for violation and terminate or add cut\n            violation = a_star.T @ x - b\n            \n            if violation = epsilon:\n                return num_cuts\n            \n            # Add the new cut\n            A_cuts = np.vstack([A_cuts, a_star])\n            b_cuts = np.append(b_cuts, b)\n            num_cuts += 1\n            \n        return max_iter\n\n    # Define common algorithm parameters\n    epsilon = 1e-8\n    max_iterations = 100\n\n    # Define test cases\n    test_cases = [\n        {\n            \"n\": 3, \"m\": 3,\n            \"c\": np.array([-1.0, -0.8, -1.2]),\n            \"b\": 1.0,\n            \"a_0\": np.array([0.6, 0.2, 0.3]),\n            \"P\": np.diag([0.3, 0.1, 0.2]),\n            \"G\": np.diag([0.2, 0.15, 0.05])\n        },\n        {\n            \"n\": 4, \"m\": 4,\n            \"c\": np.array([0.5, 0.4, 0.7, 0.6]),\n            \"b\": 0.2,\n            \"a_0\": np.array([1.0, 0.5, 0.2, 0.1]),\n            \"P\": np.diag([0.4, 0.3, 0.2, 0.1]),\n            \"G\": np.diag([0.2, 0.1, 0.05, 0.03])\n        },\n        {\n            \"n\": 3, \"m\": 3,\n            \"c\": np.array([-0.9, -1.1, -0.7]),\n            \"b\": 0.5,\n            \"a_0\": np.array([0.3, 0.2, 0.25]),\n            \"P\": np.zeros((3, 3)),\n            \"G\": np.zeros((3, 3))\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Run for Polyhedral Uncertainty\n        iters_poly = run_cutting_plane(\n            case[\"c\"], case[\"b\"], case[\"a_0\"], case[\"G\"], 'poly', case[\"n\"], epsilon, max_iterations\n        )\n        results.append(iters_poly)\n\n        # Run for Ellipsoidal Uncertainty\n        # For ellipsoidal, P is n x n, so u_star is n-dim\n        if uncertainty_type == 'ell':\n            if P.shape[1] != n:\n                u_star = np.zeros(n)\n            else:\n                 u_star = np.zeros(P.shape[1])\n        iters_ell = run_cutting_plane(\n            case[\"c\"], case[\"b\"], case[\"a_0\"], case[\"P\"], 'ell', case[\"n\"], epsilon, max_iterations\n        )\n        # correct shape for u_star\n        if case['P'].shape[1] != case['n']: # handle non-square P if needed, though problem implies square\n            u_star_dim = case['P'].shape[1]\n        else:\n            u_star_dim = case['n']\n\n        # Fix u_star initialization in ellipsoidal case\n        original_run_func = run_cutting_plane\n        def run_cutting_plane_ell_fixed(*args, **kwargs):\n            # This wrapper is a bit of a hack to fix the u_star dimension inside the loop\n            # without rewriting the whole function structure for this specific call.\n            # A better implementation would have the shape of u passed or inferred inside.\n            _run = original_run_func\n            P_matrix = args[3] # M matrix\n            \n            # Local override inside the wrapper\n            def _local_run_cutting_plane(c, b, a_0, M, uncertainty_type, n, epsilon, max_iter):\n                A_cuts = np.empty((0, n))\n                b_cuts = np.empty(0)\n                num_cuts = 0\n                while num_cuts  max_iter:\n                    res = linprog(c, A_ub=A_cuts, b_ub=b_cuts, bounds=(0, 1), method='highs')\n                    if res.status == 2: return num_cuts\n                    if not res.success: return max_iter\n                    x = res.x\n                    if uncertainty_type == 'ell':\n                        P = M\n                        Pt_x = P.T @ x\n                        norm_Pt_x = np.linalg.norm(Pt_x, 2)\n                        if norm_Pt_x  1e-12:\n                            u_star = np.zeros(P.shape[1])\n                        else:\n                            u_star = Pt_x / norm_Pt_x\n                        a_star = a_0 + P @ u_star\n                    else: # poly\n                        G = M\n                        Gt_x = G.T @ x\n                        z_star = np.sign(Gt_x)\n                        a_star = a_0 + G @ z_star\n                    violation = a_star.T @ x - b\n                    if violation = epsilon: return num_cuts\n                    A_cuts = np.vstack([A_cuts, a_star])\n                    b_cuts = np.append(b_cuts, b)\n                    num_cuts += 1\n                return max_iter\n            return _local_run_cutting_plane(*args, **kwargs)\n        \n        iters_ell = _local_run_cutting_plane(\n            case[\"c\"], case[\"b\"], case[\"a_0\"], case[\"P\"], 'ell', case[\"n\"], epsilon, max_iterations\n        )\n        \n        results.append(iters_ell)\n\n    # The wrapper hack is overly complex. The original code is correct because P is n x n, so P.shape[1] is n.\n    # The u_star vector should have dimension n. So np.zeros(n) was correct.\n    # Re-running the logic mentally: P is n x n, x is n x 1, P.T is n x n. P.T @ x is n x 1. u_star is n x 1. P @ u_star is n x 1. All dimensions match.\n    # The original code `u_star = np.zeros(n)` was correct. The shape of u is the number of columns of P, which is n.\n    # The code was mostly fine, just the loop condition needed fixing. Let's revert to a simpler code structure.\n\n    # Simpler, corrected main block\n    final_results = []\n    for case in test_cases:\n        # Run for Polyhedral Uncertainty\n        iters_poly = run_cutting_plane(\n            case[\"c\"], case[\"b\"], case[\"a_0\"], case[\"G\"], 'poly', case[\"n\"], epsilon, max_iterations\n        )\n        final_results.append(iters_poly)\n\n        # Run for Ellipsoidal Uncertainty\n        iters_ell = run_cutting_plane(\n            case[\"c\"], case[\"b\"], case[\"a_0\"], case[\"P\"], 'ell', case[\"n\"], epsilon, max_iterations\n        )\n        final_results.append(iters_ell)\n\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```"
        }
    ]
}