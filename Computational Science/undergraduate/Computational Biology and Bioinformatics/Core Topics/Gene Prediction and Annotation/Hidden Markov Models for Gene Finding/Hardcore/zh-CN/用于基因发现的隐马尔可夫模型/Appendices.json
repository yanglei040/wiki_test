{
    "hands_on_practices": [
        {
            "introduction": "在我们寻找*最可能*的基因结构之前，我们必须理解如何计算*任何*给定结构的概率。这项练习让您亲手实践隐马尔可夫模型（HMM）的基石——前向算法，通过计算在特定生物学约束下观测序列的总概率来巩固核心知识。掌握这项计算对于理解HMM如何评估关于基因组数据的不同假设至关重要。",
            "id": "2397576",
            "problem": "一个用于基因识别的双状态隐马尔可夫模型 (HMM) 从两个发射状态——外显子 ($E$) 和内含子 ($I$)——发射脱氧核糖核酸 (DNA) 核苷酸。模型有一个静默起始状态 ($S$) 和一个静默结束状态 ($F$)。转移概率如下：\n- 从 $S$ 出发：$a_{S,E}=0.9$，$a_{S,I}=0.1$。\n- 从 $E$ 出发：$a_{E,E}=0.8$，$a_{E,I}=0.1$，$a_{E,F}=0.1$。\n- 从 $I$ 出发：$a_{I,I}=0.7$，$a_{I,E}=0.2$，$a_{I,F}=0.1$。\n\n对于核苷酸 $A, C, G, T$ 的发射概率如下：\n- 在状态 $E$ 中：$b_{E}(A)=0.3$，$b_{E}(C)=0.2$，$b_{E}(G)=0.2$，$b_{E}(T)=0.3$。\n- 在状态 $I$ 中：$b_{I}(A)=0.1$，$b_{I}(C)=0.4$，$b_{I}(G)=0.4$，$b_{I}(T)=0.1$。\n\n假设模型从状态 $S$ 开始，发射正好三个符号，然后转移到状态 $F$。对于观测到的核苷酸序列 $G, C, A$，计算模型生成此序列且状态路径在终止前至少访问一次内含子状态 $I$ 的概率。将你的答案四舍五入到四位有效数字。将最终结果表示为一个无量纲数。",
            "solution": "该问题提法恰当且科学上合理。这是隐马尔可夫模型 (HMM) 在生物信息学中的一个标准应用。所有必需的参数均已提供，且目标明确。我们将着手进行解答。\n\n问题要求计算在给定 HMM 下生成观测核苷酸序列 $O = (G, C, A)$ 的概率，并附加一个约束条件，即底层状态序列 $\\Pi = (\\pi_1, \\pi_2, \\pi_3)$ 至少访问一次内含子状态 $I$。模型从静默起始状态 $S$ 开始，从发射状态 $E$ (外显子) 或 $I$ (内含子) 发射三个符号，然后通过转移到静默结束状态 $F$ 来终止。\n\n所求概率是序列 $O$ 在所有包含至少一个状态 $I$ 的长度为 3 的可能状态路径上的概率之和。\n$$ P(\\text{goal}) = \\sum_{\\Pi: I \\in \\Pi} P(O, \\Pi) $$\n一个更有效的方法是使用全概率公式。观测到序列 $O$ 的总概率，记为 $P(O)$，是所有可能路径上的概率之和。\n$$ P(O) = \\sum_{\\text{all } \\Pi} P(O, \\Pi) = P(O, \\text{path contains } I) + P(O, \\text{path contains no } I) $$\n唯一不包含状态 $I$ 的长度为 3 的路径是 $\\Pi_{EEE} = (E, E, E)$。因此，所求概率可以计算为：\n$$ P(\\text{goal}) = P(O=(G,C,A)) - P(O=(G,C,A), \\Pi=\\Pi_{EEE}) $$\n我们将分别计算这两项。\n\n**第一部分：使用前向算法计算总概率 $P(O)$**\n\n前向变量 $\\alpha_t(j)$ 定义为观测到部分序列 $O_1, \\dots, O_t$ 并在时间 $t$ 处于状态 $j$ 的概率。\n状态为 $j \\in \\{E, I\\}$。观测值为 $O_1=G$, $O_2=C$, $O_3=A$。\n\n初始化 ($t=1$)：在第一次发射后处于状态 $j$ 的概率是从起始状态 $S$ 到 $j$ 的转移概率与从状态 $j$ 发射 $O_1$ 的发射概率的乘积。\n$$ \\alpha_1(j) = a_{S,j} \\cdot b_j(O_1) $$\n对于 $O_1=G$：\n$$ \\alpha_1(E) = a_{S,E} \\cdot b_E(G) = 0.9 \\times 0.2 = 0.18 $$\n$$ \\alpha_1(I) = a_{S,I} \\cdot b_I(G) = 0.1 \\times 0.4 = 0.04 $$\n\n递归 ($t=2, 3$)：时间 $t$ 的前向变量是基于时间 $t-1$ 的值计算的。\n$$ \\alpha_t(j) = \\left( \\sum_{i \\in \\{E,I\\}} \\alpha_{t-1}(i) \\cdot a_{i,j} \\right) \\cdot b_j(O_t) $$\n对于 $t=2$ 和 $O_2=C$：\n$$ \\alpha_2(E) = (\\alpha_1(E) \\cdot a_{E,E} + \\alpha_1(I) \\cdot a_{I,E}) \\cdot b_E(C) $$\n$$ \\alpha_2(E) = (0.18 \\times 0.8 + 0.04 \\times 0.2) \\times 0.2 = (0.144 + 0.008) \\times 0.2 = 0.152 \\times 0.2 = 0.0304 $$\n$$ \\alpha_2(I) = (\\alpha_1(E) \\cdot a_{E,I} + \\alpha_1(I) \\cdot a_{I,I}) \\cdot b_I(C) $$\n$$ \\alpha_2(I) = (0.18 \\times 0.1 + 0.04 \\times 0.7) \\times 0.4 = (0.018 + 0.028) \\times 0.4 = 0.046 \\times 0.4 = 0.0184 $$\n对于 $t=3$ 和 $O_3=A$：\n$$ \\alpha_3(E) = (\\alpha_2(E) \\cdot a_{E,E} + \\alpha_2(I) \\cdot a_{I,E}) \\cdot b_E(A) $$\n$$ \\alpha_3(E) = (0.0304 \\times 0.8 + 0.0184 \\times 0.2) \\times 0.3 = (0.02432 + 0.00368) \\times 0.3 = 0.028 \\times 0.3 = 0.0084 $$\n$$ \\alpha_3(I) = (\\alpha_2(E) \\cdot a_{E,I} + \\alpha_2(I) \\cdot a_{I,I}) \\cdot b_I(A) $$\n$$ \\alpha_3(I) = (0.0304 \\times 0.1 + 0.0184 \\times 0.7) \\times 0.1 = (0.00304 + 0.01288) \\times 0.1 = 0.01592 \\times 0.1 = 0.001592 $$\n\n终止：观测到序列 $O=(G,C,A)$ 的总概率是最终的前向概率乘以它们各自到最终状态 $F$ 的转移概率之和。\n$$ P(O) = \\sum_{j \\in \\{E,I\\}} \\alpha_3(j) \\cdot a_{j,F} $$\n$$ P(O) = \\alpha_3(E) \\cdot a_{E,F} + \\alpha_3(I) \\cdot a_{I,F} $$\n$$ P(O) = (0.0084 \\times 0.1) + (0.001592 \\times 0.1) = 0.00084 + 0.0001592 = 0.0009992 $$\n\n**第二部分：计算路径 $\\Pi_{EEE}$ 与序列 $O$ 的概率**\n\n特定状态路径 $\\Pi=(\\pi_1, \\pi_2, \\pi_3)$ 和观测序列 $O=(O_1, O_2, O_3)$ 的联合概率由下式给出：\n$$ P(O, \\Pi) = a_{S,\\pi_1} \\cdot b_{\\pi_1}(O_1) \\cdot a_{\\pi_1,\\pi_2} \\cdot b_{\\pi_2}(O_2) \\cdot a_{\\pi_2,\\pi_3} \\cdot b_{\\pi_3}(O_3) \\cdot a_{\\pi_3,F} $$\n对于路径 $\\Pi_{EEE}=(E,E,E)$ 和序列 $O=(G,C,A)$：\n$$ P(O, \\Pi_{EEE}) = a_{S,E} b_E(G) \\cdot a_{E,E} b_E(C) \\cdot a_{E,E} b_E(A) \\cdot a_{E,F} $$\n代入给定值：\n$$ P(O, \\Pi_{EEE}) = (0.9 \\times 0.2) \\cdot (0.8 \\times 0.2) \\cdot (0.8 \\times 0.3) \\cdot 0.1 $$\n$$ P(O, \\Pi_{EEE}) = 0.18 \\times 0.16 \\times 0.24 \\times 0.1 = 0.0006912 $$\n\n**第三部分：最终计算**\n\n观测到序列 $O$ 且至少访问一次状态 $I$ 的概率是：\n$$ P(\\text{goal}) = P(O) - P(O, \\Pi_{EEE}) $$\n$$ P(\\text{goal}) = 0.0009992 - 0.0006912 = 0.0003080 $$\n\n题目要求将答案四舍五入到四位有效数字。计算出的值为 $0.0003080$。第一个有效数字是 $3$。四位有效数字是 $3, 0, 8, 0$。结果已经是所要求的格式。",
            "answer": "$$\n\\boxed{0.0003080}\n$$"
        },
        {
            "introduction": "维特比算法是基因发现的主力工具，它使我们能够从DNA序列中解码出最可能的状态序列（即基因结构）。本实践将指导您实现这一基本算法，并用它来研究一个关键的生物学问题：单个核苷酸的插入或缺失如何引起移码，从而彻底改变预测的基因。这个练习将算法的实现与一个具体的生物学后果直接联系起来。",
            "id": "2397575",
            "problem": "给定一个离散隐马尔可夫模型（HMM），该模型专为捕捉基因结构而设计，采用了一个简单的编码框架模型。隐藏状态空间由四个状态组成：非编码状态 $N$ 和一个三周期编码循环 $C_0, C_1, C_2$。观测值为核苷酸，来自字母表 $\\{A,C,G,T\\}$。该HMM的完整定义如下。\n\n- 隐藏状态：$\\{N, C_0, C_1, C_2\\}$，按此顺序。\n- 初始分布 $\\boldsymbol{\\pi}$：\n  - $\\pi(N)=0.9$, $\\pi(C_0)=0.1$, $\\pi(C_1)=0.0$, $\\pi(C_2)=0.0$。\n- 从状态 $i$ 到状态 $j$ 的转移概率 $a_{ij}$（行和为 $1$）：\n  - 从 $N$：$a_{N,N}=0.95$, $a_{N,C_0}=0.05$, $a_{N,C_1}=0.0$, $a_{N,C_2}=0.0$。\n  - 从 $C_0$：$a_{C_0,C_1}=0.94$, $a_{C_0,N}=0.06$, $a_{C_0,C_0}=0.0$, $a_{C_0,C_2}=0.0$。\n  - 从 $C_1$：$a_{C_1,C_2}=0.94$, $a_{C_1,N}=0.06$, $a_{C_1,C_0}=0.0$, $a_{C_1,C_1}=0.0$。\n  - 从 $C_2$：$a_{C_2,C_0}=0.94$, $a_{C_2,N}=0.06$, $a_{C_2,C_1}=0.0$, $a_{C_2,C_2}=0.0$。\n- 每个状态 $s \\in \\{N,C_0,C_1,C_2\\}$ 和符号 $x \\in \\{A,C,G,T\\}$ 的发射概率 $b_s(x)$：\n  - 对于 $N$：$b_N(A)=0.30$, $b_N(C)=0.20$, $b_N(G)=0.20$, $b_N(T)=0.30$。\n  - 对于 $C_0$：$b_{C_0}(A)=0.15$, $b_{C_0}(C)=0.35$, $b_{C_0}(G)=0.35$, $b_{C_0}(T)=0.15$。\n  - 对于 $C_1$：$b_{C_1}(A)=0.25$, $b_{C_1}(C)=0.25$, $b_{C_1}(G)=0.25$, $b_{C_1}(T)=0.25$。\n  - 对于 $C_2$：$b_{C_2}(A)=0.35$, $b_{C_2}(C)=0.15$, $b_{C_2}(G)=0.15$, $b_{C_2}(T)=0.35$。\n\n对于一个观测序列，维特比路径是该HMM下最可能的隐藏状态序列。\n\n您的任务是通过比较原始序列及其突变对应序列的维特比路径，来量化由单个核苷酸插入或删除（indel）引起的读码框移位如何改变维特比路径。使用以下比对约定，在原始序列的基因组坐标系中比较路径：\n- 对于在原始索引 $i$（从零开始）处向突变序列中插入一个符号的情况：对于每个原始位置 $j$（其中 $0 \\le j  L$），如果 $j  i$，则将原始路径中的状态 $(Q_{\\text{orig}})_j$ 与突变路径中的状态 $(Q_{\\text{mut}})_j$ 进行比较；如果 $j \\ge i$，则将 $(Q_{\\text{orig}})_j$ 与 $(Q_{\\text{mut}})_{j+1}$ 进行比较。差异为错配数除以原始序列长度 $L$。\n- 对于在原始索引 $i$ 处删除一个符号的情况：对于每个原始位置 $j$（其中 $j \\ne i$），如果 $j  i$，则将 $(Q_{\\text{orig}})_j$ 与 $(Q_{\\text{mut}})_j$ 进行比较；如果 $j > i$，则将 $(Q_{\\text{orig}})_j$ 与 $(Q_{\\text{mut}})_{j-1}$ 进行比较。差异为错配数除以 $(L-1)$。\n该“移码状态差异”值是状态不同的位置所占的比例。\n\n- 测试用例 1：原始序列 $x_1 = (\\text{\"GCA\"})^{12}$，在索引 $15$ 处插入 \"A\"。\n- 测试用例 2：原始序列 $x_2 = (\\text{\"GCA\"})^{10}$，在索引 $0$ 处插入 \"T\"。\n- 测试用例 3：原始序列 $x_3 = (\\text{\"AT\"})^{18}$，在索引 $10$ 处删除一个核苷酸。\n\n将三个差异值（按顺序）作为逗号分隔的列表包含在方括号中，四舍五入到三位小数。例如，`[0.123,0.456,0.789]`。",
            "solution": "该问题需要进行验证。\n\n**步骤1：提取给定信息**\n- **隐藏状态**：包含四个状态的集合 $\\{N, C_0, C_1, C_2\\}$，分别代表非编码区和编码框架的三个阶段。用于矩阵表示的指定顺序是 $N, C_0, C_1, C_2$。\n- **观测字母表**：核苷酸集合 $\\{A,C,G,T\\}$。\n- **初始状态分布 ($\\boldsymbol{\\pi}$)**：一个向量，指定在每个状态开始的概率。\n  - $\\pi(N)=0.9$\n  - $\\pi(C_0)=0.1$\n  - $\\pi(C_1)=0.0$\n  - $\\pi(C_2)=0.0$\n- **转移概率 ($a_{ij}$)**：一个矩阵，其中 $a_{ij}$ 是从状态 $i$ 转移到状态 $j$ 的概率。\n  - 从 $N$：$a_{N,N}=0.95$, $a_{N,C_0}=0.05$。从 $N$ 出发的其他转移概率为 $0.0$。\n  - 从 $C_0$：$a_{C_0,C_1}=0.94$, $a_{C_0,N}=0.06$。从 $C_0$ 出发的其他转移概率为 $0.0$。\n  - 从 $C_1$：$a_{C_1,C_2}=0.94$, $a_{C_1,N}=0.06$。从 $C_1$ 出发的其他转移概率为 $0.0$。\n  - 从 $C_2$：$a_{C_2,C_0}=0.94$, $a_{C_2,N}=0.06$。从 $C_2$ 出发的其他转移概率为 $0.0$。\n- **发射概率 ($b_s(x)$)**：对于每个状态 $s$，观测字母表上的一个分布。\n  - 状态 $N$：$b_N(A)=0.30$, $b_N(C)=0.20$, $b_N(G)=0.20$, $b_N(T)=0.30$。\n  - 状态 $C_0$：$b_{C_0}(A)=0.15$, $b_{C_0}(C)=0.35$, $b_{C_0}(G)=0.35$, $b_{C_0}(T)=0.15$。\n  - 状态 $C_1$：$b_{C_1}(A)=0.25$, $b_{C_1}(C)=0.25$, $b_{C_1}(G)=0.25$, $b_{C_1}(T)=0.25$。\n  - 状态 $C_2$：$b_{C_2}(A)=0.35$, $b_{C_2}(C)=0.15$, $b_{C_2}(G)=0.15$, $b_{C_2}(T)=0.35$。\n- **任务**：对于三个涉及原始序列和突变序列（通过插入或删除）的特定测试用例，计算“移码状态差异”。\n- **差异定义**：使用指定的比对规则，比较原始序列的维特比路径与突变序列的维特比路径时，状态不同的位置所占的比例。\n- **测试用例**：\n  1. 原始序列 $x_1 = (\\text{\"GCA\"})^{12}$，在索引 $15$ 处插入 \"A\"。\n  2. 原始序列 $x_2 = (\\text{\"GCA\"})^{10}$，在索引 $0$ 处插入 \"T\"。\n  3. 原始序列 $x_3 = (\\text{\"AT\"})^{18}$，在索引 $10$ 处删除。\n- **输出格式**：单行输出，包含三个差异值，以逗号分隔的列表形式，并用方括号括起来，四舍五入到三位小数。\n\n**步骤2：使用提取的给定信息进行验证**\n根据验证标准对问题进行评估。\n- **科学依据**：该问题使用了隐马尔可夫模型（HMM），这是计算生物学中用于序列分析（包括基因发现）的标准和基础工具。该模型架构虽然简化，但有效表示了非编码区和三阶段编码框架。所有定义都基于成熟的概率论和算法。该问题在科学上是合理的。\n- **适定性**：该问题提供了HMM参数（$\\boldsymbol{\\pi}$、转移矩阵 $A$、发射矩阵 $B$）的完整规范。维特比算法是一个确定性过程，可为给定的观测序列找到唯一的最大概率状态路径。“移码状态差异”的度量标准定义明确。该问题是适定的。\n- **客观性**：问题的所有组成部分都由精确的数值或清晰、客观的规则指定。没有主观性语言或依赖于观点。\n- **缺陷检查清单**：该问题没有违反任何指定的缺陷条件。分布中的概率总和为 $1$。模型是自洽、一致且计算上可行的。\n\n**步骤3：结论和行动**\n该问题是**有效的**。将提供一个解决方案。\n\n**方法论**\n\n隐马尔可夫模型是一个由一组参数 $\\lambda = (A, B, \\boldsymbol{\\pi})$ 定义的统计模型。设 $K$ 个隐藏状态的集合为 $S = \\{s_1, s_2, \\dots, s_K\\}$，观测字母表由 $M$ 个符号组成。我们已知：\n- 初始状态概率 $\\boldsymbol{\\pi} = [\\pi_i]$，其中 $\\pi_i = P(q_1 = s_i)$ 是初始状态 $q_1$ 为 $s_i$ 的概率。\n- 状态转移概率矩阵 $A = [a_{ij}]$，其中 $a_{ij} = P(q_{t+1} = s_j | q_t = s_i)$ 是从状态 $s_i$ 转移到状态 $s_j$ 的概率。\n- 发射概率矩阵 $B = [b_j(k)]$，其中 $b_j(k) = P(o_t = v_k | q_t = s_j)$ 是在状态 $s_j$ 时观测到符号 $v_k$ 的概率。\n\n对于这个问题，状态为 $S = \\{N, C_0, C_1, C_2\\}$，索引从 $0$ 到 $3$。观测值来自 $\\{A, C, G, T\\}$，索引从 $0$ 到 $3$。HMM参数如下：\n\n初始概率 $\\boldsymbol{\\pi}$：\n$$ \\boldsymbol{\\pi} = \\begin{bmatrix} 0.9  0.1  0.0  0.0 \\end{bmatrix} $$\n\n转移矩阵 $A$：\n$$ A = \\begin{bmatrix}\n0.95  0.05  0.00  0.00 \\\\\n0.06  0.00  0.94  0.00 \\\\\n0.06  0.00  0.00  0.94 \\\\\n0.06  0.94  0.00  0.00\n\\end{bmatrix} $$\n行和列由 $(N, C_0, C_1, C_2)$ 索引。\n\n发射矩阵 $B$：\n$$ B = \\begin{bmatrix}\n0.30  0.20  0.20  0.30 \\\\\n0.15  0.35  0.35  0.15 \\\\\n0.25  0.25  0.25  0.25 \\\\\n0.35  0.15  0.15  0.35\n\\end{bmatrix} $$\n行由 $(N, C_0, C_1, C_2)$ 索引，列由 $(A, C, G, T)$ 索引。\n\n**维特比算法**\n\n给定一个观测序列 $O = o_1, o_2, \\dots, o_T$，维特比算法找到最可能的隐藏状态序列 $Q^* = q_1^*, q_2^*, \\dots, q_T^*$。为了避免因乘以许多小概率而导致的数值下溢，我们在对数空间中进行操作。\n\n定义 $\\delta_t(k)$ 为生成了前 $t$ 个观测值且以状态 $s_k$ 结尾的任意长度为 $t$ 的路径的最大概率。在对数空间中，这表示为 $\\log\\delta_t(k)$。我们还存储回溯指针 $\\psi_t(k)$，它记录了在时间 $t$ 到达状态 $s_k$ 的路径上最可能的前一个状态。\n\n1.  **初始化 ($t=1$)：**\n    对于每个状态 $s_k$，$k \\in \\{1, \\dots, K\\}$：\n    $$ \\log\\delta_1(k) = \\log(\\pi_k) + \\log(b_k(o_1)) $$\n    $$ \\psi_1(k) = 0 $$\n\n2.  **递归 ($t=2, \\dots, T$)：**\n    对于每个状态 $s_j$，$j \\in \\{1, \\dots, K\\}$：\n    $$ \\log\\delta_t(j) = \\max_{i=1 \\dots K} [ \\log\\delta_{t-1}(i) + \\log(a_{ij}) ] + \\log(b_j(o_t)) $$\n    $$ \\psi_t(j) = \\arg\\max_{i=1 \\dots K} [ \\log\\delta_{t-1}(i) + \\log(a_{ij}) ] $$\n\n3.  **终止：**\n    最可能路径的概率是 $P^* = \\max_{k=1 \\dots K} [ \\log\\delta_T(k) ]$。\n    最可能路径的最终状态是 $q_T^* = \\arg\\max_{k=1 \\dots K} [ \\log\\delta_T(k) ]$。\n\n4.  **路径回溯 ($t=T-1, \\dots, 1$)：**\n    通过回溯指针恢复状态序列：\n    $$ q_t^* = \\psi_{t+1}(q_{t+1}^*) $$\n\n**移码状态差异**\n\n该度量量化了长度为 $L$ 的原始序列的维特比路径 $Q_{\\text{orig}}$ 与突变序列的路径 $Q_{\\text{mut}}$ 之间的差异。\n\n- **插入**：在原始索引 $i$ 处的一次插入会产生一个长度为 $L+1$ 的突变序列。比较是在 $L$ 个位置上进行的。\n  - 对于 $j \\in [0, i-1]$，我们比较 $(Q_{\\text{orig}})_j$ 和 $(Q_{\\text{mut}})_j$。\n  - 对于 $j \\in [i, L-1]$，我们比较 $(Q_{\\text{orig}})_j$ 和 $(Q_{\\text{mut}})_{j+1}$。\n  差异值为错配数除以 $L$。\n\n- **删除**：在原始索引 $i$ 处的一次删除会产生一个长度为 $L-1$ 的突变序列。比较是在 $L-1$ 个位置上进行的。\n  - 对于 $j \\in [0, i-1]$，我们比较 $(Q_{\\text{orig}})_j$ 和 $(Q_{\\text{mut}})_j$。\n  - 原始序列中的位置 $j=i$ 被跳过。\n  - 对于 $j \\in [i+1, L-1]$，我们比较 $(Q_{\\text{orig}})_j$ 和 $(Q_{\\text{mut}})_{j-1}$。\n  差异值为错配数除以 $(L-1)$。\n\n**执行**\n\n对于三个测试用例中的每一个，执行以下步骤：\n1.  构建原始和突变的核苷酸序列。\n2.  对每个序列应用维特比算法，以确定其最可能的隐藏状态路径。\n3.  根据指定的插入/删除操作规则对齐两个结果路径。\n4.  统计对齐后状态不同的位置数量。\n5.  通过将错配计数除以比较的总位置数来计算移码状态差异。\n6.  结果四舍五入到三位小数。\n\n这些结果的汇总构成了最终输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the HMM gene finding problem by implementing the Viterbi algorithm\n    and calculating frame-shift state divergence for given test cases.\n    \"\"\"\n    \n    # Define HMM parameters\n    # States: {0: N, 1: C0, 2: C1, 3: C2}\n    # Observations: {0: A, 1: C, 2: G, 3: T}\n    \n    states = {'N': 0, 'C0': 1, 'C1': 2, 'C2': 3}\n    state_names = {v: k for k, v in states.items()}\n    obs_map = {'A': 0, 'C': 1, 'G': 2, 'T': 3}\n\n    # Initial probabilities (pi)\n    pi = np.array([0.9, 0.1, 0.0, 0.0])\n\n    # Transition matrix (A)\n    A = np.array([\n        [0.95, 0.05, 0.00, 0.00],  # From N\n        [0.06, 0.00, 0.94, 0.00],  # From C0 to N, C1\n        [0.06, 0.00, 0.00, 0.94],  # From C1 to N, C2\n        [0.06, 0.94, 0.00, 0.00]   # From C2 to N, C0\n    ])\n\n    # Emission matrix (B)\n    B = np.array([\n        [0.30, 0.20, 0.20, 0.30],  # N\n        [0.15, 0.35, 0.35, 0.15],  # C0\n        [0.25, 0.25, 0.25, 0.25],  # C1\n        [0.35, 0.15, 0.15, 0.35]   # C2\n    ])\n\n    # Convert probabilities to log-space to prevent underflow\n    with np.errstate(divide='ignore'):\n        log_pi = np.log(pi)\n        log_A = np.log(A)\n        log_B = np.log(B)\n\n    def viterbi(obs_seq, num_states, log_start_p, log_trans_p, log_emit_p):\n        \"\"\"\n        Calculates the most likely hidden state sequence using the Viterbi algorithm in log-space.\n        \n        Args:\n            obs_seq (list of int): Sequence of observation indices.\n            num_states (int): Number of hidden states.\n            log_start_p (np.array): Log of initial state probabilities.\n            log_trans_p (np.array): Log of transition probability matrix.\n            log_emit_p (np.array): Log of emission probability matrix.\n            \n        Returns:\n            list of int: The most probable sequence of hidden state indices.\n        \"\"\"\n        T = len(obs_seq)\n        if T == 0:\n            return []\n\n        # Viterbi (delta) matrix for log probabilities\n        viterbi_matrix = np.zeros((T, num_states))\n        # Backpointer matrix\n        backpointer_matrix = np.zeros((T, num_states), dtype=int)\n\n        # Initialization step\n        viterbi_matrix[0, :] = log_start_p + log_emit_p[:, obs_seq[0]]\n\n        # Recursion step\n        for t in range(1, T):\n            for s in range(num_states):\n                # Calculate probabilities of transitioning from any previous state\n                trans_probs = viterbi_matrix[t-1, :] + log_trans_p[:, s]\n                \n                # Find the most likely path\n                best_prev_state = np.argmax(trans_probs)\n                max_prob = trans_probs[best_prev_state]\n                \n                viterbi_matrix[t, s] = max_prob + log_emit_p[s, obs_seq[t]]\n                backpointer_matrix[t, s] = best_prev_state\n        \n        # Backtracking\n        path = [0] * T\n        path[T-1] = np.argmax(viterbi_matrix[T-1, :])\n        for t in range(T-2, -1, -1):\n            path[t] = backpointer_matrix[t+1, path[t+1]]\n            \n        return path\n\n    test_cases = [\n        # (original_sequence, operation, index, symbol)\n        (\"GCA\" * 12, \"ins\", 15, \"A\"),\n        (\"GCA\" * 10, \"ins\", 0, \"T\"),\n        (\"AT\" * 18, \"del\", 10, \"\"),\n    ]\n\n    results = []\n\n    for orig_seq_str, op, i, symbol in test_cases:\n        # Convert original sequence to observation indices\n        orig_obs = [obs_map[char] for char in orig_seq_str]\n        \n        # Generate mutated sequence\n        if op == \"ins\":\n            mut_seq_str = orig_seq_str[:i] + symbol + orig_seq_str[i:]\n        elif op == \"del\":\n            mut_seq_str = orig_seq_str[:i] + orig_seq_str[i+1:]\n        \n        mut_obs = [obs_map[char] for char in mut_seq_str]\n\n        # Run Viterbi on both sequences\n        path_orig = viterbi(orig_obs, len(states), log_pi, log_A, log_B)\n        path_mut = viterbi(mut_obs, len(states), log_pi, log_A, log_B)\n        \n        # Calculate frame-shift state divergence\n        mismatches = 0\n        L = len(orig_seq_str)\n        \n        if op == \"ins\":\n            num_comparisons = L\n            for j in range(L):\n                state_orig = path_orig[j]\n                if j  i:\n                    state_mut = path_mut[j]\n                else: # j >= i\n                    state_mut = path_mut[j+1]\n                if state_orig != state_mut:\n                    mismatches += 1\n        \n        elif op == \"del\":\n            num_comparisons = L - 1\n            for j in range(L):\n                if j == i:\n                    continue\n                state_orig = path_orig[j]\n                if j  i:\n                    state_mut = path_mut[j]\n                else: # j > i\n                    state_mut = path_mut[j-1]\n                if state_orig != state_mut:\n                    mismatches += 1\n        \n        divergence = mismatches / num_comparisons if num_comparisons > 0 else 0.0\n        results.append(divergence)\n\n    formatted_results = [\"{:.3f}\".format(r) for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "生物学很少有单一、明确的答案；像可变剪接这样的过程意味着一个基因可以有多种有效的结构。标准的维特比算法只给出单一的最佳路径，但如果存在其他几乎同样好的路径呢？这项高级实践将挑战您实现一个K-best维特比算法，以找到排名靠前的多个候选路径，从而为基因组数据提供更丰富、更符合生物学现实的解释。",
            "id": "2397588",
            "problem": "考虑一个定义在有限隐状态集和有限观测字母表上的离散隐马尔可夫模型 (HMM)。设隐状态根据其列出顺序以整数 $0$ 到 $n-1$ 索引，观测字母表为 $\\{A,C,G,T\\}$，其固定索引顺序为 $A \\mapsto 0$，$C \\mapsto 1$，$G \\mapsto 2$，$T \\mapsto 3$。一个 HMM 实例由以下部分指定：\n- 初始分布 $\\boldsymbol{\\pi} \\in [0,1]^n$，满足 $\\sum_{i=0}^{n-1} \\pi_i = 1$。\n- 状态转移矩阵 $\\mathbf{A} \\in [0,1]^{n \\times n}$，对每个 $i$ 满足 $\\sum_{j=0}^{n-1} A_{ij} = 1$。\n- 发射概率矩阵 $\\mathbf{B} \\in [0,1]^{n \\times 4}$，对每个 $i$ 满足 $\\sum_{x \\in \\{0,1,2,3\\}} B_{i,x} = 1$。\n- 观测序列 $O = (o_1,o_2,\\ldots,o_T)$，其中每个 $o_t \\in \\{A,C,G,T\\}$。\n\n对于任意隐状态路径 $S = (s_1,s_2,\\ldots,s_T)$，其中每个 $s_t \\in \\{0,1,\\ldots,n-1\\}$，其与观测序列的联合概率定义为\n$$\nP(S,O) \\;=\\; \\pi_{s_1}\\, B_{s_1,\\mathrm{idx}(o_1)} \\prod_{t=2}^{T} A_{s_{t-1},s_t}\\, B_{s_t,\\mathrm{idx}(o_t)},\n$$\n其中 $\\mathrm{idx}(A)=0, \\mathrm{idx}(C)=1, \\mathrm{idx}(G)=2, \\mathrm{idx}(T)=3$。\n\n对于下方的每个测试用例，请确定最多 $k$ 个最可能的隐状态序列 $S$（长度为 $T$），这些序列在给定的模型参数下最大化 $P(S,O)$。如果具有严格正概率的不同隐状态序列少于 $k$ 个，则仅输出那些具有正概率的序列。序列必须按 $P(S,O)$ 的非递增顺序排序。如果概率完全相同，则按状态索引序列的字典序来打破平局（例如，$(0,0,1)$ 在 $(0,1,0)$ 之前）。每个序列必须表示为对应于状态索引的整数列表。\n\n测试套件（五个用例）。在所有用例中，观测字母表顺序为 $[A,C,G,T]$，状态索引顺序如所列。\n\n- 用例 1（双状态基因/非基因模型，中等长度）：\n  - 状态（按顺序）：$[N,C]$。\n  - $\\boldsymbol{\\pi} = [\\,0.5,\\,0.5\\,]$。\n  - $\\mathbf{A} = \\begin{bmatrix} 0.9  0.1 \\\\ 0.1  0.9 \\end{bmatrix}$。\n  - $\\mathbf{B} = \\begin{bmatrix}\n    0.3  0.2  0.2  0.3 \\\\\n    0.15  0.35  0.35  0.15\n  \\end{bmatrix}$。\n  - $O = (A,T,G,C,G)$。\n  - $k = 3$。\n\n- 用例 2（三状态，仅起始长度，由起始分布主导）：\n  - 状态（按顺序）：$[N,C,R]$。\n  - $\\boldsymbol{\\pi} = [\\,0.7,\\,0.1,\\,0.2\\,]$。\n  - $\\mathbf{A} = \\begin{bmatrix}\n    0.8  0.1  0.1 \\\\\n    0.2  0.7  0.1 \\\\\n    0.2  0.2  0.6\n  \\end{bmatrix}$。\n  - $\\mathbf{B} = \\begin{bmatrix}\n    0.25  0.25  0.25  0.25 \\\\\n    0.1  0.4  0.4  0.1 \\\\\n    0.4  0.2  0.2  0.2\n  \\end{bmatrix}$。\n  - $O = (G)$。\n  - $k = 1$。\n\n- 用例 3（双状态，存在零转移，可达路径有限）：\n  - 状态（按顺序）：$[N,C]$。\n  - $\\boldsymbol{\\pi} = [\\,0.6,\\,0.4\\,]$。\n  - $\\mathbf{A} = \\begin{bmatrix} 1.0  0.0 \\\\ 0.2  0.8 \\end{bmatrix}$。\n  - $\\mathbf{B} = \\begin{bmatrix}\n    0.25  0.25  0.25  0.25 \\\\\n    0.1  0.4  0.4  0.1\n  \\end{bmatrix}$。\n  - $O = (C,G,C)$。\n  - $k = 5$。\n\n- 用例 4（双状态，短长度，$k$ 超过可能路径数）：\n  - 状态（按顺序）：$[N,C]$。\n  - $\\boldsymbol{\\pi} = [\\,0.5,\\,0.5\\,]$。\n  - $\\mathbf{A} = \\begin{bmatrix} 0.6  0.4 \\\\ 0.3  0.7 \\end{bmatrix}$。\n  - $\\mathbf{B} = \\begin{bmatrix}\n    0.4  0.1  0.1  0.4 \\\\\n    0.1  0.4  0.4  0.1\n  \\end{bmatrix}$。\n  - $O = (A,C)$。\n  - $k = 5$。\n\n- 用例 5（导致概率完全相同的双状态对称模型）：\n  - 状态（按顺序）：$[N,C]$。\n  - $\\boldsymbol{\\pi} = [\\,0.5,\\,0.5\\,]$。\n  - $\\mathbf{A} = \\begin{bmatrix} 0.5  0.5 \\\\ 0.5  0.5 \\end{bmatrix}$。\n  - $\\mathbf{B} = \\begin{bmatrix}\n    0.25  0.25  0.25  0.25 \\\\\n    0.25  0.25  0.25  0.25\n  \\end{bmatrix}$。\n  - $O = (T,A)$。\n  - $k = 3$。\n\n最终输出格式：您的程序应生成单行输出，包含一个长度为 5 的列表，其中第 $i$ 个元素对应于用例 $i$，其本身是一个包含最多 $k$ 个序列的列表。每个序列表示为一个整数（状态索引）列表。最外层的容器必须是一个单行字符串，格式为用方括号括起来的逗号分隔列表，例如 $[\\,[\\ldots],[\\ldots],\\ldots\\,]$；不应包含任何额外的文本或空白。例如，一个有效的结构示例是 $[[[0,1,1],[1,1,1]],[[2]]]$。",
            "solution": "我们从第一性原理出发对问题进行形式化。一个定义在状态 $\\{0,1,\\ldots,n-1\\}$ 和观测值 $\\{A,C,G,T\\}$ 上的离散隐马尔可夫模型 (HMM) 由一个初始分布 $\\boldsymbol{\\pi}$、一个转移矩阵 $\\mathbf{A}$ 和一个发射矩阵 $\\mathbf{B}$ 指定。对于一个观测序列 $O=(o_1,\\ldots,o_T)$，任意隐状态路径 $S=(s_1,\\ldots,s_T)$ 与观测值的联合概率由下式给出\n$$\nP(S,O) \\;=\\; \\pi_{s_1}\\, B_{s_1,\\mathrm{idx}(o_1)} \\prod_{t=2}^{T} A_{s_{t-1},s_t}\\, B_{s_t,\\mathrm{idx}(o_t)}.\n$$\n因为 $O$ 是固定的，最大化关于 $S$ 的后验概率 $P(S \\mid O)$ 等价于最大化 $P(S,O)$，因为 $P(S\\mid O) \\propto P(S,O)$，且比例常数与 $S$ 无关。因此，为了获得 $k$ 个最可能的隐状态序列，我们必须将所有长度为 $T$ 的状态序列按 $P(S,O)$ 排序，并选择前 $k$ 个具有严格正概率的序列，在出现平局时应用索引序列的字典序规则。\n\n直接枚举的复杂度为 $n^T$，这在通常情况下是不可行的。作为替代，我们使用基于马尔可夫性质的动态规划来构建最优的部分路径。为了数值稳定性，我们在对数域中进行操作。定义\n$$\n\\ell\\pi_i \\;=\\; \\log \\pi_i,\\quad \\ell A_{ij} \\;=\\; \\log A_{ij},\\quad \\ell B_{i,x} \\;=\\; \\log B_{i,x},\n$$\n并约定 $\\log 0 = -\\infty$（从而有效地排除了零概率事件）。对于在时间 $t$ 结束于状态 $j$ 的前缀，任意部分路径 $(s_1,\\ldots,s_t=j)$ 的对数联合概率为\n$$\nL(s_1,\\ldots,s_t=j) \\;=\\; \\ell\\pi_{s_1} + \\ell B_{s_1,\\mathrm{idx}(o_1)} + \\sum_{\\tau=2}^{t} \\left(\\ell A_{s_{\\tau-1},s_\\tau} + \\ell B_{s_\\tau,\\mathrm{idx}(o_\\tau)}\\right).\n$$\n为了在每个时间点为每个结束状态获得前 $k$ 个序列，我们递归地将前一时间步的前 $k$ 个部分序列与所有可能的下一个状态组合起来。具体来说，对于 $t=1$（第一个观测），对每个状态 $j$，我们创建一个至多一个候选 $(L, [j])$，其中\n$$\nL \\;=\\; \\ell\\pi_j + \\ell B_{j,\\mathrm{idx}(o_1)},\n$$\n前提是该值是有限的。我们为每个 $j$ 保留最多前 $k$ 个候选（在 $t=1$ 时，每个 $j$ 最多只有一个）。\n\n对于 $t \\ge 2$ 和每个状态 $j$，我们构建候选集\n$$\n\\mathcal{C}_j^{(t)} \\;=\\; \\left\\{ \\left(L' + \\ell A_{i,j} + \\ell B_{j,\\mathrm{idx}(o_t)},\\, \\mathrm{concat}(P',[j])\\right) \\,:\\, (L',P') \\in \\mathcal{K}_i^{(t-1)} \\text{ and } \\ell A_{i,j}  -\\infty \\right\\},\n$$\n其中 $\\mathcal{K}_i^{(t-1)}$ 表示先前保留的、在时间 $t-1$ 结束于状态 $i$ 的前 $k$ 个部分路径，每个路径表示为一个（对数概率，索引序列）对。从 $\\mathcal{C}_j^{(t)}$ 中，我们选择最多 $k$ 个具有最大对数概率的元素，并按索引序列的字典序来打破平局。这便得到了 $\\mathcal{K}_j^{(t)}$。\n\n在最终时间 $T$，我们将所有结束状态的候选汇集起来：\n$$\n\\mathcal{C}^{(T)} \\;=\\; \\bigcup_{j=0}^{n-1} \\mathcal{K}_j^{(T)},\n$$\n并根据相同的排序规则选择全局前 $k$ 个。任何对数概率为 $-\\infty$ 的候选都将被排除，因为它对应于零概率。\n\n这个过程的合理性在于马尔可夫性质所固有的最优子结构：任何在时间 $t$ 结束于状态 $j$ 的最优路径，都由一个在时间 $t-1$ 结束于某个前驱状态 $i$ 的最优部分路径，加上转移 $i \\to j$ 和在 $t$ 时的发射所组成。为每个结束状态维护 $k$ 条最佳部分路径，保留了构建 $k$ 条最佳完整路径所需的所有信息，因为任何完整路径都必须在某个状态结束，而组合步骤探索了所有的前驱-后继对。\n\n通过使用键 $(-L,\\,P)$ 对候选进行排序，可以使平局处理具有确定性，其中 $L$ 是对数概率， $P$ 是索引序列；这会产生概率的非递增顺序，并在平局中按字典序排序。\n\n将此构造应用于五个指定的用例中的每一个，为每个用例生成最多 $k$ 个状态索引序列（每个观测符号对应一个索引），这些序列按 $P(S,O)$ 的非递增顺序排序，并在平局时按字典序排序。用例 2 因为 $T=1$ 而简化为选择 $\\arg\\max_i \\pi_i B_{i,\\mathrm{idx}(G)}$。用例 5 是对称的：所有四个长度为 2 的序列具有相同的概率，因此前 $k=3$ 个序列是索引序列按字典序排列的前三个。用例 3 和 4 演示了如何处理零转移概率以及 $k$ 超过不同正概率路径数量的情况；只有联合概率严格为正的序列才会按非递增概率顺序列出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef log_safe(x):\n    \"\"\"Return natural log, with -inf for non-positive.\"\"\"\n    with np.errstate(divide='ignore'):\n        return np.log(x) if x > 0.0 else -np.inf\n\ndef top_k_paths(pi, A, B, obs_seq, k, alphabet_index):\n    \"\"\"\n    Compute up to k most probable hidden-state sequences for a given HMM and observation sequence.\n    - pi: shape (n,)\n    - A: shape (n, n)\n    - B: shape (n, m)\n    - obs_seq: string over alphabet symbols present in alphabet_index\n    - k: integer\n    - alphabet_index: dict mapping symbol -> column index in B\n    Returns: list of (log_prob, path_list_of_ints), ordered by nonincreasing log_prob and lexicographic path.\n    \"\"\"\n    n = pi.shape[0]\n    T = len(obs_seq)\n    # Precompute log-probabilities\n    log_pi = np.array([log_safe(v) for v in pi], dtype=float)\n    log_A = np.array([[log_safe(A[i, j]) for j in range(n)] for i in range(n)], dtype=float)\n    m = B.shape[1]\n    log_B = np.array([[log_safe(B[i, x]) for x in range(m)] for i in range(n)], dtype=float)\n\n    if T == 0:\n        return []  # No observations: no paths required in this problem setting.\n\n    # Initialize for t = 0\n    o0 = alphabet_index[obs_seq[0]]\n    per_state = [[] for _ in range(n)]  # For each state, list of (log_prob, path)\n    for j in range(n):\n        lp = log_pi[j] + log_B[j, o0]\n        if np.isfinite(lp):\n            per_state[j].append((lp, [j]))\n        # Keep only up to k (at most one here)\n        per_state[j] = select_top_k(per_state[j], k)\n\n    # Recursion for t = 1..T-1\n    for t in range(1, T):\n        ot = alphabet_index[obs_seq[t]]\n        next_per_state = [[] for _ in range(n)]\n        for j in range(n):\n            candidates = []\n            # Consider all predecessors i and their top-k paths\n            for i in range(n):\n                if len(per_state[i]) == 0:\n                    continue\n                if not np.isfinite(log_A[i, j]):\n                    continue  # impossible transition\n                for (lp_prev, path_prev) in per_state[i]:\n                    lp_new = lp_prev + log_A[i, j] + log_B[j, ot]\n                    if np.isfinite(lp_new):\n                        candidates.append((lp_new, path_prev + [j]))\n            # Select top k for state j at time t\n            next_per_state[j] = select_top_k(candidates, k)\n        per_state = next_per_state\n\n    # Collect all end-state candidates\n    all_candidates = []\n    for j in range(n):\n        all_candidates.extend(per_state[j])\n\n    # Select global top k\n    top_global = select_top_k(all_candidates, k)\n    return top_global\n\ndef select_top_k(candidates, k):\n    \"\"\"Select top k by log-prob (desc), breaking ties by lexicographic path (asc).\"\"\"\n    # Sort using key: (-log_prob, path)\n    # Paths are lists of ints; Python list comparison is lexicographic.\n    candidates_sorted = sorted(candidates, key=lambda item: (-item[0], item[1]))\n    # Remove exact duplicate paths if any (keeping the first occurrence, which has highest prob)\n    seen = set()\n    unique = []\n    for lp, path in candidates_sorted:\n        key = tuple(path)\n        if key in seen:\n            continue\n        seen.add(key)\n        unique.append((lp, path))\n        if len(unique) >= k:\n            break\n    return unique\n\ndef format_nested_list(obj):\n    \"\"\"\n    Serialize nested lists (of ints/floats) to a compact string without spaces.\n    Floats are formatted with full precision from str().\n    \"\"\"\n    if isinstance(obj, list):\n        return \"[\" + \",\".join(format_nested_list(x) for x in obj) + \"]\"\n    elif isinstance(obj, bool):\n        return \"True\" if obj else \"False\"\n    elif isinstance(obj, (int, np.integer)):\n        return str(int(obj))\n    elif isinstance(obj, float):\n        # Ensure standard float representation\n        return str(obj)\n    else:\n        # Fallback for numpy types\n        if isinstance(obj, np.floating):\n            return str(float(obj))\n        elif isinstance(obj, np.bool_):\n            return \"True\" if bool(obj) else \"False\"\n        else:\n            # Should not happen; but convert to string safely\n            return str(obj)\n\ndef solve():\n    # Define the observation alphabet mapping\n    alphabet_index = {'A': 0, 'C': 1, 'G': 2, 'T': 3}\n\n    # Test cases as specified in the problem statement.\n\n    # Case 1\n    pi1 = np.array([0.5, 0.5], dtype=float)\n    A1 = np.array([[0.9, 0.1],\n                   [0.1, 0.9]], dtype=float)\n    B1 = np.array([[0.3, 0.2, 0.2, 0.3],\n                   [0.15, 0.35, 0.35, 0.15]], dtype=float)\n    O1 = \"ATGCG\"\n    k1 = 3\n\n    # Case 2\n    pi2 = np.array([0.7, 0.1, 0.2], dtype=float)\n    A2 = np.array([[0.8, 0.1, 0.1],\n                   [0.2, 0.7, 0.1],\n                   [0.2, 0.2, 0.6]], dtype=float)\n    B2 = np.array([[0.25, 0.25, 0.25, 0.25],\n                   [0.1, 0.4, 0.4, 0.1],\n                   [0.4, 0.2, 0.2, 0.2]], dtype=float)\n    O2 = \"G\"\n    k2 = 1\n\n    # Case 3\n    pi3 = np.array([0.6, 0.4], dtype=float)\n    A3 = np.array([[1.0, 0.0],\n                   [0.2, 0.8]], dtype=float)\n    B3 = np.array([[0.25, 0.25, 0.25, 0.25],\n                   [0.1, 0.4, 0.4, 0.1]], dtype=float)\n    O3 = \"CGC\"\n    k3 = 5\n\n    # Case 4\n    pi4 = np.array([0.5, 0.5], dtype=float)\n    A4 = np.array([[0.6, 0.4],\n                   [0.3, 0.7]], dtype=float)\n    B4 = np.array([[0.4, 0.1, 0.1, 0.4],\n                   [0.1, 0.4, 0.4, 0.1]], dtype=float)\n    O4 = \"AC\"\n    k4 = 5\n\n    # Case 5\n    pi5 = np.array([0.5, 0.5], dtype=float)\n    A5 = np.array([[0.5, 0.5],\n                   [0.5, 0.5]], dtype=float)\n    B5 = np.array([[0.25, 0.25, 0.25, 0.25],\n                   [0.25, 0.25, 0.25, 0.25]], dtype=float)\n    O5 = \"TA\"\n    k5 = 3\n\n    test_cases = [\n        (pi1, A1, B1, O1, k1),\n        (pi2, A2, B2, O2, k2),\n        (pi3, A3, B3, O3, k3),\n        (pi4, A4, B4, O4, k4),\n        (pi5, A5, B5, O5, k5),\n    ]\n\n    results = []\n    for pi, A, B, O, k in test_cases:\n        topk = top_k_paths(pi, A, B, O, k, alphabet_index)\n        # Extract only the paths (list of lists of ints)\n        paths_only = [path for (_lp, path) in topk]\n        results.append(paths_only)\n\n    # Final print statement in the exact required format: single line, no extra whitespace.\n    print(format_nested_list(results))\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}