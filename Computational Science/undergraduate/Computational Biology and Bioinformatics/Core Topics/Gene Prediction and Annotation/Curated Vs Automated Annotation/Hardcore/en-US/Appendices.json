{
    "hands_on_practices": [
        {
            "introduction": "Automated annotation pipelines generate hypotheses about gene function on a massive scale, but their reliability can vary. A critical task in bioinformatics is to perform quality control by flagging annotations that are likely to be incorrect. This exercise simulates this process by asking you to develop a quantitative \"inconsistency score\" that integrates diverse lines of evidence—such as sequence homology, protein domain content, and enzymatic function—to build a case for or against an automated prediction. By completing this practice, you will gain insight into how computational systems can prioritize annotations for review by human experts, a cornerstone of the interplay between automated and curated annotation systems .",
            "id": "2383758",
            "problem": "You are evaluating the reliability of an automated protein function annotation in the context of curated versus automated annotation. For each protein, you are given abstracted, database-derived evidence that can be represented as numerical and set-theoretic objects. Define a quantitative inconsistency score using first principles and decide whether the automated annotation should be flagged for curator review. Additionally, provide a minimal justification code list identifying which evidence streams independently support the decision to flag.\n\nLet the automated label be denoted by $\\mathcal{L}_a$ (no specific structure of $\\mathcal{L}_a$ is used beyond equality comparisons). For each protein instance, you are provided the following inputs:\n\n- Weighted homology agreement list: $N = [(w_1,a_1),\\ldots,(w_k,a_k)]$, where each $w_i \\in [0,1]$ and $\\sum_{i=1}^k w_i = 1$, and where $a_i \\in \\{0,1\\}$ indicates whether the $i$-th nearest homolog’s curated function agrees with $\\mathcal{L}_a$ ($a_i=1$) or not ($a_i=0$).\n- InterPro-like domain support counts: $(s_{\\text{supp}}, s_{\\text{conf}}) \\in \\mathbb{N}_0 \\times \\mathbb{N}_0$, where $s_{\\text{supp}}$ is the number of domains supporting $\\mathcal{L}_a$ and $s_{\\text{conf}}$ is the number of domains contradicting $\\mathcal{L}_a$.\n- Enzyme Commission (EC) evidence sets: $A$ is the set of EC identifiers predicted by the automated pipeline; $C$ is the set of EC identifiers observed in curated databases for homologs under stringent criteria. Each EC identifier is a $4$-tuple of integers, e.g., $(1,1,1,1)$.\n- Localization mismatch indicator: $l \\in \\{0,1\\}$, where $l=1$ if the predicted subcellular localization is inconsistent with the curated localization distribution for proteins annotated with $\\mathcal{L}_a$, and $l=0$ otherwise.\n- Taxonomic constraint violation: $t \\in \\{0,1\\}$, where $t=1$ if $\\mathcal{L}_a$ violates known taxonomic constraints (e.g., the function is not known in the given lineage), and $t=0$ otherwise.\n- Name-based red flag: $n \\in \\{0,1\\}$, where $n=1$ if the automated name contains terms that curators avoid for specific functions (for example, “hypothetical protein” or “putative” when a highly specific $\\mathcal{L}_a$ is claimed), and $n=0$ otherwise.\n\nDefine the following quantities from first principles:\n\n1. Weighted homology disagreement:\n$$\nh = \\sum_{i=1}^{k} w_i \\cdot (1 - a_i).\n$$\n\n2. Domain contradiction ratio:\n$$\nd = \\begin{cases}\n0, & \\text{if } s_{\\text{supp}} + s_{\\text{conf}} = 0 \\\\\n\\frac{s_{\\text{conf}}}{s_{\\text{supp}} + s_{\\text{conf}}}, & \\text{otherwise}\n\\end{cases}\n$$\n\n3. Enzyme Commission mismatch (Jaccard distance on sets of EC identifiers):\n$$\ne = \\begin{cases}\n0, & \\text{if } |A \\cup C| = 0 \\\\\n1 - \\frac{|A \\cap C|}{|A \\cup C|}, & \\text{otherwise}\n\\end{cases}\n$$\n\n4. Use $l$, $t$, and $n$ as defined above.\n\nDefine the inconsistency score $S$ as a convex combination of these terms:\n$$\nS = \\alpha h + \\beta d + \\gamma e + \\delta l + \\zeta t + \\eta n,\n$$\nwith weights fixed as\n$$\n\\alpha = 0.3,\\quad \\beta = 0.25,\\quad \\gamma = 0.2,\\quad \\delta = 0.1,\\quad \\zeta = 0.1,\\quad \\eta = 0.05.\n$$\n\nDecision rule: flag the automated annotation as potentially wrong if and only if\n$$\nS \\ge \\tau,\n$$\nwith threshold $\\tau = 0.5$.\n\nJustification codes: provide a minimal set $J$ of integer codes indicating which independent evidence streams individually support flagging, using the following criteria:\n\n- Code $1$: include if $h \\ge 0.5$.\n- Code $2$: include if $d \\ge 0.5$.\n- Code $3$: include if $e \\ge 0.5$.\n- Code $4$: include if $l = 1$.\n- Code $5$: include if $t = 1$.\n- Code $6$: include if $n = 1$.\n\nYour task is to compute, for each test case below, the triple $[s,f,j]$, where $s$ is the value of $S$ rounded to four decimal places as a decimal number, $f$ is the boolean decision according to the rule above, and $j$ is the justification code list in increasing order. There are no physical units involved. Angles are not used. All numeric answers must be decimals. Booleans must be printed as the literals True or False.\n\nTest suite (five cases):\n\n- Case $1$:\n  - $N = [(0.4,0),(0.3,0),(0.2,1),(0.1,0)]$.\n  - $(s_{\\text{supp}}, s_{\\text{conf}}) = (1,3)$.\n  - $A = \\{(1,1,1,1)\\}$, $C = \\{(2,7,1,1),(1,1,1,2)\\}$.\n  - $l = 1$, $t = 1$, $n = 0$.\n\n- Case $2$:\n  - $N = [(0.5,1),(0.2,1),(0.2,1),(0.1,1)]$.\n  - $(s_{\\text{supp}}, s_{\\text{conf}}) = (4,0)$.\n  - $A = \\{(3,5,1,4)\\}$, $C = \\{(3,5,1,4)\\}$.\n  - $l = 0$, $t = 0$, $n = 0$.\n\n- Case $3$:\n  - $N = [(0.6,1),(0.4,0)]$.\n  - $(s_{\\text{supp}}, s_{\\text{conf}}) = (0,0)$.\n  - $A = \\varnothing$, $C = \\varnothing$.\n  - $l = 1$, $t = 0$, $n = 0$.\n\n- Case $4$:\n  - $N = [(0.5,0),(0.3,1),(0.2,1)]$.\n  - $(s_{\\text{supp}}, s_{\\text{conf}}) = (3,2)$.\n  - $A = \\{(1,2,3,4),(2,3,4,5),(3,4,5,6)\\}$,\n    $C = \\{(1,2,3,4),(2,3,4,5),(3,4,5,6),(9,9,9,9)\\}$.\n  - $l = 1$, $t = 1$, $n = 0$.\n\n- Case $5$:\n  - $N = [(0.7,1),(0.2,1),(0.1,1)]$.\n  - $(s_{\\text{supp}}, s_{\\text{conf}}) = (0,5)$.\n  - $A = \\{(1,1,1,1),(2,2,2,2)\\}$, $C = \\{(1,1,1,1),(2,2,2,3)\\}$.\n  - $l = 1$, $t = 0$, $n = 1$.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each test case, output the triple $[s,f,j]$ where $s$ is rounded to four decimal places, $f$ is a boolean literal, and $j$ is the list of justification codes in increasing order. For example, the overall output must look like\n$[[s_1,f_1,j_1],[s_2,f_2,j_2],\\ldots,[s_5,f_5,j_5]]$ in one single line with no additional text.",
            "solution": "The problem statement is subjected to validation.\n\n**Step 1: Extract Givens**\n\nThe givens are:\n- A weighted homology agreement list $N = [(w_1,a_1),\\ldots,(w_k,a_k)]$ where $w_i \\in [0,1]$, $\\sum_{i=1}^k w_i = 1$, and $a_i \\in \\{0,1\\}$.\n- Domain support counts $(s_{\\text{supp}}, s_{\\text{conf}}) \\in \\mathbb{N}_0 \\times \\mathbb{N}_0$.\n- Enzyme Commission (EC) evidence sets $A$ and $C$, where elements are $4$-tuples of integers.\n- Binary indicators for localization mismatch ($l$), taxonomic violation ($t$), and name-based red flag ($n$), all in $\\{0,1\\}$.\n- Definitions for intermediate scores:\n  - Weighted homology disagreement: $h = \\sum_{i=1}^{k} w_i \\cdot (1 - a_i)$.\n  - Domain contradiction ratio: $d = \\frac{s_{\\text{conf}}}{s_{\\text{supp}} + s_{\\text{conf}}}$ if $s_{\\text{supp}} + s_{\\text{conf}} \\neq 0$, and $d=0$ otherwise.\n  - Enzyme Commission mismatch (Jaccard distance): $e = 1 - \\frac{|A \\cap C|}{|A \\cup C|}$ if $|A \\cup C| \\neq 0$, and $e=0$ otherwise.\n- The total inconsistency score $S$ is a convex combination: $S = \\alpha h + \\beta d + \\gamma e + \\delta l + \\zeta t + \\eta n$.\n- The weights are fixed: $\\alpha = 0.3$, $\\beta = 0.25$, $\\gamma = 0.2$, $\\delta = 0.1$, $\\zeta = 0.1$, $\\eta = 0.05$. These sum to $1$.\n- The decision rule is to flag the annotation if $S \\ge \\tau$, with threshold $\\tau = 0.5$.\n- The justification code list $J$ is a minimal set of codes $\\{1,2,3,4,5,6\\}$ corresponding to individual evidence streams meeting their respective thresholds: $h \\ge 0.5$, $d \\ge 0.5$, $e \\ge 0.5$, $l=1$, $t=1$, $n=1$.\n- Five specific test cases with all necessary input data are provided.\n\n**Step 2: Validate Using Extracted Givens**\n\nThe problem is evaluated against the validation criteria:\n- **Scientifically Grounded**: The problem constructs a heuristic scoring model based on standard evidence types used in bioinformatics for protein function annotation (homology, protein domains, EC numbers, localization, taxonomy). The mathematical formulation, using weighted sums and Jaccard distance, is conventional and appropriate for such a model. It is a simplified but scientifically plausible abstraction.\n- **Well-Posed**: The problem is deterministic and self-contained. All variables, constants, functions, and decision rules are defined unambiguously. The input for each test case is complete. This ensures that a unique and stable solution can be computed.\n- **Objective**: The problem is stated in precise mathematical and logical terms, free from subjectivity or ambiguity.\n\nThe problem exhibits no flaws. It is not scientifically unsound, non-formalizable, incomplete, contradictory, unrealistic, or ill-posed.\n\n**Step 3: Verdict and Action**\n\nThe problem is **valid**. A complete solution will be provided.\n\n**Solution Derivation**\n\nThe task is to compute the triple $[s, f, j]$ for each of the five test cases, where $s$ is the score $S$ rounded to four decimal places, $f$ is the boolean flag decision, and $j$ is the sorted list of justification codes. The calculation for each case proceeds as follows.\n\n**Case 1:**\n- Inputs: $N = [(0.4,0),(0.3,0),(0.2,1),(0.1,0)]$, $(s_{\\text{supp}}, s_{\\text{conf}}) = (1,3)$, $A = \\{(1,1,1,1)\\}$, $C = \\{(2,7,1,1),(1,1,1,2)\\}$, $l = 1$, $t = 1$, $n = 0$.\n- $h = 0.4(1-0) + 0.3(1-0) + 0.2(1-1) + 0.1(1-0) = 0.4 + 0.3 + 0.0 + 0.1 = 0.8$.\n- $d = \\frac{3}{1+3} = 0.75$.\n- $A \\cap C = \\varnothing$, so $|A \\cap C| = 0$. $A \\cup C = \\{(1,1,1,1), (2,7,1,1), (1,1,1,2)\\}$, so $|A \\cup C| = 3$.\n- $e = 1 - \\frac{0}{3} = 1.0$.\n- $S = 0.3(0.8) + 0.25(0.75) + 0.2(1.0) + 0.1(1) + 0.1(1) + 0.05(0) = 0.24 + 0.1875 + 0.2 + 0.1 + 0.1 = 0.8275$.\n- $s = 0.8275$. Since $S=0.8275 \\ge 0.5$, $f=\\text{True}$.\n- Justification codes: $h=0.8 \\ge 0.5$ (Code $1$), $d=0.75 \\ge 0.5$ (Code $2$), $e=1.0 \\ge 0.5$ (Code $3$), $l=1$ (Code $4$), $t=1$ (Code $5$). $j = [1, 2, 3, 4, 5]$.\n- Result: $[0.8275, \\text{True}, [1, 2, 3, 4, 5]]$.\n\n**Case 2:**\n- Inputs: $N = [(0.5,1),(0.2,1),(0.2,1),(0.1,1)]$, $(s_{\\text{supp}}, s_{\\text{conf}}) = (4,0)$, $A = \\{(3,5,1,4)\\}$, $C = \\{(3,5,1,4)\\}$, $l = 0$, $t = 0$, $n = 0$.\n- All $a_i=1$, so $h = 0$.\n- $s_{\\text{conf}}=0$, so $d = \\frac{0}{4+0} = 0$.\n- $A \\cap C = A = C$, so $|A \\cap C|=1$ and $|A \\cup C|=1$.\n- $e = 1 - \\frac{1}{1} = 0$.\n- $l=0$, $t=0$, $n=0$.\n- All terms are $0$, thus $S = 0$.\n- $s = 0.0000$. Since $S=0 < 0.5$, $f=\\text{False}$.\n- Justification codes: None of the criteria are met. $j = []$.\n- Result: $[0.0000, \\text{False}, []]$.\n\n**Case 3:**\n- Inputs: $N = [(0.6,1),(0.4,0)]$, $(s_{\\text{supp}}, s_{\\text{conf}}) = (0,0)$, $A = \\varnothing$, $C = \\varnothing$, $l = 1$, $t = 0$, $n = 0$.\n- $h = 0.6(1-1) + 0.4(1-0) = 0.4$.\n- $s_{\\text{supp}} + s_{\\text{conf}} = 0$, so $d=0$.\n- $|A \\cup C| = 0$, so $e=0$.\n- $S = 0.3(0.4) + 0.25(0) + 0.2(0) + 0.1(1) + 0.1(0) + 0.05(0) = 0.12 + 0.1 = 0.22$.\n- $s = 0.2200$. Since $S=0.22 < 0.5$, $f=\\text{False}$.\n- Justification codes: only $l=1$ meets its criterion (Code $4$). $j = [4]$.\n- Result: $[0.2200, \\text{False}, [4]]$.\n\n**Case 4:**\n- Inputs: $N = [(0.5,0),(0.3,1),(0.2,1)]$, $(s_{\\text{supp}}, s_{\\text{conf}}) = (3,2)$, $A = \\{(1,2,3,4),(2,3,4,5),(3,4,5,6)\\}$, $C = \\{(1,2,3,4),(2,3,4,5),(3,4,5,6),(9,9,9,9)\\}$, $l = 1$, $t = 1$, $n = 0$.\n- $h = 0.5(1-0) + 0.3(1-1) + 0.2(1-1) = 0.5$.\n- $d = \\frac{2}{3+2} = 0.4$.\n- $|A|=3$, $|C|=4$. $A \\subset C$. So $|A \\cap C| = 3$ and $|A \\cup C|=4$.\n- $e = 1 - \\frac{3}{4} = 0.25$.\n- $S = 0.3(0.5) + 0.25(0.4) + 0.2(0.25) + 0.1(1) + 0.1(1) + 0.05(0) = 0.15 + 0.1 + 0.05 + 0.1 + 0.1 = 0.5$.\n- $s = 0.5000$. Since $S=0.5 \\ge 0.5$, $f=\\text{True}$.\n- Justification codes: $h=0.5 \\ge 0.5$ (Code $1$), $l=1$ (Code $4$), $t=1$ (Code $5$). $j = [1, 4, 5]$.\n- Result: $[0.5000, \\text{True}, [1, 4, 5]]$.\n\n**Case 5:**\n- Inputs: $N = [(0.7,1),(0.2,1),(0.1,1)]$, $(s_{\\text{supp}}, s_{\\text{conf}}) = (0,5)$, $A = \\{(1,1,1,1),(2,2,2,2)\\}$, $C = \\{(1,1,1,1),(2,2,2,3)\\}$, $l = 1$, $t = 0$, $n = 1$.\n- All $a_i=1$, so $h = 0$.\n- $d = \\frac{5}{0+5} = 1.0$.\n- $A \\cap C = \\{(1,1,1,1)\\}$, so $|A \\cap C| = 1$. $A \\cup C = \\{(1,1,1,1),(2,2,2,2),(2,2,2,3)\\}$, so $|A \\cup C|=3$.\n- $e = 1 - \\frac{1}{3} \\approx 0.3333...$\n- $S = 0.3(0) + 0.25(1.0) + 0.2(1/3) + 0.1(1) + 0.1(0) + 0.05(1) = 0.25 + 0.0666... + 0.1 + 0.05 = 0.4 + 1/15 \\approx 0.4666...$\n- $s = 0.4667$. Since $S \\approx 0.4667 < 0.5$, $f=\\text{False}$.\n- Justification codes: $d=1.0 \\ge 0.5$ (Code $2$), $l=1$ (Code $4$), $n=1$ (Code $6$). $j = [2, 4, 6]$.\n- Result: $[0.4667, \\text{False}, [2, 4, 6]]$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of evaluating automated protein function annotation reliability.\n    \"\"\"\n    \n    # Weights for the inconsistency score\n    weights = {\n        'alpha': 0.3,\n        'beta': 0.25,\n        'gamma': 0.2,\n        'delta': 0.1,\n        'zeta': 0.1,\n        'eta': 0.05\n    }\n    \n    # Decision threshold\n    tau = 0.5\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        {\n            'N': [(0.4, 0), (0.3, 0), (0.2, 1), (0.1, 0)],\n            's_counts': (1, 3),\n            'A': {(1, 1, 1, 1)},\n            'C': {(2, 7, 1, 1), (1, 1, 1, 2)},\n            'l': 1, 't': 1, 'n': 0\n        },\n        # Case 2\n        {\n            'N': [(0.5, 1), (0.2, 1), (0.2, 1), (0.1, 1)],\n            's_counts': (4, 0),\n            'A': {(3, 5, 1, 4)},\n            'C': {(3, 5, 1, 4)},\n            'l': 0, 't': 0, 'n': 0\n        },\n        # Case 3\n        {\n            'N': [(0.6, 1), (0.4, 0)],\n            's_counts': (0, 0),\n            'A': set(),\n            'C': set(),\n            'l': 1, 't': 0, 'n': 0\n        },\n        # Case 4\n        {\n            'N': [(0.5, 0), (0.3, 1), (0.2, 1)],\n            's_counts': (3, 2),\n            'A': {(1, 2, 3, 4), (2, 3, 4, 5), (3, 4, 5, 6)},\n            'C': {(1, 2, 3, 4), (2, 3, 4, 5), (3, 4, 5, 6), (9, 9, 9, 9)},\n            'l': 1, 't': 1, 'n': 0\n        },\n        # Case 5\n        {\n            'N': [(0.7, 1), (0.2, 1), (0.1, 1)],\n            's_counts': (0, 5),\n            'A': {(1, 1, 1, 1), (2, 2, 2, 2)},\n            'C': {(1, 1, 1, 1), (2, 2, 2, 3)},\n            'l': 1, 't': 0, 'n': 1\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        # 1. Weighted homology disagreement (h)\n        h = sum(w * (1 - a) for w, a in case['N'])\n\n        # 2. Domain contradiction ratio (d)\n        s_supp, s_conf = case['s_counts']\n        s_total = s_supp + s_conf\n        d = s_conf / s_total if s_total > 0 else 0\n\n        # 3. Enzyme Commission mismatch (e)\n        A, C = case['A'], case['C']\n        union_size = len(A.union(C))\n        intersection_size = len(A.intersection(C))\n        e = 1 - (intersection_size / union_size) if union_size > 0 else 0\n\n        # 4. Other indicators (l, t, n)\n        l, t, n = case['l'], case['t'], case['n']\n\n        # Calculate inconsistency score S\n        S = (weights['alpha'] * h +\n             weights['beta'] * d +\n             weights['gamma'] * e +\n             weights['delta'] * l +\n             weights['zeta'] * t +\n             weights['eta'] * n)\n\n        # Decision rule\n        f = S >= tau\n        \n        # Justification codes\n        j = []\n        if h >= 0.5:\n            j.append(1)\n        if d >= 0.5:\n            j.append(2)\n        if e >= 0.5:\n            j.append(3)\n        if l == 1:\n            j.append(4)\n        if t == 1:\n            j.append(5)\n        if n == 1:\n            j.append(6)\n        \n        # Store the result triple\n        s = round(S, 4)\n        results.append([s, f, j])\n\n    # Final print statement in the exact required format.\n    result_strings = []\n    for s_val, f_val, j_val in results:\n        # Format the float to 4 decimal places even if integer-like (e.g., 0.5000)\n        s_str = f\"{s_val:.4f}\"\n        result_strings.append(f\"[{s_str},{f_val},{j_val}]\")\n    \n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Beyond assessing conflicting evidence, we can sometimes identify an erroneous annotation because it violates fundamental biological principles. This exercise demonstrates how to formalize such a \"sanity check\" using an evolutionary framework. You will use the principle of parsimony on a species tree to calculate the plausibility of a functional annotation. This practice highlights how deep biological context can be used to automatically reject biologically impossible claims, such as a human protein being involved in photosynthesis, providing a powerful layer of validation that complements feature-based scoring .",
            "id": "2383796",
            "problem": "An automated annotation pipeline assigns a human protein the function string \"chlorophyll biosynthesis\". Design and implement a phylogenetically informed sanity-check algorithm that flags such function assignments as implausible using only curated presence sets of functions over a rooted species tree and the parsimony principle of minimizing state changes on that tree.\n\nBase facts to use: evolution by common descent implies that traits and gene functions are inherited along a species tree; the Central Dogma of Molecular Biology (Deoxyribonucleic Acid to Ribonucleic Acid to protein) constrains that gene functions map to organismal capabilities; parsimony (Occam’s razor) posits that among alternative evolutionary reconstructions, those with fewer state changes are preferred. No other specialized formulas are to be assumed.\n\nMathematical formalization: Let the rooted tree be denoted by $T$, with leaves labeled by species names. For a biological function $f$, let $P_f \\subseteq L(T)$ denote the curated set of leaves known to possess $f$ from expert curation. Define a binary character on $L(T)$ by assigning state $1$ to leaves in $P_f$ and state $0$ to all other leaves. For any such assignment, let $C(P_f)$ denote the minimal number of state changes (gains or losses) required to explain the observed states on $T$ under Fitch parsimony. For a proposed annotation claiming that species $q \\in L(T)$ has function $f$, define the phylogenetic inconsistency score\n$$D(q,f) = C\\big(P_f \\cup \\{q\\}\\big) - C(P_f).$$\nIntuitively, $D(q,f)$ is the extra number of changes the tree must endure to accommodate the claim. The sanity-check rule is: flag the annotation as implausible if and only if $D(q,f) \\ge \\tau$, for the threshold $\\tau = 1$.\n\nYour task: implement a complete program that, given $T$, the curated presence sets $P_f$ for several functions, and a list of query annotations $(q,f)$, computes $D(q,f)$ by Fitch parsimony and returns a boolean flag per query according to the rule above.\n\nTree topology $T$ (rooted, directed from parent to children, leaves are those with no children):\n\n- \"root\" has children \"bacteria\", \"archaea\", \"eukaryota\".\n- \"bacteria\" has children \"cyanobacteria\", \"e_coli\".\n- \"archaea\" has child \"methanoarchaea\".\n- \"eukaryota\" has children \"opisthokonta\", \"archaeplastida\", \"excavata\".\n- \"opisthokonta\" has children \"human\", \"mouse\", \"yeast\".\n- \"archaeplastida\" has child \"arabidopsis\".\n- \"excavata\" has child \"euglena\".\n\nCurated presence sets $P_f$:\n\n- For function \"chlorophyll_biosynthesis\": $P_{\\mathrm{chlorophyll\\_biosynthesis}} = \\{\\text{\"arabidopsis\"}, \\text{\"cyanobacteria\"}, \\text{\"euglena\"}\\}$.\n- For function \"photosystem_II\": $P_{\\mathrm{photosystem\\_II}} = \\{\\text{\"arabidopsis\"}, \\text{\"cyanobacteria\"}, \\text{\"euglena\"}\\}$.\n- For function \"heme_biosynthesis\": $P_{\\mathrm{heme\\_biosynthesis}} = \\{\\text{\"human\"}, \\text{\"yeast\"}, \\text{\"arabidopsis\"}, \\text{\"e_coli\"}\\}$.\n- For function \"methanogenesis\": $P_{\\mathrm{methanogenesis}} = \\{\\text{\"methanoarchaea\"}\\}$.\n\nImplementation requirements:\n\n- Compute $C(\\cdot)$ using the standard Fitch parsimony algorithm on $T$ for a binary character, allowing multifurcating internal nodes. A leaf state is $\\{1\\}$ if in $P_f$, otherwise $\\{0\\}$. For an internal node with child state-sets $S_1, S_2, \\dots, S_k$, combine them by repeated application of: if the current accumulator $A$ intersects the next $S_i$, set $A \\leftarrow A \\cap S_i$; otherwise set $A \\leftarrow A \\cup S_i$ and add $1$ to the change count. The total change count aggregated over all internal nodes equals $C(\\cdot)$.\n- For each query $(q,f)$, compute $D(q,f)$ as defined above and flag implausible if $D(q,f) \\ge \\tau$ with $\\tau = 1$.\n\nTest suite: Use the following ordered list of queries; your program must compute a boolean per query indicating whether it is flagged as implausible.\n\n- $(\\text{\"human\"}, \\text{\"chlorophyll_biosynthesis\"})$\n- $(\\text{\"arabidopsis\"}, \\text{\"chlorophyll_biosynthesis\"})$\n- $(\\text{\"cyanobacteria\"}, \\text{\"chlorophyll_biosynthesis\"})$\n- $(\\text{\"human\"}, \\text{\"heme_biosynthesis\"})$\n- $(\\text{\"yeast\"}, \\text{\"methanogenesis\"})$\n- $(\\text{\"euglena\"}, \\text{\"chlorophyll_biosynthesis\"})$\n- $(\\text{\"human\"}, \\text{\"photosystem_II\"})$\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list of booleans enclosed in square brackets, with no spaces, in the same order as the test suite (for example, $[\\text{True},\\text{False},\\dots]$).",
            "solution": "The problem statement is subjected to rigorous validation and is found to be valid. It is scientifically grounded in the principles of evolutionary biology and bioinformatics, well-posed with a clear mathematical formulation, and objective in its language. All necessary data and definitions for a unique solution are provided. The problem is a direct and formalizable application of phylogenetic comparative methods to the practical task of biological annotation quality control.\n\nThe objective is to design and implement an algorithm that acts as a sanity check for automated protein function annotations. The core of this check is the principle of parsimony, a fundamental concept in phylogenetics, which states that the preferred evolutionary scenario is the one that requires the fewest state changes (e.g., gains or losses of a function). We are tasked with calculating a \"phylogenetic inconsistency score,\" denoted as $D(q, f)$, for a proposed annotation that species $q$ possesses a function $f$.\n\nThe score is defined as:\n$$D(q,f) = C\\big(P_f \\cup \\{q\\}\\big) - C(P_f)$$\nHere, $P_f$ is the set of species known through expert curation to have function $f$. The term $C(S)$ represents the parsimony score for a given presence set $S$, which is the minimum number of evolutionary changes (from state $0$ to $1$ or $1$ to $0$) on the species tree $T$ required to explain the distribution of the function among the leaves. A proposed annotation $(q,f)$ is flagged as implausible if this score meets or exceeds a threshold $\\tau = 1$. A score of $D(q,f) \\ge 1$ signifies that accommodating the new annotation requires at least one additional evolutionary event on the tree, thereby increasing its complexity and reducing its parsimony.\n\nThe calculation of the parsimony score $C(\\cdot)$ is accomplished using the Fitch parsimony algorithm. This algorithm operates in two conceptual passes over the tree $T$, but for computing the score, only the first pass (the up-pass) is necessary. The algorithm proceeds as follows:\n\n1.  **State Initialization:** A binary character is defined on the leaves $L(T)$ of the tree. For a given presence set $S$, a leaf $l \\in L(T)$ is assigned the state set $\\{1\\}$ if $l \\in S$, and $\\{0\\}$ otherwise.\n\n2.  **Up-pass (Post-order Traversal):** The algorithm traverses the tree from the leaves to the root. For each internal node $u$ with children $v_1, v_2, \\dots, v_k$, we compute its hypothetical state set $S_u$ and the number of changes, $c_u$, occurring on the branches leading to its children.\n    *   The state sets of the children, $S_{v_1}, S_{v_2}, \\dots, S_{v_k}$, are determined recursively.\n    *   The state set $S_u$ and change count $c_u$ are computed by iterating through the child state sets. We initialize an accumulator set $A = S_{v_1}$ and a local change count $c_u = 0$.\n    *   For each subsequent child $v_i$ (from $i=2$ to $k$):\n        *   If the intersection $A \\cap S_{v_i}$ is non-empty, the accumulator is updated to this intersection: $A \\leftarrow A \\cap S_{v_i}$. This represents a shared state inherited from the parent $u$.\n        *   If the intersection $A \\cap S_{v_i}$ is empty, the accumulator is updated to the union $A \\leftarrow A \\cup S_{v_i}$, and the change count is incremented: $c_u \\leftarrow c_u + 1$. This signifies a necessary state change (a convergence or a loss) on one of the branches involved.\n    *   The final state set for node $u$ is the final value of $A$, and the cost at node $u$ is the final value of $c_u$.\n\n3.  **Total Parsimony Score:** The total parsimony score, $C(S)$, is the sum of the change counts from all internal nodes in the tree:\n    $$C(S) = \\sum_{u \\in \\text{InternalNodes}(T)} c_u$$\n\nTo implement the solution, the provided tree topology is first represented as a directed graph, for instance, using a dictionary mapping parent nodes to lists of their children. A recursive function is then designed to perform the post-order traversal, calculating state sets and change counts as it progresses from leaves to the root.\n\nFor each query $(q,f)$ from the test suite:\n1.  The baseline parsimony score $C(P_f)$ is calculated using the curated presence set $P_f$.\n2.  If the query species $q$ is already in $P_f$, then $P_f \\cup \\{q\\} = P_f$, which implies $C(P_f \\cup \\{q\\}) = C(P_f)$. Thus, $D(q,f) = 0$, and the annotation is not flagged.\n3.  If $q \\notin P_f$, a new presence set $P'_f = P_f \\cup \\{q\\}$ is formed.\n4.  The parsimony score $C(P'_f)$ is calculated for this new set.\n5.  The inconsistency score $D(q,f) = C(P'_f) - C(P_f)$ is computed.\n6.  The result is compared against the threshold $\\tau=1$. The query is flagged as implausible (boolean `True`) if $D(q,f) \\ge 1$, and plausible (boolean `False`) otherwise.\n\nThis procedure is applied to every query in the provided test suite to generate the final output.",
            "answer": "```python\nimport numpy as np\nfrom functools import lru_cache\n\ndef solve():\n    \"\"\"\n    Solves the phylogenetic sanity-check problem.\n    \"\"\"\n    \n    # Define the species tree topology as a parent-to-children dictionary.\n    TREE = {\n        \"root\": [\"bacteria\", \"archaea\", \"eukaryota\"],\n        \"bacteria\": [\"cyanobacteria\", \"e_coli\"],\n        \"archaea\": [\"methanoarchaea\"],\n        \"eukaryota\": [\"opisthokonta\", \"archaeplastida\", \"excavata\"],\n        \"opisthokonta\": [\"human\", \"mouse\", \"yeast\"],\n        \"archaeplastida\": [\"arabidopsis\"],\n        \"excavata\": [\"euglena\"],\n    }\n    \n    # Identify all nodes and leaf nodes from the tree structure.\n    all_nodes = set(TREE.keys())\n    for children in TREE.values():\n        all_nodes.update(children)\n    LEAVES = all_nodes - set(TREE.keys())\n\n    # Define the curated presence sets for each function.\n    CURATED_SETS = {\n        \"chlorophyll_biosynthesis\": {\"arabidopsis\", \"cyanobacteria\", \"euglena\"},\n        \"photosystem_II\": {\"arabidopsis\", \"cyanobacteria\", \"euglena\"},\n        \"heme_biosynthesis\": {\"human\", \"yeast\", \"arabidopsis\", \"e_coli\"},\n        \"methanogenesis\": {\"methanoarchaea\"},\n    }\n\n    # Define the test suite of queries (species, function).\n    QUERIES = [\n        (\"human\", \"chlorophyll_biosynthesis\"),\n        (\"arabidopsis\", \"chlorophyll_biosynthesis\"),\n        (\"cyanobacteria\", \"chlorophyll_biosynthesis\"),\n        (\"human\", \"heme_biosynthesis\"),\n        (\"yeast\", \"methanogenesis\"),\n        (\"euglena\", \"chlorophyll_biosynthesis\"),\n        (\"human\", \"photosystem_II\"),\n    ]\n\n    def fitch_parsimony_score(presence_set):\n        \"\"\"\n        Calculates the total Fitch parsimony score for a given presence set.\n        \n        Args:\n            presence_set (frozenset): A set of leaf names that possess the function (state 1).\n        \n        Returns:\n            int: The minimum number of state changes on the tree.\n        \"\"\"\n        \n        # Memoization to avoid recomputing for the same node and presence set.\n        @lru_cache(maxsize=None)\n        def post_order_traversal(node, p_set):\n            \"\"\"\n            Performs a post-order traversal to compute state sets and change counts.\n\n            Args:\n                node (str): The current node name.\n                p_set (frozenset): The presence set for this calculation.\n            \n            Returns:\n                tuple[set, int]: A tuple containing the state set for the node and the\n                                 cumulative change count for the subtree rooted at this node.\n            \"\"\"\n            # Base Case: Leaf node\n            if node in LEAVES:\n                state_set = {1} if node in p_set else {0}\n                return state_set, 0\n\n            # Recursive Step: Internal node\n            children = TREE.get(node, [])\n            if not children: # Should not happen for internal nodes\n                return set(), 0\n\n            # Get state sets and costs from all children\n            child_results = [post_order_traversal(child, p_set) for child in children]\n            \n            # Initialize accumulator and total cost for this subtree\n            # Start with the first child\n            running_state_set, total_subtree_cost = child_results[0]\n            # Make a copy to modify\n            running_state_set = set(running_state_set)\n            \n            # The change count at this specific node\n            node_cost = 0\n\n            # Sequentially merge the rest of the children\n            for i in range(1, len(child_results)):\n                child_state_set, child_cost = child_results[i]\n                total_subtree_cost += child_cost\n                \n                intersection = running_state_set.intersection(child_state_set)\n                \n                if intersection:\n                    running_state_set = intersection\n                else:\n                    running_state_set.update(child_state_set)\n                    node_cost += 1\n            \n            total_subtree_cost += node_cost\n            return running_state_set, total_subtree_cost\n\n        # Start the traversal from the root node.\n        # The presence_set is converted to a frozenset to be hashable for lru_cache.\n        _, total_cost = post_order_traversal(\"root\", frozenset(presence_set))\n        return total_cost\n\n    results = []\n    tau = 1\n\n    for q, f in QUERIES:\n        p_f = CURATED_SETS[f]\n        \n        # If the queried species is already in the curated set, the score change is 0.\n        if q in p_f:\n            d_qf = 0\n        else:\n            # Calculate score without the query\n            c_pf = fitch_parsimony_score(p_f)\n            \n            # Calculate score with the query\n            p_f_union_q = p_f.union({q})\n            c_pf_union_q = fitch_parsimony_score(p_f_union_q)\n            \n            d_qf = c_pf_union_q - c_pf\n        \n        # Flag as implausible if the score change is >= tau\n        is_implausible = d_qf >= tau\n        results.append(is_implausible)\n\n    # Format and print the final output as specified.\n    print(f\"[{','.join(map(str, results))}]\".replace(\" \", \"\"))\n\nsolve()\n```"
        },
        {
            "introduction": "The accuracy of an annotation is meaningless if the gene it refers to no longer exists in the reference genome. Biological databases are dynamic, with gene identifiers constantly being updated, merged, or retired. This leads to the problem of \"zombie annotations\"—records that persist in downstream databases but point to obsolete identifiers. This final practice models the essential data curation task of tracking identifier evolution to detect these zombie records, helping you understand the importance of database maintenance and a key difference in data quality between curated and automated sources .",
            "id": "2383787",
            "problem": "You are given a formalized reconciliation task that models the detection of “zombie annotations” in downstream biological databases. A zombie annotation is an annotation record that refers to a gene identifier that has been superseded by a replacement (merge) or has been deleted in the authoritative source but persists uncorrected downstream. The task is to define a decision rule from first principles and implement a program that applies it to a finite set of test cases.\n\nDefinitions and setup:\n- Let $U$ be a finite universe of gene identifiers. Let $C \\subseteq U$ be the set of identifiers that are current and valid at a fixed authoritative reference release $R^\\ast$.\n- Let $E \\subseteq U \\times \\left(U \\cup \\{\\bot\\}\\right)$ be a binary relation encoding identifier evolution, where $(x,y) \\in E$ with $y \\in U$ denotes that identifier $x$ was replaced by $y$ (for example, by a merge), and $(x,\\bot) \\in E$ denotes that identifier $x$ was deleted without replacement. The special symbol $\\bot$ denotes the deletion terminal.\n- For any $x \\in U$, define the canonicalization function $c(x)$ at release $R^\\ast$ as follows:\n  - If $x \\in C$ and there is no $(x,y) \\in E$, then $c(x) = x$.\n  - If $(x,y) \\in E$ with $y \\in U$, then $c(x) = c(y)$.\n  - If $(x,\\bot) \\in E$, then $c(x) = \\bot$.\n  - If $x \\notin C$ and there is no $(x,y) \\in E$, then $c(x) = \\bot$.\n  - If there exists a directed cycle reachable from $x$ in the graph induced by $E$ on $U$, then $c(x) = \\bot$.\n- An annotation record is a pair $(x,s)$ with $x \\in U$ and $s \\in \\{\\mathsf{curated}, \\mathsf{automated}\\}$. Given $c(x)$, define the zombie indicator $z(x)$ by\n  - $z(x) = 1$ if $c(x) = \\bot$ or $c(x) \\neq x$,\n  - $z(x) = 0$ if $c(x) = x$.\n- For a multiset of annotation records $A = \\{(x_i,s_i)\\}_{i=1}^{n}$, define:\n  - $Z = \\sum_{i=1}^{n} z(x_i)$, the total number of zombie annotations.\n  - $Z_C = \\sum_{i=1}^{n} \\mathbf{1}[s_i = \\mathsf{curated}] \\cdot z(x_i)$, the number of zombie annotations among curated records.\n  - $Z_A = \\sum_{i=1}^{n} \\mathbf{1}[s_i = \\mathsf{automated}] \\cdot z(x_i)$, the number of zombie annotations among automated records.\n  - $N_C = \\sum_{i=1}^{n} \\mathbf{1}[s_i = \\mathsf{curated}]$, the total number of curated records.\n  - $N_A = \\sum_{i=1}^{n} \\mathbf{1}[s_i = \\mathsf{automated}]$, the total number of automated records.\n  - $r_C = \\begin{cases} Z_C / N_C & \\text{if } N_C \\neq 0 \\\\\\\\ 0 & \\text{if } N_C = 0 \\end{cases}$, the curated zombie rate expressed as a decimal fraction.\n  - $r_A = \\begin{cases} Z_A / N_A & \\text{if } N_A \\neq 0 \\\\\\\\ 0 & \\text{if } N_A = 0 \\end{cases}$, the automated zombie rate expressed as a decimal fraction.\n\nTest suite:\nYou must apply the above to the following three test cases. In each case, $U$ is implicitly the union of all identifiers appearing in $C$, the domain and codomain of $E$, and the annotation records $A$.\n\n- Test case $1$:\n  - Current identifiers $C = \\{g\\_3, g\\_4\\}$.\n  - Evolution relation $E = \\{(g\\_1,g\\_2),(g\\_2,g\\_3),(g\\_5,\\bot)\\}$.\n  - Annotation records $A = [(g\\_1,\\mathsf{curated}),(g\\_2,\\mathsf{automated}),(g\\_3,\\mathsf{curated}),(g\\_5,\\mathsf{automated}),(g\\_4,\\mathsf{automated})]$.\n\n- Test case $2$:\n  - Current identifiers $C = \\{h\\_1, h\\_2\\}$.\n  - Evolution relation $E = \\varnothing$.\n  - Annotation records $A = [(h\\_1,\\mathsf{curated}),(h\\_2,\\mathsf{automated})]$.\n\n- Test case $3$:\n  - Current identifiers $C = \\{a\\_3, c\\_1\\}$.\n  - Evolution relation $E = \\{(a\\_0,a\\_1),(a\\_1,a\\_3),(a\\_2,a\\_3),(b\\_1,\\bot)\\}$.\n  - Annotation records $A = [(a\\_2,\\mathsf{curated}),(a\\_3,\\mathsf{automated}),(b\\_1,\\mathsf{automated}),(x\\_{999},\\mathsf{curated}),(a\\_0,\\mathsf{automated})]$.\n\nRequired output:\n- For each test case, compute the $5$-tuple $[Z, Z_C, Z_A, r_C, r_A]$ as defined above, where $Z$, $Z_C$, and $Z_A$ are integers and $r_C$, $r_A$ are decimal fractions.\n- Your program should produce a single line of output containing the results aggregated across the $3$ test cases as a comma-separated list enclosed in square brackets, where each element is itself the bracket-enclosed, comma-separated $5$-tuple for a test case. For example, the format must be exactly like $[[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot]]$ with no whitespace characters.",
            "solution": "We formalize the detection of zombie annotations by reference to a canonicalization function that resolves each identifier to its current form at the authoritative reference release, if possible.\n\nLet $U$ be the identifier universe, $C \\subseteq U$ be current identifiers, and $E \\subseteq U \\times \\left(U \\cup \\{\\bot\\}\\right)$ be the evolution relation. Define $c: U \\to U \\cup \\{\\bot\\}$ by structural recursion:\n- Base cases:\n  - If $x \\in C$ and there is no $(x,y) \\in E$, then $c(x) = x$. This is a fixed point representing an up-to-date identifier.\n  - If $(x,\\bot) \\in E$, then $c(x) = \\bot$. This represents deletion.\n  - If $x \\notin C$ and there is no $(x,y) \\in E$, set $c(x) = \\bot$. This covers unknown or invalid identifiers relative to the authoritative release.\n- Recursive case:\n  - If $(x,y) \\in E$ with $y \\in U$, define $c(x) = c(y)$, which follows the replacement chain until a base case holds.\n- Cycle handling:\n  - If during recursive evaluation a previously seen identifier is encountered again, a directed cycle exists in the reachable subgraph, so $c(x)$ is undefined in the natural sense; we define $c(x) = \\bot$ to conservatively treat cycle-involved identifiers as non-resolvable and therefore zombie. In curated sources, such cycles are not expected, but the rule remains well-defined.\n\nDefine the zombie indicator $z(x)$ by $z(x) = 1$ if $c(x) = \\bot$ or $c(x) \\neq x$, and $z(x) = 0$ otherwise. This captures both deleted identifiers (where $c(x) = \\bot$) and obsolete identifiers that should have been updated to their canonical replacements (where $c(x) \\neq x$). The rule is source-agnostic; it applies identically to curated and automated records, enabling comparison of zombie rates between sources.\n\nFor a multiset of annotation records $A = \\{(x_i,s_i)\\}_{i=1}^{n}$, define\n- $Z = \\sum_{i=1}^{n} z(x_i)$,\n- $Z_C = \\sum_{i=1}^{n} \\mathbf{1}[s_i = \\mathsf{curated}] \\cdot z(x_i)$,\n- $Z_A = \\sum_{i=1}^{n} \\mathbf{1}[s_i = \\mathsf{automated}] \\cdot z(x_i)$,\n- $N_C = \\sum_{i=1}^{n} \\mathbf{1}[s_i = \\mathsf{curated}]$,\n- $N_A = \\sum_{i=1}^{n} \\mathbf{1}[s_i = \\mathsf{automated}]$,\n- $r_C = Z_C / N_C$ if $N_C \\neq 0$ and $r_C = 0$ if $N_C = 0$,\n- $r_A = Z_A / N_A$ if $N_A \\neq 0$ and $r_A = 0$ if $N_A = 0$.\n\nWe now apply these definitions to the test suite.\n\nTest case $1$:\n- $C = \\{g\\_3,g\\_4\\}$,\n- $E = \\{(g\\_1,g\\_2),(g\\_2,g\\_3),(g\\_5,\\bot)\\}$,\n- $A = [(g\\_1,\\mathsf{curated}),(g\\_2,\\mathsf{automated}),(g\\_3,\\mathsf{curated}),(g\\_5,\\mathsf{automated}),(g\\_4,\\mathsf{automated})]$.\nCanonicalization:\n- $c(g\\_1) = c(g\\_2) = c(g\\_3) = g\\_3$, so $z(g\\_1) = 1$, $z(g\\_2) = 1$, $z(g\\_3) = 0$.\n- $c(g\\_5) = \\bot$, so $z(g\\_5) = 1$.\n- $c(g\\_4) = g\\_4$, so $z(g\\_4) = 0$.\nCounts and rates:\n- $Z = 3$,\n- $Z_C = 1$ (only $(g\\_1,\\mathsf{curated})$ is zombie),\n- $Z_A = 2$ (both $(g\\_2,\\mathsf{automated})$ and $(g\\_5,\\mathsf{automated})$ are zombie),\n- $N_C = 2$, $N_A = 3$,\n- $r_C = 1/2 = 0.5$,\n- $r_A = 2/3 \\approx 0.6666666666666666$.\n\nTest case $2$:\n- $C = \\{h\\_1,h\\_2\\}$,\n- $E = \\varnothing$,\n- $A = [(h\\_1,\\mathsf{curated}),(h\\_2,\\mathsf{automated})]$.\nCanonicalization:\n- $c(h\\_1) = h\\_1$, $c(h\\_2) = h\\_2$, so $z(h\\_1) = 0$, $z(h\\_2) = 0$.\nCounts and rates:\n- $Z = 0$,\n- $Z_C = 0$, $Z_A = 0$,\n- $N_C = 1$, $N_A = 1$,\n- $r_C = 0$, $r_A = 0$.\n\nTest case $3$:\n- $C = \\{a\\_3,c\\_1\\}$,\n- $E = \\{(a\\_0,a\\_1),(a\\_1,a\\_3),(a\\_2,a\\_3),(b\\_1,\\bot)\\}$,\n- $A = [(a\\_2,\\mathsf{curated}),(a\\_3,\\mathsf{automated}),(b\\_1,\\mathsf{automated}),(x\\_{999},\\mathsf{curated}),(a\\_0,\\mathsf{automated})]$.\nCanonicalization:\n- $c(a\\_2) = c(a\\_3) = a\\_3$, so $z(a\\_2) = 1$, $z(a\\_3) = 0$.\n- $c(b\\_1) = \\bot$, so $z(b\\_1) = 1$.\n- $x\\_{999} \\notin C$ and no outgoing edge in $E$, so $c(x\\_{999}) = \\bot$ and $z(x\\_{999}) = 1$.\n- $c(a\\_0) = c(a\\_1) = c(a\\_3) = a\\_3$, so $z(a\\_0) = 1$.\nCounts and rates:\n- $Z = 4$,\n- $Z_C = 2$ (both $(a\\_2,\\mathsf{curated})$ and $(x\\_{999},\\mathsf{curated})$ are zombie),\n- $Z_A = 2$ (both $(b\\_1,\\mathsf{automated})$ and $(a\\_0,\\mathsf{automated})$ are zombie),\n- $N_C = 2$, $N_A = 3$,\n- $r_C = 2/2 = 1.0$,\n- $r_A = 2/3 \\approx 0.6666666666666666$.\n\nThus, the required outputs per test case are the $5$-tuples:\n- Test case $1$: $[3, 1, 2, 0.5, 0.6666666666666666]$.\n- Test case $2$: $[0, 0, 0, 0.0, 0.0]$.\n- Test case $3$: $[4, 2, 2, 1.0, 0.6666666666666666]$.\n\nThe program must output these three lists aggregated into a single bracketed list with no whitespace characters on a single line.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef canonical(id_, current, edges):\n    \"\"\"\n    Compute canonical identifier for id_ given:\n    - current: set of current valid identifiers\n    - edges: dict mapping obsolete id -> replacement id (string) or None for deletion\n    Returns:\n        - the canonical current id as a string, if resolvable and current\n        - None if deleted, unknown, or cycle detected\n    \"\"\"\n    visited = set()\n    x = id_\n    while True:\n        if x in visited:\n            # Cycle detected\n            return None\n        visited.add(x)\n        if x in edges:\n            y = edges[x]\n            if y is None:\n                return None\n            x = y\n            continue\n        # No outgoing edge from x\n        if x in current:\n            return x\n        else:\n            # Unknown or invalid w.r.t. current/edges\n            return None\n\ndef analyze_case(current_ids, evolution_edges, annotations):\n    \"\"\"\n    current_ids: set of strings\n    evolution_edges: dict {old: new or None}\n    annotations: list of tuples (id, source) where source is 'curated' or 'automated'\n    Returns list: [Z, Z_C, Z_A, r_C, r_A]\n    \"\"\"\n    # Compute zombies\n    total_zombies = 0\n    curated_zombies = 0\n    automated_zombies = 0\n    n_curated = 0\n    n_automated = 0\n\n    for gene_id, source in annotations:\n        canon = canonical(gene_id, current_ids, evolution_edges)\n        is_zombie = (canon is None) or (canon != gene_id)\n        if is_zombie:\n            total_zombies += 1\n        if source == 'curated':\n            n_curated += 1\n            if is_zombie:\n                curated_zombies += 1\n        elif source == 'automated':\n            n_automated += 1\n            if is_zombie:\n                automated_zombies += 1\n        else:\n            # Unknown source label; for robustness, ignore counts (not expected in test suite)\n            pass\n\n    r_c = (curated_zombies / n_curated) if n_curated != 0 else 0.0\n    r_a = (automated_zombies / n_automated) if n_automated != 0 else 0.0\n\n    return [total_zombies, curated_zombies, automated_zombies, r_c, r_a]\n\ndef solve():\n    # Define the test cases from the problem statement.\n\n    # Test case 1\n    current_1 = {'g_3', 'g_4'}\n    edges_1 = {\n        'g_1': 'g_2',\n        'g_2': 'g_3',\n        'g_5': None  # deletion\n    }\n    annotations_1 = [\n        ('g_1', 'curated'),\n        ('g_2', 'automated'),\n        ('g_3', 'curated'),\n        ('g_5', 'automated'),\n        ('g_4', 'automated'),\n    ]\n\n    # Test case 2\n    current_2 = {'h_1', 'h_2'}\n    edges_2 = {}\n    annotations_2 = [\n        ('h_1', 'curated'),\n        ('h_2', 'automated'),\n    ]\n\n    # Test case 3\n    current_3 = {'a_3', 'c_1'}\n    edges_3 = {\n        'a_0': 'a_1',\n        'a_1': 'a_3',\n        'a_2': 'a_3',\n        'b_1': None,  # deletion\n    }\n    annotations_3 = [\n        ('a_2', 'curated'),\n        ('a_3', 'automated'),\n        ('b_1', 'automated'),\n        ('x_999', 'curated'),\n        ('a_0', 'automated'),\n    ]\n\n    test_cases = [\n        (current_1, edges_1, annotations_1),\n        (current_2, edges_2, annotations_2),\n        (current_3, edges_3, annotations_3),\n    ]\n\n    results = []\n    for current, edges, annotations in test_cases:\n        results.append(analyze_case(current, edges, annotations))\n\n    # Build exact output format: no spaces, list of lists\n    # Convert each inner list to a string without spaces\n    def list_to_compact_str(lst):\n        # Elements are ints or floats\n        elems = []\n        for v in lst:\n            if isinstance(v, float):\n                elems.append(repr(v))\n            else:\n                elems.append(str(v))\n        return \"[\" + \",\".join(elems) + \"]\"\n\n    out = \"[\" + \",\".join(list_to_compact_str(r) for r in results) + \"]\"\n    print(out)\n\nsolve()\n```"
        }
    ]
}