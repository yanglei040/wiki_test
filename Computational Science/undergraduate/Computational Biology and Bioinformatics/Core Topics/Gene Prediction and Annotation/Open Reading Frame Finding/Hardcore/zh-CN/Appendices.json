{
    "hands_on_practices": [
        {
            "introduction": "理论知识最终需要通过实践来巩固。这项练习将引导你将开放阅读框（ORF）的生物学定义——一个从起始密码子开始到终止密码子结束的序列——转化为一个具体的计算机程序。通过从头开始构建一个六框ORF查找器()，你将掌握在DNA序列中识别潜在基因的核心计算技能。",
            "id": "2435536",
            "problem": "你的任务是编写一个完整的程序，该程序为一组脱氧核糖核酸（DNA）重叠群（contig）识别所有长度（以密码子为单位）超过给定阈值的开放阅读框（ORF）。此处，ORF 使用标准遗传密码定义，指一个最大的框内区间，其始于一个典型的起始密码子，并终于同一链上下游的第一个框内终止密码子。程序必须搜索每个重叠群的所有六个阅读框（$+1$, $+2$, $+3$, $-1$, $-2$, $-3$）。\n\n需要使用的基本原理和定义：\n- 分子生物学的中心法则：DNA 转录为核糖核酸（RNA），再翻译为蛋白质；翻译以密码子为单位进行，密码子是连续的三个核苷酸。\n- 在标准遗传密码下，有三个终止密码子：TAA、TAG 和 TGA。典型的起始密码子是 ATG。\n- 阅读框由链上模 $3$ 的相位偏移定义。每条链有三个阅读框，因此当同时考虑正向链和反向互补链时，总共有六个。\n- DNA 字符串的反向互补是通过反转字符串并对每个核苷酸进行互补（A↔T, C↔G）来获得的，这反映了反向平行、互补的碱基配对。\n\n你必须根据以下原则推导算法：\n- 在每条链上，以 $3$ 个核苷酸为步长扫描每个阅读框。每当遇到起始密码子 ATG 时，在同一阅读框中寻找下游的第一个框内终止密码子（TAA、TAG 或 TGA）。如果在重叠群末端之前不存在框内终止密码子，则此起始密码子不会产生可报告的 ORF。\n- 设重叠群长度为 $L$。对于在正向链上发现的 ORF，其起始核苷酸索引为 $s$（ATG 中 A 的索引），终止密码子起始索引为 $t$（终止密码子第一个碱基的索引），则该 ORF 的核苷酸区间为 $[s, t+3)$（一个半开区间）。以密码子为单位的 ORF 长度（不包括末端终止密码子）为 $(t - s)/3 - 1$。\n- 对于在反向互补链上发现的 ORF，其反向互补坐标为 $[s_{\\mathrm{rc}}, t_{\\mathrm{rc}}+3)$，使用 $s_{\\mathrm{orig}} = L - (t_{\\mathrm{rc}}+3)$ 和 $t_{\\mathrm{orig}} = L - s_{\\mathrm{rc}}$ 将其映射回原始重叠群坐标。所有情况下都应报告原始重叠群上的坐标。\n- 当且仅当一个 ORF 的密码子长度严格超过给定阈值 $N$（即，长度 $> N$）时，它才被包含在输出中。报告的长度不包括末端终止密码子。\n\n将每个 ORF 表示为一个包含四个整数的列表 $[f, s, e, \\ell]$，其中：\n- $f$ 是阅读框标识符：$+1$, $+2$, $+3$ 分别对应偏移量为 $0$, $1$, $2$ 的正向阅读框；$-1$, $-2$, $-3$ 分别对应反向互补链上偏移量为 $0$, $1$, $2$ 的反向互补阅读框。\n- $s$ 是原始重叠群上从 0 开始的起始索引（包含）。\n- $e$ 是原始重叠群上从 0 开始的结束索引（不包含），即紧跟在终止密码子之后的索引。\n- $\\ell$ 是以密码子为单位的 ORF 长度，不包括末端终止密码子。\n\n排序规则：对每个重叠群，按 $s$ 升序、然后按 $e$ 升序、最后按 $f$ 升序对 ORF 进行排序。\n\n假设和约束：\n- 所有重叠群都是基于字母表 {A, C, G, T} 的大写字符串。不出现模糊符号。\n- 仅使用标准遗传密码，以 ATG 为唯一初始密码子，TAA、TAG、TGA 为终止密码子。\n- 坐标必须以原始重叠群上从 0 开始的半开区间 $[s,e)$ 的形式报告。\n\n测试套件：\n你的程序必须计算以下四个测试用例的结果。每个测试用例是一对 $(\\text{contig}, N)$。\n\n- 测试用例 1（包含正向和反向阅读框的正常路径）：\n  - Contig: \"AAAATGAAACCCGGGTTTTAAAATGGCCGAACCTTAGTCAGGGTTTTTTCAT\"\n  - 阈值 $N = 2$\n- 测试用例 2（边界条件，一个 ORF 的长度恰好为 $N$ 且必须被排除，旁边还有一个更长的 ORF）：\n  - Contig: \"GGGATGAAATAGGGATGCCACCCTAA\"\n  - 阈值 $N = 1$\n- 测试用例 3（边缘情况，任何地方都没有起始密码子）：\n  - Contig: \"CCCTTTGGGCCCTAGTAA\"\n  - 阈值 $N = 0$\n- 测试用例 4（边缘情况，有起始密码子但在末端前没有框内终止密码子；不报告不完整的 ORF）：\n  - Contig: \"GGGATGCCCCCCCCGGG\"\n  - 阈值 $N = 0$\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含所有测试用例的结果，格式为用方括号括起来的逗号分隔列表。\n- 每个测试用例的结果必须是按指定方式排序的 ORF 记录列表 $[f,s,e,\\ell]$。顶层输出是这些按测试用例组织的列表的列表。\n- 输出必须完全不含任何空白字符。例如，一个有效的格式是 \"[[...],[...],[],[]]\"。\n\n你的程序必须是自包含的，且不得读取任何输入。它必须计算上述四个测试用例的结果，并打印所需的单行输出。",
            "solution": "所提出的问题是生物信息学中的一个标准练习，特别是在序列分析领域。它要求在给定的脱氧核糖核酸（DNA）重叠群中识别开放阅读框（ORF）。该问题具有科学依据，定义明确，并提供了一套完整且无歧义的定义和约束。因此，该问题是有效的，并且可以构建解决方案。\n\n基本原理是将核苷酸序列翻译成氨基酸序列，这一过程由遗传密码所支配。翻译在特定的阅读框中进行，阅读框是将序列划分为连续、不重叠的核苷酸三联体（称为密码子）的方式。一个 ORF 代表一个潜在的蛋白质编码基因，定义为在同一阅读框中以起始密码子开始并以终止密码子结束的序列。由于 DNA 是具有反向平行链的双链分子，我们必须总共分析六个阅读框：三个在正向链上，三个在反向互补链上。\n\n该算法旨在系统地检查每个给定重叠群的六个阅读框中的每一个。\n\n**步骤 1：链与阅读框迭代**\n该过程必须应用于正向链及其反向互补链。反向互补链的生成方式是：首先反转 DNA 序列，然后将每个核苷酸替换为其互补碱基（$A \\leftrightarrow T$, $C \\leftrightarrow G$）。对于每条链，存在三个阅读框，由第一个密码子的起始位置决定。这些阅读框分别从序列的索引 $0$, $1$, 和 $2$ 开始。我们将用阅读框标识符 $+1, +2, +3$ 表示正向链的阅读框，用 $-1, -2, -3$ 表示反向互补链的阅读框。\n\n**步骤 2：在单链上识别 ORF**\n对于给定的链（正向链或反向互补链）和特定的阅读框（偏移量 $i \\in \\{0, 1, 2\\}$），算法会扫描序列以寻找 ORF。扫描从阅读框的偏移量开始，逐个密码子进行，即以 $3$ 个核苷酸为步长。\n\n单个阅读框的处理过程如下：\n1.  使用起始索引 $s$ 遍历序列，其中 $s \\equiv i \\pmod 3$。\n2.  在每个位置 $s$，检查密码子 `dna[s:s+3]` 是否为典型的起始密码子 `ATG`。\n3.  如果在索引 $s$ 处找到起始密码子，则从位置 $s+3$ 开始进行后续搜索，以找到第一个框内终止密码子（`TAA`、`TAG` 或 `TGA`）。此搜索也以 $3$ 为步长进行。\n4.  如果在索引 $t$ 处找到终止密码子，这就定义了一个 ORF。问题陈述将此 ORF 的密码子长度（不包括终止密码子）定义为 $\\ell = (t-s)/3 - 1$。由于对于框内终止密码子，$(t-s)$ 保证是 $3$ 的倍数，因此可以使用整数除法。\n5.  仅当此 ORF 的长度 $\\ell$ 严格大于给定阈值 $N$ 时，才认为它可用于报告。\n6.  如果在序列结束前未找到框内终止密码子，则位于 $s$ 处的起始密码子不构成一个完整的 ORF，并且不会为其报告任何内容。\n7.  对下一个起始密码子的扫描从当前起始密码子之后的位置（即 $s+3$）恢复，以确保找到所有潜在的 ORF。问题将 ORF 定义为“最大的框内区间”，我们将其解释为从给定起始密码子到该阅读框中遇到的第一个终止密码子的区间。\n\n**步骤 3：反向互补链的坐标转换**\n在反向互补链上找到的 ORF，其坐标必须映射回原始正向链的坐标系。设原始重叠群的长度为 $L$。如果在反向互补链上发现一个 ORF，其起始索引为 $s_{rc}$，终止密码子起始索引为 $t_{rc}$，则其核苷酸区间为 $[s_{rc}, t_{rc}+3)$。原始重叠群上对应的区间由链的反向平行特性导出。原始重叠群上的起始坐标为 $s_{orig} = L - (t_{rc}+3)$，不包含的结束坐标为 $e_{orig} = L - s_{rc}$。\n\n**步骤 4：记录的构建与排序**\n每个有效的 ORF 都被记录为一个包含四个整数的列表：$[f, s, e, \\ell]$。其中，$f$ 是阅读框标识符（$+1, +2, +3, -1, -2, -3$），$s$ 是原始重叠群上从 0 开始的起始索引，$e$ 是从 0 开始的不包含的结束索引，$\\ell$ 是计算出的密码子长度。在识别出一个重叠群的所有 ORF 后，对结果列表进行排序。指定的排序标准是：首先按起始位置 $s$ 升序，其次按结束位置 $e$ 升序，最后按阅读框标识符 $f$ 升序。\n\n这种结构化的方法确保了对所有六个阅读框进行详尽的搜索，并根据问题的严格要求正确地筛选、格式化和排序任何已识别的 ORF，从而得出一个确定且正确的解决方案。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Solves the ORF finding problem for the predefined test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\"AAAATGAAACCCGGGTTTTAAAATGGCCGAACCTTAGTCAGGGTTTTTTCAT\", 2),\n        (\"GGGATGAAATAGGGATGCCACCCTAA\", 1),\n        (\"CCCTTTGGGCCCTAGTAA\", 0),\n        (\"GGGATGCCCCCCCCGGG\", 0),\n    ]\n\n    results = []\n    for contig, n_threshold in test_cases:\n        results.append(find_all_orfs(contig, n_threshold))\n\n    # Final print statement in the exact required format.\n    # The string representation of a list includes spaces, which must be removed.\n    final_output = str(results).replace(\" \", \"\")\n    print(final_output)\n\ndef find_all_orfs(contig, n_threshold):\n    \"\"\"\n    Finds all ORFs in a given contig that are longer than a specified threshold.\n    Searches all six reading frames.\n\n    Args:\n        contig (str): The DNA sequence.\n        n_threshold (int): The minimum number of codons (exclusive of stop)\n                           for an ORF to be reported. Length must be > threshold.\n    \n    Returns:\n        list: A sorted list of ORF records. Each record is [frame, start, end, length].\n    \"\"\"\n    stop_codons = {\"TAA\", \"TAG\", \"TGA\"}\n    start_codon = \"ATG\"\n    all_orfs = []\n    L = len(contig)\n\n    # Process forward strand (+1, +2, +3 frames)\n    for offset in range(3):\n        frame_id = offset + 1\n        # Iterate through the sequence in steps of 3 for the current frame\n        for s in range(offset, L - 5, 3):\n            if contig[s:s+3] == start_codon:\n                # Found a start codon, now search for the first in-frame stop codon\n                for t in range(s + 3, L - 2, 3):\n                    if contig[t:t+3] in stop_codons:\n                        # ORF found, calculate length and check against threshold\n                        length = (t - s) // 3 - 1\n                        if length > n_threshold:\n                            e = t + 3\n                            all_orfs.append([frame_id, s, e, length])\n                        # Break inner loop as we only care about the first stop\n                        break\n\n    # Process reverse-complement strand (-1, -2, -3 frames)\n    # The translation map for complementing DNA\n    complement_map = str.maketrans(\"ATCG\", \"TAGC\")\n    rc_contig = contig.translate(complement_map)[::-1]\n    \n    for offset in range(3):\n        frame_id = -(offset + 1)\n        for s_rc in range(offset, L - 5, 3):\n            if rc_contig[s_rc:s_rc+3] == start_codon:\n                for t_rc in range(s_rc + 3, L - 2, 3):\n                    if rc_contig[t_rc:t_rc+3] in stop_codons:\n                        length = (t_rc - s_rc) // 3 - 1\n                        if length > n_threshold:\n                            # Map coordinates from reverse-complement to original\n                            s_orig = L - (t_rc + 3)\n                            e_orig = L - s_rc\n                            all_orfs.append([frame_id, s_orig, e_orig, length])\n                        break\n\n    # Sort the collected ORFs according to the specified rule: s, then e, then f\n    # In the list [f, s, e, l], these correspond to indices 0, 1, 2\n    all_orfs.sort(key=lambda orf: (orf[1], orf[2], orf[0]))\n\n    return all_orfs\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "仅仅找到所有可能的ORF是不够的，因为随机序列中也可能偶然出现短的ORF。真正的挑战在于区分“信号”（真实的基因）和“噪声”（随机产生的序列）。这项练习()将让你扮演一个计算生物学家的角色，通过建立一个统计模型来确定一个最小长度阈值，从而在整个基因组尺度上控制假阳性发现的数量。",
            "id": "2410641",
            "problem": "一个细菌基因组的长度为 $N = 5 \\times 10^{6}$ 个核苷酸，背景核苷酸频率为 $p_{A} = 0.3$，$p_{T} = 0.3$，$p_{G} = 0.2$ 和 $p_{C} = 0.2$。假设核苷酸模型是独立同分布（i.i.d.）的，并且连续的密码子之间是相互独立的。一个开放阅读框（ORF）被定义为一个以标准起始密码子 ATG 开始，并在起始密码子下游至少 $L$ 个密码子内，在同一读码框中没有遇到任何终止密码子的序列。考虑三个标准的终止密码子 TAA、TAG 和 TGA。对基因组的两条链以及每条链上的所有三个阅读框进行扫描。\n\n您需要一个统计决策规则，能够在上述零假设随机序列模型下，通过将全基因组范围内的假阳性 ORF 的期望数量控制在最多 $\\alpha = 0.05$，从而稳健地将真实的（但非常短的）ORF 与随机生成的 ORF 区分开来。在这里，假阳性 ORF 是指在随机序列中纯粹由于偶然机会而满足上述定义的任何 ORF。\n\n确定最小整数 $L$（以密码子为单位），使得在整个基因组、两条链和所有阅读框中，假阳性 ORF 的期望数最多为 $\\alpha$。以密码子的最小整数形式报告您的答案。除了选择满足该标准的最小整数外，不需要进行其他舍入。",
            "solution": "对问题陈述进行验证。\n\n**步骤 1：提取已知条件**\n- 基因组长度：$N = 5 \\times 10^{6}$ 个核苷酸\n- 核苷酸频率：$p_{A} = 0.3$，$p_{T} = 0.3$，$p_{G} = 0.2$，$p_{C} = 0.2$\n- 序列模型：独立同分布（i.i.d.）的核苷酸\n- 密码子模型：连续密码子之间相互独立\n- ORF 定义：以 ATG 开始，后跟至少 $L$ 个同读码框的非终止密码子\n- 起始密码子：ATG\n- 终止密码子：TAA, TAG, TGA\n- 扫描参数：两条链，每条链三个阅读框\n- 统计阈值：全基因组范围内的假阳性 ORF 期望数最多为 $\\alpha = 0.05$\n- 目标：找到满足标准的最小整数 $L$（以密码子为单位）。\n\n**步骤 2：使用提取的已知条件进行验证**\n根据所需标准对问题进行评估。\n- **科学依据**：该问题基于计算生物学和统计学的基本原理。使用独立同分布（i.i.d.）随机序列模型来估计某个特征（一个 ORF）偶然出现的次数，是生物信息学中用于设定显著性阈值的标准技术。\n- **适定性**：问题定义清晰。它提供了所有必要的参数（$N$、核苷酸频率、$\\alpha$），以构建一个数学不等式并求解唯一的未知变量 $L$。预计会有一个唯一的整数解。\n- **客观性**：问题以精确、定量的术语陈述，没有任何主观或模棱两可的语言。\n\n**步骤 3：结论与行动**\n该问题在科学上是合理的、适定的和客观的。它不包含任何矛盾、缺失信息或逻辑缺陷。因此，它被判定为**有效**。将推导出一个解决方案。\n\n目标是找到最小整数 $L$，使得假阳性开放阅读框的期望数（表示为 $E[N_{FP}]$）不大于 $\\alpha$。这可以用不等式表示为：\n$$\nE[N_{FP}] \\leq \\alpha\n$$\n假阳性的期望数是一个 ORF 可能开始的位置数与在任何此类位置出现所需长度的随机 ORF 的概率的乘积。\n\n首先，我们根据提供的独立同分布（i.i.d.）核苷酸模型计算必要的概率。任何密码子的概率是其组成核苷酸概率的乘积。\n\n起始密码子 ATG 的概率为：\n$$\nP_{\\text{start}} = P(\\text{ATG}) = p_{A} \\times p_{T} \\times p_{G} = 0.3 \\times 0.3 \\times 0.2 = 0.018\n$$\n\n接下来，我们计算遇到三个终止密码子之一的概率：TAA、TAG、TGA。\n$$\nP(\\text{TAA}) = p_{T} \\times p_{A} \\times p_{A} = 0.3 \\times 0.3 \\times 0.3 = 0.027\n$$\n$$\nP(\\text{TAG}) = p_{T} \\times p_{A} \\times p_{G} = 0.3 \\times 0.3 \\times 0.2 = 0.018\n$$\n$$\nP(\\text{TGA}) = p_{T} \\times p_{G} \\times p_{A} = 0.3 \\times 0.2 \\times 0.3 = 0.018\n$$\n由于这些是互斥事件，随机选择的密码子是终止密码子的总概率是它们的和：\n$$\nP_{\\text{stop}} = P(\\text{TAA}) + P(\\text{TAG}) + P(\\text{TGA}) = 0.027 + 0.018 + 0.018 = 0.063\n$$\n因此，一个密码子*不是*终止密码子的概率是：\n$$\nP_{\\text{non-stop}} = 1 - P_{\\text{stop}} = 1 - 0.063 = 0.937\n$$\n\n一个假阳性 ORF 被定义为一个以起始密码子（ATG）开始，后跟至少 $L$ 个同读码框非终止密码子的序列。假设连续密码子之间相互独立，在特定密码子位置开始这样一个事件的概率 $p_{FP}$ 是：\n$$\np_{FP} = P_{\\text{start}} \\times (P_{\\text{non-stop}})^{L}\n$$\n\n接下来，我们必须确定我们测试 ORF 起始位置的总数 $N_{\\text{trials}}$。基因组在两条链上以及每条链的所有三个阅读框中进行扫描。对于一个长度为 $N$ 的长基因组，我们可以将在一个阅读框中密码子可能的起始位置数近似为 $N/3$。由于正向链上有三个阅读框，反向链上也有三个，因此不同、不重叠的密码子位置总数为 $6 \\times (N/3) = 2N$。一个更直接的看法是，两条链上的每个核苷酸位置（总共 $2N$ 个位置）都可以被视为一个特定阅读框中三联体的开始。因此，试验总数实际上是 $2N$。\n$$\nN_{\\text{trials}} = 2N = 2 \\times (5 \\times 10^{6}) = 10^{7}\n$$\n假阳性 ORF 的期望数是试验次数与每次试验中出现假阳性的概率的乘积：\n$$\nE[N_{FP}] = N_{\\text{trials}} \\times p_{FP} = 2N \\times P_{\\text{start}} \\times (P_{\\text{non-stop}})^{L}\n$$\n我们必须找到满足 $E[N_{FP}] \\leq \\alpha$ 的最小整数 $L$。我们将已知值代入不等式：\n$$\n2 \\times (5 \\times 10^{6}) \\times (0.018) \\times (0.937)^{L} \\leq 0.05\n$$\n$$\n10^{7} \\times 0.018 \\times (0.937)^{L} \\leq 0.05\n$$\n$$\n180000 \\times (0.937)^{L} \\leq 0.05\n$$\n我们分离出包含 $L$ 的项：\n$$\n(0.937)^{L} \\leq \\frac{0.05}{180000} = \\frac{1}{3600000}\n$$\n为了解出 $L$，我们对两边取自然对数：\n$$\n\\ln((0.937)^{L}) \\leq \\ln\\left(\\frac{1}{3600000}\\right)\n$$\n$$\nL \\ln(0.937) \\leq -\\ln(3600000)\n$$\n因为 $\\ln(0.937)$ 是一个负数，所以用它相除会改变不等号的方向：\n$$\nL \\geq \\frac{-\\ln(3600000)}{\\ln(0.937)} = \\frac{\\ln(3600000)}{-\\ln(0.937)}\n$$\n现在，我们计算这个值：\n$$\n\\ln(3600000) \\approx 15.09659\n$$\n$$\n\\ln(0.937) \\approx -0.065056\n$$\n$$\nL \\geq \\frac{15.09659}{-(-0.065056)} \\approx \\frac{15.09659}{0.065056} \\approx 232.054\n$$\n由于 $L$ 必须是整数且满足 $L \\geq 232.054$，因此 $L$ 的最小整数值为 $233$。这是起始密码子下游所需的最小密码子数，以确保全基因组范围内的假阳性期望数最多为 $0.05$。",
            "answer": "$$\n\\boxed{233}\n$$"
        },
        {
            "introduction": "虽然长度是区分真实基因和随机ORF的一个重要指标，但生物学特征提供了更强大的分辨能力。这项高级练习()引入了密码子适应指数（CAI），这是一个衡量基因对其宿主翻译机制适应程度的指标。通过计算并使用CAI对候选ORF进行排序，你将学会如何整合密码子使用偏好这一重要的生物学信息，以更精确地预测功能性基因。",
            "id": "2410622",
            "problem": "给定一个由字母表 $\\{\\text{A},\\text{C},\\text{G},\\text{T}\\}$ 构成的脱氧核糖核酸（DNA）字符串和一组参数。一个候选的开放阅读框（ORF）在某一股链和某一框架上被定义为任何一个以经典起始密码子 $\\text{ATG}$ 开始，并终止于沿同一股链和框架遇到的第一个框内终止密码子（$\\{\\text{TAA},\\text{TAG},\\text{TGA}\\}$ 中的一个）的最大子串。ORF 的有义密码子序列是指从起始密码子（含）到终止密码子（不含）之间的密码子列表（即，终止密码子不包含在有义密码子列表中）。对于一个长度为 $N$ 的 DNA，您必须考虑所有六个阅读框架：正向链上的三个框架（偏移量为 $0$, $1$, $2$，对应于框架 $+1$, $+2$, $+3$）和反向互补链上的三个框架（在反向互补链上偏移量为 $0$, $1$, $2$，对应于框架 $-1$, $-2$, $-3$）。对于反向互补链上由反向互补坐标中的半开区间 $[s',e')$ 定义的任何 ORF，其在正向链坐标系中的半开区间为 $[N-e',\\,N-s')$。\n\n对于任何长度为 $n \\ge 1$ 的有义密码子序列 $(c_1,c_2,\\ldots,c_n)$，密码子适应指数（CAI）定义为\n$$\n\\mathrm{CAI}(c_1,\\ldots,c_n)\\;=\\;\\left(\\prod_{i=1}^{n} w(c_i)\\right)^{1/n},\n$$\n其中 $w(c)$ 是与密码子 $c$ 相关联的非负权重，该权重源自一个固定的同义密码子偏好性参考集。对于本问题，您必须使用以下固定的密码子权重函数 $w(\\cdot)$（仅适用于有义密码子；终止密码子从不用于乘积计算）：\n- 丙氨酸 (Alanine): $w(\\text{GCT})=1.0$, $w(\\text{GCC})=0.9$, $w(\\text{GCA})=0.8$, $w(\\text{GCG})=0.7$。\n- 缬氨酸 (Valine): $w(\\text{GTT})=1.0$, $w(\\text{GTC})=0.9$, $w(\\text{GTA})=0.7$, $w(\\text{GTG})=0.6$。\n- 甘氨酸 (Glycine): $w(\\text{GGT})=1.0$, $w(\\text{GGC})=0.8$, $w(\\text{GGA})=0.7$, $w(\\text{GGG})=0.6$。\n- 脯氨酸 (Proline): $w(\\text{CCT})=1.0$, $w(\\text{CCC})=0.9$, $w(\\text{CCA})=0.8$, $w(\\text{CCG})=0.7$。\n- 苏氨酸 (Threonine): $w(\\text{ACT})=1.0$, $w(\\text{ACC})=0.9$, $w(\\text{ACA})=0.8$, $w(\\text{ACG})=0.7$。\n- 赖氨酸 (Lysine): $w(\\text{AAA})=1.0$, $w(\\text{AAG})=0.6$。\n- 谷氨酸 (Glutamate): $w(\\text{GAA})=1.0$, $w(\\text{GAG})=0.5$。\n- 精氨酸 (Arginine): $w(\\text{CGT})=1.0$, $w(\\text{CGC})=0.9$, $w(\\text{CGA})=0.6$, $w(\\text{CGG})=0.6$, $w(\\text{AGA})=0.5$, $w(\\text{AGG})=0.5$。\n- 苯丙氨酸 (Phenylalanine): $w(\\text{TTC})=1.0$, $w(\\text{TTT})=0.8$。\n- 异亮氨酸 (Isoleucine): $w(\\text{ATT})=1.0$, $w(\\text{ATC})=0.9$, $w(\\text{ATA})=0.5$。\n- 亮氨酸 (Leucine): $w(\\text{CTG})=1.0$, $w(\\text{CTT})=0.8$, $w(\\text{CTC})=0.7$, $w(\\text{CTA})=0.5$, $w(\\text{TTG})=0.6$, $w(\\text{TTA})=0.4$。\n- 丝氨酸 (Serine): $w(\\text{TCT})=1.0$, $w(\\text{TCC})=0.9$, $w(\\text{TCA})=0.8$, $w(\\text{TCG})=0.7$, $w(\\text{AGT})=0.6$, $w(\\text{AGC})=0.6$。\n- 天冬酰胺 (Asparagine): $w(\\text{AAT})=1.0$, $w(\\text{AAC})=0.9$。\n- 天冬氨酸 (Aspartate): $w(\\text{GAT})=1.0$, $w(\\text{GAC})=0.9$。\n- 谷氨酰胺 (Glutamine): $w(\\text{CAA})=1.0$, $w(\\text{CAG})=0.8$。\n- 组氨酸 (Histidine): $w(\\text{CAT})=1.0$, $w(\\text{CAC})=0.9$。\n- 酪氨酸 (Tyrosine): $w(\\text{TAC})=1.0$, $w(\\text{TAT})=0.9$。\n- 半胱氨酸 (Cysteine): $w(\\text{TGC})=1.0$, $w(\\text{TGT})=0.9$。\n- 甲硫氨酸 (Methionine): $w(\\text{ATG})=1.0$。\n- 色氨酸 (Tryptophan): $w(\\text{TGG})=1.0$。\n\n如果一个 ORF 中的任何有义密码子在上述列表中没有定义权重，则该 ORF 被视为不合格，必须被丢弃。将 ORF 的有义密码子长度定义为 $n$，即不包括终止密码子的有义密码子数量。一个 ORF 是可接受的，当且仅当 $n \\ge L_{\\min}$，其中 $L_{\\min}$ 是以密码子为单位的所提供的最小长度阈值。\n\n您的程序必须对每个测试用例，枚举所有六个框架中的所有可接受的 ORF，计算它们的 $\\mathrm{CAI}$，并使用以下按顺序应用的确定性平局决胜规则选择一个“最佳”ORF：\n- 最高的 $\\mathrm{CAI}$ 值。\n- 如果平局，则选择最大的有义密码子长度 $n$。\n- 如果仍然平局，则选择最小的正向链起始坐标 $s$（从零开始计数）。\n- 如果仍然平局，则根据顺序 $+1 \\prec +2 \\prec +3 \\prec -1 \\prec -2 \\prec -3$ 选择最小的框架排名。\n\n对于选定的 ORF，报告：\n- 框架，以 $\\{+1,+2,+3,-1,-2,-3\\}$ 中的整数表示，\n- ORF 半开区间 $[s,e)$ 在正向链上的起始坐标 $s$（以核苷酸为单位，从零开始计数），\n- 同一区间的正向链结束坐标 $e$（不包含在内），\n- $\\mathrm{CAI}$ 值，四舍五入到小数点后恰好 $4$ 位。\n\n如果在某个测试用例中不存在可接受的 ORF，则为该用例输出整数 $-1$。\n\n测试套件：\n为您的程序提供以下测试用例，每个用例都是一个 $(\\text{DNA}, L_{\\min})$ 对，其中 $L_{\\min}$ 以密码子为单位：\n- 用例 $1$：$\\left(\\text{ATGGCTGTTGGTCCTACTAAAGAACGTTTCATTTAA}\\,\\|\\text{GCCGCCGCC}\\,\\|\\text{ATGGCGGTGGGGCCGACGAAGGAGCGGTTTATCTAG},\\; L_{\\min}=8\\right)$，其中 $\\|$ 表示字符串拼接。\n- 用例 $2$：$\\left(\\text{TTAAGGACCAACAGCCATATGAAATGA},\\; L_{\\min}=5\\right)$。\n- 用例 $3$：$\\left(\\text{GGGGCCCCAAAATTTT},\\; L_{\\min}=3\\right)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含三个用例的结果，结果为一个用逗号分隔的列表，并用方括号括起来。每个结果要么是整数 $-1$，要么是一个包含四个元素的列表 $[\\text{frame}, s, e, \\mathrm{CAI}]$，其中 $\\mathrm{CAI}$ 显示为小数点后恰好 $4$ 位。例如，一个语法上有效的输出看起来像这样：$[[1,0,90,0.7123],[-2,5,41,0.6431],-1]$。不应打印任何额外的空白或文本。",
            "solution": "用户提供了一个计算生物学问题，要求根据一组标准在给定的 DNA 序列中找到最优的开放阅读框（ORF）。解决此问题的步骤如下：问题陈述的验证、算法的开发和实现。\n\n### 问题验证\n\n问题陈述已根据指定标准进行了评估：\n1.  **既定条件提取**：所有数据和定义均已提取。这包括 DNA 字母表 $\\{\\text{A},\\text{C},\\text{G},\\text{T}\\}$、起始密码子 $\\text{ATG}$、终止密码子 $\\{\\text{TAA},\\text{TAG},\\text{TGA}\\}$、六个阅读框架（三个正向，三个反向互补）、反向链的坐标映射、密码子适应指数（CAI）的公式、一个包含 $61$ 个密码子权重的完整表格、可接受 ORF 的定义（$n \\ge L_{\\min}$），以及用于选择最佳 ORF 的确定性平局决胜规则。\n2.  **科学依据**：该问题在分子生物学和计算生物学的既定原则中有充分的依据。ORF 查找、六框架翻译、起始/终止密码子以及 CAI 都是标准概念。该问题在科学上是合理的。\n3.  **适定性与客观性**：该问题是适定的。所有术语都经过数学上的精确定义。目标函数（CAI）和平局决胜规则是明确的，确保存在唯一解。语言客观，没有主观论断。\n4.  **完整性与一致性**：该问题是自洽的，提供了所有必要信息。所提供的密码子权重列表覆盖了所有 $61$ 个有义密码子，使系统完整。定义或约束中没有矛盾。\n\n**结论**：问题有效。可以构建一个合理的解决方案。\n\n### 算法解决方案\n\n任务的核心是系统地枚举所有六个阅读框架中的所有可接受的 ORF，计算它们的属性，然后根据一个多级排序标准选择最佳的一个。\n\n**1. 六框架翻译与 ORF 识别**\n\n一个长度为 $N$ 的 DNA 序列有六个阅读框架。三个在正向链上，三个在反向互补链上。\n-   **正向框架 (+1, +2, +3)**：这些对应于从偏移量 $0$、$1$ 和 $2$ 开始分别读取 DNA 序列。\n-   **反向框架 (-1, -2, -3)**：这些对应于读取 DNA 序列的反向互补链，同样使用偏移量 $0$、$1$ 和 $2$。这些框架表示为 $-1, -2, -3$。\n\n对于六个框架中的每一个，我们必须识别所有候选的 ORF。一个候选 ORF 是一个以密码子 $\\text{ATG}$ 开始并以第一个框内终止密码子（$\\text{TAA}$、$\\text{TAG}$ 或 $\\text{TGA}$）结束的最大序列。这意味着，对于在给定框架中出现的每一个 $\\text{ATG}$ 密码子，我们必须在同一框架内向下游扫描以找到第一个终止密码子。由于 ORF 可以嵌套，这个过程必须对找到的每一个 $\\text{ATG}$ 重复进行。\n\n**2. ORF 可接受性与属性计算**\n\n对于找到的每个候选 ORF，我们确定其属性：\n-   **有义密码子序列和长度 ($n$)**：这是从 $\\text{ATG}$ 开始直到（但不包括）终止密码子的密码子序列。其长度 $n$ 是这些密码子的数量。如果一个 ORF 的有义密码子长度 $n$ 大于或等于给定的最小阈值 $L_{\\min}$，则该 ORF 被视为**可接受的**。\n-   **密码子适应指数 (CAI)**：对于一个有义密码子为 $(c_1, c_2, \\ldots, c_n)$ 的可接受 ORF，CAI 是其权重 $w(c_i)$ 的几何平均值：\n    $$\n    \\mathrm{CAI} = \\left(\\prod_{i=1}^{n} w(c_i)\\right)^{1/n}\n    $$\n    为确保数值稳定性，特别是对于长 ORF，其权重的乘积可能导致浮点数下溢，计算上最好使用对数：\n    $$\n    \\ln(\\mathrm{CAI}) = \\frac{1}{n} \\sum_{i=1}^{n} \\ln(w(c_i)) \\implies \\mathrm{CAI} = \\exp\\left(\\frac{1}{n} \\sum_{i=1}^{n} \\ln(w(c_i))\\right)\n    $$\n-   **坐标和框架**：ORF 的起始 ($s$) 和结束 ($e$) 坐标必须在正向链、从零开始的坐标系中报告。对于正向链上从索引 $s_{fwd}$ 开始并以索引 $j_{fwd}$ 处的终止密码子结束的 ORF，其区间为 $[s, e) = [s_{fwd}, j_{fwd}+3)$。对于在反向互补序列上找到的区间为 $[s', e')$ 的 ORF，其在正向链上的坐标由转换 $[s, e) = [N-e', N-s')$ 给出。框架是 $\\{+1, +2, +3, -1, -2, -3\\}$ 中的一个。\n\n**3. 最佳 ORF 的选择**\n\n收集所有六个框架中的所有可接受的 ORF。如果没有找到可接受的 ORF，则该测试用例的处理终止，结果为 $-1$。否则，使用指定的平局决胜层次结构对收集到的 ORF 进行排序，以找到唯一的最佳 ORF：\n1.  **最高的 CAI 值**：按 CAI 降序排序。\n2.  **最大的有义密码子长度 $n$**：对于 CAI 相同的平局，按 $n$ 降序排序。\n3.  **最小的正向链起始坐标 $s$**：对于进一步的平局，按 $s$ 升序排序。\n4.  **最小的框架排名**：作为最后的平局决胜规则，按指定的顺序对框架进行排序：$+1 \\prec +2 \\prec +3 \\prec -1 \\prec -2 \\prec -3$。这可以通过将框架映射到整数排名 $\\{+1:0, +2:1, \\ldots, -3:5\\}$ 并按排名升序排序来实现。\n\n经过这种多级排序后排在第一位的 ORF 即为“最佳” ORF。然后报告其属性（框架、$s$、$e$ 和四舍五入到小数点后四位的 CAI）。这个系统化的过程保证了能够根据问题陈述识别出唯一的、最优的 ORF。",
            "answer": "```python\nimport numpy as np\nimport math\n\n# Fixed parameters and definitions from the problem statement\nCODON_WEIGHTS = {\n    'GCT': 1.0, 'GCC': 0.9, 'GCA': 0.8, 'GCG': 0.7,  # Alanine\n    'GTT': 1.0, 'GTC': 0.9, 'GTA': 0.7, 'GTG': 0.6,  # Valine\n    'GGT': 1.0, 'GGC': 0.8, 'GGA': 0.7, 'GGG': 0.6,  # Glycine\n    'CCT': 1.0, 'CCC': 0.9, 'CCA': 0.8, 'CCG': 0.7,  # Proline\n    'ACT': 1.0, 'ACC': 0.9, 'ACA': 0.8, 'ACG': 0.7,  # Threonine\n    'AAA': 1.0, 'AAG': 0.6,                           # Lysine\n    'GAA': 1.0, 'GAG': 0.5,                           # Glutamate\n    'CGT': 1.0, 'CGC': 0.9, 'CGA': 0.6, 'CGG': 0.6, 'AGA': 0.5, 'AGG': 0.5,  # Arginine\n    'TTC': 1.0, 'TTT': 0.8,                           # Phenylalanine\n    'ATT': 1.0, 'ATC': 0.9, 'ATA': 0.5,               # Isoleucine\n    'CTG': 1.0, 'CTT': 0.8, 'CTC': 0.7, 'CTA': 0.5, 'TTG': 0.6, 'TTA': 0.4,  # Leucine\n    'TCT': 1.0, 'TCC': 0.9, 'TCA': 0.8, 'TCG': 0.7, 'AGT': 0.6, 'AGC': 0.6,  # Serine\n    'AAT': 1.0, 'AAC': 0.9,                           # Asparagine\n    'GAT': 1.0, 'GAC': 0.9,                           # Aspartate\n    'CAA': 1.0, 'CAG': 0.8,                           # Glutamine\n    'CAT': 1.0, 'CAC': 0.9,                           # Histidine\n    'TAC': 1.0, 'TAT': 0.9,                           # Tyrosine\n    'TGC': 1.0, 'TGT': 0.9,                           # Cysteine\n    'ATG': 1.0,                                       # Methionine\n    'TGG': 1.0,                                       # Tryptophan\n}\nSTART_CODON = 'ATG'\nSTOP_CODONS = {'TAA', 'TAG', 'TGA'}\nFRAME_RANKS = {1: 0, 2: 1, 3: 2, -1: 3, -2: 4, -3: 5}\nCOMPLEMENT_DNA = str.maketrans('ATCG', 'TAGC')\n\ndef get_reverse_complement(dna_seq):\n    \"\"\"Computes the reverse complement of a DNA sequence.\"\"\"\n    return dna_seq.translate(COMPLEMENT_DNA)[::-1]\n\ndef process_case(dna_seq, L_min):\n    \"\"\"Finds the best ORF for a given DNA sequence and minimum length.\"\"\"\n    admissible_orfs = []\n    N = len(dna_seq)\n\n    # Process both forward and reverse-complement strands\n    for strand_type in ['forward', 'reverse']:\n        seq = dna_seq if strand_type == 'forward' else get_reverse_complement(dna_seq)\n        \n        # Iterate through the three reading frames for the current strand\n        for frame_offset in range(3):\n            # Scan for all potential start codons within the current frame\n            for i in range(frame_offset, len(seq) - 2, 3):\n                if seq[i:i+3] == START_CODON:\n                    start_pos_in_strand = i\n                    sense_codons = []\n                    \n                    # Find the first in-frame stop codon after the start\n                    for j in range(start_pos_in_strand, len(seq) - 2, 3):\n                        codon = seq[j:j+3]\n                        if codon in STOP_CODONS:\n                            # ORF is defined, check for admissibility\n                            n = len(sense_codons)\n                            if n >= L_min:\n                                # Calculate CAI using logarithms for numerical stability\n                                weights = [CODON_WEIGHTS[c] for c in sense_codons]\n                                if 0 in weights:\n                                    cai = 0.0\n                                else:\n                                    cai = np.exp(np.mean(np.log(weights)))\n                                \n                                # Determine frame number and forward-strand coordinates\n                                if strand_type == 'forward':\n                                    frame = frame_offset + 1\n                                    s = start_pos_in_strand\n                                    e = j + 3\n                                else:  # reverse strand\n                                    frame = -(frame_offset + 1)\n                                    s_prime = start_pos_in_strand\n                                    e_prime = j + 3\n                                    s = N - e_prime\n                                    e = N - s_prime\n                                \n                                frame_rank = FRAME_RANKS[frame]\n                                \n                                admissible_orfs.append({\n                                    'cai': cai, 'n': n, 's': s,\n                                    'frame_rank': frame_rank, 'frame': frame, 'e': e\n                                })\n                            \n                            # Break inner loop since we found the first stop codon\n                            break\n                        \n                        sense_codons.append(codon)\n\n    if not admissible_orfs:\n        return -1\n\n    # Sort ORFs based on the specified tie-breaking rules\n    admissible_orfs.sort(key=lambda o: (-o['cai'], -o['n'], o['s'], o['frame_rank']))\n    \n    best_orf = admissible_orfs[0]\n    return [best_orf['frame'], best_orf['s'], best_orf['e'], best_orf['cai']]\n\ndef to_string_repr(item):\n    \"\"\"Formats an ORF result list or integer into the required string format.\"\"\"\n    if isinstance(item, int):\n        return str(item)\n    frame, s, e, cai = item\n    return f\"[{frame},{s},{e},{cai:.4f}]\"\n\ndef solve():\n    \"\"\"Main function to run the test suite and print results.\"\"\"\n    test_cases = [\n        (\n            \"ATGGCTGTTGGTCCTACTAAAGAACGTTTCATTTAA\" + \n            \"GCCGCCGCC\" +\n            \"ATGGCGGTGGGGCCGACGAAGGAGCGGTTTATCTAG\",\n            8\n        ),\n        (\n            \"TTAAGGACCAACAGCCATATGAAATGA\",\n            5\n        ),\n        (\n            \"GGGGCCCCAAAATTTT\",\n            3\n        ),\n    ]\n\n    results = [process_case(dna, l_min) for dna, l_min in test_cases]\n    output_strings = [to_string_repr(res) for res in results]\n    \n    print(f\"[{','.join(output_strings)}]\")\n\nsolve()\n```"
        }
    ]
}