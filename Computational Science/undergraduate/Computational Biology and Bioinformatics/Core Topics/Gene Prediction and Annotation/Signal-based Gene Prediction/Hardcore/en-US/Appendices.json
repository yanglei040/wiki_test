{
    "hands_on_practices": [
        {
            "introduction": "To effectively use signal-based models, we must first grasp the mechanics of how they score sequences. This exercise delves into the fundamental properties of a Position Weight Matrix (PWM), a common tool for modeling sequence motifs like splice sites. By deriving an expression for the score range—the difference between the highest and lowest possible scores—you will build a core understanding of how PWMs quantify the strength of a signal based on its sequence composition. ",
            "id": "2429061",
            "problem": "In signal-based gene prediction for splice donor sites, a sequence model often uses a position weight matrix (PWM) to score candidates. Consider a position weight matrix (PWM) of length $L$ over the deoxyribonucleic acid (DNA) alphabet $\\mathcal{B} = \\{A, C, G, T\\}$. For each position $i \\in \\{1,\\dots,L\\}$ and base $b \\in \\mathcal{B}$, the matrix contains a log-odds weight $w_{i,b} = \\ln\\!\\left(\\frac{p_{i,b}}{q_b}\\right)$, where $p_{i,b}$ is the probability assigned by the splice-site model at position $i$ to base $b$, and $q_b$ is the background probability of base $b$ in the genome. Assume $p_{i,b} > 0$ and $q_b > 0$ for all $i$ and $b$ so that all weights are finite. The PWM score of a length-$L$ DNA sequence $\\mathbf{s} = (s_{1},\\dots,s_{L}) \\in \\mathcal{B}^{L}$ is defined as\n$$\nS(\\mathbf{s}) = \\sum_{i=1}^{L} w_{i, s_{i}}.\n$$\nLet $S_{\\max}$ be the maximum possible PWM score over all sequences $\\mathbf{s} \\in \\mathcal{B}^{L}$ and $S_{\\min}$ be the minimum possible PWM score over all sequences $\\mathbf{s} \\in \\mathcal{B}^{L}$. Define $\\Delta = S_{\\max} - S_{\\min}$.\n\nDerive a single closed-form analytical expression for $\\Delta$ in terms of the entries $w_{i,b}$ of the PWM only. Your final answer must be this expression. No rounding is required.",
            "solution": "The problem as stated is scientifically grounded, well-posed, and objective. It presents a standard formulation from bioinformatics for scoring sequence motifs using a position weight matrix (PWM). All terms are defined rigorously, and the objective is to derive a mathematical expression based on these definitions. The problem is therefore valid and permits a direct analytical solution.\n\nThe PWM score for a DNA sequence $\\mathbf{s} = (s_{1}, \\dots, s_{L})$ is defined as a sum over the positions of the sequence:\n$$\nS(\\mathbf{s}) = \\sum_{i=1}^{L} w_{i, s_{i}}\n$$\nwhere $w_{i, s_{i}}$ is the log-odds weight for observing the base $s_{i}$ at position $i$. The choice of base $s_i$ at any given position $i$ is independent of the choice of base $s_j$ at any other position $j \\neq i$. The total score $S(\\mathbf{s})$ is a sum of $L$ independent terms, where the $i$-th term's value, $w_{i, s_i}$, is determined solely by the base $s_i$ chosen for position $i$.\n\nTo find the maximum possible score, $S_{\\max}$, we must maximize this sum. Due to the independence of the terms, the sum is maximized when each individual term is maximized. For each position $i \\in \\{1, \\dots, L\\}$, we must select the base $s_i$ from the alphabet $\\mathcal{B} = \\{A, C, G, T\\}$ that corresponds to the largest possible weight $w_{i,b}$. Let us define the maximum weight for each position $i$ as:\n$$\nw_{i, \\max} = \\max_{b \\in \\mathcal{B}} \\{w_{i,b}\\}\n$$\nThe sequence that achieves the maximum score is therefore $\\mathbf{s}_{\\max} = (s_{1,\\max}, \\dots, s_{L,\\max})$, where $s_{i,\\max}$ is the base that provides the weight $w_{i, \\max}$ at each position $i$. The maximum score, $S_{\\max}$, is the sum of these maximum positional weights:\n$$\nS_{\\max} = \\sum_{i=1}^{L} w_{i, \\max} = \\sum_{i=1}^{L} \\left( \\max_{b \\in \\mathcal{B}} \\{w_{i,b}\\} \\right)\n$$\n\nBy analogous reasoning, to find the minimum possible score, $S_{\\min}$, we must minimize the sum $S(\\mathbf{s})$. This is achieved by minimizing each independent term in the summation. For each position $i$, we select the base $s_i$ from $\\mathcal{B}$ that corresponds to the smallest possible weight $w_{i,b}$. Let us define the minimum weight for each position $i$ as:\n$$\nw_{i, \\min} = \\min_{b \\in \\mathcal{B}} \\{w_{i,b}\\}\n$$\nThe sequence that achieves the minimum score is $\\mathbf{s}_{\\min} = (s_{1,\\min}, \\dots, s_{L,\\min})$, where $s_{i,\\min}$ is the base that provides the weight $w_{i, \\min}$ at each position $i$. The minimum score, $S_{\\min}$, is the sum of these minimum positional weights:\n$$\nS_{\\min} = \\sum_{i=1}^{L} w_{i, \\min} = \\sum_{i=1}^{L} \\left( \\min_{b \\in \\mathcal{B}} \\{w_{i,b}\\} \\right)\n$$\n\nThe problem requires the derivation of $\\Delta = S_{\\max} - S_{\\min}$. We substitute the expressions derived for $S_{\\max}$ and $S_{\\min}$:\n$$\n\\Delta = \\left( \\sum_{i=1}^{L} \\max_{b \\in \\mathcal{B}} \\{w_{i,b}\\} \\right) - \\left( \\sum_{i=1}^{L} \\min_{b \\in \\mathcal{B}} \\{w_{i,b}\\} \\right)\n$$\nUsing the linearity property of the summation operator, we can combine the two sums into a single sum:\n$$\n\\Delta = \\sum_{i=1}^{L} \\left( \\max_{b \\in \\mathcal{B}} \\{w_{i,b}\\} - \\min_{b \\in \\mathcal{B}} \\{w_{i,b}\\} \\right)\n$$\nThis is the final closed-form analytical expression for $\\Delta$. It represents the sum, over all positions in the PWM, of the difference between the maximum and minimum possible log-odds weight at that position. This quantity is often referred to as the information content range of the PWM.",
            "answer": "$$\n\\boxed{\\sum_{i=1}^{L} \\left( \\max_{b \\in \\mathcal{B}} \\{w_{i,b}\\} - \\min_{b \\in \\mathcal{B}} \\{w_{i,b}\\} \\right)}\n$$"
        },
        {
            "introduction": "With a solid understanding of PWM scoring, we can now apply it to a critical task in bioinformatics: predicting the functional impact of genetic variants. This practice guides you through a virtual perturbation analysis, where you systematically mutate each position in a putative splice site and calculate the resulting change in its score. This *in silico* experiment provides direct, hands-on experience in quantifying how single nucleotide changes can weaken or \"break\" essential biological signals, a key skill in computational genetics. ",
            "id": "2429077",
            "problem": "You are given a finite alphabet $\\Sigma=\\{\\text{A},\\text{C},\\text{G},\\text{T}\\}$ and a windowed sequence model of length $L$ around a putative splice site. For a sequence $s$ of length $L$ over $\\Sigma$, its score $S(s)$ under a Position Weight Matrix (PWM) model is defined by\n$$\nS(s) \\;=\\; \\sum_{i=1}^{L} \\ln\\!\\left(\\frac{P_{i,b_i}}{Q_{b_i}}\\right),\n$$\nwhere $b_i \\in \\Sigma$ is the base at position $i$ in $s$, $P_{i,\\cdot}$ is the position-specific multinomial distribution over $\\Sigma$ for position $i$, $Q_{\\cdot}$ is the background multinomial distribution over $\\Sigma$, and $\\ln(\\cdot)$ denotes the natural logarithm. The order of nucleotides within any vector is fixed as $[\\text{A},\\text{C},\\text{G},\\text{T}]$.\n\nFor each position $i \\in \\{1,\\dots,L\\}$ and each possible point mutation that replaces the reference base $r_i$ with a different base $b \\in \\Sigma \\setminus \\{r_i\\}$, define the single-mutation change in score\n$$\n\\Delta S(i,b) \\;=\\; S\\big(s^{(i \\rightarrow b)}\\big) \\;-\\; S(s),\n$$\nwhere $s^{(i \\rightarrow b)}$ is the sequence equal to $s$ except at position $i$ where it has base $b$ instead of $r_i$. For each position $i$, define the positional sensitivity as the most deleterious single-mutation change\n$$\n\\Delta S_{\\min}(i) \\;=\\; \\min_{b \\in \\Sigma \\setminus \\{r_i\\}} \\Delta S(i,b).\n$$\n\nYour task is to compute $\\Delta S_{\\min}(i)$ for all positions $i$ in each test case below, rounding each value to $6$ decimal places.\n\nTest Suite (all probabilities are given in the order $[\\text{A},\\text{C},\\text{G},\\text{T}]$):\n\n- Test case $1$ (donor-like PWM with strong $\\text{G}\\text{T}$ at positions around the splice junction):\n  - Length $L = 9$.\n  - Background distribution $Q = [\\,0.30,\\,0.20,\\,0.20,\\,0.30\\,]$.\n  - Reference sequence $s = \\text{\"CAGGTAAGT\"}$.\n  - PWM probabilities $P$ as rows $P_{i,\\cdot}$ for $i=1,\\dots,9$:\n    - $i=1$: $[\\,0.35,\\,0.25,\\,0.25,\\,0.15\\,]$\n    - $i=2$: $[\\,0.40,\\,0.20,\\,0.25,\\,0.15\\,]$\n    - $i=3$: $[\\,0.45,\\,0.15,\\,0.25,\\,0.15\\,]$\n    - $i=4$: $[\\,0.07,\\,0.07,\\,0.80,\\,0.06\\,]$\n    - $i=5$: $[\\,0.06,\\,0.07,\\,0.07,\\,0.80\\,]$\n    - $i=6$: $[\\,0.30,\\,0.25,\\,0.25,\\,0.20\\,]$\n    - $i=7$: $[\\,0.60,\\,0.15,\\,0.15,\\,0.10\\,]$\n    - $i=8$: $[\\,0.20,\\,0.20,\\,0.50,\\,0.10\\,]$\n    - $i=9$: $[\\,0.20,\\,0.20,\\,0.10,\\,0.50\\,]$\n\n- Test case $2$ (same PWM and background as test case $1$, different reference sequence):\n  - Length $L = 9$.\n  - Background distribution $Q = [\\,0.30,\\,0.20,\\,0.20,\\,0.30\\,]$.\n  - Reference sequence $s = \\text{\"TAGGTGAGT\"}$.\n  - PWM probabilities $P$ identical to those in test case $1$.\n\n- Test case $3$ (uninformative PWM equal to background, edge case):\n  - Length $L = 6$.\n  - Background distribution $Q = [\\,0.25,\\,0.25,\\,0.25,\\,0.25\\,]$.\n  - Reference sequence $s = \\text{\"ACGTAC\"}$.\n  - PWM probabilities $P$ with every row equal to $[\\,0.25,\\,0.25,\\,0.25,\\,0.25\\,]$.\n\nFinal Output Format:\n\nYour program should produce a single line of output containing the results as a comma-separated nested list enclosed in square brackets, where each inner list corresponds to one test case and contains $L$ floating-point values for $\\Delta S_{\\min}(i)$ in positional order $i=1$ to $i=L$. For example, an output with three test cases must look like $[[x_{1,1},\\dots,x_{1,L_1}],[x_{2,1},\\dots,x_{2,L_2}],[x_{3,1},\\dots,x_{3,L_3}]]$, where each $x_{t,i}$ is rounded to $6$ decimal places. No units are involved, and no additional text should be printed.",
            "solution": "The problem statement has been rigorously validated and is determined to be sound. It is scientifically grounded in the principles of bioinformatics and statistical sequence analysis, is well-posed with all necessary information provided, and is formulated objectively using precise mathematical definitions. No flaws were found. We may proceed with the solution.\n\nThe problem asks for the computation of the positional sensitivity, $\\Delta S_{\\min}(i)$, for each position $i$ in a given nucleotide sequence $s$. This sensitivity is defined as the most deleterious change in a sequence score $S(s)$ resulting from a single point mutation at that position. The score itself is based on a Position Weight Matrix (PWM) model, which is a common representation of sequence motifs.\n\nThe score $S(s)$ for a sequence $s = b_1 b_2 \\dots b_L$ is a log-likelihood ratio, given by:\n$$\nS(s) = \\sum_{i=1}^{L} \\ln\\left(\\frac{P_{i,b_i}}{Q_{b_i}}\\right)\n$$\nHere, $P_{i,b_i}$ is the probability of observing base $b_i$ at position $i$ according to the motif model, and $Q_{b_i}$ is the probability of observing base $b_i$ according to a background model. This score quantifies how much more likely the sequence $s$ is under the motif model compared to the background.\n\nWe are asked to find the change in score, $\\Delta S(i,b)$, when the reference base $r_i$ at a single position $i$ is mutated to a new base $b \\in \\Sigma \\setminus \\{r_i\\}$. The original sequence is $s$, and the mutated sequence is $s^{(i \\rightarrow b)}$. The change in score is:\n$$\n\\Delta S(i,b) = S\\big(s^{(i \\rightarrow b)}\\big) - S(s)\n$$\n\nLet us expand this expression. The score for the original sequence $s$, which has reference bases $r_j$ at each position $j$, is:\n$$\nS(s) = \\sum_{j=1}^{L} \\ln\\left(\\frac{P_{j,r_j}}{Q_{r_j}}\\right) = \\ln\\left(\\frac{P_{i,r_i}}{Q_{r_i}}\\right) + \\sum_{j \\neq i} \\ln\\left(\\frac{P_{j,r_j}}{Q_{j,r_j}}\\right)\n$$\nThe score for the mutated sequence $s^{(i \\rightarrow b)}$, which differs only at position $i$, is:\n$$\nS\\big(s^{(i \\rightarrow b)}\\big) = \\ln\\left(\\frac{P_{i,b}}{Q_b}\\right) + \\sum_{j \\neq i} \\ln\\left(\\frac{P_{j,r_j}}{Q_{r_j}}\\right)\n$$\nWhen we compute the difference $\\Delta S(i,b)$, the summation term, which represents the contribution from all unchanged positions, cancels out completely. This significantly simplifies the calculation:\n$$\n\\Delta S(i,b) = \\left( \\ln\\left(\\frac{P_{i,b}}{Q_b}\\right) + \\sum_{j \\neq i} \\ln\\left(\\frac{P_{j,r_j}}{Q_{r_j}}\\right) \\right) - \\left( \\ln\\left(\\frac{P_{i,r_i}}{Q_{r_i}}\\right) + \\sum_{j \\neq i} \\ln\\left(\\frac{P_{j,r_j}}{Q_{r_j}}\\right) \\right)\n$$\n$$\n\\Delta S(i,b) = \\ln\\left(\\frac{P_{i,b}}{Q_b}\\right) - \\ln\\left(\\frac{P_{i,r_i}}{Q_{r_i}}\\right)\n$$\nThis shows that the change in the total score due to a mutation at position $i$ depends only on the probabilities defined for that specific position. Let us define the log-odds score for a base $x$ at position $i$ as $L_i(x) = \\ln(P_{i,x}/Q_x)$. Then, $\\Delta S(i,b) = L_i(b) - L_i(r_i)$.\n\nThe positional sensitivity, $\\Delta S_{\\min}(i)$, is the minimum such change over all possible mutations at position $i$.\n$$\n\\Delta S_{\\min}(i) = \\min_{b \\in \\Sigma \\setminus \\{r_i\\}} \\Delta S(i,b)\n$$\nSubstituting our simplified expression for $\\Delta S(i,b)$:\n$$\n\\Delta S_{\\min}(i) = \\min_{b \\in \\Sigma \\setminus \\{r_i\\}} \\left( \\ln\\left(\\frac{P_{i,b}}{Q_b}\\right) - \\ln\\left(\\frac{P_{i,r_i}}{Q_{r_i}}\\right) \\right)\n$$\nSince the term $\\ln(P_{i,r_i}/Q_{r_i})$ is constant with respect to the minimization variable $b$, we can write:\n$$\n\\Delta S_{\\min}(i) = \\left( \\min_{b \\in \\Sigma \\setminus \\{r_i\\}} \\ln\\left(\\frac{P_{i,b}}{Q_b}\\right) \\right) - \\ln\\left(\\frac{P_{i,r_i}}{Q_{r_i}}\\right)\n$$\n\nThe algorithm to compute $\\Delta S_{\\min}(i)$ for each position $i=1, \\dots, L$ is as follows:\n1.  For each position $i$ in the reference sequence $s$, identify the reference base $r_i$.\n2.  Using the provided PWM $P$ and background distribution $Q$, calculate the log-odds score for the reference base: $L_i(r_i) = \\ln(P_{i,r_i}/Q_{r_i})$.\n3.  For each of the three possible mutant bases $b \\in \\Sigma \\setminus \\{r_i\\}$, calculate its corresponding log-odds score: $L_i(b) = \\ln(P_{i,b}/Q_b)$.\n4.  Find the minimum value among the three mutant log-odds scores: $L_{i, \\text{min\\_mut}} = \\min_{b \\in \\Sigma \\setminus \\{r_i\\}} L_i(b)$.\n5.  The positional sensitivity is the difference between the minimum mutant score and the reference score: $\\Delta S_{\\min}(i) = L_{i, \\text{min\\_mut}} - L_i(r_i)$.\n6.  This procedure is repeated for all positions $i=1, \\dots, L$ for each test case. The results are rounded to $6$ decimal places.\n\nFor the special case where the PWM is uninformative and equal to the background distribution (i.e., $P_{i,b} = Q_b$ for all $i, b$), the log-odds score for any base at any position is $\\ln(1) = 0$. Consequently, $\\Delta S(i,b) = 0 - 0 = 0$ for all mutations, and thus $\\Delta S_{\\min}(i) = 0$ for all positions. This is confirmed by the calculation for Test Case $3$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the positional sensitivity problem for the given test suite.\n    \"\"\"\n    \n    # Define a mapping from nucleotide characters to array indices.\n    base_to_idx = {'A': 0, 'C': 1, 'G': 2, 'T': 3}\n    idx_to_base = ['A', 'C', 'G', 'T']\n    \n    # Define the test cases from the problem statement.\n    p_matrix_tc1 = np.array([\n        [0.35, 0.25, 0.25, 0.15],\n        [0.40, 0.20, 0.25, 0.15],\n        [0.45, 0.15, 0.25, 0.15],\n        [0.07, 0.07, 0.80, 0.06],\n        [0.06, 0.07, 0.07, 0.80],\n        [0.30, 0.25, 0.25, 0.20],\n        [0.60, 0.15, 0.15, 0.10],\n        [0.20, 0.20, 0.50, 0.10],\n        [0.20, 0.20, 0.10, 0.50]\n    ])\n    \n    p_matrix_tc3 = np.array([\n        [0.25, 0.25, 0.25, 0.25],\n        [0.25, 0.25, 0.25, 0.25],\n        [0.25, 0.25, 0.25, 0.25],\n        [0.25, 0.25, 0.25, 0.25],\n        [0.25, 0.25, 0.25, 0.25],\n        [0.25, 0.25, 0.25, 0.25],\n    ])\n\n    test_cases = [\n        {\n            \"L\": 9,\n            \"Q\": np.array([0.30, 0.20, 0.20, 0.30]),\n            \"s\": \"CAGGTAAGT\",\n            \"P\": p_matrix_tc1\n        },\n        {\n            \"L\": 9,\n            \"Q\": np.array([0.30, 0.20, 0.20, 0.30]),\n            \"s\": \"TAGGTGAGT\",\n            \"P\": p_matrix_tc1\n        },\n        {\n            \"L\": 6,\n            \"Q\": np.array([0.25, 0.25, 0.25, 0.25]),\n            \"s\": \"ACGTAC\",\n            \"P\": p_matrix_tc3\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        L = case[\"L\"]\n        Q = case[\"Q\"]\n        s = case[\"s\"]\n        P = case[\"P\"]\n        \n        positional_sensitivities = []\n        for i in range(L):\n            # Identify reference base and its index\n            ref_base = s[i]\n            ref_idx = base_to_idx[ref_base]\n            \n            # Get the PWM probabilities for the current position\n            p_row = P[i]\n            \n            # Calculate log-odds score for the reference base\n            ref_log_odds = np.log(p_row[ref_idx] / Q[ref_idx])\n\n            # Calculate log-odds scores for all possible mutations\n            mutant_log_odds = []\n            for b_idx in range(4): # 4 bases in the alphabet\n                if b_idx != ref_idx:\n                    log_odds = np.log(p_row[b_idx] / Q[b_idx])\n                    mutant_log_odds.append(log_odds)\n            \n            # Find the minimum (most deleterious) mutant score\n            min_mutant_log_odds = min(mutant_log_odds)\n\n            # Calculate positional sensitivity delta_S_min(i)\n            delta_s_min = min_mutant_log_odds - ref_log_odds\n            \n            # Round to 6 decimal places and append\n            positional_sensitivities.append(round(delta_s_min, 6))\n            \n        all_results.append(positional_sensitivities)\n\n    # Format the final output string as a nested list string.\n    # The str() representation of a Python list is exactly the format required.\n    # Whitespace must be removed for exact match.\n    output_str = f\"[{','.join(str(res).replace(' ', '') for res in all_results)}]\"\n    \n    # Final print statement in the exact required format.\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "Predicting a gene is more complex than just identifying isolated signals; it requires assembling a coherent structure from a collection of candidate exons and introns. This advanced exercise reframes gene prediction as a 'pathfinding' challenge on a graph of potential signals. You will use dynamic programming to find the \"shortest path\"—the gene structure with the lowest overall cost—by integrating signal scores with penalties for exon and intron lengths, mimicking the sophisticated logic of modern gene prediction algorithms. ",
            "id": "2429125",
            "problem": "You are given a formal model of signal-based gene prediction that treats the decoding of a gene as a constrained minimization problem over a directed acyclic graph whose nodes are candidate genomic signals. Each candidate is a putative biological signal on a Deoxyribonucleic Acid (DNA) sequence, such as a promoter, a start codon, a splice donor site, a splice acceptor site, or a stop codon. Positions are measured in base pairs (bp). You are provided with candidates, their positions, and their nonnegative signal costs. The goal is to select an ordered subset of these candidates that forms a valid gene structure with minimal total cost. The total cost combines the contributions from selected signal costs and length-model penalties for exons and introns.\n\nDefinitions and notation:\n- Let $S$ be a DNA sequence of length $N$ base pairs (bp).\n- Each candidate signal $j$ has:\n  - A type $t_j \\in \\{\\text{P}, \\text{S}, \\text{D}, \\text{A}, \\text{T}\\}$, denoting Promoter (P), Start codon (S), splice Donor (D), splice Acceptor (A), and sTop codon (T), respectively.\n  - A genomic position $p_j \\in \\{1,2,\\dots,N\\}$ in bp.\n  - A nonnegative signal cost $c_j \\ge 0$.\n- A valid gene structure is an ordered sequence of candidates whose types follow the pattern:\n  - One Promoter $\\rightarrow$ one Start codon $\\rightarrow$ zero or more repetitions of (Donor $\\rightarrow$ Acceptor) pairs $\\rightarrow$ one Stop codon.\n  - The positions must be strictly increasing along the selected sequence: if candidates $i$ and $k$ are consecutive in the sequence, then $p_i < p_k$.\n- The promoter-to-start distance must satisfy a constraint: if promoter is at $p_{\\text{P}}$ and start is at $p_{\\text{S}}$, then the distance $d = p_{\\text{S}} - p_{\\text{P}}$ must satisfy $D_{\\min} \\le d \\le D_{\\max}$.\n- Exon segments are contiguous coding stretches between:\n  - Start $\\rightarrow$ Donor,\n  - Acceptor $\\rightarrow$ Donor (for internal exons),\n  - Acceptor $\\rightarrow$ Stop,\n  - Start $\\rightarrow$ Stop (for single-exon genes with no intron).\n- Intron segments are contiguous noncoding stretches between Donor $\\rightarrow$ Acceptor.\n- Let $L$ denote a segment length in bp. Exon lengths incur a penalty $f_{\\text{exon}}(L)$ and intron lengths incur a penalty $f_{\\text{intron}}(L)$, where\n  $$f_{\\text{exon}}(L) = \\frac{(L - \\mu_{\\text{e}})^2}{2 \\sigma_{\\text{e}}^2}, \\quad f_{\\text{intron}}(L) = \\frac{(L - \\mu_{\\text{i}})^2}{2 \\sigma_{\\text{i}}^2}.$$\n  Here $\\mu_{\\text{e}}$ and $\\sigma_{\\text{e}}$ are the exon length mean and standard deviation, and $\\mu_{\\text{i}}$ and $\\sigma_{\\text{i}}$ are the intron length mean and standard deviation.\n- For a valid gene structure that selects the ordered sequence of signals $(j_1, j_2, \\dots, j_m)$ with strictly increasing positions $(p_{j_1} < p_{j_2} < \\dots < p_{j_m})$, the total cost $C$ is the sum of:\n  - All signal costs $\\sum_{r=1}^{m} c_{j_r}$,\n  - Plus the exon penalty $f_{\\text{exon}}(L)$ for each exon segment,\n  - Plus the intron penalty $f_{\\text{intron}}(L)$ for each intron segment,\n  where $L$ for a segment connecting consecutive signals at positions $p_{u} < p_{v}$ is defined as $L = p_{v} - p_{u} - 1$ bp.\n\nGlobal constants for all test cases:\n- Exon length parameters: $\\mu_{\\text{e}} = 150$, $\\sigma_{\\text{e}} = 30$ (bp).\n- Intron length parameters: $\\mu_{\\text{i}} = 200$, $\\sigma_{\\text{i}} = 40$ (bp).\n- Promoter-to-start distance constraint: $D_{\\min} = 20$, $D_{\\max} = 1000$ (bp).\n\nValidity constraints:\n- Only the following consecutive signal-type transitions are allowed:\n  - $\\text{P} \\rightarrow \\text{S}$, with the promoter-to-start distance constraint $D_{\\min} \\le p_{\\text{S}} - p_{\\text{P}} \\le D_{\\max}$ and no segment penalty.\n  - $\\text{S} \\rightarrow \\text{D}$ with exon penalty $f_{\\text{exon}}(p_{\\text{D}} - p_{\\text{S}} - 1)$.\n  - $\\text{A} \\rightarrow \\text{D}$ with exon penalty $f_{\\text{exon}}(p_{\\text{D}} - p_{\\text{A}} - 1)$.\n  - $\\text{D} \\rightarrow \\text{A}$ with intron penalty $f_{\\text{intron}}(p_{\\text{A}} - p_{\\text{D}} - 1)$.\n  - $\\text{S} \\rightarrow \\text{T}$ with exon penalty $f_{\\text{exon}}(p_{\\text{T}} - p_{\\text{S}} - 1)$.\n  - $\\text{A} \\rightarrow \\text{T}$ with exon penalty $f_{\\text{exon}}(p_{\\text{T}} - p_{\\text{A}} - 1)$.\n- The selected sequence must include exactly one promoter, exactly one start, exactly one stop, and zero or more properly ordered donor-acceptor pairs, all with strictly increasing positions.\n\nObjective:\n- Among all valid gene structures, find the one that minimizes the total cost $C$.\n\nOutput specification:\n- For each test case, output the selected signals’ genomic positions as integers in bp, in order, as a list: $[\\text{promoter}, \\text{start}, (\\text{donor}, \\text{acceptor})^*, \\text{stop}]$.\n- If multiple valid structures achieve the same minimal cost up to a tolerance of $\\varepsilon = 10^{-9}$, select the one whose list of positions is lexicographically smallest.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[[...],[...],[...]]\") with no spaces. All positions must be integers in base pairs (bp).\n\nTest suite (three independent cases). For each case, $N$ is the sequence length (bp), followed by candidates with their type, position $p$, and cost $c$:\n\n- Case 1:\n  - $N = 1000$.\n  - Candidates:\n    - Promoters: $(\\text{P}, p=100, c=0.5)$, $(\\text{P}, p=300, c=0.2)$.\n    - Starts: $(\\text{S}, p=350, c=0.2)$, $(\\text{S}, p=600, c=0.4)$.\n    - Donors: $(\\text{D}, p=500, c=0.25)$, $(\\text{D}, p=650, c=0.45)$.\n    - Acceptors: $(\\text{A}, p=720, c=0.25)$, $(\\text{A}, p=800, c=0.5)$.\n    - Stops: $(\\text{T}, p=900, c=0.2)$.\n- Case 2:\n  - $N = 500$.\n  - Candidates:\n    - Promoters: $(\\text{P}, p=30, c=0.15)$.\n    - Starts: $(\\text{S}, p=100, c=0.25)$.\n    - Donors: $(\\text{D}, p=200, c=0.3)$.\n    - Acceptors: $(\\text{A}, p=150, c=0.2)$.\n    - Stops: $(\\text{T}, p=480, c=0.25)$.\n- Case 3:\n  - $N = 1200$.\n  - Candidates:\n    - Promoters: $(\\text{P}, p=101, c=0.1)$, $(\\text{P}, p=100, c=0.22)$, $(\\text{P}, p=80, c=0.4)$.\n    - Starts: $(\\text{S}, p=120, c=0.2)$.\n    - Donors: $(\\text{D}, p=270, c=0.28)$, $(\\text{D}, p=300, c=0.3)$.\n    - Acceptors: $(\\text{A}, p=440, c=0.31)$, $(\\text{A}, p=470, c=0.35)$.\n    - Stops: $(\\text{T}, p=700, c=0.25)$.\n\nFinal output format:\n- Your program must print a single line representing a list of three lists, one per case, with no spaces. Each inner list is the ordered integer positions (in bp) of the chosen signals, for example: \"[[p1,p2,...],[q1,q2,...],[r1,r2,...]]\".",
            "solution": "The problem presented is to identify the optimal gene structure from a set of candidate genomic signals by minimizing a total cost function. This cost function is an aggregation of signal-specific costs and length-dependent penalties for the inferred exon and intron segments. This formulation is a classic optimization problem that can be rigorously solved using dynamic programming. The problem is valid, scientifically grounded in the principles of computational gene finding, and mathematically well-posed.\n\nWe model this problem as finding the minimum-cost path in a Directed Acyclic Graph (DAG).\nThe nodes of the graph $G=(V, E)$ are the candidate signals provided in the input. Let the set of all candidates be $\\mathcal{S}$. The vertex set is $V = \\mathcal{S}$.\nAn edge $(i, j)$ exists in the edge set $E$ if and only if a transition from candidate signal $i$ to candidate signal $j$ is permitted by the rules of gene structure, and the position of $j$ is greater than the position of $i$, i.e., $p_j > p_i$. The cost of traversing an edge $(i, j)$ is defined as the sum of the signal cost of the destination node $j$, $c_j$, and the penalty associated with the genomic segment between $i$ and $j$, if any.\n\nThe objective is to find a path $(j_1, j_2, \\dots, j_m)$ that starts with a Promoter (P), ends with a Stop codon (T), and follows the specified gene grammar, such that the total path cost is minimized. The total cost is the sum of the initial signal cost $c_{j_1}$ and the costs of all subsequent transitions.\n\nWe will employ dynamic programming to solve this shortest path problem. Let the set of all candidates be sorted by their genomic position $p_j$. Let this sorted sequence of candidates be denoted by $s_1, s_2, \\dots, s_{|V|}$. We define $C(k)$ as the minimum cost of a valid partial gene structure ending at candidate $s_k$. We also define $\\Pi(k)$ as the list of genomic positions corresponding to the optimal path ending at $s_k$.\n\nThe dynamic programming algorithm proceeds by computing $C(k)$ and $\\Pi(k)$ for each candidate $s_k$ in the order of their genomic positions.\n\nThe recurrence relations are defined based on the type of the candidate signal $s_k$:\nLet $s_k$ be a candidate signal with type $t_k$, position $p_k$, and cost $c_k$.\n\n1.  If $t_k = \\text{P}$ (Promoter):\n    A promoter can only be the start of a gene. The cost is its own signal cost.\n    $$C(k) = c_k$$\n    $$\\Pi(k) = [p_k]$$\n\n2.  If $t_k = \\text{S}$ (Start codon):\n    A start codon must be preceded by a promoter $s_j$ (where $j<k$).\n    $$(C(k), \\Pi(k)) = \\min_{\\substack{j<k, t_j=\\text{P} \\\\ D_{\\min} \\le p_k - p_j \\le D_{\\max}}} \\left( C(j) + c_k, \\quad \\Pi(j) \\oplus [p_k] \\right)$$\n    where $\\oplus$ denotes list concatenation. The minimization is performed lexicographically on the tuple `(cost, path)`.\n\n3.  If $t_k = \\text{D}$ (Donor site):\n    A donor site must be preceded by either a start codon $s_j$ or an acceptor site $s_j$. The segment is an exon.\n    $$(C(k), \\Pi(k)) = \\min_{j<k, t_j \\in \\{\\text{S}, \\text{A}\\}} \\left( C(j) + c_k + f_{\\text{exon}}(p_k - p_j - 1), \\quad \\Pi(j) \\oplus [p_k] \\right)$$\n    The exon length penalty is $f_{\\text{exon}}(L) = \\frac{(L - \\mu_{\\text{e}})^2}{2 \\sigma_{\\text{e}}^2}$.\n\n4.  If $t_k = \\text{A}$ (Acceptor site):\n    An acceptor site must be preceded by a donor site $s_j$. The segment is an intron.\n    $$(C(k), \\Pi(k)) = \\min_{j<k, t_j=\\text{D}} \\left( C(j) + c_k + f_{\\text{intron}}(p_k - p_j - 1), \\quad \\Pi(j) \\oplus [p_k] \\right)$$\n    The intron length penalty is $f_{\\text{intron}}(L) = \\frac{(L - \\mu_{\\text{i}})^2}{2 \\sigma_{\\text{i}}^2}$.\n\n5.  If $t_k = \\text{T}$ (Stop codon):\n    A stop codon must be preceded by either a start codon $s_j$ (for single-exon genes) or an acceptor site $s_j$. The segment is the final exon.\n    $$(C(k), \\Pi(k)) = \\min_{j<k, t_j \\in \\{\\text{S}, \\text{A}\\}} \\left( C(j) + c_k + f_{\\text{exon}}(p_k - p_j - 1), \\quad \\Pi(j) \\oplus [p_k] \\right)$$\n\nThe initial values for $C(k)$ are set to $\\infty$ for all non-promoter signals. The algorithm iterates through the position-sorted candidates $s_k$ for $k=1, \\dots, |V|$, calculating $(C(k), \\Pi(k))$ by considering all valid predecessors $s_j$ with $j < k$.\n\nThe tie-breaking rule specifies that if two paths yield the same minimal cost (within a tolerance $\\varepsilon = 10^{-9}$), the one with the lexicographically smaller list of positions must be chosen. This is handled at each minimization step. When comparing a newly computed path cost `new_cost` with the current minimum `C(k)`, if `abs(new_cost - C(k)) <= \\varepsilon`, we then compare their corresponding paths $\\Pi_{new}$ and $\\Pi(k)$ lexicographically.\n\nAfter computing $(C(k), \\Pi(k))$ for all candidates, the final solution is the path corresponding to the minimum cost found among all stop codons. Let $\\mathcal{T}$ be the set of indices of all stop codons. The final optimal path $\\Pi_{\\text{opt}}$ is given by:\n$$(\\_, \\Pi_{\\text{opt}}) = \\min_{k \\in \\mathcal{T}} (C(k), \\Pi(k))$$\nThis procedure guarantees finding the valid gene structure with the globally minimum cost, respecting all constraints and the tie-breaking condition.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the gene prediction problem for the given test cases using dynamic programming.\n    \"\"\"\n    # Global constants\n    MU_E, SIGMA_E = 150.0, 30.0\n    MU_I, SIGMA_I = 200.0, 40.0\n    D_MIN, D_MAX = 20, 1000\n    EPSILON = 1e-9\n\n    def f_exon(L):\n        \"\"\"Calculates exon length penalty.\"\"\"\n        return (L - MU_E)**2 / (2 * SIGMA_E**2)\n\n    def f_intron(L):\n        \"\"\"Calculates intron length penalty.\"\"\"\n        return (L - MU_I)**2 / (2 * SIGMA_I**2)\n\n    test_cases_data = [\n        # Case 1\n        [\n            ('P', 100, 0.5), ('P', 300, 0.2),\n            ('S', 350, 0.2), ('S', 600, 0.4),\n            ('D', 500, 0.25), ('D', 650, 0.45),\n            ('A', 720, 0.25), ('A', 800, 0.5),\n            ('T', 900, 0.2)\n        ],\n        # Case 2\n        [\n            ('P', 30, 0.15),\n            ('S', 100, 0.25),\n            ('D', 200, 0.3),\n            ('A', 150, 0.2),\n            ('T', 480, 0.25)\n        ],\n        # Case 3\n        [\n            ('P', 101, 0.1), ('P', 100, 0.22), ('P', 80, 0.4),\n            ('S', 120, 0.2),\n            ('D', 270, 0.28), ('D', 300, 0.3),\n            ('A', 440, 0.31), ('A', 470, 0.35),\n            ('T', 700, 0.25)\n        ]\n    ]\n\n    results = []\n    \n    for case_data in test_cases_data:\n        # Sort candidates by position\n        candidates = sorted(case_data, key=lambda x: x[1])\n        num_candidates = len(candidates)\n        \n        # dp[i] stores a tuple (minimum_cost, path_list) to reach candidate i\n        dp = [(float('inf'), []) for _ in range(num_candidates)]\n\n        for i in range(num_candidates):\n            cand_i_type, cand_i_pos, cand_i_cost = candidates[i]\n\n            # Base case: Promoter\n            if cand_i_type == 'P':\n                dp[i] = (cand_i_cost, [cand_i_pos])\n                continue\n\n            # Iterate through all preceding candidates to find valid predecessors\n            for j in range(i):\n                cand_j_type, cand_j_pos, _ = candidates[j]\n                \n                # If predecessor path is invalid, skip\n                if dp[j][0] == float('inf'):\n                    continue\n\n                new_cost = -1\n                pred_cost, pred_path = dp[j]\n\n                if cand_i_type == 'S' and cand_j_type == 'P':\n                    dist = cand_i_pos - cand_j_pos\n                    if D_MIN <= dist <= D_MAX:\n                        new_cost = pred_cost + cand_i_cost\n                \n                elif cand_i_type == 'D' and cand_j_type in ['S', 'A']:\n                    length = cand_i_pos - cand_j_pos - 1\n                    penalty = f_exon(length)\n                    new_cost = pred_cost + cand_i_cost + penalty\n                \n                elif cand_i_type == 'A' and cand_j_type == 'D':\n                    length = cand_i_pos - cand_j_pos - 1\n                    penalty = f_intron(length)\n                    new_cost = pred_cost + cand_i_cost + penalty\n\n                elif cand_i_type == 'T' and cand_j_type in ['S', 'A']:\n                    length = cand_i_pos - cand_j_pos - 1\n                    penalty = f_exon(length)\n                    new_cost = pred_cost + cand_i_cost + penalty\n                \n                if new_cost != -1:\n                    new_path = pred_path + [cand_i_pos]\n                    \n                    # Update DP table with tie-breaking\n                    current_cost, current_path = dp[i]\n                    if new_cost < current_cost - EPSILON:\n                        dp[i] = (new_cost, new_path)\n                    elif abs(new_cost - current_cost) <= EPSILON:\n                        if not current_path or new_path < current_path:\n                            dp[i] = (new_cost, new_path)\n\n        # Find the best path among all stop codons\n        best_overall_cost = float('inf')\n        best_overall_path = []\n\n        for i in range(num_candidates):\n            if candidates[i][0] == 'T':\n                cost, path = dp[i]\n                if path: # Ensure a valid path was found\n                    if cost < best_overall_cost - EPSILON:\n                        best_overall_cost = cost\n                        best_overall_path = path\n                    elif abs(cost - best_overall_cost) <= EPSILON:\n                        if not best_overall_path or path < best_overall_path:\n                             best_overall_path = path\n        \n        results.append(best_overall_path)\n\n    # Format final output as a single line string\n    output_str = \"[\"\n    for i, res in enumerate(results):\n        output_str += f\"[{','.join(map(str, res))}]\"\n        if i < len(results) - 1:\n            output_str += \",\"\n    output_str += \"]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}