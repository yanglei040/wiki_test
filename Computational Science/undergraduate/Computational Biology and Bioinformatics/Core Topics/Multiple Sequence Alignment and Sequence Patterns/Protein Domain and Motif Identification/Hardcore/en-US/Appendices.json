{
    "hands_on_practices": [
        {
            "introduction": "We begin our practical exploration with the most direct method for finding patterns in sequences: regular expressions. Many protein motifs, such as the C$_2$H$_2$ zinc finger, are defined by a specific sequence of conserved amino acids separated by spacers of variable length. This exercise  challenges you to translate these biological definitions into computational search patterns, providing fundamental practice in applying text-searching algorithms to biological data.",
            "id": "2420143",
            "problem": "You must write a complete, runnable program that, for a fixed set of candidate human protein primary structures over the standard amino acid alphabet, identifies which sequences contain at least one occurrence of both of the following domain-defining motif patterns: a deoxyribonucleic acid (DNA)-binding C$_2$H$_2$ zinc finger motif and an E3 ubiquitin ligase Really Interesting New Gene (RING) finger motif. Motif presence is defined purely as the existence of a contiguous subsequence that satisfies the positional constraints specified below. The alphabet is $\\Sigma = \\{ \\text{A, C, D, E, F, G, H, I, K, L, M, N, P, Q, R, S, T, V, W, Y, X} \\}$ where $\\text{X}$ denotes an unknown residue that can appear only as a generic symbol and is treated as matching any single residue in wildcard positions; it does not satisfy positions that explicitly require a specific residue. The following is the formal specification.\n\nMathematical definition of a pattern: Given a sequence $S \\in \\Sigma^{*}$ and a pattern described as a concatenation of symbols and bounded wildcards, a match exists if there is an index $i$ and a length $L$ such that the substring $S[i\\,..\\,i+L-1]$ is exactly equal to a string formed by concatenating literal residues and wildcard blocks of the form $\\text{any}^{k}$, where $k$ is a nonnegative integer, and where $\\text{any}$ denotes any single symbol from $\\Sigma$. Literal positions must match the exact residue symbol, and wildcard positions may match any residue symbol in $\\Sigma$.\n\nMotif definitions:\n- DNA-binding C$_2$H$_2$ zinc finger motif (abbreviated here as C2H2): a literal $\\text{C}$, followed by $k_1$ arbitrary residues with $k_1 \\in \\{2,3,4\\}$, followed by a literal $\\text{C}$, then exactly $12$ arbitrary residues, then a literal $\\text{H}$, then $k_2$ arbitrary residues with $k_2 \\in \\{3,4,5\\}$, then a literal $\\text{H}$. Formally, this is $\\text{C} \\cdot \\text{any}^{k_1} \\cdot \\text{C} \\cdot \\text{any}^{12} \\cdot \\text{H} \\cdot \\text{any}^{k_2} \\cdot \\text{H}$.\n- E3 ubiquitin ligase RING finger motif (abbreviated here as RING): a literal $\\text{C}$, followed by exactly $2$ arbitrary residues, followed by a literal $\\text{C}$, followed by $n_1$ arbitrary residues with $n_1 \\in [9,39]$, followed by a literal $\\text{C}$, followed by $n_2$ arbitrary residues with $n_2 \\in [1,3]$, followed by a literal $\\text{H}$, followed by $n_3$ arbitrary residues with $n_3 \\in [2,3]$, followed by a literal $\\text{C}$, followed by exactly $2$ arbitrary residues, followed by a literal $\\text{C}$, followed by $n_4$ arbitrary residues with $n_4 \\in [4,48]$, followed by a literal $\\text{C}$, followed by exactly $2$ arbitrary residues, followed by a literal $\\text{C}$. Formally, $\\text{C} \\cdot \\text{any}^{2} \\cdot \\text{C} \\cdot \\text{any}^{n_1} \\cdot \\text{C} \\cdot \\text{any}^{n_2} \\cdot \\text{H} \\cdot \\text{any}^{n_3} \\cdot \\text{C} \\cdot \\text{any}^{2} \\cdot \\text{C} \\cdot \\text{any}^{n_4} \\cdot \\text{C} \\cdot \\text{any}^{2} \\cdot \\text{C}$.\n\nYou are given a fixed list of candidate protein sequences $S_0, S_1, \\dots, S_8$, each associated with a zero-based index. Construct the following reusable building blocks exactly:\n- Define $Z_{\\min} =$ \"CAACAAAAAAAAAAAAHAAAH\", which instantiates the C2H2 motif with $k_1 = 2$ and $k_2 = 3$, that is, $\\text{C} \\cdot \\text{A}^{2} \\cdot \\text{C} \\cdot \\text{A}^{12} \\cdot \\text{H} \\cdot \\text{A}^{3} \\cdot \\text{H}$.\n- Define $Z_{\\max} =$ \"CAAAACAAAAAAAAAAAAHAAAAAH\", which instantiates the C2H2 motif with $k_1 = 4$ and $k_2 = 5$, that is, $\\text{C} \\cdot \\text{A}^{4} \\cdot \\text{C} \\cdot \\text{A}^{12} \\cdot \\text{H} \\cdot \\text{A}^{5} \\cdot \\text{H}$.\n- Define $Z_{\\mathrm{exact}} =$ \"CAAACAAAAAAAAAAAAHAAAAH\", which instantiates the C2H2 motif with $k_1 = 3$ and $k_2 = 4$, that is, $\\text{C} \\cdot \\text{A}^{3} \\cdot \\text{C} \\cdot \\text{A}^{12} \\cdot \\text{H} \\cdot \\text{A}^{4} \\cdot \\text{H}$.\n- Define $R_{\\min} =$ \"CAACAAAAAAAAACAHAACAACAAAACAAC\", which instantiates the RING motif with $n_1 = 9$, $n_2 = 1$, $n_3 = 2$, and $n_4 = 4$, that is, $\\text{C} \\cdot \\text{A}^{2} \\cdot \\text{C} \\cdot \\text{A}^{9} \\cdot \\text{C} \\cdot \\text{A}^{1} \\cdot \\text{H} \\cdot \\text{A}^{2} \\cdot \\text{C} \\cdot \\text{A}^{2} \\cdot \\text{C} \\cdot \\text{A}^{4} \\cdot \\text{C} \\cdot \\text{A}^{2} \\cdot \\text{C}$.\n- Define $R_{\\max}$ as the string constructed by $\\text{C} \\cdot \\text{A}^{2} \\cdot \\text{C} \\cdot \\text{A}^{39} \\cdot \\text{C} \\cdot \\text{A}^{3} \\cdot \\text{H} \\cdot \\text{A}^{3} \\cdot \\text{C} \\cdot \\text{A}^{2} \\cdot \\text{C} \\cdot \\text{A}^{48} \\cdot \\text{C} \\cdot \\text{A}^{2} \\cdot \\text{C}$ (length $107$).\n- Define $Z_{\\mathrm{X}}$ as the string $\\text{C} \\cdot \\text{X}^{2} \\cdot \\text{C} \\cdot \\text{X}^{12} \\cdot \\text{H} \\cdot \\text{X}^{3} \\cdot \\text{H}$.\n- Define $R_{\\mathrm{X}}$ as the string $\\text{C} \\cdot \\text{X}^{2} \\cdot \\text{C} \\cdot \\text{X}^{9} \\cdot \\text{C} \\cdot \\text{X}^{1} \\cdot \\text{H} \\cdot \\text{X}^{2} \\cdot \\text{C} \\cdot \\text{X}^{2} \\cdot \\text{C} \\cdot \\text{X}^{4} \\cdot \\text{C} \\cdot \\text{X}^{2} \\cdot \\text{C}$.\n\nNow define the sequences $S_i$ for indices $i \\in \\{0,1,2,3,4,5,6,7,8\\}$ as follows:\n- $S_0 =$ \"M\" repeated $10$ times, followed by $Z_{\\min}$, followed by \"G\" repeated $5$ times, followed by $R_{\\min}$, followed by \"T\" repeated $3$ times.\n- $S_1 =$ \"M\" repeated $5$ times, followed by $Z_{\\max}$, followed by \"Q\" repeated $5$ times.\n- $S_2 =$ \"V\" repeated $5$ times, followed by $R_{\\min}$, followed by \"P\" repeated $5$ times.\n- $S_3 =$ the literal string \"MKTLLILVVAAAAGGG\".\n- $S_4 =$ \"S\" repeated $4$ times, followed by $Z_{\\max}$, followed by \"N\" repeated $5$ times, followed by $R_{\\max}$, followed by \"E\" repeated $4$ times.\n- $S_5 =$ the string obtained from $Z_{\\min}$ by replacing its final literal $\\text{H}$ by $\\text{K}$ (so that the last position is no longer $\\text{H}$), followed by \"G\" repeated $3$ times, followed by $R_{\\min}$.\n- $S_6 =$ $Z_{\\mathrm{X}}$ followed by \"GG\", followed by $R_{\\mathrm{X}}$.\n- $S_7 =$ $R_{\\min}$ followed immediately by $Z_{\\min}$.\n- $S_8 =$ \"D\" repeated $3$ times, followed by $Z_{\\mathrm{exact}}$, followed by \"P\" repeated $3$ times, followed by $R_{\\min}$, followed by \"K\" repeated $3$ times.\n\nTest suite of pattern parameterizations:\n- Test case $1$: C2H2 motif with $k_1 \\in \\{2,3,4\\}$, exactly $12$ arbitrary residues between $\\text{C}$ and $\\text{H}$, and $k_2 \\in \\{3,4,5\\}$; RING motif with $n_1 \\in [9,39]$, $n_2 \\in [1,3]$, $n_3 \\in [2,3]$, and $n_4 \\in [4,48]$.\n- Test case $2$: C2H2 motif identical to test case $1$; RING motif tightened to $n_1 \\in [9,12]$ and $n_4 \\in [4,12]$, with $n_2 \\in [1,3]$ and $n_3 \\in [2,3]$ unchanged.\n- Test case $3$: C2H2 motif tightened to $k_1 = 3$ and $k_2 = 4$ with exactly $12$ arbitrary residues between the second $\\text{C}$ and first $\\text{H}$; RING motif identical to test case $1$.\n\nFor each test case $t \\in \\{1,2,3\\}$, determine the set of indices $I_t \\subseteq \\{0,1,\\dots,8\\}$ such that $S_i$ contains at least one occurrence of a substring matching the C2H2 motif specified for test case $t$ and at least one occurrence of a substring matching the RING motif specified for test case $t$. Your program must output a single line containing the three results aggregated as a list of lists of integers without spaces, in the order $[I_1, I_2, I_3]$, where each $I_t$ is represented as a list of the zero-based indices in strictly increasing order. For example, a valid output format would look like \"[[a_1,a_2],[b_1],[c_1,c_2,c_3]]\" where $a_j$, $b_j$, and $c_j$ are integers. No other text should be printed.",
            "solution": "The problem presented is a standard exercise in bioinformatics, specifically in the domain of sequence analysis and motif identification. It is computationally well-posed and scientifically sound. The task is to identify, from a given set of protein primary structures, those that contain instances of two distinct motifs: a C$_2$H$_2$ zinc finger and a RING finger, under varying parameter constraints.\n\nThe fundamental principle for solving this problem is pattern matching in strings. Given that the motifs are defined by a sequence of specific amino acid residues interspersed with variable-length segments of arbitrary residues, the most direct and computationally efficient method is the use of regular expressions. A regular expression is a formal language for specifying search patterns that is directly suited to the definitions provided.\n\nThe methodology is implemented in three stages.\n\nFirst, the programmatic construction of the inputs. The nine protein sequences, denoted $S_0$ through $S_8$, are synthesized precisely as described, by concatenating the provided literal strings and predefined building blocks ($Z_{\\min}$, $Z_{\\max}$, etc.). This step is trivial string manipulation.\n\nSecond, the formulation of parametrized pattern-matching functions. Two core functions are required: one for the C$_2$H$_2$ motif and one for the RING motif.\nThe C$_2$H$_2$ motif is defined as $\\text{C} \\cdot \\text{any}^{k_1} \\cdot \\text{C} \\cdot \\text{any}^{12} \\cdot \\text{H} \\cdot \\text{any}^{k_2} \\cdot \\text{H}$. This translates into a regular expression pattern of the form `C.{k1_min,k1_max}C.{12}H.{k2_min,k2_max}H`, where $\\{k_1\\_{\\min}, k_1\\_{\\max}\\}$ and $\\{k_2\\_{\\min}, k_2\\_{\\max}\\}$ define the inclusive integer ranges for the lengths of the wildcard segments. The symbol `.` is a wildcard that matches any single character, which correctly models the `any` symbol over the alphabet $\\Sigma$, including the special residue $\\text{X}$. The literal characters `C` and `H` in the pattern will only match themselves, correctly enforcing the specified conserved residues.\n\nSimilarly, the RING finger motif, formally $\\text{C} \\cdot \\text{any}^{2} \\cdot \\text{C} \\cdot \\text{any}^{n_1} \\cdot \\text{C} \\cdot \\text{any}^{n_2} \\cdot \\text{H} \\cdot \\text{any}^{n_3} \\cdot \\text{C} \\cdot \\text{any}^{2} \\cdot \\text{C} \\cdot \\text{any}^{n_4} \\cdot \\text{C} \\cdot \\text{any}^{2} \\cdot \\text{C}$, is translated into the regular expression `C..C.{n1_min,n1_max}C.{n2_min,n2_max}H.{n3_min,n3_max}C..C.{n4_min,n4_max}C..C`. The parameters $n_1, n_2, n_3, n_4$ are supplied as ranges for each test case.\n\nThird, the systematic evaluation of each sequence against the test cases. A main procedure iterates through the three specified test cases. For each test case, it configures the regular expression patterns with the corresponding parameter ranges for $k_1, k_2, n_1, n_2, n_3, n_4$. It then iterates through each sequence $S_i$ for $i \\in \\{0, \\ldots, 8\\}$. For a sequence to be considered a match for a given test case, a search for the C$_2$H$_2$ pattern *and* a search for the RING pattern must both be successful. The indices $i$ of all sequences that satisfy this dual condition are collected for each test case.\n\nThe final output is an aggregation of these sets of indices, presented in the required list-of-lists format. The entire process is a deterministic application of regular expression matching and logical conjunction, yielding a unique and correct solution.",
            "answer": "```python\nimport re\nimport numpy as np  # numpy is specified as available but not used.\n# scipy is specified as available but not used.\n\ndef solve():\n    \"\"\"\n    Solves the protein motif identification problem by:\n    1. Constructing the target protein sequences from given building blocks.\n    2. Defining the parameter sets for three test cases.\n    3. Implementing helper functions to generate regular expressions for\n       C2H2 and RING motifs based on variable length parameters.\n    4. Iterating through each test case and each sequence, checking for the\n       presence of both required motifs.\n    5. Collecting and printing the indices of matching sequences in the\n       specified format.\n    \"\"\"\n\n    # Define reusable building blocks for sequences\n    Z_min = \"CAACAAAAAAAAAAAAHAAAH\"\n    Z_max = \"CAAAACAAAAAAAAAAAAHAAAAAH\"\n    Z_exact = \"CAAACAAAAAAAAAAAAHAAAAH\"\n    R_min = \"CAACAAAAAAAAACAHAACAACAAAACAAC\"\n    R_max = (\n        \"C\" + \"A\" * 2 + \"C\" + \"A\" * 39 + \"C\" + \"A\" * 3 + \"H\" + \"A\" * 3 +\n        \"C\" + \"A\" * 2 + \"C\" + \"A\" * 48 + \"C\" + \"A\" * 2 + \"C\"\n    )\n    Z_X = \"C\" + \"X\" * 2 + \"C\" + \"X\" * 12 + \"H\" + \"X\" * 3 + \"H\"\n    R_X = (\n        \"C\" + \"X\" * 2 + \"C\" + \"X\" * 9 + \"C\" + \"X\" * 1 + \"H\" + \"X\" * 2 +\n        \"C\" + \"X\" * 2 + \"C\" + \"X\" * 4 + \"C\" + \"X\" * 2 + \"C\"\n    )\n\n    # Define the list of candidate protein sequences S_0 to S_8\n    sequences = [\n        \"M\" * 10 + Z_min + \"G\" * 5 + R_min + \"T\" * 3,  # S_0\n        \"M\" * 5 + Z_max + \"Q\" * 5,                      # S_1\n        \"V\" * 5 + R_min + \"P\" * 5,                      # S_2\n        \"MKTLLILVVAAAAGGG\",                             # S_3\n        \"S\" * 4 + Z_max + \"N\" * 5 + R_max + \"E\" * 4,    # S_4\n        Z_min[:-1] + \"K\" + \"G\" * 3 + R_min,             # S_5\n        Z_X + \"GG\" + R_X,                               # S_6\n        R_min + Z_min,                                  # S_7\n        \"D\" * 3 + Z_exact + \"P\" * 3 + R_min + \"K\" * 3,  # S_8\n    ]\n\n    # Define the parameters for the three test cases\n    test_cases = [\n        {\n            \"c2h2\": {\"k1_range\": (2, 4), \"k2_range\": (3, 5)},\n            \"ring\": {\"n1_range\": (9, 39), \"n2_range\": (1, 3), \"n3_range\": (2, 3), \"n4_range\": (4, 48)},\n        },\n        {\n            \"c2h2\": {\"k1_range\": (2, 4), \"k2_range\": (3, 5)},\n            \"ring\": {\"n1_range\": (9, 12), \"n2_range\": (1, 3), \"n3_range\": (2, 3), \"n4_range\": (4, 12)},\n        },\n        {\n            \"c2h2\": {\"k1_range\": (3, 3), \"k2_range\": (4, 4)},\n            \"ring\": {\"n1_range\": (9, 39), \"n2_range\": (1, 3), \"n3_range\": (2, 3), \"n4_range\": (4, 48)},\n        },\n    ]\n\n    # Helper function to generate a regular expression for the C2H2 motif\n    def make_c2h2_regex(k1_range, k2_range):\n        pattern = f\"C.{{{k1_range[0]},{k1_range[1]}}}C.{{12}}H.{{{k2_range[0]},{k2_range[1]}}}H\"\n        return re.compile(pattern)\n\n    # Helper function to generate a regular expression for the RING motif\n    def make_ring_regex(n1_range, n2_range, n3_range, n4_range):\n        pattern = (\n            f\"C..C.{{{n1_range[0]},{n1_range[1]}}}C.{{{n2_range[0]},{n2_range[1]}}}\"\n            f\"H.{{{n3_range[0]},{n3_range[1]}}}C..C.{{{n4_range[0]},{n4_range[1]}}}C..C\"\n        )\n        return re.compile(pattern)\n\n    all_results = []\n    # Process each test case\n    for case_params in test_cases:\n        c2h2_regex = make_c2h2_regex(**case_params[\"c2h2\"])\n        ring_regex = make_ring_regex(**case_params[\"ring\"])\n        \n        current_case_indices = []\n        # Check each sequence against the current test case's motifs\n        for i, seq in enumerate(sequences):\n            has_c2h2 = c2h2_regex.search(seq) is not None\n            has_ring = ring_regex.search(seq) is not None\n            \n            # A sequence passes if it contains at least one of each motif\n            if has_c2h2 and has_ring:\n                current_case_indices.append(i)\n        \n        all_results.append(current_case_indices)\n\n    # Format the final output string as specified: [[a,b],[c,d,e],[f]]\n    # This construction avoids any spaces in the output.\n    result_str = \"[\" + \",\".join(f\"[{','.join(map(str, r))}]\" for r in all_results) + \"]\"\n    \n    print(result_str)\n\nsolve()\n```"
        },
        {
            "introduction": "Building on simple motif detection, this practice introduces a more realistic and biologically nuanced scenario. Often, a complete functional domain is defined not by a single motif, but by a constellation of smaller motifs that must appear in a specific order and with constrained spacing. This exercise  guides you through identifying kinase domains by their tripartite structure, and more importantly, asks you to distinguish between a canonical, active domain and an inactive 'pseudo-domain' where a critical residue has been mutated. This task moves beyond simple pattern finding to the crucial skill of functional inference from sequence.",
            "id": "2420098",
            "problem": "You are given a computational task grounded in the observation that many enzymatic protein domains possess highly conserved active-site motifs. In particular, protein kinases classically exhibit three conserved short motifs appearing in order along the primary sequence with characteristic spacing: a lysine-containing motif near the $\\beta3$ strand, a catalytic-loop motif with an aspartate, and an activation-loop motif beginning with an aspartate. You will detect canonical domains that respect these conserved residues and identify pseudo-domains that preserve the motif context and spacing but deviate at one or more critical residues.\n\nFormalization\n\n- Let $\\Sigma$ be the set of the $20$ standard amino acid one-letter codes. A protein sequence is a finite string $S \\in \\Sigma^\\ast$ indexed from position $0$.\n- Define three motif strings:\n  - $M_1 = \\text{\"VAIK\"}$,\n  - $M_2 = \\text{\"HRD\"}$,\n  - $M_3 = \\text{\"DFG\"}$.\n- Define motif lengths $\\ell_1 = 4$, $\\ell_2 = 3$, $\\ell_3 = 3$.\n- Define gap-length constraints that must be satisfied simultaneously for a valid triplet occurrence:\n  - $g_{12}^{\\min} = 50$, $g_{12}^{\\max} = 70$,\n  - $g_{23}^{\\min} = 20$, $g_{23}^{\\max} = 30$.\n- For any occurrence of $M_i$ at starting index $p_i$ (with $0 \\le p_i \\le |S| - \\ell_i$), the gaps are defined as\n  $$g_{12} = p_2 - (p_1 + \\ell_1), \\quad g_{23} = p_3 - (p_2 + \\ell_2).$$\n  A valid in-order triplet satisfies $p_1 < p_2 < p_3$ and\n  $$g_{12}^{\\min} \\le g_{12} \\le g_{12}^{\\max}, \\quad g_{23}^{\\min} \\le g_{23} \\le g_{23}^{\\max}.$$\n- Critical residues are defined at specific positions within each motif:\n  - In $M_1$, the residue at position $4$ (the lysine, $\\text{\"K\"}$) is critical.\n  - In $M_2$, the residue at position $3$ (the aspartate, $\\text{\"D\"}$) is critical.\n  - In $M_3$, the residue at position $1$ (the aspartate, $\\text{\"D\"}$) is critical.\n- Define relaxed motifs $M_1^\\ast, M_2^\\ast, M_3^\\ast$ by replacing only the critical positions with a wildcard that can match any residue, leaving all non-critical positions unchanged:\n  - $M_1^\\ast = \\text{\"VAI?\"}$,\n  - $M_2^\\ast = \\text{\"HR?\"}$,\n  - $M_3^\\ast = \\text{\"?FG\"}$.\n- A canonical domain is present in $S$ if there exists at least one valid in-order triplet of exact matches to $M_1, M_2, M_3$ (with the gaps defined above).\n- A pseudo-domain is present in $S$ if there exists at least one valid in-order triplet of matches to the relaxed motifs $M_1^\\ast, M_2^\\ast, M_3^\\ast$ that satisfies the same gap constraints and in which at least one of the critical residues differs from its canonical identity (that is, the residues at the corresponding critical locations in $M_1, M_2, M_3$ are not simultaneously equal to $\\text{\"K\"}, \\text{\"D\"}, \\text{\"D\"}$). A canonical domain must not be counted as a pseudo-domain.\n\nNotation for the test suite\n\n- For any character $X \\in \\Sigma$ and integer $n \\ge 0$, let $X^n$ denote the string consisting of $n$ repeats of character $X$.\n- Concatenation of strings is denoted by simple juxtaposition.\n\nTest suite\n\nYou must evaluate the following five sequences. Each sequence is specified using the repetition notation and simple concatenation. All repetitions use the character $\\text{\"A\"}$.\n\n- $S_1 = \\text{\"A\"}^{10}\\ \\text{\"VAIK\"}\\ \\text{\"A\"}^{50}\\ \\text{\"HRD\"}\\ \\text{\"A\"}^{20}\\ \\text{\"DFG\"}\\ \\text{\"A\"}^{5}.$\n- $S_2 = \\text{\"A\"}^{8}\\ \\text{\"VAIK\"}\\ \\text{\"A\"}^{60}\\ \\text{\"HRN\"}\\ \\text{\"A\"}^{25}\\ \\text{\"DFG\"}\\ \\text{\"A\"}^{4}.$\n- $S_3 = \\text{\"A\"}^{12}\\ \\text{\"VAIR\"}\\ \\text{\"A\"}^{55}\\ \\text{\"HRD\"}\\ \\text{\"A\"}^{20}\\ \\text{\"DFG\"}\\ \\text{\"A\"}^{7}.$\n- $S_4 = \\text{\"A\"}^{9}\\ \\text{\"VAIK\"}\\ \\text{\"A\"}^{10}\\ \\text{\"HRD\"}\\ \\text{\"A\"}^{30}\\ \\text{\"DFG\"}\\ \\text{\"A\"}^{6}.$\n- $S_5 = \\text{\"A\"}^{6}\\ \\text{\"VAIK\"}\\ \\text{\"A\"}^{52}\\ \\text{\"HRD\"}\\ \\text{\"A\"}^{20}\\ \\text{\"DFG\"}\\ \\text{\"A\"}^{80}\\ \\text{\"VAIR\"}\\ \\text{\"A\"}^{60}\\ \\text{\"HRN\"}\\ \\text{\"A\"}^{20}\\ \\text{\"DFG\"}\\ \\text{\"A\"}^{3}.$\n\nAnswer specification\n\n- For each sequence $S_k$, you must determine two boolean values:\n  - whether a canonical domain exists in $S_k$ under the definitions above;\n  - whether a pseudo-domain exists in $S_k$ under the definitions above.\n- Your program must process the five sequences in the exact order $S_1, S_2, S_3, S_4, S_5$ and produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each sequence, output the pair as a two-element list in the form $\\text{\"[True,False]\"}$, $\\text{\"[False,True]\"}$, etc., using boolean literals $\\text{True}$ and $\\text{False}$.\n- Concretely, the final output must be a single line string representing a list of five pairs: $\\text{\"[[b_{11},b_{12}],[b_{21},b_{22}],[b_{31},b_{32}],[b_{41},b_{42}],[b_{51},b_{52}]]\"}$, where each $b_{ij}$ is a boolean as defined above.\n\nYour program must be a complete, runnable program that performs these computations without any user input or external files.",
            "solution": "The problem has been subjected to rigorous validation and is deemed valid. It is scientifically grounded in the principles of computational biology, specifically the identification of protein domains via conserved sequence motifs. The problem is well-posed, with all parameters, constraints, and objectives defined with sufficient mathematical and algorithmic precision. There are no logical contradictions, factual unsoundness, or critical ambiguities. Therefore, a solution can be derived.\n\nThe task is to determine, for a given protein sequence $S$, the existence of \"canonical\" and \"pseudo\" kinase domains. These are defined by the presence of triplets of specific motifs, separated by constrained gap lengths.\n\nThe fundamental approach is a combinatorial search for valid motif triplets within the sequence. The algorithm proceeds in three stages:\n\n1.  **Motif Instance Identification**: First, we must identify all potential locations for the three motifs. The problem defines three canonical motifs, $M_1 = \\text{\"VAIK\"}$, $M_2 = \\text{\"HRD\"}$, and $M_3 = \\text{\"DFG\"}$. It also defines relaxed versions, $M_1^\\ast = \\text{\"VAI?\"}$, $M_2^\\ast = \\text{\"HR?\"}$, and $M_3^\\ast = \\text{\"?FG\"}$, where the wildcard '?' may match any amino acid from the alphabet $\\Sigma$. We will perform three independent linear scans of the input sequence $S$ to find all occurrences of $M_1^\\ast$, $M_2^\\ast$, and $M_3^\\ast$. For each match, we record its starting position, $p_i$, and the specific amino acid found at the critical position. Let $\\mathcal{P}_1$, $\\mathcal{P}_2$, and $\\mathcal{P}_3$ be the sets of these findings, where each element is a pair $(p_i, c_i)$ of a zero-based starting index and the critical residue.\n\n2.  **Triplet Enumeration and Validation**: We then enumerate all possible triplets of motif instances by taking one element from each set: $(p_1, c_1) \\in \\mathcal{P}_1$, $(p_2, c_2) \\in \\mathcal{P}_2$, and $(p_3, c_3) \\in \\mathcal{P}_3$. For each candidate triplet of motif occurrences, we must validate it against two sets of constraints:\n    *   **Order Constraint**: The motifs must appear in the correct order along the sequence, i.e., $p_1 < p_2 < p_3$.\n    *   **Gap-Length Constraints**: The number of residues separating the motifs must fall within specified ranges. The gaps are defined as $g_{12} = p_2 - (p_1 + \\ell_1)$ and $g_{23} = p_3 - (p_2 + \\ell_2)$, where the motif lengths are $\\ell_1 = 4$, $\\ell_2 = 3$, and $\\ell_3 = 3$. The constraints are $g_{12}^{\\min} \\le g_{12} \\le g_{12}^{\\max}$ and $g_{23}^{\\min} \\le g_{23} \\le g_{23}^{\\max}$, with the given values $g_{12}^{\\min} = 50$, $g_{12}^{\\max} = 70$, $g_{23}^{\\min} = 20$, and $g_{23}^{\\max} = 30$.\n    Any triplet that fails to meet all of these conditions is discarded.\n\n3.  **Domain Classification**: A triplet of motif instances that satisfies all order and gap constraints is deemed a \"valid triplet\". Each valid triplet is then classified based on its critical residues $(c_1, c_2, c_3)$. The canonical critical residues are 'K' for $M_1$, 'D' for $M_2$, and 'D' for $M_3$.\n    *   A valid triplet is **canonical** if and only if $c_1 = \\text{'K'}$, $c_2 = \\text{'D'}$, and $c_3 = \\text{'D'}$.\n    *   A valid triplet is **pseudo** if it is not canonical. This means at least one of its critical residues deviates from the canonical identity.\n\nFinally, we determine the properties of the entire sequence $S$. A canonical domain exists if at least one canonical triplet was found. A pseudo-domain exists if at least one pseudo triplet was found. It is possible for a sequence to contain both, one, or neither. Two boolean flags, `has_canonical` and `has_pseudo`, are initialized to false and are set to true upon finding the first instance of the corresponding triplet type. The final output for a sequence $S$ is the pair of these two boolean values. This entire process is repeated for each of the five provided test sequences.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the protein domain identification problem for a suite of test sequences.\n    \"\"\"\n\n    def generate_sequence(parts):\n        \"\"\"\n        Generates a full protein sequence string from a compact specification.\n        Example part: ('A', 10) for \"AAAAAAAAAA\", or ('VAIK', 1) for \"VAIK\".\n        \"\"\"\n        return \"\".join([char * count for char, count in parts])\n\n    def find_relaxed_matches(sequence, prefix, suffix, length, critical_offset_from_start):\n        \"\"\"\n        Finds all occurrences of a relaxed motif in a sequence.\n        A relaxed motif is defined by a prefix, a suffix, and a total length.\n        The single character between the prefix and suffix is the critical residue.\n        \n        Args:\n            sequence (str): The protein sequence to search.\n            prefix (str): The fixed prefix of the motif.\n            suffix (str): The fixed suffix of the motif.\n            length (int): The total length of the motif.\n            critical_offset_from_start (int): The 0-based index of the critical residue.\n            \n        Returns:\n            list: A list of tuples, where each tuple is (start_index, critical_residue).\n        \"\"\"\n        matches = []\n        len_prefix = len(prefix)\n        len_suffix = len(suffix)\n        \n        if len_prefix + len_suffix != length - 1:\n            raise ValueError(\"Prefix and suffix lengths do not match total length.\")\n\n        for i in range(len(sequence) - length + 1):\n            if sequence[i : i + len_prefix] == prefix and \\\n               sequence[i + length - len_suffix : i + length] == suffix:\n                critical_char = sequence[i + critical_offset_from_start]\n                matches.append((i, critical_char))\n        return matches\n\n    # Test cases defined using the compact notation from the problem statement.\n    test_specs = [\n        # S1\n        [('A', 10), ('VAIK', 1), ('A', 50), ('HRD', 1), ('A', 20), ('DFG', 1), ('A', 5)],\n        # S2\n        [('A', 8), ('VAIK', 1), ('A', 60), ('HRN', 1), ('A', 25), ('DFG', 1), ('A', 4)],\n        # S3\n        [('A', 12), ('VAIR', 1), ('A', 55), ('HRD', 1), ('A', 20), ('DFG', 1), ('A', 7)],\n        # S4\n        [('A', 9), ('VAIK', 1), ('A', 10), ('HRD', 1), ('A', 30), ('DFG', 1), ('A', 6)],\n        # S5\n        [('A', 6), ('VAIK', 1), ('A', 52), ('HRD', 1), ('A', 20), ('DFG', 1), ('A', 80), \n         ('VAIR', 1), ('A', 60), ('HRN', 1), ('A', 20), ('DFG', 1), ('A', 3)]\n    ]\n\n    sequences = [generate_sequence(spec) for spec in test_specs]\n    \n    # Problem constants\n    l1, l2 = 4, 3\n    g12_min, g12_max = 50, 70\n    g23_min, g23_max = 20, 30\n    crit1_char, crit2_char, crit3_char = 'K', 'D', 'D'\n\n    all_results = []\n\n    for S in sequences:\n        # Find all occurrences of the three relaxed motifs\n        # M1* = \"VAI?\", critical residue at 0-based index 3\n        matches1 = find_relaxed_matches(S, prefix=\"VAI\", suffix=\"\", length=4, critical_offset_from_start=3)\n        # M2* = \"HR?\", critical residue at 0-based index 2\n        matches2 = find_relaxed_matches(S, prefix=\"HR\", suffix=\"\", length=3, critical_offset_from_start=2)\n        # M3* = \"?FG\", critical residue at 0-based index 0\n        matches3 = find_relaxed_matches(S, prefix=\"\", suffix=\"FG\", length=3, critical_offset_from_start=0)\n\n        has_canonical = False\n        has_pseudo = False\n\n        # Iterate through all combinations of found motifs to find valid triplets\n        for p1, c1 in matches1:\n            for p2, c2 in matches2:\n                # Enforce order constraint p1 < p2\n                if p1 >= p2:\n                    continue\n                \n                # Check gap constraint g12\n                g12 = p2 - (p1 + l1)\n                if not (g12_min <= g12 <= g12_max):\n                    continue\n\n                for p3, c3 in matches3:\n                    # Enforce order constraint p2 < p3\n                    if p2 >= p3:\n                        continue\n                    \n                    # Check gap constraint g23\n                    g23 = p3 - (p2 + l2)\n                    if not (g23_min <= g23 <= g23_max):\n                        continue\n\n                    # At this point, a valid triplet (p1, p2, p3) has been found.\n                    # Now, classify it based on critical residues.\n                    is_canonical_triplet = (c1 == crit1_char and c2 == crit2_char and c3 == crit3_char)\n\n                    if is_canonical_triplet:\n                        has_canonical = True\n                    else:\n                        has_pseudo = True\n        \n        all_results.append([has_canonical, has_pseudo])\n\n    # Format the final output string exactly as specified.\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n```"
        },
        {
            "introduction": "While deterministic patterns are powerful, they can be too rigid to capture the full diversity of a protein family. This final practice introduces a more sophisticated and robust approach: the profile Hidden Markov Model (HMM). HMMs are probabilistic models that excel at representing the consensus of a domain family, including common substitutions and insertions or deletions. In this exercise , you will implement a core bioinformatics algorithm to score sequences against a simplified HMM, learning to use log-odds scoring to decide if a sequence is a true member of the family or simply a product of random chance.",
            "id": "2420110",
            "problem": "You are given a simplified, fully specified profile Hidden Markov Model (HMM) for the conserved palm-domain core of viral RNA-dependent RNA polymerases, focusing on three hallmark motifs. The model is to be used to decide whether protein sequences contain a local subsequence consistent with this domain. The goal is to compute, for each provided sequence, whether there exists a contiguous subsequence whose log-odds score against a uniform background is at least a specified threshold.\n\nAlphabet and background model:\n- The amino acid alphabet is the set of $20$ standard uppercase letters $\\{ \\mathrm{A}, \\mathrm{C}, \\mathrm{D}, \\mathrm{E}, \\mathrm{F}, \\mathrm{G}, \\mathrm{H}, \\mathrm{I}, \\mathrm{K}, \\mathrm{L}, \\mathrm{M}, \\mathrm{N}, \\mathrm{P}, \\mathrm{Q}, \\mathrm{R}, \\mathrm{S}, \\mathrm{T}, \\mathrm{V}, \\mathrm{W}, \\mathrm{Y} \\}$.\n- Additionally, the symbol $\\mathrm{X}$ denotes an unknown residue and must be treated as having the same emission probability as the background.\n- The background model is an independent and identically distributed process with probability $1/20$ for each letter in the $20$-letter alphabet. For $\\mathrm{X}$, use $1/20$ as well.\n- All logarithms must be natural logarithms.\n\nHMM structure:\n- The HMM has the following emitting states: $\\mathrm{MA1}, \\mathrm{MA2}, \\mathrm{MA3}, \\mathrm{MA4}, \\mathrm{MA5}, \\mathrm{IA}, \\mathrm{MB1}, \\mathrm{MB2}, \\mathrm{MB3}, \\mathrm{MB4}, \\mathrm{IB}, \\mathrm{MC1}, \\mathrm{MC2}, \\mathrm{MC3}$.\n- The HMM is entered before emitting $\\mathrm{MA1}$ and is exited immediately after emitting $\\mathrm{MC3}$. There are no non-emitting states during emission; begin and end are implicit.\n- Allowed transitions and their probabilities:\n  - $\\mathrm{MA1} \\to \\mathrm{MA2}$ with probability $1$.\n  - $\\mathrm{MA2} \\to \\mathrm{MA3}$ with probability $1$.\n  - $\\mathrm{MA3} \\to \\mathrm{MA4}$ with probability $1$.\n  - $\\mathrm{MA4} \\to \\mathrm{MA5}$ with probability $1$.\n  - $\\mathrm{MA5} \\to \\mathrm{MB1}$ with probability $0.7$.\n  - $\\mathrm{MA5} \\to \\mathrm{IA}$ with probability $0.3$.\n  - $\\mathrm{IA} \\to \\mathrm{IA}$ with probability $0.8$.\n  - $\\mathrm{IA} \\to \\mathrm{MB1}$ with probability $0.2$.\n  - $\\mathrm{MB1} \\to \\mathrm{MB2}$ with probability $1$.\n  - $\\mathrm{MB2} \\to \\mathrm{MB3}$ with probability $1$.\n  - $\\mathrm{MB3} \\to \\mathrm{MB4}$ with probability $1$.\n  - $\\mathrm{MB4} \\to \\mathrm{MC1}$ with probability $0.7$.\n  - $\\mathrm{MB4} \\to \\mathrm{IB}$ with probability $0.3$.\n  - $\\mathrm{IB} \\to \\mathrm{IB}$ with probability $0.8$.\n  - $\\mathrm{IB} \\to \\mathrm{MC1}$ with probability $0.2$.\n  - $\\mathrm{MC1} \\to \\mathrm{MC2}$ with probability $1$.\n  - $\\mathrm{MC2} \\to \\mathrm{MC3}$ with probability $1$.\n- Any transition not listed is disallowed (probability $0$).\n\nEmissions:\n- For states $\\mathrm{MA1}$, $\\mathrm{MB1}$, $\\mathrm{MC1}$, $\\mathrm{MC2}$, and $\\mathrm{MC3}$, a consensus residue is expected. The emission probabilities are:\n  - If the observed residue equals the consensus letter, the emission probability is $0.9$.\n  - If the observed residue is one of the other $19$ letters in the alphabet and not equal to the consensus, the emission probability is $0.1/19$.\n  - If the observed residue is $\\mathrm{X}$, the emission probability is $1/20$.\n- The consensus letters are:\n  - $\\mathrm{MA1}$ expects $\\mathrm{D}$.\n  - $\\mathrm{MB1}$ expects $\\mathrm{G}$.\n  - $\\mathrm{MC1}$ expects $\\mathrm{G}$.\n  - $\\mathrm{MC2}$ expects $\\mathrm{D}$.\n  - $\\mathrm{MC3}$ expects $\\mathrm{D}$.\n- For all other emitting states $\\mathrm{MA2}, \\mathrm{MA3}, \\mathrm{MA4}, \\mathrm{MA5}, \\mathrm{MB2}, \\mathrm{MB3}, \\mathrm{MB4}, \\mathrm{IA}, \\mathrm{IB}$, the emission distribution is uniform over the alphabet, that is, $1/20$ for any of the $20$ letters. For $\\mathrm{X}$, use $1/20$.\n\nScoring and decision rule:\n- For a given protein sequence, consider every contiguous subsequence. For any subsequence of length $L$, let $P_{\\mathrm{HMM}}$ denote the maximum probability of generating that subsequence by any valid path that starts at $\\mathrm{MA1}$ and ends at $\\mathrm{MC3}$ while emitting exactly $L$ residues and respecting all transition constraints and emission probabilities given above. Let $P_{\\mathrm{BG}}$ denote the background probability of the same subsequence under the uniform independent model, that is $P_{\\mathrm{BG}} = (1/20)^L$.\n- Define the log-odds score for that subsequence as\n$$\n\\mathrm{LLR} = \\ln P_{\\mathrm{HMM}} - \\ln P_{\\mathrm{BG}}.\n$$\n- For the sequence, define the final score as the maximum $\\mathrm{LLR}$ over all of its contiguous subsequences.\n- Use the threshold $T = 5.0$. If the maximum $\\mathrm{LLR} \\ge T$, classify the sequence as containing the domain (boolean value $\\mathrm{True}$); otherwise classify as not containing the domain (boolean value $\\mathrm{False}$).\n\nTest suite:\n- Use the following ordered list of protein sequences (strings). The alphabet is restricted as described, and any $\\mathrm{X}$ denotes an unknown residue to be handled as specified.\n  - Case $1$: $\\mathrm{DAAAAGAAAGDD}$\n  - Case $2$: $\\mathrm{MTRNAVDPQMDKSTADGAAAGDDQL}$\n  - Case $3$: $\\mathrm{ACFLKPNRTSVYHMIQLKTAACFLKPNR}$\n  - Case $4$: $\\mathrm{DAAAADVVVVVLLLLLPPPPPSSSSSTTTTTGAAAVVVVVLLLLLPPPPPSSSSSTTTTTGDD}$\n  - Case $5$: $\\mathrm{XAAAADGAAAGDX}$\n  - Case $6$: $\\mathrm{DGGD}$\n\nRequired final output format:\n- Your program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the same order as the test suite. Each result must be a boolean rendered as either $\\mathrm{True}$ or $\\mathrm{False}$, for example, $[\\mathrm{True},\\mathrm{False},\\mathrm{True}]$.",
            "solution": "The problem presented requires the validation of protein sequences against a simplified profile Hidden Markov Model (HMM) representing a conserved protein domain. The task is to determine, for each sequence, if any contiguous subsequence achieves a log-odds score of at least a given threshold, $T = 5.0$. The score is calculated by comparing the maximal probability of the subsequence being generated by the HMM, $P_{\\mathrm{HMM}}$, against its probability under a uniform background model, $P_{\\mathrm{BG}}$.\n\nFirst, we formalize the problem. The log-odds score, LLR, for a subsequence $S'$ of length $L$ is given by:\n$$ \\mathrm{LLR} = \\ln P_{\\mathrm{HMM}}(S') - \\ln P_{\\mathrm{BG}}(S') $$\nThe background model is uniform, so $P_{\\mathrm{BG}}(S') = (1/20)^L$. Its logarithm is $\\ln P_{\\mathrm{BG}}(S') = L \\ln(1/20) = -L \\ln(20)$.\nThe HMM probability, $P_{\\mathrm{HMM}}(S')$, is the maximum probability over all possible paths $\\pi$ of length $L$ that start at state $\\mathrm{MA1}$ and end at state $\\mathrm{MC3}$:\n$$ P_{\\mathrm{HMM}}(S') = \\max_{\\pi: \\pi_0=\\mathrm{MA1}, \\pi_{L-1}=\\mathrm{MC3}} \\left( \\prod_{k=0}^{L-1} P_{\\text{emission}}(S'_k | \\pi_k) \\prod_{k=0}^{L-2} P_{\\text{transition}}(\\pi_{k+1} | \\pi_k) \\right) $$\nSubstituting these into the LLR equation and using properties of logarithms, we get:\n$$ \\mathrm{LLR} = \\max_{\\pi} \\left( \\sum_{k=0}^{L-1} \\ln P_{\\text{emission}}(S'_k | \\pi_k) + \\sum_{k=0}^{L-2} \\ln P_{\\text{transition}}(\\pi_{k+1} | \\pi_k) \\right) + L \\ln(20) $$\nThis can be rearranged into a sum of log-odds emission scores and log-transition probabilities:\n$$ \\mathrm{LLR} = \\max_{\\pi} \\left( \\sum_{k=0}^{L-1} \\left( \\ln P_{\\text{emission}}(S'_k | \\pi_k) + \\ln(20) \\right) + \\sum_{k=0}^{L-2} \\ln P_{\\text{transition}}(\\pi_{k+1} | \\pi_k) \\right) $$\nLet the log-odds emission score for residue $c$ in state $k$ be $E(c, k) = \\ln(P_{\\text{emission}}(c | k) \\times 20)$, and the log-transition probability be $T(j, k) = \\ln P_{\\text{transition}}(k | j)$. The problem is to find the maximum LLR over all contiguous subsequences of the input protein.\n\nA brute-force approach iterating through all subsequences is computationally prohibitive. A more efficient solution utilizes dynamic programming, specifically a Viterbi-like algorithm modified for local alignment detection. We define a DP table, $V[i][k]$, to store the maximum log-odds score of any path that ends at state $k$, having emitted the $i$-th residue of the input sequence $S$. The \"local\" nature of the alignment is handled by allowing a new alignment to begin at any position in the sequence, which corresponds to initializing a path in the start state $\\mathrm{MA1}$.\n\nThe states of the HMM are indexed from $0$ to $13$. Let the set of states be $\\mathcal{K} = \\{ \\mathrm{MA1}, \\dots, \\mathrm{MC3} \\}$. The DP table $V$ has dimensions $N \\times |\\mathcal{K}|$, where $N$ is the length of the sequence $S=S_0S_1...S_{N-1}$.\n\nThe recurrence relations are as follows:\nFor the initial state $\\mathrm{MA1}$, an alignment can start at any position $i$:\n$$ V[i][\\mathrm{MA1}] = E(S_i, \\mathrm{MA1}) $$\nFor any other state $k \\in \\mathcal{K} \\setminus \\{\\mathrm{MA1}\\}$, the score is calculated based on the scores of its predecessor states at the previous position $i-1$:\n$$ V[i][k] = E(S_i, k) + \\max_{j \\in \\text{Pred}(k)} \\left( V[i-1][j] + T(j, k) \\right) \\quad \\text{for } i > 0 $$\nwhere $\\text{Pred}(k)$ is the set of states that can transition to state $k$. For $i=0$, $V[0][k] = -\\infty$ for $k \\ne \\mathrm{MA1}$, as any path must start at $\\mathrm{MA1}$.\n\nThe log-odds emission scores $E(c, k)$ are pre-calculated:\n- For consensus states ($\\mathrm{MA1}, \\mathrm{MB1}, \\mathrm{MC1}, \\mathrm{MC2}, \\mathrm{MC3}$):\n  - Match: $\\ln(0.9 \\times 20) = \\ln(18) \\approx 2.8904$\n  - Mismatch: $\\ln((0.1/19) \\times 20) = \\ln(2/19) \\approx -2.2513$\n  - Unknown ('$\\mathrm{X}$'): $\\ln((1/20) \\times 20) = \\ln(1) = 0$\n- For uniform states (all others):\n  - Any residue: $\\ln((1/20) \\times 20) = \\ln(1) = 0$\n\nLog-transition probabilities $T(j, k)$ are also pre-calculated:\n- $P=1 \\implies T = \\ln(1) = 0$\n- $P=0.8 \\implies T = \\ln(0.8) \\approx -0.2231$\n- $P=0.7 \\implies T = \\ln(0.7) \\approx -0.3567$\n- $P=0.3 \\implies T = \\ln(0.3) \\approx -1.2040$\n- $P=0.2 \\implies T = \\ln(0.2) \\approx -1.6094$\n\nThe algorithm proceeds by iterating through the sequence from $i=0$ to $N-1$, filling the DP table $V$. At each position $i$, we compute $V[i][k]$ for all states $k$. The problem specifies that a valid path for the domain must end in state $\\mathrm{MC3}$. Therefore, after computing all scores for position $i$, we update a running maximum score, $\\mathrm{LLR}_{\\max}$, with the value of $V[i][\\mathrm{MC3}]$.\n$$ \\mathrm{LLR}_{\\max} = \\max_{i \\in [0, N-1]} V[i][\\mathrm{MC3}] $$\nInitially, $\\mathrm{LLR}_{\\max}$ is set to $-\\infty$. After iterating through the entire sequence, the final $\\mathrm{LLR}_{\\max}$ is compared with the threshold $T=5.0$. If $\\mathrm{LLR}_{\\max} \\geq T$, the sequence is classified as containing the domain (True); otherwise, it is not (False). This procedure is applied to each sequence in the test suite.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the protein domain identification problem using a Viterbi-like algorithm.\n    \"\"\"\n    \n    # Define problem parameters\n    THRESHOLD = 5.0\n    ALPHABET = \"ACDEFGHIKLMNPQRSTVWY\"\n    STATES = [\n        \"MA1\", \"MA2\", \"MA3\", \"MA4\", \"MA5\", \"IA\", \n        \"MB1\", \"MB2\", \"MB3\", \"MB4\", \"IB\", \n        \"MC1\", \"MC2\", \"MC3\"\n    ]\n    CONSENSUS_SPEC = {\n        'MA1': 'D', 'MB1': 'G', 'MC1': 'G', 'MC2': 'D', 'MC3': 'D'\n    }\n    \n    TRANSITIONS = [\n        ('MA1', 'MA2', 1.0), ('MA2', 'MA3', 1.0), ('MA3', 'MA4', 1.0), ('MA4', 'MA5', 1.0),\n        ('MA5', 'MB1', 0.7), ('MA5', 'IA', 0.3),\n        ('IA', 'IA', 0.8), ('IA', 'MB1', 0.2),\n        ('MB1', 'MB2', 1.0), ('MB2', 'MB3', 1.0), ('MB3', 'MB4', 1.0),\n        ('MB4', 'MC1', 0.7), ('MB4', 'IB', 0.3),\n        ('IB', 'IB', 0.8), ('IB', 'MC1', 0.2),\n        ('MC1', 'MC2', 1.0), ('MC2', 'MC3', 1.0),\n    ]\n\n    # Pre-computation\n    # 1. Mappings\n    state_map = {name: i for i, name in enumerate(STATES)}\n    num_states = len(STATES)\n    char_map = {c: i for i, c in enumerate(ALPHABET)}\n    char_map['X'] = 20\n    \n    # 2. Log-odds emission scores\n    log_emission_scores = np.full((num_states, 21), 0.0) # Default is uniform, log-odds = 0\n    for state_name, cons_char in CONSENSUS_SPEC.items():\n        state_idx = state_map[state_name]\n        cons_char_idx = char_map[cons_char]\n        for char_code in range(21):\n            if char_code == 20: # 'X'\n                log_emission_scores[state_idx, char_code] = 0.0\n            elif char_code == cons_char_idx:\n                log_emission_scores[state_idx, char_code] = np.log(0.9 * 20) # Match\n            else:\n                log_emission_scores[state_idx, char_code] = np.log((0.1 / 19) * 20) # Mismatch\n\n    # 3. Log-transition probabilities and predecessor structure\n    predecessors = {i: [] for i in range(num_states)}\n    for from_s, to_s, prob in TRANSITIONS:\n        log_prob = np.log(prob)\n        predecessors[state_map[to_s]].append((state_map[from_s], log_prob))\n\n    test_cases = [\n        \"DAAAAGAAAGDD\",\n        \"MTRNAVDPQMDKSTADGAAAGDDQL\",\n        \"ACFLKPNRTSVYHMIQLKTAACFLKPNR\",\n        \"DAAAADVVVVVLLLLLPPPPPSSSSSTTTTTGAAAVVVVVLLLLLPPPPPSSSSSTTTTTGDD\",\n        \"XAAAADGAAAGDX\",\n        \"DGGD\",\n    ]\n\n    results = []\n    \n    s_idx_ma1 = state_map['MA1']\n    s_idx_mc3 = state_map['MC3']\n\n    for seq in test_cases:\n        seq_len = len(seq)\n        if seq_len == 0:\n            results.append(False)\n            continue\n\n        V = np.full((seq_len, num_states), -np.inf)\n        max_llr = -np.inf\n\n        for i in range(seq_len):\n            char_idx = char_map.get(seq[i])\n\n            # Recurrence for MA1 (start of a local alignment)\n            V[i, s_idx_ma1] = log_emission_scores[s_idx_ma1, char_idx]\n            \n            # Recurrence for other states\n            if i > 0:\n                for k in range(num_states):\n                    if k == s_idx_ma1: continue \n                    \n                    max_prev_score = -np.inf\n                    if predecessors[k]:\n                        for pred_idx, log_trans_prob in predecessors[k]:\n                            score = V[i-1, pred_idx] + log_trans_prob\n                            if score > max_prev_score:\n                                max_prev_score = score\n                    \n                    if max_prev_score > -np.inf:\n                         V[i, k] = max_prev_score + log_emission_scores[k, char_idx]\n            \n            # Check for new max score at the final state\n            if V[i, s_idx_mc3] > max_llr:\n                max_llr = V[i, s_idx_mc3]\n\n        results.append(max_llr >= THRESHOLD)\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}