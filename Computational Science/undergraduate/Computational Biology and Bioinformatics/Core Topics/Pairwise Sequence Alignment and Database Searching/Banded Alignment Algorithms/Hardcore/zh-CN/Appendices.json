{
    "hands_on_practices": [
        {
            "introduction": "理论知识是基础，但真正的掌握来自于实践。这些动手练习旨在帮助你将带状比对算法的抽象概念转化为具体的计算技能。理解一个算法最好的方法之一就是亲手执行它。这项练习将引导你完成一个带状全局比对问题的手动计算，让你在一个小规模的动态规划矩阵上，一步步应用带宽约束，从而将抽象的递推规则变得具体化和形象化。",
            "id": "2374044",
            "problem": "给定两个脱氧核糖核酸 (DNA) 序列，要求使用动态规划 (DP) 计算一个带状全局比对，然后执行回溯以确定最优路径。在标准的全局比对框架 (Needleman–Wunsch (NW)) 内，使用线性罚分进行计算，但将计算限制在固定半宽度的对角带内。请使用以下数据和定义。\n\n- 序列：$S = \\text{\"GACT\"}$，长度 $m = 4$；以及 $T = \\text{\"GAT\"}$，长度 $n = 3$。\n- 评分方案：匹配 $= +2$，错配 $= -1$，空位 $= -2$。\n- 带状约束：只允许计算满足 $|i - j| \\le w$ 的 DP 单元格 $(i,j)$，其中带半宽度 $w = 1$。任何需要进入 $|i - j| > w$ 单元格的转移都是不允许的，并被视为得分为 $-\\infty$。\n- 初始化遵循全局比对的定义：将一个非空前缀与空字符串对齐的成本是字母数乘以空位罚分，但这仅适用于带内的单元格。具体而言，设置 $D(0,0) = 0$；对于任何 $i \\ge 1$，如果 $|i - 0| \\le w$，则 $D(i,0) = i \\times (-2)$；对于任何 $j \\ge 1$，如果 $|0 - j| \\le w$，则 $D(0,j) = j \\times (-2)$。任何带外的边界单元格都是不允许的。\n\n任务：\n1. 根据带状约束，使用全局比对的最优子结构原理（仅考虑从允许的前驱单元格进行的对角、向上和向左转移），手动填写所有允许的 DP 单元格 $D(i,j)$。\n2. 在带内执行回溯，以确定一条从 $(i,j) = (m,n)$ 到 $(0,0)$ 的最优带状全局比对路径。\n3. 使用你完成的 DP 表和回溯结果，给出最优带状全局比对分数 $D(m,n)$。\n\n请仅报告最终的最优带状全局比对分数作为你的答案。无需四舍五入，也没有单位。你的最终答案必须是一个实数值。",
            "solution": "问题陈述已经过严格评估，被认为是有效的。它科学地基于生物信息学的既定原则，特别是用于全局序列比对的 Needleman-Wunsch 算法，并增加了标准的带状约束。该问题定义明确，提供了所有必要的参数：两个序列 $S$ 和 $T$、它们的长度 $m$ 和 $n$、一个完整的评分方案（匹配、错配、空位罚分），以及对带半宽度 $w$ 和初始化条件的精确定义。目标清晰且可形式化。因此，我们开始进行求解。\n\n目标是计算两个 DNA 序列 $S = \\text{\"GACT\"}$（长度 $m=4$）和 $T = \\text{\"GAT\"}$（长度 $n=3$）的带状全局比对的最优分数。动态规划 (DP) 表，记为 $D$，其维度为 $(m+1) \\times (n+1)$，即 $5 \\times 4$。索引 $i$ 的范围从 $0$ 到 $4$，对应于 $S$ 的前缀；索引 $j$ 的范围从 $0$ 到 $3$，对应于 $T$ 的前缀。\n\n计算被限制在由约束 $|i - j| \\le w$ 定义的带内，其中半宽度 $w=1$。任何不满足此条件的单元格 $(i,j)$ 都被认为是不可访问的，等同于其分数为 $-\\infty$。在 $5 \\times 4$ 的 DP 网格中，允许的单元格是满足 $|i - j| \\le 1$ 的那些。\n\n评分方案为：匹配得分 $s_{match} = +2$，错配得分 $s_{mismatch} = -1$，以及线性空位罚分 $g = -2$。\n\n带内单元格 $D(i,j)$ 的递推关系源自标准的 Needleman-Wunsch 算法：\n$$\nD(i,j) = \\max\n\\begin{cases}\nD(i-1, j-1) + \\text{score}(S_i, T_j)  \\text{(来自对角)} \\\\\nD(i-1, j) + g  \\text{(来自上方)} \\\\\nD(i, j-1) + g  \\text{(来自左方)}\n\\end{cases}\n$$\n其中，如果 $S_i = T_j$，则 $\\text{score}(S_i, T_j)$ 为 $s_{match}$，否则为 $s_{mismatch}$。带外的前驱单元格为此最大化过程提供 $-\\infty$ 的分数，从而有效阻止了从该单元格的转移。\n\n**步骤 1：初始化**\n根据问题描述，$D(0,0) = 0$。对于第一行和第一列，我们初始化位于带内的单元格：\n- 对于 $i \\ge 1$，$D(i,0) = i \\times g$，条件是 $|i-0| \\le w=1$。这仅对 $i=1$ 成立。因此，$D(1,0) = 1 \\times (-2) = -2$。单元格 $(2,0)$ 在带外，因为 $|2-0| > 1$。\n- 对于 $j \\ge 1$，$D(0,j) = j \\times g$，条件是 $|0-j| \\le w=1$。这仅对 $j=1$ 成立。因此，$D(0,1) = 1 \\times (-2) = -2$。单元格 $(0,2)$ 在带外，因为 $|0-2| > 1$。\n所有其他边界单元格都在带外，不进行计算。\n\n初始化单元格总结（X 表示带外）：\n- $D(0,0)=0$\n- $D(1,0)=-2$\n- $D(0,1)=-2$\n- 对于 $(i,j) \\in \\{(2,0), (3,0), (4,0), (0,2), (0,3)\\}$，$D(i,j) = X$\n\n**步骤 2：填充 DP 表**\n我们按照尊重数据依赖关系的顺序（例如，逐行或逐列）计算剩余可访问单元格的分数。\n\n- **单元格 (1,1):** $|1-1|=0 \\le 1$。\n$S_1=\\text{'G'}, T_1=\\text{'G'}$ (匹配)。\n$D(1,1) = \\max(D(0,0)+s_{match}, D(0,1)+g, D(1,0)+g) = \\max(0+2, -2-2, -2-2) = 2$。\n\n- **单元格 (1,2):** $|1-2|=1 \\le 1$。\n$S_1=\\text{'G'}, T_2=\\text{'A'}$ (错配)。前驱单元格 $(0,2)$ 在带外。\n$D(1,2) = \\max(D(0,1)+s_{mismatch}, D(1,1)+g) = \\max(-2-1, 2-2) = 0$。\n\n- **单元格 (2,1):** $|2-1|=1 \\le 1$。\n$S_2=\\text{'A'}, T_1=\\text{'G'}$ (错配)。前驱单元格 $(2,0)$ 在带外。\n$D(2,1) = \\max(D(1,0)+s_{mismatch}, D(1,1)+g) = \\max(-2-1, 2-2) = 0$。\n\n- **单元格 (2,2):** $|2-2|=0 \\le 1$。\n$S_2=\\text{'A'}, T_2=\\text{'A'}$ (匹配)。\n$D(2,2) = \\max(D(1,1)+s_{match}, D(1,2)+g, D(2,1)+g) = \\max(2+2, 0-2, 0-2) = 4$。\n\n- **单元格 (2,3):** $|2-3|=1 \\le 1$。\n$S_2=\\text{'A'}, T_3=\\text{'T'}$ (错配)。前驱单元格 $(1,3)$ 在带外。\n$D(2,3) = \\max(D(1,2)+s_{mismatch}, D(2,2)+g) = \\max(0-1, 4-2) = 2$。\n\n- **单元格 (3,2):** $|3-2|=1 \\le 1$。\n$S_3=\\text{'C'}, T_2=\\text{'A'}$ (错配)。前驱单元格 $(3,1)$ 在带外。\n$D(3,2) = \\max(D(2,1)+s_{mismatch}, D(2,2)+g) = \\max(0-1, 4-2) = 2$。\n\n- **单元格 (3,3):** $|3-3|=0 \\le 1$。\n$S_3=\\text{'C'}, T_3=\\text{'T'}$ (错配)。\n$D(3,3) = \\max(D(2,2)+s_{mismatch}, D(2,3)+g, D(3,2)+g) = \\max(4-1, 2-2, 2-2) = 3$。\n\n- **单元格 (4,3):** $|4-3|=1 \\le 1$。这是最终的单元格 $D(m,n)$。\n$S_4=\\text{'T'}, T_3=\\text{'T'}$ (匹配)。前驱单元格 $(4,2)$ 在带外。\n$D(4,3) = \\max(D(3,2)+s_{match}, D(3,3)+g) = \\max(2+2, 3-2) = 4$。\n\n**步骤 3：回溯与最终分数**\n计算出的 DP 矩阵（仅显示可访问的单元格）如下所示：\n$$\n\\begin{array}{c|cccc}\nD  \\epsilon  \\text{G}  \\text{A}  \\text{T} \\\\\n\\hline\n\\epsilon  0  -2  X  X \\\\\n\\text{G}  -2  2  0  X \\\\\n\\text{A}  X  0  4  2 \\\\\n\\text{C}  X  X  2  3 \\\\\n\\text{T}  X  X  X  4 \\\\\n\\end{array}\n$$\n带状全局比对的最优分数是右下角可访问单元格中的值，$D(m,n) = D(4,3)$。根据我们的计算，该分数为 $4$。\n\n从 $D(4,3)$ 开始的回溯证实了此分数。值 $D(4,3)=4$ 来自对角前驱 $D(3,2)$，对应于将 $S_4=\\text{'T'}$ 与 $T_3=\\text{'T'}$ 对齐。值 $D(3,2)=2$ 来自上方前驱 $D(2,2)$，对应于将 $S_3=\\text{'C'}$ 与一个空位对齐。值 $D(2,2)=4$ 来自对角前驱 $D(1,1)$，对应于将 $S_2=\\text{'A'}$ 与 $T_2=\\text{'A'}$ 对齐。最后，$D(1,1)=2$ 来自对角前驱 $D(0,0)=0$，对应于将 $S_1=\\text{'G'}$ 与 $T_1=\\text{'G'}$ 对齐。这得出了比对结果：\nS: G A C T\nT: G A - T\n分数为 $(+2) + (+2) + (-2) + (+2) = 4$，与结果一致。\n\n最终的最优带状全局比对分数为 $D(4,3)$。",
            "answer": "$$\\boxed{4}$$"
        },
        {
            "introduction": "掌握了基本计算方法后，一个关键的实际问题是：带宽应该设为多宽？这项练习将你的关注点从“如何计算”转移到“如何设计”，挑战你为特定序列确定保证能找到真正最优比对所需的最小带宽。这突出了在计算速度和比对灵敏度之间的核心权衡。",
            "id": "2373995",
            "problem": "两个脱氧核糖核酸（DNA）序列将使用带有仿射空位罚分的 Needleman–Wunsch (NW) 算法进行全局比对。设序列 $S$ 为\nAAAAAACCCCCCTTTTTTGGGGGG\n设序列 $T$ 为\nAAAAAACCCCCCGGGGGG。\n评分方案如下：匹配得分 $+1$，错配得分 $-2$，空位开放罚分 $-2$，以及空位延伸罚分 $-1$。在仿射罚分下，一个长度为 $\\ell$ 的连续空位产生的总分数为 $-2-(\\ell-1)\\cdot 1$。\n\n考虑一种动态规划（DP）解决方案的带状实现，该实现将计算限制在满足 $|i-j| \\leq k$ 的单元格 $(i,j)$ 内，其中 $i$ 是序列 $S$ 中位置的索引（从 $0$ 到 $n$），$j$ 是序列 $T$ 中位置的索引（从 $0$ 到 $m$）。确定最小的非负整数带半宽度 $k_{\\min}$，使得带状算法能够保证在给定的评分方案下，为这两个序列找到真正的最优全局比对分数。\n\n请以单个整数形式提供最终答案。无需四舍五入。",
            "solution": "该问题要求确定 Needleman-Wunsch 算法带状实现的最小非负整数带半宽度，记为 $k_{\\min}$。这个 $k_{\\min}$ 必须足以保证在仿射空位罚分模型下，能够为两个特定的DNA序列 $S$ 和 $T$ 找到真正的最优全局比对分数。\n\n首先，我们必须将给定的信息形式化。\n序列为：\n$S = \\text{AAAAAACCCCCCTTTTTTGGGGGG}$\n$T = \\text{AAAAAACCCCCCGGGGGG}$\n序列 $S$ 的长度为 $n=24$。序列 $T$ 的长度为 $m=18$。\n\n评分方案如下：\n- 匹配得分：$s_{\\text{match}} = +1$\n- 错配得分：$s_{\\text{mismatch}} = -2$\n- 空位开放罚分：$g_{\\text{open}} = -2$\n- 空位延伸罚分：$g_{\\text{extend}} = -1$\n\n一个长度为 $\\ell$ 的连续空位产生的总罚分为 $G(\\ell) = g_{\\text{open}} + (\\ell-1)g_{\\text{extend}} = -2 - (\\ell-1)$。\n\n带状比对算法将动态规划计算限制在DP矩阵中的一个单元格带 $(i,j)$ 内，其中 $i$ 是序列 $S$ 的索引（从 $0$到 $n$），$j$ 是序列 $T$ 的索引（从 $0$ 到 $m$），且满足条件 $|i-j| \\leq k$。该算法保证能找到最优比对，当且仅当对应于最优比对的整个路径都位于此带内。因此，所需的最小半宽度 $k_{\\min}$ 是构成最优比对路径的所有单元格 $(i,j)$ 中 $|i-j|$ 的最大值。\n\n因此，我们的任务是确定 $S$ 和 $T$ 的最优全局比对，然后计算其在DP矩阵中对应路径上 $|i-j|$ 的最大值。\n\n让我们分析序列的结构。\n序列 $S$ 由四个含有六个相同核苷酸的块组成：\n$S = S_1 S_2 S_3 S_4$，其中 $S_1=\\text{A}_6$, $S_2=\\text{C}_6$, $S_3=\\text{T}_6$, $S_4=\\text{G}_6$。\n序列 $T$ 由三个含有六个相同核苷酸的块组成：\n$T = T_1 T_2 T_3$，其中 $T_1=\\text{A}_6$, $T_2=\\text{C}_6$, $T_3=\\text{G}_6$。\n\n最优比对将通过尽可能比对相同的块来最大化总分。块 $S_1$ 和 $T_1$、$S_2$ 和 $T_2$，以及 $S_4$ 和 $T_3$ 是相同的。序列 $S$ 中的块 $S_3 = \\text{TTTTTT}$ 在序列 $T$ 中没有同源对应部分。\n\n最优比对策略是直观清晰的：\n1. 将 $S_1S_2$ 与 $T_1T_2$ 对齐。这是将 $\\text{AAAAAACCCCCC}$ 与 $\\text{AAAAAACCCCCC}$ 进行比对，包含 $12$ 个匹配。这部分的分数是 $12 \\times s_{\\text{match}} = 12 \\times 1 = 12$。\n2. 处理块 $S_3 = \\text{TTTTTT}$。它可以与 $T$ 中的一个空位对齐，或者与 $T$ 中的下一个块 $T_3 = \\text{GGGGGG}$ 错配。\n   - 方案A：将 $S_3$ 与序列 $T$ 中长度为 $\\ell=6$ 的空位对齐。由此产生的得分是空位罚分 $G(6) = -2 - (6-1) \\times 1 = -7$。\n   - 方案B：将 $S_3$ 与 $T_3$ 对齐。这将导致 $6$ 个错配（`T` vs `G`）。得分将是 $6 \\times s_{\\text{mismatch}} = 6 \\times (-2) = -12$。\n   由于 $-7 > -12$，将 $S_3$ 与空位对齐是该片段的最优选择。\n3. 将剩余的块 $S_4 = \\text{GGGGGG}$ 与 $T_3 = \\text{GGGGGG}$ 对齐。这次比对提供了 $6$ 个匹配，得分为 $6 \\times s_{\\text{match}} = 6 \\times 1 = 6$。\n\n由此产生的最优比对是：\n$S$: AAAAAACCCCCCTTTTTTGGGGGG\n$T$: AAAAAACCCCC------GGGGGG\n\n该比对的总分是 $12 + (-7) + 6 = 11$。任何其他比对都会引入错配或次优空位，导致得分更低。例如，打断完美匹配的块会将匹配得分（$+1$）替换为错配（$-2$）或空位（开放罚分 $-2$）得分，这显然是次优的。\n\n现在我们必须在大小为 $(n+1) \\times (m+1) = 25 \\times 19$ 的DP矩阵中追踪这个最优比对的路径。索引为 $i \\in [0, 24]$ 和 $j \\in [0, 18]$。路径从 $(0,0)$ 开始，到 $(24,18)$ 结束。\n\n1.  前 $12$ 个字符（$\\text{AAAAAACCCCCC}$）的比对是完美匹配。这对应于DP矩阵中的 $12$ 次对角线移动。路径从 $(0,0)$ 移动到 $(12,12)$。对于该段路径上的任何单元格 $(i,j)$，我们有 $i=j$，所以 $|i-j|=0$。\n\n2.  来自 $S$ 的 $\\text{TTTTTT}$ 与 $T$ 中的空位的比对，对应于DP矩阵中的 $6$ 次垂直移动（因为我们消耗了 $S$ 的字符但没有消耗 $T$ 的字符）。路径从 $(12,12)$ 移动到 $(18,12)$。对于该段路径上的任何单元格 $(i,j)$，$j=12$，而 $i$ 的范围是从 $13$ 到 $18$。$|i-j|$ 的值是 $|i-12|$。这个值从 $|13-12|=1$ 增加到单元格 $(18,12)$ 处的最大值 $|18-12|=6$。\n\n3.  最后 $6$ 个字符（$\\text{GGGGGG}$）的比对是另一个完美匹配。这对应于 $6$ 次对角线移动。路径从 $(18,12)$ 移动到 $(24,18)$。对于该段路径上的任何单元格 $(i,j)$，索引之间的关系是 $j = i-6$。这是因为对于每一步 $d \\in \\{1, \\dots, 6\\}$，单元格是 $(18+d, 12+d)$。差值为 $(18+d)-(12+d)=6$。因此，对于这整个片段， $|i-j| = 6$。\n\n结合这三个片段，路径上 $|i-j|$ 的值首先是 $0$，然后从 $1$ 增加到 $6$，最后保持在 $6$ 不变。因此，在整个最优路径上遇到的 $|i-j|$ 的最大值为 $6$。\n\n为了保证带状比对算法能找到这个最优路径，带半宽度 $k$ 必须至少是这个最大值。\n$$k_{\\min} = \\max_{(i,j) \\in \\text{optimal path}} |i-j| = 6$$\n因此，最小的非负整数带半宽度是 $6$。",
            "answer": "$$\\boxed{6}$$"
        },
        {
            "introduction": "使用带状比对的主要动机是节省计算时间和内存。这项练习将我们带入理论分析的层面，要求你推导出算法所执行的计算单元总数的精确公式。通过这种方式，你可以量化效率的提升，并更深入地理解算法的性能表现。",
            "id": "2374058",
            "problem": "考虑一个使用动态规划 (DP) 对两条脱氧核糖核酸 (DNA) 序列进行带状全局比对的算法。设 $S$ 和 $T$ 是字母表 $\\{\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{T}\\}$ 上的两个序列，每个序列的长度为 $n$，其中 $n$ 是一个正整数。DP 矩阵有 $(n+1)$ 行和 $(n+1)$ 列，索引从 $(0,0)$ 到 $(n,n)$。该带状算法计算一个单元格 $(i,j)$ 当且仅当 $|i - j| \\leq w$，其中 $w$ 是一个满足 $0 \\leq w \\leq n$ 的整数半带宽。假设计算算法所计算的任何单个单元格（包括带内的边界单元格）的成本为单位时间。\n\n您必须根据带状 DP 的定义，在所有能使最优全局比对路径从 $(0,0)$ 到 $(n,n)$ 完全保持在带内的序列对和评分方案的最坏情况下，确定作为 $n$ 和 $w$ 的函数所计算的 DP 单元格的精确数量。此外，构建一个明确的序列对 $S$ 和 $T$ 以及一个评分方案（匹配奖励为 $+a$，错配罚分为 $-b$，缺口罚分为 $-g$，其中 $a, b, g$ 是正实数），该方案能强制产生这种最坏情况行为，即最优路径对所有行都保持在带内，并在矩阵边界允许的任何地方都使用整个允许的带宽。\n\n作为您的最终答案，报告一个给出所计算的 DP 单元格精确数量的、关于 $n$ 和 $w$ 的单一封闭形式解析表达式。不要提供任何中间步骤。最终答案无需四舍五入，也不应包含任何单位。",
            "solution": "问题陈述必须首先经过严格验证。\n\n步骤 1：提取已知条件\n- 算法：通过动态规划 (DP) 实现的带状全局比对。\n- 序列：$S$ 和 $T$，字母表 $\\{\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{T}\\}$ 上的两个 DNA 序列。\n- 长度：两个序列的长度均为 $n$，$n$ 是一个正整数。\n- DP 矩阵：大小为 $(n+1) \\times (n+1)$，索引从 $(i,j)$ 的 $(0,0)$ 到 $(n,n)$。\n- 带状条件：当且仅当 $|i - j| \\leq w$ 时，计算单元格 $(i,j)$。\n- 半带宽：$w$ 是一个满足 $0 \\leq w \\leq n$ 的整数。\n- 成本：每个计算单元格的单位时间成本。\n- 目标 1：找出作为 $n$ 和 $w$ 的函数的已计算 DP 单元格的精确数量。\n- 目标 2：构建一个序列 $S, T$ 和评分方案 ($+a, -b, -g$) 的明确示例，以展示所述的最坏情况路径行为。\n\n步骤 2：使用提取的已知条件进行验证\n该问题具有科学依据，因为它涉及对用于序列比对的、完善的带状动态规划算法的分析。该问题是客观且定义明确的。主要任务是一个定义明确的组合计数问题。变量 $n$ 和 $w$ 以及单元格计算的条件都以数学精度进行了陈述。没有矛盾之处。$0 \\le w \\le n$ 的取值与该算法的典型应用领域一致。构建示例的次要任务也是有效的；对于任何给定的比对路径，已知可以构建序列和评分方案来使该路径成为最优路径。最优路径保持在带内的条件是带状算法找到真正全局最优解的先决条件，包含此条件并不构成缺陷。\n\n步骤 3：结论与行动\n该问题被视为有效。我们将继续推导解决方案。\n\n问题要求计算算法所计算的 DP 单元格 $(i,j)$ 的总数。根据问题陈述，这些单元格正是满足以下条件的单元格：\n$1.$ $0 \\le i \\le n$\n$2.$ $0 \\le j \\le n$\n$3.$ $|i - j| \\le w$\n\n这是一个在二维网格的指定区域内计数整数点的问题。我们可以通过对 DP 矩阵中落在带内的每条对角线上的贡献单元格数量求和来解决这个问题。\n\n一条对角线由差值 $k = i - j$ 的一个恒定值定义。条件 $|i - j| \\le w$ 等价于 $|-k| \\le w$，或 $|k| \\le w$。这意味着我们必须考虑总共 $2w+1$ 条对角线，其中 $k \\in \\{-w, -w+1, \\ldots, 0, \\ldots, w-1, w\\}$。\n\n对于由 $k$ 指定的每条对角线，我们必须计算位于其上且同时在网格边界 $0 \\le i \\le n$ 和 $0 \\le j \\le n$ 内的单元格 $(i,j)$ 的数量。将 $j = i - k$ 代入 $j$ 的边界条件，我们得到 $0 \\le i-k \\le n$，这意味着 $k \\le i \\le n+k$。结合条件 $0 \\le i \\le n$，索引 $i$ 的有效范围是 $\\max(0, k) \\le i \\le \\min(n, n+k)$。因此，对角线 $k$ 上的单元格数量，表示为 $N_k$，是 $\\min(n, n+k) - \\max(0, k) + 1$。\n\n我们根据 $k$ 的符号分两种情况进行分析：\n情况 1：$k \\ge 0$。由于 $w \\le n$，我们有 $k \\le n$。$i$ 的范围变为 $k \\le i \\le n$。单元格数量为 $N_k = n - k + 1$。这适用于 $k = 0, 1, \\ldots, w$。\n情况 2：$k  0$。$i$ 的范围变为 $0 \\le i \\le n+k$。单元格数量为 $N_k = (n+k) - 0 + 1 = n+k+1$。这适用于 $k = -1, -2, \\ldots, -w$。\n\n计算的单元格总数 $N$ 是所有有效 $k$ 值的 $N_k$ 之和：\n$$N = \\sum_{k=-w}^{w} N_k = \\sum_{k=-w}^{-1} (n+k+1) + \\sum_{k=0}^{w} (n-k+1)$$\n\n让我们分别计算这两个和。第二个和是：\n$$\\sum_{k=0}^{w} (n-k+1) = (w+1)(n+1) - \\sum_{k=0}^{w} k = (w+1)(n+1) - \\frac{w(w+1)}{2}$$\n这计算了主对角线及其上方的 $w$ 条对角线上的单元格。\n\n对于第一个和，我们改变求和索引。令 $m = -k$。当 $k$ 从 $-w$ 遍历到 $-1$ 时，$m$ 从 $w$ 遍历到 $1$：\n$$\\sum_{k=-w}^{-1} (n+k+1) = \\sum_{m=1}^{w} (n-m+1)$$\n这个和计算了主对角线下方的 $w$ 条对角线上的单元格。该表达式与前一部分中 $k$ 从 $1$ 到 $w$ 的和相同。\n$$\\sum_{m=1}^{w} (n-m+1) = \\sum_{k=1}^{w} (n-k+1) = \\left(\\sum_{k=0}^{w} (n-k+1)\\right) - (n-0+1) = \\left((w+1)(n+1) - \\frac{w(w+1)}{2}\\right) - (n+1)$$\n\n合并这些和：\n$$N = \\left( (w+1)(n+1) - \\frac{w(w+1)}{2} \\right) + \\left( (w+1)(n+1) - \\frac{w(w+1)}{2} - (n+1) \\right)$$\n$$N = 2(w+1)(n+1) - w(w+1) - (n+1)$$\n$$N = (2w+2-1)(n+1) - w(w+1)$$\n$$N = (2w+1)(n+1) - w(w+1)$$\n\n这就是计算单元格的精确数量。这个表达式可以用边界条件进行验证。\n- 对于 $w=0$，带是主对角线。$N = (1)(n+1) - 0 = n+1$，这是正确的。\n- 对于 $w=n$，带覆盖整个矩阵。$N = (2n+1)(n+1) - n(n+1) = (2n+1-n)(n+1) = (n+1)(n+1) = (n+1)^2$，这也是正确的。\n\n通过创建具有不匹配的交替块的序列，强制进行有缺口的比对，并选择一个评分方案，其中错配罚分相对于缺口罚分而言非常高（例如，$b \\gg g$），可以构建将比对路径强制到带边缘 $|i-j|=w$ 的序列。例如，令 $S = (\\text{A}^w \\text{C}^w)^k \\text{A}^{n \\pmod{2w}}$ 和 $T = (\\text{C}^w \\text{A}^w)^k \\text{C}^{n \\pmod{2w}}$，其中 $n=2wk+ (n \\pmod{2w})$。在一个评分方案中，如果错配罚分 $-b$ 的绝对值远大于缺口罚分 $-g$ 的绝对值，那么最优路径将倾向于引入 $w$ 个缺口的块来比对匹配的块（例如，$\\text{C}^w$ 与 $\\text{C}^w$），从而将路径强制到坐标 $(i,j)$ 处，使得 $|i-j|=w$。这证明了问题第二部分的可行性。然而，最终答案只需要单元格计数的解析表达式。",
            "answer": "$$\\boxed{(2w+1)(n+1) - w(w+1)}$$"
        }
    ]
}