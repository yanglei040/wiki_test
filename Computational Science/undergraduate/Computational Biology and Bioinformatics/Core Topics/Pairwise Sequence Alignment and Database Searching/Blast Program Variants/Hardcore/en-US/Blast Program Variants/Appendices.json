{
    "hands_on_practices": [
        {
            "introduction": "This practice establishes a foundational skill: verifying the integrity of your bioinformatics workflow. Before embarking on discovery, it's crucial to perform a \"sanity check\" by searching a database for a sequence you know is present. This exercise explores the rationale behind this vital step and delves into the correct statistical interpretation of a perfect match's E-value, a concept central to all BLAST analyses .",
            "id": "2376102",
            "problem": "You run the Basic Local Alignment Search Tool protein–protein program variant (BLASTP) using a protein query sequence against a protein database that is known to include the exact same protein sequence. The search returns the query sequence as the top hit, and the reported expected value (E-value) for this hit is $0.0$. Which option best describes both a scientifically sound purpose for performing such a search and the correct interpretation of the reported E-value?\n\nA. To sanity-check that the search configuration and database are correct by confirming the expected self-hit; an E-value of $0.0$ indicates an alignment score so extreme that the expected number of equally good random matches is below numerical reporting precision (i.e., effectively zero for practical purposes), not that the probability is literally $0$.\n\nB. To determine the optimal amino acid substitution matrix from the query itself; an E-value of $0.0$ proves the alignment has $100\\%$ identity and no gaps and guarantees the sequences are orthologs.\n\nC. To mask low-complexity regions in the query; an E-value of $0.0$ means the score could not be computed because those regions were removed.\n\nD. To calibrate the statistical parameters of the scoring system from a single alignment; an E-value of $0.0$ means the database is too small to produce any random hit at all.\n\nE. To automatically de-duplicate the database; an E-value of $0.0$ means the expected number of random hits is exactly $0$ and the probability that the sequences are unrelated is exactly $0$.",
            "solution": "The problem statement will now be subjected to rigorous validation.\n\n**Step 1: Extract Givens**\n- Program: Basic Local Alignment Search Tool protein–protein program variant (BLASTP).\n- Query: A protein query sequence.\n- Database: A protein database.\n- Condition: The database contains the exact same protein sequence as the query.\n- Result 1: The search returns the query sequence as the top hit.\n- Result 2: The reported expected value (E-value) for this hit is $0.0$.\n- Question: What is the scientifically sound purpose for this search, and what is the correct interpretation of the E-value?\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is evaluated against the validation criteria.\n\n1.  **Scientific Grounding**: The problem describes a standard procedure in computational biology. BLASTP is a fundamental tool, and the E-value is its primary statistical metric for significance. The scenario of a sequence matching itself in a database is commonplace and serves as a crucial positive control or \"sanity check\". The concepts are firmly rooted in bioinformatics and statistics.\n2.  **Well-Posed**: The problem is well-posed. It asks for the rationale behind a specific, well-defined bioinformatics experiment and the correct interpretation of a specific numerical result. A unique and meaningful solution exists.\n3.  **Objectivity**: The problem is stated in precise, objective language. It is free from ambiguity and subjective claims.\n4.  **Completeness**: The problem provides all necessary information. The context (BLASTP, self-hit) and the specific result (E-value of $0.0$) are sufficient to deduce the purpose and interpretation.\n5.  **Consistency**: There are no internal contradictions in the problem statement. The outcome described (a self-hit being the top result with a very low E-value) is exactly what is expected under the given conditions.\n\n**Step 3: Verdict and Action**\nThe problem statement is scientifically sound, well-posed, and objective. It is a valid problem. I will now proceed with the solution.\n\nThe problem requires an analysis of both the purpose of performing a BLASTP search where the query is known to exist in the database, and the correct interpretation of the resulting E-value of $0.0$.\n\nFirst, let us analyze the purpose. Performing a search with a known positive case—in this instance, a query sequence that is guaranteed to be in the target database—is a fundamental form of a \"sanity check\" or a positive control. If this search fails to return the query sequence itself as the top hit with a maximally significant score, it indicates a critical failure in the experimental setup. This could be due to a corrupted database, an improperly formatted query sequence, incorrect program parameters, or a buggy installation of the software. Therefore, confirming the expected self-hit is a prudent and scientifically sound step to validate the integrity of the search system before using it for discovery-oriented research.\n\nSecond, let us analyze the meaning of an E-value of $0.0$. The E-value, or Expect value, in BLAST statistics represents the number of distinct alignments with a score at least as high as the one observed ($S$) that would be expected to occur purely by chance in a search of a database of a given size. It is calculated using a formula derived from the raw score $S$, or more commonly, from the normalized bit-score $S'$. The bit-score is calculated as $S' = (\\lambda S - \\ln K) / \\ln 2$. The E-value is then given by:\n$$E = m' \\cdot n' \\cdot 2^{-S'}$$\nHere, $\\lambda$ and $K$ are statistical constants derived from the scoring matrix (e.g., BLOSUM62) and the background amino acid frequencies. The terms $m'$ and $n'$ are the effective lengths of the query and the database, respectively, corrected for edge effects.\n\nAn alignment of a protein sequence perfectly against itself will yield an extremely high raw score $S$, determined by the sum of the diagonal elements of the substitution matrix for each amino acid in the sequence. This leads to a very large bit-score $S'$. Consequently, the term $2^{-S'}$ becomes an exceedingly small positive number. Computers perform calculations using finite-precision floating-point arithmetic. If the calculated E-value is smaller than the minimum representable positive value for the data type used (e.g., typically on the order of $10^{-308}$ for double-precision floating-point numbers), the software will report the value as $0.0$. This does not mean the true mathematical E-value is identically zero. The probability of a random event is never truly zero in this context. It simply means the expected number of chance occurrences is so vanishingly small that it is below the numerical precision of the reporting system, making it effectively zero for all practical purposes of statistical inference.\n\nNow I will evaluate each option based on this analysis.\n\n**Option A:** To sanity-check that the search configuration and database are correct by confirming the expected self-hit; an E-value of $0.0$ indicates an alignment score so extreme that the expected number of equally good random matches is below numerical reporting precision (i.e., effectively zero for practical purposes), not that the probability is literally $0$.\n- **Purpose Analysis**: \"To sanity-check that the search configuration and database are correct by confirming the expected self-hit\" is a precise and correct description of the procedural purpose.\n- **E-value Analysis**: The interpretation that an E-value of $0.0$ results from an extremely high score, leading to a calculated value below numerical precision, and that it does not imply a literal probability of zero, is entirely correct. It captures the nuance of floating-point arithmetic in scientific software.\n- **Verdict**: **Correct**.\n\n**Option B:** To determine the optimal amino acid substitution matrix from the query itself; an E-value of $0.0$ proves the alignment has $100\\%$ identity and no gaps and guarantees the sequences are orthologs.\n- **Purpose Analysis**: \"To determine the optimal amino acid substitution matrix\" from a single self-alignment is nonsensical. Substitution matrices are derived from statistical analysis of large, diverse sets of aligned homologous proteins.\n- **E-value Analysis**: While a self-hit will have $100\\%$ identity, an E-value of $0.0$ is the result, not the proof. More gravely, homology (let alone orthology, a specific type of homology) is an evolutionary inference that cannot be \"guaranteed\" by a similarity score. A self-hit provides zero evolutionary information. This statement contains multiple fundamental errors.\n- **Verdict**: **Incorrect**.\n\n**Option C:** To mask low-complexity regions in the query; an E-value of $0.0$ means the score could not be computed because those regions were removed.\n- **Purpose Analysis**: Masking low-complexity regions is a filtering step performed *prior* to the search to avoid spurious, statistically inflated hits. It is not the purpose of the search itself.\n- **E-value Analysis**: An E-value of $0.0$ is the result of a very high, successfully computed score. If a score \"could not be computed\", there would be no hit and no E-value reported. This statement demonstrates a complete misunderstanding of both masking and the BLAST output.\n- **Verdict**: **Incorrect**.\n\n**Option D:** To calibrate the statistical parameters of the scoring system from a single alignment; an E-value of $0.0$ means the database is too small to produce any random hit at all.\n- **Purpose Analysis**: The statistical parameters $\\lambda$ and $K$ are characteristics of the scoring system and amino acid distributions, not something to be \"calibrated\" from a single, trivial alignment.\n- **E-value Analysis**: The E-value is proportional to database size, so a smaller database reduces the E-value. However, the claim that a small database \"cannot produce any random hit at all\" is false. More importantly, the E-value of $0.0$ in this case is overwhelmingly due to the immense score of a perfect self-match, not the database size. Any non-zero sized database can theoretically produce a random hit.\n- **Verdict**: **Incorrect**.\n\n**Option E:** To automatically de-duplicate the database; an E-value of $0.0$ means the expected number of random hits is exactly $0$ and the probability that the sequences are unrelated is exactly $0$.\n- **Purpose Analysis**: While BLAST can be a component in a de-duplication pipeline, the described action—a single self-hit search—is not itself a de-duplication process. It is a system check.\n- **E-value Analysis**: The statement that the expected number is \"exactly 0\" and the probability is \"exactly 0\" is a critical error of absolutism. Statistical metrics in this domain are not absolute. This interpretation lacks the necessary scientific and computational nuance and is strictly incorrect. The true E-value is a very small positive number rounded to $0.0$.\n- **Verdict**: **Incorrect**.\n\nBased on a thorough analysis of all options, only Option A provides both a scientifically correct purpose and a correct interpretation of the E-value.",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "Real-world genomic sequences are rarely simple; they are often rich with repetitive elements that can overwhelm a BLAST search with spurious hits. This practice explores masking, the primary strategy for managing these repeats. You will compare the distinct effects of \"soft\" and \"hard\" masking on the BLASTN algorithm's seeding and extension phases, learning how to choose the right approach to unearth a true signal from a noisy background .",
            "id": "2376028",
            "problem": "A researcher uses the Basic Local Alignment Search Tool nucleotide search (BLASTN) to align a genomic query sequence against a large vertebrate genome database. The query contains a single internal segment that is a common primate short interspersed nuclear element (Alu). Two searches are performed that differ only in how this Alu segment is treated in the query: in search $\\mathrm{S}_{\\mathrm{soft}}$, the Alu is soft masked (letters converted to lower case); in search $\\mathrm{S}_{\\mathrm{hard}}$, the Alu is hard masked (letters replaced by ambiguity codes so that they are not aligned). The flanking regions on both sides of the Alu are unique, alignable sequence present once in the database. Consider how BLASTN constructs local alignments using short exact or near-exact words of length $w$ for seeding, followed by ungapped and then gapped extension to form high-scoring segment pairs (HSPs), and how masking interacts with these stages. Which option best describes the expected differences between $\\mathrm{S}_{\\mathrm{soft}}$ and $\\mathrm{S}_{\\mathrm{hard}}$ in terms of (i) where seeds can originate, (ii) whether extensions can traverse the repeat to yield a single spanning HSP, (iii) the prevalence of spurious repeat-only hits, and (iv) the typical impact on the expect value (E-value) of the true alignment spanning the Alu?\n\nA. In $\\mathrm{S}_{\\mathrm{soft}}$, seeds are not generated from the Alu, but once a seed is found in a unique flank, gapped extension can pass through the Alu so a single HSP spanning the repeat can be reported; spurious repeat-only hits are suppressed. In $\\mathrm{S}_{\\mathrm{hard}}$, the Alu is effectively removed from both seeding and extension, so extensions cannot cross it and HSPs that would have spanned the repeat become truncated or split; both approaches reduce spurious repeat-only hits, but hard masking often shortens true alignments and can raise their E-values relative to soft masking.\n\nB. In $\\mathrm{S}_{\\mathrm{soft}}$, both seeding and extension are prohibited in the Alu, preventing any HSP from spanning the repeat; in $\\mathrm{S}_{\\mathrm{hard}}$, seeds are not generated in the Alu but extension can traverse it, so HSPs spanning the repeat are still reported; spurious repeat-only hits are unaffected.\n\nC. Hard masking in $\\mathrm{S}_{\\mathrm{hard}}$ increases spurious hits to Alu instances because the masked letters act as wildcards that seed many locations, whereas soft masking in $\\mathrm{S}_{\\mathrm{soft}}$ only modestly reduces such spurious hits; both approaches preserve the length and E-value of true alignments spanning the repeat.\n\nD. In BLASTN, soft-masked letters are down-weighted during scoring, so any HSP that crosses a soft-masked Alu has a lower score and a higher E-value than if unmasked; hard masking leaves scoring unchanged but blocks seeding in the Alu, with no effect on whether extension can cross the repeat.\n\nE. Both $\\mathrm{S}_{\\mathrm{soft}}$ and $\\mathrm{S}_{\\mathrm{hard}}$ allow seeds to originate within the Alu but rely on a post-alignment low-complexity filter to discard repeat-only hits; consequently, both produce similar spanning HSPs and E-values for the true alignment and similar numbers of spurious repeat-only matches.",
            "solution": "The user has provided a problem in computational biology concerning the operation of the Basic Local Alignment Search Tool (BLAST). I will now proceed with the validation of the problem statement.\n\n### Step 1: Extract Givens\n- **Tool**: Basic Local Alignment Search Tool nucleotide search (BLASTN).\n- **Query Sequence**: A genomic sequence containing a single internal segment that is a common primate short interspersed nuclear element (Alu).\n- **Database**: A large vertebrate genome database.\n- **Flanking Regions**: The regions on both sides of the Alu element in the query are unique and alignable, present once in the database.\n- **Search $\\mathrm{S}_{\\mathrm{soft}}$**: The Alu segment is soft masked (letters converted to lower case).\n- **Search $\\mathrm{S}_{\\mathrm{hard}}$**: The Alu segment is hard masked (letters replaced by ambiguity codes so that they are not aligned).\n- **BLASTN Mechanism**: The tool uses short exact or near-exact words of length $w$ for seeding, followed by ungapped and then gapped extension to form high-scoring segment pairs (HSPs).\n- **Question**: Compare searches $\\mathrm{S}_{\\mathrm{soft}}$ and $\\mathrm{S}_{\\mathrm{hard}}$ regarding (i) seed origination, (ii) extension traversal of the repeat, (iii) prevalence of spurious repeat-only hits, and (iv) impact on the expect value (E-value) of the true alignment.\n\n### Step 2: Validate Using Extracted Givens\n1.  **Scientifically Grounded**: The problem is well-grounded in the principles of bioinformatics and computational biology. BLAST, Alu elements, soft masking, hard masking, seeding, extension, HSPs, and E-values are all standard, well-defined concepts. The scenario described is a common and practical task in sequence analysis.\n2.  **Well-Posed**: The problem is well-posed. It asks for a qualitative comparison between two clearly defined methods ($\\mathrm{S}_{\\mathrm{soft}}$ and $\\mathrm{S}_{\\mathrm{hard}}$) based on four specific, answerable criteria. A unique, correct description based on the known mechanics of the BLAST algorithm exists.\n3.  **Objective**: The language used is technical, precise, and objective. \"Soft masked\", \"hard masked\", \"seeding\", and \"extension\" have concrete, unambiguous meanings in the context of BLAST.\n4.  **No Flaws**: The problem statement does not violate any scientific principles, is not metaphorical, is complete, is realistic, and is not ill-posed. The description of hard masking as replacing letters with ambiguity codes \"so that they are not aligned\" accurately captures the functional outcome, which is the inability of the extension algorithm to proceed through such regions due to high mismatch penalties.\n\n### Step 3: Verdict and Action\nThe problem statement is declared **valid**. I will proceed with the derivation of the solution and evaluation of the options.\n\n### Solution Derivation\n\nThe problem requires an analysis of how soft masking and hard masking affect the BLASTN algorithm's results. The algorithm can be understood in two main stages: seeding and extension.\n\n1.  **Seeding**: BLASTN first identifies short, perfectly or nearly-perfectly matching \"words\" of a defined length $w$ between the query and the database. These words serve as seeds for potential alignments. Repetitive elements like Alu are present in high copy numbers in the database. If a query containing an unmasked Alu is used, it will generate a very large number of seeds by matching countless Alu elements in the database, leading to a large number of spurious alignments and a computationally expensive search. Masking is the primary strategy to mitigate this.\n\n2.  **Soft Masking ($\\mathrm{S}_{\\mathrm{soft}}$)**: In soft masking, the nucleotide bases in the repetitive Alu region are converted to lower-case (e.g., `atgc...` instead of `ATGC...`).\n    - **Effect on Seeding**: By default, BLAST programs are configured to ignore soft-masked (lower-case) regions of the query sequence during the seeding stage. Therefore, no seeds will originate from the Alu segment in search $\\mathrm{S}_{\\mathrm{soft}}$. Seeds can only be generated from the unmasked, unique flanking regions.\n    - **Effect on Extension**: Once a seed is found in a unique flanking region, the alignment extension process begins. During this gapped extension phase, soft-masked letters are treated as regular nucleotides and are scored using the standard scoring matrix. This allows the alignment to extend *through* the soft-masked Alu region, connecting the two unique flanks. The result is a single, long high-scoring segment pair (HSP) that spans the entire query region, including the Alu.\n    - **Effect on Spurious Hits**: Since seeding from the query's Alu is disabled, BLASTN will not initiate alignments with the multitude of other Alu elements in the database. This effectively suppresses the reporting of spurious, repeat-only hits.\n    - **Effect on E-value**: A single, long HSP is generated. The alignment score ($S$) will be high due to its length. The Expect value (E-value), which measures the number of hits one can \"expect\" to see by chance, is related to the score by $E = Kmn e^{-\\lambda S}$, where $K$ and $\\lambda$ are statistical parameters, and $m$ and $n$ are the lengths of the query and database. A higher score $S$ leads to an exponentially lower (more significant) E-value.\n\n3.  **Hard Masking ($\\mathrm{S}_{\\mathrm{hard}}$)**: In hard masking, the bases in the repetitive Alu region are replaced by an ambiguity character, typically 'N'. The problem states this is done so the letters \"are not aligned.\"\n    - **Effect on Seeding**: Similar to soft masking, regions with 'N's are not used to generate seeds. Thus, no seeds will originate from the hard-masked Alu segment.\n    - **Effect on Extension**: During the extension phase, an 'N' in the sequence represents a complete unknown. Aligning an 'N' to any standard base (A, C, G, T) or even to another 'N' typically incurs a significant penalty in BLASTN's scoring system. This penalty is usually large enough to terminate the extension process. Therefore, an alignment initiated in one flanking region cannot extend across the hard-masked Alu to the other flank.\n    - **Effect on Spurious Hits**: Like soft masking, hard masking prevents seeding from the query's Alu region and thus suppresses spurious repeat-only hits.\n    - **Effect on E-value**: Because the extension is halted at the boundary of the hard-masked region, the original single true alignment is fragmented. Instead of one long HSP spanning the entire locus, the result will be two shorter HSPs (one for each flank) or a single truncated HSP (if only one flank finds a seed and extends). These shorter HSPs will have lower scores ($S$) compared to the single long HSP from $\\mathrm{S}_{\\mathrm{soft}}$. A lower score results in a higher (less significant) E-value.\n\n### Option-by-Option Analysis\n\n**A. In $\\mathrm{S}_{\\mathrm{soft}}$, seeds are not generated from the Alu, but once a seed is found in a unique flank, gapped extension can pass through the Alu so a single HSP spanning the repeat can be reported; spurious repeat-only hits are suppressed. In $\\mathrm{S}_{\\mathrm{hard}}$, the Alu is effectively removed from both seeding and extension, so extensions cannot cross it and HSPs that would have spanned the repeat become truncated or split; both approaches reduce spurious repeat-only hits, but hard masking often shortens true alignments and can raise their E-values relative to soft masking.**\n- This option accurately describes all four points of comparison for both $\\mathrm{S}_{\\mathrm{soft}}$ and $\\mathrm{S}_{\\mathrm{hard}}$. It correctly states that soft masking prevents seeding in the Alu but allows extension through it, yielding a single spanning HSP and suppressing spurious hits. It also correctly states that hard masking prevents both seeding and extension in the Alu, leading to truncated/split HSPs. Finally, it correctly concludes that hard masking's shortening of the alignment leads to higher (worse) E-values compared to soft masking.\n- **Verdict: Correct.**\n\n**B. In $\\mathrm{S}_{\\mathrm{soft}}$, both seeding and extension are prohibited in the Alu, preventing any HSP from spanning the repeat; in $\\mathrm{S}_{\\mathrm{hard}}$, seeds are not generated in the Alu but extension can traverse it, so HSPs spanning the repeat are still reported; spurious repeat-only hits are unaffected.**\n- The statement about $\\mathrm{S}_{\\mathrm{soft}}$ is incorrect; extension is *not* prohibited in soft-masked regions. The statement about $\\mathrm{S}_{\\mathrm{hard}}$ is also incorrect; extension *cannot* traverse hard-masked regions. This option reverses the effects of the two masking types on the extension phase. The claim that spurious hits are unaffected is also incorrect.\n- **Verdict: Incorrect.**\n\n**C. Hard masking in $\\mathrm{S}_{\\mathrm{hard}}$ increases spurious hits to Alu instances because the masked letters act as wildcards that seed many locations, whereas soft masking in $\\mathrm{S}_{\\mathrm{soft}}$ only modestly reduces such spurious hits; both approaches preserve the length and E-value of true alignments spanning the repeat.**\n- This is fundamentally wrong. The purpose and effect of masking (both types) is to *prevent* seeding in repetitive regions and thus *reduce* spurious hits. 'N's do not act as wildcards for seeding. Furthermore, hard masking does *not* preserve the length and E-value of the true alignment; it shortens it and worsens the E-value.\n- **Verdict: Incorrect.**\n\n**D. In BLASTN, soft-masked letters are down-weighted during scoring, so any HSP that crosses a soft-masked Alu has a lower score and a higher E-value than if unmasked; hard masking leaves scoring unchanged but blocks seeding in the Alu, with no effect on whether extension can cross the repeat.**\n- The first part is not standard behavior. Soft-masked letters are typically scored normally during extension, they are only ignored for seeding. The claim that this leads to a higher E-value is illogical in the context of filtering repeats. The section on hard masking is incorrect; it has a decisive effect on extension, blocking it.\n- **Verdict: Incorrect.**\n\n**E. Both $\\mathrm{S}_{\\mathrm{soft}}$ and $\\mathrm{S}_{\\mathrm{hard}}$ allow seeds to originate within the Alu but rely on a post-alignment low-complexity filter to discard repeat-only hits; consequently, both produce similar spanning HSPs and E-values for the true alignment and similar numbers of spurious repeat-only matches.**\n- This statement is incorrect from the beginning. The primary function of masking is to *prevent* seeds from originating within the masked regions. Consequently, the downstream conclusions that they produce similar spanning HSPs and E-values are also false. $\\mathrm{S}_{\\mathrm{hard}}$ does not produce spanning HSPs.\n- **Verdict: Incorrect.**",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "This final challenge moves from using BLAST to thinking like its designer, tackling the difficult problem of detecting distant evolutionary relationships in the \"twilight zone\" of sequence identity. By implementing a simplified BLASTP-like algorithm, you will gain a first-principles understanding of how parameter tuning—modifying word size, scoring matrices, and gap penalties—can dramatically increase search sensitivity. This exercise provides a deep, hands-on appreciation for the interplay between algorithmic heuristics and biological discovery .",
            "id": "2376047",
            "problem": "You will implement a complete, runnable program that models a simplified version of the Basic Local Alignment Search Tool for proteins (BLASTP). The goal is to automatically select a non-default parameter configuration that reveals homology between amino acid sequences in the so-called \"twilight zone\" of sequence identity (approximately $0.25$ as a fraction). The program must use a principled, first-principles design rooted in the Central Dogma of Molecular Biology and in well-tested formulas for local alignment statistics. Your program must not read any input; it must run as-is and produce a single-line output.\n\nYou are to implement a detector that uses a seed-and-extend heuristic combined with local alignment scoring and statistical significance estimation, following these foundational rules:\n\n1. Central Dogma and homology. Protein sequences arise by translation of coding DNA, and homology implies common ancestry evidenced by conserved positions. Your algorithm should rely on local alignments to detect conserved regions indicative of homology without assuming global similarity.\n\n2. Log-odds scoring and substitution families. Proteins are scored with substitution matrices derived from log-odds principles. You will implement three substitution families that mimic BLOSUM behavior qualitatively:\n   - A reduced chemical-group model on the canonical $20$ amino acid alphabet $\\mathcal{A}$ partitions $\\mathcal{A}$ into the following five groups:\n     - Hydrophobic: $\\{ \\mathrm{A}, \\mathrm{V}, \\mathrm{I}, \\mathrm{L}, \\mathrm{M}, \\mathrm{F}, \\mathrm{W}, \\mathrm{Y} \\}$\n     - Polar uncharged: $\\{ \\mathrm{S}, \\mathrm{T}, \\mathrm{N}, \\mathrm{Q}, \\mathrm{C} \\}$\n     - Acidic: $\\{ \\mathrm{D}, \\mathrm{E} \\}$\n     - Basic: $\\{ \\mathrm{K}, \\mathrm{R}, \\mathrm{H} \\}$\n     - Special: $\\{ \\mathrm{G}, \\mathrm{P} \\}$\n   - Define three matrices by a scoring function $s_{\\mathrm{family}}(x,y)$, for $x,y \\in \\mathcal{A}$:\n     - LOOSE: exact match scores $+5$, same-group non-identical scores $+2$, different-group scores $-2$.\n     - MEDIUM: exact match scores $+4$, same-group non-identical scores $+1$, different-group scores $-3$.\n     - STRICT: exact match scores $+6$, same-group non-identical scores $0$, different-group scores $-4$.\n\n3. Seeding (word hits). Use the protein seed-and-extend heuristic:\n   - Word size $w \\in \\{2,3\\}$.\n   - For every pair of positions $(i,j)$ in the query and subject, compute the seed score for the $w$-mer as $\\sum_{k=0}^{w-1} s_{\\mathrm{family}}(q_{i+k}, t_{j+k})$, provided indices are in range.\n   - A seed is declared if the seed score is at least a family- and $w$-dependent cutoff $T(\\mathrm{family},w)$:\n     - For LOOSE: $T(\\mathrm{LOOSE},2)=6$, $T(\\mathrm{LOOSE},3)=10$.\n     - For MEDIUM: $T(\\mathrm{MEDIUM},2)=8$, $T(\\mathrm{MEDIUM},3)=12$.\n     - For STRICT: $T(\\mathrm{STRICT},2)=10$, $T(\\mathrm{STRICT},3)=15$.\n   - If no seed exists, declare “no hit” and skip extension.\n\n4. Extension by local alignment with affine gaps. If at least one seed exists, compute the optimal local alignment score $S$ using the Smith–Waterman algorithm with affine gap costs:\n   - Gap open penalty $g_o \\in \\{9,11\\}$.\n   - Gap extension penalty $g_e \\in \\{1,2\\}$.\n   - Use the same $s_{\\mathrm{family}}$ as above for matches/mismatches.\n\n5. Statistical significance (Karlin–Altschul statistics). For protein BLAST, use the Karlin–Altschul well-tested result for local alignment scores. Given query length $m$, database effective length $n$, and the maximum local alignment score $S$, compute the bit score $S'$ and the expected count $E$:\n   - Use family-specific constants $(\\lambda, K)$:\n     - LOOSE: $\\lambda=0.27$, $K=0.07$.\n     - MEDIUM: $\\lambda=0.318$, $K=0.13$.\n     - STRICT: $\\lambda=0.35$, $K=0.16$.\n   - Convert raw score to bit score by $S' = (\\lambda S - \\ln K)/\\ln 2$.\n   - Expected count is $E = mn\\, 2^{-S'}$. Equivalently $E = K\\, m n \\, e^{-\\lambda S}$.\n   - A hit is declared significant if $E \\le \\tau$, where $\\tau=0.01$ (a pure number; no units).\n\n6. Composition-based statistics flag. Include a boolean parameter $c \\in \\{0,1\\}$ representing composition-based statistics (off/on). For this simplified model, $c$ does not alter the scoring or statistics directly; it is tracked as part of the parameter tuple to enforce “non-default” selection.\n\n7. Parameter enumeration and default. Enumerate parameter tuples in lexicographic order as\n   - family $\\in [\\mathrm{LOOSE}, \\mathrm{MEDIUM}, \\mathrm{STRICT}]$,\n   - $w \\in [2,3]$,\n   - $g_o \\in [9,11]$,\n   - $g_e \\in [1,2]$,\n   - $c \\in [0,1]$.\n   Let the default BLASTP-like tuple be $(\\mathrm{MEDIUM},3,11,1,1)$, corresponding to family MEDIUM, word size $w=3$, $g_o=11$, $g_e=1$, $c=1$. The default is included in the enumeration but must never be chosen as the answer.\n\n8. Selection rule. For a given query–subject pair and database effective length $n$, among all non-default parameter tuples that declare at least one seed and yield $E \\le \\tau$, select the tuple that differs from the default in the fewest fields (count each field equally). Among ties, choose the lexicographically smallest tuple under the enumeration in item $7$. If no non-default tuple yields a significant hit, return no solution.\n\nYour program must implement the above detector and apply it to the following test suite. Each test case provides a query, a subject, and a database effective length. All amino acid sequences are uppercase strings over $\\mathcal{A}$. There are no physical units.\n\nTest suite (four cases):\n- Case A (twilight-zone homologs, approximately $0.25$ identity): \n  - Query $q_A$: \"MAVKDLGATYVAGLSERAGADVVVVNTDAGKSTLLNQLAGLDKTTELWAVDAGHNTMPNVIAGLKMKDGKKLSALDAGADLLSVTNPADKVIAGLEGA\"\n  - Subject $t_A$: \"LVIRDLGCTFIAGLTERTGVDIIVVNKDAGKSALLSQLSGIDETTELYAVDSGHNTLPNVVSGIKMREGKKLTALDAGKDLLTITNPKDKILAGMEGS\"\n  - Database effective length $n_A = 10^6$.\n- Case B (unrelated sequences; should not be significant): \n  - Query $q_B$: \"WQFPCHMNRTYGPADKSVYHCRWTQGPNTRHACDYKMPLWQHTRNYGACDPKTYRH\"\n  - Subject $t_B$: \"IVLVMAGTALLLVALGLTGATAAAVVLVALGLTVAIVGLALVVVVLAIVVVLVVV\"\n  - Database effective length $n_B = 10^6$.\n- Case C (moderate similarity; above twilight zone): \n  - Query $q_C$: \"ADKQLVQKAKLAEQAERYDDMAAAMKAVTEQGHELSNEERNLLSVAYKNVVGARRSSWR\"\n  - Subject $t_C$: \"AEKQLVQRAKLAEQAERYDEMAEALKKVTEQGHELSNDEKDLLSVAYKNVVNARRATWR\"\n  - Database effective length $n_C = 10^6$.\n- Case D (short proteins; boundary where $w=3$ may be too strict): \n  - Query $q_D$: \"GPWKVVVVAGHGISDLGKTKAVAI\"\n  - Subject $t_D$: \"GSWKIIVVAGHGITDLGKSRAIAL\"\n  - Database effective length $n_D = 10^6$.\n\nOutput specification:\n- For each case, compute the zero-based index of the selected parameter tuple within the full enumeration order described in item $7$ (that is, including the default in the count), or output $-1$ if no non-default tuple yields a significant hit.\n- Your program should produce a single line of output containing the four results as a comma-separated list enclosed in square brackets, for example, \"[i_A,i_B,i_C,i_D]\".\n- All values must be integers.\n\nNotes:\n- There are no physical units; the expected count $E$ is a pure number. The fraction $0.01$ is a threshold and must be applied exactly as given.\n- Angles are not involved.\n- Percentages must be handled as fractions, which is why the twilight zone is described using $0.25$.",
            "solution": "The problem as stated is subjected to rigorous validation.\n\n**Step 1: Extract Givens**\n\n- **Amino Acid Alphabet ($\\mathcal{A}$):** The canonical $20$ amino acids.\n- **Amino Acid Groups:**\n  - Hydrophobic: $\\{ \\mathrm{A}, \\mathrm{V}, \\mathrm{I}, \\mathrm{L}, \\mathrm{M}, \\mathrm{F}, \\mathrm{W}, \\mathrm{Y} \\}$\n  - Polar uncharged: $\\{ \\mathrm{S}, \\mathrm{T}, \\mathrm{N}, \\mathrm{Q}, \\mathrm{C} \\}$\n  - Acidic: $\\{ \\mathrm{D}, \\mathrm{E} \\}$\n  - Basic: $\\{ \\mathrm{K}, \\mathrm{R}, \\mathrm{H} \\}$\n  - Special: $\\{ \\mathrm{G}, \\mathrm{P} \\}$\n- **Scoring Families ($s_{\\mathrm{family}}(x,y)$):**\n  - LOOSE: exact match $+5$, same-group non-identical $+2$, different-group $-2$.\n  - MEDIUM: exact match $+4$, same-group non-identical $+1$, different-group $-3$.\n  - STRICT: exact match $+6$, same-group non-identical $0$, different-group $-4$.\n- **Seeding:**\n  - Word size $w \\in \\{2, 3\\}$.\n  - Seed score: $\\sum_{k=0}^{w-1} s_{\\mathrm{family}}(q_{i+k}, t_{j+k})$.\n  - Seed thresholds $T$: $T(\\mathrm{LOOSE},2)=6$, $T(\\mathrm{LOOSE},3)=10$; $T(\\mathrm{MEDIUM},2)=8$, $T(\\mathrm{MEDIUM},3)=12$; $T(\\mathrm{STRICT},2)=10$, $T(\\mathrm{STRICT},3)=15$.\n- **Extension (Local Alignment with Affine Gaps):**\n  - Gap open penalty $g_o \\in \\{9, 11\\}$.\n  - Gap extension penalty $g_e \\in \\{1, 2\\}$.\n- **Statistical Significance (Karlin-Altschul):**\n  - Query length $m$, database effective length $n$.\n  - Statistics constants $(\\lambda, K)$: LOOSE ($\\lambda=0.27, K=0.07$), MEDIUM ($\\lambda=0.318, K=0.13$), STRICT ($\\lambda=0.35, K=0.16$).\n  - Bit score $S' = (\\lambda S - \\ln K)/\\ln 2$.\n  - Expected count $E = mn\\, 2^{-S'} = Kmn \\, e^{-\\lambda S}$.\n  - Significance threshold $\\tau=0.01$. A hit is significant if $E \\le \\tau$.\n- **Composition-Based Statistics Flag:** $c \\in \\{0, 1\\}$.\n- **Parameter Enumeration (Lexicographic):** family $\\in [\\mathrm{LOOSE}, \\mathrm{MEDIUM}, \\mathrm{STRICT}]$, $w \\in [2,3]$, $g_o \\in [9,11]$, $g_e \\in [1,2]$, $c \\in [0,1]$.\n- **Default Parameter Tuple:** $(\\mathrm{MEDIUM}, 3, 11, 1, 1)$.\n- **Selection Rule:** For a given query/subject pair, from all non-default parameter tuples that find a seed and yield $E \\le \\tau$, select the one with the minimum number of differing fields from the default. Tie-break using the smallest lexicographical index. If no such tuple exists, the result is \"no solution\".\n- **Test Suite:**\n  - Case A: $q_A=$ \"MAVKDLGATYVAGLSERAGADVVVVNTDAGKSTLLNQLAGLDKTTELWAVDAGHNTMPNVIAGLKMKDGKKLSALDAGADLLSVTNPADKVIAGLEGA\", $t_A=$ \"LVIRDLGCTFIAGLTERTGVDIIVVNKDAGKSALLSQLSGIDETTELYAVDSGHNTLPNVVSGIKMREGKKLTALDAGKDLLTITNPKDKILAGMEGS\", $n_A = 10^6$.\n  - Case B: $q_B=$ \"WQFPCHMNRTYGPADKSVYHCRWTQGPNTRHACDYKMPLWQHTRNYGACDPKTYRH\", $t_B=$ \"IVLVMAGTALLLVALGLTGATAAAVVLVALGLTVAIVGLALVVVVLAIVVVLVVV\", $n_B = 10^6$.\n  - Case C: $q_C=$ \"ADKQLVQKAKLAEQAERYDDMAAAMKAVTEQGHELSNEERNLLSVAYKNVVGARRSSWR\", $t_C=$ \"AEKQLVQRAKLAEQAERYDEMAEALKKVTEQGHELSNDEKDLLSVAYKNVVNARRATWR\", $n_C = 10^6$.\n  - Case D: $q_D=$ \"GPWKVVVVAGHGISDLGKTKAVAI\", $t_D=$ \"GSWKIIVVAGHGITDLGKSRAIAL\", $n_D = 10^6$.\n- **Output:** A single-line list of four zero-based integer indices, e.g., `[i_A,i_B,i_C,i_D]`. An index of $-1$ indicates no solution found.\n\n**Step 2: Validate Using Extracted Givens**\n\nThe problem is scientifically grounded, well-posed, and objective. It provides a simplified but correct model of the BLASTP algorithm, rooted in established principles of bioinformatics such as log-odds scoring matrices, seed-and-extend heuristics, local alignment via dynamic programming (Smith-Waterman), and Karlin-Altschul statistics for significance estimation. All required data, parameters, and algorithms are specified without ambiguity or contradiction. The selection rule is deterministic, ensuring a unique solution. The computational task is intensive but feasible for the given sequence lengths. The problem does not violate any of the invalidity criteria.\n\n**Step 3: Verdict and Action**\n\nThe problem is valid. A solution will be constructed.\n\n**Principle-Based Design**\n\nThe task is to implement a simplified BLASTP-like homology search tool and use it to find an optimal, non-default parameter configuration for detecting homology in several test cases. The solution will proceed by systematically evaluating a discrete parameter space, applying a full seed-and-extend alignment procedure for each parameter set, and selecting the best set based on a clearly defined rule.\n\nFirst, we establish the parameter space. There are $3$ scoring families, $2$ word sizes, $2$ gap open penalties, $2$ gap extension penalties, and $2$ composition-based statistics flags. This yields a total of $3 \\times 2 \\times 2 \\times 2 \\times 2 = 48$ parameter tuples. These are enumerated in lexicographical order: (family, $w$, $g_o$, $g_e$, $c$). The default tuple is specified as $(\\mathrm{MEDIUM}, 3, 11, 1, 1)$.\n\nFor each test case (a query sequence $q$, a subject sequence $t$, and an effective database size $n$), we iterate through all $48$ parameter tuples. Let $m$ be the length of the query sequence. For each non-default tuple, the following procedure is executed:\n\n**1. Seeding:**\nThe algorithm first searches for \"word hits\" or seeds. A word of size $w$ is a short substring of the sequence. We consider all $w$-mers from the query and all $w$-mers from the subject. For each pair of $w$-mers, one from the query ($q_{i...i+w-1}$) and one from the subject ($t_{j...j+w-1}$), a seed score is computed as the sum of substitution scores for the aligned amino acids: $\\sum_{k=0}^{w-1} s_{\\mathrm{family}}(q_{i+k}, t_{j+k})$. The substitution score $s_{\\mathrm{family}}(x, y)$ is determined by the active scoring family (LOOSE, MEDIUM, or STRICT). If this seed score meets or exceeds the specified threshold $T(\\mathrm{family}, w)$, a seed is found. If no seed is found across the entire pair of sequences, this parameter tuple is discarded, and we proceed to the next.\n\n**2. Extension using Smith-Waterman with Affine Gaps:**\nIf at least one seed is found, we proceed to find the optimal local alignment score, $S$, between the full query and subject sequences. This is achieved using the Smith-Waterman dynamic programming algorithm, modified for affine gap penalties. An affine gap penalty model uses a higher cost for opening a gap ($g_o$) and a lower cost for extending it ($g_e$). This is implemented using three dynamic programming matrices: $H(i,j)$ for the best score ending at $(i,j)$ (either a match/mismatch or closing a gap), $E(i,j)$ for the best score ending with a gap in the query, and $F(i,j)$ for the best score ending with a gap in the subject.\nLet $q_i$ and $t_j$ be the amino acids at positions $i$ and $j$ of the query and subject sequences, respectively. The recurrences are, for $i=1...m$ and $j=1...|t|$:\n$$F(i,j) = \\max \\left\\{ H(i-1, j) - g_o, F(i-1, j) - g_e \\right\\}$$\n$$E(i,j) = \\max \\left\\{ H(i, j-1) - g_o, E(i, j-1) - g_e \\right\\}$$\n$$H(i,j) = \\max \\left\\{ H(i-1, j-1) + s(q_i, t_j), E(i,j), F(i,j), 0 \\right\\}$$\nThe base cases are $H(0,j) = H(i,0) = 0$ for all $i,j$. The final local alignment score $S$ is the maximum value found anywhere in the $H$ matrix: $S = \\max_{i,j} H(i,j)$.\n\n**3. Statistical Significance:**\nThe raw score $S$ is evaluated for statistical significance using the Karlin-Altschul E-value formula:\n$$E = K m n e^{-\\lambda S}$$\nHere, $m$ is the query length, $n$ is the effective database length, and $\\lambda$ and $K$ are statistical parameters specific to the scoring system. A result is deemed statistically significant if its E-value $E$ is less than or equal to a threshold $\\tau$, given as $0.01$.\n\n**4. Parameter Selection:**\nAll non-default parameter tuples that pass the seeding stage and produce a significant E-value ($E \\le 0.01$) are collected. Among these successful tuples, we apply the selection rule:\n- First, calculate the \"difference\" for each successful tuple, defined as the number of fields that differ from the default tuple $(\\mathrm{MEDIUM}, 3, 11, 1, 1)$.\n- Identify the minimum difference found among all successful tuples.\n- The final chosen tuple is the one that achieves this minimum difference and has the lowest lexicographical index among all ties. If no non-default tuple yields a significant hit, the result for the test case is $-1$.\n\nThis entire process is repeated for each of the four test cases provided, and the zero-based index of the chosen parameter tuple is recorded as the final result for that case.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Implements a simplified BLASTP model to find optimal parameters for homology detection.\n    \"\"\"\n\n    # --- Problem Definition and Constants ---\n\n    AA_GROUPS = {\n        'A': 'Hydrophobic', 'V': 'Hydrophobic', 'I': 'Hydrophobic', 'L': 'Hydrophobic',\n        'M': 'Hydrophobic', 'F': 'Hydrophobic', 'W': 'Hydrophobic', 'Y': 'Hydrophobic',\n        'S': 'Polar uncharged', 'T': 'Polar uncharged', 'N': 'Polar uncharged',\n        'Q': 'Polar uncharged', 'C': 'Polar uncharged',\n        'D': 'Acidic', 'E': 'Acidic',\n        'K': 'Basic', 'R': 'Basic', 'H': 'Basic',\n        'G': 'Special', 'P': 'Special'\n    }\n\n    # Parameter space definition\n    FAMILIES = ['LOOSE', 'MEDIUM', 'STRICT']\n    WORD_SIZES = [2, 3]\n    GAP_OPENS = [9, 11]\n    GAP_EXTENDS = [1, 2]\n    COMP_STATS = [0, 1]\n\n    # Generate parameter space in lexicographic order\n    param_space = []\n    for family in FAMILIES:\n        for w in WORD_SIZES:\n            for g_o in GAP_OPENS:\n                for g_e in GAP_EXTENDS:\n                    for c in COMP_STATS:\n                        param_space.append((family, w, g_o, g_e, c))\n\n    DEFAULT_PARAMS = ('MEDIUM', 3, 11, 1, 1)\n\n    SCORING_RULES = {\n        'LOOSE': {'match': 5, 'same_group': 2, 'diff_group': -2},\n        'MEDIUM': {'match': 4, 'same_group': 1, 'diff_group': -3},\n        'STRICT': {'match': 6, 'same_group': 0, 'diff_group': -4},\n    }\n\n    SEED_THRESHOLDS = {\n        ('LOOSE', 2): 6, ('LOOSE', 3): 10,\n        ('MEDIUM', 2): 8, ('MEDIUM', 3): 12,\n        ('STRICT', 2): 10, ('STRICT', 3): 15,\n    }\n\n    STAT_CONSTANTS = {\n        'LOOSE': {'lambda': 0.27, 'K': 0.07},\n        'MEDIUM': {'lambda': 0.318, 'K': 0.13},\n        'STRICT': {'lambda': 0.35, 'K': 0.16},\n    }\n\n    E_VALUE_THRESHOLD = 0.01\n\n    test_cases = [\n        (\"MAVKDLGATYVAGLSERAGADVVVVNTDAGKSTLLNQLAGLDKTTELWAVDAGHNTMPNVIAGLKMKDGKKLSALDAGADLLSVTNPADKVIAGLEGA\",\n         \"LVIRDLGCTFIAGLTERTGVDIIVVNKDAGKSALLSQLSGIDETTELYAVDSGHNTLPNVVSGIKMREGKKLTALDAGKDLLTITNPKDKILAGMEGS\",\n         10**6),\n        (\"WQFPCHMNRTYGPADKSVYHCRWTQGPNTRHACDYKMPLWQHTRNYGACDPKTYRH\",\n         \"IVLVMAGTALLLVALGLTGATAAAVVLVALGLTVAIVGLALVVVVLAIVVVLVVV\",\n         10**6),\n        (\"ADKQLVQKAKLAEQAERYDDMAAAMKAVTEQGHELSNEERNLLSVAYKNVVGARRSSWR\",\n         \"AEKQLVQRAKLAEQAERYDEMAEALKKVTEQGHELSNDEKDLLSVAYKNVVNARRATWR\",\n         10**6),\n        (\"GPWKVVVVAGHGISDLGKTKAVAI\",\n         \"GSWKIIVVAGHGITDLGKSRAIAL\",\n         10**6),\n    ]\n\n    # --- Helper Functions ---\n\n    memoized_score_funcs = {}\n    def get_score_func(family):\n        if family in memoized_score_funcs:\n            return memoized_score_funcs[family]\n\n        rules = SCORING_RULES[family]\n        \n        memoized_scores = {}\n        all_aas = list(AA_GROUPS.keys())\n        for i in range(len(all_aas)):\n            for j in range(i, len(all_aas)):\n                aa1, aa2 = all_aas[i], all_aas[j]\n                if aa1 == aa2:\n                    score = rules['match']\n                elif AA_GROUPS[aa1] == AA_GROUPS[aa2]:\n                    score = rules['same_group']\n                else:\n                    score = rules['diff_group']\n                memoized_scores[(aa1, aa2)] = score\n                memoized_scores[(aa2, aa1)] = score\n        \n        def score_func(aa1, aa2):\n            return memoized_scores[(aa1, aa2)]\n            \n        memoized_score_funcs[family] = score_func\n        return score_func\n\n    def check_seeding(query, subject, w, score_func, T):\n        len_q, len_s = len(query), len(subject)\n        for i in range(len_q - w + 1):\n            for j in range(len_s - w + 1):\n                seed_score = sum(score_func(query[i + k], subject[j + k]) for k in range(w))\n                if seed_score >= T:\n                    return True\n        return False\n\n    def smith_waterman_affine(query, subject, score_func, g_o, g_e):\n        m, n = len(query), len(subject)\n        H = np.zeros((m + 1, n + 1), dtype=np.int32)\n        E = np.zeros((m + 1, n + 1), dtype=np.int32)\n        F = np.zeros((m + 1, n + 1), dtype=np.int32)\n        \n        max_score = 0\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                # Gap in subject (deletion in query)\n                F[i, j] = max(H[i - 1, j] - g_o, F[i - 1, j] - g_e)\n                # Gap in query (insertion in subject)\n                E[i, j] = max(H[i, j - 1] - g_o, E[i, j - 1] - g_e)\n                \n                match_score = H[i - 1, j - 1] + score_func(query[i - 1], subject[j - 1])\n                H[i, j] = max(0, match_score, E[i, j], F[i, j])\n                \n                if H[i, j] > max_score:\n                    max_score = H[i, j]\n        \n        return int(max_score)\n\n    def calculate_diff_from_default(params):\n        diff = 0\n        for i in range(len(params)):\n            if params[i] != DEFAULT_PARAMS[i]:\n                diff += 1\n        return diff\n\n    # --- Main Logic ---\n\n    final_results = []\n    for query, subject, n_eff in test_cases:\n        m = len(query)\n        successful_params = []\n\n        for i, params in enumerate(param_space):\n            if params == DEFAULT_PARAMS:\n                continue\n\n            family, w, g_o, g_e, c = params\n            \n            score_func = get_score_func(family)\n            T = SEED_THRESHOLDS[(family, w)]\n\n            has_seed = check_seeding(query, subject, w, score_func, T)\n            if not has_seed:\n                continue\n            \n            S = smith_waterman_affine(query, subject, score_func, g_o, g_e)\n            \n            if S == 0:\n                continue\n\n            stat_p = STAT_CONSTANTS[family]\n            lambda_val, K_val = stat_p['lambda'], stat_p['K']\n            \n            # E = K * m * n * e^(-lambda * S)\n            try:\n                # Use high precision for intermediate exponent calculation\n                exponent = -lambda_val * float(S)\n                if exponent  -700: # Avoid underflow with math.exp\n                    e_value = 0.0\n                else:\n                    e_value = K_val * m * n_eff * math.exp(exponent)\n            except OverflowError:\n                continue\n\n            if e_value = E_VALUE_THRESHOLD:\n                diff = calculate_diff_from_default(params)\n                successful_params.append({'index': i, 'diff': diff})\n\n        if not successful_params:\n            final_results.append(-1)\n        else:\n            min_diff = min(p['diff'] for p in successful_params)\n            \n            # Find the first one (lexicographically smallest index) with min_diff\n            best_param = next(p for p in successful_params if p['diff'] == min_diff)\n            final_results.append(best_param['index'])\n            \n    # Print the final result in the specified format\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```"
        }
    ]
}