{
    "hands_on_practices": [
        {
            "introduction": "序列相似性矩阵（如BLOSUM62）编码了氨基酸的生物化学特性，这使我们即使在序列不共享相同残基的情况下也能发现相关的序列。这个练习要求你亲手实现经典的Smith-Waterman局部比对算法，并用它来构建一个比对得分大于零而序列一致性为零的实例。这不仅是一次编程实践，更是一个经典的例证，它直观地展示了为什么相似性评分在寻找远源同源序列时比简单的一致性度量更为强大。",
            "id": "2428720",
            "problem": "你必须编写一个完整的程序，该程序从基本原理出发，构建由表示氨基酸的大写英文字母组成的蛋白质序列对，并评估在指定的局部比对评分模型下，是否能满足以下性质：两条序列之间的 Smith–Waterman (SW) 局部比对具有严格为正的最优得分，同时比对区域内的一致性等于小数 $0$。你的程序必须实现带有线性罚分的 Smith–Waterman 动态规划递推式。必须严格遵守下述定义和评估规则。\n\n定义。设 $X = x_1 x_2 \\dots x_n$ 和 $Y = y_1 y_2 \\dots y_m$ 是定义在指定有限字母表上的两条序列。评分函数 $s(\\cdot,\\cdot)$ 为任意比对的字母对指定一个整数相似性得分。幅值为 $d \\ge 0$ 的线性罚分，为引入的每个空位字符减去 $d$。Smith–Waterman 动态规划矩阵 $H \\in \\mathbb{Z}^{(n+1)\\times(m+1)}$ 由基础条件 $H_{0,j} = 0$ (对于所有 $j \\in \\{0,1,\\dots,m\\}$) 和 $H_{i,0} = 0$ (对于所有 $i \\in \\{0,1,\\dots,n\\}$) 定义，并由以下递推式定义 (对于所有 $i \\in \\{1,\\dots,n\\}$ 和 $j \\in \\{1,\\dots,m\\}$)：\n$$\nH_{i,j} \\;=\\; \\max\\Big\\{\\, 0,\\; H_{i-1,j-1} + s(x_i,y_j),\\; H_{i-1,j} - d,\\; H_{i,j-1} - d \\,\\Big\\}.\n$$\n最优 Smith–Waterman 局部比对得分是 $S^\\star(X,Y) = \\max_{0 \\le i \\le n,\\; 0 \\le j \\le m} H_{i,j}$。一个最优比对区域是通过有效回溯路径恢复的任何比对，该路径始于获得最大值 $S^\\star(X,Y)$ 的单元格 $(i^\\star,j^\\star)$，并在每一步选择一个实现该最大值的前驱单元格，直到达到值为 $0$ 的单元格。将比对列定义为回溯路径上与对角移动相对应的位置；每个对角移动将 $X$ 中的一个字母与 $Y$ 中的一个字母进行比对。设 $L$ 为比对列的总数（即对角移动的次数）。将比对区域的一致性定义为\n$$\n\\mathrm{Id}(X,Y) \\;=\\; \n\\begin{cases}\n\\frac{M}{L},  \\text{if } L  0,\\\\\n0,  \\text{if } L = 0,\n\\end{cases}\n$$\n其中 $M$ 是在 $L$ 次对角移动中，两个字母相同的比对列的数量。一致性必须表示为区间 $[0,1]$ 内的一个小数，对于本任务，该值必须等于小数 $0$。\n\n评分模型。你的程序必须处理以下评分模型，每个模型构成一个测试用例。对于每个测试用例，你可以构建任何满足所述字母表约束和任何附加长度约束的序列。对于每个测试用例，你的输出必须是一个布尔值，当且仅当你构建的序列 $X$ 和 $Y$ 满足 $S^\\star(X,Y)  0$ 且 $\\mathrm{Id}(X,Y) = 0$ 时，该值为 true，否则为 false。\n\n- 测试用例 1（顺利路径，疏水性相似）。字母表限制为氨基酸 $\\{ \\mathrm{I}, \\mathrm{L}, \\mathrm{V}, \\mathrm{M} \\}$。对此 $4 \\times 4$ 子集使用 Blocks Substitution Matrix $62$ (BLOSUM$62$) 评分，其中 $s(a,b)$ 指定如下：\n  $s(\\mathrm{I},\\mathrm{I}) = 4$, $s(\\mathrm{I},\\mathrm{L}) = 2$, $s(\\mathrm{I},\\mathrm{V}) = 3$, $s(\\mathrm{I},\\mathrm{M}) = 1$;\n  $s(\\mathrm{L},\\mathrm{I}) = 2$, $s(\\mathrm{L},\\mathrm{L}) = 4$, $s(\\mathrm{L},\\mathrm{V}) = 1$, $s(\\mathrm{L},\\mathrm{M}) = 2$;\n  $s(\\mathrm{V},\\mathrm{I}) = 3$, $s(\\mathrm{V},\\mathrm{L}) = 1$, $s(\\mathrm{V},\\mathrm{V}) = 4$, $s(\\mathrm{V},\\mathrm{M}) = 1$;\n  $s(\\mathrm{M},\\mathrm{I}) = 1$, $s(\\mathrm{M},\\mathrm{L}) = 2$, $s(\\mathrm{M},\\mathrm{V}) = 1$, $s(\\mathrm{M},\\mathrm{M}) = 5$。\n  使用线性罚分 $d = 5$。除了 $n \\ge 1$ 和 $m \\ge 1$ 之外，没有长度约束。\n\n- 测试用例 2（边界长度，零罚分）。与测试用例 1 相同的 BLOSUM$62$ 子集和字母表，但使用线性罚分 $d = 0$。强制执行边界条件 $n = 1$ 和 $m = 1$。\n\n- 测试用例 3（仅基于一致性评分的不可能情况）。使用完整的大写氨基酸字母表。使用匹配/错配评分模型，定义为 $s(a,b) = 2$（如果 $a=b$）和 $s(a,b) = -1$（如果 $a \\ne b$）。使用线性罚分 $d = 2$。除了 $n \\ge 1$ 和 $m \\ge 1$ 之外，没有长度约束。\n\n你的任务。对于每个测试用例 $t \\in \\{1,2,3\\}$，构建一对序列 $(X_t,Y_t)$，使其符合该测试用例所述的字母表和长度约束，并使用上述定义评估 $S^\\star(X_t,Y_t)$ 和 $\\mathrm{Id}(X_t,Y_t)$。你的程序必须产生单行输出，其中包含一个长度为 3、用方括号括起来的逗号分隔列表形式的结果，列表的第 $t$ 个元素是一个布尔值，当且仅当 $S^\\star(X_t,Y_t)  0$ 和 $\\mathrm{Id}(X_t,Y_t) = 0$ 同时成立时为 true，否则为 false。例如，你的程序必须打印一行形式为 $[\\text{result}_1,\\text{result}_2,\\text{result}_3]$ 的内容。\n\n你必须实现和评估的测试套件摘要：\n- 测试 1：在 $\\{\\mathrm{I},\\mathrm{L},\\mathrm{V},\\mathrm{M}\\}$ 上使用 BLOSUM$62$ 子集，罚分 $d=5$。\n- 测试 2：在 $\\{\\mathrm{I},\\mathrm{L},\\mathrm{V},\\mathrm{M}\\}$ 上使用 BLOSUM$62$ 子集，罚分 $d=0$ 且 $n=m=1$。\n- 测试 3：在氨基酸字母表上使用匹配 $+2$ 和错配 $-1$ 的评分，罚分 $d=2$。\n\n所有答案都没有单位。一致性必须作为 $[0,1]$ 区间内的小数处理。你的单行输出必须严格为指定的布尔值列表，不含任何额外字符或行。",
            "solution": "在尝试任何解决方案之前，对问题陈述进行了严格的验证。\n\n### 第一步：提取已知条件\n\n已知条件逐字从问题陈述中提取：\n-   **序列**：$X = x_1 x_2 \\dots x_n$ 和 $Y = y_1 y_2 \\dots y_m$。\n-   **评分函数**：$s(\\cdot,\\cdot)$ 指定一个整数得分。\n-   **线性罚分**：幅值 $d \\ge 0$。\n-   **Smith-Waterman (SW) 矩阵**：$H \\in \\mathbb{Z}^{(n+1)\\times(m+1)}$。\n-   **基础条件**：$H_{0,j} = 0$ (对于所有 $j \\in \\{0,1,\\dots,m\\}$) 和 $H_{i,0} = 0$ (对于所有 $i \\in \\{0,1,\\dots,n\\}$)。\n-   **SW 递推式**：对于所有 $i \\in \\{1,\\dots,n\\}$ 和 $j \\in \\{1,\\dots,m\\}$：\n    $$\n    H_{i,j} \\;=\\; \\max\\Big\\{\\, 0,\\; H_{i-1,j-1} + s(x_i,y_j),\\; H_{i-1,j} - d,\\; H_{i,j-1} - d \\,\\Big\\}.\n    $$\n-   **最优得分**：$S^\\star(X,Y) = \\max_{0 \\le i \\le n,\\; 0 \\le j \\le m} H_{i,j}$。\n-   **回溯**：始于得分为 $S^\\star$ 的单元格 $(i^\\star,j^\\star)$，止于得分为 $0$ 的单元格。\n-   **比对列**：回溯路径上的对角移动。$L$ 是其总数。\n-   **一致性**：\n    $$\n    \\mathrm{Id}(X,Y) \\;=\\; \n    \\begin{cases}\n    \\frac{M}{L},  \\text{if } L  0,\\\\\n    0,  \\text{if } L = 0,\n    \\end{cases}\n    $$\n    其中 $M$ 是在 $L$ 个比对列中相同字母对的数量。\n-   **待评估的性质**：是否存在序列 $X, Y$，使得 $S^\\star(X,Y)  0$ 并且 $\\mathrm{Id}(X,Y)$ 等于小数 $0$。\n\n-   **测试用例 1**：字母表 $\\{\\mathrm{I}, \\mathrm{L}, \\mathrm{V}, \\mathrm{M}\\}$，使用提供的 BLOSUM$62$ 子集评分，罚分 $d=5$，长度约束 $n \\ge 1, m \\ge 1$。\n-   **测试用例 2**：与用例 1 相同的字母表和评分，罚分 $d=0$，长度约束 $n=1, m=1$。\n-   **测试用例 3**：完整大写氨基酸字母表，评分 $s(a,b) = 2$（如果 $a=b$）和 $s(a,b)=-1$（如果 $a \\ne b$），罚分 $d=2$，长度约束 $n \\ge 1, m \\ge 1$。\n\n### 第二步：使用提取的已知条件进行验证\n\n-   **科学依据**：该问题基于 Smith-Waterman 算法，这是生物信息学中的一个基本概念。评分模型（BLOSUM 矩阵、匹配/错配方案）和线性罚分都是标准的。所提供的定义在数学上和算法上都是正确的。该问题是可靠的。\n-   **良构性**：问题被构造成三个独立的测试用例，每个用例都有完全指定的参数。对于每个用例，它询问是否存在满足精确定义性质的序列。这是一个有明确布尔答案（true 或 false）的良构问题。\n-   **客观性**：问题以客观、正式的语言陈述，没有歧义或主观论断。\n\n该问题没有表现出任何诸如科学上不可靠、不完整、矛盾或结构不良等缺陷。\n\n### 第三步：结论与行动\n\n问题有效。将提供解决方案。\n\n### 基于原理的解决方案设计\n\n核心任务是为三种评分模型中的每一种确定是否可以构建两个序列 $X$ 和 $Y$，使其同时满足两个条件：\n1. 最优局部比对得分 $S^\\star(X,Y)$ 严格为正。\n2. 最优局部比对的一致性 $\\mathrm{Id}(X,Y)$ 恰好为 $0$。\n\n条件 $\\mathrm{Id}(X,Y) = 0$ 意味着在最优局部比对区域内，没有匹配的字符。为了使这变得有意义，比对长度 $L$（回溯中的对角移动次数）必须大于 0，这反过来意味着匹配数 $M$ 必须为 $0$。如果 $L=0$，则比对为空，其得分为 $0$，违反了 $S^\\star  0$ 的条件。因此，我们寻求一个至少包含一个对角移动（$L \\ge 1$）的比对路径，其中所有这些移动都是错配。\n\n局部比对的得分由其构成操作（匹配、错配和空位）的得分总和决定。为了使 $S^\\star  0$，必须存在一条从得分 $0$ 开始并累积得到正总分的比对路径。\n\n**测试用例 1：BLOSUM$62$ 子集, $d=5$**\n\n字母表是 $\\{\\mathrm{I}, \\mathrm{L}, \\mathrm{V}, \\mathrm{M}\\}$。所提供的评分矩阵为这些相似的疏水性氨基酸之间的替换指定了正分。例如，比对异亮氨酸 (I) 和缬氨酸 (V) 的得分是 $s(\\mathrm{I},\\mathrm{V}) = 3$。让我们构建最简单的非平凡序列：$X = \\text{\"I\"}$ 和 $Y = \\text{\"V\"}$。这里，$n=1, m=1$。\n\nSmith-Waterman 矩阵 $H$ 的大小为 $2 \\times 2$。唯一需要计算的非平凡条目是 $H_{1,1}$：\n$$H_{1,1} = \\max\\{0, H_{0,0} + s(\\text{'I'},\\text{'V'}), H_{0,1} - 5, H_{1,0} - 5\\}$$\n$$H_{1,1} = \\max\\{0, 0 + 3, 0 - 5, 0 - 5\\} = \\max\\{0, 3, -5, -5\\} = 3$$\n最优得分是 $S^\\star = 3$，大于 $0$。\n为了找到一致性，我们从单元格 $(1,1)$ 回溯。得分 $3$ 是从对角前驱 $H_{0,0}$ 获得的。这构成了一次对角移动，所以 $L=1$。比对是 $\\text{'I'}$ 与 $\\text{'V'}$。由于它们不同，匹配数 $M=0$。\n一致性是 $\\mathrm{Id} = M/L = 0/1 = 0$。\n两个条件（$S^\\star  0$ 和 $\\mathrm{Id}=0$）都满足。因此，该性质在此情况下是可满足的。答案是 `True`。\n\n**测试用例 2：BLOSUM$62$ 子集, $d=0, n=m=1$**\n\n此用例使用与用例 1 相同的评分，但罚分为零，且有 $n=1, m=1$ 的严格长度约束。用例 1 的逻辑可直接应用。让我们再次选择 $X = \\text{\"I\"}$ 和 $Y = \\text{\"V\"}$。\n得分计算如下：\n$$H_{1,1} = \\max\\{0, H_{0,0} + s(\\text{'I'},\\text{'V'}), H_{0,1} - 0, H_{1,0} - 0\\}$$\n$$H_{1,1} = \\max\\{0, 0 + 3, 0 - 0, 0 - 0\\} = \\max\\{0, 3, 0, 0\\} = 3$$\n最优得分是 $S^\\star = 3  0$。比对包含一次错配，所以 $L=1, M=0$，且 $\\mathrm{Id}=0$。两个条件都满足。答案是 `True`。\n\n**测试用例 3：仅基于一致性评分, $d=2$**\n\n评分模型是 $s(a,a) = 2$（匹配）和 $s(a,b) = -1$（当 $a \\ne b$ 时，即错配）。罚分是 $d=2$。\n为了实现 $\\mathrm{Id}=0$，比对路径必须完全由错配和空位组成。\n让我们分析这种比对中每个可能步骤的得分贡献：\n-   一个错配贡献 -1 分。\n-   一个空位（插入或删除）贡献 -d = -2 分。\n\n任何从得分 $0$ 开始并由这些操作序列组成的比对路径都将累积一个总分。设路径有 $k_d$ 次错配和 $k_g$ 次空位。为了一致性按规定定义且比对非空，我们需要 $L = k_d  0$。此比对路径的总分是：\n$$\\text{Score} = k_d \\times (-1) + k_g \\times (-2) = -k_d - 2k_g$$\n由于 $k_d \\ge 1$ 且 $k_g \\ge 0$，这个得分总是严格为负（例如，$\\le -1$）。\nSmith-Waterman 递推式是 $H_{i,j} = \\max\\{0, \\dots\\}$。这意味着如果扩展任何现有比对或开始新比对的得分为负，则结果单元格值 $H_{i,j}$ 将被设置为 0。仅由错配和空位组成的比对将总是产生非正的得分路径。因此，整个矩阵中的最大得分 $S^\\star$ 永远不可能严格为正。它将是 $0$。\n因此，在这种评分模型下，不可能同时满足 $S^\\star  0$ 和 $\\mathrm{Id}=0$。该性质是不可满足的。答案是 `False`。\n\n**算法实现**\n\n该解决方案用 Python 实现。一个名为 `run_sw_and_evaluate` 的函数封装了单个测试用例的逻辑。它构建指定的序列、评分函数和罚分。然后它调用一个 `smith_waterman` 函数，该函数使用 `numpy` 作为动态规划矩阵，从基本原理上实现了该算法。该函数计算最优得分 $S^\\star$，如果 $S^\\star  0$，则执行回溯以计算比对一致性 $\\mathrm{Id}$。主函数 `solve` 遍历三个测试用例，为每个用例调用 `run_sw_and_evaluate`，并将得到的布尔值附加到列表中。最后，它以指定格式打印该列表。如上所述，为测试用例 1 和 2 选择的序列是展示正错配得分的简单对。对于测试用例 3，使用了一个简单的错配对，它正确地得出了 0 分的结果，从而得到一个 `False` 结果，这与不可能性的证明是一致的。",
            "answer": "```python\nimport numpy as np\n\ndef smith_waterman(X: str, Y: str, score_func, d: int):\n    \"\"\"\n    Implements the Smith-Waterman algorithm from first principles.\n\n    Args:\n        X: The first sequence.\n        Y: The second sequence.\n        score_func: A function s(a, b) that returns the score of aligning characters a and b.\n        d: The linear gap penalty (a positive integer).\n\n    Returns:\n        A tuple (max_score, identity) where max_score is the optimal local\n        alignment score and identity is the fraction of matches in the\n        optimal alignment.\n    \"\"\"\n    n = len(X)\n    m = len(Y)\n    H = np.zeros((n + 1, m + 1), dtype=int)\n    \n    max_score = 0\n    max_pos = (0, 0)\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            match_score = H[i - 1, j - 1] + score_func(X[i - 1], Y[j - 1])\n            delete_score = H[i - 1, j] - d\n            insert_score = H[i, j - 1] - d\n            \n            H[i, j] = max(0, match_score, delete_score, insert_score)\n\n            if H[i, j]  max_score:\n                max_score = H[i, j]\n                max_pos = (i, j)\n\n    if max_score == 0:\n        return 0, 0.0\n\n    # Traceback to calculate identity\n    i, j = max_pos\n    L, M = 0, 0\n    \n    while H[i, j]  0:\n        current_score = H[i, j]\n        \n        # Check diagonal predecessor\n        if i  0 and j  0 and current_score == H[i - 1, j - 1] + score_func(X[i - 1], Y[j - 1]):\n            L += 1\n            if X[i - 1] == Y[j - 1]:\n                M += 1\n            i, j = i - 1, j - 1\n        # Check up predecessor (gap in Y)\n        elif i  0 and current_score == H[i - 1, j] - d:\n            i -= 1\n        # Check left predecessor (gap in X)\n        elif j  0 and current_score == H[i, j - 1] - d:\n            j -= 1\n        else:\n            # Should not be reached if traceback starts from a cell  0.\n            # This indicates the alignment started at this cell.\n            break\n            \n    identity = M / L if L  0 else 0.0\n    return max_score, identity\n\ndef solve():\n    \"\"\"\n    Defines and runs the three test cases specified in the problem.\n    \"\"\"\n    \n    # Test Case 1: BLOSUM62 subset, d=5\n    blosum62_subset = {\n        'I': {'I': 4, 'L': 2, 'V': 3, 'M': 1},\n        'L': {'I': 2, 'L': 4, 'V': 1, 'M': 2},\n        'V': {'I': 3, 'V': 4, 'L': 1, 'M': 1},\n        'M': {'I': 1, 'L': 2, 'V': 1, 'M': 5}\n    }\n    score_func_1 = lambda a, b: blosum62_subset[a][b]\n    # We choose two different amino acids with a positive substitution score.\n    X1, Y1 = \"I\", \"V\" \n    d1 = 5\n    \n    # Test Case 2: BLOSUM62 subset, d=0, n=m=1\n    score_func_2 = score_func_1\n    X2, Y2 = \"I\", \"V\"\n    d2 = 0\n\n    # Test Case 3: Match/mismatch, d=2\n    score_func_3 = lambda a, b: 2 if a == b else -1\n    # We choose any two different amino acids to form a mismatch.\n    X3, Y3 = \"A\", \"R\"\n    d3 = 2\n    \n    test_cases = [\n        (X1, Y1, score_func_1, d1),\n        (X2, Y2, score_func_2, d2),\n        (X3, Y3, score_func_3, d3),\n    ]\n\n    results = []\n    for X, Y, score_func, d in test_cases:\n        s_star, identity = smith_waterman(X, Y, score_func, d)\n        condition_met = (s_star  0 and identity == 0.0)\n        results.append(condition_met)\n    \n    # Python's str(bool) produces \"True\" and \"False\".\n    # The problem asks for a boolean, and this is the standard representation.\n    # The example [result_1, ...] suggests a comma-separated list.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "在理解了相似性与一致性的区别之后，我们来挑战一个更具设计性的优化问题。本练习要求你在固定序列一致性（$50\\%$）的严格约束下，通过策略性地选择替换氨基酸，来最大化两条序列的总体BLOSUM62相似性得分。要解决这个问题，你需要深入分析BLOSUM62矩阵，并运用贪心策略来权衡保留一个相同残基与进行一次“最佳”替换之间的得分收益，从而加深对替换矩阵在序列设计中实际应用的理解。",
            "id": "2428729",
            "problem": "给定一个由$20$种标准氨基酸$\\{ \\mathrm{A}, \\mathrm{R}, \\mathrm{N}, \\mathrm{D}, \\mathrm{C}, \\mathrm{Q}, \\mathrm{E}, \\mathrm{G}, \\mathrm{H}, \\mathrm{I}, \\mathrm{L}, \\mathrm{K}, \\mathrm{M}, \\mathrm{F}, \\mathrm{P}, \\mathrm{S}, \\mathrm{T}, \\mathrm{W}, \\mathrm{Y}, \\mathrm{V} \\}$组成的参考蛋白质序列。设参考序列为$S = (a_1, a_2, \\dots, a_n)$，其长度为$n$，其中$n$为偶数。考虑构建一个相同长度的新蛋白质序列$T = (b_1, b_2, \\dots, b_n)$，使得恰好有一半的位置与参考序列相同，也就是说，恰好有$n/2$个索引$i$满足$b_i = a_i$。没有插入或删除。块替换矩阵（BLOSUM62）为任意一对氨基酸$x$和$y$定义了一个替换得分$s(x,y)$。序列间的总相似性得分是各位置得分的总和：\n$$\n\\text{Score}(S,T) = \\sum_{i=1}^{n} s(a_i, b_i).\n$$\n你的任务是，对于每个给定的参考序列$S$，在所有与$S$有恰好$n/2$个相同位置的序列$T$中，计算$\\text{Score}(S,T)$的最大可能值。计算需使用标准的BLOSUM62替换得分，并允许在不相同的位置选择任意氨基酸。所有序列均由20种标准氨基酸构成，不含模糊字母。不允许有空位，所有比较都是逐位进行的。\n\n测试套件：\n- 案例1（常见重复残基）：$S = \\text{\"AAAAAA\"}$。\n- 案例2（具高对角线值的常见重复残基）：$S = \\text{\"WWWWWW\"}$。\n- 案例3（具中性非对角线值的常见重复残基）：$S = \\text{\"GGGG\"}$。\n- 案例4（交替残基以探究逐位权衡）：$S = \\text{\"ACACACAC\"}$。\n- 案例5（边界长度）：$S = \\text{\"AA\"}$。\n\n对于每个案例，计算一个整数：任何与$S$有恰好$n/2$个相同位点的序列$T$可达到的$\\text{Score}(S,T)$的最大值。你的程序应该生成单行输出，包含用方括号括起来的逗号分隔列表形式的结果（例如，“[x1,x2,x3,x4,x5]”），顺序与上述测试套件相同。本问题不涉及物理单位。相同位置的比例必须表示为恰好二分之一，即$n/2$或$0.5$个位置，而不是百分比。",
            "solution": "所述问题是计算生物学领域内的一个约束优化问题。我们被要求在给定参考蛋白质序列$S$和一个相同长度的目标序列$T$之间，找到最大的相似性得分，其特定约束条件是$T$中恰好有一半的位置与$S$中的位置相同。\n\n设参考序列为$S = (a_1, a_2, \\dots, a_n)$，其长度为偶数$n$，由20种标准氨基酸字母表构成。我们旨在构建一个序列$T = (b_1, b_2, \\dots, b_n)$，以最大化总相似性得分，定义如下：\n$$\n\\text{Score}(S,T) = \\sum_{i=1}^{n} s(a_i, b_i)\n$$\n其中$s(x,y)$是由BLOSUM62矩阵给出的替换得分。\n\n$T$的构建受一个关键约束的制约：$b_i = a_i$的位置$i$的数量必须恰好为$n/2$。让我们将序列索引集合$\\{1, 2, \\dots, n\\}$划分为两个不相交的子集：\n1.  相同位置的集合，$I = \\{i \\mid b_i = a_i\\}$，其基数为$|I| = n/2$。\n2.  突变位置的集合，$M = \\{i \\mid b_i \\neq a_i\\}$，其基数为$|M| = n/2$。\n\n总得分可以分解为对这两个集合的求和：\n$$\n\\text{Score}(S,T) = \\sum_{i \\in I} s(a_i, a_i) + \\sum_{i \\in M} s(a_i, b_i)\n$$\n\n为了最大化该总得分，我们必须对划分$(I, M)$和所有$i \\in M$的特定氨基酸$b_i$做出最优选择。对于$i \\in M$的$b_i$的选择彼此独立，且独立于划分。对于任何被指定为突变位点（即$i \\in M$）的给定位置$i$，得分贡献$s(a_i, b_i)$可以通过选择与$a_i$具有最高替换得分的氨基酸$b_i$（其中$b_i \\neq a_i$）来最大化。\n\n让我们为参考序列$S$中的每个位置$i$定义两个量：\n1.  **相同得分**（identity score），$\\delta_{id}(i)$，是如果位置$i$被选为相同时的得分贡献。这只是BLOSUM62矩阵中对应氨基酸$a_i$的对角线元素：\n    $$\n    \\delta_{id}(i) = s(a_i, a_i)\n    $$\n2.  **最大突变得分**（maximum mutation score），$\\delta_{mut}(i)$，是如果位置$i$被选为突变位点时的最大可能得分贡献。这可以通过取BLOSUM62矩阵中对应氨基酸$a_i$的最大非对角线得分来找到：\n    $$\n    \\delta_{mut}(i) = \\max_{x \\in \\mathcal{A}, x \\neq a_i} s(a_i, x)\n    $$\n    其中$\\mathcal{A}$是20种标准氨基酸的集合。\n\n根据这些定义，对于一个固定的划分$(I, M)$，最大可达得分为：\n$$\n\\text{Score}_{max}(I, M) = \\sum_{i \\in I} \\delta_{id}(i) + \\sum_{i \\in M} \\delta_{mut}(i)\n$$\n\n我们的任务现在简化为找到使该总和最大化的最优划分$(I, M)$。我们可以重新表述该表达式，以分离出依赖于划分选择的项。由于$I \\cup M = \\{1, \\dots, n\\}$且$I \\cap M = \\emptyset$，我们可以写出$\\sum_{i \\in M} \\delta_{mut}(i) = \\sum_{j=1}^{n} \\delta_{mut}(j) - \\sum_{j \\in I} \\delta_{mut}(j)$。将此代入得分方程得到：\n$$\n\\text{Score}_{max}(I) = \\sum_{i \\in I} \\delta_{id}(i) + \\left( \\sum_{j=1}^{n} \\delta_{mut}(j) - \\sum_{j \\in I} \\delta_{mut}(j) \\right)\n$$\n$$\n\\text{Score}_{max}(I) = \\left( \\sum_{j=1}^{n} \\delta_{mut}(j) \\right) + \\sum_{i \\in I} (\\delta_{id}(i) - \\delta_{mut}(i))\n$$\n\n第一项$\\sum_{j=1}^{n} \\delta_{mut}(j)$对于给定的参考序列$S$是一个常数；它不依赖于集合$I$的选择。因此，为了最大化总得分，我们必须最大化第二项。让我们将每个位置$i$的**相同优势**（identity advantage）定义为：\n$$\n\\Delta_i = \\delta_{id}(i) - \\delta_{mut}(i)\n$$\n这个量$\\Delta_i$表示通过选择位置$i$成为一个相同位点（$i \\in I$）而不是一个最优突变位点（$i \\in M$）所获得的得分净增益。\n\n问题现在是选择一个大小为$n/2$的集合$I$，以最大化$\\sum_{i \\in I} \\Delta_i$。这是一个经典的选择问题。最优策略是贪心策略：为所有位置$i=1, \\dots, n$计算优势值$\\Delta_i$，然后选择具有最大优势值的$n/2$个位置来组成集合$I$。\n\n算法如下：\n1.  对于给定的参考序列$S = (a_1, \\dots, a_n)$，使用标准的BLOSUM62矩阵，为20种标准氨基酸中的每一种$a$预先计算并存储$\\delta_{id}(a)$和$\\delta_{mut}(a)$的值。\n2.  对于每个位置$i \\in \\{1, \\dots, n\\}$，确定氨基酸$a_i$并获取其对应的值$\\delta_{id}(a_i)$和$\\delta_{mut}(a_i)$。\n3.  计算突变得分列表$M_{scores} = [\\delta_{mut}(a_1), \\dots, \\delta_{mut}(a_n)]$和优势值列表$\\text{Advantages} = [\\Delta_1, \\dots, \\Delta_n]$，其中$\\Delta_i = \\delta_{id}(a_i) - \\delta_{mut}(a_i)$。\n4.  将`Advantages`列表按降序排序。\n5.  最大总分是所有最大突变得分之和，加上前$n/2$个最大优势值之和：\n    $$\n    \\text{Score}_{max} = \\left( \\sum_{i=1}^{n} \\delta_{mut}(a_i) \\right) + \\left( \\sum_{j=1}^{n/2} \\text{sorted\\_Advantages}_j \\right)\n    $$\n此方法得出精确的最大得分，因为各个位置的得分贡献是可加的，并且它们的优化是解耦的，从而允许对相同位点集合$I$进行贪心选择。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the protein sequence scoring problem based on a greedy optimization strategy.\n    \n    The problem is to maximize the BLOSUM62 score of a sequence T against a \n    reference sequence S, where T has exactly n/2 identical residues to S.\n\n    The logic is as follows:\n    1. For each position in S, we can either keep it identical or mutate it.\n    2. The score for an identical position `i` is `s(a_i, a_i)`.\n    3. The best possible score for a mutated position `i` is `max(s(a_i, x))` for all `x != a_i`.\n    4. The \"advantage\" of keeping a position identical is the difference: \n       `s(a_i, a_i) - max(s(a_i, x))`.\n    5. To maximize the total score, we should choose the `n/2` positions with the highest\n       \"advantage\" to be identical. The rest will be optimally mutated.\n    6. The final score is the sum of scores from the chosen identical positions and the\n       optimally mutated positions. This is equivalent to summing all optimal mutation\n       scores and adding the sum of the top `n/2` advantages.\n    \"\"\"\n\n    # The canonical 20 amino acids as per the problem.\n    # The order must match the BLOSUM62 matrix below.\n    AA_ORDER = 'ARNDCQEGHILKMFPSTWYV'\n    \n    # Standard BLOSUM62 substitution matrix for the 20 amino acids.\n    # Source: NCBI\n    BLOSUM62 = np.array([\n        # A, R, N, D, C, Q, E, G, H, I, L, K, M, F, P, S, T, W, Y, V\n        [ 4,-1,-2,-2, 0,-1,-1, 0,-2,-1,-1,-1,-1,-2,-1, 1, 0,-3,-2, 0], # A\n        [-1, 5, 0,-2,-3, 1, 0,-2, 0,-3,-2, 2,-1,-3,-2,-1,-1,-3,-2,-3], # R\n        [-2, 0, 6, 1,-3, 0, 0, 0, 1,-3,-3, 0,-2,-3,-2, 1, 0,-4,-2,-3], # N\n        [-2,-2, 1, 6,-3, 0, 2,-1,-1,-3,-4,-1,-3,-3,-1, 0,-1,-4,-3,-3], # D\n        [ 0,-3,-3,-3, 9,-3,-4,-3,-3,-1,-1,-3,-1,-2,-3,-1,-1,-2,-2,-1], # C\n        [-1, 1, 0, 0,-3, 5, 2,-2, 0,-3,-2, 1, 0,-3,-1, 0,-1,-2,-1,-2], # Q\n        [-1, 0, 0, 2,-4, 2, 5,-2, 0,-3,-3, 1,-2,-3,-1, 0,-1,-3,-2,-2], # E\n        [ 0,-2, 0,-1,-3,-2,-2, 6,-2,-4,-4,-2,-3,-3,-2, 0,-2,-2,-3,-3], # G\n        [-2, 0, 1,-1,-3, 0, 0,-2, 8,-3,-3,-1,-2,-1,-2,-1,-2,-2, 2,-3], # H\n        [-1,-3,-3,-3,-1,-3,-3,-4,-3, 4, 2,-3, 1, 0,-3,-2,-1,-3,-1, 3], # I\n        [-1,-2,-3,-4,-1,-2,-3,-4,-3, 2, 4,-2, 2, 0,-3,-2,-1,-2,-1, 1], # L\n        [-1, 2, 0,-1,-3, 1, 1,-2,-1,-3,-2, 5,-1,-3,-1, 0,-1,-3,-2,-2], # K\n        [-1,-1,-2,-3,-1, 0,-2,-3,-2, 1, 2,-1, 5, 0,-2,-1,-1,-1,-1, 1], # M\n        [-2,-3,-3,-3,-2,-3,-3,-3,-1, 0, 0,-3, 0, 6,-4,-2,-2, 1, 3,-1], # F\n        [-1,-2,-2,-1,-3,-1,-1,-2,-2,-3,-3,-1,-2,-4, 7,-1,-1,-4,-3,-2], # P\n        [ 1,-1, 1, 0,-1, 0, 0, 0,-1,-2,-2, 0,-1,-2,-1, 4, 1,-3,-2,-2], # S\n        [ 0,-1, 0,-1,-1,-1,-1,-2,-2,-1,-1,-1,-1,-2,-1, 1, 5,-2,-2, 0], # T\n        [-3,-3,-4,-4,-2,-2,-3,-2,-2,-3,-2,-3,-1, 1,-4,-3,-2,11, 2,-3], # W\n        [-2,-2,-2,-3,-2,-1,-2,-3, 2,-1,-1,-2,-1, 3,-3,-2,-2, 2, 7,-1], # Y\n        [ 0,-3,-3,-3,-1,-2,-2,-3,-3, 3, 1,-2, 1,-1,-2,-2, 0,-3,-1, 4]  # V\n    ])\n    \n    # Map amino acid characters to their index in the matrix\n    AA_MAP = {aa: i for i, aa in enumerate(AA_ORDER)}\n\n    # Pre-calculate identity scores and max mutation scores for each amino acid\n    delta_cache = {}\n    for aa, idx in AA_MAP.items():\n        row = BLOSUM62[idx]\n        delta_id = row[idx]\n        # Max mutation score is the max of the row excluding the identity score\n        delta_mut = np.max(np.delete(row, idx))\n        delta_cache[aa] = (delta_id, delta_mut)\n\n    test_cases = [\n        \"AAAAAA\",     # Case 1\n        \"WWWWWW\",     # Case 2\n        \"GGGG\",       # Case 3\n        \"ACACACAC\",   # Case 4\n        \"AA\"          # Case 5\n    ]\n\n    results = []\n    for seq in test_cases:\n        n = len(seq)\n        num_identities = n // 2\n        \n        advantages = []\n        mut_scores_sum = 0\n        \n        for aa_char in seq:\n            delta_id, delta_mut = delta_cache[aa_char]\n            advantage = delta_id - delta_mut\n            advantages.append(advantage)\n            mut_scores_sum += delta_mut\n            \n        # Sort advantages in descending order to find the top n/2\n        advantages.sort(reverse=True)\n        \n        # The total score is the sum of all optimal mutation scores plus the sum of the\n        # advantages for the positions we choose to keep identical.\n        top_advantages_sum = sum(advantages[:num_identities])\n        \n        max_score = mut_scores_sum + top_advantages_sum\n        results.append(max_score)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "这个高级练习揭示了一个微妙但关键的观点：序列比对算法的首要目标是最大化一个综合的相似性得分，而得分最高的比对不一定具有最高的一致性。通过实现一个带有仿射空位罚分模型的全局比对算法，你将探索不同的空位（gap）策略如何导致这一看似违反直觉却至关重要的结果。完成这项任务能让你更深刻地理解算法的优化目标（score）与我们直观追求的生物学相似性（identity）之间的复杂权衡。",
            "id": "2428713",
            "problem": "你需要编写一个完整的、可运行的程序，该程序针对一小组序列对和评分参数的测试套件，在仿射空位罚分模型下构建全局配对对齐，并定量地展示优化序列相似性（通过替换函数和空位罚分进行评分）与优化序列一致性之间的差异。你的程序必须实现以下两者：(i) 一个最大化相似性得分的无约束全局对齐，以及 (ii) 一个最大化相同相似性得分但限制为空位区段数恰好为 $K=2$ 的约束变体。然后，你必须计算每个结果对齐的序列一致性，并验证一个构造：在该构造中，相似性优化的对齐使用一个大的空位区段，而强制使用两个较小的空位区段则能产生更高的序列一致性。\n\n基本定义和要求：\n- 设两条序列为 $x = x_1 x_2 \\dots x_n$ 和 $y = y_1 y_2 \\dots y_m$，它们基于一个有限字母表。全局对齐是一个配对列的序列，其中包含 $x$ 和 $y$ 的每个字符恰好一次，可能插入了空位符号 $-$。\n- 定义一个字母-字母替换得分函数 $s(a,b)$，其中 $a$ 和 $b$ 来自该字母表。在本次作业中，使用 $s(a,b) = \\alpha$（如果 $a=b$）和 $s(a,b)=\\beta$（如果 $a \\neq b$），其中 $\\alpha = +2$ 且 $\\beta = -1$。\n- 使用仿射空位罚分模型：一个长度为 $L \\ge 1$ 的连续空位区段对总对齐得分的贡献为 $c(L) = g_o + (L-1) g_e$，其中 $g_o$ 是空位开放罚分，$g_e$ 是空位延伸罚分。$g_o$ 和 $g_e$ 均为非正数。一个对齐的相似性得分是所有字母-字母替换得分与所有空位区段罚分之和。\n- 空位区段的数量定义为对齐中两条序列上连续空位片段的总数。等效地，它是从一个字母-字母列转换到一个空位列的次数，在两条序列上求和。\n- 将一个对齐的序列一致性定义为\n$$\n\\mathrm{Id} = \\frac{M}{T},\n$$\n其中 $M$ 是两条序列中字母都存在且相等的列数（即精确匹配），$T$ 是总对齐列数，包括在某条序列中包含空位的列。将 $\\mathrm{Id}$ 以小数形式报告。\n\n你的程序必须执行的算法任务：\n1. 对于给定的序列对 $(x,y)$ 和参数 $(\\alpha, \\beta, g_o, g_e)$，计算一个在仿射模型下最大化相似性得分的全局对齐。记录最优相似性得分、产生的空位区段数 $r^\\star$ 以及结果对齐的一致性 $\\mathrm{Id}^\\star$。\n2. 对于相同的 $(x,y)$ 和参数，计算一个最大化相似性得分的全局对齐，但受限于该对齐恰好使用 $K=2$ 个空位区段。如果不存在这样的对齐，则将此约束问题的一致性定义为 $\\mathrm{NaN}$ (not a number)。否则，记录约束下的最优一致性 $\\mathrm{Id}^{(2)}$。\n3. 对于每个测试用例，输出四个量：\n   - 一个布尔值，指示无约束最优对齐是否恰好使用一个空位区段（即 $r^\\star = 1$ 是否成立）；\n   - 无约束一致性 $\\mathrm{Id}^\\star$，四舍五入到三位小数；\n   - 约束一致性 $\\mathrm{Id}^{(2)}$，四舍五入到三位小数（如果不可行则为 $\\mathrm{NaN}$）；\n   - 一个布尔值，指示是否 $\\mathrm{Id}^{(2)}  \\mathrm{Id}^\\star$。\n4. 你的程序应生成单行输出，包含一个由各用例结果列表组成的逗号分隔列表，每个用例结果列表的格式为 [uses_one_gap_boolean,Id_unconstrained,Id_K2,IdK2_greater_boolean]。例如：[[True,0.615,0.692,True],[...],[...]]。\n\n测试套件：\n使用以下三个测试用例来检验不同的行为，包括一个展示所要求现象的构造。\n\n- 用例 A（此构造中，最优相似性使用一个大的空位区段，而强制使用两个较小的空位区段会增加一致性）：\n  - $x = \\text{\"AAAAMCCCC\"}$\n  - $y = \\text{\"AAAAXXMYYCCCC\"}$\n  - $\\alpha = +2$, $\\beta = -1$\n  - $g_o = -6.0$, $g_e = -0.5$\n  此用例经过精心设计，使得相似性优化的对齐倾向于使用一个覆盖 $\\text{\"XXMYY\"}$ 的大空位（一个空位区段），而强制使用两个空位区段则允许将 $\\text{\"XX\"}$ 和 $\\text{\"YY\"}$ 作为两个短空位移除，同时对齐 $\\text{\"M\"}$，从而增加如上定义的一致性。\n\n- 用例 B（相同序列的边界行为；无约束情况不使用空位，而具有恰好两个空位区段的约束问题仍然可行，但必然会降低一致性，因为分母中包含了空位）：\n  - $x = \\text{\"ACGT\"}$\n  - $y = \\text{\"ACGT\"}$\n  - $\\alpha = +2$, $\\beta = -1$\n  - $g_o = -6.0$, $g_e = -0.5$\n\n- 用例 C（在此参数和序列下，即使没有约束，两个短的空位区段也是最优的；约束后的一致性与无约束的一致性相匹配，且不会超过它）：\n  - $x = \\text{\"AAAATTTTCCCC\"}$\n  - $y = \\text{\"AAAAxxTTTTyyCCCC\"}$\n  - $\\alpha = +2$, $\\beta = -1$\n  - $g_o = -2.0$, $g_e = -1.0$\n\n最终输出格式：\n- 你的程序必须精确打印一行，其中包含一个含三个内部列表（每个测试用例一个）的单一列表，顺序为 [用例 A, 用例 B, 用例 C]。\n- 每个内部列表必须是 [uses_one_gap_boolean,Id_unconstrained_decimal_rounded_to_3_places,Id_K2_decimal_rounded_to_3_places_or_nan,IdK2_greater_boolean]。\n- 不得打印任何额外文本。\n\n所有角度或物理单位均不相关。将一致性表示为四舍五入到三位小数的小数。输出中不允许使用百分比。程序不得要求任何输入。实现必须是自包含的，且按原样即可运行。",
            "solution": "用户要求实现全局成对序列对齐算法，以展示序列相似性与序列一致性之间的区别。这涉及两个主要任务：首先，使用仿射空位罚分模型（戈托算法）进行无约束的全局对齐；其次，是对齐的约束版本，该版本被限制为固定数量的空位区段。\n\n该问题在科学上和算法上都定义明确。所有参数和测试用例均已指定，目标清晰。问题的核心在于正确实现两种动态规划 (DP) 算法。\n\n### 原则1：使用仿射空位罚分的无约束全局对齐\n\n第一个任务是计算一个最优全局对齐，该对齐最大化由替换矩阵 $s(a,b)$ 和仿射空位罚分函数 $c(L) = g_o + (L-1)g_e$ 定义的相似性得分。这是生物信息学中的一个经典问题，可通过戈托 (Gotoh) 算法高效解决。该算法使用动态规划，涉及三个矩阵，通常表示为 $M$、$I_x$ 和 $I_y$。\n\n设两条序列为长度为 $n$ 的 $x$ 和长度为 $m$ 的 $y$。DP 矩阵保存了 $x$ 和 $y$ 的前缀的最优对齐得分。\n- $M(i,j)$: $x_{1 \\dots i}$ 和 $y_{1 \\dots j}$ 的最佳对齐中，以对齐对 $(x_i, y_j)$ 结尾的得分。\n- $I_x(i,j)$: $x_{1 \\dots i}$ 和 $y_{1 \\dots j}$ 的最佳对齐中，以 $x$ 序列中的空位结尾（即列 $(-, y_j)$）的得分。\n- $I_y(i,j)$: $x_{1 \\dots i}$ 和 $y_{1 \\dots j}$ 的最佳对齐中，以 $y$ 序列中的空位结尾（即列 $(x_i, -)$）的得分。\n\n对于 $1 \\le i \\le n$ 和 $1 \\le j \\le m$，递推关系为：\n$$\nM(i,j) = s(x_i, y_j) + \\max\n\\begin{cases}\nM(i-1, j-1)  \\text{在匹配/错配后对齐 } x_i, y_j \\\\\nI_x(i-1, j-1)  \\text{在 } x \\text{ 的空位后对齐 } x_i, y_j \\\\\nI_y(i-1, j-1)  \\text{在 } y \\text{ 的空位后对齐 } x_i, y_j\n\\end{cases}\n$$\n$$\nI_x(i,j) = \\max\n\\begin{cases}\nM(i, j-1) + g_o + g_e  \\text{在 } x \\text{ 中新开一个空位} \\\\\nI_x(i, j-1) + g_e  \\text{延伸 } x \\text{ 中已有的空位}\n\\end{cases}\n$$\n$$\nI_y(i,j) = \\max\n\\begin{cases}\nM(i-1, j) + g_o + g_e  \\text{在 } y \\text{ 中新开一个空位} \\\\\nI_y(i-1, j) + g_e  \\text{延伸 } y \\text{ 中已有的空位}\n\\end{cases}\n$$\n\n全局对齐的基本情况是 $M(0,0)=0$，初始空位的边界条件为：$I_x(0,j) = g_o + (j-1)g_e$ 和 $I_y(i,0) = g_o + (i-1)g_e$。第 $0$ 行和第 $0$ 列中的所有其他条目初始化为 $-\\infty$。最优对齐得分是 $M(n,m)$、$I_x(n,m)$ 和 $I_y(n,m)$ 中的最大值。为了重构对齐及其属性（空位区段数 $r^\\star$，一致性 $\\mathrm{Id}^\\star$），我们从产生最大得分的单元格 $(n,m)$ 开始进行回溯。\n\n### 原则2：具有固定数量空位区段的约束对齐\n\n第二个任务要求修改 DP 算法以处理一个附加约束：空位区段的总数必须恰好为 $K=2$。问题通过将空位区段数定义为“从一个字母-字母列转换到一个空位列的次数”，提供了一个关键的简化。这个定义与戈托算法的状态转换完美契合，其中从状态 $M$ 转换到 $I_x$ 或 $I_y$ 对应于开放一个空位。\n\n我们将 DP 状态扩展，以包含已使用的空位区段数 $k$。DP 表变为 $M(i,j,k)$、$I_x(i,j,k)$ 和 $I_y(i,j,k)$，其中 $k$ 计空位区段的数量。$k$ 的最大值为约束 $K$。\n\n新的递推关系是：\n$$\nM(i,j,k) = s(x_i, y_j) + \\max(M(i-1,j-1,k), I_x(i-1,j-1,k), I_y(i-1,j-1,k))\n$$\n$$\nI_x(i,j,k) = \\max\n\\begin{cases}\nM(i, j-1, k-1) + g_o + g_e  (\\text{若 } k \\ge 1, \\text{ 开放空位，增加区段计数}) \\\\\nI_x(i, j-1, k) + g_e  (\\text{延伸空位，区段计数不变})\n\\end{cases}\n$$\n$$\nI_y(i,j,k) = \\max\n\\begin{cases}\nM(i-1, j, k-1) + g_o + g_e  (\\text{若 } k \\ge 1, \\text{ 开放空位，增加区段计数}) \\\\\nI_y(i-1, j, k) + g_e  (\\text{延伸空位，区段计数不变})\n\\end{cases}\n$$\n\n初始化需要设置 $M(0,0,0) = 0$。沿边界的初始空位现在算作一个空位区段，所以 $I_x(0,j,1) = g_o + (j-1)g_e$ 且 $I_y(i,0,1) = g_o + (i-1)g_e$。所有其他条目均为 $-\\infty$。具有恰好 $K$ 个空位区段的对齐的最终得分是 $\\max(M(n,m,K), I_x(n,m,K), I_y(n,m,K))$。如果该得分为 $-\\infty$，则不存在此类可行的对齐。\n\n### 一致性与空位区段的计算\n\n通过回溯找到最优对齐，得到一对对齐后的序列 $(x', y')$ 后，其属性计算如下：\n- **序列一致性**：$\\mathrm{Id} = \\frac{M}{T}$，其中 $T$ 是对齐的总长度（即 `len(x')`），$M$ 是 $x'[i] == y'[i]$ 且 $x'[i] \\neq '-'$ 的列 `i` 的数量。\n- **空位区段数**：通过计算包含至少一个空位字符的连续列块的数量来确定。\n\n实现将首先定义一个通用的对齐求解器，该求解器可以处理无约束和有约束两种情况。对于无约束情况，空位区段计数器维度可被忽略（或等效地，设置为具有无限最大值）。对于约束情况，DP 表被扩展，并按所述修改递推关系。这种统一的结构有助于实现清晰的代码。然后，程序将遍历测试套件，对每个用例应用这两种算法，计算所需的指标，并格式化最终输出。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the sequence alignment problem for the given test suite.\n    \"\"\"\n\n    test_cases = [\n        # Case A: Optimal similarity uses one large gap, forcing two gaps increases identity.\n        {\n            \"x\": \"AAAAMCCCC\",\n            \"y\": \"AAAAXXMYYCCCC\",\n            \"alpha\": 2.0, \"beta\": -1.0,\n            \"g_o\": -6.0, \"g_e\": -0.5\n        },\n        # Case B: Identical sequences; unconstrained is perfect match, constrained forces gaps.\n        {\n            \"x\": \"ACGT\",\n            \"y\": \"ACGT\",\n            \"alpha\": 2.0, \"beta\": -1.0,\n            \"g_o\": -6.0, \"g_e\": -0.5\n        },\n        # Case C: Two short gaps are optimal even without constraints.\n        {\n            \"x\": \"AAAATTTTCCCC\",\n            \"y\": \"AAAAxxTTTTyyCCCC\",\n            \"alpha\": 2.0, \"beta\": -1.0,\n            \"g_o\": -2.0, \"g_e\": -1.0\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        x, y, alpha, beta, g_o, g_e = case[\"x\"], case[\"y\"], case[\"alpha\"], case[\"beta\"], case[\"g_o\"], case[\"g_e\"]\n\n        # 1. Unconstrained alignment\n        unconstrained_res = align(x, y, alpha, beta, g_o, g_e, max_k=len(x)+len(y))\n        r_star = unconstrained_res[\"gap_runs\"]\n        id_star = unconstrained_res[\"identity\"]\n\n        # 2. Constrained alignment (K=2)\n        constrained_res = align(x, y, alpha, beta, g_o, g_e, max_k=2, exact_k=True)\n        id_k2 = constrained_res[\"identity\"] # Will be NaN if infeasible\n\n        # 3. Format results\n        uses_one_gap_boolean = (r_star == 1)\n        id_unconstrained_rounded = round(id_star, 3)\n\n        if np.isnan(id_k2):\n            id_k2_rounded = 'NaN'\n            idK2_greater_boolean = False\n        else:\n            id_k2_rounded = round(id_k2, 3)\n            # Handle potential floating point inaccuracies before comparison\n            if not np.isnan(id_star):\n                 idK2_greater_boolean = (id_k2_rounded  id_unconstrained_rounded)\n            else: # if unconstrained is NaN, this should also be False\n                 idK2_greater_boolean = False\n\n        all_results.append(f\"[{uses_one_gap_boolean},{id_unconstrained_rounded},{id_k2_rounded},{idK2_greater_boolean}]\")\n\n    # The final output must be compatible with Python's f-string formatting,\n    # converting boolean values to their string representations 'True' and 'False'.\n    final_output_str = f\"[{','.join(all_results)}]\"\n    final_output_str = final_output_str.replace(\"'NaN'\", \"NaN\") # Ensure NaN is not quoted\n    print(final_output_str)\n\ndef align(x, y, alpha, beta, g_o, g_e, max_k, exact_k=False):\n    \"\"\"\n    Performs global sequence alignment with an affine gap model,\n    with an optional constraint on the number of gap runs.\n\n    Args:\n        x, y: The sequences to align.\n        alpha, beta: Match and mismatch scores.\n        g_o, g_e: Gap open and gap extend penalties.\n        max_k: The maximum number of gap runs allowed.\n        exact_k: If true, require exactly max_k gap runs.\n\n    Returns:\n        A dictionary with the alignment, score, identity, and gap runs.\n        Returns NaN for metrics if no valid alignment is found.\n    \"\"\"\n    n, m = len(x), len(y)\n    neg_inf = -np.inf\n\n    # DP tables: M (match), Ix (gap in x), Iy (gap in y)\n    # The third dimension is for the number of gap runs (k)\n    k_dim = max_k + 1\n    M = np.full((n + 1, m + 1, k_dim), neg_inf)\n    Ix = np.full((n + 1, m + 1, k_dim), neg_inf)\n    Iy = np.full((n + 1, m + 1, k_dim), neg_inf)\n\n    # Traceback pointers\n    ptr_M = np.zeros((n + 1, m + 1, k_dim), dtype=int)\n    ptr_Ix = np.zeros((n + 1, m + 1, k_dim), dtype=int)\n    ptr_Iy = np.zeros((n + 1, m + 1, k_dim), dtype=int)\n\n    M[0, 0, 0] = 0\n\n    # Initialization of boundaries\n    for i in range(1, n + 1):\n        if 1  k_dim: Iy[i, 0, 1] = g_o + (i - 1) * g_e\n    for j in range(1, m + 1):\n        if 1  k_dim: Ix[0, j, 1] = g_o + (j - 1) * g_e\n\n    # DP calculation\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            s = alpha if x[i - 1] == y[j - 1] else beta\n            for k in range(k_dim):\n                # M table\n                scores_m = [M[i - 1, j - 1, k], Ix[i - 1, j - 1, k], Iy[i - 1, j - 1, k]]\n                best_prev_m_idx = np.argmax(scores_m)\n                M[i, j, k] = s + scores_m[best_prev_m_idx]\n                ptr_M[i, j, k] = best_prev_m_idx\n\n                # Ix table (gap in x)\n                open_gap_ix = neg_inf\n                if k > 0:\n                    open_gap_ix = M[i, j - 1, k - 1] + g_o + g_e\n                extend_gap_ix = Ix[i, j - 1, k] + g_e\n                \n                if open_gap_ix >= extend_gap_ix:\n                    Ix[i, j, k] = open_gap_ix\n                    ptr_Ix[i, j, k] = 0 # Came from M\n                else:\n                    Ix[i, j, k] = extend_gap_ix\n                    ptr_Ix[i, j, k] = 1 # Came from Ix\n\n                # Iy table (gap in y)\n                open_gap_iy = neg_inf\n                if k > 0:\n                    open_gap_iy = M[i - 1, j, k - 1] + g_o + g_e\n                extend_gap_iy = Iy[i - 1, j, k] + g_e\n                \n                if open_gap_iy >= extend_gap_iy:\n                    Iy[i, j, k] = open_gap_iy\n                    ptr_Iy[i, j, k] = 0 # Came from M\n                else:\n                    Iy[i, j, k] = extend_gap_iy\n                    ptr_Iy[i, j, k] = 1 # Came from Iy\n    \n    # Find optimal score and starting point for traceback\n    k_range = [max_k] if exact_k else range(k_dim)\n    \n    final_score = neg_inf\n    best_final_idx = -1\n    k_opt = -1\n\n    for k_val in k_range:\n        current_scores = [M[n,m,k_val], Ix[n,m,k_val], Iy[n,m,k_val]]\n        best_idx_for_k = np.argmax(current_scores)\n        score_for_k = current_scores[best_idx_for_k]\n        if score_for_k > final_score:\n            final_score = score_for_k\n            best_final_idx = best_idx_for_k\n            k_opt = k_val\n\n    if final_score == neg_inf:\n        return {\"alignment\": (\"\", \"\"), \"score\": neg_inf, \"identity\": np.nan, \"gap_runs\": -1}\n\n    # Traceback\n    ax, ay = [], []\n    i, j, k = n, m, k_opt\n    \n    state = best_final_idx\n\n    while i > 0 or j > 0:\n        if state == 0:  # In M\n            ax.append(x[i - 1])\n            ay.append(y[j - 1])\n            prev_state = ptr_M[i, j, k]\n            i, j = i - 1, j - 1\n            state = prev_state\n        elif state == 1: # In Ix\n            ax.append('-')\n            ay.append(y[j - 1])\n            prev_state = ptr_Ix[i, j, k]\n            j -= 1\n            if prev_state == 0: # Opened gap\n                k -= 1\n                state = 0\n            else: # Extended gap\n                state = 1\n        elif state == 2: # In Iy\n            ax.append(x[i - 1])\n            ay.append('-')\n            prev_state = ptr_Iy[i, j, k]\n            i -= 1\n            if prev_state == 0: # Opened gap\n                k -= 1\n                state = 0\n            else: # Extended gap\n                state = 2\n    \n    align_x = \"\".join(reversed(ax))\n    align_y = \"\".join(reversed(ay))\n\n    # Calculate identity and gap runs\n    matches = 0\n    total_len = len(align_x)\n    for l in range(total_len):\n        if align_x[l] == align_y[l] and align_x[l] != '-':\n            matches += 1\n    identity = matches / total_len if total_len > 0 else 0\n\n    gap_runs = 0\n    in_gap = False\n    for l in range(total_len):\n        is_gap_col = align_x[l] == '-' or align_y[l] == '-'\n        if is_gap_col and not in_gap:\n            gap_runs += 1\n            in_gap = True\n        elif not is_gap_col:\n            in_gap = False\n\n    return {\"alignment\": (align_x, align_y), \"score\": final_score, \"identity\": identity, \"gap_runs\": gap_runs}\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}