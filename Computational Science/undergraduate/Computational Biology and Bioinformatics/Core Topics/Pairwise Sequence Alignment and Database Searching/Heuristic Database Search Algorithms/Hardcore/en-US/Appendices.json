{
    "hands_on_practices": [
        {
            "introduction": "Heuristic algorithms like BLAST and FASTA rely on a 'seed-and-extend' strategy, which begins by finding short, exact matches called seeds. The probability of finding such a seed by chance is a critical factor that governs the algorithm's sensitivity and speed. This exercise  guides you through a foundational derivation of this probability, building your quantitative intuition for how parameters like word size ($W$) and alphabet size ($k$) impact the initial step of a database search.",
            "id": "2396864",
            "problem": "Consider seed-and-extend heuristic database search as used in tools such as the Basic Local Alignment Search Tool (BLAST). A query contains a fixed contiguous seed word of length $W$ over an alphabet of size $k$. Model a target database as a single long sequence of length $N$ in which characters are independently and identically distributed, each uniformly drawn from the $k$ letters. Assume that for each possible starting position in the database, whether the seed matches exactly at that position can be treated as an independent Bernoulli trial. Under this model, derive a closed-form analytic expression, in terms of $W$, $k$, and $N$, for the probability that the database contains at least one exact occurrence of the seed. Provide your answer as a single analytic expression. Do not include any units.",
            "solution": "The problem statement must first be rigorously validated.\n\nStep 1: Extract Givens.\n- A query contains a contiguous seed word of length $W$.\n- The alphabet has a size of $k$.\n- A target database is a single sequence of length $N$.\n- Database characters are independently and identically distributed (i.i.d.), each uniformly drawn from the $k$ letters.\n- For each possible starting position in the database, the event of an exact seed match is treated as an independent Bernoulli trial.\n- The objective is to derive a closed-form analytic expression for the probability that the database contains at least one exact occurrence of the seed, in terms of $W$, $k$, and $N$.\n\nStep 2: Validate Using Extracted Givens.\nThe problem is scientifically grounded, as it employs a standard probabilistic model used in the introductory analysis of bioinformatics algorithms. The assumption that match events at different starting positions are independent Bernoulli trials is a significant simplification of reality—in a real sequence, overlapping potential matches are not independent—however, the problem explicitly instructs us to use this model. As such, this is a feature of the given theoretical framework, not a flaw in the problem statement itself. The problem is well-posed, objective, and contains sufficient information for a unique solution within the specified model. It is mathematically formalizable and free of contradictions or logical fallacies.\n\nVerdict: The problem is valid. We will proceed to derive the solution.\n\nThe event of interest is that the database contains at least one exact occurrence of the seed. Let us denote this event by $A$. It is often simpler to calculate the probability of the complementary event, denoted $A^c$, which is the event that the database contains *no* exact occurrences of the seed. The law of total probability states that $P(A) = 1 - P(A^c)$.\n\nFirst, we must determine the probability of an exact match at a single, specific starting position in the database. Let us call this event $E_i$ for a starting position $i$. The seed word has length $W$. For an exact match to occur at position $i$, the character at position $i$ in the database must match the first character of the seed, the character at $i+1$ must match the second, and so on, up to position $i+W-1$.\n\nThe problem states that the characters in the database are drawn uniformly from an alphabet of size $k$. Thus, the probability of any single database character matching a specific character from the seed is $\\frac{1}{k}$. Since the database characters are also i.i.d., the probability of a sequence of $W$ specific characters occurring contiguously is the product of their individual probabilities. Therefore, the probability of an exact match at any single given starting position, let us call this probability $p$, is:\n$$p = \\left(\\frac{1}{k}\\right)^W = k^{-W}$$\n\nThis is the probability of \"success\" for a single Bernoulli trial. The probability of \"failure,\" i.e., no match at a given position, is $1-p$.\n$$1-p = 1 - k^{-W}$$\n\nNext, we must determine the number of possible starting positions for the seed in the database. The database has length $N$ and the seed has length $W$. We assume $N \\ge W$, as otherwise, a match is impossible. The first possible starting position is at index $1$ (spanning database characters $1$ through $W$). The last possible starting position is at index $N-W+1$ (spanning characters $N-W+1$ through $N$). Thus, there are a total of $M$ possible starting positions, where:\n$$M = (N - W + 1) - 1 + 1 = N - W + 1$$\n\nThe problem explicitly states that we are to treat these $M$ possible match events as independent Bernoulli trials. The event $A^c$—that no exact matches occur in the entire database—is equivalent to the event that we observe failure at all $M$ independent trials. The probability of this compound event is the product of the probabilities of the individual failures:\n$$P(A^c) = (1 - p)^M = \\left(1 - k^{-W}\\right)^{N-W+1}$$\n\nFinally, the probability of at least one exact match, $P(A)$, is found by substituting this result back into the complementary probability formula:\n$$P(A) = 1 - P(A^c) = 1 - \\left(1 - k^{-W}\\right)^{N-W+1}$$\n\nThis expression is a closed-form analytic solution for the requested probability in terms of the given parameters $W$, $k$, and $N$.",
            "answer": "$$\n\\boxed{1 - \\left(1 - k^{-W}\\right)^{N-W+1}}\n$$"
        },
        {
            "introduction": "After a seed hit triggers an alignment, the resulting score is just a number; its biological significance can only be judged through a rigorous statistical framework. The Karlin-Altschul theory provides this foundation by calculating the probability of obtaining a score by chance. This exercise  lets you derive its central parameter $\\lambda$ for a simple case, connecting abstract statistical theory to the concrete values that make BLAST's E-values possible.",
            "id": "2396829",
            "problem": "Consider random alignments of deoxyribonucleic acid (DNA) letters under the independent and identically distributed (i.i.d.) background model with uniform base frequencies, that is, $p_{A}=p_{C}=p_{G}=p_{T}=\\frac{1}{4}$. Let the pairwise scoring scheme be $s(a,b)=+1$ if $a=b$ (match) and $s(a,b)=-3$ if $a \\neq b$ (mismatch). In the Karlin–Altschul statistical framework for ungapped local alignments, the parameter $\\lambda$ is defined as the unique positive real number satisfying\n$$\n\\sum_{a \\in \\{A,C,G,T\\}} \\sum_{b \\in \\{A,C,G,T\\}} p_{a} p_{b} \\exp\\!\\big(\\lambda\\, s(a,b)\\big) \\;=\\; 1.\n$$\nUsing only this definition together with the stated model and scoring scheme, determine the numerical value of $\\lambda$. Round your answer to $4$ significant figures. Express your final result as a dimensionless number without units.",
            "solution": "The problem statement will first be subjected to a rigorous validation process.\n\nStep 1: Extract Givens\nThe explicit information provided in the problem statement is as follows:\n- Model: Random alignments of DNA letters under the independent and identically distributed (i.i.d.) background model.\n- Base frequencies: $p_{A}=p_{C}=p_{G}=p_{T}=\\frac{1}{4}$.\n- Pairwise scoring scheme: $s(a,b)=+1$ if $a=b$ (match) and $s(a,b)=-3$ if $a \\neq b$ (mismatch).\n- Definition of $\\lambda$: The unique positive real number satisfying the equation\n$$ \\sum_{a \\in \\{A,C,G,T\\}} \\sum_{b \\in \\{A,C,G,T\\}} p_{a} p_{b} \\exp(\\lambda s(a,b)) = 1 $$\n- Requirement: Determine the numerical value of $\\lambda$, rounded to $4$ significant figures.\n\nStep 2: Validate Using Extracted Givens\nThe problem is assessed against the criteria for validity.\n- **Scientifically Grounded:** The problem is based on the foundational Karlin-Altschul statistical theory, which is a critical component of modern bioinformatics, particularly for a tool such as BLAST. The equation provided is the core definition of the parameter $\\lambda$ in this context. The model and scoring scheme are standard for illustrative purposes. The problem is scientifically sound.\n- **Well-Posed:** The problem provides a well-defined equation and asks for a unique positive real solution. The theory of Karlin and Altschul guarantees that such a unique positive $\\lambda$ exists if and only if the expected score $E[s(a,b)]$ is negative. Let us compute this value. The probability of any specific pair $(a,b)$ is $p_a p_b = (\\frac{1}{4})(\\frac{1}{4}) = \\frac{1}{16}$. There are $4$ possible matches and $12$ possible mismatches. The expected score is:\n$$ E[s(a,b)] = \\sum_{a,b} p_a p_b s(a,b) = (4 \\times \\frac{1}{16} \\times (+1)) + (12 \\times \\frac{1}{16} \\times (-3)) = \\frac{4}{16} - \\frac{36}{16} = -\\frac{32}{16} = -2 $$\nSince $E[s(a,b)] = -2 < 0$, a unique positive solution for $\\lambda$ exists. The problem is well-posed.\n- **Objective:** The problem is stated using precise mathematical language and definitions, free of any subjectivity or ambiguity.\n\nStep 3: Verdict and Action\nThe problem is valid as it is scientifically grounded, well-posed, objective, and self-contained. Therefore, a solution will be derived.\n\nThe defining equation for $\\lambda$ is:\n$$ \\sum_{a \\in \\{A,C,G,T\\}} \\sum_{b \\in \\{A,C,G,T\\}} p_{a} p_{b} \\exp(\\lambda s(a,b)) = 1 $$\nThe set of all possible pairs of letters $(a,b)$ can be partitioned into two disjoint sets: matches, where $a=b$, and mismatches, where $a \\neq b$. The summation can be split accordingly:\n$$ \\sum_{a=b} p_{a} p_{b} \\exp(\\lambda s(a,b)) + \\sum_{a \\neq b} p_{a} p_{b} \\exp(\\lambda s(a,b)) = 1 $$\nThe DNA alphabet has $4$ letters. Thus, there are $4$ possible matching pairs (A,A), (C,C), (G,G), (T,T) and $4 \\times 4 - 4 = 12$ possible mismatching pairs.\nThe probabilities are uniform, so for any pair $(a,b)$, $p_a p_b = \\frac{1}{4} \\times \\frac{1}{4} = \\frac{1}{16}$.\nFor matches, the score is $s(a,b) = +1$. The first sum becomes:\n$$ \\sum_{a=b} p_{a} p_{b} \\exp(\\lambda s(a,b)) = 4 \\times \\left( \\frac{1}{16} \\exp(\\lambda \\cdot 1) \\right) = \\frac{4}{16} \\exp(\\lambda) = \\frac{1}{4} \\exp(\\lambda) $$\nFor mismatches, the score is $s(a,b) = -3$. The second sum becomes:\n$$ \\sum_{a \\neq b} p_{a} p_{b} \\exp(\\lambda s(a,b)) = 12 \\times \\left( \\frac{1}{16} \\exp(\\lambda \\cdot (-3)) \\right) = \\frac{12}{16} \\exp(-3\\lambda) = \\frac{3}{4} \\exp(-3\\lambda) $$\nSubstituting these expressions back into the main equation yields:\n$$ \\frac{1}{4} \\exp(\\lambda) + \\frac{3}{4} \\exp(-3\\lambda) = 1 $$\nTo solve for $\\lambda$, we can multiply the entire equation by $4$:\n$$ \\exp(\\lambda) + 3 \\exp(-3\\lambda) = 4 $$\nLet $x = \\exp(\\lambda)$. Since we are seeking a positive $\\lambda$, we must have $x > 1$. The equation transforms into an algebraic equation in terms of $x$:\n$$ x + 3x^{-3} = 4 $$\nMultiplying by $x^3$ (which is non-zero) to clear the negative exponent gives a polynomial equation:\n$$ x^4 + 3 = 4x^3 $$\nRearranging into standard form:\n$$ x^4 - 4x^3 + 3 = 0 $$\nWe seek the roots of this quartic polynomial. By the rational root theorem, any rational root must be a divisor of the constant term $3$. The possible rational roots are $\\pm 1$ and $\\pm 3$.\nTesting $x=1$:\n$$ (1)^4 - 4(1)^3 + 3 = 1 - 4 + 3 = 0 $$\nSo, $x=1$ is a root. This corresponds to $\\lambda = \\ln(1) = 0$, which is the trivial solution that always exists when $\\sum p_a p_b = 1$. We are interested in the unique *positive* solution for $\\lambda$, which corresponds to $x > 1$.\nSince $x=1$ is a root, $(x-1)$ is a factor of the polynomial. We perform polynomial division:\n$$ \\frac{x^4 - 4x^3 + 3}{x-1} = x^3 - 3x^2 - 3x - 3 $$\nThus, the equation becomes:\n$$ (x-1)(x^3 - 3x^2 - 3x - 3) = 0 $$\nThe non-trivial roots are the solutions to the cubic equation:\n$$ P(x) = x^3 - 3x^2 - 3x - 3 = 0 $$\nThis equation does not have simple rational roots. We must find the relevant root numerically. Let's analyze the function $P(x)$ to locate the root we seek. We found that $P(3) = (3)^3 - 3(3)^2 - 3(3) - 3 = 27 - 27 - 9 - 3 = -12$ and $P(4) = (4)^3 - 3(4)^2 - 3(4) - 3 = 64 - 48 - 12 - 3 = 1$.\nSince $P(3) < 0$ and $P(4) > 0$, and $P(x)$ is continuous, there is a root between $3$ and $4$. As this root is greater than $1$, it will give the required positive $\\lambda$. Using a numerical method, such as Newton's method or a computational solver, we find the root to be:\n$$ x \\approx 3.9526368 $$\nNow, we solve for $\\lambda$ using the relation $x = \\exp(\\lambda)$:\n$$ \\lambda = \\ln(x) = \\ln(3.9526368) $$\n$$ \\lambda \\approx 1.374333 $$\nThe problem requires the answer to be rounded to $4$ significant figures. The first four significant digits are $1, 3, 7, 4$. The following digit is $3$, so we round down.\n$$ \\lambda \\approx 1.374 $$\nThis is the required numerical value.",
            "answer": "$$\n\\boxed{1.374}\n$$"
        },
        {
            "introduction": "Heuristic algorithms trade guaranteed accuracy for speed, meaning they can sometimes miss important similarities. Understanding these failure modes is crucial for expert use of tools like BLAST. This exercise  challenges you to computationally construct an 'anti-BLAST' sequence pair—one with a high-scoring alignment that is invisible to a word-based seeding strategy—thereby exposing the core speed-sensitivity trade-off.",
            "id": "2396847",
            "problem": "You must write a complete, runnable program that computes, for each specified parameter set, the minimal alignment length required to produce a high-scoring local alignment that is not detected by a simplified word-based seeding heuristic.\n\nDefinitions. Consider two deoxyribonucleic acid (DNA) sequences over the alphabet $\\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{T}\\}$. Let $X$ and $Y$ be two sequences, and let a local alignment between substrings of $X$ and $Y$ be scored by the Smith–Waterman scheme with an affine gap model: a match contributes $+m$, a mismatch contributes $-\\mu$, and a single contiguous gap of length $\\ell$ contributes a penalty of $-(g + e \\cdot (\\ell - 1))$, where $m > 0$, $\\mu \\ge 0$, $g \\ge 0$, and $e \\ge 0$. The optimal local alignment score $S^{\\star}(X,Y)$ is the maximum score over all local alignments between substrings of $X$ and $Y$.\n\nHeuristic detection rule. Model a Basic Local Alignment Search Tool (BLAST)-like word-based seeding heuristic with a fixed word length $w \\in \\mathbb{N}$. The heuristic is said to detect a pair $(X,Y)$ if and only if the optimal local alignment between $X$ and $Y$ contains at least one contiguous run of matches of length at least $w$. A pair $(X,Y)$ is anti-seed if the heuristic does not detect it, i.e., no contiguous run of matches of length at least $w$ occurs inside the optimal local alignment.\n\nTask. For a given parameter set $(w,m,\\mu,g,e,S_{\\min})$, define $L^{\\ast}$ to be the minimal possible number of alignment columns (counting every aligned column, whether it is a match, a mismatch, or a gap) among all pairs $(X,Y)$ such that:\n- the optimal local alignment score satisfies $S^{\\star}(X,Y) \\ge S_{\\min}$, and\n- the pair $(X,Y)$ is anti-seed under the heuristic rule above.\n\nIf there exists no such pair, define $L^{\\ast} = -1$.\n\nYour program must compute $L^{\\ast}$ for each of the following parameter sets and output the sequence of results in order:\n\n- Case $1$: $w=3$, $m=2$, $\\mu=1$, $g=5$, $e=1$, $S_{\\min}=10$.\n- Case $2$: $w=4$, $m=2$, $\\mu=1$, $g=5$, $e=1$, $S_{\\min}=3$.\n- Case $3$: $w=5$, $m=1$, $\\mu=5$, $g=10$, $e=2$, $S_{\\min}=5$.\n- Case $4$: $w=6$, $m=2$, $\\mu=3$, $g=8$, $e=1$, $S_{\\min}=31$.\n- Case $5$: $w=2$, $m=2$, $\\mu=1$, $g=5$, $e=1$, $S_{\\min}=5$.\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3,r_4,r_5]$), where each $r_i$ is the integer $L^{\\ast}$ for Case $i$ in the order given, or $-1$ if no such pair exists for that case. No additional text should be printed.",
            "solution": "The problem asks for the minimal alignment length $L^{\\ast}$ required to achieve a local alignment score of at least $S_{\\min}$, under the constraint that the alignment is \"anti-seed\". An anti-seed alignment is one where any contiguous run of matches has a length strictly less than a given word size $w$.\n\nFirst, we must correctly interpret the problem statement, specifically the condition that \"the optimal local alignment between $X$ and $Y$\" is anti-seed. A naive interpretation would require us to design sequences $X$ and $Y$ and then verify that our constructed anti-seed alignment is indeed the highest-scoring one among all possible local alignments, including those that may contain match runs of length $\\ge w$. This verification is a formidable task. However, the problem becomes tractable if we recognize that we can construct the sequences $X$ and $Y$ in such a way that no alignment containing a run of $w$ or more matches is possible. For instance, if we construct sequences $X$ and $Y$ from an alphabet like $\\{\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{T}\\}$ such that no substring of length $w$ is a homopolymer (e.g., $\\mathrm{A}^w$), then it is impossible to form an alignment with $w$ consecutive matches of the same character. By appropriately choosing non-matching characters, we can ensure that our designed anti-seed alignment is, by construction, the optimal one for those specific sequences. Therefore, the problem simplifies to finding the minimal length of a realizable anti-seed alignment that achieves the target score $S_{\\min}$.\n\nThis is a classic dynamic programming problem. We seek to find the minimum length $L$ for which the maximum possible score of an anti-seed alignment of that length, let's call it $S_{\\text{max}}(L)$, satisfies $S_{\\text{max}}(L) \\ge S_{\\min}$. We can iteratively compute $S_{\\text{max}}(i)$ for $i=1, 2, 3, \\dots$ and stop at the first $i$ that meets the score requirement.\n\nTo structure the dynamic programming, we must distinguish between alignments that end in a match column and those that end in a non-match column (a \"breaker\"). This is because a new match run can only start after a breaker. Let us define two states for our DP:\n1. $S_M(i)$: The maximum score for an anti-seed alignment of length $i$ that ends with a match.\n2. $S_B(i)$: The maximum score for an anti-seed alignment of length $i$ that ends with a breaker (a mismatch or a gap column).\n\nThe overall maximum score for an alignment of length $i$ is then $dp[i] = \\max(S_M(i), S_B(i))$. We initialize $dp[0] = 0$, representing a zero-length alignment with zero score, which can be considered to end in a \"breaker\" state, so $S_B(0)=0$. All other DP table entries are initialized to $-\\infty$.\n\nThe recurrence relations for $i > 0$ are as follows:\n\n1.  To compute $S_M(i)$: An alignment of length $i$ ending in a match must consist of a preceding alignment of length $i-k$ that ends in a breaker, followed by a run of $k$ matches. The anti-seed constraint dictates that $1 \\le k < w$.\n    $$S_M(i) = \\max_{1 \\le k < w, i \\ge k} \\{ S_B(i-k) + k \\cdot m \\}$$\n\n2.  To compute $S_B(i)$: An alignment of length $i$ ending in a breaker can be formed in several ways. It could be an alignment of length $i-1$ followed by a mismatch, or an alignment of length $i-\\ell$ followed by a gap of length $\\ell$.\n    - If it ends in a mismatch (length $1$, score $-\\mu$): the score is $dp[i-1] - \\mu$.\n    - If it ends in a gap: This is more complex. A gap of length $\\ell$ ending at $i$ adds a penalty of $-(g + e(\\ell-1))$ to the score of the alignment at length $i-\\ell$. To handle this efficiently, we introduce a helper DP state, $S_{\\text{GapEnd}}(i)$, for the maximum score of an alignment of length $i$ ending in a gap column. This can be computed with the recurrence $S_{\\text{GapEnd}}(i) = \\max(dp[i-1] - g, S_{\\text{GapEnd}}(i-1) - e)$, which considers opening a new gap or extending an existing one.\n    Combining these, the recurrence for $S_B(i)$ is:\n    $$S_B(i) = \\max(dp[i-1] - \\mu, S_{\\text{GapEnd}}(i))$$\n\nWe iterate through lengths $i=1, 2, \\dots$ up to a reasonable maximum length $L_{\\text{max}}$. For each $i$, we compute $S_{\\text{GapEnd}}(i)$, $S_B(i)$, $S_M(i)$, and finally $dp[i]$. The first value of $i$ for which $dp[i] \\ge S_{\\min}$ is our minimal length $L^{\\ast}$.\n\nA special case arises if $S_{\\min}$ is unreachable. This occurs if the maximum possible score is less than $S_{\\min}$. The highest score density is achieved by composing runs of $w-1$ matches with the most efficient (least penalizing) breaker. If the score contribution of such optimal repeating units is non-positive, and the score from a single maximal match run, $(w-1)m$, is less than $S_{\\min}$, then the target score can never be reached. This condition, $\\left( (w-1)m < S_{\\min} \\right) \\land \\left( (w-1)m - \\min(\\mu,g) \\le 0 \\right)$, serves as a strong indicator that no solution exists, in which case $L^{\\ast} = -1$. Our DP naturally handles this, as the score $dp[i]$ will fail to increase towards $S_{\\min}$. If the loop completes without finding a solution, the result is $-1$.\n\nThe final algorithm is as follows:\nFor each parameter set:\n1.  Perform the check for trivial non-existence.\n2.  Initialize DP arrays $dp$, $S_M$, $S_B$, and $S_{\\text{GapEnd}}$. Set $dp[0]=0$ and $S_B[0]=0$.\n3.  Iterate $i$ from $1$ to $L_{\\text{max}}$. In each step, compute $S_{\\text{GapEnd}}(i)$, $S_B(i)$, $S_M(i)$, and $dp[i]$ using the recurrences.\n4.  If $dp[i] \\ge S_{\\min}$, then $L^{\\ast}=i$; terminate and return $i$.\n5.  If the loop finishes, no solution was found; return $-1$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve for all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # (w, m, mu, g, e, S_min)\n        (3, 2, 1, 5, 1, 10),\n        (4, 2, 1, 5, 1, 3),\n        (5, 1, 5, 10, 2, 5),\n        (6, 2, 3, 8, 1, 31),\n        (2, 2, 1, 5, 1, 5),\n    ]\n\n    results = []\n    for params in test_cases:\n        w, m, mu, g, e, S_min = params\n        result = compute_l_star(w, m, mu, g, e, S_min)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_l_star(w, m, mu, g, e, S_min):\n    \"\"\"\n    Computes the minimal alignment length L* for a given parameter set.\n    \"\"\"\n    if S_min <= 0:\n        return 0\n\n    # If w=1, no match runs are allowed (max length is <1).\n    # If S_min > 0, it's impossible to achieve with only non-positive scores\n    # from mismatches/gaps.\n    if w == 1:\n        return -1\n    \n    # A necessary condition for a solution to exist when S_min > (w-1)*m\n    # is that it must be possible to increase the score by adding blocks.\n    # The most score-efficient repeating unit is a run of w-1 matches\n    # followed by the best single-column breaker (mismatch or gap of 1).\n    # If this unit's score contribution is not positive, S_min is unreachable.\n    max_score_single_block = (w - 1) * m\n    best_breaker_penalty = min(mu, g)\n    if max_score_single_block < S_min and (max_score_single_block - best_breaker_penalty) <= 0:\n        # A more thorough check would also consider longer gaps, but this covers most cases.\n        # If (w-1)m - g <= 0, then (w-1)m - (g+e(l-1)) <= 0 for l>1.\n        return -1\n\n    # Set a sufficiently large max length to search.\n    L_max = 500\n    neg_inf = -1e18 # Use a large negative number for -infinity\n\n    # dp[i] = max score for an anti-seed alignment of length i\n    dp = np.full(L_max + 1, neg_inf, dtype=np.float64)\n    # S_M[i] = max score for length i, ending in a Match\n    S_M = np.full(L_max + 1, neg_inf, dtype=np.float64)  \n    # S_B[i] = max score for length i, ending in a Breaker (Mismatch/Gap)\n    S_B = np.full(L_max + 1, neg_inf, dtype=np.float64)  \n    # S_GapEnd[i] = max score for length i, ending in a Gap\n    S_GapEnd = np.full(L_max + 1, neg_inf, dtype=np.float64)\n\n    # Base case: alignment of length 0 has score 0 and ends in a \"breaker\" state.\n    dp[0] = 0.0\n    S_B[0] = 0.0\n\n    for i in range(1, L_max + 1):\n        # Max score ending in a gap: from opening a new gap or extending an old one.\n        gap_open_score = dp[i-1] - g\n        gap_extend_score = S_GapEnd[i-1] - e\n        S_GapEnd[i] = max(gap_open_score, gap_extend_score)\n\n        # Max score ending in a breaker: from adding a mismatch or ending in a gap.\n        mismatch_score = dp[i-1] - mu\n        S_B[i] = max(mismatch_score, S_GapEnd[i])\n        \n        # Max score ending in a match: add a run of k matches after a breaker.\n        max_sm_score = neg_inf\n        for k in range(1, w):\n            if i >= k:\n                prev_score = S_B[i-k]\n                if prev_score > neg_inf:\n                   current_sm_score = prev_score + k * m\n                   if current_sm_score > max_sm_score:\n                       max_sm_score = current_sm_score\n        S_M[i] = max_sm_score\n\n        # Overall max score is the maximum of the substates.\n        dp[i] = max(S_M[i], S_B[i])\n\n        if dp[i] >= S_min:\n            return i\n            \n    return -1\n\nsolve()\n```"
        }
    ]
}