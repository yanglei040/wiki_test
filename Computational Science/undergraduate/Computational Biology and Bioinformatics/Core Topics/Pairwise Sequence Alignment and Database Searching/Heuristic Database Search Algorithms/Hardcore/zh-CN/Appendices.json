{
    "hands_on_practices": [
        {
            "introduction": "虽然连续的词匹配（contiguous word matches）概念简单，但它们可能会错过那些保守残基被非保守残基隔开的同源区域。为了克服这一限制，研究人员提出了非连续或间隔种子（discontiguous or spaced seeds）作为一种更强大的替代方案。通过这个编码练习，你将亲手实现并比较间隔种子与连续种子的检测性能，从而直观地理解种子设计的精妙之处及其对搜索灵敏度的影响。",
            "id": "2396841",
            "problem": "给定一个基于种子的序列相似性检测的形式化模型，该模型旨在评估非连续词种子（也称间隔种子）与连续种子在检测潜在远缘蛋白质同源体方面的效用。假设一个蛋白质序列是在标准的 $20$ 符号氨基酸字母表上的一个有限字符串。一个二进制种子模式是一个长度为 $L$ 的有限二进制字符串，记为 $b_0 b_1 \\dots b_{L-1}$，其中对于每个索引 $j$，$b_j \\in \\{0,1\\}$。种子的权重 $w$ 是 $b_j = 1$ 的位置 $j$ 的数量。如果在两个等长序列 $Q$ 和 $T$ 之间存在一个索引 $i$，使得对于所有满足 $b_j = 1$ 的 $j \\in \\{0,1,\\dots,L-1\\}$，都有 $Q[i+j] = T[i+j]$，那么就发生了一次种子命中。非连续种子是任何不全是1的种子；权重为 $w$ 的连续种子是 $L = w$ 且 $b_0 = b_1 = \\dots = b_{w-1} = 1$ 的特殊情况。\n\n对于给定的序列对 $(Q,T)$，定义种子模式 $b$ 的检测决策为一个布尔值 $D(b;Q,T)$，当且仅当存在一个索引 $i$（$0 \\le i \\le |Q|-L$）满足上述种子命中条件时，该值为 $\\mathrm{true}$，否则为 $\\mathrm{false}$。所有序列索引都是从0开始的，并且所考虑的唯一比对是共线、索引对齐的窗口，这意味着在 $Q$ 和 $T$ 之间不允许有任何间隙或偏移。如果 $|Q| \\ne |T|$ 或者 $|Q|  L$，那么 $D(b;Q,T)$ 被定义为 $\\mathrm{false}$。\n\n固定非连续种子模式 $p = 1101001$，其长度为 $L = 7$，权重为 $w = 4$。定义相应的公平连续比较种子 $c$ 为权重为 $w$ 的连续种子，因此 $c = 1111$，长度为 $4$。\n\n对于每个测试对 $(Q,T)$，根据以下规则将比较优势值 $A(Q,T)$ 定义为一个整数：\n- 如果 $D(p;Q,T) = \\mathrm{true}$ 且 $D(c;Q,T) = \\mathrm{false}$，则 $A(Q,T) = 1$，\n- 如果 $D(p;Q,T) = \\mathrm{false}$ 且 $D(c;Q,T) = \\mathrm{true}$，则 $A(Q,T) = -1$，\n- 其他情况下，$A(Q,T) = 0$。\n\n你的任务是为以下每个测试用例计算 $A(Q,T)$。在每个案例中，两个序列都基于标准的20个氨基酸字母表，并且长度相同。种子模式 $p$ 始终为 $1101001$，比较连续种子 $c$ 始终为 $1111$。\n\n测试套件：\n- 案例1（类远缘同源体，预期仅间隔种子能检测到）：\n  - $Q_1$ = MKTAYIAKQRQISFVKSHFS\n  - $T_1$ = LLLLLIALQLLILLLLLLLL\n- 案例2（完全相同，预期两种种子都能检测到）：\n  - $Q_2$ = ACDEFGHIKL\n  - $T_2$ = ACDEFGHIKL\n- 案例3（完全不匹配，预期两种种子都检测不到）：\n  - $Q_3$ = AAAAAAAAAAAAAAA\n  - $T_3$ = CCCCCCCCCCCCCCC\n- 案例4（在 $L=7$ 的窗口内有局部连续匹配但无间隔模式匹配，预期仅连续种子能检测到）：\n  - $Q_4$ = ABCDEFG\n  - $T_4$ = MNCDEFP\n- 案例5（边界长度短于 $L=7$，可能仅连续种子能检测到）：\n  - $Q_5$ = ACDE\n  - $T_5$ = ACDE\n\n你的程序必须计算列表 $[A(Q_1,T_1), A(Q_2,T_2), A(Q_3,T_3), A(Q_4,T_4), A(Q_5,T_5)]$，并生成一行输出，其中包含用方括号括起来的逗号分隔的结果列表，例如 $[x_1,x_2,x_3,x_4,x_5]$，其中每个 $x_k$ 是 $\\{-1,0,1\\}$ 中的一个整数。",
            "solution": "所提出的问题要求使用两种不同的种子模式——一个非连续（或间隔）种子和一个连续种子——来计算蛋白质序列对 $(Q,T)$ 的比较优势值，记为 $A(Q,T)$。该问题在科学上基于启发式序列相似性搜索的原理，这是生物信息学中的一个基本概念。所有定义都是精确的，问题是适定的。我们将进行系统性的、逐个案例的分析。\n\n首先，让我们形式化给定的定义。\n\n对于一个长度为 $L$ 的二进制种子模式 $b$，如果在两个序列 $Q$ 和 $T$ 之间存在一个起始索引 $i$（$0 \\le i \\le |Q|-L$），使得对于每个满足 $b_j=1$ 的位置 $j \\in \\{0, 1, \\dots, L-1\\}$，条件 $Q[i+j] = T[i+j]$ 都成立，则发生了一次种子命中。\n\n检测决策函数 $D(b;Q,T)$ 定义如下：\n- 如果在 $Q$ 和 $T$ 之间存在模式 $b$ 的种子命中，则 $D(b;Q,T) = \\mathrm{true}$。\n- 如果不存在种子命中，则 $D(b;Q,T) = \\mathrm{false}$。\n- 根据定义，如果 $|Q| \\ne |T|$ 或 $|Q|  L$，则 $D(b;Q,T) = \\mathrm{false}$。\n\n两个种子模式是固定的：\n1. 非连续种子模式是 $p = 1101001$。其长度为 $L_p = 7$，权重（1的数量）为 $w=4$。在长度为7的窗口内，要求匹配的位置是相对索引 $0, 1, 3$ 和 $6$。\n2. 公平连续比较种子是 $c = 1111$。其长度为 $L_c = 4$，权重为 $w=4$。这要求一个长度为4的连续匹配字符块。\n\n比较优势值 $A(Q,T)$ 是一个由两个检测函数的结果决定的整数：\n- 如果 $D(p;Q,T)=\\mathrm{true}$ 且 $D(c;Q,T)=\\mathrm{false}$，则 $A(Q,T) = 1$。\n- 如果 $D(p;Q,T)=\\mathrm{false}$ 且 $D(c;Q,T)=\\mathrm{true}$，则 $A(Q,T) = -1$。\n- 如果 $D(p;Q,T)=D(c;Q,T)$（即两者都为真或都为假），则 $A(Q,T) = 0$。\n\n我们现在将为每个测试用例 $k=1, \\dots, 5$ 计算 $A(Q_k,T_k)$。\n\n**案例1：**\n-   $Q_1$ = `MKTAYIAKQRQISFVKSHFS` ($|Q_1|=20$)\n-   $T_1$ = `LLLLLIALQLLILLLLLLLL` ($|T_1|=20$)\n-   两个序列的长度均为20，大于 $L_p=7$ 和 $L_c=4$。\n\n- **$D(p; Q_1, T_1)$ 的评估：**\n  我们必须搜索一个长度为7的窗口，起始索引为 $i$（$0 \\le i \\le 13$），其中对于 $j \\in \\{0, 1, 3, 6\\}$，$Q_1[i+j]=T_1[i+j]$。\n  让我们测试从 $i=5$ 开始的窗口：\n  $Q_1$ 中的窗口是 $Q_1[5 \\dots 11]$ = `IAKQRQI`。\n  $T_1$ 中的窗口是 $T_1[5 \\dots 11]$ = `IALQLLI`。\n  我们来检查所需的位置：\n  -   $j=0$：$Q_1[5] = \\text{'I'}$，$T_1[5] = \\text{'I'}$。匹配。\n  -   $j=1$：$Q_1[6] = \\text{'A'}$，$T_1[6] = \\text{'A'}$。匹配。\n  -   $j=3$：$Q_1[8] = \\text{'Q'}$，$T_1[8] = \\text{'Q'}$。匹配。\n  -   $j=6$：$Q_1[11] = \\text{'I'}$，$T_1[11] = \\text{'I'}$。匹配。\n  在 $i=5$ 处找到一个命中。因此，$D(p; Q_1, T_1) = \\mathrm{true}$。\n\n- **$D(c; Q_1, T_1)$ 的评估：**\n  我们必须搜索一个长度为 $L_c=4$ 的公共连续子串。系统性搜索显示 $Q_1$ 和 $T_1$ 之间没有这样的公共子串。因此，$D(c; Q_1, T_1) = \\mathrm{false}$。\n\n- **$A(Q_1, T_1)$ 的计算：**\n  由于 $D(p; Q_1, T_1) = \\mathrm{true}$ 且 $D(c; Q_1, T_1) = \\mathrm{false}$，我们得到 $A(Q_1, T_1) = 1$。\n\n**案例2：**\n-   $Q_2$ = `ACDEFGHIKL` ($|Q_2|=10$)\n-   $T_2$ = `ACDEFGHIKL` ($|T_2|=10$)\n-   序列完全相同。长度为10，大于 $L_p=7$ 和 $L_c=4$。\n\n- **$D(p; Q_2, T_2)$ 的评估：**\n  由于对所有 $j$ 都有 $Q_2[j]=T_2[j]$，任何有效的窗口都会导致命中。对于 $i=0$，条件 $Q_2[0]=T_2[0]$, $Q_2[1]=T_2[1]$, $Q_2[3]=T_2[3]$ 和 $Q_2[6]=T_2[6]$ 自然满足。因此，$D(p; Q_2, T_2) = \\mathrm{true}$。\n\n- **$D(c; Q_2, T_2)$ 的评估：**\n  同样地，对于任何长度为4的窗口，比如在 $i=0$ 处，我们有 $Q_2[0 \\dots 3] = T_2[0 \\dots 3]$。命中是保证的。因此，$D(c; Q_2, T_2) = \\mathrm{true}$。\n\n- **$A(Q_2, T_2)$ 的计算：**\n  由于两个检测函数都为真，$A(Q_2, T_2) = 0$。\n\n**案例3：**\n-   $Q_3$ = `AAAAAAAAAAAAAAA` ($|Q_3|=15$)\n-   $T_3$ = `CCCCCCCCCCCCCCC` ($|T_3|=15$)\n-   序列长度为15，对两个种子都足够。\n\n- **$D(p; Q_3, T_3)$ 的评估：**\n  对于任何索引 $j$，$Q_3[j] = \\text{'A'}$ 且 $T_3[j] = \\text{'C'}$。由于对所有 $j$ 都有 $Q_3[j] \\ne T_3[j]$，所以在任何位置都不可能匹配。因此，不可能发生种子命中。$D(p; Q_3, T_3) = \\mathrm{false}$。\n\n- **$D(c; Q_3, T_3)$ 的评估：**\n  出于同样的原因，不存在连续的匹配字符块。$D(c; Q_3, T_3) = \\mathrm{false}$。\n\n- **$A(Q_3, T_3)$ 的计算：**\n  由于两个检测函数都为假，$A(Q_3, T_3) = 0$。\n\n**案例4：**\n-   $Q_4$ = `ABCDEFG` ($|Q_4|=7$)\n-   $T_4$ = `MNCDEFP` ($|T_4|=7$)\n-   序列长度为7，对两个种子都足够（$7 \\ge 7$ 且 $7 \\ge 4$）。\n\n- **$D(p; Q_4, T_4)$ 的评估：**\n  唯一可能的窗口是整个序列，从 $i=0$ 开始，因为 $|Q_4|-L_p = 7-7=0$。我们检查所需的匹配位置 $\\{0, 1, 3, 6\\}$：\n  -   $j=0$：$Q_4[0] = \\text{'A'}$，$T_4[0] = \\text{'M'}$。不匹配。\n  没有发生命中。因此，$D(p; Q_4, T_4) = \\mathrm{false}$。\n\n- **$D(c; Q_4, T_4)$ 的评估：**\n  我们搜索长度为4的公共连续子串。可能的起始索引是 $i \\in \\{0, 1, 2, 3\\}$。\n  -   $i=0$：`ABCD` 与 `MNCD`。不匹配。\n  -   $i=1$：`BCDE` 与 `NCDE`。不匹配。\n  -   $i=2$：`CDEF` 与 `CDEF`。找到匹配。\n  找到了一个命中。因此，$D(c; Q_4, T_4) = \\mathrm{true}$。\n\n- **$A(Q_4, T_4)$ 的计算：**\n  由于 $D(p; Q_4, T_4) = \\mathrm{false}$ 且 $D(c; Q_4, T_4) = \\mathrm{true}$，我们得到 $A(Q_4, T_4) = -1$。\n\n**案例5：**\n-   $Q_5$ = `ACDE` ($|Q_5|=4$)\n-   $T_5$ = `ACDE` ($|T_5|=4$)\n-   序列长度为4。\n\n- **$D(p; Q_5, T_5)$ 的评估：**\n  种子长度为 $L_p=7$。序列长度为 $|Q_5|=4$。由于 $|Q_5|  L_p$，根据定义，$D(p; Q_5, T_5) = \\mathrm{false}$。\n\n- **$D(c; Q_5, T_5)$ 的评估：**\n  种子长度为 $L_c=4$。序列长度为 $|Q_5|=4$。由于 $|Q_5| \\ge L_c$（$4 \\ge 4$），我们继续。唯一可能的窗口从 $i=0$ 开始。由于 $Q_5$ 和 $T_5$ 完全相同，窗口 $Q_5[0 \\dots 3]$ 与 $T_5[0 \\dots 3]$ 匹配。找到了一个命中。因此，$D(c; Q_5, T_5) = \\mathrm{true}$。\n\n- **$A(Q_5, T_5)$ 的计算：**\n  由于 $D(p; Q_5, T_5) = \\mathrm{false}$ 且 $D(c; Q_5, T_5) = \\mathrm{true}$，我们得到 $A(Q_5, T_5) = -1$。\n\n**最终结果总结：**\n计算出的值为：\n-   $A(Q_1, T_1) = 1$\n-   $A(Q_2, T_2) = 0$\n-   $A(Q_3, T_3) = 0$\n-   $A(Q_4, T_4) = -1$\n-   $A(Q_5, T_5) = -1$\n\n最终列表为 $[1, 0, 0, -1, -1]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\n# No external libraries are necessary for this problem.\n\ndef detect_hit(Q, T, seed_pattern):\n    \"\"\"\n    Determines if a seed hit occurs between two sequences for a given seed pattern.\n\n    Args:\n        Q (str): The query sequence.\n        T (str): The target sequence.\n        seed_pattern (str): The binary seed pattern (e.g., '1101001').\n\n    Returns:\n        bool: True if a hit is found, False otherwise.\n    \"\"\"\n    len_Q = len(Q)\n    len_T = len(T)\n    len_L = len(seed_pattern)\n\n    # Per problem definition, D(b;Q,T) is false if lengths are unequal or Q is too short.\n    if len_Q != len_T or len_Q  len_L:\n        return False\n\n    # Extract the indices that must match (where seed pattern is '1').\n    match_indices = [j for j, bit in enumerate(seed_pattern) if bit == '1']\n\n    # Iterate through all possible start positions 'i' for the seed window.\n    for i in range(len_Q - len_L + 1):\n        is_hit = True\n        # Check if all required positions in the window match.\n        for j in match_indices:\n            if Q[i + j] != T[i + j]:\n                is_hit = False\n                break  # Mismatch found, this window is not a hit.\n        \n        if is_hit:\n            return True  # A hit was found, no need to search further.\n\n    # If the loop completes without finding any hit, return False.\n    return False\n\ndef calculate_A(Q, T, p_pattern, c_pattern):\n    \"\"\"\n    Computes the comparative advantage value A(Q, T).\n\n    Args:\n        Q (str): The query sequence.\n        T (str): The target sequence.\n        p_pattern (str): The discontiguous seed pattern.\n        c_pattern (str): The contiguous seed pattern.\n\n    Returns:\n        int: The comparative advantage value (-1, 0, or 1).\n    \"\"\"\n    d_p = detect_hit(Q, T, p_pattern)\n    d_c = detect_hit(Q, T, c_pattern)\n    \n    if d_p and not d_c:\n        return 1\n    elif not d_p and d_c:\n        return -1\n    else: # This covers cases where both are True or both are False.\n        return 0\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # The fixed seed patterns from the problem statement.\n    p_pattern = '1101001'\n    c_pattern = '1111'\n\n    # The test suite provided in the problem statement.\n    test_cases = [\n        # Case 1\n        (\"MKTAYIAKQRQISFVKSHFS\", \"LLLLLIALQLLILLLLLLLL\"),\n        # Case 2\n        (\"ACDEFGHIKL\", \"ACDEFGHIKL\"),\n        # Case 3\n        (\"AAAAAAAAAAAAAAA\", \"CCCCCCCCCCCCCCC\"),\n        # Case 4\n        (\"ABCDEFG\", \"MNCDEFP\"),\n        # Case 5\n        (\"ACDE\", \"ACDE\"),\n    ]\n\n    results = []\n    for Q, T in test_cases:\n        result = calculate_A(Q, T, p_pattern, c_pattern)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在了解了如何改进种子策略后，我们同样需要认识到启发式算法的内在局限性。这个高级实践要求你逆向思考速度与灵敏度之间的权衡，去构建一个得分很高但会被基于词的启发式算法系统性地错过的序列比对。通过解决这个动态规划问题，你将深刻体会到为何没有一种启发式算法是完美的，并理解其“捷径”所带来的代价。",
            "id": "2396847",
            "problem": "您必须编写一个完整、可运行的程序，为每个指定的参数集计算产生一个高分局部比对所需的最小比对长度，该比对不被一种简化的基于词的种子启发式算法所检测。\n\n定义。考虑两条基于字母表 $\\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{T}\\}$ 的脱氧核糖核酸（DNA）序列。设 $X$ 和 $Y$ 为两条序列，$X$ 和 $Y$ 子串间的局部比对采用带仿射罚分模型的 Smith–Waterman 方案进行评分：一次匹配贡献 $+m$，一次错配贡献 $-\\mu$，一个长度为 $\\ell$ 的连续空位贡献罚分 $-(g + e \\cdot (\\ell - 1))$，其中 $m  0$、$\\mu \\ge 0$、$g \\ge 0$ 且 $e \\ge 0$。最佳局部比对分数 $S^{\\star}(X,Y)$ 是 $X$ 和 $Y$ 子串之间所有局部比对的最高分。\n\n启发式检测规则。模拟一种类似基本局部比对搜索工具（BLAST）的、具有固定词长 $w \\in \\mathbb{N}$ 的基于词的种子启发式算法。当且仅当 $X$ 和 $Y$ 之间的最佳局部比对包含至少一个长度不小于 $w$ 的连续匹配时，称该启发式算法检测到一对序列 $(X,Y)$。如果启发式算法没有检测到一对序列 $(X,Y)$，则称其为反种子的（anti-seed），即最佳局部比对内部没有出现长度不小于 $w$ 的连续匹配。\n\n任务。对于一个给定的参数集 $(w,m,\\mu,g,e,S_{\\min})$，定义 $L^{\\ast}$ 为在所有满足以下条件的序列对 $(X,Y)$ 中，可能的最小比对列数（计算每一个比对列，无论是匹配、错配还是空位）：\n- 最佳局部比对分数满足 $S^{\\star}(X,Y) \\ge S_{\\min}$，且\n- 该序列对 $(X,Y)$ 在上述启发式规则下是反种子的。\n\n如果不存在这样的序列对，则定义 $L^{\\ast} = -1$。\n\n您的程序必须为以下每个参数集计算 $L^{\\ast}$，并按顺序输出结果序列：\n\n- 情况1：$w=3$，$m=2$，$\\mu=1$，$g=5$，$e=1$，$S_{\\min}=10$。\n- 情况2：$w=4$，$m=2$，$\\mu=1$，$g=5$，$e=1$，$S_{\\min}=3$。\n- 情况3：$w=5$，$m=1$，$\\mu=5$，$g=10$，$e=2$，$S_{\\min}=5$。\n- 情况4：$w=6$，$m=2$，$\\mu=3$，$g=8$，$e=1$，$S_{\\min}=31$。\n- 情况5：$w=2$，$m=2$，$\\mu=1$，$g=5$，$e=1$，$S_{\\min}=5$。\n\n最终输出格式。您的程序应产生单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，$[r_1,r_2,r_3,r_4,r_5]$），其中每个 $r_i$ 是按给定顺序排列的情况 $i$ 的整数 $L^{\\ast}$，如果该情况不存在这样的序列对，则为 $-1$。不应打印任何额外文本。",
            "solution": "该问题要求在比对是“反种子”（anti-seed）的约束下，达到至少为 $S_{\\min}$ 的局部比对分数所需的最小比对长度 $L^{\\ast}$。反种子比对是指其中任何连续匹配的长度都严格小于给定词长 $w$ 的比对。\n\n首先，我们必须正确解读问题陈述，特别是“$X$ 和 $Y$ 之间的最佳局部比对是反种子的”这一条件。一个朴素的解读会要求我们设计序列 $X$ 和 $Y$，然后验证我们所构造的反种子比对确实是所有可能的局部比对（包括那些可能包含长度 $\\ge w$ 的匹配段）中得分最高的一个。这个验证是一项艰巨的任务。然而，如果我们认识到可以构造出这样的序列 $X$ 和 $Y$，使得任何包含 $w$ 个或更多连续匹配的比对都不可能发生，那么问题就变得易于处理了。例如，如果我们从诸如 $\\{\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{T}\\}$ 的字母表中构造序列 $X$ 和 $Y$，使得没有长度为 $w$ 的子串是同聚物（例如 $\\mathrm{A}^w$），那么就不可能形成具有 $w$ 个相同字符连续匹配的比对。通过适当地选择不匹配的字符，我们可以确保我们设计的反种子比对，就其构造而言，对于这些特定序列就是最佳比对。因此，问题简化为寻找一个能够达到目标分数 $S_{\\min}$ 的、可实现的反种子比对的最小长度。\n\n这是一个经典的动态规划问题。我们旨在寻找最小长度 $L$，使得该长度的反种子比对的最大可能分数（我们称之为 $S_{\\text{max}}(L)$）满足 $S_{\\text{max}}(L) \\ge S_{\\min}$。我们可以对 $i=1, 2, 3, \\dots$ 迭代计算 $S_{\\text{max}}(i)$，并在第一个满足分数要求的 $i$ 处停止。\n\n为了构建动态规划，我们必须区分以匹配列结尾的比对和以非匹配列（一个“中断符”(breaker)）结尾的比对。这是因为一个新的匹配段只能在一个中断符之后开始。让我们为我们的动态规划定义两种状态：\n1. $S_M(i)$: 长度为 $i$ 且以匹配结尾的反种子比对的最大分数。\n2. $S_B(i)$: 长度为 $i$ 且以中断符（错配或空位列）结尾的反种子比对的最大分数。\n\n长度为 $i$ 的比对的总体最大分数即为 $dp[i] = \\max(S_M(i), S_B(i))$。我们初始化 $dp[0] = 0$，代表一个零长度、零分数的比对，这可以被认为是以一个“中断符”状态结尾，因此 $S_B(0)=0$。所有其他 DP 表条目均初始化为 $-\\infty$。\n\n对于 $i  0$ 的递推关系如下：\n\n1.  计算 $S_M(i)$：一个长度为 $i$ 且以匹配结尾的比对，必须由一个长度为 $i-k$ 且以中断符结尾的前续比对，后跟一段 $k$ 次匹配组成。反种子约束规定了 $1 \\le k  w$。\n    $$S_M(i) = \\max_{1 \\le k  w, i \\ge k} \\{ S_B(i-k) + k \\cdot m \\}$$\n\n2.  计算 $S_B(i)$：一个长度为 $i$ 且以中断符结尾的比对可以通过几种方式形成。它可以是一个长度为 $i-1$ 的比对后跟一个错配，或者是一个长度为 $i-\\ell$ 的比对后跟一个长度为 $\\ell$ 的空位。\n    - 如果它以错配（长度为1，分数为 $-\\mu$）结尾：分数为 $dp[i-1] - \\mu$。\n    - 如果它以空位结尾：这更复杂。一个在 $i$ 处结束的长度为 $\\ell$ 的空位会为长度为 $i-\\ell$ 的比对分数增加一个 $-(g + e(\\ell-1))$ 的罚分。为了高效地处理这个问题，我们引入一个辅助 DP 状态 $S_{\\text{GapEnd}}(i)$，表示长度为 $i$ 且以空位列结尾的比对的最大分数。这可以通过递推式 $S_{\\text{GapEnd}}(i) = \\max(dp[i-1] - g, S_{\\text{GapEnd}}(i-1) - e)$ 来计算，该递推式考虑了开启一个新空位或扩展一个现有空位。\n    结合这些， $S_B(i)$ 的递推关系是：\n    $$S_B(i) = \\max(dp[i-1] - \\mu, S_{\\text{GapEnd}}(i))$$\n\n我们遍历长度 $i=1, 2, \\dots$ 直到一个合理的最大长度 $L_{\\text{max}}$。对于每个 $i$，我们计算 $S_{\\text{GapEnd}}(i)$、$S_B(i)$、$S_M(i)$，最后计算 $dp[i]$。第一个使 $dp[i] \\ge S_{\\min}$ 成立的 $i$ 值就是我们的最小长度 $L^{\\ast}$。\n\n如果 $S_{\\min}$ 无法达到，会出现一种特殊情况。当可能的最大分数小于 $S_{\\min}$ 时，就会发生这种情况。最高的分数密度是通过将 $w-1$ 次匹配的运行与最有效（罚分最低）的中断符组合来实现的。如果这种最佳重复单元的分数贡献为非正数，并且单个最大匹配运行的分数 $(w-1)m$ 小于 $S_{\\min}$，那么目标分数就永远无法达到。当 $(w-1)m  S_{\\min}$ 且 $(w-1)m - \\min(\\mu,g) \\le 0$ 时，这个条件是一个强有力的指标，表明不存在解，此时 $L^{\\ast} = -1$。我们的动态规划会自然地处理这种情况，因为分数 $dp[i]$ 将无法向 $S_{\\min}$ 增长。如果循环完成而没有找到解，则结果为 $-1$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve for all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # (w, m, mu, g, e, S_min)\n        (3, 2, 1, 5, 1, 10),\n        (4, 2, 1, 5, 1, 3),\n        (5, 1, 5, 10, 2, 5),\n        (6, 2, 3, 8, 1, 31),\n        (2, 2, 1, 5, 1, 5),\n    ]\n\n    results = []\n    for params in test_cases:\n        w, m, mu, g, e, S_min = params\n        result = compute_l_star(w, m, mu, g, e, S_min)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_l_star(w, m, mu, g, e, S_min):\n    \"\"\"\n    Computes the minimal alignment length L* for a given parameter set.\n    \"\"\"\n    if S_min = 0:\n        return 0\n\n    # If w=1, no match runs are allowed (max length is  1).\n    # If S_min > 0, it's impossible to achieve with only non-positive scores\n    # from mismatches/gaps.\n    if w == 1:\n        return -1\n    \n    # A necessary condition for a solution to exist when S_min > (w-1)*m\n    # is that it must be possible to increase the score by adding blocks.\n    # The most score-efficient repeating unit is a run of w-1 matches\n    # followed by the best single-column breaker (mismatch or gap of 1).\n    # If this unit's score contribution is not positive, S_min is unreachable.\n    max_score_single_block = (w - 1) * m\n    best_breaker_penalty = min(mu, g)\n    if max_score_single_block  S_min and (max_score_single_block - best_breaker_penalty) = 0:\n        # A more thorough check would also consider longer gaps, but this covers most cases.\n        # If (w-1)m - g = 0, then (w-1)m - (g+e(l-1))  0 for l>1.\n        return -1\n\n    # Set a sufficiently large max length to search.\n    L_max = 500\n    neg_inf = -1e18 # Use a large negative number for -infinity\n\n    # dp[i] = max score for an anti-seed alignment of length i\n    dp = np.full(L_max + 1, neg_inf, dtype=np.float64)\n    # S_M[i] = max score for length i, ending in a Match\n    S_M = np.full(L_max + 1, neg_inf, dtype=np.float64)  \n    # S_B[i] = max score for length i, ending in a Breaker (Mismatch/Gap)\n    S_B = np.full(L_max + 1, neg_inf, dtype=np.float64)  \n    # S_GapEnd[i] = max score for length i, ending in a Gap\n    S_GapEnd = np.full(L_max + 1, neg_inf, dtype=np.float64)\n\n    # Base case: alignment of length 0 has score 0 and ends in a \"breaker\" state.\n    dp[0] = 0.0\n    S_B[0] = 0.0\n\n    for i in range(1, L_max + 1):\n        # Max score ending in a gap: from opening a new gap or extending an old one.\n        gap_open_score = dp[i-1] - g\n        gap_extend_score = S_GapEnd[i-1] - e\n        S_GapEnd[i] = max(gap_open_score, gap_extend_score)\n\n        # Max score ending in a breaker: from adding a mismatch or ending in a gap.\n        mismatch_score = dp[i-1] - mu\n        S_B[i] = max(mismatch_score, S_GapEnd[i])\n        \n        # Max score ending in a match: add a run of k matches after a breaker.\n        max_sm_score = neg_inf\n        for k in range(1, w):\n            if i >= k:\n                prev_score = S_B[i-k]\n                if prev_score > neg_inf:\n                    current_sm_score = prev_score + k * m\n                    if current_sm_score > max_sm_score:\n                        max_sm_score = current_sm_score\n        S_M[i] = max_sm_score\n\n        # Overall max score is the maximum of the substates.\n        dp[i] = max(S_M[i], S_B[i])\n\n        if dp[i] >= S_min:\n            return i\n            \n    return -1\n\nsolve()\n```"
        },
        {
            "introduction": "当启发式搜索找到了一个有潜力的比对后，我们如何判断其得分是具有生物学意义，还是仅仅源于偶然？最后一个实践将带你回归BLAST的统计学核心，要求你根据给定的打分矩阵，从Karlin-Altschul方程中推导出关键参数 $\\lambda$。这个理论练习将一个抽象的统计概念具象化，让你亲身体验原始比对分数是如何被转化为具有统计意义的评估结果的。",
            "id": "2396829",
            "problem": "考虑在独立同分布 (i.i.d.) 背景模型下，脱氧核糖核酸 (DNA) 字母的随机比对，其碱基频率是均一的，即 $p_{A}=p_{C}=p_{G}=p_{T}=\\frac{1}{4}$。设配对评分方案为：如果 $a=b$（匹配），则 $s(a,b)=+1$；如果 $a \\neq b$（错配），则 $s(a,b)=-3$。在用于无空位局部比对的 Karlin–Altschul 统计框架中，参数 $\\lambda$ 被定义为满足以下方程的唯一正实数：\n$$\n\\sum_{a \\in \\{A,C,G,T\\}} \\sum_{b \\in \\{A,C,G,T\\}} p_{a} p_{b} \\exp\\!\\big(\\lambda\\, s(a,b)\\big) \\;=\\; 1.\n$$\n仅使用此定义以及所述的模型和评分方案，确定 $\\lambda$ 的数值。将您的答案四舍五入到 $4$ 位有效数字。将最终结果表示为一个无单位的无量纲数。",
            "solution": "首先将对问题陈述进行严格的验证过程。\n\n步骤 1：提取已知条件\n问题陈述中提供的明确信息如下：\n- 模型：独立同分布 (i.i.d.) 背景模型下的 DNA 字母随机比对。\n- 碱基频率：$p_{A}=p_{C}=p_{G}=p_{T}=\\frac{1}{4}$。\n- 配对评分方案：如果 $a=b$（匹配），则 $s(a,b)=+1$；如果 $a \\neq b$（错配），则 $s(a,b)=-3$。\n- $\\lambda$ 的定义：满足方程\n$$ \\sum_{a \\in \\{A,C,G,T\\}} \\sum_{b \\in \\{A,C,G,T\\}} p_{a} p_{b} \\exp(\\lambda s(a,b)) = 1 $$\n的唯一正实数。\n- 要求：确定 $\\lambda$ 的数值，并四舍五入到 $4$ 位有效数字。\n\n步骤 2：使用提取的已知条件进行验证\n根据有效性标准对问题进行评估。\n- **科学依据：**该问题基于 Karlin-Altschul 统计理论的基础，这是现代生物信息学的一个关键组成部分，特别是对于像 BLAST 这样的工具。所提供的方程是该背景下参数 $\\lambda$ 的核心定义。该模型和评分方案是用于说明目的的标准配置。该问题是科学合理的。\n- **适定性：**该问题提供了一个定义明确的方程，并要求一个唯一的正实数解。Karlin 和 Altschul 的理论保证，当且仅当期望得分 $E[s(a,b)]$ 为负时，才存在这样一个唯一的正 $\\lambda$。让我们计算这个值。任何特定配对 $(a,b)$ 的概率是 $p_a p_b = (\\frac{1}{4})(\\frac{1}{4}) = \\frac{1}{16}$。有 $4$ 种可能的匹配和 $12$ 种可能的错配。期望得分是：\n$$ E[s(a,b)] = \\sum_{a,b} p_a p_b s(a,b) = (4 \\times \\frac{1}{16} \\times (+1)) + (12 \\times \\frac{1}{16} \\times (-3)) = \\frac{4}{16} - \\frac{36}{16} = -\\frac{32}{16} = -2 $$\n由于 $E[s(a,b)] = -2  0$，因此存在一个唯一的正解 $\\lambda$。该问题是适定的。\n- **客观性：**该问题使用精确的数学语言和定义进行陈述，没有任何主观性或模糊性。\n\n步骤 3：结论与行动\n该问题是有效的，因为它是科学合理的、适定的、客观的和自洽的。因此，将推导出一个解决方案。\n\n$\\lambda$ 的定义方程是：\n$$ \\sum_{a \\in \\{A,C,G,T\\}} \\sum_{b \\in \\{A,C,G,T\\}} p_{a} p_{b} \\exp(\\lambda s(a,b)) = 1 $$\n所有可能的字母对 $(a,b)$ 的集合可以划分为两个不相交的集合：匹配（其中 $a=b$）和错配（其中 $a \\neq b$）。求和可以相应地拆分：\n$$ \\sum_{a=b} p_{a} p_{b} \\exp(\\lambda s(a,b)) + \\sum_{a \\neq b} p_{a} p_{b} \\exp(\\lambda s(a,b)) = 1 $$\nDNA 字母表有 $4$ 个字母。因此，有 $4$ 种可能的匹配对（A,A）、（C,C）、（G,G）、（T,T）和 $4 \\times 4 - 4 = 12$ 种可能的错配对。\n概率是均一的，所以对于任何配对 $(a,b)$，$p_a p_b = \\frac{1}{4} \\times \\frac{1}{4} = \\frac{1}{16}$。\n对于匹配，分数为 $s(a,b) = +1$。第一个求和变为：\n$$ \\sum_{a=b} p_{a} p_{b} \\exp(\\lambda s(a,b)) = 4 \\times \\left( \\frac{1}{16} \\exp(\\lambda \\cdot 1) \\right) = \\frac{4}{16} \\exp(\\lambda) = \\frac{1}{4} \\exp(\\lambda) $$\n对于错配，分数为 $s(a,b) = -3$。第二个求和变为：\n$$ \\sum_{a \\neq b} p_{a} p_{b} \\exp(\\lambda s(a,b)) = 12 \\times \\left( \\frac{1}{16} \\exp(\\lambda \\cdot (-3)) \\right) = \\frac{12}{16} \\exp(-3\\lambda) = \\frac{3}{4} \\exp(-3\\lambda) $$\n将这些表达式代回主方程得到：\n$$ \\frac{1}{4} \\exp(\\lambda) + \\frac{3}{4} \\exp(-3\\lambda) = 1 $$\n为了求解 $\\lambda$，我们可以将整个方程乘以 $4$：\n$$ \\exp(\\lambda) + 3 \\exp(-3\\lambda) = 4 $$\n设 $x = \\exp(\\lambda)$。因为我们寻求一个正的 $\\lambda$，我们必须有 $x > 1$。该方程转换为关于 $x$ 的代数方程：\n$$ x + 3x^{-3} = 4 $$\n乘以 $x^3$（非零）以消除负指数，得到一个多项式方程：\n$$ x^4 + 3 = 4x^3 $$\n整理成标准形式：\n$$ x^4 - 4x^3 + 3 = 0 $$\n我们寻求这个四次多项式的根。根据有理根定理，任何有理根都必须是常数项 $3$ 的约数。可能的有理根是 $\\pm 1$ 和 $\\pm 3$。\n测试 $x=1$：\n$$ (1)^4 - 4(1)^3 + 3 = 1 - 4 + 3 = 0 $$\n所以，$x=1$ 是一个根。这对应于 $\\lambda = \\ln(1) = 0$，这是在 $\\sum p_a p_b = 1$ 时始终存在的平凡解。我们感兴趣的是 $\\lambda$ 的唯一*正*解，它对应于 $x > 1$。\n由于 $x=1$ 是一个根，所以 $(x-1)$ 是该多项式的一个因子。我们进行多项式除法：\n$$ \\frac{x^4 - 4x^3 + 3}{x-1} = x^3 - 3x^2 - 3x - 3 $$\n因此，方程变为：\n$$ (x-1)(x^3 - 3x^2 - 3x - 3) = 0 $$\n非平凡根是三次方程的解：\n$$ P(x) = x^3 - 3x^2 - 3x - 3 = 0 $$\n这个方程没有简单的有理根。我们必须用数值方法找到相关的根。让我们分析函数 $P(x)$ 来定位我们寻求的根。我们发现 $P(3) = (3)^3 - 3(3)^2 - 3(3) - 3 = 27 - 27 - 9 - 3 = -12$ 和 $P(4) = (4)^3 - 3(4)^2 - 3(4) - 3 = 64 - 48 - 12 - 3 = 1$。\n由于 $P(3)  0$ 且 $P(4) > 0$，并且 $P(x)$ 是连续的，所以在 $3$ 和 $4$ 之间有一个根。由于这个根大于 $1$，它将给出所需的大于零的 $\\lambda$。使用数值方法，如牛顿法或计算求解器，我们发现该根为：\n$$ x \\approx 3.9526368 $$\n现在，我们使用关系式 $x = \\exp(\\lambda)$ 求解 $\\lambda$：\n$$ \\lambda = \\ln(x) = \\ln(3.9526368) $$\n$$ \\lambda \\approx 1.374333 $$\n问题要求答案四舍五入到 $4$ 位有效数字。前四位有效数字是 $1, 3, 7, 4$。随后的数字是 $3$，所以我们向下舍入。\n$$ \\lambda \\approx 1.374 $$\n这就是所要求的数值。",
            "answer": "$$\n\\boxed{1.374}\n$$"
        }
    ]
}