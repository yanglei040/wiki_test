{
    "hands_on_practices": [
        {
            "introduction": "Modern read mappers rely on compressed data structures like the FM-index, which is built upon the Burrows-Wheeler Transform (BWT), to achieve remarkable speed and memory efficiency. A key feature of this index is checkpointing, which introduces a fundamental trade-off between memory usage and query speed. This exercise challenges you to model this space-time trade-off mathematically and use calculus to determine the optimal checkpointing interval, providing insight into the core design principles of high-performance bioinformatics tools .",
            "id": "2425278",
            "problem": "A reference genome of length $N$ characters over an alphabet of size $\\sigma$ is indexed using the Burrowsâ€“Wheeler Transform (BWT). The index stores occurrence-count checkpoints every $k$ BWT positions. Each checkpoint stores cumulative counts for all $\\sigma$ symbols, using $b$ bytes per counter. Thus, the checkpointing overhead in memory is proportional to the number of checkpoints. For read mapping via last-to-first (LF) mapping, consider backward search over a read of length $L$. In each step of backward search, two rank queries are performed. Each rank query is computed by starting from the most recent checkpoint preceding the queried BWT position and scanning forward symbol-by-symbol up to the queried position to accumulate counts. Assume:\n- The queried BWT positions are uniformly distributed with respect to the checkpoint lattice, so the distance (in symbols) from a queried position to its preceding checkpoint is uniformly distributed on $\\{0,1,\\ldots,k-1\\}$.\n- The time cost per rank query has a fixed overhead of $\\tau_{0}$ seconds plus an additional $\\tau_{s}$ seconds per scanned BWT symbol.\n- The total time to process a read is the sum of the times of all rank queries in its $L$ LF-mapping steps.\n- The memory overhead due to checkpoints is $(N/k)\\sigma b$ bytes (ignore ceiling effects).\n- A tradeoff parameter $\\eta$ converts bytes of memory into an equivalent time cost in seconds per byte, so that the combined objective to minimize is $J(k)=T(k)+\\eta M(k)$, where $T(k)$ is the expected time (in seconds) to process one read and $M(k)$ is the checkpoint memory overhead (in bytes).\n\nGiven:\n- $N=5.0\\times 10^{6}$,\n- $\\sigma=5$,\n- $b=4$,\n- $L=150$,\n- $\\tau_{0}=30\\times 10^{-9}\\ \\text{s}$,\n- $\\tau_{s}=3.0\\times 10^{-9}\\ \\text{s}$,\n- $\\eta=1.7\\times 10^{-10}\\ \\text{s/byte}$,\n\ntreat $k$ as a positive real variable. Find the real-valued $k^*$ that minimizes $J(k)$. Report $k^*$ as a pure number (dimensionless), rounded to four significant figures.",
            "solution": "The problem as stated is scientifically grounded, well-posed, and objective. It presents a standard optimization problem in computational biology concerning the trade-off between time and memory in genomic indexing. All parameters are provided, and the objective is clearly defined. Therefore, the problem is valid, and a solution can be derived.\n\nThe objective is to find the checkpoint interval $k$ that minimizes the combined cost function $J(k) = T(k) + \\eta M(k)$, where $T(k)$ is the expected time to process one read and $M(k)$ is the memory overhead from checkpoints. We will treat $k$ as a positive real variable as specified.\n\nFirst, we formulate the expected time cost, $T(k)$. A read has length $L$, and processing it involves $L$ steps of backward search. Each step requires $2$ rank queries, for a total of $2L$ rank queries per read.\n\nThe time cost for a single rank query is composed of a fixed overhead $\\tau_0$ and a variable part that depends on the number of symbols scanned from the last checkpoint. Let this distance be $d$. The time for one query is $\\tau_0 + d \\cdot \\tau_s$. The problem states that the distance $d$ from a queried position to its preceding checkpoint is uniformly distributed on the set of integers $\\{0, 1, \\ldots, k-1\\}$. The expected value of this distance, $E[d]$, is:\n$$E[d] = \\frac{1}{k} \\sum_{i=0}^{k-1} i = \\frac{1}{k} \\frac{(k-1)k}{2} = \\frac{k-1}{2}$$\nThe expected time for a single rank query, $E[T_{\\text{query}}]$, is therefore:\n$$E[T_{\\text{query}}] = \\tau_0 + E[d] \\cdot \\tau_s = \\tau_0 + \\left(\\frac{k-1}{2}\\right)\\tau_s$$\nThe total expected time to process one read of length $L$, denoted $T(k)$, is the product of the number of queries ($2L$) and the expected time per query:\n$$T(k) = 2L \\cdot E[T_{\\text{query}}] = 2L \\left( \\tau_0 + \\frac{k-1}{2}\\tau_s \\right) = 2L\\tau_0 + L(k-1)\\tau_s$$\n\nNext, we formulate the memory overhead cost, $M(k)$. The problem statement provides this directly:\n$$M(k) = \\frac{N}{k} \\sigma b$$\nwhere $N$ is the genome length, $\\sigma$ is the alphabet size, and $b$ is the number of bytes per counter.\n\nThe combined objective function $J(k)$ is the sum of the time cost and the memory cost converted to an equivalent time cost via the parameter $\\eta$:\n$$J(k) = T(k) + \\eta M(k) = \\left( 2L\\tau_0 + L(k-1)\\tau_s \\right) + \\eta \\left( \\frac{N \\sigma b}{k} \\right)$$\nTo simplify for differentiation, we can expand the expression for $T(k)$:\n$$J(k) = 2L\\tau_0 + Lk\\tau_s - L\\tau_s + \\frac{\\eta N \\sigma b}{k}$$\nTo find the value of $k$ that minimizes $J(k)$, we compute the first derivative of $J(k)$ with respect to $k$ and set it to zero. The terms $2L\\tau_0$ and $-L\\tau_s$ are constant with respect to $k$.\n$$\\frac{dJ}{dk} = \\frac{d}{dk} \\left( (2L\\tau_0 - L\\tau_s) + L\\tau_s k + \\eta N \\sigma b k^{-1} \\right)$$\n$$\\frac{dJ}{dk} = L\\tau_s - \\eta N \\sigma b k^{-2} = L\\tau_s - \\frac{\\eta N \\sigma b}{k^2}$$\nSetting the derivative to zero to find the optimal value $k^*$:\n$$L\\tau_s - \\frac{\\eta N \\sigma b}{(k^*)^2} = 0$$\n$$L\\tau_s = \\frac{\\eta N \\sigma b}{(k^*)^2}$$\nSolving for $(k^*)^2$:\n$$(k^*)^2 = \\frac{\\eta N \\sigma b}{L \\tau_s}$$\nSince $k$ must be a positive value, we take the positive square root:\n$$k^* = \\sqrt{\\frac{\\eta N \\sigma b}{L \\tau_s}}$$\nTo confirm this is a minimum, we check the second derivative:\n$$\\frac{d^2J}{dk^2} = \\frac{d}{dk} \\left( L\\tau_s - \\eta N \\sigma b k^{-2} \\right) = 2 \\eta N \\sigma b k^{-3} = \\frac{2 \\eta N \\sigma b}{k^3}$$\nFor $k > 0$, all parameters ($\\eta, N, \\sigma, b$) are positive, so $\\frac{d^2J}{dk^2} > 0$. This confirms that $k^*$ corresponds to a minimum of the function $J(k)$.\n\nNow, we substitute the given numerical values:\n$N=5.0 \\times 10^{6}$\n$\\sigma=5$\n$b=4$\n$L=150$\n$\\tau_s=3.0 \\times 10^{-9}\\ \\text{s}$\n$\\eta=1.7 \\times 10^{-10}\\ \\text{s/byte}$\n\n$$k^* = \\sqrt{\\frac{(1.7 \\times 10^{-10}) \\cdot (5.0 \\times 10^{6}) \\cdot (5) \\cdot (4)}{(150) \\cdot (3.0 \\times 10^{-9})}}$$\nLet's compute the numerator and denominator of the fraction under the square root.\nNumerator:\n$$\\eta N \\sigma b = (1.7 \\times 10^{-10}) \\cdot (5.0 \\times 10^{6}) \\cdot (20) = 1.7 \\times 10^{-10} \\cdot 100 \\times 10^{6} = 1.7 \\times 10^{-2}$$\nDenominator:\n$$L \\tau_s = 150 \\cdot (3.0 \\times 10^{-9}) = 450 \\times 10^{-9} = 4.5 \\times 10^{-7}$$\nNow, we compute the value of $(k^*)^2$:\n$$(k^*)^2 = \\frac{1.7 \\times 10^{-2}}{4.5 \\times 10^{-7}} = \\frac{1.7}{4.5} \\times 10^5 \\approx 0.3777\\ldots \\times 10^5 = 37777.7\\ldots$$\nFinally, we compute $k^*$:\n$$k^* = \\sqrt{37777.7\\ldots} \\approx 194.36506 \\ldots$$\nThe problem requires the answer to be rounded to four significant figures. The first four significant figures are $1, 9, 4, 3$. The fifth digit is $6$, so we round up the third decimal place.\n$$k^* \\approx 194.4$$",
            "answer": "$$\\boxed{194.4}$$"
        },
        {
            "introduction": "Before aligning reads to a reference genome, it is crucial to identify and remove sequences from contaminant organisms, a common issue in sample preparation. This hands-on coding challenge guides you through building a practical pre-mapping filter using $k$-mers, a fast and powerful alignment-free technique. You will implement an algorithm that uses canonical $k$-mers to account for the double-stranded nature of DNA and classifies reads based on a specified contamination threshold .",
            "id": "2425285",
            "problem": "You are given the task of designing a pre-mapping filter to detect and remove reads that originate from a known contaminant organism by using fixed-length substring counting (also called $k$-mer counting). Work with Deoxyribonucleic Acid (DNA) sequences over the alphabet $\\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{T}\\}$ and possibly the ambiguity symbol $\\mathrm{N}$. The fundamental base is the following: a $k$-mer is any length-$k$ contiguous substring of a DNA string; the reverse complement of a DNA string is formed by reversing the string and replacing each $\\mathrm{A}$ by $\\mathrm{T}$, each $\\mathrm{T}$ by $\\mathrm{A}$, each $\\mathrm{C}$ by $\\mathrm{G}$, and each $\\mathrm{G}$ by $\\mathrm{C}$. The canonical form of a $k$-mer is defined as the lexicographically smaller of the $k$-mer and its reverse complement, where lexicographic order uses $\\mathrm{A}<\\mathrm{C}<\\mathrm{G}<\\mathrm{T}$. The contaminant signature for a given $k$ is the set of canonical $k$-mers observed in the contaminant reference.\n\nDesign a program that, for each read, decides whether to classify it as contaminant according to this rule:\n- Build the contaminant signature set $D_k$ by extracting all canonical $k$-mers from the contaminant reference string $S_c$.\n- For a read $R$, slide a window of length $k$ across $R$. A window that contains any symbol outside $\\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{T}\\}$ is invalid and must be excluded from both the numerator and denominator. Let $n_k$ be the number of valid windows in $R$ (that is, the number of valid $k$-mers), and let $c_k$ be the number of these valid windows whose canonical $k$-mer is in $D_k$.\n- Compute the match ratio $r_k = c_k / n_k$ when $n_k>0$. If $n_k=0$, define the read to be non-contaminant without further computation.\n- Given a threshold $\\tau$ with $0 \\le \\tau \\le 1$ expressed as a decimal, classify the read as contaminant if and only if $r_k \\ge \\tau$.\n\nAll computations are to be purely string-based with no physical units. Treat each overlapping window independently; that is, count with multiplicity rather than as unique $k$-mers within a read.\n\nTest Suite:\n- Use the following fixed contaminant reference string $S_c$: \"ACGTTGCAACGTTGCA\", which has length $16$.\n- For each test case $i$, you are given a tuple $(R_i, k_i, \\tau_i)$ consisting of a read string $R_i$, an integer $k_i$, and a real threshold $\\tau_i$ as a decimal. Your program must evaluate each case independently using $S_c$ to build $D_{k_i}$ for that case.\n\nThe test cases are:\n1. $R_1=$ \"TTGCAACGTTG\", $k_1 = 4$, $\\tau_1 = 0.6$.\n2. $R_2=$ \"ACGTTGCATTT\", $k_2 = 4$, $\\tau_2 = 0.625$.\n3. $R_3=$ \"AAAAACCCCC\", $k_3 = 4$, $\\tau_3 = 0.5$.\n4. $R_4=$ \"GTTGCAACGT\", $k_4 = 4$, $\\tau_4 = 0.9$.\n5. $R_5=$ \"ACGTNNNNACGT\", $k_5 = 4$, $\\tau_5 = 1.0$.\n6. $R_6=$ \"ACGT\", $k_6 = 5$, $\\tau_6 = 0.5$.\n7. $R_7=$ \"ACGTACGTACGT\", $k_7 = 4$, $\\tau_7 = 0.3$.\n\nFinal Output Format:\n- Your program should produce a single line of output containing a list of Boolean results for the $7$ test cases in order, where each entry is $\\mathrm{True}$ if the read is classified as contaminant and $\\mathrm{False}$ otherwise.\n- The line must be formatted as a comma-separated list enclosed in square brackets, with no spaces, for example, \"[True,False,...]\".\n\nYour program must be a complete, runnable implementation that constructs $D_{k}$ from $S_c$ for each test case, applies the above decision rule, and outputs the results for all cases as specified.",
            "solution": "The problem is well-defined and scientifically grounded in the field of bioinformatics. It describes a standard method for filtering sequencing reads based on $k$-mer content, which is a common pre-processing step in genomic analyses to remove contamination. The problem statement is complete, providing all necessary definitions, data, and a clear, deterministic algorithm. Therefore, a solution can be constructed.\n\nThe core principle is to quantify the similarity between a sequencing read $R$ and a contaminant reference genome $S_c$ by comparing their constituent substrings of a fixed length $k$, known as $k$-mers. Since DNA is double-stranded, a read can originate from either strand. To account for this, we do not work with $k$-mers directly, but with their canonical forms.\n\nThe canonical form of a $k$-mer is defined as the lexicographically smaller of the $k$-mer itself and its reverse complement, using the standard lexicographic order where $\\mathrm{A}<\\mathrm{C}<\\mathrm{G}<\\mathrm{T}$. The reverse complement is found by reversing the sequence and substituting each base with its Watson-Crick pair ($\\mathrm{A} \\leftrightarrow \\mathrm{T}$, $\\mathrm{C} \\leftrightarrow \\mathrm{G}$). This normalization ensures that a $k$-mer and its reverse complement are treated as a single entity, abstracting away the strand of origin.\n\nThe algorithm proceeds in two main stages: signature generation and read classification.\n\n1.  **Signature Generation**: First, we construct a contaminant signature, denoted as $D_k$, for a given integer $k$. This signature is the set of all unique canonical $k$-mers found in the contaminant reference string $S_c$. We slide a window of length $k$ across $S_c$, and for each resulting $k$-mer, we compute its canonical form and add it to a set data structure. Using a set is computationally efficient, providing an average time complexity of $O(1)$ for membership queries. The problem specifies a fixed $S_c$ of \"ACGTTGCAACGTTGCA\", which is of length $16$. For each test case with a specific $k_i$, the corresponding signature $D_{k_i}$ is built from this $S_c$.\n\n2.  **Read Classification**: For each test case, a read $R_i$ is evaluated against the signature $D_{k_i}$ using a given threshold $\\tau_i$. The procedure is as follows:\n    a. We slide a window of length $k_i$ across the read $R_i$.\n    b. Each window, or $k$-mer, is first validated. A window is considered valid only if it consists entirely of symbols from the alphabet $\\{\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{T}\\}$. Windows containing ambiguity symbols like $\\mathrm{N}$ are invalid and are ignored. We count the total number of valid windows, $n_{k_i}$.\n    c. If $n_{k_i} = 0$, which occurs if the read is shorter than $k_i$ or contains no valid windows, the read is immediately classified as non-contaminant.\n    d. For each valid window, we compute its canonical $k$-mer. We then check if this canonical form exists in the contaminant signature set $D_{k_i}$. We count the total number of such matches, denoted as $c_{k_i}$. The problem states to count with multiplicity, meaning each occurrence of a matching $k$-mer in the read contributes to the count.\n    e. The match ratio, $r_{k_i}$, is computed as the fraction of valid $k$-mers in the read that are also found in the contaminant signature: $r_{k_i} = c_{k_i} / n_{k_i}$.\n    f. Finally, a decision is made based on the threshold $\\tau_i$. The read is classified as contaminant if and only if its match ratio is greater than or equal to the threshold: $r_{k_i} \\ge \\tau_i$.\n\nThe implementation will consist of helper functions to compute the reverse complement and canonical form of a sequence, a function to build the contaminant signature set, and a main classification function that orchestrates these steps to evaluate each read according to the specified rule. The results for all test cases will be collected and formatted as a list of Boolean values.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# No other libraries outside the Python standard library are permitted.\n\n# Define helper functions at the top level for clarity.\n\n# Create a translation table for complementing DNA bases.\nCOMPLEMENT_MAP = str.maketrans('ACGT', 'TGCA')\nVALID_BASES = {'A', 'C', 'G', 'T'}\n\ndef reverse_complement(seq: str) -> str:\n    \"\"\"Computes the reverse complement of a DNA sequence.\"\"\"\n    return seq.translate(COMPLEMENT_MAP)[::-1]\n\ndef canonical_form(kmer: str) -> str:\n    \"\"\"Computes the canonical form of a k-mer.\"\"\"\n    rev_comp = reverse_complement(kmer)\n    return min(kmer, rev_comp)\n\ndef build_contaminant_signature(s_c: str, k: int) -> set:\n    \"\"\"Builds the set of canonical k-mers from a reference string.\"\"\"\n    signature = set()\n    if len(s_c) < k:\n        return signature\n    for i in range(len(s_c) - k + 1):\n        kmer = s_c[i:i+k]\n        # Assuming the contaminant reference string S_c contains only valid bases.\n        signature.add(canonical_form(kmer))\n    return signature\n\ndef classify_read(read: str, k: int, tau: float, contaminant_signature: set) -> bool:\n    \"\"\"Classifies a read as contaminant based on k-mer matching.\"\"\"\n    if len(read) < k:\n        return False\n\n    n_k = 0  # Count of valid k-mers in the read\n    c_k = 0  # Count of valid k-mers found in the contaminant signature\n\n    for i in range(len(read) - k + 1):\n        window = read[i:i+k]\n        \n        # A window is valid if it contains only symbols {A,C,G,T}.\n        is_valid = all(char in VALID_BASES for char in window)\n        \n        if is_valid:\n            n_k += 1\n            canonical_kmer = canonical_form(window)\n            if canonical_kmer in contaminant_signature:\n                c_k += 1\n    \n    # If no valid k-mers, classify as non-contaminant.\n    if n_k == 0:\n        return False\n    \n    # Compute match ratio and compare with the threshold.\n    ratio = c_k / n_k\n    return ratio >= tau\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the fixed contaminant reference string from the problem.\n    s_c = \"ACGTTGCAACGTTGCA\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\"TTGCAACGTTG\", 4, 0.6),\n        (\"ACGTTGCATTT\", 4, 0.625),\n        (\"AAAAACCCCC\", 4, 0.5),\n        (\"GTTGCAACGT\", 4, 0.9),\n        (\"ACGTNNNNACGT\", 4, 1.0),\n        (\"ACGT\", 5, 0.5),\n        (\"ACGTACGTACGT\", 4, 0.3),\n    ]\n\n    results = []\n    for case in test_cases:\n        read_str, k, tau = case\n        \n        # Build the contaminant signature for the given k.\n        signature = build_contaminant_signature(s_c, k)\n        \n        # Classify the read and store the result.\n        is_contaminant = classify_read(read_str, k, tau, signature)\n        results.append(is_contaminant)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Bioinformatics is not a one-size-fits-all field; algorithms must often be adapted to handle the unique characteristics of novel experimental data. This exercise dives into the world of epigenomics by tackling the challenge of mapping bisulfite-treated DNA, where unmethylated cytosines are chemically converted to thymines. You will design and implement a specialized seeding heuristic that accounts for this asymmetric transformation, demonstrating how core mapping concepts can be creatively modified to enable new types of biological discovery .",
            "id": "2425351",
            "problem": "Consider a finite alphabet $\\Sigma = \\{\\text{A}, \\text{C}, \\text{G}, \\text{T}\\}$ and a reference string $R \\in \\Sigma^{*}$ representing a segment of Deoxyribonucleic Acid (DNA). In bisulfite-treated DNA sequencing, unmethylated cytosines are converted to thymines on the sequenced strand, and equivalently guanines on the opposite strand correspond to adenines after treatment when viewed through reverse complementarity. We define two symbol-reduction functions to capture this chemistry as equivalence-preserving mappings:\n- $\\varphi_{\\mathrm{fwd}} : \\Sigma \\to \\Sigma$ given by $\\varphi_{\\mathrm{fwd}}(\\text{C}) = \\text{T}$ and $\\varphi_{\\mathrm{fwd}}(x) = x$ for all $x \\in \\{\\text{A}, \\text{G}, \\text{T}\\}$.\n- $\\varphi_{\\mathrm{rev}} : \\Sigma \\to \\Sigma$ given by $\\varphi_{\\mathrm{rev}}(\\text{G}) = \\text{A}$ and $\\varphi_{\\mathrm{rev}}(x) = x$ for all $x \\in \\{\\text{A}, \\text{C}, \\text{T}\\}$.\n\nLet $\\rho : \\Sigma^{*} \\to \\Sigma^{*}$ denote reverse complement, defined by first applying the complement mapping $\\text{A} \\leftrightarrow \\text{T}$ and $\\text{C} \\leftrightarrow \\text{G}$ to each character and then reversing the string.\n\nFix a seed length $k \\in \\mathbb{N}$ with $k \\ge 1$. For any string $S \\in \\Sigma^{*}$ and any index $i$ with $0 \\le i \\le |S| - k$, write $S[i{:}i{+}k]$ for the contiguous length-$k$ substring. For a read $Q \\in \\Sigma^{*}$, define its bisulfite-robust seeding candidate set against $R$ as the set of all indices $i$ with $0 \\le i \\le |R| - k$ for which there exists a seed position $j$ with $0 \\le j \\le |Q| - k$ such that either\n- $\\varphi_{\\mathrm{fwd}}\\big(Q[j{:}j{+}k]\\big) = \\varphi_{\\mathrm{fwd}}\\big(R[i{:}i{+}k]\\big)$, or\n- $\\varphi_{\\mathrm{rev}}\\big(\\rho(Q)[j{:}j{+}k]\\big) = \\varphi_{\\mathrm{rev}}\\big(R[i{:}i{+}k]\\big)$.\nIf $|Q| < k$, the candidate set is empty. All indices are to be reported as $0$-based integers.\n\nYour task is to, for a fixed $R$ and $k$, compute the sorted list (ascending order) of distinct $0$-based starting indices in $R$ that belong to the bisulfite-robust seeding candidate set for each given read $Q$, under the definition above.\n\nTest suite and parameters:\n- Reference string $R = \\text{\"AGCCGTTAGCGTTCACCGTAGC\"}$.\n- Seed length $k = 4$.\n- Reads, in order:\n  1. $Q_1 = \\text{\"TTGT\"}$.\n  2. $Q_2 = \\text{\"AAAT\"}$.\n  3. $Q_3 = \\text{\"AT\"}$.\n  4. $Q_4 = \\text{\"AGTTTT\"}$.\n  5. $Q_5 = \\text{\"TAGT\"}$.\n  6. $Q_6 = \\text{\"GGGG\"}$.\n\nAnswer specification:\n- For each read $Q_m$ in the list above (in the same order), compute the corresponding sorted list of distinct $0$-based indices as defined.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is itself a bracketed comma-separated list of integers. For example, the format is $[\\,[i_{1,1},\\dots,i_{1,a_1}],\\,[i_{2,1},\\dots],\\dots\\,]$. Concretely, the output for the test suite must be exactly one line in this format with no additional text.",
            "solution": "The problem statement is subjected to validation and is found to be scientifically grounded, well-posed, and objective. It is based on established principles in computational biology, specifically the simulation of bisulfite sequencing for read mapping. All terms are formally defined, and the task is a direct, unambiguous algorithmic challenge. Thus, we proceed with a solution.\n\nThe problem requires us to find a set of starting positions in a reference DNA string $R$ that are potential alignment sites for a given read $Q$. This is based on a specialized matching of short substrings of length $k$, called seeds or $k$-mers. The matching rules are designed to account for the chemical transformation induced by bisulfite treatment, which converts unmethylated cytosine ($C$) to thymine ($T$). This has implications for matching on both the forward strand and its reverse complement.\n\nOur algorithmic approach consists of two main phases: a preprocessing phase on the reference string $R$, and a query phase for each read $Q$. This design is efficient as it avoids redundant computations on the static reference string when processing multiple reads.\n\nFirst, we must formalize the given transformations.\nThe alphabet is $\\Sigma = \\{\\text{A}, \\text{C}, \\text{G}, \\text{T}\\}$.\nThe forward transformation, $\\varphi_{\\mathrm{fwd}} : \\Sigma^* \\to \\Sigma^*$, models the $C \\to T$ conversion on the forward strand. It is defined by applying the rule $\\varphi_{\\mathrm{fwd}}(\\text{C}) = \\text{T}$ to each character in a string, leaving other characters unchanged.\nThe reverse transformation, $\\varphi_{\\mathrm{rev}} : \\Sigma^* \\to \\Sigma^*$, models the equivalent change on the reverse complement strand. An unmethylated $C$ on the forward strand corresponds to a guanine ($G$) on the reverse complement strand. When sequenced, this $C$ appears as a $T$, and its complement is an adenine ($A$). Therefore, the original $G$ on the reverse complement strand effectively becomes an $A$. This is captured by the rule $\\varphi_{\\mathrm{rev}}(\\text{G}) = \\text{A}$, applied character-wise.\nThe reverse complement operation, $\\rho : \\Sigma^* \\to \\Sigma^*$, involves complementing each base ($\\text{A} \\leftrightarrow \\text{T}$, $\\text{C} \\leftrightarrow \\text{G}$) and then reversing the resulting string.\n\nThe candidate set for a read $Q$ against reference $R$ is the set of all indices $i$ in $R$ ($0 \\le i \\le |R|-k$) for which a seed from $R$ starting at $i$ matches a seed from $Q$ under these transformations. Specifically, for an index $i$ to be included, there must exist some seed starting at index $j$ in $Q$ ($0 \\le j \\le |Q|-k$) such that one of the following conditions holds:\n1.  Forward strand match: $\\varphi_{\\mathrm{fwd}}\\big(Q[j{:}j{+}k]\\big) = \\varphi_{\\mathrm{fwd}}\\big(R[i{:}i{+}k]\\big)$\n2.  Reverse complement match: $\\varphi_{\\mathrm{rev}}\\big(\\rho(Q)[j{:}j{+}k]\\big) = \\varphi_{\\mathrm{rev}}\\big(R[i{:}i{+}k]\\big)$\n\n**Phase 1: Preprocessing the Reference String $R$**\n\nTo accelerate the search for matching indices, we first process all $k$-mers from the reference string $R = \\text{\"AGCCGTTAGCGTTCACCGTAGC\"}$ with $k=4$. We generate two lookup tables (hash maps or dictionaries) that map transformed $k$-mers to the list of their original $0$-based starting indices in $R$.\n\nLet $N_R = |R| = 22$. We iterate through all possible starting indices $i$ from $0$ to $N_R - k = 18$. For each index $i$, we extract the $k$-mer $S_i = R[i:i+k]$.\n1.  We compute the forward-transformed $k$-mer, $S'_i = \\varphi_{\\mathrm{fwd}}(S_i)$, and store the mapping $S'_i \\to i$. We build a dictionary, `fwd_map`, where keys are the transformed $k$-mers and values are lists of indices.\n2.  Similarly, we compute the reverse-transformed $k$-mer, $S''_i = \\varphi_{\\mathrm{rev}}(S_i)$, and build a second dictionary, `rev_map`, to store the mapping $S''_i \\to i$.\n\nThis preprocessing step is performed only once.\n\n**Phase 2: Querying with Reads**\n\nFor each read $Q$ from the provided test suite, we perform the following steps to find its candidate set of indices.\n\n1.  Initialize an empty set, `candidate_indices`, to collect the unique matching indices from $R$.\n2.  A trivial case is handled first: if the length of the read $|Q|$ is less than the seed length $k$, no $k$-mers can be formed, and the candidate set is empty as per the problem definition.\n3.  **Forward Strand Search**: We iterate through all possible starting indices $j$ from $0$ to $|Q|-k$. For each index $j$, we extract the seed $q_j = Q[j:j+k]$. We transform this seed using $\\varphi_{\\mathrm{fwd}}$ to get $q'_j = \\varphi_{\\mathrm{fwd}}(q_j)$. We then look up $q'_j$ in our precomputed `fwd_map`. If a match is found, we add all indices from `fwd_map[q'_j]` to our `candidate_indices` set.\n4.  **Reverse Complement Strand Search**: We first compute the reverse complement of the entire read, $Q_{rc} = \\rho(Q)$. Then, we iterate through all possible starting indices $j$ from $0$ to $|Q_{rc}|-k$, extracting each seed $q_{rc,j} = Q_{rc}[j:j+k]$. We transform this seed using $\\varphi_{\\mathrm{rev}}$ to get $q''_{rc,j} = \\varphi_{\\mathrm{rev}}(q_{rc,j})$. We look up $q''_{rc,j}$ in our `rev_map`. If a match is found, we add all indices from `rev_map[q''_{rc,j}]` to the `candidate_indices` set.\n5.  **Finalization**: After considering all seeds from the read and its reverse complement, the `candidate_indices` set contains all unique matching indices in $R$. We convert this set to a list and sort it in ascending order to meet the output specification.\n\nThis procedure is repeated for every read in the test suite. The final output is an aggregation of the sorted lists of indices for each read, formatted as specified. The use of hash maps makes the search\nin steps $3$ and $4$ highly efficient, with an average time complexity of $O(1)$ for each lookup.",
            "answer": "```python\nimport collections\n\ndef solve():\n    \"\"\"\n    Solves the bisulfite-robust seeding problem.\n    This function implements the logic described in the solution, including\n    preprocessing the reference and then querying for each read.\n    \"\"\"\n    # Problem parameters and test suite\n    R = \"AGCCGTTAGCGTTCACCGTAGC\"\n    k = 4\n    reads = [\n        \"TTGT\",\n        \"AAAT\",\n        \"AT\",\n        \"AGTTTT\",\n        \"TAGT\",\n        \"GGGG\",\n    ]\n\n    # --- Helper Functions ---\n\n    def phi_fwd(s):\n        \"\"\"Applies the forward transformation (C -> T).\"\"\"\n        return s.replace('C', 'T')\n\n    def phi_rev(s):\n        \"\"\"Applies the reverse transformation (G -> A).\"\"\"\n        return s.replace('G', 'A')\n\n    def reverse_complement(s):\n        \"\"\"Computes the reverse complement of a DNA string.\"\"\"\n        comp_map = str.maketrans('AGCT', 'TCGA')\n        return s.translate(comp_map)[::-1]\n\n    # --- Phase 1: Preprocessing the Reference R ---\n\n    fwd_ref_map = collections.defaultdict(list)\n    rev_ref_map = collections.defaultdict(list)\n\n    if len(R) >= k:\n        for i in range(len(R) - k + 1):\n            kmer = R[i : i + k]\n            \n            # Map for forward strand matches\n            fwd_transformed_kmer = phi_fwd(kmer)\n            fwd_ref_map[fwd_transformed_kmer].append(i)\n            \n            # Map for reverse complement strand matches\n            rev_transformed_kmer = phi_rev(kmer)\n            rev_ref_map[rev_transformed_kmer].append(i)\n\n    # --- Phase 2: Processing each read Q ---\n\n    all_results = []\n    for q_str in reads:\n        candidate_indices = set()\n\n        # Handle case where read is shorter than seed length\n        if len(q_str) < k:\n            all_results.append([])\n            continue\n\n        # Condition 1: Forward strand check\n        for j in range(len(q_str) - k + 1):\n            q_kmer = q_str[j : j + k]\n            fwd_transformed_q_kmer = phi_fwd(q_kmer)\n            if fwd_transformed_q_kmer in fwd_ref_map:\n                candidate_indices.update(fwd_ref_map[fwd_transformed_q_kmer])\n        \n        # Condition 2: Reverse complement strand check\n        rc_q_str = reverse_complement(q_str)\n        for j in range(len(rc_q_str) - k + 1):\n            rc_q_kmer = rc_q_str[j : j + k]\n            rev_transformed_rc_q_kmer = phi_rev(rc_q_kmer)\n            if rev_transformed_rc_q_kmer in rev_ref_map:\n                candidate_indices.update(rev_ref_map[rev_transformed_rc_q_kmer])\n\n        all_results.append(sorted(list(candidate_indices)))\n\n    # --- Final Output Formatting ---\n    \n    # Format each inner list to \"[i1,i2,...]\" without spaces\n    inner_strs = [f\"[{','.join(map(str, res))}]\" for res in all_results]\n    \n    # Join the inner list strings into the final format \"[[...],[...]]\"\n    final_output = f\"[{','.join(inner_strs)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        }
    ]
}