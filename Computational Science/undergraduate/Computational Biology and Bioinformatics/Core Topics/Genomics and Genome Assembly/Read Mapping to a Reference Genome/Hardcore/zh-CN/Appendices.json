{
    "hands_on_practices": [
        {
            "introduction": "在读取比对中，找到一个错误率低或无错误的匹配位置固然重要，但该匹配的可信度同样关键，尤其是在充满重复序列的基因组中。比对质量分数（Mapping Quality, MAPQ）是衡量这种可信度的标准指标。这个练习将通过一个思想实验，探讨 MAPQ 的真正含义，揭示为何一个序列上的完美匹配不一定意味着高置信度的定位。",
            "id": "2425337",
            "problem": "一个长度为 $L$ 的单端DNA测序读长(read)是一个周期性的低复杂度字符串 $r=\\texttt{ATAT}\\dots$（交替的$\\texttt{A}$和$\\texttt{T}$），它在参考基因组中的多个位点(loci)上以零错配(mismatch)的方式比对。假设当存在多个得分相同的最佳比对时，读长比对器(aligner)会报告其中一个，而不使用关于位点唯一性的外部先验信息。忽略测序错误。作图质量(Mapping Quality, MAPQ)定义为 $\\mathrm{MAPQ}=-10\\log_{10} P_{\\text{err}}$，其中 $P_{\\text{err}}$ 是报告的比对位置不正确的概率。\n\n这个读长是否应该获得高的MAPQ分数？请选择使用概率论证正确解释答案的选项。\n\nA. 是。完美匹配意味着 $P_{\\text{err}}=0$，所以 $\\mathrm{MAPQ}$ 应该是最大的。\n\nB. 否。如果对于 $r$ 有 $k$ 个同样好的基因组位置，而比对器报告了其中一个，那么 $P_{\\text{err}}=1-\\frac{1}{k}$，所以 $\\mathrm{MAPQ}=-10\\log_{10}\\!\\left(1-\\frac{1}{k}\\right)$，当 $k\\gg 1$ 时这个值很小。\n\nC. 是。在测序错误可忽略的情况下，$P_{\\text{err}}\\approx 4^{-L}$，因此对于中等长度的 $L$，$\\mathrm{MAPQ}$ 很高。\n\nD. 这只取决于 $L$。任何 $L\\ge 30$ 的完美匹配都应获得 $\\mathrm{MAPQ}\\ge 30$ 的分数，无论基因组的重复性如何。\n\nE. 否。低复杂度读长本身具有更高的单位碱基错误率，即使序列完美匹配，这也会增加 $P_{\\text{err}}$。",
            "solution": "必须首先验证问题陈述的科学性和逻辑完整性。\n\n**步骤1：提取已知条件**\n- 测序读长是长度为 $L$ 的单端读长。\n- 读长序列是 $r=\\texttt{ATAT}\\dots$，一个周期性的低复杂度字符串。\n- 该读长在参考基因组的多个位点上以零错配的方式比对。\n- 当存在多个得分相同的最佳比对时，比对器报告其中一个。\n- 比对器不使用外部先验信息。\n- 测序错误被忽略。\n- 作图质量定义为 $\\mathrm{MAPQ}=-10\\log_{10} P_{\\text{err}}$。\n- $P_{\\text{err}}$ 是报告的比对位置不正确的概率。\n- 问题是这个读长是否应该获得高的 $\\mathrm{MAPQ}$ 分数，并用概率论证来解释。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题具有科学依据，表述清晰且客观。它描述了生物信息学中一个常见且基本的情景：重复序列的作图。作图质量($\\mathrm{MAPQ}$)的定义是标准的，正如在SAM/BAM等格式中使用的那样。诸如忽略测序错误和比对器在比对结果相同时的处理方式等假设被明确陈述，以将问题简化为其核心的概率性质。问题本身是自洽的，没有矛盾或歧义。\n\n**步骤3：结论与行动**\n问题是有效的。可以从提供的信息中推导出严谨的解决方案。\n\n**解决方案推导**\n作图质量，$\\mathrm{MAPQ}$，是衡量报告的比对位置即为读长真实来源位置的置信度的指标。其定义为 $\\mathrm{MAPQ}=-10\\log_{10} P_{\\text{err}}$，其中 $P_{\\text{err}}$ 是作图不正确的概率。\n\n问题陈述，读长 $r$ 在“多个位点”上以零错配的方式比对。我们将这样同样完美的比对位置的数量表示为 $k$。因为存在“多个”位点，我们知道 $k > 1$。\n\n鉴于所有 $k$ 个比对都是完美的（零错配），并且问题指示我们忽略测序错误，这 $k$ 个位置中的每一个都是读长同样可能的来源。比对器在没有任何其他信息或先验知识的情况下，没有理由偏好其中任何一个位置。因此，任何特定位点 $i$（其中 $i \\in \\{1, 2, \\dots, k\\}$）是读长真实来源的概率是 $\\frac{1}{k}$。\n\n比对器报告了这 $k$ 个位置中的一个。我们称报告的位置为 $L_{rep}$。这个报告的位置是正确位置的概率是：\n$$ P(\\text{correct}) = P(L_{rep} \\text{ is true origin}) = \\frac{1}{k} $$\n错误概率 $P_{\\text{err}}$ 是指报告的位置*不是*真实来源的概率。这是 $P(\\text{correct})$ 的补集：\n$$ P_{\\text{err}} = 1 - P(\\text{correct}) = 1 - \\frac{1}{k} = \\frac{k-1}{k} $$\n现在，我们可以计算 $\\mathrm{MAPQ}$ 分数：\n$$ \\mathrm{MAPQ} = -10\\log_{10} P_{\\text{err}} = -10\\log_{10}\\left(1 - \\frac{1}{k}\\right) $$\n我们来分析这个表达式。由于读长在多个位点上比对，$k \\ge 2$。\n- 如果 $k=2$，$P_{\\text{err}} = 1 - \\frac{1}{2} = 0.5$。$\\mathrm{MAPQ} = -10\\log_{10}(0.5) \\approx -10(-0.301) \\approx 3$。\n- 如果 $k=10$，$P_{\\text{err}} = 1 - \\frac{1}{10} = 0.9$。$\\mathrm{MAPQ} = -10\\log_{10}(0.9) \\approx -10(-0.046) \\approx 0.46$。\n- 当 $k \\to \\infty$ 时，$P_{\\text{err}} \\to 1$，并且 $\\mathrm{MAPQ} \\to 0$。\n\n在所有 $k>1$ 的情况下，$\\mathrm{MAPQ}$ 分数都是一个小的正数。$\\mathrm{MAPQ}$ 为 $3$ 对应 $50\\%$ 的错误率，这是一个极低的置信度。$\\mathrm{MAPQ}$ 分数趋近于 $0$ 表示几乎可以肯定作图是错误的（或者更准确地说，报告的比对是从大量同样好的候选位置中任意选择的）。因此，一个作图到多个位置的低复杂度读长不应获得高的 $\\mathrm{MAPQ}$ 分数。\n\n**逐项分析**\n\nA. 是。完美匹配意味着 $P_{\\text{err}}=0$，所以 $\\mathrm{MAPQ}$ 应该是最大的。\n这种说法不正确。完美匹配并不意味着唯一匹配。问题的核心是存在多个完美匹配。存在多个同样好的比对（$k>1$）意味着报告的单个比对正确的概率为 $\\frac{1}{k}  1$，因此 $P_{\\text{err}} = 1 - \\frac{1}{k}  0$。“完美匹配意味着 $P_{\\text{err}}=0$”这一前提是错误的。**不正确**。\n\nB. 否。如果对于 $r$ 有 $k$ 个同样好的基因组位置，而比对器报告了其中一个，那么 $P_{\\text{err}}=1-\\frac{1}{k}$，所以 $\\mathrm{MAPQ}=-10\\log_{10}\\!\\left(1-\\frac{1}{k}\\right)$，当 $k\\gg 1$ 时这个值很小。\n这种说法准确地反映了上述概率推理。它正确地指出，对于 $k$ 个同样好的放置位置，单个报告的比对的错误概率是 $1 - \\frac{1}{k}$。它正确地计算了由此产生的 $\\mathrm{MAPQ}$，并正确地得出结论：这个值很小，特别是对于大量的重复（$k\\gg 1$）。最终答案“否”也与推导一致。**正确**。\n\nC. 是。在测序错误可忽略的情况下，$P_{\\text{err}}\\approx 4^{-L}$，所以 $\\mathrm{MAPQ}$ 对于中等长度的 $L$ 很高。\n这种说法不正确。值 $4^{-L}$ 表示在假设一个独立同分布(i.i.d.)且核苷酸频率相等的模型下，一个长度为 $L$ 的特定序列在随机位置偶然出现的概率。这是一个随机命中概率的模型，而不是经验作图错误概率 $P_{\\text{err}}$。$P_{\\text{err}}$ 必须根据在给定参考基因组中找到的实际高质量比对位点的数量来计算。问题明确指出存在多个这样的位点，而该选项忽略了这一点。**不正确**。\n\nD. 这只取决于 $L$。任何 $L\\ge 30$ 的完美匹配都应获得 $\\mathrm{MAPQ}\\ge 30$ 的分数，无论基因组的重复性如何。\n这种说法不正确。$\\mathrm{MAPQ}$ 从根本上取决于作图的唯一性，而不仅仅是读长长度 $L$。一个非常长的读长（例如，$L=500$）如果由重复的双核苷酸 $\\texttt{AT}$ 组成，仍然可能作图到大型真核生物基因组中的数千个位置。在这种情况下，$k$ 会非常大，$P_{\\text{err}}$ 会接近 $1$，而 $\\mathrm{MAPQ}$ 会接近 $0$。声称无论重复性如何 $\\mathrm{MAPQ}$ 都很高，这直接与其定义相矛盾。**不正确**。\n\nE. 否。低复杂度读长本身具有更高的单位碱基错误率，即使序列完美匹配，这也会增加 $P_{\\text{err}}$。\n在问题的背景下，这种说法不正确。问题明确指示我们“忽略测序错误”。因此，引入基于内在错误率的论点违反了问题的前提。此外，其逻辑是混乱的：如果序列完美匹配，意味着在比对中没有观察到错误，因此根据给定的比对结果计算 $P_{\\text{err}}$ 时，推测潜在的错误率是无关紧要的。**不正确**。",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "从解读结果转向构建工具，一个高效的生物信息学流程通常会在进行计算密集型比对之前，先滤除无关数据，例如来自污染生物的序列。$k$-mer（长度为 $k$ 的 DNA 子串）是完成此任务的基本构件，它能快速地为序列提供一种“指纹”。本练习将指导你构建一个实用的污染过滤器，这是一个将 $k$-mer 概念付诸实践的绝佳编程任务。",
            "id": "2425285",
            "problem": "您的任务是设计一个预映射过滤器，通过使用固定长度子串计数（也称为$k$-mer计数）来检测并移除源自已知污染生物体的测序读数。处理的序列是基于字母表 $\\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{T}\\}$ 以及可能的不确定性符号 $\\mathrm{N}$ 的脱氧核糖核酸（DNA）序列。基本定义如下：$k$-mer 是 DNA 字符串中任意长度为 $k$ 的连续子串；DNA 字符串的反向互补序列是通过反转字符串并将每个 $\\mathrm{A}$ 替换为 $\\mathrm{T}$、每个 $\\mathrm{T}$ 替换为 $\\mathrm{A}$、每个 $\\mathrm{C}$ 替换为 $\\mathrm{G}$、每个 $\\mathrm{G}$ 替换为 $\\mathrm{C}$ 来形成的。$k$-mer 的规范形式定义为该 $k$-mer 与其反向互补序列中字典序较小的一个，其中字典序遵循 $\\mathrm{A}\\mathrm{C}\\mathrm{G}\\mathrm{T}$。对于给定的 $k$，污染特征是在污染参考序列中观察到的所有规范 $k$-mer 的集合。\n\n设计一个程序，根据以下规则对每个读数进行判断，决定是否将其分类为污染：\n- 通过从污染参考字符串 $S_c$ 中提取所有规范 $k$-mer，构建污染特征集 $D_k$。\n- 对于一个读数 $R$，在 $R$ 上滑动一个长度为 $k$ 的窗口。任何包含 $\\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{T}\\}$ 之外符号的窗口都是无效的，必须从分子和分母中排除。设 $n_k$ 为 $R$ 中有效窗口的数量（即有效 $k$-mer 的数量），设 $c_k$ 为这些有效窗口中，其规范 $k$-mer 存在于 $D_k$ 中的数量。\n- 当 $n_k  0$ 时，计算匹配率 $r_k = c_k / n_k$。如果 $n_k=0$，则无需进一步计算，直接将该读数定义为非污染。\n- 给定一个以小数表示的阈值 $\\tau$（$0 \\le \\tau \\le 1$），当且仅当 $r_k \\ge \\tau$ 时，将该读数分类为污染。\n\n所有计算都应纯粹基于字符串，不涉及物理单位。独立处理每个重叠窗口；也就是说，计数时要考虑其多重性，而不是作为读数内的唯一 $k$-mer 来计数。\n\n测试套件：\n- 使用以下固定的污染参考字符串 $S_c$：\"ACGTTGCAACGTTGCA\"，其长度为 16。\n- 对于每个测试用例 $i$，您会得到一个元组 $(R_i, k_i, \\tau_i)$，它由一个读数串 $R_i$、一个整数 $k_i$ 和一个以小数表示的实数阈值 $\\tau_i$ 组成。您的程序必须独立评估每个用例，并使用 $S_c$ 为该用例构建 $D_{k_i}$。\n\n测试用例如下：\n1. $R_1=$ \"TTGCAACGTTG\", $k_1 = 4$, $\\tau_1 = 0.6$.\n2. $R_2=$ \"ACGTTGCATTT\", $k_2 = 4$, $\\tau_2 = 0.625$.\n3. $R_3=$ \"AAAAACCCCC\", $k_3 = 4$, $\\tau_3 = 0.5$.\n4. $R_4=$ \"GTTGCAACGT\", $k_4 = 4$, $\\tau_4 = 0.9$.\n5. $R_5=$ \"ACGTNNNNACGT\", $k_5 = 4$, $\\tau_5 = 1.0$.\n6. $R_6=$ \"ACGT\", $k_6 = 5$, $\\tau_6 = 0.5$.\n7. $R_7=$ \"ACGTACGTACGT\", $k_7 = 4$, $\\tau_7 = 0.3$.\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含按顺序排列的 7 个测试用例的布尔结果列表，如果读数被分类为污染，则对应条目为 $\\mathrm{True}$，否则为 $\\mathrm{False}$。\n- 该行必须格式化为用方括号括起来的逗号分隔列表，不含空格，例如，\"[True,False,...]\"。\n\n您的程序必须是一个完整、可运行的实现，它能为每个测试用例从 $S_c$ 构建 $D_k$，应用上述决策规则，并按规定格式输出所有用例的结果。",
            "solution": "该问题定义明确，在生物信息学领域有其科学依据。它描述了一种基于 $k$-mer 内容过滤测序读数的标准方法，这是基因组分析中去除污染的常见预处理步骤。问题陈述是完整的，提供了所有必要的定义、数据和一个清晰的确定性算法。因此，可以构建一个解决方案。\n\n核心原理是通过比较测序读数 $R$ 和污染参考基因组 $S_c$ 的组成子串（即固定长度为 $k$ 的 $k$-mer），来量化它们之间的相似性。由于 DNA 是双链的，一个读数可能源自任何一条链。考虑到这一点，我们不直接使用 $k$-mer，而是使用它们的规范形式。\n\n$k$-mer 的规范形式定义为该 $k$-mer 自身与其反向互补序列中字典序较小的一个，使用的标准字典序为 $\\mathrm{A}\\mathrm{C}\\mathrm{G}\\mathrm{T}$。反向互补序列是通过反转序列并将每个碱基替换为其 Watson-Crick 配对碱基（$\\mathrm{A} \\leftrightarrow \\mathrm{T}$, $\\mathrm{C} \\leftrightarrow \\mathrm{G}$）来获得的。这种归一化确保了一个 $k$-mer 及其反向互补序列被视为一个单一实体，从而忽略了其来源链。\n\n该算法分两个主要阶段进行：特征生成和读数分类。\n\n1.  **特征生成**：首先，对于给定的整数 $k$，我们构建一个污染特征，记为 $D_k$。该特征是在污染参考字符串 $S_c$ 中找到的所有唯一规范 $k$-mer 的集合。我们在 $S_c$ 上滑动一个长度为 $k$ 的窗口，对于每个产生的 $k$-mer，我们计算其规范形式并将其添加到一个集合数据结构中。使用集合在计算上是高效的，其成员资格查询的平均时间复杂度为 $O(1)$。问题指定了一个固定的 $S_c$ \"ACGTTGCAACGTTGCA\"，其长度为 16。对于每个具有特定 $k_i$ 的测试用例，相应的特征 $D_{k_i}$ 将从这个 $S_c$ 构建。\n\n2.  **读数分类**：对于每个测试用例，使用给定的阈值 $\\tau_i$，根据特征 $D_{k_i}$ 对一个读数 $R_i$ 进行评估。流程如下：\n    a. 我们在读数 $R_i$ 上滑动一个长度为 $k_i$ 的窗口。\n    b. 每个窗口（或 $k$-mer）首先需要经过验证。一个窗口只有在完全由字母表 $\\{\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{T}\\}$ 中的符号组成时才被认为是有效的。包含像 $\\mathrm{N}$ 这样的不确定性符号的窗口是无效的，将被忽略。我们计算有效窗口的总数 $n_{k_i}$。\n    c. 如果 $n_{k_i} = 0$（当读数短于 $k_i$ 或不包含有效窗口时会发生这种情况），则该读数立即被分类为非污染。\n    d. 对于每个有效窗口，我们计算其规范 $k$-mer。然后我们检查该规范形式是否存在于污染特征集 $D_{k_i}$ 中。我们统计这类匹配的总数，记为 $c_{k_i}$。问题要求计数时要考虑其多重性，这意味着读数中每次出现的匹配 $k$-mer 都会计入总数。\n    e. 匹配率 $r_{k_i}$ 计算为读数中也能在污染特征中找到的有效 $k$-mer 的比例：$r_{k_i} = c_{k_i} / n_{k_i}$。\n    f. 最后，根据阈值 $\\tau_i$ 做出决策。当且仅当其匹配率大于或等于该阈值时，读数才被分类为污染：$r_{k_i} \\ge \\tau_i$。\n\n实现将包括用于计算序列的反向互补序列和规范形式的辅助函数、一个用于构建污染特征集的函数，以及一个协调这些步骤以根据指定规则评估每个读数的主分类函数。所有测试用例的结果将被收集并格式化为布尔值列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# No other libraries outside the Python standard library are permitted.\n\n# Define helper functions at the top level for clarity.\n\n# Create a translation table for complementing DNA bases.\nCOMPLEMENT_MAP = str.maketrans('ACGT', 'TGCA')\nVALID_BASES = {'A', 'C', 'G', 'T'}\n\ndef reverse_complement(seq: str) - str:\n    \"\"\"Computes the reverse complement of a DNA sequence.\"\"\"\n    return seq.translate(COMPLEMENT_MAP)[::-1]\n\ndef canonical_form(kmer: str) - str:\n    \"\"\"Computes the canonical form of a k-mer.\"\"\"\n    rev_comp = reverse_complement(kmer)\n    return min(kmer, rev_comp)\n\ndef build_contaminant_signature(s_c: str, k: int) - set:\n    \"\"\"Builds the set of canonical k-mers from a reference string.\"\"\"\n    signature = set()\n    if len(s_c)  k:\n        return signature\n    for i in range(len(s_c) - k + 1):\n        kmer = s_c[i:i+k]\n        # Assuming the contaminant reference string S_c contains only valid bases.\n        signature.add(canonical_form(kmer))\n    return signature\n\ndef classify_read(read: str, k: int, tau: float, contaminant_signature: set) - bool:\n    \"\"\"Classifies a read as contaminant based on k-mer matching.\"\"\"\n    if len(read)  k:\n        return False\n\n    n_k = 0  # Count of valid k-mers in the read\n    c_k = 0  # Count of valid k-mers found in the contaminant signature\n\n    for i in range(len(read) - k + 1):\n        window = read[i:i+k]\n        \n        # A window is valid if it contains only symbols {A,C,G,T}.\n        is_valid = all(char in VALID_BASES for char in window)\n        \n        if is_valid:\n            n_k += 1\n            canonical_kmer = canonical_form(window)\n            if canonical_kmer in contaminant_signature:\n                c_k += 1\n    \n    # If no valid k-mers, classify as non-contaminant.\n    if n_k == 0:\n        return False\n    \n    # Compute match ratio and compare with the threshold.\n    ratio = c_k / n_k\n    return ratio = tau\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the fixed contaminant reference string from the problem.\n    s_c = \"ACGTTGCAACGTTGCA\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\"TTGCAACGTTG\", 4, 0.6),\n        (\"ACGTTGCATTT\", 4, 0.625),\n        (\"AAAAACCCCC\", 4, 0.5),\n        (\"GTTGCAACGT\", 4, 0.9),\n        (\"ACGTNNNNACGT\", 4, 1.0),\n        (\"ACGT\", 5, 0.5),\n        (\"ACGTACGTACGT\", 4, 0.3),\n    ]\n\n    results = []\n    for case in test_cases:\n        read_str, k, tau = case\n        \n        # Build the contaminant signature for the given k.\n        signature = build_contaminant_signature(s_c, k)\n        \n        # Classify the read and store the result.\n        is_contaminant = classify_read(read_str, k, tau, signature)\n        results.append(is_contaminant)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "核心的生物信息学算法并非“一刀切”的解决方案，它们常常需要被调整以适应不同实验技术的细微差别。亚硫酸氢盐测序是表观遗传学中的一种关键技术，它会引起特定的化学变化（未甲基化的胞嘧啶 $C$ 变为胸腺嘧啶 $T$），这就要求我们对比对算法进行修改。本练习将作为前一个 $k$-mer 练习的延伸，挑战你如何调整基本的种子匹配逻辑，以解决这一特殊但重要的数据分析难题。",
            "id": "2425351",
            "problem": "考虑一个有限字母表 $\\Sigma = \\{\\text{A}, \\text{C}, \\text{G}, \\text{T}\\}$ 和一个代表脱氧核糖核酸（DNA）片段的参考字符串 $R \\in \\Sigma^{*}$。在经过亚硫酸氢盐处理的DNA测序中，测序链上未甲基化的胞嘧啶会转化为胸腺嘧啶，等效地，从反向互补的角度看，对链上的鸟嘌呤在处理后对应于腺嘌呤。我们定义两个符号简化函数来捕捉这种作为保持等价性映射的化学变化：\n- $\\varphi_{\\mathrm{fwd}} : \\Sigma \\to \\Sigma$，由 $\\varphi_{\\mathrm{fwd}}(\\text{C}) = \\text{T}$ 给出，且对于所有 $x \\in \\{\\text{A}, \\text{G}, \\text{T}\\}$，$\\varphi_{\\mathrm{fwd}}(x) = x$。\n- $\\varphi_{\\mathrm{rev}} : \\Sigma \\to \\Sigma$，由 $\\varphi_{\\mathrm{rev}}(\\text{G}) = \\text{A}$ 给出，且对于所有 $x \\in \\{\\text{A}, \\text{C}, \\text{T}\\}$，$\\varphi_{\\mathrm{rev}}(x) = x$。\n\n令 $\\rho : \\Sigma^{*} \\to \\Sigma^{*}$ 表示反向互补操作，其定义为首先对每个字符应用互补映射 $\\text{A} \\leftrightarrow \\text{T}$ 和 $\\text{C} \\leftrightarrow \\text{G}$，然后反转整个字符串。\n\n固定一个种子长度 $k \\in \\mathbb{N}$ 且 $k \\ge 1$。对于任意字符串 $S \\in \\Sigma^{*}$ 和任意索引 $i$（其中 $0 \\le i \\le |S| - k$），用 $S[i{:}i{+}k]$ 表示其长度为 $k$ 的连续子串。对于一个读段 $Q \\in \\Sigma^{*}$，我们定义其相对于 $R$ 的亚硫酸氢盐稳健种子候选集为所有满足 $0 \\le i \\le |R| - k$ 的索引 $i$ 的集合，对其中每个索引 $i$，都存在一个种子位置 $j$（其中 $0 \\le j \\le |Q| - k$），使得以下两个条件之一成立：\n- $\\varphi_{\\mathrm{fwd}}\\big(Q[j{:}j{+}k]\\big) = \\varphi_{\\mathrm{fwd}}\\big(R[i{:}i{+}k]\\big)$，或\n- $\\varphi_{\\mathrm{rev}}\\big(\\rho(Q)[j{:}j{+}k]\\big) = \\varphi_{\\mathrm{rev}}\\big(R[i{:}i{+}k]\\big)$。\n如果 $|Q|  k$，则候选集为空。所有索引都应报告为从0开始的整数。\n\n你的任务是，对于固定的 $R$ 和 $k$，根据上述定义，为每个给定的读段 $Q$ 计算出其亚硫酸氢盐稳健种子候选集，并以排序列表（升序）的形式返回 $R$ 中所有属于该候选集的、不重复的、从0开始的起始索引。\n\n测试套件与参数：\n- 参考字符串 $R = \\text{\"AGCCGTTAGCGTTCACCGTAGC\"}$。\n- 种子长度 $k = 4$。\n- 读段，按顺序：\n  1. $Q_1 = \\text{\"TTGT\"}$。\n  2. $Q_2 = \\text{\"AAAT\"}$。\n  3. $Q_3 = \\text{\"AT\"}$。\n  4. $Q_4 = \\text{\"AGTTTT\"}$。\n  5. $Q_5 = \\text{\"TAGT\"}$。\n  6. $Q_6 = \\text{\"GGGG\"}$。\n\n答案规格：\n- 对于上面列表中的每个读段 $Q_m$（按相同顺序），计算其对应的、根据定义得出的、不重复的、从0开始的索引的排序列表。\n- 你的程序应该生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，列表中的每个元素本身也是一个用方括号括起来的、以逗号分隔的整数列表。例如，格式为 $[\\,[i_{1,1},\\dots,i_{1,a_1}],\\,[i_{2,1},\\dots],\\dots\\,]$。具体来说，测试套件的输出必须是严格符合此格式的一行，不得包含任何额外文本。",
            "solution": "问题陈述已经过验证，被认定为具有科学依据、定义明确且客观。它基于计算生物学中的既定原则，特别是用于读段比对的亚硫酸氢盐测序模拟。所有术语均有正式定义，该任务是一个直接、无歧义的算法挑战。因此，我们着手提供解决方案。\n\n该问题要求我们在参考DNA字符串 $R$ 中找到一个起始位置集合，这些位置是给定读段 $Q$ 的潜在比对位点。这是基于对长度为 $k$ 的短子串（称为种子或 $k$-mer）的专门匹配规则。匹配规则旨在解释亚硫酸氢盐处理引起的化学转化，即未甲基化的胞嘧啶（$C$）转化为胸腺嘧啶（$T$）。这对正向链及其反向互补链的匹配都有影响。\n\n我们的算法方法包括两个主要阶段：对参考字符串 $R$ 的预处理阶段，以及对每个读段 $Q$ 的查询阶段。这种设计是高效的，因为它避免了在处理多个读段时对静态参考字符串进行重复计算。\n\n首先，我们必须将给定的转换形式化。\n字母表为 $\\Sigma = \\{\\text{A}, \\text{C}, \\text{G}, \\text{T}\\}$。\n正向转换 $\\varphi_{\\mathrm{fwd}} : \\Sigma^* \\to \\Sigma^*$ 模拟了正向链上的 $C \\to T$ 转化。其定义为对字符串中的每个字符应用规则 $\\varphi_{\\mathrm{fwd}}(\\text{C}) = \\text{T}$，同时保持其他字符不变。\n反向转换 $\\varphi_{\\mathrm{rev}} : \\Sigma^* \\to \\Sigma^*$ 模拟了反向互补链上的等效变化。正向链上一个未甲基化的 $C$ 对应于反向互补链上的一个鸟嘌呤（$G$）。测序时，这个 $C$ 显示为 $T$，其互补碱基是腺嘌呤（$A$）。因此，反向互补链上原始的 $G$ 实际上变成了 $A$。这一点通过逐字符应用规则 $\\varphi_{\\mathrm{rev}}(\\text{G}) = \\text{A}$ 来捕捉。\n反向互补操作 $\\rho : \\Sigma^* \\to \\Sigma^*$，包括对每个碱基进行互补（$\\text{A} \\leftrightarrow \\text{T}$, $\\text{C} \\leftrightarrow \\text{G}$），然后反转得到的字符串。\n\n读段 $Q$ 相对于参考 $R$ 的候选集是 $R$ 中所有索引 $i$（$0 \\le i \\le |R|-k$）的集合，对于这些索引，从 $i$ 开始的 $R$ 的一个种子与 $Q$ 的一个种子在这些转换规则下匹配。具体来说，要包含索引 $i$，必须存在 $Q$ 中某个从索引 $j$ 开始的种子（$0 \\le j \\le |Q|-k$），使得以下条件之一成立：\n1.  正向链匹配: $\\varphi_{\\mathrm{fwd}}\\big(Q[j{:}j{+}k]\\big) = \\varphi_{\\mathrm{fwd}}\\big(R[i{:}i{+}k]\\big)$\n2.  反向互补链匹配: $\\varphi_{\\mathrm{rev}}\\big(\\rho(Q)[j{:}j{+}k]\\big) = \\varphi_{\\mathrm{rev}}\\big(R[i{:}i{+}k]\\big)$\n\n**阶段 1：预处理参考字符串 $R$**\n\n为了加速匹配索引的搜索，我们首先处理参考字符串 $R = \\text{\"AGCCGTTAGCGTTCACCGTAGC\"}$（其中 $k=4$）中的所有 $k$-mer。我们生成两个查找表（哈希映射或字典），将转换后的 $k$-mer 映射到它们在 $R$ 中原始的、从0开始的起始索引列表。\n\n令 $N_R = |R| = 22$。我们遍历所有可能的起始索引 $i$，从 $0$到 $N_R - k = 18$。对于每个索引 $i$，我们提取 $k$-mer $S_i = R[i:i+k]$。\n1.  我们计算正向转换后的 $k$-mer，$S'_i = \\varphi_{\\mathrm{fwd}}(S_i)$，并存储映射 $S'_i \\to i$。我们构建一个字典 `fwd_map`，其中键是转换后的 $k$-mer，值是索引列表。\n2.  类似地，我们计算反向转换后的 $k$-mer，$S''_i = \\varphi_{\\mathrm{rev}}(S_i)$，并构建第二个字典 `rev_map` 来存储映射 $S''_i \\to i$。\n\n此预处理步骤仅执行一次。\n\n**阶段 2：使用读段进行查询**\n\n对于所提供测试套件中的每个读段 $Q$，我们执行以下步骤来找到其候选索引集。\n\n1.  初始化一个空集合 `candidate_indices`，用于收集来自 $R$ 的唯一匹配索引。\n2.  首先处理一个平凡情况：如果读段的长度 $|Q|$ 小于种子长度 $k$，则无法形成 $k$-mer，根据问题定义，候选集为空。\n3.  **正向链搜索**：我们遍历所有可能的起始索引 $j$，从 $0$ 到 $|Q|-k$。对于每个索引 $j$，我们提取种子 $q_j = Q[j:j+k]$。我们使用 $\\varphi_{\\mathrm{fwd}}$ 转换这个种子得到 $q'_j = \\varphi_{\\mathrm{fwd}}(q_j)$。然后在我们预先计算的 `fwd_map` 中查找 $q'_j$。如果找到匹配项，我们将 `fwd_map[q'_j]` 中的所有索引添加到我们的 `candidate_indices` 集合中。\n4.  **反向互补链搜索**：我们首先计算整个读段的反向互补链 $Q_{rc} = \\rho(Q)$。然后，我们遍历所有可能的起始索引 $j$，从 $0$ 到 $|Q_{rc}|-k$，提取每个种子 $q_{rc,j} = Q_{rc}[j:j+k]$。我们使用 $\\varphi_{\\mathrm{rev}}$ 转换这个种子得到 $q''_{rc,j} = \\varphi_{\\mathrm{rev}}(q_{rc,j})$。我们在 `rev_map` 中查找 $q''_{rc,j}$。如果找到匹配项，我们将 `rev_map[q''_{rc,j}]` 中的所有索引添加到 `candidate_indices` 集合中。\n5.  **最终处理**：在考虑了读段及其反向互补链的所有种子之后，`candidate_indices` 集合包含了 $R$ 中所有唯一的匹配索引。我们将此集合转换为列表，并按升序排序，以满足输出规格要求。\n\n对测试套件中的每个读段重复此过程。最终输出是为每个读段生成的已排序索引列表的聚合，并按指定格式化。使用哈希映射使得步骤3和4中的搜索非常高效，每次查找的平均时间复杂度为 $O(1)$。",
            "answer": "```python\nimport collections\n\ndef solve():\n    \"\"\"\n    Solves the bisulfite-robust seeding problem.\n    This function implements the logic described in the solution, including\n    preprocessing the reference and then querying for each read.\n    \"\"\"\n    # Problem parameters and test suite\n    R = \"AGCCGTTAGCGTTCACCGTAGC\"\n    k = 4\n    reads = [\n        \"TTGT\",\n        \"AAAT\",\n        \"AT\",\n        \"AGTTTT\",\n        \"TAGT\",\n        \"GGGG\",\n    ]\n\n    # --- Helper Functions ---\n\n    def phi_fwd(s):\n        \"\"\"Applies the forward transformation (C - T).\"\"\"\n        return s.replace('C', 'T')\n\n    def phi_rev(s):\n        \"\"\"Applies the reverse transformation (G - A).\"\"\"\n        return s.replace('G', 'A')\n\n    def reverse_complement(s):\n        \"\"\"Computes the reverse complement of a DNA string.\"\"\"\n        comp_map = str.maketrans('AGCT', 'TCGA')\n        return s.translate(comp_map)[::-1]\n\n    # --- Phase 1: Preprocessing the Reference R ---\n\n    fwd_ref_map = collections.defaultdict(list)\n    rev_ref_map = collections.defaultdict(list)\n\n    if len(R) = k:\n        for i in range(len(R) - k + 1):\n            kmer = R[i : i + k]\n            \n            # Map for forward strand matches\n            fwd_transformed_kmer = phi_fwd(kmer)\n            fwd_ref_map[fwd_transformed_kmer].append(i)\n            \n            # Map for reverse complement strand matches\n            rev_transformed_kmer = phi_rev(kmer)\n            rev_ref_map[rev_transformed_kmer].append(i)\n\n    # --- Phase 2: Processing each read Q ---\n\n    all_results = []\n    for q_str in reads:\n        candidate_indices = set()\n\n        # Handle case where read is shorter than seed length\n        if len(q_str)  k:\n            all_results.append([])\n            continue\n\n        # Condition 1: Forward strand check\n        for j in range(len(q_str) - k + 1):\n            q_kmer = q_str[j : j + k]\n            fwd_transformed_q_kmer = phi_fwd(q_kmer)\n            if fwd_transformed_q_kmer in fwd_ref_map:\n                candidate_indices.update(fwd_ref_map[fwd_transformed_q_kmer])\n        \n        # Condition 2: Reverse complement strand check\n        rc_q_str = reverse_complement(q_str)\n        for j in range(len(rc_q_str) - k + 1):\n            rc_q_kmer = rc_q_str[j : j + k]\n            rev_transformed_rc_q_kmer = phi_rev(rc_q_kmer)\n            if rev_transformed_rc_q_kmer in rev_ref_map:\n                candidate_indices.update(rev_ref_map[rev_transformed_rc_q_kmer])\n\n        all_results.append(sorted(list(candidate_indices)))\n\n    # --- Final Output Formatting ---\n    \n    # Format each inner list to \"[i1,i2,...]\" without spaces\n    inner_strs = [f\"[{','.join(map(str, res))}]\" for res in all_results]\n    \n    # Join the inner list strings into the final format \"[[...],[...]]\"\n    final_output = f\"[{','.join(inner_strs)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        }
    ]
}