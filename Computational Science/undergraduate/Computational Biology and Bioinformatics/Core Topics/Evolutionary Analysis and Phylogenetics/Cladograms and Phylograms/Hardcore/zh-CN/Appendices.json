{
    "hands_on_practices": [
        {
            "introduction": "掌握如何正确解读进化树是学习系统发育学的第一步。本练习旨在帮助你理解一个核心概念：进化树的拓扑结构（即分支模式）决定了物种间的亲缘关系，而节点的旋转并不会改变这些关系 。通过比较两棵看似不同但拓扑结构相同的树，你将学会如何准确地辨别等价的进化历史表达方式。",
            "id": "2311348",
            "problem": "一位外空生物学家正在研究一颗遥远行星上新发现的五种外星物种的进化史。我们称它们为物种V、W、X、Y和Z。两位不同的研究生使用相同的遗传数据集但不同的可视化软件，对系统发育树生成了两种文本描述。你的任务是确定他们关于进化关系的结论是相同还是不同。\n\n**树1描述：**\n该树以物种Z为外群作为根，这意味着它与所有其他物种的亲缘关系最远。剩下的四个物种形成一个单系群，该单系群分裂成两个主要分支。第一个分支导向物种Y。第二个分支导向一个包含物种V、W和X的较小群体。在这个较小的群体中，物种X是包含物种V和物种W的进化支的姐妹分类单元，而物种V和物种W互为彼此最亲近的亲属。\n\n**树2描述：**\n该树以物种Z为外群作为根。导向其他四个物种的谱系立即分裂成两个进化支。第一个进化支由物种V、W和X组成。第二个进化支仅由物种Y组成。在第一个进化支中，物种V和物种W是姐妹分类单元，并且这对组合与物种X共享的共同祖先，比它们与任何其他物种共享的共同祖先都要晚近。\n\n以下哪个陈述正确地评估了这两棵树？\n\nA. 这两棵树代表了不同的进化史，因为物种Y和(V, W, X)进化支的位置互换了。\n\nB. 这两棵树代表了不同的进化史，因为在树1中，物种Y似乎比物种X更“高等”，而在树2中它们的关系不明确。\n\nC. 这两棵树代表了相同的进化史，因为两者中姐妹群关系的模式是相同的。\n\nD. 这两棵树代表了相同的进化史，但这仅仅是因为物种Z在两者中都是外群。不同的外群会使它们不等价。\n\nE. 如果没有看到代表进化时间的枝长，就不可能确定它们的进化史是相同还是不同。",
            "solution": "我们首先解释标准的系统发育术语。一棵带有外群的有根树表示树根位于导向外群的分支上，所有其他分类单元构成内群。一个进化支（单系群）包括一个祖先及其所有后代。姐妹分类单元共享一个直接的共同祖先。两棵有根树代表相同的进化史，当且仅当它们的姐妹群关系和嵌套进化支（拓扑结构）的集合是相同的。\n\n解析树1：\n- 以Z为外群作为根意味着Z是内群 $\\{V,W,X,Y\\}$ 的姐妹群。\n- 内群分裂成两个主要分支：一个是单独的 $Y$，另一个是进化支 $\\{V,W,X\\}$。\n- 在 $\\{V,W,X\\}$ 内部，$X$ 是包含 $V$ 和 $W$ 的进化支的姐妹群，而 $V$ 和 $W$ 是姐妹分类单元。\n- 因此，层级的姐妹关系是：\n  $$ (V,W) \\text{ are sisters}, \\quad X \\text{ is sister to } (V,W), \\quad Y \\text{ is sister to } (X,(V,W)). $$\n\n解析树2：\n- 以Z为外群作为根意味着Z是内群 $\\{V,W,X,Y\\}$ 的姐妹群。\n- 内群立即分裂成两个进化支：$\\{V,W,X\\}$ 和 $\\{Y\\}$，因此 $Y$ 是进化支 $\\{V,W,X\\}$ 的姐妹群。\n- 在 $\\{V,W,X\\}$ 内部，$V$ 和 $W$ 是姐妹分类单元，并且这对组合与 $X$ 共享的共同祖先比它们与任何其他物种共享的共同祖先都要晚近；这等价于说，$X$ 是 $(V,W)$ 的姐妹群。\n- 因此，层级的姐妹关系是相同的：\n  $$ (V,W) \\text{ are sisters}, \\quad X \\text{ is sister to } (V,W), \\quad Y \\text{ is sister to } (X,(V,W)). $$\n\n比较：\n- 两棵树在以Z为外群的情况下，在 $\\{V,W,X,Y\\}$ 上具有相同的有根拓扑结构。因此，两种描述中的姐妹群关系模式是相同的。\n- 评估选项：\n  - A是不正确的：两种描述都没有互换位置；两者都将 $Y$ 置于进化支 $\\{V,W,X\\}$ 的姐妹群位置。\n  - B是不正确的：不存在更“高等”的排序；两者都指定了 $Y$ 和 $X$ 之间相同的拓扑结构。\n  - C是正确的：姐妹群关系完全匹配。\n  - D是不正确的：等价性是由于拓扑结构相同，而不仅仅是共享同一个外群。\n  - E是不正确的：评估拓扑等价性不需要枝长。\n\n因此，正确选项是 C。",
            "answer": "$$\\boxed{C}$$"
        },
        {
            "introduction": "在推断进化树时，科学家们需要一个标准来从众多可能性中选出“最佳”的树，最大简约法便是其中一个经典原则。这个练习将让你亲手为一个四物种的小型数据集计算不同拓扑结构的简约性分数 ，从而直观地理解简约性原则是如何通过“最少进化改变”来评估进化假设的。这项基本技能是理解更复杂系统发育推断方法的基础。",
            "id": "2378551",
            "problem": "下面给出了一个包含 $4$ 个分类单元和 $5$ 个位点的脱氧核糖核酸（DNA）比对。假设每个位点在最大简约性原则下独立进化，其中一棵树的简约性分数定义为：为解释在叶节点观察到的状态，所有边上所需发生的状态改变的最小总数，并对所有位点求和。分类单元为 $\\mathrm{T}_1$、$\\mathrm{T}_2$、$\\mathrm{T}_3$ 和 $\\mathrm{T}_4$。每个位点观察到的核苷酸状态如下：\n- 位点 $1$：$\\mathrm{T}_1=A$、$\\mathrm{T}_2=A$、$\\mathrm{T}_3=G$、$\\mathrm{T}_4=G$。\n- 位点 $2$：$\\mathrm{T}_1=C$、$\\mathrm{T}_2=T$、$\\mathrm{T}_3=C$、$\\mathrm{T}_4=T$。\n- 位点 $3$：$\\mathrm{T}_1=G$、$\\mathrm{T}_2=A$、$\\mathrm{T}_3=A$、$\\mathrm{T}_4=G$。\n- 位点 $4$：$\\mathrm{T}_1=A$、$\\mathrm{T}_2=A$、$\\mathrm{T}_3=A$、$\\mathrm{T}_4=A$。\n- 位点 $5$：$\\mathrm{T}_1=A$、$\\mathrm{T}_2=A$、$\\mathrm{T}_3=C$、$\\mathrm{T}_4=G$。\n\n考虑这 $4$ 个分类单元上 $3$ 种可能的无根二叉树拓扑，它们对应于双分划分 $\\big((\\mathrm{T}_1,\\mathrm{T}_2),(\\mathrm{T}_3,\\mathrm{T}_4)\\big)$、$\\big((\\mathrm{T}_1,\\mathrm{T}_3),(\\mathrm{T}_2,\\mathrm{T}_4)\\big)$ 和 $\\big((\\mathrm{T}_1,\\mathrm{T}_4),(\\mathrm{T}_2,\\mathrm{T}_3)\\big)$。对于每种拓扑，通过将每个位点所需的状态改变的最小数量相加，计算总简约性分数。然后，将这 $3$ 个总简约性分数中的最小值作为一个整数报告为您的最终答案。不包括任何单位。无需四舍五入。",
            "solution": "我们的目标是为4个分类单元 $(\\mathrm{T}_1, \\mathrm{T}_2, \\mathrm{T}_3, \\mathrm{T}_4)$ 的3种可能的无根二叉树拓扑计算总简约性分数，并找出其中的最小值。这三种拓扑由以下双分划分定义：\n$T_1: ((\\mathrm{T}_1, \\mathrm{T}_2), (\\mathrm{T}_3, \\mathrm{T}_4))$\n$T_2: ((\\mathrm{T}_1, \\mathrm{T}_3), (\\mathrm{T}_2, \\mathrm{T}_4))$\n$T_3: ((\\mathrm{T}_1, \\mathrm{T}_4), (\\mathrm{T}_2, \\mathrm{T}_3))$\n\n一个拓扑的总简约性分数是其在5个位点上分数的总和。对于一个4分类单元的树，如果一个位点将分类单元划分为两组，每组有两个成员（例如 AAGG），那么支持这种划分的拓扑需要1次改变，而另外两种拓扑需要2次改变。如果一个位点有三种或四种状态，它对于所有三种拓扑都需要相同的改变次数。\n\n我们逐个分析每个位点：\n\n**位点 1：** 状态为 $(A, A, G, G)$。\n- 这种模式将 $(\\mathrm{T}_1, \\mathrm{T}_2)$ 和 $(\\mathrm{T}_3, \\mathrm{T}_4)$ 分组。\n- 拓扑 $T_1$ $((\\mathrm{T}_1, \\mathrm{T}_2), (\\mathrm{T}_3, \\mathrm{T}_4))$ 与该模式完全匹配，需要 **1** 次改变。\n- 拓扑 $T_2$ 和 $T_3$ 与该模式不匹配，需要 **2** 次改变。\n- 分数：$T_1=1, T_2=2, T_3=2$。\n\n**位点 2：** 状态为 $(C, T, C, T)$。\n- 这种模式将 $(\\mathrm{T}_1, \\mathrm{T}_3)$ 和 $(\\mathrm{T}_2, \\mathrm{T}_4)$ 分组。\n- 拓扑 $T_2$ $((\\mathrm{T}_1, \\mathrm{T}_3), (\\mathrm{T}_2, \\mathrm{T}_4))$ 与该模式完全匹配，需要 **1** 次改变。\n- 拓扑 $T_1$ 和 $T_3$ 与该模式不匹配，需要 **2** 次改变。\n- 分数：$T_1=2, T_2=1, T_3=2$。\n\n**位点 3：** 状态为 $(G, A, A, G)$。\n- 这种模式将 $(\\mathrm{T}_1, \\mathrm{T}_4)$ 和 $(\\mathrm{T}_2, \\mathrm{T}_3)$ 分组。\n- 拓扑 $T_3$ $((\\mathrm{T}_1, \\mathrm{T}_4), (\\mathrm{T}_2, \\mathrm{T}_3))$ 与该模式完全匹配，需要 **1** 次改变。\n- 拓扑 $T_1$ 和 $T_2$ 与该模式不匹配，需要 **2** 次改变。\n- 分数：$T_1=2, T_2=2, T_3=1$。\n\n**位点 4：** 状态为 $(A, A, A, A)$。\n- 这是一个恒定位点。所有分类单元状态相同。\n- 所有拓扑都需要 **0** 次改变。\n- 分数：$T_1=0, T_2=0, T_3=0$。\n\n**位点 5：** 状态为 $(A, A, C, G)$。\n- 该位点有三种状态 (A, C, G)。\n- 对于一个4分类单元的树，任何具有3种或4种状态的位点，在所有拓扑上的简约性分数都相同。最小改变次数为 (状态数 - 1)。\n- 在此，最小改变次数为 $3-1 = 2$。\n- 所有拓扑都需要 **2** 次改变。\n- 分数：$T_1=2, T_2=2, T_3=2$。\n\n现在，我们将每个拓扑在所有位点上的分数相加，得到总简约性分数：\n\n- **拓扑 $T_1$ 总分数:** $1 + 2 + 2 + 0 + 2 = 7$\n- **拓扑 $T_2$ 总分数:** $2 + 1 + 2 + 0 + 2 = 7$\n- **拓扑 $T_3$ 总分数:** $2 + 2 + 1 + 0 + 2 = 7$\n\n这三个总简约性分数都是7。因此，这些数据无法在简约性原则下区分这三种拓扑。\n\n问题要求报告这三个总分中的最小值。\n$\\min(7, 7, 7) = 7$。",
            "answer": "$$\n\\boxed{7}\n$$"
        },
        {
            "introduction": "基因的进化历史（基因树）与物种的进化历史（物种树）并非总是一致的，二者之间的不匹配揭示了重要的进化事件，如基因重复。本练习将引导你实现一个基因树与物种树的和解算法，以区分基因谱系中的物种形成事件和基因重复事件 。这是一种在比较基因组学中至关重要的分析方法，能帮助我们理解基因家族的演化。",
            "id": "2378555",
            "problem": "给定两个有根的严格二叉分支图：一个叶节点集合为 $\\Sigma_S$ 的物种树 $S$ 和一个叶节点集合为 $\\Sigma_G$ 的基因树 $G$。每个基因叶节点 $g \\in \\Sigma_G$ 通过一个给定的函数 $m : \\Sigma_G \\to \\Sigma_S$ 映射到一个物种叶节点。对于物种树 $S$ 中的任意两个节点 $x$ 和 $y$，将其最近公共祖先 (LCA) 定义为 $\\mathrm{LCA}_S(x,y)$。定义从基因树 $G$ 的节点到物种树 $S$ 的节点的协调图 $M$：如果 $g$ 是 $G$ 的一个叶节点，则 $M(g)=m(g)$；对于 $G$ 中任意一个拥有子节点 $u$ 和 $v$ 的内部节点 $g$，定义 $M(g) = \\mathrm{LCA}_S\\!\\big(M(u), M(v)\\big)$。如果 $M(g)=M(u)$ 或 $M(g)=M(v)$，则 $G$ 的内部节点 $g$ 被标记为基因重复 (duplication)；否则，标记为物种形成 (speciation)。\n\n你的任务是编写一个完整的程序，对每个测试用例，使用上述规则将 $G$ 的每个内部节点标记为基因重复或物种形成，并以后序（左子树、右子树、然后是节点）返回一个布尔值列表。其中布尔值 $\\mathrm{True}$ 表示基因重复，布尔值 $\\mathrm{False}$ 表示物种形成。后序由 $G$ 的 Newick 格式表示所引出的从左到右的顺序确定。如果 $G$ 没有内部节点，则返回一个空列表。所有树都以不带分支长度的 Newick 格式提供。映射 $m$ 以一组键值对的形式显式提供。最终程序不得读取输入，必须使用内嵌的测试套件。\n\n共有 $4$ 个测试用例。在每个用例中，物种树 $S$、基因树 $G$ 和映射 $m$ 的指定如下：\n\n- 测试用例 $1$：\n  - $S = \\text{\"((A,B),(C,D));\"}$\n  - $G = \\text{\"((ax,bz),(cw,dx));\"}$\n  - $m = \\{\\,\\text{\"ax\"} \\mapsto \\text{\"A\"},\\, \\text{\"bz\"} \\mapsto \\text{\"B\"},\\, \\text{\"cw\"} \\mapsto \\text{\"C\"},\\, \\text{\"dx\"} \\mapsto \\text{\"D\"}\\,\\}$\n\n- 测试用例 $2$：\n  - $S = \\text{\"((A,B),(C,D));\"}$\n  - $G = \\text{\"(((ax,ay),bz),(cw,dx));\"}$\n  - $m = \\{\\,\\text{\"ax\"} \\mapsto \\text{\"A\"},\\, \\text{\"ay\"} \\mapsto \\text{\"A\"},\\, \\text{\"bz\"} \\mapsto \\text{\"B\"},\\, \\text{\"cw\"} \\mapsto \\text{\"C\"},\\, \\text{\"dx\"} \\mapsto \\text{\"D\"}\\,\\}$\n\n- 测试用例 $3$：\n  - $S = \\text{\"((A,B),(C,D));\"}$\n  - $G = \\text{\"((ax,ay),(az,aw));\"}$\n  - $m = \\{\\,\\text{\"ax\"} \\mapsto \\text{\"A\"},\\, \\text{\"ay\"} \\mapsto \\text{\"A\"},\\, \\text{\"az\"} \\mapsto \\text{\"A\"},\\, \\text{\"aw\"} \\mapsto \\text{\"A\"}\\,\\}$\n\n- 测试用例 $4$：\n  - $S = \\text{\"((A,B),(C,D));\"}$\n  - $G = \\text{\"ax;\"}$\n  - $m = \\{\\,\\text{\"ax\"} \\mapsto \\text{\"A\"}\\,\\}$\n\n你的程序应处理这 $4$ 个测试用例，并生成单行输出。该输出包含一个用方括号括起来的逗号分隔列表，其中每个元素是对应一个测试用例的布尔标签的后序列表。例如，一个有效的输出格式为 $\\text{\"[[False,True],[True],[False,False,True],[]]\"}$。不涉及物理单位或角度单位。所有布尔输出必须表示为编程语言的规范布尔字面量。每个测试用例的答案必须是一个布尔值列表，最终输出必须是这些列表组成的列表，并严格按照指定格式打印在单行上。",
            "solution": "所提出的问题是计算生物学中的一个经典算法任务：将基因树与物种树进行协调，以推断进化事件。所描述的方法是标准的最近公共祖先 (LCA) 协调法，这是一个用于解释基因系统发育与其所在的生物系统发育之间不一致性的简约模型。该解决方案需要实现几个不同但相关的算法，我们将逐步构建这些算法。\n\n该解决方案的逻辑结构如下：\n$1$. 将物种树 $S$ 和基因树 $G$ 的 Newick 字符串表示解析为计算树数据结构。\n$2$. 预处理物种树 $S$，以便能高效计算其中任意两个节点的最近公共祖先 ($\\mathrm{LCA}_S$)。\n$3$. 以后序遍历基因树 $G$，应用协调图 $M$ 来确定每个内部节点的事件（基因重复或物种形成）。\n\n让我们详细说明每个步骤。\n\n树可以使用基于节点的结构来表示，其中每个节点对象存储对其父节点和子节点的引用。节点也可以有名称，这对于叶节点至关重要。为此，我们定义一个 `Node` 类。子节点存储在一个有序列表中，以保留 Newick 格式指定的从左到右的拓扑结构。在严格二叉树中，一个内部节点恰好有 $2$ 个子节点，而一个叶节点有 $0$ 个子节点。\n\nNewick 格式的字符串必须被解析成这种 `Node` 结构。递归下降解析器非常适合这项任务。给定一个子树的 Newick 字符串，解析器操作如下：\n- 如果字符串不是以 `(` 开头，它代表一个叶节点。创建一个新的 `Node`，并将该字符串作为其名称。\n- 如果字符串的形式是 `(left,right)`，它代表一个内部节点。创建一个新的 `Node`。根据分隔两个主要子树的逗号将字符串分割成 `left` 和 `right` 部分。这需要进行括号平衡检查以找到正确的分割逗号。然后对 `left` 和 `right` 子字符串递归调用解析器，以生成子树。生成的子节点按指定顺序附加到当前节点的子节点列表中。\n\n解析物种树 $S$ 后，我们增强其结构以便进行高效的 LCA 查询。这通过遍历一次树为每个节点建立 `parent` 指针来实现。有了父指针，物种树 $S$ 中两个节点 $n_1$ 和 $n_2$ 的 $\\mathrm{LCA}_S(n_1, n_2)$ 可以通过以下方式找到：首先将 $n_1$ 的所有祖先（包括 $n_1$ 自身）收集到一个集合中。然后，从 $n_2$ 开始向上遍历，直到遇到一个存在于该集合中的节点。找到的第一个共同祖先就是 $\\mathrm{LCA}_S(n_1, n_2)$。\n\n解决方案的核心是协调算法，我们将其实现为一个递归函数，称之为 $ReconcileAndLabel(g\\_node, \\dots)$。该函数遍历基因树 $G$，并在每个节点上执行三个操作：它计算该节点在协调图 $M$ 下在 $S$ 中的像，如果节点是内部节点则对其进行分类，并返回其在 $S$ 中的映射。遍历顺序是后序（左子节点、右子节点、节点），这是递归的自然结果。\n\n函数 $ReconcileAndLabel$ 定义如下：\n- **输入**：来自基因树 $G$ 的一个节点 $g$。\n- **输出**：节点 $g$ 映射到的 $S$ 中的节点 $s$，即 $s = M(g)$。其副作用是填充一个针对内部节点的布尔标签列表。\n\n**基本情况**：如果输入节点 $g$ 是一个叶节点（即有 $0$ 个子节点），其映射 $M(g)$ 由函数 $m$ 给出。我们查找 $m(g.name)$ 以获取相应物种叶节点的名称，然后在我们解析的物种树 $S$ 中找到该叶节点的 `Node` 对象。返回此 `Node` 对象。\n\n**递归步骤**：如果输入节点 $g$ 是一个有子节点 $u$ 和 $v$ 的内部节点（在严格二叉树中，它们将是 $g.children[0]$ 和 $g.children[1]$），算法按以下步骤进行：\n$1$. 对左子节点 $u$ 递归调用函数：$s_u = ReconcileAndLabel(u, \\dots)$。\n$2$. 对右子节点 $v$ 递归调用函数：$s_v = ReconcileAndLabel(v, \\dots)$。\n$3$. 通过找到其子节点映射的 LCA 来计算当前节点 $g$ 的映射：$s_g = M(g) = \\mathrm{LCA}_S(s_u, s_v)$。\n$4$. 对节点 $g$ 处的事件进行分类。根据定义，如果 $M(g) = M(u)$ 或 $M(g) = M(v)$，则 $g$ 代表一个基因重复。在我们的实现中，这对应于检查节点对象 $s_g$ 是否与 $s_u$ 或 $s_v$ 相同。如果此条件成立，则事件为基因重复（$\\mathrm{True}$）。否则为物种形成（$\\mathrm{False}$）。\n$5$. 节点 $g$ 的这个布尔标签被附加到一个全局结果列表中。由于此步骤在对子节点的递归调用完成后发生，因此标签是以以后序序列收集的。\n$6$. 函数返回物种树节点 $s_g$。\n\n主过程为标签初始化一个空列表，然后在基因树 $G$ 的根节点上调用 $ReconcileAndLabel$。如果基因树仅由单个节点组成（根即叶），则它没有内部节点，按要求返回一个空列表。否则，填充后的标签列表就是给定测试用例的结果。对提供的每个测试用例重复此整个过程。",
            "answer": "```python\nimport numpy as np\n\n# Note: The problem environment specifies numpy and scipy as available,\n# but they are not required for this particular algorithmic problem.\n# We include the numpy import to adhere to the specified environment setup.\n\nclass Node:\n    \"\"\"Represents a node in a tree.\"\"\"\n    def __init__(self, name=None):\n        self.name = name\n        self.parent = None\n        self.children = []\n\n    def __repr__(self):\n        return f\"Node({self.name or 'internal'})\"\n\ndef parse_newick(newick_str: str) -> Node:\n    \"\"\"\n    Parses a Newick format string into a tree of Node objects.\n    Assumes strictly binary trees for internal nodes, but handles single-node trees.\n    \"\"\"\n    clean_str = newick_str.strip()\n    if clean_str.endswith(';'):\n        clean_str = clean_str[:-1]\n\n    if '(' not in clean_str:\n        # It's a single leaf node tree, e.g., \"ax\"\n        return Node(name=clean_str)\n\n    # Use a stack-based approach for robustness\n    stack = []\n    current_node = None\n    i = 0\n    while i < len(clean_str):\n        char = clean_str[i]\n        if char == '(':\n            new_node = Node()\n            if current_node:\n                current_node.children.append(new_node)\n            stack.append(new_node)\n            current_node = new_node\n        elif char == ',':\n            # Move from left sibling to parent, ready for right sibling\n            current_node = stack[-1]\n        elif char == ')':\n            # Finished with children of node on stack, pop it\n            current_node = stack.pop()\n        elif char not in ' ;':\n            # It's a name\n            name_start = i\n            while i + 1 < len(clean_str) and clean_str[i+1] not in ',)':\n                i += 1\n            name = clean_str[name_start:i+1]\n            leaf_node = Node(name=name)\n            if current_node:\n                current_node.children.append(leaf_node)\n        i += 1\n\n    return current_node or Node(name=clean_str) # Handles single node \"(A);\" case too\n\ndef add_parents(node: Node, parent: Node = None):\n    \"\"\"Recursively adds parent pointers to all nodes in a tree.\"\"\"\n    node.parent = parent\n    for child in node.children:\n        add_parents(child, node)\n\ndef collect_leaves(node: Node, leaf_map: dict):\n    \"\"\"Recursively collects leaf nodes into a dictionary mapping name to node.\"\"\"\n    if not node.children:\n        if node.name:\n            leaf_map[node.name] = node\n    else:\n        for child in node.children:\n            collect_leaves(child, leaf_map)\n\ndef get_lca(node1: Node, node2: Node) -> Node:\n    \"\"\"Finds the Least Common Ancestor of two nodes in a tree with parent pointers.\"\"\"\n    path_to_root1 = set()\n    curr = node1\n    while curr:\n        path_to_root1.add(curr)\n        curr = curr.parent\n    \n    curr = node2\n    while curr:\n        if curr in path_to_root1:\n            return curr\n        curr = curr.parent\n    # Should not be reached in a valid tree with common root\n    raise ValueError(\"Nodes do not share a common ancestor.\")\n\ndef reconcile_and_label(g_node: Node, s_leaf_map: dict, m_mapping: dict, labels: list) -> Node:\n    \"\"\"\n    Recursively traverses the gene tree, computes the reconciliation map,\n    labels internal nodes, and returns the mapped species tree node.\n    \"\"\"\n    if not g_node.children:  # Base case: g_node is a leaf\n        species_leaf_name = m_mapping[g_node.name]\n        return s_leaf_map[species_leaf_name]\n\n    # Recursive step: g_node is internal. Process children first (postorder).\n    # Newick order corresponds to children[0] (left) and children[1] (right).\n    s_map_left = reconcile_and_label(g_node.children[0], s_leaf_map, m_mapping, labels)\n    s_map_right = reconcile_and_label(g_node.children[1], s_leaf_map, m_mapping, labels)\n\n    # Compute mapping for the current node g\n    s_map_lca = get_lca(s_map_left, s_map_right)\n\n    # Classify event and record the label\n    # The check must be by object identity (is), not by value (==).\n    is_duplication = (s_map_lca is s_map_left) or (s_map_lca is s_map_right)\n    labels.append(is_duplication)\n    \n    return s_map_lca\n\ndef solve():\n    \"\"\"\n    Main function to process test cases and produce the final output.\n    \"\"\"\n    test_cases = [\n        (\n            \"((A,B),(C,D));\",\n            \"((ax,bz),(cw,dx));\",\n            {\"ax\": \"A\", \"bz\": \"B\", \"cw\": \"C\", \"dx\": \"D\"}\n        ),\n        (\n            \"((A,B),(C,D));\",\n            \"(((ax,ay),bz),(cw,dx));\",\n            {\"ax\": \"A\", \"ay\": \"A\", \"bz\": \"B\", \"cw\": \"C\", \"dx\": \"D\"}\n        ),\n        (\n            \"((A,B),(C,D));\",\n            \"((ax,ay),(az,aw));\",\n            {\"ax\": \"A\", \"ay\": \"A\", \"az\": \"A\", \"aw\": \"A\"}\n        ),\n        (\n            \"((A,B),(C,D));\",\n            \"ax;\",\n            {\"ax\": \"A\"}\n        ),\n    ]\n\n    all_results = []\n    for s_newick, g_newick, m_mapping in test_cases:\n        # 1. Prepare the species tree\n        s_root = parse_newick(s_newick)\n        add_parents(s_root)\n        s_leaf_map = {}\n        collect_leaves(s_root, s_leaf_map)\n\n        # 2. Prepare the gene tree\n        g_root = parse_newick(g_newick)\n        \n        # 3. Handle edge case of a single-node gene tree\n        if not g_root.children:\n            all_results.append([])\n            continue\n        \n        # 4. Reconcile and get postorder labels\n        labels = []\n        reconcile_and_label(g_root, s_leaf_map, m_mapping, labels)\n        all_results.append(labels)\n\n    # 5. Format and print the final output as a string representation of a list of lists.\n    # The string representation of a Python list of booleans matches the required format.\n    formatted_results = ','.join(map(str, all_results))\n    print(f\"[{formatted_results}]\")\n\nsolve()\n```"
        }
    ]
}