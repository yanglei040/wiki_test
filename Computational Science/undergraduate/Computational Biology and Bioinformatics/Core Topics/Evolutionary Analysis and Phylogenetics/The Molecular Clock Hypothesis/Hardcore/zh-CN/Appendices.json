{
    "hands_on_practices": [
        {
            "introduction": "本节练习将引导你完成一个思想实验，旨在探讨将一个简单的模型（严格分子钟）应用于一个更复杂的现实（宽松分子钟）时可能产生的后果。理解这种模型误用可能导致的系统性偏差，对于在实际研究中正确解读分子钟的定年结果至关重要。",
            "id": "2435879",
            "problem": "您正在计算生物学和生物信息学中，根据分子钟假说分析一个有根系统发育树。真实的进化过程是一个松弛分子钟，具有分支特异性的替换速率。该树有一个根，分裂成两个大的单系演化支。在演化支 F 内部，谱系以恒定速率 $r_{F}$ 演化；在演化支 S 内部，谱系以恒定速率 $r_{S}$ 演化，且 $r_{F} > r_{S}$。沿某一谱系累积的每个位点的预期替换数等于该谱系的替换速率与所用时间的乘积，以每个位点的替换数衡量的从根到末端的遗传距离反映了这一乘积。设根的真实年龄为 $t_{\\mathrm{root}}$。假设您有充足的序列数据，因此估计的遗传距离与它们的期望值非常接近。\n\n您只有一个硬校准点：在分析 I 中，您将演化支 F 的冠群（最近共同祖先，MRCA）的年龄固定为其真实值；而在分析 II 中，您则将演化支 S 的冠群（MRCA）的年龄固定为其真实值。所有其他节点的年龄都不受校准点约束。然而，在这两种分析中，您都拟合了一个严格分子钟模型，该模型在整个树上强制使用单一的替换速率 $r_{\\mathrm{strict}}$。\n\n在严格分子钟模型下，对于这两种校准点放置方式，以下哪个陈述最准确地描述了估计的根年龄相对于 $t_{\\mathrm{root}}$ 的偏差方向，并解释了原因？\n\nA. 在两种分析中，根年龄都会被高估，因为强制使用单一速率会迫使模型增加时间以适应演化较慢的谱系。\n\nB. 在两种分析中，根年龄都会被低估，因为强制使用单一速率会迫使模型减少时间以适应演化较快的谱系。\n\nC. 当校准点位于演化支 S 时，根年龄将被高估；当校准点位于演化支 F 时，根年龄将被低估。这是因为单一速率迫使时间通过遗传距离、速率和时间之间的关系来吸收谱系速率的差异。\n\nD. 在有足够数据的情况下，不存在系统性偏差；无论真实的速率变化如何，单个校准点足以在严格分子钟下确定根年龄。",
            "solution": "必须首先对问题陈述进行严格验证。\n\n**步骤1：提取已知条件**\n-   进化过程是松弛分子钟。\n-   系统发育树有一个根，分裂成两个单系演化支：演化支 F 和演化支 S。\n-   演化支 F 内的谱系以恒定速率 $r_{F}$ 演化。\n-   演化支 S 内的谱系以恒定速率 $r_{S}$ 演化。\n-   速率不相等：$r_{F} > r_{S}$。\n-   每个位点的预期替换数（遗传距离，$d$）是替换速率（$r$）和时间（$t$）的乘积：$d = r \\cdot t$。\n-   根的真实年龄为 $t_{\\mathrm{root}}$。\n-   序列数据充足，因此假设估计的遗传距离等于其真实的期望值。\n-   进行了两项分析，均使用了一个设定不当的严格分子钟模型，该模型具有单一速率 $r_{\\mathrm{strict}}$。\n-   分析 I：通过硬校准点将演化支 F 的最近共同祖先（MRCA）的年龄固定为其真实值。\n-   分析 II：通过硬校准点将演化支 S 的最近共同祖先（MRCA）的年龄固定为其真实值。\n-   问题要求在两种分析中，估计的根年龄 $t_{\\mathrm{root, est}}$ 相对于真实根年龄 $t_{\\mathrm{root}}$ 的偏差方向。\n\n**步骤2：使用提取的已知条件进行验证**\n-   **科学依据：** 该问题牢固地植根于分子系统发育学和计算生物学的原理。它描述了一个常见且被充分理解的问题：模型设定不当（将严格分子钟拟合到由松弛分子钟产生的数据）对参数估计（特别是节点年龄）的影响。\n-   **问题定义明确：** 问题定义清晰。距离、速率和时间之间的关系已明确给出。两项独立分析的条件明确无误。问题要求一个具体的、可推导的结果（偏差的方向）。\n-   **客观性：** 问题使用了该领域精确、客观的术语进行陈述。它不含主观或推测性的主张。\n\n**步骤3：结论与行动**\n问题陈述在科学上是合理的、定义明确的、客观的且自洽的。因此，它是**有效的**。我将继续进行解答。\n\n支配该系统的基本关系是遗传距离 $d$ 是替换速率 $r$ 和时间 $t$ 的乘积：\n$$d = r \\cdot t$$\n问题陈述指出，由于数据充足，估计的遗传距离准确地反映了由松弛分子钟过程产生的真实期望距离。然而，严格分子钟模型设定不当，并强制在整个树上使用单一速率 $r_{\\mathrm{strict}}$。因此，为了解释“正确”的遗传距离，模型必须调整其时间估计值 $t_{\\mathrm{est}}$。这种关系可以表示为：\n$$t_{\\mathrm{est}} = \\frac{d}{r_{\\mathrm{strict}}}$$\n$t_{\\mathrm{est}}$ 中的任何偏差都源于 $r_{\\mathrm{strict}}$ 与真实的、谱系特异性的速率 $r_{\\mathrm{true}}$ 不匹配。\n\n让我们分析这两种情景。\n\n**分析 I：在演化支 F（快速演化的演化支）上进行校准**\n\n在此分析中，演化支 F 的 MRCA 年龄被固定为其真实值，我们称之为 $t_{F}$。硬校准点迫使模型将演化支 F 内部的遗传距离与这个固定的时间相协调。考虑一个从演化支 F 的 MRCA 到该演化支内任意末端的谱系。真实经过的时间是 $t_{F}$，真实速率是 $r_{F}$。因此，遗传距离为 $d_{F, \\mathrm{internal}} = r_{F} \\cdot t_{F}$。\n\n具有单一速率 $r_{\\mathrm{strict, I}}$ 的严格分子钟模型必须在固定的时间 $t_{F}$ 内解释这个距离。因此：\n$$r_{\\mathrm{strict, I}} \\cdot t_{F} = d_{F, \\mathrm{internal}} = r_{F} \\cdot t_{F}$$\n这迫使此分析的估计速率为：\n$$r_{\\mathrm{strict, I}} = r_{F}$$\n模型采用了来自校准演化支的快速率，并将其应用于整个树。现在，我们评估根年龄。对于演化缓慢的演化支 S 中的一个谱系，其真实的从根到末端的距离由下式给出：\n$$d_{\\mathrm{S, root-tip}} = r_{S} \\cdot t_{\\mathrm{root}}$$\n严格分子钟模型使用其估计的速率 $r_{\\mathrm{strict, I}}$ 从该距离推断根年龄：\n$$t_{\\mathrm{root, est, I}} = \\frac{d_{\\mathrm{S, root-tip}}}{r_{\\mathrm{strict, I}}} = \\frac{r_{S} \\cdot t_{\\mathrm{root}}}{r_{F}}$$\n已知 $r_{F} > r_{S}$，则比率 $r_{S} / r_{F}  1$。由此得出：\n$$t_{\\mathrm{root, est, I}}  t_{\\mathrm{root}}$$\n在分析 I 中，根年龄被**低估**了。\n\n**分析 II：在演化支 S（缓慢演化的演化支）上进行校准**\n\n在此分析中，演化支 S 的 MRCA 年龄被固定为其真实值 $t_{S}$。根据与之前相同的逻辑，严格分子钟模型被迫采用这个校准演化支的速率。从 S 的 MRCA 到一个末端的真实遗传距离是 $d_{S, \\mathrm{internal}} = r_{S} \\cdot t_{S}$。模型必须满足：\n$$r_{\\mathrm{strict, II}} \\cdot t_{S} = d_{S, \\mathrm{internal}} = r_{S} \\cdot t_{S}$$\n这导致此分析的估计速率为：\n$$r_{\\mathrm{strict, II}} = r_{S}$$\n模型采用了慢速率，并将其应用于整个树。现在，我们通过考虑快速演化的演化支 F 中的一个谱系来评估根年龄。该谱系的真实从根到末端的距离是：\n$$d_{\\mathrm{F, root-tip}} = r_{F} \\cdot t_{\\mathrm{root}}$$\n严格分子钟模型使用其估计的速率 $r_{\\mathrm{strict, II}}$ 从该距离推断根年龄：\n$$t_{\\mathrm{root, est, II}} = \\frac{d_{\\mathrm{F, root-tip}}}{r_{\\mathrm{strict, II}}} = \\frac{r_{F} \\cdot t_{\\mathrm{root}}}{r_{S}}$$\n已知 $r_{F} > r_{S}$，则比率 $r_{F} / r_{S}  1$。由此得出：\n$$t_{\\mathrm{root, est, II}}  t_{\\mathrm{root}}$$\n在分析 II 中，根年龄被**高估**了。\n\n现在，我们评估所提供的选项。\n\n**A. 在两种分析中，根年龄都会被高估，因为强制使用单一速率会迫使模型增加时间以适应演化较慢的谱系。**\n这个陈述是**不正确的**。根据推导，当校准点位于快速演化的演化支 F 时，根年龄被低估，而不是高估。所提供的推理也是有缺陷的；它只考虑了模型设定不当影响的一方面。\n\n**B. 在两种分析中，根年龄都会被低估，因为强制使用单一速率会迫使模型减少时间以适应演化较快的谱系。**\n这个陈述是**不正确的**。根据推导，当校准点位于缓慢演化的演化支 S 时，根年龄被高估，而不是低估。同样，其推理是片面的，没有捕捉到完整的动态过程。\n\n**C. 当校准点位于演化支 S 时，根年龄将被高估；当校准点位于演化支 F 时，根年龄将被低估。这是因为单一速率迫使时间通过遗传距离、速率和时间之间的关系来吸收谱系速率的差异。**\n这个陈述是**正确的**。我的推导证实了结论的两个部分。\n1.  在演化支 S（慢速率 $r_S$）中校准导致 $t_{\\mathrm{root, est, II}}  t_{\\mathrm{root}}$（高估）。\n2.  在演化支 F（快速率 $r_F$）中校准导致 $t_{\\mathrm{root, est, I}}  t_{\\mathrm{root}}$（低估）。\n所提供的推理也是正确和简洁的。模型设定不当在固定的遗传距离（$d$）和强制的单一速率（$r_{\\mathrm{strict}}$）之间造成了矛盾。为了满足方程 $d = r_{\\mathrm{strict}} \\cdot t_{\\mathrm{est}}$，估计的时间（$t_{\\mathrm{est}}$）必须补偿 $r_{\\mathrm{strict}}$ 中的误差。\n\n**D. 在有足够数据的情况下，不存在系统性偏差；无论真实的速率变化如何，单个校准点足以在严格分子钟下确定根年龄。**\n这个陈述是**不正确的**。这是关于统计建模的一个根本性错误断言。充足的数据确保了输入（遗传距离）的准确性，但它不能也无法纠正一个设定不当的底层模型（严格分子钟 vs. 松弛分子钟）。正如所证明的，在存在速率异质性的情况下，选择在何处放置单个校准点，会对未校准节点的年龄估计引入可预测的系统性偏差。",
            "answer": "$$\\boxed{C}$$"
        },
        {
            "introduction": "在理解了潜在的理论陷阱之后，一项关键的实践技能便是能够通过计算来验证一个系统发育树是否符合严格分子钟的假设。本练习将指导你编写一个程序来检验超度量性（ultrametricity）——这是严格分子钟树的核心数学属性，从而将抽象的理论直接转化为一个实用的分析工具。",
            "id": "2435884",
            "problem": "您的任务是验证严格分子钟假说，该假说应用于以带有分支长度的Newick格式表示的有根系统发育树。在严格分子钟模型下，如果所有分类单元（taxa）都是同时代采样的，那么从根节点到任意叶节点的每个位点累积的预期替换数是相等的。这是因为瞬时替换率（以 $r$ 表示）被假定在所有时间和谱系中都是恒定的，而这类树中的分支长度代表了每个位点的预期替换数，该值与流逝的时间成正比。因此，在一个现存叶节点均为同时代的有根树中，每个根到叶的路径长度应该在数值容差范围内相等。\n\n基本原理：\n- 在一个时间同质的泊松过程中，如果每个位点的替换率恒为 $r$，那么在长度为 $t$ 的时间间隔内，预期的替换数是 $rt$。在一个叶节点均为同时代的有根树中，从根到每个叶节点所流逝的时间是相同的，假设为 $T$，因此沿着任一根到叶路径的总预期替换数是 $rT$。由于分支长度编码了每个位点的预期替换数，对于一个严格分子钟树，沿任意根到叶路径的分支长度之和对于所有叶节点都应该是相等的。\n\n本任务的定义：\n- 一个Newick格式的有根带权树定义了一组带标签的叶节点（tips），每条边都带有一个非负长度，该长度等于该边每个位点的预期替换数。\n- 对于每个叶节点 $i$，令 $L_i$ 为总的根到叶长度，定义为从根到该叶节点的唯一路径上所有分支长度的总和。\n- 给定一个非负容差 $\\epsilon$，如果 $\\max_i L_i - \\min_i L_i \\le \\epsilon$，则该树被声明为超度量的（ultrametric）。\n- 如果树不是超度量的，定义中位根到叶长度 $\\tilde{L}$ 为 $\\{L_i\\}$ 的中位数。最不符合时钟模型的谱系是其绝对偏差 $|L_i - \\tilde{L}|$ 最大的叶节点。如果出现平局，选择标签按字典序最小的谱系。\n- 为了使输出无需字符串即可进行机器校验，按如下方式为叶节点定义一个索引映射：列出所有叶节点标签，按字典升序排序，并按顺序分配索引 $0,1,2,\\dots$。报告最不符合时钟模型的谱系的索引。如果树是超度量的，则报告谱系索引为 $-1$，偏差为 $0.0$。\n\n您的程序必须：\n- 将带有分支长度的有根Newick树字符串解析为内部表示。输入字符串将是语法有效的Newick格式，并且始终是有根的。您必须正确处理多歧分叉（度大于$2$的节点）、叶节点和内部节点，每个节点都可能带有标签。所有分支长度都是非负实数，且所有叶节点都有标签。\n- 计算所有根到叶的长度 $\\{L_i\\}$。\n- 使用容差 $\\epsilon$ 判断超度量性。\n- 如果不是超度量的，则按上述定义识别最不符合时钟模型的谱系，并计算其最大绝对偏差 $d^\\star = \\max_i |L_i - \\tilde{L}|$。\n- 对于每个测试用例，输出一个三元组 `[u,k,d]`，其中 $u$ 是一个布尔值，表示是否为超度量树；$k$ 是如上定义的整数谱系索引；$d$ 是浮点数 $d^\\star$。如果 $u$ 为真，则输出 $k=-1$ 和 $d=0.0$。使用标准四舍五入将 $d$ 保留到 $6$ 位小数。\n\n角度单位不适用。分支长度的单位是每个位点的预期替换数。输出是如上指定的无单位数值数据。\n\n测试套件：\n使用以下测试用例，每个用例指定为一个元组 $(\\text{Newick}, \\epsilon)$。\n- 案例 1 (严格超度量，平衡二叉树)：\n  - Newick: $((A:0.1,B:0.1):0.2,C:0.3);$\n  - $\\epsilon = 10^{-9}$\n- 案例 2 (非超度量，一个谱系更长)：\n  - Newick: $((A:0.1,B:0.2):0.2,C:0.3);$\n  - $\\epsilon = 10^{-6}$\n- 案例 3 (在容差范围内近似超度量)：\n  - Newick: $((A:0.1,B:0.1):0.2,C:0.3000004);$\n  - $\\epsilon = 5\\times 10^{-7}$\n- 案例 4 (单叶有根树)：\n  - Newick: $(A:0.5);$\n  - $\\epsilon = 10^{-9}$\n- 案例 5 (有根多歧分叉，一个叶节点稍长)：\n  - Newick: $(A:0.2,B:0.2,C:0.21,D:0.2);$\n  - $\\epsilon = 0.005$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素按上述顺序对应一个测试用例的结果。每个测试用例的结果本身必须是形如 `[u,k,d]` 的列表。例如，包含两个假设案例的输出应如下所示：$[[\\text{True},-1,0.0],[\\text{False},1,0.123456]]$。",
            "solution": "该问题陈述清晰、有科学依据且客观。它基于进化生物学中的一个基本概念——分子钟假说，提出了一个明确的计算任务。所有术语，如Newick格式、根到叶长度和超度量性，都得到了精确定义。输入、预期输出和评估标准（包括平局打破规则）都得到了明确规定。因此，该问题是有效的，可以构建解决方案。\n\n解决方案通过遵循一系列逻辑步骤来实现：\n1.  **树解析**：代表有根系统发育树的Newick格式字符串必须被解析为合适的内存数据结构。这里采用了一种递归下降的解析策略。树使用一个 `Node` 类来表示，其中每个实例存储其名称（如果有）、通向它的分支的长度以及对其父节点和子节点的引用。解析器首先分割根节点的子节点，然后递归调用一个函数来解析每个子节点的子树字符串。这种方法能正确处理嵌套结构和多歧分叉。\n\n2.  **根到叶长度计算**：一旦树被解析，就需要计算每个叶节点 $i$ 的根到叶距离 $L_i$。这通过从树的根节点开始的深度优先遍历来实现。函数 `_get_root_to_tip_lengths` 递归地遍历树，累加每条路径上的分支长度。当到达一个叶节点时，其名称和总路径长度被存储下来。结果是树中所有叶节点的一组 $(name_i, L_i)$ 对。\n\n3.  **超度量性测试**：分子钟假说意味着，在一个具有同时代叶节点的完美时钟树中，所有根到叶的路径应具有相等的长度。这一特性被称为超度量性。为了测试这一点，我们计算最大和最小根到叶长度之间的差值 $\\max_i L_i - \\min_i L_i$。如果这个差值小于或等于给定的容差 $\\epsilon$，则该树被认为是超度量的。在这种情况下，根据问题规范，结果记录为超度量（$u=\\text{True}$），谱系索引为 $k=-1$，偏差为 $d=0.0$。\n\n4.  **非超度量分析**：如果树未能通过超度量性测试（$\\max_i L_i - \\min_i L_i  \\epsilon$），则声明其为非超度量的（$u=\\text{False}$）。根据问题定义，我们必须识别出最不符合时钟模型的谱系。这涉及以下步骤：\n    a.  从所有 $\\{L_i\\}$ 的集合中计算中位根到叶长度 $\\tilde{L}$。`numpy.median` 函数用于此计算，它能正确处理奇数和偶数个元素的情况。\n    b.  对于每个叶节点 $i$，计算其路径长度与中位数的绝对偏差：$|L_i - \\tilde{L}|$。\n    c.  确定这些偏差的最大值 $d^\\star = \\max_i |L_i - \\tilde{L}|$。该值使用Python内置的 `round()` 函数四舍五入到6位小数，对应于输出值 $d$。\n    d.  识别与此最大偏差对应的谱系。如果出现平局（多个谱系表现出相同的最大偏差），问题规定了一个平局打破规则：选择标签按字典序最小的谱系。\n    e.  最后，必须确定所选谱系的索引 $k$。通过将所有叶节点标签按字典序排序并分配索引 $0, 1, 2, \\dots$ 来创建一个索引映射。所选谱系标签在此排序列表中的索引即为值 $k$。\n\n5.  **输出生成**：为每个测试用例生成一个三元组 $[u,k,d]$。这些三元组被收集到一个列表中。最终输出是一个表示这些结果三元组列表的单个字符串，其格式严格按照规定，例如 `[[True,-1,0.0],[False,1,0.100000]]`。",
            "answer": "```python\nimport numpy as np\n\nclass Node:\n    \"\"\"Represents a node in a phylogenetic tree.\"\"\"\n    def __init__(self, name=\"\", length=0.0):\n        self.name = name\n        self.length = length  # Branch length from parent to this node\n        self.parent = None\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\ndef _split_newick_children(s: str) - list[str]:\n    \"\"\"Splits a Newick string section into its top-level children.\"\"\"\n    if not s:\n        return []\n    children = []\n    paren_level = 0\n    start = 0\n    for i, char in enumerate(s):\n        if char == '(':\n            paren_level += 1\n        elif char == ')':\n            paren_level -= 1\n        elif char == ',' and paren_level == 0:\n            children.append(s[start:i])\n            start = i + 1\n    children.append(s[start:])\n    return children\n\ndef _parse_newick_string(s: str) - Node:\n    \"\"\"Recursively parses a Newick string component into a Node object.\"\"\"\n    s = s.strip()\n    \n    # Check for internal node syntax (e.g., (...)label:length)\n    if s.startswith('(') and s.endswith(')'):\n        # This is a special case of a whole subtree being passed without label/length\n        content = s[1:-1]\n        node = Node()\n        children_strings = _split_newick_children(content)\n        for child_s in children_strings:\n            child_node = _parse_newick_string(child_s)\n            node.add_child(child_node)\n        return node\n    \n    label_part = \"\"\n    length_part = \"\"\n    content = \"\"\n\n    last_paren = s.rfind(')')\n    if last_paren != -1: # Internal node\n        content = s[1:last_paren]\n        label_len_part = s[last_paren+1:]\n        if ':' in label_len_part:\n            label_part, length_part = label_len_part.split(':', 1)\n        else:\n            label_part = label_len_part\n    else: # Leaf node\n        if ':' in s:\n            label_part, length_part = s.split(':', 1)\n        else:\n            label_part = s\n    \n    name = label_part.strip()\n    length = float(length_part) if length_part else 0.0\n    \n    node = Node(name=name, length=length)\n\n    if last_paren != -1: # If internal, parse its children\n        children_strings = _split_newick_children(content)\n        for child_s in children_strings:\n            child_node = _parse_newick_string(child_s)\n            node.add_child(child_node)\n            \n    return node\n\ndef parse_newick(newick_str: str) - Node:\n    \"\"\"Parses a full Newick string into a tree of Node objects.\"\"\"\n    if newick_str.endswith(';'):\n        newick_str = newick_str[:-1]\n    \n    root = _parse_newick_string(newick_str)\n    return root\n\ndef _get_root_to_tip_lengths(node: Node, current_length: float, lengths: dict):\n    \"\"\"Recursively traverses the tree to calculate all root-to-tip lengths.\"\"\"\n    path_len = current_length + node.length\n\n    if not node.children:  # It's a leaf\n        if node.name:\n            lengths[node.name] = path_len\n        return\n\n    for child in node.children:\n        _get_root_to_tip_lengths(child, path_len, lengths)\n\ndef process_tree(newick_str: str, epsilon: float) - list:\n    \"\"\"Processes a single tree to check for ultrametricity and non-clock-like lineages.\"\"\"\n    root = parse_newick(newick_str)\n    \n    leaf_lengths = {}\n    _get_root_to_tip_lengths(root, 0.0, leaf_lengths)\n    \n    if not leaf_lengths:\n        return [True, -1, 0.0]\n\n    lengths = list(leaf_lengths.values())\n    max_len = max(lengths)\n    min_len = min(lengths)\n\n    if max_len - min_len = epsilon:\n        return [True, -1, 0.0]\n    else: # Not ultrametric\n        u = False\n        median_l = np.median(lengths)\n        \n        deviations = {name: abs(length - median_l) for name, length in leaf_lengths.items()}\n        \n        max_deviation = -1.0\n        for dev in deviations.values():\n            if dev > max_deviation:\n                max_deviation = dev\n        \n        # Tie-breaking: find all candidates with max deviation, then choose lexicographically smallest name\n        candidates = []\n        # Use a small tolerance for floating point comparison\n        for name, dev in deviations.items():\n            if abs(dev - max_deviation)  1e-12:\n                candidates.append(name)\n        \n        chosen_lineage = sorted(candidates)[0]\n        \n        sorted_labels = sorted(leaf_lengths.keys())\n        k = sorted_labels.index(chosen_lineage)\n        \n        d = round(max_deviation, 6)\n        \n        return [u, k, d]\n\n\ndef solve():\n    \"\"\"Main function to run the test suite and format the output.\"\"\"\n    test_cases = [\n        (\"((A:0.1,B:0.1):0.2,C:0.3);\", 1e-9),\n        (\"((A:0.1,B:0.2):0.2,C:0.3);\", 1e-6),\n        (\"((A:0.1,B:0.1):0.2,C:0.3000004);\", 5e-7),\n        (\"(A:0.5);\", 1e-9),\n        (\"(A:0.2,B:0.2,C:0.21,D:0.2);\", 0.005)\n    ]\n\n    results = []\n    for newick_str, epsilon in test_cases:\n        result = process_tree(newick_str, epsilon)\n        results.append(result)\n\n    formatted_results = []\n    for res in results:\n        u, k, d = res\n        # Manual formatting to match problem example (no spaces, Python bool literals)\n        formatted_results.append(f\"[{u},{k},{d}]\")\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "当真实数据违背了严格分子钟的假设时，我们就需要转向更复杂的宽松分子钟模型。这项高级练习将带你深入探索一种常用的宽松分子钟模型，指导你模拟树上进化速率的变化过程，并像生物信息学家一样从模拟数据中恢复出模型的原始参数。这个过程将帮助你从第一性原理出发，建立对这些强大模型的深刻理解。",
            "id": "2435895",
            "problem": "您需要实现一个完整、可运行的程序，该程序在一个固定的有根树上，在具有自相关速率的松弛分子钟下，模拟替换率的演化，然后直接从第一性原理出发恢复生成数据的参数。该模型是沿着每个分支的速率对数上的带线性漂移的几何布朗运动。具体来说，设节点 $v$ 处的瞬时替换率为 $r_{v}$。定义对数速率 $x_{v} = \\log r_{v}$。对于任何从父节点 $p$ 到子节点 $c$、持续时间为 $t$ 的分支，其条件演化由下式给出：\n$$\nx_{c} \\mid x_{p} \\sim \\mathcal{N}\\left(x_{p} + \\delta \\, t,\\ \\sigma^{2} \\, t\\right),\n$$\n其中 $\\delta$ 是漂移参数（单位时间内的对数速率），$\\sigma^{2}$ 是扩散方差（单位时间内的对数速率的平方）。该过程从根节点开始，其 $x_{\\text{root}} = \\mu_{0}$，其中 $\\mu_{0}$ 是一个指定的常数，而不是一个待估计的参数。在给定其父节点状态的条件下，不同分支上的所有抽样都是条件独立的。\n\n使用以下具有节点索引和分支时长的固定有根树。根节点为节点 $0$。每个元组为（父节点，子节点，时间）：\n- $(0, 1, 1.0)$\n- $(1, 3, 0.7)$\n- $(1, 4, 0.4)$\n- $(0, 2, 0.5)$\n- $(2, 5, 0.6)$\n- $(5, 6, 0.9)$\n- $(5, 7, 0.3)$\n\n所有时间都以任意但一致的单位度量；无需单位转换。共有 $8$ 个节点和 $7$ 个分支。\n\n您的程序必须：\n- 对于每个测试用例，使用指定的参数 $(\\delta, \\sigma^{2}, \\mu_{0})$ 在树的所有节点上模拟对数速率 $x_{v}$ 的一次实现。模拟必须是可复现的：为第一个测试用例初始化一个种子为 $42$ 的伪随机数生成器，对于索引为 $i$（从 $0$ 开始）的测试用例，使用种子 $42 + i$。\n- 从模拟数据中，通过将观测数据视为树中所有分支 $e$ 上所有父子对数速率差 $\\Delta_{e} = x_{c} - x_{p}$ 及其相应分支时长 $t_{e}$ 的集合，来恢复漂移参数 $\\delta$ 和方差参数 $\\sigma^{2}$。恢复的值必须是能够最好地解释上述模型下模拟出的差异的参数，并以实数形式表示。\n\n测试套件：\n- 案例 1：$(\\delta, \\sigma^{2}, \\mu_{0}) = (0.0,\\ 0.2,\\ 0.0)$\n- 案例 2：$(\\delta, \\sigma^{2}, \\mu_{0}) = (-0.3,\\ 0.5,\\ -0.357)$\n- 案例 3：$(\\delta, \\sigma^{2}, \\mu_{0}) = (0.2,\\ 0.01,\\ 0.0)$\n\n输出规范：\n- 对于每个测试用例，输出恢复的漂移和方差，形式为列表 $[\\widehat{\\delta}, \\widehat{\\sigma^{2}}]$，每个值四舍五入到 $6$ 位小数。\n- 将所有测试用例的结果汇总为单行打印到标准输出，格式为用方括号括起来的逗号分隔列表，其中每个元素本身是一个包含两个元素的列表，例如：$[[a_{1},b_{1}],[a_{2},b_{2}],[a_{3},b_{3}]]$。\n- 最终输出必须严格遵守此格式且只有一行，除了有效的逗号分隔和括号所必需的字符外，不得包含任何多余的字符或空白。\n\n不提供外部输入；所有参数、树和测试套件都在程序中固定。最终答案必须是指定格式的实值浮点数，输出中不需要单位。",
            "solution": "用户提供的问题是有效的。它在计算生物学领域有科学依据，具体涉及分子演化模型。该问题是适定 (well-posed) 的，提供了生成模型的完整描述、固定的数据集结构（一个系统发育树）以及一个明确的任务：从模型中模拟数据，然后使用从第一性原理推导出的统计估计程序来恢复模型参数。问题陈述是客观、精确的，并且不包含矛盾或模糊之处。\n\n该问题分两个阶段解决：首先，在提供的系统发育树上模拟替换率的演化；其次，从模拟数据中估计模型的参数。\n\n**1. 速率演化的模拟**\n\n该模型描述了在一棵有根树的分支上，替换率的对数 $x_v = \\log r_v$ 的演化过程。该演化遵循带漂移的几何布朗运动。对于连接父节点 $p$ 和子节点 $c$ 的任意一个时长为 $t$ 的分支，子节点的对数速率 $x_c$ 在给定父节点的对数速率 $x_p$ 的条件下，遵循以下关系：\n$$\nx_{c} \\mid x_{p} \\sim \\mathcal{N}\\left(x_{p} + \\delta t,\\ \\sigma^{2} t\\right)\n$$\n此处，$\\delta$ 表示单位时间内的对数速率漂移，$\\sigma^2$ 是单位时间内扩散过程的方差。这意味着 $x_c$ 的值可以通过从指定的正态分布中抽样生成。一个随机变量 $Y \\sim \\mathcal{N}(\\mu, \\sigma_{\\text{var}}^2)$ 可以表示为 $Y = \\mu + \\sqrt{\\sigma_{\\text{var}}^2} \\cdot Z$，其中 $Z \\sim \\mathcal{N}(0, 1)$ 是一个标准正态变量。将此应用于我们的模型，我们得到生成方程：\n$$\nx_c = (x_p + \\delta t) + \\sqrt{\\sigma^2 t} \\cdot Z = x_p + \\delta t + \\sigma \\sqrt{t} \\cdot Z\n$$\n模拟通过遍历树来进行，从根节点（节点 0）开始。根节点的初始对数速率给定为 $x_{\\text{root}} = x_0 = \\mu_0$。所有其他节点 $v$ 的 $x_v$ 值是顺序计算的。由于树的结构是固定的，并以从父节点到子节点的有向边列表形式提供，我们可以在知道其父节点的对数速率后，计算每个子节点的对数速率。该过程需要一个伪随机数生成器来为 $Z$ 抽样。为保证可复现性，对于第 $i$ 个测试用例（$i$ 从 0 开始索引），生成器的种子设置为 $42+i$。\n\n指定的树有 $8$ 个节点（编号 $0$ 到 $7$）和 $7$ 个分支：\n- $(0, 1, 1.0)$, $(1, 3, 0.7)$, $(1, 4, 0.4)$, $(0, 2, 0.5)$, $(2, 5, 0.6)$, $(5, 6, 0.9)$, $(5, 7, 0.3)$\n模拟算法如下：\n1. 对于给定的测试用例 $(\\delta, \\sigma^2, \\mu_0)$ 和种子，初始化大小为 $8$ 的对数速率数组 `x_values`。\n2. 设置根节点的对数速率：`x_values[0]` $= \\mu_0$。\n3. 遍历分支列表 $(p, c, t)$。对于每个分支：\n   a. 获取父节点的对数速率，$x_p =$ `x_values[p]`。\n   b. 从 $\\mathcal{N}(0, 1)$ 中抽取一个样本 $Z$。\n   c. 计算子节点的对数速率：$x_c = x_p + \\delta t + \\sigma \\sqrt{t} \\cdot Z$。\n   d. 存储该值：`x_values[c]` $= x_c$。\n处理完所有 $7$ 个分支后，`x_values` 数组包含该过程在树上的一次完整实现。\n\n**2. 从模拟数据中进行参数估计**\n\n问题的第二部分是从模拟的对数速率 $\\{x_v\\}$ 中恢复参数 $\\delta$ 和 $\\sigma^2$。问题指定估计应基于父子对数速率差的集合 $\\Delta_e = x_c - x_p$ 及其相应的分支时长 $t_e$。\n\n根据生成模型，这个差值的分布是：\n$$\n\\Delta_e = x_c - x_p \\sim \\mathcal{N}(\\delta t_e, \\sigma^2 t_e)\n$$\n我们的任务是找到能最好地解释观测数据的参数。这通过最大似然估计（MLE）来实现。在给定父节点值的条件下，每个分支的抽样是条件独立的。因此，在所有 $N=7$ 个分支上观测到所有差值集合 $\\{\\Delta_e\\}$ 的总似然是各个概率密度的乘积：\n$$\nL(\\delta, \\sigma^2 \\mid \\{\\Delta_e, t_e\\}) = \\prod_{e=1}^{N} \\frac{1}{\\sqrt{2\\pi \\sigma^2 t_e}} \\exp\\left(-\\frac{(\\Delta_e - \\delta t_e)^2}{2\\sigma^2 t_e}\\right)\n$$\n最大化对数似然 $\\ell = \\log L$ 更为方便：\n$$\n\\ell(\\delta, \\sigma^2) = \\sum_{e=1}^{N} \\left[ -\\frac{1}{2}\\log(2\\pi) - \\frac{1}{2}\\log(\\sigma^2) - \\frac{1}{2}\\log(t_e) - \\frac{(\\Delta_e - \\delta t_e)^2}{2\\sigma^2 t_e} \\right]\n$$\n$$\n\\ell(\\delta, \\sigma^2) = C - \\frac{N}{2}\\log(\\sigma^2) - \\frac{1}{2\\sigma^2} \\sum_{e=1}^{N} \\frac{(\\Delta_e - \\delta t_e)^2}{t_e}\n$$\n其中 $C$ 包含不依赖于 $\\delta$ 或 $\\sigma^2$ 的项。\n\n为了找到 $\\delta$ 的最大似然估计（MLE），记为 $\\widehat{\\delta}$，我们将 $\\ell$ 对 $\\delta$ 求偏导数并令其为零：\n$$\n\\frac{\\partial \\ell}{\\partial \\delta} = - \\frac{1}{2\\sigma^2} \\sum_{e=1}^{N} \\frac{2(\\Delta_e - \\delta t_e)(-t_e)}{t_e} = \\frac{1}{\\sigma^2} \\sum_{e=1}^{N} (\\Delta_e - \\delta t_e) = 0\n$$\n$$\n\\sum_{e=1}^{N} \\Delta_e - \\widehat{\\delta} \\sum_{e=1}^{N} t_e = 0 \\implies \\widehat{\\delta} = \\frac{\\sum_{e=1}^{N} \\Delta_e}{\\sum_{e=1}^{N} t_e}\n$$\n$\\delta$ 的估计量是所有分支上对数速率的总变化量除以所有分支的总时长。\n\n为了找到 $\\sigma^2$ 的最大似然估计（MLE），记为 $\\widehat{\\sigma^2}$，我们将 $\\ell$ 对 $\\sigma^2$ 求偏导数并令其为零，同时将 $\\delta$ 替换为 $\\widehat{\\delta}$：\n$$\n\\frac{\\partial \\ell}{\\partial \\sigma^2} = -\\frac{N}{2\\sigma^2} + \\frac{1}{2(\\sigma^2)^2} \\sum_{e=1}^{N} \\frac{(\\Delta_e - \\widehat{\\delta} t_e)^2}{t_e} = 0\n$$\n$$\n-N\\sigma^2 + \\sum_{e=1}^{N} \\frac{(\\Delta_e - \\widehat{\\delta} t_e)^2}{t_e} = 0 \\implies \\widehat{\\sigma^2} = \\frac{1}{N} \\sum_{e=1}^{N} \\frac{(\\Delta_e - \\widehat{\\delta} t_e)^2}{t_e}\n$$\n这是加权残差平方的样本均值，其中分支 $e$ 的残差为 $(\\Delta_e - \\widehat{\\delta} t_e)$，权重为 $1/t_e$。\n\n实现将首先为每个测试用例执行模拟以生成 `x_values`，然后应用这些推导出的公式从模拟数据中计算 $\\widehat{\\delta}$ 和 $\\widehat{\\sigma^2}$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Simulates rate evolution on a fixed tree and recovers the model parameters.\n    \"\"\"\n    \n    # Define the fixed tree structure as a list of (parent, child, time) tuples.\n    # The tree has 8 nodes (0-7) and 7 branches. Node 0 is the root.\n    branches = [\n        (0, 1, 1.0),\n        (1, 3, 0.7),\n        (1, 4, 0.4),\n        (0, 2, 0.5),\n        (2, 5, 0.6),\n        (5, 6, 0.9),\n        (5, 7, 0.3),\n    ]\n    num_nodes = 8\n    num_branches = len(branches)\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (delta, sigma_squared, mu_0)\n    test_cases = [\n        (0.0, 0.2, 0.0),\n        (-0.3, 0.5, -0.357),\n        (0.2, 0.01, 0.0),\n    ]\n\n    results = []\n    \n    for i, case in enumerate(test_cases):\n        delta, sigma_sq, mu_0 = case\n        \n        # --- 1. Simulation Phase ---\n        \n        # Initialize the pseudo-random number generator with the specified seed for reproducibility.\n        seed = 42 + i\n        rng = np.random.default_rng(seed)\n        \n        # Array to store the simulated log-rates at each node.\n        x_values = np.zeros(num_nodes)\n        \n        # Set the log-rate at the root.\n        x_values[0] = mu_0\n        \n        # The standard deviation parameter is the square root of the variance.\n        sigma = np.sqrt(sigma_sq)\n        \n        # Traverse the tree and simulate the log-rate for each child node.\n        for p, c, t in branches:\n            # Parent's log-rate\n            x_p = x_values[p]\n            \n            # Draw from a standard normal distribution N(0, 1).\n            Z = rng.normal(0, 1)\n            \n            # Calculate the child's log-rate using the model's generative equation.\n            # x_c = x_p + delta*t + sigma*sqrt(t)*Z\n            x_c = x_p + delta * t + sigma * np.sqrt(t) * Z\n            \n            # Store the child's log-rate.\n            x_values[c] = x_c\n\n        # --- 2. Parameter Recovery Phase ---\n        \n        # Calculate the log-rate differences (Delta_e) and branch durations (t_e).\n        delta_e_list = []\n        t_e_list = []\n        for p, c, t in branches:\n            delta_e_list.append(x_values[c] - x_values[p])\n            t_e_list.append(t)\n            \n        # Calculate the MLE for delta (drift).\n        # delta_hat = (sum of Delta_e) / (sum of t_e)\n        sum_delta_e = np.sum(delta_e_list)\n        sum_t_e = np.sum(t_e_list)\n        delta_hat = sum_delta_e / sum_t_e\n        \n        # Calculate the MLE for sigma^2 (variance).\n        # sigma_sq_hat = (1/N) * sum[ (Delta_e - delta_hat * t_e)^2 / t_e ]\n        ssr = 0.0\n        for delta_e, t_e in zip(delta_e_list, t_e_list):\n            residual = delta_e - delta_hat * t_e\n            ssr += (residual ** 2) / t_e\n        \n        sigma_sq_hat = ssr / num_branches\n        \n        # Store the recovered parameters for this test case.\n        results.append([delta_hat, sigma_sq_hat])\n\n    # --- 3. Final Output Formatting ---\n    \n    # Build the final output string in the exact required format.\n    # Example: [[a1,b1],[a2,b2],[a3,b3]]\n    output_parts = []\n    for res in results:\n        # Format each number to 6 decimal places.\n        inner_part = f\"[{res[0]:.6f},{res[1]:.6f}]\"\n        output_parts.append(inner_part)\n        \n    final_output = f\"[{','.join(output_parts)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        }
    ]
}