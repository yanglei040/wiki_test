{
    "hands_on_practices": [
        {
            "introduction": "深入理解算法的最佳方式之一是亲手实现它。本练习将引导你从基本定义出发，逐步构建UPGMA算法。通过这个过程，你将掌握其核心机制：迭代合并最近的簇，并使用算术平均法则更新距离矩阵。这项实践旨在为你后续更深入地分析和评估该方法奠定坚实的编程和概念基础。",
            "id": "2439017",
            "problem": "给定三个源自蛋白质结构之间均方根偏差 (RMSD) 值的对称成对相异性矩阵。RMSD 是一种以埃 (Å) 为单位测量的非负相异性。请实现非加权对组平均法 (UPGMA)，这是一种凝聚式、有根的层次聚类方法，它假设一个恒定速率（超度量）模型，通过构建一棵超度量树将蛋白质分组为结构族。您的程序必须计算完整的合并序列，并为每次合并报告被合并的两个簇的索引、它们合并时的共表型高度（单位为 Å）以及新形成的簇的大小。\n\n使用的基本依据和规则：\n- 从相异性矩阵的定义开始：一个对称矩阵 $D$，其条目满足 $d(i,j) \\ge 0$, $d(i,i) = 0$, 以及 $d(i,j) = d(j,i)$，编码了项目之间的成对相异性。\n- 在每次迭代中，选择具有最小簇间相异性的两个活跃簇并将它们合并。\n- 新合并的簇与任何剩余簇之间的距离必须定义为其成员之间所有成对距离的算术平均值。\n- 一次合并的共表型高度定义为合并时两个簇之间相异性的一半，以埃为单位表示。\n- 确定性要求：\n  - 最小簇间相异性的平局必须通过选择字典序中最小的有序标签对来打破。\n  - $n$个独立蛋白质的初始标签为 $0,1,\\dots,n-1$。\n  - 每次创建一个新簇时，从$n$开始，按递增顺序为其分配下一个未使用的整数标签。\n  - 报告合并时，始终按升序排列两个标签。\n- 将每次合并报告为一个包含四个数字的列表 $[a,b,h,s]$，其中 $a$ 和 $b$ 是被合并簇的标签且 $a  b$。",
            "solution": "问题陈述在科学上是合理的，阐述清晰，并为非加权对组平均法（UPGMA）算法提供了完整、明确的规范。其验证成功，我将继续提供完整解决方案。\n\nUPGMA 算法是一种凝聚式层次聚类方法。它从将 $n$ 个项目中的每一个都视为其自身的簇开始。在每一步中，两个最接近的簇被合并成一个新的、更大的簇。这个过程重复进行，直到只剩下一个包含所有 $n$ 个项目的簇。结果是一棵有根二叉树，或称树状图，其中分支长度代表进化或结构距离。UPGMA 假定具有超度量属性，意味着所有叶子（原始项目）都与根等距，这对应于一个恒定的变化率（在系统发育学中是分子钟假说，在这里是均匀的结构差异）。\n\n该算法的核心包括以下步骤：\n$1$. **初始化**：从 $n$ 个簇开始，每个簇包含一个初始项目。簇的大小为 $|C_i| = 1$，对于 $i \\in \\{0, 1, ..., n-1\\}$。这些初始簇之间的相异性由输入矩阵 $D$ 给出，其中 $d(i, j)$ 是项目 $i$ 和项目 $j$ 之间的相异性。\n$2$. **迭代**：重复 $n-1$ 步：\n    a. **寻找最近对**：识别具有最小相异性 $d(i, j)$ 的一对活跃簇 $(i, j)$。问题指定了平局打破规则：如果多个对共享相同的最小相异性，则选择其标签 $(a, b)$（其中 $a  b$）在字典序中最先出现的对。\n    b. **合并**：将被选择的簇 $C_i$ 和 $C_j$ 合并成一个新的簇 $C_u$。新簇被赋予一个新的标签，从 $n$ 开始，每次合并递增。\n    c. **计算高度**：在树状图中代表这次合并的节点被放置在共表型高度 $h = d(i, j) / 2$ 处。\n    d. **更新距离**：新簇 $C_u$ 与任何其他现有簇 $C_k$ 之间的相异性计算为其组成成员之间相异性的算术平均值。这等同于预先存在的簇间距离的加权平均值：\n    $$d(u, k) = \\frac{|C_i| d(i, k) + |C_j| d(j, k)}{|C_i| + |C_j|}$$\n    e. **更新状态**：原始簇 $C_i$ 和 $C_j$ 从活跃簇集合中移除，新簇 $C_u$ 被加入。新簇的大小为 $|C_u| = |C_i| + |C_j|$。\n$3$. **终止**：当只剩下一个簇时，算法终止。\n\n每次合并所需的输出是一个列表 $[a, b, h, s]$，其中 $a$ 和 $b$ 是被合并簇的标签（$a  b$），$h$ 是以埃（Å）为单位的共表型高度，$s$ 是新簇的大小。\n\n下面是将此过程逐步应用于所提供测试用例的说明。\n\n### 情况 A：$n=5$\n初始簇为 $\\{0\\}, \\{1\\}, \\{2\\}, \\{3\\}, \\{4\\}$，每个大小为 $1$。活跃标签：$\\{0, 1, 2, 3, 4\\}$。下一个标签：$5$。\n距离矩阵 $D_A$：\n$$\n\\begin{pmatrix}\n0.0  1.2  2.8  2.6  4.0 \\\\\n1.2  0.0  3.0  2.7  3.9 \\\\\n2.8  3.0  0.0  0.9  3.7 \\\\\n2.6  2.7  0.9  0.0  3.8 \\\\\n4.0  3.9  3.7  3.8  0.0\n\\end{pmatrix}\n$$\n\n**步骤 1：**\n- 最小相异性为 $d(2, 3) = 0.9$。这对是唯一的。\n- 合并簇 $2$ 和 $3$ 为新簇 $5$。\n- 共表型高度 $h = 0.9 / 2 = 0.45$。新大小 $s = 1+1=2$。\n- 合并记录：$[2, 3, 0.45, 2]$。\n- 更新到簇 $5$ 的距离：\n  - $d(5, 0) = (1 \\cdot d(2, 0) + 1 \\cdot d(3, 0)) / 2 = (2.8 + 2.6) / 2 = 2.7$。\n  - $d(5, 1) = (1 \\cdot d(2, 1) + 1 \\cdot d(3, 1)) / 2 = (3.0 + 2.7) / 2 = 2.85$。\n  - $d(5, 4) = (1 \\cdot d(2, 4) + 1 \\cdot d(3, 4)) / 2 = (3.7 + 3.8) / 2 = 3.75$。\n- 活跃标签：$\\{0, 1, 4, 5\\}$。大小：$|C_0|=1, |C_1|=1, |C_4|=1, |C_5|=2$。\n\n**步骤 2：**\n- 活跃簇相异性：$d(0, 1) = 1.2$, $d(0, 4) = 4.0$, $d(0, 5) = 2.7$, $d(1, 4) = 3.9$, $d(1, 5) = 2.85$, $d(4, 5) = 3.75$。\n- 最小值为 $d(0, 1) = 1.2$。\n- 合并簇 $0$ 和 $1$ 为新簇 $6$。\n- 共表型高度 $h = 1.2 / 2 = 0.6$。新大小 $s = 1+1=2$。\n- 合并记录：$[0, 1, 0.6, 2]$。\n- 更新到簇 $6$ 的距离：\n  - $d(6, 4) = (1 \\cdot d(0, 4) + 1 \\cdot d(1, 4)) / 2 = (4.0 + 3.9) / 2 = 3.95$。\n  - $d(6, 5) = (1 \\cdot d(0, 5) + 1 \\cdot d(1, 5)) / 2 = (2.7 + 2.85) / 2 = 2.775$。\n- 活跃标签：$\\{4, 5, 6\\}$。大小：$|C_4|=1, |C_5|=2, |C_6|=2$。\n\n**步骤 3：**\n- 活跃簇相异性：$d(4, 5) = 3.75$, $d(4, 6) = 3.95$, $d(5, 6) = 2.775$。\n- 最小值为 $d(5, 6) = 2.775$。\n- 合并簇 $5$ 和 $6$ 为新簇 $7$。\n- 共表型高度 $h = 2.775 / 2 = 1.3875$。新大小 $s = 2+2=4$。\n- 合并记录：$[5, 6, 1.3875, 4]$。\n- 更新到簇 $7$ 的距离：\n  - $d(7, 4) = (|C_5| \\cdot d(5, 4) + |C_6| \\cdot d(6, 4)) / (|C_5|+|C_6|) = (2 \\cdot 3.75 + 2 \\cdot 3.95) / 4 = 15.4 / 4 = 3.85$。\n- 活跃标签：$\\{4, 7\\}$。大小：$|C_4|=1, |C_7|=4$。\n\n**步骤 4：**\n- 只剩下一对：$(4, 7)$。相异性 $d(4, 7) = 3.85$。\n- 合并簇 $4$ 和 $7$ 为新簇 $8$。\n- 共表型高度 $h = 3.85 / 2 = 1.925$。新大小 $s = 1+4=5$。\n- 合并记录：$[4, 7, 1.925, 5]$。\n- 算法终止。\n\n情况 A 的结果：$[[2, 3, 0.45, 2], [0, 1, 0.6, 2], [5, 6, 1.3875, 4], [4, 7, 1.925, 5]]$\n\n### 情况 B：$n=2$\n初始簇 $\\{0\\}, \\{1\\}$。活跃标签：$\\{0, 1\\}$。\n距离矩阵 $D_B$：$d(0, 1)=1.8$。\n\n**步骤 1：**\n- 只有一对 $(0, 1)$ 存在。\n- 合并簇 $0$ 和 $1$ 为新簇 $2$。\n- 共表型高度 $h = 1.8 / 2 = 0.9$。新大小 $s = 1+1=2$。\n- 合并记录：$[0, 1, 0.9, 2]$。\n- 算法终止。\n\n情况 B 的结果：$[[0, 1, 0.9, 2]]$\n\n### 情况 C：$n=4$\n初始簇 $\\{0\\}, \\{1\\}, \\{2\\}, \\{3\\}$。活跃标签：$\\{0, 1, 2, 3\\}$。下一个标签：$4$。\n距离矩阵 $D_C$：\n$$\n\\begin{pmatrix}\n0.0  1.0  2.0  2.2 \\\\\n1.0  0.0  2.2  2.0 \\\\\n2.0  2.2  0.0  1.0 \\\\\n2.2  2.0  1.0  0.0\n\\end{pmatrix}\n$$\n\n**步骤 1：**\n- 最小相异性为 $1.0$，出现在两对上：$(0, 1)$ 和 $(2, 3)$。\n- 应用平局打破规则，标签对 $(0, 1)$ 的字典序小于 $(2, 3)$。\n- 合并簇 $0$ 和 $1$ 为新簇 $4$。\n- 共表型高度 $h = 1.0 / 2 = 0.5$。新大小 $s = 1+1=2$。\n- 合并记录：$[0, 1, 0.5, 2]$。\n- 更新到簇 $4$ 的距离：\n  - $d(4, 2) = (1 \\cdot d(0, 2) + 1 \\cdot d(1, 2)) / 2 = (2.0 + 2.2) / 2 = 2.1$。\n  - $d(4, 3) = (1 \\cdot d(0, 3) + 1 \\cdot d(1, 3)) / 2 = (2.2 + 2.0) / 2 = 2.1$。\n- 活跃标签：$\\{2, 3, 4\\}$。大小：$|C_2|=1, |C_3|=1, |C_4|=2$。\n\n**步骤 2：**\n- 活跃簇相异性：$d(2, 3) = 1.0$, $d(2, 4) = 2.1$, $d(3, 4) = 2.1$。\n- 最小值为 $d(2, 3) = 1.0$。\n- 合并簇 $2$ 和 $3$ 为新簇 $5$。\n- 共表型高度 $h = 1.0 / 2 = 0.5$。新大小 $s = 1+1=2$。\n- 合并记录：$[2, 3, 0.5, 2]$。\n- 更新到簇 $5$ 的距离：\n  - $d(5, 4) = (1 \\cdot d(2, 4) + 1 \\cdot d(3, 4)) / 2 = (2.1 + 2.1) / 2 = 2.1$。\n- 活跃标签：$\\{4, 5\\}$。大小：$|C_4|=2, |C_5|=2$。\n\n**步骤 3：**\n- 只剩下一对：$(4, 5)$。相异性 $d(4, 5) = 2.1$。\n- 合并簇 $4$ 和 $5$ 为新簇 $6$。\n- 共表型高度 $h = 2.1 / 2 = 1.05$。新大小 $s = 2+2=4$。\n- 合并记录：$[4, 5, 1.05, 4]$。\n- 算法终止。\n\n情况 C 的结果：$[[0, 1, 0.5, 2], [2, 3, 0.5, 2], [4, 5, 1.05, 4]]$",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport json\n\ndef upgma(D):\n    \"\"\"\n    Implements the UPGMA algorithm based on fundamental definitions.\n\n    Args:\n        D (np.ndarray): A symmetric n x n dissimilarity matrix.\n\n    Returns:\n        list: A list of n-1 merge events. Each event is a list\n              [label1, label2, height, size].\n    \"\"\"\n    n = D.shape[0]\n    if n = 1:\n        return []\n\n    # Initialize active clusters, their sizes, and the distance matrix representation\n    active_labels = set(range(n))\n    cluster_sizes = {i: 1 for i in range(n)}\n    # Using a dictionary of dictionaries for the distance matrix allows for\n    # easy addition and removal of clusters.\n    dist_matrix = {i: {j: D[i, j] for j in range(n)} for i in range(n)}\n    \n    next_label = n\n    merges = []\n\n    # There will be exactly n-1 merges\n    for _ in range(n - 1):\n        # Find the pair of active clusters with the minimum dissimilarity\n        min_dist = float('inf')\n        best_pair = (-1, -1)\n        \n        # To enforce the lexicographical tie-breaking rule, we must iterate\n        # through pairs of labels in a sorted, deterministic order.\n        sorted_labels = sorted(list(active_labels))\n        for i in range(len(sorted_labels)):\n            for j in range(i + 1, len(sorted_labels)):\n                label1 = sorted_labels[i]\n                label2 = sorted_labels[j]\n                \n                d = dist_matrix[label1][label2]\n                if d  min_dist:\n                    min_dist = d\n                    best_pair = (label1, label2)\n        \n        a, b = best_pair\n        \n        # Record the merge event\n        height = min_dist / 2.0\n        size_a = cluster_sizes[a]\n        size_b = cluster_sizes[b]\n        new_size = size_a + size_b\n        merges.append([a, b, height, new_size])\n        \n        # Create the new cluster\n        new_label = next_label\n        \n        # Calculate distances from the new cluster to all other active clusters\n        # using the fundamental UPGMA formula.\n        new_distances = {}\n        for k in active_labels:\n            if k != a and k != b:\n                dist_ak = dist_matrix[a][k]\n                dist_bk = dist_matrix[b][k]\n                new_dist = (size_a * dist_ak + size_b * dist_bk) / (size_a + size_b)\n                new_distances[k] = new_dist\n        \n        # Update the set of active clusters\n        active_labels.remove(a)\n        active_labels.remove(b)\n        \n        # Update the distance matrix representation: remove old clusters\n        del dist_matrix[a]\n        del dist_matrix[b]\n        for k in dist_matrix:\n            del dist_matrix[k][a]\n            del dist_matrix[k][b]\n\n        # Add the new cluster to the distance matrix\n        dist_matrix[new_label] = new_distances\n        for k, d in new_distances.items():\n            dist_matrix[k][new_label] = d\n        dist_matrix[new_label][new_label] = 0.0\n\n        # Update cluster metadata\n        active_labels.add(new_label)\n        cluster_sizes[new_label] = new_size\n        next_label += 1\n        \n    return merges\n\ndef format_result(data):\n    \"\"\"\n    Custom JSON-like formatter to produce output without spaces.\n    \"\"\"\n    if isinstance(data, list):\n        return f\"[{','.join(format_result(item) for item in data)}]\"\n    if isinstance(data, float):\n        # Format float to remove trailing .0 and handle precision as default\n        return f\"{data:.16f}\".rstrip('0').rstrip('.') if '.' in f\"{data:.16f}\" else f\"{data}\"\n    return str(data)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (general, n=5)\n        np.array([\n            [0.0, 1.2, 2.8, 2.6, 4.0],\n            [1.2, 0.0, 3.0, 2.7, 3.9],\n            [2.8, 3.0, 0.0, 0.9, 3.7],\n            [2.6, 2.7, 0.9, 0.0, 3.8],\n            [4.0, 3.9, 3.7, 3.8, 0.0]\n        ]),\n        # Case B (boundary, n=2)\n        np.array([\n            [0.0, 1.8],\n            [1.8, 0.0]\n        ]),\n        # Case C (edge: ties in minimal distances, n=4)\n        np.array([\n            [0.0, 1.0, 2.0, 2.2],\n            [1.0, 0.0, 2.2, 2.0],\n            [2.0, 2.2, 0.0, 1.0],\n            [2.2, 2.0, 1.0, 0.0]\n        ])\n    ]\n\n    results = []\n    for D in test_cases:\n        result = upgma(D)\n        results.append(result)\n\n    # The final print statement produces a single line in the exact required format.\n    # The default str() for lists includes spaces, which is not desired according\n    # to the problem's output format example '[result_A,result_B,result_C]'.\n    # A simple way to achieve this is with json.dumps or a custom formatter.\n    formatted_results = [json.dumps(res, separators=(',', ':')) for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "构建了UPGMA树之后，我们必须提出一个关键问题：它的结果有多准确？本练习探讨了UPGMA的核心假设——“分子钟”假说，即数据必须满足超度量性质。你将学习如何通过计算“共表型距离”（cophenetic distance）并量化其与原始距离的偏差，来衡量当输入数据不符合此假设时产生的扭曲程度。这项实践对于培养批判性思维和理解算法的适用范围至关重要。",
            "id": "2438994",
            "problem": "要求您设计并实现一个算法程序，该程序使用非加权对组平均法（UPGMA）从给定的对称成对距离矩阵重建一棵超度量树，并量化一个非超度量输入矩阵如何在推断的分支长度中引发失真。目标是从第一性原理出发进行推理，从度量空间和超度量空间的基本定义以及定义 UPGMA 的簇平均规则开始，而不依赖任何预封装的黑盒例程。\n\n用作基本基础的定义：\n- 有限分类单元集合上的距离矩阵是一个函数 $d : X \\times X \\to \\mathbb{R}_{\\ge 0}$，该函数是对称的，对所有 $x \\in X$ 满足 $d(x,x) = 0$，并且对所有 $x,y,z \\in X$ 服从三角不等式 $d(x,z) \\le d(x,y) + d(y,z)$。\n- 超度量是一种距离函数，除了上述属性外，还满足强三角不等式：对于 $X$ 中的所有 $x,y,z$，$d(x,y)$、$d(x,z)$ 和 $d(y,z)$ 中的两个最大值相等。\n- 非加权对组平均法（UPGMA）通过迭代地对两个最近的簇进行聚类，并将它们合并节点的高度设置为其簇间距离的一半，来构建一棵有根超度量树。设 $C_{i}$ 和 $C_{j}$ 是两个大小分别为 $|C_{i}|$ 和 $|C_{j}|$ 的簇，它们在距离 $D(C_{i},C_{j})$ 处合并。新节点的高度为 $h = D(C_{i},C_{j})/2$，对于任何其他簇 $C_{k}$，新距离通过算术平均值更新\n$$\nD(C_{i}\\cup C_{j}, C_{k}) \\;=\\; \\frac{|C_{i}| \\, D(C_{i},C_{k}) + |C_{j}| \\, D(C_{j},C_{k})}{|C_{i}| + |C_{j}|}.\n$$\n- 由超度量树导出的共表型距离是成对距离 $u(x,y)$，它等于所构建树中 $x$ 和 $y$ 的最近公共祖先高度的两倍。等价地，在 UPGMA 中，如果 $x \\in C_{i}$ 和 $y \\in C_{j}$ 首次在距离 $D(C_{i},C_{j})$ 处合并，则 $u(x,y) = D(C_{i},C_{j})$。\n- 定义分支长度失真指数为原始距离与 UPGMA 树的共表型距离之间的平均绝对偏差：\n$$\n\\Delta \\;=\\; \\frac{2}{n(n-1)} \\sum_{1 \\le i  j \\le n} \\left| d(i,j) - u(i,j) \\right|,\n$$\n其中 $n$ 是分类单元的数量，求和遍及所有无序对。\n\n您的程序必须：\n- 从第一性原理出发实现 UPGMA，使用上述算术平均更新规则，并在每次合并时为所有通过该合并连接的叶子的交叉对分配 $u(i,j)$。如果最小簇间距离存在冲突，通过选择当前工作顺序中字典序最小的簇索引对来确定性地解决冲突（即，选择最小的 $i$，然后是最小的 $j  i$）。\n- 对于下面的每个测试用例，计算共表型距离矩阵 $u(\\cdot,\\cdot)$，然后计算如上定义的 $\\Delta$，并将其作为四舍五入到 $6$ 位小数的浮点数返回。\n\n测试套件（矩阵按分类单元顺序给出，所有值均为无单位距离）：\n- 测试用例 $1$（明确的非超度量，5个分类单元）：\n$$\nD_{1} \\;=\\;\n\\begin{pmatrix}\n0  4  6  6  7 \\\\\n4  0  8  8  9 \\\\\n6  8  0  4  7 \\\\\n6  8  4  0  7 \\\\\n7  9  7  7  0 \\\\\n\\end{pmatrix}.\n$$\n- 测试用例 $2$（超度量，4个分类单元）：\n$$\nD_{2} \\;=\\;\n\\begin{pmatrix}\n0  2  6  6 \\\\\n2  0  6  6 \\\\\n6  6  0  3 \\\\\n6  6  3  0 \\\\\n\\end{pmatrix}.\n$$\n- 测试用例 $3$（冲突边界，3个分类单元，所有距离相等）：\n$$\nD_{3} \\;=\\;\n\\begin{pmatrix}\n0  4  4 \\\\\n4  0  4 \\\\\n4  4  0 \\\\\n\\end{pmatrix}.\n$$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含三个测试用例的结果列表，按顺序排列，作为一个逗号分隔的列表并用方括号括起来，每个值都精确到 $6$ 位小数。例如，输出必须是以下形式\n$[x_{1},x_{2},x_{3}]$\n其中每个 $x_{k}$ 是一个渲染为小数点后恰好有 $6$ 位数字的浮点数。",
            "solution": "我们从超度量的定义开始：有限集合 $X$ 上的距离函数 $d$ 是超度量的，如果对于所有 $x,y,z \\in X$，$d(x,y)$、$d(x,z)$ 和 $d(y,z)$ 中的两个最大值相等。非加权对组平均法（UPGMA）通过迭代合并最近的一对簇，并使用算术平均值来定义新形成的簇的距离，从而构建一个有根超度量树。该方法假设存在分子钟样的条件（进化速率相等），因此所有叶节点都在相同的高度结束，因此即使输入不是超度量的，输出也是超度量的。\n\n从第一性原理进行算法设计：\n- 将每个分类单元初始化为高度为 $0$ 的单例簇。维护一个从输入 $d$ 导出的对称簇间距离矩阵 $D$。\n- 在每次迭代中，找到使簇间距离 $D(C_{i},C_{j})$ 最小化的不同簇对 $(C_{i}, C_{j})$。如果存在冲突，按索引的字典序确定性地解决它们以确保可复现性。\n- 创建一个新簇 $C_{u} = C_{i} \\cup C_{j}$，并将其节点高度赋为 $h_{u} = D(C_{i},C_{j})/2$。对于每一对 $(x,y)$，其中 $x \\in C_{i}$ 和 $y \\in C_{j}$，分配共表型距离 $u(x,y) = D(C_{i},C_{j})$；这是因为叶节点的高度为 $0$，节点高度决定了在该节点合并的对之间的路径长度为 $2 h_{u}$，这等于 $D(C_{i},C_{j})$。\n- 对于每个剩余的簇 $C_{k}$，通过算术平均值更新簇间距离：\n$$\nD(C_{u},C_{k}) \\;=\\; \\frac{|C_{i}| \\, D(C_{i},C_{k}) + |C_{j}| \\, D(C_{j},C_{k})}{|C_{i}|+|C_{j}|}.\n$$\n- 从活动集合中移除 $C_{i}$ 和 $C_{j}$，并添加 $C_{u}$。重复此过程，直到只剩下一个簇。\n- 完整的共表型矩阵 $u(\\cdot,\\cdot)$ 是通过在每个合并步骤中填充条目来组装的，如上所述。\n\n对于每个有 $n$ 个分类单元的测试用例，定义失真指数\n$$\n\\Delta \\;=\\; \\frac{2}{n(n-1)} \\sum_{1 \\le i  j \\le n} \\left| d(i,j) - u(i,j) \\right|.\n$$\n该指数可以量化原始成对距离与 UPGMA 树所蕴含的超度量距离之间的平均绝对偏差，直接反映了将非超度量数据强制转换为超度量模型所导致的分支长度失真。\n\n测试套件的手动分析：\n\n- 测试用例 1：\n在分类单元 $\\{A,B,C,D,E\\}$ （索引为 $0,1,2,3,4$）上的矩阵 $D_{1}$ 是\n$$\n\\begin{pmatrix}\n0  4  6  6  7 \\\\\n4  0  8  8  9 \\\\\n6  8  0  4  7 \\\\\n6  8  4  0  7 \\\\\n7  9  7  7  0 \\\\\n\\end{pmatrix}.\n$$\n该矩阵明确地不是超度量的。应用 UPGMA 并采用字典序解决冲突：\n    - **第1步**: 最小距离为 $4$，存在于 $(0,1)$ 和 $(2,3)$。根据字典序规则，选择 $(0,1)$。合并 $(0,1)$ 为簇 $5$。设置 $u(0,1)=4$。更新距离：$d(5,2)=7$, $d(5,3)=7$, $d(5,4)=8$。\n    - **第2步**: 活跃簇为 $\\{2,3,4,5\\}$。最小距离仍为 $d(2,3)=4$。合并 $(2,3)$ 为簇 $6$。设置 $u(2,3)=4$。更新距离：$d(6,4)=7$, $d(6,5)=(d(2,5)+d(3,5))/2 = (7+7)/2=7$。\n    - **第3步**: 活跃簇为 $\\{4,5,6\\}$（大小分别为 $1,2,2$）。距离为 $d(4,5)=8$, $d(4,6)=7$, $d(5,6)=7$。最小距离为 $7$，存在于 $(4,6)$ 和 $(5,6)$。根据字典序规则，选择 $(4,6)$。合并 $(4,6)$ 为簇 $7$。设置交叉对 $u(4,2)=u(4,3)=7$。更新距离：$d(7,5) = (|C_4|d(4,5)+|C_6|d(6,5))/(|C_4|+|C_6|) = (1 \\cdot 8 + 2 \\cdot 7)/(1+2) = 22/3 \\approx 7.333$。\n    - **第4步**: 最后的合并是 $(5,7)$，距离为 $22/3$。设置所有剩余的交叉对 $u(0,2)=u(0,3)=u(0,4)=u(1,2)=u(1,3)=u(1,4)=22/3$。\n所有 $\\binom{5}{2}=10$ 对的绝对偏差 $|d-u|$ 为：\n$|d(0,1)-u(0,1)| = |4-4| = 0$\n$|d(2,3)-u(2,3)| = |4-4| = 0$\n$|d(0,2)-u(0,2)| = |6-22/3| = 4/3$\n$|d(0,3)-u(0,3)| = |6-22/3| = 4/3$\n$|d(0,4)-u(0,4)| = |7-22/3| = 1/3$\n$|d(1,2)-u(1,2)| = |8-22/3| = 2/3$\n$|d(1,3)-u(1,3)| = |8-22/3| = 2/3$\n$|d(1,4)-u(1,4)| = |9-22/3| = 5/3$\n$|d(2,4)-u(2,4)| = |7-7| = 0$\n$|d(3,4)-u(3,4)| = |7-7| = 0$\n偏差总和为 $0+0+4/3+4/3+1/3+2/3+2/3+5/3+0+0 = 18/3 = 6.0$。\n$\n\\Delta_{1} \\;=\\; 6.0 / 10 \\;=\\; 0.6.\n$\n\n- 测试用例 2：\n$$\nD_{2} \\;=\\;\n\\begin{pmatrix}\n0  2  6  6 \\\\\n2  0  6  6 \\\\\n6  6  0  3 \\\\\n6  6  3  0 \\\\\n\\end{pmatrix}.\n$$\n这是超度量的：对于任意三元组，两个较大的距离相等。UPGMA 会恢复相同的共表型距离：在 $2$ 处合并 $(0,1)$，在 $3$ 处合并 $(2,3)$，然后在 $6$ 处合并这两个簇，得到所有对的 $u=d$。因此\n$\n\\Delta_{2} \\;=\\; 0.0.\n$\n\n- 测试用例 3：\n$$\nD_{3} \\;=\\;\n\\begin{pmatrix}\n0  4  4 \\\\\n4  0  4 \\\\\n4  4  0 \\\\\n\\end{pmatrix}.\n$$\n所有距离都相等，这是超度量的。UPGMA 在 $4$ 处合并任意一对，然后在 $4$ 处合并剩余的分类单元，得到所有对的 $u=d$。因此\n$\n\\Delta_{3} \\;=\\; 0.0.\n$\n\n因此，失真指数四舍五入到六位小数后为 $[0.600000, 0.000000, 0.000000]$。测试用例 1 中的非超度量输入迫使 UPGMA 压缩和扩展某些分类单元间的距离以适应超度量结构，产生了非零的平均绝对偏差，而测试用例 2 和 3 中的超度量输入产生了零失真，这与方法的假设相符。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_distortion(dist_matrix: np.ndarray) -> float:\n    \"\"\"\n    Computes the UPGMA tree and then the distortion index Delta.\n    \"\"\"\n    n = dist_matrix.shape[0]\n    if n = 1:\n        return 0.0\n\n    # --- UPGMA Implementation ---\n    # Store cluster info in a dictionary: {label: {'leaves': set, 'size': int}}\n    clusters = {i: {'leaves': {i}, 'size': 1} for i in range(n)}\n    # Use a dictionary for distances for easy manipulation\n    D = {i: {j: dist_matrix[i, j] for j in range(n)} for i in range(n)}\n    active_labels = set(range(n))\n    next_label = n\n    \n    # Cophenetic distance matrix\n    U = np.zeros_like(dist_matrix, dtype=float)\n\n    for _ in range(n - 1):\n        min_dist = float('inf')\n        best_pair = None\n        \n        # Find minimum distance pair with tie-breaking\n        sorted_active = sorted(list(active_labels))\n        for i in range(len(sorted_active)):\n            for j in range(i + 1, len(sorted_active)):\n                label1, label2 = sorted_active[i], sorted_active[j]\n                d = D[label1][label2]\n                if d  min_dist:\n                    min_dist = d\n                    best_pair = (label1, label2)\n        \n        c1_label, c2_label = best_pair\n        \n        # Set cophenetic distances for all newly joined leaf pairs\n        c1_leaves = clusters[c1_label]['leaves']\n        c2_leaves = clusters[c2_label]['leaves']\n        for leaf1 in c1_leaves:\n            for leaf2 in c2_leaves:\n                U[leaf1, leaf2] = U[leaf2, leaf1] = min_dist\n\n        # Create new cluster\n        new_label = next_label\n        c1_size = clusters[c1_label]['size']\n        c2_size = clusters[c2_label]['size']\n        new_size = c1_size + c2_size\n        new_leaves = c1_leaves.union(c2_leaves)\n        \n        # Calculate distances from new cluster to others\n        new_distances = {}\n        for k in active_labels:\n            if k != c1_label and k != c2_label:\n                d_c1_k = D[c1_label][k]\n                d_c2_k = D[c2_label][k]\n                new_dist = (c1_size * d_c1_k + c2_size * d_c2_k) / new_size\n                new_distances[k] = new_dist\n        \n        # Update data structures\n        active_labels.remove(c1_label)\n        active_labels.remove(c2_label)\n        clusters[new_label] = {'leaves': new_leaves, 'size': new_size}\n        \n        # Update distance dictionary\n        del D[c1_label]\n        del D[c2_label]\n        for k in D:\n            del D[k][c1_label]\n            del D[k][c2_label]\n        \n        D[new_label] = new_distances\n        for k, d_val in new_distances.items():\n            D[k][new_label] = d_val\n        D[new_label][new_label] = 0.0\n        \n        active_labels.add(new_label)\n        next_label += 1\n\n    # --- Distortion Calculation ---\n    total_abs_dev = 0.0\n    num_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_abs_dev += abs(dist_matrix[i, j] - U[i, j])\n            num_pairs += 1\n            \n    delta = total_abs_dev / num_pairs if num_pairs > 0 else 0.0\n    return delta\n\ndef solve():\n    test_cases = [\n        np.array([\n            [0, 4, 6, 6, 7],\n            [4, 0, 8, 8, 9],\n            [6, 8, 0, 4, 7],\n            [6, 8, 4, 0, 7],\n            [7, 9, 7, 7, 0],\n        ]),\n        np.array([\n            [0, 2, 6, 6],\n            [2, 0, 6, 6],\n            [6, 6, 0, 3],\n            [6, 6, 3, 0],\n        ]),\n        np.array([\n            [0, 4, 4],\n            [4, 0, 4],\n            [4, 4, 0],\n        ])\n    ]\n\n    results = []\n    for D in test_cases:\n        delta = calculate_distortion(D)\n        results.append(f\"{delta:.6f}\")\n    \n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "UPGMA中的“A”代表“算术平均”（Arithmetic），但这是否是唯一的选择？本练习将引导你进行一次更高级的探索，通过将算术平均替换为几何平均来修改聚类规则。你需要从第一性原理出发，推导新的距离更新公式，并比较两种方法产生的树在拓扑结构和分支长度上的差异。这项实践有助于揭示平均方法的选择如何从根本上影响聚类结果，从而加深你对算法设计的理解。",
            "id": "2439048",
            "problem": "要求您在小型的固定测试实例上实现并比较两种非加权成对组算术平均法 (UPGMA) 层次聚类方法的变体。您的比较必须从簇间非相似性和均值聚合的基础定义推导得出，不得依赖任何记忆的公式。只能使用基于第一性原理的逻辑推导。\n\n基本原理和定义：\n- 设 $D \\in \\mathbb{R}^{n \\times n}$ 为一个对称非相似性矩阵，其中对所有 $i$ 都有 $D[i,i] = 0$，且对于 $i \\neq j$ 的非对角线元素 $D[i,j] \\in \\mathbb{R}_{0}$ 均为严格正数。UPGMA 方法通过迭代地合并当前非相似性最小的簇对 $(A,B)$ 来构建一个有根的超度量树状图。\n- 对于任意两个非空不相交的簇 $X$ 和 $Y$，其基数分别为 $|X|$ 和 $|Y|$，算术平均簇距离是 $X$ 中元素与 $Y$ 中元素之间所有成对非相似性的平均值，即多重集 $\\{ D[x,y] \\mid x \\in X, y \\in Y \\}$ 的平均值。类似地，几何平均簇距离是同一多重集的几何平均值。在聚类的每个阶段，当计算新形成的簇与任何其他现有簇之间的非相似性时，这些定义都适用。您必须推导出这些定义如何导出一个仅依赖于现有簇间非相似性和簇大小的递归更新公式，而无需枚举单个元素。\n- 在每次合并簇 $A$ 和 $B$ 时，分配给新内部节点的高度是 $A$ 和 $B$ 合并时非相似性的一半。这种构造在叶子集上诱导出一个超度量，其中两个叶子之间的共表型距离定义为其最近公共祖先高度的两倍。\n\n任务：\n1) 仅根据上述定义，为算术平均 UPGMA 变体推导一个闭式递归更新公式，用于计算新簇 $C = A \\cup B$ 与任何其他现存簇 $Z$ 之间的距离，该公式以 $|A|$、$|B|$、$A$ 与 $Z$ 之间的当前距离、$B$ 与 $Z$ 之间的当前距离以及 $|Z|$ 的大小表示。您的更新公式中不得枚举 $A$、$B$ 或 $Z$ 的单个元素。\n2) 类似地，为几何平均 UPGMA 变体推导一个闭式递归更新公式，该公式与上面给出的几何平均定义一致，并且仅依赖于 $|A|$、$|B|$、$A$ 与 $Z$ 之间的当前距离、$B$ 与 $Z$ 之间的当前距离以及 $|Z|$ 的大小。确保您的推导仅使用对严格正实数有效的对数和几何平均的性质。\n3) 实现两种变体，以便在每次迭代中您执行以下操作：\n   - 选择使当前距离最小化的不同簇的无序对 $(i,j)$，并采用确定性的平局打破规则：如果多个对在容差 $\\varepsilon = 10^{-12}$ 内实现了相同的最小值，则选择字典序最小的索引对 $(i,j)$，其中 $i  j$ 且簇标识符为整数。\n   - 创建一个新簇，其标识符等于下一个未使用的整数，其叶子集是合并簇的叶子集的并集，其高度是合并时非相似性的一半。\n   - 使用相应的派生更新规则更新到所有其他簇的距离。\n4) 对于生成的每棵树，计算：\n   - 合并高度的序列。\n   - 一个布尔值，报告合并高度序列在容差 $\\varepsilon = 10^{-12}$ 内是否非递减。\n   - 根高度（最后一次合并的高度）。\n   - 拓扑结构，表示为合并的有序列表，其中每次合并记录为两个被合并的叶索引集的有序对，每个集合表示为叶索引的排序列表，并且一次合并中的两个列表按字典序排序以使该对规范化。\n   - 共表型距离矩阵（对于索引为 $0$ 到 $n-1$ 的叶子），其中叶子对的条目等于该对首次合并时高度的两倍。\n\n算术平均 UPGMA 与几何平均 UPGMA 之间影响的度量：\n- 对于每个测试实例，计算：\n  - 一个布尔值，指示两种拓扑结构（作为有序合并序列）是否相同。\n  - 一个布尔值，指示算术平均 UPGMA 的合并高度是否非递减。\n  - 一个布尔值，指示几何平均 UPGMA 的合并高度是否非递减。\n  - 算术平均 UPGMA 的根高度，四舍五入到 $6$ 位小数。\n  - 几何平均 UPGMA 的根高度，四舍五入到 $6$ 位小数。\n  - 两个共表型距离矩阵之差的弗罗贝尼乌斯范数（欧几里得矩阵范数），四舍五入到 $6$ 位小数。\n\n角度或物理单位不适用。所有距离都是无量纲的实数。\n\n测试套件和打破平局规则：\n- 使用以下三个对称非相似性矩阵，叶索引按行/列顺序为 $0,1,2,\\dots$，且非对角线元素均为严格正数。\n  - 测试用例 1 ($n=4$):\n    $$\n    D^{(1)} =\n    \\begin{pmatrix}\n    0  0.1  0.7  0.75 \\\\\n    0.1  0  0.72  0.78 \\\\\n    0.7  0.72  0  0.12 \\\\\n    0.75  0.78  0.12  0\n    \\end{pmatrix}.\n    $$\n  - 测试用例 2 ($n=5$):\n    $$\n    D^{(2)} =\n    \\begin{pmatrix}\n    0  0.2  0.21  1.6  1.6 \\\\\n    0.2  0  4.0  1.6  1.6 \\\\\n    0.21  4.0  0  1.5  1.5 \\\\\n    1.6  1.6  1.5  0  0.3 \\\\\n    1.6  1.6  1.5  0.3  0\n    \\end{pmatrix}.\n    $$\n  - 测试用例 3 ($n=4$):\n    $$\n    D^{(3)} =\n    \\begin{pmatrix}\n    0  1.0  1.0  1.0 \\\\\n    1.0  0  1.0  1.000001 \\\\\n    1.0  1.0  0  1.000002 \\\\\n    1.0  1.000001  1.000002  0\n    \\end{pmatrix}.\n    $$\n- 在每个选择步骤中，使用容差 $\\varepsilon = 10^{-12}$ 进行平局检测，并根据簇标识符对 $(i,j)$（其中 $i  j$）的字典序打破平局。",
            "solution": "问题陈述已解析和验证。所有给定条件均已提取，问题被确认为具有科学依据、良构、客观且完整。这是一个计算生物学中的标准算法问题，尽管细节繁多，但没有任何概念或事实上的缺陷。因此，有必要提供一个解决方案。\n\n问题的核心在于为非加权成对组算术平均法 (UPGMA) 算法的两种变体推导并实现递归更新规则，一种基于算术平均，另一种基于几何平均来定义簇间非相似性。\n\n### 1. 算术平均 UPGMA 更新规则的推导\n\n设两个不相交的簇 $A$ 和 $B$ 合并成一个新簇 $C = A \\cup B$。设 $Z$ 是任何其他与 $C$ 不相交的现有簇。$C$ 和 $Z$ 之间的非相似性，记为 $d_{AM}(C, Z)$，定义为其组成元素之间所有成对非相似性的算术平均值。\n根据定义：\n$$\nd_{AM}(C, Z) = d_{AM}(A \\cup B, Z) = \\frac{1}{|C| |Z|} \\sum_{c \\in C} \\sum_{z \\in Z} D[c, z]\n$$\n其中 $|C| = |A| + |B|$，$D[c, z]$ 是叶元素 $c$ 和 $z$ 之间的初始非相似性。\n\n由于 $C$ 是 $A$ 和 $B$ 的不交并，求和可以分解为：\n$$\n\\sum_{c \\in C} \\sum_{z \\in Z} D[c, z] = \\sum_{a \\in A} \\sum_{z \\in Z} D[a, z] + \\sum_{b \\in B} \\sum_{z \\in Z} D[b, z]\n$$\n\n根据簇间算术平均距离的定义，对于当前的非相似性 $d_{AM}(A, Z)$ 和 $d_{AM}(B, Z)$，我们有以下恒等式：\n$$\n\\sum_{a \\in A} \\sum_{z \\in Z} D[a, z] = |A| |Z| \\cdot d_{AM}(A, Z)\n$$\n$$\n\\sum_{b \\in B} \\sum_{z \\in Z} D[b, z] = |B| |Z| \\cdot d_{AM}(B, Z)\n$$\n\n将这些代入 $d_{AM}(C, Z)$ 的表达式中：\n$$\nd_{AM}(C, Z) = \\frac{1}{(|A| + |B|) |Z|} \\left( |A| |Z| \\cdot d_{AM}(A, Z) + |B| |Z| \\cdot d_{AM}(B, Z) \\right)\n$$\n\n项 $|Z|$ 代表外部簇的基数，并且很明显，它在表达式中被消掉了。这是“非加权”成对组方法的一个决定性特征，因为更新独立于未参与合并的簇的属性。最终得到的闭式递归更新公式是：\n$$\nd_{AM}(A \\cup B, Z) = \\frac{|A| \\cdot d_{AM}(A, Z) + |B| \\cdot d_{AM}(B, Z)}{|A| + |B|}\n$$\n该公式表明，新的非相似性是先前非相似性的加权算术平均值，权重与合并簇的大小成正比。\n\n### 2. 几何平均 UPGMA 更新规则的推导\n\n类似地，我们推导几何平均变体的更新规则。非相似性 $d_{GM}(C, Z)$ 定义为成对非相似性的几何平均值。问题指明初始矩阵 $D$ 的所有非对角线元素都是严格正数，这确保了几何平均值是良定义且为正的。\n根据定义：\n$$\nd_{GM}(C, Z) = d_{GM}(A \\cup B, Z) = \\left( \\prod_{c \\in C} \\prod_{z \\in Z} D[c, z] \\right)^{\\frac{1}{|C| |Z|}}\n$$\n和之前一样，我们将乘积在不交并 $C = A \\cup B$ 上分解：\n$$\n\\prod_{c \\in C} \\prod_{z \\in Z} D[c, z] = \\left( \\prod_{a \\in A} \\prod_{z \\in Z} D[a, z] \\right) \\cdot \\left( \\prod_{b \\in B} \\prod_{z \\in Z} D[b, z] \\right)\n$$\n根据几何平均距离的定义，我们有：\n$$\n\\prod_{a \\in A} \\prod_{z \\in Z} D[a, z] = \\left( d_{GM}(A, Z) \\right)^{|A| |Z|}\n$$\n$$\n\\prod_{b \\in B} \\prod_{z \\in Z} D[b, z] = \\left( d_{GM}(B, Z) \\right)^{|B| |Z|}\n$$\n将这些代入 $d_{GM}(C, Z)$ 的表达式中：\n$$\nd_{GM}(C, Z) = \\left( \\left( d_{GM}(A, Z) \\right)^{|A| |Z|} \\cdot \\left( d_{GM}(B, Z) \\right)^{|B| |Z|} \\right)^{\\frac{1}{(|A| + |B|) |Z|}}\n$$\n使用指数性质 $(x^p y^q)^r = x^{pr} y^{qr}$，我们简化得：\n$$\nd_{GM}(C, Z) = \\left( d_{GM}(A, Z) \\right)^{\\frac{|A| |Z|}{(|A| + |B|) |Z|}} \\cdot \\left( d_{GM}(B, Z) \\right)^{\\frac{|B| |Z|}{(|A| + |B|) |Z|}}\n$$\n项 $|Z|$ 被消掉了，得到递归更新规则：\n$$\nd_{GM}(A \\cup B, Z) = \\left( d_{GM}(A, Z) \\right)^{\\frac{|A|}{|A| + |B|}} \\cdot \\left( d_{GM}(B, Z) \\right)^{\\frac{|B|}{|A| + |B|}}\n$$\n这是一个加权几何平均值。为了计算稳定性，尤其是在簇很多的情况下，使用对数更优。对两边取自然对数：\n$$\n\\ln \\left( d_{GM}(A \\cup B, Z) \\right) = \\frac{|A|}{|A| + |B|} \\ln \\left( d_{GM}(A, Z) \\right) + \\frac{|B|}{|A| + |B|} \\ln \\left( d_{GM}(B, Z) \\right)\n$$\n这表明，在对数空间中，几何平均变体的更新规则在形式上与线性空间中的算术平均变体相同。\n\n### 3. 算法实现与分析\n\n实现遵循基于所推导更新规则的标准凝聚式聚类方案。\n1.  **初始化**：从 $n$ 个单例簇开始，每个簇对应一个叶子。初始的簇间距离由输入矩阵 $D$ 给出。必须维护一个活动簇的记录。\n2.  **迭代**：算法进行 $n-1$ 步。在每一步中：\n    a.  **选择**：找出具有最小非相似性 $d(A, B)$ 的不同活动簇对 $(A, B)$。问题指定了严格的确定性平局打破规则：如果多个对在容差 $\\varepsilon = 10^{-12}$ 内共享最小距离，则选择字典序最小的索引对 $(i, j)$，其中 $i  j$。\n    b.  **合并**：将选定的簇 $A$ 和 $B$ 合并为一个新簇 $C$。记录合并事件，包括叶子集和合并高度，定义为 $h = d(A, B)/2$。按步骤排序的合并事件列表定义了树的拓扑结构。\n    c.  **距离更新**：使用相应的派生递归公式计算从新簇 $C$ 到每个其他活动簇 $Z$ 的非相似性。\n    d.  **共表型距离**：来自 $A$ 的任何叶子与来自 $B$ 的任何叶子之间的共表型距离是它们的合并非相似性 $d(A, B)$。该值被记录在共表型距离矩阵中。\n3.  **终止**：经过 $n-1$ 次合并后，只剩下一个包含所有叶子的簇（根），过程终止。\n\n最终分析涉及比较两种 UPGMA 变体的输出。标准（算术平均）UPGMA 的一个关键理论特性是它总能生成一个超度量树，这意味着合并高度序列必须是非递减的。问题要求对两种变体的这一特性进行经验验证。几何平均变体不保证生成超度量树，任何与非递减合并高度的偏离都表明违反了超度量不等式。两个结果共表型矩阵之差的弗罗贝尼乌斯范数提供了一个定量度量，衡量这两种聚类方法在它们施加于数据上的超度量距离方面有多大差异。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_upgma(D, method='arithmetic'):\n    \"\"\"\n    Performs UPGMA clustering on a distance matrix.\n\n    Args:\n        D (np.ndarray): A symmetric dissimilarity matrix.\n        method (str): 'arithmetic' or 'geometric'.\n\n    Returns:\n        tuple: A tuple containing:\n            - topology (list): The sequence of merges.\n            - is_monotonic (bool): Whether merge heights were non-decreasing.\n            - root_height (float): The height of the root node.\n            - cophen_matrix (np.ndarray): The cophenetic distance matrix.\n    \"\"\"\n    n = D.shape[0]\n    epsilon = 1e-12\n\n    # In geometric mode, work with log-distances for stability\n    if method == 'geometric':\n        # Replace 0s on diagonal to avoid log(0)\n        D_log = np.log(D + np.eye(n))\n        dist_matrix = D_log\n    else:\n        dist_matrix = D.copy()\n\n    # clusters[i] = {'size': int, 'leaves': set}\n    clusters = {i: {'size': 1, 'leaves': {i}} for i in range(n)}\n    active_clusters = set(range(n))\n    next_cluster_id = n\n\n    merge_heights = []\n    topology = []\n    cophen_matrix = np.zeros((n, n))\n\n    for _ in range(n - 1):\n        min_dist = np.inf\n        best_pair = None\n\n        active_list = sorted(list(active_clusters))\n        for i in range(len(active_list)):\n            for j in range(i + 1, len(active_list)):\n                u, v = active_list[i], active_list[j]\n                # Ensure correct indexing for upper/lower triangular\n                row, col = min(u, v), max(u, v)\n                if col >= dist_matrix.shape[0]: # handle matrix expansion\n                    continue\n                d = dist_matrix[row, col]\n                \n                if d  min_dist - epsilon:\n                    min_dist = d\n                    best_pair = (u, v)\n                elif abs(d - min_dist) = epsilon:\n                    if best_pair is None or (u, v)  best_pair:\n                        best_pair = (u, v)\n        \n        A, B = best_pair\n        \n        # d_merge is in linear space for both methods\n        d_merge = np.exp(min_dist) if method == 'geometric' else min_dist\n        h_merge = d_merge / 2.0\n        merge_heights.append(h_merge)\n        \n        # Create new cluster\n        C = next_cluster_id\n        size_A = clusters[A]['size']\n        size_B = clusters[B]['size']\n        leaves_A = clusters[A]['leaves']\n        leaves_B = clusters[B]['leaves']\n        \n        new_leaves = leaves_A.union(leaves_B)\n        clusters[C] = {'size': size_A + size_B, 'leaves': new_leaves}\n\n        # Record topology\n        list_A = sorted(list(leaves_A))\n        list_B = sorted(list(leaves_B))\n        if list_A > list_B:\n            list_A, list_B = list_B, list_A\n        topology.append((tuple(list_A), tuple(list_B)))\n\n        # Update cophenetic matrix\n        for la in leaves_A:\n            for lb in leaves_B:\n                cophen_matrix[la, lb] = cophen_matrix[lb, la] = d_merge\n\n        # Update distance matrix (by adding a new row/col for C)\n        # We need a bigger matrix to hold new clusters\n        if C >= dist_matrix.shape[0]:\n            new_size = C + 1\n            temp_matrix = np.full((new_size, new_size), 0.0)\n            temp_matrix[:dist_matrix.shape[0], :dist_matrix.shape[1]] = dist_matrix\n            dist_matrix = temp_matrix\n\n        for Z in active_clusters:\n            if Z != A and Z != B:\n                d_AZ = dist_matrix[min(A, Z), max(A, Z)]\n                d_BZ = dist_matrix[min(B, Z), max(B, Z)]\n\n                if method == 'arithmetic':\n                    d_CZ = (size_A * d_AZ + size_B * d_BZ) / (size_A + size_B)\n                else: # geometric (in log space)\n                    log_d_CZ = (size_A * d_AZ + size_B * d_BZ) / (size_A + size_B)\n                    d_CZ = log_d_CZ\n                \n                dist_matrix[min(C, Z), max(C, Z)] = d_CZ\n\n        active_clusters.remove(A)\n        active_clusters.remove(B)\n        active_clusters.add(C)\n        next_cluster_id += 1\n\n    is_monotonic = all(merge_heights[i] = merge_heights[i+1] + epsilon for i in range(len(merge_heights) - 1))\n    root_height = merge_heights[-1] if merge_heights else 0.0\n\n    return topology, is_monotonic, root_height, cophen_matrix\n\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        np.array([\n            [0, 0.1, 0.7, 0.75],\n            [0.1, 0, 0.72, 0.78],\n            [0.7, 0.72, 0, 0.12],\n            [0.75, 0.78, 0.12, 0]\n        ]),\n        np.array([\n            [0, 0.2, 0.21, 1.6, 1.6],\n            [0.2, 0, 4.0, 1.6, 1.6],\n            [0.21, 4.0, 0, 1.5, 1.5],\n            [1.6, 1.6, 1.5, 0, 0.3],\n            [1.6, 1.6, 1.5, 0.3, 0]\n        ]),\n        np.array([\n            [0, 1.0, 1.0, 1.0],\n            [1.0, 0, 1.0, 1.000001],\n            [1.0, 1.0, 0, 1.000002],\n            [1.0, 1.000001, 1.000002, 0]\n        ])\n    ]\n\n    all_results = []\n    for D in test_cases:\n        topo_a, mono_a, root_a, cophen_a = run_upgma(D, 'arithmetic')\n        topo_g, mono_g, root_g, cophen_g = run_upgma(D, 'geometric')\n\n        same_topology = (topo_a == topo_g)\n        frobenius_norm = np.linalg.norm(cophen_a - cophen_g, 'fro')\n\n        result_for_case = [\n            same_topology,\n            mono_a,\n            mono_g,\n            round(root_a, 6),\n            round(root_g, 6),\n            round(frobenius_norm, 6)\n        ]\n        all_results.append(result_for_case)\n\n    # Final print statement in the exact required format.\n    # The default str() of a list includes spaces, which must be removed.\n    print(str(all_results).replace(\" \", \"\").replace(\"True\", \"true\").replace(\"False\", \"false\"))\n\nsolve()\n```"
        }
    ]
}