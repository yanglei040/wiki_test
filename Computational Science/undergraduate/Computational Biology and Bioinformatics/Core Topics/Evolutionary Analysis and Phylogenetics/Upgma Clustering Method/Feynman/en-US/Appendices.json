{
    "hands_on_practices": [
        {
            "introduction": "To truly grasp the UPGMA algorithm, there is no substitute for building it from the ground up. This first exercise  guides you through a complete implementation, starting from a given dissimilarity matrix representing protein structural differences. By handling the iterative merging process, distance updates, and deterministic tie-breaking rules yourself, you will gain a robust, practical understanding of the algorithm's core mechanics.",
            "id": "2439017",
            "problem": "You are given three symmetric pairwise dissimilarity matrices derived from Root Mean Square Deviation (RMSD) values between protein structures. RMSD is a nonnegative dissimilarity measured in Angstroms (Å). Implement the Unweighted Pair Group Method with Arithmetic Mean (UPGMA), an agglomerative, rooted, hierarchical clustering method that assumes a constant-rate (ultrametric) model, to group the proteins into structural families by building an ultrametric tree. Your program must compute the full sequence of merges and report, for each merge, the indices of the two clusters that were merged, the cophenetic height at which they were merged (in Å), and the size of the newly formed cluster.\n\nFundamental base and rules to be used:\n- Start from the definition of a dissimilarity matrix: a symmetric matrix $D$ with entries $d(i,j) \\ge 0$, $d(i,i) = 0$, and $d(i,j) = d(j,i)$, encoding pairwise dissimilarities between items.\n- At each iteration, choose the two active clusters with the smallest intercluster dissimilarity and merge them.\n- Distances between the new merged cluster and any remaining cluster must be defined by the arithmetic mean of all pairwise distances between their members.\n- The cophenetic height for a merge is defined as half of the dissimilarity between the two clusters at the moment they are merged, expressed in Angstroms.\n- Determinism requirements:\n  - Ties in the minimal intercluster dissimilarity must be broken by selecting the pair with the smallest ordered pair of labels in lexicographic order.\n  - Initial labels for the $n$ individual proteins are $0,1,\\dots,n-1$.\n  - Each time you create a new cluster, assign it the next unused integer label in increasing order starting from $n$.\n  - When reporting a merge, always list the two labels in ascending order.\n- Report each merge as a list of four numbers $[a,b,h,s]$ where $a$ and $b$ are the labels of the merged clusters with $a<b$, $h$ is the cophenetic height in Angstroms (a float), and $s$ is the size (number of original proteins) in the newly formed cluster (an integer).\n\nTest suite (all dissimilarities in Angstroms):\n- Case A (general, $n=5$):\n  - Matrix $D_A$ with entries:\n    - $d(0,1)=1.2$, $d(0,2)=2.8$, $d(0,3)=2.6$, $d(0,4)=4.0$\n    - $d(1,2)=3.0$, $d(1,3)=2.7$, $d(1,4)=3.9$\n    - $d(2,3)=0.9$, $d(2,4)=3.7$\n    - $d(3,4)=3.8$\n    - Diagonal entries $d(i,i)=0$, symmetry $d(i,j)=d(j,i)$.\n- Case B (boundary, $n=2$):\n  - Matrix $D_B$:\n    - $d(0,1)=1.8$, with $d(0,0)=d(1,1)=0$, symmetric.\n- Case C (edge: ties in minimal distances, $n=4$):\n  - Matrix $D_C$ with entries:\n    - $d(0,1)=1.0$, $d(2,3)=1.0$\n    - $d(0,2)=2.0$, $d(0,3)=2.2$, $d(1,2)=2.2$, $d(1,3)=2.0$\n    - Diagonal entries $d(i,i)=0$, symmetry $d(i,j)=d(j,i)$.\n\nRequired output for each case:\n- A list of merges, each merge formatted as $[a,b,h,s]$ with $h$ in Angstroms and $s$ an integer. The output for a case with $n$ items must contain exactly $n-1$ merges.\n\nFinal output format:\n- Your program should produce a single line of output containing the results for the three cases as a comma-separated list enclosed in square brackets (for example, $[result_A,result_B,result_C]$), where each $result_\\cdot$ is the list of merges for the corresponding case. All numbers must be plain numerals without unit annotations; heights are understood to be in Angstroms.\n\nYour program must implement the UPGMA procedure from the fundamental definitions above; no shortcut formulas are to be quoted in the problem statement. The final answers must be presented as described and must be fully determined by the test suite above.",
            "solution": "The problem statement is scientifically sound, well-posed, and provides a complete, unambiguous specification for the Unweighted Pair Group Method with Arithmetic Mean (UPGMA) algorithm. Its validation is successful, and I shall proceed with a complete solution.\n\nThe UPGMA algorithm is an agglomerative hierarchical clustering method. It begins with each of the $n$ items as its own cluster. In each step, the two closest clusters are merged into a new, larger cluster. This process is repeated until only one cluster, containing all $n$ items, remains. The result is a rooted binary tree, or dendrogram, where the branch lengths represent evolutionary or structural distance. UPGMA assumes an ultrametric property, meaning all leaves (original items) are equidistant from the root, which corresponds to a constant rate of change (molecular clock hypothesis in phylogenetics, or uniform structural divergence here).\n\nThe core of the algorithm consists of the following steps:\n$1$. **Initialization**: Start with $n$ clusters, each containing one of the initial items. The cluster sizes are $|C_i| = 1$ for $i \\in \\{0, 1, ..., n-1\\}$. The dissimilarities between these initial clusters are given by the input matrix $D$, where $d(i, j)$ is the dissimilarity between item $i$ and item $j$.\n$2$. **Iteration**: Repeat for $n-1$ steps:\n    a. **Find Closest Pair**: Identify the pair of active clusters $(i, j)$ with the smallest dissimilarity $d(i, j)$. The problem specifies a tie-breaking rule: if multiple pairs share the same minimum dissimilarity, the pair whose labels $(a, b)$ with $a < b$ come first in lexicographical order is chosen.\n    b. **Merge**: Combine the chosen clusters, $C_i$ and $C_j$, into a new cluster $C_u$. The new cluster is assigned a new label, starting from $n$ and incrementing for each merge.\n    c. **Calculate Height**: The node representing the merge in the dendrogram is placed at a cophenetic height of $h = d(i, j) / 2$.\n    d. **Update Distances**: The dissimilarity between the new cluster $C_u$ and any other existing cluster $C_k$ is calculated as the arithmetic mean of the dissimilarities between their constituent members. This is equivalent to the weighted average of the pre-existing inter-cluster distances:\n    $$d(u, k) = \\frac{|C_i| d(i, k) + |C_j| d(j, k)}{|C_i| + |C_j|}$$\n    e. **Update State**: The original clusters $C_i$ and $C_j$ are removed from the set of active clusters, and the new cluster $C_u$ is added. The size of the new cluster is $|C_u| = |C_i| + |C_j|$.\n$3$. **Termination**: The algorithm terminates when only one cluster remains.\n\nThe required output for each merge is a list $[a, b, h, s]$, where $a$ and $b$ are the labels of the merged clusters ($a < b$), $h$ is the cophenetic height in Angstroms (\\AA), and $s$ is the size of the new cluster.\n\nBelow is the step-by-step application of this procedure to the provided test cases.\n\n### Case A: $n=5$\nInitial clusters are $\\{0\\}, \\{1\\}, \\{2\\}, \\{3\\}, \\{4\\}$, each of size $1$. Active labels: $\\{0, 1, 2, 3, 4\\}$. Next label: $5$.\nDistance matrix $D_A$:\n$$\n\\begin{pmatrix}\n0.0 & 1.2 & 2.8 & 2.6 & 4.0 \\\\\n1.2 & 0.0 & 3.0 & 2.7 & 3.9 \\\\\n2.8 & 3.0 & 0.0 & 0.9 & 3.7 \\\\\n2.6 & 2.7 & 0.9 & 0.0 & 3.8 \\\\\n4.0 & 3.9 & 3.7 & 3.8 & 0.0\n\\end{pmatrix}\n$$\n\n**Step 1:**\n- Minimum dissimilarity is $d(2, 3) = 0.9$. This pair is unique.\n- Merge clusters $2$ and $3$ into new cluster $5$.\n- Cophenetic height $h = 0.9 / 2 = 0.45$. New size $s = 1+1=2$.\n- Merge record: $[2, 3, 0.45, 2]$.\n- Update distances to cluster $5$:\n  - $d(5, 0) = (1 \\cdot d(2, 0) + 1 \\cdot d(3, 0)) / 2 = (2.8 + 2.6) / 2 = 2.7$.\n  - $d(5, 1) = (1 \\cdot d(2, 1) + 1 \\cdot d(3, 1)) / 2 = (3.0 + 2.7) / 2 = 2.85$.\n  - $d(5, 4) = (1 \\cdot d(2, 4) + 1 \\cdot d(3, 4)) / 2 = (3.7 + 3.8) / 2 = 3.75$.\n- Active labels: $\\{0, 1, 4, 5\\}$. Sizes: $|C_0|=1, |C_1|=1, |C_4|=1, |C_5|=2$.\n\n**Step 2:**\n- Active cluster dissimilarities: $d(0, 1) = 1.2$, $d(0, 4) = 4.0$, $d(0, 5) = 2.7$, $d(1, 4) = 3.9$, $d(1, 5) = 2.85$, $d(4, 5) = 3.75$.\n- Minimum is $d(0, 1) = 1.2$.\n- Merge clusters $0$ and $1$ into new cluster $6$.\n- Cophenetic height $h = 1.2 / 2 = 0.6$. New size $s = 1+1=2$.\n- Merge record: $[0, 1, 0.6, 2]$.\n- Update distances to cluster $6$:\n  - $d(6, 4) = (1 \\cdot d(0, 4) + 1 \\cdot d(1, 4)) / 2 = (4.0 + 3.9) / 2 = 3.95$.\n  - $d(6, 5) = (1 \\cdot d(0, 5) + 1 \\cdot d(1, 5)) / 2 = (2.7 + 2.85) / 2 = 2.775$.\n- Active labels: $\\{4, 5, 6\\}$. Sizes: $|C_4|=1, |C_5|=2, |C_6|=2$.\n\n**Step 3:**\n- Active cluster dissimilarities: $d(4, 5) = 3.75$, $d(4, 6) = 3.95$, $d(5, 6) = 2.775$.\n- Minimum is $d(5, 6) = 2.775$.\n- Merge clusters $5$ and $6$ into new cluster $7$.\n- Cophenetic height $h = 2.775 / 2 = 1.3875$. New size $s = 2+2=4$.\n- Merge record: $[5, 6, 1.3875, 4]$.\n- Update distances to cluster $7$:\n  - $d(7, 4) = (|C_5| \\cdot d(5, 4) + |C_6| \\cdot d(6, 4)) / (|C_5|+|C_6|) = (2 \\cdot 3.75 + 2 \\cdot 3.95) / 4 = 15.4 / 4 = 3.85$.\n- Active labels: $\\{4, 7\\}$. Sizes: $|C_4|=1, |C_7|=4$.\n\n**Step 4:**\n- Only one pair remains: $(4, 7)$. Dissimilarity $d(4, 7) = 3.85$.\n- Merge clusters $4$ and $7$ into new cluster $8$.\n- Cophenetic height $h = 3.85 / 2 = 1.925$. New size $s = 1+4=5$.\n- Merge record: $[4, 7, 1.925, 5]$.\n- Algorithm terminates.\n\nResult for Case A: $[[2, 3, 0.45, 2], [0, 1, 0.6, 2], [5, 6, 1.3875, 4], [4, 7, 1.925, 5]]$\n\n### Case B: $n=2$\nInitial clusters $\\{0\\}, \\{1\\}$. Active labels: $\\{0, 1\\}$.\nDistance matrix $D_B$: $d(0, 1)=1.8$.\n\n**Step 1:**\n- Only one pair $(0, 1)$ exists.\n- Merge clusters $0$ and $1$ into new cluster $2$.\n- Cophenetic height $h = 1.8 / 2 = 0.9$. New size $s = 1+1=2$.\n- Merge record: $[0, 1, 0.9, 2]$.\n- Algorithm terminates.\n\nResult for Case B: $[[0, 1, 0.9, 2]]$\n\n### Case C: $n=4$\nInitial clusters $\\{0\\}, \\{1\\}, \\{2\\}, \\{3\\}$. Active labels: $\\{0, 1, 2, 3\\}$. Next label: $4$.\nDistance matrix $D_C$:\n$$\n\\begin{pmatrix}\n0.0 & 1.0 & 2.0 & 2.2 \\\\\n1.0 & 0.0 & 2.2 & 2.0 \\\\\n2.0 & 2.2 & 0.0 & 1.0 \\\\\n2.2 & 2.0 & 1.0 & 0.0\n\\end{pmatrix}\n$$\n\n**Step 1:**\n- Minimum dissimilarity is $1.0$, which occurs for two pairs: $(0, 1)$ and $(2, 3)$.\n- Applying the tie-breaking rule, the pair of labels $(0, 1)$ is lexicographically smaller than $(2, 3)$.\n- Merge clusters $0$ and $1$ into new cluster $4$.\n- Cophenetic height $h = 1.0 / 2 = 0.5$. New size $s = 1+1=2$.\n- Merge record: $[0, 1, 0.5, 2]$.\n- Update distances to cluster $4$:\n  - $d(4, 2) = (1 \\cdot d(0, 2) + 1 \\cdot d(1, 2)) / 2 = (2.0 + 2.2) / 2 = 2.1$.\n  - $d(4, 3) = (1 \\cdot d(0, 3) + 1 \\cdot d(1, 3)) / 2 = (2.2 + 2.0) / 2 = 2.1$.\n- Active labels: $\\{2, 3, 4\\}$. Sizes: $|C_2|=1, |C_3|=1, |C_4|=2$.\n\n**Step 2:**\n- Active cluster dissimilarities: $d(2, 3) = 1.0$, $d(2, 4) = 2.1$, $d(3, 4) = 2.1$.\n- Minimum is $d(2, 3) = 1.0$.\n- Merge clusters $2$ and $3$ into new cluster $5$.\n- Cophenetic height $h = 1.0 / 2 = 0.5$. New size $s = 1+1=2$.\n- Merge record: $[2, 3, 0.5, 2]$.\n- Update distances to cluster $5$:\n  - $d(5, 4) = (1 \\cdot d(2, 4) + 1 \\cdot d(3, 4)) / 2 = (2.1 + 2.1) / 2 = 2.1$.\n- Active labels: $\\{4, 5\\}$. Sizes: $|C_4|=2, |C_5|=2$.\n\n**Step 3:**\n- Only one pair remains: $(4, 5)$. Dissimilarity $d(4, 5) = 2.1$.\n- Merge clusters $4$ and $5$ into new cluster $6$.\n- Cophenetic height $h = 2.1 / 2 = 1.05$. New size $s = 2+2=4$.\n- Merge record: $[4, 5, 1.05, 4]$.\n- Algorithm terminates.\n\nResult for Case C: $[[0, 1, 0.5, 2], [2, 3, 0.5, 2], [4, 5, 1.05, 4]]$",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport json\n\ndef upgma(D):\n    \"\"\"\n    Implements the UPGMA algorithm based on fundamental definitions.\n\n    Args:\n        D (np.ndarray): A symmetric n x n dissimilarity matrix.\n\n    Returns:\n        list: A list of n-1 merge events. Each event is a list\n              [label1, label2, height, size].\n    \"\"\"\n    n = D.shape[0]\n    if n = 1:\n        return []\n\n    # Initialize active clusters, their sizes, and the distance matrix representation\n    active_labels = set(range(n))\n    cluster_sizes = {i: 1 for i in range(n)}\n    # Using a dictionary of dictionaries for the distance matrix allows for\n    # easy addition and removal of clusters.\n    dist_matrix = {i: {j: D[i, j] for j in range(n)} for i in range(n)}\n    \n    next_label = n\n    merges = []\n\n    # There will be exactly n-1 merges\n    for _ in range(n - 1):\n        # Find the pair of active clusters with the minimum dissimilarity\n        min_dist = float('inf')\n        best_pair = (-1, -1)\n        \n        # To enforce the lexicographical tie-breaking rule, we must iterate\n        # through pairs of labels in a sorted, deterministic order.\n        sorted_labels = sorted(list(active_labels))\n        for i in range(len(sorted_labels)):\n            for j in range(i + 1, len(sorted_labels)):\n                label1 = sorted_labels[i]\n                label2 = sorted_labels[j]\n                \n                d = dist_matrix[label1][label2]\n                if d  min_dist:\n                    min_dist = d\n                    best_pair = (label1, label2)\n        \n        a, b = best_pair\n        \n        # Record the merge event\n        height = min_dist / 2.0\n        size_a = cluster_sizes[a]\n        size_b = cluster_sizes[b]\n        new_size = size_a + size_b\n        merges.append([a, b, height, new_size])\n        \n        # Create the new cluster\n        new_label = next_label\n        \n        # Calculate distances from the new cluster to all other active clusters\n        # using the fundamental UPGMA formula.\n        new_distances = {}\n        for k in active_labels:\n            if k != a and k != b:\n                dist_ak = dist_matrix[a][k]\n                dist_bk = dist_matrix[b][k]\n                new_dist = (size_a * dist_ak + size_b * dist_bk) / (size_a + size_b)\n                new_distances[k] = new_dist\n        \n        # Update the set of active clusters\n        active_labels.remove(a)\n        active_labels.remove(b)\n        \n        # Update the distance matrix representation: remove old clusters\n        del dist_matrix[a]\n        del dist_matrix[b]\n        for k in dist_matrix:\n            del dist_matrix[k][a]\n            del dist_matrix[k][b]\n\n        # Add the new cluster to the distance matrix\n        dist_matrix[new_label] = new_distances\n        for k, d in new_distances.items():\n            dist_matrix[k][new_label] = d\n        dist_matrix[new_label][new_label] = 0.0\n\n        # Update cluster metadata\n        active_labels.add(new_label)\n        cluster_sizes[new_label] = new_size\n        next_label += 1\n        \n    return merges\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (general, n=5)\n        np.array([\n            [0.0, 1.2, 2.8, 2.6, 4.0],\n            [1.2, 0.0, 3.0, 2.7, 3.9],\n            [2.8, 3.0, 0.0, 0.9, 3.7],\n            [2.6, 2.7, 0.9, 0.0, 3.8],\n            [4.0, 3.9, 3.7, 3.8, 0.0]\n        ]),\n        # Case B (boundary, n=2)\n        np.array([\n            [0.0, 1.8],\n            [1.8, 0.0]\n        ]),\n        # Case C (edge: ties in minimal distances, n=4)\n        np.array([\n            [0.0, 1.0, 2.0, 2.2],\n            [1.0, 0.0, 2.2, 2.0],\n            [2.0, 2.2, 0.0, 1.0],\n            [2.2, 2.0, 1.0, 0.0]\n        ])\n    ]\n\n    results = []\n    for D in test_cases:\n        result = upgma(D)\n        results.append(result)\n\n    # The final print statement produces a single line in the exact required format.\n    # The default str() for lists includes spaces, which is not desired according\n    # to the problem's output format example '[result_A,result_B,result_C]'.\n    # A simple way to achieve this is with json.dumps or a custom formatter.\n    formatted_results = [json.dumps(res, separators=(',', ':')) for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The UPGMA algorithm's power comes from its core assumption of a 'molecular clock,' which implies the resulting tree is ultrametric. But what happens when the input data does not fit this model? This practice  challenges you to quantify this discrepancy by implementing a branch-length distortion index, $\\Delta$, which measures the deviation between the original distances and the ultrametric distances imposed by the UPGMA tree. This provides a critical lens through which to evaluate the method's applicability and limitations.",
            "id": "2438994",
            "problem": "You are asked to design and implement an algorithmic procedure that reconstructs an ultrametric tree using the Unweighted Pair Group Method with Arithmetic mean (UPGMA) from a given symmetric pairwise distance matrix, and to quantify how a non-ultrametric input matrix induces distortions in inferred branch lengths. The goal is to reason from first principles, starting from basic definitions of metric and ultrametric spaces, and the cluster-averaging rule that defines UPGMA, without relying on any prepackaged black-box routines.\n\nDefinitions to use as the fundamental base:\n- A distance matrix on a finite set of taxa is a function $d : X \\times X \\to \\mathbb{R}_{\\ge 0}$ that is symmetric, satisfies $d(x,x) = 0$ for all $x \\in X$, and obeys the triangle inequality $d(x,z) \\le d(x,y) + d(y,z)$ for all $x,y,z \\in X$.\n- An ultrametric is a distance function that, in addition to the properties above, satisfies the strong triangle inequality: for all $x,y,z$ in $X$, the two largest values among $d(x,y)$, $d(x,z)$, and $d(y,z)$ are equal.\n- The Unweighted Pair Group Method with Arithmetic mean (UPGMA) constructs a rooted ultrametric tree by iteratively clustering the two closest clusters and assigning the height of their merge node to be half of their inter-cluster distance. Let $C_{i}$ and $C_{j}$ be two clusters of sizes $|C_{i}|$ and $|C_{j}|$ that merge at distance $D(C_{i},C_{j})$. The height of the new node is $h = D(C_{i},C_{j})/2$, and for any other cluster $C_{k}$, the new distance is updated by the arithmetic mean\n$$\nD(C_{i}\\cup C_{j}, C_{k}) \\;=\\; \\frac{|C_{i}| \\, D(C_{i},C_{k}) + |C_{j}| \\, D(C_{j},C_{k})}{|C_{i}| + |C_{j}|}.\n$$\n- The cophenetic distance induced by an ultrametric tree is the pairwise distance $u(x,y)$ equal to twice the height of the least common ancestor of $x$ and $y$ in the constructed tree. Equivalently, in UPGMA, if $x \\in C_{i}$ and $y \\in C_{j}$ first merge at distance $D(C_{i},C_{j})$, then $u(x,y) = D(C_{i},C_{j})$.\n- Define a branch-length distortion index as the mean absolute deviation between the original distances and the cophenetic distances of the UPGMA tree:\n$$\n\\Delta \\;=\\; \\frac{2}{n(n-1)} \\sum_{1 \\le i  j \\le n} \\left| d(i,j) - u(i,j) \\right|,\n$$\nwhere $n$ is the number of taxa and the sum is over unordered pairs.\n\nYour program must:\n- Implement UPGMA from first principles, using the arithmetic-mean update rule above, and at each merge assign $u(i,j)$ for all cross-pairs of leaves that are joined by that merge. In case of ties for the minimal inter-cluster distance, break ties deterministically by choosing the lexicographically smallest pair of cluster indices in the current working order (that is, pick the smallest $i$ and then the smallest $j  i$).\n- For each test case below, compute the cophenetic distance matrix $u(\\cdot,\\cdot)$, then compute $\\Delta$ as defined above, and return it as a floating-point number rounded to $6$ decimal places.\n\nTest suite (matrices are given in taxa order and all values are in unitless distance):\n- Test case $1$ (explicitly non-ultrametric, $5$ taxa):\n$$\nD_{1} \\;=\\;\n\\begin{pmatrix}\n0  4  6  6  7 \\\\\n4  0  8  8  9 \\\\\n6  8  0  4  7 \\\\\n6  8  4  0  7 \\\\\n7  9  7  7  0 \\\\\n\\end{pmatrix}.\n$$\n- Test case $2$ (ultrametric, $4$ taxa):\n$$\nD_{2} \\;=\\;\n\\begin{pmatrix}\n0  2  6  6 \\\\\n2  0  6  6 \\\\\n6  6  0  3 \\\\\n6  6  3  0 \\\\\n\\end{pmatrix}.\n$$\n- Test case $3$ (tie boundary, $3$ taxa, all equal distances):\n$$\nD_{3} \\;=\\;\n\\begin{pmatrix}\n0  4  4 \\\\\n4  0  4 \\\\\n4  4  0 \\\\\n\\end{pmatrix}.\n$$\n\nFinal output format:\n- Your program should produce a single line of output containing the list of results for the three test cases in order, as a comma-separated list enclosed in square brackets, with each value rounded to exactly $6$ decimal places. For example, the output must be of the form\n$[x_{1},x_{2},x_{3}]$\nwhere each $x_{k}$ is a float rendered with exactly $6$ digits after the decimal point.",
            "solution": "We begin from the definition of an ultrametric: a distance function $d$ on a finite set $X$ is ultrametric if for all $x,y,z \\in X$, the two largest values among $d(x,y)$, $d(x,z)$, and $d(y,z)$ are equal. The Unweighted Pair Group Method with Arithmetic mean (UPGMA) constructs a rooted ultrametric tree by iteratively merging the closest pair of clusters and using the arithmetic mean to define distances from the newly formed cluster. The method assumes a molecular clock-like condition (equal rate of evolution) so that all leaves end at the same height, and hence the output is ultrametric even when the input is not.\n\nAlgorithmic design from first principles:\n- Initialize each taxon as a singleton cluster. Maintain a symmetric inter-cluster distance matrix $D$.\n- At each iteration, find the pair of distinct clusters $(C_{i}, C_{j})$ that minimizes $D(C_{i},C_{j})$, breaking ties lexicographically on cluster indices.\n- Create a new cluster $C_{u} = C_{i} \\cup C_{j}$. For every pair $(x,y)$ with $x \\in C_{i}$ and $y \\in C_{j}$, assign the cophenetic distance $u(x,y) = D(C_{i},C_{j})$.\n- For each remaining cluster $C_{k}$, update the inter-cluster distance via the arithmetic mean:\n$$\nD(C_{u},C_{k}) \\;=\\; \\frac{|C_{i}| \\, D(C_{i},C_{k}) + |C_{j}| \\, D(C_{j},C_{k})}{|C_{i}|+|C_{j}|}.\n$$\n- Repeat until one cluster remains. The distortion index is $\\Delta = \\frac{1}{\\binom{n}{2}} \\sum_{ij} |d(i,j) - u(i,j)|$.\n\nHand analysis for the test suite:\n\n- **Test case 1:**\nThe matrix $D_{1}$ on taxa $\\{0,1,2,3,4\\}$ is non-ultrametric.\n    1. Initial clusters: $\\{0\\},\\{1\\},\\{2\\},\\{3\\},\\{4\\}$. Min distance is $d(0,1)=4$. Merge 0 and 1 into cluster 5. $u(0,1)=4$.\n    2. Active clusters: $\\{2\\},\\{3\\},\\{4\\},\\{5\\}$. Distances to 5: $d(5,2)=7, d(5,3)=7, d(5,4)=8$. Min distance in the current matrix is $d(2,3)=4$. Merge 2 and 3 into cluster 6. $u(2,3)=4$.\n    3. Active clusters: $\\{4\\},\\{5\\},\\{6\\}$. Inter-cluster distances: $d(4,5)=8$, $d(4,6) = (d(4,2)+d(4,3))/2=7$, $d(5,6) = (d(5,2)+d(5,3))/2=7$. Tie for min distance (7) between pairs (4,6) and (5,6). Lexicographically, (4,6) is chosen. Merge 4 and 6 into cluster 7. $u(4,2)=7, u(4,3)=7$.\n    4. Active clusters: $\\{5\\},\\{7\\}$. Final merge distance: $d(5,7) = (|C_4|d(5,4) + |C_6|d(5,6))/(|C_4|+|C_6|) = (1 \\cdot 8 + 2 \\cdot 7) / 3 = 22/3$. All remaining cross-pairs get cophenetic distance $22/3 \\approx 7.333$.\n    - The absolute deviations $|d-u|$ for the $\\binom{5}{2}=10$ pairs are:\n        - Pairs merged early: $|d(0,1)-u(0,1)|=|4-4|=0$. $|d(2,3)-u(2,3)|=|4-4|=0$.\n        - Pairs merged at step 3: $|d(2,4)-u(2,4)|=|7-7|=0$. $|d(3,4)-u(3,4)|=|7-7|=0$.\n        - Pairs merged at step 4: $|d(0,2)-u(0,2)|=|6-22/3|=4/3$. $|d(0,3)-u(0,3)|=|6-22/3|=4/3$. $|d(0,4)-u(0,4)|=|7-22/3|=1/3$. $|d(1,2)-u(1,2)|=|8-22/3|=2/3$. $|d(1,3)-u(1,3)|=|8-22/3|=2/3$. $|d(1,4)-u(1,4)|=|9-22/3|=5/3$.\n    - Sum of deviations is $0+0+0+0 + (4+4+1+2+2+5)/3 = 18/3 = 6$.\n    - $\\Delta_1 = 6.0 / 10 = 0.6$.\n\n- **Test case 2:**\nThe matrix $D_2$ is ultrametric. UPGMA recovers the same cophenetic distances: merge (0,1) at 2 and (2,3) at 3. Then merge these two clusters at 6. This yields $u=d$ for all pairs.\n$\n\\Delta_{2} \\;=\\; 0.0.\n$\n\n- **Test case 3:**\nThe matrix $D_3$ is ultrametric as all distances are equal. UPGMA merges any pair (e.g., (0,1) by tie-breaking) at 4, then the remaining taxon at 4. This yields $u=d$ for all pairs.\n$\n\\Delta_{3} \\;=\\; 0.0.\n$\n\nThus, the distortion indices rounded to six decimal places are $[0.600000, 0.000000, 0.000000]$. The non-ultrametric input in test case 1 forces UPGMA to compress and expand certain inter-taxon distances to fit an ultrametric structure, producing a nonzero mean absolute deviation, while the ultrametric inputs in test cases 2 and 3 produce zero distortion as expected.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the UPGMA distortion index problem for the given test cases.\n    \"\"\"\n    def get_cophenetic_matrix(D_in: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Computes the cophenetic distance matrix using UPGMA.\n        \"\"\"\n        n = D_in.shape[0]\n        if n = 1:\n            return np.zeros_like(D_in)\n\n        # Use a dict-of-dicts for the distance matrix for easy manipulation\n        dist_matrix = {i: {j: D_in[i, j] for j in range(n)} for i in range(n)}\n        \n        # Keep track of cluster info\n        clusters = {i: {i} for i in range(n)} # Maps cluster ID to set of original leaf IDs\n        cluster_sizes = {i: 1 for i in range(n)}\n        active_labels = set(range(n))\n        next_label = n\n        \n        # Final cophenetic matrix\n        U = np.zeros((n, n))\n\n        while len(active_labels) > 1:\n            min_dist = float('inf')\n            best_pair = (-1, -1)\n            \n            # Find closest pair with lexicographical tie-breaking\n            sorted_labels = sorted(list(active_labels))\n            for i in range(len(sorted_labels)):\n                for j in range(i + 1, len(sorted_labels)):\n                    label1, label2 = sorted_labels[i], sorted_labels[j]\n                    d = dist_matrix[label1][label2]\n                    if d  min_dist:\n                        min_dist = d\n                        best_pair = (label1, label2)\n            \n            a, b = best_pair\n            \n            # Set cophenetic distances for leaves being merged\n            for leaf_a in clusters[a]:\n                for leaf_b in clusters[b]:\n                    U[leaf_a, leaf_b] = U[leaf_b, leaf_a] = min_dist\n            \n            # Create new cluster\n            new_label = next_label\n            new_cluster_leaves = clusters[a].union(clusters[b])\n            size_a, size_b = cluster_sizes[a], cluster_sizes[b]\n            new_size = size_a + size_b\n            \n            # Calculate new distances\n            new_distances = {}\n            for k in active_labels:\n                if k != a and k != b:\n                    dist_ak = dist_matrix[a][k]\n                    dist_bk = dist_matrix[b][k]\n                    new_dist = (size_a * dist_ak + size_b * dist_bk) / new_size\n                    new_distances[k] = new_dist\n            \n            # Update state: remove old clusters\n            active_labels.remove(a)\n            active_labels.remove(b)\n            del dist_matrix[a]\n            del dist_matrix[b]\n            for k in dist_matrix:\n                del dist_matrix[k][a]\n                del dist_matrix[k][b]\n\n            # Update state: add new cluster\n            dist_matrix[new_label] = new_distances\n            for k, d in new_distances.items():\n                dist_matrix[k][new_label] = d\n            dist_matrix[new_label][new_label] = 0.0\n            \n            active_labels.add(new_label)\n            clusters[new_label] = new_cluster_leaves\n            cluster_sizes[new_label] = new_size\n            next_label += 1\n            \n        return U\n\n    def calculate_delta(D_orig: np.ndarray, U_cophen: np.ndarray) -> float:\n        \"\"\"\n        Calculates the mean absolute distortion index.\n        \"\"\"\n        n = D_orig.shape[0]\n        if n = 1:\n            return 0.0\n        \n        # Extract upper triangle to avoid double counting and the diagonal\n        iu = np.triu_indices(n, k=1)\n        abs_diff = np.abs(D_orig[iu] - U_cophen[iu])\n        \n        return np.mean(abs_diff)\n\n    # Test Cases\n    D1 = np.array([\n        [0., 4., 6., 6., 7.],\n        [4., 0., 8., 8., 9.],\n        [6., 8., 0., 4., 7.],\n        [6., 8., 4., 0., 7.],\n        [7., 9., 7., 7., 0.]\n    ])\n    D2 = np.array([\n        [0., 2., 6., 6.],\n        [2., 0., 6., 6.],\n        [6., 6., 0., 3.],\n        [6., 6., 3., 0.]\n    ])\n    D3 = np.array([\n        [0., 4., 4.],\n        [4., 0., 4.],\n        [4., 4., 0.]\n    ])\n\n    test_cases = [D1, D2, D3]\n    results = []\n    \n    for D in test_cases:\n        U = get_cophenetic_matrix(D)\n        delta = calculate_delta(D, U)\n        results.append(f\"{delta:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Moving beyond the standard algorithm, this exercise invites you to explore the design space of clustering methods. You will modify the core UPGMA update rule by replacing the arithmetic mean with a geometric mean, deriving the new formula from first principles . By comparing the resulting topologies and properties, such as the non-decreasing nature of merge heights, you will gain insight into how fundamental algorithmic choices impact tree reconstruction and the validity of the underlying ultrametric assumption.",
            "id": "2439048",
            "problem": "You are asked to implement and compare two variants of the Unweighted Pair Group Method with Arithmetic Mean (UPGMA) hierarchical clustering method on small, fixed test instances. Your comparison must be derived from foundational definitions of cluster-to-cluster dissimilarity and mean aggregation, and must not rely on any memorized formula. Use only logical derivation from first principles.\n\nFundamental base and definitions:\n- Let $D \\in \\mathbb{R}^{n \\times n}$ be a symmetric dissimilarity matrix with $D[i,i] = 0$ for all $i$ and strictly positive off-diagonal entries $D[i,j] \\in \\mathbb{R}_{0}$ for $i \\neq j$. The UPGMA method builds a rooted, ultrametric dendrogram by iteratively merging the pair of clusters $(A,B)$ with the smallest current dissimilarity.\n- For any two nonempty disjoint clusters $X$ and $Y$ with cardinalities $|X|$ and $|Y|$, the arithmetic mean cluster distance is the mean over all pairwise dissimilarities between elements of $X$ and elements of $Y$, that is, the average of the multiset $\\{ D[x,y] \\mid x \\in X, y \\in Y \\}$. Similarly, the geometric mean cluster distance is the geometric mean over the same multiset. These definitions apply at every stage of clustering when computing the dissimilarity between the newly formed cluster and any other existing cluster. You must derive how these definitions imply a recursive update that depends only on existing cluster-to-cluster dissimilarities and cluster sizes, without enumerating individual elements.\n- At each merge of clusters $A$ and $B$, the height assigned to the new internal node is half the dissimilarity at which $A$ and $B$ merge. This construction induces an ultrametric on the leaf set, where the cophenetic distance between two leaves is defined as twice the height of their least common ancestor.\n\nTasks:\n1) Derive, from the above definitions only, a closed-form recursive update for the arithmetic-mean UPGMA variant to compute the distance from the new cluster $C = A \\cup B$ to any other extant cluster $Z$ in terms of $|A|$, $|B|$, the current distances between $A$ and $Z$ and between $B$ and $Z$, and the size $|Z|$. You must not enumerate individual elements of $A$, $B$, or $Z$ in your update.\n2) Analogously, derive a closed-form recursive update for the geometric-mean UPGMA variant that is consistent with the geometric mean definition given above and depends only on $|A|$, $|B|$, the current distances between $A$ and $Z$ and between $B$ and $Z$, and the size $|Z|$. Ensure that your derivation uses only properties of logarithms and geometric means valid for strictly positive real numbers.\n3) Implement both variants so that at each iteration you:\n   - Select the unordered pair $(i,j)$ of distinct clusters that minimizes the current distance with a deterministic tie-break: if multiple pairs realize the same minimal value within tolerance $\\varepsilon = 10^{-12}$, choose the pair with lexicographically smallest indices $(i,j)$, where $i  j$ and cluster identifiers are integers.\n   - Create a new cluster with identifier equal to the next unused integer, whose leaf set is the union of the merged clusters’ leaf sets, and whose height is half the merge dissimilarity.\n   - Update distances to all other clusters using the appropriate derived update rule.\n4) For each produced tree, compute:\n   - The sequence of merge heights.\n   - A boolean reporting whether the sequence of merge heights is non-decreasing up to tolerance $\\varepsilon = 10^{-12}$.\n   - The root height (the last merge height).\n   - The topology as the ordered list of merges, where each merge is recorded as an ordered pair of the two merged leaf-index sets, each represented as a sorted list of leaf indices, and the two lists within a merge are ordered lexicographically to make the pair canonical.\n   - The cophenetic distance matrix (for leaves indexed $0$ through $n-1$), where the entry for a leaf pair equals twice the height at which the pair first coalesces.\n\nMeasure of impact between arithmetic-mean UPGMA and geometric-mean UPGMA:\n- For each test instance, compute:\n  - A boolean indicating whether the two topologies (as ordered merge sequences) are identical.\n  - A boolean indicating whether arithmetic-mean UPGMA has non-decreasing merge heights.\n  - A boolean indicating whether geometric-mean UPGMA has non-decreasing merge heights.\n  - The arithmetic-mean UPGMA root height, rounded to $6$ decimal places.\n  - The geometric-mean UPGMA root height, rounded to $6$ decimal places.\n  - The Frobenius norm (Euclidean matrix norm) of the difference between the two cophenetic distance matrices, rounded to $6$ decimal places.\n\nAngle or physical units are not applicable. All distances are dimensionless real numbers.\n\nTest suite and tie-breaking:\n- Use the following three symmetric dissimilarity matrices, with leaf indices in row/column order $0,1,2,\\dots$ and strictly positive off-diagonal entries.\n  - Test case $1$ ($n=4$):\n    $$\n    D^{(1)} =\n    \\begin{pmatrix}\n    0  0.1  0.7  0.75 \\\\\n    0.1  0  0.72  0.78 \\\\\n    0.7  0.72  0  0.12 \\\\\n    0.75  0.78  0.12  0\n    \\end{pmatrix}.\n    $$\n  - Test case $2$ ($n=5$):\n    $$\n    D^{(2)} =\n    \\begin{pmatrix}\n    0  0.2  0.21  1.6  1.6 \\\\\n    0.2  0  4.0  1.6  1.6 \\\\\n    0.21  4.0  0  1.5  1.5 \\\\\n    1.6  1.6  1.5  0  0.3 \\\\\n    1.6  1.6  1.5  0.3  0\n    \\end{pmatrix}.\n    $$\n  - Test case $3$ ($n=4$):\n    $$\n    D^{(3)} =\n    \\begin{pmatrix}\n    0  1.0  1.0  1.0 \\\\\n    1.0  0  1.0  1.000001 \\\\\n    1.0  1.0  0  1.000002 \\\\\n    1.0  1.000001  1.000002  0\n    \\end{pmatrix}.\n    $$\n- At every selection step, use tolerance $\\varepsilon = 10^{-12}$ for tie detection and break ties lexicographically on the cluster identifier pair $(i,j)$ with $ij$.\n\nFinal output format:\n- Your program must produce a single line of output containing a Python-style list of length $3$ (one entry per test case), where each entry is a list of length $6$ containing, in order:\n  $[\\text{same\\_topology}, \\text{mono\\_arith}, \\text{mono\\_geom}, \\text{root\\_arith}, \\text{root\\_geom}, \\text{cophen\\_L2}]$.\n- Booleans must be Python booleans (i.e., $True$ or $False$). Floats must be rounded to $6$ decimal places as specified. The output must be exactly one line, for example:\n  $[[\\dots],[\\dots],[\\dots]]$.",
            "solution": "The problem statement is parsed and validated. All givens are extracted, and the problem is confirmed to be scientifically grounded, well-posed, objective, and complete. It is a standard, albeit detailed, algorithmic problem in computational biology, free of any conceptual or factual flaws. Thus, a solution is warranted.\n\nThe core of the problem lies in deriving and implementing recursive update rules for two variants of the Unweighted Pair Group Method with Arithmetic Mean (UPGMA) algorithm, one based on the arithmetic mean and the other on the geometric mean for defining inter-cluster dissimilarity.\n\n### 1. Derivation of the Arithmetic-Mean UPGMA Update Rule\n\nLet two disjoint clusters, $A$ and $B$, be merged into a new cluster $C = A \\cup B$. Let $Z$ be any other existing cluster, disjoint from $C$. The dissimilarity between $C$ and $Z$, denoted $d_{AM}(C, Z)$, is defined as the arithmetic mean of all pairwise dissimilarities between their constituent elements.\nBy definition:\n$$\nd_{AM}(C, Z) = d_{AM}(A \\cup B, Z) = \\frac{1}{|C| |Z|} \\sum_{c \\in C} \\sum_{z \\in Z} D[c, z]\n$$\nwhere $|C| = |A| + |B|$ and $D[c, z]$ is the initial dissimilarity between leaf elements $c$ and $z$.\n\nSince $C$ is the disjoint union of $A$ and $B$, the summation can be decomposed:\n$$\n\\sum_{c \\in C} \\sum_{z \\in Z} D[c, z] = \\sum_{a \\in A} \\sum_{z \\in Z} D[a, z] + \\sum_{b \\in B} \\sum_{z \\in Z} D[b, z]\n$$\n\nFrom the definition of arithmetic-mean distance between clusters, we have the following identities for the current dissimilarities $d_{AM}(A, Z)$ and $d_{AM}(B, Z)$:\n$$\n\\sum_{a \\in A} \\sum_{z \\in Z} D[a, z] = |A| |Z| \\cdot d_{AM}(A, Z)\n$$\n$$\n\\sum_{b \\in B} \\sum_{z \\in Z} D[b, z] = |B| |Z| \\cdot d_{AM}(B, Z)\n$$\n\nSubstituting these back into the expression for $d_{AM}(C, Z)$:\n$$\nd_{AM}(C, Z) = \\frac{1}{(|A| + |B|) |Z|} \\left( |A| |Z| \\cdot d_{AM}(A, Z) + |B| |Z| \\cdot d_{AM}(B, Z) \\right)\n$$\n\nThe term $|Z|$ represents the cardinality of the external cluster and, as is evident, cancels from the expression. This is a defining characteristic of \"unweighted\" pair-group methods, as the update is independent of the properties of clusters not involved in the merge. The resulting closed-form recursive update is:\n$$\nd_{AM}(A \\cup B, Z) = \\frac{|A| \\cdot d_{AM}(A, Z) + |B| \\cdot d_{AM}(B, Z)}{|A| + |B|}\n$$\nThis formula demonstrates that the new dissimilarity is a weighted arithmetic mean of the previous dissimilarities, with weights proportional to the sizes of the merged clusters.\n\n### 2. Derivation of the Geometric-Mean UPGMA Update Rule\n\nAnalogously, we derive the update rule for the geometric-mean variant. The dissimilarity $d_{GM}(C, Z)$ is defined as the geometric mean of pairwise dissimilarities. The problem specifies that all off-diagonal entries of the initial matrix $D$ are strictly positive, ensuring the geometric mean is well-defined and positive.\nBy definition:\n$$\nd_{GM}(C, Z) = d_{GM}(A \\cup B, Z) = \\left( \\prod_{c \\in C} \\prod_{z \\in Z} D[c, z] \\right)^{\\frac{1}{|C| |Z|}}\n$$\nAs before, we decompose the product over the disjoint union $C = A \\cup B$:\n$$\n\\prod_{c \\in C} \\prod_{z \\in Z} D[c, z] = \\left( \\prod_{a \\in A} \\prod_{z \\in Z} D[a, z] \\right) \\cdot \\left( \\prod_{b \\in B} \\prod_{z \\in Z} D[b, z] \\right)\n$$\nFrom the definition of geometric-mean distance, we have:\n$$\n\\prod_{a \\in A} \\prod_{z \\in Z} D[a, z] = \\left( d_{GM}(A, Z) \\right)^{|A| |Z|}\n$$\n$$\n\\prod_{b \\in B} \\prod_{z \\in Z} D[b, z] = \\left( d_{GM}(B, Z) \\right)^{|B| |Z|}\n$$\nSubstituting these into the expression for $d_{GM}(C, Z)$:\n$$\nd_{GM}(C, Z) = \\left( \\left( d_{GM}(A, Z) \\right)^{|A| |Z|} \\cdot \\left( d_{GM}(B, Z) \\right)^{|B| |Z|} \\right)^{\\frac{1}{(|A| + |B|) |Z|}}\n$$\nUsing the property of exponents $(x^p y^q)^r = x^{pr} y^{qr}$, we simplify:\n$$\nd_{GM}(C, Z) = \\left( d_{GM}(A, Z) \\right)^{\\frac{|A| |Z|}{(|A| + |B|) |Z|}} \\cdot \\left( d_{GM}(B, Z) \\right)^{\\frac{|B| |Z|}{(|A| + |B|) |Z|}}\n$$\nThe term $|Z|$ cancels, yielding the recursive update rule:\n$$\nd_{GM}(A \\cup B, Z) = \\left( d_{GM}(A, Z) \\right)^{\\frac{|A|}{|A| + |B|}} \\cdot \\left( d_{GM}(B, Z) \\right)^{\\frac{|B|}{|A| + |B|}}\n$$\nThis is a weighted geometric mean. For computational stability, especially with many clusters, it is superior to work with logarithms. Taking the natural logarithm of both sides:\n$$\n\\ln \\left( d_{GM}(A \\cup B, Z) \\right) = \\frac{|A|}{|A| + |B|} \\ln \\left( d_{GM}(A, Z) \\right) + \\frac{|B|}{|A| + |B|} \\ln \\left( d_{GM}(B, Z) \\right)\n$$\nThis shows that in logarithmic space, the update rule for the geometric-mean variant is identical in form to the arithmetic-mean variant in linear space.\n\n### 3. Algorithmic Implementation and Analysis\n\nThe implementation follows a standard agglomerative clustering scheme based on the derived update rules.\n1.  **Initialization**: Begin with $n$ singleton clusters, each corresponding to a leaf. The initial inter-cluster distances are given by the input matrix $D$. A record of active clusters must be maintained.\n2.  **Iteration**: The algorithm proceeds for $n-1$ steps. In each step:\n    a.  **Selection**: The pair of distinct active clusters $(A, B)$ with the minimum dissimilarity, $d(A, B)$, is identified. The problem specifies a strict deterministic tie-breaking rule: if multiple pairs share the minimum distance (within a tolerance $\\varepsilon = 10^{-12}$), the pair with the lexicographically smallest indices $(i, j)$ where $i  j$ is chosen.\n    b.  **Merging**: The selected clusters $A$ and $B$ are merged into a new cluster $C$. The merge event is recorded, including the leaf sets and the merge height, which is defined as $h = d(A, B)/2$. The list of merge events, ordered by step, defines the tree topology.\n    c.  **Distance Update**: The dissimilarity from the new cluster $C$ to every other active cluster $Z$ is computed using the appropriate derived recursive formula.\n    d.  **Cophenetic Distance**: The cophenetic distance between any leaf from $A$ and any leaf from $B$ is their merge dissimilarity, $d(A, B)$. This value is recorded in the cophenetic distance matrix.\n3.  **Termination**: After $n-1$ merges, only one cluster containing all leaves remains (the root), and the process terminates.\n\nThe final analysis involves comparing the outputs of the two UPGMA variants. A key theoretical property of the standard (arithmetic-mean) UPGMA is that it always produces an ultrametric tree, which implies that the sequence of merge heights must be non-decreasing. The problem requires empirical verification of this property for both variants. The geometric-mean variant is not guaranteed to produce an ultrametric tree, and any deviation from non-decreasing merge heights indicates a violation of the ultrametric inequality. The Frobenius norm of the difference between the two resulting cophenetic matrices provides a quantitative measure of how much the two clustering methods diverge in the ultrametric distances they impose on the data.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_upgma(D, method='arithmetic'):\n    \"\"\"\n    Performs UPGMA clustering on a distance matrix.\n\n    Args:\n        D (np.ndarray): A symmetric dissimilarity matrix.\n        method (str): 'arithmetic' or 'geometric'.\n\n    Returns:\n        tuple: A tuple containing:\n            - topology (list): The sequence of merges.\n            - is_monotonic (bool): Whether merge heights were non-decreasing.\n            - root_height (float): The height of the root node.\n            - cophen_matrix (np.ndarray): The cophenetic distance matrix.\n    \"\"\"\n    n = D.shape[0]\n    epsilon = 1e-12\n\n    # In geometric mode, work with log-distances for stability\n    if method == 'geometric':\n        # Replace 0s on diagonal to avoid log(0)\n        D_log = np.log(D + np.eye(n))\n        dist_matrix = D_log\n    else:\n        dist_matrix = D.copy()\n\n    # clusters[i] = {'size': int, 'leaves': set}\n    clusters = {i: {'size': 1, 'leaves': {i}} for i in range(n)}\n    active_clusters = set(range(n))\n    next_cluster_id = n\n\n    merge_heights = []\n    topology = []\n    cophen_matrix = np.zeros((n, n))\n\n    # To handle dynamic cluster IDs, expand the matrix as needed\n    current_max_id = n\n    \n    for _ in range(n - 1):\n        min_dist = np.inf\n        best_pair = None\n\n        active_list = sorted(list(active_clusters))\n        for i in range(len(active_list)):\n            for j in range(i + 1, len(active_list)):\n                u, v = active_list[i], active_list[j]\n                d = dist_matrix[u, v] if u  v else dist_matrix[v, u]\n                \n                if d  min_dist - epsilon:\n                    min_dist = d\n                    best_pair = (u, v)\n        \n        A, B = best_pair\n        \n        # d_merge is in linear space for both methods\n        d_merge = np.exp(min_dist) if method == 'geometric' else min_dist\n        h_merge = d_merge / 2.0\n        merge_heights.append(h_merge)\n        \n        # Create new cluster\n        C = next_cluster_id\n        size_A = clusters[A]['size']\n        size_B = clusters[B]['size']\n        leaves_A = clusters[A]['leaves']\n        leaves_B = clusters[B]['leaves']\n        \n        new_leaves = leaves_A.union(leaves_B)\n        clusters[C] = {'size': size_A + size_B, 'leaves': new_leaves}\n\n        # Record topology\n        list_A = sorted(list(leaves_A))\n        list_B = sorted(list(leaves_B))\n        if list_A > list_B:\n            list_A, list_B = list_B, list_A\n        topology.append((tuple(list_A), tuple(list_B)))\n\n        # Update cophenetic matrix\n        for la in leaves_A:\n            for lb in leaves_B:\n                cophen_matrix[la, lb] = cophen_matrix[lb, la] = d_merge\n\n        # Update distance matrix by adding a new row/col for C\n        if C >= current_max_id:\n            new_size = C + 1\n            temp_matrix = np.full((new_size, new_size), 0.0)\n            temp_matrix[:dist_matrix.shape[0], :dist_matrix.shape[1]] = dist_matrix\n            dist_matrix = temp_matrix\n            current_max_id = new_size\n\n        for Z in active_clusters:\n            if Z != A and Z != B:\n                d_AZ = dist_matrix[min(A, Z), max(A, Z)]\n                d_BZ = dist_matrix[min(B, Z), max(B, Z)]\n\n                if method == 'arithmetic':\n                    d_CZ = (size_A * d_AZ + size_B * d_BZ) / (size_A + size_B)\n                else: # geometric (in log space)\n                    d_CZ = (size_A * d_AZ + size_B * d_BZ) / (size_A + size_B)\n                \n                dist_matrix[min(C, Z), max(C, Z)] = d_CZ\n\n        active_clusters.remove(A)\n        active_clusters.remove(B)\n        active_clusters.add(C)\n        next_cluster_id += 1\n\n    is_monotonic = all(merge_heights[i] = merge_heights[i+1] + epsilon for i in range(len(merge_heights) - 1))\n    root_height = merge_heights[-1] if merge_heights else 0.0\n\n    return topology, is_monotonic, root_height, cophen_matrix\n\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        np.array([\n            [0, 0.1, 0.7, 0.75],\n            [0.1, 0, 0.72, 0.78],\n            [0.7, 0.72, 0, 0.12],\n            [0.75, 0.78, 0.12, 0]\n        ]),\n        np.array([\n            [0, 0.2, 0.21, 1.6, 1.6],\n            [0.2, 0, 4.0, 1.6, 1.6],\n            [0.21, 4.0, 0, 1.5, 1.5],\n            [1.6, 1.6, 1.5, 0, 0.3],\n            [1.6, 1.6, 1.5, 0.3, 0]\n        ]),\n        np.array([\n            [0, 1.0, 1.0, 1.0],\n            [1.0, 0, 1.0, 1.000001],\n            [1.0, 1.0, 0, 1.000002],\n            [1.0, 1.000001, 1.000002, 0]\n        ])\n    ]\n\n    all_results = []\n    for D in test_cases:\n        topo_a, mono_a, root_a, cophen_a = run_upgma(D, 'arithmetic')\n        topo_g, mono_g, root_g, cophen_g = run_upgma(D, 'geometric')\n\n        same_topology = (topo_a == topo_g)\n        frobenius_norm = np.linalg.norm(cophen_a - cophen_g, 'fro')\n\n        result_for_case = [\n            same_topology,\n            mono_a,\n            mono_g,\n            round(root_a, 6),\n            round(root_g, 6),\n            round(frobenius_norm, 6)\n        ]\n        all_results.append(result_for_case)\n\n    # Final print statement in the exact required format.\n    # The default str() of a list includes spaces, which must be removed.\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n```"
        }
    ]
}