{
    "hands_on_practices": [
        {
            "introduction": "比较蛋白质序列是生物信息学的基本任务，有助于推断功能和进化关系。然而，仅仅比较氨基酸的相同性可能过于严格，因为不同的氨基酸可能具有相似的物理化学性质。本练习将指导你实现一种更精妙的比较方法：首先将氨基酸按性质分组，然后找出两条序列之间最长的“物理化学共同子序列”，从而在生物学背景下实践经典的动态规划算法。",
            "id": "2412673",
            "problem": "给定一个在包含20种氨基酸（单字母代码）的标准集合 $\\mathcal{A}$ 上的固定物理化学分类函数 $M:\\mathcal{A}\\to\\{0,1,2,3,4,5,6\\}$。当且仅当两个残基在映射 $M$ 下属于同一类别时，它们被视为匹配。映射 $M$ 根据粗略的物理化学性质对残基进行如下分组：\n- 类别 $0$（脂肪族疏水性）：A, V, L, I, M\n- 类别 $1$（芳香族）：F, W, Y\n- 类别 $2$（极性不带电）：S, T, N, Q, C\n- 类别 $3$（酸性）：D, E\n- 类别 $4$（碱性）：K, R, H\n- 类别 $5$（小分子，甘氨酸）：G\n- 类别 $6$（特殊构象，脯氨酸）：P\n\n对于一对一级序列 $X$ 和 $Y$（在 $\\mathcal{A}$ 上的字符串），通过 $X'[i]=M(X[i])$ 和 $Y'[j]=M(Y[j])$ 定义它们的物理化学类别序列 $X'$ 和 $Y'$。最长公共物理化学子序列长度 $L(X,Y)$ 是满足以下条件的最大整数 $k$：存在严格递增的索引序列 $1\\le i_1<i_2<\\dots<i_k\\le |X|$ 和 $1\\le j_1<j_2<\\dots<j_k\\le |Y|$，使得对于所有 $t\\in\\{1,\\dots,k\\}$ 都有 $X'[i_t]=Y'[j_t]$。此处，$|X|$ 和 $|Y|$ 分别表示 $X$ 和 $Y$ 的长度。\n\n任务：对于下面的每个测试用例，计算如上定义的 $L(X,Y)$，即最长公共物理化学子序列的长度。\n\n测试套件（每一项都是一个有序对 $(X,Y)$）：\n- 用例 $1$：$X=$ \"MTEYKLVVVGAGGVGKS\", $Y=$ \"GAGGVGKTCLLISYTTN\"\n- 用例 $2$：$X=$ \"DDEEEDD\", $Y=$ \"KKRHHK\"\n- 用例 $3$：$X=$ \"\", $Y=$ \"ACDE\"\n- 用例 $4$：$X=$ \"ACDEFGHIKLMNPQRSTVWY\", $Y=$ \"ACDEFGHIKLMNPQRSTVWY\"\n- 用例 $5$：$X=$ \"DEDE\", $Y=$ \"EEDD\"\n\n答案规格：\n- 对于每个用例，输出单个整数 $L(X,Y)$（无其他数据类型）。\n- 将所有用例的结果按顺序汇总到单行的一个列表字面量中：一个用方括号括起来的逗号分隔列表，例如，“[a,b,c,d,e]”，其中 $a,b,c,d,e$ 是整数。输出中不应出现空格。\n\n不涉及物理单位。您的程序不能读取任何输入，并且必须以指定格式准确地产生一行输出。",
            "solution": "问题陈述已经过分析并被确定为有效。它具有科学依据、良构、客观，并包含唯一解所需的所有信息。该问题要求计算两个蛋白质序列之间最长公共子序列的长度，但不是基于氨基酸字母表本身，而是基于一个派生的物理化学类别字母表。这是生物信息学中的一个标准程序，它将一个基本的生物学概念与一个来自计算机科学的经典算法相结合。\n\n解决方案是一个两步过程：首先，将输入的氨基酸序列转换为物理化学类别索引序列；其次，应用动态规划算法来找出这些转换后序列的最长公共子序列（LCS）的长度。\n\n步骤 1：物理化学转换\n\n问题定义了一个映射函数 $M$，它将 20 种标准氨基酸的字母表 $\\mathcal{A}$ 映射到一个整数类别标签集合 $\\{0, 1, 2, 3, 4, 5, 6\\}$。该映射定义如下：\n- 类别 $0$（脂肪族疏水性）：$M(\\text{'A'}) = M(\\text{'V'}) = M(\\text{'L'}) = M(\\text{'I'}) = M(\\text{'M'}) = 0$\n- 类别 $1$（芳香族）：$M(\\text{'F'}) = M(\\text{'W'}) = M(\\text{'Y'}) = 1$\n- 类别 $2$（极性不带电）：$M(\\text{'S'}) = M(\\text{'T'}) = M(\\text{'N'}) = M(\\text{'Q'}) = M(\\text{'C'}) = 2$\n- 类别 $3$（酸性）：$M(\\text{'D'}) = M(\\text{'E'}) = 3$\n- 类别 $4$（碱性）：$M(\\text{'K'}) = M(\\text{'R'}) = M(\\text{'H'}) = 4$\n- 类别 $5$（小分子，甘氨酸）：$M(\\text{'G'}) = 5$\n- 类别 $6$（特殊构象，脯氨酸）：$M(\\text{'P'}) = 6$\n\n对于任意给定的输入序列对，$X$（长度为 $m = |X|$）和 $Y$（长度为 $n = |Y|$），我们首先计算它们相应的物理化学类别序列 $X'$ 和 $Y'$。这些是通过将映射 $M$ 应用于每个残基而构建的整数序列：\n- $X' = [M(X_1), M(X_2), \\dots, M(X_m)]$\n- $Y' = [M(Y_1), M(Y_2), \\dots, M(Y_n)]$\n\n问题随后简化为找到 $X'$ 和 $Y'$ 的最长公共子序列的长度。\n\n步骤 2：最长公共子序列（LCS）算法\n\n序列 $X'$ 和 $Y'$ 的 LCS 长度是使用标准的动态规划方法计算的。令 $dp[i][j]$ 为前缀 $X'[1..i]$ 和 $Y'[1..j]$ 的最长公共子序列的长度。$dp[i][j]$ 的值可以通过以下递推关系计算：\n\n$$\ndp[i][j] =\n\\begin{cases}\n0  \\text{if } i=0 \\text{ or } j=0 \\\\\n1 + dp[i-1][j-1]  \\text{if } i,j > 0 \\text{ and } X'[i-1] = Y'[j-1] \\\\\n\\max(dp[i-1][j], dp[i][j-1])  \\text{if } i,j > 0 \\text{ and } X'[i-1] \\neq Y'[j-1]\n\\end{cases}\n$$\n\n在这里，序列 $X'$ 和 $Y'$ 的索引是从 0 开始的，这在计算实现中是常规做法，而 $dp$ 表的索引 $i$ 和 $j$ 的范围分别是 $0$ 到 $m$ 和 $0$ 到 $n$。基本情况 $dp[i][0] = 0$ 和 $dp[0][j] = 0$（对于所有 $i, j$）确立了任何序列与空序列的 LCS 长度为 0。最终答案，即完整序列 $X'$ 和 $Y'$ 的 LCS 长度，由 $L(X, Y) = dp[m][n]$ 给出。\n\n此过程应用于提供的每个测试用例。例如，在用例 1 中：\n- $X = \\text{\"MTEYKLVVVGAGGVGKS\"}$\n- $Y = \\text{\"GAGGVGKTCLLISYTTN\"}$\n\n序列被转换为它们的类别表示：\n- $X' = [0, 2, 3, 1, 4, 0, 0, 0, 0, 5, 0, 5, 5, 0, 5, 4, 2]$\n- $Y' = [5, 0, 5, 5, 0, 5, 4, 2, 2, 0, 0, 0, 2, 1, 2, 2, 2]$\n\n对 $X'$ 和 $Y'$（长度均为 $17$）应用动态规划算法，得到 LCS 长度为 $9$。\n\n同样的方法也给出了其他用例的结果：\n- 用例 $2$：$X = \\text{\"DDEEEDD\"}$，$Y = \\text{\"KKRHHK\"}$。转换后的序列是 $X'=[3,3,3,3,3,3,3]$ 和 $Y'=[4,4,4,4,4,4]$。它们没有共同的元素，因此 LCS 长度为 $0$。\n- 用例 $3$：$X = \\text{\"\"}$，$Y = \\text{\"ACDE\"}$。由于 $X$ 是一个空序列，LCS 长度为 $0$。\n- 用例 $4$：$X = \\text{\"ACDEFGHIKLMNPQRSTVWY\"}$，$Y = \\text{\"ACDEFGHIKLMNPQRSTVWY\"}$。序列是相同的，因此它们转换后的序列也是相同的。LCS 长度就是序列的长度，即 $20$。\n- 用例 $5$：$X = \\text{\"DEDE\"}$，$Y = \\text{\"EEDD\"}$。转换后的序列是 $X'=[3,3,3,3]$ 和 $Y'=[3,3,3,3]$。它们是相同的，因此 LCS 长度为 $4$。\n\n因此，最终计算出的结果是 $[9, 0, 0, 20, 4]$。下面的程序实现了这一完整逻辑。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the length of the longest common physicochemical subsequence for a suite of test cases.\n    \"\"\"\n\n    # Define the fixed physicochemical classification function M.\n    # A dictionary provides an efficient implementation of the mapping.\n    PHYSICOCHEMICAL_MAP = {\n        'A': 0, 'V': 0, 'L': 0, 'I': 0, 'M': 0,  # Class 0: Aliphatic hydrophobic\n        'F': 1, 'W': 1, 'Y': 1,                  # Class 1: Aromatic\n        'S': 2, 'T': 2, 'N': 2, 'Q': 2, 'C': 2,  # Class 2: Polar uncharged\n        'D': 3, 'E': 3,                          # Class 3: Acidic\n        'K': 4, 'R': 4, 'H': 4,                  # Class 4: Basic\n        'G': 5,                                  # Class 5: Glycine\n        'P': 6                                   # Class 6: Proline\n    }\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\"MTEYKLVVVGAGGVGKS\", \"GAGGVGKTCLLISYTTN\"), # Case 1\n        (\"DDEEEDD\", \"KKRHHK\"),                     # Case 2\n        (\"\", \"ACDE\"),                              # Case 3\n        (\"ACDEFGHIKLMNPQRSTVWY\", \"ACDEFGHIKLMNPQRSTVWY\"), # Case 4\n        (\"DEDE\", \"EEDD\"),                          # Case 5\n    ]\n    \n    def compute_lcs_length(X: str, Y: str) -> int:\n        \"\"\"\n        Calculates the length of the longest common physicochemical subsequence.\n        \n        Args:\n            X: The first protein sequence.\n            Y: The second protein sequence.\n            \n        Returns:\n            The integer length of the LCS of the transformed sequences.\n        \"\"\"\n        # Step 1: Transform amino acid sequences into physicochemical class sequences.\n        X_prime = [PHYSICOCHEMICAL_MAP[residue] for residue in X]\n        Y_prime = [PHYSICOCHEMICAL_MAP[residue] for residue in Y]\n        \n        m = len(X_prime)\n        n = len(Y_prime)\n\n        # Handle trivial case of empty sequences.\n        if m == 0 or n == 0:\n            return 0\n        \n        # Step 2: Compute LCS length using dynamic programming.\n        # Initialize a DP table of size (m+1) x (n+1) with zeros.\n        # dp[i][j] will store the LCS length of X_prime[:i] and Y_prime[:j].\n        dp = np.zeros((m + 1, n + 1), dtype=np.int32)\n        \n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                # If the current elements match, extend the LCS from the previous subproblem.\n                if X_prime[i - 1] == Y_prime[j - 1]:\n                    dp[i, j] = 1 + dp[i - 1, j - 1]\n                # If they don't match, take the maximum LCS length from the two possible subproblems.\n                else:\n                    dp[i, j] = max(dp[i - 1, j], dp[i, j - 1])\n                    \n        # The final result is in the bottom-right corner of the table.\n        return int(dp[m, n])\n\n    results = []\n    for x_seq, y_seq in test_cases:\n        lcs_len = compute_lcs_length(x_seq, y_seq)\n        results.append(lcs_len)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在了解了氨基酸性质的重要性后，我们可以从序列比较更进一步，尝试预测蛋白质的物理特性。本练习要求你根据一个简化的假设模型，通过计算沿主链的局部相互作用来为蛋白质稳定性打分。这个实践将向你展示如何将基于生物化学原理的抽象规则，转化为一个可执行的计算预测模型。",
            "id": "2412675",
            "problem": "创建一个完整的、可运行的程序，该程序模拟蛋白质一级结构在由化学相似性定义的系统性突变前后肽键的局部稳定性。该程序必须对从蛋白质数据库（PDB）文件中提取的一级序列进行操作，并根据下面定义的、受第一性原理启发的、显式的、局部的加性模型计算稳定性变化分数。程序不得读取任何输入；相反，它必须在一个固定的内部测试套件上运行。所有输出必须报告为无单位的整数。\n\n定义和约束：\n1) 从蛋白质数据库（PDB）提取一级结构：仅考虑链标识符为大写字母 A 的链。对于每个 PDB 输入，通过仅扫描标记为 ATOM 的记录，严格按照残基索引递增的顺序选择残基，并仅取链 A 中每个残基索引的首次出现，来构建由单字母残基代码组成的氨基酸序列字符串。非标准或未知的残基名称必须省略。对 $20$ 种规范氨基酸使用标准的三字母到单字母映射：ALA$\\to$A, ARG$\\to$R, ASN$\\to$N, ASP$\\to$D, CYS$\\to$C, GLN$\\to$Q, GLU$\\to$E, GLY$\\to$G, HIS$\\to$H, ILE$\\to$I, LEU$\\to$L, LYS$\\to$K, MET$\\to$M, PHE$\\to$F, PRO$\\to$P, SER$\\to$S, THR$\\to$T, TRP$\\to$W, TYR$\\to$Y, VAL$\\to$V。\n\n2) 化学相似性突变映射 $M$：根据以下为反映常见化学相似性类别而选择的固定映射，将序列中的每个单字母残基 $r$ 替换为 $M(r)$：\n- A$\\to$G, R$\\to$K, N$\\to$Q, D$\\to$E, C$\\to$S, Q$\\to$N, E$\\to$D, G$\\to$A, H$\\to$K, I$\\to$L, L$\\to$I, K$\\to$R, M$\\to$L, F$\\to$Y, P$\\to$A, S$\\to$T, T$\\to$S, W$\\to$F, Y$\\to$F, V$\\to$I.\n\n3) 每个残基 $r$（单字母代码）的残基类别函数 $C(r)$，代表与肽键相关的简化侧链类别：\n- 疏水性：$\\{ \\mathrm{A}, \\mathrm{V}, \\mathrm{I}, \\mathrm{L}, \\mathrm{M}, \\mathrm{F}, \\mathrm{Y}, \\mathrm{W} \\}$，\n- 极性不带电：$\\{ \\mathrm{S}, \\mathrm{T}, \\mathrm{N}, \\mathrm{Q}, \\mathrm{C} \\}$，\n- 带正电：$\\{ \\mathrm{K}, \\mathrm{R}, \\mathrm{H} \\}$，\n- 带负电：$\\{ \\mathrm{D}, \\mathrm{E} \\}$，\n- 特殊（主链异常）：$\\{ \\mathrm{G}, \\mathrm{P} \\}$。\n\n4) 序列 $s_1 s_2 \\dots s_n$（其中 $n \\ge 1$）的局部稳定性分数为\n$$\nE(s_1 \\dots s_n) \\;=\\; \\sum_{i=1}^{n-1} \\Big( \\mathbf{1}[\\,C(s_i) \\neq C(s_{i+1})\\,] \\;+\\; \\mathbf{1}[\\,s_i=\\mathrm{P} \\text{ or } s_{i+1}=\\mathrm{P}\\,] \\;+\\; \\mathbf{1}[\\,s_i=\\mathrm{G} \\text{ or } s_{i+1}=\\mathrm{G}\\,] \\Big),\n$$\n其中 $\\mathbf{1}[\\cdot]$ 是指示函数，当其条件为真时返回 $1$，否则返回 $0$。该分数是一个整数，当肽键两侧的相邻残基类别不同，或者其中至少一个是甘氨酸或脯氨酸（由于其独特的主链约束）时，该分数会增加。\n\n5) 稳定性变化（报告值）：对于每个 PDB 输入，设野生型序列为 $S$，突变序列为 $S'$（通过对 $S$ 的每个残基应用 $M$ 得到）。计算\n$$\n\\Delta\\Delta E \\;=\\; E(S') - E(S).\n$$\n将 $\\Delta\\Delta E$ 报告为一个整数（无单位，无小数点）。\n\n测试套件：\n为以下三个 PDB 输入提供结果，每个输入均按上述规定仅限于链 A。每个输入应按此处列出的顺序解析为其残基序列。\n\n- 案例 $1$（一般覆盖范围，混合类别，包括甘氨酸和脯氨酸）：链 A 的残基序列，按顺序为\nALA, GLY, VAL, ILE, LEU, PRO, ASP, GLU, LYS, ARG, SER, THR, ASN, GLN, PHE, TYR, TRP, CYS, HIS, MET。\n\n- 案例 $2$（边界条件，单个残基）：链 A 的残基序列，按顺序为\nPRO。\n\n- 案例 $3$（强调甘氨酸和脯氨酸罚分的边缘案例）：链 A 的残基序列，按顺序为\nGLY, GLY, PRO, ALA, GLY, PRO。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个逗号分隔的列表，用方括号括起来，按上述案例的顺序排列结果，例如，“[x,y,z]”，其中 $x$、$y$ 和 $z$ 分别是案例 1、2 和 3 计算出的整数。",
            "solution": "该问题陈述已经过严格验证，被认为是具有科学依据、定义明确且客观的。它提出了一个清晰、自洽的计算任务，基于简化但与生物化学相关的蛋白质一级结构原理。关于序列处理、残基属性、突变映射和稳定性评分函数的定义在数学上是明确无误的。因此，该问题是有效的，并且可以构建一个解决方案。\n\n问题的核心是实现一个确定性模型，用于计算蛋白质一级结构在系统性突变后所产生的稳定性变化分数 $\\Delta\\Delta E$。解决方案需要基于所提供的定义进行逐步的算法构建。\n\n首先，必须对问题中提供的所有静态数据进行编码。这包括标准的三字母到单字母氨基酸代码映射、指定的突变映射 $M(r)$ 以及残基类别函数 $C(r)$。这些映射最好使用字典数据结构来实现，以便高效查找。五个残基类别——疏水性、极性不带电、带正电、带负电和特殊——对 $20$ 种规范氨基酸是完备的，定义如下：\n- $C_{Hph} = \\{ \\mathrm{A}, \\mathrm{V}, \\mathrm{I}, \\mathrm{L}, \\mathrm{M}, \\mathrm{F}, \\mathrm{Y}, \\mathrm{W} \\}$\n- $C_{Pol} = \\{ \\mathrm{S}, \\mathrm{T}, \\mathrm{N}, \\mathrm{Q}, \\mathrm{C} \\}$\n- $C_{Pos} = \\{ \\mathrm{K}, \\mathrm{R}, \\mathrm{H} \\}$\n- $C_{Neg} = \\{ \\mathrm{D}, \\mathrm{E} \\}$\n- $C_{Spe} = \\{ \\mathrm{G}, \\mathrm{P} \\}$\n\n该模型的核心组成部分是给定序列 $S = s_1 s_2 \\dots s_n$ 的局部稳定性分数 $E(S)$。该公式是一个对相邻残基对的加性模型：\n$$\nE(s_1 \\dots s_n) \\;=\\; \\sum_{i=1}^{n-1} \\Big( \\mathbf{1}[\\,C(s_i) \\neq C(s_{i+1})\\,] \\;+\\; \\mathbf{1}[\\,s_i=\\mathrm{P} \\text{ or } s_{i+1}=\\mathrm{P}\\,] \\;+\\; \\mathbf{1}[\\,s_i=\\mathrm{G} \\text{ or } s_{i+1}=\\mathrm{G}\\,] \\Big)\n$$\n其中 $\\mathbf{1}[\\cdot]$ 是指示函数。残基 $s_i$ 和 $s_{i+1}$ 之间的肽键分数为三个不同整数值项的总和：\n$1$. 如果残基属于不同的化学类别，即 $C(s_i) \\neq C(s_{i+1})$，则罚分 $1$。\n$2$. 如果任一残基是脯氨酸（$\\mathrm{P}$），则罚分 $1$。\n$3$. 如果任一残基是甘氨酸（$\\mathrm{G}$），则罚分 $1$。\n这些罚分是累加的。例如，一个脯氨酸-甘氨酸连接，其中 $C(\\mathrm{P}) = C(\\mathrm{G})$，将对总和贡献 $0 + 1 + 1 = 2$ 的分数。长度为 $n  2$ 的序列没有肽键，从 $i=1$ 到 $n-1$ 的求和为空，正确地得到分数 $E=0$。\n\n计算序列 $S$（长度为 $n$）的 $E(S)$ 的算法如下：\n$1$. 初始化总分 $E_{total} \\leftarrow 0$。\n$2$. 如果 $n  2$，返回 $0$。\n$3$. 使用索引 $i$ 从 $1$ 迭代到 $n-1$。对于每个 $i$，考虑残基对 $(s_i, s_{i+1})$。\n$4$. 对于每对残基，计算一个 `pair_score`。\n    a. 如果 $C(s_i) \\neq C(s_{i+1})$，将 `pair_score` 加 $1$。\n    b. 如果 $s_i = \\mathrm{P}$ 或 $s_{i+1} = \\mathrm{P}$，将 `pair_score` 加 $1$。\n    c. 如果 $s_i = \\mathrm{G}$ 或 $s_{i+1} = \\mathrm{G}$，将 `pair_score` 加 $1$。\n$5$. 将 `pair_score` 加到 $E_{total}$。\n$6$. 循环完成后，返回 $E_{total}$。\n\n最后，对于每个测试用例，我们必须计算稳定性变化 $\\Delta\\Delta E$。这涉及以下过程：\n$1$. 从提供的三字母氨基酸代码列表中构建野生型一级序列 $S$。\n$2$. 通过将突变映射 $M$ 应用于 $S$ 的每个残基来构建突变序列 $S'$。\n$3$. 计算野生型序列的稳定性分数 $E(S)$。\n$4$. 计算突变序列的稳定性分数 $E(S')$。\n$5$. 计算最终报告值作为差值：$\\Delta\\Delta E = E(S') - E(S)$。\n\n整个过程是确定性的，必须应用于问题陈述中指定的三个固定测试用例中的每一个。然后将得到的 $\\Delta\\Delta E$ 整数值整理并格式化为单行输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\n\ndef solve():\n    \"\"\"\n    Computes the peptide-bond-local stability change for protein primary structures\n    based on a defined additive model.\n    \"\"\"\n\n    # 1) Standard three-letter to one-letter amino acid mapping.\n    THREE_TO_ONE = {\n        \"ALA\": \"A\", \"ARG\": \"R\", \"ASN\": \"N\", \"ASP\": \"D\", \"CYS\": \"C\",\n        \"GLN\": \"Q\", \"GLU\": \"E\", \"GLY\": \"G\", \"HIS\": \"H\", \"ILE\": \"I\",\n        \"LEU\": \"L\", \"LYS\": \"K\", \"MET\": \"M\", \"PHE\": \"F\", \"PRO\": \"P\",\n        \"SER\": \"S\", \"THR\": \"T\", \"TRP\": \"W\", \"TYR\": \"Y\", \"VAL\": \"V\",\n    }\n\n    # 2) Chemically similar mutation mapping M(r).\n    MUTATION_MAP = {\n        'A': 'G', 'R': 'K', 'N': 'Q', 'D': 'E', 'C': 'S', 'Q': 'N', 'E': 'D',\n        'G': 'A', 'H': 'K', 'I': 'L', 'L': 'I', 'K': 'R', 'M': 'L', 'F': 'Y',\n        'P': 'A', 'S': 'T', 'T': 'S', 'W': 'F', 'Y': 'F', 'V': 'I',\n    }\n    \n    # 3) Residue class function C(r).\n    CLASS_DEFINITIONS = {\n        \"Hydrophobic\":      {'A', 'V', 'I', 'L', 'M', 'F', 'Y', 'W'},\n        \"Polar uncharged\":  {'S', 'T', 'N', 'Q', 'C'},\n        \"Positively charged\": {'K', 'R', 'H'},\n        \"Negatively charged\": {'D', 'E'},\n        \"Special\":          {'G', 'P'},\n    }\n    CLASS_MAP = {\n        residue: class_name\n        for class_name, residues in CLASS_DEFINITIONS.items()\n        for residue in residues\n    }\n    \n    def calculate_e_score(sequence: str, class_map: dict) - int:\n        \"\"\"\n        Calculates the local stability score E(S) for a given sequence.\n        E(s_1...s_n) = sum_{i=1 to n-1} ( I[C(s_i)!=C(s_{i+1})] + \n                                          I[s_i=P or s_{i+1}=P] + \n                                          I[s_i=G or s_{i+1}=G] )\n        \"\"\"\n        n = len(sequence)\n        if n  2:\n            return 0\n            \n        total_score = 0\n        for i in range(n - 1):\n            s_i = sequence[i]\n            s_i_plus_1 = sequence[i+1]\n            \n            pair_score = 0\n            \n            # Term 1: Class change penalty\n            if class_map[s_i] != class_map[s_i_plus_1]:\n                pair_score += 1\n            \n            # Term 2: Proline penalty\n            if s_i == 'P' or s_i_plus_1 == 'P':\n                pair_score += 1\n\n            # Term 3: Glycine penalty\n            if s_i == 'G' or s_i_plus_1 == 'G':\n                pair_score += 1\n                \n            total_score += pair_score\n            \n        return total_score\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (general coverage)\n        [\"ALA\", \"GLY\", \"VAL\", \"ILE\", \"LEU\", \"PRO\", \"ASP\", \"GLU\", \"LYS\", \"ARG\", \"SER\", \"THR\", \"ASN\", \"GLN\", \"PHE\", \"TYR\", \"TRP\", \"CYS\", \"HIS\", \"MET\"],\n        # Case 2 (boundary condition, single residue)\n        [\"PRO\"],\n        # Case 3 (edge case with G and P penalties)\n        [\"GLY\", \"GLY\", \"PRO\", \"ALA\", \"GLY\", \"PRO\"],\n    ]\n    \n    results = []\n    for case_residues_3_letter in test_cases:\n        # Construct wild-type sequence S from 3-letter codes\n        s_wild_type = \"\".join([THREE_TO_ONE[res] for res in case_residues_3_letter])\n        \n        # Construct mutated sequence S'\n        s_mutated = \"\".join([MUTATION_MAP[res] for res in s_wild_type])\n\n        # Calculate E for both sequences\n        e_s = calculate_e_score(s_wild_type, CLASS_MAP)\n        e_s_prime = calculate_e_score(s_mutated, CLASS_MAP)\n\n        # Calculate and store the stability change\n        delta_delta_e = e_s_prime - e_s\n        results.append(delta_delta_e)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "最后的练习将分析提升到一个新的层次，探索蛋白质一级结构的“鲁棒性”。你不再是计算单一的稳定性分数，而是要系统地引入每个可能的单点突变，并衡量其影响，最终得到一个量化“脆弱性”的指标。通过这项练习，你将亲身体验灵敏度分析，并了解我们如何通过计算来探索蛋白质的进化前景。",
            "id": "2412732",
            "problem": "给定一个基于蛋白质一级序列的稳定性代理指标和一个相应的脆性度量的形式化定义。设一级结构是一个基于标准 $20$ 个字母的氨基酸字母表 $\\mathcal{A}=\\{\\text{A},\\text{R},\\text{N},\\text{D},\\text{C},\\text{Q},\\text{E},\\text{G},\\text{H},\\text{I},\\text{L},\\text{K},\\text{M},\\text{F},\\text{P},\\text{S},\\text{T},\\text{W},\\text{Y},\\text{V}\\}$ 的字符串。使用 Kyte–Doolittle 亲疏水性指数值定义一个亲疏水性函数 $h:\\mathcal{A}\\to\\mathbb{R}$ 如下：$h(\\text{A})=1.8$，$h(\\text{R})=-4.5$，$h(\\text{N})=-3.5$，$h(\\text{D})=-3.5$，$h(\\text{C})=2.5$，$h(\\text{Q})=-3.5$，$h(\\text{E})=-3.5$，$h(\\text{G})=-0.4$，$h(\\text{H})=-3.2$，$h(\\text{I})=4.5$，$h(\\text{L})=3.8$，$h(\\text{K})=-3.9$，$h(\\text{M})=1.9$，$h(\\text{F})=2.8$，$h(\\text{P})=-1.6$，$h(\\text{S})=-0.8$，$h(\\text{T})=-0.7$，$h(\\text{W})=-0.9$，$h(\\text{Y})=-1.3$，$h(\\text{V})=4.2$。\n\n对于一个长度为 $L$ 的序列 $s=s_1 s_2\\cdots s_L$，通过肽键间的最近邻相互作用来定义稳定性代理指标 $E(s)$：\n$$\nE(s)=\\sum_{i=1}^{L-1} h(s_i)\\,h(s_{i+1}).\n$$\n按照惯例，对于 $L=1$ 的情况，空和等于 $0$，因此 $E(s)=0$。\n\n一个单点突变体 $s^{(i\\to x)}$ 是通过将位置 $i\\in\\{1,2,\\dots,L\\}$ 的一个氨基酸替换为 $x\\in\\mathcal{A}\\setminus\\{s_i\\}$ 得到的。对于一个非负的去稳定化阈值 $\\tau\\ge 0$，一个单点突变被认为是去稳定化的，当且仅当\n$$\nE\\bigl(s^{(i\\to x)}\\bigr) \\le E(s)-\\tau.\n$$\n\n定义一级序列脆性 $F(s,\\tau)$ 为所有单点突变体中去稳定化突变体所占的比例：\n$$\nF(s,\\tau) = \\frac{D(s,\\tau)}{19\\,L},\n$$\n其中 $D(s,\\tau)$ 是在 $19\\,L$ 种可能的单点替换中，去稳定化单点突变体的数量。每个测试用例所需的输出是 $F(s,\\tau)$ 的值，表示为一个四舍五入到 $6$ 位小数的十进制数。不要使用百分号；以小数形式报告该比例。\n\n您的任务是编写一个完整、可运行的程序，对下面的每个测试用例，根据上述定义计算 $F(s,\\tau)$。测试用例集如下：\n\n- 具有中等阈值的通用情况：$s=\\text{\"MKTIIALSYIFCLVFAD\"}$，$\\tau=0.25$。\n- L=1 的边界情况：$s=\\text{\"G\"}$，$\\tau=0.0$。\n- 疏水性片段：$s=\\text{\"VVVV\"}$，$\\tau=0.0$。\n- 疏水/亲水交替模式：$s=\\text{\"DVDVDV\"}$，$\\tau=0.0$。\n- 大阈值（应产生零脆性）：$s=\\text{\"ACDEFGHIKLMNPQRSTVWY\"}$，$\\tau=100.0$。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\dots]$）。结果必须与上述测试用例的顺序相同，并且每个值都必须四舍五入到 $6$ 位小数。",
            "solution": "在尝试任何解决方案之前，需对问题陈述进行验证。\n\n### 步骤1：提取已知条件\n\n-   **字母表**：$\\mathcal{A}=\\{\\text{A},\\text{R},\\text{N},\\text{D},\\text{C},\\text{Q},\\text{E},\\text{G},\\text{H},\\text{I},\\text{L},\\text{K},\\text{M},\\text{F},\\text{P},\\text{S},\\text{T},\\text{W},\\text{Y},\\text{V}\\}$，包含 $20$ 种标准氨基酸的集合。\n-   **亲疏水性函数**：$h:\\mathcal{A}\\to\\mathbb{R}$ 由 Kyte–Doolittle 指数定义：$h(\\text{A})=1.8$，$h(\\text{R})=-4.5$，$h(\\text{N})=-3.5$，$h(\\text{D})=-3.5$，$h(\\text{C})=2.5$，$h(\\text{Q})=-3.5$，$h(\\text{E})=-3.5$，$h(\\text{G})=-0.4$，$h(\\text{H})=-3.2$，$h(\\text{I})=4.5$，$h(\\text{L})=3.8$，$h(\\text{K})=-3.9$，$h(\\text{M})=1.9$，$h(\\text{F})=2.8$，$h(\\text{P})=-1.6$，$h(\\text{S})=-0.8$，$h(\\text{T})=-0.7$，$h(\\text{W})=-0.9$，$h(\\text{Y})=-1.3$，$h(\\text{V})=4.2$。\n-   **稳定性代理指标**：对于长度为 $L$ 的序列 $s=s_1 s_2\\cdots s_L$，稳定性代理指标为 $E(s)=\\sum_{i=1}^{L-1} h(s_i)\\,h(s_{i+1})$。对于 $L=1$，$E(s)=0$。\n-   **去稳定化突变**：一个单点突变体 $s^{(i\\to x)}$（位置 $i$ 的残基变为 $x$）相对于阈值 $\\tau\\ge 0$ 是去稳定化的，如果 $E\\bigl(s^{(i\\to x)}\\bigr) \\le E(s)-\\tau$。\n-   **脆性度量**：一级序列脆性 $F(s,\\tau)$ 是所有 $19\\,L$ 个单点突变体中去稳定化突变体所占的比例：$F(s,\\tau) = \\frac{D(s,\\tau)}{19\\,L}$，其中 $D(s,\\tau)$ 是这类去稳定化突变体的数量。\n-   **测试用例**：\n    1.  $s=\\text{\"MKTIIALSYIFCLVFAD\"}$，$\\tau=0.25$\n    2.  $s=\\text{\"G\"}$，$\\tau=0.0$\n    3.  $s=\\text{\"VVVV\"}$，$\\tau=0.0$\n    4.  $s=\\text{\"DVDVDV\"}$，$\\tau=0.0$\n    5.  $s=\\text{\"ACDEFGHIKLMNPQRSTVWY\"}$，$\\tau=100.0$\n-   **输出格式**：单行输出，包含一个用方括号括起来的逗号分隔列表，结果四舍五入到 $6$ 位小数。\n\n### 步骤2：使用提取的已知条件进行验证\n\n根据所需标准对问题进行评估。\n\n-   **科学依据**：该问题利用了已确立的 Kyte–Doolittle 亲疏水性标度。稳定性代理指标是一个简化的最近邻相互作用模型，这是计算生物学中用于说明基于序列的性质的常用教学工具。虽然它不是一个完整的物理模型，但它基于合理的科学概念，并非伪科学。\n-   **适定性**：所有术语和函数（$h, E, F$）都具有数学上的精确定义。说明为计算任何给定序列 $s$ 和阈值 $\\tau$ 的脆性提供了清晰、确定性的过程。存在唯一的解，并且可以通过算法计算得出。\n-   **客观性**：问题以形式化、客观的语言陈述，没有主观或基于观点的断言。\n\n该问题不存在任何指定的缺陷。在一个简化模型的背景下，它在科学上是合理的，可进行数学形式化，是完整的，并且是可通过算法解决的。\n\n### 步骤3：结论与行动\n\n问题是**有效的**。将着手开发解决方案。\n\n### 解决方案推导\n\n任务是为一组给定的序列 $s$ 和去稳定化阈值 $\\tau$ 计算脆性 $F(s,\\tau)$。脆性是去稳定化的单点突变所占的比例。在位置 $i$ 处，残基从 $s_i$ 突变为 $x$ 是去稳定化的，如果其稳定性变化满足特定不等式。\n\n一种朴素的方法是生成所有 $19\\,L$ 个突变序列，计算每个序列的稳定性代理指标 $E(s')$，并将其与原始序列的稳定性代理指标 $E(s)$ 进行比较。对于长度为 $L$ 的序列，计算 $E(s)$ 需要 $O(L)$ 次操作。这将导致总复杂度为 $O(L) \\times 19L = O(L^2)$，效率低下。\n\n一种计算效率更高的方法是直接计算稳定性变化 $\\Delta E = E(s^{(i\\to x)}) - E(s)$。定义 $E(s)$ 的总和仅涉及最近邻项。当残基 $s_i$ 突变为 $x$ 时，只有涉及 $s_i$ 的项会受到影响。设 $h_{old} = h(s_i)$ 和 $h_{new} = h(x)$。\n\n变化量 $\\Delta E$ 取决于突变的位置 $i$（在此推导中使用基于 1 的索引）：\n\n1.  **内部位置 ($1   i   L$)：** 涉及 $s_i$ 的原始项是 $h(s_{i-1})h(s_i) + h(s_i)h(s_{i+1})$。新项是 $h(s_{i-1})h(x) + h(x)h(s_{i+1})$。\n    变化量是：\n    $$\n    \\Delta E = \\left( h(s_{i-1})h_{new} + h_{new}h(s_{i+1}) \\right) - \\left( h(s_{i-1})h_{old} + h_{old}h(s_{i+1}) \\right) = (h_{new} - h_{old}) \\left( h(s_{i-1}) + h(s_{i+1}) \\right).\n    $$\n\n2.  **第一个位置 ($i=1, L > 1$)：** 唯一受影响的项是 $h(s_1)h(s_2)$。\n    $$\n    \\Delta E = h_{new}h(s_2) - h_{old}h(s_2) = (h_{new} - h_{old})h(s_2).\n    $$\n\n3.  **最后一个位置 ($i=L, L > 1$)：** 唯一受影响的项是 $h(s_{L-1})h(s_L)$。\n    $$\n    \\Delta E = h(s_{L-1})h_{new} - h(s_{L-1})h_{old} = (h_{new} - h_{old})h(s_{L-1}).\n    $$\n\n4.  **长度为一的序列 ($L=1$)：** 根据定义，对于任何长度为 $1$ 的序列，$E(s)=0$。任何单点突变体也是长度为 $1$ 的序列，所以其稳定性也为 $0$。因此，对于所有突变，$\\Delta E = 0$。\n\n去稳定化突变的条件是 $E(s^{(i\\to x)}) \\le E(s) - \\tau$。使用 $\\Delta E$ 可以将其重写为 $E(s) + \\Delta E \\le E(s) - \\tau$，简化后得到：\n$$\n\\Delta E \\le -\\tau.\n$$\n这使我们能够在 $O(1)$ 时间内检查每个突变的条件，如果需要，可以在初始遍中预计算邻居的亲疏水性值。整体算法的复杂度变为 $O(L)$。\n\n### 算法\n\n对于每个测试用例 $(s, \\tau)$：\n1.  初始化去稳定化突变计数器，$D \\leftarrow 0$。\n2.  设 $L$ 为序列 $s$ 的长度。\n3.  如果 $L=1$，根据问题定义，任何单个残基序列的 $E(s)=0$。那么 $\\Delta E = 0$。去稳定化的条件是 $0 \\le -\\tau$。由于 $\\tau \\ge 0$，这个条件仅当 $\\tau=0$ 时成立。因此，如果 $\\tau=0$，$D=19$；否则 $D=0$。\n4.  如果 $L > 1$，则遍历从 $0$ 到 $L-1$ 的每个位置 $i$（使用基于 0 的索引）：\n    a. 设 $s_i$ 是位置 $i$ 的原始氨基酸。\n    b. 确定其邻居的亲疏水性总和 `context_h`：\n       - 如果 $i=0$：`context_h` = $h(s_1)$。\n       - 如果 $i=L-1$：`context_h` = $h(s_{L-2})$。\n       - 如果 $0  i  L-1$：`context_h` = $h(s_{i-1}) + h(s_{i+1})$。\n    c. 设 $h_{old} = h(s_i)$。\n    d. 遍历字母表 $\\mathcal{A}$ 中的每个氨基酸 $x$：\n       i. 如果 $x$ 与 $s_i$ 相同，则继续下一个氨基酸。\n       ii. 设 $h_{new} = h(x)$。\n       iii. 计算 $\\Delta E = (h_{new} - h_{old}) \\times \\text{context\\_h}$。\n       iv. 如果 $\\Delta E \\le -\\tau$，则将计数器 $D$ 加一。\n5.  在遍历所有位置和所有可能的替换后，计算脆性：$F(s, \\tau) = D / (19 \\times L)$。处理 $L=0$ 的情况以避免除以零，尽管测试用例中没有出现这种情况。\n6.  结果必须四舍五入到 $6$ 位小数。\n\n将实现这个优化算法来解决所提供的测试用例。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\n\ndef solve():\n    \"\"\"\n    Solves the protein primary sequence fragility problem.\n    \"\"\"\n    # Define the Kyte-Doolittle hydropathy index values.\n    HYDROPATHY_MAP = {\n        'A': 1.8, 'R': -4.5, 'N': -3.5, 'D': -3.5, 'C': 2.5,\n        'Q': -3.5, 'E': -3.5, 'G': -0.4, 'H': -3.2, 'I': 4.5,\n        'L': 3.8, 'K': -3.9, 'M': 1.9, 'F': 2.8, 'P': -1.6,\n        'S': -0.8, 'T': -0.7, 'W': -0.9, 'Y': -1.3, 'V': 4.2\n    }\n    AMINO_ACIDS = sorted(HYDROPATHY_MAP.keys())\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\"MKTIIALSYIFCLVFAD\", 0.25),\n        (\"G\", 0.0),\n        (\"VVVV\", 0.0),\n        (\"DVDVDV\", 0.0),\n        (\"ACDEFGHIKLMNPQRSTVWY\", 100.0)\n    ]\n\n    results = []\n\n    for s, tau in test_cases:\n        L = len(s)\n        \n        if L == 0:\n            results.append(0.0)\n            continue\n        \n        if L == 1:\n            # For L=1, E=0. Destabilizing if E_mutant = E_wt - tau, which is 0 = 0 - tau.\n            # This is only true if tau is 0 (since tau >= 0).\n            if tau == 0.0:\n                fragility = 1.0 # All 19 mutants are \"destabilizing\".\n            else:\n                fragility = 0.0 # 0 = -tau is false for tau > 0.\n            results.append(round(fragility, 6))\n            continue\n            \n        destabilizing_mutant_count = 0\n        total_possible_mutants = 19 * L\n\n        # Iterate through each position i in the sequence s\n        for i in range(L):\n            original_aa = s[i]\n            h_old = HYDROPATHY_MAP[original_aa]\n\n            # Calculate the hydropathy sum of the neighbors (context)\n            context_h = 0.0\n            if i == 0:  # First position\n                context_h = HYDROPATHY_MAP[s[i+1]]\n            elif i == L - 1:  # Last position\n                context_h = HYDROPATHY_MAP[s[i-1]]\n            else:  # Interior position\n                context_h = HYDROPATHY_MAP[s[i-1]] + HYDROPATHY_MAP[s[i+1]]\n\n            # Iterate through all possible amino acid substitutions\n            for new_aa in AMINO_ACIDS:\n                if new_aa == original_aa:\n                    continue\n                \n                h_new = HYDROPATHY_MAP[new_aa]\n                \n                # Calculate the change in stability energy\n                delta_E = (h_new - h_old) * context_h\n                \n                # Check if the mutation is destabilizing\n                if delta_E = -tau:\n                    destabilizing_mutant_count += 1\n        \n        fragility = destabilizing_mutant_count / total_possible_mutants\n        results.append(round(fragility, 6))\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}