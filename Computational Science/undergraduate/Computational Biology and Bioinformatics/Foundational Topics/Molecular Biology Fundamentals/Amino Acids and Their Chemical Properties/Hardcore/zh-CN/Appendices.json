{
    "hands_on_practices": [
        {
            "introduction": "氨基酸的净电荷取决于其所处环境的 $pH$ 值。等电点（$pI$）是分子净电荷为零时的特定 $pH$ 值，这是等电聚焦等纯化技术的关键属性。这个练习  将帮助你实践如何将 Henderson-Hasselbalch 方程应用于多质子酸，从而加深你对 $pKa$ 值如何决定电离状态和分子总电荷的理解。",
            "id": "2303334",
            "problem": "等电聚焦 (Isoelectric focusing, IEF) 是一种强大的生物化学技术，用于根据分子的等电点来分离蛋白质和多肽等分子。分子的等电点 ($pI$) 是其净电荷为零时的特定 pH 值。在典型的 IEF 设置中，在凝胶基质中建立一个 pH 梯度。当施加样品时，每个分子在梯度中迁移，直到达到其 $pI$ 对应的 pH 值时停止移动。\n\n一位研究人员正计划进行一项实验来分离氨基酸混合物，并希望预测组氨酸 (Histidine) 在 IEF 凝胶中的最终位置。为此，他们需要计算组氨酸的等电点。给定组氨酸中三个可电离基团的酸解离常数 ($pKa$)：\n\n- $\\alpha$-羧基的 $pKa_1 = 1.82$。\n- 咪唑侧链的 $pKa_R = 6.00$。\n- $\\alpha$-氨基的 $pKa_2 = 9.17$。\n\n计算组氨酸的等电点 ($pI$)。你的答案应报告至三位有效数字。",
            "solution": "在等电聚焦中，等电点 $pI$ 是分子净电荷为零时的 pH 值。对于组氨酸，随着 pH 值升高，相关的顺序去质子化过程如下：\n1) $\\alpha$-羧基在 $pKa_{1}=1.82$ 时去质子化（产生带 $+1$ 电荷的物质），\n2) 咪唑侧链在 $pKa_{R}=6.00$ 时去质子化（产生中性的两性离子物质），\n3) $\\alpha$-氨基在 $pKa_{2}=9.17$ 时去质子化（产生带 $-1$ 电荷的物质）。\n\n在 $pI$ 附近，主要的相互转化物质是 $+1$ 阳离子 ($X^{+}$)、中性两性离子 ($Z^{0}$) 和 $-1$ 阴离子 ($Y^{-}$)。$pI$ 出现在平均电荷为零时，这在 $+1$ 和 $-1$ 形式的浓度相等时达到，即 $[X^{+}] = [Y^{-}]$，因为中性形式不带电荷。\n\n相关的平衡和 Henderson–Hasselbalch 关系式为：\n$$\npH = pKa_{R} + \\log_{10}\\left(\\frac{[Z^{0}]}{[X^{+}]}\\right), \\quad\npH = pKa_{2} + \\log_{10}\\left(\\frac{[Y^{-}]}{[Z^{0}]}\\right).\n$$\n将相应的比率相乘得到\n$$\n\\frac{[Y^{-}]}{[X^{+}]} = 10^{\\left(pH - pKa_{R}\\right)} \\cdot 10^{\\left(pH - pKa_{2}\\right)} = 10^{2 \\cdot pH - \\left(pKa_{R} + pKa_{2}\\right)}.\n$$\n在 $pI$ 时，施加条件 $[Y^{-}] = [X^{+}]$，因此\n$$\n10^{2 \\cdot pH - \\left(pKa_{R} + pKa_{2}\\right)} = 1 \\;\\;\\Longrightarrow\\;\\; 2 \\cdot pH - \\left(pKa_{R} + pKa_{2}\\right) = 0,\n$$\n所以\n$$\npI = \\frac{pKa_{R} + pKa_{2}}{2}.\n$$\n代入给定值，\n$$\npI = \\frac{6.00 + 9.17}{2} = 7.585 \\approx 7.59 \\text{ (to three significant figures).}\n$$\n$\\alpha$-羧基的 $pKa_{1}$ 不计入此平均值，因为在滴定曲线上，组氨酸的中性（两性离子）形式位于 $pKa_{R}$ 和 $pKa_{2}$ 之间。",
            "answer": "$$\\boxed{7.59}$$"
        },
        {
            "introduction": "疏水效应是蛋白质折叠的主要驱动力之一。疏水-极性（HP）模型将这一复杂过程简化为一个基于格点的模拟，其目标是最大化疏水（H）残基之间的接触。通过实现这个简化模型 ，你将获得将核心生物物理学原理转化为计算算法的实践经验，并探索构象空间和能量最小化等概念。",
            "id": "2371271",
            "problem": "要求您使用疏水-极性（HP）模型，在二维方格晶格上实现一个简化的蛋白质折叠模拟器。该模型捕捉了疏水性氨基酸相互接触的趋势。唯一的能量项是疏水性残基之间的接触势。\n\n起点、定义和约束：\n- 底层聚合物链的长度为 $N$，由一个长度为 $N$ 的字符串 $S$ 编码，该字符串的字母表为 $\\{ \\text{H}, \\text{P} \\}$，其中 $\\text{H}$ 表示疏水性残基，$\\text{P}$ 表示极性残基。\n- 一个构象是一个映射 $f : \\{0,1,\\dots,N-1\\} \\to \\mathbb{Z}^2$，满足以下条件：\n  - 方格晶格上的自回避行走：对于所有 $i \\in \\{0,\\dots,N-2\\}$，晶格（曼哈顿）距离满足 $\\| f(i+1) - f(i) \\|_1 = 1$，且 $f$ 是单射的（没有两个残基占据相同的晶格位置）。\n  - 为消除旋转对称性，不失一般性地固定 $f(0) = (0,0)$，并且当 $N \\ge 2$ 时，固定 $f(1) = (1,0)$。\n- 在具有接触势的HP模型下，构象 $f$ 的能量为\n  $$ E(f) = -\\varepsilon \\cdot \\#\\left\\{ \\{i,j\\} \\mid 0 \\le i  j \\le N-1,\\ \\lvert i - j \\rvert > 1,\\ S[i] = \\text{H},\\ S[j] = \\text{H},\\ \\| f(i) - f(j) \\|_1 = 1 \\right\\}, $$\n  其中 $\\varepsilon$ 是一个正常数。在本问题中，取 $\\varepsilon = 1$（无量纲能量单位），因此 $E(f)$ 是一个整数。\n\n任务：\n- 对于每个给定的测试序列 $S$，计算最小可能能量\n  $$ E_{\\min}(S) = \\min_{f} E(f), $$\n  其中最小值是在二维方格晶格上，取遍所有满足上述约束的自回避构象 $f$。\n- 将每个 $E_{\\min}(S)$ 作为整数报告。\n\n您可以假设的基本原理：\n- 在水性环境中，疏水效应驱动疏水性残基聚集，HP模型通过为晶格上相邻的非连续疏水性残基赋予有利的接触能量来近似这一效应。\n- 晶格上的自回避行走为聚合物构象提供了一种组合抽象。\n- 在 $\\mathbb{Z}^2$ 上的曼哈顿距离 $\\| (x_1,y_1) - (x_2,y_2) \\|_1 = |x_1 - x_2| + |y_1 - y_2|$ 在等于1时表示邻接。\n\n程序的输入和输出规范：\n- 没有外部输入。按给定顺序使用以下测试序列套件。\n  - 测试 $1$：$S_1 = \\text{\"H\"}$ (因此 $N = 1$)。\n  - 测试 $2$：$S_2 = \\text{\"HH\"}$ (因此 $N = 2$)。\n  - 测试 $3$：$S_3 = \\text{\"HHHH\"}$ (因此 $N = 4$)。\n  - 测试 $4$：$S_4 = \\text{\"PPPPPP\"}$ (因此 $N = 6$)。\n  - 测试 $5$：$S_5 = \\text{\"HHPHHH\"}$ (因此 $N = 6$)。\n  - 测试 $6$：$S_6 = \\text{\"HPHPPHHPH\"}$ (因此 $N = 9$)。\n- 您的程序应计算每个 $k \\in \\{1,2,3,4,5,6\\}$ 的 $E_{\\min}(S_k)$，并生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，结果顺序与测试顺序相同。例如，格式必须是 $\\left[\\text{res}_1,\\text{res}_2,\\dots,\\text{res}_6\\right]$，其中每个 $\\text{res}_k$ 是一个整数。\n\n注意事项和要求：\n- 仅使用所述的定义和约束；不要假设任何未经证实的捷径。构象空间由 $\\mathbb{Z}^2$ 上的自回避行走定义，并通过所述的锚定来打破旋转对称性。\n- 除了无量纲的 $\\varepsilon = 1$ 外，没有其他物理单位。此问题不涉及角度。\n- 确保您的算法对测试套件中的所有情况都正确，包括 $N = 1$ 和 $N = 2$ 的边界情况。",
            "solution": "我们通过将物理动机与数学上精确的组合模型以及穷举算法过程相结合，构建一个有原则的解决方案。\n\n原理和定义：\n- 在水中，疏水性残基倾向于聚集以最小化与溶剂的接触；疏水-极性（HP）模型通过为空间上相邻的非连续疏水性残基对赋予有利的接触能量来编码这一点。这是对溶剂化自由能贡献的一种粗粒度近似。\n- 我们将聚合物构象表示为二维方格晶格 $\\mathbb{Z}^2$ 上的自回避行走。形式上，一个构象是一个函数 $f : \\{0,1,\\dots,N-1\\} \\to \\mathbb{Z}^2$，使得对于所有 $i \\in \\{0,\\dots,N-2\\}$ 都有 $\\| f(i+1) - f(i) \\|_1 = 1$，且 $f$ 是单射的。不失一般性，为消除全局旋转简并性，我们固定 $f(0) = (0,0)$，并且如果 $N \\ge 2$，固定 $f(1) = (1,0)$。\n- 能量定义为\n  $$ E(f) = -\\varepsilon \\cdot C(f), $$\n  其中 $C(f)$ 是满足 $0 \\le i  j \\le N-1$, $\\lvert i - j \\rvert > 1$, $S[i] = \\text{H}$, $S[j] = \\text{H}$ 且 $\\| f(i) - f(j) \\|_1 = 1$ 的无序对 $\\{i,j\\}$ 的数量。当 $\\varepsilon = 1$ 时，$E(f)$ 仅为疏水接触数的负值。\n\n问题简化：\n- 最小化 $E(f)$ 等价于最大化 $C(f)$，因为 $\\varepsilon = 1$ 是正数。因此，\n  $$ E_{\\min}(S) = - \\max_{f} C(f). $$\n\n算法策略：\n- 我们枚举所有与锚定约束一致的、长度为 $N-1$ 步的自回避行走。这通过带回溯的深度优先搜索（DFS）来完成：\n  - 在搜索过程中，维护一个已放置坐标的列表 $\\left[ f(0), f(1), \\dots, f(k) \\right]$ 和一个已占据晶格位点的哈希集合，其中 $k \\in \\{0,\\dots,N-1\\}$。\n  - 在每一步，尝试通过四个单位晶格移动 $(\\pm 1, 0)$ 和 $(0, \\pm 1)$ 中的一个来扩展行走，前提是目标位点未被占据。\n  - 继续直到构建出一个长度为 $N$ 的完整构象 $f$（即 $k = N-1$），此时计算 $C(f)$ 并更新找到的最佳（最低）能量 $E_{\\min}$。\n- 完整构象的能量计算：\n  - 计算\n    $$ C(f) = \\sum_{0 \\le i  j \\le N-1} \\mathbf{1}\\left[ \\lvert i - j \\rvert > 1 \\right] \\cdot \\mathbf{1}\\left[ S[i] = \\text{H} \\right] \\cdot \\mathbf{1}\\left[ S[j] = \\text{H} \\right] \\cdot \\mathbf{1}\\left[ \\| f(i) - f(j) \\|_1 = 1 \\right], $$\n    其中 $\\mathbf{1}[\\cdot]$ 是指示函数。然后 $E(f) = -C(f)$。\n- 正确性：\n  - DFS 精确地枚举了在锚定约束下的自回避行走集合，因此探索了所有构象（模去全局旋转，而全局旋转不改变 $C(f)$）。因为每个可行的 $f$ 都被评估，并且 $E(f)$ 是根据第一性原理计算的，即非连续相邻残基之间的疏水接触数的负值，所以根据定义，遍及所有枚举构象的最小值就是 $E_{\\min}(S)$。\n- 复杂度考量：\n  - 在 $\\mathbb{Z}^2$ 上，长度为 $n$ 的自回避行走数量约以 $A \\cdot \\mu^n$ 的形式增长，其中连接常数 $\\mu \\approx 2.638$。这里 $n = N-1$。对于测试套件中 $N \\le 9$ 的情况，穷举法在计算上是可行的，特别是当通过 $f(1) = (1,0)$ 固定了旋转对称性后。\n- 边界情况：\n  - 如果 $N = 1$，不存在任何残基对，因此对于唯一的构象 $f(0) = (0,0)$，$C(f) = 0$，所以 $E_{\\min} = 0$。\n  - 如果 $N = 2$，只存在连续的残基对，这被条件 $\\lvert i-j \\rvert > 1$ 排除，因此 $E_{\\min}$ 同样为 $0$。\n  - 对于 $N=4$ 和 $S=\\text{\"HHHH\"}$，一个紧凑的U形构象可以形成一个非连续的疏水接触，得到能量 $E=-1$。穷举搜索证实这是最小能量值。\n\n实现计划：\n  - 硬编码测试套件中的序列 $S_1$ 到 $S_6$。\n  - 对每个 $S_k$，运行 DFS 枚举器来确定 $E_{\\min}(S_k)$。\n  - 打印一行，包含按顺序排列的结果列表 $\\left[ E_{\\min}(S_1), E_{\\min}(S_2), \\dots, E_{\\min}(S_6) \\right]$。\n\n此方法直接源于晶格上HP模型的基本定义，不使用任何启发式捷径，并完全探索了为证实所提供测试用例的最小能量值所需的离散构象空间。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef hp_min_energy(sequence: str) - int:\n    \"\"\"\n    Compute the minimal HP-model energy for a given sequence on a 2D square lattice,\n    using exhaustive enumeration of self-avoiding walks with rotational symmetry fixed.\n\n    Energy E = - (# of nonconsecutive H-H contacts that are adjacent on the lattice).\n    \"\"\"\n    N = len(sequence)\n    # Trivial small cases\n    if N = 1:\n        return 0\n    if N == 2:\n        return 0\n\n    # Directions: right, up, left, down\n    dirs = [(1,0), (0,1), (-1,0), (0,-1)]\n\n    # Anchor positions to break rotational symmetry\n    positions = [(0,0), (1,0)]\n    occupied = {positions[0], positions[1]}\n\n    best_energy = 0  # minimal energy found\n\n    # Precompute H flags for speed\n    is_h = [c == 'H' for c in sequence]\n\n    def manhattan(p, q):\n        return abs(p[0]-q[0]) + abs(p[1]-q[1])\n\n    def energy_of_full_conformation(pos_list):\n        # Count nonconsecutive adjacent H-H contacts\n        contacts = 0\n        for i in range(N):\n            if not is_h[i]:\n                continue\n            pi = pos_list[i]\n            for j in range(i+1, N):\n                if not is_h[j]:\n                    continue\n                if abs(i - j) == 1:\n                    continue                 # consecutive pairs excluded\n                if manhattan(pi, pos_list[j]) == 1:\n                    contacts += 1\n        return -contacts\n\n    # DFS to enumerate all SAWs consistent with anchors\n    def dfs(idx):\n        nonlocal best_energy\n        if idx == N:\n            # Full conformation built\n            e = energy_of_full_conformation(positions)\n            if e  best_energy:\n                best_energy = e\n            return\n\n        curr = positions[-1]\n        for dx, dy in dirs:\n            nx, ny = curr[0] + dx, curr[1] + dy\n            nxt = (nx, ny)\n            if nxt in occupied:\n                continue\n            # Append\n            positions.append(nxt)\n            occupied.add(nxt)\n            dfs(idx + 1)\n            # Backtrack\n            occupied.remove(nxt)\n            positions.pop()\n\n    dfs(2)\n    return best_energy\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        \"H\",          # N=1, boundary\n        \"HH\",         # N=2, boundary\n        \"HHHH\",       # N=4\n        \"PPPPPP\",     # N=6, all polar\n        \"HHPHHH\",     # N=6\n        \"HPHPPHHPH\",  # N=9\n    ]\n\n    results = []\n    for seq in test_cases:\n        result = hp_min_energy(seq)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "不同的氨基酸在 α-螺旋或 β-折叠等特定二级结构中出现的统计偏好（倾向性）各不相同。Chou-Fasman 算法是一种经典方法，它利用这些倾向性从蛋白质的一级序列预测其二级结构。这项实践  要求你从零开始实现一个基于规则的生物信息学算法，将单个氨基酸的化学性质与局部蛋白质结构的预测联系起来，这是生物信息学中的一项基本任务。",
            "id": "2371310",
            "problem": "从第一性原理出发，实现一个基于 Chou–Fasman (CF) 框架的、基于倾向性的蛋白质二级结构预测器。其基本依据包括以下广为接受的事实和定义：根据经验估计，氨基酸具有出现在 α-螺旋和 β-折叠构象中的倾向性；原始的 CF 方法论假设不同位置之间是相互独立的；残基窗口的平均倾向性若超过中性基线，则更有可能成为该二级结构的成核点。设 $P_{\\alpha}(a)$ 和 $P_{\\beta}(a)$ 分别表示氨基酸 $a$ 的螺旋倾向性和折叠倾向性。\n\n使用以下 $20$ 种标准氨基酸的倾向性值（单字母代码，然后是 $P_{\\alpha}$ 和 $P_{\\beta}$）：\n- 丙氨酸 (A): $P_{\\alpha}=1.45$, $P_{\\beta}=0.97$。\n- 精氨酸 (R): $P_{\\alpha}=1.00$, $P_{\\beta}=0.90$。\n- 天冬酰胺 (N): $P_{\\alpha}=0.67$, $P_{\\beta}=0.89$。\n- 天冬氨酸 (D): $P_{\\alpha}=0.98$, $P_{\\beta}=0.80$。\n- 半胱氨酸 (C): $P_{\\alpha}=0.77$, $P_{\\beta}=1.30$。\n- 谷氨酰胺 (Q): $P_{\\alpha}=1.11$, $P_{\\beta}=1.10$。\n- 谷氨酸 (E): $P_{\\alpha}=1.53$, $P_{\\beta}=0.26$。\n- 甘氨酸 (G): $P_{\\alpha}=0.53$, $P_{\\beta}=0.81$。\n- 组氨酸 (H): $P_{\\alpha}=1.24$, $P_{\\beta}=0.71$。\n- 异亮氨酸 (I): $P_{\\alpha}=1.00$, $P_{\\beta}=1.60$。\n- 亮氨酸 (L): $P_{\\alpha}=1.34$, $P_{\\beta}=1.22$。\n- 赖氨酸 (K): $P_{\\alpha}=1.07$, $P_{\\beta}=0.74$。\n- 甲硫氨酸 (M): $P_{\\alpha}=1.20$, $P_{\\beta}=1.67$。\n- 苯丙氨酸 (F): $P_{\\alpha}=1.12$, $P_{\\beta}=1.28$。\n- 脯氨酸 (P): $P_{\\alpha}=0.59$, $P_{\\beta}=0.62$。\n- 丝氨酸 (S): $P_{\\alpha}=0.79$, $P_{\\beta}=0.72$。\n- 苏氨酸 (T): $P_{\\alpha}=0.82$, $P_{\\beta}=1.20$。\n- 色氨酸 (W): $P_{\\alpha}=1.14$, $P_{\\beta}=1.19$。\n- 酪氨酸 (Y): $P_{\\alpha}=0.61$, $P_{\\beta}=1.29$。\n- 缬氨酸 (V): $P_{\\alpha}=0.97$, $P_{\\beta}=1.65$。\n\n推导并实现以下决策过程，该过程根植于独立性假设和倾向性平均值的中性基线 $1.0$：\n\n- α-螺旋成核：沿序列滑动一个长度为 $6$ 的窗口。在从索引 $i$（基于零）开始的窗口中，设 $c_{\\alpha}(i)$ 为 $P_{\\alpha}>1.03$ 的残基数量，$\\overline{P}_{\\alpha}(i)$ 为窗口内 $P_{\\alpha}$ 的算术平均值。如果 $c_{\\alpha}(i)\\ge 4$ 且 $\\overline{P}_{\\alpha}(i) > 1.0$，则将此窗口标记为 α-螺旋种子。\n- β-折叠成核：滑动一个长度为 $5$ 的窗口。在从索引 $j$ 开始的窗口中，设 $c_{\\beta}(j)$ 为 $P_{\\beta}>1.00$ 的残基数量，$\\overline{P}_{\\beta}(j)$ 为窗口内 $P_{\\beta}$ 的算术平均值。如果 $c_{\\beta}(j)\\ge 3$ 且 $\\overline{P}_{\\beta}(j) > 1.0$，则将此窗口标记为 β-折叠种子。\n- 延伸：对于每个种子区域，向两个方向延伸。例如，对于一个跨越索引 $[s, e)$ 的螺旋区域，只要 $e$ 小于序列长度且末端4个残基 $[e-4, e-1]$ 的平均$\\alpha$螺旋倾向性大于1.0，就将 $e$ 增加1。类似地，只要 $s>0$ 且前端4个残基 $[s, s+3]$ 的平均$\\alpha$螺旋倾向性大于1.0，就将 $s$ 减小1。对$\\beta$-折叠区域应用相同的逻辑和阈值。\n- 冲突解决：如果在延伸后，一个残基被同时分配给螺旋和折叠，则比较该连续重叠区域的平均 $P_{\\alpha}$ 和平均 $P_{\\beta}$。将该区域分配给倾向性更高的结构类型。如果倾向性相等，则分配给无规卷曲。\n\n任务：\n对以下测试序列应用您的实现，并报告最终的结构分配。对于每个残基，输出 $1$ 表示 α-螺旋， $2$ 表示 β-折叠， $0$ 表示无规卷曲。\n\n测试序列：\n- `AAAAAAAGAAAA`\n- `VVVVVVVV`\n- `ACDEFGHIKLMNPQRSTVWY`\n- `PPGPPGPP`\n- `EEEELLLVVVVLLLEEEE`\n\n将结果格式化为一个 JSON 风格的列表，其中包含五个列表（对应每个测试序列），用逗号分隔，不带空格。例如，`[[0,1,1,0],[2,2,0]]`。",
            "solution": "该问题要求实现一个基于倾向性的蛋白质二级结构预测算法，该算法基于 Chou-Fasman 方法的原理。该算法将应用于一组测试序列，并且预测结果必须以特定方式格式化。整个过程是确定性的，并遵循一系列明确定义的步骤：成核、延伸和冲突解决。\n\n首先，我们建立基础数据。对于 $20$ 种标准氨基酸中的每一种（用单字母代码 $a$ 表示），我们都获得了两个经验倾向性值：$P_{\\alpha}(a)$ 表示其处于 α-螺旋的倾向性，以及 $P_{\\beta}(a)$ 表示其处于 β-折叠的倾向性。这些值存储在一个查找表中。对于长度为 $n$ 的序列中的每个残基，最终的预测是一个整数：$1$ 代表 α-螺旋 (H)，$2$ 代表 β-折叠 (S)，$0$ 代表无规卷曲 (C)。\n\n该预测算法分四个不同阶段进行。\n\n**阶段 1：成核位点识别**\n\n第一阶段识别蛋白质序列中的短片段，称为“种子”或“成核位点”，这些片段极有可能形成 α-螺旋或 β-折叠。这是通过沿着序列滑动一个固定长度的窗口并应用一组规则来完成的。\n\n1.  **α-螺旋成核**：一个长度为 $L_{\\alpha} = 6$ 的滑动窗口沿序列移动。对于每个从零基索引 $i$ 开始并覆盖残基 $a_i, a_{i+1}, \\ldots, a_{i+5}$ 的窗口：\n    *   我们计算螺旋形成残基的数量 $c_{\\alpha}(i)$，定义为窗口内倾向性 $P_{\\alpha}(a_k) > 1.03$ 的残基计数。\n    *   我们还计算窗口内螺旋倾向性的算术平均值：$\\overline{P}_{\\alpha}(i) = \\frac{1}{6} \\sum_{k=i}^{i+5} P_{\\alpha}(a_k)$。\n    *   如果同时满足以下两个条件，则该窗口被声明为 α-螺旋种子：$c_{\\alpha}(i) \\ge 4$ 且 $\\overline{P}_{\\alpha}(i) > 1.0$。\n\n2.  **β-折叠成核**：对 β-折叠也遵循类似的过程，使用一个长度为 $L_{\\beta} = 5$ 的滑动窗口。对于每个从索引 $j$ 开始并覆盖残基 $a_j, a_{j+1}, \\ldots, a_{j+4}$ 的窗口：\n    *   我们计算折叠形成残基的数量 $c_{\\beta}(j)$，定义为窗口内 $P_{\\beta}(a_k) > 1.00$ 的残基计数。\n    *   我们计算平均折叠倾向性：$\\overline{P}_{\\beta}(j) = \\frac{1}{5} \\sum_{k=j}^{j+4} P_{\\beta}(a_k)$。\n    *   如果 $c_{\\beta}(j) \\ge 3$ 且 $\\overline{P}_{\\beta}(j) > 1.0$，则该窗口被声明为 β-折叠种子。\n\n所有识别出的种子（即一级序列上的连续片段）都被收集起来，用于下一阶段。\n\n**阶段 2：区域延伸**\n\n一旦识别出成核位点，它们就会沿着序列向两个方向（左和右）延伸。只要末端区域对于给定的二级结构类型的倾向性仍然有利，这个过程就会继续。\n\n让一个初始种子区域用半开索引区间 $[s, e)$ 表示。\n\n1.  **螺旋延伸**：对于每个最初跨越 $[s_0, s_0+6)$ 的 α-螺旋种子：\n    *   **向右延伸**：只要 $e  n$（$n$ 是序列长度）并且当前区域尾端的四个残基 $[e-4, e-1]$ 的平均 α-螺旋倾向性高于阈值，区域的结束索引 $e$ 就会重复递增 $1$。条件是：$\\frac{1}{4} \\sum_{k=e-4}^{e-1} P_{\\alpha}(a_k) > 1.0$。\n    *   **向左延伸**：只要 $s > 0$ 并且当前区域前端的四个残基 $[s, s+3]$ 的平均 α-螺旋倾向性高于阈值，区域的开始索引 $s$ 就会重复递减 $1$。条件是：$\\frac{1}{4} \\sum_{k=s}^{s+3} P_{\\alpha}(a_k) > 1.0$。\n\n2.  **折叠延伸**：对每个 β-折叠种子应用相同的逻辑，使用 β-折叠倾向性 $P_{\\beta}$ 和相同的 $1.0$ 阈值，用于 4-残基末端窗口的平均倾向性。\n\n在延伸完每个种子后，所有相同结构类型的最终区域将被合并。这通过创建两个长度为 $n$ 的布尔数组 `is_helix` 和 `is_sheet` 来实现。对于每个最终的延伸螺旋区域 $[s, e)$，所有 $k \\in [s, e)$ 的元素 `is_helix[k]` 都被设置为 true。对折叠区域和 `is_sheet` 数组也进行同样的操作。这一步有效地取得了所有同类型延伸区域的并集。\n\n**阶段 3：冲突解决**\n\n延伸过程可能导致一些残基被同时归类为 α-螺旋和 β-折叠的一部分。这些冲突必须得到解决。\n\n冲突索引集被识别为所有 `is_helix[i]` 和 `is_sheet[i]` 都为 true 的索引 $i$。这些索引被划分为连续的片段。对于每个这样的连续重叠片段，比如从索引 $u$ 到 $v$（包含两端）：\n*   计算平均 α-螺旋倾向性 $\\overline{P}_{\\alpha}([u, v]) = \\frac{1}{v-u+1} \\sum_{k=u}^{v} P_{\\alpha}(a_k)$。\n*   计算平均 β-折叠倾向性 $\\overline{P}_{\\beta}([u, v]) = \\frac{1}{v-u+1} \\sum_{k=u}^{v} P_{\\beta}(a_k)$。\n*   该片段被分配给具有严格更高平均倾向性的结构类型。例如，如果 $\\overline{P}_{\\alpha}([u, v])  \\overline{P}_{\\beta}([u, v])$，该片段被分配给螺旋，并且索引 $u$ 到 $v$ 的 `is_sheet` 标志被设置为 false。\n*   如果平均倾向性完全相等，该片段被分配给无规卷曲，这意味着这些索引的 `is_helix` 和 `is_sheet` 标志都设置为 false。\n\n在此阶段之后，对于任何给定的索引 $i$，`is_helix[i]` 或 `is_sheet[i]` 中最多只有一个可以为 true。\n\n**阶段 4：最终状态分配**\n\n最终的预测是通过遍历已解决的布尔数组生成的：\n*   如果 `is_helix[i]` 为 true，残基 $i$ 被分配为状态 $1$（螺旋）。\n*   如果 `is_sheet[i]` 为 true，残基 $i$ 被分配为状态 $2$（折叠）。\n*   否则，残基 $i$ 被分配为状态 $0$（无规卷曲）。\n\n这个确定性过程为任何给定的氨基酸序列提供了一个唯一的二级结构预测。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the Chou-Fasman based secondary structure prediction algorithm\n    and applies it to the given test cases.\n    \"\"\"\n    \n    propensities = {\n        'A': (1.45, 0.97), 'R': (1.00, 0.90), 'N': (0.67, 0.89),\n        'D': (0.98, 0.80), 'C': (0.77, 1.30), 'Q': (1.11, 1.10),\n        'E': (1.53, 0.26), 'G': (0.53, 0.81), 'H': (1.24, 0.71),\n        'I': (1.00, 1.60), 'L': (1.34, 1.22), 'K': (1.07, 0.74),\n        'M': (1.20, 1.67), 'F': (1.12, 1.28), 'P': (0.59, 0.62),\n        'S': (0.79, 0.72), 'T': (0.82, 1.20), 'W': (1.14, 1.19),\n        'Y': (0.61, 1.29), 'V': (0.97, 1.65),\n    }\n\n    def predict_structure(sequence: str) -> list[int]:\n        n = len(sequence)\n        if n == 0:\n            return []\n\n        seq_p_alpha = np.array([propensities[aa][0] for aa in sequence])\n        seq_p_beta = np.array([propensities[aa][1] for aa in sequence])\n\n        # Stage 1: Nucleation\n        helix_seeds = []\n        win_len_h = 6\n        for i in range(n - win_len_h + 1):\n            window = seq_p_alpha[i : i + win_len_h]\n            count_formers = np.sum(window > 1.03)\n            mean_propensity = np.mean(window)\n            if count_formers >= 4 and mean_propensity > 1.0:\n                helix_seeds.append([i, i + win_len_h])\n\n        sheet_seeds = []\n        win_len_s = 5\n        for j in range(n - win_len_s + 1):\n            window = seq_p_beta[j : j + win_len_s]\n            count_formers = np.sum(window > 1.00)\n            mean_propensity = np.mean(window)\n            if count_formers >= 3 and mean_propensity > 1.0:\n                sheet_seeds.append([j, j + win_len_s])\n        \n        # Stage 2: Extension\n        is_helix = np.zeros(n, dtype=bool)\n        for s, e in helix_seeds:\n            # Extend right\n            current_e = e\n            while current_e  n:\n                if current_e  4: break \n                if np.mean(seq_p_alpha[current_e - 4 : current_e]) > 1.0:\n                    current_e += 1\n                else:\n                    break\n            \n            # Extend left\n            current_s = s\n            while current_s > 0:\n                if np.mean(seq_p_alpha[current_s : current_s + 4]) > 1.0:\n                    current_s -= 1\n                else:\n                    break\n            \n            is_helix[current_s:current_e] = True\n\n        is_sheet = np.zeros(n, dtype=bool)\n        for s, e in sheet_seeds:\n            # Extend right\n            current_e = e\n            while current_e  n:\n                if current_e  4: break\n                if np.mean(seq_p_beta[current_e - 4 : current_e]) > 1.0:\n                    current_e += 1\n                else:\n                    break\n            \n            # Extend left\n            current_s = s\n            while current_s > 0:\n                if np.mean(seq_p_beta[current_s : current_s + 4]) > 1.0:\n                    current_s -= 1\n                else:\n                    break\n            \n            is_sheet[current_s:current_e] = True\n\n        # Stage 3: Conflict Resolution\n        overlap = np.logical_and(is_helix, is_sheet)\n        i = 0\n        while i  n:\n            if overlap[i]:\n                j = i\n                while j  n and overlap[j]:\n                    j += 1\n                \n                # We have a contiguous overlap region [i, j-1]\n                overlap_slice = slice(i, j)\n                mean_alpha = np.mean(seq_p_alpha[overlap_slice])\n                mean_beta = np.mean(seq_p_beta[overlap_slice])\n\n                if mean_alpha > mean_beta:\n                    is_sheet[overlap_slice] = False\n                elif mean_beta > mean_alpha:\n                    is_helix[overlap_slice] = False\n                else: # Equal, assign to coil\n                    is_helix[overlap_slice] = False\n                    is_sheet[overlap_slice] = False\n                i = j\n            else:\n                i += 1\n\n        # Stage 4: Final Assignment\n        prediction = np.zeros(n, dtype=int)\n        prediction[is_helix] = 1\n        prediction[is_sheet] = 2\n        \n        return prediction.tolist()\n\n    test_cases = [\n        \"AAAAAAAGAAAA\",\n        \"VVVVVVVV\",\n        \"ACDEFGHIKLMNPQRSTVWY\",\n        \"PPGPPGPP\",\n        \"EEEELLLVVVVLLLEEEE\",\n    ]\n\n    results = []\n    for case in test_cases:\n        result = predict_structure(case)\n        results.append(result)\n\n    # Format output as specified: a list of lists, comma-separated, no spaces.\n    results_str = \",\".join(str(r) for r in results).replace(\" \", \"\")\n    print(f\"[{results_str}]\")\n\nsolve()\n```"
        }
    ]
}