{
    "hands_on_practices": [
        {
            "introduction": "RNA分子并非静态地存在于单一构象中，而是在一个包含多种可能结构的“折叠景观”中动态变化。这个练习将带你超越寻找最低自由能（$E_{\\min}$）结构，进入一个更广阔的视角。通过实现一个基于动态规划的算法，你将学习如何在一个简化的能量模型下，量化$E_{\\min}$附近竞争性结构的数量。这项实践不仅揭示了RNA折叠预测算法的核心逻辑，也引入了“结构系综”和“折叠受挫”等重要的生物学概念，帮助我们理解RNA功能的构象基础。",
            "id": "2427180",
            "problem": "您将实现一个程序，通过在一个简化但科学标准的模型下，计算竞争性的、近乎最优的二级结构的数量，来量化核糖核酸（RNA）折叠景观的“挫败度”。目标是从第一性原理出发，推导出一个精确的算法，并针对一组给定的RNA序列和能量阈值，计算有多少次优二级结构的能量与最低自由能（MFE）结构相近。\n\n定义和模型假设：\n- RNA序列是基于字母表 $\\{ \\mathrm{A}, \\mathrm{U}, \\mathrm{G}, \\mathrm{C} \\}$ 的字符串。\n- 二级结构是一组非交叉的碱基对 $(i,j)$，其中 $i  j$，每个核苷酸最多属于一个碱基对，且不存在假结（即不存在两个碱基对 $(i,j)$ 和 $(k,\\ell)$ 满足 $i  k  j  \\ell$）。\n- 允许的碱基对及其能量（单位：千卡/摩尔）如下：\n  - $\\mathrm{G}$–$\\mathrm{C}$ 或 $\\mathrm{C}$–$\\mathrm{G}$：能量 $-3$，\n  - $\\mathrm{A}$–$\\mathrm{U}$ 或 $\\mathrm{U}$–$\\mathrm{A}$：能量 $-2$，\n  - $\\mathrm{G}$–$\\mathrm{U}$ 或 $\\mathrm{U}$–$\\mathrm{G}$：能量 $-1$。\n  未配对的核苷酸贡献的能量为 $0$。\n- 发夹环最小长度约束：仅当 $j - i - 1 \\geq 3$ 时，碱基对 $(i,j)$ 才被允许。\n- 一个二级结构 $s$ 的总自由能是其所有碱基对能量的总和，记为 $E(s)$，单位为 $\\mathrm{kcal/mol}$。\n- 最低自由能（MFE）为 $E_{\\min} = \\min_{s} E(s)$，其中 $s$ 是给定序列的所有有效二级结构。\n- 对于一个非负阈值 $\\Delta$（单位为 $\\mathrm{kcal/mol}$），定义挫败度计数为\n  $$F(\\Delta) = \\left| \\left\\{ s \\ \\big| \\ E_{\\min}  E(s) \\leq E_{\\min} + \\Delta \\right\\} \\right|,$$\n  即能量严格大于 MFE 但在 MFE 的 $\\Delta$ 范围内的不同近优结构的数量。不同的结构由不同的碱基对集合定义。\n\n您的任务：\n- 仅使用上述定义，设计一个算法，该算法能够：\n  - 在给定约束下计算序列的 $E_{\\min}$。\n  - 枚举所有有效的二级结构（无假结）及其能量。\n  - 为每个测试用例计算 $F(\\Delta)$。\n- 普适性要求：您的算法必须以纯数学和逻辑术语呈现和实现，仅依赖上述定义和约束，并且应独立于任何特定的外部生物学软件包而易于理解。\n\n单位和数值格式：\n- 能量以 $\\mathrm{kcal/mol}$ 为单位；但您的程序输出的是无单位的计数值，每个都是整数。\n- 不使用角度。\n- 不使用百分比。\n\n测试套件：\n为以下每个 $(\\text{sequence}, \\Delta)$ 对计算 $F(\\Delta)$：\n- 情况 1：序列 \"GCAUCU\"，$\\Delta = 1$。\n- 情况 2：序列 \"GCAUCU\"，$\\Delta = 3$。\n- 情况 3：序列 \"AAAAAA\"，$\\Delta = 5$。\n- 情况 4：序列 \"AUGC\"，$\\Delta = 10$。\n- 情况 5：序列 \"GGGAAACCC\"，$\\Delta = 2$。\n- 情况 6：序列 \"GCAUUGC\"，$\\Delta = 3$。\n- 情况 7：序列 \"GGGCCC\"，$\\Delta = 3$。\n\n最终输出格式：\n- 您的程序应生成单行输出，包含一个逗号分隔的列表，并用方括号括起来（例如，\"[r1,r2,r3,r4,r5,r6,r7]\"），其中每个 $r_k$ 是按指定顺序排列的第 $k$ 个情况的整数挫败度计数 $F(\\Delta)$。",
            "solution": "该问题要求我们为给定的RNA序列计算在指定能量阈值 $\\Delta$ 内，高于最低自由能（MFE）的次优二级结构的数量。这是一个在所有有效的非假结二级结构状态空间上定义的计数问题。此类问题的结构受非交叉条件的约束，天然适合采用动态规划方法，因为一个序列的折叠可以分解为其子序列上的独立折叠问题。\n\n我们将基于此原理设计一个算法。该算法的核心是系统地计算给定RNA序列的每个可能子序列的能量分布。能量分布不仅仅是一个单一的最小值，而是对所有可能能量以及能够达到每种能量的不同结构数量的完整枚举。我们将此分布表示为一个从能量值 $E$ 到计数 $c$ 的映射，表示有 $c$ 个不同的结构具有总自由能 $E$。\n\n设RNA序列为 $S$，长度为 $L$，索引从 $0$ 到 $L-1$。我们定义两个动态规划表 $N$ 和 $C$，其中每个条目 $(i,j)$（$0 \\le i \\le j  L$）存储一个能量分布映射。\n\n1.  $N(i,j)$：此映射存储子序列 $S[i..j]$ 上所有有效二级结构的能量分布。\n2.  $C(i,j)$：此映射存储在核苷酸 $S[i]$ 和 $S[j]$ 形成碱基对的条件下，子序列 $S[i..j]$ 上所有有效二级结构的能量分布。\n\n通过遍历子序列的长度 $d = j-i$（从 $d=0$ 到 $L-1$）来填充这些表。\n\n**基本情况：**\n- 对于空子序列，存在一种结构（空结构），其能量为 $0$。为处理递推中的边界条件，我们定义 $N(i, i-1) = \\{0: 1\\}$。\n- 对于长度为 $1$ 的子序列 $S[i]$，只有一种结构（未配对的核苷酸），其能量为 $0$。因此，$N(i,i) = \\{0: 1\\}$。\n- 更一般地，对于任何太短而无法形成发夹环的子序列 $S[i..j]$，即 $j-i-1  3$，唯一可能的结构是没有任何碱基对的结构，其能量为 $0$。所以，对于 $d = j-i  4$，$N(i,j) = \\{0: 1\\}$，而 $C(i,j)$ 是一个空映射。\n\n**递推关系：**\n对于长度为 $d+1$ 的子序列 $S[i..j]$，其中 $d = j-i$：\n\n首先，我们计算 $C(i,j)$。只有在条件允许的情况下，才能在 $S[i..j]$ 上形成一个 $S[i]$ 和 $S[j]$ 配对的结构。令 $e(S[i], S[j])$ 为该碱基对的能量。此能量仅对规范配对（G-C, A-U, G-U）为非零。发夹环约束要求 $j - i - 1 \\ge 3$。如果满足这些条件，总能量是 $e(S[i], S[j])$ 与内部子序列 $S[i+1..j-1]$ 上任何有效结构的能量之和。因此，$C(i,j)$ 的分布是 $N(i+1, j-1)$ 的分布，其中每个能量都加上了 $e(S[i], S[j])$。\n$$C(i,j)[E + e(S[i],S[j])] = N(i+1, j-1)[E]$$\n此式对分布 $N(i+1, j-1)$ 中的所有能量 $E$ 均成立。如果碱基对 $(i,j)$ 不被允许，$C(i,j)$ 为空。\n\n接下来，我们计算 $N(i,j)$。我们考虑核苷酸 $S[j]$ 的所有可能性。\n1.  **$S[j]$ 未配对：** $S[i..j]$ 的结构集合与 $S[i..j-1]$ 的结构集合相同。因此，我们用 $N(i, j-1)$ 来初始化 $N(i,j)$ 的分布。\n2.  **$S[j]$ 与某个 $S[k]$ 配对（$i \\le k  j$）：** 非交叉约束意味着这种结构可以分解为两个独立部分：外部子序列 $S[i..k-1]$ 上的结构，和子序列 $S[k..j]$ 上 $(k,j)$ 必须配对的结构。后者的能量分布由 $C(k,j)$ 给出。给定能量的总结构数是通过两个独立部分的能量分布的卷积得到的。\n总能量 $E$ 为 $E_{left} + E_{bifurcation}$，其中 $E_{left}$ 来自 $S[i..k-1]$ 上的结构，而 $E_{bifurcation}$ 来自 $S[k..j]$ 上带有配对 $(k,j)$ 的结构。形成这种情况的方式数量为 $c_{left} \\times c_{bifurcation}$。\n\n综合这些情况，$N(i,j)$ 的递推关系为：\n$$N(i,j) = N(i,j-1) \\oplus \\bigoplus_{k=i}^{j-4} \\left( N(i,k-1) \\otimes C(k,j) \\right)$$\n这里，$\\oplus$ 表示通过对相同键的计数求和来合并两个能量分布图，而 $\\otimes$ 表示两个分布的卷积，对应于对所有能量组合的计数进行乘法。对 $k$ 的求和范围到 $j-4$ 为止，以遵循发夹环约束 $j-k-1 \\ge 3$。\n\n**最终计算：**\n在填充 DP 表直到 $N(0, L-1)$ 后，我们获得了整个序列的完整能量分布。设其为 $D_{final} = N(0, L-1)$。\n1.  我们找到最低自由能，$E_{\\min} = \\min(\\text{keys}(D_{final}))$。\n2.  然后我们通过对 $D_{final}$ 中所有满足条件 $E_{\\min}  E \\leq E_{\\min} + \\Delta$ 的能量 $E$ 的计数求和，来计算挫败度计数 $F(\\Delta)$。\n$$F(\\Delta) = \\sum_{E \\in D_{final}, E_{\\min}  E \\leq E_{\\min} + \\Delta} D_{final}[E]$$\n这个过程提供了一个精确、可验证的计数，完全基于问题陈述中阐明的第一性原理。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the RNA frustration count problem for a suite of test cases.\n    \"\"\"\n\n    # --- Problem Definition ---\n\n    # Allowed base pairs and their energies\n    energy_map = {\n        'AU': -2, 'UA': -2,\n        'GC': -3, 'CG': -3,\n        'GU': -1, 'UG': -1,\n    }\n\n    # Hairpin minimum loop length constraint\n    MIN_LOOP_LENGTH = 3\n\n    # Test suite\n    test_cases = [\n        (\"GCAUCU\", 1),\n        (\"GCAUCU\", 3),\n        (\"AAAAAA\", 5),\n        (\"AUGC\", 10),\n        (\"GGGAAACCC\", 2),\n        (\"GCAUUGC\", 3),\n        (\"GGGCCC\", 3),\n    ]\n\n    # --- Algorithm Implementation ---\n    \n    def get_pair_energy(b1, b2):\n        \"\"\"Returns the energy of a base pair.\"\"\"\n        return energy_map.get(b1 + b2, 0)\n\n    def add_distributions(dist1, dist2):\n        \"\"\"Merges two energy distributions.\"\"\"\n        res = dist1.copy()\n        for e, c in dist2.items():\n            res[e] = res.get(e, 0) + c\n        return res\n\n    def convolve_distributions(dist1, dist2):\n        \"\"\"Computes the convolution of two energy distributions.\"\"\"\n        res = {}\n        if not dist1 or not dist2:\n            return res\n        for e1, c1 in dist1.items():\n            for e2, c2 in dist2.items():\n                new_e = e1 + e2\n                new_c = c1 * c2\n                res[new_e] = res.get(new_e, 0) + new_c\n        return res\n\n    def compute_frustration(sequence, delta):\n        \"\"\"\n        Computes the frustration count F(Delta) for a given RNA sequence.\n        \"\"\"\n        n = len(sequence)\n        \n        # N[i][j]: energy distribution for all structures on subsequence S[i..j]\n        # C[i][j]: energy distribution for structures on S[i..j] with (i,j) paired\n        N = [[{} for _ in range(n)] for _ in range(n)]\n        C = [[{} for _ in range(n)] for _ in range(n)]\n\n        # Base case for empty subsequence (N[i][i-1]) used in recurrence\n        N_pre = {0: 1}\n\n        # Initialize for subsequences of length 1\n        for i in range(n):\n            N[i][i] = {0: 1}\n\n        # Fill DP tables by increasing subsequence length d = j - i\n        for d in range(1, n):\n            for i in range(n - d):\n                j = i + d\n\n                # Compute C[i][j]\n                if d > MIN_LOOP_LENGTH:\n                    pair_energy = get_pair_energy(sequence[i], sequence[j])\n                    if pair_energy  0:\n                        internal_dist = N[i + 1][j - 1]\n                        C[i][j] = {e + pair_energy: c for e, c in internal_dist.items()}\n                \n                # Compute N[i][j]\n                # Case 1: j is unpaired\n                dist_N = N[i][j - 1].copy()\n\n                # Case 2: j is paired with k\n                # k must be such that j-k-1 >= MIN_LOOP_LENGTH  => k = j - MIN_LOOP_LENGTH - 1\n                for k in range(i, j - MIN_LOOP_LENGTH):\n                    dist_bifurcation = C[k][j]\n                    if not dist_bifurcation:\n                        continue\n                    \n                    dist_left = N[i][k - 1] if k > i else N_pre\n                    \n                    # Convolve left and bifurcation distributions\n                    convolution_result = convolve_distributions(dist_left, dist_bifurcation)\n                    dist_N = add_distributions(dist_N, convolution_result)\n                \n                N[i][j] = dist_N\n\n        final_distribution = N[0][n - 1]\n        \n        if not final_distribution:\n            return 0\n\n        # Calculate E_min and the frustration count F(Delta)\n        e_min = min(final_distribution.keys())\n        frustration_count = 0\n        for energy, count in final_distribution.items():\n            if e_min  energy = e_min + delta:\n                frustration_count += count\n        \n        return frustration_count\n\n    results = []\n    for seq, delta_val in test_cases:\n        result = compute_frustration(seq, delta_val)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "除了基于热力学的方法，我们还可以从生命的演化历史中寻找RNA结构的线索。当一个突变发生时，为了维持关键的结构功能，与之空间邻近的另一个碱基可能会发生补偿性突变。这项实践将引导你使用信息论中的互信息（Mutual Information）来从多序列比对（MSA）中检测这种共进化信号。更重要的是，你将推导并应用一种关键的偏差校正方法（平均乘积校正，APC），以区分真实的直接接触和虚假的间接相关性，这是从进化数据中准确预测三级结构接触的强大前沿技术。",
            "id": "2427140",
            "problem": "您的任务是利用从多重序列比对 (MSA) 中计算出的共进化信号来预测核糖核酸 (RNA) 中的三级接触点。目标是设计并实现一个程序，该程序从第一性原理出发，利用信息论量构建一个配对共进化分数，然后应用偏差校正以更好地分离出直接的位置耦合。最终的预测将与提供的真实接触点基准集进行评估。您的方法必须源自以下基本原理和核心定义，且在您的推理过程中不得使用任何未从这些基础推导出的简化公式：分子生物学中心法则（脱氧核糖核酸到核糖核酸到蛋白质）、香农熵的定义以及互信息的定义。\n\n所要求的基本定义如下。对于一个在有限字母表上具有概率质量函数 $p(x)$ 的离散随机变量 $X$，香农熵定义为\n$$\nH(X) = - \\sum_{x} p(x) \\log p(x),\n$$\n其中 $\\log$ 表示以 $e$ 为底的自然对数。对于一对离散随机变量 $(X,Y)$，其联合概率质量函数为 $p(x,y)$，边际概率为 $p(x)$ 和 $p(y)$，互信息为\n$$\nI(X;Y) = \\sum_{x}\\sum_{y} p(x,y)\\,\\log\\frac{p(x,y)}{p(x)\\,p(y)}.\n$$\n您必须使用这些定义作为构建算法的基本基础。\n\n您需要以一种有原则的方式实现以下概念性步骤。\n- 从 MSA 出发，将每个比对列视为一个在大小为 $q=5$ 的字母表 $\\{\\texttt{A}, \\texttt{C}, \\texttt{G}, \\texttt{U}, \\texttt{-}\\}$ 上的离散随机变量，其中 $\\texttt{-}$ 表示缺口。设该比对包含 $N$ 条等长为 $L$ 的序列。\n- 对于每个位置对 $(i,j)$（其中 $1 \\le i  j \\le L$），使用基于计数的频率估计和狄利克雷（加性）伪计数先验来估计联合分布 $p_{ij}(x,y)$。具体来说，通过向每个配对状态 $(x,y)$ 添加一个伪计数 $\\alpha$ 来实现拉普拉斯平滑，然后进行归一化以获得有效的联合概率分布。相应的边际概率通过分别对 $y$ 或 $x$ 的联合概率求和来计算。在所有计算中，使用以 $e$ 为底的自然对数。\n- 使用上面互信息 $I$ 的基本定义来计算每个配对 $(i,j)$ 的初始共进化分数。\n- 在进行三级接触预测之前，推导并应用一种校正方法，以移除每个位置的平均背景偏差，从而更好地近似直接耦合。该校正必须基于减去一个可分离的平均偏差分量的原理，该分量由每个位置的均值和配对分数矩阵的全局均值构建，以减少由整体位置变异性和有限样本效应引入的伪相关。您的推导不得依赖任何简化公式；相反，您必须从所述原理出发，为最终实现的校正形式提供理由。\n- 通过仅考虑序列间隔至少为 $s$ 的配对，即满足 $|i-j| \\ge s$ 的配对，来排除平凡的局部邻居。\n- 对于每个测试用例，按校正后的分数对符合条件的位置对进行降序排名。当分数相同时，按 $(i,j)$（其中 $i  j$）的字典序对配对进行排序。\n- 通过将您的前 $k$ 个预测与真实的（“基准”）接触集进行比较，来评估预测的准确性。准确率应报告为精确率@k，即您的前 $k$ 个预测中属于真实接触集的比例。\n\n测试套件和参数：\n- 伪计数：$\\alpha=0.5$\n- 序列间隔：$s=3$\n- 评估等级：$k=2$\n- 基准集：每个测试用例均提供一个基准集。\n- 测试用例A：\n  - MSA（12条序列，长度10）：`[\"AACGUCCGUA\", \"UCGCGAGUGU\", \"GGAUAUAACC\", \"CUUGCGCCAG\", \"ACUCUUGGGA\", \"UAGGCCCUUU\", \"GGCUUAACCG\", \"CUACAGGAGC\", \"AAUUCCAUUU\", \"UCCGGUCCGA\", \"GGGCUAGACG\", \"CUUUAGAGAC\"]`\n  - 接触点（1-based）：$\\{(3, 10), (5, 8)\\}$\n- 测试用例B：\n  - MSA（6条序列，长度8）：`[\"ACGUACGU\", \"ACGUACGU\", \"ACGUACGU\", \"ACGUACGU\", \"ACGUACGU\", \"ACGUACGU\"]`\n  - 接触点（1-based）：空集\n- 测试用例C：\n  - MSA（10条序列，长度8）：`[\"ACGUACGU\", \"CGUAGUCG\", \"GUACCAUC\", \"UACGUGAA\", \"-CGUACG-\", \"-GUAGUC-\", \"AUCGAUGU\", \"CAGUGACG\", \"GCUACGUC\", \"UGACUCAA\"]`\n  - 接触点（1-based）：$\\{(2, 9)\\}$\n\n输出格式：\n- 您必须输出一个用方括号括起来的逗号分隔的字符串列表，例如 `\"[0.500,0.000,1.000]\"`。每个字符串代表按顺序排列的测试用例的精确率@k，格式化为三位小数。",
            "solution": "该问题要求开发一种计算方法，从多重序列比对 (MSA) 中预测 RNA 分子的三级接触。该方法需从信息论的第一性原理构建，并且必须包含一种有原则的偏差校正。问题陈述的有效性已得到确认，因为它在科学上基于生物信息学和信息论的既定概念，是适定的，所有必要的参数和数据都已指定，并以客观、正式的语言表述。因此，该问题是有效的，将按如下方式构建解决方案。\n\n该方法的核心是量化 MSA 中残基位置对之间的共进化。两个位置之间强烈的共进化信号表明，它们可能处于补偿性进化压力下，以维持结构或功能上的相互作用，例如三级接触。\n\n设给定的 MSA 由 $N$ 条长度为 $L$ 的序列组成。残基字母表为 $\\mathcal{A} = \\{\\texttt{A}, \\texttt{C}, \\texttt{G}, \\texttt{U}, \\texttt{-}\\}$，大小为 $q=5$。对于 $i \\in \\{1, \\dots, L\\}$，MSA 的每一列 $i$ 都可以建模为一个离散随机变量 $X_i$，其取值来自 $\\mathcal{A}$。\n\n步骤 1：概率分布的估计\n\n为了量化共进化，我们首先需要估计单个位置和位置对的概率分布。对于任何一对列 $(i,j)$（其中 $1 \\le i  j \\le L$），我们估计所有 $x, y \\in \\mathcal{A}$ 的联合概率质量函数 $p_{ij}(x,y) = P(X_i=x, X_j=y)$。\n\n从一个包含 $N$ 条序列的有限样本中鲁棒地估计这些概率至关重要。我们使用带有加性伪计数的频率计数法，这是一种对应于狄利克雷先验的贝叶斯估计技术。这种方法常被称为拉普拉斯平滑，它能防止未观察到的状态出现零概率，从而避免在对数计算中出现问题。\n\n设 $f_{ij}(x,y)$ 为 MSA 中第 $i$ 列和第 $j$ 列中残基对 $(x,y)$ 的观测频率计数。我们向 $q^2$ 个可能的配对状态中的每一个添加一个伪计数 $\\alpha > 0$。估计的联合概率则为：\n$$\np_{ij}(x,y) = \\frac{f_{ij}(x,y) + \\alpha}{N + q^2 \\alpha}\n$$\n分母 $N + q^2 \\alpha$ 是归一化常数，即所有原始计数（$N$）与所有伪计数之和（$q^2 \\alpha$）的总和。\n\n从联合概率分布 $p_{ij}(x,y)$，我们通过求和推导出边际概率分布 $p_i(x)$ 和 $p_j(y)$：\n$$\np_i(x) = \\sum_{y \\in \\mathcal{A}} p_{ij}(x,y) \\quad \\text{和} \\quad p_j(y) = \\sum_{x \\in \\mathcal{A}} p_{ij}(x,y)\n$$\n这些边际分布与联合分布一致，确保了 $\\sum_{x \\in \\mathcal{A}} p_i(x) = 1$ 和 $\\sum_{y \\in \\mathcal{A}} p_j(y) = 1$。\n\n步骤 2：互信息作为共进化分数\n\n信息论中的互信息 (MI) 用于衡量两个随机变量之间的统计依赖性。对于 MSA 列对 $(i,j)$ 的 MI 定义为：\n$$\nMI_{ij} = I(X_i; X_j) = \\sum_{x \\in \\mathcal{A}}\\sum_{y \\in \\mathcal{A}} p_{ij}(x,y)\\,\\log\\frac{p_{ij}(x,y)}{p_i(x)\\,p_j(y)}\n$$\n其中对数是自然对数（以 $e$ 为底）。较高的 $MI_{ij}$ 值表示位置 $i$ 和 $j$ 之间存在强烈的统计耦合。然而，MI 易受系统发育历史和有限样本效应产生的背景噪声的影响，这可能为并非直接接触的配对产生高分。\n\n步骤 3：偏差校正的推导\n\n为了从背景噪声中分离出直接耦合的信号，必须对原始的 $MI$ 分数应用校正。问题指定了要基于减去一个可分离的平均偏差分量来推导校正。我们假设观测到的分数 $MI_{ij}$ 是真实直接耦合信号 $D_{ij}$ 和一个背景偏差项 $B_{ij}$ 的和，该偏差项可近似分离为来自每个位置的贡献。\n$$\nMI_{ij} = D_{ij} + B_{ij}\n$$\n让我们将偏差项 $B_{ij}$ 建模为位置特异性因子的乘积：$B_{ij} \\approx \\beta_i \\beta_j$。我们假设直接耦合信号 $D_{ij}$ 是稀疏的（即，仅对少数对应于真实接触的配对为非零），而背景偏差 $B_{ij}$ 是稠密的。在此假设下，位置 $i$ 的平均分数将主要由偏差贡献主导。\n\n设 $\\overline{MI}_{i\\cdot}$ 表示位置 $i$ 相对于所有其他位置 $k \\neq i$ 的平均 MI 分数，而 $\\overline{MI}_{\\cdot\\cdot}$ 是所有配对 $(k,l)$（其中 $k \\neq l$）的全局平均 MI 分数。\n$$\n\\overline{MI}_{i\\cdot} = \\frac{1}{L-1} \\sum_{k \\neq i} MI_{ik} \\approx \\frac{1}{L-1} \\sum_{k \\neq i} \\beta_i \\beta_k = \\beta_i \\left(\\frac{1}{L-1} \\sum_{k \\neq i} \\beta_k\\right) = \\beta_i \\bar{\\beta}\n$$\n全局平均值为：\n$$\n\\overline{MI}_{\\cdot\\cdot} = \\frac{1}{L(L-1)} \\sum_{k \\neq l} MI_{kl} \\approx \\frac{1}{L(L-1)} \\sum_{k \\neq l} \\beta_k \\beta_l \\approx \\bar{\\beta}^2\n$$\n从这些近似中，我们可以用可观测的平均值来表示偏差因子 $\\beta_i$：$\\beta_i \\approx \\overline{MI}_{i\\cdot} / \\bar{\\beta}$。将此代入偏差模型 $B_{ij} \\approx \\beta_i \\beta_j$ 中：\n$$\nB_{ij} \\approx \\left(\\frac{\\overline{MI}_{i\\cdot}}{\\bar{\\beta}}\\right) \\left(\\frac{\\overline{MI}_{j\\cdot}}{\\bar{\\beta}}\\right) = \\frac{\\overline{MI}_{i\\cdot}\\overline{MI}_{j\\cdot}}{\\bar{\\beta}^2}\n$$\n使用 $\\bar{\\beta}^2 \\approx \\overline{MI}_{\\cdot\\cdot}$，我们得到了偏差项的估计值：\n$$\nB_{ij} \\approx \\frac{\\overline{MI}_{i\\cdot}\\overline{MI}_{j\\cdot}}{\\overline{MI}_{\\cdot\\cdot}}\n$$\n校正后的分数，称为平均积校正 (APC)，是通过从原始 MI 分数中减去此偏差项得到的：\n$$\nAPC_{ij} = MI_{ij} - \\frac{\\overline{MI}_{i\\cdot}\\overline{MI}_{j\\cdot}}{\\overline{MI}_{\\cdot\\cdot}}\n$$\n这种校正有效地降低了那些两个位置都与所有其他位置表现出高平均 MI 的配对的 MI 分数，而这正是背景噪声的特征。\n\n步骤 4：接触预测与评估\n\n接触预测的最终算法如下：\n1.  对于一个包含 $N$ 条序列且长度为 $L$ 的 MSA，计算所有配对 $(i,j)$（其中 $1 \\le i  j \\le L$）的原始 $MI_{ij}$ 分数。\n2.  从 $MI$ 分数矩阵中，计算所有配对的经 APC 校正的分数 $APC_{ij}$。\n3.  筛选配对，只考虑潜在的三级接触，排除局部邻居。我们只保留满足序列间隔标准 $|i-j| \\ge s$（其中 $s=3$）的配对 $(i,j)$。\n4.  根据其 $APC_{ij}$ 分数对符合条件的配对进行降序排名。平局由配对 $(i,j)$ 的字典序打破。\n5.  从此排名列表中选择前 $k=2$ 个配对作为预测的接触点。\n6.  通过计算 top-k 精确率来评估预测准确性，即 top-k 预测中出现在真实接触点基准集里的比例。\n$$\n\\text{Precision@k} = \\frac{|\\{\\text{Top-}k \\text{ 预测}\\} \\cap \\{\\text{真实接触点}\\}|}{k}\n$$\n此过程将应用于每个测试用例，使用指定的参数：伪计数 $\\alpha=0.5$，间隔阈值 $s=3$，以及评估排名 $k=2$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the RNA contact prediction problem for all test cases.\n    \"\"\"\n\n    # --- Parameter Definition ---\n    s = 3  # Sequence separation threshold\n    k = 2  # Top-k predictions for precision calculation\n    alpha = 0.5  # Pseudocount for probability estimation\n    alphabet = {'A': 0, 'C': 1, 'G': 2, 'U': 3, '-': 4}\n    q = len(alphabet)\n\n    # --- Test Case Definitions ---\n    test_cases = [\n        {\n            \"name\": \"A\",\n            \"msa\": [\n                \"AACGUCCGUA\", \"UCGCGAGUGU\", \"GGAUAUAACC\", \"CUUGCGCCAG\",\n                \"ACUCUUGGGA\", \"UAGGCCCUUU\", \"GGCUUAACCG\", \"CUACAGGAGC\",\n                \"AAUUCCAUUU\", \"UCCGGUCCGA\", \"GGGCUAGACG\", \"CUUUAGAGAC\"\n            ],\n            \"contacts\": {(3, 10), (5, 8)}\n        },\n        {\n            \"name\": \"B\",\n            \"msa\": [\n                \"ACGUACGU\", \"ACGUACGU\", \"ACGUACGU\",\n                \"ACGUACGU\", \"ACGUACGU\", \"ACGUACGU\"\n            ],\n            \"contacts\": set()\n        },\n        {\n            \"name\": \"C\",\n            \"msa\": [\n                \"ACGUACGU\", \"CGUAGUCG\", \"GUACCAUC\", \"UACGUGAA\",\n                \"-CGUACG-\", \"-GUAGUC-\", \"AUCGAUGU\", \"CAGUGACG\",\n                \"GCUACGUC\", \"UGACUCAA\"\n            ],\n            \"contacts\": {(2, 9)}\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        msa = case[\"msa\"]\n        true_contacts = case[\"contacts\"]\n        N = len(msa)\n        L = len(msa[0])\n\n        precision = calculate_precision(msa, true_contacts, L, N, q, alpha, s, k, alphabet)\n        results.append(f\"{precision:.3f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef calculate_precision(msa, true_contacts, L, N, q, alpha, s, k, alphabet):\n    \"\"\"\n    Calculates the precision@k for a single test case.\n    \"\"\"\n    # 1. Convert MSA characters to integer representation for numpy\n    msa_int = np.array([[alphabet[res] for res in seq] for seq in msa], dtype=int)\n\n    # 2. Calculate Mutual Information (MI) matrix\n    mi_matrix = np.zeros((L, L))\n    for i in range(L):\n        for j in range(i + 1, L):\n            # 2a. Calculate joint frequency counts\n            freq_ij = np.zeros((q, q), dtype=float)\n            for seq_idx in range(N):\n                res_i = msa_int[seq_idx, i]\n                res_j = msa_int[seq_idx, j]\n                freq_ij[res_i, res_j] += 1\n            \n            # 2b. Estimate joint probability distribution with pseudocount\n            prob_ij = (freq_ij + alpha) / (N + q**2 * alpha)\n\n            # 2c. Estimate marginal probabilities by summing over the joint distribution\n            prob_i = prob_ij.sum(axis=1)\n            prob_j = prob_ij.sum(axis=0)\n\n            # 2d. Calculate Mutual Information\n            # Term p_i(x) * p_j(y) is calculated using an outer product.\n            # Due to alpha > 0, all probabilities are non-zero, avoiding log(0).\n            p_i_p_j = np.outer(prob_i, prob_j)\n            \n            # Avoid log(0) for prob_ij, though alpha should prevent this.\n            # Create a mask for non-zero elements in prob_ij\n            non_zero_mask = prob_ij > 1e-12\n            log_ratio = np.zeros_like(prob_ij)\n            log_ratio[non_zero_mask] = np.log(prob_ij[non_zero_mask] / p_i_p_j[non_zero_mask])\n            \n            # The mutual information is the expectation of the log-ratio\n            mi = np.sum(prob_ij * log_ratio)\n            mi_matrix[i, j] = mi_matrix[j, i] = mi\n\n    # 3. Apply Average Product Correction (APC)\n    apc_matrix = np.zeros((L, L))\n    if L > 1:\n        # Calculate row/column and global averages.\n        # Note: Diagonal of mi_matrix is zero.\n        # Mean for position i is the sum of row i divided by (L-1).\n        mean_mi_i = mi_matrix.sum(axis=1) / (L - 1)\n        # Global mean is the sum of all elements divided by L*(L-1) off-diagonal pairs.\n        mean_mi_global = mi_matrix.sum() / (L * (L - 1)) if (L * (L - 1)) > 0 else 0\n\n        if mean_mi_global > 1e-9: # Avoid division by zero\n            # Correction term is outer product of position-wise means, normalized by global mean.\n            correction = np.outer(mean_mi_i, mean_mi_i) / mean_mi_global\n            apc_matrix = mi_matrix - correction\n        else: # If no background signal, APC score equals MI score\n            apc_matrix = mi_matrix\n        np.fill_diagonal(apc_matrix, 0)\n\n    # 4. Filter, rank pairs, and get top-k predictions\n    candidate_pairs = []\n    for i in range(L):\n        for j in range(i + 1, L):\n            # Apply sequence separation filter: |i-j| >= s\n            if (j - i) >= s:\n                # Store tuple for sorting: (-score, i, j)\n                # Negating score allows for descending order sort.\n                # (i, j) provides lexicographical tie-breaking.\n                candidate_pairs.append((-apc_matrix[i, j], i, j))\n    \n    candidate_pairs.sort()\n    \n    top_k_predictions = []\n    for idx in range(min(k, len(candidate_pairs))):\n        _, pred_i, pred_j = candidate_pairs[idx]\n        top_k_predictions.append(tuple(sorted((pred_i, pred_j))))\n\n    # 5. Calculate Precision@k\n    # Convert 1-based ground truth contacts to 0-based for comparison\n    true_contacts_0based = set()\n    for c1, c2 in true_contacts:\n        true_contacts_0based.add(tuple(sorted((c1 - 1, c2 - 1))))\n    \n    correct_predictions = 0\n    for pred_pair in top_k_predictions:\n        if pred_pair in true_contacts_0based:\n            correct_predictions += 1\n            \n    precision = correct_predictions / k if k > 0 else 0.0\n    return precision\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "机器学习为我们提供了一种全新的视角来解决生物学问题，它不依赖于复杂的物理模型，而是直接从数据中学习规律。本练习将指导你构建一个机器学习回归器，以仅根据序列信息来预测RNA双链的熔解温度（$T_m$）——这是衡量其热稳定性的关键指标。你将基于生物学直觉（如GC含量和最近邻相互作用）设计特征，并应用岭回归这一强大的线性模型进行拟合。这项实践是生物信息学中应用机器学习的绝佳入门，它突出了特征工程的重要性，并展示了数据驱动方法如何有效地捕捉复杂的生物物理关系。",
            "id": "2427183",
            "problem": "给定由四种核糖核苷酸——腺嘌呤 (A)、尿嘧啶 (U)、鸟嘌呤 (G) 和胞嘧啶 (C)——组成的短核糖核酸 (RNA) 序列。假定在固定的缓冲液条件下，每条序列在等链浓度下与其反向互补链形成完美的双链结构。因此，熔解温度的任何变化仅源于序列的组成和顺序。熔解温度，记为 $T_m$，是在热力学平衡状态下，一半双链结构变性时的温度。经过充分检验的生物物理学事实表明，双链的稳定性源于沃森-克里克 (Watson–Crick) 碱基配对和碱基堆积相互作用，并且鸟嘌呤-胞嘧啶含量和最近邻二核苷酸堆积对稳定性有显著贡献。您的任务是实现一个机器学习回归器，通过从带标签的样本中学习，仅根据序列来预测 $T_m$。\n\n设计的基本依据：\n- 分子生物学的中心法则指出，遗传信息从脱氧核糖核酸 (DNA) 流向 RNA，再到蛋白质，但在这里我们只关注 RNA 碱基配对形成双链的过程。\n- RNA 双链的稳定性由碱基配对和堆积决定；最近邻模型将双链视为沿链的二核苷酸贡献的总和，对于长度为 $L$ 的序列，相邻碱基对的数量为 $L-1$。\n- 更长的双链和更高的鸟嘌呤-胞嘧啶比例通常更稳定，因此有用的特征必须编码长度、鸟嘌呤-胞嘧啶含量和最近邻组成，而无需假定任何特定的 $T_m$ 目标公式。\n\n您必须：\n- 仅使用序列将每个序列表示为一个定长的实值特征向量。至少包括以下内容：\n  - 一个长度为 $16$ 的向量，对应于集合 $\\{ \\text{AA}, \\text{AU}, \\text{AG}, \\text{AC}, \\text{UA}, \\text{UU}, \\text{UG}, \\text{UC}, \\text{GA}, \\text{GU}, \\text{GG}, \\text{GC}, \\text{CA}, \\text{CU}, \\text{CG}, \\text{CC} \\}$ 中所有二核苷酸的归一化计数。其中，如果 $L \\ge 2$，每个分量等于该二核苷酸的计数除以 $(L-1)$；如果 $L  2$，则等于 $0$。\n  - 鸟嘌呤-胞嘧啶核苷酸的比例，定义为当 $L \\ge 1$ 时，鸟嘌呤或胞嘧啶核苷酸的数量除以 $L$；如果 $L = 0$，则为 $0$。\n  - 长度 $L$ 本身作为一个实值特征。\n  - 一个截距项。\n- 对训练数据拟合一个带有平方损失和 $\\ell_2$ 正则化（岭回归）的线性模型，使用闭式正规方程解。不要使用迭代训练或随机元素。\n- 使用生成的模型预测测试集的 $T_m$，将每个预测值四舍五入到两位小数。所有温度均以摄氏度表示。\n\n数学和算法要求：\n- 从 $N$ 个训练序列和每个序列的 $d$ 个特征构建一个设计矩阵 $X \\in \\mathbb{R}^{N \\times d}$，以及一个标签向量 $y \\in \\mathbb{R}^{N}$，其中包含给定的以摄氏度为单位的 $T_m$ 值。\n- 使用 $\\ell_2$ 正则化，正则化强度 $\\alpha > 0$ 应用于除截距外的所有系数。通过求解正规方程来计算岭回归解：\n$$\n\\left(X^\\top X + \\Lambda\\right) w = X^\\top y,\n$$\n其中 $w \\in \\mathbb{R}^{d}$ 是系数向量（包括截距），$\\Lambda \\in \\mathbb{R}^{d \\times d}$ 是一个对角矩阵，其对角线元素对于非截距系数为 $\\alpha$，对于截距系数为 $0$。不允许使用其他拟合程序。\n\n训练数据（序列, $T_m$ 单位为摄氏度）：\n- $\\text{AUAUAU}$，$22.0$\n- $\\text{GCGCGC}$，$54.0$\n- $\\text{AUGCUA}$，$34.0$\n- $\\text{GGGCCC}$，$57.0$\n- $\\text{AAAAAA}$，$18.0$\n- $\\text{CCGGCC}$，$53.0$\n- $\\text{AUGGCAU}$，$39.0$\n- $\\text{GGAUCC}$，$44.0$\n- $\\text{AUGCAUGC}$，$47.0$\n- $\\text{GCAUGCAC}$，$49.0$\n- $\\text{ACGUACGU}$，$45.0$\n- $\\text{UUUUUUUU}$，$20.0$\n- $\\text{GGGGGGGG}$，$68.0$\n- $\\text{AUAUAUAU}$，$30.0$\n- $\\text{GCGCGCGC}$，$62.0$\n- $\\text{AUGCUAGC}$，$48.0$\n- $\\text{CGAUCG}$，$41.0$\n- $\\text{AUGGCCAU}$，$53.0$\n- $\\text{AUGCUAGCUA}$，$56.0$\n- $\\text{GGCAUUGCCG}$，$63.0$\n\n测试集（预测每个序列的 $T_m$，单位为摄氏度）：\n- $\\text{AUAU}$\n- $\\text{GCGC}$\n- $\\text{AUGCAU}$\n- $\\text{GGCAUGCC}$\n- $\\text{ACACACAC}$\n- $\\text{GGAACCUU}$\n- $\\text{GC}$\n\n涵盖的边缘情况包括长度为 $L=2$ 和 $L=4$ 的短序列、低鸟嘌呤-胞嘧啶含量和高鸟嘌呤-胞嘧啶含量。\n\n您的程序必须：\n- 完全按照规定从序列构建特征。\n- 使用固定的 $\\alpha = 10^{-3}$，通过闭式正规方程拟合岭回归模型。\n- 按照上面列出的顺序预测测试集序列的 $T_m$。\n- 将每个预测的 $T_m$ 四舍五入到两位小数。\n- 生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，例如 $[\\dots]$。\n\n角度单位不适用。所有温度必须以摄氏度为单位进行解释，并报告为不带单位符号的十进制数。不允许用户输入或外部数据；程序必须是自包含和确定性的。",
            "solution": "所呈现的问题是生物信息学和应用机器学习中的一个经典练习，要求为短 RNA 双链的熔解温度 $T_m$ 构建一个预测模型。该任务需要通过对一组从 RNA 序列派生的特征应用岭回归来完成。问题陈述具有科学依据，定义明确，并包含确定性解决方案所需的所有必要信息。因此，它是有效的。我们开始进行求解。\n\n目标是找到一个从 RNA 序列到其熔解温度 $T_m$ 的映射。我们将构建一个形式为 $\\hat{T}_m = w^\\top x$ 的线性模型，其中 $x$ 是从序列派生的特征向量，$w$ 是从数据中学到的系数向量。\n\n**步骤 1：特征工程**\n\n第一个也是最关键的步骤是将离散的 RNA 序列转换为连续的实值特征向量。根据规定，对于长度为 $L$ 的序列 $S$，特征向量 $x \\in \\mathbb{R}^{d}$ 必须封装其长度、碱基组成和最近邻内容。我们定义一个维度为 $d=19$ 的特征向量，其结构如下：\n\n1.  **截距项 ($x_0$)**：一个常数值 $1$。该项 $x_0 = 1$ 允许模型学习一个与任何序列特定属性无关的基线 $T_m$ 值。\n\n2.  **鸟嘌呤-胞嘧啶 (GC) 比例 ($x_1$)**：此特征定义为鸟嘌呤 ($G$) 和胞嘧啶 ($C$) 核苷酸数量与序列总长度的比值。\n    $$\n    x_1 = \\frac{N_G + N_C}{L} \\text{ for } L \\ge 1\n    $$\n    并且当 $L=0$ 时 $x_1 = 0$。此特征捕捉了众所周知的 GC 对的稳定效应，GC 对形成三个氢键，而 AU 对则形成两个氢键。\n\n3.  **序列长度 ($x_2$)**：序列本身的长度 $L$，即 $x_2 = L$。由于累积的碱基堆积和氢键相互作用数量更多，更长的双链通常更稳定。\n\n4.  **二核苷酸频率 ($x_3, \\dots, x_{18}$)**：这是一组 $16$ 个特征，代表所有可能的二核苷酸的归一化频率。二核苷酸集合为 $\\{\\text{AA}, \\text{AU}, \\text{AG}, \\text{AC}, \\ldots, \\text{CC}\\}$。我们按照问题陈述中的规定为这 $16$ 个二核苷酸建立一个固定的顺序。对于这个有序集合中的每个二核苷酸 $D_k$，其对应的特征 $x_{k+3}$ 计算如下：\n    $$\n    x_{k+3} = \\frac{\\text{count}(D_k)}{L-1} \\text{ for } L \\ge 2\n    $$\n    并且当 $L  2$ 时 $x_{k+3} = 0$。除数 $L-1$ 是长度为 $L$ 的序列中二核苷酸步骤的总数。这些特征代表了最近邻堆积相互作用对双链稳定性的贡献，这是核酸热力学模型的基石。\n\n因此，对于任何给定的 RNA 序列，我们都可以构建一个唯一的 $19$ 维特征向量 $x = [x_0, x_1, \\dots, x_{18}]^\\top$。\n\n**步骤 2：模型构建与训练**\n\n我们获得一个包含 $N=20$ 个序列及其相应测量的 $T_m$ 值的训练集。我们将这些数据组织成一个设计矩阵 $X \\in \\mathbb{R}^{N \\times d}$ 和一个标签向量 $y \\in \\mathbb{R}^{N}$。$X$ 的第 $i$ 行是第 $i$ 个训练序列的特征向量 $x^{(i)\\top}$，对应的条目 $y_i$ 是其测量的 $T_m$。这里，$d=19$。\n\n我们采用岭回归来学习系数向量 $w \\in \\mathbb{R}^{d}$。该模型最小化一个带有系数 $\\ell_2$ 范数惩罚的平方误差损失函数：\n$$\n\\min_{w} \\| Xw - y \\|_2^2 + \\alpha \\sum_{j=1}^{d-1} w_j^2\n$$\n注意，根据规定，惩罚项应用于除截距 $w_0$ 之外的所有系数。正则化参数 $\\alpha > 0$ 控制着拟合数据与惩罚大系数值之间的权衡，这有助于防止过拟合。\n\n最优权重向量 $w$ 是通过求解为岭回归修改后的正规方程找到的：\n$$\n\\left(X^\\top X + \\Lambda\\right) w = X^\\top y\n$$\n此处，$\\Lambda$ 是一个实现选择性正则化的 $d \\times d$ 对角矩阵。由于我们的截距项对应于第一个特征（索引为 $0$），$\\Lambda$ 的对角线元素为：\n$$\n\\Lambda_{jj} = \\begin{cases} 0  \\text{if } j=0 \\\\ \\alpha  \\text{if } j \\in \\{1, 2, \\dots, d-1\\} \\end{cases}\n$$\n问题指定了固定的正则化强度 $\\alpha = 10^{-3}$。\n\n矩阵 $(X^\\top X + \\Lambda)$ 是对称的，并且对于 $\\alpha > 0$ 是正定的，从而保证其可逆。权重向量 $w$ 的解是通过求解这个线性系统得到的：\n$$\nw = \\left(X^\\top X + \\Lambda\\right)^{-1} X^\\top y\n$$\n在计算上，直接求解该系统比显式计算矩阵的逆在数值上更稳定。\n\n**步骤 3：预测**\n\n一旦从训练数据中确定了权重向量 $w$，它就构成了我们的预测模型。为了预测新测试序列的熔解温度 $\\hat{T}_m$，我们首先使用完全相同的特征工程过程构建其特征向量 $x_{\\text{test}} \\in \\mathbb{R}^{d}$。然后通过点积计算预测值：\n$$\n\\hat{T}_m = x_{\\text{test}}^\\top w\n$$\n每个测试序列的最终结果需要四舍五入到两位小数。这个确定性程序保证了可复现的结果。该解决方案完全按照这些规范实现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a ridge regression model to predict RNA melting temperature (Tm)\n    based on sequence features, using a closed-form normal equation solution.\n    \"\"\"\n    \n    # Training data: (sequence, Tm in Celsius)\n    training_data = [\n        (\"AUAUAU\", 22.0),\n        (\"GCGCGC\", 54.0),\n        (\"AUGCUA\", 34.0),\n        (\"GGGCCC\", 57.0),\n        (\"AAAAAA\", 18.0),\n        (\"CCGGCC\", 53.0),\n        (\"AUGGCAU\", 39.0),\n        (\"GGAUCC\", 44.0),\n        (\"AUGCAUGC\", 47.0),\n        (\"GCAUGCAC\", 49.0),\n        (\"ACGUACGU\", 45.0),\n        (\"UUUUUUUU\", 20.0),\n        (\"GGGGGGGG\", 68.0),\n        (\"AUAUAUAU\", 30.0),\n        (\"GCGCGCGC\", 62.0),\n        (\"AUGCUAGC\", 48.0),\n        (\"CGAUCG\", 41.0),\n        (\"AUGGCCAU\", 53.0),\n        (\"AUGCUAGCUA\", 56.0),\n        (\"GGCAUUGCCG\", 63.0)\n    ]\n\n    # Test suite sequences for which to predict Tm\n    test_sequences = [\n        \"AUAU\",\n        \"GCGC\",\n        \"AUGCAU\",\n        \"GGCAUGCC\",\n        \"ACACACAC\",\n        \"GGAACCUU\",\n        \"GC\"\n    ]\n    \n    # Regularization parameter\n    alpha = 1e-3\n    \n    # Ordered list of dinucleotides for feature vector construction\n    dinucl_order = [\n        'AA', 'AU', 'AG', 'AC', 'UA', 'UU', 'UG', 'UC', \n        'GA', 'GU', 'GG', 'GC', 'CA', 'CU', 'CG', 'CC'\n    ]\n    dinucl_map = {d: i for i, d in enumerate(dinucl_order)}\n    num_features = 1 + 1 + 1 + len(dinucl_order) # Intercept, GC-frac, length, dinucleotides\n\n    def featurize(sequence: str) -> np.ndarray:\n        \"\"\"\n        Converts an RNA sequence into a fixed-length feature vector.\n        Feature vector order: [intercept, gc_fraction, length, dinucleotide_freqs...]\n        \"\"\"\n        features = np.zeros(num_features)\n        L = len(sequence)\n\n        # 1. Intercept term (index 0)\n        features[0] = 1.0\n\n        # 2. GC-fraction (index 1)\n        if L > 0:\n            gc_count = sequence.count('G') + sequence.count('C')\n            features[1] = gc_count / L\n        else:\n            features[1] = 0.0\n\n        # 3. Length (index 2)\n        features[2] = float(L)\n\n        # 4. Dinucleotide frequencies (indices 3 to 18)\n        if L >= 2:\n            counts = {d: 0 for d in dinucl_order}\n            for i in range(L - 1):\n                dinuc = sequence[i:i+2]\n                if dinuc in counts:\n                    counts[dinuc] += 1\n            \n            # Normalize counts\n            for dinuc, count in counts.items():\n                features[3 + dinucl_map[dinuc]] = count / (L - 1)\n        \n        return features\n\n    # --- Model Training ---\n\n    # Construct the design matrix X and label vector y\n    num_training_samples = len(training_data)\n    X = np.zeros((num_training_samples, num_features))\n    y = np.zeros(num_training_samples)\n\n    for i, (seq, tm) in enumerate(training_data):\n        X[i, :] = featurize(seq)\n        y[i] = tm\n    \n    # Construct the regularization matrix Lambda\n    # The intercept (at index 0) is not regularized\n    Lambda = np.diag([0.0] + [alpha] * (num_features - 1))\n    \n    # Solve the normal equations: (X^T X + Lambda) w = X^T y\n    XTX = X.T @ X\n    XTy = X.T @ y\n    \n    A = XTX + Lambda\n    \n    # Solve for the weight vector w\n    try:\n        w = np.linalg.solve(A, XTy)\n    except np.linalg.LinAlgError:\n        # Fallback to pseudoinverse if solving fails, though unlikely with regularization\n        w = np.linalg.pinv(A) @ XTy\n\n    # --- Prediction ---\n\n    results = []\n    for seq in test_sequences:\n        # Generate feature vector for the test sequence\n        x_test = featurize(seq)\n        \n        # Predict Tm\n        tm_pred = x_test @ w\n        \n        # Round to two decimal places and store\n        results.append(round(tm_pred, 2))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}