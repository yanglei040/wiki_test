{
    "hands_on_practices": [
        {
            "introduction": "核糖体RNA（rRNA）分子中的并非所有核苷酸位点都具有同等的重要性；许多位点由于其在维持结构或催化功能方面的关键作用而在进化过程中高度保守。我们可以利用信息论中的概念，特别是香non熵（Shannon entropy），来量化这种保守性。在这个练习中，您将通过计算多序列比对（MSA）中每一列的香non熵，来识别那些几乎没有变异（即低熵）的位点，这些位点很可能受到了功能上的限制。这项实践旨在训练您从序列数据中推断功能重要性的核心生物信息学技能。",
            "id": "2426486",
            "problem": "给定一个来自小亚基核糖体RNA (rRNA)（具体为 $16\\mathrm{S}$ rRNA）片段的固定多序列比对。该比对由 $M=8$ 条序列组成，每条序列的长度为 $L=12$，字符集为 $\\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{U},\\mathrm{T},\\mathrm{N},-\\}$。这些序列是：\n\n- $S_1$: \"AAAAANGACAAG\"\n- $S_2$: \"AAC-UNGACAAT\"\n- $S_3$: \"AAG-T-GACAAU\"\n- $S_4$: \"AAU-C-GAGAAC\"\n- $S_5$: \"AGA-ANGA-UAN\"\n- $S_6$: \"AGC-U-GA-UA-\"\n- $S_7$: \"AGGAT-G--UAA\"\n- $S_8$: \"AGU-CN---AAA\"\n\n对于每个比对列 $j \\in \\{1,\\dots,L\\}$，按如下方式解释字符：\n- 将 $\\mathrm{T}$ 视作 $\\mathrm{U}$。\n- 将符号 $\\mathrm{N}$ 和 $-$ 视为非信息性字符，并将其从该列的所有频率和概率计算中排除。\n- 只有四种规范核糖核苷酸 $\\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{U}\\}$ 对概率有贡献。\n\n经过上述解释后，令 $n(j)$ 为第 $j$ 列中信息性字符的数量，令 $n_b(j)$ 为第 $j$ 列中碱基 $b \\in \\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{U}\\}$ 的数量。通过\n$$\np_b(j) = \\frac{n_b(j)}{n(j)}\n$$\n定义第 $j$ 列的经验碱基概率，此定义适用于 $n_b(j) > 0$ 的碱基 $b$。通过\n$$\nH_j = -\\sum_{\\substack{b \\in \\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{U}\\} \\\\ p_b(j) > 0}} p_b(j)\\,\\log_2 p_b(j),\n$$\n定义第 $j$ 列的香农熵（单位为比特），并约定如果 $n(j)=0$，则 $H_j = 0$。通过\n$$\nc_j = \\frac{n(j)}{M}.\n$$\n定义第 $j$ 列的覆盖度。\n\n当且仅当一个列满足 $H_j \\le \\tau$ 和 $c_j \\ge \\gamma$ 这两个条件时，该列被认为是功能受限的，其中 $\\tau$ 和 $\\gamma$ 为指定的阈值。\n\n您的任务是编写一个程序，对于上述比对，精确地按照定义计算每列 $j \\in \\{1,\\dots,12\\}$ 的 $H_j$ 和 $c_j$，并对于以下每个参数对 $(\\tau,\\gamma)$，返回所有功能受限的列 $j$ 的列表，使用基于1的索引：\n\n测试集（三对参数）：\n- 用例 1：$(\\tau,\\gamma) = (0.0, 0.5)$\n- 用例 2：$(\\tau,\\gamma) = (1.0, 0.5)$\n- 用例 3：$(\\tau,\\gamma) = (2.0, 0.75)$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含所有三个测试用例的结果。结果是一个逗号分隔的列表，用方括号括起来，不含空格。每个用例的结果本身必须是一个方括号括起来的、逗号分隔的所选列索引列表，按升序排列。例如，一个包含三个用例的有效输出应如 \"[[1,2],[3],[4,5,6]]\"。",
            "solution": "该问题要求根据给定的多序列比对（MSA）数据，通过计算香农熵和覆盖度来识别功能受限的列。这是一个定义明确的生物信息学任务。解题过程需要对每一列进行系统性的分析。\n\n首先，我们根据问题中给定的8条序列，逐列（从1到12）提取字符，并进行预处理：将`T`视为`U`，并忽略`N`和`-`。然后我们计算每列的覆盖度 $c_j$ 和香农熵 $H_j$。\n\n给定的比对如下：\n- $S_1$: \"AAAAANGACAAG\"\n- $S_2$: \"AAC-UNGACAAT\"\n- $S_3$: \"AAG-T-GACAAU\"\n- $S_4$: \"AAU-C-GAGAAC\"\n- $S_5$: \"AGA-ANGA-UAN\"\n- $S_6$: \"AGC-U-GA-UA-\"\n- $S_7$: \"AGGAT-G--UAA\"\n- $S_8$: \"AGU-CN---AAA\"\n\n每列计算出的 $H_j$ 和 $c_j$ 值总结在下表中。\n\n| 列 ($j$) | 处理后的字符 | $n(j)$ | 碱基计数 ($n_b(j)$) | $c_j$ | 香农熵 $H_j$ (比特) |\n|:---:|:---|:---:|:---|:---:|:---:|\n| 1 | `AAAAAAAA` | 8 | A:8 | 1.0 | $0.0$ |\n| 2 | `AAAAGGGG` | 8 | A:4, G:4 | 1.0 | $1.0$ |\n| 3 | `ACGUACGG` | 8 | A:2, C:2, G:3, U:1 | 1.0 | $\\approx 1.906$ |\n| 4 | `AGAA` | 4 | A:3, G:1 | 0.5 | $\\approx 0.811$ |\n| 5 | `UUCACUU` | 7 | A:1, C:2, U:4 | 0.875 | $\\approx 1.379$ |\n| 6 | `G` | 1 | G:1 | 0.125 | $0.0$ |\n| 7 | `AGAGAGA` | 7 | A:4, G:3 | 0.875 | $\\approx 0.985$ |\n| 8 | `CAAG` | 4 | A:2, C:1, G:1 | 0.5 | $1.5$ |\n| 9 | `ACCAC` | 5 | A:2, C:3 | 0.625 | $\\approx 0.971$ |\n| 10| `AAAAUUUA` | 8 | A:5, U:3 | 1.0 | $\\approx 0.955$ |\n| 11| `GUTC AAAA` | 8 | A:4, C:1, G:1, U:2 | 1.0 | $1.75$ |\n| 12| `GTUCAA` | 6 | A:2, C:1, G:1, U:2 | 0.75 | $\\approx 1.918$ |\n\n利用这些精确计算的值，我们对每个测试用例评估约束条件 $H_j \\le \\tau$ 和 $c_j \\ge \\gamma$。\n\n**用例 1: $(\\tau, \\gamma) = (0.0, 0.5)$**\n我们需要 $H_j = 0.0$ 且 $c_j \\ge 0.5$。\n- 第1列：$H_1=0.0$，$c_1=1.0$。满足条件。\n- 第6列：$H_6=0.0$，但 $c_6=0.125  0.5$。不满足条件。\n此用例的功能受限列集合为 $\\{1\\}$。\n\n**用例 2: $(\\tau, \\gamma) = (1.0, 0.5)$**\n我们需要 $H_j \\le 1.0$ 且 $c_j \\ge 0.5$。\n- 第1列：$H_1=0.0 \\le 1.0$，$c_1=1.0 \\ge 0.5$。满足。\n- 第2列：$H_2=1.0 \\le 1.0$，$c_2=1.0 \\ge 0.5$。满足。\n- 第4列：$H_4 \\approx 0.811 \\le 1.0$，$c_4=0.5 \\ge 0.5$。满足。\n- 第7列：$H_7 \\approx 0.985 \\le 1.0$，$c_7=0.875 \\ge 0.5$。满足。\n- 第9列：$H_9 \\approx 0.971 \\le 1.0$，$c_9=0.625 \\ge 0.5$。满足。\n- 第10列：$H_{10} \\approx 0.955 \\le 1.0$，$c_{10}=1.0 \\ge 0.5$。满足。\n其他列不满足至少一个条件。\n此用例的功能受限列集合为 $\\{1, 2, 4, 7, 9, 10\\}$。\n\n**用例 3: $(\\tau, \\gamma) = (2.0, 0.75)$**\n我们需要 $H_j \\le 2.0$ 且 $c_j \\ge 0.75$。\n- 第1列：$H_1=0.0 \\le 2.0$，$c_1=1.0 \\ge 0.75$。满足。\n- 第2列：$H_2=1.0 \\le 2.0$，$c_2=1.0 \\ge 0.75$。满足。\n- 第3列：$H_3 \\approx 1.906 \\le 2.0$，$c_3=1.0 \\ge 0.75$。满足。\n- 第5列：$H_5 \\approx 1.379 \\le 2.0$，$c_5=0.875 \\ge 0.75$。满足。\n- 第7列：$H_7 \\approx 0.985 \\le 2.0$，$c_7=0.875 \\ge 0.75$。满足。\n- 第10列：$H_{10} \\approx 0.955 \\le 2.0$，$c_{10}=1.0 \\ge 0.75$。满足。\n- 第11列：$H_{11}=1.75 \\le 2.0$，$c_{11}=1.0 \\ge 0.75$。满足。\n- 第12列：$H_{12} \\approx 1.918 \\le 2.0$，$c_{12}=0.75 \\ge 0.75$。满足。\n其他列不满足至少一个条件。\n此用例的功能受限列集合为 $\\{1, 2, 3, 5, 7, 10, 11, 12\\}$。\n\n最终结果被编译成所需的输出格式。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport collections\n\ndef solve():\n    \"\"\"\n    Computes functionally constrained columns in an rRNA alignment for three test cases.\n    \"\"\"\n    # Define the alignment and problem constants.\n    sequences = [\n        \"AAAAANGACAAG\",\n        \"AAC-UNGACAAT\",\n        \"AAG-T-GACAAU\",\n        \"AAU-C-GAGAAC\",\n        \"AGA-ANGA-UAN\",\n        \"AGC-U-GA-UA-\",\n        \"AGGAT-G--UAA\",\n        \"AGU-CN---AAA\",\n    ]\n    M = 8  # Number of sequences\n    L = 12 # Length of sequences\n\n    # Test suite parameters (tau, gamma).\n    test_cases = [\n        (0.0, 0.5),\n        (1.0, 0.5),\n        (2.0, 0.75),\n    ]\n\n    # Transpose the alignment to get columns.\n    columns = list(zip(*sequences))\n    \n    # Calculate entropy and coverage for each column.\n    column_metrics = []\n    for j in range(L):\n        column_chars = columns[j]\n        \n        # Pre-process characters: T -> U, filter for informative bases.\n        informative_chars = []\n        for char in column_chars:\n            if char == 'T':\n                informative_chars.append('U')\n            elif char in 'ACGU':\n                informative_chars.append(char)\n        \n        n_j = len(informative_chars)\n        \n        # Calculate coverage (c_j).\n        c_j = n_j / M\n        \n        # Calculate Shannon entropy (H_j).\n        H_j = 0.0\n        if n_j > 0:\n            # Count occurrences of each base in the column.\n            counts = collections.Counter(informative_chars)\n            for base in counts:\n                p_b_j = counts[base] / n_j\n                if p_b_j > 0:\n                    H_j -= p_b_j * np.log2(p_b_j)\n        \n        column_metrics.append({'H': H_j, 'c': c_j})\n\n    # Apply the constraint criteria for each test case.\n    all_results = []\n    for tau, gamma in test_cases:\n        constrained_columns = []\n        for j in range(L):\n            metrics = column_metrics[j]\n            if metrics['H'] = tau and metrics['c'] >= gamma:\n                # Append 1-based index.\n                constrained_columns.append(j + 1)\n        all_results.append(constrained_columns)\n\n    # Format the final output string.\n    # e.g., [[1,2],[3],[4,5,6]]\n    result_str = \",\".join([f\"[{','.join(map(str, res))}]\" for res in all_results])\n    \n    # Final print statement in the exact required format.\n    print(f\"[{result_str}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在理解rRNA功能的过程中，准确预测其二级结构至关重要，但这本身是一个巨大的挑战。幸运的是，我们可以利用进化信息来验证计算预测出的结构。如果一个预测的螺旋（helix）在生物学上是真实的，那么在进化过程中，一个破坏碱基配对的突变通常会被其配对伙伴的另一个“补偿性”突变所抵消，从而恢复结构。这个练习将指导您开发一种算法，通过在多序列比对中量化这些补偿性碱基对变化（Compensatory Base-pair Changes, CBCs），来评估预测螺旋的可靠性，从而将序列分析与结构生物学联系起来。",
            "id": "2426467",
            "problem": "编写一个完整的程序，该程序在给定一个固定的核糖体RNA (rRNA) 多序列比对和一个固定的预测螺旋集的情况下，评估每个螺旋的补偿性碱基对变化 (CBC) 支持度，并报告在几个阈值下有多少螺旋得到验证。\n\n提供了一个核糖体RNA (rRNA) 的多序列比对 (MSA)，该比对包含 $S$ 条长度均为 $L$ 的已对齐序列。所有序列都是基于字母表 {A, C, G, U, -} 的字符串，其中破折号字符表示一个缺口。将一个预测的螺旋视为一个或多个碱基配对的比对列索引对 $(i,j)$ 的集合，其中 $1 \\le i  j \\le L$，使用基于1的索引。\n\n定义经典碱基对集合 $P$ 为 $P = \\{(A,U),(U,A),(G,C),(C,G),(G,U),(U,G)\\}$。对于给定的一对比对列 $(i,j)$ 和一个给定的序列 $k \\in \\{1,\\dots,S\\}$，设 $x_k$ 为第 $i$ 列的核苷酸，$y_k$ 为第 $j$ 列的核苷酸。如果 $(x_k,y_k) \\in P$，则序列 $k$ 在 $(i,j)$ 处贡献一个经典配对状态；否则，对于 $(i,j)$ 而言，该序列将被忽略。\n\n对于给定的一对列 $(i,j)$，将补偿性碱基对变化 (CBC) 的数量定义为满足以下条件的无序序列对 $\\{k,\\ell\\}$（其中 $1 \\le k  \\ell \\le S$）的数量：\n- $(x_k,y_k) \\in P$ 和 $(x_{\\ell},y_{\\ell}) \\in P$ 两者均成立，并且\n- $x_k \\ne x_{\\ell}$ 且 $y_k \\ne y_{\\ell}$。\n\n对于一个由 $m \\in \\{1,\\dots,H_{\\text{pairs}}\\}$ 的配对 $(i_m,j_m)$ 组成的螺旋，将其总CBC计数定义为其所有构成的碱基配对列对的CBC计数之和：\n$$\n\\mathrm{CBC\\_total} = \\sum_{m=1}^{H_{\\text{pairs}}} \\mathrm{CBC}(i_m,j_m).\n$$\n如果一个螺旋的 $\\mathrm{CBC\\_total} \\ge t$，则认为该螺旋在阈值 $t$ 下得到验证。\n\n使用以下固定的MSA（包含 $S=6$ 条序列和 $L=12$ 列），以 $6$ 个等长字符串形式给出：\n\n- $s_1 =$ \"AAGGG--UCCUU\"\n- $s_2 =$ \"GGAGG-ACCUCC\"\n- $s_3 =$ \"-UUGGC-UCAA-\"\n- $s_4 =$ \"-GGGG--GCUU-\"\n- $s_5 =$ \"-CCGGAUCCGG-\"\n- $s_6 =$ \"-AGGG--UCCU-\"\n\n使用以下包含5个预测螺旋的集合，每个螺旋由一个基于1的索引对 $(i,j)$ 的列表指定：\n- 螺旋 $1$：$(2,11)$ 和 $(3,10)$\n- 螺旋 $2$：$(4,9)$\n- 螺旋 $3$：$(5,8)$\n- 螺旋 $4$：$(6,7)$\n- 螺旋 $5$：$(1,12)$\n\n测试套件（在相同的MSA和螺旋集上独立评估四个阈值 $t$）：\n- 情况 $1$：$t = 5$\n- 情况 $2$：$t = 0$\n- 情况 $3$：$t = 1$\n- 情况 $4$：$t = 100$\n\n您的程序必须为每种情况计算在给定阈值 $t$ 下得到验证的螺旋数量。最终输出必须是单行文本，包含一个逗号分隔的4个整数结果列表，按情况顺序排列，并用方括号括起来（例如，“[a,b,c,d]”），不含任何额外文本。无需或不允许用户输入。角度和物理单位不适用于此问题；所有报告的量均为无量纲整数。",
            "solution": "该问题要求基于来自多序列比对 (MSA) 的进化证据，对预测的核糖体RNA (rRNA) 二级结构螺旋进行验证。具体来说，我们必须通过计算补偿性碱基对变化 (CBC) 来量化每个预测螺旋的支持度，然后确定在几个给定的阈值下，有多少螺旋满足验证标准。\n\n提供的输入包括一个包含 $S=6$ 条rRNA序列（每条长度为 $L=12$）的MSA，一个由比对列对定义的包含5个预测螺旋的集合，以及一组用于验证的4个整数阈值。所有列索引都是基于1的，在计算时必须转换为基于0的索引。\n\n一个基本概念是经典碱基对集合，定义为 $P = \\{(A,U),(U,A),(G,C),(C,G),(G,U),(U,G)\\}$。对于给定的一对比对列 $(i,j)$ 和一个序列 $k$，如果在这些列上的核苷酸 $(x_k, y_k)$ 形成一个经典配对状态，即 $(x_k, y_k) \\in P$。\n\n分析的核心在于补偿性碱基对变化 (CBC) 的定义。根据问题陈述，列对 $(i,j)$ 的CBC计数是MSA中满足两个严格条件的无序序列对 $\\{k,\\ell\\}$ 的数量：\n$1$. 两条序列都必须在列 $(i,j)$ 处形成经典配对：$(x_k, y_k) \\in P$ 且 $(x_{\\ell}, y_{\\ell}) \\in P$。\n$2$. 两个位置的核苷酸必须不同：$x_k \\ne x_{\\ell}$ 且 $y_k \\ne y_{\\ell}$。这要求两个位点发生协同变化，例如，从(G,C)变为(A,U)或从(G,C)变为(C,G)，但不包括从(G,C)变为(G,U)的情况，因为第一个碱基未发生变化。\n\n螺旋的总支持度 $\\mathrm{CBC\\_total}$ 是构成该螺旋的所有列对 $(i_m, j_m)$ 的CBC计数之和：$\\mathrm{CBC\\_total} = \\sum_{m=1}^{H_{\\text{pairs}}} \\mathrm{CBC}(i_m,j_m)$。最后，如果一个螺旋的总支持度达到或超过阈值 $t$，即 $\\mathrm{CBC\\_total} \\ge t$，则认为该螺旋在该阈值下得到验证。\n\n该解决方案遵循一个系统的、多步骤的算法：\n\n首先，我们处理输入数据。MSA存储为字符串数组。螺旋集合存储为基于1的索引对的列表的列表。经典配对集合 $P$ 存储在哈希集合中，以便进行高效的 $O(1)$ 查找。\n\n其次，对于螺旋中定义的每个相关的比对列对 $(i,j)$，我们计算其CBC计数。这里采用了一种计算上高效的方法：\n$1$. 对于给定的列对 $(i,j)$，遍历MSA中的所有 $S$ 条序列。\n$2$. 对每个序列 $k$，提取核苷酸对 $(x_k, y_k)$。如果该配对属于集合 $P$，则保留它。\n$3$. 为所有保留的经典配对构建一个频率图（一个多重集）。这个图，我们称之为 $M$，存储找到的每种独特的经典配对类型及其出现的序列数量。\n$4. $通过遍历图 $M$ 中作为键存在的所有不同经典配对类型 $\\{p_a, p_b\\}$ 的无序对来计算CBC计数。设 $p_a = (x_a, y_a)$ 和 $p_b = (x_b, y_b)$。如果满足严格的补偿条件（$x_a \\ne x_b$ 且 $y_a \\ne y_b$），则这两种类型对CBC计数有贡献。在 $p_a$ 类型的序列和 $p_b$ 类型的序列之间形成的CBC数量是它们频率的乘积，即 $M[p_a] \\times M[p_b]$。列对 $(i,j)$ 的总CBC计数是所有合格配对类型的这些乘积之和。\n\n第三，对于5个预测螺旋中的每一个，我们通过将其所有构成列对在上一步中计算的CBC计数相加，来计算其总支持度 $\\mathrm{CBC\\_total}$。\n\n第四，我们根据指定的阈值评估螺旋。对于集合 $\\{5, 0, 1, 100\\}$ 中的每个阈值 $t$，我们遍历5个螺旋，并计算有多少个螺旋的 $\\mathrm{CBC\\_total}$ 值大于或等于 $t$。\n\n此过程产生一个包含4个整数计数的列表，对应于每个阈值下验证的螺旋数量，这就是最终结果。",
            "answer": "```python\nimport collections\n\n# There is no need for numpy or scipy for this problem, but the template requires this formatting.\n# import numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Solves the rRNA helix validation problem based on Compensatory Base-pair Changes (CBCs).\n    \"\"\"\n\n    # --- Step 1: Define Givens from the problem statement ---\n\n    # Multiple Sequence Alignment (S=6, L=12)\n    msa = [\n        \"AAGGG--UCCUU\",\n        \"GGAGG-ACCUCC\",\n        \"-UUGGC-UCAA-\",\n        \"-GGGG--GCUU-\",\n        \"-CCGGAUCCGG-\",\n        \"-AGGG--UCCU-\",\n    ]\n\n    # Predicted Helices (1-based indexing)\n    helices_1_based = {\n        1: [(2, 11), (3, 10)],\n        2: [(4, 9)],\n        3: [(5, 8)],\n        4: [(6, 7)],\n        5: [(1, 12)],\n    }\n    \n    # Convert helices to 0-based indexing for programming convenience\n    helices = {\n        name: [(i - 1, j - 1) for i, j in pairs]\n        for name, pairs in helices_1_based.items()\n    }\n\n    # Canonical Base Pairs\n    canonical_pairs = {\n        ('A', 'U'), ('U', 'A'),\n        ('G', 'C'), ('C', 'G'),\n        ('G', 'U'), ('U', 'G'),\n    }\n\n    # Test cases: Threshold values\n    thresholds = [5, 0, 1, 100]\n    \n    # --- Step 2: Implement the CBC calculation logic ---\n\n    def calculate_cbc_for_pair(col_i, col_j):\n        \"\"\"\n        Calculates the CBC count for a single pair of alignment columns.\n        \"\"\"\n        # Extract pairs from the specified columns for all sequences\n        sequence_pairs = []\n        for seq in msa:\n            pair = (seq[col_i], seq[col_j])\n            if pair in canonical_pairs:\n                sequence_pairs.append(pair)\n\n        # If fewer than 2 sequences have canonical pairs, no CBC is possible.\n        if len(sequence_pairs)  2:\n            return 0\n        \n        # Create a frequency map of the canonical pairs found\n        pair_counts = collections.Counter(sequence_pairs)\n        \n        cbc_count = 0\n        \n        # Get the unique pair types\n        unique_pair_types = list(pair_counts.keys())\n        \n        # Iterate over all unordered pairs of distinct pair types\n        for i in range(len(unique_pair_types)):\n            for j in range(i + 1, len(unique_pair_types)):\n                p_a = unique_pair_types[i]\n                p_b = unique_pair_types[j]\n                \n                x_a, y_a = p_a\n                x_b, y_b = p_b\n                \n                # Check for the strict CBC condition: x_k != x_l AND y_k != y_l\n                if x_a != x_b and y_a != y_b:\n                    # The number of CBCs between these two types is the product of their frequencies\n                    cbc_count += pair_counts[p_a] * pair_counts[p_b]\n                    \n        return cbc_count\n\n    # --- Step 3: Calculate total CBC support for each helix ---\n    \n    helix_total_cbcs = {}\n    for helix_name, column_pairs in helices.items():\n        total_cbc_for_helix = 0\n        for i, j in column_pairs:\n            total_cbc_for_helix += calculate_cbc_for_pair(i, j)\n        helix_total_cbcs[helix_name] = total_cbc_for_helix\n\n    # --- Step 4: Evaluate helices against thresholds and collect results ---\n\n    results = []\n    for t in thresholds:\n        validated_helices_count = 0\n        for helix_name in helices:\n            if helix_total_cbcs[helix_name] >= t:\n                validated_helices_count += 1\n        results.append(validated_helices_count)\n\n    # --- Final Output ---\n    # The final print statement must match the required format exactly.\n    print(f\"[{','.join(map(str, results))}]\")\n\n\nsolve()\n```"
        },
        {
            "introduction": "本练习将带您进入一个在宏基因组学中至关重要的实际应用：数据质量控制。基于rRNA基因（如16S rRNA）的高通量测序是研究微生物群落的基石，但聚合酶链式反应（PCR）扩增步骤可能会产生被称为“嵌合体”的人工序列。这些序列是两个或多个不同亲本序列片段的拼接体，会严重干扰下游分析。您将设计一个检测器，利用基于$k$-mer的相似性度量，在查询序列中寻找相似性从一个亲本切换到另一个亲本的“断点”，从而识别并标记这些有问题的序列。",
            "id": "2426476",
            "problem": "您的任务是设计并实现一个基于原则的检测器，用于检测嵌合核糖体核糖核酸（rRNA）序列，特别是$16\\mathrm{S}$ rRNA。这些序列可能作为聚合酶链式反应（PCR）的假象出现在宏基因组数据集中。该设计必须从计算生物学中基础且经过充分检验的理论出发：中心法则（脱氧核糖核酸到核糖核酸到蛋白质）、PCR扩增可通过模板切换产生嵌合序列这一事实，以及嵌合体的定义，即嵌合体是两个亲本序列串联而成的单个查询序列，其不同的连续片段与不同的亲本具有不同的最近邻相似性关系。\n\n您必须使用字母表 $\\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{T}\\}$ 上的字符串，构建一个纯粹的数学和逻辑算法。核心相似性度量必须基于 $k$-mer 和集合相似性。对于任意字符串 $S$ 和整数 $k \\ge 1$，将 $k$-mer 集合 $\\mathcal{K}_k(S)$ 定义为 $S$ 的所有长度为 $k$ 的连续子串的集合。对于两个集合 $A$ 和 $B$，Jaccard 相似度 $J(A,B)$ 定义为\n$$\nJ(A,B) \\equiv \\frac{|A \\cap B|}{|A \\cup B|}.\n$$\n所有计算都必须使用固定长度为 $k$ 的 $k$-mer，无间隙，并采用集合语义（重复的 $k$-mer 不增加计数）。\n\n您的算法必须通过扫描所有有效断点，来判断给定的查询序列 $Q$ 相对于一个小型参考组 $\\{R_i\\}$ 是否为嵌合体。位置 $b$ 处的断点将 $Q$ 划分为 $Q_{\\mathrm{L}} = Q[1{:}b]$ 和 $Q_{\\mathrm{R}} = Q[b{+}1{:}L]$，其中 $L$ 是 $Q$ 的长度，位置使用 1-索引。一个断点是有效的，当且仅当两个片段都满足最小片段长度 $s_{\\min}$。对于一个候选的不同参考序列对 $(P,Q)$（其中 $P \\ne Q$），定义左、右 Jaccard 相似度\n$$\nJ_{\\mathrm{L}}(b,P) = J\\!\\left(\\mathcal{K}_k(Q_{\\mathrm{L}}), \\mathcal{K}_k(R_P)\\right), \\quad\nJ_{\\mathrm{R}}(b,Q) = J\\!\\left(\\mathcal{K}_k(Q_{\\mathrm{R}}), \\mathcal{K}_k(R_Q)\\right).\n$$\n类似地，定义交叉相似度\n$$\nJ_{\\mathrm{cross,L}}(b,Q) = J\\!\\left(\\mathcal{K}_k(Q_{\\mathrm{L}}), \\mathcal{K}_k(R_Q)\\right), \\quad\nJ_{\\mathrm{cross,R}}(b,P) = J\\!\\left(\\mathcal{K}_k(Q_{\\mathrm{R}}), \\mathcal{K}_k(R_P)\\right).\n$$\n当且仅当存在任何有效断点 $b$ 和任何有序对 $(P,Q)$（其中 $P \\ne Q$）满足以下决策规则时，将查询序列 $Q$ 分类为嵌合体：\n- 两个片段与亲本的相似度都很高：$J_{\\mathrm{L}}(b,P) \\ge t_{\\mathrm{high}}$ 且 $J_{\\mathrm{R}}(b,Q) \\ge t_{\\mathrm{high}}$。\n- 两个交叉相似度都很低：$J_{\\mathrm{cross,L}}(b,Q) \\le t_{\\mathrm{low}}$ 且 $J_{\\mathrm{cross,R}}(b,P) \\le t_{\\mathrm{low}}$。\n\n您必须使用以下固定参数和参考序列来实现此检测器：\n- $k = 5$，$s_{\\min} = 15$，$t_{\\mathrm{high}} = 0.7$，$t_{\\mathrm{low}} = 0.35$。\n- 通过将基序串联并各精确重复 $3$ 次来定义三个参考 $16\\mathrm{S}$ rRNA 样模板序列：\n  - $R_{\\mathrm{A}} = (\\mathrm{ACGTGACCTG}\\,\\Vert\\,\\mathrm{TACGAGTTCC})$ 重复 $3$ 次（这里 $\\Vert$ 表示串联）。\n  - $R_{\\mathrm{B}} = (\\mathrm{GGCTAACGTA}\\,\\Vert\\,\\mathrm{CCGTTAGGCA})$ 重复 $3$ 次。\n  - $R_{\\mathrm{C}} = (\\mathrm{GGCTAACATA}\\,\\Vert\\,\\mathrm{CCGTTAGGTA})$ 重复 $3$ 次。\n\n您必须在一套包含 $5$ 个测试用例的测试套件上评估您的检测器。每个用例都是一个根据明确规则从参考序列构建的查询序列，位置指定为 1-索引。使用作用于单个核苷酸的突变映射 $f$：$f(\\mathrm{A})=\\mathrm{C}$, $f(\\mathrm{C})=\\mathrm{A}$, $f(\\mathrm{G})=\\mathrm{T}$, $f(\\mathrm{T})=\\mathrm{G}$。测试用例如下：\n- 用例 1（带少量噪音的非嵌合体）：$Q_1$ 由 $R_{\\mathrm{A}}$ 形成，在位置 $10$ 和 $35$（均从 $R_{\\mathrm{A}}$ 的起始位置 1-索引计数）应用 $f$，所有其他位置保持不变。\n- 用例 2（明确的双亲本嵌合体）：$Q_2$ 是 $R_{\\mathrm{A}}[1{:}30]$ 与 $R_{\\mathrm{B}}[31{:}60]$ 的串联。\n- 用例 3（因参考序列高度相似而导致的模糊近嵌合体）：$Q_3$ 是 $R_{\\mathrm{B}}[1{:}30]$ 与 $R_{\\mathrm{C}}[31{:}60]$ 的串联。\n- 用例 4（太短无法验证任何断点）：$Q_4$ 是 $R_{\\mathrm{A}}[1{:}14]$ 与 $R_{\\mathrm{B}}[1{:}14]$ 的串联。\n- 用例 5（不平衡但有效的嵌合体）：$Q_5$ 是 $R_{\\mathrm{A}}[1{:}20]$ 与 $R_{\\mathrm{B}}[21{:}60]$ 的串联。\n\n您的程序必须使用上述确切参数和决策规则，按顺序计算这 $5$ 个用例的布尔嵌合体分类。要求的最终输出格式为单行，包含一个用方括号括起来的、逗号分隔的 Python 风格布尔值列表，即严格遵循 $[\\texttt{True},\\texttt{False},\\dots]$ 的形式，不含空格。该测试套件旨在覆盖一个典型的非嵌合体、一个明确的嵌合体、一个因亲本间高度相似而导致的模糊情况、一个 $L  2 s_{\\min}$ 的边界情况，以及一个具有偏离中心断点的有效嵌合体。",
            "solution": "所提出的问题是计算生物学领域中一个明确定义的练习，具体属于生物信息学算法设计范畴。它要求使用基于 $k$-mer 集合相似性的原则性方法，制定并实现一个用于检测嵌合脱氧核糖核酸（DNA）序列的检测器，这些序列是聚合酶链式反应（PCR）扩增过程的假象。问题陈述具有科学依据，逻辑上一致，并为获得唯一解提供了所有必要的参数和定义。因此，该问题被认为是有效的。我们着手解决该问题。\n\n核心任务是确定一个查询序列 $Q$ 相对于参考组 $\\mathcal{R} = \\{R_{\\mathrm{A}}, R_{\\mathrm{B}}, R_{\\mathrm{C}}\\}$ 是否为嵌合体。如果一个序列可以解释为由参考组中两个不同的亲本序列在一个称为断点的特定点连接而成的复合物，则该序列被分类为嵌合体。决策逻辑基于 $k$-mer 集合的 Jaccard 相似度。\n\n首先，我们根据所提供的定义来确定算法的组成部分。\n一个序列 $S$ 的 $k$-mer 集合，表示为 $\\mathcal{K}_k(S)$，是其所有长度为 $k$ 的连续子串的集合。给定两个集合 $A$ 和 $B$，它们的 Jaccard 相似度为 $J(A,B) = \\frac{|A \\cap B|}{|A \\cup B|}$。\n\n给定的参数是固定的：\n- $k$-mer 长度: $k = 5$\n- 最小片段长度: $s_{\\min} = 15$\n- 高相似度阈值: $t_{\\mathrm{high}} = 0.7$\n- 低相似度阈值: $t_{\\mathrm{low}} = 0.35$\n\n参考序列通过将一个碱基基序重复三次来构建：\n- $R_{\\mathrm{A}} = (\\mathrm{ACGTGACCTG} \\Vert \\mathrm{TACGAGTTCC}) \\times 3$，产生一个 60 个碱基的序列。\n- $R_{\\mathrm{B}} = (\\mathrm{GGCTAACGTA} \\Vert \\mathrm{CCGTTAGGCA}) \\times 3$，产生一个 60 个碱基的序列。\n- $R_{\\mathrm{C}} = (\\mathrm{GGCTAACATA} \\Vert \\mathrm{CCGTTAGGTA}) \\times 3$，产生一个 60 个碱基的序列。\n\n对长度为 $L$ 的查询序列 $Q$ 进行分类的算法如下：\n\n1.  **初始验证**：算法必须扫描寻找有效断点。位置 $b$（使用 1-索引）处的断点将 $Q$ 划分为长度为 $b$ 的左片段 $Q_{\\mathrm{L}} = Q[1:b]$ 和长度为 $L-b$ 的右片段 $Q_{\\mathrm{R}} = Q[b+1:L]$。要使断点有效，两个片段都必须足够长：$b \\ge s_{\\min}$ 且 $L-b \\ge s_{\\min}$。这意味着查询序列的总长度必须至少为 $2s_{\\min}$。如果 $L  2s_{\\min}$，则不存在有效断点，该序列不能被分类为嵌合体。在我们的情况下，$L  2 \\times 15 = 30$ 立即意味着非嵌合的结果。\n\n2.  **迭代搜索**：如果查询序列足够长，算法必须穷举搜索嵌合体的证据。这包括遍历所有可能的不同有序亲本参考序列和有效断点的组合。\n    - 设参考序列集为 $\\mathcal{R}$。算法考虑来自 $\\mathcal{R} \\times \\mathcal{R}$ 的每一对不同的有序参考序列 $(R_P, R_Q)$，其中 $R_P \\ne R_Q$。\n    - 对于每一对这样的组合，它遍历所有有效断点 $b$，其中 $b$ 的范围从 $s_{\\min}$ 到 $L-s_{\\min}$。\n\n3.  **决策规则应用**：对于每对 $(R_P, R_Q)$ 和每个断点 $b$，算法执行以下四个相似度计算：\n    - 左片段与亲本 $P$ 的相似度：$J_{\\mathrm{L}}(b,R_P) = J(\\mathcal{K}_k(Q_{\\mathrm{L}}), \\mathcal{K}_k(R_P))$\n    - 右片段与亲本 $Q$ 的相似度：$J_{\\mathrm{R}}(b,R_Q) = J(\\mathcal{K}_k(Q_{\\mathrm{R}}), \\mathcal{K}_k(R_Q))$\n    - 左片段与亲本 $Q$ 的交叉相似度：$J_{\\mathrm{cross,L}}(b,R_Q) = J(\\mathcal{K}_k(Q_{\\mathrm{L}}), \\mathcal{K}_k(R_Q))$\n    - 右片段与亲本 $P$ 的交叉相似度：$J_{\\mathrm{cross,R}}(b,R_P) = J(\\mathcal{K}_k(Q_{\\mathrm{R}}), \\mathcal{K}_k(R_P))$\n\n    当且仅当找到一个 $(R_P, R_Q)$ 和 $b$ 的组合，同时满足决策规则的所有四个条件时，查询序列 $Q$ 才被分类为嵌合体：\n    - $J_{\\mathrm{L}}(b,R_P) \\ge t_{\\mathrm{high}}$\n    - $J_{\\mathrm{R}}(b,R_Q) \\ge t_{\\mathrm{high}}$\n    - $J_{\\mathrm{cross,L}}(b,R_Q) \\le t_{\\mathrm{low}}$\n    - $J_{\\mathrm{cross,R}}(b,R_P) \\le t_{\\mathrm{low}}$\n\n    如果找到这样的组合，搜索将终止并返回 `True` 的分类。如果测试了所有组合都无一满足该规则，则函数返回 `False`。\n\n此逻辑被应用于这 $5$ 个测试用例。查询序列 $Q_1, \\dots, Q_5$ 首先根据其定义构建。突变函数 $f$ 定义为 $f(\\mathrm{A})=\\mathrm{C}$, $f(\\mathrm{C})=\\mathrm{A}$, $f(\\mathrm{G})=\\mathrm{T}$, $f(\\mathrm{T})=\\mathrm{G}$。\n\n- **$Q_1$**：非嵌合体。它是 $R_{\\mathrm{A}}$ 的一个轻微突变版本。对于任何断点 $b$ 和亲本对（例如，$(R_{\\mathrm{A}}, R_{\\mathrm{B}})$），右片段 $Q_{1\\mathrm{R}}$ 仍然与 $R_{\\mathrm{A}}$ 高度相似，无法满足条件 $J_{\\mathrm{R}}(b, R_{\\mathrm{B}}) \\ge t_{\\mathrm{high}}$。算法正确地将其分类为非嵌合体。\n- **$Q_2$**：一个来自 $R_{\\mathrm{A}}$ 和 $R_{\\mathrm{B}}$ 的明确嵌合体。当使用亲本 $(R_P, R_Q) = (R_{\\mathrm{A}}, R_{\\mathrm{B}})$ 和断点 $b=30$ 进行测试时，算法发现 $Q_{\\mathrm{L}}$ 与 $R_{\\mathrm{A}}$ 高度相似，$Q_{\\mathrm{R}}$ 与 $R_{\\mathrm{B}}$ 高度相似，并且由于 $R_{\\mathrm{A}}$ 和 $R_{\\mathrm{B}}$ 是不同的，交叉相似度很低。所有四个条件都满足。\n- **$Q_3$**：一个来自 $R_{\\mathrm{B}}$ 和 $R_{\\mathrm{C}}$ 的模糊嵌合体。潜在的亲本 $R_{\\mathrm{B}}$ 和 $R_{\\mathrm{C}}$ 本身非常相似。它们完整 $k$-mer 集合的 Jaccard 相似度为 $J(\\mathcal{K}_k(R_{\\mathrm{B}}),\\mathcal{K}_k(R_{\\mathrm{C}})) \\approx 0.391$。当使用亲本 $(R_{\\mathrm{B}}, R_{\\mathrm{C}})$ 和断点 $b=30$ 进行测试时，交叉相似度 $J_{\\mathrm{cross,L}}(30, R_{\\mathrm{C}}) = J(\\mathcal{K}_k(Q_{3\\mathrm{L}}), \\mathcal{K}_k(R_{\\mathrm{C}}))$ 很高，因为 $Q_{3\\mathrm{L}}$ 来自于与 $R_{\\mathrm{C}}$ 相似的 $R_{\\mathrm{B}}$。该值约为 $0.391$，大于 $t_{\\mathrm{low}}=0.35$。条件 $J_{\\mathrm{cross,L}} \\le t_{\\mathrm{low}}$ 不成立，因此在这些严格的阈值下，它被正确地分类为非嵌合体。\n- **$Q_4$**：太短。$Q_4$ 的长度为 $L=28$。由于 $L  2s_{\\min}=30$，不存在有效断点。算法立即返回 `False`。\n- **$Q_5$**：一个不平衡但有效的嵌合体。断点位于 $b=20$。这是一个有效的断点，因为 $20 \\ge s_{\\min}$ 且 $60-20=40 \\ge s_{\\min}$。当使用亲本 $(R_{\\mathrm{A}}, R_{\\mathrm{B}})$ 进行测试时，该断点通过了所有四个条件，该序列被正确地分类为嵌合体。\n\n实现将系统地将此逻辑应用于每个用例。",
            "answer": "```python\n# The problem statement specifies numpy as a permitted library, but it is not used.\n# import numpy as np\n# The problem statement specifies scipy as a permitted library, but it is not used.\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Solves the chimera detection problem by implementing the specified algorithm and\n    evaluating it on the given test cases.\n    \"\"\"\n\n    # --- Problem Parameters and Definitions ---\n    K_MER_LEN = 5\n    MIN_SEG_LEN = 15\n    T_HIGH = 0.7\n    T_LOW = 0.35\n\n    # --- Reference Sequence Construction ---\n    motif_a = \"ACGTGACCTG\" + \"TACGAGTTCC\"\n    motif_b = \"GGCTAACGTA\" + \"CCGTTAGGCA\"\n    motif_c = \"GGCTAACATA\" + \"CCGTTAGGTA\"\n\n    ref_a = motif_a * 3\n    ref_b = motif_b * 3\n    ref_c = motif_c * 3\n\n    references = {\n        \"R_A\": ref_a,\n        \"R_B\": ref_b,\n        \"R_C\": ref_c,\n    }\n\n    # --- Test Case Construction ---\n    def mutate(seq_str, pos_1_indexed, mut_map):\n        seq_list = list(seq_str)\n        char_to_mutate = seq_list[pos_1_indexed - 1]\n        seq_list[pos_1_indexed - 1] = mut_map[char_to_mutate]\n        return \"\".join(seq_list)\n\n    mutation_map = {'A': 'C', 'C': 'A', 'G': 'T', 'T': 'G'}\n\n    # Case 1: Non-chimeric with small noise\n    q1 = mutate(ref_a, 10, mutation_map)\n    q1 = mutate(q1, 35, mutation_map)\n\n    # Case 2: Clear two-parent chimera\n    q2 = ref_a[0:30] + ref_b[30:60]\n\n    # Case 3: Ambiguous near-chimera\n    q3 = ref_b[0:30] + ref_c[30:60]\n\n    # Case 4: Too short to validate any breakpoint\n    q4 = ref_a[0:14] + ref_b[0:14]\n\n    # Case 5: Imbalanced but valid chimera\n    q5 = ref_a[0:20] + ref_b[20:60]\n\n    test_cases = [q1, q2, q3, q4, q5]\n\n    # --- Core Algorithmic Functions ---\n    def get_kmer_set(seq, k):\n        \"\"\"Generates the set of k-mers for a given sequence.\"\"\"\n        if len(seq)  k:\n            return set()\n        return {seq[i:i+k] for i in range(len(seq) - k + 1)}\n\n    def jaccard_similarity(set_a, set_b):\n        \"\"\"Calculates the Jaccard similarity between two sets.\"\"\"\n        intersection_size = len(set_a.intersection(set_b))\n        union_size = len(set_a.union(set_b))\n        if union_size == 0:\n            return 1.0  # Convention for two empty sets\n        return intersection_size / union_size\n\n    # --- Main Chimera Detection Logic ---\n    def is_chimeric(query_seq, ref_map, k, s_min, t_high, t_low):\n        \"\"\"\n        Determines if a query sequence is chimeric based on the provided rules.\n        \"\"\"\n        L = len(query_seq)\n        \n        # Condition from problem: L must be >= 2 * s_min for any valid breakpoint\n        if L  2 * s_min:\n            return False\n\n        # Pre-compute k-mer sets for all reference sequences\n        ref_kmers = {name: get_kmer_set(seq, k) for name, seq in ref_map.items()}\n        ref_names = list(ref_map.keys())\n\n        # Iterate through all ordered pairs of distinct references (P, Q)\n        for i in range(len(ref_names)):\n            for j in range(len(ref_names)):\n                if i == j:\n                    continue\n                \n                parent_p_name = ref_names[i]\n                parent_q_name = ref_names[j]\n\n                kmer_set_p = ref_kmers[parent_p_name]\n                kmer_set_q = ref_kmers[parent_q_name]\n\n                # Iterate through all valid breakpoints b\n                for b in range(s_min, L - s_min + 1):\n                    # Partition query sequence (b is 1-indexed length, so slice is up to b)\n                    q_l = query_seq[0:b]\n                    q_r = query_seq[b:L]\n                    \n                    kmer_set_l = get_kmer_set(q_l, k)\n                    kmer_set_r = get_kmer_set(q_r, k)\n\n                    # Calculate the four required Jaccard similarities\n                    j_l_p = jaccard_similarity(kmer_set_l, kmer_set_p)\n                    j_r_q = jaccard_similarity(kmer_set_r, kmer_set_q)\n                    j_cross_l_q = jaccard_similarity(kmer_set_l, kmer_set_q)\n                    j_cross_r_p = jaccard_similarity(kmer_set_r, kmer_set_p)\n\n                    # Apply the decision rule\n                    if (j_l_p >= t_high and j_r_q >= t_high and\n                        j_cross_l_q = t_low and j_cross_r_p = t_low):\n                        return True\n        \n        # If no combination satisfies the rule, it is not chimeric\n        return False\n\n    # --- Evaluate All Test Cases ---\n    results = []\n    for query in test_cases:\n        result = is_chimeric(\n            query,\n            references,\n            K_MER_LEN,\n            MIN_SEG_LEN,\n            T_HIGH,\n            T_LOW\n        )\n        results.append(result)\n\n    # --- Final Output ---\n    # Convert booleans to 'True'/'False' strings as per standard Python list printing\n    # and join into the required format without spaces.\n    results_str = [str(r) for r in results]\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```"
        }
    ]
}