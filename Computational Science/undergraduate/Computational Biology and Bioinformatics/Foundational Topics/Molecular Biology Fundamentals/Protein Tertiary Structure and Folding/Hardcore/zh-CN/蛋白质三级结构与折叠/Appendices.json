{
    "hands_on_practices": [
        {
            "introduction": "蛋白质折叠的一个关键驱动力是疏水残基倾向于在内部紧密堆积，以避开水环境。本练习将指导您如何量化这一物理特性，即计算蛋白质疏水核心的堆积密度，并将其与理想球体堆积的理论极限进行比较。通过这个计算实践，您将学会评估蛋白质结构紧实度的基本方法，从而更深入地理解蛋白质三级结构的物理基础。",
            "id": "2422553",
            "problem": "一个球状蛋白质的疏水核心被近似为一个半径为 $12~\\text{\\AA}$ 的球体。该核心包含以下被埋藏的侧链，其范德华体积（在此模型中假定为可加的）以立方埃（$\\text{\\AA}^3$）为单位给出：\n\n- Phenylalanine (Phe)：$3$ 个残基，每个体积为 $189$\n- Leucine (Leu)：$6$ 个残基，每个体积为 $166$\n- Isoleucine (Ile)：$3$ 个残基，每个体积为 $166$\n- Valine (Val)：$5$ 个残基，每个体积为 $140$\n- Methionine (Met)：$2$ 个残基，每个体积为 $166$\n- Tyrosine (Tyr)：$1$ 个残基，体积为 $193$\n- Tryptophan (Trp)：$1$ 个残基，体积为 $227$\n- Alanine (Ala)：$4$ 个残基，每个体积为 $88$\n- Threonine (Thr)：$2$ 个残基，每个体积为 $116$\n- Cysteine (Cys)：$2$ 个残基，每个体积为 $108$\n- Proline (Pro)：$2$ 个残基，每个体积为 $112$\n\n在此简化模型下，核心的侧链堆积密度定义为被埋藏侧链所占据的核心体积的比例。均匀球体的理论最大堆积密度（Kepler 密堆积）为 $0.74048$。\n\n计算核心的侧链堆积密度与 $0.74048$ 的比值。将最终答案表示为一个无量纲的十进制数，四舍五入到四位有效数字。最终答案中不要包含单位。",
            "solution": "问题陈述经过验证，被认为是科学上合理的、问题明确的、客观的。它基于一个标准的、尽管是简化的模型，该模型用于结构生物信息学中分析蛋白质堆积。所有必要的数据都已提供，定义明确。该问题是有效的，将提供解答。\n\n主要任务是计算所计算出的侧链堆积密度 $\\rho_{\\text{packing}}$ 与均匀球体的理论最大堆积密度 $\\rho_{\\text{max}}$ 的比值。堆积密度定义为构成侧链所占据的核心体积的比例。\n\n首先，我们必须计算所有被埋藏侧链的总范德华体积，记为 $V_{\\text{sc}}$。这是每个单独侧链体积的总和。问题提供了每种残基类型的数量和体积。\n\n总和计算如下：\n$V_{\\text{sc}} = (3 \\times 189) + (6 \\times 166) + (3 \\times 166) + (5 \\times 140) + (2 \\times 166) + (1 \\times 193) + (1 \\times 227) + (4 \\times 88) + (2 \\times 116) + (2 \\times 108) + (2 \\times 112)~\\text{\\AA}^3$。\n\n对每一项进行乘法运算：\n$V_{\\text{Phe}} = 3 \\times 189 = 567~\\text{\\AA}^3$\n$V_{\\text{Leu}} = 6 \\times 166 = 996~\\text{\\AA}^3$\n$V_{\\text{Ile}} = 3 \\times 166 = 498~\\text{\\AA}^3$\n$V_{\\text{Val}} = 5 \\times 140 = 700~\\text{\\AA}^3$\n$V_{\\text{Met}} = 2 \\times 166 = 332~\\text{\\AA}^3$\n$V_{\\text{Tyr}} = 1 \\times 193 = 193~\\text{\\AA}^3$\n$V_{\\text{Trp}} = 1 \\times 227 = 227~\\text{\\AA}^3$\n$V_{\\text{Ala}} = 4 \\times 88 = 352~\\text{\\AA}^3$\n$V_{\\text{Thr}} = 2 \\times 116 = 232~\\text{\\AA}^3$\n$V_{\\text{Cys}} = 2 \\times 108 = 216~\\text{\\AA}^3$\n$V_{\\text{Pro}} = 2 \\times 112 = 224~\\text{\\AA}^3$\n\n将这些值相加，得到总侧链体积：\n$$V_{\\text{sc}} = 567 + 996 + 498 + 700 + 332 + 193 + 227 + 352 + 232 + 216 + 224 = 4537~\\text{\\AA}^3$$\n\n接下来，我们计算疏水核心的体积 $V_{\\text{core}}$，它被近似为一个半径为 $R = 12~\\text{\\AA}$ 的球体。球体的体积由以下公式给出：\n$$V_{\\text{core}} = \\frac{4}{3}\\pi R^3$$\n代入给定的半径：\n$$V_{\\text{core}} = \\frac{4}{3}\\pi (12~\\text{\\AA})^3 = \\frac{4}{3}\\pi (1728)~\\text{\\AA}^3 = 2304\\pi~\\text{\\AA}^3$$\n\n侧链堆积密度 $\\rho_{\\text{packing}}$ 是总侧链体积与核心体积的比值：\n$$\\rho_{\\text{packing}} = \\frac{V_{\\text{sc}}}{V_{\\text{core}}} = \\frac{4537}{2304\\pi}$$\n\n问题要求计算该堆积密度与理论最大堆积密度 $\\rho_{\\text{max}} = 0.74048$ 的比值。设这个要求的比值为 $\\mathcal{R}$。\n$$\\mathcal{R} = \\frac{\\rho_{\\text{packing}}}{\\rho_{\\text{max}}} = \\frac{\\frac{4537}{2304\\pi}}{0.74048} = \\frac{4537}{2304 \\times 0.74048 \\times \\pi}$$\n\n现在，我们进行数值计算：\n$$V_{\\text{core}} = 2304\\pi \\approx 2304 \\times 3.14159265 \\approx 7238.229~\\text{\\AA}^3$$\n$$\\rho_{\\text{packing}} = \\frac{4537}{7238.229} \\approx 0.626815$$\n$$\\mathcal{R} = \\frac{0.626815}{0.74048} \\approx 0.846490$$\n\n问题要求答案四舍五入到四位有效数字。第五位有效数字是 $9$，大于或等于 $5$，所以我们将第四位数字向上取整。\n$$\\mathcal{R} \\approx 0.8465$$\n这个无量纲值表示蛋白质核心相对于均匀球体理想密堆积的堆积效率。",
            "answer": "$$\\boxed{0.8465}$$"
        },
        {
            "introduction": "在真实的生物环境中，水分子扮演着至关重要的角色，有些甚至作为“结构水”稳定蛋白质的三级结构。本次实践要求您编写一个算法，通过分析一个简化的分子动力学模拟轨迹，来识别这些关键的水分子。您将学习如何根据水分子的位置稳定性（方差）、停留时间（占有率）和与蛋白质的距离，建立一套量化标准来解决这个在真实科研中极具价值的问题。",
            "id": "2422534",
            "problem": "您将处理一个蛋白质与水分子分子动力学 (MD) 模拟的简化抽象模型，该模型适用于分析那些可能通过稳定蛋白质三级结构而起到“结构性”作用的水分子。该系统代表一个单一蛋白质，其重原子位置固定，取自蛋白质数据库 (PDB) 结构；以及一组在短时 MD 轨迹中观察到的水分子的氧原子位置。蛋白质原子坐标和水分子位置的单位为埃 (Å)。您的任务是编写一个完整的程序，使用关于位置方差和邻近度的第一性原理定义，将水分子分类为结构性或非结构性。\n\n定义：\n- 设共有 $T$ 个帧，索引为 $t\\in\\{1,\\dots,T\\}$，以及 $N$ 个水分子，索引为 $i\\in\\{0,\\dots,N-1\\}$。蛋白质的重原子坐标为 $\\{\\mathbf{R}_j\\in\\mathbb{R}^3\\}_{j=1}^{M}$。\n- 对于水分子 $i$，令 $\\mathbf{r}_{i,t}\\in\\mathbb{R}^3$ 表示其在第 $t$ 帧的氧原子位置。如果水分子 $i$ 在第 $t$ 帧中不存在，则 $\\mathbf{r}_{i,t}$ 被视为缺失，并在对 $t$ 进行的任何平均或求和计算中被排除。在计算占有率时，缺失帧被计为未观察到，但仍计入占有率分数的分母 $T$ 中。\n- 对于每个水分子 $i$，定义其被观察到的帧集合为 $S_i=\\{t\\in\\{1,\\dots,T\\}:\\mathbf{r}_{i,t}\\text{ is observed}\\}$，并令 $n_i=|S_i|$。占有率分数为 $f_{\\mathrm{occ}}(i)=n_i/T$。\n- 在观察到的帧上的时间平均位置为 $\\boldsymbol{\\mu}_i=\\frac{1}{n_i}\\sum_{t\\in S_i}\\mathbf{r}_{i,t}$，位置方差为 $\\sigma_i^2=\\frac{1}{n_i}\\sum_{t\\in S_i}\\|\\mathbf{r}_{i,t}-\\boldsymbol{\\mu}_i\\|_2^2$。\n- 关于与蛋白质的邻近度，定义每帧的最小重原子距离为 $d_{i,t}=\\min_{1\\le j\\le M}\\|\\mathbf{r}_{i,t}-\\mathbf{R}_j\\|_2$。给定一个距离截断值 $d_{\\max}>0$，定义结合接触分数为 $f_{\\mathrm{bind}}(i)=\\frac{1}{n_i}\\sum_{t\\in S_i}\\mathbf{1}\\big[d_{i,t}\\le d_{\\max}\\big]$，其中 $\\mathbf{1}[\\cdot]$ 是指示函数，当条件为真时等于 $1$，否则等于 $0$。\n- 一个水分子 $i$ 被分类为结构性水，当且仅当以下所有条件同时成立：$f_{\\mathrm{occ}}(i)\\ge f_{\\min}$，$\\sigma_i^2\\le \\sigma^2_{\\max}$，以及 $f_{\\mathrm{bind}}(i)\\ge f_{\\mathrm{bind}}^{\\min}$。\n\n数据集（对所有测试用例固定）：\n- 帧数：$T=6$。\n- 蛋白质重原子数：$M=3$，坐标（单位 Å）：\n  - $\\mathbf{R}_1=\\left(0.0,0.0,0.0\\right)$，\n  - $\\mathbf{R}_2=\\left(3.0,0.0,0.0\\right)$，\n  - $\\mathbf{R}_3=\\left(0.0,3.0,0.0\\right)$。\n- 水分子数：$N=5$。对于每个水分子 $i\\in\\{0,1,2,3,4\\}$ 和帧 $t\\in\\{1,\\dots,6\\}$，其氧原子位置（单位 Å）如下。对于给定的水分子，未列出的帧应被视为该水分子的缺失观察值。\n  - 水分子 $i=0$（所有帧均被观察到）：平均位置靠近 $\\left(1.0,0.0,0.0\\right)$，有微小的对称偏差：\n    - $t=1$: $\\left(1.05,0.0,0.0\\right)$，\n    - $t=2$: $\\left(0.95,0.0,0.0\\right)$，\n    - $t=3$: $\\left(1.0,0.05,0.0\\right)$，\n    - $t=4$: $\\left(1.0,-0.05,0.0\\right)$，\n    - $t=5$: $\\left(1.0,0.0,0.05\\right)$，\n    - $t=6$: $\\left(1.0,0.0,-0.05\\right)$。\n  - 水分子 $i=1$（所有帧均被观察到）：可移动的溶剂，远离蛋白质：\n    - $t=1$: $\\left(5.0,5.0,5.0\\right)$，\n    - $t=2$: $\\left(6.0,5.0,5.0\\right)$，\n    - $t=3$: $\\left(5.0,6.0,5.0\\right)$，\n    - $t=4$: $\\left(7.0,5.0,5.0\\right)$，\n    - $t=5$: $\\left(5.0,7.0,6.0\\right)$，\n    - $t=6$: $\\left(4.0,4.0,4.0\\right)$。\n  - 水分子 $i=2$（间歇性；仅观察到前三帧，其余缺失）：\n    - $t=1$: $\\left(1.22,0.0,0.0\\right)$，\n    - $t=2$: $\\left(1.18,0.0,0.0\\right)$，\n    - $t=3$: $\\left(1.20,0.02,0.0\\right)$。\n  - 水分子 $i=3$（所有帧均被观察到）：平均位置靠近 $\\left(1.0,1.8,0.0\\right)$，沿各轴有大小为 $0.1$ Å 的对称偏差：\n    - $t=1$: $\\left(1.1,1.8,0.0\\right)$，\n    - $t=2$: $\\left(0.9,1.8,0.0\\right)$，\n    - $t=3$: $\\left(1.0,1.9,0.0\\right)$，\n    - $t=4$: $\\left(1.0,1.7,0.0\\right)$，\n    - $t=5$: $\\left(1.0,1.8,0.1\\right)$，\n    - $t=6$: $\\left(1.0,1.8,-0.1\\right)$。\n  - 水分子 $i=4$（所有帧均被观察到）：远离蛋白质，方差较低：\n    - $t=1$: $\\left(10.02,10.0,10.0\\right)$，\n    - $t=2$: $\\left(9.98,10.0,10.0\\right)$，\n    - $t=3$: $\\left(10.0,10.02,10.0\\right)$，\n    - $t=4$: $\\left(10.0,9.98,10.0\\right)$，\n    - $t=5$: $\\left(10.0,10.0,10.02\\right)$，\n    - $t=6$: $\\left(10.0,10.0,9.98\\right)$。\n\n参数集测试套件：\n- 案例 A（基线阈值）：\n  - 方差阈值：$\\sigma^2_{\\max}=0.005$ $\\left(\\text{\\AA}^2\\right)$,\n  - 最小占有率分数：$f_{\\min}=0.8$,\n  - 邻近距离截断值：$d_{\\max}=3.5$ $\\left(\\text{\\AA}\\right)$,\n  - 最小结合接触分数：$f_{\\mathrm{bind}}^{\\min}=0.8$。\n- 案例 B（方差边界包含）：\n  - $\\sigma^2_{\\max}=0.01$ $\\left(\\text{\\AA}^2\\right)$,\n  - $f_{\\min}=0.8$,\n  - $d_{\\max}=3.5$ $\\left(\\text{\\AA}\\right)$,\n  - $f_{\\mathrm{bind}}^{\\min}=0.8$。\n- 案例 C（占有率边界包含）：\n  - $\\sigma^2_{\\max}=0.005$ $\\left(\\text{\\AA}^2\\right)$,\n  - $f_{\\min}=0.5$,\n  - $d_{\\max}=3.5$ $\\left(\\text{\\AA}\\right)$,\n  - $f_{\\mathrm{bind}}^{\\min}=0.8$。\n- 案例 D（严格邻近度，可能为空集）：\n  - $\\sigma^2_{\\max}=1.0$ $\\left(\\text{\\AA}^2\\right)$,\n  - $f_{\\min}=0.8$,\n  - $d_{\\max}=1.0$ $\\left(\\text{\\AA}\\right)$,\n  - $f_{\\mathrm{bind}}^{\\min}=0.5$。\n\n计算要求：\n- 精确实现上述定义，使用欧几里得范数计算距离，并在计算均值、方差和邻近度分数时忽略缺失帧（但在计算占有率分数时将它们计为未观察到）。\n- 阈值处的等式必须是包含性的：对 $f_{\\mathrm{occ}}$ 和 $f_{\\mathrm{bind}}$ 使用 $\\ge$，对 $\\sigma^2$ 使用 $\\le$。\n- 对于四个参数案例中的每一个，输出被分类为结构性水的水分子索引列表，按升序排序。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含四个案例的结果，格式为一个由方括号括起的逗号分隔列表，其中每个案例的结果本身就是一个水分子索引列表。例如，输出可能看起来像 $\\left[\\left[0\\right],\\left[0,3\\right],\\left[0,2\\right],\\left[\\right]\\right]$（这只是格式示例，不一定是正确答案）。不应打印任何额外文本。",
            "solution": "所提出的问题是结构生物信息学中一个明确定义的计算任务。它要求基于从简化的分子动力学轨迹中得出的三个量化指标——占有率、位置方差和与蛋白质的邻近度——将水分子分类为“结构性”水。所有数据、定义和阈值都已明确提供。该问题具有科学依据、逻辑一致且计算上是可行的。因此，通过直接应用给定的公式可以得出一个严谨的解。\n\n方法如下。对于 $N=5$ 个水分子中的每一个，我们首先根据其在 $T=6$ 个轨迹帧中的观察位置计算其内在属性。这些属性是占有率分数 $f_{\\mathrm{occ}}(i)$、时间平均位置 $\\boldsymbol{\\mu}_i$ 和位置方差 $\\sigma_i^2$。随后，对于测试用例中指定的不同邻近度截断值 $d_{\\max}$，我们计算相应的结合接触分数 $f_{\\mathrm{bind}}(i)$。计算出这些量后，我们接着根据每个测试用例的标准评估每个水分子，以确定其分类。\n\n蛋白质由 $M=3$ 个重原子表示，其坐标为：\n- $\\mathbf{R}_1 = \\left(0.0, 0.0, 0.0\\right)$\n- $\\mathbf{R}_2 = \\left(3.0, 0.0, 0.0\\right)$\n- $\\mathbf{R}_3 = \\left(0.0, 3.0, 0.0\\right)$\n\n让我们系统地计算每个水分子 $i \\in \\{0, 1, 2, 3, 4\\}$ 所需的统计数据。\n\n**水分子 $i=0$**\n- 观察到的帧：$S_0=\\{1,2,3,4,5,6\\}$，因此 $n_0 = 6$。\n- 占有率：$f_{\\mathrm{occ}}(0) = n_0/T = 6/6 = 1.0$。\n- 平均位置 $\\boldsymbol{\\mu}_0$：提供的坐标围绕 $\\left(1.0, 0.0, 0.0\\right)$ 对称。平均值为 $\\boldsymbol{\\mu}_0 = \\frac{1}{6}\\sum_{t=1}^6 \\mathbf{r}_{0,t} = \\left(1.0, 0.0, 0.0\\right)$ Å。\n- 位置方差 $\\sigma_0^2$：偏差向量的形式为 $(\\pm 0.05, 0, 0)$、$(0, \\pm 0.05, 0)$ 和 $(0, 0, \\pm 0.05)$。每个向量的欧几里得范数平方为 $0.05^2 = 0.0025$ Å$^2$。\n$$ \\sigma_0^2 = \\frac{1}{n_0}\\sum_{t\\in S_0}\\|\\mathbf{r}_{0,t}-\\boldsymbol{\\mu}_0\\|_2^2 = \\frac{1}{6}\\left(6 \\times 0.0025\\right) = 0.0025 \\text{ Å}^2 $$\n- 邻近度：该水分子位于 $\\mathbf{R}_1$ 附近。所有每帧距离 $d_{0,t}$ 约等于 $1.0$ Å。具体来说，距离为 $1.05, 0.95, \\sqrt{1.0025}, \\sqrt{1.0025}, \\sqrt{1.0025}, \\sqrt{1.0025}$。\n    - 当 $d_{\\max}=3.5$ Å 时，所有六个帧都满足 $d_{0,t} \\le 3.5$。因此，$f_{\\mathrm{bind}}(0) = 6/6 = 1.0$。\n    - 当 $d_{\\max}=1.0$ Å 时，只有 $t=2$ 时的帧的距离 $d_{0,2}=0.95 \\le 1.0$。因此，$f_{\\mathrm{bind}}(0) = 1/6 \\approx 0.167$。\n\n**水分子 $i=1$**\n- 观察到的帧：$S_1=\\{1,2,3,4,5,6\\}$，因此 $n_1 = 6$。\n- 占有率：$f_{\\mathrm{occ}}(1) = 6/6 = 1.0$。\n- 平均位置 $\\boldsymbol{\\mu}_1$：$\\boldsymbol{\\mu}_1 = \\frac{1}{6}\\sum_{t=1}^6 \\mathbf{r}_{1,t} = \\left(\\frac{32}{6}, \\frac{32}{6}, \\frac{30}{6}\\right) = \\left(\\frac{16}{3}, \\frac{16}{3}, 5.0\\right)$ Å。\n- 位置方差 $\\sigma_1^2$：\n$$ \\sigma_1^2 = \\frac{1}{6}\\sum_{t=1}^6 \\|\\mathbf{r}_{1,t}-\\boldsymbol{\\mu}_1\\|_2^2 = \\frac{1}{6}\\left(\\frac{2}{9} + \\frac{5}{9} + \\frac{5}{9} + \\frac{26}{9} + \\frac{35}{9} + \\frac{41}{9}\\right) = \\frac{1}{6} \\frac{114}{9} = \\frac{19}{9} \\approx 2.111 \\text{ Å}^2 $$\n- 邻近度：所有坐标都远离蛋白质原子。任何帧的最小距离是 $\\|\\left(4.0, 4.0, 4.0\\right) - \\left(3.0, 3.0, 0.0\\right)\\| = \\sqrt{1^2+1^2+4^2} = \\sqrt{18} \\approx 4.24$ Å，但这甚至不是到蛋白质集合中原子的距离。到实际蛋白质原子的最小距离是 $\\|\\left(4,4,4\\right)-\\left(3,0,0\\right)\\| = \\sqrt{1^2+4^2+4^2}=\\sqrt{33} \\approx 5.74$ Å。对于 $d_{\\max}=3.5$ Å 和 $d_{\\max}=1.0$ Å，没有帧处于接触状态。因此，$f_{\\mathrm{bind}}(1) = 0.0$。\n\n**水分子 $i=2$**\n- 观察到的帧：$S_2=\\{1,2,3\\}$，因此 $n_2 = 3$。\n- 占有率：$f_{\\mathrm{occ}}(2) = n_2/T = 3/6 = 0.5$。\n- 平均位置 $\\boldsymbol{\\mu}_2$：$\\boldsymbol{\\mu}_2 = \\frac{1}{3}\\left((1.22,0,0) + (1.18,0,0) + (1.20,0.02,0)\\right) = \\left(1.2, \\frac{0.02}{3}, 0\\right)$ Å。\n- 位置方差 $\\sigma_2^2$：\n$$ \\sigma_2^2 = \\frac{1}{3}\\left( \\|(0.02, -\\frac{0.02}{3}, 0)\\|^2 + \\|(-0.02, -\\frac{0.02}{3}, 0)\\|^2 + \\|(0, \\frac{0.04}{3}, 0)\\|^2 \\right) \\approx 0.000356 \\text{ Å}^2 $$\n- 邻近度：该水分子靠近 $\\mathbf{R}_1$。距离 $d_{2,t}$ 分别为 $1.22, 1.18, 1.20017$。\n    - 当 $d_{\\max}=3.5$ Å 时，所有三个帧都满足 $d_{2,t} \\le 3.5$。因此，$f_{\\mathrm{bind}}(2) = 3/3 = 1.0$。\n    - 当 $d_{\\max}=1.0$ Å 时，没有帧满足条件。因此，$f_{\\mathrm{bind}}(2) = 0.0$。\n\n**水分子 $i=3$**\n- 观察到的帧：$S_3=\\{1,2,3,4,5,6\\}$，因此 $n_3 = 6$。\n- 占有率：$f_{\\mathrm{occ}}(3) = 6/6 = 1.0$。\n- 平均位置 $\\boldsymbol{\\mu}_3$：坐标围绕 $(1.0, 1.8, 0.0)$ 对称。因此，$\\boldsymbol{\\mu}_3 = \\left(1.0, 1.8, 0.0\\right)$ Å。\n- 位置方差 $\\sigma_3^2$：偏差沿各轴的大小为 $0.1$。\n$$ \\sigma_3^2 = \\frac{1}{6}\\left(6 \\times 0.1^2\\right) = 0.01 \\text{ Å}^2 $$\n- 邻近度：该水分子位于三个蛋白质原子之间，最接近 $\\mathbf{R}_3=(0,3,0)$。距离 $d_{3,t}$ 约在 $1.5-1.6$ Å 之间。\n    - 当 $d_{\\max}=3.5$ Å 时，所有六个帧都满足 $d_{3,t} \\le 3.5$。因此，$f_{\\mathrm{bind}}(3) = 6/6 = 1.0$。\n    - 当 $d_{\\max}=1.0$ Å 时，没有帧满足条件。因此，$f_{\\mathrm{bind}}(3) = 0.0$。\n\n**水分子 $i=4$**\n- 观察到的帧：$S_4=\\{1,2,3,4,5,6\\}$，因此 $n_4 = 6$。\n- 占有率：$f_{\\mathrm{occ}}(4) = 6/6 = 1.0$。\n- 平均位置 $\\boldsymbol{\\mu}_4$：坐标围绕 $(10,10,10)$ 对称。因此，$\\boldsymbol{\\mu}_4 = \\left(10.0, 10.0, 10.0\\right)$ Å。\n- 位置方差 $\\sigma_4^2$：偏差沿各轴的大小为 $0.02$。\n$$ \\sigma_4^2 = \\frac{1}{6}\\left(6 \\times 0.02^2\\right) = 0.0004 \\text{ Å}^2 $$\n- 邻近度：所有坐标都远离蛋白质。到蛋白质原子的最小距离约为 $15.78$ Å。对于 $d_{\\max}=3.5$ Å 和 $d_{\\max}=1.0$ Å，没有帧处于接触状态。因此，$f_{\\mathrm{bind}}(4) = 0.0$。\n\n计算出的属性总结在下表中。\n\n| 水分子 $i$ | $f_{\\mathrm{occ}}(i)$ | $\\sigma_i^2$ (Å$^2$) | 当 $d_{\\max}=3.5$ 时的 $f_{\\mathrm{bind}}(i)$ | 当 $d_{\\max}=1.0$ 时的 $f_{\\mathrm{bind}}(i)$ |\n|:---:|:---:|:---:|:---:|:---:|\n| $0$ | $1.0$ | $0.0025$ | $1.0$ | $\\approx 0.167$ |\n| $1$ | $1.0$ | $\\approx 2.111$ | $0.0$ | $0.0$ |\n| $2$ | $0.5$ | $\\approx 0.000356$ | $1.0$ | $0.0$ |\n| $3$ | $1.0$ | $0.01$ | $1.0$ | $0.0$ |\n| $4$ | $1.0$ | $0.0004$ | $0.0$ | $0.0$ |\n\n现在，我们对每个测试用例应用分类标准。\n\n**案例 A：** $\\sigma^2_{\\max}=0.005$，$f_{\\min}=0.8$，$d_{\\max}=3.5$，$f_{\\mathrm{bind}}^{\\min}=0.8$。\n- 水分子 0：$1.0\\ge0.8$ (真)，$0.0025\\le0.005$ (真)，$1.0\\ge0.8$ (真) $\\implies$ 结构性。\n- 水分子 1：$1.0\\ge0.8$ (真)，$2.111\\le0.005$ (假) $\\implies$ 非结构性。\n- 水分子 2：$0.5\\ge0.8$ (假) $\\implies$ 非结构性。\n- 水分子 3：$1.0\\ge0.8$ (真)，$0.01\\le0.005$ (假) $\\implies$ 非结构性。\n- 水分子 4：$1.0\\ge0.8$ (真)，$0.0004\\le0.005$ (真)，$0.0\\ge0.8$ (假) $\\implies$ 非结构性。\n案例 A 的结果：$[0]$。\n\n**案例 B：** $\\sigma^2_{\\max}=0.01$，$f_{\\min}=0.8$，$d_{\\max}=3.5$，$f_{\\mathrm{bind}}^{\\min}=0.8$。\n- 水分子 0：$1.0\\ge0.8$ (真)，$0.0025\\le0.01$ (真)，$1.0\\ge0.8$ (真) $\\implies$ 结构性。\n- 水分子 1：$1.0\\ge0.8$ (真)，$2.111\\le0.01$ (假) $\\implies$ 非结构性。\n- 水分子 2：$0.5\\ge0.8$ (假) $\\implies$ 非结构性。\n- 水分子 3：$1.0\\ge0.8$ (真)，$0.01\\le0.01$ (真)，$1.0\\ge0.8$ (真) $\\implies$ 结构性。\n- 水分子 4：$1.0\\ge0.8$ (真)，$0.0004\\le0.01$ (真)，$0.0\\ge0.8$ (假) $\\implies$ 非结构性。\n案例 B 的结果：$[0, 3]$。\n\n**案例 C：** $\\sigma^2_{\\max}=0.005$，$f_{\\min}=0.5$，$d_{\\max}=3.5$，$f_{\\mathrm{bind}}^{\\min}=0.8$。\n- 水分子 0：$1.0\\ge0.5$ (真)，$0.0025\\le0.005$ (真)，$1.0\\ge0.8$ (真) $\\implies$ 结构性。\n- 水分子 1：$1.0\\ge0.5$ (真)，$2.111\\le0.005$ (假) $\\implies$ 非结构性。\n- 水分子 2：$0.5\\ge0.5$ (真)，$0.000356\\le0.005$ (真)，$1.0\\ge0.8$ (真) $\\implies$ 结构性。\n- 水分子 3：$1.0\\ge0.5$ (真)，$0.01\\le0.005$ (假) $\\implies$ 非结构性。\n- 水分子 4：$1.0\\ge0.5$ (真)，$0.0004\\le0.005$ (真)，$0.0\\ge0.8$ (假) $\\implies$ 非结构性。\n案例 C 的结果：$[0, 2]$。\n\n**案例 D：** $\\sigma^2_{\\max}=1.0$，$f_{\\min}=0.8$，$d_{\\max}=1.0$，$f_{\\mathrm{bind}}^{\\min}=0.5$。\n- 水分子 0：$1.0\\ge0.8$ (真)，$0.0025\\le1.0$ (真)，$0.167\\ge0.5$ (假) $\\implies$ 非结构性。\n- 水分子 1：$1.0\\ge0.8$ (真)，$2.111\\le1.0$ (假) $\\implies$ 非结构性。\n- 水分子 2：$0.5\\ge0.8$ (假) $\\implies$ 非结构性。\n- 水分子 3：$1.0\\ge0.8$ (真)，$0.01\\le1.0$ (真)，$0.0\\ge0.5$ (假) $\\implies$ 非结构性。\n- 水分子 4：$1.0\\ge0.8$ (真)，$0.0004\\le1.0$ (真)，$0.0\\ge0.5$ (假) $\\implies$ 非结构性。\n案例 D 的结果：[]。\n\n计算已完成，所有四个测试用例的结果已经确定。实现将遵循此确切逻辑。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the structural water classification problem based on the provided dataset and definitions.\n    \"\"\"\n    # ====== DATA SETUP ======\n    \n    # Total number of frames in the trajectory.\n    T = 6\n\n    # Protein heavy atom coordinates.\n    protein_atoms = np.array([\n        [0.0, 0.0, 0.0],\n        [3.0, 0.0, 0.0],\n        [0.0, 3.0, 0.0]\n    ])\n\n    # Water oxygen coordinates. A dictionary is used to handle missing frames naturally.\n    # Key: water index, Value: dictionary of {frame_index: coordinates}. Frame indices are 1-based.\n    all_water_coords = {\n        0: {\n            1: [1.05, 0.0, 0.0], 2: [0.95, 0.0, 0.0], 3: [1.0, 0.05, 0.0],\n            4: [1.0, -0.05, 0.0], 5: [1.0, 0.0, 0.05], 6: [1.0, 0.0, -0.05]\n        },\n        1: {\n            1: [5.0, 5.0, 5.0], 2: [6.0, 5.0, 5.0], 3: [5.0, 6.0, 5.0],\n            4: [7.0, 5.0, 5.0], 5: [5.0, 7.0, 6.0], 6: [4.0, 4.0, 4.0]\n        },\n        2: {\n            1: [1.22, 0.0, 0.0], 2: [1.18, 0.0, 0.0], 3: [1.20, 0.02, 0.0]\n        },\n        3: {\n            1: [1.1, 1.8, 0.0], 2: [0.9, 1.8, 0.0], 3: [1.0, 1.9, 0.0],\n            4: [1.0, 1.7, 0.0], 5: [1.0, 1.8, 0.1], 6: [1.0, 1.8, -0.1]\n        },\n        4: {\n            1: [10.02, 10.0, 10.0], 2: [9.98, 10.0, 10.0], 3: [10.0, 10.02, 10.0],\n            4: [10.0, 9.98, 10.0], 5: [10.0, 10.0, 10.02], 6: [10.0, 10.0, 9.98]\n        }\n    }\n    \n    # Test suite of parameter sets.\n    # format: (sigma_sq_max, f_min, d_max, f_bind_min)\n    test_cases = [\n        (0.005, 0.8, 3.5, 0.8),  # Case A\n        (0.01, 0.8, 3.5, 0.8),   # Case B\n        (0.005, 0.5, 3.5, 0.8),   # Case C\n        (1.0, 0.8, 1.0, 0.5),     # Case D\n    ]\n    \n    # ====== CALCULATION ======\n    \n    num_waters = 5\n    water_properties = []\n\n    for i in range(num_waters):\n        water_frames = all_water_coords.get(i, {})\n        if not water_frames:\n            # Handle case of a water with no observations.\n            water_properties.append({\n                'f_occ': 0.0, 'sigma_sq': float('inf'), 'frames': []\n            })\n            continue\n\n        observed_coords = np.array(list(water_frames.values()))\n        n_i = len(observed_coords)\n        \n        # Calculate occupancy fraction\n        f_occ = n_i / T\n        \n        # Calculate mean position and positional variance\n        mu_i = np.mean(observed_coords, axis=0)\n        # Variance is the mean of the squared Euclidean distances from the mean\n        sigma_sq = np.mean(np.sum((observed_coords - mu_i)**2, axis=1))\n\n        water_properties.append({\n            'f_occ': f_occ, 'sigma_sq': sigma_sq, 'frames': observed_coords, 'n_i': n_i\n        })\n        \n    final_results = []\n    \n    for case_params in test_cases:\n        sigma_sq_max, f_min, d_max, f_bind_min = case_params\n        structural_waters = []\n        \n        for i in range(num_waters):\n            props = water_properties[i]\n            \n            # Condition 1: Occupancy\n            if not (props['f_occ'] >= f_min):\n                continue\n            \n            # Condition 2: Positional variance\n            if not (props['sigma_sq'] = sigma_sq_max):\n                continue\n                \n            # Condition 3: Binding-contact fraction\n            observed_coords = props['frames']\n            n_i = props['n_i']\n            \n            if n_i == 0:\n                # If there are no frames, binding fraction is undefined or 0. Fails condition.\n                continue\n\n            contact_frames = 0\n            for r_it in observed_coords:\n                # Calculate distances from this water position to all protein atoms\n                distances = np.linalg.norm(r_it - protein_atoms, axis=1)\n                min_dist = np.min(distances)\n                if min_dist = d_max:\n                    contact_frames += 1\n            \n            f_bind = contact_frames / n_i\n            \n            if f_bind >= f_bind_min:\n                structural_waters.append(i)\n                \n        final_results.append(structural_waters)\n\n    # ====== FORMAT OUTPUT ======\n    \n    # Generate the output string in the exact format \"[[i,...],[j,...],...]\"\n    output_str_parts = []\n    for res in final_results:\n        # str(list) produces spaces, which must be removed.\n        output_str_parts.append(str(res).replace(\" \", \"\"))\n        \n    print(f\"[{','.join(output_str_parts)}]\")\n\n\nsolve()\n```"
        },
        {
            "introduction": "蛋白质折叠是一个极其复杂的过程，但其核心驱动力可以通过简化的物理模型来捕捉。本项编程挑战将带您从零开始实现经典的疏水-极性（HP）二维格点模型，这是理解蛋白质折叠原理的基石。您将亲手设计一个“折叠游戏”，通过定义构象、能量函数和构象变化的规则（转角移动），并使用蒙特卡洛算法来探索蛋白质如何从伸展的肽链自发折叠成能量最低的紧凑结构。",
            "id": "2422555",
            "problem": "您需要实现一个完整的、可运行的程序，该程序在疏水-极性（HP）模型下模拟二维方格上的蛋白质折叠，并对给定氨基酸序列的相同初始构象评估两种折叠策略：一种是确定性的手动枢轴移动序列，另一种是定义为离散时间马尔可夫链的随机动力学。\n\n一个长度为 $N$、残基索引为 $0,1,\\dots,N-1$ 的蛋白质由字母表 $\\{\\mathrm{H},\\mathrm{P}\\}$ 上的序列 $S$ 表示，其中 $\\mathrm{H}$ 代表疏水性，$\\mathrm{P}$ 代表极性。$S$ 的一个构象是将索引映射到坐标 $\\mathbf{r}_i \\in \\mathbb{Z}^2$ 的过程，使得对于所有 $i \\in \\{0,\\dots,N-2\\}$，连续残基之间的曼哈顿距离为1，即 $\\|\\mathbf{r}_{i+1}-\\mathbf{r}_i\\|_1=1$，并且对于所有 $i \\neq j$，$\\mathbf{r}_i \\neq \\mathbf{r}_j$（自回避行走）。对于所有测试用例，初始构象是沿 $x$ 轴的直线：\n$$\n\\mathbf{r}_i^{(0)} = (i,0) \\quad \\text{for } i \\in \\{0,1,\\dots,N-1\\}.\n$$\n\n序列 $S$ 的一个构象 $\\{\\mathbf{r}_i\\}_{i=0}^{N-1}$ 的HP能量 $E$ 定义为\n$$\nE = -\\sum_{\\substack{0 \\le i  j \\le N-1 \\\\ |i-j| > 1}} \\left[ S_i=\\mathrm{H} \\wedge S_j=\\mathrm{H} \\wedge \\|\\mathbf{r}_i - \\mathbf{r}_j\\|_1 = 1 \\right],\n$$\n其中 $[\\cdot]$ 表示指示函数，如果条件为真则值为 $1$，否则为 $0$。每个非连续的疏水-疏水接触对 $E$ 的贡献为 $-1$。能量是无量纲的。\n\n一个基本的枢轴移动由一个索引 $k \\in \\{1,2,\\dots,N-2\\}$ 和一个旋转角 $a \\in \\{+90,-90,180\\}$（角度单位为度）参数化。该移动通过围绕固定的枢轴位置 $\\mathbf{r}_k$，将后缀坐标 $\\{\\mathbf{r}_{k+1},\\dots,\\mathbf{r}_{N-1}\\}$ 在平面内旋转指定的角度来作用。如果最终的构型违反了自回避性，则该移动无效且不起作用（构象保持不变）。否则，该移动有效并更新构象。所有旋转必须是精确的晶格旋转：\n- 对于 $a=+90$，应用逆时针旋转矩阵 $\\begin{pmatrix}0  -1 \\\\ 1  0\\end{pmatrix}$。\n- 对于 $a=-90$，应用顺时针旋转矩阵 $\\begin{pmatrix}0  1 \\\\ -1  0\\end{pmatrix}$。\n- 对于 $a=180$，应用旋转矩阵 $\\begin{pmatrix}-1  0 \\\\ 0  -1\\end{pmatrix}$。\n\n每个测试用例必须评估两种折叠策略：\n\n1. 手动引导：给定一个有序的枢轴移动列表 $\\{(k_m,a_m)\\}_{m=1}^M$，其中每个 $k_m \\in \\{1,\\dots,N-2\\}$ 且 $a_m \\in \\{+90,-90,180\\}$（角度单位为度），将它们顺序地应用于初始构象。任何无效的移动都会使该步骤的构象保持不变。在尝试所有移动后，计算最终构象的能量 $E_{\\mathrm{manual}}$。\n\n2. 自动随机动力学：从初始构象开始，考虑一个离散时间马尔可夫链，在每一步 $t=1,2,\\dots,T_{\\max}$ 进行如下转换：\n   - 从 $\\{1,2,\\dots,N-2\\}$ 中均匀抽取 $k$，并从 $\\{+90,-90,180\\}$（角度单位为度）中均匀抽取 $a$。提出相应的枢轴移动。\n   - 如果提议的移动无效，则在步骤 $t$ 构象保持不变。\n   - 如果移动有效，计算 $\\Delta E = E_{\\text{proposed}} - E_{\\text{current}}$ 并以概率 $p_{\\text{acc}} = \\min\\{1, \\exp(-\\Delta E / T)\\}$ 接受该移动，其中 $T$ 是温度，玻尔兹曼常数设为1，因此 $T$ 是无量纲的。如果接受，则将构象更新为提议的构象；否则，保留当前构象。\n   - 令 $E_{\\mathrm{best}}$ 表示截至并包括步骤 $t$（包括步骤 $0$ 的初始构象）所观察到的最低能量。\n为了可复现性，该随机过程必须使用指定的整数伪随机种子进行初始化。此策略的输出是 $T_{\\max}$ 步后的 $E_{\\mathrm{auto}} = E_{\\mathrm{best}}$。\n\n您的程序必须精确实现上述定义，并为以下测试套件生成结果。在所有情况下，角度单位为度，能量为无量纲整数，索引是零基的，枢轴索引限制在 $k \\in \\{1,2,\\dots,N-2\\}$。\n\n测试套件：\n- 案例 A：\n  - 序列 $S = \\text{\"HHHH\"}$，长度 $N=4$。\n  - 手动移动：$\\big[(1,+90),(2,+90)\\big]$。\n  - 温度 $T = 1$。\n  - 随机步数 $T_{\\max} = 0$。\n  - 种子 $= 1$。\n- 案例 B：\n  - 序列 $S = \\text{\"HPHPHPHP\"}$，长度 $N=8$。\n  - 手动移动：空列表 $\\big[\\ \\big]$。\n  - 温度 $T = 1$。\n  - 随机步数 $T_{\\max} = 0$。\n  - 种子 $= 2$。\n- 案例 C：\n  - 序列 $S = \\text{\"HHHHHH\"}$，长度 $N=6$。\n  - 手动移动：$\\big[(1,+90),(2,+90),(4,-90)\\big]$。\n  - 温度 $T = 1$。\n  - 随机步数 $T_{\\max} = 0$。\n  - 种子 $= 3$。\n\n必需的最终输出格式：您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素对应一个测试用例，并且本身是一个双元素列表 $[E_{\\mathrm{manual}}, E_{\\mathrm{auto}}]$。例如，一个包含三个测试用例的输出应如下所示\n$$\n\\big[ [e_1^{\\mathrm{man}}, e_1^{\\mathrm{auto}}], [e_2^{\\mathrm{man}}, e_2^{\\mathrm{auto}}], [e_3^{\\mathrm{man}}, e_3^{\\mathrm{auto}}] \\big].\n$$",
            "solution": "问题陈述是有效的。它科学地基于公认的疏水-极性（HP）晶格模型，这是简化蛋白质折叠研究的基石。该问题定义良好，提供了推导唯一解所需的所有定义、初始条件和参数。语言客观且数学上精确。我现在将着手提供一个完整的解决方案。\n\n解决方案要求实现一个在二维方格上模拟蛋白质折叠的程序，该过程由HP模型控制。蛋白质被抽象为一个长度为 $N$ 的序列 $S$，其字母表为 $\\{\\mathrm{H}, \\mathrm{P}\\}$，分别代表疏水和极性残基。该链的构象是在整数网格 $\\mathbb{Z}^2$ 上的自回避行走，由一系列坐标 $\\{\\mathbf{r}_i\\}_{i=0}^{N-1}$ 表示，其中 $\\mathbf{r}_i = (x_i, y_i)$。对于所有测试用例，链从沿x轴完全伸展的线性构象开始，即 $\\mathbf{r}_i^{(0)} = (i,0)$。\n\nHP模型的核心是其能量函数，该函数假定疏水效应是蛋白质折叠中的主导力量。给定构象的能量 $E$ 是通过计算非相邻疏水残基之间的拓扑接触数来计算的。如果两个这样的残基占据相邻的晶格位点，就形成一个接触。能量由下式给出：\n$$\nE = -\\sum_{\\substack{0 \\le i  j \\le N-1 \\\\ |i-j|  1}} \\left[ S_i=\\mathrm{H} \\wedge S_j=\\mathrm{H} \\wedge \\|\\mathbf{r}_i - \\mathbf{r}_j\\|_1 = 1 \\right]\n$$\n其中 $[\\cdot]$ 是艾佛森括号。每个这样的H-H接触对总能量的贡献为 $-1$，因此能量更低（更负）的构象更稳定。为实现这一点，我们首先识别所有对应于 $\\mathrm{H}$ 残基的索引。然后，我们遍历所有这些索引对 $(i, j)$（使得 $j  i+1$），并计算曼哈顿距离 $\\|\\mathbf{r}_i - \\mathbf{r}_j\\|_1 = |x_i - x_j| + |y_i - y_j|$。如果距离为 $1$，我们就将能量计数器减一。初始线性构象的能量为 $E=0$，因为没有非相邻残基接触。\n\n构象变化通过枢轴移动来建模。枢轴移动由一个索引 $k \\in \\{1, 2, \\dots, N-2\\}$ 和一个旋转角 $a \\in \\{+90, -90, 180\\}$ 度定义。位于 $\\mathbf{r}_k$ 的残基作为枢轴，从残基 $k+1$ 到 $N-1$ 的子链围绕它进行刚性旋转。前缀的坐标 $\\{\\mathbf{r}_0, \\dots, \\mathbf{r}_k\\}$ 保持不变。对于后缀中的每个点 $\\mathbf{r}_i$ ($i  k$)，其新位置 $\\mathbf{r}'_i$ 是通过将向量 $\\mathbf{v}_i = \\mathbf{r}_i - \\mathbf{r}_k$ 围绕原点旋转，然后加回到枢轴坐标上来找到的：$\\mathbf{r}'_i = \\mathbf{r}_k + R_a \\mathbf{v}_i$。平面上的旋转矩阵 $R_a$ 是：\n$$\nR_{+90} = \\begin{pmatrix}0  -1 \\\\ 1  0\\end{pmatrix}, \\quad R_{-90} = \\begin{pmatrix}0  1 \\\\ -1  0\\end{pmatrix}, \\quad R_{180} = \\begin{pmatrix}-1  0 \\\\ 0  -1\\end{pmatrix}\n$$\n只有当最终的构象是自回避的，即所有坐标 $\\mathbf{r}'_i$ 都是唯一的时，移动才有效。这通过检查坐标元组集合的大小是否为 $N$ 来验证。如果移动无效，构象不发生改变。\n\n评估两种折叠策略：\n\n1.  **手动引导：** 串行应用预定的一系列枢轴移动。从初始线性构象开始，尝试每个移动 $(k_m, a_m)$。如果有效，则更新构象。如果无效，则丢弃该移动，并在未改变的构象上尝试下一个移动。处理完所有移动后，计算最终能量 $E_{\\mathrm{manual}}$。\n\n2.  **自动随机动力学：** 此策略采用Metropolis-Hastings蒙特卡洛模拟（一种离散时间马尔可夫链过程）来探索构象空间。从初始构象开始，模拟进行 $T_{\\max}$ 步。在每一步 $t$：\n    - 通过从 $\\{1, \\dots, N-2\\}$ 中均匀选择 $k$ 和从 $\\{+90, -90, 180\\}$ 中均匀选择 $a$ 来提出一个随机枢轴移动。\n    - 检查移动的有效性。如果无效，则此步构象保持不变。\n    - 如果移动有效，则提出一个新的构象。计算能量变化 $\\Delta E = E_{\\text{proposed}} - E_{\\text{current}}$。\n    - 提议的移动以概率 $p_{\\text{acc}} = \\min\\{1, \\exp(-\\Delta E / T)\\}$ 被接受，其中 $T$ 是一个无量纲的温度参数。降低能量的移动（$\\Delta E  0$）总是被接受。增加能量的移动被接受的概率随能量增加呈指数下降，这使得系统能够逃离局部最小值。如果一个移动被拒绝，构象保持不变。\n    - 在整个模拟过程中，跟踪遇到的最低能量 $E_{\\mathrm{best}}$。该过程以起始构象的能量进行初始化。此策略的最终输出是在 $T_{\\max}$ 步后的 $E_{\\mathrm{auto}} = E_{\\mathrm{best}}$。对于给定的测试用例，$T_{\\max}=0$，意味着不执行任何随机步骤。因此，$E_{\\mathrm{auto}}$ 将仅仅是初始线性构象的能量。\n\n该实现将利用 `numpy` 数组来高效处理坐标向量和矩阵运算。整体逻辑被封装在一个主函数中，该函数处理每个测试用例，为手动和自动策略调用适当的函数，并按规定格式化输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_energy(coords, sequence):\n    \"\"\"\n    Calculates the HP energy of a given conformation.\n    Energy E = -1 for each non-adjacent H-H contact.\n    \"\"\"\n    n = len(sequence)\n    energy = 0\n    h_indices = [i for i, res in enumerate(sequence) if res == 'H']\n\n    if len(h_indices)  2:\n        return 0\n\n    for i_idx in range(len(h_indices)):\n        for j_idx in range(i_idx + 1, len(h_indices)):\n            i = h_indices[i_idx]\n            j = h_indices[j_idx]\n\n            # Condition for non-adjacent residues\n            if abs(i - j) > 1:\n                # Manhattan distance\n                dist = np.sum(np.abs(coords[i] - coords[j]))\n                if dist == 1:\n                    energy -= 1\n    return energy\n\n\ndef get_proposed_coords(coords, n, k, angle):\n    \"\"\"\n    Generates a new conformation by applying a pivot move.\n    Returns the new coordinate array if the move is valid (self-avoiding),\n    otherwise returns None.\n    \"\"\"\n    # Pivot index k must be in {1, ..., N-2}\n    if not (1 = k  n - 1):\n        return None\n\n    if angle == 90:\n        rot_matrix = np.array([[0, -1], [1, 0]], dtype=int)\n    elif angle == -90:\n        rot_matrix = np.array([[0, 1], [-1, 0]], dtype=int)\n    elif angle == 180:\n        rot_matrix = np.array([[-1, 0], [0, -1]], dtype=int)\n    else:\n        # Invalid angle\n        return None\n\n    new_coords = coords.copy()\n    pivot_coord = coords[k]\n    \n    # Suffix coordinates relative to the pivot\n    suffix_relative = coords[k+1:] - pivot_coord\n    \n    # Rotate the suffix vectors\n    rotated_suffix_relative = (rot_matrix @ suffix_relative.T).T\n    \n    # New absolute coordinates for the suffix\n    new_suffix_absolute = rotated_suffix_relative + pivot_coord\n    \n    new_coords[k+1:] = new_suffix_absolute\n    \n    # Check for self-avoidance. Using a set is efficient.\n    # The number of unique coordinates must be equal to the chain length.\n    if len(set(map(tuple, new_coords))) == n:\n        return new_coords\n    else:\n        return None\n\n\ndef solve():\n    \"\"\"\n    Main function to run the folding simulations for all test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"S\": \"HHHH\",\n            \"manual_moves\": [(1, 90), (2, 90)],\n            \"T\": 1.0, \"T_max\": 0, \"seed\": 1\n        },\n        {\n            \"S\": \"HPHPHPHP\",\n            \"manual_moves\": [],\n            \"T\": 1.0, \"T_max\": 0, \"seed\": 2\n        },\n        {\n            \"S\": \"HHHHHH\",\n            \"manual_moves\": [(1, 90), (2, 90), (4, -90)],\n            \"T\": 1.0, \"T_max\": 0, \"seed\": 3\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        sequence = case[\"S\"]\n        manual_moves = case[\"manual_moves\"]\n        T = case[\"T\"]\n        T_max = case[\"T_max\"]\n        seed = case[\"seed\"]\n\n        n = len(sequence)\n        \n        # --- Strategy 1: Manual Guidance ---\n        manual_coords = np.array([[i, 0] for i in range(n)], dtype=int)\n        \n        for k, angle in manual_moves:\n            proposed = get_proposed_coords(manual_coords, n, k, angle)\n            if proposed is not None:\n                manual_coords = proposed\n        \n        e_manual = calculate_energy(manual_coords, sequence)\n\n        # --- Strategy 2: Automated Stochastic Dynamics ---\n        rng = np.random.default_rng(seed)\n        \n        # Start with the initial linear conformation\n        current_coords = np.array([[i, 0] for i in range(n)], dtype=int)\n        current_energy = calculate_energy(current_coords, sequence)\n        best_energy = current_energy\n\n        # Perform T_max steps of Monte Carlo simulation\n        if T_max > 0 and n >= 3:\n            possible_k = list(range(1, n - 1))\n            possible_angles = [90, -90, 180]\n\n            for _ in range(T_max):\n                k_rand = rng.choice(possible_k)\n                angle_rand = rng.choice(possible_angles)\n                \n                proposed = get_proposed_coords(current_coords, n, k_rand, angle_rand)\n                \n                if proposed is not None:\n                    # Move is valid, evaluate for acceptance\n                    proposed_energy = calculate_energy(proposed, sequence)\n                    delta_E = proposed_energy - current_energy\n                    \n                    if delta_E  0 or rng.random()  np.exp(-delta_E / T):\n                        # Accept the move\n                        current_coords = proposed\n                        current_energy = proposed_energy\n                \n                # If move is invalid, conformation and energy remain unchanged.\n                best_energy = min(best_energy, current_energy)\n\n        e_auto = best_energy\n        \n        results.append([e_manual, e_auto])\n\n    # Final print statement in the exact required format\n    output_str = \",\".join([f\"[{r[0]},{r[1]}]\" for r in results])\n    print(f\"[{output_str}]\")\n\nsolve()\n```"
        }
    ]
}