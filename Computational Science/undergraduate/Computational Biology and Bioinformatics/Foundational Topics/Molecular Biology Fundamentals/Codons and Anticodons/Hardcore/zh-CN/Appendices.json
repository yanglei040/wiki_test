{
    "hands_on_practices": [
        {
            "introduction": "遗传密码的简并性，即多个密码子编码同一个氨基酸，是其基本特征之一。本练习将引导你使用一种常见的数据结构——哈希表，来模拟和量化分析遗传密码。通过计算不同哈希函数下的碰撞率和分布熵，你将从计算的角度直观地理解简并性如何影响数据组织，并加深对遗传密码内在结构的认识 。",
            "id": "2380350",
            "problem": "您的任务是使用哈希表对标准遗传密码进行建模，并定量分析该密码的简并性（即多个密码子编码同一个氨基酸）如何与哈希行为相互作用。作为基础的生物学基本原理是分子生物学中心法则、密码子和反密码子的定义，以及通过实验确立的标准遗传密码。具体来说，核糖核酸（RNA）以称为密码子的核苷酸三联体形式进行翻译，每个密码子与转移核糖核酸（tRNA）携带的反密码子相匹配，并且由于简并性，从密码子到氨基酸的映射是多对一的。这种简bixing意味着存在同义密码子，即映射到相同氨基酸的不同密码子。您将使用带有分离链表法的哈希表来表示密码子到氨基酸的映射，并在指定的哈希函数族下评估碰撞行为。\n\n请实现一个程序，严格使用标准的RNA遗传密码（核苷酸为 $\\{\\mathrm{U}, \\mathrm{C}, \\mathrm{A}, \\mathrm{G}\\}$，密码子字母表为 $\\{\\mathrm{U}, \\mathrm{C}, \\mathrm{A}, \\mathrm{G}\\}^3$）来执行以下步骤，其中每个密码子映射到一个氨基酸或一个终止信号：\n\n- 构建从所有 $64$ 个RNA密码子到氨基酸的完整映射（使用单字母氨基酸代码和单个字符如 $\\ast$ 代表终止）。此映射是固定的，并且必须是标准遗传密码。\n\n- 定义一个哈希函数族如下。设一个密码子为 $c = c_0 c_1 c_2$，其中 $c_i \\in \\{ \\mathrm{U}, \\mathrm{C}, \\mathrm{A}, \\mathrm{G} \\}$。选择一个有序字母表 $\\alpha$，它是 $\\langle \\mathrm{U}, \\mathrm{C}, \\mathrm{A}, \\mathrm{G} \\rangle$ 的一个排列。根据在 $\\alpha$ 中的位置定义一个数字化映射 $\\phi_{\\alpha} : \\{ \\mathrm{U}, \\mathrm{C}, \\mathrm{A}, \\mathrm{G} \\} \\to \\{0,1,2,3\\}$。设权重固定为 $w_0 = 1$，$w_1 = 4$，$w_2 = 16$。对于模数 $M \\in \\mathbb{N}$，定义哈希索引为\n$$\nh(c) = \\left( w_0 \\, \\phi_{\\alpha}(c_0) + w_1 \\, \\phi_{\\alpha}(c_1) + w_2 \\, \\phi_{\\alpha}(c_2) \\right) \\bmod M.\n$$\n通过插入所有 $64$ 个密码子，使用分离链表法将它们构建到 $M$ 个桶中，从而建立哈希表。\n\n- 对于生成的哈希表，计算以下将哈希与生物学简并性联系起来的定量指标：\n    1. 平均桶负载 $\\overline{L} = \\frac{1}{M} \\sum_{i=1}^{M} L_i$，其中 $L_i$ 是桶 $i$ 中的密码子数量。请注意，根据构造，$\\sum_i L_i = 64$。\n    2. 最大桶负载 $\\max_i L_i$。\n    3. 总碰撞对数\n    $$\n    C_{\\mathrm{tot}} = \\sum_{i=1}^{M} \\binom{L_i}{2},\n    $$\n    它计算哈希到同一个桶中的无序密码子对的数量。\n    4. 同义碰撞对数\n    $$\n    C_{\\mathrm{syn}} = \\sum_{i=1}^{M} \\sum_{a} \\binom{L_{i,a}}{2},\n    $$\n    其中 $L_{i,a}$ 是桶 $i$ 中映射到氨基酸 $a$ 的密码子数量。这计算了桶内编码相同氨基酸的无序碰撞对。\n    5. 非同义碰撞对数 $C_{\\mathrm{non}} = C_{\\mathrm{tot}} - C_{\\mathrm{syn}}$。\n    6. 同义碰撞分数\n    $$\n    f_{\\mathrm{syn}} = \n    \\begin{cases}\n    \\dfrac{C_{\\mathrm{syn}}}{C_{\\mathrm{tot}}},  \\text{if } C_{\\mathrm{tot}} > 0,\\\\\n    0,  \\text{if } C_{\\mathrm{tot}} = 0,\n    \\end{cases}\n    $$\n    即同义碰撞对在总碰撞对中所占的比例。\n    7. 负载方差\n    $$\n    \\sigma_L^2 = \\frac{1}{M} \\sum_{i=1}^{M} \\left(L_i - \\overline{L}\\right)^2,\n    $$\n    一个衡量负载不平衡的分布度量。\n    8. 桶占用分布的香农熵（以2为底）\n    $$\n    H = - \\sum_{i=1}^{M} p_i \\log_2 p_i,\n    $$\n    其中对于 $L_i > 0$ 的桶，$p_i = \\frac{L_i}{64}$，当 $L_i = 0$ 时，$p_i \\log_2 p_i$ 被视为 $0$。\n\n- 您的实现必须对任何 $M$ 和任何有效的 $\\alpha$（$\\langle \\mathrm{U}, \\mathrm{C}, \\mathrm{A}, \\mathrm{G} \\rangle$ 的一个排列）都通用。使用分离链表法。不允许随机化。\n\n测试套件和要求的输出：\n- 对以下测试用例 $(M, \\alpha)$ 运行您的程序：\n    - $(64,\\ \\langle \\mathrm{U}, \\mathrm{C}, \\mathrm{A}, \\mathrm{G} \\rangle)$,\n    - $(61,\\ \\langle \\mathrm{U}, \\mathrm{C}, \\mathrm{A}, \\mathrm{G} \\rangle)$,\n    - $(32,\\ \\langle \\mathrm{U}, \\mathrm{C}, \\mathrm{A}, \\mathrm{G} \\rangle)$,\n    - $(16,\\ \\langle \\mathrm{U}, \\mathrm{C}, \\mathrm{A}, \\mathrm{G} \\rangle)$,\n    - $(23,\\ \\langle \\mathrm{U}, \\mathrm{C}, \\mathrm{A}, \\mathrm{G} \\rangle)$,\n    - $(32,\\ \\langle \\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{U} \\rangle)$,\n    - $(1,\\ \\langle \\mathrm{U}, \\mathrm{C}, \\mathrm{A}, \\mathrm{G} \\rangle)$.\n- 对每个测试，按以下顺序生成一个结果列表：\n    - $\\overline{L}$,\n    - $\\max_i L_i$,\n    - $C_{\\mathrm{tot}}$,\n    - $C_{\\mathrm{syn}}$,\n    - $C_{\\mathrm{non}}$,\n    - $f_{\\mathrm{syn}}$,\n    - $\\sigma_L^2$,\n    - $H$.\n- 程序的最终输出必须是单行，包含这些结果列表的列表，没有空格，所有浮点数四舍五入到 $6$ 位小数，例如：\n    - $\\text{\"[[1.000000,1,0,0,0,0.000000,0.000000,6.000000],[\\dots],\\dots]\"}$。\n\n不涉及物理单位。不要打印任何额外文本。您的程序必须是完全确定性的和自包含的，仅使用标准遗传密码。最终输出格式是单行，由方括号括起来的逗号分隔列表，其中每个测试用例的结果本身也是一个按上述确切顺序排列的、由方括号括起来的逗号分隔列表。",
            "solution": "问题陈述已经过严格验证，并被认定为有效。它在科学上基于分子生物学的原理，特别是标准遗传密码，并提出了一个良定的计算任务。定义、约束和目标都以足够的清晰度和精确度进行了规定，从而可以得出一个唯一且确定性的解。因此，我们将继续进行解的推导和实现。\n\n该问题要求对应用于 $64$ 个标准RNA密码子集合的哈希模型进行定量分析。该分析将一个已定义的哈希函数族的属性与遗传密码中的生物学简并现象联系起来。\n\n首先，我们建立基础数据。RNA核苷酸的集合是 $\\{\\mathrm{U}, \\mathrm{C}, \\mathrm{A}, \\mathrm{G}\\}$。密码子的集合是笛卡尔积 $\\{\\mathrm{U}, \\mathrm{C}, \\mathrm{A}, \\mathrm{G}\\}^3$，产生 $4^3 = 64$ 个不同的密码子。我们将标准遗传密码实现为从这 $64$ 个密码子中的每一个到 $20$ 种标准氨基酸之一（用单字母代码表示）或一个终止信号（用 $\\ast$ 表示）的映射。这个映射是固定的，并且是根据经验确定的。\n\n问题的核心是为这 $64$ 个密码子构建和分析一个哈希表。该哈希表有 $M$ 个桶，并使用分离链表法来解决碰撞。对于由参数 $(M, \\alpha)$ 指定的给定测试用例，其中 $M \\in \\mathbb{N}$ 是桶的数量，$\\alpha$ 是 $\\langle \\mathrm{U}, \\mathrm{C}, \\mathrm{A}, \\mathrm{G} \\rangle$ 的一个有序排列，其过程如下：\n\n步骤1：哈希表构建\n我们首先定义数字化映射 $\\phi_{\\alpha}: \\{\\mathrm{U}, \\mathrm{C}, \\mathrm{A}, \\mathrm{G}\\} \\to \\{0, 1, 2, 3\\}$，它将每个核苷酸映射到其在有序字母表 $\\alpha$ 中从零开始的索引。对于一个密码子 $c = c_0 c_1 c_2$，哈希函数由下式给出：\n$$\nh(c) = \\left( w_0 \\, \\phi_{\\alpha}(c_0) + w_1 \\, \\phi_{\\alpha}(c_1) + w_2 \\, \\phi_{\\alpha}(c_2) \\right) \\bmod M\n$$\n其中固定整数权重为 $w_0 = 1$，$w_1 = 4$ 和 $w_2 = 16$。总和 $\\sum_{i=0}^{2} w_i \\phi_{\\alpha}(c_i)$ 为每个密码子提供一个从 $0$ 到 $63$ 的唯一整数值，这实际上是将密码子视为一个四进制位值制中的数字。我们遍历所有 $64$ 个密码子，计算它们的哈希索引 $h(c)$，并将它们放入相应的桶中，每个桶是一个映射到该索引的密码子列表。\n\n步骤2：指标计算\n在所有 $64$ 个密码子被分配到 $M$ 个桶之后，我们计算以下八个指标。设 $L_i$ 为桶 $i$ 的负载（密码子数量），其中 $i \\in \\{0, 1, \\dots, M-1\\}$。\n\n1.  平均桶负载，$\\overline{L}$：这是项目总数（$64$）除以桶的数量（$M$）。\n    $$\n    \\overline{L} = \\frac{64}{M}\n    $$\n2.  最大桶负载，$\\max_i L_i$：这是所有桶负载 $L_i$ 中的最大值。\n3.  总碰撞对数，$C_{\\mathrm{tot}}$：对于一个负载为 $L_i$ 的桶，有 $\\binom{L_i}{2}$ 个无序密码子对发生碰撞。总数是所有桶的总和。\n    $$\n    C_{\\mathrm{tot}} = \\sum_{i=0}^{M-1} \\binom{L_i}{2} = \\sum_{i=0}^{M-1} \\frac{L_i (L_i - 1)}{2}\n    $$\n4.  同义碰撞对数，$C_{\\mathrm{syn}}$：这个指标通过考虑生物学意义来细化总碰撞。我们只计算同义（即编码相同氨基酸）的密码子碰撞对。对于每个桶 $i$，我们按其编码的氨基酸 $a$ 对密码子进行分组。设 $L_{i,a}$ 是桶 $i$ 中编码氨基酸 $a$ 的密码子数量。同义对的数量是 $\\binom{L_{i,a}}{2}$ 对所有氨基酸 $a$ 和所有桶 $i$ 的总和。\n    $$\n    C_{\\mathrm{syn}} = \\sum_{i=0}^{M-1} \\sum_{a} \\binom{L_{i,a}}{2}\n    $$\n5.  非同义碰撞对数，$C_{\\mathrm{non}}$：这仅仅是总碰撞对数与同义碰撞对数之间的差值。这些是哈希到同一个桶但编码不同氨基酸的密码子对。\n    $$\n    C_{\\mathrm{non}} = C_{\\mathrm{tot}} - C_{\\mathrm{syn}}\n    $$\n6.  同义碰撞分数，$f_{\\mathrm{syn}}$：这是同义碰撞与总碰撞的比率，表示对应于简并编码的哈希碰撞的比例。\n    $$\n    f_{\\mathrm{syn}} = \\begin{cases} \\dfrac{C_{\\mathrm{syn}}}{C_{\\mathrm{tot}}},  \\text{if } C_{\\mathrm{tot}} > 0 \\\\ 0,  \\text{if } C_{\\mathrm{tot}} = 0 \\end{cases}\n    $$\n7.  负载方差，$\\sigma_L^2$：这衡量了桶负载分布围绕平均负载 $\\overline{L}$ 的离散程度。较低的方差表示密码子的分布更均匀。\n    $$\n    \\sigma_L^2 = \\frac{1}{M} \\sum_{i=0}^{M-1} (L_i - \\overline{L})^2\n    $$\n8.  香农熵，$H$：这衡量了密码子在各桶中分布的不确定性或“无序性”。设 $p_i = L_i / 64$ 是一个随机选择的密码子落入桶 $i$ 的概率。熵以比特（以2为底）为单位给出。\n    $$\n    H = - \\sum_{i=0}^{M-1} p_i \\log_2 p_i\n    $$\n    其中，如果 $p_i = 0$，则 $p_i \\log_2 p_i$ 项被视为 $0$。更高的熵对应于更均匀的分布。对于一个 $M=64$ 的完美哈希函数，每个 $L_i=1$，因此每个 $p_i = 1/64$，并且 $H = \\log_2(64) = 6$ 比特，这是可能的最大值。\n\n实现将通过执行这些步骤来处理每个测试用例，并按规定将八个结果浮点数格式化为六位小数。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import entropy\n\ndef solve():\n    \"\"\"\n    Solves the computational biology problem by modeling the genetic code with a hash table\n    and analyzing its properties for a given set of test cases.\n    \"\"\"\n\n    # The canonical RNA genetic code mapping from codon to amino acid (1-letter) or stop (*).\n    CANONICAL_GENETIC_CODE = {\n        'UUU': 'F', 'UUC': 'F', 'UUA': 'L', 'UUG': 'L',\n        'UCU': 'S', 'UCC': 'S', 'UCA': 'S', 'UCG': 'S',\n        'UAU': 'Y', 'UAC': 'Y', 'UAA': '*', 'UAG': '*',\n        'UGU': 'C', 'UGC': 'C', 'UGA': '*', 'UGG': 'W',\n\n        'CUU': 'L', 'CUC': 'L', 'CUA': 'L', 'CUG': 'L',\n        'CCU': 'P', 'CCC': 'P', 'CCA': 'P', 'CCG': 'P',\n        'CAU': 'H', 'CAC': 'H', 'CAA': 'Q', 'CAG': 'Q',\n        'CGU': 'R', 'CGC': 'R', 'CGA': 'R', 'CGG': 'R',\n\n        'AUU': 'I', 'AUC': 'I', 'AUA': 'I', 'AUG': 'M',\n        'ACU': 'T', 'ACC': 'T', 'ACA': 'T', 'ACG': 'T',\n        'AAU': 'N', 'AAC': 'N', 'AAA': 'K', 'AAG': 'K',\n        'AGU': 'S', 'AGC': 'S', 'AGA': 'R', 'AGG': 'R',\n\n        'GUU': 'V', 'GUC': 'V', 'GUA': 'V', 'GUG': 'V',\n        'GCU': 'A', 'GCC': 'A', 'GCA': 'A', 'GCG': 'A',\n        'GAU': 'D', 'GAC': 'D', 'GAA': 'E', 'GAG': 'E',\n        'GGU': 'G', 'GGC': 'G', 'GGA': 'G', 'GGG': 'G',\n    }\n\n    # All 64 codons, derived from the keys of the genetic code map.\n    ALL_CODONS = list(CANONICAL_GENETIC_CODE.keys())\n    \n    # Weights for the hash function.\n    WEIGHTS = [1, 4, 16]\n\n    test_cases = [\n        (64, ('U', 'C', 'A', 'G')),\n        (61, ('U', 'C', 'A', 'G')),\n        (32, ('U', 'C', 'A', 'G')),\n        (16, ('U', 'C', 'A', 'G')),\n        (23, ('U', 'C', 'A', 'G')),\n        (32, ('A', 'C', 'G', 'U')),\n        (1, ('U', 'C', 'A', 'G')),\n    ]\n\n    all_results = []\n\n    for m_val, alpha in test_cases:\n        # Step 1: Build the hash table for the given test case (M, alpha)\n\n        # Create the digitization map phi_alpha\n        phi_alpha = {nucleotide: i for i, nucleotide in enumerate(alpha)}\n\n        # Initialize M buckets for separate chaining\n        buckets = [[] for _ in range(m_val)]\n\n        # Hash each of the 64 codons and place them in the appropriate bucket\n        for codon in ALL_CODONS:\n            h_val_unmod = (WEIGHTS[0] * phi_alpha[codon[0]] +\n                           WEIGHTS[1] * phi_alpha[codon[1]] +\n                           WEIGHTS[2] * phi_alpha[codon[2]])\n            h_index = h_val_unmod % m_val\n            buckets[h_index].append(codon)\n\n        # Step 2: Compute the quantitative metrics\n\n        # Get bucket loads Li\n        bucket_loads = [len(b) for b in buckets]\n\n        # 1. Average bucket load\n        avg_load = 64.0 / m_val\n\n        # 2. Maximum bucket load\n        max_load = 0\n        if bucket_loads:\n            max_load = max(bucket_loads)\n\n        # Helper function for combinations nC2\n        def n_choose_2(n):\n            return n * (n - 1) // 2\n\n        # 3. Total collision pairs\n        c_tot = sum(n_choose_2(load) for load in bucket_loads)\n\n        # 4. Synonymous collision pairs\n        c_syn = 0\n        for bucket in buckets:\n            if len(bucket) > 1:\n                aa_counts = {}\n                for codon in bucket:\n                    aa = CANONICAL_GENETIC_CODE[codon]\n                    aa_counts[aa] = aa_counts.get(aa, 0) + 1\n                \n                for count in aa_counts.values():\n                    c_syn += n_choose_2(count)\n        \n        # 5. Non-synonymous collision pairs\n        c_non = c_tot - c_syn\n\n        # 6. Synonymous collision fraction\n        f_syn = 0.0 if c_tot == 0 else c_syn / c_tot\n        \n        # 7. Load variance\n        load_variance = np.var(bucket_loads)\n        \n        # 8. Shannon entropy\n        # Probability distribution p_i = L_i / 64\n        probabilities = np.array(bucket_loads) / 64.0\n        shannon_entropy = entropy(probabilities, base=2)\n\n        # Collect and format results for the current test case\n        case_results = [\n            f\"{avg_load:.6f}\",\n            str(max_load),\n            str(c_tot),\n            str(c_syn),\n            str(c_non),\n            f\"{f_syn:.6f}\",\n            f\"{load_variance:.6f}\",\n            f\"{shannon_entropy:.6f}\",\n        ]\n        all_results.append(f\"[{','.join(case_results)}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "细胞如何用有限种类的转运RNA（tRNA）来识别所有61种有义密码子？“摆动假说”为此提供了关键解释，揭示了翻译过程中的效率原则。在本练习中，你将通过解决一系列小型集合覆盖问题，来计算在给定的非标准摆动配对规则下，翻译一组基因所需的最小tRNA种类数 。这项实践将密码子与反密码子的配对机制与一个经典的计算优化问题联系起来。",
            "id": "2380386",
            "problem": "您的任务是计算在特定的非标准摆动配对规则下，翻译给定核糖核酸 (RNA) 基因组所需的最小转运核糖核酸 (tRNA) 种类数，记为 $N_{\\min}$。分子生物学的中心法则指出，脱氧核糖核酸 (DNA) 转录为 RNA，RNA 再被翻译成蛋白质。翻译过程通过 tRNA 反密码子与 RNA 密码子（基于字母表$\\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{U}\\}$ 的三联体）的碱基配对，将密码子解码为氨基酸。标准的 Watson–Crick 碱基配对应用于密码子的第 $1$ 和第 $2$ 位（对应反密码子的第 $3$ 和第 $2$ 位），而摆动位置（密码子第 $3$ 位和反密码子第 $1$ 位）则允许由修饰决定的扩展配对规则。每种 tRNA 被假定为对单一氨基酸具有特异性，并且在此仅通过其反密码子第 $1$ 位的摆动碱基来表征；反密码子的第 $2$ 和第 $3$ 位被假定为与密码子前两位严格 Watson–Crick 互补。终止密码子不被翻译，必须忽略。\n\n基本基础与约束：\n- 密码子是 $\\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{U}\\}$ 上长度为 $3$ 的词。经典核遗传密码（标准遗传密码）将 $64$ 个密码子映射到 $20$ 种氨基酸和 $3$ 个终止信号（三个终止密码子是 $\\mathrm{UAA}$、$\\mathrm{UAG}$ 和 $\\mathrm{UGA}$）。只有有义密码子（非终止）需要 tRNA。\n- 对于任何固定的氨基酸和固定的前两个碱基 $XY \\in \\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{U}\\}^2$，其在该“家族框”中的同义密码子集合是 $XY\\{b \\mid b \\in \\mathcal{B}_{aa,XY}\\}$，其中 $\\mathcal{B}_{aa,XY} \\subseteq \\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{U}\\}$ 取决于标准遗传密码的分配。该框的一种 tRNA 的反密码子第 $2$ 和第 $3$ 位与 $X$ 和 $Y$ 互补，其反密码子摆动碱基决定了它在该框中可以解码哪些第三位碱基字母。一个 tRNA 不能服务于翻译成不同氨基酸的密码子，即使其反密码子可以配对，因为氨酰化过程是氨基酸特异性的。\n- 摆动配对规则以从反密码子摆动碱基符号到其解码的密码子第三位碱基字母集合的映射形式提供。对于给定的氨基酸和 $XY$ 家族框，如果在基因组中观察到的该框的第三位碱基集合是 $S \\subseteq \\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{U}\\}$，那么该框所需的最小 tRNA 数量等于其解码字母集合能够覆盖 $S$ 的摆动碱基类型的最小数量。这是一个在大小最多为 $4$ 的基集上的最小集合覆盖问题。\n\n待使用的非标准摆动规则集：\n- 规则集 $\\mathcal{R}_{\\mathrm{NS1}}$ (允许线粒体样的超级摆动): \n  $\\mathrm{A}\\to\\{\\mathrm{U}\\}$, $\\mathrm{C}\\to\\{\\mathrm{G}\\}$, $\\mathrm{G}\\to\\{\\mathrm{C},\\mathrm{U}\\}$, $\\mathrm{U}\\to\\{\\mathrm{A},\\mathrm{G}\\}$, $\\mathrm{I}\\to\\{\\mathrm{A},\\mathrm{C},\\mathrm{U}\\}$, $\\mathrm{W}\\to\\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{U}\\}$, $\\mathrm{K}\\to\\{\\mathrm{A}\\}$, $\\mathrm{Q}\\to\\{\\mathrm{U},\\mathrm{C}\\}$。\n- 规则集 $\\mathcal{R}_{\\mathrm{NS2}}$ (无肌苷；扩展但非超级摆动): \n  $\\mathrm{A}\\to\\{\\mathrm{U}\\}$, $\\mathrm{C}\\to\\{\\mathrm{G}\\}$, $\\mathrm{G}\\to\\{\\mathrm{C},\\mathrm{U}\\}$, $\\mathrm{U}\\to\\{\\mathrm{A},\\mathrm{G}\\}$, $\\mathrm{Q}\\to\\{\\mathrm{U},\\mathrm{C}\\}$, $\\mathrm{M}\\to\\{\\mathrm{A},\\mathrm{G}\\}$, $\\mathrm{K}\\to\\{\\mathrm{A}\\}$。\n- 规则集 $\\mathcal{R}_{\\mathrm{NS3}}$ (限制性摆动；抑制的 $\\mathrm{G}\\text{-}\\mathrm{U}$ 配对): \n  $\\mathrm{A}\\to\\{\\mathrm{U}\\}$, $\\mathrm{C}\\to\\{\\mathrm{G}\\}$, $\\mathrm{G}\\to\\{\\mathrm{C}\\}$, $\\mathrm{U}\\to\\{\\mathrm{A}\\}$, $\\mathrm{I}\\to\\{\\mathrm{A},\\mathrm{C},\\mathrm{U}\\}$, $\\mathrm{K}\\to\\{\\mathrm{A}\\}$, $\\mathrm{Q}\\to\\{\\mathrm{U},\\mathrm{C}\\}$。\n\n任务：\n- 实现一个程序，对每个测试用例，按如下方式计算 $N_{\\min}$。对于每种氨基酸，将基因组中编码该氨基酸的密码子按其前两个碱基 $XY$ 进行划分。对于每个分区，令 $S$ 为该氨基酸和 $XY$ 在基因组中实际观察到的第三位碱基字母集合。使用指定的摆动规则集，找到其解码字母集合能覆盖 $S$ 的反密码子摆动碱基类型的最小数量。将所有氨基酸和所有 $XY$ 分区的这个最小计数相加，得到该基因组在该规则集下的 $N_{\\min}$。完全忽略终止密码子。所有计数均为整数，并应以整数形式报告。\n\n测试套件：\n- 案例 $1$：基因组 $\\mathcal{G}_1$，包含密码子 \n  $\\{\\mathrm{AUG},\\mathrm{GCU},\\mathrm{GCC},\\mathrm{GCA},\\mathrm{GCG},\\mathrm{GGU},\\mathrm{GGC},\\mathrm{GGA},\\mathrm{AUU},\\mathrm{AUC},\\mathrm{AUA},\\mathrm{UUU},\\mathrm{UUC},\\mathrm{CCU},\\mathrm{CCA},\\mathrm{UCU},\\mathrm{UCC},\\mathrm{UCA},\\mathrm{UCG},\\mathrm{AGU},\\mathrm{CUA},\\mathrm{CUG},\\mathrm{UUA},\\mathrm{GUU},\\mathrm{UAU},\\mathrm{UAC},\\mathrm{UAA},\\mathrm{UGA},\\mathrm{UAG}\\}$，在 $\\mathcal{R}_{\\mathrm{NS1}}$ 规则下进行评估。\n- 案例 $2$：相同的基因组 $\\mathcal{G}_1$，在 $\\mathcal{R}_{\\mathrm{NS2}}$ 规则下进行评估。\n- 案例 $3$：相同的基因组 $\\mathcal{G}_1$，在 $\\mathcal{R}_{\\mathrm{NS3}}$ 规则下进行评估。\n- 案例 $4$：基因组 $\\mathcal{G}_2$，包含重复 $10$ 次的 $\\mathrm{UUU}$ 和一个终止密码子 $\\mathrm{UAA}$，在 $\\mathcal{R}_{\\mathrm{NS3}}$ 规则下进行评估。\n- 案例 $5$：基因组 $\\mathcal{G}_{\\mathrm{all}}$，包含 $61$ 个有义密码子中的每一个恰好一次（所有标准遗传密码的有义密码子），在 $\\mathcal{R}_{\\mathrm{NS3}}$ 规则下进行评估。\n\n您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5]$），其中每个 $\\text{result}_i$ 是上述顺序中对应案例的整数 $N_{\\min}$。程序不应读取任何用户输入；所有数据必须嵌入程序中。不涉及任何物理单位或角度。所有输出均为整数。实现语言和环境在最终答案说明中指定。",
            "solution": "问题陈述是有效的。它具有科学依据、定义明确且客观。它基于分子生物学的既定原则，特别是信使 RNA 翻译成蛋白质的过程，提出了一个清晰的计算任务。该问题要求计算在指定的非标准摆动配对规则下，翻译给定 RNA 密码子集所需的最小转运 RNA (tRNA) 种类数 $N_{\\min}$。这是一个定义明确的优化问题，可以分解为一系列最小集合覆盖问题。\n\n基本原理是蛋白质合成依赖于 tRNA 分子上相应的三碱基反密码子对 mRNA 分子上三碱基密码子的识别。每个 tRNA 都携带一个特定的氨基酸。虽然密码子的前两个位置分别与反密码子的第三和第二个位置的碱基配对遵循标准的 Watson-Crick 规则（$\\mathrm{A}$-$\\mathrm{U}$，$\\mathrm{G}$-$\\mathrm{C}$），但在“摆动”位置（密码子第 $3$ 位，反密码子第 $1$ 位）的配对则更为灵活。这种灵活性通常由反密码子第一个碱基的化学修饰所决定。问题提供了三套假设的此类摆动配对规则集 $\\mathcal{R}_{\\mathrm{NS1}}$、$\\mathcal{R}_{\\mathrm{NS2}}$ 和 $\\mathcal{R}_{\\mathrm{NS3}}$，将反密码子摆动碱基映射到它们可以识别的密码子第三位碱基集合。\n\n核心约束是，由其反密码子和氨基酸特异性定义的单个 tRNA 种类，不能服务于翻译成不同氨基酸的密码子。这引出了核心算法步骤：划分问题。总 tRNA 数量 $N_{\\min}$ 是为不同密码子组所需的最小 tRNA 数量之和。这些组由唯一的（氨基酸，密码子前缀 $XY$）对定义，其中 $XY$ 是该组中密码子的前两个碱基。\n\n解决方案按以下步骤进行：\n\n步骤 1：数据结构化。\n首先，我们对必要的生物学和问题特定数据进行编码。\n- 标准核遗传密码表示为从 $64$ 个密码子到其对应氨基酸或终止信号的映射。例如，$\\mathrm{UUU} \\to \\mathrm{苯丙氨酸}$ 和 $\\mathrm{UAA} \\to \\mathrm{终止}$。\n- 非标准摆动配对规则（$\\mathcal{R}_{\\mathrm{NS1}}$、$\\mathcal{R}_{\\mathrm{NS2}}$ 和 $\\mathcal{R}_{\\mathrm{NS3}}$）存储为映射。每个映射将一个反密码子摆动碱基（例如，`I` 代表肌苷）与其可以配对的密码子第三位碱基集合（例如，$\\{\\mathrm{A}, \\mathrm{C}, \\mathrm{U}\\}$）相关联。\n- 每个测试用例的输入基因组以唯一密码子的集合形式提供。终止密码子（$\\mathrm{UAA}$、$\\mathrm{UAG}$、$\\mathrm{UGA}$）被排除在任何分析之外。\n\n步骤 2：密码子划分。\n对于给定的基因组和规则集，我们遍历所有存在的、唯一的、非终止的密码子。每个密码子根据其编码的氨基酸及其前两个核苷酸（$XY$）进行分类。这将创建一组不相交的分区。对于由键（氨基酸, $XY$）标识的每个分区，我们收集所有观察到的第三位碱基的集合。对于对应于（氨基酸$_{i}$，$XY_{j}$）的分区，令这个观察到的第三位碱基集合为 $S_{i,j}$。\n\n例如，如果基因组包含密码子 $\\mathrm{GCU}$、$\\mathrm{GCC}$ 和 $\\mathrm{GCA}$，它们都编码丙氨酸，并且都共享前缀 $\\mathrm{GC}$。这形成了一个键为（$\\mathrm{丙氨酸}$, $\\mathrm{GC}$）的单一分区，所需的第三位碱基集合为 $S = \\{\\mathrm{U}, \\mathrm{C}, \\mathrm{A}\\}$。\n\n步骤 3：解决最小集合覆盖问题。\n对于每个分区 $(i, j)$ 及其对应的所需第三位碱基集 $S_{i,j}$，我们必须从指定的规则集中找到最小数量的 tRNA 摆动碱基，使得它们识别的碱基集合能共同“覆盖”$S_{i,j}$。这是一个经典的最小集合覆盖问题。要覆盖的元素全集是 $S_{i,j}$，它是 $\\{\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{U}\\}$ 的一个子集。可用于形成覆盖的可用集合集合由所选摆动规则映射中的值给出（例如，对于 $\\mathcal{R}_{\\mathrm{NS1}}$，可用集合为 $\\{\\mathrm{U}\\}, \\{\\mathrm{G}\\}, \\{\\mathrm{C}, \\mathrm{U}\\}, \\dots$）。\n\n由于全集大小最多为 $4$，这个问题可以通过穷举搜索高效解决。我们检查是否存在大小为 $k=1$ 的覆盖。如果不存在，我们检查大小为 $k=2$ 的覆盖，依此类推。第一个找到覆盖的 $k$ 值就是最小大小。令 $c_{i,j}$ 为分区 $(i, j)$ 所需的最小 tRNA 数量。\n\n例如，要在规则集 $\\mathcal{R}_{\\mathrm{NS1}}$ 下覆盖（$\\mathrm{丙氨酸}$, $\\mathrm{GC}$）的集合 $S = \\{\\mathrm{U}, \\mathrm{C}, \\mathrm{A}\\}$，我们检查可用的摆动配对。反密码子摆动碱基 `I` 识别 $\\{\\mathrm{A}, \\mathrm{C}, \\mathrm{U}\\}$。由于 $S \\subseteq \\{\\mathrm{A}, \\mathrm{C}, \\mathrm{U}\\}$，一个带有反密码子 `I` 的 tRNA 就足够了。因此，该分区的成本为 $c = 1$。如果没有单个 tRNA 可以覆盖 $S$，我们将检查所有 tRNA 对，依此类推。\n\n步骤 4：最终计算。\n所需的 tRNA 种类总数 $N_{\\min}$ 是为每个分区计算的最小数量之和：\n$$ N_{\\min} = \\sum_{i,j} c_{i,j} $$\n对问题中指定的五个测试用例中的每一个重复此过程，为每个案例使用适当的基因组和摆动规则集。最终输出是每个案例的 $N_{\\min}$ 整数值的有序列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom itertools import combinations\n\ndef solve():\n    \"\"\"\n    Solves the tRNA minimization problem for all test cases.\n    \"\"\"\n\n    # --- Data Definitions ---\n\n    # Standard Nuclear Genetic Code\n    genetic_code = {\n        'UUU': 'F', 'UUC': 'F', 'UUA': 'L', 'UUG': 'L',\n        'UCU': 'S', 'UCC': 'S', 'UCA': 'S', 'UCG': 'S',\n        'UAU': 'Y', 'UAC': 'Y', 'UAA': 'Stop', 'UAG': 'Stop',\n        'UGU': 'C', 'UGC': 'C', 'UGA': 'Stop', 'UGG': 'W',\n\n        'CUU': 'L', 'CUC': 'L', 'CUA': 'L', 'CUG': 'L',\n        'CCU': 'P', 'CCC': 'P', 'CCA': 'P', 'CCG': 'P',\n        'CAU': 'H', 'CAC': 'H', 'CAA': 'Q', 'CAG': 'Q',\n        'CGU': 'R', 'CGC': 'R', 'CGA': 'R', 'CGG': 'R',\n\n        'AUU': 'I', 'AUC': 'I', 'AUA': 'I', 'AUG': 'M',\n        'ACU': 'T', 'ACC': 'T', 'ACA': 'T', 'ACG': 'T',\n        'AAU': 'N', 'AAC': 'N', 'AAA': 'K', 'AAG': 'K',\n        'AGU': 'S', 'AGC': 'S', 'AGA': 'R', 'AGG': 'R',\n\n        'GUU': 'V', 'GUC': 'V', 'GUA': 'V', 'GUG': 'V',\n        'GCU': 'A', 'GCC': 'A', 'GCA': 'A', 'GCG': 'A',\n        'GAU': 'D', 'GAC': 'D', 'GAA': 'E', 'GAG': 'E',\n        'GGU': 'G', 'GGC': 'G', 'GGA': 'G', 'GGG': 'G'\n    }\n\n    # Non-standard Wobble Rule Sets\n    wobble_rules = {\n        'R_NS1': {\n            'A': frozenset({'U'}), 'C': frozenset({'G'}),\n            'G': frozenset({'C', 'U'}), 'U': frozenset({'A', 'G'}),\n            'I': frozenset({'A', 'C', 'U'}), 'W': frozenset({'A', 'C', 'G', 'U'}),\n            'K': frozenset({'A'}), 'Q': frozenset({'U', 'C'})\n        },\n        'R_NS2': {\n            'A': frozenset({'U'}), 'C': frozenset({'G'}),\n            'G': frozenset({'C', 'U'}), 'U': frozenset({'A', 'G'}),\n            'Q': frozenset({'U', 'C'}), 'M': frozenset({'A', 'G'}),\n            'K': frozenset({'A'})\n        },\n        'R_NS3': {\n            'A': frozenset({'U'}), 'C': frozenset({'G'}),\n            'G': frozenset({'C'}), 'U': frozenset({'A'}),\n            'I': frozenset({'A', 'C', 'U'}), 'K': frozenset({'A'}),\n            'Q': frozenset({'U', 'C'})\n        }\n    }\n\n    # Test Suite\n    genome_g1 = {\n        \"AUG\", \"GCU\", \"GCC\", \"GCA\", \"GCG\", \"GGU\", \"GGC\", \"GGA\", \"AUU\", \"AUC\", \"AUA\",\n        \"UUU\", \"UUC\", \"CCU\", \"CCA\", \"UCU\", \"UCC\", \"UCA\", \"UCG\", \"AGU\", \"CUA\",\n        \"CUG\", \"UUA\", \"GUU\", \"UAU\", \"UAC\", \"UAA\", \"UGA\", \"UAG\"\n    }\n\n    genome_g2 = {\"UUU\"} # 10 times does not change the set, stop codon UAA is ignored\n\n    all_sense_codons = {codon for codon, aa in genetic_code.items() if aa != 'Stop'}\n\n    test_cases = [\n        (genome_g1, wobble_rules['R_NS1']),\n        (genome_g1, wobble_rules['R_NS2']),\n        (genome_g1, wobble_rules['R_NS3']),\n        (genome_g2, wobble_rules['R_NS3']),\n        (all_sense_codons, wobble_rules['R_NS3']),\n    ]\n\n    # --- Helper Functions ---\n    def solve_min_set_cover(target_set, covering_sets):\n        \"\"\"\n        Solves the minimum set cover problem for a small universe.\n        The target_set must be covered by the union of sets from covering_sets.\n        \"\"\"\n        if not target_set:\n            return 0\n        \n        # Check covers of increasing size\n        for k in range(1, len(covering_sets) + 1):\n            for combo in combinations(covering_sets, k):\n                # An arbitrary iterable of a collection of sets can be passed to union()\n                union_of_combo = frozenset.union(*combo)\n                if target_set.issubset(union_of_combo):\n                    return k\n        # This part should be unreachable if all bases can be covered.\n        # Fallback in case of an un-coverable base, though problem setup prevents this.\n        return len(target_set)\n\n    def compute_n_min(genome_codons, rules):\n        \"\"\"\n        Computes N_min for a given genome and rule set.\n        \"\"\"\n        codons_by_group = {}\n        for codon in genome_codons:\n            aa = genetic_code.get(codon)\n            if aa and aa != 'Stop':\n                prefix = codon[:2]\n                third_base = codon[2]\n                key = (aa, prefix)\n                if key not in codons_by_group:\n                    codons_by_group[key] = set()\n                codons_by_group[key].add(third_base)\n\n        total_trna_count = 0\n        available_covers = list(rules.values())\n        \n        for group_key, third_bases_needed in codons_by_group.items():\n            min_cover_size = solve_min_set_cover(frozenset(third_bases_needed), available_covers)\n            total_trna_count += min_cover_size\n            \n        return total_trna_count\n\n    # --- Main Logic ---\n    results = []\n    for genome, rules in test_cases:\n        result = compute_n_min(genome, rules)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "同义密码子的选择并非总是随机的，它可能受到选择压力的影响，这构成了密码子使用偏好性的基础。一个有趣的进化假说是，那些仅需一次突变就会变成终止密码子的“近终止”密码子，可能会因其潜在的风险而在重要基因中被选择性地规避。本练习将指导你完成一项完整的生物信息学分析 ，通过处理基因序列数据并应用统计检验，来验证这一假说是否成立。",
            "id": "2380355",
            "problem": "您的任务是通过编程来量化，在一组必需基因中，与一组匹配的非必需基因相比，那些与终止密码子仅相差一个点突变的信使核糖核酸（mRNA）密码子是否存在代表性不足的情况。该分析必须基于分子生物学中心法则（脱氧核糖核酸到核糖核酸到蛋白质）、密码子是在字母表 $\\Sigma = \\{\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{U}\\}$ 上长度为$3$的三联体的定义、三个终止密码子$\\{\\mathrm{UAA}, \\mathrm{UAG}, \\mathrm{UGA}\\}$的存在，以及定义转移核糖核酸（tRNA）反密码子的碱基配对规则。如果一个密码子到任意一个终止密码子的汉明距离（两个等长字符串在相应位置上不同符号的数量）恰好为$1$，且该密码子本身不是终止密码子，则该密码子是“近终止”密码子。只有有义密码子（非终止密码子）计入使用总数。假设编码序列已经过剪接，并以框内读码方式、沿$5'$到$3'$方向作为字母表 $\\Sigma$ 上的字符串提供，其长度是$3$的倍数。\n\n从这些基本原理出发：\n- 终止密码子集合为 $S = \\{\\mathrm{UAA}, \\mathrm{UAG}, \\mathrm{UGA}\\}$。\n- 所有密码子的集合为 $\\Sigma^3$，其大小为 $|\\Sigma^3| = 4^3 = 64$。\n- 有义密码子的集合为 $\\Sigma^3 \\setminus S$。\n- 一个“近终止”密码子 $c$ 满足 $\\min_{s \\in S} \\mathrm{Hamming}(c, s) = 1$ 且 $c \\notin S$。\n- 在沃森-克里克配对（$\\mathrm{A}\\leftrightarrow \\mathrm{U}$，$\\mathrm{C}\\leftrightarrow \\mathrm{G}$）规则下，反密码子是密码子的反向互补序列，但在此处使用反密码子仅为证明密码子框架的合理性；计算完全在密码子层面上进行。\n\n您必须设计一个算法，该算法能够：\n- 在给定的读码框中，将每个基因序列解析为不重叠的密码子。\n- 从使用计数中排除遇到的任何终止密码子。\n- 对每个基因集（必需基因与非必需基因），分别计算近终止有义密码子的总数和非近终止有义密码子的总数。\n- 构建一个包含以下条目的 $2\\times 2$ 列联表：\n  - $a$：必需基因中的近终止密码子计数，\n  - $b$：必需基因中的非近终止密码子计数，\n  - $c$：非必需基因中的近终止密码子计数，\n  - $d$：非必需基因中的非近终止密码子计数。\n- 计算使用拉普拉斯平滑参数 $\\alpha > 0$ 的平滑对数优势比：\n  $$\\mathrm{LOR}_\\alpha = \\log\\left(\\frac{a+\\alpha}{b+\\alpha}\\right) - \\log\\left(\\frac{c+\\alpha}{d+\\alpha}\\right)。$$\n- 为该表计算双边Fisher精确检验的$p$值\n  $$\\begin{pmatrix} a  b \\\\ c  d \\end{pmatrix}。$$\n  如果任何行和或任何列和等于$0$（即 $a+b=0$ 或 $c+d=0$ 或 $a+c=0$ 或 $b+d=0$），为了本程序的目的，将双边$p$值定义为$1.0$。\n- 当且仅当 $\\mathrm{LOR}_\\alpha < 0$ 且双边$p$值小于指定的显著性阈值 $\\tau$ 时，判定必需基因中存在“代表性不足”。\n\n实现要求：\n- 完全基于给定的序列和定义进行工作。\n- 将所有输入视为字母表 $\\{\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{U}\\}$ 上的mRNA密码子。\n- 忽略任何无法形成完整密码子三联体的尾部核苷酸（所提供的序列长度将是$3$的倍数）。\n\n测试套件：\n实现您的程序以运行以下三个独立的测试用例。每个测试用例都指定了一组必需基因序列、一组非必需基因序列、一个平滑参数 $\\alpha$ 和一个显著性阈值 $\\tau$。所有序列都是有效的mRNA编码序列，每个字符串的长度都是$3$的倍数，且不包含内部终止密码子。\n\n- 测试用例1（平衡使用；预期无代表性不足）：\n  - 必需基因：\n    - $\\mathrm{E1} = \\text{\"AAGGCUAAAGCUUUU\"}$ 解析为 $(\\mathrm{AAG}, \\mathrm{GCU}, \\mathrm{AAA}, \\mathrm{GCU}, \\mathrm{UUU})$，\n    - $\\mathrm{E2} = \\text{\"GCCUGGUGGUUCGCA\"}$ 解析为 $(\\mathrm{GCC}, \\mathrm{UGG}, \\mathrm{UGG}, \\mathrm{UUC}, \\mathrm{GCA})$。\n  - 非必需基因：\n    - $\\mathrm{N1} = \\text{\"CAAGCUUAUGCGUUC\"}$ 解析为 $(\\mathrm{CAA}, \\mathrm{GCU}, \\mathrm{UAU}, \\mathrm{GCG}, \\mathrm{UUC})$，\n    - $\\mathrm{N2} = \\text{\"AAAGCCUUGGCAUUU\"}$ 解析为 $(\\mathrm{AAA}, \\mathrm{GCC}, \\mathrm{UUG}, \\mathrm{GCA}, \\mathrm{UUU})$。\n  - 参数：$\\alpha = 1.0$，$\\tau = 0.05$。\n\n- 测试用例2（必需基因中存在强烈的代表性不足）：\n  - 必需基因：\n    - $\\mathrm{E1} = \\text{\"GCUGCCGCAGCGUUC\"}$ 解析为 $(\\mathrm{GCU}, \\mathrm{GCC}, \\mathrm{GCA}, \\mathrm{GCG}, \\mathrm{UUC})$，\n    - $\\mathrm{E2} = \\text{\"GCUGCGUUUUUCGCC\"}$ 解析为 $(\\mathrm{GCU}, \\mathrm{GCG}, \\mathrm{UUU}, \\mathrm{UUC}, \\mathrm{GCC})$。\n  - 非必需基因：\n    - $\\mathrm{N1} = \\text{\"AAAAAGCAAGAAUUA\"}$ 解析为 $(\\mathrm{AAA}, \\mathrm{AAG}, \\mathrm{CAA}, \\mathrm{GAA}, \\mathrm{UUA})$，\n    - $\\mathrm{N2} = \\text{\"UGGUCGUAUUACAGA\"}$ 解析为 $(\\mathrm{UGG}, \\mathrm{UCG}, \\mathrm{UAU}, \\mathrm{UAC}, \\mathrm{AGA})$。\n  - 参数：$\\alpha = 0.5$，$\\tau = 0.01$。\n\n- 测试用例3（两组中近终止密码子计数均为零的边界情况）：\n  - 必需基因：\n    - $\\mathrm{E1} = \\text{\"GCUGCCGCAGCGUUU\"}$ 解析为 $(\\mathrm{GCU}, \\mathrm{GCC}, \\mathrm{GCA}, \\mathrm{GCG}, \\mathrm{UUU})$，\n    - $\\mathrm{E2} = \\text{\"UUCGCUGCCGCAGCG\"}$ 解析为 $(\\mathrm{UUC}, \\mathrm{GCU}, \\mathrm{GCC}, \\mathrm{GCA}, \\mathrm{GCG})$。\n  - 非必需基因：\n    - $\\mathrm{N1} = \\text{\"GCUGCGUUUUUCGCC\"}$ 解析为 $(\\mathrm{GCU}, \\mathrm{GCG}, \\mathrm{UUU}, \\mathrm{UUC}, \\mathrm{GCC})$，\n    - $\\mathrm{N2} = \\text{\"GCAGCUUUCUUUGCG\"}$ 解析为 $(\\mathrm{GCA}, \\mathrm{GCU}, \\mathrm{UUC}, \\mathrm{UUU}, \\mathrm{GCG})$。\n  - 参数：$\\alpha = 1.0$，$\\tau = 0.05$。\n\n最终输出规范：\n- 对于每个测试用例，您的程序必须生成一个三元组 $[\\mathrm{LOR}_\\alpha, p, \\mathrm{underrep}]$，其中 $\\mathrm{LOR}_\\alpha$ 是如上定义的平滑对数优势比，$p$ 是双边Fisher精确检验的$p$值，$\\mathrm{underrep}$ 是一个布尔值，指示必需基因是否表现出统计上显著的代表性不足。将所有浮点输出四舍五入到$6$位小数。\n- 您的程序应生成单行输出，其中包含三个测试用例的结果，格式为一个由方括号括起来的逗号分隔列表，每个测试用例的结果本身也呈现为由方括号括起来的逗号分隔列表。例如：“[[x1,y1,True],[x2,y2,False],[x3,y3,True]]”。\n- 此问题不要求任何物理单位、角度或百分比；所有报告的量均为无量纲的实数或布尔值。",
            "solution": "问题陈述已经过严格验证，被认为是有效的。它在科学上基于分子生物学，在数学上是适定问题，并为所需的算法及其参数提供了完整、明确的规范。因此，我们将着手提供一个完整的解决方案。\n\n问题的核心是量化和检验在一类被称为“近终止”密码子的特定密码子类别中，必需基因相比于非必需基因是否存在代表性不足。该解决方案分四个逻辑阶段执行。\n\n**步骤1：近终止密码子的形式化与识别**\n\n问题将密码子 $c$ 定义为“近终止”，需满足两个条件：\n1.  $c$ 必须是一个有义密码子，即它不属于终止密码子集合 $S = \\{\\mathrm{UAA}, \\mathrm{UAG}, \\mathrm{UGA}\\}$。\n2.  从 $c$ 到其最近的终止密码子的汉明距离必须恰好为 $1$。这形式化地表示为 $\\min_{s \\in S} \\mathrm{Hamming}(c, s) = 1$。两个等长字符串之间的汉明距离是相应位置上符号不同的位置数量。\n\n为实现这一点，我们系统地从字母表 $\\Sigma = \\{\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{U}\\}$ 生成所有 $4^3 = 64$ 个可能的密码子。对于每个密码子 $c$，我们首先检查它是否 $c \\in S$。如果是，则将其丢弃。如果 $c \\notin S$，我们接着计算它与 $S$ 中三个终止密码子中每一个的汉明距离。如果这三个距离中的最小值为 $1$，则该密码子 $c$ 被归类为近终止密码子。\n\n此过程产生以下包含18个近终止密码子的集合，该集合将被预先计算并用于所有后续分析：$\\{\\mathrm{AAA}, \\mathrm{AAG}, \\mathrm{AGA}, \\mathrm{CAA}, \\mathrm{CAG}, \\mathrm{CGA}, \\mathrm{GAA}, \\mathrm{GAG}, \\mathrm{GGA}, \\mathrm{UAC}, \\mathrm{UAU}, \\mathrm{UCA}, \\mathrm{UCG}, \\mathrm{UGC}, \\mathrm{UGU}, \\mathrm{UGG}, \\mathrm{UUA}, \\mathrm{UUG}\\}$。\n\n**步骤2：序列处理与列联表构建**\n\n提供的基因序列是mRNA碱基字符串。该算法按如下方式处理每组基因（必需基因和非必需基因）：\n1.  对于每个基因序列（保证其长度是$3$的倍数），我们将其解析为一个由不重叠、框内的长度为$3$的密码子组成的列表。\n2.  对于每个密码子，我们确定它是否属于预先计算的近终止密码子集合。\n3.  问题陈述指出输入序列不包含终止密码子，因此每个密码子都是有义密码子。一个密码子要么是“近终止”，要么是“非近终止”。\n4.  我们在一个集合（必需基因或非必需基因）内的所有基因中累积计数，以填充一个形式为 $\\begin{pmatrix} a  b \\\\ c  d \\end{pmatrix}$ 的 $2 \\times 2$ 列联表，其中：\n    - $a$：必需基因中近终止密码子的总数。\n    - $b$：必需基因中非近终止有义密码子的总数。\n    - $c$：非必需基因中近终止密码子的总数。\n    - $d$：非必需基因中非近终止有义密码子的总数。\n\n**步骤3：统计分析**\n\n构建列联表后，计算两个统计量。\n\n首先，计算平滑对数优势比（$\\mathrm{LOR}_\\alpha$）以估计效应的大小和方向。该公式使用一个参数为 $\\alpha > 0$ 的拉普拉斯平滑来处理潜在的零计数：\n$$\n\\mathrm{LOR}_\\alpha = \\log\\left(\\frac{a+\\alpha}{b+\\alpha}\\right) - \\log\\left(\\frac{c+\\alpha}{d+\\alpha}\\right)\n$$\n负的 $\\mathrm{LOR}_\\alpha$ 表明，在必需基因集中，一个密码子为近终止密码子的几率低于非必需基因集，这表明存在代表性不足。这里使用自然对数。\n\n其次，对列联表执行双边Fisher精确检验，以评估基因类型（必需 vs. 非必需）与密码子类型（近终止 vs. 非近终止）之间关联的统计显著性。该检验计算一个$p$值，它代表在无关联的原假设下，观测到与所构建的表同样极端或更极端的表的概率。一个小的$p$值提供了反对原假设的证据。\n\n对$p$值的计算规定了一个特殊条件：如果列联表的任何行和（$a+b$或$c+d$）或列和（$a+c$或$b+d$）为零，则$p$值被定义为$1.0$。这处理了某一类别在数据中完全缺失的情况，此时检验变得无意义。\n\n**步骤4：判定代表性不足**\n\n“代表性不足”的最终判定基于两个必须同时满足的标准：\n1.  效应方向必须表明在必需基因中存在代表性不足：$\\mathrm{LOR}_\\alpha < 0$。\n2.  结果必须具有统计显著性：$p$值必须小于指定的显著性阈值 $\\tau$。\n\n如果 $\\mathrm{LOR}_\\alpha < 0$ 和 $p < \\tau$ 同时为真，则结果为 `True`；否则为 `False`。该算法为每个测试用例计算这些值，并按规定格式化输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import fisher_exact\n\ndef solve():\n    \"\"\"\n    Main function to run the analysis for all test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"essential_genes\": [\"AAGGCUAAAGCUUUU\", \"GCCUGGUGGUUCGCA\"],\n            \"nonessential_genes\": [\"CAAGCUUAUGCGUUC\", \"AAAGCCUUGGCAUUU\"],\n            \"alpha\": 1.0,\n            \"tau\": 0.05\n        },\n        {\n            \"essential_genes\": [\"GCUGCCGCAGCGUUC\", \"GCUGCGUUUUUCGCC\"],\n            \"nonessential_genes\": [\"AAAAAGCAAGAAUUA\", \"UGGUCGUAUUACAGA\"],\n            \"alpha\": 0.5,\n            \"tau\": 0.01\n        },\n        {\n            \"essential_genes\": [\"GCUGCCGCAGCGUUU\", \"UUCGCUGCCGCAGCG\"],\n            \"nonessential_genes\": [\"GCUGCGUUUUUCGCC\", \"GCAGCUUUCUUUGCG\"],\n            \"alpha\": 1.0,\n            \"tau\": 0.05\n        }\n    ]\n\n    results = []\n    \n    # Pre-compute the set of near-stop codons once.\n    near_stop_codons = _get_near_stop_codons()\n\n    for case in test_cases:\n        # Extract parameters for the current test case.\n        essential_genes = case[\"essential_genes\"]\n        nonessential_genes = case[\"nonessential_genes\"]\n        alpha = case[\"alpha\"]\n        tau = case[\"tau\"]\n\n        # Step 1: Count codon types in essential genes.\n        a, b = _count_codon_types(essential_genes, near_stop_codons)\n        \n        # Step 2: Count codon types in nonessential genes.\n        c, d = _count_codon_types(nonessential_genes, near_stop_codons)\n        \n        # Step 3: Compute the smoothed log-odds ratio.\n        # LOR = log((a+alpha)/(b+alpha)) - log((c+alpha)/(d+alpha))\n        term_essential = (a + alpha) / (b + alpha)\n        term_nonessential = (c + alpha) / (d + alpha)\n        lor = np.log(term_essential) - np.log(term_nonessential)\n        \n        # Step 4: Compute the two-sided Fisher's exact test p-value.\n        table = np.array([[a, b], [c, d]])\n        \n        # Check for zero row or column sums as per the problem specification.\n        if (a + b == 0) or (c + d == 0) or (a + c == 0) or (b + d == 0):\n            p_value = 1.0\n        else:\n            _, p_value = fisher_exact(table, alternative='two-sided')\n            \n        # Step 5: Determine if there is underrepresentation.\n        # Condition: LOR  0 and p-value  significance threshold tau.\n        is_underrepresented = lor  0 and p_value  tau\n        \n        # Append the formatted result triplet to the list.\n        results.append([lor, p_value, is_underrepresented])\n\n    # Format the final output string as specified.\n    formatted_results = [\n        f\"[{lor:.6f},{p_val:.6f},{str(underrep).lower()}]\" \n        for lor, p_val, underrep in results\n    ]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef _get_near_stop_codons():\n    \"\"\"\n    Generates the set of \"near-stop\" codons based on the problem definition.\n    A codon is near-stop if its Hamming distance to any stop codon is 1\n    and it is not itself a stop codon.\n    \"\"\"\n    bases = ['A', 'C', 'G', 'U']\n    stop_codons = {'UAA', 'UAG', 'UGA'}\n    \n    all_codons = {b1 + b2 + b3 for b1 in bases for b2 in bases for b3 in bases}\n    sense_codons = all_codons - stop_codons\n    \n    near_stop_set = set()\n    for codon in sense_codons:\n        min_dist = 3  # The maximum possible Hamming distance for length 3 strings.\n        for stop_codon in stop_codons:\n            dist = sum(1 for i in range(3) if codon[i] != stop_codon[i])\n            if dist  min_dist:\n                min_dist = dist\n        \n        if min_dist == 1:\n            near_stop_set.add(codon)\n            \n    return near_stop_set\n\ndef _count_codon_types(gene_sequences, near_stop_set):\n    \"\"\"\n    Parses gene sequences into codons and counts near-stop vs. non-near-stop codons.\n    \n    Args:\n        gene_sequences (list[str]): A list of mRNA sequences.\n        near_stop_set (set[str]): The pre-computed set of near-stop codons.\n\n    Returns:\n        tuple[int, int]: A tuple containing (near_stop_count, non_near_stop_count).\n    \"\"\"\n    near_stop_count = 0\n    non_near_stop_count = 0\n    \n    for seq in gene_sequences:\n        # Parse sequence into non-overlapping codons of length 3.\n        for i in range(0, len(seq), 3):\n            codon = seq[i:i+3]\n            \n            # According to problem, input sequences do not contain stop codons.\n            if codon in near_stop_set:\n                near_stop_count += 1\n            else:\n                non_near_stop_count += 1\n                \n    return near_stop_count, non_near_stop_count\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}