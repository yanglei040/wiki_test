{
    "hands_on_practices": [
        {
            "introduction": "遗传密码的简并性意味着一条氨基酸序列可以由多种不同的核酸序列编码。这个练习将带你直面这个被称为“反向翻译”的基本问题，通过一个直接的组合计算来量化给定肽链的编码可能性。掌握这项技能是理解基因合成和进行进化分析的基础。",
            "id": "2800939",
            "problem": "序列设计和注释中的一个核心挑战是从蛋白质到核酸的反向映射，这通常被称为反向翻译问题。仅使用分子生物学中心法则（脱氧核糖核酸 (DNA) 到核糖核酸 (RNA) 到蛋白质）的基本原则、核糖体阅读框的三联体非重叠特性以及经典标准遗传密码，完成以下任务：首先，精确定义反向翻译问题；其次，当只考虑遗传密码的简并性时，计算能够编码一个特定肽的所有不同编码链 DNA 序列集合的确切大小。\n\n使用的假设：\n- 翻译过程以固定的 $5'$ 到 $3'$ 阅读框读取长度为 $3$ 的连续、不重叠的密码子。\n- 标准遗传密码将 $64$ 个密码子映射到 $20$ 种氨基酸和 $3$ 个终止信号；不发生重编码、程序性移码或使用替代遗传密码。\n- 该肽由一个单一的、无内含子的开放阅读框编码；计数中不包括末端终止密码子，并且如果肽的第一个氨基酸是甲硫氨酸，则假定在此处起始翻译。\n- 不同位置的密码子选择是独立的；忽略了密码子使用偏好、mRNA 结构、调控基序及其他限制因素。\n- 标准密码的简并性如下：甲硫氨酸 (M) 和色氨酸 (W) 的简并性为 $1$；苯丙氨酸 (F)、酪氨酸 (Y)、组氨酸 (H)、谷氨酰胺 (Q)、天冬酰胺 (N)、赖氨酸 (K)、天冬氨酸 (D)、谷氨酸 (E) 和半胱氨酸 (C) 的简并性为 $2$；异亮氨酸 (I) 的简并性为 $3$；丙氨酸 (A)、甘氨酸 (G)、脯氨酸 (P)、苏氨酸 (T) 和缬氨酸 (V) 的简并性为 $4$；亮氨酸 (L)、精氨酸 (R) 和丝氨酸 (S) 的简并性为 $6$。\n\n任务：\n1. 基于上述假设，用精确的术语定义反向翻译问题。\n2. 对于长度为 $20$ 的肽序列 $\\text{MWSRLIYNQKDGTACFPVEH}$，计算在给定标准遗传密码简并性下能够编码它的不同 $5' \\to 3'$ 编码链 DNA 序列（长度为 $3 \\times 20$ 个核苷酸，不包括任何终止密码子）的确切数量。请提供无舍入的精确整数作为最终答案。",
            "solution": "所述问题具有科学依据，提法恰当，并包含足够的信息以获得唯一且有意义的解。因此，该问题被认为是有效的。解答按要求分为两部分呈现。\n\n第一部分：反向翻译问题的定义\n\n分子生物学中心法则描述了遗传信息从脱氧核糖核酸 (DNA) 流向核糖核酸 (RNA)，再到蛋白质的过程。翻译过程将信使 RNA (mRNA) 序列转换为肽序列。这一转换由遗传密码决定，遗传密码将密码子（核苷酸三联体）映射到氨基酸。\n\n设 $\\mathcal{A}$ 为 $20$ 种标准氨基酸的集合，$\\mathcal{C}$ 为 $4^3 = 64$ 种可能密码子的集合。遗传密码是一个函数 $g: \\mathcal{C} \\to \\mathcal{A} \\cup \\{\\text{Stop}\\}$，其中 $\\{\\text{Stop}\\}$ 代表三个终止信号的集合。这个函数不是单射的；多个密码子可以映射到同一个氨基酸。这一特性被称为遗传密码的简并性。\n\n对于任意给定的氨基酸 $a \\in \\mathcal{A}$，我们可以将其编码密码子的集合定义为 $C_a = \\{c \\in \\mathcal{C} \\mid g(c) = a\\}$。这个集合的大小 $D(a) = |C_a|$，即为氨基酸 $a$ 的简并度。\n\n反向翻译问题是翻译的逆过程。它旨在确定能够编码给定肽序列的所有可能的核酸序列集合。\n\n形式上，给定一个长度为 $n$ 的肽 $P$，表示为氨基酸序列 $P = p_1 p_2 \\dots p_n$，其中每个 $p_i \\in \\mathcal{A}$，反向翻译问题就是找到所有能够编码 $P$ 的编码链 DNA 序列（或其对应的 mRNA 序列）的集合 $S_{P}$。\n\n在每个氨基酸位置的密码子选择是相互独立的假设下，所有可能的 mRNA 序列的总集合是该肽中每个氨基酸的密码子集合的笛卡尔积：\n$$ S_{mRNA} = C_{p_1} \\times C_{p_2} \\times \\dots \\times C_{p_n} $$\n这些独特的 mRNA 序列的总数 $N_{mRNA}$ 是各个氨基酸简并度的乘积：\n$$ N_{mRNA} = |S_{mRNA}| = \\prod_{i=1}^{n} |C_{p_i}| = \\prod_{i=1}^{n} D(p_i) $$\n由于从 DNA 编码链到 mRNA 的转录是一一对应的（其中胸腺嘧啶 T 被尿嘧啶 U 替换），编码该肽 $P$ 的不同编码链 DNA 序列的数量 $N_{DNA}$ 等于 mRNA 序列的数量。因此，$N_{DNA} = N_{mRNA}$。该问题因此简化为基于标准遗传密码已知简并性的组合计算。\n\n第二部分：对肽 $\\text{MWSRLIYNQKDGTACFPVEH}$ 的计算\n\n指定的肽是 $P = \\text{MWSRLIYNQKDGTACFPVEH}$，长度为 $n=20$ 个氨基酸。问题要求计算能够编码该肽的不同 $5' \\to 3'$ 编码链 DNA 序列的总数，不包括任何终止密码子。\n\n我们根据所提供的数据，确定序列中每个氨基酸的简并度：\n- $D(\\text{M, Met}) = 1$\n- $D(\\text{W, Trp}) = 1$\n- $D(\\text{S, Ser}) = 6$\n- $D(\\text{R, Arg}) = 6$\n- $D(\\text{L, Leu}) = 6$\n- $D(\\text{I, Ile}) = 3$\n- $D(\\text{Y, Tyr}) = 2$\n- $D(\\text{N, Asn}) = 2$\n- $D(\\text{Q, Gln}) = 2$\n- $D(\\text{K, Lys}) = 2$\n- $D(\\text{D, Asp}) = 2$\n- $D(\\text{G, Gly}) = 4$\n- $D(\\text{T, Thr}) = 4$\n- $D(\\text{A, Ala}) = 4$\n- $D(\\text{C, Cys}) = 2$\n- $D(\\text{F, Phe}) = 2$\n- $D(\\text{P, Pro}) = 4$\n- $D(\\text{V, Val}) = 4$\n- $D(\\text{E, Glu}) = 2$\n- $D(\\text{H, His}) = 2$\n\n序列总数 $N$ 是这些简并度值的乘积：\n$$ N = D(\\text{M}) \\times D(\\text{W}) \\times D(\\text{S}) \\times D(\\text{R}) \\times D(\\text{L}) \\times D(\\text{I}) \\times D(\\text{Y}) \\times D(\\text{N}) \\times D(\\text{Q}) \\times D(\\text{K}) \\times D(\\text{D}) \\times D(\\text{G}) \\times D(\\text{T}) \\times D(\\text{A}) \\times D(\\text{C}) \\times D(\\text{F}) \\times D(\\text{P}) \\times D(\\text{V}) \\times D(\\text{E}) \\times D(\\text{H}) $$\n为了简化计算，我们按简并度值对各项进行分组。我们统计肽中每种氨基酸类型的出现次数：\n- 简并度为 $1$：M, W（出现 $2$ 次）\n- 简并度为 $2$：Y, N, Q, K, D, C, F, E, H（出现 $9$ 次）\n- 简并度为 $3$：I（出现 $1$ 次）\n- 简并度为 $4$：G, T, A, P, V（出现 $5$ 次）\n- 简并度为 $6$：S, R, L（出现 $3$ 次）\n\n序列总数是这些简并度值根据其出现频率求幂后的乘积：\n$$ N = (1^2) \\times (2^9) \\times (3^1) \\times (4^5) \\times (6^3) $$\n我们可以使用质因数分解来简化这个表达式：\n$$ N = 1 \\times 2^9 \\times 3^1 \\times (2^2)^5 \\times (2 \\times 3)^3 $$\n$$ N = 2^9 \\times 3^1 \\times 2^{10} \\times 2^3 \\times 3^3 $$\n合并素数底数的幂：\n$$ N = 2^{(9+10+3)} \\times 3^{(1+3)} $$\n$$ N = 2^{22} \\times 3^4 $$\n现在，我们计算最终的整数值：\n$2^{10} = 1024$\n$2^{20} = (2^{10})^2 = 1024^2 = 1048576$\n$2^{22} = 2^{20} \\times 2^2 = 1048576 \\times 4 = 4194304$\n$3^4 = 81$\n最后，我们计算乘积：\n$$ N = 4194304 \\times 81 = 339738624 $$\n这就是能够编码指定肽的编码链 DNA 序列的确切数量。",
            "answer": "$$\n\\boxed{339738624}\n$$"
        },
        {
            "introduction": "除了提供编码多样性，遗传密码的结构还对其稳健性有深远影响。本练习探讨了移码突变（一种常见的基因错误）如何导致提前终止密码子的出现。通过比较标准遗传密码和具有不同终止密码子数量的假想密码，你将运用概率论来评估密码在面对突变时的“脆弱性”。",
            "id": "2384860",
            "problem": "一个编码序列被建模为一个核苷酸流，其中在任何给定的读码框中，密码子在 $64$ 种可能的三联体中是等可能的，并且在不同位置上相互独立。在一个随机位置发生一次单核苷酸插入，产生一次移码，使得翻译从此点开始在移位的读码框中进行。当在移位框中遇到终止密码子时，会发生提前终止。\n\n考虑两种遗传密码：\n- 标准遗传密码 (SGC)，其中 $64$ 种可能的密码子中有 $3$ 种是终止密码子。\n- 假设遗传密码 (HGC)，其中 $64$ 种可能的密码子中有 $6$ 种是终止密码子。\n\n假设氨基酸的同义词（简并密码子）除了通过终止密码子的总数外与终止无关，并且在每种密码中，终止密码子在 $64$ 个三联体中是均匀分布的。在上述独立性和均匀性假设下，分别计算 SGC 和 HGC 中，在移位框中读取的前 $50$ 个密码子（将第一个移位框密码子计为位置 $1$）中出现至少一个提前终止密码子的概率。请用精确的闭式表达式表示您的答案。不要四舍五入。",
            "solution": "对所述问题进行验证。\n\n**第一步：提取已知条件**\n- 可能的密码子总数为 $64$。\n- 密码子是等可能的，并且在不同位置上相互独立。\n- 标准遗传密码 (SGC) 有 $3$ 个终止密码子。\n- 假设遗传密码 (HGC) 有 $6$ 个终止密码子。\n- 终止密码子在 $64$ 个三联体中均匀分布。\n- 任务是计算在移位读码框中，前 $50$ 个密码子中出现至少一个提前终止密码子的概率。\n- 需要分别对 SGC 和 HGC 进行计算。\n- 答案必须是精确的闭式表达式。\n\n**第二步：使用提取的已知条件进行验证**\n- 该问题具有**科学依据**。该模型虽然是一种简化，但基于遗传密码的基本结构（$4$ 种碱基，$3$ 碱基密码子，终止密码子）。SGC 的数字是符合事实的。\n- 该问题是**良构的**。这是一个标准的概率计算问题，所有必要的参数和假设都已明确定义。存在唯一、稳定的解。\n- 该问题是**客观的**。语言精确，没有主观论断。\n\n**第三步：结论与行动**\n该问题是有效的。这是一个定义明确的应用概率练习。将提供解答。\n\n问题要求计算在一个新的读码框中，长度为 $50$ 个密码子的序列里观察到至少一个终止密码子的概率。这是一系列独立的伯努利试验。设“成功”事件为某个密码子是终止密码子。\n\n设 $p$ 为单个密码子是终止密码子的概率。根据题目陈述，所有 $64$ 种可能的密码子都是等可能的。因此，概率 $p$ 是终止密码子数量与密码子总数之比。\n\n对于标准遗传密码 (SGC)，终止密码子的数量为 $N_{stop, SGC} = 3$。密码子总数为 $N_{total} = 4^3 = 64$。\n在 SGC 中，单个密码子是终止密码子的概率为：\n$$p_{SGC} = \\frac{N_{stop, SGC}}{N_{total}} = \\frac{3}{64}$$\n\n对于假设遗传密码 (HGC)，终止密码子的数量为 $N_{stop, HGC} = 6$。\n在 HGC 中，单个密码子是终止密码子的概率为：\n$$p_{HGC} = \\frac{N_{stop, HGC}}{N_{total}} = \\frac{6}{64} = \\frac{3}{32}$$\n\n我们关心的是在 $n=50$ 个密码子的序列中出现至少一个终止密码子的概率。设 $A$ 为在 $n$ 个密码子中找到至少一个终止密码子的事件。计算其互补事件 $A^c$ 的概率更为直接，即在 $n$ 个密码子中*没有*找到终止密码子的事件。\n\n单个密码子*不是*终止密码子的概率是 $(1-p)$。\n对于 SGC，这个概率是：\n$$1 - p_{SGC} = 1 - \\frac{3}{64} = \\frac{61}{64}$$\n对于 HGC，这个概率是：\n$$1 - p_{HGC} = 1 - \\frac{6}{64} = \\frac{58}{64} = \\frac{29}{32}$$\n\n由于密码子在不同位置上是独立的，观察到一串 $n=50$ 个非终止密码子序列的概率是它们各自概率的乘积。\nSGC 的事件 $A^c$ 的概率是：\n$$P(A^c_{SGC}) = (1 - p_{SGC})^n = \\left(\\frac{61}{64}\\right)^{50}$$\nHGC 的事件 $A^c$ 的概率是：\n$$P(A^c_{HGC}) = (1 - p_{HGC})^n = \\left(\\frac{29}{32}\\right)^{50}$$\n\n观察到至少一个终止密码子的概率是 $P(A) = 1 - P(A^c)$。\n对于 SGC，该概率为：\n$$P(A_{SGC}) = 1 - P(A^c_{SGC}) = 1 - \\left(\\frac{61}{64}\\right)^{50}$$\n对于 HGC，该概率为：\n$$P(A_{HGC}) = 1 - P(A^c_{HGC}) = 1 - \\left(\\frac{29}{32}\\right)^{50}$$\n\n题目要求将这两个概率作为最终答案。它们是所要求的精确闭式表达式。",
            "answer": "$$\\boxed{\\begin{pmatrix} 1 - \\left(\\frac{61}{64}\\right)^{50}  1 - \\left(\\frac{29}{32}\\right)^{50} \\end{pmatrix}}$$"
        },
        {
            "introduction": "利用遗传密码的简并性，我们不仅可以分析现有序列，还可以进行创造性的生物工程设计。这个高级练习将挑战你设计一条能在其正向链和反向互补链上编码两种完全不同蛋白质的DNA序列。这个精巧的编码难题深刻地揭示了DNA作为信息存储媒介的巨大潜力，并模仿了自然界中（如病毒中）发现的信息压缩策略。",
            "id": "2384918",
            "problem": "你的任务是编写一个完整、可运行的程序。给定两个等长的氨基酸序列，该程序需要构建一个基于字母表 $\\Sigma = \\{\\text{A}, \\text{C}, \\text{G}, \\text{T}\\}$ 的脱氧核糖核酸 (DNA) 序列。该 DNA 序列需满足以下条件：当沿正向链的 $5^{\\prime} \\rightarrow 3^{\\prime}$ 方向以密码子读取时，得到第一个蛋白质；当沿反向互补链的 $5^{\\prime} \\rightarrow 3^{\\prime}$ 方向读取时，得到第二个不同的蛋白质。此构建过程必须利用遗传密码的简并性。如果根据以下约束条件，这样的 DNA 序列不存在，你的程序必须为该测试用例指出“不可能”。\n\n使用的基本原理和约束条件：\n- 分子生物学中心法则指出，信息从 DNA 流向核糖核酸 (RNA)，再到蛋白质。翻译过程将每个密码子（三个核苷酸组成的三联体）映射到一个氨基酸；标准核遗传密码是一个经过充分验证的从密码子到氨基酸的映射。\n- Watson–Crick 碱基配对定义了核苷酸上的互补函数：$\\text{A}\\leftrightarrow \\text{T}$ 和 $\\text{C}\\leftrightarrow \\text{G}$。一个 DNA 字符串的反向互补序列是通过反转该字符串并用其互补碱基替换每个核苷酸得到的。\n- 设 $\\mathcal{A}$ 表示 $20$ 种标准氨基酸的集合，每种氨基酸由其标准的单字母代码表示（例如，$\\text{A}$ 代表丙氨酸，$\\text{R}$ 代表精氨酸，…，$\\text{W}$ 代表色氨酸，$\\text{Y}$ 代表酪氨酸，$\\text{M}$ 代表甲硫氨酸等）。终止密码子不属于 $\\mathcal{A}$，且不得出现在编码序列内部。\n- 设 $g : \\Sigma^3 \\rightarrow \\mathcal{A}\\cup\\{\\text{Stop}\\}$ 为从密码子到氨基酸（或终止子）的标准核遗传密码映射。请使用标准遗传密码（也称为 NCBI 翻译表 $1$），其中的三个终止密码子是 $\\text{TAA}$、$\\text{TAG}$ 和 $\\text{TGA}$。\n- 设 $\\mathrm{RC} : \\Sigma^3 \\rightarrow \\Sigma^3$ 表示作用于密码子上的反向互补算子，其定义为反转密码子并根据 Watson–Crick 配对原则对每个核苷酸进行互补。\n\n形式化问题：\n- 给定两个等长的氨基酸序列 $S_f$ 和 $S_r$，其长度为 $L \\geq 1$，其中对于所有索引 $i \\in \\{0,1,\\dots,L-1\\}$，都有 $S_f[i] \\in \\mathcal{A}$ 和 $S_r[i] \\in \\mathcal{A}$。\n- 你必须确定一个 DNA 序列 $D \\in \\Sigma^{3L}$，该序列可划分为连续的密码子 $(c_0,c_1,\\dots,c_{L-1})$，其中 $c_i \\in \\Sigma^3$，并满足以下条件：\n  1. 对于所有 $i \\in \\{0,1,\\dots,L-1\\}$，满足 $g(c_i) = S_f[i]$，且\n  2. 对于所有 $i \\in \\{0,1,\\dots,L-1\\}$，满足 $g(\\mathrm{RC}(c_i)) = S_r[L-1-i]$。\n- 如果存在多个有效的 $D$，你必须选择唯一的 $D$，该 $D$ 是通过在每个位置 $i$ 选择字典序最小的密码子 $c_i$ 获得的（其中 $\\Sigma$ 上的字典序定义为 $\\text{A}  \\text{C}  \\text{G}  \\text{T}$，并以标准方式扩展到 $\\Sigma^3$）。如果存在解，这种对每个位置的选择将产生一个唯一的确定性 $D$。\n- 如果不存在这样的 $D$，你必须为该测试用例输出一个如下文指定的显式空结果。\n- 如果给定的两个序列长度不同，根据定义，解不存在。\n\n输出编码：\n- 对于每个测试用例，你必须将整个 DNA 序列 $D$ 输出为一个整数列表。核苷酸的编码映射为 $\\text{A}\\mapsto 0$, $\\text{C}\\mapsto 1$, $\\text{G}\\mapsto 2$, $\\text{T}\\mapsto 3$，并按顺序列出 $3L$ 个整数。如果无解，则为该测试用例输出空列表 $[\\ ]$。\n- 你的程序必须生成单行输出，其中包含所有测试用例结果的聚合，形式为列表的列表，不含任何空格，例如 $[[0,1,2],[\\ ],[2,2,3]]$。\n\n测试套件：\n你的程序必须硬编码并精确解决以下测试用例。每个测试用例都是一对 $(S_f,S_r)$：\n- 用例 $1$ (正常路径): $S_f=\\text{\"MALG\"}$, $S_r=\\text{\"TQGH\"}$。\n- 用例 $2$ (不可能的单密码子): $S_f=\\text{\"W\"}$, $S_r=\\text{\"A\"}$。\n- 用例 $3$ (可行的单密码子): $S_f=\\text{\"M\"}$, $S_r=\\text{\"H\"}$。\n- 用例 $4$ (长度不匹配): $S_f=\\text{\"ACD\"}$, $S_r=\\text{\"GG\"}$。\n- 用例 $5$ (奇数长度可行): $S_f=\\text{\"AKR\"}$, $S_r=\\text{\"TFS\"}$。\n\n最终输出格式：\n- 你的程序必须打印单行输出，其中包含一个有 $5$ 个元素的列表，每个元素对应一个测试用例。对于无解的用例，元素为空列表 $[\\ ]$；对于有解的用例，元素是代表 DNA 序列的 $3L$ 个整数的列表，使用核苷酸到整数的编码 $\\text{A}\\mapsto 0$, $\\text{C}\\mapsto 1$, $\\text{G}\\mapsto 2$, $\\text{T}\\mapsto 3$。打印的行中不得有任何空格。",
            "solution": "我们从第一性原理出发，利用中心法则和 Watson–Crick 互补性，推导出一个构造性算法，该算法通过密码子映射和反向互补运算进行形式化。\n\n定义：\n- 设 $\\Sigma=\\{\\text{A},\\text{C},\\text{G},\\text{T}\\}$，$\\mathcal{A}$ 为 $20$ 种标准氨基酸的集合。\n- 设 $g:\\Sigma^3\\to \\mathcal{A}\\cup\\{\\text{Stop}\\}$ 为标准遗传密码映射，其中终止密码子为 $\\text{TAA}$、$\\text{TAG}$、$\\text{TGA}$。\n- 设 $\\mathrm{comp}:\\Sigma\\to\\Sigma$ 为互补函数，$\\mathrm{comp}(\\text{A})=\\text{T}$，$\\mathrm{comp}(\\text{T})=\\text{A}$，$\\mathrm{comp}(\\text{C})=\\text{G}$，$\\mathrm{comp}(\\text{G})=\\text{C}$，并通过逐字符应用扩展到字符串。\n- 设 $\\mathrm{RC}:\\Sigma^k\\to \\Sigma^k$ 为反向互补函数，定义为 $\\mathrm{RC}(x_0x_1\\cdots x_{k-1})=\\mathrm{comp}(x_{k-1})\\cdots \\mathrm{comp}(x_1)\\mathrm{comp}(x_0)$。一个基本性质是，对于 $\\Sigma$ 上的任意字符串 $x, y$，有 $\\mathrm{RC}(xy)=\\mathrm{RC}(y)\\mathrm{RC}(x)$。\n\n给定两个等长的氨基酸序列 $S_f$ 和 $S_r$，长度为 $L$（若长度不同则无解）。我们寻求一个 DNA 序列 $D=c_0c_1\\cdots c_{L-1}$，其中 $c_i\\in\\Sigma^3$，满足：\n- 对所有索引 $i\\in\\{0,\\dots,L-1\\}$，有 $g(c_i)=S_f[i]$。\n- 在读码框 0 中读取反向互补链得到 $S_r$。由于性质 $\\mathrm{RC}(xy)=\\mathrm{RC}(y)\\mathrm{RC}(x)$，密码子串联的反向互补等于每个密码子反向互补后的反序串联。因此，如果我们定义 $d_i=\\mathrm{RC}(c_i)$，那么反向互补链上位置 $j$（从 $5^{\\prime}$ 端起从 0 开始计数）的密码子是 $d_{L-1-j}$。为了使反向链翻译为 $S_r$，必须对所有 $j$ 满足 $g(d_{L-1-j})=S_r[j]$，这等价于对所有 $i$ 满足 $g(\\mathrm{RC}(c_i))=S_r[L-1-i]$。\n\n关键在于，这种分解显示了位置间的独立性：每个正向密码子 $c_i$ 只影响反向链上对应的反转位置，当两条链都在读码框 0 中读取时，不存在跨密码子的约束。因此，全局约束简化为 $L$ 个独立的局部约束。对于每个 $i\\in\\{0,\\dots,L-1\\}$，我们必须选择一个 $c_i\\in\\Sigma^3$ 来满足配对条件 $g(c_i)=S_f[i]$ 和 $g(\\mathrm{RC}(c_i))=S_r[L-1-i]$。如果任何位置 $i$ 不存在这样的 $c_i$，则解不存在；否则，由于 $\\mathrm{RC}$ 运算如前述可在串联上分配，对每个位置的任何选择都能产生一个有效的全局解。\n\n为利用简并性，我们为任意氨基酸 $a\\in\\mathcal{A}$ 计算其同义密码子集合：\n$$\n\\mathrm{Codons}(a)=\\{c\\in\\Sigma^3 \\mid g(c)=a\\}.\n$$\n对于每个位置 $i$，我们构建可行的正向密码子集合\n$$\n\\mathcal{C}_i=\\{c\\in \\mathrm{Codons}(S_f[i]) \\mid \\mathrm{RC}(c)\\in \\mathrm{Codons}(S_r[L-1-i])\\}.\n$$\n如果对于任何 $i$，有 $\\mathcal{C}_i=\\varnothing$，则返回不可能。否则，为保证确定性，我们应用字典序平局打破规则。在 $\\Sigma$ 上定义序关系 $\\text{A}\\text{C}\\text{G}\\text{T}$，并以标准字典序比较方式扩展到 $\\Sigma^3$。选择\n$$\nc_i=\\min\\nolimits_{\\text{lex}} \\mathcal{C}_i.\n$$\n将这些 $c_i$ 串联起来，得到唯一的确定性解 $D=c_0c_1\\cdots c_{L-1}$。\n\n正确性论证：\n- 合理性：根据构造，对于所有 $i$ 都有 $g(c_i)=S_f[i]$ 和 $g(\\mathrm{RC}(c_i))=S_r[L-1-i]$。因此，在读码框 0 中，$D$ 在正向链上翻译为 $S_f$，而 $\\mathrm{RC}(D)$ 在反向链上翻译为 $S_r$。\n- 完备性：如果存在任何满足约束的 $D^{\\star}$，那么对于每个 $i$，其密码子 $c_i^{\\star}$ 必须属于 $\\mathcal{C}_i$。因此，对所有 $i$ 都有 $\\mathcal{C}_i\\neq\\varnothing$。我们的算法选择了某个 $c_i\\in\\mathcal{C}_i$，从而构造了一个有效的 $D$。确定性源于每个位置的字典序最小化。\n\n复杂度：\n- 预处理阶段为所有 $a\\in\\mathcal{A}$ 构建 $\\mathrm{Codons}(a)$，使用常数大小的表，时间复杂度为 $O(1)$。\n- 对每个测试用例，对于每个位置 $i$，我们最多扫描 $6$ 个密码子（针对高度简并的氨基酸，如亮氨酸、丝氨酸、精氨酸）。因此，时间复杂度为 $O(L)$，常数因子很小；空间复杂度为 $O(L)$，用于存储结果。\n\n输出编码：\n- 通过映射 $\\text{A}\\mapsto 0$, $\\text{C}\\mapsto 1$, $\\text{G}\\mapsto 2$, $\\text{T}\\mapsto 3$ 对核苷酸进行编码。将 $D$ 编码为一个按顺序列出的包含 $3L$ 个整数的列表。若无解，则输出空列表。将 $5$ 个必需测试用例的输出聚合为一个不含空格的方括号列表。\n\n在测试套件上的应用：\n- 用例 1，$S_f=\\text{\"MALG\"}$, $S_r=\\text{\"TQGH\"}$，是可行的；通过对每个位置进行字典序选择，可以获得一个有效的确定性解 $D$。\n- 用例 2，$S_f=\\text{\"W\"}$, $S_r=\\text{\"A\"}$，是不可能的，因为唯一的色氨酸密码子 $\\text{TGG}$ 的反向互补是 $\\text{CCA}$（脯氨酸），而它不编码丙氨酸。\n- 用例 3，$S_f=\\text{\"M\"}$, $S_r=\\text{\"H\"}$，是可行的，因为 $\\text{ATG}$ 的反向互补是 $\\text{CAT}$（组氨酸）。\n- 用例 4 长度不匹配，因此立即判定为不可能。\n- 用例 5，$S_f=\\text{\"AKR\"}$, $S_r=\\text{\"TFS\"}$，通过适当的密码子选择是可行的，解由约束下的字典序最小化唯一确定。\n\n随附的程序实现了该算法，包含了标准遗传密码，构建了可行的密码子集合，强制执行字典序规则，将结果转换为指定的整数编码，并以单行无空格的形式打印五个测试用例的输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Mapping for nucleotide complements (Watson–Crick base pairing)\nCOMP = {'A': 'T', 'T': 'A', 'C': 'G', 'G': 'C'}\n\n# Standard Genetic Code (NCBI Translation Table 1): DNA codons to amino acids (one-letter code)\nCODON_TO_AA = {\n    # Phenylalanine, Leucine\n    'TTT': 'F', 'TTC': 'F', 'TTA': 'L', 'TTG': 'L',\n    # Serine, Proline, Threonine, Alanine\n    'TCT': 'S', 'TCC': 'S', 'TCA': 'S', 'TCG': 'S',\n    'CCT': 'P', 'CCC': 'P', 'CCA': 'P', 'CCG': 'P',\n    'ACT': 'T', 'ACC': 'T', 'ACA': 'T', 'ACG': 'T',\n    'GCT': 'A', 'GCC': 'A', 'GCA': 'A', 'GCG': 'A',\n    # Tyrosine, Histidine, Glutamine, Asparagine, Lysine, Aspartic acid, Glutamic acid, Cysteine, Tryptophan\n    'TAT': 'Y', 'TAC': 'Y', 'TAA': 'Stop', 'TAG': 'Stop',\n    'CAT': 'H', 'CAC': 'H', 'CAA': 'Q', 'CAG': 'Q',\n    'AAT': 'N', 'AAC': 'N', 'AAA': 'K', 'AAG': 'K',\n    'GAT': 'D', 'GAC': 'D', 'GAA': 'E', 'GAG': 'E',\n    'TGT': 'C', 'TGC': 'C', 'TGA': 'Stop', 'TGG': 'W',\n    # Leucine, Arginine, Isoleucine, Methionine, Valine, Serine, Arginine, Glycine\n    'CTT': 'L', 'CTC': 'L', 'CTA': 'L', 'CTG': 'L',\n    'CGT': 'R', 'CGC': 'R', 'CGA': 'R', 'CGG': 'R',\n    'ATT': 'I', 'ATC': 'I', 'ATA': 'I', 'ATG': 'M',\n    'GTT': 'V', 'GTC': 'V', 'GTA': 'V', 'GTG': 'V',\n    'AGT': 'S', 'AGC': 'S', 'AGA': 'R', 'AGG': 'R',\n    'GGT': 'G', 'GGC': 'G', 'GGA': 'G', 'GGG': 'G',\n}\n\n# Build amino acid to codons mapping (excluding Stops)\nAA_TO_CODONS = {}\nfor codon, aa in CODON_TO_AA.items():\n    if aa == 'Stop':\n        continue\n    AA_TO_CODONS.setdefault(aa, []).append(codon)\n\n# Define nucleotide order for lexicographic sorting: A  C  G  T\nNUC_ORDER = {'A': 0, 'C': 1, 'G': 2, 'T': 3}\n\ndef lex_key(codon: str):\n    return (NUC_ORDER[codon[0]], NUC_ORDER[codon[1]], NUC_ORDER[codon[2]])\n\n# Sort codon lists for deterministic lexicographic selection\nfor aa in AA_TO_CODONS:\n    AA_TO_CODONS[aa].sort(key=lex_key)\n\ndef reverse_complement(codon: str) -> str:\n    # Reverse the codon and complement each nucleotide\n    return ''.join(COMP[n] for n in reversed(codon))\n\ndef dna_to_ints(dna: str):\n    # Map nucleotides to integers A->0, C->1, G->2, T->3\n    mapping = {'A': 0, 'C': 1, 'G': 2, 'T': 3}\n    return [mapping[n] for n in dna]\n\ndef find_dual_encoding_dna(Sf: str, Sr: str):\n    # If lengths differ, impossible\n    if len(Sf) != len(Sr):\n        return []\n    L = len(Sf)\n    codons_forward = []\n\n    for i in range(L):\n        a_f = Sf[i]\n        a_r = Sr[L - 1 - i]\n        # Validate amino acids\n        if a_f not in AA_TO_CODONS or a_r not in AA_TO_CODONS:\n            return []\n        feasible = None\n        for codon in AA_TO_CODONS[a_f]:\n            rc = reverse_complement(codon)\n            # Ensure reverse complement codon encodes the required reverse amino acid\n            if rc in AA_TO_CODONS[a_r]:\n                feasible = codon\n                break  # lexicographically smallest due to prior sorting\n        if feasible is None:\n            return []\n        codons_forward.append(feasible)\n\n    dna = ''.join(codons_forward)\n    return dna_to_ints(dna)\n\ndef format_result_list(list_of_lists):\n    # Format as a single-line string with no spaces, nested lists\n    def format_one(lst):\n        return '[' + ','.join(str(x) for x in lst) + ']'\n    return '[' + ','.join(format_one(lst) for lst in list_of_lists) + ']'\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\"MALG\", \"TQGH\"),  # Case 1\n        (\"W\", \"A\"),        # Case 2\n        (\"M\", \"H\"),        # Case 3\n        (\"ACD\", \"GG\"),     # Case 4\n        (\"AKR\", \"TFS\"),    # Case 5\n    ]\n\n    results = []\n    for Sf, Sr in test_cases:\n        res = find_dual_encoding_dna(Sf, Sr)\n        results.append(res)\n\n    # Final print statement in the exact required format: single line, no spaces.\n    print(format_result_list(results))\n\nsolve()\n```"
        }
    ]
}