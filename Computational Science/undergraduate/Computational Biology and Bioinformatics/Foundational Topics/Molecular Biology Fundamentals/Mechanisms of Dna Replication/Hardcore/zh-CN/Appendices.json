{
    "hands_on_practices": [
        {
            "introduction": "经典的 Meselson-Stahl 实验通过巧妙的设计证实了DNA的半保留复制机制。本练习将带你重温这一思想实验，通过数学推导来追踪在多代（包括非整数代）生长后不同类型DNA分子的比例。这不仅能加深你对半保留复制和指数增长模型的理解，还能锻炼你将生物学原理转化为定量模型的核心能力 。",
            "id": "2792765",
            "problem": "将大肠杆菌（Escherichia coli）在含有重氮$^{15}\\mathrm{N}$的培养基中培养多代，使得每个基因组脱氧核糖核酸（DNA）双链最初都由两条$^{15}\\mathrm{N}$标记的链组成。在时间$t=0$时，将该菌群突然转移到只含有轻氮$^{14}\\mathrm{N}$的培养基中。假设以下基本条件：(i) DNA半保留复制，即每个子代双链精确地继承一条亲代链；(ii) 转移后没有$^{15}\\mathrm{N}$的掺入（所有新合成的链都是$^{14}\\mathrm{N}$）；(iii) 通过二分裂进行指数增长，使得经过$g$代后，完整的DNA双链总数按$2^{g}$的比例增长；(iv) 没有细胞死亡；(v) 在取样时所有活跃的复制叉都被允许完成复制，以便测量时的每个DNA分子都是一个完整的双链。然后通过氯化铯（CsCl）密度梯度离心法对DNA进行分析，该方法根据浮力密度将DNA分离为混合型$^{15}\\mathrm{N}/^{14}\\mathrm{N}$和轻型$^{14}\\mathrm{N}/^{14}\\mathrm{N}$条带。感光条带的强度与在该密度下成带的DNA总质量成正比；由于所有基因组的长度相等，强度与该密度的双链分子数量成正比。\n\n仅使用所述的基本条件，从第一性原理推导出当培养物在$^{14}\\mathrm{N}$培养基中生长了$2.5$代后，混合型和轻型DNA条带的归一化相对强度（总和为$1$的无量纲分数）。将最终答案表示为一个行矩阵$\\begin{pmatrix}I_{\\mathrm{hybrid}} & I_{\\mathrm{light}}\\end{pmatrix}$，其中包含精确值（矩阵内不进行四舍五入，也不含单位）。",
            "solution": "所提出的问题是分子遗传学中的一个经典练习，著名地模拟了Meselson-Stahl实验，其有效性必须首先得到严格的证实。\n\n**问题验证**\n\n逐字提取已知条件：\n1.  初始状态：在$^{15}\\mathrm{N}$培养基中生长的大肠杆菌（*Escherichia coli*）培养物；所有基因组DNA均为$^{15}\\mathrm{N}$/$^{15}\\mathrm{N}$。\n2.  实验转移：在$t=0$时，将培养物移至$^{14}\\mathrm{N}$培养基中。\n3.  基本条件(i)：DNA复制是半保留的。\n4.  基本条件(ii)：所有新合成的链都是$^{14}\\mathrm{N}$。\n5.  基本条件(iii)：经过$g$代后，完整的DNA双链总数按$2^g$的比例增长。\n6.  基本条件(iv)：没有细胞死亡。\n7.  基本条件(v)：在分析前，所有活跃的复制叉都已完成复制，确保测量对象是完整的双链。\n8.  分析：氯化铯（CsCl）密度梯度离心法将DNA分离为混合型（$^{15}\\mathrm{N}/^{14}\\mathrm{N}$）和轻型（$^{14}\\mathrm{N}/^{14}\\mathrm{N}$）条带。\n9.  强度规则：条带强度与该密度的DNA双链分子数量成正比。\n10. 目标：推导出$g=2.5$代后混合型和轻型条带的归一化相对强度。\n\n验证结果：\n该问题具有科学依据，基于证实了DNA半保留复制模型的经典Meselson-Stahl实验。所有基本条件都是分子生物学和群体动力学的标准原理。该问题提法明确；初始条件和演化规则都已明确说明。包含非整数代数$g=2.5$，并结合双链总数为$N_0 2^g$的公理，正确地在宏观层面上模拟了一个非同步、指数增长的群体。至关重要的是，基本条件(v)提供了一个必要的理想化，使我们能够对离散、完整的分子进行推理，而无需分析包含部分复制DNA的群体的复杂性。该问题避免了歧义，可以进行数学形式化，并且考验的是基本理解而非琐碎知识。因此，该问题被认为是有效的。\n\n**求解推导**\n\n设$N_0$为第$g=0$代时大肠杆菌（*E. coli*）细胞的初始数量，因此也是DNA双链的初始数量。根据初始条件，所有这些双链都是重/重型，我们表示为$^{15}\\mathrm{N}/^{15}\\mathrm{N}$。DNA单链的总数是$2N_0$，并且都用$^{15}\\mathrm{N}$标记。根据半保留复制机制，这些原始链在整个实验过程中都是保守的。\n\n在$g=0$时，培养基更换为只含$^{14}\\mathrm{N}$的培养基。根据基本条件(ii)，任何新合成的链都将是轻链（$^{14}\\mathrm{N}$）。\n\n此分析的基石是最初的$2N_0$条重链的去向。基本条件(i)指出复制是半保留的，意味着这些链作为模板，并且永不降解（基本条件(iv)，无细胞死亡，加强了这一点）。基本条件(v)保证在测量点，每个分子都是一个完整的双链。由此逻辑上可以得出，最初的$2N_0$条重链（$^{15}\\mathrm{N}$）中的每一条都必须存在于一个完整的DNA双链中。经过第一轮复制后，任何原始的$^{15}\\mathrm{N}$链都必须与一条新合成的$^{14}\\mathrm{N}$链配对，形成一个混合型（$^{15}\\mathrm{N}/^{14}\\mathrm{N}$）双链。由于没有新的$^{15}\\mathrm{N}$可用，不可能形成新的$^{15}\\mathrm{N}/^{15}\\mathrm{N}$双链，$^{15}\\mathrm{N}$链也不可能丢失。因此，对于任何代数$g \\ge 1$，混合型双链的数量$N_{\\mathrm{hybrid}}(g)$必须精确等于原始模板链的数量。\n$$N_{\\mathrm{hybrid}}(g) = 2N_0 \\quad (\\text{for } g \\ge 1)$$\n\n接下来，我们考虑群体中DNA双链的总数。基本条件(iii)明确给出了指数增长培养物的控制方程：\n$$N_{\\mathrm{total}}(g) = N_0 2^g$$\n这个方程对任何非负实数$g$都有效。\n\n对于任何代数$g \\ge 1$，双链群体由两种类型组成：混合型（$^{15}\\mathrm{N}/^{14}\\mathrm{N}$）和轻型（$^{14}\\mathrm{N}/^{14}\\mathrm{N}$）。双链的总数是这两种类型数量的总和：\n$$N_{\\mathrm{total}}(g) = N_{\\mathrm{hybrid}}(g) + N_{\\mathrm{light}}(g)$$\n我们现在可以通过代入法推导出轻型双链数量$N_{\\mathrm{light}}(g)$的表达式：\n$$N_{\\mathrm{light}}(g) = N_{\\mathrm{total}}(g) - N_{\\mathrm{hybrid}}(g) = N_0 2^g - 2N_0 = N_0 (2^g - 2) \\quad (\\text{for } g \\ge 1)$$\n\n问题要求的是系统在$g=2.5$时的状态。我们应用上面推导出的公式。\n在$g=2.5$时，混合型双链的数量是：\n$$N_{\\mathrm{hybrid}}(2.5) = 2N_0$$\n在$g=2.5$时，双链的总数是：\n$$N_{\\mathrm{total}}(2.5) = N_0 2^{2.5} = N_0 2^{5/2} = N_0 \\sqrt{2^5} = N_0 \\sqrt{32} = N_0 \\sqrt{16 \\times 2} = 4\\sqrt{2} N_0$$\n在$g=2.5$时，轻型双链的数量是：\n$$N_{\\mathrm{light}}(2.5) = N_0 (2^{2.5} - 2) = N_0 (4\\sqrt{2} - 2)$$\n\n每个条带的归一化相对强度与该条带中的分子数量除以分子总数成正比。设$I_{\\mathrm{hybrid}}$和$I_{\\mathrm{light}}$为归一化强度。\n\n对于混合型条带：\n$$I_{\\mathrm{hybrid}} = \\frac{N_{\\mathrm{hybrid}}(2.5)}{N_{\\mathrm{total}}(2.5)} = \\frac{2N_0}{4\\sqrt{2} N_0} = \\frac{2}{4\\sqrt{2}} = \\frac{1}{2\\sqrt{2}}$$\n为了使分母有理化，我们将分子和分母同乘以$\\sqrt{2}$：\n$$I_{\\mathrm{hybrid}} = \\frac{1 \\times \\sqrt{2}}{2\\sqrt{2} \\times \\sqrt{2}} = \\frac{\\sqrt{2}}{2 \\times 2} = \\frac{\\sqrt{2}}{4}$$\n\n对于轻型条带：\n$$I_{\\mathrm{light}} = \\frac{N_{\\mathrm{light}}(2.5)}{N_{\\mathrm{total}}(2.5)} = \\frac{N_0(4\\sqrt{2} - 2)}{4\\sqrt{2} N_0} = \\frac{4\\sqrt{2} - 2}{4\\sqrt{2}} = 1 - \\frac{2}{4\\sqrt{2}} = 1 - \\frac{1}{2\\sqrt{2}}$$\n使用混合型计算中的有理化形式：\n$$I_{\\mathrm{light}} = 1 - \\frac{\\sqrt{2}}{4} = \\frac{4 - \\sqrt{2}}{4}$$\n\n作为验证，归一化强度的总和必须为$1$：\n$$I_{\\mathrm{hybrid}} + I_{\\mathrm{light}} = \\frac{\\sqrt{2}}{4} + \\frac{4 - \\sqrt{2}}{4} = \\frac{\\sqrt{2} + 4 - \\sqrt{2}}{4} = \\frac{4}{4} = 1$$\n推导是一致的。最终强度按要求表示为精确分数。\n\n结果需表示为一个行矩阵$\\begin{pmatrix} I_{\\mathrm{hybrid}} & I_{\\mathrm{light}} \\end{pmatrix}$。\n代入推导出的值即可得到最终答案。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{\\sqrt{2}}{4} & \\frac{4-\\sqrt{2}}{4}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "DNA复制不仅要进行，更要精确地进行，以维持遗传信息的稳定。细胞进化出了一套包括聚合酶筛选、即时校对和错配修复在内的多层次保真机制。本练习要求你构建一个概率模型，来量化这些机制对最终突变率的贡献，特别是评估校对功能减弱带来的影响 。通过这个练习，你将学会如何用数学语言描述和分析复杂的生物保真系统。",
            "id": "2403484",
            "problem": "一个细胞使用高保真度的复制性脱氧核糖核酸（DNA）聚合酶来复制其DNA。该聚合酶在掺入核苷酸时，每个掺入的核苷酸发生错误掺入的基线概率为 $r_{0}$（每个碱基每次复制）。该聚合酶具有 $3^{\\prime}\\!\\to\\!5^{\\prime}$ 外切酶活性校对功能，当发生错误掺入时，它会在延伸之前以概率 $p$ 对其进行校正。复制后的错配修复（MMR）系统会以概率 $q$ 校正任何逃脱了校对的剩余错配。假设错误掺入事件在不同位点上是罕见且独立的，并且校对和MMR对同一个错误顺序起作用（一个错配必须首先逃脱校对才能被MMR系统识别），所述概率在每个阶段独立应用，且以其前一阶段的失败为条件。\n\n考虑一个单倍体基因组，其每次完整基因组复制的核苷酸掺入数量为 $L$。一个假设的突变使聚合酶的校对效率降低了 $x$ 个百分点，这意味着新的校对校正概率变为 $(1 - \\frac{x}{100})\\,p$，而 $r_{0}$、$q$ 和 $L$ 保持不变。\n\n请推导一个单一的闭式解析表达式，用于表示仅因校对效率降低而导致的、每个基因组每次细胞分裂中复制引起的点突变期望数的增量 $\\Delta M(x)$，该表达式用 $L$、$r_{0}$、$p$、$q$ 和 $x$ 表示。将最终答案表示为解析表达式；不要进行数值计算，也不要在表达式中包含单位。答案应代表每个基因组每次细胞分裂预期增加的突变数量。",
            "solution": "对问题陈述进行验证。\n\n逐字提取给定条件：\n- 每个核苷酸错误掺入的基线概率：$r_{0}$\n- 校对校正的概率：$p$\n- 错配修复 (MMR) 校正的概率：$q$\n- 每次完整基因组复制的核苷酸掺入数量：$L$\n- 校对效率降低的百分比：$x$\n- 新的校对校正概率：$(1 - \\frac{x}{100})p$\n- 假设：错误掺入事件罕见且独立；校对和MMR顺序、独立地起作用。\n- 目标：推导每个基因组每次细胞分裂中复制引起的点突变期望数的增量 $\\Delta M(x)$。\n\n使用提取的给定条件进行验证：\n该问题具有科学依据，基于已确立的DNA复制保真度的分子机制——聚合酶错误、外切酶活性校对和错配修复。所提出的概率模型是计算生物学和群体遗传学中使用的标准、有效的简化模型。该问题是适定的，提供了推导唯一解析解所需的所有参数和假设。语言客观、精确。设定是自洽的，没有矛盾。该场景是对突变表型的一个假设但生物学上合理的表述。因此，该问题被认定为有效。\n\n求解过程如下。\n\n设 $R$ 为单个核苷酸掺入事件导致永久性、固定突变的概率。要使一个突变被固定下来，必须发生一系列失败：聚合酶的初始错误掺入、即时校对机制的失败，以及随后的错配修复系统的失败。\n\n首先，我们定义在基线条件下每个位点发生突变的概率，记为 $R_{baseline}$。\n一个错误以概率 $r_{0}$ 被引入。\n该错误以概率 $(1 - p)$ 逃脱 $3^{\\prime}\\!\\to\\!5^{\\prime}$ 外切酶活性校对机制。\n在逃脱校对的情况下，产生的错配以概率 $(1 - q)$ 逃脱复制后MMR系统。\n由于这些顺序事件是相互独立的，每个位点发生突变的总概率是这些概率的乘积：\n$$R_{baseline} = r_{0} (1 - p) (1 - q)$$\n\n每个基因组每次复制的期望突变数 $M$ 是复制位点数（核苷酸掺入数）$L$ 与每个位点的突变概率 $R$ 的乘积。这是 $L$ 次独立伯努利试验之和的期望值。\n因此，基线条件下每个基因组的期望突变数为：\n$$M_{baseline} = L \\cdot R_{baseline} = L r_{0} (1 - p) (1 - q)$$\n\n接下来，我们分析校对功能受损的情况。新的校对校正概率 $p_{new}$ 在其原始值 $p$ 的基础上降低了 $x$ 个百分点：\n$$p_{new} = p \\left(1 - \\frac{x}{100}\\right)$$\n因此，新的校对*失败*概率是：\n$$1 - p_{new} = 1 - p \\left(1 - \\frac{x}{100}\\right)$$\n参数 $r_{0}$、$q$ 和 $L$ 保持不变。每个位点新的突变概率 $R_{new}(x)$ 由下式给出：\n$$R_{new}(x) = r_{0} (1 - p_{new}) (1 - q) = r_{0} \\left[1 - p \\left(1 - \\frac{x}{100}\\right)\\right] (1 - q)$$\n每个基因组新的期望突变数 $M_{new}(x)$ 为：\n$$M_{new}(x) = L \\cdot R_{new}(x) = L r_{0} \\left[1 - p \\left(1 - \\frac{x}{100}\\right)\\right] (1 - q)$$\n\n问题要求推导期望突变数的*增量* $\\Delta M(x)$，即新的期望值与基线期望值之差：\n$$\\Delta M(x) = M_{new}(x) - M_{baseline}$$\n代入上面推导出的表达式：\n$$\\Delta M(x) = \\left( L r_{0} \\left[1 - p \\left(1 - \\frac{x}{100}\\right)\\right] (1 - q) \\right) - \\left( L r_{0} (1 - p) (1 - q) \\right)$$\n我们可以提出公因式 $L r_{0} (1 - q)$：\n$$\\Delta M(x) = L r_{0} (1 - q) \\left[ \\left(1 - p \\left(1 - \\frac{x}{100}\\right)\\right) - (1 - p) \\right]$$\n现在，我们简化方括号内的表达式：\n$$ \\left[ 1 - p + \\frac{px}{100} \\right] - (1 - p) = 1 - p + \\frac{px}{100} - 1 + p = \\frac{px}{100} $$\n将此结果代回 $\\Delta M(x)$ 的方程，得到最终的闭式表达式：\n$$\\Delta M(x) = L r_{0} (1 - q) \\left(\\frac{px}{100}\\right)$$\n这可以写作：\n$$\\Delta M(x) = \\frac{L r_{0} p x (1 - q)}{100}$$\n这个表达式代表了仅由于特定的校对效率降低而导致的每个基因组每次细胞分裂的额外期望突变数。",
            "answer": "$$\\boxed{\\frac{L r_{0} p x (1 - q)}{100}}$$"
        },
        {
            "introduction": "除了内在的保真机制，DNA序列本身的物理特性也会影响复制的进程。特定的回文序列可能形成发夹结构，从而阻碍DNA聚合酶的前进。这项实践任务要求你将一个关于发夹稳定性的生物物理模型，转化为一个可以扫描基因组并识别这些潜在结构位点的算法 。这是一个典型的生物信息学问题，旨在从海量序列数据中发现具有生物学功能的模式。",
            "id": "2403464",
            "problem": "在脱氧核糖核酸 (DNA) 字符串中，给定一个关于反向互补回文子串的形式化定义，以及一个可能使DNA依赖性DNA聚合酶停滞的发夹结构形成的简化生物物理判据。设字母表为 $\\{A,C,G,T\\}$。对于一个长度为 $N$ 的基因组字符串 $G$，发夹候选结构是 $G$ 的任意子串 $H$，该子串可划分为 $H = L \\cdot \\ell \\cdot R$，其中 $L$ 是长度为 $s$ 的左臂，$\\ell$ 是长度为 $l$ 的环，$R$ 是长度为 $s$ 的右臂，且 $s \\in \\mathbb{Z}_{\\ge 1}$ 和 $l \\in \\mathbb{Z}_{\\ge 1}$。定义互补映射 $c$ 为 $c(A)=T$, $c(T)=A$, $c(C)=G$, $c(G)=C$。对于每个位置 $j \\in \\{0,1,\\dots,s-1\\}$，在 $L[j]$ 和 $R[s-1-j]$ 之间定义一个碱基对。如果 $R[s-1-j] = c(L[j])$，则该碱基对为匹配，否则为错配。设 $b$ 为匹配总数，$m$ 为错配总数，使得 $m = s - b$。设 $g$ 为鸟嘌呤-胞嘧啶 (GC) 对的匹配数量，即满足 $\\{L[j],R[s-1-j]\\} = \\{G,C\\}$ 的匹配。定义GC分数 $f_{\\mathrm{GC}}$ 为：如果 $b \\neq 0$，则 $f_{\\mathrm{GC}}=g/b$；如果 $b=0$，则 $f_{\\mathrm{GC}} = 0$。\n\n一个发夹候选结构 $H$ 被预测为能够形成稳定的发夹结构并停滞聚合酶，当且仅当以下所有条件同时成立：\n- 茎长度约束：$s_{\\min} \\le s \\le s_{\\max}$。\n- 环长度约束：$l_{\\min} \\le l \\le l_{\\max}$。\n- 错配容忍度：$m \\le k_{\\max}$。\n- 最小配对数：$b \\ge b_{\\min}$。\n- 最小GC分数：$f_{\\mathrm{GC}} \\ge f_{\\mathrm{GC}}^{\\min}$。\n\n对于给定的基因组 $G$ 和参数 $(s_{\\min}, s_{\\max}, l_{\\min}, l_{\\max}, k_{\\max}, b_{\\min}, f_{\\mathrm{GC}}^{\\min})$，定义任务输出为 $G$ 中满足上述标准的不同发夹实例的总数。不同的实例由三元组 $(i,s,l)$ 定义，其中 $i \\in \\{0,1,\\dots,N-(2s+l)\\}$ 是 $H$ 在 $G$ 中的起始索引，$s$ 和 $l$ 如上所述。\n\n您的程序必须精确实现此定义，并为以下测试套件生成所需的输出。每个测试用例是一个元组，包含一个基因组字符串 $G$ 和一个七元参数组 $(s_{\\min}, s_{\\max}, l_{\\min}, l_{\\max}, k_{\\max}, b_{\\min}, f_{\\mathrm{GC}}^{\\min})$：\n\n- 测试用例1 (富含GC的通用回文结构):\n  - $G =$ \"AAAGCGCTTGCGCAAATTT\"\n  - 参数: $(s_{\\min}, s_{\\max}, l_{\\min}, l_{\\max}, k_{\\max}, b_{\\min}, f_{\\mathrm{GC}}^{\\min}) = (\\,4,\\,4,\\,2,\\,2,\\,0,\\,4,\\,0.75\\,)$\n- 测试用例2 (边界情况，恰好一个错配且GC分数处于阈值):\n  - $G =$ \"TTTATCAAAGTTCCC\"\n  - 参数: $(\\,3,\\,3,\\,3,\\,3,\\,1,\\,2,\\,0.5\\,)$\n- 测试用例3 (严格约束下无有效发夹结构):\n  - $G =$ \"ATCAAAGTT\"\n  - 参数: $(\\,3,\\,3,\\,3,\\,3,\\,0,\\,3,\\,1.0\\,)$\n- 测试用例4 (两个分离的强发夹结构，均富含GC):\n  - $G =$ \"AAAGCGCTTGCGCTTTCCGGAACCGGAAA\"\n  - 参数: $(\\,4,\\,4,\\,2,\\,2,\\,0,\\,4,\\,1.0\\,)$\n- 测试用例5 (处于阈值的包含性情况，GC分数为 $\\frac{2}{3}$ 且错配数达到上限):\n  - $G =$ \"AAAGTATCAAAGGTCCAAA\"\n  - 参数: $(\\,5,\\,5,\\,3,\\,3,\\,2,\\,3,\\,\\frac{2}{3}\\,)$\n\n角度单位不适用，也不涉及任何物理单位。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表内容为按上述测试用例顺序（从测试用例1到测试用例5）排列的结果。例如，所需格式为“[rA,rB,rC,rD,rE]”，其中每个项目是对应测试用例的整数计数。",
            "solution": "问题陈述已经过严格验证，被认为是科学上可靠、定义明确且客观的。它为DNA发夹结构的形成提供了一个简化但连贯的生物物理模型，已知DNA发夹结构与复制过程中DNA聚合酶的停滞有关。所有术语、参数和标准都经过了精确的数学定义，使得问题明确无歧义且在算法上是可解的。未发现任何矛盾、信息缺失或伪科学论断。因此，不仅可能，而且必须给出一个解。\n\n任务是枚举给定基因组字符串 $G$ 中所有满足一组同步的生物物理和结构约束的独立发夹实例。一个独立的实例由一个三元组 $(i, s, l)$ 唯一标识，其中 $i$ 是发夹候选结构 $H$ 在 $G$ 中的起始位置（0索引），$s$ 是茎臂的长度，$l$ 是环的长度。\n\n方法论上的途径是对所有可能的发夹候选结构的整个空间进行直接的穷举搜索。该算法按以下步骤系统地进行：\n\n1.  **候选结构生成**：我们遍历茎长度 $s$ 和环长度 $l$ 的所有允许整数值，这些值分别受输入参数 $(s_{\\min}, s_{\\max})$ 和 $(l_{\\min}, l_{\\max})$ 的约束。\n    $$ s \\in [s_{\\min}, s_{\\max}] $$\n    $$ l \\in [l_{\\min}, l_{\\max}] $$\n    对于每个有效的 $(s, l)$ 对，一个发夹候选结构 $H$ 的总长度为 $2s+l$。然后我们遍历此类候选结构在长度为 $N$ 的基因组 $G$ 中的所有可能的起始位置 $i$。\n    $$ i \\in [0, N - (2s+l)] $$\n    这种三层循环结构确保了由 $(i, s, l)$ 定义的每个潜在发夹候选结构都被恰好考虑一次。\n\n2.  **子结构划分**：对于每个候选三元组 $(i,s,l)$，我们提取相应的子串 $H = G[i:i+2s+l]$。该子串被划分为其组成部分：左臂 $L$、环 $\\ell$ 和右臂 $R$。\n    -   $L = G[i:i+s]$\n    -   $\\ell = G[i+s:i+s+l]$\n    -   $R = G[i+s+l:i+2s+l]$\n\n3.  **生物物理分析**：然后我们分析左臂 $L$ 和右臂 $R$ 之间的配对潜力。根据问题定义，在每个位置 $j \\in \\{0, 1, \\dots, s-1\\}$，碱基对在 $L[j]$ 和 $R[s-1-j]$ 之间形成。我们必须量化以下属性：\n    -   匹配总数 $b$，其中 $R[s-1-j] = c(L[j])$，而 $c$ 是互补映射 $\\{A \\leftrightarrow T, C \\leftrightarrow G\\}$。\n    -   错配总数 $m$，即 $m = s-b$。\n    -   鸟嘌呤-胞嘧啶 (GC) 匹配数 $g$，其中匹配涉及碱基对 $\\{G,C\\}$。\n\n4.  **约束验证**：为由 $(i,s,l)$ 定义的候选结构计算出的属性 $(b, m, g)$ 将根据给定的稳定性标准进行验证：\n    -   错配容忍度：$m \\le k_{\\max}$\n    -   最小配对数：$b \\ge b_{\\min}$\n    -   最小GC分数：一个关键检查涉及GC分数 $f_{\\mathrm{GC}}$。其定义为：如果 $b \\neq 0$，则 $f_{\\mathrm{GC}} = g/b$；如果 $b=0$，则 $f_{\\mathrm{GC}} = 0$。此计算值必须满足 $f_{\\mathrm{GC}} \\ge f_{\\mathrm{GC}}^{\\min}$。\n\n5.  **枚举**：如果一个候选结构 $(i,s,l)$ 同时满足所有指定约束，则计为一个有效的发夹实例。总计数在所有评估过的候选结构中累加。\n\n这种穷举枚举提供了问题陈述所要求的精确、唯一且正确的解。每个测试用例的最终结果是此类有效 $(i,s,l)$ 三元组的总数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the DNA hairpin counting problem for a suite of test cases.\n    \"\"\"\n    \n    # The complement map for DNA bases.\n    complement_map = {'A': 'T', 'T': 'A', 'C': 'G', 'G': 'C'}\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\n            \"AAAGCGCTTGCGCAAATTT\",\n            (4, 4, 2, 2, 0, 4, 0.75)\n        ),\n        (\n            \"TTTATCAAAGTTCCC\",\n            (3, 3, 3, 3, 1, 2, 0.5)\n        ),\n        (\n            \"ATCAAAGTT\",\n            (3, 3, 3, 3, 0, 3, 1.0)\n        ),\n        (\n            \"AAAGCGCTTGCGCTTTCCGGAACCGGAAA\",\n            (4, 4, 2, 2, 0, 4, 1.0)\n        ),\n        (\n            \"AAAGTATCAAAGGTCCAAA\",\n            (5, 5, 3, 3, 2, 3, 2/3)\n        ),\n    ]\n\n    def count_hairpins(G, params):\n        \"\"\"\n        Calculates the number of valid hairpin instances in a genome string.\n        \"\"\"\n        s_min, s_max, l_min, l_max, k_max, b_min, f_gc_min = params\n        N = len(G)\n        valid_hairpin_count = 0\n\n        # Iterate over all possible stem lengths s\n        for s in range(s_min, s_max + 1):\n            # Iterate over all possible loop lengths l\n            for l in range(l_min, l_max + 1):\n                hairpin_len = 2 * s + l\n                if hairpin_len > N:\n                    continue\n\n                # Iterate over all possible start positions i\n                for i in range(N - hairpin_len + 1):\n                    # Extract hairpin candidate substructures\n                    L = G[i : i + s]\n                    # Loop ell is G[i + s : i + s + l]\n                    R = G[i + s + l : i + hairpin_len]\n                    \n                    # Calculate biophysical properties\n                    b = 0  # matches\n                    g = 0  # GC matches\n                    \n                    for j in range(s):\n                        base_L = L[j]\n                        base_R = R[s - 1 - j]\n                        \n                        if complement_map.get(base_L) == base_R:\n                            b += 1\n                            if base_L in ('G', 'C'):\n                                g += 1\n                    \n                    m = s - b # mismatches\n\n                    # Check stability criteria\n                    # 1. Stem length (implicit in loop bounds)\n                    # 2. Loop length (implicit in loop bounds)\n                    # 3. Mismatch tolerance\n                    if m > k_max:\n                        continue\n                    \n                    # 4. Minimum pairing\n                    if b  b_min:\n                        continue\n                        \n                    # 5. Minimum GC fraction\n                    if b == 0:\n                        f_gc = 0.0\n                    else:\n                        f_gc = g / b\n                    \n                    if f_gc  f_gc_min:\n                        continue\n                        \n                    # If all criteria are met, this is a valid hairpin instance\n                    valid_hairpin_count += 1\n                        \n        return valid_hairpin_count\n\n    results = []\n    for genome, parameters in test_cases:\n        result = count_hairpins(genome, parameters)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}