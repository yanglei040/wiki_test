{
    "hands_on_practices": [
        {
            "introduction": "蛋白质三维结构的可视化始于理解其基本的构造单元。本练习聚焦于肽键——蛋白质主链中的关键连接。你将通过编程实现二面角 $\\omega$ 的精确数学定义，以计算方式识别出稀有但重要的“顺式”肽键，从而锻炼你将几何学原理应用于分子坐标的技能。",
            "id": "2416436",
            "problem": "给定一个数学规范，用于根据围绕肽键的主链二面角，将蛋白质主链中的肽键分类为顺式或非顺式。考虑一个连接残基 $i$ 和残基 $i+1$ 的肽键。设四个三维点分别为残基 $i$ 的α-碳原子（$\\mathrm{C}_\\alpha(i)$）、残基 $i$ 的羰基碳（$\\mathrm{C}(i)$）、残基 $i+1$ 的酰胺氮（$\\mathrm{N}(i+1)$）以及残基 $i+1$ 的α-碳原子（$\\mathrm{C}_\\alpha(i+1)$）。将这四个点分别记为 $P_1$、$P_2$、$P_3$ 和 $P_4$，其坐标位于 $\\mathbb{R}^3$ 中。围绕肽键 $\\mathrm{C}(i)-\\mathrm{N}(i+1)$ 的主链二面角定义为平面 $(P_1,P_2,P_3)$ 和平面 $(P_2,P_3,P_4)$ 之间的有符号角 $\\omega$，其计算从第一性原理出发，如下所示。\n\n设键矢量为\n$$\n\\mathbf{b}_0 = P_2 - P_1,\\quad \\mathbf{b}_1 = P_3 - P_2,\\quad \\mathbf{b}_2 = P_4 - P_3.\n$$\n设\n$$\n\\mathbf{n}_1 = \\mathbf{b}_0 \\times \\mathbf{b}_1,\\quad \\mathbf{n}_2 = \\mathbf{b}_1 \\times \\mathbf{b}_2,\\quad \\hat{\\mathbf{b}}_1 = \\frac{\\mathbf{b}_1}{\\lVert \\mathbf{b}_1 \\rVert},\\quad \\mathbf{m}_1 = \\mathbf{n}_1 \\times \\hat{\\mathbf{b}}_1.\n$$\n那么，有符号二面角 $\\omega$ 为\n$$\n\\omega = \\operatorname{atan2}\\!\\left(\\mathbf{m}_1 \\cdot \\mathbf{n}_2,\\ \\mathbf{n}_1 \\cdot \\mathbf{n}_2\\right),\n$$\n该函数返回以弧度为单位、在 $(-\\pi,\\pi]$ 区间内的主值。\n\n一个肽键被分类为顺式，当且仅当其二面角 $\\omega$ 的主值满足\n$$\n\\lvert \\omega \\rvert \\le \\tau,\n$$\n其中容差为 $\\tau = \\pi/6$ 弧度。在评估该不等式时，使用 $\\epsilon = 10^{-9}$ 弧度的数值比较容差。\n\n您的任务是编写一个完整、可运行的程序，该程序针对下面指定的每个测试用例，识别出哪些肽键是顺式的，并返回该测试用例中这些顺式键的从零开始的索引列表。角度必须以弧度为单位处理。\n\n为了使测试用例具体且自包含，无需外部文件，每个测试用例中的肽键都由一对角度 $(\\theta_1,\\theta_2)$ 间接给出。这对角度参数化了一个与 $x$ 轴对齐的标准的四点构造。对于每对 $(\\theta_1,\\theta_2)$，构造如下四个点：\n$$\nP_1 = (-1,\\ \\cos\\theta_1,\\ \\sin\\theta_1),\\quad\nP_2 = (0,\\ 0,\\ 0),\\quad\nP_3 = (1,\\ 0,\\ 0),\\quad\nP_4 = (2,\\ \\cos\\theta_2,\\ \\sin\\theta_2),\n$$\n所有坐标均以任意长度单位表示。这种构造产生的肽键二面角 $\\omega = \\theta_1 - \\theta_2$，其主值可通过上述 $\\operatorname{atan2}$ 表达式获得。\n\n测试套件（每行为一个测试用例；每个测试用例是一个 $(\\theta_1,\\theta_2)$ 对的列表；所有角度均以弧度为单位）：\n\n- 测试用例 1：$[(1.234,\\ 1.234)]$。\n- 测试用例 2：$[(1.234,\\ 1.834)]$。\n- 测试用例 3：$[(0.0,\\ \\pi - 0.01),\\ (2.5,\\ 2.5 + 2\\pi - 0.1),\\ (0.0,\\ -\\pi/6)]$。\n- 测试用例 4：$[]$ (无肽键)。\n\n要求的最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素本身也是一个方括号列表，包含了对应测试用例中顺式键的从零开始的索引。例如，如果第一个测试用例在索引 $0$ 处有一个顺式键，第二个没有，第三个在索引 $1$ 和 $2$ 处有顺式键，第四个没有，则输出必须是\n$[[0],[],[1,2],[]]$。",
            "solution": "所提供的问题陈述已经过验证，并被认为是有效的。它具有科学依据、问题适定、客观且内部一致。它基于结构生物学和矢量数学的既定原则，提出了一个清晰的计算任务。我现在将提供一个完整的解决方案。\n\n该问题要求根据主链二面角 $\\omega$ 的值将肽键分类为“顺式”。一个肽键由四个原子坐标定义：$P_1 = \\mathrm{C}_\\alpha(i)$、$P_2 = \\mathrm{C}(i)$、$P_3 = \\mathrm{N}(i+1)$ 和 $P_4 = \\mathrm{C}_\\alpha(i+1)$，其中 $i$ 是残基索引。\n\n二面角 $\\omega$ 定义为包含点 $(P_1, P_2, P_3)$ 的平面与包含点 $(P_2, P_3, P_4)$ 的平面之间的有符号角。该计算是使用矢量代数指定的。设键矢量定义如下：\n$$\n\\mathbf{b}_0 = P_2 - P_1,\\quad \\mathbf{b}_1 = P_3 - P_2,\\quad \\mathbf{b}_2 = P_4 - P_3\n$$\n这两个平面的法向量由定义它们的键矢量的叉积给出：\n$$\n\\mathbf{n}_1 = \\mathbf{b}_0 \\times \\mathbf{b}_1 \\\\\n\\mathbf{n}_2 = \\mathbf{b}_1 \\times \\mathbf{b}_2\n$$\n平面间的无符号角就是这两个法向量之间的夹角。为了确定角度的符号，在第一个平面中建立一个参考方向。问题使用矢量 $\\mathbf{m}_1$ 来定义这个方向：\n$$\n\\hat{\\mathbf{b}}_1 = \\frac{\\mathbf{b}_1}{\\lVert \\mathbf{b}_1 \\rVert} \\\\\n\\mathbf{m}_1 = \\mathbf{n}_1 \\times \\hat{\\mathbf{b}}_1\n$$\n然后使用双参数反正切函数 $\\operatorname{atan2}$ 计算有符号角 $\\omega$，该函数能正确地将结果映射到 $(-\\pi, \\pi]$ 弧度的区间内：\n$$\n\\omega = \\operatorname{atan2}\\!\\left(\\mathbf{m}_1 \\cdot \\mathbf{n}_2,\\ \\mathbf{n}_1 \\cdot \\mathbf{n}_2\\right)\n$$\n如果一个肽键的二面角 $\\omega$ 满足条件 $|\\omega| \\le \\tau$，则将其分类为顺式，其中角度容差为 $\\tau = \\pi/6$ 弧度。涉及浮点数的数值计算必须考虑潜在的精度误差，因此我们使用给定的数值容差 $\\epsilon = 10^{-9}$ 弧度，将此不等式评估为 $|\\omega| \\le \\tau + \\epsilon$。\n\n问题提供了一种特定的、参数化的构造方法来生成测试用例，从而避免了使用外部数据文件。对于给定的一对角度 $(\\theta_1, \\theta_2)$，这四个点构造如下：\n$$\nP_1 = (-1,\\ \\cos\\theta_1,\\ \\sin\\theta_1) \\\\\nP_2 = (0,\\ 0,\\ 0) \\\\\nP_3 = (1,\\ 0,\\ 0) \\\\\nP_4 = (2,\\ \\cos\\theta_2,\\ \\sin\\theta_2)\n$$\n在实现解决方案之前，我们必须验证问题中的论断，即这种构造导致 $\\omega$ 是 $\\theta_1 - \\theta_2$ 的主值。我们进行如下推导。\n\n首先，我们根据给定的点计算键矢量：\n$$ \\mathbf{b}_0 = P_2 - P_1 = (0,0,0) - (-1, \\cos\\theta_1, \\sin\\theta_1) = (1, -\\cos\\theta_1, -\\sin\\theta_1) $$\n$$ \\mathbf{b}_1 = P_3 - P_2 = (1,0,0) - (0,0,0) = (1, 0, 0) $$\n$$ \\mathbf{b}_2 = P_4 - P_3 = (2, \\cos\\theta_2, \\sin\\theta_2) - (1,0,0) = (1, \\cos\\theta_2, \\sin\\theta_2) $$\n接下来，我们计算法向量：\n$$ \\mathbf{n}_1 = \\mathbf{b}_0 \\times \\mathbf{b}_1 = (1, -\\cos\\theta_1, -\\sin\\theta_1) \\times (1, 0, 0) = (0, -\\sin\\theta_1, \\cos\\theta_1) $$\n$$ \\mathbf{n}_2 = \\mathbf{b}_1 \\times \\mathbf{b}_2 = (1, 0, 0) \\times (1, \\cos\\theta_2, \\sin\\theta_2) = (0, -\\sin\\theta_2, \\cos\\theta_2) $$\n然后我们计算点积 $\\mathbf{n}_1 \\cdot \\mathbf{n}_2$，它将作为 $\\operatorname{atan2}$ 的第二个参数：\n$$ \\mathbf{n}_1 \\cdot \\mathbf{n}_2 = (0)(0) + (-\\sin\\theta_1)(-\\sin\\theta_2) + (\\cos\\theta_1)(\\cos\\theta_2) = \\cos\\theta_1\\cos\\theta_2 + \\sin\\theta_1\\sin\\theta_2 = \\cos(\\theta_1 - \\theta_2) $$\n对于 $\\operatorname{atan2}$ 的第一个参数，我们需要 $\\mathbf{m}_1 \\cdot \\mathbf{n}_2$。首先，我们求出 $\\mathbf{m}_1$：\n$$ \\hat{\\mathbf{b}}_1 = \\frac{\\mathbf{b}_1}{\\lVert \\mathbf{b}_1 \\rVert} = \\frac{(1,0,0)}{\\sqrt{1^2+0^2+0^2}} = (1, 0, 0) $$\n$$ \\mathbf{m}_1 = \\mathbf{n}_1 \\times \\hat{\\mathbf{b}}_1 = (0, -\\sin\\theta_1, \\cos\\theta_1) \\times (1, 0, 0) = (0, \\cos\\theta_1, \\sin\\theta_1) $$\n现在，我们计算点积 $\\mathbf{m}_1 \\cdot \\mathbf{n}_2$：\n$$ \\mathbf{m}_1 \\cdot \\mathbf{n}_2 = (0)(0) + (\\cos\\theta_1)(-\\sin\\theta_2) + (\\sin\\theta_1)(\\cos\\theta_2) = \\sin\\theta_1\\cos\\theta_2 - \\cos\\theta_1\\sin\\theta_2 = \\sin(\\theta_1 - \\theta_2) $$\n将这些结果代入 $\\omega$ 的公式中：\n$$ \\omega = \\operatorname{atan2}(\\sin(\\theta_1 - \\theta_2), \\cos(\\theta_1 - \\theta_2)) $$\n这证实了对于所提供的测试用例构造，$\\omega$ 精确地是角度差 $\\theta_1 - \\theta_2$ 的主值，并被约化到区间 $(-\\pi, \\pi]$。这个优雅的简化使我们能够绕过对特定测试用例的完整矢量计算，而采用更直接的计算方法。\n\n算法如下：\n对于每个测试用例（一个 $(\\theta_1, \\theta_2)$ 对的列表）：\n1. 初始化一个空列表，用于存储顺式键的从零开始的索引。\n2. 对于列表中索引为 $i$ 的每一对 $(\\theta_1, \\theta_2)$：\n    a. 计算角度差 $\\Delta\\theta = \\theta_1 - \\theta_2$。\n    b. 计算这个差值的主值 $\\omega = \\operatorname{atan2}(\\sin(\\Delta\\theta), \\cos(\\Delta\\theta))$。\n    c. 检查是否满足顺式条件：$|\\omega| \\le \\pi/6 + 10^{-9}$。\n    d. 如果条件为真，则将索引 $i$ 添加到顺式键索引列表中。\n3. 处理完所有对后，当前测试用例的索引列表就完成了。对所有测试用例重复此过程。\n4. 最后，将收集到的结果按照问题指定的格式格式化为单个字符串。\n此过程是确定性的，并直接实现了经过验证的问题定义。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the peptide bond classification problem for a given suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple represents a (theta1, theta2) pair in radians.\n    test_cases = [\n        # Test case 1\n        [(1.234, 1.234)],\n        # Test case 2\n        [(1.234, 1.834)],\n        # Test case 3\n        [(0.0, np.pi - 0.01), (2.5, 2.5 + 2 * np.pi - 0.1), (0.0, -np.pi / 6)],\n        # Test case 4\n        [],\n    ]\n\n    # Define constants from the problem\n    tau = np.pi / 6.0  # Cis/trans boundary angle tolerance\n    epsilon = 1e-9      # Numerical comparison tolerance\n\n    all_results = []\n\n    for case in test_cases:\n        cis_indices = []\n        for i, (theta1, theta2) in enumerate(case):\n            # As derived, for the special case geometry, the dihedral angle omega\n            # is the principal value of (theta1 - theta2).\n            delta_theta = theta1 - theta2\n            \n            # The use of np.arctan2(np.sin(x), np.cos(x)) correctly computes the\n            # principal value of an angle x in the range (-pi, pi].\n            omega = np.arctan2(np.sin(delta_theta), np.cos(delta_theta))\n            \n            # A peptide bond is cis if |omega| = tau.\n            # We use the numerical tolerance epsilon for the comparison.\n            if abs(omega) = tau + epsilon:\n                cis_indices.append(i)\n        \n        all_results.append(cis_indices)\n\n    # Format the final output string precisely as required: [[...],[...],...]\n    # A list comprehension and f-strings are used to avoid spaces in the output.\n    results_str = [f\"[{','.join(map(str, r))}]\" for r in all_results]\n    final_output = f\"[{','.join(results_str)}]\"\n\n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n\n```"
        },
        {
            "introduction": "为了理解蛋白质如何折叠成其独特的三维形状，我们必须识别其链上相距遥远的区域之间的相互作用。本练习将指导你构建一个“接触图”，这是结构分析中可视化这些长程相互作用的基础工具。你将学习如何同时根据空间距离和序列间隔来筛选接触，并将此信息映射到如透明度这样的视觉属性上，这是有效数据可视化的核心原则之一。",
            "id": "2416453",
            "problem": "给定代表玩具蛋白质片段骨架C-α位置的简短三维残基坐标集。残基索引 $i$ 和 $j$ 之间的“接触图”由其坐标 $\\mathbf{r}_i \\in \\mathbb{R}^3$ 和 $\\mathbf{r}_j \\in \\mathbb{R}^3$ 之间的三维空间欧几里得距离定义。令欧几里得距离为 $d_{ij} = \\|\\mathbf{r}_i - \\mathbf{r}_j\\|_2$。当且仅当以下两个条件同时成立时，一对 $(i,j)$ 被视为一个接触，并可视化为连接 $\\mathbf{r}_i$ 和 $\\mathbf{r}_j$ 的线段：(1) 序列分离满足 $|i-j| \\ge s_{\\min}$，以及 (2) 空间分离满足 $d_{ij} \\le d_{\\mathrm{thr}}$。对于每个包含的接触，通过 $\\alpha_{ij} = \\max\\{0, 1 - d_{ij}/d_{\\mathrm{thr}}\\}$ 定义一个无单位的半透明度值（alpha），该值将较短的距离映射到较高的不透明度，并将等于阈值 $d_{\\mathrm{thr}}$ 的距离映射到零不透明度。坐标以埃（Å）为单位，所有距离 $d_{ij}$ 和 $d_{\\mathrm{thr}}$ 也以埃（Å）为单位，而 $\\alpha_{ij}$ 是无单位的。\n\n如果某个残基坐标缺失，任何涉及该残基的配对都必须被忽略。报告时，使用从1开始的残基索引。对于下方的每个测试用例，计算接触对的集合、它们的 $\\alpha_{ij}$ 值，并为每个测试生成以下输出：\n- 接触对的整数数量，\n- 所有 $\\alpha_{ij}$ 值的浮点数总和，四舍五入到三位小数，\n- 包含的残基索引对列表，形式为双整数列表 $[i,j]$ 且 $ij$，按升序字典序排序。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，不含任何空格。每个元素对应一个测试用例，并且本身是按给定顺序包含上述三个输出的列表。例如，整体结构必须是 \"[[n1,sum1,[[i,j],...]], [n2,sum2,[]], [n3,sum3,[[i,j],...]]]\" 的形式，但要用实际计算出的值代替占位符。\n\n测试套件：\n- 测试用例 A (类螺旋片段)：残基坐标，单位为埃 (Å)\n  - $\\mathbf{r}_1 = (2.300000, 0.000000, 0.000000)$\n  - $\\mathbf{r}_2 = (-0.399391, 2.265058, 1.500000)$\n  - $\\mathbf{r}_3 = (-2.161293, -0.786646, 3.000000)$\n  - $\\mathbf{r}_4 = (1.150000, -1.991858, 4.500000)$\n  - $\\mathbf{r}_5 = (1.761902, 1.478411, 6.000000)$\n  - $\\mathbf{r}_6 = (-1.761902, 1.478411, 7.500000)$\n  - 参数: $d_{\\mathrm{thr}} = 8.000000$ Å, $s_{\\min} = 3$。\n- 测试用例 B (伸展片段)：残基坐标，单位为埃 (Å)\n  - $\\mathbf{r}_1 = (0.000000, 0.000000, 0.000000)$\n  - $\\mathbf{r}_2 = (3.800000, 0.000000, 0.000000)$\n  - $\\mathbf{r}_3 = (7.600000, 0.000000, 0.000000)$\n  - $\\mathbf{r}_4 = (11.400000, 0.000000, 0.000000)$\n  - $\\mathbf{r}_5 = (15.200000, 0.000000, 0.000000)$\n  - $\\mathbf{r}_6 = (19.000000, 0.000000, 0.000000)$\n  - 参数: $d_{\\mathrm{thr}} = 6.000000$ Å, $s_{\\min} = 2$。\n- 测试用例 C (存在缺失坐标)：残基坐标，单位为埃 (Å)\n  - $\\mathbf{r}_1 = (0.000000, 0.000000, 0.000000)$\n  - $\\mathbf{r}_2 = (4.000000, 0.000000, 0.000000)$\n  - $\\mathbf{r}_3$ 缺失\n  - $\\mathbf{r}_4 = (0.000000, 4.000000, 0.000000)$\n  - $\\mathbf{r}_5 = (3.000000, 3.000000, 0.000000)$\n  - 参数: $d_{\\mathrm{thr}} = 5.000000$ Å, $s_{\\min} = 2$。\n\n此任务中不使用角度单位。所有最终数值答案均按规定为无单位或以埃（Å）为单位，但您的程序的单行输出必须只包含所述的数字和列表，不得包含单位符号、空格或任何额外文本。仅将每个测试的 $\\alpha_{ij}$ 值总和四舍入至三位小数；在判断是否包含时，不要对中间距离进行四舍五入。",
            "solution": "问题陈述已经过严格验证，并被认定为有效。它具有科学依据，定义明确，且没有矛盾、歧义或事实错误。该问题构成一个基于结构生物信息学基本原理的明确计算任务。因此，解决方案是直接实现指定的算法。\n\n问题的核心是识别和表征蛋白质残基之间的“接触”，这些残基由其 C-α 坐标 $\\mathbf{r}_i \\in \\mathbb{R}^3$ 表示。只有当两个条件同时满足时，具有从1开始的索引 $i$ 和 $j$ 的两个残基之间才会建立接触。\n\n首先，由索引的绝对差定义的序列分离必须达到最小阈值 $s_{\\min}$。这表示为：\n$$|i-j| \\ge s_{\\min}$$\n该条件排除了聚合物链中彼此靠近的残基之间的接触，将分析重点放在三级结构相互作用上。按照惯例，我们只考虑 $i  j$ 的配对，因此条件简化为 $j-i \\ge s_{\\min}$。\n\n其次，定义为其坐标之间的欧几里得距离 $d_{ij}$ 的空间分离不得超过指定的距离阈值 $d_{\\mathrm{thr}}$。距离计算如下：\n$$d_{ij} = \\|\\mathbf{r}_i - \\mathbf{r}_j\\|_2 = \\sqrt{(x_i - x_j)^2 + (y_i - y_j)^2 + (z_i - z_j)^2}$$\n条件是：\n$$d_{ij} \\le d_{\\mathrm{thr}}$$\n\n对于满足这两个条件的每一对 $(i, j)$，都会计算一个无单位的半透明度值 $\\alpha_{ij}$。该值被设计为与距离成反比，为更近的接触分配更高的不透明度（更低的透明度）。公式为：\n$$\\alpha_{ij} = \\max\\{0, 1 - d_{ij}/d_{\\mathrm{thr}}\\}$$\n由于接触条件 $d_{ij} \\le d_{\\mathrm{thr}}$ 确保了 $d_{ij}/d_{\\mathrm{thr}} \\le 1$，表达式可简化为 $\\alpha_{ij} = 1 - d_{ij}/d_{\\mathrm{thr}}$。\n\n解决每个测试用例的算法流程如下：\n\n1.  初始化一个空列表用于存放接触对，并初始化一个运行总和用于存放 $\\alpha$ 值，初始值为 $0.0$。\n2.  遍历所有唯一的残基索引对 $(i, j)$，使得 $1 \\le i  j \\le N$，其中 $N$ 是残基总数。\n3.  对于每一对 $(i, j)$：\n    a. 验证残基 $i$ 和残基 $j$ 的坐标都存在。如果任一坐标缺失，则根据问题规范丢弃该对。\n    b. 检查是否满足序列分离条件 $j-i \\ge s_{\\min}$。如果不满足，则丢弃该对。\n    c. 如果序列分离足够，则计算欧几里得距离 $d_{ij}$。\n    d. 检查是否满足空间距离条件 $d_{ij} \\le d_{\\mathrm{thr}}$。如果不满足，则丢弃该对。\n    e. 如果两个条件都满足，则该对是一个接触。计算值 $\\alpha_{ij} = 1 - d_{ij}/d_{\\mathrm{thr}}$ 并将其加到运行总和中。将配对 $[i, j]$ 添加到接触列表中。\n4.  在评估完所有配对后，编译结果：\n    a. 接触总数是接触列表中的最终配对计数。\n    b. $\\alpha$ 值的总和四舍五入到三位小数。\n    c. 由于嵌套循环的性质（$i$ 从 $1$ 到 $N-1$，$j$ 从 $i+1$ 到 $N$），接触对列表已经按升序字典序排序。\n5.  这三个聚合结果——计数、四舍入后的总和以及配对列表——根据问题中指定的严格“无空格”规则格式化为单个字符串。\n\n此过程是确定性的，并将为每个测试用例生成唯一、可验证的结果。该实现利用 `numpy` 库进行高效、精确的向量计算。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef format_result(result_tuple):\n    \"\"\"Formats a single test case result into the required string format.\"\"\"\n    n, s, pairs = result_tuple\n    # Round the sum of alphas to three decimal places.\n    s_rounded = round(s, 3)\n    \n    # Format pairs as a string list \"[i,j]\"\n    pairs_str_list = [f\"[{p[0]},{p[1]}]\" for p in pairs]\n    # Join pairs into a single string \"[[i,j],[k,l],...]\"\n    pairs_str = f\"[{','.join(pairs_str_list)}]\"\n    \n    # Format the final result for the test case as \"[n,s,pairs_str]\"\n    return f\"[{n},{s_rounded},{pairs_str}]\"\n\ndef process_case(coords, d_thr, s_min):\n    \"\"\"Processes a single test case.\"\"\"\n    contact_pairs = []\n    alpha_sum = 0.0\n    num_residues = len(coords)\n\n    # Iterate over all unique pairs of residues (i, j) with i  j\n    for i in range(num_residues):\n        for j in range(i + 1, num_residues):\n            # Residue indices are 1-based\n            res_idx_i = i + 1\n            res_idx_j = j + 1\n\n            # Ignore pairs involving a missing coordinate\n            if coords[i] is None or coords[j] is None:\n                continue\n\n            # 1. Check sequence separation\n            if (res_idx_j - res_idx_i) >= s_min:\n                # 2. Calculate Euclidean distance\n                dist = np.linalg.norm(coords[i] - coords[j])\n\n                # 3. Check spatial separation\n                if dist = d_thr:\n                    # This is a contact\n                    contact_pairs.append([res_idx_i, res_idx_j])\n                    \n                    # Calculate alpha value\n                    alpha = 1.0 - (dist / d_thr)\n                    alpha_sum += alpha\n    \n    num_contacts = len(contact_pairs)\n    \n    return (num_contacts, alpha_sum, contact_pairs)\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run the processing, and print the final output.\n    \"\"\"\n    test_cases = [\n        # Test case A\n        {\n            \"coords\": [\n                np.array([2.300000, 0.000000, 0.000000]),\n                np.array([-0.399391, 2.265058, 1.500000]),\n                np.array([-2.161293, -0.786646, 3.000000]),\n                np.array([1.150000, -1.991858, 4.500000]),\n                np.array([1.761902, 1.478411, 6.000000]),\n                np.array([-1.761902, 1.478411, 7.500000])\n            ],\n            \"d_thr\": 8.0,\n            \"s_min\": 3\n        },\n        # Test case B\n        {\n            \"coords\": [\n                np.array([0.000000, 0.000000, 0.000000]),\n                np.array([3.800000, 0.000000, 0.000000]),\n                np.array([7.600000, 0.000000, 0.000000]),\n                np.array([11.400000, 0.000000, 0.000000]),\n                np.array([15.200000, 0.000000, 0.000000]),\n                np.array([19.000000, 0.000000, 0.000000])\n            ],\n            \"d_thr\": 6.0,\n            \"s_min\": 2\n        },\n        # Test case C\n        {\n            \"coords\": [\n                np.array([0.000000, 0.000000, 0.000000]),\n                np.array([4.000000, 0.000000, 0.000000]),\n                None,  # Missing coordinate for residue 3\n                np.array([0.000000, 4.000000, 0.000000]),\n                np.array([3.000000, 3.000000, 0.000000])\n            ],\n            \"d_thr\": 5.0,\n            \"s_min\": 2\n        }\n    ]\n\n    formatted_results = []\n    for case in test_cases:\n        result_tuple = process_case(case[\"coords\"], case[\"d_thr\"], case[\"s_min\"])\n        formatted_results.append(format_result(result_tuple))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "蛋白质的结构是其功能的支架，而功能会随时间演化。这项高级练习将来自多序列比对（MSA）的进化信息与三维结构数据相结合。你将学习使用香农熵来量化序列保守性，并将高变异区域映射到蛋白质结构上，这是一种为功能位点或结构稳定性生成假说的强大技术。",
            "id": "2416426",
            "problem": "编写一个程序，将以下可视化原则形式化：为了仅可视化蛋白质中在多重序列比对 (MSA) 中不保守的原子，必须从 MSA 计算逐列的保守性得分，识别哪些比对位置是可变的，将这些位置映射回所选参考序列中的残基索引，然后在三维空间中选择相应的原子。在此问题中，将每个残基视为由其 α-碳原子 (Cα) 表示，其三维坐标以埃 (Angstroms) 为单位给出。您的任务是为每个提供的测试用例计算所选原子的数量以及由回旋半径测量的其位置的空间分布范围。将所选原子的数量报告为整数，将回旋半径报告为以埃为单位、四舍五入到三位小数的浮点数。\n\n需要使用的基本定义和规则：\n- 多重序列比对 (MSA)：MSA 是一组已对齐的蛋白质序列，其对齐长度相等，其中空位符用 $-$ 表示，字母取自 $20$ 种标准氨基酸单字母代码。将已对齐的参考序列视为 MSA 的一部分。\n- 列频率和香农熵：对于每个比对列 $j$，令非空位氨基酸的多重集为 $X_j$。令 $n_j$ 为 $X_j$ 中非空位字符的数量。对于 $X_j$ 中观察到的每种氨基酸类型 $a$，定义经验频率 $p(a) = \\frac{\\text{a 的计数}}{n_j}$。该列的香农熵为\n$$\nH_j = -\\sum_{a \\in X_j^\\ast} p(a)\\,\\ln p(a),\n$$\n其中 $X_j^\\ast$ 是列 $j$ 中存在的不同氨基酸的集合，$\\ln$ 是自然对数。定义最大可能熵 $H_{\\max} = \\ln 20$。归一化熵为\n$$\n\\widehat{H}_j = \\frac{H_j}{H_{\\max}}。\n$$\n- 非保守（可变）标准：给定一个阈值 $\\tau$，其中 $0 \\le \\tau \\le 1$，当且仅当 $\\widehat{H}_j \\ge \\tau$ 时，列 $j$ 被认为是可变的。\n- 从比对列到参考残基的映射：从左到右扫描已对齐的参考序列。维护一个初始化为 $-1$ 的残基索引 $k$。对于每个列位置 $j$，如果已对齐的参考字符是空位 $-$，则此列不映射到任何残基索引。否则，将 $k$ 递增 $k \\leftarrow k+1$，并将列 $j$ 映射到未比对参考序列的残基索引 $k$。未比对的参考序列长度为 $L$，其 Cα 坐标以 $L$ 个三维向量（单位为埃）的形式提供。\n- 原子选择与几何：所选原子的集合是参考残基的 Cα 坐标集合，这些残基的比对列根据上述标准是可变的。如果所选集合为空，则定义回旋半径为 $0$。否则，如果有 $N$ 个选定原子，其位置为 $\\{\\mathbf{r}_i\\}_{i=1}^N$，定义质心（质量相等）为 $\\mathbf{r}_{\\mathrm{cm}}=\\frac{1}{N}\\sum_{i=1}^N \\mathbf{r}_i$，回旋半径为\n$$\nR_g = \\sqrt{\\frac{1}{N}\\sum_{i=1}^N \\lVert \\mathbf{r}_i - \\mathbf{r}_{\\mathrm{cm}} \\rVert^2},\n$$\n其中 $\\lVert \\cdot \\rVert$ 表示欧几里得范数。距离单位为埃。报告 $R_g$ 时需四舍五入到三位小数。\n\n您的程序必须将这些步骤应用于以下测试套件。每个测试用例提供：未比对的参考序列、其 Cα 坐标、已对齐的参考序列、其余已对齐的序列以及阈值 $\\tau$。\n\n测试用例 1（无变量映射的标准情况）：\n- 参考序列（未比对）：ACDEG\n- Cα 坐标（埃）：$\\big[(0.0,0.0,0.0),(3.8,0.0,0.0),(7.6,0.0,0.0),(11.4,0.0,0.0),(15.2,0.0,0.0)\\big]$\n- 已对齐的参考序列：A-CDEG-\n- 其他已对齐序列：AFC-EG-, A-CDE--\n- 阈值 $\\tau$：$0.5$\n\n测试用例 2（通过较低阈值捕捉到的中等变异性）：\n- 参考序列（未比对）：HIKLM\n- Cα 坐标（埃）：$\\big[(0.0,0.0,0.0),(3.8,0.5,0.0),(7.6,1.0,0.0),(11.4,1.5,0.0),(15.2,2.0,0.0)\\big]$\n- 已对齐的参考序列：HIKLM-\n- 其他已对齐序列：HIKQM-, HFKLM-\n- 阈值 $\\tau$：$0.2$\n\n测试用例 3（包含空位和多个变量映射的四序列 MSA）：\n- 参考序列（未比对）：NPQR\n- Cα 坐标（埃）：$\\big[(0.0,0.0,0.0),(3.8,0.0,0.0),(7.6,0.0,0.0),(11.4,0.0,0.0)\\big]$\n- 已对齐的参考序列：-NP-QR\n- 其他已对齐序列：ANP-ER, -NP-QR, -NS-QR\n- 阈值 $\\tau$：$0.18$\n\n测试用例 4（单可变残基的边缘情况）：\n- 参考序列（未比对）：WXY\n- Cα 坐标（埃）：$\\big[(0.0,0.0,0.0),(3.8,0.0,0.0),(7.6,0.0,0.0)\\big]$\n- 已对齐的参考序列：W-XY\n- 其他已对齐序列：W-XY, F-XY\n- 阈值 $\\tau$：$0.2$\n\n每个测试用例的所需输出：\n- 一个包含两个元素的列表 $[N, R_g]$，其中 $N$ 是所选原子的整数计数，$R_g$ 是以埃为单位、四舍五入到三位小数的回旋半径。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含四个测试用例的结果，格式为用方括号括起来的逗号分隔列表，每个测试用例报告为 $[N,R_g]$，且无空格。例如，格式应类似于 $[[2,1.234],[0,0.000],[3,5.678],[1,0.000]]$（这仅为格式示例，并非正确的数值答案）。\n\n角度单位不适用。所有距离必须以埃为单位进行解释和报告。答案是按指定格式聚合的纯数字。",
            "solution": "该问题是计算生物学领域中一个定义明确且具有科学依据的练习，具体涉及在序列进化背景下分析蛋白质结构。它要求应用标准原则：使用香农熵量化序列变异性，在比对和未比对的序列表示之间进行映射，以及计算一个基本的结构参数——回旋半径。该问题是有效的，因为它是自洽的、逻辑一致的，并且基于已确立的形式体系。我将对每个测试用例进行逐步求解。\n\n问题的核心在于执行一个已定义的算法。让我们将这些步骤形式化。\n首先，对于给定的多重序列比对 (MSA)，我们必须分析每一列 $j$。一列中的非空位字符集合表示为 $X_j$。这个多重集的大小是 $n_j$。如果 $n_j > 0$，我们确定唯一的氨基酸类型集合 $X_j^\\ast$。对于每种类型 $a \\in X_j^\\ast$，我们计算其频率 $p(a)$。该列的香农熵是 $H_j = -\\sum_{a \\in X_j^\\ast} p(a)\\,\\ln p(a)$。通过除以包含 $20$ 种氨基酸的字母表的最大可能熵 $H_{\\max} = \\ln 20$ 进行归一化，得到 $\\widehat{H}_j = H_j / H_{\\max}$。如果 $\\widehat{H}_j$ 大于或等于给定的阈值 $\\tau$，则列 $j$ 被视为“可变”。\n\n其次，我们将这些可变列映射到未比对参考序列的残基上。我们遍历已比对的参考序列。残基索引计数器 $k$ 初始化为 $-1$。对于每一列 $j$，如果已比对参考序列中的字符是氨基酸，我们就递增 $k$。此列 $j$ 对应于残基 $k$。如果该列被确定为可变，则选择残基 $k$。\n\n第三，我们收集 $N$ 个选定残基的三维坐标 $\\{\\mathbf{r}_i\\}_{i=1}^N$。选定原子的数量为 $N$。如果 $N=0$，回旋半径 $R_g$ 定义为 $0$。如果 $N > 0$，我们首先计算质心 $\\mathbf{r}_{\\mathrm{cm}}=\\frac{1}{N}\\sum_{i=1}^N \\mathbf{r}_i$。然后回旋半径计算为 $R_g = \\sqrt{\\frac{1}{N}\\sum_{i=1}^N \\lVert \\mathbf{r}_i - \\mathbf{r}_{\\mathrm{cm}} \\rVert^2}$，其中 $\\lVert \\cdot \\rVert$ 是欧几里得范数。\n\n最大熵的值为 $H_{\\max} = \\ln(20) \\approx 2.99573$。\n\n**测试用例 1**\n- 已对齐的参考序列：`A-CDEG-`\n- 其他序列：`AFC-EG-`, `A-CDE--`\n- 阈值 $\\tau = 0.5$\n该 MSA 由 $3$ 个序列组成。对齐长度为 $7$。\n- 第 $0$ 列 (`A,A,A`): $n_0=3$, $X_0^\\ast=\\{\\text{A}\\}$, $p(A)=1$。$H_0 = 0$。$\\widehat{H}_0=0  0.5$。\n- 第 $1$ 列 (`-,F,-`): $n_1=1$, $X_1^\\ast=\\{\\text{F}\\}$, $p(F)=1$。$H_1 = 0$。$\\widehat{H}_1=0  0.5$。\n- 第 $2$ 列 (`C,C,C`): $H_2=0$。$\\widehat{H}_2=0  0.5$。\n- 第 $3$ 列 (`D,-,D`): $n_3=2$, $X_3^\\ast=\\{\\text{D}\\}$, $p(D)=1$。$H_3 = 0$。$\\widehat{H}_3=0  0.5$。\n- 第 $4$ 列 (`E,E,E`): $H_4=0$。$\\widehat{H}_4=0  0.5$。\n- 第 $5$ 列 (`G,G,-`): $n_5=2$, $X_5^\\ast=\\{\\text{G}\\}$, $p(G)=1$。$H_5=0$。$\\widehat{H}_5=0  0.5$。\n- 第 $6$ 列 (`-,-,-`): $n_6=0$。$H_6 = 0$。$\\widehat{H}_6=0  0.5$。\n没有一列满足可变性标准 $\\widehat{H}_j \\ge 0.5$。因此，没有残基被选中。\n选定原子数 $N=0$。回旋半径 $R_g=0.000$。\n结果：$[0, 0.000]$\n\n**测试用例 2**\n- 已对齐的参考序列：`HIKLM-`\n- 其他序列：`HIKQM-`, `HFKLM-`\n- 阈值 $\\tau = 0.2$\n- 第 $0$ 列 (`H,H,H`): $H_0=0$。$\\widehat{H}_0 = 0  0.2$。\n- 第 $1$ 列 (`I,I,F`): $n_1=3$, $X_1^\\ast=\\{\\text{I},\\text{F}\\}$, $p(I)=2/3$, $p(F)=1/3$。$H_1 = -(\\frac{2}{3}\\ln\\frac{2}{3} + \\frac{1}{3}\\ln\\frac{1}{3}) \\approx 0.6365$。$\\widehat{H}_1 \\approx 0.6365/2.99573 \\approx 0.2125$。因为 $0.2125 \\ge 0.2$，此列是可变的。\n- 第 $2$ 列 (`K,K,K`): $H_2=0$。$\\widehat{H}_2 = 0  0.2$。\n- 第 $3$ 列 (`L,Q,L`): $n_3=3$, $X_3^\\ast=\\{\\text{L},\\text{Q}\\}$, $p(L)=2/3$, $p(Q)=1/3$。$H_3=H_1 \\approx 0.6365$。$\\widehat{H}_3 \\approx 0.2125 \\ge 0.2$。此列是可变的。\n- 第 $4$ 列 (`M,M,M`): $H_4=0$。$\\widehat{H}_4 = 0  0.2$。\n- 第 $5$ 列 (`-,-,-`): $H_5=0$。$\\widehat{H}_5 = 0  0.2$。\n可变列为 $j=1$ 和 $j=3$。\n映射到参考残基 (`HIKLM-`):\n- 第 $0$ 列 (`H`) 映射到残基 $0$。非可变。\n- 第 $1$ 列 (`I`) 映射到残基 $1$。可变。选中。\n- 第 $2$ 列 (`K`) 映射到残基 $2$。非可变。\n- 第 $3$ 列 (`L`) 映射到残基 $3$。可变。选中。\n- 第 $4$ 列 (`M`) 映射到残基 $4$。非可变。\n选中了两个残基：残基 $1$ 和残基 $3$。$N=2$。对应的坐标是 $\\mathbf{r}_1=(3.8, 0.5, 0.0)$ 和 $\\mathbf{r}_3=(11.4, 1.5, 0.0)$。\n质心：$\\mathbf{r}_{\\mathrm{cm}} = \\frac{1}{2}(\\mathbf{r}_1 + \\mathbf{r}_3) = (7.6, 1.0, 0.0)$。\n与 $\\mathbf{r}_{\\mathrm{cm}}$ 的距离平方：\n$\\lVert \\mathbf{r}_1 - \\mathbf{r}_{\\mathrm{cm}} \\rVert^2 = \\lVert (3.8-7.6, 0.5-1.0, 0.0) \\rVert^2 = (-3.8)^2 + (-0.5)^2 = 14.44 + 0.25 = 14.69$。\n$\\lVert \\mathbf{r}_3 - \\mathbf{r}_{\\mathrm{cm}} \\rVert^2 = \\lVert (11.4-7.6, 1.5-1.0, 0.0) \\rVert^2 = (3.8)^2 + (0.5)^2 = 14.44 + 0.25 = 14.69$。\n$R_g = \\sqrt{\\frac{1}{2}(14.69 + 14.69)} = \\sqrt{14.69} \\approx 3.83275$。四舍五入到三位小数，$R_g=3.833$。\n结果：$[2, 3.833]$\n\n**测试用例 3**\n- 已对齐的参考序列：`-NP-QR`\n- 其他序列：`ANP-ER`, `-NP-QR`, `-NS-QR`\n- 阈值 $\\tau = 0.18$\nMSA 有 $4$ 个序列。\n- 第 $0$ 列 (`-,A,-,-`): $H_0=0$。$\\widehat{H}_0 = 0  0.18$。\n- 第 $1$ 列 (`N,N,N,N`): $H_1=0$。$\\widehat{H}_1=0  0.18$。\n- 第 $2$ 列 (`P,P,P,S`): $n_2=4$, $X_2^\\ast=\\{\\text{P},\\text{S}\\}$, $p(P)=3/4$, $p(S)=1/4$。$H_2 = -(\\frac{3}{4}\\ln\\frac{3}{4} + \\frac{1}{4}\\ln\\frac{1}{4}) \\approx 0.5623$。$\\widehat{H}_2 \\approx 0.5623/2.99573 \\approx 0.1877$。因为 $0.1877 \\ge 0.18$，此列是可变的。\n- 第 $3$ 列 (`-,-,-,-`): $H_3=0$。$\\widehat{H}_3=0  0.18$。\n- 第 $4$ 列 (`Q,E,Q,Q`): $n_4=4$, $X_4^\\ast=\\{\\text{Q},\\text{E}\\}$, $p(Q)=3/4$, $p(E)=1/4$。$H_4=H_2 \\approx 0.5623$。$\\widehat{H}_4 \\approx 0.1877 \\ge 0.18$。此列是可变的。\n- 第 $5$ 列 (`R,R,R,R`): $H_5=0$。$\\widehat{H}_5=0  0.18$。\n可变列为 $j=2$ 和 $j=4$。\n映射到参考残基 (`-NP-QR`):\n- 第 $1$ 列 (`N`) 映射到残基 $0$。\n- 第 $2$ 列 (`P`) 映射到残基 $1$。可变。选中。\n- 第 $4$ 列 (`Q`) 映射到残基 $2$。可变。选中。\n- 第 $5$ 列 (`R`) 映射到残基 $3$。\n选中了两个残基：残基 $1$ 和残基 $2$。$N=2$。坐标为 $\\mathbf{r}_1=(3.8, 0.0, 0.0)$ 和 $\\mathbf{r}_2=(7.6, 0.0, 0.0)$。\n$\\mathbf{r}_{\\mathrm{cm}} = \\frac{1}{2}(\\mathbf{r}_1 + \\mathbf{r}_2) = (5.7, 0.0, 0.0)$。\n$\\lVert \\mathbf{r}_1 - \\mathbf{r}_{\\mathrm{cm}} \\rVert^2 = (3.8-5.7)^2 = (-1.9)^2 = 3.61$。\n$\\lVert \\mathbf{r}_2 - \\mathbf{r}_{\\mathrm{cm}} \\rVert^2 = (7.6-5.7)^2 = (1.9)^2 = 3.61$。\n$R_g = \\sqrt{\\frac{1}{2}(3.61 + 3.61)} = \\sqrt{3.61} = 1.9$。四舍五入结果：$1.900$。\n结果：$[2, 1.900]$\n\n**测试用例 4**\n- 已对齐的参考序列：`W-XY`\n- 其他序列：`W-XY`, `F-XY`\n- 阈值 $\\tau = 0.2$\n- 第 $0$ 列 (`W,W,F`): $n_0=3$, $X_0^\\ast=\\{\\text{W},\\text{F}\\}$, $p(W)=2/3$, $p(F)=1/3$。$H_0 \\approx 0.6365$。$\\widehat{H}_0 \\approx 0.2125 \\ge 0.2$。可变。\n- 第 $1$ 列 (`-,-,-`): $H_1=0$。$\\widehat{H}_1=0  0.2$。\n- 第 $2$ 列 (`X,X,X`): $H_2=0$。$\\widehat{H}_2=0  0.2$。\n- 第 $3$ 列 (`Y,Y,Y`): $H_3=0$。$\\widehat{H}_3=0  0.2$。\n只有第 $j=0$ 列是可变的。\n映射到参考残基 (`W-XY`):\n- 第 $0$ 列 (`W`) 映射到残基 $0$。可变。选中。\n- 第 $2$ 列 (`X`) 映射到残基 $1$。\n- 第 $3$ 列 (`Y`) 映射到残基 $2$。\n选中了一个残基：残基 $0$。$N=1$。坐标为 $\\mathbf{r}_0=(0.0, 0.0, 0.0)$。\n对于 $N=1$，质心就是该点本身，所以偏差为零。因此，$R_g=0$。\n结果：$[1, 0.000]$\n\n最终结果总结：\n- 用例 1：$[0, 0.000]$\n- 用例 2：$[2, 3.833]$\n- 用例 3：$[2, 1.900]$\n- 用例 4：$[1, 0.000]$\n这些结果将被格式化为所需的最终输出字符串。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\nfrom collections import Counter\n\ndef solve():\n    \"\"\"\n    Solves the problem for all test cases and prints the formatted output.\n    \"\"\"\n    # Foundational constant H_max = ln(20)\n    H_MAX = math.log(20)\n\n    test_cases = [\n        {\n            \"ref_unaligned\": \"ACDEG\",\n            \"coords\": np.array([\n                [0.0, 0.0, 0.0], [3.8, 0.0, 0.0], [7.6, 0.0, 0.0],\n                [11.4, 0.0, 0.0], [15.2, 0.0, 0.0]\n            ]),\n            \"ref_aligned\": \"A-CDEG-\",\n            \"other_aligned\": [\"AFC-EG-\", \"A-CDE--\"],\n            \"tau\": 0.5\n        },\n        {\n            \"ref_unaligned\": \"HIKLM\",\n            \"coords\": np.array([\n                [0.0, 0.0, 0.0], [3.8, 0.5, 0.0], [7.6, 1.0, 0.0],\n                [11.4, 1.5, 0.0], [15.2, 2.0, 0.0]\n            ]),\n            \"ref_aligned\": \"HIKLM-\",\n            \"other_aligned\": [\"HIKQM-\", \"HFKLM-\"],\n            \"tau\": 0.2\n        },\n        {\n            \"ref_unaligned\": \"NPQR\",\n            \"coords\": np.array([\n                [0.0, 0.0, 0.0], [3.8, 0.0, 0.0], \n                [7.6, 0.0, 0.0], [11.4, 0.0, 0.0]\n            ]),\n            \"ref_aligned\": \"-NP-QR\",\n            \"other_aligned\": [\"ANP-ER\", \"-NP-QR\", \"-NS-QR\"],\n            \"tau\": 0.18\n        },\n        {\n            \"ref_unaligned\": \"WXY\",\n            \"coords\": np.array([\n                [0.0, 0.0, 0.0], [3.8, 0.0, 0.0], [7.6, 0.0, 0.0]\n            ]),\n            \"ref_aligned\": \"W-XY\",\n            \"other_aligned\": [\"W-XY\", \"F-XY\"],\n            \"tau\": 0.2\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        coords = case[\"coords\"]\n        ref_aligned = case[\"ref_aligned\"]\n        other_aligned = case[\"other_aligned\"]\n        tau = case[\"tau\"]\n\n        # Step 1: Form the full MSA and analyze columns\n        msa = [ref_aligned] + other_aligned\n        aligned_len = len(ref_aligned)\n        \n        variable_columns = set()\n        for j in range(aligned_len):\n            column = [seq[j] for seq in msa]\n            non_gap_residues = [res for res in column if res != '-']\n            \n            n_j = len(non_gap_residues)\n            if n_j == 0:\n                h_j_norm = 0.0\n            else:\n                counts = Counter(non_gap_residues)\n                h_j = 0.0\n                for count in counts.values():\n                    p_a = count / n_j\n                    if p_a > 0:\n                        h_j -= p_a * math.log(p_a)\n                \n                h_j_norm = h_j / H_MAX\n            \n            if h_j_norm >= tau:\n                variable_columns.add(j)\n\n        # Step 2: Map columns to reference residues and identify variable ones\n        variable_residue_indices = []\n        residue_idx = -1\n        for j, char in enumerate(ref_aligned):\n            if char != '-':\n                residue_idx += 1\n                if j in variable_columns:\n                    variable_residue_indices.append(residue_idx)\n\n        # Step 3: Select atoms and compute geometry\n        selected_coords = coords[variable_residue_indices]\n        N = len(selected_coords)\n\n        if N == 0:\n            Rg = 0.0\n        else:\n            # Handle N=1 case; Rg is 0\n            if N == 1:\n                Rg = 0.0\n            else: # N > 1\n                center_of_mass = np.mean(selected_coords, axis=0)\n                # Correct calculation for Radius of Gyration\n                # Rg = sqrt( (1/N) * sum_i( ||r_i - r_cm||^2 ) )\n                # ||v||^2 is sum(v_j^2)\n                squared_distances = np.sum((selected_coords - center_of_mass)**2, axis=1)\n                Rg = np.sqrt(np.mean(squared_distances))\n\n        results.append(f\"[{N},{Rg:.3f}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}