{
    "hands_on_practices": [
        {
            "introduction": "本练习将指导您在二维晶格上构建一个蛋白质模型，将经典的疏水-极性（HP）模型扩展到包含静电相互作用。通过执行穷举搜索，您将对构象空间、接触能量以及即使对于非常短的多肽链寻找最低能量状态的计算挑战有一个具体的理解。此实践为您理解蛋白质折叠中能量最小化的基本原理奠定了基础。",
            "id": "2369976",
            "problem": "要求您形式化并实现一个二维（$2$D）疏水-极性（HP）晶格蛋白质模型的扩展，该扩展模型使用包含带电残基的四字母表，分别表示为疏水（Hydrophobic）、极性（Polar）、带负电（Negative）、带正电（Cationic）（HPNC）。目标是寻找一个短多肽序列和一个在方形晶格上的自回避二维（$2$D）构象，它们共同达到最小的加性接触能量，同时包含至少一个盐桥。此处，盐桥被定义为一个带负电（Negative）残基和一个带正电（Cationic）残基之间的非连续最近邻晶格接触。\n\n请从适用于从头（ab initio）蛋白质结构预测中使用的晶格蛋白质模型的第一性原理出发。基本依据必须是以下事实，且不使用任何快捷公式：\n- 蛋白质可以被抽象为晶格上的自回避行走，其中每个残基占据一个晶格位点，而序列上连续的残基在晶格上是相邻的。只有非连续的最近邻残基对才被视为接触相互作用。\n- 疏水效应促使疏水残基之间在接触时产生有利的吸引力，这通过为疏水-疏水接触设定一个负的接触能量贡献来建模。\n- 带电残基之间的静电相互作用促使异种电荷接触具有有利能量，而同种电荷接触具有不利能量。在一个以晶格间距为单位长度的粗粒化晶格模型中，可以用一个恒定的负贡献来近似异种电荷间的相互作用，用一个恒定的正贡献来近似同种电荷间的相互作用，且这些贡献仅应用于最近邻的非连续接触。\n- 可加性假设：总能量是所有非连续接触残基对的成对接触能量之和。\n\n您的程序必须实现以下精确模型和搜索协议。\n- 残基类型是一个包含$4$个字母的字母表：疏水（$\\mathrm{H}$）、极性（$\\mathrm{P}$）、带负电（$\\mathrm{N}$）和带正电（$\\mathrm{C}$）。序列是该字母表上长度为$L$的字符串。\n- 构象是二维方形晶格上长度为$L$的自回避行走，其坐标在$\\mathbb{Z}^2$中，具体表示为一个晶格坐标列表$\\left[(x_0,y_0),(x_1,y_1),\\dots,(x_{L-1},y_{L-1})\\right]$，步长为单位长度且没有重复坐标。为避免冗余的对称性，固定$(x_0,y_0)=(0,0)$和$(x_1,y_1)=(1,0)$。\n- 将一个构象的接触集$\\mathcal{C}$定义为所有满足$0 \\le i  j \\le L-1$、$|i-j| \\ge 2$且$(x_i,y_i)$与$(x_j,y_j)$之间曼哈顿距离等于$1$的无序索引对$(i,j)$。\n- 将残基类型$a$和$b$之间的成对接触能量函数$\\varepsilon(a,b)$定义如下，使用每个测试用例提供的参数$e_{\\mathrm{HH}}$、$e_{\\mathrm{NC}}$和$e_{\\mathrm{like}}$。为了编码，设$\\mathrm{H}=0$，$\\mathrm{P}=1$，$\\mathrm{N}=2$，$\\mathrm{C}=3$。那么：\n  - $\\varepsilon(\\mathrm{H},\\mathrm{H})=\\varepsilon(0,0)=e_{\\mathrm{HH}}$。\n  - $\\varepsilon(\\mathrm{N},\\mathrm{C})=\\varepsilon(2,3)=\\varepsilon(\\mathrm{C},\\mathrm{N})=\\varepsilon(3,2)=e_{\\mathrm{NC}}$。\n  - $\\varepsilon(\\mathrm{N},\\mathrm{N})=\\varepsilon(2,2)=e_{\\mathrm{like}}$ 且 $\\varepsilon(\\mathrm{C},\\mathrm{C})=\\varepsilon(3,3)=e_{\\mathrm{like}}$。\n  - 所有其他残基对的$\\varepsilon(a,b)=0$。\n- 对于一个序列$\\{t_i\\}_{i=0}^{L-1}$和一个具有接触集$\\mathcal{C}$的构象，其总能量为\n  $$E=\\sum_{(i,j)\\in\\mathcal{C}}\\varepsilon\\left(t_i,t_j\\right).$$\n- 盐桥数为\n  $$S=\\left|\\left\\{(i,j)\\in\\mathcal{C}\\;:\\;\\{t_i,t_j\\}=\\{\\mathrm{N},\\mathrm{C}\\}\\right\\}\\right|.$$\n- 一个解必须至少包含一个盐桥，即$S \\ge 1$。\n\n搜索目标与决胜规则：\n- 在所有长度为$L$的HPNC字母表序列和所有如上定义的有效构象中，找到在满足$S \\ge 1$的条件下使$E$最小化的对。\n- 如果有多个对达到相同的最小$E$，选择$S$最大的那个。\n- 如果仍然存在平局，根据编码$\\mathrm{H}=0, \\mathrm{P}=1, \\mathrm{N}=2, \\mathrm{C}=3$，选择字典序最小的序列，从左到右比较整数列表。\n- 如果仍然存在平局，选择其扁平化坐标列表$\\left[x_0,y_0,x_1,y_1,\\dots,x_{L-1},y_{L-1}\\right]$字典序最小的构象。\n\n序列编码和输出表示：\n- 将序列编码为一个包含$L$个整数的列表，这些整数在$\\{0,1,2,3\\}$中，分别对应$\\mathrm{H},\\mathrm{P},\\mathrm{N},\\mathrm{C}$。\n- 将构象编码为一个包含$L$个坐标对的列表，每个坐标对是一个包含两个整数的列表$\\left[x_i,y_i\\right]$。\n\n您的程序必须执行穷举搜索，通过以下方式保证为下面给出的小规模测试用例找到精确的最优解：\n- 枚举方形晶格上所有长度为$L$且满足上述固定条件的自回避行走。\n- 枚举所有长度为$L$的、基于大小为$4$的字母表的序列。\n- 对每一对（序列和构象）精确计算$E$和$S$，并应用目标和决胜规则。\n\n测试套件：\n- 案例A（理想情况）：$L=6$, $e_{\\mathrm{HH}}=-1.0$, $e_{\\mathrm{NC}}=-2.0$, $e_{\\mathrm{like}}=+0.5$。\n- 案例B（盐桥主导）：$L=7$, $e_{\\mathrm{HH}}=0.0$, $e_{\\mathrm{NC}}=-2.5$, $e_{\\mathrm{like}}=+0.5$。\n- 案例C（强同种电荷排斥）：$L=6$, $e_{\\mathrm{HH}}=-0.5$, $e_{\\mathrm{NC}}=-1.0$, $e_{\\mathrm{like}}=+1.0$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表，每个结果对应一个测试用例，并与上面列出的顺序相同。\n- 每个结果必须是$[E_{\\min},S_{\\mathrm{best}},\\mathrm{seq},\\mathrm{coords}]$形式的列表，其中$E_{\\min}$是四舍五入到三位小数的最小能量（作为一个实数），$S_{\\mathrm{best}}$是所选解的盐桥数（作为一个整数），$\\mathrm{seq}$是所选序列，编码为$\\{0,1,2,3\\}$中的整数列表，$\\mathrm{coords}$是所选构象，按规定编码为坐标对列表。\n- 因此，最终输出必须是包含类似$[\\mathrm{r}_\\mathrm{A},\\mathrm{r}_\\mathrm{B},\\mathrm{r}_\\mathrm{C}]$内容的单行，其中每个$\\mathrm{r}_\\mathrm{X}$是对应案例的上述格式的列表。不要打印任何其他文本。",
            "solution": "所提出的问题是计算蛋白质结构预测框架内的一个受约束的优化任务。它要求对一个四字母疏水-极性-带负电-带正电（HPNC）晶格模型进行形式化和实现。其目标是找到一个多肽序列及其在二维（$2$D）方形晶格上对应的自回避构象，二者协同作用，在结构必须包含至少一个盐桥的约束下，达到最小可能的加性接触能量。盐桥被定义为带负电（$\\mathrm{N}$）残基和带正电（$\\mathrm{C}$）残基之间的非共价接触。\n\n该问题提法明确，科学上基于粗粒化蛋白质模型的原理，并为确定唯一解提供了所有必要的定义和参数。该模型是经典疏水-极性（HP）模型的扩展，它引入了静电效应，这是该领域的标准方法。鉴于指定的序列长度较小（$L=6$和$L=7$），对完整的构象和序列空间进行穷举搜索在计算上是可行的，并且是保证找到由分层目标函数所定义的真正全局最优解的唯一方法。\n\n因此，该解决方案被设计为一个穷举搜索算法，该算法系统地探索所有有效的序列-构象对，对它们进行评估，并根据指定的标准识别出最优对。该算法按以下步骤进行：\n\n首先，我们必须生成所有可能的分子实体的整个空间。这个空间是所有唯一的、有效构象的集合与所有可能的长度为$L$的序列的集合的笛卡尔积。\n\n构象是二维方形晶格上长度为$L$的自回避行走。为了生成所有此类构象，我们采用递归回溯（深度优先搜索）算法。将行走的前两个残基固定在坐标$(x_0,y_0)=(0,0)$和$(x_1,y_1)=(1,0)$处，以消除平凡的旋转和平移对称性。递归过程一次扩展一个残基的行走，探索所有四个基本方向，并确保新的晶格位点未被占据。当一个长度为$L$的行走完成时，它被添加到我们的有效构象列表中。\n\n序列是字母表$\\{\\mathrm{H}, \\mathrm{P}, \\mathrm{N}, \\mathrm{C}\\}$上长度为$L$的字符串，我们将其编码为整数$\\{0, 1, 2, 3\\}$。序列总数为$4^L$。这些序列被系统地生成，以确保每个可能的序列都被考虑到。这可以通过遍历所有$L$位的四进制数来实现。\n\n对于每个构象和序列对，我们必须计算其总能量$E$和盐桥数$S$。此评估分两步执行。\n1. 给定一个构象，我们首先确定其接触集$\\mathcal{C}$。一个接触是一个无序的残基索引对$(i,j)$，其中这两个残基在序列上不相邻（$|i-j| \\ge 2$），但在晶格上占据相邻的位点。邻接性通过检查其坐标之间的曼哈顿距离是否等于$1$来确定。\n2. 利用接触集$\\mathcal{C}$和序列$\\{t_i\\}_{i=0}^{L-1}$，我们计算总能量$E$和盐桥数$S$。总能量是成对相互作用能量的总和，$E = \\sum_{(i,j)\\in\\mathcal{C}}\\varepsilon(t_i, t_j)$。能量函数$\\varepsilon(a,b)$由问题参数$e_{\\mathrm{HH}}$、$e_{\\mathrm{NC}}$和$e_{\\mathrm{like}}$定义，并且仅对于$\\mathrm{H}-\\mathrm{H}$、$\\mathrm{N}-\\mathrm{C}$、$\\mathrm{N}-\\mathrm{N}$和$\\mathrm{C}-\\mathrm{C}$接触非零。盐桥数$S$是接触集$\\mathcal{C}$中残基类型为$\\{\\mathrm{N}, \\mathrm{C}\\}$的接触数量。\n\n最后，我们确定最优解。搜索必须遵守一个严格的、四级的决胜规则。我们旨在：\n1. 最小化总能量$E$。\n2. 对于给定的最小$E$，最大化盐桥数$S$。\n3. 对于给定的$E$和$S$，选择字典序最小的序列（使用整数编码）。\n4. 作为最后的决胜方法，选择其扁平化坐标列表字典序最小的构象。\n\n这种分层优化是通过在整个穷举搜索过程中维护一个“迄今为止最优”的单一解来实现的。每个新的有效候选解（即$S \\ge 1$的解）都与当前最优解进行比较。如果一个候选解对应的目标元组比当前最优解的元组在字典序上更小，则该候选解被认为是“更优的”。对于一个由序列$\\mathbf{t}$和构象$\\mathbf{x}$组成的候选解，其目标元组构造为$(E, -S, \\mathbf{t}, \\mathbf{x}_{\\text{flat}})$，其中$\\mathbf{t}$是整数编码的残基类型的元组，$\\mathbf{x}_{\\text{flat}}$是扁平化的坐标元组。对$S$取负可以正确地将最大化$S$的问题转化为最小化问题，从而适应字典序比较的框架。通过遍历所有序列-构象对并应用此比较，该算法保证能够收敛到问题陈述所定义的唯一最优解。",
            "answer": "```python\nimport numpy as np\nimport itertools\n\ndef generate_conformations(L):\n    \"\"\"\n    Generates all self-avoiding walks of length L on a 2D square lattice,\n    anchored at (0,0) and (1,0).\n    \"\"\"\n    if L  2:\n        return []\n\n    # Anchored start as specified\n    path = [(0, 0), (1, 0)]\n    if L == 2:\n        return [tuple(path)]\n    \n    visited = set(path)\n    conformations = []\n    \n    def extend_walk(current_path, visited_sites):\n        if len(current_path) == L:\n            conformations.append(tuple(current_path))\n            return\n            \n        last_x, last_y = current_path[-1]\n        # Possible moves: North, South, East, West\n        moves = [(last_x, last_y + 1), (last_x, last_y - 1), (last_x + 1, last_y), (last_x - 1, last_y)]\n        \n        for next_pos in moves:\n            if next_pos not in visited_sites:\n                current_path.append(next_pos)\n                visited_sites.add(next_pos)\n                extend_walk(current_path, visited_sites)\n                visited_sites.remove(next_pos) # Backtrack\n                current_path.pop()\n\n    extend_walk(path, visited)\n    return conformations\n\ndef find_contacts(conf, L):\n    \"\"\"\n    Finds all non-consecutive nearest-neighbor contacts for a given conformation.\n    \"\"\"\n    contacts = []\n    for i in range(L - 1):\n        for j in range(i + 2, L):\n            xi, yi = conf[i]\n            xj, yj = conf[j]\n            if abs(xi - xj) + abs(yi - yj) == 1:\n                contacts.append((i, j))\n    return contacts\n\ndef make_energy_matrix(e_HH, e_NC, e_like):\n    \"\"\"\n    Creates the 4x4 pairwise energy matrix.\n    Encoding: H=0, P=1, N=2, C=3\n    \"\"\"\n    energy_matrix = np.zeros((4, 4), dtype=float)\n    energy_matrix[0, 0] = e_HH\n    energy_matrix[2, 3] = e_NC\n    energy_matrix[3, 2] = e_NC\n    energy_matrix[2, 2] = e_like\n    energy_matrix[3, 3] = e_like\n    return energy_matrix\n\ndef evaluate(seq, contacts, energy_matrix):\n    \"\"\"\n    Calculates total energy E and salt bridge count S for a sequence and its contacts.\n    \"\"\"\n    E = 0.0\n    S = 0\n    N_type, C_type = 2, 3\n    \n    for i, j in contacts:\n        type1, type2 = seq[i], seq[j]\n        E += energy_matrix[type1, type2]\n        if (type1 == N_type and type2 == C_type) or (type1 == C_type and type2 == N_type):\n            S += 1\n    return E, S\n\ndef find_optimal_structure(L, e_HH, e_NC, e_like):\n    \"\"\"\n    Performs the exhaustive search for the optimal sequence and conformation.\n    \"\"\"\n    energy_matrix = make_energy_matrix(e_HH, e_NC, e_like)\n    \n    all_conformations = generate_conformations(L)\n    \n    best_result_tuple = (float('inf'),)\n    best_solution_details = None\n\n    # Pre-calculate contacts for each conformation\n    conf_contacts = {conf: find_contacts(conf, L) for conf in all_conformations}\n    \n    # Iterate through all sequences and conformations to find the optimum\n    for seq in itertools.product(range(4), repeat=L):\n        seq_tuple = tuple(seq)\n        for conf in all_conformations:\n            contacts = conf_contacts[conf]\n            E, S = evaluate(seq_tuple, contacts, energy_matrix)\n\n            if S  1:\n                continue\n\n            conf_flat_tuple = tuple(coord for pair in conf for coord in pair)\n            current_result_tuple = (E, -S, seq_tuple, conf_flat_tuple)\n\n            if best_solution_details is None or current_result_tuple  best_result_tuple:\n                best_result_tuple = current_result_tuple\n                best_solution_details = (E, S, seq_tuple, conf)\n    \n    E, S, seq, conf = best_solution_details\n    return E, S, list(seq), [list(c) for c in conf]\n\ndef format_result_list(res_list):\n    \"\"\"\n    Formats the final result list for one test case into the required string format.\n    \"\"\"\n    E, S, seq, coords = res_list\n    E_str = f\"{E:.3f}\"\n    seq_str = str(seq).replace(\" \", \"\")\n    coords_str = str(coords).replace(\" \", \"\")\n    return f\"[{E_str},{S},{seq_str},{coords_str}]\"\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        # (L, e_HH, e_NC, e_like)\n        (6, -1.0, -2.0, 0.5),  # Case A\n        (7, 0.0, -2.5, 0.5),  # Case B\n        (6, -0.5, -1.0, 1.0),  # Case C\n    ]\n    \n    results = []\n    for L, e_HH, e_NC, e_like in test_cases:\n        E_min, S_best, seq, coords = find_optimal_structure(L, e_HH, e_NC, e_like)\n        results.append([E_min, S_best, seq, coords])\n    \n    final_output_str_parts = [format_result_list(res) for res in results]\n    final_output = f\"[{','.join(final_output_str_parts)}]\"\n    print(final_output)\n\n# Execute the solver\nsolve()\n```"
        },
        {
            "introduction": "在探索了离散的晶格模型之后，这个实践将我们的焦点转移到能量景观的连续性上。您将处理一个简化的二维能量函数，该函数模拟了主链扭转角 $(\\phi, \\psi)$ 的内在能量偏好。通过寻找全局能量最低点，您将直接体验到相互竞争的因素，例如形成 $\\alpha$-螺旋与 $\\beta$-折叠构象的倾向性和空间位阻的排斥作用，是如何共同塑造出一个复杂的能量表面的。",
            "id": "2369985",
            "problem": "给定一个具有 $N$ 个残基的多肽的粗粒度、二维、周期性的类 Rosetta 能量代理函数，该函数以一对统一的主链二面角（单位为度）$\\phi \\in [-180, 180]$ 和 $\\psi \\in [-180, 180]$ 表示。目标是针对每个指定的参数集，计算能量函数在定义域 $[-180, 180] \\times [-180, 180]$ 上的全局最小值点 $(\\phi^\\star, \\psi^\\star)$ 和相应的最小能量 $E^\\star$，假设每个维度上的角度周期性为 $360$ 度。角度必须以度为单位报告，能量以任意单位报告。所有角度都必须以度为单位处理，所有角度差必须使用下面定义的周期性环绕（periodic wrapping）来计算。\n\n对于任意实值差 $d$（以度为单位），定义环绕角差函数 $w(d)$ 为\n$$\nw(d) \\equiv d - 360 \\cdot \\mathrm{round}\\!\\left(\\frac{d}{360}\\right),\n$$\n使得 $w(d) \\in (-180, 180]$ 是圆上的最短有符号差。\n\n设能量为\n$$\nE(\\phi,\\psi) = N \\left[ -a_\\alpha \\exp\\!\\left(-\\frac{1}{2}\\left(\\frac{w(\\phi - \\mu_{\\alpha,\\phi})^2}{\\sigma_{\\alpha,\\phi}^2} + \\frac{w(\\psi - \\mu_{\\alpha,\\psi})^2}{\\sigma_{\\alpha,\\psi}^2}\\right)\\right) - a_\\beta \\exp\\!\\left(-\\frac{1}{2}\\left(\\frac{w(\\phi - \\mu_{\\beta,\\phi})^2}{\\sigma_{\\beta,\\phi}^2} + \\frac{w(\\psi - \\mu_{\\beta,\\psi})^2}{\\sigma_{\\beta,\\psi}^2}\\right)\\right) \\right.\n$$\n$$\n\\left. + \\; p_{\\mathrm{clash}} \\exp\\!\\left(-\\frac{1}{2}\\left(\\frac{w(\\phi - \\mu_{c,\\phi})^2}{\\sigma_{c}^2} + \\frac{w(\\psi - \\mu_{c,\\psi})^2}{\\sigma_{c}^2}\\right)\\right) \\right] + (N-4)\\, w_{\\mathrm{hb}} \\left[ -h_\\alpha \\exp\\!\\left(-\\frac{1}{2}\\left(\\frac{w(\\phi - \\mu_{\\alpha,\\phi})^2}{\\sigma_{\\alpha,\\phi}^2} + \\frac{w(\\psi - \\mu_{\\alpha,\\psi})^2}{\\sigma_{\\alpha,\\psi}^2}\\right)\\right) \\right].\n$$\n\n第一个方括号模拟了残基局部的拉马钱德兰倾向性（Ramachandran propensities），包含两个有利的势阱（一个以 $(\\mu_{\\alpha,\\phi}, \\mu_{\\alpha,\\psi})$ 为中心的 $\\alpha$-螺旋盆地和一个以 $(\\mu_{\\beta,\\phi}, \\mu_{\\beta,\\psi})$ 为中心的 $\\beta$-折叠盆地）以及一个以 $(\\mu_{c,\\phi}, \\mu_{c,\\psi})$ 为中心的空间位阻（steric clash）惩罚项。第二个方括号模拟了在螺旋结构中更有利的 $i \\leftrightarrow i+4$ 氢键的标度效应。常数 $(\\sigma_{\\alpha,\\phi}, \\sigma_{\\alpha,\\psi})$、$(\\sigma_{\\beta,\\phi}, \\sigma_{\\beta,\\psi})$ 和 $\\sigma_c$ 是以度为单位的宽度参数。\n\n使用固定的中心和宽度\n- $\\mu_{\\alpha,\\phi} = -57$, $\\mu_{\\alpha,\\psi} = -47$,\n- $\\mu_{\\beta,\\phi} = -135$, $\\mu_{\\beta,\\psi} = 135$,\n- $\\mu_{c,\\phi} = 0$, $\\mu_{c,\\psi} = 0$,\n- $\\sigma_{\\alpha,\\phi} = 18$, $\\sigma_{\\alpha,\\psi} = 18$,\n- $\\sigma_{\\beta,\\phi} = 20$, $\\sigma_{\\beta,\\psi} = 20$,\n- $\\sigma_{c} = 15$.\n\n对于下面列出的每个参数集 $(N, a_\\alpha, a_\\beta, p_{\\mathrm{clash}}, w_{\\mathrm{hb}}, h_\\alpha)$，计算\n- 在 $[-180,180] \\times [-180,180]$ 范围内的全局最小值角度 $(\\phi^\\star, \\psi^\\star)$（周期性等价类中的任何代表都是可接受的），以及\n- 最小能量 $E^\\star = \\min_{\\phi,\\psi} E(\\phi,\\psi)$。\n\n测试套件（按顺序求解三个参数集）：\n1. $(N, a_\\alpha, a_\\beta, p_{\\mathrm{clash}}, w_{\\mathrm{hb}}, h_\\alpha) = (30, 1.0, 0.8, 1.5, 0.2, 2.0)$。\n2. $(N, a_\\alpha, a_\\beta, p_{\\mathrm{clash}}, w_{\\mathrm{hb}}, h_\\alpha) = (30, 1.0, 1.6, 1.5, 0.05, 2.0)$。\n3. $(N, a_\\alpha, a_\\beta, p_{\\mathrm{clash}}, w_{\\mathrm{hb}}, h_\\alpha) = (30, 0.4, 0.4, 3.0, 0.25, 2.5)$。\n\n角度单位要求：所有角度必须以度为单位。用度表示 $\\phi^\\star$ 和 $\\psi^\\star$。最终的数值输出必须按如下方式四舍五入：\n- $E^\\star$ 四舍五入到小数点后 $3$ 位，\n- $\\phi^\\star$ 四舍五入到小数点后 $1$ 位，\n- $\\psi^\\star$ 四舍五入到小数点后 $1$ 位。\n\n最终输出格式：您的程序应生成单行输出，包含一个由三个列表组成的列表，每个测试用例对应一个列表，其中每个内部列表在四舍五入后按 $[E^\\star, \\phi^\\star, \\psi^\\star]$ 的顺序排列，例如 $[[e_1,\\phi_1,\\psi_1],[e_2,\\phi_2,\\psi_2],[e_3,\\phi_3,\\psi_3]]$。\n\n不提供用户输入；所有值均如上所述。您的程序必须确定性地计算三个参数集的全局最小值点和最小能量，同时遵守角度的周期性和上述定义。",
            "solution": "对问题陈述进行验证。\n\n**步骤 1：提取已知条件**\n- **目标**：对于给定的能量函数 $E(\\phi, \\psi)$，找到全局最小值点 $(\\phi^\\star, \\psi^\\star)$ 和最小能量 $E^\\star$。\n- **定义域**：$(\\phi, \\psi) \\in [-180, 180] \\times [-180, 180]$ 度，具有周期为 $360$ 度的周期性边界条件。\n- **环绕角差**：$w(d) \\equiv d - 360 \\cdot \\mathrm{round}\\!\\left(\\frac{d}{360}\\right)$，结果范围为 $w(d) \\in (-180, 180]$。\n- **能量函数**：\n$$\nE(\\phi,\\psi) = N \\left[ -a_\\alpha G_\\alpha(\\phi, \\psi) - a_\\beta G_\\beta(\\phi, \\psi) + p_{\\mathrm{clash}} G_c(\\phi, \\psi) \\right] + (N-4)\\, w_{\\mathrm{hb}} \\left[ -h_\\alpha G_\\alpha(\\phi, \\psi) \\right]\n$$\n其中高斯项定义为：\n$$\nG_\\alpha(\\phi, \\psi) = \\exp\\!\\left(-\\frac{1}{2}\\left(\\frac{w(\\phi - \\mu_{\\alpha,\\phi})^2}{\\sigma_{\\alpha,\\phi}^2} + \\frac{w(\\psi - \\mu_{\\alpha,\\psi})^2}{\\sigma_{\\alpha,\\psi}^2}\\right)\\right)\n$$\n$$\nG_\\beta(\\phi, \\psi) = \\exp\\!\\left(-\\frac{1}{2}\\left(\\frac{w(\\phi - \\mu_{\\beta,\\phi})^2}{\\sigma_{\\beta,\\phi}^2} + \\frac{w(\\psi - \\mu_{\\beta,\\psi})^2}{\\sigma_{\\beta,\\psi}^2}\\right)\\right)\n$$\n$$\nG_c(\\phi, \\psi) = \\exp\\!\\left(-\\frac{1}{2}\\left(\\frac{w(\\phi - \\mu_{c,\\phi})^2}{\\sigma_{c}^2} + \\frac{w(\\psi - \\mu_{c,\\psi})^2}{\\sigma_{c}^2}\\right)\\right)\n$$\n- **固定常数**（所有角度均以度为单位）：\n  - $\\mu_{\\alpha,\\phi} = -57$, $\\mu_{\\alpha,\\psi} = -47$\n  - $\\mu_{\\beta,\\phi} = -135$, $\\mu_{\\beta,\\psi} = 135$\n  - $\\mu_{c,\\phi} = 0$, $\\mu_{c,\\psi} = 0$\n  - $\\sigma_{\\alpha,\\phi} = 18$, $\\sigma_{\\alpha,\\psi} = 18$\n  - $\\sigma_{\\beta,\\phi} = 20$, $\\sigma_{\\beta,\\psi} = 20$\n  - $\\sigma_{c} = 15$\n- **参数集** $(N, a_\\alpha, a_\\beta, p_{\\mathrm{clash}}, w_{\\mathrm{hb}}, h_\\alpha)$:\n  1. $(30, 1.0, 0.8, 1.5, 0.2, 2.0)$\n  2. $(30, 1.0, 1.6, 1.5, 0.05, 2.0)$\n  3. $(30, 0.4, 0.4, 3.0, 0.25, 2.5)$\n- **输出格式**：\n  - $E^\\star$ 四舍五入到小数点后 $3$ 位。\n  - $\\phi^\\star, \\psi^\\star$ 四舍五入到小数点后 $1$ 位。\n  - 最终输出：一个列表的列表 `[[E_1, \\phi_1, \\psi_1], [E_2, \\phi_2, \\psi_2], [E_3, \\phi_3, \\psi_3]]`。\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学依据**：该问题具有科学依据。它提出了一个多肽的简化、粗粒度能量函数，这是计算结构生物学中的一种标准建模方法。这些项对应于拉马钱德兰倾向性、空间位阻和氢键，它们是决定蛋白质结构的基本相互作用。\n- **适定性**：该问题是适定的。目标是在一个紧凑域（二维环面 $\\mathbb{T}^2$）上找到一个连续函数 $E(\\phi, \\psi)$ 的全局最小值。根据极值定理，保证存在全局最小值。所提供的信息足以唯一确定此最小能量值 $E^\\star$。\n- **客观性**：该问题以精确、客观的数学语言陈述。所有参数和函数都有明确定义。\n\n在 $w(d)$ 的定义中存在一个微小的歧义。定义 $w(d) = d - 360 \\cdot \\mathrm{round}(d/360)$ 与范围 $w(d) \\in (-180, 180]$ 的组合在 $d = k \\cdot 180$（对于奇数整数 $k$）处不一致。例如，使用标准的“四舍六入五成双”约定，$\\mathrm{round}(-0.5)=0$，这导致 $w(-180) = -180$。这超出了指定的范围 $(-180, 180]$。然而，这只是边界上一个单点的奇点。由于在指定的周期性下，角度 $\\phi=-180^\\circ$ 和 $\\phi=180^\\circ$ 是等效的，并且问题要求最小值点的任何有效代表，因此这种歧义不关键，不会妨碍为连续能量函数找到解决方案。这个问题不会因为这个微小的不精确而失效。\n\n**步骤 3：结论与行动**\n问题是**有效的**。将提供解决方案。\n\n**解决方案**\n\n任务是在环面域 $(\\phi, \\psi) \\in [-180, 180] \\times [-180, 180]$ 上找到能量函数 $E(\\phi, \\psi)$ 的全局最小值。\n\n首先，我们简化能量 $E(\\phi, \\psi)$ 的表达式。涉及 $\\alpha$-螺旋高斯函数 $G_\\alpha(\\phi, \\psi)$ 的项可以组合在一起。\n$$\nE(\\phi,\\psi) = -N a_\\alpha G_\\alpha(\\phi, \\psi) - N a_\\beta G_\\beta(\\phi, \\psi) + N p_{\\mathrm{clash}} G_c(\\phi, \\psi) - (N-4) w_{\\mathrm{hb}} h_\\alpha G_\\alpha(\\phi, \\psi)\n$$\n这可以重写为：\n$$\nE(\\phi, \\psi) = -C_\\alpha G_\\alpha(\\phi, \\psi) - C_\\beta G_\\beta(\\phi, \\psi) + C_c G_c(\\phi, \\psi)\n$$\n其中有效系数为：\n$$\nC_\\alpha = N a_\\alpha + (N-4) w_{\\mathrm{hb}} h_\\alpha\n$$\n$$\nC_\\beta = N a_\\beta\n$$\n$$\nC_c = N p_{\\mathrm{clash}}\n$$\n请注意，对于所有测试用例，$N=30$，因此项 $(N-4)$ 是正的。因此，函数 $E(\\phi, \\psi)$ 是三个周期性二维高斯函数的和。其中两项，分别由 $-C_\\alpha$ 和 $-C_\\beta$ 缩放，是吸引势（能量阱），分别以 $(\\mu_{\\alpha,\\phi}, \\mu_{\\alpha,\\psi})$ 和 $(\\mu_{\\beta,\\phi}, \\mu_{\\beta,\\psi})$ 为中心。第三项，由 $C_c$ 缩放，是排斥势（能量壁垒），以 $(\\mu_{c,\\phi}, \\mu_{c,\\psi})$ 为中心。\n\n全局能量最小值点 $(\\phi^\\star, \\psi^\\star)$ 必须位于两个吸引中心之一的附近。确切位置是两个吸引势和一个排斥势之间平衡的结果。由于方程的超越性和环绕差函数 $w(d)$ 的存在，通过设置梯度 $\\nabla E(\\phi, \\psi) = \\mathbf{0}$ 来获得最小值的解析解是相当复杂的。\n\n需要一个稳健的数值策略。能量景观是连续的，并且只有有限数量的显著局部最小值，对应于 $G_\\alpha$ 和 $G_\\beta$ 项的吸引盆地。我们将采用局部优化算法来找到这两个主要盆地内的最小值，然后比较它们的能量值以确定全局最小值。\n\n方法如下：\n1.  对于每个参数集，计算系数 $C_\\alpha$、$C_\\beta$ 和 $C_c$。\n2.  为特定参数集定义能量函数 $E(\\phi, \\psi)$。\n3.  使用带有 Nelder-Mead 单纯形算法的 `scipy.optimize.minimize` 函数执行两次独立的数值最小化。该方法是合适的，因为它不需要梯度信息，这使其对于 $w(d)$ 梯度中的微小不连续性具有稳健性。\n    -   第一次最小化从 $\\alpha$-螺旋势阱的中心开始，$\\mathbf{x}_{0,\\alpha} = (\\mu_{\\alpha,\\phi}, \\mu_{\\alpha,\\psi}) = (-57, -47)$。\n    -   第二次最小化从 $\\beta$-折叠势阱的中心开始，$\\mathbf{x}_{0,\\beta} = (\\mu_{\\beta,\\phi}, \\mu_{\\beta,\\psi}) = (-135, 135)$。\n4.  比较这两次优化的结果，$((\\phi_\\alpha^\\star, \\psi_\\alpha^\\star), E_\\alpha^\\star)$ 和 $((\\phi_\\beta^\\star, \\psi_\\beta^\\star), E_\\beta^\\star)$。能量较低者即为给定参数的全局最小值。\n5.  使用周期性环绕函数将最终的最优角度 $(\\phi^\\star, \\psi^\\star)$ 归一化到区间 $(-180, 180]$，以确保标准表示。\n6.  根据问题规范对 $E^\\star$、$ \\phi^\\star$ 和 $\\psi^\\star$ 的最终值进行四舍五入。\n\n对所有三个提供的测试用例重复此过程。环绕角差函数 $w(d)$ 直接根据其定义实现，使用数值舍入，将形式为 $k.5$ 的值舍入到最近的偶数整数。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Solves for the global energy minimum of a peptide's surrogate energy function for three parameter sets.\n    \"\"\"\n\n    # --- Fixed constants ---\n    # Centers (mu) and widths (sigma) in degrees\n    mu_alpha_phi, mu_alpha_psi = -57.0, -47.0\n    mu_beta_phi, mu_beta_psi = -135.0, 135.0\n    mu_c_phi, mu_c_psi = 0.0, 0.0\n    \n    sigma_alpha_phi, sigma_alpha_psi = 18.0, 18.0\n    sigma_beta_phi, sigma_beta_psi = 20.0, 20.0\n    sigma_c = 15.0\n\n    # --- Test Cases ---\n    test_cases = [\n        # (N, a_alpha, a_beta, p_clash, w_hb, h_alpha)\n        (30, 1.0, 0.8, 1.5, 0.2, 2.0),\n        (30, 1.0, 1.6, 1.5, 0.05, 2.0),\n        (30, 0.4, 0.4, 3.0, 0.25, 2.5)\n    ]\n\n    results = []\n\n    # --- Helper functions ---\n    def w(d):\n        \"\"\"\n        Computes the wrapped angular difference in degrees.\n        d - 360 * round(d/360), result in [-180, 180]\n        \"\"\"\n        return d - 360.0 * np.round(d / 360.0)\n\n    def normalize_angle(angle):\n        \"\"\"\n        Normalizes an angle to the range (-180, 180].\n        \"\"\"\n        wrapped_angle = w(angle)\n        # Map -180 to 180 to conform to (-180, 180]\n        if wrapped_angle == -180.0:\n            return 180.0\n        return wrapped_angle\n\n    for params in test_cases:\n        N, a_alpha, a_beta, p_clash, w_hb, h_alpha = params\n\n        def energy_function(angles):\n            \"\"\"\n            The surrogate energy function E(phi, psi).\n            \"\"\"\n            phi, psi = angles[0], angles[1]\n            \n            # Gaussian term for alpha-helical region\n            term_alpha_exponent = -0.5 * (\n                (w(phi - mu_alpha_phi) / sigma_alpha_phi)**2 + \n                (w(psi - mu_alpha_psi) / sigma_alpha_psi)**2\n            )\n            g_alpha = np.exp(term_alpha_exponent)\n\n            # Gaussian term for beta-strand region\n            term_beta_exponent = -0.5 * (\n                (w(phi - mu_beta_phi) / sigma_beta_phi)**2 + \n                (w(psi - mu_beta_psi) / sigma_beta_psi)**2\n            )\n            g_beta = np.exp(term_beta_exponent)\n\n            # Gaussian term for steric clash region\n            term_clash_exponent = -0.5 * (\n                (w(phi - mu_c_phi) / sigma_c)**2 + \n                (w(psi - mu_c_psi) / sigma_c)**2\n            )\n            g_clash = np.exp(term_clash_exponent)\n            \n            # Ramachandran propensity term\n            e_rama = N * (-a_alpha * g_alpha - a_beta * g_beta + p_clash * g_clash)\n            \n            # Hydrogen-bond term\n            e_hb = 0.0\n            if N > 4:\n                e_hb = (N - 4) * w_hb * (-h_alpha * g_alpha)\n            \n            return e_rama + e_hb\n\n        # --- Optimization ---\n        # Starting points at the center of the two attractive wells\n        x0_alpha = np.array([mu_alpha_phi, mu_alpha_psi])\n        x0_beta = np.array([mu_beta_phi, mu_beta_psi])\n\n        # Minimize starting from the alpha-well\n        res_alpha = minimize(energy_function, x0_alpha, method='Nelder-Mead', options={'xatol': 1e-8, 'fatol': 1e-8})\n\n        # Minimize starting from the beta-well\n        res_beta = minimize(energy_function, x0_beta, method='Nelder-Mead', options={'xatol': 1e-8, 'fatol': 1e-8})\n\n        # Compare results to find the global minimum\n        if res_alpha.fun  res_beta.fun:\n            best_res = res_alpha\n        else:\n            best_res = res_beta\n            \n        e_star = best_res.fun\n        phi_star, psi_star = best_res.x\n\n        # --- Formatting Output ---\n        # Normalize angles to the (-180, 180] range\n        phi_final = normalize_angle(phi_star)\n        psi_final = normalize_angle(psi_star)\n\n        # Round values as specified\n        e_rounded = round(e_star, 3)\n        phi_rounded = round(phi_final, 1)\n        psi_rounded = round(psi_final, 1)\n\n        results.append([e_rounded, phi_rounded, psi_rounded])\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "现实世界中的蛋白质折叠问题涉及一个巨大且高维度的构象空间，无法通过穷举搜索来解决。本练习将向您介绍一种强大的元启发式方法——蚁群优化（Ant Colony Optimization），以应对这一挑战。您将实现该算法，为一个更真实的三维离格（off-lattice）蛋白质模型寻找低能量构象，从而学习基于记忆的搜索如何能够有效地探索能量景观中的有利区域。",
            "id": "2369960",
            "problem": "给定一个三维多肽骨架的粗粒度内坐标模型。考虑一个由 $N$ 个α-碳原子组成的链，这些原子通过固定的键长 $b$ 和固定的键角 $\\theta$ 连接。其内部自由度是骨架二面角 $\\{\\phi_i\\}$（$i \\in \\{3,4,\\dots,N-1\\}$），从第四个原子开始，每个新添加的原子对应一个二面角。该链的构建方式如下。将前三个原子放置在\n$p_0 = (0,0,0)$、$p_1 = (b,0,0)$ 和 $p_2 = (b + b\\cos\\theta, b\\sin\\theta, 0)$。对于 $i \\ge 3$，给定 $p_{i-3}, p_{i-2}, p_{i-1}$ 和一个二面角 $\\phi_i \\in [-\\pi,\\pi)$，定义单位向量 $u = \\frac{p_{i-1}-p_{i-2}}{\\|p_{i-1}-p_{i-2}\\|}$ 和 $v = \\frac{p_{i-2}-p_{i-3}}{\\|p_{i-2}-p_{i-3}\\|}$，法向量 $n = \\frac{v \\times u}{\\|v \\times u\\|}$，以及 $m = u \\times n$。然后将原子 $p_i$ 放置在：\n$$\np_i = p_{i-1} + b\\left( \\cos\\theta\\,(-u) + \\sin\\theta\\left(\\cos\\phi_i\\, m + \\sin\\phi_i\\, n\\right)\\right).\n$$\n\n对于由二面角 $\\Phi = (\\phi_3,\\dots,\\phi_{N-1})$ 指定的构象，其约化单位下的总能量定义为\n$$\nE(\\Phi) = E_{\\text{tors}}(\\Phi) + E_{\\text{nb}}(\\Phi),\n$$\n其中扭转项为\n$$\nE_{\\text{tors}}(\\Phi) = k_t \\sum_{i=3}^{N-1} \\left(1 + \\cos(3\\phi_i)\\right),\n$$\n非键合项是位于不相邻原子之间的Lennard-Jones势：\n$$\nE_{\\text{nb}}(\\Phi) = \\sum_{\\substack{0 \\le i  j \\le N-1 \\\\ j - i  2}} 4\\varepsilon\\left[\\left(\\frac{\\sigma}{r_{ij}}\\right)^{12} - \\left(\\frac{\\sigma}{r_{ij}}\\right)^{6}\\right],\n$$\n其中 $r_{ij} = \\|p_i - p_j\\|$。长度单位使用埃（Å），角度单位使用弧度，能量单位与 $\\varepsilon$ 的约化单位相同。\n\n考虑一个基于离散内存的、关于二面角的概率性构建过程。对于每个二面角索引 $k \\in \\{3,4,\\dots,N-1\\}$，将定义域 $[-\\pi,\\pi)$ 离散化为 $B$ 个等宽的区间，其中心为 $\\{\\varphi_{k,b}\\}_{b=1}^B$。维护一个非负内存矩阵（“信息素”内存）$T \\in \\mathbb{R}_{\\ge 0}^{(N-3)\\times B}$，其元素为 $T_{k,b}$，并统一初始化为 $T_{k,b} = \\tau_0$。为每个区间定义一个启发式权重：\n$$\n\\eta_{k,b} = \\exp\\left(-\\frac{k_t\\left(1 + \\cos(3\\varphi_{k,b})\\right)}{T_h}\\right),\n$$\n其中温度 $T_h  0$。对于参数 $\\alpha  0$ 和 $\\beta \\ge 0$，在二面角索引 $k$ 处选择区间 $b$ 的概率定义为：\n$$\n\\mathbb{P}(\\text{choose } b \\mid k) = \\frac{T_{k,b}^{\\alpha}\\,\\eta_{k,b}^{\\beta}}{\\sum_{b'=1}^{B} T_{k,b'}^{\\alpha}\\,\\eta_{k,b'}^{\\beta}}.\n$$\n一次迭代包括：根据跨索引 $k$ 的乘积分布，通过对每个二面角进行一次区间独立采样，生成 $M$ 个完整的角度序列 $\\Phi$；对每个序列计算其能量 $E(\\Phi)$；选择该次迭代中能量最低的单个样本，其能量为 $E^\\star$；然后使用蒸发率 $\\rho \\in (0,1)$ 和在所选区间 $\\{b_k^\\star\\}$ 上的秩-1 沉积来更新内存：\n$$\nT_{k,b} \\leftarrow (1-\\rho) T_{k,b} \\quad \\text{for all } k,b,\n$$\n$$\nT_{k,b_k^\\star} \\leftarrow T_{k,b_k^\\star} + Q\\exp\\left(-\\frac{E^\\star}{T_d}\\right) \\quad \\text{for all } k,\n$$\n随后将 $T_{k,b}$ 的值限制在 $[\\tau_{\\min}, \\tau_{\\max}]$ 区间内，$T_{k,b} \\leftarrow \\min\\{\\tau_{\\max}, \\max\\{\\tau_{\\min}, T_{k,b}\\}\\}$，其中 $\\tau_{\\min}  0$ 且 $\\tau_{\\max}  \\tau_{\\min}$。重复 $I$ 次迭代，并返回在所有样本和所有迭代中遇到的最低能量。\n\n在所有运行中使用以下固定的物理和能量常数：\n- 键长 $b = 3.8$ Å。\n- 键角 $\\theta = 111.5^\\circ$（在计算中使用弧度；$\\theta \\approx 1.946$）。\n- Lennard-Jones参数 $\\varepsilon = 0.1$ 和 $\\sigma = 4.0$（单位为Å）。\n- 扭转刚度 $k_t = 0.1$。\n- 启发式温度 $T_h = 1.0$。\n- 沉积强度 $Q = 1.0$ 和沉积温度 $T_d = 1.0$。\n- 信息素初始化 $\\tau_0 = 1.0$，下限 $\\tau_{\\min} = 10^{-6}$，上限 $\\tau_{\\max} = 100.0$。\n\n你的任务是实现上述过程，并在以下测试集上执行。对于每个测试用例，使用一个由给定种子初始化的独立伪随机数生成器，并报告找到的最佳（最低）能量 $E$。将每个答案表示为四舍五入到三位小数的浮点数。\n\n测试集（角度单位为弧度，长度单位为Å，能量单位为 $\\varepsilon$ 的单位）：\n- 用例 A（通用）：$N = 8, M = 25, I = 40, B = 36, \\alpha = 1.0, \\beta = 2.0, \\rho = 0.1$，随机种子 $s = 1234$。\n- 用例 B（边界长度）：$N = 4, M = 16, I = 25, B = 24, \\alpha = 1.0, \\beta = 1.0, \\rho = 0.3$，随机种子 $s = 202$。\n- 用例 C（不同平衡）：$N = 10, M = 20, I = 30, B = 24, \\alpha = 1.5, \\beta = 1.0, \\rho = 0.2$，随机种子 $s = 999$。\n\n最终输出格式：你的程序应生成单行输出，其中包含用例 A、B 和 C 的结果，形式为方括号括起来的逗号分隔列表，例如“[x_A,x_B,x_C]”。每个 $x$ 必须是按上述规定四舍五入的浮点值，不得包含任何额外文本。",
            "solution": "问题陈述已经过验证，被认定是有效的。这是一个在计算结构生物学领域中定义明确的问题，具体是使用粗粒度模型的*ab initio*蛋白质结构预测。所有物理参数、数学公式和算法定义均已提供，并且在科学上是合理的、内部是一致的。该问题是一个标准的能量最小化任务，为此，指定的元启发式算法，即蚁群优化（ACO）的一种变体，是一种合适的方法。不需要`scipy`库，因为所有必要的功能都由`numpy`提供。\n\n解决方案是通过遵循指定的程序来实现的。问题的核心是找到最小化总能量函数 $E(\\Phi)$ 的二面角集合 $\\Phi = (\\phi_3, \\dots, \\phi_{N-1})$。\n\n**1. 链几何结构构建**\n\n$N$ 个原子的三维坐标，表示为 $\\{p_i\\}_{i=0}^{N-1}$，是顺序生成的。前三个原子 $p_0, p_1, p_2$ 在 $xy$ 平面上建立一个初始参考系：\n$$p_0 = (0,0,0)$$\n$$p_1 = (b,0,0)$$\n$$p_2 = (b + b\\cos\\theta, b\\sin\\theta, 0)$$\n这里，$b$ 是固定键长，$\\theta$ 是固定键角。对于每个后续原子 $p_i$ ($i \\ge 3$)，其位置由前三个原子（$p_{i-3}, p_{i-2}, p_{i-1}$）的位置和单个内部自由度，即二面角 $\\phi_i$，决定。\n\n$p_i$ 的构建基于定义一个局部坐标系。令 $u$ 为沿键 $p_{i-2} \\to p_{i-1}$ 的单位向量，$v$ 为沿键 $p_{i-3} \\to p_{i-2}$ 的单位向量。\n$$u = \\frac{p_{i-1}-p_{i-2}}{\\|p_{i-1}-p_{i-2}\\|}, \\quad v = \\frac{p_{i-2}-p_{i-3}}{\\|p_{i-2}-p_{i-3}\\|}$$\n包含这两个键的平面的法向量 $n$ 由它们的叉积给出，$n = \\text{normalize}(v \\times u)$。第三个向量 $m = u \\times n$ 完成了一个右手正交基 $\\{u, m, n\\}$。然后，新原子 $p_i$ 的位置相对于 $p_{i-1}$ 放置，使得新键向量 $p_i - p_{i-1}$ 的长度为 $b$，与向量 $p_{i-1}-p_{i-2}$ 成 $\\pi-\\theta$ 角（从而保持键角 $\\theta$），并且其在垂直于 $u$ 的平面上的投影由二面角 $\\phi_i$ 旋转。这由给定的公式捕获：\n$$p_i = p_{i-1} + b\\left( \\cos\\theta\\,(-u) + \\sin\\theta\\left(\\cos\\phi_i\\, m + \\sin\\phi_i\\, n\\right)\\right)$$\n这种几何构建是分子建模中的一种标准方法，通常称为自然扩展参考系（NeRF）或类似的内坐标构建算法。\n\n**2. 能量函数**\n\n给定构象（由二面角集合 $\\Phi$ 指定）的势能是两项之和：一个扭转项和一个非键相互作用项。\n$$E(\\Phi) = E_{\\text{tors}}(\\Phi) + E_{\\text{nb}}(\\Phi)$$\n扭转能 $E_{\\text{tors}}$ 表示围绕骨架键旋转的能垒：\n$$E_{\\text{tors}}(\\Phi) = k_t \\sum_{i=3}^{N-1} \\left(1 + \\cos(3\\phi_i)\\right)$$\n项 $k_t$ 代表扭转弹簧的刚度。$3\\phi_i$ 的依赖关系模拟了类烷烃链中常见的三重旋转对称性。\n\n非键能量 $E_{\\text{nb}}$ 模拟了链中非近邻原子之间的范德华相互作用。它使用Lennard-Jones 12-6势计算：\n$$E_{\\text{nb}}(\\Phi) = \\sum_{\\substack{0 \\le i  j \\le N-1 \\\\ j - i  2}} 4\\varepsilon\\left[\\left(\\frac{\\sigma}{r_{ij}}\\right)^{12} - \\left(\\frac{\\sigma}{r_{ij}}\\right)^{6}\\right]$$\n这里，$r_{ij}$ 是原子 $p_i$ 和 $p_j$ 之间的欧几里得距离。参数 $\\varepsilon$ 和 $\\sigma$ 分别定义了势阱的深度和位置。条件 $j-i  2$ 正确地排除了键合邻居（如 $i, i+1$ 的1,2对）和键角邻居（如 $i, i+2$ 的1,3对），这些相互作用已由固定的键长和键角约束隐式处理。\n\n**3. 蚁群优化（ACO）算法**\n\n能量景观的高维和非凸性质使得寻找全局最小值成为一项不平凡的任务。该问题指定了一种基于ACO元启发式算法的随机优化算法。\n\n首先，将每个二面角的连续域 $[-\\pi, \\pi)$ 离散化为 $B$ 个区间。然后，对最优构象的搜索就转化为对最佳区间序列的搜索。\n\n该算法进行 $I$ 次迭代。在每次迭代中，构建 $M$ 个候选解（蚂蚁）。每只蚂蚁通过对每个二面角 $\\phi_k$（$k=3, \\dots, N-1$）进行概率性选择，来构建一个完整的二面角序列 $\\Phi$。为二面角 $k$ 选择区间 $b$ 的概率是两个组成部分的函数：\n-   **信息素轨迹 ($\\tau$)**：一个内存矩阵 $T$ 根据过去成功的解，存储了为每个二面角选择每个区间的“期望度”。条目 $T_{k,b}$ 对应于二面角 $k$ 的区间 $b$ 的信息素水平。\n-   **启发式信息 ($\\eta$)**：该项提供了关于选择质量的*先验*知识，与搜索历史无关。在这里，它基于二面角的局部扭转能：$\\eta_{k,b} = \\exp\\left(-\\frac{E_{\\text{tors}}(\\varphi_{k,b})}{T_h}\\right)$。能量较低的选择具有较高的启发式价值。\n\n选择第 $k$ 个二面角（对应于矩阵行 $k-3$）的区间 $b$ 的概率由下式给出：\n$$\\mathbb{P}(\\text{choose } b \\mid k) = \\frac{T_{k-3,b}^{\\alpha}\\,\\eta_{k-3,b}^{\\beta}}{\\sum_{b'=1}^{B} T_{k-3,b'}^{\\alpha}\\,\\eta_{k-3,b'}^{\\beta}}$$\n参数 $\\alpha$ 和 $\\beta$ 控制信息素轨迹与启发式信息的相对影响。\n\n在构建了 $M$ 个解并评估了它们的能量之后，使用迭代中能量为 $E^\\star$ 的单个最佳解来更新信息素矩阵。更新有两个阶段：\n1.  **蒸发**：所有信息素轨迹都统一乘以一个因子 $(1-\\rho)$，其中 $\\rho \\in (0,1)$ 是蒸发率。这可以防止过早收敛。\n$$T_{k,b} \\leftarrow (1-\\rho) T_{k,b}$$\n2.  **沉积**：对应于迭代最佳解 $\\{b_k^\\star\\}$ 中所做选择的轨迹被加强。沉积的信息素量与能量 $E^\\star$ 成反比。\n$$T_{k-3,b_k^\\star} \\leftarrow T_{k-3,b_k^\\star} + Q\\exp\\left(-\\frac{E^\\star}{T_d}\\right)$$\n最后，为了确保稳定性，信息素值被限制在 $\\tau_{\\min}$ 和 $\\tau_{\\max}$ 之间。整个过程在连续的迭代中引导搜索朝向构象空间中有希望的区域。在所有蚂蚁和所有迭代中找到的最低能量将作为最终结果报告。\n\n**4. 实现策略**\n\n所描述的算法是使用 `numpy` 库在 Python 中实现的，用于高效的数值和向量运算。一个主函数为一组给定的参数 $(N, M, I, B, \\alpha, \\beta, \\rho, s)$ 组织模拟。\n-   一个辅助函数 `build_chain` 接受一个二面角序列，并根据几何构造规则生成原子坐标 $\\{p_i\\}$。\n-   第二个辅助函数 `calculate_energy` 接受原子坐标和二面角来计算总能量 $E(\\Phi)$。`numpy` 的向量化操作被用来加速求和和势能计算。\n-   主 ACO 循环管理状态，包括信息素矩阵 $T$ 和全局找到的最佳能量。它使用一个 `numpy.random.Generator` 实例，为可复现性而设定种子，以执行二面角区间的概率采样。\n-   代码的结构是首先定义所有常量，然后是辅助函数，最后是主模拟驱动程序，该驱动程序将按规定为每个测试用例调用。",
            "answer": "```python\nimport numpy as np\n\n# Fixed physical and energetic constants\nBOND_LENGTH = 3.8  # b in Å\nBOND_ANGLE_DEG = 111.5\nBOND_ANGLE_RAD = np.deg2rad(BOND_ANGLE_DEG)  # theta in radians\nEPSILON = 0.1      # ε\nSIGMA = 4.0        # σ in Å\nKT = 0.1           # k_t\nT_H = 1.0          # T_h (Heuristic temperature)\nQ = 1.0            # Deposition strength\nT_D = 1.0          # Deposition temperature\nTAU_0 = 1.0        # Pheromone initialization\nTAU_MIN = 1e-6     # Pheromone floor\nTAU_MAX = 100.0    # Pheromone cap\n\ndef build_chain(dihedrals, N, b, theta):\n    \"\"\"Constructs the atomic coordinates for a given chain length and dihedrals.\"\"\"\n    if N == 0:\n        return np.array([])\n    \n    positions = np.zeros((N, 3))\n    if N > 1:\n        positions[1] = np.array([b, 0.0, 0.0])\n    if N > 2:\n        positions[2] = np.array([\n            b + b * np.cos(theta),\n            b * np.sin(theta),\n            0.0\n        ])\n\n    for i in range(3, N):\n        p_im1, p_im2, p_im3 = positions[i-1], positions[i-2], positions[i-3]\n        \n        # Define local frame vectors\n        u_vec = p_im1 - p_im2\n        u = u_vec / np.linalg.norm(u_vec)\n        \n        v_vec = p_im2 - p_im3\n        v = v_vec / np.linalg.norm(v_vec)\n        \n        cross_vu = np.cross(v, u)\n        n = cross_vu / np.linalg.norm(cross_vu)\n        \n        m = np.cross(u, n)\n        \n        phi_i = dihedrals[i - 3]\n        cos_phi = np.cos(phi_i)\n        sin_phi = np.sin(phi_i)\n\n        # Construct new atom position using the provided formula\n        new_bond_vector = -np.cos(theta) * u + np.sin(theta) * (cos_phi * m + sin_phi * n)\n        positions[i] = p_im1 + b * new_bond_vector\n        \n    return positions\n\ndef calculate_energy(positions, dihedrals, N, kt, eps, sigma):\n    \"\"\"Calculates the total energy of a conformation.\"\"\"\n    \n    # 1. Torsional energy\n    if dihedrals:\n        cos3_phi = np.cos(3 * np.array(dihedrals))\n        e_tors = kt * np.sum(1 + cos3_phi)\n    else:\n        e_tors = 0.0\n\n    # 2. Non-bonded Lennard-Jones energy\n    e_nb = 0.0\n    for i in range(N):\n        for j in range(i + 3, N):  # Condition j - i > 2\n            dist_sq = np.sum((positions[i] - positions[j])**2)\n            dist = np.sqrt(dist_sq)\n            \n            if dist > 0:\n                sigma_over_r = sigma / dist\n                sigma_over_r6 = sigma_over_r**6\n                sigma_over_r12 = sigma_over_r6**2\n                e_nb += 4 * eps * (sigma_over_r12 - sigma_over_r6)\n    \n    return e_tors + e_nb\n\ndef run_simulation(N, M, I, B, alpha, beta, rho, seed):\n    \"\"\"Runs the full ACO simulation for one test case.\"\"\"\n    \n    rng = np.random.default_rng(seed)\n    num_dihedrals = N - 3\n\n    if num_dihedrals = 0:\n        # Fixed geometry, only possible LJ energy. \n        # For N=3, no pair satisfies j-i>2, so energy is 0.\n        return 0.0\n    \n    # Discretize dihedral space\n    bin_width = 2 * np.pi / B\n    dihedral_bins = np.linspace(-np.pi + bin_width / 2, np.pi - bin_width / 2, B)\n\n    # Initialize pheromone matrix T\n    pheromone = np.full((num_dihedrals, B), TAU_0)\n    \n    # Pre-calculate heuristic matrix eta\n    torsional_heuristic_term = KT * (1 + np.cos(3 * dihedral_bins))\n    heuristic = np.exp(-torsional_heuristic_term / T_H)\n    \n    best_energy_global = float('inf')\n\n    for iteration in range(I):\n        iteration_samples = []\n        \n        # M ants construct solutions\n        for _ in range(M):\n            chosen_dihedrals = []\n            chosen_bin_indices = []\n            \n            for k in range(num_dihedrals):\n                probs = (pheromone[k] ** alpha) * (heuristic ** beta)\n                if np.sum(probs) > 0:\n                    probs /= np.sum(probs)\n                else: # Fallback to uniform if all probabilities are zero\n                    probs = np.ones(B) / B\n\n                chosen_bin_idx = rng.choice(B, p=probs)\n                chosen_bin_indices.append(chosen_bin_idx)\n                chosen_dihedrals.append(dihedral_bins[chosen_bin_idx])\n\n            # Evaluate the constructed conformation\n            positions = build_chain(chosen_dihedrals, N, BOND_LENGTH, BOND_ANGLE_RAD)\n            energy = calculate_energy(positions, chosen_dihedrals, N, KT, EPSILON, SIGMA)\n            \n            iteration_samples.append({'dihedrals': chosen_dihedrals, 'bins': chosen_bin_indices, 'energy': energy})\n\n        # Find best ant of the iteration\n        best_sample = min(iteration_samples, key=lambda x: x['energy'])\n        e_star = best_sample['energy']\n        \n        # Update global best energy\n        if e_star  best_energy_global:\n            best_energy_global = e_star\n\n        # Update pheromone trails\n        # 1. Evaporation\n        pheromone *= (1 - rho)\n\n        # 2. Deposition\n        deposition_amount = Q * np.exp(-e_star / T_D)\n        best_bins = best_sample['bins']\n        for k in range(num_dihedrals):\n            pheromone[k, best_bins[k]] += deposition_amount\n\n        # 3. Clamping\n        np.clip(pheromone, TAU_MIN, TAU_MAX, out=pheromone)\n\n    return best_energy_global\n\ndef solve():\n    \"\"\"Main solver function to run test cases.\"\"\"\n    \n    test_cases = [\n        # Case A: (N, M, I, B, alpha, beta, rho, seed)\n        (8, 25, 40, 36, 1.0, 2.0, 0.1, 1234),\n        # Case B\n        (4, 16, 25, 24, 1.0, 1.0, 0.3, 202),\n        # Case C\n        (10, 20, 30, 24, 1.5, 1.0, 0.2, 999),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, M, I, B, alpha, beta, rho, seed = case\n        best_energy = run_simulation(N, M, I, B, alpha, beta, rho, seed)\n        results.append(f\"{best_energy:.3f}\")\n        \n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}