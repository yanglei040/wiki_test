{
    "hands_on_practices": [
        {
            "introduction": "在蛋白质结构预测和设计中，确定侧链的最佳构象是一项基础而关键的任务。为了在巨大的构象空间中进行有效搜索，计算方法通常使用离散的“旋转异构体库”（rotamer library）。这个练习将引导你思考一个实际问题：增加旋转异构体的采样密度（例如，在Rosetta中使用 `--ex1` 和 `--ex2` 标志）如何影响计算成本和预测准确性，这是一个在计算速度和模型精度之间进行权衡的经典例子。",
            "id": "2381401",
            "problem": "您正在固定蛋白质主链上使用 Rosetta 侧链堆积协议 `pack_rotamers`，以从离散的旋转异构体库中分配侧链构象。该堆积器使用的能量函数可以写成一个成对可分解的和的形式\n$$\nE(\\{r_i\\}) \\;=\\; \\sum_{i} E_i(r_i) \\;+\\; \\sum_{(i,j)} E_{ij}(r_i, r_j),\n$$\n其中 $r_i$ 表示位置 $i$ 处选择的旋转异构体，$E_i$ 是单体项，$E_{ij}$ 是相邻位置之间的双体相互作用项。旋转异构体库将侧链二面角 $\\chi_1, \\chi_2, \\ldots$ 离散化为每个残基有限的一组状态。Rosetta 标志 `--ex1` 和 `--ex2` 分别围绕 $\\chi_1$ 和 $\\chi_2$ 的标准旋转异构体添加额外的采样，从而增加了每个残基可用的旋转异构体数量。在如上所述的固定主链、成对能量模型下，考虑启用这些标志对计算速度（墙钟时间）和堆积准确性（例如，在小的角度容差内恢复类天然的 $\\chi_1$ 或 $\\chi_2$ 以及实现有利相互作用的能力）的影响。\n\n选择所有与以下第一性原理推理最一致的陈述：扩大离散搜索空间如何影响运行时间，以及更精细地采样 $\\chi_1$ 或 $\\chi_2$ 如何影响识别低能量、类天然侧链排列的可能性。\n\nA. 单独启用 `--ex1` 通常会增加运行时间，并倾向于改善埋藏位点上类天然 $\\chi_1$ 的恢复，因为它减少了空间位阻最受限制的二面角的离散化误差；对 $\\chi_2$ 恢复的影响通常小于对 $\\chi_1$ 的影响。\n\nB. 单独启用 `--ex2` 通常会减少运行时间，因为添加额外的 $\\chi_2$ 旋转异构体允许堆积器考虑更少的 $\\chi_1$ 状态，从而缩小了有效搜索空间。\n\nC. 同时启用 `--ex1` 和 `--ex2` 会使每个残基的旋转异构体集合成倍增加，因此构建双体相互作用表 $\\sum_{(i,j)} E_{ij}(r_i, r_j)$ 的成本大约与每个残基的倍增因子的平方成正比，导致运行时间呈超线性增长。\n\nD. 添加额外的旋转异构体无法改善堆积器在固定主链上找到的最低能量，因为基础库中的离散最小值已经是最佳的；给优化器更多状态只会因过拟合而使能量变差。\n\nE. 对于表面极性残基，其柔性的 $\\chi_2$ 直接定向远端极性基团，启用 `--ex2` 在实现正确的氢键几何形状方面可能比启用 `--ex1` 产生更大的准确性增益，因为在这些位点上 $\\chi_2$ 更直接地控制这些相互作用。",
            "solution": "对问题陈述进行验证。\n\n**步骤 1：提取已知条件**\n-   **协议**：Rosetta 侧链堆积协议 `pack_rotamers`。\n-   **系统**：具有固定主链的蛋白质。\n-   **搜索空间**：一个离散的旋转异构体库，它将侧链二面角 $\\chi_1, \\chi_2, \\ldots$ 离散化。\n-   **能量函数**：一个成对可分解的和：$E(\\{r_i\\}) = \\sum_{i} E_i(r_i) + \\sum_{(i,j)} E_{ij}(r_i, r_j)$。其中，$r_i$ 是位置 $i$ 处的旋转异构体，$E_i$ 是单体（自能量）项，$E_{ij}$ 是双体（相互作用）项。\n-   **扰动**：Rosetta 标志 `--ex1` 和 `--ex2` 分别围绕 $\\chi_1$ 和 $\\chi_2$ 二面角的标准值添加额外的旋转异构体采样。\n-   **任务**：评估这些标志对计算速度（墙钟时间）和堆积准确性（恢复类天然构象和有利相互作用）影响的陈述。\n\n**步骤 2：使用提取的已知条件进行验证**\n-   **科学依据**：该问题植根于计算蛋白质结构预测和设计这一成熟领域。`pack_rotamers` 协议、离散旋转异构体库的使用以及成对能量函数是 Rosetta 框架和类似工具的标准组成部分。二面角（$\\chi_1, \\chi_2$）、空间位阻约束和氢键能等概念是结构生物学的基本原理。该问题在科学上是合理的。\n-   **适定性**：该问题定义了一个清晰的计算场景，并要求基于计算复杂性和生物物理学的既定原则对其后果进行定性分析。问题的结构旨在评估对组合优化问题中采样密度、计算成本和准确性之间权衡的理解。这是一个适定的概念性问题。\n-   **客观性**：该问题使用了计算生物学中的精确技术术语（例如，`pack_rotamers`、`rotamer library`、`dihedral angles`、`pairwise-decomposable`）。它没有主观或含糊不清的语言。\n\n**步骤 3：结论与行动**\n问题陈述在科学上是合理的、适定的、客观的且自洽的。它是有效的。解决方案将继续基于第一性原理分析每个选项。\n\n**基于原理的推导**\n在离散旋转异构体集上使用成对可分解能量函数进行侧链堆积的核心任务是一个组合优化问题。目标是找到最小化总能量 $E$ 的旋转异构体组合 $\\{r_i\\}$。这个问题属于 NP-hard 问题类。可能构象的总数是 $\\prod_i N_i$，其中 $N_i$ 是残基 $i$ 的离散旋转异构体的数量。\n\n`--ex1` 和 `--ex2` 标志通过为 $\\chi_1$ 和 $\\chi_2$ 二面角添加更多的采样点来增加每个残基的 $N_i$ 值。设一个残基的基线旋转异构体数量为 $N_i^{base}$。添加额外的采样会将其增加到 $N_i^{ex} > N_i^{base}$。\n\n1.  **对计算速度（运行时间）的影响**：运行时间有两个主要组成部分。\n    a.  **能量矩阵预计算**：必须为所有相互作用的残基对 $(i, j)$ 的所有旋转异构体对计算双体能量 $E_{ij}(r_i, r_j)$。一个对 $(i, j)$ 的成本与 $N_i \\times N_j$ 成正比。将每个残基的旋转异构体数量平均增加一个因子 $f$，会使该成本大约增加一个因子 $f^2$。\n    b.  **组合搜索**：用于寻找最低能量构象的算法（例如，模拟退火、置信传播）必须探索一个大得多的搜索空间。此搜索的复杂性随每个位置的旋转异构体数量而增长。\n    因此，启用 `--ex1` 或 `--ex2` 将明确地增加总搜索空间，从而增加找到解决方案所需的计算时间。\n\n2.  **对准确性的影响**：离散旋转异构体库是侧链连续构象空间的近似。真实的最低能量构象可能与库中的任何离散旋转异构体都不重合。这会产生离散化误差。\n    a.  **减少离散化误差**：通过添加更多旋转异构体（`--ex` 标志），构象空间的采样变得更密集。这减少了库中旋转异构体与真实最低能量构象之间的平均距离。因此，堆积器有更高概率找到一个在几何上更接近、能量上更低于真实最优解的状态。因此，增加采样密度可以提高准确性。\n    b.  **生物物理背景**：采样特定二面角的重要性取决于其环境。在空间拥挤的蛋白质核心中，近端二面角（如 $\\chi_1$）的微小变化可能因范德华碰撞而导致大的能量惩罚。在溶剂暴露的表面，侧链更灵活，远端二面角（如 $\\chi_2$、$\\chi_3$ 等）对于定位功能基团以形成特定的长程相互作用（如氢键）至关重要。\n\n**逐项分析**\n\n**A. 单独启用 --ex1 通常会增加运行时间，并倾向于改善埋藏位点上类天然 $\\chi_1$ 的恢复，因为它减少了空间位阻最受限制的二面角的离散化误差；对 $\\chi_2$ 恢复的影响通常小于对 $\\chi_1$ 的影响。**\n-   *增加运行时间*：正确。如前所述，增加旋转异构体的数量会扩大搜索空间，从而增加计算成本。\n-   *改善埋藏位点上类天然 $\\chi_1$ 的恢复*：正确。埋藏位点紧密堆积，使得避免空间位阻至关重要。$\\chi_1$ 二面角最靠近主链，因此空间位阻最受限制。对 $\\chi_1$ 进行更精细的采样可以在核心的狭窄范围内实现更好的拟合，从而减少离散化误差并提高其预测的准确性。\n-   *对 $\\chi_2$ 恢复的影响较小*：正确。`--ex1` 标志专门为 $\\chi_1$ 添加采样。虽然一个更好的 $\\chi_1$ 选择可以促进一个更好的 $\\chi_2$ 选择，但直接的改进是针对 $\\chi_1$ 的。主要的好处体现在被更精细采样的自由度上。\n**结论：正确。**\n\n**B. 单独启用 --ex2 通常会减少运行时间，因为添加额外的 $\\chi_2$ 旋转异构体允许堆积器考虑更少的 $\\chi_1$ 状态，从而缩小了有效搜索空间。**\n-   *减少运行时间*：不正确。添加旋转异构体总是会增加搜索空间的大小（$ \\prod_i N_i $），这必然导致运行时间的增加，而不是减少。\n-   *允许堆积器考虑更少的 $\\chi_1$ 状态*：不正确。这是一个无稽之谈。堆积器算法被赋予每个位置的一组旋转异构体，其中每个旋转异构体都是二面角（例如，$(\\chi_1, \\chi_2, \\dots)$）的完整规范。添加具有新 $\\chi_2$ 值的旋转异构体并不会消除那些具有旧 $\\chi_1$ 值的旋转异构体；它只是扩展了可用选项的总列表。\n**结论：不正确。**\n\n**C. 同时启用 --ex1 和 --ex2 会使每个残基的旋转异构体集合成倍增加，因此构建双体相互作用表 $\\sum_{(i,j)} E_{ij}(r_i, r_j)$ 的成本大约与每个残基的倍增因子的平方成正比，导致运行时间呈超线性增长。**\n-   *成倍增加旋转异构体集合*：正确。旋转异构体是二面角值的组合。如果 $\\chi_1$ 有 $k_1$ 个采样，$\\chi_2$ 有 $k_2$ 个采样，则有 $k_1 \\times k_2$ 个组合的 $(\\chi_1, \\chi_2)$ 状态。如果 `--ex1` 将 $k_1$ 增加一个因子 $f_1$，而 `--ex2` 将 $k_2$ 增加一个因子 $f_2$，则旋转异构体的总数增加一个因子 $f_1 f_2$。\n-   *成本...大约与...倍增因子的平方成正比*：正确。如上所述，为具有 $N_i$ 和 $N_j$ 个旋转异构体的两个残基预计算成对能量的规模为 $O(N_i N_j)$。如果 $N_i$ 和 $N_j$ 都增加一个因子 $f$，则成本按 $f^2$ 比例增加。这种二次增长主导了计算的这一阶段。\n-   *导致超线性运行时间增长*：正确。二次（$f^2$）增长是一种超线性增长。由于总运行时间的很大部分都用于此预计算，因此整体运行时间也将以超线性的方式增加。\n**结论：正确。**\n\n**D. 添加额外的旋转异构体无法改善堆积器在固定主链上找到的最低能量，因为基础库中的离散最小值已经是最佳的；给优化器更多状态只会因过拟合而使能量变差。**\n-   *无法改善最低能量*：不正确。可能找到的最低能量是所有提供的旋转异构体集合中的最小值。如果我们将基础旋转异构体集合表示为 $S_{base}$，将额外的旋转异构体表示为 $S_{extra}$，那么 $\\min_{r \\in S_{base} \\cup S_{extra}} E(r) \\le \\min_{r \\in S_{base}} E(r)$。能量只能改善（降低）或保持不变。添加更多搜索点提供了找到更好（更低能量）最小值的机会。\n-   *离散最小值...已经是最佳的*：不正确。它只是*在该离散集合内*是最佳的。它不是连续构象空间中的全局最优解。添加旋转异构体的目标是找到对该真实全局最优解的更好近似。\n-   *过拟合*：不正确。这个术语被误用了。过拟合与机器学习中的模型泛化有关。在寻找固定能量函数在一组离散点上的最小值的情况下，它没有意义。\n**结论：不正确。**\n\n**E. 对于表面极性残基，其柔性的 $\\chi_2$ 直接定向远端极性基团，启用 --ex2 在实现正确的氢键几何形状方面可能比启用 --ex1 产生更大的准确性增益，因为在这些位点上 $\\chi_2$ 更直接地控制这些相互作用。**\n-   *背景*：这涉及蛋白质表面的极性残基（例如，赖氨酸、精氨酸、谷氨酰胺）。这些残基受局部堆积的约束较小，更多地由特定的、有方向性的相互作用驱动，例如氢键，通常与溶剂或其他远端极性基团形成。\n-   *$\\chi_2$ 的作用*：对于许多长的极性侧链，$\\chi_1$ 控制着 C$_\\beta$ 碳附近的初始取向，而随后的二面角（如 $\\chi_2$）对负责氢键的末端功能基团的最终位置具有更大的杠杆臂效应。例如，在谷氨酰胺中，末端酰胺基团的位置对 $\\chi_2$ 和 $\\chi_3$ 高度敏感。\n-   *结论*：从生物物理学角度来看，这是合理的，并且是一个常见的观察结果：对于这类残基，为了实现最佳氢键而精确地定位末端极性基团，对远端二面角的敏感性要高于近端 $\\chi_1$。因此，增加对 $\\chi_2$ 的采样（`--ex2`）比增加对 $\\chi_1$ 的采样（`--ex1`）更能为精确建模这些相互作用带来好处。\n**结论：正确。**",
            "answer": "$$\\boxed{ACE}$$"
        },
        {
            "introduction": "在解决了侧链问题后，我们转向更具挑战性的主链折叠问题。基于片段的构象搜索是一种强大的策略，它通过拼接来自已知蛋白质结构的小片段来有效地探索构象空间。这个思想实验将挑战你预测当采样工具（片段库）与目标结构（从全 $ \\alpha $ 蛋白库中选择片段来折叠一个全 $ \\beta $ 蛋白）严重不匹配时会发生什么，从而深刻揭示构象搜索方法的偏差如何决定模拟的最终成败。",
            "id": "2381444",
            "problem": "在Rosetta框架中，基于片段的蛋白质结构预测方法会在一个由打分函数引导的蒙特卡洛（Monte Carlo, MC）搜索过程中，将从已知结构中提取的短主链片段（通常是$3$-mers和$9$-mers）插入到一个演化中的模型里。考虑一个对目标蛋白进行的假设性从头折叠（ab initio folding）计算，该蛋白的天然结构是全$\\beta$（all-$\\beta$）结构。由于失误，片段库完全由一个非冗余的全$\\alpha$（all-$\\alpha$）蛋白集合构建而成，因此片段的$\\phi$和$\\psi$扭转角分布主要占据$\\alpha$-螺旋区域。所有其他参数（温度方案、移动频率，以及低分辨率和全原子阶段的打分函数）均为标准设置。下列哪个结果最有可能发生？\n\nA. 搜索将严重偏向于$\\alpha$-螺旋构象；它将很少能采样到形成$\\beta$-折叠所必需的伸展的$\\beta$-链几何构型；结果，诱饵构象（decoys）将集中在螺旋拓扑结构中，与天然样的$\\beta$-折叠相比，其全原子和低分辨率打分都相对较差；并且该计算过程将表现出向低均方根偏差（RMSD）模型的收敛性很差。\n\nB. Rosetta全原子打分函数包含明确的$\\beta$-折叠氢键项，这将迫使通过片段插入形成的螺旋解旋并重排成$\\beta$-折叠，因此，搜索仍能高效地找到正确的折叠，其收敛性与使用匹配的片段库时相似。\n\nC. 因为片段很短（$3$-mers和$9$-mers），它们的二级结构内容是无关紧要的；只要有足够的蒙特卡洛步数，采样仍然是有效无偏的，并且将以不受影响的效率达到正确的$\\beta$拓扑。\n\nD. 移动集变得无效，因为$\\alpha$和$\\beta$区域的$\\phi$和$\\psi$扭转角限制不同，这导致频繁的违规并被确定性地拒绝；因此，马尔可夫链无法进行下去，模拟会提前终止。",
            "solution": "对问题陈述进行了严格评估，并认定其有效。它描述了计算蛋白质结构预测领域中一个科学上合理的情景，该情景设定良好、客观且内容完整。问题关注在蒙特卡洛搜索中使用构象偏向的移动集所产生的可预测结果，这是该领域的标准课题。\n\n该问题描述了一个使用Rosetta框架进行的*从头*(ab initio)蛋白质折叠模拟。在此方法中，构象空间通过蒙特卡洛（Monte Carlo, MC）搜索进行探索。一种关键的移动类型是插入主链扭转角片段，这些片段通常长度为$3$和$9$个残基（$3$-mers和$9$-mers），从已知蛋白质结构的片段库中提取。移动的接受与否由一个打分函数和Metropolis准则决定。\n\n问题的核心在于模拟中两个组成部分之间的冲突：\n1.  **采样偏差：** 片段库完全由全$\\alpha$蛋白构建。这意味着可用片段的扭转角（$\\phi$, $\\psi$）将主要处于Ramachandran图的$\\alpha$-螺旋区域（大约$\\phi \\approx -60^\\circ$, $\\psi \\approx -40^\\circ$）。因此，对主链构象进行显著改变的主要方法被严重偏向于产生和维持$\\alpha$-螺旋二级结构。\n2.  **目标结构：** 目标蛋白的天然结构为全$\\beta$结构。这意味着其组成残基应采用Ramachandran图的$\\beta$-链区域的扭转角（大约$\\phi \\approx -120^\\circ$, $\\psi \\approx +135^\\circ$）。由Rosetta打分函数定义的该蛋白的能量景观的全局最小值对应于这个全$\\beta$折叠。\n\n模拟的结果由这种有偏采样和能量景观之间的相互作用决定。MC搜索将按以下方式进行：\n- 片段插入移动将持续提出具有$\\alpha$-螺旋特征的局部构象。这将非常有效地采样螺旋拓扑。\n- 搜索将无法有效采样伸展的$\\beta$-链构象，因为所需的($\\phi$, $\\psi$)角度在片段库提供的移动集中系统性地缺失。尽管存在其他小扰动移动（`small`和`shear`），但在实际的模拟时间尺度上，它们不足以实现从紧凑的螺旋球状结构到伸展的$\\beta$-折叠拓扑的转变。\n- 因此，生成的构象（“诱饵构象”）将主要是螺旋构象。\n- Rosetta打分函数（包括低分辨率和全原子的）旨在识别天然折叠的能量优势。对于一个全$\\beta$蛋白，打分函数将正确地为天然的$\\beta$-折叠拓扑分配比任何非天然的螺旋排列低得多（更好）的能量。采样的螺旋诱饵构象将缺乏稳定天然$\\beta$-折叠所需的特定长程氢键网络和三级堆积，从而导致高（差）的打分。\n- 模拟将无法收敛。能量-RMSD图不会显示出典型的漏斗形状，在该形状中，能量最低的结构与天然态的均方根偏差（RMSD）很低。相反，搜索找到的能量最低的结构将是具有高RMSD的非天然螺旋紧凑状态。\n\n基于此理解，我们评估给出的选项：\n\n**A. 搜索将严重偏向于$\\alpha$-螺旋构象；它将很少能采样到形成$\\beta$-折叠所必需的伸展的$\\beta$-链几何构型；结果，诱饵构象（decoys）将集中在螺旋拓扑结构中，与天然样的$\\beta$-折叠相比，其全原子和低分辨率打分都相对较差；并且该计算过程将表现出向低均方根偏差（RMSD）模型的收敛性很差。**\n这个陈述是对预期结果的精确和准确的描述。采样因片段库而产生偏差，从而无法进入正确的构象空间区域。产生的诱饵构象是非天然的，因此得分很差。整体预测失败，表现为未能收敛到低RMSD的结构。\n**结论：正确。**\n\n**B. Rosetta全原子打分函数包含明确的$\\beta$-折叠氢键项，这将迫使通过片段插入形成的螺旋解旋并重排成$\\beta$-折叠，因此，搜索仍能高效地找到正确的折叠，其收敛性与使用匹配的片段库时相似。**\n这个陈述是不正确的。打分函数评估构象，它不会“强制”构象跨越巨大的动力学能垒进行重排。模拟通过可用移动定义的路径探索构象空间。如果移动没有导向正确的折叠，单靠打分函数无法弥补。低分辨率搜索将为全原子阶段产生糟糕的起始模型，而全原子精修使用的是局部扰动，无法将整个蛋白质的拓扑结构从全$\\alpha$转换为全$\\beta$。声称能“高效地”找到正确折叠并具有“相似的收敛性”是错误的。\n**结论：不正确。**\n\n**C. 因为片段很短（$3$-mers和$9$-mers），它们的二级结构内容是无关紧要的；只要有足够的蒙特卡洛步数，采样仍然是有效无偏的，并且将以不受影响的效率达到正确的$\\beta$拓扑。**\n这个陈述有根本性的缺陷。片段中编码的局部二级结构信息正是使用它们的原因。它极大地加速了对天然样局部构象的搜索。声称其内容“无关紧要”与基于片段组装的整个原则相悖。理论上，无限长的MC运行可以采样任何状态，但在实践中，强烈的偏差使得在任何可行的模拟时间内采样到正确折叠的概率变得极小。采样并非“有效无偏”；它是严重有偏的，并且效率将急剧下降，直至完全失败。\n**结论：不正确。**\n\n**D. 移动集变得无效，因为$\\alpha$和$\\beta$区域的$\\phi$和$\\psi$扭转角限制不同，这导致频繁的违规并被确定性地拒绝；因此，马尔可夫链无法进行下去，模拟会提前终止。**\n这个陈述误解了Rosetta算法。对扭转角没有硬性的“无效”限制，会导致确定性的拒绝和模拟终止。一个导致不利扭转角（例如，在Ramachandran图的禁区）的提议移动会从相应的打分项（例如`rama`）中获得高能量罚分。这使得根据Metropolis准则，该移动的接受概率极低，但这是一个概率性过程，而非确定性过程。马尔可夫链会继续进行，但它被困在构象空间的一个无效区域。模拟不会终止。\n**结论：不正确。**",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "现在，我们将理论付诸实践，将前面练习中的概念性思考转化为实际的代码。在这个动手编程练习中，你将构建一个简化的能量函数和构象搜索算法，以模拟丝氨酸磷酸化这一重要的翻译后修饰如何影响其主链构象。通过将物理化学原理（如静电和空间位阻）编码到能量项中，你将亲身体验计算方法如何被用来预测生物分子功能的结构基础。",
            "id": "2381408",
            "problem": "要求您形式化一个简化的构象搜索和打分问题，其灵感来源于 Rosetta 建模框架。您的程序必须模拟一个残基参数文件和一个磷酸化补丁 (Patch) 如何改变残基的主链构象偏好和预测的最低能量构象。\n\n科学基础。您必须从一个基本原则出发：在像 Rosetta 这样的基于知识的建模框架中，预测的构象是使总势能最小化的那一个。具体来说，如果 $E(\\boldsymbol{\\theta}; \\boldsymbol{\\lambda})$ 是一个关于构象变量 $\\boldsymbol{\\theta}$ 和参数 $\\boldsymbol{\\lambda}$ 的标量能量函数，那么预测的构象是任何能够最小化 $E$ 的 $\\boldsymbol{\\theta}^{\\star}$。化学身份或翻译后修饰状态的改变可以通过残基参数文件（基础身份）和补丁（修饰覆盖）来表示为 $\\boldsymbol{\\lambda}$ 的变化。因此，通过在丝氨酸上添加一个磷酸基团实现的磷酸化，可以被建模为统计扭转偏好的改变以及反映空间体积效应和静电相互作用的附加物理化学项。\n\n您将实现一个针对单个残基主链二面角 $\\phi$ 和 $\\psi$（以度为单位）的粗粒化、自洽的打分函数。总能量是多个可解释组分的总和，这些组分是对常见 Rosetta 术语的抽象：主链统计偏好、由增加的体积引起的空间位阻效应，以及一种环境方向性的静电或类氢键相互作用。您的程序必须在代码中将一个基础的“丝氨酸参数 (Serine params)”和一个“磷酸化丝氨酸补丁 (phospho-Serine Patch)”构建为数据结构，并应用它们来计算能量。\n\n需要实现的定义：\n- 角度以度（degree）为单位。能量以千卡/摩尔（kilocalories per mole）为单位。\n- 主链统计偏好被建模为两个各向异性高斯势阱的混合，分别代表 $\\alpha$-螺旋和 $\\beta$-折叠区域。对于残基类型 $r \\in \\{\\mathrm{Ser}, \\mathrm{pSer}\\}$，\n  $$\n  E_{\\mathrm{bb}}^{(r)}(\\phi,\\psi) \\;=\\; -d_{\\alpha}^{(r)} \\exp\\!\\left(-\\tfrac{1}{2}\\left(\\tfrac{\\phi-\\mu_{\\phi,\\alpha}}{\\sigma_{\\phi}}\\right)^{2} - \\tfrac{1}{2}\\left(\\tfrac{\\psi-\\mu_{\\psi,\\alpha}}{\\sigma_{\\psi}}\\right)^{2}\\right)\n  \\;-\\; d_{\\beta}^{(r)} \\exp\\!\\left(-\\tfrac{1}{2}\\left(\\tfrac{\\phi-\\mu_{\\phi,\\beta}}{\\sigma_{\\phi}}\\right)^{2} - \\tfrac{1}{2}\\left(\\tfrac{\\psi-\\mu_{\\psi,\\beta}}{\\sigma_{\\psi}}\\right)^{2}\\right).\n  $$\n  使用中心点 $\\left(\\mu_{\\phi,\\alpha},\\mu_{\\psi,\\alpha}\\right)=(-60,-45)$ 和 $\\left(\\mu_{\\phi,\\beta},\\mu_{\\psi,\\beta}\\right)=(-120,130)$（角度单位为度），以及宽度 $\\sigma_{\\phi}=\\sigma_{\\psi}=25$（度）。基础丝氨酸（“参数 (params)”）的势阱深度为 $d_{\\alpha}^{(\\mathrm{Ser})}=3.0$ 和 $d_{\\beta}^{(\\mathrm{Ser})}=2.0$。经磷酸化丝氨酸（“补丁 (Patch)”修饰）的势阱深度为 $d_{\\alpha}^{(\\mathrm{pSer})}=1.2$ 和 $d_{\\beta}^{(\\mathrm{pSer})}=3.2$。\n- 磷酸化补丁还增加了一个空间位阻惩罚项，该项因磷酸基团的体积而惩罚采取 $\\alpha$-螺旋构象的 $\\phi$ 角：\n  $$\n  E_{\\mathrm{steric}}^{(\\mathrm{pSer})}(\\phi) \\;=\\; + s_{0} \\exp\\!\\left(-\\tfrac{1}{2}\\left(\\tfrac{\\phi - \\mu_{\\phi,\\mathrm{steric}}}{\\sigma_{\\phi,\\mathrm{steric}}}\\right)^{2}\\right),\n  $$\n  其中 $\\mu_{\\phi,\\mathrm{steric}}=-60$，$\\sigma_{\\phi,\\mathrm{steric}}=15$，以及 $s_{0}=0.8$。对于未修饰的丝氨酸，此项为 $0$。\n- 环境可能为磷酸基团提供一个有利的方向性相互作用，该作用来自于附近的一个正电荷，并可近似地由一个以环境指定的目标 $\\psi_{0}$ 为中心的高斯函数来描述：\n  $$\n  E_{\\mathrm{env}}^{(\\mathrm{pSer})}(\\psi; k_{\\mathrm{el}}, \\psi_{0}) \\;=\\; - k_{\\mathrm{el}} \\exp\\!\\left(-\\tfrac{1}{2}\\left(\\tfrac{\\psi - \\psi_{0}}{\\sigma_{\\psi,\\mathrm{el}}}\\right)^{2}\\right),\n  $$\n  其中 $\\sigma_{\\psi,\\mathrm{el}}=25$。此项以粗粒化的方式模拟了静电或类氢键的方向性偏好。如果附近不存在正电荷，则设置 $k_{\\mathrm{el}}=0$。对于未修饰的丝氨酸，此项为 $0$。\n- 总能量为\n  $$\n  E_{\\mathrm{total}}^{(r)}(\\phi,\\psi) \\;=\\; E_{\\mathrm{bb}}^{(r)}(\\phi,\\psi) \\;+\\; \\mathbb{1}[r=\\mathrm{pSer}] \\left( E_{\\mathrm{steric}}^{(\\mathrm{pSer})}(\\phi) + E_{\\mathrm{env}}^{(\\mathrm{pSer})}(\\psi; k_{\\mathrm{el}}, \\psi_{0}) \\right).\n  $$\n  此处 $\\mathbb{1}[\\cdot]$ 是指示函数，当条件为真时其值为 $1$，否则为 $0$。\n\n计算任务：\n- 在代码中为丝氨酸构建一个“参数 (params)”数据结构，包含 $d_{\\alpha}^{(\\mathrm{Ser})}$ 和 $d_{\\beta}^{(\\mathrm{Ser})}$ 以及共享的高斯中心和宽度。在代码中构建一个磷酸化“补丁 (Patch)”，当它应用于丝氨酸参数时，会产生 pSer 参数 $d_{\\alpha}^{(\\mathrm{pSer})}$ 和 $d_{\\beta}^{(\\mathrm{pSer})}$，并添加 $E_{\\mathrm{steric}}^{(\\mathrm{pSer})}$ 和 $E_{\\mathrm{env}}^{(\\mathrm{pSer})}$ 这两个项及上述常量。应用补丁不得改变打分函数的任何其他方面。\n- 实现一个在 $\\phi \\in \\{-180,-175,\\ldots,180\\}$ 和 $\\psi \\in \\{-180,-175,\\ldots,180\\}$（均以度为单位）上的网格搜索，以在相同的环境参数下为 Ser 和 pSer 找到最低能量构象。\n- 对于下方的每个测试用例，计算：\n  1. 能量最低的主链二面角 $(\\phi^{\\star}_{\\mathrm{Ser}},\\psi^{\\star}_{\\mathrm{Ser}})$ 和 $(\\phi^{\\star}_{\\mathrm{pSer}},\\psi^{\\star}_{\\mathrm{pSer}})$，以度为单位。\n  2. 带符号的、折叠后的角差 $\\Delta \\phi$ 和 $\\Delta \\psi$，每个都通过映射 $\\Delta \\theta \\mapsto \\left((\\Delta \\theta + 180) \\bmod 360\\right) - 180$ 折叠到 $(-180,180]$ 区间内，其中 $\\Delta \\theta = \\theta^{\\star}_{\\mathrm{pSer}} - \\theta^{\\star}_{\\mathrm{Ser}}$。\n  3. 能量变化 $\\Delta E = E_{\\min}^{(\\mathrm{pSer})} - E_{\\min}^{(\\mathrm{Ser})}$，以千卡/摩尔为单位。\n\n测试套件（三种环境）：\n- 案例1（理想情况）：附近有正电荷，且与 $\\alpha$-螺旋类几何构象对齐。使用 $k_{\\mathrm{el}}=1.5$ 和 $\\psi_{0}=-60$。\n- 案例2（无方向性稳定作用）：附近无正电荷。使用 $k_{\\mathrm{el}}=0.0$ 和 $\\psi_{0}=0.0$。\n- 案例3（在 $\\beta$ 区域附近存在竞争性稳定作用）：有较弱的正电荷，且与 $\\beta$-折叠类几何构象对齐。使用 $k_{\\mathrm{el}}=0.9$ 和 $\\psi_{0}=130.0$。\n\n要求的输出格式：\n- 您的程序必须生成单行输出，包含一个含 $9$ 个数字的一维列表：$\\left[\\Delta \\phi_{1},\\Delta \\psi_{1},\\Delta E_{1},\\Delta \\phi_{2},\\Delta \\psi_{2},\\Delta E_{2},\\Delta \\phi_{3},\\Delta \\psi_{3},\\Delta E_{3}\\right]$。\n- 角度必须四舍五入到一位小数（度）。能量必须四舍五入到三位小数（千卡/摩尔）。\n\n您的最终答案必须是一个完整的、可运行的 Python 程序，该程序构建 Ser 的“参数”，应用磷酸化“补丁”，为每个测试用例执行构象网格搜索，并以上述指定的确切格式打印结果。",
            "solution": "所提出的问题要求形式化并实现一个简化的、基于知识的能量函数，以预测单个氨基酸残基在其标准状态（丝氨酸，Ser）和带有翻译后修饰的状态（磷酸化丝氨酸，pSer）下的优选主链构象。这项任务植根于计算结构生物学的基本原则：分子的热力学有利构象对应于其势能面上的一个极小值点。能量函数或打分函数 $E(\\boldsymbol{\\theta}; \\boldsymbol{\\lambda})$ 是一个近似该势能的数学模型，其中 $\\boldsymbol{\\theta}$ 代表系统的构象自由度，$\\boldsymbol{\\lambda}$ 是模型的参数。\n\n在这个问题中，构象变量是主链二面角 $\\phi$ 和 $\\psi$。残基化学状态的变化，从 Ser 到 pSer，通过改变参数 $\\boldsymbol{\\lambda}$ 来建模。这类似于分子建模软件（如 Rosetta）中使用的“参数文件”和“补丁”系统，其中一组基本参数定义了一个标准残基，而一个补丁则应用一个特定的修饰。\n\n我们的任务是为 Ser 和 pSer 构建能量函数，通过执行网格搜索找到各自的最低能量构象 $(\\phi^{\\star}, \\psi^{\\star})$，然后在三种不同的环境条件下量化由磷酸化引起的构象和能量变化。所有角度均以度为单位，能量以千卡/摩尔为单位。\n\n对于类型为 $r \\in \\{\\mathrm{Ser}, \\mathrm{pSer}\\}$ 的残基，其总能量由以下公式给出：\n$$\nE_{\\mathrm{total}}^{(r)}(\\phi,\\psi) \\;=\\; E_{\\mathrm{bb}}^{(r)}(\\phi,\\psi) \\;+\\; \\mathbb{1}[r=\\mathrm{pSer}] \\left( E_{\\mathrm{steric}}^{(\\mathrm{pSer})}(\\phi) + E_{\\mathrm{env}}^{(\\mathrm{pSer})}(\\psi; k_{\\mathrm{el}}, \\psi_{0}) \\right)\n$$\n其中 $\\mathbb{1}[\\cdot]$ 是指示函数，若其参数为真则值为 $1$，否则为 $0$。这意味着对于丝氨酸，只有 $E_{\\mathrm{bb}}$ 项有贡献，而对于磷酸化丝氨酸，则应用了两个额外的“补丁”项。\n\n能量组分定义如下：\n1. **主链统计偏好, $E_{\\mathrm{bb}}^{(r)}(\\phi,\\psi)$**：该项模拟了肽主链的内在构象倾向，已知这些构象倾向于聚集在拉曼钱德兰图的特定区域，即 $\\alpha$-螺旋和 $\\beta$-折叠区域。它被表述为两个高斯势阱的总和，其中势阱的深度 $d_{\\alpha}^{(r)}$ 和 $d_{\\beta}^{(r)}$ 取决于残基类型 $r$。\n$$\nE_{\\mathrm{bb}}^{(r)}(\\phi,\\psi) \\;=\\; -d_{\\alpha}^{(r)} \\exp\\!\\left(-\\tfrac{1}{2}\\left(\\tfrac{\\phi-\\mu_{\\phi,\\alpha}}{\\sigma_{\\phi}}\\right)^{2} - \\tfrac{1}{2}\\left(\\tfrac{\\psi-\\mu_{\\psi,\\alpha}}{\\sigma_{\\psi}}\\right)^{2}\\right)\n\\;-\\; d_{\\beta}^{(r)} \\exp\\!\\left(-\\tfrac{1}{2}\\left(\\tfrac{\\phi-\\mu_{\\phi,\\beta}}{\\sigma_{\\phi}}\\right)^{2} - \\tfrac{1}{2}\\left(\\tfrac{\\psi-\\mu_{\\psi,\\beta}}{\\sigma_{\\psi}}\\right)^{2}\\right)\n$$\n公共参数是 $\\alpha$-区域的中心 $(\\mu_{\\phi,\\alpha},\\mu_{\\psi,\\alpha})=(-60,-45)$，$\\beta$-区域的中心 $(\\mu_{\\phi,\\beta},\\mu_{\\psi,\\beta})=(-120,130)$，以及宽度 $\\sigma_{\\phi}=\\sigma_{\\psi}=25$。\n对于丝氨酸，参数为 $d_{\\alpha}^{(\\mathrm{Ser})}=3.0$ 和 $d_{\\beta}^{(\\mathrm{Ser})}=2.0$，偏好于 $\\alpha$-螺旋构象。\n磷酸化“补丁”将这些参数更改为 $d_{\\alpha}^{(\\mathrm{pSer})}=1.2$ 和 $d_{\\beta}^{(\\mathrm{pSer})}=3.2$，使偏好转向 $\\beta$-折叠构象。\n\n2. **空间位阻惩罚, $E_{\\mathrm{steric}}^{(\\mathrm{pSer})}(\\phi)$**：该项仅为 pSer 添加，模拟了由庞大的磷酸基团引入的空间位阻，这尤其不利于与 $\\alpha$-螺旋区域相关的紧密转角。它是一个以 $\\alpha$-螺旋区域的 $\\phi$ 值为中心的正高斯函数。\n$$\nE_{\\mathrm{steric}}^{(\\mathrm{pSer})}(\\phi) \\;=\\; + s_{0} \\exp\\!\\left(-\\tfrac{1}{2}\\left(\\tfrac{\\phi - \\mu_{\\phi,\\mathrm{steric}}}{\\sigma_{\\phi,\\mathrm{steric}}}\\right)^{2}\\right)\n$$\n参数为振幅 $s_{0}=0.8$，中心 $\\mu_{\\phi,\\mathrm{steric}}=-60$，宽度 $\\sigma_{\\phi,\\mathrm{steric}}=15$。对于丝氨酸，此项为 $0$。\n\n3. **环境相互作用, $E_{\\mathrm{env}}^{(\\mathrm{pSer})}(\\psi)$**：该项也仅为 pSer 添加，模拟了带负电的磷酸基团与蛋白质环境中附近的某个正电荷之间的方向性静电或氢键相互作用。此相互作用的强度为 $k_{\\mathrm{el}}$，并且它偏好于一个特定的 $\\psi$ 角 $\\psi_{0}$。\n$$\nE_{\\mathrm{env}}^{(\\mathrm{pSer})}(\\psi; k_{\\mathrm{el}}, \\psi_{0}) \\;=\\; - k_{\\mathrm{el}} \\exp\\!\\left(-\\tfrac{1}{2}\\left(\\tfrac{\\psi - \\psi_{0}}{\\sigma_{\\psi,\\mathrm{el}}}\\right)^{2}\\right)\n$$\n宽度为 $\\sigma_{\\psi,\\mathrm{el}}=25$。参数 $k_{\\mathrm{el}}$ 和 $\\psi_{0}$ 由测试用例指定。对于丝氨酸，或当 $k_{\\mathrm{el}}=0$ 时，此项为 $0$。\n\n为了找到最低能量构象，我们将执行网格搜索。搜索空间是一个由 $\\phi, \\psi \\in \\{-180, -175, \\ldots, 180\\}$ 定义的离散网格。对于三个测试用例中的每一个，我们将执行两次独立的网格搜索：一次用于丝氨酸以找到 $(\\phi^{\\star}_{\\mathrm{Ser}},\\psi^{\\star}_{\\mathrm{Ser}})$ 和 $E_{\\min}^{(\\mathrm{Ser})}$，另一次用于磷酸化丝氨酸，使用指定的环境参数 $(k_{\\mathrm{el}}, \\psi_{0})$ 以找到 $(\\phi^{\\star}_{\\mathrm{pSer}},\\psi^{\\star}_{\\mathrm{pSer}})$ 和 $E_{\\min}^{(\\mathrm{pSer})}$。\n\n根据这些结果，我们为每个案例计算所需的输出：\n- 二面角的变化量，$\\Delta \\phi = \\phi^{\\star}_{\\mathrm{pSer}} - \\phi^{\\star}_{\\mathrm{Ser}}$ 和 $\\Delta \\psi = \\psi^{\\star}_{\\mathrm{pSer}} - \\psi^{\\star}_{\\mathrm{Ser}}$。这些差值使用映射 $\\Delta \\theta \\mapsto ((\\Delta \\theta + 180) \\pmod{360}) - 180$ 被折叠到区间 $(-180, 180]$ 内。这确保了报告的是最短角距离。\n- 最低能量的变化量，$\\Delta E = E_{\\min}^{(\\mathrm{pSer})} - E_{\\min}^{(\\mathrm{Ser})}$。\n\n对所有三个测试用例重复此过程，并将得到的 $9$ 个值（每个案例的 $\\Delta\\phi, \\Delta\\psi, \\Delta E$）收集起来，按照指定的精度（角度保留 $1$ 位小数，能量保留 $3$ 位小数）进行四舍五入，并以一个单一的一维列表形式呈现。实现将使用数据结构来表示丝氨酸的基础“参数”和磷酸化的“补丁”，以模仿模块化建模框架的逻辑。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the conformational search and scoring problem for Serine and phospho-Serine.\n    \"\"\"\n\n    # --- Data Structures for Parameters (\"Params\" and \"Patch\") ---\n    \n    # Shared parameters for backbone statistical potential\n    bb_shared_params = {\n        'mu_phi_alpha': -60.0, 'mu_psi_alpha': -45.0,\n        'mu_phi_beta': -120.0, 'mu_psi_beta': 130.0,\n        'sigma_phi': 25.0, 'sigma_psi': 25.0,\n    }\n\n    # Base \"params\" file for Serine\n    serine_params = {\n        'type': 'Ser',\n        **bb_shared_params,\n        'd_alpha': 3.0,\n        'd_beta': 2.0,\n        # Patch-related flags are off by default\n        'has_steric_penalty': False,\n        'has_env_interaction': False,\n    }\n\n    # \"Patch\" for phosphorylation\n    pser_patch = {\n        'd_alpha': 1.2,\n        'd_beta': 3.2,\n        'has_steric_penalty': True,\n        's0_steric': 0.8,\n        'mu_phi_steric': -60.0,\n        'sigma_phi_steric': 15.0,\n        'has_env_interaction': True,\n        'sigma_psi_el': 25.0,\n    }\n\n    def apply_patch(base_params, patch):\n        \"\"\"Applies a patch to base parameters to create modified parameters.\"\"\"\n        patched_params = base_params.copy()\n        patched_params['type'] = 'pSer'\n        patched_params.update(patch)\n        return patched_params\n\n    # Create phospho-Serine parameters by applying the patch\n    pser_base_params = apply_patch(serine_params, pser_patch)\n\n    # --- Energy Functions ---\n\n    def E_bb(phi, psi, params):\n        \"\"\"Calculates backbone statistical energy.\"\"\"\n        term_alpha = -params['d_alpha'] * np.exp(\n            -0.5 * ((phi - params['mu_phi_alpha']) / params['sigma_phi'])**2\n            -0.5 * ((psi - params['mu_psi_alpha']) / params['sigma_psi'])**2\n        )\n        term_beta = -params['d_beta'] * np.exp(\n            -0.5 * ((phi - params['mu_phi_beta']) / params['sigma_phi'])**2\n            -0.5 * ((psi - params['mu_psi_beta']) / params['sigma_psi'])**2\n        )\n        return term_alpha + term_beta\n\n    def E_steric(phi, params):\n        \"\"\"Calculates steric penalty for pSer.\"\"\"\n        if not params['has_steric_penalty']:\n            return 0.0\n        return params['s0_steric'] * np.exp(\n            -0.5 * ((phi - params['mu_phi_steric']) / params['sigma_phi_steric'])**2\n        )\n\n    def E_env(psi, params, k_el, psi_0):\n        \"\"\"Calculates environmental interaction for pSer.\"\"\"\n        if not params['has_env_interaction'] or k_el == 0.0:\n            return 0.0\n        return -k_el * np.exp(-0.5 * ((psi - psi_0) / params['sigma_psi_el'])**2)\n\n    def total_energy(phi, psi, params, env_params):\n        \"\"\"Calculates the total energy for a given conformation.\"\"\"\n        k_el, psi_0 = env_params\n        energy = E_bb(phi, psi, params) + \\\n                 E_steric(phi, params) + \\\n                 E_env(psi, params, k_el, psi_0)\n        return energy\n        \n    # --- Grid Search and Calculation ---\n\n    def find_minimum_energy_conformation(params, env_params):\n        \"\"\"Performs a grid search to find the minimum energy conformation.\"\"\"\n        phi_grid = np.arange(-180.0, 180.1, 5.0)\n        psi_grid = np.arange(-180.0, 180.1, 5.0)\n        \n        min_energy = float('inf')\n        min_angles = (None, None)\n\n        for phi in phi_grid:\n            for psi in psi_grid:\n                E = total_energy(phi, psi, params, env_params)\n                if E < min_energy:\n                    min_energy = E\n                    min_angles = (phi, psi)\n        \n        return min_angles, min_energy\n\n    def wrap_angle(delta_theta):\n        \"\"\"Wraps an angular difference to the range (-180, 180].\"\"\"\n        return (delta_theta + 180.0) % 360.0 - 180.0\n\n    # --- Test Suite ---\n    test_cases = [\n        # (k_el, psi_0)\n        (1.5, -60.0),  # Case 1\n        (0.0, 0.0),    # Case 2\n        (0.9, 130.0),  # Case 3\n    ]\n\n    all_results = []\n    \n    # Find Serine minimum once (it's environment-independent)\n    ser_env_params = (0.0, 0.0) # k_el=0 for Serine\n    ser_min_angles, ser_min_energy = find_minimum_energy_conformation(serine_params, ser_env_params)\n    phi_star_ser, psi_star_ser = ser_min_angles\n\n    for case_env_params in test_cases:\n        # Find pSerine minimum for current environment\n        pser_min_angles, pser_min_energy = find_minimum_energy_conformation(pser_base_params, case_env_params)\n        phi_star_pser, psi_star_pser = pser_min_angles\n        \n        # Calculate differences\n        delta_phi = wrap_angle(phi_star_pser - phi_star_ser)\n        delta_psi = wrap_angle(psi_star_pser - psi_star_ser)\n        delta_E = pser_min_energy - ser_min_energy\n\n        # Round and append results\n        all_results.append(np.round(delta_phi, 1))\n        all_results.append(np.round(delta_psi, 1))\n        all_results.append(np.round(delta_E, 3))\n\n    # --- Final Output ---\n    # Convert all numbers to strings for joining, handling -0.0\n    # The format 'g' prevents scientific notation for small numbers.\n    results_str = [f\"{x:.1f}\" if i % 3 != 2 else f\"{x:.3f}\" for i, x in enumerate(all_results)]\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```"
        }
    ]
}