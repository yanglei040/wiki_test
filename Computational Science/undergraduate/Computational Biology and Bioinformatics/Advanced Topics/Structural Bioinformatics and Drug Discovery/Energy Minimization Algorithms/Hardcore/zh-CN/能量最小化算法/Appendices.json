{
    "hands_on_practices": [
        {
            "introduction": "我们从能量最小化的基础开始：基于梯度的方法。这个练习将引导你实现并比较两种经典的优化算法：最速下降法（Steepest Descent）和共轭梯度法（Conjugate Gradient）。最速下降法是最直观的“下山”策略，而共轭梯度法则是一种更精妙、更高效的算法。通过这个实践，你将亲身体会到能量景观的“形状”（具体来说，由Hessian矩阵的条件数$\\kappa$所表征的各向异性）如何戏剧性地影响收敛速度，这是所有计算科学家都必须掌握的关键一课。",
            "id": "2388054",
            "problem": "您的任务是设计并实现一个程序，该程序针对一系列严格凸的二次分子力学能量模型，在从指定的初始构型开始最小化能量时，比较两种经典的能量最小化方法——最速下降法 (SD) 和共轭梯度法 (CG) 的迭代次数。需要最小化的能量是二次近似 $$E(\\mathbf{x})=\\tfrac{1}{2}\\,\\mathbf{x}^{\\mathsf{T}}\\mathbf{H}\\,\\mathbf{x},$$ 其中 $\\mathbf{x}\\in\\mathbb{R}^{n}$ 是相对于参考构象的笛卡尔位移，$\\mathbf{H}\\in\\mathbb{R}^{n\\times n}$ 是一个对称正定矩阵（海森矩阵）。梯度为 $\\nabla E(\\mathbf{x})=\\mathbf{H}\\,\\mathbf{x}$。两种方法之间的收敛速率比较必须通过满足指定停止准则所需的迭代次数来量化。\n\n定义和要求：\n- 设停止准则为：梯度的欧几里得范数满足 $$\\lVert\\nabla E(\\mathbf{x}_{k})\\rVert_{2}\\leq \\tau\\,\\lVert\\nabla E(\\mathbf{x}_{0})\\rVert_{2}$$ 的第一个迭代索引 $k$，其中容差 $\\tau=10^{-8}$，初始状态 $\\mathbf{x}_{0}$ 定义如下。\n- 一次迭代定义为沿着当前搜索方向对 $\\mathbf{x}$ 进行一次更新，并在此方向上进行精确线性最小化。对于最速下降法和共轭梯度法，在迭代 $k$ 处的步长 $\\alpha_{k}$ 是单变量函数 $E(\\mathbf{x}_{k}+\\alpha\\,\\mathbf{p}_{k})$ 相对于 $\\alpha\\in\\mathbb{R}$ 的唯一最小化子，其中 $\\mathbf{p}_{k}$ 是在迭代 $k$ 处与方法相关的搜索方向。\n- 对于最速下降法，每次迭代的搜索方向为 $\\mathbf{p}_{k}=-\\nabla E(\\mathbf{x}_{k})$。\n- 对于共轭梯度法，搜索方向是相互 $\\mathbf{H}$-共轭的。\n\n测试套件（四个测试用例）：\n对于每个测试用例，海森矩阵是对角矩阵，$\\mathbf{H}=\\operatorname{diag}(\\lambda_{1},\\dots,\\lambda_{n})$，其元素遵循一个设置条件数 $\\kappa$ 的几何级数：\n$$\\lambda_{i}=\\exp\\!\\Big(\\ln(\\kappa)\\cdot\\frac{i-1}{n-1}\\Big),\\quad i\\in\\{1,\\dots,n\\},$$\n使得 $\\lambda_{1}=1$ 且 $\\lambda_{n}=\\kappa$。初始状态按分量定义为\n$$x_{0,i}=\\sin(i),\\quad i\\in\\{1,\\dots,n\\},$$\n其中正弦函数以弧度为单位进行计算。所有用例的停止容差均为 $\\tau=10^{-8}$。具体的测试用例为：\n- 用例 1（类螺旋，高度各向异性曲率）：$n=60$，$\\kappa=1000$。\n- 用例 2（类球状，中度各向异性曲率）：$n=60$，$\\kappa=10$。\n- 用例 3（边界情况，已最小化）：$n=60$，$\\kappa=50$，且 $\\mathbf{x}_{0}=\\mathbf{0}$。\n- 用例 4（小型良态实例）：$n=5$，$\\kappa=50$。\n\n对每个测试用例，您的程序必须计算：\n- 最速下降法的整数迭代次数，记为 $I_{\\mathrm{SD}}$；\n- 共轭梯度法的整数迭代次数，记为 $I_{\\mathrm{CG}}$；\n- 以及整数差 $D=I_{\\mathrm{SD}}-I_{\\mathrm{CG}}$。\n\n如果在初始状态下已满足停止准则，则相应的迭代次数必须为 $0$。对于共轭梯度法，不得超过 $n$ 次迭代。对于最速下降法，不得超过 $100000$ 次迭代的安全上限；如果达到该上限时仍未满足停止准则（对于上述参数，这种情况不应发生），则返回该上限作为迭代次数。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按如下顺序排列\n$$[I_{\\mathrm{SD}}^{(1)},\\,I_{\\mathrm{CG}}^{(1)},\\,D^{(1)},\\,I_{\\mathrm{SD}}^{(2)},\\,I_{\\mathrm{CG}}^{(2)},\\,D^{(2)},\\,I_{\\mathrm{SD}}^{(3)},\\,I_{\\mathrm{CG}}^{(3)},\\,D^{(3)},\\,I_{\\mathrm{SD}}^{(4)},\\,I_{\\mathrm{CG}}^{(4)},\\,D^{(4)}],$$\n其中上标 $(j)$ 指的是测试用例 $j\\in\\{1,2,3,4\\}$。不得打印任何其他文本。",
            "solution": "问题陈述经过验证，被认为是科学上可靠、适定且客观的。它提出了一个标准的数值优化任务：使用两种经典的迭代方法——最速下降法 (SD) 和共轭梯度法 (CG) 来最小化一个严格凸的二次函数。所有的参数、定义和条件都以足够的精度被指定，从而确保了唯一且有意义的解的存在。因此，该问题是有效的。\n\n该数学问题是找到二次能量函数 $E(\\mathbf{x}): \\mathbb{R}^n \\to \\mathbb{R}$ 的最小值，其定义为：\n$$\nE(\\mathbf{x}) = \\frac{1}{2}\\mathbf{x}^{\\mathsf{T}}\\mathbf{H}\\,\\mathbf{x}\n$$\n其中 $\\mathbf{x} \\in \\mathbb{R}^n$ 代表笛卡尔位移，$\\mathbf{H} \\in \\mathbb{R}^{n \\times n}$ 是一个对称正定 (SPD) 的海森矩阵。$\\mathbf{H}$ 的正定性确保了 $E(\\mathbf{x})$ 是严格凸的，并在 $\\mathbf{x} = \\mathbf{0}$ 处有唯一的全局最小值。优化算法所需的能量函数梯度由下式给出：\n$$\n\\nabla E(\\mathbf{x}) = \\mathbf{g}(\\mathbf{x}) = \\mathbf{H}\\mathbf{x}\n$$\n两种优化方法都从一个初始点 $\\mathbf{x}_0$ 开始，并生成一个点序列 $\\{\\mathbf{x}_k\\}$，该序列迭代地逼近最小值。更新规则的一般形式为 $\\mathbf{x}_{k+1} = \\mathbf{x}_k + \\alpha_k \\mathbf{p}_k$，其中 $\\mathbf{p}_k$ 是搜索方向，$\\alpha_k$ 是步长。问题指定了精确线搜索，意味着选择 $\\alpha_k$ 以最小化关于 $\\alpha$ 的函数 $E(\\mathbf{x}_k + \\alpha \\mathbf{p}_k)$。对于给定的二次能量函数，这个最优步长有一个解析解：\n$$\n\\alpha_k = \\underset{\\alpha \\in \\mathbb{R}}{\\arg\\min}\\, E(\\mathbf{x}_k + \\alpha \\mathbf{p}_k) = -\\frac{\\mathbf{g}_k^{\\mathsf{T}}\\mathbf{p}_k}{\\mathbf{p}_k^{\\mathsf{T}}\\mathbf{H}\\mathbf{p}_k}\n$$\n其中 $\\mathbf{g}_k = \\nabla E(\\mathbf{x}_k)$。\n\n最速下降法 (SD) 在每一步都采用负梯度作为其搜索方向：\n$$\n\\mathbf{p}_k = -\\mathbf{g}_k\n$$\n将此代入 $\\alpha_k$ 的公式，得到 SD 的特定步长：\n$$\n\\alpha_k^{\\mathrm{SD}} = -\\frac{\\mathbf{g}_k^{\\mathsf{T}}(-\\mathbf{g}_k)}{(-\\mathbf{g}_k)^{\\mathsf{T}}\\mathbf{H}(-\\mathbf{g}_k)} = \\frac{\\mathbf{g}_k^{\\mathsf{T}}\\mathbf{g}_k}{\\mathbf{g}_k^{\\mathsf{T}}\\mathbf{H}\\mathbf{g}_k}\n$$\nSD 算法通过迭代更新位置 $\\mathbf{x}_{k+1} = \\mathbf{x}_k - \\alpha_k^{\\mathrm{SD}}\\mathbf{g}_k$ 来进行。众所周知，随着海森矩阵条件数 $\\kappa(\\mathbf{H})$ 的增加，其收敛速度会显著下降，导致典型的锯齿形路径逼近最小值。\n\n共轭梯度法 (CG) 通过选择 $\\mathbf{H}$-共轭的搜索方向（即，对于 $i \\neq j$ 有 $\\mathbf{p}_i^{\\mathsf{T}}\\mathbf{H}\\mathbf{p}_j = 0$）来改进 SD 方法。这可以防止沿相同方向重复进行最小化。搜索方向在每次迭代时更新：\n$$\n\\mathbf{p}_k = -\\mathbf{g}_k + \\beta_k \\mathbf{p}_{k-1}\n$$\n其中 $\\mathbf{p}_0 = -\\mathbf{g}_0$。$\\beta_k$ 的一个常用选择是 Fletcher-Reeves 公式：\n$$\n\\beta_k = \\frac{\\mathbf{g}_k^{\\mathsf{T}}\\mathbf{g}_k}{\\mathbf{g}_{k-1}^{\\mathsf{T}}\\mathbf{g}_{k-1}}\n$$\n对于具有精确线搜索的严格凸二次函数，此选择与其他选择（例如 Polak-Ribière）等价。精确线搜索的一个关键特性是，新的梯度 $\\mathbf{g}_k$ 与前一个搜索方向 $\\mathbf{p}_{k-1}$ 正交，因此 $\\mathbf{g}_k^{\\mathsf{T}}\\mathbf{p}_{k-1} = 0$。利用这一点，CG 步长公式的分子可以简化为：\n$$\n\\mathbf{g}_k^{\\mathsf{T}}\\mathbf{p}_k = \\mathbf{g}_k^{\\mathsf{T}}(-\\mathbf{g}_k + \\beta_k \\mathbf{p}_{k-1}) = -\\mathbf{g}_k^{\\mathsf{T}}\\mathbf{g}_k\n$$\n因此，CG 的步长可以计算为：\n$$\n\\alpha_k^{\\mathrm{CG}} = \\frac{\\mathbf{g}_k^{\\mathsf{T}}\\mathbf{g}_k}{\\mathbf{p}_k^{\\mathsf{T}}\\mathbf{H}\\mathbf{p}_k}\n$$\nCG 方法有一个显著的特性，即在精确算术中，它保证在至多 $n$ 次迭代内找到二次函数的精确最小值。\n\n两种方法的停止准则是梯度的欧几里得范数降至相对容差以下：\n$$\n\\lVert\\mathbf{g}_k\\rVert_2 \\leq \\tau \\lVert\\mathbf{g}_0\\rVert_2\n$$\n其中 $\\mathbf{g}_k = \\nabla E(\\mathbf{x}_k)$ 且 $\\tau=10^{-8}$。从 $\\mathbf{x}_k$ 到 $\\mathbf{x}_{k+1}$ 的一次更新计为一次迭代。如果在 $\\mathbf{x}_0$ 处满足条件，迭代次数为 $0$。\n\n测试用例指定了对角海森矩阵 $\\mathbf{H} = \\operatorname{diag}(\\lambda_1, \\dots, \\lambda_n)$，这将矩阵-向量乘积 $\\mathbf{H}\\mathbf{v}$ 大大简化为逐元素乘积。构造特征值 $\\lambda_i$ 以固定条件数 $\\kappa = \\lambda_n/\\lambda_1 = \\kappa/1 = \\kappa$。实现将利用这种对角结构来提高效率。$\\mathbf{x}_0 = \\mathbf{0}$ 的情况作为基本情况处理，由于系统已处于最小值，因此迭代次数为 $0$。\n\n提供了一个程序，它实现了这两种算法，将它们应用于指定的测试用例，并计算所需的迭代次数 $I_{\\mathrm{SD}}$、$I_{\\mathrm{CG}}$ 及其差值 $D$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef steepest_descent(h_diag, x0, tau, max_iter):\n    \"\"\"\n    Minimizes a quadratic form using the Steepest Descent method.\n    \"\"\"\n    x = x0.copy()\n    g = h_diag * x\n    g0_norm = np.linalg.norm(g)\n\n    # If already at the minimum, iterations = 0.\n    if g0_norm == 0:\n        return 0\n\n    threshold = tau * g0_norm\n\n    for i in range(1, max_iter + 1):\n        g_dot_g = np.dot(g, g)\n        \n        # Calculate alpha_k = (g_k^T * g_k) / (g_k^T * H * g_k)\n        # H is diagonal, so g_k^T * H * g_k = g_k^T * (h_diag * g_k)\n        g_H_g = np.dot(g, h_diag * g)\n        \n        # Avoid division by zero if gradient is effectively zero\n        if g_H_g == 0:\n            return i - 1\n\n        alpha = g_dot_g / g_H_g\n        \n        # Update position: x_{k+1} = x_k - alpha_k * g_k\n        x -= alpha * g\n        \n        # Update gradient for next iteration\n        g = h_diag * x\n        \n        if np.linalg.norm(g) = threshold:\n            return i\n            \n    return max_iter\n\ndef conjugate_gradient(h_diag, x0, tau, n):\n    \"\"\"\n    Minimizes a quadratic form using the Conjugate Gradient method.\n    \"\"\"\n    x = x0.copy()\n    g = h_diag * x\n    g0_norm = np.linalg.norm(g)\n    \n    # If already at the minimum, iterations = 0.\n    if g0_norm == 0:\n        return 0\n\n    threshold = tau * g0_norm\n    \n    p = -g\n    g_sq_norm = np.dot(g, g)\n\n    # CG is guaranteed to converge in at most n iterations for quadratics in exact arithmetic.\n    for i in range(1, n + 1):\n        # Calculate p_k^T * H * p_k\n        p_H_p = np.dot(p, h_diag * p)\n        \n        # Avoid division by zero\n        if p_H_p == 0:\n            # This can happen if p becomes zero, meaning we have likely converged\n            return i - 1\n\n        # alpha_k = (g_k^T * g_k) / (p_k^T * H * p_k)\n        alpha = g_sq_norm / p_H_p\n        \n        # Update position: x_{k+1} = x_k + alpha_k * p_k\n        x += alpha * p\n        \n        # Efficient gradient update: g_{k+1} = g_k + alpha_k * H * p_k\n        g += alpha * (h_diag * p)\n\n        if np.linalg.norm(g) = threshold:\n            return i\n\n        g_new_sq_norm = np.dot(g, g)\n        beta = g_new_sq_norm / g_sq_norm\n        \n        # Update search direction: p_{k+1} = -g_{k+1} + beta_{k+1} * p_k\n        p = -g + beta * p\n        g_sq_norm = g_new_sq_norm\n        \n    return n\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test cases and prints the results.\n    \"\"\"\n    test_cases = [\n        # (n, kappa)\n        (60, 1000.0),  # Case 1\n        (60, 10.0),    # Case 2\n        (60, 50.0),    # Case 3\n        (5, 50.0),     # Case 4\n    ]\n\n    tau = 1e-8\n    sd_max_iter = 100000\n    \n    results = []\n\n    for i, (n, kappa) in enumerate(test_cases):\n        # Construct Hessian diagonal entries\n        if n == 1:\n            # Special case to avoid division by zero in the formula for lambda_i\n            h_diag = np.array([kappa])\n        else:\n            indices = np.arange(n, dtype=float)\n            h_diag = np.exp(np.log(kappa) * indices / (n - 1))\n        \n        # Construct initial state x0\n        # Case 3 has a special x0\n        if i == 2:  # 0-indexed case 3\n            x0 = np.zeros(n)\n        else:\n            # i from 1 to n for sin(i)\n            indices_for_sin = np.arange(1, n + 1)\n            x0 = np.sin(indices_for_sin)\n\n        # Run both algorithms\n        i_sd = steepest_descent(h_diag, x0, tau, sd_max_iter)\n        i_cg = conjugate_gradient(h_diag, x0, tau, n)\n        \n        difference = i_sd - i_cg\n        \n        results.extend([i_sd, i_cg, difference])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "梯度下降等确定性方法可能会陷入局部能量最低点。为了克服这一限制，我们转向随机方法，它们旨在探索更广阔的构象空间。本练习将介绍Metropolis蒙特卡洛算法，这是一种模拟物理系统并寻找低能态的强大工具。你将通过实现这一关键算法来模拟一个简化的聚合物折叠过程（疏水链模型），从而获得宝贵的实践经验，并理解温度$T$如何帮助系统“跳出”能量陷阱以寻找更优的构象。",
            "id": "2388039",
            "problem": "考虑一个长度为 $N=5$ 的疏水性聚合物链，该链嵌入在一个边长为 $L$ 且具有周期性边界条件（一个环面）的二维方格晶格上。该聚合物由 $N$ 个不可区分的单体组成，占据 $N$ 个不同的晶格位点，并满足连通性约束（即连续的单体之间的晶格距离为单位长度，曼哈顿距离为 1）和自回避约束（即没有两个单体占据相同的位点）。所有单体都是疏水性的，相互作用能定义如下。对于一个构象，其单体坐标为 $\\{\\mathbf{r}_i\\}_{i=0}^{N-1}$，其中每个 $\\mathbf{r}_i$ 是一个由整数坐标 $(x_i,y_i)$ 表示的晶格位点，且 $x_i \\in \\{0,1,\\dots,L-1\\}$，$y_i \\in \\{0,1,\\dots,L-1\\}$。定义非键合最近邻接触数 $C$ 为满足 $|i-j|1$ 且 $\\mathbf{r}_i$ 与 $\\mathbf{r}_j$ 之间的环面晶格距离恰好为 1 的无序对 $\\{i,j\\}$ 的基数。两个位点 $(x,y)$ 和 $(x',y')$ 之间的环面晶格距离通过计算最小环绕坐标差 $\\Delta x = \\min\\{|x-x'|, L - |x-x'|\\}$ 和 $\\Delta y = \\min\\{|y-y'|, L - |y-y'|\\}$ 来确定，当 $(\\Delta x=1,\\Delta y=0)$ 或 $(\\Delta x=0,\\Delta y=1)$ 时，定义这两个位点为最近邻。能量由下式给出：\n$$\nE(\\{\\mathbf{r}_i\\}) = -\\varepsilon \\, C,\n$$\n其中 $\\varepsilon0$ 是一个固定的能量标度。在整个问题中，使用 $\\varepsilon=1$ 和玻尔兹曼常数 $k_{\\mathrm{B}}=1$，因此能量和温度均使用无量纲单位。\n\n对于每个测试用例，初始构象被确定性地指定为占据以下位点的水平直链：\n$$\n\\mathbf{r}_i = (i \\bmod L,\\, 0), \\quad i \\in \\{0,1,2,3,4\\},\n$$\n对于所有 $L \\ge 5$，该构象满足连通性和自回避约束。时间演化通过离散的尝试来改变构象，同时保持连通性和自回避性。在每次尝试中，会提出一个局域移动，该移动会修改一个末端单体或一个内部单体的位置，但必须保持其与链上直接邻居之间的单位键长。如果提议的构象违反了自回避约束，则该移动被拒绝。否则，计算能量变化 $\\Delta E$，并以如下概率接受该移动：\n$$\np_{\\mathrm{acc}} = \n\\begin{cases}\n1,  \\text{if } \\Delta E \\le 0,\\\\\n\\exp(-\\Delta E/T),  \\text{if } \\Delta E  0,\n\\end{cases}\n$$\n其中 $T$ 是该测试用例的温度。如果 $T=0$，则将接受规则解释为只接受 $\\Delta E \\le 0$ 的移动。在所有访问过的构象（包括初始构象）中，跟踪遇到的最低能量。在指定次数的尝试 $M$ 之后，报告以 $\\varepsilon$ 为单位找到的最低能量，结果为整数。\n\n假设每次尝试时采用以下具体的局域移动。以相等的概率选择两种移动类型之一：\n- 末端移动：以相等的概率选择一个末端单体，即索引为 $0$ 或 $N-1$ 的单体。假设其唯一的键合邻居分别是单体 $1$ 或 $N-2$。提议将所选的末端单体移动到其键合邻居的最近邻（在环面意义上）的某个空闲晶格位点上，该位点从所有可用位点中均匀随机选择。如果不存在这样的位点，则该尝试被拒绝。\n- 角翻转：从索引为 $i \\in \\{1,2,3\\}$ 的内部单体中均匀随机选择一个。如果从 $\\mathbf{r}_i$ 到其键合邻居 $\\mathbf{r}_{i-1}$ 和 $\\mathbf{r}_{i+1}$ 的向量是环面上的正交单位晶格向量（即，在最小环绕坐标中，一个是 $(\\pm 1, 0)$，另一个是 $(0,\\pm 1)$），则提议将单体 $i$ 移动到另一个唯一的晶格位点，该位点同时是 $\\mathbf{r}_{i-1}$ 和 $\\mathbf{r}_{i+1}$ 的最近邻，即 $\\mathbf{r}'_i = \\mathbf{r}_i + (\\mathbf{r}_{i-1} - \\mathbf{r}_i) + (\\mathbf{r}_{i+1} - \\mathbf{r}_i)$，使用最小环绕位移计算，然后对 $L$ 取模化简到 $\\{0,1,\\dots,L-1\\}^2$ 中。如果该位点已被另一个单体占据，则该尝试被拒绝。\n\n请实现上述精确定义的动力学过程并跟踪最低能量。对于下面的每个测试用例，从指定的初始构象开始，运行恰好 $M$ 次独立的移动尝试，并使用指定的伪随机种子来初始化一个伪随机数生成器，从而使提议的移动序列对于该测试是确定性的。所有测试用例的所需输出是单行文本，其中包含找到的最低能量列表，按指定的测试用例顺序列出，格式为用方括号括起来的逗号分隔列表。\n\n使用以下测试套件，每个测试用例以元组 $(L,M,T,\\text{seed})$ 的形式给出，所有值均按相同顺序列出：\n- 测试 A（一般探索）：$(L,M,T,\\text{seed}) = (\\,6,\\,100000,\\,0.8,\\,20231102\\,)$。\n- 测试 B（无移动的边界条件）：$(L,M,T,\\text{seed}) = (\\,5,\\,0,\\,0.5,\\,1\\,)$。\n- 测试 C（高温探索）：$(L,M,T,\\text{seed}) = (\\,6,\\,30000,\\,5.0,\\,777\\,)$。\n- 测试 D（低温有限探索）：$(L,M,T,\\text{seed}) = (\\,6,\\,5000,\\,0.2,\\,424242\\,)$。\n\n您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，例如 $[\\text{result}_A,\\text{result}_B,\\text{result}_C,\\text{result}_D]$。请以 $\\varepsilon$ 为单位将能量报告为整数。",
            "solution": "该问题要求为二维环面晶格上的自回避聚合物链实现一个 Metropolis 蒙特卡洛模拟。目标是为几个测试用例，在固定数量的模拟步骤中找到遇到的最低能量。该问题定义明确、科学上合理且计算上可行。这是计算统计物理学中的一个标准问题，常用于模拟聚合物折叠。\n\n系统状态是由 $N=5$ 个单体组成的单条聚合物链。构象由单体坐标集 $\\{\\mathbf{r}_i\\}_{i=0}^{N-1}$ 描述，其中每个 $\\mathbf{r}_i=(x_i, y_i)$ 是一个在具有周期性边界条件的 $L \\times L$ 方格晶格上的位点。坐标是整数，$x_i, y_i \\in \\{0, 1, \\dots, L-1\\}$。链必须满足两个约束：连通性，即连续的单体 $\\mathbf{r}_i$ 和 $\\mathbf{r}_{i+1}$ 是晶格上的最近邻；以及自回避性，即对于 $i \\neq j$，有 $\\mathbf{r}_i \\neq \\mathbf{r}_j$。\n\n给定构象的能量由非键合单体之间有利接触的数量定义。具体来说，$E = -\\varepsilon C$，其中 $\\varepsilon=1$ 是能量单位，$C$ 是非键合的最近邻接触数。如果一对单体 $\\{i,j\\}$ 的序列分离度大于1（即 $|i-j|  1$），并且它们在环面晶格上的空间距离恰好为1，则它们形成一个非键合接触。两个位点 $\\mathbf{r}=(x,y)$ 和 $\\mathbf{r}'=(x',y')$ 之间的环面曼哈顿距离由 $\\min(|x-x'|, L - |x-x'|) + \\min(|y-y'|, L-|y-y'|)$ 给出。\n\n模拟通过 Metropolis-Hastings 算法进行。从一个指定的初始构象开始，执行一系列共 $M$ 次的移动尝试。在每次尝试中，通过对当前构象应用一个局域移动来提议一个新的构象。该移动根据能量变化 $\\Delta E$ 和系统温度 $T$ 被接受或拒绝。接受概率由 $p_{\\mathrm{acc}} = \\min\\{1, \\exp(-\\Delta E/T)\\}$ 给出。对于 $T=0$ 的特殊情况，只接受不增加能量的移动（$\\Delta E \\le 0$）。在整个模拟过程中，会跟踪遇到的最低能量。\n\n局域移动集被精确定义，包含两种类型的移动，每次尝试时以相等的概率选择其中一种：\n1.  **末端移动**：选择两个末端单体之一（索引为 $0$ 或 $N-1$）。为其提议一个新位置，该位置从其链上键合邻居的空闲最近邻位点中均匀随机选择。如果不存在这样的空闲位点，则移动尝试被拒绝。\n2.  **角翻转**：选择一个内部单体 $i \\in \\{1, \\dots, N-2\\}$。如果其键合邻居 $\\mathbf{r}_{i-1}$ 和 $\\mathbf{r}_{i+1}$ 在其周围形成一个 $90$ 度角（即最小位移向量 $\\mathbf{r}_{i-1}-\\mathbf{r}_i$ 和 $\\mathbf{r}_{i+1}-\\mathbf{r}_i$ 是正交单位向量），则提议移动到所形成的 $2 \\times 2$ 正方形的第四个角。新位置是 $\\mathbf{r}'_i = \\mathbf{r}_{i-1} + \\mathbf{r}_{i+1} - \\mathbf{r}_i$，所有坐标都对 $L$ 取模。如果该目标位点已被另一个单体占据，则移动尝试被拒绝。\n\n实现将直接遵循这些规范。对于每个测试用例，使用给定的参数 $(L, M, T, \\text{seed})$ 初始化一个模拟。初始构象是一个水平直链，$\\mathbf{r}_i = (i,0)$，其中 $i \\in \\{0, \\dots, 4\\}$。一个使用指定值作为种子的梅森旋转伪随机数生成器，确保每次运行时系统的演化是确定性的。构象的能量通过遍历所有非键合对来计算。为了提高效率，在模拟过程中，能量变化 $\\Delta E$ 是通过仅考虑被移动的单个单体的接触来局域计算的。程序将为每个测试用例执行模拟，并按指定格式报告找到的最低能量。对于 $M=0$ 的测试用例，不尝试任何移动，报告的最低能量就是初始构象的能量。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the polymer folding problem by running Monte Carlo simulations\n    for a given set of test cases.\n    \"\"\"\n\n    class PolymerSimulation:\n        \"\"\"\n        A class to encapsulate the state and methods for a single\n        polymer Monte Carlo simulation.\n        \"\"\"\n        def __init__(self, L, M, T, seed):\n            self.L = L\n            self.N = 5\n            self.M = M\n            self.T = T\n            self.rng = np.random.default_rng(seed)\n            \n            # Initial conformation: r_i = (i mod L, 0)\n            self.positions = np.array([[i % self.L, 0] for i in range(self.N)], dtype=np.int32)\n            \n            self.energy = self._calculate_total_energy()\n            self.min_energy = self.energy\n\n        def _get_toroidal_displacement(self, p1, p2):\n            \"\"\"Returns the minimal displacement vector from p2 to p1 on the torus.\"\"\"\n            disp = p1 - p2\n            if disp[0] > self.L / 2:\n                disp[0] -= self.L\n            elif disp[0]  -self.L / 2:\n                disp[0] += self.L\n            \n            if disp[1] > self.L / 2:\n                disp[1] -= self.L\n            elif disp[1]  -self.L / 2:\n                disp[1] += self.L\n            return disp\n\n        def _toroidal_manhattan_dist(self, p1, p2):\n            \"\"\"Calculates the Manhattan distance on the torus.\"\"\"\n            disp = np.abs(p1 - p2)\n            dx = min(disp[0], self.L - disp[0])\n            dy = min(disp[1], self.L - disp[1])\n            return dx + dy\n\n        def _calculate_total_energy(self):\n            \"\"\"Calculates the total energy of the current conformation.\"\"\"\n            contacts = 0\n            for i in range(self.N):\n                for j in range(i + 2, self.N):  # |i-j| > 1\n                    if self._toroidal_manhattan_dist(self.positions[i], self.positions[j]) == 1:\n                        contacts += 1\n            return -contacts\n\n        def _calculate_energy_change(self, moved_idx, new_pos):\n            \"\"\"Calculates the energy change resulting from moving a single monomer.\"\"\"\n            old_pos = self.positions[moved_idx]\n            old_contacts = 0\n            new_contacts = 0\n            \n            for i in range(self.N):\n                if i == moved_idx or abs(i - moved_idx) == 1:\n                    continue\n                \n                p_other = self.positions[i]\n                if self._toroidal_manhattan_dist(old_pos, p_other) == 1:\n                    old_contacts += 1\n                if self._toroidal_manhattan_dist(new_pos, p_other) == 1:\n                    new_contacts += 1\n\n            delta_C = new_contacts - old_contacts\n            # Energy E = -eps * C with eps=1\n            return -delta_C\n\n        def run(self):\n            \"\"\"Runs the Monte Carlo simulation for M steps.\"\"\"\n            if self.M == 0:\n                return self.min_energy\n\n            for _ in range(self.M):\n                current_occupied = {tuple(p) for p in self.positions}\n                proposal = None\n\n                # Choose move family: End move or Corner flip\n                if self.rng.random()  0.5:\n                    # Propose an End Move\n                    moved_idx = 0 if self.rng.random()  0.5 else self.N - 1\n                    neighbor_idx = 1 if moved_idx == 0 else self.N - 2\n                    neighbor_pos = self.positions[neighbor_idx]\n                    \n                    available_sites = []\n                    for move in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                        site = (neighbor_pos + move) % self.L\n                        if tuple(site) not in current_occupied:\n                            available_sites.append(site)\n                    \n                    if available_sites:\n                        new_pos_coord = self.rng.choice(available_sites, axis=0)\n                        proposal = (moved_idx, new_pos_coord)\n                else:\n                    # Propose a Corner Flip\n                    moved_idx = self.rng.choice([1, 2, 3])\n                    pos_i = self.positions[moved_idx]\n                    pos_prev = self.positions[moved_idx - 1]\n                    pos_next = self.positions[moved_idx + 1]\n                    \n                    disp_prev = self._get_toroidal_displacement(pos_prev, pos_i)\n                    disp_next = self._get_toroidal_displacement(pos_next, pos_i)\n                    \n                    is_corner = (np.sum(np.abs(disp_prev)) == 1 and\n                                 np.sum(np.abs(disp_next)) == 1 and\n                                 np.dot(disp_prev, disp_next) == 0)\n                    \n                    if is_corner:\n                        new_pos = (pos_i + disp_prev + disp_next) % self.L\n                        if tuple(new_pos) not in current_occupied:\n                            proposal = (moved_idx, new_pos)\n\n                if proposal is None:\n                    continue # Attempt rejected\n\n                moved_idx, new_pos = proposal\n                \n                delta_E = self._calculate_energy_change(moved_idx, new_pos)\n                \n                accept = False\n                if self.T == 0:\n                    if delta_E = 0:\n                        accept = True\n                else:\n                    if delta_E = 0 or self.rng.random()  np.exp(-delta_E / self.T):\n                        accept = True\n                \n                if accept:\n                    self.positions[moved_idx] = new_pos\n                    self.energy += delta_E\n                    self.min_energy = min(self.min_energy, self.energy)\n            \n            return self.min_energy\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (L, M, T, seed)\n        (6, 100000, 0.8, 20231102),\n        (5, 0, 0.5, 1),\n        (6, 30000, 5.0, 777),\n        (6, 5000, 0.2, 424242),\n    ]\n\n    results = []\n    for L, M, T, seed in test_cases:\n        sim = PolymerSimulation(L, M, T, seed)\n        min_e = sim.run()\n        results.append(int(min_e))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "与前两种通用的搜索算法不同，某些特定问题具有特殊的“最优子结构”特性，允许我们通过更巧妙的方式保证找到全局最优解。本练习以RNA二级结构预测为背景，引导你使用动态规划（Dynamic Programming）这一强大的算法范式。你将学习如何将一个复杂问题分解为一系列更小的、可管理的子问题，并自底向上地构建出全局最优解。这个实践不仅揭示了算法设计的美妙之处，还将其与一个重要的生物学过程——共转录折叠——紧密联系起来。",
            "id": "2388076",
            "problem": "要求您设计并实现一个程序，该程序在一个简化的能量模型下，通过每次添加一个核苷酸并重新最小化结构来模拟共转录核糖核酸（RNA）的折叠过程。核心计算任务是RNA二级结构的能量最小化，该问题以纯数学术语构建，并通过从第一性原理设计的算法求解。\n\n您必须依赖的基本原理包括：(i) RNA的规范碱基配对规则，(ii) 构成动态规划（DP）基础的最优性原理，以及(iii) 简化二级结构模型中独立结构组件自由能的可加性。您的程序应实现这些原理，而无需引入任何非基于这些原理推导的特定问题公式。\n\n考虑一个长度为 $L$ 的RNA一级序列 $S = (S_1, S_2, \\dots, S_L)$，其中每个 $S_i \\in \\{\\text{A}, \\text{U}, \\text{G}, \\text{C}\\}$。二级结构是索引对的集合 $X \\subset \\{(i,j) \\mid 1 \\le i  j \\le L\\}$，并遵循以下约束：\n- 每个索引最多出现在一个配对中。\n- 结构不允许交叉：对于任意 $(i,j) \\in X$ 和 $(k,\\ell) \\in X$，若 $i  k$，则当 $k  j$ 时必有 $\\ell  j$。\n- 只允许规范配对：$(\\text{A}, \\text{U})$, $(\\text{U}, \\text{A})$, $(\\text{G}, \\text{C})$, $(\\text{C}, \\text{G})$。\n- 强制执行最小发夹环长度约束 $h \\in \\mathbb{Z}_{\\ge 0}$：如果 $j - i - 1  h$，则禁止配对 $(i,j)$。\n\n在该简化模型下，二级结构 $X$ 的能量定义为\n$$\nE(X) \\;=\\; \\sum_{(i,j) \\in X} e_p \\;+\\; \\sum_{\\substack{(i,j) \\in X \\\\ (i+1,j-1) \\in X}} e_s,\n$$\n其中 $e_p \\in \\mathbb{R}$ 是每个碱基对的能量，而 $e_s \\in \\mathbb{R}$ 是为每个相邻的堆积对 $(i,j)$ 和 $(i+1,j-1)$ 添加一次的堆积能量。我们约定 $e_p  0$ 和 $e_s \\le 0$，未配对的核苷酸贡献的能量为 $0$。\n\n对于每个前缀长度 $t \\in \\{1,2,\\dots,L\\}$，将在索引 $\\{1,\\dots,t\\}$ 上的所有有效结构中的最小自由能（MFE）定义为\n$$\nM(t) \\;=\\; \\min\\{\\, E(X) \\mid X \\text{ is a valid structure on } \\{1,\\dots,t\\}\\,\\}.\n$$\n共转录折叠通过计算序列 $\\big(M(1), M(2), \\dots, M(L)\\big)$ 来建模，在每一步 $t$ 中，新添加的核苷酸可以形成或断开碱基对，以便在上述约束条件下最小化能量。\n\n您的任务是：\n- 从最优性原理和上述约束出发，推导出一个计算所有 $t \\in \\{1,\\dots,L\\}$ 的 $M(t)$ 的算法方案。\n- 实现一个正确且高效的程序，对于下面的每个测试用例，输出列表 $\\big(M(1), M(2), \\dots, M(L)\\big)$，所有值四舍五入到一位小数。\n\n测试套件。对于每个测试用例，给定一个序列 $S$、每个碱基对的能量 $e_p$、堆积能量 $e_s$ 和最小发夹环长度 $h$。在所有情况下，仅使用如上定义的规范配对。\n- 测试用例 1：$S=\\text{\"GCGC\"}$, $e_p=-1.0$, $e_s=-0.5$, $h=0$。\n- 测试用例 2：$S=\\text{\"AUGC\"}$, $e_p=-1.0$, $e_s=-0.5$, $h=3$。\n- 测试用例 3：$S=\\text{\"AUAU\"}$, $e_p=-1.0$, $e_s=-0.2$, $h=0$。\n- 测试用例 4：$S=\\text{\"AAAAAA\"}$, $e_p=-1.0$, $e_s=-0.5$, $h=0$。\n- 测试用例 5：$S=\\text{\"GCGC\"}$, $e_p=-1.0$, $e_s=-0.5$, $h=1$。\n\n您的程序应生成单行输出，包含一个由列表组成的列表，以逗号分隔，无空格，并用方括号括起来。每个内部列表必须按顺序包含该测试用例的 $L$ 个四舍五入后的值 $M(1),\\dots,M(L)$。例如，格式必须类似于 $[\\,[m_{1,1},\\dots,m_{1,L_1}],[m_{2,1},\\dots,m_{2,L_2}],\\dots\\,]$，并且必须精确打印为 \"[[...],[...],...]\"。将每个能量值四舍五入到一位小数。此问题不涉及物理单位或角度单位。",
            "solution": "所提出的问题是一个有效、适定的科学问题，它植根于计算生物学的原理，并且可以通过严谨的算法设计来解决。\n\n它要求推导并实现一个动态规划（DP）算法，以在简化的能量模型下模拟RNA序列的共转录折叠。\n\n核心任务是计算给定RNA序列 $S$ 的所有前缀的最小自由能（MFE）。令 $S_{i \\dots j}$ 表示从索引 $i$到 $j$的子序列。长度为 $t$ 的前缀 $S_{1 \\dots t}$ 的MFE记为 $M(t)$。该值对应于整个子序列 $S_{1 \\dots t}$ 的MFE，我们可以通过解决寻找任何子序列 $S_{i \\dots j}$ 的MFE的通用问题来找到它。\n\n最优性原理指出，一个问题的最优解包含其子问题的最优解。这是动态规划的基础。一个无交叉的RNA二级结构可以分解为更小的、独立的子结构，这使得基于DP的解决方案成为可能。所提供的能量函数 $E(X) = \\sum_{(i,j) \\in X} e_p + \\sum_{\\text{stacks}} e_s$ 是局部的和可加的，满足DP的要求。\n\n我们定义两个耦合的DP表：\n1. $W(i, j)$: 子序列 $S_{i \\dots j}$ 上任何有效二级结构的最小自由能。\n2. $V(i, j)$: 子序列 $S_{i \\dots j}$ 上任何有效二级结构的最小自由能，但有明确约束，即端点 $i$ 和 $j$ 形成一个碱基对。\n\n这些表中的值是针对长度递增的子序列计算的。最终所需量 $M(t)$ 由前缀 $S_{1 \\dots t}$ 的 $W(1, t)$ 给出。\n\n递推关系是通过考虑子序列 $S_{i \\dots j}$ 边界处核苷酸所有可能的结构状态推导出来的。\n\n**$W(i, j)$ 的递推关系**\n\n为计算 $W(i, j)$，我们考虑索引 $j$ 处核苷酸的两种互斥情况：\n1. **$j$ 未配对**：在这种情况下，核苷酸 $S_j$ 不对能量产生贡献。子序列 $S_{i \\dots j}$ 的MFE与子序列 $S_{i \\dots j-1}$ 的MFE相同。因此能量为 $W(i, j-1)$。\n2. **$j$ 与 $k$ 配对**：核苷酸 $S_j$ 与核苷酸 $S_k$ 形成配对，其中 $i \\le k  j$。由于无交叉约束，配对 $(k, j)$ 将子序列 $S_{i \\dots j}$ 分为两个独立的区域：外部区域 $S_{i \\dots k-1}$ 和由该配对包围的区域 $S_{k+1 \\dots j-1}$。总能量是外部区域MFE $W(i, k-1)$ 与由配对 $(k,j)$ 闭合的结构MFE之和，后者恰好是 $V(k, j)$。我们必须对所有可能的配对伙伴 $k$ 进行最小化。\n\n结合这些情况，我们得到 $W(i, j)$ 的递推关系：\n$$\nW(i, j) = \\min \\left( W(i, j-1), \\quad \\min_{i \\le k  j, \\text{ valid pair } (k,j)} \\left\\{ W(i, k-1) + V(k, j) \\right\\} \\right)\n$$\n如果 $S_k$ 和 $S_j$ 是规范互补的，并且满足环长度约束 $j-k-1 \\ge h$，则配对 $(k,j)$ 是有效的。基本情况是 $W(i, i-1) = 0$（对于空子序列）和 $W(i, i) = 0$。\n\n**$V(i, j)$ 的递推关系**\n\n为计算 $V(i, j)$，我们假设配对 $(i, j)$ 已经形成。如果 $(i, j)$ 不是有效配对（非规范配对或 $j-i-1  h$），则 $V(i, j) = \\infty$。否则，总能量是配对 $(i,j)$ 本身的能量与内部区域 $S_{i+1 \\dots j-1}$ 的MFE之和。配对 $(i,j)$ 贡献 $e_p$。内部区域的结构可以是以下之一：\n1. **发夹环**：内部区域 $S_{i+1 \\dots j-1}$ 完全未配对。其能量贡献为 $0$。\n2. **堆积对**：配对 $(i, j)$ 堆积在相邻的配对 $(i+1, j-1)$ 之上。该结构是一个配对 $(i,j)$ 包围着一个更小的子结构，而该子结构本身由配对 $(i+1, j-1)$ 闭合。能量贡献是堆积能量 $e_s$ 加上由 $(i+1, j-1)$ 闭合的结构的MFE，即 $V(i+1, j-1)$。\n3. **多分支环**：内部区域 $S_{i+1 \\dots j-1}$ 分解为两个或多个独立的子结构。对于一个简单的分叉，该区域在某个索引 $k$（$i+1 \\le k  j-1$）处分裂成两个关于 $S_{i+1 \\dots k}$ 和 $S_{k+1 \\dots j-1}$ 的独立子问题。MFE是 $W(i+1, k) + W(k+1, j-1)$ 的和。我们对所有可能的分裂点 $k$ 进行最小化。\n\n因此，$V(i, j)$ 的递推关系是：\n$$\nV(i, j) = e_p + \\min \\left( E_{\\text{hairpin}}, E_{\\text{stack}}, E_{\\text{multi}} \\right)\n$$\n其中：\n- $E_{\\text{hairpin}} = 0$\n- $E_{\\text{stack}} = e_s + V(i+1, j-1)$\n- $E_{\\text{multi}} = \\min_{i+1 \\le k  j-1} \\{W(i+1, k) + W(k+1, j-1)\\}$\n\n这些递推关系定义了一个完整的DP算法。为了模拟共转录折叠，我们迭代地应用此算法。对于每个前缀长度 $t = 1, \\dots, L$，我们求解序列 $S_{1 \\dots t}$ 的MFE，即 $W(1, t)$。这涉及计算 $S_{1 \\dots t}$ 内所有子序列的DP表 $W$ 和 $V$。每个测试用例的结果是这些MFE值的序列，$(M(1), M(2), \\dots, M(L))$。提供的解决方案通过为每个前缀长度从头重新计算MFE来实现这一点。考虑到测试套件中的序列长度较小，这种 $O(L^4)$ 的方法在计算上是可行的且正确的。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Global constant for infinity\nINF = np.inf\n\ndef get_canonical_pairs():\n    \"\"\"Returns a set of canonical RNA base pairs.\"\"\"\n    return {('A', 'U'), ('U', 'A'), ('G', 'C'), ('C', 'G')}\n\ndef compute_mfe_for_prefix(S_prefix, ep, es, h, canonical_pairs):\n    \"\"\"\n    Computes the Minimum Free Energy (MFE) for a given RNA sequence prefix.\n\n    This function implements a dynamic programming algorithm based on the Zuker-Stankiewicz\n    model, simplified according to the problem statement.\n    \"\"\"\n    N = len(S_prefix)\n    if N == 0:\n        return 0.0\n\n    # W[i][j]: MFE for any valid structure on subsequence S[i...j]\n    W = np.full((N, N), 0.0)\n    # V[i][j]: MFE for a structure on S[i...j] that is CLOSED by pair (i,j)\n    V = np.full((N, N), INF)\n\n    # d is the length of the subsequence minus 1.\n    for d in range(1, N):\n        for i in range(N - d):\n            j = i + d\n\n            # --- Calculate V[i][j] ---\n            if (S_prefix[i], S_prefix[j]) in canonical_pairs and (j - i - 1 >= h):\n                # Hairpin loop: region i+1...j-1 is unpaired.\n                e_hairpin = 0.0\n\n                # Stacked pair: pair (i,j) stacks on (i+1,j-1)\n                e_stack = es + V[i+1][j-1] if d > 1 else INF\n\n                # Multiloop (bifurcation): internal region i+1...j-1 splits\n                e_multi = INF\n                if d > 1: # A multiloop requires at least one split point\n                    for k in range(i + 1, j):\n                        e_multi = min(e_multi, W[i+1][k] + W[k+1][j-1])\n                \n                V[i][j] = ep + min(e_hairpin, e_stack, e_multi)\n\n            # --- Calculate W[i][j] ---\n            # Case 1: j is unpaired\n            e_unpaired = W[i][j-1]\n\n            # Case 2: j is paired with some k  j\n            e_paired = INF\n            for k in range(i, j):\n                # The pair (k,j) must be valid (pre-calculated in V)\n                if V[k][j] != INF:\n                    energy_prefix = W[i][k-1] if k > i else 0.0\n                    e_paired = min(e_paired, energy_prefix + V[k][j])\n            \n            W[i][j] = min(e_unpaired, e_paired)\n    \n    return W[0][N-1] if N > 0 else 0.0\n\ndef solve():\n    \"\"\"\n    Main function to process test cases and print final results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\"S\": \"GCGC\", \"ep\": -1.0, \"es\": -0.5, \"h\": 0},\n        {\"S\": \"AUGC\", \"ep\": -1.0, \"es\": -0.5, \"h\": 3},\n        {\"S\": \"AUAU\", \"ep\": -1.0, \"es\": -0.2, \"h\": 0},\n        {\"S\": \"AAAAAA\", \"ep\": -1.0, \"es\": -0.5, \"h\": 0},\n        {\"S\": \"GCGC\", \"ep\": -1.0, \"es\": -0.5, \"h\": 1},\n    ]\n\n    canonical_pairs = get_canonical_pairs()\n    all_results = []\n\n    for case in test_cases:\n        S, ep, es, h = case[\"S\"], case[\"ep\"], case[\"es\"], case[\"h\"]\n        L = len(S)\n        m_sequence = []\n        for t in range(1, L + 1):\n            prefix = S[:t]\n            mfe = compute_mfe_for_prefix(prefix, ep, es, h, canonical_pairs)\n            m_sequence.append(round(mfe, 1))\n        all_results.append(m_sequence)\n\n    # Format the final output according to problem specifications.\n    # The output is a comma-separated list of lists, with no spaces.\n    inner_lists_str = [f\"[{','.join(map(str, sublist))}]\" for sublist in all_results]\n    print(f\"[{','.join(inner_lists_str)}]\")\n\nsolve()\n```"
        }
    ]
}