{
    "hands_on_practices": [
        {
            "introduction": "在深入研究复杂的可训练图神经网络之前，理解其基本运算机制至关重要。本练习将引导你构建一个确定性的模型，通过 GNN 的前向传播过程来精确计数特定的化学子结构，从而揭开其神秘面纱。通过这个实践，你将了解到 GNN 如何学习原子的局部环境，并为掌握更高级的概念打下坚实的基础。",
            "id": "2395403",
            "problem": "给定一个图神经网络（GNN；Graph Neural Network）的形式化规范，该网络能生成一个可解释的二元分子指纹，其中每个比特位对应一个精确定义的子结构特征。分子被表示为一个无向标记图，其中原子为节点，化学键为边。每个节点具有一个one-hot原子类型特征，每条边具有一个one-hot键类型特征。该GNN是基于第一性原理定义的，无需学习训练，仅使用固定的、确定性的操作。\n\n原子特征编码和键特征编码：\n- 原子类型字母表按碳 (C)、氧 (O)、氮 (N)、氢 (H) 的顺序排列。对于一个节点 $i$，其原子类型one-hot向量为 $x_i \\in \\mathbb{R}^4$，遵循此顺序。也就是说，如果 $i$ 是碳，则 $x_i = [1,0,0,0]^\\top$；如果 $i$ 是氧，则 $x_i = [0,1,0,0]^\\top$；如果 $i$ 是氮，则 $x_i = [0,0,1,0]^\\top$；如果 $i$ 是氢，则 $x_i = [0,0,0,1]^\\top$。\n- 键类型字母表按单键、双键的顺序排列。对于一条无向边 $\\{i,j\\}$，为计算目的定义两条有向边 $(i,j)$ 和 $(j,i)$。每条有向边 $(i,j)$ 都有一个键类型one-hot向量 $e_{ij} \\in \\mathbb{R}^2$，其中单键为 $e_{ij} = [1,0]^\\top$，双键为 $e_{ij} = [0,1]^\\top$。\n\n消息、节点表示和图表示：\n- 对于每个节点 $i$，定义其邻居集合 $N(i)$ 为所有满足 $\\{i,j\\}$ 是一条边的节点 $j$。在节点 $i$ 处聚合的消息是\n$$\nm_i \\;=\\; \\sum_{j \\in N(i)} \\left( x_j \\otimes e_{ij} \\right) \\in \\mathbb{R}^8,\n$$\n其中 $\\otimes$ 表示克罗内克积。在指定的原子顺序和键顺序下，$x_j \\otimes e_{ij}$ 按块枚举邻居原子类型与键类型的有序组合：对于邻居类型索引 $b \\in \\{0,1,2,3\\}$ 和键类型索引 $t \\in \\{0,1\\}$，坐标索引为 $b \\cdot 2 + t$。\n- 对于每个节点 $i$，定义其类型化邻域张量展平后的向量为\n$$\nH_i \\;=\\; x_i \\otimes m_i \\in \\mathbb{R}^{32}.\n$$\n在指定的中心原子顺序和邻居-键顺序下，坐标索引为：对于中心原子索引 $a \\in \\{0,1,2,3\\}$、邻居原子索引 $b \\in \\{0,1,2,3\\}$ 和键类型索引 $t \\in \\{0,1\\}$，\n$$\n\\text{index}(a,b,t) \\;=\\; a \\cdot 8 \\;+\\; b \\cdot 2 \\;+\\; t.\n$$\n- 图级别的表示是所有节点表示的总和：\n$$\ns \\;=\\; \\sum_{i} H_i \\in \\mathbb{R}^{32}.\n$$\n\n可解释指纹读出：\n您将计算一个 $4$ 比特的指纹 $f \\in \\{0,1\\}^4$，其比特位由 $s$ 中相应计数的简单线性阈值定义：\n- 比特位 $0$（C–O单键的存在）：令 $k_0 = \\text{index}(a{=}0, b{=}1, t{=}0) = 0 \\cdot 8 + 1 \\cdot 2 + 0 = 2$。定义logit值 $\\ell_0 = s_{k_0} - 0.5$。如果 $\\ell_0 \\ge 0$，则设 $f_0 = 1$，否则 $f_0 = 0$。\n- 比特位 $1$（C=O双键的存在）：令 $k_1 = \\text{index}(a{=}0, b{=}1, t{=}1) = 0 \\cdot 8 + 1 \\cdot 2 + 1 = 3$。定义logit值 $\\ell_1 = s_{k_1} - 0.5$。如果 $\\ell_1 \\ge 0$，则设 $f_1 = 1$，否则 $f_1 = 0$。\n- 比特位 $2$（分子中任何位置存在至少两个N–H单键）：令 $k_2 = \\text{index}(a{=}2, b{=}3, t{=}0) = 2 \\cdot 8 + 3 \\cdot 2 + 0 = 22$。定义logit值 $\\ell_2 = s_{k_2} - 1.5$。如果 $\\ell_2 \\ge 0$，则设 $f_2 = 1$，否则 $f_2 = 0$。\n- 比特位 $3$（C–C单键的存在）：令 $k_3 = \\text{index}(a{=}0, b{=}0, t{=}0) = 0 \\cdot 8 + 0 \\cdot 2 + 0 = 0$。定义logit值 $\\ell_3 = s_{k_3} - 0.5$。如果 $\\ell_3 \\ge 0$，则设 $f_3 = 1$，否则 $f_3 = 0$。\n\n请注意，每个比特位都对应于在整个图上聚合的、明确定义的有向边类型计数，从而提供了可解释性：比特位 $0$ 统计以C为中心、通过单键连接的O邻居数量；比特位 $1$ 统计以C为中心、通过双键连接的O邻居数量；比特位 $2$ 统计以N为中心、通过单键连接的H邻居数量；比特位 $3$ 统计以C为中心、通过单键连接的C邻居数量。\n\n测试套件的输入数据：\n对于每个测试用例，您将获得：\n- 一个有序的原子类型列表（每个类型来自集合{C, O, N, H}），索引从 $0$ 到 $n-1$，其中 $n$ 是原子数。\n- 一个无向键列表，表示为三元组 $(i,j,\\text{type})$，其中 $i$ 和 $j$ 是整数节点索引，$\\text{type} \\in \\{\\text{single}, \\text{double}\\}$。在上述GNN计算中，每个无向键 $\\{i,j\\}$ 都应被视为两个具有相同类型的有向键 $(i,j)$ 和 $(j,i)$。\n\n测试套件分子：\n- 测试用例 $1$（乙醇；$\\mathrm{C_2H_6O}$）：\n  - 原子（索引 $0$ 到 $8$）：[C, C, O, H, H, H, H, H, H]\n  - 化学键：$(0,1,\\text{single})$, $(1,2,\\text{single})$, $(0,3,\\text{single})$, $(0,4,\\text{single})$, $(0,5,\\text{single})$, $(1,6,\\text{single})$, $(1,7,\\text{single})$, $(2,8,\\text{single})$。\n- 测试用例 $2$（甲醛；$\\mathrm{CH_2O}$）：\n  - 原子（索引 $0$ 到 $3$）：[C, O, H, H]\n  - 化学键：$(0,1,\\text{double})$, $(0,2,\\text{single})$, $(0,3,\\text{single})$。\n- 测试用例 $3$（氨；$\\mathrm{NH_3}$）：\n  - 原子（索引 $0$ 到 $3$）：[N, H, H, H]\n  - 化学键：$(0,1,\\text{single})$, $(0,2,\\text{single})$, $(0,3,\\text{single})$。\n- 测试用例 $4$（乙烷；$\\mathrm{C_2H_6}$）：\n  - 原子（索引 $0$ 到 $7$）：[C, C, H, H, H, H, H, H]\n  - 化学键：$(0,1,\\text{single})$, $(0,2,\\text{single})$, $(0,3,\\text{single})$, $(0,4,\\text{single})$, $(1,5,\\text{single})$, $(1,6,\\text{single})$, $(1,7,\\text{single})$。\n- 测试用例 $5$（水；$\\mathrm{H_2O}$）：\n  - 原子（索引 $0$ 到 $2$）：[O, H, H]\n  - 化学键：$(0,1,\\text{single})$, $(0,2,\\text{single})$。\n- 测试用例 $6$（丙酮；$\\mathrm{C_3H_6O}$，重原子骨架为 $\\mathrm{O{=}C{-}C}$，带有甲基）：\n  - 原子（索引 $0$ 到 $9$）：[O, C, C, C, H, H, H, H, H, H]\n  - 化学键：$(1,0,\\text{double})$, $(1,2,\\text{single})$, $(1,3,\\text{single})$, $(2,4,\\text{single})$, $(2,5,\\text{single})$, $(2,6,\\text{single})$, $(3,7,\\text{single})$, $(3,8,\\text{single})$, $(3,9,\\text{single})$。\n\n程序所需行为和输出格式：\n- 仅使用给定的原子和键编码、克罗内克积和求和运算，实现上述精确的GNN计算。\n- 按所列顺序为每个测试用例计算指纹 $f \\in \\{0,1\\}^4$。\n- 您的程序应生成单行输出，其中包含六个指纹的结果，形式为一个逗号分隔的列表。每个指纹本身也是一个由四个整数组成的逗号分隔列表，所有内容都用方括号括起来。例如：“[[a,b,c,d],[e,f,g,h],...]”，其中每个字母为 $0$ 或 $1$。",
            "solution": "问题陈述被认定为有效。它有科学依据、良构且客观，为一种确定性图神经网络（GNN）算法提供了完整且一致的规范。陈述中没有事实错误、矛盾或歧义。因此，我们将着手构建解决方案。\n\n任务是实现一个计算4比特分子指纹的GNN。这个GNN并非需要训练的典型机器学习模型；相反，它是一个基于第一性原理定义的、固定的、确定性的特征提取器。从原子特征编码到最终指纹的整个过程，都基于一系列精确定义的数学运算。\n\n该GNN的基础在于其分层特征表示，该表示是使用克罗内克积（$\\otimes$）构建的。特征向量和操作的设计确保了最终的图级别表示 $s \\in \\mathbb{R}^{32}$ 具有清晰的物理释义。$s$ 的每个分量都对应于分子图中特定类型的有向、类型化边的计数。\n\n让我们逐步剖析其构建过程。\n\n1.  **原子和键级别编码**：\n    初始特征是表示离散类别的one-hot向量。对于原子 $i$，其特征 $x_i \\in \\mathbb{R}^4$ 标识其在集合 $\\{\\text{C, O, N, H}\\}$ 中的类型。对于有向边 $(i, j)$，其特征 $e_{ij} \\in \\mathbb{R}^2$ 标识其在集合 $\\{\\text{Single, Double}\\}$ 中的键类型。这种离散编码是所有后续操作的基础。\n\n2.  **消息构建**：\n    对于每个节点 $i$，从其邻居 $j \\in N(i)$ 聚合一个消息向量 $m_i \\in \\mathbb{R}^8$。消息定义为：\n    $$\n    m_i \\;=\\; \\sum_{j \\in N(i)} \\left( x_j \\otimes e_{ij} \\right)\n    $$\n    克罗内克积 $x_j \\otimes e_{ij}$ 产生一个8维向量。由于 $x_j$ 和 $e_{ij}$ 都是one-hot向量，因此 $x_j \\otimes e_{ij}$ 也是一个one-hot向量。其唯一的非零项唯一地标识了邻居原子类型（4种选择）和连接键类型（2种选择）的组合，总共有 $4 \\times 2 = 8$ 种可能性。因此，对所有邻居 $j \\in N(i)$ 的求和使得 $m_i$ 成为一个直方图向量。每个分量 $(m_i)_k$ 计​​算节点 $i$ 的邻居中对应于第 $k$ 种原子类型和键类型组合的数量。例如，如果邻居原子类型用 $b \\in \\{0,1,2,3\\}$ 索引，键类型用 $t \\in \\{0,1\\}$ 索引，则 $m_i$ 在索引 $k = b \\cdot 2 + t$ 处的分量是通过 $t$ 类型键连接到 $i$ 的 $b$ 类型邻居的数量。\n\n3.  **节点表示**：\n    每个节点 $i$ 的表示 $H_i \\in \\mathbb{R}^{32}$ 是通过将其自身特征向量 $x_i$ 与其聚合的消息 $m_i$ 相结合来计算的：\n    $$\n    H_i \\;=\\; x_i \\otimes m_i\n    $$\n    此操作将局部邻域信息（$m_i$）嵌入到一个更大的特征空间中，该空间按中心原子 $i$ 的类型进行划分。最终的32维空间是由中心原子 $i$ 的4种可能类型与8维邻域直方图组合而成的。$H_i$ 在索引 $k = a \\cdot 8 + b \\cdot 2 + t$（其中 $a$ 是原子 $i$ 的类型索引）处的分量只有在原子 $i$ 的类型为 $a$ 时才非零。如果非零，其值将是通过 $t$ 类型键连接的 $b$ 类型邻居的数量。\n\n4.  **图级别表示**：\n    最终的图级别表示 $s \\in \\mathbb{R}^{32}$ 是所有节点表示的总和：\n    $$\n    s \\;=\\; \\sum_{i} H_i\n    $$\n    由于 $H_i$ 的结构，这个求和具有非常具体的含义。让我们考虑分量 $s_k$，其中 $k = a \\cdot 8 + b \\cdot 2 + t$。\n    $$\n    s_k = \\left( \\sum_{i} H_i \\right)_k = \\sum_{i} (H_i)_k = \\sum_{\\substack{i \\text{ s.t.} \\\\ \\text{type}(i)=a}} (m_i)_{b \\cdot 2 + t}\n    $$\n    如前所述，$(m_i)_{b \\cdot 2 + t}$ 是通过 $t$ 类型键连接到 $i$ 的 $b$ 类型邻居的数量。将这个值对所有类型为 $a$ 的节点 $i$ 求和，就得到了图中从类型为 $a$ 的原子开始、到类型为 $b$ 的原子结束、且键类型为 $t$ 的有向边的总数。$s$ 的分量与子结构计数之间的这种直接对应关系是该模型可解释性的关键。\n\n5.  **可解释指纹读出**：\n    4比特指纹 $f$ 是通过对 $s$ 的特定分量应用简单的阈值规则得出的。每个比特位都用于测试特定分子特征的存在。\n    - **比特位 0 (C–O 单键)**：相关子结构是从碳（$a=0$）到氧（$b=1$）的单键（$t=0$）有向边。对应的索引是 $k_0 = 0 \\cdot 8 + 1 \\cdot 2 + 0 = 2$。值 $s_2$ 是此类 `C->O` 单键的总数。条件是 $s_2 - 0.5 \\ge 0$，对于整数计数 $s_2$ 来说，这等价于 $s_2 \\ge 1$。这正确地检查了是否存在至少一个C–O单键。\n    - **比特位 1 (C=O 双键)**：对应于索引 $k_1 = \\text{index}(a=0, b=1, t=1) = 3$。条件 $s_3 - 0.5 \\ge 0$ 等价于 $s_3 \\ge 1$，用于检查是否存在至少一个 `C->O` 双键。\n    - **比特位 2 (至少两个 N–H 单键)**：对应于索引 $k_2 = \\text{index}(a=2, b=3, t=0) = 22$。值 $s_{22}$ 计算所有 `N->H` 单键的数量。条件是 $s_{22} - 1.5 \\ge 0$，等价于 $s_{22} \\ge 2$，这正确地检查了是否存在至少两个此类键。\n    - **比特位 3 (C–C 单键)**：对应于索引 $k_3 = \\text{index}(a=0, b=0, t=0) = 0$。条件 $s_0 - 0.5 \\ge 0$ 等价于 $s_0 \\ge 1$，用于检查是否存在至少一个 `C->C` 单键。\n\n因此，该算法是一个在GNN框架内实现的精确、可解释的计数机制。实现将直接遵循这些步骤来为给定的测试用例计算指纹。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the specified GNN to compute molecular fingerprints.\n    \"\"\"\n    atom_map = {'C': 0, 'O': 1, 'N': 2, 'H': 3}\n    bond_map = {'single': 0, 'double': 1}\n    num_atom_types = 4\n    num_bond_types = 2\n\n    # Define the atom and bond one-hot basis vectors.\n    atom_basis = np.identity(num_atom_types)\n    bond_basis = np.identity(num_bond_types)\n    \n    test_cases = [\n        # Test case 1 (Ethanol)\n        {\n            \"atoms\": ['C', 'C', 'O', 'H', 'H', 'H', 'H', 'H', 'H'],\n            \"bonds\": [(0, 1, 'single'), (1, 2, 'single'), (0, 3, 'single'), (0, 4, 'single'), (0, 5, 'single'), (1, 6, 'single'), (1, 7, 'single'), (2, 8, 'single')]\n        },\n        # Test case 2 (Formaldehyde)\n        {\n            \"atoms\": ['C', 'O', 'H', 'H'],\n            \"bonds\": [(0, 1, 'double'), (0, 2, 'single'), (0, 3, 'single')]\n        },\n        # Test case 3 (Ammonia)\n        {\n            \"atoms\": ['N', 'H', 'H', 'H'],\n            \"bonds\": [(0, 1, 'single'), (0, 2, 'single'), (0, 3, 'single')]\n        },\n        # Test case 4 (Ethane)\n        {\n            \"atoms\": ['C', 'C', 'H', 'H', 'H', 'H', 'H', 'H'],\n            \"bonds\": [(0, 1, 'single'), (0, 2, 'single'), (0, 3, 'single'), (0, 4, 'single'), (1, 5, 'single'), (1, 6, 'single'), (1, 7, 'single')]\n        },\n        # Test case 5 (Water)\n        {\n            \"atoms\": ['O', 'H', 'H'],\n            \"bonds\": [(0, 1, 'single'), (0, 2, 'single')]\n        },\n        # Test case 6 (Acetone)\n        {\n            \"atoms\": ['O', 'C', 'C', 'C', 'H', 'H', 'H', 'H', 'H', 'H'],\n            \"bonds\": [(1, 0, 'double'), (1, 2, 'single'), (1, 3, 'single'), (2, 4, 'single'), (2, 5, 'single'), (2, 6, 'single'), (3, 7, 'single'), (3, 8, 'single'), (3, 9, 'single')]\n        }\n    ]\n\n    all_fingerprints = []\n\n    for case in test_cases:\n        atoms = case[\"atoms\"]\n        bonds = case[\"bonds\"]\n        num_atoms = len(atoms)\n\n        # 1. Build atom feature vectors and adjacency list\n        atom_features = [atom_basis[atom_map[atom_name]] for atom_name in atoms]\n        \n        adj = [[] for _ in range(num_atoms)]\n        for i, j, bond_type_name in bonds:\n            bond_type_idx = bond_map[bond_type_name]\n            adj[i].append((j, bond_type_idx))\n            adj[j].append((i, bond_type_idx))\n            \n        # 2. Compute GNN representations\n        graph_s = np.zeros(32)\n\n        for i in range(num_atoms):\n            # Message aggregation\n            m_i = np.zeros(8)\n            for j, bond_type_idx in adj[i]:\n                x_j = atom_features[j]\n                e_ij = bond_basis[bond_type_idx]\n                m_i += np.kron(x_j, e_ij)\n            \n            # Node representation\n            x_i = atom_features[i]\n            H_i = np.kron(x_i, m_i)\n            \n            # Graph-level aggregation\n            graph_s += H_i\n\n        # 3. Compute fingerprint\n        fingerprint = [0, 0, 0, 0]\n        \n        # Bit 0 (C-O single): k0 = index(a=0, b=1, t=0) = 2\n        k0 = 2\n        l0 = graph_s[k0] - 0.5\n        if l0 >= 0:\n            fingerprint[0] = 1\n\n        # Bit 1 (C=O double): k1 = index(a=0, b=1, t=1) = 3\n        k1 = 3\n        l1 = graph_s[k1] - 0.5\n        if l1 >= 0:\n            fingerprint[1] = 1\n\n        # Bit 2 (>=2 N-H single): k2 = index(a=2, b=3, t=0) = 22\n        k2 = 22\n        l2 = graph_s[k2] - 1.5\n        if l2 >= 0:\n            fingerprint[2] = 1\n\n        # Bit 3 (C-C single): k3 = index(a=0, b=0, t=0) = 0\n        k3 = 0\n        l3 = graph_s[k3] - 0.5\n        if l3 >= 0:\n            fingerprint[3] = 1\n            \n        all_fingerprints.append(fingerprint)\n\n    # Format output as required\n    result_str = \",\".join([f\"[{','.join(map(str, fp))}]\" for fp in all_fingerprints])\n    print(f\"[{result_str}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "掌握了 GNN 的基本特征工程原理后，我们可以将其应用于实际的属性预测任务。本练习要求你为一个经典的生物信息学问题——利用“李宾斯基五规则”评估分子的“类药性”——设计一个 GNN。通过这个练习，你不仅会实现一个评分函数，还会发现一个关键的洞见：对于那些可简单地通过原子贡献求和得到的性质，GNN 的消息传递机制可以被简化，这突显了根据问题的内在结构来定制模型架构的重要性。",
            "id": "2395422",
            "problem": "要求您形式化一个有原则的、置换不变的图神经网络 (GNN) 程序，以基于 Lipinski 五规则对分子的“类药性”进行评分，且仅使用第一性原理定义和广泛接受的事实。您必须生成一个完整的程序来实现您的设计，并在提供的测试套件上进行评估。\n\n从以下基本基础开始：\n- 一个分子可以被建模为一个无向图，其邻接矩阵为 $A \\in \\{0,1\\}^{n \\times n}$，节点特征为 $X \\in \\mathbb{R}^{n \\times d}$，其中 $n$ 是原子（节点）的数量，$d$ 是特征维度。\n- 一个带有消息传递的图神经网络 (GNN) 使用置换不变的聚合来获得图级表示。求和聚合对于节点排序是不变的。\n- Lipinski 五规则指出，口服类药分子通常满足四个约束条件：分子量 $\\leq 500$（单位 $\\mathrm{g/mol}$），油水分配系数 $\\log P \\leq 5$（无单位），氢键供体 $\\leq 5$（无量纲计数），以及氢键受体 $\\leq 10$（无量纲计数）。这些是经验启发式规则，并为软满足分数提供了一个合理的目标。\n\n您的任务：\n1. 将每个分子建模为一个图，其邻接矩阵为 $A$，节点特征为 $X$，其中每个节点特征向量按顺序包含四个分量：\n   - 对分子量的单原子贡献（单位：$\\mathrm{g/mol}$），\n   - 对 $\\log P$ 的单原子贡献（无单位，遵循简化的片段加和近似），\n   - 单原子氢键供体指示符（$0$ 或 $1$），\n   - 单原子氢键受体指示符（$0$ 或 $1$）。\n   四个全局分子性质是相应分量在所有节点上的总和。\n2. 设计一个单层消息传递图神经网络 (GNN)，该网络是置换不变的，并通过求和池化生成图级嵌入。使用线性消息传递更新和求和池化，以便可以通过合适的线性读出从节点级贡献中精确恢复可加的图级性质。\n3. 根据预测的性质，使用一个由每个规则的阈值归一化的 hinge 风格的惩罚，定义一个可微的软满足分数 $s \\in [0,1]$。令 $\\phi(z) = \\max(0,z)$ 表示修正线性单元。定义四个归一化的违规量\n   $$v_{\\mathrm{MW}} = \\phi\\left(\\frac{\\mathrm{MW} - 500}{500}\\right), \\quad v_{\\log P} = \\phi\\left(\\frac{\\log P - 5}{5}\\right), \\quad v_{\\mathrm{HBD}} = \\phi\\left(\\frac{\\mathrm{HBD} - 5}{5}\\right), \\quad v_{\\mathrm{HBA}} = \\phi\\left(\\frac{\\mathrm{HBA} - 10}{10}\\right).$$\n   然后定义\n   $$s = \\mathrm{clip}\\left(1 - \\frac{v_{\\mathrm{MW}} + v_{\\log P} + v_{\\mathrm{HBD}} + v_{\\mathrm{HBA}}}{4}, \\, 0, \\, 1\\right),$$\n   其中 $\\mathrm{MW}$ 的单位是 $\\mathrm{g/mol}$，$\\log P$ 是无单位的，$\\mathrm{HBD}$ 和 $\\mathrm{HBA}$ 是无量纲的计数。最终分数 $s$ 是无单位的。clip 是逐元素裁剪到 $[0,1]$ 区间内。\n4. 将此过程实现为一个完整的、可运行的程序，并在下面的测试套件上进行评估。最终程序必须打印出测试用例的分数，四舍五入到三位小数。\n\n测试套件：\n用 $(A, X)$ 表示每个分子，其中 $A$ 是邻接矩阵，$X$ 是节点特征矩阵，其列按上述顺序排列。\n\n- 情况 $1$（典型的类药分子，所有约束都远在限制范围内）：\n  $$A_1 = \\begin{bmatrix}\n  0  1  0  0  0 \\\\\n  1  0  1  0  0 \\\\\n  0  1  0  1  0 \\\\\n  0  0  1  0  1 \\\\\n  0  0  0  1  0\n  \\end{bmatrix}, \\quad\n  X_1 = \\begin{bmatrix}\n  60  0.4  0  1 \\\\\n  80  0.6  0  2 \\\\\n  100  0.8  1  1 \\\\\n  55  0.5  0  1 \\\\\n  55  0.5  0  1\n  \\end{bmatrix}.$$\n\n- 情况 $2$（边界情况：所有性质恰好在阈值上）：\n  $$A_2 = \\begin{bmatrix}\n  0  1  0  0  0  0  0  0  0  1 \\\\\n  1  0  1  0  0  0  0  0  0  0 \\\\\n  0  1  0  1  0  0  0  0  0  0 \\\\\n  0  0  1  0  1  0  0  0  0  0 \\\\\n  0  0  0  1  0  1  0  0  0  0 \\\\\n  0  0  0  0  1  0  1  0  0  0 \\\\\n  0  0  0  0  0  1  0  1  0  0 \\\\\n  0  0  0  0  0  0  1  0  1  0 \\\\\n  0  0  0  0  0  0  0  1  0  1 \\\\\n  1  0  0  0  0  0  0  0  1  0\n  \\end{bmatrix}, \\quad\n  X_2 = \\begin{bmatrix}\n  50  0.5  1  1 \\\\\n  50  0.5  1  1 \\\\\n  50  0.5  1  1 \\\\\n  50  0.5  1  1 \\\\\n  50  0.5  1  1 \\\\\n  50  0.5  0  1 \\\\\n  50  0.5  0  1 \\\\\n  50  0.5  0  1 \\\\\n  50  0.5  0  1 \\\\\n  50  0.5  0  1\n  \\end{bmatrix}.$$\n\n- 情况 $3$（中度违反两个规则：分子量和 $\\log P$）：\n  $$A_3 = \\begin{bmatrix}\n  0  1  0  0  0  0 \\\\\n  1  0  1  0  1  0 \\\\\n  0  1  0  1  0  0 \\\\\n  0  0  1  0  1  0 \\\\\n  0  1  0  1  0  1 \\\\\n  0  0  0  0  1  0\n  \\end{bmatrix}, \\quad\n  X_3 = \\begin{bmatrix}\n  100  0.9  0  1 \\\\\n  120  1.2  0  2 \\\\\n  130  1.4  1  2 \\\\\n  90  1.0  0  2 \\\\\n  80  0.8  1  1 \\\\\n  100  1.1  0  1\n  \\end{bmatrix}.$$\n\n- 情况 $4$（非常小的水样分子，轻易地满足规则）：\n  $$A_4 = \\begin{bmatrix} 0 \\end{bmatrix}, \\quad\n  X_4 = \\begin{bmatrix} 18  -0.4  2  1 \\end{bmatrix}.$$\n\n您的程序应实现指定的基于 GNN 的计算，评估每个 $(A, X)$ 的软类药性分数 $s$，并生成单行输出，其中包含一个用方括号括起来的逗号分隔的分数列表，顺序为 $[ \\text{情况 }1, \\text{情况 }2, \\text{情况 }3, \\text{情况 }4 ]$，每个分数都四舍五入到三位小数（无单位），例如 $[0.123,0.456,0.789,1.000]$。",
            "solution": "对问题陈述进行验证。\n\n**步骤1：提取给定条件**\n- **分子模型**：一个无向图，其邻接矩阵为 $A \\in \\{0,1\\}^{n \\times n}$，节点特征为 $X \\in \\mathbb{R}^{n \\times d}$。\n- **节点特征**：对于每个节点（原子），特征向量有 $d=4$ 个分量：（1）对分子量的单原子贡献（$\\mathrm{g/mol}$），（2）对 $\\log P$ 的单原子贡献（无单位），（3）单原子氢键供体（HBD）指示符（$0$ 或 $1$），以及（4）单原子氢键受体（HBA）指示符（$0$ 或 $1$）。\n- **全局性质**：四个全局分子性质（$\\mathrm{MW}$、$\\log P$、$\\mathrm{HBD}$、$\\mathrm{HBA}$）是相应特征分量在所有节点上的总和。\n- **Lipinski五规则阈值**：$\\mathrm{MW} \\leq 500$，$\\log P \\leq 5$，$\\mathrm{HBD} \\leq 5$，$\\mathrm{HBA} \\leq 10$。\n- **GNN架构**：一个单层消息传递GNN，具有置换不变性，使用求和池化，并允许通过线性读出精确恢复可加的全局性质。\n- **软分数定义**：\n    - 修正线性单元：$\\phi(z) = \\max(0,z)$。\n    - 归一化违规量：\n        - $v_{\\mathrm{MW}} = \\phi\\left(\\frac{\\mathrm{MW} - 500}{500}\\right)$\n        - $v_{\\log P} = \\phi\\left(\\frac{\\log P - 5}{5}\\right)$\n        - $v_{\\mathrm{HBD}} = \\phi\\left(\\frac{\\mathrm{HBD} - 5}{5}\\right)$\n        - $v_{\\mathrm{HBA}} = \\phi\\left(\\frac{\\mathrm{HBA} - 10}{10}\\right)$\n    - 最终分数：$s = \\mathrm{clip}\\left(1 - \\frac{v_{\\mathrm{MW}} + v_{\\log P} + v_{\\mathrm{HBD}} + v_{\\mathrm{HBA}}}{4}, \\, 0, \\, 1\\right)$。\n- **测试套件**：四个测试用例，由它们的邻接矩阵 $A_k$ 和节点特征矩阵 $X_k$ 指定（$k \\in \\{1, 2, 3, 4\\}$）。\n- **输出格式**：单行输出，包含一个用方括号括起来的、由逗号分隔的四个案例的分数列表，每个分数四舍五入到三位小数。\n\n**步骤2：使用提取的给定条件进行验证**\n该问题具有科学依据，是适定且客观的。它基于图神经网络的标准原理和化学信息学中的既定启发式规则（Lipinski规则）。所有定义、数据和约束都已提供，使得问题是自洽且没有矛盾的。其设定是形式化且明确的。\n\n**步骤3：结论与行动**\n该问题被判定为**有效**。将提供解决方案。\n\n**原则性解决方案**\n\n任务是设计一个基于 GNN 的程序来计算类药性分数。让我们按照问题中概述的步骤逐一进行。\n\n**1. 分子性质计算**\n一个分子由一个有 $n$ 个节点和节点特征 $X \\in \\mathbb{R}^{n \\times 4}$ 的图表示。$X$ 的第 $i$ 行，记为 $X_i$，是第 $i$ 个原子的特征向量：$X_i = [x_{i, \\mathrm{MW}}, x_{i, \\log P}, x_{i, \\mathrm{HBD}}, x_{i, \\mathrm{HBA}}]$。问题陈述指出，全局分子性质是可加的。这意味着它们是通过将各个特征在所有原子上求和来计算的：\n$$ \\mathrm{MW} = \\sum_{i=1}^{n} x_{i, \\mathrm{MW}}, \\quad \\log P = \\sum_{i=1}^{n} x_{i, \\log P}, \\quad \\mathrm{HBD} = \\sum_{i=1}^{n} x_{i, \\mathrm{HBD}}, \\quad \\mathrm{HBA} = \\sum_{i=1}^{n} x_{i, \\mathrm{HBA}} $$\n令 $\\mathbf{p} \\in \\mathbb{R}^4$ 为这四个性质的向量。该向量可以通过对输入特征矩阵 $X$ 的各列求和直接计算得出：\n$$ \\mathbf{p} = \\left[ \\sum_{i=1}^{n} X_{i,1}, \\sum_{i=1}^{n} X_{i,2}, \\sum_{i=1}^{n} X_{i,3}, \\sum_{i=1}^{n} X_{i,4} \\right]^T = \\sum_{i=1}^n X_i^T = X^T \\mathbf{1} $$\n其中 $\\mathbf{1}$ 是一个包含 $n$ 个1的列向量。\n\n**2. GNN 设计**\n我们必须设计一个单层消息传递 GNN，它能生成一个图级嵌入 $h_G$，并且性质向量 $\\mathbf{p}$ 可以通过一个线性读出从 $h_G$ 中被精确恢复。令 $H^{(0)} = X$ 为初始节点特征。一个单层的、线性的消息传递层如下更新节点 $i$ 的特征：\n$$ H_i^{(1)} = W_{self} H_i^{(0)} + W_{neigh} \\sum_{j \\in \\mathcal{N}(i)} H_j^{(0)} $$\n其中 $H_i^{(l)}$ 是节点 $i$ 在第 $l$ 层的特征向量，$W_{self}, W_{neigh} \\in \\mathbb{R}^{d \\times d}$ 是可学习的权重矩阵。求和是在节点 $i$ 的邻居 $\\mathcal{N}(i)$ 上进行的。\n\n图级嵌入 $h_G$ 是通过对最终的节点嵌入进行求和池化得到的：\n$$ h_G = \\sum_{i=1}^n H_i^{(1)} $$\n代入更新规则：\n$$ h_G = \\sum_{i=1}^n \\left( W_{self} H_i^{(0)} + W_{neigh} \\sum_{j \\in \\mathcal{N}(i)} H_j^{(0)} \\right) = W_{self} \\left(\\sum_{i=1}^n H_i^{(0)}\\right) + W_{neigh} \\left(\\sum_{i=1}^n \\sum_{j \\in \\mathcal{N}(i)} H_j^{(0)}\\right) $$\n第一项是 $W_{self} \\sum_i X_i$。第二项取决于图的连接结构（邻接矩阵 $A$）。令 $d_j = |\\mathcal{N}(j)|$ 为节点 $j$ 的度。第二项可以重写为 $\\sum_{j=1}^n d_j H_j^{(0)}$。因此：\n$$ h_G = W_{self} \\sum_{i=1}^n X_i + W_{neigh} \\sum_{j=1}^n d_j X_j $$\n问题要求性质向量 $\\mathbf{p} = \\sum_i X_i$ 能够通过一个线性读出 $W_{readout} \\in \\mathbb{R}^{4 \\times d}$ 从 $h_G$ 中为任何图恢复。即，$W_{readout} h_G = \\sum_i X_i$。\n$$ W_{readout} \\left( W_{self} \\sum_{i=1}^n X_i + W_{neigh} \\sum_{j=1}^n d_j X_j \\right) = \\sum_{i=1}^n X_i $$\n为了使此等式对任意图（具有变化的度 $d_j$）和任意特征矩阵 $X$ 都成立，涉及度的项必须消失。这仅在 $W_{neigh} = 0$ 时才可能。这意味着来自邻近节点的信息（即消息传递）必须被置为零，以保证纯粹相加性质的精确恢复。对于此特定任务，邻接矩阵 $A$ 变得无关紧要。\n\n当 $W_{neigh} = 0$ 时，方程简化为 $W_{readout} W_{self} \\sum_i X_i = \\sum_i X_i$。这要求 $W_{readout} W_{self} = I$，其中 $I$ 是单位矩阵。满足此条件的最简单选择是令 $W_{self}$ 和 $W_{readout}$ 均为 $4 \\times 4$ 的单位矩阵 $I_4$。\n\n因此，“GNN”过程简化为：\n1.  节点更新：$H^{(1)}_i = I_4 H^{(0)}_i = X_i$。（特征保持不变）。\n2.  求和池化：$h_G = \\sum_i H^{(1)}_i = \\sum_i X_i$。\n3.  线性读出：$\\mathbf{p} = I_4 h_G = h_G$。\n\n得到的图级嵌入 $h_G$ 恰好是全局性质向量 $\\mathbf{p}$。此公式满足所有约束：它是一个单层 GNN（尽管是一个平凡的 GNN），由于求和池化而具有置换不变性，并且允许精确恢复可加性质。\n\n**3. 软满足分数计算**\n给定性质向量 $\\mathbf{p} = [\\mathrm{MW}, \\log P, \\mathrm{HBD}, \\mathrm{HBA}]^T$，我们计算类药性分数 $s$。阈值为 $\\mathbf{t} = [500, 5, 5, 10]^T$。\n归一化的违规量是：\n$v_{\\mathrm{MW}} = \\max\\left(0, \\frac{\\mathrm{MW} - 500}{500}\\right)$\n$v_{\\log P} = \\max\\left(0, \\frac{\\log P - 5}{5}\\right)$\n$v_{\\mathrm{HBD}} = \\max\\left(0, \\frac{\\mathrm{HBD} - 5}{5}\\right)$\n$v_{\\mathrm{HBA}} = \\max\\left(0, \\frac{\\mathrm{HBA} - 10}{10}\\right)$\n最终分数由下式给出：\n$s = \\max\\left(0, \\min\\left(1, 1 - \\frac{v_{\\mathrm{MW}} + v_{\\log P} + v_{\\mathrm{HBD}} + v_{\\mathrm{HBA}}}{4}\\right)\\right)$\n\n**4. 在测试套件上进行评估**\n\n我们现在将此过程应用于提供的测试用例。\n\n- **情况 1**：\n  $X_1$ 有 $5$ 行。$\\mathbf{p}_1 = \\sum_i X_{1,i}^T = [350, 2.8, 1, 6]^T$。\n  所有性质都在其阈值之内。\n  $v_{\\mathrm{MW}}=v_{\\log P}=v_{\\mathrm{HBD}}=v_{\\mathrm{HBA}} = 0$。\n  $s_1 = \\mathrm{clip}(1 - 0/4, 0, 1) = 1.0$。\n\n- **情况 2**：\n  $X_2$ 有 $10$ 行。$\\mathbf{p}_2 = \\sum_i X_{2,i}^T = [500, 5.0, 5, 10]^T$。\n  所有性质都恰好在其阈值上。\n  $v_{\\mathrm{MW}} = \\max(0, \\frac{500-500}{500})=0$。\n  $v_{\\log P} = \\max(0, \\frac{5-5}{5})=0$。\n  $v_{\\mathrm{HBD}} = \\max(0, \\frac{5-5}{5})=0$。\n  $v_{\\mathrm{HBA}} = \\max(0, \\frac{10-10}{10})=0$。\n  $s_2 = \\mathrm{clip}(1 - 0/4, 0, 1) = 1.0$。\n\n- **情况 3**：\n  $X_3$ 有 $6$ 行。$\\mathbf{p}_3 = \\sum_i X_{3,i}^T = [620, 6.4, 2, 9]^T$。\n  $\\mathrm{MW}$ 和 $\\log P$ 违反了它们的规则。\n  $v_{\\mathrm{MW}} = \\max(0, \\frac{620-500}{500}) = 0.24$。\n  $v_{\\log P} = \\max(0, \\frac{6.4-5}{5}) = 0.28$。\n  $v_{\\mathrm{HBD}} = \\max(0, \\frac{2-5}{5}) = 0$。\n  $v_{\\mathrm{HBA}} = \\max(0, \\frac{9-10}{10}) = 0$。\n  总违规量：$0.24 + 0.28 = 0.52$。\n  $s_3 = \\mathrm{clip}(1 - 0.52/4, 0, 1) = \\mathrm{clip}(1 - 0.13, 0, 1) = 0.87$。\n\n- **情况 4**：\n  $X_4$ 有 $1$ 行。$\\mathbf{p}_4 = [18, -0.4, 2, 1]^T$。\n  所有性质都远在其阈值之内。\n  $v_{\\mathrm{MW}}=v_{\\log P}=v_{\\mathrm{HBD}}=v_{\\mathrm{HBA}} = 0$。\n  $s_4 = \\mathrm{clip}(1 - 0/4, 0, 1) = 1.0$。\n\n最终计算出的分数为 $[1.0, 1.0, 0.87, 1.0]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the GNN-based drug-likeness scoring procedure and evaluates it on the test suite.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # The adjacency matrix A is not used in the final calculation, as derived in the solution,\n    # because recovering purely additive properties requires nullifying the message passing term.\n    # It is included here for completeness.\n    test_cases = [\n        # Case 1\n        (np.array([[0, 1, 0, 0, 0], [1, 0, 1, 0, 0], [0, 1, 0, 1, 0], [0, 0, 1, 0, 1], [0, 0, 0, 1, 0]]),\n         np.array([[60, 0.4, 0, 1], [80, 0.6, 0, 2], [100, 0.8, 1, 1], [55, 0.5, 0, 1], [55, 0.5, 0, 1]])),\n        # Case 2\n        (np.array([[0, 1, 0, 0, 0, 0, 0, 0, 0, 1], [1, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 1, 0, 0, 0, 0, 0, 0], \n                   [0, 0, 1, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 1, 0, 0, 0], \n                   [0, 0, 0, 0, 0, 1, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 1], \n                   [1, 0, 0, 0, 0, 0, 0, 0, 1, 0]]),\n         np.array([[50, 0.5, 1, 1], [50, 0.5, 1, 1], [50, 0.5, 1, 1], [50, 0.5, 1, 1], [50, 0.5, 1, 1], \n                   [50, 0.5, 0, 1], [50, 0.5, 0, 1], [50, 0.5, 0, 1], [50, 0.5, 0, 1], [50, 0.5, 0, 1]])),\n        # Case 3\n        (np.array([[0, 1, 0, 0, 0, 0], [1, 0, 1, 0, 1, 0], [0, 1, 0, 1, 0, 0], [0, 0, 1, 0, 1, 0], \n                   [0, 1, 0, 1, 0, 1], [0, 0, 0, 0, 1, 0]]),\n         np.array([[100, 0.9, 0, 1], [120, 1.2, 0, 2], [130, 1.4, 1, 2], [90, 1.0, 0, 2], \n                   [80, 0.8, 1, 1], [100, 1.1, 0, 1]])),\n        # Case 4\n        (np.array([[0]]),\n         np.array([[18, -0.4, 2, 1]]))\n    ]\n\n    def calculate_drug_likeness_score(X: np.ndarray) -> float:\n        \"\"\"\n        Calculates the drug-likeness score based on Lipinski's rule of five.\n\n        Args:\n            X: Node feature matrix of shape (n_atoms, 4), where columns are\n               per-atom contributions to MW, logP, HBD, and HBA.\n\n        Returns:\n            The soft satisfaction score s, a float between 0 and 1.\n        \"\"\"\n        # The GNN-based procedure simplifies to summing the node features to get the graph-level properties.\n        # This corresponds to sum pooling of the initial node features.\n        properties = np.sum(X, axis=0)\n        mw, logp, hbd, hba = properties[0], properties[1], properties[2], properties[3]\n\n        # Lipinski's rule thresholds\n        thresholds = {'mw': 500, 'logp': 5, 'hbd': 5, 'hba': 10}\n\n        # Calculate normalized violations using a rectified linear unit (phi(z) = max(0, z))\n        v_mw = max(0, (mw - thresholds['mw']) / thresholds['mw'])\n        v_logp = max(0, (logp - thresholds['logp']) / thresholds['logp'])\n        v_hbd = max(0, (hbd - thresholds['hbd']) / thresholds['hbd'])\n        v_hba = max(0, (hba - thresholds['hba']) / thresholds['hba'])\n\n        # Calculate the total penalty\n        total_violation = v_mw + v_logp + v_hbd + v_hba\n        \n        # Calculate the final score, clipped to the [0, 1] range\n        score = 1.0 - (total_violation / 4.0)\n        final_score = np.clip(score, 0, 1)\n        \n        return final_score\n\n    results = []\n    for _, X_case in test_cases:\n        score = calculate_drug_likeness_score(X_case)\n        results.append(score)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.3f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "实际的分子数据往往比理想化的单个连通图更为复杂，例如离子盐就包含多个不相连的组分。标准的消息传递图神经网络无法在这些组分之间传递信息。这个思想练习将促使你评估并比较不同的架构策略，以为整个系统创建一个统一的表示，这是任何 GNN 从业者都必须掌握的关键设计技能。",
            "id": "2395424",
            "problem": "你正在构建一个图神经网络（GNN）来预测一种离子盐的标量性质 $y(G)$。该离子盐表示为一个分子图 $G=(V,E)$，其共价键拓扑结构产生了多个不连通分量。考虑一个典型案例，如 $\\text{Na}^+\\text{Cl}^-$，其中 $G$ 分解为 $k\\ge 2$ 个连通分量 $G_i=(V_i,E_i)$，满足 $\\bigsqcup_{i=1}^k V_i=V$ 和 $\\bigsqcup_{i=1}^k E_i=E$。节点特征 $x_v$ 包括原子类型和形式电荷；边特征 $e_{uv}$ 为 $(u,v)\\in E$ 编码了键的类型。数据集中没有可靠的三维坐标或离子间距离，性质 $y(G)$ 是为化学式单位（例如，一个阳离子和一个阴离子）定义的。一个 $T$ 层的消息传递GNN通过函数 $\\psi$ 和 $\\phi$ 以及一个置换不变的多重集聚合器 $\\square$ 来更新节点状态：\n$$\nh_v^{(0)}=x_v,\\quad\nm_v^{(t)}=\\square_{u\\in \\mathcal{N}(v)} \\psi\\!\\left(h_v^{(t)},h_u^{(t)},e_{uv}\\right),\\quad\nh_v^{(t+1)}=\\phi\\!\\left(h_v^{(t)},m_v^{(t)}\\right),\\quad t=0,\\dots,T-1.\n$$\n图级别的预测器必须产生一个 $\\hat y(G)$，该预测值对每个分量内部的原子排序不变，对各分量 $\\{G_i\\}_{i=1}^k$ 的置换不变，并且必须能处理可变的 $k$。\n\n在当前设定下，以下哪种策略是处理不连通分量的有原则的方法，以获得一个用于性质预测的、良定义的、置换不变的图级别表示？\n\nA. 执行分层池化：首先用一个置换不变的读出函数 $\\rho$ 计算一个组分级别的嵌入 $r_i=\\rho\\!\\left(\\{h_v^{(T)}: v\\in V_i\\}\\right)$，然后用一个置换不变的集合函数 $\\Gamma$（例如，对于广延性目标使用求和，对于强度性目标使用均值）计算一个分子级别的嵌入 $z=\\Gamma\\!\\left(\\{r_i\\}_{i=1}^k\\right)$，并预测 $\\hat y=f(z)$。\n\nB. 引入一个单一的可学习的全局虚拟节点 $g$，通过特殊类型的边连接到每个原子；扩展消息传递以包括 $g$，使得 $h_g^{(T)}$ 聚合所有分量的信息，并使用 $h_g^{(T)}$（可选择性地与池化后的节点特征结合）作为图表示来预测 $\\hat y$。\n\nC. 在阳离子中随机选择一个原子，在阴离子中随机选择一个原子，在这两个原子之间人为添加一条无向边，并将该边与共价键同等对待，从而使 $G$ 变为连通图，然后应用标准的图级别读出。\n\nD. 丢弃除最大分量外的所有分量，仅对该分量应用GNN和读出函数，并将其结果用作分子级别的表示。\n\nE. 将离子盐转换为一个序列，方法是用点分隔符连接各离子的简化分子线性输入规范（SMILES）字符串，将此序列输入循环神经网络（RNN），并使用最后一个隐藏状态来预测 $\\hat y$，从而绕开图不连通的问题。",
            "solution": "问题陈述需要经过验证。\n\n**第一步：提取已知条件**\n- **模型类型**：用于预测分子图 $G$ 的标量性质 $y(G)$ 的图神经网络（GNN）。\n- **输入图**：$G=(V,E)$ 表示一种离子盐。\n- **图结构**：$G$ 由 $k\\ge 2$ 个不连通分量 $G_i=(V_i,E_i)$ 组成，满足 $V=\\bigsqcup_{i=1}^k V_i$ 且 $E=\\bigsqcup_{i=1}^k E_i$。一个例子是 $\\text{Na}^+\\text{Cl}^-$。\n- **特征**：提供了节点特征 $x_v$（原子类型、形式电荷）和边特征 $e_{uv}$（键类型）。共价键构成分量内部的边。\n- **缺失信息**：三维坐标和离子间距离不可用。\n- **目标性质**：$y(G)$ 是为化学式单位（例如，一个阳离子和一个阴离子）定义的。\n- **GNN架构**：使用一个 $T$ 层的消息传递GNN，其更新规则如下（对于 $t=0, \\dots, T-1$）：\n  - 节点初始化：$h_v^{(0)}=x_v$。\n  - 消息聚合：$m_v^{(t)}=\\square_{u\\in \\mathcal{N}(v)} \\psi(h_v^{(t)},h_u^{(t)},e_{uv})$，其中 $\\square$ 是一个置换不变的多重集聚合器。\n  - 节点更新：$h_v^{(t+1)}=\\phi(h_v^{(t)},m_v^{(t)})$。\n- **输出要求**：图级别预测器 $\\hat y(G)$ 必须满足：\n  1. 对每个分量 $G_i$ 内的原子排序不变。\n  2. 对分量本身 $\\{G_i\\}_{i=1}^k$ 的置换不变。\n  3. 能够处理可变数量的分量 $k$。\n\n**第二步：使用提取的已知条件进行验证**\n- **科学依据**：该问题在计算生物学和化学信息学领域有坚实的依据。使用GNN预测分子性质是一个标准且非常活跃的研究领域。在缺乏3D结构信息时，将离子盐表示为其共价拓扑结构的不连通图是一种常见且有效的方法。所述的消息传递框架是一种通用且广泛使用的公式（例如，图同构网络或GIN是其一个特例）。对置换不变性的要求是创建有效化学系统模型的基础。该问题在科学上是合理的。\n- **良定性**：该问题是良定的。它清晰地定义了输入（一个具有特定特征的不连通图）、模型类别（一个消息传递GNN）以及对输出的约束（不变性）。问题要求找到满足这些约束的有原则的策略，这是一个明确定义的目标。虽然可能存在多种有效策略，不期望有唯一答案，但这组有效策略是明确界定的。\n- **客观性**：问题陈述使用机器学习和计算化学文献中常见的精确技术语言表达。它没有歧义、主观性或个人观点。\n\n**第三步：结论与行动**\n问题陈述是有效的。它在科学上合理、良定、客观且自洽。因此，将推导出一个解决方案。\n\n**推导与选项分析**\n\n核心困难源于图 $G$ 的不连通性。在所述的消息传递方案中，信息无法在不连通分量之间流动。对于任意两个节点 $u \\in V_i$ 和 $v \\in V_j$，$i \\neq j$，它们之间没有路径。因此，经过 $T$ 层消息传递后，节点 $v \\in V_i$ 的最终嵌入 $h_v^{(T)}$ 仅是其自身分量 $G_i$ 内的节点和边的初始特征的函数。因此，模型必须采用一种特定策略，从这些独立的分量中聚合信息，以形成一个单一、连贯的、代表整个离子盐的表示，同时遵守所要求的不变性。\n\n**选项A：执行分层池化...**\n该策略提出了一个两步聚合过程。\n1.  **组分级别池化**：对于每个分量 $G_i$，通过对其最终节点嵌入集合 $\\{h_v^{(T)}: v\\in V_i\\}$ 应用一个置换不变的读出函数 $\\rho$，来计算一个表示 $r_i$。GNN本身确保了节点嵌入的集合对分量内节点索引的置换是不变的。应用一个置换不变的函数，如求和、均值或最大池化（即 $\\rho$），可以确保 $r_i$ 是分量 $G_i$ 的一个规范表示。\n2.  **分子级别池化**：然后使用另一个置换不变的集合函数 $\\Gamma$ 来聚合这组分量表示 $\\{r_i\\}_{i=1}^k$，以产生最终的图级别嵌入 $z = \\Gamma(\\{r_i\\}_{i=1}^k)$。这明确地解决了对分量置换不变性的要求。像求和或均值聚合这样的函数也能自然地处理可变数量的分量 $k$。$\\Gamma$ 的选择（例如，对于广延性质使用求和，对于强度性质使用均值）为模型增添了另一层物理原理。\n\n这是一个逻辑上合理、有原则且广泛用于处理输入集合的方法，而不连通图正是一个连通分量的集合。\n**结论：正确**\n\n**选项B：引入一个单一的可学习的全局虚拟节点...**\n该策略涉及增强图结构。在图中添加一个名为 $g$ 的新“虚拟”节点，并将其连接到所有现有节点 $v \\in V$。可以为这些新边分配一种特殊类型，以便消息函数 $\\psi$ 能够区分它们。\n在这个修改后的连通图中，消息传递的运作方式不同：\n- 在第一层，虚拟节点 $g$ 聚合来自所有分量中所有节点的消息。其状态 $h_g^{(1)}$ 成为整个图的摘要。\n- 同时，所有节点 $v \\in V$ 都从 $g$ 接收一条消息。\n- 在第二层，一个节点 $v \\in V_i$ 可以通过路径 $u \\to g \\to v$ 从另一个节点 $u \\in V_j$（$i \\neq j$）接收消息。现在，信息通过全局节点在所有分量之间交换。\n经过 $T$ 层后，虚拟节点的最终嵌入 $h_g^{(T)}$ 已从整个分子系统中迭代地聚合了信息。由于用于更新 $h_g^{(t)}$ 的聚合函数 $\\square$ 是置换不变的，$h_g^{(T)}$ 内在地对节点的置换不变，因此也对分量的置换不变。因此，使用 $h_g^{(T)}$ 作为图级别表示是产生整个系统的置换不变嵌入的一种有效且强大的技术。这是一种标准的架构模式，称为“主节点”或“全局读出”。\n**结论：正确**\n\n**选项C：在阳离子和阴离子中随机选择原子，人为添加一条无向边...**\n该策略旨在通过添加一条边来使图连通。虽然这允许信息在整个结构中流动，但选择这条边端点的方法被指定为*随机*。\nGNN通常对图的拓扑结构不是不变的。通过在不同节点对之间添加边来改变连通性，通常会导致不同的最终节点嵌入和不同的图级别预测。对于给定的输入图 $G$，预测 $\\hat y(G)$ 必须是确定性的。在模型的前向传播中引入随机选择会使固定输入的预测变为随机的，这是不可接受的。有人可能会建议对所有可能的连接进行平均，但这不是该选项所提议的，并且计算成本高昂。这种方法是一种随意的启发式方法，而不是有原则的方法。它引入了一个依赖于随机种子而非系统化学性质的人为结构特征。\n**结论：不正确**\n\n**选项D：丢弃除最大分量外的所有分量...**\n该策略提议通过丢弃数据来简化问题。问题陈述指出，性质 $y(G)$ 是为化学式单位（例如，一个阳离子和一个阴离子）定义的。对于 $\\text{Na}^+\\text{Cl}^-$，其组分是大小相等的单个原子，因此“最大”没有唯一定义。对于像硫酸镁 $(\\text{Mg}^{2+})(\\text{SO}_4^{2-})$ 这样更复杂的盐，硫酸根离子（5个原子）是最大的分量。这个策略会丢弃镁阳离子（$\\text{Mg}^{2+}$）。硫酸镁的性质关键地依赖于镁阳离子和硫酸根阴离子两者。忽略其中之一使得从物理和化学上都无法预测该盐的性质。该方法从根本上说是不合理的，因为它丢弃了解决问题所需的基本信息。\n**结论：不正确**\n\n**选项E：将离子盐转换为一个序列...并使用循环神经网络（RNN）...**\n问题明确要求在GNN模型的背景下提出一种策略。该选项提议完全放弃图表示和GNN架构。它用基于字符串的表示（SMILES）和序列模型（RNN）取而代之。虽然将SMILES与RNN或Transformer一起使用是分子性质预测的一种有效的替代建模范式，但它不是在*指定的GNN框架内处理不连通分量*的策略。它完全偏离了问题设定。问题是如何让给定的GNN架构工作，而不是如何替换它。因此，这个选项没有回答所提出的问题。\n**结论：不正确**",
            "answer": "$$\\boxed{AB}$$"
        }
    ]
}