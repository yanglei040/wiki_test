{
    "hands_on_practices": [
        {
            "introduction": "许多药物基因组学的核心任务是将复杂的遗传变异转化为可量化的功能指标。`CYP2D6` 基因是药物代谢领域的一个典型例子，其复杂的结构变异（如拷贝数变异和杂合等位基因）直接影响个体代谢可待因等药物的能力。在本练习中，您将根据既定规则，构建一个模型，将 `CYP2D6` 的基因型字符串解析为总活性分数，并结合米氏动力学方程计算药物代谢速率，从而亲身体验从基因型到表型的完整推导过程。",
            "id": "2413841",
            "problem": "实现一个确定性的、单位感知的模型，该模型将具有结构变异的细胞色素P450 2D6亚家族成员6 (Cytochrome P450 Family 2 Subfamily D Member 6, CYP2D6) 基因型映射到固定血浆浓度下预测的可待因O-去甲基化速率。基因型由两个单倍型指定。每个单倍型是一个遵循以下语法的字符串，由一个星号等位基因标记和可选的结构修饰符组成：一个简单的星号等位基因形式为“*k”，其中“k”是集合 {“*1”, “*2”, “*4”, “*5”, “*10”, “*17”, “*36”, “*41”} 中的一个标准星号等位基因标识符；一个整数拷贝数由后缀“xN”表示，应用于整个单倍型，并表示同一条染色体上有 $N$ 个串联拷贝；一个串联杂合单倍型表示为“A+B”，它在单个染色体片段上组合了两个星号等位基因标记 $A$ 和 $B$；拷贝数也可以应用于串联杂合体，形式为“(A+B)xN”或“A+BxN”。一个简单星号等位基因 $a$ 的每个拷贝的内在活性由映射 $\\alpha(a)$ 给出，其值为 $\\alpha(\\text{“*1”})=1.0$, $\\alpha(\\text{“*2”})=1.0$, $\\alpha(\\text{“*4”})=0.0$, $\\alpha(\\text{“*5”})=0.0$, $\\alpha(\\text{“*10”})=0.25$, $\\alpha(\\text{“*17”})=0.5$, $\\alpha(\\text{“*36”})=0.0$, 以及 $\\alpha(\\text{“*41”})=0.5$。对于一个串联杂合体“A+B”，其有效的每个拷贝的活性定义为\n$$\n\\alpha_{\\mathrm{tandem}}(A,B) \\equiv p_t \\cdot \\frac{\\alpha(A) + \\alpha(B)}{2},\n$$\n其中串联惩罚因子固定为 $p_t=0.8$。对于一个拷贝数为 $c \\in \\mathbb{Z}_{\\ge 1}$ 的单倍型，其单倍型活性贡献对于简单等位基因 $a$ 是 $c \\cdot \\alpha(a)$，对于串联杂合体 $A+B$ 是 $c \\cdot \\alpha_{\\mathrm{tandem}}(A,B)$。总活性分数是两个单倍型贡献之和：\n$$\nS \\equiv S(H_1,H_2) = \\mathrm{contrib}(H_1) + \\mathrm{contrib}(H_2).\n$$\n从活性分数到可待因O-去甲基化速率的药代动力学映射遵循米氏 (Michaelis–Menten, MM) 动力学。设野生型 (Wild Type, WT) 表示活性分数为 $S_{\\mathrm{WT}}=2.0$ 的参考二倍体型。将最大速度 $V_{\\max}(S)$ 定义为\n$$\nV_{\\max}(S) \\equiv V_{\\max}^{\\mathrm{WT}} \\cdot \\frac{S}{S_{\\mathrm{WT}}},\n$$\n其中 $V_{\\max}^{\\mathrm{WT}}=1.0$ 单位为 $\\mathrm{mg}\\,\\mathrm{L}^{-1}\\,\\mathrm{h}^{-1}$。设米氏常数 (Michaelis constant) 为 $K_m=0.2$，单位为 $\\mathrm{mg}\\,\\mathrm{L}^{-1}$，并设可待因血浆浓度为 $C$，单位为 $\\mathrm{mg}\\,\\mathrm{L}^{-1}$。吗啡生成速率为\n$$\nv(S,C) \\equiv V_{\\max}(S) \\cdot \\frac{C}{K_m + C},\n$$\n报告单位为 $\\mathrm{mg}\\,\\mathrm{L}^{-1}\\,\\mathrm{h}^{-1}$。如果 $S=0$ 或 $C=0$，那么根据上述定义 $v=0$。\n\n你的任务是编写一个程序，对于下方的每个测试用例，解析两个单倍型字符串，根据指定规则计算 $S$，然后计算 $v(S,C)$。将所有测试用例的最终结果表示为单行，该行包含一个用方括号括起来的、以逗号分隔的列表，其中每个条目四舍五入到恰好 $6$ 位小数，单位为 $\\mathrm{mg}\\,\\mathrm{L}^{-1}\\,\\mathrm{h}^{-1}$（不要打印单位）。\n\n测试套件（每个测试用例都是 (单倍型$_1$, 单倍型$_2$, $C$) 形式的三元组）：\n$1.$ (“*1”, “*1”, $0.5$)\n$2.$ (“*4”, “*5$, $0.5$)\n$3.$ (“*1x3”, “*1”, $2.0$)\n$4.$ (“*36+*10”, “*1”, $0.5$)\n$5.$ (“*1x2”, “*10”, $0.5$)\n$6.$ (“*17”, “*4”, $10.0$)\n$7.$ (“*1”, “*1x2”, $0.0$)\n\n你的程序应该产生单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，“[r1,r2,r3,r4,r5,r6,r7]”），其中每个 $r_i$ 是一个如上所述四舍五入到 $6$ 位小数的浮点数。",
            "solution": "该问题要求实现一个确定性模型，以预测可待因O-去甲基化为吗啡的速率，这是一个由CYP2D6酶催化的代谢过程。该模型基于一个由两个单倍型定义的特定药物基因组学基因型以及固定的可待因血浆浓度。解决方案遵循一个分两部分的、基于规则的方法：首先，将基因型映射到一个数值活性分数；其次，使用经典酶动力学将此分数和底物浓度映射到一代谢速率。\n\n第一步是从给定的两个单倍型字符串 $H_1$ 和 $H_2$ 计算总活性分数 $S$。总分数是每个单倍型各自贡献的总和：\n$$\nS = \\mathrm{contrib}(H_1) + \\mathrm{contrib}(H_2)\n$$\n单个单倍型贡献 $\\mathrm{contrib}(H)$ 的计算取决于其结构，该结构从其字符串表示中解析而来。一个单倍型字符串指定了一个基本等位基因构型和一个可选的拷贝数。\n\n首先，确定由整数 $c$ 表示的拷贝数。如果字符串包含后缀“xN”，则拷贝数 $c$ 为 $N$。如果没有此后缀，则拷贝数取为 $c=1$。字符串的其余部分指定了基本等位基因构型。\n\n基本等位基因构型有两种类型：\n1.  **简单等位基因：** 基本构型是单个星号等位基因，例如“*1”或“*10”。其贡献计算为 $c \\cdot \\alpha(a)$，其中 $a$ 是星号等位基因标识符，$\\alpha(a)$ 是其每个拷贝的内在活性。问题提供了以下活性映射：\n    -   $\\alpha(\\text{“*1”}) = 1.0$\n    -   $\\alpha(\\text{“*2”}) = 1.0$\n    -   $\\alpha(\\text{“*4”}) = 0.0$\n    -   $\\alpha(\\text{“*5”}) = 0.0$\n    -   $\\alpha(\\text{“*10”}) = 0.25$\n    -   $\\alpha(\\text{“*17”}) = 0.5$\n    -   $\\alpha(\\text{“*36”}) = 0.0$\n    -   $\\alpha(\\text{“*41”}) = 0.5$\n\n2.  **串联杂合等位基因：** 基本构型是两个星号等位基因的杂合体，表示为“A+B”。其每个拷贝的活性由一个包含惩罚项的特定公式定义：\n    $$\n    \\alpha_{\\mathrm{tandem}}(A,B) = p_t \\cdot \\frac{\\alpha(A) + \\alpha(B)}{2}\n    $$\n    串联惩罚因子给定为 $p_t=0.8$。那么此单倍型的总贡献为 $c \\cdot \\alpha_{\\mathrm{tandem}}(A,B)$。\n\n第二步是基于酶动力学的米氏 (Michaelis-Menten) 模型，使用计算出的总活性分数 $S$ 来确定吗啡生成速率 $v$。最大反应速度 $V_{\\max}$ 被假定为与由分数 $S$ 表示的总酶活性成正比。这种关系表示为：\n$$\nV_{\\max}(S) = V_{\\max}^{\\mathrm{WT}} \\cdot \\frac{S}{S_{\\mathrm{WT}}}\n$$\n其中 $S_{\\mathrm{WT}}=2.0$ 是参考野生型 (WT) 二倍体型（例如 *1/*1）的活性分数，并且 $V_{\\max}^{\\mathrm{WT}}=1.0 \\, \\mathrm{mg}\\,\\mathrm{L}^{-1}\\,\\mathrm{h}^{-1}$ 是此参考的最大速度。\n\n反应速率 $v$ 随后由米氏 (Michaelis-Menten) 方程给出，该方程将反应速度与底物浓度 $C$ 联系起来：\n$$\nv(S,C) = V_{\\max}(S) \\cdot \\frac{C}{K_m + C}\n$$\n米氏常数 (Michaelis constant) 给定为 $K_m=0.2 \\, \\mathrm{mg}\\,\\mathrm{L}^{-1}$。定义了一个特殊条件：如果活性分数 $S=0$ 或可待因浓度 $C=0$，则反应速率 $v$ 为 $0$。\n\n实现包含一个用于解析单个单倍型字符串以计算其贡献的函数，以及一个处理每个测试用例的主过程。解析函数首先分离出拷贝数和基本等位基因字符串。然后它检查是否存在杂合结构（“+”），以决定应用哪个活性公式。主过程对给定二倍体型的两个单倍型都调用此解析函数，将它们的贡献相加以求得 $S$，然后使用所提供的浓度 $C$ 和药代动力学方程计算 $v$。每个测试用例的最终结果按要求四舍五入到 $6$ 位小数。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the codeine O-demethylation rate based on CYP2D6 genotype and plasma concentration.\n    \"\"\"\n\n    # --- Model Constants ---\n    ALPHA_MAP = {\n        \"*1\": 1.0, \"*2\": 1.0, \"*4\": 0.0, \"*5\": 0.0,\n        \"*10\": 0.25, \"*17\": 0.5, \"*36\": 0.0, \"*41\": 0.5\n    }\n    TANDEM_PENALTY = 0.8  # p_t\n    S_WT = 2.0\n    VMAX_WT = 1.0  # mg L^-1 h^-1\n    KM = 0.2  # mg L^-1\n\n    def _calculate_haplotype_contribution(hap_str: str) -> float:\n        \"\"\"\n        Parses a haplotype string and computes its activity score contribution.\n        \"\"\"\n        base_hap = hap_str\n        copy_count = 1\n\n        # Check for and extract copy number\n        if 'x' in hap_str:\n            parts = hap_str.split('x')\n            base_hap = parts[0]\n            copy_count = int(parts[1])\n\n        # Remove parentheses if present (e.g., from (A+B)xN)\n        base_hap = base_hap.strip('()')\n\n        # Check for tandem hybrid structure\n        if '+' in base_hap:\n            alleles = base_hap.split('+')\n            allele_a = alleles[0]\n            allele_b = alleles[1]\n            \n            activity_a = ALPHA_MAP.get(allele_a, 0.0)\n            activity_b = ALPHA_MAP.get(allele_b, 0.0)\n            \n            alpha_tandem = TANDEM_PENALTY * (activity_a + activity_b) / 2.0\n            per_copy_activity = alpha_tandem\n        else: # Simple allele\n            per_copy_activity = ALPHA_MAP.get(base_hap, 0.0)\n            \n        return copy_count * per_copy_activity\n\n    test_cases = [\n        (\"*1\", \"*1\", 0.5),\n        (\"*4\", \"*5\", 0.5),\n        (\"*1x3\", \"*1\", 2.0),\n        (\"*36+*10\", \"*1\", 0.5),\n        (\"*1x2\", \"*10\", 0.5),\n        (\"*17\", \"*4\", 10.0),\n        (\"*1\", \"*1x2\", 0.0)\n    ]\n\n    results = []\n    for hap1, hap2, C in test_cases:\n        contrib1 = _calculate_haplotype_contribution(hap1)\n        contrib2 = _calculate_haplotype_contribution(hap2)\n        \n        S = contrib1 + contrib2\n        \n        # Calculate metabolic rate v\n        if S == 0 or C == 0:\n            v = 0.0\n        else:\n            Vmax_S = VMAX_WT * (S / S_WT)\n            v = Vmax_S * (C / (KM + C))\n\n        results.append(f\"{v:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在临床实践中，区分表面上相似但潜在机制完全不同的药物反应是一项挑战，例如，因无效停药与因不良反应停药。本练习提供了一个假设场景，要求您利用朴素贝叶斯分类器来解决这个问题。通过整合基因标记物（如HLA风险等位基因）和临床指标，您将学习如何构建一个概率模型，来预测导致治疗终止的最可能原因，这体现了利用多源数据进行临床决策的基本思路。",
            "id": "2413852",
            "problem": "您将执行一个形式化的药物基因组学基因型-表型分类任务，以区分药物无效响应和药物不良反应（ADR），这两种临床结果都会导致治疗中止。考虑一个二元分类变量 $Y \\in \\{0,1\\}$，其中 $Y=0$ 表示无效响应，$Y=1$ 表示药物不良反应（ADR）。对于每个个体，您会观察到一个由以下部分组成的特征向量 $X=(g_{\\mathrm{HLA}}, g_T, a)$：一个人类白细胞抗原（HLA）风险等位基因指示符 $g_{\\mathrm{HLA}} \\in \\{0,1\\}$，一个转运蛋白功能丧失指示符 $g_T \\in \\{0,1\\}$，以及一个标准化的酶活性分数 $a \\in \\mathbb{R}_{\\ge 0}$。假设存在以下生成模型和概率假设。\n\n1. 类别先验概率：$P(Y=0)=\\tfrac{1}{2}$ 和 $P(Y=1)=\\tfrac{1}{2}$。\n\n2. 在给定类别的情况下，特征条件独立：对于任何 $x=(g_{\\mathrm{HLA}}, g_T, a)$ 和 $y \\in \\{0,1\\}$，\n$$\np(x \\mid y) \\;=\\; p(g_{\\mathrm{HLA}} \\mid y)\\; p(g_T \\mid y)\\; f(a \\mid y).\n$$\n\n3. 对于人类白细胞抗原（HLA）风险等位基因指示符，\n$$\nP(g_{\\mathrm{HLA}}=1 \\mid Y=1) = 0.7,\\quad P(g_{\\mathrm{HLA}}=1 \\mid Y=0) = 0.05,\n$$\n且对于 $y \\in \\{0,1\\}$，$P(g_{\\mathrm{HLA}}=0 \\mid y) = 1 - P(g_{\\mathrm{HLA}}=1 \\mid y)$。\n\n4. 对于转运蛋白功能丧失指示符，\n$$\nP(g_T=1 \\mid Y=0) = 0.6,\\quad P(g_T=1 \\mid Y=1) = 0.2,\n$$\n且对于 $y \\in \\{0,1\\}$，$P(g_T=0 \\mid y) = 1 - P(g_T=1 \\mid y)$。\n\n5. 对于酶活性分数，假设其类别条件概率为高斯密度，参数如下\n$$\na \\mid Y=0 \\sim \\mathcal{N}(\\mu_0, \\sigma_0^2), \\quad \\mu_0 = 0.2,\\ \\sigma_0 = 0.1,\n$$\n$$\na \\mid Y=1 \\sim \\mathcal{N}(\\mu_1, \\sigma_1^2), \\quad \\mu_1 = 1.0,\\ \\sigma_1 = 0.2,\n$$\n其密度函数为\n$$\nf(a \\mid y) \\;=\\; \\frac{1}{\\sigma_y \\sqrt{2\\pi}} \\exp\\!\\left( -\\frac{(a - \\mu_y)^2}{2 \\sigma_y^2} \\right), \\quad y \\in \\{0,1\\}。\n$$\n\n您的任务是构建一个分类器，对于每个观测值 $x=(g_{\\mathrm{HLA}}, g_T, a)$，在上述定义的模型下，选择能够最大化后验概率 $P(Y=y \\mid X=x)$ 的类别 $\\hat{y} \\in \\{0,1\\}$。在概率完全相等的情况下，您必须预测为药物不良反应（ADR）类别，即选择 $\\hat{y}=1$。\n\n测试集。请使用以下五个观测值，每个都以有序三元组 $(g_{\\mathrm{HLA}}, g_T, a)$ 的形式给出：\n1. $(1, 0, 0.9)$\n2. $(0, 1, 0.1)$\n3. $(0, 0, 0.5)$\n4. $(0, 1, 0.0)$\n5. $(1, 1, 0.05)$\n\n最终输出格式。您的程序应生成单行输出，其中包含五个观测值的预测类别，格式为方括号内由逗号分隔的整数列表，顺序与上面列出的一致。例如，要求的格式是 $[c_1,c_2,c_3,c_4,c_5]$，其中每个 $c_i \\in \\{0,1\\}$ 是测试用例 $i$ 的预测类别。不涉及单位，也不需要百分比。输出必须只有一行，不含任何其他字符或文本。",
            "solution": "对问题陈述进行验证。\n\n步骤 1：提取给定信息。\n- 分类变量：$Y \\in \\{0,1\\}$，其中 $Y=0$ 表示无效响应，$Y=1$ 表示药物不良反应（ADR）。\n- 特征向量：$X=(g_{\\mathrm{HLA}}, g_T, a)$，其中 $g_{\\mathrm{HLA}} \\in \\{0,1\\}$，$g_T \\in \\{0,1\\}$，$a \\in \\mathbb{R}_{\\ge 0}$。\n- 类别先验概率：$P(Y=0) = \\tfrac{1}{2}$ 和 $P(Y=1) = \\tfrac{1}{2}$。\n- 条件独立性假设：$p(x \\mid y) = p(g_{\\mathrm{HLA}} \\mid y) p(g_T \\mid y) f(a \\mid y)$。\n- $g_{\\mathrm{HLA}}$ 的条件概率：$P(g_{\\mathrm{HLA}}=1 \\mid Y=1) = 0.7$，$P(g_{\\mathrm{HLA}}=1 \\mid Y=0) = 0.05$。这意味着 $P(g_{\\mathrm{HLA}}=0 \\mid y) = 1 - P(g_{\\mathrm{HLA}}=1 \\mid y)$。\n- $g_T$ 的条件概率：$P(g_T=1 \\mid Y=0) = 0.6$，$P(g_T=1 \\mid Y=1) = 0.2$。这意味着 $P(g_T=0 \\mid y) = 1 - P(g_T=1 \\mid y)$。\n- $a$ 的类别条件密度：\n  - $a \\mid Y=0 \\sim \\mathcal{N}(\\mu_0, \\sigma_0^2)$，均值 $\\mu_0 = 0.2$，标准差 $\\sigma_0 = 0.1$。\n  - $a \\mid Y=1 \\sim \\mathcal{N}(\\mu_1, \\sigma_1^2)$，均值 $\\mu_1 = 1.0$，标准差 $\\sigma_1 = 0.2$。\n  - 概率密度函数由 $f(a \\mid y) = \\frac{1}{\\sigma_y \\sqrt{2\\pi}} \\exp\\left( -\\frac{(a - \\mu_y)^2}{2 \\sigma_y^2} \\right)$ 给出。\n- 分类任务：对于一个观测值 $x=(g_{\\mathrm{HLA}}, g_T, a)$，预测使后验概率 $P(Y=y \\mid X=x)$ 最大化的类别 $\\hat{y}$。\n- 平局决胜规则：如果概率相等，则预测 $\\hat{y}=1$。\n- 测试集：$(1, 0, 0.9)$, $(0, 1, 0.1)$, $(0, 0, 0.5)$, $(0, 1, 0.0)$, $(1, 1, 0.05)$。\n\n步骤 2：使用提取的给定信息进行验证。\n该问题描述了一个标准的朴素贝叶斯分类任务。\n- **科学依据：** 该设置是药物基因组学中一个简化但合理的模型。特征（HLA 等位基因、转运蛋白基因、酶活性）是相关的生物标志物。概率框架是科学合理的。该问题并非基于伪科学。\n- **定义明确：** 模型所需的所有参数（先验概率、条件概率、分布参数）都已提供。目标函数（最大化后验概率）定义清晰，平局决胜规则确保任何输入都有唯一解。\n- **客观性：** 该问题以精确的数学语言陈述，没有歧义或主观论断。\n\n该问题未违反任何指定的无效标准。它是完整的、一致的且可形式化的。\n\n步骤 3：结论与行动。\n该问题有效。将构建一个解决方案。\n\n解决方案：\n目标是设计一个分类器，预测使后验概率 $P(Y=y \\mid X=x)$ 最大化的类别 $\\hat{y}$。这被称为最大后验概率（MAP）决策规则。\n$$\n\\hat{y} = \\arg\\max_{y \\in \\{0, 1\\}} P(Y=y \\mid X=x)\n$$\n根据贝叶斯定理，后验概率由下式给出：\n$$\nP(Y=y \\mid X=x) = \\frac{p(X=x \\mid Y=y) P(Y=y)}{p(X=x)}\n$$\n分母 $p(X=x)$ 是一个边缘概率（也称为证据），用作归一化常数。由于它与类别 $y$ 无关，因此不影响最大化过程。因此，决策规则等价于最大化联合概率：\n$$\n\\hat{y} = \\arg\\max_{y \\in \\{0, 1\\}} p(X=x \\mid Y=y) P(Y=y)\n$$\n问题指定了相等的类别先验概率，$P(Y=0) = P(Y=1) = \\tfrac{1}{2}$。因此，先验概率项也不影响最大化，可以省略。问题简化为最大化类别条件似然 $p(X=x \\mid Y=y)$：\n$$\n\\hat{y} = \\arg\\max_{y \\in \\{0, 1\\}} p(X=x \\mid Y=y)\n$$\n使用特征向量 $x=(g_{\\mathrm{HLA}}, g_T, a)$ 的条件独立性假设，似然函数为：\n$$\np(x \\mid y) = P(g_{\\mathrm{HLA}} \\mid Y=y) \\cdot P(g_T \\mid Y=y) \\cdot f(a \\mid Y=y)\n$$\n为了避免因乘以小概率而导致的数值下溢，并为方便起见，标准做法是使用似然的对数。由于对数是严格递增函数，最大化一个值等同于最大化其对数。设 $S_y$ 为与类别 $y$ 的对数后验概率成正比的分数。\n$$\n\\hat{y} = \\arg\\max_{y \\in \\{0, 1\\}} \\left( \\log P(g_{\\mathrm{HLA}} \\mid Y=y) + \\log P(g_T \\mid Y=y) + \\log f(a \\mid Y=y) \\right)\n$$\n特征 $a$ 的高斯分布的对数密度为：\n$$\n\\log f(a \\mid y) = \\log\\left(\\frac{1}{\\sigma_y \\sqrt{2\\pi}} \\exp\\left( -\\frac{(a - \\mu_y)^2}{2 \\sigma_y^2} \\right)\\right) = -\\log(\\sigma_y) - \\frac{1}{2}\\log(2\\pi) - \\frac{(a - \\mu_y)^2}{2 \\sigma_y^2}\n$$\n项 $-\\tfrac{1}{2}\\log(2\\pi)$ 对两个类别是共同的，可以从比较中去掉。因此，每个类别 $y$ 的决策分数为：\n$$\nS_y = \\log P(g_{\\mathrm{HLA}} \\mid Y=y) + \\log P(g_T \\mid Y=y) - \\log(\\sigma_y) - \\frac{(a - \\mu_y)^2}{2 \\sigma_y^2}\n$$\n如果 $S_1 \\ge S_0$（包含平局决胜规则），则预测 $\\hat{y}$ 为 $1$，否则为 $0$。\n\n首先，我们必须根据给定信息列出所有必要的条件概率。\n对于 $g_{\\mathrm{HLA}}$：\n- $P(g_{\\mathrm{HLA}}=1 \\mid Y=0) = 0.05$，所以 $P(g_{\\mathrm{HLA}}=0 \\mid Y=0) = 1 - 0.05 = 0.95$。\n- $P(g_{\\mathrm{HLA}}=1 \\mid Y=1) = 0.7$，所以 $P(g_{\\mathrm{HLA}}=0 \\mid Y=1) = 1 - 0.7 = 0.3$。\n对于 $g_T$：\n- $P(g_T=1 \\mid Y=0) = 0.6$，所以 $P(g_T=0 \\mid Y=0) = 1 - 0.6 = 0.4$。\n- $P(g_T=1 \\mid Y=1) = 0.2$，所以 $P(g_T=0 \\mid Y=1) = 1 - 0.2 = 0.8$。\n对于 $a$：\n- 类别 $Y=0$：$\\mu_0 = 0.2$, $\\sigma_0 = 0.1$。\n- 类别 $Y=1$：$\\mu_1 = 1.0$, $\\sigma_1 = 0.2$。\n\n现在我们将此决策规则应用于每个测试用例。\n\n1. 观测值 $(g_{\\mathrm{HLA}}, g_T, a) = (1, 0, 0.9)$：\n$S_0 = \\log(0.05) + \\log(0.4) - \\log(0.1) - \\frac{(0.9 - 0.2)^2}{2(0.1)^2} = -2.996 - 0.916 - (-2.303) - \\frac{0.49}{0.02} \\approx -1.609 - 24.5 = -26.109$\n$S_1 = \\log(0.7) + \\log(0.8) - \\log(0.2) - \\frac{(0.9 - 1.0)^2}{2(0.2)^2} = -0.357 - 0.223 - (-1.609) - \\frac{0.01}{0.08} \\approx 1.029 - 0.125 = 0.904$\n因为 $S_1 > S_0$，所以预测为 $\\hat{y}=1$。\n\n2. 观测值 $(g_{\\mathrm{HLA}}, g_T, a) = (0, 1, 0.1)$：\n$S_0 = \\log(0.95) + \\log(0.6) - \\log(0.1) - \\frac{(0.1 - 0.2)^2}{2(0.1)^2} = -0.051 - 0.511 - (-2.303) - \\frac{0.01}{0.02} \\approx 1.741 - 0.5 = 1.241$\n$S_1 = \\log(0.3) + \\log(0.2) - \\log(0.2) - \\frac{(0.1 - 1.0)^2}{2(0.2)^2} = -1.204 - \\frac{0.81}{0.08} \\approx -1.204 - 10.125 = -11.329$\n因为 $S_0 > S_1$，所以预测为 $\\hat{y}=0$。\n\n3. 观测值 $(g_{\\mathrm{HLA}}, g_T, a) = (0, 0, 0.5)$：\n$S_0 = \\log(0.95) + \\log(0.4) - \\log(0.1) - \\frac{(0.5 - 0.2)^2}{2(0.1)^2} = -0.051 - 0.916 - (-2.303) - \\frac{0.09}{0.02} \\approx 1.336 - 4.5 = -3.164$\n$S_1 = \\log(0.3) + \\log(0.8) - \\log(0.2) - \\frac{(0.5 - 1.0)^2}{2(0.2)^2} = -1.204 - 0.223 - (-1.609) - \\frac{0.25}{0.08} \\approx 0.182 - 3.125 = -2.943$\n因为 $S_1 > S_0$，所以预测为 $\\hat{y}=1$。\n\n4. 观测值 $(g_{\\mathrm{HLA}}, g_T, a) = (0, 1, 0.0)$：\n$S_0 = \\log(0.95) + \\log(0.6) - \\log(0.1) - \\frac{(0.0 - 0.2)^2}{2(0.1)^2} = 1.741 - \\frac{0.04}{0.02} = 1.741 - 2.0 = -0.259$\n$S_1 = \\log(0.3) + \\log(0.2) - \\log(0.2) - \\frac{(0.0 - 1.0)^2}{2(0.2)^2} = -1.204 - \\frac{1.0}{0.08} = -1.204 - 12.5 = -13.704$\n因为 $S_0 > S_1$，所以预测为 $\\hat{y}=0$。\n\n5. 观测值 $(g_{\\mathrm{HLA}}, g_T, a) = (1, 1, 0.05)$：\n$S_0 = \\log(0.05) + \\log(0.6) - \\log(0.1) - \\frac{(0.05 - 0.2)^2}{2(0.1)^2} = -2.996 - 0.511 - (-2.303) - \\frac{0.0225}{0.02} \\approx -1.204 - 1.125 = -2.329$\n$S_1 = \\log(0.7) + \\log(0.2) - \\log(0.2) - \\frac{(0.05 - 1.0)^2}{2(0.2)^2} = -0.357 - \\frac{0.9025}{0.08} \\approx -0.357 - 11.281 = -11.638$\n因为 $S_0 > S_1$，所以预测为 $\\hat{y}=0$。\n\n最终的预测序列是 $[1, 0, 1, 0, 0]$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the pharmacogenomic genotype-phenotype classification task.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1, 0, 0.9),\n        (0, 1, 0.1),\n        (0, 0, 0.5),\n        (0, 1, 0.0),\n        (1, 1, 0.05),\n    ]\n\n    # Model parameters extracted from the problem statement.\n    \n    # P(g_HLA = g | Y = y)\n    # Stored as p_ghla[y][g]\n    p_ghla = {\n        0: {1: 0.05, 0: 0.95},\n        1: {1: 0.7, 0: 0.3}\n    }\n\n    # P(g_T = g | Y = y)\n    # Stored as p_gt[y][g]\n    p_gt = {\n        0: {1: 0.6, 0: 0.4},\n        1: {1: 0.2, 0: 0.8}\n    }\n\n    # Parameters for Gaussian density of a | Y = y\n    # Stored as params_a[y] = (mu, sigma)\n    params_a = {\n        0: (0.2, 0.1),  # mu_0, sigma_0\n        1: (1.0, 0.2)   # mu_1, sigma_1\n    }\n\n    def classify(g_hla: int, g_t: int, a: float) -> int:\n        \"\"\"\n        Classifies a single observation using the MAP decision rule.\n        The implementation uses log-probabilities to ensure numerical stability.\n        \n        The decision rule is to maximize the posterior P(Y=y|X=x).\n        This is equivalent to maximizing the log of the class-conditional likelihood,\n        since priors P(Y=y) are uniform.\n        \n        Score_y = log(P(g_HLA|Y=y)) + log(P(g_T|Y=y)) + log(f(a|Y=y))\n        \n        The log of the Gaussian PDF, ignoring constant terms common to both classes, is:\n        log(f(a|Y=y)) ~ -log(sigma_y) - (a - mu_y)^2 / (2 * sigma_y^2)\n        \"\"\"\n        \n        # Calculate score for class Y=0\n        mu0, sigma0 = params_a[0]\n        log_likelihood_g_0 = np.log(p_ghla[0][g_hla]) + np.log(p_gt[0][g_t])\n        log_pdf_a_0 = -np.log(sigma0) - ((a - mu0)**2) / (2 * sigma0**2)\n        score_0 = log_likelihood_g_0 + log_pdf_a_0\n        \n        # Calculate score for class Y=1\n        mu1, sigma1 = params_a[1]\n        log_likelihood_g_1 = np.log(p_ghla[1][g_hla]) + np.log(p_gt[1][g_t])\n        log_pdf_a_1 = -np.log(sigma1) - ((a - mu1)**2) / (2 * sigma1**2)\n        score_1 = log_likelihood_g_1 + log_pdf_a_1\n        \n        # Decision rule: predict Y=1 if score_1 is greater or equal (tie-breaking).\n        if score_1 >= score_0:\n            return 1\n        else:\n            return 0\n\n    results = []\n    for case in test_cases:\n        g_hla_val, g_t_val, a_val = case\n        prediction = classify(g_hla_val, g_t_val, a_val)\n        results.append(prediction)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在医疗领域，一个预测模型不仅需要准确，其决策过程的透明和可解释性也同样重要。本练习以经典的华法林剂量预测为例，指导您构建一个线性回归模型，并使用与SHAP（SHapley Additive exPlanations）等效的理论来解释模型的预测结果。您将学习如何量化每个特征（包括基因型和临床协变量）对最终剂量建议的贡献，从而理解模型为何对具有相似基因型但临床特征不同的患者给出不同建议。",
            "id": "2413806",
            "problem": "您将设计并实现一个可解释的药物基因组学基因型-表型预测模型，该模型用于解释基因型相似但临床协变量不同的患者对之间的剂量建议差异。该场景基于一个被广泛研究的课题，即细胞色素P450和维生素K环氧化物还原酶复合物基因对华法林（warfarin）剂量的影响，使用通过普通最小二乘法（Ordinary Least Squares, OLS）训练的简单线性模型，并采用SHapley加性解释（SHapley Additive exPlanations, SHAP）或满足标准公理的等效加性、合作博弈论分解方法进行解释。您的程序必须是一个完整的、可运行的程序，能够完全按照规定生成最终输出。\n\n基础和建模假设：\n- 药物基因组学的基因型会影响药物代谢和药物靶点敏感性（中心法则：DNA到RNA到蛋白质），从而导致剂量调整。我们采用经过充分检验的方法，在效应对于小扰动近似可加时，将剂量建模为基因型特征和临床协变量的线性函数。\n- 我们将通过最小化残差平方和（普通最小二乘法）来训练一个线性回归模型，这是线性模型中一种标准且经过充分检验的参数估计方法。\n- 我们要求对每个预测使用SHapley加性解释（SHAP）或满足标准公理（效率性、对称性、虚拟性和可加性）的等效合作博弈论加性归因方法进行可解释的局部解释，其背景数据集由训练数据的经验特征分布定义。\n\n数据规范：\n- 特征按以下顺序索引和排列：\n  - 索引 $0$：CYP2C9 活性评分（取值范围 $\\{0,1,2\\}$）。\n  - 索引 $1$：VKORC1 $-1639$ A等位基因计数（取值范围 $\\{0,1,2\\}$）。\n  - 索引 $2$：年龄（以十年为单位，例如，年龄 $50$ 岁编码为 $5.0$）。\n  - 索引 $3$：体重（以十公斤为单位，例如，体重 $70$ 公斤编码为 $7.0$）。\n\n- 训练设计矩阵 $X_{\\text{train}} \\in \\mathbb{R}^{6 \\times 4}$ 和目标向量 $y_{\\text{train}} \\in \\mathbb{R}^{6}$（稳定的华法林日剂量，单位为mg/day）由以下给出：\n$$\nX_{\\text{train}}=\n\\begin{bmatrix}\n2  0  5.0  7.0\\\\\n1  1  6.0  6.5\\\\\n2  2  4.0  8.0\\\\\n0  1  7.0  5.0\\\\\n1  0  3.0  9.0\\\\\n2  1  5.5  7.5\n\\end{bmatrix},\n\\quad\ny_{\\text{train}}=\n\\begin{bmatrix}\n6.3\\\\\n5.55\\\\\n5.2\\\\\n5.2\\\\\n8.3\\\\\n5.55\n\\end{bmatrix}.\n$$\n\n任务要求：\n1) 通过在 $(X_{\\text{train}}, y_{\\text{train}})$ 上最小化误差平方和来拟合一个线性回归模型，包含一个截距项。将拟合后的模型表示为 $f(\\mathbf{x})=\\hat{b}+\\sum_{i=0}^{3}\\hat{w}_i x_i$。\n\n2) 将解释的背景数据集定义为 $X_{\\text{train}}$ 的经验分布。使用SHapley加性解释（SHAP）或满足标准公理并使用指定背景数据集的等效合作博弈论加性分解方法，将每个预测分解为一个基线项和加性特征归因。具体来说，对于任何输入 $\\mathbf{x}$，计算一个加性分解 $f(\\mathbf{x})=\\phi_0+\\sum_{i=0}^{3}\\phi_i(\\mathbf{x})$，其中 $\\phi_0$ 是与背景相关的基线预测，$\\phi_i(\\mathbf{x})$ 是特征 $i$ 的贡献。您必须实现一个与线性模型的SHAP公理和指定的背景相符的归因方法。\n\n3) 对于下面的每个测试用例，计算：\n   - 患者A的预测剂量，$f(\\mathbf{x}^{(A)})$，单位为mg/day。\n   - 患者B的预测剂量，$f(\\mathbf{x}^{(B)})$，单位为mg/day。\n   - 差值 $f(\\mathbf{x}^{(B)})-f(\\mathbf{x}^{(A)})$，单位为mg/day。\n   - 使B和A之间归因绝对差值最大的特征索引 $j \\in \\{0,1,2,3\\}$，即 $j=\\arg\\max_{i} \\left|\\phi_i(\\mathbf{x}^{(B)})-\\phi_i(\\mathbf{x}^{(A)})\\right|$。如果出现平局，则返回最小的那个索引。\n   - 该特征的带符号贡献差值，$\\phi_j(\\mathbf{x}^{(B)})-\\phi_j(\\mathbf{x}^{(A)})$，单位为mg/day。\n\n测试套件：\n- 用例 $1$（理想情况：基因型相同，体重不同）：\n  - 患者 A: $\\mathbf{x}^{(A)}=[2,\\,1,\\,6.0,\\,6.0]$\n  - 患者 B: $\\mathbf{x}^{(B)}=[2,\\,1,\\,6.0,\\,8.0]$\n- 用例 $2$（CYP2C9处存在基因型差异，协变量相同）：\n  - 患者 A: $\\mathbf{x}^{(A)}=[1,\\,1,\\,5.0,\\,7.0]$\n  - 患者 B: $\\mathbf{x}^{(B)}=[2,\\,1,\\,5.0,\\,7.0]$\n- 用例 $3$（边界情况：患者完全相同）：\n  - 患者 A: $\\mathbf{x}^{(A)}=[2,\\,1,\\,5.5,\\,7.5]$\n  - 患者 B: $\\mathbf{x}^{(B)}=[2,\\,1,\\,5.5,\\,7.5]$\n\n单位和四舍五入：\n- 所有预测剂量和贡献值均以mg/day为单位表示，并四舍五入到三位小数。特征索引是一个整数。\n\n最终输出格式：\n- 您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表，其中每个元素对应一个测试用例，并且本身也是一个列表：$\\left[f(\\mathbf{x}^{(A)}), f(\\mathbf{x}^{(B)}), f(\\mathbf{x}^{(B)})-f(\\mathbf{x}^{(A)}), j, \\phi_j(\\mathbf{x}^{(B)})-\\phi_j(\\mathbf{x}^{(A)})\\right]$。\n- 因此，最终输出必须是以下形式的单行：\n  - 例如，使用占位符：$[[a_1,b_1,d_1,j_1,c_1],[a_2,b_2,d_2,j_2,c_2],[a_3,b_3,d_3,j_3,c_3]]$\n- 输出行中不允许有空格。必须只打印包含方括号列表的那一行。",
            "solution": "所给问题具有科学依据、定义明确且客观。它明确了一个药物基因组学中的标准计算任务：拟合一个预测性线性模型，并解释其对特定个体的预测。数据、假设和所需的计算都已明确定义，从而能够得到唯一且可验证的解。所有必要组成部分——训练数据、模型类型、解释框架和测试用例——都已提供。此问题有效，我将继续提供完整解答。\n\n目标是构建一个用于华法林剂量预测的线性回归模型，并使用一种等效于SHapley加性解释（SHAP）的博弈论归因方法来解释患者对之间预测的差异。\n\n**步骤1：线性回归模型拟合**\n\n要拟合的模型是包含一个截距项的 $p=4$ 个特征的线性函数：\n$$f(\\mathbf{x}) = \\beta_0 + \\sum_{i=1}^{p} \\beta_i x_{i-1} = \\beta_0 + \\beta_1 x_0 + \\beta_2 x_1 + \\beta_3 x_2 + \\beta_4 x_3$$\n其中 $\\mathbf{x} = [x_0, x_1, x_2, x_3]^T$ 代表特征向量。系数 $\\mathbf{\\beta} = [\\beta_0, \\beta_1, \\beta_2, \\beta_3, \\beta_4]^T$ 通过普通最小二乘法（OLS）估计，该方法最小化残差平方和。\n\n我们给定了训练数据 $X_{\\text{train}} \\in \\mathbb{R}^{6 \\times 4}$ 和 $y_{\\text{train}} \\in \\mathbb{R}^{6}$。为了容纳截距 $\\beta_0$，我们用一个前导为1的列来增广特征矩阵 $X_{\\text{train}}$，从而创建设计矩阵 $X' \\in \\mathbb{R}^{6 \\times 5}$。\n$$\nX' =\n\\begin{bmatrix}\n1  2  0  5.0  7.0\\\\\n1  1  1  6.0  6.5\\\\\n1  2  2  4.0  8.0\\\\\n1  0  1  7.0  5.0\\\\\n1  1  0  3.0  9.0\\\\\n1  2  1  5.5  7.5\n\\end{bmatrix},\n\\quad\ny_{\\text{train}}=\n\\begin{bmatrix}\n6.3\\\\\n5.55\\\\\n5.2\\\\\n5.2\\\\\n8.3\\\\\n5.55\n\\end{bmatrix}\n$$\nOLS估计值 $\\hat{\\mathbf{\\beta}}$ 是正规方程的解：\n$$(X'^T X') \\hat{\\mathbf{\\beta}} = X'^T y_{\\text{train}}$$\n假设 $X'^T X'$ 是可逆的，解由以下公式给出：\n$$\\hat{\\mathbf{\\beta}} = (X'^T X')^{-1} X'^T y_{\\text{train}}$$\n解这个线性系统得到以下系数向量：\n$$\\hat{\\mathbf{\\beta}} \\approx [9.92349, -1.25301, -0.65000, -0.44157, 0.11747]^T$$\n所以，截距是 $\\hat{b} = \\hat{\\beta}_0 \\approx 9.923$，特征权重是 $\\hat{\\mathbf{w}} = [\\hat{w}_0, \\hat{w}_1, \\hat{w}_2, \\hat{w}_3]^T \\approx [-1.253, -0.650, -0.442, 0.117]^T$。\n拟合后的模型是：\n$$f(\\mathbf{x}) \\approx 9.923 - 1.253 x_0 - 0.650 x_1 - 0.442 x_2 + 0.117 x_3$$\n\n**步骤2：用于预测解释的归因方法**\n\n该问题要求使用一种与SHAP公理一致的加性特征归因方法。对于线性模型 $f(\\mathbf{x}) = \\hat{b} + \\sum_{i=0}^{3} \\hat{w}_i x_i$，在输入 $\\mathbf{x}$ 处特征 $i$ 的SHAP值由以下公式给出：\n$$\\phi_i(\\mathbf{x}) = \\hat{w}_i (x_i - E[X_i])$$\n其中 $E[X_i]$ 是特征 $i$ 在背景数据分布上的期望值，该分布被定义为 $X_{\\text{train}}$ 的经验分布。因此，$E[X_i]$ 是 $X_{\\text{train}}$ 第 $i$ 列的均值。基准值 $\\phi_0$ 是模型在背景数据上的期望输出：\n$$\\phi_0 = E[f(\\mathbf{X})] = \\hat{b} + \\sum_{i=0}^{3} \\hat{w}_i E[X_i]$$\n分解式 $f(\\mathbf{x}) = \\phi_0 + \\sum_{i=0}^{3} \\phi_i(\\mathbf{x})$ 满足效率性公理。\n\n任务是找到最能解释两个患者A和B之间预测剂量*差异*的特征。特征 $i$ 的归因差异是：\n$$\\Delta\\phi_i = \\phi_i(\\mathbf{x}^{(B)}) - \\phi_i(\\mathbf{x}^{(A)})$$\n代入 $\\phi_i$ 的公式：\n$$\\Delta\\phi_i = \\left[\\hat{w}_i (x_i^{(B)} - E[X_i])\\right] - \\left[\\hat{w}_i (x_i^{(A)} - E[X_i])\\right]$$\n这可以简化为：\n$$\\Delta\\phi_i = \\hat{w}_i (x_i^{(B)} - x_i^{(A)})$$\n这个简洁的结果表明，一个特征贡献的变化就是其权重乘以其值的变化。这使我们能够计算所需的量，而无需从训练数据中显式计算特征均值。解释最大预测差异部分的特征 $j$ 通过以下方式找到：\n$$j = \\arg\\max_{i \\in \\{0,1,2,3\\}} |\\Delta\\phi_i| = \\arg\\max_{i \\in \\{0,1,2,3\\}} |\\hat{w}_i (x_i^{(B)} - x_i^{(A)})|$$\n平局通过选择最小的索引 $j$ 来打破。\n\n**步骤3：测试用例评估**\n\n我们现在将这些公式应用于三个指定的测试用例。所有结果都四舍五入到三位小数。\n\n**用例 1:**\n- 患者 A: $\\mathbf{x}^{(A)} = [2, 1, 6.0, 6.0]$\n- 患者 B: $\\mathbf{x}^{(B)} = [2, 1, 6.0, 8.0]$\n- A的预测剂量: $f(\\mathbf{x}^{(A)}) \\approx 9.923 - 1.253(2) - 0.650(1) - 0.442(6.0) + 0.117(6.0) \\approx 4.817$\n- B的预测剂量: $f(\\mathbf{x}^{(B)}) \\approx 9.923 - 1.253(2) - 0.650(1) - 0.442(6.0) + 0.117(8.0) \\approx 5.052$\n- 剂量差异: $f(\\mathbf{x}^{(B)}) - f(\\mathbf{x}^{(A)}) \\approx 5.052 - 4.817 = 0.235$\n- 归因差异:\n  - $\\Delta\\phi_0 = \\hat{w}_0(2 - 2) = 0$\n  - $\\Delta\\phi_1 = \\hat{w}_1(1 - 1) = 0$\n  - $\\Delta\\phi_2 = \\hat{w}_2(6.0 - 6.0) = 0$\n  - $\\Delta\\phi_3 = \\hat{w}_3(8.0 - 6.0) = 2 \\hat{w}_3 \\approx 0.235$\n- 归因差异最大的特征: 唯一非零差异来自特征 $3$。因此，$j=3$。\n- $j=3$ 的带符号贡献差异: $\\Delta\\phi_3 \\approx 0.235$\n- 结果: $[4.817, 5.052, 0.235, 3, 0.235]$\n\n**用例 2:**\n- 患者 A: $\\mathbf{x}^{(A)} = [1, 1, 5.0, 7.0]$\n- 患者 B: $\\mathbf{x}^{(B)} = [2, 1, 5.0, 7.0]$\n- A的预测剂量: $f(\\mathbf{x}^{(A)}) \\approx 9.923 - 1.253(1) - 0.650(1) - 0.442(5.0) + 0.117(7.0) \\approx 6.633$\n- B的预测剂量: $f(\\mathbf{x}^{(B)}) \\approx 9.923 - 1.253(2) - 0.650(1) - 0.442(5.0) + 0.117(7.0) \\approx 5.380$\n- 剂量差异: $f(\\mathbf{x}^{(B)}) - f(\\mathbf{x}^{(A)}) \\approx 5.380 - 6.633 = -1.253$\n- 归因差异:\n  - $\\Delta\\phi_0 = \\hat{w}_0(2 - 1) = \\hat{w}_0 \\approx -1.253$\n  - $\\Delta\\phi_1 = \\hat{w}_1(1 - 1) = 0$\n  - $\\Delta\\phi_2 = \\hat{w}_2(5.0 - 5.0) = 0$\n  - $\\Delta\\phi_3 = \\hat{w}_3(7.0 - 7.0) = 0$\n- 归因差异最大的特征: 唯一非零差异来自特征 $0$。因此，$j=0$。\n- $j=0$ 的带符号贡献差异: $\\Delta\\phi_0 \\approx -1.253$\n- 结果: $[6.633, 5.380, -1.253, 0, -1.253]$\n\n**用例 3:**\n- 患者 A: $\\mathbf{x}^{(A)} = [2, 1, 5.5, 7.5]$\n- 患者 B: $\\mathbf{x}^{(B)} = [2, 1, 5.5, 7.5]$\n- 患者完全相同，所以 $f(\\mathbf{x}^{(A)}) = f(\\mathbf{x}^{(B)})$。\n- 预测剂量: $f(\\mathbf{x}^{(A)}) \\approx 9.923 - 1.253(2) - 0.650(1) - 0.442(5.5) + 0.117(7.5) \\approx 5.217$\n- 剂量差异: $f(\\mathbf{x}^{(B)}) - f(\\mathbf{x}^{(A)}) = 0.000$\n- 归因差异: 由于 $\\mathbf{x}^{(A)} = \\mathbf{x}^{(B)}$，所有的 $x_i^{(B)} - x_i^{(A)} = 0$。因此，对于所有 $i \\in \\{0, 1, 2, 3\\}$，$\\Delta\\phi_i = 0$。\n- 归因差异最大的特征: 所有绝对差异均为 $0$。平局规则规定选择最小的索引。因此，$j=0$。\n- $j=0$ 的带符号贡献差异: $\\Delta\\phi_0 = 0.000$\n- 结果: $[5.217, 5.217, 0.000, 0, 0.000]$\n\n这些计算为最终程序实现提供了基础。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the pharmacogenomic prediction and explanation problem.\n\n    The solution involves three main steps:\n    1. Fit a linear regression model using Ordinary Least Squares (OLS) on the\n       provided training data.\n    2. For each test case, calculate the predicted warfarin dose for two patients,\n       A and B.\n    3. Calculate the difference in predictions and explain it by finding the\n       feature that contributes most to this difference, based on a SHAP-like\n       additive attribution method for linear models.\n    \"\"\"\n    \n    # 1. Define the training data from the problem statement.\n    X_train = np.array([\n        [2.0, 0.0, 5.0, 7.0],\n        [1.0, 1.0, 6.0, 6.5],\n        [2.0, 2.0, 4.0, 8.0],\n        [0.0, 1.0, 7.0, 5.0],\n        [1.0, 0.0, 3.0, 9.0],\n        [2.0, 1.0, 5.5, 7.5]\n    ])\n    y_train = np.array([6.3, 5.55, 5.2, 5.2, 8.3, 5.55])\n    \n    # 2. Fit a linear regression model.\n    # Augment the training data matrix with a column of ones for the intercept.\n    X_prime = np.hstack([np.ones((X_train.shape[0], 1)), X_train])\n    \n    # Solve the normal equations: (X'T * X') * beta = X'T * y\n    # This is numerically more stable than calculating the inverse directly.\n    try:\n        beta_hat = np.linalg.solve(X_prime.T @ X_prime, X_prime.T @ y_train)\n    except np.linalg.LinAlgError:\n        # Fallback to pseudoinverse if matrix is singular, though not expected here.\n        beta_hat = np.linalg.pinv(X_prime) @ y_train\n\n    intercept = beta_hat[0]\n    weights = beta_hat[1:]\n\n    # 3. Define the test cases.\n    test_cases = [\n        # Case 1 (happy path: identical genotypes, different weight)\n        (np.array([2.0, 1.0, 6.0, 6.0]), np.array([2.0, 1.0, 6.0, 8.0])),\n        # Case 2 (genotype difference at CYP2C9, same covariates)\n        (np.array([1.0, 1.0, 5.0, 7.0]), np.array([2.0, 1.0, 5.0, 7.0])),\n        # Case 3 (boundary: identical patients)\n        (np.array([2.0, 1.0, 5.5, 7.5]), np.array([2.0, 1.0, 5.5, 7.5]))\n    ]\n    \n    all_results = []\n\n    # 4. Process each test case.\n    for x_a, x_b in test_cases:\n        # a. Compute predicted doses for patient A and B.\n        # f(x) = intercept + sum(weights * features)\n        pred_a = intercept + weights.T @ x_a\n        pred_b = intercept + weights.T @ x_b\n\n        # b. Compute the difference in predictions.\n        pred_diff = pred_b - pred_a\n\n        # c. Compute the feature attribution differences.\n        # For a linear model, the SHAP-based attribution difference for feature i\n        # is simply weight_i * (x_b_i - x_a_i).\n        delta_phis = weights * (x_b - x_a)\n\n        # d. Find the feature index 'j' that maximizes the absolute attribution difference.\n        # np.argmax returns the first index in case of a tie, which satisfies the\n        # requirement to return the smallest such index.\n        j = np.argmax(np.abs(delta_phis))\n        \n        # e. Get the signed contribution difference for that feature.\n        contrib_diff = delta_phis[j]\n\n        # Store the 5 required values for the current test case.\n        case_result = [pred_a, pred_b, pred_diff, j, contrib_diff]\n        all_results.append(case_result)\n\n    # 5. Format the output string exactly as specified.\n    # Example format: [[a1,b1,d1,j1,c1],[a2,b2,d2,j2,c2],...]\n    # Floats must be rounded to three decimal places.\n    case_strings = []\n    for result in all_results:\n        pred_a_str = f\"{result[0]:.3f}\"\n        pred_b_str = f\"{result[1]:.3f}\"\n        pred_diff_str = f\"{result[2]:.3f}\"\n        j_str = str(result[3]) # Index is an integer\n        contrib_diff_str = f\"{result[4]:.3f}\"\n        \n        formatted_case = (\n            f\"[{pred_a_str},\"\n            f\"{pred_b_str},\"\n            f\"{pred_diff_str},\"\n            f\"{j_str},\"\n            f\"{contrib_diff_str}]\"\n        )\n        case_strings.append(formatted_case)\n\n    # Join all case strings with a comma and enclose in brackets.\n    final_output = f\"[{','.join(case_strings)}]\"\n    \n    # Final print statement must produce only the specified single-line format.\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}