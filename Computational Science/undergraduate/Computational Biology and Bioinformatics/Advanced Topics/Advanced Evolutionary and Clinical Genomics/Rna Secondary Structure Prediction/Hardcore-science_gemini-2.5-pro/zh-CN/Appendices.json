{
    "hands_on_practices": [
        {
            "introduction": "基础的Nussinov算法通过最大化碱基对的数量来预测RNA二级结构，但它平等地对待所有类型的碱基对。在生物物理现实中，鸟嘌呤（G）和胞嘧啶（C）之间通过三个氢键配对，而腺嘌呤（A）和尿嘧啶（U）之间只有两个，因此G-C对具有更高的热稳定性。这个练习将引导你修改动态规划算法，使其目标函数从最大化总配对数转变为最大化G-C配对数，这是向更真实的能量模型迈出的第一步，能让你更好地理解如何通过调整评分方案来优化预测结果。",
            "id": "2426841",
            "problem": "给定一个理想化的核糖核酸（RNA）二级结构模型，该模型是基于字母表 {A, U, G, C} 的单链序列上的一组碱基对。长度为 $n$ 的序列上的二级结构是一个有序索引对 $(i,j)$ 的集合 $M$，其中 $0 \\le i  j \\le n-1$，并满足以下有效性约束：(1) 每个索引最多出现在一个对中，(2) 只允许规范配对，允许的碱基对为 A–U、U–A、G–C、C–G、G–U 和 U–G，以及 (3) 不存在假结（pseudoknots），意味着如果 $(i,j) \\in M$ 且 $(k,\\ell) \\in M$，其中 $i  k$，则必须是 $i  j  k  \\ell$（不相交）或 $i  k  \\ell  j$（嵌套）。此外，还强制执行最小发夹环长度约束：对于每个对 $(i,j) \\in M$，该对所包含的未配对核苷酸的数量必须至少为 $L$，即 $j - i - 1 \\ge L$，其中 $L$ 是一个给定的非负整数。\n\n定义鸟嘌呤-胞嘧啶含量目标如下。对于一个给定的有效结构 $M$，其鸟嘌呤-胞嘧啶分数为\n$$\n\\operatorname{GC}(M) \\;=\\; \\sum_{(i,j)\\in M} \\mathbf{1}\\big(\\{s_i,s_j\\}=\\{\\mathrm{G},\\mathrm{C}\\}\\big),\n$$\n其中 $s_i$ 是位置 $i$ 处的核苷酸，$\\mathbf{1}(\\cdot)$ 是指示函数，如果该对是鸟嘌呤–胞嘧啶对（G–C 或 C–G），则计为 $1$，否则计为 $0$。你的任务是，对于每个测试用例，计算在给定序列和指定的最小发夹环长度 $L$ 的条件下，满足上述所有约束的有效结构 $M$ 中，$\\operatorname{GC}(M)$ 的最大可能值。\n\n你的程序必须使用下面固定的测试套件。对于每个测试用例，输入是由一个序列和一个 $L$ 值组成的对。对于每个测试用例，输出必须是一个整数，等于在上述规则下 $\\operatorname{GC}(M)$ 可达到的最大值。\n\n测试套件：\n- 序列 \"GGGCCC\"，最小发夹环长度 $L=0$。\n- 序列 \"AAAA\"，最小发夹环长度 $L=0$。\n- 序列 \"GCAUCG\"，最小发夹环长度 $L=3$。\n- 序列 \"GUGU\"，最小发夹环长度 $L=0$。\n- 序列 \"\"，最小发夹环长度 $L=0$。\n- 序列 \"CGCG\"，最小发夹环长度 $L=0$。\n\n最终输出格式：你的程序应该生成一行输出，其中包含按顺序排列的结果，格式为方括号括起来的逗号分隔列表（例如，\"[x_1,x_2,\\dots,x_6]\"），其中每个 $x_i$ 是测试套件中第 $i$ 个测试用例的整数最大值 $\\operatorname{GC}(M)$。",
            "solution": "所提出的问题是一个约束优化问题，其核心是 RNA 二级结构的预测，这是计算生物学中的一个经典课题。任务是找到一个能使鸟嘌呤-胞嘧啶（G-C）对数量最大化的有效二级结构。禁止假结是一项关键约束，它使得该问题可以通过动态规划求解，因为它确保了结构可以被分层分解。\n\n设给定的 RNA 序列为 $s$，长度为 $n$，索引从 $0$ 到 $n-1$。我们定义 $E(i, j)$ 为子序列 $s_i, s_{i+1}, \\dots, s_j$ 可能的最大 G-C 分数。目标是计算 $E(0, n-1)$。\n\n解决方案建立在最优化原理之上：一个序列的最优结构由其子序列的最优结构组成。我们通过考虑子序列 $s_i \\dots s_j$ 的所有有效结构构型，来构建 $E(i, j)$ 的递推关系。任何此类结构都由索引 $j$ 处的碱基的状态决定。\n\n对于碱基 $s_j$，有两种基本情况：\n\n1.  **碱基 $s_j$ 未配对。** 在这种情况下，$s_j$ 不形成配对，对 G-C 分数没有贡献。优化 $s_i \\dots s_j$ 上结构的问题简化为在较短的子序列 $s_i \\dots s_{j-1}$ 上寻找最优结构。因此，分数由 $E(i, j-1)$ 给出。\n\n2.  **碱基 $s_j$ 与碱基 $s_k$ 配对，其中 $i \\le k  j$。** 配对 $(k, j)$ 的形成受问题中定义的两个主要约束的限制：\n    -   **规范配对**：核苷酸对 $(s_k, s_j)$ 必须是允许的规范配对之一：A–U、U–A、G–C、C–G、G–U 或 U–G。\n    -   **最小发夹环长度**：该对所包含的核苷酸数量必须至少为 $L$，这转化为条件 $j - k - 1 \\ge L$。\n\n如果一个对 $(k, j)$ 满足这些条件，它的形成会产生局部和全局的影响。局部上，它对总分有贡献。如果 $\\{s_k, s_j\\} = \\{\\text{G}, \\text{C}\\}$，则贡献为 $1$，对于其他允许的规范配对（A-U、G-U 及其反向互补对），贡献为 $0$。全局上，无假结规则规定，配对 $(k, j)$ 将序列 $s_i \\dots s_j$ 分割成两个可独立优化的子区域：配对之前的区域 $s_i \\dots s_{k-1}$，以及配对所包含的区域 $s_{k+1} \\dots s_{j-1}$。这种特定构型的总分是这两个独立子问题的最优分数之和，再加上配对 $(k, j)$ 本身的贡献分数。\n\n通过组合这些情况并在所有可能性中取最大值，我们得到以下递推关系：\n$$\nE(i, j) = \\max \\left( E(i, j-1), \\quad \\max_{ \\substack{i \\le k  j \\\\ (k,j) \\text{ is valid}} } \\left\\{ E(i, k-1) + E(k+1, j-1) + \\mathbf{1}(\\{s_k,s_j\\}=\\{\\mathrm{G},\\mathrm{C}\\}) \\right\\} \\right)\n$$\n此处，$\\mathbf{1}(\\cdot)$ 是指示函数，如果其参数为真，则其值为 $1$，否则为 $0$。术语“有效”对于配对 $(k,j)$ 而言，包含了规范配对规则和最小环长度约束。\n\n递归的基例是那些太短而无法形成任何有效配对的子序列。对于任何满足子序列长度 $j-i+1$ 小于 $L+2$ 的 $i, j$，不可能形成满足最小长度 $L$ 的发夹环。因此，对于这样的子序列，$E(i, j) = 0$。我们还定义对于任何 $i > j$ 的情况，$E(i, j) = 0$，这对应于一个空子序列。\n\n这个递推关系通过填充一个二维数组（我们称之为 $\\texttt{dp}[i][j]$）来算法实现，该数组存储 $E(i, j)$ 的计算值。计算过程通过迭代递增的子序列长度 $d = j-i$（从 $d=1$ 到 $d=n-1$）进行。对于每个长度 $d$，我们遍历所有可能的起始位置 $i$（从 $0$ 到 $n-1-d$）。问题的最终解是存储在 $\\texttt{dp}[0][n-1]$ 中的值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the RNA secondary structure problem for a fixed test suite.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\"GGGCCC\", 0),\n        (\"AAAA\", 0),\n        (\"GCAUCG\", 3),\n        (\"GUGU\", 0),\n        (\"\", 0),\n        (\"CGCG\", 0),\n    ]\n\n    results = []\n    for sequence, L in test_cases:\n        result = compute_max_gc_pairs(sequence, L)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_max_gc_pairs(sequence: str, L: int) -> int:\n    \"\"\"\n    Computes the maximum number of G-C pairs in a valid RNA secondary structure.\n\n    This function uses dynamic programming to solve the problem. The state E(i, j)\n    represents the maximum G-C score for the subsequence from index i to j.\n\n    Args:\n        sequence: The RNA sequence string.\n        L: The minimum hairpin loop length.\n\n    Returns:\n        The maximum number of G-C pairs.\n    \"\"\"\n    n = len(sequence)\n    if n  L + 2:\n        return 0\n\n    # Initialize a DP table to store the max scores for subsequences.\n    # dp[i][j] will store the max GC score for sequence[i:j+1]\n    dp = np.zeros((n, n), dtype=int)\n\n    canonical_pairs = {('A', 'U'), ('U', 'A'), ('G', 'C'), ('C', 'G'), ('G', 'U'), ('U', 'G')}\n\n    def is_canonical(b1: str, b2: str) -> bool:\n        return (b1, b2) in canonical_pairs\n\n    def gc_score(b1: str, b2: str) -> int:\n        return 1 if (b1 == 'G' and b2 == 'C') or (b1 == 'C' and b2 == 'G') else 0\n\n    # Iterate over subsequence length d (from 1 to n-1)\n    for d in range(1, n):\n        # Iterate over start index i\n        for i in range(n - d):\n            j = i + d\n\n            # Case 1: j is unpaired. The score is the same as the subsequence s_i...s_{j-1}.\n            score_unpaired = dp[i, j - 1]\n\n            # Case 2: j is paired with some k. We must maximize over all possible k.\n            max_score_j_paired = 0\n            # k must satisfy i = k  j and the loop length constraint j - k - 1 >= L.\n            # This implies k = j - L - 1.\n            for k in range(i, j - L):\n                if is_canonical(sequence[k], sequence[j]):\n                    # Score from the pair (k, j) itself.\n                    pair_score = gc_score(sequence[k], sequence[j])\n                    \n                    # Score from the structure on the subsequence before k.\n                    score_before = dp[i, k - 1] if k > i else 0\n                    \n                    # Score from the structure on the subsequence inside (k, j).\n                    score_inside = dp[k + 1, j - 1] if k + 1 = j - 1 else 0\n                    \n                    current_total_score = score_before + pair_score + score_inside\n                    if current_total_score > max_score_j_paired:\n                        max_score_j_paired = current_total_score\n\n            # The final score for dp[i, j] is the maximum of the unpaired and paired cases.\n            dp[i, j] = max(score_unpaired, max_score_j_paired)\n            \n    return dp[0, n - 1] if n > 0 else 0\n\nsolve()\n```"
        },
        {
            "introduction": "在认识到不同碱基对具有不同稳定性之后，我们进一步考虑RNA结构稳定性的另一个关键因素：堆积相互作用（stacking interactions）。一个碱基对的稳定性很大程度上受到其相邻碱基对的影响，形成“螺旋”（helix）的堆叠结构远比孤立的“孤独碱基对”（lonely pair）在能量上更有利。这个练习要求你设计一个不允许孤独碱基对的算法，这需要对动态规划的公式进行实质性修改，例如通过引入辅助表格来预计算螺旋，或定义更复杂的状态来跟踪堆积信息。通过解决这个问题，你将学会如何将邻近碱基间的相互作用整合到全局结构预测中，这是从简单的配对计数模型迈向复杂能量模型的关键一步。",
            "id": "2426853",
            "problem": "给定字母表 {A, C, G, U} 上的有限序列，代表核糖核酸 (RNA)。对于一个长度为 $n$ 的序列 $s = s_1 s_2 \\dots s_n$，一个二级结构是一个索引的有序对集合 $\\{(i,j)\\}$，其中 $1 \\le i  j \\le n$，并满足以下条件：\n- 每个索引最多出现在一个对中。\n- 该结构是无假结的（非交叉）：对于任意两个配对 $(i,j)$ 和 $(k,\\ell)$，如果 $i  k$，则必须满足 $j  k$ 或 $\\ell  j$。\n- 碱基配对遵循经典规则：允许的碱基对为 $\\{ \\text{A-U}, \\text{U-A}, \\text{G-C}, \\text{C-G}, \\text{G-U}, \\text{U-G} \\}$。\n- 不允许出现孤立对：对于结构中的每一个配对 $(i,j)$，只要索引在 $[1,n]$ 范围内，$(i+1, j-1)$ 或 $(i-1, j+1)$ 中至少有一个也必须在结构中。换言之，每个配对的核苷酸必须是长度至少为 $2$ 的螺旋的一部分（即至少在一侧与一个相邻的配对堆叠）。\n\n本问题不设最小发夹环长度限制，也没有物理单位。对于每个输入序列，目标是在所有满足上述约束的二级结构中，计算可能的最大碱基对数量（一个整数）。\n\n测试套件：\n- 情况 $1$：$s = \\text{\"AU\"}$\n- 情况 $2$：$s = \\text{\"AUAU\"}$\n- 情况 $3$：$s = \\text{\"GGGAAACCC\"}$\n- 情况 $4$：$s = \\text{\"GCAU\"}$\n- 情况 $5$：$s = \\text{\"AUAUCCCCAUAU\"}$\n- 情况 $6$：$s = \\text{\"AGCU\"}$\n\n您的程序必须为每种情况计算在规定约束下的最大碱基对数，并将结果输出为单行，形式为一个包含六个整数的逗号分隔列表，用方括号括起来，且不含空格。例如，格式必须与 $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5,\\text{result}_6]$ 完全一致。",
            "solution": "用户提交了一个计算生物学领域的问题，具体涉及RNA二级结构的预测。我将首先验证问题陈述的科学合理性和逻辑一致性。\n\n### 第一步：提取已知条件\n- **输入**：字母表 $\\{A, C, G, U\\}$ 上长度为 $n$ 的RNA序列 $s = s_1 s_2 \\dots s_n$。\n- **输出**：有效二级结构中可能的最大碱基对数量。\n- **二级结构约束**：一个配对集合 $\\{(i,j)\\}$（其中 $1 \\le i  j \\le n$）必须满足：\n    1.  **唯一配对**：每个索引 $k \\in \\{1, \\dots, n\\}$ 最多只能出现在一个配对中。\n    2.  **无假结**：对于任意两个配对 $(i,j)$ 和 $(k,\\ell)$，如果 $i  k$，则必须满足 $j  k$（配对不相交）或 $\\ell  j$（配对 $(k,\\ell)$ 嵌套在 $(i,j)$ 内）。禁止 $i  k  j  \\ell$ 的情况。\n    3.  **经典碱基对**：允许的配对为 $(s_i, s_j) \\in \\{ (\\text{A},\\text{U}), (\\text{U},\\text{A}), (\\text{G},\\text{C}), (\\text{C},\\text{G}), (\\text{G},\\text{U}), (\\text{U},\\text{G}) \\}$。\n    4.  **无孤立对**：对于结构中的每一个配对 $(i,j)$，其相邻的潜在配对 $(i+1, j-1)$ 或 $(i-1, j+1)$ 中至少有一个也必须在结构中（假设索引有效）。\n\n### 第二步：使用提取的已知条件进行验证\n1.  **科学依据**：该问题是RNA二级结构预测的一个简化但有科学依据的表述。这些约束模拟了基本的生物物理特性：碱基配对规则、空间上的非交叉性（无假结），以及堆叠对的能量有利性（无孤立对）。这是生物信息学中一个成熟的课题。该问题在科学上是有效的。\n2.  **适定性**：该问题要求在一个离散、有限的可能结构集合上，求一个明确定义的量（碱基对数量）的最大值。对于任何有限序列，保证存在唯一的最大值。该问题是适定的。\n3.  **客观性**：问题陈述使用了精确、客观和形式化的定义，没有歧义或主观性语言。\n\n### 第三步：结论与行动\n问题陈述是有效的。这是一个定义明确的优化问题，可以通过算法解决。我现在将着手构建解决方案。\n\n### 解决方案推导\n问题是在无假结的RNA二级结构中，找到满足“无孤立对”附加约束条件下的最大碱基对数。这类问题通常使用动态规划来解决。\n\n无假结约束意味着任何在子序列 $s_i \\dots s_j$ 上的结构都可以被分解。该结构要么由两个独立的、相邻的子结构（分叉）形成，要么被一个连接某个 $s_k$ 和 $s_l$（其中 $i \\le k  l \\le j$）的碱基对所包围。\n\n关键约束是“无孤立对”规则。该规则规定，每个碱基对必须与至少另一个碱基对相邻，形成一个堆叠。最小的此类结构是“堆叠对”或“长度为2的螺旋”，例如，配对 $(i, j)$ 和 $(i+1, j-1)$。这意味着计分的基本单位不是单个碱基对，而是长度至少为 $2$ 的螺旋。\n\n基于这一洞见，我们可以构建一个动态规划解决方案。设 $M[i][j]$ 为在子序列 $s_i \\dots s_j$ 内可以形成的最大碱基对数。为了计算 $M[i][j]$，我们考虑该子序列所有可能的有效结构。由于无假结约束，任何此类结构都属于以下两类之一：\n\n1.  **分叉**：$s_i \\dots s_j$ 上的结构由 $s_i \\dots s_k$ 和 $s_{k+1} \\dots s_j$ 上的两个独立且相邻的子结构组成，其中 $k$ 是某个分裂点，$i \\le k  j$。在这种情况下，总配对数是 $M[i][k] + M[k+1][j]$。我们必须对所有可能的 $k$ 取最大值。\n\n2.  **闭合螺旋**：整个子序列 $s_i \\dots s_j$ 被一个螺旋所包围。根据“无孤立对”规则，该螺旋的长度必须为 $p \\ge 2$。一个长度为 $p$ 的螺旋由 $p$ 个堆叠对组成：$(i, j), (i+1, j-1), \\dots, (i+p-1, j-p+1)$。此构型贡献了 $p$ 个配对，外加在剩余内部子序列 $s_{i+p} \\dots s_{j-p}$ 中可以形成的最大配对数，即 $M[i+p][j-p]$。\n\n为了有效地确定可能的螺旋长度，我们可以预先计算一个辅助表 $H[i][j]$，它存储了以配对 $(i, j)$ 开始并向内延伸的最长可能螺旋的长度。该表可以通过递归计算：\n$$\nH[i][j] = \\begin{cases} 1 + H[i+1][j-1]  \\text{如果 } (s_i, s_j) \\text{ 可以形成碱基对} \\\\ 0  \\text{否则} \\end{cases}\n$$\n基本情况是当 $j \\le i$ 时，$H[i][j] = 0$。\n\n在预先计算好 $H$ 表后，$M[i][j]$ 的递推关系结合了两种结构可能性：\n$$\nM[i][j] = \\max \\left( \\max_{i \\le k  j} (M[i][k] + M[k+1][j]), \\quad \\max_{p=2, \\dots, H[i][j]} (p + M[i+p][j-p]) \\right)\n$$\n第一项对应分叉情况。第二项对应闭合螺旋情况，其中我们对所有可能的有效螺旋长度 $p \\ge 2$ 取最大值。如果无法形成这样的螺旋（即 $H[i][j]  2$），则此项实际上为 $0$ 或 $-\\infty$，对最大值没有贡献。主递推的基本情况是对于所有 $j \\le i$，$M[i][j] = 0$。\n\n算法通过从 $1$ 到 $n$ 递增子序列长度 $L$ 进行迭代。对于每个 $L$，我们计算所有 $i$（其中 $j=i+L-1$）的 $H[i][j]$ 和 $M[i][j]$。最终答案是整个序列的最大配对数，由 $M[0][n-1]$ 给出。这确保了当计算某个长度的子序列的值时，所有更短子序列的值都已经计算完毕。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the RNA secondary structure problem for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        \"AU\",\n        \"AUAU\",\n        \"GGGAAACCC\",\n        \"GCAU\",\n        \"AUAUCCCCAUAU\",\n        \"AGCU\",\n    ]\n\n    results = []\n    for s in test_cases:\n        result = compute_max_pairs(s)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_max_pairs(s: str) -> int:\n    \"\"\"\n    Computes the maximum number of base pairs in an RNA sequence\n    under the constraints of being pseudoknot-free and having no lonely pairs.\n\n    This is achieved using dynamic programming. Two tables are used:\n    - H[i, j]: Stores the length of the longest helix starting with a pair (i, j).\n    - M[i, j]: Stores the maximum number of pairs in the subsequence s[i...j].\n\n    The recurrence for M[i, j] considers two cases for the structure on s[i...j]:\n    1. A bifurcation into two independent adjacent substructures.\n    2. An enclosing helix of length p = 2.\n    \"\"\"\n    n = len(s)\n    if n  4:  # A helix of length 2 requires at least 4 nucleotides.\n        return 0\n\n    allowed_pairs = {('A', 'U'), ('U', 'A'), ('G', 'C'), ('C', 'G'), ('G', 'U'), ('U', 'G')}\n\n    def can_pair(i, j):\n        if i  0 or j >= n or i >= j:\n            return False\n        return (s[i], s[j]) in allowed_pairs\n\n    # H[i,j]: length of the longest helix starting with pair (i,j)\n    H = np.zeros((n, n), dtype=int)\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if can_pair(i, j):\n                if length == 2:\n                    H[i, j] = 1\n                else:\n                    H[i, j] = 1 + H[i + 1, j - 1]\n\n    # M[i,j]: maximum number of pairs in subsequence s[i...j]\n    M = np.zeros((n, n), dtype=int)\n    # The loop must start from a length where a valid structure can form.\n    # The smallest valid structure is a helix of length 2 which spans 4 bases.\n    for length in range(4, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n\n            # Case 1: Bifurcation. Structure on s[i...j] is a concatenation\n            # of structures on s[i...k] and s[k+1...j].\n            bifurcation_max = 0\n            for k in range(i, j):\n                bifurcation_max = max(bifurcation_max, M[i, k] + M[k + 1, j])\n\n            # Case 2: Closing helix. Structure on s[i...j] is enclosed\n            # by a helix of length p = 2.\n            helix_max = 0\n            helix_len = H[i, j]\n            if helix_len >= 2:\n                for p in range(2, helix_len + 1):\n                    # Check if the helix fits within the [i,j] interval.\n                    # This is guaranteed by H, but the inner loop indices must be valid.\n                    if (i + p - 1)  (j - p + 1):\n                        current_helix_pairs = p\n                        inner_pairs = 0\n                        # Calculate pairs in the loop enclosed by the helix\n                        if i + p = j - p:\n                             inner_pairs = M[i + p, j - p]\n                        \n                        helix_max = max(helix_max, current_helix_pairs + inner_pairs)\n\n            M[i, j] = max(bifurcation_max, helix_max)\n\n    return int(M[0, n - 1])\n\nsolve()\n```"
        },
        {
            "introduction": "到目前为止，我们的目标都是找到一个唯一的“最优”结构，即最小自由能（MFE）结构。然而，在细胞环境中，一个RNA分子可能以多种能量相近但结构迥异的构象共存，形成一个结构整体（structural ensemble），而其生物学功能可能由其中某个次优结构（suboptimal structure）介导。这个高级练习挑战你超越MFE预测的局限，去探索次优结构空间。你需要实现一个多阶段算法：首先找到唯一的MFE结构 $S^{\\star}$，然后在一个给定的能量窗口 $\\Delta$ 内，找到一个与 $S^{\\star}$ 结构差异最大（即碱基对距离 $d(S,S^{\\star})$ 最大）的次优结构。这个练习将让你深刻体会到结构整体的概念，并掌握在庞大的结构空间中进行目标性搜索的高级动态规划技巧。",
            "id": "2426771",
            "problem": "给定一个 RNA 序列，它是一个由字母表 {'A','C','G','U'} 中字符组成的有限字符串。一个长度为 $n$ 的序列的二级结构定义为一个有序对 $(i,j)$ 的有限集合 $S$，其中 $1 \\le i  j \\le n$，且满足以下所有约束条件：\n- 碱基配对约束：只允许配对 $\\{\\text{A},\\text{U}\\}$、$\\{\\text{U},\\text{A}\\}$、$\\{\\text{G},\\text{C}\\}$、$\\{\\text{C},\\text{G}\\}$、$\\{\\text{G},\\text{U}\\}$ 和 $\\{\\text{U},\\text{G}\\}$。\n- 最小发夹环长度约束：对于集合 $S$ 中的每一个配对 $(i,j)$，必须满足 $j - i - 1 \\ge L$，其中 $L$ 是一个给定的非负整数。\n- 非交叉和非重叠约束：如果 $(i,j) \\in S$ 且 $(k,\\ell) \\in S$，其中 $i  k$，则必须是 $i  j  k  \\ell$（不相交）或 $i  k  \\ell  j$（嵌套）。\n\n对于任何二级结构 $S$，其能量 $E(S)$ 定义为 $-|S|$，其中 $|S|$ 是该结构中碱基对的数量。因此，能量最小化等价于最大化碱基对的数量。最小自由能（MFE）结构 $S^\\star$ 是所有有效结构中具有最大碱基对数量的结构。如果存在多个这样的结构，则 $S^\\star$ 是其中碱基对列表按字典序最小的一个。\n\n两个二级结构 $S_1$ 和 $S_2$ 之间的距离 $d(S_1, S_2)$ 定义为它们对称差的大小：$| (S_1 \\setminus S_2) \\cup (S_2 \\setminus S_1) |$。一个结构 $S$ 被认为是“次优的”，如果其碱基对数量 $B(S)=|S|$ 在一个给定的能量窗口 $\\Delta$ 内，但严格低于MFE结构的碱基对数量，即 $B(S^\\star) > B(S) \\ge B(S^\\star) - \\Delta$。\n\n你的任务是找到一个在给定 $\\Delta$ 范围内的次优结构 $S$ 中，与MFE结构 $S^\\star$ 的距离 $d(S, S^\\star)$ 最大的那个。如果不存在这样的次优结构，则结果为 $-1$。\n\n你的程序必须使用以下固定的测试套件：\n- 情况 1：序列 = \"GCAUCUAUGC\", $L=3$, $\\Delta=2$\n- 情况 2：序列 = \"AAAAAA\", $L=3$, $\\Delta=3$\n- 情况 3：序列 = \"GCGC\", $L=0$, $\\Delta=1$\n- 情况 4：序列 = \"AUGCUA\", $L=2$, $\\Delta=0$\n\n对于每个测试用例，输出一个整数：最大距离，或 $-1$。最终输出必须是一行，包含一个用方括号括起来的逗号分隔的整数列表，不含空格，例如，`[result_1,result_2,result_3,result_4]`。",
            "solution": "用户提供了一个关于 RNA 二级结构的计算生物学问题。任务是找到最小自由能（MFE）结构与一组由能量容差定义的严格次优结构之间的最大碱基对距离。我将首先验证问题陈述，然后提供详细的解决方案。\n\n### 第 1 步：提取给定信息\n- **RNA 序列**：一个由字母表 $\\{'A','C','G','U'\\}$ 构成的字符串。\n- **二级结构 $S$**：一个有序对 $(i, j)$ 的集合，其中 $1 \\le i  j \\le n$（此处描述使用 1-based 索引，但实现中使用 0-based）。\n- **$S$ 的约束条件**：\n    1.  **配对**：只允许 Watson-Crick 配对 $\\{A,U\\}$ 和 $\\{G,C\\}$，以及摆动配对 $\\{G,U\\}$。\n    2.  **环长度**：对于 $S$ 中的任何配对 $(i,j)$，发夹环的长度必须满足 $j-i-1 \\ge L$。\n    3.  **非交叉**：对于 $S$ 中的任意两个配对 $(i,j)$ 和 $(k,\\ell)$，它们不能交叉（即，禁止 $i  k  j  \\ell$ 的情况）。\n- **能量与 MFE**：能量 $E(S) = -|S|$。MFE 结构 $S^\\star$ 是使 $|S|$ 最大化的结构。若有多个，则选择配对列表字典序最小的那个。\n- **次优结构**：一个结构 $S$ 是次优的，如果 $B(S^\\star) > |S| \\ge B(S^\\star) - \\Delta$。\n- **距离**：$d(S_1, S_2) = |(S_1 \\setminus S_2) \\cup (S_2 \\setminus S_1)| = |S_1| + |S_2| - 2|S_1 \\cap S_2|$。\n- **目标**：在所有有效的次优结构 $S$ 中，最大化 $d(S, S^\\star)$。如果不存在这样的次优结构，则返回 -1。\n\n### 第 2 步：验证与解决方案规划\n问题定义明确，在科学上是合理的。它结合了 MFE 预测和次优结构分析，这是 RNA 生物信息学中的一个重要概念。解决方案需要一个多阶段的动态规划方法。\n\n1.  **找到 MFE 结构 $S^\\star$**：这可以通过修改 Nussinov 算法来实现。我们需要一个 DP 表，`dp_mfe[i, j]`，它存储子序列 `s[i...j]` 的 MFE 结构（即最大配对数和字典序最小的配对列表）。递推关系将比较一个碱基未配对的情况与它与所有可能伙伴配对的情况，并根据问题中的决胜规则选择最佳结构。\n\n2.  **确定次优配对数范围**：设 $b_{max} = |S^\\star|$。次优结构的配对数 $k$ 必须满足 $b_{max} > k \\ge b_{max} - \\Delta$。我们确定所有满足此条件的整数 $k$。如果没有这样的 $k$，则不存在次优结构，答案为 -1。\n\n3.  **计算最大距离**：对于每个有效的 $k$，我们需要找到一个具有 $k$ 个配对的结构 $S_k$，它最大化 $d(S_k, S^\\star)$。因为 $d(S_k, S^\\star) = k + b_{max} - 2|S_k \\cap S^\\star|$，而 $k$ 和 $b_{max}$ 是固定的，所以最大化距离等同于最小化交集大小 $|S_k \\cap S^\\star|$。\n    - 我们可以使用另一个 DP 来解决这个问题。设 `dp_overlap[i, j, p]` 为在子序列 `s[i...j]` 中形成一个具有 $p$ 个配对的有效结构的最小可能交集大小（与 $S^\\star$ 的相应子集）。\n    - 递推关系将考虑所有形成 $p$ 个配对的方式（分叉或闭合配对），并跟踪与 $S^\\star$ 的重叠。对于一个新形成的配对 $(i,j)$，如果它也在 $S^\\star$ 中，则重叠增加 1。\n    - DP 状态：`dp_overlap[i, j, p]` = 在子序列 $s_i..s_j$ 中形成 $p$ 个配对的结构与 $S^\\star$ 的最小重叠。\n    - 递推：\n      - **未配对**：$j$ 未配对。最小重叠来自子序列 $s_i..s_{j-1}$ 的 $p$ 配对结构：`dp_overlap[i, j-1, p]`。\n      - **配对**：$j$ 与 $k$ 配对。对于所有可能的 $k$ 和所有可能的配对数分割 $p_1 + p_2 = p-1$，`cost(k,j) + dp_overlap[i, k-1, p_1] + dp_overlap[k+1, j-1, p_2]`，其中 `cost(k,j)` 是 1（如果 $(k,j) \\in S^\\star$）或 0（如果不在）。\n      - `dp_overlap[i, j, p]` 是这些选项中的最小值。\n\n4.  **最终计算**：对于每个在范围内的 $k$，我们计算 $m_k = \\text{dp\\_overlap}[0, n-1, k]$。如果 $m_k$ 不是无穷大（意味着可以形成一个有 $k$ 个配对的结构），我们计算距离 $d_k = k + b_{max} - 2m_k$。最终答案是所有有效 $d_k$ 中的最大值。如果所有 $m_k$ 都是无穷大，则返回 -1。",
            "answer": "```python\nimport numpy as np\n\ndef _is_canonical_pair(base1, base2):\n    \"\"\"Checks if two bases form a canonical or wobble pair.\"\"\"\n    return (base1, base2) in {('A', 'U'), ('U', 'A'), ('G', 'C'), ('C', 'G'), ('G', 'U'), ('U', 'G')}\n\ndef _compare_mfe_structures(s1, s2):\n    \"\"\"\n    Compares two MFE candidate structures: (num_pairs, pair_list).\n    Returns the better one (more pairs, then lexicographically smaller list).\n    \"\"\"\n    p1, l1 = s1\n    p2, l2 = s2\n    if p1 > p2:\n        return s1\n    if p2 > p1:\n        return s2\n    # If same number of pairs, compare pair lists lexicographically\n    if l1  l2:\n        return s1\n    else:\n        return s2\n\ndef _solve_single_case(sequence, L, delta):\n    \"\"\"Solves the problem for a single test case.\"\"\"\n    n = len(sequence)\n\n    # --- Step 1: Find the MFE structure S* with tie-breaking ---\n    # dp_mfe[(i, j)] stores tuple (max_pairs, pair_list) for substring sequence[i:j+1]\n    dp_mfe = {}\n\n    for length in range(1, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if i >= j:\n                dp_mfe[(i, j)] = (0, [])\n                continue\n            \n            # Option 1: j is unpaired. The best structure is that of sequence[i:j].\n            best_struct = dp_mfe[(i, j - 1)]\n            \n            # Option 2: j is paired with some k in [i, j-1].\n            # This recurrence is for a structure composed of disjoint substructures.\n            for k in range(i, j):\n                if _is_canonical_pair(sequence[k], sequence[j]) and j - k - 1 >= L:\n                    # The structure is formed by the pair (k,j) and substructures\n                    # before and inside the pair.\n                    s_before = dp_mfe.get((i, k - 1), (0, []))\n                    s_inside = dp_mfe.get((k + 1, j - 1), (0, []))\n                    \n                    num_pairs = s_before[0] + 1 + s_inside[0]\n                    pair_list = sorted(s_before[1] + [(k, j)] + s_inside[1])\n                    \n                    candidate_struct = (num_pairs, pair_list)\n                    best_struct = _compare_mfe_structures(best_struct, candidate_struct)\n            \n            dp_mfe[(i, j)] = best_struct\n\n    b_max, s_star_list = dp_mfe.get((0, n - 1), (0, []))\n    s_star_set = set(s_star_list)\n\n    # --- Step 2: Determine range of pairs k for suboptimal structures ---\n    # `b_max > B(S) >= b_max - delta`\n    k_min_bound = b_max - delta\n    k_max_bound = b_max - 1\n\n    if k_max_bound  0:\n        return -1\n        \n    k_range = [k for k in range(int(np.ceil(k_min_bound)), int(np.floor(k_max_bound)) + 1) if k >= 0]\n    if not k_range:\n        return -1\n\n    # --- Step 3: DP to find min overlap with S* for structures of size p ---\n    max_p_total = n // 2\n    dp_overlap = np.full((n, n, max_p_total + 1), np.inf)\n\n    # Base cases: zero pairs have zero overlap\n    for i in range(n):\n        for j in range(i - 1, n):\n            dp_overlap[i, j, 0] = 0\n\n    for length in range(1, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if i >= j:\n                continue\n\n            max_p_sub = (j - i + 1) // 2\n            for p in range(1, max_p_sub + 1):\n                min_ov = dp_overlap[i, j - 1, p]\n\n                for k in range(i, j):\n                    if _is_canonical_pair(sequence[k], sequence[j]) and j - k - 1 >= L:\n                        pair_cost = 1 if (k, j) in s_star_set else 0\n                        \n                        max_p_before = (k - i) // 2 if k > i else 0\n                        max_p_inside = (j-1 - (k+1) + 1)//2 if k+1 = j-1 else 0\n\n                        for p_before in range(min(p, max_p_before + 1)):\n                            p_inside = p - 1 - p_before\n                            if 0 = p_inside = max_p_inside:\n                                ov_before = dp_overlap[i, k-1, p_before] if i = k-1 else 0\n                                ov_inside = dp_overlap[k+1, j-1, p_inside] if k+1 = j-1 else 0\n                                \n                                if np.isfinite(ov_before) and np.isfinite(ov_inside):\n                                    current_ov = ov_before + pair_cost + ov_inside\n                                    min_ov = min(min_ov, current_ov)\n                dp_overlap[i, j, p] = min_ov\n\n    # --- Step 4: Calculate max distance ---\n    max_dist = -1\n    for k in k_range:\n        m_k = dp_overlap[0, n-1, k] if n > 0 else 0\n        if np.isfinite(m_k):\n            # d(S, S*) = |S| + |S*| - 2*|S intersect S*|\n            dist = k + b_max - 2 * m_k\n            if dist > max_dist:\n                max_dist = dist\n    \n    return int(max_dist)\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    test_cases = [\n        (\"GCAUCUAUGC\", 3, 2),\n        (\"AAAAAA\", 3, 3),\n        (\"GCGC\", 0, 1),\n        (\"AUGCUA\", 2, 0),\n    ]\n\n    results = []\n    for sequence, L, delta in test_cases:\n        result = _solve_single_case(sequence, L, delta)\n        results.append(result)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}