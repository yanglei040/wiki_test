{
    "hands_on_practices": [
        {
            "introduction": "The foundational algorithms for RNA secondary structure prediction often focus on maximizing the sheer number of base pairs. However, from a biophysical standpoint, not all pairs are created equal. This practice introduces a crucial refinement by asking you to maximize only the number of Guanine-Cytosine (G-C) pairs, which are significantly more stable than Adenine-Uracil (A-U) pairs. This exercise  serves as an excellent introduction to energy-based scoring, requiring a simple but insightful modification to the classic dynamic programming recurrence.",
            "id": "2426841",
            "problem": "You are given an idealized model of ribonucleic acid (RNA) secondary structure as a set of base pairs on a single-stranded sequence over the alphabet {A, U, G, C}. A secondary structure on a sequence of length $n$ is a set $M$ of ordered index pairs $(i,j)$ with $0 \\le i  j \\le n-1$ satisfying the following validity constraints: (1) each index appears in at most one pair, (2) only canonical pairs are allowed, where the allowed base pairs are A–U, U–A, G–C, C–G, G–U, and U–G, and (3) there are no pseudoknots, meaning that if $(i,j) \\in M$ and $(k,\\ell) \\in M$, then it is not the case that $i  k  j  \\ell$. Additionally, a minimum hairpin loop length constraint is enforced: for each pair $(i,j) \\in M$, the number of unpaired nucleotides enclosed by the pair must be at least $L$, that is $j - i - 1 \\ge L$, where $L$ is a given nonnegative integer.\n\nDefine the guanine-cytosine content objective as follows. For a given valid structure $M$, its guanine-cytosine score is\n$$\n\\operatorname{GC}(M) \\;=\\; \\sum_{(i,j)\\in M} \\mathbf{1}\\big(\\{s_i,s_j\\}=\\{\\mathrm{G},\\mathrm{C}\\}\\big),\n$$\nwhere $s_i$ is the nucleotide at position $i$, and $\\mathbf{1}(\\cdot)$ is the indicator that counts $1$ if the pair is a guanine–cytosine pair (G–C or C–G) and counts $0$ otherwise. Your task is to compute, for each test case, the maximum possible value of $\\operatorname{GC}(M)$ over all valid structures $M$ that satisfy the constraints above for the given sequence and the specified minimum hairpin loop length $L$.\n\nYour program must use the fixed test suite below. For each test case, the input is a pair consisting of a sequence and a value of $L$. For each test case, the output must be a single integer equal to the maximum achievable value of $\\operatorname{GC}(M)$ under the rules above.\n\nTest suite:\n- Sequence \"GGGCCC\", with minimum hairpin loop length $L=0$.\n- Sequence \"AAAA\", with minimum hairpin loop length $L=0$.\n- Sequence \"GCAUCG\", with minimum hairpin loop length $L=3$.\n- Sequence \"GUGU\", with minimum hairpin loop length $L=0$.\n- Sequence \"\", with minimum hairpin loop length $L=0$.\n- Sequence \"CGCG\", with minimum hairpin loop length $L=0$.\n\nFinal output format: Your program should produce a single line of output containing the results, in order, as a comma-separated list enclosed in square brackets (for example, \"[x_1,x_2,\\dots,x_6]\"), where each $x_i$ is the integer maximum $\\operatorname{GC}(M)$ for the $i$-th test case in the test suite.",
            "solution": "The problem presented is a constrained optimization problem centered on the prediction of RNA secondary structure, a classic subject in computational biology. The task is to find a valid secondary structure that maximizes the number of Guanine-Cytosine (G-C) pairs. The prohibition of pseudoknots is a critical constraint that renders the problem solvable by dynamic programming, as it ensures that the structure can be decomposed hierarchically.\n\nLet the given RNA sequence be $s$, with length $n$, indexed from $0$ to $n-1$. We define $E(i, j)$ as the maximum possible G-C score for the subsequence $s_i, s_{i+1}, \\dots, s_j$. The objective is to compute $E(0, n-1)$.\n\nThe solution is built upon the principle of optimality: an optimal structure for a sequence is composed of optimal structures for its sub-sequences. We construct a recurrence relation for $E(i, j)$ by considering all valid structural configurations of the subsequence $s_i \\dots s_j$. Any such structure is determined by the status of the base at index $j$.\n\nThere are two fundamental cases for the base $s_j$:\n\n1.  **The base $s_j$ is unpaired.** In this case, $s_j$ does not form a pair and contributes nothing to the G-C score. The problem of optimizing the structure on $s_i \\dots s_j$ reduces to finding the optimal structure for the shorter subsequence $s_i \\dots s_{j-1}$. The score is therefore given by $E(i, j-1)$.\n\n2.  **The base $s_j$ is paired with a base $s_k$, where $i \\le k  j$.** The formation of a pair $(k, j)$ is subject to two primary constraints defined in the problem:\n    -   **Canonical Pairing**: The pair of nucleotides $(s_k, s_j)$ must be one of the allowed canonical pairs: A–U, U–A, G–C, C–G, G–U, or U–G.\n    -   **Minimum Hairpin Loop Length**: The number of nucleotides enclosed by the pair must be at least $L$, which translates to the condition $j - k - 1 \\ge L$.\n\nIf a pair $(k, j)$ satisfies these conditions, its formation has a local and global impact. Locally, it contributes to the total score. The contribution is $1$ if $\\{s_k, s_j\\} = \\{\\text{G}, \\text{C}\\}$, and $0$ for other allowed canonical pairs (A-U, G-U, and their reverse complements). Globally, the no-pseudoknot rule dictates that the pair $(k, j)$ partitions the sequence $s_i \\dots s_j$ into two independent sub-regions that can be optimized separately: the region preceding the pair, $s_i \\dots s_{k-1}$, and the region enclosed by the pair, $s_{k+1} \\dots s_{j-1}$. The total score for this specific configuration is the sum of the optimal scores from these two independent sub-problems plus the score contribution from the pair $(k, j)$ itself.\n\nBy combining these cases and maximizing over all possibilities, we arrive at the following recurrence relation:\n$$\nE(i, j) = \\max \\left( E(i, j-1), \\quad \\max_{ \\substack{i \\le k  j \\\\ (k,j) \\text{ is valid}} } \\left\\{ E(i, k-1) + E(k+1, j-1) + \\mathbf{1}(\\{s_k,s_j\\}=\\{\\mathrm{G},\\mathrm{C}\\}) \\right\\} \\right)\n$$\nHere, $\\mathbf{1}(\\cdot)$ is the indicator function, which evaluates to $1$ if its argument is true and $0$ otherwise. The term \"valid\" for the pair $(k,j)$ encompasses both the canonical pairing rule and the minimum loop length constraint.\n\nThe base cases for the recursion are subsequences that are too short to form any valid pairs. For any $i, j$ such that the subsequence length $j-i+1$ is less than $L+2$, it is impossible to form a hairpin loop satisfying the minimum length $L$. Thus, for such subsequences, $E(i, j) = 0$. We also define $E(i, j) = 0$ for any $i > j$, corresponding to an empty subsequence.\n\nThis recurrence is implemented algorithmically by populating a two-dimensional array, let's call it $\\texttt{dp}[i][j]$, which stores the computed values of $E(i, j)$. The computation proceeds by iterating over increasing subsequence lengths $d = j-i$, from $d=1$ up to $d=n-1$. For each length $d$, we iterate through all possible starting positions $i$ from $0$ to $n-1-d$. The final solution to the problem is the value stored in $\\texttt{dp}[0][n-1]$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the RNA secondary structure problem for a fixed test suite.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\"GGGCCC\", 0),\n        (\"AAAA\", 0),\n        (\"GCAUCG\", 3),\n        (\"GUGU\", 0),\n        (\"\", 0),\n        (\"CGCG\", 0),\n    ]\n\n    results = []\n    for sequence, L in test_cases:\n        result = compute_max_gc_pairs(sequence, L)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_max_gc_pairs(sequence: str, L: int) -> int:\n    \"\"\"\n    Computes the maximum number of G-C pairs in a valid RNA secondary structure.\n\n    This function uses dynamic programming to solve the problem. The state E(i, j)\n    represents the maximum G-C score for the subsequence from index i to j.\n\n    Args:\n        sequence: The RNA sequence string.\n        L: The minimum hairpin loop length.\n\n    Returns:\n        The maximum number of G-C pairs.\n    \"\"\"\n    n = len(sequence)\n    if n  L + 2:\n        return 0\n\n    # Initialize a DP table to store the max scores for subsequences.\n    # dp[i][j] will store the max GC score for sequence[i:j+1]\n    dp = np.zeros((n, n), dtype=int)\n\n    canonical_pairs = {('A', 'U'), ('U', 'A'), ('G', 'C'), ('C', 'G'), ('G', 'U'), ('U', 'G')}\n\n    def is_canonical(b1: str, b2: str) -> bool:\n        return (b1, b2) in canonical_pairs\n\n    def gc_score(b1: str, b2: str) -> int:\n        return 1 if (b1 == 'G' and b2 == 'C') or (b1 == 'C' and b2 == 'G') else 0\n\n    # Iterate over subsequence length d (from 1 to n-1)\n    for d in range(1, n):\n        # Iterate over start index i\n        for i in range(n - d):\n            j = i + d\n\n            # Case 1: j is unpaired. The score is the same as the subsequence s_i...s_{j-1}.\n            score_unpaired = dp[i, j - 1]\n\n            # Case 2: j is paired with some k. We must maximize over all possible k.\n            max_score_j_paired = 0\n            # k must satisfy i = k  j and the loop length constraint j - k - 1 >= L.\n            # This implies k = j - L - 1.\n            for k in range(i, j - L):\n                if is_canonical(sequence[k], sequence[j]):\n                    # Score from the pair (k, j) itself.\n                    pair_score = gc_score(sequence[k], sequence[j])\n                    \n                    # Score from the structure on the subsequence before k.\n                    score_before = dp[i, k - 1] if k > i else 0\n                    \n                    # Score from the structure on the subsequence inside (k, j).\n                    score_inside = dp[k + 1, j - 1] if k + 1 = j - 1 else 0\n                    \n                    current_total_score = score_before + pair_score + score_inside\n                    if current_total_score > max_score_j_paired:\n                        max_score_j_paired = current_total_score\n\n            # The final score for dp[i, j] is the maximum of the unpaired and paired cases.\n            dp[i, j] = max(score_unpaired, max_score_j_paired)\n            \n    return dp[0, n - 1] if n > 0 else 0\n\nsolve()\n```"
        },
        {
            "introduction": "Realistic energy models for RNA folding account for more than just individual pairs; they consider interactions between adjacent pairs. A key principle is that \"stacked pairs,\" which form helical structures, are much more stable than isolated or \"lonely\" pairs. This exercise  challenges you to implement this biophysical rule by designing an algorithm that explicitly forbids lonely pairs, ensuring every pair is part of a helix. Solving this requires moving beyond the basic Nussinov framework to a more sophisticated dynamic programming approach, a critical step towards understanding modern folding algorithms.",
            "id": "2426853",
            "problem": "You are given finite sequences over the alphabet {A, C, G, U} representing Ribonucleic Acid (RNA). For a sequence $s = s_1 s_2 \\dots s_n$ of length $n$, a secondary structure is a set of ordered pairs of indices $\\{(i,j)\\}$ with $1 \\le i  j \\le n$ such that:\n- Each index appears in at most one pair.\n- The structure is pseudoknot-free (noncrossing): for any two pairs $(i,j)$ and $(k,\\ell)$ with $i  k$, either $j  k$ or $\\ell  j$.\n- Base pairing follows canonical rules: allowed base pairs are $\\{ \\text{A-U}, \\text{U-A}, \\text{G-C}, \\text{C-G}, \\text{G-U}, \\text{U-G} \\}$.\n- No lonely pairs are allowed: for every pair $(i,j)$ in the structure, at least one of $(i+1, j-1)$ or $(i-1, j+1)$ is also in the structure, provided the indices are within $[1,n]$. In other words, every paired nucleotide must be part of a helix of length at least $2$ (stacked with an adjacent pair on at least one side).\n\nNo minimum hairpin loop length constraint is imposed in this problem, and there are no physical units. For each input sequence, the goal is to compute the maximum possible number of base pairs (an integer) among all secondary structures satisfying the above constraints.\n\nTest suite:\n- Case $1$: $s = \\text{\"AU\"}$\n- Case $2$: $s = \\text{\"AUAU\"}$\n- Case $3$: $s = \\text{\"GGGAAACCC\"}$\n- Case $4$: $s = \\text{\"GCAU\"}$\n- Case $5$: $s = \\text{\"AUAUCCCCAUAU\"}$\n- Case $6$: $s = \\text{\"AGCU\"}$\n\nYour program must compute, for each case, the maximum number of base pairs under the stated constraints and output the results as a single line containing a comma-separated list of the six integers in order, enclosed in square brackets, with no spaces. For example, the format must be exactly like $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5,\\text{result}_6]$.",
            "solution": "The problem is to find the maximum number of base pairs in a pseudoknot-free RNA secondary structure, with the additional constraint that lonely pairs are forbidden. This \"no lonely pairs\" rule means that every base pair must be part of a stack (helix) of length at least two. This constraint is key and requires a modification of the standard Nussinov algorithm. A dynamic programming approach is well-suited for this problem due to the non-crossing nature of the structures.\n\nThe core idea is to build optimal structures from optimal substructures. However, instead of considering single pairs, we must consider helices as the fundamental building blocks. We can define two coupled dynamic programming tables:\n1.  `M[i, j]`: The maximum number of base pairs in a valid structure for the subsequence `s[i...j]`.\n2.  `H[i, j]`: The length of the longest possible helix that can be formed starting with an outer pair `(i, j)` and extending inwards.\n\nFirst, we can pre-compute the helix table `H`. A helix can start at `(i, j)` only if `s[i]` and `s[j]` can pair. If they can, the length of the helix is one plus the length of the helix starting at `(i+1, j-1)`. This gives the recurrence:\n$$\nH[i, j] = \\begin{cases} 1 + H[i+1, j-1]  \\text{if } (s_i, s_j) \\text{ can pair} \\\\ 0  \\text{otherwise} \\end{cases}\n$$\nThis table can be filled for subsequences of increasing length.\n\nWith the `H` table, we can compute the main `M` table. For a subsequence `s[i...j]`, an optimal structure can arise in two ways:\n\n1.  **Bifurcation**: The structure is composed of two independent, adjacent substructures on `s[i...k]` and `s[k+1...j]` for some split point `k`. The total number of pairs is the sum of the pairs from the optimal solutions for these two subproblems, `M[i, k] + M[k+1, j]`. We must take the maximum over all possible split points `k` from `i` to `j-1`.\n\n2.  **Enclosing Helix**: The entire structure is enclosed by a helix starting at `(i, j)`. Due to the 'no lonely pairs' rule, this helix must have a length `p` of at least 2. If a helix of length `p` closes the structure, it contributes `p` pairs. The remaining inner subsequence, `s[i+p...j-p]`, can then form its own optimal structure, contributing `M[i+p, j-p]` pairs. We must consider all possible helix lengths `p` from 2 up to the maximum possible length `H[i, j]`.\n\nCombining these two cases gives the final recurrence for `M[i, j]`:\n$$\nM[i, j] = \\max \\left( \\max_{i \\le k  j} (M[i, k] + M[k+1, j]), \\quad \\max_{p=2, \\dots, H[i, j]} (p + M[i+p, j-p]) \\right)\n$$\nIf no helix of length $\\ge 2$ can be formed starting at `(i, j)`, the second term is considered to be 0. The base cases for the recurrence are `M[i, j] = 0` for subsequences too short to form a valid structure (length less than 4, as a helix of length 2 needs 4 bases). The algorithm proceeds by filling the `M` table for subsequences of increasing length. The final answer is `M[0, n-1]`.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the RNA secondary structure problem for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        \"AU\",\n        \"AUAU\",\n        \"GGGAAACCC\",\n        \"GCAU\",\n        \"AUAUCCCCAUAU\",\n        \"AGCU\",\n    ]\n\n    results = []\n    for s in test_cases:\n        result = compute_max_pairs(s)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_max_pairs(s: str) -> int:\n    \"\"\"\n    Computes the maximum number of base pairs in an RNA sequence\n    under the constraints of being pseudoknot-free and having no lonely pairs.\n\n    This is achieved using dynamic programming. Two tables are used:\n    - H[i, j]: Stores the length of the longest helix starting with a pair (i, j).\n    - M[i, j]: Stores the maximum number of pairs in the subsequence s[i...j].\n\n    The recurrence for M[i, j] considers two cases for the structure on s[i...j]:\n    1. A bifurcation into two independent adjacent substructures.\n    2. An enclosing helix of length p >= 2.\n    \"\"\"\n    n = len(s)\n    if n  4:  # A helix of length 2 requires at least 4 nucleotides.\n        return 0\n\n    allowed_pairs = {('A', 'U'), ('U', 'A'), ('G', 'C'), ('C', 'G'), ('G', 'U'), ('U', 'G')}\n\n    def can_pair(i, j):\n        if i  0 or j >= n or i >= j:\n            return False\n        return (s[i], s[j]) in allowed_pairs\n\n    # H[i,j]: length of the longest helix starting with pair (i,j)\n    H = np.zeros((n, n), dtype=int)\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if can_pair(i, j):\n                if length == 2:\n                    H[i, j] = 1\n                else:\n                    H[i, j] = 1 + H[i + 1, j - 1]\n\n    # M[i,j]: maximum number of pairs in subsequence s[i...j]\n    M = np.zeros((n, n), dtype=int)\n    # The loop must start from a length where a valid structure can form.\n    # The smallest valid structure is a helix of length 2 which spans 4 bases.\n    for length in range(4, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n\n            # Case 1: Bifurcation. Structure on s[i...j] is a concatenation\n            # of structures on s[i...k] and s[k+1...j].\n            bifurcation_max = 0\n            for k in range(i, j):\n                bifurcation_max = max(bifurcation_max, M[i, k] + M[k + 1, j])\n\n            # Case 2: Closing helix. Structure on s[i...j] is enclosed\n            # by a helix of length p >= 2.\n            helix_max = 0\n            helix_len = H[i, j]\n            if helix_len >= 2:\n                for p in range(2, helix_len + 1):\n                    # Check if the helix fits within the [i,j] interval.\n                    # The inner loop indices must be valid.\n                    if (i + p - 1)  (j - p + 1):\n                        current_helix_pairs = p\n                        inner_pairs = 0\n                        # Calculate pairs in the loop enclosed by the helix\n                        if i + p = j - p:\n                             inner_pairs = M[i + p, j - p]\n                        \n                        helix_max = max(helix_max, current_helix_pairs + inner_pairs)\n\n            M[i, j] = max(bifurcation_max, helix_max)\n\n    return int(M[0, n - 1])\n\nsolve()\n```"
        },
        {
            "introduction": "Bioinformatics problems often involve balancing multiple, sometimes competing, objectives. This practice explores this common scenario by posing a constrained optimization problem: maximize the count of A-U pairs, but only for structures that meet a minimum threshold for the *total* number of base pairs. This task  will teach you how to expand the state of your dynamic programming table to track multiple values simultaneously, allowing you to find the optimal solution within a constrained landscape. This powerful technique is widely applicable to many complex optimization problems in computational biology.",
            "id": "2426844",
            "problem": "You are given a ribonucleic acid (RNA) nucleotide string $s$ over the alphabet $\\{ \\text{A}, \\text{U}, \\text{G}, \\text{C} \\}$ with length $n$, indexed from positions $1$ to $n$. A secondary structure on $s$ is a set $S$ of ordered index pairs $(i,j)$ with $1 \\le i  j \\le n$ such that the following conditions hold:\n- Base-pairing rule: A pair $(i,j) \\in S$ is permitted if and only if $(s[i], s[j]) \\in \\{(\\text{A},\\text{U}),(\\text{U},\\text{A}),(\\text{G},\\text{C}),(\\text{C},\\text{G})\\}$.\n- Pseudoknot-free (noncrossing) constraint: If $(i,j),(k,\\ell) \\in S$ with $ij$ and $k\\ell$, then configurations with $ikj\\ell$ are forbidden.\n- Minimum hairpin loop length constraint: For every $(i,j) \\in S$, it must hold that $j-i-1 \\ge L$, where $L$ is a given nonnegative integer.\n\nFor any secondary structure $S$, define the total number of base pairs as $|S|$, and define the count of adenine-uracil pairs as\n$$\n\\#\\text{AU}(S) = \\left| \\{ (i,j) \\in S \\,:\\, (s[i],s[j]) \\in \\{(\\text{A},\\text{U}),(\\text{U},\\text{A})\\} \\} \\right|.\n$$\nFor given inputs $(s,M,L)$, define the objective\n$$\nF(s,M,L) = \n\\begin{cases}\n\\max\\limits_{S} \\#\\text{AU}(S)  \\text{subject to } S \\text{ satisfying all constraints above and } |S| \\ge M,\\\\\n-1  \\text{if no such } S \\text{ exists.}\n\\end{cases}\n$$\n\nYour task is to implement a program that, for a given test suite of $(s,M,L)$ inputs specified below, computes $F(s,M,L)$ for each case. If no structure $S$ satisfies $|S| \\ge M$, the required output for that case is $-1$. All intermediate reasoning is internal to your program; you must only output the final results as integers on a single line as specified at the end of this problem. No physical units are involved.\n\nTest suite to evaluate:\n- Case $1$: $s=\\text{\"AUGCAU\"}$, $M=2$, $L=0$.\n- Case $2$: $s=\\text{\"AUAU\"}$, $M=2$, $L=0$.\n- Case $3$: $s=\\text{\"GGCC\"}$, $M=2$, $L=0$.\n- Case $4$: $s=\\text{\"AAAA\"}$, $M=1$, $L=0$.\n- Case $5$: $s=\\text{\"AUGUA\"}$, $M=1$, $L=2$.\n- Case $6$: $s=\\text{\"AGCU\"}$, $M=0$, $L=0$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\dots]$) in the same order as the cases above. Each $\\text{result}_k$ must be an integer. If a case is infeasible under the constraints, the corresponding entry must be $-1$.",
            "solution": "The problem presented is a variant of the classical ribonucleic acid (RNA) secondary structure prediction problem. It asks for the maximum number of adenine-uracil (AU) pairs in a valid, non-crossing secondary structure, subject to a minimum total number of base pairs and a minimum loop length. The non-crossing (or pseudoknot-free) constraint is the critical feature that allows for an efficient solution using dynamic programming. The structure of the problem, where an optimal solution for a sequence can be constructed from optimal solutions of its subsequences, is a hallmark of problems amenable to this technique.\n\nWe shall formulate a dynamic programming algorithm to solve this problem. Let the input RNA sequence be $s$ of length $n$. For implementation convenience, we will use $0$-based indexing, so the sequence is $s[0..n-1]$.\n\nThe state of our dynamic program, $DP(i, j)$, must encapsulate all necessary information about optimal structures for the subsequence $s[i..j]$. Since the objective is to maximize AU pairs for a given constraint on the total number of pairs, $DP(i, j)$ cannot be a single value. Instead, we define $DP(i, j)$ as a dictionary (or map) where keys represent the total number of base pairs, $c$, and values represent the maximum number of AU pairs achievable with exactly $c$ pairs in a valid structure on $s[i..j]$.\n$DP(i, j)[c] = \\max \\{\\#\\text{AU}(S) \\mid S \\text{ is a valid structure on } s[i..j] \\text{ with } |S|=c\\}$.\nIf no structure with $c$ pairs exists, this entry will not be in the dictionary.\n\nThe DP table will be a two-dimensional array of such dictionaries, indexed by the start $i$ and end $j$ of the subsequence. We compute the entries for $DP(i, j)$ for all $0 \\le i \\le j  n$, proceeding in order of increasing subsequence length, $d = j-i$.\n\n**Base Cases:**\nFor a subsequence of length $0$ (e.g., $s[i..i-1]$) or length $1$ (e.g., $s[i..i]$), no base pairs can be formed. Thus, the only possible structure is the empty one, with $0$ pairs and $0$ AU pairs.\nFor any $i$, the solution for an empty subsequence (e.g., from index $i$ to $i-1$) is $DP_{\\text{empty}} = \\{0: 0\\}$.\nFor a subsequence of length $1$, $s[i..i]$, we have $DP(i, i) = \\{0: 0\\}$.\n\n**Recurrence Relation:**\nTo compute $DP(i, j)$ for a subsequence $s[i..j]$ of length $d+1 > 1$, we consider the status of the base at the end of the interval, $s[j]$. There are two exclusive possibilities:\n\n1.  **$s[j]$ is unpaired:** If $s[j]$ does not form a pair, any optimal structure on $s[i..j]$ is simply an optimal structure on the shorter subsequence $s[i..j-1]$. Therefore, we initialize the solutions for $s[i..j]$ with those for $s[i..j-1]$:\n    $DP(i, j) = DP(i, j-1)$.\n\n2.  **$s[j]$ is paired with $s[k]$ for some $i \\le k  j$:** Due to the non-crossing constraint, a pair $(k, j)$ divides the problem into two independent subproblems: one on the subsequence to the left of the pair, $s[i..k-1]$, and one on the subsequence enclosed by the pair, $s[k+1..j-1]$.\n    A pair $(k, j)$ is only allowed if it satisfies the base-pairing rule and the minimum loop length constraint, which dictates that the number of enclosed bases, $j-k-1$, must be at least $L$. That is, $j-k-1 \\ge L$, or $k \\le j-L-1$.\n\n    For each valid $k$, we combine the solutions from the two subproblems. Let $S_L$ be a structure on $s[i..k-1]$ with $c_L$ pairs and $au_L$ AU pairs, and $S_I$ be a structure on $s[k+1..j-1]$ with $c_I$ pairs and $au_I$ AU pairs. Combining them with the new pair $(k, j)$ yields a new structure on $s[i..j]$ with a total of $c = c_L + c_I + 1$ pairs. The number of AU pairs will be $au = au_L + au_I + \\delta$, where $\\delta = 1$ if $(s[k], s[j])$ is an AU or UA pair, and $\\delta = 0$ otherwise.\n\n    We must consider all possible combinations of structures from the subproblems. For each valid $k$, we update $DP(i, j)$ as follows:\n    For each pair count $c_L$ in $DP(i, k-1)$ and $c_I$ in $DP(k+1, j-1)$:\n    Let $c_{\\text{new}} = c_L + c_I + 1$.\n    Let $au_{\\text{new}} = DP(i, k-1)[c_L] + DP(k+1, j-1)[c_I] + \\delta$.\n    We then update the dictionary for the current subproblem:\n    $DP(i, j)[c_{\\text{new}}] = \\max(DP(i, j).get(c_{\\text{new}}, -1), au_{\\text{new}})$.\n    The base cases for these subproblems (empty subsequences) are handled by using the solution $\\{0: 0\\}$.\n\nThe algorithm proceeds by iterating through subsequence lengths $d$ from $1$ to $n-1$, and for each length, through all possible start positions $i$. After filling the entire table, the dictionary $DP(0, n-1)$ contains the solutions for the full RNA sequence.\n\n**Final Result Computation:**\nThe problem asks for $F(s, M, L) = \\max \\#\\text{AU}(S)$ subject to $|S| \\ge M$. Using the computed $DP(0, n-1)$, we can find this value. We iterate through all total pair counts $c$ present as keys in $DP(0, n-1)$. If $c \\ge M$, the corresponding value $DP(0, n-1)[c]$ is a candidate for our maximum. We take the maximum over all such valid candidates. If no key $c \\ge M$ exists in the dictionary, it means no structure satisfies the constraint, and the answer is $-1$, as per the problem definition.\n\nThe overall time complexity of this algorithm is $O(n^5)$, arising from three nested loops for the DP state $(i, j, k)$ and two nested loops for combining subproblem solutions, where the size of the dictionaries is at most $O(n)$. Given the small values of $n$ in the test suite, this is computationally feasible.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n    test_cases = [\n        (\"AUGCAU\", 2, 0),\n        (\"AUAU\", 2, 0),\n        (\"GGCC\", 2, 0),\n        (\"AAAA\", 1, 0),\n        (\"AUGUA\", 1, 2),\n        (\"AGCU\", 0, 0),\n    ]\n\n    results = []\n    for s, M, L in test_cases:\n        results.append(solve_case(s, M, L))\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef can_pair(b1, b2):\n    \"\"\"Checks if two bases can form a canonical Watson-Crick pair.\"\"\"\n    pairs = {('A', 'U'), ('U', 'A'), ('G', 'C'), ('C', 'G')}\n    return (b1, b2) in pairs\n\ndef is_au_pair(b1, b2):\n    \"\"\"Checks if a pair is an AU or UA pair.\"\"\"\n    au_pairs = {('A', 'U'), ('U', 'A')}\n    return (b1, b2) in au_pairs\n\ndef solve_case(s, M, L):\n    \"\"\"\n    Computes F(s, M, L) using dynamic programming.\n    \"\"\"\n    n = len(s)\n    \n    # dp[i, j] will store a dictionary mapping {total_pairs -> max_au_pairs}\n    # for the substring s[i..j].\n    dp = np.full((n, n), None, dtype=object)\n\n    # Initialize DP table with empty dictionaries\n    for i in range(n):\n        for j in range(n):\n            dp[i, j] = {}\n\n    # Base cases: Substrings of length 1 (d=0).\n    # A single nucleotide can only form a structure with 0 pairs.\n    for i in range(n):\n        dp[i, i][0] = 0\n\n    # Fill DP table for substrings of increasing length d+1 (from 2 to n).\n    for d in range(1, n):\n        for i in range(n - d):\n            j = i + d\n\n            # Case 1: Base s[j] is unpaired.\n            # Solutions are inherited from the subproblem on s[i...j-1].\n            dp[i, j] = dp[i, j - 1].copy()\n\n            # Case 2: Base s[j] pairs with a base s[k] where i = k  j.\n            # The pair (k, j) must satisfy the minimum loop length constraint:\n            # j - k - 1 >= L  =>  k = j - L - 1.\n            # Python's range(start, stop) goes up to stop-1.\n            for k in range(i, j - L):\n                if can_pair(s[k], s[j]):\n                    au_increment = 1 if is_au_pair(s[k], s[j]) else 0\n                    \n                    # The subproblem on s[i..k-1] (left part).\n                    # If i > k-1, the subsequence is empty, forming 0 pairs.\n                    left_sol = dp[i, k - 1] if i = k - 1 else {0: 0}\n                    \n                    # The subproblem on s[k+1..j-1] (inner part).\n                    # If k+1 > j-1, the subsequence is empty, forming 0 pairs.\n                    inner_sol = dp[k + 1, j - 1] if k + 1 = j - 1 else {0: 0}\n                    \n                    # Combine solutions from subproblems.\n                    for c1, au1 in left_sol.items():\n                        for c2, au2 in inner_sol.items():\n                            total_c = c1 + c2 + 1\n                            total_au = au1 + au2 + au_increment\n                            \n                            # Update DP[i, j] with the max AU count for this total pair count.\n                            current_max_au = dp[i, j].get(total_c, -1)\n                            if total_au > current_max_au:\n                                dp[i, j][total_c] = total_au\n\n    # The solution for the full string is in dp[0, n-1].\n    # An empty structure with 0 pairs is always a possibility.\n    final_solutions = dp[0, n-1] if n > 0 else {}\n    if 0 not in final_solutions:\n        final_solutions[0] = 0\n    \n    # Find the maximum AU pairs among all structures with at least M pairs.\n    max_au = -1\n    found_feasible = False\n    for total_c, total_au in final_solutions.items():\n        if total_c >= M:\n            found_feasible = True\n            if total_au > max_au:\n                max_au = total_au\n    \n    return max_au\n\nif __name__ == \"__main__\":\n    solve()\n\n```"
        }
    ]
}