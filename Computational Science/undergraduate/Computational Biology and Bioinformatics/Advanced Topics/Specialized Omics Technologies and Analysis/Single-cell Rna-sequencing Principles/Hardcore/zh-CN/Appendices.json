{
    "hands_on_practices": [
        {
            "introduction": "单细胞RNA测序（scRNA-seq）数据充满了技术噪音，在揭示生物学见解之前必须进行仔细处理。直接对原始计数数据应用t-SNE等降维算法，其结果可能会产生误导。这项练习是一个思想实验，旨在建立关于为何预处理是分析中最关键步骤的直觉，它揭示了如果不加以校正，测序深度等技术因素会如何完全掩盖生物信号。",
            "id": "2429837",
            "problem": "一项单细胞RNA测序（scRNA-seq）实验产生了一个原始计数矩阵 $X \\in \\mathbb{N}^{G \\times C}$，其中包含 $G$ 个基因和 $C$ 个细胞，每个条目 $X_{gc}$ 是基因 $g$ 在细胞 $c$ 中的唯一分子标识符（UMI）计数。一名学生使用标准的欧几里得度量，直接将t-分布随机邻域嵌入（t-SNE）应用于 $X$ 的列，没有进行任何归一化、转换或特征选择（没有文库大小缩放、没有对数转换、也没有限制于高变异基因）。假设由于批次和捕获效率的差异，细胞的总计数 $n_c = \\sum_{g=1}^{G} X_{gc}$ 表现出显著的变异，并且基因的平均表达量和技术噪音差异很大。\n\n以下哪种描述最准确地预测了最终生成的二维t-SNE嵌入图的定性外观？\n\nA. 两个或更多的宽泛分组，主要按每个细胞的总计数和其他技术协变量（例如，测序深度和线粒体分数）排序，嵌入图中经常出现与 $n_c$ 对应的梯度或条带，存在大量虚假的小亚群，并且生物学亚型分离效果差，大部分相互混合。\n\nB. 清晰、紧凑的聚类，与生物学细胞类型紧密对应，因为t-SNE保留了局部结构，并且对全局尺度差异不敏感；技术变异对嵌入图的影响可以忽略不计。\n\nC. 一个近乎均匀、无定形的点云，点均匀分布，没有可辨别的结构，因为来自未归一化计数的高维噪音在欧几里得距离下被平均掉，并消除了邻域间的差异。\n\nD. 一个晶格状的点网格，按染色体基因顺序排列，因为原始计数保留了空间基因组邻接信息，t-SNE将其投影成一个反映染色体位置的规则模式。\n\nE. 一个完美的环形，其中细胞沿着连续轨迹按生物学伪时间排序，因为即使没有预处理，t-SNE也能保留原始计数空间中存在的全局测地距离。",
            "solution": "首先必须验证问题陈述的科学合理性、清晰度和完整性。\n\n**步骤1：提取已知条件**\n-   数据是一个原始计数矩阵 $X \\in \\mathbb{N}^{G \\times C}$，其中 $G$ 是基因数， $C$ 是细胞数。\n-   $X_{gc}$ 是基因 $g$ 在细胞 $c$ 中的唯一分子标识符（UMI）计数。\n-   t-分布随机邻域嵌入（t-SNE）直接应用于 $X$ 的列。\n-   使用的距离度量是标准欧几里得度量。\n-   未执行任何预处理步骤：没有归一化（如文库大小缩放）、没有转换（如对数转换）、也没有特征选择（如限制于高变异基因）。\n-   由于批次效应和捕获效率等技术因素，每个细胞的总计数 $n_c = \\sum_{g=1}^{G} X_{gc}$ 存在显著变异。\n-   基因的平均表达水平和相关的技术噪音表现出巨大差异。\n\n**步骤2：使用提取的已知条件进行验证**\n问题陈述描述了一个生物信息学中的计算实验。\n-   **科学依据**：该场景完全基于单细胞基因组学的原理。原始UMI计数矩阵、文库大小的技术变异以及应用t-SNE等降维技术都是标准概念。所描述的过程虽然已知不是最优的，但却是从业者可能尝试的真实操作。它没有违反任何基本的科学定律或数学原理。\n-   **适定性**：这个问题是适定的。它明确了输入数据、其性质、确切的计算方法，并要求对输出进行定性预测。基于对scRNA-seq数据分析和t-SNE算法的既有知识，可以确定一个最可能的结果。\n-   **客观性**：问题以客观、技术性的语言陈述。它没有歧义、主观性和非科学性主张。\n\n**步骤3：结论与行动**\n问题陈述是有效的。它科学合理、适定且客观。可以推导出解决方案。\n\n**解决方案的推导**\n\n问题的核心在于理解原始scRNA-seq数据的特性与使用欧几里得距离度量的t-SNE算法行为之间的相互作用。\n\n1.  **t-SNE输入的性质**：t-SNE的运作方式是首先计算所有高维点之间的成对相似性矩阵。在这种情况下，点是细胞（$X$的列），由它们的基因表达向量表示。相似性源自欧几里得距离。两个细胞向量 $c_i$ 和 $c_j$ 之间的欧几里得距离由以下公式给出：\n    $$d(c_i, c_j) = \\sqrt{\\sum_{g=1}^{G} (X_{gi} - X_{gj})^2}$$\n\n2.  **变异的主要来源**：问题陈述指出，细胞间的“总计数 $n_c$ 存在显著变异”。这种通常被称为文库大小的技术伪影意味着，一些细胞在大多数基因上的UMI计数要高得多，仅仅是因为它们的RNA被更有效地捕获和测序。例如，一个文库大小为 $n_{c_1} = 20000$ 的高文库大小细胞 $c_1$，其 $X_{g,c_1}$ 值将系统性地大于一个文库大小为 $n_{c_2} = 2000$ 的低文库大小细胞 $c_2$。\n\n3.  **对欧几里得距离的影响**：在计算欧几里得距离时，平方差 $(X_{gi} - X_{gj})^2$ 将被这个全局缩放因子所主导。两个文库大小差异很大的细胞之间的距离将会很大，无论它们潜在的生物学相似性如何。相反，两个文库大小相似的细胞之间的距离往往会更小。因此，成对欧几里得距离矩阵将主要反映文库大小的相似性，而不是生物学细胞类型的相似性。编码在基因相对表达模式中的生物学信号，被测序深度的技术信号所淹没。\n\n4.  **缺少转换和特征选择的影响**：没有进行对数转换，距离计算会进一步被少数高表达基因所扭曲，这些基因的大计数值对平方差之和的贡献不成比例。使用所有基因而非经过筛选的高变异基因集，会引入大量来自无信息或随机基因表达的技术噪音，进一步掩盖了生物学结构。\n\n5.  **t-SNE的行为**：t-SNE的目标是创建一个低维嵌入，使得在高维空间中相近的点保持相近。由于高维原始计数空间中的“相近性”主要由文库大小和其他强烈的技术因素（如线粒体基因百分比，这是另一个常见的技术协变量）定义，t-SNE将根据这些技术因素在二维嵌入图中排列细胞。最显著的变异来源——文库大小，通常会形成结果图中的主轴或梯度。细胞将按照总计数（$n_c$）从低到高排列。任何真实的生物学分组都将在这个技术梯度上被混淆和混合。高水平的噪音也可能导致形成小的、虚假的聚类，这些是算法和数据的伪影，而非生物学现象。\n\n**选项评估**\n\n**A. 两个或更多的宽泛分组，主要按每个细胞的总计数和其他技术协变量（例如，测序深度和线粒体分数）排序，嵌入图中经常出现与 $n_c$ 对应的梯度或条带，存在大量虚假的小亚群，并且生物学亚型分离效果差，大部分相互混合。**\n这个描述是一个精确且准确的预测。嵌入图将由技术协变量主导，其中文库大小（$n_c$）是主要因素，导致梯度或条带的出现。生物学身份将被掩盖，导致细胞类型相互混合。高噪音和缺乏特征选择的存在使得虚假亚群的形成极有可能。\n**结论：正确。**\n\n**B. 清晰、紧凑的聚类，与生物学细胞类型紧密对应，因为t-SNE保留了局部结构，并且对全局尺度差异不敏感；技术变异对嵌入图的影响可以忽略不计。**\n这是不正确的。这种结果是在进行*适当的*预处理（归一化、转换、特征选择）之后所期望的，这些处理明确地移除了所描述的技术效应。t-SNE对全局尺度差异不敏感的前提在这种情况下是错误的；它所保留的“局部结构”是由输入距离定义的，而这些距离被文库大小的全局尺度因子所主导。技术变异将产生主导性而非可忽略的影响。\n**结论：不正确。**\n\n**C. 一个近乎均匀、无定形的点云，点均匀分布，没有可辨别的结构，因为来自未归一化计数的高维噪音在欧几里得距离下被平均掉，并消除了邻域间的差异。**\n这是不正确的。虽然数据噪音很大，但它并非纯粹随机。文库大小的变异提供了一个强烈的、非随机的结构。这个结构将被欧几里得距离捕获并由t-SNE可视化。结果将是有结构的，但该结构是技术性的，而非生物学性的。它不会是一个无定形的、均匀的点云。\n**结论：不正确。**\n\n**D. 一个晶格状的点网格，按染色体基因顺序排列，因为原始计数保留了空间基因组邻接信息，t-SNE将其投影成一个反映染色体位置的规则模式。**\n这种说法毫无意义。首先，t-SNE是对细胞（列）而不是基因（行）进行的。该分析测量的是细胞之间的距离。其次，标准的基因-细胞计数矩阵并未以一种能通过计算细胞向量间欧几里得距离来检测到的方式编码染色体邻接信息。该选项混淆了分析对象和数据矩阵的信息内容。\n**结论：不正确。**\n\n**E. 一个完美的环形，其中细胞沿着连续轨迹按生物学伪时间排序，因为t-SNE保留了原始计数空间中存在的全局测地距离，即使没有预处理。**\n这是不正确的，原因有多个。首先，众所周知，t-SNE在有效保留全局结构或长程距离方面表现不佳；它经常会割裂连续的轨迹。其次，即使存在生物学轨迹，它也会被文库大小变异产生的更强烈的技术信号完全掩盖。嵌入图将反映技术结构，而非生物学结构。“完美的环形”这一说法是极端的夸大，不是对t-SNE的一般期望。\n**结论：不正确。**",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "理解了预处理的必要性之后，我们来解决一个常见的、重大的技术问题：批次效应（batch effects）。本实践提供了一个具体的计算模型来校正这些效应。通过将批次效应视为一个已知的向量偏移，并使用基于图论的方法，我们可以练习合并被人为分离的细胞簇，这是整合来自不同实验数据的关键技能。",
            "id": "2429786",
            "problem": "您将处理一个形式化的问题：在单细胞RNA测序（scRNA-seq）中，已知的加性批次效应会如何人为地分裂生物学上相同的细胞簇。经过标准化和降维等标准预处理后，假设每个观测到的簇在低维空间中由一个质心向量表示，并且每个批次都会带来一个已知的加性偏移向量。具体来说，假设有 $B$ 个批次，索引为 $b \\in \\{1,\\dots,B\\}$。对于每个批次 $b$，给定一个已知的批次效应向量 $\\mathbf{s}_b \\in \\mathbb{R}^d$。每个观测到的簇 $i$ 都关联一个批次索引 $b(i)$ 和一个观测质心 $\\mathbf{m}_i \\in \\mathbb{R}^d$。批次校正后的质心定义为\n$$\n\\mathbf{c}_i \\;=\\; \\mathbf{m}_i \\;-\\; \\mathbf{s}_{b(i)} \\, .\n$$\n如果两个簇 $i$ 和 $j$ 满足 $b(i) \\neq b(j)$ 且 $\\lVert \\mathbf{c}_i - \\mathbf{c}_j \\rVert_2 \\le \\tau$（其中 $\\tau \\in \\mathbb{R}_{\\ge 0}$ 是给定的容差），则认为它们是直接兼容的。定义一个无向图，其顶点是各个簇，其边连接所有直接兼容的簇对。合并组被定义为该图的连通分量。您的任务是，对下面的每个独立测试用例，计算合并组的总数（即连通分量的数量）。\n\n重要说明：\n- 距离 $\\lVert \\cdot \\rVert_2$ 是 $\\mathbb{R}^d$ 中的标准欧几里得范数。\n- 仅允许在来自不同批次的簇之间建立边，即仅当 $b(i) \\neq b(j)$ 时。\n- 容差 $\\tau$ 的应用是包含性的：如果 $\\lVert \\mathbf{c}_i - \\mathbf{c}_j \\rVert_2 = \\tau$，那么 $i$ 和 $j$ 之间会由一条边连接。\n- 每个测试用例的最终结果是一个整数：连通分量的数量。\n\n测试套件：\n- 测试用例 1:\n  - 维度 $d = 2$。\n  - 批次 $B = 2$，其中 $\\mathbf{s}_1 = [\\,1,\\,0\\,]$ 且 $\\mathbf{s}_2 = [\\,-1,\\,0\\,]$。\n  - 容差 $\\tau = 0.2$。\n  - 观测簇：\n    - 批次 1：$\\mathbf{m}_{A} = [\\,5,\\,0\\,]$，$\\mathbf{m}_{C} = [\\,1,\\,10\\,]$。\n    - 批次 2：$\\mathbf{m}_{B} = [\\,3,\\,0\\,]$，$\\mathbf{m}_{D} = [\\,-1,\\,10.15\\,]$。\n\n- 测试用例 2:\n  - 维度 $d = 2$。\n  - 批次 $B = 3$，其中 $\\mathbf{s}_1 = [\\,0,\\,0\\,]$，$\\mathbf{s}_2 = [\\,0.5,\\,0\\,]$，$\\mathbf{s}_3 = [\\,1.0,\\,0\\,]$。\n  - 容差 $\\tau = 1.0$。\n  - 观测簇：\n    - 批次 1：$\\mathbf{m}_{A} = [\\,0,\\,0\\,]$，$\\mathbf{m}_{D} = [\\,100,\\,100\\,]$。\n    - 批次 2：$\\mathbf{m}_{B} = [\\,1.5,\\,0\\,]$，$\\mathbf{m}_{E} = [\\,-100,\\,-100\\,]$。\n    - 批次 3：$\\mathbf{m}_{C} = [\\,3.0,\\,0\\,]$。\n\n- 测试用例 3:\n  - 维度 $d = 3$。\n  - 批次 $B = 2$，其中 $\\mathbf{s}_1 = [\\,0.2,\\,-0.1,\\,0.0\\,]$ 且 $\\mathbf{s}_2 = [\\,-0.2,\\,0.1,\\,0.0\\,]$。\n  - 容差 $\\tau = 0.0$。\n  - 观测簇：\n    - 批次 1：$\\mathbf{m}_{X} = [\\,1.2,\\,0.9,\\,3.0\\,]$，$\\mathbf{m}_{Z} = [\\,10.2,\\,-4.1,\\,0.0\\,]$。\n    - 批次 2：$\\mathbf{m}_{Y} = [\\,0.8,\\,1.1,\\,3.0\\,]$，$\\mathbf{m}_{W} = [\\,9.8,\\,-3.9,\\,0.05\\,]$。\n\n您的程序应生成单行输出，其中包含三个测试用例的结果，格式为方括号内以逗号分隔的列表，例如 $[\\,r_1,r_2,r_3\\,]$，其中每个 $r_k$ 是测试用例 $k$ 的合并组数量（整数）。",
            "solution": "所提出的问题是计算生物学中一个有效且定义明确的练习，具体涉及单细胞RNA测序（scRNA-seq）数据分析中批次效应校正的原理。该问题具有科学依据、数学精确性且可通过算法求解。因此，我将给出一个完整的解决方案。\n\n其基本目标是识别并合并那些生物学上相同，但由于被称为批次效应的技术性伪影而显得不同的细胞簇。该问题将此场景形式化，并为数据重整合提供了清晰的流程。解决方案基于既定原则，分三个逻辑步骤进行。\n\n首先，我们应用**加性批次校正**的原则。假设实验批次 $b$ 的效应是在特征空间中对数据点产生统一的、加性的位移。这由一个已知的偏移向量 $\\mathbf{s}_b \\in \\mathbb{R}^d$ 表示。一个来自批次 $b(i)$ 的观测簇 $i$，由其质心 $\\mathbf{m}_i$ 表示，其真实的生物学位置 $\\mathbf{c}_i$ 受到了这种效应的扭曲。为了校正这一点，我们减去相应的偏移向量，得到批次校正后的质心：\n$$\n\\mathbf{c}_i = \\mathbf{m}_i - \\mathbf{s}_{b(i)}\n$$\n此操作旨在将来自不同批次的生物学等效簇的质心对齐到一个共同的、校正后的坐标系中。\n\n其次，我们采用一个**基于图的框架来定义关系**。这些簇被视为一个无向图中的顶点。两个顶点之间的边表示相应的簇是兼容的，可以合并。兼容性的标准被严格定义为：\n1.  簇必须源自不同的批次，即 $b(i) \\neq b(j)$。这是一个关键约束，因为目标是跨批次合并，而不是在批次内部合并，因为批次内的簇被假定为生物学上是不同的。\n2.  它们批次校正后的质心之间的欧几里得距离必须在给定的容差 $\\tau \\ge 0$ 之内。这在数学上表示为：\n    $$\n    \\lVert \\mathbf{c}_i - \\mathbf{c}_j \\rVert_2 \\le \\tau\n    $$\n    这个条件形式化了这样一种概念：如果两个簇在生物学上是相同的，那么它们校正后的质心在特征空间中应该彼此非常接近。\n\n第三，最终的**合并组被识别为连通分量**。连通分量是一个最大子图，其中任意两个顶点都通过一条路径相互连接。这个定义自然地将所有直接或间接兼容的簇组合在一起。因此，这类合并组的总数等于图中连通分量的数量。\n\n为了计算这个数量，我们实现一个标准的图算法。对于每个测试用例，我们执行以下步骤：\n1.  对每个观测簇 $i$，计算其校正后的质心 $\\mathbf{c}_i$。\n2.  构建具有 $N$ 个顶点的图的邻接表示（例如，邻接矩阵或邻接表），其中 $N$ 是簇的总数。遍历所有唯一的簇对 $(i, j)$。\n3.  如果 $b(i) \\neq b(j)$ 且 $\\lVert \\mathbf{c}_i - \\mathbf{c}_j \\rVert_2 \\le \\tau$，则在顶点 $i$ 和 $j$ 之间添加一条边。\n4.  利用图遍历算法，如深度优先搜索（DFS）或广度优先搜索（BFS），来计算连通分量的数量。或者，也可以使用专门的库函数，例如 `scipy.sparse.csgraph.connected_components` 来完成此任务。\n\n现在我们将此程序应用于每个测试用例。\n\n**测试用例 1：**\n- 批次：$B=2$。簇：$A, C$ 在批次 1 中；$B, D$ 在批次 2 中。$\\tau = 0.2$。\n- 批次偏移：$\\mathbf{s}_1 = [1, 0]$，$\\mathbf{s}_2 = [-1, 0]$。\n- 观测质心：$\\mathbf{m}_A = [5, 0]$，$\\mathbf{m}_C = [1, 10]$，$\\mathbf{m}_B = [3, 0]$，$\\mathbf{m}_D = [-1, 10.15]$。\n- 校正后质心：\n  - $\\mathbf{c}_A = \\mathbf{m}_A - \\mathbf{s}_1 = [5, 0] - [1, 0] = [4, 0]$。\n  - $\\mathbf{c}_C = \\mathbf{m}_C - \\mathbf{s}_1 = [1, 10] - [1, 0] = [0, 10]$。\n  - $\\mathbf{c}_B = \\mathbf{m}_B - \\mathbf{s}_2 = [3, 0] - [-1, 0] = [4, 0]$。\n  - $\\mathbf{c}_D = \\mathbf{m}_D - \\mathbf{s}_2 = [-1, 10.15] - [-1, 0] = [0, 10.15]$。\n- 兼容性检查（在批次 1 和 2 之间）：\n  - $\\lVert \\mathbf{c}_A - \\mathbf{c}_B \\rVert_2 = \\lVert [4, 0] - [4, 0] \\rVert_2 = 0 \\le 0.2$。存在边 $(A, B)$。\n  - $\\lVert \\mathbf{c}_C - \\mathbf{c}_D \\rVert_2 = \\lVert [0, 10] - [0, 10.15] \\rVert_2 = 0.15 \\le 0.2$。存在边 $(C, D)$。\n  - 所有其他跨批次距离都很大。\n- 该图有两个连通分量：$\\{A, B\\}$ 和 $\\{C, D\\}$。合并组的数量为 $2$。\n\n**测试用例 2：**\n- 批次：$B=3$。簇：$A, D$ 在批次 1 中；$B, E$ 在批次 2 中；$C$ 在批次 3 中。$\\tau = 1.0$。\n- 批次偏移：$\\mathbf{s}_1 = [0, 0]$，$\\mathbf{s}_2 = [0.5, 0]$，$\\mathbf{s}_3 = [1.0, 0]$。\n- 校正后质心：\n  - $\\mathbf{c}_A = [0, 0] - [0, 0] = [0, 0]$。\n  - $\\mathbf{c}_D = [100, 100]$。\n  - $\\mathbf{c}_B = [1.5, 0] - [0.5, 0] = [1.0, 0]$。\n  - $\\mathbf{c}_E = [-100, -100] - [0.5, 0] = [-100.5, -100]$。\n  - $\\mathbf{c}_C = [3.0, 0] - [1.0, 0] = [2.0, 0]$。\n- 兼容性检查：\n  - $\\lVert \\mathbf{c}_A - \\mathbf{c}_B \\rVert_2 = \\lVert [0, 0] - [1.0, 0] \\rVert_2 = 1.0 \\le 1.0$。存在边 $(A, B)$。\n  - $\\lVert \\mathbf{c}_B - \\mathbf{c}_C \\rVert_2 = \\lVert [1.0, 0] - [2.0, 0] \\rVert_2 = 1.0 \\le 1.0$。存在边 $(B, C)$。\n  - 与 $D$ 和 $E$ 相关的距离都很大。\n- 该图有一个连通分量 $\\{A, B, C\\}$ 和两个孤立顶点 $\\{D\\}$ 和 $\\{E\\}$。合并组的数量为 $3$。\n\n**测试用例 3：**\n- 批次：$B=2$。簇：$X, Z$ 在批次 1 中；$Y, W$ 在批次 2 中。$\\tau = 0.0$。\n- 批次偏移：$\\mathbf{s}_1 = [0.2, -0.1, 0.0]$，$\\mathbf{s}_2 = [-0.2, 0.1, 0.0]$。\n- 校正后质心：\n  - $\\mathbf{c}_X = [1.2, 0.9, 3.0] - [0.2, -0.1, 0.0] = [1.0, 1.0, 3.0]$。\n  - $\\mathbf{c}_Z = [10.2, -4.1, 0.0] - [0.2, -0.1, 0.0] = [10.0, -4.0, 0.0]$。\n  - $\\mathbf{c}_Y = [0.8, 1.1, 3.0] - [-0.2, 0.1, 0.0] = [1.0, 1.0, 3.0]$。\n  - $\\mathbf{c}_W = [9.8, -3.9, 0.05] - [-0.2, 0.1, 0.0] = [10.0, -4.0, 0.05]$。\n- 兼容性检查（当 $\\tau=0.0$ 时，距离必须恰好为 $0$）：\n  - $\\mathbf{c}_X$ 与 $\\mathbf{c}_Y$ 相同，所以 $\\lVert \\mathbf{c}_X - \\mathbf{c}_Y \\rVert_2 = 0 \\le 0.0$。存在边 $(X, Y)$。\n  - 没有其他对具有相同的校正后质心。\n- 该图有一个连通分量 $\\{X, Y\\}$ 和两个孤立顶点 $\\{Z\\}$ 和 $\\{W\\}$。合并组的数量为 $3$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse.csgraph import connected_components\n\ndef solve():\n    \"\"\"\n    Solves the cluster merging problem for the given test suite.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1\n        {\n            \"batch_shifts\": {1: np.array([1.0, 0.0]), 2: np.array([-1.0, 0.0])},\n            \"tau\": 0.2,\n            \"clusters\": [\n                {'m': np.array([5.0, 0.0]), 'b': 1},\n                {'m': np.array([1.0, 10.0]), 'b': 1},\n                {'m': np.array([3.0, 0.0]), 'b': 2},\n                {'m': np.array([-1.0, 10.15]), 'b': 2},\n            ],\n        },\n        # Test Case 2\n        {\n            \"batch_shifts\": {\n                1: np.array([0.0, 0.0]),\n                2: np.array([0.5, 0.0]),\n                3: np.array([1.0, 0.0]),\n            },\n            \"tau\": 1.0,\n            \"clusters\": [\n                {'m': np.array([0.0, 0.0]), 'b': 1},\n                {'m': np.array([100.0, 100.0]), 'b': 1},\n                {'m': np.array([1.5, 0.0]), 'b': 2},\n                {'m': np.array([-100.0, -100.0]), 'b': 2},\n                {'m': np.array([3.0, 0.0]), 'b': 3},\n            ],\n        },\n        # Test Case 3\n        {\n            \"batch_shifts\": {\n                1: np.array([0.2, -0.1, 0.0]),\n                2: np.array([-0.2, 0.1, 0.0]),\n            },\n            \"tau\": 0.0,\n            \"clusters\": [\n                {'m': np.array([1.2, 0.9, 3.0]), 'b': 1},\n                {'m': np.array([10.2, -4.1, 0.0]), 'b': 1},\n                {'m': np.array([0.8, 1.1, 3.0]), 'b': 2},\n                {'m': np.array([9.8, -3.9, 0.05]), 'b': 2},\n            ],\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        clusters_data = case[\"clusters\"]\n        batch_shifts = case[\"batch_shifts\"]\n        tau = case[\"tau\"]\n        num_clusters = len(clusters_data)\n\n        # Step 1: Compute batch-corrected centroids\n        corrected_centroids = []\n        for i in range(num_clusters):\n            m_i = clusters_data[i]['m']\n            b_i = clusters_data[i]['b']\n            s_i = batch_shifts[b_i]\n            c_i = m_i - s_i\n            corrected_centroids.append(c_i)\n\n        # Step 2: Build the adjacency matrix for the compatibility graph\n        adjacency_matrix = np.zeros((num_clusters, num_clusters), dtype=int)\n        for i in range(num_clusters):\n            for j in range(i + 1, num_clusters):\n                # Condition 1: Must be from different batches\n                b_i = clusters_data[i]['b']\n                b_j = clusters_data[j]['b']\n                if b_i == b_j:\n                    continue\n\n                # Condition 2: Distance between corrected centroids is within tolerance\n                c_i = corrected_centroids[i]\n                c_j = corrected_centroids[j]\n                distance = np.linalg.norm(c_i - c_j)\n\n                if distance = tau:\n                    adjacency_matrix[i, j] = 1\n                    adjacency_matrix[j, i] = 1\n\n        # Step 3: Count the number of connected components\n        n_components, _ = connected_components(\n            csgraph=adjacency_matrix, directed=False, return_labels=True\n        )\n        results.append(n_components)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "当数据被清理和聚类后，下一步是进行生物学解释。本实践专注于识别标记基因（marker genes）——即那些其表达模式能够独特定义一个细胞簇的基因。我们将使用ROC曲线下面积（Area Under the ROC Curve, AUROC）这一强大的统计指标，来量化每个基因区分特定细胞簇与其他细胞的能力，从而对它们进行排序，并找出最佳的生物学标记。",
            "id": "2429791",
            "problem": "给定来自单细胞RNA测序 (scRNA-seq) 的多个基因在单个细胞中的表达量测量值，以及每个细胞的簇成员身份的二元指示符。将每个基因在所有细胞中的表达量视为一个数值分数，用于将目标簇与所有其他细胞区分开。使用受试者工作特征 (ROC) 曲线下面积 (AUROC) 来评估每个基因的表达量将目标簇与其余细胞分开的效果。受试者工作特征 (ROC) 曲线是根据当判别阈值在所有可能的分数值上变化时，真阳性率和假阳性率的变化来定义的。ROC曲线下面积 (AUROC) 是从正类中均匀抽取的分数超过从负类中均匀抽取的分数的概率，其中平局情况贡献二分之一。形式上，对于一个给定的基因，其在细胞 $i \\in \\{1,\\dots,N\\}$ 上的分数为 $s_i$，并且有指示簇成员身份的二元标签 $y_i \\in \\{0,1\\}$，定义\n$$\n\\mathrm{AUROC} \\;=\\; \\frac{1}{n_1\\, n_0}\\sum_{\\substack{i:\\, y_i=1}}\\sum_{\\substack{j:\\, y_j=0}}\\left(\\mathbf{1}\\{s_i  s_j\\} \\;+\\; \\tfrac{1}{2}\\,\\mathbf{1}\\{s_i = s_j\\}\\right),\n$$\n其中 $n_1 = \\sum_i y_i$ 是正类（簇内）细胞的数量，$n_0 = N - n_1$ 是负类（簇外）细胞的数量，而 $\\mathbf{1}\\{\\cdot\\}$ 是指示函数。\n\n对于下面的每个测试用例，您将获得：\n- 一个二元簇标签向量 $y \\in \\{0,1\\}^N$，其中两类都存在（即 $0  \\sum_i y_i  N$），以及\n- 一个基因-细胞分数矩阵 $X \\in \\mathbb{R}^{N \\times G}$，其中第 $g$ 列包含基因索引为 $g$ 的基因在所有 $N$ 个细胞中的分数 $s_i$。\n\n您在每个测试用例中的任务是：\n1. 根据上述定义，为每个基因 $g \\in \\{0,\\dots,G-1\\}$ 计算AUROC。在您最终报告的数字中，将每个AUROC四舍五入到 $6$ 位小数。\n2. 按AUROC降序对基因索引进行排序。如果两个或多个基因的AUROC完全相同，则按基因索引升序打破平局（即，较小的索引排在前面）。\n\n测试套件：\n- 测试用例 $1$：\n  - $y = [\\,1,1,1,0,0,0,0,0\\,]$。\n  - $X$ 有 $N=8$ 行（细胞）和 $G=5$ 列（基因），其中每行按顺序罗列了 $[g_0,g_1,g_2,g_3,g_4]$ 的分数：\n    - 第 $0$ 行：$[\\,6,1,0,2,3\\,]$\n    - 第 $1$ 行：$[\\,4,0,1,2,1\\,]$\n    - 第 $2$ 行：$[\\,5,1,0,2,2\\,]$\n    - 第 $3$ 行：$[\\,2,1,3,2,2\\,]$\n    - 第 $4$ 行：$[\\,1,0,2,2,1\\,]$\n    - 第 $5$ 行：$[\\,0,1,4,2,2\\,]$\n    - 第 $6$ 行：$[\\,1,0,1,2,0\\,]$\n    - 第 $7$ 行：$[\\,2,1,2,2,3\\,]$\n- 测试用例 $2$：\n  - $y = [\\,0,0,1,0\\,]$。\n  - $X$ 有 $N=4$ 行和 $G=4$ 列，行格式为 $[g_0,g_1,g_2,g_3]$：\n    - 第 $0$ 行：$[\\,1,5,3,2\\,]$\n    - 第 $1$ 行：$[\\,2,4,3,5\\,]$\n    - 第 $2$ 行：$[\\,5,1,3,5\\,]$\n    - 第 $3$ 行：$[\\,2,4,3,5\\,]$\n- 测试用例 $3$：\n  - $y = [\\,1,1,1,1,1,0,0\\,]$。\n  - $X$ 有 $N=7$ 行和 $G=3$ 列，行格式为 $[g_0,g_1,g_2]$：\n    - 第 $0$ 行：$[\\,3,0,0\\,]$\n    - 第 $1$ 行：$[\\,0,1,2\\,]$\n    - 第 $2$ 行：$[\\,2,0,0\\,]$\n    - 第 $3$ 行：$[\\,0,0,1\\,]$\n    - 第 $4$ 行：$[\\,1,1,1\\,]$\n    - 第 $5$ 行：$[\\,0,3,1\\,]$\n    - 第 $6$ 行：$[\\,0,2,0\\,]$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，形式为一个列表。对于每个测试用例，输出一个包含两个元素的列表：第一个元素是基因 $[0,1,\\dots,G-1]$ 的AUROC列表，四舍五入到 $6$ 位小数；第二个元素是按上述规定排序的基因索引列表。因此，总输出应为单行，表示一个包含三个元素（对应三个测试用例）的列表，其中每个元素本身就是一个双元素列表。所有元素必须聚合到单行文本中，并用方括号括起来。例如，其形状应类似于 $[\\,[\\,[\\dots],[\\dots]\\,],\\,[\\,[\\dots],[\\dots]\\,],\\,[\\,[\\dots],[\\dots]\\,]\\,]$。本问题中没有物理单位或角度。所有数值输出必须是上下文所要求的实数或整数，其中AUROC值报告为四舍五入到 $6$ 位的小数。",
            "solution": "所提出的问题是有效的。它在科学上基于生物信息学和统计学的原理，特别是关于单细胞RNA测序 (scRNA-seq) 数据的分析。任务是根据基因作为特定细胞簇标记物的效用对其进行评估和排序。用于此评估的度量标准是受试者工作特征曲线下面积 (AUROC)，这是一种标准的非参数度量，用于衡量评分系统区分两个类别的能力。该问题为AUROC提供了精确的数学定义，所有必要的输入数据（$y$，即簇标签，和 $X$，即基因表达矩阵），以及对期望输出的明确说明，包括平局打破规则。该问题是适定问题，没有缺失信息、矛盾或歧义。\n\n问题的核心是计算每个基因的AUROC，它作为其区分能力的得分。提供的公式是：\n$$\n\\mathrm{AUROC} \\;=\\; \\frac{1}{n_1\\, n_0}\\sum_{\\substack{i:\\, y_i=1}}\\sum_{\\substack{j:\\, y_j=0}}\\left(\\mathbf{1}\\{s_i  s_j\\} \\;+\\; \\tfrac{1}{2}\\,\\mathbf{1}\\{s_i = s_j\\}\\right)\n$$\n其中，$s_i$ 是给定基因在所有 $N$ 个细胞中的表达分数，$y_i$ 是指示目标簇成员身份（$y_i=1$）与所有其他细胞（$y_i=0$）的二元标签。项 $n_1$ 和 $n_0$ 分别代表目标簇内和簇外的细胞数量。此公式对应于从正类（簇）中随机选择的细胞比从负类（簇外）中随机选择的细胞具有更高基因表达分数的概率，平局情况贡献值为 $\\frac{1}{2}$。\n\n解决步骤如下：\n1.  对于每个测试用例，我们都得到一个标签向量 $y$ 和一个分数矩阵 $X$。\n2.  我们遍历每个基因 $g$，它对应于矩阵 $X$ 中的一列。让这一列分数作为向量 $s$。\n3.  使用标签向量 $y$，我们将 $s$ 中的分数划分为两个集合：$S_1 = \\{s_i \\mid y_i=1\\}$，即目标簇内细胞的分数集合，和 $S_0 = \\{s_j \\mid y_j=0\\}$，即簇外细胞的分数集合。设它们各自的大小为 $n_1 = |S_1|$ 和 $n_0 = |S_0|$。问题保证 $n_1 > 0$ 和 $n_0 > 0$。\n4.  然后我们计算AUROC公式的分子，即成对比较的总和。对于 $S_1$ 中的每个分数 $s_i$，我们将其与 $S_0$ 中的每个分数 $s_j$ 进行比较。\n    -   如果 $s_i > s_j$，我们将 $1$ 加到一个运行总和中。\n    -   如果 $s_i = s_j$，我们将 $0.5$ 加到运行总和中。\n    -   如果 $s_i  s_j$，我们加 $0$。\n5.  在比较完所有对之后，将总和除以总对数，即乘积 $n_1 n_0$。这就得到了基因 $g$ 的AUROC。\n6.  对所有 $G$ 个基因重复此过程，得到一个包含 $G$ 个AUROC值的列表。按规定将每个值四舍五入到 $6$ 位小数。\n7.  最后，我们必须对基因进行排序。主要排序标准是AUROC值，按降序排列。更高的AUROC表示更好的区分度，因此具有更高值的基因排名靠前。次要标准用于打破平局：如果两个或多个基因具有完全相同的AUROC值，则索引较小的基因排名更高。我们通过基于一个结合了负AUROC（用于降序）和基因索引（用于升序）的键来对基因索引进行排序来实现这一点。\n\n将此过程应用于提供的每个测试用例。然后将结果汇总到指定的嵌套列表结构中作为最终输出。该实现将利用 `numpy` 库进行高效的向量化操作，特别是对于成对比较，这可以通过广播来完成。\n\n例如，对于一个给定的基因，如果 `s_pos` 是来自正类的分数数组，`s_neg` 是来自负类的分数数组，则可以高效地计算总分。通过将 `s_pos` 重塑为形状为 ($n_1$, $1$) 的列向量，并保持 `s_neg` 为形状为 ($1$, $n_0$) 的行向量，`numpy` 的广播规则将创建一个 $n_1 \\times n_0$ 的成对比较矩阵。正类分数大于负类分数的总和是 `np.sum(s_pos[:, np.newaxis] > s_neg)`，平局的总和是 `np.sum(s_pos[:, np.newaxis] == s_neg)`。这避免了在Python中使用显式的、速度较慢的嵌套循环。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the AUROC gene ranking problem for the given test suite.\n    \"\"\"\n    test_cases = [\n        {\n            \"y\": np.array([1, 1, 1, 0, 0, 0, 0, 0]),\n            \"X\": np.array([\n                [6, 1, 0, 2, 3],\n                [4, 0, 1, 2, 1],\n                [5, 1, 0, 2, 2],\n                [2, 1, 3, 2, 2],\n                [1, 0, 2, 2, 1],\n                [0, 1, 4, 2, 2],\n                [1, 0, 1, 2, 0],\n                [2, 1, 2, 2, 3],\n            ])\n        },\n        {\n            \"y\": np.array([0, 0, 1, 0]),\n            \"X\": np.array([\n                [1, 5, 3, 2],\n                [2, 4, 3, 5],\n                [5, 1, 3, 5],\n                [2, 4, 3, 5],\n            ])\n        },\n        {\n            \"y\": np.array([1, 1, 1, 1, 1, 0, 0]),\n            \"X\": np.array([\n                [3, 0, 0],\n                [0, 1, 2],\n                [2, 0, 0],\n                [0, 0, 1],\n                [1, 1, 1],\n                [0, 3, 1],\n                [0, 2, 0],\n            ])\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        y = case[\"y\"]\n        X = case[\"X\"]\n        \n        N, G = X.shape\n        \n        y_bool = y.astype(bool)\n        s_pos_all = X[y_bool, :]\n        s_neg_all = X[~y_bool, :]\n        \n        n1 = s_pos_all.shape[0]\n        n0 = s_neg_all.shape[0]\n        \n        if n1 == 0 or n0 == 0:\n            continue\n            \n        aurocs = []\n        for g in range(G):\n            s_pos = s_pos_all[:, g]\n            s_neg = s_neg_all[:, g]\n            \n            # Using broadcasting for efficient pairwise comparison\n            gt_sum = np.sum(s_pos[:, np.newaxis] > s_neg)\n            eq_sum = np.sum(s_pos[:, np.newaxis] == s_neg)\n            \n            comparison_sum = gt_sum + 0.5 * eq_sum\n            auroc = comparison_sum / (n1 * n0)\n            aurocs.append(auroc)\n            \n        rounded_aurocs = [round(a, 6) for a in aurocs]\n        \n        # Rank genes: descending AUROC, ascending gene index for ties\n        gene_indices = list(range(G))\n        ranked_indices = sorted(gene_indices, key=lambda i: (-rounded_aurocs[i], i))\n        \n        all_results.append([rounded_aurocs, ranked_indices])\n\n    # Format output to a compact, single-line string representation of the list\n    # with no spaces.\n    final_output_str = str(all_results).replace(\" \", \"\")\n    print(final_output_str)\n\nsolve()\n```"
        }
    ]
}