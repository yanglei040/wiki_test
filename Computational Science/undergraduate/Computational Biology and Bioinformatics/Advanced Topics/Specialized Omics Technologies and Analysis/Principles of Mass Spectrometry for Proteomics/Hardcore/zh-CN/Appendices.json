{
    "hands_on_practices": [
        {
            "introduction": "现代蛋白质组学离不开高分辨率质谱仪。它们区分质量极其相近的分子（同量异位素）的能力至关重要。本练习  提供了一个动手计算，要求你确定区分两种常见且质量几乎相同的翻译后修饰所需的分辨率。通过这个练习，你将深入理解一个基本的仪器参数如何直接影响生物学发现。",
            "id": "2416842",
            "problem": "一个肽具有中性单同位素质量 $M_0 = 1500.0000$ Da。考虑在一个赖氨酸残基上可能发生的两种翻译后修饰 (PTM)：三甲基化和乙酰化。对于添加到肽主链上的净质量偏移，三甲基化使用元素组成 $C_3H_6$，乙酰化使用元素组成 $C_2H_2O$。两种修饰后的母离子都在高分辨率质谱仪中以电荷态 $z=2$ 的双质子化物种被观测到。假设单同位素原子质量为 $m(\\mathrm{C}) = 12.000000$，$m(\\mathrm{H}) = 1.00782503223$，$m(\\mathrm{N}) = 14.00307400443$，$m(\\mathrm{O}) = 15.99491461957$，质子质量为 $m_p = 1.00727646688$（单位均为道尔顿）。使用质谱学中半峰全宽 (FWHM) 处的常规分辨率定义，并在两个单同位素母离子峰的平均 $m/z$ 处进行评估。\n\n在这些条件下，区分乙酰化和三甲基化母离子所需的理论最低分辨率 $R$ 是多少？将您的答案四舍五入至四位有效数字。将 $R$ 以无量纲数的形式报告。",
            "solution": "对问题陈述进行验证。\n\n**步骤1：提取已知条件**\n- 未修饰肽的中性单同位素质量：$M_0 = 1500.0000$ Da。\n- 翻译后修饰1 (PTM1)：三甲基化，其净质量偏移对应于元素组成 $C_3H_6$。\n- 翻译后修饰2 (PTM2)：乙酰化，其净质量偏移对应于元素组成 $C_2H_2O$。\n- 母离子的电荷态：$z=2$。\n- 单同位素原子质量：\n  - $m(\\mathrm{C}) = 12.000000$ Da\n  - $m(\\mathrm{H}) = 1.00782503223$ Da\n  - $m(\\mathrm{N}) = 14.00307400443$ Da\n  - $m(\\mathrm{O}) = 15.99491461957$ Da\n- 质子质量：$m_p = 1.00727646688$ Da。\n- 分辨率的定义：$R = \\frac{m}{(\\Delta m)_{\\text{FWHM}}}$，其中 $(\\Delta m)_{\\text{FWHM}}$ 是质荷比为 $m$ 的峰的半峰全宽。\n- $R$ 的评估点：两个单同位素母离子峰的平均 $m/z$。\n- 目标：确定区分这两种母离子所需的最低分辨率 $R$。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题具有科学依据，提法明确且客观。它描述了高分辨率蛋白质组学质谱中的一个标准计算。所提供的原子质量是正确的单同位素值。赖氨酸上三甲基化和乙酰化的质量偏移定义在化学上是正确的。该问题提供了计算唯一且有意义的解所需的所有信息。问题中没有矛盾、歧义或事实错误。\n\n**步骤3：结论与行动**\n问题有效。将推导解答。\n\n任务是找出区分两种同位素上不同的母离子所需的最低理论分辨率 $R$。两个峰恰好被分辨的标准是，它们的质荷比之差 $\\Delta(m/z)$ 等于峰的半峰全宽 (FWHM)，记为 $(\\Delta m)_{\\text{FWHM}}$。\n$$(\\Delta m)_{\\text{FWHM}} = \\Delta(m/z)$$\n分辨率定义为 $R = \\frac{m}{(\\Delta m)_{\\text{FWHM}}}$。问题指定 $R$ 应在两个峰的平均质荷比 $(m/z)_{\\text{avg}}$ 处进行评估。\n因此，所需的最低分辨率由下式给出：\n$$R = \\frac{(m/z)_{\\text{avg}}}{\\Delta(m/z)}$$\n\n首先，我们根据每种 PTM 的元素组成计算其质量偏移 $\\Delta M$。\n对于三甲基化 ($PTM_1$)：\n$$\\Delta M_{tri} = 3 \\times m(\\mathrm{C}) + 6 \\times m(\\mathrm{H})$$\n$$\\Delta M_{tri} = 3 \\times 12.000000 + 6 \\times 1.00782503223 = 36.000000 + 6.04695019338 = 42.04695019338 \\text{ Da}$$\n对于乙酰化 ($PTM_2$)：\n$$\\Delta M_{ac} = 2 \\times m(\\mathrm{C}) + 2 \\times m(\\mathrm{H}) + 1 \\times m(\\mathrm{O})$$\n$$\\Delta M_{ac} = 2 \\times 12.000000 + 2 \\times 1.00782503223 + 15.99491461957 = 24.000000 + 2.01565006446 + 15.99491461957 = 42.01056468403 \\text{ Da}$$\n\n接下来，我们确定两种修饰肽的中性单同位素质量 $M_{tri}$ 和 $M_{ac}$。\n$$M_{tri} = M_0 + \\Delta M_{tri} = 1500.0000 + 42.04695019338 = 1542.04695019338 \\text{ Da}$$\n$$M_{ac} = M_0 + \\Delta M_{ac} = 1500.0000 + 42.01056468403 = 1542.01056468403 \\text{ Da}$$\n\n对于一个中性质量为 $M$、电荷态为 $z$、质子质量为 $m_p$ 的离子，其质荷比 $m/z$ 由下式给出：\n$$(m/z) = \\frac{M + z \\cdot m_p}{z} = \\frac{M}{z} + m_p$$\n这两种物质的 $m/z$ 差异是：\n$$\\Delta(m/z) = (m/z)_{tri} - (m/z)_{ac} = \\left(\\frac{M_{tri}}{z} + m_p\\right) - \\left(\\frac{M_{ac}}{z} + m_p\\right) = \\frac{M_{tri} - M_{ac}}{z}$$\n中性质量的差异是：\n$$M_{tri} - M_{ac} = \\Delta M_{tri} - \\Delta M_{ac} = 42.04695019338 - 42.01056468403 = 0.03638550935 \\text{ Da}$$\n当 $z=2$ 时，$m/z$ 的差异是：\n$$\\Delta(m/z) = \\frac{0.03638550935}{2} = 0.018192754675$$\n\n现在，我们计算平均质荷比 $(m/z)_{\\text{avg}}$。\n$$(m/z)_{\\text{avg}} = \\frac{(m/z)_{tri} + (m/z)_{ac}}{2} = \\frac{1}{2} \\left[ \\left(\\frac{M_{tri}}{z} + m_p\\right) + \\left(\\frac{M_{ac}}{z} + m_p\\right) \\right] = \\frac{M_{tri} + M_{ac}}{2z} + m_p$$\n平均中性质量是：\n$$M_{avg} = \\frac{M_{tri} + M_{ac}}{2} = \\frac{1542.04695019338 + 1542.01056468403}{2} = 1542.028757438705 \\text{ Da}$$\n平均 $m/z$ 是：\n$$(m/z)_{\\text{avg}} = \\frac{1542.028757438705}{2} + 1.00727646688 = 771.0143787193525 + 1.00727646688 = 772.02165518623$$\n\n最后，我们计算所需的最低分辨率 $R$。\n$$R = \\frac{(m/z)_{\\text{avg}}}{\\Delta(m/z)} = \\frac{772.02165518623}{0.018192754675} \\approx 42436.0029$$\n问题要求答案四舍五入至四位有效数字。\n$$R \\approx 42440$$\n用标准科学记数法表示，即为 $4.244 \\times 10^4$。",
            "answer": "$$\\boxed{4.244 \\times 10^{4}}$$"
        },
        {
            "introduction": "串联质谱（MS/MS）技术使我们能够从头（*de novo*）测定肽段序列。这种鉴定方法的可靠性取决于所获得的序列标签在目标蛋白质组中是否是独一无二的。本练习  将指导你完成一个统计计算，以确定一个序列标签要被认为是唯一的所需具备的最小长度。这个练习展示了概率论如何成为我们对肽段鉴定置信度的理论基础。",
            "id": "2416808",
            "problem": "在基于串联质谱（MS/MS）的蛋白质组学中，一种从头测序算法会输出一个长度为 $L$ 的连续氨基酸“序列标签”。考虑以下基于序列采样第一性原理的建模假设：\n\n- 由于典型的MS/MS碎裂无法区分亮氨酸和异亮氨酸，有效的氨基酸字母表大小为 $A = 19$。\n- 人类蛋白质组（所有标准蛋白质序列的串联）总共包含 $M = 1.1 \\times 10^{7}$ 个氨基酸残基。\n- 将蛋白质组视为一个通过从具有均匀概率的 $A$ 字母表中进行独立同分布抽样生成的序列。忽略蛋白质边界效应，并将长度为 $L$ 的子序列（$L$-mer）的可能起始位置数量近似视为 $M$。\n- 从头测序的序列标签是正确的，并且源自蛋白质组中的一个真实肽段，因此它在蛋白质组中至少匹配一个位置。\n\n定义“在人类蛋白质组中唯一”意为该序列标签在蛋白质组中所有可能的 $L$-mer 窗口中仅出现于一个起始位置。确定最小的整数 $L$，使得一个随机抽取的正确标签是唯一的概率至少为 $0.99$。报告满足此标准的最小整数 $L$。除了选择最小整数外，不需要进行四舍五入。",
            "solution": "首先必须验证问题陈述的科学合理性、自洽性和清晰度。\n\n步骤1：提取已知条件。\n- 氨基酸序列标签的长度用 $L$ 表示。\n- 有效氨基酸字母表的大小为 $A = 19$，因为亮氨酸和异亮氨酸不可区分。\n- 人类蛋白质组中的氨基酸残基总数为 $M = 1.1 \\times 10^{7}$。\n- 蛋白质组被建模为一个长度为 $M$ 的残基序列，由从 $A$ 字母表上的均匀分布中进行独立同分布（i.i.d.）抽样生成。\n- 长度为 $L$ 的子序列（$L$-mer）的潜在起始位置数约为 $M$。\n- 序列标签是正确的，意味着它在蛋白质组中至少出现一次。\n- 如果一个标签在蛋白质组中只出现在一个起始位置，则定义该标签为“唯一的”。\n- 目标是找到最小的整数 $L$，使得随机抽取的正确标签是唯一的概率至少为 $0.99$。\n\n步骤2：使用提取的已知条件进行验证。\n这是一个定义明确的概率论在生物信息学中应用的问题。\n- **科学依据**：模型的假设虽然是简化，但在此领域中是标准且适合进行一阶近似的。蛋白质组的独立同分布均匀模型是一个常见的零假设模型，给定的 $A$ 和 $M$ 的值是现实的。该问题基于已建立的序列统计学原理。\n- **良构性**：问题要求在概率约束下最小化整数 $L$。这是一个良构的数学问题，存在唯一的整数解。\n- **目标**：问题陈述使用了精确、定量的语言，没有主观或模糊的术语。提供了数学公式所需的所有参数。\n- **结论**：该问题没有验证清单中列出的缺陷。它是有效的。\n\n步骤3：裁决与行动。\n问题有效。将提供解答。\n\n问题要求找到最小的整数 $L$，使得一个正确的序列标签是唯一的概率至少为 $0.99$。设 $N$ 为一个特定的 $L$-mer 标签在蛋白质组中出现的次数。标签“正确”的条件转化为 $N \\ge 1$。标签“唯一”的条件转化为 $N = 1$。因此，问题是找到最小的整数 $L$，使得 $P(N=1 | N \\ge 1) \\ge 0.99$。\n\n蛋白质组被建模为长度为 $M$ 的随机序列。由于均匀独立同分布的假设，一个特定的 $L$-mer 在任何给定起始位置出现的概率为 $p = (1/A)^L = A^{-L}$。可能的起始位置数为 $M$。因此，特定 $L$-mer 的出现次数 $N$ 服从二项分布，$N \\sim B(M, p)$。\n\n鉴于 $M = 1.1 \\times 10^{7}$ 非常大，且对于任何实际的 $L$，$p = 19^{-L}$ 都非常小，二项分布可以被参数为 $\\lambda = M p = M A^{-L}$ 的泊松分布精确近似。观测到 $k$ 次出现的概率由 $P(N=k) = \\frac{\\lambda^k e^{-\\lambda}}{k!}$ 给出。\n\n我们需要计算条件概率：\n$$P(N=1 | N \\ge 1) = \\frac{P(N=1 \\text{ and } N \\ge 1)}{P(N \\ge 1)} = \\frac{P(N=1)}{1 - P(N=0)}$$\n使用泊松近似，我们有：\n$$P(N=1) = \\lambda e^{-\\lambda}$$\n$$P(N=0) = e^{-\\lambda}$$\n将这些代入条件概率的表达式中得到：\n$$f(\\lambda) = \\frac{\\lambda e^{-\\lambda}}{1 - e^{-\\lambda}}$$\n问题要求找到满足 $f(M A^{-L}) \\ge 0.99$ 的最小整数 $L$。\n\n为了确定 $f(\\lambda)$ 的行为，我们考察它关于 $\\lambda$ 的单调性。$f(\\lambda)$ 的导数为：\n$$ f'(\\lambda) = \\frac{d}{d\\lambda} \\left( \\frac{\\lambda e^{-\\lambda}}{1 - e^{-\\lambda}} \\right) = \\frac{(e^{-\\lambda} - \\lambda e^{-\\lambda})(1-e^{-\\lambda}) - (\\lambda e^{-\\lambda})(e^{-\\lambda})}{(1-e^{-\\lambda})^2} = \\frac{e^{-\\lambda}(1-\\lambda-e^{-\\lambda})}{(1-e^{-\\lambda})^2} $$\n对于 $\\lambda > 0$，分母和 $e^{-\\lambda}$ 项都是正的。因此，$f'(\\lambda)$ 的符号由分子中的项 $g(\\lambda) = 1-\\lambda-e^{-\\lambda}$ 决定。我们分析 $g(\\lambda)$：当 $\\lambda=0$ 时，$g(0) = 1-0-e^0 = 0$。$g(\\lambda)$ 的导数是 $g'(\\lambda) = -1 - (-e^{-\\lambda}) = e^{-\\lambda} - 1$。对于所有 $\\lambda > 0$，$e^{-\\lambda}  1$，所以 $g'(\\lambda)  0$。这意味着 $g(\\lambda)$ 是一个从 $g(0)=0$ 开始的严格递减函数。因此，对于所有 $\\lambda > 0$，$g(\\lambda)  0$。所以，$f'(\\lambda)  0$ 对所有 $\\lambda > 0$ 成立，这意味着 $f(\\lambda)$ 是 $\\lambda$ 的一个单调递减函数。\n\n由于 $f(\\lambda)$ 随着 $\\lambda$ 的增加而减小，而 $\\lambda = M A^{-L}$ 随着 $L$ 的增加而减小，所以概率 $f(M A^{-L})$ 是 $L$ 的一个单调递增函数。因此，我们可以通过测试连续的整数值来找到最小的整数 $L$。\n\n让我们测试 $L=6$：\n$$\\lambda_6 = M A^{-6} = (1.1 \\times 10^7) \\times 19^{-6} = \\frac{1.1 \\times 10^7}{47045881} \\approx 0.2338$$\n概率是：\n$$f(\\lambda_6) = f(0.2338) = \\frac{0.2338 \\exp(-0.2338)}{1 - \\exp(-0.2338)} \\approx \\frac{0.2338 \\times 0.7915}{1 - 0.7915} = \\frac{0.1850}{0.2085} \\approx 0.887$$\n由于 $0.887  0.99$，$L=6$ 是不够的。\n\n让我们测试 $L=7$:\n$$\\lambda_7 = M A^{-7} = (1.1 \\times 10^7) \\times 19^{-7} = \\frac{\\lambda_6}{19} \\approx \\frac{0.2338}{19} \\approx 0.0123$$\n概率是：\n$$f(\\lambda_7) = f(0.0123) = \\frac{0.0123 \\exp(-0.0123)}{1 - \\exp(-0.0123)} \\approx \\frac{0.0123 \\times 0.9878}{1 - 0.9878} = \\frac{0.01215}{0.0122} \\approx 0.996$$\n由于 $0.996 \\ge 0.99$，$L=7$ 是足够的。\n\n鉴于概率是 $L$ 的单调递增函数，且 $L=6$ 不满足标准而 $L=7$ 满足，因此 $L$ 的最小整数值为 $7$。",
            "answer": "$$ \\boxed{7} $$"
        },
        {
            "introduction": "在真实的蛋白质组学实验中，多个肽段同时被分析并产生“嵌合”质谱图是一种常见情况。为了准确鉴定其中的肽段，我们必须首先在计算上分离它们的信号。本练习  要求你将问题建模为一个非负最小二乘优化问题，并实现一个算法来将嵌合质谱图解构为其组成部分。这个动手编程任务展示了计算方法在解释蛋白质组学中复杂且不完美的实验数据时不可或缺的作用。",
            "id": "2416809",
            "problem": "串联质谱 (MS/MS) 嵌合谱在两个肽前体共分离并共碎裂时产生，从而生成一个单一的观测谱，该谱是两个潜在肽谱的叠加。设观测谱在一个以汤姆逊单位 (Th) 为单位的固定质心化质荷比网格上表示为一个非负列向量 $\\mathbf{y} \\in \\mathbb{R}_{\\ge 0}^{N}$，并设两个肽特异性非负模板谱为列向量 $\\mathbf{a}_1, \\mathbf{a}_2 \\in \\mathbb{R}_{\\ge 0}^{N}$，其元素编码了在相同的 $N$ 个质荷比区间上的相对强度。假设在所考虑的窗口内，每个肽的同位素包络可以由其提供的模板很好地近似，并且共洗脱意味着单次扫描的观测可以被建模为线性组合\n$$\n\\mathbf{y} = c_1 \\mathbf{a}_1 + c_2 \\mathbf{a}_2 + \\boldsymbol{\\varepsilon},\n$$\n其中 $c_1 \\ge 0$ 和 $c_2 \\ge 0$ 是待估计的未知肽丰度，$\\boldsymbol{\\varepsilon}$ 是一个可能为零的加性残差向量。您必须设计一个程序，在给定 $(\\mathbf{a}_1, \\mathbf{a}_2, \\mathbf{y})$ 的情况下，返回能最小化残差的欧几里得范数平方的非负对 $(\\hat{c}_1, \\hat{c}_2)$，即\n$$\n(\\hat{c}_1, \\hat{c}_2) = \\arg\\min_{c_1 \\ge 0,\\, c_2 \\ge 0} \\left\\| \\mathbf{y} - c_1 \\mathbf{a}_1 - c_2 \\mathbf{a}_2 \\right\\|_2^2.\n$$\n所有强度都使用任意但一致的单位，质荷比的单位是汤姆逊 (Th)。输出 $(\\hat{c}_1, \\hat{c}_2)$ 是无量纲标量。\n\n测试套件。对于下方的每个测试用例，$N$ 以及向量 $\\mathbf{a}_1$、$\\mathbf{a}_2$ 和 $\\mathbf{y}$ 都被明确指定。您的程序必须为每个用例计算 $(\\hat{c}_1, \\hat{c}_2)$。\n\n- 测试用例 1（不相交的同位素包络；无残差）：\n  - $N = 6$。\n  - $\\mathbf{a}_1 = [\\,0.6,\\,0.3,\\,0.1,\\,0,\\,0,\\,0\\,]^{\\top}$。\n  - $\\mathbf{a}_2 = [\\,0,\\,0,\\,0,\\,0.5,\\,0.33,\\,0.17\\,]^{\\top}$。\n  - 真实丰度：$c_1 = 1.0$， $c_2 = 0.8$。\n  - $\\mathbf{y} = c_1 \\mathbf{a}_1 + c_2 \\mathbf{a}_2 = [\\,0.6,\\,0.3,\\,0.1,\\,0.4,\\,0.264,\\,0.136\\,]^{\\top}$。\n\n- 测试用例 2（部分重叠的同位素包络；无残差）：\n  - $N = 6$。\n  - $\\mathbf{a}_1 = [\\,0,\\,0.6,\\,0.3,\\,0.1,\\,0,\\,0\\,]^{\\top}$。\n  - $\\mathbf{a}_2 = [\\,0,\\,0,\\,0.5,\\,0.33,\\,0.17,\\,0\\,]^{\\top}$。\n  - 真实丰度：$c_1 = 1.2$， $c_2 = 0.7$。\n  - $\\mathbf{y} = c_1 \\mathbf{a}_1 + c_2 \\mathbf{a}_2 = [\\,0,\\,0.72,\\,0.71,\\,0.351,\\,0.119,\\,0\\,]^{\\top}$。\n\n- 测试用例 3（近似共线的模板；无残差）：\n  - $N = 3$。\n  - $\\mathbf{a}_1 = [\\,0.5,\\,0.3,\\,0.2\\,]^{\\top}$。\n  - $\\mathbf{a}_2 = [\\,0.52,\\,0.31,\\,0.17\\,]^{\\top}$。\n  - 真实丰度：$c_1 = 0.9$， $c_2 = 0.9$。\n  - $\\mathbf{y} = c_1 \\mathbf{a}_1 + c_2 \\mathbf{a}_2 = [\\,0.918,\\,0.549,\\,0.333\\,]^{\\top}$。\n\n要求的最终输出格式。您的程序应生成单行输出，其中包含所有测试用例的结果，形式为一个嵌套列表，每个内部列表为对应测试用例的 $[\\,\\hat{c}_1, \\hat{c}_2\\,]$，每个浮点数四舍五入到恰好六位小数，并按测试用例 1、2 和 3 的顺序排列。例如，输出必须具有以下形式\n$$\n[\\,[\\,x_{1,1},x_{1,2}\\,],\\,[\\,x_{2,1},x_{2,2}\\,],\\,[\\,x_{3,1},x_{3,2}\\,]\\,],\n$$\n其中每个 $x_{i,j}$ 是小数点后恰好有六位数字的十进制表示。",
            "solution": "该问题要求确定非负丰度 $(\\hat{c}_1, \\hat{c}_2)$，以两个模板谱 $\\mathbf{a}_1$ 和 $\\mathbf{a}_2$ 的线性组合形式，最好地解释观测到的嵌合质谱 $\\mathbf{y}$。目标是最小化残差向量的欧几里得范数平方，该问题可公式化为以下优化问题：\n$$\n(\\hat{c}_1, \\hat{c}_2) = \\arg\\min_{c_1 \\ge 0,\\, c_2 \\ge 0} \\left\\| \\mathbf{y} - c_1 \\mathbf{a}_1 - c_2 \\mathbf{a}_2 \\right\\|_2^2.\n$$\n这个问题可以用矩阵代数更紧凑地表示。设模板谱 $\\mathbf{a}_1 \\in \\mathbb{R}_{\\ge 0}^{N}$ 和 $\\mathbf{a}_2 \\in \\mathbb{R}_{\\ge 0}^{N}$ 是一个 $N \\times 2$ 矩阵 $A$ 的列，并设未知丰度是向量 $\\mathbf{c} = [c_1, c_2]^{\\top} \\in \\mathbb{R}_{\\ge 0}^{2}$ 的元素。那么问题就变成了找到能解决以下问题的向量 $\\hat{\\mathbf{c}}$：\n$$\n\\hat{\\mathbf{c}} = \\arg\\min_{\\mathbf{c} \\ge \\mathbf{0}} \\left\\| \\mathbf{y} - A\\mathbf{c} \\right\\|_2^2.\n$$\n这是一个标准的非负最小二乘法 (NNLS) 问题。目标函数 $f(\\mathbf{c}) = \\left\\| \\mathbf{y} - A\\mathbf{c} \\right\\|_2^2$ 是关于 $\\mathbf{c}$ 的一个凸二次函数，由约束 $\\mathbf{c} \\ge \\mathbf{0}$（即 $c_1 \\ge 0$ 和 $c_2 \\ge 0$）定义的可行域是一个凸集。因此，这是一个凸优化问题，保证了任何局部最小值也是全局最小值。如果矩阵 $A$ 的列是线性无关的，那么解是唯一的。\n\n尽管可以通过分析约束优化的 Karush-Kuhn-Tucker (KKT) 条件来推导解，但这通常相当复杂。一种更实用和稳健的方法是采用迭代数值算法。由 Lawson 和 Hanson 开发的活动集法是解决 NNLS 问题的经典且广泛使用的算法。它的工作原理是：迭代地将 $\\mathbf{c}$ 中的变量划分为“活动集”（其中系数固定为零）和“被动集”（其中系数允许为正），在每一步对被动集求解一个无约束最小二乘问题，并更新集合，直到满足 KKT 条件。\n\n该实现将利用标准的科学计算库，这些库为 NNLS 问题提供了稳健的求解器。具体来说，Python 中 SciPy 库的 `scipy.optimize.nnls` 函数实现了上述的活动集算法。\n\n对于每个测试用例，求解过程如下：\n1.  定义输入向量 $\\mathbf{a}_1$、$\\mathbf{a}_2$ 和 $\\mathbf{y}$。\n2.  通过将 $\\mathbf{a}_1$ 和 $\\mathbf{a}_2$ 作为列来构造矩阵 $A$。\n3.  以 $A$ 和 $\\mathbf{y}$ 为参数调用 `scipy.optimize.nnls` 函数。\n4.  该函数返回最优的非负系数向量 $\\hat{\\mathbf{c}} = [\\hat{c}_1, \\hat{c}_2]^{\\top}$。\n\n值得注意的是，对于所提供的所有测试用例，观测谱 $\\mathbf{y}$ 都是由模板以正系数精确线性组合而成，且没有加性噪声 ($\\boldsymbol{\\varepsilon} = \\mathbf{0}$)。对于这种无噪声的情况，当真实解位于可行域内部（即 $c_1 > 0, c_2 > 0$）时，NNLS 解与无约束普通最小二乘法 (OLS) 解 $\\hat{\\mathbf{c}} = (A^{\\top}A)^{-1}A^{\\top}\\mathbf{y}$ 一致。因此，该算法预期能精确地恢复真实丰度。使用通用的 NNLS 求解器确保了该方法论的正确性，并使其能够应用于包含测量噪声或某个组分可能缺失的更真实场景。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import nnls\n\ndef solve():\n    \"\"\"\n    Solves for the non-negative abundances of two peptides in chimeric mass spectra\n    for a given set of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"a1\": np.array([0.6, 0.3, 0.1, 0.0, 0.0, 0.0]),\n            \"a2\": np.array([0.0, 0.0, 0.0, 0.5, 0.33, 0.17]),\n            \"y\": np.array([0.6, 0.3, 0.1, 0.4, 0.264, 0.136]),\n        },\n        {\n            \"a1\": np.array([0.0, 0.6, 0.3, 0.1, 0.0, 0.0]),\n            \"a2\": np.array([0.0, 0.0, 0.5, 0.33, 0.17, 0.0]),\n            \"y\": np.array([0.0, 0.72, 0.71, 0.351, 0.119, 0.0]),\n        },\n        {\n            \"a1\": np.array([0.5, 0.3, 0.2]),\n            \"a2\": np.array([0.52, 0.31, 0.17]),\n            \"y\": np.array([0.918, 0.549, 0.333]),\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        a1 = case[\"a1\"]\n        a2 = case[\"a2\"]\n        y = case[\"y\"]\n\n        # Construct the matrix A from template vectors a1 and a2\n        A = np.stack([a1, a2], axis=1)\n\n        # Solve the Non-Negative Least Squares problem: argmin_c ||Ac - y||_2^2 for c = 0\n        c, _ = nnls(A, y)\n        results.append(list(c))\n\n    # Format the results into the required string format.\n    # Each float must be represented with exactly six decimal places.\n    # The final format is a nested list string representation, e.g., [[c1,c2],[c1,c2],...].\n    formatted_pairs = []\n    for pair in results:\n        formatted_pair_str = [f\"{val:.6f}\" for val in pair]\n        formatted_pairs.append(f\"[{','.join(formatted_pair_str)}]\")\n    \n    final_output = f\"[{','.join(formatted_pairs)}]\"\n\n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}