{
    "hands_on_practices": [
        {
            "introduction": "宏基因组分箱依赖多种信号将重叠群（contigs）与其来源生物体联系起来。双末端测序读段（paired-end reads）的连接信息是一种强大的信号，它基于基因组上的物理邻近性。这个练习将引导你使用贝叶斯推断和香农熵，来量化观测到的双末端连接如何改变我们关于两个重叠群是否属于同一物种的确信度。通过计算信息增益（information gain），你将为不同数据类型提供的证据强度建立起一种定量的直觉。",
            "id": "2433913",
            "problem": "在宏基因组数据的物种分类归属（taxonomic binning）中，如果来自同一DNA片段的配对读段（mates）能够唯一地比对到两个不同的重叠群（contig）上，且方向和插入片段大小均符合要求，那么这些双端测序读段（paired-end read）信息就可以支持将这两个重叠群连接起来。考虑两个重叠群以及一个二元潜在假设：$S$（来自相同分类单元）与 $D$（来自不同分类单元）。假设先验概率为 $P(S) = 0.2$ 且 $P(D) = 1 - P(S)$。设在两个重叠群之间观测到的正确比对的双端连接数 $K$ 服从泊松分布建模，其在假设 $S$ 下的均值为 $\\lambda_{S} = 8$，在假设 $D$ 下的均值为 $\\lambda_{D} = 0.5$。也就是说，对于 $k \\in \\{0,1,2,\\dots\\}$，\n$$\nP(K = k \\mid S) = \\exp(-\\lambda_{S}) \\frac{\\lambda_{S}^{k}}{k!}, \\quad P(K = k \\mid D) = \\exp(-\\lambda_{D}) \\frac{\\lambda_{D}^{k}}{k!}.\n$$\n你观测到 $K = 5$。定义使用双端测序数据所获得的信息增益为指示两个重叠群是否来自同一分类单元的二元变量的香农熵减少量（以比特为单位），即\n$$\n\\Delta I \\equiv H_{\\text{prior}} - H_{\\text{posterior}},\n$$\n其中对于伯努利参数 $p \\in (0,1)$，有 $H(p) = -\\big[p \\log_{2}(p) + (1-p)\\log_{2}(1-p)\\big]$，且 $H_{\\text{prior}} = H\\big(P(S)\\big)$，$H_{\\text{posterior}} = H\\big(P(S \\mid K=5)\\big)$。计算 $\\Delta I$（以比特为单位）。将你的答案四舍五入到四位有效数字。以比特为单位表示最终结果。",
            "solution": "该问题要求计算信息增益 $\\Delta I$，其定义为在观测到数据 $K=5$ 后，状态变量 $S$ 的香农熵的减少量。信息增益由以下公式给出：\n$$\n\\Delta I = H_{\\text{prior}} - H_{\\text{posterior}}\n$$\n其中 $H_{\\text{prior}}$ 是 $S$ 的先验分布的熵，$H_{\\text{posterior}}$ 是在给定观测值的情况下 $S$ 的后验分布的熵。对于参数为 $p$ 的伯努利变量，其香农熵（以比特为单位）定义为 $H(p) = -\\left[p \\log_{2}(p) + (1-p)\\log_{2}(1-p)\\right]$。\n\n首先，我们计算先验熵 $H_{\\text{prior}}$。两个重叠群来自同一分类单元的先验概率为 $P(S) = 0.2$。\n令 $p_{\\text{prior}} = P(S) = 0.2$。则 $1 - p_{\\text{prior}} = P(D) = 0.8$。\n先验熵为：\n$$\nH_{\\text{prior}} = H(p_{\\text{prior}}) = H(0.2) = -\\left[0.2 \\log_{2}(0.2) + 0.8 \\log_{2}(0.8)\\right]\n$$\n使用换底公式 $\\log_{2}(x) = \\frac{\\ln(x)}{\\ln(2)}$，我们得到：\n$$\nH_{\\text{prior}} = -\\frac{1}{\\ln(2)} \\left[0.2 \\ln(0.2) + 0.8 \\ln(0.8)\\right]\n$$\n代入数值 $\\ln(0.2) \\approx -1.609438$ 和 $\\ln(0.8) \\approx -0.223144$，以及 $\\ln(2) \\approx 0.693147$：\n$$\nH_{\\text{prior}} \\approx -\\frac{1}{0.693147} \\left[0.2(-1.609438) + 0.8(-0.223144)\\right] \\approx -\\frac{-0.500403}{0.693147} \\approx 0.721928 \\text{ 比特}\n$$\n\n接下来，我们必须求出后验概率 $P(S \\mid K=5)$ 来计算后验熵 $H_{\\text{posterior}}$。我们使用贝叶斯定理：\n$$\nP(S \\mid K=5) = \\frac{P(K=5 \\mid S) P(S)}{P(K=5)}\n$$\n观测到 $K=5$ 的边缘概率 $P(K=5)$ 由全概率公式给出：\n$$\nP(K=5) = P(K=5 \\mid S) P(S) + P(K=5 \\mid D) P(D)\n$$\n条件概率（或称似然）由泊松概率质量函数给出。\n对于假设 $S$，有 $\\lambda_S = 8$：\n$$\nP(K=5 \\mid S) = \\frac{\\lambda_S^5 \\exp(-\\lambda_S)}{5!} = \\frac{8^5 \\exp(-8)}{120}\n$$\n对于假设 $D$，有 $\\lambda_D = 0.5$：\n$$\nP(K=5 \\mid D) = \\frac{\\lambda_D^5 \\exp(-\\lambda_D)}{5!} = \\frac{(0.5)^5 \\exp(-0.5)}{120}\n$$\n因此，后验概率 $p_{\\text{posterior}} = P(S \\mid K=5)$ 为：\n$$\np_{\\text{posterior}} = \\frac{P(K=5 \\mid S) P(S)}{P(K=5 \\mid S) P(S) + P(K=5 \\mid D) P(D)}\n$$\n代入似然表达式以及先验概率 $P(S)=0.2$ 和 $P(D)=0.8$：\n$$\np_{\\text{posterior}} = \\frac{\\frac{8^5 \\exp(-8)}{120} \\times 0.2}{\\frac{8^5 \\exp(-8)}{120} \\times 0.2 + \\frac{(0.5)^5 \\exp(-0.5)}{120} \\times 0.8}\n$$\n分子和分母中的项 $1/120$ 可以消去：\n$$\np_{\\text{posterior}} = \\frac{8^5 \\exp(-8) \\times 0.2}{8^5 \\exp(-8) \\times 0.2 + (0.5)^5 \\exp(-0.5) \\times 0.8}\n$$\n让我们计算各项：\n$8^5 \\exp(-8) = 32768 \\times \\exp(-8) \\approx 32768 \\times 0.00033546 = 10.9936$\n$(0.5)^5 \\exp(-0.5) = 0.03125 \\times \\exp(-0.5) \\approx 0.03125 \\times 0.60653 = 0.018954$\n$$\np_{\\text{posterior}} \\approx \\frac{10.9936 \\times 0.2}{10.9936 \\times 0.2 + 0.018954 \\times 0.8} = \\frac{2.19872}{2.19872 + 0.015163} = \\frac{2.19872}{2.213883} \\approx 0.9931499\n$$\n这就得到了重叠群来自同一分类单元的后验概率。现在我们可以计算后验熵 $H_{\\text{posterior}}$：\n$$\nH_{\\text{posterior}} = H(p_{\\text{posterior}}) \\approx H(0.99315) = -\\left[0.99315 \\log_{2}(0.99315) + (1-0.99315)\\log_{2}(1-0.99315)\\right]\n$$\n令 $p_{\\text{post}} \\approx 0.99315$ 且 $1-p_{\\text{post}} \\approx 0.00685$。\n$$\nH_{\\text{posterior}} \\approx -\\frac{1}{\\ln(2)} \\left[0.99315 \\ln(0.99315) + 0.00685 \\ln(0.00685)\\right]\n$$\n$$\nH_{\\text{posterior}} \\approx -\\frac{1}{0.693147} \\left[0.99315(-0.00687) + 0.00685(-4.9836)\\right] \\approx -\\frac{-0.00682 - 0.03414}{0.693147} \\approx \\frac{0.04096}{0.693147} \\approx 0.059101 \\text{ 比特}\n$$\n最后，信息增益 $\\Delta I$ 是先验熵与后验熵之差：\n$$\n\\Delta I = H_{\\text{prior}} - H_{\\text{posterior}} \\approx 0.721928 - 0.059101 = 0.662827\n$$\n将结果四舍五入到四位有效数字，得到 $0.6628$。",
            "answer": "$$\n\\boxed{0.6628}\n$$"
        },
        {
            "introduction": "分箱的一个主要挑战是区分亲缘关系近的物种，或基因组组成恰好相似的物种。这个练习模拟了一个这样的“神秘”物种，其GC含量恰好是群落中两种最丰富生物的加权平均值。你将实现一个简单的基于GC含量的分箱规则，并使用准确率（accuracy）和阳性预测值（PPV）等标准分类指标来评估其性能。这项实践将帮助你理解基于组成特征方法（composition-based methods）的局限性，以及在复杂群落中对分箱质量进行定量评估的重要性。",
            "id": "2433879",
            "problem": "给定一个简化的概率模型，该模型仅基于鸟嘌呤-胞嘧啶 (GC) 含量对宏基因组读数进行物种分箱。考虑一个由 $n$ 个生物组成的集合，索引为 $i \\in \\{1,\\dots,n\\}$，每个生物都有一个 GC 概率 $p_i \\in (0,1)$ 和一个严格为正的归一化前丰度权重 $w_i \\in \\mathbb{R}_{>0}$。读数是长度固定为 $L \\in \\mathbb{N}$ 的独立同分布序列。对于来自生物 $i$ 的一个读数，每个碱基以概率 $p_i$ 独立地抽取为 G 或 C，以概率 $1 - p_i$ 抽取为 A 或 T，其中 G/C 对内和 A/T 对内的选择是等概率的。\n\n定义长度为 $L$ 的读数中 GC 碱基的数量为随机变量 $K$，因此，对于生物 $i$，$K \\sim \\mathrm{Binomial}(L, p_i)$。每个读数的 GC 分数是 $r = K / L$。\n\n引入一个额外的生物，称为隐匿生物，其归一化前丰度权重为 $w_c \\in \\mathbb{R}_{>0}$，GC 概率 $p_c$ 定义为两个丰度最高的原始生物的 GC 概率的加权平均值。设 $a$ 和 $b$ 是集合 $\\{w_1,\\dots,w_n\\}$ 中两个最大元素的索引，若出现平局，则选择较小的索引。那么\n$$\np_c \\;=\\; \\frac{w_a\\,p_a + w_b\\,p_b}{w_a + w_b}.\n$$\n添加隐匿生物后，将所有丰度权重（包括 $w_c$）除以总和进行归一化，使得归一化后的权重总和为 $1$。\n\n定义一个分箱规则，将 GC 分数为 $r$ 的读数分配给生物索引\n$$\n\\hat{\\imath}(r) \\;=\\; \\arg\\min_{j \\in \\{1,\\dots,n,n+1\\}} \\big| r - p_j \\big|,\n$$\n其中 $j = n+1$ 表示隐匿生物，若出现平局，则选择最小的索引。\n\n定义以下量：\n- 总体期望准确率，\n$$\n\\mathrm{ACC} \\;=\\; \\sum_{i=1}^{n+1} \\tilde{w}_i \\cdot \\sum_{k=0}^{L} \\Pr(K=k \\mid i)\\, \\mathbf{1}\\!\\left(\\hat{\\imath}\\!\\left(\\frac{k}{L}\\right) = i\\right),\n$$\n其中 $\\tilde{w}_i$ 是归一化权重，$\\Pr(K=k \\mid i) = \\binom{L}{k} p_i^{k} (1-p_i)^{L-k}$。\n- 隐匿生物分箱的阳性预测值 (PPV)，\n$$\n\\mathrm{PPV}_c = \\begin{cases}\n\\displaystyle \\frac{\\tilde{w}_{c} \\cdot \\sum_{k=0}^{L} \\Pr(K=k \\mid c) \\, \\mathbf{1}\\!\\left(\\hat{\\imath}\\!\\left(\\frac{k}{L}\\right) = c\\right)}{\\sum_{j=1}^{n+1} \\tilde{w}_{j} \\cdot \\sum_{k=0}^{L} \\Pr(K=k \\mid j) \\, \\mathbf{1}\\!\\left(\\hat{\\imath}\\!\\left(\\frac{k}{L}\\right) = c\\right)}  \\text{若分母非零} \\\\\n0  \\text{若分母为零}\n\\end{cases}\n$$\n- 隐匿生物读数被错分到两个丰度最高的原始生物 $a$ 和 $b$ 的概率，\n$$\nm_{c \\to a} \\;=\\; \\sum_{k=0}^{L} \\Pr(K=k \\mid c)\\, \\mathbf{1}\\!\\left(\\hat{\\imath}\\!\\left(\\frac{k}{L}\\right) = a\\right), \\qquad\nm_{c \\to b} \\;=\\; \\sum_{k=0}^{L} \\Pr(K=k \\mid c)\\, \\mathbf{1}\\!\\left(\\hat{\\imath}\\!\\left(\\frac{k}{L}\\right) = b\\right).\n$$\n\n你的任务是编写一个完整的程序，对于下面指定的每个测试用例，构建隐匿生物，归一化丰度，对所有 $k \\in \\{0,\\dots,L\\}$ 使用 $r = k/L$ 应用分箱规则，并计算四个指标 $\\mathrm{ACC}$、$\\mathrm{PPV}_c$、$m_{c \\to a}$ 和 $m_{c \\to b}$。所有浮点数结果必须四舍五入到 $6$ 位小数。此问题中没有物理单位。\n\n测试套件：\n- 测试用例 1：\n  - 原始 GC 概率：$[0.35,\\, 0.62,\\, 0.48]$。\n  - 原始归一化前丰度：$[0.5,\\, 0.3,\\, 0.2]$。\n  - 隐匿生物归一化前丰度：$0.1$。\n  - 读数长度：$L = 100$。\n- 测试用例 2：\n  - 原始 GC 概率：$[0.49,\\, 0.5,\\, 0.61,\\, 0.39]$。\n  - 原始归一化前丰度：$[0.4,\\, 0.35,\\, 0.15,\\, 0.10]$。\n  - 隐匿生物归一化前丰度：$0.2$。\n  - 读数长度：$L = 60$。\n- 测试用例 3：\n  - 原始 GC 概率：$[0.2,\\, 0.8]$。\n  - 原始归一化前丰度：$[0.55,\\, 0.45]$。\n  - 隐匿生物归一化前丰度：$0.2$。\n  - 读数长度：$L = 30$。\n\n最终输出格式：\n- 你的程序必须生成单行输出，其中包含三个测试用例的结果，格式为方括号括起来的逗号分隔列表。每个测试用例的结果本身必须是一个包含四个浮点数 $[\\mathrm{ACC},\\, \\mathrm{PPV}_c,\\, m_{c \\to a},\\, m_{c \\to b}]$ 的列表，每个浮点数四舍五入到 $6$ 位小数。例如：$[[x_{11},x_{12},x_{13},x_{14}],[x_{21},x_{22},x_{23},x_{24}],[x_{31},x_{32},x_{33},x_{34}]]$。",
            "solution": "问题陈述是有效的。它在计算生物学领域具有科学依据，在数学上是适定的，并且有客观的定义。为求得唯一解所需的所有数据、公式和条件都已提供。该模型虽然经过简化，但对基于 GC 含量的物种分箱问题提供了一致的表示，并且所要求的指标是分类任务的标准性能度量。该问题没有矛盾、歧义或伪科学主张。\n\n我们将采用系统性的解决方案。对于每个测试用例，整个过程包括三个主要阶段：首先，构建包括隐匿生物在内的完整生物集合；其次，根据 GC 含量确定分箱规则；第三，使用此规则和给定的概率模型计算指定的性能指标。\n\n我们用索引 $j \\in \\{1, \\dots, n\\}$ 表示原始生物的集合。隐匿生物将用索引 $c = n+1$ 表示。\n\n**1. 构建完整生物集合**\n\n给定一个由 $n$ 个原始生物组成的集合，其 GC 概率为 $\\{p_1, \\dots, p_n\\}$，归一化前权重为 $\\{w_1, \\dots, w_n\\}$。\n\n首先，我们确定 $\\{w_1, \\dots, w_n\\}$ 中两个最大权重对应的索引 $a, b \\in \\{1, \\dots, n\\}$。按规定，若出现平局，则选择较小的索引。\n\n引入索引为 $c=n+1$ 的隐匿生物。其归一化前丰度权重给定为 $w_c = w_{n+1}$，其 GC 概率 $p_c = p_{n+1}$ 计算为两个丰度最高的原始生物的 GC 概率的加权平均值：\n$$\np_c = \\frac{w_a p_a + w_b p_b}{w_a + w_b}\n$$\n这样就得到了一个包含 $n+1$ 个生物的完整集合。完整的 GC 概率集合是 $P = \\{p_1, \\dots, p_n, p_{n+1}\\}$，完整的归一化前丰度权重集合是 $W = \\{w_1, \\dots, w_n, w_{n+1}\\}$。\n\n接下来，将所有丰度权重归一化，使其总和为 $1$。每个生物 $j \\in \\{1, \\dots, n+1\\}$ 的归一化丰度 $\\tilde{w}_j$ 为：\n$$\n\\tilde{w}_j = \\frac{w_j}{\\sum_{i=1}^{n+1} w_i}\n$$\n\n**2. 概率模型和分箱规则**\n\n模型指出，对于来自生物 $j$ 的长度为 $L$ 的读数，GC 碱基的数量 $K$ 是一个遵循二项分布的随机变量，$K \\sim \\mathrm{Binomial}(L, p_j)$。对于特定的 GC 计数 $k \\in \\{0, \\dots, L\\}$，其概率质量函数 (PMF) 由以下公式给出：\n$$\n\\Pr(K=k \\mid j) = \\binom{L}{k} p_j^k (1-p_j)^{L-k}\n$$\n我们将为每个生物 $j \\in \\{1, \\dots, n+1\\}$ 和每个可能的 GC 计数 $k$ 计算这些概率。\n\n读数根据其每个读数的 GC 分数 $r = k/L$ 被分配到一个物种分箱中。分箱规则将读数分配给其特征 GC 概率与读数 GC 分数最接近的生物。分配的索引 $\\hat{\\imath}(r)$ 由以下公式确定：\n$$\n\\hat{\\imath}(r) = \\arg\\min_{j \\in \\{1, \\dots, n+1\\}} |r - p_j|\n$$\n在此最小化过程中，若出现平局，则选择最小的生物索引 $j$。我们对从 $0$ 到 $L$ 的所有可能整数值 $k$ 预先计算这个分配 $\\hat{\\imath}(k/L)$。\n\n**3. 指标计算**\n\n在确定了归一化丰度 $\\tilde{w}_j$、二项概率 $\\Pr(K=k \\mid j)$ 和分箱分配 $\\hat{\\imath}(k/L)$ 之后，我们计算四个所需的指标。\n\n**总体期望准确率 (ACC):** 该指标表示从宏基因组中随机抽取一个读数被正确分类的概率。它通过将每个生物的正确分类概率按其归一化丰度加权求和来计算。\n$$\n\\mathrm{ACC} = \\sum_{j=1}^{n+1} \\tilde{w}_j \\cdot P(\\text{correctly classified}|j) = \\sum_{j=1}^{n+1} \\tilde{w}_j \\left( \\sum_{k=0}^{L} \\Pr(K=k \\mid j) \\mathbf{1}\\!\\left[\\hat{\\imath}(k/L) = j\\right] \\right)\n$$\n其中 $\\mathbf{1}[\\cdot]$ 是指示函数，当条件为真时其值为 $1$，否则为 $0$。\n\n**隐匿生物分箱的阳性预测值 (PPV$_c$):** 隐匿生物分箱（索引 $c$）的 PPV 是指被分配到隐匿生物分箱的读数真正来源于隐匿生物的概率。它是该分箱的真阳性与总（真和假）阳性的比率。\n$$\n\\mathrm{PPV}_c = \\frac{\\text{Prob(is } c \\text{ AND binned as } c)}{\\text{Prob(binned as } c)} = \\frac{\\tilde{w}_{c} \\sum_{k=0}^{L} \\Pr(K=k \\mid c) \\, \\mathbf{1}\\!\\left[\\hat{\\imath}(k/L) = c\\right]}{\\sum_{j=1}^{n+1} \\tilde{w}_{j} \\sum_{k=0}^{L} \\Pr(K=k \\mid j) \\, \\mathbf{1}\\!\\left[\\hat{\\imath}(k/L) = c\\right]}\n$$\n如果分母为零（即，没有任何读数被分箱到 $c$），则 $\\mathrm{PPV}_c$ 定义为 $0$。\n\n**错分概率 ($m_{c \\to a}$ 和 $m_{c \\to b}$):** 这些是源自隐匿生物 $c$ 的读数被分别错分到生物 $a$ 或生物 $b$ 的分箱中的总概率（其中 $a$ 和 $b$ 是两个丰度最高的原始生物的索引）。\n$$\nm_{c \\to a} = \\sum_{k=0}^{L} \\Pr(K=k \\mid c) \\mathbf{1}\\!\\left[\\hat{\\imath}(k/L) = a\\right]\n$$\n$$\nm_{c \\to b} = \\sum_{k=0}^{L} \\Pr(K=k \\mid c) \\mathbf{1}\\!\\left[\\hat{\\imath}(k/L) = b\\right]\n$$\n\n实现过程将对三个测试用例中的每一个应用此完整流程，并按要求将最终数值结果四舍五入到 $6$ 位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import binom\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n\n    def calculate_metrics(p_orig, w_orig, w_c, L):\n        \"\"\"\n        Calculates the four specified metrics for a single test case.\n        \"\"\"\n        p_orig = np.array(p_orig)\n        w_orig = np.array(w_orig)\n        n = len(p_orig)\n\n        # 1. Identify the two most abundant original organisms\n        # Sort by weight (desc) and then index (asc) for tie-breaking\n        orig_indices = np.arange(n)\n        sorted_indices = sorted(orig_indices, key=lambda i: (-w_orig[i], i))\n        idx_a, idx_b = sorted_indices[0], sorted_indices[1]\n\n        # 2. Define the cryptic organism and the full set of organisms\n        p_a, p_b = p_orig[idx_a], p_orig[idx_b]\n        w_a, w_b = w_orig[idx_a], w_orig[idx_b]\n        p_c = (w_a * p_a + w_b * p_b) / (w_a + w_b)\n        idx_c = n\n\n        p_full = np.append(p_orig, p_c)\n        w_prenorm = np.append(w_orig, w_c)\n\n        # 3. Normalize abundance weights\n        w_norm = w_prenorm / np.sum(w_prenorm)\n        \n        # 4. Pre-compute binomial PMFs\n        # pmfs[j, k] = P(K=k | organism j)\n        k_values = np.arange(L + 1)\n        pmfs = np.zeros((n + 1, L + 1))\n        for j in range(n + 1):\n            pmfs[j, :] = binom.pmf(k_values, L, p_full[j])\n\n        # 5. Determine binning rule assignments for each possible GC count k\n        r_values = k_values / L\n        binned_to = np.zeros(L + 1, dtype=int)\n        for k_idx, r in enumerate(r_values):\n            dists = np.abs(r - p_full)\n            min_dist = np.min(dists)\n            # Use isclose for robust floating point comparison\n            tied_indices = np.where(np.isclose(dists, min_dist))[0]\n            binned_to[k_idx] = np.min(tied_indices)\n\n        # 6. Calculate the four metrics\n        \n        # ACC\n        acc = 0.0\n        # C[j] = P(correctly classified | organism j)\n        C = np.zeros(n + 1)\n        for j in range(n + 1):\n            correctly_binned_mask = (binned_to == j)\n            C[j] = np.sum(pmfs[j, correctly_binned_mask])\n            acc += w_norm[j] * C[j]\n\n        # PPV_c\n        # Numerator: Prob(is cryptic AND binned as cryptic)\n        num_ppv_c = w_norm[idx_c] * C[idx_c]\n        \n        # Denominator: Prob(binned as cryptic)\n        binned_to_c_mask = (binned_to == idx_c)\n        denom_ppv_c = 0.0\n        for j in range(n + 1):\n            denom_ppv_c += w_norm[j] * np.sum(pmfs[j, binned_to_c_mask])\n        \n        ppv_c = num_ppv_c / denom_ppv_c if denom_ppv_c  0 else 0.0\n\n        # m_c-a and m_c-b\n        binned_to_a_mask = (binned_to == idx_a)\n        m_c_to_a = np.sum(pmfs[idx_c, binned_to_a_mask])\n        \n        binned_to_b_mask = (binned_to == idx_b)\n        m_c_to_b = np.sum(pmfs[idx_c, binned_to_b_mask])\n\n        # Round all results to 6 decimal places\n        return [\n            round(acc, 6),\n            round(ppv_c, 6),\n            round(m_c_to_a, 6),\n            round(m_c_to_b, 6)\n        ]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"p_orig\": [0.35, 0.62, 0.48],\n            \"w_orig\": [0.5, 0.3, 0.2],\n            \"w_c\": 0.1,\n            \"L\": 100\n        },\n        {\n            \"p_orig\": [0.49, 0.5, 0.61, 0.39],\n            \"w_orig\": [0.4, 0.35, 0.15, 0.10],\n            \"w_c\": 0.2,\n            \"L\": 60\n        },\n        {\n            \"p_orig\": [0.2, 0.8],\n            \"w_orig\": [0.55, 0.45],\n            \"w_c\": 0.2,\n            \"L\": 30\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        res = calculate_metrics(**case)\n        results.append(res)\n\n    # Final print statement in the exact required format.\n    formatted_case_results = []\n    for case_res in results:\n        res_str = f\"[{','.join(map(str, case_res))}]\"\n        formatted_case_results.append(res_str)\n    \n    final_output_str = f\"[{','.join(formatted_case_results)}]\"\n    print(final_output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "现实世界中的分箱工具通常采用混合策略，将快速但特异性较低的方法与慢速但更精确的方法结合起来，这是一个经典的速度与准确性的权衡。本练习要求你构建一个两阶段的分箱流程，以体现这种设计思想。第一阶段使用快速的 $k$-mer 相似性来生成候选分类，第二阶段则利用精确的蛋白质结构域（protein domain）的 Smith-Waterman 比对进行验证。通过实现这种混合式分箱器，你将在设计和整合生物信息学算法以形成一个连贯的工作流程方面获得实践经验，这是计算生物学中的一项核心技能。",
            "id": "2433908",
            "problem": "给定一个有限的分类单元集合，每个分类单元由一条脱氧核糖核酸 (DNA) 参考序列和一个蛋白质域特征序列定义。您必须实现一个两阶段决策函数，该函数将每个输入的 DNA 读段映射到一个唯一的分类单元索引或一个未分配值。所有步骤都必须严格按照下文定义实现，且仅能使用所提供的参数和定义。DNA 的字母表为 $\\{A,C,G,T\\}$，蛋白质字母表为 $20$ 种标准氨基酸外加终止符号 $*$。\n\n阶段 1 (快速集合相似度预筛选)：对于一个 DNA 字符串 $s$ 和一个正整数 $k$，将 $k$-mer 集合 $K(s,k)$ 定义为 $s$ 的所有长度为 $k$ 的子字符串（包括重叠的子字符串）的集合。对于一个读段 $r$ 和一个参考基因组 $g_i$，定义 Jaccard 相似度\n$$\nJ_k(r,g_i) \\coloneqq \\frac{\\lvert K(r,k)\\cap K(g_i,k)\\rvert}{\\lvert K(r,k)\\cup K(g_i,k)\\rvert}.\n$$\n给定一个阈值 $\\tau_k$ 和一个最大候选数 $m$，为读段 $r$ 定义候选集 $C(r)$ 如下：\n- 对每个分类单元索引 $i$ 计算 $J_k(r,g_i)$。\n- 令 $S_{\\ge}(r) \\coloneqq \\{ i : J_k(r,g_i) \\ge \\tau_k \\}$。如果 $\\lvert S_{\\ge}(r)\\rvert = 0$，则将 $C(r)$ 设置为具有最大 $J_k(r,g_i)$ 值的 $m$ 个索引的集合，若值相等则优先选择较小的索引。否则，将 $C(r)$ 设置为 $S_{\\ge}(r)$ 中具有最大 $J_k(r,g_i)$ 值的最多 $m$ 个索引的子集，若值相等则优先选择较小的索引。如果 $\\lvert S_{\\ge}(r)\\rvert  m$，则 $\\lvert C(r)\\rvert = \\lvert S_{\\ge}(r)\\rvert$。\n\n阶段 2 (通过局部比对进行慢速域级别验证)：将 DNA 读段 $r$ 的翻译 $\\mathcal{T}(r)$ 定义为：使用标准遗传密码，从其第一个核苷酸开始沿正向以三核苷酸密码子长度进行翻译所得到的氨基酸序列，忽略任何末尾不完整的密码子（如果 $r$ 的长度不能被 $3$ 整除）。终止密码子翻译为 $*$，且 $*$ 被视为一个字面字符。设 $d_i$ 为分类单元 $i$ 的蛋白质域特征序列。\n\n对于两个蛋白质字符串 $x$ 和 $y$，定义使用以下线性计分法的 Smith–Waterman 局部比对得分 $SW(x,y)$：\n- 匹配得分 $s_{\\mathrm{match}} = +2$，\n- 错配得分 $s_{\\mathrm{mismatch}} = -1$，\n- 每个空位符号的空位罚分 $s_{\\mathrm{gap}} = -2$，\n以及动态规划递推式\n$$\nH_{a,b} \\coloneqq \\max\\Big(0,\\ H_{a-1,b-1} + \\sigma(x_a,y_b),\\ H_{a-1,b} + s_{\\mathrm{gap}},\\ H_{a,b-1} + s_{\\mathrm{gap}}\\Big),\n$$\n其中 $H_{0,b} = 0$ 且 $H_{a,0} = 0$ 对所有 $a,b$ 成立，并且\n$$\n\\sigma(u,v) \\coloneqq\n\\begin{cases}\ns_{\\mathrm{match}}  \\text{若 } u=v,\\\\\ns_{\\mathrm{mismatch}}  \\text{若 } u\\ne v.\n\\end{cases}\n$$\n局部比对得分为 $\\max_{a,b} H_{a,b}$。\n\n分配规则：对于一个读段 $r$，计算 $x=\\mathcal{T}(r)$，并对 $C(r)$ 中的每个 $i$ 计算 $SW(x,d_i)$。设 $i^\\star$ 为 $C(r)$ 中具有最大 $SW(x,d_i)$ 值的索引；若值相等则选择较小的索引。给定一个域得分阈值 $\\tau_d$，如果 $SW(x,d_{i^\\star}) \\ge \\tau_d$，则输出 $i^\\star$；否则输出 $-1$。\n\n所有索引都是从零开始的整数。未分配值为整数 $-1$。\n\n所有计算中使用的参数：\n- $k = 3$，\n- $\\tau_k = 0.2$，\n- $m = 2$，\n- $s_{\\mathrm{match}} = +2$，\n- $s_{\\mathrm{mismatch}} = -1$，\n- $s_{\\mathrm{gap}} = -2$，\n- $\\tau_d = 4$。\n\n分类单元和序列：\n- 分类单元 $0$：参考基因组 $g_0 = \\texttt{ATGGCCATTGTAATGGGCCGCTGAAAGGGTGCCCGATAG}$，蛋白质域 $d_0 = \\texttt{MAIVMGRKG}$。\n- 分类单元 $1$：参考基因组 $g_1 = \\texttt{ATGGCGGCTGCTGCTGAAAACCCGTTGAATGCCGCCGAA}$，蛋白质域 $d_1 = \\texttt{MAAAAAK}$。\n- 分类单元 $2$：参考基因组 $g_2 = \\texttt{TTGAAACCCGGGTTTAAACCCGGGTTTAAAGGGCCCAA}$，蛋白质域 $d_2 = \\texttt{MKTLLILAL}$。\n\n遗传密码：使用标准遗传密码，从核苷酸位置 $1$ 开始在正向读码框中进行翻译；忽略任何末尾不构成完整密码子的 $1$ 或 $2$ 个核苷酸。\n\n测试集 (读段)：\n- 读段 $r_1 = \\texttt{ATGGCCATTGTAATGGGCCGCTG}$，\n- 读段 $r_2 = \\texttt{ATGGCGGCTGCTGCT}$，\n- 读段 $r_3 = \\texttt{TTTTTTTTTTTTTTT}$，\n- 读段 $r_4 = \\texttt{ATGGCC}$。\n\n您的程序必须按 $(r_1,r_2,r_3,r_4)$ 的顺序处理这些读段，并生成一行输出，其中包含一个用方括号括起来的、以逗号分隔的整数分配结果列表（例如，$\\texttt{[0,1,-1,0]}$）。对每个读段，唯一允许的输出是 $-1$、$0$、$1$ 或 $2$。",
            "solution": "该任务指定了一个两阶段映射，将每个 DNA 读段映射到一个分类单元索引或未分配值。解决方案通过将每个阶段形式化，并将其确定性地应用于所提供的输入来执行。\n\n阶段 1 形式化：对于固定的 $k=3$， $k$-mer 集合 $K(s,3)$ 包含 $s$ 中所有长度为 $3$ 的连续子字符串。Jaccard 相似度为 $J_3(r,g_i) = \\lvert K(r,3)\\cap K(g_i,3)\\rvert / \\lvert K(r,3)\\cup K(g_i,3)\\rvert$。对于每个读段 $r$，我们计算 $i\\in\\{0,1,2\\}$ 的 $J_3(r,g_i)$。我们定义集合 $S_{\\ge}(r)=\\{i: J_3(r,g_i)\\ge \\tau_k\\}$，其中 $\\tau_k = 0.2$。如果 $\\lvert S_{\\ge}(r)\\rvert = 0$，则 $C(r)$ 包含具有最大 $J_3(r,g_i)$ 值的 $m=2$ 个索引，若值相等则选择较小的索引。否则，$C(r)$ 包含 $S_{\\ge}(r)$ 中具有最大 $J_3(r,g_i)$ 值的最多 $m$ 个索引，若值相等则选择较小的索引；如果 $S_{\\ge}(r)$ 中的索引少于 $m$ 个，则全部包含在内。\n\n阶段 2 形式化：我们使用标准遗传密码，从第一个核苷酸开始在正向读码框中翻译每个 DNA 读段，并忽略任何末尾不完整的密码子。这会产生 $x=\\mathcal{T}(r)$。对于每个候选 $i\\in C(r)$，我们使用递推式\n$$\nH_{a,b} = \\max\\left(0,\\,H_{a-1,b-1} + \\sigma(x_a,y_b),\\,H_{a-1,b} + s_{\\mathrm{gap}},\\,H_{a,b-1} + s_{\\mathrm{gap}}\\right),\n$$\n计算 Smith–Waterman 局部比对得分 $SW(x,d_i)$，其中 $y=d_i$，$s_{\\mathrm{match}}=+2$，$s_{\\mathrm{mismatch}}=-1$，且 $s_{\\mathrm{gap}}=-2$。计分函数 $\\sigma(u,v)$ 在 $u=v$ 时为 $+2$，否则为 $-1$。局部得分为 $\\max_{a,b} H_{a,b}$。我们找出 $C(r)$ 中使 $SW(x,d_i)$ 最大化的 $i^\\star$，若值相等则选择较小的索引。当 $\\tau_d=4$ 时，如果 $SW(x,d_{i^\\star})\\ge 4$，我们分配 $i^\\star$；否则输出 $-1$。\n\n应用于给定的测试集：\n\n- 读段 $r_1 = \\texttt{ATGGCCATTGTAATGGGCCGCTG}$。在正向读码框中翻译得到 $\\mathcal{T}(r_1) = \\texttt{MAIVMGR}$，因为密码子为 $\\texttt{ATG}\\to \\texttt{M}$、$\\texttt{GCC}\\to \\texttt{A}$、$\\texttt{ATT}\\to \\texttt{I}$、$\\texttt{GTA}\\to \\texttt{V}$、$\\texttt{ATG}\\to \\texttt{M}$、$\\texttt{GGC}\\to \\texttt{G}$、$\\texttt{CGC}\\to \\texttt{R}$，末尾的 $\\texttt{TG}$ 被忽略。由于 $r_1$ 是 $g_0$ 的子字符串，$r_1$ 的 $3$-mer 集合与 $K(g_0,3)$ 有显著重叠，因此 $J_3(r_1,g_0)$ 相对于 $J_3(r_1,g_1)$ 和 $J_3(r_1,g_2)$ 很大。因此 $0\\in C(r_1)$，且 $C(r_1)$ 将最多包含另一个索引。局部比对 $SW(\\texttt{MAIVMGR}, \\texttt{MAIVMGRKG})$ 产生一个长度为 $7$ 的完美连续匹配，得分为 $7\\times 2=14$。与 $d_1=\\texttt{MAAAAAK}$ 或 $d_2=\\texttt{MKTLLILAL}$ 的任何比对最多是一个短的前缀匹配；对于 $d_1$，最佳连续匹配是 $\\texttt{MA}$，得分为 $2\\times 2=4$；对于 $d_2$，最多是 $\\texttt{M}$，得分为 $2$。因此 $i^\\star=0$ 且 $SW\\ge 4$，所以分配结果为 $0$。\n\n- 读段 $r_2 = \\texttt{ATGGCGGCTGCTGCT}$。翻译得到 $\\mathcal{T}(r_2)=\\texttt{MAAAA}$，源于 $\\texttt{ATG}\\to \\texttt{M}$、$\\texttt{GCG}\\to \\texttt{A}$、$\\texttt{GCT}\\to \\texttt{A}$、$\\texttt{GCT}\\to \\texttt{A}$、$\\texttt{GCT}\\to \\texttt{A}$。其 $3$-mer 内容与 $K(g_1,3)$ 的重叠比与 $K(g_0,3)$ 或 $K(g_2,3)$ 的重叠更强，所以 $1\\in C(r_2)$（可能因为 $m=2$ 而有另一个索引）。比对 $SW(\\texttt{MAAAA}, \\texttt{MAAAAAK})$ 产生一个长度为 $5$ 的连续匹配，得分为 $10$。与 $d_0$ 或 $d_2$ 的比对由于共享前缀较短，得分最多为 $4$ 或更低。因此 $i^\\star=1$，得分为 $10 \\ge 4$，所以分配结果为 $1$。\n\n- 读段 $r_3 = \\texttt{TTTTTTTTTTTTTTT}$。翻译产生 $\\mathcal{T}(r_3)=\\texttt{FFFFF}$，因为 $\\texttt{TTT}\\to \\texttt{F}$ 重复出现。$3$-mer 集合 $K(r_3,3)=\\{\\texttt{TTT}\\}$ 与 $K(g_0,3)$ 和 $K(g_1,3)$ 的重叠极小，与 $K(g_2,3)$ 有一些重叠（如果 $\\texttt{TTT}$ 出现的话），但无论 $C(r_3)$ 的构成如何（受限于 $m=2$），对于 $i\\in C(r_3)$，局部比对得分 $SW(\\texttt{FFFFF}, d_i)$ 都为 $0$，因为 $d_0=\\texttt{MAIVMGRKG}$、$d_1=\\texttt{MAAAAAK}$ 和 $d_2=\\texttt{MKTLLILAL}$ 都不包含 $\\texttt{F}$，任何比对都会累积错配和空位，在以 $0$ 为下限的局部比对递推中没有好处。因此，最佳得分为 $0  \\tau_d$，分配结果为 $-1$。\n\n- 读段 $r_4 = \\texttt{ATGGCC}$。翻译得到 $\\mathcal{T}(r_4)=\\texttt{MA}$。$r_4$ 的 $3$-mer 为 $\\{\\texttt{ATG},\\texttt{TGG},\\texttt{GGC},\\texttt{GCC}\\}$，与 $K(g_0,3)$ 和 $K(g_1,3)$ 都有重叠，因此在应用 $m=2$ 的上限和 $\\tau_k$ 阈值后，$C(r_4)$ 将包含索引 $\\{0,1\\}$。局部比对得分 $SW(\\texttt{MA}, \\texttt{MAIVMGRKG})$ 和 $SW(\\texttt{MA}, \\texttt{MAAAAAK})$ 都通过匹配前缀 $\\texttt{MA}$ 达到值 $4$，而 $SW(\\texttt{MA}, \\texttt{MKTLLILAL})$ 则更小。因此，索引 $0$ 和 $1$ 在最高分上出现平局，平局决胜规则选择较小的索引 $0$。由于 $4 \\ge \\tau_d$，分配结果为 $0$。\n\n按 $(r_1,r_2,r_3,r_4)$ 的顺序收集这些结果，得到最终列表 $[0,1,-1,0]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Standard genetic code mapping (forward strand, frame starting at position 0)\nGENETIC_CODE = {\n    'TTT': 'F', 'TTC': 'F', 'TTA': 'L', 'TTG': 'L',\n    'TCT': 'S', 'TCC': 'S', 'TCA': 'S', 'TCG': 'S',\n    'TAT': 'Y', 'TAC': 'Y', 'TAA': '*', 'TAG': '*',\n    'TGT': 'C', 'TGC': 'C', 'TGA': '*', 'TGG': 'W',\n    'CTT': 'L', 'CTC': 'L', 'CTA': 'L', 'CTG': 'L',\n    'CCT': 'P', 'CCC': 'P', 'CCA': 'P', 'CCG': 'P',\n    'CAT': 'H', 'CAC': 'H', 'CAA': 'Q', 'CAG': 'Q',\n    'CGT': 'R', 'CGC': 'R', 'CGA': 'R', 'CGG': 'R',\n    'ATT': 'I', 'ATC': 'I', 'ATA': 'I', 'ATG': 'M',\n    'ACT': 'T', 'ACC': 'T', 'ACA': 'T', 'ACG': 'T',\n    'AAT': 'N', 'AAC': 'N', 'AAA': 'K', 'AAG': 'K',\n    'AGT': 'S', 'AGC': 'S', 'AGA': 'R', 'AGG': 'R',\n    'GTT': 'V', 'GTC': 'V', 'GTA': 'V', 'GTG': 'V',\n    'GCT': 'A', 'GCC': 'A', 'GCA': 'A', 'GCG': 'A',\n    'GAT': 'D', 'GAC': 'D', 'GAA': 'E', 'GAG': 'E',\n    'GGT': 'G', 'GGC': 'G', 'GGA': 'G', 'GGG': 'G',\n}\n\ndef kmer_set(seq: str, k: int):\n    return {seq[i:i+k] for i in range(len(seq) - k + 1)} if len(seq) = k else set()\n\ndef jaccard_kmer(a: str, b: str, k: int) - float:\n    ka = kmer_set(a, k)\n    kb = kmer_set(b, k)\n    if not ka and not kb:\n        return 0.0\n    inter = ka  kb\n    union = ka | kb\n    return len(inter) / len(union) if union else 0.0\n\ndef translate_frame1(dna: str) - str:\n    aa = []\n    n = len(dna) // 3\n    for i in range(n):\n        codon = dna[3*i:3*i+3]\n        aa.append(GENETIC_CODE.get(codon, 'X'))  # 'X' for any unexpected codon (should not happen)\n    return ''.join(aa)\n\ndef smith_waterman(x: str, y: str, match: int = 2, mismatch: int = -1, gap: int = -2) - int:\n    # Local alignment with linear gap penalty\n    n, m = len(x), len(y)\n    # Use a 1D rolling DP to save memory; track max\n    H = [0] * (m + 1)\n    max_score = 0\n    for i in range(1, n + 1):\n        prev_diag = 0\n        for j in range(1, m + 1):\n            temp = H[j]\n            score_sub = match if x[i-1] == y[j-1] else mismatch\n            h_diag = prev_diag + score_sub\n            h_up = H[j] + gap\n            h_left = H[j-1] + gap\n            h_ij = max(0, h_diag, h_up, h_left)\n            H[j] = h_ij\n            prev_diag = temp\n            if h_ij  max_score:\n                max_score = h_ij\n        # reset H[0] to 0 each row (already 0)\n    return max_score\n\ndef select_candidates_by_kmer(read: str, refs: list[str], k: int, tau_k: float, m: int):\n    sims = []\n    for idx, g in enumerate(refs):\n        sims.append((idx, jaccard_kmer(read, g, k)))\n    # Sort by similarity desc, then index asc\n    sims_sorted = sorted(sims, key=lambda t: (-t[1], t[0]))\n    above = [idx for idx, s in sims_sorted if s = tau_k]\n    if len(above) == 0:\n        return [idx for idx, _ in sims_sorted[:m]]\n    else:\n        return above[:m]\n\ndef assign_read(read: str, refs: list[str], domains: list[str],\n                k: int, tau_k: float, m: int, tau_d: int,\n                match: int = 2, mismatch: int = -1, gap: int = -2) - int:\n    candidates = select_candidates_by_kmer(read, refs, k, tau_k, m)\n    aa = translate_frame1(read)\n    best_idx = -1\n    best_score = -1_000_000\n    for idx in candidates:\n        score = smith_waterman(aa, domains[idx], match, mismatch, gap)\n        if score  best_score or (score == best_score and idx  best_idx):\n            best_score = score\n            best_idx = idx\n    if best_idx == -1:\n        return -1\n    return best_idx if best_score = tau_d else -1\n\ndef solve():\n    # Parameters\n    k = 3\n    tau_k = 0.2\n    m = 2\n    match, mismatch, gap = 2, -1, -2\n    tau_d = 4\n\n    # References and domains\n    refs = [\n        \"ATGGCCATTGTAATGGGCCGCTGAAAGGGTGCCCGATAG\",  # g0\n        \"ATGGCGGCTGCTGCTGAAAACCCGTTGAATGCCGCCGAA\",  # g1\n        \"TTGAAACCCGGGTTTAAACCCGGGTTTAAAGGGCCCAA\",   # g2\n    ]\n    domains = [\n        \"MAIVMGRKG\",  # d0\n        \"MAAAAAK\",    # d1\n        \"MKTLLILAL\",  # d2\n    ]\n\n    # Test cases (reads)\n    test_reads = [\n        \"ATGGCCATTGTAATGGGCCGCTG\",   # r1\n        \"ATGGCGGCTGCTGCT\",           # r2\n        \"TTTTTTTTTTTTTTT\",           # r3\n        \"ATGGCC\",                    # r4\n    ]\n\n    results = []\n    for read in test_reads:\n        assign_idx = assign_read(\n            read, refs, domains, k, tau_k, m, tau_d, match, mismatch, gap\n        )\n        results.append(assign_idx)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}