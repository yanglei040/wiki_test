{
    "hands_on_practices": [
        {
            "introduction": "理论知识是基础，但亲手实践才能真正巩固理解。本练习将引导你手动完成Gillespie算法的几个步骤，模拟一个简单的生灭过程。通过这种方式，你可以清晰地看到每一步中倾向性函数如何计算、反应等待时间如何生成、以及下一个反应如何被选择，从而对算法的核心机制建立直观而深刻的认识。",
            "id": "2678033",
            "problem": "考虑一个分子布居 $X(t)$ 的单物种生灭过程，该过程包含两个反应通道：\n- 出生：$X \\to X + 1$，以恒定速率 $\\lambda$ 发生（这等效于 $\\varnothing \\to X$，倾向性为 $\\lambda$）。\n- 死亡：$X \\to X - 1$，发生速率与当前布居成正比，倾向性为 $\\mu X$。\n\n假设 $\\lambda = 2\\,\\mathrm{s^{-1}}$，$\\mu = 0.25\\,\\mathrm{s^{-1}}$ 每分子，以及初始条件 $X(0) = 3$。使用 Gillespie 直接法（也称为随机模拟算法），将每个事件间的等待时间视为一个指数随机变量，其速率等于瞬时总倾向性，并根据与当前倾向性成正比的概率选择下一个反应的通道。为您提供了三对独立的均匀随机种子 $(u_{1,k},u_{2,k})$，其中 $k \\in \\{1,2,3\\}$。对于每个事件 $k$，$u_{1,k}$ 用于对等待时间进行抽样，$u_{2,k}$ 用于选择反应通道：\n- $(u_{1,1},u_{2,1}) = \\big(\\exp(-1.1),\\,0.8\\big)$,\n- $(u_{1,2},u_{2,2}) = \\big(\\exp(-0.05),\\,0.2\\big)$,\n- $(u_{1,3},u_{2,3}) = \\big(\\exp(-0.3),\\,0.55\\big)$.\n\n从时间 $t=0$ 开始，手动执行 Gillespie 直接法的前三个事件，并在每个事件后更新状态 $X$ 和绝对时间。仅使用上述定义，确定第三个反应事件发生的绝对时间 $t_3$。请以秒为单位，用精确值表示您的最终答案。不要四舍五入；如果可能，请提供一个精确的分数。最终答案必须是单个实数。",
            "solution": "对问题陈述进行验证。\n\n**步骤1：提取已知条件**\n- 系统：单物种生灭过程，布居 $X(t)$。\n- 反应与倾向性：\n  - 出生：$X \\to X + 1$（或 $\\varnothing \\to X$），倾向性 $a_1 = \\lambda$。\n  - 死亡：$X \\to X - 1$，倾向性 $a_2 = \\mu X$。\n- 速率常数：\n  - $\\lambda = 2\\,\\mathrm{s^{-1}}$。\n  - $\\mu = 0.25\\,\\mathrm{s^{-1}}$ 每分子。\n- 初始条件：在时间 $t=0$ 时，$X(0) = 3$。\n- 算法：Gillespie 直接法。事件间等待时间 $\\tau$ 从速率为 $a_{total}$（所有倾向性之和）的指数分布中抽样得出。其公式为 $\\tau = \\frac{1}{a_{total}} \\ln(\\frac{1}{u_1})$。下一个反应通道是基于与单个倾向性成正比的概率，使用第二个均匀随机数 $u_2$ 来选择的。\n- 随机种子：用于事件 $k = 1, 2, 3$ 的三对均匀随机种子 $(u_{1,k}, u_{2,k})$：\n  - $(u_{1,1}, u_{2,1}) = (\\exp(-1.1), 0.8)$。\n  - $(u_{1,2}, u_{2,2}) = (\\exp(-0.05), 0.2)$。\n  - $(u_{1,3}, u_{2,3}) = (\\exp(-0.3), 0.55)$。\n- 目标：确定第三个反应事件的绝对时间 $t_3$。\n\n**步骤2：使用提取的已知条件进行验证**\n根据验证标准对问题进行评估。\n- **科学依据**：该问题描述了一个标准的生灭过程，这是随机化学动力学中的一个基本模型。Gillespie 算法是用于此类系统的权威、精确的模拟方法。其表述完全符合既定的科学原理。\n- **良态性**：该问题是良态的。它提供了所有必需的参数、初始条件和特定的随机数序列，以确定性地追踪随机模拟的前三个事件。目标清晰明确。\n- **客观性**：该问题以精确、客观的语言陈述，不含任何主观或非科学内容。\n\n**结论与行动**\n该问题在科学上是合理的、自洽的且良态的。没有可识别的缺陷。因此，该问题是**有效的**。将推导求解过程。\n\n模拟逐个事件进行，在每个步骤中更新系统状态 $(t, X)$。步骤 $k$ 开始时的状态为 $(t_{k-1}, X_{k-1})$。\n\n**初始状态 ($k=0$)：**\n系统在时间 $t_0 = 0$ 开始，初始布居为 $X_0 = 3$。\n\n**事件 1 ($k=1$)：**\n首先，我们根据状态 $(t_0, X_0)$ 计算两个反应通道的倾向性。\n- 出生倾向性：$a_1 = \\lambda = 2$。\n- 死亡倾向性：$a_2 = \\mu X_0 = (0.25) \\cdot 3 = 0.75$。\n\n总倾向性是各个倾向性之和：\n$$a_{total,0} = a_1 + a_2 = 2 + 0.75 = 2.75 = \\frac{11}{4}$$\n第一个事件的等待时间 $\\tau_1$ 使用第一个随机种子 $u_{1,1} = \\exp(-1.1)$ 计算。\n$$\\tau_1 = \\frac{1}{a_{total,0}} \\ln\\left(\\frac{1}{u_{1,1}}\\right) = \\frac{1}{11/4} \\ln\\left(\\frac{1}{\\exp(-1.1)}\\right) = \\frac{4}{11} \\ln(\\exp(1.1)) = \\frac{4}{11} \\cdot (1.1) = \\frac{4.4}{11} = 0.4 = \\frac{2}{5}$$\n第一个事件发生的时间是：\n$$t_1 = t_0 + \\tau_1 = 0 + 0.4 = 0.4$$\n接下来，我们使用第二个随机种子 $u_{2,1} = 0.8$ 来确定发生哪个反应。如果 $u_{2,1} \\le \\frac{a_1}{a_{total,0}}$，则发生出生反应（通道1）。\n$$\\frac{a_1}{a_{total,0}} = \\frac{2}{2.75} = \\frac{2}{11/4} = \\frac{8}{11} \\approx 0.727$$\n由于 $u_{2,1} = 0.8  \\frac{8}{11}$，因此选择死亡反应（通道2）。布居相应更新：\n$$X_1 = X_0 - 1 = 3 - 1 = 2$$\n第一个事件后的状态是 $(t_1, X_1) = (0.4, 2)$。\n\n**事件 2 ($k=2$)：**\n我们从状态 $(t_1, X_1) = (0.4, 2)$ 继续。\n- 出生倾向性：$a_1 = \\lambda = 2$。\n- 死亡倾向性：$a_2 = \\mu X_1 = (0.25) \\cdot 2 = 0.5$。\n\n总倾向性是：\n$$a_{total,1} = a_1 + a_2 = 2 + 0.5 = 2.5 = \\frac{5}{2}$$\n第二个事件的等待时间 $\\tau_2$ 使用 $u_{1,2} = \\exp(-0.05)$ 计算。\n$$\\tau_2 = \\frac{1}{a_{total,1}} \\ln\\left(\\frac{1}{u_{1,2}}\\right) = \\frac{1}{5/2} \\ln\\left(\\frac{1}{\\exp(-0.05)}\\right) = \\frac{2}{5} \\ln(\\exp(0.05)) = \\frac{2}{5} \\cdot (0.05) = \\frac{0.1}{5} = 0.02 = \\frac{1}{50}$$\n第二个事件发生的时间是：\n$$t_2 = t_1 + \\tau_2 = 0.4 + 0.02 = 0.42 = \\frac{42}{100} = \\frac{21}{50}$$\n使用 $u_{2,2} = 0.2$ 选择反应。发生出生反应的条件是 $u_{2,2} \\le \\frac{a_1}{a_{total,1}}$。\n$$\\frac{a_1}{a_{total,1}} = \\frac{2}{2.5} = \\frac{4}{5} = 0.8$$\n由于 $u_{2,2} = 0.2 \\le 0.8$，因此选择出生反应。布居变为：\n$$X_2 = X_1 + 1 = 2 + 1 = 3$$\n第二个事件后的状态是 $(t_2, X_2) = (0.42, 3)$。\n\n**事件 3 ($k=3$)：**\n我们从状态 $(t_2, X_2) = (0.42, 3)$ 继续。布居数量已返回其初始值。\n- 出生倾向性：$a_1 = \\lambda = 2$。\n- 死亡倾向性：$a_2 = \\mu X_2 = (0.25) \\cdot 3 = 0.75$。\n\n总倾向性与第一步相同：\n$$a_{total,2} = a_1 + a_2 = 2 + 0.75 = 2.75 = \\frac{11}{4}$$\n第三个事件的等待时间 $\\tau_3$ 使用 $u_{1,3} = \\exp(-0.3)$ 计算。\n$$\\tau_3 = \\frac{1}{a_{total,2}} \\ln\\left(\\frac{1}{u_{1,3}}\\right) = \\frac{1}{11/4} \\ln\\left(\\frac{1}{\\exp(-0.3)}\\right) = \\frac{4}{11} \\ln(\\exp(0.3)) = \\frac{4}{11} \\cdot (0.3) = \\frac{1.2}{11} = \\frac{12}{110} = \\frac{6}{55}$$\n第三个事件的绝对时间 $t_3$ 是等待时间的累积和：\n$$t_3 = t_2 + \\tau_3 = \\frac{21}{50} + \\frac{6}{55}$$\n为了将这些分数相加，我们找到一个公分母，即 $\\mathrm{lcm}(50, 55) = \\mathrm{lcm}(2 \\cdot 5^2, 5 \\cdot 11) = 2 \\cdot 5^2 \\cdot 11 = 550$。\n$$t_3 = \\frac{21 \\cdot 11}{50 \\cdot 11} + \\frac{6 \\cdot 10}{55 \\cdot 10} = \\frac{231}{550} + \\frac{60}{550} = \\frac{231 + 60}{550} = \\frac{291}{550}$$\n分数 $\\frac{291}{550}$ 是不可约分的，因为分子的质因数是 $291 = 3 \\cdot 97$，而分母的质因数是 $550 = 2 \\cdot 5^2 \\cdot 11$，它们没有公因数。\n\n问题只要求时间 $t_3$。为完整起见，第三个反应将是出生反应，因为 $u_{2,3} = 0.55 \\le \\frac{8}{11}$。\n\n最终答案是第三个事件发生的绝对时间。",
            "answer": "$$\\boxed{\\frac{291}{550}}$$"
        },
        {
            "introduction": "手动计算有助于理解算法原理，但要探索复杂系统的宏观行为，我们必须借助计算机。本练习要求你编写程序，使用Gillespie算法模拟一个经典的自催化反应系统。通过运行大量独立的模拟轨迹，你将能观察到随机性如何导致系统走向两种截然不同的终点——种群爆炸或灭绝，这正是随机模拟在揭示系统内在随机性方面的威力所在。",
            "id": "2430922",
            "problem": "您需要实现精确随机模拟算法 (SSA)，也称为 Gillespie 算法，以研究一个表现出双峰结果的自催化反应网络。该化学系统由两个在充分混合、恒温、恒容条件下的反应组成，并遵循基元质量作用动力学：\n- 反应 $\\mathrm{R}_1$：$A + X \\rightarrow 2X$\n- 反应 $\\mathrm{R}_2$：$X \\rightarrow \\varnothing$\n\n从充分混合的马尔可夫跳跃过程的化学主方程的基本定义和基元步骤的质量作用原理出发。对于一个分子数为 $A$ 和 $X$ 的状态，其反应倾向为：\n- $a_1(A,X) = c \\cdot A \\cdot X$\n- $a_2(A,X) = d \\cdot X$\n\n总倾向为 $a_0(A,X) = a_1(A,X) + a_2(A,X)$。到下一次反应的等待时间是一个均值为 $1/a_0$ 的指数分布随机变量，下一个反应的索引根据与各反应倾向成比例的概率来选择。在有限资源下，该系统表现出两个竞争性吸收边界：\n- 灭绝边界：$X$ 达到 $0$（没有自催化剂来维持增长）。\n- 爆发边界（资源耗尽）：$A$ 达到 $0$（底物在灭绝前完全转化）。\n\n您的任务是为这个双反应系统实现精确的 SSA，并通过重复模拟来估计在固定视界时间 $T_{\\max}$ 内两种结果的经验概率：\n- 灭绝的经验概率是指在时间 $T_{\\max}$ 到达之前、$A$ 达到 $0$ 之前，$X$ 先达到 $0$ 的轨迹所占的比例。\n- 爆发的经验概率是指在时间 $T_{\\max}$ 到达之前、$X$ 达到 $0$ 之前，$A$ 先达到 $0$ 的轨迹所占的比例。\n在时间 $T_{\\max}$ 前未达到任一吸收边界的轨迹不计为任何一种结果。\n\n使用上述定义，实现一个程序，为每个测试用例在固定的随机种子下运行 $N$ 条独立轨迹以确保可复现性，并返回两个浮点数：灭绝的经验概率和爆发的经验概率，每个都四舍五入到三位小数。该算法必须是精确的 Gillespie 方法，在每一步中从速率为 $a_0$ 的指数分布中抽取时间增量 $\\tau$，并根据 $a_1/a_0$ 和 $a_2/a_0$ 来选择反应索引。\n\n测试套件：\n- 案例 $1$（灭绝主导区域）：$(A_0, X_0, c, d, T_{\\max}, N, \\text{seed}) = (60, 3, 0.001, 0.2, 200.0, 2000, 1729)$\n- 案例 $2$（近阈值区域）：$(A_0, X_0, c, d, T_{\\max}, N, \\text{seed}) = (100, 10, 0.005, 0.5, 100.0, 2000, 1733)$\n- 案例 $3$（爆发主导区域）：$(A_0, X_0, c, d, T_{\\max}, N, \\text{seed}) = (200, 5, 0.01, 0.05, 50.0, 2000, 1737)$\n\n实现要求：\n- 使用基于化学主方程和如上所述的质量作用倾向的精确 Gillespie 算法。\n- 对每个案例，从 $(A_0, X_0)$ 开始模拟 $N$ 条轨迹，直到 $A=0$、$X=0$ 或 $t \\ge T_{\\max}$。\n- 完全如上所述定义两种结果。\n- 对每个案例，报告两个浮点数：灭绝的经验概率和爆发的经验概率，每个都四舍五入到三位小数。\n- 最终输出格式：您的程序应生成单行输出，其中包含所有三个测试用例的结果，形式为一个包含六个浮点数的逗号分隔列表，并用方括号括起来。顺序必须是案例 $1$ 的灭绝概率、案例 $1$ 的爆发概率、案例 $2$ 的灭绝概率、案例 $2$ 的爆发概率、案例 $3$ 的灭绝概率、案例 $3$ 的爆发概率。例如：\"[0.913,0.085,0.501,0.495,0.002,0.997]\"。\n- 输出中不需要物理单位，因为概率是无量纲的。所有报告的数字必须是小数，而不是百分数。\n\n您的程序必须是自包含的，无需输入。在为每个案例运行 $N$ 条轨迹之前，必须通过使用提供的种子为随机数生成器设置种子来确定性地复现相同的结果。",
            "solution": "该问题已经过验证并被确认有效。这是一个计算生物学中的良态问题，它基于已确立的随机化学动力学理论，并为获得唯一的、可复现的解提供了所有必要的参数和条件。\n\n任务是使用精确随机模拟算法 (SSA)（通常称为 Gillespie 算法）来模拟一个随机化学系统。该算法生成由化学主方程 (CME) 控制的马尔可夫跳跃过程的统计上正确的轨迹。\n\n该系统包含两种化学物质，底物 $A$ 和自催化剂 $X$，在恒定温度和充分混合的体积内参与两个基元反应：\n1.  $X$ 的自催化生产：$R_1: A + X \\xrightarrow{c} 2X$\n2.  $X$ 的降解：$R_2: X \\xrightarrow{d} \\varnothing$\n\n系统在任意时刻 $t$ 的状态由分子数的整数向量 $\\mathbf{n}(t) = (A(t), X(t))$ 定义。每个反应引起的状态变化由状态改变向量给出：\n- 对于 $R_1$：$\\mathbf{v}_1 = (-1, +1)$，表示一个 $A$ 分子转化为一个 $X$ 分子。\n- 对于 $R_2$：$\\mathbf{v}_2 = (0, -1)$，表示一个 $X$ 分子被移除。\n\n根据基元反应的质量作用动力学原理，每个反应的速率与其反应物数量的乘积成正比。这些速率被定义为倾向函数 $a_j(\\mathbf{n})$：\n- $R_1$ 的倾向：$a_1(A, X) = c \\cdot A \\cdot X$\n- $R_2$ 的倾向：$a_2(X) = d \\cdot X$\n\n总倾向 $a_0(\\mathbf{n})$ 是各个倾向之和，代表任何反应可能发生总速率：\n$$a_0(A, X) = a_1(A, X) + a_2(X) = c \\cdot A \\cdot X + d \\cdot X$$\n\nGillespie 算法是一种精确的模拟方法，它通过在每一步回答两个问题来进行：下一次反应何时发生？以及它将是哪个反应？\n\n1.  **到下一次反应的时间 ($\\tau$)**：对于处于状态 $\\mathbf{n}$ 的系统，到下一次反应事件的时间 $\\tau$ 是一个从速率参数为 $a_0(\\mathbf{n})$ 的指数分布中抽取的随机变量。其概率密度函数为 $p(\\tau | \\mathbf{n}) = a_0(\\mathbf{n}) e^{-a_0(\\mathbf{n})\\tau}$。可以使用逆变换采样法生成 $\\tau$ 的值：\n    $$\\tau = \\frac{1}{a_0(\\mathbf{n})} \\ln\\left(\\frac{1}{r_1}\\right)$$\n    其中 $r_1$ 是从 $(0, 1)$ 上的均匀分布中抽取的一个随机数。\n\n2.  **确定下一个反应 ($\\mu$)**：下一个反应是 $R_j$ 的概率由其倾向与总倾向的比率给出，$P(\\mu=j | \\mathbf{n}) = a_j(\\mathbf{n}) / a_0(\\mathbf{n})$。通过抽取第二个均匀随机数 $r_2 \\in U(0, 1)$ 并找到满足以下条件的最小整数索引 $\\mu$ 来选择具体反应：\n    $$\\sum_{j=1}^{\\mu} a_j(\\mathbf{n})  r_2 \\cdot a_0(\\mathbf{n})$$\n    对于我们的双反应系统，这可以简化为：\n    - 如果 $r_2 \\cdot a_0 \\le a_1$，则下一个反应是 $R_1$。\n    - 否则，下一个反应是 $R_2$。\n\n单个轨迹的逐步模拟如下：\n- **初始化**：设置时间 $t = 0.0$ 和初始分子数 $(A, X) = (A_0, X_0)$。\n- **迭代循环**：当终止条件未满足时：\n    1.  计算倾向 $a_1 = c \\cdot A \\cdot X$ 和 $a_2 = d \\cdot X$，以及总倾向 $a_0 = a_1 + a_2$。\n    2.  如果 $a_0 = 0$，系统处于吸收态（对于此系统，这意味着 $X=0$）。该轨迹的模拟结束。\n    3.  通过从速率为 $a_0$ 的指数分布中抽样来生成时间步长 $\\tau$。\n    4.  检查时间视界：如果下一个事件时间 $t + \\tau$ 大于或等于最大模拟时间 $T_{\\max}$，则轨迹因时间限制而终止。此轨迹不记录任何结果。\n    5.  更新时间：$t \\leftarrow t + \\tau$。\n    6.  根据倾向选择反应 $\\mu$。\n    7.  更新状态：$(A, X) \\leftarrow (A, X) + \\mathbf{v}_{\\mu}$。\n    8.  检查吸收边界：如果 $A = 0$ 或 $X = 0$，轨迹终止。\n\n为了估计经验概率，对 $N$ 条独立轨迹重复此过程。每条轨迹都从相同的初始状态 $(A_0, X_0)$ 开始，但由于随机性而遵循不同的路径。为两种指定的结果各维护一个计数器：\n- **灭绝**：如果一条轨迹因在 $A  0$ 且 $t  T_{\\max}$ 的情况下 $X$ 变为 $0$ 而终止，则计为一个“灭绝”事件。\n- **爆发**：如果一条轨迹因在 $X  0$ 且 $t  T_{\\max}$ 的情况下 $A$ 变为 $0$ 而终止，则计为一个“爆发”（资源耗尽）事件。\n\n在为给定参数集运行所有 $N$ 条轨迹后，经验概率计算为导致每种结果的轨迹所占的比例：\n$$P_{\\text{extinction}} = \\frac{\\text{extinction\\_count}}{N}$$\n$$P_{\\text{explosion}} = \\frac{\\text{explosion\\_count}}{N}$$\n\n为了保证可复现性，在为每个测试用例开始 $N$ 次模拟之前，会使用指定的值为随机数生成器设置种子。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the exact Stochastic Simulation Algorithm (Gillespie algorithm)\n    to study an autocatalytic reaction network and estimate the probabilities\n    of extinction and explosion outcomes.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (A_0, X_0, c, d, T_max, N, seed)\n        (60, 3, 0.001, 0.2, 200.0, 2000, 1729),  # Case 1: extinction-dominated\n        (100, 10, 0.005, 0.5, 100.0, 2000, 1733), # Case 2: near-threshold\n        (200, 5, 0.01, 0.05, 50.0, 2000, 1737),   # Case 3: explosion-dominated\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        A0, X0, c, d, T_max, N, seed = case\n        \n        # Initialize random number generator with the specified seed for reproducibility\n        rng = np.random.default_rng(seed)\n\n        extinction_count = 0\n        explosion_count = 0\n\n        # Run N independent trajectories\n        for _ in range(N):\n            t = 0.0\n            A = A0\n            X = X0\n\n            # Main Gillespie algorithm loop for a single trajectory\n            while True:\n                # Check for absorbing state termination (species depletion)\n                # These checks are placed before the time check to correctly attribute\n                # the outcome if the boundary is hit at the start of an interval.\n                if X == 0:\n                    # Condition for extinction: X depletes before A and before T_max\n                    extinction_count += 1\n                    break\n                if A == 0:\n                    # Condition for explosion: A depletes before X and before T_max\n                    explosion_count += 1\n                    break\n                \n                # Check for time horizon termination\n                if t = T_max:\n                    # Trajectory ends due to time limit, neither outcome is counted.\n                    break\n\n                # Step 1: Calculate propensity functions\n                propensity_r1 = c * A * X\n                propensity_r2 = d * X\n                propensity_total = propensity_r1 + propensity_r2\n\n                # If total propensity is zero, no more reactions can occur.\n                # In this system, this only happens if X is zero, which is already handled.\n                if propensity_total == 0:\n                    break\n\n                # Step 2: Draw time to next reaction from exponential distribution\n                # tau = (1.0 / propensity_total) * np.log(1.0 / rng.random()) is equivalent\n                tau = rng.exponential(scale=1.0 / propensity_total)\n\n                # Check if the next reaction would occur after the time horizon\n                if t + tau = T_max:\n                    # The trajectory runs until T_max but doesn't hit a boundary in time.\n                    break\n                \n                # Step 4: Update time\n                t += tau\n\n                # Step 3: Choose which reaction occurs\n                if rng.random() * propensity_total  propensity_r1:\n                    # Reaction R1: A + X - 2X\n                    # Stoichiometry vector: (-1, +1)\n                    A -= 1\n                    X += 1\n                else:\n                    # Reaction R2: X - 0\n                    # Stoichiometry vector: (0, -1)\n                    X -= 1\n\n        # Calculate empirical probabilities\n        prob_extinction = extinction_count / N\n        prob_explosion = explosion_count / N\n        \n        # Append results formatted to three decimal places\n        results.append(f\"{prob_extinction:.3f}\")\n        results.append(f\"{prob_explosion:.3f}\")\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一个精确的算法需要精确的工具，对于随机模拟而言，这个工具就是伪随机数生成器（PRNG）。本练习将引导你探究一个更深层次的问题：如果PRNG生成的随机数并非真正独立，会对模拟结果产生什么影响？通过构建一个具有可控相关性的“劣质”PRNG，你将量化其对模拟稳态均值和方差的系统性偏差，深刻体会到数值实验中工具选择的重要性。",
            "id": "2430840",
            "problem": "考虑一个单物种生灭化学反应系统，该系统被建模为一个连续时间马尔可夫链，其状态 $X(t) \\in \\{0,1,2,\\dots\\}$ 表示物种 $X$ 在时间 $t$ 的分子数。该系统有两个反应：\n- 反应 $R_1$: $\\varnothing \\rightarrow X$，倾向函数为 $a_1(x) = k_b$，\n- 反应 $R_2$: $X \\rightarrow \\varnothing$，倾向函数为 $a_2(x) = k_d \\, x$，\n其中 $x$ 表示当前计数值 $X(t)$，$k_b$ 是出生率常数，$k_d$ 是死亡率常数。总倾向为 $a_0(x) = a_1(x) + a_2(x)$。\n\n在任何状态 $x$ 下，到下一次反应的等待时间 $\\tau$ 服从参数为 $a_0(x)$ 的指数分布，并且下一个反应通道根据概率 $\\mathbb{P}(R_1 \\mid x) = a_1(x)/a_0(x)$ 和 $\\mathbb{P}(R_2 \\mid x) = a_2(x)/a_0(x)$ 被选择。假设在时间 $t=0$ 时的初始条件为 $X(0) = 0$。设 $k_b = 4.0\\,\\text{s}^{-1}$，$k_d = 1.0\\,\\text{s}^{-1}$，并模拟至最终时间 $T = 40.0\\,\\text{s}$（时间必须以秒为单位解释）。对于每条模拟轨迹，我们感兴趣的输出量是终端计数值 $X(T)$，这是一个无量纲的量。\n\n假设在每次反应事件中，使用两个位于开放单位区间的伪随机变量 $r_1$ 和 $r_2$ 如下：$r_1$ 用于抽样指数等待时间，$r_2$ 用于通过对累积倾向进行阈值判断来选择反应通道。定义一个基准情况，其中 $r_1$ 和 $r_2$ 是从 $(0,1)$ 上的均匀分布中独立同分布地抽取的。定义一族由相关性参数 $s \\in [-1,1]$ 参数化的“劣质”伪随机数生成器，该生成器在每次事件中由独立的基础变量 $u \\sim \\text{Uniform}(0,1)$ 和 $v \\sim \\text{Uniform}(0,1)$ 构建：\n- 首先设置 $r_1 = \\mathrm{clip}(u,\\varepsilon,1-\\varepsilon)$，其中 $\\varepsilon = 10^{-12}$ 以避免边界值。\n- 然后设置\n$$\nr_2 =\n\\begin{cases}\n\\mathrm{clip}\\!\\left(s \\, r_1 + (1-s)\\, v, \\varepsilon, 1-\\varepsilon\\right),  \\text{若 } s \\ge 0, \\\\\n\\mathrm{clip}\\!\\left(|s| \\, (1 - r_1) + (1-|s|)\\, v, \\varepsilon, 1-\\varepsilon\\right),  \\text{若 } s  0,\n\\end{cases}\n$$\n其中 $\\mathrm{clip}(z,\\varepsilon,1-\\varepsilon) = \\min(\\max(z,\\varepsilon),1-\\varepsilon)$。注意，当 $s=0$ 时，$r_2$ 简化为一个独立的均匀变量；而当 $s=1$ 时，$r_2=r_1$；负的 $s$ 会导致负相关。\n\n令该过程的理论稳态均值和方差分别表示为 $\\mu$ 和 $\\sigma^2$。对于给定参数，在稳态下 $\\mu = \\sigma^2 = k_b/k_d$。对于下述每个测试用例，执行 $M$ 次独立轨迹模拟，每次从 $X(0)=0$ 开始运行至时间 $T$，并在每次反应事件中使用指定的 $s$ 生成对 $(r_1,r_2)$。汇总终端值 $\\{X^{(m)}(T)\\}_{m=1}^M$ 并计算：\n- 样本均值 $\\widehat{\\mu}$，\n- 样本方差 $\\widehat{\\sigma}^2$（使用总体方差定义，即不含贝塞尔校正的偏差平方的平均值），\n- 归一化均方根误差\n$$\nE(s) \\;=\\; \\frac{1}{\\mu} \\sqrt{\\frac{\\left(\\widehat{\\mu} - \\mu\\right)^2 + \\left(\\widehat{\\sigma}^2 - \\sigma^2\\right)^2}{2}} \\, ,\n$$\n这是一个无量纲的量。\n\n使用以下测试套件，其中指定了相关性参数 $s$、轨迹数 $M$、伪随机数生成器的种子，以及所有其他如上所述的隐式参数：\n- 测试用例 1：$s = 0.0$，$M = 3000$，种子 $= 123456789$，\n- 测试用例 2：$s = 0.9$，$M = 3000$，种子 $= 123456789$，\n- 测试用例 3：$s = 1.0$，$M = 3000$，种子 $= 123456789$，\n- 测试用例 4：$s = -0.9$，$M = 3000$，种子 $= 123456789$。\n\n对于所有情况，使用 $k_b = 4.0\\,\\text{s}^{-1}$，$k_d = 1.0\\,\\text{s}^{-1}$，$T = 40.0\\,\\text{s}$，以及 $X(0)=0$。\n\n您的程序必须产生单行输出，其中包含按所列顺序排列的四个测试用例的 $E(s)$ 值，作为一个用方括号括起来的逗号分隔列表，例如 $[e_1,e_2,e_3,e_4]$。每个 $e_i$ 都必须是浮点数。输出是无量纲数；不要包含任何物理单位或百分比符号。不应从用户读取任何输入，也不应使用任何外部文件。",
            "solution": "该问题陈述已经过验证，并被确定为有效。它具有科学依据，定义明确且客观。它在随机化学动力学领域——计算生物学和生物信息学的一个基础领域——提出了一个明确定义的计算实验。任务是为一个简单的生灭过程实现 Gillespie 随机模拟算法（SSA），并精确量化当底层的伪随机数生成器（PRNG）产生相关变量而非独立变量时，引入到关键统计估计量中的系统误差。\n\n所考虑的系统是一个连续时间马尔可夫链，其中状态 $X(t) \\in \\{0, 1, 2, \\dots\\}$ 表示单个物种 $X$ 的分子数。状态演化由两个基本反应控制：\n- 出生：$R_1: \\varnothing \\xrightarrow{k_b} X$，具有一个常数倾向函数 $a_1(x) = k_b$。\n- 死亡：$R_2: X \\xrightarrow{k_d} \\varnothing$，具有一个依赖状态的倾向函数 $a_2(x) = k_d x$。\n在这里，$x$ 是当前的分子数 $X(t)$，$k_b$ 是零级出生率常数，$k_d$ 是一级死亡率常数。任何反应发生的总倾向是各个倾向的总和，$a_0(x) = a_1(x) + a_2(x) = k_b + k_d x$。\n\nGillespie 算法（或称 SSA）为该系统提供了一条精确的随机轨迹。在任何时间 $t$ 且状态为 $X(t)=x$ 时，模拟通过对两个量进行抽样来推进：到下一次反应的时间 $\\tau$，以及该反应的索引 $j \\in \\{1, 2\\}$。\n等待时间 $\\tau$ 从一个速率参数等于总倾向 $a_0(x)$ 的指数分布中抽取。其概率密度函数为 $p(\\tau|x) = a_0(x) e^{-a_0(x)\\tau}$。使用反变换采样法，并借助一个均匀随机变量 $r_1 \\in (0,1)$，等待时间计算为 $\\tau = -\\frac{\\ln(r_1)}{a_0(x)}$。\n接下来发生的具体反应通道是根据与其倾向成正比的概率来选择的。使用第二个均匀随机变量 $r_2 \\in (0,1)$。如果 $r_2  a_1(x)/a_0(x)$，则选择反应 $R_1$；否则选择 $R_2$。\n反应事件发生后，系统状态相应更新（对于 $R_1$，$x \\to x+1$；对于 $R_2$，$x \\to x-1$），且时钟按采样的等待时间推进（$t \\to t+\\tau$）。此过程被迭代，直到模拟达到最终时间 $T$。\n\n对于指定的参数 $k_b = 4.0\\,\\text{s}^{-1}$ 和 $k_d = 1.0\\,\\text{s}^{-1}$，该系统拥有一个理论稳态分布。该分布是参数为 $\\lambda = k_b/k_d = 4.0/1.0 = 4.0$ 的泊松分布。此稳态分布的理论均值 $\\mu$ 和方差 $\\sigma^2$ 均等于 $\\lambda$，因此 $\\mu = 4.0$ 且 $\\sigma^2 = 4.0$。模拟进行到最终时间 $T = 40.0\\,\\text{s}$。因为这个时间范围远长于系统的特征弛豫时间尺度（约为 $1/k_d=1.0\\,\\text{s}$），所以终端状态 $X(T)$ 的分布预期会非常接近稳态分布。\n\n该问题的核心任务是研究用于推进模拟的随机变量 $r_1$ 和 $r_2$ 之间的统计相关性所带来的系统性影响。问题提供了一个用于生成这些相关变量的特定模型，由参数 $s \\in [-1,1]$ 控制。在模拟的每个事件中，从 $(0,1)$ 上的均匀分布中抽取两个独立的基础变量 $u$ 和 $v$。然后构造变量 $r_1$ 和 $r_2$。首先，通过将 $u$ 裁剪到一个安全区间来获得 $r_1$，以防止数值不稳定：\n$$r_1 = \\mathrm{clip}(u, \\varepsilon, 1-\\varepsilon)$$\n其中 $\\varepsilon = 10^{-12}$，裁剪函数定义为 $\\mathrm{clip}(z,a,b) = \\min(\\max(z,a),b)$。然后，$r_2$ 作为 $r_1$、$v$ 和相关性参数 $s$ 的函数生成。\n对于非负相关，$s \\ge 0$：\n$$r_2 = \\mathrm{clip}(s \\cdot r_1 + (1-s) \\cdot v, \\varepsilon, 1-\\varepsilon)$$\n对于负相关，$s  0$：\n$$r_2 = \\mathrm{clip}(|s| \\cdot (1 - r_1) + (1-|s|) \\cdot v, \\varepsilon, 1-\\varepsilon)$$\n这种构造在 $s=0$ 时产生独立变量（标准的 SSA），在 $s=1$ 时产生完全相关的变量（$r_2=r_1$），在 $s=-1$ 时产生完全反相关的变量（$r_2 = 1-r_1$）（忽略裁剪和含 $v$ 的随机项）。\n\n对于每个由 $s$ 值定义的测试用例，共模拟 $M = 3000$ 条独立轨迹。每条轨迹在 $t=0$ 时以 $X(0)=0$ 初始化，并演化直到模拟时间 $t$ 超过或等于最终时间 $T=40.0\\,\\text{s}$。在此最后一步之前的系统状态 $X(t)$ 被记录为该轨迹的终端计数值，从而产生一个样本 $\\{X^{(m)}(T)\\}_{m=1}^M$。\n\n根据这个终端计数值的样本，计算样本均值 $\\widehat{\\mu}$ 和样本方差 $\\widehat{\\sigma}^2$。问题指定使用总体方差公式，即分母为 $M$。\n$$ \\widehat{\\mu} = \\frac{1}{M}\\sum_{m=1}^{M} X^{(m)}(T) $$\n$$ \\widehat{\\sigma}^2 = \\frac{1}{M}\\sum_{m=1}^{M} \\left(X^{(m)}(T) - \\widehat{\\mu}\\right)^2 $$\n最后，为了量化模拟结果与理论稳态预测的偏差，计算归一化均方根误差 $E(s)$：\n$$ E(s) = \\frac{1}{\\mu} \\sqrt{\\frac{(\\widehat{\\mu} - \\mu)^2 + (\\widehat{\\sigma}^2 - \\sigma^2)^2}{2}} $$\n对四个指定的测试用例中的每一个都执行此过程。在这些案例中对基础 PRNG 使用固定的种子，确保了底层的 $(u,v)$ 对序列是相同的，从而隔离了相关性参数 $s$ 的影响。最终输出将包含四个计算出的 $E(s)$ 值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation_case(s, M, seed, kb, kd, T_final, X0):\n    \"\"\"\n    Runs a full simulation for a given test case to compute the error metric E(s).\n\n    Args:\n        s (float): The correlation parameter for the PRNG.\n        M (int): The number of trajectories to simulate.\n        seed (int): The seed for the random number generator.\n        kb (float): The birth rate constant.\n        kd (float): The death rate constant.\n        T_final (float): The final simulation time.\n        X0 (int): The initial molecular count.\n\n    Returns:\n        float: The calculated error metric E(s).\n    \"\"\"\n    # Epsilon for clipping to avoid log(0) or boundary issues.\n    eps = 1e-12\n\n    # Theoretical stationary mean and variance\n    mu_th = kb / kd\n    sigma2_th = kb / kd\n\n    # Initialize the random number generator with the specified seed.\n    rng = np.random.default_rng(seed)\n\n    # Array to store the terminal molecular count for each trajectory.\n    terminal_counts = np.zeros(M, dtype=int)\n\n    # Loop over the number of trajectories.\n    for m in range(M):\n        t = 0.0\n        x = X0\n\n        # Simulate a single trajectory until T_final.\n        while t  T_final:\n            # Calculate propensities for the current state x.\n            a1 = kb\n            a2 = kd * x if x  0 else 0.0\n            a0 = a1 + a2\n\n            # If total propensity is zero, no more reactions can occur.\n            if a0 == 0:\n                break\n            \n            # Generate two independent base uniform variates (u, v).\n            u, v = rng.uniform(0.0, 1.0, 2)\n            \n            # Construct the correlated variates r1 and r2.\n            r1 = np.clip(u, eps, 1.0 - eps)\n\n            if s = 0:\n                term = s * r1 + (1.0 - s) * v\n            else:  # s  0\n                term = abs(s) * (1.0 - r1) + (1.0 - abs(s)) * v\n            r2 = np.clip(term, eps, 1.0 - eps)\n\n            # Sample the time to the next reaction using r1.\n            dt = -np.log(r1) / a0\n            \n            # If the next reaction occurs after T_final, the trajectory ends.\n            # The state at T_final is the current state x.\n            if t + dt = T_final:\n                break\n            \n            # Update time and state.\n            t += dt\n            \n            # Choose the next reaction using r2.\n            if r2  a1 / a0:\n                x += 1  # Birth reaction\n            else:\n                x -= 1  # Death reaction\n        \n        terminal_counts[m] = x\n\n    # Compute sample mean and variance from the terminal counts.\n    # np.mean() computes the sample mean.\n    mu_hat = np.mean(terminal_counts)\n    # np.var() computes the population variance (denominator N) by default.\n    sigma2_hat = np.var(terminal_counts)\n    \n    # Calculate the squared errors for the mean and variance.\n    error_mu_sq = (mu_hat - mu_th)**2\n    error_sigma2_sq = (sigma2_hat - sigma2_th)**2\n    \n    # Calculate the final normalized RMS error metric E(s).\n    E_s = (1.0 / mu_th) * np.sqrt((error_mu_sq + error_sigma2_sq) / 2.0)\n    \n    return E_s\n\ndef solve():\n    \"\"\"\n    Defines the test cases and computes the final result for each.\n    \"\"\"\n    # Common parameters for all test cases as defined in the problem.\n    kb = 4.0\n    kd = 1.0\n    T_final = 40.0\n    X0 = 0\n    M = 3000\n    seed = 123456789\n\n    # Test cases defined by the correlation parameter s.\n    test_cases = [\n        # (s, M, seed)\n        (0.0, M, seed),   # Case 1: Independent PRNG\n        (0.9, M, seed),   # Case 2: Strong positive correlation\n        (1.0, M, seed),   # Case 3: Perfect positive correlation\n        (-0.9, M, seed),  # Case 4: Strong negative correlation\n    ]\n\n    results = []\n    # Run the simulation for each test case and collect the error metric.\n    for s_val, M_val, seed_val in test_cases:\n        error = run_simulation_case(s_val, M_val, seed_val, kb, kd, T_final, X0)\n        results.append(error)\n\n    # Print the final result in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the solver.\nsolve()\n```"
        }
    ]
}