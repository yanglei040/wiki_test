{
    "hands_on_practices": [
        {
            "introduction": "通路富集分析的许多基础方法，如超几何检验，都植根于扎实的统计学原理。亲自计算这些统计量是深入理解其行为的最佳方式。本练习将引导你直接探究超几何检验的 $p$ 值，通过改变“基因总体”的大小这一关键参数，你将观察到其对富集显著性的直接影响，从而为后续更复杂的分析打下坚实的直觉基础。",
            "id": "2412461",
            "problem": "在一项基于靶向基因组合的通路富集分析中，研究人员考虑了一个大小为 $N$ 的基因全集，并评估了该全集中一个包含 $M$ 个基因的特定通路的富集情况。通过实验获得了一个大小为 $n$ 的差异表达基因（DEGs）列表，观测到该列表与通路之间的重叠基因为 $k$ 个。单边富集 $p$ 值定义为右尾概率 $\\Pr(X \\geq k)$，其中 $X$ 是从大小为 $N$ 的全集中无放回地抽取大小为 $n$ 的样本时，观测到的通路基因数量。\n\n假设初始时，基因全集大小为 $N_{1} = 20$，通路包含 $M = 6$ 个基因，DEG 列表大小为 $n = 5$，观测到的重叠数量为 $k = 3$。现在，通过添加不属于该通路的基因，将基因全集大小增加一倍至 $N_{2} = 40$，而 $M = 6$、$n = 5$ 和 $k = 3$ 保持不变。\n\n令 $p_{1}$ 表示当 $N = N_{1}$ 时的富集 $p$ 值，$p_{2}$ 表示当 $N = N_{2}$ 时的富集 $p$ 值。计算精确比值 $r = \\dfrac{p_{2}}{p_{1}}$，并将最终答案表示为单个最简分数。不要四舍五入。",
            "solution": "问题陈述已经过验证，是有效的。它具有科学依据、提法得当、客观且自洽。它描述了一种用于通路富集分析的标准统计检验，其基础概率分布是超几何分布。我将开始解答。\n\n该问题要求计算两个富集 $p$ 值的比值。富集检验基于无放回抽样，这可以用超几何分布来正确建模。设 $N$ 是基因全集中的基因总数，$M$ 是通路中的基因数（总体中的成功数），$n$ 是抽取的样本大小（DEG 列表的大小），$i$ 是在样本中发现的通路基因数（样本中的成功数）。观测到恰好 $i$ 次成功抽取的概率质量函数 (PMF) 由下式给出：\n$$P(X=i) = \\frac{\\binom{M}{i} \\binom{N-M}{n-i}}{\\binom{N}{n}}$$\n单边富集 $p$ 值定义为右尾概率 $P(X \\ge k)$，其中 $k$ 是在样本中观测到的通路基因数。其计算方式如下：\n$$p = P(X \\ge k) = \\sum_{i=k}^{\\min(n,M)} P(X=i) = \\sum_{i=k}^{\\min(n,M)} \\frac{\\binom{M}{i} \\binom{N-M}{n-i}}{\\binom{N}{n}}$$\n\n首先，我们计算初始条件下的 $p$ 值，$p_1$。\n参数为 $N_1 = 20$，$M = 6$，$n = 5$，且 $k = 3$。最大可能重叠数为 $\\min(n, M) = \\min(5, 6) = 5$。\n$$p_1 = P(X_1 \\ge 3) = P(X_1=3) + P(X_1=4) + P(X_1=5)$$\n使用 PMF，我们将 $p_1$ 表示为：\n$$p_1 = \\frac{\\binom{6}{3}\\binom{20-6}{5-3}}{\\binom{20}{5}} + \\frac{\\binom{6}{4}\\binom{20-6}{5-4}}{\\binom{20}{5}} + \\frac{\\binom{6}{5}\\binom{20-6}{5-5}}{\\binom{20}{5}}$$\n$$p_1 = \\frac{1}{\\binom{20}{5}} \\left[ \\binom{6}{3}\\binom{14}{2} + \\binom{6}{4}\\binom{14}{1} + \\binom{6}{5}\\binom{14}{0} \\right]$$\n我们计算二项式系数：\n$\\binom{6}{3} = \\frac{6 \\cdot 5 \\cdot 4}{3 \\cdot 2 \\cdot 1} = 20$\n$\\binom{6}{4} = \\binom{6}{2} = \\frac{6 \\cdot 5}{2 \\cdot 1} = 15$\n$\\binom{6}{5} = \\binom{6}{1} = 6$\n$\\binom{14}{2} = \\frac{14 \\cdot 13}{2 \\cdot 1} = 91$\n$\\binom{14}{1} = 14$\n$\\binom{14}{0} = 1$\n$\\binom{20}{5} = \\frac{20 \\cdot 19 \\cdot 18 \\cdot 17 \\cdot 16}{5 \\cdot 4 \\cdot 3 \\cdot 2 \\cdot 1} = 15504$\n代入这些值，我们得到 $p_1$ 的分子：\n$$ \\text{Numerator}_1 = (20)(91) + (15)(14) + (6)(1) = 1820 + 210 + 6 = 2036 $$\n所以，$p_1 = \\frac{2036}{15504}$。\n\n接下来，我们计算第二种条件下的 $p$ 值，$p_2$。\n参数为 $N_2 = 40$，$M = 6$，$n = 5$，且 $k = 3$。不在通路中的基因数量为 $N_2 - M = 40 - 6 = 34$。\n$$p_2 = P(X_2 \\ge 3) = P(X_2=3) + P(X_2=4) + P(X_2=5)$$\n$$p_2 = \\frac{1}{\\binom{40}{5}} \\left[ \\binom{6}{3}\\binom{34}{2} + \\binom{6}{4}\\binom{34}{1} + \\binom{6}{5}\\binom{34}{0} \\right]$$\n我们计算所需的二项式系数：\n关于 $M$ 的系数是相同的：$\\binom{6}{3}=20$，$\\binom{6}{4}=15$，$\\binom{6}{5}=6$。\n$\\binom{34}{2} = \\frac{34 \\cdot 33}{2 \\cdot 1} = 17 \\cdot 33 = 561$\n$\\binom{34}{1} = 34$\n$\\binom{34}{0} = 1$\n$\\binom{40}{5} = \\frac{40 \\cdot 39 \\cdot 38 \\cdot 37 \\cdot 36}{5 \\cdot 4 \\cdot 3 \\cdot 2 \\cdot 1} = 658008$\n代入这些值，我们得到 $p_2$ 的分子：\n$$ \\text{Numerator}_2 = (20)(561) + (15)(34) + (6)(1) = 11220 + 510 + 6 = 11736 $$\n所以，$p_2 = \\frac{11736}{658008}$。\n\n最后，我们计算比值 $r = \\frac{p_2}{p_1}$：\n$$r = \\frac{p_2}{p_1} = \\frac{11736/658008}{2036/15504} = \\frac{11736}{2036} \\times \\frac{15504}{658008}$$\n我们分别化简每个分数。\n对于第一个分数：\n$$\\frac{11736}{2036} = \\frac{4 \\times 2934}{4 \\times 509} = \\frac{2934}{509}$$\n数字 $509$ 是一个质数。\n对于第二个分数：\n$$\\frac{15504}{658008} = \\frac{\\binom{20}{5}}{\\binom{40}{5}} = \\frac{20 \\cdot 19 \\cdot 18 \\cdot 17 \\cdot 16 / 5!}{40 \\cdot 39 \\cdot 38 \\cdot 37 \\cdot 36 / 5!} = \\frac{20 \\cdot 19 \\cdot 18 \\cdot 17 \\cdot 16}{40 \\cdot 39 \\cdot 38 \\cdot 37 \\cdot 36}$$\n我们通过配对各项来化简这个表达式：\n$$ \\frac{20}{40} \\cdot \\frac{18}{36} \\cdot \\frac{19}{38} \\cdot \\frac{16 \\cdot 17}{39 \\cdot 37} = \\left(\\frac{1}{2}\\right) \\cdot \\left(\\frac{1}{2}\\right) \\cdot \\left(\\frac{1}{2}\\right) \\cdot \\frac{16 \\cdot 17}{39 \\cdot 37} = \\frac{1}{8} \\cdot \\frac{272}{1443} = \\frac{34}{1443} $$\n现在我们将化简后的分数相乘来求 $r$：\n$$r = \\frac{2934}{509} \\times \\frac{34}{1443}$$\n为简化此乘积，我们对分子和分母进行质因数分解。\n$2934 = 2 \\times 1467 = 2 \\times 3 \\times 489 = 2 \\times 3 \\times 3 \\times 163 = 2 \\times 3^2 \\times 163$。\n$34 = 2 \\times 17$。\n$509$ 是质数。\n$1443 = 3 \\times 481 = 3 \\times 13 \\times 37$。\n现在，将这些分解式代入 $r$ 的表达式中：\n$$r = \\frac{2 \\times 3^2 \\times 163}{509} \\times \\frac{2 \\times 17}{3 \\times 13 \\times 37}$$\n约去一个因子 $3$：\n$$r = \\frac{2 \\times 3 \\times 163}{509} \\times \\frac{2 \\times 17}{13 \\times 37} = \\frac{12 \\times 17 \\times 163}{509 \\times 13 \\times 37}$$\n分子中剩余的因子是 $2$, $3$, $17$, $163$。分母中的因子是 $13$, $37$, $509$。所有这些都是质数，分子和分母之间没有公因子。因此，该分数已是最简形式。我们计算最终的乘积。\n分子：$12 \\times 17 \\times 163 = 204 \\times 163 = 33252$。\n分母：$509 \\times 13 \\times 37 = 509 \\times 481 = 244829$。\n精确比值为：\n$$r = \\frac{33252}{244829}$$",
            "answer": "$$\\boxed{\\frac{33252}{244829}}$$"
        },
        {
            "introduction": "在生物信息学实践中，使用不同分析方法得到看似矛盾的结果是常有的事。理解这些差异的来源是培养批判性思维和解决问题能力的关键。本练习模拟了一个经典场景：一个通路在无需设定阈值的GSEA分析中显著富集，但在基于阈值的ORA分析中却不显著。通过辨析该结果，你将学会如何解读不同分析策略的优缺点，并提炼出更深刻的生物学洞见。",
            "id": "2412467",
            "problem": "您分析了一项比较两种表型的RNA测序实验，并根据一个有符号的差异表达统计量获得了所有基因的排序列表。对完整的排序列表进行基因集富集分析 (GSEA) 后，报告标记为“免疫应答”的基因集在假发现率 (FDR) 低于 $0.05$ 时显著富集。另外，您使用超几何框架对在 FDR 低于 $0.05$ 时定义的前 $200$ 个差异表达基因 (DEGs) 进行了过表达分析 (ORA)，而在该分析中，“免疫应答”基因集不显著。以下哪项是这些发现最可能的生物学解释？在这里，基因集富集分析 (GSEA)、过表达分析 (ORA) 和差异表达基因 (DEGs) 均按其标准生物信息学用法定义。\n\nA. 许多免疫应答基因表现出微小、协调且方向一致的变化，但这些变化太微弱，无法超过单个 DEG 的阈值，从而产生 GSEA 可检测到的分布偏移，但与前 $200$ 个 DEG 的重叠不足以使 ORA 显著。\n\nB. 免疫应答通路在所有样本中都完全不活跃；GSEA 的结果完全是由基因集大小偏倚引起的，应被忽略。\n\nC. 过表达分析在本质上比基因集富集分析更敏感；因此，ORA 结果不显著表明没有真正的免疫参与。\n\nD. 这种不一致性必然表明存在影响看家基因的严重批次效应，这是对于有显著 GSEA 结果而无匹配 ORA 信号的唯一合理解释。\n\nE. 免疫应答信号完全由少数几个表达差异极强的基因驱动，而 ORA 倾向于错过这些基因，但 GSEA 会检测到。",
            "solution": "问题陈述将首先经过严格验证。\n\n步骤1：提取已知条件\n- 一项RNA测序实验比较了两种表型。\n- 根据一个有符号的差异表达统计量生成了所有基因的排序列表。\n- 对完整的排序列表进行了基因集富集分析 (GSEA)。\n- GSEA 报告“免疫应答”基因集在假发现率 (FDR) 低于 $0.05$ 时显著富集。\n- 另外使用超几何框架进行了过表达分析 (ORA)。\n- ORA 的输入是前 $200$ 个差异表达基因 (DEGs) 的列表，这些基因本身是在 FDR 低于 $0.05$ 的条件下定义的。\n- 在 ORA 中，“免疫应答”基因集未被发现显著。\n- 任务是确定这些发现最可能的生物学解释。\n\n步骤2：使用提取的已知条件进行验证\n该问题描述了转录组数据分析中一个标准且确实常见的情景。提到的方法——GSEA 和 ORA——是计算生物学中用于通路分析的基础技术。其前提涉及比较一个基于阈值的方法 (ORA) 和一个无阈值方法 (GSEA) 的结果，这是生物信息学教育和实践中的一个经典主题。所提供的数据内部一致，描述了一组合理、不矛盾的分析结果。该问题具有科学依据，提法恰当，客观，并与其所述领域直接相关。它没有违反任何科学逻辑原则，也不包含会妨碍得出合理解答的歧义或缺失信息。\n\n步骤3：结论和行动\n问题陈述有效。我将进行完整的推导和分析。\n\n这个问题的核心在于理解过表达分析 (ORA) 和基因集富集分析 (GSEA) 之间的根本方法学差异。\n\n首先，我们来定义每种方法的原理。\n过表达分析 (ORA) 是一种依赖于阈值的方法。它首先将所有被测量的基因集合划分为两组：一组是“感兴趣的”基因（在此例中是前 $200$ 个差异表达基因，或 DEGs）的小列表，另一组是所有其他基因。这种划分基于一个有些随意的显著性阈值（这里是排名截断与 $0.05$ 的 FDR 阈值相结合）。然后，ORA 使用统计检验，通常是超几何检验或费雪精确检验，来确定一个预定义的基因集（例如，“免疫应答”）在“感兴趣的”基因列表中，与所有基因的背景相比，是否在统计上过表达。ORA 的关键弱点在于它所导致的信息损失：所有关于未通过严格阈值的基因的定量信息都被丢弃了。具有微弱但具有生物学意义变化的基因与完全没有变化的基因被同等对待。\n\n相比之下，基因集富集分析 (GSEA) 是一种无阈值方法。它不是从一个随意的截断值开始来选择一个小列表的 DEGs。相反，它考虑实验中测量的所有基因，并根据差异表达度量（例如，信噪比、log-倍数变化）进行排序。该方法沿着排序的基因列表移动，并计算一个移动加和统计量，当遇到来自目标基因集的基因时，该统计量增加；当遇到不在该集合中的基因时，该统计量减少。这个移动加和与零的最大偏差即为富集分数 (ES)。该 ES 反映了一个基因集在整个排序列表的顶端或底端过表达的程度。ES 的统计显著性通过置换检验来评估，该检验通过打乱基因标签或样本标签来生成空分布，然后进行多重检验校正 (FDR)。GSEA 的主要优势在于其能够检测通路内许多基因表达的微弱、协调的变化，即使这些基因中没有任何一个的变化足以通过严格的 DEG 截断值。\n\n现在，我们分析所呈现的具体结果。GSEA 发现“免疫应答”基因集是显著的 (FDR  $0.05$)，而 ORA 没有。\n显著的 GSEA 结果表明，属于“免疫应答”集的基因在整个排序列表中并非随机分布。它们作为一个群体，富集在列表的一端，这意味着在表型比较中存在一个协调的、有方向性的变化（例如，轻微但一致的上调）。\n不显著的 ORA 结果表明，当我们只考虑扰动最剧烈的 $200$ 个基因时，在这个短列表中发现的“免疫应答”基因的数量在统计上并不出人意料。\n\n对这两个发现最合乎逻辑的综合解释是，“免疫应答”通路确实在转录水平上受到了扰动，但这种扰动表现为该基因集中许多基因表达的微弱、广泛且协调的变化。这些单个变化的幅度太小，使得这些基因中的大多数没有资格被纳入前 $200$ 个 DEGs。GSEA 通过整合整个基因集的这些微小效应，正确地识别出显著的生物学信号。ORA 由于仅关注“冰山一角”（前 $200$ 个 DEGs），未能看到更广泛的模式，因此错误地得出没有显著富集的结论。\n\n在此基础上，我们评估每个选项：\n\nA. 许多免疫应答基因表现出微小、协调且方向一致的变化，但这些变化太微弱，无法超过单个 DEG 的阈值，从而产生 GSEA 可检测到的分布偏移，但与前 $200$ 个 DEG 的重叠不足以使 ORA 显著。\n该陈述准确地描述了 GSEA 被设计用来解决并且在灵敏度上优于 ORA 的确切情景。它基于这些方法的根本原理，完美地调和了这两个看似矛盾的结果。\n结论：**正确**。\n\nB. 免疫应答通路在所有样本中都完全不活跃；GSEA 的结果完全是由基因集大小偏倚引起的，应被忽略。\n这是一个不合理的断言。一个显著的 GSEA 结果，尤其是在经过置换检验校正后的 FDR 低于 $0.05$ 时，是反对“通路不活跃”这一说法的有力证据。虽然基因集大小可能是一个混杂因素，但标准的 GSEA 实现包含用于校正它的归一化步骤。在没有进一步证据的情况下，将一个统计显著的发现仅仅当作假象而摒弃，是不严谨的科研实践。该陈述称通路“完全不活跃”是一个与 GSEA 结果相矛盾的极端断言。\n结论：**不正确**。\n\nC. 过表达分析在本质上比基因集富集分析更敏感；因此，ORA 结果不显著表明没有真正的免疫参与。\n这个前提在事实上是错误的。生物信息学文献和社区广泛承认，GSEA 及类似的无阈值方法通常比 ORA *更*敏感，正是因为它们避免了随意的截断，并能检测到微弱的、累积的效应。该选项的逻辑基于一个错误的前提。\n结论：**不正确**。\n\nD. 这种不一致性必然表明存在影响看家基因的严重批次效应，这是对于有显著 GSEA 结果而无匹配 ORA 信号的唯一合理解释。\n这是一个过于强烈且未经证实的说法。批次效应是任何高通量实验中的一个潜在问题，但它远非“唯一合理的解释”。GSEA 和 ORA 之间的方法学差异为观察到的结果提供了一个更直接、更简洁的解释。没有依据“必然”得出批次效应是原因的结论，也没有任何信息可以特指看家基因受到了影响。\n结论：**不正确**。\n\nE. 免疫应答信号完全由少数几个表达差异极强的基因驱动，而 ORA 倾向于错过这些基因，但 GSEA 会检测到。\n该陈述表明了对 ORA 的误解。如果信号是由少数几个表达差异极强的 DEGs 驱动的，那么根据定义，这些基因将位于排序列表的最顶端，并会被包含在用于 ORA 的前 $200$ 个 DEGs 中。在这种情况下，ORA *极有可能*返回一个显著结果。这种情况会导致 GSEA 和 ORA 都显著，这与问题陈述中 ORA 不显著的事实相矛盾。\n结论：**不正确**。\n\n总之，GSEA 和 ORA 结果之间的差异是它们各自优缺点的一个经典例证。选项 A 提供了唯一正确且在机制上合理的解释。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "通路分析不仅仅是应用现成的工具，更重要的是能够根据特定的生物学问题定义和实现新的分析逻辑。本练习要求你将一个精确的、关于“失调通路”的规则集转化为具体的算法。这个过程不仅能锻炼你的编程和逻辑思维能力，还能让你体会到计算生物学家如何将抽象的假设转化为可执行、可检验的分析流程，这是连接理论与实践的核心技能。",
            "id": "2412448",
            "problem": "给定一个由全集 $G$ 表示的有限基因集合，以及一个实值函数 $s:G\\to\\mathbb{R}$，该函数为每个基因分配一个带符号的分数，表示其相对于基线的对数倍数变化（log fold-change）。指定了两个正实数阈值：一个上调阈值 $\\tau_{u} > 0$ 和一个下调阈值 $\\tau_{d} > 0$。对于任何子集（通路）$P\\subseteq G$，定义子集 $U(P)=\\{g\\in P:\\ s(g)\\ge \\tau_{u}\\}$ 和 $D(P)=\\{g\\in P:\\ s(g)\\le -\\tau_{d}\\}$。\n\n一个通路 $P$ 被认为是失调的，当且仅当以下所有条件同时成立：\n- $P\\subseteq G$，\n- $\\lvert P\\rvert$ 是一个偶数且 $\\lvert P\\rvert\\ge 2$，\n- $\\lvert U(P)\\rvert=\\lvert D(P)\\rvert=\\frac{\\lvert P\\rvert}{2}$。\n\n换句话说，$P$ 中恰好一半的基因必须在 $\\tau_{u}$ 或以上被强上调，另一半必须在 $-\\tau_{d}$ 或以下被强下调；$P$ 中不能有任何相对于这些阈值是中性的基因。\n\n你的任务是确定给定测试集中的每个通路是否根据这些规则是失调的。使用以下具体实例：\n- 全集 $G=\\{A,B,C,D,E,F,G,H,I\\}$。\n- 分数函数 $s$ 由以下赋值定义：$s(A)=2.4$, $s(B)=1.5$, $s(C)=-2.1$, $s(D)=-1.2$, $s(E)=0.2$, $s(F)=-3.0$, $s(G)=1.0$, $s(H)=-1.0$, $s(I)=0.0$。\n- 阈值 $\\tau_{u}=1.0$ 和 $\\tau_{d}=1.0$。\n\n按所列顺序评估以下通路：\n- $P_{1}=\\{A,B,C,D\\}$,\n- $P_{2}=\\{A,C,E,F\\}$,\n- $P_{3}=\\{G,H\\}$,\n- $P_{4}=\\{A,C,D\\}$,\n- $P_{5}=\\{A,B,C,D,F,H\\}$,\n- $P_{6}=\\{A,Z\\}$, 其中 $Z\\notin G$。\n\n你的程序应产生单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如 $[result_{1},result_{2},\\dots]$），其中每个 $result_{i}$ 是一个布尔值，指示 $P_{i}$ 是否根据上述规则是失调的，并按 $P_{1}$ 到 $P_{6}$ 的顺序报告。",
            "solution": "该问题要求根据一个精确的失调定义，验证几个被称为通路的基因集。一个通路如果满足三个特定的、同时成立的条件，则被认为是失调的。我们将系统地分析每个测试通路是否满足这些条件。\n\n首先，我们形式化给定的参数和定义。\n基因全集是集合 $G = \\{A, B, C, D, E, F, G, H, I\\}$。\n基因分数函数 $s: G \\to \\mathbb{R}$ 由以下映射定义：\n$s(A) = 2.4$, $s(B) = 1.5$, $s(C) = -2.1$, $s(D) = -1.2$, $s(E) = 0.2$, $s(F) = -3.0$, $s(G) = 1.0$, $s(H) = -1.0$, $s(I) = 0.0$。\n调控阈值为上调阈值 $\\tau_u = 1.0$ 和下调阈值 $\\tau_d = 1.0$。\n\n对于任何给定的通路 $P$，我们将上调和下调的基因集定义为：\n$U(P) = \\{g \\in P : s(g) \\ge \\tau_u\\}$\n$D(P) = \\{g \\in P : s(g) \\le -\\tau_d\\}$\n\n一个通路 $P$ 被定义为失调的，当且仅当以下所有三个条件都满足：\n1.  **子集条件：** 该通路必须是基因全集的子集，$P \\subseteq G$。\n2.  **大小条件：** 通路的基数 $|P|$ 必须是大于或等于 $2$ 的偶数。\n3.  **平衡条件：** 通路中恰好一半的基因必须是上调的，另一半是下调的。形式上， $|U(P)| = |D(P)| = \\frac{|P|}{2}$。此条件意味着，在一个失调的通路中，没有任何基因的分数 $s(g)$ 能落在中性范围 $(-\\tau_d, \\tau_u)$ 内。\n\n现在我们根据这三个条件评估每个指定的通路。\n\n**$P_1 = \\{A, B, C, D\\}$**\n1.  **子集条件：** 所有元素 $\\{A, B, C, D\\}$ 都是全集 $G$ 的成员。此条件满足。\n2.  **大小条件：** 基数为 $|P_1| = 4$。这是一个偶数且 $4 \\ge 2$。此条件满足。\n3.  **平衡条件：** 我们要求 $|U(P_1)| = |D(P_1)| = \\frac{4}{2} = 2$。\n    -   $P_1$ 中的上调基因：$s(A) = 2.4 \\ge 1.0$ 且 $s(B) = 1.5 \\ge 1.0$。所以，$U(P_1) = \\{A, B\\}$，且 $|U(P_1)| = 2$。\n    -   $P_1$ 中的下调基因：$s(C) = -2.1 \\le -1.0$ 且 $s(D) = -1.2 \\le -1.0$。所以，$D(P_1) = \\{C, D\\}$，且 $|D(P_1)| = 2$。\n    -   两个计数都符合要求的值 $2$。此条件满足。\n**结论：** 所有三个条件都满足。$P_1$ 是失调的。**(True)**\n\n**$P_2 = \\{A, C, E, F\\}$**\n1.  **子集条件：** 所有元素 $\\{A, C, E, F\\}$ 都是 $G$ 的成员。此条件满足。\n2.  **大小条件：** 基数为 $|P_2| = 4$。这是一个偶数且 $4 \\ge 2$。此条件满足。\n3.  **平衡条件：** 我们要求 $|U(P_2)| = |D(P_2)| = \\frac{4}{2} = 2$。\n    -   $P_2$ 中的上调基因：$s(A) = 2.4 \\ge 1.0$。$U(P_2) = \\{A\\}$，所以 $|U(P_2)| = 1$。\n    -   要求计数为 $2$，但我们发现 $|U(P_2)| = 1$。此条件不满足。基因 $E$ 的分数为 $s(E) = 0.2$，是中性的（$-1.0  0.2  1.0$），违反了平衡条件的前提。\n**结论：** 平衡条件不满足。$P_2$ 不是失调的。**(False)**\n\n**$P_3 = \\{G, H\\}$**\n1.  **子集条件：** 所有元素 $\\{G, H\\}$ 都是 $G$ 的成员。此条件满足。\n2.  **大小条件：** 基数为 $|P_3| = 2$。这是一个偶数且 $2 \\ge 2$。此条件满足。\n3.  **平衡条件：** 我们要求 $|U(P_3)| = |D(P_3)| = \\frac{2}{2} = 1$。\n    -   $P_3$ 中的上调基因：$s(G) = 1.0 \\ge 1.0$。$U(P_3) = \\{G\\}$，所以 $|U(P_3)| = 1$。\n    -   $P_3$ 中的下调基因：$s(H) = -1.0 \\le -1.0$。$D(P_3) = \\{H\\}$，所以 $|D(P_3)| = 1$。\n    -   两个计数都符合要求的值 $1$。此条件满足。\n**结论：** 所有三个条件都满足。$P_3$ 是失调的。**(True)**\n\n**$P_4 = \\{A, C, D\\}$**\n1.  **子集条件：** 所有元素 $\\{A, C, D\\}$ 都是 $G$ 的成员。此条件满足。\n2.  **大小条件：** 基数为 $|P_4| = 3$。这不是一个偶数。此条件不满足。\n**结论：** 大小条件不满足。$P_4$ 不是失调的。**(False)**\n\n**$P_5 = \\{A, B, C, D, F, H\\}$**\n1.  **子集条件：** 所有元素 $\\{A, B, C, D, F, H\\}$ 都是 $G$ 的成员。此条件满足。\n2.  **大小条件：** 基数为 $|P_5| = 6$。这是一个偶数且 $6 \\ge 2$。此条件满足。\n3.  **平衡条件：** 我们要求 $|U(P_5)| = |D(P_5)| = \\frac{6}{2} = 3$。\n    -   $P_5$ 中的上调基因：$s(A) = 2.4 \\ge 1.0$ 且 $s(B) = 1.5 \\ge 1.0$。$U(P_5) = \\{A, B\\}$，所以 $|U(P_5)| = 2$。\n    -   上调基因的要求计数为 $3$，但我们发现 $|U(P_5)| = 2$。此条件不满足。\n**结论：** 平衡条件不满足。$P_5$ 不是失调的。**(False)**\n\n**$P_6 = \\{A, Z\\}$**\n1.  **子集条件：** 元素 $Z$ 不是基因全集 $G$ 的成员。此条件不满足。\n**结论：** 子集条件不满足。$P_6$ 不是失调的。**(False)**\n\n按顺序组合这些结果得出最终序列。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the pathway dysregulation problem for a given set of test cases.\n    \"\"\"\n    # Define the universe of genes, score function, and thresholds\n    # as specified in the problem statement.\n    gene_universe = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I'}\n    gene_scores = {\n        'A': 2.4, 'B': 1.5, 'C': -2.1, 'D': -1.2, 'E': 0.2,\n        'F': -3.0, 'G': 1.0, 'H': -1.0, 'I': 0.0\n    }\n    tau_u = 1.0\n    tau_d = 1.0\n\n    # Define the pathways to be evaluated, in order.\n    # Using sets for efficient handling of gene collections.\n    test_cases = [\n        {'A', 'B', 'C', 'D'},        # P1\n        {'A', 'C', 'E', 'F'},        # P2\n        {'G', 'H'},                  # P3\n        {'A', 'C', 'D'},             # P4\n        {'A', 'B', 'C', 'D', 'F', 'H'}, # P5\n        {'A', 'Z'}                   # P6\n    ]\n\n    results = []\n    for pathway in test_cases:\n        results.append(check_dysregulation(pathway, gene_universe, gene_scores, tau_u, tau_d))\n\n    # The final print statement must produce only the specified output format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef check_dysregulation(pathway: set, universe: set, scores: dict, up_thresh: float, down_thresh: float) -> bool:\n    \"\"\"\n    Determines if a given pathway is dysregulated based on three conditions.\n\n    Args:\n        pathway: A set of strings representing the genes in the pathway.\n        universe: A set of strings representing all possible genes.\n        scores: A dictionary mapping gene names to their scores.\n        up_thresh: The positive threshold for up-regulation.\n        down_thresh: The positive threshold for down-regulation.\n\n    Returns:\n        A boolean indicating whether the pathway is dysregulated.\n    \"\"\"\n    # Condition 1: The pathway must be a subset of the gene universe.\n    if not pathway.issubset(universe):\n        return False\n\n    pathway_size = len(pathway)\n\n    # Condition 2: The pathway size must be an even integer >= 2.\n    if pathway_size  2 or pathway_size % 2 != 0:\n        return False\n\n    # Condition 3: Exactly half of genes are up-regulated, and half are down-regulated.\n    required_count = pathway_size // 2\n    up_regulated_count = 0\n    down_regulated_count = 0\n\n    for gene in pathway:\n        score = scores[gene]\n        if score >= up_thresh:\n            up_regulated_count += 1\n        elif score = -down_thresh:\n            down_regulated_count += 1\n        # Genes with scores between -down_thresh and up_thresh are neutral.\n        # A dysregulated pathway cannot contain neutral genes based on the problem's definition.\n        # If the counts of up and down regulated genes sum to pathway_size, then there are no neutral genes.\n    \n    # This check validates both the counts and the absence of neutral genes implicitly.\n    if up_regulated_count == required_count and down_regulated_count == required_count:\n        return True\n    \n    return False\n\n# Execute the solver.\nsolve()\n```"
        }
    ]
}