{
    "hands_on_practices": [
        {
            "introduction": "基因调控网络最常见的结构单元之一是负反馈回路，即一个蛋白质抑制其自身基因的表达。这个练习将指导你将这一生物学过程转化为一个简洁的数学模型，并求解其稳态浓度。通过这个实践，你将掌握建立和分析基本调控模块的核心技能，理解细胞如何利用负反馈来维持内部环境的稳定。",
            "id": "1435734",
            "problem": "一位合成生物学家正在一个细菌宿主中设计一个简单的基因电路。该电路旨在实现负向自动调节，即一个我们称之为阻遏蛋白（R）的蛋白质会抑制其自身基因的表达。在时间 $t$ 时，阻遏蛋白的浓度表示为 $R(t)$。该系统的动力学由以下原理建模：\n\n1.  **生成：** 阻遏蛋白的合成速率由一个抑制性Hill函数描述。当R的浓度为零时，其生成速率达到最大值 $k_p$。随着浓度 $R(t)$ 的增加，该蛋白质与其自身的启动子区域结合，从而抑制合成。这种抑制作用由一个常数 $K$ 来表征，$K$ 定义为能使生成速率降至其最大值一半时的R的浓度。该结合过程是非协同的，对应的Hill系数为 $n=1$。\n\n2.  **降解：** 阻遏蛋白会持续地从细胞中被移除。这个移除过程遵循一级动力学，其特征是降解速率常数为 $k_d$。\n\n所有参数 $k_p$、$k_d$ 和 $K$ 均为正常数。经过足够长的时间后，观察到系统达到一个稳定构型，此时阻遏蛋白的浓度不再变化。确定在这个最终的稳定构型中，阻遏蛋白R的浓度。您的答案应该是一个用参数 $k_p$、$k_d$ 和 $K$ 表示的解析表达式。",
            "solution": "设 $R(t)$ 表示阻遏蛋白的浓度。根据问题描述：\n- 生成过程遵循抑制性Hill函数，其中 $n=1$，在 $R=0$ 时达到最大速率 $k_{p}$，在 $R=K$ 时为半最大速率。因此，生成速率为\n$$\n\\text{生成速率}(R) = \\frac{k_{p}}{1 + \\frac{R}{K}}.\n$$\n- 降解过程遵循一级动力学，速率常数为 $k_{d}$，因此降解速率为\n$$\n\\text{降解速率}(R) = k_{d} R.\n$$\n\n因此，动力学方程为\n$$\n\\frac{dR}{dt} = \\frac{k_{p}}{1 + \\frac{R}{K}} - k_{d} R.\n$$\n\n在最终的稳定构型（稳态）下，$\\frac{dR}{dt}=0$。因此，$R$ 满足\n$$\n\\frac{k_{p}}{1 + \\frac{R}{K}} - k_{d} R = 0.\n$$\n整理得\n$$\n\\frac{k_{p}}{1 + \\frac{R}{K}} = k_{d} R.\n$$\n两边同乘以 $1 + \\frac{R}{K}$：\n$$\nk_{p} = k_{d} R \\left(1 + \\frac{R}{K}\\right) = k_{d} R + \\frac{k_{d}}{K} R^{2}.\n$$\n因此，$R$ 满足以下二次方程\n$$\n\\frac{k_{d}}{K} R^{2} + k_{d} R - k_{p} = 0.\n$$\n设 $a = \\frac{k_{d}}{K}$，$b = k_{d}$，及 $c = -k_{p}$。根据二次方程求根公式，\n$$\nR = \\frac{-b \\pm \\sqrt{b^{2} - 4 a c}}{2 a} = \\frac{-k_{d} \\pm \\sqrt{k_{d}^{2} + \\frac{4 k_{d} k_{p}}{K}}}{2 \\frac{k_{d}}{K}}.\n$$\n因为 $k_{p}, k_{d}, K > 0$，所以具有物理意义的（非负）根应取正号。化简可得，\n$$\nR^{\\ast} = \\frac{K}{2 k_{d}} \\left(-k_{d} + \\sqrt{k_{d}^{2} + \\frac{4 k_{d} k_{p}}{K}}\\right)\n= \\frac{K}{2} \\left(-1 + \\sqrt{1 + \\frac{4 k_{p}}{k_{d} K}}\\right).\n$$\n这就是用参数 $k_{p}$、$k_{d}$ 和 $K$ 表示的阻遏蛋白的稳态浓度。",
            "answer": "$$\\boxed{\\frac{K}{2}\\left(\\sqrt{1+\\frac{4 k_{p}}{k_{d} K}}-1\\right)}$$"
        },
        {
            "introduction": "基因调控网络的魅力不仅在于理解单个模块，更在于揭示它们如何共同作用以实现复杂的生物学功能，例如在发育过程中形成精确的组织边界。本练习将带你探索一个关键问题：分子层面的参数如何决定宏观的生物学模式？你将通过分析一个由形态发生素梯度调控的基因表达模型，推导出发育边界的锐利度与调控蛋白结合的协同性（即Hill系数$n$）之间的定量关系。",
            "id": "2393654",
            "problem": "给定一个一维发育模型，其中一个阻遏子形态发生素沿坐标 $x$ 在区间 $[0,L]$ 上形成空间梯度，一个靶基因根据希尔函数被阻遏。形态发生素的浓度模型为 $M(x) = M_{0}\\,\\exp(-x/\\lambda)$，稳态基因表达水平的模型为 $G(x) = \\dfrac{G_{\\max}}{1 + \\left(\\dfrac{M(x)}{K}\\right)^{n}}$，其中 $n$ 是希尔系数。本问题中所有量均为无量纲量。考虑固定的参数值 $M_{0} = 100$, $K = 1$, $\\lambda = 2$, $L = 20$ 和 $G_{\\max} = 1$。\n\n将边界锐度定义为表达水平分别达到 $0.1\\,G_{\\max}$ 和 $0.9\\,G_{\\max}$ 的位置 $x_{0.1}$ 和 $x_{0.9}$ 之间的宽度 $\\Delta x_{10\\text{--}90}$。即 $G(x_{0.1}) = 0.1\\,G_{\\max}$ 和 $G(x_{0.9}) = 0.9\\,G_{\\max}$，且 $\\Delta x_{10\\text{--}90} = x_{0.9} - x_{0.1}$。假设 $x \\in [0,L]$。\n\n您的任务是为以下测试集中的每个希尔系数 $n$ 计算 $\\Delta x_{10\\text{--}90}$：\n- $n = 0.5$\n- $n = 1$\n- $n = 2$\n- $n = 4$\n- $n = 10$\n\n所有输出必须是实数。您的程序必须生成单行输出，其中包含按测试集顺序排列的结果宽度，四舍五入到 $6$ 位小数，并以逗号分隔列表的形式用方括号括起来。例如，如果五个结果是 $a_{1}$ 到 $a_{5}$，则输出必须是“[a1,a2,a3,a4,a5]”的形式。",
            "solution": "所述问题在科学上是合理的、自洽的且定义明确的。它描述了发育生物学中空间模式形成的一个标准模型，其中形态发生素梯度确立了基因表达的边界。我将进行严谨的解析求解。\n\n目标是计算一个被形态发生素抑制的基因的边界锐度 $\\Delta x_{10\\text{--}90}$。形态发生素浓度 $M(x)$ 和由此产生的基因表达 $G(x)$ 由以下公式给出：\n$$M(x) = M_{0} \\exp(-x/\\lambda)$$\n$$G(x) = \\frac{G_{\\max}}{1 + \\left(\\frac{M(x)}{K}\\right)^{n}}$$\n固定的无量纲参数为 $M_{0} = 100$, $K = 1$, $\\lambda = 2$, $L = 20$ 和 $G_{\\max} = 1$。希尔系数 $n$ 是可变参数。\n\n边界锐度定义为 $\\Delta x_{10\\text{--}90} = x_{0.9} - x_{0.1}$，其中 $x_{0.1}$ 和 $x_{0.9}$ 是基因表达水平分别为其最大值的 $10\\%$ 和 $90\\%$ 时的空间位置。即 $G(x_{0.1}) = 0.1 G_{\\max}$ 和 $G(x_{0.9}) = 0.9 G_{\\max}$。\n\n首先，我们必须推导出一个通用表达式，用于计算基因表达为其最大值的一小部分 $p$ 时的位置 $x_p$：$G(x_p) = p \\cdot G_{\\max}$。\n代入 $G(x)$ 的表达式，我们得到：\n$$p \\cdot G_{\\max} = \\frac{G_{\\max}}{1 + \\left(\\frac{M(x_p)}{K}\\right)^{n}}$$\n由于 $G_{\\max} \\neq 0$，我们可以将两边同时除以 $G_{\\max}$：\n$$p = \\frac{1}{1 + \\left(\\frac{M(x_p)}{K}\\right)^{n}}$$\n现在我们求解该位置的形态发生素浓度 $M(x_p)$：\n$$1 + \\left(\\frac{M(x_p)}{K}\\right)^{n} = \\frac{1}{p}$$\n$$\\left(\\frac{M(x_p)}{K}\\right)^{n} = \\frac{1}{p} - 1 = \\frac{1-p}{p}$$\n$$M(x_p) = K \\left(\\frac{1-p}{p}\\right)^{1/n}$$\n接下来，我们代入形态发生素梯度的表达式 $M(x) = M_{0} \\exp(-x/\\lambda)$ 来求解位置 $x_p$：\n$$M_{0} \\exp(-x_p/\\lambda) = K \\left(\\frac{1-p}{p}\\right)^{1/n}$$\n$$\\exp(-x_p/\\lambda) = \\frac{K}{M_{0}} \\left(\\frac{1-p}{p}\\right)^{1/n}$$\n对两边取自然对数：\n$$-x_p/\\lambda = \\ln\\left[\\frac{K}{M_{0}} \\left(\\frac{1-p}{p}\\right)^{1/n}\\right]$$\n利用对数的性质 $\\ln(ab) = \\ln(a) + \\ln(b)$ 和 $\\ln(a^b) = b\\ln(a)$：\n$$-x_p/\\lambda = \\ln\\left(\\frac{K}{M_{0}}\\right) + \\frac{1}{n} \\ln\\left(\\frac{1-p}{p}\\right)$$\n最终，求解 $x_p$：\n$$x_p = -\\lambda \\left[ \\ln\\left(\\frac{K}{M_{0}}\\right) + \\frac{1}{n} \\ln\\left(\\frac{1-p}{p}\\right) \\right]$$\n使用 $\\ln(a/b) = -\\ln(b/a)$ 和 $\\ln((1-p)/p) = -\\ln(p/(1-p))$，这可以重写为更方便的形式：\n$$x_p = \\lambda \\left[ \\ln\\left(\\frac{M_{0}}{K}\\right) + \\frac{1}{n} \\ln\\left(\\frac{p}{1-p}\\right) \\right]$$\n该方程为任何给定的表达水平分数 $p$ 提供了位置 $x_p$。\n\n现在，我们应用这个通用公式来求 $x_{0.9}$ (其中 $p = 0.9$) 和 $x_{0.1}$ (其中 $p = 0.1$) 。\n对于 $x_{0.9}$：\n$$x_{0.9} = \\lambda \\left[ \\ln\\left(\\frac{M_{0}}{K}\\right) + \\frac{1}{n} \\ln\\left(\\frac{0.9}{1-0.9}\\right) \\right] = \\lambda \\left[ \\ln\\left(\\frac{M_{0}}{K}\\right) + \\frac{1}{n} \\ln(9) \\right]$$\n对于 $x_{0.1}$：\n$$x_{0.1} = \\lambda \\left[ \\ln\\left(\\frac{M_{0}}{K}\\right) + \\frac{1}{n} \\ln\\left(\\frac{0.1}{1-0.1}\\right) \\right] = \\lambda \\left[ \\ln\\left(\\frac{M_{0}}{K}\\right) + \\frac{1}{n} \\ln\\left(\\frac{1}{9}\\right) \\right]$$\n由于 $\\ln(1/9) = -\\ln(9)$，这可以简化为：\n$$x_{0.1} = \\lambda \\left[ \\ln\\left(\\frac{M_{0}}{K}\\right) - \\frac{1}{n} \\ln(9) \\right]$$\n边界锐度 $\\Delta x_{10\\text{--}90}$ 是这两个位置之差：\n$$\\Delta x_{10\\text{--}90} = x_{0.9} - x_{0.1}$$\n$$\\Delta x_{10\\text{--}90} = \\left( \\lambda \\left[ \\ln\\left(\\frac{M_{0}}{K}\\right) + \\frac{1}{n} \\ln(9) \\right] \\right) - \\left( \\lambda \\left[ \\ln\\left(\\frac{M_{0}}{K}\\right) - \\frac{1}{n} \\ln(9) \\right] \\right)$$\n项 $\\lambda \\ln(M_0/K)$ 被消去，得出一个非常简洁的结果：\n$$\\Delta x_{10\\text{--}90} = \\frac{\\lambda}{n} \\ln(9) - \\left(-\\frac{\\lambda}{n} \\ln(9)\\right) = \\frac{2\\lambda}{n} \\ln(9)$$\n这个结果表明，边界锐度与希尔系数 $n$ 成反比，与形态发生素衰减长度 $\\lambda$ 成正比。更高的希尔系数（更像开关的，或超敏的响应）会导致更锐利的边界（更小的 $\\Delta x$）。\n\n现在我们将给定的值 $\\lambda=2$ 代入此公式：\n$$\\Delta x_{10\\text{--}90} = \\frac{2 \\cdot 2}{n} \\ln(9) = \\frac{4}{n} \\ln(9)$$\n$9$ 的自然对数值约为 $\\ln(9) \\approx 2.197224577$。使用这个值，我们为测试集中的每个 $n$ 值计算锐度。\n\n对于 $n=0.5$：\n$$\\Delta x = \\frac{4}{0.5} \\ln(9) = 8 \\ln(9) \\approx 8 \\times 2.197224577 \\approx 17.577797$$\n对于 $n=1$：\n$$\\Delta x = \\frac{4}{1} \\ln(9) = 4 \\ln(9) \\approx 4 \\times 2.197224577 \\approx 8.788898$$\n对于 $n=2$：\n$$\\Delta x = \\frac{4}{2} \\ln(9) = 2 \\ln(9) \\approx 2 \\times 2.197224577 \\approx 4.394449$$\n对于 $n=4$：\n$$\\Delta x = \\frac{4}{4} \\ln(9) = \\ln(9) \\approx 2.197224577 \\approx 2.197225$$\n对于 $n=10$：\n$$\\Delta x = \\frac{4}{10} \\ln(9) = 0.4 \\ln(9) \\approx 0.4 \\times 2.197224577 \\approx 0.878890$$\n\n这些值将根据实现要求进行计算和格式化。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the boundary sharpness for a gene expression pattern formed by a repressor morphogen gradient.\n    \"\"\"\n    \n    # Define the constants from the problem statement.\n    # While M0, K, L, and Gmax are given, they are not needed for the final analytical formula.\n    # The decay length lambda is required.\n    lambda_val = 2.0\n    \n    # Define the test suite of Hill coefficients.\n    hill_coefficients = [0.5, 1.0, 2.0, 4.0, 10.0]\n    \n    results = []\n    \n    # The derived analytical formula for boundary sharpness is:\n    # delta_x_10_90 = (2 * lambda / n) * ln(9)\n    constant_term = 2.0 * lambda_val * np.log(9.0)\n    \n    for n in hill_coefficients:\n        # Calculate the boundary sharpness for the current Hill coefficient.\n        delta_x = constant_term / n\n        \n        # Format the result to 6 decimal places and add to the list.\n        # Using string formatting a la f-string is precise for this task.\n        results.append(f\"{delta_x:.6f}\")\n        \n    # Print the final output in the specified format: [a1,a2,a3,a4,a5]\n    print(f\"[{','.join(results)}]\")\n\n# Execute the solver function.\nsolve()\n```"
        },
        {
            "introduction": "在前面的练习中，我们基于已知的网络结构来预测其行为。然而，在真实的生物学研究中，我们往往面临一个逆向问题：如何通过实验数据来推断未知的网络结构？这个练习将让你扮演系统生物学家的“侦探”角色，利用模拟的基因敲除实验数据，来区分基因之间的直接与间接调控关系。通过解决这个问题，你将体会到网络推断这一生物信息学核心任务的逻辑精髓，并理解如何设计实验来揭示基因调控网络的布线图。",
            "id": "2393624",
            "problem": "您必须编写一个完整的程序，该程序针对基因 $A$、$B$ 和 $C$ 上的几个三基因网络中的每一个，仅使用稳态敲除数据来确定从 $A$ 到 $C$ 的调控是直接的、通过 $B$ 间接的，还是不存在的。建模假设、允许的观测值和要求的输出规定如下。\n\n基因调控网络被建模为处于稳态的线性连续时间系统。令 $x \\in \\mathbb{R}^3$ 表示稳态表达向量，按 $[A,B,C]$ 排序。令 $W \\in \\mathbb{R}^{3 \\times 3}$ 为对角线为零的加权邻接矩阵，其中条目 $W_{ij}$ 代表基因 $j$ 对基因 $i$ 的影响（行是目标，列是调控者），并令 $s \\in \\mathbb{R}^3$ 为一个恒定的基础输入向量。无约束稳态 $x^{(\\varnothing)}$ 满足\n$$\nx^{(\\varnothing)} = W \\, x^{(\\varnothing)} + s,\n$$\n条件是 $W$ 的谱半径严格小于 $1$，从而 $(I - W)$ 可逆且稳态是唯一的。\n\n对子集 $S \\subseteq \\{A,B,C\\}$ 的敲除被建模为：对每个 $i \\in S$ 将 $x_i$ 固定为 $0$，并求解剩余基因的稳态方程。形式上，令 $R = \\{A,B,C\\} \\setminus S$；那么在敲除 $S$ 下的稳态是向量 $x^{(S)} \\in \\mathbb{R}^3$，使得：\n- 对所有 $i \\in S$，$x^{(S)}_i = 0$，\n- $x^{(S)}_R$ 满足\n$$\nx^{(S)}_R = W_{R,R} \\, x^{(S)}_R + s_R,\n$$\n其中 $W_{R,R}$ 和 $s_R$ 是由 $R$ 索引的主子矩阵和子向量。\n\n对于每个网络，您只能使用稳态向量 $x^{(\\varnothing)}$、$x^{(\\{A\\})}$、$x^{(\\{B\\})}$ 和 $x^{(\\{A,B\\})}$ 来确定该网络中三联体 $(A,B,C)$ 的分类。如果 $|u - v| \\le \\varepsilon$ 且 $\\varepsilon = 10^{-8}$，则将两个实数 $u$ 和 $v$ 视为相等。\n\n对每个网络，按如下方式输出一个分类代码：\n- 如果从 $A$ 到 $C$ 的调控是直接的（即，存在一个从 $A$ 到 $C$ 的非零直接影响，该影响不会因敲除 $B$ 而被完全消除），则输出 $2$。\n- 如果从 $A$ 到 $C$ 的调控是通过 $B$ 间接的（即，$A$ 对 $C$ 的任何影响都会因敲除 $B$ 而被消除，且不存在从 $A$ 到 $C$ 的直接影响），则输出 $1$。\n- 如果根据允许的稳态敲除数据检测不到 $A$ 对 $C$ 的影响，则输出 $0$。\n\n您的程序必须实现上述模型，从提供的参数集生成允许的稳态敲除数据，然后仅使用这些数据为每个网络生成所需的分类代码。\n\n测试套件（顺序很重要，基因顺序为 $[A,B,C]$；$W$ 的行是目标，列是调控者）：\n1. 情况 1（仅直接）：\n$$\nW^{(1)} = \\begin{bmatrix}\n0  0  0 \\\\\n0  0  0 \\\\\n0.4  0  0\n\\end{bmatrix},\n\\quad\ns^{(1)} = \\begin{bmatrix} 1 \\\\ 1 \\\\ 1 \\end{bmatrix}.\n$$\n2. 情况 2（仅通过 $B$ 间接）：\n$$\nW^{(2)} = \\begin{bmatrix}\n0  0  0 \\\\\n0.5  0  0 \\\\\n0  0.6  0\n\\end{bmatrix},\n\\quad\ns^{(2)} = \\begin{bmatrix} 1 \\\\ 1 \\\\ 1 \\end{bmatrix}.\n$$\n3. 情况 3（直接和间接均有）：\n$$\nW^{(3)} = \\begin{bmatrix}\n0  0  0 \\\\\n0.4  0  0 \\\\\n0.3  0.5  0\n\\end{bmatrix},\n\\quad\ns^{(3)} = \\begin{bmatrix} 1 \\\\ 1 \\\\ 1 \\end{bmatrix}.\n$$\n4. 情况 4（从 $A$ 到 $C$ 无路径）：\n$$\nW^{(4)} = \\begin{bmatrix}\n0  0  0 \\\\\n0  0  0 \\\\\n0  0  0\n\\end{bmatrix},\n\\quad\ns^{(4)} = \\begin{bmatrix} 1 \\\\ 1 \\\\ 1 \\end{bmatrix}.\n$$\n5. 情况 5（直接和间接，并带有 $C \\rightarrow A$ 的反馈）：\n$$\nW^{(5)} = \\begin{bmatrix}\n0  0  -0.2 \\\\\n0.5  0  0 \\\\\n0.2  0.5  0\n\\end{bmatrix},\n\\quad\ns^{(5)} = \\begin{bmatrix} 1 \\\\ 1 \\\\ 1 \\end{bmatrix}.\n$$\n\n最终输出格式：您的程序应生成单行输出，其中包含五个案例的分类结果，按顺序排列，形式为方括号括起来的逗号分隔列表，例如 $[r_1,r_2,r_3,r_4,r_5]$，其中每个 $r_i$ 是如上定义的集合 $\\{0,1,2\\}$ 中的一个整数。不应打印任何额外文本。",
            "solution": "所提出的问题是计算系统生物学中一个定义明确的练习，具体涉及从稳态扰动数据推断网络拓扑。该问题具有科学依据，数学上精确，且不含任何模糊或矛盾之处。我们将着手进行形式化的求解。\n\n系统由线性稳态方程描述\n$$x = Wx + s$$\n其中 $x \\in \\mathbb{R}^3$ 是指定为 $A$、$B$ 和 $C$（索引分别为 $0$、$1$ 和 $2$）的基因的表达水平向量，$W \\in \\mathbb{R}^{3 \\times 3}$ 是相互作用矩阵，$s \\in \\mathbb{R}^3$ 是基础生产向量。谱半径 $\\rho(W)  1$ 的条件确保了 $(I-W)$ 是可逆的，从而产生唯一的稳态 $x = (I-W)^{-1}s$。\n\n敲除一个基因集 $S$ 对应于将这些基因的表达设置为 $0$，并让由 $R = \\{A,B,C\\} \\setminus S$ 索引的剩余子系统达到一个新的稳态。该子系统的方程是\n$x_R = W_{R,R}x_R + s_R$\n它有唯一解 $x_R = (I_{R,R} - W_{R,R})^{-1}s_R$，前提是主子矩阵 $W_{R,R}$ 也对应一个稳定的系统。完整的状态向量 $x^{(S)}$ 随后通过对 $i \\in S$ 设置 $x_i^{(S)} = 0$ 并用 $x_R$ 的分量填充剩余部分来构建。\n\n任务是仅使用来自四项实验的稳态表达向量来对从基因 $A$ 到基因 $C$ 的调控进行分类：野生型 ($x^{(\\varnothing)}$)、$A$ 敲除型 ($x^{(\\{A\\})}$)、$B$ 敲除型 ($x^{(\\{B\\})}$)以及 $A$ 和 $B$ 双敲除型 ($x^{(\\{A,B\\})}$)。分类的依据是区分直接调控 ($A \\to C$) 和间接调控 ($A \\to B \\to C$)。\n\n我们可以基于从允许的观测中推导出的可量化效应，设计一个逻辑框架。令 $x_C^{(S)}$ 表示在对应于敲除集 $S$ 的稳态下基因 $C$（分量 $x_2$）的表达。\n\n首先，我们必须为 $A$ 对 $C$ 的直接影响定义一个度量，根据定义，这是一种不通过基因 $B$ 介导的影响。这可以通过在基因 $B$ 已经缺失的遗传背景中观察敲除基因 $A$ 的效应来量化。在这些条件下，基因 $C$ 表达的变化分离出了 $A$ 对 $C$ 的不依赖于 $B$ 的影响。我们将直接效应 $\\Delta_{\\text{direct}}$ 定义为：\n$$\\Delta_{\\text{direct}} = x_C^{(\\{B\\})} - x_C^{(\\{A,B\\})}$$\n让我们分析这个表达式。基因 $C$ 的方程是 $x_2 = W_{20}x_0 + W_{21}x_1 + s_2$（因为 $W_{22}=0$）。在 $\\{A,B\\}$ 双敲除下，$x_0 = 0$ 且 $x_1 = 0$，因此方程简化为 $x_2^{(\\{A,B\\})} = s_2$。该实验直接测量了 $C$ 的基础生产。在 $\\{B\\}$ 敲除中，$x_1 = 0$，基因 $A$ 和 $C$ 的子系统达到平衡。因此，表达式 $x_C^{(\\{B\\})}$ 反映了基础生产 $s_2$ 加上来自基因 $A$ 的任何贡献（通过项 $W_{20}x_0^{(\\{B\\})}$ 以及任何如 $W_{02}$ 的反馈）。因此，差值 $\\Delta_{\\text{direct}}$ 分离出了在没有基因 $B$ 的情况下，源于基因 $A$ 对基因 $C$ 的净效应。$\\Delta_{\\text{direct}}$ 的非零值（在数值容差 $\\varepsilon = 10^{-8}$ 内）是存在一个不涉及 $B$ 的从 $A$ 到 $C$ 的调控路径的决定性证据。\n\n其次，我们为 $A$ 对 $C$ 的总影响定义一个度量，这包括所有路径，直接和间接的。这可以通过在野生型背景下敲除 $A$ 后 $C$ 表达的变化来自然地测量：\n$$\\Delta_{\\text{total}} = x_C^{(\\varnothing)} - x_C^{(\\{A\\})}$$\n非零的 $\\Delta_{\\text{total}}$ 表明基因 $A$ 对基因 $C$ 有某种调控影响。\n\n利用这两个可测量的量，我们可以建立一个清晰的分类算法：\n\n1.  **测试直接调控（代码 2）：** 计算 $\\Delta_{\\text{direct}} = x_C^{(\\{B\\})} - x_C^{(\\{A,B\\})}$。如果 $|\\Delta_{\\text{direct}}| > \\varepsilon$，则表示存在从 $A$ 到 $C$ 的直接调控影响（或通过不涉及 B 的路径）。这符合代码 $2$ 的定义。\n\n2.  **测试仅间接调控（代码 1）：** 如果第一个测试失败，即 $|\\Delta_{\\text{direct}}| \\le \\varepsilon$，这意味着任何从 $A$ 到 $C$ 的调控在 $B$ 被敲除时都会被消除。然后我们检查一开始是否存在任何调控。我们计算 $\\Delta_{\\text{total}} = x_C^{(\\varnothing)} - x_C^{(\\{A\\})}$。如果 $|\\Delta_{\\text{total}}| > \\varepsilon$，我们得出结论：存在从 $A$ 到 $C$ 的影响，但它必须完全通过 $B$ 来介导。这符合代码 $1$ 的定义。\n\n3.  **测试无调控（代码 0）：** 如果以上两个测试都失败，即 $|\\Delta_{\\text{direct}}| \\le \\varepsilon$ 且 $|\\Delta_{\\text{total}}| \\le \\varepsilon$，那么根据可用数据，没有可检测到的 $A$ 对 $C$ 的影响。这对应于代码 $0$。\n\n对于每个提供的测试用例 $(W, s)$，实现将按以下步骤进行：\na) 对于四个敲除集 $S \\in \\{\\varnothing, \\{A\\}, \\{B\\}, \\{A,B\\}\\}$ 中的每一个，计算稳态向量 $x^{(S)}$。这涉及确定剩余基因 $R$，构建子矩阵 $M_R = I_{R,R} - W_{R,R}$ 和子向量 $s_R$，并求解线性系统 $M_R x_R = s_R$。\nb) 从四个计算出的向量中提取基因 $C$ ($x_2$) 的表达水平。\nc) 计算 $\\Delta_{\\text{direct}}$ 和 $\\Delta_{\\text{total}}$。\nd) 应用上述分类逻辑来确定相应的整数代码。\ne) 收集所有测试用例的代码，并以指定格式呈现。需要使用数值线性代数库来稳健地求解方程组。",
            "answer": "```python\nimport numpy as np\n\ndef solve_steady_state(W, s, knockout_indices):\n    \"\"\"\n    Solves for the steady-state gene expression vector for a given network\n    and a set of knocked-out genes.\n\n    Args:\n        W (np.ndarray): The 3x3 weighted adjacency matrix.\n        s (np.ndarray): The 3x1 basal input vector.\n        knockout_indices (set): A set of indices (0, 1, or 2) for the genes to be knocked out.\n\n    Returns:\n        np.ndarray: The 3x1 steady-state expression vector x.\n    \"\"\"\n    all_indices = {0, 1, 2}\n    remaining_indices = sorted(list(all_indices - knockout_indices))\n\n    if not remaining_indices:\n        return np.zeros(3)\n\n    W_rr = W[np.ix_(remaining_indices, remaining_indices)]\n    s_r = s[remaining_indices]\n\n    # The system to solve is x_R = W_R,R * x_R + s_R\n    # which can be rewritten as (I - W_R,R) * x_R = s_R\n    I_rr = np.identity(len(remaining_indices))\n    A_matrix = I_rr - W_rr\n\n    # Solve the linear system for the remaining genes\n    try:\n        x_r = np.linalg.solve(A_matrix, s_r)\n    except np.linalg.LinAlgError:\n        # This case should not occur for the given problem constraints (rho(W)  1)\n        # and its sub-systems.\n        return np.full(3, np.nan) \n\n    # Construct the full steady-state vector\n    x_full = np.zeros(3)\n    for i, idx in enumerate(remaining_indices):\n        x_full[idx] = x_r[i]\n        \n    return x_full\n\ndef solve():\n    \"\"\"\n    Main function to process test cases and produce the final classification.\n    \"\"\"\n    # Problem parameters\n    # Gene indices: A=0, B=1, C=2\n    # Row=target, Col=regulator\n    \n    test_cases = [\n        # Case 1 (direct only)\n        (np.array([[0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.4, 0.0, 0.0]]), np.array([1.0, 1.0, 1.0])),\n        # Case 2 (indirect only via B)\n        (np.array([[0.0, 0.0, 0.0], [0.5, 0.0, 0.0], [0.0, 0.6, 0.0]]), np.array([1.0, 1.0, 1.0])),\n        # Case 3 (both direct and indirect)\n        (np.array([[0.0, 0.0, 0.0], [0.4, 0.0, 0.0], [0.3, 0.5, 0.0]]), np.array([1.0, 1.0, 1.0])),\n        # Case 4 (no path from A to C)\n        (np.array([[0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]]), np.array([1.0, 1.0, 1.0])),\n        # Case 5 (direct and indirect with feedback C -> A)\n        (np.array([[0.0, 0.0, -0.2], [0.5, 0.0, 0.0], [0.2, 0.5, 0.0]]), np.array([1.0, 1.0, 1.0]))\n    ]\n\n    results = []\n    epsilon = 1e-8\n    C_INDEX = 2\n\n    for W, s in test_cases:\n        # Generate the four required steady-state vectors from knockout experiments\n        x_wild_type = solve_steady_state(W, s, set())\n        x_ko_A = solve_steady_state(W, s, {0})\n        x_ko_B = solve_steady_state(W, s, {1})\n        x_ko_AB = solve_steady_state(W, s, {0, 1})\n\n        # Extract the expression level of gene C\n        x_C_wild_type = x_wild_type[C_INDEX]\n        x_C_ko_A = x_ko_A[C_INDEX]\n        x_C_ko_B = x_ko_B[C_INDEX]\n        x_C_ko_AB = x_ko_AB[C_INDEX]\n\n        # Calculate the direct and total effects\n        delta_direct = x_C_ko_B - x_C_ko_AB\n        delta_total = x_C_wild_type - x_C_ko_A\n\n        # Apply the classification logic\n        if abs(delta_direct) > epsilon:\n            # Code 2: A has an effect on C even when B is knocked out,\n            # indicating a direct path (or path not involving B).\n            results.append(2)\n        elif abs(delta_total) > epsilon:\n            # Code 1: The direct effect is zero, but the total effect is non-zero.\n            # This means the effect of A on C is entirely mediated by B.\n            results.append(1)\n        else:\n            # Code 0: The total effect of A on C is zero (or negligible).\n            results.append(0)\n    \n    # Print the final output in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}