{
    "hands_on_practices": [
        {
            "introduction": "RNA测序（RNA-seq）数据的一个基本特性是其“成分性”：我们测量的是每个基因在总转录本库中所占的相对比例，而非其绝对分子数量。这就好比一个固定大小的饼图，如果其中一块变得非常大，其他所有块即使代表的绝对值不变，其相对份额也会被压缩变小。这个练习  通过一个具体的计算场景，让您亲身体验这一重要概念，理解为何一个基因的剧烈上调会导致其他表达稳定的基因在标准化后看起来像是被下调了。",
            "id": "2417849",
            "problem": "一位实验者在两种条件 $A$ 和 $B$ 下进行RNA测序（RNA-seq；核糖核酸测序），每个样本使用相同数量的细胞，且没有使用外部对照或spike-in。每个文库被测序到恰好 $100000$ 个比对上的读数。该实验产生的读数计数，在期望上，与文库中每个基因贡献的转录本分子所占的比例成正比。实验者采用了一种标准的总计数缩放归一化方法（每百万读数计数，CPM），该方法将每个基因的计数除以样本的总比对读数，从而比较相对丰度。\n\n考虑一个由一个基因 $X$ 和另外 $990$ 个基因组成的基因集。每个细胞中真实的绝对转录本分子数如下：\n\n- 在条件 $A$ 中：基因 $X$ 有 $1000$ 个分子；其余 $990$ 个基因每个有 $100$ 个分子。\n- 在条件 $B$ 中：基因 $X$ 强烈过表达，有 $50000$ 个分子；其余 $990$ 个基因每个仍保持 $100$ 个分子。\n\n假设测序过程是根据这些基础的转录本比例来抽样读数的，并且忽略抽样方差。实验者使用CPM归一化后的值，计算了条件 $B$ 相对于条件 $A$ 的以2为底的对数倍数变化。\n\n在这种归一化方法下，对于那些未发生变化的其他基因（非 $X$）中的任意一个，哪个选项最能描述其表观的以2为底的对数倍数变化，并说明原因？\n\nA. 对于大多数其他基因，大约为 $-0.58$，因为在条件 $B$ 中，单个高丰度基因 $X$ 降低了所有未变化基因的相对比例，使得它们在总计数归一化下表现为下调。\n\nB. 对于大多数其他基因，大约为 $0$，因为总计数归一化完全消除了由单个基因过表达引起的组分效应。\n\nC. 对于大多数其他基因，大约为 $+0.58$，因为条件 $B$ 中总RNA含量的大幅增加提高了所有归一化后的计数值。\n\nD. 这取决于测序深度；在总计数归一化下，将读数从 $100000$ 增加到 $200000$ 会使大多数其他基因的表观以2为底的对数倍数变化趋向于 $0$。",
            "solution": "对问题陈述进行验证。\n\n**步骤1：提取已知条件**\n- 实验：在两种条件 $A$ 和 $B$ 下进行RNA测序。\n- 重复：问题描述了两个样本，每种条件一个。每个样本的细胞数量相同。\n- 对照：未使用外部对照或spike-in。\n- 测序深度：每个文库被测序到恰好 $100000$ 个比对上的读数。\n- 实验原理：读数计数在期望上与每个基因的转录本分子比例成正比。\n- 归一化：总计数缩放（每百万读数计数，CPM），定义为将每个基因的计数除以样本的总比对读数并进行缩放。\n- 基因集：一个基因 $X$ 和另外 $990$ 个基因。\n- 真实的绝对丰度（每个细胞的分子数）：\n    - 条件 $A$：基因 $X$ 有 $1000$ 个分子。其余 $990$ 个基因每个有 $100$ 个分子。\n    - 条件 $B$：基因 $X$ 有 $50000$ 个分子。其余 $990$ 个基因每个有 $100$ 个分子。\n- 假设：\n    1.  测序过程按基础的转录本比例抽样读数。\n    2.  抽样方差被忽略。\n- 问题：使用CPM归一化值，计算在比较条件 $B$ 与条件 $A$ 时，任何一个未变化基因的表观以2为底的对数倍数变化。\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学依据**：该问题描述了组分数据分析中的一个经典且根本性的问题，这也是RNA-seq实验的一个特点。在总计数归一化下，一个高表达基因会扭曲其他基因的相对丰度，这一概念是生物信息学中一个公认的假象。其原理在科学上是合理的。\n- **适定性**：该问题是适定的。它提供了所有必要的数值数据和一个清晰、无歧义的问题，可以通过直接计算得到唯一解。\n- **客观性**：问题以精确、客观的语言陈述，没有主观论断或含糊之处。\n\n**步骤3：结论与行动**\n问题陈述是有效的。这是一个标准的、尽管是简化的模型，用以说明转录组学中简单归一化方法的缺陷。我将继续推导解决方案。\n\n**推导**\n\n如前所述，RNA-seq实验的核心先验假设是，比对到某个基因的读数数量与样本中该基因转录本的总数成正比。由于我们忽略了抽样方差，我们将这种比例关系视为一种精确关系。我们用基因 $Y$ 表示这 $990$ 个未变化基因中的任意一个。\n\n1.  **计算每种条件下每个细胞的总转录本分子数：**\n    每个细胞的总分子数是计算每个基因分子比例的分母。\n    -   在条件 $A$ 中，总分子数 $T_A$ 为：\n        $$T_A = (\\text{X的分子数}) + (990 \\times \\text{其他基因的分子数}) = 1000 + (990 \\times 100) = 1000 + 99000 = 100000 \\text{ 个分子}$$\n    -   在条件 $B$ 中，总分子数 $T_B$ 为：\n        $$T_B = (\\text{X的分子数}) + (990 \\times \\text{其他基因的分子数}) = 50000 + (990 \\times 100) = 50000 + 99000 = 149000 \\text{ 个分子}$$\n\n2.  **计算每种条件下基因 $Y$ 的期望读数计数：**\n    一个基因的期望读数计数是文库中的总比对读数乘以该基因的分子比例。\n    -   在条件 $A$ 中，基因 $Y$ 的分子比例为 $f_{Y,A} = \\frac{100}{T_A} = \\frac{100}{100000}$。基因 $Y$ 的期望读数计数 $C_{Y,A}$ 为：\n        $$C_{Y,A} = (\\text{总读数}) \\times f_{Y,A} = 100000 \\times \\frac{100}{100000} = 100\n        $$\n    -   在条件 $B$ 中，基因 $Y$ 的分子比例为 $f_{Y,B} = \\frac{100}{T_B} = \\frac{100}{149000}$。基因 $Y$ 的期望读数计数 $C_{Y,B}$ 为：\n        $$C_{Y,B} = (\\text{总读数}) \\times f_{Y,B} = 100000 \\times \\frac{100}{149000} \\approx 67.114\n        $$\n\n3.  **计算CPM归一化值和倍数变化：**\n    CPM归一化公式为 $CPM = \\frac{\\text{基因计数}}{\\text{总比对读数}} \\times 10^6$。我们需要计算基因 $Y$ 在条件 $B$ 和 $A$ 之间的CPM值的倍数变化。\n\n    -   $CPM_{Y,A} = \\frac{C_{Y,A}}{\\text{总读数}_A} \\times 10^6 = \\frac{100}{100000} \\times 10^6 = 1000$\n    -   $CPM_{Y,B} = \\frac{C_{Y,B}}{\\text{总读数}_B} \\times 10^6 = \\frac{100000 \\times \\frac{100}{149000}}{100000} \\times 10^6 = \\frac{100}{149000} \\times 10^6 \\approx 671.14$\n\n    归一化值的倍数变化 ($FC$) 是比率 $\\frac{CPM_{Y,B}}{CPM_{Y,A}}$。\n    $$FC = \\frac{CPM_{Y,B}}{CPM_{Y,A}} = \\frac{\\frac{100}{149000} \\times 10^6}{\\frac{100}{100000} \\times 10^6} = \\frac{100000}{149000} \\approx 0.67114$$\n    注意，缩放因子 $10^6$ 和相同的总比对读数会相互抵消，因此CPM值的倍数变化等同于原始计数的比率，而原始计数的比率又等同于基础分子比例的比率。\n\n4.  **计算以2为底的对数倍数变化：**\n    问题要求的是以2为底的对数倍数变化。\n    $$\\log_2(FC) = \\log_2\\left(\\frac{100000}{149000}\\right) \\approx \\log_2(0.67114)$$\n    $$\\log_2(FC) \\approx -0.5753$$\n    这个值约等于 $-0.58$。\n\n**逐项分析**\n\n-   **A. 对于大多数其他基因，大约为 $-0.58$，因为在条件 $B$ 中，单个高丰度基因 $X$ 降低了所有未变化基因的相对比例，使得它们在总计数归一化下表现为下调。**\n    -   计算出的值 $\\approx -0.5753$ 与所述的大约 $-0.58$ 相匹配。\n    -   其提供的理由完全正确。在条件 $B$ 中，来自基因 $X$ 的转录本的大量增加夸大了用于计算相对丰度的分母 ($T_B$)。因此，所有其他绝对分子数未变的基因的读数相对比例必然下降。总计数归一化方法会固化这种失真，从而导致这些基因被下调的人为结论。\n    -   **结论：正确。**\n\n-   **B. 对于大多数其他基因，大约为 $0$，因为总计数归一化完全消除了由单个基因过表达引起的组分效应。**\n    -   计算结果显示了一个非零值。\n    -   其理由根本上是错误的。总计数归一化（如CPM）正是将这种组分假象*引入*最终报告值的方法。它并不能消除这种效应，反而对它们很敏感。对这种假象具有鲁棒性的方法，如TMM或RLE，其基础假设是大多数基因*没有*差异表达，而总计数归一化并未使用这一假设。\n    -   **结论：错误。**\n\n-   **C. 对于大多数其他基因，大约为 $+0.58$，因为条件 $B$ 中总RNA含量的大幅增加提高了所有归一化后的计数值。**\n    -   符号错误。计算得出的对数倍数变化为负值，表明表观下调。\n    -   其推理存在缺陷。虽然条件 $B$ 中的总RNA含量增加，但归一化计数是总量的*分数*。当分母（总RNA含量）增加而一个基因的分子（其自身的RNA含量）保持不变时，最终得到的分数会*减小*。\n    -   **结论：错误。**\n\n-   **D. 这取决于测序深度；在总计数归一化下，将读数从 $100000$ 增加到 $200000$ 会使大多数其他基因的表观以2为底的对数倍数变化趋向于 $0$。**\n    -   表观的对数倍数变化是由*相对分子比例*的比率决定的，而不是由读数的绝对数量决定的。如推导所示，在计算CPM归一化值之间的倍数变化时，只要被比较的两个样本的测序深度相同，总测序深度就是一个可以完全抵消的缩放因子。如果我们将两个样本的深度都从 $100000$ 改为 $200000$，CPM值将保持不变，因此倍数变化也将保持不变。这是一个组分问题，而不是测序深度问题。\n    -   **结论：错误。**",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "在理解了数据的内在成分性之后，我们来处理另一个在真实世界实验中普遍存在的挑战：批次效应。当样本在不同时间或不同条件下处理时，会引入与生物学无关的技术变异，这些变异可能会掩盖或扭曲我们真正关心的生物学信号。本练习  将指导您完成一个实际的编程任务，使用线性模型这一强大工具来识别并从数据中“移除”这些不请自来的批次效应，从而将抽象的统计理论转化为净化数据的实用技能。",
            "id": "2417834",
            "problem": "您的任务是形式化并实现一种有原则的方法，使用线性模型来消除核糖核酸测序 (RNA-seq) 数据中的批次效应。考虑一个计数矩阵，其中基因由 $g \\in \\{1,\\dots,G\\}$ 索引，样本由 $i \\in \\{1,\\dots,N\\}$ 索引。设 $c_{g,i} \\in \\mathbb{N}_0$ 为样本 $i$ 中基因 $g$ 的观测原始读数计数。每个样本有两个二元协变量：一个生物学条件指示符 $z_i \\in \\{0,1\\}$ 和一个批次指示符 $b_i \\in \\{0,1\\}$。目标是在转换后表达值的线性模型中将批次效应建模为一个加性项，然后通过计算消除批次的贡献。\n\n从第一性原理定义以下内容。\n\n1. 大小因子归一化。对于每个样本 $i$，设文库大小为 $L_i = \\sum_{g=1}^G c_{g,i}$。定义大小因子 $s_i$ 为\n$$\ns_i = \\frac{L_i}{\\frac{1}{N}\\sum_{j=1}^N L_j}.\n$$\n2. 对数转换的归一化表达值。对于一个固定的伪计数 $c_0 > 0$，定义\n$$\ny_{g,i} = \\log_2\\Big(\\frac{c_{g,i}}{s_i} + c_0\\Big).\n$$\n使用 $c_0 = 1.0$。\n\n3. 每个基因的线性模型。对于每个基因 $g$，使用普通最小二乘法对所有样本 $i$ 的 $y_{g,i}$ 进行建模，其设计矩阵包含三列：截距、条件指示符和批次指示符。也就是说，对于每个 $g$，\n$$\ny_{g,i} = \\beta_{g,0} + \\beta_{g,\\text{cond}}\\; z_i + \\beta_{g,\\text{batch}}\\; b_i + \\varepsilon_{g,i},\n$$\n其中 $\\varepsilon_{g,i}$ 是零均值残差。通过最小化所有样本 $i \\in \\{1,\\dots,N\\}$ 上的残差平方和来估计 $(\\beta_{g,0}, \\beta_{g,\\text{cond}}, \\beta_{g,\\text{batch}})$。\n\n4. 批次效应消除。对于每个基因 $g$ 和样本 $i$，定义批次校正后的表达值\n$$\n\\tilde{y}_{g,i} = y_{g,i} - \\beta_{g,\\text{batch}}\\; b_i.\n$$\n\n5. 评估统计量。对于每个基因 $g$ 和每个条件水平 $z \\in \\{0,1\\}$，如果两个批次中都至少有一个样本具有该条件（即，存在至少一个 $i$ 使得 $z_i = z$ 且 $b_i = 0$，并且存在至少一个 $i$ 使得 $z_i = z$ 且 $b_i = 1$），计算\n$$\nd_{g}(z) = \\Big(\\text{mean of } \\tilde{y}_{g,i} \\text{ over } i \\text{ with } z_i = z,\\, b_i = 1\\Big) - \\Big(\\text{mean of } \\tilde{y}_{g,i} \\text{ over } i \\text{ with } z_i = z,\\, b_i = 0\\Big).\n$$\n对于每个基因 $g$，定义\n$$\nD_g = \\max_{z \\in \\{0,1\\} \\text{ valid}} \\left| d_{g}(z) \\right|,\n$$\n其中最大值取自上文所述的有效条件水平 $z$。如果对于基因 $g$ 没有有效的条件水平，则定义 $D_g = 0$。\n\n对于下面的每个测试用例，计算评估统计量\n$$\nR = \\max_{g \\in \\{1,\\dots,G\\}} D_g,\n$$\n并报告 $R$ 值，四舍五入到小数点后六位。\n\n测试套件。为以下三个独立的测试用例精确地实现上述定义。在每个用例中，$G$ 是基因数（行），$N$ 是样本数（列），计数矩阵是 $C = (c_{g,i})$，条件向量是 $(z_1,\\dots,z_N)$，批次向量是 $(b_1,\\dots,b_N)$。\n\n- 测试用例 1：\n  - $G = 3$, $N = 4$。\n  - 计数 $C$（行 $g=1,2,3$；列 $i=1,2,3,4$）：\n    $$\n    \\begin{bmatrix}\n    100  150  160  240 \\\\\n    80  160  128  256 \\\\\n    40  40  64  64\n    \\end{bmatrix}\n    $$\n  - 条件向量 $(z_1,z_2,z_3,z_4) = (0,1,0,1)$。\n  - 批次向量 $(b_1,b_2,b_3,b_4) = (0,0,1,1)$。\n\n- 测试用例 2：\n  - $G = 3$, $N = 4$。\n  - 计数 $C$：\n    $$\n    \\begin{bmatrix}\n    60  90  90  120 \\\\\n    30  30  30  60 \\\\\n    10  20  20  20\n    \\end{bmatrix}\n    $$\n  - 条件向量 $(z_1,z_2,z_3,z_4) = (0,1,1,0)$。\n  - 批次向量 $(b_1,b_2,b_3,b_4) = (0,0,0,1)$。\n\n- 测试用例 3：\n  - $G = 5$, $N = 4$。\n  - 计数 $C$：\n    $$\n    \\begin{bmatrix}\n    200  300  260  390 \\\\\n    500  750  500  750 \\\\\n    0  0  5  8 \\\\\n    1000  1500  1000  1500 \\\\\n    0  0  0  0\n    \\end{bmatrix}\n    $$\n  - 条件向量 $(z_1,z_2,z_3,z_4) = (0,0,1,1)$。\n  - 批次向量 $(b_1,b_2,b_3,b_4) = (0,1,0,1)$。\n\n最终输出格式。您的程序应生成一行输出，其中包含三个测试用例的结果 $R$（已四舍五入），结果为逗号分隔的列表，并用方括号括起来。例如，一个可接受的输出格式是\n$$\n[\\text{result}_1,\\text{result}_2,\\text{result}_3].\n$$\n所有数字输出必须是浮点数，并精确四舍五入到小数点后六位。不应打印任何其他文本。",
            "solution": "该问题要求形式化并实现一个计算过程，以消除 RNA 测序 (RNA-seq) 计数数据中的批次效应。该方法基于一个应用于对数转换后归一化表达值的线性模型。然后使用一个定义的统计指标来评估批次校正的效果。整个过程将按照规定逐步执行。\n\n基本原理是将观测到的基因表达建模为多种效应的线性组合：一个基线表达水平（截距）、一个由目标生物学条件引起的效应，以及一个由实验批次引起的不期望的效应。通过使用普通最小二乘法 (OLS) 估计批次效应的大小，我们随后可以从数据中算术减去该分量，从而得到批次校正后的表达值。\n\n计算步骤如下：\n\n首先，我们处理不同样本间测序深度变化的这一技术性假象。这通过大小因子归一化来完成。对于每个样本 $i$，文库大小 $L_i$ 计算为所有基因 $G$ 的读数计数总和：$L_i = \\sum_{g=1}^G c_{g,i}$。样本 $i$ 的大小因子，记为 $s_i$，是其文库大小与所有 $N$ 个样本的平均文库大小之比：\n$$\ns_i = \\frac{L_i}{\\frac{1}{N}\\sum_{j=1}^N L_j}\n$$\n通过样本 $i$ 对应的大小因子 $s_i$ 对原始计数 $c_{g,i}$ 进行归一化，可将计数调整至一个共同的尺度。\n\n其次，将归一化后的计数转换到对数尺度。这种转换有两个目的：它稳定了方差，因为 RNA-seq 数据的方差通常依赖于均值；它还将计数数据中固有的乘法关系转换为适合线性建模的加法框架。添加一个伪计数 $c_0 = 1.0$ 以防止对零取对数，并缓和低表达基因的方差。对数转换后的表达值 $y_{g,i}$ 定义为：\n$$\ny_{g,i} = \\log_2\\Big(\\frac{c_{g,i}}{s_i} + c_0\\Big)\n$$\n\n第三，对于每个基因 $g$，对所有样本 $i=1, \\dots, N$ 的对数转换表达值 $y_{g,i}$ 拟合一个线性模型。该模型将 $y_{g,i}$ 对所提供的协变量进行回归：一个截距项、二元条件指示符 $z_i$ 和二元批次指示符 $b_i$。模型是：\n$$\ny_{g,i} = \\beta_{g,0} + \\beta_{g,\\text{cond}}\\; z_i + \\beta_{g,\\text{batch}}\\; b_i + \\varepsilon_{g,i}\n$$\n对于单个基因 $g$，用矩阵表示法为 $Y_g = X\\beta_g + \\varepsilon_g$，其中 $Y_g$ 是基因 $g$ 的 $N \\times 1$ 表达值向量，$X$ 是 $N \\times 3$ 的设计矩阵，其列分别为截距（全为 1）、条件向量 $(z_1, \\dots, z_N)^T$ 和批次向量 $(b_1, \\dots, b_N)^T$。系数向量 $\\beta_g = (\\beta_{g,0}, \\beta_{g,\\text{cond}}, \\beta_{g,\\text{batch}})^T$ 使用普通最小二乘法 (OLS) 进行估计，该方法最小化残差平方和 $\\sum_i \\varepsilon_{g,i}^2$。OLS 估计由 $\\hat{\\beta}_g = (X^T X)^{-1} X^T Y_g$ 给出，前提是设计矩阵 $X$ 是满列秩的。我们特别关注的是 $\\hat{\\beta}_{g,\\text{batch}}$，即基因 $g$ 的估计批次效应。\n\n第四，消除批次效应。对于每个基因 $g$ 和样本 $i$，通过从原始的对数转换值中减去估计的批次分量来计算批次校正后的表达值 $\\tilde{y}_{g,i}$：\n$$\n\\tilde{y}_{g,i} = y_{g,i} - \\hat{\\beta}_{g,\\text{batch}}\\; b_i\n$$\n此校正仅应用于属于批次 $b_i=1$ 的样本，有效地将其表达水平调整到与批次 $b_i=0$ 的基线相匹配。\n\n第五，评估校正的成功与否。对于每个基因 $g$，我们按生物学条件分层，测量批次间表达的残余均值差异。对于给定的条件水平 $z \\in \\{0,1\\}$，如果该条件下存在来自两个批次（$b_i=0$ 和 $b_i=1$）的样本，我们计算：\n$$\nd_{g}(z) = \\Big(\\text{mean}_{i: z_i=z, b_i=1} \\tilde{y}_{g,i}\\Big) - \\Big(\\text{mean}_{i: z_i=z, b_i=0} \\tilde{y}_{g,i}\\Big)\n$$\n有效的校正应导致 $d_g(z) \\approx 0$。统计量 $D_g$ 捕捉了基因 $g$ 在所有有效条件水平下的最坏情况残余批次效应：\n$$\nD_g = \\max_{z \\in \\{0,1\\} \\text{ valid}} \\left| d_{g}(z) \\right|\n$$\n如果不存在可供比较的有效条件水平，则 $D_g$ 定义为 $0$。\n\n最后，给定数据集的总体评估统计量 $R$ 是这些逐基因统计量的最大值，代表了校正后数据中存在的最大残余批次效应：\n$$\nR = \\max_{g \\in \\{1,\\dots,G\\}} D_g\n$$\n\n为求解每个提供的测试用例的 $R$ 值，我们实现了这整个计算序列。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_case(C, z, b):\n    \"\"\"\n    Solves a single test case for batch effect removal and evaluation.\n\n    Args:\n        C (np.ndarray): Count matrix (G x N).\n        z (np.ndarray): Condition vector (N,).\n        b (np.ndarray): Batch vector (N,).\n\n    Returns:\n        float: The evaluation statistic R, rounded to 6 decimal places.\n    \"\"\"\n    G, N = C.shape\n    C = C.astype(np.float64)\n    z = z.astype(np.float64)\n    b = b.astype(np.float64)\n    c0 = 1.0\n\n    # Step 1: Size-factor normalization\n    L = C.sum(axis=0)\n    L_mean = L.mean()\n    s = L / L_mean\n\n    # Step 2: Log-transformed normalized expression\n    # Use np.divide and np.newaxis for broadcasting s across rows of C\n    y = np.log2(np.divide(C, s[np.newaxis, :]) + c0)\n\n    # Step 3: Linear model per gene\n    # Construct the design matrix X\n    X = np.vstack([np.ones(N), z, b]).T\n\n    # Check for collinearity. If not full rank, OLS is ill-defined.\n    # The problem statement guarantees full-rank designs for the test cases.\n    # if np.linalg.matrix_rank(X)  X.shape[1]:\n    #     raise ValueError(\"Design matrix is not full column rank.\")\n\n    # Fit the model for each gene to get beta_batch\n    beta_batch_g = np.zeros(G)\n    for g in range(G):\n        # np.linalg.lstsq returns a tuple; the first element is the solution vector\n        beta_hat, _, _, _ = np.linalg.lstsq(X, y[g, :], rcond=None)\n        beta_batch_g[g] = beta_hat[2]\n\n    # Step 4: Batch-effect removal\n    # Subtract beta_batch * b_i from each y_gi\n    # This can be done with broadcasting\n    y_tilde = y - beta_batch_g[:, np.newaxis] * b[np.newaxis, :]\n\n    # Step 5: Evaluation statistic\n    D_g = np.zeros(G)\n    for g in range(G):\n        d_g_z_abs = []\n        \n        # Check condition z=0\n        z0_b0_indices = np.where((z == 0)  (b == 0))[0]\n        z0_b1_indices = np.where((z == 0)  (b == 1))[0]\n        if len(z0_b0_indices) > 0 and len(z0_b1_indices) > 0:\n            mean_b1_z0 = np.mean(y_tilde[g, z0_b1_indices])\n            mean_b0_z0 = np.mean(y_tilde[g, z0_b0_indices])\n            d_g_0 = mean_b1_z0 - mean_b0_z0\n            d_g_z_abs.append(np.abs(d_g_0))\n            \n        # Check condition z=1\n        z1_b0_indices = np.where((z == 1)  (b == 0))[0]\n        z1_b1_indices = np.where((z == 1)  (b == 1))[0]\n        if len(z1_b0_indices) > 0 and len(z1_b1_indices) > 0:\n            mean_b1_z1 = np.mean(y_tilde[g, z1_b1_indices])\n            mean_b0_z1 = np.mean(y_tilde[g, z1_b0_indices])\n            d_g_1 = mean_b1_z1 - mean_b0_z1\n            d_g_z_abs.append(np.abs(d_g_1))\n\n        if len(d_g_z_abs) > 0:\n            D_g[g] = np.max(d_g_z_abs)\n        else:\n            D_g[g] = 0.0\n\n    # Final result R\n    R = np.max(D_g) if len(D_g) > 0 else 0.0\n    \n    return round(R, 6)\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run them, and print results.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        {\n            \"C\": np.array([\n                [100, 150, 160, 240],\n                [80, 160, 128, 256],\n                [40, 40, 64, 64]\n            ]),\n            \"z\": np.array([0, 1, 0, 1]),\n            \"b\": np.array([0, 0, 1, 1])\n        },\n        # Test case 2\n        {\n            \"C\": np.array([\n                [60, 90, 90, 120],\n                [30, 30, 30, 60],\n                [10, 20, 20, 20]\n            ]),\n            \"z\": np.array([0, 1, 1, 0]),\n            \"b\": np.array([0, 0, 0, 1])\n        },\n        # Test case 3\n        {\n            \"C\": np.array([\n                [200, 300, 260, 390],\n                [500, 750, 500, 750],\n                [0, 0, 5, 8],\n                [1000, 1500, 1000, 1500],\n                [0, 0, 0, 0]\n            ]),\n            \"z\": np.array([0, 0, 1, 1]),\n            \"b\": np.array([0, 1, 0, 1])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(case[\"C\"], case[\"z\"], case[\"b\"])\n        results.append(f\"{result:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在对数据进行清理和校正后，最后也是至关重要的一步是质量控制（QC），以确保数据的完整性和准确性，例如，验证样本标签是否与其实际生物学特性相符。本练习  将挑战您像生物信息学家一样思考，利用性别特异性基因的表达差异，设计一个稳健的QC指标来检测样本性别是否标注错误或存在交叉污染。这个过程将促使您深入思考，一个优秀的统计指标应如何考虑归一化、特异性和生物学原理，以在复杂的真实数据中发挥可靠作用。",
            "id": "2417798",
            "problem": "您正在评估人类批量核糖核酸测序 (RNA-seq) 文库的样本身份。元数据显示了每个样本的既定生理性别（男性或女性）。您希望设计一个单一样本水平的质量控制统计量，通过利用性别特异性基因（特别是Y染色体上的基因）的表达来标记潜在的污染或标签错误，同时对变化的测序深度、基因长度和比对模糊性具有鲁棒性。您可以假设对于每个样本，您拥有基因水平的读数计数 $c_g$、有效转录本长度 $L_g$、总比对片段数 $N$，以及计算诸如每百万转录本（TPM）等标准归一化方法的方式。您还有一个经过筛选的集合 $Y$，其中包含男性特异性的、高可比对性的Y连锁标记基因，这些基因排除了伪常染色体区和旁系同源区；您还了解X失活特异性转录本（XIST），这是一种在女性中表达但在男性中通常被沉默的基因。设 $\\delta$ 表示一个小的正伪计数。\n\n考虑到上述限制，以下哪项定义了最适合用于检测性别不一致或污染的指标？\n\nA. 如果比对到Y染色体上任何位置的读数 absolute 数量超过 $100$，则宣布样本被污染。\n\nB. 计算性别不一致分数\n$$\nS \\;=\\; \\log_2\\!\\left(\\frac{\\sum_{g\\in Y} \\mathrm{TPM}^{\\mathrm{uniq}}_g + \\delta}{\\mathrm{TPM}_{\\mathrm{XIST}} + \\delta}\\right),\n$$\n其中 $\\mathrm{TPM}^{\\mathrm{uniq}}_g$ 是根据基因 $g\\in Y$ 的唯一比对片段和有效长度计算得出的。如果一个标记为女性的样本的 $S$ 值高于选定阈值，或者一个标记为男性的样本的 $S$ 值低于该阈值，则标记该样本。\n\nC. 使用染色体水平的比率\n$$\nR \\;=\\; \\frac{\\text{总比对到Y染色体的读数}}{\\text{总比对到X染色体的读数}},\n$$\n如果对于标记为女性的样本，$R$ 超过一个固定阈值，或者对于标记为男性的样本，$R$ 低于该阈值，则宣布不一致。\n\nD. 使用线粒体读数分数\n$$\nM \\;=\\; \\frac{\\text{比对到线粒体基因组的读数}}{N},\n$$\n如果与队列中位数相比，$M$ 异常高，则宣布污染。\n\nE. 计算比例\n$$\nP \\;=\\; \\frac{1}{|Y|}\\sum_{g\\in Y}\\mathbf{1}\\{c_g \\geq 1\\},\n$$\n如果在一个标记为女性的样本中，$P$ 超过一个固定阈值，则宣布污染。",
            "solution": "问题要求为检测人类批量RNA-seq样本中的性别不一致（标签错误）或异性交叉污染，制定一个鲁棒的质量控制指标。这类指标的核心要求是，它必须利用性别特异性基因表达，对测序深度和基因长度的变化具有鲁棒性，并考虑到比对模糊性。\n\n让我们根据所提供的信息，为有效的指标建立原则。\n1.  **生物学基础**：基本的生物学差异在于染色体组成：男性是XY，女性是XX。一个有效的指标必须利用这一点。问题提供了一个经过筛选的男性特异性Y连锁基因集 $Y$，以及X失活特异性转录本 `XIST`，`XIST` 在女性中高表达以介导X染色体失活，但在男性中通常是沉默的。一个强大的指标应该将Y连锁标记物的表达与 `XIST` 的表达进行对比。\n2.  **对测序深度的鲁棒性**：每个样本的总读数数量 $N$ 可能有很大差异。任何基于原始读数计数 $c_g$ 的指标都会受到这种变化的严重影响。因此，对文库大小进行归一化是必不可少的。\n3.  **对基因长度的鲁棒性**：比对到一个基因的读数数量与其长度 $L_g$ 成正比。一个将基因的读数计数相加而没有考虑其长度的指标将会产生偏差。为了进行基因间的比较，需要对基因长度进行归一化。\n4.  **对比对模糊性的鲁棒性**：源自重复序列或具有近旁系同源基因（例如，在其他染色体上）的读数可能会被比对算法错误放置。这对于Y染色体尤其成问题，因为它与X染色体共享伪常染色体区（PARs）。问题正确地建议使用一个经过筛选的`高可比对性`非PAR基因集 $Y$，并且作为一项额外措施，可以筛选唯一比对的读数。\n\n一个满足这些要点的指标很可能涉及每百万转录本（TPM），因为TPM归一化的定义是：\n$$\n\\mathrm{TPM}_g = \\left( \\frac{c_g / L_g}{\\sum_{k} (c_k / L_k)} \\right) \\times 10^6\n$$\n其中 $k$ 遍历所有基因。这个公式明确地对基因长度 $L_g$（在 $c_g / L_g$ 项中）和测序深度（在分母中，它与总文库大小成正比）都进行了归一化。\n\n利用这些原则，我们现在来评估每个选项。\n\n**A. 如果比对到Y染色体上任何位置的读数绝对数量超过 $100$，则宣布样本被污染。**\n该指标基于一个绝对读数计数的固定阈值。\n- 它对测序深度不具鲁棒性。一个测序深度非常高的女性样本可能会由于背景噪音或比对错误而累积超过 $100$ 个伪读数，导致假阳性。相反，一个测序深度较浅的男性样本可能产生少于 $100$ 个读数，导致假阴性。\n- 它对比对模糊性不具鲁棒性。通过考虑“Y染色体上任何位置”的读数，它包含了伪常染色体区和其他模糊位点，已知这些位点即使在女性样本中也会吸引读数。它未能利用提供的高可比对性基因集 $Y$。\n- $100$ 的阈值是任意的，不能推广到不同的实验或测序技术。\n因此，这种方法存在根本性缺陷。\n**结论：不正确。**\n\n**B. 计算性别不一致分数 $$S \\;=\\; \\log_2\\!\\left(\\frac{\\sum_{g\\in Y} \\mathrm{TPM}^{\\mathrm{uniq}}_g + \\delta}{\\mathrm{TPM}_{\\mathrm{XIST}} + \\delta}\\right)$$，其中 $\\mathrm{TPM}^{\\mathrm{uniq}}_g$ 是根据基因 $g\\in Y$ 的唯一比对片段和有效长度计算得出的。如果一个标记为女性的样本的 $S$ 值高于选定阈值，或者一个标记为男性的样本的 $S$ 值低于该阈值，则标记该样本。**\n该指标构建了一个男性表达特征与女性表达特征的比率。\n- 它正确地利用了性别特异性标记物：分子捕获了来自经过筛选的Y连锁基因（$g \\in Y$）的表达，而分母捕获了 `XIST` 的表达。\n- 它对测序深度和基因长度具有鲁棒性，因为它使用了TPM，这是一种专门为此目的设计的归一化方法。\n- 它通过两种方式对比对模糊性具有鲁棒性：它使用了经过筛选的高可比对性基因集 $Y$，并且它指定了TPM应该从`唯一比对片段`（$\\mathrm{TPM}^{\\mathrm{uniq}}$）计算得出。\n- 使用对数转换在统计上是合理的，因为它有助于创建更对称的分数分布。伪计数 $\\delta$ 防止了除以零。最终得分 $S$ 提供了一个连续的度量，允许进行比任意计数截断更鲁棒的经验阈值设定。高 $S$ 值表示男性样特征（高Y表达，低 `XIST`），低 $S$ 值表示女性样特征（低Y表达，高 `XIST`）。这是正确的解释。\n该指标满足所有陈述的要求，是一个鲁棒且科学合理地统计量。\n**结论：正确。**\n\n**C. 使用染色体水平的比率 $$R \\;=\\; \\frac{\\text{总比对到Y染色体的读数}}{\\text{总比对到X染色体的读数}}$$，如果对于标记为女性的样本，$R$ 超过一个固定阈值，或者对于标记为男性的样本，$R$ 低于该阈值，则宣布不一致。**\n该指标使用在染色体水平上汇总的原始读数计数的比率。\n- 它对X染色体上基因内容和表达模式的巨大差异不具鲁棒性。分母，“总比对到X染色体的读数”，是大量基因的函数，其中许多基因与性别决定无关，其表达可能因生物状态而急剧变化，使比率 $R$ 不稳定且充满噪音。\n- 它未能对基因长度进行归一化。\n- 通过使用“总比对读数”，它未能考虑来自PARs和其他同源区域的比对模糊性。\n- 这种方法比特异性和灵敏度都比像B那样的基于基因集的方法低。\n**结论：不正确。**\n\n**D. 使用线粒体读数分数 $$M \\;=\\; \\frac{\\text{比对到线粒体基因组的读数}}{N}$$，如果与队列中位数相比，$M$ 异常高，则宣布污染。**\n该指标测量线粒体读数的比例。\n- 虽然高线粒体读数分数是一个有效且重要的QC指标，但它通常指示细胞活力（例如，细胞凋亡）或RNA质量的问题，而不是关于性别的样本身份。\n- 该指标完全没有使用性别特异性基因表达。它没有提供任何信息来区分男性样本和女性样本。\n- 因此，它完全不适用于所述的检测性别不一致的任务。\n**结论：不正确。**\n\n**E. 计算比例 $$P \\;=\\; \\frac{1}{|Y|}\\sum_{g\\in Y}\\mathbf{1}\\{c_g \\geq 1\\}$$，如果在一个标记为女性的样本中，$P$ 超过一个固定阈值，则宣布污染。**\n该指标计算基因集 $Y$ 中被至少一个读数检测到的基因的比例。\n- 条件 $c_g \\geq 1$ 对测序深度高度敏感。一个测序深度较浅的男性样本可能无法检测到某些Y连锁基因，而一个测序深度很高的女性样本可能会检测到几个Y连锁基因的伪读数。这违反了对深度鲁棒性的要求。\n- 它通过将计数二值化，丢弃了所有的定量表达信息。一个有一个读数的基因与一个有数千个读数的基因被同等对待，这是信息和统计效力的一大损失。\n- 该指标不如基于像TPM这样适当归一化的表达度量的指标强大和鲁棒。\n**结论：不正确。**\n\n总而言之，选项B是唯一一个提出了满足RNA-seq分析中鲁棒、灵敏且特异的性别检查统计量的所有关键要求的指标。无论从生物学还是生物信息学的角度来看，它都设计得很好。",
            "answer": "$$\\boxed{B}$$"
        }
    ]
}