{
    "hands_on_practices": [
        {
            "introduction": "一个看似表现良好的伪随机数生成器，其一维分布可能看起来完美均匀，但这有时会掩盖其在更高维度中的严重缺陷。这个练习 () 将引导你亲手揭示这一现象。你将实现一个简单的线性同余生成器，并看到尽管它在一维上完美均匀，但其连续数值对 $(U_i, U_{i+1})$ 在二维平面上却会形成清晰的晶格结构，从而让你对伪随机数的“随机性”有更深刻的认识。",
            "id": "3264088",
            "problem": "考虑由整数模的剩余类上的确定性映射产生的序列，以及它们在归一化到单位区间后的行为。设 $m \\in \\mathbb{N}$，序列 $(X_i)_{i \\ge 0}$ 满足 $X_i \\in \\{0,1,\\dots,m-1\\}$，其归一化形式为 $U_i = X_i / m \\in [0,1)$。一维边际均匀性被离散地定义为在一个完整周期内每个剩余类恰好被访问一次，而二维结构则通过连续对 $(U_i, U_{i+1})$ 的几何形状来评估。\n\n从模算术和剩余类双射的基本定义出发，设计并实现能生成具有以下性质序列的生成器：\n- 一个生成器，其在 $\\{0,1,\\dots,m-1\\}$ 上的一维边际分布是精确均匀的，即在一个周期内每个剩余类恰好出现一次。\n- 一个生成器，其连续对 $(X_i, X_{i+1})$ 满足线性模关系，使得归一化后的 $(U_i,U_{i+1})$ 在二维空间中呈现出易于检测的几何结构。\n\n您的程序必须：\n1. 为每个测试用例生成所需的序列。\n2. 为每个测试用例计算以下量化指标，所有指标均基于归一化对 $(U_i, U_{i+1})$：\n    - 一维均匀性比率，定义为 $|\\mathrm{VisitedStates}| / m$，其中 $|\\mathrm{VisitedStates}|$ 是在一个检测到的周期内观察到的 $\\{X_i\\}$ 中不同值的数量。该比率为 $[0,1]$ 内的实数。\n    - 在 $[0,1) \\times [0,1)$ 上的大小为 $G \\times G$ 的均匀网格的占用计数，定义为被点对集合 $(U_i, U_{i+1})$ 击中的不同网格单元的数量，单元格索引为 $(\\lfloor G U_i \\rfloor, \\lfloor G U_{i+1} \\rfloor)$。该计数是一个整数。\n    - 点对云 $(U_i,U_{i+1})$ 各分量之间的皮尔逊相关系数，计算范围为所有可用的点对。该系数是一个实数。\n    - 模差 $(X_{i+1} - X_i) \\bmod m$ 在宽度为 $m/G$ 的粗分箱下的不同分箱数量，即 $\\left\\lfloor \\frac{(X_{i+1} - X_i) \\bmod m}{m/G} \\right\\rfloor$ 的不同值的计数。该计数是一个整数。\n\n仅使用模算术和剩余类双射的定义作为基本基础。不要依赖任何未经证实的快捷公式。您必须从第一性原理推导出为什么一维边际分布可以做到精确均匀，同时二维连续对图可以显示出可见的结构。\n\n实现以下测试套件，其设计旨在覆盖一般情况、边界情况和比较情况。对于所有情况，使用 $G = 64$：\n- 情况 A (加法同余，完整周期)：模数 $m = 4096$，增量 $c = 5$，种子 $X_0 = 0$。通过连续模 $m$ 加 $c$ 来生成序列，直到状态重复，然后在第一次重复时停止。\n- 情况 B (加法同余，短周期边界情况)：模数 $m = 4096$，增量 $c = 512$，种子 $X_0 = 0$。通过连续模 $m$ 加法生成序列，直到状态重复，然后停止。\n- 情况 C (线性同余，一般情况)：模数 $m = 4096$，乘数 $a = 5$，增量 $c = 1$，种子 $X_0 = 1$。通过重复应用模 $m$ 的线性映射来生成序列，直到状态重复，然后停止。\n- 情况 D (独立均匀基线)：模数 $m = 4096$，种子 $s = 12345$。生成 $m$ 个独立样本 $U_i \\in [0,1)$，设置 $X_i = \\lfloor m U_i \\rfloor$，并使用前 $m$ 个值，不进行周期检测。\n\n对于每种情况，使用所有可用的连续对 $(U_i, U_{i+1})$ 计算上面列出的四个指标，其中索引 $i$ 遍历该情况生成序列的位置，并在不进行环绕配对时在最后一个元素之前停止。将所有量表示为无单位的纯数字。\n\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，该列表被方括号括起，每个案例的结果是一个四元素列表，顺序为：[均匀性比率, 占用计数, 相关系数, 差值分箱数]。例如，输出应类似于 $[[r_1,o_1,\\rho_1,b_1],[r_2,o_2,\\rho_2,b_2],[r_3,o_3,\\rho_3,b_3],[r_4,o_4,\\rho_4,b_4]]$，不含多余的空格或文本。",
            "solution": "该问题要求分析和实现通过模算术生成的确定性序列，这种序列常用于伪随机数生成。任务的核心是从第一性原理出发，理解这些序列的性质，特别是一维均匀性和二维结构。\n\n## 基本原理\n\n### 模算术与线性同余生成器 (LCG)\n序列 $(X_i)_{i \\ge 0}$ 在模 $m$ 的剩余类集合 $\\mathbb{Z}_m = \\{0, 1, \\dots, m-1\\}$ 内生成。一个被广泛研究的此类生成器是线性同余生成器 (LCG)，由以下递推关系定义：\n$$X_{i+1} = (a X_i + c) \\bmod m$$\n其中 $m > 0$ 是模数， $a$ 是乘数， $c$ 是增量， $X_0$ 是种子。当 $a=1$ 时，该生成器称为加法同余生成器 (ACG)。归一化序列由 $U_i = X_i/m \\in [0, 1)$ 给出。\n\n### 一维均匀性与周期性\n一个好的生成器的关键特性是长周期。周期是满足对所有 $i$ 都有 $X_{i+p} = X_i$ 的最小正数 $p$。为使生成器发挥最大效用，我们希望周期尽可能大。一个 LCG 当且仅当它在重复之前恰好生成了 $\\{0, 1, \\dots, m-1\\}$ 中的每个整数一次时，才具有 $m$ 的完整周期。这赋予了完美的一维边际均匀性，意味着均匀性比率 $|\\mathrm{VisitedStates}|/m$ 精确为 $1$。\n\n达到完整周期的条件取决于参数 $a$、$c$ 和 $m$。\n1.  **对于 ACG ($a=1$)：** 递推关系为 $X_{i+1} = (X_i + c) \\bmod m$。状态序列是模 $m$ 的一个算术级数。该序列具有完整周期 $m$ 的充要条件是增量 $c$ 是加法群 $\\mathbb{Z}_m$ 的一个生成元，这要求 $c$ 与 $m$ 互质。即 $\\gcd(c, m) = 1$。如果 $\\gcd(c, m) = d > 1$，周期会缩短为 $m/d$。\n\n2.  **对于 LCG ($a>1$)：** 当模数 $m$ 是 2 的幂，比如 $m = 2^k$ 且 $k \\ge 2$ 时，著名的 Hull-Dobell 定理指出 LCG 具有完整周期 $m$ 的充要条件是：\n    -   $c$ 是奇数 (即 $\\gcd(c, m) = 1$)。\n    -   $a \\equiv 1 \\pmod 4$。\n\n### 二维结构\nLCG 的确定性特性给连续对 $(X_i, X_{i+1})$ 施加了严格的结构。对 LCG 递推关系进行归一化，我们得到：\n$$m U_{i+1} = (a m U_i + c) \\pmod m$$\n两边除以 $m$ 得：\n$$U_{i+1} = (a U_i + c/m) \\pmod 1$$\n此方程揭示了所有连续对 $(U_i, U_{i+1})$ 都位于有限数量的平行超平面上。在二维空间中，这些是直线。具体来说，这些点落在由 $y = ax + c/m - k$ 定义的线段上，其中整数 $k$ 的取值使得该直线与单位正方形 $[0,1) \\times [0,1)$ 相交。这种固有的晶格结构是一种“易于检测的几何结构”，也是 LCG 的一个众所周知的弱点，而指定的指标正是为了量化这一点。\n\n## 测试用例分析\n\n对于所有情况，用于占用率指标的网格大小为 $G=64$。\n\n**情况 A：加法同余，完整周期**\n($m=4096$, $c=5$, $X_0=0$, $a=1$)\n-   **均匀性：** $m=4096=2^{12}$ 且 $c=5$。因为 $5$ 是奇数，它与 2 的幂没有公因子，所以 $\\gcd(5, 4096)=1$。该 ACG 具有 $m=4096$ 的完整周期。序列会恰好访问 $\\{0, \\dots, 4095\\}$ 中的每个状态一次。均匀性比率为 $4096/4096 = 1.0$。\n-   **结构：** 点对 $(U_i, U_{i+1})$ 满足 $U_{i+1} = (U_i + 5/4096) \\pmod 1$。这些点位于两条平行的直线上。预计会有很强的正相关性。模差 $(X_{i+1} - X_i) \\bmod m$ 总是 $5$。这个单一的值会落入分箱 $\\lfloor 5 / (4096/64) \\rfloor = \\lfloor 5/64 \\rfloor = 0$ 中。因此，差值分箱数为 $1$。\n\n**情况 B：加法同余，短周期**\n($m=4096$, $c=512$, $X_0=0$, $a=1$)\n-   **均匀性：** 这里 $c=512=2^9$。最大公约数为 $\\gcd(512, 4096) = 512$。周期为 $m/\\gcd(c,m) = 4096/512 = 8$。序列只访问 $8$ 个状态。均匀性比率为 $8/4096 = 1/512$。\n-   **结构：** 这 $8$ 个状态都是 $512$ 的倍数。点对 $(U_i, U_{i+1})$ 位于单条直线 $y=x+1/8$ 上。相关性将是完美的。模差总是 $512$，落入分箱 $\\lfloor 512 / 64 \\rfloor = 8$。差值分箱数为 $1$。\n\n**情况 C：线性同余，一般情况**\n($m=4096$, $a=5$, $c=1$, $X_0=1$)\n-   **均匀性：** 满足 Hull-Dobell 条件：$m=2^{12}$，$c=1$ 是奇数，且 $a=5 \\equiv 1 \\pmod 4$。该 LCG 具有 $m=4096$ 的完整周期。均匀性比率为 $1.0$。\n-   **结构：** 点对 $(U_i, U_{i+1})$ 位于由 $U_{i+1} = (5 U_i + 1/4096) \\pmod 1$ 定义的 $a=5$ 条平行线上。模差为 $(X_{i+1} - X_i) \\bmod m = (4X_i + 1) \\bmod m$。由于 $X_i$ 遍历所有剩余类，且 $\\gcd(4, 4096)=4$，差值会取 $4096/4=1024$ 个不同的值，所有值都与 $1 \\pmod 4$ 同余。这些值是 $\\{1, 5, 9, \\dots\\}$。这 $1024$ 个值在 $[0, 4096)$ 上分布良好，将落入所有 $G=64$ 个宽度为 $m/G=64$ 的分箱中。差值分箱数将为 $64$。\n\n**情况 D：独立均匀基线**\n($m=4096$, $s=12345$)\n-   此情况可作为“良好”随机性的基准，其中连续值是独立的。\n-   **均匀性：** 抽取 $m=4096$ 个值。访问到的唯一状态数与优惠券收集者问题有关。唯一值的期望数量为 $m(1-(1-1/m)^m) \\approx m(1-1/e) \\approx 0.632m$。所以比率应接近 $0.632$。\n-   **结构：** 对于独立的点对 $(U_i, U_{i+1})$，点应该均匀地散布在单位正方形上，没有可辨别的线性结构。皮尔逊相关系数应接近 $0$。这些点应占据许多网格单元，其期望计数与均匀性结果相似，约为 $m(1-e^{-1}) \\approx 2588$。模差 $(X_{i+1}-X_i)\\bmod m$ 将近似均匀地分布在 $\\{0, \\dots, m-1\\}$ 上。对于 $4095$ 个这样的差值，所有 $64$ 个分箱被访问到的概率极高。差值分箱数应为 $64$。\n\n## 量化指标\n问题定义了需要计算的四个指标：\n1.  **均匀性比率：** $R_U = \\frac{|\\{X_i\\}|}{m}$，其中 $|\\{X_i\\}|$ 是一个周期内访问到的不同状态的数量。\n2.  **占用计数：** $N_{occ} = |\\{(\\lfloor G U_i \\rfloor, \\lfloor G U_{i+1} \\rfloor)\\}|$，即点对 $(U_i, U_{i+1})$ 在 $G \\times G$ 网格中击中的唯一单元格数量。\n3.  **皮尔逊相关系数：** $\\rho(U_i, U_{i+1}) = \\frac{\\mathrm{Cov}(U_i, U_{i+1})}{\\sigma_{U_i}\\sigma_{U_{i+1}}}$，衡量连续归一化值之间的线性相关性。\n4.  **差值分箱数：** $N_{db} = |\\{\\lfloor \\frac{(X_{i+1}-X_i)\\bmod m}{m/G} \\rfloor\\}|$，即模差所击中的粗分箱的唯一数量。\n\n现在，实现将遵循这些原理来生成序列，并为每种情况计算指定的指标。",
            "answer": "```python\nimport numpy as np\n\ndef generate_sequence_lcg(m, a, c, x0):\n    \"\"\"\n    Generates a sequence from a Linear Congruential Generator (LCG)\n    X_{i+1} = (a * X_i + c) mod m, until the first state repeats.\n    \"\"\"\n    seq = []\n    # Use a dictionary for fast lookups and to store the first occurrence index.\n    visited = {}\n    x = x0\n    i = 0\n    while x not in visited:\n        visited[x] = i\n        seq.append(x)\n        x = (a * x + c) % m\n        i += 1\n    return np.array(seq, dtype=np.int64)\n\ndef calculate_metrics(X, m, G):\n    \"\"\"\n    Calculates the four specified metrics for a given sequence X.\n    \"\"\"\n    # 1. One-dimensional uniformity ratio\n    # Using np.unique is a robust way to count distinct elements.\n    num_distinct_states = len(np.unique(X))\n    uniformity_ratio = num_distinct_states / m\n\n    if len(X)  2:\n        # Cannot compute pair-based metrics if sequence length is less than 2.\n        return [uniformity_ratio, 0, 0.0, 0]\n\n    # Create consecutive pairs from the sequence\n    X_i = X[:-1]\n    X_ip1 = X[1:]\n\n    # Normalize pairs to the unit interval [0, 1)\n    U_i = X_i / m\n    U_ip1 = X_ip1 / m\n\n    # 2. Occupancy count of a uniform grid\n    grid_indices = np.floor(np.vstack([U_i * G, U_ip1 * G]).T).astype(np.int32)\n    # Using a set of tuples is an efficient way to count unique 2D integer points.\n    unique_cells = set(map(tuple, grid_indices))\n    occupancy_count = len(unique_cells)\n\n    # 3. Pearson correlation coefficient\n    # Check for constant series to avoid NaN from division by zero in correlation formula.\n    if np.std(U_i) == 0 or np.std(U_ip1) == 0:\n        correlation = 1.0 if np.array_equal(U_i, U_ip1) else 0.0\n    else:\n        correlation = np.corrcoef(U_i, U_ip1)[0, 1]\n\n    # 4. Number of distinct bins of the modular difference\n    # np.mod ensures the result is in [0, m), correctly handling negative differences.\n    diff = np.mod(X_ip1 - X_i, m)\n    bin_width = m / G\n    diff_bins = np.floor(diff / bin_width)\n    diff_bin_count = len(np.unique(diff_bins))\n    \n    return [uniformity_ratio, occupancy_count, correlation, diff_bin_count]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results in the required format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Format: (name, (m, a, c, x0), G) or (name, (m, seed), G)\n    test_cases = [\n        ('A', (4096, 1, 5, 0), 64),\n        ('B', (4096, 1, 512, 0), 64),\n        ('C', (4096, 5, 1, 1), 64),\n        ('D', (4096, 12345), 64)\n    ]\n\n    results = []\n    for case in test_cases:\n        name, params, G = case\n        \n        if name == 'D':\n            m, seed = params\n            # Generate sequence for Case D (independent uniform baseline)\n            rng = np.random.default_rng(seed=seed)\n            U = rng.random(size=m)\n            X = np.floor(m * U).astype(np.int64)\n        else:\n            # Generate sequence for Cases A, B, C (LCGs)\n            m, a, c, x0 = params\n            X = generate_sequence_lcg(m, a, c, x0)\n            \n        metrics = calculate_metrics(X, m, G)\n        results.append(metrics)\n\n    # The final print statement must produce the exact single-line format.\n    # repr() creates a string representation of the list, and replace() removes spaces.\n    print(repr(results).replace(\" \", \"\"))\n\nsolve()\n```"
        },
        {
            "introduction": "在实际编程中，我们常常需要将一个大范围的随机整数映射到一个较小的目标范围，一个看似直观的方法是使用取模运算符。然而，这个常见的操作可能引入微妙但严重的偏差，破坏随机数的均匀性。通过这个练习 ()，你将从第一性原理出发，分析并量化这种“取模偏见”，并理解在何种条件下可以安全地使用它，这是保证模拟和抽样结果准确性的关键一步。",
            "id": "3264136",
            "problem": "一个伪随机整数生成器产生输出 $X$，$X$ 在离散集合 $\\{0,1,\\dots,M-1\\}$ 上独立同分布且服从均匀分布。一位从业者希望通过计算 $Y = X \\bmod N$ 来获得 $\\{0,1,\\dots,N-1\\}$ 中的整数，其中 $\\bmod$ 表示除以 $N$ 的余数。假设 $M$ 和 $N$ 是正整数，且 $M \\geq N$。你的任务是从均匀离散分布和整数除法的基本原理出发，推断 $Y$ 在何种情况下是均匀分布的，以及偏差是如何产生的。然后，具体分析 $M = 2^{31}$ 和 $N = 10$ 的情况，并量化其结果分布。\n\n选择所有正确的陈述：\n\nA. 对于任意的 $M$ 和 $N$，随机变量 $Y = X \\bmod N$ 在 $\\{0,1,\\dots,N-1\\}$ 上精确均匀分布。\n\nB. 随机变量 $Y = X \\bmod N$ 在 $\\{0,1,\\dots,N-1\\}$ 上精确均匀分布，当且仅当 $N$ 整除 $M$。\n\nC. 对于 $M = 2^{31}$ 和 $N = 10$，令 $q = \\left\\lfloor \\dfrac{M}{N} \\right\\rfloor = 214748364$ 且 $r = M - Nq = 8$，则有\n$$\\mathbb{P}(Y=y) = \\frac{q+1}{M} = \\frac{214748365}{2147483648} \\text{ for } y \\in \\{0,1,2,3,4,5,6,7\\},$$\n和\n$$\\mathbb{P}(Y=y) = \\frac{q}{M} = \\frac{214748364}{2147483648} \\text{ for } y \\in \\{8,9\\}.$$\n\nD. $Y$ 中的偏差仅由有限精度浮点运算引起；在精确整数运算中，$Y$ 对于任何 $M$ 和 $N$ 都是均匀分布的。\n\nE. 如果丢弃任何满足 $X \\geq N \\left\\lfloor \\dfrac{M}{N} \\right\\rfloor$ 的 $X$，否则返回 $Y = X \\bmod N$，那么得到的 $Y$ 在 $\\{0,1,\\dots,N-1\\}$ 上是精确均匀分布的。",
            "solution": "首先验证问题陈述，以确保其科学性和逻辑严谨性。\n\n### 第1步：提取已知条件\n- 生成一个伪随机变量 `$X$`。\n- `$X$` 的值是独立同分布的。\n- `$X$` 的分布在离散集合 `$\\{0, 1, \\dots, M-1\\}$` 上是均匀的。\n- 定义了一个新的随机变量 `$Y$` 为 `$Y = X \\bmod N$`，其中 `$\\bmod$` 是 `$X$` 除以 `$N$` 的整数除法余数。\n- `$M$` 和 `$N$` 是正整数。\n- 给定约束条件 `$M \\geq N$`。\n- 任务是分析 `$Y$` 的分布，确定其均匀分布的条件，并分析 `$M = 2^{31}$` 和 `$N = 10$` 的具体情况。\n\n### 第2步：使用提取的已知条件进行验证\n问题具有科学依据，提法恰当且客观。这是伪随机数生成器分析中的一个标准问题，依赖于概率论和数论的基本原理。前提清晰、一致，不违反任何基本定律。语言精确且数学化。为具体案例提供的值 `$M = 2^{31}$` 代表了常见的32位线性同余生成器的输出范围。未发现任何缺陷。\n\n### 第3步：结论与行动\n问题有效。将从第一性原理推导 `$Y$` 的分布，然后评估每个选项。\n\n### 推导\n随机变量 `$X$` 在集合 `$\\{0, 1, \\dots, M-1\\}$` 上均匀分布。这意味着对于任何整数 `$k \\in \\{0, 1, \\dots, M-1\\}$`，`$X$` 取值为 `$k$` 的概率是：\n$$ \\mathbb{P}(X=k) = \\frac{1}{M} $$\n随机变量 `$Y$` 定义为 `$Y = X \\bmod N$`。`$Y$` 的可能取值是集合 `$\\{0, 1, \\dots, N-1\\}$` 中的整数。\n\n为了找到 `$Y$` 的概率分布，我们必须确定对于每个 `$y \\in \\{0, 1, \\dots, N-1\\}$` 的 `$\\mathbb{P}(Y=y)$`。事件 `$Y=y$` 发生当且仅当 `$X$` 取一个值 `$k$` 使得 `$k \\bmod N = y$`。概率 `$\\mathbb{P}(Y=y)$` 是所有这些 `$k$` 的概率之和。\n$$ \\mathbb{P}(Y=y) = \\sum_{k \\in \\{0, \\dots, M-1\\} \\text{ s.t. } k \\bmod N = y} \\mathbb{P}(X=k) $$\n由于对所有 `$k$` 都有 `$\\mathbb{P}(X=k) = 1/M$`，这可以简化为：\n$$ \\mathbb{P}(Y=y) = \\frac{1}{M} \\cdot |\\{k \\in \\{0, 1, \\dots, M-1\\} \\mid k \\bmod N = y\\}| $$\n其中 `$|\\cdot|$` 表示集合中元素的数量。\n\n让我们来计算 `$\\{0, 1, \\dots, M-1\\}$` 中有多少个整数除以 `$N$` 的余数是 `$y$`。我们可以使用带余除法将 `$M$` 写成 `$M = qN + r$`，其中 `$q = \\lfloor M/N \\rfloor$` 是商，`$r = M \\bmod N$` 是余数，且 $0 \\le r  N$。\n\n从 `$0$` 到 `$M-1$` 的整数可以被分成大小为 `$N$` 的完整块。\n- 数字 `$\\{0, 1, \\dots, N-1\\}$` 产生余数 `$\\{0, 1, \\dots, N-1\\}$`。\n- 数字 `$\\{N, N+1, \\dots, 2N-1\\}$` 产生余数 `$\\{0, 1, \\dots, N-1\\}$`。\n- ...\n这个模式重复 `$q = \\lfloor M/N \\rfloor$` 个完整的块。从 `$0$` 到 `$qN-1$` 的数字覆盖了 `$q$` 个完整的余数周期。因此，对于每个 `$y \\in \\{0, 1, \\dots, N-1\\}$`，在范围 `$\\{0, 1, \\dots, qN-1\\}$` 中恰好有 `$q$` 个 `$X$` 的值映射到 `$y$`。\n\n`$X$` 的其余值在范围 `$\\{qN, qN+1, \\dots, M-1\\}$` 内。这个范围内的值的数量是 `$M-1 - qN + 1 = M - qN = r$`。\n这些值是 `$\\{qN, qN+1, \\dots, qN+r-1\\}$`。\n这些数除以 `$N$` 的余数是 `$\\{0, 1, \\dots, r-1\\}$`。\n因此：\n- 对于 `$y \\in \\{0, 1, \\dots, r-1\\}$`，还有一个额外的 `$X$` 值（来自最后一个不完整的块）映射到 `$y$`。这样的 `$y$` 的总数是 `$q+1$`。\n- 对于 `$y \\in \\{r, r+1, \\dots, N-1\\}$`，没有额外的 `$X$` 值。这样的 `$y$` 的总数是 `$q$`。\n\n因此 `$Y$` 的概率分布为：\n$$ \\mathbb{P}(Y=y) = \\begin{cases} \\frac{q+1}{M}  \\text{for } y \\in \\{0, 1, \\dots, r-1\\} \\\\ \\frac{q}{M}  \\text{for } y \\in \\{r, r+1, \\dots, N-1\\} \\end{cases} $$\n其中 `$q = \\lfloor M/N \\rfloor$` 和 `$r = M \\bmod N$`。\n\n`$Y$` 的分布是均匀的，当且仅当对所有 `$y \\in \\{0, 1, \\dots, N-1\\}$`，`$\\mathbb{P}(Y=y)` 都相同。这要求要么第一种情况覆盖所有的 `$y$`（即 `$r-1=N-1 \\implies r=N$`，这是不可能的，因为 `$r",
            "answer": "$$\\boxed{BCE}$$"
        },
        {
            "introduction": "伪随机数生成器的确定性结构，虽然是其“伪”随机性的根源，但也可以被巧妙地利用，成为一个强大的特性。在并行计算等高级应用中，我们常常需要从序列的不同位置同时开始生成随机数，这就要求我们能够高效地“跳跃”到序列的任意位置。这个练习 () 将指导你推导并实现一个高效的“跳跃”（skip-ahead）算法，利用线性同余生成器的代数结构，在对数时间内完成数百万步的跳转，让你领略将理论知识转化为高效算法的魅力。",
            "id": "3179049",
            "problem": "您将为一个线性同余生成器（LCG）实现并验证一个跳步（skip-ahead）操作。一个在整数模 $m$ 上的LCG由递推关系 $x_{n+1} \\equiv a x_n + c \\pmod m$ 定义，其中 $a$、$c$、$m$ 是固定的整数，$m \\geq 2$，且 $x_n \\in \\{0,1,\\dots,m-1\\}$。您的任务是，从LCG的基本定义和标准模算术规则出发，推导、实现并测试一个单次操作即可将状态推进 $t$ 步的过程。\n\n起点（基本原理）：\n- 模算术的定义：对于整数 $u$、$v$ 和 $m \\ge 2$，$u \\equiv v \\pmod m$ 当且仅当 $m$ 整除 $u - v$；加法和乘法与模数兼容。\n- 整数上的有限几何级数恒等式：对于整数 $t \\ge 1$，当 $r \\ne 1$ 时，$\\sum_{k=0}^{t-1} r^k = \\frac{r^t - 1}{r - 1}$。\n- 平方求幂法（Exponentiation by squaring）用 $O(\\log e)$ 次乘法计算 $b^e$。\n- 整数 $q$ 模 $m$ 的乘法逆元存在的充要条件是 $\\gcd(q,m)=1$；它可以通过扩展欧几里得算法计算。\n\n要求：\n1) 从递推关系 $x_{n+1} \\equiv a x_n + c \\pmod m$ 推导出一个关于 $x_n$、$a$、$c$、$t$ 和 $m$ 的 $x_{n+t}$ 的闭式表达式。写出其中出现的有限和，并解释何时除以 $a-1$ 在模 $m$ 意义下是有效的。\n2) 设计一个 $O(\\log t)$ 的跳步算法，该算法无需迭代 $t$ 次即可从 $x_n$ 计算出 $x_{n+t}$，使用：\n   - 平方求幂法计算 $a^t \\bmod m$，以及\n   - 扩展欧几里得算法在需要时计算模乘法逆元。\n   正确处理边界情况 $t=0$。\n3) 通过数值实验进行验证：对于下方的每个测试用例，将跳步结果与基准真相进行验证。当 $t$ 小到计算上可行时，基准真相必须通过直接迭代递推关系 $t$ 次来计算；否则，通过代数一致性检查来计算。整个过程使用纯整数算术。\n\n假设：\n- 对于所有测试用例，假设 $\\gcd(a-1,m)=1$，因此只要出现除以 $a-1$ 的情况，在模 $m$ 意义下都是有效的。\n- 不涉及角度。不涉及物理单位。\n\n测试套件：\n- 测试 1（正常路径，小模数）：$(m, a, c, x_n, t) = (97, 23, 17, 42, 35)$。基准真相：迭代递推关系 $t$ 次。\n- 测试 2（大素数模，仿射情形）：$(m, a, c, x_n, t) = (2147483647, 48271, 12345, 987654321, 50000)$。基准真相：迭代递推关系 $t$ 次。\n- 测试 3（乘法LCG，大 $t$ 值依然可行）：$(m, a, c, x_n, t) = (2147483647, 16807, 0, 1, 80000)$。基准真相：迭代递推关系 $t$ 次。\n- 测试 4（边界情况 $t=0$）：$(m, a, c, x_n, t) = (2147483647, 1103515245, 12345, 67890, 0)$。基准真相：$x_{n+t} = x_n$。\n- 测试 5（边界情况 $t=1$）：$(m, a, c, x_n, t) = (65537, 3, 7, 1234, 1)$。基准真相：应用一次 $x \\mapsto a x + c \\bmod m$。\n- 测试 6（无需朴素迭代的复合性检查）：$(m, a, c, x_n, t_1, t_2) = (1000003, 123457, 891, 222, 1234, 5678)$。验证先应用 $t_1$ 步的跳步操作，再接着应用 $t_2$ 步的跳步操作，其结果与一次性应用 $t_1 + t_2$ 步的跳步操作相等。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个用方括号括起来的布尔值逗号分隔列表（例如，`[True,False,True]`），按顺序对应于测试 $1$ 到 $6$ 的结果。",
            "solution": "问题陈述已经过严格的验证过程，并被确定为有效。这是一个在计算科学领域内表述良好、具有科学依据的问题，其构思清晰、客观。所有必要的数据和约束条件都已提供，并且没有内部矛盾或逻辑缺陷。\n\n**1. $x_{n+t}$ 的闭式表达式推导**\n\n线性同余生成器（LCG）由以下递推关系定义：\n$$x_{k+1} \\equiv a x_k + c \\pmod m$$\n我们的目标是找到一个用 $x_n$、$a$、$c$、$t$ 和 $m$ 表示 $x_{n+t}$ 的表达式。我们可以通过展开递推关系来推导：\n$x_{n+1} \\equiv a x_n + c \\pmod m$\n$x_{n+2} \\equiv a x_{n+1} + c \\equiv a(a x_n + c) + c \\equiv a^2 x_n + ac + c \\pmod m$\n$x_{n+3} \\equiv a x_{n+2} + c \\equiv a(a^2 x_n + ac + c) + c \\equiv a^3 x_n + a^2 c + ac + c \\pmod m$\n\n这提示了一般形式，该形式可以通过对 $t$ 进行数学归纳法来正式证明：\n$$x_{n+t} \\equiv a^t x_n + c \\sum_{k=0}^{t-1} a^k \\pmod m$$\n求和项是一个有限几何级数。对于任何整数 $r \\ne 1$，该级数的恒等式为 $\\sum_{k=0}^{t-1} r^k = \\frac{r^t - 1}{r - 1}$。将此应用于我们的表达式，令 $r=a$，我们得到：\n$$\\sum_{k=0}^{t-1} a^k = \\frac{a^t - 1}{a - 1}$$\n这个恒等式在 $a \\ne 1$ 的条件下成立。在模算术中，当且仅当整数 $q$ 与模数 $m$ 互质时，才允许除以 $q$。在这种情况下，除以 $q$ 等价于乘以其模乘法逆元 $q^{-1} \\pmod m$，即一个整数 $q_{\\text{inv}}$ 使得 $q \\cdot q_{\\text{inv}} \\equiv 1 \\pmod m$。\n\n问题陈述中给出了假设 $\\gcd(a-1, m) = 1$。这保证了 $(a-1)$ 模 $m$ 的模乘法逆元存在且唯一。设此逆元为 $(a-1)^{-1}$。因此，该几何级数和可以在模 $m$ 意义下计算为：\n$$\\sum_{k=0}^{t-1} a^k \\equiv (a^t - 1)(a-1)^{-1} \\pmod m$$\n将此代入 $x_{n+t}$ 的表达式中，我们得到闭式解：\n$$x_{n+t} \\equiv a^t x_n + c \\left( (a^t - 1)(a-1)^{-1} \\right) \\pmod m$$\n此表达式使我们能够直接从 $x_n$ 计算 $x_{n+t}$，而无需执行 $t$ 次单独的迭代。\n\n**2. $O(\\log t)$ 跳步算法的设计**\n\n$x_{n+t}$ 的闭式表达式有助于设计一个高效的算法。计算过程可以分解为几个步骤，其复杂度不与 $t$ 呈线性关系。\n\n首先，我们处理边界情况 $t=0$。公式正确地得出 $x_{n+0} \\equiv a^0 x_n + c(a^0-1)(a-1)^{-1} \\equiv 1 \\cdot x_n + c(1-1)(a-1)^{-1} \\equiv x_n \\pmod m$。因此，对于 $t=0$，算法只需返回 $x_n$。\n\n对于 $t  0$，算法按以下步骤进行：\n1.  **计算 $A \\equiv a^t \\pmod m$**：这是一个模幂运算。可以使用平方求幂法（也称为二进制幂）高效地执行，其时间复杂度为 $O(\\log_2 t)$。\n2.  **计算 $I \\equiv (a-1)^{-1} \\pmod m$**：这是 $(a-1)$ 关于模数 $m$ 的模乘法逆元。它使用扩展欧几里得算法计算，该算法找到整数 $i$ 和 $j$ 使得 $(a-1)i + mj = \\gcd(a-1, m)$。由于我们已知 $\\gcd(a-1, m) = 1$，我们有 $(a-1)i + mj = 1$，这意味着 $(a-1)i \\equiv 1 \\pmod m$。因此，逆元 $I$ 是 $i \\pmod m$。此计算的时间复杂度为 $O(\\log m)$。\n3.  **组合最终结果**：使用预先计算的值 $A$ 和 $I$，我们使用推导出的公式计算 $x_{n+t}$。所有算术运算都在模 $m$ 下进行：\n    - 计算求和部分：$S \\equiv c \\cdot (A - 1) \\cdot I \\pmod m$。\n    - 计算初始状态部分：$X \\equiv A \\cdot x_n \\pmod m$。\n    - 最终状态是：$x_{n+t} \\equiv (X + S) \\pmod m$。\n    这些步骤中的每一步都涉及常数次模乘法和模加法。\n\n该算法的总时间复杂度由模幂运算和模逆元步骤主导，总体复杂度为 $O(\\log t + \\log m)$。这比复杂度为 $O(t)$ 的朴素迭代方法有了显著的改进。\n\n**3. 通过数值实验进行验证**\n\n跳步算法的正确性通过一组测试用例进行验证。\n- 对于步数 $t$ 在计算上可行的测试（测试1、2、3、5），通过实现一个简单的迭代函数来建立基准真相，该函数精确地应用LCG递推关系 $x_{k+1} \\equiv (ax_k + c) \\pmod m$ 共 $t$ 次。然后将跳步算法的输出与此基准真相进行比较。\n- 对于边界情况 $t=0$（测试4），基准真相根据定义就是 $x_n$。检查算法的输出是否与此值相等。\n- 对于复合性检查（测试6），我们验证跳步算子（我们称之为 $S(x, k)$，它将状态 $x$ 推进 $k$ 步）的代数性质。该测试确认，执行两次连续的跳步，$S(S(x_n, t_1), t_2)$，与执行一次组合跳步，$S(x_n, t_1 + t_2)$，产生相同的结果。这表明跳步操作构成了一个有效的半群作用，这是其正确性的一个基本要求，与是否能通过迭代计算基准真相无关。\n\n所有计算都使用纯整数算术，并在每一步都进行取模操作，以防止溢出并保持正确性，因为Python的任意精度整数支持所涉及的大数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are needed for this problem.\n\ndef solve():\n    \"\"\"\n    Implements and verifies a skip-ahead operation for a linear congruential\n    generator (LCG).\n    \"\"\"\n\n    def lcg_iterate(m: int, a: int, c: int, x_n: int, t: int) - int:\n        \"\"\"\n        Computes x_{n+t} by iterating the LCG recurrence t times.\n        Serves as the ground truth for verification.\n        \"\"\"\n        x = x_n\n        for _ in range(t):\n            x = (a * x + c) % m\n        return x\n\n    def lcg_skip_ahead(m: int, a: int, c: int, x_n: int, t: int) - int:\n        \"\"\"\n        Computes x_{n+t} using the O(log t) closed-form formula.\n        x_{n+t} = (a^t * x_n + c * (a^t - 1) * (a - 1)^-1) mod m\n        \"\"\"\n        if t  0:\n            raise ValueError(\"Step count t cannot be negative.\")\n        if t == 0:\n            return x_n\n\n        # The term (a-1) can be negative. The modulo operation works correctly\n        # with Python's integers.\n        a_minus_1 = a - 1\n        \n        # In Python 3.8+, pow(base, -1, mod) computes the modular\n        # multiplicative inverse using the Extended Euclidean Algorithm.\n        # The problem guarantees gcd(a-1, m) == 1.\n        a_minus_1_inv = pow(a_minus_1, -1, m)\n\n        # A = a^t mod m, calculated efficiently with modular exponentiation.\n        A = pow(a, t, m)\n\n        # Sum of geometric series part: c * (a^t - 1) * (a - 1)^-1 mod m\n        # (A - 1) might be negative, but Python's % handles this as desired\n        # for modular arithmetic (i.e., result has same sign as modulus).\n        sum_term = (A - 1) * a_minus_1_inv % m\n        \n        # Combine the terms according to the derived formula\n        term1 = (A * x_n) % m\n        term2 = (c * sum_term) % m\n        \n        result = (term1 + term2) % m\n        return result\n\n    # Test cases extracted from the problem statement\n    test_cases = [\n        # Test 1: Happy path, small modulus\n        {'m': 97, 'a': 23, 'c': 17, 'x_n': 42, 't': 35, 'type': 'iterate'},\n        # Test 2: Large prime modulus, affine case\n        {'m': 2147483647, 'a': 48271, 'c': 12345, 'x_n': 987654321, 't': 50000, 'type': 'iterate'},\n        # Test 3: Multiplicative LCG, large t still feasible\n        {'m': 2147483647, 'a': 16807, 'c': 0, 'x_n': 1, 't': 80000, 'type': 'iterate'},\n        # Test 4: Boundary case t=0\n        {'m': 2147483647, 'a': 1103515245, 'c': 12345, 'x_n': 67890, 't': 0, 'type': 'identity'},\n        # Test 5: Boundary case t=1\n        {'m': 65537, 'a': 3, 'c': 7, 'x_n': 1234, 't': 1, 'type': 'onestep'},\n        # Test 6: Composition check\n        {'m': 1000003, 'a': 123457, 'c': 891, 'x_n': 222, 't1': 1234, 't2': 5678, 'type': 'composition'}\n    ]\n\n    results = []\n    for case in test_cases:\n        m, a, c, x_n = case['m'], case['a'], case['c'], case['x_n']\n        \n        if case['type'] == 'iterate':\n            t = case['t']\n            skip_result = lcg_skip_ahead(m, a, c, x_n, t)\n            iter_result = lcg_iterate(m, a, c, x_n, t)\n            results.append(skip_result == iter_result)\n            \n        elif case['type'] == 'identity':\n            t = case['t']\n            skip_result = lcg_skip_ahead(m, a, c, x_n, t)\n            # Ground truth for t=0 is x_n\n            results.append(skip_result == x_n)\n\n        elif case['type'] == 'onestep':\n            t = case['t']\n            skip_result = lcg_skip_ahead(m, a, c, x_n, t)\n            # Ground truth for t=1 is one application of the recurrence\n            onestep_result = (a * x_n + c) % m\n            results.append(skip_result == onestep_result)\n\n        elif case['type'] == 'composition':\n            t1, t2 = case['t1'], case['t2']\n            # Verify S(S(x, t1), t2) == S(x, t1 + t2)\n            res_t1 = lcg_skip_ahead(m, a, c, x_n, t1)\n            res_t1_t2 = lcg_skip_ahead(m, a, c, res_t1, t2)\n            res_total_t = lcg_skip_ahead(m, a, c, x_n, t1 + t2)\n            results.append(res_t1_t2 == res_total_t)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}