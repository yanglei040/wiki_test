{
    "hands_on_practices": [
        {
            "introduction": "热方程是描述扩散过程（如热量在杆中的传导）的基本模型。在物理上，一个孤立的、边界温度固定的系统，其总能量会随着时间耗散。一个可靠的数值模拟应该能准确地复现这一基本物理定律。\n\n本练习  将指导你如何将一个连续的物理定律（能量衰减）转化为离散的数值检验。通过这个过程，你将亲身体验到数值稳定性条件与物理属性（如能量非增）之间的深刻联系，这是模型验证中的一个核心概念。",
            "id": "3201887",
            "problem": "您将对一维热方程的一个具有物理动机的性质进行数值验证。其根本基础是热方程，这是一个线性的偏微分方程（PDE），表达了热量的守恒和扩散。在空间区间 $[0,1]$ 上带狄利克雷边界条件的一维热方程为\n$$\n\\frac{\\partial u}{\\partial t}(x,t) = \\nu \\frac{\\partial^2 u}{\\partial x^2}(x,t), \\quad x \\in [0,1], \\ t \\ge 0,\n$$\n边界条件为 $u(0,t) = 0$ 和 $u(1,t) = 0$，其中 $\\nu > 0$ 是扩散系数。关于此偏微分方程一个基础且经过充分检验的事实是，其平方 $L^2$ 能量，\n$$\nE(t) = \\int_0^1 u(x,t)^2 \\, dx,\n$$\n在时间上是单调非增的，这反映了物理上的耗散现象。\n\n您的任务是离散化该偏微分方程，并验证离散能量\n$$\nE_n = \\Delta x \\sum_{i=1}^{N-2} (u_i^n)^2,\n$$\n是否在时间步长上单调非增。使用一个包含 $N$ 个点的均匀网格，其中 $\\Delta x = \\frac{1}{N-1}$，以及时间步长 $\\Delta t$。空间导数用二阶中心差分进行近似，并使用前向欧拉法在时间上推进：\n$$\nu_i^{n+1} = u_i^n + \\alpha\\left(u_{i+1}^n - 2u_i^n + u_{i-1}^n\\right), \\quad i=1,\\dots,N-2,\n$$\n其中 $u_0^n = u_{N-1}^n = 0$ 强制施加狄利克雷边界条件，$\\alpha = \\nu \\frac{\\Delta t}{\\Delta x^2}$。离散能量 $E_n$ 应在每个时间步使用内部点 $i=1,\\dots,N-2$ 计算，边界点设为零。\n\n实现一个程序，对于每个提供的测试用例，根据指定的初始条件初始化 $u_i^0$，运行显式格式 $n = 0,1,\\dots,n_{\\text{steps}}$ 次，其中 $n_{\\text{steps}} = \\left\\lfloor \\frac{T_{\\text{end}}}{\\Delta t} \\right\\rfloor$，并检查是否对于所有步长都有 $E_{n+1} \\le E_n$，同时考虑一个小的数值容差 $\\varepsilon = 10^{-12} \\cdot (1 + E_n)$ 来处理浮点舍入误差。程序必须为每个测试用例返回一个布尔值，指示在整个模拟过程中能量是否为单调非增。\n\n空间网格点 $x_i = i \\Delta x$ 的初始条件定义如下：\n- \"sine\": $u_i^0 = \\sin(\\pi x_i)$。\n- \"highfreq\": $u_i^0 = \\sin(m \\pi x_i)$，其中 $m = \\left\\lfloor 0.45\\cdot(N-1) \\right\\rfloor$ 且 $m \\ge 1$。\n- \"zero\": $u_i^0 = 0$。\n\n参数 $\\alpha$ 通过 $\\Delta t = \\alpha \\frac{\\Delta x^2}{\\nu}$ 决定时间步长。\n\n测试套件：\n提供一个程序，评估以下测试用例，每个用例为一个元组 $(N,\\nu,\\alpha,T_{\\text{end}},\\text{initial})$：\n1. $(41, 0.1, 0.4, 0.1, \\text{\"sine\"})$。\n2. $(41, 0.1, 0.5, 0.1, \\text{\"sine\"})$。\n3. $(41, 0.1, 0.6, 0.1, \\text{\"highfreq\"})$。\n4. $(5, 1.0, 0.5, 0.5, \\text{\"sine\"})$。\n5. $(21, 0.5, 0.9, 0.1, \\text{\"zero\"})$。\n\n为覆盖性而设计：\n- 用例1是一个标准的稳定配置，预期会表现出能量衰减。\n- 用例2是一个边界稳定性情况。\n- 用例3使用一个较大的 $\\alpha$ 和一个高频初始条件，这对稳定性构成考验，并可能违反能量单调性。\n- 用例4使用粗网格来检验边界和离散化处理。\n- 用例5具有零初始能量，并检查在可能不稳定的参数下的平凡单调性。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，\"[result1,result2,...]\"），其中每个结果是一个布尔值（\"True\" 或 \"False\"），对应于相应测试用例的单调性检查。不涉及物理单位，答案仅为布尔值。",
            "solution": "该问题要求对一维热方程的有限差分法的能量耗散性质进行数值验证。连续问题由偏微分方程（PDE）给出\n$$\n\\frac{\\partial u}{\\partial t}(x,t) = \\nu \\frac{\\partial^2 u}{\\partial x^2}(x,t)\n$$\n在空间域 $x \\in [0,1]$ 上，具有齐次狄利克雷边界条件 $u(0,t) = u(1,t) = 0$。扩散系数为 $\\nu > 0$。该系统的一个基本性质是总能量，由平方 $L^2$-范数 $E(t) = \\int_0^1 u(x,t)^2 \\, dx$ 定义，是时间的非增函数，即 $\\frac{dE}{dt} \\le 0$。这反映了在边界保持恒定温度的孤立系统中热量耗散的物理原理。\n\n我们的任务是验证一个特定的数值格式是否保留了此性质的离散模拟。空间域 $[0,1]$ 使用一个包含 $N$ 个点的均匀网格进行离散化，$x_i = i \\Delta x$，其中 $i=0, 1, \\dots, N-1$，网格间距为 $\\Delta x = \\frac{1}{N-1}$。在网格点 $x_i$ 和时间步 $n$ 的解表示为 $u_i^n \\approx u(x_i, n\\Delta t)$。\n\n所提供的数值格式是前向时间、中心空间（FTCS）方法。时间导数由前向差分近似，空间二阶导数由二阶中心差分近似：\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} = \\nu \\frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{\\Delta x^2}。\n$$\n整理此方程得到内部网格点（$i=1, \\dots, N-2$）的显式更新规则：\n$$\nu_i^{n+1} = u_i^n + \\alpha \\left(u_{i+1}^n - 2u_i^n + u_{i-1}^n\\right),\n$$\n其中 $\\alpha = \\nu \\frac{\\Delta t}{\\Delta x^2}$ 是无量纲扩散数。通过在所有时间步 $n$ 设置 $u_0^n = 0$ 和 $u_{N-1}^n = 0$ 来施加边界条件。\n\n这种显式格式的一个关键方面是其条件稳定性。冯·诺伊曼稳定性分析表明，该格式是稳定的当且仅当 $\\alpha \\le 0.5$。如果此条件被违反（$\\alpha > 0.5$），数值解的高频分量将在每个时间步被放大，导致指数增长并完全偏离真实解。\n\n离散能量被定义为连续能量积分的一个数值求积：\n$$\nE_n = \\Delta x \\sum_{i=1}^{N-2} (u_i^n)^2。\n$$\n这对应于 $\\int_0^1 u(x,t)^2 dx$ 的梯形法则近似，因为被积函数在边界处为零。我们的任务是检查这个离散能量在模拟的每个时间步是否都是单调非增的，即对于所有的 $n$ 是否有 $E_{n+1} \\le E_n$。由于浮点运算，我们必须使用一个小的容差来检查这个不等式：$E_{n+1} \\le E_n + \\varepsilon$，其中 $\\varepsilon = 10^{-12} (1 + E_n)$。在任何一步未能满足此条件都意味着该测试用例的能量单调性被违反。\n\n对于每个测试用例 $(N,\\nu,\\alpha,T_{\\text{end}},\\text{initial})$，需要实现的算法如下：\n1.  计算离散化参数：$\\Delta x = \\frac{1}{N-1}$，$\\Delta t = \\alpha \\frac{\\Delta x^2}{\\nu}$，以及时间步数 $n_{\\text{steps}} = \\lfloor \\frac{T_{\\text{end}}}{\\Delta t} \\rfloor$。\n2.  根据指定的初始条件（\"sine\", \"highfreq\" 或 \"zero\"）初始化大小为 $N$ 的解向量 $u^0$。边界值 $u_0^0$ 和 $u_{N-1}^0$ 设置为 $0$。\n3.  计算初始能量 $E_0$。\n4.  从 $n = 0$ 迭代到 $n_{\\text{steps}}-1$：\n    a. 使用 FTCS 更新规则为所有内部点计算下一个时间步的解 $u^{n+1}$。边界值保持为零。\n    b. 计算新能量 $E_{n+1}$。\n    c. 检查是否有 $E_{n+1} > E_n + \\varepsilon$。如果满足此条件，则性质被违反。该测试用例的结果为 `False`，并且此用例的模拟可以终止。\n    d. 为下一次比较更新能量：$E_n \\leftarrow E_{n+1}$。\n5.  如果循环完成而没有任何违反，则性质成立，结果为 `True`。\n\n此过程将应用于每个测试用例。\n-   用例1、2和4具有 $\\alpha \\le 0.5$，因此格式是稳定的，预期能量单调性会成立 (`True`)。用例2代表稳定性极限 $\\alpha=0.5$。\n-   用例3具有 $\\alpha = 0.6 > 0.5$，这是不稳定的。\"highfreq\" 初始条件将激发不稳定模式，导致能量增长 (`False`)。\n-   用例5具有 $\\alpha = 0.9 > 0.5$（不稳定），但初始条件恒为零。对于线性格式，零初始数据将产生始终为零的解，假设没有舍入误差。因此，对于所有 $n$，$E_n = 0$，条件 $E_{n+1} \\le E_n$ 被平凡地满足 (`True`)。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(N, nu, alpha, T_end, initial_type):\n    \"\"\"\n    Runs a single simulation of the 1D heat equation and checks for energy monotonicity.\n\n    Args:\n        N (int): Number of grid points.\n        nu (float): Diffusion coefficient.\n        alpha (float): Dimensionless diffusion number.\n        T_end (float): Total simulation time.\n        initial_type (str): Type of initial condition (\"sine\", \"highfreq\", \"zero\").\n\n    Returns:\n        bool: True if discrete energy is monotonically non-increasing, False otherwise.\n    \"\"\"\n    # Step 1: Initialize parameters and grid\n    dx = 1.0 / (N - 1)\n    # Avoid division by zero if nu is zero, though problem states nu > 0\n    if nu == 0:\n        # If nu=0, dt is technically infinite unless alpha=0.\n        # This case is not in the test suite but is a safe guard.\n        if alpha == 0:\n            dt = 0  # No time evolution\n        else:\n            return False # Ill-defined problem\n    else:\n        dt = alpha * dx**2 / nu\n\n    if dt == 0:\n        n_steps = 0\n    else:\n        n_steps = int(T_end / dt)\n\n    x = np.linspace(0.0, 1.0, N)\n    u = np.zeros(N, dtype=np.float64)\n\n    # Step 2: Set initial condition\n    if initial_type == \"sine\":\n        u = np.sin(np.pi * x)\n    elif initial_type == \"highfreq\":\n        m = int(0.45 * (N - 1))\n        # Per problem spec, ensure m >= 1\n        if m < 1:\n            m = 1\n        u = np.sin(m * np.pi * x)\n    elif initial_type == \"zero\":\n        # u is already initialized to zeros\n        pass\n    \n    # Enforce boundary conditions, though initializers above already satisfy them\n    u[0] = 0.0\n    u[-1] = 0.0\n\n    # Step 3: Calculate initial energy\n    E_prev = dx * np.sum(u[1:-1]**2)\n    is_monotonic = True\n\n    # Step 4: Time-stepping loop\n    for _ in range(n_steps):\n        # Create a copy to store the new state\n        u_new = u.copy()\n        \n        # Apply FTCS update rule for interior points\n        u_new[1:-1] = u[1:-1] + alpha * (u[2:] - 2 * u[1:-1] + u[:-2])\n        \n        # Update u for the next iteration\n        u = u_new\n\n        # Calculate new energy\n        E_curr = dx * np.sum(u[1:-1]**2)\n\n        # Check for monotonicity violation with tolerance\n        epsilon = 1e-12 * (1.0 + E_prev)\n        if E_curr > E_prev + epsilon:\n            is_monotonic = False\n            break\n\n        # Update previous energy\n        E_prev = E_curr\n\n    return is_monotonic\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (41, 0.1, 0.4, 0.1, \"sine\"),\n        (41, 0.1, 0.5, 0.1, \"sine\"),\n        (41, 0.1, 0.6, 0.1, \"highfreq\"),\n        (5, 1.0, 0.5, 0.5, \"sine\"),\n        (21, 0.5, 0.9, 0.1, \"zero\"),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation(*case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在验证了模型的核心物理属性后，我们需要将注意力转向边界——这是计算模型中常见的误差来源。不同的物理情景需要不同的边界条件，例如一个孤立系统（反射边界）与一个周期性系统（周期边界）的行为截然不同。\n\n这个练习  旨在强调正确实现边界条件的重要性。你将通过实验验证不同的边界条件（反射与周期性）如何影响质量守恒和对称性等物理不变量，从而学会设计针对模型实现细节的验证测试。",
            "id": "3201854",
            "problem": "您的任务是通过对应力测试边界条件并检查关键物理不变量是否守恒，来对一维扩散模型进行验证与确认练习。实现一个程序，该程序模拟具有两种边界条件类型的无量纲一维扩散，并在一小组测试套件上评估不变量的守恒性。本问题中的所有量均为无量纲（无单位）。\n\n扩散过程由偏微分方程（PDE）$$\\frac{\\partial u}{\\partial t} = D \\frac{\\partial^2 u}{\\partial x^2},$$描述，其中 $u$ 是场，$t$ 是时间，$x$ 是空间，$D$ 是扩散系数。在长度为 $L$ 的域上，对包含 $N$ 个点的均匀网格，使用有限差分法（FDM），时间离散化采用前向欧拉法，空间拉普拉斯算子采用中心二阶差分。设时间步长为 $\\Delta t$，网格间距为 $\\Delta x$。定义 $$\\alpha = \\frac{D \\Delta t}{\\Delta x^2}.$$ 采用两种边界条件类型：\n- 反射（Neumann，零通量）边界条件：在边界处 $\\frac{\\partial u}{\\partial x} = 0$。\n- 周期性边界条件：$u(x + L) = u(x)$。\n\n您的实现必须：\n1. 通过重复应用显式更新，将场从初始条件 $u^0$ 演化到 $u^n$，总时间为预设的 $T$。选择步数 $n$ 为 $n = \\lceil T / \\Delta t \\rceil$，并调整 $\\Delta t$ 以精确满足 $n \\Delta t = T$。对于反射边界，使用 $\\Delta x = L/(N-1)$；对于周期性边界，使用 $\\Delta x = L/N$。\n2. 对于反射边界，使用虚点策略来施加零通量边界条件，该策略在端点处产生的更新与零梯度一致。\n3. 对于周期性边界，实施环绕索引。\n\n定义以下待检查的不变量：\n- 质量守恒（离散）：量 $\\sum_{j} u_j \\Delta x$ 不随时间改变。\n- 对称性保持：如果初始场关于中心对称（回文），则对于线性扩散，对称性将被保持。\n- 对于周期性边界条件和波数为 $k$ 的余弦初始条件，模式振幅必须根据周期性离散拉普拉斯算子的离散特征值进行衰减。如果每步的放大因子为 $$g_k = 1 - 4 \\alpha \\sin^2\\left(\\frac{\\pi k}{N}\\right),$$ 那么在 $n$ 步之后，振幅比必须为 $g_k^n$。\n\n测试套件：\n- 案例1（恒定场，跨边界比较）：\n  - 参数：$L = 1.0$，$D = 0.1$，$N = 64$，$T = 0.1$，初始化所有 $j$ 的 $u_j^0 = 3.0$。\n  - 时间步长选择：对两种边界类型均设置 $\\alpha = 0.45$；即，选择 $\\Delta t$ 使得在每种边界类型的 $\\Delta x$ 下，$\\alpha = 0.45$。使用各自的 $\\Delta x$ 和 $\\Delta t$ 独立运行反射和周期性边界条件的模拟。\n  - 输出三个布尔值：\n    - 案例1.1：在反射边界下质量守恒。\n    - 案例1.2：在周期性边界下质量守恒。\n    - 案例1.3：从恒定场开始，反射和周期性运行产生的最终数组在容差范围内相等。\n\n- 案例2（周期性余弦模式，理论振幅衰减）：\n  - 参数：$L = 1.0$，$D = 0.2$，$N = 128$，$T = 0.05$，波数 $k = 1$，初始化 $u_j^0 = \\cos\\left( \\frac{2\\pi k j}{N} \\right)$。\n  - 时间步长选择：设置 $\\alpha = 0.10$（对于周期性边界，$\\Delta x = L/N$），因此 $\\Delta t$ 必须满足 $\\alpha = D \\Delta t / \\Delta x^2$。\n  - 输出三个布尔值：\n    - 案例2.1：在周期性边界下质量守恒。\n    - 案例2.2：测量的振幅比在容差范围内等于 $g_k^n$。\n    - 案例2.3：在相同的初始条件和 $T$ 下，使用其自身的 $\\Delta x$ 和对应于 $\\alpha = 0.10$ 的 $\\Delta t$ 运行时，在反射边界下质量守恒。\n\n- 案例3（回文对称形状，在两种边界下均保持对称性）：\n  - 参数：$L = 1.0$，$D = 0.1$，$N = 129$，$T = 0.05$，将 $u^0$ 初始化为关于中心对称的回文三角形凸起（例如，构造左半部分并将其镜像到右半部分，以使 $u_j^0 = u_{N-1-j}^0$ 精确成立）。\n  - 时间步长选择：在两种边界类型下均设置 $\\alpha = 0.45$。\n  - 输出三个布尔值：\n    - 案例3.1：在反射边界下质量守恒。\n    - 案例3.2：在反射边界下对称性（回文属性）在容差范围内保持。\n    - 案例3.3：在周期性边界下对称性在容差范围内保持。\n\n- 案例4（Courant 极限下的边缘稳定性，最小网格）：\n  - 参数：$L = 1.0$，$D = 0.1$，$N = 3$，初始化 $u^0 = [1.0, 0.0, 0.0]$，选择 $\\Delta t = \\Delta x^2/(2D)$ 使 $\\alpha = 0.5$，并设置 $T = 5 \\Delta t$。\n  - 边界：周期性。\n  - 输出三个布尔值：\n    - 案例4.1：质量守恒。\n    - 案例4.2：在整个模拟过程中，所有值保持有限（没有非数值或无穷大）。\n    - 案例4.3：解保持在初始范围 $[\\min(u^0), \\max(u^0)]$ 内。\n\n容差策略：\n- 比较浮点数量（例如质量和对称性）时，使用绝对容差 $\\varepsilon_{\\text{abs}} = 10^{-10}$ 和相对容差 $\\varepsilon_{\\text{rel}} = 10^{-9}$。\n- 对于振幅比比较，使用 $\\varepsilon_{\\text{rel}} = 10^{-8}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[result1,result2,...]”）。按指定顺序（案例1.1、案例1.2、案例1.3、案例2.1、案例2.2、案例2.3、案例3.1、案例3.2、案例3.3、案例4.1、案例4.2、案例4.3）列出四个案例的布尔值。",
            "solution": "问题陈述已经过分析，并被确定为**有效**。这是一个在计算科学领域内适定且科学上合理的问题，专注于数值模型的验证与确认。\n\n核心任务是使用有限差分法（FDM）模拟一维扩散方程，\n$$ \\frac{\\partial u}{\\partial t} = D \\frac{\\partial^2 u}{\\partial x^2} $$\n我们在均匀网格上采用前向时间、中心空间（FTCS）格式。\n\n令 $u_j^n$ 表示在网格点 $x_j = j \\Delta x$ 和时间 $t_n = n \\Delta t$ 处场 $u(x, t)$ 的数值近似。FTCS 离散化为：\n$$ \\frac{u_j^{n+1} - u_j^n}{\\Delta t} = D \\frac{u_{j+1}^n - 2u_j^n + u_{j-1}^n}{\\Delta x^2} $$\n重新整理以得到时间推进的更新规则：\n$$ u_j^{n+1} = u_j^n + \\frac{D \\Delta t}{\\Delta x^2} (u_{j+1}^n - 2u_j^n + u_{j-1}^n) $$\n引入无量纲稳定性参数 $\\alpha = \\frac{D \\Delta t}{\\Delta x^2}$，更新规则变为：\n$$ u_j^{n+1} = u_j^n + \\alpha (u_{j+1}^n - 2u_j^n + u_{j-1}^n) $$\n此方程适用于网格的内部点。边界点需要根据指定的边界条件进行特殊处理。网格间距 $\\Delta x$ 取决于边界条件类型以及长度为 $L$ 的域上的网格点数 $N$：\n- 对于反射边界：$\\Delta x = L/(N-1)$\n- 对于周期性边界：$\\Delta x = L/N$\n\n模拟运行总时间为 $T$。时间步长 $\\Delta t$ 最初由期望的 $\\alpha$ 值确定，$\\Delta t_{\\text{initial}} = \\alpha \\Delta x^2 / D$。然后步数为 $n = \\lceil T / \\Delta t_{\\text{initial}} \\rceil$。为确保模拟在 $T$ 时刻精确结束，时间步长被调整为 $\\Delta t = T/n$。这可能会轻微改变 $\\alpha$ 的值，必须为模拟循环重新计算该值。\n\n**边界条件实现**\n\n1.  **反射（Neumann）边界条件**：此条件 $\\frac{\\partial u}{\\partial x} = 0$ 意味着边界上没有通量。我们使用虚点来实现这一点。\n    - 在左边界（$x=0$，索引 $j=0$）：引入一个虚点 $u_{-1}^n$。梯度的中心差分给出 $\\frac{u_1^n - u_{-1}^n}{2 \\Delta x} = 0$，这意味着 $u_{-1}^n = u_1^n$。将此代入 $j=0$ 的通用更新规则，得到：\n      $$ u_0^{n+1} = u_0^n + \\alpha(u_1^n - 2u_0^n + u_1^n) = u_0^n + 2\\alpha(u_1^n - u_0^n) $$\n    - 在右边界（$x=L$，索引 $j=N-1$）：使用一个虚点 $u_{N}^n$。条件 $\\frac{u_{N}^n - u_{N-2}^n}{2 \\Delta x} = 0$ 意味着 $u_{N}^n = u_{N-2}^n$。将其代入 $j=N-1$ 的通用更新规则：\n      $$ u_{N-1}^{n+1} = u_{N-1}^n + \\alpha(u_{N}^n - 2u_{N-1}^n + u_{N-2}^n) = u_{N-1}^n + 2\\alpha(u_{N-2}^n - u_{N-1}^n) $$\n\n2.  **周期性边界条件**：此条件 $u(x+L) = u(x)$ 意味着网格是环绕的。点 $u_0$ 的邻居是 $u_1$ 和 $u_{N-1}$，点 $u_{N-1}$ 的邻居是 $u_0$ 和 $u_{N-2}$。通过对索引使用模运算（例如，$(j+1) \\pmod N$ 和 $(j-1) \\pmod N$），通用更新规则适用于所有点 $j \\in \\{0, 1, \\dots, N-1\\}$。这可以使用 `numpy.roll` 高效实现。\n\n**验证与确认检查**\n\n使用一个辅助函数 `is_close(a, b, rtol, atol)` 来比较浮点值，实现为 `abs(a - b) <= (atol + rtol * abs(b))`。\n\n- **质量守恒**：总离散质量为 $M = \\Delta x \\sum_{j=0}^{N-1} u_j$。我们使用 $\\varepsilon_{\\text{rel}} = 10^{-9}$ 和 $\\varepsilon_{\\text{abs}} = 10^{-10}$ 检查初始质量 $M_0$ 和最终质量 $M_f$ 是否接近。\n\n- **对称性保持**：对于回文初始条件（$u_j^0 = u_{N-1-j}^0$），最终状态 $u^n$ 也应该是回文的。通过比较最终数组 `u_final` 与其反转版本 `u_final[::-1]` 来检查这一点。\n\n- **振幅衰减**：对于周期性余弦初始条件 $u_j^0 = \\cos\\left( \\frac{2\\pi k j}{N} \\right)$，FTCS 格式的理论放大因子为 $g_k = 1 - 4 \\alpha \\sin^2\\left(\\frac{\\pi k}{N}\\right)$。在 $n$ 步之后，最终振幅应为初始振幅的 $g_k^n$ 倍。测量的最终振幅取为 $u_0^n$。初始振幅为 $u_0^0 = 1$。该检查使用相对容差 $\\varepsilon_{\\text{rel}} = 10^{-8}$ 比较测量比率 $u_0^n/u_0^0 = u_0^n$ 与理论比率 $g_k^n$。\n\n- **稳定性与范围**：对于 $\\alpha=0.5$（即稳定性极限）的情况，我们验证解保持有限（没有 `NaN` 或 `inf` 值）并且遵循极值原理，即 $u^n$ 中的值保持在初始值范围 $[\\min(u^0), \\max(u^0)]$ 之内。\n\n提供的 Python 代码在一个 `simulate` 函数中实现了这些原理，该函数处理两种边界条件的核心 FDM 逻辑。`solve` 函数按规定组织四个测试案例，计算十二个布尔结果，并以所需格式打印它们。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Performs a verification and validation exercise on a 1D diffusion model.\n    \"\"\"\n    \n    # Tolerance policy\n    ATOL = 1e-10\n    RTOL_MASS_SYM = 1e-9\n    RTOL_AMP = 1e-8\n\n    def simulate(L, D, N, T, u0_in, bc_type, alpha):\n        \"\"\"\n        Simulates the 1D diffusion equation using the FTCS scheme.\n        \"\"\"\n        u0 = u0_in.copy()\n        \n        if bc_type == 'reflective':\n            dx = L / (N - 1)\n        elif bc_type == 'periodic':\n            dx = L / N\n        else:\n            raise ValueError(\"Invalid boundary condition type.\")\n\n        # Determine dt and number of steps\n        if D > 0 and dx > 0:\n            dt_initial = alpha * dx**2 / D\n            if T > 0 and dt_initial > 0:\n                n_steps = int(np.ceil(T / dt_initial))\n            else:\n                n_steps = 1\n            if n_steps == 0:\n                n_steps = 1 # Ensure at least one step if T is very small\n        else: # Handle D=0 or dx=0 cases\n            dt_initial = 0\n            n_steps = 1\n        \n        dt = T / n_steps\n        \n        # Recalculate alpha with the adjusted dt\n        alpha_actual = D * dt / dx**2 if dx > 0 else 0.0\n\n        u = u0.copy()\n        for _ in range(n_steps):\n            u_new = u.copy()\n            if bc_type == 'reflective':\n                # Interior points\n                u_new[1:-1] = u[1:-1] + alpha_actual * (u[2:] - 2 * u[1:-1] + u[:-2])\n                # Boundary points\n                u_new[0] = u[0] + 2 * alpha_actual * (u[1] - u[0])\n                u_new[-1] = u[-1] + 2 * alpha_actual * (u[-2] - u[-1])\n            elif bc_type == 'periodic':\n                u_jp1 = np.roll(u, -1)\n                u_jm1 = np.roll(u, 1)\n                u_new = u + alpha_actual * (u_jp1 - 2 * u + u_jm1)\n            u = u_new\n            \n        return u, dx, dt, n_steps, alpha_actual\n\n    results = []\n\n    # --- Case 1 ---\n    L1, D1, N1, T1, alpha1 = 1.0, 0.1, 64, 0.1, 0.45\n    u0_1 = np.full(N1, 3.0)\n\n    # 1.1: Mass conservation (reflective)\n    u_ref_1, dx_ref_1, _, _, _ = simulate(L1, D1, N1, T1, u0_1, 'reflective', alpha1)\n    mass0_ref_1 = np.sum(u0_1) * dx_ref_1\n    massf_ref_1 = np.sum(u_ref_1) * dx_ref_1\n    results.append(np.isclose(mass0_ref_1, massf_ref_1, rtol=RTOL_MASS_SYM, atol=ATOL))\n\n    # 1.2: Mass conservation (periodic)\n    u_per_1, dx_per_1, _, _, _ = simulate(L1, D1, N1, T1, u0_1, 'periodic', alpha1)\n    mass0_per_1 = np.sum(u0_1) * dx_per_1\n    massf_per_1 = np.sum(u_per_1) * dx_per_1\n    results.append(np.isclose(mass0_per_1, massf_per_1, rtol=RTOL_MASS_SYM, atol=ATOL))\n\n    # 1.3: Final arrays equality\n    results.append(np.allclose(u_ref_1, u_per_1, rtol=RTOL_MASS_SYM, atol=ATOL))\n\n    # --- Case 2 ---\n    L2, D2, N2, T2, k2, alpha2 = 1.0, 0.2, 128, 0.05, 1, 0.10\n    j2 = np.arange(N2)\n    u0_2 = np.cos(2 * np.pi * k2 * j2 / N2)\n\n    # Periodic run for 2.1 and 2.2\n    u_per_2, dx_per_2, _, n_per_2, alpha_p_act_2 = simulate(L2, D2, N2, T2, u0_2, 'periodic', alpha2)\n\n    # 2.1: Mass conservation (periodic)\n    mass0_per_2 = np.sum(u0_2) * dx_per_2\n    massf_per_2 = np.sum(u_per_2) * dx_per_2\n    results.append(np.isclose(mass0_per_2, massf_per_2, rtol=RTOL_MASS_SYM, atol=ATOL))\n\n    # 2.2: Amplitude decay\n    g_k = 1 - 4 * alpha_p_act_2 * np.sin(np.pi * k2 / N2)**2\n    theo_ratio = g_k**n_per_2\n    meas_ratio = u_per_2[0] / u0_2[0]\n    results.append(np.isclose(meas_ratio, theo_ratio, rtol=RTOL_AMP, atol=ATOL))\n\n    # 2.3: Mass conservation (reflective)\n    u_ref_2, dx_ref_2, _, _, _ = simulate(L2, D2, N2, T2, u0_2, 'reflective', alpha2)\n    mass0_ref_2 = np.sum(u0_2) * dx_ref_2\n    massf_ref_2 = np.sum(u_ref_2) * dx_ref_2\n    results.append(np.isclose(mass0_ref_2, massf_ref_2, rtol=RTOL_MASS_SYM, atol=ATOL))\n\n    # --- Case 3 ---\n    L3, D3, N3, T3, alpha3 = 1.0, 0.1, 129, 0.05, 0.45\n    mid3 = (N3 - 1) / 2\n    u0_3 = 1.0 - np.abs(np.arange(N3) - mid3) / mid3\n\n    # 3.1: Mass conservation (reflective)\n    u_ref_3, dx_ref_3, _, _, _ = simulate(L3, D3, N3, T3, u0_3, 'reflective', alpha3)\n    mass0_ref_3 = np.sum(u0_3) * dx_ref_3\n    massf_ref_3 = np.sum(u_ref_3) * dx_ref_3\n    results.append(np.isclose(mass0_ref_3, massf_ref_3, rtol=RTOL_MASS_SYM, atol=ATOL))\n\n    # 3.2: Symmetry preservation (reflective)\n    results.append(np.allclose(u_ref_3, u_ref_3[::-1], rtol=RTOL_MASS_SYM, atol=ATOL))\n    \n    # 3.3: Symmetry preservation (periodic)\n    u_per_3, _, _, _, _ = simulate(L3, D3, N3, T3, u0_3, 'periodic', alpha3)\n    results.append(np.allclose(u_per_3, u_per_3[::-1], rtol=RTOL_MASS_SYM, atol=ATOL))\n\n    # --- Case 4 ---\n    L4, D4, N4 = 1.0, 0.1, 3\n    u0_4 = np.array([1.0, 0.0, 0.0])\n    alpha4 = 0.5\n    \n    # Override T calculation for this case\n    dx4 = L4 / N4\n    dt4 = alpha4 * dx4**2 / D4\n    T4 = 5 * dt4\n\n    # Run simulation with periodic BC\n    u_final_4, dx_final_4, _, n_steps_4, _ = simulate(L4, D4, N4, T4, u0_4, 'periodic', alpha4)\n    \n    # 4.1: Mass conservation\n    mass0_4 = np.sum(u0_4) * dx_final_4\n    massf_4 = np.sum(u_final_4) * dx_final_4\n    results.append(np.isclose(mass0_4, massf_4, rtol=RTOL_MASS_SYM, atol=ATOL))\n\n    # 4.2: Finiteness\n    results.append(np.all(np.isfinite(u_final_4)))\n    \n    # 4.3: Range preservation (Maximum Principle)\n    min_u0 = np.min(u0_4)\n    max_u0 = np.max(u0_4)\n    range_ok = np.all((u_final_4 >= min_u0 - ATOL) & (u_final_4 <= max_u0 + ATOL))\n    results.append(range_ok)\n\n    # Format output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "让我们从线性偏微分方程进入非线性世界，以无粘性伯格斯方程为例，这是一个能够产生冲击波的经典模型。对于某些特定问题，例如黎曼问题，我们能够推导出其精确的解析解。\n\n本练习  将介绍一种最强大的验证技术：将数值解与已知的精确解进行比较（即“精确解方法”）。你将实现一个更高级的数值格式（戈杜诺夫通量的有限体积法），并学习如何量化数值解与“标准答案”之间的误差，从而验证你的代码是否能够正确捕捉像冲击波这样的复杂非线性现象。",
            "id": "3201943",
            "problem": "您需要构建一个程序，通过将计算得到的数值解与阶跃初始数据的精确黎曼解进行比较，来验证一阶有限体积格式对于一维无粘伯格斯方程（作为一种非线性守恒律）的激波捕捉能力。您的设计必须从基本定义出发：守恒形式、通量计算、Rankine–Hugoniot 跳跃条件以及熵可容的自相似解。除了这些原则之外，不要使用任何预先推导的公式。实现以下内容，并保持所有量纲为一。\n\n核心模型与验证目标：\n- 考虑守恒形式下的一维无粘伯格斯方程\n  $$u_t + \\left(f(u)\\right)_x = 0,$$\n  其中通量由下式给出 $$f(u) = \\tfrac{1}{2} u^2.$$\n- 使用在点 $$x_0 \\in \\mathbb{R}$$ 处具有单个间断的黎曼初始条件：\n  $$u(x,0) = \\begin{cases}\n  u_L, & x < x_0,\\\\\n  u_R, & x > x_0.\n  \\end{cases}$$\n- 为进行验证，将数值解与根据守恒律、激波的 Rankine–Hugoniot 条件以及适当时根据自相似稀疏解构造的黎曼问题的精确熵解进行比较。\n- 为进行验证，在指定的最终时间 $$T > 0$$ 使用离散 $$L^1$$ 误差来量化差异，并且对于激波情况，还需数值上估计激波位置并与精确激波位置进行比较。\n\n需实现的数值方法：\n- 在域 $$[x_{\\min}, x_{\\max}]$$ 上的均匀网格上使用具有 $$N$$ 个单元的一阶显式有限体积法。\n- 令 $$\\Delta x = (x_{\\max} - x_{\\min}) / N$$，并使用满足 Courant–Friedrichs–Lewy (CFL) 条件的时间步长 $$\\Delta t$$，通过显式前向欧拉法在时间上推进：\n  $$\\Delta t \\le \\mathrm{CFL} \\cdot \\frac{\\Delta x}{\\max_i |u_i|},$$\n  其中 $$u_i$$ 是单元平均值。请根据下文测试套件中指定的 Courant–Friedrichs–Lewy (CFL) 数进行选择。\n- 在每个单元界面处使用针对无粘伯格斯方程的 Godunov 数值通量，以确保选择正确的熵解。通过在每个时间步将边界单元的值复制到虚拟状态中，实现透射（出流）边界条件。\n- 在时间 $$T$$ 停止，裁剪最后一个时间步，以确保最终时间恰好为 $$T$$。\n\n精确解与误差度量：\n- 使用以下方法构造时间 $$t = T$$ 时的精确黎曼解：\n  - 对于 $$u_L > u_R$$ 的激波，使用 Rankine–Hugoniot 条件，其中精确激波位于 $$x_s(T)$$。\n  - 对于 $$u_L < u_R$$，使用基于特征线的自相似稀疏扇。\n- 计算离散 $$L^1$$ 误差：\n  $$E_{L^1} = \\sum_{i=1}^{N} \\left| u_i^{\\text{num}}(T) - u_i^{\\text{exact}}(T) \\right| \\Delta x.$$\n- 对于激波情况，通过定位数值解穿过中点状态 $$\\tfrac{u_L + u_R}{2}$$ 的位置，并在相邻单元之间进行线性插值，来估计数值激波位置 $$\\hat{x}_s(T)$$；如果未检测到符号变化，则回退到使用最大离散梯度幅值的位置。报告绝对位置误差 $$| \\hat{x}_s(T) - x_s(T) |.$$\n\n网格、域和时间：\n- 使用空间域 $$[x_{\\min}, x_{\\max}] = [-1, 1]$$，间断位置 $$x_0 = 0$$，以及最终时间 $$T = 0.2$$。\n- 除非测试用例明确说明，否则使用 $$\\mathrm{CFL} = 0.9$$。\n\n测试套件：\n实现以下五个测试用例。每个用例定义了输入参数，并指定了该用例需要报告的单个标量结果。所有计算均为无量纲。\n\n1. 激波，中等分辨率下的误差（正常路径）：\n   - 参数：$$u_L = 2.0, \\; u_R = 0.0, \\; x_0 = 0.0, \\; N = 200, \\; T = 0.2, \\; \\mathrm{CFL} = 0.9.$$\n   - 输出：$$L^1$$ 误差 $$E_{L^1}$$，以浮点数形式表示。\n\n2. 激波，网格加密下的收敛性观察：\n   - 参数：与用例1相同，但分别使用 $$N = 200$$ 和 $$N = 400$$ 进行计算。\n   - 输出：一个整数指示符，如果 $$N = 400$$ 时的 $$L^1$$ 误差严格小于 $$N = 200$$ 时的误差，则为 $$1$$，否则为 $$0$$。\n\n3. 稀疏波，中等分辨率下的误差：\n   - 参数：$$u_L = 0.0, \\; u_R = 2.0, \\; x_0 = 0.0, \\; N = 400, \\; T = 0.2, \\; \\mathrm{CFL} = 0.9.$$\n   - 输出：$$L^1$$ 误差 $$E_{L^1}$$，以浮点数形式表示。\n\n4. 恒定状态保持（边界情况）：\n   - 参数：$$u_L = 1.0, \\; u_R = 1.0, \\; x_0 = 0.0, \\; N = 200, \\; T = 0.2, \\; \\mathrm{CFL} = 0.9.$$\n   - 输出：在时间 $$T$$，数值解与 $$1.0$$ 的最大绝对偏差，以浮点数形式报告。\n\n5. 左行激波，激波位置精度：\n   - 参数：$$u_L = 0.0, \\; u_R = -2.0, \\; x_0 = 0.0, \\; N = 300, \\; T = 0.2, \\; \\mathrm{CFL} = 0.9.$$\n   - 输出：激波位置的绝对误差 $$| \\hat{x}_s(T) - x_s(T) |$$，以浮点数形式报告。\n\n最终输出格式要求：\n- 您的程序必须生成单行输出，其中包含一个 Python 风格的列表，该列表有五个条目，按顺序对应五个测试用例。\n- 浮点数必须四舍五入到六位小数，并以定点表示法打印，不使用科学记数法。\n- 用例2中的收敛指示符必须打印为整数 $$0$$ 或 $$1$$。\n- 示例格式（所示值为占位符）：\"[0.012345,1,0.006789,0.000000,0.004321]\"。",
            "solution": "用户指定了一个问题，要求将一维无粘伯格斯方程的一阶有限体积格式与其精确黎曼解进行验证。任务包括实现数值格式，为激波和稀疏波两种情况构造精确解，并量化误差。\n\n### **问题验证**\n\n**步骤1：提取已知条件**\n\n*   **控制方程**：守恒形式的一维无粘伯格斯方程为 $u_t + (f(u))_x = 0$，通量为 $f(u) = \\frac{1}{2} u^2$。\n*   **初始条件**：在 $x_0$ 处有单个间断的黎曼问题：对于 $x < x_0$，$u(x,0) = u_L$；对于 $x > x_0$，$u(x,0) = u_R$。\n*   **数值离散**：在域 $[x_{\\min}, x_{\\max}] = [-1, 1]$ 上，采用具有 $N$ 个单元的均匀网格上的一阶显式有限体积法。单元宽度为 $\\Delta x = (x_{\\max} - x_{\\min}) / N$。\n*   **时间步进**：采用显式前向欧拉法，时间步长 $\\Delta t$ 满足 Courant–Friedrichs–Lewy (CFL) 条件：$\\Delta t \\le \\mathrm{CFL} \\cdot \\frac{\\Delta x}{\\max_i |u_i|}$。最后一个时间步将被裁剪，以确保在时间 $T$ 精确结束。\n*   **数值通量**：在单元界面处使用 Godunov 数值通量。\n*   **边界条件**：透射（出流）边界，通过将边界单元值复制到虚拟单元来实现。\n*   **域和时间参数**：$[x_{\\min}, x_{\\max}] = [-1, 1]$，$x_0 = 0$，以及 $T = 0.2$。默认 CFL 数为 $0.9$。\n*   **精确解构造**：基于激波的 Rankine–Hugoniot 条件 ($u_L > u_R$) 和自相似稀疏解 ($u_L < u_R$)。\n*   **误差度量**：\n    1.  离散 $L^1$ 误差：$E_{L^1} = \\sum_{i=1}^{N} \\left| u_i^{\\text{num}}(T) - u_i^{\\text{exact}}(T) \\right| \\Delta x$。\n    2.  绝对激波位置误差：$| \\hat{x}_s(T) - x_s(T) |$。\n*   **数值激波位置估计**：使用线性插值找到数值解穿过值 $\\frac{u_L + u_R}{2}$ 的位置。指定了一个备用方法：使用最大离散梯度幅值的位置。\n*   **测试套件**：提供了五个具体的测试用例，每个用例都带有参数 $(u_L, u_R, N, \\mathrm{CFL})$ 和一个确定的输出。\n\n**步骤2：使用提取的已知条件进行验证**\n\n根据验证标准对问题进行分析：\n*   **科学基础**：该问题在根本上是合理的。它基于伯格斯方程，这是流体动力学和双曲守恒律理论中的一个经典模型。黎曼问题、Rankine–Hugoniot 条件、稀疏波、有限体积法、Godunov 通量和 CFL 条件等概念都是应用数学和计算科学中标准且成熟的原则。\n*   **适定性**：该问题是适定的。它提供了数学模型、初始和边界条件、数值方法以及误差分析程序的完整规范。每个测试用例的所有参数都明确定义，从而导出一个唯一且有意义的计算任务。\n*   **客观性**：问题陈述精确、客观、无歧义。任务是定量的，并基于形式化的数学和数值定义。\n*   **完整性和一致性**：问题陈述是自洽的，没有矛盾。它提供了实现模拟和执行所需分析的所有必要信息。\n*   **可行性和现实性**：该问题在计算上是可行的。指定的网格大小和最终时间所导致的模拟可以在标准计算机上很短的时间内完成。该设置是数值格式的经典验证练习。\n*   **其他缺陷**：该问题不是隐喻性的、琐碎的、无法验证的或故作高深的。它是数值方法验证和确认中的一个直接和标准的练习。\n\n**步骤3：结论和行动**\n\n问题陈述是**有效的**。将开发一个完整的解决方案。\n\n### **方案设计与原理**\n\n解决方案将基于双曲守恒律和有限体积法的基本原理来构建。\n\n**1. 无粘伯格斯方程与黎曼问题**\n\n控制方程为守恒形式的无粘伯格斯方程：\n$$ \\frac{\\partial u}{\\partial t} + \\frac{\\partial}{\\partial x} \\left(\\frac{1}{2} u^2\\right) = 0 $$\n该方程模拟了量 $u$ 的演化，其通量为 $f(u) = \\frac{1}{2} u^2$。初始条件是一个黎曼问题，由在 $x_0$ 处被一个间断分开的两个恒定状态 $u_L$ 和 $u_R$ 组成。\n\n**2. 黎曼问题的精确解**\n\n精确解取决于 $u_L$ 和 $u_R$ 之间的关系。该方程的特征速度为 $f'(u) = u$。\n\n*   **激波 ($u_L > u_R$)**：当来自间断左右两侧的特征线相撞时，形成一个激波。这个间断的速度 $s$ 由 Rankine–Hugoniot 跳跃条件给出：\n    $$ s = \\frac{f(u_R) - f(u_L)}{u_R - u_L} = \\frac{\\frac{1}{2}u_R^2 - \\frac{1}{2}u_L^2}{u_R - u_L} = \\frac{1}{2}(u_L + u_R) $$\n    激波以这个恒定速度传播。其在时间 $t$ 的位置是 $x_s(t) = x_0 + s \\cdot t$。解是分段常数：\n    $$ u(x, t) = \\begin{cases} u_L, & x < x_s(t) \\\\ u_R, & x > x_s(t) \\end{cases} $$\n\n*   **稀疏波 ($u_L < u_R$)**：当特征线分开时，会形成一个膨胀波或稀疏扇。解是连续且自相似的，仅依赖于变量 $\\xi = (x - x_0)/t$。解由下式给出：\n    $$ u(x, t) = \\begin{cases} u_L, & \\text{if } (x - x_0)/t \\le u_L \\\\ (x - x_0)/t, & \\text{if } u_L < (x - x_0)/t < u_R \\\\ u_R, & \\text{if } (x - x_0)/t \\ge u_R \\end{cases} $$\n    对于 $t=0$，这简化为初始条件。对于 $t>0$，解通过一个关于 $x$ 的线性剖面平滑地连接 $u_L$ 和 $u_R$。\n\n*   **恒定状态 ($u_L = u_R$)**：解在所有时间内保持恒定：$u(x,t) = u_L$。\n\n**3. 有限体积法**\n\n我们将域 $[x_{\\min}, x_{\\max}]$ 离散为 $N$ 个单元，$C_i = [x_{i-1/2}, x_{i+1/2}]$，每个单元的宽度为 $\\Delta x$。我们追踪解的单元平均值，$u_i(t) \\approx \\frac{1}{\\Delta x} \\int_{C_i} u(x,t) dx$。将守恒律在单元 $C_i$ 上积分并使用散度定理，得到：\n$$ \\frac{d u_i}{d t} + \\frac{1}{\\Delta x} \\left[ f(u(x_{i+1/2}, t)) - f(u(x_{i-1/2}, t)) \\right] = 0 $$\n我们用一个数值通量函数 $F(u_L, u_R)$ 来近似单元界面 $x_{i+1/2}$ 处的瞬时通量，该函数依赖于相邻单元 $u_i$ 和 $u_{i+1}$ 的状态。使用一阶显式欧拉时间积分，我们得到更新公式：\n$$ u_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x} \\left( F_{i+1/2} - F_{i-1/2} \\right) $$\n其中 $u_i^n$ 是在时间 $t^n$ 的近似值，而 $F_{i+1/2} = F(u_i^n, u_{i+1}^n)$。\n\n**4. Godunov 数值通量**\n\nGodunov 通量是从每个单元界面处的局部黎曼问题的精确解推导出来的。对于单元 $i$（状态 $u_i$）和单元 $i+1$（状态 $u_{i+1}$）之间的界面，通量 $F(u_i, u_{i+1})$ 是在界面位置（在局部坐标中为 $x/t=0$）计算的精确通量 $f(u(x,t))$。此计算得出：\n$$ F_G(u_L, u_R) = \\begin{cases} f(u_L) & \\text{if } u_L > u_R \\text{ and } s \\ge 0 \\\\ f(u_R) & \\text{if } u_L > u_R \\text{ and } s < 0 \\\\ f(u_L) & \\text{if } u_L \\le u_R \\text{ and } u_L \\ge 0 \\\\ f(u_R) & \\text{if } u_L \\le u_R \\text{ and } u_R \\le 0 \\\\ f(0) = 0 & \\text{if } u_L < 0 < u_R \\end{cases} $$\n其中 $s = \\frac{1}{2}(u_L + u_R)$ 是激波速度。已知这种通量格式是满足熵条件的，这意味着它能正确捕捉激波而不会产生非物理的膨胀激波。\n\n**5. 时间步长和边界条件**\n\n显式格式在 CFL 条件下是稳定的，该条件根据域中的最大波速限制时间步长 $\\Delta t$。对于伯格斯方程，波速为 $|u|$。因此，\n$$ \\Delta t = \\mathrm{CFL} \\frac{\\Delta x}{\\max_{i} |u_i^n|} $$\n其中 $\\mathrm{CFL} \\in (0, 1]$ 是 Courant 数。必须裁剪最后一个时间步以确保模拟在 $T$ 时刻精确停止。透射（出流）边界条件通过将虚拟单元中的值设置为其相邻内部单元的值来实现，例如，$u_0 = u_1$ 和 $u_{N+1} = u_N$。\n\n**6. 误差计算**\n\n为了计算 $L^1$ 误差，必须将数值解（代表单元平均值）与精确解的单元平均值进行比较。对于一个单元 $C_i = [x_{i-1/2}, x_{i+1/2}]$，精确的单元平均值为：\n$$ u_i^{\\text{exact}}(T) = \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} u_{\\text{exact}}(x, T) dx $$\n这个积分是解析计算的。对于激波，被积函数是分段常数。对于稀疏波，它是分段线性的，涉及 $(x-x_0)/T$ 的积分，这是初等的。\n\n数值激波位置 $\\hat{x}_s(T)$ 是通过找到数值解穿过值 $u_{mid} = (u_L+u_R)/2$ 的两个相邻单元中心 $x_{c,j}$ 和 $x_{c,j+1}$ 来估计的。然后使用线性插值来找到这个交叉点的位置。绝对误差为 $| \\hat{x}_s(T) - x_s(T) |$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main driver function to execute the verification suite for the \n    finite volume solution of the inviscid Burgers' equation.\n    \"\"\"\n\n    def godunov_flux(u_l, u_r):\n        \"\"\"Computes the Godunov flux for the Burgers' equation f(u) = 0.5*u^2.\"\"\"\n        f_l = 0.5 * u_l**2\n        f_r = 0.5 * u_r**2\n\n        if u_l > u_r:  # Shock\n            s = 0.5 * (u_l + u_r)\n            return f_l if s >= 0 else f_r\n        else:  # Rarefaction or constant state\n            if u_l >= 0:\n                return f_l\n            elif u_r <= 0:\n                return f_r\n            else:  # u_l < 0 < u_r\n                return 0.0\n\n    def get_exact_solution_cell_avg(x_centers, dx, T, u_l, u_r, x0):\n        \"\"\"\n        Computes the cell-averaged exact solution of the Riemann problem\n        for the Burgers' equation at time T.\n        \"\"\"\n        N = len(x_centers)\n        u_exact_avg = np.zeros(N)\n        \n        if T == 0:\n            return np.where(x_centers < x0, u_l, u_r)\n\n        if u_l > u_r:  # Shock wave\n            s = 0.5 * (u_l + u_r)\n            xs = x0 + s * T\n            for i in range(N):\n                xa = x_centers[i] - 0.5 * dx\n                xb = x_centers[i] + 0.5 * dx\n                if xb <= xs:\n                    u_exact_avg[i] = u_l\n                elif xa >= xs:\n                    u_exact_avg[i] = u_r\n                else:\n                    u_exact_avg[i] = (u_l * (xs - xa) + u_r * (xb - xs)) / dx\n        else:  # Rarefaction wave\n            x_fan_l = x0 + u_l * T\n            x_fan_r = x0 + u_r * T\n            \n            # Indefinite integral of (x-x0)/T is F(x)\n            F = lambda x: (0.5 * x**2 - x0 * x) / T\n            \n            for i in range(N):\n                xa = x_centers[i] - 0.5 * dx\n                xb = x_centers[i] + 0.5 * dx\n                \n                # Part 1: Integral over the left constant region\n                len_l = max(0, min(xb, x_fan_l) - xa)\n                integral_l = u_l * len_l\n\n                # Part 2: Integral over the right constant region\n                len_r = max(0, xb - max(xa, x_fan_r))\n                integral_r = u_r * len_r\n\n                # Part 3: Integral over the fan region\n                ix_a = max(xa, x_fan_l)\n                ix_b = min(xb, x_fan_r)\n                if ix_a >= ix_b:\n                    integral_fan = 0.0\n                else:\n                    integral_fan = F(ix_b) - F(ix_a)\n                \n                u_exact_avg[i] = (integral_l + integral_fan + integral_r) / dx\n\n        return u_exact_avg\n\n    def estimate_shock_pos(u_num, x_centers, dx, u_l, u_r):\n        \"\"\"Estimates the numerical shock position.\"\"\"\n        u_mid = 0.5 * (u_l + u_r)\n        \n        # Find where solution crosses the midpoint\n        crossings = np.where(np.diff(np.sign(u_num - u_mid)))[0]\n\n        if len(crossings) > 0:\n            idx = crossings[0]\n            u1, u2 = u_num[idx], u_num[idx+1]\n            x1, x2 = x_centers[idx], x_centers[idx+1]\n            # Linear interpolation\n            if u2 - u1 != 0:\n                pos = x1 + (x2 - x1) * (u_mid - u1) / (u2 - u1)\n                return pos\n        \n        # Fallback: position of largest gradient magnitude\n        gradient_mag = np.abs(np.diff(u_num))\n        idx = np.argmax(gradient_mag)\n        # Position is the interface between cell idx and idx+1\n        pos = x_centers[idx] + 0.5 * dx\n        return pos\n\n    def run_simulation(u_l, u_r, x0, N, T, cfl, x_min=-1.0, x_max=1.0):\n        \"\"\"\n        Runs the first-order finite volume simulation for Burgers' equation.\n        \"\"\"\n        dx = (x_max - x_min) / N\n        x_centers = x_min + (np.arange(N) + 0.5) * dx\n        u = np.where(x_centers < x0, u_l, u_r)\n        \n        t = 0.0\n        while t < T:\n            max_abs_u = np.max(np.abs(u))\n            \n            if max_abs_u == 0:\n                dt = T - t # If u is zero, it stays zero. Fast-forward.\n            else:\n                dt = cfl * dx / max_abs_u\n            \n            dt = min(dt, T - t)\n            \n            # Transmissive (outflow) boundary conditions using padding\n            u_padded = np.pad(u, 1, 'edge')\n            \n            fluxes = np.zeros(N + 1)\n            for i in range(N + 1):\n                fluxes[i] = godunov_flux(u_padded[i], u_padded[i + 1])\n                \n            u = u - (dt / dx) * (fluxes[1:] - fluxes[:-1])\n            t += dt\n            \n        return u, x_centers, dx\n\n    results = []\n    \n    # --- Test Case 1: Shock, L1 error ---\n    params1 = {'u_l': 2.0, 'u_r': 0.0, 'x0': 0.0, 'N': 200, 'T': 0.2, 'cfl': 0.9}\n    u_num, x_centers, dx = run_simulation(**params1)\n    u_exact = get_exact_solution_cell_avg(x_centers, dx, params1['T'], params1['u_l'], params1['u_r'], params1['x0'])\n    l1_error = np.sum(np.abs(u_num - u_exact)) * dx\n    results.append(l1_error)\n    \n    # --- Test Case 2: Shock, convergence ---\n    params2_200 = {'u_l': 2.0, 'u_r': 0.0, 'x0': 0.0, 'N': 200, 'T': 0.2, 'cfl': 0.9}\n    u_num_200, x_200, dx_200 = run_simulation(**params2_200)\n    u_exact_200 = get_exact_solution_cell_avg(x_200, dx_200, params2_200['T'], params2_200['u_l'], params2_200['u_r'], params2_200['x0'])\n    l1_error_200 = np.sum(np.abs(u_num_200 - u_exact_200)) * dx_200\n    \n    params2_400 = {'u_l': 2.0, 'u_r': 0.0, 'x0': 0.0, 'N': 400, 'T': 0.2, 'cfl': 0.9}\n    u_num_400, x_400, dx_400 = run_simulation(**params2_400)\n    u_exact_400 = get_exact_solution_cell_avg(x_400, dx_400, params2_400['T'], params2_400['u_l'], params2_400['u_r'], params2_400['x0'])\n    l1_error_400 = np.sum(np.abs(u_num_400 - u_exact_400)) * dx_400\n    \n    convergence_indicator = 1 if l1_error_400 < l1_error_200 else 0\n    results.append(convergence_indicator)\n\n    # --- Test Case 3: Rarefaction, L1 error ---\n    params3 = {'u_l': 0.0, 'u_r': 2.0, 'x0': 0.0, 'N': 400, 'T': 0.2, 'cfl': 0.9}\n    u_num, x_centers, dx = run_simulation(**params3)\n    u_exact = get_exact_solution_cell_avg(x_centers, dx, params3['T'], params3['u_l'], params3['u_r'], params3['x0'])\n    l1_error = np.sum(np.abs(u_num - u_exact)) * dx\n    results.append(l1_error)\n    \n    # --- Test Case 4: Constant state preservation ---\n    params4 = {'u_l': 1.0, 'u_r': 1.0, 'x0': 0.0, 'N': 200, 'T': 0.2, 'cfl': 0.9}\n    u_num, x_centers, dx = run_simulation(**params4)\n    max_dev = np.max(np.abs(u_num - 1.0))\n    results.append(max_dev)\n    \n    # --- Test Case 5: Left-moving shock, position error ---\n    params5 = {'u_l': 0.0, 'u_r': -2.0, 'x0': 0.0, 'N': 300, 'T': 0.2, 'cfl': 0.9}\n    u_num, x_centers, dx = run_simulation(**params5)\n    \n    # Exact shock position\n    s_exact = 0.5 * (params5['u_l'] + params5['u_r'])\n    x_s_exact = params5['x0'] + s_exact * params5['T']\n    \n    # Numerical shock position\n    x_s_hat = estimate_shock_pos(u_num, x_centers, dx, params5['u_l'], params5['u_r'])\n    \n    pos_error = np.abs(x_s_hat - x_s_exact)\n    results.append(pos_error)\n\n    # Format output\n    formatted_results = []\n    for i, res in enumerate(results):\n        if i == 1: # Case 2 is an integer\n            formatted_results.append(str(int(res)))\n        else:\n            formatted_results.append(f\"{res:.6f}\")\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}