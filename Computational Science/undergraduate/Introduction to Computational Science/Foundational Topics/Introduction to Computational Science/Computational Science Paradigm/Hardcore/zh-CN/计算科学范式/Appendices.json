{
    "hands_on_practices": [
        {
            "introduction": "建立对科学计算代码信任的一个强有力方法是检验它是否遵守其旨在模拟的基本物理原理，例如守恒定律或对称性。这种被称为“基于属性的测试”的实践超越了简单的单元测试，它使用随机生成的输入来严格地探查代码中的缺陷。本练习  将演示如何对一个常见的模型——热方程——实施这种测试，并展示这些测试如何能够捕捉到真实世界中的程序错误。",
            "id": "3109343",
            "problem": "设计并实现一个自包含程序，该程序需演示通过基于属性的测试来验证科学代码的计算科学范式。程序必须实例化一个简单的、具有物理动机的数值模型，并使用随机生成的输入来测试核心不变量是否得到遵守。模型、不变量和测试策略详述如下。\n\n模型。考虑一个具有 $N$ 个点的周期性离散网格上的一维热方程（也称为扩散方程），其连续形式为 $u_t = D u_{xx}$，其中 $u$ 表示一个标量场，$D$ 是扩散系数。使用标准的显式前向欧拉有限差分时间推进方法，配合对称三点模板、周期性边界条件和无量纲参数。将离散状态定义为向量 $u \\in \\mathbb{R}^N$，并执行一个时间步长\n$$\nu_i^{\\text{new}} \\;=\\; u_i^{\\text{old}} \\;+\\; \\alpha \\,\\big(u_{i-1}^{\\text{old}} \\;-\\; 2\\,u_i^{\\text{old}} \\;+\\; u_{i+1}^{\\text{old}}\\big)\n$$\n对于所有索引 $i \\in \\{0,1,\\dots,N-1\\}$，采用周期性索引，即 $u_{-1} \\equiv u_{N-1}$ 且 $u_{N} \\equiv u_0$。标量 $\\alpha \\ge 0$ 编码了无量纲化的时间步长和扩散常数。该模型是整个计算科学领域用于研究守恒性、对称性和单调性属性的典型实例。\n\n基本原理和不变量。以下不变量源于核心的物理和数学原理，必须用于构建基于属性的测试：\n- 总量（质量）守恒。对于周期性边界和上述对称模板，离散总量 $S = \\sum_{i=0}^{N-1} u_i$ 在更新步骤下应保持守恒，这反映了在没有源和汇的情况下物理上的质量守恒。\n- 空间反射下的对称等变性。定义离散反射算子 $\\mathcal{R}$ 为 $(\\mathcal{R}u)_i = u_{N-1-i}$。由于模板是对称的，因此对反射后的状态执行更新步骤，然后再反射其结果，这两个操作应该是可交换的：\n$$\n\\text{step}(\\mathcal{R}u) \\;=\\; \\mathcal{R}(\\text{step}(u)).\n$$\n- 值域的单调性。对于 $0 \\le \\alpha \\le \\tfrac{1}{2}$，更新操作是 $u_{i-1}$、$u_i$ 和 $u_{i+1}$ 的一个非负凸组合；因此，离散值域 $R(u) = \\max_i u_i - \\min_i u_i$ 在该步骤下应该是非增的（即 $R(u^{\\text{new}}) \\le R(u^{\\text{old}})$）。这体现了扩散的平滑特性。\n\n测试策略。通过生成随机状态 $u$ 并自动检查上述不变量来实现基于属性的测试。为进行数值验证，采用容差 $\\varepsilon = 10^{-10}$，并将违例情况定义如下：\n- 守恒性违例：如果 $\\big|\\sum_i u_i^{\\text{new}} - \\sum_i u_i^{\\text{old}}\\big| > \\varepsilon$。\n- 对称等变性违例：如果 $\\max_i \\big|(\\text{step}(\\mathcal{R}u))_i - (\\mathcal{R}(\\text{step}(u)))_i\\big| > \\varepsilon$。\n- 单调性违例：如果 $R(u^{\\text{new}}) - R(u^{\\text{old}}) > \\varepsilon$。\n\n缺陷注入。为了模拟代码缺陷，您必须实现更新步骤的两个变体：\n- 一个使用循环移位（即周期性邻居）的正确周期性实现。\n- 一个错误的实现，它在两端错误地使用了零边界条件，即 $\\{0,\\dots,N-1\\}$ 之外的邻居被视为 $0$ 而不是回环。这个缺陷会破坏守恒性和对称性，也可能影响单调性。\n\n随机输入生成。对于每个测试用例，抽取 $T$ 个独立随机状态 $u$，其分量从 $[0,1]$ 上的均匀分布中采样。此外，如果测试用例指定“包含零”，则额外插入一次全零状态 $u = 0$ 的试验，以探查平凡不变量的满足情况。使用提供的种子以保证可复现性。\n\n测试套件。您的程序必须评估以下测试用例，每个用例以元组 $(N,\\alpha,T,\\text{seed},\\text{mode},\\text{include\\_zero})$ 的形式给出：\n- 案例 1：$(64, 0.2, 200, 101, \\text{``correct''}, \\text{True})$。\n- 案例 2：$(64, 0.49, 200, 102, \\text{``correct''}, \\text{True})$。\n- 案例 3：$(64, 0.6, 200, 103, \\text{``correct''}, \\text{False})$。\n- 案例 4：$(64, 0.2, 200, 104, \\text{``buggy''}, \\text{True})$。\n- 案例 5：$(1, 0.2, 50, 105, \\text{``correct''}, \\text{True})$。\n- 案例 6：$(32, 0.2, 200, 106, \\text{``buggy''}, \\text{False})$。\n\n要求输出。对于每个测试用例，按固定顺序（守恒性、对称等变性、单调性）汇总其所有试验中观察到的三种不变量的违例次数。将每个测试用例的结果表示为一个包含三个整数的列表 $[c,s,m]$，其中 $c$ 是守恒性违例计数，$s$ 是对称等变性违例计数，$m$ 是单调性违例计数。您的程序必须生成单行输出，其中包含所有用例的结果，格式为一个用逗号分隔并用方括号括起来的列表，即 Python 风格的列表的列表。因此，该行应表示一个包含 $6$ 个元素的列表，每个元素都是一个按所述顺序排列的包含三个整数的列表。\n\n角度单位不适用。无需进行物理单位转换。\n\n科学真实性。模型、不变量和测试源于广泛使用的数值分析和物理原理。所选参数均在合理范围内。随机化试验模拟了计算科学中常见的基于属性的测试。\n\n您的解决方案必须在不依赖上述基本原理未证明的捷径公式的情况下，推导、实现和测试这些属性。最终答案必须是一个完整的、可运行的程序，并能产生指定的单行输出。",
            "solution": "该问题要求设计并实现一个基于属性的测试框架，以验证一维热方程的数值模型。这包括实现数值方案，形式化定义其基本不变量，然后使用随机生成的数据系统地测试这些不变量的违例情况。\n\n### 1. 数值模型与实现\n\n该物理系统由周期域上的热方程 $u_t = D u_{xx}$ 控制。我们在一个含 $N$ 个点的网格上对此系统进行离散化，其状态由向量 $u \\in \\mathbb{R}^N$ 表示。时间演化使用显式前向欧拉方法建模，空间二阶导数采用中心三点模板。每个网格点 $u_i$ 的更新规则如下：\n$$\nu_i^{\\text{new}} = u_i^{\\text{old}} + \\alpha \\left(u_{i-1}^{\\text{old}} - 2u_i^{\\text{old}} + u_{i+1}^{\\text{old}}\\right)\n$$\n其中 $\\alpha \\ge 0$ 是一个结合了时间步长和扩散系数的无量纲参数。索引按周期性处理，即 $u_{-1} \\equiv u_{N-1}$ 且 $u_N \\equiv u_0$。\n\n此更新可以表示为适合数值计算的向量化形式。括号中的项是离散拉普拉斯算子 $\\Delta_d u$。\n\n**正确实现（周期性边界）：**\n对于周期性边界，$u_i$ 的邻居是 $u_{(i-1) \\pmod N}$ 和 $u_{(i+1) \\pmod N}$。该操作可以通过对状态向量 $u$ 进行循环移位来高效实现。设 $u^{\\text{old}}$ 是前一时间步的状态值向量。新的状态向量 $u^{\\text{new}}$ 为：\n$$\nu^{\\text{new}} = u^{\\text{old}} + \\alpha \\left( \\text{shift}(u^{\\text{old}}, 1) - 2u^{\\text{old}} + \\text{shift}(u^{\\text{old}}, -1) \\right)\n$$\n其中 $\\text{shift}(u, k)_i = u_{(i-k) \\pmod N}$。这对应于 NumPy 中的 `np.roll`。\n\n**错误实现（零边界）：**\n一个常见的缺陷是边界条件的错误处理。这个错误的实现假定零边界条件，即将边界外的邻居值设为零。对于 $i=0$，邻居 $u_{-1}$ 被视为 $0$。对于 $i=N-1$，邻居 $u_N$ 被视为 $0$。边界上的更新规则变为：\n$$\nu_0^{\\text{new}} = u_0^{\\text{old}} + \\alpha \\left(0 - 2u_0^{\\text{old}} + u_1^{\\text{old}}\\right)\n$$\n$$\nu_{N-1}^{\\text{new}} = u_{N-1}^{\\text{old}} + \\alpha \\left(u_{N-2}^{\\text{old}} - 2u_{N-1}^{\\text{old}} + 0\\right)\n$$\n内部点 $i \\in \\{1, \\dots, N-2\\}$ 使用标准模板进行更新。\n\n### 2. 不变量与基于属性的测试\n\n我们根据源于底层物理和数学的三个基本属性来验证这些实现。\n\n**A. 总量守恒**\n该属性反映了封闭系统中的质量或能量守恒。总量为总和 $S = \\sum_{i=0}^{N-1} u_i$。\n对于**正确**的周期性实现，我们将更新规则对所有 $i$ 求和：\n$$\n\\sum_{i=0}^{N-1} u_i^{\\text{new}} = \\sum_{i=0}^{N-1} u_i^{\\text{old}} + \\alpha \\sum_{i=0}^{N-1} \\left(u_{i-1}^{\\text{old}} - 2u_i^{\\text{old}} + u_{i+1}^{\\text{old}}\\right)\n$$\n最后一项在周期性边界下是一个离散伸缩和：\n$$\n\\sum_{i=0}^{N-1} (u_{i-1} - 2u_i + u_{i+1}) = \\sum u_{i-1} - 2\\sum u_i + \\sum u_{i+1} = S^{\\text{old}} - 2S^{\\text{old}} + S^{\\text{old}} = 0\n$$\n因此，$\\sum u_i^{\\text{new}} = \\sum u_i^{\\text{old}}$。总和是一个不变量。\n对于**错误**的实现，离散拉普拉斯算子的总和为 $\\sum_{i=0}^{N-1} L_i = -u_0 - u_{N-1}$（通过逐项求和得出），通常不为零。因此，守恒性被破坏。\n测试检查 $|\\sum u_i^{\\text{new}} - \\sum u_i^{\\text{old}}| > \\varepsilon$ 是否成立，其中 $\\varepsilon=10^{-10}$。\n\n**B. 空间反射下的对称等变性**\n反射算子定义为 $(\\mathcal{R}u)_i = u_{N-1-i}$。模板的对称性意味着时间步长操作 $\\text{step}(\\cdot)$ 应与 $\\mathcal{R}$ 可交换：$\\text{step}(\\mathcal{R}u) = \\mathcal{R}(\\text{step}(u))$。\n对于**正确**的实现，对反射状态 $(\\mathcal{R}u)$ 在索引 $i$ 处的更新取决于 $u_{N-1-(i-1)}, u_{N-1-i}, u_{N-1-(i+1)}$。对原始状态 $u$ 在索引 $N-1-i$ 处的更新取决于 $u_{N-1-i-1}, u_{N-1-i}, u_{N-1-i+1}$。由于 $i\\pm1$ 邻居的系数相同，这两个操作产生相同的结果。\n**错误**的实现破坏了这种对称性。零边界条件应用于索引 $0$ 和 $N-1$。当我们计算 $\\text{step}(\\mathcal{R}u)$ 时，零边界条件应用于 $(\\mathcal{R}u)_0 = u_{N-1}$ 和 $(\\mathcal{R}u)_{N-1} = u_0$。当我们计算 $\\mathcal{R}(\\text{step}(u))$ 时，我们反射的是将零边界条件应用于 $u_0$ 和 $u_{N-1}$ 后的结果。这两个操作是不等价的。\n测试检查 $\\max_i |(\\text{step}(\\mathcal{R}u))_i - (\\mathcal{R}(\\text{step}(u)))_i| > \\varepsilon$ 是否成立。\n\n**C. 值域的单调性**\n对于 $0 \\le \\alpha \\le \\frac{1}{2}$，更新规则是一个非负系数的凸组合：\n$$\nu_i^{\\text{new}} = \\alpha u_{i-1}^{\\text{old}} + (1-2\\alpha)u_i^{\\text{old}} + \\alpha u_{i+1}^{\\text{old}}\n$$\n其中 $\\alpha \\ge 0$ 且 $(1-2\\alpha) \\ge 0$。系数之和为 $1$。该属性被称为离散极值原理。它意味着新值 $u_i^{\\text{new}}$ 不可能超出其贡献来源的旧值的范围。从全局来看，这意味着 $\\min(u^{\\text{old}}) \\le \\min(u^{\\text{new}})$ 且 $\\max(u^{\\text{new}}) \\le \\max(u^{\\text{old}})$。因此，值域 $R(u) = \\max_i u_i - \\min_i u_i$ 必须是非增的：$R(u^{\\text{new}}) \\le R(u^{\\text{old}})$。\n只要 $0 \\le \\alpha \\le \\frac{1}{2}$，此属性对**正确**和**错误**的实现都成立，因为在错误情况下，边界处的更新规则也构成了凸组合。\n当 $\\alpha > \\frac{1}{2}$ 时，该属性预计不成立，这对应于一个物理上和数值上都不稳定的区域。\n测试检查 $R(u^{\\text{new}}) - R(u^{\\text{old}}) > \\varepsilon$ 是否成立。\n\n### 3. 测试过程\n\n程序会遍历一套预定义的测试用例。对于每个用例，它都会使用给定的种子初始化一个随机数生成器，以保证可复现性。它生成 $T$ 个随机状态向量 $u$，其分量从 $[0,1]$ 上的均匀分布中抽取。如果指定，还会额外包含一次使用零向量 $u=0$ 的试验。对于每个试验状态，程序应用指定的（`correct` 或 `buggy`）时间步长函数，并检查三种不变量的违例情况。每种不变量的违例总数被计数并报告。这个自动化过程是基于属性的测试的典范，即通过大量随机输入来验证系统的抽象属性，从而为代码的正确性提供有力证据或揭示细微的错误。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef step_correct(u: np.ndarray, alpha: float) -> np.ndarray:\n    \"\"\"\n    Performs one time step of the 1D heat equation with periodic boundary conditions.\n    \"\"\"\n    if u.size == 0:\n        return np.array([])\n    # The discrete Laplacian with periodic boundaries is implemented via circular shifts.\n    laplacian = np.roll(u, 1) - 2 * u + np.roll(u, -1)\n    return u + alpha * laplacian\n\ndef step_buggy(u: np.ndarray, alpha: float) -> np.ndarray:\n    \"\"\"\n    Performs one time step of the 1D heat equation with buggy zero boundary conditions.\n    \"\"\"\n    n = u.size\n    if n == 0:\n        return np.array([])\n    \n    u_new = np.copy(u)\n    \n    # Interior points update\n    if n > 2:\n        laplacian_interior = u[:-2] - 2 * u[1:-1] + u[2:]\n        u_new[1:-1] += alpha * laplacian_interior\n\n    # Boundary points update with zero-value neighbors\n    if n >= 2:\n        # Left boundary i=0, neighbor u_{-1} is 0\n        laplacian_0 = 0 - 2 * u[0] + u[1]\n        u_new[0] += alpha * laplacian_0\n        # Right boundary i=n-1, neighbor u_{n} is 0\n        laplacian_n_minus_1 = u[n-2] - 2 * u[n-1] + 0\n        u_new[n-1] += alpha * laplacian_n_minus_1\n    elif n == 1:\n        # Special case for N=1, both neighbors are 0\n        laplacian_0 = 0 - 2 * u[0] + 0\n        u_new[0] += alpha * laplacian_0\n\n    return u_new\n\ndef solve():\n    \"\"\"\n    Main function to run the property-based tests for the given cases.\n    \"\"\"\n    test_cases = [\n        (64, 0.2, 200, 101, \"correct\", True),\n        (64, 0.49, 200, 102, \"correct\", True),\n        (64, 0.6, 200, 103, \"correct\", False),\n        (64, 0.2, 200, 104, \"buggy\", True),\n        (1, 0.2, 50, 105, \"correct\", True),\n        (32, 0.2, 200, 106, \"buggy\", False),\n    ]\n\n    all_results = []\n    epsilon = 1e-10\n\n    for n, alpha, t, seed, mode, include_zero in test_cases:\n        \n        # 1. Select the stepping function based on the test case mode\n        step_func = step_correct if mode == \"correct\" else step_buggy\n\n        # 2. Generate random states for testing\n        rng = np.random.default_rng(seed)\n        states = [rng.uniform(0, 1, size=n) for _ in range(t)]\n        if include_zero:\n            states.append(np.zeros(n))\n        \n        # 3. Initialize violation counters\n        conservation_violations = 0\n        symmetry_violations = 0\n        monotonicity_violations = 0\n\n        # 4. Iterate through test states and check invariants\n        for u_old in states:\n            if u_old.size == 0:\n                continue\n            \n            # --- Perform one time step ---\n            u_new = step_func(u_old, alpha)\n\n            # --- Test 1: Conservation of total quantity ---\n            sum_old = np.sum(u_old)\n            sum_new = np.sum(u_new)\n            if np.abs(sum_new - sum_old) > epsilon:\n                conservation_violations += 1\n\n            # --- Test 2: Symmetry equivariance ---\n            # LHS: step(reflect(u))\n            u_reflected = u_old[::-1]\n            lhs = step_func(u_reflected, alpha)\n            # RHS: reflect(step(u))\n            rhs = u_new[::-1]\n            \n            if np.max(np.abs(lhs - rhs)) > epsilon:\n                symmetry_violations += 1\n\n            # --- Test 3: Monotonicity of the range ---\n            # This property is only guaranteed for 0 <= alpha <= 0.5\n            # The test is run for all alpha to see when it fails.\n            if u_old.size > 0:\n                range_old = np.max(u_old) - np.min(u_old)\n                range_new = np.max(u_new) - np.min(u_new)\n                if range_new - range_old > epsilon:\n                    monotonicity_violations += 1\n            \n        all_results.append([conservation_violations, symmetry_violations, monotonicity_violations])\n\n    # Final print statement in the exact required format.\n    print(f\"{all_results}\")\n\nsolve()\n```"
        },
        {
            "introduction": "即使是正确实现的算法，由于离散化过程本身，其产生的结果也可能偏离真实的物理现象。计算科学家的一个关键技能是理解并量化这些“数值效应”。本练习  提供了一种动手实践的方法，用于测量一种称为“数值扩散”的效应，即模拟中的尖锐特征被人为地平滑掉，并将其与一个等效的物理扩散系数联系起来。",
            "id": "3109427",
            "problem": "要求您设计并实现一个受控数值实验，以估计一维线性双曲偏微分方程的离散求解器所引入的数值扩散量。考虑单位区间上的周期性线性平流方程，\n$$\n\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = 0, \\quad x \\in [0,1), \\quad t \\ge 0,\n$$\n其中平流速度 $a > 0$ 为常数。所有量均为无量纲。\n\n基本和建模假设：\n- 线性平流方程表示在恒定输运速度 $a$ 下被动平流标量的守恒。输运定理意味着，在连续情况下，方波初始条件将保持为方波，仅发生平移而无变形。\n- 双曲方程的标准一阶单调离散化方法，如迎风格式（upwind）或 Lax–Friedrichs 格式，通常会在不连续处引入平滑。这种平滑可以被解释为一种伪影，类似于一种有效扩散，而这种扩散在真实的连续动力学中是不存在的。\n\n您的目标是通过估计一个等效扩散系数来量化这种平滑，如果每个界面附近的解局部地由纯扩散方程控制，该系数将产生可比较的边缘展宽。为此，您必须：\n- 从已知的守恒律出发，利用关于阶跃函数扩散的成熟理论，推导出一个实用的估计器，将数值弥散锋面的测量陡度与等效的常数扩散系数联系起来。\n- 在一个带有周期性边界条件的均匀网格上，为平流方程实现两种显式有限差分格式：\n  1. $a > 0$ 的迎风格式（也称 donor-cell 格式）。\n  2. Lax–Friedrichs 格式。\n- 使用高度为 $1$ 的方波初始条件，占据域的中心一半：\n  $$\n  u(x,0) = \n  \\begin{cases}\n  1, & x \\in [0.25, 0.75), \\\\\n  0, & \\text{otherwise on } [0,1).\n  \\end{cases}\n  $$\n- 设置平流速度为 $a = 1$。\n- 用 $N$ 个均匀间隔的网格点对空间进行离散化，网格间距为 $\\Delta x = 1/N$。使用由 Courant–Friedrichs–Lewy (CFL) 数 $\\lambda = a \\Delta t / \\Delta x$ 决定的恒定时间步长 $\\Delta t$，即 $\\Delta t = \\lambda \\Delta x / a$。使用显式更新在时间上进行演化，直到满足 $n \\Delta t \\le T$ 的最大整数步数 $n$，其中 $T$ 是目标最终时间，并将达到的最终时间记为 $t_{\\text{end}} = n \\Delta t$。\n- 在 $t_{\\text{end}}$ 时刻，使用数值解计算最大斜率幅值的稳健度量，\n  $$\n  g_{\\max} \\approx \\max_i \\left| \\frac{u_{i+1} - u_{i-1}}{2 \\Delta x} \\right|,\n  $$\n  它近似了解的最陡空间导数。\n\n估计器设计要求：\n- 利用扩散理论中一个成熟的结论，即在具有恒定扩散系数 $\\nu$ 的纯扩散方程下，不连续阶跃的局部演化会导致一个自相似的误差函数剖面，其界面中心斜率随时间以已知速率衰减。从这一事实出发，推导一个显式估计器，用 $g_{\\max}$ 和 $t_{\\text{end}}$ 表示等效的常数扩散系数 $\\nu_{\\text{eff}}$。基于基本原理，从逻辑和量纲上证明该估计器的合理性，而无需借助任何特别拟合。\n- 实现该估计器，以根据每个数值实验计算 $\\nu_{\\text{eff}}$。\n\n实现细节：\n- 在 $[0,1)$ 上使用周期性边界条件。\n- 按照规定，使用中心有限差分计算斜率代理 $g_{\\max}$。\n- 求解器的实现必须是：\n  - 迎风格式（$a>0$）：仅使用 $u_i^n$ 和 $u_{i-1}^n$ 以及正确的迎风通量来更新 $u_i^{n+1}$。\n  - Lax–Friedrichs 格式：将 $u_i^{n+1}$ 更新为一个对称平均值加上一个由 Courant–Friedrichs–Lewy 数缩放的中心通量差。\n\n测试套件：\n运行以下五个测试用例，每个用例指定为一个元组，包含方法、网格点数 $N$、Courant–Friedrichs–Lewy 数 $\\lambda$ 和目标最终时间 $T$：\n- 用例 1：方法 = upwind, $N = 200$, $\\lambda = 0.5$, $T = 0.2$。\n- 用例 2：方法 = upwind, $N = 400$, $\\lambda = 0.5$, $T = 0.2$。\n- 用例 3：方法 = upwind, $N = 200$, $\\lambda = 0.9$, $T = 0.2$。\n- 用例 4：方法 = lax\\_friedrichs, $N = 200$, $\\lambda = 0.5$, $T = 0.2$。\n- 用例 5：方法 = lax\\_friedrichs, $N = 400$, $\\lambda = 0.9$, $T = 0.2$。\n\n对于每个用例，计算并报告一个浮点数：与达到的最终时间 $t_{\\text{end}}$ 对应的估计等效扩散系数 $\\nu_{\\text{eff}}$。所有量均为无量纲。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个逗号分隔的十进制数列表，这些数字四舍五入到小数点后六位，并用方括号括起来，顺序与上述五个用例相同；例如，输出行的格式如下\n  $$\n  [x_1,x_2,x_3,x_4,x_5],\n  $$\n  其中每个 $x_i$ 是格式化为小数点后六位的浮点数。",
            "solution": "问题陈述已经过严格审查，并被确定为有效。它具有科学依据，是适定的、客观的和完整的。它构成了计算科学中的一个标准练习，要求推导估计器、实现数值格式以及执行受控数值实验。\n\n### 1. 有效扩散系数估计器的推导\n\n目标是推导一个有效扩散系数 $\\nu_{\\text{eff}}$ 的估计器，用以量化尖锐界面的数值弥散。问题建议将这种弥散建模为一个由纯扩散方程控制的物理扩散过程：\n$$\n\\frac{\\partial u}{\\partial t} = \\nu_{\\text{eff}} \\frac{\\partial^2 u}{\\partial x^2}\n$$\n我们考虑一个位于 $x=x_0$、高度为 $\\Delta U$ 的单个阶跃函数初始条件：\n$$\nu(x,0) = \\begin{cases} U_L, & x < x_0 \\\\ U_R, & x > x_0 \\end{cases}\n$$\n其中跳跃高度为 $\\Delta U = |U_R - U_L|$。对于该初始条件，扩散方程的解析解用误差函数 $\\text{erf}(z)$ 表示：\n$$\nu(x,t) = U_L + (U_R - U_L) \\frac{1}{2} \\left[ 1 + \\text{erf}\\left(\\frac{x-x_0}{2\\sqrt{\\nu_{\\text{eff}} t}}\\right) \\right]\n$$\n问题指定了一个方波初始条件，在 $x=0.25$ 处有高度为 $\\Delta U = 1$ 的跳跃（从 $0$ 到 $1$），在 $x=0.75$ 处有高度为 $\\Delta U = -1$ 的跳跃（从 $1$ 到 $0$）。在每个界面附近，短时间内，其演化可以独立地用单个阶跃的扩散来近似。我们来分析 $x_0 = 0.25$ 处的阶跃，其中 $U_L=0$ 且 $U_R=1$。局部解的剖面为：\n$$\nu(x,t) \\approx \\frac{1}{2}\\left[ 1 + \\text{erf}\\left(\\frac{x-x_0}{2\\sqrt{\\nu_{\\text{eff}} t}}\\right) \\right]\n$$\n为了找到剖面最陡峭的部分，我们计算空间导数 $\\frac{\\partial u}{\\partial x}$：\n$$\n\\frac{\\partial u}{\\partial x} = \\frac{1}{2} \\frac{d}{dx} \\left[ \\text{erf}\\left(\\frac{x-x_0}{2\\sqrt{\\nu_{\\text{eff}} t}}\\right) \\right]\n$$\n使用恒等式 $\\frac{d}{dz} \\text{erf}(z) = \\frac{2}{\\sqrt{\\pi}} e^{-z^2}$ 和链式法则，我们得到：\n$$\n\\frac{\\partial u}{\\partial x} = \\frac{1}{2} \\left[ \\frac{2}{\\sqrt{\\pi}} \\exp\\left(-\\left(\\frac{x-x_0}{2\\sqrt{\\nu_{\\text{eff}} t}}\\right)^2\\right) \\right] \\cdot \\frac{1}{2\\sqrt{\\nu_{\\text{eff}} t}} = \\frac{1}{2\\sqrt{\\pi \\nu_{\\text{eff}} t}} \\exp\\left(-\\frac{(x-x_0)^2}{4 \\nu_{\\text{eff}} t}\\right)\n$$\n斜率的幅值在界面中心 $x=x_0$ 处达到最大。设这个最大斜率为 $g_{\\max}$：\n$$\ng_{\\max} = \\left| \\frac{\\partial u}{\\partial x} \\right|_{x=x_0} = \\frac{1}{2\\sqrt{\\pi \\nu_{\\text{eff}} t}}\n$$\n这个关系将扩散剖面的最大斜率与扩散系数 $\\nu_{\\text{eff}}$ 和时间 $t$ 联系起来。数值实验在最终时间 $t_{\\text{end}}$ 测量 $g_{\\max}$。我们可以重新整理方程以求解 $\\nu_{\\text{eff}}$：\n$$\ng_{\\max}^2 = \\frac{1}{4 \\pi \\nu_{\\text{eff}} t_{\\text{end}}}\n$$\n$$\n\\nu_{\\text{eff}} = \\frac{1}{4 \\pi t_{\\text{end}} g_{\\max}^2}\n$$\n这就是所要求的有效扩散系数估计器。它根据要求从扩散理论的第一性原理推导得出，并且在量纲上是一致的。\n\n### 2. 数值格式与实现\n\n线性平流方程在一个具有 $N$ 个点的均匀网格上求解，$x_i = i \\Delta x$，$i=0, \\dots, N-1$，其中 $\\Delta x = 1/N$。时间用恒定步长 $\\Delta t = \\lambda \\Delta x / a$ 进行离散化，其中 $\\lambda$ 是 CFL 数，$a$ 是平流速度。我们使用周期性边界条件。\n\n#### 2.1 迎风格式\n对于正的平流速度 ($a > 0$)，一阶迎风格式对空间导数使用后向差分：\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} + a \\frac{u_i^n - u_{i-1}^n}{\\Delta x} = 0\n$$\n求解更新后的状态 $u_i^{n+1}$：\n$$\nu_i^{n+1} = u_i^n - \\frac{a \\Delta t}{\\Delta x} (u_i^n - u_{i-1}^n) = u_i^n - \\lambda (u_i^n - u_{i-1}^n)\n$$\n这可以重写为：\n$$\nu_i^{n+1} = (1 - \\lambda) u_i^n + \\lambda u_{i-1}^n\n$$\n该格式在 $0 \\le \\lambda \\le 1$ 时是稳定的。\n\n#### 2.2 Lax–Friedrichs 格式\nLax–Friedrichs 格式对空间导数使用中心差分，并将时间导数中的 $u_i^n$ 项替换为空间平均值：\n$$\n\\frac{u_i^{n+1} - \\frac{1}{2}(u_{i+1}^n + u_{i-1}^n)}{\\Delta t} + a \\frac{u_{i+1}^n - u_{i-1}^n}{2 \\Delta x} = 0\n$$\n求解 $u_i^{n+1}$：\n$$\nu_i^{n+1} = \\frac{1}{2}(u_{i+1}^n + u_{i-1}^n) - \\frac{a \\Delta t}{2 \\Delta x} (u_{i+1}^n - u_{i-1}^n)\n$$\n代入 $\\lambda = a \\Delta t / \\Delta x$：\n$$\nu_i^{n+1} = \\frac{1}{2}(u_{i+1}^n + u_{i-1}^n) - \\frac{\\lambda}{2} (u_{i+1}^n - u_{i-1}^n)\n$$\n该格式在 $|\\lambda| \\le 1$ 时是稳定的。\n\n### 3. 计算流程\n\n对于由（方法，$N$，$\\lambda$，$T$）指定的每个测试用例：\n1.  **初始化**：设置平流速度 $a=1$。定义空间网格，$\\Delta x = 1/N$，在 $[0,1)$ 上有 $N$ 个点。用方波剖面初始化解向量 $u$：当 $x \\in [0.25, 0.75)$ 时，$u(x,0) = 1$，否则为 $0$。\n2.  **时间步进**：计算时间步长 $\\Delta t = \\lambda \\Delta x / a$。确定总时间步数 $n_{\\text{steps}} = \\lfloor T / \\Delta t \\rfloor$。模拟的最终时间为 $t_{\\text{end}} = n_{\\text{steps}} \\Delta t$。\n3.  **演化**：使用指定的数值格式（Upwind 或 Lax–Friedrichs）将解 $u$ 演化 $n_{\\text{steps}}$ 个时间步。周期性边界条件通过使用环绕索引（例如，$u_{-1} \\equiv u_{N-1}$ 和 $u_N \\equiv u_0$）来处理。\n4.  **斜率测量**：在最后一个时间步之后，使用周期性的二阶中心差分从最终解 $u_{\\text{final}}$ 计算最大斜率代理 $g_{\\max}$：\n    $$\n    g_{\\max} = \\max_{i=0, \\dots, N-1} \\left| \\frac{u_{i+1} - u_{i-1}}{2 \\Delta x} \\right|\n    $$\n    其中索引对 $N$ 取模。\n5.  **估计**：使用推导出的估计器计算有效扩散系数 $\\nu_{\\text{eff}}$：\n    $$\n    \\nu_{\\text{eff}} = \\frac{1}{4 \\pi t_{\\text{end}} g_{\\max}^2}\n    $$\n对所有五个测试用例重复此过程，并报告所得的 $\\nu_{\\text{eff}}$ 值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Designs and implements a controlled numerical experiment to estimate \n    numerical diffusion for solvers of the 1D linear advection equation.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (method, N, lambda, T)\n        ('upwind', 200, 0.5, 0.2),\n        ('upwind', 400, 0.5, 0.2),\n        ('upwind', 200, 0.9, 0.2),\n        ('lax_friedrichs', 200, 0.5, 0.2),\n        ('lax_friedrichs', 400, 0.9, 0.2),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        method, N, lam, T = case\n        \n        # --- 1. Initialization ---\n        a = 1.0  # Advection speed\n        \n        # Spatial grid setup\n        dx = 1.0 / N\n        x = np.linspace(0.0, 1.0, N, endpoint=False)\n        \n        # Initial condition: square wave\n        u = np.zeros(N)\n        u[(x >= 0.25) & (x < 0.75)] = 1.0\n        \n        # --- 2. Time Stepping ---\n        dt = lam * dx / a\n        # Ensure num_steps is non-negative, though T>0 and dt>0 makes this safe\n        num_steps = int(np.floor(T / dt)) if dt > 0 else 0\n        t_end = num_steps * dt\n\n        # If no steps are taken, diffusion is zero.\n        # This is an edge case not triggered by the problem's test suite\n        # but is good practice for robustness.\n        if t_end == 0:\n            results.append(0.0)\n            continue\n            \n        # --- 3. Evolution Loop ---\n        for _ in range(num_steps):\n            if method == 'upwind':\n                # u_i^{n+1} = (1-lambda)*u_i^n + lambda*u_{i-1}^n\n                # np.roll(u, 1) shifts elements to the right, u_i -> u_{i+1}\n                # so u_{i-1} corresponds to np.roll(u, 1)\n                u_im1 = np.roll(u, 1)\n                u = (1.0 - lam) * u + lam * u_im1\n            elif method == 'lax_friedrichs':\n                # u_i^{n+1} = 0.5*(u_{i+1}+u_{i-1}) - 0.5*lambda*(u_{i+1}-u_{i-1})\n                u_ip1 = np.roll(u, -1)\n                u_im1 = np.roll(u, 1)\n                u = 0.5 * (u_ip1 + u_im1) - 0.5 * lam * (u_ip1 - u_im1)\n\n        # --- 4. Slope Measurement ---\n        # g_max approx max| (u_{i+1} - u_{i-1}) / (2*dx) |\n        u_ip1 = np.roll(u, -1)\n        u_im1 = np.roll(u, 1)\n        gradient = (u_ip1 - u_im1) / (2.0 * dx)\n        g_max = np.max(np.abs(gradient))\n        \n        # --- 5. Estimation ---\n        # nu_eff = 1 / (4 * pi * t_end * g_max^2)\n        if g_max > 0:\n            nu_eff = 1.0 / (4.0 * np.pi * t_end * g_max**2)\n        else:\n            # If g_max is zero, it implies no diffusion (perfect translation)\n            # which equates to zero effective diffusivity.\n            nu_eff = 0.0\n\n        results.append(nu_eff)\n\n    # Format results to six decimal places for the final output.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "本章最后将探讨现代科学的基石：可复现性。在计算科学中，这意味着确保研究结果是稳健的，而不仅仅是特定计算机或编译器的偶然产物。这项实践  模拟了这一挑战，它在略有不同的“计算环境”下运行同一个模型，并引入一种正式的统计方法——柯尔莫哥洛夫-斯米尔诺夫检验（Kolmogorov-Smirnov test），来客观地判断两组结果在统计上是否等价。",
            "id": "3109390",
            "problem": "要求您本着计算科学范式的精神，设计一个小型、独立的的可复现性案例研究。该研究将模拟在不同的编译器和标志配置下运行相同的分子动力学模拟，并通过正式检验系综分布的相等性来判断结果是否可复现。\n\n模拟模型是一个使用速度 Verlet 更新方法进行积分的一维谐振子。在步长索引 $t$ 处的状态是位置 $x_t$ 和速度 $v_t$。物理参数是质量 $m$ 和刚度 $k$。模拟的时间步长是 $\\Delta t$。为了模拟编译器和标志的差异，在每次更新时，中间算术运算的结果会四舍五入到指定的小数精度 $p$，并且可以向更新中应用一个微小的确定性偏差项 $b$ 来表示诸如融合乘加重排之类的效应。所有量都是无量纲的；本问题不涉及物理单位。\n\n从初始条件出发，您的程序必须为一组 $N$ 个独立的初始条件生成一个轨迹系综，然后形成一个最终能量的系综。状态 $(x, v)$ 的能量定义为 $E = \\frac{1}{2} m v^2 + \\frac{1}{2} k x^2$。每个测试用例您将生成两个系综，分别代表两个编译器和标志配置 $A$ 和 $B$。\n\n您必须实现的单个时间步长的积分方案如下：\n- 使用以下公式计算下一个位置：\n$$\nx_{t+\\Delta t} = x_t + v_t \\Delta t - \\frac{1}{2}\\frac{k}{m} x_t (\\Delta t)^2 + b\\, x_t v_t,\n$$\n然后将 $x_{t+\\Delta t}$ 四舍五入到 $p$ 位小数。\n- 使用以下公式计算下一个速度：\n$$\nv_{t+\\Delta t} = v_t - \\frac{1}{2}\\frac{k}{m} (x_t + x_{t+\\Delta t}) \\Delta t + b\\, x_{t+\\Delta t} v_t,\n$$\n然后将 $v_{t+\\Delta t}$ 四舍五入到 $p$ 位小数。\n\n必须通过在一个对称区间上均匀采样 $N$ 个确定性的初始位置 $x_0$ 来构建系综，并为所有系综成员设置 $v_0 = 0$。具体来说，使用在 $[-X, X]$（其中 $X = 0.5$）上均匀分布的 $x_0$ 值。对于给定的配置 $(m, k, \\Delta t, p, b)$ 和步数 $T$，您应该：\n- 如上所述初始化系综，\n- 使用上述更新方法将每个成员推进 $T$ 步，\n- 计算并收集每个成员的最终能量 $E$，形成一个能量系综。\n\n为了判断可复现性，定义原假设 $H_0$ 为：来自配置 $A$ 和 $B$ 的两个能量系综是从同一潜在分布中抽取的样本：\n$$\nH_0: F_A(E) = F_B(E) \\text{ for all } E,\n$$\n其中 $F_A$ 和 $F_B$ 是累积分布函数。使用显著性水平为 $\\alpha$ 的双样本 Kolmogorov–Smirnov (KS) 检验来接受或拒绝可复现性。具体来说，计算两个能量样本的 KS $p$ 值；如果 $p$ 值大于或等于 $\\alpha$，则宣布结果是可复现的，否则为不可复现。\n\n实现程序以运行以下测试套件，每个测试用例由配置 $A$ 和 $B$ 的参数元组以及 $\\alpha$ 定义：\n\n- 测试用例 $1$ (正常路径，配置相同):\n  - 配置 $A$：$m = 1.0$, $k = 2.0$, $\\Delta t = 0.005$, $p = 12$, $b = 0.0$, $T = 100$, $N = 1000$。\n  - 配置 $B$：$m = 1.0$, $k = 2.0$, $\\Delta t = 0.005$, $p = 12$, $b = 0.0$, $T = 100$, $N = 1000$。\n  - $\\alpha = 0.05$。\n- 测试用例 $2$ (边界条件，系综规模非常小):\n  - 配置 $A$：$m = 1.0$, $k = 2.0$, $\\Delta t = 0.005$, $p = 12$, $b = 0.0$, $T = 50$, $N = 8$。\n  - 配置 $B$：$m = 1.0$, $k = 2.0$, $\\Delta t = 0.005$, $p = 12$, $b = 0.0$, $T = 50$, $N = 8$。\n  - $\\alpha = 0.05$。\n- 测试用例 $3$ (质量参数有明显差异):\n  - 配置 $A$：$m = 1.0$, $k = 2.0$, $\\Delta t = 0.005$, $p = 12$, $b = 0.0$, $T = 100$, $N = 500$。\n  - 配置 $B$：$m = 1.5$, $k = 2.0$, $\\Delta t = 0.005$, $p = 12$, $b = 0.0$, $T = 100$, $N = 500$。\n  - $\\alpha = 0.05$。\n- 测试用例 $4$ (多重差异：步长、舍入精度和偏差):\n  - 配置 $A$：$m = 1.0$, $k = 2.0$, $\\Delta t = 0.005$, $p = 12$, $b = 0.0$, $T = 150$, $N = 1000$。\n  - 配置 $B$：$m = 2.0$, $k = 2.0$, $\\Delta t = 0.02$, $p = 6$, $b = 10^{-3}$, $T = 150$, $N = 1000$。\n  - $\\alpha = 0.05$。\n\n您的程序必须：\n- 实现所述的积分器和系综构建方法，\n- 对每个测试用例，为 $A$ 和 $B$ 生成能量系综，\n- 在指定的 $\\alpha$ 水平下应用双样本 KS 检验，\n- 生成一行输出，其中包含一个用方括号括起来的布尔值逗号分隔列表（例如，$[\\text{True},\\text{False},\\text{True}]$），按测试用例 1 到 4 的顺序排列。\n\n所有计算都是无量纲的；不要包含或转换任何物理单位。本问题不使用角度。百分比（如果出现）必须以小数形式表示；然而，本问题没有明确要求使用百分比。",
            "solution": "该问题要求设计并实现一个计算实验来研究数值可复现性。这通过在不同配置下模拟一维谐振子来完成，这些配置模拟了编译器或硬件中的变动，然后使用统计检验来确定结果是否等效。解决方案的核心涉及数值积分、系综生成和假设检验。\n\n首先，我们定义物理模型及其数值积分。该系统是一个质量为 $m$、弹簧常数为 $k$ 的简谐振子。一个状态由其位置 $x$ 和速度 $v$ 定义。状态 $(x, v)$ 的总能量在理想物理系统中是一个守恒量，由表达式 $E = \\frac{1}{2} m v^2 + \\frac{1}{2} k x^2$ 给出。对于数值模拟，我们用步长 $\\Delta t$ 将时间离散化。在时间步长索引 $t$ 处的状态 $(x_t, v_t)$ 通过一个指定的更新方案推进到下一个状态 $(x_{t+\\Delta t}, v_{t+\\Delta t})$。问题陈述提供了一种标准速度 Verlet 算法的变体。首先更新位置：\n$$\nx_{t+\\Delta t} = x_t + v_t \\Delta t - \\frac{1}{2}\\frac{k}{m} x_t (\\Delta t)^2 + b\\, x_t v_t\n$$\n这个更新后的位置 $x_{t+\\Delta t}$ 随后被用来计算新速度：\n$$\nv_{t+\\Delta t} = v_t - \\frac{1}{2}\\frac{k}{m} (x_t + x_{t+\\Delta t}) \\Delta t + b\\, x_{t+\\Delta t} v_t\n$$\n在这些方程中，与偏差参数 $b$ 成比例的项是一个小的确定性扰动，旨在模拟计算环境之间微妙的算术差异，例如由融合乘加指令重排引起的差异。为了进一步模拟有限精度算术的影响，位置和速度更新的结果 $x_{t+\\Delta t}$ 和 $v_{t+\\Delta t}$ 都会四舍五入到指定的小数位数 $p$。\n\n第二个原则是使用系综来捕捉系统演化的统计特性。单个轨迹对初始条件和扰动很敏感（即“蝴蝶效应”）。为了获得对动力学的鲁棒统计描述，我们模拟了一个由 $N$ 个独立系统组成的系综，每个系统都从略微不同的初始条件开始。对于本问题，初始系综由 $N$ 个在区间 $[-0.5, 0.5]$ 上均匀分布的确定性起始位置 $x_0$ 构成。对于系综的所有成员，初始速度 $v_0$ 设为 $0$。然后，使用上述数值方案将这 $N$ 个系统中的每一个随时间向前积分 $T$ 步。在模拟结束时，即在时间 $T \\Delta t$ 处，我们计算 $N$ 个成员中每一个的最终能量 $E$。这个过程产生两组最终能量，一组用于“参考”配置 $A$，另一组用于“测试”配置 $B$。\n\n最后一步是正式检验可复现性。核心问题是，来自配置 $A$ 和 $B$ 的两个最终能量系综是否可能从相同的潜在概率分布中抽取。我们将其形式化为原假设 $H_0$，即两种配置的能量累积分布函数 (CDF) 相同：$H_0: F_A(E) = F_B(E)$。为了检验这个假设，我们采用双样本 Kolmogorov-Smirnov (KS) 检验。这是一种非参数检验，它量化了两个样本的经验累积分布函数之间的最大距离。KS 检验产生一个 $p$ 值，它表示在假设 $H_0$ 为真的情况下，观测到等于或大于所测差异的概率。较小的 $p$ 值表明观测到的差异不太可能仅仅由随机偶然引起，从而导致我们拒绝 $H_0$。问题基于显著性水平 $\\alpha$ 来定义可复现性：如果计算出的 $p$ 值大于或等于 $\\alpha$，我们未能拒绝原假设，并宣布结果是可复现的。如果 $p$ 值小于 $\\alpha$，我们拒绝 $H_0$ 并宣布结果不可复现。\n\n算法设计直接遵循这些原则。实现一个函数，用于对给定的参数集 $(m, k, \\Delta t, p, b, T, N)$ 执行系综模拟。该函数将 $N$ 个系综成员的位置和速度初始化为 `numpy` 数组，然后迭代 $T$ 个时间步长，为了计算效率，将矢量化的更新方程一次性应用于整个系综。积分之后，它计算并返回一个最终能量的数组。程序的主体部分遍历指定的测试用例。对于每个用例，它为配置 $A$ 和 $B$ 调用模拟函数，获得两个能量系综，并将它们传递给 `scipy.stats.ks_2samp` 函数。将得到的 $p$ 值与给定的 $\\alpha$ 进行比较，并存储一个布尔结果（$True$ 表示可复现，$False$ 表示不可复现）。最后，收集所有的布尔结果并以指定的格式打印。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import stats\n\ndef solve():\n    \"\"\"\n    Solves the computational reproducibility case study by running simulations\n    for given test cases and performing a Kolmogorov-Smirnov test.\n    \"\"\"\n\n    def run_simulation(m: float, k: float, dt: float, p: int, b: float, T: int, N: int) -> np.ndarray:\n        \"\"\"\n        Runs a single ensemble simulation for a given configuration.\n\n        Args:\n            m: Mass parameter.\n            k: Stiffness parameter.\n            dt: Time step.\n            p: Decimal precision for rounding.\n            b: Bias term.\n            T: Number of time steps.\n            N: Number of ensemble members.\n\n        Returns:\n            An array of final energies for each ensemble member.\n        \"\"\"\n        # Initialize ensemble states (position x, velocity v)\n        # For N=1, linspace produces array([0.5]), not the center. Use [-0.5, 0.5]\n        # For N=1, linspace with 1 point on [-0.5, 0.5] gives [-0.5], but should be 0.\n        # Let's adjust to be robust for N=1. The problem specifies a symmetric interval.\n        if N > 1:\n            x = np.linspace(-0.5, 0.5, N)\n        else: # N=1 case, center of the interval is 0\n            x = np.array([0.0])\n            \n        v = np.zeros(N)\n\n        # Time integration loop\n        for _ in range(T):\n            # Position update step\n            x_new_unrounded = x + v * dt - 0.5 * (k / m) * x * (dt**2) + b * x * v\n            x_new = np.round(x_new_unrounded, p)\n\n            # Velocity update step, using the just-computed position x_new\n            v_new_unrounded = v - 0.5 * (k / m) * (x + x_new) * dt + b * x_new * v\n            v_new = np.round(v_new_unrounded, p)\n\n            # Update state vectors for the next iteration\n            x, v = x_new, v_new\n\n        # Calculate final energy for each ensemble member\n        energy = 0.5 * m * v**2 + 0.5 * k * x**2\n        return energy\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1 (happy path, identical configurations)\n        (\n            {'m': 1.0, 'k': 2.0, 'dt': 0.005, 'p': 12, 'b': 0.0, 'T': 100, 'N': 1000}, # Config A\n            {'m': 1.0, 'k': 2.0, 'dt': 0.005, 'p': 12, 'b': 0.0, 'T': 100, 'N': 1000}, # Config B\n            0.05  # alpha\n        ),\n        # Test case 2 (boundary condition, very small ensemble size)\n        (\n            {'m': 1.0, 'k': 2.0, 'dt': 0.005, 'p': 12, 'b': 0.0, 'T': 50, 'N': 8},\n            {'m': 1.0, 'k': 2.0, 'dt': 0.005, 'p': 12, 'b': 0.0, 'T': 50, 'N': 8},\n            0.05\n        ),\n        # Test case 3 (clear difference in mass parameter)\n        (\n            {'m': 1.0, 'k': 2.0, 'dt': 0.005, 'p': 12, 'b': 0.0, 'T': 100, 'N': 500},\n            {'m': 1.5, 'k': 2.0, 'dt': 0.005, 'p': 12, 'b': 0.0, 'T': 100, 'N': 500},\n            0.05\n        ),\n        # Test case 4 (multiple differences: step size, rounding precision, and bias)\n        (\n            {'m': 1.0, 'k': 2.0, 'dt': 0.005, 'p': 12, 'b': 0.0, 'T': 150, 'N': 1000},\n            {'m': 2.0, 'k': 2.0, 'dt': 0.02, 'p': 6, 'b': 1e-3, 'T': 150, 'N': 1000},\n            0.05\n        )\n    ]\n    # Correction in the logic for initial conditions as per my thinking process.\n    # The problem asks for values on [-X,X] where X=0.5.\n    # For N=8, linspace(-0.5, 0.5, 8) gives:\n    # [-0.5, -0.357, -0.214, -0.071, 0.071, 0.214, 0.357, 0.5]\n    # This is a correct deterministic sampling on the interval.\n    # The initial implementation is correct. My small fix for N=1 was an unnecessary micro-optimization, \n    # but harmless. Let's revert it for perfect adherence to the simple linspace logic.\n    def run_simulation_revised(m: float, k: float, dt: float, p: int, b: float, T: int, N: int) -> np.ndarray:\n        x = np.linspace(-0.5, 0.5, N)\n        v = np.zeros(N)\n        for _ in range(T):\n            x_new_unrounded = x + v * dt - 0.5 * (k / m) * x * (dt**2) + b * x * v\n            x_new = np.round(x_new_unrounded, p)\n            v_new_unrounded = v - 0.5 * (k / m) * (x + x_new) * dt + b * x_new * v\n            v_new = np.round(v_new_unrounded, p)\n            x, v = x_new, v_new\n        energy = 0.5 * m * v**2 + 0.5 * k * x**2\n        return energy\n\n\n    results = []\n    for config_A, config_B, alpha in test_cases:\n        # Generate energy ensembles for both configurations\n        energy_A = run_simulation_revised(**config_A)\n        energy_B = run_simulation_revised(**config_B)\n        \n        # Perform the two-sample Kolmogorov-Smirnov test\n        ks_result = stats.ks_2samp(energy_A, energy_B)\n        p_value = ks_result.pvalue\n        \n        # Determine reproducibility based on the p-value and significance level alpha\n        is_reproducible = p_value >= alpha\n        results.append(is_reproducible)\n\n    # Final print statement in the exact required format.\n    # Python's str(bool) gives 'True' or 'False' as required.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}