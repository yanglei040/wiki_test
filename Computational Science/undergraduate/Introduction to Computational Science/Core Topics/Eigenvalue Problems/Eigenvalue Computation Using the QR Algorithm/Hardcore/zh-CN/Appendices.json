{
    "hands_on_practices": [
        {
            "introduction": "从理论上讲，计算矩阵的特征值似乎可以简化为求解其特征多项式的根。然而，在有限精度的计算世界中，这种理论上直接的方法却因其固有的数值不稳定性而臭名昭著。本练习将引导你通过编程，直接对比 QR 算法和特征多项式求根法在计算精度上的巨大差异，从而亲身体验为何 QR 算法凭借其卓越的数值稳定性，成为计算科学领域的基石工具。",
            "id": "3121833",
            "problem": "您的任务是构建一个程序，用于比较计算小型实对称矩阵特征值的两种数值方法：正交三角（QR）算法和从特征多项式系数获得的根。目标是通过测量每种方法恢复一组已知基准特征值的接近程度，来量化这两种方法在小矩阵尺寸下的数值稳定性差异。\n\n从以下基础知识开始：\n- 方阵的特征值定义为满足 $\\det(\\lambda I - A) = 0$ 的 $\\lambda$ 值。\n- 一个 $n \\times n$ 矩阵 $A$ 的特征多项式是一个 $n$ 次的首一多项式，其根是 $A$ 的特征值。\n- 特征值在相似变换下是不变的；正交相似变换保留谱，并且在浮点运算中是数值良态的。\n- 对于一个实对称矩阵 $A \\in \\mathbb{R}^{n \\times n}$，使用正交分解的QR算法应用重复的正交相似变换，这些变换趋向于产生一个对角矩阵，其对角线元素收敛到特征值。\n\n您的程序必须以基于原理的方式实现以下步骤：\n1. 实现一个专门针对大小为 $n = 3$ 的实对称矩阵的QR迭代，而不调用任何内置的特征值求解器。给定一个实对称矩阵 $A$，执行形如 $A_{k} = Q_{k}^{\\top} A_{k-1} Q_{k}$ 的迭代，其中 $A_{k-1} = Q_{k} R_{k}$ 是第 $k$ 步的QR分解，直到 $A_{k}$ 的非对角弗罗贝尼乌斯范数小于一个容差。从结果矩阵的对角线元素中提取近似特征值。\n2. 构造同一矩阵 $A$ 的特征多项式，并数值计算其根。为此，从 $A$ 的不变量（对于 $n = 3$，这涉及 $A$ 的幂的迹与 $A$ 的行列式之间的代数关系）推导出三次特征多项式的系数，然后计算该多项式的根。\n3. 对于下面的每个测试用例，矩阵 $A$ 必须构造为 $A = Q \\operatorname{diag}(d) Q^{\\top}$，其中 $Q$ 是一个固定的正交矩阵，由两个确定的三维旋转复合而成，$\\operatorname{diag}(d)$ 是指定基准特征值的对角矩阵。正交矩阵 $Q$ 必须构造成 $Q = R_{z}(\\theta_{z}) R_{y}(\\theta_{y})$，其中 $R_{z}(\\theta_{z})$ 是绕 $z$ 轴旋转角度 $\\theta_{z}$ 的旋转，而 $R_{y}(\\theta_{y})$ 是绕 $y$ 轴旋转角度 $\\theta_{y}$ 的旋转。所有角度必须以弧度解释。\n\n定义计算出的特征值集合 $\\hat{\\lambda} \\in \\mathbb{C}^{3}$ 相对于基准特征值 $\\lambda \\in \\mathbb{R}^{3}$ 的相对误差为\n$$\n\\mathrm{relerr}(\\hat{\\lambda}, \\lambda) = \\frac{\\left\\| \\operatorname{sort}(\\hat{\\lambda}) - \\operatorname{sort}(\\lambda) \\right\\|_{2}}{\\left\\|\\lambda\\right\\|_{2}},\n$$\n其中排序是按实部升序进行的，范数是 $\\mathbb{C}^{3}$ 中的欧几里得范数。如果分母在数值上为零，您的实现必须通过添加一个微小的正数来防止除以零。对于特征多项式方法，允许数值计算产生复数近似值；在计算上述范数时，必须将这些复数包括在内。\n\n对于每个测试用例，计算比率的以10为底的对数\n$$\nr = \\log_{10}\\left(\\frac{\\mathrm{relerr}(\\hat{\\lambda}_{\\mathrm{poly}}, \\lambda)}{\\max\\left(\\mathrm{relerr}(\\hat{\\lambda}_{\\mathrm{QR}}, \\lambda), \\varepsilon\\right)}\\right),\n$$\n其中 $\\hat{\\lambda}_{\\mathrm{poly}}$ 是从特征多项式系数计算出的特征值，$\\hat{\\lambda}_{\\mathrm{QR}}$ 是通过QR迭代计算出的特征值，而 $\\varepsilon$ 是一个小的正保护值，例如 $\\varepsilon = 10^{-16}$。$r$ 的正值表示在该测试用例中，QR方法比多项式系数求根方法更准确，而负值则表示相反。\n\n使用以下参数值测试套件来构造矩阵。每个用例指定了基准特征值 $d = [d_{1}, d_{2}, d_{3}]$ 和旋转角度 $(\\theta_{z}, \\theta_{y})$（以弧度为单位）：\n- 用例 1（理想情况，良好缩放）：$d = [\\,1,\\,2,\\,3\\,]$，$\\theta_{z} = 0.3$，$\\theta_{y} = -0.5$。\n- 用例 2（接近重根）：$d = [\\,2,\\,2 + 10^{-10},\\,5\\,]$，$\\theta_{z} = 0.7$，$\\theta_{y} = -0.9$。\n- 用例 3（大动态范围）：$d = [\\,10^{-8},\\,1,\\,10^{8}\\,]$，$\\theta_{z} = 0.1$，$\\theta_{y} = 0.2$。\n- 用例 4（系数中的符号抵消）：$d = [\\,1000,\\,-1000,\\,10^{-12}\\,]$，$\\theta_{z} = 0.4$，$\\theta_{y} = -0.4$。\n- 用例 5（紧密聚集的特征值）：$d = [\\,3 - 10^{-12},\\,3,\\,3 + 10^{-12}\\,]$，$\\theta_{z} = 0.2$，$\\theta_{y} = 0.6$。\n\n您的程序应生成一行输出，其中包含按上述测试用例顺序排列的五个计算出的 $r$ 值，格式为方括号内以逗号分隔的列表，例如 $[r_{1},r_{2},r_{3},r_{4},r_{5}]$。不应打印任何其他文本。此计算不涉及任何物理单位。所有角度必须以弧度为单位，所有输出必须表示为浮点数。",
            "solution": "任务是定量比较计算 $3 \\times 3$ 实对称矩阵特征值的两种方法的数值稳定性：QR算法和求解特征多项式的根。该比较基于计算出的特征值相对于已知基准的相对误差。\n\n基本原理是，虽然数学问题可能有多个等价的解析解，但它们的计算实现在浮点运算环境下可能表现出截然不同的行为。此问题说明了数值稳定算法（如使用正交变换的QR迭代）相对于可能病态的方法（如从计算出的系数求解多项式根）的优越性。\n\n首先，我们建立一个可验证的基准。对于每个测试用例，构造一个实对称矩阵 $A$，使其具有一组预定义的特征值 $\\lambda = \\{d_1, d_2, d_3\\}$。这是通过相似变换 $A = Q D Q^\\top$ 实现的，其中 $D = \\operatorname{diag}(d_1, d_2, d_3)$ 是真实特征值的对角矩阵，$Q$ 是一个正交矩阵。选择正交变换 $Q$ 是因为它保留了 $D$ 的特征值。矩阵 $Q$ 是通过复合两个基本旋转矩阵构造的：一个绕 $z$ 轴旋转角度 $\\theta_z$ 的旋转 $R_z(\\theta_z)$，以及一个绕 $y$ 轴旋转角度 $\\theta_y$ 的旋转 $R_y(\\theta_y)$。得到的正交矩阵是 $Q = R_z(\\theta_z) R_y(\\theta_y)$。旋转矩阵的显式形式是：\n$$\nR_z(\\theta_z) = \\begin{pmatrix} \\cos\\theta_z  -\\sin\\theta_z  0 \\\\ \\sin\\theta_z  \\cos\\theta_z  0 \\\\ 0  0  1 \\end{pmatrix}, \\quad\nR_y(\\theta_y) = \\begin{pmatrix} \\cos\\theta_y  0  \\sin\\theta_y \\\\ 0  1  0 \\\\ -\\sin\\theta_y  0  \\cos\\theta_y \\end{pmatrix}.\n$$\n这种构造产生一个矩阵 $A$，其特征值保证为 $d$ 的元素，从而可以对数值方法进行精确的误差分析。\n\n第一种方法是基本的QR算法。从 $A_0 = A$ 开始，该算法通过迭代 $A_{k-1} = Q_k R_k$ 后跟 $A_k = R_k Q_k$ 生成一个矩阵序列 $\\{A_k\\}$，其中 $k=1, 2, \\dots$。这里，$Q_k$ 是一个正交矩阵，$R_k$ 是 $A_{k-1}$ 的上三角矩阵因子。每一步都是一个正交相似变换，$A_k = R_k Q_k = (Q_k^\\top A_{k-1}) Q_k = Q_k^\\top A_{k-1} Q_k$。这样的变换保留了原始矩阵 $A$ 的特征值。对于实对称矩阵，序列 $A_k$ 收敛到一个对角矩阵 $\\Lambda = \\operatorname{diag}(\\lambda_1, \\lambda_2, \\lambda_3)$。极限矩阵的对角线元素就是 $A$ 的特征值。此方法以其出色的数值稳定性而闻名。当矩阵 $A_k$ “足够对角化”时，迭代终止，这是通过其非对角元素的弗罗贝尼乌斯范数 $\\sqrt{\\sum_{i \\neq j} |(A_k)_{ij}|^2}$ 小于某个小容差（例如 $\\tau = 10^{-14}$）来衡量的。\n\n第二种方法涉及特征多项式。$A$ 的特征值是特征多项式 $p(\\lambda) = \\det(\\lambda I - A)$ 的根。对于一个 $3 \\times 3$ 矩阵 $A$，这是一个三次多项式，可以写成 $p(\\lambda) = \\lambda^3 + c_2 \\lambda^2 + c_1 \\lambda + c_0$。系数 $c_i$ 可以用矩阵不变量表示，特别是迹和行列式。使用 Faddeev–LeVerrier 算法（或牛顿和），系数由以下公式给出：\n$$\nc_2 = -\\mathrm{tr}(A)\n$$\n$$\nc_1 = \\frac{1}{2}\\left((\\mathrm{tr}(A))^2 - \\mathrm{tr}(A^2)\\right)\n$$\n$$\nc_0 = -\\det(A)\n$$\n一旦从矩阵 $A$ 计算出这些系数，就可以通过使用数值求根程序计算多项式 $\\lambda^3 + c_2 \\lambda^2 + c_1 \\lambda + c_0 = 0$ 的根来找到特征值 $\\hat{\\lambda}_{\\mathrm{poly}}$。这种方法虽然在数学上很直接，但通常数值不稳定。计算出的系数中的微小误差（由于计算迹和行列式时的浮点不精确性）可能导致根的巨大误差，这一现象由 Wilkinson 多项式著名地阐释了。\n\n为了比较这两种方法，我们计算每组计算出的特征值 $\\hat{\\lambda}_{\\mathrm{QR}}$ 和 $\\hat{\\lambda}_{\\mathrm{poly}}$ 相对于基准特征值 $\\lambda$ 的相对误差。误差定义为：\n$$\n\\mathrm{relerr}(\\hat{\\lambda}, \\lambda) = \\frac{\\left\\| \\operatorname{sort}(\\hat{\\lambda}) - \\operatorname{sort}(\\lambda) \\right\\|_{2}}{\\left\\|\\lambda\\right\\|_{2}}\n$$\n在这里，$\\operatorname{sort}(\\cdot)$ 按实部升序排列特征值，$\\|\\cdot\\|_2$ 是欧几里得范数。在分母上添加一个小的正常数以防止除以零，尽管测试用例确保了这不会成为问题。\n\n最后，两种方法的相对性能通过误差比的以10为底的对数来量化：\n$$\nr = \\log_{10}\\left(\\frac{\\mathrm{relerr}(\\hat{\\lambda}_{\\mathrm{poly}}, \\lambda)}{\\max\\left(\\mathrm{relerr}(\\hat{\\lambda}_{\\mathrm{QR}}, \\lambda), \\varepsilon\\right)}\\right)\n$$\n其中 $\\varepsilon = 10^{-16}$ 是一个小的正常数，用于避免在QR方法达到机器精度时除以零或除以一个极小的数。$r$ 的正值表示多项式方法的误差大于QR方法的误差，这表明对于给定的测试用例，QR算法更准确。程序将为五个指定的测试用例中的每一个计算这个值 $r$。",
            "answer": "```python\nimport numpy as np\n\ndef construct_matrix(d, theta_z, theta_y):\n    \"\"\"\n    Constructs a 3x3 real symmetric matrix A = Q D Q^T with known eigenvalues.\n\n    Args:\n        d (list or np.ndarray): The ground-truth eigenvalues.\n        theta_z (float): Rotation angle around the z-axis in radians.\n        theta_y (float): Rotation angle around the y-axis in radians.\n\n    Returns:\n        np.ndarray: The 3x3 symmetric matrix A.\n    \"\"\"\n    # Rotation matrix around z-axis\n    cz, sz = np.cos(theta_z), np.sin(theta_z)\n    Rz = np.array([\n        [cz, -sz, 0],\n        [sz, cz, 0],\n        [0, 0, 1]\n    ])\n\n    # Rotation matrix around y-axis\n    cy, sy = np.cos(theta_y), np.sin(theta_y)\n    Ry = np.array([\n        [cy, 0, sy],\n        [0, 1, 0],\n        [-sy, 0, cy]\n    ])\n\n    # Composite orthogonal matrix Q\n    Q = Rz @ Ry\n    # Diagonal matrix of eigenvalues\n    D = np.diag(d)\n\n    # Construct the symmetric matrix A\n    A = Q @ D @ Q.T\n    return A\n\ndef compute_eigs_qr(A, tol=1e-14, max_iter=1000):\n    \"\"\"\n    Computes eigenvalues of a symmetric matrix using the basic QR algorithm.\n\n    Args:\n        A (np.ndarray): The input 3x3 symmetric matrix.\n        tol (float): Tolerance for a off-diagonal norm to determine convergence.\n        max_iter (int): Maximum number of iterations.\n\n    Returns:\n        np.ndarray: The computed eigenvalues.\n    \"\"\"\n    Ak = A.copy()\n    for _ in range(max_iter):\n        # The Frobenius norm of the off-diagonal elements for a symmetric 3x3 matrix\n        off_diag_norm = np.sqrt(2 * (Ak[0, 1]**2 + Ak[0, 2]**2 + Ak[1, 2]**2))\n        if off_diag_norm = tol:\n            break\n        \n        # QR factorization and update step\n        Q, R = np.linalg.qr(Ak)\n        Ak = R @ Q\n        \n    return np.diag(Ak)\n\ndef compute_eigs_poly(A):\n    \"\"\"\n    Computes eigenvalues by finding roots of the characteristic polynomial.\n\n    Args:\n        A (npndarray): The input 3x3 matrix.\n\n    Returns:\n        np.ndarray: The computed eigenvalues (can be complex).\n    \"\"\"\n    tr_A = np.trace(A)\n    A_sq = A @ A\n    tr_A2 = np.trace(A_sq)\n    det_A = np.linalg.det(A)\n\n    # Coefficients for p(lambda) = lambda^3 + c2*lambda^2 + c1*lambda + c0 = 0\n    c2 = -tr_A\n    c1 = 0.5 * (tr_A**2 - tr_A2)\n    c0 = -det_A\n\n    coeffs = [1, c2, c1, c0]\n    return np.roots(coeffs)\n\ndef calculate_relative_error(lambda_hat, lambda_true, eps=1e-16):\n    \"\"\"\n    Calculates the relative error between computed and true eigenvalues.\n\n    Args:\n        lambda_hat (np.ndarray): Computed eigenvalues.\n        lambda_true (np.ndarray): Ground-truth eigenvalues.\n        eps (float): Small constant to safeguard against division by zero.\n\n    Returns:\n        float: The relative error.\n    \"\"\"\n    # Sort both eigenvalue sets. np.sort on complex arrays sorts by real part first.\n    sorted_lambda_hat = np.sort(lambda_hat)\n    sorted_lambda_true = np.sort(lambda_true)\n\n    numerator = np.linalg.norm(sorted_lambda_hat - sorted_lambda_true)\n    denominator = np.linalg.norm(sorted_lambda_true)\n    \n    # Safeguard against division by zero or a numerically zero value\n    return numerator / max(denominator, eps)\n\ndef solve():\n    \"\"\"\n    Main function to run the comparison for all test cases.\n    \"\"\"\n    test_cases = [\n        {'d': [1., 2., 3.], 'theta_z': 0.3, 'theta_y': -0.5},\n        {'d': [2., 2. + 1e-10, 5.], 'theta_z': 0.7, 'theta_y': -0.9},\n        {'d': [1e-8, 1., 1e8], 'theta_z': 0.1, 'theta_y': 0.2},\n        {'d': [1000., -1000., 1e-12], 'theta_z': 0.4, 'theta_y': -0.4},\n        {'d': [3. - 1e-12, 3., 3. + 1e-12], 'theta_z': 0.2, 'theta_y': 0.6},\n    ]\n\n    results = []\n    comparison_epsilon = 1e-16\n\n    for case in test_cases:\n        d_true = np.array(case['d'])\n        A = construct_matrix(d_true, case['theta_z'], case['theta_y'])\n        \n        # Compute eigenvalues using both methods\n        lambda_qr = compute_eigs_qr(A)\n        lambda_poly = compute_eigs_poly(A)\n        \n        # Calculate relative errors\n        relerr_qr = calculate_relative_error(lambda_qr, d_true)\n        relerr_poly = calculate_relative_error(lambda_poly, d_true)\n        \n        # Compute the log-ratio of errors\n        r = np.log10(relerr_poly / max(relerr_qr, comparison_epsilon))\n        results.append(r)\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在确立了 QR 算法的稳定性优势之后，我们的关注点自然转向其执行效率。本实践将深入探讨 QR 算法的收敛速度，揭示其收敛性如何依赖于矩阵特征值的分布情况，特别是特征值之间的间隔。你将亲手实现一种强大的加速策略——威尔金森位移（Wilkinson shift），并量化分析其对算法性能的提升，从而理解是什么让 QR 算法不仅稳定，而且在实际应用中异常高效。",
            "id": "3121818",
            "problem": "要求您通过计算来研究，当正交三角 (QR) 算法应用于实对称矩阵时，特征值的分离度如何影响其收敛速度。您的研究必须纯粹从数学和算法的角度进行，其结果必须是一个完整的、可运行的程序，该程序能输出在一小组矩阵测试套件上达到收敛所需的 QR 迭代次数。您的程序必须实现带 Wilkinson 位移的经典 QR 算法，使用正交相似变换，并在非对角 Frobenius 范数低于指定容差时终止。\n\n本任务的理论基础：\n- 正交相似变换保持特征值不变：若 $Q$ 是正交矩阵 (即 $Q^{\\mathsf{T}} Q = I$)，则 $Q^{\\mathsf{T}} A Q$ 与 $A$ 具有相同的谱。\n- 正交三角 (QR) 分解可将任意方阵 $M$ 分解为 $M = Q R$，其中 $Q$ 为正交矩阵，$R$ 为上三角矩阵。\n- 对于实对称矩阵，采用适当位移的 QR 算法会收敛到一个对角矩阵，其对角元即为特征值。\n\n您的实现要求：\n- 通过对含指定特征值的对角矩阵进行正交相似变换来构造每个测试矩阵 $A \\in \\mathbb{R}^{n \\times n}$，即 $A = Q^{\\mathsf{T}} \\operatorname{diag}(\\lambda_1,\\dots,\\lambda_n) Q$，其中 $Q$ 为正交矩阵。\n- 使用带 Wilkinson 位移的 QR 迭代。在每次迭代 $k$ 中，给定当前迭代矩阵 $A_k$，通过实数 Wilkinson 位移从 $A_k$ 的尾部 $2 \\times 2$ 主子矩阵构造位移 $\\mu_k$，然后计算 $A_k - \\mu_k I$ 的正交三角分解，即 $(A_k - \\mu_k I) = Q_k R_k$，并令 $A_{k+1} = R_k Q_k + \\mu_k I$。为控制舍入漂移，在每一步通过将 $A_{k+1}$ 显式对称化为 $(A_{k+1} + A_{k+1}^{\\mathsf{T}})/2$ 来保持对称性。\n- 使用非对角 Frobenius 范数作为停止准则。定义严格下三角部分 $L_k = \\operatorname{tril}(A_k,-1)$，并在 $\\|L_k\\|_{\\mathrm{F}} \\le \\varepsilon$ 时停止，容差 $\\varepsilon = 10^{-10}$。为避免在极端情况下出现无限循环，设置最大迭代次数 $N_{\\max} = 5000$，若达到此上限则停止。\n- 所有计算都是无量纲的；不涉及物理单位。\n\n测试套件规范：\n- 维度：所有情况下均为 $n = 6$。\n- 对于每种情况，构造 $A = Q^{\\mathsf{T}} \\operatorname{diag}(\\lambda_1,\\dots,\\lambda_6) Q$，其中除特殊说明外，$Q$ 是通过对一个由指定整数作为种子的实数高斯随机矩阵进行正交三角分解而生成的。每种情况使用独立的种子以确保可复现性。具体如下：\n  1. 情况 $\\mathrm{C1}$ (中等聚集的特征值，“理想情况”)：$\\lambda = [\\,1.0,\\,1.01,\\,1.02,\\,3.0,\\,5.0,\\,8.0\\,]$，种子为 $0$。\n  2. 情况 $\\mathrm{C2}$ (分离良好的特征值)：$\\lambda = [\\,1.0,\\,2.0,\\,4.0,\\,8.0,\\,16.0,\\,32.0\\,]$，种子为 $1$。\n  3. 情况 $\\mathrm{C3}$ (紧密聚集的子集)：$\\lambda = [\\,1.0,\\,1.0001,\\,1.0002,\\,2.0,\\,3.0,\\,4.0\\,]$，种子为 $2$。\n  4. 情况 $\\mathrm{C4}$ (已为对角矩阵的边界情况)：$A = \\operatorname{diag}(1.0,\\,2.0,\\,2.0,\\,3.0,\\,5.0,\\,8.0)$，即使用 $Q = I$，不应用相似变换。\n  5. 情况 $\\mathrm{C5}$ (带有混合的重复特征值)：$\\lambda = [\\,2.0,\\,2.0,\\,2.0,\\,3.0,\\,4.0,\\,5.0\\,]$，种子为 $3$。\n\n计算内容：\n- 对每种情况，运行带位移的 QR 迭代，直到满足停止准则或达到最大迭代次数，并记录所用的整数迭代次数 $k$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含五个迭代次数，按 $\\mathrm{C1}$ 到 $\\mathrm{C5}$ 的顺序排列，形式为方括号内以逗号分隔的列表，例如 $[k_1,k_2,k_3,k_4,k_5]$，其中每个 $k_i$ 都是整数。\n\n注：\n- 使用双精度浮点运算 (指定库中的默认设置)。\n- 不涉及角度；无需角度单位。\n- 不涉及百分比；任何地方都不要使用百分号。",
            "solution": "用户提供的问题是有效的。它在科学上是合理的、适定的、客观的，并包含了构建唯一可计算解所需的所有信息。任务是实现用于实对称矩阵的带位移的 QR 算法，以研究特征值分离度对收敛速度的影响。\n\n解是基于以下原理和算法步骤构建的。\n\n**1. 通过正交相似变换构造矩阵**\nQR 算法的基础是正交相似变换保持特征值不变。为创建具有预定义谱 $\\lambda = \\{\\lambda_1, \\dots, \\lambda_n\\}$ 的测试矩阵，我们构造一个矩阵 $A$ 如下：\n$$\nA = Q^{\\mathsf{T}} D Q\n$$\n其中 $D = \\operatorname{diag}(\\lambda_1, \\dots, \\lambda_n)$ 是特征值构成的对角矩阵，$Q$ 是一个正交矩阵 (即 $Q^{\\mathsf{T}} Q = I$，其中 $I$ 是单位矩阵)。这种构造确保了 $A$ 是对称的，并具有指定的特征值。为在保持非平凡结构的同时确保可复现性，矩阵 $Q$ 由一个随机矩阵 $M$ 的 QR 分解生成 (即 $M=QR$)，并且每个测试用例的随机数生成器都使用固定的种子。\n\n**2. 带位移的 QR 迭代**\nQR 算法通过迭代计算一个矩阵序列 $\\{A_k\\}_{k=0}^\\infty$，该序列收敛到一个对角矩阵。从 $A_0 = A$ 开始，每次迭代执行一个“带位移的 QR 步”：\n1.  选择一个位移 $\\mu_k$。\n2.  计算位移后矩阵的 QR 分解：$A_k - \\mu_k I = Q_k R_k$。\n3.  形成下一个迭代矩阵：$A_{k+1} = R_k Q_k + \\mu_k I$。\n\n这个过程构成了一个正交相似变换，因为 $A_{k+1} = Q_k^{\\mathsf{T}}(A_k - \\mu_k I)Q_k + \\mu_k I = Q_k^{\\mathsf{T}}A_k Q_k$。因此，每个 $A_k$ 都是对称的，并与原始矩阵 $A$ 共享相同的特征值。\n\n**3. 用于加速收敛的 Wilkinson 位移**\n位移 $\\mu_k$ 的选择对收敛速度至关重要。问题指定了 **Wilkinson 位移**，已知该位移可为对称矩阵提供渐进三次收敛。对于每个迭代矩阵 $A_k$，位移从其尾部的 $2 \\times 2$ 主子矩阵导出：\n$$\nT_k = \\begin{pmatrix} a_{n-1,n-1}^{(k)}  a_{n-1,n}^{(k)} \\\\ a_{n,n-1}^{(k)}  a_{n,n}^{(k)} \\end{pmatrix}\n$$\n由于 $A_k$ 是对称的，所以 $a_{n-1,n}^{(k)} = a_{n,n-1}^{(k)}$。Wilkinson 位移 $\\mu_k$ 是 $T_k$ 的那个更接近元素 $a_{n,n}^{(k)}$ 的特征值。令 $a = a_{n-1,n-1}^{(k)}$，$b = a_{n,n}^{(k)}$，$c = a_{n-1,n}^{(k)}$。该位移可以使用一个避免相消误差的数值稳定公式来计算：\n$$\n\\mu_k = b - \\frac{\\operatorname{sgn}(\\delta) c^2}{|\\delta| + \\sqrt{\\delta^2 + c^2}}\n$$\n其中 $\\delta = (a-b)/2$，且 $\\operatorname{sgn}(\\delta)$ 定义为：如果 $\\delta \\ge 0$ 则为 $1$，如果 $\\delta  0$ 则为 $-1$。如果非对角元素 $c$ 为零，则位移就是 $b$。\n\n**4. 为保证数值稳定性的对称化**\n在浮点运算中，$A_k$ 的对称性可能由于舍入误差而逐渐丧失。为了抵消这种影响，每次迭代后，矩阵 $A_{k+1}$ 都会被显式地重新对称化：\n$$\nA_{k+1} \\leftarrow \\frac{A_{k+1} + A_{k+1}^{\\mathsf{T}}}{2}\n$$\n\n**5. 收敛准则**\n当迭代矩阵 $A_k$ 足够接近对角矩阵时，算法终止。这通过测量非对角元素的大小来量化。指定的停止准则是基于 $A_k$ 的严格下三角部分（记为 $L_k = \\operatorname{tril}(A_k, -1)$）的 Frobenius 范数。当满足以下条件时迭代停止：\n$$\n\\|L_k\\|_{\\mathrm{F}} \\le \\varepsilon\n$$\n其中 Frobenius 范数为 $\\|M\\|_{\\mathrm{F}} = \\sqrt{\\sum_{i,j} |m_{ij}|^2}$，容差为 $\\varepsilon = 10^{-10}$。同时强制设定了 $N_{\\max} = 5000$ 的最大迭代次数限制，以防止无限执行。每个测试用例的计算结果是满足此准则所需的总迭代次数 $k$。",
            "answer": "```python\n# The complete and runnable Python 3 code that implements the shifted QR algorithm.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function to run the QR algorithm on a test suite of matrices\n    and report the number of iterations for convergence.\n    \"\"\"\n    \n    # Define problem constants\n    TOLERANCE = 1e-10\n    MAX_ITERATIONS = 5000\n    MATRIX_DIMENSION = 6\n\n    def create_matrix(eigenvalues, seed):\n        \"\"\"\n        Constructs a test matrix A = Q^T D Q for a given list of eigenvalues.\n        If the seed is None, it returns the diagonal matrix D itself.\n        \n        Args:\n            eigenvalues (list): A list of floats for the diagonal of D.\n            seed (int or None): The seed for the random number generator.\n\n        Returns:\n            np.ndarray: The constructed n x n symmetric matrix.\n        \"\"\"\n        n = len(eigenvalues)\n        D = np.diag(eigenvalues)\n\n        if seed is None:\n            # Handle Case C4, which is an already diagonal matrix.\n            return D\n\n        # Use a seeded random number generator for reproducible results.\n        rng = np.random.default_rng(seed)\n        \n        # Generate a random matrix M to derive an orthogonal matrix Q.\n        M = rng.standard_normal(size=(n, n))\n        \n        # The orthogonal matrix Q from the QR factorization of M.\n        Q, _ = np.linalg.qr(M)\n\n        # Construct the symmetric matrix A = Q^T D Q via similarity transform.\n        A = Q.T @ D @ Q\n        return A\n\n    def wilkinson_shift(A):\n        \"\"\"\n        Calculates the Wilkinson shift from the trailing 2x2 submatrix of A.\n        Uses a numerically stable formula and handles edge cases.\n\n        Args:\n            A (np.ndarray): The current symmetric matrix iterate.\n\n        Returns:\n            float: The Wilkinson shift value.\n        \"\"\"\n        # Get the trailing 2x2 submatrix elements.\n        a = A[-2, -2]\n        c = A[-2, -1] \n        b = A[-1, -1]\n\n        # If the off-diagonal element is close to zero, the trailing block is\n        # already diagonal. The eigenvalue is b, so that's the shift.\n        if np.isclose(c, 0.0):\n            return b\n\n        delta = (a - b) / 2.0\n        \n        # Define sgn(0) as 1 for the formula, consistent with the solution text.\n        sign_delta = 1.0 if delta >= 0.0 else -1.0\n        \n        # Numerically stable formula for the eigenvalue of the 2x2 matrix\n        # that is closer to b. This avoids subtractive cancellation and 0/0.\n        shift = b - sign_delta * c**2 / (abs(delta) + np.sqrt(delta**2 + c**2))\n        \n        return shift\n\n    def shifted_qr_iteration(A_init, tol, max_iter):\n        \"\"\"\n        Performs the shifted QR algorithm with Wilkinson shift on a symmetric matrix.\n\n        Args:\n            A_init (np.ndarray): The initial symmetric matrix.\n            tol (float): The convergence tolerance for the off-diagonal norm.\n            max_iter (int): The maximum number of iterations allowed.\n\n        Returns:\n            int: The number of iterations until convergence or max_iter.\n        \"\"\"\n        A_k = np.copy(A_init)\n        n = A_k.shape[0]\n        \n        for k in range(max_iter):\n            # 1. Stopping Criterion: Check the Frobenius norm of the off-diagonal part.\n            # For a symmetric matrix, the norm of the strict lower triangle suffices.\n            off_diagonal_norm = np.linalg.norm(np.tril(A_k, -1), 'fro')\n            \n            if off_diagonal_norm = tol:\n                return k\n            \n            # 2. Shift Calculation: Compute the Wilkinson shift.\n            mu_k = wilkinson_shift(A_k)\n            \n            # 3. QR Factorization: Decompose the shifted matrix.\n            I = np.identity(n)\n            Q_k, R_k = np.linalg.qr(A_k - mu_k * I)\n            \n            # 4. Matrix Update: Form the next iterate.\n            A_k = R_k @ Q_k + mu_k * I\n            \n            # 5. Symmetrization: Enforce symmetry to mitigate floating-point error.\n            A_k = (A_k + A_k.T) / 2.0\n            \n        return max_iter\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # C1 (moderately clustered)\n        {'eigenvalues': [1.0, 1.01, 1.02, 3.0, 5.0, 8.0], 'seed': 0},\n        # C2 (well-separated)\n        {'eigenvalues': [1.0, 2.0, 4.0, 8.0, 16.0, 32.0], 'seed': 1},\n        # C3 (tightly clustered subset)\n        {'eigenvalues': [1.0, 1.0001, 1.0002, 2.0, 3.0, 4.0], 'seed': 2},\n        # C4 (already diagonal)\n        {'eigenvalues': [1.0, 2.0, 2.0, 3.0, 5.0, 8.0], 'seed': None},\n        # C5 (repeated eigenvalues)\n        {'eigenvalues': [2.0, 2.0, 2.0, 3.0, 4.0, 5.0], 'seed': 3}\n    ]\n    \n    results = []\n    # Process each case and collect the iteration count.\n    for case in test_cases:\n        A = create_matrix(case['eigenvalues'], case['seed'])\n        \n        # Ensure the matrix dimension matches the problem spec.\n        if A.shape[0] != MATRIX_DIMENSION:\n            raise ValueError(f\"Matrix dimension mismatch for a test case.\")\n            \n        iterations = shifted_qr_iteration(A, tol=TOLERANCE, max_iter=MAX_ITERATIONS)\n        results.append(iterations)\n        \n    # Print the final results in the specified single-line format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "许多现实世界系统，从机械振动到生态种群动态，都由具有复数特征值的矩阵来描述，这些复数特征值通常代表着振荡或旋转行为。本练习将我们的研究从对称矩阵推广到一般实数矩阵，并展示 QR 算法如何通过生成实舒尔型（real Schur form）来优雅地处理这种情况。你将学会如何识别并解释对角线上的 $2 \\times 2$ 子块，将其与旋转-缩放的物理行为联系起来，从而将抽象的数值计算结果与具体的物理现象建立关联。",
            "id": "3121844",
            "problem": "编写一个完整的程序，对于每个给定的实方阵，使用基本的带位移 QR 迭代计算实 Schur 型，并利用得到的准上三角结构来识别任何复共轭特征对。对于每个识别出的复共轭特征对，将对应的 $2\\times 2$ Schur 块解释为平面上的旋转-缩放作用，并提取旋转-缩放参数。具体来说，如果一个实 Schur 块具有以下形式\n$$\n\\begin{bmatrix}\na  b\\\\\nc  d\n\\end{bmatrix},\n$$\n且其判别式为负\n$$\n\\Delta = (a+d)^2 - 4(ad-bc)  0,\n$$\n那么特征值为 $u \\pm i v$，其中\n$$\nu = \\frac{a+d}{2},\\quad v = \\frac{\\sqrt{-\\Delta}}{2}.\n$$\n将此特征对与旋转-缩放参数关联起来\n$$\n\\rho = \\sqrt{u^2 + v^2},\\quad \\theta = \\operatorname{atan2}(v, u),\n$$\n其中 $\\theta$ 是以弧度为单位的旋转角，$\\rho$ 是缩放因子（模长）。您的程序应为每个矩阵返回检测到的复共轭特征对的数量以及这些特征对的 $(\\rho,\\theta)$ 值序列。\n\n您必须基于以下基本原理设计算法：\n\n- 特征值和特征向量的定义：如果存在非零向量 $x$ 使得 $A x = \\lambda x$ 成立，则标量 $\\lambda$ 是矩阵 $A$ 的一个特征值。\n- QR 分解的定义：对于一个满秩方阵 $M$，存在一个正交矩阵 $Q$ 和一个上三角矩阵 $R$，使得 $M = Q R$。\n- 实 Schur 定理：每个实方阵 $A$ 都正交相似于一个准上三角矩阵 $T$（实 Schur 型），其对角线由 $1\\times 1$ 块（实特征值）和编码复共轭特征对的 $2\\times 2$ 块组成。\n\n按如下方式实现一个基本的带位移 QR 迭代：将 $A$ 约化为上 Hessenberg 型，然后使用从当前末尾对角元素获取的实位移 $\\mu$ 反复应用带位移的 QR 步骤 $M \\mapsto RQ + \\mu I$，并在适当时使用一个小的紧缩容差将次对角线元素置零。迭代直到观察到准上三角形式。然后扫描实 Schur 型以识别 $2\\times 2$ 块，并通过上述方程将每个具有负判别式的此类块转换为 $(\\rho,\\theta)$。\n\n角度单位要求：所有角度 $\\theta$ 以弧度报告。数值输出要求：每个 $\\rho$ 和 $\\theta$ 报告时四舍五入到 $6$ 位小数。\n\n测试套件。将您的程序应用于以下矩阵。请严格使用这些定义：\n- 情况 1（$2\\times 2$ 纯旋转-缩放）。令 $\\rho_1 = 1.25$ 和 $\\theta_1 = 0.7$。定义\n$$\nA_1 = \\rho_1 \\begin{bmatrix}\n\\cos(\\theta_1)  -\\sin(\\theta_1)\\\\\n\\sin(\\theta_1)  \\cos(\\theta_1)\n\\end{bmatrix}.\n$$\n- 情况 2（$4\\times 4$ 块对角矩阵，含一对复共轭特征值和两个实特征值）。令 $\\rho_2 = 1.1$ 和 $\\theta_2 = 1.0$。定义\n$$\nB_2 = \\rho_2 \\begin{bmatrix}\n\\cos(\\theta_2)  -\\sin(\\theta_2)\\\\\n\\sin(\\theta_2)  \\cos(\\theta_2)\n\\end{bmatrix},\\quad\nA_2 = \\operatorname{diag}\\!\\left(B_2,\\;2.0,\\;0.5\\right).\n$$\n- 情况 3（$3\\times 3$ 对称三对角矩阵，仅有实特征值）。定义\n$$\nA_3 = \\begin{bmatrix}\n2  -1  0\\\\\n-1  2  -1\\\\\n0  -1  2\n\\end{bmatrix}.\n$$\n- 情况 4（$3\\times 3$ 矩阵，相似于一个含一对复共轭特征值和一个实特征值的块对角矩阵）。令 $\\rho_4 = 0.9$ 和 $\\theta_4 = 1.2$，且\n$$\nB_4 = \\rho_4 \\begin{bmatrix}\n\\cos(\\theta_4)  -\\sin(\\theta_4)\\\\\n\\sin(\\theta_4)  \\cos(\\theta_4)\n\\end{bmatrix},\\quad\nD_4 = \\operatorname{diag}(B_4,\\,-1.0).\n$$\n令\n$$\nS = \\begin{bmatrix}\n1  2  0\\\\\n0  1  1\\\\\n1  0  1\n\\end{bmatrix},\\quad\nA_4 = S D_4 S^{-1}.\n$$\n\n最终输出格式。您的程序应生成单行输出，其中包含一个按顺序排列的各情况结果列表。每个情况的结果本身必须是一个列表，其第一个条目是检测到的复共轭特征对的整数数量，其后是按从左上到右下扫描 Schur 型时遇到的顺序排列的这些特征对的 $\\rho,\\theta$ 值的扁平化序列（四舍五入到 $6$ 位小数）。例如，一个包含两种情况的有效输出可能如下所示\n`[ [1, rho_1, theta_1], [0] ]`。\n您的程序必须且仅能输出这样一行，不含任何额外文本。",
            "solution": "用户提供的问题经评估有效。它科学上严谨、问题定义清晰且客观，满足可解问题的所有标准。它要求实现一个计算科学中的标准数值算法，并提供了明确的规范、测试用例和输出要求。\n\n核心任务是计算给定实方阵 $A$ 的实 Schur 型，并从中识别复共轭特征对及其相关的旋转-缩放参数。需要实现的算法是带位移的 QR 迭代。\n\n该过程可分为三个主要阶段：\n$1$. 将矩阵 $A$ 约化为上 Hessenberg 型。\n$2$. 对 Hessenberg 矩阵应用迭代的带位移 QR 算法，以收敛到实 Schur 型 $T$。\n$3$. 分析得到的准上三角矩阵 $T$ 以提取所需参数。\n\n**1. 理论基础：实 Schur 分解**\n\n实 Schur 定理指出，对于任何实 $n \\times n$ 矩阵 $A$，存在一个正交矩阵 $Q$ ($Q^T Q = Q Q^T = I$) 使得：\n$$\nT = Q^T A Q\n$$\n其中 $T$ 是一个实准上三角矩阵。这意味着 $T$ 是块上三角矩阵，其对角块的大小为 $1 \\times 1$ 或 $2 \\times 2$。\n- $T$ 对角线上的一个 $1 \\times 1$ 块是 $A$ 的一个实特征值。\n- $T$ 对角线上的一个形如 $\\begin{bmatrix} a  b \\\\ c  d \\end{bmatrix}$ 的 $2 \\times 2$ 块，具有两个复共轭特征值，它们也是 $A$ 的特征值。\n\nQR 算法是计算此 Schur 型 $T$ 的一种迭代方法。\n\n**2. 阶段 1：约化为上 Hessenberg 型**\n\nQR 迭代的计算成本很高。如果首先将矩阵变换为上 Hessenberg 型，则每次迭代的成本可以显著降低。一个上 Hessenberg 矩阵 $H$ 在其第一条次对角线下方具有零元素，即对于所有 $i > j+1$，$h_{ij} = 0$。\n\n这种约化通过一系列正交相似变换在有限步内（对于一个 $n \\times n$ 矩阵需要 $n-2$ 步）完成。通常使用 Householder 反射变换。对于从 $0$ 到 $n-3$ 的每一列 $k$，构造一个 Householder 变换 $P_k$ 以将元素 $a_{k+2, k}, \\dots, a_{n-1, k}$ 置零。该变换作为相似变换应用以保持特征值不变：\n$$\nA \\rightarrow P_0 A P_0^T \\rightarrow P_1 (P_0 A P_0^T) P_1^T \\rightarrow \\dots\n$$\n这些变换的乘积保留了先前步骤中创建的上 Hessenberg 结构。最终的矩阵 $H$ 与 $A$ 相似，并且 QR 迭代将保持其 Hessenberg 结构，从而将每个 QR 分解步骤的成本从 $O(n^3)$ 降低到 $O(n^2)$。对于本实现，我们将使用一个专用的库函数 `scipy.linalg.hessenberg`，它执行此标准过程。\n\n**3. 阶段 2：带位移的 QR 迭代**\n\n从 Hessenberg 矩阵 $T_0 = H$ 开始，该算法生成一个收敛到实 Schur 型 $T$ 的矩阵序列 $T_k$。基本的带位移 QR 算法的单步如下：\n$1$. 选择一个位移 $\\mu_k \\in \\mathbb{R}$。问题指定使用当前活动子矩阵的末尾对角元素：$\\mu_k = (T_k)_{m,m}$。\n$2$. 对位移后的矩阵进行 QR 分解：$T_k - \\mu_k I = Q_k R_k$。这里，$Q_k$ 是正交矩阵，$R_k$ 是上三角矩阵。\n$3$. 以相反的顺序重组并加回位移：$T_{k+1} = R_k Q_k + \\mu_k I$。\n\n这种构造确保 $T_{k+1}$ 与 $T_k$ 正交相似：\n$$\nT_{k+1} = R_k Q_k + \\mu_k I = (Q_k^T (T_k - \\mu_k I)) Q_k + \\mu_k I = Q_k^T T_k Q_k - \\mu_k Q_k^T I Q_k + \\mu_k I = Q_k^T T_k Q_k\n$$\n这个迭代过程使得次对角线元素收敛到零。位移 $\\mu_k$ 对于加速收敛至关重要。\n\n**紧缩 (Deflation)：** 为了实际效率，当一个次对角线元素 $(T_k)_{j+1, j}$ 变得可以忽略不计时，它被设置为 $0$。这有效地将问题分裂或“紧缩”成两个更小的独立子问题。然后算法可以专注于剩余的未约化子矩阵。这是算法终止的机制：矩阵被相继紧缩为 $1 \\times 1$ 和 $2 \\times 2$ 的块，直到整个矩阵都呈准上三角形式。一个典型的紧缩条件是 $|(T_k)_{j+1, j}|  \\epsilon (|(T_k)_{j,j}| + |(T_k)_{j+1, j+1}|)$，其中 $\\epsilon$ 是一个小的容差（例如，$10^{-12}$）。\n\n如果对于一个实根的迭代没有快速收敛，这可能表明存在一个复共轭对。在这种情况下，检查末尾的 $2 \\times 2$ 子矩阵。如果其特征值是复数，则认为该块已收敛，并将问题紧缩两行/两列。\n\n**4. 阶段 3：提取旋转-缩放参数**\n\n一旦算法收敛到 Schur 型 $T$，我们扫描其对角线。\n$1$. 我们从 $i=0$ 到 $n-1$ 遍历对角元素。\n$2$. 如果一个次对角线元素 $T_{i+1, i}$ 非零（即未被紧缩），我们就找到了一个 $2 \\times 2$ 块：\n$$\nS = \\begin{bmatrix} a  b \\\\ c  d \\end{bmatrix} = \\begin{bmatrix} T_{i,i}  T_{i,i+1} \\\\ T_{i+1,i}  T_{i+1,i+1} \\end{bmatrix}\n$$\n$3$. 我们计算该块特征多项式的判别式：$\\Delta = (a+d)^2 - 4(ad-bc)$。\n$4$. 如果 $\\Delta  0$，则特征值为一对复共轭数 $u \\pm iv$。其实部和虚部由下式给出：\n$$\nu = \\frac{a+d}{2}, \\quad v = \\frac{\\sqrt{-\\Delta}}{2}\n$$\n$5$. 这些特征值对应于一个二维子空间中的旋转-缩放作用。缩放因子 $\\rho$（特征值的模）和旋转角 $\\theta$（幅角）通过将复数 $u+iv$ 转换为极坐标来找到：\n$$\n\\rho = |u+iv| = \\sqrt{u^2 + v^2}\n$$\n$$\n\\theta = \\arg(u+iv) = \\operatorname{atan2}(v, u)\n$$\n$6$. 记录下这对 $(\\rho, \\theta)$，并将迭代索引 $i$ 增加一以跳过下一个对角元素，因为它已作为块的一部分被处理。如果 $T_{i+1,i}$ 为零，我们得到一个 $1 \\times 1$ 块（一个实特征值），根据问题要求将其忽略。\n最后，对于每个输入矩阵，我们报告找到的复数对的总数以及对应的 $(\\rho, \\theta)$ 值列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import hessenberg\n\ndef compute_schur_and_params(A):\n    \"\"\"\n    Computes the real Schur form of A using a shifted QR algorithm\n    and extracts rotation-scaling parameters from 2x2 blocks.\n    \"\"\"\n    T = hessenberg(A)\n    n = T.shape[0]\n    tol = 1e-12\n    \n    m = n  # m is the size of the active submatrix, from bottom-right.\n    while m > 0:\n        if m == 1:\n            break\n\n        # Use a fixed number of iterations per eigenvalue/eigenpair.\n        # If it doesn't converge, try to deflate a 2x2 block.\n        iters_since_deflation = 0\n        max_iters_per_eig = 50\n        \n        while iters_since_deflation  max_iters_per_eig:\n            # Check for deflation at the bottom of the active submatrix\n            if abs(T[m-1, m-2]) = tol * (abs(T[m-2, m-2]) + abs(T[m-1, m-1])):\n                T[m-1, m-2] = 0.0\n                m -= 1\n                break  # Deflated a 1x1 block\n            \n            # Simple shift from the trailing entry\n            shift = T[m-1, m-1]\n            \n            # QR step on the current submatrix T[:m, :m]\n            sub_T = T[:m, :m]\n            \n            try:\n                Q, R = np.linalg.qr(sub_T - shift * np.eye(m))\n            except np.linalg.LinAlgError:\n                # In case of a singular matrix during factorization, perturb shift\n                shift += tol\n                Q, R = np.linalg.qr(sub_T - shift * np.eye(m))\n\n            T[:m, :m] = R @ Q + shift * np.eye(m)\n            iters_since_deflation += 1\n        else:\n            # Iteration limit reached without convergence of a single real root.\n            # This suggests a 2x2 block at the bottom.\n            # We check if the eigenvalues of the bottom 2x2 block are complex.\n            sub_block = T[m-2:m, m-2:m]\n            a, b = sub_block[0, 0], sub_block[0, 1]\n            c, d = sub_block[1, 0], sub_block[1, 1]\n            \n            trace = a + d\n            det = a * d - b * c\n            discriminant = trace**2 - 4 * det\n            \n            if discriminant  0:\n                # Complex conjugate pair detected, deflate this 2x2 block\n                m -= 2\n            else:\n                # Failed to converge for a real root. This can happen with a simple shift strategy.\n                # For this problem, we simply force deflation as a fallback.\n                T[m-1, m-2] = 0.0\n                m -= 1\n\n    # Final pass to zero out any remaining tiny subdiagonal elements\n    for i in range(n - 1):\n        if abs(T[i+1, i]) = tol:\n            T[i+1, i] = 0.0\n\n    # --- Extract parameters from the Schur form T ---\n    params = []\n    i = 0\n    while i  n:\n        if i == n - 1:\n            # Last element, must be a 1x1 block\n            i += 1\n            continue\n\n        if abs(T[i+1, i]) > tol:\n            # 2x2 block found\n            block = T[i:i+2, i:i+2]\n            a, b = block[0, 0], block[0, 1]\n            c, d = block[1, 0], block[1, 1]\n            \n            trace = a + d\n            det = a * d - b * c\n            discriminant = trace**2 - 4 * det\n\n            if discriminant  0:\n                u = trace / 2.0\n                v = np.sqrt(-discriminant) / 2.0\n                rho = np.sqrt(u**2 + v**2)\n                theta = np.arctan2(v, u)\n                params.extend([rho, theta])\n            \n            i += 2  # Skip the next element as it's part of the block\n        else:\n            # 1x1 block\n            i += 1\n    \n    num_pairs = len(params) // 2\n    result = [num_pairs] + params\n    return result\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Case 1\n    rho1, theta1 = 1.25, 0.7\n    c1, s1 = np.cos(theta1), np.sin(theta1)\n    A1 = rho1 * np.array([[c1, -s1], [s1, c1]])\n\n    # Case 2\n    rho2, theta2 = 1.1, 1.0\n    c2, s2 = np.cos(theta2), np.sin(theta2)\n    B2 = rho2 * np.array([[c2, -s2], [s2, c2]])\n    A2 = np.block([[B2, np.zeros((2, 2))], [np.zeros((2, 2)), np.diag([2.0, 0.5])]])\n\n    # Case 3\n    A3 = np.array([[2.0, -1.0, 0.0], [-1.0, 2.0, -1.0], [0.0, -1.0, 2.0]])\n\n    # Case 4\n    rho4, theta4 = 0.9, 1.2\n    c4, s4 = np.cos(theta4), np.sin(theta4)\n    B4 = rho4 * np.array([[c4, -s4], [s4, c4]])\n    D4 = np.block([[B4, np.zeros((2, 1))], [np.zeros((1, 2)), np.array([[-1.0]])]])\n    S = np.array([[1.0, 2.0, 0.0], [0.0, 1.0, 1.0], [1.0, 0.0, 1.0]])\n    S_inv = np.linalg.inv(S)\n    A4 = S @ D4 @ S_inv\n    \n    test_cases = [A1, A2, A3, A4]\n\n    all_results = []\n    for case in test_cases:\n        result = compute_schur_and_params(case)\n        all_results.append(result)\n\n    # Final print statement in the exact required format.\n    str_results = []\n    for res in all_results:\n        formatted_res_items = []\n        for item in res:\n            if isinstance(item, float):\n                formatted_res_items.append(f\"{item:.6f}\")\n            else:\n                formatted_res_items.append(str(item))\n        str_results.append(f\"[{','.join(formatted_res_items)}]\")\n        \n    print(f\"[{','.join(str_results)}]\")\n\nsolve()\n```"
        }
    ]
}