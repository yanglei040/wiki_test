{
    "hands_on_practices": [
        {
            "introduction": "将理论付诸实践的第一步是构建一个能够反映基本物理原理的数值方案。本练习  指导您为具有空间可变扩散系数的扩散方程实现一个 Crank-Nicolson 有限体积法。您将学习如何使用谐波平均来处理界面上的扩散系数，以确保通量的离散守恒，这是在模拟非均匀介质时保证物理真实性的关键技术。",
            "id": "3115317",
            "problem": "考虑周期性域上的一维扩散方程，由守恒律 $u_t = \\partial_x \\left( D(x) \\, u_x \\right)$ 给出，其中 $x \\in [0,L]$ 且 $t \\ge 0$，$u(x,t)$ 是标量场，$D(x)$ 是一个严格为正且随空间变化的扩散系数。此问题的基本依据是每个控制体积上的积分守恒形式、散度定理和通量的定义。使用有限体积法进行离散化，包含 $N$ 个宽度为 $\\Delta x = L/N$ 的均匀单元，单元中心为 $x_j = (j+1/2)\\Delta x$，其中 $j = 0,1,\\dots,N-1$。令 $U_j^n$ 表示在时间层 $t_n = n \\,\\Delta t$ 上对 $u(x,t_n)$ 的单元平均近似。\n\n您的任务是推导并实现一种在离散层面上保持通量守恒的 Crank-Nicolson 隐式方法 (Crank–Nicolson (CN))。按以下步骤进行：\n\n1. 从控制体积 $V_j = [x_{j-1/2}, x_{j+1/2}]$ 上的积分守恒形式开始：\n   $$\\frac{d}{dt} \\int_{V_j} u(x,t)\\,dx = \\left. - D(x) \\, u_x(x,t) \\right|_{x_{j-1/2}}^{x_{j+1/2}}.$$\n   使用散度定理和扩散通量的定义来证明此方程。定义界面通量 $F_{j+1/2}(t) = - D_{j+1/2} \\, \\left. u_x \\right|_{x_{j+1/2}}$ 和 $F_{j-1/2}(t) = - D_{j-1/2} \\, \\left. u_x \\right|_{x_{j-1/2}}$，使得\n   $$\\frac{d U_j}{dt} = \\frac{F_{j+1/2}(t) - F_{j-1/2}(t)}{\\Delta x},$$\n   其中 $U_j(t) = \\frac{1}{\\Delta x} \\int_{V_j} u(x,t)\\,dx$。\n\n2. 使用能保证通量守恒的、协调的二阶有限体积近似，对界面通量进行空间离散化：\n   - 用中心差分近似界面梯度：\n     $$\\left. u_x \\right|_{x_{j+1/2}} \\approx \\frac{U_{j+1} - U_j}{\\Delta x}.$$\n   - 使用单元中心值 $D_j = D(x_j)$ 和 $D_{j+1} = D(x_{j+1})$ 的调和平均值来定义界面扩散系数：\n     $$D_{j+1/2} = \\frac{2}{\\frac{1}{D_j} + \\frac{1}{D_{j+1}}}.$$\n   当 $D(x)$ 可变时，这种选择对于串联传导是标准的，并能确保跨界面的通量一致性。\n\n3. 使用上述空间离散化，将半离散系统写成以下形式\n   $$\\frac{d U_j}{dt} = \\frac{-D_{j+1/2}\\,(U_{j+1} - U_j) + D_{j-1/2}\\,(U_j - U_{j-1})}{\\Delta x^2},$$\n   且满足周期性边界条件 $U_{-1} \\equiv U_{N-1}$，$U_N \\equiv U_0$。将此表示为作用在向量 $\\mathbf{U} = (U_0,\\dots,U_{N-1})^\\top$ 上的线性算子 $\\mathbf{L}$：\n   $$\\frac{d \\mathbf{U}}{dt} = \\mathbf{L} \\, \\mathbf{U}.$$\n\n4. 应用 Crank-Nicolson 时间离散化以获得全离散方法：\n   $$\\frac{\\mathbf{U}^{n+1} - \\mathbf{U}^n}{\\Delta t} = \\frac{1}{2}\\left( \\mathbf{L}\\,\\mathbf{U}^{n+1} + \\mathbf{L}\\,\\mathbf{U}^{n} \\right),$$\n   这会得到如下线性系统\n   $$\\left( \\mathbf{I} - \\frac{\\Delta t}{2}\\mathbf{L} \\right)\\mathbf{U}^{n+1} = \\left( \\mathbf{I} + \\frac{\\Delta t}{2}\\mathbf{L} \\right)\\mathbf{U}^{n}.$$\n   此处，$\\mathbf{I}$ 是大小为 $N \\times N$ 的单位矩阵。\n\n5. 通过在单元中心 $x_j$ 处对 $u(x,0)$ 进行采样来初始化 $U_j^0$。在本作业中，所有三角函数必须使用以弧度为单位的角度。\n\n验证要求：\n- 在具有周期性边界条件的粗网格上，通过多个 CN 时间步来证明总质量 $M^n = \\sum_{j=0}^{N-1} U_j^n \\,\\Delta x$ 的离散守恒性。具体来说，验证 $|M^{\\text{final}} - M^0| < \\tau$，容差为 $\\tau = 10^{-10}$。\n\n实现一个完整的程序，该程序通过使用调和界面扩散系数的有限体积通量差来构造 $\\mathbf{L}$，执行 CN 时间步进，并为以下测试套件检查离散质量守恒。所有域的长度均为 $L = 1$ 并使用周期性边界条件：\n\n- 测试用例 1 (理想情况)：$N = 4$，$\\Delta t = 0.2$，步数 $= 8$，$D(x) \\equiv 1$，初始条件 $u(x,0) = 1 + \\sin(2\\pi x)$。\n- 测试用例 2 (可变扩散)：$N = 5$，$\\Delta t = 0.15$，步数 $= 12$，$D(x) = 1 + 0.5 \\sin(2\\pi x)$，初始条件 $u(x,0) = 0.8 + \\cos(2\\pi x)$。\n- 测试用例 3 (不连续扩散)：$N = 3$，$\\Delta t = 0.5$，步数 $= 5$，分段扩散 $D(x) = 0.1$ 对于 $x \\in [0,0.5)$ 且 $D(x) = 1.0$ 对于 $x \\in [0.5,1)$，初始条件 $u(x,0) = 1.2 + \\sin(4\\pi x)$。\n\n所有角度均以弧度为单位。您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表，每个条目都是一个布尔值，指示相应测试用例的质量守恒是否得到验证，例如 $[{\\text{result}_1},{\\text{result}_2},{\\text{result}_3}]$。",
            "solution": "该问题要求针对周期性域 $x \\in [0,L]$ 上具有空间变化扩散系数的一维扩散方程 $u_t = \\partial_x ( D(x) \\, u_x )$，推导并实现一种通量守恒的 Crank-Nicolson 隐式方法。求解过程将遵循指定步骤，以确保其建立在有限体积法和数值线性代数的严谨原理之上。\n\n守恒数值格式的基础是守恒律的积分形式。对于任意控制体积 $V_j = [x_{j-1/2}, x_{j+1/2}]$，体积内物理量 $u$ 的总量变化率等于穿过其边界的净通量。对偏微分方程在 $V_j$ 上进行积分可得：\n$$ \\frac{d}{dt} \\int_{x_{j-1/2}}^{x_{j+1/2}} u(x,t) \\, dx = \\int_{x_{j-1/2}}^{x_{j+1/2}} \\partial_x \\left( D(x) \\, u_x \\right) \\, dx $$\n对右侧应用微积分基本定理（一维散度定理），得到通量差：\n$$ \\frac{d}{dt} \\int_{x_{j-1/2}}^{x_{j+1/2}} u(x,t) \\, dx = \\left. D(x) \\, u_x(x,t) \\right|_{x_{j-1/2}}^{x_{j+1/2}} $$\n将扩散通量定义为 $F(x,t) = -D(x) \\, u_x(x,t)$，我们可以将其写为：\n$$ \\frac{d}{dt} \\int_{V_j} u(x,t) \\, dx = F(x_{j-1/2}, t) - F(x_{j+1/2}, t) = -\\left. F(x,t)\\right|_{x_{j-1/2}}^{x_{j+1/2}} $$\n在考虑了通量的符号约定后，这与问题中的第一个方程相符。令 $U_j(t) = \\frac{1}{\\Delta x} \\int_{V_j} u(x,t) \\, dx$ 为 $u$ 在宽度为 $\\Delta x = L/N$ 的单元 $V_j$ 上的单元平均值。单元平均值的时间演化由以下半离散方程给出：\n$$ \\frac{d U_j}{dt} = \\frac{F_{j+1/2}(t) - F_{j-1/2}(t)}{\\Delta x} $$\n其中 $F_{j \\pm 1/2}(t)$ 是在单元界面 $x_{j \\pm 1/2}$ 处计算的通量。这种公式保证了离开单元 $V_j$ 并穿过界面 $x_{j+1/2}$ 的通量与进入相邻单元 $V_{j+1}$ 的通量相同，从而确保了离散守恒性。\n\n为了在空间上完全离散化，我们必须对通量进行近似。界面 $x_{j+1/2}$ 处的通量为 $F_{j+1/2} = - D_{j+1/2} \\, \\left. u_x \\right|_{x_{j+1/2}}$，其中 $D_{j+1/2}$ 是单元界面处的扩散系数。基于单元平均值 $U_j$ 和 $U_{j+1}$，界面梯度的一个二阶精确中心差分近似为：\n$$ \\left. u_x \\right|_{x_{j+1/2}} \\approx \\frac{U_{j+1} - U_j}{\\Delta x} $$\n对于随空间变化的 $D(x)$，必须谨慎选择 $D_{j+1/2}$ 的值以保持物理一致性。问题中指定使用单元中心扩散系数 $D_j = D(x_j)$ 和 $D_{j+1} = D(x_{j+1})$ 的调和平均值：\n$$ D_{j+1/2} = \\frac{2 D_j D_{j+1}}{D_j + D_{j+1}} = \\left( \\frac{1/D_j + 1/D_{j+1}}{2} \\right)^{-1} $$\n这种选择的物理动机是考虑通过两个串联层的稳态扩散，其中有效热导率（或扩散率）由各层电导率的调和平均值导出。它能正确确保通量的连续性，尤其是在 $D(x)$ 存在剧变界面时。\n\n将这些空间近似代入半离散方程可得：\n$$ \\frac{d U_j}{dt} = \\frac{1}{\\Delta x} \\left[ -D_{j+1/2} \\frac{U_{j+1} - U_j}{\\Delta x} - \\left(-D_{j-1/2} \\frac{U_j - U_{j-1}}{\\Delta x}\\right) \\right] $$\n$$ \\frac{d U_j}{dt} = \\frac{1}{\\Delta x^2} \\left[ D_{j-1/2}U_{j-1} - (D_{j+1/2} + D_{j-1/2})U_j + D_{j+1/2}U_{j+1} \\right] $$\n这个常微分方程组可以表示为矩阵形式 $\\frac{d\\mathbf{U}}{dt} = \\mathbf{L}\\mathbf{U}$，其中 $\\mathbf{U} = (U_0, U_1, \\dots, U_{N-1})^\\top$，$\\mathbf{L}$ 是一个 $N \\times N$ 矩阵。对于单元 $j$，$\\mathbf{L}$ 的第 $j$ 行中的非零项为：\n$$ L_{j, j-1} = \\frac{D_{j-1/2}}{\\Delta x^2}, \\quad L_{j, j} = -\\frac{D_{j+1/2} + D_{j-1/2}}{\\Delta x^2}, \\quad L_{j, j+1} = \\frac{D_{j+1/2}}{\\Delta x^2} $$\n周期性边界条件（$U_{-1} \\equiv U_{N-1}$，$U_N \\equiv U_0$）要求指数在模 $N$ 的意义下进行解释。这使得 $\\mathbf{L}$ 成为一个循环三对角矩阵。这种构造的一个重要性质是 $\\mathbf{L}$ 的每行元素之和为零，这意味着 $\\mathbf{L}$ 会零化常数向量。此外，详细分析表明 $\\mathbf{L}$ 的每列元素之和也为零。这意味着 $\\mathbf{v}^\\top \\mathbf{L} = \\mathbf{0}^\\top$，其中 $\\mathbf{v}^\\top = (1, 1, \\dots, 1)$。这个性质保证了总质量的离散守恒，因为 $\\frac{d}{dt} \\sum_j U_j = \\sum_j (\\mathbf{L}\\mathbf{U})_j = (\\mathbf{v}^\\top \\mathbf{L}) \\mathbf{U} = 0$。\n\n对于时间离散化，我们应用 Crank-Nicolson 方法，该方法对扩散方程是时间上二阶精确且无条件稳定的。它对当前时间层 $t_n$ 和下一个时间层 $t_{n+1}$ 的空间算子 $\\mathbf{L}$ 取平均：\n$$ \\frac{\\mathbf{U}^{n+1} - \\mathbf{U}^n}{\\Delta t} = \\frac{1}{2} \\left( \\mathbf{L}\\mathbf{U}^{n+1} + \\mathbf{L}\\mathbf{U}^{n} \\right) $$\n其中 $\\mathbf{U}^n$ 是在时间 $t_n = n \\Delta t$ 的数值解向量。重新整理各项以求解未知状态 $\\mathbf{U}^{n+1}$，得到以下线性系统：\n$$ \\mathbf{U}^{n+1} - \\frac{\\Delta t}{2}\\mathbf{L}\\mathbf{U}^{n+1} = \\mathbf{U}^{n} + \\frac{\\Delta t}{2}\\mathbf{L}\\mathbf{U}^{n} $$\n$$ \\left( \\mathbf{I} - \\frac{\\Delta t}{2}\\mathbf{L} \\right) \\mathbf{U}^{n+1} = \\left( \\mathbf{I} + \\frac{\\Delta t}{2}\\mathbf{L} \\right) \\mathbf{U}^{n} $$\n在每个时间步，我们构造矩阵 $\\mathbf{A} = \\mathbf{I} - \\frac{\\Delta t}{2}\\mathbf{L}$ 和 $\\mathbf{B} = \\mathbf{I} + \\frac{\\Delta t}{2}\\mathbf{L}$，计算右端向量 $\\mathbf{b} = \\mathbf{B}\\mathbf{U}^n$，并使用标准线性求解器求解线性系统 $\\mathbf{A}\\mathbf{U}^{n+1} = \\mathbf{b}$。该格式保留了半离散化的质量守恒性质，可通过左乘 $\\mathbf{v}^\\top$ 来证明：\n$$ \\mathbf{v}^\\top \\left( \\mathbf{I} - \\frac{\\Delta t}{2}\\mathbf{L} \\right) \\mathbf{U}^{n+1} = \\mathbf{v}^\\top \\left( \\mathbf{I} + \\frac{\\Delta t}{2}\\mathbf{L} \\right) \\mathbf{U}^{n} $$\n由于 $\\mathbf{v}^\\top \\mathbf{L} = \\mathbf{0}^\\top$，上式可简化为 $\\mathbf{v}^\\top \\mathbf{U}^{n+1} = \\mathbf{v}^\\top \\mathbf{U}^{n}$，这证实了 $\\sum_j U_j^{n+1} = \\sum_j U_j^n$。因此，总质量 $M^n = \\sum_j U_j^n \\Delta x$ 在各个时间步之间是守恒的，其差异仅由浮点精度误差引起。\n\n该实现将首先通过在单元中心 $x_j = (j+1/2)\\Delta x$ 对给定的初始条件 $u(x,0)$进行采样来初始化解向量 $\\mathbf{U}^0$。然后，它将基于单元中心的 $D(x)$ 值的调和平均值来构造矩阵 $\\mathbf{L}$。最后，它将循环执行所需的时间步数，在每个步骤中求解线性系统。总质量 $M^n$ 的守恒性通过将初始质量 $M^0$ 与最终质量 $M^{\\text{final}}$ 和指定的容差 $\\tau = 10^{-10}$ 进行比较来验证。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D diffusion equation using a Crank-Nicolson finite-volume scheme\n    and verifies mass conservation for a suite of test cases.\n    \"\"\"\n    \n    # Define test cases as specified in the problem statement\n    test_cases = [\n        {\n            \"N\": 4, \"dt\": 0.2, \"steps\": 8, \"L\": 1.0,\n            \"D_func\": lambda x: np.ones_like(x),\n            \"u_init_func\": lambda x: 1.0 + np.sin(2 * np.pi * x)\n        },\n        {\n            \"N\": 5, \"dt\": 0.15, \"steps\": 12, \"L\": 1.0,\n            \"D_func\": lambda x: 1.0 + 0.5 * np.sin(2 * np.pi * x),\n            \"u_init_func\": lambda x: 0.8 + np.cos(2 * np.pi * x)\n        },\n        {\n            \"N\": 3, \"dt\": 0.5, \"steps\": 5, \"L\": 1.0,\n            \"D_func\": lambda x: np.piecewise(x, [x % 1.0 < 0.5, x % 1.0 >= 0.5], [0.1, 1.0]),\n            \"u_init_func\": lambda x: 1.2 + np.sin(4 * np.pi * x)\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        N = case[\"N\"]\n        dt = case[\"dt\"]\n        num_steps = case[\"steps\"]\n        L = case[\"L\"]\n        D_func = case[\"D_func\"]\n        u_init_func = case[\"u_init_func\"]\n        \n        # 1. Define grid and initialize state vector U\n        dx = L / N\n        # Cell centers\n        x_j = (np.arange(N) + 0.5) * dx\n        \n        # Initial condition\n        U_current = u_init_func(x_j)\n        \n        # 2. Calculate initial total mass\n        M_initial = np.sum(U_current) * dx\n        \n        # 3. Construct the spatial operator L\n        # Cell-centered diffusion coefficients\n        D_j = D_func(x_j)\n        \n        # Face diffusion coefficients using harmonic mean\n        # D_face[j] stores D_{j+1/2} (interface between cell j and j+1)\n        # np.roll(D_j, -1) handles periodic boundary for D_{j+1}\n        D_j_plus_1 = np.roll(D_j, -1)\n        # Avoid division by zero if D_j + D_j_plus_1 is zero, although D(x) > 0\n        D_face = np.divide(2 * D_j * D_j_plus_1, D_j + D_j_plus_1, \n                           out=np.zeros_like(D_j), where=(D_j + D_j_plus_1) != 0)\n\n        # Construct L matrix\n        L_matrix = np.zeros((N, N))\n        inv_dx2 = 1.0 / (dx * dx)\n        for j in range(N):\n            # D_{j+1/2} is at the right face of cell j\n            D_plus_half = D_face[j]\n            # D_{j-1/2} is at the left face of cell j (which is right face of cell j-1)\n            D_minus_half = D_face[(j - 1 + N) % N]\n            \n            # Indices for periodic boundaries\n            j_minus_1 = (j - 1 + N) % N\n            j_plus_1 = (j + 1) % N\n            \n            # Fill the j-th row of L\n            L_matrix[j, j_minus_1] = D_minus_half * inv_dx2\n            L_matrix[j, j] = -(D_plus_half + D_minus_half) * inv_dx2\n            L_matrix[j, j_plus_1] = D_plus_half * inv_dx2\n            \n        # 4. Construct Crank-Nicolson system matrices A and B\n        I = np.identity(N)\n        A = I - (dt / 2.0) * L_matrix\n        B = I + (dt / 2.0) * L_matrix\n        \n        # 5. Perform time stepping\n        for _ in range(num_steps):\n            # Calculate right-hand side: b = B * U^n\n            rhs = B @ U_current\n            # Solve for next time step: A * U^{n+1} = b\n            U_next = np.linalg.solve(A, rhs)\n            U_current = U_next\n            \n        # 6. Calculate final total mass\n        M_final = np.sum(U_current) * dx\n        \n        # 7. Verify mass conservation\n        conservation_tolerance = 1e-10\n        is_conserved = np.abs(M_final - M_initial) < conservation_tolerance\n        results.append(is_conserved)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "虽然 Crank-Nicolson 方法以其二阶精度和无条件稳定性而著称，但在处理非光滑或不连续的初始条件时，它可能会产生非物理的伪振荡。本练习  聚焦于这一实际挑战，通过比较纯 Crank-Nicolson 方案与采用一步后向欧拉“启动”策略的混合方案，来量化并抑制这些振荡。这个实践将帮助您理解提高数值解质量的实用技巧，确保模拟结果不仅稳定，而且物理上合理。",
            "id": "3115233",
            "problem": "考虑定义在有限区间上的具有齐次狄利克雷边界条件的一维热扩散初边值问题。其物理模型是热扩散的偏微分方程，其中温度场满足 $u_t = \\alpha u_{xx}$，定义域为 $x \\in [0,L]$，时间为 $t \\ge 0$，边界条件为 $u(0,t) = 0$ 和 $u(L,t) = 0$，初始条件为 $u(x,0) = u_0(x)$。令 $u$ 为无量纲温度，$x$ 为位置（单位：米），$t$ 为时间（单位：秒），$L$ 为长度（单位：米），$\\alpha$ 为热扩散系数（单位：平方米/秒）。\n\n从空间微分的基本定义和时间积分的梯形法则出发，实现两种全隐式时间推进策略，以演化通过空间二阶中心差分得到的半离散系统：\n- 策略 A (纯 Crank–Nicolson 方法)：从 $t=0$ 开始的每个时间步都应用梯形法则。\n- 策略 B (后向欧拉法启动，后接 Crank–Nicolson 方法)：应用一个初始的后向欧拉法（也称为隐式欧拉法）步，然后在其后所有剩余的步中切换到 Crank–Nicolson 方法。\n\n空间网格应使用包括两个边界在内的 $M$ 个点，点间距均匀，为 $\\Delta x = L/(M-1)$；只有内部的未知数随时间推进。初始条件是一个矩形阶跃函数，定义为：当 $x \\in [0.4L, 0.6L]$ 时 $u_0(x) = 1$，否则 $u_0(x) = 0$，并通过 $u(0,0) = 0$ 和 $u(L,0) = 0$ 强制执行边界条件。这些值是无量纲的。\n\n在给定的最终时间 $T$ 定义以下伪振荡的标量度量：构建包含两个边界值和内部解的完整向量，并令 $u_{\\max}$ 为其最大值，$u_{\\min}$ 为其最小值。连续模型的极值原理以及初始和边界数据的选择所蕴含的物理界限是 $0 \\le u \\le 1$。通过以下公式量化对这些界限的违反程度：\n$$\n\\mathcal{M} = \\max(0, u_{\\max} - 1) + \\max(0, 0 - u_{\\min}),\n$$\n这是一个非负实数。$\\mathcal{M}$ 的值越大，表示伪振荡越严重。对于每个测试案例，计算策略 A 下的 $\\mathcal{M}_{\\mathrm{CN}}$ 和策略 B 下的 $\\mathcal{M}_{\\mathrm{BE}\\rightarrow\\mathrm{CN}}$，并报告其减少量\n$$\nR = \\mathcal{M}_{\\mathrm{CN}} - \\mathcal{M}_{\\mathrm{BE}\\rightarrow\\mathrm{CN}}.\n$$\n正的 $R$ 值表示一步后向欧拉法启动减少了伪振荡。\n\n您的程序必须从第一性原理出发实现有限差分半离散模型和两种隐式时间积分器，确保使用科学上真实的参数。使用以下参数集的测试套件，这些参数都满足 $N_t = T/\\Delta t$ 为整数个时间步：\n- 测试 1：$\\alpha = 1.0\\,\\mathrm{m^2/s}$，$L = 1.0\\,\\mathrm{m}$，$M = 101$，$\\Delta t = 1\\times 10^{-4}\\,\\mathrm{s}$，$T = 2\\times 10^{-3}\\,\\mathrm{s}$。\n- 测试 2：$\\alpha = 1.0\\,\\mathrm{m^2/s}$，$L = 1.0\\,\\mathrm{m}$，$M = 101$，$\\Delta t = 1\\times 10^{-5}\\,\\mathrm{s}$，$T = 2\\times 10^{-4}\\,\\mathrm{s}$。\n- 测试 3：$\\alpha = 1.0\\,\\mathrm{m^2/s}$，$L = 1.0\\,\\mathrm{m}$，$M = 51$，$\\Delta t = 5\\times 10^{-4}\\,\\mathrm{s}$，$T = 1\\times 10^{-2}\\,\\mathrm{s}$。\n- 测试 4：$\\alpha = 1.0\\,\\mathrm{m^2/s}$，$L = 1.0\\,\\mathrm{m}$，$M = 101$，$\\Delta t = 1\\times 10^{-3}\\,\\mathrm{s}$，$T = 2\\times 10^{-2}\\,\\mathrm{s}$。\n\n对于每个测试案例，计算 $R$ 并将其表示为小数点后六位四舍五入的十进制数。您的程序应产生单行输出，包含一个逗号分隔的列表，用方括号括起来（例如 $[r_1,r_2,r_3,r_4]$），其中 $r_i$ 是测试 $i$ 的 $R$ 值。所有涉及物理单位的量必须严格按照规定解释；输出是无量纲的实数。",
            "solution": "所提出的问题是有效的，因为它在科学上基于热扩散和数值分析的原理，其定义和参数完整一致，问题陈述明确，并且其表述是客观的。因此，我们可以着手提供完整的解决方案。\n\n问题要求实现并比较两种用于一维热方程 $u_t = \\alpha u_{xx}$ 的时间积分方案。我们将首先在空间上对该方程进行半离散化，然后将指定的时间推进方法应用于所得的常微分方程组。\n\n控制偏微分方程 (PDE) 是：\n$$\n\\frac{\\partial u}{\\partial t} = \\alpha \\frac{\\partial^2 u}{\\partial x^2}\n$$\n对于位置 $x \\in [0, L]$ 和时间 $t \\ge 0$。该问题受齐次狄利克雷边界条件 $u(0,t) = 0$ 和 $u(L,t) = 0$ 以及不连续的初始条件 $u(x,0) = u_0(x)$ 的约束，其中当 $x \\in [0.4L, 0.6L]$ 时 $u_0(x) = 1$，否则 $u_0(x) = 0$。\n\n**1. 空间离散化**\n\n我们首先将空间域 $[0,L]$ 离散为 $M$ 个均匀分布的点 $x_j = j \\Delta x$，$j = 0, 1, \\dots, M-1$，其中网格间距为 $\\Delta x = L/(M-1)$。令 $u_j(t)$ 为 $u(x_j, t)$ 的数值近似。边界条件固定了 $u_0(t) = 0$ 和 $u_{M-1}(t) = 0$。解是针对 $M-2$ 个内部点 $j=1, 2, \\dots, M-2$ 求解的。\n\n内部节点 $x_j$ 处的二阶空间导数 $u_{xx}$ 使用二阶中心差分格式来近似：\n$$\n\\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{x=x_j} \\approx \\frac{u_{j+1}(t) - 2u_j(t) + u_{j-1}(t)}{(\\Delta x)^2}\n$$\n将此式代入每个内部节点的热方程，得到一个包含 $M-2$ 个耦合常微分方程 (ODE) 的方程组：\n$$\n\\frac{du_j}{dt} = \\frac{\\alpha}{(\\Delta x)^2} (u_{j-1} - 2u_j + u_{j+1}) \\quad \\text{for } j = 1, \\dots, M-2\n$$\n令 $\\mathbf{u}(t)$ 为内部未知数的列向量，$\\mathbf{u}(t) = [u_1(t), u_2(t), \\dots, u_{M-2}(t)]^T$。该常微分方程组可以写成矩阵形式：\n$$\n\\frac{d\\mathbf{u}}{dt} = A \\mathbf{u}(t)\n$$\n其中 $A$ 是一个 $(M-2) \\times (M-2)$ 的三对角矩阵，表示离散化的拉普拉斯算子，并按热扩散系数进行了缩放。给定齐次边界条件 ($u_0=0, u_{M-1}=0$)，矩阵 $A$ 为：\n$$\nA = \\frac{\\alpha}{(\\Delta x)^2}\n\\begin{pmatrix}\n-2  & 1  & 0  & \\cdots  & 0 \\\\\n1  & -2  & 1  & \\cdots  & 0 \\\\\n0  & \\ddots  & \\ddots  & \\ddots  & 0 \\\\\n0  & \\cdots  & 1  & -2  & 1 \\\\\n0  & \\cdots  & 0  & 1  & -2\n\\end{pmatrix}\n$$\n\n**2. 时间积分**\n\n令 $\\mathbf{u}^n$ 为在时间 $t_n = n \\Delta t$ 时 $\\mathbf{u}(t)$ 的近似值。我们分析两种要求的时间积分策略。\n\n**策略 A：纯 Crank-Nicolson 方法**\n\nCrank-Nicolson 方法等效于将梯形法则应用于半离散系统 $\\frac{d\\mathbf{u}}{dt} = A\\mathbf{u}$：\n$$\n\\frac{\\mathbf{u}^{n+1} - \\mathbf{u}^n}{\\Delta t} = \\frac{1}{2} (A \\mathbf{u}^n + A \\mathbf{u}^{n+1})\n$$\n重新整理各项以求解未知数 $\\mathbf{u}^{n+1}$，可得：\n$$\n\\mathbf{u}^{n+1} - \\frac{\\Delta t}{2} A \\mathbf{u}^{n+1} = \\mathbf{u}^n + \\frac{\\Delta t}{2} A \\mathbf{u}^n\n$$\n$$\n\\left(I - \\frac{\\Delta t}{2} A\\right) \\mathbf{u}^{n+1} = \\left(I + \\frac{\\Delta t}{2} A\\right) \\mathbf{u}^n\n$$\n其中 $I$ 是单位矩阵。令扩散数 (diffusion number) 为 $s = \\frac{\\alpha \\Delta t}{(\\Delta x)^2}$。线性系统中的矩阵变为：\n- 左侧矩阵：$C_{\\text{mat}} = I - \\frac{\\Delta t}{2} A = I - \\frac{s}{2} \\text{Tridiag}(1, -2, 1)$，即三对角矩阵 $\\text{Tridiag}(-\\frac{s}{2}, 1+s, -\\frac{s}{2})$。\n- 右侧矩阵：$D_{\\text{mat}} = I + \\frac{\\Delta t}{2} A = I + \\frac{s}{2} \\text{Tridiag}(1, -2, 1)$，即三对角矩阵 $\\text{Tridiag}(\\frac{s}{2}, 1-s, \\frac{s}{2})$。\n\n在每个时间步，我们求解三对角线性系统 $C_{\\text{mat}} \\mathbf{u}^{n+1} = D_{\\text{mat}} \\mathbf{u}^n$ 以得到 $\\mathbf{u}^{n+1}$。\n\n**策略 B：后向欧拉法启动，后接 Crank-Nicolson 方法**\n\n该策略在第一个时间步使用不同的方法，以抑制由不连续初始条件引起的高频分量。\n\n- **步骤 1 (从 $t_0$ 到 $t_1$)：后向欧拉法**\n后向（或隐式）欧拉法为：\n$$\n\\frac{\\mathbf{u}^1 - \\mathbf{u}^0}{\\Delta t} = A \\mathbf{u}^1\n$$\n重新整理以求解 $\\mathbf{u}^1$：\n$$\n(I - \\Delta t A) \\mathbf{u}^1 = \\mathbf{u}^0\n$$\n系统矩阵为 $B_{\\text{mat}} = I - \\Delta t A = I - s \\cdot \\text{Tridiag}(1, -2, 1)$，即三对角矩阵 $\\text{Tridiag}(-s, 1+2s, -s)$。我们求解线性系统 $B_{\\text{mat}} \\mathbf{u}^1 = \\mathbf{u}^0$。\n\n- **后续步骤 (对于 $n \\ge 1$)：Crank-Nicolson 方法**\n对于所有后续时间步，我们回到策略 A 中描述的 Crank-Nicolson 格式：\n$$\nC_{\\text{mat}} \\mathbf{u}^{n+1} = D_{\\text{mat}} \\mathbf{u}^n \\quad \\text{for } n=1, 2, \\dots, N_t-1\n$$\n\n**3. 振荡度量与减少量**\n\n对于每种策略，将解演化到最终时间 $T$ 后，我们得到内部未知数的向量 $\\mathbf{u}^{N_t}$。然后，我们通过包含边界值来构建完整的解向量：$\\mathbf{u}_{\\text{full}} = [0, (\\mathbf{u}^{N_t})^T, 0]^T$。最大值 $u_{\\max}$ 和最小值 $u_{\\min}$ 从此完整向量中找到。\n\n伪振荡的度量 $\\mathcal{M}$ 量化了对极值原理界限 $[0, 1]$ 的违反程度：\n$$\n\\mathcal{M} = \\max(0, u_{\\max} - 1) + \\max(0, 0 - u_{\\min})\n$$\n我们为策略 A ($\\mathcal{M}_{\\mathrm{CN}}$) 和策略 B ($\\mathcal{M}_{\\mathrm{BE}\\rightarrow\\mathrm{CN}}$) 计算此度量。每个测试案例的最终结果是振荡的减少量：\n$$\nR = \\mathcal{M}_{\\mathrm{CN}} - \\mathcal{M}_{\\mathrm{BE}\\rightarrow\\mathrm{CN}}\n$$\n正的 $R$ 值表示一步后向欧拉法启动成功地减轻了纯 Crank-Nicolson 格式中存在的伪振荡。实现将涉及建立三对角矩阵，并在每个时间步使用高效的线性求解器。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef compute_reduction(alpha: float, L: float, M: int, dt: float, T: float) -> float:\n    \"\"\"\n    Solves the 1D heat equation using two different time-marching strategies\n    and computes the reduction in spurious oscillations.\n\n    Args:\n        alpha: Thermal diffusivity (m^2/s).\n        L: Length of the domain (m).\n        M: Number of spatial grid points.\n        dt: Time step size (s).\n        T: Final time (s).\n\n    Returns:\n        The reduction R = M_CN - M_BE_CN, rounded to 6 decimal places.\n    \"\"\"\n    # 1. Setup Grid and Parameters\n    dx = L / (M - 1)\n    x = np.linspace(0, L, M)\n    Nt = int(round(T / dt))\n    num_interior = M - 2\n    \n    # Dimensionless diffusion number\n    s = alpha * dt / (dx**2)\n\n    # 2. Initial Condition\n    u0_full = np.zeros(M)\n    u0_full[(x >= 0.4 * L) & (x <= 0.6 * L)] = 1.0\n    # Boundary conditions u(0,t)=0 and u(L,t)=0 are already set by np.zeros\n    u0_interior = u0_full[1:-1]\n\n    # 3. Strategy A: Pure Crank-Nicolson\n    # System: C_mat * u^{n+1} = D_mat * u^n\n    # C_mat = Tridiag(-s/2, 1+s, -s/2)\n    # D_mat = Tridiag(s/2, 1-s, s/2)\n    \n    # Matrix for the left-hand side (banded format for scipy)\n    C_mat_banded = np.zeros((3, num_interior))\n    C_mat_banded[0, 1:] = -s / 2.0  # Super-diagonal\n    C_mat_banded[1, :] = 1.0 + s      # Main diagonal\n    C_mat_banded[2, :-1] = -s / 2.0 # Sub-diagonal\n\n    # Diagonals for the right-hand side matrix D_mat\n    D_mat_main_diag = 1.0 - s\n    D_mat_off_diag = s / 2.0\n\n    u_cn = u0_interior.copy()\n    for _ in range(Nt):\n        # Build RHS vector: b = D_mat * u_cn\n        b = np.zeros(num_interior)\n        if num_interior > 1:\n            b[1:-1] = (D_mat_off_diag * u_cn[:-2] +\n                       D_mat_main_diag * u_cn[1:-1] +\n                       D_mat_off_diag * u_cn[2:])\n            b[0] = D_mat_main_diag * u_cn[0] + D_mat_off_diag * u_cn[1]\n            b[-1] = D_mat_main_diag * u_cn[-1] + D_mat_off_diag * u_cn[-2]\n        elif num_interior == 1:\n            b[0] = D_mat_main_diag * u_cn[0]\n\n        # Solve C_mat * u_n+1 = b for u_n+1\n        u_cn = solve_banded((1, 1), C_mat_banded, b)\n\n    u_full_cn = np.concatenate(([0], u_cn, [0]))\n    u_max_cn = np.max(u_full_cn)\n    u_min_cn = np.min(u_full_cn)\n    M_cn = max(0, u_max_cn - 1.0) + max(0, -u_min_cn)\n\n    # 4. Strategy B: Backward Euler start-up, then Crank-Nicolson\n    \n    # First step: Backward Euler\n    # System: B_mat * u^1 = u^0\n    # B_mat = Tridiag(-s, 1+2s, -s)\n    B_mat_banded = np.zeros((3, num_interior))\n    B_mat_banded[0, 1:] = -s\n    B_mat_banded[1, :] = 1.0 + 2.0 * s\n    B_mat_banded[2, :-1] = -s\n    \n    u_be_cn = solve_banded((1, 1), B_mat_banded, u0_interior)\n\n    # Subsequent steps: Crank-Nicolson\n    if Nt > 1:\n        for _ in range(Nt - 1):\n            b = np.zeros(num_interior)\n            if num_interior > 1:\n                b[1:-1] = (D_mat_off_diag * u_be_cn[:-2] +\n                           D_mat_main_diag * u_be_cn[1:-1] +\n                           D_mat_off_diag * u_be_cn[2:])\n                b[0] = D_mat_main_diag * u_be_cn[0] + D_mat_off_diag * u_be_cn[1]\n                b[-1] = D_mat_main_diag * u_be_cn[-1] + D_mat_off_diag * u_be_cn[-2]\n            elif num_interior == 1:\n                b[0] = D_mat_main_diag * u_be_cn[0]\n\n            u_be_cn = solve_banded((1, 1), C_mat_banded, b)\n\n    u_full_be_cn = np.concatenate(([0], u_be_cn, [0]))\n    u_max_be_cn = np.max(u_full_be_cn)\n    u_min_be_cn = np.min(u_full_be_cn)\n    M_be_cn = max(0, u_max_be_cn - 1.0) + max(0, -u_min_be_cn)\n\n    # 5. Calculate Reduction R\n    R = M_cn - M_be_cn\n    return round(R, 6)\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # (alpha, L, M, dt, T)\n        (1.0, 1.0, 101, 1e-4, 2e-3),\n        (1.0, 1.0, 101, 1e-5, 2e-4),\n        (1.0, 1.0, 51, 5e-4, 1e-2),\n        (1.0, 1.0, 101, 1e-3, 2e-2),\n    ]\n\n    results = []\n    for case in test_cases:\n        alpha, L, M, dt, T = case\n        result = compute_reduction(alpha, L, M, dt, T)\n        results.append(f\"{result:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "现实世界中的许多问题涉及多种材料或物理过程的耦合，这要求数值方法能够处理更复杂的系统。本练习  将 Crank-Nicolson 方法的应用扩展到两种不同材料接触的耦合扩散系统。您将通过构建分块矩阵和实现一种简化的分块迭代方案，来探索处理这类问题的策略。此练习的高潮是对方案的数值稳定性进行分析，通过计算放大算子的谱半径来判断其稳定性——这是计算科学中用于验证数值方法鲁棒性的一个核心工具。",
            "id": "3115280",
            "problem": "本题要求您推导并实现一个用于一维耦合扩散系统的全耦合分块 Crank–Nicolson (CN) 格式，该系统代表两种共享一个界面的材料。您还需要通过计算单步放大算子的谱半径来研究耦合稳定性。所有计算均在无量纲变量下进行，不涉及物理单位。\n\n从以下基本原理出发：\n- 在一维杆中，热量扩散过程由偏微分方程 (PDE) $\\partial_t u(x,t) = \\partial_x \\left( \\alpha(x) \\, \\partial_x u(x,t) \\right)$ 建模，其中 $u(x,t)$ 是温度场，$\\alpha(x) \\ge 0$ 是热扩散系数，且 $\\alpha(x)$ 随空间变化。\n- 在间距为 $h$ 的均匀网格上进行守恒有限差分（或等效地，有限体积）半离散化，在内部区域会产生一个常微分方程 (ODE) 系统 $\\frac{d\\mathbf{u}}{dt} = A \\, \\mathbf{u}$，其中 $A$ 是一个三对角矩阵。该矩阵通过使用面上的调和平均扩散系数构建面心通量来构造，以保证在材料界面上温度和热通量的连续性。\n- Crank–Nicolson (CN) 方法是应用于半离散 ODE 的梯形法则所定义的时间积分器，为齐次问题生成一种形式为 $\\left(I - \\frac{\\Delta t}{2} A\\right) \\mathbf{u}^{n+1} = \\left(I + \\frac{\\Delta t}{2} A\\right) \\mathbf{u}^{n}$ 的线性单步法。\n\n问题设置：\n- 考虑域 $[0,L]$，其中 $L = L_1 + L_2$。左子域 $[0,L_1]$ 为材料 1，其扩散系数为常数 $\\alpha_1$；右子域 $[L_1, L]$ 为材料 2，其扩散系数为常数 $\\alpha_2$。\n- 施加齐次 Dirichlet 边界条件 $u(0,t)=0$ 和 $u(L,t)=0$。\n- 使用具有 $N$ 个内部节点和间距 $h = \\frac{L}{N+1}$ 的均匀网格，并假设所选的 $N$ 使得界面位置 $x=L_1$ 与一个网格节点重合，即 $k = \\frac{(N+1)L_1}{L}$ 为整数，且 $1 \\le k \\le N$。这将半离散的未知向量分解为分块形式 $\\mathbf{u} = \\begin{bmatrix} \\mathbf{u}_1 \\\\ \\mathbf{u}_2 \\end{bmatrix}$，其中 $\\mathbf{u}_1 \\in \\mathbb{R}^{k}$ 对应于材料 1 中的节点（包括界面节点），$\\mathbf{u}_2 \\in \\mathbb{R}^{N-k}$ 对应于材料 2 中的节点。\n- 构造三对角矩阵 $A \\in \\mathbb{R}^{N \\times N}$，它代表了具有分段常数 $\\alpha(x)$ 和齐次 Dirichlet 边界的算子 $\\partial_x(\\alpha \\partial_x u)$ 的半离散形式，使用守恒面通量形式。对于每个内部节点索引 $i \\in \\{1,\\dots,N\\}$（为便于说明，使用基于 1 的索引），通过在每个面上进行调和平均来定义面系数 $\\alpha_{i+1/2}$ 和 $\\alpha_{i-1/2}$：\n  $$ \\alpha_{i+1/2} = \\begin{cases}\n  \\alpha_1  & \\text{如果面完全位于材料 1 内部,} \\\\\n  \\alpha_2  & \\text{如果面完全位于材料 2 内部,} \\\\\n  \\dfrac{2 \\alpha_1 \\alpha_2}{\\alpha_1 + \\alpha_2}  & \\text{如果面与界面重合,}\n  \\end{cases} $$\n  $\\alpha_{i-1/2}$ 的定义类似。那么，节点 $i$ 处的离散算子为\n  $$ (A \\mathbf{u})_i = \\frac{1}{h^2} \\left( \\alpha_{i+1/2} (u_{i+1} - u_i) - \\alpha_{i-1/2} (u_i - u_{i-1}) \\right), $$\n  其中，通过 Dirichlet 边界条件强制 $u_0 = 0$ 和 $u_{N+1} = 0$。这确保了界面处的温度和通量连续性。\n- 使用界面分割索引 $k$ 将 $A$ 划分为块：$A = \\begin{bmatrix} A_{11} & A_{12} \\\\ A_{21} & A_{22} \\end{bmatrix}$。\n\n任务：\n1. 从第一性原理出发，使用带有调和平均的守恒面通量离散化方法，推导耦合系统的半离散矩阵 $A$。解释为何这种方法能够在不增加额外未知数的情况下强制实现界面处的温度和热通量连续性。\n2. 通过仅使用 $A$、时间步长 $\\Delta t$ 和单位矩阵 $I$（均由前述步骤精确定义）来表示，推导齐次系统的整体式 Crank–Nicolson 单步放大算子 $G$，该算子将 $\\mathbf{u}^n$ 映射到 $\\mathbf{u}^{n+1}$。\n3. 考虑一个分块迭代的变体，其中材料内部的分块是隐式处理的，但材料间的耦合是通过从 $\\mathbf{u}^{n+1,(0)} = \\mathbf{u}^n$ 开始的单次 Jacobi 迭代来处理的。推导相应的单次迭代分块放大算子 $J$，该算子以分块形式将 $\\mathbf{u}^n$ 映射到 $\\mathbf{u}^{n+1}$，仅使用 $A_{11}$、$A_{22}$、$A_{12}$、$A_{21}$、$\\Delta t$ 和分块单位矩阵。清楚地陈述所使用的任何线性代数步骤。\n4. 对于每个算子 $X \\in \\{G, J\\}$，将谱半径 $\\rho(X)$ 定义为其特征值的最大模，并解释为什么它是应用于齐次系统的单步法线性稳定性的一个有用指标。\n\n编程要求：\n- 在单个程序中实现 $A$ 的构造以及如上推导的 $\\rho(G)$ 和 $\\rho(J)$ 的计算。\n- 使用以下固定的测试套件，其中域长度 $L_1 = 1$、$L_2 = 1$，总长度 $L = 2$，并通过选择奇数 $N$ 以使 $k = \\frac{N+1}{2}$ 来对齐界面：\n  - 测试 1 (整体式 CN，常规情况): $\\alpha_1 = 1$, $\\alpha_2 = 10$, $N=41$, $\\Delta t = 2.0$；计算 $\\rho(G)$。\n  - 测试 2 (整体式 CN，极大时间步长): $\\alpha_1 = 1$, $\\alpha_2 = 100$, $N=81$, $\\Delta t = 50.0$；计算 $\\rho(G)$。\n  - 测试 3 (单次迭代分块 Jacobi CN，强对比度和大时间步长): $\\alpha_1 = 1$, $\\alpha_2 = 100$, $N=41$, $\\Delta t = 200.0$；计算 $\\rho(J)$。\n  - 测试 4 (单次迭代分块 Jacobi CN，小时间步长边界情况): $\\alpha_1 = 0.5$, $\\alpha_2 = 2.0$, $N=21$, $\\Delta t = 0.1$；计算 $\\rho(J)$。\n- 您的程序必须为每个测试用例计算谱半径（作为一个浮点数），并按顺序汇总四个结果。\n- 最终输出格式：您的程序应生成单行文本，其中包含一个 Python 风格的列表，内含四个谱半径，每个谱半径四舍五入到小数点后六位，无任何附加文本。例如，输出行的形式为 $\\left[ r_1, r_2, r_3, r_4 \\right]$，其中每个 $r_i$ 都精确打印到小数点后六位。\n\n约束和注意事项：\n- 仅使用从推导公式中明确定义的线性代数运算；不要使用任何预先计算的稳定性公式。\n- 不涉及角度，也没有物理单位；所有量都是无量纲的。\n- 通过使用奇数 $N$ 以使 $k = \\frac{N+1}{2}$ 为整数，确保您的实现遵循界面对齐约束。",
            "solution": "所述问题具有科学依据，是适定且自洽的。它提出了一个计算科学中标准而全面的问题，要求推导和实现一个用于耦合 PDE 系统的数值格式，并分析其稳定性。所有参数和方法都得到了清晰的定义，从而可以得到唯一且可验证的解。\n\n### 任务 1：半离散矩阵 $A$ 的推导及通量连续性\n\n控制偏微分方程 (PDE) 是 $\\partial_t u = \\partial_x (\\alpha(x) \\partial_x u)$。将该方程在一个以网格节点 $x_i$ 为中心的控制体积（或单元）上进行积分，从 $x_{i-1/2} = x_i - h/2$ 到 $x_{i+1/2} = x_i + h/2$，其中 $h$ 是均匀网格间距，可得：\n$$ \\int_{x_{i-1/2}}^{x_{i+1/2}} \\partial_t u \\, dx = \\int_{x_{i-1/2}}^{x_{i+1/2}} \\partial_x (\\alpha(x) \\partial_x u) \\, dx $$\n用节点值 $u_i(t) = u(x_i, t)$ 的时间导数来近似单元平均值 $\\bar{u}_i(t) = \\frac{1}{h} \\int_{x_{i-1/2}}^{x_{i+1/2}} u(x,t) dx$ 的时间导数，我们得到 $h \\frac{du_i}{dt}$。根据微积分基本定理，右侧是单元面上的通量 $F(x,t) = -\\alpha(x) \\partial_x u(x,t)$ 之差：\n$$ \\int_{x_{i-1/2}}^{x_{i+1/2}} \\partial_x (-\\alpha(x) \\partial_x u) \\, dx = -[F(x_{i+1/2}) - F(x_{i-1/2})] = F(x_{i-1/2}) - F(x_{i+1/2}) $$\n通过近似这些通量，可以得到有限差分半离散化。对于位于节点 $i$ 和 $i+1$ 之间的面 $x_{i+1/2}$，通量近似为 $F_{i+1/2} \\approx -\\alpha_{i+1/2} \\frac{u_{i+1} - u_i}{h}$。将这些结合起来，得到每个内部节点 $i$ 的半离散 ODE：\n$$ \\frac{du_i}{dt} = \\frac{1}{h} (F_{i-1/2} - F_{i+1/2}) \\approx \\frac{1}{h} \\left( -\\alpha_{i-1/2} \\frac{u_i - u_{i-1}}{h} - \\left(-\\alpha_{i+1/2} \\frac{u_{i+1} - u_i}{h}\\right) \\right) $$\n$$ \\frac{du_i}{dt} = \\frac{1}{h^2} \\left( \\alpha_{i+1/2}(u_{i+1} - u_i) - \\alpha_{i-1/2}(u_i - u_{i-1}) \\right) $$\n这与为 $(A \\mathbf{u})_i$ 提供的表达式相匹配。此格式是守恒的，因为在面 $i+1/2$ 处离开单元 $i$ 的通量 $-F_{i+1/2}$，与在同一面进入单元 $i+1$ 的通量完全相同。\n\n在材料界面处，物理条件是温度的连续性 $u(x^*) = u(x^*-) = u(x^*+)$ 和热通量的连续性 $F(x^*) = F(x^*-) = F(x^*+)$，这意味着 $-\\alpha(x^*-)\\partial_x u|_{x^*-} = -\\alpha(x^*+)\\partial_x u|_{x^*+}$。\n在我们的离散化中，通过在每个节点上使用单一未知数 $u_i$，而不在界面处分割值，温度的连续性得到了内在的满足。\n通量的连续性通过在界面处对面心系数 $\\alpha_{i+1/2}$ 的选择来强制执行。在材料 1 和 2 之间的界面处（假设位于 $x_{k+1/2}$），我们有 $\\alpha(x_{k+1/2}-) = \\alpha_1$ 和 $\\alpha(x_{k+1/2}+) = \\alpha_2$。为了找到一个能够正确模拟通量的有效扩散系数 $\\alpha_{k+1/2}$，我们考虑节点 $k$ 和 $k+1$ 之间的稳态通量。热流阻是可加的。从 $x_k$到 $x_{k+1/2}$ 的阻力是 $\\frac{h/2}{\\alpha_1}$，从 $x_{k+1/2}$ 到 $x_{k+1}$ 的阻力是 $\\frac{h/2}{\\alpha_2}$。在距离 $h$ 上的总阻力是 $\\frac{h/2}{\\alpha_1} + \\frac{h/2}{\\alpha_2}$。有效扩散系数 $\\alpha_{k+1/2}$ 应满足 $\\frac{h}{\\alpha_{k+1/2}} = \\frac{h/2}{\\alpha_1} + \\frac{h/2}{\\alpha_2}$，这给出 $\\frac{1}{\\alpha_{k+1/2}} = \\frac{1}{2}\\left(\\frac{1}{\\alpha_1} + \\frac{1}{\\alpha_2}\\right)$。这就是调和平均：\n$$ \\alpha_{k+1/2} = \\frac{2 \\alpha_1 \\alpha_2}{\\alpha_1 + \\alpha_2} $$\n使用这个值可以确保离散通量 $F_{k+1/2} = -\\alpha_{k+1/2} \\frac{u_{k+1}-u_k}{h}$ 正确地模拟了跨材料不连续处的物理通量连续性。\n\n矩阵 $A$ 是一个由该算子定义的 $N \\times N$ 三对角矩阵。对于第 $j$ 行（使用基于 1 的索引, $j \\in \\{1,\\dots,N\\}$），其元素为：\n$$ A_{j,j-1} = \\frac{\\alpha_{j-1/2}}{h^2}, \\quad A_{j,j} = -\\frac{\\alpha_{j-1/2} + \\alpha_{j+1/2}}{h^2}, \\quad A_{j,j+1} = \\frac{\\alpha_{j+1/2}}{h^2} $$\n并满足边界条件 $u_0=0$ 和 $u_{N+1}=0$。面系数 $\\alpha_{j+1/2}$ 的值是：如果节点 $j$ 和 $j+1$ 都在材料 1 中，则为 $\\alpha_1$；如果都在材料 2 中，则为 $\\alpha_2$；如果节点 $j$ 在材料 1 中而节点 $j+1$ 在材料 2 中，则为调和平均值。鉴于界面位于节点 $k$ 和 $k+1$ 之间，$\\alpha_{k+1/2}$ 是调和平均值。\n\n### 任务 2：整体式 Crank-Nicolson 放大算子 $G$\n\nCrank-Nicolson (CN) 方法应用于半离散系统 $\\frac{d\\mathbf{u}}{dt} = A \\mathbf{u}$，由时间积分的梯形法则推导而来：\n$$ \\frac{\\mathbf{u}^{n+1} - \\mathbf{u}^n}{\\Delta t} = \\frac{1}{2} (A \\mathbf{u}^{n+1} + A \\mathbf{u}^n) $$\n重新整理此方程，将含 $\\mathbf{u}^{n+1}$ 的项归于左侧，含 $\\mathbf{u}^n$ 的项归于右侧：\n$$ \\mathbf{u}^{n+1} - \\frac{\\Delta t}{2} A \\mathbf{u}^{n+1} = \\mathbf{u}^n + \\frac{\\Delta t}{2} A \\mathbf{u}^n $$\n将向量 $\\mathbf{u}^{n+1}$ 和 $\\mathbf{u}^n$ 因子提出：\n$$ \\left(I - \\frac{\\Delta t}{2} A\\right) \\mathbf{u}^{n+1} = \\left(I + \\frac{\\Delta t}{2} A\\right) \\mathbf{u}^n $$\n单步放大算子 $G$ 由关系 $\\mathbf{u}^{n+1} = G \\mathbf{u}^n$ 定义。为了求得 $G$，我们通过将两侧都乘以左侧矩阵的逆来解出 $\\mathbf{u}^{n+1}$。对于扩散问题，矩阵 $A$ 是对称负半定的，因此其特征值为非正数。因此，$I - \\frac{\\Delta t}{2}A$ 的所有特征值都大于或等于 1，这保证了其可逆性。\n$$ \\mathbf{u}^{n+1} = \\left(I - \\frac{\\Delta t}{2} A\\right)^{-1} \\left(I + \\frac{\\Delta t}{2} A\\right) \\mathbf{u}^n $$\n通过观察，整体式放大算子为：\n$$ G = \\left(I - \\frac{\\Delta t}{2} A\\right)^{-1} \\left(I + \\frac{\\Delta t}{2} A\\right) $$\n\n### 任务 3：单次迭代分块 Jacobi CN 放大算子 $J$\n\n我们从以分块形式写出的 CN 格式开始，根据划分 $\\mathbf{u} = \\begin{bmatrix} \\mathbf{u}_1 \\\\ \\mathbf{u}_2 \\end{bmatrix}$ 和 $A = \\begin{bmatrix} A_{11} & A_{12} \\\\ A_{21} & A_{22} \\end{bmatrix}$：\n$$ \\left(\\begin{bmatrix} I_1 & 0 \\\\ 0 & I_2 \\end{bmatrix} - \\frac{\\Delta t}{2} \\begin{bmatrix} A_{11} & A_{12} \\\\ A_{21} & A_{22} \\end{bmatrix}\\right) \\begin{bmatrix} \\mathbf{u}_1^{n+1} \\\\ \\mathbf{u}_2^{n+1} \\end{bmatrix} = \\left(\\begin{bmatrix} I_1 & 0 \\\\ 0 & I_2 \\end{bmatrix} + \\frac{\\Delta t}{2} \\begin{bmatrix} A_{11} & A_{12} \\\\ A_{21} & A_{22} \\end{bmatrix}\\right) \\begin{bmatrix} \\mathbf{u}_1^{n} \\\\ \\mathbf{u}_2^{n} \\end{bmatrix} $$\n展开为一个关于 $\\mathbf{u}_1^{n+1}$ 和 $\\mathbf{u}_2^{n+1}$ 的耦合系统：\n$$ \\begin{cases} (I_1 - \\frac{\\Delta t}{2} A_{11}) \\mathbf{u}_1^{n+1} - \\frac{\\Delta t}{2} A_{12} \\mathbf{u}_2^{n+1} = (I_1 + \\frac{\\Delta t}{2} A_{11}) \\mathbf{u}_1^n + \\frac{\\Delta t}{2} A_{12} \\mathbf{u}_2^n \\\\ -\\frac{\\Delta t}{2} A_{21} \\mathbf{u}_1^{n+1} + (I_2 - \\frac{\\Delta t}{2} A_{22}) \\mathbf{u}_2^{n+1} = \\frac{\\Delta t}{2} A_{21} \\mathbf{u}_1^n + (I_2 + \\frac{\\Delta t}{2} A_{22}) \\mathbf{u}_2^n \\end{cases} $$\n用于求解此线性系统 $\\mathbf{u}^{n+1}$ 的分块 Jacobi 迭代将非对角耦合项（涉及 $A_{12}$ 和 $A_{21}$）移至右侧，并使用上一次迭代的值进行计算。对于从 $\\mathbf{u}^{n+1,(0)} = \\mathbf{u}^n$ 开始的单次迭代，我们在时间层 $n$ 上计算非对角项：\n$$ \\begin{cases} (I_1 - \\frac{\\Delta t}{2} A_{11}) \\mathbf{u}_1^{n+1} = (I_1 + \\frac{\\Delta t}{2} A_{11}) \\mathbf{u}_1^n + \\frac{\\Delta t}{2} A_{12} \\mathbf{u}_2^n + \\frac{\\Delta t}{2} A_{12} \\mathbf{u}_2^n \\\\ (I_2 - \\frac{\\Delta t}{2} A_{22}) \\mathbf{u}_2^{n+1} = (I_2 + \\frac{\\Delta t}{2} A_{22}) \\mathbf{u}_2^n + \\frac{\\Delta t}{2} A_{21} \\mathbf{u}_1^n + \\frac{\\Delta t}{2} A_{21} \\mathbf{u}_1^n \\end{cases} $$\n简化右侧：\n$$ \\begin{cases} (I_1 - \\frac{\\Delta t}{2} A_{11}) \\mathbf{u}_1^{n+1} = (I_1 + \\frac{\\Delta t}{2} A_{11}) \\mathbf{u}_1^n + \\Delta t A_{12} \\mathbf{u}_2^n \\\\ (I_2 - \\frac{\\Delta t}{2} A_{22}) \\mathbf{u}_2^{n+1} = \\Delta t A_{21} \\mathbf{u}_1^n + (I_2 + \\frac{\\Delta t}{2} A_{22}) \\mathbf{u}_2^n \\end{cases} $$\n我们通过对左侧的分块对角矩阵求逆来求解 $\\mathbf{u}_1^{n+1}$ 和 $\\mathbf{u}_2^{n+1}$：\n$$ \\mathbf{u}_1^{n+1} = (I_1 - \\frac{\\Delta t}{2} A_{11})^{-1} (I_1 + \\frac{\\Delta t}{2} A_{11}) \\mathbf{u}_1^n + (I_1 - \\frac{\\Delta t}{2} A_{11})^{-1} (\\Delta t A_{12}) \\mathbf{u}_2^n $$\n$$ \\mathbf{u}_2^{n+1} = (I_2 - \\frac{\\Delta t}{2} A_{22})^{-1} (\\Delta t A_{21}) \\mathbf{u}_1^n + (I_2 - \\frac{\\Delta t}{2} A_{22})^{-1} (I_2 + \\frac{\\Delta t}{2} A_{22}) \\mathbf{u}_2^n $$\n将其写成矩阵形式 $\\mathbf{u}^{n+1} = J \\mathbf{u}^n$，我们识别出分块放大算子 $J$：\n$$ J = \\begin{bmatrix}\n(I_1 - \\frac{\\Delta t}{2} A_{11})^{-1}(I_1 + \\frac{\\Delta t}{2} A_{11}) & \\Delta t (I_1 - \\frac{\\Delta t}{2} A_{11})^{-1} A_{12} \\\\\n\\Delta t (I_2 - \\frac{\\Delta t}{2} A_{22})^{-1} A_{21} & (I_2 - \\frac{\\Delta t}{2} A_{22})^{-1}(I_2 + \\frac{\\Delta t}{2} A_{22})\n\\end{bmatrix} $$\n\n### 任务 4：谱半径与稳定性分析\n\n对于形式为 $\\mathbf{u}^{n+1} = X \\mathbf{u}^n$ 的线性单步数值方法，其中 $X$ 是放大算子（或矩阵），$n$ 个时间步后的解由 $\\mathbf{u}^n = X^n \\mathbf{u}^0$ 给出。方法的稳定性取决于当 $n \\to \\infty$ 时矩阵幂 $X^n$ 的行为。\n\n$X^n$ 的行为由 $X$ 的特征值决定。设 $\\{\\lambda_i\\}$ 是 $X$ 的特征值，$\\{\\mathbf{v}_i\\}$ 是相应的特征向量，它们构成一个基（假设 $X$ 可对角化）。任何初始条件 $\\mathbf{u}^0$ 都可以写成这些特征向量的线性组合：$\\mathbf{u}^0 = \\sum_i c_i \\mathbf{v}_i$。\n应用算子 $n$ 次可得：\n$$ \\mathbf{u}^n = X^n \\mathbf{u}^0 = X^n \\left(\\sum_i c_i \\mathbf{v}_i\\right) = \\sum_i c_i (X^n \\mathbf{v}_i) = \\sum_i c_i (\\lambda_i^n \\mathbf{v}_i) $$\n为使解在 $n$ 增加时保持有界，任何分量都不能无界增长。这要求对所有特征值 $\\lambda_i$，其 $|\\lambda_i^n| = |\\lambda_i|^n$ 保持有界。此条件当且仅当对所有 $i$ 都有 $|\\lambda_i| \\le 1$ 时满足。如果有任何特征值的模大于 1，其在解中对应的分量将指数增长，导致数值不稳定。\n\n矩阵 $X$ 的谱半径，记为 $\\rho(X)$，定义为其特征值的绝对值（或复数特征值的模）的最大值：$\\rho(X) = \\max_i |\\lambda_i|$。\n因此，单步法 $\\mathbf{u}^{n+1} = X \\mathbf{u}^n$ 的线性稳定性条件是其谱半径必须满足：\n$$ \\rho(X) \\le 1 $$\n这使得放大算子的谱半径成为评估数值格式线性稳定性的主要指标。对于整体式 Crank-Nicolson 方法，已知对于负半定矩阵 $A$，$\\rho(G) \\le 1$ 无条件成立，从而保证了稳定性。对于分块迭代格式，稳定性不是无条件保证的，它取决于参数，这使得计算 $\\rho(J)$ 变得至关重要。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef construct_A(N, L1, L2, alpha1, alpha2):\n    \"\"\"\n    Constructs the semi-discrete matrix A for the coupled diffusion problem.\n    \"\"\"\n    L = L1 + L2\n    h = L / (N + 1)\n    k = int(round((N + 1) * L1 / L))  # 1-based index of the interface node\n\n    # Face diffusivity coefficients alpha_{j+1/2}.\n    # The interface is between node k and k+1 (1-based).\n    # This corresponds to the face between index k-1 and k (0-based).\n    alpha_h = (2 * alpha1 * alpha2) / (alpha1 + alpha2)\n    \n    # 0-based indexing for arrays\n    k0 = k - 1 # 0-based index of the interface node\n    \n    # alpha_half[i] stores alpha at the face between node i and i+1\n    alpha_half = np.zeros(N - 1)\n    if k0 > 0:\n        alpha_half[:k0] = alpha1\n    if k0 < N-1:\n        alpha_half[k0] = alpha_h\n        alpha_half[k0+1:] = alpha2\n\n    h2 = h * h\n    \n    # Construct tridiagonal matrix A components\n    # Upper diagonal: A[i, i+1] corresponds to alpha_{i+1/2}\n    v_upper = alpha_half / h2\n    # Lower diagonal: A[i, i-1] corresponds to alpha_{i-1/2}\n    v_lower = alpha_half / h2\n\n    # Main diagonal: A[i, i] is -(alpha_{i+1/2} + alpha_{i-1/2})\n    v_main = np.zeros(N)\n    # At node 0, alpha_{-1/2} is for face at x=h/2 from boundary, which is in material 1.\n    v_main[0] = -(alpha1 + alpha_half[0])\n    # For internal nodes\n    if N > 2:\n        v_main[1:N-1] = -(alpha_half[0:N-2] + alpha_half[1:N-1])\n    # At node N-1, alpha_{N-1/2} is alpha_half[N-2].\n    # alpha_{N+1/2} is for face at x=L-h/2 from boundary, in material 2.\n    if N > 1:\n        v_main[N-1] = -(alpha_half[N-2] + alpha2)\n    \n    v_main /= h2\n    \n    A = np.diag(v_main) + np.diag(v_upper, 1) + np.diag(v_lower, -1)\n    \n    return A, k\n\ndef compute_rho_G(A, dt):\n    \"\"\"\n    Computes the spectral radius of the monolithic Crank-Nicolson operator G.\n    \"\"\"\n    N = A.shape[0]\n    I = np.identity(N)\n    \n    M_left = I - (dt / 2.0) * A\n    M_right = I + (dt / 2.0) * A\n    \n    # G = inv(M_left) @ M_right\n    G = np.linalg.solve(M_left, M_right) # More stable than explicit inverse\n    \n    eigenvalues = np.linalg.eigvals(G)\n    spectral_radius = np.max(np.abs(eigenvalues))\n    \n    return spectral_radius\n\ndef compute_rho_J(A, k, dt):\n    \"\"\"\n    Computes the spectral radius of the one-iteration block-Jacobi CN operator J.\n    \"\"\"\n    N = A.shape[0]\n    \n    # Partition A into blocks\n    A11 = A[0:k, 0:k]\n    A12 = A[0:k, k:N]\n    A21 = A[k:N, 0:k]\n    A22 = A[k:N, k:N]\n    \n    I1 = np.identity(k)\n    I2 = np.identity(N - k)\n    \n    # Calculate terms for the blocks of J\n    # M1_inv = inv(I1 - dt/2 * A11)\n    # M2_inv = inv(I2 - dt/2 * A22)\n    M1_left = I1 - (dt / 2.0) * A11\n    M2_left = I2 - (dt / 2.0) * A22\n    \n    # Construct blocks of J\n    # J11 = M1_inv @ (I1 + dt/2 * A11)\n    J11 = np.linalg.solve(M1_left, I1 + (dt / 2.0) * A11)\n    # J12 = dt * M1_inv @ A12\n    J12 = np.linalg.solve(M1_left, dt * A12)\n    # J21 = dt * M2_inv @ A21\n    J21 = np.linalg.solve(M2_left, dt * A21)\n    # J22 = M2_inv @ (I2 + dt/2 * A22)\n    J22 = np.linalg.solve(M2_left, I2 + (dt / 2.0) * A22)\n\n    # Assemble the full matrix J\n    J = np.block([[J11, J12], [J21, J22]])\n    \n    eigenvalues = np.linalg.eigvals(J)\n    spectral_radius = np.max(np.abs(eigenvalues))\n    \n    return spectral_radius\n    \ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the results.\n    \"\"\"\n    # Fixed parameters\n    L1, L2 = 1.0, 1.0\n\n    test_cases = [\n        {'alpha1': 1.0, 'alpha2': 10.0, 'N': 41, 'dt': 2.0, 'type': 'G'},\n        {'alpha1': 1.0, 'alpha2': 100.0, 'N': 81, 'dt': 50.0, 'type': 'G'},\n        {'alpha1': 1.0, 'alpha2': 100.0, 'N': 41, 'dt': 200.0, 'type': 'J'},\n        {'alpha1': 0.5, 'alpha2': 2.0, 'N': 21, 'dt': 0.1, 'type': 'J'}\n    ]\n\n    results = []\n    for case in test_cases:\n        N = case['N']\n        alpha1 = case['alpha1']\n        alpha2 = case['alpha2']\n        dt = case['dt']\n        \n        A, k = construct_A(N, L1, L2, alpha1, alpha2)\n        \n        if case['type'] == 'G':\n            spectral_radius = compute_rho_G(A, dt)\n        elif case['type'] == 'J':\n            spectral_radius = compute_rho_J(A, k, dt)\n        \n        results.append(spectral_radius)\n\n    # Format results to exactly six decimal places\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}