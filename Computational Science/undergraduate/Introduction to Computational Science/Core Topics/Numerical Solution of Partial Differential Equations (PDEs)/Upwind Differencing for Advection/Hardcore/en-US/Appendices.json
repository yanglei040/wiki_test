{
    "hands_on_practices": [
        {
            "introduction": "Applying a numerical scheme to a differential equation is the foundational skill in computational science. This exercise provides direct practice in discretizing a steady-state advection-diffusion equation, a common model in fluid dynamics and heat transfer. By applying the first-order upwind scheme for the advection term, you will learn how to translate a continuous PDE into a system of algebraic equations, a crucial first step toward finding a numerical solution .",
            "id": "1127421",
            "problem": "Consider the one-dimensional steady-state advection-diffusion equation on the domain $x \\in [0, L]$:\n$$\nu \\frac{d\\phi}{dx} - \\Gamma \\frac{d^2\\phi}{dx^2} = S_0\n$$\nHere, $u > 0$ is a constant velocity, $\\Gamma > 0$ is a constant diffusivity, and $S_0$ is a constant source term. The boundary conditions are given by $\\phi(0) = \\phi_A$ and $\\phi(L) = \\phi_B$.\n\nThe domain is discretized using a uniform grid with $N=4$ intervals, resulting in grid points $x_i = i\\Delta x$ for $i=0, 1, 2, 3, 4$, where $\\Delta x = L/N$. Let $\\phi_i$ denote the numerical approximation of $\\phi(x_i)$.\n\nA finite difference method is used to solve for the values of $\\phi_i$ at the interior nodes ($i=1, 2, 3$). The diffusion term is approximated using a second-order central difference scheme. Due to the advection-dominated nature of the problem, the advection term is approximated using a first-order upwind scheme (or \"upwind differencing scheme\", UDS). Given that $u>0$, the flow is from left to right.\n\nUsing this numerical scheme, determine the value of the solution at the midpoint of the domain, $\\phi_2 = \\phi(x_2 = L/2)$. Express your answer as a single symbolic expression in terms of the given parameters $u, \\Gamma, S_0, L, \\phi_A$, and $\\phi_B$.",
            "solution": "The problem asks for the numerical solution $\\phi_2$ at the grid point $x_2=L/2$ for the given advection-diffusion equation. The domain is discretized into $N=4$ intervals, so the grid spacing is $\\Delta x = L/4$. The grid points are $x_0=0, x_1=L/4, x_2=L/2, x_3=3L/4, x_4=L$. The unknowns are the values at the interior nodes: $\\phi_1, \\phi_2, \\phi_3$. The boundary values are known: $\\phi_0 = \\phi_A$ and $\\phi_4 = \\phi_B$.\n\nThe steady-state advection-diffusion equation is:\n$$u \\frac{d\\phi}{dx} - \\Gamma \\frac{d^2\\phi}{dx^2} = S_0$$\n\nWe discretize this equation at an interior grid point $x_i$.\nThe diffusion term is discretized using a second-order central difference scheme:\n$$ \\left.\\frac{d^2\\phi}{dx^2}\\right|_{x_i} \\approx \\frac{\\phi_{i+1} - 2\\phi_i + \\phi_{i-1}}{(\\Delta x)^2} $$\nThe advection term is discretized using a first-order upwind scheme. Since $u > 0$, the flow is from left to right, so we use the value from \"upwind\" (i.e., from the left):\n$$ \\left.\\frac{d\\phi}{dx}\\right|_{x_i} \\approx \\frac{\\phi_i - \\phi_{i-1}}{\\Delta x} $$\n\nSubstituting these approximations into the PDE, we get the discretized equation for an interior node $i$:\n$$ u \\left(\\frac{\\phi_i - \\phi_{i-1}}{\\Delta x}\\right) - \\Gamma \\left(\\frac{\\phi_{i+1} - 2\\phi_i + \\phi_{i-1}}{(\\Delta x)^2}\\right) = S_0 $$\nThis equation is valid for $i=1, 2, 3$.\n\nTo simplify, let's multiply the entire equation by $(\\Delta x)^2$:\n$$ u \\Delta x (\\phi_i - \\phi_{i-1}) - \\Gamma (\\phi_{i+1} - 2\\phi_i + \\phi_{i-1}) = S_0 (\\Delta x)^2 $$\nNow, we group the terms by $\\phi_{i-1}$, $\\phi_i$, and $\\phi_{i+1}$:\n$$ (-u \\Delta x - \\Gamma) \\phi_{i-1} + (u \\Delta x + 2\\Gamma) \\phi_i - \\Gamma \\phi_{i+1} = S_0 (\\Delta x)^2 $$\nThis equation can be written as a tridiagonal system. Let's write it down for each interior node ($i=1, 2, 3$):\n\nFor $i=1$:\n$$ (-u \\Delta x - \\Gamma) \\phi_0 + (u \\Delta x + 2\\Gamma) \\phi_1 - \\Gamma \\phi_2 = S_0 (\\Delta x)^2 $$\nSince $\\phi_0 = \\phi_A$, we have:\n$$ (u \\Delta x + 2\\Gamma) \\phi_1 - \\Gamma \\phi_2 = S_0 (\\Delta x)^2 + (u \\Delta x + \\Gamma) \\phi_A \\quad (1) $$\n\nFor $i=2$:\n$$ (-u \\Delta x - \\Gamma) \\phi_1 + (u \\Delta x + 2\\Gamma) \\phi_2 - \\Gamma \\phi_3 = S_0 (\\Delta x)^2 \\quad (2) $$\n\nFor $i=3$:\n$$ (-u \\Delta x - \\Gamma) \\phi_2 + (u \\Delta x + 2\\Gamma) \\phi_3 - \\Gamma \\phi_4 = S_0 (\\Delta x)^2 $$\nSince $\\phi_4 = \\phi_B$, we have:\n$$ (-u \\Delta x - \\Gamma) \\phi_2 + (u \\Delta x + 2\\Gamma) \\phi_3 = S_0 (\\Delta x)^2 + \\Gamma \\phi_B \\quad (3) $$\n\nWe have a system of three linear equations for the three unknowns $\\phi_1, \\phi_2, \\phi_3$. We need to solve for $\\phi_2$. It is convenient to use substitution. Let's isolate $\\phi_1$ from (1) and $\\phi_3$ from (3):\n\nFrom (1):\n$$ \\phi_1 = \\frac{S_0 (\\Delta x)^2 + (u \\Delta x + \\Gamma) \\phi_A + \\Gamma \\phi_2}{u \\Delta x + 2\\Gamma} $$\n\nFrom (3):\n$$ \\phi_3 = \\frac{S_0 (\\Delta x)^2 + \\Gamma \\phi_B + (u \\Delta x + \\Gamma) \\phi_2}{u \\Delta x + 2\\Gamma} $$\n\nNow, substitute these expressions for $\\phi_1$ and $\\phi_3$ into equation (2):\n$$ -(u \\Delta x + \\Gamma) \\left( \\frac{S_0 (\\Delta x)^2 + (u \\Delta x + \\Gamma) \\phi_A + \\Gamma \\phi_2}{u \\Delta x + 2\\Gamma} \\right) + (u \\Delta x + 2\\Gamma) \\phi_2 - \\Gamma \\left( \\frac{S_0 (\\Delta x)^2 + \\Gamma \\phi_B + (u \\Delta x + \\Gamma) \\phi_2}{u \\Delta x + 2\\Gamma} \\right) = S_0 (\\Delta x)^2 $$\n\nMultiply the entire equation by $(u \\Delta x + 2\\Gamma)$ to clear the denominators:\n$$ -(u \\Delta x + \\Gamma) \\left[ S_0 (\\Delta x)^2 + (u \\Delta x + \\Gamma) \\phi_A + \\Gamma \\phi_2 \\right] + (u \\Delta x + 2\\Gamma)^2 \\phi_2 - \\Gamma \\left[ S_0 (\\Delta x)^2 + \\Gamma \\phi_B + (u \\Delta x + \\Gamma) \\phi_2 \\right] = S_0 (\\Delta x)^2 (u \\Delta x + 2\\Gamma) $$\n\nNow, collect all terms with $\\phi_2$ on the left-hand side and all other terms on the right-hand side:\n$$ \\phi_2 \\left[ -(u \\Delta x + \\Gamma)\\Gamma + (u \\Delta x + 2\\Gamma)^2 - \\Gamma(u \\Delta x + \\Gamma) \\right] = S_0 (\\Delta x)^2 (u \\Delta x + 2\\Gamma) + (u \\Delta x + \\Gamma)(S_0 (\\Delta x)^2 + (u \\Delta x + \\Gamma)\\phi_A) + \\Gamma(S_0 (\\Delta x)^2 + \\Gamma\\phi_B) $$\n\nSimplify the coefficient of $\\phi_2$:\n$$ \\text{Coeff}(\\phi_2) = (u \\Delta x + 2\\Gamma)^2 - 2\\Gamma(u \\Delta x + \\Gamma) $$\n$$ = (u^2(\\Delta x)^2 + 4u\\Delta x\\Gamma + 4\\Gamma^2) - (2u\\Delta x\\Gamma + 2\\Gamma^2) $$\n$$ = u^2(\\Delta x)^2 + 2u\\Delta x\\Gamma + 2\\Gamma^2 $$\n\nSimplify the right-hand side (RHS):\n$$ \\text{RHS} = S_0 (\\Delta x)^2 (u \\Delta x + 2\\Gamma) + S_0 (\\Delta x)^2(u \\Delta x + \\Gamma) + (u \\Delta x + \\Gamma)^2 \\phi_A + S_0 (\\Delta x)^2 \\Gamma + \\Gamma^2 \\phi_B $$\n$$ = S_0 (\\Delta x)^2 (u \\Delta x + 2\\Gamma + u \\Delta x + \\Gamma + \\Gamma) + (u \\Delta x + \\Gamma)^2 \\phi_A + \\Gamma^2 \\phi_B $$\n$$ = S_0 (\\Delta x)^2 (2u \\Delta x + 4\\Gamma) + (u \\Delta x + \\Gamma)^2 \\phi_A + \\Gamma^2 \\phi_B $$\n$$ = 2S_0 (\\Delta x)^2 (u \\Delta x + 2\\Gamma) + (u \\Delta x + \\Gamma)^2 \\phi_A + \\Gamma^2 \\phi_B $$\n\nNow, solve for $\\phi_2$:\n$$ \\phi_2 = \\frac{2S_0 (\\Delta x)^2 (u \\Delta x + 2\\Gamma) + (u \\Delta x + \\Gamma)^2 \\phi_A + \\Gamma^2 \\phi_B}{u^2(\\Delta x)^2 + 2u\\Delta x\\Gamma + 2\\Gamma^2} $$\n\nFinally, we substitute $\\Delta x = L/4$:\n$u \\Delta x = uL/4$ and $(\\Delta x)^2 = L^2/16$.\n\nNumerator:\n$$ \\text{Num} = 2S_0 \\frac{L^2}{16} \\left(\\frac{uL}{4} + 2\\Gamma\\right) + \\left(\\frac{uL}{4} + \\Gamma\\right)^2 \\phi_A + \\Gamma^2 \\phi_B $$\n$$ = \\frac{S_0 L^2}{8} \\left(\\frac{uL+8\\Gamma}{4}\\right) + \\left(\\frac{uL+4\\Gamma}{4}\\right)^2 \\phi_A + \\Gamma^2 \\phi_B $$\n$$ = \\frac{S_0 L^2(uL+8\\Gamma)}{32} + \\frac{(uL+4\\Gamma)^2}{16} \\phi_A + \\Gamma^2 \\phi_B $$\nTo combine terms, use a common denominator of 32:\n$$ = \\frac{1}{32} \\left[ S_0 L^2(uL+8\\Gamma) + 2(uL+4\\Gamma)^2 \\phi_A + 32\\Gamma^2 \\phi_B \\right] $$\n\nDenominator:\n$$ \\text{Denom} = u^2 \\left(\\frac{L^2}{16}\\right) + 2u\\left(\\frac{L}{4}\\right)\\Gamma + 2\\Gamma^2 $$\n$$ = \\frac{u^2 L^2}{16} + \\frac{uL\\Gamma}{2} + 2\\Gamma^2 $$\nUse a common denominator of 16:\n$$ = \\frac{1}{16} \\left[ u^2 L^2 + 8uL\\Gamma + 32\\Gamma^2 \\right] $$\n\nNow, compute the fraction $\\phi_2 = \\text{Num}/\\text{Denom}$:\n$$ \\phi_2 = \\frac{\\frac{1}{32} \\left[ S_0 L^2(uL+8\\Gamma) + 2(uL+4\\Gamma)^2 \\phi_A + 32\\Gamma^2 \\phi_B \\right]}{\\frac{1}{16} \\left[ u^2 L^2 + 8uL\\Gamma + 32\\Gamma^2 \\right]} $$\n$$ \\phi_2 = \\frac{16}{32} \\frac{S_0 L^2(uL+8\\Gamma) + 2(uL+4\\Gamma)^2 \\phi_A + 32\\Gamma^2 \\phi_B}{u^2 L^2 + 8uL\\Gamma + 32\\Gamma^2} $$\n$$ \\phi_2 = \\frac{S_0 L^2(uL+8\\Gamma) + 2(uL+4\\Gamma)^2 \\phi_A + 32\\Gamma^2 \\phi_B}{2(u^2 L^2 + 8uL\\Gamma + 32\\Gamma^2)} $$\nThis is the final expression for $\\phi_2$.",
            "answer": "$$ \\boxed{\\frac{S_0 L^2(uL+8\\Gamma) + 2(uL+4\\Gamma)^2 \\phi_A + 32\\Gamma^2 \\phi_B}{2(u^2 L^2 + 8uL\\Gamma + 32\\Gamma^2)}} $$"
        },
        {
            "introduction": "A numerical method is only useful if it is stable, meaning that small errors do not grow uncontrollably over time. This problem delves into the vital concept of stability using the powerful technique of von Neumann analysis. By analyzing a scheme that runs backward in time, you will uncover why it becomes unconditionally unstable, providing deep insight into the Courant-Friedrichs-Lewy (CFL) condition and the fundamental link between the direction of information flow and numerical stability .",
            "id": "3201511",
            "problem": "Consider the one-dimensional linear advection equation $u_t + a\\,u_x = 0$ on a periodic domain, where $a>0$ is a constant advection speed. A uniform spatial grid with spacing $\\Delta x$ and grid indices $j \\in \\mathbb{Z}$ is used, and the solution is sampled at discrete times $t^n$. To march one step backward in time from $t^n$ to $t^{n-1} = t^n - \\Delta t_b$ (with $\\Delta t_b > 0$), suppose you apply the standard explicit forward-time, upwind-in-space discretization appropriate for $a>0$ but with a negative step, i.e., use\n$$\nu^{n-1}_j \\;=\\; u^{n}_j \\;+\\; \\mu\\left(u^{n}_j - u^{n}_{j-1}\\right),\n$$\nwhere $\\mu = \\dfrac{a\\,\\Delta t_b}{\\Delta x}$.\n\nStarting from the governing equation and the above discrete update, use the von Neumann Fourier stability analysis (Fourier-mode amplification analysis) to derive the amplification factor $G(\\theta)$ of a single backward step, where $\\theta$ is the nondimensional wavenumber associated with the Fourier mode $e^{i\\theta j}$. Then determine the maximum value of $|G(\\theta)|$ over all $\\theta \\in [-\\pi,\\pi]$, and evaluate this maximum numerically for $a=1$, $\\Delta x = 0.1$, and $\\Delta t_b = 0.03$. Provide your final numerical answer rounded to four significant figures. No physical units are required.\n\nIn addition, briefly justify, using first principles of numerical transport, why attempting to reverse advection with an upwind discretization leads to instability in this backward step.",
            "solution": "The problem is first validated to ensure it is scientifically grounded, well-posed, objective, and contains sufficient information for a unique solution. The governing equation is the one-dimensional linear advection equation, $u_t + a\\,u_x = 0$, with a constant advection speed $a>0$. The discretization for a single backward time step from $t^n$ to $t^{n-1} = t^n - \\Delta t_b$ (with $\\Delta t_b > 0$) is given by $u^{n-1}_j = u^{n}_j + \\mu(u^{n}_j - u^{n}_{j-1})$, where $\\mu = \\frac{a\\,\\Delta t_b}{\\Delta x}$. All parameters are defined, and the tasks are clearly specified. The problem is a standard exercise in numerical analysis and is therefore valid.\n\nFirst, we derive the amplification factor $G(\\theta)$ for the given scheme using von Neumann stability analysis. We consider a single Fourier mode for the solution at time level $n$ and spatial grid point $j$:\n$$u_j^n = \\hat{u}^n(\\theta) e^{i\\theta j}$$\nwhere $\\theta = k \\Delta x$ is the non-dimensional wavenumber, $k$ is the wavenumber, and $\\hat{u}^n(\\theta)$ is the amplitude of the mode at time $t^n$. The scheme advances the solution from time $t^n$ to the earlier time $t^{n-1}$. The solution at the new time level $n-1$ is related to the old time level $n$ by the amplification factor $G(\\theta)$:\n$$u_j^{n-1} = G(\\theta) u_j^n = G(\\theta) \\hat{u}^n(\\theta) e^{i\\theta j}$$\nWe substitute these Fourier mode representations into the given finite difference scheme:\n$$u^{n-1}_j = u^{n}_j + \\mu\\left(u^{n}_j - u^{n}_{j-1}\\right)$$\n$$G(\\theta) \\hat{u}^n(\\theta) e^{i\\theta j} = \\hat{u}^n(\\theta) e^{i\\theta j} + \\mu\\left(\\hat{u}^n(\\theta) e^{i\\theta j} - \\hat{u}^n(\\theta) e^{i\\theta (j-1)}\\right)$$\nDividing the entire equation by $\\hat{u}^n(\\theta) e^{i\\theta j}$ (which is non-zero), we obtain the expression for the amplification factor $G(\\theta)$:\n$$G(\\theta) = 1 + \\mu\\left(1 - e^{-i\\theta}\\right)$$\nUsing Euler's formula, $e^{-i\\theta} = \\cos(\\theta) - i\\sin(\\theta)$, we can write $G(\\theta)$ in terms of its real and imaginary parts:\n$$G(\\theta) = 1 + \\mu(1 - (\\cos(\\theta) - i\\sin(\\theta))) = (1 + \\mu(1 - \\cos(\\theta))) + i(\\mu\\sin(\\theta))$$\n\nNext, we determine the magnitude of the amplification factor, $|G(\\theta)|$. The squared magnitude is given by $|G(\\theta)|^2 = (\\text{Re}[G(\\theta)])^2 + (\\text{Im}[G(\\theta)])^2$:\n$$|G(\\theta)|^2 = \\left(1 + \\mu(1 - \\cos(\\theta))\\right)^2 + (\\mu\\sin(\\theta))^2$$\n$$|G(\\theta)|^2 = 1 + 2\\mu(1 - \\cos(\\theta)) + \\mu^2(1 - \\cos(\\theta))^2 + \\mu^2\\sin^2(\\theta)$$\n$$|G(\\theta)|^2 = 1 + 2\\mu - 2\\mu\\cos(\\theta) + \\mu^2(1 - 2\\cos(\\theta) + \\cos^2(\\theta)) + \\mu^2\\sin^2(\\theta)$$\n$$|G(\\theta)|^2 = 1 + 2\\mu - 2\\mu\\cos(\\theta) + \\mu^2 - 2\\mu^2\\cos(\\theta) + \\mu^2(\\cos^2(\\theta) + \\sin^2(\\theta))$$\nUsing the identity $\\cos^2(\\theta) + \\sin^2(\\theta) = 1$:\n$$|G(\\theta)|^2 = 1 + 2\\mu - 2\\mu\\cos(\\theta) + \\mu^2 - 2\\mu^2\\cos(\\theta) + \\mu^2$$\n$$|G(\\theta)|^2 = 1 + 2\\mu + 2\\mu^2 - (2\\mu + 2\\mu^2)\\cos(\\theta)$$\n$$|G(\\theta)|^2 = (1 + 2\\mu + 2\\mu^2) - 2\\mu(1+\\mu)\\cos(\\theta)$$\nTo find the maximum value of $|G(\\theta)|$ over all $\\theta \\in [-\\pi, \\pi]$, we must find the value of $\\theta$ that maximizes $|G(\\theta)|^2$. The problem states that $a>0$, $\\Delta x>0$, and $\\Delta t_b>0$, which implies that $\\mu = \\frac{a\\,\\Delta t_b}{\\Delta x} > 0$. Consequently, the term $2\\mu(1+\\mu)$ multiplying $\\cos(\\theta)$ is positive. Therefore, $|G(\\theta)|^2$ is maximized when $\\cos(\\theta)$ is minimized. The minimum value of $\\cos(\\theta)$ in the interval $[-\\pi, \\pi]$ is $-1$, which occurs at $\\theta = \\pm \\pi$.\nSubstituting $\\cos(\\theta) = -1$ into the expression for $|G(\\theta)|^2$:\n$$\\max_{\\theta} |G(\\theta)|^2 = (1 + 2\\mu + 2\\mu^2) - 2\\mu(1+\\mu)(-1)$$\n$$\\max_{\\theta} |G(\\theta)|^2 = 1 + 2\\mu + 2\\mu^2 + 2\\mu + 2\\mu^2$$\n$$\\max_{\\theta} |G(\\theta)|^2 = 1 + 4\\mu + 4\\mu^2 = (1+2\\mu)^2$$\nThe maximum value of the magnitude $|G(\\theta)|$ is the square root of this expression:\n$$\\max_{\\theta} |G(\\theta)| = \\sqrt{(1+2\\mu)^2} = |1+2\\mu|$$\nSince $\\mu > 0$, this simplifies to:\n$$\\max_{\\theta} |G(\\theta)| = 1 + 2\\mu$$\n\nNow, we evaluate this maximum numerically using the given values: $a=1$, $\\Delta x = 0.1$, and $\\Delta t_b = 0.03$. First, we compute the Courant number $\\mu$:\n$$\\mu = \\frac{a\\,\\Delta t_b}{\\Delta x} = \\frac{1 \\times 0.03}{0.1} = 0.3$$\nSubstituting this value of $\\mu$ into the expression for the maximum amplification factor:\n$$\\max_{\\theta} |G(\\theta)| = 1 + 2(0.3) = 1 + 0.6 = 1.6$$\nRounding to four significant figures as requested, the value is $1.600$.\n\nFinally, we justify why this backward step is unstable. The governing PDE $u_t + a u_x = 0$ with $a>0$ describes a wave propagating information from left to right (in the positive $x$ direction) as time increases. To reverse this process and find the solution at an earlier time $t^{n-1}$ from data at a later time $t^n$, one must trace the information flow backward in time. This means finding the value at $(x_j, t^{n-1})$ requires knowing the solution at a point to its right, specifically $(x_j+a\\Delta t_b, t^n)$, at the later time. A stable numerical method for this backward-in-time problem must therefore use information from grid points to the right (e.g., $u^n_j$ and $u^n_{j+1}$) to compute $u^{n-1}_j$.\nThe provided scheme, $u^{n-1}_j = u^{n}_j + \\mu(u^{n}_j - u^{n}_{j-1})$, uses a backward spatial difference, incorporating information from grid points $j$ and $j-1$. This is an \"upwind\" stencil for the forward-time problem with $a>0$. However, for the time-reversed problem, it is effectively a \"downwind\" stencil, as it takes information from the wrong direction relative to the characteristics. Using a downwind stencil for an explicit advection scheme violates the Courant-Friedrichs-Lewy (CFL) condition, as the physical domain of dependence lies entirely outside the numerical domain of dependence. The von Neumann analysis confirms this instability, showing that the amplification factor $|G(\\theta)|$ has a maximum value of $1+2\\mu$, which is strictly greater than $1$ for any $\\mu > 0$. Any numerical mode with a non-zero amplitude will be amplified in a single step, leading to exponential error growth and unconditional instability.",
            "answer": "$$\n\\boxed{1.600}\n$$"
        },
        {
            "introduction": "Bridging the gap between theory and practice requires not just implementing an algorithm, but also verifying its correctness. This coding exercise guides you through implementing the upwind method and then developing a suite of unit tests to confirm that your code respects the scheme's fundamental mathematical properties, such as conservation and bound preservation. This practice reinforces theoretical concepts in a tangible way and introduces the professional discipline of writing robust, verifiable numerical software .",
            "id": "3201531",
            "problem": "You are to implement and verify the first-order upwind finite difference method for the one-dimensional linear advection equation on a periodic domain. The governing partial differential equation is $u_t + a\\,u_x = 0$ with constant advection speed $a$, where $u(x,t)$ is the advected field. The discretization should be performed on a uniform grid with $N$ points on a periodic interval of length $L$, with grid points $x_i = i\\,\\Delta x$ for $i \\in \\{0,1,\\dots,N-1\\}$ and $\\Delta x = L/N$. Assume $a > 0$ and enforce periodic boundary conditions so that the left neighbor of index $0$ is index $N-1$. Time integration must use a single-step explicit method consistent with first-order upwind differencing; equivalently, work with the Courant-Friedrichs-Lewy (CFL) number $C = a\\,\\Delta t/\\Delta x$ for time step $\\Delta t$ and implement the canonical positive-velocity upwind update. You must not assume any particular analytic solution; instead, verify properties of the discretization itself.\n\nYour task is to write a complete program that:\n1. Implements the first-order upwind scheme on a periodic grid for $a>0$ and a given CFL number $C$.\n2. Executes the following four unit tests, each returning a boolean indicating pass or fail, using the exact parameter values specified below. All comparisons involving floating-point arithmetic must use a tolerance of $\\varepsilon = 10^{-12}$.\n\nTest A (Invariance under constant shift):\n- Parameters: $N = 200$, $L = 1$, $a = 1$, $C = 0.3$, number of time steps $K = 100$.\n- Grid: $x_i = i\\,\\Delta x$ with $\\Delta x = L/N$.\n- Initial condition $u^0_i = \\sin(2\\pi x_i) + 0.2\\cos(4\\pi x_i)$.\n- Constant shift $\\kappa = 0.7$.\n- Run the scheme for $K$ steps for both $u^0$ and $u^0 + \\kappa$. Let $u^{K}$ and $\\tilde{u}^{K}$ denote the two final states. The test passes if $\\max_i \\left| \\left(\\tilde{u}^{K}_i - u^{K}_i\\right) - \\kappa \\right| \\le \\varepsilon$.\n\nTest B (Conservation under periodic boundaries):\n- Parameters: $N = 256$, $L = 2$, $a = 0.8$, $C = 0.6$, number of time steps $K = 150$.\n- Grid: $x_i = i\\,\\Delta x$ with $\\Delta x = L/N$.\n- Initial condition $u^0_i = 0.5 + 0.25\\sin\\!\\left(2\\pi x_i/L\\right) + 0.1\\cos\\!\\left(6\\pi x_i/L\\right)$.\n- Run the scheme for $K$ steps to obtain $u^{K}$. The test passes if $\\left| \\sum_{i=0}^{N-1} u^{K}_i - \\sum_{i=0}^{N-1} u^{0}_i \\right| \\le \\varepsilon$.\n\nTest C (Bound preservation for $0 \\le C \\le 1$):\n- Parameters: $N = 300$, $L = 1$, $a = 1$, $C = 0.95$, number of time steps $K = 400$.\n- Grid: $x_i = i\\,\\Delta x$ with $\\Delta x = L/N$.\n- Initial condition $u^0_i = 0.3 + 0.4\\sin^2(2\\pi x_i)$, so that $\\min_i u^0_i = 0.3$ and $\\max_i u^0_i = 0.7$.\n- Run the scheme for $K$ steps, checking after every step $n$ that $\\min_i u^n_i \\ge 0.3 - \\varepsilon$ and $\\max_i u^n_i \\le 0.7 + \\varepsilon$. The test passes if both inequalities hold for all steps $n \\in \\{1,2,\\dots,K\\}$.\n\nTest D (Exactness at $C=1$ for step translation):\n- Parameters: $N = 128$, $L = 1$, $a = 1$, $C = 1$, number of time steps $K = 37$.\n- Define a step initial condition on the grid indices by choosing $m_0 = 40$ and setting $u^0_i = 1$ if $i  m_0$ and $u^0_i = 0$ otherwise.\n- Run the scheme for $K$ steps to obtain $u^{K}$. For $C = 1$ and $a > 0$, the upwind update becomes a pure cyclic shift by one grid cell per step. The test passes if $u^{K}_i = u^0_{(i-K)\\bmod N}$ for all $i$, up to the tolerance $\\varepsilon$; equivalently, if $\\max_i |u^{K}_i - u^0_{(i-K)\\bmod N}| \\le \\varepsilon$.\n\nImplementation requirements:\n- Use only a uniform periodic grid and the first-order upwind differencing appropriate for $a>0$.\n- Use the specified parameter values exactly as given above.\n- Use the tolerance $\\varepsilon = 10^{-12}$ for all floating-point comparisons.\n\nFinal output format:\nYour program should produce a single line of output containing the four boolean results for Tests A, B, C, and D, in that order, as a comma-separated list enclosed in square brackets (for example, \"[True,False,True,True]\"). The program must be self-contained and must not read any input.\n\nNote: No physical units are required for this problem. All angles appearing in trigonometric functions are in radians. The required output values are strictly booleans.",
            "solution": "The problem is valid as it presents a well-posed, scientifically sound task from computational science: implementing and verifying the first-order upwind method for the linear advection equation. All parameters and conditions are fully specified and consistent.\n\nThe solution proceeds by first deriving the numerical scheme and then implementing the four specified tests, each designed to verify a fundamental property of the discretization.\n\nThe governing partial differential equation (PDE) is the one-dimensional linear advection equation:\n$$\nu_t + a\\,u_x = 0\n$$\nwhere $u(x,t)$ is the advected scalar field, $t$ is time, $x$ is the spatial coordinate, and $a$ is the constant advection speed, which is given to be positive ($a > 0$). The equation is solved on a periodic domain of length $L$.\n\nThe domain is discretized into a uniform grid with $N$ points, indexed by $i \\in \\{0, 1, \\dots, N-1\\}$. The grid points are located at $x_i = i\\,\\Delta x$, where the grid spacing is $\\Delta x = L/N$. The solution on this grid at time $t_n = n\\,\\Delta t$ is denoted by the vector $u^n$, with components $u_i^n \\approx u(x_i, t_n)$.\n\nTo derive the numerical update rule, we discretize the PDE term by term. For the time derivative $u_t$, we use a first-order forward Euler scheme:\n$$\nu_t \\approx \\frac{u_i^{n+1} - u_i^n}{\\Delta t}\n$$\nFor the spatial derivative $u_x$, we use the first-order upwind method. Since the advection speed $a$ is positive, the \"wind\" or information flows from left to right (from smaller $x$ to larger $x$). Therefore, the spatial derivative at grid point $x_i$ should be approximated using the value at $x_i$ and its \"upwind\" neighbor, $x_{i-1}$. This corresponds to a first-order backward difference:\n$$\nu_x \\approx \\frac{u_i^n - u_{i-1}^n}{\\Delta x}\n$$\nSubstituting these discrete approximations into the PDE gives the fully discretized equation:\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} + a \\left( \\frac{u_i^n - u_{i-1}^n}{\\Delta x} \\right) = 0\n$$\nRearranging to solve for the solution at the next time step, $u_i^{n+1}$, yields:\n$$\nu_i^{n+1} = u_i^n - a \\frac{\\Delta t}{\\Delta x} (u_i^n - u_{i-1}^n)\n$$\nWe define the Courant-Friedrichs-Lewy (CFL) number as the dimensionless quantity $C = a\\,\\Delta t/\\Delta x$. Substituting $C$ into the equation gives the final update rule:\n$$\nu_i^{n+1} = u_i^n - C (u_i^n - u_{i-1}^n)\n$$\nThis can be rewritten as:\n$$\nu_i^{n+1} = (1 - C)u_i^n + C u_{i-1}^n\n$$\nThis form is particularly insightful. The problem specifies periodic boundary conditions, which means that the domain wraps around. For the grid point $i=0$, its left neighbor $i-1$ is the last point on the grid, $i=N-1$. This is implemented using modular arithmetic on the indices or, more efficiently, using a cyclic shift operation on the solution vector.\n\nThe four tests verify key properties of this numerical scheme.\n\nTest A (Invariance under constant shift): The scheme is a linear operator acting on the solution vector $u^n$. Let the operator for a single time step be $S_C$, so $u^{n+1} = S_C(u^n)$. The operator for $K$ steps is $S_C^K$. Linearity implies $S_C^K(u^0 + \\kappa \\mathbf{1}) = S_C^K(u^0) + S_C^K(\\kappa \\mathbf{1})$, where $\\mathbf{1}$ is a vector of ones and $\\kappa$ is a constant. For a constant field $u_i^n = \\kappa$ for all $i$, the update rule gives $u_i^{n+1} = (1-C)\\kappa + C\\kappa = \\kappa$. Thus, a constant field is a steady state, and $S_C^K(\\kappa \\mathbf{1}) = \\kappa \\mathbf{1}$. Therefore, the final state of an initially shifted field should be the shifted final state of the original field: $\\tilde{u}^K = u^K + \\kappa$. The test verifies this property by checking if $\\max_i |(\\tilde{u}^K_i - u^K_i) - \\kappa|$ is close to zero.\n\nTest B (Conservation): The scheme conserves the total \"mass\" or sum of a quantity on a periodic domain. Summing the update rule over all grid points $i$ from $0$ to $N-1$:\n$$\n\\sum_{i=0}^{N-1} u_i^{n+1} = \\sum_{i=0}^{N-1} \\left( (1-C)u_i^n + C u_{i-1}^n \\right) = (1-C)\\sum_{i=0}^{N-1} u_i^n + C \\sum_{i=0}^{N-1} u_{i-1}^n\n$$\nDue to periodicity, the set of values $\\{u_{i-1}^n\\}_{i=0}^{N-1}$ is just a cyclic permutation of $\\{u_i^n\\}_{i=0}^{N-1}$, so their sums are identical: $\\sum_{i=0}^{N-1} u_{i-1}^n = \\sum_{i=0}^{N-1} u_i^n$. The equation thus becomes:\n$$\n\\sum_{i=0}^{N-1} u_i^{n+1} = (1-C)\\sum_{i=0}^{N-1} u_i^n + C \\sum_{i=0}^{N-1} u_i^n = \\sum_{i=0}^{N-1} u_i^n\n$$\nThe total sum is conserved at every time step. The test verifies this by comparing the sum of the initial state $\\sum u_i^0$ with the sum of the final state $\\sum u_i^K$.\n\nTest C (Bound preservation): The first-order upwind scheme is known to be positivity-preserving and monotone if the CFL condition $0 \\le C \\le 1$ is satisfied. In this case, both coefficients $(1-C)$ and $C$ in the update rule $u_i^{n+1} = (1-C)u_i^n + C u_{i-1}^n$ are non-negative. The new value $u_i^{n+1}$ is a convex combination of two values from the previous time step, $u_i^n$ and $u_{i-1}^n$. This implies that the new value cannot be smaller than the minimum of all values at time $n$, nor larger than the maximum. Let $m^n = \\min_i u_i^n$ and $M^n = \\max_i u_i^n$. Then $m^n \\le u_i^{n+1} \\le M^n$ for all $i$. Consequently, $m^{n+1} \\ge m^n$ and $M^{n+1} \\le M^n$, meaning the range of solution values will not expand over time. The test uses $C=0.95$, which satisfies the condition. It correctly verifies that the solution remains within the bounds set by the initial condition for all time steps.\n\nTest D (Exactness at $C=1$): When the CFL number is exactly $C=1$, the update rule simplifies dramatically:\n$$\nu_i^{n+1} = (1-1)u_i^n + (1)u_{i-1}^n = u_{i-1}^n\n$$\nThis means that the value at each grid point $i$ is replaced by the value from its left neighbor $i-1$. This corresponds to a perfect, discrete translation of the entire solution profile by one grid cell to the right at each time step, without any change in shape (i.e., no numerical diffusion). After $K$ time steps, the initial profile $u^0$ will be shifted by exactly $K$ grid cells to the right. The test verifies this property by comparing the numerical solution $u^K$ with the initial solution $u^0$ cyclically shifted by $K$ positions, $u^0_{(i-K)\\bmod N}$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and verifies the first-order upwind finite difference method\n    for the 1D linear advection equation by running four unit tests.\n    \"\"\"\n    EPSILON = 1e-12\n\n    def upwind_step(u, C):\n        \"\"\"\n        Performs one step of the first-order upwind scheme for a  0.\n        The update rule is u_i^{n+1} = (1-C)u_i^n + C u_{i-1}^n.\n        This uses u_{i-1}, which means data is flowing from the left (smaller index).\n        np.roll(u, 1) shifts the array to the right, so the new element at index `i`\n        is the old element from index `i-1` (with periodic wrap-around at the boundary).\n        \"\"\"\n        u_prev = np.roll(u, 1)\n        return (1.0 - C) * u + C * u_prev\n\n    def run_simulation(u0, C, K, check_bounds_params=None):\n        \"\"\"\n        Runs the advection simulation for K steps.\n        If check_bounds_params is provided, it performs a check at every step.\n        \"\"\"\n        u = u0.copy()\n        if check_bounds_params:\n            initial_min, initial_max = check_bounds_params\n            for _ in range(K):\n                u = upwind_step(u, C)\n                if np.min(u)  initial_min - EPSILON or np.max(u)  initial_max + EPSILON:\n                    return False  # Indicate bound violation\n            return True  # Indicate all bounds were respected\n        else:\n            for _ in range(K):\n                u = upwind_step(u, C)\n            return u\n\n    def test_a():\n        \"\"\"Test A: Invariance under constant shift.\"\"\"\n        N, L, a, C, K = 200, 1.0, 1.0, 0.3, 100\n        kappa = 0.7\n        x = L * np.arange(N) / N\n        \n        u0 = np.sin(2 * np.pi * x) + 0.2 * np.cos(4 * np.pi * x)\n        u0_shifted = u0 + kappa\n        \n        uK = run_simulation(u0, C, K)\n        uK_tilde = run_simulation(u0_shifted, C, K)\n        \n        max_error = np.max(np.abs((uK_tilde - uK) - kappa))\n        return max_error = EPSILON\n\n    def test_b():\n        \"\"\"Test B: Conservation under periodic boundaries.\"\"\"\n        N, L, a, C, K = 256, 2.0, 0.8, 0.6, 150\n        x = L * np.arange(N) / N\n        \n        u0 = 0.5 + 0.25 * np.sin(2 * np.pi * x / L) + 0.1 * np.cos(6 * np.pi * x / L)\n        \n        uK = run_simulation(u0, C, K)\n        \n        sum_initial = np.sum(u0)\n        sum_final = np.sum(uK)\n        \n        error = np.abs(sum_final - sum_initial)\n        return error = EPSILON\n\n    def test_c():\n        \"\"\"Test C: Bound preservation for 0 = C = 1.\"\"\"\n        N, L, a, C, K = 300, 1.0, 1.0, 0.95, 400\n        x = L * np.arange(N) / N\n        \n        u0 = 0.3 + 0.4 * np.sin(2 * np.pi * x)**2\n        initial_min = 0.3\n        initial_max = 0.7\n        \n        return run_simulation(u0, C, K, check_bounds_params=(initial_min, initial_max))\n\n    def test_d():\n        \"\"\"Test D: Exactness at C=1 for step translation.\"\"\"\n        N, L, a, C, K = 128, 1.0, 1.0, 1.0, 37\n        m0 = 40\n        \n        u0 = np.zeros(N)\n        u0[:m0] = 1.0\n        \n        uK = run_simulation(u0, C, K)\n        \n        # For C=1, the update is u_i^{n+1} = u_{i-1}^n, a pure shift.\n        # After K steps, the solution should be shifted by K grid points to the right.\n        uK_expected = np.roll(u0, K)\n        \n        max_error = np.max(np.abs(uK - uK_expected))\n        return max_error = EPSILON\n\n    results = [\n        test_a(),\n        test_b(),\n        test_c(),\n        test_d(),\n    ]\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}