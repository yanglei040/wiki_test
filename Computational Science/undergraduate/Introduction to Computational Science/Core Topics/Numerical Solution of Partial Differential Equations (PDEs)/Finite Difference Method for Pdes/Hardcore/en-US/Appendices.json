{
    "hands_on_practices": [
        {
            "introduction": "Before trusting any simulation, we must first verify that our code is working correctly. The Method of Manufactured Solutions (MMS) is a powerful technique for this purpose, providing a gold standard for code verification in computational science. By designing a problem with a known analytical solution, we can precisely measure our code's error and confirm that it converges at the theoretical rate of the numerical method being used . This practice is fundamental for building confidence in your solver and developing the essential skill of debugging and validating scientific software.",
            "id": "3229592",
            "problem": "Consider the one-dimensional heat equation with a manufactured source term on a spatial interval and a finite time interval. Let the thermal diffusivity be a positive constant $\\,\\alpha > 0\\,$ and consider the problem on $\\,x \\in [0,1]\\,$ and $\\,t \\in [0,T]\\,$ with homogeneous Dirichlet boundary conditions. Use the method of manufactured solutions as follows.\n\n1. Choose the manufactured solution $\\,u(x,t) = \\exp(t)\\,\\sin(\\pi x)\\,$. Define the source term $\\,f(x,t)\\,$ so that $\\,u\\,$ satisfies the partial differential equation $\\,u_t = \\alpha u_{xx} + f\\,$ exactly. Impose initial and boundary conditions taken from this $\\,u\\,$, namely $\\,u(x,0) = \\sin(\\pi x)\\,$ and $\\,u(0,t) = u(1,t) = 0\\,$ for all $\\,t\\,$.\n\n2. Discretize $\\,[0,1]\\,$ with $\\,N_x\\,$ equal subintervals of width $\\,\\Delta x = 1/N_x\\,$ and grid points $\\,x_i = i\\,\\Delta x\\,$ for $\\,i = 0,1,\\dots,N_x\\,$. Discretize $\\, [0,T]\\,$ with $\\,N_t\\,$ equal time steps of size $\\,\\Delta t = T/N_t\\,$ and times $\\,t^n = n\\,\\Delta t\\,$ for $\\,n = 0,1,\\dots,N_t\\,$. Let $\\,u_i^n \\approx u(x_i,t^n)\\,$ denote the numerical approximation at interior indices $\\,i = 1,2,\\dots,N_x-1\\,$ and times $\\,n = 0,1,\\dots,N_t\\,$.\n\n3. Use the Crank–Nicolson method, which is the trapezoidal rule in time combined with second-order central differences in space, to discretize the heat equation at the interior nodes. Use the exact Dirichlet boundary values at $\\,x=0\\,$ and $\\,x=1\\,$ implied by the manufactured solution. Start the time stepping from the exact initial condition $\\,u_i^0 = \\sin(\\pi x_i)\\,$.\n\n4. Compute the discrete $\\,L^2\\,$ error at the final time $\\,t = T\\,$ defined by\n$$\nE(N_x,N_t) \\;=\\; \\left( \\Delta x \\sum_{i=0}^{N_x} \\bigl(u_i^{N_t} - u(x_i,T)\\bigr)^2 \\right)^{1/2},\n$$\nwith the convention that $\\,u_0^{N_t} = u_{N_x}^{N_t} = 0\\,$.\n\nYour program must verify second-order accuracy in both time and space by estimating observed convergence rates via the method of manufactured solutions. Use the following fixed parameters and test suite.\n\n- Use $\\,\\alpha = 1\\,$ and $\\,T = 0.1\\,$.\n\n- Temporal-order test suite: fix a sufficiently fine spatial grid $\\,N_x = 300\\,$ and vary the number of time steps $\\,N_t \\in \\{50,100,200,400,800\\}\\,$. For each $\\,N_t\\,$, compute $\\,E(N_x,N_t)\\,$ and then estimate the observed temporal order $\\,p_t\\,$ by a least-squares linear fit of $\\,\\log E\\,$ versus $\\,\\log \\Delta t\\,$ over these five cases, where $\\,\\Delta t = T/N_t\\,$. Report $\\,p_t\\,$ rounded to two decimal places.\n\n- Spatial-order test suite: fix a sufficiently small time step $\\,N_t = 1000\\,$ and vary the number of spatial subintervals $\\,N_x \\in \\{10,20,40,80,160\\}\\,$. For each $\\,N_x\\,$, compute $\\,E(N_x,N_t)\\,$ and then estimate the observed spatial order $\\,p_x\\,$ by a least-squares linear fit of $\\,\\log E\\,$ versus $\\,\\log \\Delta x\\,$ over these five cases, where $\\,\\Delta x = 1/N_x\\,$. Report $\\,p_x\\,$ rounded to two decimal places.\n\n- In addition, compute a boolean pass flag defined as true if and only if both $\\,p_t \\ge 1.90\\,$ and $\\,p_x \\ge 1.90\\,$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order $[p_t,p_x,pass]$. The first two entries must be floats rounded to two decimal places, and the third entry must be a boolean literal, for example $[1.99,2.01,True]$.",
            "solution": "The user-provided problem is assessed to be valid. It is a well-posed, scientifically sound, and complete problem in the field of numerical analysis for partial differential equations. The task is to verify the convergence order of the Crank-Nicolson method for the one-dimensional heat equation using the method of manufactured solutions.\n\nThe analysis and solution proceed as follows.\n\nFirst, we determine the source term $f(x,t)$ required for the manufactured solution $u(x,t) = \\exp(t)\\sin(\\pi x)$ to exactly satisfy the governing partial differential equation (PDE), $u_t = \\alpha u_{xx} + f(x,t)$.\n\nWe compute the partial derivatives of $u(x,t)$:\n-   The partial derivative with respect to time $t$ is:\n    $$ u_t = \\frac{\\partial}{\\partial t} \\left( \\exp(t)\\sin(\\pi x) \\right) = \\exp(t)\\sin(\\pi x) $$\n-   The second partial derivative with respect to space $x$ is:\n    $$ u_x = \\frac{\\partial}{\\partial x} \\left( \\exp(t)\\sin(\\pi x) \\right) = \\pi \\exp(t)\\cos(\\pi x) $$\n    $$ u_{xx} = \\frac{\\partial^2}{\\partial x^2} \\left( \\exp(t)\\sin(\\pi x) \\right) = -\\pi^2 \\exp(t)\\sin(\\pi x) $$\n\nSubstituting these derivatives into the PDE gives:\n$$ \\exp(t)\\sin(\\pi x) = \\alpha \\left( -\\pi^2 \\exp(t)\\sin(\\pi x) \\right) + f(x,t) $$\nSolving for the source term $f(x,t)$ yields:\n$$ f(x,t) = \\exp(t)\\sin(\\pi x) + \\alpha \\pi^2 \\exp(t)\\sin(\\pi x) = (1 + \\alpha \\pi^2) \\exp(t)\\sin(\\pi x) $$\n\nNext, we discretize the PDE using the Crank-Nicolson method. The spatial domain $[0,1]$ is discretized into $N_x$ subintervals of width $\\Delta x = 1/N_x$, and the time domain $[0,T]$ is discretized into $N_t$ steps of size $\\Delta t = T/N_t$. Let $u_i^n$ be the numerical approximation of $u(x_i, t^n)$, where $x_i = i\\Delta x$ and $t^n = n\\Delta t$.\n\nThe Crank-Nicolson scheme applies a central difference in space and the trapezoidal rule in time, evaluating both at the midpoint $t^{n+1/2} = t^n + \\Delta t/2$. This results in a scheme that is second-order accurate in both space and time. The discretized equation at an interior grid point $(x_i, t^{n+1/2})$ is:\n$$ \\frac{u_i^{n+1} - u_i^n}{\\Delta t} = \\frac{\\alpha}{2} \\left( \\frac{u_{i+1}^{n+1} - 2u_i^{n+1} + u_{i-1}^{n+1}}{(\\Delta x)^2} + \\frac{u_{i+1}^{n} - 2u_i^{n} + u_{i-1}^{n}}{(\\Delta x)^2} \\right) + f(x_i, t^{n+1/2}) $$\nApproximating the source term as $f(x_i, t^{n+1/2}) \\approx \\frac{1}{2}(f_i^{n+1} + f_i^n)$, where $f_i^n = f(x_i, t^n)$, we get:\n$$ \\frac{u_i^{n+1} - u_i^n}{\\Delta t} = \\frac{\\alpha}{2} \\left( D_{xx} u_i^{n+1} + D_{xx} u_i^{n} \\right) + \\frac{1}{2}(f_i^{n+1} + f_i^n) $$\nwhere $D_{xx}$ represents the second-order central difference operator.\n\nTo solve for the unknown values at time $t^{n+1}$, we rearrange the equation, moving terms at step $n+1$ to the left-hand side (LHS) and terms at step $n$ to the right-hand side (RHS). Let $\\nu = \\frac{\\alpha \\Delta t}{2(\\Delta x)^2}$. The equation for each interior node $i \\in \\{1, 2, \\dots, N_x-1\\}$ becomes:\n$$ -\\nu u_{i-1}^{n+1} + (1+2\\nu)u_i^{n+1} - \\nu u_{i+1}^{n+1} = \\nu u_{i-1}^n + (1-2\\nu)u_i^n + \\nu u_{i+1}^n + \\frac{\\Delta t}{2}(f_i^{n+1} + f_i^n) $$\n\nThis system of $N_x-1$ linear equations must be solved at each time step. Let $U^n = [u_1^n, u_2^n, \\dots, u_{N_x-1}^n]^T$ be the vector of solutions at the interior nodes at time $t^n$. The system can be written in matrix form as:\n$$ A U^{n+1} = B U^n + d^n $$\nwhere $A$ and $B$ are $(N_x-1) \\times (N_x-1)$ tridiagonal matrices:\n$$ A = \\begin{pmatrix} 1+2\\nu & -\\nu & & \\\\ -\\nu & 1+2\\nu & -\\nu & \\\\ & \\ddots & \\ddots & \\ddots \\\\ & & -\\nu & 1+2\\nu & -\\nu \\\\ & & & -\\nu & 1+2\\nu \\end{pmatrix} $$\n$$ B = \\begin{pmatrix} 1-2\\nu & \\nu & & \\\\ \\nu & 1-2\\nu & \\nu & \\\\ & \\ddots & \\ddots & \\ddots \\\\ & & \\nu & 1-2\\nu & \\nu \\\\ & & & \\nu & 1-2\\nu \\end{pmatrix} $$\nThe vector $d^n$ contains the discretized source terms:\n$$ d^n = \\frac{\\Delta t}{2} [f_1^{n+1}+f_1^n, \\dots, f_{N_x-1}^{n+1}+f_{N_x-1}^n]^T $$\nThe homogeneous Dirichlet boundary conditions $u(0,t) = u(1,t) = 0$ imply $u_0^n = u_{N_x}^n = 0$ for all $n$. These conditions are incorporated into the system as the terms involving $u_0$ and $u_{N_x}$ on the boundaries of the stencils for $i=1$ and $i=N_x-1$ are zero.\n\nThe numerical simulation proceeds as follows:\n1.  Initialize the solution at $t=0$ using the exact initial condition: $u_i^0 = u(x_i, 0) = \\sin(\\pi x_i)$ for $i=0, \\dots, N_x$.\n2.  For each time step $n$ from $0$ to $N_t-1$:\n    a.  Construct the RHS vector $RHS = B U^n + d^n$.\n    b.  Solve the linear system $A U^{n+1} = RHS$ for the unknown vector $U^{n+1}$.\n3.  After the final time step, the numerical solution at time $T=t^{N_t}$ is obtained.\n\nThe error is calculated using the discrete $L^2$ norm at the final time $T$:\n$$ E(N_x, N_t) = \\left( \\Delta x \\sum_{i=0}^{N_x} (u_i^{N_t} - u(x_i,T))^2 \\right)^{1/2} $$\nSince the boundary conditions are enforced exactly, the terms for $i=0$ and $i=N_x$ in the sum are zero.\n\nTo verify the order of accuracy, we assume the error follows the form $E \\approx C (\\Delta x)^{p_x} + D (\\Delta t)^{p_t}$.\n-   For the temporal order test ($p_t$), we fix $N_x$ at a large value ($N_x=300$), making the spatial error term negligible. The error is then approximated by $E \\approx D (\\Delta t)^{p_t}$. Taking the logarithm, we have $\\log(E) \\approx \\log(D) + p_t \\log(\\Delta t)$. We perform a linear least-squares fit on the points $(\\log(\\Delta t), \\log(E))$ for a sequence of $N_t$ values. The slope of the resulting line is the estimated order of convergence, $p_t$.\n-   Similarly, for the spatial order test ($p_x$), we fix $N_t$ at a large value ($N_t=1000$) to make the temporal error term negligible. Then $E \\approx C (\\Delta x)^{p_x}$, and $\\log(E) \\approx \\log(C) + p_x \\log(\\Delta x)$. We perform a linear fit on $(\\log(\\Delta x), \\log(E))$ for a sequence of $N_x$ values to find the slope $p_x$.\n\nThe provided parameters are $\\alpha=1$ and $T=0.1$. The implementation will carry out these two convergence studies, compute $p_t$ and $p_x$, and determine a pass/fail flag based on the condition that both orders are at least $1.90$.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D heat equation with a manufactured solution using the Crank-Nicolson method,\n    and computes the observed orders of convergence in time and space.\n    \"\"\"\n    \n    # --- Fixed Parameters ---\n    alpha = 1.0\n    T = 0.1\n\n    # --- Manufactured Solution and Source Term ---\n    # u(x,t) = exp(t) * sin(pi*x)\n    # f(x,t) = (1 + alpha*pi*pi) * exp(t) * sin(pi*x)\n    \n    def u_exact(x, t):\n        return np.exp(t) * np.sin(np.pi * x)\n\n    def f_source(x, t, alpha_val):\n        return (1.0 + alpha_val * np.pi**2) * np.exp(t) * np.sin(np.pi * x)\n\n    def run_simulation(Nx, Nt, alpha_val, T_final):\n        \"\"\"\n        Runs a single simulation for a given Nx, Nt and returns the L2 error.\n        \"\"\"\n        # Discretization parameters\n        dx = 1.0 / Nx\n        dt = T_final / Nt\n        x = np.linspace(0, 1, Nx + 1)\n        \n        # Grid for interior points\n        x_interior = x[1:Nx]\n\n        # Initial condition\n        u_current = u_exact(x_interior, 0)\n        \n        # Crank-Nicolson matrices A (LHS) and B (RHS) for interior points\n        nu = alpha_val * dt / (2.0 * dx**2)\n        M_interior = Nx - 1\n\n        # Matrix A\n        A = np.zeros((M_interior, M_interior))\n        np.fill_diagonal(A, 1.0 + 2.0 * nu)\n        if M_interior > 1:\n            A_upper = np.diag(-nu * np.ones(M_interior - 1), 1)\n            A_lower = np.diag(-nu * np.ones(M_interior - 1), -1)\n            A += A_upper + A_lower\n\n        # Matrix B\n        B = np.zeros((M_interior, M_interior))\n        np.fill_diagonal(B, 1.0 - 2.0 * nu)\n        if M_interior > 1:\n            B_upper = np.diag(nu * np.ones(M_interior - 1), 1)\n            B_lower = np.diag(nu * np.ones(M_interior - 1), -1)\n            B += B_upper + B_lower\n        \n        # Time-stepping loop\n        for n in range(Nt):\n            t_current = n * dt\n            t_next = (n + 1) * dt\n            \n            # Source term vector\n            f_curr_vals = f_source(x_interior, t_current, alpha_val)\n            f_next_vals = f_source(x_interior, t_next, alpha_val)\n            d = (dt / 2.0) * (f_curr_vals + f_next_vals)\n            \n            # RHS vector\n            rhs = B @ u_current + d\n            \n            # Solve the linear system: A * u_next = rhs\n            u_next = np.linalg.solve(A, rhs)\n            \n            u_current = u_next\n            \n        # At this point, u_current is the numerical solution at t=T\n        u_numerical_final = np.zeros(Nx + 1)\n        u_numerical_final[1:Nx] = u_current\n        \n        # Exact solution at t=T\n        u_exact_final = u_exact(x, T_final)\n        \n        # Compute L2 error\n        error_vec = u_numerical_final - u_exact_final\n        l2_error = np.sqrt(dx * np.sum(error_vec**2))\n        \n        return l2_error\n\n    # --- Temporal Order Test ---\n    Nx_temp_test = 300\n    Nt_temp_list = [50, 100, 200, 400, 800]\n    \n    log_dt_temp = []\n    log_E_temp = []\n    \n    for Nt in Nt_temp_list:\n        error = run_simulation(Nx_temp_test, Nt, alpha, T)\n        dt = T / Nt\n        log_dt_temp.append(np.log(dt))\n        log_E_temp.append(np.log(error))\n        \n    # Least-squares fit to find the slope (order of convergence)\n    p_t = np.polyfit(log_dt_temp, log_E_temp, 1)[0]\n    \n    # --- Spatial Order Test ---\n    Nt_spatial_test = 1000\n    Nx_spatial_list = [10, 20, 40, 80, 160]\n    \n    log_dx_spatial = []\n    log_E_spatial = []\n    \n    for Nx in Nx_spatial_list:\n        error = run_simulation(Nx, Nt_spatial_test, alpha, T)\n        dx = 1.0 / Nx\n        log_dx_spatial.append(np.log(dx))\n        log_E_spatial.append(np.log(error))\n        \n    # Least-squares fit to find the slope\n    p_x = np.polyfit(log_dx_spatial, log_E_spatial, 1)[0]\n    \n    # --- Pass Flag ---\n    pass_flag = (p_t >= 1.90) and (p_x >= 1.90)\n    \n    # --- Final Output ---\n    # Format: [p_t (2dp), p_x (2dp), pass_flag]\n    print(f\"[{p_t:.2f},{p_x:.2f},{pass_flag}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "When a physical process involves both transport (convection) and spreading (diffusion), the choice of spatial discretization becomes critical. A seemingly accurate method can produce completely unphysical oscillations that render the solution useless. This exercise contrasts the second-order Central Difference Scheme (CDS) with the first-order Upwind Difference Scheme (UDS) for the convection-diffusion equation . You will discover that the stability of the central scheme is governed by the cell Peclet number, $Pe_h = ah/\\epsilon$, which compares the strength of convection to diffusion at the grid scale, and learn why upwinding is a cornerstone technique for stabilizing numerical solutions in transport-dominated problems.",
            "id": "3128259",
            "problem": "You are asked to investigate spatial discretizations for the one-dimensional linear convection–diffusion Partial Differential Equation (PDE) given by $u_t + a\\,u_x = \\epsilon\\,u_{xx}$ on the domain $x \\in [0,1]$ with constant positive advection speed $a > 0$ and positive diffusivity $\\epsilon > 0$. Focus on the steady boundary layer structure that emerges from the stationary problem obtained by setting $u_t = 0$, namely $\\epsilon\\,u_{xx} - a\\,u_x = 0$, with Dirichlet boundary conditions $u(0) = 1$ and $u(1) = 0$. You will analyze how different spatial finite difference discretizations behave as the cell Peclet number increases, and quantify whether discrete oscillations appear in the numerical solution.\n\nStarting only from fundamental definitions, derive consistent second-order accurate finite differences for spatial derivatives on a uniform grid with $N$ points over $[0,1]$ and grid spacing $h = 1/(N-1)$:\n- Use the Central Difference Scheme (CDS) to approximate the first derivative by $u_x(x_i) \\approx \\left(u_{i+1} - u_{i-1}\\right)/(2h)$ and the second derivative by $u_{xx}(x_i) \\approx \\left(u_{i+1} - 2u_i + u_{i-1}\\right)/h^2$.\n- Use the Upwind Difference Scheme (UDS) for the first derivative when $a > 0$ by $u_x(x_i) \\approx \\left(u_i - u_{i-1}\\right)/h$, while keeping the same second derivative approximation as above.\n\nConstruct in each case the tridiagonal linear system for the interior unknowns $u_1,\\dots,u_{N-2}$ obtained from the steady equation $\\epsilon\\,u_{xx} - a\\,u_x = 0$ at interior grid points $x_i$ for $i = 1,\\dots,N-2$, and enforce the Dirichlet boundary conditions $u_0 = 1$ and $u_{N-1} = 0$ directly into the right-hand side. Solve the linear system to obtain the discrete steady profile $u_i$ for $i=0,\\dots,N-1$.\n\nDefine the cell Peclet number as $Pe_h = \\dfrac{a\\,h}{\\epsilon}$. Define a discrete solution to be oscillatory if either of the following holds:\n- It is not monotone decreasing from $x=0$ to $x=1$ in the sense that $\\Delta_i = u_{i+1} - u_i \\le \\tau$ for all $i=0,\\dots,N-2$ fails, where $\\tau = 10^{-10}$.\n- It exhibits overshoot or undershoot outside the physically consistent interval implied by the boundary conditions, i.e., $\\min_i u_i < -\\tau$ or $\\max_i u_i > 1 + \\tau$.\n\nFor each test case below, compute the steady solutions using both CDS and UDS. Then classify the pair of outcomes using the following integer code:\n- $0$ if CDS is non-oscillatory and UDS is non-oscillatory,\n- $1$ if CDS is oscillatory and UDS is non-oscillatory,\n- $2$ if CDS is oscillatory and UDS is oscillatory,\n- $3$ if CDS is non-oscillatory and UDS is oscillatory.\n\nTest suite (all parameters are dimensionless):\n- Case A: $a = 1$, $\\epsilon = 0.1$, $N = 41$.\n- Case B: $a = 5$, $\\epsilon = 0.01$, $N = 41$.\n- Case C: $a = 50$, $\\epsilon = 0.01$, $N = 41$.\n- Case D: $a = 1$, $\\epsilon = 0.0125$, $N = 41$.\n\nYour program must output a single line containing a comma-separated list of the integer codes for Cases A, B, C, and D in this order, enclosed in square brackets (for example, $[0,1,1,0]$). There are no physical units to report in this problem because the parameters and variables are nondimensional. The angle unit is not applicable. All final numeric outputs must be integers in the specified list format.",
            "solution": "The user-provided problem is valid as it is scientifically grounded, well-posed, and objective. It constitutes a standard exercise in the numerical analysis of partial differential equations, specifically examining the stability and accuracy of finite difference methods for the convection-diffusion equation.\n\nThe problem investigates the one-dimensional steady linear convection-diffusion equation:\n$$\n\\epsilon u_{xx} - a u_x = 0\n$$\non the spatial domain $x \\in [0, 1]$, with constant positive advection speed $a > 0$ and diffusivity $\\epsilon > 0$. The equation is subject to Dirichlet boundary conditions $u(0) = 1$ and $u(1) = 0$. The analytical solution to this boundary value problem is known to be:\n$$\nu(x) = \\frac{e^{ax/\\epsilon} - e^{a/\\epsilon}}{1 - e^{a/\\epsilon}}\n$$\nThis exact solution is monotonic, decreasing from $u(0)=1$ to $u(1)=0$. Any oscillations observed in a numerical solution are therefore artifacts of the discretization method.\n\nWe discretize the domain using a uniform grid of $N$ points, $x_i = i h$ for $i = 0, 1, \\dots, N-1$, where the grid spacing is $h = 1/(N-1)$. The numerical solution $u_i \\approx u(x_i)$ is sought at these grid points. The boundary conditions fix the values at the endpoints: $u_0 = 1$ and $u_{N-1} = 0$. The solution for the interior points, $u_1, \\dots, u_{N-2}$, is found by solving a system of linear equations derived from the discretized PDE.\n\nWe consider two different finite difference schemes for the spatial derivatives at an interior grid point $x_i$:\n\n1.  **Central Difference Scheme (CDS)**\n    This scheme utilizes second-order accurate central differences for both the first and second derivatives:\n    $$\n    u_x(x_i) \\approx \\frac{u_{i+1} - u_{i-1}}{2h}, \\quad u_{xx}(x_i) \\approx \\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2}\n    $$\n    Substituting these into the governing equation $\\epsilon u_{xx} - a u_x = 0$ yields:\n    $$\n    \\epsilon \\left( \\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2} \\right) - a \\left( \\frac{u_{i+1} - u_{i-1}}{2h} \\right) = 0\n    $$\n    Multiplying by $h^2$ and collecting terms for $u_{i-1}$, $u_i$, and $u_{i+1}$, we obtain the discrete equation for each interior node $i=1, \\dots, N-2$:\n    $$\n    \\left(\\epsilon + \\frac{ah}{2}\\right) u_{i-1} - 2\\epsilon u_i + \\left(\\epsilon - \\frac{ah}{2}\\right) u_{i+1} = 0\n    $$\n    By defining the dimensionless cell Peclet number, $Pe_h = \\frac{ah}{\\epsilon}$, which compares the strength of advection to diffusion over a grid cell, the equation can be rewritten as:\n    $$\n    \\epsilon \\left( \\left(1 + \\frac{Pe_h}{2}\\right) u_{i-1} - 2 u_i + \\left(1 - \\frac{Pe_h}{2}\\right) u_{i+1} \\right) = 0\n    $$\n    A key stability criterion, related to the discrete maximum principle, requires the off-diagonal coefficients of the resulting matrix to have signs that do not cause unphysical extrema. For this equation, the coefficient of $u_{i+1}$, which is $(1 - Pe_h/2)$, becomes negative if $Pe_h > 2$. This condition is known to lead to spurious oscillations in the numerical solution, particularly in regions with strong gradients.\n\n2.  **Upwind Difference Scheme (UDS)**\n    This scheme employs a first-order accurate backward difference for the advection term (since $a>0$, the \"upwind\" direction is from smaller $x$) and the same second-order central difference for the diffusion term:\n    $$\n    u_x(x_i) \\approx \\frac{u_i - u_{i-1}}{h}, \\quad u_{xx}(x_i) \\approx \\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2}\n    $$\n    Substituting these approximations into the governing equation gives:\n    $$\n    \\epsilon \\left( \\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2} \\right) - a \\left( \\frac{u_i - u_{i-1}}{h} \\right) = 0\n    $$\n    Multiplying by $h^2$ and collecting terms results in the discrete equation:\n    $$\n    (\\epsilon + ah) u_{i-1} - (2\\epsilon + ah) u_i + \\epsilon u_{i+1} = 0\n    $$\n    In this formulation, the coefficients for the neighboring points $u_{i-1}$ and $u_{i+1}$ are $(\\epsilon + ah)$ and $\\epsilon$, respectively. Since $a, \\epsilon, h$ are all positive, these coefficients are always positive. The resulting matrix is diagonally dominant, and this scheme is guaranteed to produce a non-oscillatory solution for any value of the cell Peclet number, at the cost of being only first-order accurate.\n\nFor both schemes, a tridiagonal system of linear equations $M \\mathbf{u}_{\\text{int}} = \\mathbf{b}$ is formed for the vector of interior unknowns $\\mathbf{u}_{\\text{int}} = [u_1, u_2, \\dots, u_{N-2}]^T$. The boundary conditions are incorporated into the right-hand side vector $\\mathbf{b}$. For the first interior node ($i=1$), the term involving $u_0=1$ is moved to the right side, and for the last interior node ($i=N-2$), the term involving $u_{N-1}=0$ vanishes. This results in a system where only the first element of $\\mathbf{b}$ is non-zero.\n\nThe solution is deemed oscillatory if it is not monotonically decreasing (specifically, if $u_{i+1} - u_i > \\tau$ for any $i$, where $\\tau=10^{-10}$) or if it exhibits over/undershoot beyond the physical bounds set by the boundary conditions (i.e., $\\min_i u_i  -\\tau$ or $\\max_i u_i > 1 + \\tau$).\n\nThe procedure is to solve these linear systems for each test case using both CDS and UDS, check the resulting solutions for oscillations, and assign the corresponding integer code based on the pair of outcomes. This is implemented in the provided Python code, which uses `scipy.linalg.solve_banded` for an efficient solution of the tridiagonal systems.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Solves the 1D steady convection-diffusion equation for specified test cases\n    using Central Difference Scheme (CDS) and Upwind Difference Scheme (UDS),\n    and classifies the results based on the presence of numerical oscillations.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (a, epsilon, N)\n        (1.0, 0.1, 41),    # Case A\n        (5.0, 0.01, 41),   # Case B\n        (50.0, 0.01, 41),  # Case C\n        (1.0, 0.0125, 41), # Case D\n    ]\n\n    # Tolerance for oscillation checks\n    tau = 1e-10\n\n    def check_oscillatory(u_sol, tau_val):\n        \"\"\"\n        Checks if a numerical solution is oscillatory.\n\n        A solution is defined as oscillatory if:\n        1. It is not monotone decreasing, i.e., u[i+1] > u[i] + tau for some i.\n        2. It has overshoot or undershoot outside the physical bounds [0, 1].\n        \"\"\"\n        # Check for non-monotonicity\n        if np.any(np.diff(u_sol) > tau_val):\n            return True\n            \n        # Check for overshoot/undershoot\n        if np.min(u_sol)  -tau_val or np.max(u_sol) > 1.0 + tau_val:\n            return True\n            \n        return False\n\n    def solve_system(a, epsilon, N, scheme):\n        \"\"\"\n        Constructs and solves the tridiagonal linear system for a given scheme.\n        \"\"\"\n        h = 1.0 / (N - 1)\n        N_int = N - 2  # Number of interior points\n        \n        # Define matrix coefficients based on the scheme\n        if scheme == 'CDS':\n            # A*u_{i-1} + B*u_i + C*u_{i+1} = 0\n            A = epsilon + a * h / 2.0\n            B = -2.0 * epsilon\n            C = epsilon - a * h / 2.0\n        elif scheme == 'UDS':\n            # A*u_{i-1} + B*u_i + C*u_{i+1} = 0\n            A = epsilon + a * h\n            B = -(2.0 * epsilon + a * h)\n            C = epsilon\n        else:\n            raise ValueError(\"Unknown scheme specified.\")\n            \n        # Create tridiagonal matrix in banded format for scipy.linalg.solve_banded\n        # For a tridiagonal matrix, (l, u) = (1, 1), so matrix `ab` has shape (3, N_int).\n        # ab[0, 1:] = upper diagonal (C)\n        # ab[1, :] = main diagonal (B)\n        # ab[2, :-1] = lower diagonal (A)\n        ab = np.zeros((3, N_int))\n        ab[0, 1:] = C\n        ab[1, :] = B\n        ab[2, :-1] = A\n        \n        # Create the right-hand side vector b\n        # For i=1: A*u_0 + B*u_1 + C*u_2 = 0 => B*u_1 + C*u_2 = -A*u_0\n        # Since u_0 = 1, the first element of b is -A.\n        # For i=N-2: A*u_{N-3} + B*u_{N-2} + C*u_{N-1} = 0\n        # Since u_{N-1} = 0, the last element remains 0.\n        b = np.zeros(N_int)\n        b[0] = -A * 1.0\n        \n        # Solve the linear system for interior points\n        u_interior = solve_banded((1, 1), ab, b)\n        \n        # Assemble the full solution vector including boundaries u_0=1 and u_{N-1}=0\n        u_full = np.concatenate(([1.0], u_interior, [0.0]))\n        \n        return u_full\n\n    results = []\n    for case in test_cases:\n        a_val, eps_val, N_val = case\n        \n        # Solve for CDS and check for oscillations\n        u_cds = solve_system(a_val, eps_val, N_val, 'CDS')\n        cds_oscillatory = check_oscillatory(u_cds, tau)\n        \n        # Solve for UDS and check for oscillations\n        u_uds = solve_system(a_val, eps_val, N_val, 'UDS')\n        uds_oscillatory = check_oscillatory(u_uds, tau)\n        \n        # Classify the outcome based on the problem's integer codes\n        code = -1\n        if not cds_oscillatory and not uds_oscillatory:\n            code = 0  # Both non-oscillatory\n        elif cds_oscillatory and not uds_oscillatory:\n            code = 1  # CDS oscillatory, UDS non-oscillatory\n        elif cds_oscillatory and uds_oscillatory:\n            code = 2  # Both oscillatory\n        elif not cds_oscillatory and uds_oscillatory:\n            code = 3  # CDS non-oscillatory, UDS oscillatory\n        \n        results.append(code)\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The Crank-Nicolson method is popular for time-dependent problems due to its second-order accuracy and its unconditional stability for the pure heat equation. However, this stability does not always prevent non-physical oscillations, especially when dealing with stiff reaction terms or sharp, discontinuous initial data. This practice explores a subtle but critical aspect of numerical stability: the difference between A-stability and L-stability . You will see how Crank-Nicolson can produce decaying temporal oscillations and then implement a professional-grade remedy, the Rannacher startup, which uses a more dissipative scheme for the first few time steps to ensure a smooth and physically meaningful solution.",
            "id": "3128239",
            "problem": "Consider the one-dimensional diffusion–reaction partial differential equation (PDE) $$u_t=\\kappa\\,u_{xx}-\\lambda\\,u$$ posed on the spatial domain $$x\\in[0,1]$$ for time $$t\\in[0,T]$$, with homogeneous Dirichlet boundary conditions $$u(0,t)=0$$ and $$u(1,t)=0$$ and a discontinuous initial condition $$u(x,0)=\\begin{cases}1,0x\\le 0.5,\\\\0,0.5x\\le 1.\\end{cases}$$ Work in dimensionless units. The task is to demonstrate, via computation, that the Crank–Nicolson (CN) method can produce temporal oscillations for stiff reaction terms and that a Rannacher startup (a remedy that uses a short Backward Euler pre-phase) suppresses these oscillations.\n\nYour program must:\n- Discretize the spatial derivative using a second-order accurate central finite difference method on a uniform grid of $$N$$ points (including the boundary points), and enforce the Dirichlet boundary conditions at $$x=0$$ and $$x=1$$.\n- Discretize time with step size $$\\Delta t$$ up to a final time $$T$$ using:\n  - The Crank–Nicolson method, which is defined by applying the trapezoidal rule in time to the semi-discrete system and solving the resulting linear system at each time step.\n  - Optionally, a Rannacher startup: perform two Backward Euler half-steps of size $$\\Delta t/2$$ at the very beginning before switching to the Crank–Nicolson method for the remainder of the time integration.\n- Diagnose temporal oscillations quantitatively. Define “oscillation present” as the existence of any time step at which either $$\\min_i u_i^n-10^{-3}$$ or $$\\max_i u_i^n1+10^{-3}$$ (which indicates violation of the discrete comparison principle at interior points). Here $$u_i^n$$ denotes the numerical solution at interior grid index $$i$$ and time level $$n$$.\n- Produce a single line of output aggregating the boolean results for each test case, formatted exactly as a comma-separated list enclosed in square brackets, for example $$[{\\rm True},{\\rm False},{\\rm True}]$$.\n\nImplement the above and evaluate the following test suite, designed to exercise different regimes:\n- Case $$1$$ (stiff reaction, large time step, CN only): $$\\kappa=1$$, $$\\lambda=400$$, $$N=51$$, $$\\Delta t=0.005$$, $$T=0.1$$, Rannacher startup disabled.\n- Case $$2$$ (stiff reaction, large time step, CN with Rannacher startup): $$\\kappa=1$$, $$\\lambda=400$$, $$N=51$$, $$\\Delta t=0.005$$, $$T=0.1$$, Rannacher startup enabled with two Backward Euler half-steps.\n- Case $$3$$ (no reaction, small time step, CN only): $$\\kappa=1$$, $$\\lambda=0$$, $$N=51$$, $$\\Delta t=0.0001$$, $$T=0.1$$, Rannacher startup disabled.\n- Case $$4$$ (no reaction, large time step, CN only): $$\\kappa=1$$, $$\\lambda=0$$, $$N=51$$, $$\\Delta t=0.005$$, $$T=0.1$$, Rannacher startup disabled.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $$[{\\rm result}_1,{\\rm result}_2,{\\rm result}_3,{\\rm result}_4]$$), where each $${\\rm result}_j$$ is a boolean indicating whether oscillations are present for the corresponding case.",
            "solution": "This problem demonstrates a key numerical pathology of the Crank-Nicolson method when applied to problems with non-smooth initial data or stiff terms, and it shows how to remedy it with a Rannacher startup procedure. The solution requires implementing and comparing two time-stepping strategies.\n\n### 1. Semi-Discretization in Space\n\nFirst, we apply the Method of Lines by discretizing the spatial domain. Using a uniform grid with spacing $\\Delta x = 1/(N-1)$, the second spatial derivative $u_{xx}$ at an interior node $x_i$ is approximated by a second-order central difference:\n$$\nu_{xx}(x_i, t) \\approx \\frac{u_{i+1}(t) - 2u_i(t) + u_{i-1}(t)}{(\\Delta x)^2}\n$$\nSubstituting this into the PDE $u_t = \\kappa u_{xx} - \\lambda u$ for each interior node $i=1, \\dots, N-2$ transforms the single PDE into a system of coupled ordinary differential equations (ODEs). Let $\\mathbf{u}(t) = [u_1(t), u_2(t), \\dots, u_{N-2}(t)]^T$ be the vector of solutions at the interior nodes. The system can be written in matrix form as:\n$$\n\\frac{d\\mathbf{u}}{dt} = (\\kappa A - \\lambda I) \\mathbf{u}(t) \\equiv L\\mathbf{u}(t)\n$$\nHere, $I$ is the identity matrix, and $A$ is the $(N-2) \\times (N-2)$ tridiagonal matrix representing the discretized second derivative operator with homogeneous Dirichlet boundary conditions:\n$$\nA = \\frac{1}{(\\Delta x)^2} \\begin{pmatrix} -2  1   \\\\ 1  -2  1  \\\\  \\ddots  \\ddots  \\ddots \\\\   1  -2  1 \\\\    1  -2 \\end{pmatrix}\n$$\nThe operator $L$ represents the semi-discretized PDE.\n\n### 2. Full Discretization in Time\n\nNext, we discretize the ODE system $\\frac{d\\mathbf{u}}{dt} = L\\mathbf{u}$ in time.\n\n#### Crank-Nicolson (CN) Method\nThe CN method is equivalent to applying the trapezoidal rule to the ODE system. This gives:\n$$\n\\frac{\\mathbf{u}^{n+1} - \\mathbf{u}^n}{\\Delta t} = \\frac{1}{2} (L\\mathbf{u}^{n+1} + L\\mathbf{u}^n)\n$$\nwhere $\\mathbf{u}^n$ is the numerical solution vector at time $t_n = n\\Delta t$. To solve for the unknown $\\mathbf{u}^{n+1}$, we rearrange the terms:\n$$\n(I - \\frac{\\Delta t}{2} L) \\mathbf{u}^{n+1} = (I + \\frac{\\Delta t}{2} L) \\mathbf{u}^n\n$$\nAt each time step, we solve this linear system to find the solution at the next time level. The CN method is A-stable, meaning it is stable for any choice of $\\Delta t > 0$ for the stable model problem $y' = zy$ with $\\text{Re}(z) \\le 0$. However, its amplification factor $G(\\zeta) = (1+\\zeta/2)/(1-\\zeta/2)$ (where $\\zeta = z\\Delta t$) approaches $-1$ as $\\text{Re}(\\zeta) \\to -\\infty$. This means stiff components (corresponding to large negative eigenvalues of $L$) are damped very slowly, which can cause spurious oscillations when the initial data has sharp discontinuities.\n\n#### Backward Euler (BE) Method and Rannacher Startup\nThe BE method is an implicit, first-order method given by:\n$$\n\\frac{\\mathbf{u}^{n+1} - \\mathbf{u}^n}{\\Delta t} = L\\mathbf{u}^{n+1} \\quad \\implies \\quad (I - \\Delta t L) \\mathbf{u}^{n+1} = \\mathbf{u}^n\n$$\nThe BE method is L-stable. Its amplification factor $G(\\zeta) = 1/(1-\\zeta)$ approaches $0$ as $\\text{Re}(\\zeta) \\to -\\infty$. This strong damping property makes it highly effective at smoothing out initial high-frequency errors.\n\nThe Rannacher startup procedure leverages this property. Instead of starting immediately with CN, we perform a few initial steps with the more dissipative BE method to damp the oscillations from the discontinuous initial condition. The problem specifies two BE half-steps of size $\\Delta t / 2$:\n1.  **Step 1 (BE):** From $t=0$ to $t=\\Delta t/2$. Solve $(I - \\frac{\\Delta t}{2} L) \\mathbf{u}^{1/2} = \\mathbf{u}^0$.\n2.  **Step 2 (BE):** From $t=\\Delta t/2$ to $t=\\Delta t$. Solve $(I - \\frac{\\Delta t}{2} L) \\mathbf{u}^1 = \\mathbf{u}^{1/2}$.\n3.  **Subsequent Steps (CN):** For $n \\ge 1$, switch to the standard CN method to evolve the now-smoother solution $\\mathbf{u}^1$ forward in time.\n\n### 3. Implementation Summary\nThe algorithm proceeds as follows:\n1.  Construct the spatial discretization matrix $L = \\kappa A - \\lambda I$.\n2.  Set up the initial condition vector $\\mathbf{u}^0$ by sampling the discontinuous function on the interior grid.\n3.  If Rannacher startup is enabled, perform two BE steps with time step $\\Delta t/2$. Otherwise, proceed directly to the CN loop.\n4.  Loop through the remaining time steps using the CN formula. At each step, form the right-hand side vector and solve the resulting linear system for the next time level.\n5.  After each time step (including the startup steps), check if the solution vector $\\mathbf{u}^n$ violates the maximum principle bounds, i.e., if any component is less than $-10^{-3}$ or greater than $1+10^{-3}$. If a violation is found at any time, the result for that case is `True`. If the simulation completes without any such violation, the result is `False`.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import diags, identity\nfrom scipy.sparse.linalg import spsolve\n\ndef run_simulation(kappa, lambda_val, N, dt, T, use_rannacher):\n    \"\"\"\n    Solves the 1D diffusion-reaction equation and detects oscillations.\n\n    Args:\n        kappa (float): Diffusion coefficient.\n        lambda_val (float): Reaction coefficient.\n        N (int): Number of spatial grid points.\n        dt (float): Time step size.\n        T (float): Final time.\n        use_rannacher (bool): Flag to enable/disable Rannacher startup.\n\n    Returns:\n        bool: True if oscillations are detected, False otherwise.\n    \"\"\"\n    # Grid setup\n    dx = 1.0 / (N - 1)\n    M = N - 2  # Number of interior points\n    x_interior = np.linspace(dx, 1.0 - dx, M)\n\n    # Initial condition for interior points\n    u_current = np.zeros(M)\n    u_current[x_interior = 0.5] = 1.0\n\n    # The maximum principle for this PDE with lambda >= 0 implies the solution\n    # should remain between 0 and 1. We check for violations of this principle beyond a tolerance.\n    oscillation_min_thresh = -1.0e-3\n    oscillation_max_thresh = 1.0 + 1.0e-3\n\n    def check_oscillation(u_vec):\n        return np.min(u_vec)  oscillation_min_thresh or np.max(u_vec) > oscillation_max_thresh\n\n    # Spatial discretization matrix A for u_xx using second-order central differences.\n    # The matrix is of size (M x M) for the M interior points.\n    diagonals = [np.ones(M - 1), -2 * np.ones(M), np.ones(M - 1)]\n    A = diags(diagonals, [-1, 0, 1], shape=(M, M), format='csc') / (dx**2)\n\n    # Full semi-discrete system matrix L = kappa*A - lambda*I\n    Id = identity(M, format='csc')\n    L = kappa * A - lambda_val * Id\n\n    # Time-stepping\n    num_steps = int(round(T / dt))\n    \n    start_step_cn = 0\n    if use_rannacher:\n        # Rannacher startup: two Backward Euler half-steps\n        dt_half = dt / 2.0\n        M_BE_half = Id - dt_half * L\n\n        # First half-step from t=0 to t=dt/2\n        u_half = spsolve(M_BE_half, u_current, use_umfpack=False)\n        if check_oscillation(u_half):\n            return True\n        \n        # Second half-step from t=dt/2 to t=dt\n        u_next = spsolve(M_BE_half, u_half, use_umfpack=False)\n        if check_oscillation(u_next):\n            return True\n        \n        u_current = u_next\n        start_step_cn = 1 # CN loop will start from the second full time step\n    \n    # Crank-Nicolson for the remaining steps\n    M_CN_lhs = Id - (dt / 2.0) * L\n    M_CN_rhs = Id + (dt / 2.0) * L\n    \n    for _ in range(start_step_cn, num_steps):\n        rhs_vector = M_CN_rhs.dot(u_current)\n        u_next = spsolve(M_CN_lhs, rhs_vector, use_umfpack=False)\n        \n        if check_oscillation(u_next):\n            return True\n            \n        u_current = u_next\n\n    return False\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Stiff reaction, large dt, CN only -> Expect oscillations\n        {'kappa': 1.0, 'lambda_val': 400.0, 'N': 51, 'dt': 0.005, 'T': 0.1, 'use_rannacher': False},\n        # Case 2: Stiff reaction, large dt, CN with Rannacher -> Expect no oscillations\n        {'kappa': 1.0, 'lambda_val': 400.0, 'N': 51, 'dt': 0.005, 'T': 0.1, 'use_rannacher': True},\n        # Case 3: No reaction, small dt, CN only -> Expect no oscillations\n        {'kappa': 1.0, 'lambda_val': 0.0, 'N': 51, 'dt': 0.0001, 'T': 0.1, 'use_rannacher': False},\n        # Case 4: No reaction, large dt, CN only -> Expect oscillations\n        {'kappa': 1.0, 'lambda_val': 0.0, 'N': 51, 'dt': 0.005, 'T': 0.1, 'use_rannacher': False},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation(**case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}