{
    "hands_on_practices": [
        {
            "introduction": "This practice explores a fundamental challenge in discretizing equations with transport phenomena: numerical stability. By comparing a centered-difference scheme with an upwind scheme for the advection-diffusion equation, you will directly observe how the choice of spatial discretization can lead to non-physical oscillations and instability, especially when advection dominates diffusion. This exercise is crucial for understanding why specialized schemes are necessary for accurately simulating transport processes. ",
            "id": "2444647",
            "problem": "Consider the one-dimensional linear advection–diffusion partial differential equation (PDE) with periodic boundary conditions,\n$$\n\\frac{\\partial u}{\\partial t}(x,t) + a \\,\\frac{\\partial u}{\\partial x}(x,t) = \\nu \\,\\frac{\\partial^2 u}{\\partial x^2}(x,t), \\quad x \\in [0,1], \\quad t \\in [0,T],\n$$\nwith spatial periodicity $u(0,t) = u(1,t)$ for all $t \\in [0,T]$ and initial condition\n$$\nu(x,0) = \\sin(2\\pi x) + 0.1 \\sin(16\\pi x).\n$$\nLet the spatial grid be uniform with $N$ points, spacing $\\Delta x = 1/N$, and periodic indexing. Define two semi-discrete spatial operators on the grid values $u_j(t) \\approx u(x_j,t)$ with $x_j = j \\,\\Delta x$:\n- Centered advection with second-order central difference and second derivative diffusion,\n$$\n\\left.\\frac{\\mathrm{d}u_j}{\\mathrm{d}t}\\right|_{\\text{centered}} = -a \\,\\frac{u_{j+1} - u_{j-1}}{2\\Delta x} + \\nu \\,\\frac{u_{j+1} - 2u_j + u_{j-1}}{\\Delta x^2}.\n$$\n- Upwind advection (first-order upwind consistent with the sign of $a$) and second derivative diffusion,\n$$\n\\left.\\frac{\\mathrm{d}u_j}{\\mathrm{d}t}\\right|_{\\text{upwind}} =\n\\begin{cases}\n-a \\,\\frac{u_j - u_{j-1}}{\\Delta x} + \\nu \\,\\frac{u_{j+1} - 2u_j + u_{j-1}}{\\Delta x^2},  a \\ge 0,\\\\\n-a \\,\\frac{u_{j+1} - u_j}{\\Delta x} + \\nu \\,\\frac{u_{j+1} - 2u_j + u_{j-1}}{\\Delta x^2},  a  0.\n\\end{cases}\n$$\nAdvance in time by the explicit forward Euler method with time step $\\Delta t$ until the final time $T$. For each simulation, define the discrete $L^2$ norm at time level $n$ by\n$$\n\\|u^n\\|_2 = \\left( \\Delta x \\sum_{j=0}^{N-1} \\left(u_j^n\\right)^2 \\right)^{1/2}.\n$$\nDeclare a run “stable” if the maximum norm over all time steps satisfies\n$$\n\\max_{0 \\le n \\le N_t} \\|u^n\\|_2 \\le G_{\\max} \\,\\|u^0\\|_2,\n$$\nand “unstable” otherwise, where $G_{\\max} = 5$ is fixed and $N_t$ is the number of time steps taken to reach $T$. Choose the time step from the minimum of advection and diffusion bounds determined by non-dimensional factors $C_{\\mathrm{adv}}$ and $C_{\\mathrm{diff}}$ as follows:\n$$\n\\Delta t =\n\\min\\!\\left(\n\\begin{array}{l}\nC_{\\mathrm{adv}} \\,\\frac{\\Delta x}{|a|} \\quad \\text{if } |a|0, \\text{ otherwise } +\\infty,\\\\\nC_{\\mathrm{diff}} \\,\\frac{\\Delta x^2}{2\\nu} \\quad \\text{if } \\nu0, \\text{ otherwise } +\\infty\n\\end{array}\n\\right).\n$$\nIf both $|a|=0$ and $\\nu=0$, this setup is not considered in the tests.\n\nYour task is to implement the above definitions and determine, for each test case below, whether the centered scheme and the upwind scheme are stable under the same $\\Delta t$ computed from the given parameters. The domain is nondimensional, and no physical units are required in the output.\n\nUse the following test suite, where each case specifies $(a,\\nu,N,C_{\\mathrm{adv}},C_{\\mathrm{diff}},T)$:\n- Test $1$: $(a,\\nu,N,C_{\\mathrm{adv}},C_{\\mathrm{diff}},T) = (\\,1.0,\\,0.001,\\,200,\\,0.5,\\,0.4,\\,0.5\\,)$.\n- Test $2$: $(a,\\nu,N,C_{\\mathrm{adv}},C_{\\mathrm{diff}},T) = (\\,20.0,\\,0.0001,\\,400,\\,0.8,\\,0.2,\\,0.2\\,)$.\n- Test $3$: $(a,\\nu,N,C_{\\mathrm{adv}},C_{\\mathrm{diff}},T) = (\\,0.0,\\,0.01,\\,100,\\,0.5,\\,0.4,\\,0.5\\,)$.\n- Test $4$: $(a,\\nu,N,C_{\\mathrm{adv}},C_{\\mathrm{diff}},T) = (\\,1.0,\\,0.0,\\,200,\\,0.99,\\,0.0,\\,0.5\\,)$.\n\nYour program must:\n- Use the same $\\Delta t$ for both centered and upwind schemes in each test case, computed exactly as defined above.\n- Integrate to the specified final time $T$ (if $\\Delta t$ does not divide $T$, take $N_t = \\lceil T/\\Delta t \\rceil$ and use a uniform time step of $T/N_t$).\n- For each test, return two boolean values in the order $\\big[$centered scheme stability, upwind scheme stability$\\big]$ based on the criterion with $G_{\\max} = 5$.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Concatenate the results from the four tests in the order of the tests, flattening the booleans into a single list. For example, the output format should be like\n$$\n[\\text{c}_1,\\text{u}_1,\\text{c}_2,\\text{u}_2,\\text{c}_3,\\text{u}_3,\\text{c}_4,\\text{u}_4],\n$$\nwhere $\\text{c}_k$ and $\\text{u}_k$ are the boolean stability outcomes for the centered and upwind schemes, respectively, in test $k$.",
            "solution": "The posed problem is subjected to validation and is found to be valid. It is scientifically grounded, well-posed, objective, and contains all necessary information for a unique, verifiable solution. We may therefore proceed with the derivation and implementation of the solution.\n\nThe problem requires the numerical solution of the one-dimensional linear advection-diffusion equation,\n$$\n\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = \\nu \\frac{\\partial^2 u}{\\partial x^2},\n$$\non the domain $x \\in [0,1]$ with periodic boundary conditions. The solution is to be obtained using the Method of Lines (MOL), where the spatial derivatives are discretized first, converting the partial differential equation (PDE) into a system of coupled ordinary differential equations (ODEs). This system is then integrated in time.\n\nFirst, we define the discrete spatial grid. The domain $[0,1]$ is discretized into $N$ uniform segments of length $\\Delta x = 1/N$. The grid points are $x_j = j\\Delta x$ for $j = 0, 1, \\dots, N-1$. The solution on this grid is represented by a vector $\\vec{u}(t)$ where the $j$-th component is $u_j(t) \\approx u(x_j, t)$. The periodic boundary condition implies $u_{j+N} = u_j$ for any integer $j$.\n\nThe MOL transforms the PDE into the form $\\frac{d\\vec{u}}{dt} = \\mathbf{L}\\vec{u}$, where $\\mathbf{L}$ is a matrix representing the discretized spatial operator. We are asked to evaluate two different discretizations for the advective term $\\frac{\\partial u}{\\partial x}$, while the diffusive term $\\frac{\\partial^2 u}{\\partial x^2}$ is consistently discretized using a standard second-order central difference.\n\nThe second-order central difference approximation for the second derivative is:\n$$\n\\left.\\frac{\\partial^2 u}{\\partial x^2}\\right|_{x_j} \\approx \\frac{u_{j+1} - 2u_j + u_{j-1}}{\\Delta x^2}.\n$$\nThis operator is applied for both schemes.\n\nScheme 1: Centered Advection\nThe advective term is approximated using a second-order central difference:\n$$\n\\left.\\frac{\\partial u}{\\partial x}\\right|_{x_j} \\approx \\frac{u_{j+1} - u_{j-1}}{2\\Delta x}.\n$$\nCombining these, the semi-discrete system for the centered scheme is:\n$$\n\\frac{d u_j}{d t} = -a \\left(\\frac{u_{j+1} - u_{j-1}}{2\\Delta x}\\right) + \\nu \\left(\\frac{u_{j+1} - 2u_j + u_{j-1}}{\\Delta x^2}\\right).\n$$\n\nScheme 2: Upwind Advection\nThe advective term is approximated using a first-order upwind difference, the stencil of which depends on the sign of the advection speed $a$. This choice is made to introduce numerical dissipation that enhances stability.\nIf $a \\ge 0$, a backward difference is used:\n$$\n\\left.\\frac{\\partial u}{\\partial x}\\right|_{x_j} \\approx \\frac{u_j - u_{j-1}}{\\Delta x}.\n$$\nIf $a  0$, a forward difference is used:\n$$\n\\left.\\frac{\\partial u}{\\partial x}\\right|_{x_j} \\approx \\frac{u_{j+1} - u_j}{\\Delta x}.\n$$\nThe corresponding semi-discrete system for the upwind scheme is thus:\n$$\n\\frac{d u_j}{d t} =\n\\begin{cases}\n-a \\left(\\frac{u_j - u_{j-1}}{\\Delta x}\\right) + \\nu \\left(\\frac{u_{j+1} - 2u_j + u_{j-1}}{\\Delta x^2}\\right),  a \\ge 0 \\\\\n-a \\left(\\frac{u_{j+1} - u_j}{\\Delta x}\\right) + \\nu \\left(\\frac{u_{j+1} - 2u_j + u_{j-1}}{\\Delta x^2}\\right),  a  0\n\\end{cases}\n$$\n\nFor time integration, the explicit forward Euler method is specified. Given the solution vector $\\vec{u}^n$ at time $t_n$, the solution at the next time step $t_{n+1} = t_n + \\Delta t$ is computed as:\n$$\n\\vec{u}^{n+1} = \\vec{u}^n + \\Delta t \\cdot \\frac{d\\vec{u}}{dt}\\bigg|_{\\vec{u}=\\vec{u}^n}.\n$$\nThe time step $\\Delta t$ must be chosen carefully to ensure numerical stability. The forward Euler method is only conditionally stable. The problem provides a specific formula for a preliminary time step, $\\Delta t_{cfl}$, based on the Courant-Friedrichs-Lewy (CFL) conditions for advection and diffusion:\n$$\n\\Delta t_{cfl} = \\min\\left( C_{\\mathrm{adv}} \\frac{\\Delta x}{|a|}, \\; C_{\\mathrm{diff}} \\frac{\\Delta x^2}{2\\nu} \\right).\n$$\nThe terms are considered infinite if their denominators ($|a|$ or $\\nu$) are zero. To ensure the simulation ends exactly at time $T$, the number of steps is fixed as $N_t = \\lceil T/\\Delta t_{cfl} \\rceil$, and a uniform actual time step $\\Delta t = T/N_t$ is used for the integration. This ensures $\\Delta t \\le \\Delta t_{cfl}$, preserving the stability constraints.\n\nThe stability of each simulation run is assessed quantitatively. A run is declared \"stable\" if the maximum discrete $L^2$ norm observed over the entire simulation does not exceed a certain multiple of the initial norm. The discrete $L^2$ norm at time step $n$ is:\n$$\n\\|u^n\\|_2 = \\left( \\Delta x \\sum_{j=0}^{N-1} (u_j^n)^2 \\right)^{1/2}.\n$$\nThe stability criterion is:\n$$\n\\max_{0 \\le n \\le N_t} \\|u^n\\|_2 \\le G_{\\max} \\|u^0\\|_2,\n$$\nwhere the growth factor is given as $G_{\\max} = 5$. The initial condition is given by $u(x,0) = \\sin(2\\pi x) + 0.1 \\sin(16\\pi x)$, which is evaluated on the grid to provide the initial vector $\\vec{u}^0$.\n\nThe algorithmic procedure for each test case is as follows:\n1.  Set parameters $(a, \\nu, N, C_{\\mathrm{adv}}, C_{\\mathrm{diff}}, T)$.\n2.  Compute grid spacing $\\Delta x = 1/N$ and create the grid points $x_j$.\n3.  Generate the initial condition vector $\\vec{u}^0$ by evaluating $u(x_j, 0)$.\n4.  Calculate the initial norm $\\|u^0\\|_2$ and the stability threshold $G_{\\max} \\|u^0\\|_2$.\n5.  Calculate $\\Delta t_{cfl}$ and then the actual time step $\\Delta t = T/\\lceil T/\\Delta t_{cfl} \\rceil$.\n6.  For each scheme (centered and upwind):\n    a. Initialize the solution vector $\\vec{u} = \\vec{u}^0$ and set $\\text{max\\_norm} = \\|u^0\\|_2$.\n    b. Loop $N_t$ times:\n        i.   Compute the right-hand side vector $\\frac{d\\vec{u}}{dt}$ using the appropriate finite difference formulas.\n        ii.  Update the solution using the forward Euler step: $\\vec{u} \\leftarrow \\vec{u} + \\Delta t \\frac{d\\vec{u}}{dt}$.\n        iii. Calculate the current norm $\\|\\vec{u}\\|_2$ and update $\\text{max\\_norm}$ if necessary. If the solution becomes non-finite, $\\text{max\\_norm}$ becomes infinite.\n    c. Compare the final $\\text{max\\_norm}$ to the threshold to determine stability (True/False).\n7.  Collect the boolean stability results for both schemes and append them to a global list.\n\nThis procedure will be implemented for all provided test cases, and the final list of boolean results will be formatted as specified. The use of vectorized operations, particularly with periodic shifts, is efficient for implementing the finite differences on the periodic grid.",
            "answer": "```python\nimport numpy as np\nimport math\n\ndef get_rhs_calculator(a, nu, N, scheme):\n    \"\"\"\n    Returns a function that computes the right-hand side of the semi-discretized PDE.\n    This corresponds to the spatial operator applied to the solution vector u.\n    \"\"\"\n    dx = 1.0 / N\n    d2udx2_term_func = lambda u: (np.roll(u, -1) - 2 * u + np.roll(u, 1)) / (dx**2)\n\n    if scheme == 'centered':\n        def rhs_centered(u):\n            dudx_adv = (np.roll(u, -1) - np.roll(u, 1)) / (2 * dx)\n            return -a * dudx_adv + nu * d2udx2_term_func(u)\n        return rhs_centered\n    elif scheme == 'upwind':\n        def rhs_upwind(u):\n            if a = 0:\n                dudx_adv = (u - np.roll(u, 1)) / dx\n            else:  # a  0\n                dudx_adv = (np.roll(u, -1) - u) / dx\n            return -a * dudx_adv + nu * d2udx2_term_func(u)\n        return rhs_upwind\n    else:\n        raise ValueError(\"Unknown scheme type\")\n\ndef check_stability(params, scheme, G_max):\n    \"\"\"\n    Runs a single simulation for a given test case and scheme, then reports its stability.\n    \"\"\"\n    a, nu, N, C_adv, C_diff, T = params\n\n    # 1. Grid and Initial Condition\n    dx = 1.0 / N\n    x = np.arange(N, dtype=float) / N\n    u = np.sin(2 * np.pi * x) + 0.1 * np.sin(16 * np.pi * x)\n\n    # 2. Initial norm and stability threshold\n    norm_initial = np.sqrt(dx * np.sum(u**2))\n    if norm_initial == 0:\n        return True  # Trivial case: zero initial condition is always stable\n    max_norm = norm_initial\n\n    # 3. Time step calculation\n    dt_adv = C_adv * dx / abs(a) if abs(a)  0 else float('inf')\n    dt_diff = C_diff * dx**2 / (2 * nu) if nu  0 else float('inf')\n    dt_cfl = min(dt_adv, dt_diff)\n\n    if T == 0:\n        return True\n    if dt_cfl == float('inf'): # Corresponds to a=0 and nu=0 case, u(x,t) is constant.\n      return True\n\n    num_steps = math.ceil(T / dt_cfl)\n    dt = T / num_steps\n    \n    # 4. Get the appropriate RHS function for the scheme\n    rhs_calculator = get_rhs_calculator(a, nu, N, scheme)\n\n    # 5. Time integration loop\n    for _ in range(num_steps):\n        u = u + dt * rhs_calculator(u)\n        \n        current_norm = np.sqrt(dx * np.sum(u**2))\n        \n        if np.isnan(current_norm) or np.isinf(current_norm):\n            max_norm = float('inf')\n            break\n            \n        if current_norm  max_norm:\n            max_norm = current_norm\n            \n    # 6. Check stability criterion\n    return max_norm = G_max * norm_initial\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # (a,      nu,       N,   C_adv, C_diff, T)\n        (1.0,    0.001,    200, 0.5,   0.4,    0.5),\n        (20.0,   0.0001,   400, 0.8,   0.2,    0.2),\n        (0.0,    0.01,     100, 0.5,   0.4,    0.5),\n        (1.0,    0.0,      200, 0.99,  0.0,    0.5),\n    ]\n\n    G_max = 5.0\n    results = []\n\n    for i, case in enumerate(test_cases):\n        is_stable_cen = check_stability(case, 'centered', G_max)\n        is_stable_upw = check_stability(case, 'upwind', G_max)\n        results.extend([is_stable_cen, is_stable_upw])\n\n    # Final print statement in the exact required format.\n    # str(True) - 'True', str(False) - 'False'\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The overall accuracy of a numerical solution is often determined by its weakest link, which can frequently be the implementation of boundary conditions. This exercise demonstrates how two different methods for handling Neumann boundary conditions—a simple ghost-cell approach and a higher-order one-sided formula—result in different global orders of accuracy for the heat equation. Through this comparison, you will learn to appreciate the importance of maintaining consistent accuracy between the interior domain and its boundaries. ",
            "id": "3159236",
            "problem": "Consider the one-dimensional heat equation as a prototype parabolic partial differential equation on a finite interval,\n$$\nu_t(x,t) = \\alpha\\,u_{xx}(x,t), \\quad 0 \\le x \\le L,\\quad 0  t \\le T,\n$$\nwith homogeneous Neumann boundary conditions\n$$\nu_x(0,t)=0,\\quad u_x(L,t)=0,\n$$\nand an initial condition formed by a superposition of cosine modes,\n$$\nu(x,0)=\\cos\\!\\Big(\\frac{n_1\\pi x}{L}\\Big)+\\frac{1}{2}\\cos\\!\\Big(\\frac{n_2\\pi x}{L}\\Big),\n$$\nwhere $n_1$ and $n_2$ are positive integers. For such data, the exact solution is\n$$\nu(x,t)=\\exp\\!\\Big(-\\alpha\\Big(\\frac{n_1\\pi}{L}\\Big)^2 t\\Big)\\cos\\!\\Big(\\frac{n_1\\pi x}{L}\\Big)+\\frac{1}{2}\\exp\\!\\Big(-\\alpha\\Big(\\frac{n_2\\pi}{L}\\Big)^2 t\\Big)\\cos\\!\\Big(\\frac{n_2\\pi x}{L}\\Big).\n$$\n\nYour task is to use the Method of Lines (MOL) to semi-discretize in space on a uniform grid of $N$ points (including boundaries) with spacing $h=L/(N-1)$, forming a linear system of ordinary differential equations of the form\n$$\n\\frac{d\\mathbf{u}}{dt}=\\mathbf{A}\\,\\mathbf{u},\n$$\nwhere $\\mathbf{u}(t)\\in\\mathbb{R}^N$ approximates $u(x_i,t)$ at grid nodes $x_i=i\\,h$ for $i=0,1,\\dots,N-1$. Use the standard second-order centered finite-difference approximation for $u_{xx}$ at interior nodes $i=1,\\dots,N-2$. At the boundaries, implement and compare the following two closures for the Neumann conditions $u_x(0,t)=u_x(L,t)=0$:\n\n- Ghost-cell reflection (GC): enforce the Neumann conditions by extending the solution with fictitious nodes beyond the domain in a way that is consistent with the zero normal derivative, and eliminate these ghost values to obtain a closed semi-discrete system on the physical nodes.\n\n- One-sided boundary closure (OS): derive a one-sided boundary formula for $u_{xx}$ at $x=0$ and $x=L$ that is at least second-order accurate in $h$, by eliminating any ghost values using Taylor expansions constrained by $u_x=0$.\n\nIntegrate the semi-discrete system exactly in time via the matrix exponential to isolate spatial discretization error. You may implement $\\mathbf{u}(T)=\\exp(T\\mathbf{A})\\,\\mathbf{u}(0)$ numerically.\n\nFor each method (GC and OS), for each grid size $N$, compute the maximum-norm error at time $T$,\n$$\ne(N)=\\max_{0\\le i\\le N-1}\\big|u_{\\text{num}}(x_i,T)-u_{\\text{exact}}(x_i,T)\\big|.\n$$\nUsing two successive refinements with spacings $h_1$ and $h_2$, report the observed order of accuracy\n$$\np=\\frac{\\log\\big(e(N_1)/e(N_2)\\big)}{\\log\\big(h_1/h_2\\big)}.\n$$\n\nTest suite. Use $L=1$ and the mode pair $(n_1,n_2)=(2,3)$. For each case below, use the grid sizes $\\{N\\}=\\{21,41,81,161\\}$ and define $h(L,N)=L/(N-1)$ when computing $p$ from the two finest grids $N=81$ and $N=161$:\n\n- Case A (happy path): $\\alpha=1$, $T=0.03$.\n- Case B (different diffusivity): $\\alpha=0.1$, $T=0.03$.\n- Case C (longer time): $\\alpha=1$, $T=0.2$.\n\nFor each case, produce three outputs:\n- the observed order $p_{\\text{GC}}$ for ghost-cell reflection between $N=81$ and $N=161$,\n- the observed order $p_{\\text{OS}}$ for the one-sided boundary closure between $N=81$ and $N=161$,\n- a boolean indicating whether $p_{\\text{OS}}1.5$ and $p_{\\text{GC}}1.5$.\n\nRound each reported order to three decimal places. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,...]\") in the order: Case A triple, Case B triple, Case C triple. No additional text should be printed.",
            "solution": "The problem is valid as it presents a well-posed initial-boundary value problem for the one-dimensional heat equation and asks for a standard numerical analysis study using the Method of Lines (MOL). The problem is scientifically grounded, self-contained, and objective.\n\nThe core of the problem is to construct and compare two different semi-discretizations of the heat equation,\n$$\nu_t = \\alpha u_{xx},\n$$\non a uniform grid of $N$ points $x_i = ih$ for $i=0, 1, \\dots, N-1$, where the grid spacing is $h=L/(N-1)$. The MOL reduces the partial differential equation (PDE) to a system of coupled ordinary differential equations (ODEs),\n$$\n\\frac{d\\mathbf{u}}{dt} = \\mathbf{A} \\mathbf{u}(t),\n$$\nwhere $\\mathbf{u}(t) = [u_0(t), u_1(t), \\dots, u_{N-1}(t)]^T$ is the vector of approximate solution values at the grid points, and $\\mathbf{A}$ is a constant matrix that approximates the spatial operator $\\alpha \\frac{\\partial^2}{\\partial x^2}$.\n\nFor the interior grid points $i=1, \\dots, N-2$, both methods use the standard second-order centered difference approximation for the second derivative:\n$$\nu_{xx}(x_i) \\approx \\frac{u(x_{i-1}) - 2u(x_i) + u(x_{i+1})}{h^2} = \\frac{u_{i-1} - 2u_i + u_{i+1}}{h^2}.\n$$\nThis defines the rows $i=1, \\dots, N-2$ of the discretization matrix $\\mathbf{A}$ as having the form $\\frac{\\alpha}{h^2}[\\dots, 1, -2, 1, \\dots]$. The methods differ in how they form the first ($i=0$) and last ($i=N-1$) rows of $\\mathbf{A}$ to incorporate the homogeneous Neumann boundary conditions, $u_x(0,t)=0$ and $u_x(L,t)=0$.\n\n**1. Ghost-Cell (GC) Reflection Method**\n\nThis method enforces the Neumann condition by introducing a fictitious \"ghost\" point outside the domain. At the left boundary $x_0=0$, we introduce a ghost point at $x_{-1}=-h$. We approximate the boundary condition $u_x(0,t)=0$ using a second-order centered difference:\n$$\n\\frac{u_1 - u_{-1}}{2h} = 0 \\implies u_{-1} = u_1.\n$$\nThis relation reflects the solution value from the first interior point to the ghost point. We can now use the standard centered difference stencil for $u_{xx}$ at the boundary point $x_0$:\n$$\nu_{xx}(x_0) \\approx \\frac{u_{-1} - 2u_0 + u_1}{h^2} = \\frac{u_1 - 2u_0 + u_1}{h^2} = \\frac{2u_1 - 2u_0}{h^2}.\n$$\nBy symmetry, the approximation at the right boundary $x_{N-1}=L$ is:\n$$\nu_{xx}(x_{N-1}) \\approx \\frac{2u_{N-2} - 2u_{N-1}}{h^2}.\n$$\nThe crucial step is to analyze the local truncation error (LTE) of this boundary approximation. Using a Taylor expansion for $u(h)$ around $x=0$ and incorporating the condition $u_x(0)=0$:\n$$\nu(h) = u(0) + h u_x(0) + \\frac{h^2}{2}u_{xx}(0) + \\frac{h^3}{6}u_{xxx}(0) + O(h^4) = u(0) + \\frac{h^2}{2}u_{xx}(0) + \\frac{h^3}{6}u_{xxx}(0) + O(h^4).\n$$\nThe LTE of our approximation for $u_{xx}(0)$ is:\n$$\n\\text{LTE}_{\\text{GC}} = \\frac{2(u(h)-u(0))}{h^2} - u_{xx}(0) = \\frac{2}{h^2}\\left(\\frac{h^2}{2}u_{xx}(0) + \\frac{h^3}{6}u_{xxx}(0) + O(h^4)\\right) - u_{xx}(0) = \\frac{h}{3}u_{xxx}(0) + O(h^2).\n$$\nThe LTE is of order $O(h)$. This first-order error at the boundary will pollute the entire solution, causing the global error of the method to be first-order, i.e., $p_{\\text{GC}} \\approx 1$.\n\n**2. One-Sided (OS) Boundary Closure Method**\n\nThis method derives a one-sided formula for $u_{xx}(0)$ using points inside the domain ($u_0, u_1, u_2$) that is specifically constructed to be second-order accurate by making use of the $u_x(0)=0$ condition. We use Taylor series for $u_1=u(h)$ and $u_2=u(2h)$ around $x=0$, with $u_x(0)=0$:\n$$\nu_1 - u_0 = \\frac{h^2}{2} u_{xx}(0) + \\frac{h^3}{6} u_{xxx}(0) + \\frac{h^4}{24} u_{xxxx}(0) + O(h^5)\n$$\n$$\nu_2 - u_0 = \\frac{(2h)^2}{2} u_{xx}(0) + \\frac{(2h)^3}{6} u_{xxx}(0) + \\frac{(2h)^4}{24} u_{xxxx}(0) + O(h^5) = 2h^2 u_{xx}(0) + \\frac{4h^3}{3} u_{xxx}(0) + \\frac{2h^4}{3} u_{xxxx}(0) + O(h^5)\n$$\nWe seek a linear combination $A(u_1-u_0) + B(u_2-u_0)$ that eliminates the $u_{xxx}(0)$ term. The coefficient of $h^3 u_{xxx}(0)$ is $(\\frac{A}{6} + \\frac{4B}{3})$. Setting this to zero gives $A = -8B$. To recover $u_{xx}(0)$, we require the coefficient of $h^2 u_{xx}(0)$, which is $(\\frac{A}{2} + 2B)$, to be $1$. Substituting $A=-8B$ yields $-4B+2B=1 \\implies B=-1/2$, and thus $A=4$. So, $4(u_1-u_0) - \\frac{1}{2}(u_2-u_0) = h^2 u_{xx}(0) + O(h^4)$. Multiplying by $2$ gives $8(u_1-u_0) - (u_2-u_0) = 2h^2 u_{xx}(0) + O(h^4)$. This provides the approximation:\n$$\nu_{xx}(0) \\approx \\frac{8u_1 - u_2 - 7u_0}{2h^2}.\n$$\nThe LTE of this approximation is:\n$$\n\\text{LTE}_{\\text{OS}} = \\frac{-7u_0 + 8u_1 - u_2}{2h^2} - u_{xx}(0),\n$$\nwhich, from our derivation, is of order $O(h^2)$. Since the interior and boundary approximations are both second-order, the global error of the method is expected to be second-order, i.e., $p_{\\text{OS}} \\approx 2$. The corresponding formula at the right boundary is $u_{xx}(x_{N-1}) \\approx \\frac{-7u_{N-1} + 8u_{N-2} - u_{N-3}}{2h^2}$.\n\n**Numerical Procedure**\n\nThe two methods give rise to two different system matrices, $\\mathbf{A}_{\\text{GC}}$ and $\\mathbf{A}_{\\text{OS}}$. The ODE system is integrated exactly from $t=0$ to $t=T$ using the matrix exponential, $\\mathbf{u}(T) = \\exp(T\\mathbf{A})\\mathbf{u}(0)$, where $\\mathbf{u}(0)$ is the vector of initial conditions. This isolates the spatial discretization error. The maximum-norm error $e(N)$ is then calculated by comparing the numerical solution to the provided exact solution at time $T$. The observed order of accuracy $p$ is computed using the errors from two grid refinements, $N_1=81$ and $N_2=161$:\n$$\np=\\frac{\\log\\big(e(N_1)/e(N_2)\\big)}{\\log\\big(h_1/h_2\\big)},\n$$\nwhere $h_1=L/(N_1-1)$ and $h_2=L/(N_2-1)$. Since $h_1/h_2 = 160/80=2$, this simplifies to $p = \\log_2(e_{81}/e_{161})$.\nOur analysis predicts $p_{\\text{GC}} \\approx 1$ and $p_{\\text{OS}} \\approx 2$. Therefore, the condition $p_{\\text{OS}}  1.5$ and $p_{\\text{GC}}  1.5$ is expected to be true for all test cases.",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef build_matrix(N, L, alpha, method):\n    \"\"\"Constructs the spatial discretization matrix A for du/dt = A*u.\"\"\"\n    h = L / (N - 1)\n    A = np.zeros((N, N))\n    \n    # Interior points (common to both methods)\n    # u_xx approx is (u_i-1 - 2u_i + u_i+1) / h^2\n    for i in range(1, N - 1):\n        A[i, i - 1] = 1.0\n        A[i, i]     = -2.0\n        A[i, i + 1] = 1.0\n        \n    if method == \"GC\":\n        # Ghost-cell reflection: u_{-1}=u_1 and u_{N}=u_{N-2}\n        # u_xx(0) approx is (2u_1 - 2u_0) / h^2\n        A[0, 0] = -2.0\n        A[0, 1] = 2.0\n        # u_xx(L) approx is (2u_{N-2} - 2u_{N-1}) / h^2\n        A[N - 1, N - 2] = 2.0\n        A[N - 1, N - 1] = -2.0\n        A *= alpha / h**2\n        \n    elif method == \"OS\":\n        # One-sided 2nd-order closure\n        # u_xx(0) approx is (-7u_0 + 8u_1 - u_2) / (2h^2)\n        A[0, 0] = -7.0\n        A[0, 1] = 8.0\n        A[0, 2] = -1.0\n        # u_xx(L) approx is (-u_{N-3} + 8u_{N-2} - 7u_{N-1}) / (2h^2)\n        A[N - 1, N - 3] = -1.0\n        A[N - 1, N - 2] = 8.0\n        A[N - 1, N - 1] = -7.0\n        A[0,:] /= 2.0\n        A[N-1,:] /= 2.0\n        A *= alpha / h**2\n        \n    else:\n        raise ValueError(\"Unknown method specified\")\n        \n    return A\n\ndef get_exact_solution(x, t, alpha, n1, n2, L):\n    \"\"\"Computes the exact solution at given points x and time t.\"\"\"\n    term1 = np.exp(-alpha * (n1 * np.pi / L)**2 * t) * np.cos(n1 * np.pi * x / L)\n    term2 = 0.5 * np.exp(-alpha * (n2 * np.pi / L)**2 * t) * np.cos(n2 * np.pi * x / L)\n    return term1 + term2\n\ndef run_case(alpha, T, n1, n2, L, N_vals):\n    \"\"\"Runs a single test case for both GC and OS methods.\"\"\"\n    errors_gc = {}\n    errors_os = {}\n\n    for N in N_vals:\n        h = L / (N - 1)\n        x = np.linspace(0, L, N)\n        \n        # Initial condition\n        u0 = get_exact_solution(x, 0, alpha, n1, n2, L)\n        \n        # Exact solution at time T\n        u_exact_T = get_exact_solution(x, T, alpha, n1, n2, L)\n        \n        # --- Ghost-Cell Method ---\n        A_gc = build_matrix(N, L, alpha, \"GC\")\n        u_num_gc = expm(T * A_gc) @ u0\n        errors_gc[N] = np.max(np.abs(u_num_gc - u_exact_T))\n        \n        # --- One-Sided Method ---\n        A_os = build_matrix(N, L, alpha, \"OS\")\n        u_num_os = expm(T * A_os) @ u0\n        errors_os[N] = np.max(np.abs(u_num_os - u_exact_T))\n\n    # Compute order of accuracy using the two finest grids\n    N1, N2 = sorted(N_vals)[-2:]\n    h1 = L / (N1 - 1)\n    h2 = L / (N2 - 1)\n    \n    p_gc = np.log(errors_gc[N1] / errors_gc[N2]) / np.log(h1 / h2)\n    p_os = np.log(errors_os[N1] / errors_os[N2]) / np.log(h1 / h2)\n    \n    # Check the boolean condition\n    bool_check = (p_os  1.5) and (p_gc  1.5)\n    \n    return round(p_gc, 3), round(p_os, 3), bool_check\n\ndef solve():\n    # Problem definition\n    L = 1.0\n    n1, n2 = 2, 3\n    N_vals = [21, 41, 81, 161]\n    \n    test_cases = [\n        {'alpha': 1.0, 'T': 0.03},  # Case A\n        {'alpha': 0.1, 'T': 0.03},  # Case B\n        {'alpha': 1.0, 'T': 0.2},   # Case C\n    ]\n\n    results = []\n    for case in test_cases:\n        p_gc, p_os, bool_check = run_case(case['alpha'], case['T'], n1, n2, L, N_vals)\n        results.extend([p_gc, p_os, bool_check])\n\n    # Format output as a single comma-separated string in brackets\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Many physical systems, from chemical reactions to population dynamics, are described by \"stiff\" equations, where different processes occur on vastly different timescales. This practice tackles a stiff reaction-diffusion problem, challenging you to compare an Implicit-Explicit (IMEX) time-stepping scheme with a fully implicit one solved via Newton's method. You will investigate the critical trade-off between the complexity of each time step and the maximum stable step size, a central theme in the numerical solution of stiff PDEs. ",
            "id": "3159311",
            "problem": "You are asked to design, implement, and benchmark a Method of Lines (MOL) approach for a reaction–diffusion Partial Differential Equation (PDE) that exhibits stiffness due to its nonlinear reaction term. The MOL framework converts the spatial derivatives of the PDE into algebraic operators by spatial discretization, leaving a system of Ordinary Differential Equations (ODEs) in time to be integrated numerically. Your numerical experiment will compare two time integration strategies: an Implicit-Explicit (IMEX) scheme that treats diffusion implicitly and the stiff reaction explicitly, versus a fully implicit scheme that treats both terms implicitly and solves the resulting nonlinear equations with Newton’s method.\n\nStart from the following well-posed PDE problem in one spatial dimension:\n$$\nu_t = D u_{xx} + f(u), \\quad x \\in [0,1], \\quad t \\in [0,T]\n$$\nwith homogeneous Dirichlet boundary conditions\n$$\nu(0,t) = 0, \\quad u(1,t) = 0,\n$$\nand a smooth initial condition\n$$\nu(x,0) = \\sin(\\pi x).\n$$\nThe nonlinear reaction term is\n$$\nf(u) = \\lambda(u - u^3)\n$$\nwhere $D$ and $\\lambda$ are positive real parameters. In the presence of large $ \\lambda $, the source term $ f(u) $ induces stiffness.\n\nConstruct the MOL discretization by placing $N$ equidistant grid points on $[0,1]$ with spacing $h = 1/(N-1)$, applying the standard second-order central difference approximation for $u_{xx}$ on the $N-2$ interior points, and enforcing $ u(0,t) = u(1,t) = 0 $ at the boundaries. Denote the interior unknown vector by $y(t) \\in \\mathbb{R}^{N-2}$. The spatial discretization yields a linear operator $A \\in \\mathbb{R}^{(N-2)\\times(N-2)}$ representing $D u_{xx}$ with the tridiagonal stencil $(1,-2,1)/h^2$, so the semi-discrete ODE system is\n$$\n\\dot{y}(t) = A y(t) + f(y(t))\n$$\nwhere $f$ acts componentwise as $f(y)_i = \\lambda \\big(y_i - y_i^3\\big)$.\n\nImplement two time integration schemes to march from $t=0$ to $t=T$:\n\n- Implicit–Explicit (IMEX) Backward Euler for diffusion and Forward Euler for reaction. With time step $ \\Delta t $, for step $ n \\rightarrow n+1 $:\n$$\n\\big(I - \\Delta t \\, A\\big) y^{n+1} = y^{n} + \\Delta t \\, f(y^{n})\n$$\nwhere $I$ is the identity matrix.\n\n- Fully implicit Backward Euler for both terms. For step $ n \\rightarrow n+1 $:\n$$\ny^{n+1} - \\Delta t \\, A y^{n+1} - \\Delta t \\, f(y^{n+1}) = y^{n}.\n$$\nSolve the nonlinear system by Newton’s method. Let\n$$\nF(v) = v - \\Delta t \\, A v - \\Delta t \\, f(v) - y^{n}.\n$$\nNewton’s iteration updates $v$ by solving\n$$\n\\Big(I - \\Delta t \\, A - \\Delta t \\, \\operatorname{diag}\\big(f'(v)\\big)\\Big) \\, \\delta = -F(v), \\quad v \\leftarrow v + \\delta\n$$\nuntil the residual norm $ \\|F(v)\\|_2 $ is below a chosen tolerance. Here $f'(u) = \\lambda(1 - 3 u^2)$.\n\nYour program must be a complete, runnable implementation of both schemes, using the above discretization and time marching rules. It must perform the following test suite of three cases, each specified by parameters $ (N, D, \\lambda, T, \\Delta t_{\\mathrm{IMEX}}, \\Delta t_{\\mathrm{IMP}}) $:\n\n- Case $1$: $ N = 50 $, $ D = 0.01 $, $ \\lambda = 200 $, $ T = 0.02 $, $ \\Delta t_{\\mathrm{IMEX}} = 2\\times 10^{-5} $, $ \\Delta t_{\\mathrm{IMP}} = 2\\times 10^{-4} $.\n- Case $2$: $ N = 70 $, $ D = 0.005 $, $ \\lambda = 700 $, $ T = 0.01 $, $ \\Delta t_{\\mathrm{IMEX}} = 1\\times 10^{-5} $, $ \\Delta t_{\\mathrm{IMP}} = 2\\times 10^{-4} $.\n- Case $3$: $ N = 30 $, $ D = 0.02 $, $ \\lambda = 100 $, $ T = 0.05 $, $ \\Delta t_{\\mathrm{IMEX}} = 1\\times 10^{-4} $, $ \\Delta t_{\\mathrm{IMP}} = 1\\times 10^{-3} $.\n\nFor each case, compute the following three metrics:\n\n- $m_1$: the discrete $L^2$ norm of the difference between the IMEX and fully implicit solutions at final time $ T $, i.e.,\n$$\nm_1 = \\big\\| y_{\\mathrm{IMEX}}(T) - y_{\\mathrm{IMP}}(T) \\big\\|_2\n$$\n- $m_2$: the ratio of the number of time steps taken by IMEX versus fully implicit,\n$$\nm_2 = \\frac{N_{\\mathrm{steps,IMEX}}}{N_{\\mathrm{steps,IMP}}}\n$$\n- $m_3$: the total number of Newton iterations used by the fully implicit solver over the whole integration to reach $ T $.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain the nine floating-point results in the order $[m_1^{(1)}, m_2^{(1)}, m_3^{(1)}, m_1^{(2)}, m_2^{(2)}, m_3^{(2)}, m_1^{(3)}, m_2^{(3)}, m_3^{(3)}]$, where the superscript corresponds to the case number. Each float must be rounded to six decimal places. No physical units are involved in this problem, so do not append any units to the outputs.",
            "solution": "The problem requires the design and implementation of two numerical schemes based on the Method of Lines (MOL) for solving a stiff one-dimensional reaction-diffusion Partial Differential Equation (PDE). We will compare an Implicit-Explicit (IMEX) scheme with a fully implicit scheme.\n\nThe governing PDE is given by:\n$$\nu_t = D u_{xx} + f(u), \\quad x \\in [0,1], \\quad t \\in [0,T]\n$$\nwith homogeneous Dirichlet boundary conditions $u(0,t) = u(1,t) = 0$ and initial condition $u(x,0) = \\sin(\\pi x)$. The nonlinear reaction term is $f(u) = \\lambda(u - u^3)$, which induces stiffness for large $\\lambda  0$.\n\nThe first step in the Method of Lines is to discretize the spatial domain. We define a uniform grid with $N$ points $x_j = j \\cdot h$ for $j=0, 1, \\dots, N-1$, where the grid spacing is $h = 1/(N-1)$. The solution at the interior grid points $x_1, \\dots, x_{N-2}$ is represented by a time-dependent vector $y(t) \\in \\mathbb{R}^{N-2}$, where $y_i(t) \\approx u(x_{i+1}, t)$. The boundary conditions imply $u(x_0,t) = 0$ and $u(x_{N-1},t) = 0$.\n\nThe second spatial derivative $u_{xx}$ at an interior point $x_j$ is approximated using a second-order central difference formula:\n$$\nu_{xx}(x_j, t) \\approx \\frac{u(x_{j-1}, t) - 2u(x_j, t) + u(x_{j+1}, t)}{h^2}\n$$\nApplying this to all $N-2$ interior points and incorporating the boundary conditions results in a system of Ordinary Differential Equations (ODEs). The discretization of the diffusion term $D u_{xx}$ forms a linear operator represented by a matrix $A \\in \\mathbb{R}^{(N-2)\\times(N-2)}$. The matrix $A$ is tridiagonal, with diagonal elements equal to $-2D/h^2$ and sub- and super-diagonal elements equal to $D/h^2$.\n\nThe semi-discrete system of ODEs is:\n$$\n\\frac{d y}{d t} = \\dot{y}(t) = A y(t) + f(y(t))\n$$\nwhere the function $f$ is applied element-wise to the vector $y(t)$, i.e., $[f(y(t))]_i = \\lambda(y_i(t) - y_i(t)^3)$. The initial condition for this ODE system is $y(0)_i = \\sin(\\pi x_{i+1})$ for $i=0, \\dots, N-3$. Wait, indexing is tricky. Let's use $i=1..N-2$. $y_i(t) \\approx u(x_i, t)$ for $i=1..N-2$. Then $y(0)_i = \\sin(\\pi x_i)$. The vector index in code will be $0..N-3$. Let's stick to Python indexing from $0$ to $N-3$ for the vector $y$ of size $N-2$. So $y_i(t) \\approx u(x_{i+1}, t)$. Then $y_i(0) = \\sin(\\pi x_{i+1})$.\n\nNext, we discretize in time. We will implement and compare two first-order schemes. Let $y^n$ be the numerical solution at time $t_n = n \\Delta t$.\n\n**Scheme 1: Implicit-Explicit (IMEX) Euler Method**\nThis scheme treats the stiff linear diffusion term implicitly (using Backward Euler) and the nonlinear reaction term explicitly (using Forward Euler). This combination is often chosen to handle the stiffness from diffusion without solving a nonlinear system at each step. The update from $y^n$ to $y^{n+1}$ is:\n$$\n\\frac{y^{n+1} - y^n}{\\Delta t} = A y^{n+1} + f(y^n)\n$$\nRearranging to solve for $y^{n+1}$, we obtain a linear system:\n$$\n(I - \\Delta t A) y^{n+1} = y^n + \\Delta t f(y^n)\n$$\nwhere $I$ is the identity matrix. The matrix on the left-hand side, $M_{\\mathrm{IMEX}} = (I - \\Delta t A)$, is constant throughout the integration. For efficiency, we can compute its LU factorization once before the time-stepping loop and then use forward/backward substitution to solve for $y^{n+1}$ at each step.\n\n**Scheme 2: Fully Implicit Euler Method**\nThis scheme treats both the diffusion and reaction terms implicitly:\n$$\n\\frac{y^{n+1} - y^n}{\\Delta t} = A y^{n+1} + f(y^{n+1})\n$$\nThis is a system of nonlinear algebraic equations for $y^{n+1}$. We define a residual function $F(v)$ where $v$ is a candidate for $y^{n+1}$:\n$$\nF(v) = v - \\Delta t A v - \\Delta t f(v) - y^n = 0\n$$\nWe solve this system using Newton's method. Starting with an initial guess (e.g., $v_0 = y^n$), we iteratively refine the solution. The $k$-th Newton iteration is:\n$$\nJ_F(v_k) \\delta_k = -F(v_k), \\quad v_{k+1} = v_k + \\delta_k\n$$\nwhere $J_F(v)$ is the Jacobian matrix of $F(v)$:\n$$\nJ_F(v) = \\frac{\\partial F}{\\partial v} = I - \\Delta t A - \\Delta t \\frac{\\partial f(v)}{\\partial v}\n$$\nThe derivative of the component-wise function $f(v)$ is a diagonal matrix: $\\frac{\\partial f(v)}{\\partial v} = \\operatorname{diag}(f'(v_i))$, with $f'(u) = \\lambda(1 - 3u^2)$.\nThe Jacobian $J_F(v)$ is a tridiagonal matrix, as it is the sum of a tridiagonal matrix $(I - \\Delta t A)$ and a diagonal matrix. This structure allows the linear system for $\\delta_k$ to be solved very efficiently at each Newton iteration, for example, using a banded matrix solver. The iterations continue until the L2-norm of the residual, $\\|F(v)\\|_2$, falls below a specified tolerance.\n\nFinally, for each test case, we compute the specified metrics:\n- $m_1 = \\| y_{\\mathrm{IMEX}}(T) - y_{\\mathrm{IMP}}(T) \\|_2$: The discrete L2 norm of the difference between the final solutions.\n- $m_2 = N_{\\mathrm{steps,IMEX}} / N_{\\mathrm{steps,IMP}} = (T/\\Delta t_{\\mathrm{IMEX}}) / (T/\\Delta t_{\\mathrm{IMP}}) = \\Delta t_{\\mathrm{IMP}} / \\Delta t_{\\mathrm{IMEX}}$: The ratio of time steps.\n- $m_3$: The total count of Newton iterations performed by the fully implicit solver over all time steps to reach $T$.\n\nThe implementation will follow these mathematical and algorithmic formulations precisely.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import lu_factor, lu_solve, solve_banded\n\n# from scipy import ...\n\ndef create_diffusion_matrix(N, D):\n    \"\"\"Constructs the diffusion matrix A for the interior grid points.\"\"\"\n    num_interior = N - 2\n    h = 1.0 / (N - 1)\n    \n    diag_val = -2.0 * D / h**2\n    offdiag_val = D / h**2\n    \n    A_diag = diag_val * np.ones(num_interior)\n    A_offdiag = offdiag_val * np.ones(num_interior - 1)\n    \n    # Using np.diag to build the sparse matrix as a dense numpy array\n    A = np.diag(A_diag) + np.diag(A_offdiag, k=1) + np.diag(A_offdiag, k=-1)\n    return A\n\ndef run_imex(N, D, lam, T, dt):\n    \"\"\"\n    Solves the reaction-diffusion PDE using the IMEX scheme.\n    (Implicit Euler for diffusion, Explicit Euler for reaction)\n    \"\"\"\n    num_interior = N - 2\n    \n    # Grid and initial condition for interior points\n    x = np.linspace(0, 1, N)\n    y = np.sin(np.pi * x[1:-1])\n    \n    # Diffusion matrix A\n    A = create_diffusion_matrix(N, D)\n    \n    # IMEX system matrix (I - dt*A)\n    I = np.identity(num_interior)\n    LHS = I - dt * A\n    \n    # Pre-compute LU factorization for efficiency\n    lu, piv = lu_factor(LHS)\n    \n    # Reaction function\n    def f(u):\n        return lam * (u - u**3)\n        \n    num_steps = int(round(T / dt))\n    \n    for _ in range(num_steps):\n        RHS = y + dt * f(y)\n        y = lu_solve((lu, piv), RHS)\n        \n    return y\n\ndef run_implicit(N, D, lam, T, dt):\n    \"\"\"\n    Solves the reaction-diffusion PDE using the fully implicit Euler scheme\n    with Newton's method for the nonlinear system.\n    \"\"\"\n    num_interior = N - 2\n    h = 1.0 / (N - 1)\n    \n    # Grid and initial condition for interior points\n    x = np.linspace(0, 1, N)\n    y_n = np.sin(np.pi * x[1:-1])  # Solution at step n\n    \n    # Diffusion matrix A components\n    A_diag_vals = -2.0 * D / h**2 * np.ones(num_interior)\n    A_offdiag_vals = D / h**2 * np.ones(num_interior - 1)\n    A = np.diag(A_diag_vals) + np.diag(A_offdiag_vals, k=1) + np.diag(A_offdiag_vals, k=-1)\n\n    # Reaction function and its derivative\n    def f(u):\n        return lam * (u - u**3)\n    def f_prime(u):\n        return lam * (1 - 3 * u**2)\n        \n    num_steps = int(round(T / dt))\n    total_newton_iters = 0\n    newton_tol = 1e-10\n    max_newton_iters = 20\n\n    for _ in range(num_steps):\n        v = y_n.copy()  # Initial guess for y^{n+1}\n        \n        for k in range(max_newton_iters):\n            total_newton_iters += 1\n            \n            # Calculate residual F(v) = v - dt*(A@v + f(v)) - y_n\n            F_v = v - dt * (A @ v + f(v)) - y_n\n            \n            if np.linalg.norm(F_v)  newton_tol:\n                break\n            \n            # Calculate Jacobian J(v) = I - dt*A - dt*diag(f'(v))\n            # J is tridiagonal, so we construct it in banded form for solve_banded\n            J_diag = 1.0 - dt * A_diag_vals - dt * f_prime(v)\n            J_offdiag = -dt * A_offdiag_vals\n            \n            J_banded = np.zeros((3, num_interior))\n            J_banded[0, 1:] = J_offdiag\n            J_banded[1, :] = J_diag\n            J_banded[2, :-1] = J_offdiag\n            \n            # Solve the linear system J * delta = -F(v)\n            delta = solve_banded((1, 1), J_banded, -F_v)\n            v += delta\n        \n        y_n = v  # Update solution for next time step\n   \n    return y_n, total_newton_iters\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and compute metrics.\n    \"\"\"\n    test_cases = [\n        # (N, D, lambda, T, dt_imex, dt_imp)\n        (50, 0.01, 200, 0.02, 2e-5, 2e-4),\n        (70, 0.005, 700, 0.01, 1e-5, 2e-4),\n        (30, 0.02, 100, 0.05, 1e-4, 1e-3),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, D, lam, T, dt_imex, dt_imp = case\n        \n        # Run IMEX solver\n        y_imex_final = run_imex(N, D, lam, T, dt_imex)\n        \n        # Run Fully Implicit solver\n        y_imp_final, total_newton_iters = run_implicit(N, D, lam, T, dt_imp)\n        \n        # Metric 1: L2 norm of the difference\n        m1 = np.linalg.norm(y_imex_final - y_imp_final)\n        \n        # Metric 2: Ratio of time steps\n        m2 = dt_imp / dt_imex\n        \n        # Metric 3: Total Newton iterations\n        m3 = float(total_newton_iters)\n        \n        results.extend([m1, m2, m3])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\nsolve()\n```"
        }
    ]
}