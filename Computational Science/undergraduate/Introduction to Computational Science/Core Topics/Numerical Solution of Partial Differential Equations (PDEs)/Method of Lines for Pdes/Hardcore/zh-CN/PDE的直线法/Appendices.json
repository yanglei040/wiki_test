{
    "hands_on_practices": [
        {
            "introduction": "对于对流占主导的输运问题，选择合适的空间离散格式至关重要。本练习将探讨对流-扩散方程，当对流速度 $a$ 远大于扩散系数 $\\nu$ 时，标准的中心差分格式可能会产生非物理的振荡，导致数值不稳定。通过亲手实现并比较中心差分与迎风格式，您将能够直观地观察和量化这两种方法在稳定性上的巨大差异，从而深刻理解数值耗散在稳定平流主导问题中的作用。",
            "id": "2444647",
            "problem": "考虑具有周期性边界条件的一维线性平流-扩散偏微分方程（PDE），\n$$\n\\frac{\\partial u}{\\partial t}(x,t) + a \\,\\frac{\\partial u}{\\partial x}(x,t) = \\nu \\,\\frac{\\partial^2 u}{\\partial x^2}(x,t), \\quad x \\in [0,1], \\quad t \\in [0,T],\n$$\n其空间周期性为 $u(0,t) = u(1,t)$（对所有 $t \\in [0,T]$ 成立），初始条件为\n$$\nu(x,0) = \\sin(2\\pi x) + 0.1 \\sin(16\\pi x).\n$$\n设空间网格是均匀的，有 $N$ 个点，间距为 $\\Delta x = 1/N$，并采用周期性索引。在网格值 $u_j(t) \\approx u(x_j,t)$（其中 $x_j = j \\,\\Delta x$）上定义两个半离散空间算子：\n- 中心平流格式，采用二阶中心差分和二阶导数扩散，\n$$\n\\left.\\frac{\\mathrm{d}u_j}{\\mathrm{d}t}\\right|_{\\text{centered}} = -a \\,\\frac{u_{j+1} - u_{j-1}}{2\\Delta x} + \\nu \\,\\frac{u_{j+1} - 2u_j + u_{j-1}}{\\Delta x^2}.\n$$\n- 迎风平流格式（与 $a$ 的符号一致的一阶迎风格式）和二阶导数扩散，\n$$\n\\left.\\frac{\\mathrm{d}u_j}{\\mathrm{d}t}\\right|_{\\text{upwind}} =\n\\begin{cases}\n-a \\,\\frac{u_j - u_{j-1}}{\\Delta x} + \\nu \\,\\frac{u_{j+1} - 2u_j + u_{j-1}}{\\Delta x^2},  a \\ge 0, \\\\\n-a \\,\\frac{u_{j+1} - u_j}{\\Delta x} + \\nu \\,\\frac{u_{j+1} - 2u_j + u_{j-1}}{\\Delta x^2},  a  0.\n\\end{cases}\n$$\n使用显式前向欧拉法以时间步长 $\\Delta t$ 向前推进至最终时间 $T$。对于每次模拟，将时间层 $n$ 的离散 $L^2$ 范数定义为\n$$\n\\|u^n\\|_2 = \\left( \\Delta x \\sum_{j=0}^{N-1} \\left(u_j^n\\right)^2 \\right)^{1/2}.\n$$\n如果所有时间步中的最大范数满足以下条件，则宣布一次运行为“稳定”\n$$\n\\max_{0 \\le n \\le N_t} \\|u^n\\|_2 \\le G_{\\max} \\,\\|u^0\\|_2,\n$$\n否则为“不稳定”，其中 $G_{\\max} = 5$ 是固定值，$N_t$ 是达到 $T$ 所需的时间步数。根据无量纲因子 $C_{\\mathrm{adv}}$ 和 $C_{\\mathrm{diff}}$ 确定的平流和扩散界限的最小值来选择时间步长，如下所示：\n$$\n\\Delta t =\n\\min\\!\\left(\n\\begin{array}{l}\nC_{\\mathrm{adv}} \\,\\frac{\\Delta x}{|a|} \\quad \\text{if } |a|0, \\text{ otherwise } +\\infty, \\\\\nC_{\\mathrm{diff}} \\,\\frac{\\Delta x^2}{2\\nu} \\quad \\text{if } \\nu0, \\text{ otherwise } +\\infty\n\\end{array}\n\\right).\n$$\n如果 $|a|=0$ 和 $\\nu=0$ 同时成立，则此设置不在测试中考虑。\n\n您的任务是实现上述定义，并针对下面的每个测试用例，确定在根据给定参数计算出的相同 $\\Delta t$ 下，中心格式和迎风格式是否稳定。该域是无量纲的，输出中不需要物理单位。\n\n使用以下测试套件，其中每个用例指定了 $(a,\\nu,N,C_{\\mathrm{adv}},C_{\\mathrm{diff}},T)$：\n- 测试 1：$(a,\\nu,N,C_{\\mathrm{adv}},C_{\\mathrm{diff}},T) = (\\,1.0,\\,0.001,\\,200,\\,0.5,\\,0.4,\\,0.5\\,)$。\n- 测试 2：$(a,\\nu,N,C_{\\mathrm{adv}},C_{\\mathrm{diff}},T) = (\\,20.0,\\,0.0001,\\,400,\\,0.8,\\,0.2,\\,0.2\\,)$。\n- 测试 3：$(a,\\nu,N,C_{\\mathrm{adv}},C_{\\mathrm{diff}},T) = (\\,0.0,\\,0.01,\\,100,\\,0.5,\\,0.4,\\,0.5\\,)$。\n- 测试 4：$(a,\\nu,N,C_{\\mathrm{adv}},C_{\\mathrm{diff}},T) = (\\,1.0,\\,0.0,\\,200,\\,0.99,\\,0.0,\\,0.5\\,)$。\n\n您的程序必须：\n- 在每个测试用例中，对中心格式和迎风格式使用相同的 $\\Delta t$，该 $\\Delta t$ 需严格按照上述定义计算。\n- 积分至指定的最终时间 $T$（如果 $\\Delta t$ 不能整除 $T$，则取 $N_t = \\lceil T/\\Delta t \\rceil$ 并使用均匀的时间步长 $T/N_t$）。\n- 对于每个测试，根据 $G_{\\max} = 5$ 的准则，按 $\\big[$中心格式稳定性, 迎风格式稳定性$\\big]$ 的顺序返回两个布尔值。\n\n最终输出格式：您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。按测试顺序连接四个测试的结果，将布尔值展平为单个列表。例如，输出格式应如下所示\n$$\n[\\text{c}_1,\\text{u}_1,\\text{c}_2,\\text{u}_2,\\text{c}_3,\\text{u}_3,\\text{c}_4,\\text{u}_4],\n$$\n其中 $\\text{c}_k$ 和 $\\text{u}_k$ 分别是测试 $k$ 中中心格式和迎风格式的布尔稳定性结果。",
            "solution": "所提出的问题已经过验证，并被认定为有效。它具有科学依据，是适定的、客观的，并包含获得唯一、可验证解所需的所有必要信息。因此，我们可以着手推导和实施解决方案。\n\n该问题要求数值求解一维线性平流-扩散方程，\n$$\n\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = \\nu \\frac{\\partial^2 u}{\\partial x^2},\n$$\n求解域为 $x \\in [0,1]$，边界条件为周期性。解将使用线方法（Method of Lines, MOL）获得，即首先对空间导数进行离散化，将偏微分方程（PDE）转化为一个耦合常微分方程组（ODEs）。然后对该系统进行时间积分。\n\n首先，我们定义离散空间网格。将域 $[0,1]$ 离散化为 $N$ 个长度为 $\\Delta x = 1/N$ 的均匀段。网格点为 $x_j = j\\Delta x$，其中 $j = 0, 1, \\dots, N-1$。此网格上的解由向量 $\\vec{u}(t)$ 表示，其第 $j$ 个分量为 $u_j(t) \\approx u(x_j, t)$。周期性边界条件意味着对于任何整数 $j$，都有 $u_{j+N} = u_j$。\n\n线方法将 PDE 转换为 $\\frac{d\\vec{u}}{dt} = \\mathbf{L}\\vec{u}$ 的形式，其中 $\\mathbf{L}$ 是一个表示离散化空间算子的矩阵。我们被要求评估平流项 $\\frac{\\partial u}{\\partial x}$ 的两种不同离散化方法，而扩散项 $\\frac{\\partial^2 u}{\\partial x^2}$ 则统一使用标准的二阶中心差分进行离散化。\n\n二阶导数的二阶中心差分近似为：\n$$\n\\left.\\frac{\\partial^2 u}{\\partial x^2}\\right|_{x_j} \\approx \\frac{u_{j+1} - 2u_j + u_{j-1}}{\\Delta x^2}.\n$$\n该算子应用于两种格式。\n\n格式 1：中心平流\n平流项使用二阶中心差分进行近似：\n$$\n\\left.\\frac{\\partial u}{\\partial x}\\right|_{x_j} \\approx \\frac{u_{j+1} - u_{j-1}}{2\\Delta x}.\n$$\n结合这些，中心格式的半离散系统为：\n$$\n\\frac{d u_j}{d t} = -a \\left(\\frac{u_{j+1} - u_{j-1}}{2\\Delta x}\\right) + \\nu \\left(\\frac{u_{j+1} - 2u_j + u_{j-1}}{\\Delta x^2}\\right).\n$$\n\n格式 2：迎风平流\n平流项使用一阶迎风差分进行近似，其差分格式（stencil）取决于平流速度 $a$ 的符号。做出此选择是为了引入数值耗散以增强稳定性。\n如果 $a \\ge 0$，则使用后向差分：\n$$\n\\left.\\frac{\\partial u}{\\partial x}\\right|_{x_j} \\approx \\frac{u_j - u_{j-1}}{\\Delta x}.\n$$\n如果 $a  0$，则使用前向差分：\n$$\n\\left.\\frac{\\partial u}{\\partial x}\\right|_{x_j} \\approx \\frac{u_{j+1} - u_j}{\\Delta x}.\n$$\n因此，迎风格式对应的半离散系统为：\n$$\n\\frac{d u_j}{d t} =\n\\begin{cases}\n-a \\left(\\frac{u_j - u_{j-1}}{\\Delta x}\\right) + \\nu \\left(\\frac{u_{j+1} - 2u_j + u_{j-1}}{\\Delta x^2}\\right),  a \\ge 0 \\\\\n-a \\left(\\frac{u_{j+1} - u_j}{\\Delta x}\\right) + \\nu \\left(\\frac{u_{j+1} - 2u_j + u_{j-1}}{\\Delta x^2}\\right),  a  0\n\\end{cases}\n$$\n\n对于时间积分，指定了显式前向欧拉法。给定时间 $t_n$ 的解向量 $\\vec{u}^n$，下一个时间步 $t_{n+1} = t_n + \\Delta t$ 的解计算如下：\n$$\n\\vec{u}^{n+1} = \\vec{u}^n + \\Delta t \\cdot \\frac{d\\vec{u}}{dt}\\bigg|_{\\vec{u}=\\vec{u}^n}.\n$$\n时间步长 $\\Delta t$ 必须谨慎选择以确保数值稳定性。前向欧拉法只是条件稳定的。问题提供了一个基于平流和扩散的 Courant-Friedrichs-Lewy (CFL) 条件的初步时间步长 $\\Delta t_{cfl}$ 的具体公式：\n$$\n\\Delta t_{cfl} = \\min\\left( C_{\\mathrm{adv}} \\frac{\\Delta x}{|a|}, \\; C_{\\mathrm{diff}} \\frac{\\Delta x^2}{2\\nu} \\right).\n$$\n如果其分母（$|a|$ 或 $\\nu$）为零，则相应项被视为无穷大。为确保模拟在时间 $T$ 准时结束，步数固定为 $N_t = \\lceil T/\\Delta t_{cfl} \\rceil$，并使用一个统一的实际时间步长 $\\Delta t = T/N_t$ 进行积分。这确保了 $\\Delta t \\le \\Delta t_{cfl}$，从而保持了稳定性约束。\n\n每次模拟运行的稳定性都会进行定量评估。如果整个模拟过程中观察到的最大离散 $L^2$ 范数不超过初始范数的特定倍数，则该次运行被宣告为“稳定”。时间步 $n$ 的离散 $L^2$ 范数为：\n$$\n\\|u^n\\|_2 = \\left( \\Delta x \\sum_{j=0}^{N-1} (u_j^n)^2 \\right)^{1/2}.\n$$\n稳定性准则为：\n$$\n\\max_{0 \\le n \\le N_t} \\|u^n\\|_2 \\le G_{\\max} \\|u^0\\|_2,\n$$\n其中增长因子给定为 $G_{\\max} = 5$。初始条件由 $u(x,0) = \\sin(2\\pi x) + 0.1 \\sin(16\\pi x)$ 给出，在网格上对其求值以提供初始向量 $\\vec{u}^0$。\n\n每个测试用例的算法流程如下：\n1. 设置参数 $(a, \\nu, N, C_{\\mathrm{adv}}, C_{\\mathrm{diff}}, T)$。\n2. 计算网格间距 $\\Delta x = 1/N$ 并创建网格点 $x_j$。\n3. 通过计算 $u(x_j, 0)$ 生成初始条件向量 $\\vec{u}^0$。\n4. 计算初始范数 $\\|u^0\\|_2$ 和稳定性阈值 $G_{\\max} \\|u^0\\|_2$。\n5. 计算 $\\Delta t_{cfl}$，然后计算实际时间步长 $\\Delta t = T/\\lceil T/\\Delta t_{cfl} \\rceil$。\n6. 对于每种格式（中心格式和迎风格式）：\n    a. 初始化解向量 $\\vec{u} = \\vec{u}^0$ 并设置 $\\text{max\\_norm} = \\|u^0\\|_2$。\n    b. 循环 $N_t$ 次：\n        i. 使用适当的有限差分公式计算右侧向量 $\\frac{d\\vec{u}}{dt}$。\n        ii. 使用前向欧拉步更新解：$\\vec{u} \\leftarrow \\vec{u} + \\Delta t \\frac{d\\vec{u}}{dt}$。\n        iii. 计算当前范数 $\\|\\vec{u}\\|_2$ 并在必要时更新 $\\text{max\\_norm}$。如果解变为非有限值，$\\text{max\\_norm}$ 将变为无穷大。\n    c. 将最终的 $\\text{max\\_norm}$ 与阈值进行比较，以确定稳定性（真/假）。\n7. 收集两种格式的布尔稳定性结果，并将它们附加到全局列表中。\n\n此过程将为所有提供的测试用例实施，并且最终的布尔结果列表将按规定格式化。使用向量化操作，特别是周期性移位，可以高效地在周期性网格上实现有限差分。",
            "answer": "```python\nimport numpy as np\nimport math\n\ndef get_rhs_calculator(a, nu, N, scheme):\n    \"\"\"\n    Returns a function that computes the right-hand side of the semi-discretized PDE.\n    This corresponds to the spatial operator applied to the solution vector u.\n    \"\"\"\n    dx = 1.0 / N\n    d2udx2_term_func = lambda u: (np.roll(u, -1) - 2 * u + np.roll(u, 1)) / (dx**2)\n\n    if scheme == 'centered':\n        def rhs_centered(u):\n            dudx_adv = (np.roll(u, -1) - np.roll(u, 1)) / (2 * dx)\n            return -a * dudx_adv + nu * d2udx2_term_func(u)\n        return rhs_centered\n    elif scheme == 'upwind':\n        def rhs_upwind(u):\n            if a >= 0:\n                dudx_adv = (u - np.roll(u, 1)) / dx\n            else:  # a  0\n                dudx_adv = (np.roll(u, -1) - u) / dx\n            return -a * dudx_adv + nu * d2udx2_term_func(u)\n        return rhs_upwind\n    else:\n        raise ValueError(\"Unknown scheme type\")\n\ndef check_stability(params, scheme, G_max):\n    \"\"\"\n    Runs a single simulation for a given test case and scheme, then reports its stability.\n    \"\"\"\n    a, nu, N, C_adv, C_diff, T = params\n\n    # 1. Grid and Initial Condition\n    dx = 1.0 / N\n    x = np.arange(N, dtype=float) / N\n    u = np.sin(2 * np.pi * x) + 0.1 * np.sin(16 * np.pi * x)\n\n    # 2. Initial norm and stability threshold\n    norm_initial = np.sqrt(dx * np.sum(u**2))\n    if norm_initial == 0:\n        return True  # Trivial case: zero initial condition is always stable\n    max_norm = norm_initial\n\n    # 3. Time step calculation\n    dt_adv = C_adv * dx / abs(a) if abs(a) > 0 else float('inf')\n    dt_diff = C_diff * dx**2 / (2 * nu) if nu > 0 else float('inf')\n    dt_cfl = min(dt_adv, dt_diff)\n\n    if T == 0:\n        return True\n    if dt_cfl == float('inf'): # Corresponds to a=0 and nu=0 case, u(x,t) is constant.\n      return True\n\n    num_steps = math.ceil(T / dt_cfl)\n    dt = T / num_steps\n    \n    # 4. Get the appropriate RHS function for the scheme\n    rhs_calculator = get_rhs_calculator(a, nu, N, scheme)\n\n    # 5. Time integration loop\n    for _ in range(num_steps):\n        u = u + dt * rhs_calculator(u)\n        \n        current_norm = np.sqrt(dx * np.sum(u**2))\n        \n        if np.isnan(current_norm) or np.isinf(current_norm):\n            max_norm = float('inf')\n            break\n            \n        if current_norm > max_norm:\n            max_norm = current_norm\n            \n    # 6. Check stability criterion\n    return max_norm = G_max * norm_initial\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # (a,      nu,       N,   C_adv, C_diff, T)\n        (1.0,    0.001,    200, 0.5,   0.4,    0.5),\n        (20.0,   0.0001,   400, 0.8,   0.2,    0.2),\n        (0.0,    0.01,     100, 0.5,   0.4,    0.5),\n        (1.0,    0.0,      200, 0.99,  0.0,    0.5),\n    ]\n\n    G_max = 5.0\n    results = []\n\n    for i, case in enumerate(test_cases):\n        is_stable_cen = check_stability(case, 'centered', G_max)\n        is_stable_upw = check_stability(case, 'upwind', G_max)\n        results.extend([is_stable_cen, is_stable_upw])\n\n    # Final print statement in the exact required format.\n    # str(True) -> 'True', str(False) -> 'False'\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了基本的离散化技术后，我们必须关注一个常常决定成败的细节：边界条件的处理。一个数值方法的整体精度往往受其最薄弱环节的限制，而边界条件的实施恰恰是常见的“短板”。本练习将研究带有诺伊曼 (Neumann) 边界条件的热传导方程，您将实现两种常见的处理方法——简单的“虚拟单元格”法和更精确的单边差分公式，并通过数值实验验证您对边界格式的选择如何直接决定了整个求解方案的全局收敛阶。",
            "id": "3159236",
            "problem": "考虑有限区间上的一维热方程，它是一种典型的抛物型偏微分方程，\n$$\nu_t(x,t) = \\alpha\\,u_{xx}(x,t), \\quad 0 \\le x \\le L,\\quad 0  t \\le T,\n$$\n其齐次诺伊曼边界条件为\n$$\nu_x(0,t)=0,\\quad u_x(L,t)=0,\n$$\n初始条件由余弦模式的叠加构成，\n$$\nu(x,0)=\\cos\\!\\Big(\\frac{n_1\\pi x}{L}\\Big)+\\frac{1}{2}\\cos\\!\\Big(\\frac{n_2\\pi x}{L}\\Big),\n$$\n其中 $n_1$ 和 $n_2$ 是正整数。对于这些数据，其精确解为\n$$\nu(x,t)=\\exp\\!\\Big(-\\alpha\\Big(\\frac{n_1\\pi}{L}\\Big)^2 t\\Big)\\cos\\!\\Big(\\frac{n_1\\pi x}{L}\\Big)+\\frac{1}{2}\\exp\\!\\Big(-\\alpha\\Big(\\frac{n_2\\pi}{L}\\Big)^2 t\\Big)\\cos\\!\\Big(\\frac{n_2\\pi x}{L}\\Big).\n$$\n\n你的任务是使用线方法 (Method of Lines, MOL) 在一个包含 $N$ 个点（包括边界）的均匀网格上进行空间半离散化，网格间距为 $h=L/(N-1)$，从而形成一个形如下式的常微分方程线性系统\n$$\n\\frac{d\\mathbf{u}}{dt}=\\mathbf{A}\\,\\mathbf{u},\n$$\n其中 $\\mathbf{u}(t)\\in\\mathbb{R}^N$ 是在网格节点 $x_i=i\\,h$（$i=0,1,\\dots,N-1$）处对 $u(x_i,t)$ 的近似。对于内部节点 $i=1,\\dots,N-2$，使用标准的二阶中心有限差分近似来计算 $u_{xx}$。在边界处，实现并比较以下两种用于诺伊曼条件 $u_x(0,t)=u_x(L,t)=0$ 的闭合方案：\n\n- 虚单元反射 (Ghost-cell reflection, GC)：通过在区域外扩展解，引入与零法向导数一致的虚拟节点来强制施加诺伊曼条件，然后消去这些虚单元值，从而在物理节点上获得一个封闭的半离散系统。\n\n- 单边边界闭合 (One-sided boundary closure, OS)：通过使用受 $u_x=0$ 约束的泰勒展开来消去任何虚单元值，从而在 $x=0$ 和 $x=L$ 处推导出至少为 $h$ 的二阶精度的 $u_{xx}$ 单边边界公式。\n\n通过矩阵指数对半离散系统进行精确的时间积分，以分离空间离散误差。你可以数值实现 $\\mathbf{u}(T)=\\exp(T\\mathbf{A})\\,\\mathbf{u}(0)$。\n\n对于每种方法（GC 和 OS）以及每个网格尺寸 $N$，计算在时间 $T$ 的最大范数误差，\n$$\ne(N)=\\max_{0\\le i\\le N-1}\\big|u_{\\text{num}}(x_i,T)-u_{\\text{exact}}(x_i,T)\\big|.\n$$\n使用间距为 $h_1$ 和 $h_2$ 的两次连续加密，报告观察到的精度阶数\n$$\np=\\frac{\\log\\big(e(N_1)/e(N_2)\\big)}{\\log\\big(h_1/h_2\\big)}.\n$$\n\n测试组。使用 $L=1$ 和模式对 $(n_1,n_2)=(2,3)$。对于以下每种情况，使用网格尺寸 $\\{N\\}=\\{21,41,81,161\\}$，并从两个最精细的网格 $N=81$ 和 $N=161$ 计算 $p$ 时定义 $h(L,N)=L/(N-1)$：\n\n- 情况 A (理想路径)：$\\alpha=1$，$T=0.03$。\n- 情况 B (不同扩散系数)：$\\alpha=0.1$，$T=0.03$。\n- 情况 C (更长时间)：$\\alpha=1$，$T=0.2$。\n\n对于每种情况，产生三个输出：\n- 在 $N=81$ 和 $N=161$ 之间，虚单元反射法观察到的阶数 $p_{\\text{GC}}$，\n- 在 $N=81$ 和 $N=161$ 之间，单边边界闭合法观察到的阶数 $p_{\\text{OS}}$，\n- 一个布尔值，指示是否 $p_{\\text{OS}}1.5$ 且 $p_{\\text{GC}}1.5$。\n\n将报告的每个阶数四舍五入到三位小数。你的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3,...]”），结果按以下顺序排列：情况 A 的三元组，情况 B 的三元组，情况 C 的三元组。不应打印任何额外文本。",
            "solution": "该问题是有效的，因为它提出了一个适定的一维热方程初边值问题，并要求使用线方法 (MOL) 进行标准的数值分析研究。该问题具有科学依据、内容自洽且客观。\n\n问题的核心是构建和比较热方程的两种不同半离散化方案，\n$$\nu_t = \\alpha u_{xx},\n$$\n这些方案在一个由 $N$ 个点 $x_i = ih$（$i=0, 1, \\dots, N-1$）组成的均匀网格上进行，网格间距为 $h=L/(N-1)$。MOL 将偏微分方程 (PDE) 简化为一个耦合的常微分方程 (ODE) 系统，\n$$\n\\frac{d\\mathbf{u}}{dt} = \\mathbf{A} \\mathbf{u}(t),\n$$\n其中 $\\mathbf{u}(t) = [u_0(t), u_1(t), \\dots, u_{N-1}(t)]^T$ 是网格点上近似解值的向量，$\\mathbf{A}$ 是一个近似空间算子 $\\alpha \\frac{\\partial^2}{\\partial x^2}$ 的常数矩阵。\n\n对于内部网格点 $i=1, \\dots, N-2$，两种方法都使用标准的二阶中心差分来近似二阶导数：\n$$\nu_{xx}(x_i) \\approx \\frac{u(x_{i-1}) - 2u(x_i) + u(x_{i+1})}{h^2} = \\frac{u_{i-1} - 2u_i + u_{i+1}}{h^2}.\n$$\n这定义了离散化矩阵 $\\mathbf{A}$ 的第 $i=1, \\dots, N-2$ 行具有 $\\frac{\\alpha}{h^2}[\\dots, 1, -2, 1, \\dots]$ 的形式。这两种方法的不同之处在于它们如何构建 $\\mathbf{A}$ 的第一行 ($i=0$) 和最后一行 ($i=N-1$) 以包含齐次诺伊曼边界条件 $u_x(0,t)=0$ 和 $u_x(L,t)=0$。\n\n**1. 虚单元 (GC) 反射法**\n\n该方法通过在区域外引入一个虚构的“虚”点来施加诺伊曼条件。在左边界 $x_0=0$ 处，我们在 $x_{-1}=-h$ 处引入一个虚点。我们使用二阶中心差分来近似边界条件 $u_x(0,t)=0$：\n$$\n\\frac{u_1 - u_{-1}}{2h} = 0 \\implies u_{-1} = u_1.\n$$\n这个关系将第一个内部点的解值反射到虚点上。现在我们可以在边界点 $x_0$ 处使用标准的中心差分格式来计算 $u_{xx}$：\n$$\nu_{xx}(x_0) \\approx \\frac{u_{-1} - 2u_0 + u_1}{h^2} = \\frac{u_1 - 2u_0 + u_1}{h^2} = \\frac{2u_1 - 2u_0}{h^2}.\n$$\n根据对称性，在右边界 $x_{N-1}=L$ 处的近似为：\n$$\nu_{xx}(x_{N-1}) \\approx \\frac{2u_{N-2} - 2u_{N-1}}{h^2}.\n$$\n关键步骤是分析此边界近似的局部截断误差 (LTE)。对 $u(h)$ 在 $x=0$ 附近进行泰勒展开，并结合条件 $u_x(0)=0$：\n$$\nu(h) = u(0) + h u_x(0) + \\frac{h^2}{2}u_{xx}(0) + \\frac{h^3}{6}u_{xxx}(0) + O(h^4) = u(0) + \\frac{h^2}{2}u_{xx}(0) + \\frac{h^3}{6}u_{xxx}(0) + O(h^4).\n$$\n我们对 $u_{xx}(0)$ 的近似的 LTE 为：\n$$\n\\text{LTE}_{\\text{GC}} = \\frac{2(u(h)-u(0))}{h^2} - u_{xx}(0) = \\frac{2}{h^2}\\left(\\frac{h^2}{2}u_{xx}(0) + \\frac{h^3}{6}u_{xxx}(0) + O(h^4)\\right) - u_{xx}(0) = \\frac{h}{3}u_{xxx}(0) + O(h^2).\n$$\nLTE 是 $O(h)$ 阶的。边界上的这个一阶误差会污染整个解，导致该方法的全局误差为一阶，即 $p_{\\text{GC}} \\approx 1$。\n\n**2. 单边 (OS) 边界闭合法**\n\n该方法利用区域内的点（$u_0, u_1, u_2$）推导出 $u_{xx}(0)$ 的单边公式，该公式通过利用 $u_x(0)=0$ 条件被特别构造成二阶精度。我们对 $u_1=u(h)$ 和 $u_2=u(2h)$ 在 $x=0$ 附近使用泰勒级数，并设 $u_x(0)=0$：\n$$\nu_1 - u_0 = \\frac{h^2}{2} u_{xx}(0) + \\frac{h^3}{6} u_{xxx}(0) + \\frac{h^4}{24} u_{xxxx}(0) + O(h^5)\n$$\n$$\nu_2 - u_0 = \\frac{(2h)^2}{2} u_{xx}(0) + \\frac{(2h)^3}{6} u_{xxx}(0) + \\frac{(2h)^4}{24} u_{xxxx}(0) + O(h^5) = 2h^2 u_{xx}(0) + \\frac{4h^3}{3} u_{xxx}(0) + \\frac{2h^4}{3} u_{xxxx}(0) + O(h^5)\n$$\n我们寻求一个线性组合 $A(u_1-u_0) + B(u_2-u_0)$ 来消去 $u_{xxx}(0)$ 项。$h^3 u_{xxx}(0)$ 的系数是 $(\\frac{A}{6} + \\frac{4B}{3})$。令其为零得到 $A = -8B$。为了恢复 $u_{xx}(0)$，我们需要 $h^2 u_{xx}(0)$ 的系数 $(\\frac{A}{2} + 2B)$ 为 1。代入 $A=-8B$ 得到 $-4B+2B=1 \\implies B=-1/2$，因此 $A=4$。所以，$4(u_1-u_0) - \\frac{1}{2}(u_2-u_0) = h^2 u_{xx}(0) + O(h^4)$。两边乘以 2 得到 $8(u_1-u_0) - (u_2-u_0) = 2h^2 u_{xx}(0) + O(h^4)$。这提供了以下近似：\n$$\nu_{xx}(0) \\approx \\frac{8u_1 - u_2 - 7u_0}{2h^2}.\n$$\n此近似的 LTE 是：\n$$\n\\text{LTE}_{\\text{OS}} = \\frac{-7u_0 + 8u_1 - u_2}{2h^2} - u_{xx}(0),\n$$\n根据我们的推导，它是 $O(h^2)$ 阶的。由于内部和边界的近似都是二阶的，该方法的全局误差预计为二阶，即 $p_{\\text{OS}} \\approx 2$。在右边界对应的公式是 $u_{xx}(x_{N-1}) \\approx \\frac{-7u_{N-1} + 8u_{N-2} - u_{N-3}}{2h^2}$。\n\n**数值步骤**\n\n这两种方法产生了两个不同的系统矩阵，$\\mathbf{A}_{\\text{GC}}$ 和 $\\mathbf{A}_{\\text{OS}}$。通过使用矩阵指数 $\\mathbf{u}(T) = \\exp(T\\mathbf{A})\\mathbf{u}(0)$，将 ODE 系统从 $t=0$ 精确积分到 $t=T$，其中 $\\mathbf{u}(0)$ 是初始条件向量。这样可以分离出空间离散误差。然后，通过将数值解与时间 $T$ 处的给定精确解进行比较，计算出最大范数误差 $e(N)$。观察到的精度阶数 $p$ 是使用来自两个网格加密（$N_1=81$ 和 $N_2=161$）的误差计算得出的：\n$$\np=\\frac{\\log\\big(e(N_1)/e(N_2)\\big)}{\\log\\big(h_1/h_2\\big)},\n$$\n其中 $h_1=L/(N_1-1)$ 且 $h_2=L/(N_2-1)$。由于 $h_1/h_2 = 160/80=2$，这可以简化为 $p = \\log_2(e_{81}/e_{161})$。\n我们的分析预测 $p_{\\text{GC}} \\approx 1$ 且 $p_{\\text{OS}} \\approx 2$。因此，对于所有测试用例，条件 $p_{\\text{OS}} > 1.5$ 且 $p_{\\text{GC}}  1.5$ 预计都将成立。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef build_matrix(N, L, alpha, method):\n    \"\"\"Constructs the spatial discretization matrix A for du/dt = A*u.\"\"\"\n    h = L / (N - 1)\n    A = np.zeros((N, N))\n    \n    # Interior points (common to both methods)\n    # u_xx approx is (u_i-1 - 2u_i + u_i+1) / h^2\n    for i in range(1, N - 1):\n        A[i, i - 1] = 1.0\n        A[i, i]     = -2.0\n        A[i, i + 1] = 1.0\n        \n    if method == \"GC\":\n        # Ghost-cell reflection: u_{-1}=u_1 and u_{N}=u_{N-2}\n        # u_xx(0) approx is (2u_1 - 2u_0) / h^2\n        A[0, 0] = -2.0\n        A[0, 1] = 2.0\n        # u_xx(L) approx is (2u_{N-2} - 2u_{N-1}) / h^2\n        A[N - 1, N - 2] = 2.0\n        A[N - 1, N - 1] = -2.0\n        A *= alpha / h**2\n        \n    elif method == \"OS\":\n        # One-sided 2nd-order closure\n        # u_xx(0) approx is (-7u_0 + 8u_1 - u_2) / (2h^2)\n        A[0, 0] = -7.0\n        A[0, 1] = 8.0\n        A[0, 2] = -1.0\n        # u_xx(L) approx is (-u_{N-3} + 8u_{N-2} - 7u_{N-1}) / (2h^2)\n        A[N - 1, N - 3] = -1.0\n        A[N - 1, N - 2] = 8.0\n        A[N - 1, N - 1] = -7.0\n        A[0,:] /= 2.0\n        A[N-1,:] /= 2.0\n        A *= alpha / h**2\n        \n    else:\n        raise ValueError(\"Unknown method specified\")\n        \n    return A\n\ndef get_exact_solution(x, t, alpha, n1, n2, L):\n    \"\"\"Computes the exact solution at given points x and time t.\"\"\"\n    term1 = np.exp(-alpha * (n1 * np.pi / L)**2 * t) * np.cos(n1 * np.pi * x / L)\n    term2 = 0.5 * np.exp(-alpha * (n2 * np.pi / L)**2 * t) * np.cos(n2 * np.pi * x / L)\n    return term1 + term2\n\ndef run_case(alpha, T, n1, n2, L, N_vals):\n    \"\"\"Runs a single test case for both GC and OS methods.\"\"\"\n    errors_gc = {}\n    errors_os = {}\n\n    for N in N_vals:\n        h = L / (N - 1)\n        x = np.linspace(0, L, N)\n        \n        # Initial condition\n        u0 = get_exact_solution(x, 0, alpha, n1, n2, L)\n        \n        # Exact solution at time T\n        u_exact_T = get_exact_solution(x, T, alpha, n1, n2, L)\n        \n        # --- Ghost-Cell Method ---\n        A_gc = build_matrix(N, L, alpha, \"GC\")\n        u_num_gc = expm(T * A_gc) @ u0\n        errors_gc[N] = np.max(np.abs(u_num_gc - u_exact_T))\n        \n        # --- One-Sided Method ---\n        A_os = build_matrix(N, L, alpha, \"OS\")\n        u_num_os = expm(T * A_os) @ u0\n        errors_os[N] = np.max(np.abs(u_num_os - u_exact_T))\n\n    # Compute order of accuracy using the two finest grids\n    N1, N2 = sorted(N_vals)[-2:]\n    h1 = L / (N1 - 1)\n    h2 = L / (N2 - 1)\n    \n    p_gc = np.log(errors_gc[N1] / errors_gc[N2]) / np.log(h1 / h2)\n    p_os = np.log(errors_os[N1] / errors_os[N2]) / np.log(h1 / h2)\n    \n    # Check the boolean condition\n    bool_check = (p_os > 1.5) and (p_gc  1.5)\n    \n    return round(p_gc, 3), round(p_os, 3), bool_check\n\ndef solve():\n    # Problem definition\n    L = 1.0\n    n1, n2 = 2, 3\n    N_vals = [21, 41, 81, 161]\n    \n    test_cases = [\n        {'alpha': 1.0, 'T': 0.03},  # Case A\n        {'alpha': 0.1, 'T': 0.03},  # Case B\n        {'alpha': 1.0, 'T': 0.2},   # Case C\n    ]\n\n    results = []\n    for case in test_cases:\n        p_gc, p_os, bool_check = run_case(case['alpha'], case['T'], n1, n2, L, N_vals)\n        results.extend([p_gc, p_os, bool_check])\n\n    # Format output as a single comma-separated string in brackets\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "现实世界中的许多物理和化学过程都表现出“刚性” (stiffness)，即系统中存在多个差异巨大的时间尺度，例如，化学反应的速率远快于物质扩散的速率。对于这类刚性问题，标准的显式时间积分方法会因稳定性限制而需要极小的时间步长，导致计算成本过高。本练习将引导您解决一个典型的刚性反应-扩散问题，通过比较两种先进的时间积分策略——需要牛顿法求解的全隐式方法与区别对待不同项的隐-显 (IMEX) 方法，您将获得设计高效求解器的宝贵实践经验。",
            "id": "3159311",
            "problem": "要求您为一类因其非线性反应项而表现出刚性的反应扩散偏微分方程 (PDE) 设计、实现并基准测试一种直线法 (MOL) 方法。MOL 框架通过空间离散化将 PDE 的空间导数转换为代数算子，从而留下一个关于时间的常微分方程组 (ODEs) 待数值积分求解。您的数值实验将比较两种时间积分策略：一种是隐式-显式 (IMEX) 格式，它隐式处理扩散项、显式处理刚性反应项；另一种是全隐式格式，它对两项都进行隐式处理，并使用牛顿法求解由此产生的非线性方程组。\n\n从以下一维空间中的适定 PDE 问题开始：\n$$\nu_t = D u_{xx} + f(u), \\quad x \\in [0,1], \\quad t \\in [0,T],\n$$\n边界条件为齐次狄利克雷边界条件\n$$\nu(0,t) = 0, \\quad u(1,t) = 0,\n$$\n以及光滑的初始条件\n$$\nu(x,0) = \\sin(\\pi x).\n$$\n非线性反应项为\n$$\nf(u) = \\lambda(u - u^3),\n$$\n其中 $D$ 和 $\\lambda$ 是正常数。当 $ \\lambda $ 很大时，源项 $ f(u) $ 会导致刚性。\n\n通过在 $[0,1]$ 上设置 $N$ 个间距为 $ h = 1/(N-1) $ 的等距网格点来构建 MOL 离散化，对 $N-2$ 个内部点上的 $u_{xx}$ 应用标准二阶中心差分近似，并在边界上强制执行 $ u(0,t) = u(1,t) = 0 $。将内部未知向量记为 $ y(t) \\in \\mathbb{R}^{N-2} $。空间离散化产生一个线性算子 $ A \\in \\mathbb{R}^{(N-2)\\times(N-2)} $，它代表具有三对角模板 $ (1,-2,1)/h^2 $ 的 $ D u_{xx} $，因此半离散 ODE 系统为\n$$\n\\dot{y}(t) = A y(t) + f(y(t)),\n$$\n其中 $ f $ 逐分量作用，即 $ f(y)_i = \\lambda \\big(y_i - y_i^3\\big) $。\n\n实现两种时间积分格式，以从 $ t=0 $ 步进到 $ t=T $：\n\n- 隐式-显式 (IMEX) 格式：对扩散项使用后向欧拉，对反应项使用前向欧拉。设时间步长为 $ \\Delta t $，对于步 $ n \\rightarrow n+1 $：\n$$\n\\big(I - \\Delta t \\, A\\big) y^{n+1} = y^{n} + \\Delta t \\, f(y^{n}),\n$$\n其中 $ I $ 是单位矩阵。\n\n- 全隐式格式：对两项均使用后向欧拉。对于步 $ n \\rightarrow n+1 $：\n$$\ny^{n+1} - \\Delta t \\, A y^{n+1} - \\Delta t \\, f(y^{n+1}) = y^{n}.\n$$\n使用牛顿法求解该非线性系统。令\n$$\nF(v) = v - \\Delta t \\, A v - \\Delta t \\, f(v) - y^{n}.\n$$\n牛顿迭代通过求解以下方程来更新 $ v $\n$$\n\\Big(I - \\Delta t \\, A - \\Delta t \\, \\operatorname{diag}\\big(f'(v)\\big)\\Big) \\, \\delta = -F(v), \\quad v \\leftarrow v + \\delta,\n$$\n直到残差的范数 $ \\|F(v)\\|_2 $ 低于选定的容差。这里 $ f'(u) = \\lambda(1 - 3 u^2) $。\n\n您的程序必须是这两种格式的完整、可运行的实现，使用上述的离散化和时间步进规则。它必须执行以下包含三个案例的测试套件，每个案例由参数 $ (N, D, \\lambda, T, \\Delta t_{\\mathrm{IMEX}}, \\Delta t_{\\mathrm{IMP}}) $ 指定：\n\n- 案例 $1$：$ N = 50 $, $ D = 0.01 $, $ \\lambda = 200 $, $ T = 0.02 $, $ \\Delta t_{\\mathrm{IMEX}} = 2\\times 10^{-5} $, $ \\Delta t_{\\mathrm{IMP}} = 2\\times 10^{-4} $。\n- 案例 $２$：$ N = 70 $, $ D = 0.005 $, $ \\lambda = 700 $, $ T = 0.01 $, $ \\Delta t_{\\mathrm{IMEX}} = 1\\times 10^{-5} $, $ \\Delta t_{\\mathrm{IMP}} = 2\\times 10^{-4} $。\n- 案例 $３$：$ N = 30 $, $ D = 0.02 $, $ \\lambda = 100 $, $ T = 0.05 $, $ \\Delta t_{\\mathrm{IMEX}} = 1\\times 10^{-4} $, $ \\Delta t_{\\mathrm{IMP}} = 1\\times 10^{-3} $。\n\n对于每个案例，计算以下三个指标：\n\n- $m_1$：IMEX 解与全隐式解在最终时刻 $ T $ 的差的离散 $L^2$ 范数，即：\n$$\nm_1 = \\big\\| y_{\\mathrm{IMEX}}(T) - y_{\\mathrm{IMP}}(T) \\big\\|_2.\n$$\n- $m_2$：IMEX 与全隐式方法所采取的时间步数之比，\n$$\nm_2 = \\frac{N_{\\mathrm{steps,IMEX}}}{N_{\\mathrm{steps,IMP}}}.\n$$\n- $m_3$：全隐式求解器在整个积分过程中为达到 $ T $ 所使用的牛顿迭代总次数。\n\n您的程序应产生单行输出，其中包含一个方括号内的逗号分隔列表形式的结果。该列表必须按顺序包含九个浮点数结果 $[m_1^{(1)}, m_2^{(1)}, m_3^{(1)}, m_1^{(2)}, m_2^{(2)}, m_3^{(2)}, m_1^{(3)}, m_2^{(3)}, m_3^{(3)}]$，其中上标对应案例编号。每个浮点数必须四舍五入到六位小数。此问题不涉及物理单位，因此不要在输出中附加任何单位。",
            "solution": "该问题要求设计并实现两种基于直线法 (MOL) 的数值格式，用于求解一个刚性一维反应扩散偏微分方程 (PDE)。我们将比较一个隐式-显式 (IMEX) 格式和一个全隐式格式。\n\n控制 PDE 由下式给出：\n$$\nu_t = D u_{xx} + f(u), \\quad x \\in [0,1], \\quad t \\in [0,T]\n$$\n齐次狄利克雷边界条件为 $u(0,t) = u(1,t) = 0$，初始条件为 $u(x,0) = \\sin(\\pi x)$。非线性反应项为 $f(u) = \\lambda(u - u^3)$，它在 $\\lambda  0$ 较大时会引起刚性。\n\n直线法的第一步是空间域离散化。我们定义一个包含 $N$ 个点 $x_j = j \\cdot h$（$j=0, 1, \\dots, N-1$）的均匀网格，其中网格间距为 $h = 1/(N-1)$。内部网格点 $x_1, \\dots, x_{N-2}$ 处的解由一个随时间变化的向量 $y(t) \\in \\mathbb{R}^{N-2}$ 表示，其中 $y_i(t) \\approx u(x_{i+1}, t)$。边界条件意味着 $u(x_0,t) = 0$ 和 $u(x_{N-1},t) = 0$。\n\n在内部点 $x_j$ 处的二阶空间导数 $u_{xx}$ 使用二阶中心差分公式近似：\n$$\nu_{xx}(x_j, t) \\approx \\frac{u(x_{j-1}, t) - 2u(x_j, t) + u(x_{j+1}, t)}{h^2}\n$$\n将此公式应用于所有 $N-2$ 个内部点并结合边界条件，会得到一个常微分方程组 (ODEs)。扩散项 $D u_{xx}$ 的离散化形成一个由矩阵 $A \\in \\mathbb{R}^{(N-2)\\times(N-2)}$ 表示的线性算子。矩阵 $A$ 是三对角的，其对角线元素等于 $-2D/h^2$，次对角线和超对角线元素等于 $D/h^2$。\n\n半离散 ODE 系统为：\n$$\n\\frac{d y}{d t} = \\dot{y}(t) = A y(t) + f(y(t))\n$$\n其中函数 $f$ 逐元素地应用于向量 $y(t)$，即 $[f(y(t))]_i = \\lambda(y_i(t) - y_i(t)^3)$。该 ODE 系统的初始条件是 $y(0)_i = \\sin(\\pi x_{i+1})$，对于 $i=0, \\dots, N-3$。等等，索引有点棘手。让我们使用 $i=1..N-2$。对于 $i=1..N-2$，$y_i(t) \\approx u(x_i, t)$。那么 $y(0)_i = \\sin(\\pi x_i)$。在代码中，向量索引将是 $0..N-3$。对于大小为 $N-2$ 的向量 $y$，我们坚持使用从 $0$ 到 $N-3$ 的 Python 索引。所以 $y_i(t) \\approx u(x_{i+1}, t)$。那么 $y_i(0) = \\sin(\\pi x_{i+1})$。\n\n接下来，我们在时间上进行离散化。我们将实现并比较两种一阶格式。设 $y^n$ 为时间 $t_n = n \\Delta t$ 处的数值解。\n\n**格式 1：隐式-显式 (IMEX) 欧拉法**\n该格式隐式地（使用后向欧拉）处理刚性线性扩散项，显式地（使用前向欧拉）处理非线性反应项。通常选择这种组合来处理扩散项带来的刚性，而无需在每一步求解非线性系统。从 $y^n$ 到 $y^{n+1}$ 的更新是：\n$$\n\\frac{y^{n+1} - y^n}{\\Delta t} = A y^{n+1} + f(y^n)\n$$\n重新整理以求解 $y^{n+1}$，我们得到一个线性系统：\n$$\n(I - \\Delta t A) y^{n+1} = y^n + \\Delta t f(y^n)\n$$\n其中 $I$ 是单位矩阵。左侧的矩阵 $M_{\\mathrm{IMEX}} = (I - \\Delta t A)$ 在整个积分过程中是常数。为提高效率，我们可以在时间步进循环开始前一次性计算其 LU 分解，然后在每一步中使用前向/后向替换来求解 $y^{n+1}$。\n\n**格式 2：全隐式欧拉法**\n该格式隐式地处理扩散项和反应项：\n$$\n\\frac{y^{n+1} - y^n}{\\Delta t} = A y^{n+1} + f(y^{n+1})\n$$\n这是一个关于 $y^{n+1}$ 的非线性代数方程组。我们定义一个残差函数 $F(v)$，其中 $v$ 是 $y^{n+1}$ 的一个候选解：\n$$\nF(v) = v - \\Delta t A v - \\Delta t f(v) - y^n = 0\n$$\n我们使用牛顿法求解该系统。从一个初始猜测（例如，$v_0 = y^n$）开始，我们迭代地改进解。第 $k$ 次牛顿迭代是：\n$$\nJ_F(v_k) \\delta_k = -F(v_k), \\quad v_{k+1} = v_k + \\delta_k\n$$\n其中 $J_F(v)$ 是 $F(v)$ 的雅可比矩阵：\n$$\nJ_F(v) = \\frac{\\partial F}{\\partial v} = I - \\Delta t A - \\Delta t \\frac{\\partial f(v)}{\\partial v}\n$$\n逐分量函数 $f(v)$ 的导数是一个对角矩阵：$\\frac{\\partial f(v)}{\\partial v} = \\operatorname{diag}(f'(v_i))$，其中 $f'(u) = \\lambda(1 - 3u^2)$。\n雅可比矩阵 $J_F(v)$ 是一个三对角矩阵，因为它是一个三对角矩阵 $(I - \\Delta t A)$ 和一个对角矩阵的和。这种结构使得在每次牛顿迭代中，求解 $\\delta_k$ 的线性系统可以非常高效地完成，例如，使用带状矩阵求解器。迭代持续进行，直到残差的 L2-范数 $\\|F(v)\\|_2$ 小于指定的容差。\n\n最后，对于每个测试案例，我们计算指定的指标：\n- $m_1 = \\| y_{\\mathrm{IMEX}}(T) - y_{\\mathrm{IMP}}(T) \\|_2$：最终解之间差值的离散 L2 范数。\n- $m_2 = N_{\\mathrm{steps,IMEX}} / N_{\\mathrm{steps,IMP}} = (T/\\Delta t_{\\mathrm{IMEX}}) / (T/\\Delta t_{\\mathrm{IMP}}) = \\Delta t_{\\mathrm{IMP}} / \\Delta t_{\\mathrm{IMEX}}$：时间步数的比率。\n- $m_3$：全隐式求解器在所有时间步中为达到 $T$ 所执行的牛顿迭代总次数。\n\n实现将精确遵循这些数学和算法公式。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import lu_factor, lu_solve, solve_banded\n\n# from scipy import ...\n\ndef create_diffusion_matrix(N, D):\n    \"\"\"Constructs the diffusion matrix A for the interior grid points.\"\"\"\n    num_interior = N - 2\n    h = 1.0 / (N - 1)\n    \n    diag_val = -2.0 * D / h**2\n    offdiag_val = D / h**2\n    \n    A_diag = diag_val * np.ones(num_interior)\n    A_offdiag = offdiag_val * np.ones(num_interior - 1)\n    \n    # Using np.diag to build the sparse matrix as a dense numpy array\n    A = np.diag(A_diag) + np.diag(A_offdiag, k=1) + np.diag(A_offdiag, k=-1)\n    return A\n\ndef run_imex(N, D, lam, T, dt):\n    \"\"\"\n    Solves the reaction-diffusion PDE using the IMEX scheme.\n    (Implicit Euler for diffusion, Explicit Euler for reaction)\n    \"\"\"\n    num_interior = N - 2\n    \n    # Grid and initial condition for interior points\n    x = np.linspace(0, 1, N)\n    y = np.sin(np.pi * x[1:-1])\n    \n    # Diffusion matrix A\n    A = create_diffusion_matrix(N, D)\n    \n    # IMEX system matrix (I - dt*A)\n    I = np.identity(num_interior)\n    LHS = I - dt * A\n    \n    # Pre-compute LU factorization for efficiency\n    lu, piv = lu_factor(LHS)\n    \n    # Reaction function\n    def f(u):\n        return lam * (u - u**3)\n        \n    num_steps = int(round(T / dt))\n    \n    for _ in range(num_steps):\n        RHS = y + dt * f(y)\n        y = lu_solve((lu, piv), RHS)\n        \n    return y\n\ndef run_implicit(N, D, lam, T, dt):\n    \"\"\"\n    Solves the reaction-diffusion PDE using the fully implicit Euler scheme\n    with Newton's method for the nonlinear system.\n    \"\"\"\n    num_interior = N - 2\n    h = 1.0 / (N - 1)\n    \n    # Grid and initial condition for interior points\n    x = np.linspace(0, 1, N)\n    y_n = np.sin(np.pi * x[1:-1])  # Solution at step n\n    \n    # Diffusion matrix A components\n    A_diag_vals = -2.0 * D / h**2 * np.ones(num_interior)\n    A_offdiag_vals = D / h**2 * np.ones(num_interior - 1)\n    A = np.diag(A_diag_vals) + np.diag(A_offdiag_vals, k=1) + np.diag(A_offdiag_vals, k=-1)\n\n    # Reaction function and its derivative\n    def f(u):\n        return lam * (u - u**3)\n    def f_prime(u):\n        return lam * (1 - 3 * u**2)\n        \n    num_steps = int(round(T / dt))\n    total_newton_iters = 0\n    newton_tol = 1e-10\n    max_newton_iters = 20\n\n    for _ in range(num_steps):\n        v = y_n.copy()  # Initial guess for y^{n+1}\n        \n        for k in range(max_newton_iters):\n            total_newton_iters += 1\n            \n            # Calculate residual F(v) = v - dt*(A@v + f(v)) - y_n\n            F_v = v - dt * (A @ v + f(v)) - y_n\n            \n            if np.linalg.norm(F_v)  newton_tol:\n                break\n            \n            # Calculate Jacobian J(v) = I - dt*A - dt*diag(f'(v))\n            # J is tridiagonal, so we construct it in banded form for solve_banded\n            J_diag = 1.0 - dt * A_diag_vals - dt * f_prime(v)\n            J_offdiag = -dt * A_offdiag_vals\n            \n            J_banded = np.zeros((3, num_interior))\n            J_banded[0, 1:] = J_offdiag\n            J_banded[1, :] = J_diag\n            J_banded[2, :-1] = J_offdiag\n            \n            # Solve the linear system J * delta = -F(v)\n            delta = solve_banded((1, 1), J_banded, -F_v)\n            v += delta\n        \n        y_n = v  # Update solution for next time step\n   \n    return y_n, total_newton_iters\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and compute metrics.\n    \"\"\"\n    test_cases = [\n        # (N, D, lambda, T, dt_imex, dt_imp)\n        (50, 0.01, 200, 0.02, 2e-5, 2e-4),\n        (70, 0.005, 700, 0.01, 1e-5, 2e-4),\n        (30, 0.02, 100, 0.05, 1e-4, 1e-3),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, D, lam, T, dt_imex, dt_imp = case\n        \n        # Run IMEX solver\n        y_imex_final = run_imex(N, D, lam, T, dt_imex)\n        \n        # Run Fully Implicit solver\n        y_imp_final, total_newton_iters = run_implicit(N, D, lam, T, dt_imp)\n        \n        # Metric 1: L2 norm of the difference\n        m1 = np.linalg.norm(y_imex_final - y_imp_final)\n        \n        # Metric 2: Ratio of time steps\n        m2 = dt_imp / dt_imex\n        \n        # Metric 3: Total Newton iterations\n        m3 = float(total_newton_iters)\n        \n        results.extend([m1, m2, m3])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\nsolve()\n```"
        }
    ]
}