{
    "hands_on_practices": [
        {
            "introduction": "Before running any complex simulation, it is essential to ensure that the chosen numerical parameters will lead to a stable result. For explicit methods like the one used for the wave equation, the Courant-Friedrichs-Lewy (CFL) condition provides a fundamental \"speed limit\" that relates the physical wave speed $c$ to the grid spacing $\\Delta x$ and time step $\\Delta t$. This exercise  focuses on applying this crucial stability criterion to determine the largest possible time step for a given simulation setup, a foundational skill for any computational scientist.",
            "id": "2172272",
            "problem": "A computational physicist is simulating the propagation of a sound wave in a one-dimensional tube, which is modeled by the wave equation $\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}$. The speed of sound in the medium is $c = 320$ m/s. The simulation employs an explicit finite difference scheme on a spatial grid with a step size of $\\Delta x = 0.8$ m. For this numerical method to be stable, the chosen time step $\\Delta t$ must adhere to the Courant-Friedrichs-Lewy (CFL) stability condition, which is given by the relation $c \\frac{\\Delta t}{\\Delta x} \\le 1$. Determine the maximum possible value for the time step $\\Delta t$ that will ensure the stability of the simulation. Express your answer in seconds.",
            "solution": "The Courant-Friedrichs-Lewy (CFL) stability condition for the explicit finite difference scheme applied to the one-dimensional wave equation is given by\n$$\nc \\frac{\\Delta t}{\\Delta x} \\le 1.\n$$\nTo ensure stability with the largest possible time step, set the inequality to equality:\n$$\nc \\frac{\\Delta t_{\\max}}{\\Delta x} = 1 \\quad \\Rightarrow \\quad \\Delta t_{\\max} = \\frac{\\Delta x}{c}.\n$$\nSubstitute the given values $\\Delta x = 0.8$ and $c = 320$:\n$$\n\\Delta t_{\\max} = \\frac{0.8}{320}.\n$$\nSimplify the fraction:\n$$\n\\frac{0.8}{320} = \\frac{8}{3200} = \\frac{1}{400} = 0.0025.\n$$\nThus, the maximum stable time step in seconds is $0.0025$.",
            "answer": "$$\\boxed{0.0025}$$"
        },
        {
            "introduction": "The standard finite difference stencil describes how to update points in the interior of a domain, but real-world physical systems have boundaries. These boundaries, such as the fixed ends of a guitar string, require special treatment in the numerical scheme. This practice  demonstrates how to adapt the general update equation to account for a fixed (Dirichlet) boundary condition, a common and essential task in setting up accurate simulations.",
            "id": "2172248",
            "problem": "Consider the one-dimensional wave equation, a Partial Differential Equation (PDE), which models phenomena like the vibration of a string:\n$$ \\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2} $$\nwhere $u(x,t)$ is the displacement at position $x$ and time $t$, and $c$ is the constant wave speed.\n\nTo solve this equation numerically, we can use a finite difference method. We discretize the domain on a grid with spatial step size $\\Delta x$ and time step size $\\Delta t$. Let $u_i^j$ denote the numerical approximation of $u(i\\Delta x, j\\Delta t)$. By substituting second-order central difference approximations for the derivatives, we arrive at the standard explicit update scheme for an interior grid point $(i, j)$:\n$$ u_i^{j+1} = 2(1-r^2)u_i^j + r^2(u_{i+1}^j + u_{i-1}^j) - u_i^{j-1} $$\nThis equation allows us to compute the displacement at the next time step, $j+1$, using values from the current and previous time steps, $j$ and $j-1$. The parameter $r = \\frac{c \\Delta t}{\\Delta x}$ is known as the Courant number.\n\nNow, consider a string defined over the spatial domain $x \\in [0, L]$. The grid points are indexed by $i=0, 1, 2, \\dots, N$, where $x_i = i\\Delta x$ and $x_N=L$. The end of the string at $x=0$ is held fixed, which imposes the boundary condition $u(0, t) = 0$ for all time $t$. In our discrete notation, this translates to $u_0^j = 0$ for all time indices $j \\ge 0$.\n\nYour task is to derive the specific update equation for the grid point at $i=1$, which is adjacent to this fixed boundary. Express the new displacement $u_1^{j+1}$ as a function of displacements at time steps $j$ and $j-1$.",
            "solution": "We start from the given explicit finite difference update scheme for the interior points of the one-dimensional wave equation:\n$$\nu_{i}^{j+1}=2(1-r^{2})u_{i}^{j}+r^{2}\\left(u_{i+1}^{j}+u_{i-1}^{j}\\right)-u_{i}^{j-1},\n$$\nwhere the Courant number is $r=\\frac{c\\Delta t}{\\Delta x}$ and $u_{i}^{j}$ approximates $u(i\\Delta x,j\\Delta t)$.\n\nTo obtain the update at the point adjacent to the fixed boundary, set $i=1$:\n$$\nu_{1}^{j+1}=2(1-r^{2})u_{1}^{j}+r^{2}\\left(u_{2}^{j}+u_{0}^{j}\\right)-u_{1}^{j-1}.\n$$\n\nThe boundary condition at the fixed end is $u(0,t)=0$ for all $t$, which in discrete form is $u_{0}^{j}=0$ for all $j\\ge 0$. Substituting $u_{0}^{j}=0$ into the equation yields\n$$\nu_{1}^{j+1}=2(1-r^{2})u_{1}^{j}+r^{2}u_{2}^{j}-u_{1}^{j-1}.\n$$\n\nThis expresses the new displacement $u_{1}^{j+1}$ in terms of values at time steps $j$ and $j-1$, using the known boundary value at $i=0$.",
            "answer": "$$\\boxed{u_{1}^{j+1}=2(1-r^{2})u_{1}^{j}+r^{2}u_{2}^{j}-u_{1}^{j-1}}$$"
        },
        {
            "introduction": "The ultimate test of understanding is translating theory into a working simulation. This comprehensive exercise  guides you through building a one-dimensional wave equation solver from first principles, including the proper initialization and time-stepping loop. By implementing a simulation and testing parameters that both satisfy and violate the CFL condition explored in , you will gain a powerful, intuitive grasp of what numerical stability means and witness its effects firsthand.",
            "id": "3129202",
            "problem": "Consider the one-dimensional wave equation for the displacement $u(x,t)$ of a taut string on the interval $[0,L]$ with fixed ends, governed by the partial differential equation $$u_{tt}(x,t) = c^2 u_{xx}(x,t),$$ where $c$ is the wave speed. The string is held fixed at the ends, meaning the boundary conditions are $u(0,t) = 0$ and $u(L,t) = 0$ for all $t \\ge 0$. The initial displacement is prescribed as $$u(x,0) = \\sin\\left(\\frac{\\pi x}{L}\\right),$$ and the initial velocity is $$u_t(x,0) = 0.$$ All distances must be treated in meters, times in seconds, and the wave speed $c$ in meters per second. By convention, the sine function uses radians.\n\nYour task is to derive and implement a second-order accurate explicit finite difference method in both space and time for this equation using uniform grid spacings. Start from the fundamental base of Taylor expansion and the definition of central differences to approximate $u_{tt}$ and $u_{xx}$ on a uniform grid and derive the update rule needed to advance the solution from discrete time level $n$ to $n+1$. Do not assume any pre-existing scheme: construct the method directly from the definitions. Treat the two endpoints with the fixed boundary conditions for all time levels. For the very first time step, use a consistent second-order accurate formula based on the given initial position and initial velocity to obtain the solution at time level $n=1$.\n\nEmpirically assess stability using the Courant–Friedrichs–Lewy (CFL) condition by running the scheme for a selection of parameter values and observing whether the numerical solution remains bounded or blows up. Define an empirical blow-up detector as follows: let $M_0$ be the maximum absolute value of $u(x,0)$ over the spatial grid. During time stepping, compute $M_n$, the maximum absolute value over all spatial points at time level $n$. If at any time $M_n$ becomes undefined (not-a-number), infinite, or exceeds $10 M_0$, declare the simulation as unstable (blown up); otherwise, declare it stable. This detector must be implemented in your program.\n\nFor spatial discretization, use a uniform grid of $N_x$ points over $[0,L]$, with spacing $\\Delta x = L/(N_x - 1)$ meters. For temporal discretization, use a uniform time step $\\Delta t$ seconds and simulate up to a final time $T$ seconds. For each test case, compute the boolean stability outcome where $True$ means stable and $False$ means blown up.\n\nImplement your program to run the following test suite that covers a typical case, a boundary case near the CFL limit, and cases beyond the limit:\n- Test $1$: $c = 1.0$ meters per second, $L = 1.0$ meters, $N_x = 101$, $\\Delta t = 0.008$ seconds, $T = 0.5$ seconds.\n- Test $2$: $c = 1.0$ meters per second, $L = 1.0$ meters, $N_x = 101$, $\\Delta t = 0.010$ seconds, $T = 0.5$ seconds.\n- Test $3$: $c = 1.0$ meters per second, $L = 1.0$ meters, $N_x = 101$, $\\Delta t = 0.015$ seconds, $T = 1.0$ seconds.\n- Test $4$: $c = 2.0$ meters per second, $L = 1.0$ meters, $N_x = 101$, $\\Delta t = 0.010$ seconds, $T = 0.5$ seconds.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result_1,result_2,result_3,result_4]$), where each $result_k$ is the boolean stability outcome for Test $k$ computed by your empirical blow-up detector. No additional text should be printed. The output booleans have no physical units. The inputs and computations involving $c$, $L$, $\\Delta x$, $\\Delta t$, and $T$ must consistently use meters and seconds as specified.",
            "solution": "We begin from the fundamental definitions of central differences obtained via Taylor expansion. On a uniform spatial grid with spacing $\\Delta x$ and a uniform temporal grid with spacing $\\Delta t$, let $x_i = i \\Delta x$ for $i = 0,1,\\dots,N_x-1$ and $t^n = n \\Delta t$ for $n = 0,1,2,\\dots$. Let $u_i^n$ denote the numerical approximation to $u(x_i,t^n)$.\n\nThe second-order central difference approximation for the second temporal derivative at the point $(x_i,t^n)$ follows from the Taylor expansions\n$$u(x_i,t^{n\\pm 1}) = u(x_i,t^n) \\pm \\Delta t \\, u_t(x_i,t^n) + \\frac{\\Delta t^2}{2} u_{tt}(x_i,t^n) \\pm \\frac{\\Delta t^3}{6} u_{ttt}(x_i,t^n) + \\cdots,$$\nwhich yields\n$$u_{tt}(x_i,t^n) \\approx \\frac{u_i^{n+1} - 2 u_i^n + u_i^{n-1}}{\\Delta t^2}.$$\nSimilarly, for the second spatial derivative, using the Taylor expansions in space,\n$$u(x_{i\\pm 1},t^n) = u(x_i,t^n) \\pm \\Delta x \\, u_x(x_i,t^n) + \\frac{\\Delta x^2}{2} u_{xx}(x_i,t^n) \\pm \\frac{\\Delta x^3}{6} u_{xxx}(x_i,t^n) + \\cdots,$$\nwe obtain\n$$u_{xx}(x_i,t^n) \\approx \\frac{u_{i+1}^n - 2 u_i^n + u_{i-1}^n}{\\Delta x^2}.$$\n\nSubstituting these approximations into the wave equation $u_{tt} = c^2 u_{xx}$ at the interior points $i = 1,2,\\dots,N_x-2$ gives the discrete equation\n$$\\frac{u_i^{n+1} - 2 u_i^n + u_i^{n-1}}{\\Delta t^2} = c^2 \\frac{u_{i+1}^n - 2 u_i^n + u_{i-1}^n}{\\Delta x^2}.$$\nRearranging for the update from time level $n$ to $n+1$ yields the explicit scheme\n$$u_i^{n+1} = 2 u_i^n - u_i^{n-1} + r^2 \\left(u_{i+1}^n - 2 u_i^n + u_{i-1}^n\\right),$$\nwhere we define the dimensionless Courant number\n$$r = \\frac{c \\, \\Delta t}{\\Delta x}.$$\n\nThe boundary conditions are $u_0^n = 0$ and $u_{N_x-1}^n = 0$ for all $n$. The initial condition provides $u_i^0 = \\sin\\left(\\frac{\\pi x_i}{L}\\right)$ for all $i$, consistent with fixed ends since $\\sin(0) = 0$ and $\\sin(\\pi) = 0$. To initialize the scheme, we also need $u_i^1$. Using a second-order accurate Taylor expansion in time around $t=0$ and the given initial velocity $u_t(x,0) = 0$, we obtain\n$$u(x_i,\\Delta t) \\approx u(x_i,0) + \\Delta t \\, u_t(x_i,0) + \\frac{\\Delta t^2}{2} u_{tt}(x_i,0).$$\nReplacing $u_{tt}(x_i,0)$ by $c^2 u_{xx}(x_i,0)$ and applying the central spatial difference at time $n=0$ gives\n$$u_i^1 = u_i^0 + \\Delta t \\cdot 0 + \\frac{1}{2} r^2 \\left(u_{i+1}^0 - 2 u_i^0 + u_{i-1}^0\\right), \\quad \\text{for } i=1,\\dots,N_x-2,$$\nwith $u_0^1 = 0$ and $u_{N_x-1}^1 = 0$.\n\nThe Courant–Friedrichs–Lewy (CFL) condition arises from stability analysis (for example, via a von Neumann Fourier mode analysis). For the explicit second-order central difference scheme above, the amplification factor $G$ applied to a single Fourier mode satisfies a stability constraint that leads to the requirement\n$$r \\le 1.$$\nWhen $r \\le 1$, all Fourier modes have $|G| \\le 1$ and the method is stable; when $r > 1$, some modes have $|G| > 1$, which causes exponential growth and numerical blow-up.\n\nAlgorithmic design principles:\n- Define physical and numerical parameters $c$, $L$, $N_x$, $\\Delta t$, $T$ using meters and seconds.\n- Compute the grid spacing $\\Delta x = L/(N_x-1)$ and the Courant number $r = c \\Delta t / \\Delta x$.\n- Initialize $u_i^0 = \\sin(\\pi x_i / L)$ for $i=0,\\dots,N_x-1$ and $u_t(x,0) = 0$.\n- Compute $u^1$ using the second-order formula that incorporates $u_{tt}(x,0) = c^2 u_{xx}(x,0)$.\n- For $n \\ge 1$, advance $u^{n+1}$ using the explicit update at interior points and enforce boundary conditions at the endpoints.\n- At each time step, compute $M_n = \\max_i |u_i^n|$ and apply the empirical blow-up detector: if $M_n$ becomes not-a-number, infinite, or exceeds $10 M_0$ where $M_0 = \\max_i |u_i^0|$, declare instability; otherwise continue until the final time $T$.\n- Return a boolean indicating stability.\n\nTest suite rationale:\n- Test $1$ selects $r = 0.8$ ($c = 1.0$, $\\Delta t = 0.008$, $\\Delta x = 0.01$) as a typical stable case.\n- Test $2$ sets $r = 1.0$ as a boundary case which should remain stable for this scheme.\n- Test $3$ uses $r = 1.5$ and a longer final time to ensure that instability manifests empirically.\n- Test $4$ uses $r = 2.0$, which is well beyond the CFL limit, and blows up rapidly.\n\nExpected outcomes based on the CFL condition and empirical detection:\n- Test $1$: $True$ (stable).\n- Test $2$: $True$ (stable).\n- Test $3$: $False$ (blows up).\n- Test $4$: $False$ (blows up).\n\nThe final program aggregates these booleans and prints them as a single comma-separated list enclosed in square brackets, as required.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef simulate_wave_1d_stability(c, L, Nx, dt, T):\n    \"\"\"\n    Simulate the 1D wave equation u_tt = c^2 u_xx with fixed ends using\n    second-order central differences in space and time. Empirically detect\n    instability (blow-up) via amplitude growth and NaN/Inf checks.\n\n    Parameters:\n        c  (float): wave speed (m/s)\n        L  (float): domain length (m)\n        Nx (int):   number of spatial grid points\n        dt (float): time step (s)\n        T  (float): final time (s)\n\n    Returns:\n        bool: True if stable (no blow-up detected), False otherwise.\n    \"\"\"\n    # Spatial discretization\n    dx = L / (Nx - 1)\n    x = np.linspace(0.0, L, Nx)\n\n    # Courant number\n    r = c * dt / dx\n\n    # Initial displacement u(x,0) = sin(pi x / L), initial velocity = 0\n    u0 = np.sin(np.pi * x / L)\n    # Boundary conditions are fixed ends: u(0,t) = 0, u(L,t) = 0\n    u0[0] = 0.0\n    u0[-1] = 0.0\n\n    # Prepare arrays for time stepping\n    u_prev = u0.copy()\n\n    # Compute u^1 using second-order accurate initialization:\n    # u^1 = u^0 + dt * v^0 + (dt^2 / 2) * c^2 * u_xx^0\n    # with v^0 = 0 and u_xx^0 approximated by central differences\n    u_curr = u0.copy()\n    # interior update for the first step\n    # u_curr[i] = u_prev[i] + 0 + 0.5 * r^2 * (u_prev[i+1] - 2*u_prev[i] + u_prev[i-1])\n    for i in range(1, Nx - 1):\n        u_curr[i] = u_prev[i] + 0.5 * (r ** 2) * (u_prev[i + 1] - 2.0 * u_prev[i] + u_prev[i - 1])\n    # Enforce boundary conditions\n    u_curr[0] = 0.0\n    u_curr[-1] = 0.0\n\n    # Empirical blow-up detector thresholds\n    M0 = np.max(np.abs(u0))\n    if not np.isfinite(M0):\n        return False  # pathological, treat as blow-up\n    threshold = 10.0 * (M0 if M0  0 else 1.0)  # avoid zero threshold\n\n    # Number of time steps\n    n_steps = int(np.floor(T / dt))\n\n    # Time stepping\n    for _ in range(1, n_steps):\n        u_next = u_curr.copy()\n        # Explicit update for interior points:\n        # u_next[i] = 2*u_curr[i] - u_prev[i] + r^2 * (u_curr[i+1] - 2*u_curr[i] + u_curr[i-1])\n        for i in range(1, Nx - 1):\n            u_next[i] = (\n                2.0 * u_curr[i]\n                - u_prev[i]\n                + (r ** 2) * (u_curr[i + 1] - 2.0 * u_curr[i] + u_curr[i - 1])\n            )\n        # Enforce boundary conditions\n        u_next[0] = 0.0\n        u_next[-1] = 0.0\n\n        # Check for blow-up\n        M_n = np.max(np.abs(u_next))\n        if not np.isfinite(M_n) or M_n  threshold:\n            return False\n\n        # Rotate time levels\n        u_prev, u_curr = u_curr, u_next\n\n    # If reached final time without blow-up, declare stable\n    return True\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case is a tuple: (c, L, Nx, dt, T)\n    test_cases = [\n        (1.0, 1.0, 101, 0.008, 0.5),  # r = 0.8, expected stable\n        (1.0, 1.0, 101, 0.010, 0.5),  # r = 1.0, expected stable\n        (1.0, 1.0, 101, 0.015, 1.0),  # r = 1.5, expected unstable\n        (2.0, 1.0, 101, 0.010, 0.5),  # r = 2.0, expected unstable\n    ]\n\n    results = []\n    for c, L, Nx, dt, T in test_cases:\n        result = simulate_wave_1d_stability(c, L, Nx, dt, T)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}