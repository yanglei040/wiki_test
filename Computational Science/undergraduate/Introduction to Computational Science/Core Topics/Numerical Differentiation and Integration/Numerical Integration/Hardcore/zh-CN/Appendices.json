{
    "hands_on_practices": [
        {
            "introduction": "数值积分在物理学和工程学中至关重要，常用于计算力在路径上所做的功。本练习将引导你应用两种基本复合求积法则——梯形法则和辛普森法则——来计算非线性弹簧所做的功 ()。通过将数值结果与精确解进行比较，你将亲身体验到高阶方法在处理平滑函数时所展现的卓越精度。",
            "id": "3214920",
            "problem": "您需要设计并实现一个程序，用于计算一个具有非线性刚度的质点-弹簧系统沿一维位移从位置 $x=a$ 移动到位置 $x=b$ 所需的机械功 $W$。力定律为 $F(x)=kx+\\alpha x^{3}$，其中 $k$ 和 $\\alpha$ 是实数常数。功由黎曼积分 $W=\\int_{a}^{b}F(x)\\,dx$ 定义。您的程序必须在具有 $n$ 个子区间的均匀分区上，使用两种复合数值积分方案来近似计算 $W$：复合梯形法则和复合辛普森法则，两者都需从标准观点推导，即在子区间上用低阶多项式逼近被积函数，并对它们在子区间上的精确积分求和。此外，通过直接对给定的 $F(x)$ 进行积分来计算精确功，并用它来量化每种数值方法的绝对误差。所有功值和误差都必须以焦耳 (J) 为单位，表示为浮点数。\n\n用于推导和算法设计的基础原理：功的积分定义 $W=\\int_{a}^{b}F(x)\\,dx$，多项式的性质，以及 Newton–Cotes 求积法的基本原理，该原理通过在每个子区间上对被积函数的插值多项式进行积分来近似一个积分。在您的推理中，不要假设或引用任何预先推导出的求积权重；而应将您的设计建立在多项式插值和有限区间上多项式精确积分的第一性原理之上。\n\n在均匀分区 $\\{x_{i}\\}_{i=0}^{n}$ 上实现这两种复合规则，其中 $x_{0}=a$, $x_{n}=b$, $x_{i}=a+ih$, 且 $h=(b-a)/n$。对于复合辛普森法则，$n$ 必须是偶数。对于下面的每个测试用例，计算：\n- 精确功 $W_{\\text{exact}}=\\int_{a}^{b}F(x)\\,dx$,\n- 复合梯形近似值 $W_{\\text{trap}}$,\n- 复合辛普森近似值 $W_{\\text{simp}}$,\n- 绝对梯形误差 $e_{\\text{trap}}=\\lvert W_{\\text{trap}}-W_{\\text{exact}}\\rvert$,\n- 绝对辛普森误差 $e_{\\text{simp}}=\\lvert W_{\\text{simp}}-W_{\\text{exact}}\\rvert$.\n\n本问题不涉及角度单位。所有长度 $x$ 的单位是米 (m)，$k$ 的单位是牛顿每米 (N/m)，$\\alpha$ 的单位是牛顿每立方米 (N/m$^{3}$)，所有功值都必须以焦耳 (J) 为单位报告。\n\n使用以下测试套件，它涵盖了一般情况、线性边界情况、软化非线性情况和粗分区边缘情况：\n- 用例 $1$：$k=100$, $\\alpha=2000$, $a=0$, $b=0.2$, $n=20$。\n- 用例 $2$：$k=250$, $\\alpha=0$, $a=0$, $b=0.3$, $n=12$。\n- 用例 $3$：$k=50$, $\\alpha=-500$, $a=0.0$, $b=0.25$, $n=10$。\n- 用例 $4$：$k=120$, $\\alpha=8000$, $a=0.05$, $b=0.18$, $n=2$。\n\n您的程序必须生成单行输出，其中包含所有测试用例的聚合结果，格式为无空格的、逗号分隔的列表之列表。对于每个用例，内部列表必须按 $[W_{\\text{exact}},W_{\\text{trap}},W_{\\text{simp}},e_{\\text{trap}},e_{\\text{simp}}]$ 的顺序排列。因此，最终输出必须是 `[[case1],[case2],[case3],[case4]]` 形式的单行字符串，其中每个 `[casei]` 都是按指定顺序排列的、用方括号括起来的五元组。不要打印单位；数值应理解为以焦耳 (J) 为单位。",
            "solution": "用户想要解决一个关于数值积分的问题，具体是使用复合求积法则计算机械功。\n\n### 步骤 1：提取已知条件\n\n-   **物理系统**：具有非线性恢复力的质点-弹簧系统。\n-   **力定律**：$F(x)=kx+\\alpha x^{3}$，其中 $k$ 和 $\\alpha$ 是实数常数。\n-   **功的定义**：$W=\\int_{a}^{b}F(x)\\,dx$。\n-   **数值方法**：复合梯形法则和复合辛普森法则。\n-   **分区**：具有 $n$ 个子区间的均匀分区 $\\{x_{i}\\}_{i=0}^{n}$，其中 $x_{0}=a$, $x_{n}=b$, $x_{i}=a+ih$, 且 $h=(b-a)/n$。\n-   **约束**：对于复合辛普森法则，$n$ 必须是偶数。\n-   **任务**：对每个测试用例，计算：\n    1.  精确功，$W_{\\text{exact}}=\\int_{a}^{b}F(x)\\,dx$。\n    2.  复合梯形近似值，$W_{\\text{trap}}$。\n    3.  复合辛普森近似值，$W_{\\text{simp}}$。\n    4.  绝对梯形误差，$e_{\\text{trap}}=\\lvert W_{\\text{trap}}-W_{\\text{exact}}\\rvert$。\n    5.  绝对辛普森误差，$e_{\\text{simp}}=\\lvert W_{\\text{simp}}-W_{\\text{exact}}\\rvert$。\n-   **推导要求**：算法必须从多项式插值和多项式精确积分的第一性原理推导得出。\n-   **单位**：长度 $x$ 单位为米 (m)，$k$ 单位为牛顿每米 (N/m)，$\\alpha$ 单位为牛顿每立方米 (N/m$^{3}$)，功 $W$ 单位为焦耳 (J)。\n-   **测试用例**：\n    -   用例 $1$：$k=100$, $\\alpha=2000$, $a=0$, $b=0.2$, $n=20$。\n    -   用例 $2$：$k=250$, $\\alpha=0$, $a=0$, $b=0.3$, $n=12$。\n    -   用例 $3$：$k=50$, $\\alpha=-500$, $a=0.0$, $b=0.25$, $n=10$。\n    -   用例 $4$：$k=120$, $\\alpha=8000$, $a=0.05$, $b=0.18$, $n=2$。\n\n### 步骤 2：使用提取的已知条件进行验证\n\n-   **科学依据**：该问题在经典力学（功作为力的积分）和数值分析 (Newton-Cotes 求积法) 方面有坚实的基础。力定律 $F(x)=kx+\\alpha x^3$ 是非线性弹簧（Duffing 振子）的标准模型，是物理学和工程动力学中的一个主要内容。\n-   **适定性**：该问题是适定的。被积函数 $F(x)$ 是一个多项式，它是连续且无限可微的，这保证了存在唯一的定积分。指定的数值方法，即复合梯形法则和辛普森法则，是定义明确的算法，对于给定的函数和分区，会产生唯一的结果。已经注意到辛普森法则要求 $n$ 为偶数的条件，并且所有提供的测试用例都遵守此要求。\n-   **客观性**：问题陈述客观而精确。所有参数、变量和计算目标都得到了清晰的定义，没有歧义或主观解释。\n-   **完整性和一致性**：问题提供了所有必要的信息：要积分的函数、其参数 ($k, \\alpha$)、积分限 ($a, b$) 以及每种情况下的子区间数 ($n$)。要计算的量的定义是明确的。单位在整个问题中保持一致。\n-   **无其他缺陷**：该问题没有表现出验证清单中的任何其他缺陷。辛普森法则对于给定的被积函数是精确的这一事实，是一个有待发现和证明的关键属性，而不是一个使问题变得无足轻重的缺陷。任务仍然是从第一性原理推导方法并实现它们，以计算指定的值。\n\n### 步骤 3：结论与行动\n\n问题陈述是 **有效的**。它在科学上是合理的、适定的和完整的。我现在将继续进行完整解答。\n\n### 基于原理的解决方案设计\n\n一个变力 $F(x)$ 在一维路径上将一个物体从 $x=a$ 移动到 $x=b$ 所做的机械功 $W$ 由以下定积分给出：\n$$\nW = \\int_{a}^{b} F(x) \\,dx\n$$\n在本问题中，力由非线性函数 $F(x) = kx + \\alpha x^3$ 给出。我们将首先找到功的精确解析解，然后按要求从第一性原理推导数值近似解。\n\n#### 1. 精确功计算 ($W_{\\text{exact}}$)\n精确功可通过对多项式力函数直接积分得到。使用积分的幂法则 $\\int x^p \\,dx = \\frac{x^{p+1}}{p+1}$：\n$$\nW_{\\text{exact}} = \\int_{a}^{b} (kx + \\alpha x^3) \\,dx = \\left[ k\\frac{x^2}{2} + \\alpha\\frac{x^4}{4} \\right]_{a}^{b}\n$$\n在积分上下限处计算反导函数的值，得到：\n$$\nW_{\\text{exact}} = \\left( k\\frac{b^2}{2} + \\alpha\\frac{b^4}{4} \\right) - \\left( k\\frac{a^2}{2} + \\alpha\\frac{a^4}{4} \\right)\n$$\n该公式提供了精确的基准值，我们将用它来与数值方法进行比较。\n\n#### 2. 复合梯形法则 ($W_{\\text{trap}}$)\n该法则通过对每个子区间内曲线下方形成的梯形面积求和来近似积分。积分区间 $[a, b]$ 被划分为 $n$ 个均匀的子区间 $[x_i, x_{i+1}]$（$i = 0, 1, \\dots, n-1$），每个子区间的宽度为 $h = (b-a)/n$。\n\n**第一性原理推导：**\n在单个子区间 $[x_i, x_{i+1}]$ 上，我们用一个通过点 $(x_i, F(x_i))$ 和 $(x_{i+1}, F(x_{i+1}))$ 的线性多项式（一条直线）$P_1(x)$ 来近似函数 $F(x)$。这个线性插值函数的积分就是由这些点和x轴形成的梯形的面积：\n$$\n\\int_{x_i}^{x_{i+1}} F(x) \\,dx \\approx \\int_{x_i}^{x_{i+1}} P_1(x) \\,dx = \\frac{1}{2} (F(x_i) + F(x_{i+1})) (x_{i+1} - x_i) = \\frac{h}{2} (F(x_i) + F(x_{i+1}))\n$$\n复合规则将这 $n$ 个子区间上的近似值相加：\n$$\nW_{\\text{trap}} = \\sum_{i=0}^{n-1} \\frac{h}{2} (F(x_i) + F(x_{i+1}))\n$$\n展开并合并各项：\n$$\nW_{\\text{trap}} = \\frac{h}{2} [ (F(x_0) + F(x_1)) + (F(x_1) + F(x_2)) + \\dots + (F(x_{n-1}) + F(x_n)) ]\n$$\n$$\nW_{\\text{trap}} = \\frac{h}{2} [ F(x_0) + 2F(x_1) + 2F(x_2) + \\dots + 2F(x_{n-1}) + F(x_n) ]\n$$\n为便于实现，可以更紧凑地写为：\n$$\nW_{\\text{trap}} = h \\left( \\frac{F(x_0) + F(x_n)}{2} + \\sum_{i=1}^{n-1} F(x_i) \\right)\n$$\n\n#### 3. 复合辛普森法则 ($W_{\\text{simp}}$)\n该方法通过使用二次近似来提供更高的精度。它要求子区间数 $n$ 为偶数。该方法通过考虑成对的子区间，即宽度为 $2h$ 的区间板，如 $[x_i, x_{i+2}]$ 来工作。\n\n**第一性原理推导：**\n在单个区间板 $[x_{2j-2}, x_{2j}]$ 上（$j = 1, \\dots, n/2$），我们用一个二次多项式 $P_2(x)$ 来近似 $F(x)$，该多项式在三个点上插值函数：$(x_{2j-2}, F(x_{2j-2}))$、$(x_{2j-1}, F(x_{2j-1}))$ 和 $(x_{2j}, F(x_{2j}))$。为了求 $P_2(x)$ 的积分，为简单起见，我们可以将区间平移到 $[-h, h]$（令 $z = x - x_{2j-1}$）。二次插值函数在此区间上的积分给出了著名的辛普森1/3法则的单区间板公式：\n$$\n\\int_{x_{2j-2}}^{x_{2j}} F(x) \\,dx \\approx \\int_{-h}^{h} P_2(z) \\,dz = \\frac{h}{3} (F(x_{2j-2}) + 4F(x_{2j-1}) + F(x_{2j}))\n$$\n复合规则将这 $n/2$ 个区间板上的近似值相加：\n$$\nW_{\\text{simp}} = \\sum_{j=1}^{n/2} \\frac{h}{3} (F(x_{2j-2}) + 4F(x_{2j-1}) + F(x_{2j}))\n$$\n展开这个和式揭示了函数求值的权重模式：\n$$\nW_{\\text{simp}} = \\frac{h}{3} [ (F(x_0) + 4F(x_1) + F(x_2)) + (F(x_2) + 4F(x_3) + F(x_4)) + \\dots + (F(x_{n-2}) + 4F(x_{n-1}) + F(x_n)) ]\n$$\n具有偶数索引的内部点（例如，$F(x_2)$）被计算两次，而具有奇数索引的点被计算一次（乘以4）。合并各项得出最终公式：\n$$\nW_{\\text{simp}} = \\frac{h}{3} [ F(x_0) + 4F(x_1) + 2F(x_2) + 4F(x_3) + \\dots + 2F(x_{n-2}) + 4F(x_{n-1}) + F(x_n) ]\n$$\n这可以通过分别对奇数索引项和偶数索引项求和来实现：\n$$\nW_{\\text{simp}} = \\frac{h}{3} \\left( F(x_0) + F(x_n) + 4 \\sum_{i=1, i \\text{ odd}}^{n-1} F(x_i) + 2 \\sum_{i=2, i \\text{ even}}^{n-2} F(x_i) \\right)\n$$\n辛普森法则的一个关键特性是它对任何次数小于或等于3的多项式都是精确的。由于我们的力函数 $F(x) = kx + \\alpha x^3$ 是一个三次多项式，辛普森法则的误差项（取决于 $F(x)$ 的四阶导数）为零 ($F^{(4)}(x) = 0$)。因此，复合辛普森法则将计算出精确功，$W_{\\text{simp}} = W_{\\text{exact}}$，误差 $e_{\\text{simp}}$ 将为零（或在机器浮点精度范围内为零）。\n\n#### 4. 绝对误差计算\n梯形法则 ($e_{\\text{trap}}$) 和辛普森法则 ($e_{\\text{simp}}$) 的绝对误差是通过取数值近似值与精确值之差的绝对值来计算的：\n$$\ne_{\\text{trap}} = \\lvert W_{\\text{trap}} - W_{\\text{exact}} \\rvert\n$$\n$$\ne_{\\text{simp}} = \\lvert W_{\\text{simp}} - W_{\\text{exact}} \\rvert\n$$\n实现将继续为每个测试用例编码这些推导出的公式。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes exact work, composite trapezoidal and Simpson's rule approximations,\n    and their absolute errors for a nonlinear spring system.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (k, alpha, a, b, n)\n        (100.0, 2000.0, 0.0, 0.2, 20),\n        (250.0, 0.0, 0.0, 0.3, 12),\n        (50.0, -500.0, 0.0, 0.25, 10),\n        (120.0, 8000.0, 0.05, 0.18, 2),\n    ]\n\n    results = []\n    for k, alpha, a, b, n in test_cases:\n        # Define the force function F(x) = kx + alpha*x^3\n        def F(x):\n            return k * x + alpha * x**3\n\n        # 1. Exact Work Calculation (W_exact)\n        # The analytical integral of F(x) is (k/2)*x^2 + (alpha/4)*x^4.\n        work_exact = (k / 2.0 * b**2 + alpha / 4.0 * b**4) - \\\n                     (k / 2.0 * a**2 + alpha / 4.0 * a**4)\n\n        # Set up the uniform partition for numerical integration\n        h = (b - a) / n\n        x = np.linspace(a, b, n + 1)\n        y = F(x)\n\n        # 2. Composite Trapezoidal Rule (W_trap)\n        # Formula: h * [ (y_0 + y_n)/2 + sum(y_i for i=1 to n-1) ]\n        if n > 0:\n            work_trap = h * (0.5 * y[0] + np.sum(y[1:-1]) + 0.5 * y[-1])\n        else: # Handle n=0 case, though not in test data\n            work_trap = 0.0\n\n        # 3. Composite Simpson's Rule (W_simp)\n        # Formula: (h/3) * [ y_0 + 4*sum(odd_indices) + 2*sum(even_indices) + y_n ]\n        # This rule requires n to be even, which is true for all test cases.\n        if n % 2 == 0 and n > 0:\n            sum_odd_indices = np.sum(y[1:-1:2])\n            sum_even_indices = np.sum(y[2:-1:2])\n            work_simp = (h / 3.0) * (y[0] + 4.0 * sum_odd_indices + 2.0 * sum_even_indices + y[-1])\n        else:\n            # Not applicable for odd n, but handle for completeness\n            work_simp = float('nan') \n\n        # 4. Absolute Error Calculations\n        error_trap = abs(work_trap - work_exact)\n        error_simp = abs(work_simp - work_exact)\n\n        # Append the 5-tuple of results for the current case.\n        results.append([work_exact, work_trap, work_simp, error_trap, error_simp])\n\n    # Final print statement in the exact required format.\n    # [[case1],[case2],[case3],[case4]] with no spaces.\n    case_strings = [f'[{\",\".join(map(str, res))}]' for res in results]\n    print(f'[{\",\".join(case_strings)}]')\n\nsolve()\n```"
        },
        {
            "introduction": "虽然高阶数值积分方法通常更精确，但这一认识并非总是成立，其有效性依赖于被积函数的光滑性。本练习提供了一个精心设计的反例 ()，其中低阶的梯形法则出人意料地比高阶的辛普森法则表现更佳。通过分析这个特殊情况，你将更深刻地理解函数的可微性对求积公式收敛阶的关键影响。",
            "id": "3258564",
            "problem": "考虑应用于连续函数的闭式 Newton–Cotes 求积法则。定义连续函数 $f:[0,2]\\to\\mathbb{R}$ 如下：\n$$\nf(x)=\n\\begin{cases}\n0, & 0 \\le x \\le 0.9, \\\\\n100(x-0.9), & 0.9 \\le x \\le 1, \\\\\n100(1.1-x), & 1 \\le x \\le 1.1, \\\\\n0, & 1.1 \\le x \\le 2.\n\\end{cases}\n$$\n令 $I=\\int_{0}^{2} f(x)\\,dx$ 为精确积分值。使用标准复合梯形法则和标准复合 Simpson 法则，在 $[0,2]$ 上均使用 $N=2$ 个等长子区间，计算它们对 $I$ 的近似值。然后计算绝对误差 $E_{T}=\\left|T-I\\right|$ 和 $E_{S}=\\left|S-I\\right|$，其中 $T$ 和 $S$ 分别表示复合梯形和复合 Simpson 近似值。最后，给出比值 $\\left|E_{S}\\right|/\\left|E_{T}\\right|$ 的精确值，以证明一个在该分辨率下 Simpson 法则比梯形法则精度更低的案例。将最终答案表示为一个精确的有理数。无需进行四舍五入。",
            "solution": "首先，我们确定问题中各个部分的精确值。\n\n**第1步：计算精确积分 $I$**\n\n被积函数 $f(x)$ 是一个三角形函数（或称“帐篷函数”），其在 $x=0.9$ 和 $x=1.1$ 之外的区域为零。该三角形的底边在 $x$ 轴上，范围从 $0.9$ 到 $1.1$，因此底边宽度为 $1.1 - 0.9 = 0.2$。三角形的顶点在 $x=1$ 处，高度为 $f(1) = 100(1-0.9) = 10$。\n积分 $I$ 就是这个三角形的面积：\n$$\nI = \\frac{1}{2} \\times \\text{底} \\times \\text{高} = \\frac{1}{2} \\times 0.2 \\times 10 = 1\n$$\n\n**第2步：计算复合梯形近似值 $T$**\n\n问题要求在区间 $[0,2]$ 上使用 $N=2$ 个等长子区间。这意味着步长 $h = (2-0)/2 = 1$。积分节点为 $x_0 = 0$, $x_1 = 1$, $x_2 = 2$。\n复合梯形法则的公式为：\n$$\nT = \\frac{h}{2} [f(x_0) + 2f(x_1) + f(x_2)]\n$$\n我们需要计算节点上的函数值：\n- $f(x_0) = f(0) = 0$\n- $f(x_1) = f(1) = 100(1-0.9) = 10$\n- $f(x_2) = f(2) = 0$\n代入公式：\n$$\nT = \\frac{1}{2} [0 + 2(10) + 0] = 10\n$$\n因此，梯形法则的绝对误差为 $E_T = |T - I| = |10 - 1| = 9$。\n\n**第3步：计算复合辛普森近似值 $S$**\n\n对于相同的节点 $x_0=0, x_1=1, x_2=2$ 和步长 $h=1$，$N=2$ 个子区间意味着对整个区间 $[0,2]$ 应用一次基本的辛普森法则。\n辛普森法则的公式为：\n$$\nS = \\frac{h}{3} [f(x_0) + 4f(x_1) + f(x_2)]\n$$\n使用我们已经计算出的函数值：\n$$\nS = \\frac{1}{3} [0 + 4(10) + 0] = \\frac{40}{3}\n$$\n因此，辛普森法则的绝对误差为 $E_S = |S - I| = \\left|\\frac{40}{3} - 1\\right| = \\left|\\frac{37}{3}\\right| = \\frac{37}{3}$。\n\n**第4步：计算误差比**\n\n最后，我们计算两个误差的绝对值之比：\n$$\n\\frac{|E_S|}{|E_T|} = \\frac{37/3}{9} = \\frac{37}{27}\n$$\n这个结果大于1，表明在这种情况下，对于给定的粗糙网格，高阶的辛普森法则反而比低阶的梯形法则产生了更大的误差。这是因为辛普森法则的高阶精度依赖于被积函数具有足够的光滑性（即高阶导数有界），而本例中的帐篷函数 $f(x)$ 仅是连续的，其一阶导数在 $x=0.9, 1, 1.1$ 处不连续，不满足辛普森法则误差理论的前提条件。",
            "answer": "$$\n\\boxed{\\frac{37}{27}}\n$$"
        },
        {
            "introduction": "对于在某些区域变化剧烈而在其他区域近乎平坦的函数，使用均匀网格的积分方法效率低下。自适应求积通过在函数变化剧烈的区域自动加密采样点来解决这一问题 ()。在此练习中，你将实现一个自适应辛普森方法，并将其效率（精度与计算成本之比）与标准复合辛普森方法进行比较，从而掌握一种在实际科学计算中更为强大和通用的工具。",
            "id": "3214881",
            "problem": "考虑对函数 $f(x) = \\exp\\left(-100(x - 0.3)^2\\right)$ 在区间 $[0,1]$ 上的定积分进行数值计算。任务是实现两种基于辛普森法则的复合数值积分方法，并比较它们的精度和计算量：\n\n1. 一种均匀复合辛普森方法，它将 $[0,1]$ 划分为 $N$ 个等长的子区间，其中 $N$ 是一个偶数。如果提供的 $N$ 是奇数，实现时必须将其加 1，以使该法则适用。\n\n2. 一种带有局部误差控制的自适应复合辛普森方法，该方法递归地细分一个区间，直到满足指定的局部绝对容差 $\\text{tol}$。局部误差控制必须通过比较一个区间上的辛普森近似值与其两个半区间上的辛普森近似值之和来强制执行，并通过一种确保全局绝对误差受控的方式将容差分配到子区间。\n\n实现应基于以下基本原理：\n\n- 多项式插值：通过三个点的二次插值多项式来逼近一个区间上足够光滑的函数，并对该插值多项式进行精确积分。\n- 基于复合多项式的求积误差行为：对于足够光滑的 $f$，辛普森法则在单个面板上的截断误差与区间长度的五次方成正比，在均匀应用时产生四阶全局收敛率。\n\n使用高斯函数的已知反导数（以误差函数表示）计算积分的真值，并将其用作误差计算的基准。\n\n对于每种方法，报告：\n- 相对于积分真值的绝对误差。\n- 所用的函数求值次数。\n\n程序必须实现这两种方法，并运行以下测试套件，其中每个测试用例是一对 $(\\text{tol}, N)$：\n\n- 测试用例 1（正常路径）：$\\text{tol} = 10^{-6}$，$N = 100$。\n- 测试用例 2（更严格的容差，更精细的网格）：$\\text{tol} = 10^{-8}$，$N = 1000$。\n- 测试用例 3（更宽松的容差，更粗糙的网格）：$\\text{tol} = 10^{-4}$，$N = 10$。\n- 测试用例 4（使用最少均匀面板的边缘情况）：$\\text{tol} = 10^{-10}$，$N = 2$。\n- 测试用例 5（非常严格的容差）：$\\text{tol} = 10^{-12}$，$N = 200$。\n\n您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。此列表中的每个元素对应一个测试用例，并且本身必须是包含以下四个值的列表：$[\\text{abs\\_error\\_adaptive}, \\text{evals\\_adaptive}, \\text{abs\\_error\\_uniform}, \\text{evals\\_uniform}]$。例如，两个用例的输出形式为 $[[e_1,c_1,E_1,C_1],[e_2,c_2,E_2,C_2]]$。\n\n本问题不涉及物理单位，也不需要角度或百分比。最终输出值必须是实数或整数（视情况而定），不带任何附加文本。",
            "solution": "用户提供了一个有效的问题陈述。\n\n### 步骤1：提取给定信息\n- **待积函数**：$f(x) = \\exp\\left(-100(x - 0.3)^2\\right)$\n- **积分区间**：$[0, 1]$\n- **方法1**：均匀复合辛普森法则，使用 $N$ 个等长子区间。如果 $N$ 是奇数，则必须将其加 1。\n- **方法2**：自适应复合辛普森法则，使用局部绝对容差 $\\text{tol}$。通过比较同一区间上的单面板辛普森法则近似值 ($S_1$) 与双面板近似值 ($S_2$) 来估计局部误差。\n- **真值**：使用误差函数 $\\text{erf}(x)$ 计算。\n- **每种方法的输出**：相对于真值的绝对误差和总函数求值次数。\n- **测试套件**：一系列测试用例，每个由一对 $(\\text{tol}, N)$ 定义：\n    1. $(\\text{tol} = 10^{-6}, N = 100)$\n    2. $(\\text{tol} = 10^{-8}, N = 1000)$\n    3. $(\\text{tol} = 10^{-4}, N = 10)$\n    4. $(\\text{tol} = 10^{-10}, N = 2)$\n    5. $(\\text{tol} = 10^{-12}, N = 200)$\n- **输出格式**：单行文本：`[[abs_error_adaptive, evals_adaptive, abs_error_uniform, evals_uniform], ...]`，包含所有测试用例。\n\n### 步骤2：使用提取的给定信息进行验证\n问题被评估为**有效**。\n\n- **科学上成立**：该问题是数值分析中的一个标准练习，涉及完善的求积法则（复合辛普森法则，自适应求积）的实现和比较。该函数是一个高斯函数，它是解析的，因此是无限可微的 ($C^\\infty$)，这使其成为高阶积分方法的理想候选。通过误差函数计算真值的方法在数学上是合理的。\n- **适定的**：问题定义清晰。函数、区间、方法和参数都已指定。对于每个测试用例，都可以计算出唯一的数值结果。\n- **客观的**：语言精确，没有主观或模糊的术语。\n- **完整性和一致性**：问题是自包含的。提供了实现解决方案和运行测试所需的所有必要信息。没有内部矛盾。\n- **可行性**：所需的计算是标准的，并且在计算上是可行的。\n\n### 步骤3：结论与行动\n问题有效。将开发一个完整的解决方案。\n\n### 基于原理的解决方案\n任务是使用两种复合辛普森法则的变体来评估定积分 $I = \\int_0^1 f(x) \\,dx$（其中 $f(x) = \\exp\\left(-100(x - 0.3)^2\\right)$），并比较它们的效率。\n\n**1. 积分的真值**\n\n高斯函数的积分可以用误差函数 $\\text{erf}(z) = \\frac{2}{\\sqrt{\\pi}} \\int_0^z e^{-t^2} \\,dt$ 来表示。\n令 $I = \\int_0^1 \\exp\\left(-100(x - 0.3)^2\\right) \\,dx$。\n我们进行变量替换。令 $u = \\sqrt{100}(x - 0.3) = 10(x - 0.3)$。这意味着 $du = 10 \\,dx$，即 $dx = \\frac{1}{10} \\,du$。\n$u$ 的积分上下限为：\n- 当 $x = 0$ 时，$u = 10(0 - 0.3) = -3$。\n- 当 $x = 1$ 时，$u = 10(1 - 0.3) = 7$。\n\n积分变为：\n$$ I = \\int_{-3}^{7} e^{-u^2} \\frac{1}{10} \\,du = \\frac{1}{10} \\int_{-3}^{7} e^{-u^2} \\,du $$\n使用误差函数的定义：\n$$ \\int_a^b e^{-t^2} \\,dt = \\int_0^b e^{-t^2} \\,dt - \\int_0^a e^{-t^2} \\,dt = \\frac{\\sqrt{\\pi}}{2} \\left[ \\text{erf}(b) - \\text{erf}(a) \\right] $$\n当 $a = -3$ 和 $b = 7$ 时，我们得到：\n$$ I = \\frac{1}{10} \\left[ \\frac{\\sqrt{\\pi}}{2} (\\text{erf}(7) - \\text{erf}(-3)) \\right] $$\n使用性质 $\\text{erf}(-z) = -\\text{erf}(z)$，真值为：\n$$ I_{true} = \\frac{\\sqrt{\\pi}}{20} \\left[ \\text{erf}(7) + \\text{erf}(3) \\right] $$\n此值将作为我们计算数值方法绝对误差的基准。\n\n**2. 均匀复合辛普森法则**\n\n辛普森法则通过对通过点 $(a, f(a))$、$((a+b)/2, f((a+b)/2))$ 和 $(b, f(b))$ 的二次插值多项式进行积分，来近似函数 $f(x)$ 在区间 $[a, b]$ 上的积分。公式为：\n$$ S(a, b) = \\frac{b-a}{6} \\left[ f(a) + 4f\\left(\\frac{a+b}{2}\\right) + f(b) \\right] $$\n复合辛普森法则是在积分区间的划分上应用此公式。对于将 $[a, b]$ 均匀划分为 $N$ 个等宽子区间（宽度 $h = (b-a)/N$，其中 $N$ 必须是偶数），节点为 $x_i = a + ih$，其中 $i = 0, 1, \\dots, N$。积分近似为：\n$$ S_N = \\frac{h}{3} \\left[ f(x_0) + 4\\sum_{i=1, i \\text{ is odd}}^{N-1} f(x_i) + 2\\sum_{i=2, i \\text{ is even}}^{N-2} f(x_i) + f(x_N) \\right] $$\n该方法的函数求值次数为 $N+1$。根据问题要求，如果给定的 $N$ 是奇数，则将其增加到 $N+1$，使得求值次数为 $N+2$。\n\n**3. 自适应复合辛普森法则**\n\n自适应求积方法根据被积函数的局部行为调整求值点的密度。函数 $f(x)$ 在 $x=0.3$ 附近有一个尖峰，在其他地方几乎为零，这使其成为采用自适应方法的绝佳候选。该方法工作如下：\n\n对于一个区间 $[a, b]$，我们计算两个近似值：\n- 一个“粗略”近似值 $S_1$，使用 $[a, b]$ 上的单个辛普森面板。\n- 一个“精细”近似值 $S_2$，通过对半区间 $[a, m]$ 和 $[m, b]$ 上的两个辛普森面板求和得到，其中 $m = (a+b)/2$。\n\n在宽度为 $h=b-a$ 的区间上，单面板辛普森法则的误差约为 $E_1 \\approx -\\frac{h^5}{2880} f^{(4)}(\\xi)$。双面板近似的误差为 $E_2 \\approx 2 \\times \\left(-\\frac{(h/2)^5}{2880} f^{(4)}(\\eta)\\right) \\approx \\frac{1}{16} E_1$。\n真积分 $I$ 可以写为 $I = S_1 + E_1$ 和 $I = S_2 + E_2$。\n假设 $f^{(4)}$ 在 $[a, b]$ 上几乎是常数，我们可以在近似值和更精细近似值的误差 $E_2$ 之间建立关系：\n$$ S_2 - S_1 \\approx E_1 - E_2 \\approx 16 E_2 - E_2 = 15 E_2 $$\n因此，$S_2$ 中局部误差的估计值为 $\\text{err} \\approx \\frac{|S_2 - S_1|}{15}$。\n\n自适应算法是递归的：\n1.  对于给定的区间 $[a, b]$ 和局部容差 $\\text{tol}_{local}$，计算 $S_1$ 和 $S_2$。\n2.  计算误差估计 $\\text{err} = \\frac{|S_2 - S_1|}{15}$。\n3.  如果 $\\text{err}  \\text{tol}_{local}$，则区间已充分解析。我们接受结果，并且为提高精度，返回 Richardson 外推值 $I_{[a,b]} = S_2 + \\frac{S_2 - S_1}{15}$。这是对该区间上积分的更准确估计。\n4.  如果 $\\text{err} \\ge \\text{tol}_{local}$，则区间未解析。将其细分为 $[a, m]$ 和 $[m, b]$。对每个子区间递归调用该算法，但每个子区间的容差减半：$\\text{tol}_{local}/2$。总积分是两次递归调用的结果之和。\n\n为确保全局误差控制，容差按区间宽度成比例分配。初始调用使用全局容差 $\\text{tol}$。在半区间上的每个递归步骤使用其父区间容差的一半。\n\n为避免冗余计算，端点和中点的函数值通过递归向下传递。在已知 $f(a)$、$f((a+b)/2)$ 和 $f(b)$ 的情况下，对 $[a, b]$ 的递归步骤只需要计算两个新值：$f((a+m)/2)$ 和 $f((m+b)/2)$。在整个递归过程中跟踪函数求值的总次数。\n\n这种自适应策略将计算量集中在高斯函数峰值周围的区域（$x \\approx 0.3$），即函数变化迅速的地方，而在 $x=0$ 和 $x=1$ 附近的平坦区域使用很少的求值，从而实现高效率。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Implements and compares uniform and adaptive Simpson's rule for integrating\n    a Gaussian function, then runs a suite of test cases.\n    \"\"\"\n    \n    # 1. Define the function to integrate\n    def f(x):\n        return np.exp(-100.0 * (x - 0.3)**2)\n\n    # 2. Calculate the \"true\" value of the integral using the error function\n    # I = integral from 0 to 1 of exp(-100*(x-0.3)^2) dx\n    # Let u = 10*(x-0.3), so du = 10*dx.\n    # Limits: x=0 -> u=-3; x=1 -> u=7.\n    # I = (1/10) * integral from -3 to 7 of exp(-u^2) du\n    # Using erf(z) = (2/sqrt(pi)) * integral from 0 to z of exp(-t^2) dt\n    # Integral from a to b = sqrt(pi)/2 * (erf(b) - erf(a))\n    # I = (1/10) * sqrt(pi)/2 * (erf(7) - erf(-3))\n    #   = (sqrt(pi)/20) * (erf(7) + erf(3))\n    true_value = (math.sqrt(math.pi) / 20.0) * (math.erf(7.0) + math.erf(3.0))\n\n    # 3. Uniform Composite Simpson's Rule Implementation\n    def uniform_simpson(func, a, b, N):\n        \"\"\"\n        Calculates the definite integral using the uniform composite Simpson's rule.\n        \n        Args:\n            func: The function to integrate.\n            a, b: The interval of integration.\n            N: The number of subintervals (must be even, adjusted if not).\n            \n        Returns:\n            A tuple (integral_value, num_evaluations).\n        \"\"\"\n        if N % 2 != 0:\n            N += 1\n        \n        h = (b - a) / float(N)\n        x = np.linspace(a, b, N + 1)\n        y = func(x)\n        \n        # Simpson's formula: h/3 * (y0 + 4y1 + 2y2 + ... + 4y(N-1) + yN)\n        # Slicing: y[1:-1:2] gets odd indices, y[2:-2:2] gets even indices.\n        integral = (h / 3.0) * (y[0] + 4.0 * np.sum(y[1:-1:2]) + 2.0 * np.sum(y[2:-2:2]) + y[-1])\n        \n        evals = N + 1\n        return integral, evals\n\n    # 4. Adaptive Composite Simpson's Rule Implementation\n    def adaptive_simpson(func, a, b, tol):\n        \"\"\"\n        Wrapper for the recursive adaptive Simpson's rule integrator.\n        \n        Args:\n            func: The function to integrate.\n            a, b: The interval of integration.\n            tol: The desired absolute error tolerance.\n            \n        Returns:\n            A tuple (integral_value, num_evaluations).\n        \"\"\"\n        \n        eval_count = [0] # Use a list as a mutable counter\n\n        def f_counted(x):\n            eval_count[0] += 1\n            return func(x)\n        \n        # Initial function evaluations\n        fa = f_counted(a)\n        fm = f_counted((a + b) / 2.0)\n        fb = f_counted(b)\n        \n        integral = _adaptive_simpson_recursive(f_counted, a, b, tol, fa, fm, fb)\n        \n        return integral, eval_count[0]\n\n    def _adaptive_simpson_recursive(func, a, b, tol, fa, fm, fb):\n        \"\"\"Recursive helper for adaptive Simpson's rule.\"\"\"\n        h = b - a\n        m = (a + b) / 2.0\n        \n        # Coarse approximation (1 panel)\n        s1 = (h / 6.0) * (fa + 4.0 * fm + fb)\n        \n        # Finer approximation (2 panels) requires 2 new function evaluations\n        ml = (a + m) / 2.0\n        mr = (m + b) / 2.0\n        fml = func(ml)\n        fmr = func(mr)\n        \n        s2 = (h / 12.0) * (fa + 4.0 * fml + 2.0 * fm + 4.0 * fmr + fb)\n        \n        # Error estimation: |(S2 - S1) / 15| is an estimate of the error in S2.\n        error_estimate = abs(s2 - s1) / 15.0\n        \n        if error_estimate  tol:\n            # Richardson extrapolation for a more accurate result\n            return s2 + (s2 - s1) / 15.0\n        else:\n            # Subdivide and recurse, distributing tolerance\n            left_integral = _adaptive_simpson_recursive(func, a, m, tol / 2.0, fa, fml, fm)\n            right_integral = _adaptive_simpson_recursive(func, m, b, tol / 2.0, fm, fmr, fb)\n            return left_integral + right_integral\n\n    # 5. Define test cases\n    test_cases = [\n        (1e-6, 100),\n        (1e-8, 1000),\n        (1e-4, 10),\n        (1e-10, 2),\n        (1e-12, 200),\n    ]\n\n    all_results = []\n\n    # 6. Run the test suite\n    for tol, N in test_cases:\n        # Run adaptive method\n        res_adaptive, evals_adaptive = adaptive_simpson(f, 0.0, 1.0, tol)\n        error_adaptive = abs(res_adaptive - true_value)\n\n        # Run uniform method\n        res_uniform, evals_uniform = uniform_simpson(f, 0.0, 1.0, N)\n        error_uniform = abs(res_uniform - true_value)\n        \n        # Store results for this test case\n        case_result = [error_adaptive, evals_adaptive, error_uniform, evals_uniform]\n        all_results.append(case_result)\n\n    # 7. Format and print the final output\n    # The output format must be exact: [[v1,v2,v3,v4],[v5,v6,v7,v8]] with no spaces.\n    # repr() gives the correct bracket/comma structure, and .replace removes spaces.\n    output_str = repr(all_results).replace(' ', '')\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}