{
    "hands_on_practices": [
        {
            "introduction": "The best way to understand numerical methods is to build and test them. This first practice connects the abstract concept of integration to the physical calculation of mechanical work. You will implement the composite trapezoidal and Simpson's rules to find the work done by a nonlinear spring, allowing you to directly compare their accuracy against a known analytical solution and gain intuition for their relative performance . This exercise is especially insightful because the integrand, a cubic polynomial, reveals a key property about the exactness of Simpson's rule.",
            "id": "3214920",
            "problem": "You are to design and implement a program that computes the mechanical work $W$ required to move a mass-spring system with nonlinear stiffness along a one-dimensional displacement from position $x=a$ to position $x=b$. The force law is $F(x)=kx+\\alpha x^{3}$, where $k$ and $\\alpha$ are real constants. The work is defined by the Riemann integral $W=\\int_{a}^{b}F(x)\\,dx$. Your program must approximate $W$ using two composite numerical integration schemes on a uniform partition with $n$ subintervals: the composite trapezoidal rule and the composite Simpson rule, both derived from the standard viewpoint of approximating the integrand by low-degree polynomials over subintervals and summing their exact subinterval integrals. In addition, compute the exact work by directly integrating the given $F(x)$ and use it to quantify the absolute error of each numerical method. All work values and errors must be expressed in joules (J) as floating-point numbers.\n\nFundamental base to use for the derivations and algorithm design: the definition of work as an integral $W=\\int_{a}^{b}F(x)\\,dx$, the properties of polynomials, and the foundational principle of Newton–Cotes quadrature that approximates an integral by integrating an interpolating polynomial of the integrand over each subinterval. Do not assume or cite any pre-derived quadrature weights in your reasoning; instead base your design on first principles of polynomial interpolation and exact integration of polynomials over finite intervals.\n\nImplement both composite rules on a uniform partition $\\{x_{i}\\}_{i=0}^{n}$ with $x_{0}=a$, $x_{n}=b$, $x_{i}=a+ih$, and $h=(b-a)/n$. For the composite Simpson rule, $n$ must be even. For each test case below, compute:\n- the exact work $W_{\\text{exact}}=\\int_{a}^{b}F(x)\\,dx$,\n- the composite trapezoidal approximation $W_{\\text{trap}}$,\n- the composite Simpson approximation $W_{\\text{simp}}$,\n- the absolute trapezoidal error $e_{\\text{trap}}=\\lvert W_{\\text{trap}}-W_{\\text{exact}}\\rvert$,\n- the absolute Simpson error $e_{\\text{simp}}=\\lvert W_{\\text{simp}}-W_{\\text{exact}}\\rvert$.\n\nAngle units are not involved in this problem. All lengths $x$ are in meters (m), $k$ is in newtons per meter (N/m), $\\alpha$ is in newtons per meter cubed (N/m$^{3}$), and all work values must be reported in joules (J).\n\nUse the following test suite, which covers a general case, a linear boundary case, a softening nonlinearity, and a coarse-partition edge case:\n- Case $1$: $k=100$, $\\alpha=2000$, $a=0$, $b=0.2$, $n=20$.\n- Case $2$: $k=250$, $\\alpha=0$, $a=0$, $b=0.3$, $n=12$.\n- Case $3$: $k=50$, $\\alpha=-500$, $a=0.0$, $b=0.25$, $n=10$.\n- Case $4$: $k=120$, $\\alpha=8000$, $a=0.05$, $b=0.18$, $n=2$.\n\nYour program must produce a single line of output containing the aggregated results for all test cases as a comma-separated list of lists, with no spaces. For each case, the inner list must be ordered as $[W_{\\text{exact}},W_{\\text{trap}},W_{\\text{simp}},e_{\\text{trap}},e_{\\text{simp}}]$. Thus the final output must be a single line string of the form [[case1],[case2],[case3],[case4]] where each [casei] is the bracketed five-tuple in the specified order. Do not print units; the numerical values are understood to be in joules (J).",
            "solution": "The user wants to solve a problem about numerical integration, specifically calculating mechanical work using composite quadrature rules.\n\n### Step 1: Extract Givens\n\n-   **Physical System**: A mass-spring system with a nonlinear restoring force.\n-   **Force Law**: $F(x)=kx+\\alpha x^{3}$, where $k$ and $\\alpha$ are real constants.\n-   **Work Definition**: $W=\\int_{a}^{b}F(x)\\,dx$.\n-   **Numerical Methods**: Composite trapezoidal rule and composite Simpson's rule.\n-   **Partition**: Uniform partition $\\{x_{i}\\}_{i=0}^{n}$ with $n$ subintervals, where $x_{0}=a$, $x_{n}=b$, $x_{i}=a+ih$, and $h=(b-a)/n$.\n-   **Constraint**: For the composite Simpson rule, $n$ must be an even integer.\n-   **Task**: For each test case, compute:\n    1.  Exact work, $W_{\\text{exact}}=\\int_{a}^{b}F(x)\\,dx$.\n    2.  Composite trapezoidal approximation, $W_{\\text{trap}}$.\n    3.  Composite Simpson approximation, $W_{\\text{simp}}$.\n    4.  Absolute trapezoidal error, $e_{\\text{trap}}=\\lvert W_{\\text{trap}}-W_{\\text{exact}}\\rvert$.\n    5.  Absolute Simpson error, $e_{\\text{simp}}=\\lvert W_{\\text{simp}}-W_{\\text{exact}}\\rvert$.\n-   **Derivation Requirement**: The algorithms must be derived from the first principles of polynomial interpolation and exact integration of polynomials.\n-   **Units**: Length $x$ in meters (m), $k$ in newtons per meter (N/m), $\\alpha$ in newtons per meter cubed (N/m$^{3}$), and work $W$ in joules (J).\n-   **Test Cases**:\n    -   Case $1$: $k=100$, $\\alpha=2000$, $a=0$, $b=0.2$, $n=20$.\n    -   Case $2$: $k=250$, $\\alpha=0$, $a=0$, $b=0.3$, $n=12$.\n    -   Case $3$: $k=50$, $\\alpha=-500$, $a=0.0$, $b=0.25$, $n=10$.\n    -   Case $4$: $k=120$, $\\alpha=8000$, $a=0.05$, $b=0.18$, $n=2$.\n\n### Step 2: Validate Using Extracted Givens\n\n-   **Scientifically Grounded**: The problem is well-grounded in classical mechanics (work as the integral of force) and numerical analysis (Newton-Cotes quadrature). The force law $F(x)=kx+\\alpha x^3$ is a standard model for a nonlinear spring (the Duffing oscillator), a staple in physics and engineering dynamics.\n-   **Well-Posed**: The problem is well-posed. The integrand $F(x)$ is a polynomial, which is continuous and infinitely differentiable, guaranteeing that a unique definite integral exists. The numerical methods specified, composite trapezoidal and Simpson's rules, are well-defined algorithms that produce unique results for a given function and partition. The condition that $n$ must be even for Simpson's rule is noted, and all provided test cases adhere to this requirement.\n-   **Objective**: The problem is stated with objective and precise language. All parameters, variables, and computational goals are clearly defined without ambiguity or subjective interpretation.\n-   **Complete and Consistent**: The problem provides all necessary information: the function to be integrated, its parameters ($k, \\alpha$), the integration limits ($a, b$), and the number of subintervals ($n$) for each case. The definitions for the quantities to be computed are explicit. Units are consistent throughout.\n-   **No Other Flaws**: The problem does not exhibit any other flaws from the validation checklist. The fact that Simpson's rule is exact for the given integrand is a key property to be discovered and demonstrated, not a flaw that trivializes the problem. The task remains to derive the methods from first principles and implement them to compute the specified values.\n\n### Step 3: Verdict and Action\n\nThe problem statement is **valid**. It is scientifically sound, well-posed, and complete. I will now proceed with the full solution.\n\n### Principle-Based Solution Design\n\nThe mechanical work $W$ done by a variable force $F(x)$ in displacing an object along a one-dimensional path from $x=a$ to $x=b$ is given by the definite integral:\n$$\nW = \\int_{a}^{b} F(x) \\,dx\n$$\nIn this problem, the force is given by the nonlinear function $F(x) = kx + \\alpha x^3$. We will first find the exact analytical solution for the work, and then derive the numerical approximations from first principles as required.\n\n#### 1. Exact Work Calculation ($W_{\\text{exact}}$)\nThe exact work is found by direct integration of the polynomial force function. Using the power rule for integration, $\\int x^p \\,dx = \\frac{x^{p+1}}{p+1}$:\n$$\nW_{\\text{exact}} = \\int_{a}^{b} (kx + \\alpha x^3) \\,dx = \\left[ k\\frac{x^2}{2} + \\alpha\\frac{x^4}{4} \\right]_{a}^{b}\n$$\nEvaluating the antiderivative at the limits of integration gives:\n$$\nW_{\\text{exact}} = \\left( k\\frac{b^2}{2} + \\alpha\\frac{b^4}{4} \\right) - \\left( k\\frac{a^2}{2} + \\alpha\\frac{a^4}{4} \\right)\n$$\nThis formula provides the exact ground truth against which we will compare the numerical methods.\n\n#### 2. Composite Trapezoidal Rule ($W_{\\text{trap}}$)\nThis rule approximates the integral by summing the areas of trapezoids formed under the curve in each subinterval. The integration interval $[a, b]$ is divided into $n$ uniform subintervals $[x_i, x_{i+1}]$ for $i = 0, 1, \\dots, n-1$, each of width $h = (b-a)/n$.\n\n**First Principles Derivation:**\nOn a single subinterval $[x_i, x_{i+1}]$, we approximate the function $F(x)$ by a linear polynomial (a straight line) $P_1(x)$ that passes through the points $(x_i, F(x_i))$ and $(x_{i+1}, F(x_{i+1}))$. The integral of this linear interpolant is the area of the trapezoid formed by these points and the x-axis:\n$$\n\\int_{x_i}^{x_{i+1}} F(x) \\,dx \\approx \\int_{x_i}^{x_{i+1}} P_1(x) \\,dx = \\frac{1}{2} (F(x_i) + F(x_{i+1})) (x_{i+1} - x_i) = \\frac{h}{2} (F(x_i) + F(x_{i+1}))\n$$\nThe composite rule sums these approximations over all $n$ subintervals:\n$$\nW_{\\text{trap}} = \\sum_{i=0}^{n-1} \\frac{h}{2} (F(x_i) + F(x_{i+1}))\n$$\nExpanding and collecting terms:\n$$\nW_{\\text{trap}} = \\frac{h}{2} [ (F(x_0) + F(x_1)) + (F(x_1) + F(x_2)) + \\dots + (F(x_{n-1}) + F(x_n)) ]\n$$\n$$\nW_{\\text{trap}} = \\frac{h}{2} [ F(x_0) + 2F(x_1) + 2F(x_2) + \\dots + 2F(x_{n-1}) + F(x_n) ]\n$$\nThis can be written more compactly for implementation:\n$$\nW_{\\text{trap}} = h \\left( \\frac{F(x_0) + F(x_n)}{2} + \\sum_{i=1}^{n-1} F(x_i) \\right)\n$$\n\n#### 3. Composite Simpson's Rule ($W_{\\text{simp}}$)\nThis rule offers higher accuracy by using a quadratic approximation. It requires an even number of subintervals, $n$. The rule works by considering pairs of subintervals, i.e., panels of width $2h$ like $[x_i, x_{i+2}]$.\n\n**First Principles Derivation:**\nOn a single panel $[x_{2j-2}, x_{2j}]$ (for $j = 1, \\dots, n/2$), we approximate $F(x)$ with a quadratic polynomial $P_2(x)$ that interpolates the function at three points: $(x_{2j-2}, F(x_{2j-2}))$, $(x_{2j-1}, F(x_{2j-1}))$, and $(x_{2j}, F(x_{2j}))$.\nTo find the integral of $P_2(x)$, we can shift the interval to $[-h, h]$ for simplicity (letting $z = x - x_{2j-1}$). The integral of the quadratic interpolant over this interval gives the well-known Simpson's 1/3 rule formula for a single panel:\n$$\n\\int_{x_{2j-2}}^{x_{2j}} F(x) \\,dx \\approx \\int_{-h}^{h} P_2(z) \\,dz = \\frac{h}{3} (F(x_{2j-2}) + 4F(x_{2j-1}) + F(x_{2j}))\n$$\nThe composite rule sums these approximations over all $n/2$ panels:\n$$\nW_{\\text{simp}} = \\sum_{j=1}^{n/2} \\frac{h}{3} (F(x_{2j-2}) + 4F(x_{2j-1}) + F(x_{2j}))\n$$\nExpanding this sum reveals a pattern of weights for the function evaluations:\n$$\nW_{\\text{simp}} = \\frac{h}{3} [ (F(x_0) + 4F(x_1) + F(x_2)) + (F(x_2) + 4F(x_3) + F(x_4)) + \\dots + (F(x_{n-2}) + 4F(x_{n-1}) + F(x_n)) ]\n$$\nThe interior points with even indices (e.g., $F(x_2)$) are counted twice, while those with odd indices are counted once (with a multiplier of $4$). Collecting terms yields the final formula:\n$$\nW_{\\text{simp}} = \\frac{h}{3} [ F(x_0) + 4F(x_1) + 2F(x_2) + 4F(x_3) + \\dots + 2F(x_{n-2}) + 4F(x_{n-1}) + F(x_n) ]\n$$\nThis can be implemented by summing the odd-indexed and even-indexed terms separately:\n$$\nW_{\\text{simp}} = \\frac{h}{3} \\left( F(x_0) + F(x_n) + 4 \\sum_{i=1, i \\text{ odd}}^{n-1} F(x_i) + 2 \\sum_{i=2, i \\text{ even}}^{n-2} F(x_i) \\right)\n$$\nA crucial property of Simpson's rule is that it is exact for any polynomial of degree $3$ or less. Since our force function $F(x) = kx + \\alpha x^3$ is a cubic polynomial, the error term for Simpson's rule, which depends on the fourth derivative of $F(x)$, is zero. ($F^{(4)}(x) = 0$). Therefore, the composite Simpson's rule will calculate the exact work, $W_{\\text{simp}} = W_{\\text{exact}}$, and the error $e_{\\text{simp}}$ will be zero (or within machine floating-point precision of zero).\n\n#### 4. Absolute Error Calculation\nThe absolute errors for the trapezoidal ($e_{\\text{trap}}$) and Simpson ($e_{\\text{simp}}$) rules are calculated by taking the absolute difference between the numerical approximation and the exact value:\n$$\ne_{\\text{trap}} = \\lvert W_{\\text{trap}} - W_{\\text{exact}} \\rvert\n$$\n$$\ne_{\\text{simp}} = \\lvert W_{\\text{simp}} - W_{\\text{exact}} \\rvert\n$$\n\nThe implementation will proceed by coding these derived formulas for each test case.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes exact work, composite trapezoidal and Simpson's rule approximations,\n    and their absolute errors for a nonlinear spring system.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (k, alpha, a, b, n)\n        (100.0, 2000.0, 0.0, 0.2, 20),\n        (250.0, 0.0, 0.0, 0.3, 12),\n        (50.0, -500.0, 0.0, 0.25, 10),\n        (120.0, 8000.0, 0.05, 0.18, 2),\n    ]\n\n    results = []\n    for k, alpha, a, b, n in test_cases:\n        # Define the force function F(x) = kx + alpha*x^3\n        def F(x):\n            return k * x + alpha * x**3\n\n        # 1. Exact Work Calculation (W_exact)\n        # The analytical integral of F(x) is (k/2)*x^2 + (alpha/4)*x^4.\n        work_exact = (k / 2.0 * b**2 + alpha / 4.0 * b**4) - \\\n                     (k / 2.0 * a**2 + alpha / 4.0 * a**4)\n\n        # Set up the uniform partition for numerical integration\n        h = (b - a) / n\n        x = np.linspace(a, b, n + 1)\n        y = F(x)\n\n        # 2. Composite Trapezoidal Rule (W_trap)\n        # Formula: h * [ (y_0 + y_n)/2 + sum(y_i for i=1 to n-1) ]\n        if n > 0:\n            work_trap = h * (0.5 * y[0] + np.sum(y[1:-1]) + 0.5 * y[-1])\n        else: # Handle n=0 case, though not in test data\n            work_trap = 0.0\n\n        # 3. Composite Simpson's Rule (W_simp)\n        # Formula: (h/3) * [ y_0 + 4*sum(odd_indices) + 2*sum(even_indices) + y_n ]\n        # This rule requires n to be even, which is true for all test cases.\n        if n % 2 == 0 and n > 0:\n            sum_odd_indices = np.sum(y[1:-1:2])\n            sum_even_indices = np.sum(y[2:-1:2])\n            work_simp = (h / 3.0) * (y[0] + 4.0 * sum_odd_indices + 2.0 * sum_even_indices + y[-1])\n        else:\n            # Not applicable for odd n, but handle for completeness\n            work_simp = float('nan') \n\n        # 4. Absolute Error Calculations\n        error_trap = abs(work_trap - work_exact)\n        error_simp = abs(work_simp - work_exact)\n\n        # Append the 5-tuple of results for the current case.\n        results.append([work_exact, work_trap, work_simp, error_trap, error_simp])\n\n    # Final print statement in the exact required format.\n    # [[case1],[case2],[case3],[case4]] with no spaces.\n    case_strings = [f'[{\",\".join(map(str, res))}]' for res in results]\n    print(f'[{\",\".join(case_strings)}]')\n\nsolve()\n```"
        },
        {
            "introduction": "Numerical analysis often involves developing an intuition for which methods work best, but it's equally important to understand the limits of that intuition. This exercise serves as a crucial stress test, presenting a carefully constructed scenario where the higher-order Simpson's rule is surprisingly less accurate than the simpler trapezoidal rule. By working through this counterexample involving a function with low smoothness, you will develop a deeper appreciation for the theoretical assumptions, particularly regarding the role of higher-order derivatives, that underpin the performance guarantees of numerical methods .",
            "id": "3258564",
            "problem": "Consider closed Newton–Cotes quadrature rules applied to a continuous function. Define the continuous function $f:[0,2]\\to\\mathbb{R}$ by\n$$\nf(x)=\n\\begin{cases}\n0, & 0 \\le x \\le 0.9, \\\\\n100(x-0.9), & 0.9 < x \\le 1, \\\\\n100(1.1-x), & 1 < x \\le 1.1, \\\\\n0, & 1.1 < x \\le 2.\n\\end{cases}\n$$\nLet $I=\\int_{0}^{2} f(x)\\,dx$ be the exact integral. Using the standard composite trapezoidal rule and the standard composite Simpson’s rule, each with $N=2$ equal subintervals on $[0,2]$, compute their approximations to $I$. Then compute the absolute errors $E_{T}=\\left|T-I\\right|$ and $E_{S}=\\left|S-I\\right|$, where $T$ and $S$ denote the composite trapezoidal and composite Simpson approximations, respectively. Finally, provide the exact value of the ratio $\\left|E_{S}\\right|/\\left|E_{T}\\right|$ to demonstrate a case where Simpson’s rule is less accurate than the trapezoidal rule at this resolution. Express your final answer as an exact rational number. No rounding is required.",
            "solution": "The problem asks for the ratio of absolute errors, $|E_S|/|E_T|$, for the composite Simpson's and trapezoidal rules applied to a specific piecewise linear function $f(x)$ on the interval $[0,2]$ with $N=2$ subintervals.\n\n**Step 1: Calculate the Exact Integral $I$**\n\nThe function $f(x)$ is non-zero only on the interval $(0.9, 1.1)$. The graph of $f(x)$ over this interval forms a triangle with its base on the x-axis.\n- **Base of the triangle:** $1.1 - 0.9 = 0.2$\n- **Height of the triangle:** The peak occurs at $x=1$. $f(1) = 100(1-0.9) = 10$.\nThe exact integral $I$ is the area of this triangle:\n$$\nI = \\int_{0}^{2} f(x)\\,dx = \\frac{1}{2} \\times \\text{base} \\times \\text{height} = \\frac{1}{2} \\times 0.2 \\times 10 = 1\n$$\n\n**Step 2: Calculate the Composite Trapezoidal Approximation $T$**\n\nThe interval $[0,2]$ is divided into $N=2$ subintervals, which are $[0,1]$ and $[1,2]$. The step size is $h = (2-0)/2 = 1$. The nodes are $x_0=0, x_1=1, x_2=2$.\nThe composite trapezoidal rule is the sum of the areas of the trapezoids over each subinterval:\n$$\nT = \\frac{h}{2}[f(x_0) + f(x_1)] + \\frac{h}{2}[f(x_1) + f(x_2)] = \\frac{h}{2}[f(x_0) + 2f(x_1) + f(x_2)]\n$$\nWe evaluate the function at the nodes:\n- $f(x_0) = f(0) = 0$\n- $f(x_1) = f(1) = 10$\n- $f(x_2) = f(2) = 0$\nSubstituting these values:\n$$\nT = \\frac{1}{2}[0 + 2(10) + 0] = 10\n$$\n\n**Step 3: Calculate the Absolute Error $E_T$**\n$$\nE_T = |T - I| = |10 - 1| = 9\n$$\n\n**Step 4: Calculate the Composite Simpson's Approximation $S$**\n\nFor $N=2$ subintervals, the composite Simpson's rule is equivalent to one application of the basic Simpson's 1/3 rule over the entire interval $[0,2]$. The step size for the formula is $h = (b-a)/N = (2-0)/2 = 1$. The three nodes are the same: $x_0=0, x_1=1, x_2=2$.\nThe formula is:\n$$\nS = \\frac{h}{3}[f(x_0) + 4f(x_1) + f(x_2)]\n$$\nSubstituting the function values:\n$$\nS = \\frac{1}{3}[0 + 4(10) + 0] = \\frac{40}{3}\n$$\n\n**Step 5: Calculate the Absolute Error $E_S$**\n$$\nE_S = |S - I| = \\left|\\frac{40}{3} - 1\\right| = \\left|\\frac{40}{3} - \\frac{3}{3}\\right| = \\frac{37}{3}\n$$\n\n**Step 6: Compute the Final Ratio**\n\nFinally, we compute the ratio of the absolute errors:\n$$\n\\frac{|E_S|}{|E_T|} = \\frac{E_S}{E_T} = \\frac{37/3}{9} = \\frac{37}{27}\n$$\nThis result demonstrates that for this function with low smoothness (it is not differentiable at several points), the higher-order Simpson's rule can be less accurate than the simpler trapezoidal rule for a coarse partition. The error bounds for Simpson's rule rely on the fourth derivative of the function, which does not exist here.",
            "answer": "$$\n\\boxed{\\frac{37}{27}}\n$$"
        },
        {
            "introduction": "While uniform grids are simple to implement, they are often inefficient for functions whose behavior varies significantly across the integration domain. This practice moves from fixed-step methods to a more powerful and practical approach known as adaptive quadrature, which is central to modern scientific software. You will implement an adaptive Simpson's method to integrate a function with a sharp peak, demonstrating how an algorithm that intelligently concentrates computational effort can achieve high accuracy with far fewer function evaluations than a uniform grid .",
            "id": "3214881",
            "problem": "Consider the numerical evaluation of the definite integral of the function $f(x) = \\exp\\left(-100(x - 0.3)^2\\right)$ on the interval $[0,1]$. The task is to implement two composite numerical integration methods based on the Simpson rule and to compare their accuracy and computational effort:\n\n1. A uniform composite Simpson method over a partition of $[0,1]$ into $N$ equal subintervals, where $N$ is an even integer. If an odd $N$ is supplied, the implementation must increase it by $1$ so that the rule is applicable.\n\n2. An adaptive composite Simpson method with local error control, which recursively subdivides an interval until a specified local absolute tolerance $\\text{tol}$ is met. Local error control must be enforced by comparing the Simpson approximation on an interval with the sum of Simpson approximations on its two halves, and by distributing the tolerance across subintervals in a manner that ensures a globally controlled absolute error.\n\nThe implementation should build from the following fundamental base:\n\n- Polynomial interpolation: approximate a sufficiently smooth function on an interval by a quadratic interpolant through three points and integrate the interpolant exactly.\n- Error behavior of composite polynomial-based quadrature: for sufficiently smooth $f$, the Simpson rule has a truncation error that scales with the fifth power of the interval length for a single panel and yields a fourth-order global convergence rate when applied uniformly.\n\nCompute the true value of the integral using the known antiderivative of a Gaussian function, expressed in terms of the error function, and use it as the ground truth for error calculation.\n\nFor each method, report:\n- The absolute error with respect to the true integral.\n- The number of function evaluations used.\n\nThe program must implement both methods and run the following test suite, where each test case is a pair $(\\text{tol}, N)$:\n\n- Test case 1 (happy path): $\\text{tol} = 10^{-6}$, $N = 100$.\n- Test case 2 (tighter tolerance, finer grid): $\\text{tol} = 10^{-8}$, $N = 1000$.\n- Test case 3 (looser tolerance, coarse grid): $\\text{tol} = 10^{-4}$, $N = 10$.\n- Test case 4 (edge case with minimal uniform panels): $\\text{tol} = 10^{-10}$, $N = 2$.\n- Test case 5 (very strict tolerance): $\\text{tol} = 10^{-12}$, $N = 200$.\n\nYour program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each element of this list corresponds to one test case and must itself be a list of four values in the following order: $[\\text{abs\\_error\\_adaptive}, \\text{evals\\_adaptive}, \\text{abs\\_error\\_uniform}, \\text{evals\\_uniform}]$. For example, an output for two cases would have the form $[[e_1,c_1,E_1,C_1],[e_2,c_2,E_2,C_2]]$.\n\nNo physical units are involved in this problem, and no angles or percentages are required. The final output values must be real numbers or integers, as appropriate, without any additional text.",
            "solution": "The user has provided a valid problem statement.\n\n### Step 1: Extract Givens\n- **Function to integrate**: $f(x) = \\exp\\left(-100(x - 0.3)^2\\right)$\n- **Interval of integration**: $[0, 1]$\n- **Method 1**: Uniform composite Simpson's rule with $N$ equal subintervals. If $N$ is odd, it must be incremented by $1$.\n- **Method 2**: Adaptive composite Simpson's rule with a local absolute tolerance $\\text{tol}$. Local error is to be estimated by comparing a one-panel Simpson rule approximation ($S_1$) with a two-panel approximation ($S_2$) over the same interval.\n- **True Value**: To be computed using the error function, $\\text{erf}(x)$.\n- **Outputs for each method**: Absolute error with respect to the true value and the total number of function evaluations.\n- **Test Suite**: A series of test cases, each defined by a pair $(\\text{tol}, N)$:\n    1. $(\\text{tol} = 10^{-6}, N = 100)$\n    2. $(\\text{tol} = 10^{-8}, N = 1000)$\n    3. $(\\text{tol} = 10^{-4}, N = 10)$\n    4. $(\\text{tol} = 10^{-10}, N = 2)$\n    5. $(\\text{tol} = 10^{-12}, N = 200)$\n- **Output Format**: A single line of text: `[[abs_error_adaptive, evals_adaptive, abs_error_uniform, evals_uniform], ...]` for all test cases.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is assessed as **valid**.\n\n- **Scientifically Grounded**: The problem is a standard exercise in numerical analysis, dealing with the implementation and comparison of well-established quadrature rules (composite Simpson's rule, adaptive quadrature). The function is a Gaussian, which is analytic and thus infinitely differentiable ($C^\\infty$), making it an ideal candidate for high-order integration methods. The method for calculating the true value via the error function is mathematically sound.\n- **Well-Posed**: The problem is clearly defined. The function, interval, methods, and parameters are all specified. For each test case, a unique numerical result can be computed.\n- **Objective**: The language is precise and devoid of subjective or ambiguous terminology.\n- **Completeness and Consistency**: The problem is self-contained. All necessary information to implement the solution and run the tests is provided. There are no internal contradictions.\n- **Feasibility**: The required computations are standard and computationally feasible.\n\n### Step 3: Verdict and Action\nThe problem is valid. A complete solution will be developed.\n\n### Principle-Based Solution\nThe task is to evaluate the definite integral $I = \\int_0^1 f(x) \\,dx$ for $f(x) = \\exp\\left(-100(x - 0.3)^2\\right)$ using two variants of the composite Simpson's rule and compare their efficiency.\n\n**1. True Value of the Integral**\n\nThe integral of a Gaussian function can be expressed in terms of the error function, $\\text{erf}(z) = \\frac{2}{\\sqrt{\\pi}} \\int_0^z e^{-t^2} \\,dt$.\nLet $I = \\int_0^1 \\exp\\left(-100(x - 0.3)^2\\right) \\,dx$.\nWe perform a change of variables. Let $u = \\sqrt{100}(x - 0.3) = 10(x - 0.3)$. This implies $du = 10 \\,dx$, or $dx = \\frac{1}{10} \\,du$.\nThe limits of integration for $u$ are:\n- When $x = 0$, $u = 10(0 - 0.3) = -3$.\n- When $x = 1$, $u = 10(1 - 0.3) = 7$.\n\nThe integral becomes:\n$$ I = \\int_{-3}^{7} e^{-u^2} \\frac{1}{10} \\,du = \\frac{1}{10} \\int_{-3}^{7} e^{-u^2} \\,du $$\nUsing the definition of the error function:\n$$ \\int_a^b e^{-t^2} \\,dt = \\int_0^b e^{-t^2} \\,dt - \\int_0^a e^{-t^2} \\,dt = \\frac{\\sqrt{\\pi}}{2} \\left[ \\text{erf}(b) - \\text{erf}(a) \\right] $$\nWith $a = -3$ and $b = 7$, we get:\n$$ I = \\frac{1}{10} \\left[ \\frac{\\sqrt{\\pi}}{2} (\\text{erf}(7) - \\text{erf}(-3)) \\right] $$\nUsing the property $\\text{erf}(-z) = -\\text{erf}(z)$, the true value is:\n$$ I_{true} = \\frac{\\sqrt{\\pi}}{20} \\left[ \\text{erf}(7) + \\text{erf}(3) \\right] $$\nThis value will serve as our ground truth for calculating the absolute error of the numerical methods.\n\n**2. Uniform Composite Simpson's Rule**\n\nSimpson's rule approximates the integral of a function $f(x)$ over an interval $[a, b]$ by integrating a quadratic interpolant through the points $(a, f(a))$, $((a+b)/2, f((a+b)/2))$, and $(b, f(b))$. The formula is:\n$$ S(a, b) = \\frac{b-a}{6} \\left[ f(a) + 4f\\left(\\frac{a+b}{2}\\right) + f(b) \\right] $$\nThe composite Simpson's rule applies this formula over a partition of the integration interval. For a uniform partition of $[a, b]$ into $N$ subintervals of equal width $h = (b-a)/N$ (where $N$ must be an even integer), the points are $x_i = a + ih$ for $i = 0, 1, \\dots, N$. The integral is approximated by:\n$$ S_N = \\frac{h}{3} \\left[ f(x_0) + 4\\sum_{i=1, i \\text{ odd}}^{N-1} f(x_i) + 2\\sum_{i=2, i \\text{ even}}^{N-2} f(x_i) + f(x_N) \\right] $$\nThe number of function evaluations for this method is $N+1$. As per the problem, if an odd $N$ is given, it is incremented to $N+1$, making the number of evaluations $N+2$.\n\n**3. Adaptive Composite Simpson's Rule**\n\nAdaptive quadrature methods adjust the density of evaluation points based on the local behavior of the integrand. The function $f(x)$ has a sharp peak around $x=0.3$ and is nearly zero elsewhere, making it a prime candidate for an adaptive approach. The method works as follows:\n\nFor an interval $[a, b]$, we compute two approximations:\n- A \"coarse\" approximation, $S_1$, using a single Simpson panel over $[a, b]$.\n- A \"fine\" approximation, $S_2$, by summing two Simpson panels over the half-intervals $[a, m]$ and $[m, b]$, where $m = (a+b)/2$.\n\nThe error of the single-panel Simpson rule on an interval of width $h=b-a$ is approximately $E_1 \\approx -\\frac{h^5}{2880} f^{(4)}(\\xi)$. The error of the two-panel approximation is $E_2 \\approx 2 \\times \\left(-\\frac{(h/2)^5}{2880} f^{(4)}(\\eta)\\right) \\approx \\frac{1}{16} E_1$.\nThe true integral $I$ can be written as $I = S_1 + E_1$ and $I = S_2 + E_2$.\nAssuming $f^{(4)}$ is nearly constant over $[a, b]$, we can establish a relationship between the approximations and the error of the finer one, $E_2$:\n$$ S_2 - S_1 \\approx E_1 - E_2 \\approx 16 E_2 - E_2 = 15 E_2 $$\nThus, an estimate for the local error in $S_2$ is $\\text{err} \\approx \\frac{|S_2 - S_1|}{15}$.\n\nThe adaptive algorithm is recursive:\n1.  For a given interval $[a, b]$ and local tolerance $\\text{tol}_{local}$, compute $S_1$ and $S_2$.\n2.  Calculate the error estimate $\\text{err} = \\frac{|S_2 - S_1|}{15}$.\n3.  If $\\text{err} < \\text{tol}_{local}$, the interval is sufficiently resolved. We accept the result and, to improve accuracy, return the Richardson-extrapolated value $I_{[a,b]} = S_2 + \\frac{S_2 - S_1}{15}$. This is a more accurate estimate of the integral over the interval.\n4.  If $\\text{err} \\ge \\text{tol}_{local}$, the interval is not resolved. Subdivide it into $[a, m]$ and $[m, b]$. Recursively call the algorithm on each sub-interval, but with the tolerance halved for each: $\\text{tol}_{local}/2$. The total integral is the sum of the results from the two recursive calls.\n\nTo ensure global error control, the tolerance is distributed proportionally to the interval widths. The initial call is made with the global tolerance $\\text{tol}$. Each recursive step on a half-interval uses half the tolerance of its parent.\n\nTo avoid redundant computations, function values at endpoints and midpoints are passed down through the recursion. A recursive step on $[a, b]$ with known $f(a)$, $f((a+b)/2)$, and $f(b)$ only needs to compute two new values: $f((a+m)/2)$ and $f((m+b)/2)$. The total number of function evaluations is tracked throughout the recursion.\n\nThis adaptive strategy concentrates computational effort on the region around the peak of the Gaussian ($x \\approx 0.3$), where the function changes rapidly, and uses very few evaluations in the flat regions near $x=0$ and $x=1$, leading to high efficiency.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Implements and compares uniform and adaptive Simpson's rule for integrating\n    a Gaussian function, then runs a suite of test cases.\n    \"\"\"\n    \n    # 1. Define the function to integrate\n    def f(x):\n        return np.exp(-100.0 * (x - 0.3)**2)\n\n    # 2. Calculate the \"true\" value of the integral using the error function\n    # I = integral from 0 to 1 of exp(-100*(x-0.3)^2) dx\n    # Let u = 10*(x-0.3), so du = 10*dx.\n    # Limits: x=0 -> u=-3; x=1 -> u=7.\n    # I = (1/10) * integral from -3 to 7 of exp(-u^2) du\n    # Using erf(z) = (2/sqrt(pi)) * integral from 0 to z of exp(-t^2) dt\n    # Integral from a to b = sqrt(pi)/2 * (erf(b) - erf(a))\n    # I = (1/10) * sqrt(pi)/2 * (erf(7) - erf(-3))\n    #   = (sqrt(pi)/20) * (erf(7) + erf(3))\n    true_value = (math.sqrt(math.pi) / 20.0) * (math.erf(7.0) + math.erf(3.0))\n\n    # 3. Uniform Composite Simpson's Rule Implementation\n    def uniform_simpson(func, a, b, N):\n        \"\"\"\n        Calculates the definite integral using the uniform composite Simpson's rule.\n        \n        Args:\n            func: The function to integrate.\n            a, b: The interval of integration.\n            N: The number of subintervals (must be even, adjusted if not).\n            \n        Returns:\n            A tuple (integral_value, num_evaluations).\n        \"\"\"\n        if N % 2 != 0:\n            N += 1\n        \n        h = (b - a) / float(N)\n        x = np.linspace(a, b, N + 1)\n        y = func(x)\n        \n        # Simpson's formula: h/3 * (y0 + 4y1 + 2y2 + ... + 4y(N-1) + yN)\n        # Slicing: y[1:-1:2] gets odd indices, y[2:-2:2] gets even indices.\n        integral = (h / 3.0) * (y[0] + 4.0 * np.sum(y[1:-1:2]) + 2.0 * np.sum(y[2:-2:2]) + y[-1])\n        \n        evals = N + 1\n        return integral, evals\n\n    # 4. Adaptive Composite Simpson's Rule Implementation\n    def adaptive_simpson(func, a, b, tol):\n        \"\"\"\n        Wrapper for the recursive adaptive Simpson's rule integrator.\n        \n        Args:\n            func: The function to integrate.\n            a, b: The interval of integration.\n            tol: The desired absolute error tolerance.\n            \n        Returns:\n            A tuple (integral_value, num_evaluations).\n        \"\"\"\n        \n        eval_count = [0] # Use a list as a mutable counter\n\n        def f_counted(x):\n            eval_count[0] += 1\n            return func(x)\n        \n        # Initial function evaluations\n        fa = f_counted(a)\n        fm = f_counted((a + b) / 2.0)\n        fb = f_counted(b)\n        \n        integral = _adaptive_simpson_recursive(f_counted, a, b, tol, fa, fm, fb)\n        \n        return integral, eval_count[0]\n\n    def _adaptive_simpson_recursive(func, a, b, tol, fa, fm, fb):\n        \"\"\"Recursive helper for adaptive Simpson's rule.\"\"\"\n        h = b - a\n        m = (a + b) / 2.0\n        \n        # Coarse approximation (1 panel)\n        s1 = (h / 6.0) * (fa + 4.0 * fm + fb)\n        \n        # Finer approximation (2 panels) requires 2 new function evaluations\n        ml = (a + m) / 2.0\n        mr = (m + b) / 2.0\n        fml = func(ml)\n        fmr = func(mr)\n        \n        s2 = (h / 12.0) * (fa + 4.0 * fml + 2.0 * fm + 4.0 * fmr + fb)\n        \n        # Error estimation: |(S2 - S1) / 15| is an estimate of the error in S2.\n        error_estimate = abs(s2 - s1) / 15.0\n        \n        if error_estimate < tol:\n            # Richardson extrapolation for a more accurate result\n            return s2 + (s2 - s1) / 15.0\n        else:\n            # Subdivide and recurse, distributing tolerance\n            left_integral = _adaptive_simpson_recursive(func, a, m, tol / 2.0, fa, fml, fm)\n            right_integral = _adaptive_simpson_recursive(func, m, b, tol / 2.0, fm, fmr, fb)\n            return left_integral + right_integral\n\n    # 5. Define test cases\n    test_cases = [\n        (1e-6, 100),\n        (1e-8, 1000),\n        (1e-4, 10),\n        (1e-10, 2),\n        (1e-12, 200),\n    ]\n\n    all_results = []\n\n    # 6. Run the test suite\n    for tol, N in test_cases:\n        # Run adaptive method\n        res_adaptive, evals_adaptive = adaptive_simpson(f, 0.0, 1.0, tol)\n        error_adaptive = abs(res_adaptive - true_value)\n\n        # Run uniform method\n        res_uniform, evals_uniform = uniform_simpson(f, 0.0, 1.0, N)\n        error_uniform = abs(res_uniform - true_value)\n        \n        # Store results for this test case\n        case_result = [error_adaptive, evals_adaptive, error_uniform, evals_uniform]\n        all_results.append(case_result)\n\n    # 7. Format and print the final output\n    # The output format must be exact: [[v1,v2,v3,v4],[v5,v6,v7,v8]] with no spaces.\n    # repr() gives the correct bracket/comma structure, and .replace removes spaces.\n    output_str = repr(all_results).replace(' ', '')\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}