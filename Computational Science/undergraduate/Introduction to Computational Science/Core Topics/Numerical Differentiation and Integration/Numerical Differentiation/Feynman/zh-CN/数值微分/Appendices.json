{
    "hands_on_practices": [
        {
            "introduction": "第一个练习旨在通过介绍三种基本的有限差分近似——前向、后向和中心差分——来为后续学习奠定基础。通过将这些公式应用于一个已知函数，你将定量地比较它们在给定步长下的绝对误差。这个练习旨在让你具体地感受到为何中心差分格式因其更高的精度阶而通常是首选方法。",
            "id": "2191753",
            "problem": "考虑函数 $f(x) = x \\exp(-x)$。我们想要近似其在点 $x_0 = 1$ 处的导数 $f'(x)$。近似的质量由其绝对误差来衡量，绝对误差定义为近似值与导数真值之间的绝对差。\n\n您需要比较三种常用的有限差分公式来近似导数：\n1.  **前向差分近似**：$D_f(x_0, h) = \\frac{f(x_0+h) - f(x_0)}{h}$\n2.  **后向差分近似**：$D_b(x_0, h) = \\frac{f(x_0) - f(x_0-h)}{h}$\n3.  **中心差分近似**：$D_c(x_0, h) = \\frac{f(x_0+h) - f(x_0-h)}{2h}$\n\n设 $E_f$、$E_b$ 和 $E_c$ 分别是当步长 $h = 0.1$ 时，对应于前向、后向和中心差分近似的绝对误差。\n\n计算比值 $R = \\frac{E_f + E_b}{E_c}$ 的值。将您的最终答案四舍五入到三位有效数字。",
            "solution": "我们从 $f(x) = x \\exp(-x)$ 开始。其导数可以通过乘法法则得到：\n$$\nf'(x) = \\exp(-x) + x \\frac{d}{dx}\\big(\\exp(-x)\\big) = \\exp(-x) - x \\exp(-x) = \\exp(-x)\\,(1 - x).\n$$\n在 $x_{0} = 1$ 处，这得到\n$$\nf'(1) = \\exp(-1)\\,(1 - 1) = 0.\n$$\n因此，对于任何有限差分近似 $D$，在 $x_{0}=1$ 处的绝对误差就是该近似值的绝对值：\n$$\nE_{f} = |D_{f}(1,h)|,\\quad E_{b} = |D_{b}(1,h)|,\\quad E_{c} = |D_{c}(1,h)|.\n$$\n\n当 $h = 0.1$ 时，使用 $f(x) = x \\exp(-x)$ 计算三种有限差分：\n- 前向差分：\n$$\nD_{f}(1,h) = \\frac{f(1+h) - f(1)}{h} = \\frac{(1.1)\\exp(-1.1) - \\exp(-1)}{0.1}.\n$$\n- 后向差分：\n$$\nD_{b}(1,h) = \\frac{f(1) - f(1-h)}{h} = \\frac{\\exp(-1) - (0.9)\\exp(-0.9)}{0.1}.\n$$\n- 中心差分：\n$$\nD_{c}(1,h) = \\frac{f(1+h) - f(1-h)}{2h} = \\frac{(1.1)\\exp(-1.1) - (0.9)\\exp(-0.9)}{0.2}.\n$$\n\n通过将 $\\exp(-1.1) = \\exp(-1)\\exp(-0.1)$ 和 $\\exp(-0.9) = \\exp(-1)\\exp(0.1)$ 写成，来提出因子 $\\exp(-1)$。定义 $t = \\exp(0.1)$，因此 $\\exp(-0.1) = 1/t$。然后\n$$\nD_{f}(1,h) = \\frac{\\exp(-1)}{0.1}\\left(1.1\\,\\frac{1}{t} - 1 \\right),\\quad\nD_{b}(1,h) = \\frac{\\exp(-1)}{0.1}\\left(1 - 0.9\\,t \\right),\n$$\n$$\nD_{c}(1,h) = \\frac{\\exp(-1)}{0.2}\\left(1.1\\,\\frac{1}{t} - 0.9\\,t \\right).\n$$\n设\n$$\nA = 1.1\\,\\frac{1}{t} - 1,\\quad B = 1 - 0.9\\,t,\\quad C = 1.1\\,\\frac{1}{t} - 0.9\\,t.\n$$\n那么\n$$\nE_{f} = \\frac{\\exp(-1)}{0.1}\\,|A|,\\quad E_{b} = \\frac{\\exp(-1)}{0.1}\\,|B|,\\quad E_{c} = \\frac{\\exp(-1)}{0.2}\\,|C|.\n$$\n因此，该比值简化为\n$$\nR = \\frac{E_{f} + E_{b}}{E_{c}} = \\frac{\\frac{\\exp(-1)}{0.1}(|A|+|B|)}{\\frac{\\exp(-1)}{0.2}|C|} = 2\\,\\frac{|A|+|B|}{|C|}.\n$$\n\n数值上，当 $t = \\exp(0.1) \\approx 1.1051701859880927$ 且 $1/t = \\exp(-0.1) \\approx 0.9048374180359596$ 时，\n$$\nA = 1.1\\cdot 0.9048374180359596 - 1 \\approx -0.00467884016044447,\\quad |A| \\approx 0.00467884016044447,\n$$\n$$\nB = 1 - 0.9\\cdot 1.1051701859880927 \\approx 0.00534683261071661,\\quad |B| \\approx 0.00534683261071661,\n$$\n$$\nC = 1.1\\cdot 0.9048374180359596 - 0.9\\cdot 1.1051701859880927 \\approx 0.000667992450272143,\\quad |C| \\approx 0.000667992450272143.\n$$\n因此，\n$$\nR = 2\\,\\frac{0.00467884016044447 + 0.00534683261071661}{0.000667992450272143} \\approx \\frac{0.02005134554232216}{0.000667992450272143} \\approx 30.0173.\n$$\n四舍五入到三位有效数字，\n$$\nR \\approx 30.0\n$$",
            "answer": "$$\\boxed{30.0}$$"
        },
        {
            "introduction": "从纯理论转向实际计算，这个问题将解决数值微分中最关键的挑战：步长 $h$ 的选择。利用一个金融领域的债券定价模型，你将分析截断误差（随 $h$ 减小而减小）与舍入误差（因灾难性抵消而随 $h$ 减小而增大）之间的权衡。这个练习将帮助你理解如何从理论上对这种权衡进行建模，以找到一个最优的步长。",
            "id": "2415137",
            "problem": "考虑一个固定票息债券的连续复利价格，作为连续复利收益率 $y$ 的函数：\n$$\nP(y) \\;=\\; \\sum_{k=1}^{N} c_k \\, e^{-y t_k},\n$$\n其中 $t_k$ 是支付时间（以年为单位），$c_k$ 是相应的现金流。设债券的面值为 $F=100$，年票息率为 $c=0.05$，期限为 $T=10$ 年，每半年付息一次 ($m=2$)，因此 $N=mT=20$，$t_k = k/m$ 对于 $k=1,\\ldots,20$，$c_k = 2.5$ 对于 $k=1,\\ldots,19$，以及 $c_{20} = 102.5$。设 $y_0 = 0.03$。\n\n假设您使用向前差分公式来估计导数 $P'(y_0)$\n$$\nD_h \\;=\\; \\frac{P(y_0 + h) - P(y_0)}{h},\n$$\n计算在标准双精度浮点运算中进行，其模型为每次算术运算的相对误差界 $|\\delta|\\le \\epsilon_{mach}$，其中 $\\epsilon_{mach} \\approx 1.11 \\times 10^{-16}$。\n\n下列哪些陈述是正确的？选择所有适用的选项。\n\nA. 对于足够小的 $h$，由于对两个相近的数进行相减（这种现象被称为灾难性抵消），$D_h$ 中的主要浮点舍入误差表现为 $O\\!\\left(\\dfrac{\\epsilon_{mach}\\,|P(y_0)|}{h}\\right)$。\n\nB. 向前差分近似 $D_h$ 的截断误差为 $O(h^2)$，其主项系数取决于 $P^{(3)}(y_0)$。\n\nC. 平衡主截断误差和舍入误差，可以得到形式为 $h^* \\asymp \\sqrt{\\dfrac{\\epsilon_{mach}\\,|P(y_0)|}{|P''(y_0)|}}$ 的渐近最优步长。\n\nD. 对于在 $y_0=0.03$ 处的指定债券，在双精度下 $\\epsilon_{mach} \\approx 1.11 \\times 10^{-16}$，使主阶总误差最小化的 $h^*$ 的数量级最接近 $10^{-9}$。\n\nE. 改用中心差分求导将完全消除所有 $h$ 的灾难性抵消。",
            "solution": "我们从基本原理开始：向前差分公式定义为\n$$\nD_h \\;=\\; \\frac{P(y_0+h)-P(y_0)}{h}.\n$$\n根据关于 $y_0$ 的泰勒定理，对于某个在 $y_0$ 和 $y_0+h$ 之间的 $\\xi$，\n$$\nP(y_0+h) \\;=\\; P(y_0) \\;+\\; h\\,P'(y_0) \\;+\\; \\frac{h^2}{2}\\,P''(\\xi).\n$$\n代入 $D_h$ 并减去 $P'(y_0)$，得到截断（离散化）误差\n$$\nD_h - P'(y_0) \\;=\\; \\frac{h}{2}\\,P''(\\xi),\n$$\n因此截断误差为 $O(h)$，当 $h \\to 0$ 时，其主项行为为 $\\frac{h}{2} P''(y_0)$。\n\n接下来，我们对浮点舍入进行建模。在标准相对误差模型下，每个计算量都会受到一个乘法因子 $(1+\\delta)$ 的扰动，其中 $|\\delta|\\le \\epsilon_{mach}$。设计算值为\n$$\n\\widehat{P(y_0+h)} = P(y_0+h)(1+\\delta_1), \\quad \\widehat{P(y_0)} = P(y_0)(1+\\delta_2),\n$$\n其中 $|\\delta_1|,|\\delta_2| \\le \\epsilon_{mach}$。向前差分的计算分子为\n$$\n\\widehat{P(y_0+h)} - \\widehat{P(y_0)} \\;=\\; \\big(P(y_0+h) - P(y_0)\\big) \\;+\\; \\delta_1 P(y_0+h) \\;-\\; \\delta_2 P(y_0).\n$$\n除以 $h$ 得到一个加性舍入误差项\n$$\n\\frac{\\delta_1 P(y_0+h) - \\delta_2 P(y_0)}{h}.\n$$\n对于小的 $h$，$P(y_0+h) \\approx P(y_0)$，因此分子中的差 $P(y_0+h)-P(y_0)$ 很小，而项 $\\frac{\\delta_1 P(y_0+h) - \\delta_2 P(y_0)}{h}$ 的量级为\n$$\nO\\!\\left(\\frac{\\epsilon_{mach}\\,|P(y_0)|}{h}\\right).\n$$\n这是灾难性抵消的标志：两个相近的大数相减会减少有效数字，从而在导数商中将相对舍入误差放大约 $1/h$ 倍。\n\n结合截断误差和舍入误差，主阶总误差可以表示为\n$$\nE(h) \\;\\approx\\; \\frac{h}{2}\\,|P''(y_0)| \\;+\\; C\\,\\frac{\\epsilon_{mach}\\,|P(y_0)|}{h},\n$$\n其中 $C$ 是一个反映浮点计算和代数重排细节的适中常数。关于 $h$ 最小化这个主阶模型可以得到\n$$\n\\frac{d}{dh}\\left(\\frac{h}{2}|P''(y_0)| + C\\,\\frac{\\epsilon_{mach}\\,|P(y_0)|}{h}\\right)=0\n\\;\\Rightarrow\\;\n\\frac{1}{2}|P''(y_0)| - C\\,\\frac{\\epsilon_{mach}\\,|P(y_0)|}{h^2}=0,\n$$\n所以\n$$\nh^* \\;=\\; \\sqrt{\\frac{2C\\,\\epsilon_{mach}\\,|P(y_0)|}{|P''(y_0)|}}\n\\;\\asymp\\; \\sqrt{\\frac{\\epsilon_{mach}\\,|P(y_0)|}{|P''(y_0)|}},\n$$\n其中 $\\asymp$ 表示在常数因子内相等。\n\n我们现在为指定的债券计算 $|P(y_0)|$ 和 $|P''(y_0)|$。对于连续复利和半年付息时间 $t_k = k/2$，$k=1,\\ldots,20$，我们有\n$$\nP(y_0) \\;=\\; \\sum_{k=1}^{19} 2.5\\,e^{-0.03\\, (k/2)} \\;+\\; 102.5\\,e^{-0.03 \\cdot 10}.\n$$\n设 $r = e^{-0.03/2} = e^{-0.015} \\approx 0.98511194$。第一个求和是一个几何级数：\n$$\n\\sum_{k=1}^{19} 2.5\\,r^k \\;=\\; 2.5\\,r\\,\\frac{1-r^{19}}{1-r}.\n$$\n使用 $1-r \\approx 0.01488806$，$r^{19} = e^{-0.015\\cdot 19} = e^{-0.285} \\approx 0.7520$，我们得到\n$$\n\\sum_{k=1}^{19} 2.5\\,r^k \\;\\approx\\; 2.5 \\times 0.98511194 \\times \\frac{1-0.7520}{0.01488806} \\;\\approx\\; 41.02.\n$$\n最终现金流项是\n$$\n102.5\\,e^{-0.3} \\;\\approx\\; 102.5 \\times 0.740818 \\;\\approx\\; 75.93.\n$$\n因此\n$$\nP(y_0) \\;\\approx\\; 41.02 + 75.93 \\;\\approx\\; 116.95.\n$$\n\n接下来，计算\n$$\nP''(y) \\;=\\; \\sum_{k=1}^{N} c_k\\, t_k^2\\, e^{-y t_k}.\n$$\n因此，在 $y_0=0.03$ 处，\n$$\nP''(y_0) \\;=\\; \\sum_{k=1}^{19} 2.5 \\left(\\frac{k}{2}\\right)^2 e^{-0.03\\,(k/2)} \\;+\\; 102.5 \\cdot 10^2 \\cdot e^{-0.3}.\n$$\n最后一项计算结果为\n$$\n102.5 \\cdot 100 \\cdot e^{-0.3} \\;\\approx\\; 102.5 \\times 100 \\times 0.740818 \\;\\approx\\; 7593.38.\n$$\n对票息项直接求和大约得到\n$$\n\\sum_{k=1}^{19} 2.5 \\left(\\frac{k}{2}\\right)^2 e^{-0.03\\,(k/2)} \\;\\approx\\; 1242.46,\n$$\n所以\n$$\nP''(y_0) \\;\\approx\\; 7593.38 + 1242.46 \\;\\approx\\; 8835.84.\n$$\n因此，\n$$\n\\frac{|P(y_0)|}{|P''(y_0)|} \\;\\approx\\; \\frac{116.95}{8835.84} \\;\\approx\\; 1.32 \\times 10^{-2}.\n$$\n当 $\\epsilon_{mach} \\approx 1.11 \\times 10^{-16}$ 时，我们有\n$$\n\\epsilon_{mach}\\,\\frac{|P(y_0)|}{|P''(y_0)|} \\;\\approx\\; 1.47 \\times 10^{-18},\n$$\n所以\n$$\nh^* \\;\\asymp\\; \\sqrt{1.47 \\times 10^{-18}} \\;\\approx\\; 1.21 \\times 10^{-9},\n$$\n并且包括常数 $\\sqrt{2C}$（其中 $C$ 的量级为 $1$）会使 $h^*$ 保持在 $10^{-9}$ 的量级。因此，最接近 $10^{-9}$ 的数量级是正确的。\n\n我们现在评估每个选项：\n\nA. 上述舍入误差分析表明，对于小的 $h$，主导项的行为类似 $O\\!\\left(\\dfrac{\\epsilon_{mach}\\,|P(y_0)|}{h}\\right)$，这是由相减两个几乎相等的大量所引起的。结论：正确。\n\nB. 根据泰勒定理，向前差分的截断误差是 $O(h)$，主项是 $\\frac{h}{2}P''(y_0)$，而不是 $O(h^2)$，它取决于 $P''(y_0)$，而不是 $P^{(3)}(y_0)$。结论：不正确。\n\nC. 平衡 $O(h)$ 的截断误差和 $O(\\epsilon_{mach}/h)$ 的舍入误差，可以得到 $h^* \\asymp \\sqrt{\\dfrac{\\epsilon_{mach}\\,|P(y_0)|}{|P''(y_0)|}}$，这与推导结果一致（相差一个常数因子）。结论：正确。\n\nD. 使用计算出的 $P(y_0)$ 和 $P''(y_0)$，并取 $\\epsilon_{mach} \\approx 1.11 \\times 10^{-16}$，得出 $h^*$ 的数量级为 $10^{-9}$。结论：正确。\n\nE. 中心差分将截断误差减小到 $O(h^2)$，但仍然涉及相减几乎相等的量 $P(y_0+h)$ 和 $P(y_0-h)$，因此舍入误差的量级仍然是 $O\\!\\left(\\dfrac{\\epsilon_{mach}\\,|P(y_0)|}{h}\\right)$。灾难性抵消并没有对所有 $h$ 都被消除。结论：不正确。",
            "answer": "$$\\boxed{ACD}$$"
        },
        {
            "introduction": "最后的这个练习要求你通过一个编程任务将理论付诸实践。基于前一个问题中的概念，你将通过最小化总误差来凭经验找到计算期权“Vega”的最优步长 $h$。通过绘制不同 $h$ 值对应的误差，你将直接观察到U形误差曲线，从而巩固对截断误差和舍入误差之间平衡的理解。",
            "id": "2415200",
            "problem": "考虑一个在Black–Scholes框架下定价的无股息资产的欧式看涨期权。设即期价格为 $S_0$，行权价为 $K$，连续复利无风险利率为 $r$，到期时间为 $T$，波动率为 $\\sigma$。Black-Scholes看涨期权价格为\n$$\nC(S_0,K,r,T,\\sigma)=S_0\\,\\Phi(d_1)-K e^{-rT}\\,\\Phi(d_2),\n$$\n其中\n$$\nd_1=\\frac{\\ln\\!\\left(\\frac{S_0}{K}\\right)+\\left(r+\\frac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}},\\quad d_2=d_1-\\sigma\\sqrt{T},\n$$\n且 $\\Phi(\\cdot)$ 是标准正态分布的累积分布函数。该看涨期权的解析Vega是价格相对于 $\\sigma$ 的偏导数，由下式给出：\n$$\n\\text{Vega}(S_0,K,r,T,\\sigma)=\\frac{\\partial C}{\\partial \\sigma}=S_0 \\sqrt{T}\\,\\varphi(d_1),\n$$\n其中 $\\varphi(\\cdot)$ 是标准正态概率密度函数。\n\n对于给定的参数向量 $(S_0,K,r,T,\\sigma)$，通过应用于波动率的对称差分商定义Vega的数值估计量，\n$$\n\\widehat{\\text{Vega}}(h)=\\frac{C(S_0,K,r,T,\\sigma+h)-C(S_0,K,r,T,\\sigma-h)}{2h},\n$$\n对于步长 $h>0$ 且满足 $\\sigma-h>0$。对于给定的 $(S_0,K,r,T,\\sigma)$ 和一个候选步长集合\n$$\n\\mathcal{H}=\\{10^{-12},10^{-11},10^{-10},10^{-9},10^{-8},10^{-7},10^{-6},10^{-5},10^{-4},10^{-3},10^{-2}\\},\n$$\n考虑其可接受子集\n$$\n\\mathcal{H}_{\\text{adm}}=\\{h\\in\\mathcal{H}\\,:\\,0<h\\le\\sigma/2\\}.\n$$\n最优步长 $h^\\star \\in \\mathcal{H}_{\\text{adm}}$ 定义为使得绝对误差\n$$\nE(h) \\;=\\; \\left|\\widehat{\\text{Vega}}(h)-\\text{Vega}(S_0,K,r,T,\\sigma)\\right|\n$$\n最小的步长。如果存在多个这样的步长，则选择最大的一个。\n\n编写一个Python 3脚本来计算四个不同测试案例的 $h^\\star$：\n1.  $(100.0, 100.0, 0.01, 1.0, 0.2)$\n2.  $(100.0, 100.0, 0.01, 0.01, 0.2)$\n3.  $(100.0, 102.0, 0.02, 0.5, 0.05)$\n4.  $(100.0, 100.0, 0.03, 2.0, 0.6)$\n\n您的程序应该将所有四个最优步长打印到一个列表中，格式为 `[h_star_1,h_star_2,h_star_3,h_star_4]`。您的代码将在一个环境中执行，该环境预安装了 `scipy` (1.11.1) 和 `numpy` (1.24.3)。",
            "solution": "问题陈述已经过严格验证，并被认为是有效的。它在科学上基于Black-Scholes期权定价理论和数值分析原理。问题是适定的，包含所有必要的参数、公式以及一个清晰、明确的目标。该问题没有矛盾和主观论断。因此，将给出一个解决方案。\n\n任务是为期权Vega的数值估计找到最优步长 $h^\\star$。Vega是期权价格对波动率 $\\sigma$ 的一阶偏导数。数值估计是使用对称差分商进行的。最优步长 $h^\\star$ 被定义为给定离散集合 $\\mathcal{H}_{\\text{adm}}$ 中的一个值，该值使得数值估计与Vega解析值之间的绝对误差最小。\n\n对于由参数集 $(S_0, K, r, T, \\sigma)$ 定义的每个测试案例，方法如下：\n\n1.  **解析Vega计算**：首先，使用提供的解析公式计算Vega的精确值：\n    $$ \\text{Vega}(S_0,K,r,T,\\sigma) = S_0 \\sqrt{T}\\,\\varphi(d_1) $$\n    其中 $\\varphi(\\cdot)$ 是标准正态分布的概率密度函数（PDF），$d_1$ 由下式给出：\n    $$ d_1=\\frac{\\ln(S_0/K)+\\left(r+\\frac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}} $$\n    这个解析值作为基准，用于与数值估计进行比较。\n\n2.  **数值估计与误差计算**：对于可接受集合 $\\mathcal{H}_{\\text{adm}}$ 中的每个步长 $h$，我们使用对称差分商计算Vega的数值近似值，记为 $\\widehat{\\text{Vega}}(h)$：\n    $$ \\widehat{\\text{Vega}}(h)=\\frac{C(S_0,K,r,T,\\sigma+h)-C(S_0,K,r,T,\\sigma-h)}{2h} $$\n    这里，$C(\\cdot)$ 是Black-Scholes看涨期权价格函数：\n    $$ C(S_0,K,r,T,\\sigma)=S_0\\,\\Phi(d_1)-K e^{-rT}\\,\\Phi(d_2) $$\n    其中 $\\Phi(\\cdot)$ 是标准正态分布的累积分布函数（CDF），且 $d_2 = d_1 - \\sigma\\sqrt{T}$。然后，每个 $h$ 的绝对误差计算如下：\n    $$ E(h)=\\left|\\widehat{\\text{Vega}}(h)-\\text{Vega}(S_0,K,r,T,\\sigma)\\right| $$\n\n3.  **最优步长选择**：候选步长集合由 $\\mathcal{H} = \\{10^{-12}, 10^{-11}, \\dots, 10^{-2}\\}$ 给出。可接受集合 $\\mathcal{H}_{\\text{adm}}$ 定义为 $\\{h\\in\\mathcal{H}\\,:\\,0<h\\le\\sigma/2\\}$。在计算了所有 $h \\in \\mathcal{H}_{\\text{adm}}$ 的误差 $E(h)$ 后，我们找到最小的误差值，然后选择产生该最小误差的步长。如果多个步长产生相同的最小误差，我们根据问题陈述的规定选择最大的一个。\n\n4.  **实现**：使用`numpy`进行数值计算，使用`scipy.stats.norm`来计算标准正态CDF（`norm.cdf`）和PDF（`norm.pdf`）。该过程对每个测试案例重复进行，并将找到的最优步长 $h^\\star$ 收集到一个列表中，然后以指定格式打印。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\n# from scipy import ...\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (100.0, 100.0, 0.01, 1.0, 0.2),\n        (100.0, 100.0, 0.01, 0.01, 0.2),\n        (100.0, 102.0, 0.02, 0.5, 0.05),\n        (100.0, 100.0, 0.03, 2.0, 0.6),\n    ]\n\n    # Candidate set of step sizes H\n    H = [10**-12, 10**-11, 10**-10, 10**-9, 10**-8, 10**-7,\n         10**-6, 10**-5, 10**-4, 10**-3, 10**-2]\n\n    # Function to calculate Black-Scholes call price\n    def black_scholes_call(S0, K, r, T, sigma):\n        # Handle edge cases for sigma and T to avoid mathematical errors\n        if sigma == 0 or T == 0:\n            # If T > 0 and sigma = 0, the option price is deterministic.\n            # If T = 0, the option price is its intrinsic value.\n            return max(0.0, S0 - K * np.exp(-r * T))\n            \n        d1 = (np.log(S0 / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n        d2 = d1 - sigma * np.sqrt(T)\n        price = S0 * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)\n        return price\n\n    # Function to calculate analytical Vega\n    def analytical_vega(S0, K, r, T, sigma):\n        # Vega is zero if T=0 or sigma=0\n        if sigma == 0 or T == 0:\n            return 0.0\n        d1 = (np.log(S0 / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n        vega = S0 * np.sqrt(T) * norm.pdf(d1)\n        return vega\n\n    optimal_h_results = []\n\n    for case in test_cases:\n        S0, K, r, T, sigma = case\n\n        # Determine the admissible set of step sizes.\n        # For all test cases provided, sigma/2 is greater than the largest h_cand in H,\n        # so the admissible set is the full set H.\n        H_adm = [h for h in H if 0  h and h = sigma / 2.0]\n\n        # Calculate the true analytical Vega to use as a benchmark\n        true_vega = analytical_vega(S0, K, r, T, sigma)\n\n        errors_with_h = []\n        for h in H_adm:\n            # Calculate numerical Vega using symmetric difference quotient\n            C_plus = black_scholes_call(S0, K, r, T, sigma + h)\n            C_minus = black_scholes_call(S0, K, r, T, sigma - h)\n            numerical_vega = (C_plus - C_minus) / (2.0 * h)\n            \n            # Calculate the absolute error\n            error = abs(numerical_vega - true_vega)\n            errors_with_h.append((error, h))\n\n        # Find the minimum error among all step sizes\n        min_error = min(e for e, h in errors_with_h)\n\n        # Find all step sizes that achieve this minimum error\n        minimizing_hs = [h for e, h in errors_with_h if e == min_error]\n\n        # Select the largest h among the minimizers as per the tie-breaking rule\n        optimal_h = max(minimizing_hs)\n        optimal_h_results.append(optimal_h)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, optimal_h_results))}]\")\n\nsolve()\n```"
        }
    ]
}