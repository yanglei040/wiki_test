{
    "hands_on_practices": [
        {
            "introduction": "The first step to mastering any numerical method is to apply it to a concrete problem. This exercise grounds the trapezoidal rule in a physical context: calculating the work $W$ done to compress a gas, which is represented by the integral $W = \\int F(x) dx$. By approximating this integral with just two trapezoids, you will solidify your understanding of the core mechanics of the method .",
            "id": "2222091",
            "problem": "In a materials science experiment, a piston is used to compress a gas in a cylinder. The process is carried out slowly, so it can be considered quasi-static and isothermal. The force $F$ required to hold the piston at a position $x$ (measured from the closed end of the cylinder) is found to vary according to the law $F(x) = \\frac{k}{x}$, where $k$ is a constant related to the temperature and the amount of gas.\n\nTo move the piston and compress the gas, work must be done. The exact work $W$ done by an external agent to move the piston from an initial position $x_i$ to a final position $x_f$ is given by the integral $W = \\int_{x_i}^{x_f} F(x) dx$.\n\nSuppose the piston is moved from $x_i = 1$ m to $x_f = 3$ m, and the constant $k$ is equal to 1 N路m. You are tasked with finding an approximate value for the work done. The approximation method consists of the following steps:\n1. Divide the total displacement interval $[x_i, x_f]$ into two subintervals of equal length.\n2. For each subinterval, approximate the area under the force-displacement curve by the area of a trapezoid formed by the x-axis, the vertical lines at the subinterval's endpoints, and the straight line segment connecting the force values at these endpoints.\n3. Sum the areas of these two trapezoids to get the total approximate work.\n\nUsing this method, calculate the approximate work done to move the piston. Express your answer in Joules as a simplified fraction.",
            "solution": "The problem asks for an approximation of the work done, $W$, by moving a piston against a force $F(x) = \\frac{k}{x}$ from $x_i = 1$ m to $x_f = 3$ m. We are given $k = 1$ N路m. The work is given by the integral:\n$$W = \\int_{1}^{3} \\frac{1}{x} dx$$\n\nThe problem describes a numerical approximation method which is equivalent to the composite trapezoidal rule with two segments. Let the interval be $[a, b] = [1, 3]$ and the number of segments be $n=2$. The function to integrate is $f(x) = \\frac{1}{x}$.\n\nFirst, we calculate the width, $h$, of each subinterval:\n$$h = \\frac{b - a}{n} = \\frac{3 - 1}{2} = 1$$\n\nThe two subintervals are $[1, 2]$ and $[2, 3]$. The evaluation points (the endpoints of the subintervals) are $x_0 = 1$, $x_1 = 2$, and $x_2 = 3$.\n\nThe approximation method described is to sum the areas of two trapezoids.\nThe area of the first trapezoid, over the interval $[x_0, x_1]$, is:\n$$A_1 = \\frac{h}{2} (f(x_0) + f(x_1))$$\nThe area of the second trapezoid, over the interval $[x_1, x_2]$, is:\n$$A_2 = \\frac{h}{2} (f(x_1) + f(x_2))$$\n\nThe total approximate work $W_{approx}$ is the sum of these two areas:\n$$W_{approx} = A_1 + A_2 = \\frac{h}{2}(f(x_0) + f(x_1)) + \\frac{h}{2}(f(x_1) + f(x_2))$$\nThis can be simplified to the standard composite trapezoidal rule formula:\n$$W_{approx} = \\frac{h}{2} (f(x_0) + 2f(x_1) + f(x_2))$$\n\nNow we evaluate the function $f(x) = \\frac{1}{x}$ at the points $x_0, x_1, x_2$:\n$$f(x_0) = f(1) = \\frac{1}{1} = 1$$\n$$f(x_1) = f(2) = \\frac{1}{2}$$\n$$f(x_2) = f(3) = \\frac{1}{3}$$\n\nNow, we substitute these values into the formula for $W_{approx}$. We also substitute $h=1$.\n$$W_{approx} = \\frac{1}{2} \\left( 1 + 2\\left(\\frac{1}{2}\\right) + \\frac{1}{3} \\right)$$\n\nWe simplify the expression inside the parentheses:\n$$W_{approx} = \\frac{1}{2} \\left( 1 + 1 + \\frac{1}{3} \\right)$$\n$$W_{approx} = \\frac{1}{2} \\left( 2 + \\frac{1}{3} \\right)$$\n\nTo add the terms inside the parentheses, we find a common denominator:\n$$W_{approx} = \\frac{1}{2} \\left( \\frac{6}{3} + \\frac{1}{3} \\right)$$\n$$W_{approx} = \\frac{1}{2} \\left( \\frac{7}{3} \\right)$$\n\nFinally, we perform the multiplication:\n$$W_{approx} = \\frac{7}{6}$$\n\nThe problem states that $k$ is in N路m and $x$ is in m, so the work $W$ is in Joules. The problem asks for the answer in Joules, expressed as a simplified fraction. Our result is $7/6$.",
            "answer": "$$\\boxed{\\frac{7}{6}}$$"
        },
        {
            "introduction": "While applying the trapezoidal rule is straightforward, its practical power comes from our ability to control its error. In fields like pharmacokinetics, knowing the total exposure to a drug is critical, and a numerical approximation is only useful if its accuracy is guaranteed. This problem will guide you through using the theoretical error bound of the trapezoidal rule to determine the exact number of subintervals needed to achieve a desired level of precision .",
            "id": "2210520",
            "problem": "In a pharmacokinetic study, the concentration of a new drug in a patient's bloodstream is modeled as a function of time, $t$, by the equation $C(t) = C_0 \\exp(-kt^2)$. Here, $t$ is the time in hours after injection, $C_0 = 50$ mg/L is the initial concentration, and $k = 0.5 \\text{ hr}^{-2}$ is a constant related to the drug's elimination rate.\n\nTo assess the total drug exposure over the first two hours, a biomedical engineer needs to calculate the Area Under the Curve (AUC), which is given by the definite integral $A = \\int_{0}^{T} C(t) dt$ with $T=2$ hours.\n\nThe engineer uses a numerical approximation method. The time interval $[0, T]$ is divided into $n$ equal subintervals, and the value of the integral is approximated by summing the areas of the trapezoids formed by connecting the points $(t_i, C(t_i))$ and $(t_{i+1}, C(t_{i+1}))$ for each subinterval.\n\nFor this specific numerical method, the absolute error, $|E_n|$, is known to be bounded by the inequality:\n$$|E_n| \\le \\frac{M(T-0)^3}{12n^2}$$\nwhere $M$ is the maximum absolute value of the second derivative of the concentration function, $M = \\max_{t \\in [0, T]} |C''(t)|$.\n\nDetermine the minimum integer number of subintervals, $n$, that the engineer must use to guarantee that the absolute error in the calculated AUC is less than $10^{-3}$ mg路hr/L.",
            "solution": "We are given $C(t) = C_{0}\\exp(-k t^{2})$ with $C_{0} = 50$ and $k = 0.5$, and the trapezoidal rule error bound\n$$|E_{n}| \\le \\frac{M(T-0)^{3}}{12 n^{2}}, \\quad M = \\max_{t \\in [0,T]} |C''(t)|, \\quad T=2.$$\n\nFirst compute $C''(t)$. Differentiating,\n$$C'(t) = C_{0}\\exp(-k t^{2})(-2 k t),$$\n$$C''(t) = C_{0}\\exp(-k t^{2})\\left(-2k + 4k^{2} t^{2}\\right) = 2k C_{0}\\exp(-k t^{2})\\left(-1 + 2k t^{2}\\right).$$\nThus\n$$|C''(t)| = 2k C_{0}\\exp(-k t^{2})\\left| -1 + 2k t^{2} \\right|.$$\n\nLet $t_{0} = \\frac{1}{\\sqrt{2k}}$. For $t \\in [0,t_{0}]$, we have $-1 + 2k t^{2} \\le 0$, so\n$$|C''(t)| = 2k C_{0}\\exp(-k t^{2})\\left(1 - 2k t^{2}\\right).$$\nDefine $h_{1}(t) = 2k C_{0}\\exp(-k t^{2})(1 - 2k t^{2})$. Its derivative is\n$$h_{1}'(t) = 4 k^{2} C_{0} t \\exp(-k t^{2})\\left(-3 + 2k t^{2}\\right).$$\nOn $(0,t_{0}]$, since $t_{0}^{2} = \\frac{1}{2k}$, we have $-3 + 2k t^{2} \\le -3 + 1 = -2  0$, hence $h_{1}'(t)  0$. Therefore $h_{1}$ is decreasing on $[0,t_{0}]$ and attains its maximum at $t=0$:\n$$h_{1}(0) = 2k C_{0}.$$\n\nFor $t \\in [t_{0},T]$, we have $-1 + 2k t^{2} \\ge 0$, so\n$$|C''(t)| = 2k C_{0}\\exp(-k t^{2})\\left(-1 + 2k t^{2}\\right).$$\nDefine $h_{2}(t) = 2k C_{0}\\exp(-k t^{2})(-1 + 2k t^{2})$. Its derivative is\n$$h_{2}'(t) = 4 k^{2} C_{0} t \\exp(-k t^{2})\\left(3 - 2k t^{2}\\right).$$\nCritical points in $[t_{0},T]$ occur at $t = \\sqrt{\\frac{3}{2k}}$ if this lies in the interval. With $k = 0.5$, we have $t_{0} = 1$, $T=2$, and $\\sqrt{\\frac{3}{2k}} = \\sqrt{3} \\in [1,2]$. Evaluate $h_{2}$ at candidates:\n- At $t = t_{0}$, $h_{2}(t_{0}) = 0$.\n- At $t = \\sqrt{\\frac{3}{2k}}$, since $2k t^{2} = 3$,\n$$h_{2}\\left(\\sqrt{\\frac{3}{2k}}\\right) = 2k C_{0} \\cdot 2 \\cdot \\exp\\!\\left(-\\frac{3}{2}\\right) = 4k C_{0}\\exp\\!\\left(-\\frac{3}{2}\\right).$$\n- At $t = T=2$,\n$$h_{2}(2) = 2k C_{0}\\left(-1 + 8k\\right)\\exp(-4k).$$\n\nCompare these to $2k C_{0}$. Note that\n$$4k C_{0}\\exp\\!\\left(-\\frac{3}{2}\\right) = 2k C_{0}\\cdot 2\\exp\\!\\left(-\\frac{3}{2}\\right)  2k C_{0}$$\nbecause $\\exp\\!\\left(\\frac{3}{2}\\right)  2$, hence $2\\exp(-\\frac{3}{2})  1$. Also $h_{2}(2)$ is smaller than $2k C_{0}$ for $k=0.5$. Therefore the maximum over $[0,2]$ is attained at $t=0$:\n$$M = \\max_{t \\in [0,2]} |C''(t)| = 2k C_{0} = 2 \\cdot 0.5 \\cdot 50 = 50.$$\n\nApply the error bound with $T=2$:\n$$|E_{n}| \\le \\frac{M T^{3}}{12 n^{2}} = \\frac{50 \\cdot 2^{3}}{12 n^{2}} = \\frac{100}{3 n^{2}}.$$\nRequire $|E_{n}|  10^{-3}$:\n$$\\frac{100}{3 n^{2}}  10^{-3} \\quad \\Longleftrightarrow \\quad n^{2}  \\frac{100}{3 \\cdot 10^{-3}} = \\frac{100000}{3}.$$\nThus $n  \\sqrt{\\frac{100000}{3}}$. Since $182^{2} = 33124$ and $183^{2} = 33489$, and $100000/3 \\approx 33333.33$, we have $182^2  100000/3  183^2$. The minimal integer $n$ satisfying the inequality is\n$$n = 183.$$",
            "answer": "$$\\boxed{183}$$"
        },
        {
            "introduction": "A uniform partition is simple but often inefficient, wasting computational effort on regions where the function is nearly flat. This advanced practice challenges you to build a smarter, more efficient algorithm: an adaptive quadrature scheme. You will implement a method that estimates the local error on the fly and recursively refines the integration grid only where needed, a technique at the heart of modern numerical integrators .",
            "id": "3284319",
            "problem": "You are tasked with building a principled, self-contained program that implements an adaptive numerical integration scheme grounded in first principles for the trapezoidal rule. The core objective is to approximate the definite integral $\\int_{a}^{b} f(x)\\,dx$ for a series of test functions using an adaptive refinement strategy that estimates local error by comparing the trapezoidal approximation on the whole interval and the sum of trapezoidal approximations on its two halves.\n\nBegin from the definition of the definite integral as the limit of Riemann sums and the construction of the linear interpolant of $f(x)$ between $x=a$ and $x=b$. The trapezoidal rule for a single interval arises by integrating this linear interpolant over $[a,b]$. Your algorithm must:\n- On any subinterval $[a,b]$ with width $h=b-a$, compute the trapezoidal approximation on the whole interval and the combined trapezoidal approximation on its two halves $[a,m]$ and $[m,b]$ with $m=(a+b)/2$.\n- Use only the comparison between these two approximations (the whole interval versus the sum over two halves) to design a local error estimator, deduced from sound reasoning about how the local truncation error scales with interval width when the interval is halved. Do not assume or use any shortcut formulas not derived from this error-scaling reasoning.\n- Accept a subinterval if the estimated local error is below a prescribed tolerance, optionally using a bias-reduced corrected estimate derived from the same error-scaling principle; otherwise, split the interval and recurse on each half.\n- Ensure termination through a maximum recursion depth parameter $D_{\\max}$ and handle degenerate intervals with $a=b$ correctly.\n\nAngle units for any trigonometric function must be radians. There are no physical units in this problem. All numeric tolerances in the test suite are absolute tolerances.\n\nImplement your program to evaluate the following test suite. For each test case, compute the integral approximation using your adaptive trapezoidal scheme with the given tolerance, and aggregate the results into a single line of output in the specified format.\n\nTest Suite:\n1. $f(x)=\\sin(x)$ on $[0,\\pi]$ with tolerance $10^{-12}$.\n2. $f(x)=e^{-x^{2}}$ on $[0,1]$ with tolerance $10^{-12}$.\n3. $f(x)=\\dfrac{1}{1+x^{2}}$ on $[-5,5]$ with tolerance $10^{-10}$.\n4. $f(x)=|x|$ on $[-1,1]$ with tolerance $10^{-10}$.\n5. $f(x)=\\dfrac{\\sin(100x)}{1+x^{2}}$ on $[0,1]$ with tolerance $10^{-8}$.\n6. $f(x)=5$ on $[2,5]$ with tolerance $10^{-12}$.\n7. $f(x)=\\sin(x)$ on $[1,1]$ (zero-length interval) with tolerance $10^{-12}$.\n\nDesign for coverage:\n- The first case is a smooth periodic function over one full period.\n- The second case has a bell-shaped integrand with rapidly decaying tails within the interval.\n- The third case tests rational integrands over a symmetric large interval.\n- The fourth case tests a non-differentiable integrand at the midpoint.\n- The fifth case is oscillatory with moderate damping.\n- The sixth case is constant and should terminate immediately.\n- The seventh case is a boundary case with zero-length interval.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with no additional whitespace or text. For example: \"[r1,r2,r3,r4,r5,r6,r7]\". Each $r_{i}$ must be a floating-point number representing the integral approximation for the corresponding test case, computed by your adaptive trapezoidal method.",
            "solution": "The problem requires the development of an adaptive numerical integration scheme based on the trapezoidal rule. The core of the task is to derive an error estimation and refinement strategy from first principles, specifically by comparing a coarse approximation on an interval with a more refined one.\n\n### Principle-Based Derivation\n\nLet the definite integral to be approximated be $I = \\int_{a}^{b} f(x)\\,dx$.\n\n**1. The Trapezoidal Rule from First Principles**\n\nThe trapezoidal rule approximates the integrand $f(x)$ with a linear polynomial $p_1(x)$ that interpolates the function at the endpoints of the interval $[a, b]$. The coordinates of these points are $(a, f(a))$ and $(b, f(b))$. The linear interpolant is given by:\n$$p_1(x) = f(a) + \\frac{f(b) - f(a)}{b-a}(x - a)$$\nThe integral of this linear polynomial over the interval $[a, b]$ provides the trapezoidal approximation, denoted as $T(a,b)$. Let $h = b - a$ be the width of the interval.\n$$T(a,b) = \\int_{a}^{b} p_1(x) \\,dx = \\int_{a}^{b} \\left( f(a) + \\frac{f(b) - f(a)}{h}(x - a) \\right) \\,dx$$\n$$= \\left[ f(a)x + \\frac{f(b) - f(a)}{h} \\left( \\frac{x^2}{2} - ax \\right) \\right]_{a}^{b}$$\n$$= f(a)(b-a) + \\frac{f(b) - f(a)}{h} \\left( \\left(\\frac{b^2}{2} - ab\\right) - \\left(\\frac{a^2}{2} - a^2\\right) \\right)$$\n$$= f(a)h + \\frac{f(b) - f(a)}{h} \\left( \\frac{b^2 - 2ab + a^2}{2} \\right) = f(a)h + \\frac{f(b) - f(a)}{h} \\frac{(b-a)^2}{2}$$\n$$= f(a)h + (f(b) - f(a))\\frac{h}{2} = \\frac{h}{2}(2f(a) + f(b) - f(a)) = \\frac{h}{2}(f(a) + f(b))$$\nThis is the single-panel trapezoidal rule. Let's call this coarse approximation $S_1$.\n$$S_1 = \\frac{h}{2}(f(a) + f(b))$$\n\n**2. Error Estimation via Refinement**\n\nTo estimate the error, we compare $S_1$ with a more accurate approximation, $S_2$, obtained by splitting the interval $[a, b]$ into two subintervals of equal width, $[a, m]$ and $[m, b]$, where $m = (a+b)/2$. The width of each subinterval is $h/2$. The approximation $S_2$ is the sum of the trapezoidal rule applied to each subinterval:\n$$S_2 = T(a, m) + T(m, b) = \\frac{h/2}{2}(f(a) + f(m)) + \\frac{h/2}{2}(f(m) + f(b))$$\n$$S_2 = \\frac{h}{4}(f(a) + 2f(m) + f(b))$$\n\nThe local truncation error for the trapezoidal rule on an interval of width $w$ is given by $E(w) = -\\frac{w^3}{12}f''(\\xi)$ for some $\\xi$ in the interval, assuming $f$ is twice continuously differentiable. This shows that the error is proportional to the cube of the interval width, i.e., $E(w) \\approx Cw^3$.\n\nThe true integral $I$ can be related to our approximations $S_1$ and $S_2$ as follows:\n$I = S_1 + E(h) \\approx S_1 + Ch^3$\n$I = S_2 + E(h/2) + E(h/2) \\approx S_2 + 2C(h/2)^3 = S_2 + \\frac{Ch^3}{4}$\n\nWe now have a system of two equations for the two unknowns, $I$ and $C$:\n$I - S_1 \\approx Ch^3$\n$I - S_2 \\approx \\frac{Ch^3}{4}$\n\nSubtracting the second equation from the first yields:\n$(I - S_2) - (I - S_1) \\approx \\frac{Ch^3}{4} - Ch^3 \\implies S_1 - S_2 \\approx -\\frac{3}{4}Ch^3$\n\nThis allows us to express the unknown term $Ch^3$ in terms of our computed quantities $S_1$ and $S_2$:\n$Ch^3 \\approx \\frac{4}{3}(S_2 - S_1)$\n\nThe error in the more accurate approximation, $E_2 = I - S_2$, can now be estimated.\n$E_2 \\approx \\frac{Ch^3}{4} \\approx \\frac{1}{4} \\left( \\frac{4}{3}(S_2 - S_1) \\right) = \\frac{1}{3}(S_2 - S_1)$\n\nThe absolute local error for the refined approximation $S_2$ can thus be estimated as:\n$$\\text{err} \\approx \\frac{1}{3}|S_2 - S_1|$$\nThis estimator is derived solely from the comparison of the two approximations and the scaling property of the local error, as required.\n\n**3. Adaptive Algorithm and Bias Reduction**\n\nThe adaptive algorithm proceeds recursively. For a given interval $[a, b]$ and an absolute tolerance $\\tau$:\n1.  Calculate $S_1$, $S_2$, and the error estimate $\\text{err} = \\frac{1}{3}|S_2 - S_1|$.\n2.  If $\\text{err}  \\tau$, the interval is considered adequately approximated. The process for this branch terminates.\n3.  If $\\text{err} \\ge \\tau$, the interval is split into $[a, m]$ and $[m, b]$. The algorithm is then called recursively on each subinterval, with the tolerance budget split accordingly, typically $\\tau/2$ for each. The results from the recursive calls are summed.\n\nThe problem mentions using a \"bias-reduced corrected estimate\". This is an application of Richardson extrapolation. A better estimate for the true integral $I$ can be obtained by correcting $S_2$ with our error estimate $E_2$:\n$$I \\approx S_2 + E_2 \\approx S_2 + \\frac{1}{3}(S_2 - S_1) = \\frac{4S_2 - S_1}{3}$$\nThis corrected value is, in fact, Simpson's rule for the interval $[a,b]$:\n$$\\frac{4}{3} \\left( \\frac{h}{4}(f(a) + 2f(m) + f(b)) \\right) - \\frac{1}{3} \\left( \\frac{h}{2}(f(a) + f(b)) \\right) = \\frac{h}{3}(f(a) + 2f(m) + f(b)) - \\frac{h}{6}(f(a) + f(b))$$\n$$= \\frac{h}{6} (2f(a) + 4f(m) + 2f(b) - f(a) - f(b)) = \\frac{h}{6}(f(a) + 4f(m) + f(b))$$\nWhen an interval is accepted (i.e., $\\text{err}  \\tau$), returning this higher-order Simpson's rule approximation provides a more accurate result for the same number of function evaluations.\n\n**4. Implementation Structure and Termination**\n\nThe algorithm is implemented as a recursive function. A wrapper function initializes the process.\n- **Base Cases for Recursion:**\n    1.  If $a = b$, the integral is $0$.\n    2.  A maximum recursion depth, $D_{\\max}$, is imposed to guarantee termination, even if the tolerance criterion is never met (e.g., for certain pathological functions or insufficient floating-point precision). If this depth is reached, the current best estimate for the subinterval is returned.\n\n- **Recursive Step:**\n    An internal function, `_adaptive_trapezoid(f, a, b, tol, fa, fb, depth)`, will perform the main logic. Passing `fa=f(a)` and `fb=f(b)` as arguments avoids redundant function evaluations at shared endpoints between parent and child intervals. If the error criterion is not met, it makes two recursive calls:\n    `_adaptive_trapezoid(f, a, m, tol/2, fa, fm, depth+1) + _adaptive_trapezoid(f, m, b, tol/2, fm, fb, depth+1)`\n    where $m=(a+b)/2$ and $fm=f(m)$. This structure efficiently and robustly implements the adaptive integration scheme.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the adaptive integration problem for the given test suite.\n    \"\"\"\n\n    MAX_DEPTH = 50\n\n    def _adaptive_trapezoid(f, a, b, tol, fa, fb, depth):\n        \"\"\"\n        Recursive helper function for adaptive trapezoidal integration.\n\n        This function approximates the integral of f(x) from a to b. It estimates\n        the error by comparing a one-panel trapezoid rule with a two-panel rule.\n        If the error is too large, it recursively calls itself on the two halves\n        of the interval.\n\n        Args:\n            f (callable): The function to integrate.\n            a (float): The start of the integration interval.\n            b (float): The end of the integration interval.\n            tol (float): The absolute tolerance for this subinterval.\n            fa (float): The value of f(a), passed to avoid re-computation.\n            fb (float): The value of f(b), passed to avoid re-computation.\n            depth (int): The current recursion depth.\n\n        Returns:\n            float: The approximated integral value for the interval [a, b].\n        \"\"\"\n        # Base case 1: Zero-length interval\n        if a == b:\n            return 0.0\n\n        # Base case 2: Maximum recursion depth reached\n        if depth  MAX_DEPTH:\n            # Reached depth limit, return best available coarse estimate.\n            # A warning could be printed here in a real application.\n            h = b - a\n            return (h / 2.0) * (fa + fb)\n\n        h = b - a\n        m = (a + b) / 2.0\n        fm = f(m)\n\n        # S1: Coarse approximation (1 trapezoid over [a,b])\n        s1 = (h / 2.0) * (fa + fb)\n\n        # S2: Finer approximation (2 trapezoids over [a,m] and [m,b])\n        s2 = (h / 4.0) * (fa + 2.0 * fm + fb)\n\n        # Estimate the error of the more accurate approximation, S2.\n        # This is derived from Richardson extrapolation, where error(S2) ~ (S2-S1)/3\n        error_estimate = abs(s2 - s1) / 3.0\n\n        if error_estimate  tol:\n            # Error is within tolerance. Return the bias-reduced (Simpson's rule) value.\n            # This is S2 + error_estimate, which is more accurate.\n            return s2 + (s2 - s1) / 3.0\n        else:\n            # Error is too large. Split the interval and recurse.\n            # The tolerance is split between the two sub-intervals.\n            left_integral = _adaptive_trapezoid(f, a, m, tol / 2.0, fa, fm, depth + 1)\n            right_integral = _adaptive_trapezoid(f, m, b, tol / 2.0, fm, fb, depth + 1)\n            return left_integral + right_integral\n\n    def adaptive_integrator(f, a, b, tol):\n        \"\"\"\n        Wrapper function to start the adaptive integration process.\n        \"\"\"\n        # Initial call to the recursive helper function.\n        # Pre-calculates f(a) and f(b) for efficiency.\n        return _adaptive_trapezoid(f, a, b, tol, f(a), f(b), 0)\n\n    # Test Suite Definition\n    test_cases = [\n        {'func': lambda x: np.sin(x), 'interval': (0, np.pi), 'tol': 1e-12},\n        {'func': lambda x: np.exp(-x**2), 'interval': (0, 1), 'tol': 1e-12},\n        {'func': lambda x: 1.0 / (1.0 + x**2), 'interval': (-5, 5), 'tol': 1e-10},\n        {'func': lambda x: np.abs(x), 'interval': (-1, 1), 'tol': 1e-10},\n        {'func': lambda x: np.sin(100 * x) / (1.0 + x**2), 'interval': (0, 1), 'tol': 1e-8},\n        {'func': lambda x: 5.0, 'interval': (2, 5), 'tol': 1e-12}, # Use 5.0 to ensure float\n        {'func': lambda x: np.sin(x), 'interval': (1, 1), 'tol': 1e-12},\n    ]\n\n    results = []\n    for case in test_cases:\n        f = case['func']\n        a, b = case['interval']\n        tol = case['tol']\n        \n        # Handle the zero-length interval case explicitly in the wrapper for clarity,\n        # although the recursion also handles it.\n        if a == b:\n            result = 0.0\n        else:\n            result = adaptive_integrator(f, a, b, tol)\n        \n        results.append(result)\n\n    # Format the final output string exactly as required.\n    # The repr() function provides a high-precision string representation of floats.\n    print(f\"[{','.join(map(repr, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}