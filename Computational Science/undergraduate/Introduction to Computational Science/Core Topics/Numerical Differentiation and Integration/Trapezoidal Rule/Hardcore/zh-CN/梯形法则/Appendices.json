{
    "hands_on_practices": [
        {
            "introduction": "掌握梯形法则的第一步是将其应用于具体问题。本练习将数值积分的抽象概念置于一个具体的物理情境中——计算压缩气体所做的功。通过分步计算，您将练习将积分问题转化为离散求和，这是所有数值积分方法的核心 。",
            "id": "2222091",
            "problem": "在一个材料科学实验中，一个活塞被用来压缩气缸中的气体。这个过程进行得很缓慢，因此可以被视为准静态和等温过程。将活塞保持在位置 $x$（从气缸封闭端测量）所需的力 $F$ 被发现遵循定律 $F(x) = \\frac{k}{x}$，其中 $k$ 是一个与温度和气体量有关的常数。\n\n为了移动活塞并压缩气体，必须做功。外部作用力将活塞从初始位置 $x_i$ 移动到最终位置 $x_f$ 所做的精确功 $W$ 由积分 $W = \\int_{x_i}^{x_f} F(x) dx$ 给出。\n\n假设活塞从 $x_i = 1$ m 移动到 $x_f = 3$ m，且常数 $k$ 等于 1 N·m。你的任务是求出所做功的近似值。近似方法包括以下步骤：\n1. 将总位移区间 $[x_i, x_f]$ 分成两个等长的子区间。\n2. 对于每个子区间，用力-位移曲线下的面积近似为由x轴、子区间端点处的垂线以及连接这些端点处力值的直线段所构成的梯形的面积。\n3. 将这两个梯形的面积相加，得到总的近似功。\n\n使用这种方法，计算移动活塞所做的近似功。以焦耳为单位，用最简分数表示你的答案。",
            "solution": "问题要求在力 $F(x) = \\frac{k}{x}$ 的作用下，将活塞从 $x_i = 1$ m 移动到 $x_f = 3$ m 所做的功 $W$ 的近似值。我们已知 $k = 1$ N·m。功由以下积分给出：\n$$W = \\int_{1}^{3} \\frac{1}{x} dx$$\n\n问题描述了一种数值近似方法，该方法等价于使用两个分段的复合梯形法则。设区间为 $[a, b] = [1, 3]$，分段数为 $n=2$。要积分的函数是 $f(x) = \\frac{1}{x}$。\n\n首先，我们计算每个子区间的宽度 $h$：\n$$h = \\frac{b - a}{n} = \\frac{3 - 1}{2} = 1$$\n\n两个子区间是 $[1, 2]$ 和 $[2, 3]$。求值点（子区间的端点）是 $x_0 = 1$, $x_1 = 2$ 和 $x_2 = 3$。\n\n所描述的近似方法是求两个梯形的面积之和。\n第一个梯形的面积，在区间 $[x_0, x_1]$ 上，是：\n$$A_1 = \\frac{h}{2} (f(x_0) + f(x_1))$$\n第二个梯形的面积，在区间 $[x_1, x_2]$ 上，是：\n$$A_2 = \\frac{h}{2} (f(x_1) + f(x_2))$$\n\n总的近似功 $W_{approx}$ 是这两个面积的和：\n$$W_{approx} = A_1 + A_2 = \\frac{h}{2}(f(x_0) + f(x_1)) + \\frac{h}{2}(f(x_1) + f(x_2))$$\n这可以简化为标准的复合梯形法则公式：\n$$W_{approx} = \\frac{h}{2} (f(x_0) + 2f(x_1) + f(x_2))$$\n\n现在我们在点 $x_0, x_1, x_2$ 处计算函数 $f(x) = \\frac{1}{x}$ 的值：\n$$f(x_0) = f(1) = \\frac{1}{1} = 1$$\n$$f(x_1) = f(2) = \\frac{1}{2}$$\n$$f(x_2) = f(3) = \\frac{1}{3}$$\n\n现在，我们将这些值代入 $W_{approx}$ 的公式中。我们也代入 $h=1$。\n$$W_{approx} = \\frac{1}{2} \\left( 1 + 2\\left(\\frac{1}{2}\\right) + \\frac{1}{3} \\right)$$\n\n我们简化括号内的表达式：\n$$W_{approx} = \\frac{1}{2} \\left( 1 + 1 + \\frac{1}{3} \\right)$$\n$$W_{approx} = \\frac{1}{2} \\left( 2 + \\frac{1}{3} \\right)$$\n\n为了将括号内的项相加，我们找到一个公分母：\n$$W_{approx} = \\frac{1}{2} \\left( \\frac{6}{3} + \\frac{1}{3} \\right)$$\n$$W_{approx} = \\frac{1}{2} \\left( \\frac{7}{3} \\right)$$\n\n最后，我们进行乘法运算：\n$$W_{approx} = \\frac{7}{6}$$\n\n问题指出 $k$ 的单位是 N·m，$x$ 的单位是 m，所以功 $W$ 的单位是焦耳。问题要求以焦耳为单位，用最简分数表示答案。我们的结果是 $7/6$。",
            "answer": "$$\\boxed{\\frac{7}{6}}$$"
        },
        {
            "introduction": "在获得近似值之后，下一个关键问题是：这个近似值有多精确？本练习将带您从简单的计算进入误差分析的领域，这是严谨数值方法的核心。您将学习如何使用梯形法则的误差界来确定达到所需精度所需的计算量（即子区间数量），从而将理论与实际工程需求联系起来 。",
            "id": "2210520",
            "problem": "在一项药物动力学研究中，患者血液中一种新药的浓度被建模为时间 $t$ 的函数，其方程为 $C(t) = C_0 \\exp(-kt^2)$。此处，$t$ 为注射后的时间（单位：小时），$C_0 = 50$ mg/L 为初始浓度，$k = 0.5 \\text{ hr}^{-2}$ 是一个与药物消除速率相关的常数。\n\n为了评估前两个小时内的总药物暴露量，一位生物医学工程师需要计算曲线下面积 (AUC)，其由定积分 $A = \\int_{0}^{T} C(t) dt$ 给出，其中 $T=2$ 小时。\n\n该工程师采用了一种数值近似方法。时间区间 $[0, T]$ 被分成 $n$ 个相等的子区间，积分值通过对每个子区间上连接点 $(t_i, C(t_i))$ 和 $(t_{i+1}, C(t_{i+1}))$ 所形成的梯形面积求和来近似。\n\n对于此特定的数值方法，已知绝对误差 $|E_n|$ 受以下不等式约束：\n$$|E_n| \\le \\frac{M(T-0)^3}{12n^2}$$\n其中 $M$ 是浓度函数二阶导数的最大绝对值，$M = \\max_{t \\in [0, T]} |C''(t)|$。\n\n确定工程师为保证计算出的 AUC 的绝对误差小于 $10^{-3}$ mg·hr/L，必须使用的最小子区间整数数量 $n$。",
            "solution": "我们已知 $C(t) = C_{0}\\exp(-k t^{2})$，其中 $C_{0} = 50$ 且 $k = 0.5$，以及梯形法则的误差界\n$$|E_{n}| \\le \\frac{M(T-0)^{3}}{12 n^{2}}, \\quad M = \\max_{t \\in [0,T]} |C''(t)|, \\quad T=2.$$\n\n首先计算 $C''(t)$。求导得，\n$$C'(t) = C_{0}\\exp(-k t^{2})(-2 k t),$$\n$$C''(t) = C_{0}\\exp(-k t^{2})\\left(-2k + 4k^{2} t^{2}\\right) = 2k C_{0}\\exp(-k t^{2})\\left(-1 + 2k t^{2}\\right).$$\n因此\n$$|C''(t)| = 2k C_{0}\\exp(-k t^{2})\\left| -1 + 2k t^{2} \\right|.$$\n\n令 $t_{0} = \\frac{1}{\\sqrt{2k}}$。对于 $t \\in [0,t_{0}]$，我们有 $-1 + 2k t^{2} \\le 0$，所以\n$$|C''(t)| = 2k C_{0}\\exp(-k t^{2})\\left(1 - 2k t^{2}\\right).$$\n定义 $h_{1}(t) = 2k C_{0}\\exp(-k t^{2})(1 - 2k t^{2})$。其导数为\n$$h_{1}'(t) = 4 k^{2} C_{0} t \\exp(-k t^{2})\\left(-3 + 2k t^{2}\\right).$$\n在 $(0,t_{0}]$ 上，由于 $t_{0}^{2} = \\frac{1}{2k}$，我们有 $-3 + 2k t^{2} \\le -3 + 1 = -2  0$，因此 $h_{1}'(t)  0$。所以 $h_{1}$ 在 $[0,t_{0}]$ 上是递减的，并在 $t=0$ 处取得其最大值：\n$$h_{1}(0) = 2k C_{0}.$$\n\n对于 $t \\in [t_{0},T]$，我们有 $-1 + 2k t^{2} \\ge 0$，所以\n$$|C''(t)| = 2k C_{0}\\exp(-k t^{2})\\left(-1 + 2k t^{2}\\right).$$\n定义 $h_{2}(t) = 2k C_{0}\\exp(-k t^{2})(-1 + 2k t^{2})$。其导数为\n$$h_{2}'(t) = 4 k^{2} C_{0} t \\exp(-k t^{2})\\left(3 - 2k t^{2}\\right).$$\n在 $[t_{0},T]$ 内的临界点出现在 $t = \\sqrt{\\frac{3}{2k}}$，如果该点位于区间内的话。当 $k = 0.5$ 时，我们有 $t_{0} = 1$，$T=2$，并且 $\\sqrt{\\frac{3}{2k}} = \\sqrt{3} \\in [1,2]$。在候选点处计算 $h_{2}$ 的值：\n- 在 $t = t_{0}$ 处，$h_{2}(t_{0}) = 0$。\n- 在 $t = \\sqrt{\\frac{3}{2k}}$ 处，由于 $2k t^{2} = 3$，\n$$h_{2}\\!\\left(\\sqrt{\\frac{3}{2k}}\\right) = 4k C_{0}\\exp\\!\\left(-\\frac{3}{2}\\right) = 4k C_{0}\\exp\\!\\left(-\\frac{3}{2}\\right).$$\n- 在 $t = T=2$ 处，\n$$h_{2}(2) = 2k C_{0}\\left(-1 + 8k\\right)\\exp(-4k).$$\n\n将这些值与 $2k C_{0}$ 进行比较。注意\n$$4k C_{0}\\exp\\!\\left(-\\frac{3}{2}\\right) = 2k C_{0}\\cdot 2\\exp\\!\\left(-\\frac{3}{2}\\right)  2k C_{0}$$\n因为 $\\exp\\!\\left(\\frac{3}{2}\\right) > 2$，所以 $2\\exp(-\\frac{3}{2})  1$。同样，对于 $k=0.5$，$h_{2}(2)$ 也小于 $2k C_{0}$。因此，在 $[0,2]$ 上的最大值在 $t=0$ 处取得：\n$$M = \\max_{t \\in [0,2]} |C''(t)| = 2k C_{0} = 2 \\cdot 0.5 \\cdot 50 = 50.$$\n\n应用 $T=2$ 的误差界：\n$$|E_{n}| \\le \\frac{M T^{3}}{12 n^{2}} = \\frac{50 \\cdot 2^{3}}{12 n^{2}} = \\frac{100}{3 n^{2}}.$$\n要求 $|E_{n}|  10^{-3}$：\n$$\\frac{100}{3 n^{2}}  10^{-3} \\quad \\Leftrightarrow \\quad n^{2} > \\frac{100}{3 \\cdot 10^{-3}} = \\frac{100000}{3}.$$\n因此 $n > \\sqrt{\\frac{100000}{3}}$。由于 $182^{2} = 33124  \\frac{100000}{3}  33489 = 183^{2}$，满足该不等式的最小整数 $n$ 是\n$$n = 183.$$",
            "answer": "$$\\boxed{183}$$"
        },
        {
            "introduction": "梯形法则的优异性能和高阶收敛性依赖于被积函数的光滑性。本练习将探讨当这一基本假设被破坏时（例如，当函数存在跳跃间断点时）会发生什么。通过对比“朴素”方法和更精细的“分段”策略，您将亲身体验到分析函数特性对于选择正确数值策略的重要性，并理解如何处理这类常见问题以恢复算法的收敛精度 。",
            "id": "3215559",
            "problem": "考虑使用复合梯形法则对一个在已知位置存在不连续点的分段定义函数进行定积分的数值逼近。设区间为 $[a,b]$，其中 $a=0$ 且 $b=1$。在 $[a,b]$上定义函数 $f(x)$ 如下：\n$$\nf(x) = \\begin{cases}\ne^{x},  x  c,\\\\\ne^{x} + 1,  x \\ge c,\n\\end{cases}\n$$\n其中 $c = 0.3$ 是已知的不连续点位置。该积分 $\\int_a^b f(x)\\,dx$ 的精确值为\n$$\n\\int_0^1 e^{x}\\,dx + \\int_c^1 1\\,dx = \\left(e^{1} - e^{0}\\right) + (1 - c).\n$$\n你将使用两种方法来逼近 $\\int_a^b f(x)\\,dx$：\n\n1. 不分割法：在整个区间 $[a,b]$ 上应用复合梯形法则，采用 $N$ 个宽度为 $h = (b-a)/N$ 的均匀子区间的划分，忽略区间内不连续点的存在。\n\n2. 分割法：在 $x=c$ 处分割区间，并分别在 $[a,c]$ 和 $[c,b]$ 上应用复合梯形法则，总共使用 $N$ 个子区间，这些子区间根据子区间的长度按比例分配。具体来说，设置\n$$\nN_1 = \\left\\lfloor N\\cdot \\frac{c-a}{b-a} + \\frac{1}{2} \\right\\rfloor,\\quad N_2 = N - N_1,\n$$\n并使用 $N_1$ 个宽度为 $h_1 = (c-a)/N_1$ 的均匀子区间来逼近 $\\int_a^c e^{x}\\,dx$，以及使用 $N_2$ 个宽度为 $h_2 = (b-c)/N_2$ 的均匀子区间来逼近 $\\int_c^b (e^{x}+1)\\,dx$。然后将这两个逼近值相加，得到分割法的逼近结果。\n\n在你的解答中，从第一性原理出发，论证为什么在光滑子区间上误差的行为像 $O(h^2)$，以及为什么如果不进行分割，单个跨越跳跃不连续点的区间会产生一个 $O(h)$ 的贡献，从而将全局误差降级为 $O(h)$；同时论证为什么在 $x=c$ 处进行分割可以恢复 $O(h^2)$ 的行为。\n\n实现这两种方法，并为以下 $N$ 值的测试组计算绝对误差：\n- $N = 5$ (不连续点与网格点不对齐),\n- $N = 25$ (不连续点与网格点不对齐),\n- $N = 125$ (不连续点与网格点不对齐),\n- $N = 10$ (在不分割法中，不连续点与网格点对齐的边界情况)。\n\n令 $E_u(N)$ 表示使用 $N$ 个子区间的不分割复合梯形法则的绝对误差，令 $E_s(N)$ 表示使用根据上述规则分配的相同总数 $N$ 个子区间的分割复合梯形法则的绝对误差。使用名义步长 $h(N) = (b-a)/N$，通过以下公式估算两对 $N$ 值之间的经验收敛阶：\n$$\np_{u}(N_1\\to N_2) = \\frac{\\log\\left(E_u(N_1)/E_u(N_2)\\right)}{\\log\\left(h(N_1)/h(N_2)\\right)},\\quad\np_{s}(N_1\\to N_2) = \\frac{\\log\\left(E_s(N_1)/E_s(N_2)\\right)}{\\log\\left(h(N_1)/h(N_2)\\right)}.\n$$\n\n你的程序应计算：\n- $E_u(5)$, $E_u(25)$, $E_u(125)$,\n- $E_s(5)$, $E_s(25)$, $E_s(125)$,\n- $p_u(5\\to 25)$, $p_u(25\\to 125)$,\n- $p_s(5\\to 25)$, $p_s(25\\to 125)$,\n- $E_u(10)$, $E_s(10)$.\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个以逗号分隔的列表，用方括号括起来，并严格按照以下顺序排列结果：\n$$\n[ E_u(5), E_u(25), E_u(125), E_s(5), E_s(25), E_s(125), p_u(5\\to 25), p_u(25\\to 125), p_s(5\\to 25), p_s(25\\to 125), E_u(10), E_s(10) ].\n$$\n所有输出均为实数（浮点数），不涉及单位。",
            "solution": "该问题要求分析和实现复合梯形法则，用于逼近一个带有已知有限跳跃不连续点的分段函数的积分。我们需要比较两种方法：一种是在整个定义域上直接应用该法则的朴素方法，另一种是在不连续点处分割定义域的更精细的方法。\n\n首先，我们按要求为复合梯形法则的误差行为建立理论基础。该分析将论证为什么朴素（不分割）方法的收敛阶会降低，而分割方法能恢复预期的高阶收敛。\n\n需要逼近的定积分是 $I = \\int_a^b f(x) \\, dx$，其中区间为 $[a,b] = [0,1]$，函数为\n$$\nf(x) = \\begin{cases}\ne^{x},  x  c,\\\\\ne^{x} + 1,  x \\ge c,\n\\end{cases}\n$$\n不连续点在 $c = 0.3$。该函数的跳跃幅度为 $J = f(c^+) - f(c^-) = (e^c + 1) - e^c = 1$。积分的精确值已给出为 $I_{\\text{exact}} = (e^1 - e^0) + (1 - c)$。\n\n复合梯形法则使用 $N$ 个等宽 $h = (b-a)/N$ 的子区间来逼近 $[a,b]$ 上的积分。其逼近公式为\n$$\nT_N(f) = h \\left( \\frac{1}{2}f(x_0) + \\sum_{i=1}^{N-1} f(x_i) + \\frac{1}{2}f(x_N) \\right)\n$$\n其中 $x_i = a + ih$，$i = 0, 1, \\dots, N$。\n\n我们来分析误差 $E_N(f) = I - T_N(f)$。\n\n**光滑函数的误差分析**\n\n对于一个二阶连续可微的函数 $g(x)$，即 $g \\in C^2([a,b])$，复合梯形法则的误差是众所周知的。在单个子区间 $[x_i, x_{i+1}]$ 上的误差由以下公式给出：\n$$\nE_i = \\int_{x_i}^{x_{i+1}} g(x)\\,dx - \\frac{h}{2}(g(x_i) + g(x_{i+1})) = -\\frac{h^3}{12} g''(\\xi_i)\n$$\n其中某个 $\\xi_i \\in (x_i, x_{i+1})$。总误差是这些局部误差之和：\n$$\nE_N(g) = \\sum_{i=0}^{N-1} E_i = -\\frac{h^3}{12} \\sum_{i=0}^{N-1} g''(\\xi_i)\n$$\n通过对和应用介值定理，存在一个 $\\xi \\in (a,b)$ 使得 $\\sum_{i=0}^{N-1} g''(\\xi_i) = N g''(\\xi)$。将此代入误差公式并使用 $N = (b-a)/h$，我们得到全局误差：\n$$\nE_N(g) = -\\frac{h^3}{12} N g''(\\xi) = -\\frac{h^2(b-a)}{12} g''(\\xi) = O(h^2)\n$$\n这表明，对于足够光滑的函数，复合梯形法则表现出二阶收敛性。\n\n**不分割方法的误差分析**\n\n在不分割方法中，我们直接对 $[0,1]$ 上的 $f(x)$ 应用该法则。然而，$f(x)$ 不在 $C^2([0,1])$ 中，因此上述误差公式不适用于整个区间。误差来自两个来源：$(N-1)$ 个 $f(x)$ 光滑的区间，以及一个包含不连续点 $c$ 的区间，比如说 $[x_k, x_{k+1}]$。\n\n来自 $(N-1)$ 个光滑子区间的误差之和贡献的量级为 $(N-1) \\times O(h^3) \\approx N \\cdot O(h^3) = O(h^2)$。\n关键的贡献来自于 $c \\in (x_k, x_{k+1})$ 的区间 $[x_k, x_{k+1}]$。此区间上的误差为：\n$$\nE_k = \\int_{x_k}^{x_{k+1}} f(x)\\,dx - \\frac{h}{2}(f(x_k) + f(x_{k+1}))\n$$\n积分可以在 $c$ 处分割：\n$$\n\\int_{x_k}^{x_{k+1}} f(x)\\,dx = \\int_{x_k}^{c} e^x\\,dx + \\int_{c}^{x_{k+1}} (e^x+1)\\,dx = \\int_{x_k}^{x_{k+1}} e^x\\,dx + (x_{k+1}-c)\n$$\n区间端点的函数值为 $f(x_k) = e^{x_k}$ (因为 $x_k  c$) 和 $f(x_{k+1}) = e^{x_{k+1}}+1$ (因为 $x_{k+1} > c$)。该单个区间的梯形逼近为：\n$$\nT_k(f) = \\frac{h}{2}(e^{x_k} + e^{x_{k+1}}+1)\n$$\n因此，误差 $E_k$ 为：\n$$\nE_k = \\left( \\int_{x_k}^{x_{k+1}} e^x\\,dx + (x_{k+1}-c) \\right) - \\left( \\frac{h}{2}(e^{x_k} + e^{x_{k+1}}) + \\frac{h}{2} \\right)\n$$\n$$\nE_k = \\underbrace{\\left( \\int_{x_k}^{x_{k+1}} e^x\\,dx - \\frac{h}{2}(e^{x_k} + e^{x_{k+1}}) \\right)}_{\\text{光滑函数 }e^x\\text{ 的误差, } O(h^3)} + \\underbrace{\\left( (x_{k+1}-c) - \\frac{h}{2} \\right)}_{\\text{跳跃导致的误差}}\n$$\n令 $c = x_k + \\theta h$，其中某个 $\\theta \\in (0,1)$。那么 $x_{k+1}-c = x_k+h - (x_k+\\theta h) = (1-\\theta)h$。由跳跃产生的误差项变为 $(1-\\theta)h - h/2 = (1/2-\\theta)h$。这是一个 $O(h)$ 项。\n不分割方法的总误差是来自光滑部分的 $O(h^2)$ 误差与来自包含不连续点的单个区间的 $O(h)$ 误差之和。\n$$\nE_N(f) = O(h^2) + O(h) = O(h)\n$$\n因此，全局收敛阶降至一阶。对于 $c$ 与网格点重合（即 $c=x_k$）的情况，类似的分析也显示出 $O(h)$ 的误差贡献，因为该法则在一个本应积分到 $e^c$ 的区间的一侧使用了 $f(x_k) = e^{x_k}+1$。\n\n**分割方法的误差分析**\n\n分割方法通过在不连续点处分割积分来规避此问题：\n$$\nI = \\int_0^1 f(x)\\,dx = \\int_0^c e^x\\,dx + \\int_c^1 (e^x+1)\\,dx\n$$\n然后我们对每个积分分别应用复合梯形法则。第一个积分涉及函数 $g_1(x) = e^x$ 在 $[0, c]$ 上，第二个积分涉及 $g_2(x) = e^x+1$ 在 $[c, 1]$ 上。$g_1$ 和 $g_2$ 在它们各自的闭合积分区间上都是无穷次可微的。\n\n假设我们对第一个积分使用 $N_1$ 个子区间，对第二个积分使用 $N_2$ 个子区间，且 $N_1+N_2=N$。步长分别为 $h_1 = (c-a)/N_1$ 和 $h_2 = (b-c)/N_2$。\n第一个积分逼近的误差是 $E_1 = O(h_1^2)$。\n第二个积分逼近的误差是 $E_2 = O(h_2^2)$。\n总误差为 $E_s(N) = E_1 + E_2 = O(h_1^2) + O(h_2^2)$。\n\n问题指定将 $N$ 按子区间长度比例分配，使得 $N_1 = \\lfloor N(c-a)/(b-a) + 1/2 \\rfloor$ 且 $N_2 = N-N_1$。这确保了 $N_1 \\approx N(c-a)/(b-a)$ 和 $N_2 \\approx N(b-c)/(b-a)$。\n因此，$h_1 = \\frac{c-a}{N_1} \\approx \\frac{c-a}{N(c-a)/(b-a)} = \\frac{b-a}{N} = h$。\n类似地，$h_2 \\approx h$。因此，总误差为：\n$$\nE_s(N) = O(h^2) + O(h^2) = O(h^2)\n$$\n通过在不连续点处分割积分，我们确保了梯形法则始终只应用于光滑函数，从而恢复了预期的二阶收敛性。\n\n**数值实现**\n\n上述过程将通过计算实现。\n1.  **精确积分**：精确值计算为 $I_{\\text{exact}} = (e - 1) + (1 - 0.3) = e - 0.3$。\n2.  **不分割逼近**：按规定定义函数 $f(x)$，并在 $[0,1]$ 上用 $N$ 个区间应用复合梯形法则。对 $N \\in \\{5, 25, 125, 10\\}$ 计算绝对误差 $E_u(N) = |I_{\\text{approx}} - I_{\\text{exact}}|$。\n3.  **分割逼近**：对于给定的总区间数 $N$，我们计算 $N_1 = \\lfloor 0.3N + 0.5 \\rfloor$ 和 $N_2=N-N_1$。在 $[0, 0.3]$ 上对 $g_1(x)=e^x$ 使用 $N_1$ 个区间应用复合梯形法则，在 $[0.3, 1]$ 上对 $g_2(x)=e^x+1$ 使用 $N_2$ 个区间应用复合梯形法则。将结果相加。对 $N \\in \\{5, 25, 125, 10\\}$ 计算绝对误差 $E_s(N) = |I_{\\text{approx}} - I_{\\text{exact}}|$。\n4.  **经验收敛阶**：使用提供的公式估算收敛率 $p_u$ 和 $p_s$，该公式将误差比与步长比关联起来，用于相继加密的网格。对于 $N$ 的五倍增加，步长比为 $h(N)/h(5N) = 5$，因此公式中的分母为 $\\log(5)$。\n\n以下程序将基于这些原理计算十二个指定的量。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the numerical integration problem for a piecewise function with a discontinuity.\n    \"\"\"\n    # Define problem constants\n    a = 0.0\n    b = 1.0\n    c = 0.3\n\n    # Define the piecewise function f(x)\n    # f(x) = exp(x) for x  c\n    # f(x) = exp(x) + 1 for x >= c\n    def f(x):\n        return np.exp(x) + np.where(x  c, 0, 1)\n\n    # Functions for the split approach\n    def f1(x):\n        return np.exp(x)\n    \n    def f2(x):\n        return np.exp(x) + 1\n\n    # Exact value of the integral\n    # integral(f(x) dx from a to b) = integral(e^x dx from a to c) + integral(e^x+1 dx from c to b)\n    # = (e^c - e^a) + (e^b - e^c + (b-c)) = e^b - e^a + b - c\n    # Given in problem: (e^1 - e^0) + (1-c) = e - 1 + 1 - c = e - c\n    exact_integral = np.exp(1) - c\n\n    def composite_trapezoid(func, start, end, n):\n        \"\"\"\n        Computes the definite integral of a function using the composite trapezoidal rule.\n        \"\"\"\n        if n == 0:\n            return 0.0\n        h = (end - start) / n\n        x = np.linspace(start, end, n + 1)\n        y = func(x)\n        return h * (np.sum(y) - 0.5 * (y[0] + y[-1]))\n\n    # --- Test Cases ---\n    N_values_conv = [5, 25, 125]\n    N_special = 10\n\n    # --- Unsplit Method Calculations ---\n    errors_unsplit = []\n    for N in N_values_conv:\n        approx_unsplit = composite_trapezoid(f, a, b, N)\n        errors_unsplit.append(np.abs(approx_unsplit - exact_integral))\n    \n    Eu5, Eu25, Eu125 = errors_unsplit\n\n    # --- Split Method Calculations ---\n    errors_split = []\n    for N in N_values_conv:\n        n1 = int(np.floor(N * (c - a) / (b - a) + 0.5))\n        n2 = N - n1\n        \n        approx_split_1 = composite_trapezoid(f1, a, c, n1)\n        approx_split_2 = composite_trapezoid(f2, c, b, n2)\n        approx_split = approx_split_1 + approx_split_2\n        \n        errors_split.append(np.abs(approx_split - exact_integral))\n        \n    Es5, Es25, Es125 = errors_split\n\n    # --- Convergence Order Calculations ---\n    # h(N) = (b-a)/N. h(N1)/h(N2) = N2/N1.\n    # For N1=5, N2=25, ratio = 5. For N1=25, N2=125, ratio = 5.\n    log_h_ratio = np.log((b - a) / N_values_conv[0]) - np.log((b-a) / N_values_conv[1])\n    \n    pu_5_25 = (np.log(Eu5 / Eu25)) / log_h_ratio\n    pu_25_125 = (np.log(Eu25 / Eu125)) / log_h_ratio\n    \n    ps_5_25 = (np.log(Es5 / Es25)) / log_h_ratio\n    ps_25_125 = (np.log(Es25 / Es125)) / log_h_ratio\n    \n    # --- Special Case: N = 10 ---\n    # Unsplit\n    approx_unsplit_10 = composite_trapezoid(f, a, b, N_special)\n    Eu10 = np.abs(approx_unsplit_10 - exact_integral)\n\n    # Split\n    n1_10 = int(np.floor(N_special * (c - a) / (b - a) + 0.5))\n    n2_10 = N_special - n1_10\n    approx_split_1_10 = composite_trapezoid(f1, a, c, n1_10)\n    approx_split_2_10 = composite_trapezoid(f2, c, b, n2_10)\n    approx_split_10 = approx_split_1_10 + approx_split_2_10\n    Es10 = np.abs(approx_split_10 - exact_integral)\n\n    # Assemble final results\n    results = [\n        Eu5, Eu25, Eu125,\n        Es5, Es25, Es125,\n        pu_5_25, pu_25_125,\n        ps_5_25, ps_25_125,\n        Eu10, Es10\n    ]\n\n    # Print in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}