{
    "hands_on_practices": [
        {
            "introduction": "在求解大规模科学计算问题时，内存容量往往是决定算法可行性的第一个瓶颈。本练习将引导你进入一个具体的计算场景，量化并比较直接法（$LU$ 分解）和迭代法（GMRES）的内存需求。通过亲手推导基于标准稀疏矩阵存储格式的内存占用表达式，你将深刻理解为何对于巨型线性系统，迭代法常常是唯一可行的选择 。",
            "id": "3118498",
            "problem": "一个稀疏线性系统产生于在结构化网格上对偏微分方程进行均匀离散化，得到一个矩阵 $A \\in \\mathbb{R}^{n \\times n}$，其平均稀疏度为每行 $z$ 个非零元。假设该矩阵以压缩稀疏行（CSR）格式存储，其中每个非零值以双精度（$8$ 字节）存储，每个列索引存储为 $32$ 位整数（$4$ 字节），行指针数组有 $n+1$ 个条目，每个条目为 $32$ 位整数（$4$ 字节）。考虑两种求解策略：\n- 一种使用LU（Lower-Upper）分解的直接法，其中 $L$ 和 $U$ 因子中的非零元总数由填充因子 $f$ 乘以 $A$ 中非零元数量来建模，并且 $L$ 和 $U$ 都以CSR格式存储，其每个条目和每个指针的成本与 $A$ 相同。\n- 一种使用带重启参数 $m$ 的广义最小残差法（GMRES），记为 GMRES($m$) 的迭代法。该方法存储一个由 $(m+1)$ 个长度为 $n$ 的向量组成的Arnoldi基（双精度），一个大小为 $(m+1) \\times m$ 的上Hessenberg矩阵（双精度），以及三个额外的长度为 $n$ 的工作向量（当前迭代解、右端项和残差），均为双精度。假设在GMRES过程中矩阵 $A$ 必须以CSR格式存储。\n\n给定参数 $n = 10^{6}$，$z = 7$，$f = 5$，以及 $3.0 \\times 10^{8}$ 字节的内存上限，使用CSR内存模型：\n1. 推导出一个以 $n$ 和 $z$ 表示的、用于存储矩阵 $A$ 所需的CSR内存（以字节为单位）的表达式。\n2. 推导出一个以 $n$、$z$ 和 $f$ 表示的、用于存储LU因子所需CSR内存（以字节为单位）的表达式。\n3. 推导出一个GMRES($m$)所需的总内存（以字节为单位）的表达式，包括存储矩阵 $A$、Arnoldi基、Hessenberg矩阵和三个工作向量的内存。\n\n然后，确定最大的整数重启参数 $m$，使得GMRES($m$)在内存上限下是可行的，而LU分解是不可行的。只报告 $m$ 的值。无需四舍五入；提供精确的整数值作为最终答案。",
            "solution": "我们将对问题进行验证，如果有效，则按照指定的推导步骤进行求解。\n\n**问题验证**\n\n*   **已知条件提取：**\n    *   矩阵 $A \\in \\mathbb{R}^{n \\times n}$。\n    *   平均稀疏度：每行 $z$ 个非零元。\n    *   存储：压缩稀疏行（CSR）。\n    *   数据类型：值使用双精度（$8$ 字节），索引和指针使用 $32$ 位整数（$4$ 字节）。\n    *   行指针数组大小：$n+1$ 个条目。\n    *   直接法（LU）：填充因子 $f$，因子 $L$ 和 $U$ 以CSR格式存储。\n    *   迭代法（GMRES($m$)）：重启参数 $m$，存储由 $(m+1)$ 个向量组成的Arnoldi基（长度为 $n$，双精度），一个大小为 $(m+1) \\times m$ 的Hessenberg矩阵（双精度），以及 $3$ 个工作向量（长度为 $n$，双精度）。矩阵 $A$ 也需要存储。\n    *   参数：$n = 10^{6}$，$z = 7$，$f = 5$。\n    *   约束：内存上限 $\\le 3.0 \\times 10^{8}$ 字节。\n\n*   **验证结论：**\n    该问题具有科学依据，提法恰当且客观。它基于数值线性代数和计算科学中的标准、可形式化的概念，即CSR存储的内存复杂度、带填充的LU分解以及GMRES算法。所有参数和模型都已明确定义，使得问题自成体系且没有歧义。所提供的值对于大规模科学计算是现实的。因此，该问题被认定为 **有效**。\n\n**求解推导**\n\n求解过程需要为三种不同情况推导内存表达式，然后使用这些表达式找到GMRES允许的最大重启参数 $m$。\n\n**1. 矩阵 $A$ 的CSR格式内存**\n设 $M_A$ 是存储矩阵 $A$ 所需的内存（以字节为单位）。CSR格式包含三个数组：一个用于存储非零值，一个用于存储它们的列索引，另一个用于存储行指针。\n- 行数为 $n$。平均每行有 $z$ 个非零元，所以非零元的总数为 $nnz(A) = nz$。\n- 非零值的内存：$nz$ 个值中的每一个都是双精度，需要 $8$ 字节。总计：$8nz$ 字节。\n- 列索引的内存：$nz$ 个非零元中的每一个都有一个对应的列索引，存储为 $32$ 位整数（$4$ 字节）。总计：$4nz$ 字节。\n- 行指针的内存：该数组有 $n+1$ 个条目，每个是 $32$ 位整数（$4$ 字节）。总计：$4(n+1)$ 字节。\n$A$ 的总内存是这些部分的总和：\n$$M_A(n, z) = 8nz + 4nz + 4(n+1)$$\n$$M_A(n, z) = 12nz + 4n + 4$$\n\n**2. LU因子的CSR格式内存**\n设 $M_{LU}$ 是 $L$ 和 $U$ 因子的内存。问题指出，$L$ 和 $U$ 中非零元的总数是 $A$ 中非零元数量的 $f$ 倍。\n- 因子中的总非零元数：$nnz(L) + nnz(U) = f \\times nnz(A) = fnz$。\n- 我们将因子的存储建模为CSR格式中的单个逻辑实体，具有 $fnz$ 个非零条目和 $n$ 行（需要 $n+1$ 个行指针），这与填充估计的常规做法一致。\n- 非零值的内存：$8(fnz)$ 字节。\n- 列索引的内存：$4(fnz)$ 字节。\n- 行指针的内存：$4(n+1)$ 字节。\nLU因子的总内存是：\n$$M_{LU}(n, z, f) = 8fnz + 4fnz + 4(n+1)$$\n$$M_{LU}(n, z, f) = 12fnz + 4n + 4$$\n\n**3. GMRES($m$)的总内存**\n设 $M_{GMRES}(m)$ 是 GMRES($m$) 算法的总内存。这包括存储矩阵 $A$ 和该算法所需的数据结构。\n- 矩阵 $A$ 的存储：$M_A = 12nz + 4n + 4$。\n- Arnoldi基的存储：该基由 $m+1$ 个向量组成，每个向量长度为 $n$，以双精度存储。内存：$8n(m+1)$ 字节。\n- Hessenberg矩阵的存储：这是一个以双精度存储的稠密 $(m+1) \\times m$ 矩阵。内存：$8m(m+1)$ 字节。\n- 工作向量的存储：三个长度为 $n$ 的双精度向量（当前迭代解、右端项、残差）。内存：$3 \\times 8n = 24n$ 字节。\n总内存是这些部分的总和：\n$$M_{GMRES}(n, z, m) = (12nz + 4n + 4) + 8n(m+1) + 8m(m+1) + 24n$$\n合并各项：\n$$M_{GMRES}(n, z, m) = 12nz + (4n + 8n + 24n) + 8nm + 8m^2 + 8m + 4$$\n$$M_{GMRES}(n, z, m) = 12nz + 36n + 4 + 8nm + 8m^2 + 8m$$\n\n**确定最大整数重启参数 $m$**\n\n给定参数 $n = 10^{6}$，$z = 7$，$f = 5$，以及内存上限 $M_{cap} = 3.0 \\times 10^{8}$ 字节。我们需要找到最大的整数 $m$，使得 $M_{LU} > M_{cap}$ 且 $M_{GMRES}(m) \\le M_{cap}$。\n\n首先，验证LU方法是不可行的：\n$$M_{LU} = 12(5)(10^{6})(7) + 4(10^{6}) + 4$$\n$$M_{LU} = 420 \\times 10^{6} + 4 \\times 10^{6} + 4$$\n$$M_{LU} = 424,000,004 \\text{ 字节}$$\n由于 $424,000,004 > 3.0 \\times 10^{8}$，LU分解方法超过了内存上限，是不可行的。这满足了第一个条件。\n\n接下来，我们为GMRES($m$)建立不等式：\n$$M_{GMRES}(m) \\le 3.0 \\times 10^{8}$$\n$$12(10^{6})(7) + 36(10^{6}) + 4 + 8(10^{6})m + 8m^2 + 8m \\le 300,000,000$$\n$$84,000,000 + 36,000,000 + 4 + 8,000,000m + 8m^2 + 8m \\le 300,000,000$$\n$$120,000,004 + 8,000,008m + 8m^2 \\le 300,000,000$$\n这简化为一个关于 $m$ 的二次不等式：\n$$8m^2 + 8,000,008m - (300,000,000 - 120,000,004) \\le 0$$\n$$8m^2 + 8,000,008m - 179,999,996 \\le 0$$\n对于 $m$ 的预期范围，$8m^2$ 项远小于 $8,000,008m$ 项。我们可以通过检查线性部分来近似求解：\n$$8,000,008m \\approx 179,999,996$$\n$$m \\approx \\frac{179,999,996}{8,000,008} \\approx \\frac{1.8 \\times 10^{8}}{8.0 \\times 10^{6}} = \\frac{180}{8} = 22.5$$\n这表明 $m$ 的最大整数值为 $22$。我们将通过在完整的二次不等式中测试 $m = 22$ 和 $m = 23$ 来验证这一点。\n\n对于 $m = 22$：\n$$8(22)^2 + 8,000,008(22) - 179,999,996$$\n$$8(484) + 176,000,176 - 179,999,996$$\n$$3,872 + 176,000,176 - 179,999,996$$\n$$176,004,048 - 179,999,996 = -3,995,948$$\n由于 $-3,995,948 \\le 0$，所以对于 $m=22$，条件成立。\n\n对于 $m = 23$：\n$$8(23)^2 + 8,000,008(23) - 179,999,996$$\n$$8(529) + 184,000,184 - 179,999,996$$\n$$4,232 + 184,000,184 - 179,999,996$$\n$$184,004,416 - 179,999,996 = 4,004,420$$\n由于 $4,004,420 > 0$，所以对于 $m=23$，条件不成立。\n\n因此，使得GMRES($m$)可行的最大整数重启参数 $m$ 是 $22$。",
            "answer": "$$\\boxed{22}$$"
        },
        {
            "introduction": "理论学习之后，最好的消化方式是动手实践。本练习要求你编写代码，在一个“表现良好”的矩阵家族上直观地比较不同求解器的行为。你将实现一个不带主元选择的 $LU$ 分解，并为经典的雅可比（Jacobi）和高斯-赛德尔（Gauss-Seidel）迭代法计算关键性能指标。通过这个过程，你将把对角占优、增长因子和谱半径等抽象概念与算法的稳定性及收敛性紧密联系起来 。",
            "id": "3118502",
            "problem": "您必须编写一个完整、可运行的程序，该程序构建一组对角占优矩阵，并用它们来比较求解线性系统的直接法和迭代法。直接法是无主元选择的LU分解（Lower-Upper decomposition），迭代法是雅可比（Jacobi）法和高斯-赛德尔（Gauss–Seidel, GS）法。您的程序必须计算明确定义的度量指标，以使这种比较定量化，并且必须按照下面指定的精确格式产生单行输出。\n\n基本基础是线性系统定义和标准矩阵分解。考虑一个方阵 $A \\in \\mathbb{R}^{n \\times n}$ 和一个线性系统 $A x = b$，其中 $x, b \\in \\mathbb{R}^{n}$。对于直接法，将 $A$ 分解为 $A = L U$，其中 $L$ 是单位下三角矩阵，$U$ 是上三角矩阵，此过程不进行任何行交换（主元选择）。对于迭代法，使用标准矩阵分裂 $A = D + L + U$，其中 $D$ 是 $A$ 的对角部分，$L$ 是严格下三角部分，$U$ 是严格上三角部分。雅可比迭代矩阵为 $T_{\\mathrm{J}} = -D^{-1}(L + U)$，高斯-赛德尔迭代矩阵为 $T_{\\mathrm{GS}} = -(D + L)^{-1} U$。对于任意方阵 $M$，其谱半径定义为 $\\rho(M) = \\max_{i} \\lvert \\lambda_{i}(M) \\rvert$，其中 $\\lambda_{i}(M)$ 是 $M$ 的特征值。此处使用的一个基本事实是：一个迭代方法对任意初始向量都收敛，当且仅当其迭代矩阵的谱半径严格小于1，即在范数一致的意义下 $\\rho(M) < 1$。\n\n您将计算以下定量度量指标：\n- LU稳定性的一个代理指标，通过增长因子 $\\gamma = \\dfrac{\\max_{i,j} \\lvert U_{i j} \\rvert}{\\max_{i,j} \\lvert A_{i j} \\rvert}$ 计算，它衡量了在无主元选择的消元过程中矩阵元素是否显著增长。\n- LU重构残差 $r = \\dfrac{\\lVert A - L U \\rVert_{\\mathrm{F}}}{\\lVert A \\rVert_{\\mathrm{F}}}$，其中 $\\lVert \\cdot \\rVert_{\\mathrm{F}}$ 是弗罗贝尼乌斯范数（Frobenius norm），用于量化分解的后向误差。\n- 雅可比谱半径 $\\rho(T_{\\mathrm{J}})$。\n- 高斯-赛德尔谱半径 $\\rho(T_{\\mathrm{GS}})$。\n\n构建以下矩阵 $A$ 的测试套件，选择的矩阵旨在覆盖理想情况、边界条件和边缘情况。所有元素都是实数，维度已明确固定：\n1. 理想情况，严格对角占优，尺寸 $3 \\times 3$：\n   $$A_{1} = \\begin{bmatrix}\n   4  -1  0 \\\\\n   -1  4  -1 \\\\\n   0  -1  3\n   \\end{bmatrix}.$$\n2. 边界条件，弱对角占优（内部行取等号），尺寸 $5 \\times 5$，具有类狄利克雷（Dirichlet-like）内部的三角离散拉普拉斯算子：\n   $$A_{2} = \\begin{bmatrix}\n   2  -1  0  0  0 \\\\\n   -1  2  -1  0  0 \\\\\n   0  -1  2  -1  0 \\\\\n   0  0  -1  2  -1 \\\\\n   0  0  0  -1  2\n   \\end{bmatrix}.$$\n3. 边缘情况，病态但仍为严格对角占优，尺寸 $2 \\times 2$：\n   $$A_{3} = \\begin{bmatrix}\n   1  -0.999 \\\\\n   -0.999  1\n   \\end{bmatrix}.$$\n4. 较大的随机严格对角占优矩阵，尺寸 $6 \\times 6$，按如下方式确定性地构造：设置伪随机数生成器的种子为 $123$。对于每个非对角元素 $(i, j)$（$i \\neq j$），从 $[-0.2, 0.2]$ 的均匀分布中抽取 $A_{4}[i, j]$。然后，对每一行 $i$，设置对角元素\n   $$A_{4}[i, i] = \\sum_{j \\neq i} \\lvert A_{4}[i, j] \\rvert + 0.5,$$\n   以确保行严格对角占优。\n\n对于每个测试矩阵 $A$，您必须：\n- 使用杜利特尔（Doolittle）算法进行无主元选择的LU分解，生成 $L$ 和 $U$，其中 $L$ 的对角线元素为1。\n- 计算上面定义的增长因子 $\\gamma$ 和重构残差 $r$。\n- 根据 $A$ 的分裂形式，构造 $T_{\\mathrm{J}} = -D^{-1}(L + U)$ 和 $T_{\\mathrm{GS}} = -(D + L)^{-1} U$，并计算它们的谱半径 $\\rho(T_{\\mathrm{J}})$ 和 $\\rho(T_{\\mathrm{GS}})$。\n\n您的程序必须生成单行输出，其中包含四个测试矩阵的结果，格式如下：\n- 一个由方括号括起来的逗号分隔列表，其中每个元素对应一个测试矩阵，并且本身是一个包含四个浮点度量指标的列表\n  $$[\\gamma,\\ r,\\ \\rho(T_{\\mathrm{J}}),\\ \\rho(T_{\\mathrm{GS}})]。$$\n- 所有浮点数必须四舍五入到6位小数。\n- 例如，精确的结构是\n  $$[[\\gamma_{1}, r_{1}, \\rho(T_{\\mathrm{J},1}), \\rho(T_{\\mathrm{GS},1})],[\\gamma_{2}, r_{2}, \\rho(T_{\\mathrm{J},2}), \\rho(T_{\\mathrm{GS},2})],[\\gamma_{3}, r_{3}, \\rho(T_{\\mathrm{J},3}), \\rho(T_{\\mathrm{GS},3})],[\\gamma_{4}, r_{4}, \\rho(T_{\\mathrm{J},4}), \\rho(T_{\\mathrm{GS},4})]]。$$\n\n不涉及任何物理单位。如果需要，所有角度都将以弧度为单位，但此处并未使用。所有答案都是浮点数，必须遵守指定的四舍五入和格式要求。\n\n您的程序必须是自包含的，不需要用户输入，并使用指定的库以Python语言编写。它必须明确实现所需的算法，以便结果是可复现和可测试的。",
            "solution": "该问题已经过验证，被认为是有效的。它在科学上基于数值线性代数的原理，问题设定良好（well-posed），具有唯一且可计算的解，并且表述客观。任务是比较求解线性系统 $A x = b$ 的直接法（LU分解）和迭代法（雅可比法、高斯-赛德尔法）。该比较通过为一套四个特殊构造的矩阵计算四个定量度量指标来执行。\n\n解决方案在一个Python程序中实现，该程序为每个矩阵计算这些度量指标。对于每个矩阵 $A \\in \\mathbb{R}^{n \\times n}$，过程如下：\n\n首先，我们按照规定构造四个测试矩阵：\n1.  $A_{1}$：一个 $3 \\times 3$ 的严格对角占优矩阵，代表所有方法的“理想情况”。\n    $$A_{1} = \\begin{bmatrix}\n    4  -1  0 \\\\\n    -1  4  -1 \\\\\n    0  -1  3\n    \\end{bmatrix}$$\n2.  $A_{2}$：一个 $5 \\times 5$ 的矩阵，表示一维离散拉普拉斯算子。它是弱对角占优且不可约的，是收敛性定理的一个边界条件，但已知迭代法在这种情况下是收敛的。\n    $$A_{2} = \\begin{bmatrix}\n    2  -1  0  0  0 \\\\\n    -1  2  -1  0  0 \\\\\n    0  -1  2  -1  0 \\\\\n    0  0  -1  2  -1 \\\\\n    0  0  0  -1  2\n    \\end{bmatrix}$$\n3.  $A_{3}$：一个 $2 \\times 2$ 的矩阵，它是严格对角占优但病态的（接近奇异）。这作为一个边缘案例，用于测试算法的数值稳定性。\n    $$A_{3} = \\begin{bmatrix}\n    1  -0.999 \\\\\n    -0.999  1\n    \\end{bmatrix}$$\n4.  $A_{4}$：一个较大的 $6 \\times 6$ 严格对角占优矩阵，使用固定种子 $123$ 的伪随机数生成器确定性地构造。对于 $i \\neq j$ 的非对角元素 $A_{4}[i, j]$，从 $[-0.2, 0.2]$ 的均匀分布中抽取。然后，对角元素被设置为强制行严格对角占优：$A_{4}[i, i] = \\sum_{j \\neq i} \\lvert A_{4}[i, j] \\rvert + 0.5$。\n\n对于每个矩阵 $A$，我们计算四个度量指标。\n\n前两个度量指标评估直接法，特别是无主元选择的LU分解（$A = LU$），其中 $L$ 是单位下三角矩阵，$U$ 是上三角矩阵。这是使用杜利特尔（Doolittle）算法实现的。对于一个 $n \\times n$ 矩阵 $A$，$L$ 和 $U$ 的元素计算如下：\n$$ U_{kj} = A_{kj} - \\sum_{i=0}^{k-1} L_{ki} U_{ij}, \\quad \\text{for } j=k, \\dots, n-1 $$\n$$ L_{ik} = \\frac{1}{U_{kk}} \\left( A_{ik} - \\sum_{j=0}^{k-1} L_{ij} U_{jk} \\right), \\quad \\text{for } i=k+1, \\dots, n-1 $$\n其中 $L_{kk}=1$。由于所有提供的矩阵都是对角占优的，该算法保证可以执行而不会遇到零主元（$U_{kk} \\neq 0$）。\n\n1.  **增长因子 ($\\gamma$)**：该指标是无主元LU分解稳定性的一个代理。它定义为计算出的上三角矩阵 $U$ 中最大绝对值与原始矩阵 $A$ 中最大绝对值的比率。\n    $$ \\gamma = \\dfrac{\\max_{i,j} \\lvert U_{i j} \\rvert}{\\max_{i,j} \\lvert A_{i j} \\rvert} $$\n    一个小的增长因子（接近1）表明在消元过程中元素没有过度增长，这表明了数值稳定性。对于对角占优矩阵，$\\gamma$ 预计会很小。\n\n2.  **LU重构残差 ($r$)**：该指标通过测量计算出的因子 $L$ 和 $U$ 重构原始矩阵 $A$ 的效果来量化分解的后向误差。它计算为残差矩阵 $A - LU$ 的弗罗贝尼乌斯范数与 $A$ 的弗罗贝尼乌斯范数的比率。\n    $$ r = \\dfrac{\\lVert A - L U \\rVert_{\\mathrm{F}}}{\\lVert A \\rVert_{\\mathrm{F}}} $$\n    一个接近机器精度的 $r$ 值表示分解非常精确。\n\n接下来的两个度量指标评估迭代法的收敛特性。雅可比法和高斯-赛德尔法基于将矩阵 $A$ 分裂为其对角部分（$D$）、严格下三角部分（$L_A$）和严格上三角部分（$U_A$），即 $A = D + L_A + U_A$。\n\n3.  **雅可比谱半径 ($\\rho(T_{\\mathrm{J}})$)**：雅可比迭代矩阵为 $T_{\\mathrm{J}} = -D^{-1}(L_A + U_A)$。迭代法收敛的充要条件是其谱半径 $\\rho(T_{\\mathrm{J}}) = \\max_{i} \\lvert \\lambda_{i}(T_{\\mathrm{J}}) \\rvert$ 小于1。$\\rho(T_{\\mathrm{J}})$ 的值决定了渐近收敛速度。\n\n4.  **高斯-赛德尔谱半径 ($\\rho(T_{\\mathrm{GS}})$)**：高斯-赛德尔迭代矩阵为 $T_{\\mathrm{GS}} = -(D + L_A)^{-1} U_A$。与雅可比法类似，收敛的充要条件是其谱半径 $\\rho(T_{\\mathrm{GS}})$ 小于1。对于所考虑的这类矩阵（对称正定矩阵，包括 $A_1$、$A_2$、$A_3$，或更一般地，不可约对角占优矩阵），高斯-赛德尔法预计比雅可比法收敛得更快，即 $\\rho(T_{\\mathrm{GS}})  \\rho(T_{\\mathrm{J}})$。\n\n程序系统地对四个测试矩阵中的每一个进行这些计算，整理结果，并按照规定将它们格式化为单行字符串，每个浮点数四舍五入到6位小数。",
            "answer": "```python\nimport numpy as np\n\ndef doolittle_lu(A):\n    \"\"\"\n    Performs LU decomposition of a square matrix A using the Doolittle algorithm\n    without pivoting. A = LU, where L is unit lower triangular.\n    \n    Args:\n        A (np.ndarray): The square matrix to decompose.\n    \n    Returns:\n        (np.ndarray, np.ndarray): The lower (L) and upper (U) triangular matrices.\n    \"\"\"\n    n = A.shape[0]\n    L = np.eye(n)\n    U = np.zeros((n, n))\n\n    for k in range(n):\n        # Vectorized calculation for the k-th row of U\n        U[k, k:] = A[k, k:] - L[k, :k] @ U[:k, k:]\n\n        if U[k, k] == 0:\n            # This should not occur for the given problem matrices\n            # as they are diagonally dominant.\n            raise ValueError(\"Zero pivot encountered.\")\n\n        # Vectorized calculation for the k-th column of L\n        if k + 1  n:\n            L[k+1:, k] = (A[k+1:, k] - L[k+1:, :k] @ U[:k, k]) / U[k, k]\n\n    return L, U\n\ndef compute_metrics(A):\n    \"\"\"\n    Computes the four specified metrics for a given matrix A.\n    \n    Args:\n        A (np.ndarray): The input square matrix.\n    \n    Returns:\n        list: A list containing [gamma, r, rho_J, rho_GS].\n    \"\"\"\n    # 1. Perform LU decomposition\n    L_lu, U_lu = doolittle_lu(A)\n\n    # 2. Compute growth factor (gamma)\n    max_abs_A = np.max(np.abs(A))\n    if max_abs_A == 0:\n        gamma = np.inf if np.max(np.abs(U_lu))  0 else 0.0\n    else:\n        gamma = np.max(np.abs(U_lu)) / max_abs_A\n\n    # 3. Compute reconstruction residual (r)\n    norm_A = np.linalg.norm(A, 'fro')\n    if norm_A == 0:\n        r = 0.0\n    else:\n        r = np.linalg.norm(A - L_lu @ U_lu, 'fro') / norm_A\n\n    # 4. Split A for iterative methods\n    D = np.diag(np.diag(A))\n    L_split = np.tril(A, k=-1)\n    U_split = np.triu(A, k=1)\n\n    # 5. Compute Jacobi spectral radius (rho_J)\n    D_inv = np.linalg.inv(D)\n    T_J = -D_inv @ (L_split + U_split)\n    rho_J = np.max(np.abs(np.linalg.eigvals(T_J)))\n\n    # 6. Compute Gauss-Seidel spectral radius (rho_GS)\n    D_plus_L_inv = np.linalg.inv(D + L_split)\n    T_GS = -D_plus_L_inv @ U_split\n    rho_GS = np.max(np.abs(np.linalg.eigvals(T_GS)))\n\n    return [gamma, r, rho_J, rho_GS]\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, compute metrics, and print results.\n    \"\"\"\n    # Test case 1: Happy path, strictly diagonally dominant\n    A1 = np.array([\n        [4., -1., 0.],\n        [-1., 4., -1.],\n        [0., -1., 3.]\n    ])\n\n    # Test case 2: Boundary condition, weak diagonal dominance\n    A2 = np.array([\n        [2., -1., 0., 0., 0.],\n        [-1., 2., -1., 0., 0.],\n        [0., -1., 2., -1., 0.],\n        [0., 0., -1., 2., -1.],\n        [0., 0., 0., -1., 2.]\n    ])\n\n    # Test case 3: Edge case, ill-conditioned but strictly diagonally dominant\n    A3 = np.array([\n        [1., -0.999],\n        [-0.999, 1.]\n    ])\n\n    # Test case 4: Larger random strictly diagonally dominant matrix\n    n4 = 6\n    rng = np.random.default_rng(123)\n    A4 = rng.uniform(low=-0.2, high=0.2, size=(n4, n4))\n    for i in range(n4):\n        # Set diagonal to ensure strict row diagonal dominance\n        row_sum_abs = np.sum(np.abs(A4[i, :])) - np.abs(A4[i, i])\n        A4[i, i] = row_sum_abs + 0.5\n\n    test_cases = [A1, A2, A3, A4]\n    \n    all_results = []\n    for case in test_cases:\n        metrics = compute_metrics(case)\n        all_results.append(metrics)\n\n    # Format the final output string\n    formatted_case_results = []\n    for metrics in all_results:\n        rounded_metrics = [f\"{val:.6f}\" for val in metrics]\n        formatted_case_results.append(f\"[{','.join(rounded_metrics)}]\")\n    \n    final_output_string = f\"[{','.join(formatted_case_results)}]\"\n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "现在，让我们探讨一个更深层次的话题：稀疏矩阵的内部结构——即非零元素（nonzero）的分布模式——如何决定最佳的求解策略。本练习将通过构造具有对称和非对称模式的矩阵，让你研究 $LU$ 分解中的“填充”（fill-in）现象，并理解为何像共轭梯度（Conjugate Gradient）法这样高效的迭代求解器有其严格的适用前提。这个实践将揭示问题结构与算法效率之间的关键联系 。",
            "id": "3118467",
            "problem": "您的任务是构建和分析稀疏矩阵，以检验非零模式的对称性如何影响下三角-上三角（LU）分解中的填充（fill-in）以及共轭梯度（CG）迭代方法的适用性。其数学基础是线性系统定义 $A x = b$、高斯消元法引出的LU分解概念，以及共轭梯度（CG）方法要求矩阵为对称正定（SPD）矩阵。\n\n定义与核心事实：\n- 一个线性系统由一个方阵 $A \\in \\mathbb{R}^{N \\times N}$ 和一个向量 $b \\in \\mathbb{R}^{N}$ 指定，旨在求解满足 $A x = b$ 的向量 $x \\in \\mathbb{R}^{N}$。\n- LU分解将矩阵 $A$（可能经过行和列的置换后）表示为 $A = L U$ 的形式，其中 $L$ 是下三角矩阵，$U$ 是上三角矩阵。高斯消元会引入新的非零元，这一现象称为填充（fill-in）。填充元的数量可以通过 $L$ 和 $U$ 中的总非零元数量与 $A$ 中原始非零元数量之差来量化。\n- 共轭梯度（CG）方法是为对称正定（SPD）矩阵定义的。如果 $A^{\\mathsf{T}} = A$ 且对于所有非零向量 $x$，都有 $x^{\\mathsf{T}} A x  0$，则矩阵 $A$ 是对称正定的。\n- 非零模式对称性指的是，无论数值大小，$A$ 的支撑集（非零元索引的集合）是否与 $A^{\\mathsf{T}}$ 的支撑集相等。\n\n您的程序必须构建三个测试矩阵，并为每个矩阵计算四个量：非零模式是否对称、自然列序下LU分解的填充计数、填充减少列序下LU分解的填充计数，以及CG方法是否适用（即矩阵是否为SPD）。所有数学量必须按照下文规定处理，最终输出必须是符合要求格式的单行文本。\n\n矩阵构建与测试套件：\n- 测试用例 $1$（对称正定基准）：设 $n = 6$，则 $N = n^2 = 36$。将 $n \\times n$ 网格上的二维离散拉普拉斯算子（带狄利克雷边界条件）定义为\n$$\nT_1 = \\mathrm{diags}\\left(\\{-\\mathbf{1}_{n-1},\\ 2\\mathbf{1}_{n},\\ -\\mathbf{1}_{n-1}\\},\\ \\{-1, 0, 1\\}\\right),\n$$\n$$\nI_n = \\mathrm{eye}(n),\n$$\n$$\nA_1 = \\mathrm{kron}(I_n, T_1) + \\mathrm{kron}(T_1, I_n).\n$$\n此矩阵 $A_1 \\in \\mathbb{R}^{N \\times N}$ 是对称正定的，并具有对称的非零模式。\n- 测试用例 $2$（非对称极端模式）：设 $N = 36$。定义\n$$\nI_N = \\mathrm{eye}(N),\n$$\n$$\nS = \\mathrm{diags}\\left(\\{\\mathbf{1}_{N-1}\\},\\ \\{1\\}\\right),\n$$\n$$\nR = \\text{第一行全为1的稀疏矩阵},\n$$\n$$\nC = \\text{最后一列全为1的稀疏矩阵}。\n$$\n设置\n$$\nA_2 = I_N + S + R + C.\n$$\n此矩阵 $A_2 \\in \\mathbb{R}^{N \\times N}$ 被设计为在其非零模式上具有强非对称性，且条件良好，足以进行LU分解。\n- 测试用例 $3$（对称不定）：使用上面的 $A_1$，令\n$$\nA_3 = A_1 - 10 I_N,\n$$\n这保留了对称的非零模式，但破坏了正定性。\n\n对于每个矩阵 $A_k$（其中 $k \\in \\{1,2,3\\}$），执行以下计算：\n- 非零模式对称性布尔值：判断 $A_k$ 的支撑集是否等于 $A_k^{\\mathsf{T}}$ 的支撑集（即对于每个满足 $A_k(i,j) \\neq 0$ 的索引对 $(i,j)$，都有 $A_k(j,i) \\neq 0$）。\n- 自然列序下LU分解的填充计数：使用自然列序计算 $A_k$ 的LU分解，然后计算整数\n$$\n\\mathrm{fill\\_nat}(A_k) = \\mathrm{nnz}(L) + \\mathrm{nnz}(U) - \\mathrm{nnz}(A_k),\n$$\n其中 $\\mathrm{nnz}(\\cdot)$ 表示非零元的数量。您应使用数值库中带有自然列序的标准稀疏LU分解来获得 $L$ 和 $U$。\n- 填充减少列序下LU分解的填充计数：使用填充减少列序（如列近似最小度排序COLAMD）重复计算，以获得\n$$\n\\mathrm{fill\\_colamd}(A_k) = \\mathrm{nnz}(L) + \\mathrm{nnz}(U) - \\mathrm{nnz}(A_k).\n$$\n- CG适用性布尔值：通过检查对称性并尝试通过Cholesky分解测试来验证正定性，以确定 $A_k$ 是否适用于共轭梯度法。当且仅当 $A_k$ 是对称且正定的时，报告为真。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。按以下顺序汇总所有三个测试用例的结果：\n$$\n[\\ \\mathrm{pat\\_sym}(A_1),\\ \\mathrm{fill\\_nat}(A_1),\\ \\mathrm{fill\\_colamd}(A_1),\\ \\mathrm{cg\\_app}(A_1),\\ \\mathrm{pat\\_sym}(A_2),\\ \\mathrm{fill\\_nat}(A_2),\\ \\mathrm{fill\\_colamd}(A_2),\\ \\mathrm{cg\\_app}(A_2),\\ \\mathrm{pat\\_sym}(A_3),\\ \\mathrm{fill\\_nat}(A_3),\\ \\mathrm{fill\\_colamd}(A_3),\\ \\mathrm{cg\\_app}(A_3)\\ ].\n$$\n此处 $\\mathrm{pat\\_sym}(A_k)$ 和 $\\mathrm{cg\\_app}(A_k)$ 是布尔值，$\\mathrm{fill\\_nat}(A_k)$ 和 $\\mathrm{fill\\_colamd}(A_k)$ 是整数。本问题不涉及物理单位。您的程序必须是自包含的，不需要任何输入，并精确生成此单行输出。",
            "solution": "我们从线性系统 $A x = b$ 的基本定义开始，其中 $A \\in \\mathbb{R}^{N \\times N}$。直接法，特别是高斯消元法，会得到一个下三角-上三角（LU）分解 $A = L U$（在置换意义下），其中 $L$ 是下三角矩阵，$U$ 是上三角矩阵。在消元过程中，即使 $A$ 是稀疏的，也可能产生新的非零元；这种现象称为填充（fill-in）。填充量可以通过计算分解因子中非零元相对于原始矩阵的增量来衡量。形式上，对于一个固定的排序，填充计数为 $\\mathrm{nnz}(L) + \\mathrm{nnz}(U) - \\mathrm{nnz}(A)$，其中 $\\mathrm{nnz}(\\cdot)$ 表示非零元的数量。\n\n迭代法以不同的方式逼近解。特别是，共轭梯度（CG）方法要求系数矩阵是对称正定（SPD）的。SPD的条件是 $A^{\\mathsf{T}} = A$（对称性）和对于所有非零 $x \\in \\mathbb{R}^{N}$ 都有 $x^{\\mathsf{T}} A x  0$（正定性）。一个等价的、用于检验正定性的实用方法是判断是否存在Cholesky分解 $A = R^{\\mathsf{T}} R$（其中 $R$ 是上三角矩阵），该分解当且仅当 $A$ 是SPD时才能成功。\n\n非零模式对称性对填充的影响可以通过消元图来解释。$A$ 的稀疏模式定义了一个在索引 $\\{1,\\dots,N\\}$ 上的图，其边表示非对角线上的非零元。高斯消元对应于消除顶点，这会在其邻居之间引入新的边（即填充）。对称模式通常允许更平衡的图结构，而填充减少排序（如列近似最小度排序COLAMD）利用这种结构来最小化消元过程中的度增长，从而减少填充。相比之下，强非对称模式，特别是那些具有形成星形或箭头形结构的密集行或列的模式，可能导致更大量的填充，因为消元过程会密集地连接许多节点。\n\n与原理相结合的算法设计：\n- 使用克罗内克和，在带有狄利克雷边界的 $n \\times n$ 网格上构建二维离散拉普拉斯算子作为 $A_1$。设 $n = 6$，因此 $N = n^2 = 36$。一维拉普拉斯算子 $T_1 = \\mathrm{diags}(\\{-\\mathbf{1}_{n-1}, 2\\mathbf{1}_{n}, -\\mathbf{1}_{n-1}\\}, \\{-1, 0, 1\\})$ 是对称且严格对角占优的，克罗内克和 $A_1 = \\mathrm{kron}(I_n, T_1) + \\mathrm{kron}(T_1, I_n)$ 是对称正定（SPD）的，并具有对称的非零模式。根据SPD性质，$A_1$ 允许进行Cholesky分解，因此CG方法适用。对于填充，我们使用两种列排序的稀疏LU分解：自然排序和填充减少排序（COLAMD），以量化差异。\n- 构建一个具有显著非对称模式的矩阵 $A_2$：$A_2 = I_N + S + R + C$，其中 $I_N$ 是单位矩阵，$S$ 是上对角线，$R$ 是一个密集的第一行，$C$ 是一个密集的最后一列。单位矩阵确保了非奇异性。模式对称性检查比较了 $A_2$ 和 $A_2^{\\mathsf{T}}$ 的支撑集；密集的第一行和最后一列破坏了支撑集的对称性。CG方法不适用，因为模式不对称，且矩阵不是SPD。在非对称的星形结构中，LU填充往往更大，因为消元会产生许多新的耦合；我们再次在自然排序和COLAMD排序下测量填充。\n- 构建 $A_3 = A_1 - 10 I_N$。这保留了对称的非零模式，但破坏了正定性，因为减去一个足够大的单位矩阵倍数会将所有特征值向左移动，使它们变为负值（因为对于此尺寸，$A_1$ 具有有界的正特征值）。Cholesky测试失败，因此CG方法不适用。LU填充由模式和排序驱动，而不是值的符号；因此，对于固定的排序，$A_3$ 表现出与 $A_1$ 相似的填充，可能由于主元选择策略而存在微小差异。\n\n与上述内容一致的实现细节：\n- 模式对称性通过比较 $A$ 的非零索引集（支撑集）与 $A^{\\mathsf{T}}$ 的非零索引集来测试；相等则表示对称。\n- 填充计数使用提供 $L$ 和 $U$ 的稀疏LU例程计算。我们针对自然列序和COLAMD列序计算 $\\mathrm{nnz}(L) + \\mathrm{nnz}(U) - \\mathrm{nnz}(A)$。为了数值稳定性，内部允许行主元选择，这是实际直接法的一部分。\n- CG适用性通过两个检查来确定：(i) 通过 $A \\stackrel{?}{=} A^{\\mathsf{T}}$ 检查对称性，以及 (ii) 通过尝试进行稠密Cholesky分解来检查正定性；成功则意味着SPD。\n\n测试套件和输出：\n- 测试用例 $1$ 使用 $N = 36$ 的SPD拉普拉斯矩阵 $A_1$。\n- 测试用例 $2$ 使用 $N = 36$ 的非对称箭头/星形矩阵 $A_2$。\n- 测试用例 $3$ 使用 $N = 36$ 的对称不定矩阵 $A_3 = A_1 - 10 I_N$。\n对于每个 $A_k$，程序输出布尔值 $\\mathrm{pat\\_sym}(A_k)$ 和 $\\mathrm{cg\\_app}(A_k)$，以及整数 $\\mathrm{fill\\_nat}(A_k)$ 和 $\\mathrm{fill\\_colamd}(A_k)$。所有十二个结果都按照问题陈述中指定的精确顺序，打印在方括号内的单个逗号分隔列表中。\n\n这个设计直接反映了非零模式对称性与直接法和迭代法行为之间的相互作用：对称模式使得有效的填充减少排序成为可能，并在SPD条件成立时允许使用CG方法，而非对称模式通常会导致更大的填充并使CG方法失效。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import diags, eye, kron, csr_matrix, coo_matrix, csc_matrix\nfrom scipy.sparse.linalg import splu\n\ndef build_laplacian_2d(n: int) - csr_matrix:\n    \"\"\"\n    Build the 2D discrete Laplacian (Dirichlet) on an n x n grid using Kronecker sums.\n    Resulting matrix is SPD and has symmetric sparsity pattern.\n    \"\"\"\n    # 1D Laplacian: tridiagonal with [ -1, 2, -1 ]\n    main = 2.0 * np.ones(n)\n    off = -1.0 * np.ones(n - 1)\n    T1 = diags([off, main, off], offsets=[-1, 0, 1], shape=(n, n), format=\"csr\")\n    In = eye(n, format=\"csr\")\n    A = kron(In, T1, format=\"csr\") + kron(T1, In, format=\"csr\")\n    return A\n\ndef build_nonsymmetric_arrow(N: int) - csr_matrix:\n    \"\"\"\n    Build a sparse matrix with a strongly nonsymmetric pattern:\n    Identity + superdiagonal + dense first row + dense last column.\n    \"\"\"\n    A = eye(N, format=\"csr\")\n    # Superdiagonal ones\n    A += diags([np.ones(N - 1)], offsets=[1], shape=(N, N), format=\"csr\")\n    # Dense first row of ones\n    row0 = np.zeros(N, dtype=int)\n    cols = np.arange(N, dtype=int)\n    data = np.ones(N)\n    R = csr_matrix((data, (row0, cols)), shape=(N, N))\n    A += R\n    # Dense last column of ones\n    rows = np.arange(N, dtype=int)\n    col_last = np.full(N, N - 1, dtype=int)\n    C = csr_matrix((np.ones(N), (rows, col_last)), shape=(N, N))\n    A += C\n    return A\n\ndef is_pattern_symmetric(A: csr_matrix) - bool:\n    \"\"\"\n    Check whether the sparsity pattern of A equals that of A^T.\n    \"\"\"\n    cooA = A.tocoo()\n    coordsA = set(zip(cooA.row.tolist(), cooA.col.tolist()))\n    cooAT = A.T.tocoo()\n    coordsAT = set(zip(cooAT.row.tolist(), cooAT.col.tolist()))\n    return coordsA == coordsAT\n\ndef fill_in_count(A: csr_matrix, permc_spec: str) - int:\n    \"\"\"\n    Compute fill-in count for sparse LU: nnz(L) + nnz(U) - nnz(A),\n    using specified column permutation strategy (permc_spec).\n    \"\"\"\n    # Convert to CSC for splu\n    Acsc = A.tocsc()\n    lu = splu(Acsc, permc_spec=permc_spec)\n    L = lu.L\n    U = lu.U\n    return L.nnz + U.nnz - A.nnz\n\ndef cg_applicable(A: csr_matrix) - bool:\n    \"\"\"\n    Determine CG applicability: True iff A is symmetric and positive definite.\n    We test symmetry and attempt dense Cholesky.\n    \"\"\"\n    dense = A.toarray()\n    if not np.allclose(dense, dense.T, atol=1e-12):\n        return False\n    try:\n        np.linalg.cholesky(dense)\n        return True\n    except np.linalg.LinAlgError:\n        return False\n\ndef solve():\n    # Define test cases: three matrices as specified in the problem statement.\n    n = 6\n    N = n * n\n\n    # Test Case 1: SPD Laplacian\n    A1 = build_laplacian_2d(n)\n\n    # Test Case 2: Nonsymmetric arrow/star\n    A2 = build_nonsymmetric_arrow(N)\n\n    # Test Case 3: Symmetric indefinite (shifted Laplacian)\n    A3 = A1 - 10.0 * eye(N, format=\"csr\")\n\n    test_cases = [A1, A2, A3]\n\n    results = []\n    for A in test_cases:\n        # Pattern symmetry boolean\n        pat_sym = is_pattern_symmetric(A)\n        # Fill-in with natural ordering\n        fill_nat = fill_in_count(A, permc_spec=\"NATURAL\")\n        # Fill-in with COLAMD ordering\n        fill_colamd = fill_in_count(A, permc_spec=\"COLAMD\")\n        # CG applicability boolean\n        cg_app = cg_applicable(A)\n        # Append in required order per test case\n        results.extend([pat_sym, fill_nat, fill_colamd, cg_app])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}